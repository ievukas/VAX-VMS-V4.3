	.TITLE	SYSGETSYI - GET SYSTEM INFORMATION SYSTEM SERVICE
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: VMS Executive, System services.
;
; ABSTRACT:
;
;	Return processor information to caller, specifically
;	processor ID register, processor type, and VMS version number.
;
; ENVIRONMENT: Kernel Mode
;
; AUTHOR: John A. Ywoskus,	 CREATION DATE: 06-August-1981
;
; MODIFIED BY:
;
;	V03-026	CWH3026		CW Hobbs		23-Jul-1984
;		Treat the QUANTUM item as special, since it is
;		stored as a negative number.
;
;	V03-025	MSH0059		Michael S. Harvey	3-Jul-1984
;		Treat a specified CSID argument of zero as if the argument
;		hadn't been specified at all. In either case, there is no
;		CSID value specified and the behavior of GETSYI should be
;		the same for both.
;
;	V03-024	MSH0021		Michael S. Harvey	9-Mar-1984
;		Allow access to SYI items stashed away in the local SB,
;		regardless of whether we're in a cluster or not.
;
;	V03-023	MSH0013		Michael S. Harvey	2-Mar-1984
;		Correctly extract node name length so as not to clobber
;		P1 space and crash the system.
;
;	V03-022	WMC0003		Wayne Cardoza		9-Feb-1984
;		Add $ARCDEF.
;
;	V03-021	WMC0002		Wayne Cardoza		29-Jan-1984
;		Add F and G floating flags.
;
;	V03-020	KPL0001		Peter Lieberwirth	15-Jan-1984
;		Fix typo in V03-019.
;
;	V03-019	WMC0001		Wayne Cardoza		07-Jan-1984
;		Add page and swap file sizes.
;
;	V03-018	TCM0001		Trudy C. Matthews	28-Dec-1983
;		In EXE$NAMCSID, do not access node name passed by caller
;		after raising IPL (it may be pagable).  Make QUORUM a
;		special parameter; it is stored as a negative value but should
;		be displayed as a positive one.
;
;	V03-017	KFH0011		Ken Henderson		30 Aug 1983
;		Fix resetting of IPL on error path.
;		Add documentation of how
;		itemcodes are added.
;
;	V03-016	KFH0010		Ken Henderson		23 Aug 1983
;		Fix checking of item code validity.
;		Update max structure code.
;
;	V03-015	KFH0009		Ken Henderson		18 Aug 1983
;		Made SCS_EXISTS special and boolean.
;
;	V03-014	KFH0008		Ken Henderson		28 Jul 1983
;		Finished support for 'retired' item-codes.
;		Took out call to SCS$CONFIG_SYS.
;
;	V03-013	KFH0007		Ken Henderson		12 Jul 1983
;		Added temporary additional check for
;		clusterness.
;
;	V03-012	KFH0006		Ken Henderson		26 May 1983
;		Changed EXE$NAMCSID entry point to
;		be non-Global.
;
;	V03-011	KFH0005		Ken Henderson		25 May 1983
;		Updated code to use IFCLSTR and IFNOCLSTR.
;
;	V03-010	KFH0004		Ken Henderson		21 May 1983
;		Added support for wild-carding through
;		nodes. Added NAMCSID and EXE$NAMCSID routines.
;		Cleaned up usage of LOCAL_SPACE on stack.
;
;	V03-009	KFH0003		Ken Henderson		11 Mar 1983
;		Added .WARN if item-code is undefined.
;
;	V03-008	KFH0002		Ken Henderson		25 Feb 1983
;		Added definition of GETSYISW.
;
;	V03-007	KFH0001		Ken Henderson		16 Feb 1983
;		Major rewrite of EXE$GETSYI and related
;		routines to make it table-driven like GETJPI,
;		and allow for SYSBOOT parameters and other
;		enhancements.
;
;	V03-006	MSH0001		Maryann Hinden		23-Mar-1982
;		Fix broken BSBW.
;
;	V03-005	JAY0006		John A. Ywoskus		17-Mar-1982
;		Change SS$_EXQUOTA return error to SS$_EXASTLM.
;
;	V03-004 JAY0005		John A. Ywoskus		21-Jan-1982
;		Return 8 bytes for system version instead of 4.
;		General cleanup.
;
;	V02-003	LJK0082		Lawrence J. Kenah	11-Nov-1981
;		Write accessibility of multiple page buffer can
;		now be done on global routine. 
;
;	V03-002 JAY0004		John A. Ywoskus		05-Oct-1981
;		Add null arguments so call list is compatable with
;		$GETJPI. Also, make external references be 
;		addressed with G^, and include VA and PSL defs.
;
;	V03-001	JAY0003		John A. Ywoskus		08-Sep-1981
;		Fix null item bug, make return length optional.
;--
;

;		GUIDE TO GETJPI/GETSYI/GETDVI
;		-----------------------------
;
;Overview
;--------
;
;These three system services are table-driven. The macro definition files
;that help define their tables are shared with DCL and the RTL. This results
;in new item-codes becoming useable with DCL's F$GETXXI lexical functions and
;the RTL's LIB$GETXXI routines automatically. Additionally, new SYSBOOT
;parameters become item-codes to the GETSYIs.
;
;The macro definition files are called JPITABLE.MAR, SYITABLE.MAR, and
;DVITABLE.MAR, and live in MASD$:<VMSLIB.SRC>. During a systembuild, they
;are inserted into the library SYS$LIBRARY:SYSBLDMLB.MLB. DCL and the RTL
;and SYS use this library to define their GETXXI tables. The system
;parameter file <SYS.SRC>SYSPARAM.MAR has also been conditionalized to be
;used to define GETSYI item-codes and is also inserted into SYSBLDMLB.MLB.
;
;
;NOTE:	SYSBLDMLB.MLB is a general macro library for holding macro
;	definitions that are shared between facilities, but will not
;	ship to the customer.
;
;
;When adding an item-code, at least two files need to be edited. One of the
;macro files listed above, as well as an SDL file that defines the 16-bit
;number which is the user-visible item-code. Also, if a SYSBOOT parameter is
;added, an SDL file needs to be updated to define the new GETSYI item-code.
;
;The GETDVI service actually uses only one table, but the GETSYI and GETJPI
;services use several. The JPITABLE file defines all the tables for GETJPI
;and the SYITABLE file defines all the tables for GETSYI. The different
;tables group the pieces of data according to method of retrieval.
;
;In some cases, the piece of data to be returned by the service requires
;special processing to fetch, calculate, or format it before returning it.
;In these cases, the code of the system service needs to be enhanced.
;If the data returned is a new format for DCL, the lexical function
;module of DCL may need to be enhanced. This is also true for the RTL code.

;The Macros
;----------
;
;A two-level scheme exists for defining the item tables used by the three
;services and the other facilities. A commonly defined macro (called
;JPI_GENERATE_TABLE, SYI_GENERATE_TABLE, or DVI_GENERATE_TABLE) contains
;multiple calls to a lower-level macro (called JPI_ITEM_CODE, SYI_ITEM_CODE,
;or DVI_ITEM_CODE) which actually defines each element in the table.
;While the _GENERATE_TABLE macros are commonly defined, the _ITEM_CODE macros
;are individually defined according to the needs of facility. (For instance,
;the LEXICON module must store the name of the item as an ASCIC string - in
;order to match it with the string supplied in the F$GETXXI function call;
;the other facilities need not store the item name in text.)
;
;When an item-code must be added, an additional call to the _ITEM_CODE macro
;must be added to the appropriate _GENERATE_TABLE macro. In the case of GETJPI
;and GETDVI, the _GENERATE_TABLE macro is defined in the JPITABLE and DVITABLE
;modules. The SYI_GENERATE_TABLE macro is defined by the SYSPARAM module
;- all the calls to the PARAMETER and PQL macros are 'collected' into the
;SYI_GENERATE_TABLE macro. When used in that mode (when GETSYISW is defined),
;the SYI_ITEMTABLES macro also becomes part of the SYI_GENERATE_TABLE macro.
;SYI_ITEMTABLES is defined in the SYITABLE module and contains all the calls
;to the SYI_ITEM_CODE macro that are Not related to SYSBOOT parameters.
;When GETSYISW is defined in SYSPARAM, the PARAMETER macro does not allocate
;or store memory, but rather passes some of the arguments to it on through via
;a call to SYI_ITEM_CODE. That is how all the calls to PARAMETER become calls
;to SYI_ITEM_CODE.
;
;The following is the situation that exists when the symbol GETSYISW is defined.
;The non-SYSBOOT items are defined by the macro SYI_ITEMTABLES in SYITABLE.MAR.
;The SYSBOOT items are defined by each invokation of the PARAMETER macro in
;SYSPARAM.MAR. Note that each invokation of the PQL macro in SYSPARAM.MAR
;invokes the PARAMETER macro twice. When GETSYISW is defined, the PARAMETER
;macro merely passes its arguments through to a call to the SYI_ITEM_CODE
;macro. The SYI_ITEM_CODE macro is locally defined as needed by the facility.
;
;+---------------------------------------------------------------------+
;|                    SYI_GENERATE_TABLE                               |
;|   SYI_ITEMTABLES          |                                         |
;|                           | PARAMETER   |           PQL             |
;|                           |             | PARAMETER   | PARAMETER   |
;|             |             |             |             |             |
;|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|
;+---------------------------------------------------------------------+
;\                          / \                                       /
; \                        /   \                                     /
;     FROM SYITABLE.MAR                  FROM SYSPARAM.MAR
;    (NON-SYSBOOT ITEMS)                  (SYSBOOT ITEMS)

	.SBTTL	DECLARATIONS
	$ARCDEF				; architectural flags
	$CLUBDEF			; cluster block definitions
	$CSBDEF				; cluster system block definitions
	$IPLDEF				; IPL definitions
	$PCBDEF				; define processor control block
	$PFLDEF				; page file control block
	$PRDEF				; define processor registers
	$PSLDEF				; define processor status register
	$SBDEF				; system block definitions
	$SSDEF				; define status codes
	$SYIDEF				; define GETSYI item identifiers
	$VADEF				; virtual addressing definitions

;
; Define the following symbol so that SYSPARAM macros will conditionalize
; correctly for us.
;
	GETSYISW = 0

;
; MACROS:
;

;
; Macros to define entries in the four item information tables.
; There is a table for each data structure from which the user may
; request information, and one table for information returned as an
; address.  Tables are indexed by low byte of item identifier.
; Refer to "OWN STORAGE:" for pictures of the table entries.
;

	.MACRO	SYI_ITEM_CODE	BASE,-		; for service to use
				NAME,-		; of the item-code
				SOURCE,-	; of the data
				DTYPE,-		; of returned value
				BITPOS,-	; of FLD type data
				BITSIZ,-	; "
				OUTLEN		; of returned value

	.IF NOT_DEFINED SYI$_'NAME

	.IF IDENTICAL <BASE><EXE>

	.WARN ; SYI$_'NAME IS NOT DEFINED AS 'EXE' IN STARDEFQZ.SDL

	.ENDC	; IDENTICAL

	.IF IDENTICAL <BASE><FLD>

	.WARN ; SYI$_'NAME IS NOT DEFINED AS 'FLD' IN STARDEFQZ.SDL

	.ENDC	; IDENTICAL

	.ENDC	; NOT_DEFINED

	STEP = 5
	.IIF IDENTICAL <BASE><EXE>,	STEP = 5
	.IIF IDENTICAL <BASE><FLD>,	STEP = 7

	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><HEXNUM>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><DECNUM>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><PRVMSK>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><PADSTR>,	XTYPE = BSTRING
	.IIF IDENTICAL <DTYPE><HEXSTR>,	XTYPE = BSTRING
	.IIF IDENTICAL <DTYPE><CNTSTR>,	XTYPE = CSTRING
	.IIF IDENTICAL <DTYPE><STRDSC>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><BITVEC>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><BITVAL>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><STDUIC>,	XTYPE = VALUE
	.IIF IDENTICAL <DTYPE><STDTIM>,	XTYPE = VALUE

	. = BASE'TBL + <<SYI$_'NAME & ^XFFF> * STEP>

	.IIF	IDENTICAL <BASE><FLD>,	.WORD	<BITSIZ-1>@11!BITPOS

	.LONG	SOURCE
	.BYTE	XTYPE@5!OUTLEN

	.ENDM	SYI_ITEM_CODE

;
; This macro defines the entries to the table of special items.
; The items in this table must be handled by action routines 
; before being returned.  Each entry has a word item identifier
; followed by the address of an action routine.
; ALL PROCESSOR REGISTER ITEMS ARE SPECIALS.
;

	.MACRO	SPECIAL_ITEM NAME,ROUTINE
	.WORD	SYI$_'NAME
	.ADDRESS ROUTINE
	.ENDM	SPECIAL_ITEM

;
; This macro defines flag bits.
;

	.MACRO	SYIBITS	NAME,SIZE
	SYI_V_'NAME' = SYI_BIT
	SYI_S_'NAME' = SIZE
	SYI_BIT = SYI_BIT + SIZE
	.ENDM	SYIBITS

;
; EQUATED SYMBOLS:
;

	EFN	 = 4			; event flag number argument
	NULLARG1 = 8			; first null argument
	NULLARG2 = 12			; second null argument
	ITMLST	 = 16			; address of item identifiers
	IOSB	 = 20			; I/O status block address
	ASTADR	 = 24			; ast routine address
	ASTPRM	 = 28			; ast parameter
	MAXSTRUC = 2 			; maximum structure code
	VALUE	 = 0			; datatypes
	BSTRING	 = 1
	CSTRING	 = 2
	LOCAL_SPACE = -32		; 8 longwords on stack
	BITSIZ   = LOCAL_SPACE+0
	BITPOS   = LOCAL_SPACE+4
	TEMPORARY = LOCAL_SPACE+8
	SPECIAL_SPACE = LOCAL_SPACE+12
	FLAGS    = LOCAL_SPACE+28

;
; Bit definitions for flags longword on stack
;

	SYI_BIT = 0
	SYIBITS	WILD,1			; we're doing a wildcard operation
	SYIBITS	INCLUSTER,1		; we're in a live cluster
	SYIBITS	REMOTE_NODE,1		; the target node isn't the local node
	SYIBITS RETIRED,1		; the item-code isn't in use anymore

;
; Max structure number definitions
;

	MAX_EXE_ITEM = <SYI$_LASTEXE&^XFFF>-1	; maximum EXE item number
	MAX_FLD_ITEM = <SYI$_LASTFLD&^XFFF>-1	; maximum FLD item number

;
; OWN STORAGE:
;

	.PSECT	YF$$SYSGETSYI

;
; This array contains the maximum item number for each of the two
; item data structures, indexed by structure number.
;
MAXCOUNT:
	.WORD	MAX_EXE_ITEM
	.WORD	MAX_FLD_ITEM

	.PAGE
;
; The following tables are zeroed explicitly to allow the code to
; recognize an uninitialized element (because of a retired item-code)
;

EXETBL:
	;-----------------------;
	; .LONG	SOURCE		;
	; .BYTE	DTYPE@5!OUTLEN	;
	;-----------------------;

	.REPEAT	5*<MAX_EXE_ITEM+1>
	.BYTE	0
	.ENDR

FLDTBL:
	;----------------------------;
	; .WORD	<BITSIZ-1>@11!BITPOS ;
	; .LONG	SOURCE		     ;
	; .BYTE	DTYPE@5!OUTLEN	     ;
	;----------------------------;

	.REPEAT	7*<MAX_FLD_ITEM+1>
	.BYTE	0
	.ENDR

	.SAVE

;***********************************************************
;
; GENERATE THE TABLES USING THE COMMONLY DEFINED MACRO
;
;***********************************************************

	SYI_GENERATE_TABLE

	.RESTORE

;
; Table to define items which must be handled by action routines
;

SPECIAL:
	SPECIAL_ITEM	CLUSTER_MEMBER, SPC_MEMBER
	SPECIAL_ITEM	CLUSTER_NODES, SPC_CLUB
	SPECIAL_ITEM	CLUSTER_VOTES, SPC_CLUB
	SPECIAL_ITEM	CLUSTER_QUORUM, SPC_CLUB
	SPECIAL_ITEM	CLUSTER_FSYSID, SPC_CLUB
	SPECIAL_ITEM	CLUSTER_FTIME, SPC_CLUB
	SPECIAL_ITEM	NODE_CSID, SPC_CSB
	SPECIAL_ITEM	NODE_VOTES, SPC_CSB
	SPECIAL_ITEM	NODE_QUORUM, SPC_CSB
	SPECIAL_ITEM	NODE_SYSTEMID, SPC_SB
	SPECIAL_ITEM	NODE_AREA, SPC_SB
	SPECIAL_ITEM	NODE_NUMBER, SPC_SB
	SPECIAL_ITEM	NODE_SWINCARN, SPC_SB
	SPECIAL_ITEM	NODE_SWTYPE, SPC_SB
	SPECIAL_ITEM	NODE_SWVERS, SPC_SB
	SPECIAL_ITEM	NODE_HWTYPE, SPC_SB
	SPECIAL_ITEM	NODE_HWVERS, SPC_SB
	SPECIAL_ITEM	NODENAME, SPC_SB
	SPECIAL_ITEM	SCS_EXISTS, SPC_EXISTS
	SPECIAL_ITEM	SID, SPC_PROCREG
	SPECIAL_ITEM	CPU, SPC_PROCREG
	SPECIAL_ITEM	PAGEFILE_PAGE, SPC_PAGESWAP
	SPECIAL_ITEM	SWAPFILE_PAGE, SPC_PAGESWAP
	SPECIAL_ITEM	PAGEFILE_FREE, SPC_PAGESWAP
	SPECIAL_ITEM	SWAPFILE_FREE, SPC_PAGESWAP
	SPECIAL_ITEM	QUANTUM, SPC_NEGATIVE
SPECIAL_LEN = <.-SPECIAL>/6

	.PAGE
	.SBTTL	SYSGETSYI - GETSYI main program

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This service allows a process to receive status and identification
;	information about the system on which the calling process is running.
;	
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	EFN(AP) = number of the event flag to set when all of the requested
;		  data is valid. 
;	NODE(AP) = pointer to nodename descriptor
;	CSIDADR(AP) = address of CSID source/destination
;	ITMLST(AP) = address of a list of item descriptors of the form:
;
;		+-----------------------------+
;		!  ITEM CODE   !  BUF. LENGTH !
;		+-----------------------------+
;		!      BUFFER ADDRESS         !
;		+-----------------------------+
;		!  ADDRESS TO RETURN LENGTH   !
;		+-----------------------------+
;
;	IOSB(AP) = address of a quadword I/O status block to receive final
;		status
;	ASTADR(AP) = address of an AST routine to be called when all of the
;		requested data has been supplied.
;	ASTPRM(AP) = 32 bit ast parameter
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	SS$_NORMAL -> normal completion
;	SS$_EXASTLM -> AST quota exceeded
;	SS$_ACCVIO -> ITMLST can not be read by the calling access mode,
;			or the return buffer or return length word can not
;			be written by the calling access mode
;	SS$_BADPARAM -> an invalid item identifier was supplied
;
; SIDE EFFECTS:
;
;	none
;--

	.PSECT	YEXEPAGED	; only entry mask in this program section

	.ENTRY	EXE$GETSYI,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_GETSYI	; transfer to real procedure

	.PSECT	YF$$SYSGETSYI

;
; Allocate some local space on the stack
;
EXE_GETSYI:
	MOVAL	LOCAL_SPACE(SP), SP
	CLRL	FLAGS(FP)		; reset the flags longword
	BSBW	NAMCSID			; process nodename/CSID pair
	BLBC	R0,4$

;
; Check for and clear possible IOSB
;
	MOVL	IOSB(AP),R1		; get IOSB address
	BEQL	3$			; branch if none
	IFNOWRT	#8,(R1),30$		; check write access to it
	CLRQ	(R1)			; clear IOSB
;
; Check for and clear event flag
;
3$:	MOVZBL	EFN(AP),R3		; get event flag number
	JSB	G^SCH$CLREF		; clear event flag
4$:	BLBC	R0,GRET			; and return on errors
;
; Validate AST, if present
;
	TSTL	ASTADR(AP)		
	BEQL	5$			; no AST to check
	MOVL	G^CTL$GL_PCB,R4		; get our PCB address
	TSTW	PCB$W_ASTCNT(R4)	; is AST quota exceeded?
	BLEQ	40$			; branch if so and return error
;
; Loop through item descriptors, validating the requested item
; identifiers and moving accessible items. A zero item identifier
; terminates the list.
;
5$:	MOVL	ITMLST(AP),R5		; get item descriptor list address
	BEQL	50$			; ITMLST not optional
	IFNORD	#4,(R5),30$		; check first longword readable
10$:					; top of item-get loop
	MOVZWL	(R5)+,R6		; get buffer size
	MOVZWL	(R5)+,R1		; get item identifier
	BEQL	60$			; done if zero, take normal exit
	IFNORD	#12,(R5),30$		; check rest of this descriptor ...
					; plus first longword of next one
	MOVQ	(R5)+,R7		; R7 = buffer address, R8 = length address
	PUSHL	R1			; save R1 across accessibility check
	MOVL	R7,R0			; buffer address to R0
	MOVL	R6,R1			; and size to R1
	CLRL	R3			; PROBE will use PSL<PRVMOD>
	JSB	EXE$PROBEW		; check write accessibility of buffer
	BLBC	R0,30$			; buffer not accessible
	POPL	R1			; restore R1 for use by CHECKITEM
	PUSHL	R5			; save R5 across item check
	BSBW	CHECKITEM		; check item's validity
	BLBC	R0,50$			; return error if not valid
	BSBW	PUTDATA			; put the item requested in user buffer
	POPL	R5			; unsave R5
	BLBS	R0,10$			; continue on success
	BRB	GRET

;
; Error/success dispatch points:
;
30$:	MOVZWL	#SS$_ACCVIO,R0		; access violation
	BRB	GRET			; terminate service below
40$:	MOVZWL	#SS$_EXASTLM,R0		; AST quota exceeded
	BRB	GRET			; terminate service below
50$:	MOVZWL	#SS$_BADPARAM,R0	; illegal item or request
	BRB	GRET			; terminate service below
60$:	MOVZWL	#SS$_NORMAL,R0		; normal return
;
; Set the event flag, post completion status, and declare completion AST
;
GRET:	PUSHL	R0			; save completion status
	MOVL	G^CTL$GL_PCB,R4		; get PCB address
	MOVL	PCB$L_PID(R4),R1	; get process's PID
	CLRL	R2			; set null priority increment
	MOVZBL	EFN(AP),R3		; get event flag number to set
	JSB	G^SCH$POSTEF		; set the event flag
10$:	MOVL	IOSB(AP),R1		; get address of IOSB
	BEQL	20$			; branch if none
	IFNOWRT	#8,(R1),20$		; check if writable
	MOVL	(SP),(R1)		; store completion status
20$:	MOVL	ASTADR(AP),R5		; get address of AST routine
	BEQL	30$			; branch if none specified
	MOVPSL	R4			; get PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R4,R4 ; extract previous mode
	$DCLAST_S (R5),ASTPRM(AP),R4	; queue the completion AST
30$:	POPL	R0			; restore completion status
	RET				; and return.

	.PAGE
	.SBTTL	CHECKITEM - Validate item identifier

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to validate item identifier and return information
;	about the item.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	R1 = item identifier
;	R2 = structure number
;	R3 = item length
;	R4 = item source address
;	R5 = item type code
;	BITSIZ(FP) - if FLD
;	BITPOS(FP) - if FLD
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit set -> successful return
;	R0 low bit clear -> invalid item identifier
;
; SIDE EFFECTS:
;
;	none
;--
	.PAGE
;
; This table is used to convert the pre V4 GETSYI item-codes to the
; new ones, which have a different form.
;
; Old form:		+--------+--------+
;			; 8 bits ; 8 bits ;
;			+--------+--------+
; SYI$_OLDVERSION =	       01       00
; SYI$_OLDCPU =		       02       00
; SYI$_OLDSID =		       02       01
;
; New form:		+---+-------------+
;			; 4 ; 12 bits     ;
;			+---+-------------+
; compatibile with old =   0
; EXE items =		   1
; FLD items =		   2
;

COMPAT:
	.WORD	SYI$_OLDVERSION,	SYI$_VERSION
	.WORD	SYI$_OLDCPU,		SYI$_CPU
	.WORD	SYI$_OLDSID,		SYI$_SID

	.ENABLE	LOCAL_BLOCK

CHECKITEM:
	CLRL	R0			; assume error
	BITW	#^XF000, R1		; is it a new item-code?
	BNEQU	10$			; NEQU means it is
	MOVZBL	#3, R3			; setup to scan table
	MOVAW	COMPAT-2, R2
5$:	TSTW	(R2)+			; skip past new item-code
	CMPW	(R2)+, R1		; does it match this old item-codes?
	BNEQU	7$			; NEQU means it does not
	MOVW	(R2), R1		; match, use the new itemcode instead
	BRB	10$			; continue like nothing happened
7$:	SOBGTR	R3, 5$			; cycle through the table
	BRB	900$			; error if it wasn't in the table
10$:	EXTZV	#12,#4,R1,R2		; get the structure number
	EXTZV	#0,#12,R1,R3		; get the item number
	CMPB	R2, #MAXSTRUC		; is it a legal structure number?
	BGTRU	900$			; GTRU means it is not
	CMPW	R3, MAXCOUNT-2[R2]	; is it a legal item number?
	BGTRU	900$			; GTRU means it is not
	CASE	R2,<EXE$,FLD$>B,#1	; goto the appropriate code

EXE$:	MULL	#5, R3			; calc total offset
	MOVAB	EXETBL[R3], R3		; get address of table element
	BRB	50$

FLD$:	MULL	#7, R3			; calc total offset
	MOVAB	FLDTBL[R3], R3		; get address of table element
	EXTZV	#11,#5,(R3),BITSIZ(FP)	; get (bitsiz-1) value
	INCL	BITSIZ(FP)		; restore its original value
	EXTZV	#0,#11,(R3),BITPOS(FP)	; get bitpos value
	TSTW	(R3)+			; point to next longword

50$:	MOVL	(R3)+, R4		; get source address
	BEQLU	100$			; NULL SOURCE MEANS RETIRED ITEM-CODE!!
					; IT ALSO MEANS PR$_KSP WILL NEVER BE
					; ABLE TO BE AN ITEM-CODE!
	EXTZV	#5,#3,(R3),R5		; get DTYPE
	EXTZV	#0,#5,(R3),R3		; get OUTLEN
70$:	INCL	R0			; success!

900$:	RSB				; return to caller

100$:	BISL	#<1@SYI_V_RETIRED>,FLAGS(FP) ; mark it as obsolete
	MOVL	#4,R3			; src length
	MOVAL	SPECIAL_SPACE(FP),R4	; scratch area
	CLRL	(R4)			; null answer now
	MOVL	#VALUE,R5		; dtype
	BRB	70$			; success exit

	.DISABLE LOCAL_BLOCK
	.PAGE
	.SBTTL	PUTDATA - Put requested data in user buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine moves the requested data to the user's buffer and
;	returns the actual data length to the user. It assumes that the
;	user's buffer has been probed.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R2 = data structure number
;	R3 = item length
;	R4 = item address
;	R5 = item type code
;	R6 = user buffer length
;	R7 = user buffer address
;	R8 = address to return length
;	BITSIZ(FP)
;	BITPOS(FP)
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit set -> success
;	R0 low bit clear -> access violation on write of length
;
; SIDE EFFECTS:
;
;	Registers R1-R4 destroyed
;--
	.PAGE

PUTDATA:

;
; Call routine to check for special conditions
;

	BBS	#SYI_V_RETIRED,FLAGS(FP),15$ ; skip alot for oldie items
	BSBB	CHECK_SPC		; handle special items
	BLBC	R0,50$			; were we successful?

;
; Check for counted string, and find actual length if so.
;

	CMPL	#CSTRING,R5		; is this special string?
	BNEQ	10$			; branch if not
	MOVZBL	(R4)+,R3		; get length and skip length byte
;
; Fetch the bitpos and bitsiz if it's a FLD item
;
10$:	CMPL	R2, #SYI$C_FLDTYPE	; is it FLD?
	BNEQU	15$			; NEQU means it is not
	MOVL	BITSIZ(FP), R0		; get bitsiz
	MOVL	BITPOS(FP), R1		; get bitpos
	MOVL	(R4), TEMPORARY(FP)	; get copy of cell
	MOVAL	TEMPORARY(FP), R4	; point to copy
	EXTZV	R1,R0,(R4),(R4)		; fetch sub-field and save
;
; Move the data
;
15$:	PUSHR	#^M<R3,R5>		; save needed registers from movc
	MOVC5	R3,(R4),#0,R6,(R7)	; move data to user's buffer, zero fill
	POPR	#^M<R3,R5>		; restore registers
	TSTL	R8			; did caller want return length?
	BEQL	30$			; branch if not
	IFNOWRT	#2,(R8),40$		; exit if word not writable
	BBC	#SYI_V_RETIRED,FLAGS(FP),18$
	CLRL	R3			; make his retlen null
18$:	CMPL	R3,R6			; see how much was moved
	BLEQ	20$			; use valid data length if it fit
	MOVL	R6,R3			; else give him "too short" buffer size
20$:	MOVW	R3,(R8)			; return length to user

30$:	MOVZWL	#SS$_NORMAL,R0		; set success code
	RSB

40$:	MOVZWL	#SS$_ACCVIO,R0		; set error code
50$:	RSB				; return
	.PAGE
	.SBTTL	SPECIAL - Handle special conditions

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	These routines handle data items which must be transformed
;	before they are returned to the user.  Generally, some
;	transformation is applied to the data item and the newly
;	computed item is stored in SPECIAL_SPACE on the stack.
;	The handling routine then changes R4 to point to SPECIAL_SPACE
;	so that PUTDATA will move the item from local storage.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R3 = item length
;	R4 = item address/offset
;	R9 = target CSB address
;	R11 = target CSID
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;--
	.PAGE

CHECK_SPC:

;
; Registers R5 - R8 are saved at this level and may be used by
; the action routines without being saved.  Action routines are JSB'ed
; to with R5 containing the address of SPECIAL_SPACE on the stack.
;

	PUSHR	#^M<R5,R6,R7,R8>	; save resisters
	MOVAL	SPECIAL_SPACE(FP),R5	; local storage for action routine
	CLRQ	(R5)			; clear the special buffer
	CLRQ	8(R5)
	MOVZWL	#SS$_NORMAL,R0		; assume success
	MOVL	#SPECIAL_LEN,R7		; get number of table entries
	MOVAL	SPECIAL,R8		; get address of table
10$:
	CMPW	R1,(R8)+		; does entry match item?
	BEQL	20$			; yes, go handle it
	ADDL	#4,R8			; skip handler address
	SOBGTR	R7,10$			; scan rest of table

	BBC	#SYI_V_REMOTE_NODE,FLAGS(FP),35$ ; nonlocal noncluster info?
	MOVL	R5,R4			; make the returned data null
35$:	POPR	#^M<R5,R6,R7,R8>	; restore registers
	RSB

20$:
	JSB	@(R8)+			; call action routine
	BRB	35$

;
; Data handling routines
;********************************************************************
; ALL NON-CLUSTER SPECIAL DATA ITEMS SHOULD TEST REMOTE_NODE AS BELOW
;********************************************************************
;

;
; Is the SCS code loaded?
;

SPC_EXISTS:
	BBS	#SYI_V_REMOTE_NODE,FLAGS(FP),POINT_R4 ; skip it for remotes
	TSTL	SCS$GA_EXISTS		; is the cell empty?
	BEQLU	POINT_R4		; null cell means it doesn't exist
	INCL	(R5)			; make result TRUE
	BRB	POINT_R4

;
; Processor registers require special instructions to fetch
;

SPC_PROCREG:
	BBS	#SYI_V_REMOTE_NODE,FLAGS(FP),POINT_R4 ; skip it for remotes
	MFPR	R4, (R5)		; get the register contents
	BRB	POINT_R4

;
; Cell is stored as a negative, reverse it and return
;

SPC_NEGATIVE:
	BBS	#SYI_V_REMOTE_NODE,FLAGS(FP),POINT_R4 ; skip it for remotes
	MNEGL	(R4), (R5)		; Negate it
	BRB	POINT_R4

;
; This cluster item makes sense even when not in a cluster
;

SPC_MEMBER:
	EXTZV	#SYI_V_INCLUSTER,#1,FLAGS(FP),(R5) ; get the flag
	BRB	POINT_R4

;
; These are cluster only items
;

SPC_CLUB:
	BBC	#SYI_V_INCLUSTER,FLAGS(FP),POINT_R4 ; return null if no cluster
	MOVL	CLU$GL_CLUB,R7		; get the address of the CLUB
	MOVAB	(R7)[R4],R4		; get the address of the field
	BRB	FETCH_CLU

SPC_CSB:
	BBC	#SYI_V_INCLUSTER,FLAGS(FP),POINT_R4 ; return null if no cluster
SPC_LOCK = .
	SETIPL	LOCK			; lock the database
	BSBB	VERIFY_CSB		; double check the CSB address
	BLBC	R0,POINT_R4		; exit if bad
	MOVAB	(R9)[R4],R4		; get actual address of field
	BRB	FETCH_CLU

LOCAL_SB:
	PUSHL	R1			; save R1
	MOVAL	G^SCS$GA_LOCALSB,R1	; point to our local system block
	BRB	GET_SB_FLD		; go get desired information from SB

POINT_R4:
	MOVL	R5,R4			; make R4 point to data
	RSB

SPC_SB:
	BBC	#SYI_V_INCLUSTER,FLAGS(FP),LOCAL_SB ; use local SB if no cluster
	SETIPL	LOCK			; lock the database
	BSBB	VERIFY_CSB		; double check the CSB address
	BLBC	R0,POINT_R4		; exit if bad
	PUSHL	R1			; save R1
	MOVL	CSB$L_SB(R9),R1		; get SB address
GET_SB_FLD:
	MOVAB	(R1)[R4],R4		; get actual address of field
	POPL	R1			; restore R1
	
FETCH_CLU:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; save the register past the MOVC3
	MOVC3	R3,(R4),(R5)		; get the data into the special buffer
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; restore the registers
	SETIPL	#0			; drop IPL again
	BRB	POINT_R4

VERIFY_CSB:
	CVTWL	R11,R6			; get the system index
	MOVL	@CLU$GL_CLUSVEC[R6],R6	; get the CSB address
	BGEQ	99$			; GEQ means it is now unused
	CMPL	R6,R9			; is it the same as ours?
	BNEQ	99$			; NEQ means it changed
	CMPL	CSB$L_CSID(R6),R11	; is the CSID the same?
	BNEQ	99$			; NEQ means it changed
	MOVZWL	#SS$_NORMAL,R0
	RSB

99$:	SETIPL	#0			; drop IPL
	BICL2	#<1@SYI_V_INCLUSTER>,FLAGS(FP) ; reset the cluster flag
	MOVZWL	#SS$_NOSUCHNODE,R0	; declare an error
	RSB

LOCK:
	.BYTE	IPL$_SCS
	ASSUME	<.-SPC_LOCK> LE 512
;
;
; Return total sizes for all page or swap files
;
; Input bit mask in R4
;	bit 0 
;	   	0 -> page file
;		1 -> swap file
;	bit 1
;		0 -> total space
;		1 -> free space
;	bit 2
;		1 -> keeps it from being null
;
;
SPC_PAGESWAP:
	BBS	#SYI_V_REMOTE_NODE,FLAGS(FP),POINT_R4 ; skip it for remotes
	BLBS	R4,10$			; swap file
	MOVZWL	SGN$GW_SWPFILCT,R7	; first page file slot
	MOVL	MMG$GL_MAXPFIDX,R8	; last one
	BRB	20$			; resume in common code
;
10$:	MOVL	#1,R7			; always the first swap file slot
	MOVZWL	SGN$GW_SWPFILCT,R8
	DECL	R8			; max index for swap files
;
20$:	CLRL	(R5)			; initial count
	SUBL	R7,R8			; slots to count - 1
	BLSS	60$			; none
	MOVAL	@MMG$GL_PAGSWPVC[R7],R7	; first slot
30$:	MOVL	(R7)+,R6		; address of PFL structure
	CMPL	R6,MMG$GL_NULLPFL	; is it in use
	BEQL	50$			; no
	BBC	#PFL$V_INITED,PFL$B_FLAGS(R6),50$ ; not inited
	BBS	#1,R4,40$		; count free space
	ADDL	PFL$L_BITMAPSIZ(R6),(R5) ; total size / 8
	BRB	50$
40$:	ADDL	PFL$L_FREPAGCNT(R6),(R5) ; total free pages
50$:	SOBGEQ	R8,30$			; loop over all files
;
	BBS	#1,R4,60$		; free space - already page count
	ASHL	#3,(R5),(R5)		; convert byte count to page count
60$:	BRW	POINT_R4		; join common exit code


	.SBTTL	NAMCSID - Get specified node CSID
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to convert a node name to a CSID. If a
;	valid CSID or node name is specified, the standard conversion
;	routine EXE$NAMCSID is simply called.  If, however, a CSID that implies
;	a "wildcard" CSID (-1) is specified, then the next active node is
;	chosen as the node CSID to pass to EXE$NAMCSID.  EXE$NAMCSID then
;	returns the node's CSB address.
;
; INPUTS:
;
;	CSIDADR(AP) = address of specified CSID
;	NODE(AP) = address of specified process name descriptor
;
; OUTPUTS:
;
;	R0 = success/failure of operation
;	R4 = current process PCB address
;	R9 = specified node CSB address
;	R11 = specified node CSID
;	@CSIDADR(AP) = specified node CSID or special "wildcard" context CSID
;--

	CSIDADR  = 8
	NODE	 = 12

NAMCSID:
	.ENABLE	LOCAL_BLOCK

;
; MAKE SURE WE'RE IN A CLUSTER HERE
;
	MOVL	CLU$GL_CLUB,R6		; GET CLUB ADDRESS
	BEQL	1$			; IF EQL, NOT IN CLUSTER
	BBC	#CLUB$V_CLUSTER,CLUB$L_FLAGS(R6),1$ ; IF CLEAR, NOT A CLUSTER
	BISL2	#<1@SYI_V_INCLUSTER>,FLAGS(FP) ; mark that we're in a cluster

1$:	MOVL	CSIDADR(AP),R6		; get CSID address
	BEQL	19$			; if eql - none
	IFWRT	#4,(R6),2$		; check access to CSID
	BRW	50$
2$:	MOVL	(R6),R0			; get CSID
	BEQL	19$			; if eql - none
	BGTR	20$			; if gtr - standard CSID
;
; "Wildcard" type CSID specified
;

	BBS	#SYI_V_INCLUSTER,FLAGS(FP),5$ ; are we in a cluster?
	BRW	60$			; wildcarding without a cluster!
5$:	SETIPL	80$			; lock the cluster database
	CVTWL	R0,R5			; get NIX (Node IndeX) from CSID
	BISL2	#<1@SYI_V_WILD>,FLAGS(FP) ; mark wildcarding in effect
10$:	INCW	R5			; increment NIX
	CMPW	R5,CLU$GW_MAXINDEX	; is NIX in valid range?
	BLSSU	11$			; if LSSU, yep
	BRW	60$			; no more nodes
11$:	MOVZWL	R5,R5			; clear out the top half of R5
	MOVL	@CLU$GL_CLUSVEC[R5],R0	; get CSB address
	BGEQ	10$			; if GEQ, unused - try next one
	MOVL	CSB$L_CSID(R0),-(SP)	; get the CSID
	SETIPL	#0			; lower IPL to touch the argument list
	MOVL	(SP)+,(R6)		; store CSID in argument list
	BRB	20$

;
;	At this point, the CSID argument was defaulted
;
19$:	BBS	#SYI_V_INCLUSTER,FLAGS(FP),21$ ; let EXE$NAMCSID do it
	MOVL	NODE(AP),R3		; get the nodename argument
	BEQL	75$			; it was defaulted too, skip everything

;
;	At this point, we're not in a cluster, but a nodename was specified,
;	see if it's the local one, if so succeed.
;
	IFNORD	#8,(R3),50$		; probe the descriptor
	MOVQ	(R3),R2			; get the nodename descriptor
	MOVZWL	R2,R2			; is the length legal?
	BEQL	65$			; EQL means nope
	CMPW	#15,R2			; is it too long?
	BLSSU	65$			; LSSU means too long
	IFNORD	R2,(R3),50$		; probe the string
	MOVAL	G^SCS$GA_LOCALSB,R1	; point at the local SB
	MOVAB	SB$T_NODENAME(R1),R5	; get address of nodename
	CMPB	R2,(R5)+		; is it the right length?
	BNEQ	65$			; NEQ means no
	CMPC3	R2,(R3),(R5)		; is it the same nodename?
	BNEQ	65$			; NEQ means this is NOT the one
	BRB	75$			; It Is the local nodename, exit
	
;
; Convert node name to CSID, if specified
;
20$:	BBC	#SYI_V_INCLUSTER,FLAGS(FP),60$ ; specified CSID - no cluster!
21$:	ADDL	#4,AP			; make CSIDADR top argument
	JSB	25$			; get into nonpaged code
	.SAVE_PSECT			; save current .PSECT context

;  The reason for jumping to the nonpaged exec rather than dynamically
;  locking down pageable pages is that EXE$NAMCSID cannot be entered
;  above IPL 2 and the dynamic locking would cause that to happen. The
;  reason that EXE$NAMCSID must be entered at IPL 2 or lower is that it
;  touches the caller's argument list (which contains arguments that
;  could fault) and page faults are not allowed above IPL 2.

	.PSECT	AEXENONPAGED		; EXE$NAMCSID returns at IPL$_SYNCH
25$:	JSB	EXE$NAMCSID		; get CSB address and CSID
	SETIPL	#0			; restore IPL - CSB is no longer locked
	RSB				; go back to paged code

	.RESTORE_PSECT			; get paged .PSECT context back
	SUBL	#4,AP			; restore argument pointer
	MOVL	R1,R11			; save CSID
	BBC	#SYI_V_WILD,FLAGS(FP),30$ ; "wildcard" type CSID specified?
	MOVW	R1,(R6)			; restore node index context
	MNEGW	#1,2(R6)		; set continuation context
;
; Check CSID address and return
;
30$:	BLBC	R0,40$			; branch if error
	MOVL	R4,R9			; save CSB address
	MOVL	CLU$GL_CLUB,R4		; get address of Cluster Block
	BNEQU	32$			; NEQU means it's not null
	BUG_CHECK ICONCLUDAT,FATAL	; oh oh
32$:	MOVAL	CLUB$L_LOCAL_CSB(R4),R4	; get address of local CSB
	CMPL	(R4),R9			; see if local csb = target csb
	BEQL	75$			; EQL means target = local
	BISL2	#<1@SYI_V_REMOTE_NODE>,FLAGS(FP) ; set the remote target flag
75$:	MOVZWL	#SS$_NORMAL,R0		; set success
40$:	MOVL	SCH$GL_CURPCB,R4	; restore current PCB address
	SETIPL	#0			; make sure we can page fault
	RSB

50$:	MOVZWL	#SS$_ACCVIO,R0		; set access violation
	BRB	40$			;
60$:	MOVZWL	#SS$_NOMORENODE,R0	; set no more nodes
	BRB	40$			;
65$:	MOVZWL	#SS$_NOSUCHNODE,R0	; set no such node
	BRB	40$			;

80$:	.BYTE	IPL$_SCS		; to lock the cluster database
	ASSUME	<.-5$> LE 512

	.DISABLE LOCAL_BLOCK

	.SBTTL	EXE$NAMCSID - CONVERT NODE NAME TO CSID
;++
;	EXE$NAMCSID  -  CONVERT NODE NAME TO CSID
;
; FUNCTIONAL DESCRIPTION:
;	EXE$NAMCSID OBTAINS THE PROPER CSID AND CSB ADDRESS FOR A
;	STANDARD NODE SERVICE ARGUMENT LIST CONSISTING
;	OF A CSID/NODE-NAME PAIR.  THE ABSENCE OF BOTH SELECTS THE
;	CURRENT NODE.
;
;	NOTE THAT THE OPERATION OF THIS ROUTINE ONLY MAKES SENSE IN
;	A CLUSTER, THEREFORE A NOSUCHNODE ERROR WILL BE RETURNED IF
;	CLU$GL_CLUB = 0 ON ENTRY.
;
; CALLING SEQUENCE:
;	JSB/BSB	EXE$NAMCSID
;
; INPUT PARAMETERS:
;	CSID(AP) - ADDRESS OF CSID SOURCE/DESTINATION (CSID)
;	NODENAME(AP) - POINTER TO NODE DESCRIPTOR TO CONVERT TO CSID
;
; IMPLICIT INPUTS:
;	@CLU$GL_CLUSVEC - VECTOR OF CSB ADDRESSES 
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;	R1 - NODE IDENTIFICATION (CSID) OF NAMED NODE.
;	R4 - CSB ADDRESS OF NODE IF MATCH IS FOUND.
;	@CSID(AP) - NODE IDENTIFICATION (CSID) OF SELECTED NODE
;	IPL - IPL$_SYNCH (IPL UNCHANGED IF SS$_ACCVIO OR SS$_IVLOGNAM)
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL SUCCESSFUL COMPLETION
;	SS$_IVLOGNAM  -  INVALID LOGICAL NAME STRING
;	SS$_NOSUCHNODE -  NONEXISTENT NODE OR INVALID CSID
;	SS$_ACCVIO  -  ACCESS VIOLATION FOR WRITE DESTINATION
;
; SIDE EFFECTS:
;	NONE
;--

	CSID     = 4			; special offset for EXE$NAMCSID
	NODENAME = 8			; special offset for EXE$NAMCSID

EXE$NAMCSID:				; TRANSLATE PNAME TO CSID
	.ENABLE	LOCAL_BLOCK
	MFPR	S^#PR$_IPL,R0		; CHECK THE CURRENT IPL LEVEL
	CMPL	#IPL$_ASTDEL,R0		; ARE WE ABOVE PAGE FAULT IPL?
	BGEQU	8$			; GOOD, WE CAN FAULT
	BSBW	999$			; CANNOT BE CALLED ABOVE ASTDEL
8$:	MOVL	CLU$GL_CLUB,R4		; GET THE CLUSTER BLOCK ADDRESS
	BNEQU	10$			; GOOD, WE'RE IN A CLUSTER
	BRW	NONEX			; CANNOT BE CALLED IF NOT IN A CLUSTER
10$:	MOVL	CLUB$L_LOCAL_CSB(R4),R4	; GET THE CSB ADDRESS
	MOVL	CSID(AP),R0		; GET CSID ADDRESS
	BEQL	30$			; NO CSID ADDRESS
	IFWRT	#4,(R0),20$		; ERROR IF ACCESS VIOLATION
35$:	MOVZWL	#SS$_ACCVIO,R0		; SET ACCESS VIOLATION ERROR CODE
	RSB				; AND EXIT
20$:	MOVL	(R0),R1			; NOW FETCH CSID
	BEQL	30$			; BRANCH IF NO CSID FOUND
	CLRL	R0			; CLEAR CSID ADDRESS,
					; DON'T NEED TO REWRITE SAME VALUE
	BRW	GOTCSID			; HAVE THE CSID, GO CHECK IT OUT

45$:	MOVZWL	#SS$_IVLOGNAM,R0	; BAD NODENAME STRING
	RSB

; NO CSID SPECIFIED (CSIDADR = 0 OR CSIDADR -> 0)
;
;	R4 -> LOCAL CSB
;	R0 = 0 OR R0 -> 0  (CSIDADR = 0 OR CSIDADR -> 0)
;	<R1,R2,R3> NOT INTERESTING

30$:	MOVL	CSB$L_CSID(R4),R1	; ASSUME LOCAL CSID
	MOVL	NODENAME(AP),R3		; GET NODENAME ADDRESS IF SPECIFIED
	BNEQ	31$			; NEQ MEANS NAME WAS SPECIFIED
	BRW	GOTCSID			; NO NAME SPECIFIED, USE CALLER'S CSID
31$:

; MUST LOOK UP NODE NAME.  PROBE THE DESCRIPTOR AND THE STRING, AND THEN
; COPY IT TO THE STACK SO THAT IT CAN BE ACCESSED AFTER WE RAISE IPL.
;
;	R4 -> CURRENT CSB
;	R3 -> NODE NAME DESCRIPTOR (ACCESS NOT YET PROBED)
;	R0 = 0 OR R0 -> 0  (CSIDADR = 0 OR CSIDADR -> 0)
;	<R1,R2> NOT INTERESTING

	IFNORD	#8,(R3),35$		; PROBE THE DESCRIPTOR
	MOVQ	(R3),R2			; GET THE NODENAME DESCRIPTOR
	MOVZWL	R2,R2			; IS THE LENGTH LEGAL?
	BEQL	45$			; EQL MEANS NOPE
	CMPW	#15,R2			; IS IT TOO LONG?
	BLSSU	45$			; LSSU MEANS TOO LONG
	IFNORD	R2,(R3),35$		; PROBE THE STRING
	SUBL	#16,SP			; ALLOCATE BUFFER ON THE STACK
	MOVL	SP,R1			; TEMPORARY POINTER TO BUFFER
	PUSHL	R2			; SAVE LENGTH OF NODE NAME STRING
40$:	MOVB	(R3)+,(R1)+		; COPY NODE NAME STRING FROM USER'S
	SOBGTR	R2,40$			;     BUFFER ONTO THE STACK
	POPL	R2			; RESTORE LENGTH OF NODE NAME STRING
	MOVL	SP,R3			; POINTER TO NODE NAME BUFFER
	PUSHL	R0			; SAVE THE CSIDADR ARGUMENT
	MOVZWL	CLU$GW_MAXINDEX,R0	; GET THE NUMBER OF ENTRIES
	DECL	R0			; CONVERT TO HIGHEST OFFSET

; SCAN CSB VECTOR TO LOOK FOR THIS NODE NAME
;
;	R4 -> CURRENT CSB
;	R3 -> USER'S NODE NAME STRING  (IN BUFFER ON THE STACK)
;	R2 =  USER'S NODE NAME LENGTH
;	R0 =  COUNTER FOR CLUSVEC SLOTS

100$:	SETIPL	LOCKPAGE		; LOCK DOWN THE REST OF THE ROUTINE
	MOVL	@CLU$GL_CLUSVEC[R0],R1	; GET THE POINTER TO THE CSB
	BGEQ	155$			; GEQ MEANS UNUSED, TRY THE NEXT ONE
	PUSHL	R1			; SAVE THE POINTER TO THE TARGET CSB
	MOVL	CSB$L_SB(R1),R1		; GET SB ADDRESS

; IS THIS THE NODENAME?
;
;	R0 -   CLUSVEC INDEX
;	R1 ->  SB (SYSTEM BLOCK)
;	R2 ->  USER'S NODENAME LENGTH
;	R3 ->  USER'S NODENAME STRING

	PUSHL	R5			; SAVE R5
	MOVAB	SB$T_NODENAME(R1),R5	; GET ADDRESS OF NODENAME
	CMPB	R2,(R5)+		; IS IT THE RIGHT LENGTH?
	BNEQ	150$			; NEQ MEANS NO, TRY THE NEXT ONE
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE REGISTERS FOR THE CMPC3
	CMPC3	R2,(R3),(R5)		; IS IT THE SAME NODENAME?
	POPR	#^M<R0,R1,R2,R3>	; RESTORE REGISTERS
	BEQL	GOTNAM			; EQL MEANS THIS IS THE ONE

; DID NOT FIND THE NODE BY NAME

150$:	POPL	R5			; RESTORE R5
	POPL	R1			; RESTORE TARGET CSB ADDRESS
155$:	SOBGEQ	R0,100$			; LOOP IF NOT DONE
	TSTL	(SP)+			; THROW AWAY R0 FROM STACK
	ADDL	#16,SP			; POP NODE NAME BUFFER FROM STACK

; EXIT WITH NONEXISTENT NODE STATUS

NONEX:	MOVZWL	#SS$_NOSUCHNODE,R0	; SET ERROR STATUS
	RSB				; AND RETURN TO CALLER

; EXIT WITH A CRASH DUMP

999$:	BUG_CHECK  ICONCLUDAT,FATAL

; FOUND THE NODE NAME, GET CSID FROM CSB AND CLEAN OFF THE STACK
;
;	R4 -> CURRENT CSB

GOTNAM:	POPL	R5			; RESTORE R5
	POPL	R1			; RESTORE TARGET CSB ADDRESS
	MOVL	CSB$L_CSID(R1),R1	; GET FULL CSID FOR NAME
	POPL	R0			; RESTORE CSIDADR ARGUMENT
	ADDL	#16,SP			; POP NODE NAME BUFFER FROM STACK

; FOUND THE TARGET CSID, VERIFY IT
;
;	R4 -> CURRENT CSB
;	R1 -> CSID OF TARGET NODE
;	R0 = 0 OR R0 -> 0  (CSIDADR = 0 OR CSIDADR -> 0)
;	<R2,R3> NOT INTERESTING

GOTCSID:
	SETIPL	LOCKPAGE		; BLOCK SYSTEM EVENTS
	MOVZWL	R1,R2			; EXTRACT NODE INDEX
	CMPW	R2,CLU$GW_MAXINDEX	; TEST AGAINST MAXIMUM VALUE
	BGEQU	NONEX			; NONEXISTENT IF GEQU THAN MAXINDEX
	MOVL	@CLU$GL_CLUSVEC[R2],R2	; GET CSB ADDRESS
	BGEQ	NONEX			; GEQ MEANS IT'S UNUSED
	CMPL	R1,CSB$L_CSID(R2)	; CHECK FOR VALID CSID
	BNEQ	NONEX			; NOT THE SAME

RETURN:					; SUCCESSFUL EXIT 
	MOVL	R2,R4			; MOVE CSB ADDRESS OF TARGET
					; NORMAL STATUS EXIT
	TSTL	R0			; WAS CSID ADDRESS SPECIFIED
	BEQL	910$			; NO, SKIP STORE OF CSID
	SETIPL	#IPL$_ASTDEL		; ALLOW PAGE FAULTS
	MOVL	R1,(R0)			; STORE CSID IN DESTINATION
	CLRL	R0			; DO NOT WRITE CSID A SECOND TIME
	BRB	GOTCSID			; MAKE SURE THAT CSID IS STILL VALID

910$:	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	RSB				; AND RETURN TO CALLER

; LOCK THIS PAGE DOWN WHEN WE RAISE IPL
;

LOCKPAGE:
	.BYTE	IPL$_SCS		; END OF LOCKED CODE REGION
	ASSUME	<.-100$> LE 512

	.DISABLE LOCAL_BLOCK

	.END
