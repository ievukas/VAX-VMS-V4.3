MODULE gencode4		(IDENT='V04-000',
			ADDRESSING_MODE(EXTERNAL=GENERAL))
= BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! Facility:	Command Definition Utility, Table Generator Module 4
!
! Abstract:	This module is one of a few modules that is responsible
!		for generating the blocks that make up a CLI table.
!		The blocks are generated by traversing the intermediate
!		representation of the CLD file created by the parsing
!		modules.
!
! Environment:	Standard CDU environment.
!
! Author:	Paul C. Anagnostopoulos
! Creation:	28 February 2983
!
! Modifications:
!
!	V04-001	BLS0338		Benn Schreiber		 9-AUG-1984
!		Count blocks created by generate_path in total table size
!
!--


library 'sys$library:lib';
require 'clitabdef';
require 'cdureq';

!	T A B L E   O F   C O N T E N T S
!	---------   ---   ---------------

forward routine
	cdu$generate_path: novalue,
	match_first_entity,
	match_remaining_entities,
	report_path_error: novalue;


!	E X T E R N A L   R E F E R E N C E S
!	---------------   -------------------

external routine
	cdu$lookup_child,
	cdu$remember_reference,
	cdu$report_semantic_error,
	lib$get_vm;

external
	cdu$gl_root_node: ref node,
	cdu$gl_table: pointer;

!	P A T H   S T A C K
!	-------   ---------

! The following items define the module-wide path stack, which is used to
! resolve an entity path into its complete entity hierarchy.

own
	path_stack_top: signed long,
	path_stack: vector[exp_k_max_path_entities,long];

! These two macros are used to push and pop the path stack.

macro
	push_path_stack(item) =
		(increment(path_stack_top);
		if .path_stack_top gequ exp_k_max_path_entities then
			signal(msg(cdu$_intpathstkov));
		path_stack[.path_stack_top] = item;
		) %,

	pop_path_stack =
		(decrement(path_stack_top)) %;


!	N O D E   M A N I P U L A T I O N   M A C R O S
!	-------   -----------------------   -----------

! The following macro is used to determine whether an arbitrary node
! represents an entity (i.e., a parameter, qualifier, or type keyword).

macro
	top_level_entity_node(a_node) =
		(.a_node[node_w_type] eqlu node_k_parameter or
		 .a_node[node_w_type] eqlu node_k_qualifier or
		 .a_node[node_w_type] eqlu node_k_keyword) %;

! The following macro is used to determine whether an arbitrary node is an
! entity node that matches a given name.  If there is a label node under
! it, then we try to match the label name.  Otherwise we try to match the
! entity name.

macro
	matching_entity(a_node,name_length,name_address) =
		(bind
			entity = a_node: node;

		if top_level_entity_node(entity) then (
			local
				entitys_label: ref node;

			! The node represents an entity.  Compare the
			! desired name to the label node, or entity node if
			! there is no label.

			if (entitys_label = cdu$lookup_child(entity,node_k_label)) neqa 0 then
				ch$eql(.entitys_label[node_b_text_length],entitys_label[node_t_text],
				       name_length,name_address,%x'00')
			else
				ch$eql(.entity[node_b_text_length],entity[node_t_text],
				       name_length,name_address,%x'00')
		) else

			! The node does not represent an entity.

			false
		) %;

! This macro is used to determine whether an arbitrary node represents an
! entity, and, if so, whether that entity references a type definition in
! its value clause.  The address of the node representing the type
! definition is returned.

macro
	type_reference(a_node) =
		(bind
			entity = a_node: node;
		local
			type: ref node;

		if top_level_entity_node(entity) then
			if (type = cdu$lookup_child(entity,node_k_value)) neqa 0 then
				if (type = cdu$lookup_child(.type,node_k_type_user)) neqa 0 then
					cdu$lookup_child(.cdu$gl_root_node,node_k_define_type,
						.type[node_b_text_length],type[node_t_text])
				else 0
			else 0
		else 0
		) %;

!++
! Description:	This routine is called to generate an expression block
!		that represents an entity path.  An entity path specifies a
!		hierarcy of entities, and is used in a boolean expression to
!		reference a specific entity (as in the DISALLOW clause).
!		Because the entity path can be elided, this routine must
!		resolve the path into a full entity hierarchy, beginning at
!		a parameter or qualifier and ending at the final keyword in
!		the path.
!
! Parameters:	definition	By reference, the node representing the verb
!				or syntax change definition that includes
!				the path.
!		path		By reference, the node representing the
!				path that we are to compile.  We will fill
!				in the TRO of the resulting block.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE cdu$generate_path(definition: ref node,
				 path: ref node)		: novalue
= BEGIN

bind
	first_child = .path[node_l_child]: node;

local
	context: ref node,
	first_entity: ref node,
	path_stack_mark: signed long,
	ambiguous: boolean initial(false),
	expression: pointer;
local
	saved_stack_top: signed long initial(-1),
	saved_stack: vector[exp_k_max_path_entities,long],
	saved_stack_mark: long;


! A path can include the name of a definition in which the entity hierarchy
! is to be resolved.  Or, if no such name is included, then it is to be
! resolved in the current definition.  See what the user wants to do.

if .first_child[node_w_type] eqlu node_k_path_definition then (

	! The user included an explicit definition name as the first element
	! in the path.  Find the node representing the definition.

	context = cdu$lookup_child(.cdu$gl_root_node,node_k_define_verb,
				.first_child[node_b_text_length],first_child[node_t_text]);
	if .context eqla 0 then
		context = cdu$lookup_child(.cdu$gl_root_node,node_k_define_syntax,
					.first_child[node_b_text_length],first_child[node_t_text]);
	if .context eqla 0 then (
		report_path_error(msg(cdu$_pathundef),.path);
		return;
	);

	! Remember the address of the node following the path definition node,
	! because this is the first entity we must match.

	first_entity = .first_child[node_l_sister];

) else (

	! No definition name was included, so use the current definition.

	context = .definition;

	! Remember the address of this first node, because this is the
	! first entity we must match.

	first_entity = first_child;
);

! Now we sit in a messy loop trying to resolve the entity path specified by
! the user.  It is resolved in the context of the definition we determined
! above.  The module-wide path stack will be used to search the definition's
! parameters, qualifiers, and type references.

path_stack_top = -1;
while match_first_entity(.context,.first_entity) do (

	! We have found a match on the first entity name and set up the
	! path stack accordingly.  Mark the stack so we can restore it to
	! this state later on.

	path_stack_mark = .path_stack_top;

	! See if we can match the remaining entities in the path, beginning
	! at the match we found.

	if match_remaining_entities(.first_entity[node_l_sister]) then (

		! Yup, we got a complete match and the path stack contains
		! the resolved entity hierarchy.  Decide if the match is
		! interesting.

		if .saved_stack_top eql -1 then (

			! This is the first match, so it's useful.  Save
			! the state of the path stack so we can use it
			! later.

			saved_stack_top = .path_stack_top;
			ch$move(%allocation(path_stack),path_stack, saved_stack);
			saved_stack_mark = .path_stack_mark;

		) else if .saved_stack_mark eqlu 0 then (

			! We already have a match, and it's one where the
			! first entity in the path matched a parameter or
			! qualifier.  Such a match takes precedence over
			! one where the first entity matched a type keyword.
			! What kind of match have we got now?

			if .path_stack_mark eqlu 0 then

				! Oops, the new match is also on a
				! parameter or qualifier.  That's ambiguous.

				ambiguous = true;

			! It appears that the new match is on a type
			! keyword.  Ignore it in favor of the saved one.

		) else (

			! The saved match is on a type keyword.  What does
			! the new one look like?

			if .path_stack_mark eqlu 0 then (

				! The new one is on a parameter or
				! qualifier, so it takes precedence.  Save
				! it as an unambiguous match.

				saved_stack_top = .path_stack_top;
				ch$move(%allocation(path_stack),path_stack, saved_stack);
				saved_stack_mark = .path_stack_mark;
				ambiguous = false;
			) else

				! The new one also matches on a type
				! keyword, so it's ambiguous.

				ambiguous = true;
		);
	);

	! Restore the path stack to its state when the first entity
	! was matched, thus flushing the entity hierarchy.  Then we can
	! loop for the next match (we need to look at all matches to
	! detect ambiguity).

	path_stack_top = .path_stack_mark;
);

! If no match was found, tell the user and forget it.

if .saved_stack_top eql -1 then (
	report_path_error(msg(cdu$_pathunres),.path);
	return;
);

! If more than one possible match was found, tell the user and forget it.

if .ambiguous then (
	report_path_error(msg(cdu$_pathambig),.path);
	return;
);

! OK, we have an unambiguous match on the path.  Create an expression block
! to contain the entity hierarchy.

allocate_largest_table_block(ent_k_length + (.saved_stack_top+1)*4, expression);

! Initialize the header of the expression block.

expression[exp_b_type] = block_k_expression;
expression[exp_b_subtype] = exp_k_path;
expression[exp_w_flags] = 0;
expression[exp_w_tro_count] = .saved_stack_top+1;

! Sit in a loop looking at each level in the path hierarchy.  Remember to
! resolve the final TRO of the associated entity block.

begin
bind
	entity_list = expression[exp_l_operand_list]: vector[,long];

incru i from 0 to .saved_stack_top do
	cdu$remember_reference(entity_list[.i],.saved_stack[.i]);
end;

! Fill in the final length of the expression block and add it's
! size to the table being created.

expression[exp_w_size] = exp_k_length + (.saved_stack_top+1)*4;
set_table_block_size(.expression[exp_w_size],expression);

! Store the TRO of this new expression block in its representing node.

path[node_l_code] = .expression - .cdu$gl_table;
return;

END;

!++
! Description:	This routine is called to find a match on the first entity in
!		a path specified by the user.  We perform a depth-first
!		search of all the entities under a given verb or syntax
!		definition, looking for an entity which matches that
!		specified by the user.  As we go, we maintain a path stack
!		that shows how we got down to the entity.
!
! Parameters:	path_definition	By reference, the node representing the verb
!				or syntax definition which is to be
!				searched.
!		path_entity	By reference, the node representing the
!				first entity in the path.
!
! Returns:	By value, a boolean which is true if we found a match.
!
! Notes:
!--

GLOBAL ROUTINE match_first_entity(path_definition: ref node,
				  path_entity: ref node)
= BEGIN

local
	type: ref node;


! The path stack is either empty, or it contains the entity hierarchy
! leading to the previous match.  Sit in a loop to find the next match.

loop (

	! If the stack is empty, begin searching the children of the
	! definition.  Otherwise, move on to the sister of the top entity
	! on the stack.

	if .path_stack_top eql -1 then
		push_path_stack(.path_definition[node_l_child])
	else (
		bind
			entity = .path_stack[.path_stack_top]: node;

		path_stack[.path_stack_top] = .entity[node_l_sister];
	);

	if .path_stack[.path_stack_top] neqa 0 then

		! If there is another node at this level, then we want to
		! search all of the type definitions below it.  Push the
		! first keyword node of each lower-level type definition
		! on the stack.

		while (type = type_reference(.path_stack[.path_stack_top])) neqa 0 do
			push_path_stack(.type[node_l_child])

	else

		! There isn't another node at this level, so pop the stack.

		pop_path_stack;

	! If the stack is empty, we're done searching.

	if .path_stack_top eql -1 then exitloop;

	! If the entity at the top of the stack matches the one we are
	! looking for, then we got a match.

	if matching_entity(.path_stack[.path_stack_top],
			   .path_entity[node_b_text_length],path_entity[node_t_text]) then
		return true;
);

! We searched the entire definition without finding a match.

return false;

END;

!++
! Description:	This routine is called to match all but the first entity in
!		a multilevel entity path, after the first entity has been
!		matched.  To constitute a match, the remaining entities
!		must match successively deeper levels of nested type
!		definitions.  As we go, we maintain a path stack that shows
!		how we got down to the final entity.
!
! Parameters:	path_entity	By reference, the node representing the
!				second entity in the path.  Its sisters
!				are the rest of the entities.
!
! Returns:	By value, a boolean which is true if a match is detected.
!
! Notes:
!--

GLOBAL ROUTINE match_remaining_entities(path_entity: ref node)
= BEGIN

local
	type: ref node,
	keyword: ref node;


! Sit in a loop looking at each of the remaining entities in the path.

while .path_entity neqa 0 do (

	! The entity on the top of the path stack must reference a type
	! definition in its value clause, or we can't possible match this
	! next entity.  Find that referencing node.

	type = type_reference(.path_stack[.path_stack_top]);
	if .type eqla 0 then
		return false;

	! We have a type definition referenced by the top entity on the
	! stack.  It must include a keyword that matches this next entity.
	! Find it.

	scan_children(type,keyword,
		if matching_entity(.keyword,.path_entity[node_b_text_length],
				   path_entity[node_t_text]) then exitloop;
	);
	if .keyword eqla 0 then
		return false;

	! The keyword represents the next level in the entity hierarchy for
	! this path, so push it on the path stack.

	push_path_stack(.keyword);

	! Go on to the next entity in the specified path.

	path_entity = .path_entity[node_l_sister];
);

! If we dropped out of that loop, then we got a match.

return true;

END;

!++
! Description:	This routine is called to report an error concerning a path.
!		The routine is needed because the path string must be
!		reconstructed from the intermediate representation.
!
! Parameters:	message		By value, a message status code used for the
!				message.  It is assumed to take a two $FAO
!				arguments, a !UL for the line number and a
!				!AS for the path string.
!		path		By reference, the top-level node
!				representing the path in error.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE report_path_error(message: long,
				 path: ref node)	: novalue
= BEGIN

local
	path_string: vector[tkn_k_max_length,byte],
	path_string_dsc: descriptor,
	index: long initial(0),
	child: ref node;


! Build the path string from the intermediate representation.
! If the first child of the path node is a path definition node,
! then the user specified an explicit definition.  Place it at the
! front of the string in angle brackets.

child = .path[node_l_child];
if .child[node_w_type] eqlu node_k_path_definition then (
	path_string[0] = '<';
	ch$move(.child[node_b_text_length],child[node_t_text], path_string[1]);
	index = 1 + .child[node_b_text_length];
	path_string[.index] = '>';
	increment(index);
	child = .child[node_l_sister];
);

! Now sit in a loop and concatenate all of the entity names onto the path
! string, with periods in between.

while .child neqa 0 do (
	ch$move(.child[node_b_text_length],child[node_t_text], path_string[.index]);
	index = .index + .child[node_b_text_length];
	path_string[.index] = '.';
	increment(index);
	child = .child[node_l_sister];
);

! Build a descriptor of the node string a report the error.

build_descriptor(path_string_dsc,.index-1,path_string);
cdu$report_semantic_error(.message,2,.path[node_w_line],path_string_dsc);

return;

END;

END
ELUDOM
