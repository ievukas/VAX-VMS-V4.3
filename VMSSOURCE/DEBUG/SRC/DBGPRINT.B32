MODULE DBGPRINT (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	March, 1982
!
! MODIFIED BY
!	V. Holt		May, 1982
!	PS		May, 1982
!	PS		Sep, 1982
!
! REVISION HISTORY
! 3.01  14-May-82	VJH	Added routine DBG$FLUSHBUF.  Needed to 
!				initialize buffer after error handling.
!
! 3.01  28-May-82	PS	Added DBG$PRINT_CONTROL function for DBG$PRINT.
!
! 3B    07-Sep-1982	PS	Added Print Primary Symbol Name Routines.
!
! 3B    01-Nov-1982	PS	Added Print language specific data routines
!
! 3B    11-Nov-1982     PS      Added Symbolization routines
!
! 3B-4	15-Sep-1983	WC3	Added updating of DBG$GL_CURRENT_PRIMARY for
!				self-referential records.
!
! MODULE FUNCTION
!	This module contains the DEBUG print formatting and output routines.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$FAO_OUT: NOVALUE,		! Output an FAO-formatted print line
    DBG$FORMAT_FAO_OUT: NOVALUE,	! Format an FAO-formatted print string
    DBG$FLUSHBUF:  NOVALUE,		! Initialize a new print line (without
					!      output)
    DBG$LANGUAGE_FORMAT,		! Print value according to language
    					!      specific format
    DBG$NEWLINE: NOVALUE,		! Output the current print buffer and
					!      initialize a new print line
    DBG$PRINT: NOVALUE,			! Output text to the print buffer using
					!      FAO formatting
    DBG$PRINT_CONTROL,			! Set indentations for DBG$PRINT
    DBG$PRINT_FIELD_REF: NOVALUE,	! Print <p,s,e> information
    DBG$PRINT_IDENTIFIER,		! Print name from a Primary or Volatile
    DBG$PRINT_IDENTIFIER_PC,		! Print name from address
    DBG$PRINT_OFFSET: NOVALUE,		! Print offset value in current radix
    DBG$PRINT_SET_VALUE: NOVALUE,	! Print Set Data
    DBG$PRINT_SET_LANGUAGE: NOVALUE,	! Set print info for current language
    DBG$PRINT_SYMBOL_NAME: NOVALUE,	! Print name of data item
    DBG$PRINT_SYMBOL_PATHNAME: NOVALUE,	! Print pathname of data item
    DBG$SET_MAX_LINE_WIDTH: NOVALUE,	! Set the maximum line width
    DBG$WRITE_LOG_FILE: NOVALUE,	! Write a line to the DEBUG log file
    DBG$WRITE_OUTPUT: NOVALUE,		! Write an output line to DBG$OUTPUT
					!      and to the log file (if any)
    GET_SUBSCRIPT_VALUE,		! Get array subscript value
    PRINT_PUSH;				! Push name string pointer on the stack
    					!      upwards or downwards

EXTERNAL ROUTINE
    DBG$COLLECT: NOVALUE,		! Sanitize character vectors
    DBG$FILL_IN_VMS_DESC,		! Fill in VMS Descriptor
    DBG$GET_DST_NAME,			! Get the name from DST record
    DBG$GET_MEMORY,			! Get a memory block
    DBG$GET_SET_TYPEID,			! Get the parent type of a set
    DBG$GET_TEMPMEM,			! Get temporary memory block
    DBG$MAKE_SKELETON_DESC,		! Create skeleton descriptor
    DBG$NEW_SYMBOLIZE,			! New symbolization routine
    DBG$NGET_RADIX,			! Get current radix
    DBG$NPATHDESC_TO_CS: NOVALUE,	! Print pathname from given pathname
    					!      descriptor
    DBG$PRIM_TO_VAL: NOVALUE,		! Turn primary into value
    DBG$PRINT_VALUE,			! Print value from descriptor
    DBG$PRINT_VALUE_AS_INTEGER: NOVALUE,! Print an absolute address
    DBG$REL_MEMORY,			! Release a memory block
    DBG$SCR_WRITE_LINE: NOVALUE,	! Write a line to a Screen Display
    DBG$STA_ADDRESS_TO_REGDESCR,	! Determine if a given address is a 
    					!      register address and returns a
    					!      register descriptor if it is
    DBG$STA_REGISTER_NAME,		! Return a pointer to a ASCIC string
    					!      containing the appropriate
    					!      register name
    DBG$SYMID_TO_PRIMARY,		! Return Primary Descriptor for the given
    					!      SYMID
    DBG$STA_SYMNAME: NOVALUE,		! Get name of data item
    DBG$STA_SYMPATHNAME: NOVALUE,	! Get fully-qualified data name
    DBG$STA_TYP_ATOMIC: NOVALUE,	! Get atomic data information
    DBG$STA_TYP_ENUM: NOVALUE,		! Get enumeration data information
    DBG$STA_TYP_SET: NOVALUE,		! Get set data information
    DBG$STA_TYP_SUBRNG: NOVALUE,	! Get subrange data information
    SYS$FAO,				! Formatter
    SYS$FAOL;				! Formatted ASCII Output routine to
					!      do text formatting

EXTERNAL
    DBG$GL_CURRENT_PRIMARY,		! Pointer to the primary being processed
    DBG$GB_VERB: BYTE,
    DBG$GL_CMND_RADIX,
    DBG$GB_RADIX: VECTOR[3, BYTE],	! Radix settings
    DBG$GL_OUTPRAB: BLOCK[,BYTE],	! RAB for DBG$OUTPUT
    DBG$GB_DEF_OUT: VECTOR[,BYTE],	! Output configuration vector
    DBG$GB_LANGUAGE: BYTE,		! Current language setting
    DBG$GB_MOD_PTR: REF VECTOR[,BYTE],	! Current mode settings
    DBG$GL_LOG_BUF,			! Pointer to log file's filespec
    DBG$GL_LOGRAB: BLOCK[,BYTE],	! RAB for LOG file
    DBG$GL_SCREEN_OUTPUT,		! Screen output Display ID or zero
    DBG$SRC_TERM_WIDTH;			! Terminal width


GLOBAL
    DBG$GL_ARRSUB_FLAG,			! Flag to indicate array subscripting
    DBG$GL_RECCMP_FLAG,			! Flag to indicate record component
    DBG$GL_SIGN_FLAG;			! Flag to indicate print '+' before
    					!	signed variables

LITERAL
    PRT$K_COMMON = 0,			! Dummy index
    RST$K_TYPE_COMMON = 0;		! Load in common print characters


OWN
    BUFFER_DESCR: VECTOR[2,LONG]	! Descriptor for temporary print
		INITIAL(132, 0),	!      buffer used in DBG$PRINT
    MAX_BRK_ON_BLANKS: INITIAL(0),	! Turn off the PRTBRK_ON_BLANKS flag,
					!      if the blank character position
					!      exceeds this size for this print
					!      line
    MAX_INDENT: INITIAL(0),		! Maximum indentation length.
    MAX_PBSIZE: INITIAL(131),		! Maximum number of characters which
					!      may be filled into print buffer
    PBSIZE: INITIAL(0),			! Current number of characters filled
					!      into the print buffer
    PRINT_BUFFER: VECTOR[132,BYTE],	! The DEBUG print buffer
    PRT_CONTINUE: INITIAL(FALSE),	! Flag set for continuation lines
    PRT_INDENT: INITIAL(0),		! Total indentation length
    PRTSET_CONTINUE: INITIAL(0),	! Continuation indentation length
    PRTSET_MARGIN: INITIAL(0),		! Left margin (for DBG$PRINT buffer)
    PRTBRK_ON_BLANKS: INITIAL(0);	! A flag to indicate break on blanks

MACRO
    GET_VALUE(VALUE) =


! This macro is used in DBG$PRINT_IDENTIFIER.
!
    	IF NOT .SUBOVF
    	THEN
    	    SUBOVF = GET_SUBSCRIPT_VALUE(NAMEPTR, UPLIT BYTE(%ASCIC '!SL'), 
		.VALUE)

    	ELSE
    	    GET_SUBSCRIPT_VALUE(NAMEPTR, UPLIT BYTE(%ASCIC '!SL'), .VALUE);%;

MACRO
    PRINT_OFFSETS_AND_RETURN =


! This macro is used in DBG$PRINT_IDENTIFIER. It prints out the offset
! and/or bit-field information, as in X+offset or X<p,s,e>.
! It then must decide whether to return the original Value Descriptor or the
! constructed Primary Descriptor to DBG$EXAMINE. The general idea is
! that if we have an exact symbolization match, then return the Primary
! so that the value displayed will be of the correct type.
!
    	BEGIN


    	! Print the byte offset if it was present. If there was a byte offset,
    	! then we did not have an exact match so return the Value Descriptor.
    	!
    	IF .BYTE_OFFSET NEQ 0
    	THEN
    	    DBG$PRINT_OFFSET(.BYTE_OFFSET);


	! Print the <p,s,e> information if it was present.
    	!
    	IF .VAL_DESC NEQ 0 
    	THEN
    	    BEGIN
    	    IF .BIT_OFFSET NEQ 0 
    	    THEN 
    		DBG$PRINT_FIELD_REF(.VAL_DESC)
    	    ELSE
    	        IF (.PRIM_DESC[DBG$B_DHDR_KIND] NEQ RST$K_DATA) AND
    		   (.PRIM_DESC[DBG$B_DHDR_KIND] NEQ RST$K_TYPCOMP)
    	        THEN
    		    DBG$PRINT_FIELD_REF(.VAL_DESC)
    		ELSE
    		    BEGIN
    		    LOCAL 
    		        TMP_VALDESC: REF DBG$VALDESC;
    	            DBG$PRIM_TO_VAL(.PRIM_DESC, DBG$K_V_VALUE_DESC, TMP_VALDESC);
    		    IF .SAVE_VAL_LENGTH NEQ .TMP_VALDESC[DBG$W_VALUE_LENGTH]
    		    THEN
    		        DBG$PRINT_FIELD_REF(.VAL_DESC);
    		    END;
    	    
    	    ! Put back the original type and length.
    	    !
    	    IF .SAVE_VAL_DTYPE NEQ 0
    	    THEN
    		BEGIN
    		VAL_DESC[DBG$B_VALUE_DTYPE] = .SAVE_VAL_DTYPE;
    		VAL_DESC[DBG$W_VALUE_LENGTH] = .SAVE_VAL_LENGTH;
    		END;

    	    IF .VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV
    	    OR .VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU
    	    OR .VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V
    	    OR .VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU
    	    THEN
    		RETURN .VAL_DESC;
    	    END;


    	! If there is no value descriptor or exact match.
    	!
	IF  .VAL_DESC EQL 0 
    	OR  (.BYTE_OFFSET EQL 0 AND .BIT_OFFSET EQL 0)
    	THEN
    	    BEGIN
    	    DBG$COLLECT(.PRIM_DESC);
    	    RETURN .PRIM_DESC;
    	    END;

    	RETURN .VAL_DESC;
    	END%;

!	M A C R O S   T O   G E N E R A T E   P R I N T   T A B L E S
!
!
!
!	These macros are used to generate the print tables used by the
!	Print Primary Symbol Name routines to print both language-independent
!	and language-specific constructs accepted by DEBUG.
!
BIND
    TABLEBASE = UPLIT BYTE(%ASCII 'BASE');


! PRINT CHARACTER TABLE
!
!
! The Print Character Table has a set of entries to define print characters
! to be used in printing for a given language.  For example, subscript 
! character in PASCAL is [, in FORTRAN is (.  A Print Character Table is
! declared as follows:
!
!	PRINT_CHAR_TABLE(TBLNAME,
!		PRINT_CHAR_ENTRY(CODE, NAMESTRING),
!		...
!		PRINT_CHAR_ENTRY(CODE, NAMESTRING));
!
! Here TBLNAME is the name of the Print Character Table.  NAMESTRING is the
! ASCII string which constitutes the print character(s), CODE is the name
! of the print character.  In some languages, for the same purpose may
! have different codes, for example, in C, Pointer can be *P or P->X.A
!
MACRO
    PRINT_CHAR_TABLE(TBLNAME) =
    	OWN	TBLNAME : VECTOR[PRT$K_MAX_PRTCHAR, LONG]
    		PSECT(DBG$PLIT) PRESET(%REMAINING) %;

MACRO
    PRINT_CHAR_ENTRY(CODE, NAMESTRING) =
    	[%NAME ('PRT$K_', CODE, '_CHAR')] = 
    		UPLIT BYTE(%ASCIC NAMESTRING) - TABLEBASE %;


! PRINT INFORMATION TABLE
!
!
! The Print Information Table for a language is a blockvector indexed by
! FCODE.  For each FCODE, it gives the print routine index, and the
! address of the corresponding Print Character Table.  All addresses are
! relative to TABLEBASE.  A Print Information Table is declared as follows:
!
!	PRINT_INFO_TABLE(TBLNAME,
!		PRINT_INFO_ENTRY(FCODE, ROUT_INDEX, PRINT_CHAR_TABLE),
!		...
!		PRINT_INFO_ENTRY(FCODE, ROUT_INDEX, PRINT_CHAR_TABLE);
!
! Here TBLNAME is the name of the Print Information Table.  ROUT_INDEX is
! the Print Routine for the given FCODE.  PRINT_CHAR_TABLE points to
! Print Character Table which contains language-specific print characters
! for the given FCODE.
!
MACRO
    PRINT_INFO_TABLE(TBLNAME) =
    	%IF %LENGTH EQL 1
    	%THEN
    	    OWN TBLNAME: PRTINFO$TABLE PSECT(DBG$PLIT)
    			 INITIAL(REP RST$K_TYPE_MAXIMUM OF (0))
    	%ELSE
	    OWN	TBLNAME : PRTINFO$TABLE PSECT(DBG$PLIT) PRESET(%REMAINING)
    	%FI %;

MACRO
    PRINT_INFO_ENTRY(FCODE, ROUT_INDEX, CHARTBL) =
    	[%NAME ('RST$K_TYPE_', FCODE), PRTINFO$L_ROUT_INDEX] =
    		%NAME ('PRT$K_', ROUT_INDEX),
    	[%NAME ('RST$K_TYPE_', FCODE), PRTINFO$L_CHARTBL] = 
    		CHARTBL - TABLEBASE %;


! TABLE OF LANGUAGE-SPECIFIC TABLES
!
! Define the macro which builds the table of pointers to the language-specific
! print tables.  Each pointer is relative to TABLEBASE.  The macro is used as
! follows:
!
!	LANGUAGE_PRINT_TABLES(LANGUAGE = language-name,
!		INFO_TABLE = Print Information Table,
!		INFO_FLAG  = Print Information Flag true-or-false,
!		REFMOD_FLAG = Reference Modifier Flag true-or-false,
!		ARRSUB_FLAG = Array Subscript Flag true-or-false,
!		RECCMP_FLAG = Record Component Flag true-or-false),
!		SIGN_FLAG   = Print '+' for signed variables Flag true-or-false);
!
! Note: One of these days those flags should be changed to bit instead of long
!       word.
!
! Here INFO_FLAG is an  indicator to indicate how we want the name to be printed.  
! For example, record component Y in record X, in PASCAL, we print it as X.Y 
! (flag sets to TRUE), in COBOL, we print it as Y OF X (flag sets to FALSE).
! REFMOD_FLAG is an indicator to indicate how we want the reference modifier
! to be printed.  For example, in FORTRAN (begin:end) (flag sets to TRUE), 
! in COBOL (begin:length) (flag sets to FALSE).  ARRSUB_FLAG is used to
! indicate whether the language has array concept or not.  (similar idea with
! RECCMP_FLAG).  These flags primarily are used for symbolization purposes.
! ie, using fortran program, set lang to macro, which macro does not understand
! the array, so we'll print address+offset instead of arr(i,j).  SIGN_FLAG
! is used for the language to print out '+' before the signed variables.
! 
!
KEYWORDMACRO
    LANGUAGE_PRINT_TABLES(LANGUAGE=UNKNOWN,
    			  INFO_TABLE=TABLEBASE,
    			  INFO_FLAG=TRUE,
    			  REFMOD_FLAG=TRUE,
    			  ARRSUB_FLAG=TRUE,
    			  RECCMP_FLAG=TRUE,
    			  SIGN_FLAG = FALSE) =
    	BIND %NAME(LANGUAGE, '_PRINT_TABLE') =
    		UPLIT (INFO_TABLE - TABLEBASE,
    		       INFO_FLAG,
    		       REFMOD_FLAG,
    		       ARRSUB_FLAG,
    		       RECCMP_FLAG,
    		       SIGN_FLAG): VECTOR[,LONG] %;

!		A D A   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the ADA symbols.
!
!
!
! Define the ADA Language Print Tables.
!
PRINT_CHAR_TABLE(ADA_COMMON_CHAR,
	PRINT_CHAR_ENTRY(BEGIN, '('),
	PRINT_CHAR_ENTRY(SEPARATOR, '..'),
	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(ADA_ARRAY_CHAR,
	PRINT_CHAR_ENTRY(BEGIN, '('),
	PRINT_CHAR_ENTRY(SEPARATOR, ','),
	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(ADA_POINTER_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '.ALL'));

PRINT_CHAR_TABLE(ADA_RECORD_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '.'));

PRINT_INFO_TABLE(ADA_INFO_TABLE,
	PRINT_INFO_ENTRY(COMMON, COMMON, ADA_COMMON_CHAR),
	PRINT_INFO_ENTRY(ARRAY, ARRAY, ADA_ARRAY_CHAR),
	PRINT_INFO_ENTRY(TPTR, POINTER, ADA_POINTER_CHAR),
	PRINT_INFO_ENTRY(FILE, POINTER, ADA_POINTER_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD, ADA_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, ADA_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = ADA,
	INFO_TABLE = ADA_INFO_TABLE,
	INFO_FLAG = TRUE,
	REFMOD_FLAG = TRUE);

!		B A S I C   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the BASIC symbols.
!
!
!
! Define the BASIC Language Print Tables.
!
PRINT_CHAR_TABLE(BASIC_COMMON_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(BASIC_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(BASIC_RECORD_CHAR,
    	PRINT_CHAR_ENTRY(SEPARATOR, '::'));

PRINT_INFO_TABLE(BASIC_INFO_TABLE,
    	PRINT_INFO_ENTRY(COMMON, COMMON, BASIC_COMMON_CHAR),
    	PRINT_INFO_ENTRY(ARRAY, ARRAY, BASIC_ARRAY_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD, BASIC_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, BASIC_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = BASIC,
    	INFO_TABLE = BASIC_INFO_TABLE,
    	INFO_FLAG = TRUE,
    	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = FALSE);

!		B L I S S   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the BLISS symbols.
!
!
!
! Define the BLISS Language Print Tables.
!
PRINT_CHAR_TABLE(BLISS_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '['),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ']'));

PRINT_INFO_TABLE(BLISS_INFO_TABLE,
    	PRINT_INFO_ENTRY(ARRAY, ARRAY, BLISS_ARRAY_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = BLISS,
    	INFO_TABLE = BLISS_INFO_TABLE,
    	INFO_FLAG = TRUE,
    	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = FALSE,
    	SIGN_FLAG = FALSE);

!		C   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the C symbols.
!
!
!
! Define the C Language Print Tables.
!
PRINT_CHAR_TABLE(C_COMMON_CHAR,
	PRINT_CHAR_ENTRY(BEGIN, '['),
	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
	PRINT_CHAR_ENTRY(END, ']'));

PRINT_CHAR_TABLE(C_ARRAY_CHAR,
	PRINT_CHAR_ENTRY(BEGIN, '['),
	PRINT_CHAR_ENTRY(SEPARATOR, ']['),
	PRINT_CHAR_ENTRY(END, ']'));

PRINT_CHAR_TABLE(C_POINTER_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '*'),
	PRINT_CHAR_ENTRY(RECPTR, '->'));

PRINT_CHAR_TABLE(C_RECORD_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '.'));

PRINT_INFO_TABLE(C_INFO_TABLE,
	PRINT_INFO_ENTRY(COMMON, COMMON, C_COMMON_CHAR),
	PRINT_INFO_ENTRY(ARRAY, ARRAY, C_ARRAY_CHAR),
	PRINT_INFO_ENTRY(TPTR, POINTER_C, C_POINTER_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD_C_PLI, C_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, C_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = C,
	INFO_TABLE = C_INFO_TABLE,
	INFO_FLAG = TRUE,
	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = FALSE);

!		C O B O L   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the COBOL symbols.
!
!
!
! Define the COBOL Language Print Tables.
!
PRINT_CHAR_TABLE(COBOL_COMMON_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(COBOL_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(COBOL_RECORD_CHAR,
    	PRINT_CHAR_ENTRY(SEPARATOR, ' of '));

PRINT_INFO_TABLE(COBOL_INFO_TABLE,
	PRINT_INFO_ENTRY(COMMON, COMMON, COBOL_COMMON_CHAR),
	PRINT_INFO_ENTRY(ARRAY, ARRAY, COBOL_ARRAY_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD_COB, COBOL_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, COBOL_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = COBOL,
    	INFO_TABLE = COBOL_INFO_TABLE,
    	INFO_FLAG = FALSE,
    	REFMOD_FLAG = FALSE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = TRUE);

!		F O R T R A N   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the FORTRAN symbols.
!
!
!
! Define the FORTRAN Language Print Tables.
! 
PRINT_CHAR_TABLE(FORTRAN_COMMON_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(FORTRAN_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(FORTRAN_RECORD_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '.'));

PRINT_INFO_TABLE(FORTRAN_INFO_TABLE,
    	PRINT_INFO_ENTRY(COMMON, COMMON, FORTRAN_COMMON_CHAR),
    	PRINT_INFO_ENTRY(ARRAY, ARRAY, FORTRAN_ARRAY_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD, FORTRAN_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = FORTRAN,
    	INFO_TABLE = FORTRAN_INFO_TABLE,
    	INFO_FLAG = TRUE,
    	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = FALSE);

!		M A C R O   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the MACRO symbols.
!
!
!
! Define the MACRO Language Print Tables.
!
PRINT_INFO_TABLE(MACRO_INFO_TABLE);

LANGUAGE_PRINT_TABLES(LANGUAGE = MACRO,
    	INFO_TABLE = MACRO_INFO_TABLE,
    	INFO_FLAG = TRUE,
    	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = FALSE,
    	RECCMP_FLAG = FALSE,
    	SIGN_FLAG = FALSE);

!		P A S C A L   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the PASCAL symbols.
!
!
!
! Define the PASCAL Language Print Tables.
!
PRINT_CHAR_TABLE(PASCAL_COMMON_CHAR,
	PRINT_CHAR_ENTRY(BEGIN, '['),
	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
	PRINT_CHAR_ENTRY(END, ']'));

PRINT_CHAR_TABLE(PASCAL_ARRAY_CHAR,
	PRINT_CHAR_ENTRY(BEGIN, '['),
	PRINT_CHAR_ENTRY(SEPARATOR, ','),
	PRINT_CHAR_ENTRY(END, ']'));

PRINT_CHAR_TABLE(PASCAL_POINTER_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '^'));

PRINT_CHAR_TABLE(PASCAL_RECORD_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '.'));

PRINT_INFO_TABLE(PASCAL_INFO_TABLE,
	PRINT_INFO_ENTRY(COMMON, COMMON, PASCAL_COMMON_CHAR),
	PRINT_INFO_ENTRY(ARRAY, ARRAY, PASCAL_ARRAY_CHAR),
	PRINT_INFO_ENTRY(TPTR, POINTER, PASCAL_POINTER_CHAR),
	PRINT_INFO_ENTRY(FILE, POINTER, PASCAL_POINTER_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD, PASCAL_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, PASCAL_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = PASCAL,
	INFO_TABLE = PASCAL_INFO_TABLE,
	INFO_FLAG = TRUE,
	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = FALSE);

!		P L I   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the PLI symbols.
!
!
!
! Define the PLI Language Print Tables.
!
PRINT_CHAR_TABLE(PLI_COMMON_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(PLI_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(PLI_POINTER_CHAR,
    	PRINT_CHAR_ENTRY(SEPARATOR, '->'));

PRINT_CHAR_TABLE(PLI_RECORD_CHAR,
    	PRINT_CHAR_ENTRY(SEPARATOR, '.'));

PRINT_INFO_TABLE(PLI_INFO_TABLE,
	PRINT_INFO_ENTRY(COMMON, COMMON, PLI_COMMON_CHAR),
	PRINT_INFO_ENTRY(ARRAY, ARRAY, PLI_ARRAY_CHAR),
	PRINT_INFO_ENTRY(PTR, POINTER, PLI_POINTER_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD_C_PLI, PLI_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, PLI_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = PLI,
    	INFO_TABLE = PLI_INFO_TABLE,
    	INFO_FLAG = TRUE,
    	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = FALSE);

!		R P G   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print the RPG symbols.
!
!
!
! Define the RPG Language Print Tables.
!
PRINT_CHAR_TABLE(RPG_COMMON_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ':'),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(RPG_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ')'));


PRINT_INFO_TABLE(RPG_INFO_TABLE,
	PRINT_INFO_ENTRY(COMMON, COMMON, RPG_COMMON_CHAR),
	PRINT_INFO_ENTRY(ARRAY, ARRAY, RPG_ARRAY_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = RPG,
    	INFO_TABLE = RPG_INFO_TABLE,
    	INFO_FLAG = FALSE,
    	REFMOD_FLAG = FALSE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = FALSE,
    	SIGN_FLAG = FALSE);

!		U N K N O W N   P R I N T   T A B L E S
!
!
!
!	This section includes all the tables needed to print language
!	UNKNOWN symbols.
!
!
!
! Language UNKNOWN has records and arrays.  Define print syntax for them
! which corresponds to syntax given in DBGPARSER.
!
PRINT_CHAR_TABLE(UNKNOWN_ARRAY_CHAR,
    	PRINT_CHAR_ENTRY(BEGIN, '('),
    	PRINT_CHAR_ENTRY(SEPARATOR, ','),
    	PRINT_CHAR_ENTRY(END, ')'));

PRINT_CHAR_TABLE(UNKNOWN_RECORD_CHAR,
    	PRINT_CHAR_ENTRY(SEPARATOR, '.'));

PRINT_CHAR_TABLE(UNKNOWN_POINTER_CHAR,
	PRINT_CHAR_ENTRY(SEPARATOR, '^'));

PRINT_INFO_TABLE(UNKNOWN_INFO_TABLE,
	PRINT_INFO_ENTRY(ARRAY, ARRAY, UNKNOWN_ARRAY_CHAR),
	PRINT_INFO_ENTRY(TPTR, POINTER, UNKNOWN_POINTER_CHAR),
	PRINT_INFO_ENTRY(FILE, POINTER, UNKNOWN_POINTER_CHAR),
	PRINT_INFO_ENTRY(RECORD, RECORD, UNKNOWN_RECORD_CHAR),
	PRINT_INFO_ENTRY(VARIANT, VARIANT, UNKNOWN_RECORD_CHAR));

LANGUAGE_PRINT_TABLES(LANGUAGE = UNKNOWN,
    	INFO_TABLE = UNKNOWN_INFO_TABLE,
    	INFO_FLAG = TRUE,
    	REFMOD_FLAG = TRUE,
    	ARRSUB_FLAG = TRUE,
    	RECCMP_FLAG = TRUE,
    	SIGN_FLAG = FALSE);

!	T A B L E   O F   P O I N T E R S   T O   L A N G U A G E   T A B L E S
!
!
!
!	This section contains the table of pointers to the language-specific
!	tables of print table pointers.  In other words, this table is indexed
!	by language code to yield a pointer (relative to TABLEBASE) to the
!	table of table pointers build by the LANGUAGE_PRINT_TABLES macro
!	for the individual language above.
!
!
! Define the table of pointers to language-specific tables.
!
OWN
    LANGUAGE_PRINT_TABLE_PTRS:
		VECTOR[DBG$K_MAX_LANGUAGE + 1, LONG] PSECT(DBG$PLIT) PRESET(

	[DBG$K_MACRO]	= MACRO_PRINT_TABLE   - TABLEBASE,	! MACRO
	[DBG$K_FORTRAN]	= FORTRAN_PRINT_TABLE - TABLEBASE,	! FORTRAN
	[DBG$K_BLISS]	= BLISS_PRINT_TABLE   - TABLEBASE,	! BLISS
	[DBG$K_COBOL]	= COBOL_PRINT_TABLE   - TABLEBASE,	! COBOL
	[DBG$K_BASIC]	= BASIC_PRINT_TABLE   - TABLEBASE,	! BASIC
	[DBG$K_PLI]	= PLI_PRINT_TABLE     - TABLEBASE,	! PLI
	[DBG$K_PASCAL]	= PASCAL_PRINT_TABLE  - TABLEBASE,	! PASCAL
	[DBG$K_C]	= C_PRINT_TABLE       - TABLEBASE,	! C
	[DBG$K_RPG]	= RPG_PRINT_TABLE     - TABLEBASE,	! RPG
	[DBG$K_ADA]	= ADA_PRINT_TABLE     - TABLEBASE,	! ADA
	[DBG$K_UNKNOWN]	= UNKNOWN_PRINT_TABLE - TABLEBASE);	! UNKNOWN

FIELD PRTID$STACK_FLD_DEF =
    	SET
    	PRTID$STACK_PTR = [0, L_],	! Pointer 
    	PRTID$STACK_FLAG = [4, B0_]	! Flag set to indicate PTR field is
    					!	a pointer to value descritptor
    	TES;				! 	and pointer to ASCIC string

LITERAL
    	PRINT_STACK_SIZE = 100,		! Stack size for the print name stack
    	PRINT_STACK_START = 60;		! Start stack pointer

MACRO 
        PRTID$STACK = BLOCKVECTOR[PRINT_STACK_SIZE, 5, BYTE]
    			FIELD (PRTID$STACK_FLD_DEF) %;


GLOBAL ROUTINE DBG$FAO_OUT(STRING, ARGUMENTS) : NOVALUE =
!
! FUNCTION
!	This routine formats an output string using FAO and writes the
!	formatted string to DBG$OUTPUT and the log file (if any).  FAO
!	(Formatted ASCII Output--see the System Services Manual) does the
!	formatting via a call on SYS$FAOL.  The formatted text string is
!	then written out by routine DBG$WRITE_OUTPUT.
!
! INPUTS
!	STRING		- The address of a Counted ASCII FAO control string.
!
!	ARGUMENTS	- Zero or more arguments to be applied to the FAO
!			  control string.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	STRING: REF VECTOR[,BYTE];	! Address of FAO control string

    LOCAL
	BUFFER: VECTOR[132,BYTE],	! Buffer to hold output string from
					!      SYS$FAOL call
	INP_DESC: VECTOR[2,LONG],	! String descriptor for input buffer
	LENGTH: WORD,			! Length of SYS$FAOL output string
	OUT_DESC: VECTOR[2,LONG];	! String descriptor for SYS$FAOL
					!      output buffer



    ! Set up the descriptors needed for the SYS$FAOL call.  Then call SYS$FAOL
    ! to format the text string and call DBG$WRITE_OUTPUT to actually output
    ! the string to DBG$OUTPUT and the log file, if any.
    !
    INP_DESC [0] = .STRING [0];
    INP_DESC [1] = STRING [1];
    OUT_DESC [0] = 131;
    OUT_DESC [1] = BUFFER;
    SYS$FAOL(INP_DESC, LENGTH, OUT_DESC, ARGUMENTS);
    DBG$WRITE_OUTPUT(.LENGTH, BUFFER);
    RETURN;

    END;

GLOBAL ROUTINE DBG$FORMAT_FAO_OUT(BUF_DESC, STRING, ARGUMENTS) : NOVALUE =
!
! FUNCTION
!	This routine formats an output string using SYS$FAOL.
!
! INPUTS
!	BUF_DESC - Output buffer String Descriptor.
!
!	STRING - The address of a Counted ASCII FAO control string.
!
!	ARGUMENTS - Zero or more arguments to be applied to the FAO control
!		  string.
!
! OUTPUTS
!	NONE


    BEGIN

    MAP
    	BUF_DESC: REF VECTOR[,LONG],	! Output buffer string descriptor
    	STRING: REF VECTOR[,BYTE]; 	! Address of FAO control string

    LOCAL
    	INP_DESC: VECTOR[2,LONG],	! String descriptor for input buffer
    	OUT_DESC: VECTOR[2,LONG],	! String descriptor for output buffer
    	OUTLEN: WORD,			! Length of SYS$FAOL output string
    	STATUS;				! Status code returned by SYS$FAOL



    ! Set up the descriptors needed for the SYS$FAOL call.
    !
    INP_DESC[0] = .STRING[0];
    INP_DESC[1] = STRING[1];
    OUT_DESC[0] = .BUF_DESC[0];
    OUT_DESC[1] = .BUF_DESC[1];
    STATUS = SYS$FAOL(INP_DESC, OUTLEN, OUT_DESC, ARGUMENTS);


    ! Update the output string length and pointer.  Then return.
    !
    BUF_DESC[0] = .OUT_DESC[0] - .OUTLEN;
    BUF_DESC[1] = .OUT_DESC[1] + .OUTLEN;
    RETURN;

    END;

GLOBAL ROUTINE DBG$FLUSHBUF: NOVALUE =
!
! FUNCTION
!	This routine flushes the current print line as built up with calls
!	on DBG$PRINT and initializes the print buffer to start a new line.
!	This is accomplished by setting PBSIZE (the print buffer size) to
!	zero so that a new empty print line is initialized.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN



    ! Flush the current contents of PRINT_BUFFER by resetting PBSIZE to zero.
    !
    PBSIZE = 0;
    RETURN;

    END;

GLOBAL ROUTINE DBG$LANGUAGE_FORMAT(VALPTR) =
!
! FUNCTION
!	This routine prints the value in a given Value Descriptor according to
!	a language-specific formatting rule if such a rule exists.  Otherwise
!	the value is not printed and the routine returns FALSE to indicate this.
!
! INPUTS
!	VALPTR	- Pointer to value descriptor containing the value to be
!		  printed in a language-specific format.
!
! OUTPUTS
!	This routine returns TRUE if the value was printed according to a
!		  language-specific formatting rule.  It returns FALSE if
!		  there is no language-specific formatting rule to print it;
!		  in this case the value was not printed.
!

    BEGIN

    MAP
    	VALPTR: REF DBG$VALDESC;	! Pointer to value descriptor



    ! If the kind is not data, then do not use language-specific rules.
    ! Note - components of records as in A.B come back with kind TYPCOMP,
    ! and this is also data.
    !
    IF (.VALPTR [DBG$B_DHDR_KIND] NEQ RST$K_DATA) AND
       (.VALPTR [DBG$B_DHDR_KIND] NEQ RST$K_TYPCOMP)
    THEN
    	RETURN FALSE;


    ! Case on the FCODE to select the approriate language-specific formatting
    ! rule.
    !
    CASE .VALPTR[DBG$B_DHDR_FCODE] FROM RST$K_TYPE_MINIMUM
    				   TO   RST$K_TYPE_MAXIMUM OF
    	SET

    	! Atomic data items, and items described by descriptor.
    	!
        [RST$K_TYPE_ATOMIC, RST$K_TYPE_DESCR]:

    		! Case on language.
    		!
    		CASE .DBG$GB_LANGUAGE FROM DBG$K_MIN_LANGUAGE
    					TO DBG$K_MAX_LANGUAGE OF
    		    SET

    		    ! For language PL/I we want to display bitstrings
    		    ! in the format '101011100'B, for example.
    		    !
    		    [DBG$K_PLI]:
    			IF (.VALPTR[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU) OR
    			   (.VALPTR[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V) OR
    			   (.VALPTR[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_TF)
    			THEN
    			    BEGIN
    			    LOCAL
    				PTR: REF BITVECTOR[],
    			  	START;
    			    DBG$PRINT(UPLIT BYTE(%ASCIC ''''));
    			    PTR = .VALPTR[DBG$L_VALUE_POINTER];
    			    IF .VALPTR[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS
    			    THEN
    				START = .VALPTR[DBG$L_VALUE_POS]
    			    ELSE
    				START = 0;
    			    INCR I FROM .START 
    				   TO .START+.VALPTR[DBG$W_VALUE_LENGTH]-1 DO
    				IF .PTR[.I]
    				THEN
    				    DBG$PRINT(UPLIT BYTE(%ASCIC '1'))
    				ELSE
    				    DBG$PRINT(UPLIT BYTE(%ASCIC '0'));
    			    DBG$PRINT(UPLIT BYTE(%ASCIC '''B'));
    			    RETURN TRUE;
    			    END;

    		    ! Other languages - no special rules.
    		    !
    		    [INRANGE]: 0;
    			
    		    ! We do not expect any other language codes here,
    		    ! so report an error if we see one.
    		    !
    		    [OUTRANGE]:
    			$DBG_ERROR('DBGPRINT\DBG$LANGUAGE_FORMAT');

    		    TES;


    	! Other FCODEs - just fall through and return FALSE.
    	!
    	[INRANGE]: 0;


    	! If kind is data, FCODE should be in the range of the
    	! CASE statement.
    	!
    	[OUTRANGE]:
    	    $DBG_ERROR('DBGPRINT\DBG$LANGUAGE_FORMAT');

    	TES;


    ! No language-specific formatting rule exists for this language and FCODE.
    ! We therefore return FALSE to indicate the value was not formatted at all.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$NEWLINE: NOVALUE =
!
! FUNCTION
!	This routine prints the current print line as built up with calls
!	on DBG$PRINT and initializes the print buffer to start a new line.
!	This is accomplished by calling DBG$WRITE_OUTPUT to output the current
!	contents of PRINT_BUFFER and then resetting PBSIZE (the print buffer
!	size) to zero so that a new empty print line is initialized.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LENGTH;				! Length of output buffer


    ! Print the current contents of PRINT_BUFFER and reset its size to zero.
    !
    LENGTH = .PBSIZE;
    PBSIZE = 0;
    PRT_CONTINUE = FALSE;
    DBG$WRITE_OUTPUT(.LENGTH, PRINT_BUFFER);
    RETURN;

    END;

GLOBAL ROUTINE DBG$PRINT(FAOSTRING, ARGUMENTS): NOVALUE =
!
! FUNCTION
!	This routine is the DEBUG print formatting routine.  It accepts an
!	FAO (Formatted ASCII Output--see the System Services Manual) control
!	string which specifies how the output formatting is to be done and
!	it accepts zero or more additional arguments as called for in the
!	FAO control string.  It calls SYS$FAOL to format the text and then
!	moves the formatted text to the DEBUG print buffer (PRINT_BUFFER).
!
!	Note, however, that the formatted output is not actually printed
!	unless the print buffer overflows.  To force the current print buffer
!	to be printed, one must call the DBG$NEWLINE routine.  DBG$PRINT can
!	thus be called repeatedly to build up the print buffer one piece at a
!	time, after which DBG$NEWLINE is called to actually output the now
!	completed print line.
!
!	If a DBG$PRINT call overflows the print buffer, the filled buffer is
!	output to the current output device (or screen display) and the over-
!	flow text is filled into the beginning of the buffer.  The effect is
!	that oversized print lines are folded on the user's output device.
!
!	Before this routine is called, you can call DBG$PRINT_CONTROL to set
!	up the proper indentation specifications.
!
! INPUTS
!	FAOSTRING - The address of an FAO control string represented as
!		  Counted ASCII.  This string contains text and FAO format-
!		  ting directives of the form "!xx" which define how the
!		  output text should be formatted.
!
!	ARGUMENTS - Zero or more FAO arguments.  These arguments must corre-
!		  spond in kind and number to the formatting directives in
!		  the FAO control string.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	FAOSTRING: REF VECTOR[,BYTE];	! FAO control string

    LOCAL
	BUFFER_PTR: REF VECTOR[,BYTE],	! Pointer to FAO formatting buffer
	FAOSTRING_DESC: VECTOR[2,LONG],	! FAO control string descriptor
	FOUND_BLANK_FLAG,		! Flag set when blank is found in back-
					!      ward scan for blank to break on
	LENGTH,				! Length of string copied at one time
					!      to PRINT_BUFFER from temp buffer
	MAX_LINE_LENGTH,		! Maximum print buffer size
	SAVEBUF: VECTOR[132, BYTE],	! Save buffer for text after the last
					!      blank if text is broken on blank
	SAVEBUF_LEN,			! The current length of SAVEBUF text
	STATUS,				! Status code returned by SYS$FAOL
	STR_SIZE: WORD;			! String size returned by SYS$FAOL



    ! Call SYS$FAOL to format the desired ASCII string.  If the output buffer
    ! we give to SYS$FAOL is too small, we increase its size and loop until it
    ! is large enough to contain the output string.
    !
    FAOSTRING_DESC[0] = .FAOSTRING[0];
    FAOSTRING_DESC[1] = FAOSTRING[1];
    WHILE TRUE DO
	BEGIN
	IF .BUFFER_DESCR[1] EQL 0
	THEN
	    BUFFER_DESCR[1] = DBG$GET_MEMORY(.BUFFER_DESCR[0]/%UPVAL);

	STATUS = SYS$FAOL(FAOSTRING_DESC, STR_SIZE, BUFFER_DESCR, ARGUMENTS);
	IF .STATUS EQL SS$_NORMAL THEN EXITLOOP;
	IF .STATUS NEQ SS$_BUFFEROVF
	THEN
	    $DBG_ERROR('DBGPRINT\DBG$PRINT 10 ', .STATUS);


	! Make sure the buffer size won't get over 2100 bytes.  (This allows
	! strings up to 2000 bytes plus a symbol name.)
	!
	IF .BUFFER_DESCR[0] GTR 2100
	THEN
	    BEGIN
	    BUFFER_DESCR[0] = 2100;
	    SIGNAL(DBG$_STGTRUNC);
	    EXITLOOP;
	    END;

	DBG$REL_MEMORY(.BUFFER_DESCR[1]);
	BUFFER_DESCR[1] = 0;
	BUFFER_DESCR[0] = .BUFFER_DESCR[0] + 100;
	END;


    ! Move the newly formatted text to PRINT_BUFFER.  If the new text would
    ! overflow PRINT_BUFFER, move over as much as will fit, output the buffer
    ! by calling DBG$WRITE_OUTPUT, and loop to move the remaining text into
    ! the print buffer.
    !
    MAX_LINE_LENGTH = MIN(.DBG$SRC_TERM_WIDTH, .MAX_PBSIZE);
    BUFFER_PTR = .BUFFER_DESCR[1];
    WHILE TRUE DO
	BEGIN


	! If the print buffer is full, output its contents before we get more
	! text from the FAO formatting buffer.
	!
	IF .PBSIZE GEQ .MAX_LINE_LENGTH
	THEN
	    BEGIN


	    ! If the Break-on-Blanks flag is set, we try to break the line on
	    ! the last blanks before the end of the line.  This prevents num-
	    ! bers and names from being broken in the middle, if possible.
	    !
	    SAVEBUF_LEN = 0;
	    IF .PRTBRK_ON_BLANKS
	    THEN
		BEGIN


		! Loop backward over the print buffer to locate the last blank
		! in the line and the last non-blank before that.
		!
		FOUND_BLANK_FLAG = FALSE;
		DECR I FROM .PBSIZE - 1 TO 0 DO
		    BEGIN


		    ! If we have already found a blank in the scan, set PBSIZE
		    ! to include all text up to the current character.  If the
		    ! current character is non-blank, stop the backward scan.
		    !
		    IF .FOUND_BLANK_FLAG
		    THEN
			BEGIN
			PBSIZE = .I + 1;
			IF .PRINT_BUFFER[.I] NEQ ' ' THEN EXITLOOP;
			END


		    ! We have not yet found a blank.  If this character is the
		    ! first blank, save all text after it in SAVEBUF and set
		    ! the found-a-blank flag.
		    !
		    ELSE IF .PRINT_BUFFER[.I] EQL ' '
		    THEN
			BEGIN
			SAVEBUF_LEN = .PBSIZE - .I - 1;
			CH$MOVE(.SAVEBUF_LEN, PRINT_BUFFER[.I + 1], SAVEBUF[0]);
			FOUND_BLANK_FLAG = TRUE;
			END


		    ! If we have not yet found a blank but are already below
		    ! the maximum backward scan index, exit the loop without
		    ! having found a place to break on.  In this case, the
		    ! line is not broken on a blank.
		    !
		    ELSE IF .I LSS .MAX_BRK_ON_BLANKS
		    THEN
			EXITLOOP;

		    END;		! End of loop to break line on blanks

		END;			! End of PRTBRK_ON_BLANKS If statement


	    ! Now output the formatted print line to the output device.
	    !
	    DBG$WRITE_OUTPUT(.PBSIZE, PRINT_BUFFER);


	    ! Indent the print buffer for the next line of text.  Also copy
	    ! over any text that remained from the previous line if that line
	    ! was broken on the last blank.
	    !
	    PRT_CONTINUE = TRUE;
	    PBSIZE = .PRT_INDENT + .PRTSET_CONTINUE;
	    CH$FILL(' ', .PBSIZE, PRINT_BUFFER[0]);
	    IF .SAVEBUF_LEN GTR 0
	    THEN
		BEGIN
		CH$MOVE(.SAVEBUF_LEN, SAVEBUF[0], PRINT_BUFFER[.PBSIZE]);
		PBSIZE = .PBSIZE + .SAVEBUF_LEN;
		END;

	    END;			! End of code to output print buffer


	! If this is a new text line, indent the line by the current indenta-
	! tion amount.  Note that a continuation line can be indented more.
	!
	IF .PBSIZE EQL 0 
	THEN 
	    BEGIN
	    PBSIZE = .PRT_INDENT;
	    IF .PRT_CONTINUE THEN PBSIZE = .PBSIZE + .PRTSET_CONTINUE;
	    CH$FILL(' ', .PBSIZE, PRINT_BUFFER[0]);
	    END;


	! Move the next section of text from the FAO buffer into the print
	! buffer and adjust the print buffer size accordingly.  As this is
	! done, all tabs are expanded to blanks to produce a completely
	! de-tabbed print buffer.
	!
	INCR I FROM 0 TO .STR_SIZE - 1 DO
	    BEGIN
	    STR_SIZE = .STR_SIZE - 1;


	    ! If the current character is a tab, we expand it to blanks.
	    !
	    IF .BUFFER_PTR[0] EQL DBG$K_TAB
	    THEN
		BEGIN
		LENGTH = MIN(8 - (.PBSIZE MOD 8), .MAX_LINE_LENGTH - .PBSIZE);
		CH$FILL(' ', .LENGTH, PRINT_BUFFER[.PBSIZE]);
		PBSIZE = .PBSIZE + .LENGTH;
		END


	    ! And if it is not a tab, we simply copy it over.
	    !
	    ELSE
		BEGIN
		PRINT_BUFFER[.PBSIZE] = .BUFFER_PTR[0];
		PBSIZE = .PBSIZE + 1;
		END;


	    ! Increment the FAO formatting buffer pointer by one.  Then, if we
	    ! are about to overflow the print buffer, we exit the copy loop.
	    ! Otherwise, we loop for the next character.
	    !
	    BUFFER_PTR = .BUFFER_PTR + 1;
	    IF .PBSIZE GEQ .MAX_LINE_LENGTH THEN EXITLOOP;

	    END;			! End of copy and de-tab loop


	! See how much input text we have left.  If there is none, exit this
	! print loop.  Otherwise, we loop to move the text that remains in the
	! FAO formatting buffer into the print buffer.
	!
	IF .STR_SIZE EQL 0 THEN EXITLOOP;

	END;				! End of WHILE loop over print lines


    ! The formatted text is now in PRINT_BUFFER.  Return control.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$PRINT_CONTROL =
!
! FUNCTION
!	This routine sets up the indentation levels for the print buffer used
!	in DBG$PRINT, so that when text overflows the print buffer, the 
!	remaining text can be indented according to the given specifications.
!
! INPUTS
!	Can be any numbers of input parameters, separated by commas.  The first
!	parameter has to be one of the following Print Control Codes: 
!	DBG$K_PRTSET_LMARGIN, DBG$K_PRTSET_RLMARGIN, DBG$K_PRTBRK_ON_BLANKS, 
!	DBG$K_PRTSET_CONTINUE, and DBG$K_PRT_RESET.  
!
!	Valid parameters are:
!	   DBG$K_PRTSET_LMARGIN followed by a value (0, or +)
!	   DBG$K_PRTSET_RLMARGIN followed by a value (0, +, or -)
!	   DBG$K_PRTBRK_ON_BLANKS
!	   DBG$K_PRTSET_CONTINUE followed by a value (0 or +)
!	   DBG$K_PRT_RESET
!	
!       Default for above parameters are:
!	   DBG$K_PRESET_LMARGIN			PRTSET_LMARGIN = 0
!	   DBG$K_PRESET_RLMARGIN		PRTSET_RLMARGIN = 0
!	   DBG$K_PRTSET_ON_BLANKS		PRTSET_ON_BLANKS = FALSE
!	   DBG$K_PRTSET_CONTINUE		PRTSET_CONTINUE = 0
!
! OUTPUTS
!	Return TRUE or FALSE status code to the caller.  TRUE means the
!		  given indentation is properly set.  FALSE means the
!		  previous indentation remains set.
!

    BEGIN

    BUILTIN
	ACTUALCOUNT,			! The number of actual parameter
	ACTUALPARAMETER;		! Select the N-th actual parameter

    LOCAL
	BRK_ON_BLANKS,			! Flag set to break on blanks at the end
	CONTINUE,			! Indentation for continuation line
	MARGIN,				! Left margin for print buffer
	PARAMCNT;			! The number of input parameters


    ! Initialization.
    !
    PARAMCNT = 0;
    MARGIN = .PRTSET_MARGIN;
    CONTINUE = .PRTSET_CONTINUE;
    BRK_ON_BLANKS = .PRTBRK_ON_BLANKS;


    ! Loop through the input parameters.  Perform the proper operation
    ! for each input parameter according to the Print Control Code.
    !
    WHILE .PARAMCNT LSS ACTUALCOUNT() DO
	BEGIN
	PARAMCNT = .PARAMCNT + 1;


	! Get the input parameter.  Case on the Print Control Code and perform
	! the proper print control operation.
	!
	CASE ACTUALPARAMETER(.PARAMCNT) FROM DBG$K_PRTSET_LMARGIN
							TO DBG$K_PRT_RESET OF
	    SET


	    ! Set the left margin.  We need to get one more input parameter
	    ! to set the left margin value.
	    !
	    [DBG$K_PRTSET_LMARGIN]:
		BEGIN
		PARAMCNT = .PARAMCNT + 1;
		IF .PARAMCNT GTR ACTUALCOUNT()
		THEN
		    $DBG_ERROR('DBGPRINT\DBG$PRINT_CONTROL, err. 10');

		MARGIN = ACTUALPARAMETER(.PARAMCNT);
		END;


	    ! Set margin relative to current setting.  We need to get one more
	    ! input parameter to set the relative margin value.
	    !
	    [DBG$K_PRTSET_RLMARGIN]:
		BEGIN
		PARAMCNT = .PARAMCNT + 1;
		IF .PARAMCNT GTR ACTUALCOUNT()
		THEN
		    $DBG_ERROR('DBGPRINT\DBG$PRINT_CONTROL, err. 10');

		MARGIN = .MARGIN + ACTUALPARAMETER(.PARAMCNT);
		END;


	    ! Set Flag to indicate to break on blanks at the end of the print 
	    ! line.
	    !
	    [DBG$K_PRTBRK_ON_BLANKS]:
		BRK_ON_BLANKS = TRUE;


	    ! Set more indentation margin for continued print line.  We need to
	    ! have one more input parameter for this Print Control Code.
	    !
	    [DBG$K_PRTSET_CONTINUE]:
		BEGIN
		PARAMCNT = .PARAMCNT + 1;
		IF .PARAMCNT GTR ACTUALCOUNT()
		THEN
		    $DBG_ERROR('DBGPRINT\DBG$PRINT_CONTROL, err. 10');

		CONTINUE = ACTUALPARAMETER(.PARAMCNT);
		END;
		

	    ! Reset all the indentations.
	    !
	    [DBG$K_PRT_RESET]:
		BEGIN
		MARGIN = 0;
		CONTINUE = 0;
		BRK_ON_BLANKS = FALSE;
		END;


	    ! We do not recognize this Print Control Code.
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGPRINT\DBG$PRINT_CONTROL, err. 20');

	    TES;


	! We have got an apparently valid parameter. Check that the
	! indentation limits are valid.
	!
	IF (.CONTINUE LSS 0) OR (.MARGIN LSS 0) OR
	  ((.MARGIN + .CONTINUE) GEQ MIN(.DBG$SRC_TERM_WIDTH,.MAX_PBSIZE))
	THEN
	    RETURN FALSE;

	END;				! End of WHILE loop over the parameters


    ! All the parameters were valid.  Set the permanent print control values.
    !
    PRTSET_MARGIN = .MARGIN;
    PRTSET_CONTINUE = .CONTINUE;
    PRTBRK_ON_BLANKS = .BRK_ON_BLANKS;


    ! Calculate the maximum indentation size.  If the new margin is greater
    ! than this size, use this size instead.
    !
    MAX_INDENT = MIN(.DBG$SRC_TERM_WIDTH, .MAX_PBSIZE) / 2;
    PRT_INDENT = MIN(.MAX_INDENT, .PRTSET_MARGIN);


    ! Calculate the maximum break on blanks size.  We use this value to stop
    ! the search for blanks when we later search for blanks backwards from
    ! end of the print buffer.  Then return.
    !
    MAX_BRK_ON_BLANKS = .PRT_INDENT + (.DBG$SRC_TERM_WIDTH - .PRT_INDENT) / 2;
    RETURN TRUE;

    END;

GLOBAL ROUTINE DBG$PRINT_FIELD_REF(VAL_DESC, TF_FLAG) : NOVALUE =
! 
! FUNCTION
!	This routine prints the field reference information as in X<p,s,e>.
!	It is called from DBG$PRINT_IDENTIFIER and from DBG$EVALUATE (in
!	the EVAL/ADDR code).  If the address passed as a Value Descriptor
!	to this routine represents a bit-field, then the "<p,s,e>" informa-
!	tion is filled into the output buffer via DBG$PRINT.
!
! INPUTS
!	VAL_DESC - A pointer to a volatile value descriptor representing
!		  the address to be printed.
!
!	TF_FLAG	- An optional flag, which if present and TRUE, indicates that
!		  we want to see field info for type TF.
!
! OUTPUTS
!	NONE
!

    BEGIN

    BUILTIN
    	ACTUALCOUNT;			! The number of actual parameters

    MAP
    	VAL_DESC: REF DBG$VALDESC;	! Pointer to input Value Descriptor

    LOCAL
    	FLAG;

    IF ACTUALCOUNT() LSS 2
    THEN
    	FLAG = FALSE

    ELSE
    	FLAG = .TF_FLAG;


    ! Check whether the Value Descriptor represents a bit-field.
    ! If so, print the <p,s,e> information.
    !
    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV)  OR
       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU) OR
       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V)   OR
       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU)  OR
       (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS) OR
       (.FLAG AND (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_TF))
    THEN
        BEGIN


	! We have a bit-field.  We now print the "<p,s,e>" information unless
	! the bitfield just happens to cover a byte-aligned longword.
	!
    	IF NOT (.VAL_DESC[DBG$L_VALUE_POS] EQL 0 AND
    		.VAL_DESC[DBG$W_VALUE_LENGTH] EQL 32)
    	THEN
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE (%ASCIC '<'));
    	    DBG$PRINT(UPLIT BYTE (%ASCIC '!UL'), .VAL_DESC[DBG$L_VALUE_POS]);
    	    DBG$PRINT(UPLIT BYTE (%ASCIC ','));
    	    DBG$PRINT(UPLIT BYTE (%ASCIC '!UW'), .VAL_DESC[DBG$W_VALUE_LENGTH]);
    	    DBG$PRINT(UPLIT BYTE (%ASCIC ','));
    	    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV) OR
    	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU)
    	    THEN
    	        DBG$PRINT(UPLIT BYTE (%ASCIC '1>'))

    	    ELSE
    	        DBG$PRINT(UPLIT BYTE (%ASCIC '0>'));

    	    END;

    	END;


    ! We are now done.  Return to the caller.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$PRINT_IDENTIFIER(PRIM_DESC) =
!
! FUNCTION
!	This routine takes a primary descriptor or turns volatile value descriptor
!	into primary descriptor + offset, then based on the language code
!	in the primary descriptor and the print format code, prints out the
!	primary symbol name + offset.  If there is no symbolization can be
!	done, (address --X--> primary + offset) then absolute address will
!	be printed.
! 
! INPUTS
!	PRIM_DESC	- Pointer to Primary Descriptor or Value Descriptor.
!
!	argument2	- Print Format Code.
!			  Format Code 0: data component name, single data name
!			  Format Code 1: data name
!			  Format code 2: M\R\data name
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP	
    	PRIM_DESC: REF DBG$PRIMARY;	! Pointer to Primary Root Node

    BUILTIN 
    	ACTUALCOUNT,			! The number of actual parameters
	ACTUALPARAMETER;		! Select the N-th actual parameter

    LITERAL
    	DESCR_SIZE = 20;		! Buffer size in bytes

    BIND
    	BACK_SLASH = UPLIT BYTE(%ASCIC '\'): VECTOR[,BYTE];

    LOCAL
    	ADDRESS: VECTOR[2, LONG],	! Address descriptor byte and offset
    	ARRAY_FLAG,			! Flag set to indicate array subscript
    					!	begin is already printed
	BITLEN,				! Bit length of array element
    	BIT_OFFSET,			! Bit offset from SYMID
	BYTE_OFFSET,			! Byte offset from the Primary Descriptor
    	BOTTOM,				! Bottom of the stack
    	CHAR_TABLE: REF VECTOR[,LONG],  ! Pointer to Print Character Table
    	FCODE,				! Format Code
    	FORMAT,				! Print Format for Primary Symbols
    	HERE,				! Temporary stack pointer
    	INFO_FLAG,			! Print Information Flag
    	INFO_TABLE: REF PRTINFO$TABLE,	! Pointer to Print Information Table
    	KIND,				! Symid's kind
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to a Counted string
	NEXT_NODE: REF DBG$PRIM_NODE,	! Next Sub-Node in Primary Descriptor
    	PATHNAME: REF PTH$PATHNAME,	! Pointer to Pathname Descriptor
    	PATHNAME_FLAG,			! Flag set to true to indicate we
    					! 	have a pathname
	REFMOD_FLAG,			! Reference Modifier Flag
    	PRIM_HEAD,			! Address of Sub-Node list head in Root
	PRIM_NODE: REF DBG$PRIM_NODE,	! Pointer to Primary Sub-Node
    	PTR: REF VECTOR[,LONG],		! Pointer to print language tables
    	PTR_FLAG,			! Flag set to indicate the pointer is
    					!	encountered
    	REGDESCR: REF DBG$REGDESCR,	! Pointer to register descriptor
    	SAVE_VAL_DTYPE,			! Saved Dtype from Value Descriptor
    	SAVE_VAL_LENGTH,		! Saved Length from Value Descriptor
    	SYMID: REF RST$ENTRY,		! Pointer to SYMID
	STACK: PRTID$STACK,		! A blockvector of pointers
    	STKOVF,				! Flag set to indicate stack overflow
    	SUBOVF,				! Flag set to indicate overflow
    	SUBVECTOR: 			! Pointer to subscript block-vector
    		REF DBG$PRIM_NODE_SUBS,	!	in Primary Descr Array Sub-Node
    	TOP,				! Top of the stack
    	TYPEID: REF RST$ENTRY,		! Pointer to TYPEID
    	VALPTR: REF DBG$VALDESC,	! Pointer to value descriptor
    	VALUE,				! Temporary variable
    	VAL_DESC: REF DBG$VALDESC,	! Value descriptor
	VMS_DESC: BLOCK [8,BYTE];	! A VMS descriptor


    ! First we set up some print flags by the current language setting.
    !
    DBG$PRINT_SET_LANGUAGE(.DBG$GB_LANGUAGE);


    ! Volatile Value Descriptors.  We do our best to symbolize this absolute
    ! address back to primary, or primary+offset.  If we cannot symbolize it
    ! at all then we print it as absolute address.
    !
    VAL_DESC = 0;
    BYTE_OFFSET = 0;
    BIT_OFFSET = 0;
    IF .PRIM_DESC[DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC
    THEN
	BEGIN
    	VAL_DESC = .PRIM_DESC;
    	SAVE_VAL_DTYPE = 0;
    	SAVE_VAL_LENGTH = .VAL_DESC[DBG$W_VALUE_LENGTH];

    	! First we try to see if the given address is a register address.
    	! If it is, a register descriptor is returned.  Then DBG$STA_REGISTER_NAME
    	! is called to converts the register descriptor into a counted ASCII
    	! name.  Otherwise, DBG$STA_GETSYMOFF is called.
    	!
    	! Note: The correct logic should call DBG$STA_GETSYMOFF first, if every-
    	! thing failed then try to see if the given address is a register 
    	! address.  If it fails, then print it as an absolute address.
    	! Currently, DBG$STA_GETSYMOFF tries to symbolize a given address in 
    	! DBG$REG_VALUES and returns the first SYMID found bound to that
    	! register.  Symbolization needs to associate the scope with the register.
    	! Till this piece of code is in place, we'll not symbolize the register
    	! address.  We'll just print it and immediately return.
    	!
    	REGDESCR = DBG$STA_ADDRESS_TO_REGDESCR(.VAL_DESC[DBG$L_VALUE_POINTER]);
    	IF .REGDESCR NEQ 0
    	THEN
    	    BEGIN
    	    NAMEPTR = DBG$STA_REGISTER_NAME(.REGDESCR);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .NAMEPTR);
    	    RETURN .VAL_DESC;
    	    END;


	! The address is not a register address.  We thus try to symbolize it,
	! but only if we are in symbolic mode.
	!
	IF .DBG$GB_MOD_PTR[MODE_SYMBOLS]
	THEN
	    BEGIN
	    ADDRESS[0] = .VAL_DESC[DBG$L_VALUE_POINTER];
	    IF .VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS
	    THEN
		ADDRESS[1] = .VAL_DESC[DBG$L_VALUE_POS]

	    ELSE
		ADDRESS[1] = 0;

	    DBG$NEW_SYMBOLIZE (ADDRESS, SYMID, BIT_OFFSET);
	    END


	! We are in non-symbolic mode, so we set SYMID to zero.
	!
	ELSE
	    SYMID = 0;


	! If we cannot symbolize it, we print it as an absolute address and
	! then return to the caller.
	!
	IF .SYMID EQL 0
	THEN
	    BEGIN


	    ! Build a VMS Descriptor of type longword unsigned, which
	    ! is the type for absolute addresses. 
	    !
	    VMS_DESC[DSC$B_CLASS] = DSC$K_CLASS_Z;
	    VMS_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_LU;
	    VMS_DESC[DSC$W_LENGTH] = 4;
	    VMS_DESC[DSC$A_POINTER] = VAL_DESC[DBG$L_VALUE_POINTER];
	    DBG$PRINT_VALUE_AS_INTEGER(VMS_DESC);


	    ! If this is a bit substring, print the angle brackets with the
	    ! offset, length, and sign extension information.  Then return.
	    !
	    DBG$PRINT_FIELD_REF(.VAL_DESC);
	    RETURN .VAL_DESC;
	    END;


	! We can symbolize it, so we build a Primary Descriptor from the
	! SYMID and offset.  
	!
    	! Note: there is one case here we need to pay special attention to.
    	! I'll use an example to explain.  If you say,
    	!
    	! E FAT_RECORD<6,10,0> what we got is a volatile value descriptor
    	! comes into this routine, with the Class UBS, one of the Dtype
    	! SV, SVU, V, VU, and Byte address for FAT_RECORD, Bit offset and
    	! length.  When we symbolize the address to symid to primary, and
    	! some bit offsets, we know the fact that we need to print bit offsets
    	! to the primary from the given CLASS UBS, and DTYPE SV, SVU, V, VU.  
    	! The following code gets these information based on these facts.  
    	! So, we'll print it M\R\FAT_RECORD.BG2<1,0,0>: 40, say the address 
    	! of FAT_RECORD.BG2 is 7FFAF4D7<5,11,0>.
    	!
    	! Now, consider another case,  If you say,
    	! E 7FFAF4D8 (this is FAT_RECORD.BG2 + some offsets).  Since the
    	! volatile value descriptor for this address has Class S, Dtype
    	! L, length 4.  So after we turn the symid to primary, we forgot
    	! the fact that we really have bit offsets to the primary for there
    	! are no CLASS and DTYPE to drive this information out.
    	!
    	! SAVE_VAL_DTYPE is the hack to do the trick.  In order words,
    	! now that we know we have bit offsets to primary, we plung in
    	! Dtype V to the value descriptor to do the bit offset symbolization.
    	! After we are done we put the orignal back.  The reason we do not
    	! put in the primary is see the first example, since we do not
    	! build primary with the offsets for FAT_RECORD<6,10,0> case, there
    	! is not a consistent way for this routine to build that way.
    	! We'll change it later if there is a need.
    	!
    	! If the above case showed up, we always print the length zero.
    	! SAVE_VAL_LENGTH is used to saved the original length.  So the
    	! original value descriptor can be returned back.
    	!
	PRIM_DESC = DBG$SYMID_TO_PRIMARY(.SYMID, BIT_OFFSET);
	IF .BIT_OFFSET NEQ 0
	THEN
	    BEGIN
    	    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV)  OR
    	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU) OR
    	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V)   OR
    	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU)  OR
    	       (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
    	    THEN
    		SAVE_VAL_DTYPE = 0

    	    ELSE


    		! Note: This trick only applies to the item that does
    		! not have a byte offset.
    		!
    		BEGIN
	        IF (.BIT_OFFSET - ((.BIT_OFFSET / 8) * 8)) NEQ 0
    		THEN
    		    BEGIN
    		    SAVE_VAL_DTYPE = .VAL_DESC[DBG$B_VALUE_DTYPE];
    		    VAL_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_V;
    		    VAL_DESC[DBG$W_VALUE_LENGTH] = 8 * .VAL_DESC[DBG$W_VALUE_LENGTH];
    		    END

    		ELSE
    		    SAVE_VAL_DTYPE = 0;
    		END;

	    BYTE_OFFSET = .BIT_OFFSET / 8;
	    BIT_OFFSET = .BIT_OFFSET - .BYTE_OFFSET * 8;
	    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV)  OR
	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU) OR
	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V)   OR
	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU)  OR
    	       (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
	    THEN
		BEGIN
		IF .BIT_OFFSET EQL 0
		THEN
		    BEGIN
		    IF .VAL_DESC[DBG$W_VALUE_LENGTH] LSS 32
		    THEN
			BEGIN
			BIT_OFFSET = .BYTE_OFFSET * 8;
			BYTE_OFFSET = 0;
			END;

		    END;

		END;

	    END;


	! Adjust the offset for printing.
	!
	IF .BIT_OFFSET NEQ 0
	THEN
	    BEGIN
	    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV)  OR
	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU) OR
	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V)  OR
	       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU) OR
    	       (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
	    THEN
		VAL_DESC[DBG$L_VALUE_POS] = .BIT_OFFSET;

	   END;

	END;				! End of code for Volatile Value Descr.


    ! Set up the Primary Symbol Print Format.  For example:
    !     Format 0 - X or (2)     
    !     Format 1 - A.X or A(2)  
    !	  Format 2 - M\R\A or M\R\A.X or M\R\A(2)
    !
    FORMAT = 2;
    IF ACTUALCOUNT() GTR 1 THEN FORMAT = MINU(ACTUALPARAMETER(2), 2);
    IF .FORMAT EQL 2
    THEN
    	DBG$STA_SYMPATHNAME(.PRIM_DESC[DBG$L_DHDR_SYMID0], PATHNAME);


    ! Output the none-data (code) item.
    !
    IF .PRIM_DESC[DBG$B_DHDR_FCODE] EQL 0
    THEN
    	BEGIN
    	IF .FORMAT LSS 2
    	THEN
    	    DBG$STA_SYMNAME(.PRIM_DESC[DBG$L_DHDR_SYMID0], NAMEPTR)

    	ELSE
    	    DBG$NPATHDESC_TO_CS(.PATHNAME, NAMEPTR);

    	DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .NAMEPTR);
    	PRINT_OFFSETS_AND_RETURN;
    	END;
    	    

    ! Data items are language-dependent.  Load in Language Print Table
    ! according to the language code in the Root Node.  Set up the stack
    ! pointers.  This stack grows two ways, so we set up TOP and BOTTOM
    ! pointers relative to STACK_START.
    !
    PTR = .LANGUAGE_PRINT_TABLE_PTRS[.PRIM_DESC[DBG$B_DHDR_LANG]] + TABLEBASE;
    INFO_TABLE = .PTR[0] + TABLEBASE;
    INFO_FLAG = .PTR[1];
    REFMOD_FLAG = .PTR[2];
    TOP = BOTTOM = PRINT_STACK_START;
    ARRAY_FLAG = FALSE;
    PTR_FLAG = FALSE;
    STKOVF = FALSE;
    SUBOVF = FALSE;
    PATHNAME_FLAG = 0;


    ! Start from the Primary Root Node, following the forward linked list,
    ! get to Sub-Nodes which describe the individual components of the symbol
    ! described by the Primary Descriptor.  Save the Address of Sub-Node
    ! list head in root, and some other information.
    !
    PRIM_HEAD = PRIM_DESC[DBG$A_PRIM_FLINK];
    PRIM_NODE = .PRIM_HEAD;
    WHILE TRUE DO
	BEGIN


	! Link to the next Primary Descriptor Sub-Node in the list.  If that
	! takes us back to the list head, exit the loop.
	!
	PRIM_NODE = .PRIM_NODE[DBG$L_PNODE_FLINK];
	IF .PRIM_NODE EQLA .PRIM_HEAD THEN EXITLOOP;


    	! Go ahead and get the Primary Symbol's name.  Check to see if this
    	! symbol is the first symbol in the node; if it is, then check to see
    	! if this symbol needs a pathname (as determined by the FORMAT param-
	! eter).  If so, get the full pathname in Counted ASCII, and if not,
	! just get the individual symbol name.
    	!
    	IF .PRIM_NODE[DBG$L_PNODE_SYMID] EQL .PRIM_DESC[DBG$L_DHDR_SYMID0]
    	THEN
    	    BEGIN
    	    DBG$STA_SYMNAME(.PRIM_NODE[DBG$L_PNODE_SYMID], NAMEPTR);


    	    ! Make a note that this symbol has M\R pathname only.
    	    !
    	    IF .NAMEPTR[0] EQL 0 THEN PATHNAME_FLAG = 1;
    	    IF .FORMAT GEQ 2
    	    THEN
    		BEGIN
    	        DBG$NPATHDESC_TO_CS(.PATHNAME, NAMEPTR);


    		! So far, this is only affect cobol.
    		!
    		! Push Pathname (M\R) and \ (In this case, there is no data name,
    		! indicated by PATHNAME_FLAG set to 1).  After we have done
    		! this, we set the PATHNAME_FLAG to 2 to indicate the next
    		! data name needs to go after \ (need to put it at the bottom
    		! of the stack).  
		! 
		IF .PATHNAME_FLAG EQL 1
		THEN
	    	    BEGIN
	    	    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, BACK_SLASH);
	    	    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
		    PATHNAME_FLAG = 2;


    		    ! Since we have done a push, go get one more data node.
    		    !
    		    PRIM_NODE = .PRIM_NODE[DBG$L_PNODE_FLINK];
    	    	    IF .PRIM_NODE[DBG$L_PNODE_SYMID] NEQ 0
    	    	    THEN
    	        	DBG$STA_SYMNAME(.PRIM_NODE[DBG$L_PNODE_SYMID], NAMEPTR)

    	            ELSE
    		        NAMEPTR = 0;
		    END;
    		END;

    	    END


	! This is not the first symbol in the full name, so we do not need the
	! full pathname.  Just get the individual symbol name if one exists.
	!
    	ELSE
    	    BEGIN
    	    IF .PRIM_NODE[DBG$L_PNODE_SYMID] NEQ 0
    	    THEN
    	        DBG$STA_SYMNAME(.PRIM_NODE[DBG$L_PNODE_SYMID], NAMEPTR)

    	    ELSE
    		NAMEPTR = 0;

    	    END;


    	! Get each node's FCODE.  Based on the FCODE, load in proper print
    	! characters and print routine index.
    	!
    	FORMAT = (IF .FORMAT EQL 0 THEN FALSE ELSE TRUE);
    	FCODE = .PRIM_NODE[DBG$B_PNODE_FCODE];
    	CHAR_TABLE = .INFO_TABLE[.FCODE, PRTINFO$L_CHARTBL] + TABLEBASE;
    	CASE .INFO_TABLE[.FCODE, PRTINFO$L_ROUT_INDEX] FROM PRT$K_MIN_ROUT
    					               TO   PRT$K_MAX_ROUT OF
    	    SET


    	    ! General data item name, it fcode is not one of the following
    	    ! for example, ARRAY, or RECORD, or Pointer.
	    !
    	    [PRT$K_OTHER]:
    		BEGIN
    		IF .PATHNAME_FLAG EQL 2
    		THEN
    		    BEGIN
    		    STKOVF = PRINT_PUSH(FALSE, STACK, BOTTOM, .NAMEPTR);
    		    PATHNAME_FLAG = 3;
    		    END

    		ELSE
    		    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
    		END;


    	    ! Print Array.
	    !
    	    [PRT$K_ARRAY]:
    		BEGIN


    		!  If the pathname_flag set to 2, we always push the name
    		!  at the bottom of the stack after the \.  After the operation
    		!  set the flag to 3 to indiate the operation is back to normal.
    		!
		IF .PATHNAME_FLAG EQL 2
		THEN
	    	    BEGIN
	    	    STKOVF = PRINT_PUSH(FALSE, STACK, BOTTOM, .NAMEPTR);
	    	    PATHNAME_FLAG = 3;
		    END

    		ELSE
    		    BEGIN


    		    ! Get the name of the array if the Print Format Code is not 0.
    		    !
    		    IF .PRIM_NODE[DBG$V_PNODE_EVAL]
    		    THEN
    		        BEGIN
		        IF .FORMAT
    		        THEN
	                    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);

    		        END

    		    ELSE
	    	        STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
    		    END;


    		! Get the array subscripts.  There are two way of getting it:
    		! In COBOL, array subscripts are printed at the end of the
    		! name string, where in other languages, array subscripts are
    		! printed along with the array name.  This is indicated by
    		! INFO_FLAG.  For example, flag sets to FALSE for COBOL.
    		!
    		IF (NOT .FORMAT AND
    		    .PRIM_NODE[DBG$V_PNODE_EVAL] AND
    		    ..PRIM_NODE[0,0,32,0] EQL .PRIM_HEAD) OR
    		   (.FORMAT AND
    		    .PRIM_NODE[DBG$V_PNODE_EVAL])
    		THEN
    		    BEGIN


    		    ! Set Pathname_flag back to 0 to indicate we should be
    		    ! all done with our funny business of pushing the
    		    ! the data name after pathname\.
    		    !
    		    PATHNAME_FLAG = 0;
		    IF .INFO_FLAG
		    THEN
			HERE = .TOP

		    ELSE
			HERE = .BOTTOM;

    	
    		    ! Place in the begin array subscript.
    		    !
    		    IF NOT (NOT .INFO_FLAG AND .ARRAY_FLAG)
    		    THEN
    		        BEGIN
	                STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
    				    .CHAR_TABLE[PRT$K_BEGIN_CHAR] + TABLEBASE);
    		        ARRAY_FLAG = TRUE;
    		        END;


	    	    ! Get the subscript value.
    		    !
    		    SUBVECTOR = PRIM_NODE[DBG$A_PNARR_SVECTOR];
		    INCR I FROM 0 TO .PRIM_NODE[DBG$B_PNARR_DIMCNT] - 1 DO
    		        BEGIN
    		        IF .SUBVECTOR[.I, DBG$L_PNSUB_TYPEID] EQL 0
    		        THEN
    			    BEGIN
    			    GET_VALUE(SUBVECTOR[.I, DBG$L_PNSUB_SVALUE]);
    		            STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, .NAMEPTR);
    			    END


    		    	! This type needs some more work.  Build a value
    		    	! descriptor for this TYPEID.
    			!
		        ELSE
    			    BEGIN
		    	    VALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
    			    TYPEID = .SUBVECTOR[.I, DBG$L_PNSUB_TYPEID];
    			    VALPTR[DBG$B_DHDR_LANG] = .PRIM_DESC[DBG$B_DHDR_LANG];
    			    VALPTR[DBG$B_DHDR_KIND] = .TYPEID[RST$B_KIND];
    			    VALPTR[DBG$B_DHDR_FCODE] = .TYPEID[RST$B_FCODE];
    			    VALPTR[DBG$L_DHDR_TYPEID] = .TYPEID;
		    	    VALPTR[DBG$L_DHDR_SYMID0] = .PRIM_DESC[DBG$L_DHDR_SYMID0];
			    DBG$GL_CURRENT_PRIMARY = .PRIM_DESC;						! 3B-4
    			    DBG$FILL_IN_VMS_DESC(.TYPEID[RST$B_FCODE], .TYPEID,
    				.PRIM_DESC[DBG$L_DHDR_SYMID0],
    				VALPTR[DBG$A_VALUE_VMSDESC], BITLEN, BIT_OFFSET);
	    		    VALPTR[DBG$L_VALUE_POINTER] = VALPTR[DBG$A_VALUE_ADDRESS];
	    		    VALPTR[DBG$L_VALUE_VALUE0] = .SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE,
    					.VALPTR, TRUE);
    			    END;


    		        ! Place in Array separator.
    		        !
	                STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
    			    	    .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);

    		        END;		! End of INCR getting the subscripts.


    		    ! Get offset, length, and sign.
    		    !
    		    IF .PRIM_DESC[DBG$V_DHDR_BLIBLK]
    		    THEN
    			BEGIN
    		    	IF .PRIM_DESC[DBG$V_DHDR_SUBREF]
    		    	THEN
    			    BEGIN


    			    ! Get offset.
    			    !
    			    GET_VALUE(PRIM_DESC[DBG$W_PRIM_OFFSET]);
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, .NAMEPTR);
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
					.CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);


    			    ! Get length.
    			    !
    			    GET_VALUE(PRIM_DESC[DBG$W_PRIM_LENGTH]);
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, .NAMEPTR);
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
    					.CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);


    			    ! Get sign.
    			    !
    			    GET_VALUE(PRIM_DESC[DBG$V_DHDR_SGNEXT]);
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, .NAMEPTR);
    			    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE,
    					.CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);
    			    END;

    			END;

    		    IF .INFO_FLAG
    		    THEN
    		        TOP = .HERE

    		    ELSE
    		        BOTTOM = .HERE;


		    ! Put in close subscript, but not in COBOL case yet. We
    		    ! have one separator too many, so we overlay the last one.
    		    !
    		    IF .INFO_FLAG
    		    THEN
    		        BEGIN
    		        TOP = .TOP + 1;
	        	STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, TOP, 
    				    .CHAR_TABLE[PRT$K_END_CHAR] + TABLEBASE);
    			END;

    		    END;		! End of getting subscripts.

    		END;


    	    ! Print general record/pointer format.
    	    !
    	    [PRT$K_RECORD,
	     PRT$K_POINTER]:
    		BEGIN
    		IF .PRIM_NODE[DBG$V_PNODE_EVAL]
    		THEN
    		    BEGIN
    		    IF .FORMAT
    		    THEN
    		        BEGIN
	                STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
		        STKOVF = PRINT_PUSH(TRUE, STACK, TOP, 
	            	            .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);
    			END;

    		    END

    		ELSE
    		    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);

		PTR_FLAG = FALSE;
		IF .INFO_TABLE[.FCODE, PRTINFO$L_ROUT_INDEX] EQL PRT$K_POINTER
		THEN
		    PTR_FLAG = TRUE;

    		END;


	    ! In cobol there are record structure started with no name cases:
    	    ! For example, in program FOO,
    	    !     01.
    	    !         02 A    PIC X.
    	    !
    	    ! We want to print it as "FOO\A", instead of "A of FOO".
    	    ! So we use PATHNAME_FLAG to fudge this case.
    	    !
    	    ! Note: Since PLI and C go through different path of code,
    	    ! so this fudge does not affect PLI and C.
    	    !
    	    [PRT$K_RECORD_COB]:
    		BEGIN
	        IF .PATHNAME_FLAG EQL 2
    		THEN
    		    BEGIN
    		    IF .PRIM_NODE[DBG$V_PNODE_EVAL]
    		    THEN
    			BEGIN
    			IF .FORMAT
    			THEN
    			    BEGIN
    			    IF .NAMEPTR NEQ 0 
    			    THEN
    			        BEGIN
    				IF .NAMEPTR[0] NEQ 0
    				THEN
    				    BEGIN
	            		    STKOVF = PRINT_PUSH(FALSE, STACK, BOTTOM, .NAMEPTR);
    		    		    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, 
	            			    .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);
    		    		    PATHNAME_FLAG = 3;
    				    END;
    		    		END;
    			    END;
    			END
    		    ELSE
    			BEGIN
    			IF .NAMEPTR NEQ 0
    			THEN
    			    BEGIN
    			    IF .NAMEPTR[0] NEQ 0
    			    THEN
    			        BEGIN
			        STKOVF = PRINT_PUSH(FALSE, STACK, BOTTOM, .NAMEPTR);
    			        PATHNAME_FLAG = 3;
    			        END;
    			    END;
    			END;

    		    END

    		! Back to the normal case.
    		!
    		ELSE
    		    BEGIN
	            IF .PRIM_NODE[DBG$V_PNODE_EVAL]
    		    THEN
    		        BEGIN
    		        IF .FORMAT
    		        THEN
		            BEGIN
		            IF .NAMEPTR NEQ 0
    			    THEN
    				BEGIN
    				IF .NAMEPTR[0] NEQ 0
    			        THEN
    			            BEGIN
	                            STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
		                    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, 
	            	                .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);
    				    END;
    				END
    			    ELSE
				STKOVF = PRINT_PUSH(TRUE, STACK, TOP, 
    		                    .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);
    			    END;
    			END
    		    ELSE
    			BEGIN
    			IF .NAMEPTR NEQ 0
    			THEN
    			    BEGIN
    			    IF .NAMEPTR[0] NEQ 0
    			    THEN
    			        STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
    			    END;
    			END;
    		    END;

		PTR_FLAG = FALSE;
		IF .INFO_TABLE[.FCODE, PRTINFO$L_ROUT_INDEX] EQL PRT$K_POINTER
		THEN
		    PTR_FLAG = TRUE;

    		END;


    	    ! Print C pointer.
	    !
    	    [PRT$K_POINTER_C]:
    		BEGIN
    		NEXT_NODE = .PRIM_NODE[DBG$L_PNODE_FLINK];
    		IF .PRIM_NODE[DBG$V_PNODE_EVAL]
    		THEN
    		    BEGIN
    		    IF .FORMAT
    		    THEN
    		        BEGIN
    			IF ..PRIM_NODE[0,0,32,0] EQL .PRIM_HEAD OR
    			   .NEXT_NODE[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_TPTR OR
    			   .NEXT_NODE[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_PTR
    			THEN
    			    BEGIN
	                    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
		            STKOVF = PRINT_PUSH(FALSE, STACK, BOTTOM, 
	            	            .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);
    			    END

    			ELSE
    			    BEGIN
	                    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
		            STKOVF = PRINT_PUSH(TRUE, STACK, TOP, 
	            	            .CHAR_TABLE[PRT$K_RECPTR_CHAR] + TABLEBASE);
    			    PTR_FLAG = TRUE;    
    			    END;

    			END;

    		    END

    		ELSE
    		    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);

    		END;


    	    ! Print C and PLI record format.
	    !
    	    [PRT$K_RECORD_C_PLI]:
    		BEGIN
    		IF .PRIM_NODE[DBG$V_PNODE_EVAL]
    		THEN
    		    BEGIN
    		    IF .FORMAT
    		    THEN
    		        BEGIN
    			IF .PTR_FLAG
    			THEN
	                    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR)

    			ELSE
    			    BEGIN
	                    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);
		            STKOVF = PRINT_PUSH(TRUE, STACK, TOP, 
	            	            .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);

    			    END;

    			END;

    		    END

    		ELSE
    		    STKOVF = PRINT_PUSH(TRUE, STACK, TOP, .NAMEPTR);

    		PTR_FLAG = FALSE;
    		END;


	    ! If this is a Variant Sub-Node, do nothing.  Record Variants have
	    ! no effect on the printed variable name, so we simply skip this
	    ! Sub-Node and go on to the next one.
	    !
	    [PRT$K_VARIANT]:
		0;


	    ! If we get here, there is an invalid print routine index in the
	    ! Print Information Table.  Signal an internal error.
	    !
    	    [INRANGE, OUTRANGE]:
    		$DBG_ERROR('DBGPRINT\DBG$PRINT_IDENTIFIER unknown print index');

    	    TES;			! End of CASE on Print Routine Index.

	END;				! End of WHILE Primary Descriptor Loop.


    ! Fix up array close subscript for COBOL.
    !
    IF NOT .INFO_FLAG 
    THEN
    	BEGIN
    	IF .BOTTOM GTR PRINT_STACK_START AND
    	   .PATHNAME_FLAG EQL 0
    	THEN
            BEGIN
	    BOTTOM = .BOTTOM - 1;
    	    CHAR_TABLE = .INFO_TABLE[RST$K_TYPE_ARRAY, PRTINFO$L_CHARTBL] + TABLEBASE;
	    STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, BOTTOM, 
		    	.CHAR_TABLE[PRT$K_END_CHAR] + TABLEBASE);
    	    END;

    	END;


    ! Get the reference modifier.  For example, in COBOL, FORTRAN, one can say
    ! CHAR(1,10)(2:3). Or if this is a bit-string sub-reference, get that.
    !
    IF .PRIM_DESC[DBG$V_DHDR_SUBREF]
    THEN
        BEGIN
    	IF NOT .PRIM_DESC[DBG$V_DHDR_BLIBLK]
    	THEN
    	    BEGIN
            IF NOT .PRIM_DESC[DBG$V_DHDR_AGGR]
            THEN
    	        BEGIN
            	CHAR_TABLE = .INFO_TABLE[RST$K_TYPE_COMMON, 
    					PRTINFO$L_CHARTBL] + TABLEBASE;
	        HERE = (IF .INFO_FLAG THEN .TOP ELSE .BOTTOM);

    	
    		! Place in the begin reference modifier subscript.
    		!
	        STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
    			    .CHAR_TABLE[PRT$K_BEGIN_CHAR] + TABLEBASE);


	        ! Get the value.
    		!
    		GET_VALUE(PRIM_DESC[DBG$W_PRIM_OFFSET]);
    		STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, .NAMEPTR);
	        STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
    		            .CHAR_TABLE[PRT$K_SEPARATOR_CHAR] + TABLEBASE);


	        ! Get the value.
    		!
	        IF .REFMOD_FLAG
	        THEN
    		    VALUE = .PRIM_DESC[DBG$W_PRIM_OFFSET] +
			    .PRIM_DESC[DBG$W_PRIM_LENGTH] - 1

	        ELSE
		    VALUE = .PRIM_DESC[DBG$W_PRIM_LENGTH];

    		GET_VALUE(VALUE);
    		STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, .NAMEPTR);
	        STKOVF = PRINT_PUSH(.INFO_FLAG, STACK, HERE, 
    				.CHAR_TABLE[PRT$K_END_CHAR] + TABLEBASE);

	        IF .INFO_FLAG
    		THEN
    		    TOP = .HERE

    		ELSE
    		    BOTTOM = .HERE;

    		END;

    	    END;		! End of getting reference modifier.

    	END;			! End of getting sub-reference.


    ! If there is any truncation during the process, give an informational
    ! signal.
    !
    IF .STKOVF OR .SUBOVF THEN SIGNAL(DBG$_STGTRUNC);


    TOP = MAX(.TOP + 1, 0);
    BOTTOM = MIN(.BOTTOM, PRINT_STACK_SIZE - 1);


    ! Go through the pointers to ASCIC strings, accumulated the strings.
    ! Print the stack from bottom to top direction.
    !
    IF .INFO_FLAG
    THEN
        DECR I FROM .BOTTOM TO .TOP DO
            BEGIN
    	    IF .STACK[.I, PRTID$STACK_FLAG]
    	    THEN
    		DBG$PRINT_VALUE(.STACK[.I, PRTID$STACK_PTR], DBG$K_DEFAULT, FALSE, FALSE)

    	    ELSE
		DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .STACK[.I, PRTID$STACK_PTR]);

    	    END


    ! Print the stack from top to bottom direction.
    !
    ELSE
	BEGIN
    	INCR I FROM .TOP TO .BOTTOM DO
            BEGIN
    	    IF .STACK[.I, PRTID$STACK_FLAG]
    	    THEN
    		DBG$PRINT_VALUE(.STACK[.I, PRTID$STACK_PTR], DBG$K_DEFAULT, FALSE, FALSE)
    	    ELSE
    		DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .STACK[.I, PRTID$STACK_PTR]);

    	    END;

	END;


    ! We are all done with the printing, print the offsets if there is any.
    ! Do some clean up and return.
    !
    PRINT_OFFSETS_AND_RETURN;

    END;

GLOBAL ROUTINE DBG$PRINT_IDENTIFIER_PC(PC) =
!
! FUNCTION
!	This routine takes in a 32 bit address, build a Volatile Value
!	Descriptor, and then call DBG$PRINT_IDENTIFIER to print out that
!	address as an absolute address.
!
! INPUTS
!	PC	- 32 bits virtual address.
!
! OUTPUTS
!	A Primary descriptor for the exact match or a Volatile Value
!		  Descriptor will be returned.
!

    BEGIN

    LOCAL
    	STATUS,				! Return value
    	VAL_DESC: REF DBG$VALDESC;	! Pointer to value descriptor


    VAL_DESC = DBG$MAKE_SKELETON_DESC (DBG$K_V_VALUE_DESC);
    VAL_DESC[DBG$B_DHDR_LANG] = DBG$GB_LANGUAGE;
    VAL_DESC[DBG$B_DHDR_KIND] = RST$K_DATA;
    VAL_DESC[DBG$B_DHDR_FCODE] = 0;
    VAL_DESC[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    VAL_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_LU;
    VAL_DESC[DBG$W_VALUE_LENGTH] = 4;
    VAL_DESC[DBG$L_VALUE_POINTER] = .PC;
    STATUS = DBG$PRINT_IDENTIFIER(.VAL_DESC);
    RETURN .STATUS;

    END;

GLOBAL ROUTINE DBG$PRINT_OFFSET(VALUE): NOVALUE =
!
! FUNCTION
!	This function prints a value in the current radix.  It suppresses
!	leading zeroes, except before hex A-F.  It is designed to be used in
!	printing positive offsets; it will not print "0", and will not print
!	negative numbers.
!
! INPUTS
!	VALUE - The value to be printed.  Should be a number greater than 0.
!
! OUTPUTS
!	The routine either prints the value in the correct radix, or signals
!	an error.
!

    BEGIN

    LOCAL
	I,				! Index.
	RADIX,				! Current radix.
	FAO_LENGTH: WORD,		! Length returned by SYS$FAO.
	CONTROL_DESC: BLOCK[8, BYTE],	! Control desc. for SYS$FAO.
	OUT_DESC: BLOCK[8, BYTE],	! Output desc. for SYS$FAO.
	OUTBUF: VECTOR[20, BYTE];	! Output buffer.



    ! Set up output descriptor.
    !
    OUT_DESC[DSC$W_LENGTH] = 19;
    OUT_DESC[DSC$A_POINTER] = OUTBUF[1];


    ! Get current radix.
    !
    IF .DBG$GB_VERB EQL DBG$K_EXAMINE_VERB
    THEN
    	BEGIN
    	RADIX = .DBG$GL_CMND_RADIX;
    	IF .RADIX EQL DBG$K_DEFAULT
    	THEN
    	    RADIX = DBG$NGET_RADIX();
    	END
    ELSE
        RADIX = DBG$NGET_RADIX();


    ! Decide on form of output based on radix mode.
    !
    CASE .RADIX FROM DBG$K_DEFAULT TO DBG$K_HEX OF
	SET


	! Output the offset in octal.
	!
	[DBG$K_OCTAL]:
	    BEGIN


	    ! Set up control descriptor for octal output; call SYS$FAO.
	    !
	    CONTROL_DESC[DSC$W_LENGTH] = %CHARCOUNT ('!OL');
	    CONTROL_DESC[DSC$A_POINTER] = UPLIT BYTE ('!OL');
	    IF NOT SYS$FAO (CONTROL_DESC, FAO_LENGTH, OUT_DESC, .VALUE)
	    THEN
    		$DBG_ERROR('DBGPRINT\DBG$PRINT_OFFSET, SYS$FAO failed');


	    ! Suppress leading zeroes.
	    !
	    I = 1;
	    WHILE .OUTBUF[.I] EQL %C'0' DO
		BEGIN
		I = .I + 1;
		IF .I GTR .FAO_LENGTH THEN EXITLOOP;
		END;

	    OUT_DESC[DSC$W_LENGTH] = .FAO_LENGTH - .I + 1;
	    OUT_DESC[DSC$A_POINTER] = OUTBUF[.I];


	    ! Output the value.
	    !
	    IF .OUT_DESC[DSC$W_LENGTH] GTR 0
	    THEN
	    	DBG$PRINT (UPLIT BYTE (%ASCIC '+!AS'), OUT_DESC);

	    END;


	! Output the offset in hexadecimal.
	!
	[DBG$K_HEX]:
	    BEGIN


	    ! Set up control descriptor for hex output; call SYS$FAO.
	    !
	    CONTROL_DESC[DSC$W_LENGTH] = %CHARCOUNT ('!XL');
	    CONTROL_DESC[DSC$A_POINTER] = UPLIT BYTE ('!XL');
	    IF NOT SYS$FAO (CONTROL_DESC, FAO_LENGTH, OUT_DESC, .VALUE)
	    THEN
    		$DBG_ERROR('DBGPRINT\DBG$PRINT_OFFSET, SYS$FAO failed');


	    ! Suppress leading zeroes.
	    !
	    I = 1;
	    WHILE .OUTBUF[.I] EQL %C'0' DO
		BEGIN
		I = .I + 1;
		IF .I GTR .FAO_LENGTH THEN EXITLOOP;
		END;


	    ! If first non-zero character is A-F, then print one leading zero.
	    !
	    IF .OUTBUF[.I] GTR '9'
	    THEN
		BEGIN
		I = .I - 1;
		OUTBUF[.I] = %C'0';
		END;

	    OUT_DESC[DSC$W_LENGTH] = .FAO_LENGTH - .I + 1;
	    OUT_DESC[DSC$A_POINTER] = OUTBUF[.I];


	    ! Output the value.
	    !
	    IF .OUT_DESC[DSC$W_LENGTH] GTR 0
	    THEN
	    	DBG$PRINT (UPLIT BYTE (%ASCIC '+!AS'), OUT_DESC);

	    END;


	! In all other cases, just format the offset in decimal.  Here there
	! are no leading zeroes to worry about.
	!
	[INRANGE, OUTRANGE]:
	    DBG$PRINT(UPLIT BYTE (%ASCIC '+!UL'), .VALUE);

	TES;


    ! The offset has been format (or omitted) as appropriate.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$PRINT_SET_VALUE(VALPTR): NOVALUE =
!
! FUNCTION
!	Given value descriptor for Set data, print its value.
!
! INPUTS
!	VALPTR	- Pointer to value descriptor.
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
    	VALPTR: REF DBG$VALDESC;	! Pointer to value descriptor

    LOCAL
    	COMMA_FLAG,			! Flag to indicate it is time to print ,
    	DUMMY,				! Subrange typeid in Set
    	PARENT_TYPE: REF RST$ENTRY,	! Set parent typeid
    	PRINT_FLAG,			! Flag to indicate it is time to print
    					!	the set value
    	PRINT_VALPTR: REF DBG$VALDESC,	! Pointer to Print value descriptor
    	SETVALUE: REF BITVECTOR[],	! A bit vector of set value
    	SIZE;				! The length of the set in bits



    PARENT_TYPE = DBG$GET_SET_TYPEID(.VALPTR[DBG$L_DHDR_TYPEID], DUMMY);
    PRINT_VALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
    PRINT_VALPTR[DBG$B_DHDR_LANG] = .VALPTR[DBG$B_DHDR_LANG];
    PRINT_VALPTR[DBG$B_DHDR_KIND] = .PARENT_TYPE[RST$B_KIND];
    PRINT_VALPTR[DBG$B_DHDR_FCODE] = .PARENT_TYPE[RST$B_FCODE];
    PRINT_VALPTR[DBG$L_DHDR_TYPEID] = .PARENT_TYPE;
    IF .PRINT_VALPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC 
    THEN
    	BEGIN
    	DBG$STA_TYP_ATOMIC(.PARENT_TYPE, PRINT_VALPTR[DBG$B_VALUE_DTYPE], SIZE);
    	IF .PRINT_VALPTR[DBG$B_VALUE_DTYPE] EQL DST$K_BOOL
    	THEN
    	    PRINT_VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_TF;

    	PRINT_VALPTR[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    	END

    ELSE
    	BEGIN
    	PRINT_VALPTR[DBG$B_VALUE_CLASS] = 0;
    	PRINT_VALPTR[DBG$B_VALUE_DTYPE] = 0;
    	SIZE = 32;
    	END;
    	
    PRINT_VALPTR[DBG$W_VALUE_LENGTH] = .SIZE / 8;
    PRINT_VALPTR[DBG$L_VALUE_POINTER] = PRINT_VALPTR[DBG$A_VALUE_ADDRESS];
    DBG$PRINT(UPLIT BYTE(%ASCIC '['));
    SETVALUE = .VALPTR[DBG$L_VALUE_POINTER];
    PRINT_FLAG = TRUE;
    COMMA_FLAG = FALSE;
    INCR I FROM 0 TO (.VALPTR[DBG$W_VALUE_LENGTH] * 8 - 1) DO
    	BEGIN
    	IF .SETVALUE[.I]
    	THEN
    	    BEGIN
    	    IF .PRINT_FLAG
    	    THEN
    		BEGIN
    		IF .COMMA_FLAG
    		THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC ', '));

    		COMMA_FLAG = TRUE;
    		PRINT_VALPTR[DBG$L_VALUE_VALUE0] = .I;
    		DBG$PRINT_VALUE(.PRINT_VALPTR, DBG$K_DEFAULT, FALSE, FALSE);
    		IF .I EQL (.VALPTR[DBG$W_VALUE_LENGTH] * 8 - 1) THEN EXITLOOP;
    		IF .SETVALUE[.I+1]
    		THEN
    		    BEGIN
    		    IF (.I + 1) EQL (.VALPTR[DBG$W_VALUE_LENGTH] * 8 - 1) OR
    		       (NOT .SETVALUE[.I + 2])
    		    THEN
    			DBG$PRINT(UPLIT BYTE(%ASCIC ', '))

    		    ELSE
	                DBG$PRINT(UPLIT BYTE(%ASCIC '..'));

    		    PRINT_FLAG = FALSE;
    		    END;

    		END

    	    ELSE
    		BEGIN
    		IF .I EQL (.VALPTR[DBG$W_VALUE_LENGTH] * 8 - 1)
    		THEN
    		    BEGIN
    		    PRINT_VALPTR[DBG$L_VALUE_VALUE0] = .I;
    		    DBG$PRINT_VALUE(.PRINT_VALPTR, DBG$K_DEFAULT, FALSE, FALSE);
    		    EXITLOOP;
    		    END;

    		IF NOT .SETVALUE[.I + 1]
    		THEN
    		    BEGIN
    		    PRINT_VALPTR[DBG$L_VALUE_VALUE0] = .I;
    		    DBG$PRINT_VALUE(.PRINT_VALPTR, DBG$K_DEFAULT, FALSE, FALSE);
    		    PRINT_FLAG = TRUE;
    		    END;

    		END;

    	    END;

    	END;

    DBG$PRINT(UPLIT BYTE(%ASCIC ']'));
    RETURN 0;
    END;

GLOBAL ROUTINE DBG$PRINT_SET_LANGUAGE(LANGUAGE) : NOVALUE =
!
! FUNCTION
!	This routine is called from the set language command.  It sets two
!	global flags to indicate whether the language has the array or record 
!	type of data.  When we do the symbolization, we symbolize to array 
!	subscript or record component by the current language setting.  If the
!	current language does not have array or record then we'll symbolize
!	to data+offset.  For example, if we debug a variable declared in 
!	fortran, but the language set to macro, then we'll symbolize the
!	variable to data+offset instead to data(i,j).
!
! INPUTS
!	LANGUAGE - The current language setting.
!
! OUTPUTS
!	None.
!

    BEGIN

    LOCAL
    	PTR: REF VECTOR[,LONG];


    ! Load in language independent print information table.  The rest of
    ! the information is set by the language code in the primary/value
    ! descritpor.  But, for the subscripting or record component is printed
    ! by the current language setting.
    !
    PTR = .LANGUAGE_PRINT_TABLE_PTRS[.LANGUAGE] + TABLEBASE;
    DBG$GL_ARRSUB_FLAG = .PTR[3];
    DBG$GL_RECCMP_FLAG = .PTR[4];
    DBG$GL_SIGN_FLAG = .PTR[5];
    RETURN 0;
    END;


GLOBAL ROUTINE DBG$PRINT_SYMBOL_NAME(SYMID) : NOVALUE =
!
! FUNCTION
!	This routine prints the symbol name without pathname qualification
!	of a symbol specified by a SYMID.  If that SYMID is zero, nothing
!	is printed.  The printing is achieved by calling DBG$PRINT.
!
! INPUTS
!	SYMID	- The SYMID of the symbol whose name is to be printed.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	NAMEPTR;			! Pointer to ASCIC symbol name



    ! If the SYMID is non-zero, print the corresponding symbol name.
    !
    IF .SYMID EQL 0 THEN RETURN;
    DBG$STA_SYMNAME(.SYMID,NAMEPTR);
    DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .NAMEPTR);
    RETURN;

    END;

GLOBAL ROUTINE DBG$PRINT_SYMBOL_PATHNAME(SYMID) : NOVALUE =
!
! FUNCTION
!	This routine prints the symbol name including pathname qualification
!	of a symbol specified by a SYMID.  If that SYMID is zero, nothing
!	is printed.  The printing is achieved by calling DBG$PRINT.
!
! INPUTS
!	SYMID	- The SYMID of the symbol whose name and pathname qualfication
!		  is to be printed.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	PATHNAME_DESC: REF PTH$PATHNAME,! Pointer to Pathname Descr.
    	SYMBOL_NAME: REF VECTOR[,BYTE];	! Pointer to counted ASCII string


    ! Get a Pathname Descriptor for the SYMID symbol from SYMPATHNAME, convert
    ! that to a Counted ASCII string through NPATHDESC_TO_CS, and then print
    ! that string and return.
    !
    DBG$STA_SYMPATHNAME (.SYMID, PATHNAME_DESC);
    DBG$NPATHDESC_TO_CS (.PATHNAME_DESC, SYMBOL_NAME);
    DBG$PRINT (UPLIT BYTE (%ASCIC '!AC'), .SYMBOL_NAME);
    RETURN;

    END;

GLOBAL ROUTINE DBG$SET_MAX_LINE_WIDTH(LINE_WIDTH): NOVALUE =
!
! FUNCTION
!	This routine sets the maximum width of DEBUG output lines so that
!	output lines that exceed this width get folded at the maximum width.
!	The maximum width cannot be set to a value less than 40 or greater
!	than 131 characters.  The width setting is accomplished by setting
!	the new width into the OWN variable MAX_PBSIZE.
!
! INPUTS
!	LINE_WIDTH - The new maximum print line width to be set.
!
! OUTPUTS
!	NONE
!

    BEGIN



    ! Set the new maximum line width and make sure it is within range.
    !
    MAX_PBSIZE = .LINE_WIDTH;
    IF .MAX_PBSIZE LSS 40 THEN MAX_PBSIZE = 40;
    IF .MAX_PBSIZE GTR 131 THEN MAX_PBSIZE = 131;
    RETURN;

    END;

GLOBAL ROUTINE DBG$WRITE_LOG_FILE(LENGTH, BUFFER): NOVALUE =
!
! FUNCTION
!	This routine writes an already formatted line of output to the DEBUG
!	log file.  It accepts the length and address of the output line as
!	input and outputs that buffer to the log file.  It then returns.  It
!	is assumed that the caller has inserted the leading "!" in the out-
!	put line (if appropriate) before calling this routine.
!
! INPUTS
!	LENGTH	- The number of bytes of text to be output to the log file
!		  from the BUFFER location
!
!	BUFFER	- The address of the buffer to be output to the log file.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	FAB_PTR: REF $FAB_DECL,		! Pointer to the log file FAB
	MSG_DESC: BLOCK[8,BYTE],	! String descriptor pointing to file
					!      name--used in error messages
	STATUS;				! Status code returned by RMS



    ! If output logging is not active, return immediately without writing
    ! anything to the log file.
    !
    IF NOT .DBG$GB_DEF_OUT[OUT_LOG] THEN RETURN;


    ! Output the buffer to the log file and check the status.  Then return.
    !
    DBG$GL_LOGRAB[RAB$L_RBF] = .BUFFER;
    DBG$GL_LOGRAB[RAB$W_RSZ] = .LENGTH;
    STATUS = $PUT(RAB = DBG$GL_LOGRAB);


    ! If we got a record stream active error, wait for the current I/O on
    ! the file to finish and then try the I/O again.
    !
    IF .STATUS EQL RMS$_RSA
    THEN
	BEGIN
	$WAIT(RAB = DBG$GL_LOGRAB);
	STATUS = $PUT(RAB = DBG$GL_LOGRAB);
	END;


    ! If the I/O operation failed, signal the error.  The error message
    ! will include the file name and the STS and STV status values.
    !
    IF NOT .STATUS
    THEN
	BEGIN
	MSG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
	MSG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	FAB_PTR = .DBG$GL_LOGRAB[RAB$L_FAB];
	IF .DBG$GL_LOG_BUF NEQ 0
	THEN
	    BEGIN
	    MSG_DESC[DSC$W_LENGTH] = .FAB_PTR[FAB$B_FNS];
	    MSG_DESC[DSC$A_POINTER] = .FAB_PTR[FAB$L_FNA];
	    END

	ELSE
	    BEGIN
	    MSG_DESC[DSC$W_LENGTH] = .FAB_PTR[FAB$B_DNS];
	    MSG_DESC[DSC$A_POINTER] = .FAB_PTR[FAB$L_DNA];
	    END;

	SIGNAL (SHR$_WRITEERR + DBG_FAC_CODE, 1, MSG_DESC,
			.DBG$GL_LOGRAB[RAB$L_STS], .DBG$GL_LOGRAB[RAB$L_STV]);

	END;


    ! Everything worked fine--return to the caller.
    !
    RETURN;

    END;

ROUTINE DBG$WRITE_OUTPUT(LENGTH, BUFFER): NOVALUE =
!
! FUNCTION
!	This routine writes a text buffer containing an ASCII character
!	string to file DBG$OUTPUT (normally the user's terminal) and to
!	the current log file (if one exists).  The write to DBG$OUTPUT
!	is done using RMS, but is skipped entirely if the user has sup-
!	pressed it with a SET OUTPUT NOTERMINAL command.
!
!	If there is a log file, the comment character "!" is inserted in
!	front of the character string before the string is written out.
!	This is done by copying the string to a temporary log file buffer.
!	The output is then done by calling DBG$WRITE_LOG_FILE.
!
! INPUTS
!	LENGTH	- The length in bytes of the ASCII character string to be
!		  output to DBG$OUTPUT and the log file.
!
!	BUFFER	- The address of the buffer containing the ASCII character
!		  string to be output to DBG$OUTPUT and the log file.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LOG_BUFFER: VECTOR[132,BYTE],	! Temporary buffer for log file output
	LOG_LENGTH,			! Length of string in log file buffer
	MSG_DESC: BLOCK[8,BYTE],	! String descriptor pointing to file
					!      name--used in error messages
	STATUS;				! RMS status code



    ! If we are in Screen Mode, we direct the print output to the currently
    ! active Screen Display instead of printing it through RMS in the normal
    ! manner.
    !
    IF .DBG$GL_SCREEN_OUTPUT NEQ 0
    THEN
	DBG$SCR_WRITE_LINE(.LENGTH, .BUFFER, .DBG$GL_SCREEN_OUTPUT)


    ! If the user wants output on DBG$OUTPUT (the normal situation unless
    ! SET OUTPUT NOTERMINAL has been specified), set up and do the write.
    ! DBG$OUTPUT is normally defined to be the user's terminal.
    !
    ELSE IF .DBG$GB_DEF_OUT[OUT_TERM]
    THEN
	BEGIN


	! Write the output buffer to DBG$OUTPUT.
	!
	DBG$GL_OUTPRAB[RAB$L_RBF] = .BUFFER;
	DBG$GL_OUTPRAB[RAB$W_RSZ] = .LENGTH;
	STATUS = $PUT(RAB = DBG$GL_OUTPRAB);


	! If we got a record stream active error, wait for the current I/O
	! operation to finish and then retry the write.
	!
	IF .STATUS EQL RMS$_RSA
	THEN
	    BEGIN
	    $WAIT(RAB = DBG$GL_OUTPRAB);
	    STATUS = $PUT(RAB = DBG$GL_OUTPRAB);
	    END;


	! If we got any other I/O error, signal an error message which includes
	! the DBG$OUTPUT file name and the STS and STV status values.
	!
	IF NOT .STATUS
	THEN
	    BEGIN
	    MSG_DESC[DSC$W_LENGTH]  = 10;
	    MSG_DESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII 'DBG$OUTPUT');
	    SIGNAL(SHR$_WRITEERR + DBG_FAC_CODE, 1, MSG_DESC,
		.DBG$GL_OUTPRAB[RAB$L_STS], .DBG$GL_OUTPRAB[RAB$L_STV]);
	    END;

	END;				! End of DBG$OUTPUT code


    ! If a LOG file is being written, write the output buffer to it, but
    ! with the comment character appended in front of it.
    !
    IF .DBG$GB_DEF_OUT[OUT_LOG]
    THEN
	BEGIN


	! Put the comment character "!" at the beginning of a temporary log
	! file buffer.  Then copy the input string into the log file buffer
	! after the comment character.  This causes all DEBUG output to look
	! like comments in the log file.
	!
	LOG_BUFFER[0] = '!';
	LOG_LENGTH = MIN(.LENGTH + 1, 132);
	CH$MOVE(.LOG_LENGTH - 1, .BUFFER, LOG_BUFFER[1]);


	! Write the output buffer to the log file.
	!
	DBG$WRITE_LOG_FILE(.LOG_LENGTH, LOG_BUFFER[0]);
	END;


    ! Everything worked fine--return to the caller.
    !
    RETURN;

    END;

ROUTINE GET_SUBSCRIPT_VALUE(NAME, STRING, ARGUMENTS) =
!
! FUNCTION
!	This routine takes an array subscript value, formats that value into
!	an output string using FAO, and returns a pointer to the formatted
!	string to the NAMEPTR parameter.
!
! INPUTS
!	NAMEPTR	- The address of a longword location to receive a pointer
!		  to the formatted array subscript value.
!
!	STRING	- The address of an ASCIC FAO control string.
!
!	ARGUMENTS - Array subscript value.
!
! OUTPUTS
!	NAMEPTR	- A pointer to the formatted array subscript value is returned
!		  to the NAMEPTR parameter.
!
!	The routine returns the value TRUE if the formatting was successful and
!		  it returns FALSE if the value was truncated when formatted.
!

    BEGIN

    MAP
    	NAME: REF VECTOR[,LONG],     	! Pointer to ASCIC string
    	STRING: REF VECTOR[,BYTE];	! Address of FAO control string

    LITERAL
    	SUBBUF = 20;			! Buffer length in bytes

    LOCAL
    	INP_DESC: VECTOR[2,LONG],	! String descriptor for input buffer
    	LENGTH: WORD,			! Length of SYS$FAOL output string
    	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC string
    	OUT_DESC: VECTOR[2,LONG],	! String descriptor for output buffer
    	STATUS;				! Return status from FAO



    ! --------------------------------------------------------------------------
    !
    INP_DESC[0] = .STRING[0];
    INP_DESC[1] = STRING[1];
    OUT_DESC[0] = SUBBUF;
    OUT_DESC[1] = DBG$GET_MEMORY(SUBBUF / 4);
    STATUS = SYS$FAOL(INP_DESC, LENGTH, OUT_DESC, ARGUMENTS);
    IF .STATUS EQL SS$_ACCVIO OR .STATUS EQL SS$_BADPARAM
    THEN
    	BEGIN
    	DBG$REL_MEMORY(.OUT_DESC[1]);
    	SIGNAL(.STATUS);
    	END;

    NAMEPTR = DBG$GET_TEMPMEM((.LENGTH + 5)/4);
    CH$MOVE(.LENGTH, .OUT_DESC[1], NAMEPTR[1]);
    NAMEPTR[0] = .LENGTH;
    DBG$REL_MEMORY(.OUT_DESC[1]);
    .NAME = .NAMEPTR;
    IF .STATUS EQL SS$_NORMAL THEN RETURN FALSE;
    RETURN TRUE;

    END;

ROUTINE PRINT_PUSH(FLAG, STACK, I, NAMEPTR) =
!
! FUNCTION
!	Push the Pointer to ASCIC name string on the top of the stack upwards
!	or downwards.
!
! INPUTS
!	FLAG 	- Flag to indicate the stack grows upwards or downwards.
!	
!	STACK	- Pointer to the beginning of the stack.
!
!	I	- Current stack pointer.
!
!	NAMEPTR - Pointer to ASCIC name string.
!
!	arg. 5	- Flag set to indicate NAMEPTR contains a value descritpor.
!
! OUTPUTS
!	TRUE or FALSE.  TRUE to indicate stack underflow or overflow.
!

    BEGIN

    MAP
    	I: REF VECTOR[,LONG],
    	NAMEPTR: REF VECTOR[,BYTE],
    	STACK: REF PRTID$STACK;

    BUILTIN
    	ACTUALCOUNT,
	ACTUALPARAMETER;

    LOCAL
    	VALFLAG;



    ! --------------------------------------------------------------------------
    !
    IF (..I LSS 0) OR (..I GEQ PRINT_STACK_SIZE) THEN RETURN TRUE;
    IF .NAMEPTR NEQ 0 
    THEN
    	BEGIN
    	VALFLAG = (IF ACTUALCOUNT() GTR 4 THEN 1 ELSE 0);


    	! Push upwards.
    	!
    	IF .FLAG
    	THEN
            BEGIN
    	    STACK[..I, PRTID$STACK_PTR] = .NAMEPTR;
    	    STACK[..I, PRTID$STACK_FLAG] = .VALFLAG;
    	    .I = ..I - 1;
    	    END


    	! Push downwards.
    	!
    	ELSE
            BEGIN
    	    .I = ..I + 1;
    	    STACK[..I, PRTID$STACK_PTR] = .NAMEPTR;
    	    STACK[..I, PRTID$STACK_FLAG] = .VALFLAG;
    	    END;

    	END;

    RETURN FALSE;

    END;

END ELUDOM
