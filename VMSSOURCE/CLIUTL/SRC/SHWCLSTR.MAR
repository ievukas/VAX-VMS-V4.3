	.TITLE	SHWCLSTR	Show Cluster Utility
	.IDENT	'V04-000'
	.SBTTL	Copyright notice
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;


	.SBTTL	Program description
;++
;
; FACILITY:
;
;	VAX/VMS SHOW CLUSTER utility
;
;
; ABSTRACT:
;
;	SHWCLSTR is a utility used to display infomation about CI clusters and
;	the local hardware interface to the cluster.  Contained within are the
;	routines necessary to extract this information from the SCS database
;	and the CI port database and present the information to the user in a
;	readable format.  Furthermore, all routines needed to parse and process
;	input from the user are also included here.
;
;
; AUTHOR:	Paul R. DeStefano,	July, 1983
;
;
; MODIFIED BY:
;
;	V03-016	PRD0111		Paul R. DeStefano	31-Jul-1984
;		Update FIRST_DATA_LINE, which contains the number of
;		first line of the scrolling region, when the CLUSTER
;		class is added or removed from the display because
;		the ADD or REMOVE field command was entered and the
;		field was the first CLUSTER class field being added
;		or the last being removed.
;
;	V03-015	PRD0107		Paul R. DeStefano	20-Jul-1984
;		Correct formating of descriptor passed to $GETDVI.
;		Make INIT assume that output goes to a listing file
;		if $GETDVI fails.
;		Make sure initialization file gets executed when
;		running in a Batch job.
;		Change scrolling back to original design.
;
;	V03-014	PRD0103		Paul R. DeStefano	11-Jul-1984
;		Make sure DISPLAY_COMMON assumes successful return.
;		Fix access violation in OUTPUT_TIME routine.
;
;	V03-013	PRD0100		Paul R. DeStefano	08-May-1984
;		Modified RESET routine to properly restore the init
;		flag.
;
;	V03-012	PRD0098		Paul R. DeStefano	30-Apr-1984
;		Fix DO_SNAPSHOT routine so that variable length buffers
;		are unlocked.
;
;	V03-011	PRD0095		Paul R. DeStefano	11-Apr-1984
;		Removed COORD_STATUS and LOCAL_STATUS fields.
;
;	V03-010	PRD0089		Paul R. DeStefano	29-Mar-1984
;		Fix display of CLUSTER class title when the ADD CLUSTER
;		command is used in an initialization file.
;
;	V03-009	PRD0080		Paul R. DeStefano	25-Mar-1984
;		Store only the prefix of offset name to save space in
;		field descriptors.
;		Added code to format a 15 character time string to
;		FORMAT_DATA routines.
;		Improved error messages.
;		Improve output of time.
;		Improve method of limiting up- and left-scrolling.
;		Add SECOND_CHANCE routine.
;		Limit refreshing on commands that fail.
;		Added TRANS_TIME and QD_NAME fields.
;		Removed FORM_STATUS field.
;
;	V03-008	PRD0079		Paul R. DeStefano	11-Mar-1984
;		Don't do refresh after SET INTERVAL or SET SCREEN commands.
;		Correct output when using SYS$OUTPUT is redefined using
;		DEFINE/USER.  Correct output when I/O is to a mailbox.
;		Correct output when /OUTPUT is used within a BATCH job.
;		Correct maximum data width when ASCIC format is used with
;		a display routine other than DISPLAY_FIELD.
;
;	V03-007	PRD0076		Paul R. DeStefano	28-Feb-1984
;		Correct output file name when SYS$OUTPUT is defined as a
;		file.
;		Add new fields to CLUSTER and MEMBERS classes.
;		Make sure Local System Block is displayed when VMSVAXCLUSTER
;		doesn't equal 1.
;		Make sure line drawing and special graphics character are set
;		in G1 area in DECcrt on each screen update.
;		Call SET_REGION_FULL before exiting for foreign terminals
;		emulating VT100s.
;		Perform initial syntax checking using DCL_PARSE.
;		Improved parsing of lists of parameters and qualifier values.
;		Added ADD_ALL_FIELDS routine for new ADD class/ALL qualifier.
;		Make INTERVAL value = seconds rather than delta time.
;		Improved message handling.
;		Modified REMOVE_FIELD routine to turn off a class when the
;		last field is removed.
;		Display CLUSTER class at the top of the CLUSTER report.
;
;	V03-006	PRD0046		Paul R. Destefano	11-Jan-1984
;		Correct the number of bytes displayed by the SYS_ID field.
;		Make COUNTERS a separate class.
;		Retry snapshot with expanded buffers if snapshot buffers
;		overflow.
;
;	V03-005	PRD0043		Paul R. DeStefano	27-Sep-1983
;		Initialize connection count in path blocks at
;		PB$SHC$L_NUM_CDT so that a circuit losing all
;		connections will be properly detected.
;		Fix access violation in CHECK_POS routine.
;
;	V03-004	PRD0042		Paul R. DeStefano	27-Sep-1983
;		Fix setup of initialization file default so that an
;		extention of .INI is defaulted but not forced.
;		Add additional remote port types to RP_TYPE field.
;
;	V03-003	PRD0041		Paul R. DeStefano	15-Sep-1983
;		Modified default report display.
;		Fix handling of formative circuits in CHECK_POS routine.
;		Add variable buffer address (VAR_BUF_ADRS) to locked
;		portion of working set.
;		Fix refresh after INITIALIZE command.
;
;	V03-002	PRD0028		Paul R. DeStefano	23-Aug-1983
;		Modified handling of broadcast messages to allow for
;		messages that lack carriage control characteristics.
;
;		Fixed handling of an initialization command file that
;		contains an INITIALIZE command.
;
;--
 

 
	.SBTTL	Definitions.
;
; System definitions: (From SYS$LIBRARY:LIB.MLB)
;

	$CDLDEF				; Define connection descriptor list
					;  offsets.
	$CDTDEF				; Define connection descriptor table
					;  offsets.
	$CIBDDEF			; Define buffer descriptor offsets.
	$CIBDTDEF			; Define buffer descriptor table
					;  offsets.
	$CLUBDEF			; Define Cluster Block.
	$CSBDEF				; Define Cluster System Block.
	$DCDEF				; Define device class codes.
	$DDBDEF				; Define DDB offsets.
	$DIBDEF				; Define device characteristics offsets.
	$DVIDEF				; Define item identifier codes.
	$HLPDEF				; Define help flags.
	$IPLDEF				; Define processor priority levels.
	$MSGDEF				; Define message types.
	$PBDEF				; Define path block offsets.
	$PDTDEF				; Define port descriptor table offsets.
	$PRVDEF				; Define privilege mask bits.
	$SBDEF				; Define system block offsets.
	$SCRDEF				; Define screen package parameters.
	$SCSDEF				; Define SCS message formats.
	$SDIRDEF			; Define SCS directory entry offsets.
	$SSDEF				; Define status codes.
	$TPADEF				; Define LIB$TPARSE parameter block.
	$TRMDEF				; Define terminal function modifiers.
	$TTDEF				; Define terminal characteristics.
	$TT2DEF				; Define extended terminal
					;  characteristics.
	$UCBDEF				; Define UCB offsets.

;
; CI specific definitions: (From PALIB.MLB)
;

	$PAPDTDEF			; Define the extention to the port
					;  descriptor table.
	$PPDDEF				; Define datagram offsets.

;
; Define offsets into field descriptors.
;

	$DEFINI	FD

	$DEF	FD$B_FIELD_SIZE		.BYTE	; Number of columns currently
						;  occupied by the field.
	$DEF	FD$B_MIN_FLD_SIZE	.BYTE	; Minimum number of columns that
						;  can be used to display the
						;  field.
	$DEF	FD$B_MAX_DATA_SIZE	.BYTE	; Maximum number of columns
						;  needed to display the data.
	$DEF	FD$B_MAX_FLD_SIZE	.BYTE	; Maximum number of columns
						;  needed to display the field.
						;  (For both title and data.)
	$DEF	FD$B_LENGTH		.BYTE	; Number of bytes of data to
						;  extract from the SCS
						;  database to display the
						;  field.
	$DEF	FD$B_FORMAT		.BYTE	; Type of format to use when
						;  displaying the field.
						;
.=.+2						; Reserve one word.
						;
	$DEF	FD$L_DISPLAY_ROUTINE	.LONG	; Routine to call to display the
						;  field.
	$DEF	FD$L_CLASS		.LONG	; Class to which the field
						;  belongs.
	$DEF	FD$L_OFFSET		.LONG	; Value of the SCS offset.
	$DEF	FD$L_OFFSET_PRFX	.LONG	; First four characters of
						;  offset name string.
	$DEF	FD$B_TITLE_SIZE		.BYTE	; Number of characters in the
						;  title for the field.
	$DEF	FD$T_TITLE			; Offset to the title string.

	$DEFEND	FD,,DEF


;
; Define the field display format types.
;

ASCII		=	1		; Data is to be formatted in ascii.
HEX		=	2		; Data is to be formatted in hexadecimal
DEC		=	3		; Data is to be formatted in decimal.
ASCIC		=	4		; Data is to be formatted using a
					;  counted ascii string.
TIME		=	5		; Data is to be formatted as a time
					;  string.
TIME_STRING_LEN	=	15		; Length of formatted time string.

;
; Define lengths and starting offsets of special buffers for snapshot data.
;

;
; The portion of the CDT stored starts at CDT$L_RCONID.  The length is the
; number of bytes in CDT$L_RCONID through CDT$W_QBDT_CNT plus the forward link.
; The difference is a negative value to be added to the SCS offset in the
; field descriptors to compensate for the portion of the CDT that isn't stored.
;

SHC$L_CDT_BEGIN	=	CDT$L_RCONID			; Starting offset.
SHC$C_CDT_LENGTH=	<<CDT$W_QBDT_CNT+2>-CDT$L_RCONID>+4	; Length.
SHC$L_CDT_DIF	=	<CDT$L_MSGINPUT-CDT$L_RCONID>+4	; Difference.

;
; The portion of the PDT stored starts at PDT$L_MSGHDRSZ.  The length is the
; number of bytes in PDT$L_MSGHDRSZ through PDT$L_LBDG.  The difference is a
; negative value to be added to the SCS offset in the field descriptors to
; compensate for the portion of the PDT that isn't stored.

SHC$L_PDT_BEGIN	=	PDT$L_MSGHDRSZ			; Starting offset.
SHC$L_PDT_LENGTH=	PDT$L_LBDG-PDT$L_MSGHDRSZ 	; Length.
SHC$L_PDT_DIF	=	<PDT$W_SIZE-8>-PDT$L_MSGHDRSZ	; Difference.


;
; Define offsets for storing the number of circuits on a system and the number
; of connections on a circuit.
;

SB$SHC$L_NUM_PB	=	SB$L_BLINK	; Store the number of paths block on a
					;  system block where the back link
					;  would normally be.
PB$SHC$L_NUM_CDT=	PB$L_BLINK	; Store the number of connections on a
					;  path block where the back link would
					;  normally be.
;
; Define the offset for storing the display's line number in the system block.
; This is used to associate a system with a line in the display to insure that
; a line which has moved in the display, but has not changed does not go
; undetected.
;

SHC$SB$B_DIS_POS=	SB$W_SIZE+1	; Store in upper byte of size field in
					;  system block.

;
; Define offsets into MISC_BUF.
;

	$DEFINI	MB

	$DEF	MB$L_PORT_NAME	.LONG	; Port name.
	$DEF	MB$L_PORT_NUM	.LONG	; Port number.
	$DEF	MB$L_DEVTYPE	.LONG	; Device type.
	$DEF	MB$L_STS	.LONG	; Device status.
	$DEF	MB$B_ERTCNT	.BYTE	; # of reinitialize attempts remaining.
	$DEF	MB$B_ERTMAX	.BYTE	; Maximum number of reinits allowed.
	$DEF	MB$W_ERRCNT	.WORD	; Number of errors logged.
	$DEF	MB$L_FORM_PB	.LONG	; Number of formative path blocks.
	$DEF	MB$L_PL_WAITERS .LONG	; Number of SCS non-paged pool waiters.
	$DEF	MB$W_DG_FREE	.WORD	; Number of free datagram buffers
					;  currently queued for receives.
	$DEF	MB$W_MSG_FREE	.WORD	; Number of free message buffers
					;  currently queued for receives.
	$DEF	MB$W_CMDS_QUED	.WORD	; Total number of messages, datagrams,
					;  and port commands queued for
					;  transmission at all priorities.
					;  by this port.
	$DEF	MB$W_RSPS_QUED	.WORD	; Number of responses of all kinds
					;  received on this port, but not yet
					;  processed.
	$DEFEND	MB,,DEF

MISC_BUF_LEN	=	46		; 11 longwords in miscellaneous buffer.


;
; Define masks and bit fields for device types.
;

DVT$V_VT52	=	0		; VT52 compatable terminal.
DVT$V_DCRT	=	1		; VT100 compatable terminal.
DVT$V_HARD	=	2		; Hardcopy device.
DVT$V_UNKNOWN	=	3		; Unknown type of scope.
DVT$V_AVO	=	4		; Advanced video option present.
DVT$V_DISK	=	5		; Disk.

DVT$M_VT52	=	1@DVT$V_VT52
DVT$M_DCRT	=	1@DVT$V_DCRT
DVT$M_HARD	=	1@DVT$V_HARD
DVT$M_UNKNOWN	=	1@DVT$V_UNKNOWN
DVT$M_AVO	=	1@DVT$V_AVO
DVT$M_DISK	=	1@DVT$V_DISK

;
; Define the terminal screen widths.
;

NARROW		=	80		; DECcrt 80 column mode.
WIDE		=	132		; DECcrt 132 column mode.


;
; Define special keyboard characters.
;

ESC		=	^X1B		; Ascii escape character.
CSI		=	^X9B		; Eight bit equivalent of "ESC [".
CTRLW		=	^X17		; Ascii control-W.
CTRLZ		=	^X1A		; Ascii control-Z.


;
; Define the escape sequences sent by the arrow keys.
;

DCRT_UP_ARROW	=	^A/[A/		; DECcrt up arrow.
DCRT_DWN_ARROW	=	^A/[B/		; DECcrt down arrow.
DCRT_LFT_ARROW	=	^A/[C/		; DECcrt left arrow.
DCRT_RT_ARROW	=	^A/[D/		; DECcrt right arrow.

VT52_UP_ARROW	=	^A/A/		; VT52 up arrow.
VT52_DWN_ARROW	=	^A/B/		; VT52 down arrow.
VT52_LFT_ARROW	=	^A/C/		; VT52 left arrow.
VT52_RT_ARROW	=	^A/D/		; VT52 right arrow.


;
; Special characters to turn the special graphics characters on and off.
;

GRAPHICS_ON	=	^X0E		; Control_N or SO (shift-out)

GRAPHICS_OFF	=	^X0F		; Control_O or SI (shift-in)


;
; DECcrt special graphics characters
;

LR_CORNER	=	^A/j/		; Lower-right corner.
UR_CORNER	=	^A/k/		; Upper-right corner.
UL_CORNER	=	^A/l/		; Upper-left corner.
LL_CORNER	=	^A/m/		; Lower-left corner.
CROSS		=	^A/n/		; Crossing lines.
SCAN_5		=	^A/q/		; Horizontal line - Scan 5.
LEFT_T		=	^A/t/		; Left "T".
RIGHT_T		=	^A/u/		; Right "T".
BOTTOM_T	=	^A/v/		; Bottom "T".
TOP_T		=	^A/w/		; TOP "T".
VERT_BAR	=	^A/x/		; Vertical bar.


;
; Define masks and bit fields for the type of information currently output
; on the two command input lines.
;

CL$V_BRDCST	=	0		; Broadcast message.
CL$V_CMD	=	1		; Command input.
CL$V_ERROR	=	2		; Error message.
CL$V_SCROLL	=	3		; Scroll message.

CL$M_BRDCST	=	1@CL$V_BRDCST
CL$M_CMD	=	1@CL$V_CMD
CL$M_ERROR	=	1@CL$V_ERROR
CL$M_SCROLL	=	1@CL$V_SCROLL



;
; Define commonly used line numbers.
;

HEADER_START	=	2		; Display header starts at line two.
HEADER_END	=	HEADER_START+5	;  and is five lines long.


;
; Define the mask for CURRENT_REPORT.
;

RPT$V_CLSTR	=	0		; Set for cluster report, clear for
RPT$M_CLSTR	=	1@RPT$V_CLSTR	;  local report.


;
; Define ASCIC strings used to identify device descriptor blocks.
;

PAAC		=	^X41415003	; "PAA".
PABC		=	^X42415003	; "PAB"


;
; To add a new class.
;
;	1)	Define the class mask and field bits.
;	2)	Add the ascii class name @CLASS_NAMES
;	3)	Add a longword to the TITLE_LEN_ARRAY
;	4)	Add field definitions preceeding them with a
;		CLASS = class_mask statement.
;	5)	Increase NUM_CLASSES by 1.
;

;
; To add a new data structure for display by DISPLAY_FIELD.
;
;	1)	Add the new prefix to SYM_PRFX.
;	2)	Add a buffer for the new structure (fixed length) or
;		descriptors for a variable buffer.
;	3)	Modify the SNAPSHOT routine to capture the new structure.
;	4)	Add a new GET_DATA call frame index.
;

NUM_CLASSES	=	9		; Nine basic class types.

;
; Masks for controlling display of classes.
;

CLS$V_CLUB	=	0		; Cluster class.
CLS$V_SYS	=	1		; Systems class.
CLS$V_CSB	=	2		; Members class.
CLS$V_CIR	=	3		; Circuits class.
CLS$V_CON	=	4		; Connections class.
CLS$V_CNT	=	5		; Counters class.
CLS$V_CRD	=	6		; Credits class.
CLS$V_LPRT	=	7		; Local ports class.
CLS$V_ERR	=	8		; Errors class.
CLS$V_OPEN_CIR	=	9		; Circuits in the open state.
CLS$V_NOOPEN_CIR=	10		; Circuits in states other than open.
CLS$V_OPEN_CON	=	11		; Connections in the open state.
CLS$V_NOOPEN_CON=	12		; Connections in states other than open.

;
; Types of systems.  Must match HW_TYPE_TABLE.
;

CLS$V_750_SYS	=	16		; 750 systems.
CLS$V_780_SYS	=	17		; 780 systems.
CLS$V_785_SYS	=	18		; 785 systems.
CLS$V_790_SYS	=	19		; 790 systems.
CLS$V_HSC50_SYS	=	20	 	; HSC50 systems.
CLS$V_HSC60_SYS	=	21	 	; HSC60 systems.

CLS$M_CLUB	=	1@CLS$V_CLUB
CLS$M_SYS	=	1@CLS$V_SYS
CLS$M_CSB	=	1@CLS$V_CSB
CLS$M_CIR	=	1@CLS$V_CIR
CLS$M_CON	=	1@CLS$V_CON
CLS$M_CNT	=	1@CLS$V_CNT
CLS$M_CRD	=	1@CLS$V_CRD
CLS$M_LPRT	=	1@CLS$V_LPRT
CLS$M_ERR	=	1@CLS$V_ERR

;
; Mask for any type of SCS class. (Includes MEMBERS)
;

CLS$M_ANY_SCS	=	<CLS$M_SYS!-	; SYSTEMS
			 CLS$M_CIR!-	; CIRCUITS
			 CLS$M_CON!-	; CONNECTIONS
			 CLS$M_CNT!-	; COUNTERS
			 CLS$M_CRD!-	; CREDITS
			 CLS$M_CSB>	; MEMBERS

;
; Mask for any type of CLUSTER report class.
;

CLS$M_ANY_CLUS	=	<CLS$M_ANY_SCS!-	; Any SCS class.
			 CLS$M_CLUB>		; Plus the CLUSTER class.

;
; Mask for any types of system
;

CLS$M_780_SYS	=	1@CLS$V_780_SYS		; 11/780
CLS$M_785_SYS	=	1@CLS$V_785_SYS		; 11/785
CLS$M_750_SYS	=	1@CLS$V_750_SYS		; 11/750
CLS$M_HSC50_SYS	=	1@CLS$V_HSC50_SYS	; HSC50
CLS$M_HSC60_SYS	=	1@CLS$V_HSC60_SYS	; HSC60


CLS$M_ALL_SYS	=	<CLS$M_SYS!-		; Any type of system...
			 CLS$M_780_SYS!-	; ...11/780
			 CLS$M_785_SYS!-	; ...11/785
			 CLS$M_750_SYS!-	; ...11/750
			 CLS$M_HSC50_SYS!-	; ...HSC50
			 CLS$M_HSC60_SYS>	; ...HSC60


;
; Mask for all types of circuits.
;

CLS$M_OPEN_CIR	=	1@CLS$V_OPEN_CIR	; Open CIRCUITS.
CLS$M_NOOPEN_CIR=	1@CLS$V_NOOPEN_CIR	; Non-open CIRCUITS.

CLS$M_ALL_CIR	=	<CLS$M_CIR!-		; All types of circuits...
			 CLS$M_OPEN_CIR!-	; ...Open CIRCUITS
			 CLS$M_NOOPEN_CIR>	; ...Non-open CIRCUITS

;
; Masks for all types of connections.
;

CLS$M_OPEN_CON	=	1@CLS$V_OPEN_CON	; Open CONNECTIONS
CLS$M_NOOPEN_CON=	1@CLS$V_NOOPEN_CON	; Non-open CONNECTIONS

CLS$M_ALL_CON	=	<CLS$M_CON!-		; All types of CONNECTIONS...
			 CLS$M_OPEN_CON!-	; ...Open CONNECTIONS
			 CLS$M_NOOPEN_CON>	; ...Non-open CONNECTIONS

;
; Define the longword indices into the GET_DATA call frame.
;

CLUB_IN		=	1
SB_IN		=	2
CSB_IN		=	3
PB_IN		=	4
CDT_IN		=	5
PDT_IN		=	6
MB_IN		=	7

;
; Masks for event flags.
;

EVF$V_TIM_FLAG	=	1		; Refresh timer expired.
EVF$V_AST_FLAG	=	2		; AST delivery.

EVF$M_TIM_FLAG	=	1@EVF$V_TIM_FLAG
EVF$M_AST_FLAG	=	1@EVF$V_AST_FLAG

;
; Miscellaneous flags.
;

MF$V_INIT_FLAG	=	0		; Initialization in progress.
MF$V_EXIT_FLAG	=	1		; User requested exit.
MF$V_INVERSE	=	2		; Field is to be displayed in inverse
					;  video.
MF$V_RIP	=	3		; Indicates that a refresh is in
					;  progress.
MF$V_CONT	=	4		; Indicates that the display is to be
					;  updated continuously.
MF$V_CYCLE	=	5		; Indicates that the display is to be
					;  cycled every other update.
MF$V_IN_OPEN	=	6		; Indicates that a command procedure
					;  file is open.
MF$V_NEW_CHAR	=	7		; Indicates terminal characteristics
					;  have been modified.
MF$V_SCROLL	=	8		; Indicates that the screen has been
					;  scrolled.
MF$V_VALID_MSG	=	9		; Indicates valid ascii string found in
					;  message buffer.
MF$V_CR_FOUND	=	10		; Indicates that a valid ascii string
					;  followed by a carriage return has
					;  been found in the message buffer.

MF$M_INIT_FLAG	=	1@MF$V_INIT_FLAG
MF$M_EXIT_FLAG	=	1@MF$V_EXIT_FLAG
MF$M_INVERSE	=	1@MF$V_INVERSE
MF$M_RIP	=	1@MF$V_RIP
MF$M_CONT	=	1@MF$V_CONT
MF$M_CYCLE	=	1@MF$V_CYCLE
MF$M_IN_OPEN	=	1@MF$V_IN_OPEN
MF$M_NEW_CHAR	=	1@MF$V_NEW_CHAR
MF$M_SCROLL	=	1@MF$V_SCROLL
MF$M_VALID_MSG	=	1@MF$V_VALID_MSG
MF$M_CR_FOUND	=	1@MF$V_CR_FOUND

;
; Scroll flags.
;

SCR$V_MORE_RT	=	0		; Data has truncated off right of
					;  screen.
SCR$V_MORE_LFT	=	1		; Display has been scrolled left.
SCR$V_MORE_UP	=	2		; Display has been scrolled up.
SCR$V_MORE_DWN	=	3		; Data has been truncated off the
					;  bottom of the screen.
SCR$V_MORE	=	4		; Any "more" flag has been set.

SCR$M_MORE_RT	=	1@SCR$V_MORE_RT
SCR$M_MORE_LFT	=	1@SCR$V_MORE_LFT
SCR$M_MORE_UP	=	1@SCR$V_MORE_UP
SCR$M_MORE_DWN	=	1@SCR$V_MORE_DWN
SCR$M_MORE	=	1@SCR$V_MORE


MAX_ID		=	16		; Maximum number of system that can be
					;  removed from the display using
					;  REMOVE SYSTEM/ID=system_id.
MAXPDT		=	2		; Maximum number of port descriptor
					; tables per system.
QUE_LIMIT	=	3		; Maximum number of entries to check
					;  in an interlocked queue.
DEF_CONNCNT	=	18		; Default value for the SYSGEN
					;  parameter SCSCONNCNT.

	.SBTTL	Ascii strings.

	.PSECT	RODATA,RD,NOWRT,NOEXE

TIME_SOURCE:
	.BYTE	0

;
; Filespecs and logical names for initialization.
;

DEF_EXT:				; Default file extention for 
	.ASCII	/.INI/			;  initialization if SHOW_CLUSTER$INIT
					;  is defined.
DEF_EXT_LEN	=.-DEF_EXT		; Length of string.

DEF_NAME2:				; Default command procedures filename
	.ASCII	/SHOW_CLUSTER$INIT:.COM/;  if SHOW_CLUSTER$INIT is defined.
DEF_NAME2_LEN	=.-DEF_NAME2		; Length of string.

;
; Names of qualifiers to the DCL level SHOW command.
;

REPORT_QUAL:				; Qualifier for specifying report name.
	.ASCID	/REPORT/

CONTINUOUS_QUAL:			; Qualifier for specifying continuous
	.ASCID	/CONTINUOUS/		;  update display.

INTERVAL_QUAL:				; Qualifier for specifying interval
	.ASCID	/INTERVAL/		;  between display updates.

OUTPUT_QUAL:				; Qualifier for specifying output file.
	.ASCID	/OUTPUT/		;

ENDING_QUAL:				; Qualifier for specifying ending time.
	.ASCID	/ENDING/		;

BEGIN_QUAL:				; Qualifier for specifying starting
	.ASCID	/BEGINNING/		;  time.

;
; Ascii strings used to make up the scrolling signals.
;

MORE_DSCR:
	.ASCID	/			     More    /
MORE_TABS:				; Extra tabs for 132 column mode.
	.ASCID	/							More    /
MORE_UP:.ASCID	/^  /			; Scroll down allowed.
MORE_DWN:
	.ASCID	/v  /			; Scroll up allowed.
MORE_LFT:
	.ASCID  /<--/			; Scroll left allowed.
MORE_RT:.ASCID	/-->/			; Scroll right allowed.
NO_MORE:.ASCID	/   /


;
; Logical names.
;

IN_DEV_NAME:				; Input device name.
	.ASCID	/SYS$INPUT/		;

OUT_DEV_NAME:				; Output device name.
	.ASCID	/SYS$OUTPUT/		;

NULL_DEV_NAME:				; Null device name.
	.ASCID	/NL:/			;

LIBRARY_NAME:				; Name of help library for interactive
	.ASCID	/SYS$HELP:SHWCLHELP.HLB/;  parser.
INIT_NAME:				; Startup initialization file name.
	.ASCID	/SHOW_CLUSTER$INIT/	;

;
; Terminal control strings.
;

DCRT_NOATR_DSCR:			; DECcrt control string to turn
	.ASCID	<ESC>/[m/		;  off character attributes.

DCRT_NARROW_DSCR:			; Escape sequence used to place DECcrt
	.ASCID	/[?3l/			;  in 80 column mode.
DCRT_WIDE_DSCR:				; Escape sequence used to place DECcrt
	.ASCID	/[?3h/			;  in 132 column mode.

GRAPHICS_DSGNTR:			; Escape sequence designate special
	.ASCID	/)0/			;  graphics and line drawing character
					;  set into G1 area for DECcrt.

DELM_DSCR:				; Control string to output a
	.ASCID	/x/			; vertical bar on a DECcrt.
DELM_DSCR_LEN	=	3

INVRS_DSCR:				; Escape sequence used to turn on
	.ASCID	/[7m/			;  inverse video attribute on a DECcrt.


;
; Misc messages and ascii strings.
;

CLUSTER_MSG:
	.ASCID	/View of Cluster from/
LOCAL_MSG:
	.ASCID	/Local ports on/
MSG1_DSCR:
	.ASCID	/ system ID /
MSG2_DSCR:
	.ASCID	/  node: /
BUFF_MSG:
	.ASCID	/ CI buffer descriptors in use./
FREE_BUFF_MSG:
	.ASCID	/ CI buffer descriptors free./

PROMPT:	.ASCID	/Command > /		; Command input prompt string.
PROMPT_LEN = .-PROMPT-8


;
; Ascii strings for class headers.
;

CLASS_NAMES:	
	.ASCIC	/CLUSTER/		; Cluster (CLUB) class.
	.ASCIC	/SYSTEMS/		; Systems class.
	.ASCIC	/MEMBERS/		; Members class.
	.ASCIC	/CIRCUITS/		; Circuits class.
	.ASCIC	/CONNECTIONS/		; Connections class.
	.ASCIC	/COUNTERS/		; Counters class.
	.ASCIC	/CREDITS/		; Credits class.
	.ASCIC	/LOCAL_PORTS/		; Local-ports class.
	.ASCIC	/ERRORS/		; Errors class.

;
; ASCIC strings used by display routines to convert an output value to an ascii
; string.
;

;
; Strings used by routine DISPLAY_CABLE_STATUS to display status of the paths
; and cable (PB$B_CBL_STS, PB$B_P0_STS, and PB$B_P1_STS).
;

CB_STAT_STRG:
	.ASCIC	/  -  /			; Paths A and B are bad.
	.ASCIC	/A -  /			; Path A is good.
	.ASCIC	/  - B/			; Path B is good.
	.ASCIC	/A - B/			; Paths A and B are good.
	.ASCIC	/CROSSED/		; Cables are crossed.

CB_STAT_STRNG_LEN = 7			; Maximum possible string length.

;
; Strings used by DISPLAY_LOOPBACK_STATUS to display path loopback status
; (PDT$B_P0_LBSTS and PDT$B_P1_LBSTS).
;

LB_STAT_STRG:

	.ASCIC	/A - B/			; Loopback tests passed on paths A and
					;  B.
	.ASCIC	/A -  /			; Loopback tests passed on path A.
	.ASCIC	/  - B/			; Loopback tests passed on path B.
	.ASCIC	/  -  /			; Loopback tests failed on paths A and
					;  B.
	.ASCIC	@ N/A @			; Loopback testing is not being done.

LB_STAT_STRG_LEN = 5			; Maximum possible string length.

;
; Strings used by DISPLAY_RPORT_TYP to display the remote port type
; (PB$L_RPORT_TYP).
;

RPORT_TYP_STRNG:
	.ASCIC	/CI780/			; Remote port is a CI780...
	.ASCIC	/CI750/			; ... CI750.
	.ASCIC	/HSC50/			; ... HSC50.
	.ASCIC	//			; ... Reserved.
	.ASCIC	/KLIPA/			; ... KL10.
	.ASCIC	/CINT/			; ... CI node tester.
	.ASCIC	/NI/			; ... NI.
	.ASCIC	/PASSTH/		; ... Pass through mode.

RPORT_TYP_STRNG_LEN = 6			; Maximum possible string length.

;
; Strings used by DISPLAY_PORT_TYPE to display the port type (UCB$B_DEVTYPE).
;

DEV_TYP_STRNG:
	.ASCIC	/CI780/			; Port is a CI780.
	.ASCIC	/CI750/			; Port is a CI750.

DEV_TYP_STRNG_LEN = 5			; Maximum possible string length.

;
; Strings used by DISPLAY_PORT_STATUS to display the port status (UCB$W_STS).
;

PORT_STATUS_STRNG:			
					
	.ASCIC	/OFFLINE/		; Port is offline.
	.ASCIC	/ONLINE/		; Port is online.

PORT_STATUS_STRNG_LEN = 7		; Maximum possible string length.

;
; Strings used by DISPLAY_CIR_STATE to display the state of a circuit
; (PB$W_STATE).
;

PB_STATE_STRNG:
	.ASCIC	/CLOSED/		; Circuit is in the closed state.
	.ASCIC	/ST_SENT/		; Start sent. 
	.ASCIC	/ST_REC/		; Start received. 
	.ASCIC	/OPEN/			; Circuit is in the open state.
	.ASCIC	/VC_FAIL/		; Virtual circuit failure in progress. 

PB_STATE_STRNG_LEN = 7			; Maximum possible string length.

;
; Strings used by DISPLAY_RSTATE to display the state of the remote port
; (PB$B_RSTATE).
;

PB_RSTATE_STRNG:
	.ASCIC	/UNINIT/		; Remote port is uninitialized.
	.ASCIC	/M_UNINIT/		; Remote port is in maintenance mode
					;  and is uninitialized.
	.ASCIC	/DISAB/			; Remote port is disabled.
	.ASCIC	/M_DISAB/		; Remote port is in maintenance mode
					;  and is disabled.
	.ASCIC	/ENAB/			; Remote port is enabled.
	.ASCIC	/M_ENAB/		; Remote port is in maintenance mode
					;  and is enabled.

PB_RSTATE_STRNG_LEN = 8			; Maximum possible string length.

;
; Strings used by DISPLAY_CON_STATE to display the connection state
; (CDT$W_STATE).
;

CDT_STATE_STRNG:
	.ASCIC	/CLOSED/		; Connection is in the closed state.
	.ASCIC	/LISTEN/		; Connection is in the listen state.
	.ASCIC	/OPEN/			; Connection is in the open state.
	.ASCIC	/DISC_ACK/		; Disconnect acknowledged.
	.ASCIC	/DISC_REC/		; Disconnect request received.
	.ASCIC	/DISC_SENT/		; Disconnect sent.
	.ASCIC	/DISC_MTCH/		; Disconnect match.
	.ASCIC	/CON_SENT/		; Connect request sent.
	.ASCIC	/CON_ACK/		; Connect request sent & acknowledged.
	.ASCIC	/CON_REC/		; Connect request received.
	.ASCIC	/ACCP_SENT/		; Accept request sent.
	.ASCIC	/REJ_SENT/		; Reject sent.
	.ASCIC	/VC_FAIL/		; Virtual circuit failed.

DISPLAY_CON_STATE_LEN = 9		; Maximum possible string length.

;
; Strings used by DISPLAY_SCS_STATE to display the SCS send blocked state
; (CDT$W_BLKSTATE).
;

CDT_BLKSTATE_STRNG:
	.ASCIC	/CLEAR/			; Not blocked.
	.ASCIC	/CON_PEND/		; Waiting to send connection request.
	.ASCIC	/ACCP_PEND/		; Waiting to send accept request.
	.ASCIC	/REJ_PEND/		; Waiting to send reject request.
	.ASCIC	/DISC_PEND/		; Waiting to send disconnect request.
	.ASCIC	/CR_PEND/		; Waiting to send credit.
	.ASCIC	/DCR_PEND/		; Waiting to send credit in
					;  preparation for disconnect.

DISPLAY_SCS_STATE_LEN = 9		; Maximum possible string length.

;
; Strings used to display quorum file states.
;

YES_NO_STRING:

	.ASCIC	/YES/
	.ASCIC	/NO/

YES_NO_STRNG_LEN = 3			; Maximum length of string.

;
; Strings used by DISPLAY_CSB_STATE to display the cluster system block state
; (CSB$B_STATE).
;

CSB_STATE_STRNG:
	.ASCIC	/OPEN/			; Open.
	.ASCIC	/CLOSED/		; Closed.
	.ASCIC	/RECONNECT/		; Attempting to reconnect.
	.ASCIC	/NEW/			; New block.
	.ASCIC	/CONNECT/		; Attempting initial connection.
	.ASCIC	/ACCEPT/		; Accepting initial connection.
	.ASCIC	/DISCONNECT/		; Disconnect in progress.
	.ASCIC	/REACCEPT/		; Accepting reconnect request.
	.ASCIC	/WAIT/			; Time-out in progress.
	.ASCIC	/DEAD/			; No connection possible.

CSB_STATE_STRNG_LEN = 10		; Maximum possible length of string.

;
; Strings used by DISPLAY_CSB_STATUS to display the status of the node in the
; cluster (CSB$L_STATUS).
;

CSB_STATUS_STRNG:
	.ASCIC	/NEW/			; New system in cluster.
	.ASCIC	/BRK_NEW/		; New system - break in connection.
	.ASCIC	/MEMBER/		; System is a member of the cluster.
	.ASCIC	/BRK_MEM/		; Member - break in connection.
	.ASCIC	/NON/			; System is not a member of the cluster.
	.ASCIC	/BRK_NON/		; Non-member - break in connection.
	.ASCIC	/REMOVED/		; System is removed from the cluster.
	.ASCIC	/BRK_REM/		; Removed system - break in connection.

CSB_STATUS_STRNG_LEN = 7		; Maximum possible string length.

;
; Symbol prefix strings used by DISPLAY_FIELD to determine which SCS data
; structure contains the data.  Prefixes must be less than 4 characters.
;

SYM_PRFX:
	.ASCIC	/CLUB/			; Prefix for club offsets.
	.ASCIC	/SB$/			; Prefix for system block offsets.
	.ASCIC	/CSB$/			; Prefix for cluster system block
					;  offsets.
	.ASCIC	/PB$/			; Prefix for path block offsets.
CDT_PFX:.ASCIC	/CDT$/			; Prefix for connection descriptor
					;  table offsets.
PDT_PFX:.ASCIC	/PDT$/			; Prefix for port descriptor table
					;  offsets.
	.ASCIC	/MB$/			; Prefix for miscellaneous buffer
					;  offsets.

PFX_LIM	= 7				; Number of valid prefixes.


;
; Table used to convert SCS data size in bytes (FD$B_LENGTH) to number of
; columns needed to display the data (FD$B_MAX_DATA_SIZE).
;

CVT_TABLE:
	.BYTE	0,3,5,8,10,13,15,17,20

;
; Table used to convert SB$L_HW_TYPE into a bit value to determine if
; the type of system should be displayed.
;

ASSUME	CLS$V_750_SYS	EQ	16
ASSUME	CLS$V_780_SYS	EQ	CLS$V_750_SYS+1
ASSUME	CLS$V_785_SYS	EQ	CLS$V_780_SYS+1
ASSUME	CLS$V_790_SYS	EQ	CLS$V_785_SYS+1
ASSUME	CLS$V_HSC50_SYS	EQ	CLS$V_790_SYS+1
ASSUME	CLS$V_HSC60_SYS	EQ	CLS$V_HSC50_SYS+1

HW_TYPE_TABLE:
	.LONG	^A/V750/		; 750 systems.
	.LONG	^A/V780/		; 780 systems.
	.LONG	^A/V785/		; 785 systems.
	.LONG	^A/8800/		; 790 systems.
	.LONG	^A/HS50/		; HSC50 systems.
	.LONG	^A/HS60/		; HSC60 systems.
NUM_HW_TYPES =	<.-HW_TYPE_TABLE>/4

;
; Table used for Hex to decimal conversion.
;

DEC_TAB:.QUAD	10000000000000000000
	.QUAD	1000000000000000000
	.QUAD	100000000000000000
	.QUAD	10000000000000000
	.QUAD	1000000000000000
	.QUAD	100000000000000
	.QUAD	10000000000000
	.QUAD	1000000000000
	.QUAD	100000000000
	.QUAD	10000000000
	.QUAD	1000000000
	.QUAD	100000000
	.QUAD	10000000
	.QUAD	1000000
	.QUAD	100000
	.QUAD	10000
	.QUAD	1000
	.QUAD	100
	.QUAD	10
	.QUAD	1

DEC_TAB_LEN = .-DEC_TAB/8
DEC_TAB_END:

;
; Starting and ending addresses of pages to be locked in working set.
; This includes the fixed length snapshot buffers and the snapshot routine
; itself.  It does not include the variable length buffers which must be
; locked separately.
;

SNAP_ADRS:
	.ADDRESS -			; Starting and ending addresses of
		SNAP_BUF,SNAP_END	;  snapshot routine.

;
; Item list for terminal QIO function modifiers.
;

TERM_LIST:
	.WORD	0
	.WORD	TRM$_MODIFIERS
	.LONG	TRM$M_TM_NOEDIT
	.LONG	0
TERM_LIST_LEN =	.-TERM_LIST

;
; List of parameters request by $GETDVI.
;

GET_LIST:
	.WORD	4			; Buffer size.
	.WORD	DVI$_DEVCLASS		; Request device class
	.ADDRESS -			; Buffer address.
		DEVICE_CLASS		;
	.LONG	0			; Length not needed.

	.WORD	4			; Buffer size.
	.WORD	DVI$_DEVTYPE		; Request device type.
	.ADDRESS -			; Buffer address.
		DEVICE_TYPE		;
	.LONG	0			; Length not needed.

	.WORD	4			; Buffer size.
	.WORD	DVI$_DEVDEPEND		; Request device dependent information.
	.ADDRESS -			; Buffer address.
		DEVDEPEND		;
	.LONG	0			; Length not needed.

	.WORD	4			; Buffer size.
	.WORD	DVI$_DEVDEPEND2		; Request additional device dependent
					;  information.
	.ADDRESS -			; Buffer address.
		DEVDEPEND2		;
	.LONG	0			; Length not needed.

	.WORD	4			; Buffer size.
	.WORD	DVI$_DEVBUFSIZ		; Request device buffer size.
	.ADDRESS -			; Buffer address.
		BUFFER_SIZE
	.LONG	0			; Length not needed.

	.LONG	0			; End of list.


;
; List of parameters request by $GETJPI.
;

JPI_LIST:
	.WORD	4			; Buffer size.
	.WORD	JPI$_CURPRIV		; Request process's current privileges.
	.ADDRESS -			; Buffer address.
		CUR_PRIV		;
	.LONG	0			; Length not needed.

	.LONG	0			; End of list.


	.SBTTL	Local storage.

	.PSECT	RWDATA,RD,WRT,NOEXE

BUFADR:	.LONG	0			; Temporary storage for queue buffer
					;  address.
BUFSIZE:.LONG	MBX_BUF_LEN		; Buffer size.

MSG_FRE_QUE:				; Queue of allocated message buffers.
	.LONG	MSG_FRE_QUE,MSG_FRE_QUE	;
MSG_OUT_QUE:				; Queue of broadcast messages to be
	.LONG	MSG_OUT_QUE,MSG_OUT_QUE	;  output.

SCRATCH:				; Temporary storage used for displaying
	.LONG	0			;  PROTOCOL field.

;
; File access block for input file.  Used when executing a command procedure
; or when executing Show Cluster from a file stream.  The default filename
; extention is .COM.
;

INFAB:	$FAB	DNM = <.COM>,-
		FNA = IN_FILE_SPEC,-
		FNS = IN_FILE_SPEC_LEN,-
		FOP = NAM,-
		NAM = INAM_BLOCK

INAM_BLOCK:
	$NAM	ESA = IN_EXP_NAME,-	; Address to store expanded filespec.
		ESS = IN_EXP_NAME_LEN	; Address to store length of expanded
					;  filespec.

IN_FILE_SPEC:				; Buffer for filespec for procedure.
	.BLKB	80			;
IN_FILE_SPEC_LEN = .-IN_FILE_SPEC	;

IN_EXP_DSCR:				; Descriptor for expanded filespec.
	.LONG	80			;
	.LONG	IN_EXP_NAME		;
IN_EXP_NAME:				; Buffer for expanded filespec.
	.BLKB	80			;
IN_EXP_NAME_LEN = . -IN_EXP_NAME	;


;
; Output file access block.  Used for /OUTPUT= or when SYS$OUTPUT has been
; defined to be a file.  The default filename is SHWCLSTR.DAT.
;

OUTFAB:	$FAB	DNM = <SHWCLSTR.DAT>,-
		FAC = PUT,-
		FNA = OUT_FILE_SPEC,-
		FNS = OUT_FILE_SPEC_LEN,-
		FOP = NAM,-
		NAM = OUTNAM_BLOCK

OUTNAM_BLOCK:
	$NAM	ESA = OUT_EXP_NAME,-	; Address to store expanded filespec.
		ESS = OUT_EXP_NAME_LEN	; Address to store length of expanded
					;  filespec.

OUT_FILE_SPEC:				; Buffer for filespec for procedure.
	.BLKB	80			;
OUT_FILE_SPEC_LEN = .-OUT_FILE_SPEC	;

OUT_EXP_DSCR:				; Descriptor for expanded filespec.
	.LONG	80			;
	.LONG	OUT_EXP_NAME		;
OUT_EXP_NAME:				; Buffer for expanded filespec.
	.BLKB	80			;
OUT_EXP_NAME_LEN = . -OUT_EXP_NAME	;

;
; Establish a record access block.  Used when inputing from a procedure or
; when executing from a file stream.
;

INRAB:	$RAB	FAB = INFAB,-		; Pointer to FAB.
		UBF = REC_BUFF,-	; Record buffer.
		USZ = REC_SIZE		; Record buffer size.

REC_DSCR:				; Descriptor for record buffer.
	.LONG	0			;
	.LONG	REC_BUFF		;
REC_BUFF:				; Record buffer.
	.BLKB	132			;
REC_SIZE = .-REC_BUFF			;


TRAN_DSCR:				; Descriptor for SHOW_CLUSTER$INIT
					;  translation.
	.LONG	64			; Length.
	.ADDRESS -			; Address of buffer.
		TRAN_BUF		;
TRAN_BUF:				; Buffer.
	.BLKB	64			;

BUF_COUNT:				; Number of times we've allocated some
	.BYTE	0			;  buffer space. (2 max)

SB_COUNT:				; Maximum number of entries to be stored
	.WORD	0			;  in the system block buffer.
CSB_COUNT:				; Maximum number of entries to be stored
	.WORD	0			;  in the cluster system block buffer.
PB_COUNT:				; Maximum number of entries to be stored
	.WORD	0			;  in the path block buffer.
CDT_COUNT:				; Maximum number of entries to be stored
	.WORD	0			;  in the CDT buffer.

VAR_BUF:.LONG	0			; Address of variable length buffer
					;  returned from GET_VM.
VAR_BUF_END:				; End of variable buffer space.
	.LONG	0			;
VAR_BUF_LEN:				; Length of variable buffer.
	.LONG	0			;

;
; Descriptors for variable length buffers from previous snapshot.
;

OLD_SB_DSCR:				; System block buffer.
	.QUAD	0			;
OLD_CSB_DSCR:				; Cluster system block buffer.
	.QUAD	0			;
OLD_PB_DSCR:				; Path block buffer.
	.QUAD	0			;
OLD_CDT_DSCR:				; CDT buffer.
	.QUAD	0			;

OLD_VAR_BUF:				; Address of previous buffer.
	.LONG	0			;

OLD_VAR_BUF_END:			; End of previous buffer.
	.LONG	0			;

OLD_VAR_BUF_LEN:			; Length of previous buffer.
	.LONG	0			;

NUM_FIELDS:				; Number of fields to be displayed
	.BYTE	0			;  Used to limit left-scrolling.
SCS_NUM_FIELDS:				; Number of SCS fields to be displayed.
	.BYTE	0			;
CLUB_NUM_FIELDS:			; Number of CLUB fields to be displayed.
	.BYTE	0			;

NUM_LINES:				; Number of lines of data this pass.
	.LONG	0			;
PRIOR_NUM_LINES:			; Number of lines of data last pass.
	.LONG	0			;
SCROLL_LINES:				; Copy of PRIOR_NUM_LINES used to
	.LONG	0			;  limit up scrolling.

;
; LINE_DIF is a record of the lines in the display that need to be redrawn
; because data on that line has changed.  Bit 7 corresponds to line #7,
; Bit 8 - line #8, etc.  LINE_DIF is used to save the time of redrawing lines
; in the display that haven't changed since the last pass.
;
; PRIOR_LINE_DIF is a record of the lines that were redrawn in the last pass.
; PRIOR_LINE_DIF is used to turn off fields that have been set to inverse
; video on the previous pass.
;
; Differences in lines are detected by the following routines:
;
;	GET_DATA	(Detects changes in data through setting of inverse
;			video flag by the CHECK_DIF routine)
;	CHECK_POS	Detects change in area of the screen where a system
;			is displayed without the data changing.
;	CHECK_NUM_PB	Detects changes in the number of circuits so that
;			NUM_CIRCUITS is updated.
;	CHECK_NUM_CDT	Detects changes in the number of connections so that
;			NUM_CONNECTIONS is updated.
;
; NOTES:
;
;	LINE_DIF is cleared (actually SCROLL_DIF is copied to LINE_DIF)
;	before each display is built after being copied to PRIOR_LINE_DIF.
;
;	LINE_DIF is used only by GET_DATA to determine if the line has to
;	be redrawn because the line has fields that need to be updated.
; 
;	PRIOR_LINE_DIF is used only by GET_DATA to redrawn the line so that
;	any fields set to inverse video will be cleared.
;

LINE_DIF:				; Reserve one longword to record the
	.LONG	0			; changes in data lines on the current
					;  pass.
PRIOR_LINE_DIF:				; Reserve one longword to save a record
	.LONG	0			; of changes in data lines on the
					;  previous pass.

;
; BLANKS_LINES is used to record which lines in the display have all the fields
; filled in with blanks.  This together with PRIOR_BLANK_LINES is used to
; save the time of redrawing a blank line every time the screen is updated.
;
;NOTES:
;
;	BLANK_LINES is cleared before each display is build after being
;	copied to PRIOR_BLANK_LINES.
;
;	BLANK_LINES and PRIOR_BLANK_LINES are used only by the GET_BLANK
;	routine to determine if the line should be drawn or not.
;

BLANK_LINES:				; Reserve one longword to save a record
	.LONG	0			;  of the blank lines that are output.
PRIOR_BLANK_LINES:			; Reserve one longword to save a record
	.LONG	0			;  of blank lines from previous pass.

;
; SCROLL_DIF is used to record which lines is the display must be redrawn
; because the screen was hardware scrolled.  When the screen is hardware
; scrolled one or more blank lines are left at the top or bottom of the
; scrolling region and need to be filled in.
;
;NOTES:
;
;	SCROLL_DIF is cleared after the display has been built and before
;	any scroll commands can be issued.
;
;	SCROLL_DIF is copied to LINE_DIF before the display is built so
;	that the line are considered "changed" lines.
;

SCROLL_DIF:				; Indicates which line on a DECcrt
	.LONG	0			;  must be redrawn because the screen
					;  scrolled.  (Because the screen is
					;  hardware scrolled).

NODE_NAME_DSCR:				; Reserve room for storing the node
	.LONG	0			;  name of the local system.
	.LONG	NODE_NAME		;
NODE_NAME:				;
	.BLKB	8			;

;
; Scrolling parameters.
;

SCROLL_DELAY:				; Number of refreshes it takes to
	.LONG	0			;  scroll the bottom two lines out of
					;  the scrolling region.

V_SCROLL:.LONG	0			; Number of data lines to be skipped by
					;  the GET_DATA routine before a line
					;  of data is added to the screen
					;  buffer.
V_SCROLL_LINE:				; Counter for the number of lines
	.LONG	0			;  skipped by the GET_DATA routine.

CLSTR_H_SCROLL:				; Number of field entries to be skipped 
	.LONG	0			;  in the cluster report by the 
					;  FIND_ENTRY routine before success is
					;   returned.

LOCAL_H_SCROLL:				; Number of field entries to be skipped
	.LONG	0			;  in the local report by the
					;  FIND_ENTRY routine before success is
					;  returned.

H_SCROLL_LINE:				; Counter for the number of entries
	.LONG	0			;  skipped by the FIND_ENTRY routine.

TOP_CMD_LINE:				; Indicates type of information last
	.BYTE	0			;  output on top command line.

BOT_CMD_LINE:				; Indicates type of information last
	.BYTE	0			;  output on bottom command line.


;
; Flags.
;

FLAG_STATE:				; Longword to receive event flag
	.LONG	0			;  status.

MISC_FLAGS:				; Miscellaneous flags.
	.LONG	0			;

SCROLL_FLAGS:				; Flags to indicate which way the
	.BYTE	0			;  screen can be scrolled.

LOCAL_SCROLL_FLAGS:			; Used to save a copy of the scroll
	.BYTE	0			;  flags for the local report.

CLSTR_SCROLL_FLAGS:			; Used to save a copy of the scroll
	.BYTE	0			;  flags for the cluster report.

HELP_FLAGS:				; Flags for LBR$OUTPUT_HELP.
	.LONG	HLP$M_PROMPT!HLP$M_HELP	; Run help in prompting mode.
					; With list of topics available.

;
; Exit routine.
;

EXIT_BLK:	
	.LONG	0			; Forward link.
	.ADDRESS -			; Exit handler address.
		EXIT_RTN		;
	.LONG	1			; Number of arguments.
	.ADDRESS -			; Address to receive exit status.
		STATUS			;

STATUS:					; Status code from $EXIT.
	.LONG	0			;

;
; Descriptor for token.  Used when a class name is parsed in case an
; error occurs.
;

TKN_DSCR:
	.QUAD	0


ERR_MSGVEC:
	.WORD	1			; Argument count.
	.WORD	^X0F			; Message flags.
	.LONG	0			; Message identification.
	.WORD	1			; FAO count.
	.WORD	0			; New message flags.
	.ADDRESS -			; Address of FAO argument.	
		TPARSE_BLK+TPA$L_TOKENCNT

MSG_OUT_ADRS:
	.LONG	0			; Address to receive OUTADRS
					;  information from $GETMSG.

;
; Broadcast messages.
;

MAX_MSG:.LONG	512			; Max message length.

BUF_QUO:.LONG	512			; Number of system memory bytes that
					;  can be used to buffer messages.

;
; Parsing
;

CMD_STATUS:				; Status returned from LIB$TPARSE.
	.LONG	0			;

TYPEAHD_BUF:				; Buffer to receive type ahead info
	.QUAD	0			;  from sensemode.

INSTRNG_LEN:				; Word to receive length of input string
	.WORD	0			;

TPARSE_BLK:				; TPARSE parameter block.
	.LONG	TPA$K_COUNT0		; Longword count.
	.LONG	TPA$M_ABBREV		; Allow abbreviation.
	.BLKL	TPA$K_LENGTH0-8		; Reserve room for parameters.

KEY_VAL:.LONG	0			; Longword to receive keyword value
					;  from LIB$LOOKUP_KEY.

KEY_OFF:.LONG	0			; Address of longword containing the bit
					;  which corresponds to the keyword.

KEY_MSK:.LONG	0			; Mask of the bit corresponding to the
					;  keyword.

KEY_DSCR:				; Address of the field descriptor
	.LONG	0			;  corresponding to the keyword.

VALUE:	.LONG	0			; Longword to receive value for SET
					;  FIELD, SET INTERVAL, or SET SCREEN
					;  command.

HELP_DSCR:				; Descriptor for help keywords.
	.QUAD	0			;

;
; Descriptors for display buffers.
;

SCREEN_DSCR:				; Descriptor for SCREEN_BUF - the
	.LONG	SCREEN_BUF_LEN		;  buffer for the screen package.
	.ADDRESS -			;
		SCREEN_BUF		;
SCREEN_BUF:				;
	.BLKB	512			;
SCREEN_BUF_LEN = .-SCREEN_BUF		;

CLASS_BOX_DSCR:				; Descriptor for CLASS_BOX_BUF - the
	.LONG	CLASS_BOX_LEN		;  buffer for line above the classes in
	.ADDRESS -			;  the header.
		CLASS_BOX_BUF		;
CLASS_BOX_BUF:				; 
	.BLKB	512			;  
CLASS_BOX_LEN =	.-CLASS_BOX_BUF		;

FIELD_TOP_BOX_DSCR:			; Descriptor for FIELD_TOP_BOX_BUF - the
	.LONG	FIELD_TOP_BOX_LEN	;  buffer for the line above the field
	.ADDRESS -			;  titles in the header.
		FIELD_TOP_BOX_BUF	;
FIELD_TOP_BOX_BUF:			;
	.BLKB	512			;
FIELD_TOP_BOX_LEN = .-FIELD_TOP_BOX_BUF	;

FIELD_BOT_BOX_DSCR:			; Descriptor for FIELD_BOT_BOX_BUF - the
	.LONG	FIELD_BOT_BOX_LEN	;  buffer for the line below the field
	.ADDRESS -			;  title in the header.
		FIELD_BOT_BOX_BUF	;
FIELD_BOT_BOX_BUF:			;
	.BLKB	512			;
FIELD_BOT_BOX_LEN = .-FIELD_BOT_BOX_BUF	;

LAST_LINE_DSCR:				; Descriptor for LAST_LINE_BUF - the
	.LONG	LAST_LINE_LEN		;  buffer for the line following the
	.ADDRESS -			;  last line of data.
		LAST_LINE_BUF		;
LAST_LINE_BUF:				; 
	.BLKB	512			;
LAST_LINE_LEN =	.-LAST_LINE_BUF		;

LAST_CLUB_LINE_DSCR:			; Descriptor for LAST_CLUB_LINE_BUF -
	.LONG	LAST_CLUB_LINE_LEN	;  the buffer for the line following the
	.ADDRESS -			;  last line of data in the CLUB
		LAST_CLUB_LINE_BUF	;  portion of the CLUSTER report.
LAST_CLUB_LINE_BUF:			; 
	.BLKB	512			;
LAST_CLUB_LINE_LEN =	.-LAST_CLUB_LINE_BUF

TITLE_DSCR:				; Descriptor for TITLE_BUF - the buffer
	.LONG	TITLE_BUF_LEN		;  which receives the titles for
	.ADDRESS -			;  display.
		TITLE_BUF		;
TITLE_BUF:				;
	.BLKB	1024			;
TITLE_BUF_LEN = .-TITLE_BUF		;

CLASS_DSCR:				; Descriptor for CLASS_BUF - the buffer
	.LONG	CLASS_BUF_LEN		;  which receives the class names for
	.ADDRESS -			;  display.
		CLASS_BUF		;
CLASS_BUF:				;
	.BLKB	1024			;
CLASS_BUF_LEN =	.-CLASS_BUF		;

DATA_DSCR:				; Descriptor for DATA_BUF the buffer
	.LONG	DATA_BUF_LEN		;  which receives the data for display.
	.ADDRESS -			;
		DATA_BUF		;
DATA_BUF:				;
	.BLKB	1024			;
DATA_BUF_LEN = .-DATA_BUF		;


;
; Miscellaneous descriptors.
;

GET_VAL_DSCR:				; Descriptor for call to CLI$GET_VALUE.
	.LONG	RET_BUF_LEN		;
	.ADDRESS -			;
		RET_BUF			;

RET_BUF_DSCR:				; Descriptor for buffer to receive
	.LONG	RET_BUF_LEN		;  string from CLI$GET_VALUE.
	.ADDRESS -			;
		RET_BUF			;
RET_BUF:.BLKB	63			;
RET_BUF_LEN = .-RET_BUF			;

LAST_BRDCST_DSCR:			; Descriptor for a copy of the last
	.LONG	0			;  broadcast message to be used to
	.ADDRESS -			; scroll the broadcast messages on
		LAST_BRDCST_BUF		; a VT52.
LAST_BRDCST_BUF:			;
	.BLKB	132			;


ERR_MSG_DSCR:				; Descriptor used to output an error
	.LONG	0			;  message.
	.ADDRESS -			;
		GET_MSG_BUF		;


GET_MSG_DSCR:				; Descriptor for buffer for $GETMSG.
	.LONG	GET_MSG_BUF_LEN		;
	.ADDRESS -			;
		GET_MSG_BUF		;
GET_MSG_BUF:				;
	.BLKB	256			;
GET_MSG_BUF_LEN = .-GET_MSG_BUF		;


ASC_TIM_DSCR:				; Descriptor used to format INCN_TIME.
	.LONG	23			; Enough room for DD-MMM-YYYY HH:MM.
	.ADDRESS -			;
		TIMBUF			;
TIMBUF:	.BLKB	23			;

MBX_MSG_DSCR:				; Descriptor for mailbox message buffer.
	.LONG	0			; Reserved to receive message length.
	.LONG	0			; Address of broadcast message (filled
					;  in by OUT_MSG routine).

MBX_BUF:.BLKB	256			; Buffer for receiving mailbox messages.
MBX_BUF_LEN = .-MBX_BUF			;

TIME_DSCR:				; Descriptor for buffer to receive
	.LONG	TIME_LEN		;  current date and time from
	.ADDRESS -			;  LIB$DATE_TIME.
			TIME_BUF	;
TIME_BUF:.BLKB	20			;
TIME_LEN = .-TIME_BUF			;

DDM_SIZE:				; Size of the display discription
	.WORD	0			;  message.

CMD_LINE_DSCR:				; Descriptor for command input buffer.
	.LONG	CMD_BUF_LEN		;
	.ADDRESS -			;
		CMD_BUF			;
CMD_BUF:				;
	.BLKB	120			;
CMD_BUF_LEN = .-CMD_BUF			;

FORMAT_BUF_DSCR:			; Descriptor for FORMAT_BUF - used to
FORMAT_BUF_LEN:				;  store the data after formatting the
	.LONG	0			;  data in ascii.
	.ADDRESS -			;
		FORMAT_BUF		;
FORMAT_BUF:				;
	.BLKB	80			;


;
; Miscellaneous parameters.
;

SWITCH:	.BYTE	0			; Controls switching between reports
					;  when /REPORT=CYCLE.  Reports are
					;  switched when bit 0 is cleared.

DELAY:	.LONG	-10*1000*1000*15,-1	; Delay time between display updates
					;  Defaults to fifteen seconds.

A_TIME:	.QUAD	0			; Quadword to receive binary time for
					;  /ENDING and /BEGINNING.

TITLE_COUNT:				; Used by GET_TITLES to calculate the
	.LONG	0			;  length of the titles in characters.

TITLE_START:				; Used by GET_TITLES to calculate the
	.LONG	0			;  length of the titles in bytes.

HEADER_SIZE:				; Size of the header in characters.
	.LONG	0			;

CLUB_HEADER_SIZE:			; Size of CLUSTER class header.
	.LONG	0			;

SCS_HEADER_SIZE:			; Size of SCS class header.
	.LONG	0			;
;
; Array for storing the length in characters of the titles as calculated by
; the GET_TITLES and SAVE_TITLE_LEN routines.  This length is used by the
; GET_CLASSES routines to center the class name.
;
;		+--------+--------+--------+--------+
;		|	Size of CLUSTER titles	    |
;		+--------+--------+--------+--------+
;		|	Size of SYSTEMS titles	    |
;		+--------+--------+--------+--------+
;		|       Size of MEMBERS titles      |
;		+--------+--------+--------+--------+
;		|      Size of CIRCUITS titles      |
;		+--------+--------+--------+--------+
;		|    Size of CONNECTIONS titles     |
;		+--------+--------+--------+--------+
;		|	Size of COUNTERS titles	    |
;		+--------+--------+--------+--------+
;		|	Size of CREDITS titles	    |
;		+--------+--------+--------+--------+
;		|     Size of LOCAL_PORTS titles    |
;		+--------+--------+--------+--------+
;		|	Size of ERRORS titles	    |
;		+--------+--------+--------+--------+

TITLE_LEN_ARRAY: 
	.BLKL	9

;
; Miscellaneous parameters for screen display.
;

CURRENT_CLASS:				; Indicates which class is currently
	.LONG	0			;  being processed for display.

DATA_CNTRL:				; Controls which classes will be
	.LONG	0			;  processed for data display.

SAVED_CLASSES:				; Used to save class selections when
	.LONG	0			;  generating the display.

LOCAL_SAVE:				; Used to save local class selections
	.LONG	0			;  when switching to cluster report.

CLUST_SAVE:				; Used to save cluster report
	.LONG	0			;  selections when switching to the
					;  local report.


;
; Buffer for device information from $GETDVI.
;

DEVICE_CLASS:				; Device class returned from $GETDVI.
	.LONG	0			;
DEVICE_TYPE:				; Device type returned from $GETDVI.
	.LONG	0			;
BUFFER_SIZE:				; Width of the terminals screen
	.LONG	0			;  returned from $GETDVI.

SAVE_CHAR_BUF:
	.BYTE	0			; Device class.
	.BYTE	0			; Device type.
	.WORD	0			; Screen width.
DEVDEPEND:				; Device terminal characteristics
	.LONG	0			;  returned from $GETDVI.
DEVDEPEND2:				; Extended terminal characteristics
	.LONG	0			;  returned from $GETDVI.
CHAR_BUF_LEN = .-SAVE_CHAR_BUF


NEW_CHAR_BUF:				; Reserve space for a copy of
	.BLKB	2			; Device class, type.
SCREEN_WIDTH:				;
	.WORD	0			; Screen width.
	.BLKL	2			; Characteristics, extended char.

OUTPUT_WIDTH:				; Output width for LBR$OUTPUT_HELP.
	.LONG	0			;


;
; Buffer for process information from $GETJPI.
;

CUR_PRIV:				; Mask of processes current privileges.
	.LONG	0			;

;
; Storage area for various terminal parameters.
;

IN_CHAN:.WORD	0			; Word to receive channel number for
					;  terminal input.

OUT_CHAN:				; Word to receive channel number for
	.WORD	0			;  terminal output.

SET_CHAN:				; Required by LIB$SET_OUTPUT.
	.LONG	0			;

MBXCHAN:.WORD	0			; Word to receive channel number
					;  assigned to the mailbox.

IOSB:	.QUAD	0			; Reserve one quadword for I/O status
					;  block.

IN_DEV:	.BYTE	0			; Input device type.
OUT_DEV:.BYTE	0			; Output device type.

LINE_NUM:				; Current line number
	.LONG	1			;
COL_NUM:				; Current column number
	.LONG	1			;
FIRST_LINE:				; First line on the screen.
	.LONG	1			;
FIRST_DATA_LINE:			; Number of the first line to contain
	.LONG	7			; display data which can be vertically
					;  scrolled.
LAST_DATA_LINE:				; Number of the last line used to
	.LONG	0			;  display data. (3rd to last on line
					;  on the terminal)
CMD_LINE:				; Number of the second to last line on
	.LONG	0			;  the terminal.
LAST_LINE:				; Number of the last line on the
	.LONG	0			;  terminal.


;
; Parameters used by the FIND_ENTRY and LOOKUP_FIELD routines.  These
; parameters control which field descriptors to use to display the report.
; 

ADRS_TABLE:				; Address of table of field descriptor
	.LONG	0			;  addresses.
BITMAP_ADRS:				; Address of bitmap to be scanned.
	.LONG	0
MAP_LEN:				; Length of the bitmap to be scanned.
	.LONG	0
START_BIT:				; Number of the bit to start the scan.
	.LONG	0
KEYTAB_ADRS:				; Address of table of keywords used to
	.LONG	0			;  identify a field


;
; List of systems that have been removed from the display by system ID number.
;

SYS_ID_LIST:
	.BLKB	6*MAX_ID		; Reserve six bytes for each possible
ID_LIST_LEN = .-SYS_ID_LIST
					;  system.
ID_LIST_ENTRYS	=	MAX_ID		; Maximum number of entries in the list.

ID_COUNT:				; Number of entries in the list.
	.LONG	0

ID_RESULT:				; Reserve one quadword for result from
	.QUAD	0			;  system ID string to hex conversion.



	.SBTTL	Macro definitions.
	.SBTTL		-	Conditional Branch Macro.

;
; The following macros are used in place of a BRANCH ON (CONDITION) instruction
; when the displacement exceeds 256 bytes.
;

;
; JLBS - used in place of BLBS
;

	.MACRO	JLBS	SOURCE,ADDRESS?L1
		BLBC	SOURCE,L1
		BRW	ADDRESS
L1:
	.ENDM	JLBS


;
; JLBC - used in place of BLBC
;

	.MACRO	JLBC	SOURCE,ADDRESS?L1
		BLBS	SOURCE,L1
		BRW	ADDRESS
L1:
	.ENDM	JLBC


;
; JNEQ - used in place of BNEQ
;

	.MACRO	JNEQ	ADDRESS?L1
		BEQL	L1
		BRW	ADDRESS
L1:
	.ENDM	JNEQ


;
; JEQL - used in place of BEQL
;

	.MACRO	JEQL	ADDRESS?L1
		BNEQ	L1
		BRW	ADDRESS
L1:
	.ENDM	JEQL


;
; JNEQU - used in place of BNEQU
;

	.MACRO	JNEQU	ADDRESS?L1
		BEQLU	L1
		BRW	ADDRESS
L1:
	.ENDM	JNEQU


;
; JEQLU - used in place of BEQLU
;

	.MACRO	JEQLU	ADDRESS?L1
		BNEQU	L1
		BRW	ADDRESS
L1:
	.ENDM	JEQLU


;
; JGTR - used in place of BGTR
;

	.MACRO	JGTR	ADDRESS?L1
		BLEQ	L1
		BRW	ADDRESS
L1:
	.ENDM	JGTR


;
; JLEQ - Used In place of BLEQ
;

	.MACRO	JLEQ	ADDRESS?L1
		BGTR	L1
		BRW	ADDRESS
L1:
	.ENDM	JLEQ


;
; JGTRU - used in place of BGTRU
;

	.MACRO	JGTRU	ADDRESS?L1
		BLEQU	L1
		BRW	ADDRESS
L1:
	.ENDM	JGTRU


;
; JLEQU - used in place of BLEQU
;

	.MACRO	JLEQU	ADDRESS?L1
		BGTRU	L1
		BRW	ADDRESS
L1:
	.ENDM	JLEQU


;
; JGEQ - used in place of BGEQ
;

	.MACRO	JGEQ	ADDRESS?L1
		BLSS	L1
		BRW	ADDRESS
L1:
	.ENDM	JGEQ


;
; JLSS - used in place of BLSS
;

	.MACRO	JLSS	ADDRESS?L1
		BGEQ	L1
		BRW	ADDRESS
L1:
	.ENDM	JLSS


;
; JGEQU - used in place of BGEQU
;

	.MACRO	JGEQU	ADDRESS?L1
		BLSSU	L1
		BRW	ADDRESS
L1:
	.ENDM	JGEQU


;
; JLSSU - used in place of BLSSU
;

	.MACRO	JLSSU	ADDRESS?L1
		BGEQU	L1
		BRW	ADDRESS
L1:
	.ENDM	JLSSU


;
; JCS - used in place of BCS
;

	.MACRO	JCS	ADDRESS?L1
		BCC	L1
		BRW	ADDRESS
L1:
	.ENDM	JCS


;
; JCC - used in place of BCC
;

	.MACRO	JCC	ADDRESS?L1
		BCS	L1
		BRW	ADDRESS
L1:
	.ENDM	JCC


;
; JVS - used in place of BVS
;

	.MACRO	JVS	ADDRESS?L1
		BVC	L1
		BRW	ADDRESS
L1:
	.ENDM	JVS


;
; JVC - used in place of BVC
;

	.MACRO	JVC	ADDRESS?L1
		BVS	L1
		BRW	ADDRESS
L1:
	.ENDM	JVC

;
; JBC - used in place of BBC
;

	.MACRO	JBC	BIT_NUM,SRC_ADRS,ADDRESS?L1
		BBS	BIT_NUM,SRC_ADRS,L1
		BRW	ADDRESS
L1:
	.ENDM	JBC

;
; JBS - used in place of BBS
;

	.MACRO	JBS	BIT_NUM,SRC_ADRS,ADDRESS?L1
		BBC	BIT_NUM,SRC_ADRS,L1
		BRW	ADDRESS
L1:
	.ENDM	JBS



	.SBTTL		-	DEFINE_FIELD macro.
; 	
; MACRO DEFINE_FIELD
;
;	This macro builts the data structures neccessary to display each field.
;
;
; ARGUMENTS -
;
; 	REPORT -
;		Report that the field will appear in.  Must be CLUSTER,
;		or LOCAL_PORTS.
;
; 	OFFSET -
;		Name of the SCS offset to use when extracting the data from the
;		SCS database.  This can be any predefined offset.  It is
;		normally one of the SCS offsets with prefixes CLUB$, SB$, CSB$,
;		PB$, CDT$, or PDT$ or a miscellaneous buffer offset with prefix
;		MB$.  This allows the default display routine DISPLAY_FIELD to
;		be used.
;
; 	LENGTH -
;		The number of bytes of data to be extracted from the SCS
;		database to display the field.
;
;		Note: For ASCIC formated fields, LENGTH must be the maximum
;		number of characters in the length of the formatted string.
;		This may differ from the number of bytes extracted if the
;		DISPLAY_FIELD routine is not used for an ASCIC field.
;
; 	TITLE -
;		Title for this field as it will appear in the display.
;
; 	FORMAT -
;		Format of display for this field.  Must be one of HEX, DEC,
;		ASCII, ASCIC, or TIME.
;
;	MINIMUM_SIZE -
;		Minimum number of columns to allow for display of this field.
;
;	DEFAULT_SIZE -
;		Default number of columns to use for display of this field.
;
;	DISPLAY_FLAG -
;		This is an optional argument.  It is non-zero if the display of
;		the field is to be enabled in the report by default.  If this
;		argument is omitted, the field will not be displayed.
;
; 	DISPLAY_ROUTINE -
;		Optional address of routine to handle display of this field.
;		If this argument is omitted, the field is displayed using the
;		routine DISPLAY_FIELD.
;
;
;	Five structures are built for each report:
;
;	'REPORT'_DSCRS -
;		This structure contains the field descriptors which contain the
;		information needed to display each of the fields in the report. 
;		The following illustrates the format of one such descriptor:
;
; 'OFFSET'_DSCR:
;			+--------+--------+--------+--------+
;			|  MAX_	 |  MAX_  |  MIN_  | FIELD_ |
;			| FIELD_ |  DATA_ | FIELD_ |  SIZE  |
;			|  SIZE	 |  SIZE  |  SIZE  |	    |
;			+--------+--------+--------+--------+
;			|     RESERVED 	  | FORMAT | LENGTH |
;			+--------+--------+--------+--------+
;			|	 FD$L_DISPLAY_ROUTINE	    |
;			+--------+--------+--------+--------+
;			|	     FD$L_CLASS		    |
;			+--------+--------+--------+--------+
;			|	     FD$L_OFFSET	    |
;			+--------+--------+--------+--------+
;			|	 FD$L_OFFSET_PRFX	    |
;			+--------+--------+--------+--------+
;
; 'TITLE'_ADRS:
;			+--------+--------+--------+--------+
;			|        	    	   |  SIZE  |
;			|		  	   +--------+
;			~	     FD$T_TITLE     	    ~
;			|		  		    |
;			|		  		    |
;			+--------+--------+--------+--------+
;
;
;	'REPORT'_TABLE -
;
;		Since the field descriptors are of variable length, this table
;		is used to locate the start of each descriptor.  It contains a
;		list of pointers to each of the	field descriptors for the
;		report.
;
;	^		+--------+--------+--------+--------+
;	|		|    ADDRESS OF FIELD DESCRIPTOR    |
;			+--------+--------+--------+--------+
; Number of fields			  .
;			 		  .
;	|		  		  .
;	v				  .
;
;
;	'REPORT'_BITMAP -
;
;		This bitmap is used to control which field in the report are
;		displayed.  Each bit in the map corresponds to one of the
;		fields in the display.  Setting the bit turns the field on.
;
;	^		+--------+--------+--------+--------+
;	|		|  ONE BIT FOR EACH FIELD IN REPORT |
;			+--------+--------+--------+--------+
; Number of fields/32			  .
;					  .
;	|		  		  .
;	v				  .
;
;
;	'REPORT'_KEYTAB -
;
;		This is a table of keywords which is used to associate a field
;		title with a bit in the bitmap.  The format of this table is
;		compatable with LIB$LOOKUP_KEY.
;
;			+--------+--------+--------+--------+
;			|	     VECTOR_COUNT	    |
;			+--------+--------+--------+--------|
;	^		+--------+--------+--------+--------+
;	|		|	    KEYWORD VALUE	    |
;			+--------+--------+--------+--------|
;  Number of fields	|   ADDRESS OF KEYWORD NAME STRING  |
;    times two		+--------+--------+--------+--------|
;					  .
;	|				  .
;	v				  .
;
;	'REPORT'_SIZE_ARRAY -
;
;		This array is used to restore the default widths for each of the
;		fields in the display.  It contains one byte for each of the
;		fields in the display.  Each byte is a copy of the byte at
;		FD$B_FIELD_SIZE in the field descriptor.
;
;	^		+--------+
; 	|		| Copy of|
;	|		| FIELD_ |
;			|  SIZE  |
; One byte for each	+--------+
;     field		    .
;			    .
;	|		    .
;	v
;
;

KEYWRDVAL	=	0

	.NOSHOW MEB

	.MACRO	DEFINE_FIELD	REPORT,OFFSET,LENGTH,TITLE,FORMAT-
				MINIMUM_SIZE,DEFAULT_SIZE,DISPLAY_FLAG=0,-
				DISPLAY_ROUTINE=DISPLAY_FIELD


	.PSECT	'REPORT'_SIZE_ARRAY,RD,WRT,NOEXE

	.BYTE	DEFAULT_SIZE		; Save the default field size for use
					;  by the INITIALIZE command.

	.PSECT	'REPORT'_DSCRS,RD,WRT,NOEXE

'OFFSET'_DSCR:
	.BYTE	DEFAULT_SIZE 		; Store the current display field size
					;  at offset FD$B_FIELD_SIZE.
	.BYTE	MINIMUM_SIZE		; Store the minimum display field size
					; at offset FD$B_MIN_FLD_SIZE.

;
; Store the maximum data size at offset FD$B_MAX_DATA_SIZE followed by maximum
; field size at offset FD$B_MAX_FLD_SIZE if data is to be displayed using ASCII
; or hexadecimal format.
;

	.IF	NE	FORMAT-DEC
	.IF	NE	FORMAT-ASCIC
	.IF	NE	FORMAT-TIME
	.BYTE	FORMAT*LENGTH
	.IF	GE	FORMAT*LENGTH-%LENGTH(TITLE)
	.BYTE	FORMAT*LENGTH
	.IFF
	.BYTE	%LENGTH(TITLE)
	.ENDC
	.ENDC
	.ENDC
	.ENDC

;
; Store the maximum data size at offset FD$B_MAX_DATA_SIZE followed by maximum
; field size at offset FD$B_MAX_FLD_SIZE if data is to be displayed using ASCIC
; format.
;
	.IF	EQ	FORMAT-ASCIC
	.BYTE	FORMAT/ASCIC*LENGTH
	.IF	GE	FORMAT/ASCIC*LENGTH-%LENGTH(TITLE)
	.BYTE	FORMAT/ASCIC*LENGTH
	.IFF
	.BYTE	%LENGTH(TITLE)
	.ENDC
	.ENDC

;
; Store the maximum data size at offset FD$B_MAX_DATA_SIZE followed by maximum
; field size at offset FD$B_MAX_FLD_SIZE if data is to be displayed as a time
; string.
;
	.IF	EQ	FORMAT-TIME
	.BYTE	LENGTH
	.IF	GE	LENGTH-%LENGTH(TITLE)
	.BYTE	LENGTH
	.IFF
	.BYTE	%LENGTH(TITLE)
	.ENDC
	.ENDC

;
; Store the maximum data size at offset FD$B_MAX_DATA_SIZE followed by maximum
; field size at offset FD$B_MAX_FLD_SIZE if data is to be displayed using
; decimal format.
;
	.IF	EQ	FORMAT-DEC
	LEN = 1
	.IRP	SIZE,<3,5,8,10,13,15,17,20>
	.IIF	EQ	LENGTH-LEN,	DEC_SIZE	=	SIZE
	LEN = LEN +1
	.ENDR
	.BYTE	DEC_SIZE
	.IF	GE	DEC_SIZE-%LENGTH(TITLE)
	.BYTE	DEC_SIZE
	.ENDC
	.IF	LT	DEC_SIZE-%LENGTH(TITLE)
	.BYTE	%LENGTH(TITLE)
	.ENDC
	.ENDC

	.BYTE	LENGTH			; Store the number of bytes that appear
					;  in the SCS database for this field
					;  at offset FD$B_LENGTH.
	.BYTE	FORMAT			; Store the type of format to use to
					;  display the data at offset
					;  FD$B_FORMAT.
	.WORD	0			; Reserve on one.
	.ADDRESS -			; Store the address of the routine used
		DISPLAY_ROUTINE		;  to display the field at offset
					; FD$L_DISPLAY_ROUTINE.
	.LONG	CLASS			; Store the family type that this field
					;  is a member of at offset FD$L_CLASS.
	.LONG	'OFFSET'		; Store the value of the SCS data
					;  structure offset for this field at
					; offset FD$L_OFFSET.
;
; Save the first four characters of the offset name at offset
; FD$L_OFFSET_PRFX.
;
	.IIF EQ %LOCATE(<CLUB$>,OFFSET),	.LONG	^A/CLUB/
	.IIF EQ %LOCATE(<SB$>,OFFSET),		.LONG	^A/SB$ /
	.IIF EQ %LOCATE(<CSB$>,OFFSET),		.LONG	^A/CSB$/
	.IIF EQ %LOCATE(<PB$>,OFFSET),		.LONG	^A/PB$ /
	.IIF EQ %LOCATE(<CDT$>,OFFSET),		.LONG	^A/CDT$/
	.IIF EQ %LOCATE(<PDT$>,OFFSET),		.LONG	^A/PDT$/
	.IIF EQ %LOCATE(<MB$>,OFFSET),		.LONG	^A/MB$ /
	.IIF EQ %LOCATE(<SCS$>,OFFSET),		.LONG	^A/SCS$/

	.IIF EQ %LOCATE(<$>,OFFSET) - %LENGTH(OFFSET),	.LONG	0
	
;
; Store the ascii title at offset FD$T_TITLE.  Create a label for the
; location where the title is stored.  The label is the same as the title, but
; is followed by '_ADRS'.
;

'TITLE'_ADRS:


;
; Now save the title as an ASCIC string.  This will place the length of the
; string at offset FD$B_TITLE_SIZE and the string at offset FD$T_TITLE.
;
	.ASCIC	/TITLE/			; Title for display field.
					; FD$B_TITLE_SIZE
					; FD$T_TITLE

	.PSECT	'REPORT'_TABLE,RD,NOWRT,NOEXE

	.ADDRESS -			; Store descriptor address in the
		'OFFSET'_DSCR		;  address table.
'REPORT'_TAB_LEN = .-'REPORT'_TABLE	; Calculate length of the table.

	.PSECT	'REPORT'_BITMAP,RD,WRT,NOEXE

;
; Every 33 times we invoke this macro, save the mask we are building in the
; bitmap and reset the mask to 0.  Also increment the count of the number of
; longwords in the map.
;

COUNT		=	COUNT+1
	.IF	EQ	COUNT-33
	.LONG	MASK			; Save the mask in the bitmap.

MAP_LENGTH	=	MAP_LENGTH+1	; Increase count of the number of
					;  longwords in the map.
MASK		=	0		; Clear the mask.
COUNT		=	1		; Reinitialize the counter.
MASK_BIT	=	1		; Start over with bit 0.

	.ENDC

;
; If the display flag for this field descriptor is non-zero the this field is
; to be displayed.  Set the bit for this field by combining the bit value for
; this field with the bit mask.
;

	.IF	NE	DISPLAY_FLAG
MASK		=	MASK!MASK_BIT
	.ENDC

;
; On to the next bit.
;

MASK_BIT	=	MASK_BIT@1


	.PSECT	'REPORT'_KEYTABLE


;
; Save the address of the title string in the keyword table.  This address is
; used by LIB%LOOKUP_KEY.
;

	.ADDRESS -
		'TITLE'_ADRS


;
; Save the keyword value in the keyword table.  This value is used by
; LIB$LOOKUP_KEY.
;

	.LONG	KEYWRDVAL

KEYWRDVAL	=	KEYWRDVAL+1

	.ENDM	DEFINE_FIELD



	.SBTTL	Cluster report field descriptors.
	.SAVE_PSECT

;
; Initialize counters and masks.
;

MASK_BIT	=	1
MASK		=	0
COUNT		=	0
MAP_LENGTH	=	-1

;
; Create labels which will be used to reference each of the data structures
; used in the cluster report as created by the DEFINE_FIELD macro.
;
	.PSECT	CLUSTER_SIZE_ARRAY,RD,WRT,NOEXE
CLUSTER_SIZE_ARRAY:

	.PSECT	CLUSTER_BITMAP,RD,WRT,NOEXE
CLUSTER_BITMAP:

	.PSECT	CLUSTER_TABLE,RD,NOWRT,NOEXE
CLUSTER_TABLE:

	.PSECT	CLUSTER_KEYTABLE,RD,NOWRT,NOEXE
CLUSTER_KEYTAB:
	.LONG	0

;
; Define the fields that make up the CLUSTER class.
;

CLASS	=	CLS$M_CLUB

	DEFINE_FIELD	<CLUSTER>,<CLUB$W_QUORUM>,2,<CL_QUORUM>,DEC,4,4,1
	DEFINE_FIELD	<CLUSTER>,<CLUB$W_VOTES>,2,<CL_VOTES>,DEC,4,4,1
	DEFINE_FIELD	<CLUSTER>,<CLUB$T_QDNAME>,16,<QD_NAME>,ASCIC,6,15,1
	DEFINE_FIELD	<CLUSTER>,<CLUB$L_FLAGS>,YES_NO_STRNG_LEN,-
			<QF_VOTE>,ASCIC,4,4,1,DISPLAY_QF_VOTE
	DEFINE_FIELD	<CLUSTER>,<CLUB$W_QDVOTES>,2,<CL_QDVOTES>,DEC,4,6
	DEFINE_FIELD	<CLUSTER>,<CLUB$W_MEMSEQ>,2,<MEMSEQ>,DEC,4,6
	DEFINE_FIELD	<CLUSTER>,<CLUB$Q_FTIME>,TIME_STRING_LEN,<FORMED>,-
			TIME,6,15,1
	DEFINE_FIELD	<CLUSTER>,<CLUB$Q_LST_TIME>,TIME_STRING_LEN,-
			<LAST_TRANSITION>,TIME,6,15,1

;
; Define the fields that make up the SYSTEMS class.
;

CLASS	=	CLS$M_SYS	

	DEFINE_FIELD	<CLUSTER>,<SB$T_NODENAME>,16,<NODE>,ASCIC,2,6,1
	DEFINE_FIELD	<CLUSTER>,<SB$B_SYSTEMID>,6,<SYS_ID>,DEC,2,8
	DEFINE_FIELD	<CLUSTER>,<SB$B_HWVERS>,12,<HW_VERS>,HEX,2,20
SB$T_HWTYPE = SB$Q_SWINCARN + 8
	DEFINE_FIELD	<CLUSTER>,<SB$T_HWTYPE>,4,<HW_TYPE>,ASCII,4,4
	DEFINE_FIELD	<CLUSTER>,<SB$T_SWVERS>,4,<SOFTWARE>,ASCII,3,8,1,-
			DISPLAY_SOFTWARE
	DEFINE_FIELD	<CLUSTER>,<SB$SHC$L_NUM_PB>,2,<NUM_CIRCUITS>,DEC,7,7
	DEFINE_FIELD	<CLUSTER>,<SB$W_MAXDG>,2,<DG_SIZE>,DEC,2,4
	DEFINE_FIELD	<CLUSTER>,<SB$W_MAXMSG>,2,<MSG_SIZE>,DEC,2,5
	DEFINE_FIELD	<CLUSTER>,<SB$Q_SWINCARN>,8,<INCARNATION>,HEX,2,14
SB$Q_SWINCARN_2 = SB$Q_SWINCARN
	DEFINE_FIELD	<CLUSTER>,<SB$Q_SWINCARN_2>,TIME_STRING_LEN,-
			<INCN_TIME>,TIME,6,9

;
; Define the fields that make up the MEMBERS class.
;

CLASS		=	CLS$M_CSB

	DEFINE_FIELD	<CLUSTER>,<CSB$L_CSID>,4,<CSID>,HEX,5,6
	DEFINE_FIELD	<CLUSTER>,<CSB$W_SENDSEQNM>,2,<SEND_SQ>,DEC,6,6
	DEFINE_FIELD	<CLUSTER>,<CSB$W_RCVDSEQNM>,2,<RCVD_SQ>,DEC,6,6
	DEFINE_FIELD	<CLUSTER>,<CSB$W_ACKRSEQNM>,2,<ACKR_SQ>,DEC,4,6
	DEFINE_FIELD	<CLUSTER>,<CSB$W_LCKDIRWT>,2,<DIR_WT>,DEC,4,6
	DEFINE_FIELD	<CLUSTER>,<CSB$B_UNACKEDMSGS>,1,<UNACKED>,DEC,3,5
	DEFINE_FIELD	<CLUSTER>,<CSB$B_REMACKLIM>,1,<ACK_LM>,DEC,4,5
	DEFINE_FIELD	<CLUSTER>,<CSB$B_ECOLVL>,2,<PROTOCOL>,DEC,3,5,,-
			DISPLAY_PROTOCOL
	DEFINE_FIELD	<CLUSTER>,<CSB$B_WARMCDRPS>,1,<WARMCDRPS>,DEC,1,5
	DEFINE_FIELD	<CLUSTER>,<CSB$B_STATE>,CSB_STATE_STRNG_LEN,-
			<CNX_STATE>,ASCIC,5,6,,DISPLAY_CSB_STATE
	DEFINE_FIELD	<CLUSTER>,<CSB$W_VOTES>,2,<VOTES>,DEC,1,5
	DEFINE_FIELD	<CLUSTER>,<CSB$W_QUORUM>,2,<QUORUM>,DEC,1,6
	DEFINE_FIELD	<CLUSTER>,<CSB$W_QDVOTES>,2,<QDVOTES>,DEC,4,7

CSB$L_STATUS1	=	CSB$L_STATUS
	DEFINE_FIELD	<CLUSTER>,<CSB$L_STATUS1>,YES_NO_STRNG_LEN,-
			<QF_SAME>,ASCIC,4,7,,DISPLAY_QF_SAME
CSB$L_STATUS2	=	CSB$L_STATUS
	DEFINE_FIELD	<CLUSTER>,<CSB$L_STATUS2>,YES_NO_STRNG_LEN,-
			<QF_ACTIVE>,ASCIC,4,9,,DISPLAY_QF_ACTIVE
	DEFINE_FIELD	<CLUSTER>,<CSB$L_STATUS>,CSB_STATUS_STRNG_LEN,-
			<STATUS>,ASCIC,3,7,1,DISPLAY_CSB_STATUS
	DEFINE_FIELD	<CLUSTER>,<CSB$Q_REFTIME>,TIME_STRING_LEN,-
			<TRANSITION_TIME>,TIME,6,15,,
;
; Define the fields that make up the CIRCUITS class.
;

CLASS		=	CLS$M_CIR

	DEFINE_FIELD	<CLUSTER>,<PB$T_LPORT_NAME>,4,<LPORT_NAME>,ASCII,3,5
	DEFINE_FIELD	<CLUSTER>,<PB$B_RSTATION>,6,<RPORT_NUM>,DEC,2,5,1
	DEFINE_FIELD	<CLUSTER>,<PB$B_RST_PORT>,1,<RP_OWNER>,DEC,5,6
	DEFINE_FIELD	<CLUSTER>,<PB$L_RPORT_TYP>,RPORT_TYP_STRNG_LEN,-
			<RP_TYPE>,ASCIC,5,6,1,DISPLAY_RPORT_TYP
	DEFINE_FIELD	<CLUSTER>,<PB$SHC$L_NUM_CDT>,4,<NUM_CONNECTIONS>,DEC,7,7
	DEFINE_FIELD	<CLUSTER>,<PB$W_STATE>,PB_STATE_STRNG_LEN,-
			<CIR_STATE>,ASCIC,5,7,1,DISPLAY_CIR_STATE
	DEFINE_FIELD	<CLUSTER>,<PB$B_RSTATE>,PB_STATE_STRNG_LEN,-
			<REM_STATE>,ASCIC,6,7,,DISPLAY_RSTATE
	DEFINE_FIELD	<CLUSTER>,<PB$B_CBL_STS>,CB_STAT_STRNG_LEN,-
			<CABLE_STATUS>,ASCIC,5,5,,DISPLAY_CABLE_STATUS
	DEFINE_FIELD	<CLUSTER>,<PB$L_RPORT_REV>,4,<RP_REVISION>,HEX,5,8
	DEFINE_FIELD	<CLUSTER>,<PB$L_RPORT_FCN>,4,<RP_FUNCTIONS>,HEX,5,8
	DEFINE_FIELD	<CLUSTER>,<PB$L_WAITQFL>,4,<SCS_WAITERS>,DEC,2,5,,

;
; Define the fields that make up the CONNECTIONS class.
;

CLASS		=	CLS$M_CON

	DEFINE_FIELD	<CLUSTER>,<SCS$T_DST_PROC>,16,<LOC_PROC_NAME>,-
			ASCII,8,16,1,DISPLAY_PROC_NAME
	DEFINE_FIELD	<CLUSTER>,<SCS$T_SRC_PROC>,16,<REM_PROC_NAME>,-
			ASCII,8,16,,DISPLAY_PROC_NAME
	DEFINE_FIELD	<CLUSTER>,<CDT$W_STATE>,DISPLAY_CON_STATE_LEN,-
			<CON_STATE>,ASCIC,6,7,1,DISPLAY_CON_STATE
	DEFINE_FIELD	<CLUSTER>,<CDT$L_LCONID>,4,<LOC_CONID>,HEX,8,9,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_RCONID>,4,<REM_CONID>,HEX,8,9,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_BLKSTATE>,DISPLAY_SCS_STATE_LEN,-
			<SCS_STATE>,ASCIC,6,7,,DISPLAY_SCS_STATE

;
; Define the fields that make up the COUNTERS class.
;

CLASS		=	CLS$M_CNT
	DEFINE_FIELD	<CLUSTER>,<CDT$L_DGSENT>,4,<DGS_SENT>,DEC,5,5,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_DGRCVD>,4,<DGS_RCVD>,DEC,5,5,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_DGDISCARD>,4,<DGS_DSCRD>,DEC,-
			5,5,,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_MSGSENT>,4,<MSGS_SENT>,DEC,6,6,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_MSGRCVD>,4,<MSGS_RCVD>,DEC,6,6,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_SNDDATS>,4,<BLKS_SENT>,DEC,6,6,,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_REQDATS>,4,<BLKS_REQ>,DEC,3,6,,
	DEFINE_FIELD	<CLUSTER>,<CDT$L_BYTSENT>,4,<KB_SENT>,DEC,4,4,,-
			DISPLAY_KBYTES
	DEFINE_FIELD	<CLUSTER>,<CDT$L_BYTREQD>,4,<KB_RCVD>,DEC,4,4,,-
			DISPLAY_KBYTES
	DEFINE_FIELD	<CLUSTER>,<CDT$L_BYTMAPD>,4,<KB_MAPPED>,DEC,4,4,,-
			DISPLAY_KBYTES
	DEFINE_FIELD	<CLUSTER>,<CDT$W_QCR_CNT>,2,<CR_WAITS>,DEC,1,4,,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_QBDT_CNT>,2,<BDT_WAITS>,DEC,1,5,,

;
; Define the fields that make up the CREDITS class.
;

CLASS		=	CLS$M_CRD

	DEFINE_FIELD	<CLUSTER>,<CDT$W_SEND>,2,<SEND>,-
			DEC,1,4,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_MINSEND>,2,<MIN_SEND>,-
			DEC,5,5,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_REC>,2,<RECEIVE>,-
			DEC,1,3,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_PENDREC>,2,<PEND_REC>,-
			DEC,1,6,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_INITLREC>,2,<INIT_REC>,-
			DEC,1,6,1,
	DEFINE_FIELD	<CLUSTER>,<CDT$W_MINREC>,2,<MIN_REC>,-
			DEC,5,5,1,

	.PSECT	CLUSTER_KEYTABLE,RD,NOWRT,NOEXE

NUM_CLUSTER_DSCRS = KEYWRDVAL		; Save the number of descriptors in the
					;  cluster report.

. =	CLUSTER_KEYTAB			; Save the vector count for
	.LONG	KEYWRDVAL*2		;  LIB$LOOKUP_KEY.
. =	.+KEYWRDVAL*2


;
; Save any partial mask in the bitmap and increase the count of the bitmap's
; length.
;
	.PSECT	CLUSTER_BITMAP,RD,WRT,NOEXE

	.IF	NE	COUNT-33
	.LONG	MASK
	MAP_LENGTH	=	MAP_LENGTH+1
	.ENDC

CLUSTER_MAP_LEN = MAP_LENGTH		; Save the number of longwords in the
					;  cluster bitmap.

CL_SAVE_BITMAP:				; Reserve enough room for a copy of the
	.BLKL	MAP_LENGTH+1		;  cluster bitmap to be used by the
					;  INITIALIZE command.



	.SBTTL	Local status report field descriptors.
;
; Initialize counters and masks.
;

MASK_BIT	=	1
MASK		=	0
COUNT		=	0
MAP_LENGTH	=	-1
KEYWRDVAL	=	0

;
; Create labels which will be used to reference each of the data structures
; used in the local report as created by the DEFINE_FIELD macro.
;

	.PSECT	LOCAL_SIZE_ARRAY,RD,WRT,NOEXE
LOCAL_SIZE_ARRAY:

	.PSECT	LOCAL_BITMAP,RD,WRT,NOEXE
LOCAL_BITMAP:

	.PSECT	LOCAL_TABLE,RD,NOWRT,NOEXE
LOCAL_TABLE:

	.PSECT	LOCAL_KEYTABLE,RD,NOWRT,NOEXE
LOCAL_KEYTAB:
	.LONG	0

;
; Define the fields that make up the LOCAL_PORTS class.
;

CLASS		=	CLS$M_LPRT


	DEFINE_FIELD	<LOCAL>,<LOCSYSID>,6,<LSYSTEM_ID>,DEC,4,4,,FORMAT_DATA
	DEFINE_FIELD	<LOCAL>,<NUM_BUF_DSCR>,2,<BUFF_DESCRIPTORS>,-
			DEC,2,10,,FORMAT_DATA
	DEFINE_FIELD	<LOCAL>,<NUM_FREE_BUF_DSCR>,4,-
			<FREE_BUFF_DESCRIPTORS>,DEC,2,10,,FORMAT_DATA


	DEFINE_FIELD	<LOCAL>,<MB$L_PORT_NAME>,4,<NAME>,ASCII,3,4,1,
	DEFINE_FIELD	<LOCAL>,<MB$L_STS>,PORT_STATUS_STRNG_LEN,-
			<LP_STATUS>,ASCIC,4,6,1,DISPLAY_PORT_STATUS
	DEFINE_FIELD	<LOCAL>,<MB$L_PORT_NUM>,1,<PORT_NUM>,DEC,1,4,1
	DEFINE_FIELD	<LOCAL>,<MB$W_DG_FREE>,2,<DGS_FREE>,ASCII,1,3,1
	DEFINE_FIELD	<LOCAL>,<MB$W_MSG_FREE>,2,<MSGS_FREE>,ASCII,1,3,1
	DEFINE_FIELD	<LOCAL>,<PDT$T_CNTOWNER>,16,<COUNTER_OWNER>,ASCII,8,16
	DEFINE_FIELD	<LOCAL>,<MB$L_PL_WAITERS>,4,<POOL_WAITERS>,DEC,2,4
	DEFINE_FIELD	<LOCAL>,<PDT$L_MSGHDRSZ>,4,<MSG_HDR_SIZE>,DEC,5,6
	DEFINE_FIELD	<LOCAL>,<PDT$L_DGOVRHD>,4,<DG_OVRHD_SIZE>,DEC,4,6
	DEFINE_FIELD	<LOCAL>,<MB$L_DEVTYPE>,DEV_TYP_STRNG_LEN,-
			<LP_TYPE>,ASCIC,4,5,,DISPLAY_PORT_TYPE
	DEFINE_FIELD	<LOCAL>,<PDT$W_PBCOUNT>,2,<OPEN_CIRCS>,DEC,3,6,1
	DEFINE_FIELD	<LOCAL>,<MB$L_FORM_PB>,4,<FORM_CIRCS>,DEC,3,6,1
	DEFINE_FIELD	<LOCAL>,<MB$W_CMDS_QUED>,2,<CMDS_QUEUED>,ASCII,2,4
	DEFINE_FIELD	<LOCAL>,<MB$W_RSPS_QUED>,2,<RSPS_QUEUED>,ASCII,2,4
	DEFINE_FIELD	<LOCAL>,<PDT$B_MAX_PORT>,1,<MAX_PORT>,DEC,5,8
	DEFINE_FIELD	<LOCAL>,<PDT$B_PORTMAP>,2,<PRT_MAP>,HEX,5,7
	DEFINE_FIELD	<LOCAL>,<PDT$B_DQIMAP>,2,<DGI_MAP>,HEX,3,6
	DEFINE_FIELD	<LOCAL>,<PDT$B_PLOGMAP>,2,<LOG_MAP>,HEX,5,7
	DEFINE_FIELD	<LOCAL>,<PDT$B_P0_LBSTS>,LB_STAT_STRG_LEN,-
			<LB_STATUS>,ASCIC,5,5,,DISPLAY_LOOPBACK_STATUS


;
; Define the fields that make up the ERRORS class.
;

CLASS		=	CLS$M_ERR


	DEFINE_FIELD	<LOCAL>,<MB$B_ERTCNT>,1,<ERT_COUNT>,DEC,3,5,1
	DEFINE_FIELD	<LOCAL>,<MB$B_ERTMAX>,1,<ERT_MAX>,DEC,5,5,1
	DEFINE_FIELD	<LOCAL>,<MB$W_ERRCNT>,1,<NUM_ERRORS>,DEC,6,6,1


	.PSECT	LOCAL_KEYTABLE,RD,NOWRT,NOEXE


NUM_LOCAL_DSCRS = KEYWRDVAL		; Save the number of descriptors in the
					;  local report.

. =	LOCAL_KEYTAB			; Save the vector count for
	.LONG	KEYWRDVAL*2		;  LIB$LOOKUP_KEY.
. =	.+KEYWRDVAL*2

	.PSECT	LOCAL_BITMAP,RD,WRT,NOEXE

;
; Save any partial mask in the bitmap and increase the count of the bitmap's
; length.
;
	.IF	NE	COUNT-33
	.LONG	MASK
	MAP_LENGTH	=	MAP_LENGTH+1
	.ENDC


LOCAL_MAP_LEN = MAP_LENGTH		; Save the number of longwords in the
					;  local bitmap.

LOC_SAVE_BITMAP:			; Reserve enough room for a copy of the
	.BLKL	MAP_LENGTH+1		;  local bitmap to be used by the
					;  INITIALIZE command.


	.RESTORE_PSECT



	.SBTTL	Main program loop.
	.PSECT	MAIN,RD,NOWRT,EXE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This is the main entry point for show cluster.  The basic program
;	flow is as follows:
;
;	1)	Initialize
;	2)	Capture a snapshot of the SCS database.
;	3)	Display the report.
;	4)	Set a timer and wait for expiration or unsolicited data.
;		(command input or broadcast message received)
;	5)	Process the unsolicited data and/or go to step 2.
;
;--

.ENTRY	START,^M<R2,R3,R4,R5,R7,R10,R11>

	BISL	#<MF$M_INIT_FLAG!-	; Set flags to indicate we're performing
		  MF$M_RIP>,MISC_FLAGS	;  initialization and that the full
					;  screen must be drawn.
	BSBW	INIT			; Initialize.
	JLBC	R0,MAIN_ERR		; Branch on error.

MAIN_LOOP:
	BBS	#DVT$V_UNKNOWN,OUT_DEV,-; Set up screen buffer on each pass if
		10$			;  output device is an unknown terminal
					;  type.
	BBC	#MF$V_INIT_FLAG,-	; Otherwise set up screen buffer only
		MISC_FLAGS,20$		;  during initialization.
10$:	PUSHAQ	SCREEN_DSCR		; Set up a buffer for the screen.
	CALLS	#1,G^LIB$SET_BUFFER	;
	JLBC	R0,MAIN_ERR		; Branch on error.

20$:	BBC	#DVT$V_DCRT,OUT_DEV,30$	; Branch if output device isn't a
					;  DECcrt.
	PUSHAL	COL_NUM			; Set line drawing and special graphics
	PUSHAL	LINE_NUM		;  character set in G1 area in DECcrt.
	PUSHAL	GRAPHICS_DSGNTR		;
	CALLS	#3,G^LIB$PUT_SCREEN	;
	JLBC	R0,MAIN_ERR		; Branch on error.
	
30$:	BSBW	DISPLAY			; Generate the display output.
	JLBC	R0,MAIN_ERR		; Branch on error.
	CALLS	#0,G^LIB$PUT_BUFFER	; Output the report to the screen.
	BBS	#MF$V_CONT,MISC_FLAGS,-	; Branch if continuous display.
		40$			;
	PUSHAL	COL_NUM			; Otherwise place the cursor at the
	PUSHAL	CMD_LINE		;  bottom of the screen.
	CALLS	#2,G^LIB$SET_CURSOR	;
	JLBC	R0,MAIN_ERR		; Branch on error.
	$EXIT_S				; Exit.

;
; If input is from a command file, then continute reading commands from the
; file.  Otherwise, go to sleep until a key in pressed, a broadcast message
; comes in, or the interval timer expires.
;

40$:	BBC	#DVT$V_HARD,OUT_DEV,50$	; Branch if not hardcopy terminal.
	PUSHAQ	SCREEN_DSCR		; Set up a buffer for the screen.
	CALLS	#1,G^LIB$SET_BUFFER	;
	JLBC	R0,MAIN_ERR		; Branch on error.
	BBC	#DVT$V_DISK,IN_DEV,50$	; Branch if input isn't from a file.
	CALLS	#0,EXECUTE		; Go process command input.
	JLBC	R0,MAIN_ERR		; Branch on error.
	BBC	#MF$V_INIT_FLAG,-	; Branch if initialization not in
		MISC_FLAGS,50$		;  progress.
	$EXIT_S				; Otherwise exit.

50$:	$SETIMR_S -			; Set the refresh interval timer.
		EFN=#EVF$V_TIM_FLAG,-	;
		DAYTIM=DELAY,-		;
		REQIDT=#1		;
	JLBC	R0,MAIN_ERR		; Branch on error.

;
; Wait for expiration of interval timer, or an AST to occur.
;

	$WFLOR_S -
		EFN=#0,-
		MASK=#EVF$M_TIM_FLAG!EVF$M_AST_FLAG
	JLBC	R0,MAIN_ERR		; Branch on error.

	$CANTIM_S -			; Now that we're awake, cancel
		REQIDT=#1		;  outstanding refresh timer requests.
	JLBC	R0,MAIN_ERR		; Branch on error.

	$READEF_S -			; Read flags to determine which
		EFN=#0,-		;  condition occured.
		STATE=FLAG_STATE
	JLBC	R0,MAIN_ERR		; Branch on error.

	BBS	#EVF$V_AST_FLAG,-	; Branch if AST flag set.
		FLAG_STATE,70$
	BBS	#MF$V_CYCLE,MISC_FLAGS,-; Branch if we're not cycling the
		60$			;   display.
	BRW	MAIN_LOOP		; Otherwise start over.
60$:	INCB	SWITCH			; Toggle switch.
	JLBS	SWITCH,MAIN_LOOP	; Branch if not time to switch displays.
	BSBW	SWITCH_DISPLAY		; Otherwise, switch the displays
	BRW	MAIN_LOOP		;  and do a screen update.
70$:	$CLREF_S -			; Reset AST flag.
		EFN=#EVF$V_AST_FLAG	;
	JLBC	R0,MAIN_ERR		; Branch on error.
	CMPW	MBX_BUF,#MSG$_TRMUNSOLIC; Was AST caused by unsolicited data?
	BNEQ	80$			; Branch if not.
	JSB	READ_LOOP		; Otherwise go process the command.
	JLBC	R0,MAIN_ERR		; Branch on error.
	BRB	MAIN_CONT		;
80$:	CMPW	MBX_BUF,#MSG$_TRMBRDCST	; Was AST caused by terminal broadcast?
	BNEQ	MAIN_CONT		; If not, ignore AST.
	JSB	BRDCST			; Otherwise, go handle broadcast
					;  message.
	JLBC	R0,MAIN_ERR		; Branch on error.

MAIN_CONT:
	BSBW	SET_AST			; Set up for next AST.
	JLBC	R0,MAIN_ERR		; Branch on error.
	BRW	MAIN_LOOP		; Start again.

	.DSABL	LSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered when a unsolicited data AST occurs.  It
;	examines the type-ahead buffer and then issues a read QIO with or
;	without a prompt depending on the character found in the type-ahead
;	buffer.
;
;	Once the read completes control is passed to DCL_PARSE or to
;	the appropriate routine to handle control or escape sequences.
;
; CALLING SEQUENCE:
;
;	JSB	READ_LOOP
;
; CALLED BY:
;
;	MAIN_LOOP
;
;--

	.ENABL	LSB

READ_LOOP:
	$QIOW_S -			; Get the number of characters in the
		CHAN=IN_CHAN,-		;  type ahead buffer.
		FUNC=#IO$_SENSEMODE!IO$M_TYPEAHDCNT,-
		P1=TYPEAHD_BUF
	JLBC	R0,999$			; Branch on error.
	TSTW	TYPEAHD_BUF		; Are there any characters in the type
					;  ahead buffer?
	BNEQU	30$			; Branch if there are.
	BRW	999$			; Return with status.

30$:	CMPB	TYPEAHD_BUF+2,#ESC	; Is there an escape sequence in the
					;  type ahead buffer?
	BEQL	READ_WO_PROMPT		; Branch if so.
	CMPB	TYPEAHD_BUF+2,#CSI	; Is there an 8 bit escape sequence in
					;  the type ahead buffer?
	BEQL	READ_WO_PROMPT		; Branch if so.
	CMPB	TYPEAHD_BUF+2,#CTRLW	; Is there a ^W in the type ahead
					;  buffer?
	BEQL	READ_WO_PROMPT		; Branch if so.
	CMPB	TYPEAHD_BUF+2,#CTRLZ	; Is there a ^Z in the type ahead
					;  buffer?
	JNEQ	READ_W_PROMPT		; Branch if not.

READ_WO_PROMPT:
	$QIOW_S -			; Read the command without prompt.
		CHAN=IN_CHAN,-		;
		FUNC=#IO$M_EXTEND!IO$_READVBLK,-
		IOSB=IOSB,-		;
		P1=CMD_BUF,-		;
		P2=#CMD_BUF_LEN,-	;
		P5=#TERM_LIST,-		;
		P6=#TERM_LIST_LEN	;
	JLBC	R0,999$			; Branch on error.

	CMPB	IOSB+4,#CTRLZ		; Did the user type an control-Z?
	BNEQ	40$			; Branch if not.
	MOVL	#SS$_NORMAL,R0		; Indicate normal exit.
	$EXIT_S				; Exit

40$:	CMPB	IOSB+4,#CSI		; Did the user type an eight-bit escape
					;  sequence?
	BEQL	50$			; Branch if so.
	CMPB	IOSB+4,#ESC		; Did the user type an escape sequence?
	BNEQ	60$			; Branch if not.
50$:	BSBW	SET_SCROLL		; Set scroll.
	BRW	READ_LOOP		; Loop till type ahead buffer is empty.
60$:	CMPB	IOSB+4,#CTRLW		; Did user type control-W?
	JLBC	R0,999$			; Error if not.
	CLRB	TOP_CMD_LINE		; Indicate that there is no additional
					;  information on the top command line.
	MOVL	CMD_LINE,LINE_NUM	; Get the number of the last line of
					;  the command display area.
	BSBW	ERASE_TWO_LINES		; Erase any information in the command
					;  display area.
	JLBC	R0,999$			; Branch on error.
	CALLS	#0,REFRESH		; Otherwise, refresh the screen.
	JLBC	R0,999$			; Branch on error.
	BRW	READ_LOOP		; Loop till type ahead buffer is empty.

READ_W_PROMPT:
	MOVL	CMD_LINE,LINE_NUM	; Set cursor to line 23,
	BBC	#DVT$V_DCRT,IN_DEV,70$	;  or if terminal is a DECcrt,
	INCL	LINE_NUM		;  on line 24.
70$:	PUSHAW	COL_NUM			;
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$SET_CURSOR	;
	JLBC	R0,999$			; Branch on error.
	MOVL	#1,SCROLL_DELAY		; Set the number of refreshes before
					;  the command is scrolled.
	BLBS	CMD_STATUS,80$		; Branch if the last command succeeded.
	BSBW	SCROLL_TWO		; Scroll the two command lines.
	JLBC	R0,999$			; Branch on error.
80$:	CALLS	#0,G^LIB$ERASE_LINE	; Erase the command line.
	JLBC	R0,999$			; Branch on error.
	BBC	#DVT$V_DCRT,IN_DEV,90$	; Skip the following input device isn't
					;  a DECcrt.
	JSB	SET_REGION_COMMAND	; Establish a scrolling region.
	JLBC	R0,999$			; Branch on error.

90$:	$QIOW_S -			; Read the command with prompt.
		CHAN=IN_CHAN,-
		FUNC=#IO$_READPROMPT!IO$M_DSABLMBX,-
		IOSB=IOSB,-
		P1=CMD_BUF,-
		P2=#CMD_BUF_LEN,-
		P5=#PROMPT+8,-
		P6=#PROMPT_LEN
	JLBC	R0,999$			; Branch on error.

	CMPB	IOSB+4,#CTRLZ		; Did user type control-Z?
	BNEQ	100$			; Branch if not.
	MOVL	#SS$_NORMAL,R0		; Indicate normal exit.
	$EXIT_S				; Exit

100$:	MOVZWL	IOSB+2,CMD_LINE_DSCR	; Save number of characters in command.
	PUSHAL	CMD_LINE_DSCR		; Convert command line to uppercase.
	PUSHAL	CMD_LINE_DSCR		;
	CALLS	#2,G^STR$UPCASE		;
	JLBC	R0,999$			; Branch on error.

	CMPB	TYPEAHD_BUF+2,#^A/@/	; Is there a "@" in the type ahead
					;  buffer?
	BEQL	110$			; If so, bypass DCL_PARSE.

;
; Use DCL_PARSE to check for obvious syntax errors.
;

	PUSHAL	SECOND_CHANCE
	PUSHAL	SHOW_CLUSTER$COMMAND_TABLE
	PUSHAL	CMD_LINE_DSCR
	CALLS	#3,G^CLI$DCL_PARSE
	BLBS	R0,110$			; Branch if no error.
	MOVB	#CL$M_ERROR,TOP_CMD_LINE; Indicate that there is error
					;  information on both command lines.
	MOVB	#CL$M_ERROR,BOT_CMD_LINE;
	BRB	130$			;

;
; Use TPARSE to do the actual parsing and call the action routines.
;

;
; Form the descriptor for LIB$TPARSE.
;

110$:	MOVW	CMD_LINE_DSCR,TPARSE_BLK+TPA$L_STRINGCNT
	MOVAL	CMD_BUF,TPARSE_BLK+TPA$L_STRINGPTR
	PUSHAL	CMD_KEY			; Parse the input line.
	PUSHAL	CMD_STATE		;
	PUSHAL	TPARSE_BLK		;
	CALLS	#3,G^LIB$TPARSE		;
	MOVL	R0,CMD_STATUS		; Save the command status for SIGNAL.
	BLBC	R0,120$			; Branch on error.
	MOVB	#CL$M_CMD,TOP_CMD_LINE	; Indicate that the last command
					;  entered is now scrolled up one.
	CLRB	BOT_CMD_LINE		;  and the bottom command line is blank.
	BRB	130$			; Continue.
120$:	MOVB	#CL$M_CMD,TOP_CMD_LINE	; Indicate that the last command
					;  entered is now scrolled up one.
	MOVB	#CL$M_ERROR,BOT_CMD_LINE; And the bottom command line contains
					;  an error message.
	BSBW	SIGNAL			; Output the error.

;
; Before looping, make sure ERR_MSGVEC still has the address of TPARSE_BLK+
; TPA$L_TOKENCNT.  This may have changed if an ADD or REMOVE class was just
; parsed.
;

130$:	MOVAL	TPARSE_BLK+TPA$L_TOKENCNT,-
		ERR_MSGVEC+12		;
	BRW	READ_LOOP		; Loop till no more command.

999$:	RSB

	.DSABL	LSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when there are parameters or qualifier values
;	missing from the input string.  When called, DCL_PARSE has already
;	set up an arguement list to call LIB$GET_INPUT.  The address that
;	DCL has provided for the return string descriptor is saved and the
;	call to LIB$GET_INPUT is made.  When the string is returned it is
;	concatenated with the original command string so that the whole
;	command can be passed to TPARSE.
;
; CALLING SEQUENCE:
;
;	CALLS	SECOND_CHANCE
;
; CALLED BY:
;
;	CLI$DCL_PARSE from READ_W_PROMPT
;
; INPUTS:
;
;	(AP)	Number of arguments.
;	(AP)+4	Address of descriptor for string returned.
;	(AP)+8  Address of prompt descriptor.
;	(AP)+12 Address to store length of string returned.
;
;--

.ENTRY	SECOND_CHANCE,^M<R2,R3,R4,R5>
	MOVL	#4,R3			; Get address of DCL's param-routine
	MOVAL	(AP)[R3],R2		;  string descriptor.
	CALLG	(AP),G^LIB$GET_INPUT	; Get missing parameter from user.
	BLBC	R0,99$			; Branch on error.
	MOVZWL	CMD_LINE_DSCR,R1	; Get number of characters in original
					;  command line.
	MOVL	CMD_LINE_DSCR+4,R3	; Get address of command line.
	MOVAB	(R3)[R1],R3		; Get address of last byte in command.
	MOVB	#^A/ /,(R3)+		; Change <CR> to <SPACE>.
	ADDL3	#1,(R2)+,R1		; Get the length of the additional
					;  input string (plus the space).
	ADDW	R1,CMD_LINE_DSCR	; Save length of combined strings.
	MOVC3	R1,@(R2),(R3)		; Concatenate the two strings.
	PUSHAL	CMD_LINE_DSCR		; Make sure the full line is uppercase.
	PUSHAL	CMD_LINE_DSCR		;
	CALLS	#2,G^STR$UPCASE		;
99$:	RET				; Return with status.



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered when a broadcast message AST occurs.  It
;	determines where the end of a line in the broadcast message occurs
;	and then call STORE_MSG to place the broadcast message in a queue
;	to be output to the terminal.  This routine also replaces non-
;	printable characters in the broadcast message with periods (".").
;
; CALLING SEQUENCE:
;
;	JSB	BRDCST
;
; CALLED BY:
;
;	MAIN_LOOP
;
;--

BRDCST:	PUSHR	#^M<R2,R3,R4,R5,R6>
	MOVAL	MBX_BUF+22,R3		; Get address of broadcast message.
	MOVZWL	MBX_BUF+20,R2		; Get length of broadcast message.
10$:	MOVQ	R2,R4			; Save a copy in R4,R5.

;
; Scan the message for non-ascii characters.  If a non-ascii character is
; found, substitute a period (".").  Loop until the first carriage return
; following a valid ascii string is found or until the end of the message
; is found.
;
	BICL	#<MF$M_VALID_MSG!-	; Clear valid message flag and <CR>
		MF$M_CR_FOUND>,-	;  found after valid message flag.
		MISC_FLAGS		;
20$:	MOVL	R3,R6			; Save pointer to broadcast message.
	BSBW	CHECK_ASCII		; Check for non-ascii characters.
	BLBS	R0,70$			; Branch if entire message contains
					;  valid ascii characters.
	CMPL	R3,R6			; Were any ascii at all characters
					;  found?
	BEQL	30$			; Branch if not.
	BBS	#MF$V_CR_FOUND,-	; Branch if the characters found are
		MISC_FLAGS,60$		;  part of the next line of a multi-
					;  line message.
	BISL	#MF$M_VALID_MSG,-	; Set valid message found flag.
		MISC_FLAGS		;
30$:	DECL	R2			; Count down characters remaining in the
					;  message.
	BLSS	70$			; Branch if we've reached the end of the
					;  message.
	CMPB	(R3),#^X0D		; Was a carriage return found?
	BNEQ	40$			; Branch if not.
	BBC	#MF$V_VALID_MSG,-	; Branch if a carriage return has been
		MISC_FLAGS,40$		;  found before any valid ascii
					;  characters have been found.
	BISL	#MF$M_CR_FOUND,-	; Indicate a carriage return following
		MISC_FLAGS		;  a valid message has been found.
40$:	CMPB	(R3),#7			; Was a BELL found?
	BNEQ	50$			; Branch if not.
	INCL	R3			; Leave the BELL in the buffer
	BRB	20$			;  and loop.
50$:	MOVB	#^A/./,(R3)+		; Substitute a "." for the character.
	BRB	20$			; Loop.

;
; A carriage return has been found following a string of valid ascii characters
; indicating the end of a line in a multi-line message.  Calculate the length
; of the line and store it in the message output queue.
;

60$:	MOVQ	R4,R2			; Restore length and address of full
					;  message.
	SUBL3	R3,R6,R2		; Get length of this line of the
					;  message.
	BSB	STORE_MSG		; Store this line in the message output
					;  queue.
	SUBL3	R2,R4,R2		; Get the length of the remainder of
					;  the message in R2.
	MOVL	R6,R3			; Get the address of the remainder of
					;  the message in R3.
	BRB	10$			; Loop till entire message processed.

;
; The end of the message has been found.  Store the last remainder of the
; message in the message output queue.
;

70$:	MOVQ	R4,R2			; Restore length and address of message.
	BSB	STORE_MSG		; Store the message in the message
					;  output queue.
	MOVL	#1,SCROLL_DELAY		; Set the delay counter.
	POPR	#^M<R2,R3,R4,R5,R6>
	RSB




;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Allocate a buffer from the message buffer free queue.  Store a line
;	from the broadcast message in the buffer and insert the buffer in the
;	message output queue.
;
; CALLING SEQUENCE:
;
;	JSB	STORE_MSG
;
; CALLED BY:
;
;	BRDCST
;
; IMPLICIT INPUTS:
;
;	MSG_FRE_QUE contains a queue of buffers allocated and available for use.
;	MSG_OUT_QUE contains a queue of broadcast message lines to be output.
;
; INPUTS:
;
;	R2 contains the length of the message.
;	R3 contains the address of the message.
;
; IMPLICIT OUTPUTS:
;
;	Message line inserted at end of MSG_OUT_QUE
;
;--

STORE_MSG:
	REMQUE	@MSG_FRE_QUE,BUFADR	; Get a from the message buffer free
					;  queue.
	BVC	10$			; Branch if buffer available.
	PUSHAB	BUFADR			; Allocate a new buffer.
	PUSHAB	BUFSIZE			;
	CALLS	#2,G^LIB$GET_VM		;
	BLBC	R0,99$			; Branch on error.
10$:	PUSHR	#^M<R2,R3,R4,R5>
	ADDL3	#8,BUFADR,R4		; Get the address to store the message.
	MOVW	R2,(R4)+		; Store message length in the buffer.
	MOVC3	R2,(R3),(R4)		; Store the message in the buffer.
	POPR	#^M<R2,R3,R4,R5>
	INSQUE	@BUFADR,@MSG_OUT_QUE+4	; Insert buffer into broadcast message
					;  output queue.
	MOVL	#SS$_NORMAL,R0
99$:	RSB				; Return with status.




;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the allocation and deallocation of variable
;	length buffers used by the SNAPSHOT routine.  No more than two
;	buffers are ever allocated.  Before taking a new snapshot, the
;	buffer used for the last snapshot becomes the "old" buffer.  This
;	is done by simply moving the new buffer descriptor to the old buffer
;	descriptors (see SAVE_OLD routine).  The previous "old" buffer is then
;	deallocated.  What are now the "old" buffer descriptors are used to
;	determine how much space to allocate for the new buffer based on the
;	following:
;
;	       OLD			              New
;    ---------------------------      	-------------------------------
;       n System Blocks 		n+4 System Blocks
;       x Cluster System Blocks		n+4 Cluster System Blocks
;       y Path Blocks	       		(n+4)*4 Path Blocks
;       z Connection Descriptors 	(n+4)*4+z Connection Descriptors
;
;	Where n,x,y, and z are the number of blocks found by the last snapshot
;	routine.  (not the number last allocated)
;
;	Once the size of the buffer is determined, the buffer is allocated and
;	locked in memory along with the fixed length buffers and other data
;	needed by the snapshot routine.  A snapshot is then taken.  After the
;	snapshot, the number of entries of each of the four types shown above
;	is determined and saved for the next buffer allocation.
;
; CALLING SEQUENCE:
;
;	JSB	DO_SNAPSHOT
;
; CALLED BY:
;
;	DISPLAY
;
; OUTPUTS:
;
;--

DO_SNAPSHOT:
	PUSHR	#^M<R2,R3,R4,R5>
10$:	CMPB	#2,BUF_COUNT		; Have we allocated two variable length
					;  buffers?
	BEQL	20$			; Branch if so.
	INCB	BUF_COUNT		; Increase count of buffers allocated.
	BRB	30$			; Jump to common code.
20$:	PUSHAL	OLD_VAR_BUF		; Free up the old buffer before we
	PUSHAL	OLD_VAR_BUF_LEN		;  allocate a new one.
	CALLS	#2,G^LIB$FREE_VM	;
	JLBC	R0,99$			; Branch on error.

30$:	BSBW	SAVE_OLD		; Replace old descriptors with new
					;  descriptors.
	MOVW	OLD_SB_DSCR+2,R1	; Get the number of system blocks found
					;  in the last snapshot.
	ADDW	#4,R1			; Increase by four for expansion.
	MOVW	R1,SB_DSCR+2		; Set number of system blocks that will
					;  fit in the buffer.
	MULW3	#SB$C_LENGTH,R1,SB_DSCR ; Set the length of the system block
					;  buffer.
	MOVW	R1,CSB_DSCR+2		; Set the number of cluster system
					;  blocks that will fit in the buffer.
	MULW3	#CSB$C_LENGTH,R1,-	; Set the length of the cluster system
		CSB_DSCR		;  block buffer.
	MULW	#4,R1			; Get the number of path blocks that
					;  will fit in the buffer.
	MOVW	R1,PB_DSCR+2		; Save in descriptor.
	MULW3	#PB$C_LENGTH,R1,PB_DSCR	; Set the length of the path block
					;  buffer.
	ADDW	OLD_CDT_DSCR+2,R1	; Allow number of connections to expand
					;  by one per path.
	MOVW	R1,CDT_DSCR+2		; Save in descriptor.
	MULW	#SHC$C_CDT_LENGTH,R1	; Get the length of the connections
					;  buffer.
	MOVW	R1,CDT_DSCR		; Save in descriptor.
	MOVL	VAR_BUF,OLD_VAR_BUF	; Save address of previous buffer.
	MOVL	VAR_BUF_LEN,-		; Save length of previous buffer.
		OLD_VAR_BUF_LEN		;
;
; Total the number of bytes needed for the variable length buffers.
;

	MOVZWL	R1,VAR_BUF_LEN		; CDT buffer.
	ADDW	SB_DSCR,VAR_BUF_LEN	; SB buffer.
	BCC	40$
	ADDL	^X10000,VAR_BUF_LEN
40$:	ADDW	CSB_DSCR,VAR_BUF_LEN	; CSB buffer.
	BCC	50$
	ADDL	^X10000,VAR_BUF_LEN
50$:	ADDW	PB_DSCR,VAR_BUF_LEN	; PB buffer.
	BCC	60$
	ADDL	^X10000,VAR_BUF_LEN

;
; Save the number of entries we can store in each of the buffers.
; The numbers will be used to determine how many entries were actually
; stored in each of the buffers.
;

60$:	MOVW	SB_DSCR+2,SB_COUNT	; Number of entrys that can be stored
					;  in the system block buffer.
	MOVW	CSB_DSCR+2,CSB_COUNT	; Number of entrys that can be stored
					;  in the cluster system block buffer.
	MOVW	PB_DSCR+2,PB_COUNT	; Number of entrys that can be stored
					;  in the path block buffer.
	MOVW	CDT_DSCR+2,CDT_COUNT	; Number of entrys that can be stored
					;  in the CDT buffer.
	
	PUSHAL	VAR_BUF			; Allocate some buffer space.
	PUSHAL	VAR_BUF_LEN		;
	CALLS	#2,G^LIB$GET_VM		;
	JLBC	R0,99$			; Branch on error.
	MOVL	VAR_BUF,VAR_BUF_ADRS	; Save copy of buffer address for
					;  snapshot routine.
	ADDL3	VAR_BUF,VAR_BUF_LEN,-	; Calculate address of end of buffer.
		VAR_BUF_END		;

	MOVC5	#0,@VAR_BUF,#0,-	; Zero out the variable length snapshot
		#VAR_BUF_LEN,@VAR_BUF	;  buffers.

	MOVC5	#0,FIX_BUF,#0,-		; Zero out the fixed length snapshot
		#FIX_BUF_LEN,FIX_BUF	;  buffers.

;
; Complete the variable buffer descriptors.
;

	MOVL	VAR_BUF,SB_DSCR+4	; Save address of system block buffer.
	MOVZWL	SB_DSCR,R1		; Get length of system block buffer.
	ADDL3	R1,SB_DSCR+4,CSB_DSCR+4	; Save address of cluster system block
					;  buffer.
	MOVZWL	CSB_DSCR,R1		; Get length of cluster system block
					;  buffer.
	ADDL3	R1,CSB_DSCR+4,PB_DSCR+4	; Save address of path block buffer.
	MOVZWL	PB_DSCR,R1		; Get length of path block buffer.
	ADDL3	R1,PB_DSCR+4,CDT_DSCR+4	; Save address of CDT buffer.

;
; Set up buffer pointers.
;
	MOVL	SB_DSCR+4,SB_BUF_PNTR	; Initialize pointer into system block
					;  buffer.
	MOVL	CSB_DSCR+4,CSB_BUF_PNTR	; Initialize pointer into cluster
					;  system block buffer.
	MOVL	PB_DSCR+4,PB_BUF_PNTR	; Initialize pointer into path block
					;  buffer.
	MOVL	CDT_DSCR+4,CDT_BUF_PNTR	; Initialize pointer into connection
					;  descriptor buffer.

	$LKWSET_S -			; Lock variable length snapshot buffers
		INADR=VAR_BUF		;  in memory.
	JLBC	R0,99$			; Branch on error.

	$LKWSET_S -			; Lock fixed snapshot buffers and
		INADR=SNAP_ADRS		;  snapshot routine in memory.
	JLBC	R0,99$			; Branch on error.

	$CMKRNL_S -			; Capture SCS database.
		ROUTIN=SNAPSHOT		;
	MOVL	R0,ERR_MSGVEC+4		; Save snapshot status.

	$ULWSET_S -			; Unlock snapshot buffers and snapshot
		INADR=SNAP_ADRS		;  routine pages.
	JLBC	R0,99$			; Branch on error.

	$ULWSET_S -			; Unlock variable snapshot buffer pages.
		INADR=VAR_BUF		;
	JLBC	R0,99$			; Branch on error.

	MOVL	ERR_MSGVEC+4,R0		; Restore snapshot status.
	JLBC	R0,99$			; Branch on error.
;
; Calculate the number of entries actually stored in each of the variable
; length buffers by subtacting the number of empty entries remaining from
; the number of entries we started with.
;

	SUBW3	SB_DSCR+2,SB_COUNT,-	; Number of system block entries in
		SB_DSCR+2		;  buffer.
	SUBW3	CSB_DSCR+2,CSB_COUNT,-	; Number of cluster system block
		CSB_DSCR+2		;  entries in buffer.
	SUBW3	PB_DSCR+2,PB_COUNT,-	; Number of path block entries in
		PB_DSCR+2		;  buffer.
	SUBW3	CDT_DSCR+2,CDT_COUNT,-	; Number of CDT entries in buffer.
		CDT_DSCR+2		;

	BBSC	#MF$V_INIT_FLAG,-	; Old = new if init pass in progress.
		MISC_FLAGS,70$		;
	BBC	#MF$V_RIP,MISC_FLAGS,99$; Or if refresh just performed.
70$:	BSB	SAVE_OLD		;
	MOVC5	#FIX_BUF_LEN,FIX_BUF,-	; Duplicate the fixed length buffers so
		#0,#FIX_BUF_LEN,-	;  we don't display the data in inverse
		OLD_FIX_BUF		;  video.

;
; Check if we got the full data base on this snapshot.  If so go display the
; report.  Otherwise, loop to expand buffers and try again.
;

	CMPW	SB_DSCR+2,SB_COUNT	; Did we run out of system block buffer?
	JEQLU	10$			; Branch if so.
	CMPW	CSB_DSCR+2,CSB_COUNT	; Did we run out of clustre system
					;  block buffer?
	JEQLU	10$			; Branch if so.
	CMPW	PB_DSCR+2,PB_COUNT	; Did we run out of path block buffer?
	JEQLU	10$			; Branch if so.
	CMPW	CDT_DSCR+2,CDT_COUNT	; Did we run out of connection
					;  descriptor buffer?
	JEQLU	10$			; Branch if so.

	MOVL	#SS$_NORMAL,R0		; Indicate success.

99$:	POPR	#^M<R2,R3,R4,R5>
	RSB				; Return with status.



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs two functions:
;		1) When called prior to taking a snapshot it is used to move the
;		   newest set of buffer descriptors to the storage area for the
;		   old buffer descriptors before building a new set.
;		2) When called after taking a snapshot it is used to duplicate
;		   the new buffer descriptors so that both sets point to the
;		   same buffers.  This will mean that the CHECK_DIF routine.
;		   will extract the same data when comparing new and old data.
;
; CALLING SEQUENCE:
;
;	JSB	SAVE_OLD
;
; CALLED BY:
;
;	DO_SNAPSHOT
;
;--

SAVE_OLD:
	MOVQ	SB_DSCR,OLD_SB_DSCR	; Make descriptor for variable length
	MOVQ	CSB_DSCR,OLD_CSB_DSCR	;  buffers used in the last pass point
	MOVQ	PB_DSCR,OLD_PB_DSCR	;  to the ones for this pass so we don't
	MOVQ	CDT_DSCR,OLD_CDT_DSCR	;  display the data in inverse video.
	RSB


	.SBTTL	Initialization.
	.PSECT	MAIN,RD,EXE,NOWRT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the following steps for program initialization.
;
;	- Establishes an exit handler.
;	- Assigns channels to I/O devices.
;	- Determines the device type of the I/O devices and saves a summary of
;	  the type.
;	- Translates logical name SYS$NODE.
;	- Saves the system ID of the local system.
;	- Saves a copy of the display bitmap for use by the INITIALIZE command.
;	- Parses the DCL command line for /REPORT=, /CONTINUOUS, /INTERVAL=,
;	  /OUTPUT= and sets up accordingly.
;	- Executes the startup initialization file.
;	- Establishes a control-C handler.
;	- Sets the first AST for unsolicited data.
;	- If input is from a terminal:
;		- A mailbox is associated with the terminal.
;		- New terminal characteristics are set up after saving the old
;		  ones for restoration upon exit.
;		- Screen is cleared if terminal is a scope.
;
; CALLING SEQUENCE:
;
;	JSB	INIT
;
; CALLED BY:
;
;	START
;
; OUTPUTS:
;
;	IN_DEV, OUT_DEV	Set to reflect the I/O device type.
;	SAVE_CHAR_BUF	Contains the original terminal characteristics.
;	LOCSYSID	Receives the system ID of the local system.
;	CL_SAVE_BITMAP	Receives a copy of the cluster bitmap.
;	LOC_SAVE_BITMAP	Reveives a copy of the local bitmap.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

INIT:	PUSHR	#^M<R2,R3,R4,R5,R6,R7>

;
; Setup an exit handler.
;

	$DCLEXH_S -			; Declare exit handler.
		DESBLK=EXIT_BLK		;
	JLBC	R0,99$			; Branch on error.

	$GETJPI_S -			; Get mask of the user's current
		ITMLST=JPI_LIST		;  privileges.
	JLBC	R0,99$			; Branch on error.

	BBS	#PRV$V_CMKRNL,CUR_PRIV,-; Branch if user has change mode KERNEL
		4$			;  privilege.
	MOVL	#SS$_NOCMKRNL,R0	; Indicate CMKRNL required.
	BRW	99$			; Exit with error status.

4$:	$GETDVI_S -			; Get the input device characteristics.
		DEVNAM=IN_DEV_NAME,-	;
		ITMLST=GET_LIST		;
	JLBC	R0,99$			; Branch on error.

	CMPB	#DC$_TERM,DEVICE_CLASS	; Is input device a terminal?
	BEQL	5$			; Branch if so.
	BBSS	#DVT$V_DISK,IN_DEV,30$	; Input is from a disk file.

5$:	PUSHAL	MBXCHAN			; Assign a channel to the terminal and
	PUSHAL	IN_CHAN			;  associate a mailbox with it.
	PUSHAL	BUF_QUO			;
	PUSHAL	MAX_MSG			;
	PUSHAL	IN_DEV_NAME		;
	CALLS	#5,G^LIB$ASN_WTH_MBX	;
	JLBC	R0,99$			; Branch on error.

;
; Check the input terminal characteristics and summarize in IN_DEV.
;
	BITL	#TT2$M_DECCRT,DEVDEPEND2; Is terminal a DECcrt?
	BEQL	7$			; Branch if not.
	BISB	#DVT$M_DCRT,IN_DEV	; Set VT100 bit.
	BRB	30$			; Jump to common code.
7$:	BITL	#DT$_VT5X,DEVICE_TYPE	; Is terminal VT52 compatable?
	BEQL	10$			; Branch if not.
	BISB	#DVT$M_VT52,IN_DEV	; Set VT52 bit.
	BRB	30$			; Jump to common code.
10$:	BITL	#TT$M_SCOPE,DEVDEPEND	; Is the terminal some type of scope?
	BEQL	20$			; Branch if not.
	BISB	#DVT$M_VT52,IN_DEV	; Treat terminal as if its a VT52.
	BISB	#DVT$M_UNKNOWN,IN_DEV	; Indicate actual type is unknown.
	BRB	30$			; Jump to common code.
20$:	BISB	#DVT$M_HARD,IN_DEV	; Assume terminal is some type of
					;  hardcopy device.

;
; Get the output terminal characteristics and summarize in OUT_DEV.  Save
; a copy of the characteristics for restoration upon exit.  Set new
; characteristics NOBRDCST and BRDCSTMBX.
;

30$:	PUSHAL	OUTPUT_QUAL		; Was /OUTPUT specified?
	CALLS	#1,G^CLI$PRESENT	;
	BLBS	R0,31$			; Branch if so.

	MOVC3	NULL_DEV_NAME,-		; Otherwise, NL: is the output device.
		NULL_DEV_NAME+8,-	;
		OUT_FILE_SPEC		;
	BRB	32$			; Branch to common code.

31$:	PUSHAL	RET_BUF_DSCR		; Get the output qualifier.
	PUSHAL	GET_VAL_DSCR		;
	PUSHAL	OUTPUT_QUAL		;
	CALLS	#3,G^CLI$GET_VALUE	;
	JLBC	R0,99$			; Branch on error.

	MOVC3	RET_BUF_DSCR,RET_BUF,-	; Store the output file string for
		OUT_FILE_SPEC		;  $PARSE.

32$:	$PARSE	FAB = OUTFAB		; Parse the filespec.
	JLBC	R0,99$			; Branch on error.
	JBS	#DEV$V_NET,-		; Branch if network device.
		OUTFAB+FAB$L_DEV,57$	;
	JBC	#DEV$V_TRM,-		; Branch if output device isn't a
		OUTFAB+FAB$L_DEV,55$	;  terminal.
	MOVZBW	OUTNAM_BLOCK+NAM$T_DVI,-; Build a descriptor for GETDVI.
		RET_BUF_DSCR		;
	MOVC3	RET_BUF_DSCR,-		;
		OUTNAM_BLOCK+NAM$T_DVI+1,- ;
		RET_BUF			;
	$GETDVI_S -			; Get the output device characteristics.
		DEVNAM=RET_BUF_DSCR,-	;
		ITMLST=GET_LIST		;
33$:	BLBS	R0,34$			; Branch if successful.
	MOVL	#SS$_NORMAL,R0		; Otherwise treat it like a file.
	BRW	55$			;

34$:	CMPB	#DC$_TERM,DEVICE_CLASS	; Is output device a terminal?
	JNEQ	55$			; Branch if not.

	$ASSIGN_S -			; Assign a channel to the output device.
		DEVNAM=OUT_DEV_NAME,-	;
		CHAN=OUT_CHAN		;
	JLBC	R0,99$			; Branch on error.

	BITL	#TT2$M_DECCRT,DEVDEPEND2; Is output device a DECcrt?
	BEQL	35$			; Branch if not.
	BISB	#DVT$M_DCRT,OUT_DEV	; Set VT100 bit.
	BITL	#TT2$M_AVO,DEVDEPEND2	; Does the DECcrt have the advanced
					;  video option?
	BEQL	50$			; Branch if not.
	BISB	#DVT$M_AVO,OUT_DEV	; Set advanced video bit.
	BRB	50$			; Jump to common code.
35$:	BITL	#DT$_VT5X,DEVICE_TYPE	; Is output device VT52 compatable?
	BEQL	40$			; Branch if not.
	BISB	#DVT$M_VT52,OUT_DEV	; Set VT52 bit.
	BRB	50$			; Jump to common code.
40$:	BITL	#TT$M_SCOPE,DEVDEPEND	; Is the output device some type of
					;  scope?
	BEQL	45$			; Branch if not.
	BISB	#DVT$M_VT52,OUT_DEV	; Treat output device as if its a VT52.
	BISB	#DVT$M_UNKNOWN,OUT_DEV	; Indicate actual type is unknown.
	BRB	50$			; Jump to common code.
45$:	BISB	#DVT$M_HARD,OUT_DEV	; Assume output device is some type of
					;  hardcopy device.
;
; Build the characteristics buffer for setmode so that the terminal
; characteristics can be restored.
;

50$:	MOVB	DEVICE_CLASS,-		; Store the device class.
		SAVE_CHAR_BUF		;
	MOVB	DEVICE_TYPE,-		; Store the device type.
		SAVE_CHAR_BUF+1		;
	MOVW	BUFFER_SIZE,-		; Store the terminal width.
		SAVE_CHAR_BUF+2		;

	MOVZBL	DEVDEPEND+3,LAST_LINE	; Save the number of the last line
					;  (bottom command line) on the
					;  terminal.
;
; Setup new terminal characteristics for output device.
;

	MOVQ	SAVE_CHAR_BUF,-		; Get a copy of the terminal
		NEW_CHAR_BUF		;  characteristics for new setup.
	MOVL	DEVDEPEND2,-		;
		NEW_CHAR_BUF+8		;

	BISL	#TT$M_NOBRDCST!TT$M_ESCAPE,-
		NEW_CHAR_BUF+4		; Set no broadcast bit and escape bit
					;  in terminal characteristics.
	BICL	#TT$M_WRAP,-		; Clear wrap bit in terminal
		NEW_CHAR_BUF+4		;  characteristics.
	BISL	#TT2$M_BRDCSTMBX,-	; Set broadcast mailbox bit in extended
		NEW_CHAR_BUF+8		;  terminal characteristics.

	$QIOW_S -			; Set new characteristics.
		CHAN=OUT_CHAN,-		;
		FUNC=#IO$_SETMODE,-	;
		P1=NEW_CHAR_BUF,-	;
		P2=#CHAR_BUF_LEN	;
	JLBC	R0,99$			; Branch on error.
	BISL	#MF$M_NEW_CHAR,-	; Indicate that the terminal
		MISC_FLAGS		;  characteristics have been changed.

	BRB	60$			; Jump to common code.

55$:	PUSHAL	OUT_EXP_DSCR		; Redirect output to file.
	PUSHAL	SET_CHAN		;
	CALLS	#2,G^LIB$SET_OUTPUT	;
	JLBC	R0,99$			; Branch on error.

57$:	BISB	#DVT$M_DISK!DVT$M_HARD,-; Output is to a file.
		OUT_DEV			;
	MOVW	#132,SCREEN_WIDTH	; Assume 132 columns.
	MOVL	#68,LAST_LINE		; Assume 68 lines.

60$:	SUBL3	#1,LAST_LINE,CMD_LINE	; Save the number of the next-to-last
					;  line (top command line) on the
					;  terminal.
	SUBL3	#2,LAST_LINE,-		; Save the number of the last line on
		LAST_DATA_LINE		;  the terminal to be used to display
					;  data.

;
; Save local system ID in LOCSYSID.
;

63$:	MOVL	G^SCS$GB_SYSTEMID,LOCSYSID
	MOVW	G^SCS$GB_SYSTEMID+4,LOCSYSID+4

;
; Get the local node name.
;

	$CMKRNL_S -
		ROUTIN=GET_NODE_NAME

;
; Process command line qualifier /REPORT=.
;
	PUSHAL	REPORT_QUAL		; Was the report name specified?
	CALLS	#1,G^CLI$PRESENT	;
	JLBC	R0,80$			; If not default to cluster report.
	PUSHAL	GET_VAL_DSCR		; Get the report name.
	PUSHAL	REPORT_QUAL		;
	CALLS	#2,G^CLI$GET_VALUE	;
	JLBC	R0,80$			; Default to cluster report on error.
	CMPB	RET_BUF,#^A/L/		; Local report requested?
	BEQL	75$			; Yes go setup for the local report.
	CMPW	RET_BUF,#^A/CL/		; Cluster report requested?
	BEQL	80$			; Yes, go setup for the cluster report.
	CMPW	RET_BUF,#^A/CY/		; /REPORT=CYCLE specified?
	BNEQ	72$			; Branch if not.
	BISL	#MF$M_CONT!MF$M_CYCLE,-	; Set cycle and continuous display
		MISC_FLAGS		;  flags.
	BRB	80$			; Set up to start cycling with the
					;  cluster report.
72$:	MOVL	#SS$_BADPARAM,R0	; Exit status is bad parameter value.
	BRW	MAIN_ERR		; Exit.


;
; Setup for the local report.
;

75$:	MOVL	#CLS$M_ALL_SYS!CLS$M_CSB,-
		CLUST_SAVE
	MOVL	#CLS$M_LPRT!CLS$M_ERR,CLASS_SELECT
	BICB	#RPT$M_CLSTR,-		; Set current report to local.
		CURRENT_REPORT
	MOVAL	LOCAL_KEYTAB,KEYTAB_ADRS; Store address of local status keyword
					;  table.
	MOVAL	LOCAL_TABLE,ADRS_TABLE	; Store address of local address table.
	MOVAL	LOCAL_BITMAP,BITMAP_ADRS; Store address of local bitmap.
	MOVL	#LOCAL_MAP_LEN,MAP_LEN	; Store length of local bitmap.
	BRB	85$			; Branch to common code.

;
; Setup for the cluster report.
;

80$:	MOVL	#CLS$M_ALL_SYS!CLS$M_CSB,-
		CLASS_SELECT
	MOVL	#CLS$M_LPRT!CLS$M_ERR,-
		LOCAL_SAVE
	BISB	#RPT$M_CLSTR,-		; Set current report to clusters.
		CURRENT_REPORT		;
	MOVAL	CLUSTER_KEYTAB,-	; Store address of cluster keyword
		KEYTAB_ADRS		;  table.
	MOVAL	CLUSTER_TABLE,ADRS_TABLE; Store address of cluster table.
	MOVAL	CLUSTER_BITMAP,-	; Store address of cluster bitmap.
		BITMAP_ADRS		;
	MOVL	#CLUSTER_MAP_LEN,MAP_LEN; Store length of cluster bitmap.

;
; Check for /CONTINUOUS.
;

85$:	PUSHAL	CONTINUOUS_QUAL		; Was /CONTINUOUS specified?
	CALLS	#1,G^CLI$PRESENT	;
	BLBC	R0,87$			; Branch if not.
	BISL	#MF$M_CONT,MISC_FLAGS	; Set continuous display flag.

;
; Check for /INTERVAL.
;

87$:	PUSHAL	INTERVAL_QUAL		; Was /INTERVAL specified?
	CALLS	#1,G^CLI$PRESENT	;
	BLBC	R0,88$			; Branch if not.
	BISL	#MF$M_CONT,MISC_FLAGS	; Set continuous display flag.
	PUSHAL	RET_BUF_DSCR		; Get the time string.
	PUSHAL	GET_VAL_DSCR		;
	PUSHAL	INTERVAL_QUAL		;
	CALLS	#3,G^CLI$GET_VALUE	;
	JLBC	R0,99$			; Branch on error.
	PUSHAL	DELAY			; Convert the desired number of seconds
	PUSHAL	RET_BUF			;  to a longword.
	PUSHL	RET_BUF_DSCR		;
	CALLS	#3,G^LIB$CVT_DTB	;
	JLBC	R0,99$			; Branch on error.
	EMUL	#-10000000,DELAY,#0,-	; Convert the number of seconds to
		DELAY			;  binary time.

88$:	JSB	SET_REGION_DATA		; Set up scrolling region.

;
; Save a copy of the cluster bitmap for INITIALIZE command.
;

90$:	MOVL	#CLUSTER_MAP_LEN,R5
	MOVAL	CLUSTER_BITMAP,R7
	MOVAL	CL_SAVE_BITMAP,R6
91$:	MOVL	(R7)+,(R6)+
	SOBGEQ	R5,91$

;
; Save a copy of the local ports bitmap for INITIALIZE command.
;
	MOVL	#LOCAL_MAP_LEN,R5
	MOVAL	LOCAL_BITMAP,R7
	MOVAL	LOC_SAVE_BITMAP,R6
92$:	MOVL	(R7)+,(R6)+
	SOBGEQ	R5,92$


;
; Set the initial number of system blocks and connections that can be handled
; by the snapshot routine.  These numbers will be used in the MAIN_LOOP routine
; to determine the size of buffers to allocate for system blocks and
; connections.  The size of buffers for circuits and cluster system blocks will
; be derived from the number of system blocks. 
;
; The initial number of connections is set to the number of connections allowed
; by the SYSGEN SCSCONNCNT parameter but not to exceed the parameter default
; (DEF_CONNCNT).  This is to protect from the possibility of the parameter
; being set much higher than necessary. (maximum is 32k)
;
; The initial number of system blocks is set to 12 which is in affect
; the same as setting it to 16 because it will be increased by 4 on the first
; pass to allow for expansion.
;
	CMPW	G^SCS$GW_CDTCNT,-	; Are there less connections allowed
		#DEF_CONNCNT		;  on this system then there normally
					;  are by default?
	BLSSU	93$			; Branch if so.
	MOVW	#DEF_CONNCNT,CDT_DSCR+2	; Otherwise take the default.
	BRB	94$			; Jump to common code.
93$:	MOVW	G^SCS$GW_CDTCNT,-	; Store the actual number allowed.
		CDT_DSCR+2		;
94$:	MOVW	#12,SB_DSCR+2		; Fake the number of known system
					;  blocks.  This will be expanded to
					;  16 on the first pass.

;
; Clear the terminals screen.
;
	BSBW	CLEAR_SCREEN		; Clear the screen.
	JLBC	R0,99$			; Branch on error.

;
; Translate SHOW_CLUSTER$INIT.  If the logical name is defined then go execute
; the initialization file.
;

	$TRNLOG_S -			; Translate the logical name
		LOGNAM=INIT_NAME,-	;  SHOW_CLUSTER$INIT.
		RSLLEN=TRAN_DSCR,-	;
		RSLBUF=TRAN_DSCR	;
	CMPL	#SS$_NOTRAN,R0		; Was SHOW_CLUSTER$INIT defined?
	BEQL	95$			; Branch if not.
	MOVAL	DEF_EXT,-		; Store default file extention in FAB.
		INFAB+FAB$L_DNA		;
	MOVB	#DEF_EXT_LEN,-		; Store length of default extention in
		INFAB+FAB$B_DNS		;  FAB.
	CALLS	#0,EXECUTE		; Execute initialization file.
	JLBC	R0,99$			; Branch on error.
	MOVAL	DEF_NAME2,-		; Store default filename in FAB.
		INFAB+FAB$L_DNA		;
	MOVB	#DEF_NAME2_LEN,-	; Store length of default filename in
		INFAB+FAB$B_DNS		;  FAB.

95$:	PUSHAL	ENDING_QUAL		; Was /ENDING specified?
	CALLS	#1,G^CLI$PRESENT	;
	BLBC	R0,96$			; Branch if not.
	PUSHAL	RET_BUF_DSCR		; Get the time string.
	PUSHAL	GET_VAL_DSCR		;
	PUSHAL	ENDING_QUAL		;
	CALLS	#3,G^CLI$GET_VALUE	;
	JLBC	R0,99$			; Branch on error.

	PUSHAQ	A_TIME			; Convert the time string to binary.
	PUSHAL	RET_BUF_DSCR		;
	CALLS	#2,G^LIB$CVT_TIME	;
	JLBC	R0,99$			; Branch on error.

	$SETIMR_S -			; Set the timer to force a control-C
		DAYTIM = A_TIME,-	;  when it expires.
		ASTADR = CNTRLC_AST_DEL	;
	JLBC	R0,99$			; Branch on error.

96$:	PUSHAL	BEGIN_QUAL		; Was /BEGINNING specified?
	CALLS	#1,G^CLI$PRESENT	;
	BLBS	R0,97$			; Branch if so.
	MOVL	#SS$_NORMAL,R0		; Otherwise, make sure we don't
					;  consider the error fatal.
	BRB	975$			; Branch to common.
97$:	PUSHAL	RET_BUF_DSCR		; Get the time string.
	PUSHAL	GET_VAL_DSCR		;
	PUSHAL	BEGIN_QUAL		;
	CALLS	#3,G^CLI$GET_VALUE	;
	JLBC	R0,99$			; Branch on error.

	PUSHAQ	A_TIME			; Convert the time string to binary.
	PUSHAL	RET_BUF_DSCR		;
	CALLS	#2,G^LIB$CVT_TIME	;
	JLBC	R0,99$			; Branch on error.

	$SCHDWK_S -			; Leave a wakeup call.
		DAYTIM = A_TIME		;
	BLBC	R0,99$			; Branch on error.

	MOVAL	RET_BUF_DSCR,-		; Save address of time string in error
		ERR_MSGVEC+12		;  message vector.
	MOVL	#SHOW$_HIBER,CMD_STATUS	; Tell the user we're going into
	BSBW	SIGNAL			;  hibernation.
	MOVAL	<TPARSE_BLK+-		; Restore error message vector to
		TPA$L_STRINGCNT>,-	;  normal.
		ERR_MSGVEC+12		;

	$HIBER_S			; Off to sleep...

975$:	BBC	#DVT$V_DISK,IN_DEV,98$	; Branch if input isn't from a file.
	BRW	99$			; And finish up.

;
; Set up control-c handler.
;

98$:	$QIOW_S -			; Setup a control-C ast handler.
		CHAN=IN_CHAN,-		;
		FUNC=#IO$_SETMODE!IO$M_CTRLCAST,-
		P1=CNTRLC_AST_DEL	;

	MOVZWL	SCREEN_WIDTH,VALUE	; Save number of columns for set screen
	CALLS	#0,SET_SCREEN		; Set the screen width to 80 or 132
					;  column mode.
	BLBC	R0,99$			; Branch on error.

;
; Set up for first AST.
;

	$CLREF_S -			; Clear ast event flag.
		EFN=#EVF$V_AST_FLAG
	BLBC	R0,99$			; Branch on error.
	BSBW	SET_AST			; Set first AST for unsolicited data.

99$:	POPR	#^M<R2,R3,R4,R5,R6,R7>
	RSB				; Return with status.



;++
;
; FUNCTIONAL DESCRIPTION:
;
; This routine simply gets the node name of the local system from the local
; system block and stores it in the NODE_NAME_DSCR.  The nodename is then used
; by the GET_HEADER routine to display the nodename in the header.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,GET_NODE_NAME
;
; CALLED BY:
;
;	INIT
;
; INPUTS:
;
;	Nodename stored in the local system block.
;
; OUTPUTS:
;
;	Nodename stored in NODE_NAME_DSCR.
;
; RETURN STATUS:
;
;	None.
;
;--

.ENTRY	GET_NODE_NAME,^M<R2,R3,R4,R5>

;
; Get the number of bytes in the nodename.
;
	MOVB	G^SCS$GA_LOCALSB+SB$T_NODENAME,-
		NODE_NAME_DSCR
;
; Store the node name in the node name descriptor.
;
	MOVC3	NODE_NAME_DSCR,-
		G^SCS$GA_LOCALSB+SB$T_NODENAME+1,-
		NODE_NAME

	RET



	.SBTTL	Exit handler.
;
;	This is the entry point for the exit routine established during
;	initialization.  It simply moves the status stored in STATUS by
;	the $EXIT_S to R0 and falls through to the MAIN_ERR routine.
;

.ENTRY	EXIT_RTN,^M<>

	MOVL	STATUS,R0		; Get the exit status.

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles all cleanup before the program exits.  It restores
;	the original terminal characteristics, restores the original screen
;	width, and deassigns the channels assigned to the terminal and mailbox.
;	An error encountered while trying to do the cleanup is considered fatal
;	and the image immediately exits.
;
; INPUTS:
;
;	Error status in R0.
;
; IMPLICIT OUTPUTS:
;
;	Error message output to terminal if status in R0 is not success.
;
; RETURN STATUS:
;
;	Error status in R0.
;
;--

MAIN_ERR:
	BISL	#MF$M_EXIT_FLAG,-	; Indicate exit in progress.
		MISC_FLAGS		;
	BBC	#DVT$V_DISK,OUT_DEV,-	; Branch if I/O device is a terminal.
		5$			;
	BRW	MAIN_EXIT		; Otherwise, skip the following.
5$:	MOVL	R0,ERR_MSGVEC+4		; Save status for error message.

	$QIOW_S -			; Make sure graphics mode is off.
		CHAN=OUT_CHAN,-	
		FUNC=#IO$_WRITEVBLK,-
		P1=#^A//,-
		P2=#1
	JLBC	R0,MAIN_EXIT		; Branch on error.

	MOVZWL	SAVE_CHAR_BUF+2,VALUE	; Get the original screen width.
	CALLS	#0,SET_SCREEN		; Reset the screen width.
	JLBC	R0,MAIN_EXIT		; Branch on error.

	BSBW	SET_REGION_FULL		; Reset the scrolling region to use the
					;  full screen. (Added for foreign
					;  terminals emulating VT100s).

	BLBC	ERR_MSGVEC+4,10$	; Don't clear the screen if exiting
					;  with error status.
	BBC	#MF$V_CONT,MISC_FLAGS,-	; Don't clear the screen if display
		10$			;  is not in continuous update mode.
	BSBW	CLEAR_SCREEN		; Clear the screen.
	JLBC	R0,MAIN_EXIT		; Branch on error.
	BRB	10$			; Exit status is normal - don't output
					;  any message.

10$:	BBC	#MF$V_NEW_CHAR,-	; Branch if the terminal characteristics
		MISC_FLAGS,MAIN_EXIT	;  were never changed.
	$QIOW_S -			; Restore old terminal characteristics.
		CHAN=OUT_CHAN,-		;
		FUNC=#IO$_SETMODE,-	;
		P1=SAVE_CHAR_BUF,-	;
		P2=#CHAR_BUF_LEN	;

MAIN_EXIT:
	CMPL	#SS$_NORMAL,ERR_MSGVEC+4; Is the original exit status success?
	BEQL	99$			; If so exit with status from MAIN_ERR
					;  routine.
	MOVL	ERR_MSGVEC+4,R0		; Otherwise get the original status
					;  back.
99$:	RET				; And exit...



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine coordinates the generation of each report by calling
;	the appropriate routines based on the classes selected by the
;	user.
;
;--

DISPLAY:
	PUSHR	#^M<R7,R10>
	MOVL	#1,LINE_NUM		; Initialize line number.
	BBC	#DVT$V_DCRT,OUT_DEV,10$	; Branch if output device isn't a
					;  DECcrt.
	PUSHAL	COL_NUM			; Make sure line drawing and special
	PUSHAL	LINE_NUM		;  graphics character set in G1 area in
	PUSHAL	GRAPHICS_DSGNTR		;  DECcrt on each screen update.
	CALLS	#3,G^LIB$PUT_SCREEN	;
	JLBC	R0,DISPLAY_ERROR	; Branch on error.

10$:	BICB	#SCR$M_MORE_DWN,-	; Clear flag that indicates there is
		SCROLL_FLAGS		;  data off the bottom of the screen.
	MOVL	LINE_DIF,PRIOR_LINE_DIF	; Save record of lines changed on the
					;  last pass.
	MOVL	SCROLL_DIF,LINE_DIF	; Clear record of lines changed this
					;  pass, but set the bits for any
					;  lines that have to be redrawn
					;  because of scrolling.
	MOVL	BLANK_LINES,-		; Save record of blank lines on the
		PRIOR_BLANK_LINES	;  last pass.
	CLRL	BLANK_LINES		; Clear record of blank lines this
					;  pass.
	BBC	#MF$V_RIP,MISC_FLAGS,20$; Branch if refresh not in progress.
	CLRL	CLUB_HEADER_SIZE	; Initialize CLUB header size...
	CLRL	SCS_HEADER_SIZE		; ...SCS header size...
	CLRB	CLUB_NUM_FIELDS		; ...number of CLUB fields...
	CLRB	SCS_NUM_FIELDS		; ...number of SCS fields...

;
; Go allocate some buffer space, lock in memory and take a snapshot of the
; SCS and port databases.
;

20$:	JSB	DO_SNAPSHOT		;
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	JBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,-	;  cluster report.
		DISPLAY_PTP		;
	BITL	#CLS$M_ANY_CLUS,-	; Any Cluster report information to be
		CLASS_SELECT		;  displayed?
	BNEQ	30$			; Branch if so.
	BRW	DISPLAY_END		; And go finish up.
30$:	BBC	#CLS$V_CLUB,-		; Branch if display of CLUB is disabled.
		CLASS_SELECT,DISPLAY_SCS;
;
; Display the CLUSTER class at the top of the screen.  This class
; contains general cluster information from the CLUB.
;

DISPLAY_CLUB:
	MOVL	CLASS_SELECT,-		; Save mask of selected classes.
		SAVED_CLASSES		;
	BICL	#CLS$M_ANY_SCS,-	; Temporarily disable all classes but
		CLASS_SELECT		;  the CLUB.
	BISL	#CLS$M_CLUB,DATA_CNTRL	; Enable display of fields in the CLUB.
	MOVL	#CLS$M_CLUB,-		; Set current class to CLUSTER.
		CURRENT_CLASS		;
	BSBW	GET_HEADER		; Output CLUB header to screen buffer.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	MOVL	CLUB_HEADER_SIZE,-	; If no refresh and displaying both CLUB
		HEADER_SIZE		;  and SCS, the HEADER_SIZE will be set
					;  to the SCS header size, so we must
					;  get the real CLUB_HEADER_SIZE back.
	PUSHAL	CLUB_BUF		; Push address of the CLUB.
	CALLS	#1,GET_DATA		; Get a line of data.
;
; Since the number of lines in the CLUB portion of the display will never
; change, we don't have to call DISPLAY_COMMON.  Instead we output the
; bottom line of the display box only when doing a refresh pass.
;
	BBC	#MF$V_RIP,MISC_FLAGS,20$; Branch if refresh not in progress.
	BSBW	DRAW_LAST_LINE		; Draw bottom line of CLUB display box.
	BRB	30$			; Branch to common code.
20$:	INCL	LINE_NUM		; Skip over bottom line of CLUB display
					;  box.
30$:	MOVL	SAVED_CLASSES,-		; Restore mask of selected classes.
		CLASS_SELECT		;

;
; Display any SCS data (SYSTEMS, CIRCUITS, CONNECTION, COUNTERS,
; or CREDITS classes) or any CSB data (MEMBERS class).
;

DISPLAY_SCS:
	BITL	#CLS$M_ANY_SCS,-	; Any SCS or Cluster System Block info
		CLASS_SELECT		;  to be displayed?
	JEQL	DISPLAY_END		; Branch if not.
	MOVL	CLASS_SELECT,-		; Save mask of selected classes.
		SAVED_CLASSES		;
	MOVL	V_SCROLL,V_SCROLL_LINE	; Set the number of data lines to skip.
	BSBW	GET_NUM_PB		; Get the number of circuits on each
					;  system.
	BICL	#CLS$M_CLUB,CLASS_SELECT; We've already displayed CLUB info.
	MOVL	#CLS$M_SYS,CURRENT_CLASS; Set current class to SYSTEMS.
	BSBW	GET_HEADER		; Output SCS header to screen buffer.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	MOVL	SCS_HEADER_SIZE,-	; If no refresh, and displaying both
		HEADER_SIZE		;  CLUB and SCS, the header size will
					;  be set to the CLUB header size.  We
					;  must get the SCS header size back.
	BEQL	10$			; Branch if nothing to display.
	BSBW	SCS_REPORT		; Output the SCS data.
	BSBW	DISPLAY_COMMON		; Execute common display code.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
10$:	MOVL	SAVED_CLASSES,-		; Restore mask of selected classes.
		CLASS_SELECT		;
	BRW	DISPLAY_END		; Finish up display.


;
; Display the Port-to-Port data.  (LOCAL_PORTS and ERRORS classes).
;

DISPLAY_PTP:
	CLRL	V_SCROLL_LINE		; Insure that vertical scrolling
					;  doesn't occur in the local report.
	MOVL	#CLS$M_LPRT,-		; Set current class to LOCAL_PORTS.
		CURRENT_CLASS		;
	BSBW	GET_HEADER		; Output SCS header to screen buffer.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	BSBW	LOCAL_REPORT		; Output the PTP data.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	BSBW	DISPLAY_COMMON		; Execute common display code.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
;
; For the Local_Ports report, we also output the number of buffer descriptors
; free and in use below the rest of the display.
;
	BSBW	ERASE_TWO_LINES		; Leave a couple of blank lines.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	MOVAL	NUM_BUF_DSCR_DSCR,R10	; Point to descriptor for the number of
					; buffer descriptors in use.
	MOVL	FD$L_OFFSET(R10),R7	; Get the SCS offset from the
					;  descriptor.
	BSBW	FORMAT_DATA		; Format the data.
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	PUSHAW	COL_NUM			; Output the data to the report.
	PUSHAW	LINE_NUM		;
	PUSHAL	FORMAT_BUF_DSCR		;
	CALLS	#3,G^LIB$PUT_SCREEN	;
	JLBC	R0,DISPLAY_ERROR	; Branch on error.
	PUSHAL	BUFF_MSG		; Print "CI buffer descriptors in use."
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	CALLS	#0,G^LIB$ERASE_LINE	; Erase the rest of the line.
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	INCL	LINE_NUM		; Free buffer descriptors on next line.
	MOVAL	NUM_FREE_BUF_DSCR_DSCR,-; Point to descriptor for number of 
		R10			;  buffer descriptors free.
	MOVL	FD$L_OFFSET(R10),R7	; Get the SCS offset from the
					;  descriptor.
	BSBW	FORMAT_DATA		; Format the data.
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	PUSHAW	COL_NUM			; Output the data to the report.
	PUSHAW	LINE_NUM		;
	PUSHAL	FORMAT_BUF_DSCR		;
	CALLS	#3,G^LIB$PUT_SCREEN	;
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	PUSHAL	FREE_BUFF_MSG		; Print "CI buffer descriptors free."
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	CALLS	#0,G^LIB$ERASE_LINE	; Erase the rest of the line.
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	INCL	LINE_NUM		; Set line number to next line.

DISPLAY_END:

;
; Erase any lines following the report, and update the scrolling
; signals and broadcast messages at the bottom of the display.
;

	BSBW	ERASE_PAGE		; Erase any remaining data.
	BLBC	R0,DISPLAY_ERROR	; Branch on error.
	BSBW	CHECK_MORE		; Add scrolling signals or broadcast
					;  messages to the report.
	BICL	#MF$M_RIP,MISC_FLAGS	; Clear refresh in progress flag.

DISPLAY_ERROR:
	POPR	#^M<R7,R10>
	RSB



;
; This routine is called output of either the Cluster Report or the Local
; report. It determines if the bottom line of the box surrounding the data
; should be draw.  This line is drawn only if there is room on the screen and
; either the line won't be drawn in the same place is was last pass, or the
; screen is being refreshed. 
;

DISPLAY_COMMON:
	MOVL	#SS$_NORMAL,R0		; Assume success.
	MOVL	LINE_NUM,NUM_LINES	; Save number of lines this pass.
	CLRL	SCROLL_DIF		; Clear record of lines to redraw
					;  because we scrolled.
	BBS	#SCR$V_MORE_DWN,-	; Branch if we have more lines of data
		SCROLL_FLAGS,20$	;  than will fit on the screen.
	CMPL	LINE_NUM,CMD_LINE	; Will the next line be in the command
					;  region?
	BEQL	20$			; If so don't output the last line.
	BBSC	#MF$V_SCROLL,-		; Clear flag that indicates that we
		MISC_FLAGS,10$		;  have scrolled.
	CMPL	NUM_LINES,-		; Do we have the same number of lines
		PRIOR_NUM_LINES		;  of data as last pass?
	BNEQ	10$			; If not, draw the last line of the box.
	BBS	#MF$V_RIP,MISC_FLAGS,10$; If refresh in progress better draw the
					;  last line.
	INCL	LINE_NUM		; Skip the last line draw.
	MOVL	#SS$_NORMAL,R0		; Indicate success.
	BRB	20$			; Jump to common code.
10$:	BSBW	DRAW_LAST_LINE		; Draw bottom line of display box.
	JLBC	R0,MAIN_ERR		; Branch on error.
20$:	RSB


	.SBTTL	SCS report generation routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine formats the SCS portion of the cluster report.  This
;	portion	of the report has been designed to illustrate the heirarchy of
;	the cluster by showing the relationship between a system on the cluster,
;	the circuits established on the system, and the connections established
;	over these circuits.  This portion of the report also displays the
;	system membership status (MEMBERS class).
;
;	This routine scans through the snapshot buffer looking for data to be
;	displayed while controlling what data is to be displayed on a
;	particular line of the report (using the mask at DATA_CNTRL).
;	If the data found in the snapshot buffer conforms to the data to be
;	displayed on the particular line and the user has elected to see that
;	type of data, then a call is made to the GET_DATA routine to extract,
;	 format and add the line of data to the	screen buffer.
;
;	This routine also sets up the counter V_SCROLL_LINE by using the
;	value in V_SCROLL.  This count is an input to the GET_DATA routine
;	which causes it to ignore the first "V_SCROLL" times it is called.
;	This effectively scrolls the report up "V_SCROLL" lines.
;
; CALLING SEQUENCE:
;
;	JSB	SCS_REPORT
;
; CALLED BY:
;
;	DISPLAY_SCS
;
; INPUTS:
;
;	V_SCROLL	Set to the number of lines of data to skip before
;			adding the first line of data to the report.
;	         
;	CLASS_SELECT	Contains a mask of the classes selected for display
;			by the user.
;
; IMPLICIT INPUTS:
;
;	Snapshot has been performed and all the system blocks, path blocks, etc.
;	have been stored in SNAP_BUF.
;
; IMPLICIT OUTPUTS:
;
;	Display data stored in SCREEN_BUF.
;
; RETURN STATUS:
;
;	Status from call to GET_DATA routine passed in R0.
;
; REGISTER USAGE:
;
;	R8  -	Pointer to connections in CDT buffer.
;	R9  -	Pointer to path blocks in PB buffer.
;	R10 -   Pointer to cluster system block in CSB buffer.
;	R11 -	Pointer to system blocks in SB buffer.
;
;
; NOTES:
;	In order to display a class, the corresponding CLS$ (class) bit in
;	CLASS_SELECT must be set.  The same must be true of DATA_CNTRL or all
;	the fields in that class will be filled in with blanks.  Normally the
;	CLASS_SELECT bits are controlled by the user through the ADD class and
;	REMOVE class commands and the DATA_CNTRL bits are controlled by Show
;	Cluster to format the display.  When the CLUSTER class is being
;	displayed, Show Cluster also manipulates the CLASS_SELECT bits.
;	CLASS_SELECT bits are manipulated in this routine and in the REFRESH
;	routine to control the display of the header.
;--

ASSUME	CLS$V_750_SYS EQ 16

SCS_REPORT:
	PUSHR	#^M<R2,R8,R9,R10,R11>
	BICL	#<CLS$M_CSB!CLS$M_CIR!-	; Assume no members, circuits,
		  CLS$M_CON!CLS$M_CNT!-	;  connections, counters, or credits,
		  CLS$M_CRD!CLS$M_CLUB>,-; and no general cluster information
		DATA_CNTRL		;  to display, so disable them all.
	MOVL	VAR_BUF,R11		; Get address of first system block.
10$:	MOVAL	HW_TYPE_TABLE,R2	; Point to table of system types.
	CLRL	R1			; Initialize index into table.
20$:	CMPL	(R2)[R1],-		; Is the type of system specified by
		SB$T_HWTYPE(R11)	;  this system block in the table?
	BEQL	30$			; Branch if so.
	AOBLSS	#NUM_HW_TYPES,R1,20$	; Loop for all types of systems.
;
; If not in the table, accept it anyway.  It could be the local system block
; and VMSVAXCLUSTER <> 1, or pre VMS Version 3.3 system.
;
	BRB	40$			;

30$:	ADDL	#CLS$V_750_SYS,R1	; Convert index to CLS$ bit value.
	JBC	R1,CLASS_SELECT,160$	; Branch if user has removed this
					;  type of system from the display.
40$:	JSB	CHECK_ID		; Check if this systems ID is in the
					;  disabled list.
	JLBS	R0,160$			; Go on to next system block if it is.
	BISL	#CLS$M_SYS,DATA_CNTRL	; Enable display of systems class.
	MOVB	LINE_NUM,-		; Store line number for this system in
		SHC$SB$B_DIS_POS(R11)	;  system block.
50$:	BBC	#CLS$V_CSB,-		; Branch if user has removed members
		CLASS_SELECT,55$	;  from the display.
	BICL	#CLS$M_CSB,DATA_CNTRL	; Assume no CSB associated with this
					;  system.
	MOVL	SB$L_CSB(R11),R10	; Get address of CSB for this system.
	BEQL	55$			; Branch if no CSB.
	BISL	#CLS$M_CSB,DATA_CNTRL	; Enable display of CSB's.
55$:	JSB	CHECK_NUM_PB		; See if the number of path blocks on
					;  this system block has changed.
	MOVL	SB$L_PBFL(R11),R9	; Get address of first path block on
					;  this system block.
	BEQL	120$			; Branch if there are no circuits on
					;  this system.
	CMPW	PB$W_STATE(R9),-	; Is the circuit in the open state?
		#PB$C_OPEN		;
	BNEQ	70$			; Branch if not.
60$:	BBC	#CLS$V_OPEN_CIR,-	; Branch if user has removed open
		CLASS_SELECT,90$	;  circuits from the display.
	BRB	80$
70$:	BBC	#CLS$V_NOOPEN_CIR,-	; Branch if user has removed circuits in
		CLASS_SELECT,90$	;  states other that open from the
					;  display.
80$:	BISL	#CLS$M_CIR,DATA_CNTRL	; Enable display of circuits class.
90$:	JSB	CHECK_NUM_CDT		; See if the number of connections
					;  on this path has changed since the
					;  last pass.
 	MOVL	PB$L_CDTLST(R9),R8	; Get address of first CDT on this
					;  path block.
	BEQL	120$			; Branch if there are no connections
					;  on this circuit.
	CMPW	SHC$L_CDT_DIF+CDT$W_STATE(R8),-
		#CDT$C_LISTEN		; Is this CDT in the "listen" state?
	BNEQ	110$			; Branch if not.
	BICL	#CLS$M_CIR,DATA_CNTRL	; Otherwise, disable display of
					;  circuits class.
	BISL	#CLS$M_CON,DATA_CNTRL	; Enable display of connections class.
	BRB	120$			; Jump to common code.
110$:	CMPW	SHC$L_CDT_DIF+CDT$W_STATE(R8),-
		#CDT$C_OPEN		; Is this CDT in the "open" state?
	BNEQ	115$			; Branch if not.
	BBC	#CLS$V_OPEN_CON,-	; Branch if user has removed open
		CLASS_SELECT,119$	;  open connections from the display.
	BRB	118$			; Branch to common.
115$:	BBC	#CLS$V_NOOPEN_CON,-	; Branch if user has removed non-open
		CLASS_SELECT,119$	;  connections from the display.
118$:	BISL	#CLS$M_CON,DATA_CNTRL	; Enable display of connections class.
119$:	BISL	#CLS$M_CRD!CLS$M_CNT,-	; Enable display of counters and
		DATA_CNTRL		;  credits classes.

;
; AND the mask of classes we've enabled with the mask of classes the user has
; selected and see if there's any data to be displayed.  If so, output a line
; of data, otherwise continue looking.
;

120$:	MCOML	DATA_CNTRL,R1		; Get mask of classes enabled.
	BICL3	R1,CLASS_SELECT,R1	; Any data to be displayed?
	BEQL	130$			; Branch if not.
	BBS	#MF$V_RIP,MISC_FLAGS,-	; Skip position check if performing a
		125$			;  refresh.
	BBS	#MF$V_SCROLL,-		; Skip position check if we just
		MISC_FLAGS,125$		;  scrolled.
	JSB	CHECK_POS		; Check if the system has moved in the
					;  display.
125$:	PUSHL	R8			; Push address of CDT.
	PUSHL	R9			; Push address of path block.
	PUSHL	R10			; Push address of cluster system block.
	PUSHL	R11			; Push address of system block.
	PUSHL	#0			; Bogus CLUB address.
	CALLS	#5,GET_DATA		; Get a line of data.
	BLBC	R0,999$			; Branch on error.
130$:	BITL	#<CLS$M_CON!CLS$M_CNT!-	; Are we displaying connections,
		  CLS$M_CRD>,DATA_CNTRL	;  counters or credits?
	BEQLU	140$			; Branch if not.
	BICL	#<CLS$M_SYS!CLS$M_CSB!-	; Disable display of systems, members,
		  CLS$M_CIR>,DATA_CNTRL	;  and circuits class.
	MOVL	(R8),R8			; Get address of next CDT.
	BNEQ	120$			; Loop for all connections on this
					;  circuit.
140$:	BICL	#<CLS$M_CON!CLS$M_CNT!-	; Assume no connections on the next
		  CLS$M_CRD>,DATA_CNTRL	;  circuit, so disable display of
					;  connections, counters, and credits
					;  classes.
	TSTL	R9			; Are there any circuits on this system?
	BEQL	160$			; Branch if not.
	MOVL	(R9),R9			; Get address of next path block.
	BEQL	150$			; Branch if no more circuits on this
					;  system.
	BICL	#CLS$M_SYS!CLS$M_CSB,-	; Disable display of systems, members
		DATA_CNTRL		;  classes.
	BRW	60$			; Loop for all circuits on this system.
150$:	BICL	#<CLS$M_CIR!CLS$M_CON!-	; Assume no circuits on next system, so
		  CLS$M_CNT!CLS$M_CRD>,-;  disable display of circuits,
		DATA_CNTRL		;  connections, counters, and credits.
160$:	MOVAL	DUMMY_SB,R1		; Determine if we are displaying
	CMPL	R1,R11			;  formative paths without formative
					;  system blocks.
	BEQL	999$			; If so, end the report.
	MOVL	(R11),R11		; Get address of next system block.
	JNEQ	10$			; Loop for all systems in the cluster.
;
; Display any formative path blocks that have no associated formative system
; block.
;
	MOVAL	DUMMY_SB,R11		; Get the address of the fake system
					;  block.
	TSTL	SB$L_PBFL(R11)		; Are there any formative path blocks
					;  on the dummy system block?
	BEQL	999$			; Branch if not.
	BSBW	GET_BLANK		; Leave one blank line.
	BICL	#CLS$M_SYS!CLS$M_CSB,-	; Disable display of systems, and
		DATA_CNTRL		;  members classes of data.
	BRW	50$			; Display the formative path blocks.

999$:	POPR	#^M<R2,R8,R9,R10,R11>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine insures that a change in the number of path blocks
;	does not go undetected.  When a path block is removed from the
;	database, CHECK_DIF is no longer called to check for a change
;	in data for that path block.  This means that the line will
;	not be redrawn until the screen is refreshed.  This routine
;	calls CHECK_DIF with the data to be checked being the number
;	of path blocks, so a change will always be detected.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_NUM_PB
;
; CALLED BY:
;
;	CLUSTER_REPORT
;
; INPUTS:
;
;	Address of the system block in R11
;
; OUTPUTS:
;
;	The bit coresponding to the current line number in LINE_DIF
;	is set if the number of path block on this system block has
;	changed.
;
;--

CHECK_NUM_PB:
	PUSHR	#^M<R7,R10>
	MOVAL	SB$SHC$L_NUM_PB(R11),R7	; Get the address of the data.
	MOVAL	SB$SHC$L_NUM_PB_DSCR,-  ; Get the address of the field
		R10			;  descriptor.
	JSB	CHECK_DIF		; See if the number of path
					;  blocks changed.
	BBCC	#MF$V_INVERSE,-		; Branch if there was no change.
		MISC_FLAGS,99$		;
	BBSS	LINE_NUM,LINE_DIF,99$	; Indicate that this line of data
					;  must be redrawn.
99$:	POPR	#^M<R7,R10>
	RSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine insures that a change in the number of connections
;	does not go undetected.  When a CDT is removed from the database
;	CHECK_DIF is no longer called to check for a change in data for
;	that CDT.  This means that the line will not be redrawn until
;	screen is refreshed.  This routine calls CHECK_DIF with the data
;	to be checked being the number of CDTS , so a change will always
;	be detected.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_NUM_CDT
;
; CALLED BY:
;
;	CLUSTER_REPORT
;
; INPUTS:
;
;	Address of Path Block in R11
;
; OUTPUTS:
;
;	The bit coresponding to the current line number in LINE_DIF
;	is set if the number of CDT's on this path block has changed.
;
;--

CHECK_NUM_CDT:
	PUSHR	#^M<R7,R10>
	MOVAL	PB$SHC$L_NUM_CDT(R11),R7; Get the address of the data.
	MOVAL	PB$SHC$L_NUM_CDT_DSCR,-	; Get the address of the field
		R10			;  descriptor.
	JSB	CHECK_DIF		; See if the number of path
					;  blocks changed.
	BBCC	#MF$V_INVERSE,-		; Branch if there was no change.
		MISC_FLAGS,99$		;
	BBSS	LINE_NUM,LINE_DIF,99$	; Indicate that this line of data
					;  must be redrawn.
99$:	POPR	#^M<R7,R10>
	RSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine compares the display line number stored in the system block
;	at SHC$SB$B_DIS_POS  (SB$W_SIZE+1)  with the display line number stored
;	during the last update.  If different it indicates that the data for
;	this system has moved to a different part of the display.  If the data
;	itself has has not changed, then this could otherwise go undetected.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_POS
;
; CALLED BY:
;
;	CLUSTER_REPORT
;
; INPUTS:
;
;	R11 = Base address of system block containing line number to check.
;	OLD_VAR_BUF points to buffer containing system blocks from the previous
;	pass.
;
; OUTPUTS:
;
;	If the line numbers are found to be different, then a bit corresponding
;	to the line number is set in LINE_DIF.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL
;
;--

CHECK_POS:
	PUSHR	#^M<R2,R3>
	CMPL	R11,#DUMMY_SB		; Does R11 point to the fake system
					;  block?
	BNEQ	10$			; Branch if not.
	MOVAL	OLD_FIX_BUF,R3		; Point R3 to previous fixed length
					;  buffers.
	MOVAL	FIX_BUF,R2		; Get the address of the current fixed
					;  length buffers.
	SUBL3	R2,R11,R2		; Get the offset into the current
					;  fixed length buffer where this
					;  system block is located.
	BRB	20$			; Branch to common.
10$:	MOVL	OLD_VAR_BUF,R3		; Point R3 to the previous variable
					;  length buffers.
	SUBL3	VAR_BUF,R11,R2		; Get the offset into the current
					;  variable length buffer where this
					;  system block is located.
	CMPL	R2,OLD_VAR_BUF_LEN	; Is the offset larger than length of
					;  the previous buffer?
	BGEQ	30$			; Branch if so.
20$:	ADDL	R2,R3			; Locate the system block in the
					;  old buffer.
	CMPB	SHC$SB$B_DIS_POS(R11),-	; Is the line number different?
		SHC$SB$B_DIS_POS(R3)	;
	BEQL	40$			; Branch if not.
30$:	BBSS	LINE_NUM,LINE_DIF,40$	; Indicate line must be redrawn.
40$:	POPR	#^M<R2,R3>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine takes the system ID found in the system block and calls
;	FIND_SYS_ID to check if the system ID is in the SYS_ID_LIST of system
;	that are not to be display.  It returns success if the system ID was
;	found.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_ID
;
; CALLED BY:
;
;	CLUSTER_REPORT
;
; INPUTS:
;
;	R11 = Base address of system block containing ID to check.
;
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL if system ID is in the list.
;
;--

CHECK_ID:
	PUSHR	#^M<R4>			; R4 destroyed by FIND_SYS_ID.
	MOVL	SB$B_SYSTEMID(R11),-	; Get the system ID from the system
		ID_RESULT		;  block and store in ID_RESULT.
	MOVW	SB$B_SYSTEMID+4(R11),-	;
		ID_RESULT+4		;
	JSB	FIND_SYS_ID		; Look for it in the list.
	POPR	#^M<R4>			; Restore R4.
	RSB				; Return with status from FIND_SYS_ID.



	.SBTTL	Local report generation routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine formats the display for the local port report.  It simply
;	enables both classes in the local report gets the address of the
;	information for the port PDT_BUF and MISC_BUF and calls the GET_DATA
;	routine.  It then determines if a second report is present and if so
;	repeats the process for the second report.
;
;	Note that V_SCROLL_LINE is cleared for this report since it is never
;	necessary to scroll this report vertically.
;
; CALLING SEQUENCE:
;
;	JSB	LOCAL_REPORT
;
; CALLED BY:
;
;	MAIN_LOOP
;
; INPUTS:
;
;	CLASS_SELECT	Contains a mask of the classes selected for display
;			by the user.
;
; IMPLICIT INPUTS:
;
;	Snapshot has been performed and all the port discriptors and
;	miscellaneous port information has been stored in SNAP_BUF.
;
; IMPLICIT OUTPUTS:
;
;	Display data stored in SCREEN_BUF.
;
; RETURN STATUS:
;
;	Status from call to GET_DATA routine passed in R0.
;
; REGISTER USAGE:
;
;	R9  -	Pointer into MISC_BUF.
;	R10 -	Pointer into PDT_BUF.
;
;--

LOCAL_REPORT:
	PUSHR	#^M<R9,R10>
	MOVAL	PDT_BUF,R10		; Get address of first PDT.
	MOVAL	MISC_BUF,R9		; Get address of miscellaneous buffer.
	MOVL	#CLS$M_LPRT!CLS$M_ERR,-	; Enable display of local ports and
		DATA_CNTRL		;  errors.
	TSTL	(R9)			; Any data on first port?
	BEQL	10$			; Branch if not.
	BSB	100$			; Get data for this port.
	BLBC	R0,99$			; Branch on error.
10$:	ADDL	#MISC_BUF_LEN,R9	; Get address of miscellaneous data for
					;  the second port.
	ADDL	#SHC$L_PDT_LENGTH,R10	; Get address of PDT for second port.
	BSB	100$			; Get data for this port.
99$:	POPR	#^M<R9,R10>
	RSB

100$:	TSTL	(R9)			; Any data on port?
	BEQL	199$			; If not return.
	PUSHL	R9			; Save address of miscellaneous buffer.
	PUSHL	R10			; Save address of PDT
	SUBL	#5*4,SP			; Adjust SP for no CDT, PB, CSB, SB, or
					;  CLUB.
	CALLS	#7,GET_DATA		; Get info on port.
199$:	RSB



	.SBTTL	Error message output.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine does a call to $GETMSG using the status stored in
;	CMD_STATUS. (normally the result from the last command parse).
;	It then determines if any FAO arguments are expected with the
;	message and sets up the message vector accordingly.  Finally it
;	does a call to LIB$SIGNAL to output the message to the terminal.
;
; CALLING SEQUENCE:
;
;	JSB	SIGNAL
;
; CALLED BY:
;
;	READ_W_PROMPT
;	SCROLL_TWO
;
; INPUTS:
;
;	Message identification number stored at CMD_STATUS.
;
; IMPLICIT IMPUTS:
;
;	Descriptor for FAO argument stored at TPARSE_BLK+TPA$L_STRINGCNT.
;
; OUTPUTS:
;
;	Message output to the terminal.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

SIGNAL:
	CMPL	CMD_STATUS,-		; Syntax error detected by TPARSE?
		#LIB$_SYNTAXERR		;
	BNEQ	10$			; Branch if not.
	MOVL	#SHOW$_UNRCMD,CMD_STATUS; "Unrecognized command"
	BRB	30$			; Branch to common code.

10$:	CMPL	CMD_STATUS,#LIB$_UNRKEY	; Unrecognized keyword?
	BNEQ	20$			; Branch if not.
	MOVL	#SHOW$_UNRKEY,CMD_STATUS; "Unrecognized keyword"
	BRB	30$			; Branch to common code.

20$:	CMPL	CMD_STATUS,#LIB$_AMBKEY	; Ambiguous keyword?
	BNEQ	30$			; Branch if not.
	MOVL	#SHOW$_AMBIG,CMD_STATUS	; "Ambiguous keyword"

30$:	$GETMSG_S -			; Get the error message into the
		MSGID = CMD_STATUS,-	;  buffer.
		MSGLEN = ERR_MSG_DSCR,-	;
		BUFADR = GET_MSG_DSCR,-	;
		OUTADR = MSG_OUT_ADRS	;
	BLBC	R0,99$			; Branch on error.

	TSTB	MSG_OUT_ADRS+1		; Is there an FAO argument associated
					;  with the message.
	BEQL	40$			; Branch if not.
	MOVW	#3,ERR_MSGVEC		; Otherwise set the number of longwords
					;  in the message vector to include the
					;  FAO argument.
	MOVB	MSG_OUT_ADRS+1,-	; Save the number of FAO arguments in
		ERR_MSGVEC+8		;  the message vector.
	PUSHL	ERR_MSGVEC+12		;
	MOVZWL	ERR_MSGVEC+8,-(SP)	; Output the error message with FAO
	PUSHL	CMD_STATUS		;  directives.
	CALLS	#3,G^LIB$SIGNAL		;
	BRB	99$			; Branch to common code.

40$:	MOVB	#1,ERR_MSGVEC		; Set the number of longwords in the
					;  message vector to indicate that
					;  there are no FAO arguments are
					;  associated with the message.
	PUSHL	CMD_STATUS		; Output the error message.
	CALLS	#1,G^LIB$SIGNAL		;
	BRB	99$			; Branch to common code.

99$:	RSB



	.SBTTL	Broadcast message handling.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to output a broadcast message.  It determines
;	if any information is being display on the bottom line of the report
;	(command input, error messages, or a previous broadcast message).
;	If no information is being displayed, then a line of a broadcast
;	message is removed from the MSG_OUT_QUE (if available) and displayed
;	on the bottom line.  Once output, the buffer used for the message is
;	placed in the MSG_FRE_QUE to save calls to GET_VM by the STORE_MSG
;	routine.
;
; CALLING SEQUENCE:
;
;	JSB	OUT_MSG
;
; CALLED BY:
;
;	CHECK_MORE
;
; IMPLICIT INPUTS:
;
;	BOT_CMD_LINE	Indicates the type of information currently being
;			displayed in the bottom line of the command scroll
;			region.
;
;	MSG_OUT_QUE	Contains a list of buffers containing message lines
;			to be output.
;
; IMPLICIT OUTPUTS:
;
;	Broadcast message output to the screen buffer.
;	Message buffer added to MSG_FRE_QUE
;	Message buffer removed from MSG_OUT_QUE
;
;	BOT_CMD_LINE	Set to indicate that there is a broadcast message on
;			the bottom line of the command scroll region if a
;			message was output.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

OUT_MSG:PUSHR	#^M<R2,R3,R4,R5>
	TSTB	BOT_CMD_LINE		; Any information on the bottom command
					;  line?
	JNEQ	99$			; Branch if so.
	REMQUE	@MSG_OUT_QUE,BUFADR	; Remove a line from the message output
					;  queue.
	BVC	10$			; Skip next if available.
	BRW	99$			; Branch if none available.
10$:	ADDL3	#8,BUFADR,R4		; Get the address of the message.
					; Build message descriptor
	MOVZWL	(R4)+,MBX_MSG_DSCR	;  - length and type
	MOVL	R4,MBX_MSG_DSCR+4	;  - address.
	MOVL	LAST_LINE,LINE_NUM	; Output message on the bottom line.
	PUSHAW	COL_NUM			; Output the broadcast message.
	PUSHAW	LINE_NUM		;
	PUSHAW	MBX_MSG_DSCR		;
	CALLS	#3,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
	CALLS	#0,G^LIB$ERASE_LINE	; Erase the rest of the line.
	BLBC	R0,99$			; Branch on error.
	BBS	#DVT$V_DCRT,OUT_DEV,20$	; Branch if DECcrt terminal.
	MOVC3	MBX_MSG_DSCR,-		; Save a copy of the last message
		MBX_MSG_DSCR+4,-	;  output so that in can be scrolled.
		LAST_BRDCST_BUF		;
	MOVL	MBX_MSG_DSCR,-		; Save the length of the message.
		LAST_BRDCST_DSCR	;
20$:	BISB	#CL$M_BRDCST,-		; Indicate that there is a broadcast
		BOT_CMD_LINE		;  message on the bottom command line.
	MOVL	#SS$_NORMAL,R0
	INSQUE	@BUFADR,MSG_FRE_QUE	; Place message buffer in message free
					;  queue.
99$:	POPR	#^M<R2,R3,R4,R5>
	RSB



	.SBTTL	Scrolling routines.
	.SBTTL		-	SET_SCROLL routine.

	.ENABL	LSB

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine translates the characters following an escape in the 
;	command buffer into a scroll command.  If the escape sequence indicates
;	that one of the	arrow keys has been pressed then the value stored at
;	location V_SCROLL (for vertical scrolling) or either CLSTR_H_SCROLL
;	or LOCAL_H_SCROLL (for horizontal scrolling depending on which report
;	is being displayed) is incremented or decremented appropriately.
;
;	This routine also sets flags at location SCROLL_FLAGS if it determines
;	that data has been scrolled off the left or top of the screen or clears
;	the flags if the data has been restored.
;
;	If the terminal type is DECcrt, and the display is scrolled up or
;	down, then bits are set in SCROLL_DIF corresponding to the lines
;	which much be redrawn to complete the display.
;
;	NOTE:	This routine does not set or clear the flags that indicate that
;		the data has been truncated at the right side or bottom of the
;		screen
;
; CALLING SEQUENCE:
;
;	JSB	SET_SCROLL
;
; CALLED BY:
;
;	READ_WO_PROMPT
;
; IMPLICIT INPUTS:
;
;	Escape sequence stored in CMD_BUF.
;
; OUTPUTS:
;
;	V_SCROLL, CLSTR_H_SCROLL, or LOCAL_H_SCROLL updated.
;	SCROLL_FLAGS updated.
;	SCROLL_DIF updated.
;
;--

SET_SCROLL:
	CMPB	IOSB+4,#CSI		; Did the user type an eight-bit escape
					;  sequence?
	BNEQ	10$			; Branch if not.
	MOVB	#^A/[/,CMD_BUF		; Substitute an open bracket.
	MOVAL	CMD_BUF,R1		; Point to open bracket.
	BRB	20$			; Jump to common code.
10$:	MOVAL	CMD_BUF+1,R1		; Point to open bracket.
20$:	BBC	#DVT$V_DCRT,OUT_DEV,-	; Branch if not DECcrt terminal.
		40$			;
	CMPW	(R1),#DCRT_RT_ARROW	; Right arrow?
	JEQL	DEC_H_SCROLL		; Scroll right.
	CMPW	(R1),#DCRT_LFT_ARROW	; Left arrow?
	JEQL	INC_H_SCROLL		; Scroll left.
	BBS	#RPT$V_CLSTR,-		; Branch if we're displaying the
		CURRENT_REPORT,30$	;  cluster report.
	BRW	999$			; Otherwise, don't allow up or down
					;  scroll.
30$:	CMPW	(R1),#DCRT_UP_ARROW	; Up arrow?
	JEQL	DEC_V_SCROLL		; Scroll up.
	CMPW	(R1),#DCRT_DWN_ARROW	; Down arrow?
	JEQL	INC_V_SCROLL		; Scroll down.
	BRW	999$			; Must be invalid escape sequence.

40$:	CMPB	(R1),#VT52_RT_ARROW	; Right arrow?
	JEQL	DEC_H_SCROLL		; Scroll right.
	CMPB	(R1),#VT52_LFT_ARROW	; Left arrow?
	JEQL	INC_H_SCROLL		; Scroll left.
	BBS	#RPT$V_CLSTR,-		; Branch if we're displaying the
		CURRENT_REPORT,50$	;  cluster report.
	BRW	999$			; Otherwise, don't allow up or down
					;  scroll.
50$:	CMPB	(R1),#VT52_UP_ARROW	; Up arrow?
	BEQL	DEC_V_SCROLL		; Scroll up.
	CMPB	(R1),#VT52_DWN_ARROW	; Down arrow?
	JEQL	INC_V_SCROLL		; Scroll down.
	BRW	999$			; Must be invalid escape sequence.

DEC_V_SCROLL:
	TSTL	V_SCROLL		; Already scrolled all the way down?
	JEQL	999$			; If so, don't scroll.
	INCL	SCROLL_LINES		; Increase number of times we are
					;  allowed to scroll up.
	DECL	V_SCROLL		; Scroll display down.
	BNEQ	60$			; Branch if we're not all the way down.
	BICB	#SCR$M_MORE_UP,-	; Otherwise, clear the up flag.
		SCROLL_FLAGS		;
60$:	BBS	#DVT$V_DCRT,OUT_DEV,70$	; Branch if terminal is a DECcrt.
	BRW	140$			; Otherwise branch to set refresh flag.
70$:	BSBW	SET_REGION_DATA		; Set scrolling region to include only
					;  the data area of the screen.
	MOVL	FIRST_DATA_LINE,LINE_NUM; Set the cursor to the first line of
	PUSHAW	COL_NUM			;  data.
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$SET_CURSOR	;
	JLBC	R0,999$			; Branch on error.
	CALLS	#0,G^LIB$DOWN_SCROLL	; Scroll down one line.
	JLBC	R0,999$			; Branch on error.
	BSBW	SET_REGION_FULL		; Reset the scrolling region to use the
					;  full screen.
	ROTL	#1,SCROLL_DIF,SCROLL_DIF; Force the top line of data to be
	BBSS	FIRST_DATA_LINE,-	;  redrawn.
		SCROLL_DIF,80$		;
80$:	BRW	999$			; Finish up.

INC_V_SCROLL:
	BITL	#CLS$M_ANY_SCS,-	; Any SCS fields being displayed?
		CLASS_SELECT		;
	JEQL	999$			; Branch if not.
;
; Since we don't really know how many lines might be displayed in a given
; report, we don't really know how many times we can up-scroll.  Because of
; this, we limit the number of times the user can hit the up arrow before
; we get a chance to redraw the screen and see how many more lines we have.
;
	TSTL	SCROLL_LINES		; Any more lines to be scrolled?
	JEQL	999$			; Branch if not.
	DECL	SCROLL_LINES		; Now there's one less.
	INCL	V_SCROLL		; Scroll display up.
	BBC	#DVT$V_DCRT,OUT_DEV,90$	; Branch if terminal isn't a DECcrt.
	BSBW	SET_REGION_DATA		; Set scrolling region to include only
					;  the data area of the screen.
	MOVL	LAST_DATA_LINE,LINE_NUM	; Set the cursor to the last line of
	PUSHAW	COL_NUM			;  data.
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$SET_CURSOR	;
	JLBC	R0,999$			; Branch on error.
	CALLS	#0,G^LIB$UP_SCROLL	; Scroll up one line.
	JLBC	R0,999$			; Branch on error.
	BSBW	SET_REGION_FULL		; Reset the scrolling region to use the
					;  full screen.
	BBC	#SCR$V_MORE_DWN,-	; Branch if the bottom line doesn't
		SCROLL_FLAGS,90$	;  need to be drawn.
	ROTL	#-1,SCROLL_DIF,-	; Force the last data line to be
		SCROLL_DIF		;  drawn.
	BBSS	LAST_DATA_LINE,-	;
		SCROLL_DIF,90$		;
90$:	BISB	#SCR$M_MORE_UP!SCR$M_MORE,-
		SCROLL_FLAGS		; Indicate screen can be scrolled down.
	BBC	#DVT$V_DCRT,OUT_DEV,140$; Branch if terminal isn't a DECcrt.
	BRB	999$			; Otherwise, don't set the refresh flag.

INC_H_SCROLL:
	TSTB	NUM_FIELDS		; Any fields to be displayed?
	BEQL	999$			; Branch if not.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,100$	;  cluster report.
	INCL	CLSTR_H_SCROLL		; Otherwise scroll the cluster report
					;  left.
	BRB	110$			; Branch to common code.
100$:	INCL	LOCAL_H_SCROLL		; Scroll the local report left.
110$:	DECB	NUM_FIELDS		; Decrease number of times we can scroll
					;  left.
	BISB	#SCR$M_MORE_LFT!SCR$M_MORE,-
		SCROLL_FLAGS		; Indicate screen can be scrolled
					;  right.
	BRB	140$			; Done.

DEC_H_SCROLL:
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,120$	;  cluster report.
	TSTL	CLSTR_H_SCROLL		; Is the cluster report scrolled all
					;  the way to the right?
	BEQL	999$			; Don't scroll anymore if so.
	DECL	CLSTR_H_SCROLL		; Otherwise scroll the cluster report
					;  right.
	BNEQ	135$			; Branch if the cluster report isn't
					;  scrolled all the way to the right.
	BRB	130$			; Branch to common code.

120$:	TSTL	LOCAL_H_SCROLL		; Is the local report scrolled all the
					;  way to the right?
	BEQL	999$			; Don't scroll anymore if so.
	DECL	LOCAL_H_SCROLL		; Otherwise, scroll the local report
					;  right.
	BNEQ	135$			; Branch if the local report isn't
					;  scrolled all the way to the right.
130$:	BICB	#SCR$M_MORE_LFT,-	; Clear left flag.
		SCROLL_FLAGS		;
135$:	INCB	NUM_FIELDS		; Increase number of times we can scroll
					;  left.
140$:	BISL	#MF$M_RIP,MISC_FLAGS	; Set flag to indicate that the screen
					;  should be refreshed.
999$:	BISL	#MF$M_SCROLL,MISC_FLAGS	; Indicate we just scrolled.
	RSB

	.DSABL	LSB



	.SBTTL		-	CHECK_MORE routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to output the "MORE" scrolling signals at the
;	bottom of the display.  It first calls the routine which outputs
;	broadcast messages (giving the messages priority over the scrolling
;	signals).  It then checks to see if any scroll flags are set.  If
;	there is a scroll flag set it then checks to see if any information has
;	been output on either of the command lines (the bottom two lines of the
;	display - the top line has priority).  If there is no information
;	indicated on one of the lines it adds the "MORE" scrolling signals to
;	the screen buffer.
;
; CALLING SEQUENCE:
;
;	JSB CHECK_MORE
;
; IMPLICIT INPUTS:
;
;	TOP_CMD_LINE and BOT_CMD_LINE indicate the type of data currently being
;		displayed in the command scroll region.
;
; IMPLICIT OUTPUTS:
;
;	Scrolling signals output to the screen buffer if no other data is being
;	displayed in the command scroll region.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;--

CHECK_MORE:
	BSBW	OUT_MSG			; First see if there are any broadcast
					;  messages to output.
	CMPV	#SCR$V_MORE_RT,#4,-	; Has any data been scrolled off the
		SCROLL_FLAGS,#0		;  screen or truncated?
	JEQL	99$			; Branch if not.
	TSTB	BOT_CMD_LINE		; Is the bottom command line blank?
	JNEQ	99$			; Branch if not.
	MOVL	LAST_LINE,LINE_NUM	; Output on the bottom command line.
	CMPW	#NARROW,SCREEN_WIDTH	; Is the terminal width 80 columns?
	BEQL	5$			; Branch if it is.
	PUSHAW	COL_NUM			; Output "		More   ".
	PUSHAW	LINE_NUM		;
	PUSHAW	MORE_TABS		;
	BRB	7$			;
5$:	PUSHAW	COL_NUM			; Output "More	".
	PUSHAW	LINE_NUM		;
	PUSHAW	MORE_DSCR		;
7$:	CALLS	#3,G^LIB$PUT_SCREEN	;
	JLBC	R0,99$			; Branch on error.
	BITB	#SCR$M_MORE_UP,-	; Has the screen been scrolled up?
		SCROLL_FLAGS		;
	BEQL	10$			; Branch if not.
	PUSHAW	MORE_UP			; Output "^   ".
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
	BRB	20$			; Jump to common code.
10$:	PUSHAW	NO_MORE			; Output "    ".
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
20$:	BITB	#SCR$M_MORE_DWN,-	; Are there more lines of data than can
		SCROLL_FLAGS		;  be displayed?
	BEQL	30$			; Branch if not.
	PUSHAW	MORE_DWN		; Output "v   ".
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
	BRB	50$			; Jump to common code.
30$:	PUSHAW	NO_MORE			; Output "    ".
40$:	CALLS	#1,G^LIB$PUT_SCREEN	;
50$:	BITB	#SCR$M_MORE_LFT,-	; Has the screen been scrolled right?
		SCROLL_FLAGS		;
	BEQL	60$			; Branch if not.
	PUSHAW	MORE_LFT		; Output "<   ".
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
	BRB	70$			; Jump to common code.
60$:	PUSHAW	NO_MORE			; Output "    ".
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
70$:	BITB	#SCR$M_MORE_RT,-	; Has the data been truncated?
		SCROLL_FLAGS		;
	BEQL	99$			; Branch if not.
	PUSHAW	MORE_RT			; Output ">".
	CALLS	#1,G^LIB$PUT_SCREEN	;
99$:	RSB



	.SBTTL		-	Set scrolling region routines.
	.ENABL	LSB
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	The followin four routines set the scrolling regions of the terminal.
;	The four regions are defined as follows:
;
;	FULL		The full screen
;	DATA		The line imediately following the header up to the
;			command region.
;	COMMAND		The last two lines of the screen.
;	HELP		The line immediately following the header through the
;			last line of the screen.
;
; CALLING SEQUENCE:
;
;	JSB	SET_REGION_FULL
;	JSB	SET_REGION_COMMAND
;	JSB	SET_REGION_DATA
;	JSB	SET_REGION_HELP
;
; CALLED BY:
;
;	READ_W_PROMPT
;	DEC_V_SCROLL
;	INC_V_SCROLL
;	SCROLL_TWO
;	GET_HELP
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;--

SET_REGION_FULL:
	PUSHAW	FIRST_LINE		; Reset the scrolling region to use
	PUSHAW	LAST_LINE		;  the full screen.
	BRB	10$			; Branch to common code.

SET_REGION_DATA:
	PUSHAW	LAST_DATA_LINE		; Set the scrolling region to use only
	PUSHAW	FIRST_DATA_LINE		;  the data area of the display.
	BRB	10$			; Branch to common code.

SET_REGION_COMMAND:
	MOVL	CMD_LINE,LINE_NUM	; Set the scrolling region to the last
	PUSHAW	LAST_LINE		;  two lines of the display.
	PUSHAW	LINE_NUM		;
	BRB	10$			; Branch to common code.

SET_REGION_HELP:
	MOVL	#HEADER_END,LINE_NUM	; Set the scrolling region to the area
	PUSHAW	LAST_LINE		;  from the line following the header
	PUSHAW	LINE_NUM		;  to the last line of the display.

10$:	CALLS	#2,G^LIB$SET_SCROLL	;
	RSB				;

	.DSABL	LSB


	.SBTTL	AST routines.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered when data has been placed in the mailbox
;	associated with the terminal.  This data may be from a broadcast
;	message, unsolicited input from the terminal, or terminal hangup.
;	This routine simply sets an event flag and return so that we do
;	not remain at AST delivery very long.
;
; OUPUTS:
;
; 	AST event flag set.
;
;--

.ENTRY	AST_DEL,^M<>
	$SETEF_S -			; Set the AST event flag.
		EFN=#EVF$V_AST_FLAG	;
	RET



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered when the user types control-C on the terminal.
;	It simply sets the exit flag to indicate that the user has requested
;	that the program exit and then transfers control to the exit routine.
;
; OUTPUTS:
;
;	Exit flag set at MISC_FLAGS.
;
;--

.ENTRY	CNTRLC_AST_DEL,^M<>

	MOVL	#SS$_NORMAL,R0		; Indicate normal exit.
	$EXIT_S				; Exit.
	RET



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine queues a read over the mailbox channel which has been
;	associated with the terminal and then enables the mailbox.
;
; CALLING SEQUENCE:
;
;	JSB	SET_AST
;
; CALLED BY:
;
;	INIT
;	MAIN_CONT
;
; RETURN STATUS:
;
;	SS$_NORMAL returned in R0.
;--

SET_AST:
	$QIO_S -			; Set the AST.
		CHAN=MBXCHAN,-
		FUNC=#IO$_READVBLK,-
		IOSB=IOSB,-
		ASTADR=AST_DEL,-
		P1=MBX_BUF,-
		P2=#MBX_BUF_LEN
	BLBC	R0,99$			; Branch on error.

	$QIO_S -			; Enable mailbox.
		CHAN=IN_CHAN,-
		FUNC=#IO$_WRITEVBLK!IO$M_ENABLMBX,-
		IOSB=IOSB,-
		P1=CMD_BUF,-
		P2=#0

	MOVL	#SS$_NORMAL,R0
99$:	RSB


	.ENABL	LSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to erase the screen from the end of the report up
;	to the last two lines of the display.  It also erases the line where
;	the scrolling signals appear if they are being output.  This insures
;	that the scrolling signals always reflect the correct status and also
;	produces a blinking effect.
;
;	This routine also determines if the bottom two lines of the display
;	should be scrolled.  This scrolling is done only if there is additional
;	information on the bottom command line or if there is no information
;	on the bottom command line and the top command line does not contain
;	a broadcast message. The results (listed in priority) appear as follows:
;
;	1) Command input and error messages are scrolled in the command region
;	   on each refresh until they disappear from the display.
;
;	2) Broadcast messages are scrolled in the command region until the last
;	   broadcast message is on the top line in the command region at which
;	   point it is left there until the user takes action to remove it.
;
;	3) Scrolling signals are erased and are restored after the next update
;	   on the first blank line in the command region.
;
; CALLING SEQUENCE:
;
;	JSB	ERASE_PAGE
;
; CALLED BY:
;
;	DISPLAY_END
;
; INPUTS:
;
;	Number of the line following the report is stored in LINE_NUM.
;
; IMPLICIT INPUTS:
;
;	SCROLL_FLAGS	have been set to indicate the direction the screen can
;			be scrolled.
;	TOP_CMD_LINE and BOT_CMD_LINE indicate the type of data currently being
;		displayed in the command scroll region.
;
; IMPLICIT OUTPUTS:
;
;	Bottom two lines of display are scrolled.
;	TOP_CMD_LINE and BOT_CMD_LINE are updated.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
; REGISTER USAGE:
;
;	R2 -	Used to determine when all the lines have been erased.
;--

ERASE_PAGE:
	MOVL	#SS$_NORMAL,R0		; Assume success.
	BBS	#MF$V_RIP,MISC_FLAGS,5$	; Branch if refresh in progress.
	CMPL	NUM_LINES,-		; Do we have the same number of lines
		PRIOR_NUM_LINES		;  of data as last pass?
	BEQL	14$			; If so skip the erase.
5$:	PUSHR	#^M<R2>
	MOVL	LAST_DATA_LINE,R2	; Erase all the remaining data.
10$:	CMPL	LINE_NUM,R2		; Any lines to erase?
	BGTR	11$			; Branch if not.
	BSBW	ERASE_LINE		; Erase one line.
	JLBC	R0,99$			; Branch on error.
	BRB	10$			; Loop.
11$:	POPR	#^M<R2>

;
; If we are outputing "more" on the bottom line then erase the line so that it
; reflects the correct status.
;

14$:	MOVL	NUM_LINES,-		; Save number of lines for next pass.
		PRIOR_NUM_LINES		;
	SUBL3	#7,NUM_LINES,-		; Save number of times we can up scroll.
		SCROLL_LINES		;
	BBC	#CLS$V_CLUB,-		; Branch if not displaying the CLUSTER
		CLASS_SELECT,15$	;  class.
	SUBL	#7,SCROLL_LINES		; Otherwise, adjust number of lines that
					;  can be scrolled.
15$:	BBC	#SCR$V_MORE,-		; Branch if none of the scroll flags
		SCROLL_FLAGS,20$	;  have been set.
	CMPV	#SCR$V_MORE_RT,#4,-	; Are any of the scroll flags still
		SCROLL_FLAGS,#0		;  set?
	BNEQ	16$			; Branch if so.
	BICB	#SCR$M_MORE,SCROLL_FLAGS; Otherwise clear the summary flag.
16$:	TSTB	BOT_CMD_LINE		; Is the bottom command line blank?
	BNEQ	20$			; Branch if not.
	MOVL	LAST_LINE,LINE_NUM	; Get the number of the bottom command
					;   line.
	BSBW	ERASE_LINE		; Erase the line that we are outputing
					;  "more" on.
	JLBC	R0,99$			; Branch on error.
20$:	TSTL	SCROLL_DELAY		; Time to scroll the bottom two lines?
	BEQL	30$			; Branch if so.
	DECL	SCROLL_DELAY		; Count down the intervals before it's
					;  time to scroll.
	BRW	99$			; Done for now.
30$:	TSTB	BOT_CMD_LINE		; Any information on the bottom command
					;  line?
	JNEQ	SCROLL_TWO		; Branch if so.
	TSTB	TOP_CMD_LINE		; Any information on the top command
					;  line?
	JEQL	99$			; If not, no need to scroll.
	BITB	#CL$M_BRDCST,-		; Is there a broadcast message on the
		TOP_CMD_LINE		;  top command line?
	JNEQ	99$			; If so, don't scroll.

SCROLL_TWO:
	BBC	#DVT$V_DCRT,OUT_DEV,40$	; Branch if terminal is a VT52 type.
	JSB	SET_REGION_COMMAND	; Establish a scrolling region.
	JLBC	R0,99$			; Branch on error.
	MOVL	LAST_LINE,LINE_NUM	; Set the cursor to the last line.
	PUSHAW	COL_NUM			;
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$SET_CURSOR	;
	JLBC	R0,99$			; Branch on error.
	CALLS	#0,G^LIB$UP_SCROLL	; Scroll up one line.
	JLBC	R0,99$			; Branch on error.
	BRW	80$			; Jump to common code.
40$:	BBC	#DVT$V_HARD,OUT_DEV,43$	; Branch if output device isn't
					;  hardcopy.
	BRW	80$			; Otherwise, jump to common code.
43$:	BBS	#DVT$V_UNKNOWN,OUT_DEV,-; Branch if terminal type is unknown.
		80$			;
	TSTB	BOT_CMD_LINE		; Any information on the bottom command
					;  line?
	BEQL	50$			; Branch if not.
	MOVL	CMD_LINE,LINE_NUM	; Set the cursor to the top command
	PUSHAW	COL_NUM			;  line.
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$SET_CURSOR	;
	BLBC	R0,99$			; Branch on error.
	BITB	#CL$M_BRDCST,-		; Is there a broadcast message on the
		BOT_CMD_LINE		;  on the bottom command line.
	BEQL	45$			; If not, must be error message.
	PUSHAW	LAST_BRDCST_DSCR	; Output the last broadcast message on
	CALLS	#1,G^LIB$PUT_SCREEN	;   the top command line.
	BLBC	R0,99$			; Branch on error.
	BRB	46$			; Jump to common code.
45$:	BSBW	SIGNAL			; Output the last error message on the
					;  top command line.
46$:	CALLS	#0,G^LIB$ERASE_PAGE	; Erase the bottom line.
	BLBC	R0,99$			; Branch on error.
	BRB	80$			; Jump to common code.
50$:	TSTB	TOP_CMD_LINE		; Any information on the top command
					;  line?
	BEQL	99$			; Branch if not.
	MOVL	CMD_LINE,LINE_NUM	; Erase the top command line.
	PUSHAW	COL_NUM			;
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$ERASE_PAGE	;
	BLBC	R0,99$			; Branch on error.
80$:	MOVB	BOT_CMD_LINE,-		; Bottom command line information now
		TOP_CMD_LINE		;  on the command line.
	CLRB	BOT_CMD_LINE		; No information on bottom command
					;  line.
99$:	RSB

	.DSABL	LSB



	.SBTTL	Display header generation.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine combines the class titles and the field titles to form the
;	display header.  It also adds the necessary strings to draw the box
;	around the header.  It outputs a message identifying the report and the
;	displays the time in the upper right hand corner.
;
; CALLING SEQUENCE:
;
;	JSB	GET_HEADER
;
;
; CALLED BY:
;
;	DISPLAY_CLUB
;	DISPLAY_SCS
;	DISPLAY_PTP
;
; OUTPUTS:
;
;	  The entire header is stored in the screen buffer for
;	output using LIB$PUT_BUFFER.
;
; RETURN STATUS:
;
;	R0 =	SS$_Normal or failed status from LIB$PUT_SCREEN.
;
; REGISTER USAGE:
;
;	R7  -	Used to in formating the system id.
;	R10 -	Used to in formating the system id.
;	R11 -	Pointer to descriptor for data to be stored in the screen
;		buffer.
;
;--

GET_HEADER:
	PUSHR	#^M<R11>
	BBS	#MF$V_RIP,MISC_FLAGS,30$; Branch if refresh in progress.
;
; When not doing a refresh, just output the time in the upper right hand corner.
;
; If the CLUSTER class is being display along with any SCS class, then display
; the time when GET_HEADER is called for the CLUSTER class only, so that we
; don't update the time twice.
;

	BBC	#RPT$V_CLSTR,-		; Branch if displaying the local report.
		CURRENT_REPORT,10$	;
	BBS	#CLS$V_CLUB,-		; Branch if this header is for the
		CLASS_SELECT,10$	;  CLUSTER class.
	BBS	#CLS$V_CLUB,-		; Branch if we have already output
		SAVED_CLASSES,20$	;  the time.
10$:	BSBW	OUTPUT_TIME		; Output the time.
	INCL	LINE_NUM
20$:	ADDL	#5,LINE_NUM		; Skip past header info.
	BRW	998$			; And we're done.

30$:	BSBW	GET_TITLES		; Build the title line in TITLE_BUF.
	JLBC	R0,999$			; Branch on error.
	CMPL	HEADER_SIZE,#1		; Are there any classes or fields being
					;  displayed?
	BNEQ	40$			; Branch if so.
	CLRL	HEADER_SIZE		; Otherwise, make sure the first field
					;  delimiter doesn't get displayed.
40$:	BSBW	GET_CLASSES		; Build the class line in CLASS_BUF.
	JLBC	R0,999$			; Branch on error.
	BBC	#DVT$V_DCRT,OUT_DEV,50$	; Branch if terminal isn't a DECcrt.
	BSBW	BUILD_DECCRT_BOX	; Get the four lines of data that make
					;  up the boxes around the header.
	BRB	60$			; Jump to common code.
50$:	BSBW	BUILD_VT52_BOX		; Build the line for above the classes
					;  in CLASS_BOX_BUF and the line for
					;  above and below the field titles in
					;  FIELD_BOX_BUF.

60$:	BBC	#RPT$V_CLSTR,-		; Branch if displaying the local report.
		CURRENT_REPORT,90$	;
	BBC	#CLS$V_CLUB,-		; Branch if this header isn't for the
		CLASS_SELECT,70$	;  CLUSTER class.
	MOVL	HEADER_SIZE,-		; Save size of CLUB header.
		CLUB_HEADER_SIZE	;
	MOVB	NUM_FIELDS,-		; Save the number of CLUB fields being
		CLUB_NUM_FIELDS		;  displayed.
	BSBW	OUTPUT_DDM		; Output the display descriptor message.
	BITL	#CLS$M_ANY_SCS,-	; Are any SCS fields being displayed in
		SAVED_CLASSES		;  this report?
	BNEQ	65$			; If so, don't output the time yet.
	BSBW	OUTPUT_TIME		; Otherwise, do it now.
65$:	INCL	LINE_NUM		; Update line number.
	BRB	100$			; Branch to common code.
70$:	MOVL	HEADER_SIZE,-		; Save size of SCS header.
		SCS_HEADER_SIZE		;
	MOVB	NUM_FIELDS,-		; Save the number of SCS fields being
		SCS_NUM_FIELDS		;  displayed.
80$:	BBC	#CLS$V_CLUB,-		; If CLUB bit is clear we need to output
		SAVED_CLASSES,90$	;  the display descriptor.
	CMPB	SCS_NUM_FIELDS,-	; Are there more SCS fields than CLUB
		CLUB_NUM_FIELDS		;  fields bei]ng displayed?
	BGEQ	85$			; Branch if so.
	MOVB	CLUB_NUM_FIELDS,-	; Otherwise, limit left-scrolling by the
		NUM_FIELDS		;  number of CLUB fields.
85$:	BSBW	OUTPUT_TIME		; Output the time.
	ADDL	#8,LINE_NUM		; Skip past the CLUB display area.
	BRB	100$			; Branch to common code.
90$:	BSBW	OUTPUT_DDM		; Output the display descriptor message.
	BSBW	OUTPUT_TIME		; Output the time.
	INCL	LINE_NUM		; Update line number.

100$:	MOVAL	CLASS_BOX_DSCR,R11	; Point to descriptor for top of box.
	BSBW	DRAW_LINE		; Output top of box.
	BLBC	R0,999$			; Branch on error.
	MOVAL	CLASS_DSCR,R11		; Point to descriptor for the classes.
	BSBW	DRAW_LINE		; Output class names.
	BLBC	R0,999$			; Branch on error.
	MOVAL	FIELD_TOP_BOX_DSCR,R11	; Point to descriptor for line above
					;  the field names.
	BSBW	DRAW_LINE		; Output the line.
	BLBC	R0,999$			; Branch on error.
	MOVAL	TITLE_DSCR,R11		; Point to descriptor for the field
					;  titles.
	BSBW	DRAW_LINE		; Output the field names.
	BLBC	R0,999$			; Branch on error.
	BBC	#DVT$V_DCRT,OUT_DEV,110$; Branch if terminal is not a DECcrt.
	MOVAL	FIELD_BOT_BOX_DSCR,R11	; Point to descriptor for line below
					;  the field names.
	BRB	120$			; Jump to common code.
110$:	MOVAL	FIELD_TOP_BOX_DSCR,R11	; Point to descriptor for line above
					;  the field names.
120$:	BSBW	DRAW_LINE		; Complete the box around the field
	BLBC	R0,999$			; Branch on error.
					;  names.
998$:	MOVL	#SS$_NORMAL,R0
999$:	POPR	#^M<R11>
	RSB



	.SBTTL	-	Output the display description
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by GET_HEADER only if we are doing a refresh
;	pass.  It outputs the description of the display which appears on the
;	top line of the report.
;
; CALLING SEQUENCE:
;
;	JSB	OUTPUT_DDM
;
;
; CALLED BY:
;
;	GET_HEADER
;
; OUTPUTS:
;
;	Display discription message is output to the screen buffer.
;	Length of message is stored in DDM_SIZE.
;
; IMPLICIT OUTPUTS:
;
;	LINE_NUM is set to 1.
;
; RETURN STATUS:
;
;	R0 =	SS$_Normal or failed status from LIB$PUT_SCREEN.
;

OUTPUT_DDM:
	PUSHR	#^M<R2,R3,R7,R10>
	CLRL	R3			; Initialize string length.
	MOVL	#1,LINE_NUM		; Output description on line one.
	PUSHAW	COL_NUM			; Setup for LIB$PUT_SCREEN.
	PUSHAW	LINE_NUM		;
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,10$	;  cluster report.
	MOVAL	CLUSTER_MSG,R2		; Get address of message
					;  "View of Cluster from" string.
	BRB	20$			; Jump to common code.
10$:	MOVAL	LOCAL_MSG,R2		; Get address of "Local ports on".
20$:	ADDW	(R2),R3			; Calculate string length thus far.
	PUSHL	R2			; Output the message.
	CALLS	#3,G^LIB$PUT_SCREEN	;
	JLBC	R0,99$			; Branch on error.
	ADDW	MSG1_DSCR,R3		; Add length of system id message to
					;  string length.
	PUSHAL	MSG1_DSCR		; Push address of " system ID# "
					;  string.
	CALLS	#1,G^LIB$PUT_SCREEN	; Output the message.
	JLBC	R0,99$			; Branch on error.
	MOVAL	LOCSYSID_DSCR,R10	; Point to descriptor for the local
					;  system ID.
	MOVL	FD$L_OFFSET(R10),R7	; Get the address of the data.
	BSBW	FORMAT_DATA		; Format the data.
	JLBC	R0,99$			; Branch on error.
	ADDW	FORMAT_BUF_DSCR,R3	; Add length of system id to string
					;  length.
	PUSHAL	FORMAT_BUF_DSCR		; Push the address of the formatted
					;  data.
	CALLS	#1,G^LIB$PUT_SCREEN	; Output the system ID number.
	JLBC	R0,99$			; Branch on error.
	ADDW	MSG2_DSCR,R3		; Add length of node message to string
					;  length.
	PUSHAL	MSG2_DSCR		; Push the address of "  node: "
					;  string.
	CALLS	#1,G^LIB$PUT_SCREEN	; Output the message.
	JLBC	R0,99$			; Branch on error.
	ADDW	NODE_NAME_DSCR,R3	; Add length of node name to string
					;  length.
	PUSHAL	NODE_NAME_DSCR		; Push address of local nodename.
	CALLS	#1,G^LIB$PUT_SCREEN	; Output the nodename.
	JLBC	R0,99$			; Branch on error.
	MOVW	R3,DDM_SIZE		; Save size of display descriptor
					;  message.
99$:	POPR	#^M<R2,R3,R7,R10>
	RSB



	.SBTTL	-	Output the time
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by GET_HEADER to output the time on the
;	top line of the display.
;
;	If the size of the either the CLUSTER class header, the SCS class
;	header in the CLUSTER report, or the header for the LOCAL report
;	(depending on what's being displayed) is larger that the display
;	description message + 10, then the time is output along the right
;	hand border of the header.  If it's smaller, then the time is
;	output at the extreme right.  This is done to improve the appearance
;	of the display and to allow hardcopy output on 80 column paper without
;	cutting off the time.
;
;
; CALLING SEQUENCE:
;
;	JSB	OUTPUT_TIME
;
; CALLED BY:
;
;	GET_HEADER
;
; INPUTS:
;
;	DDM_SIZE contains the length of the display description message.
;	SCREEN_WIDTH contains the current width of the screen.
;	HEADER_SIZE, CLUB_HEADER_SIZE and SCS_HEADER_SIZE contain the
;	width of the header for the classes being displayed.
;
; OUTPUTS:
;
;	Time is output to the screen buffer.
;
; IMPLICIT OUTPUTS:
;
;	LINE_NUM is set to 1.
;
; RETURN STATUS:
;
;	R0 =	SS$_Normal or failed status from LIB$PUT_SCREEN.
;

OUTPUT_TIME:
	PUSHR	#^M<R2,R3,R4,R5>
	MOVL	#1,LINE_NUM		;
	ADDW3	#1,DDM_SIZE,COL_NUM	; Get number of column after display
					;  description message.
	MOVW	#1,LINE_NUM		; Time goes on line one.
	BBC	#RPT$V_CLSTR,-		; Branch if not displaying the cluster
		CURRENT_REPORT,10$	;  report.
	CMPL	SCS_HEADER_SIZE,-	; Use the larger header to determine
		CLUB_HEADER_SIZE	;  where the time should be output.
	BGTR	5$			; Branch if SCS is larger.
	MOVL	CLUB_HEADER_SIZE,R4	; Get the header size of the CLUB.
	BRB	20$			; Branch to common code.
5$:	MOVL	SCS_HEADER_SIZE,R4	; Get the header size of the SCS.
	BRB	20$			; Branch to common code.
10$:	MOVL	HEADER_SIZE,R4		; Get the header size for the local
					;  report.
;
; Determine how many spaces to output between the display discription message
; and the time based on the size on the header.  If it's less than 10, then
; output the time at the extreme right.
;

20$:	ADDW3	TIME_DSCR,DDM_SIZE,R2	; Get size of message + time.
	SUBW3	R2,R4,R3		; Get the number of columns to erase.
	CMPW	R3,#6			; Less than 6 blanks?
	BGEQ	40$			; Branch if not.
	BBS	#DVT$V_HARD,OUT_DEV,30$	; Branch if output is hardcopy.
	SUBW3	R2,SCREEN_WIDTH,R3	; Get the number of columns to erase.
	BRB	40$			; Branch to common code.
30$:	SUBW3	R2,#80,R3		; Get the number of columns to erase.
40$:	TSTL	R3			; Skip decrement if fill length is 0.
	BEQL	50$			;
	DECW	R3			; One less for aesthetics...
50$:	MOVW	R3,DATA_DSCR		; Use data descriptor for fill.
	MOVC5	#0,@DATA_DSCR+4,-	; Fill the descriptor with some spaces.
		#^A/ /,R3,@DATA_DSCR+4	;
	PUSHAW	COL_NUM			; Setup for LIB$PUT_SCREEN.
	PUSHAW	LINE_NUM		;
	PUSHAL	DATA_DSCR		; Output the spaces.
	CALLS	#3,G^LIB$PUT_SCREEN	;
	JLBC	R0,99$			; Branch on error.
	PUSHAL	TIME_DSCR		; Push address to store time.
	CALLS	#1,G^LIB$DATE_TIME	; Get the current date and time.
	BLBC	R0,99$			; Branch on error.
	PUSHAL	TIME_DSCR		;
	CALLS	#1,G^LIB$PUT_SCREEN	;
	BLBC	R0,99$			; Branch on error.
	CALLS	#0,G^LIB$ERASE_LINE	; Erase the rest of the line.
99$:	MOVL	#1,COL_NUM		; Restore column number.
	POPR	#^M<R2,R3,R4,R5>
	RSB



	.SBTTL		-	Box drawing routines.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds the descriptors for the lines which make up the
;	boxes surrounding the classes and titles in the display header and the
;	line following the last line of data in the report when the report is
;	run on a non-VT100 compatable terminal.
;
; CALLING SEQUENCE:
;
;	JSB	BUILD_VT52_BOX
;
; CALLED BY:
;
;	GET_HEADER
;
; OUTPUTS:
;	Data for line above and below the titles and the line following the
;	last line of data stored in FIELD_TOP_BOX_BUF_DSCR.
;	Data for line above and below the classes stored in CLASS_BOX_BUF_DSCR.
;
; RETURN STATUS:
;
;	None
;
; REGISTER USAGE:
;
;	R5 -	Pointer into TITLE_BUF
;	R6 -	Counter for the number of charcters in the buffers.
;	R7 -	Pointer into CLASS_BUF
;	R8 -	Pointer into CLASS_BOX_BUF
;	R9 -	Pointer into FIELD_TOP_BOX_BUF
;
;--

BUILD_VT52_BOX:
	PUSHR	#^M<R5,R6,R7,R8,R9>
	MOVAL	CLASS_BOX_BUF,R8	; Get address of buffer for line above
					;  the classes.
	MOVAL	FIELD_TOP_BOX_BUF,R9	; Get address of buffer for above and
					;  below field titles and last line.
	MOVZWL	TITLE_DSCR,R6		; Get the number of bytes in TITLE_BUF.
	MOVW	R6,FIELD_TOP_BOX_DSCR	; Save as the number of bytes in
					;  FIELD_BOX_BUF.
	MOVW	R6,CLASS_BOX_DSCR	; Save as the number of bytes in
					;  CLASS_BOX_BUF.
	MOVAL	CLASS_BUF,R7		; Get the address of the class buffer.
	MOVAL	TITLE_BUF,R5		; Get the address of the title buffer.
10$:	CMPB	(R7)+,#^A/|/		; Is this character a vertical bar?
	BNEQU	20$			; Branch if not.
	MOVB	#^A/+/,(R8)+		; Store a plus sign in the buffer.
	BRB	30$
20$:	MOVB	#^A/-/,(R8)+		; Store a minus sign in the buffer.
30$:	CMPB	(R5)+,#^A/|/		; Is this character a vertical bar?
	BNEQU	40$			; Branch if not.
	MOVB	#^A/+/,(R9)+		; Store a plus sign in the buffer.
	BRB	50$
40$:	MOVB	#^A/-/,(R9)+		; Store a minus sign in the buffer.
50$:	SOBGTR	R6,10$			; Loop for all characters.
	POPR	#^M<R5,R6,R7,R8,R9>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds the descriptors for the lines which make up the
;	boxes surrounding the classes and titles in the display header and the
;	line following the last line of data in the report when the report is
;	run on a VT100 compatable terminal.
;
; CALLING SEQUENCE:
;
;	JSB	BUILD_DECCRT_BOX
;
; CALLED BY:
;
;	GET_HEADER
;
; OUTPUTS:
;
;	Date for line above classes stored in CLASS_BOX_BUF.
;	Data for line above fields stored in FIELD_TOP_BOX_BUF.
;	Data for line below fields stored in FIELD_BOT_BOX_BUF.
;	Data for line below the last line of data stored in
;	LAST_LINE_BUF for SCS display or LAST_CLUB_LINE_BUF for
;	CLUB display.
;
; RETURN STATUS:
;
;	None.
;
; REGISTER USAGE:
;
;	R2 -	Pointer into CLASS_BOX_BUF.
;	R3 -	Pointer into FIELD_TOP_BOX_BUF.
;	R4 -	Pointer into FIELD_BOT_BOX_BUF.
;	R5 -	Pointer into LAST_LINE_BUF or LAST_CLUB_LINE_BOX.
;	R6 -	Counter for the number of characters in the buffers.
;	R7 -	Pointer into CLASS_BUF.
;	R8 -	Pointer into TITLE_BUF.
;--

BUILD_DECCRT_BOX:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8>
	MOVZWL	TITLE_DSCR,R6		; Get the number of bytes in TITLE_BUF.
	JEQL	60$			; Branch if nothing to display.
	MOVAL	CLASS_BOX_BUF,R2	; Get address of buffer for line above
					;  classes.
	MOVAL	FIELD_TOP_BOX_BUF,R3	; Get address of buffer for line above
					;  fields.
	MOVAL	FIELD_BOT_BOX_BUF,R4	; Get address of buffer for line below
					;  fields.
	BBC	#CLS$V_CLUB,-		; Branch if not displaying the CLUSTER
		CLASS_SELECT,5$		;  class.
	MOVAL	LAST_CLUB_LINE_BUF,R5	; Get address of buffer for line below
					;  the last data line of CLUB display.
	BRB	6$			; Branch to common code.
5$:	MOVAL	LAST_LINE_BUF,R5	; Get address of buffer for line below
					;  the last data line of SCS display.
6$:	MOVAL	CLASS_BUF,R7		; Get address of buffer for class
					;  names.
	MOVAL	TITLE_BUF,R8		; Get address of buffer for field
					;  names.
	MOVZWL	TITLE_DSCR,R6		; Get the number of bytes in TITLE_BUF.
	MOVB	#GRAPHICS_ON,(R2)+	; Store character to turn on graphics in
	MOVB	#GRAPHICS_ON,(R3)+	;  each of the buffers.
	MOVB	#GRAPHICS_ON,(R4)+	;
	MOVB	#GRAPHICS_ON,(R5)+	;
	BBS	#SCR$V_MORE_LFT,-	; Branch if screen has been scrolled
		SCROLL_FLAGS,10$	;  left.
	MOVB	#UL_CORNER,(R2)+	; Store upper-left corner.
	MOVB	#LEFT_T,(R3)+		; Store left "T".
	MOVB	#LEFT_T,(R4)+		; Store left "T".
	MOVB	#LL_CORNER,(R5)+	; Store lower-left corner.
	ADDL	#DELM_DSCR_LEN,R7	; Ignore first character in CLASS_BUF
	ADDL	#DELM_DSCR_LEN,R8	;  and FIELD_BUF. (assumed a "|").
	SUBL	#DELM_DSCR_LEN,R6	; Decrement number of bytes remaining.
10$:	CMPB	#GRAPHICS_ON,(R8)+	; Is there a field delimiter in
					;  FIELD_BUF?
	BNEQU	30$			; Branch if not.
	ADDL	#DELM_DSCR_LEN-1,R8	; Update pointer into FIELD_BUF.
	SUBL	#DELM_DSCR_LEN-1,R6	; Update counter.
	MOVB	#CROSS,(R4)+		; Store crossing lines in
					;  FIELD_BOT_BOX_BUF.
	MOVB	#BOTTOM_T,(R5)+		; Store a bottom "T" in LAST_LINE_BUF.
	CMPB	#GRAPHICS_ON,(R7)+	; Is there an escape sequence in
					;  CLASS_BUF?
	BNEQU	20$			; Branch if not.
	MOVB	#CROSS,(R3)+		; Store crossing lines in
					;  FIELD_TOP_BOX_BUF.
	MOVB	#TOP_T,(R2)+		; Store a top "T" in CLASS_BOX_BUF.
	ADDL	#DELM_DSCR_LEN-1,R7	; Update pointer in CLASS_BUF.
	BRB	40$			; Join common code.

20$:	MOVB	#TOP_T,(R3)+		; Store a top "T" in FIELD_TOP_BOX_BUF.
	MOVB	#SCAN_5,(R2)+		; Store a horizontal line - scan 5 in
					;  CLASS_BOX_BUF.
	BRB	40$			; Join common code.

30$:	MOVB	#SCAN_5,(R2)+		; Store a horizontal line - scan 5 in
					;  CLASS_BOX_BUF...
	MOVB	#SCAN_5,(R3)+		;   in FIELD_TOP_BOX_BUF...
	MOVB	#SCAN_5,(R4)+		;   in FIELD_BOT_BOX_BUF...
	MOVB	#SCAN_5,(R5)+		;   and in LAST_LINE_BUF.
	INCL	R7			; Update pointer into CLASS_BUF.
40$:	SOBGTR	R6,10$			; Loop for all bytes in CLASS_BUF.
	DECL	R2			; Now that we know we've hit the end
	DECL	R3			;  backup one character in each buffer
	DECL	R4			;  and fix the last character on the
	DECL	R5			;  line.
	MOVW	#<GRAPHICS_OFF@8>!UR_CORNER,-
		(R2)+			; Store an upper-right corner followed
					;   by character to turn graphics off in
					;  CLASS_BOX_BUF.
	MOVW	#<GRAPHICS_OFF@8>!RIGHT_T,-
		(R3)+			; Store a right "T" followed by
					;  character to turn graphics off
					;  in FIELD_TOP_BOX_BUF.
	MOVW	#<GRAPHICS_OFF@8>!RIGHT_T,-
		(R4)+			; Store a right "T" followed by
					;  character to turn graphics off in
					;  FIELD_BOT_BOX_BUF.
	MOVW	#<GRAPHICS_OFF@8>!LR_CORNER,-
		(R5)+			; Store a lower-right corner followed
					;  by character to turn graphics off in
					;  LAST_LINE_BUF.

	SUBL3	CLASS_BOX_DSCR+4,R2,-	; Save the number of characters stored
		CLASS_BOX_DSCR		;  in CLASS_BOX_BUF.
	SUBL3	FIELD_TOP_BOX_DSCR+4,-	; Save the number of characters stored
		R3,FIELD_TOP_BOX_DSCR	;  in FIELD_TOP_BOX_BUF.
	SUBL3	FIELD_BOT_BOX_DSCR+4,-	; Save the number of characters stored
		R4,FIELD_BOT_BOX_DSCR	;  in FIELD_BOT_BOX_BUF.
	BBC	#CLS$V_CLUB,-		; Branch if not displaying the CLUSTER
		CLASS_SELECT,50$	;  class.
	SUBL3	LAST_CLUB_LINE_DSCR+4,-	; Save the number of characters stored
		R5,LAST_CLUB_LINE_DSCR	;  in LAST_CLUB_LINE_BUF.
	BRB	70$			; Branch to common code.
50$:	SUBL3	LAST_LINE_DSCR+4,R5,-	; Save the number of characters stored
		LAST_LINE_DSCR		;  in LAST_LINE_BUF.
	BRB	70$			; Branch to common code.

60$:	CLRL	CLASS_BOX_DSCR		; Nothing to display, so clear length in
	CLRL	FIELD_TOP_BOX_DSCR	;  all descriptors.
	CLRL	FIELD_BOT_BOX_DSCR	;
	BBC	#CLS$V_CLUB,-		; Branch if not displaying the CLUSTER
		CLASS_SELECT,65$	;  class.
	CLRL	LAST_CLUB_LINE_DSCR	;
	BRB	70$			; Branch to common code.
65$:	CLRL	LAST_LINE_DSCR		;
70$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8>
	RSB



	.SBTTL		-	DRAW_LAST_LINE

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to output the line immediately following the
;	data, i.e., the bottom line of the display box.
;
; CALLING SEQUENCE:
;
;	JSB	DRAW_LAST_LINE
;
; CALLED BY:
;
;	DISPLAY_CLUB
;	DISPLAY_COMMON
;	GET_HELP
;
; INPUTS:
;
;	LAST_LINE_DSCR or LAST_CLUB_LINE_DSCR filled in for DECcrts.
;	FIELD_TOP_BOX_DSCR filled in if not DECcrt.
;
; OUTPUTS:
;
;	One line output to SCREEN_BUFFER.
;
; RETURN STATUS:
;
;	R0 = Status returned form DRAW_LINE routine.
;
; REGISTER USAGE:
;
;	R11 points to descriptor for the line to be output.
;
;--

DRAW_LAST_LINE:
	PUSHR	#^M<R11>
	BBC	#DVT$V_DCRT,OUT_DEV,30$	; Branch if output device isn't a
					;  DECcrt terminal.
	BBC	#RPT$V_CLSTR,-		; Branch if not displaying the Cluster
		CURRENT_REPORT,20$	;  report.
	BBC	#CLS$V_CLUB,-		; Branch if not displaying the CLUSTER
		CLASS_SELECT,10$	;  class.
	MOVAL	LAST_CLUB_LINE_DSCR,R11	; Point to descriptor for last line
					;  of CLUB display.
	MOVL	CLUB_HEADER_SIZE,-	; Get size of CLUB header.
		HEADER_SIZE		;
	BRB	40$			; Branch to common code.
10$:	MOVL	SCS_HEADER_SIZE,-	; Get size of SCS header.
		HEADER_SIZE		;
20$:	MOVAL	LAST_LINE_DSCR,R11	; Point to descriptor for last line
					;  of SCS display.
	BRB	40$			; Jump to common code.
30$:	MOVAL	FIELD_TOP_BOX_DSCR,R11	; Point to descriptor for line below
					;  the field names.
40$:	BSBW	DRAW_LINE		; Output the last line.
	POPR	#^M<R11>
	RSB



	.SBTTL		-	Field title generation.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine scans the field descriptor bit map to determine which
;	fields will be displayed.  If a field is to be displayed, then its
;	title is added to the title buffer along with the appropriate
;	delimiters and spaces so that the title is centered in the field.
;	The scan continues until the entire bit map is checked, or the title
;	buffer is full.
;
; CALLING SEQUENCE:
;
;	JSB	GET_TITLES
;
; CALLED BY:
;
;	GET_HEADER
;
; OUTPUTS:
;
;	Field titles are output to TITLE_BUF.  Descriptor for the title is
;	built at TITLE_DSCR.
;
; RETURN STATUS:
;
;	R0 = SS$_NORNAL
;
; REGISTER USAGE:
;
;	R2 -	Used to determine when the located title is in a different
;		class than the previously located title.
;	R3 -	Points to the next free byte in the title buffer.
;	R6 -	Number of character positions left on the line before the
;		screen line overflows.
;	R7 -	Used to hold the size of the current display field.
;	R9 -	Used to calculate the number of spaces needed to center the
;		title in the field.
;	R10 -	Points to the start of the current field descriptor entry.
;		(From FIND_ENTRY routine)
;
;--

GET_TITLES:
	PUSHR	#^M<R2,R3,R6,R7,R9,R10>
	CLRB	NUM_FIELDS		; Initialize number of fields found.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,3$	;  cluster report.
	MOVL	CLSTR_H_SCROLL,-	; Get a copy of the scroll value for the
		H_SCROLL_LINE		;  cluster report.
	BRB	4$			; Branch to common code.
3$:	MOVL	LOCAL_H_SCROLL,-	; Get a copy of the scroll value for the
		H_SCROLL_LINE		;  local report.
4$:	MOVAL	TITLE_LEN_ARRAY,R3	; Set length of titles to 0.
	PUSHR	#^M<R2,R4,R5>		;
	MOVC5	#0,(R3),#0,-		;
		#4*NUM_CLASSES,(R3)	;
	POPR	#^M<R2,R4,R5>		;
	CLRL	TITLE_DSCR		; Set length of buffer to 0.
	CLRL	HEADER_SIZE		; Set width of header to 0.
	MOVAL	TITLE_BUF,R3		; Get pointer to title buffer.
	MOVL	R3,TITLE_START		; Save address of start of titles.
	MOVZWL	SCREEN_WIDTH,R6		; Get screen width.
	BBS	#SCR$V_MORE_LFT,-	; Branch if screen has been scrolled
		SCROLL_FLAGS,5$		;  left.
	BSBW	DELM			; Start line with field delimiter.
	INCL	HEADER_SIZE		; Header size = 1.
5$:	MOVL	R6,TITLE_COUNT		; Save the number of bytes remaining on
					;  the line.
	CLRL	START_BIT		; Start scanning the field descriptor
					;  bitmap at bit zero.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,7$	;  cluster report.
	MOVL	#CLUSTER_MAP_LEN,MAP_LEN; Save length of cluster bitmap.
	BRB	10$			; Jump to common code.
7$:	MOVL	#LOCAL_MAP_LEN,MAP_LEN	; Save length of local bitmap.
10$:	BSBW	FIND_ENTRY		; Locate a field to be displayed.
	BLBC	R0,80$			; Branch if field wasn't found.
	INCB	NUM_FIELDS		; Increment number of fields found.
20$:	BICL3	FD$L_CLASS(R10),-	; Is this field in a different class?
		CURRENT_CLASS,R2	;
	BEQL	30$			; Branch if not.
	BSB	SAVE_TITLE_LEN		; Save length of the class title.
30$:	BITL	FD$L_CLASS(R10),-	; Is this class enabled?
		CLASS_SELECT		;
	BEQLU	10$			; Branch if not.
	BSBW	ADD_ONE_SPACE		; Preceed title with atleast one space.
	BLSSU	70$			; Branch if it won't fit.
	SUBB3	FD$B_TITLE_SIZE(R10),-	; Get the difference between the number
		FD$B_FIELD_SIZE(R10),R9	; of characters in the title and the
					;  size of the field.
	BGEQ	40$			; Branch if field size is larger than
					;  the title.
	CLRB	R9			; Number of spaces needed before and
					;  after the title equals zero.
40$:	MOVZBL	R9,R9			; Make R9 a longword.
	ROTL	#-1,R9,R9		; Calculate the number of spaces to
					;  center the title.
	BSBW	ADD_SPACES		; Add the spaces to the buffer.
	BLSSU	70$			; Branch if the spaces won't fit on the
					;  screen.
	BBC	#31,R9,50$		; Branch if even number of spaces.
	BSBW	ADD_ONE_SPACE		; Otherwise, add one more.
50$:	BLSSU	70$			; Branch if the won't fit.
	MOVZBL	FD$B_TITLE_SIZE(R10),R7	; Assume the full title will fit in the
					;  field.
	CMPB	R7,FD$B_FIELD_SIZE(R10)	; Will it really fit?
	BLEQ	60$			; Branch if it will
	MOVZBL	FD$B_FIELD_SIZE(R10),R7	; Get the size of the field.
60$:	PUSHR	#^M<R2,R4,R5>
	MOVC3	R7,FD$T_TITLE(R10),(R3)	; Copy title to title buffer.
	POPR	#^M<R2,R4,R5>
	SUBB	R7,R6			; Calculate room left on screen.
	BLSSU	70$			; Branch if it didn't fit.
	BSBW	ADD_SPACES		; Add spaces following the title.
	BLSSU	70$			; Branch if the spaces won't fit on the
					;  screen.
	BSBW	ADD_ONE_SPACE		; Follow title with one space.
	BLSSU	70$			; Branch if it didn't fit.
	BSBW	DELM			; Add ending delimiter to line.
	BGEQU	10$			; Loop if there's more room on the
					;  line.
70$:	CLRL	R6			; Number of columns remaining equals
					;  zero.
80$:	BSB	SAVE_TITLE_LEN		; Save the length of the titles.
	MOVL	#SS$_NORMAL,R0		; Indicate success.
	POPR	#^M<R2,R3,R6,R7,R9,R10>
	RSB				; Return.



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to save the total number of columns used by all the
;	titles in a particular class that are to be displayed.  This number is
;	used by the GET_CLASSES routine to center the classes.  This routine
;	also saves the total number of columns that will be used by the report.
;	Note that this routine is called whenever a title to be displayed has
;	been found that is in a different class than the previously found title
;	or when the last title to be displayed has been found.
;
; CALLING SEQUENCE:
;
;	JSB	SAVE_TITLE_LEN
;
; CALLED BY:
;
;	GET_TITLES
;
; INPUTS:
;
;	R3 points to the address following the last byte stored in the title
;	buffer.
;	R6 contains the number of characters that can be added to the title
;	buffer before the number of characters in the buffer exceeds the width
;	of the screen.
;
; IMPLICIT INPUTS:
;
;	TITLE_COUNT = Number of characters that can be added to the title
;		as saved from a previous call to this rouine.  TITLE_COUNT
;		is initially set to the screen width by GET_TITLES.
;	TITLE_START = Address in the title buffer where the last group of
;		titles begins as saved from a previous call to this routine.
;		TITLE_START initially points to the start of the title buffer.
;
; OUTPUTS:
;
;	HEADER_SIZE updated to reflect the width of the report in characters.
;
; IMPLICIT OUTPUTS:
;
;	TITLE_COUNT updated.
;	TITLE_START updated.
;
; RETURN STATUS:
;
;	None.
;
; REGISTER USAGE:
;
;	R2 -	Used to index into an array containing the lengths of the
;		titles in each of the classes.
;	R4 -	Used to point to the base address of the array.
;	R3,R5 -	Used to calculate the number of bytes stored in the title
;		buffer.
;
;--

SAVE_TITLE_LEN:
	PUSHR	#^M<R2,R4,R5>
	FFS	#0,#NUM_CLASSES,-	; Convert class bit to index value.
		CURRENT_CLASS,R2	;
	MOVAL	TITLE_LEN_ARRAY,R4	; Get address of title length array.
	SUBL3	R6,TITLE_COUNT,(R4)[R2]	; Save length of titles in characters.
	ADDL	(R4)[R2],HEADER_SIZE	; Add to total size of header in
					;  characters	
	SUBL3	TITLE_START,R3,R5	; Get actual length of titles in bytes.
	ADDL	R5,TITLE_DSCR		; Add length to total length of titles.
	BLBC	R0,10$			; Skip following if FIND_ENTRY failed.
	MOVL	R6,TITLE_COUNT		; Save number of bytes remaining.
	MOVL	R3,TITLE_START		; Save starting address for next set of
					;  titles.
	MOVL	FD$L_CLASS(R10),-	; Set new class to current class.
		CURRENT_CLASS		;
10$:	POPR	#^M<R2,R4,R5>
	RSB



	.SBTTL		-	Class title generation.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine stores the class titles in CLASS_BUF for the GET_HEADER
;	routine.  The class titles are stored with the appropriate field
;	delimiters and spacing such that the class titles will be displayed
;	centered above the field titles. 
;
;
; CALLING SEQUENCE:
;
;	JSB	GET_CLASSES
;
; CALLED BY:
;
;	GET_HEADER
;
; OUTPUTS:
;
;	Clases are stored in CLASS_BUF.
; 
; RETURN STATUS:
;
;	R0 =	SS$_Normal.
;
;
; REGISTER USAGE:
;
;	R3 -	Points to next free character position in CLASS_BUF.
;	R4 -	Used to calculate the number of leading spaces to precede the
;		class title.
;	R5 -	Used as a pointer into the class name strings.
;	R6 -	Used to calculate the number of trailing spaces to follow the
;		class title.
;	R7 -	Points to descriptor containing the class name.
;	R8 -	Used to calculate the number of spaces needed to center the
;		class name.
;	R9 -	Used to calculate the number of spaces needed to center the
;		class name.
;
;	R11-	Used to index into the title length array.
;
;--

GET_CLASSES:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R11>
	CLRL	R11			; Set counter to 0
	MOVAL	CLASS_BUF,R3		; Get address of class buffer.
	MOVZWL	SCREEN_WIDTH,R6		; Get screen width.
	MOVAL	TITLE_LEN_ARRAY,R7	; Get address of title length array.
	MOVAL	CLASS_NAMES,R5		; Get address of class descriptors.
	MOVZBL	(R5)+,R4		; Get number of bytes in first string.
	BBS	#SCR$V_MORE_LFT,-	; Branch if screen has been scrolled
		SCROLL_FLAGS,2$		;  left.
	BSBW	DELM			; Add starting delimiter to line.
2$:	BLSSU	20$			; Branch if it won't fit on the line.
	MOVL	CLASS_SELECT,R2		; Get mask of classes to be displayed.
3$:	CMPZV	R11,#1,R2,#0		; Check if class is enabled.
	BNEQ	5$			; Branch if so.
4$:	MOVZBL	-1(R5),R4		; Get number of bytes
	ADDL	R4,R5			; Point to next class string.
	MOVZBL	(R5)+,R4		; Get number of bytes in string.
	ACBL	#CLS$V_ERR,#1,R11,3$	; Branch if there's more classes to
	BRW	20$			;  check.
5$:	MOVL	(R7)[R11],R8		; Get length of the titles for this
					;  class.
	DECL	R8			; Subtract one for the delimeter.
	BLSS	4$			; Branch if no titles being displayed.
	SUBL3	R4,R8,R9		; Calculate the number of spaces
					;  to appear before and after the
					;  class name.
	BGTR	6$			; Branch if more characters in the
					;  titles than in the class name.
	CLRL	R9			; Otherwise, no leading or trailing
					;  spaces around the class name.
	MOVL	R8,R4			; Make length of class same as titles.
6$:	ROTL	#-1,R9,R9		; Calculate the number of leading
					;  spaces to appear before the class
					;  type in order to center it.
	BSBW	ADD_SPACES		; Add leading spaces.
	BLSSU	20$			; Branch if the spaces won't fit on the
					;  screen.
	BBCC	#31,R9,10$		; Branch if even number of spaces.
	BSBW	ADD_ONE_SPACE		; Add one more space.
	BLSSU	20$			; Branch if it won't fit.
10$:	PUSHR	#^M<R2,R4,R5>
	MOVC3	R4,(R5),(R3)		; Add class type.
	POPR	#^M<R2,R4,R5>
	BSBW	ADD_SPACES		; Add trailing spaces.
	BLSSU	20$			; Branch if the spaces won't fit on the
					;  screen.
	BSBW	DELM			; Add ending delimiter.
	BLSSU	20$			; Branch if it won't fit.
17$:	CMPW	R6,SCREEN_WIDTH		; Will classes fit on the screen?
	JLEQU	4$			; Branch if they will.
20$:	SUBL3	#CLASS_BUF,R3,CLASS_DSCR; Save length of buffer.
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R11>
	RSB



	.SBTTL	REFRESH routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine causes the display header, which is not normally redraw on
;	each update, to be redraw.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,REFRESH
;
; CALLED BY:
;
;	READ_LOOP
;	READ_WO_PROMPT
;	SHOW_CLUSTER
;	SHOW_LOCAL
;	ADD_FIELD
;	REM_FIELD
;	INCLUDE_CLASS
;	EXCLUDE_CLASS
;	SET_WIDTH
;	SET_SCREEN
;
; OUTPUTS:
;
;	RIP (Refresh in Progress) flag set at MISC_FLAGS.
;
;--

.ENTRY	REFRESH,^M<R2>
	JBS	#MF$V_IN_OPEN,-		; Skip refresh if executing from a
		MISC_FLAGS,99$		;  command procedure.
	CLRB	SWITCH			; Initialize switch count.
	BISL	#MF$M_RIP,MISC_FLAGS	; Indicate refresh in progress.
99$:	RET



	.SBTTL	FIND_ENTRY routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to scan one of the class bitmaps for a set bit,
;	indicating that a field is to be displayed.  It returns the address
;	of the field descriptor to the calling routine. 
;
;	This routine also performs the horizontal scrolling by ignoring the
;	first entries found as determined by the value stored in H_SCROLL_LINE.
;
; CALLING SEQUENCE:
;
;	JSB	FIND_ENTRY
;
; CALLED BY:
;
; 	GET_TITLES
;	GET_DATA
;	ADD_FIELD
;
; IMPLICIT INPUTS:
;
;	ADRS_TABLE -	Contains the address of the table of entry addresses.
;	BITMAP_ADRS -	Contains the address of bitmap to be searched.
;	MAP_LEN -	Contains the length of the bitmap.
;	START_BIT -	Contains the number of the bit in the bitmap to start
;			the search.
;			 (Should be zero on the first call to this routine.)
;	H_SCROLL_LINE	Set to the number of entries to skip before success is
;			returned.
;
; OUTPUTS:
;
;	R10 =	Address of field descriptor.
;
; IMPLICIT OUTPUTS:
;
;	START_BIT updated to point to next bit to be checked.
;	MAP_LEN	  updated to indicate the remaining length of the bitmap.
;
; RETURN STATUS:
;
;	R0 =	SS$_Normal if an entry is found.
;
; REGISTER USAGE:
;
;	R6  -	Pointer into the address table for the report.
;	R7  -	Pointer into the bitmap for the report.
;	R9  -	Used to determine the starting bit in the longword to scan.
;	R10 -	Used to determine the number of bits left to scan in the
;		longword.
;	    -	Receives the address of the field descriptor once a entry has
;		been found.
;--

FIND_ENTRY:
	PUSHR	#^M<R6,R7,R8,R9>
	CLRL	R0			; Assume failure.
	MOVL	ADRS_TABLE,R6		; Get address of address table.
	MOVL	BITMAP_ADRS,R7		; Get address of bitmap.
5$:	MOVL	START_BIT,R9		; Get the starting bit position.
	CLRL	R10			; Dividend must be a quadword.
	EDIV	#32,R9,R1,R10		; Calculate the number of bits left to 
	SUBL3	R10,#32,R10		;  scan in the longword.
	FFS	R9,R10,(R7),R9		; Scan for a set bit.
	BNEQ	20$			; Branch if found in this longword.
	CMPL	R1,MAP_LEN		; Any more map left to scan?
	BEQL	99$			; Branch if not.
	MOVL	R9,START_BIT		; Save starting bit for next longword.
	BRB	5$			; Scan next longword.
20$:	MOVL	(R6)[R9],R10		; Get the address from the table.
	ADDL3	#1,R9,START_BIT		; Save starting bit for next
					;  call to FIND_ENTRY.
	BITL	FD$L_CLASS(R10),-	; Is this entry in a selected class?
		CLASS_SELECT		;
	BEQLU	5$			; Branch if not.
	TSTL	H_SCROLL_LINE		; Is this field scrolled off the left of
					;  the screen?
	BLSS	30$			; Branch if not.
	DECL	H_SCROLL_LINE		; Count down the number of fields to be
					;   ignored.
	BGEQ	5$			; Ignore this field.
30$:	MOVL	#SS$_NORMAL,R0		; Indicate success.
99$:	POPR	#^M<R6,R7,R8,R9>	; 
	RSB				; 



	.SBTTL	Miscellaneous routines.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to clear the terminal's screen.
;
; CALLING SEQUENCE:
;
;	JSB	CLEAR_SCREEN
;
; CALLED BY:
;
;	MAIN_ERR
;	SHOW_CLUSTER
;	SHOW_LOCAL
;
; IMPLICIT OUTPUTS:
;
;	COL_NUM (column number) and LINE_NUM (line number) are set to 1
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL or failing status from SRCPKG routine.
;
;
;--

CLEAR_SCREEN:
	MOVL	#SS$_NORMAL,R0		; Assume success.
	MOVL	#1,COL_NUM		; Start at column 1
	MOVL	#1,LINE_NUM		;  and line 1.
	BBS	#DVT$V_HARD,OUT_DEV,99$	; Skip if output is hardcopy device.
	PUSHAW	COL_NUM			; Clear the screen.
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$ERASE_PAGE	;
99$:	RSB				; Return with status.



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routines to erase one or two lines on the terminal.
;
; CALLING SEQUENCE:
;
;	JSB	ERASE_LINE
;	JSB	ERASE_TWO_LINES
;
; CALLED BY:
;
;	ERASE_PAGE
;	DRAW_LINE
;
;	READ_WO_PROMPT
;	DISPLAY_PTP
;
; IMPLICIT OUTPUTS:
;
;	LINE_NUM (line number) is incremented.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL or failing status from SRCPKG routine.
;
;
;--
	.ENABL	LSB

ERASE_TWO_LINES:
	BSB	ERASE_LINE		; Erase a line.
	BLBC	R0,99$			; Branch on error.

ERASE_LINE:
	MOVL	#SS$_NORMAL,R0		; Assume success.
	PUSHAW	COL_NUM			; Erase the line
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$ERASE_LINE	;
	INCL	LINE_NUM		; Bump line number.
99$:	RSB				; Return with status.

	.DSABL	LSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	The following routine adds a control string to a line of data to
;	 indicate the start, and end of fields in the data line.
;
; CALLING SEQUENCE:
;
;	JSB	DELM
;
; CALLED BY:
;
;	GET_TITLES
;	GET_CLASSES
;
; INPUTS:
;
;	R3 -	Address of the next free character position in the buffer
;	R6 -	Number of bytes that can be added to the buffer before its
;		length exceeds that of the screen line.
;
; OUTPUTS:
;
;	R3 -	Next free position in the buffer.
;	R6 -	Updated number of bytes that can be added to the buffer before
;		its length exceeds that of the screen line.
;
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL.
;
;--

DELM:
	PUSHR	#^M<R2,R4,R5>
	BBS	#DVT$V_DCRT,OUT_DEV,10$	; Branch if terminal is a DECcrt.
	MOVB	#^A/|/,(R3)+		; Store a VT52 vertical bar "|".
	BRB	20$			; Jump to common code.
10$:	MOVC3	DELM_DSCR,DELM_DSCR+8,-	; Store a DECcrt vertical bar.
		(R3)			;
20$:	DECL	R6			; Subtract the length of the string
					;  in characters as it will appear on
					;  the screen.
	POPR	#^M<R2,R4,R5>
	MOVL	#SS$_NORMAL,R0
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine adds a single space to a buffer at the location pointed to
;	by R3.
;
; CALLING SEQUENCE:
;
;	JSB	ADD_ONE_SPACE
;
; CALLED BY:
;
;	GET_TITLES
;	GET_CLASSES
;
; INPUTS:
;
;	R3 -	Points to the next free position in the buffer.
;	R6 -	Contains the number of characters that can be output to the
;		buffer before the number of characters in the buffer exceeds
;		the width of the screen.
;
; OUTPUTS:
;
;	Single space stored in buffer pointed to by R3.
;
; IMPLICIT OUTPUTS:
;
;	R3 and R6 updated
;
; RETURN STATUS:
;
;	None.
;
;--

ADD_ONE_SPACE:
	MOVB	#^A/ /,(R3)+		; Add one space to the buffer.
	DECL	R6			; Decrease room left on display line.
	RSB
	

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine adds a number of spaces to a buffer by recusively calling
;	ADD_ONE_SPACE.
;
; CALLING SEQUENCE:
;
;	JSB	ADD_SPACES
;
; CALLED BY:
;
;	GET_TITLES
;	GET_CLASSES
;
; INPUTS:
;
;	R9 -	Number of spaces to output.
;	R3 -	Points to the next free position in the buffer.
;	R6 -	Contains the number of characters that can be output to the
;		buffer before the number of characters in the buffer exceeds
;		the width of the screen.
;
; OUTPUTS:
;
;	Spaces stored in buffer pointed to by R3.
;
; IMPLICIT OUTPUTS:
;
;	R3 and R6 updated
;
; RETURN STATUS:
;
;	None.
;
;--

ADD_SPACES:
	PUSHR	#^M<R9>
	TSTB	R9			; Any spaces to be output?
	BNEQ	10$			; Branch if so.
	MOVL	#1,R9			; Otherwise clear zero flag.
	BRB	99$			; And return.
10$:	BSB	ADD_ONE_SPACE		; Output one space.
	BLSSU	99$			; Return if there's no more room on the
					;  line.
	DECB	R9			; Count down the number of spaces to
					;  output.
	BNEQ	10$			; Loop till all spaces are output.
	MOVL	#1,R9			; Clear zero flag.
99$:	POPR	#^M<R9>
	RSB
	


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine outputs a line to the screen buffer.  If the line causes
;	the screen buffer to overflow then the screen buffer is output to the
;	screen and the line output retried. 
;
;	This routine also handles the case where the output line is longer than
;	the width of the screen by outputing a trunction character at the end
;	of the line.  The truncation character is either a block or a diamond
;	shape depending on terminal type. 
;
; CALLING SEQUENCE:
;
;	JSB	DRAW_LINE
;
; CALLED BY:
;
;	DRAW_LAST_LINE
;	GET_HEADER
;	GET_DATA
;
; INPUTS:
;
;	Address of output line descriptor in R11.
;
; IMPLICIT OUTPUTS:
;
;	LINE_NUM = LINE_NUM + 1
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL.
;
;--

DRAW_LINE:
	PUSHAW	COL_NUM			; Output the line to the screen buffer.
	PUSHAW	LINE_NUM		;
	PUSHL	R11			;
	CALLS	#3,G^LIB$PUT_SCREEN	;
	BLBS	R0,10$			; Branch if no error.
	CALLS	#0,G^LIB$PUT_BUFFER	; Output the screen buffer to the
					;  screen.
	JLBC	R0,99$			; Branch on error.
	BRB	DRAW_LINE		; Try outputing the line again.
10$:	ADDW3	HEADER_SIZE,#1,COL_NUM	; Erase the remainer of the line.
	BSBW	ERASE_LINE		;
	JLBC	R0,99$			; Branch on error.
	CMPW	COL_NUM,SCREEN_WIDTH	; Does the line fit on the screen?
	BGTR	20$			; Branch if not.
	BICB	#SCR$M_MORE_RT,-	; Clear the flag that indicates that
		SCROLL_FLAGS		;  there is more data off the right of
					;  the screen.
	BITB	#<SCR$M_MORE_LFT!-	; Are any of the other scroll flags
		SCR$M_MORE_UP!-		;  set?
		SCR$M_MORE_DWN>,-	;
		SCROLL_FLAGS		;
	BNEQ	40$			; Branch if not.
	BICB	#SCR$M_MORE,SCROLL_FLAGS; Otherwise, be sure to clear the
					;  scroll summary flag.
	BRB	40$			; Jump to common.
20$:	BISB	#SCR$M_MORE_RT!SCR$M_MORE,-; Set the scroll flag to indicate
		SCROLL_FLAGS		;  that there is more data off the
					;  right of the screen.
40$:	BBS	#MF$V_CONT,MISC_FLAGS,-	; Branch if continuous display.
		99$
	BBC	#DVT$V_DCRT,OUT_DEV,99$	; Branch if terminal isn't a DECcrt.
	CMPL	LINE_NUM,LAST_DATA_LINE	; Have we hit the bottom?
	BNEQ	99$			; Branch if not.
	BSBW	SET_REGION_DATA		; Set scrolling region to include only
					;  the data area of the screen.
	PUSHAW	COL_NUM			; Set cursor back to last line.
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$SET_CURSOR	;
	BLBC	R0,99$			; Branch on error.
	CALLS	#0,G^LIB$UP_SCROLL	; Scroll up one line.
	BLBC	R0,99$			; Branch on error.
	BSBW	SET_REGION_FULL		; Reset the scrolling region to use the
					;  full screen.
	DECL	LINE_NUM		; Adjust line number.
99$:	MOVL	#1,COL_NUM		; Reset column counter to first column.
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to get a line of data with all the fields filled
;	with spaces.  This is done by disabling the display of all classes and
;	calling the GET_DATA routine.
;
; CALLING SEQUENCE:
;
;	JSB	GET_BLANK
;
; CALLED BY:
;
;	CLUSTER_REPORT
;
; OUTPUTS:
;
;	One line of data output to the screen buffer.
;
; RETURN STATUS:
;
;	None.
;
; REGISTER USAGE:
;
;	R4 -	Used to save a mask of currently enabled classes.
;
;--

GET_BLANK:
	BBSS	LINE_NUM,BLANK_LINES,10$; Indicate that this is a blank line.
	BBS	#MF$V_RIP,MISC_FLAGS,20$; If refresh in progress, make sure
					;  we draw all the lines.
10$:	BBC	LINE_NUM,-		; Branch this line wasn't blank
	PRIOR_BLANK_LINES,20$		;  during the last pass.
	INCL	LINE_NUM		; Otherwise just bump the line number.
	BRB	99$			; And finish up.
20$:	PUSHL	DATA_CNTRL		; Save a copy of the current classes.
	CLRL	DATA_CNTRL		; Disable all classes.
	CALLS	#0,GET_DATA		; Get blank line of data.
	BLBC	R0,99$			; Branch on error.
	POPL	DATA_CNTRL		; Reenable classes.
99$:	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine simply calls the cluster display set up routine if
;	the local ports report is being displayed or it calls the local port
;	display set up routine if the cluster report is being displayed.
;
; CALLING SEQUENCE:
;
;	JSB	SWITCH_DISPLAY
;
; CALLED BY:
;
;
;--

SWITCH_DISPLAY:

	BBS	#RPT$V_CLSTR,-		; Branch if we're displaying the
		CURRENT_REPORT,10$	;  cluster report.
	CALLS	#0,SHOW_CLUSTER		; Display the cluster report.
	BRB	99$			; Jump to common code.
10$:	CALLS	#0,SHOW_LOCAL		; Display the local report.
99$:	RSB



	.SBTTL	Data formatting routines.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine formats the display data for the GET_DATA routine.  It
;	returns the formatted data in FORMAT_BUF and the number of characters
;	worth of display data in FORMAT_BUF_LEN.
;
;	The field descriptor parameter FD$B_FORMAT determines if the routine
;	will format the output in ascii, hexadecimal, or decimal.  Up to a
;	quadword of data can be formatted in decimal.  Ascii and hexadecimal
;	formatting has no restrictions.
;
; CALLING SEQUENCE:
;
;	JSB	FORMAT_DATA
;
; CALLED BY:
;
;	DISPLAY_PTP
;	OUTPUT_DDM
;	GET_DATA
;	DISPLAY_FIELD
;	DISPLAY_STRING
;	DISPLAY_CIRCUITS
;	DISPLAY_INCN_TIME
;	DISPLAY_PROC_NAME
;	DISPLAY_PORT_STATUS
;	DISPLAY_PORT_TYPE
;
; INPUTS:
;
;	R10	= Address of field descriptor.
;
; OUTPUTS:
;
;	Formated data string returned in FORMAT_BUF.
;	Length of formatted data string returned in FORMAT_BUF_LEN.
;
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status.
;
;
; REGISTER USAGE:
;
;	R3 -	Points to the next free position in FORMAT_BUF where the
;		the conversion is temporarily stored.
;	R5 -	Contains the byte returned from the CONVERT_DEC routine.
;	R6 -	Used to index into the data.	
;	R7 -	Points to the address of the data.
;	R8 -	Used by HEX_DISPLAY to convert a byte to two hex digits.
;	   -	Used by DEC_DISPLAY to hold value from conversion table.
;	R10 -	Points to the field descriptor.
;	R11 -	Used to calculate the length of the conversion.
;	R10,R11 Used by DEC_DISPLAY to hold the quadword of data to be
;		converted to decimal.
;
;--

FORMAT_DATA:
	PUSHR	#^M<R3,R5,R6,R7,R8,R10,R11>
	CLRL	R0			; Assume failure.
	MOVAL	FORMAT_BUF,R3		; Get address of temporary buffer.
	CASE	FD$B_FORMAT(R10),-	; Dispatch on format type.
		<ASCII_DISPLAY,-
		HEX_DISPLAY,-
		DEC_DISPLAY,-
		ASCIC_DISPLAY,-
		TIME_DISPLAY>,TYPE=B,LIMIT=#1


TIME_DISPLAY:
	$ASCTIM_S -			; Convert time to ascii.
		TIMBUF=ASC_TIM_DSCR,-	;
		TIMADR=(R7)		;
;
; Shift the last tenth through eighteenth characters of the time string
; left two places.  This is to condense the date by effectively removing
; the first two digits of the year, i.e., dd-mmm-yyyy hh:mm:ss.cc becomes
; dd-mmm-yy hh:mmmm:ss.cc.  The last eigth characters are simply not output,
; leaving dd-mmm-yy hh:mm.
;

	MOVAL	TIMBUF+9,R1		; Get address of "yyyy"
	MOVAL	TIMBUF+7,R7		; Get address of "yy h"
	MOVQ	(R1)+,(R7)+		; Shift first four characters left 2.
	MOVQ	(R1)+,(R7)+		; Shift next four characters left 2.
	MOVAL	TIMBUF,R7		; Get address of time string.
					; Fall through to ASCII_DISPLAY.


;
; Format the data in ASCII.
;

ASCII_DISPLAY:
	CLRL	R6			; Zero index.
	MOVZBL	FD$B_LENGTH(R10),-	; Save length of string for return.
		FORMAT_BUF_LEN		;
10$:	MOVB	(R7)[R6],(R3)+		; Store a character.
	INCB	R6			; Bump index.
	CMPB	R6,FD$B_LENGTH(R10)	; Are we done?
	BNEQU	10$			; Loop if not.
20$:	CMPB	-(R3),#^A/ /		; Any trailing spaces?
	BNEQU	30$			; Branch if not.
	SOBGTR	FORMAT_BUF_LEN,20$	; Remove trailing space.
30$:	INCL	R3			; Restore R3 to last character plus 1.
	BSBW	CHECK_VALID		; Make sure the string contains valid
					;  ascii characters.
	JLBC	R0,FERR			; Branch if string contains non-ascii.
	BRW	FDONE			; Done.

;
; Format the data in HEXADECIMAL
;

HEX_DISPLAY:
	MOVZBL	FD$B_LENGTH(R10),R6	; Get the number of bytes of data.
	ROTL	#1,R6,R11		; Get the maximum length of the
					;  converted string.
10$:	DECL	R6			; Count down number of bytes.
	BLSS	15$			; Branch if data equals 0.
	MOVZBL	(R7)[R6],R8		; Get a byte of data.
	BNEQ	20$			; Branch if not 2 leading zeros.
	SUBL	#2,R11			; Subtract 2 leading zeros from the
					;  length of the converted string.
	BRB	10$			; Loop for all leading zeros.
15$:	MOVL	#1,FORMAT_BUF_LEN	; Length equals 1.
	MOVB	#^A/0/,FORMAT_BUF	; String equals "0"
	BRW	FDONE			; Done.
20$:	ASHL	#-4,R8,R8		; Scratch lower nyble.
	BNEQ	HIGH_NYBLE		; Branch if not single leading zero.
	DECL	R11			; Subtract one leading zero from the
					;  length of the converted string.
	BRB	LOW_NYBLE		; Start format with low nyble.
HIGH_NYBLE:
	MOVZBL	(R7)[R6],R8		; Get a byte of data.
	ROTL	#-4,R8,R8		; Scratch the low nyble.
	BSBW	CONVERT_HEX		; Convert the nyble to ascii.
LOW_NYBLE:
	MOVZBL	(R7)[R6],R8		; Get full byte back.
	BICL	#^X000000F0,R8		; Mask the low nyble.
	BSBW	CONVERT_HEX		; Convert the nyble to ascii.
	SOBGEQ	R6,HIGH_NYBLE		; Loop for entire value.
	MOVL	R11,FORMAT_BUF_LEN	; Save length of conversion.
	BRW	FDONE			; Done.


;
; Format the data in DECIMAL.
;

DEC_DISPLAY:
	MOVZBL	FD$B_LENGTH(R10),R6	; Get the number of bytes of data.
	CMPB	R6,#8			; We can't handle more than 8 bytes.
	BGTR	FERR			; Error if more than 8 bytes.
	CLRQ	R10			; Start with quadword of zero.
10$:	DECL	R6			; Count down the bytes.
	BLSS	15$			; Branch if we've got all the bytes.
	ASHQ	#8,R10,R10		; Shift the byte into quadword.
	MOVB	(R7)[R6],R10		; Get a byte of data.
	BRB	10$			; Loop for entire value.
15$:	MOVAL	DEC_TAB,R7		; Point to conversion table.
	MOVL	#DEC_TAB_LEN,R6		; 20 conversions steps in all.
20$:	MOVQ	(R7)+,R8		; Get a value from the conversion
					;  table.
	BSBW	CONVERT_DEC		; Convert to one decimal digit.
	CMPL	R3,#FORMAT_BUF		; Have any characters been output yet?
	BNEQU	30$			; Branch if so.
	TSTB	R5			; Was the conversion result = 0.
	BEQLU	40$			; If so, don't save the character.
30$:	ADDB3	#^X30,R5,(R3)+		; Convert to ascii and save character.
40$:	SOBGTR	R6,20$			; Loop for all 20 steps.
	SUBL3	#FORMAT_BUF,R3,-	; Save the length of the conversion.
		FORMAT_BUF_LEN		;
	BNEQ	50$			; Branch if result wasn't zero.
	MOVB	#^A/0/,FORMAT_BUF	; Store a "0"
	MOVL	#1,FORMAT_BUF_LEN	; Length equals one byte.
50$:	BRW	FDONE			; Done.

ASCIC_DISPLAY:
	MOVZBL	(R7)+,FORMAT_BUF_LEN	; Save length of string for return.
	PUSHR	#^M<R2,R4,R5>
	MOVC3	FORMAT_BUF_LEN,(R7),(R3); Save the string. 
	POPR	#^M<R2,R4,R5>
	BSB	CHECK_VALID		; Make sure string contains valid ascii
					;  characters.
	BLBC	R0,FERR			; Branch if not.

FDONE:	MOVL	#SS$_NORMAL,R0		; Indicate success.
FERR:	POPR	#^M<R3,R5,R6,R7,R8,R10,R11>
	RSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine checks the string in the format buffer for valid ascii
;	characters.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_VALID
;
; CALLED BY:
;
;	ASCII_DISPLAY
;	ASCIC_DISPLAY
;
; INPUTS:
;
;	FORMAT_BUF contains the string.
;	FORMAT_BUF_LEN contains the length of the string.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL if string contains valid ascii characters.
;
; REGISTER USAGE:
;
;	R2 -	Counts down the characters in the string.
;	R3 -	Points into the buffer to the character to check.
;
;--

CHECK_VALID:
	PUSHR	#^M<R2,R3>
	CLRL	R0			; Assume failure.
	MOVL	FORMAT_BUF_LEN,R2	; Get length of string.
	MOVAL	FORMAT_BUF,R3		; Get address of format buffer.
	BSB	CHECK_ASCII		; Check for none ascii characters.
	POPR	#^M<R2,R3>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Check a string for valid ascii characters.  Return immediately if an
;	invalid ascii character is found with R3 pointing to the character and
;	failed status in R0.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_ASCII
;
; CALLED BY:
;
;	CHECK_VALID
;	BRDCST
;
; INPUTS:
;
;	R2 = Length of string
;	R3 = Address of string
;
; RETURN STATUS:
;
;	If all charcters in the string are valid ascii:
;
;		R0 = SS$_NORMAL
;		R2 = 0
;		R3 = pointer to character following the string.
;
;	If invalid character found:
;
;		R0 = failed status
;		R2 = number of characters remaining in string.
;		R3 = points to failed character.
;
;--

CHECK_ASCII:
	CLRL	R0			; Assume failure.
10$:	CMPB	(R3),#^A/ /		; Less than ^X20 ?
	BLSS	99$			; If so, character is not ascii.
20$:	CMPB	(R3),#^A/~/		; Greater than ^X7E ?
	BGTR	99$			; If so, character is not ascii.
	INCL	R3			; Update pointer.
	SOBGTR	R2,10$			; Loop for entire string.
	MOVL	#SS$_NORMAL,R0		; Indicate success.
99$:	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts the value in R8 to one ascii format hex digit 
;	and outputs the digit to the format buffer.
;
; CALLING SEQUENCE:
;
;	JSB	CONVERT_HEX
;
; CALLED BY:
;
;	LOW_NYBLE
;	HIGH_NYBLE
;
; INPUTS:
;
;	R3 -	Points to the position in the format buffer where the result
;		will be stored.
;	R8 -	Contains the value to be converted in the low nyble.
;
; OUTPUTS:
;
;	One ascii character output to the format buffer.
;
; IMPLICIT OUTPUTS:
;
;	R3 updated.
;	R8 scratched.
;
; RETURN STATUS:
;
;	None.
;
;--

CONVERT_HEX:
	CMPB	R8,#10			; Value less than 10?
	BGEQU	10$			; Branch if not.
	ADDB	#^X30,R8		; Convert value 0 through 9 to ascii.
	BRB	20$			; Jump to common code.
10$:	SUBL	#10,R8			; Convert value ^X0A through ^X0F to
	ADDL	#^X41,R8		;  ascii.
20$:	MOVB	R8,(R3)+		; Store the converted character.
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs one step of hex to decimal conversion by dividing
;	the quadword in R10 by the quadword in R8.  R8 contains the decimal
;	weight of the digit for this step of the conversion.
;
; CALLING SEQUENCE:
;
;	JSB	CONVERT_DEC
;
; CALLED BY:
;
;	DEC_DISPLAY
;
; INPUTS:
;
;	R8  -	Quadword value for this step from the conversion table.
;	R10 -	Quadword value to be converted.
;
; OUTPUTS:
;
;	R5 -	Decimal digit resulting from this step of the conversion.
;	R8 -	Remainder to be used in next step of conversion.
;
; RETURN STATUS:
;
;	None.
;
;--

CONVERT_DEC:
	CLRB	R5			; Assume result equals zero.
10$:	SUBL	R8,R10			; Quadword subtract with carry.
	SBWC	R9,R11			;
	BCS	20$			; Jump if less than zero.
	INCB	R5			; Otherwise result = result + 1.
	BRB	10$			; Loop.
20$:	ADDL	R8,R10			; Quadword add to restore remainder.
	ADWC	R9,R11			;
	RSB



	.SBTTL	Data display routines.
;
; Addresses of data structures are passed to the data display routines in a
; call frame.  All addresses are determined by the routines CLUSTER_REPORT
; and LOCAL_REPORT, which determine the format of the report.
;
;
;		+--------------------------------+
;	(AP)	|	 Number of elements	 |
;		+--------------------------------+
; (AP)[CLUB_IN] |     Base address of CLUB	 |
;		+--------------------------------+
;   (AP)[SB_IN] |  Base address of system block	 |
;		+--------------------------------+
;  (AP)[CSB_IN] |      Base address of CSB 	 |
;		+--------------------------------+
;   (AP)[PB_IN] |   Base address of path block	 |
;		+--------------------------------+
;  (AP)[CDT_IN] |      Base address of CDT	 |
;		+--------------------------------+
;  (AP)[PDT_IN] |      Base address of PDT	 |
;		+--------------------------------+
;   (AP)[MB_IN] | Address of miscellaneous buffer|
;		+--------------------------------+
;



	.SBTTL	-	GET_DATA routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine gets a line of data into the data buffer by calling a
;	routines that extract and format the data for each of the fields that
;	are to be displayed.  The data is then stored in DATA_BUF for output.
; 
; CALLING SEQUENCE:
;
;	CALLS	GET_DATA
;
; INPUTS:
;
;	Addresses of data structures from which the data is to be extracted are
;	stored in a call frame.  See above picture for details.
;
; IMPLICIT INPUTS:
;
;	ADRS_TABLE, BITMAP_ADRS, and MAP_LEN must be set up according to the
;	FIND_ENTRY routine.
;
; OUTPUTS:
;
;	One line of ascii formatted data stored in DATA_BUF.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL.
;
; REGISTER USAGE:
;
;	R3 -	Pointer to next free character position in data buffer.
;	R6 -	Counts down the number of characters that can be added
;		to the data buffer before its length exceeds the width
;		of the screen.
;	R7 -	Contains the offset into the data structure used to extract
;		the data.
;	R10 -	Points to field descriptor.
;	R11 -	Used to determine the number of fill characters (asterisks,
;		question marks, or spaces) to add to the display field.
;
;--

.ENTRY	GET_DATA,^M<R3,R6,R7,R9,R10,R11>
	BICL	#MF$M_INVERSE,MISC_FLAGS; Make sure inverse flags starts out
					;  clear.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,3$	;  cluster report.
	BBC	#MF$V_CONT,MISC_FLAGS,2$; Branch if noncontinuous display.
	CMPL	LINE_NUM,CMD_LINE	; Have we overflowed the screen?
	BLSS	2$			; Branch if not.
	BISB	#SCR$M_MORE_DWN!SCR$M_MORE,-
		SCROLL_FLAGS		; Indicate screen can be scrolled up.
	BRW	50$			; No need to get data for the line.
2$:	MOVL	CLSTR_H_SCROLL,-	; Get a copy of the scroll value for the
		H_SCROLL_LINE		;  cluster report.
	BRB	4$			; Branch to common code.
3$:	MOVL	LOCAL_H_SCROLL,-	; Get a copy of the scroll value for the
		H_SCROLL_LINE		;  local report.
4$:	DECL	V_SCROLL_LINE		; Count down the number of lines of
					;  data that are scrolled off the
					;  screen.
	JGEQ	50$			; Skip this line if it's scrolled off
					;  the screen.
	MOVAL	DATA_BUF,R3		; Get pointer to data buffer.
	MOVZWL	SCREEN_WIDTH,R6		; Get screen width.
	BBS	#SCR$V_MORE_LFT,-	; Branch if screen has been scrolled
		SCROLL_FLAGS,5$		;  left.
	BSBW	DELM			; Add starting field delimiter to line.
	JLEQU	40$			; Branch if it won't fit on the screen.
5$:	CLRL	START_BIT		; Start scanning the bitmap with bit
					;  zero.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,6$	;  cluster report.
	MOVL	#CLUSTER_MAP_LEN,MAP_LEN; Save length of cluster bitmap.
	BRB	10$			; Jump to common code.
6$:	MOVL	#LOCAL_MAP_LEN,MAP_LEN	; Save length of local bitmap.
10$:	BSBW	FIND_ENTRY		; Find an entry.
	JLBC	R0,40$			; Branch if an entry wasn't found.
	BITL	FD$L_CLASS(R10),-	; Is this entry in a different class?
		CLASS_SELECT		;
	BEQLU	10$			; Branch if so.
	BITL	FD$L_CLASS(R10),-	; Is this class enabled?
		DATA_CNTRL		;
	BNEQU	20$			; Branch if so.
;
; Class is disabled, so fill this field with spaces.
;
	BSBW	ADD_ONE_SPACE		; Preceed the data with atleast one
					;  space.
	JLEQU	40$			; Branch if it won't fit.
	MOVZBL	FD$B_FIELD_SIZE(R10),R9	; Get the size of the field.
	BSBW	ADD_SPACES		; Fill the field with spaces.
	BRW	29$			; Jump to common code.

20$:	MOVL	FD$L_OFFSET(R10),R7	; Get the SCS offset.
	JSB	@FD$L_DISPLAY_ROUTINE(R10)
					; Call the display routine to extract
					;  and format the data.
	MOVL	R0,R9			; Save status from display routine.
	BBC	#MF$V_INVERSE,-		; Branch if the data hasn't changed
		MISC_FLAGS,22$		;  since the last snapshot.
	BBSS	LINE_NUM,LINE_DIF,21$	; Indicate the some data in this line
					;  changed and the line must be
					;  rewritten to the screen.
21$:	BBC	#DVT$V_DCRT,OUT_DEV,22$	; Branch if not DECcrt terminal.
	MOVC3	INVRS_DSCR,-		; Store sequence to turn on inverse
		INVRS_DSCR+8,(R3)	;  video.
22$:	BSBW	ADD_ONE_SPACE		; Preceed data with one space.
					; Branch to display subroutine for this
					;  field.
	JLEQU	40$			; Branch if it didn't fit.
	BLBS	R9,25$			; Branch if display routine succeeded.
;
; Display routine failed, so center a question mark in the field.
;
	MOVZBL	FD$B_FIELD_SIZE(R10),R9	; Get the size of this field.
	DECB	R9			; Subtract one for the question mark.
	ROTL	#-1,R9,R9		; Calculate the number of spaces needed
					;  to center the question mark.
	BSBW	ADD_SPACES		; Add leading spaces to buffer.
	JLEQU	40$			; Branch if the spaces won't fit on the
					;  screen.
	BBC	#31,R9,23$		; Branch if even number of spaces.
	BSBW	ADD_ONE_SPACE		; Add one more leading space.
	JLEQU	40$			; Branch if it didn't fit.
23$:	MOVB	#^A/?/,(R3)+		; Store the question mark.
	DECL	R6			; Update number of columns remaining.
	JLEQU	40$			; Branch if the question mark didn't
					;  fit on the screen.
	BSBW	ADD_SPACES		; Add trailing spaces to buffer.
	BRW	29$			; Jump to common code.

25$:	MOVZBL	FD$B_FIELD_SIZE(R10),R9	; Get the size of this field.
	CMPL	FORMAT_BUF_LEN,R9	; Will the formatted data fit in the
					;  display field?
	BEQLU	28$			; Branch if it fits exactly.
	BLSSU	27$			; Branch if its smaller.
	CMPB	FD$B_FORMAT(R10),-	; Is the data formatted in hex?
		#HEX			;
	BEQLU	26$			; Branch if so.
	CMPB	FD$B_FORMAT(R10),-	; Is the data formatted in decimal?
		#DEC			;
	BEQLU	26$			; Branch if so.
;
; The data is ascii, but is larger than the field, so truncate the string.
;

	MOVL	R9,FORMAT_BUF_LEN	; Truncate the string by making its
					;  length equal to the field size.
	BRB	28$			; Copy the string.

;
; The data is non ascii and is larger than the field, so fill the field with
; asterisks.
;

26$:	PUSHR	#^M<R2,R4,R5>
	MOVC5	#0,(R3),#^A/*/,R9,(R3)	; Fill field with asterisks.
	POPR	#^M<R2,R4,R5>
	SUBL	R9,R6			; See if it fit on the screen.
	BRB	29$			; Jump to common code.
;
; If the string is ascii then left justify the string in the field.  If
; hex or decimal then right justify the string.
;

27$:
	SUBL	FORMAT_BUF_LEN,R9	; Get number of spaces to add.
	CMPB	FD$B_FORMAT(R10),#HEX	; Is the data to be displayed in
					;  hexadecimal?
	BEQL	275$			; Branch if so.
	CMPB	FD$B_FORMAT(R10),#DEC	; Is the data to be displayed in
					;  decimal?
	BEQL	275$			; Branch if so.
	PUSHR	#^M<R2,R4,R5>
	MOVC3	FORMAT_BUF_LEN,-	; Copy the string into the data buffer.
		FORMAT_BUF,(R3)		;
	POPR	#^M<R2,R4,R5>
	SUBL	FORMAT_BUF_LEN,R6	; Calculate columns remaining.
	BLEQU	40$			; Branch if the string didn't fit on
					;  the screen.
	BSBW	ADD_SPACES		; Add trailing spaces.
	BRB	29$			; Branch to common code.
275$:
	BSBW	ADD_SPACES		; Add leading spaces.
	JLEQU	40$			; Branch if the spaces didn't fit on
					;  the screen.
	PUSHR	#^M<R2,R4,R5>
	MOVC3	FORMAT_BUF_LEN,-	; Copy the string into the data buffer.
		FORMAT_BUF,(R3)		;
	POPR	#^M<R2,R4,R5>
	SUBL	FORMAT_BUF_LEN,R6	; Calculate columns remaining.
	BRB	29$			; Branch to common code.
28$:	PUSHR	#^M<R2,R4,R5>
	MOVC3	FORMAT_BUF_LEN,-	; Copy the string into the data buffer.
		FORMAT_BUF,(R3)		;
	POPR	#^M<R2,R4,R5>
	SUBL	FORMAT_BUF_LEN,R6	; Will it fit on the screen?
29$:	BLEQU	40$			; Branch if it didn't fit.
	BSBW	ADD_ONE_SPACE		; Follow with one space.
	BLEQU	40$			; Branch if it didn't fit.
	BBCC	#MF$V_INVERSE,-		; Branch if the data hasn't changed
		MISC_FLAGS,30$		;  since the last snapshot.
	BBC	#DVT$V_DCRT,OUT_DEV,30$	; Branch if not DECcrt terminal.
	MOVC3	DCRT_NOATR_DSCR,-	; Store sequence to turn off attributes
		DCRT_NOATR_DSCR+8,(R3)	;  (inverse video).
30$:	BSBW	DELM			; Add ending delimiter to line.
	JGTRU	10$			; Loop if there's more room on the line.
40$:	BBCC	#MF$V_INVERSE,-		; Branch if the data hasn't changed
		MISC_FLAGS,45$		;  since the last snapshot.
	BBC	#DVT$V_DCRT,OUT_DEV,45$	; Branch if not DECcrt terminal.
	MOVC3	DCRT_NOATR_DSCR,-	; Store sequence to turn off attributes
		DCRT_NOATR_DSCR+8,(R3)	;  (inverse video).
45$:	SUBL3	#DATA_BUF,R3,DATA_DSCR	; Save length of data line.
	MOVAL	DATA_DSCR,R11		; Get address of descriptor for the
					;  line of data.

	BBS	#MF$V_RIP,MISC_FLAGS,49$; If refresh in progress, make sure
					;  we draw all the lines.
	BBS	LINE_NUM,BLANK_LINES,49$; Branch if this is a new blank line.
	BBS	LINE_NUM,LINE_DIF,49$	; Branch if this line has changed.
	BBC	#DVT$V_DCRT,OUT_DEV,48$	; Branch if output device is not a
					;  DECcrt terminal.
	BBS	LINE_NUM,-		; Branch if this line changed on the
		PRIOR_LINE_DIF,49$	;  last pass and must be rewritten to
					;  remove the inverse video.
48$:	INCL	LINE_NUM		; Otherwise, just bump the line number.
	BRB	50$			; And finish up.
49$:	BSBW	DRAW_LINE		; Output the line.
50$:	MOVL	#SS$_NORMAL,R0
	RET



	.SBTTL	-	General data display routines.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This is the default data display routine.  It gets the address of the
;	data by first determining the type of structure containing the data
;	by examining the prefix of the structure name argument.  If the prefix
;	is valid, it is converted to an index into the call frame which
;	contains the base address of the data structures containing the data.
;	the base address of the proper structure is then added to R7 to get
;	the address of the data. FORMAT_DATA is then called to format the data.
;
; Note:	DISPLAY_FIELD can only be used when the data to be displayed is found
;	in either the club, a cluster system block, an SCS system block, path
;	block, or connection descriptor table, a port descriptor table, or the
;	miscellaneous buffer.  The argument STRUCTURE_NAME given in the
;	DEFINE_FIELD macro must be a valid SCS offset and must begin with CLUB.
;	SB$, PB$, CDT$, PDT$ or a miscellaneous buffer offset begining with MB$.
;	Any other argument will cause the field to be filled with question
;	marks. 
;
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_FIELD
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset from DEFINE_FIELD macro.
;	R10	= Address of field descriptor.
;
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated data string returned in FORMAT_BUF.
;	Length of formatted data string returned in FORMAT_BUF_LEN.
;
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed, or status from FORMAT_DATA.
;
;--

DISPLAY_FIELD:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8>
	CLRL	R0			; Assume failure.
	MOVL	#1,R8			; Set index past number of arguments in
					;  call frame.
	MOVAL	SYM_PRFX,R4		; Point to array of symbol prefixes.
	MOVAL	FD$L_OFFSET_PRFX(R10),R5; Get the address of the src2 string.
10$:	MOVZBL	(R4)+,R3		; Get the length of src1 string
	PUSHR	#^M<R3>
	CMPC	R3,(R4),(R5)		; Check for valid prefix.
	POPR	#^M<R3>
	BEQL	20$			; Branch if valid prefix.
	ADDL	R3,R4			; Point to next prefix.
	ACBL	R6,#1,R8,10$		; Loop for all arguments.
	BRB	99$			; Branch if invalid prefix.
20$:	CMPL	#CDT_PFX+1,R4		; Is the prefix "CDT$"?
	BNEQ	30$			; Branch if not.
	ADDL	#SHC$L_CDT_DIF,R7	; Adjust CDT offset to compensate for
					;  portion of CDT not stored.
	BRB	40$			; Skip check for "PDT$".
30$:	CMPL	#PDT_PFX+1,R4		; Is the prefix "PDT$"?
	BNEQ	40$			; Branch if not.
	ADDL	#SHC$L_PDT_DIF,R7	; Adjust PDT offset to compensate for
					;  portion of PDT not stored.
40$: 	ADDL	(R12)[R8],R7		; Get address of data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	BSBW	FORMAT_DATA		; Format the data.
99$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to convert a numeric value into a string.  The
;	value is used as an index into a list of counted ascii strings.  The
;	address of the indexed string is then used when calling the FORMAT_DATA
;	routine.
;
; Note:	The FORMAT argument in the field descriptor for any field using this 
;	routine must be of the type "ASCIC".
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_STRING
;
; CALLED BY:
;
;	DISPLAY_RPORT_TYPE
;	DISPLAY_CABLE_STATUS
;	DISPLAY_LOOPBACK_STATUS
;
; INPUTS:
;
;	R7	= Value to be used as an index into a list of counted ascii
;		  strings.
;	R8	= Address of a list of counted ascii strings.
;
; OUTPUTS:
;
;	Formated data string returned in FORMAT_BUF.
;	Length of formatted data string returned in FORMAT_BUF_LEN.
;
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed, or status from FORMAT_DATA.
;
;--

DISPLAY_STRING:
	PUSHR	#^M<R7,R8,R9>
	TSTL	R7			; Index equal zero?
	BEQLU	20$			; Branch if so.
10$:	MOVZBL	(R8)+,R9		; Get the number of characters in the
					;  descriptor.
	ADDL	R9,R8			; Point to next descriptor.
	SOBGTR	R7,10$			; Loop till R7 equals 0 and R8 points
					;  to the string.
20$:	ADDL	R8,R7			; Get address of string.
	BSBW	FORMAT_DATA		; Format the string.
	POPR	#^M<R7,R8,R9>
	RSB



	.SBTTL	-	Cluster class display routines.

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	The following routines are used to display the bit in the CLUB$L_FLAGS
;	longword in the CLUB and the CSB$L_STATUS longword in the CSB.  These
;	bits are displayed as a one or zero only.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_QF_VOTE
;	JSB	DISPLAY_QF_SAME
;	JSB	DISPLAY_QF_ACTIVE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= Offset of longword containing the bit to display.
;	(AP)[CLUB_IN]	= Base address of club or cluster system block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated data string returned in FORMAT_BUF.
;	Length of formatted data string returned in FORMAT_BUF_LEN.
;
; REGISTER USAGE:
;
;	R7	= Offset into data structure where data is located.  Converted
;		  into actual address of data.
;	R8	= Index into call frame to locate structure base address.
;--

DISPLAY_QF_VOTE:
	PUSHR	#^M<R6,R7,R8>
	MOVL	#CLUB_IN,R8		; Set index into call frame to club
					;  base address.
	ADDL	(R12)[R8],R7		; Get address of data.
	MOVL	#CLUB$V_QF_VOTE,R6	; Get number of bit to check.
	BSBW	DISPLAY_QF		; Convert to formatted string.
	POPR	#^M<R6,R7,R8>
	RSB

DISPLAY_QF_SAME:
	PUSHR	#^M<R6,R7,R8>
	MOVL	#CSB_IN,R8		; Set index into call frame to cluster
					;  system block base address.
	ADDL	(R12)[R8],R7		; Get address of data.
	MOVL	#CSB$V_QF_SAME,R6	; Get number of bit to check.
	BSBW	DISPLAY_QF		; Convert to formatted string.
	POPR	#^M<R6,R7,R8>
	RSB

DISPLAY_QF_ACTIVE:
	PUSHR	#^M<R6,R7,R8>
	MOVL	#CSB_IN,R8		; Set index into call frame to cluster
					;  system block base address.
	ADDL	(R12)[R8],R7		; Get address of data.
	MOVL	#CSB$V_QF_ACTIVE,R6	; Get number of bit to check.
	BSBW	DISPLAY_QF		; Convert to formatted string.
	POPR	#^M<R6,R7,R8>
	RSB

;
; Convert the bit into an ascii string "YES" or "NO".
;

DISPLAY_QF:
	BSBW	CHECK_DIF		; Check for change in data since last
					;  update.
	BBC	R6,(R7),10$		; Branch if QF_VOTE isn't set.
	CLRL	R7			; Get index into string array.
	BRB	20$			; Branch to common.
10$:	MOVL	#1,R7			; Get index into string array.
20$:	MOVAL	YES_NO_STRING,R8	; Get address of string array.
	BSBW	DISPLAY_STRING		; Format the string.
	RSB


	.SBTTL	-	Systems class display routines.

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to combine SB$T_SWTYPE and SB$T_SWVERS to
;	produce the SOFTWARE field.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_SOFTWARE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= Offset to SB$T_SWVERS in the system block.
;	(AP)[SB_IN]	= Address of system block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated data string returned in FORMAT_BUF.
;	Length of formatted data string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	Status returned from FORMAT_DATA routine.
;
; REGISTER USAGE:
;
;	R7	= Offset into data structure where data is located.  Converted
;		  into actual address of data.
;	R8	= Index into call frame to locate system block base address.
;--

DISPLAY_SOFTWARE:
	PUSHR	#^M<R8,R9>
	BSBW	DISPLAY_FIELD		; Format the software version.
	MOVL	FORMAT_BUF,R9		; Save the version temporarily.
	MOVL	#SB_IN,R8		; Set index into call frame to system
					;  block base address.
	MOVL	#SB$T_SWTYPE,R7		; Get software type offset.
	ADDL	(R12)[R8],R7		; Get address of data.
	MOVL	(R7),FORMAT_BUF		; Store software type in buffer.
	MOVB	#^A/ /,FORMAT_BUF+3	; Place a space between type and
					;  version.
	MOVL	R9,FORMAT_BUF+4		; Store the version in the buffer.
	MOVL	#8,FORMAT_BUF_LEN	; Buffer length = 8 characters.
	POPR	#^M<R8,R9>
	RSB



	.SBTTL	-	Cluster system block display routines.

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the protocol version and ECO level.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_PROTOCOL
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset CSB$B_ECOLVL from DEFINE_FIELD macro.
;	(AP)[CSB_IN]	= Base address of selected cluster system block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_PROTOCOL:
	PUSHR	#^M<R7,R8>
	MOVL	#CSB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	ASHL	#8,(R7),SCRATCH		; Store eco level in 2nd byte of
					;  scratch location.
	MOVL	#CSB$B_VERNUM,R7	; Get version number offset.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVB	(R7),SCRATCH		; Store version number in 1st byte of
					;  scratch location.
	MOVAL	SCRATCH,R7		; Get address of data.
	BSBW	FORMAT_DATA		; Format the data.
	POPR	#^M<R7,R8>
	RSB




;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the state of the cluster system.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_CSB_STATE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset CSB$B_STATE from DEFINE_FIELD macro.
;	(AP)[CSB_IN]	= Base address of selected cluster system block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_CSB_STATE:
	PUSHR	#^M<R7,R8>
	MOVL	#CSB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	CSB_STATE_STRNG,R8	; Point to array of state descriptors.
	MOVZBL	(R7),R7			; Get the state.
	DECL	R7			; Subtract one so index starts at zero.
	BSBW	DISPLAY_STRING		; Format the string.
	POPR	#^M<R7,R8>
	RSB




;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the state of the cluster system.
;
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_CSB_STATUS
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset CSB$L_STATUS from DEFINE_FIELD macro.
;	(AP)[CSB_IN]	= Base address of selected cluster system block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

ASSUME CSB$V_LONG_BREAK	EQ 0
ASSUME CSB$V_MEMBER	EQ 1
ASSUME CSB$V_REMOVED	EQ 2

DISPLAY_CSB_STATUS:
	PUSHR	#^M<R7,R8>
	MOVL	#CSB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVB	(R7),R7			; Get the status.
	BICL	#^C<CSB$M_LONG_BREAK!-	; Clear any non-status bits.
		CSB$M_MEMBER!-		;
		CSB$M_REMOVED>,R7	; 
	MOVAL	CSB_STATUS_STRNG,R8	; Point to array of status descriptors.
	BSBW	DISPLAY_STRING		; Format the string.
	POPR	#^M<R7,R8>
	RSB


	.SBTTL	-	Circuits class display routines.

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the remote port type using the data
;	stored at offset PB$L_RPORT_TYP in the path block.  CI780s and CI750s
;	both have a port type of 2.  If PB$L_RPORT_TYP indicates a port type
;	code = 2, then the hardware type field in the system block for the
;	remote system is checked to make the distinction.
;	
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_RPORT_TYP
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7  =	SCS offset PB$L_RPORT_TYP from DEFINE FIELD macro.
;	(AP)[PB_IN]	= Address of path block.
;	(AP)[SB_IN]	= Address of system block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0  =	SS$_NORMAL of failed status returned from FORMAT_DATA.
;
;--

DISPLAY_RPORT_TYP:
	PUSHR	#^M<R7,R8>
	MOVL	#PB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	EXTZV	#PB$V_PORT_TYP,-	; Get the port type code.
		#PB$S_PORT_TYP,(R7),R7	;
	SUBL	#2,R7			; Convert port type code to index into
					;  array of port type descriptors.
	BNEQ	10$			; Branch if port is not a CI780 or
					;  CI750.
	MOVL	#SB_IN,R8		; Set index into call frame to system
					;  block base address.
	MOVL	(R12)[R8],R8		; Get the address of the system block
					;  for the remote system.
	MOVL	SB$T_HWTYPE(R8),R8	; Get the remote system hardware type.
	CMPL	R8,#^A/V780/		; Is the remote system an 11/780?
	BEQL	10$			; Branch if so.
	CMPL	R8,#^A/V785/		; Is the remote system an 11/785?
	BEQL	10$			; Branch if so.
	INCL	R7			; Bump port type index.
	CMPL	R8,#^A/V750/		; Is the remote system an 11/750?
	BNEQ	99$			; Error if not.
10$:	MOVAL	RPORT_TYP_STRNG,R8	; Point to array of port type
					;  descriptors.
	BSBW	DISPLAY_STRING		; Display the port type string.
99$:	POPR	#^M<R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the state of the virtual circuit.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_CIR_STATE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS Offset PB$W_STATE from DEFINE_FIELD macro.
;	(AP)[PB_IN]	= Base address of selected path block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_CIR_STATE:
	PUSHR	#^M<R7,R8>
	MOVL	#PB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get address of data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	PB_STATE_STRNG,R8	; Point to array of circuit state
					;  strings.
	MOVZWL	(R7),R7			; Get the state.
	BITW	#PB$C_VC_FAIL,R7	; Check for VC_FAIL.
	BEQLU	10$			; Branch if not.
	MOVW	#4,R7			; Get index to VC_FAIL string.
10$:	BSBW	DISPLAY_STRING		; Display the string.
	POPR	#^M<R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the state of the remote port.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_RSTATE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset PB$B_RSTATE from DEFINE_FIELD macro.
;	(AP)[PB_IN]	= Base address of selected path block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_RSTATE:
	PUSHR	#^M<R7,R8>
	MOVL	#PB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	PB_RSTATE_STRNG,R8	; Point to array of state descriptors.
	MOVZBL	(R7),R7			; Get the state.
	BSBW	DISPLAY_STRING		; Format the string.
	POPR	#^M<R7,R8>
	RSB
	


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the path/cable status.  The state of
;	the cable is first checked and if good the states of the path A and path
;	B are checked.  The output is in the format:
;
;		"  -  "		Cable is good.  No good paths.
;		"A -  "		Cable is good.  Path A is good.
;		"  - B"		Cable is good.  Path B is good.
;		"A - B"		Cable is good.  Paths A and B are good.
;		"CROSSED"	Cable is bad or crossed.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_CABLE_STATUS
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset PB$B_CBL_STS from DEFINE_FIELD macro.
;	(AP)[PB_IN]	= Base address of selected path block.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

ASSUME PB$B_P0_STS	EQ PB$B_CBL_STS+1
ASSUME PB$B_P1_STS	EQ PB$B_P0_STS+1

DISPLAY_CABLE_STATUS:
	PUSHR	#^M<R7,R8,R9>
	MOVL	#PB_IN,R8		; Set index into call frame to path
					;  block base address.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	CB_STAT_STRG,R8		; Point to cable status strings.
	BITB	#PB$M_CUR_CBL,(R7)+	; Is the cable status ok?
	BNEQ	10$			; Branch if so.
	MOVL	#4,R7			; Indicate crossed.
	BRB	40$			; Skip path state checks.
10$:	BSBW	CHECK_DIF		; Check for change in path A.
	CLRL	R9			; Assume path A and path B bad.
	BITB	#PB$M_CUR_PS,(R7)+	; Path A ok?
	BEQL	20$			; Branch if not.
	BISL	#1,R9			; Indicate path A ok.
20$:	BSBW	CHECK_DIF		; Check for change in path B.
	BITB	#PB$M_CUR_PS,(R7)	; Path B ok?
	BEQL	30$			; Branch if not.
	BISL	#2,R9			; Indicate B ok.
30$:	MOVL	R9,R7			; Get result in R7.
40$:	BSBW	DISPLAY_STRING		; Display the string.
	POPR	#^M<R7,R8,R9>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the local or remote process names
;	associated with a CDT.  The process names, if available, are stored
;	following each CDT by the snapshot routine.  The first 16 bytes being
;	the local process name and the next 16 bytes being the remote process
;	name.  The routine determines which name is to be formatted by the
;	offset in R7.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_PROC_NAME
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset SCS$T_DST_PROC for local process name or
;		  SCS$T_SRC_PROC for remote process name.  From DEFINE_FIELD
;		  macro.
;	(AP)[CDT_IN]	= Base address of selected CDT.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

ASSUME SCS$T_SRC_PROC	EQ SCS$T_DST_PROC+16

DISPLAY_PROC_NAME:
	PUSHR	#^M<R7,R8>
	CLRL	R0			; Assume failure.
	MOVL	#CDT_IN,R8		; Set index into call frame to CDT
					;  block base address.
	ADDL3	(R12)[R8],-		; Get the address of the process names
		#SHC$C_CDT_LENGTH,R8	;  associated with the CDT by adding
					;  the CDT base address to the length
					;  of the CDT.
	CMPL	#SCS$T_DST_PROC,R7	; Are we displaying the local process
					;  name?
	BEQL	10$			; Branch if so.
	CMPL	#SCS$T_SRC_PROC,R7	; If not, make sure we are displaying
					;  the remote process name.
	BNEQ	99$			; Error if not.
	ADDL	#16,R8			; Point to remote process name.
10$:	MOVL	R8,R7			; Get address of data in R7.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	BSBW	FORMAT_DATA		; Format the string.
99$:	POPR	#^M<R7,R8>
	RSB


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the state of a connection.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_CON_STATE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset CDT$W_STATE from DEFINE_FIELD macro.
;	(AP)[CDT_IN]	= Base address of selected CDT.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_CON_STATE:
	PUSHR	#^M<R7,R8>
	MOVL	#CDT_IN,R8		; Set index into call frame to CDT
					;  block base address.
	ADDL	#SHC$L_CDT_DIF,R7	; Adjust CDT offset to compensate for
					;  portion of CDT not stored.
 	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	CDT_STATE_STRNG,R8	; Point to array of connection state
					;  strings.
	MOVZWL	(R7),R7			; Get the connection state.
	BSBW	DISPLAY_STRING		; Display the string.
	POPR	#^M<R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the SCS blocked state.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_SCS_STATE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset CDT$W_BLKSTATE from DEFINE_FIELD macro.
;	(AP)[CDT_IN]	= Base address of selected CDT.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_SCS_STATE:
	PUSHR	#^M<R7,R8>
	MOVL	#CDT_IN,R8		; Set index into call frame to CDT
					;  block base address.
	ADDL	#SHC$L_CDT_DIF,R7	; Adjust CDT offset to compensate for
					;  portion of CDT not stored.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	CDT_BLKSTATE_STRNG,R8	; Point to array of send blocked state
					;  strings.
	MOVZWL	(R7),R7			; Get the SCS blocked state.
	BSBW	DISPLAY_STRING		; Display the string.
	POPR	#^M<R7,R8>
	RSB


	.SBTTL	-	Local port display routines.

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the kilobyte values CDT$L_KBYTSENT,
;	CDT$L_KBYTREQD, and CDT$L_KBYTMAPD.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_KBYTES
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= SCS offset from DEFINE_FIELD macro.
;	(AP)[CDT_IN]	= Base address of selected CDT.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_KBYTES:
	PUSHR	#^M<R7,R8>
	MOVL	#CDT_IN,R8		; Set index into call frame to CDT
					;  block base address.
	ADDL	#SHC$L_CDT_DIF,R7	; Adjust CDT offset to compensate for
					;  portion of CDT not stored.
	ADDL	(R12)[R8],R7		; Get the address of the data.
	EXTZV	#10,#22,(R7),(R7)	; Convert bytes to Kbytes.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	BSBW	FORMAT_DATA		; Format the string.
	POPR	#^M<R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the status of the port.  The value
;	at offset MB$L_STS for the selected port in the miscellaneous buffer
;	is checked for online or offline status.  A string is then placed in
;	the format buffer which is an ascii representation of the status.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_PORT_STATUS
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= Offset MB$L_STS from DEFINE_FIELD macro.
;	(AP)[MB_IN] = Base address of the data for selected port in MISC_BUF.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_PORT_STATUS:
	PUSHR	#^M<R7,R8>
	MOVL	#MB_IN,R8		; Set index into call frame to base
					;  address of port data in MISC_BUF.
	ADDL	(R12)[R8],R7		; Get address of data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	PORT_STATUS_STRNG,R8	; Get address of port status strings.
	BBC	#UCB$V_ONLINE,(R7),10$	; Branch if the port is offline.
	ADDB	(R8)+,R8		; Otherwise, point to online status
					;  string.
10$:	MOVL	R8,R7			; Get address of string.
	BSBW	FORMAT_DATA		; Format the string.
	POPR	#^M<R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the device type of the port.  The value
;	at offset MB$L_DEVTYPE is checked for device type of CI780 or CI750.
;	The appropriate string is then stored in the format buffer.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_PORT_TYPE
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= Offset MB$L_DEVTYPE from DEFINE_FIELD macro.
;	(AP)[MB_IN] = Base address of the data for selected port in MISC_BUF.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

DISPLAY_PORT_TYPE:
	PUSHR	#^M<R7,R8>
	MOVL	#MB_IN,R8		; Set index into call frame to base
					;  address of port data in MISC_BUF.
	ADDL	(R12)[R8],R7		; Get address of data.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  scan.
	MOVAL	DEV_TYP_STRNG,R8	; Get address of device type strings.
	CMPL	#DT$_CI780,(R7)		; Is the port a CI780?  ********
	BEQL	10$			; Branch if so.
	ADDB	(R8)+,R8		; Otherwise point to the next string.
	CMPL	#DT$_CI750,(R7)		; Is the port a CI750?  ********
	BEQL	10$			; Branch if so.
	CLRL	R0			; Otherwise indicate failure.
	BRB	99$			; Any return imediately.
10$:	MOVL	R8,R7			; Get address of the string in R7.
	BSBW	FORMAT_DATA		; Format the string.
99$:	POPR	#^M<R7,R8>
	RSB



;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to display the loopback status of the port.
;	The value at offsets PDT$B_P0_LBSTS and PDT$B_P1_LBSTS are checked for
;	loopback or normal status and converted to an ascii string as follows:
;
;	"A - B"		-	Loopback tests passed on paths A and B.
;	"A -  "		-	Loopback tests passed on path A.
;	"  - B"		-	Loopback tests passed on path B.
;	"  -  "		-	Loopback tests failed on paths A and B.
;	" N/A "		-	Loopback testing is not being done.
;
;	The ascii string is stored in the format buffer.
;
; CALLING SEQUENCE:
;
;	JSB	DISPLAY_LOOPBACK_STATUS
;
; CALLED BY:
;
;	GET_DATA
;
; INPUTS:
;
;	R7	= Offset PDT$B_P0_LBSTS from DEFINE_FIELD macro.
;	(AP)[PDT_IN]	= Base address of the data for selected port in PDT_BUF.
;
; IMPLICIT INPUTS:
;
;	AP	= Address of call frame containing the addresses of the data
;		  structures to be used when data is extracted.
;
; OUTPUTS:
;
;	Formated ascii string returned in FORMAT_BUF.
;	Length of formatted ascii string returned in FORMAT_BUF_LEN.
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL or failed status from FORMAT_DATA.
;
;--

ASSUME	PDT$B_P1_LBSTS	EQ PDT$B_P0_LBSTS+1
PDT$V_LBDG	=	2

DISPLAY_LOOPBACK_STATUS:
	PUSHR	#^M<R7,R8,R9>
	MOVL	#PDT_IN,R8		; Set index into call frame to base
					;  address of PDT for this port.
	ADDL3	(R12)[R8],-		; Get address of local port status.
		#PDT$W_LPORT_STS,R7	;
	ADDL	#SHC$L_PDT_DIF,R7	; Adjust PDT offset to compensate for
					;  portion of PDT not copied.
	BSBW	CHECK_DIF		; Check for change in data since last
					;  update.
	BBS	#PDT$V_LBDG,R7,5$	; Branch if loopback test enabled.
	MOVL	#4,R9			; Set index to point to "N/A" string.
	BRB	20$			; Display the string.
5$:	CLRL	R9			; Assume loopback tests succeeded on
					;  both ports.
	ADDL	#<PDT$B_P0_LBSTS--	; Get address of path A loopback
		PDT$W_LPORT_STS>,R7	;  status.
	BSBW	CHECK_DIF		; Check for change in path A loopback
					;  status.
	BITB	#PDT$M_PRV_LBS,(R7)+	; Path A loopback test succeeded?
	BNEQ	10$			; Branch if so.
	BISL	#2,R9			; Index = index + 2.
10$:	BSBW	CHECK_DIF		; Check for change in path B loopback
					;  status.
	BITB	#PDT$M_PRV_LBS,(R7)	; Path B loopback test suceeded?
	BNEQ	20$			; Branch if so.
	BISL	#1,R9			; Index = index + 1.
20$:	MOVL	R9,R7			; Get index in R7 for DISPLAY_STRING.
	MOVAL	LB_STAT_STRG,R8		; Point to loopback status strings.
	BSBW	DISPLAY_STRING		; Convert index to string and format.
	POPR	#^M<R7,R8,R9>
	RSB



	.SBTTL	-	CHECK_DIF routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine uses the address of the data in R7 to determine which
;	buffer the data is to be extracted from.  It the uses that address
;	to determine where the matching data in the corresponding buffer from
;	the previous snapshot can be found.  The data is then compared and
;	if found to be is different then a flag is set.  The flag is used by
;	the GET_DATA routine to determine when to turn on inverse video.
;
; CALLING SEQUENCE:
;
;	JSB	CHECK_DIF
;
; CALLED BY:
;
;	DISPLAY_PORT_TYPE
;	DISPLAY_PORT_STATUS
;	DISPLAY_SCS_STATE
;	DISPLAY_CON_STATE
;	DISPLAY_PROC_NAME
;	DISPLAY_CABLE_STATUS
;	DISPLAY_RSTATE
;	DISPLAY_CIR_STATE
;	DISPLAY_INCN_TIME
;	DISPLAY_FIELD
;
; INPUTS:
;
;	Address of the data from the most recent snapshot in R7.
;
; IMPLICIT INPUTS:
;
;	Data from the previous snapshot stored in OLD_VAR_BUF and OLD_FIX_BUF.
;
; OUTPUTS:
;
;	Flag set in MISC_FLAGS if new data is different from the old data.
;
; RETURN STATUS:
;
;	None.
;
; REGISTER USAGE:
;
;	R2,R3 -	Used to calculate the address of the data in the old buffer
;	R6 -	Receives the number of bytes of data in the field.  Used to
;		to compare the new data with the old.
;	R7 -	Contains the address of the data.  Used to calculate the
;		address of the data in the old snapshot buffer.
;--

CHECK_DIF:
	PUSHR	#^M<R2,R3,R6>
	CMPL	R7,#SNAP_BUF_END	; Was the data extracted from the fixed
					;  length buffers.
	BLSSU	40$			; Branch if so.
	CMPL	R7,CSB_DSCR+4		; Was the data extracted from the
					;  system block buffer?
	BGEQU	10$			; Branch if not.
	MOVL	SB_DSCR+4,R2		; Get the address of the system block
					;  buffer.
	MOVL	OLD_SB_DSCR+4,R3	; Get address of system block buffer
					;  from previous snapshot.
	BRB	50$			; Jump to common code.
10$:	CMPL	R7,PB_DSCR+4		; Was the data extracted from the
					;  cluster system block buffer?
	BGEQU	20$			; Branch if not.
	MOVL	CSB_DSCR+4,R2		; Get the address of the cluster system
					;  block buffer.
	MOVL	OLD_CSB_DSCR+4,R3	; Get address of cluster system block
					;  buffer from previous snapshot.
	BRB	50$			; Jump to common code.
20$:	CMPL	R7,CDT_DSCR+4		; Was the data extracted from the
					;  path block buffer?
	BGEQU	30$			; Branch if not.
	MOVL	PB_DSCR+4,R2		; Get the address of the path block
					;  buffer.
	MOVL	OLD_PB_DSCR+4,R3	; Get address of path block buffer
					;  from previous snapshot.
	BRB	50$			; Jump to common code.
30$:	MOVL	CDT_DSCR+4,R6		; Get the starting address of the
					;  CDT buffer.
	MOVZWL	CDT_DSCR,R3		; Get the length of the CDT buffer.
	ADDL	R3,R6			; Calculate ending address of CDT
					;  buffer.
	CMPL	R7,R6			; Was the data extracted from the
					;  CDT buffer?
	BGEQU	99$			; Branch if not.
	MOVL	CDT_DSCR+4,R2		; Get the address of the CDT buffer.
	MOVL	OLD_CDT_DSCR+4,R3	; Get address of CDT buffer from
					;  previous snapshot.
	BRB	50$			; Jump to common code.
40$:	MOVAL	FIX_BUF,R2		; Get the starting address of the
					;  fixed length buffers.

	MOVAL	OLD_FIX_BUF,R3		; Get the starting address of the fixed
					;  length buffers from the previous
					;  snapshot.
50$:	SUBL3	R2,R7,R2		; Get the offset into the buffer where
					;  the data is located.
	ADDL	R2,R3			; Get the corresponding address of the
					;  data from the previous snapshot.
	MOVZBW	FD$B_LENGTH(R10),R6	; Get the number of bytes of raw data.
	CMPC	R6,(R7),(R3)		; Compare the old data with the new.
	BEQL	99$			; Branch if they're the same.
	BISL	#MF$M_INVERSE,MISC_FLAGS; Set the inverse video flag.
99$:	POPR	#^M<R2,R3,R6>
	RSB



	.SBTTL	Description of snapshot buffers.
;
;SNAP_BUF:	Start of buffers to be locked.
;
;			+--------+
;CURRENT_REPORT:	|        |   Bit 0 set indicates cluster report.
;			+--------+
;
;			+--------+--------+--------+--------+
;CLASS_SELECT:		| USER selected classes for display |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+--------+--------+
;LOCSYSID:		|	    ID number of the local system.	      |
;			+--------+--------+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;NUM_BUF_DSCR:		|  # of buffer descriptors in use   |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;NUM_FREE_BUF_DSCR:	| # of buffer descriptors available |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;LOC_SB_ADRS:		|   Address of local system block   |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;SB_BUF_PNTR:		|       Pointer into SB buffer	    |
;			+--------+--------+--------+--------+
;			+--------+--------+--------+--------+
;CSB_BUF_PNTR:		|      Pointer into CSB buffer	    |
;			+--------+--------+--------+--------+
;			+--------+--------+--------+--------+
;PB_BUF_PNTR:		|      Pointer into PB buffer	    |
;			+--------+--------+--------+--------+
;			+--------+--------+--------+--------+
;CDT_BUF_PNTR:		|      Pointer into CDT buffer	    |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
; VAR_BUF_ADRS:		|Address of variable length buffers |
;			+--------+--------+--------+--------+
;
; Descriptors for the variable length snapshot buffers.
;
;			+--------+--------+--------+--------+
;SB_DSCR:		|#entrys in buffer|Length of buffer |
;			+--------+--------+--------+--------+
;			|	  Address of buffer	    |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;CSB_DSCR:		|#entrys in buffer|Length of buffer |
;			+--------+--------+--------+--------+
;			|	  Address of buffer	    |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;PB_DSCR:		|#entrys in buffer|Length of buffer |
;			+--------+--------+--------+--------+
;			|	  Address of buffer	    |
;			+--------+--------+--------+--------+
;
;			+--------+--------+--------+--------+
;CDT_DSCR:		|#entrys in buffer|Length of buffer |
;			+--------+--------+--------+--------+
;			|	  Address of buffer	    |
;			+--------+--------+--------+--------+
;
; Buffer for system blocks.
;
;			+--------+--------+--------+--------+
;	  ^ SB$L_FLINK	|   Pointer to next system block    |
;	  |		+-----------------------------------+
;	  | SB$L_BLINK:	|	   SB$SHC$L_NUM_PB	    |
;	  |		+-----------------+--------+--------+
;	  |		|		  |SHC$SB$B|	    |
;	  |		|		  |_DIS_POS|	    |
;			+-----------------+--------+--------+
;    SB$C_LENGTH	|				    |
;			|				    |
;	  |		|				    |
;	  |		|				    |
;	  |		|				    |
;	  |		+--------+--------+--------+--------+
;	  V   SB$L_CSB: |  Pointer to CSB for this system   |
;			+--------+--------+--------+--------+
;			|				    |
;		    	|				    |
;			|				    |
;			~r~	  More system blocks	    ~
;			|				    |
;			|				    |
;			|				    |
;			+--------+--------+--------+--------+
;
;
; Buffer for cluster system blocks.
;
;			+--------+--------+--------+--------+
;		^	|				    |
;		|	|				    |
;	   	|	|				    |
;	   CSB$C_LENGTH	|     One cluster system block      |
;	  	|	|				    |
;	  	|	|				    |
;	  	V	|				    |
;			+--------+--------+--------+--------+
;			|				    |
;			|				    |
;			|				    |
;			~    More cluster system blocks	    ~
;			|				    |
;			|				    |
;			|				    |
;			+--------+--------+--------+--------+
;
;
; Buffer for path blocks.
;
;			+--------+--------+--------+--------+
;		^	|	        Flink		    |
;	  	|	+-----------------------------------+
;	  	|	|	  PB$SHC$L_NUM_CDT	    |
;			+-----------------------------------+
;	   PB$C_LENGTH	|				    |
;			|				    |
;	  	|	|	  One path block	    |
;	  	|	|				    |
;	  	|	|				    |
;	  	V	|				    |
;			+--------+--------+--------+--------+
;			|				    |
;			|				    |
;			|				    |
;			~	  More path blocks	    ~
;			|				    |
;			|				    |
;			|				    |
;			+--------+--------+--------+--------+
;
; Buffer for CDT's.
;
;			+--------+--------+--------+--------+
;		^	|	      FLINK		    |
;	  	|	+-----------------------------------+
;	  	|	|				    |
;			|				    |
;   SHC$C_CDT_LENGTH+32	|             One CDT		    |
;			|   (portion of actual CDT from	    |
;	  	|	|   CDT$L_RCONID to CDT$W_DGREC)    |
;	  	|	|				    |
;	  	V	|				    |
;			+--------+--------+--------+--------+
;			|				    |
;			|				    |
;			|				    |
;			~	  Lots more CDT's	    ~
;			|				    |
;			|				    |
;			|				    |
;			+--------+--------+--------+--------+
;
; Fixed length buffers
;			+--------+--------+--------+--------+
;CLUB_BUF:	^    	|				    |
;		|	|				    |
;	  CLUB$C_LENGTH	|	 Buffer for the CLUB	    |
;		|	|				    |
;		|	|				    |
;		v	+--------+--------+--------+--------+
;			+--------+--------+--------+--------+
;DUMMY_SB:	^    	|				    |
;		|	|				    |
;		|	|				    |
;			|				    |
;	   SB$C_LENGTH	|	 One fake system block	    |
;			|				    |
;		|	|				    |
;		|	|				    |
;		V	|				    |
;			+--------+--------+--------+--------+
;DUMMY_PB:	^    	|				    |
;		|	|				    |
;		|	|				    |
;			|				    |
;	   PB$C_LENGTH	|	 One fake path block	    |
;			|				    |
;		|	|				    |
;		|	|				    |
;		V	|				    |
;			+--------+--------+--------+--------+
;
; Buffer for PDT's.
;
;			+--------+--------+--------+--------+
;PDT_BUF: ^	    ^	|				    |
;	  |	    |	|				    |
;	  |	    |	|				    |
;		    |	|             First PDT		    |
; SHC$L_PDT_LENGTH  |	|    (portion of actual PDT from    |
;		    |	|   PDT$L_MSGHDRSZ to PDT$L_LBDG)   |
;	  |	    |	|				    |
;	  |	    |	|				    |
;	  V	    |	|				    |
;		    |	+--------+--------+--------+--------+
;		    |	|				    |
;			|				    |
;SHC$L_PDT_LENGTH*MAXPDT|				    |
;		    	|				    |
;		    |	|	     Second PDT		    |
;		    |	~	     			    ~
;		    |	|				    |
;		    |	|				    |
;		    V	|				    |
;			+--------+--------+--------+--------+
;
;
; Buffer for miscellaneous port data.
;
;
;			+--------+--------+--------+--------+
;MISC_BUF:		|  	   MB$L_PORT_NAME	    |
;			+--------+--------+--------+--------+
;			|	   MB$L_PORT_NUM	    |
;			+--------+--------+--------+--------+
;			|  	    MB$L_DEVTYPE	    |
;			+--------+--------+--------+--------+
;			|	      MB$L_STS		    |
;			+--------+--------+--------+--------+
;			|  MB$W_ERRCNT    | ERTMAX | ERTCNT |
;			+--------+--------+--------+--------+
;			|	    MB$L_FORM_PB	    |
;			+--------+--------+--------+--------+
;			|	   MB$L_PL_WAITERS	    |
;			+--------+--------+--------+--------+
;			|   MB$W_MSG_FREE |   MB$W_DG_FREE  |
;			+--------+--------+--------+--------+
;			|  MB$W_RSPS_QUED |  MB$W_CMDS_QUED |
;			+--------+--------+--------+--------+
;			+--------+--------+--------+--------+
;MISC_BUF+MISC_BUF_LEN:	|				    |
;			|				    |
;			|				    |
;			|				    |
;			|				    |
;			|      MISC_BUF for second port     |
;			|				    |
;			|				    |
;			|				    |
;			|				    |
;			|				    |
;			+--------+--------+--------+--------+
;
;
;
;SNAP_BUF_END:		End of buffers to be locked.
;
;



	.SBTTL	Snapshot buffers.
	.PSECT	SNAP_DATA,RD,WRT,NOEXE

SNAP_BUF:				; Start of buffers to be locked.

CURRENT_REPORT:				; Indicates which report the user has
	.BYTE	0			;  selected for display.

CLASS_SELECT:				; Indicates which classes the user has
	.LONG	0			;  selected for display.

LOCSYSID:				; ID number of the local system.
	.BLKB	6

NUM_BUF_DSCR:				; Number of buffer descriptors in use.
	.LONG	0

NUM_FREE_BUF_DSCR:			; Number of buffer descriptors
	.LONG	0			;  available.

LOC_SB_ADRS:				; Address of system block for local
	.LONG	0			;  system.

SB_BUF_PNTR:				; Pointer into system block buffer.
	.LONG	0			;
CSB_BUF_PNTR:				; Pointer into cluster system block
	.LONG	0			;  buffer.
PB_BUF_PNTR:				; Pointer in path block buffer.
	.LONG	0			;
CDT_BUF_PNTR:				; Pointer into CDT buffer.
	.LONG	0			;

SB_DSCR:.QUAD	0			; System block buffer.
	
CSB_DSCR:				; Cluster system block buffer.
	.QUAD	0			;

PB_DSCR:.QUAD	0			; Path block buffer.

CDT_DSCR:				; Connection descriptor table buffer.
	.QUAD	0			;

VAR_BUF_ADRS:				; Copy of the variable buffer address
	.LONG	0			;  returned from GET_VM.

FIX_BUF:				; Start of fixed length buffers.

CLUB_BUF:				; Buffer for the club.
	.BLKB	CLUB$C_LENGTH		;

DUMMY_SB:				; Fake system block for formative path
	.BLKB	SB$C_LENGTH		;  blocks without an associated
					;  formative system block.

DUMMY_PB:				; Fake path block for connections in
	.BLKB	PB$C_LENGTH		;  the listen state.

PDT_BUF:
	.BLKB	SHC$L_PDT_LENGTH*MAXPDT	; Buffer for port information.

MISC_BUF:				; Buffer for miscellaneous information.
	.BLKB	MISC_BUF_LEN*2

SNAP_BUF_END:				; End of buffers to be locked.

FIX_BUF_LEN	= .-FIX_BUF
SNAP_BUF_LEN	= .-SNAP_BUF



	.SBTTL	Snapshot routines.
	.PSECT	MAIN,RD,EXE,NOWRT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to extract the data from the SCS database and the
;	CI port database.  This routine is called whenever the interval timer
;	expires or upon completion of parsing and executing a command.
;
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S -
;		ROUTINE=SNAPSHOT
;
; CALLED BY:
;
;	DO_SNAPSHOT
;
;
; IMPLICIT IMPUTS:
;
;	Cluster and port data stored in SCS database and CI port database.
;
;
; IMPLICIT OUTPUTS:
;
;	Extracted data stored in snapshot buffers.  For details see previous
;	section.
;
;
; RETURN STATUS:
;
;	SS$_NORMAL or SS$_NOSUCHNODE returned in R0.
;
;
; SIDE EFFECTS:
;
;	It should be noted that this routine runs at IPL$_SCS and calls a
;	routine CHECK_QUE that runs at IPL 31.  Also both routines and all
;	the buffers used by the routines are locked in memory during execution
;	of this routine.
;
;
; REGISTER USAGE:
;
;	Listed here is a general register usage.  Detailed usage is given in
;	each subsection.
;
;	R3  -	Used as destination pointer when storing structures in buffers.
;	R4  -	Used as a temporary register and by MOVC's.
;	R5  -	Used as a temporary register and by MOVC's.
;	R6  -	Used as a temporary register.
;	R7  -	Used to store the address of the first link in a doubly linked
;		list.
;	R8  -	Used as a temporary register and pointer to the base address to
;		store data in MISC_BUF.
;	R9  -	Used as a temporary register and to save a copy of R3 before
;		R3 is updated to point to next slot in buffer.
;	R10 - 	Used to store the address of the next link in a doubly linked
;	      	list.
;	    -	Used as source pointer when storing structures in buffers.
;--

.ENTRY	SNAPSHOT,^M<R3,R4,R5,R6,R7,R8,R9,R10>
	BBC	#CLS$V_CLUB,-		; Branch if display of the club is
		CLASS_SELECT,5$		;  disabled.
	MOVL	G^CLU$GL_CLUB,R10	; Get address of the club.
	BEQL	5$			; Branch if there isn't a club.
	MOVAL	CLUB_BUF,R3		; Get address to store the club.
	MOVC3	#CLUB$C_LENGTH,(R10),-	; Store club in club buffer.
		(R3)			;
5$:	MOVL	#SS$_NOSUCHNODE,R0	; Assume that there is no cluster.
	CMPL	G^SCS$GQ_CONFIG,-	; Any remote SB's known?
		#SCS$GQ_CONFIG		;
	JEQL	SNAPSHOT_ERR		; If not, exit with error status.
10$:	DSBINT	#IPL$_SCS		; Lock the SCS database.
	BBS	#RPT$V_CLSTR,-		; Branch to cluster snapshot routine
		CURRENT_REPORT,-	;  if we're displaying the cluster
		CLUSTER_SNAP		;  report.
	BRW	LOCAL_SNAP		; Otherwise branch to the local
					;  snapshot routine.

;
; Store the information necessary to display the cluster report.  This includes
; all system blocks, path blocks, and connection descriptors.  Formative path
; blocks and connections descriptors for connections in the listen state will
; also be stored if the user has elected to see them.
;

CLUSTER_SNAP:
	CLRL	LOC_SB_ADRS		; Clear address of local system block.
	CLRL	DUMMY_SB+SB$L_PBFL	; Assume no formative path blocks with
					;  formative system blocks.
	CLRL	DUMMY_PB		; Assume there are no additional
					;  formative path blocks with
					;  associated system blocks.

;
; Store each system block in a singly linked list in SB buffer.
;
; REGISTER USAGE:
;
;	R3  -	Pointer into SB buffer where the system block will be stored.
;	R9  -	Used to save a copy of R3 to be used after R3 is updated to
;		point to the next free slot in SB buffer.
;	R10 -	Pointer to system block in the SCS database.
;

SB_SNAP:MOVL	SB_BUF_PNTR,R3		; Get address of system block buffer.
	MOVL	G^SCS$GQ_CONFIG,R10	; Get address of first system block.
10$:	BBC	#47,SB$B_SYSTEMID(R10),-; Branch if not illegal type or system
		SB_FIRST_LOOP		;  block for UNA.
	MOVL	(R10),R10		; Get address of next system block.
	CMPL	R10,#SCS$GQ_CONFIG	; Any more system blocks?
	JEQL	SB_LOOP_END		; Branch if not.
	BRB	10$			; Otherwise, loop for all system blocks.
;
; The following is skipped on the first pass because the first system block has
; no previous system block to link to.
;

SB_LOOP:DECW	SB_DSCR+2		; Anymore room left in the buffer?
	JEQLU	SB_LOOP_END		; Branch if not.
10$:	MOVL	(R10),R10		; Get address of next system block.
	CMPL	R10,#SCS$GQ_CONFIG	; Any more system blocks?
	JEQL	SB_LOOP_END		; Branch if not.
	BBS	#47,SB$B_SYSTEMID(R10),-; Ignore illegal and UNA system blocks.
		10$			;  
	MOVL	R3,-SB$C_LENGTH(R3)	; Link previous system block to this
					;  one.
SB_FIRST_LOOP:
	MOVL	R3,R9			; Save address where this SB will be
					;  stored.
	MOVC3	#SB$C_LENGTH,(R10),(R3)	; Store system block in SB buffer.
	CLRL	-SB$C_LENGTH(R3)	; Assume no more system blocks.
;
; Save the address of the local system block.  This will be used by the
; LISTENER_SNAP routine to link a dummy path block to the local system block
; if any listeners are found.
;

	TSTL	LOC_SB_ADRS		; Have we already saved the address of
					;  the local system block?
	BNEQ	CSB_SNAP		; Branch if we have.
	CMPL	SB$B_SYSTEMID(R9),-	; Is this system block for the local
		LOCSYSID		; system?
	BNEQ	CSB_SNAP		; Branch if not.
	CMPW	SB$B_SYSTEMID+4(R9),-	; Must check all six bytes of ID.
		LOCSYSID+4		;
	BNEQ	CSB_SNAP		; Branch if no match.
	MOVL	R9,LOC_SB_ADRS		; Save address of local system block.


;
; This code executes if the display of Cluster System Blocks is enabled.
; If there is a CSB associated with the last System Block stored in the SB
; buffer, then it stores the CSB in the CBS buffer and adjusts SB$L_CSB to
; point to the CSB.
;
; INPUTS:
;	R3,R9  - Point to SB buffer where last SB was stored.
;
; REGISTER USAGE:
;
;	R3	- Used to point to CSB buffer where a CSB will be stored.
;	R9 	- Pointer to last SB stored the SB_BUFFER.
;

CSB_SNAP:
	BBC	#CLS$V_CSB,-		; Skip saving of CSB if MEMBERS class
		CLASS_SELECT,PB_SNAP	;  is disabled.
	PUSHR	#^M<R3,R10>
	MOVL	SB$L_CSB(R9),R10	; Get the address of the Cluster System
					;  Block for this system.
	BEQL	CSB_SNAP_END		; Branch if no CSB.
	MOVL	CSB_BUF_PNTR,R3		; Get the address to store the CSB in
					;  the CSB buffer.
	MOVL	R3,SB$L_CSB(R9)		; Save pointer to CSB in SB.
	MOVC3	#CSB$C_LENGTH,(R10),-	; Store the CSB in the CSB buffer.
		(R3)			;
	MOVL	R3,CSB_BUF_PNTR		; Save address to store next CSB.

CSB_SNAP_END:
	POPR	#^M<R3,R10>

;
; Store the path blocks in singly linked lists in PB buffer. Link each list to
; the associated system block by saving the address of the first path block
; at offset SB$L_PBFL in the system block.
;
; Note: This loop does not store formative path blocks. See FORM_PB_SNAP:.
;
; INPUTS:
;
;	R9  -	Address of system block SB buffer that is associated with this
;		path block.  (Passed from SB_SNAP routine)
;	R10 -	Address of system block in SCS database for the last system
;		block stored in SB buffer.
;
; REGISTER USAGE:
;
;	R3  -	Pointer into PB buffer where the path block will be stored.
;	R7  -	Address of link to first path block on the system block.
;	R9  -	Used to save a copy of R3 to be used after R3 is updated to
;		point to the next free slot in PB buffer.
;	R10 -	Pointer to path block in the SCS database.
;

PB_SNAP:PUSHR	#^M<R3,R7,R9,R10>
	CLRL	SB$L_PBFL(R9)		; Assume no paths on this system block.
	MOVL	PB_BUF_PNTR,R3		; Get address of first free slot in
					; path block buffer.
	MOVAL	SB$L_PBFL(R10),R7	; Get address of forward link to first
					;  path block?
	CMPL	SB$L_PBFL(R10),R7	; Are there any paths on this system
					;  block?
	JEQL	PB_LOOP_END		; If not, exit this loop.
	MOVL	R3,SB$L_PBFL(R9)	; Save address of first path block in
					;  associated system block.
	MOVL	R7,R10			; Get a copy of link address in R10.
	MOVL	(R10),R10		; Get forward link to the first path
					;  block.
	BRB	PB_FIRST_LOOP		; Go save the first path block in
					;  PB buffer.

PB_LOOP:
	DECW	PB_DSCR+2		; Any room left in the path block
					;  buffer?
	JEQLU	PB_LOOP_END		; Branch if not.
	MOVL	(R10),R10		; Get forward link to the (next) path
					;  block.
	CMPL	R10,R7			; Does the forward link point back to
					;  first forward link?
	JEQL	PB_LOOP_END		; If so, no more path blocks.
	MOVL	R3,-PB$C_LENGTH(R3)	; Link previous path block to this one.

PB_FIRST_LOOP:
	MOVL	R3,R9			; Save address where this path block
					;  will be stored.
	MOVC3	#PB$C_LENGTH,(R10),(R3)	; Copy path block to PB buffer.
	CLRL	-PB$C_LENGTH(R3)	; Assume no more path blocks.
	CLRL	-PB$C_LENGTH+PB$L_CDTLST(R3)
					; Assume no CDT's on this path block.
	CLRL	-PB$C_LENGTH+PB$SHC$L_NUM_CDT(R3)
;
; Get the number of SCS waiters on each path block by counting the entries
; in the queue at offset PB$L_WAITQFL.  Save the count at the same offset in
; place of the forward link (since it won't be used again)
;
; Fix the port name to be PA%0 rather than PA%"null".
;
; INPUTS:
;
;	R9  -	Address of path block that was last stored in PB buffer.
;		(Passed from PB_SNAP routine)
;	R10 -	Address of path block in the SCS database for the last path
;		block stored in PB buffer.
;
; REGISTER USAGE:
;
;	R7  -	Address of link to first entry in SCS wait queue.
;	R10 -	Pointer to entry in SCS wait queue.
;

SCS_WAITER_SNAP:
	PUSHR	#^M<R7,R10>
	MOVAL	PB$L_WAITQFL(R10),R7	; Get the address of the forward link
					;  for the first entry in the SCS
					;  wait queue.
	MOVL	R7,R10			; Get a copy in R10.

SCS_WAITER_LOOP:
	MOVL	(R10),R10		; Get forward link to next entry in the
					;  SCS wait queue.
	CMPL	(R10),R7		; Does the forward link point back to
					;  the first forward link?
	BEQL	SCS_WT_LP_END		; If so, no more SCS waiters.
	INCL	R0			; Increase count of SCS waiters.
	BRB	SCS_WAITER_LOOP		; Loop for all SCS waiters.

SCS_WT_LP_END:
	MOVL	R0,PB$L_WAITQFL(R9)	; Store the number of SCS waiter at
					;  offset PB$L_WAITQFL in the PB.
	MOVB	#^A/0/,-		; Fix the unit number in the port name
		PB$T_LPORT_NAME+3(R9)	;  to be "0" instead of NULL.

	POPR	#^M<R7,R10>


;
; This routine is used to count the number of connections on a circuit and if
; the display of connections is enabled, to store the connection descriptors in
; CDT buffer.  All the CDT's for connections established over a particular path
; are linked together and the first is linked to the associated path block.
; The message associated with the CDT are also stored in CDT buffer immediately
; following the CDT.  The number of connections on the circuit is stored in
; the path block for the associated circuit at offset PB$SHC$L_NUM_PB.
;
; NOTE: This code does not check for connections that are in the LISTEN state.
;	See LISTEN_CDT_SNAP:.
;
; INPUTS:
;
;	R9  -	Address of path block last stored in PB buffer.
;	R10 -	Address of path block in SCS database for the last path block
;		stored in PB buffer.
;
; REGISTER USAGE:
;
;	R3  -	Pointer into CDT buffer where the CDT will be stored.
;	R4  -	Counter for copying or zeroing message.
;	R5  -	Pointer to message when copying message into CDT buffer.
;	R8  -	Used to count the number of connections on a given path.
;	R10 -	Pointer to CDT in the SCS database.
;

ASSUME	SCS$T_SRC_PROC	EQ SCS$T_DST_PROC+16
ASSUME	SCS$B_CON_DAT	EQ SCS$T_SRC_PROC+16

CDT_SNAP:
	PUSHR	#^M<R3,R10>
	CLRL	R8			; Clear counter for number of
					;  connections.
	MOVL	CDT_BUF_PNTR,R3		; Get address of first free slot in
					;  CDT buffer.
	MOVAL	PB$L_CDTLST(R10),R10	; Get the address of the first forward
					;  link for the CDT's associated with
					;  this path block.
	MOVL	(R10),R10		; Are there any CDTs on this path
					;  block?
5$:	JEQL	CDT_SNAP_DONE		; If not go on to next path block.
	INCL	R8			; Increase count of connections on this
					;  circuit.
	BITL	#CLS$M_CNT!CLS$M_CRD,-	; Is the display of counters or credits
		CLASS_SELECT		;  enabled?
	BNEQ	20$			; Branch if so.
	BBC	#CLS$V_CON,-		; If the display of connections is also
		CLASS_SELECT,30$	;  disabled, then skip storing of CDT.
	CMPW	CDT$W_STATE(R10),-	; Is the connection in the open state?
		#CDT$C_OPEN		;
	BNEQU	10$			; Branch if not.
	BBS	#CLS$V_OPEN_CON,-	; Branch to link first CDT if we're
		CLASS_SELECT,20$	;  displaying open connections.
	BRB	30$			; Otherwise skip first link.
10$:	BBC	#CLS$V_NOOPEN_CON,-	; Branch if we're not displaying
		CLASS_SELECT,30$	;  connections in any other state.
20$:	MOVL	R3,PB$L_CDTLST(R9)	; Else, link the first CDT to the PB.
	BRB	CDT_FIRST_LOOP		; Don't link to previous CDT.

30$:	MOVL	CDT$L_CDTLST(R10),R10	; Get the forward link to the next CDT.
	BRB	5$			; And loop.

CDT_LOOP:
	DECW	CDT_DSCR+2		; Any room left in connections buffer?
	BEQLU	CDT_SNAP_DONE		; Branch if not.
	MOVL	CDT$L_CDTLST(R10),R10	; Get forward link to CDT.
	BEQL	CDT_SNAP_DONE		; Branch if there are no (more) CDT's.
	CMPW	CDT$W_STATE(R10),-	; Is the connection in the open state?
		#CDT$C_OPEN		;
	BNEQU	10$			; Branch if not.
	INCL	R8			; Increase count of connections on this
					;  circuit.
	BITL	#<CLS$M_OPEN_CON!-	; Are we displaying open connections,
		CLS$M_CNT!CLS$M_CRD>,-	;  counters or credits?
		CLASS_SELECT		;
	BNEQ	20$			; Branch if so.
	BRB	CDT_LOOP		; Otherwise, don't link CDT.
10$:	BITL	#<CLS$M_NOOPEN_CON!-	; Are we displaying connections that
		CLS$M_CRD!CLS$M_CRD>,-	;  aren't open, counters, or credits?
		CLASS_SELECT		;  
	BEQL	CDT_LOOP		; If not, don't link CDT.
20$:	MOVL	R3,-			; Link previous CDT to this one.
	-<SHC$C_CDT_LENGTH+32>(R3)	; Total length of CDT is number of
					;  bytes stored + 32 byte message.
CDT_FIRST_LOOP:
	CLRL	(R3)+			; Assume this is the last CDT;
					;  Zero forward link.
	MOVC3	#SHC$C_CDT_LENGTH-4,-	; Save a portion of the CDT in CDT
		SHC$L_CDT_BEGIN(R10),-	;  buffer.  (Length -4 because forward
		(R3)			;  link is not copied.)
					;  Note: R4 is cleared.
	MOVL	CDT$L_SCSMSG(R10),R5	; Is there a message associated with
					;  this CDT?
	BEQL	NO_MESSAGE		; Branch if not.
	MOVAL	SCS$T_DST_PROC(R5),R5	; Get the address of the process names
					;  in the message.
MESSAGE:MOVQ	(R5)+,(R3)+		; Move message 8 bytes at a time.
	AOBLSS	#4,R4,MESSAGE		; Loop for 32 bytes.
	BRB	CDT_LOOP		; Loop for all CDT's.

NO_MESSAGE:
	CLRQ	(R3)+			; Zero out the messages area.
	AOBLSS	#4,R4,NO_MESSAGE	; Loop for 32 bytes.
	BRB	CDT_LOOP		; Loop for all CDT's.

CDT_SNAP_DONE:
	MOVL	R8,PB$SHC$L_NUM_CDT(R9)	; Save number of connections on this
					;  path in the path block.
	MOVL	R3,CDT_BUF_PNTR		; Save address of next free slot in
					;  CDT buffer.
	POPR	#^M<R3,R10>

CDT_SNAP_END:
	BRW	PB_LOOP			; Loop for all path blocks on this
					;  system block.

PB_LOOP_END:
	MOVL	R3,PB_BUF_PNTR		; Save address of next free entry in
					;  PB buffer.
	POPR	#^M<R3,R7,R9,R10>

	BRW	SB_LOOP			; Loop for all system blocks.

SB_LOOP_END:

	MOVL	R3,SB_BUF_PNTR		; Save address of next free entry in
					;  SB buffer.

;
; This routine executes if the display of circuits in states other than open
; is enabled.  It scans the SCS directory and checks for local processes with
; connections in the LISTEN state.  If any listening CDT's are found, they are
; copied into CDT buffer and linked together.  The first CDT is linked to a
; dummy path block which is in turn linked to the system block for the local
; system.  The local process name is copied from the SCS directory entry and
; stored with the CDT.  The remote process name is zero out.
;
; In the event that there is no system block for the local system block, the
; dummy path block is linked to the dummy system block.
;
; REGISTER USAGE:
;
;	R3  -	Pointer into CDT buffer where the CDT will be stored.
;	R4  -	Used to determine the address where the link to the first
;		listening CDT should be stored.  This address will either be
;		in the dummy path block or in the last path block on the local
;		system system block.
;	R5  -	Used to copy the local process name from the directory entry to
;		CDT buffer.
;	R6  -	Pointer to SCS connection descriptor list.
;	R7  -	Pointer to entry in SCS directory.
;	R9  -	Pointer to dummy path block.
;	R10 -	Used to convert index from the SCS directory to the address of
;		the CDT.
;

LISTENER_SNAP:
	BBS	#CLS$V_NOOPEN_CON,-	; Execute this code if display of
		CLASS_SELECT,5$		;  connections in states other than
					;  open is enabled.
	BRW	COMMON_SNAP		; Other wise jump to common code.
5$:	MOVL	CDT_BUF_PNTR,R3		; Get address to store next CDT in
					;  CDT buffer.
	MOVAL	DUMMY_PB,R9		; Get address of dummy path block.
	CLRL	PB$L_CDTLST(R9)		; Assume there are no listeners.
	MOVAL	G^SCS$GQ_DIRECT,R7	; Get address of first SCS directory
					;  forward link.
	MOVL	G^SCS$GL_CDL,R6		; Get the address of the SCS connection
					;  descriptor list.

SCS_DIR_LOOP:
	TSTW	CDT_DSCR+2		; Is there any room on the CDT buffer?
	BEQLU	LISTENER_SNAP_END	; Branch if not.
	MOVL	(R7),R7			; Get the forward link to first SCS
					;  directory entry.
	CMPL	R7,#SCS$GQ_DIRECT	; Does the link point back to the
					;  address of the first link?
	BEQL	LISTENER_SNAP_END	; If so, no more directory entries.
	MOVZWL	SDIR$L_CONID(R7),R10	; Get index value for this CDT.
	MOVL	(R6)[R10],R10		; Get address of the CDT.
	CMPW	CDT$W_STATE(R10),-	; Is this CDT in the "listen" state?
		#CDT$C_LISTEN		;
	BNEQ	SCS_DIR_LOOP		; If not, look at next directory entry.
	TSTL	PB$L_CDTLST(R9)		; Have we already linked the first
					;  listening CDT to the dummy PB?
	BNEQ	30$			; Branch if we have.
	MOVL	R3,PB$L_CDTLST(R9)	; Otherwise, link it now.
	MOVL	LOC_SB_ADRS,R4		; Get the address of the system block
					;  for the local system.
	BNEQ	5$			; Branch if there is a system block for
					;  the local system.
	MOVAL	DUMMY_SB,R4		; Otherwise, get the address of the
					;  dummy system block.
5$:	MOVAL	SB$L_PBFL(R4),R4	; Get the address of the link to the
					;  first path block on this system
					;  block.
	TSTL	(R4)			; Are there any path blocks on this
					;  system block?
	BEQL	20$			; If not, link the dummy path block
					;  directly to the system block.
10$:	MOVL	(R4),R4			; Get the link to the next path block.
	TSTL	(R4)			; Is this the last path block?
	BNEQ	10$			; Loop of not.
20$:	MOVL	R9,(R4)			; Link the dummy PB to the last path
					;  block on this system block.
	BRB	40$			; Don't link listening CDT to any
					;  previous CDT's.
30$:	MOVL	R3,-			; Link previous CDT to this one.
	-<SHC$C_CDT_LENGTH+32>(R3)	; Total length of CDT is number of
					;  bytes stored + 32 byte message.
40$:	CLRL	(R3)+			; Assume this is the last CDT in the
					;  listen state; Zero forward link.
	MOVC3	#SHC$C_CDT_LENGTH-4,-	; Save a portion of the CDT in CDT
		SHC$L_CDT_BEGIN(R10),-	;  buffer.  (Length -4 because forward
		(R3)			;  link is not copied.)
					;  Note: R4 is cleared.
	MOVAL	SDIR$B_PROCNAM(R7),R5	; Get address of local process name in
					;  directory entry.
	MOVQ	(R5)+,(R3)+		; Save local process name immediately
	MOVQ	(R5)+,(R3)+		;  following the CDT.
	CLRQ	(R3)+			; Zero out remote process name.
	CLRQ	(R3)+			; All 16 bytes...
	DECW	CDT_DSCR+2		; Count down the number of entries that
					;  will fit in the CDT buffer.
	BRB	SCS_DIR_LOOP		; Loop for all directory entries.

LISTENER_SNAP_END:
	MOVL	R3,CDT_BUF_PNTR		; Save address to store next CDT.

COMMON_SNAP:
	BBS	#CLS$V_NOOPEN_CIR,-	; Continue with the following code
		CLASS_SELECT,-		;  if we're displaying formative paths.
		LOCAL_SNAP		;
	BRW	SNAPSHOT_END		; Otherwise finish up.

;	
; This code is always executed for the local report.  It is also executed for
; the cluster report if circuits in states other than open are being displayed.
; It scans the device list looking for PAA0 or PAB0 to determine what ports are
; on the local system so that the associated DDBs, UCBs, and PDTs can be
; located.
;
; REGISTER USAGE:
;
;	R3  -	Address in PDT_BUF where the PDT will be stored.
;	R8  -	Pointer into MISC_BUF where miscellaneous information for the
;		port will be stored.  Data for PAA0 starts at MISC_BUF.  Data
;		for PAB0 starts at MISC_BUF+MISC_BUF_LEN.
;	R10 -	Used as pointer to DDB's.
;

LOCAL_SNAP:
	MOVAL	PDT_BUF,R3		; Get address of PDT buffer.
	MOVL	G^IOC$GL_DEVLIST,R10	; Get address of device list.
	MOVAL	MISC_BUF-MISC_BUF_LEN,R8; Initialize pointer to MISC_BUF.

DDB_LOOP:
	MOVL	(R10),R10		; Get address of DDB.
	BNEQ	10$			; Continue if more DDB's.
	BRW	SNAPSHOT_END		; Otherwise, done if no more DDBs.
10$:	CMPL	DDB$T_NAME(R10),#PAAC	; Is this DDB for PAA0?
	BEQL	20$			; Branch if so.
	CMPL	DDB$T_NAME(R10),#PABC	; Is this DDB for PAB0?
	BNEQ	DDB_LOOP		; If not continue looking.
20$:	ADDL	#MISC_BUF_LEN,R8	; Get address to store data for PA%0 in
					;  miscellaneous buffer.
	BBS	#RPT$V_CLSTR,-		; Branch to the formative path block
		CURRENT_REPORT,-	; snapshot routine if we are displaying
		FORM_PB_SNAP		; the cluster report.
	BRW	PORT_SNAP		; Otherwise, branch to the port
					;  snapshot routine.
					
;
; This code executes only if the cluster report is selected and display of
; circuits in states other than open is enabled.  This routine stores formative
; path blocks in PB buffer.  It checks for a formative system block associated
; with the formative path block.
;
; If there is no formative system block associated with the formative path
; block then it links the formative path block to a dummy system block.
;
; If the formative path block does have a formative system block associated it
; checks if the system ID of the formative system block matchs that of any of
; the system blocks stored in SB buffer.  If there is no match, then the
; formative system block is stored in SB buffer and the formative path block is
; linked to it.
;
; If there is a match, then the incarnation number of the formative system
; block is checked against the incarnation number of the system block stored in
; SB buffer.  If the incarnation numbers are the same, then the formative path
; block is linked to the system block in SB buffer.  If the incarnation numbers
; are different, then the formative system block is stored in SB buffer and the
; formative path block is linked to it.
;
; INPUTS:
;
;	R10 -	Points to base address of DDB.
;
; REGISTER USAGE:
;
;	R3  -	Used to scan the system blocks in SB buffer for a system whose
;		ID matches the formative system block.  If found points to
;		the system block.  If not found points to dummy system block.
;	    -	Used to find the address last formative path block on the
;		formative system block or the dummy system block.
;	    -	Used as pointer into PB buffer where the formative path block
;		is to be stored.
;	R7  -	Address of forward link to first formative path block on the
;		PDT.
;	R9  -	Address of formative system block if available.
;	R10 -	Used to get address of UCB from DDB and address of PDT from
;		UCB.
;	    -	Pointer to formative path block.
;
;

FORM_PB_SNAP:
	BBC	#CLS$V_NOOPEN_CIR,-	; If display of circuits in states 
		CLASS_SELECT,DDB_LOOP	;  other than open is disabled then
					;  continue scanning for DDB's.
	PUSHR	#^M<R2,R3,R8,R9,R10>
	MOVL	DDB$L_UCB(R10),R10	; Get address of UCB0 for this port.
	MOVL	UCB$L_PDT(R10),R10	; Get address of PDT for this port.
	JEQL	FORM_PB_DONE		; Branch if no PDT.
	MOVAL	PDT$Q_FORMPB(R10),R7	; Get address of the forward link for
					;  the first formative path block on
					;  this PDT.
	MOVL	R7,R10			; Get copy in R10.
FORM_PB_LOOP:
	MOVL	(R10),R10		; Get address of formative path block.
	CMPL	R10,R7			; Does the forward link point to the
					;  address of the first link?
	JEQL	FORM_PB_DONE		; If so, no (more) formative path
					;  blocks.  Go check for another port.
	MOVL	PB$L_SBLINK(R10),R9	; Get formative system block link.
	BEQL	40$			; Branch if there is no system block
					;  associated with this path block.
	MOVL	VAR_BUF_ADRS,R8		; Point to the system block buffer.
10$:	CMPL	SB$B_SYSTEMID(R8),-	; Does the system ID of the formative
		SB$B_SYSTEMID(R9)	;  system block match the ID of any of
					;  the system blocks stored in SB
					;  buffer?
	BNEQ	20$			; Branch if not.
	CMPW	SB$B_SYSTEMID+4(R8),-	; Check all six bytes.
		SB$B_SYSTEMID+4(R9)	;
	BNEQ	20$			; Branch if no match.
	CMPL	SB$Q_SWINCARN(R8),-	; Does the boot time in the formative
		SB$Q_SWINCARN(R9)	;   system block match the system block
					;   we've found?
	BNEQ	30$			; Branch if not.
	CMPL	SB$Q_SWINCARN+4(R8),-	; Check the full boot time.
		SB$Q_SWINCARN+4(R9)	;
	BEQL	50$			; Branch if the boot time matches.

20$:	MOVL	SB$L_FLINK(R8),R8	; Get address of next system block.
	BNEQ	10$			; Loop for all system blocks in SB
					;  buffer.

;
; Save the formative system block if it's ID doesn't match any of the system
; blocks in SB buffer or if the ID matches, but the incarnation number doesn't.
;

30$:	MOVL	SB_BUF_PNTR,R3		; Get the address in SB buffer to store
					;  system block.
	MOVL	R3,-SB$C_LENGTH(R3)	; Link previous system block to this
					;  one.
	MOVL	R3,R8			; Save the address where this system
					;  block will be stored.
	MOVC3	#SB$C_LENGTH,(R9),(R3)	; Save the system block in SB buffer.
	MOVL	R3,SB_BUF_PNTR		; Save address to store next system
					;  block.
	CLRL	(R8)			; Indicate that this is the last system
					;  block.
	CLRL	SB$L_PBFL(R8)		; Indicate that there are no path
					;  blocks on this system block.
	BRB	50$			; Jump to common code.
40$:	MOVAL	DUMMY_SB,R8		; Get the address of the fake system
					;  block.
50$:	MOVAL	SB$L_PBFL(R8),R8	; Get address of first forward link to
					;  the path blocks on this system
					;  block.
60$:	TSTL	(R8)			; Is this the last formative path
					;  block?
	BEQL	70$			; Branch if so.
	MOVL	(R8),R8			; Get link to next formative PB.
	BRB	60$			; Loop till last FORM_PB is found.
70$:	MOVL	PB_BUF_PNTR,(R8)	; Link the new formative path block
					;  to the last one.
	MOVL	(R8),R3			; Get address where the formative PB
					;  will be stored.
	MOVC3	#PB$C_LENGTH,(R10),(R3)	; Save the formative PB in PB buffer.
	CLRL	-PB$C_LENGTH(R3)	; Indicate that the formative PB is
					;  now the last path block on this
					;  system block.
	CLRL	-PB$C_LENGTH+PB$L_CDTLST(R3)
					; Zero the link to any connections.
	CLRL	-PB$C_LENGTH+PB$SHC$L_NUM_CDT(R3)
					; Zero the number of connections on the
					;  formative path block.
	MOVL	R3,PB_BUF_PNTR		; Save the address to store the next
					;  PB.
	BRW	FORM_PB_LOOP		; Loop for all formative path blocks.

FORM_PB_DONE:
	POPR	#^M<R2,R3,R8,R9,R10>
	BRW	DDB_LOOP		; Go check for another port.

;
; This code executes only if the local port report in selected.  It stores
; miscellaneous data about the port and data from the interlocked queues in
; MISC_BUF.  It stores the PDT's in PDT_BUF.
;
; INPUTS:
;
;	R10 -	Points to base address of DDB.
;	R8  -	Pointer into MISC_BUF where miscellaneous information for the
;		port will be stored.
;
; REGISTER USAGE:
;
;	R7  -	Used to get address of UCB from DDB and address of PDT from
;		UCB.
;	R8  -	Pointer to MISC_BUF.
;	R10 -	Pointer to DDB.
;

PORT_SNAP:

;
; Convert the port name for this port from "PA%" to "PA%0" and save in
; MISC_BUF.
;
	ASHL	#-8,DDB$T_NAME(R10),-	; Get the port name shifted left one
		MB$L_PORT_NAME(R8)	;  byte.
	BISL	#^X30000000,-		; AND in a zero at the end of the name.
		MB$L_PORT_NAME(R8)	;
	CLRL	MB$L_FORM_PB(R8)	; Initialize count of formative path
					;  blocks on this port. (In MISC_BUF)
	MOVL	DDB$L_UCB(R10),R7	; Get address of UCB0 for this port.
	MOVZBL	UCB$B_DEVTYPE(R7),-	; Get the device type for this port
		MB$L_DEVTYPE(R8)	;  from UCB0 and save in MISC_BUF.
	MOVZWL	UCB$W_STS(R7),-		; Get device status for this port
		MB$L_STS(R8)		;  from UCB0 and save in MISC_BUF.
	MOVL	UCB$B_ERTCNT(R7),-	; Get current retry count, maximum
		MB$B_ERTCNT(R8)		;  retry count, and error count from
					;  UCB0 and save in MISC_BUF.
	MOVL	UCB$L_PDT(R7),R7	; Get address of PDT for this port.
	JEQL	FREE_BUF_SNAP		; Branch if no PDT.

;
; Count the number of formative circuits and save in MISC_BUF.
; Save the port number in MISC_BUF.
; Copy a portion of the PDT in PDT_BUF.
; Count the number of pool waiters and store in MISC_BUF.
;
; INPUTS:
;
;	R3  -	Pointer into PDT_BUF where PDT is to be stored.
;	R7  -	Base address of PDT.
;	R8  -	Base address to store data for this port in MISC_BUF.
;
; REGISTER USAGE:
;
;	R5  -	Pointer to formative path blocks.
;	R5  -	Pointer to entries in pool waiter queue.
;	R6  -	Address of link to first formative path block on the PDT.
;	    -	Address of loopback data gram buffer.
;	    -	Pointer to first address in PDT to be saved in PDT_BUF.
;	    -	Address of link to first pool waiter queue entry.
;	R8  -	Pointer to MISC_BUF.
;
	MOVAL	PDT$Q_FORMPB(R7),R6	; Get address of the forward link for
					;  the first formative path block on
					;  this PDT.
	MOVL	R6,R5			; Get copy in R5.

PORT_FORM_PB_LOOP:
	MOVL	(R5),R5			; Get address of formative path block.
	CMPL	R5,R6			; Does the forward link point to the
					;  address of the first link?
	BEQL	PORT_FORM_PB_LOOP_END	; If so, no (more) formative path
					;  blocks.  Go check for another port.
	INCL	MB$L_FORM_PB(R8)	; Increase count of formative circuits.
	BRB	PORT_FORM_PB_LOOP	; Loop for all formative paths.

PORT_FORM_PB_LOOP_END:
	MOVL	PDT$L_LBDG(R7),R6	; Get address of loopback datagram
					;  buffer.
	MOVZBL	PPD$B_PORT(R6),-	; Save the port number of this port in
		MB$L_PORT_NUM(R8)	;  MISC_BUF.
	MOVAL	SHC$L_PDT_BEGIN(R7),R6	; Get address to start copying PDT.
	MOVC3	#SHC$L_PDT_LENGTH,-	; Get a portion of the PDT into
		(R6),(R3)		;  PDT_BUF.
	MOVAL	PDT$L_WAITQFL(R7),R5	; Get address of pool waiter queue
					;  forward link.
	MOVL	R5,R6			; Save a copy in R5.
	CLRL	MB$L_PL_WAITERS(R8)	; Initialize number of pool waiters on
					;  this port.

POOL_WAITER_LOOP:
	MOVL	(R5),R5			; Get first forward link.
	CMPL	R5,R6			; Any (more) pool waiters?
	BEQL	POOL_WAITER_LOOP_END	; Branch if not.
	INCL	MB$L_PL_WAITERS(R8)	; Increment number of pool waiters on
					;  this port.
	BRB	POOL_WAITER_LOOP	; Loop till all pool waiters found.

POOL_WAITER_LOOP_END:

;
; Count the number of entries in the interlocked queue and store in MISC_BUF.
;
; INPUTS:
;
;	R8  -	Pointer into MISC_BUF to store data for the port.
;	R7  -	Pointer to PDT.
;
; REGISTER USAGE:
;
;	R6  -	Pointer to queue to be counted.
;	R7  -	Pointer to PDT.
;	R8  -	Pointer to MISC_BUF.
;	R9  -	Count of entries returned form CHECK_QUE routine.
;

INTERLOCK_SNAP:
	MOVAL	PDT$Q_DFREEQ(R7),R6	; Get address of datagram free queue.
	CLRL	R9			; Initialize count of entries in que.
	BSBW	CHECK_QUE		; Get the number of entries.
	BSBW	CNVRT_ASCII		; Convert result to ascii string.
	MOVW	R9,MB$W_DG_FREE(R8)	; Save number of free datagrams on this
					;  port.
	MOVAL	PDT$Q_MFREEQ(R7),R6	; Get the address of the message free
					;  queue.
	CLRL	R9			; Initialize count of entries in que.
	BSBW	CHECK_QUE		; Get the number of entries.
	BSB	CNVRT_ASCII		; Convert result to ascii string.
	MOVW	R9,MB$W_MSG_FREE(R8)	; Save number of free messages on
					;  this port.
	MOVAL	PDT$Q_COMQL(R7),R6	; Get address of low priority command
					;  queue.
	CLRL	R9			; Initialize count of entries in que.
	BSBW	CHECK_QUE		; Get the number of entries in the low
					;  priority command queue.
	MOVAL	PDT$Q_COMQH(R7),R6	; Get the address of the high priority
					;  command queue.
	BSB	CHECK_QUE		; Get the number of entries in the high
					;  priority command queue and add to
					;  total number of commands queued.
	MOVAL	PDT$Q_COMQ2(R7),R6	; Get the address of command queue 2.
	BSB	CHECK_QUE		; Get the number of entries in command
					;  queue 2 and add to total number of
					;  commands qued.
	MOVAL	PDT$Q_COMQ3(R7),R6	; Get the address of command queue 3.
	BSB	CHECK_QUE		; Get the number of entries in command
					;  queue 3 and add to total number of
					;  commands qued.
	BSB	CNVRT_ASCII		; Convert result to ascii string.
	MOVW	R9,MB$W_CMDS_QUED(R8)	; Save the total number of commands
					;  queue on this port.
	MOVAL	PDT$Q_RSPQ(R7),R6	; Get the address of the response
					;  queue.
	CLRL	R9			; Initialize count of entries in que.
	BSB	CHECK_QUE		; Get the number of entries in the
					;  response queue.
	BSB	CNVRT_ASCII		; Convert result to ascii string.
	MOVW	R9,MB$W_RSPS_QUED(R8)	; Save the number of responses queued
					;  on this port.

;
; Count the number of free buffer descriptors and save in NUM_FREE_BUF_DSCR.
; Calculate the number of buffer descriptors in use and save in NUM_BUF_DSCR.
;
; REGISTER USAGE:
;
;	R6  -	Counter for number of free buffer descriptors.
;	R7  -	Pointer to free buffer descriptors.
;

FREE_BUF_SNAP:
	MOVL	G^SCS$GL_BDT,R7		; Get the address of the buffer
					;  descriptor table header.
	ADDL	#CIBDT$L_FREEBD-CIBD$L_LINK,R7
					; Get the link to the first buffer
					;  descriptor.
	CLRL	R6			; Assume no free buffer descriptors.

FREE_BUF_LOOP:
	MOVL	CIBD$L_LINK(R7),R7	; Are there any (more) free buffer
					;  descriptors?
	BEQL	FREE_BUF_END		; Branch if not.
	INCL	R6			; Increase count of free buffer
					;  descriptors for this port.
 	BRB	FREE_BUF_LOOP		; Loop for all free buffer descriptors.

FREE_BUF_END:
	MOVL	R6,NUM_FREE_BUF_DSCR	; Save number of free buffer
					;  descriptors.
	MOVZWL	G^SCS$GW_BDTCNT,R7	; Get the total number of buffer
					;  descriptors available.
	SUBL3	R6,R7,NUM_BUF_DSCR	; Save the number of buffer descriptors
					;  in use.
	BRW	DDB_LOOP		; Loop for all ports.

PORT_SNAP_END:

SNAPSHOT_END:
	MOVL	#SS$_NORMAL,R0		; Indicate success.

SNAPSHOT_ERR:
	ENBINT				; Lower IPL.
	RET				; And return.


;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts the number of entries found in an interlock queue
;	to an ascii string.  If the number of entries found exceeds QUEUE_LIMIT
;	then a carrot ">" is placed before the count when it is output.
;
; CALLING SEQUENCE:
;
;	JSB	CNVRT_ASCII
;
; CALLED BY:
;
;	INTERLOCK_SNAP
;
; INPUTS:
;
;	Number of entries in the queue in R9.
;
; OUTPUTS:
;
;	Ascii string returned in R9.
;
; RETURN STATUS:
;
;	None.
;--

CNVRT_ASCII:
	CMPB	#QUE_LIMIT,R9		; Does the result equal the limit.
	BEQL	10$			; Branch if so.
	ASHL	#8,R9,R9		; Get the count into the second byte.
	ADDW	#^A/ 0/,R9		; Convert second byte to ascii and make
					;  the first byte a blank.
	BRB	20$			; Branch to common code.
10$:	DECL	R9			; 3 becomes >2.
	ASHL	#8,R9,R9		; Get the count into the second byte.
	ADDW	#^A/>0/,R9		; Convert second byte to ascii and make
					;  the first byte a ">"
20$:	RSB


	.SBTTL		-	Interlock Queue routine.
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to count the number of entries in an interlocked
;	 queue.  The number of entries found is returned in R9.  Note that R9
;	 is not cleared by this routine so that R9 can be used to count the
;	 total number of entries in several queues if this routine is called
;	 repeatedly.  Since this routine executes at IPL 31 the maximum number
;	 of entries counted by this routine has been limited to 3.
;
; CALLING SEQUENCE:
;
;	JSB CHECK_QUE	
;
; CALLED BY:
;
;	INTERLOCK_SNAP
;
; INPUTS:
;
;	R6  = Address of queue for which entries are to be counted.
;
; OUTPUTS:
;
;	The number of entries in the queue is added to R9.
;
; IMPLICIT OUTPUTS:
;
;	R5 scratched.
;
; RETURN STATUS:
;
;	NORMAL or SS$_INTERLOCK status returned in R0.
;
; REGISTER USAGE:
;
;	R1 -	Interlock retry counter.
;	R4 - 	Offset to next queue entry.
;	R5 -	Address of queue entry.
;	R6 -	Address of first entry in the queue.
;	R9 -	Counter for number of entries in the queue.
;
;--

CHECK_QUE:
	MOVL	#SS$_INTERLOCK,R0	; Assume interlock failure.
	CLRL	R1			; Initialize interlock retry counter.
	MOVL	R6,R5			; Save copy of queue address in R5.
	DSBINT				; Disable interupts.
	BICL3	#1,(R5),R4		; Clear interlock bit in first
					;  self-relative offset.

WAS_LOCKED:
	AOBLSS	G^EXE$GL_LOCKRTRY,R1,-	; Try to lock again if we still have
		TRY_LOCK		;  time.
	BRB	LOCK_FAIL		; Otherwise, return with failure.

TRY_LOCK:
	BBSSI	#0,(R6),WAS_LOCKED	; Try to lock the queue.

LOOP:	MOVAB	(R5)[R4],R5		; Get forward link to next entry.
	CMPL	R5,R6			; Does this link point back to the
					;  first link?
	BEQL	10$			; Branch if it does.
	MOVL	(R5),R4			; Get next relative offset.
	AOBLSS	#QUE_LIMIT,R9,LOOP	; Increment number of entries and 
					;  loop if limit not exceeded.

10$:	BBCCI	#0,(R6),LOWERIPL	; Unlock the queue.

LOWERIPL:
	MOVL	#SS$_NORMAL,R0		; Indicate success.

LOCK_FAIL:
	ENBINT				; Enable interupts.
	RSB

SNAP_END:



	.PSECT	SNAP_DATA,RD,WRT,NOEXE

;
; This buffer has been placed here so that the fixed length snapshot buffers
; can be locked in memory at the same time as the snapshot routines.  The
; program will not assemble if this buffer is placed before the snapshot
; buffers.  (For some reason FIX_BUF_LEN cannot be resolved)
;

OLD_FIX_BUF:				; Copy of fix length buffer from
	.BLKB	FIX_BUF_LEN		;  previous snapshot.  No need to
					;  lock this buffer.

	.SBTTL		-	GET_NUM_PB
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to count the number of circuits on a system.
;	It uses the information stored in PB buffer by the SNAPSHOT
;	routine to count the path blocks.  The number of circuits is stored in
;	the associated system block.
;
;	This code is separated from the snapshot routine to minimize time spent
;	at raised IPL.
;
; CALLING SEQUENCE:
;
;	JSB GET_NUM_PB
;
;
; IMPLICIT INPUTS:
;
;	SNAPSHOT routine has been executed and the snapshot data is stored in
;	SNAP_BUF.
;
; OUTPUTS:
;
;	Number of path blocks on each system block stored in the respective
;	system block at offset SB$SHC$L_NUM_PB.
;
; REGISTER USAGE:
;
;	R2  -	Counts the number of path blocks.
;	R10 -	Points to the first longword of a path block in PB buffer.
;	R11 -	Points to the first longword of a connection descriptor in
;		CDT buffer.
;
;--

GET_NUM_PB:
	PUSHR	#^M<R2,R10,R11>
	MOVL	VAR_BUF,R11		; Get address of first system block.
10$:	CLRL	R2			; Clear counter for number of paths on
					;  this system block.
	MOVL	SB$L_PBFL(R11),R10	; Get address of first path block on
					;  this system block.
	BEQL	40$			; Branch if there are no circuits on
					;  this system.
20$:	CMPW	PB$W_STATE(R10),-	; Is the circuit in the open state?
		#PB$C_OPEN		;
	BNEQ	30$			; If not don't count it.
	INCL	R2			; Increase count of path blocks on this
					;  system block.
30$:	MOVL	(R10),R10		; Get address of next path block.
	BNEQ	20$			; Branch if no more circuits on this
					;  system.
40$:	MOVL	R2,SB$SHC$L_NUM_PB(R11)	; Save number of paths on the system
					;  block.
	MOVL	(R11),R11		; Get address of next system block.
	BNEQ	10$			; Loop for all systems in the cluster.
	POPR	#^M<R2,R10,R11>
	RSB


	.SBTTL	Parser State Table.

	$INIT_STATE	CMD_STATE,CMD_KEY

	$STATE	CMD_START

	$TRAN	'!',TPA$_EXIT		; Ignore comments.

	$TRAN	'SHOW',SHOW		; Command "SHOW".

	$TRAN	'ADD',ADD		; Command "ADD".

	$TRAN	'REMOVE',REMOVE		; Command "REMOVE".

	$TRAN	'SET',SET		; Command "SET".

	$TRAN	'HELP',HELP		; Command "HELP".

	$TRAN	'EXIT',TPA$_EXIT,-	; Command "EXIT".
		CNTRLC_AST_DEL		;

	$TRAN	'INITIALIZE',TPA$_EXIT,-; Command "INITIALIZE".
		RESET

	$TRAN	'@',TPA$_EXIT,EXECUTE	; Execute procedure command.

;
; Translate the SHOW CLUSTER and SHOW LOCAL commands.
;
	$STATE	SHOW

	$TRAN	TPA$_EOS,TPA$_EXIT,-	; Return if end of string.
		REFRESH

	$TRAN	'CLUSTER',TPA$_EXIT,-	; "SHOW CLUSTER".
		SHOW_CLUSTER		;

	$TRAN	'LOCAL_PORTS',-		; "SHOW LOCAL_PORTS".
		TPA$_EXIT,SHOW_LOCAL	;



;
; Translate the add "class" or "field-name" commands.
;
	$STATE	ADD

	$TRAN	TPA$_EOS,TPA$_EXIT,-	; Return if end of string.
		REFRESH

	$TRAN	'CLUSTER',ADD_CLUSTER,-	; "ADD CLUSTER"
		,,TKN_DSCR		;

	$TRAN	'SYSTEMS',ADD_SYS,-	; "ADD SYSTEMS".
		,,TKN_DSCR		;

	$TRAN	'MEMBERS',ADD_MEMBERS,-	; "ADD MEMBERS.
		,,TKN_DSCR		;

	$TRAN	'CONNECTIONS',ADD_CON,-	; "ADD CONNECTIONS".
		,,TKN_DSCR		;

	$TRAN	'CIRCUITS',ADD_CIR,-	; "ADD CIRCUITS".
		,,TKN_DSCR		;

	$TRAN	'COUNTERS',-		; "ADD COUNTERS".
		ADD_COUNTERS,-		;
		,,TKN_DSCR		;

	$TRAN	'CREDITS',ADD_CREDITS,-	; "ADD CREDITS".
		,,TKN_DSCR		;

	$TRAN	'LOCAL_PORTS',-		; "ADD LOCAL_PORTS".
		ADD_LOCAL_PORTS,-	;
		,,TKN_DSCR		;

	$TRAN	'ERRORS',ADD_ERRORS,-	; "ADD ERRORS".
		,,TKN_DSCR		;

	$TRAN	TPA$_SYMBOL,,ADD_FIELD	; "ADD field-name".

	$STATE	ADD_NEXT_CLASS
	$TRAN	<','>,ADD		; Loop if another class was
					;  specified.
	$TRAN	'!',TPA$_EXIT,REFRESH	; Allow comments...
	$TRAN	TPA$_EOS,TPA$_EXIT,-	;  or end of string.
		REFRESH			;
	$TRAN	TPA$_LAMBDA,TPA$_FAIL,-	;
		REFRESH			; Anything else is an error.


;
; ADD CLUSTER
;

	$STATE	ADD_CLUSTER

	$TRAN	'/',ADD_CLUSTER_ALL

	$TRAN	TPA$_LAMBDA,-
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_CLUB		;

	$STATE	ADD_CLUSTER_ALL
	$TRAN	'ALL',ADD_NEXT_CLASS,-	; ADD CLUSTER/ALL
		ADD_ALL_FIELDS,,,-	;
		CLS$M_CLUB		;

;
; ADD MEMBERS
;

	$STATE	ADD_MEMBERS

	$TRAN	'/',ADD_MEMBERS_QUAL

	$TRAN	TPA$_LAMBDA,-
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_CSB		;

	$STATE	ADD_MEMBERS_QUAL
	$TRAN	'ALL',ADD_NEXT_CLASS,-	; ADD MEMBERS/ALL
		ADD_ALL_FIELDS,,,-	;
		CLS$M_CSB		;

;
; ADD COUNTERS
;

	$STATE	ADD_COUNTERS

	$TRAN	'/',ADD_COUNTERS_QUAL

	$TRAN	TPA$_LAMBDA,-
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_CNT		;

	$STATE	ADD_COUNTERS_QUAL
	$TRAN	'ALL',ADD_NEXT_CLASS,-	; ADD COUNTERS/ALL
		ADD_ALL_FIELDS,,,-	;
		CLS$M_CNT		;


;
; ADD CREDITS
;

	$STATE	ADD_CREDITS

	$TRAN	'/',ADD_CREDITS_QUAL

	$TRAN	TPA$_LAMBDA,-
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_CRD		;

	$STATE	ADD_CREDITS_QUAL
	$TRAN	'ALL',ADD_NEXT_CLASS,-	; ADD CREDITS/ALL
		ADD_ALL_FIELDS,,,-	;
		CLS$M_CRD		;


;
; ADD ERRORS
;

	$STATE	ADD_ERRORS

	$TRAN	'/',ADD_ERRORS_QUAL

	$TRAN	TPA$_LAMBDA,-
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_ERR		;

	$STATE	ADD_ERRORS_QUAL
	$TRAN	'ALL',ADD_NEXT_CLASS,-	; ADD ERRORS/ALL
		ADD_ALL_FIELDS,,,-	;
		CLS$M_ERR		;

;
; ADD LOCAL_PORTS
;

	$STATE	ADD_LOCAL_PORTS

	$TRAN	'/',ADD_LOCAL_PORTS_QUAL

	$TRAN	TPA$_LAMBDA,-
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_LPRT		;

	$STATE	ADD_LOCAL_PORTS_QUAL
	$TRAN	'ALL',ADD_NEXT_CLASS,-	; ADD LOCAL_PORTS/ALL
		ADD_ALL_FIELDS,,,-	;
		CLS$M_LPRT		;



;
; ADD SYSTEMS
;
	$STATE	ADD_SYS

	$TRAN	'/',ADD_SYS_QUAL	; Go to ADD_SYS_QUAL state if qualifier
					;  is present.

	$TRAN	TPA$_LAMBDA,-		; Otherwise just ADD SYSTEMS.
		ADD_NEXT_CLASS,-	;
		INCLUDE_CLASS,,,-	;
		CLS$M_SYS		;

;
; Process ADD SYSTEMS qualifiers.
;
	$STATE	ADD_SYS_QUAL

	$TRAN	'ALL',-			; ADD SYSTEMS/ALL
		NEXT_ADD_SYS_QUAL,-	;
		ADD_ALL_FIELDS,,,-	;
		CLS$M_SYS		;
	$TRAN	'ID',ADD_SYS_ID		; ADD SYSTEM/ID
	$TRAN	'TYPE',ADD_SYS_TYPE	; ADD SYSTEM/TYPE
	$TRAN	'NODE',ADD_SYS_NODE	; ADD SYSTEM/NODE
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

;
; Loop for multiple qualifiers on the SYSTEMS class.
;
	$STATE NEXT_ADD_SYS_QUAL
	$TRAN	'/',ADD_SYS_QUAL
	$TRAN	TPA$_LAMBDA,ADD_NEXT_CLASS



;
; Process ADD SYSTEMS/ID=system_id
;	  ADD SYSTEMS/ID=(system_id,...)

	$STATE	ADD_SYS_ID
	$TRAN	'='
	$STATE
	$TRAN	'(',ADD_ID_LOOP		; Go parse a list of ID's
	$TRAN	TPA$_LAMBDA,		; Go parse a single ID
	$STATE
	$TRAN	!ADD_SYS_ID_STRING,-	;
		NEXT_ADD_SYS_QUAL	;

	$STATE	ADD_ID_LOOP		; Parse a list of ID numbers till a ")"
					;  is found.
	$TRAN	!ADD_SYS_ID_STRING	; 
	$STATE
	$TRAN	<','>,ADD_ID_LOOP	; Go parse a single ID
	$TRAN	')',NEXT_ADD_SYS_QUAL	; Exit loop if ")" found.

	$STATE	ADD_SYS_ID_STRING	; Parse a single ID

	$TRAN	TPA$_STRING,,,,TKN_DSCR	; Save address of string.
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,-	; Call REM_ID to remove system from
		REM_ID			;  disabled list.




;
; Process ADD SYSTEMS/TYPE=hw_type
;	  ADD SYSTEMS/TYPE=(hw_type,...)

	$STATE	ADD_SYS_TYPE
	$TRAN	'='
	$STATE
	$TRAN	'(',ADD_SYS_TYPE_LOOP	; Go parse a list of system types.
	$TRAN	TPA$_LAMBDA,		; Go parse a single system type.
	$STATE
	$TRAN	!ADD_SYS_TYPE_STRING,-;
		NEXT_ADD_SYS_QUAL	;

	$STATE	ADD_SYS_TYPE_LOOP	; Parse a list of system types till a
					;  ")" is found.
	$TRAN	!ADD_SYS_TYPE_STRING	; 
	$STATE
	$TRAN	<','>,ADD_SYS_TYPE_LOOP	; Go parse a single system type.
	$TRAN	')',NEXT_ADD_SYS_QUAL	; Exit loop if ")" found.


	$STATE	ADD_SYS_TYPE_STRING	; Parse a single system type

	$TRAN	'ALL',TPA$_EXIT,-	; "ADD SYSTEMS/TYPE=ALL" - Add all
		INCLUDE_CLASS,,,-	; types of systems to the display.
		CLS$M_ALL_SYS

	$TRAN	'V780',TPA$_EXIT,-	; "ADD SYSTEMS/TYPE=780" - Add only
		INCLUDE_CLASS,,,-	;   11/780 systems to the display.
		CLS$M_780_SYS		;  

	$TRAN	'V785',TPA$_EXIT,-	; "ADD SYSTEMS/TYPE=785" - Add only
		INCLUDE_CLASS,,,-	;   11/785 systems to the display.
		CLS$M_785_SYS		;  

	$TRAN	'V750',TPA$_EXIT,-	; "ADD SYSTEMS/TYPE=750" - Add only
		INCLUDE_CLASS,,,-	;   11/750 systems to the display.
		CLS$M_750_SYS		;  

	$TRAN	'HS50',TPA$_EXIT,-	; "ADD SYSTEMS/TYPE=HS50" - Add only
		INCLUDE_CLASS,,,-	;   HSC50 systems to the display.
		CLS$M_HSC50_SYS		;

	$TRAN	'HS60',TPA$_EXIT,-	; "ADD SYSTEMS/TYPE=HS60" - Add only
		INCLUDE_CLASS,,,-	;   HSC60 systems to the display.
		CLS$M_HSC60_SYS		;

	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other type is an error.



;
; Process ADD SYSTEMS/NODE=nodename
;	  ADD SYSTEMS/NODE=(nodename,...)

	$STATE	ADD_SYS_NODE
	$TRAN	'='
	$STATE
	$TRAN	'(',ADD_NODE_LOOP	; Go parse a list of nodenames
	$TRAN	TPA$_LAMBDA		; Go parse a single nodename
	$STATE
	$TRAN	!ADD_SYS_NODE_STRING,-	;
		NEXT_ADD_SYS_QUAL	;

	$STATE	ADD_NODE_LOOP		; Parse a list of nodenames till a ")"
					;  is found.
	$TRAN	!ADD_SYS_NODE_STRING	; Go parse a nodename.
	$STATE
	$TRAN	<','>,ADD_NODE_LOOP	; Loop if "," found.
	$TRAN	')',NEXT_ADD_SYS_QUAL	; Until a ")" is found.

	$STATE	ADD_SYS_NODE_STRING	; Parse a single nodename
	$TRAN	TPA$_STRING,,,,TKN_DSCR	; Save address of string.
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,-	; Call ADD_NODE.
		ADD_NODE



;
; ADD CIRCUITS
;
	$STATE	ADD_CIR

	$TRAN	'/',ADD_CIR_QUAL	; Go to ADD_CIR_QUAL state if qualifier
					;  is present.

	$TRAN	TPA$_LAMBDA,-		; Otherwise add all types of circuits
		ADD_NEXT_CLASS,-	;  to the display.
		INCLUDE_CLASS,,,-	;
		CLS$M_ALL_CIR		;

;
; Process ADD CIRCUITS qualifiers.
;
	$STATE	ADD_CIR_QUAL

	$TRAN	'ALL',-			; ADD CIRCUITS/ALL
		NEXT_ADD_CIR_QUAL,-	;
		ADD_ALL_FIELDS,,,-	;
		CLS$M_ALL_CIR
	$TRAN	'TYPE',ADD_CIR_TYPE	; ADD CIRCUITS/TYPE
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

;
; Loop for multiple qualifiers on the CIRCUITS class.
;
	$STATE NEXT_ADD_CIR_QUAL
	$TRAN	'/',ADD_CIR_QUAL
	$TRAN	TPA$_LAMBDA,ADD_NEXT_CLASS

	$STATE	ADD_CIR_TYPE
	$TRAN	'='
	$STATE
	$TRAN	'(',ADD_CIR_TYPE_LOOP	; Go parse a list of circuit types.
	$TRAN	TPA$_LAMBDA,		; Go parse a single circuit type.
	$STATE
	$TRAN	!ADD_CIR_TYPE_STRING,-	;
		NEXT_ADD_CIR_QUAL	;

	$STATE	ADD_CIR_TYPE_LOOP	; Parse a list of circuit types till a
					;  ")" is found.
	$TRAN	!ADD_CIR_TYPE_STRING	; 
	$STATE
	$TRAN	<','>,ADD_CIR_TYPE_LOOP	; Go parse a single circuit type.
	$TRAN	')',NEXT_ADD_CIR_QUAL	; Exit loop if ")" found.


	$STATE	ADD_CIR_TYPE_STRING	; Parse a single circuit type.

	$TRAN	'ALL',TPA$_EXIT,-	; "ADD CIRCUITS/TYPE=ALL" - Add all
		INCLUDE_CLASS,,,-	; types of circuits to the display.
		CLS$M_ALL_CIR

	$TRAN	'OPEN',TPA$_EXIT,-	; "ADD CIRCUITS/OPEN" - Add circuits in
		INCLUDE_CLASS,,,-	;  the open state to the display.
		CLS$M_CIR!CLS$M_OPEN_CIR;

	$TRAN	'NOOPEN',TPA$_EXIT,-	; "ADD CIRCUITS/NOOPEN" - Add circuits
		INCLUDE_CLASS,,,-	;  in non-open states to the display.
		CLS$M_CIR!CLS$M_NOOPEN_CIR

	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other type is an error.



;
; ADD CONNECTIONS
;
	$STATE	ADD_CON

	$TRAN	'/',ADD_CON_QUAL	; Go to ADD_CON_QUAL state if qualifier
					;  is present.

	$TRAN	TPA$_LAMBDA,-		; Otherwise add all types of connections
		ADD_NEXT_CLASS,-	;  to the display.
		INCLUDE_CLASS,,,-	;
		CLS$M_ALL_CON		;

;
; Process ADD CONNECTIONS qualifiers.
;
	$STATE	ADD_CON_QUAL

	$TRAN	'ALL',-			; ADD CONNECTIONS/ALL
		NEXT_ADD_CON_QUAL,-	;
		ADD_ALL_FIELDS,,,-	;
		CLS$M_ALL_CON
	$TRAN	'TYPE',ADD_CON_TYPE	; ADD CONNECTIONS/TYPE
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

;
; Loop for multiple qualifiers on the CONNECTIONS class.
;
	$STATE NEXT_ADD_CON_QUAL
	$TRAN	'/',ADD_CON_QUAL
	$TRAN	TPA$_LAMBDA,ADD_NEXT_CLASS

	$STATE	ADD_CON_TYPE
	$TRAN	'='
	$STATE
	$TRAN	'(',ADD_CON_TYPE_LOOP	; Go parse a list of connection types.
	$TRAN	TPA$_LAMBDA,		; Go parse a single connection type.
	$STATE
	$TRAN	!ADD_CON_TYPE_STRING,-	;
		NEXT_ADD_CON_QUAL	;


	$STATE	ADD_CON_TYPE_LOOP	; Parse a list of connection types till
					;  a ")" is found.
	$TRAN	!ADD_CON_TYPE_STRING	; 
	$STATE
	$TRAN	<','>,ADD_CON_TYPE_LOOP	; Go parse a single connection type.
	$TRAN	')',NEXT_ADD_CON_QUAL	; Exit loop if ")" found.


	$STATE	ADD_CON_TYPE_STRING	; Parse a single connection type.

	$TRAN	'ALL',TPA$_EXIT,-	; "ADD CONNECTION/TYPE=ALL" - Add all
		INCLUDE_CLASS,,,-	; types of connections to the display.
		CLS$M_ALL_CON

	$TRAN	'OPEN',TPA$_EXIT,-	; "ADD CONNECTIONS/OPEN" - Add 
		INCLUDE_CLASS,,,-	;  connections in the open state to the
		CLS$M_CON!CLS$M_OPEN_CON;  display.

	$TRAN	'NOOPEN',TPA$_EXIT,-	; "ADD CONNECTIONS/NOOPEN" - Add
		INCLUDE_CLASS,,,-	;  connections in non-open states to
		CLS$M_CON!CLS$M_NOOPEN_CON  ;  the display.

	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other type is an error.



;
; Translate the REMOVE "class" or "field-name" commands.
;
	$STATE	REMOVE

	$TRAN	TPA$_EOS,TPA$_EXIT,-	; Return if end of string.
		REFRESH

	$TRAN	'CLUSTER',REM_CLUSTER,-	; "REMOVE CLUSTER"
		,,TKN_DSCR		;

	$TRAN	'SYSTEMS',REM_SYS,-	; "REMOVE SYSTEMS".
		,,TKN_DSCR		;

	$TRAN	'MEMBERS',REM_MEMBERS,-	; "REMOVE MEMBERS".
		,,TKN_DSCR		;

	$TRAN	'CONNECTIONS',REM_CON,-	; "REMOVE CONNECTIONS".
		,,TKN_DSCR		;

	$TRAN	'CIRCUITS',REM_CIR,-	; "REMOVE CIRCUITS".
		,,TKN_DSCR		;

	$TRAN	'COUNTERS',-		; "REMOVE COUNTERS".
		REM_COUNTERS,-		;
		,,TKN_DSCR		;

	$TRAN	'CREDITS',REM_CREDITS,-	; "REMOVE CREDITS".
		,,TKN_DSCR		;

	$TRAN	'ERRORS',REM_ERRORS,-	; "REMOVE ERRORS".
		,,TKN_DSCR		;

	$TRAN	'LOCAL_PORTS',-		; "REMOVE LOCAL_PORTS".
		REM_LOCAL_PORTS,-	;
		,,TKN_DSCR		;

	$TRAN	TPA$_SYMBOL,,-		; "REMOVE field-name".
		REMOVE_FIELD,-		;
		,,TKN_DSCR		;


	$STATE	REM_NEXT_CLASS
	$TRAN	<','>,REMOVE		; Loop if another class was
					;  specified.
	$TRAN	'!',TPA$_EXIT,REFRESH	; Allow comments...
	$TRAN	TPA$_EOS,TPA$_EXIT,-	;
		REFRESH			;  or end of string.
	$TRAN	TPA$_LAMBDA,TPA$_FAIL,-	;
		REFRESH			; Anything else is an error.



;
; REMOVE CLUSTER
;

	$STATE	REM_CLUSTER		;
	$TRAN	TPA$_LAMBDA,-		;
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_CLUB		;

;
; REMOVE MEMBERS
;

	$STATE	REM_MEMBERS		;
	$TRAN	TPA$_LAMBDA,-		;
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_CSB		;

;
; REMOVE COUNTERS
;
	$STATE	REM_COUNTERS
	$TRAN	TPA$_LAMBDA,-		;
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_CNT		;

;
; REMOVE CREDITS
;
	$STATE	REM_CREDITS
	$TRAN	TPA$_LAMBDA,-		;
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_CRD		;

;
; REMOVE LOCAL_PORTS
;

	$STATE	REM_LOCAL_PORTS
	$TRAN	TPA$_LAMBDA,-		;
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_LPRT		;

;
; REMOVE ERRORS
;

	$STATE	REM_ERRORS
	$TRAN	TPA$_LAMBDA,-		;
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_ERR		;

;
; REMOVE SYSTEMS
;
	$STATE	REM_SYS

	$TRAN	'/',REM_SYS_QUAL	; Go to REM_SYS_QUAL state if
					;  qualifier is present.
	$TRAN	TPA$_LAMBDA,-		; Otherwise just REMOVE SYSTEMS.
		REM_NEXT_CLASS,-	;
		EXCLUDE_CLASS,,,-	;
		CLS$M_SYS		;

;
; Process REMOVE SYSTEMS qualifiers.
;
	$STATE	REM_SYS_QUAL

	$TRAN	'ID',REM_SYS_ID		; REMOVE SYSTEM/ID
	$TRAN	'TYPE',REM_SYS_TYPE	; REMOVE SYSTEM/TYPE
	$TRAN	'NODE',REM_SYS_NODE	; REMOVE SYSTEM/NODE
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

;
; Loop for multiple qualifiers on the SYSTEMS class.
;
	$STATE NEXT_REM_SYS_QUAL
	$TRAN	'/',REM_SYS_QUAL
	$TRAN	TPA$_LAMBDA,REM_NEXT_CLASS



;
; Process REMOVE SYSTEMS/ID=system_id
;	  REMOVE SYSTEMS/ID=(system_id,...)

	$STATE	REM_SYS_ID
	$TRAN	'='
	$STATE
	$TRAN	'(',REM_ID_LOOP		; Go parse a list of ID's
	$TRAN	TPA$_LAMBDA,		; Go parse a single ID
	$STATE
	$TRAN	!REM_SYS_ID_STRING,-	;
		NEXT_REM_SYS_QUAL	;

	$STATE	REM_ID_LOOP		; Parse a list of ID numbers till a ")"
					;  is found.
	$TRAN	!REM_SYS_ID_STRING	; 
	$STATE
	$TRAN	<','>,REM_ID_LOOP	; Go parse a single ID
	$TRAN	')',NEXT_REM_SYS_QUAL	; Exit loop if ")" found.

	$STATE	REM_SYS_ID_STRING	; Parse a single ID

	$TRAN	TPA$_STRING,,,,TKN_DSCR	; Save address of string.
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,-	; Call ADD_ID to add system to
		ADD_ID			;  disabled list.



;
; Process REMOVE SYSTEMS/TYPE=hw_type
;	  REMOVE SYSTEMS/TYPE=(hw_type,...)

	$STATE	REM_SYS_TYPE
	$TRAN	'='
	$STATE
	$TRAN	'(',REM_SYS_TYPE_LOOP	; Go parse a list of system types.
	$TRAN	TPA$_LAMBDA,		; Go parse a single system type.
	$STATE
	$TRAN	!REM_SYS_TYPE_STRING,-	;
		NEXT_REM_SYS_QUAL	;

	$STATE	REM_SYS_TYPE_LOOP	; Parse a list of system types till a
					;  ")" is found.
	$TRAN	!REM_SYS_TYPE_STRING	; 
	$STATE
	$TRAN	<','>,REM_SYS_TYPE_LOOP	; Go parse a single system type.
	$TRAN	')',NEXT_REM_SYS_QUAL	; Exit loop if ")" found.


	$STATE	REM_SYS_TYPE_STRING	; Parse a single system type

	$TRAN	'ALL',TPA$_EXIT,-	; "REMOVE SYSTEMS/TYPE=ALL" - Remove all
		EXCLUDE_CLASS,,,-	; types of systems from the display.
		CLS$M_ALL_SYS

	$TRAN	'V780',TPA$_EXIT,-	; "REMOVE SYSTEMS/TYPE=780" - Remove
		EXCLUDE_CLASS,,,-	;  only 11/780 systems from the display.
		CLS$M_780_SYS		;

	$TRAN	'V785',TPA$_EXIT,-	; "REMOVE SYSTEMS/TYPE=785" - Remove
		EXCLUDE_CLASS,,,-	;  only 11/785 systems from the display.
		CLS$M_785_SYS		;

	$TRAN	'V750',TPA$_EXIT,-	; "REMOVE SYSTEMS/TYPE=750" - Remove
		EXCLUDE_CLASS,,,-	;  only 11/750 systems from the display.
		CLS$M_750_SYS		;

	$TRAN	'HS50',TPA$_EXIT,-	; "REMOVE SYSTEMS/TYPE=HS50" - Remove
		EXCLUDE_CLASS,,,-	;  only HSC50 systems from the display.
		CLS$M_HSC50_SYS		;

	$TRAN	'HS60',TPA$_EXIT,-	; "REMOVE SYSTEMS/TYPE=HS60" - Remove
		EXCLUDE_CLASS,,,-	;  only HSC60 systems from the display.
		CLS$M_HSC60_SYS		;

	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other type is an error.



;
; Process REMOVE SYSTEMS/NODE=nodename
;	  REMOVE SYSTEMS/NODE=(nodename,...)

	$STATE	REM_SYS_NODE
	$TRAN	'='
	$STATE
	$TRAN	'(',REM_NODE_LOOP	; Go parse a list of nodenames
	$TRAN	TPA$_LAMBDA		; Go parse a single nodename
	$STATE
	$TRAN	!REM_SYS_NODE_STRING,-	;
		NEXT_REM_SYS_QUAL	;

	$STATE	REM_NODE_LOOP		; Parse a list of nodenames till a ")"
					;  is found.
	$TRAN	!REM_SYS_NODE_STRING	; Go parse a nodename.
	$STATE
	$TRAN	<','>,REM_NODE_LOOP	; Loop if "," found.
	$TRAN	')',NEXT_REM_SYS_QUAL	; Until a ")" is found.

	$STATE	REM_SYS_NODE_STRING	; Parse a single nodename
	$TRAN	TPA$_STRING,,,,TKN_DSCR	; Save address of string.
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,-	; Call REM_NODE.
		REM_NODE


;
; REMOVE CIRCUITS
;
	$STATE	REM_CIR

	$TRAN	'/',REM_CIR_QUAL	; Go to REM_CIR_QUAL state if qualifier
					;  is present.

	$TRAN	TPA$_LAMBDA,-		; Otherwise remove all types of circuits
		REM_NEXT_CLASS,-	;  to the display.
		EXCLUDE_CLASS,,,-	;
		CLS$M_ALL_CIR		;

;
; Process REMOVE CIRCUITS qualifiers.
;
	$STATE	REM_CIR_QUAL

	$TRAN	'TYPE',REM_CIR_TYPE	; REMOVE CIRCUITS/TYPE
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

;
; Loop for multiple qualifiers on the CIRCUITS class.
;
	$STATE NEXT_REM_CIR_QUAL
	$TRAN	'/',REM_CIR_QUAL
	$TRAN	TPA$_LAMBDA,REM_NEXT_CLASS

	$STATE	REM_CIR_TYPE
	$TRAN	'='
	$STATE
	$TRAN	'(',REM_CIR_TYPE_LOOP	; Go parse a list of circuit types.
	$TRAN	TPA$_LAMBDA,		; Go parse a single circuit type.
	$STATE
	$TRAN	!REM_CIR_TYPE_STRING,-	;
		NEXT_REM_CIR_QUAL	;


	$STATE	REM_CIR_TYPE_LOOP	; Parse a list of circuit types till a
					;  ")" is found.
	$TRAN	!REM_CIR_TYPE_STRING	; 
	$STATE
	$TRAN	<','>,REM_CIR_TYPE_LOOP	; Go parse a single circuit type.
	$TRAN	')',NEXT_REM_CIR_QUAL	; Exit loop if ")" found.


	$STATE	REM_CIR_TYPE_STRING	; Parse a single circuit type.

	$TRAN	'ALL',TPA$_EXIT,-	; "REMOVE CIRCUITS/TYPE=ALL" - Remove
		EXCLUDE_CLASS,,,-	;  all types of circuits from the
		CLS$M_ALL_CIR		;  display.

	$TRAN	'OPEN',TPA$_EXIT,-	; "REMOVE CIRCUITS/OPEN" - Remove
		EXCLUDE_CLASS,,,-	;  circuits in the open state from to
		CLS$M_OPEN_CIR		;  the display.

	$TRAN	'NOOPEN',TPA$_EXIT,-	; "REMOVE CIRCUITS/NOOPEN" - Remove
		EXCLUDE_CLASS,,,-	;  circuits in non-open states from the
		CLS$M_NOOPEN_CIR 	; display.

	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other type is an error.


;
; REMOVE CONNECTIONS
;
	$STATE	REM_CON

	$TRAN	'/',REM_CON_QUAL	; Go to REM_CON_QUAL state if qualifier
					;  is present.

	$TRAN	TPA$_LAMBDA,-		; Otherwise remove all types of
		REM_NEXT_CLASS,-	;  connections from the display.
		EXCLUDE_CLASS,,,-	;
		CLS$M_ALL_CON		;

;
; Process REMOVE CONNECTIONS qualifiers
;
	$STATE	REM_CON_QUAL

	$TRAN	'TYPE',REM_CON_TYPE	; REMOVE CONNECTIONS/TYPE
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

;
; Loop for multiple qualifiers on the CONNECTIONS class.
;
	$STATE NEXT_REM_CON_QUAL
	$TRAN	'/',REM_CON_QUAL
	$TRAN	TPA$_LAMBDA,REM_NEXT_CLASS

	$STATE	REM_CON_TYPE
	$TRAN	'='
	$STATE
	$TRAN	'(',REM_CON_TYPE_LOOP	; Go parse a list of connection types.
	$TRAN	TPA$_LAMBDA,		; Go parse a single connection type.
	$STATE
	$TRAN	!REM_CON_TYPE_STRING,-	;
		NEXT_REM_CON_QUAL	;


	$STATE	REM_CON_TYPE_LOOP	; Parse a list of connection types till
					;  a ")" is found.
	$TRAN	!REM_CON_TYPE_STRING	; 
	$STATE
	$TRAN	<','>,REM_CON_TYPE_LOOP	; Go parse a single connection type.
	$TRAN	')',NEXT_REM_CON_QUAL	; Exit loop if ")" found.


	$STATE	REM_CON_TYPE_STRING	; Parse a single connection type.

	$TRAN	'ALL',TPA$_EXIT,-	; "REM CONNECTION/TYPE=ALL" - Remove all
		EXCLUDE_CLASS,,,-	;  types of connections from the
		CLS$M_ALL_CON		;  display.

	$TRAN	'OPEN',TPA$_EXIT,-	; "REMOVE CONNECTIONS/OPEN" - Remove
		EXCLUDE_CLASS,,,-	;  connections in the open state from
		CLS$M_OPEN_CON		;  the display.

	$TRAN	'NOOPEN',TPA$_EXIT,-	; "REMOVE CONNECTIONS/NOOPEN" - Remove
		EXCLUDE_CLASS,,,-	;  connections in non-open states from
		CLS$M_NOOPEN_CON  	;  the display.

	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other type is an error.



;
; Set command.
;

	$STATE	SET
	$TRAN	TPA$_EOS,TPA$_EXIT,-	; Return if end of string.
		REFRESH
	
	$TRAN	'INTERVAL',-		; SET INTERVAL
		PARSE_INTERVAL		;
	$TRAN	'SCREEN',PARSE_SCREEN	; SET SCREEN
	$TRAN	TPA$_LAMBDA,SET_FIELD	; Must be SET FIELD


	$STATE	SET_FIELD
	$TRAN	TPA$_SYMBOL,-		; Check for valid field name.
		SET_FIELD_QUAL,-	;
		LOOKUP_FIELD		;

	$STATE NEXT_SET_FIELD_QUAL
	$TRAN	'/',SET_FIELD_QUAL	; Loop on qualifiers to the fieldname.
	$TRAN	TPA$_LAMBDA,SET_NEXT	; Or else go on to next SET entity.

	$STATE	SET_FIELD_QUAL
	$TRAN	'/'			; Expect a qualifier.
	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Else error.
	$STATE	
	$TRAN	'WIDTH',SET_FIELD_WIDTH	; SET field-name/WIDTH.
	$TRAN	'FORMAT',-		; SET field-name/FORMAT.
		SET_FIELD_FORMAT	;
	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; Any other qualifier is an error.

	$STATE	SET_FIELD_WIDTH		; SET field/WIDTH
	$TRAN	!PARSE_VALUE,-		; Get the value and set it.
		NEXT_SET_FIELD_QUAL,-	;
		SET_WIDTH		;

	$STATE	SET_FIELD_FORMAT	; Get the desired field format.
	$TRAN	'='			; SET field/FORMAT=
	$STATE				;
	$TRAN	'DECIMAL',-		; SET field/FORMAT=DECIMAL
		NEXT_SET_FIELD_QUAL,-	;
		SET_FORMAT,,,DEC	;
	$TRAN	'HEXADECIMAL',-		; SET field/FORMAT=HEXADECIMAL
		NEXT_SET_FIELD_QUAL,-	;
		SET_FORMAT,,,HEX	;

	$STATE	SET_NEXT
	$TRAN	<','>,SET		; Loop on set command if comma follows
					;  the entity.
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,-	; If not comma then redraw the header
		REFRESH			;  and return.

	$STATE	PARSE_INTERVAL
	$TRAN	!PARSE_VALUE,TPA$_EXIT,-; Get the value and set it.
		SET_INTERVAL		; 

	$STATE	PARSE_SCREEN
	$TRAN	!PARSE_VALUE,TPA$_EXIT,-; Get the value and set it.
		SET_SCREEN		;

	$STATE	PARSE_VALUE
	$TRAN	'='			; Must begin with =
	$STATE				;
	$TRAN	<'-'>,TPA$_FAIL		; Negative numbers are a no-no.
	$TRAN	TPA$_DECIMAL,TPA$_EXIT,-; Store a decimal number at VALUE.
		,,VALUE			;
	$TRAN	TPA$_LAMBDA,TPA$_FAIL	; All else fails.


;
; Help command
;

	$STATE	HELP

	$TRAN	TPA$_LAMBDA,TPA$_EXIT,GET_HELP

	$END_STATE



	.SBTTL	Tparse action routines.
	.SBTTL		-	SHOW_CLUSTER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine sets the report to clusters.  It stores the parameters
;	necessary for the FIND_ENTRY routine to locate a field descriptor for
;	the cluster report.  It sets the bit in CURRENT_REPORT that indicates
;	that the cluster report is being displayed.  It also saves a copy of
;	the scroll flags for the local report and restores the scroll flags
;	for the cluster report.
;
;
; CALLING SEQUENCE:
;
;	CALLS	#0,SHOW_CLUSTER
;
; CALLED BY:
;
;	SWITCH_DISPLAY
;	RESET
;
;
; IMPLICIT INPUTS:
;
;	CLSTR_SCROLL_FLAGS
;			contains a mask of the scroll flags set from the last
;			time the cluster report was being displayed.
;
; IMPLICIT OUTPUTS:
;
;	ADRS_TABLE	contains the address of the cluster address table.
;	BITMAP_ADRS	contains the address of the cluster bitmap.
;	KEYTAB_ADRS	contains the address of the cluster keyword table.
;	MAP_LEN		contains the the length of the cluster bitmap.
;	CURRENT_REPORT	Set to clusters by setting RPT$M_REPORT.
;	SCROLL_FLAGS	restored to from the last time the cluster report was
;			displayed.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	SHOW_CLUSTER,^M<>

	BSBW	CLEAR_SCREEN		; Clear the screen.
	BLBC	R0,99$			; Branch on error.
	PUSHAQ	SCREEN_DSCR		; Set up a buffer for the screen.
	CALLS	#1,G^LIB$SET_BUFFER	;
	BLBC	R0,99$			; Branch on error.
	BBSS	#RPT$V_CLSTR,-		; Branch if we're already displaying
		CURRENT_REPORT,10$	;  the cluster report.  Otherwise set
					;  the current report to clusters.
	MOVB	SCROLL_FLAGS,-		; Store the scroll flags for the local
		LOCAL_SCROLL_FLAGS	;  report.
	MOVB	CLSTR_SCROLL_FLAGS,-	; Get the cluster report scroll flags.
		SCROLL_FLAGS		;
	MOVL	CLASS_SELECT,LOCAL_SAVE	; Save local report class selections.
	MOVL	CLUST_SAVE,CLASS_SELECT	; Get cluster report class selections.
	MOVAL	CLUSTER_KEYTAB,-	; Store address of cluster keyword
		KEYTAB_ADRS		;  table.
	MOVAL	CLUSTER_TABLE,ADRS_TABLE; Store address of cluster address
					;  table.
	MOVAL	CLUSTER_BITMAP,-	; Store address of cluster bitmap.
		BITMAP_ADRS		;
	MOVL	#CLUSTER_MAP_LEN,MAP_LEN; Store length of cluster bitmap.
10$:	CALLS	#0,REFRESH		; Redraw the header.
99$:	RET


	.SBTTL		-	SHOW_LOCAL
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine sets the report to local ports.  It stores the parameters
;	necessary for the FIND_ENTRY routine to locate a field descriptor for
;	the local report.  It sets the bit in CURRENT_REPORT that indicates
;	that the local report is being displayed.  It also saves a copy of
;	the scroll flags for the cluster report and restores the scroll flags
;	for the local report.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,SHOW_LOCAL
;
; CALLED BY:
;
;	SWITCH_DISPLAY
;
; IMPLICIT INPUTS:
;
;	LOCAL_SCROLL_FLAGS
;			contains a mask of the scroll flags set from the last
;			time the cluster report was being displayed.
;
; IMPLICIT OUTPUTS:
;
;	ADRS_TABLE	contains the address of the local status address table.
;	BITMAP_ADRS	contains the address of the local status bitmap.
;	KEYTAB_ADRS	contains the address of the local status keyword table.
;	MAP_LEN		contains the the length of the local status bitmap.
;	CURRENT_REPORT	Set to local report by clearing RPT$M_REPORT.
;	SCROLL_FLAGS	restored to from the last time the cluster report was
;			displayed.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	SHOW_LOCAL,^M<>

	BSBW	CLEAR_SCREEN		; Clear the screen.
	BLBC	R0,99$			; Branch on error.
	PUSHAQ	SCREEN_DSCR		; Set up a buffer for the screen.
	CALLS	#1,G^LIB$SET_BUFFER	;
	BLBC	R0,99$			; Branch on error.
	BBCC	#RPT$V_CLSTR,-		; Branch if we are already displaying
		CURRENT_REPORT,10$	;  local report.  Otherwise, set the
					;  current report to local.
	MOVB	SCROLL_FLAGS,-		; Store the current scroll flags for
		CLSTR_SCROLL_FLAGS	;  the cluster report.
	MOVB	LOCAL_SCROLL_FLAGS,-	; Get the local report scroll flags.
		SCROLL_FLAGS		;
	MOVL	CLASS_SELECT,CLUST_SAVE	; Save cluster report class selections.
	MOVL	LOCAL_SAVE,CLASS_SELECT	; Get local report class selections.
	MOVAL	LOCAL_KEYTAB,KEYTAB_ADRS; Store address of local status keyword
					;  table.
	MOVAL	LOCAL_TABLE,ADRS_TABLE	; Store address of local table.
	MOVAL	LOCAL_BITMAP,BITMAP_ADRS; Store address of local bitmap.
	MOVL	#LOCAL_MAP_LEN,MAP_LEN	; Store length of local bitmap.
10$:	CALLS	#0,REFRESH		; Redraw the header.
99$:	RET



	.SBTTL		-	ADD_FIELD
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to add a field to the display by setting the bit
;	corresponding to the field in the bitmap for the current report.  If
;	the field is in a class which is currently not being displayed, then
;	that class is enabled along with the desired field, but all other
;	fields in that class are turned off.  If the class being enabled is
;	the Cluster class, then update FIRST_DATA_LINE so that the scrolling
;	region does not encompass the Cluster class display.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,ADD_FIELD
;
; CALLED_BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	KEY_OFF	= Address of longword in the bitmap that contains the bit
;		   corresponding to the field selected.
;	KEY_MSK	= Mask of the bit within KEY_OFF corresponding to the field.
;
; OUTPUTS:
;
;	Bit corresponding to the field set in the bitmap.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
; REGISTER USAGE:
;
;	R2 -	Points to the address containing the bit corresponding to the
;		field.
;
;--

.ENTRY	ADD_FIELD,^M<R2,R3,R4,R5,R6,R7,R8>
	CALLS	#0,LOOKUP_FIELD		; Check for valid field name.
	JLBC	R0,99$			; Branch on error.
	MOVL	KEY_OFF,R2		; Get address of longword containing
					;  the bit.
	MOVL	KEY_DSCR,R3		; Get the address of the descriptor for
					;  the field.
	BITL	FD$L_CLASS(R3),-	; Is the class for this field already
		CLASS_SELECT		;  enabled?
	JNEQ	70$			; Branch if so.
	BBC	#CLS$V_CIR,-		; Is this field in the circuits class?
		FD$L_CLASS(R3),10$	;
	BISL	#CLS$M_ALL_CIR,-	; If so, enable all types of circuits.
		CLASS_SELECT		;
	BRB	30$			; Jump to common code.
10$:	BBC	#CLS$V_CON,-		; Is this field in the connections
		FD$L_CLASS(R3),20$	;  class?
	BISL	#CLS$M_ALL_CON,-	; If so, enable all types of
		CLASS_SELECT		;  connections.
	BRB	30$			; Jump to common code.
20$:	BBC	#CLS$V_CLUB,-		; Is this field in the cluster class?
		FD$L_CLASS(R3),25$	;
	MOVL	#14,FIRST_DATA_LINE	; If so, set first line to be scrolled.
25$:	BISL	FD$L_CLASS(R3),-	; Enable the class.
		CLASS_SELECT		;
30$:	MOVL	BITMAP_ADRS,R8		; Get the address of field descriptor
					;  bitmap for the current report.
	CLRL	START_BIT		; Set up for FIND_ENTRY.
	CLRL	H_SCROLL_LINE		; Make sure that fields scrolled off
					;  the screen are also checked.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,50$	;  cluster report.
	MOVL	#CLUSTER_MAP_LEN,MAP_LEN; Save length of cluster bitmap.
	BRB	60$			; Jump to common code.
50$:	MOVL	#LOCAL_MAP_LEN,MAP_LEN	; Save length of local bitmap.
60$:	BSBW	FIND_ENTRY		; Search for any field being displayed.
	BLBC	R0,70$			; Branch if none found.
	CMPL	FD$L_CLASS(R10),-	; Is the class for the field we just
		FD$L_CLASS(R3)		;  found the same as the field we are
					;  adding to the display?
	BNEQ	60$			; If not go find another field.
	SUBL3	#1,START_BIT,R4		; Get the number of the bit in the
					;  bitmap that corresponds to the field
					;  we just found.
	CLRL	R5			; Set up for extended divide.
	EDIV	#8,R4,R6,R7		; R6 gets the index into the address
					;  table.  R7 gets the bit position.
	BBCC	R7,(R8)[R6],60$		; Disable the field and loop.
	BRB	60$			; Loop for all field descriptors.
70$:	BISL	KEY_MSK,(R2)		; Set the bit, turn on the field.
	MOVL	#SS$_NORMAL,R0
99$:	RET



	.SBTTL		-	REMOVE_FIELD
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to remove a field from the display by clearing the
;	bit corresponding to the field in the bitmap for the current report.
;	If the field being cleared is the last field being displayed in a
;	particular class, then the class is turned off instead.  If the class
;	being turned off is the Cluster class, then update FIRST_DATA_LINE so
;	that the scrolling region uses the full display.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,REMOVE_FIELD
;
; CALLED_BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	KEY_OFF	= Address of longword in the bitmap that contains the bit
;		   corresponding to the field selected.
;	KEY_MSK	= Mask of the bit within KEY_OFF corresponding to the field.
;
; OUTPUTS:
;
;	Bit corresponding to the field cleared in the bitmap, or bit
;	corresponding to the class cleared at CLASS_SELECT.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
; REGISTER USAGE:
;
;	R2 -	Points to the address containing the bit corresponding to the
;		field.
;
;--
.ENTRY	REMOVE_FIELD,^M<R2,R3,R8>
	CALLS	#0,LOOKUP_FIELD		; Check for valid field name.
	BLBC	R0,99$			; Branch on error.
	MOVL	KEY_OFF,R2		; Get address of longword containing
					;  the bit.
	MOVL	KEY_DSCR,R3		; Get the address of the descriptor
					;  for the field.
	MOVL	BITMAP_ADRS,R8		; Get the address of the field
					;  descriptor bitmap for the current
					;  report.
	CLRL	START_BIT		; Set up for FIND_ENTRY.
	CLRL	H_SCROLL_LINE		; Make sure that fields scrolled off
					;  the screen are also checked.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,20$	;  cluster report.
	MOVL	#CLUSTER_MAP_LEN,MAP_LEN; Save length of cluster bitmap.
	BRB	30$			; Jump to common code.
20$:	MOVL	#LOCAL_MAP_LEN,MAP_LEN	; Save length of local bitmap.
30$:	BSBW	FIND_ENTRY		; Search for any field being displayed.
	BLBC	R0,40$			; Branch if none found.
	CMPL	FD$L_CLASS(R10),-	; Is the class for the field we just
		FD$L_CLASS(R3)		;  found the same as the field we are
					;  adding to the display?
	BNEQ	30$			; If not go find another field.
	CMPL	R3,R10			; Is it the same field?
	BEQL	30$			; If so go find another field.
	BICL	KEY_MSK,(R2)		; Clear the bit, turn off the field.
	BRB	99$			; Branch to common code.
40$:	BICL	FD$L_CLASS(R3),-	; No other fields in this class found,
		CLASS_SELECT		;  so turn off the class, not the field.
	BBC	#CLS$V_CLUB,-		; Did we just turn off the cluster
		FD$L_CLASS(R3),50$	;  class?
	MOVL	#7,FIRST_DATA_LINE	; If so, set first line to be scrolled.
50$:	MOVL	#SS$_NORMAL,R0		; Return success.
99$:	RET



	.SBTTL		-	LOOKUP_FIELD
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	   This routine is used to parse the field name by calling
;	LIB$LOOKUP_KEY using each of the keyword tables containing the field
;	names.  The keyword value is converted into an address and mask for the
;	bit within the appropriate bitmap and the address of the descriptor for
;	the field.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,LOOKUP_FIELD
;
; CALLED BY:
;
;	ADD_FIELD
;	REMOVE_FIELD
;
; INPUTS:
;
; IMPLICIT INPUTS:
;
;	Selected fieldname stored at address TPARSE_BLK+TPA$L_TOKENCNT.
; 	Address of keyword table stored at KEYTAB_ADRS.
;	Address of bitmap stored at BITMAP_ADRS.
;	Address of address table stored at ADRS_TABLE.
;
; OUTPUTS:
;
;	KEY_OFF	 = Address of longword in the bitmap that contains the bit
;		   corresponding to the field selected.
;	KEY_MSK	 = Mask of the bit within KEY_OFF corresponding to the field.
;	KEY_DSCR = Address of the field descriptor for the selected field.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status from LIB$LOOKUP_KEY returned in R0.
;
;--

.ENTRY	LOOKUP_FIELD,^M<R2,R3,R4,R5>
	MOVL	KEYTAB_ADRS,R3		; Get address of keyword table.
	MOVL	BITMAP_ADRS,R4		; Get address of bitmap.
	MOVL	ADRS_TABLE,R5		; Get address of address table.
	PUSHAL	KEY_VAL			; Push address to receive value.
	PUSHL	R3			; Push keyword table address.
					; Push address of descriptor for the
					;  remainder of the string.
	PUSHAL	TPARSE_BLK+TPA$L_TOKENCNT
	CALLS	#3,G^LIB$LOOKUP_KEY	; Check for valid field name in the
					;  current report.
	BLBS	R0,30$			; Branch if field name is valid in the
					;  current report.
;
; If the field lookup fails, then determine if it is a valid field name,
; but simply can't be displayed in the current report.  If so, then pass
; the additional information on to the user.
;
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,10$	;  cluster report.
	PUSHAL	LOCAL_KEYTAB		; Lookup field in the LOCAL keyword
					;  table.
	BRB	20$			; Jump to common code.
10$:	PUSHAL	CLUSTER_KEYTAB		; Check for valid field name.
20$:	PUSHAL	TPARSE_BLK+TPA$L_TOKENCNT
	CALLS	#2,G^LIB$LOOKUP_KEY	; Check for valid field name.
	BLBC	R0,99$			; Branch on error.
	MOVL	#SHOW$_NOAVAIL,R0	; "Field not available in this report".
	BRB	99$			; Exit with status.
30$:	MOVL	KEY_VAL,R2		; Get the keyword value in R2,R3.
	CLRL	R3			;
	EDIV	#32,R2,R2,R3		; Convert the keyword value into an
					;  offset into a field bitmap.
					;  R2 gets the longword offset,
					;  R3 gets the bit offset.
	MOVAL	(R4)[R2],KEY_OFF	; Get address of longword containing
					;  the bit and store in KEY_OFF.
;
; Convert the bit position in R3 to a mask.
;
	MOVL	#1,R4			; Start with mask for bit 0.
	ASHL	R3,R4,KEY_MSK		; Shift left by the number a bits in R3
					;  and save in KEY_MSK.

	MOVL	KEY_VAL,R4
	MOVL	(R5)[R4],KEY_DSCR	; Get address of field descriptor for
					;  this keyword and save in KEY_DSCR.
	MOVL	#SS$_NORMAL,R0		; Indicate success.
99$:	RET



	.SBTTL		-	ADD_ALL_FIELDS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to turn on all the fields in a particular class
;	when the /ALL qualifier is used with the ADD class-name command.
;
; CALLING SEQUENCE:
;
;	BRB	ADD_ALL_FIELDS
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	Class select bit for the class to have all fields turned on at
;	TPARSE_BLK+TPA$L_PARAM.
;
; OUTPUTS:
;
;	Bits corresponding to the the fields in the selected class set in the
;	bitmap.
;	Bit corresponding to the selected class set at CLASS_SELECT.
;
;
;--

.ENTRY	ADD_ALL_FIELDS,^M<R5,R6,R7,R9,R10>
	CALLS	#0,INCLUDE_CLASS	; Make sure the class is add to the
					;  display.
	MOVL	ADRS_TABLE,R6		; Get the address of the address table
					;  for the field descriptors.
	MOVL	BITMAP_ADRS,R7		; Get the address of field descriptor
					;  bitmap for the current report.
	MOVL	#1,R9			; Start with bit 0.
	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,10$	;  cluster report.
	MOVL	CLUSTER_KEYTAB,R5	; Get the number of cluster keyword
					;  vectors.
	BRB	15$			; Jump to common code.
10$:	MOVL	LOCAL_KEYTAB,R5		; Get the number of local keyword
					;  vectors.
15$:	ASHL	#-1,R5,R5		; Get the number of fields to check.
16$:	CLRL	R10			; Dividend must be a quadword.
	EDIV	#32,R9,R1,R10		; Calculate the number of bits left to
	SUBL3	R10,#32,R10		;  scan in the longword.
	FFC	R9,R10,(R7),R9		; Scan for a clear bit.
	BEQLU	16$			; If not, scan next longword.
	CMPL	R9,R5			; Have we checked all fields?
	BEQL	99$			; Branch if so.

20$:	MOVL	(R6)[R9],R10		; Get the address of the field
					;  descriptor.
	BITL	FD$L_CLASS(R10),-	; Is the field in the desired class?
		TPARSE_BLK+TPA$L_PARAM	;
	BEQL	25$			; If not go find another field.
	BBSS	R9,(R7),25$		; Otherwise, turn on the field.
25$:	INCL	R9			; Get number of next bit to test.
	BRB	16$			; Loop for all fields.
99$:	RET



	.SBTTL		-	INCLUDE_CLASS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to add a class to the display.  It simply sets the
;	bit that corresponds to the desired class in location CLASS_SELECT.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,INCLUDE_CLASS
;
; CALLED BY:
;
;	READ_W_PROMPT
;	ADD_ALL_FIELDS
;
; INPUTS:
;
;	Mask of the bit to be set at address TPARSE_BLK+TPA$L_PARAM.
;
; OUTPUTS:
;
;	Bit corresponding to the desired class set at CLASS_SELECT.
;
; RETURN STATUS:
;
;	SS$_NORMAL if class can be added to the current report, otherwise
;	SHOW$_CACLS if the class can't be added to the current report.
;
;--

.ENTRY	INCLUDE_CLASS,^M<>

	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,10$	;  cluster report.
	BITL	#CLS$M_LPRT!CLS$M_ERR,-	; Is the desired class in the
		TPARSE_BLK+TPA$L_PARAM	;  LOCAL_PORTS report?
	BNEQ	98$			; Error if so.
	BRB	20$			; Branch to common code.

10$:	BITL	#CLS$M_ANY_CLUS,-	; Is the desired class in the CLUSTER
		TPARSE_BLK+TPA$L_PARAM	;  report?
	BNEQ	98$			; Error if so.

20$:	BISL	TPARSE_BLK+TPA$L_PARAM,-; Set the bit corresponding to the
		CLASS_SELECT		;  desired class.
	BBC	#CLS$V_CLUB,-		; Branch if desired class isn't
		TPARSE_BLK+TPA$L_PARAM,-;  CLUSTER
		30$			
	MOVL	#14,FIRST_DATA_LINE	; Set first line to be scrolled.
30$:	MOVL	#SS$_NORMAL,R0		; Indicate success.
	BRB	99$			; Branch to common exit.

98$:	MOVAL	TKN_DSCR,ERR_MSGVEC+12	; Save descriptor for class name.
	MOVL	#SHOW$_CACLS,R0		; "Can't add the class to this report"
99$:	RET



	.SBTTL		-	EXCLUDE_CLASS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to remove a class from the display.  It simply
;	clears the bit that corresponds to the desired class in location
;	CLASS_SELECT.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,EXCLUDE_CLASS
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	Mask of the bit to be cleared at address TPARSE_BLK+TPA$L_PARAM.
;
; OUTPUTS:
;
;	Bit corresponding to the desired class cleared at CLASS_SELECT.
;
; RETURN STATUS:
;
;	SS$_NORMAL if class can be removed from the current report, otherwise
;	SHOW$_CRCLS if the class can't be removrd from the current report.
;
;--

.ENTRY	EXCLUDE_CLASS,^M<>

	BBC	#RPT$V_CLSTR,-		; Branch if we're not displaying the
		CURRENT_REPORT,10$	;  cluster report.
	BITL	#CLS$M_LPRT!CLS$M_ERR,-	; Is the desired class in the
		TPARSE_BLK+TPA$L_PARAM	;  LOCAL_PORTS report?
	BNEQ	98$			; Error if so.
	BRB	20$			; Branch to common code.

10$:	BITL	#CLS$M_ANY_CLUS,-	; Is the desired class in the CLUSTER
		TPARSE_BLK+TPA$L_PARAM	;  report?
	BNEQ	98$			; Error if so.

20$:	BICL	TPARSE_BLK+TPA$L_PARAM,-; Clear the bit corresponding to the
		CLASS_SELECT		;  desired class.
	BBC	#CLS$V_CLUB,-		; Branch if desired class isn't
		TPARSE_BLK+TPA$L_PARAM,-;  CLUSTER
		30$			
	MOVL	#7,FIRST_DATA_LINE	; Set first line to be scrolled.
30$:	MOVL	#SS$_NORMAL,R0		; Indicate success.
	BRB	99$			; Branch to common exit.

98$:	MOVAL	TKN_DSCR,ERR_MSGVEC+12	; Save descriptor for class name.
	MOVL	#SHOW$_CRCLS,R0		; Assume we can't remove the class from
					;  this report.
99$:	RET



	.SBTTL		-	ADD_ID

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine adds a system ID to the ID list for systems that will not
;	be included in the display.
;
;
; CALLING SEQUENCE:
;
;	CALLS	#0,ADD_ID
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	TKN_DSCR Contains the descriptor for the string which specifies the
;	ID of the system to add to the list.
;
; OUTPUTS:
;
;	Six byte hex ID number is stored in the list of ID numbers for systems
;	to be removed from the display.
;
;	The number of entries in the list is incremented (ID_COUNT).
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	ADD_ID,^M<>

	JSB	CONVERT_TO_HEX		; Convert system ID string to hex value.
	BLBC	R0,98$			; Branch on error.
	JSB	ADD_TO_LIST		; Add the system ID to the list.
	BLBS	R0,99$			; Exit on success.
98$:	MOVL	#SHOW$_IVREMID,R0	; "Can't remove system from the display"
	MOVAL	TKN_DSCR,ERR_MSGVEC+12	; Save descriptor for class name.
99$:	RET				; Return with status.



	.SBTTL		-	REM_NODE

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine removes a system from the display by converting the node
;	name of the system to the system's ID and then adding the system's ID
;	to the ID list for systems that will not be included in the display.
;
;
; CALLING SEQUENCE:
;
;	CALLS	#0,REM_NODE
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	TKN_DSCR Contains the descriptor for the string which specifies the
;	node name of the system to remove from the display.
;
; OUTPUTS:
;
;	Six byte hex ID number is stored in the list of ID numbers for systems
;	to be removed from the display.
;
;	The number of entries in the list is incremented (ID_COUNT).
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	REM_NODE,^M<>

	JSB	FIND_NODE		; Find the ID of the system that
					;  coresponds to the specified node
					;  name.
	BLBC	R0,98$			; Branch if not found.
10$:	JSB	ADD_TO_LIST		; Add the system ID to the list.
	BLBS	R0,99$			; Exit on success.

98$:	MOVL	#SHOW$_IVREMNODE,R0	; Indicate specified system can not be
					;  removed.
99$:	RET				; Return with status.



	.SBTTL		-	REM_ID

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine removes adds a system to the display by removing it's
;	system ID from the ID list of systems that will not be included in
;	the display.
;
;
; CALLING SEQUENCE:
;
;	CALLS	#0,REM_ID
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	TKN_DSCR Contains the descriptor for the string which specifies the
;	ID of the system to remove from the list.
;
; OUTPUTS:
;
;	The six byte hex ID number stored in the list of ID numbers for systems
;	to be removed from the display is cleared.
;
;	The number of entries in the list is decremented (ID_COUNT).
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	REM_ID,^M<>

	JSB	CONVERT_TO_HEX		; Convert system ID string to hex value.
	BLBC	R0,98$			; Branch on error.
	JSB	REMOVE_FROM_LIST	; Remove the system ID from
					;  SYS_ID_LIST.
	BLBS	R0,99$			; Exit on success.
98$:	MOVL	#SHOW$_IVADDID,R0	; "Can't add system to the display"
	MOVAL	TKN_DSCR,ERR_MSGVEC+12	; Save descriptor for system ID.
99$:	RET				; Return with status.



	.SBTTL		-	ADD_NODE

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine adds a system to the display by converting the node
;	name specified into the system ID and removing the system ID
;	from the ID list for systems that will not be included in the display.
;
;
; CALLING SEQUENCE:
;
;	CALLS	#0,ADD_NODE
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	TKN_DSCR Contains the descriptor for the string which specifies the
;	node name of the system to remove from the list.
;
; OUTPUTS:
;
;	The six byte hex ID number stored in the list of ID numbers for systems
;	to be removed from the display is cleared.
;
;	The number of entries in the list is decremented (ID_COUNT).
;
; RETURN STATUS:
;
;	R0 =	SS$_NORMAL
;		SHOW$_IVADDNODE if node is unknown or already being displayed.
;
;--

.ENTRY	ADD_NODE,^M<>

	JSB	FIND_NODE		; Find the ID of the system that
					;  coresponds to the specified node
					;  name.
	BLBC	R0,98$			; Branch if not found.
	JSB	REMOVE_FROM_LIST	; Remove the system ID from the list of
					;  systems removed from the display.
	BLBS	R0,99$			; Exit on success.
98$:	MOVL	#SHOW$_IVADDNODE,R0	; Indicate specified node can not be
					;  added.
99$:	RET				; Return with status.



	.SBTTL		-	FIND_NODE

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to convert the node name specified by the
;	REMOVE or ADD SYSTEMS/NODE= commands into a system ID.  The
;	system blocks in SB buffer are scanned for a node name equal to
;	the node name specified.  If a match is found, then the system
;	ID of the matching system block is taken from the system block	
;	and stored in ID_RESULT.  The system ID can then be used to add
;	or remove the system ID from SYS_ID_LIST.
;
; CALLING SEQUENCE:
;
;	JSB	FIND_NODE
;
; CALLED BY:
;
;	REM_NODE
;	ADD_NODE
;
; INPUTS:
;
;	TKN_DSCR contains a descriptor for the node name string specified.
;
; OUTPUTS:
;
;	System ID for the node specified stored in ID_RESULT.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL if a system block and system ID were found that match
;	     the node name.
;	R0 = 0 if not found.
;
; REGISTER USAGE:
;
;	R2  - Used by CMPC.
;	R3  - Used by CMPC.
;	R10 - Points to the base of a system block in SB buffer.
;
;--

FIND_NODE:
	PUSHR	#^M<R2,R3,R10>
	MOVL	VAR_BUF,R10		; Get the address of the system block
					;  buffer.
10$:	CMPB	TKN_DSCR,-		; Is the number of characters specified
		SB$T_NODENAME(R10)	;  the same as the length of the node
					;  name in this system block?
	BNEQ	20$			; If not this can't be the right system
					;  block.
	CMPC3	TKN_DSCR,@TKN_DSCR+4,-	; Compare the nodename specified with
		SB$T_NODENAME+1(R10)	;  the nodename in the system block.
	BEQL	30$			; Branch if they're the same.
20$:	MOVL	(R10),R10		; Get the address of the next system
					;  block.
	BNEQ	10$			; Loop of there's more SB's.
	CLRL	R0			; Otherwise, indicate failure,
	BRB	99$			;  and return with error status.
30$:	MOVL	SB$B_SYSTEMID(R10),-	; Store the system ID for the matching
	ID_RESULT			;  system block in ID_RESULT.
	MOVW	SB$B_SYSTEMID+4(R10),-	;
	ID_RESULT+4			;
	MOVL	#SS$_NORMAL,R0		; Indicate success.
99$:	POPR	#^M<R2,R3,R10>
	RSB



	.SBTTL		-	ADD_TO_LIST

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	The routine disables a system from being displayed by adding it's
;	system ID to the list of systems not to be displayed.  It searches
;	the list at SYS_ID_LIST to make sure that the system id is not
;	already in the list.  If it isn't, then it inserts the system ID
;	in the first empty entry.
;
; CALLING SEQUENCE:
;
;	JSB	ADD_TO_LIST
;
; CALLED BY:
;
;	ADD_ID
;	REM_NODE
;
; INPUTS:
;
;	SYS_ID_LIST contains a list of system ID's for systems removed from
;	the display.
;	ID_RESULT contains the ID of the system to remove add to the list.
;	ID_COUNT contains the number of system entered in the list.
;
; OUTPUTS:
;
;	System ID for entered in SYS_ID_LIST.
;	ID_COUNT updated.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL or failed status if the entry is already in the
;	    list or if there is no more room in the list.
;
; REGISTER USAGE:
;
;	R2  - Used as an index for comparing the six bytes of the system ID.
;	R4  - Used as a pointer into the SYS_ID_LIST.
;	R5  - Used to count down the total number of possible entries.
;	R6  - Used to save the address of the first empty entry found.
;
;--

ADD_TO_LIST:
	PUSHR	#^M<R2,R4,R5,R6>
	CLRL	R0			; Assume failure.
	MOVAL	SYS_ID_LIST,R4		; Get the address of the list.
	CLRL	R6			; Assume no empty entry.
	MOVL	#ID_LIST_ENTRYS,R5	; Get the number of entries to search.
	MOVL	#2,R2			; R2 = word index.
10$:	CMPL	ID_RESULT,(R4)		; Compare the specified result with
					;  the entry in the list.
	BNEQ	20$			; Branch if no match.
	CMPW	ID_RESULT+4,(R4)[R2]	; Compare all 6 bytes.
	BEQL	99$			; Branch if the system ID is already in
					;  the list.
20$:	TSTL	R6			; Have we saved the address of the
					;  empty entry in R6?
	BNEQ	30$			; Branch if so.
	TSTL	(R4)			; Is this entry empty?
	BNEQ	30$			; Branch if not.
	TSTW	(R4)[R2]		; Check all 6 bytes.
	BNEQ	30$			; Branch if entry isn't empty.
	MOVL	R4,R6			; Save the address of the empty entry.
30$:	ADDL	#6,R4			; Point to next entry.
	SOBGTR	R5,10$			; Loop for entire list.
	TSTL	R6			; Did we find an empty entry.
	BEQL	99$			; Branch if not.
	MOVL	ID_RESULT,(R6)+		; Otherwise, save the system ID in the
	MOVW	ID_RESULT+4,(R6)	;  list.
	INCL	ID_COUNT		; Increase count of entries in the
					;  list.
	MOVL	#SS$_NORMAL,R0		; Indicate success.
99$:	POPR	#^M<R2,R4,R5,R6>
	RSB



	.SBTTL		-	REMOVE_FROM_LIST

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine clears the entry for a system in the ID list of systems
;	that are not to	be included in the display thereby adding the system
;	to the display.
;
; CALLING SEQUENCE:
;
;	JSB	REMOVE_FROM_LIST
;
; CALLED BY:
;
;	REM_ID
;	ADD_NODE
;
; INPUTS:
;
;	ID_RESULT contains the system ID to match.
;	SYS_ID_LIST contains a list of system ID's for systems removed from
;	the display.
;	ID_COUNT contains the number of entries in the list.
;
; OUTPUTS:
;
;	Entry in SYS_ID_LIST coresponding to the the system ID specified
;	is cleared.
;	The number of entries in the list stored at ID_COUNT is decremented.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL or failed status if entry wasn't found.
;
; REGISTER USAGE:
;
;	R4  Contains the address of the entry as returned from the
;	FIND_SYS_ID routine.
;
;--

REMOVE_FROM_LIST:
	PUSHR	#^M<R4>
	JSB	FIND_SYS_ID		; Is the entry in the list?
	BLBC	R0,99$			; Branch if not.
	CLRL	(R4)+			; Zero out the entry.
	CLRW	(R4)			; All six bytes.
	DECL	ID_COUNT		; Decrease number of entries in the
					;  list.
99$:	POPR	#^M<R4>
	RSB



	.SBTTL		-	FIND_SYS_ID

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine locates a system ID in the ID list.
;
;
; CALLING SEQUENCE:
;
;	JSB	FIND_SYS_ID
;
; CALLED BY:
;
;	REM_ID
;	CHECK_ID
;
; INPUTS:
;
;	ID_RESULT contains the system ID to match.
;	SYS_ID_LIST contains a list of system ID's.
;	ID_COUNT contains the number of entries in the list.
;
; OUTPUTS:
;
;	Address of entry returned in R4.
;
; RETURN STATUS:
;
;	R0 = SS$_NORMAL if the system ID is in the list.
;
; REGISTER USAGE:
;
;--

FIND_SYS_ID:
	PUSHR	#^M<R2,R3>
	CLRL	R0			; Assume failure.
	MOVAL	SYS_ID_LIST,R4		; Get the address of the list.
	MOVL	ID_COUNT,R3		; Get the number of entries in the list.
	BEQL	99$			; Branch if list is empty.
	MOVL	#2,R2			; Index = word.
10$:	CMPL	ID_RESULT,(R4)		; Does the entry match the designated
					;  system?
	BNEQ	20$			; Branch if not.
	CMPW	ID_RESULT+4,(R4)[R2]	; Check all six bytes.
	BNEQ	20$			; Branch if no match.
	MOVL	#SS$_NORMAL,R0		; Indicate success.
	BRB	99$			; Done.
20$:	TSTL	(R4)			; Is the entry empty?
	BNEQ	30$			; Branch if not.
	TSTW	(R4)[R2]		; Check all six bytes.
	BNEQ	30$			; Branch if not empty.
	ADDL	#6,R4			; Point to next entry.
	BRB	10$			; Loop if empty entry.
30$:	ADDL	#6,R4			; Point to next entry.
	SOBGTR	R3,10$			; Loop for all valid entries in the
					;  list.
99$:	POPR	#^M<R2,R3>
	RSB



	.SBTTL		-	CONVERT_TO_HEX

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts the system ID string at TKN_DSCR to a six
;	byte hex value and stores the value at ID_RESULT.
;
;
; CALLING SEQUENCE:
;
;	JSB	CONVERT_TO_HEX
;
; CALLED BY:
;
;	REM_ID
;	ADD_ID
;
; INPUTS:
;
;	TKN_DSCR contains a descriptor for the system ID string.
;
; OUTPUTS:
;
;	ID_RESULT contains the system ID.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
; REGISTER USAGE:
;
;--

	.ENABL	LSB

CONVERT_TO_HEX:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	CLRL	R0			; Assume failure.
	MOVAL	SB$B_SYSTEMID_DSCR,R2	; Get the address of the field
					;  descriptor for the system ID.
	CMPB	FD$B_FORMAT(R2),#HEX	; Is the system ID being displayed in
					;  hexidecimal?
	BNEQU	DECIMAL_ID		; Branch if not.
	CMPW	TKN_DSCR,#12		; Are there more than 12 digits in the
					;  system ID string that was specified?
	JGTRU	99$			; Error if so.
;
; Convert the string into a 6 byte hex number.
;
	PUSHL	#6			; Six byte result.
	PUSHAL	ID_RESULT		; Address to receive result.
	PUSHAL	TKN_DSCR		; String descriptor.
	CALLS	#3,G^OTS$CVT_TZ_L	; Convert the string.
	BRW	99$			; Jump to common code.

DECIMAL_ID:

;
; Convert the decimal string to a six byte hex number.
;

	MOVZWL	TKN_DSCR,R2		; Get the number of digits in the
					;  string.
	MOVL	TKN_DSCR+4,R5		; Get the address of the string.
	CMPL	R2,#20			; Are there more that twenty digits in
					;  the string?
	JGTRU	99$			; Error if so.
	ROTL	#3,R2,R3		; Multiply number of digits by 8 to get
					;  quadword index.
	MOVAL	DEC_TAB_END,R4		; Get the address of the end of the
					;  decimal conversion table.
	SUBL	R3,R4			; Get the address of the first quadword
					;  in the table to use for conversion.
	CLRL	ID_RESULT		; Clear the result of conversion.
	CLRL	ID_RESULT+4		;
10$:	MOVQ	(R4)+,R6		; Get the quadword.
	SUBB3	#^X30,(R5),R3		; Convert the ascii digit to decimal.
	BEQLU	40$			; Ignore if digit is zero.
	JLSSU	99$			; Branch if not valid decimal number.
	CMPB	R3,#9			; Check high limit.
	BGTRU	99$			; Branch if not valid decimal number.
;
; Multiply the quadword in R6,R7 by the byte in R3 and add the result to 
; ID_RESULT.
;
	MOVZBL	R3,R3			; Convert byte to longword.
	EMUL	R3,R6,#0,R8		; Multiply low longword.
	BGEQ	20$			; Branch if result is positive.
	ADDL	R3,R9			; Otherwise, compensate for unsighned
					;  bias.
20$:	EMUL	R3,R7,R9,R9		; Multiply high longword.
30$:	ADDL	R8,ID_RESULT		; Add the resulting quadword to
	ADWC	R9,ID_RESULT+4		;  ID_RESULT.
40$:	INCL	R5			; Point to next byte of string.
	SOBGTR	R2,10$			; Loop for all digits in the string.
	MOVL	#SS$_NORMAL,R0		; Indicate success.

99$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	RSB

	.DSABL	LSB



	.SBTTL		-	SET_WIDTH

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to change the number of columns used by a
;	particular field.  It changes the value in the field descriptor at
;	location FD$B_FIELD_SIZE after checking that the desired width does not
;	exceed the minimum or maximum values for the field.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,SET_WIDTH
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	Desired width stored at location VALUE.
;	Address of the field descriptor for the selected field stored in
;	KEY_DSCR.
;
; OUTPUTS:
;
;	Value at location VALUE stored at offset FD$B_FIELD_SIZE in the field
;	descriptor for the selected field.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
; REGISTER USAGE:
;
;	R4 -	Points to the base address of the field descriptor for the
;		selected field.
;--

.ENTRY	SET_WIDTH,^M<R4>
	MOVL	KEY_DSCR,R4		; Get the field descriptor address.
	CMPB	VALUE,-			; Is the desired size smaller than the
		FD$B_MIN_FLD_SIZE(R4)	;  minimum allowed for this field?
	BLSSU	10$			; Branch if so.
	CMPB	VALUE,-			; Is the desired size larger than the
		FD$B_MAX_FLD_SIZE(R4)	;  maximum allowed for this field?
	BGTRU	20$			; Branch if so.
	MOVB	VALUE,-			; Store the new field size.
		FD$B_FIELD_SIZE(R4)	;
	BRB	99$			; Jump to common code.
10$:	MOVB	FD$B_MIN_FLD_SIZE(R4),-	; Store the minimum field size.
		FD$B_FIELD_SIZE(R4)	;
	BRB	99$			; Jump to common code.
20$:	MOVB	FD$B_MAX_FLD_SIZE(R4),-	; Store the maximum field size.
		FD$B_FIELD_SIZE(R4)	;
99$:	RET



	.SBTTL		-	SET_FORMAT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to change the output format of a particular field
;	to decimal or hexadecimal.  It changes the value in the field
;	descriptor at location FD$B_FORMAT after checking that the current
;	format is not ascii or ascic.  FD$B_MAX_DATA_SIZE is set to the maximum
;	number of columns needed to display the data in the new format.  This
;	value is also compared with FD$B_TITLE_SIZE (the number of characters
;	in the field title) and the larger of the two is saved as the maximum
;	number of columns necessary to display the field (FD$B_MAX_FLD_SIZE).
;
;	Note:   This routine will return an error if the number of bytes of
;		data needed to display the field exceeds eight and the format
;		is being changed from hexadecimal to decimal.  This is because
;		the format routines will not format a value larger than a
;		quadword in decimal.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,SET_FORMAT
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	Desired format type stored at location TPARSE_BLK+TPA$L_PARAM.
;	Address of the field descriptor for the selected field stored in
;	KEY_DSCR.
;
; OUTPUTS:
;
;	Value at location TPARSE_BLK+TPA$L_PARAM stored at offset
;	FD$B_FORMAT in the field descriptor for the selected field.
;
;	Value at offset FD$B_MAX_DATA_SIZE in the field descriptor set to the
;	maximum number of columns needed to display the data.
;
;	Value at offset FD$B_MAX_FLD_SIZE in the field descriptor set to the
;	maximum number of columns needed to display the field.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
; REGISTER USAGE:
;
;	R3 -	Used to hold the number of byte of SCS data needed to display
;		the field.
;	R4 -	Points to the base address of the field descriptor for the
;		selected field.
;	R5 -	Pointer to data length to number of columns conversion table.
;--

.ENTRY	SET_FORMAT,^M<R3,R4,R5>
	MOVL	KEY_DSCR,R4		; Get the field descriptor address.
	CMPB	TPARSE_BLK+TPA$L_PARAM,-; Is the format already set to the
		FD$B_FORMAT(R4)		;  desired type?
	BEQL	99$			; Return if so.
	CMPB	FD$B_FORMAT(R4),#ASCII	; Is the field formated in ascii?
	BEQL	98$			; Error if so.
	CMPB	FD$B_FORMAT(R4),#ASCIC	; Is the field formated in ascii using
					;  a counted ascii string?
	BEQL	98$			; Error if so.
	MOVZBL	FD$B_LENGTH(R4),R3	; Get the number of bytes of SCS data
					;  needed to display this field.
	CMPB	TPARSE_BLK+TPA$L_PARAM,-; Is the new format decimal?
		#DEC			;
	BNEQ	10$			; Branch if not.
	CMPB	R3,#8			; Is the SCS data more that 8 bytes?
	BGTR	98$			; Error if so.
	MOVAL	CVT_TABLE,R5		; Point to conversion table.
	MOVB	(R5)[R3],-		; Save the maximum number of columns
		FD$B_MAX_DATA_SIZE(R4)	;  needed to display the field in
					;  decimal.
	BRB	20$			; Jump to common code.
10$:	ADDB3	R3,R3,-			; Save the maximum number of columns
		FD$B_MAX_DATA_SIZE(R4)	;  needed to display the field in
					;  hexadecimal.
20$:	MOVB	TPARSE_BLK+TPA$L_PARAM,-; Set the new format type.
		FD$B_FORMAT(R4)		;
	CMPB	FD$B_MAX_DATA_SIZE(R4),-; Are more columns required to display
		FD$B_TITLE_SIZE(R4)	;  the data than to display the field
					;  title?
	BLSSU	30$			; Branch if not.
	MOVB	FD$B_MAX_DATA_SIZE(R4),-; Make the maximum field size the same
		FD$B_MAX_FLD_SIZE(R4)	;  as the maximum data size.
	BRB	99$			; Return with success.
30$:	MOVB	FD$B_TITLE_SIZE(R4),-	; Make the maximum field size the same
		FD$B_MAX_FLD_SIZE(R4)	;  as the title size.
	BRB	99$			; Return with success.
98$:	CLRL	R0			; Indicate failure.
99$:	RET



	.SBTTL		-	SET_INTERVAL
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts the number of seconds string entered in the SET
;	INTERVAL command to binary time and stores it at location DELAY.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,SET_INTERVAL
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; INPUTS:
;
;	Desired number of seconds stored at location VALUE.
;
; OUTPUTS:
;
;	Binary representation of desired interval stored at location DELAY.
;
; RETURN STATUS:
;
;	SS$_NORMAL returned in R0.
;
;--

.ENTRY	SET_INTERVAL,^M<>

	MOVZWL	VALUE,VALUE		; Make sure VALUE is a longword.
	EMUL	#-10000000,VALUE,#0,-	; Convert the number of seconds to
		DELAY			;  binary time.
	MOVL	#SS$_NORMAL,R0		; Return success.
	RET				; Return with status.



	.SBTTL		-	SET_SCREEN
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine sets the width of the terminal screen to 80 or 132
;	columns.  If the desired width is 80 or less than the screen is set to
;	80 columns.  If the desired width is 81 or greater than the screen is
;	set to 132 columns.
;	If this routine is not being called while initialization or exit is
;	in progress and is being run on a video terminal than the display
;	header is redrawn.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,SET_SCREEN
;
; CALLED BY:
;
;	INIT
;	MAIN_ERR
;	READ_W_PROMPT
;
; INPUTS:
;
;	Desired screen width stored at location VALUE.
;
; OUTPUTS:
;
;	SCREEN_WIDTH is set to 80 or 132.
;
; IMPLICIT OUTPUTS:
;
;	Terminal is set to 80 or 132 column mode.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	SET_SCREEN,^M<>

	MOVL	#SS$_NORMAL,R0		; Assume success.
	CMPW	VALUE,#NARROW		; Is the desired screen width > 80 ?
	BGTRU	10$			; Branch if so.
	CMPW	#NARROW,SCREEN_WIDTH	; Is the terminal width already 80?
	JEQL	99$			; Return if it is.
	MOVW	#NARROW,SCREEN_WIDTH	; Set number of columns to 80.
	BBC	#DVT$V_DCRT,OUT_DEV,30$	; Branch if terminal isn't a DECcrt.
	PUSHAL	DCRT_NARROW_DSCR	; Push address of descriptor to set
					;  terminal into 80 column mode.
	BBS	#DVT$V_AVO,OUT_DEV,20$	; Branch if terminal is a DECcrt with
					;  advanced video option.
	MOVL	#24,LAST_LINE		; Save the number of the last line
					;  (bottom command line) on the
					;  terminal.
	MOVL	#23,CMD_LINE		; Save the number of the next-to-last
					;  line (top command line) on the
					;  terminal.
	MOVL	#22,LAST_DATA_LINE	; Save the number of the last line on
					;  the terminal to be used to display
					;  data.
	BRB	20$			; Jump to common code.
10$:	BBS	#DVT$V_VT52,OUT_DEV,99$	; Branch if terminal is VT52 type.
	CMPW	#WIDE,SCREEN_WIDTH	; Is the terminal width already 132?
	BEQL	99$			; Return if it is.
	MOVW	#WIDE,SCREEN_WIDTH	; Set number of columns to 132.
	BBC	#DVT$V_DCRT,OUT_DEV,99$	; Branch if terminal isn't a DECcrt.
	BBS	#DVT$V_AVO,OUT_DEV,15$	; Branch if DECcrt with advanced video
					;  option.
	MOVL	#14,LAST_LINE		; Save the number of the last line
					;  (bottom command line) on the
					;  terminal.
	MOVL	#13,CMD_LINE		; Save the number of the next-to-last
					;  line (top command line) on the
					;  terminal.
	MOVL	#12,LAST_DATA_LINE	; Save the number of the last line on
					;  the terminal to be used to display
					;  data.
15$:	PUSHAL	DCRT_WIDE_DSCR		; Push address of descriptor to set
					;  terminal into 132 column mode.
20$:	CALLS	#1,G^LIB$PUT_OUTPUT	; Set the terminal.
	BLBC	R0,99$			; Branch on error.
30$:	BBS	#MF$V_EXIT_FLAG,-	; Branch if exit flag is set.
		MISC_FLAGS,99$		;
	BBS	#MF$V_INIT_FLAG,-	; Or if INIT flag is set.
		MISC_FLAGS,99$		;
	CALLS	#0,REFRESH		; Refresh the screen.
99$:	RET



	.SBTTL		-	GET_HELP
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when the user asks for help.  The remainder
;	of the string is passed to the LBR$OUTPUT_HELP routine.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,GET_HELP
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; IMPLICIT_INPUTS:
;
;	TPARSE_BLK+TPA$L_STRINGPTR points to the first keyword in the command
;	buffer following the "HELP" command string.
;
;	CMD_LINE_DSCR contains the number of bytes in the entire command line.
;
; IMPLICIT OUTPUTS:
;
;	Help txt is output to the terminal.
;
; RETURN STATUS:
;
;	SS$_NORMAL or failed status returned in R0.
;
;--

.ENTRY	GET_HELP,^M<R11>

;
; Store the number of bytes remaining in the command string in HELP_DSCR.
;
	SUBL3	CMD_LINE_DSCR+4,-	    ; Get the number of bytes we've
		TPARSE_BLK+TPA$L_STRINGPTR,-;  already parsed.
		R0

	SUBL3	R0,CMD_LINE_DSCR,-	; Save the number of bytes remaining.
		HELP_DSCR		;
;
; Store the address of remainder of the command string in HELP_DSCR+4.
;
	MOVL	TPARSE_BLK+TPA$L_TOKENPTR,-
		HELP_DSCR+4

	MOVL	#HEADER_END-1,LINE_NUM	; Set the scrolling region to the area
	BSBW	DRAW_LAST_LINE		; Draw bottom line of the display box
					;  as the bottom line of the display
					;  header.
	JLBC	R0,99$			; Branch on error.
	BBC	#DVT$V_DCRT,OUT_DEV,10$	; Branch if terminal is not a DECcrt.
	JSB	SET_REGION_HELP		; Establish a scrolling region.
	BLBC	R0,99$			; Branch on error.
10$:	MOVL	#HEADER_END,LINE_NUM	; Set cursor to line after header.
	PUSHAW	COL_NUM			; Erase all the data.
	PUSHAW	LINE_NUM		;
	CALLS	#2,G^LIB$ERASE_PAGE	;
	BLBC	R0,99$			; Branch on error.
	PUSHAL	G^LIB$GET_INPUT		; Push address of input routine.
	PUSHAL	HELP_FLAGS		; Push address of flags.
	PUSHAL	LIBRARY_NAME		; Push address of descriptor for the
					;  library name.
	PUSHAL	HELP_DSCR		; Push address of descriptor for the
					;  help keywords.
	MOVZWL	SCREEN_WIDTH,-		; Save width of screen.
		OUTPUT_WIDTH		;
	PUSHAL	OUTPUT_WIDTH		; Push address of longword containing
					;  the output width.
	PUSHAL	G^LIB$PUT_OUTPUT	; Push address of output routine.
	CALLS	#6,G^LBR$OUTPUT_HELP	; Call librarian help routine.
	BLBC	R0,99$			; Branch on error.
	BBC	#DVT$V_DCRT,OUT_DEV,20$	; Branch if terminal is not a DECcrt.
	BSBW	SET_REGION_FULL		; Set scrolling region to use full
					;  screen.
20$:	CALLS	#0,REFRESH		; Refresh the screen.
	MOVL	#SS$_NORMAL,R0
99$:	RET



	.SBTTL		-	RESET
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine restores the default classes and fields for the cluster
;	and local reports.  It also reselects the cluster report, reenables
;	any systems that have been removed from the report, and resets the
;	screen to 80 columns if run on a DECcrt.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,RESET
;
; CALLED BY:
;
;	READ_W_PROMPT
;
; OUTPUTS
;
;	Cluster bitmap restored using copy saved by the INIT routine.
;	Local bitmap restored using copy saved by the INIT routine.
;	CURRENT_REPORT set to cluster.
;	Default cluster report classes stored in CLASS_SELECT.
;	Default local report classes stored in LOCAL_SAVE.
;
; RETURN STATUS:
;
;	None.
;
;--

.ENTRY	RESET,^M<R2,R3,R4,R5,R6,R7>

	MOVL	#80,VALUE		; Screen width = 80 columns.

;
; Set default classes for each report.
;
	MOVL	#CLS$M_ALL_SYS!CLS$M_CSB,-
		CLUST_SAVE
	MOVL	#CLS$M_LPRT!CLS$M_ERR,CLASS_SELECT
;
; Restore saved copy of cluster bitmap.
;
	MOVL	#CLUSTER_MAP_LEN,R5	; Get the length of the cluster bitmap.
	MOVAL	CLUSTER_BITMAP,R6	; Get the address of the cluster
					;  bitmap. 
	MOVAL	CL_SAVE_BITMAP,R7	; Get the address of the saved copy of
					;  the cluster bitmap.
60$:	MOVL	(R7)+,(R6)+		; Restore the cluster bitmap.
	SOBGEQ	R5,60$			;

;
; Restore the field sizes for the cluster report.
;

	MOVAL	CLUSTER_SIZE_ARRAY,R7	; Get the address of the cluster field
					;  size array.
	MOVAL	CLUSTER_TABLE,R6	; Get the address of the cluster
					;   address table.
	MOVL	#NUM_CLUSTER_DSCRS,R5	; Get the number of field descriptors
					;  for the cluster report.
	CLRL	R3			; Clear index.
70$:	MOVL	(R6)[R3],R2		; Get the address of the field
					;  descriptor.
	MOVB	(R7)[R3],-		; Copy the original field size back
		FD$B_FIELD_SIZE(R2)	 ;  into the field descriptor.
	AOBLSS	R5,R3,70$		; Loop for each field descriptor in the
					;  cluster report.
;
; Restore saved copy of the local ports bitmap.
;
	MOVL	#LOCAL_MAP_LEN,R5	; Get the length of the local bitmap.
	MOVAL	LOCAL_BITMAP,R6		; Get the address of the local bitmap. 
	MOVAL	LOC_SAVE_BITMAP,R7	; Get the address of the saved copy of
					;  the local bitmap.
80$:	MOVL	(R7)+,(R6)+		; Restore the local ports bitmap.
	SOBGEQ	R5,80$			;

;
; Restore the field sizes for the local report.
;

	MOVAL	LOCAL_SIZE_ARRAY,R7	; Get the address of the local field
					;  size array.
	MOVAL	LOCAL_TABLE,R6		; Get the address of the local
					;   address table.
	MOVL	#NUM_LOCAL_DSCRS,R5	; Get the number of field descriptors
					;  for the local report.
	CLRL	R3			; Clear index.
90$:	MOVL	(R6)[R3],R2		; Get the address of the field
					;  descriptor.
	MOVB	(R7)[R3],-		; Copy the original field size back
		FD$B_FIELD_SIZE(R2)	;  into the field descriptor.
	AOBLSS	R5,R3,90$		; Loop for each field descriptor in the
					;  local report.

	MOVC5	#0,SYS_ID_LIST,#0,-	; Restore any systems that have been
		#ID_LIST_LEN,SYS_ID_LIST;  removed from the display.
	CLRL	ID_COUNT		; Clear the number of system removed
					;  from the display.

	CLRB	SCROLL_FLAGS		; Clear the scroll flags.
	CLRB	CLSTR_SCROLL_FLAGS	; Clear the flags that will be retored
					;  as the scroll flags after call to
					;  SHOW_CLUSTER.
	CLRL	CLSTR_H_SCROLL		; Clear all the scroll counters.
	CLRL	LOCAL_H_SCROLL		;
	CLRL	V_SCROLL		;
	BICB	#RPT$M_CLSTR,-		; Force the SHOW_CLUSTER routine to
		CURRENT_REPORT		;  reset the report by setting report
					;  to the local report.
	MOVL	MISC_FLAGS,R2		; Save copy of miscellaneous flags.
	BISL	#MF$M_INIT_FLAG,-	; Set init flag so we don't draw the
		MISC_FLAGS		;  local report.
	CALLS	#0,SET_SCREEN		; Set the screen width.

ASSUME	MF$V_INIT_FLAG EQ 0

	INSV	R2,#MF$V_INIT_FLAG,#1,-	; Restore init flag to original state.
		MISC_FLAGS		;
	CALLS	#0,SHOW_CLUSTER		; Set default report to clusters.
	RET



	.SBTTL		-	EXECUTE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to execute a command procedure when requested by
;	the user (@filespec), to execute a startup initialization file
;	when Show Cluster if first envoked, and to read commands when the input
;	is from a file.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,EXECUTE
;
; CALLED BY:
;
;	INIT				; Execute initialization file.
;	READ_W_PROMPT			; Execute command procedure.
;	END_REPORT			; Get command input from a file.
;
; RETURN STATUS:
;
;	SS$_NORMAL or falied status returned in R0.
;
;--

.ENTRY	EXECUTE,^M<R2,R3,R4,R5>
					
	MOVC5	#0,IN_FILE_SPEC,#^A/ /,-; Pad the filespec with blanks.
		#IN_FILE_SPEC_LEN,-	;
		IN_FILE_SPEC		;

3$:	BBC	#MF$V_INIT_FLAG,-	; Branch if initialization not in
		MISC_FLAGS,4$		;  progress.
	MOVC3	INIT_NAME,@INIT_NAME+4,-; Store logical name in the file spec.
		IN_FILE_SPEC		;
	BRB	7$			; Jump to common.

4$:	BBC	#DVT$V_DISK,IN_DEV,5$	; Branch if input isn't from a file.
	MOVC3	IN_DEV_NAME,-		; Otherwise SYS$INPUT is the filespec.
		IN_DEV_NAME+8,-		;
		IN_FILE_SPEC		;
	BRB	7$			; Jump to common.

;
; Get the filename from the command line and store in in the filespec.
;

5$:	MOVC3	TPARSE_BLK+TPA$L_STRINGCNT,-
		@TPARSE_BLK+TPA$L_STRINGPTR,-
		IN_FILE_SPEC

7$:	$PARSE 	FAB = INFAB		; Expand the filespec.
	JLBC	R0,20$			; Branch on error.

	$OPEN	FAB = INFAB		; Open the file.
	JLBC	R0,20$			; Branch on error.
	BISL	#MF$M_IN_OPEN,MISC_FLAGS; Indicate file is open.

	$CONNECT -			; Connect to input.
		RAB = INRAB		;
	BLBC	R0,20$			; Branch on error.

10$:	$GET	RAB = INRAB		; Get a record.
	BLBC	R0,20$			; Branch on error.

	MOVW	INRAB+RAB$W_RSZ,REC_DSCR; Get the record size.
	PUSHAL	REC_DSCR		; Convert record to uppercase.
	PUSHAL	REC_DSCR		;
	CALLS	#2,G^STR$UPCASE		;

;
; Parse the record.
;

	MOVW	INRAB+RAB$W_RSZ,TPARSE_BLK+TPA$L_STRINGCNT
	MOVL	INRAB+RAB$L_RBF,TPARSE_BLK+TPA$L_STRINGPTR
	PUSHAL	CMD_KEY
	PUSHAL	CMD_STATE
	PUSHAL	TPARSE_BLK
	CALLS	#3,G^LIB$TPARSE
	BLBS	R0,10$			; Loop for entire file.

20$:	BBC	#MF$V_IN_OPEN,-		; Branch if the file isn't open.
		MISC_FLAGS,25$		;
	MOVL	R0,R2			; Save error status.
	$CLOSE	FAB = INFAB		; Close the file.
	BLBC	R0,99$			; Branch on error.
	BICL	#MF$M_IN_OPEN,MISC_FLAGS; Indicate file is closed.
	MOVL	R2,R0			; Restore previous status.
	CMPL	R0,#RMS$_EOF		; Was error condition END-OF-FILE?
	BEQL	30$			; Branch if so.
25$:	CMPL	R0,#RMS$_DEV		; Was error bad or inappropriate device?
	BNEQ	99$			; Branch if not.
	BBC	#MF$V_INIT_FLAG,-	; Ok if called by INIT, assume SHC$INIT
		MISC_FLAGS,99$		;  not defined.
30$:	MOVL	#SS$_NORMAL,R0		; Indicate success.
	BBS	#MF$V_INIT_FLAG,-	; Branch if initialization pass.
		MISC_FLAGS,99$		;
	CALLS	#0,REFRESH		; Update the screen.
99$:	RET


	.END	START

