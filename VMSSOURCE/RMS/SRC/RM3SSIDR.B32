MODULE RM3SSIDR (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                Search thru a SIDR array and return the first
!		 non-deleted record
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Todd M. Katz		RE-CREATION DATE:	23-Jun-1982
!
!
! MODIFIED BY:
!
!	V03-022	RAS0164		Ron Schaefer		29-Jun-1983
!		Make references to RM$RU_RECLAIM be LONG_RELATIVE addressing.
!
!	V03-021 MCN0002		Maria del C. Nasr	24-Mar-1983
!		More linkages reorganization
!
!	V03-020	TMK0013		Todd M. Katz		11-Mar-1983
!		Make a change to RM$FOLLOW_PTR so that the primary data bucket
!		containing the target record is exclusively accessed if it is
!		possible that some reclamation maybe done (the file is write
! 		accessed and Recovery Unit Journallable).
!
!	V03-019 MCN0001		Maria del C. Nasr	28-Feb-1983
!		Reorganize linkages
!
!	V03-018	TMK0012		Todd M. Katz		18-Jan-1983
!		Add support for Recovery Unit Journalling and RU ROLLBACK
!		Recovery of ISAM files. Support involves modifications to
!		the routine RM$FOLLOW_PTR.
!
!		The purpose of the routines within this module is to find the 
!		next non-deleted primary data record by means of an alternate
!		index. Towards this goal, RMS will search all SIDRs with key
!		values matching the key in keybuffer 2 according to the 
!		characteristics of the search, until such a record is found. If
!		during its search RMS encounters records that are marked 
!		RU_DELETE, RMS will try and delete them for good at this time 
!		provided it has write access to the file and the Recovery Unit 
!		in which they were deleted has completed successfully. 
!
!		If RMS is able to delete a primary data record marked RU_DELETE,
!		then RMS proceeds to continue looking for a non-deleted primary
!		data record just as if it had encountered a deleted record in
!		the first place. Likewise, if RMS is unable to delete a record
!		that is marked RU_DELETE because it does not have write access
!		to the file, it will also continue its search. However, if RMS 
!		is unable to delete a RU_DELETE marked record for good because
!		the Recovery Unit in which it was marked RU_DELETE has not
!		successfully terminated, then RMS returns this record as if it
!		was the next non-deleted primary data record, and lets a higher
!		higher level routine decide whether or not to wait for the
!		Recovery Unit in which the record was deleted to complete, or to
!		return an error to the user.
!
!		RMS will also re-format any records that are marked RU_UPDATE
!		and are in a special format provided the stream has write access
!		to the file, and the Recovery Unit in which the record was 
!		updated has terminated.
!
!		In addition to this change, I have made a further enhancement to
!		the routine RM$SEARCH_SIDR. At the present time, when a SIDR 
!		array element is encountered that should have been marked 
!		deleted, it is marked deleted without recovering any space if 
!		and only if the stream has write access to the file, and the 
!		file is not being shared. I have changed this by removing the 
!		restriction that to mark a SIDR element deleted the file can not
!		be shared. Furthermore, RMS will now not only mark such elements
!		as deleted, but reclaim as much space as possible as long as the
!		stream has write access to the file.
!
!	V03-017	TMK0011		Todd M. Katz		05-Jan-1983
!		Eliminate the routine RM$FND_SDR_ARRY. This global routine is
!		now being called in only one place, and has been folded directly
!		into the code.
!
!	V03-016	TMK0010		Todd M. Katz		04-Jan-1983
!		If during positioning to the next primary data record by means
!		of an alternate index, RMS encounters a SIDR element that is
!		not marked deleted although the primary data record it points 
!		to is either deleted or the alternate key does not match the
!		key of the SIDR, then RMS may mark the element deleted provided
!		the file is not being shared and has been open for write access
!		before it continues its search for the next primary data record.
!		If either of these two conditions is violated, RMS can not mark
!		the element deleted, but just positions past it to continue the
!		search. What it should also be doing when it positions past the
!		element in this case is increment the count of the number of 
!		preceeding elements in the current SIDR array. RMS was not 
!		doing this and this represents a bug.
!
!	V03-015	TMK0009		Todd M. Katz		07-Dec-1982
!		Remove all the re-positioning code. Sigh. This code was
!		originally required to fix the 1.5 SIDR deadlock problem. I
!		have come up with a different way to fix this problem. I have
!		changed how buckets are locked during $DELETEs. A stream can now
!		never hold onto a primary data bucket while attempting to 
!		access a SIDR bucket. Therefore, a stream is able to hold onto
!		a SIDR bucket while waiting for a primary data bucket without 
!		the possibility of a deadlock existing. Thus, there is no 
!		longer any need to perform any type of SIDR re-positioning, and 
!		I have eliminated all the new code that used to do it.
!
!	V03-014	TMK0008		Todd M. Katz		12-Nov-1982
!		The routine RM$FND_SDR_ARRY requires as input, the size of the
!		secondary key it is to search for in IRB$B_KEYSZ. This IRAB
!		cell might not have the correct key size when this routine is
!		called from within RM$SIDR_REPOS. Yet, RM$SIDR_REPOS can not
!		merely overwrite the cell with the correct key size because
!		RMS might be performing a generic search at the time SIDR
!		re-positioning was required, and might later need the value 
!		stored there. Therefore, RMS must save the value in IRB$B_KEYSZ
!		when the routine RM$SIDR_REPOS is entered, set it to the full
!		key size, and restore the original value when the routine is
!		exited. If this is not done, the possibility exists that
!		RM$FND_SDR_ARRY might position RMS to the wrong SIDR instead
!		of to the SIDR it was positioned to when the routine was first
!		entered.
!
!	V03-013	TMK0007		Todd M. Katz		09-Nov-1982
!		Make another change to the SIDR re-positioning code. IF RMS is
!		unable to position either to the primary data record, or back to
!		the SIDR during SIDR re-positioning, then before returning RMS
!		ascertains whether it was unsuccessful in positioning to the
!		current SIDR array, or whether it was unsuccessful at 
!		positioning even to the SIDR itself. The former case represents
!		an error, the latter is reasonable because the SIDR could have
!		been deleted and the space it occupied reclaimed. During this
!		attempt to re-position to the current SIDR, performed by the
!		routine RM$FIND_SIDR, RMS will position either to the current 
!		SIDR (which would represent an error), or to the next SIDR that 
!		followed this SIDR. However, if RMS is unable to position to the
!		current SIDR and there is no next SIDR (the end-of-file is
!		encountered), then RM$FIND_SIDR returns an error of RNF. 
!		Unfortunately, the routine RM$SIDR_REPOS can not return this 
!		status to its caller (RM$SEARCH_SIDR) because that would 
!		indicate that RMS was unable to find the primary data record
!		during re-positioning - a very grave error and definitly not 
!		the case here. When RM$SIDR_REPOS returns an error of RNF 
!		signalling this very bad condition, RMS converts it into a BUG 
!		error, and returns it to the user. However, the error RMS does 
!		want to return from RM$SEARCH_SIDR in the case when RMS finds 
!		both the primary data record and the SIDR deleted during 
!		re-positioning and is unable to position to the next SIDR 
!		because of encountering the end-of-file is in fact RNF! In 
!		order to arrange things so that this error will be returned 
!		under these circumstances, I have changed RM$SIDR_REPOS so 
!		that it will return an error of EOF when RM$FIND_SIDR returns 
!		RNF and RM$SEARCH_SIDR so that it changes the EOF returned by 
!		RM$SIDR_REPOS back to RNF.
!
!	V03-012	TMK0006		Todd M. Katz		29-Oct-1982
!		If RMS is successful at finding the target primary data record
!		within RM$FOLLOW_PTR, then save the current index descriptor and
!		replace it with the index descriptor for the primary key before
!		determining record overhead and size of the primary data record.
!		After this determination is made, the descriptor is restored.
!
!	V03-011	TMK0005		Todd M. Katz		22-Sep-1982
!		If a SIDR re-positioning is required, and key compression is
!		enabled, then reset the variable containing the address of the 
!		last record in the bucket encountered with a zero front 
!		compressed key to be the first record in the bucket. This 
!		resetting is only required when RMS must continue the search 
!		for a non-deleted primary data record within the current SIDR, 
!		and when the possibility exists that the search maybe continued 
!		in a SIDR with a completly different key value necessitating 
!		its expansion into keybuffer 2. This resetting is necessary 
!		because during the re-positioning RMS had to release the SIDR 
!		bucket, and then reclaim it, and while it didn't have it locked,
!		anything might have happened to its contents. The reason why 
!		the variable is initialized with the address of the first SIDR 
!		in the bucket is because the key of the first SIDR must be zero 
!		front compressed, and it is the last known record with such a 
!		property.
!
!	V03-010	KBT0329		Keith B. Thompson	22-Sep-1982
!		Change check for sharing to sfsb test
!
!	V03-009	TMK0004		Todd M. Katz		06-Sep-1982
!		The field IRB$B_SRCHFLAGS is now a word. Fix all references
!		to it.
!
!		The routine RM$SEARCH_SIDR maybe called to search SIDR arrays
!		for a non-deleted primary data record either when RMS is 
!		positioning sequentially, or when RMS is positioning randomly
!		by an alternate key value. When I initially wrote this routine
!		I mistakenly wrote it for the sequential case only. Since in 
!		this case RM$SEARCH_SIDR only has to search those SIDRs whose 
!		keys exactly match the full size search key, this mean't that
!		positioning randomly by key was broken for all cases involving
!		generic search keys, greater-than searches, or greater-than or
!		equal searches when more than one SIDR had to be searched.
!		The fix for this set of problems was actually quite simple. If
!		the search characteristics are not setup such that RMS is
!		performing an exact match search, the routine RM$SEARCH_SIDR
!		saves the search key in keybuffer 5, and extracts the key of
!		the current SIDR into keybuffer 2. When this SIDR is exhausted
!		and a non-deleted primary data record has not been found, RMS
!		returns the search key saved in keybuffer 5 to keybuffer 2,
!		and determines whether the key of the next SIDR matches the
!		search key according to the characteristics of the search. If 
!		so, this whole cycle repeats itself, otherwise, this routine 
!		returns the appropriate error to its caller.
!
!		I also made a change to RM$SIDR_REPOS involving the case when
!		RMS is unable to position to a primary data record because it
!		has been deleted, and when it re-positions back to the SIDR
!		it finds that it too has been deleted. In such a case, because
!		RMS was unable to re-position to the SIDR, it did a 
!		greater-than or equal search and had positioned exactly to the 
!		SIDR that followed. This is exactly where RMS wants to continue
!		its search for a non-deleted primary data record provided the
!		key of this SIDR matches search key according to the search
!		characteristics. Therefore, all the routine RM$SIDR_REPOS has to
!		do is return a 0. The routine RM$SEARCH_SIDR, when it sees this 
!		0, knows that the current SIDR has been exhaused (or in this 
!		case deleted), and that it should go determine whether the 
!		search can continue with the SIDR it now finds itself 
!		positioned to.
!
!	V03-008	KBT0298		Keith B. Thompson	24-Aug-1982
!		Reorganize psects
!
!	V03-007	TMK0003		Todd M. Katz		10-Aug-1982
!		Change the linkage of RM$SIDR_REPOS. The address of the
!		beginning of the SIDR is now both in the input parameter
!		list and in the output parameter list. This is necessary
!		instead of just passing its address to this routine, an address
!		of a stack location, because this routine will allow RMS to 
!		stall, and when RMS resumes after a stall, the stack addresses 
!		are not necessairly the same as they were before the stall. 
!
!	V03-006	TMK0002		Todd M. Katz		10-Aug-1982
!		When RMS positions to the first non-deleted primary data
!		record by alternate key, it first skips past all entries
!		within a SIDR that are marked deleted until either the
!		end of the SIDR is encountered, or a non-deleted entry is
!		found. Using this non-deleted entry, RMS attempts to position
!		to the primary data record. If RMS finds that the data record
!		is in fact deleted, it wants to mark the SIDR entry deleted, 
!		and return to the loop that looks for a non-deleted SIDR entry.
!		There it starts its search for a non-deleted SIDR array element
!		with the current SIDR element which of course RMS has just
!		marked deleted. However, RMS can only mark such a SIDR entry
!		deleted if it has write access to the file and the file is not
!		being shared. Thus, the way this RMS currently works, if the
!		file was being shared or had not been opened for write access
!		and RMS has positioned to a non-deleted SIDR array element
!		which pointed to a deleted primary data record, RMS would not 
!		mark the SIDR entry deleted, it would return to the loop which 
!		searches for the first non-deleted SIDR entry starting with the 
!		current entry, and it would position to the very same 
!		non-deleted entry (which points to a deleted primary data 
!		record). The result is an infinite loop! To fix this problem, 
!		RMS will now immediately position past the current element to 
!		the next one when it finds that the current non-deleted SIDR 
!		element points to a deleted primary data record, and it is 
!		unable to mark the SIDR element deleted at that point.
!
!	V03-005	TMK0001		Todd M. Katz		22-Jun-1982
!		Revised entire module.
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! Define default PSECTS for code
!
PSECT
    CODE = RM$RMS3(PSECT_ATTR),
    PLIT = RM$RMS3(PSECT_ATTR);

! Linkages
!
LINKAGE
    L_PRESERVE1,
    L_RABREG_567,
    L_RABREG_67,
    L_RABREG_7,
    L_REC_OVHD,
    L_SIDR_FIRST,
    L_JSB01,

! Linkages for Local Routines
!
    RL$FOLLOW_PTR = JSB () 
		  : GLOBAL (COMMON_RABREG, R_REC_ADDR, R_IDX_DFN),
    RL$POS_BY_COUNT = JSB (REGISTER = 1)
		    : GLOBAL (COMMON_RABREG, R_REC_ADDR, R_IDX_DFN);

! External Routines
!
EXTERNAL ROUTINE
    RM$COMPARE_REC	: RL$RABREG_67,
    RM$CSEARCH_TREE	: RL$RABREG_67,
    RM$EXT_ARRY_RFA	: RL$RABREG_67,
    RM$FIND_BY_RRV	: RL$RABREG_67,
    RM$KEY_DESC		: RL$RABREG_7,
    RM$GETNXT_ARRAY	: RL$RABREG_67,
    RM$RECORD_KEY	: RL$PRESERVE1,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$RLSBKT		: RL$PRESERVE1,
    RM$RU_RECLAIM	: RL$RABREG_67 ADDRESSING_MODE(LONG_RELATIVE),
    RM$SIDR_END		: RL$RABREG_67,
    RM$SIDR_FIRST	: RL$SIDR_FIRST,
    RM$SQUISH_SIDR	: RL$RABREG_567,
    RM$UNPACK_REC	: RL$JSB01;
		      
! Forward Routine
!
FORWARD ROUTINE
	RM$POS_BY_COUNT	: RL$POS_BY_COUNT;

%SBTTL 'RM$FOLLOW_PTR'
ROUTINE RM$FOLLOW_PTR (VBN, ID)	: RL$FOLLOW_PTR =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine recieves as input the RFA of an allegedly non-deleted
!	primary data record containing a secondary key of specific value. It
!	positions to that primary data record, and checks whether it is deleted
!	and if not, whether the secondary key whose specific value is stored 
!	in keybuffer 2 has been deleted from the primary data record.
!	
!	If RMS finds that the target primary data record is marked RU_DELETE
!	and the Recovery Unit in which the record was deleted is still active,
!	then RMS returns positioned to this record and lets a higher level 
!	routine decide what to do. If the Recovery Unit in which the record was 
!	deleted has successfully terminated, then RMS will return an error of 
!	DEL after deleting this RU_DELETEd record (if it has write access to 
!	the file), and releasing the primary data bucket.
!
!	If RMS encounters a record that is marked RU_UPDATE and is in a special
!	format then RMS will return positioned to this record after
!	reformatting it. The reformatting is done if RMS has write access to 
!	the file, and the Recovery Unit in which it was updated has 
!	successfully terminated.
!
! CALLING SEQUENCE:
!
!	BSBW RM$FOLLOW_PTR ()
!
! INPUT PARAMETERS:
!
!	VBN		- RFA VBN of the target primary data record
!	ID		- RFA ID of the target primary data record
!
! IMPLICIT INPUTS:
!
!	IDX_DFN			- address of current index descriptor
!	    IDX$B_KEYSZ		- size of secondary key
!	    IDX$W_MINRECSZ	- minimum size of record to contain key
!
!	IFAB			- address of IFAB
!	    IFB$B_KBUFSZ	- size of each keybuffer
!	    IFB$B_PLG_VER	- prologue version of file
!	    IFB$V_RU		- if set, the file is Recovery Unit Journallable
!	    IFB$V_WRTACC	- if set, file is open for write access
!
!	IRAB			- address of IRAB
!	    IRB$L_CURBDB	- address of SIDR bucket's BDB
!				  (0 if re-positioning)
!	    IRB$L_KEYBUF	- address of keybuffers
!	    IRB$L_RECBUF	- address of internal record buffer
!
!	REC_ADDR		- address of SIDR array element
!				  (invalid if re-positioning)
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB
!	    IRB$L_CURBDB	- address of primary data bucket's BDB (success)
!				  or contents on input (failure)
!	    IRB$L_NXTBDB	- contents on input (success)
!				  or 0 (failure)
!	    IRB$L_RECBUF	- unpacked primary data record 
!				  (success and prologue 3 file)
!	    IRB$V_RU_DELETE	- if set, do not reclaim SIDR array space
!
!	REC_ADDR		- address of primary data bucket (success)
!				  or contents on input (failure)
!
! ROUTINE VALUE:
!
!	SUC	- non-deleted primary data record successfully positioned to.
!	DEL	- primary data record deleted or specific alternate key deleted
!		  from primary data record.
!	RNF	- primary data record not found.
!	various I/O errors
!
! SIDE EFFECTS:
!
!	On success, REC_ADDR points to the primary data record (which will be 
!	     unpacked if the file's prologue version is 3), the primary data
!	     bucket's BDB address is stored in IRB$L_CURBDB, and IRB$L_NXTBDB 
!	     contains whatever was in IRB$L_CURBDB on input.
!	On any and all failures, REC_ADDR points to whatever it had pointed to
!	     on input, IRB$L_CURBDB contains whatever it contained on input,
!	     and any buckets accessed have been released.
!	If the record is marked RU_DELETEd, it might have been deleted.
!	If the record is marked RU_UPDATE or RU_DELETEd and RMS is unable to
!	     recover any space from it because the Recovery Unit in which the
!	     record was modified has not completed, then RMS sets the state
!	     bit IRB$V_RU_DELETE whenever it makes a decision to return an error
!	     status of RMS$_DEL and the file has been opened for write access.
!	     This will guarentee that the coresponding SIDR array element will
!	     only be marked RU_DELETE, and no space will be reclaimed from it.
!	If the record is marked RU_UPDATEd, it might have been reformatted.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    LOCAL
	SAVE_SDR_ADDR,
	STATUS;

    ! Save the current SIDR array's address, and the address of the SIDR 
    ! bucket's BDB while performing the primary data record lookup.
    !
    SAVE_SDR_ADDR = .REC_ADDR;
    IRAB[IRB$L_NXTBDB] = .IRAB[IRB$L_CURBDB];

    ! If the file is write accessed and Recovery Unit Journallable, then make
    ! sure the primary data bucket containing the target record is exclusively
    ! accessed in case reclamation is required.
    !
    IF  .IFAB[IFB$V_WRTACC]
	 AND
	.IFAB[IFB$V_RU]
    THEN
	IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

    ! Position to the primary data record pointing at by the SIDR array element
    ! RMS has positioned to.
    !
    STATUS = RM$FIND_BY_RRV (.VBN, .ID, 0);

    ! If RMS is successful at positioning to tthe target primary data record
    ! only to find that it has been deleted within a Recovery Unit, subject
    ! this record to further processing before deciding what to do with this 
    ! record.
    !
    IF  .STATUS
	 AND
	.REC_ADDR[IRC$V_RU_DELETE]
    THEN
	BEGIN

	LOCAL
	    TEMP_STATUS;

	! If the Recovery Unit in which the current record was deleted has
	! not completed, or if the file has not been opened for write access
	! then RMS will not be able to reclaim any space from the record. RMS
	! may still want to consider this record as a non-deleted primary data 
	! record though.
	!
	IF  NOT (TEMP_STATUS = RM$RU_RECLAIM())
	THEN
	    BEGIN

	    ! If the current record was deleted within a currently active 
	    ! Recovery Unit and it was this stream that deleted it; or, if
	    ! this stream is able to lock the record but does not have write
	    ! access to the file, then RMS wants to treat this record as if it 
	    ! is actually deleted. To do so, RMS will return a status of 
	    ! RMS$_DEL so that the search will continue. However, RMS will also 
	    ! set the state bit IRB$V_RU_DELETE, if it has write access to the 
	    ! file, so that no space is reclaimed from the corresponding SIDR 
	    ! array element.
	    !
	    IF .TEMP_STATUS<0,16> NEQU RMSERR(RLK)
	    THEN
		BEGIN
		STATUS = RMSERR(DEL);

		IF .IFAB[IFB$V_WRTACC]
		THEN
		    IRAB[IRB$V_RU_DELETE] = 1;
		END;
	    END

	! The Recovery Unit in which the current record was deleted has
	! completed successfully and RMS was able to reclaim some space
	! from the record. RMS changes the status to RMS$_DEL so that the 
	! search will be continued.
	!
	ELSE
	    STATUS = RMSERR(DEL);

	! If RMS has discovered that the Recovery Unit in which the target 
	! primary data record was deleted has terminated successfully and that 
	! the record is in fact deleted, then release the primary data bucket
 	! containing the record.
	!
	IF .STATUS<0,16> EQLU RMSERR(DEL)
	THEN
	    BEGIN

	    GLOBAL REGISTER
		R_BDB_STR;

	    RELEASE (IRAB[IRB$L_CURBDB]);
	    END;
	END;

    ! If RMS was successful at positioning to the target primary data record
    ! only to find that it had been updated but not deleted within a Recovery
    ! Unit, and if the file has been opened for write access, then RMS will 
    ! try to re-format the record provided the Recovery Unit in which the record
    ! was modified has completed.
    !
    IF  .STATUS
	 AND
	.IFAB[IFB$V_WRTACC]
	 AND
	.REC_ADDR[IRC$V_RU_UPDATE]
	 AND
	NOT .REC_ADDR[IRC$V_RU_DELETE]
    THEN
	RM$RU_RECLAIM();

    ! If RMS was successful at positioning to the primary data record pointed
    ! at by the SIDR array element, and the record is NOT marked deleted, then
    ! RMS must make sure that it is the right one - ie that the alternate key in
    ! this index matches the key of the SIDR which has been saved in 
    ! keybuffer 2.
    !
    IF .STATUS
    THEN
	BEGIN

	LOCAL
	    RECORD_OVHD,
	    RECORD_SIZE,
	    SAVE_UDR_ADDR : REF BBLOCK;

	SAVE_UDR_ADDR = .REC_ADDR;

	! Determine the size of the primary data record's overhead, and the 
	! size of the primary data record itself. This is necessary to
	! determine whether or not the alternate key has been deleted through
	! truncation of part of the record.
	!
	BEGIN

	LOCAL
	    REC_SIZE,
	    SAVE_IDX_DFN : REF BBLOCK;

	SAVE_IDX_DFN = .IDX_DFN;
	RM$KEY_DESC (0);

	RECORD_OVHD = RM$REC_OVHD(0; REC_SIZE);

	! If the target primary data record was updated within a Recovery
	! Unit then the true size of the primary data record maybe retrieved
	! from the last two bytes in the reserved space of the record.
	!
	IF .REC_ADDR[IRC$V_RU_UPDATE]
	THEN
	    RECORD_SIZE = .(.REC_ADDR + .RECORD_OVHD 
				      + .REC_SIZE 
				      - IRC$C_DATSZFLD)<0,16>
	ELSE
	    RECORD_SIZE = .REC_SIZE;

	IDX_DFN = .SAVE_IDX_DFN;
	END;

	! If this is a prologue 3 file then the record must be unpacked in 
	! order to obtain the full size of the record and to be able to compare
	! the SIDR key with the alternate key in the data record itself. RMS
	! also sets REC_ADDR to point to the unpacked record, so that the
	! alternate key may easily be extracted from the record for key 
	! comparison.
	!
	! NOTE that because RMS always unpacks prologue 3 primary data records
	! when positioning by a secondary key for key comparison, it is never
	! necessary to unpack the record a second time during a $GET/$FIND.
	!
	IF .IFAB[IFB$B_PLG_VER] GEQU PLG$C_VER_3
	THEN
	    BEGIN

	    BUILTIN
		AP;

	    GLOBAL REGISTER
		R_BKT_ADDR;

	    REC_ADDR = .REC_ADDR + .RECORD_OVHD;

	    AP = 0;
	    RECORD_SIZE = RM$UNPACK_REC (.IRAB[IRB$L_RECBUF], .RECORD_SIZE);

	    REC_ADDR = .IRAB[IRB$L_RECBUF];
	    END;

	! If the primary data record is of sufficient size to contain the 
	! alternate key (ie - the alternate key has not been deleted through
	! truncation of the record during the process of updating the record
	! by some other process), then RMS determines whether or not the
	! alternate key in the record still matches the SIDR it has positioned
	! to. If this is the case then RMS has found the next non-deleted
	! primary data record, and returns success.
	!
	IF (.RECORD_SIZE GEQU .IDX_DFN[IDX$W_MINRECSZ])
	     AND
	   (NOT RM$COMPARE_REC (KEYBUF_ADDR(2), .IDX_DFN[IDX$B_KEYSZ], -1))
	THEN
	    BEGIN
	    REC_ADDR = .SAVE_UDR_ADDR;
	    RETURN RMSSUC();
	    END

	! If the secondary key has been deleted totally from the record through
	! truncation of the record during an $UPDATE by another process, or
	! if during the $UPDATE the secondary key changed, and the secondary
	! key in the primary data record no longer matches the key of the SIDR 
	! RMS is positioned to, then this is not the next non-deleted primary
	! data record. In this case, RMS releases the primary data bucket, and 
	! sets up to return an error status of record deleted, so that the 
	! search for the next non-deleted primary data record can continue.
	!
	ELSE
	    BEGIN

	    GLOBAL REGISTER
		R_BDB_STR;

	    ! If the target primary data record has been modified within a
	    ! Recovery Unit, and the stream has write access to the file so
	    ! that some attempt will be made to reclaim the space occupied by
	    ! SIDR array element, then set up so that when the SIDR array 
	    ! element pointing to this primary data record is deleted, it is 
	    ! only marked RU_DELETE, and no space is reclaimed.
	    !
	    IF  .IFAB[IFB$V_WRTACC]
		 AND
		(.SAVE_UDR_ADDR[IRC$V_RU_DELETE]
			 OR
			.SAVE_UDR_ADDR[IRC$V_RU_UPDATE])
	    THEN
		IRAB[IRB$V_RU_DELETE] = 1;

	    RELEASE(IRAB[IRB$L_CURBDB]);
	    STATUS = RMSERR(DEL);
	    END;

	END;

    ! If RMS was unable to position to the target primary data record, or if
    ! after positioning to the record it found that the record itself, or the
    ! secondary key it expected to find there had been deleted, then RMS
    ! restores the address of the SIDR bucket's BDB to IRB$L_CURBDB, and the
    ! address of the SIDR array element it currently has positioned to 
    ! to REC_ADDR, and it returns the appropriate status.
    !
    IRAB[IRB$L_CURBDB] = .IRAB[IRB$L_NXTBDB];
    IRAB[IRB$L_NXTBDB] = 0;
    REC_ADDR = .SAVE_SDR_ADDR;

    RETURN .STATUS;

    END;					! {  of routine }

%SBTTL 'RM$POS_BY_COUNT'
ROUTINE RM$POS_BY_COUNT (SKIP_NUMBER) : RL$POS_BY_COUNT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine's responsibility is to position to a particular SIDR
!	array element. It does this by skipping SKIP_NUMBER array elements.
!
! CALLING SEQUENCE:
!
!	BSBW RM$POS_BY_COUNT()
!
! INPUT PARAMETERS:
!
!	SKIP_NUMBER	- number of array elements to skip
!
! IMPLICIT INPUTS:
!
!	REC_ADDR		- address of SIDR
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	REC_ADDR		- address of desired array element
!
! ROUTINE VALUE:
!
!	SUC 	- positioned to desired array element.
!	BUG	- the number of array elements preceeding the desired
!		  element exceeds the number of elements in the entire array.
!
! SIDE EFFECTS:
!
!	on success, REC_ADDR points to the desired array element.
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    LOCAL
	END_OF_SIDR;

    ! Find the end of the current SIDR.
    !
    END_OF_SIDR = RM$SIDR_END();

    ! Position to the SIDR's first array element
    !
    REC_ADDR = RM$SIDR_FIRST(0);

    ! Skip the desired number of array elements, or until the end of the SIDR
    ! is encountered - which ever comes first.
    !
    DECRU LOOP_INDEX FROM .SKIP_NUMBER TO 1 BY 1
    DO

	! If the end of the SIDR is encountered before the desired array 
	! element is encountered then this represents an invalid internal
	! condition, and report it as such.
	!
	IF .REC_ADDR GEQA .END_OF_SIDR
	THEN
	    RETURN RMSERR(BUG)

	! Position past the current array element to the next array element.
	!
	ELSE
	    RM$GETNXT_ARRAY();

    ! Having positioned to the desired SIDR arrary element, return success.
    !
    RETURN RMSSUC();
    END;					! {  of routine }

%SBTTL 'RM$SEARCH_SIDR'
GLOBAL ROUTINE RM$SEARCH_SIDR : RL$RABREG_67 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	The purpose of this routine is to search for a non-deleted primary
!	data record by means of an alternate key of reference. This routine
!	starts its search with an array element in the current SIDR array. If
!	RMS is positioning sequentially, then the array element RMS starts
!	its search with will always be one more that the value in 
!	IRB$W_SAVE_POS. Thus, RMS may start its search with any of the elements
!	in the current SIDR array depending upon the value in this variable.
!	However, if RMS is positioning randomly by key value, then RMS will
!	always start its search for a non-deleted primary data record with the
!	very first element in the current SIDR.
!
!	When the current SIDR array is exhausted, RMS will attempt to continue
!	its search within the very next SIDR array that follows. RMS may 
!	continue its search provided the key of this next SIDR matches the
!	characteristics of the search. These search characteristics include the
!	search key itself (in keybuffer 2), the size of the search key (in
!	IRB$B_KEYSZ) which may not be the same as the size of the alternate key
!	itself, and whether the search is for an equal match, a greater-than
!	or equal match (IRB$V_SRCHGE is set), or a greater-than match 
!	(IRB$V_SRCHGT is set). If RMS is positioning randomly then any possible
!	combination of these search characteristics is possible, but when RMS is
!	positioning sequentially, RMS will only search those SIDRs whose key
!	exactly matches the full size search key in keybuffer 2.
!
!	If during its search for a non-deleted primary data record RMS 
!	encounters a non-deleted SIDR array element pointing to a deleted 
!	primary data record, then RMS will mark the SIDR array element deleted 
!	and reclaim as much space from the SIDR as it can according to the 
!	normal rules of SIDR deletion. However, such activity will only take
!	place if the stream has write access to the file.
!
!	This routine concludes its search when either an error occurs, it is
!	successful at positioning to a non-deleted primary data record, or it
!	exhausts all SIDRs matching the search characteristics without 
!	positioning to such a primary data record.
!
! CALLING SEQUENCE:
!
!	BSBW RM$SEARCH_SIDR()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN  		- address of index descriptor describing key
!	    IDX$V_KEY_COMPR	- if set, SIDR key compression is enabled
!	    IDX$B_KEYSZ		- size of key
!
!	IFAB	 		- address of IFAB
!	    IFB$L_SFSB_PTR	- pointer to file shared file sync. block
!	    IFB$W_KBUFSZ	- size of a keybuffer
!	    IFB$V_WRTACC	- if set, file is write accessed
!
!	IRAB     		- address of IRAB
!	    IRB$L_CURBDB	- address of SIDR bucket's BDB
!	    IRB$L_KEYBUF	- pointer to the contigious keybuffers
!	    IRB$B_KEYSZ		- size of search key
!	    IRB$L_LST_NCMP	- address of last zero front compressed key
!	    IRB$V_PRM		- if set, permanence should be set in SIDR BDB
!	    IRB$W_SAVE_POS	- number of elements preceeding starting point
!	    IRB$V_SRCHGE	- if set, search for GE match 
!	    IRB$V_SRCHGT	- if set, search for GT match 
!
!	REC_ADDR 		- address of SIDR within bucket
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB			- address of IRAB
!	    IRB$L_CURBDB	- address of primary data bucket's BDB
!	    IRB$W_FIRST_ID	- RFA ID of new current SIDR's first element 
!	    IRB$L_FIRST_VBN	- RFA VBN of new current SIDR's first element 
!	    IRB$L_LST_NCMP	- address of last zero front compressed key
!	    IRB$L_RFA_VBN	- VBN of new current SIDR's bucket
!	    IRB$W_SAVE_POS	- number of elements before new current element
!
!	REC_ADDR	- address of primary data record
!
! ROUTINE VALUE:
!
!	BUG	- invalid internal condition
!	SUC	- next non-deleted primary data record found
!	RNF	- all SIDRs of this key value exhausted
!	various I/O errors
!
! SIDE EFFECTS:
!
!	AP is trashed.
!	Keybuffer 5 will contain the search key, if this routine was called
!		with a generic search key (search key size less than key size),
!		or to find the first SIDR with a key greater-than or 
!		greater-than-or-equal to the search key in keybuffer 2.
!	On success, IRB$L_CURBDB contains the primary data bucket's BDB 
!		address, the SIDR bucket will have been released, REC_ADDR
!		points to the primary data bucket, and the IRAB contains
!		sufficient information necessary to uniquely identify and 
!		re-position to the SIDR array element pointing to the 
!		non-deleted primary data record. In addition, keybuffer 2 will
!		contain the key of the SIDR.
!	On all errors except for a RNF found error, the SIDR bucket will have 
!		been released and possibly marked dirty/permanent.
!	SIDR array elements and in fact whole SIDRs might have been deleted
!		if the stream positioning has write access to the file.
!
!--

    BEGIN

    BUILTIN
	AP,
	TESTBITSC;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    LABEL
	NEXT;
	
    LOCAL
	BEG_OF_SIDR,
	END_OF_SIDR,
	FLAGS		: BLOCK [1],
	STATUS;

    MACRO
	FIRST_TIME	= 0,0,1,0 %,
	NEW_KEY		= 0,1,1,0 %;

    FLAGS[FIRST_TIME] = 1;

    ! Save the address of the SIDR, and the address of the first byte past the 
    ! last SIDR array element (ie the end of the SIDR). 
    !
    BEG_OF_SIDR = .REC_ADDR;
    END_OF_SIDR = RM$SIDR_END();

    ! RMS must perform an initial positioning before it begins its search for
    ! the next non-deleted primary data record. This positioning depends upon
    ! whether RMS is positioning randomly by key value, or is positioning
    ! sequentially. In the latter case, where RMS initially positions to will
    ! depend upon whether RMS had been able to position to the current SIDR 
    ! before calling this routine. Thus, this routine is faced with four 
    ! different ways in which it could perform this initial positioning 
    ! depending upon the mode of access, and if the access mode is sequential,
    ! whether or not RMS had positioned to the current SIDR before this 
    ! routine was called.
    ! 
    ! 1. If RMS is positioning randomly by key value then RMS has positioned to
    !	 the first SIDR whose key matches the search key according to the 
    !	 search characteristics, and RMS wants to begin its search for a
    !    non-deleted primary data record with the very first element in the 
    !	 SIDR array. 
    !
    ! 2. This is the first positioning attempt after a $REWIND or $CONNECT and
    !	 as it is sequential there is no current SIDR. In this case RMS has 
    !	 positioned to the very first SIDR it could find, and begins its search 
    !	 for the next non-deleted primary data record with the very first 
    !	 element in the SIDR array. 
    !
    ! 3. RMS has successfully positioned to the current SIDR. In this case RMS
    ! 	 begins its search for the next non-deleted primary data record with
    !	 the first element that follows the current SIDR element. Note that
    !	 there may not be a following element in which case RMS exhausts the
    !	 current SIDR very quickly. 
    !
    ! 4. RMS was unable to position to the current SIDR before calling this
    !	 routine. This could only be because the entire current SIDR was 
    !	 deleted. In this case RMS has positioned to the first SIDR with a
    !    key value greater than or equal to the key of the current SIDR, and
    !	 it begins its search for the next non-deleted primary data record with
    !	 the first array element in this SIDR. 
    !
    RM$POS_BY_COUNT (.IRAB[IRB$W_SAVE_POS]);

    ! If RMS is positioning randomly by key value and either the size of the 
    ! search key is less than the true key size or the search is for the first
    ! record with an alternate key either greater-than-or-equal or greater-than
    ! that of the search key, then save the search key presently located in
    ! keybuffer 2 in keybuffer 5. It is necessary to save the search key because
    ! if the SIDR positioned to is exhausted without locating a non-deleted
    ! primary data record, it will be necessary to continue the search with the
    ! next SIDR matching the search characteristics, and the search key will be
    ! required in order to continue this search. In addition, it will be 
    ! necessary each time RMS positions to a new SIDR to extract its key into
    ! keybuffer 2, since the key of the SIDR RMS has currently positioned to 
    ! might not be the same as the keys of SIDRs RMS has previously positioned 
    ! to during the course of its search for a non-deleted primary data record.
    !
    IF  .IRAB[IRB$V_SRCHGE]
	 OR
	.IRAB[IRB$V_SRCHGT]
	 OR
	.IRAB[IRB$B_KEYSZ] LSSU .IDX_DFN[IDX$B_KEYSZ]
    THEN
	BEGIN
	FLAGS[NEW_KEY] = 1;
	CH$MOVE (.IRAB[IRB$B_KEYSZ], KEYBUF_ADDR(2), KEYBUF_ADDR(5));
	END

    ! Regardless of how many SIDRs RMS will position to in its quest for a 
    ! non-deleted primary data record, their key value will always be the
    ! same as the key in keybuffer 2 (once keybuffer 2 has a key if it doesn't
    ! already), and there will not be a need to extract the key out of each
    ! SIDR positioned to.
    !
    ELSE
	FLAGS[NEW_KEY] = 0;

    ! Continue until either the next non-deleleted primary data record is
    ! encountered, the end-of-file is reached, or some error is encountered.
    !
NEXT :
    BEGIN

    WHILE 1
    DO
	BEGIN

	! If RMS is currently positioned to the very first element of a
	! SIDR array, and either this is first such array being scanned
	! during this current positioning or the search characteristics 
	! indicate that the key of each SIDR positioned to must be 
	! extracted, then extract the key of the SIDR into keybuffer 2.
	! 
	IF  (TESTBITSC(FLAGS[FIRST_TIME])
		 OR
		.FLAGS[NEW_KEY])
	     AND
	    (.IRAB[IRB$W_SAVE_POS] EQLU 0)

	THEN
	    BEGIN

	    LOCAL
		TMP_REC_ADDR;

	    TMP_REC_ADDR = .REC_ADDR;
	    REC_ADDR = .BEG_OF_SIDR;

	    REC_ADDR = .REC_ADDR + RM$REC_OVHD(-1);

	    IF .IDX_DFN[IDX$V_KEY_COMPR]
	    THEN
		BEGIN

		GLOBAL REGISTER
		    R_BDB;

		AP = 1;
		RM$RECORD_KEY (KEYBUF_ADDR(2));
		END
	    ELSE
		CH$MOVE (.IDX_DFN[IDX$B_KEYSZ], .REC_ADDR, KEYBUF_ADDR(2));

	    REC_ADDR = .TMP_REC_ADDR;
	    END;

	! Continue searching for the next non-deleted primary data record 
	! until either it is found, an error occurs, the end of the SIDR
	! is encountered, or no SIDR with a key matching the search key
	! according to the search characteristics remains to be scanned for an
	! array element pointing to a non-deleted primary data record.
	!
	WHILE .REC_ADDR LSSA .END_OF_SIDR
	DO
	    BEGIN

	    ! Starting with the current SIDR array element, search for the 
	    ! first element in the SIDR array that is not marked deleted
	    ! until either one is found or the end of the SIDR is encountered.
	    !
	    WHILE ((.REC_ADDR LSSA .END_OF_SIDR)
		    AND
		   .REC_ADDR[IRC$V_DELETED])
	    DO
		BEGIN

		RM$GETNXT_ARRAY();
		IRAB[IRB$W_SAVE_POS] = .IRAB[IRB$W_SAVE_POS] + 1;
		END;

	    ! If RMS has not runoff the end of the current SIDR array it is
	    ! searching, but has successfully positioned to an element in the 
	    ! SIDR array that is not marked deleted, then attempt to access the
	    ! primary data record that it points to, and determine whether or
	    ! not it is marked deleted.
	    !
	    IF .REC_ADDR LSSA .END_OF_SIDR
	    THEN
		BEGIN

		LOCAL
		    RFA_ID,
		    RFA_VBN;

		! Attempt to access the primary data record while holding on to
		! the SIDR bucket lock; waiting for the lock on the primary data
		! bucket to be released if someone else has it while holding 
		! onto the SIDR bucket lock if necessary.
		!
		RM$EXT_ARRY_RFA (RFA_VBN, RFA_ID);

		STATUS = RM$FOLLOW_PTR (.RFA_VBN, .RFA_ID);

		! If RMS has successfully found the next non-deleted primary
		! data record, or some serious error has been encountered,
		! then terminate the search for the next non-deleted primary
		! data record. If the error encountered was just that the 
		! primary data record accessed had been deleted, then RMS will
		! be able to continue the search for the next non-deleted 
		! primary data record with the next element in the SIDR array
		! currently being searched which is not marked deleted.
		!
		IF .STATUS<0,16> NEQU RMSERR(DEL)
		THEN
		    LEAVE NEXT;

		! If the primary data record positioned to is deleted, but the
		! SIDR array element is not marked as such, then alleviate this
		! discrepency provided the user has accessed the file for
		! writing, before continuing on with the search for the next 
		! non-deleted primary data record. If the current SIDR array
		! element is marked RU_DELETE, and RMS is to RU_DELETE it, then
		! in this case there is no need to do anything.
		!
		IF .IFAB[IFB$V_WRTACC]
		    AND
		   NOT  (.REC_ADDR[IRC$V_RU_DELETE]
			 AND
			.IRAB[IRB$V_RU_DELETE])
		THEN
		    BEGIN

		    GLOBAL REGISTER
			COMMON_IO_STR;

		    LOCAL
			SAVE_REC_ADDR;

		    ! Retrieve the address of the SIDR bucket and mark it dirty.
		    !
		    BDB = .IRAB[IRB$L_CURBDB];
		    BDB[BDB$V_DRT] = 1;
		    BKT_ADDR = .BDB[BDB$L_ADDR];

		    ! Save the address of the current SIDR array element before
		    ! attempting to delete any space.
		    !
		    SAVE_REC_ADDR = .REC_ADDR;
		    REC_ADDR[IRC$V_RU_DELETE] = 0;

		    ! If RMS is able to only delete the space occupied by the
		    ! current SIDR array element's RRV pointer, then RMS may
		    ! continue its search for a non-deleted primary data record
		    ! within the current SIDR array after re-determining the 
		    ! address of the end of the current SIDR array.
		    !
		    IF RM$SQUISH_SIDR (1, .BEG_OF_SIDR)
		    THEN
			IF .REC_ADDR EQLU .SAVE_REC_ADDR
			THEN
			    BEGIN
			    REC_ADDR    = .BEG_OF_SIDR;
			    END_OF_SIDR = RM$SIDR_END();
			    REC_ADDR    = .SAVE_REC_ADDR;
			    END

			! If RMS is able to delete the entire current SIDR 
			! because all the elements contained within it have
			! been deleted, then leave the loop responsible for
			! searching the current SIDR so that conditions might
			! be set up to attempt to search the next SIDR array
			! in the alternate index.
			!
			ELSE
			    EXITLOOP

		    ! If RMS is able to only mark the current SIDR array as
		    ! deleted without recovering any space then make sure the
		    ! state bit IRB$V_RU_DELETE is clear (if it was set) and
		    ! continue the search for a non-deleted primary data record
		    ! with the next SIDR array element.
		    !
		    ELSE
			BEGIN
			IRAB[IRB$V_RU_DELETE] = 0;
			RM$GETNXT_ARRAY();
			IRAB[IRB$W_SAVE_POS] = .IRAB[IRB$W_SAVE_POS] + 1;
			END;
		    END

		! If the file has not been opened for write access or there are
		! really no changes that need to be made then the SIDR element 
		! can not be marked deleted, and RMS must immediately position 
		! to the next SIDR array element. This is because having 
		! unexpectantly encountered a deleted primary data record RMS 
		! will want to continue its search for the next non-deleted 
		! SIDR element. Since RMS always starts such a search with the 
		! current element, and since RMS was unable to mark the current 
		! SIDR array element deleted, RMS would end up positioning to 
		! the current element as if it was the next element. 
		! Immediately positioning to the next element prevents this.
		!
		ELSE
		    BEGIN
		    RM$GETNXT_ARRAY();
		    IRAB[IRB$W_SAVE_POS] = .IRAB[IRB$W_SAVE_POS] + 1;
		    IRAB[IRB$V_RU_DELETE] = 0;
		    END;
		END;

	    END;

	! Having exhausted this current SIDR array in the search for the next
	! non-deleted primary data record, RMS positions to the next SIDR 
	! in order to continue the search. NOTE that if the search 
	! characteristics require the original search key, it is restored to
	! keybuffer 2 from keybuffer 5 before initiating the search. This
	! will always be the case when the key of the next SIDR RMS positions 
	! to maybe different from the key of the current SIDR.
	!
	IF .FLAGS[NEW_KEY]
	THEN
	    CH$MOVE (.IRAB[IRB$B_KEYSZ], KEYBUF_ADDR(5), KEYBUF_ADDR(2));

	IRAB[IRB$V_NORLS_RNF] = 1;
	RETURN_ON_ERROR (RM$CSEARCH_TREE(), IRAB[IRB$V_PRM] = 0);

	! Reset all the fields necessary to search a SIDR array starting
	! from its first element.
	!
	BEG_OF_SIDR = .REC_ADDR;
	END_OF_SIDR = RM$SIDR_END();

	REC_ADDR = RM$SIDR_FIRST(0);
	IRAB[IRB$W_SAVE_POS] = 0;
	END;


    END;				! {of NEXT}

    ! If some serious error was encountered in RMS's search for the next
    ! non-deleted primary data record such that the search could no longer
    ! be continued, then RMS releases any bucket locks the process has 
    ! outstanding (primary or SIDR but not both), and returns the error. 
    ! 
    ! There is one error case which is handled differently. A record not found 
    ! error on a search for a primary data record is a serious error. To signal 
    ! to a caller of this routine that in this particular case this routine 
    ! should never be recalled, RMS returns an invalid internal condition or 
    ! bug error after storing the RNF status in the RAB's RAB$L_STV field.
    !
    IF NOT .STATUS
    THEN
	BEGIN

	GLOBAL REGISTER
	    COMMON_IO_STR;

	IF .IRAB[IRB$L_CURBDB] NEQU 0
	THEN
	    RELEASE (IRAB[IRB$L_CURBDB]);

	IF .STATUS<0,16> EQLU RMSERR(RNF)
	THEN
	    BEGIN
	    RAB[RAB$L_STV] = .STATUS;
	    STATUS = RMSERR(BUG);
	    END;

	IRAB[IRB$V_PRM] = 0;
	RETURN .STATUS;
	END

    ! If RMS has been successful in positioning to the next non-deleted
    ! primary data record, then save all information necessary to position
    ! to this SIDR array element as if it was the current element (because it 
    ! soon will be), release the SIDR bucket, and return success.
    !
    ELSE
	BEGIN

	GLOBAL REGISTER
	    COMMON_IO_STR;

	LOCAL
	    SAVE_REC_ADDR;

	BDB = .IRAB[IRB$L_NXTBDB];
	IRAB[IRB$L_NXTBDB] = 0;

	IRAB[IRB$L_RFA_VBN] = .BDB[BDB$L_VBN];

	SAVE_REC_ADDR = .REC_ADDR;
	REC_ADDR = .BEG_OF_SIDR;
	RM$SIDR_FIRST (1; IRAB[IRB$L_FIRST_VBN], IRAB[IRB$W_FIRST_ID]);
	REC_ADDR = .SAVE_REC_ADDR;


	IF .IRAB[IRB$V_PRM]
	THEN
	    BDB[BDB$V_PRM] = 1;

	RM$RLSBKT(0);
	IRAB[IRB$V_PRM] = 0;

	RETURN RMSSUC();
	END;

    END;				! {of the routine RM$SEARCH_SIDR}

END

ELUDOM
