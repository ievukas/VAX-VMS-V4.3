MODULE COPYMAIN (IDENT = 'V04-000',
		MAIN = COPY$COPY
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  COPY
!
! ABSTRACT:
!
!	This utility program creates a copy of one or more user-specified
!	files.  Two or more files may optionally be concatenated to 
!	create a single output file.
!
! ENVIRONMENT:  
!
! AUTHOR:  Ward Clark,	CREATION DATE:  19 August 1977
!
! Modified by:
!
!	V03-014 TSK0015		Tamar Krichevsky	  26-Jul-1984
!		Use the constant 32 for the multi-block count, instead of
!		the system multi-block count.
!
!	V03-013 TSK0014		Tamar Krichevsky	  9-jun-1984
!		Avoid an access violation by have BYPASS_CONCAT return a value.
!		If this value is true, then stop processing.  If it is false,
!		then continue copying files.
!
!	V03-012 TSK0013		Tamar Krichevsky	  8-May-1984
!		Rearrange the calls to CLI$GET_VALUE and LIB$FIND_FILE so that
!		a command such as COPY a.a,a.a,a.a,a.a NL: will copy every file,
!		instead of every other file.
!
!	V03-011 TSK0012		Tamar Krichevsky	 25-Apr-1984
!		Add a check, after trying to open the output file, to be
!		sure that if the current operation is an APPEND and the output 
!		file was not found, then processing should stop.  No use 
!		appending to a non-existant file.
!
!	V03-010 TSK0011		Tamar Krichevsky	 17-Mar-1984
!		Add a missing ".", so that the correct files are opened when
!		the input file has a wildcard in it's specification.  Copy the
!		resultant file file name from LIB$FIND_FILE into the input
!		file's NAM block and IN_NAME_DESC.  Otherwise, the confirm
!		prompt, log messages and error reporting would use the wrong
!		information.
!
!	V03-009 TSK0010		Tamar Krichevsky	 27-Feb-1984
!		Replace COPY's scheme for allocating I/O buffer pool (The I/O
!		buffer pool is area in which COPY maintains its user buffers
!		for RMS calls.)  The old scheme allocated virtual memory for
!		the I/O buffer pool based on the processes working set size.
!		The new scheme alloates enough virtual memory to hold the
!		largest record or block transfer instead.
!
!		Convert input file parse and searching to LIB$FIND_FILE.
!
!	V03-008 TSK0009		Tamar Krichevsky	 15-Feb-1984
!		Fix RMS_SETUP so that the incompatible attributes message is
!		not issued when the input or the output device is network.
!
!	V03-007 TSK0008		Tamar Krichevsky	 3-Oct-1983
!		Fix RMS_SETUP so that the incompatible attributes message is
!		not issued when the input device is a unit record device.
!		The input and output devices have to be the same kind of devices
!		and be file structured before the information in the file header
!		can be compared.
!
!	V03-006 TSK0007		Tamar Krichevsky	 6-Sep-1983
!		Fix an Access violation introduced in V30-005.  This time 
!		wild card copy operations didn't work.
!
!	V03-005 TSK0006		Tamar Krichevsky	 1-Sep-1983
!		Fix access violation introduced in V30-004.  Append operations
!		didn't work.
!
!	V03-004 TSK0005		Tamar Krichevsky	29-Aug-1983
!		Modify how the output file's XAB chain is reinitialized at the
!		end of COPY$COPY.  This change has been made so that COPY 
!		adheres to the new philosophy about the propogation of 
!		file protection and revision dates.
!
!	V03-003 TSK0004		Tamar Krichevsky	23-Jan-1983
!		Replace the command language interface with the the new CLI.
!
!		Add COPY$CHECK_FILE_FOR_MATCH routine which calls LIB$QUAL_FILE_MATCH
!		to see if the input file should be copuied to the output file.
!
!	V03-003 TSK0003		Tamar Krichevsky	29-Mar-1982
!		Allow /NOTRUNCATE to work for non-contiguous sequential files
!		by correcting the IF statement in COPY$CALC_ALQ which decides 
!		if the output file will be truncated or the same size as
!		the input file.  Previously, non-contiguous sequential files
!		were always being truncated, even if /NOTRUNCATE was specified.
!		Now, if /NOTRUNCATE is given, the allocation of the input file
!		is used for the output file.
!		
!
!	V03-002 TSK0002		Tamar Krichevsky	22-Mar-1982
!		Correct logic in IF statement which forces record mode I/O
!		in RMS_SETUP.  Record mode copies to a foreign disk were being
!		attempted instead of block mode.
!
!	V03-001 TSK0001		Tamar Krichevsky	16-Mar-1982
!		Force record mode operations if input and output devices are 
!		both magtape and one is ANSI while the other is mounted 
!		foreign.
!
!	V021	WMC032		Wayne Cardoza	22-Dec-1981
!		Don't allow copy of a directory as a file.
!		Let the [] be displayed in mag tape log messages.
!
!	V020	WMC026		Wayne Cardoza	10-Dec-1981
!		Fix incorrect ordering of PARSE.
!		Fix log messages for network devices.
!
!	V019	WMC003		Wayne Cardoza	17-Nov-1981
!		Quit when operator aborts a mount request.
!
!	V018	WMC002		Wayne Cardoza	02-Nov-1981
!		Don't try to create directories on record devices.
!		Make sure directory created in correct directory.
!		Don't print directory name for non-directory devices.
!
!	V017	TMH0017		Tim Halvorsen	06-Sep-1981
!		Do not issue "N files created" if the number of files
!		created is only one.
!
!	X0016	KRM0007		Karl Malik	11-Feb-1981
!		Modified COPY$COPY to not attempt to create a directory
!		when the output is a network device. Instead, issue a
!		MSG$_NOTCREDIR (new) warning message and continue.
!
!	X0015	KRM0005		Karl Malik	14-Jan-1981
!		Init the block_count and record_count in CREATE_DIR so as
!		not to use the previous value. Also, modified REPORT_NAMES
!		to issue a "created" message when a subdirectory is created
!		(rather than a "copied" message).
!
!	X0014	LMK0001		Len Kawell	27-Mar-1980
!		Correct computation of USZ and MBC for record mode.
!
!	X0013	TMH0012		Tim Halvorsen	31-Jan-1980
!		Do not use LRL as the USZ for record mode I/O as the LRL
!		can sometimes be incorrect when appending files together
!		with differing LRL's.  COPY should be fixed sometime in
!		the future to make the LRL on a concatenated file correct.
!
!	X0012	JAK0012		J. Krycka	07-Dec-1979
!		Set ASY bit in ROP after $CONNECT when doing block I/O to
!		avoid having to issue a $WAIT after the connect. This is
!		necessary for network block I/O because a network $CONNECT
!		actually causes DAP messages to be exchanged and thus does not
!		complete immediately.
!
!	X00011	TMH0011		T. Halvorsen	19-Dec-1979
!		Do not create a directory on the output side for magtapes.
!
!	X00010	TMH0010		T. Halvorsen	17-Nov-1979
!		Add GLOBAL ROUTINE msg_number from its own module to
!		this module to avoid conflict with require file of the
!		same name in the update procedure.
!		It had one modification:
!				T. Halvorsen	15-Nov-1979
!		Do not add in COPY/APPEND facility unless high-order
!		word is non-zero.
!
!	X00009	TMH0009		T. Halvorsen	24-Oct-1979
!		If input file is a directory file, then either create
!		a directory on the output side or do nothing depending
!		on whether the directory already exists or not.
!
!	X00008	T. Halvorsen	16-Aug-1979
!		Move fixed_overhead to here from COPY.REQ and increase
!		it by another 10 to avoid copy from magtape wsl problems
!
!	X00007	T. Halvorsen	30-Jul-1979
!		Make RMS_SETUP fill the UBF/USZ fields for all device types
!		due to a change in RMS which causes move mode to always be
!		used (locate mode had some timing windows).
!
!	X00006	T. Halvorsen	21-Jul-1979
!		Remove 60 second timeout from input RAB
!
!	X00005	T. Halvorsen	14-Jul-1979
!		Detect insufficient working set size to avoid "internal logic
!		error" message when allocating negative amount of storage.
!
!	X00004	JAK0004		J. Krycka	16-Mar-1978	15:00
!		To support file append over the network, omit 'incompatible
!		attributes' check if NET bit is set.
!
!	X00003	JAK0003		J. Krycka	16-Mar-1978	14:30
!		To support copy of files in VFC format over the network,
!		put RHB address in both input and output RABs if NET bit is set.
!
!
! 01	18-04-78	C. Peters	Change INCLUDE file declarations to suit VMS native compiles.
!					Remove SHR$_HASHCONCAT, SHR$_INCOMPAT literals.
! 02	18-04-78	C. Peters	Change COPY to reflect modified behavior.
!	Include COPY.REQ. Delete LITERAL definitions for general use, status flags. Delete
!		macro definitions for commonly used status flags.
!	Rename COPY_STATUS to COPY$CLI_STATUS.
!	Don't include RMSMAC.L32, STARDE.L32. Include STARLET.L32 from SYS$LIBRARY.
!		Delete external literal declarations of RMS status codes. They are in STARLET.L32 too.
!	Delete GLOBAL variable COPY$CLI_STATUS. Put it in a new module, COPYGBL.B32.
!	Instead of calling GET_OUTFILE, call COPY$GET_OUTFIL, in COPYSPECS.
!	Delete GET_OUTFILE.
!	Instead of calling GET_INFILE, call COPY$GET_INFILE, in COPYSPECS.B32.
!	Delete GET_INFILE from this module.
!	Instead of calling OPEN_INFILE, call COPY$OPN_INFILE, in COPYSPECS.
!	Delete OPEN_INFILE.
!	Rename IN_OPEN_ERROR to COPY$INOPN_ERR; OUT_OPEN_ERROR to COPY$OUTOPN_ERR;
!		CLOSE_OUTFILE to COPY$CLOSE_OUTF.
!	Instead of calling OPEN_OUTFILE, call COPY$OPN_OUTFIL, in COPYSPECS.
!	Rename OUT_CLOSE_ERROR to COPY$OCLOSE_ERR.
!	Remove declaration for STS$K_INFO. Put this in COPY.REQ.
!	Remove declaration for VMSMAC.L32, put it in COPY.REQ.
!	Delete routine OPEN_OUTFILE. This routine is replaced by COPY$OPN_OUTFIL, in COPYSPECS.
!	Rename CALCULATE_ALQ to COPY$CALC_ALQ and make it a global routine.
!	Rename MESSAGE_NUMBER to COPY$MSG_NUMBER and make it a global routine.
!	Rename CLI_RESULT to COPY$CLI_RESULT. Declare it a global in COPYGBL.
!	In main routine, close output file is flag MULTIPLE_OUTPUT is set, instead of testing
!		for the CONCAT_FOLLOWS flag being not set.
!	Move setting of CONCAT_QUAL and NOCONCAT_QUAL into the routine GET_CMD_QUAL.
!	Move OUTFILE_OPEN and APPEND_COMMAND bits into COPY$SEM_STATUS from COPY$CLI_STATUS.
!	Remove RMS declarations for input file descriptions to file called FILINPUT.B32.
!	Remove RMS declarations for output file descriptions to file called FILOUTPUT.B32.
!	Rename PARSE_INFILE to COPY$PARS_INFIL.
!	Move PUT_MESSAGE and PUT_MESSAGEX macro definitions to include file COPYMSG.REQ.
!	Move routine COPY$MSG_NUMBER to new module, COPYMSG.B32.
!	In CALC_ALQ, if /TRUNCATE was specified without /ALLOCATION, calculate allocation
!		value based on actual EOF of input file.
!	Add a global variable COPY$B_INCOMPAT. If this variable is set, don't output
!		incompatible attributes message because it has already been output once
!		for this output file.
!	In RMS_SETUP, when setting the MBC and MBF fields for a record mode copy,
!		set the MBC field to the size of the input file only the size is less than or
!		equal to 127 blocks. Otherwise, MBC goes negative.
!	In RMS_SETUP, a record mode copy from disk or tape loads RAB$W_USZ from XAB$W_LRL if
!		non-zero; otherwise, FAB$W_BLS.
!
!--

!++
! DETAILED FUNCTIONAL DESCRIPTION:
!
!	This utility program creates a copy of one or more user-specified
!	files.  These files can be explicitly named or can be referred to
!	through use of RMS wildcard file naming.  Two or more files may
!	optionally be concatenated to create a single output file.
!
!	All file I/O is done using standard RMS facilities.  Therefore,
!	the input and output files can exist on any device supported by RMS,
!	including devices at remote network nodes.  If possible, file copying
!	is done using block I/O.  Record I/O is used only when an input or
!	output file is record oriented (e.g., terminal, unit record) or when
!	a concatenated file is being copied.
!
!	This utility is intended to interface directly with a Command Language
!	Interpreter (CLI) and cannot be directly invoked from Command Language
!	level or from an executing program.  Numerous command options
!	(i.e., qualifiers) are supported to allow the Command Language user
!	to (1) optionally specify the location and attributes of the input
!	and output files, and (2) control the reporting of each file copy.
!
!	If more than one copy operation is specified in a single COPY request,
!	each file copy is performed independent of the others.  Therefore,
!	the failure of one file copy operation (e.g., I/O error, input
!	file not found) does not affect the remaining copy requests.  The
!	single exception to this rule is that unprocessed concatenated input
!	files are bypassed in the event of a file copy failure.
!
!--

!	NOTE:  This module contains some temporary code that (1) circumvents
!	a system problem or (2) cannot be implemented until an expected
!	system function is available.  In some cases, codes have been added;
!	in other cases, code has been "commented out".  In either case, each
!	statement affected includes a comment of the form "!#n", where "n" is
!	a number from the following table:
!
!		#1 - symbol not currently defined in STARLET.L32
!		#2 - I/O buffers cannot be locked in working set - known restriction
!		#3 - MODIFY does not accept FHC XAB - future feature

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    COPY$COPY,						! Main COPY control routine
    COPY$CHECK_FILE_FOR_MATCH,				! Sees if input file matches command line criteria
    CREATE_DIR, 					! Create directory file
    RMS_SETUP,						! RAB/buffer initialization
    COPY_FILE,						! Copies an input file to the output file
    CLOSE_INFILE :  NOVALUE,				! Closes the current input file
    COPY$CLOSE_OUTF :  NOVALUE,				! Closes the current output file
    BYPASS_CONCAT,					! Bypass concatenated input files after an error
    COPY$FIND_INPUT_FILE,				! Parse an input file-specification
    COPY$CALC_ALQ,					! Calculate the output file allocation quantity
    REPORT_NAMES :  NOVALUE,				! Report names of input and output files
    REPORT_BYPASS :  NOVALUE,				! Report name of file bypassed
    COPY$LOG_MSG :  NOVALUE,				! Informational message routine
    COPY$INOPN_ERR :  NOVALUE,				! Input open error routine
    IN_READ_ERROR :  NOVALUE,				! Input read error routine
    IN_CLOSE_ERROR :  NOVALUE,				! Input close error routine
    COPY$OUTOPN_ERR :  NOVALUE,				! Output open error routine
    OUT_WRITE_ERROR :  NOVALUE,				! Output write error routine
    COPY$OCLOSE_ERR :  NOVALUE,				! Output close error routine
    COPY$MSG_NUMBER;					! Compute message number

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:STARLET.L32';			! VAX/VMS common definitions
REQUIRE 'SRC$:COPYMSG.REQ';				! Definition of macros to SIGNAL a message

!
! MACROS:
!

MACRO
    IN_NEQ_OUT[] =					! Compare input and output FHC XAB field
	.INFILE_XABFHC[%REMAINING] NEQ .OUTFILE_XABFHC[%REMAINING] %,

    NAM$B_DVILNG = $DEFINE_BYTE[NAM$T_DVI] %,

    $DEFINE_BYTE( D, B, S, X ) = D, B, 8, 0 %,

    !
    ! Check to see if the global or local qualifier flag is set without the 
    ! local negation flag being set.
    !
    qualifier_active( global_qual, local_qual, locally_negated ) =
    	(IF (.global_qual AND NOT .locally_negated) OR .local_qual
    	 THEN true
    	 ELSE false )%
    ;


!
! EQUATED SYMBOLS:
!

LITERAL
    CLI_STATUS_LEN = 28,				! Length of COPY$CLI_STATUS block
    SEM_STATUS_LEN =  4					! Length of COPY$SEM_STATUS block
    ;
!    RME$K_OVERLAY = 0;					!#1 ***** KLUDGE *****

!
! Global variables
!

GLOBAL
    OUTFILE_COUNT :  INITIAL (0),			! Number of output files created

    BLOCK_COUNT,					! Number of input blocks copied (current file)

    RECORD_COUNT,					! Number of input records copied (current file)

    MOST_SEVERE_ERR :  BLOCK[4,BYTE]			! Most severe error encountered
			INITIAL( SS$_NORMAL ),		!

    IO_BUFFER_BASE : INITIAL(0),			! Address of I/O buffer pool

    RMS_MBC : INITIAL(32),				! Size of the RMS buffers

    BLOCK_SIZE,						! Input file block size

    COPY$CLI_STATUS : $BBLOCK[ CLI_STATUS_LEN ] 	! Results of the command line parse
    		      INITIAL(0),
    COPY$SEM_STATUS : $BBLOCK[ SEM_STATUS_LEN ]		! Status of the input and output files
    		      INITIAL(0),
    COPY$B_INCOMPAT : BYTE INITIAL(0)			! Flag which is set if files have incoompatible attrib's
    ;			

!
! YET ANOTHER REQUIRE FILE
!
REQUIRE
    'SRC$:COPY.REQ';					! Field definitions for COPY$CLI_STATUS and COPY$SEM_STATUS

!
! EXTERNAL REFERENCES:
!
EXTERNAL

    !
    ! Command line qualifier values
    !
    common_qual_context,				! Common qualifier data area
    curr_allocation_value,				! The allocation for the output file
    curr_protection_or,					! Protection mask for /PROTECTION qualifier
    curr_protection_and,				! Protection mask for /PROTECTION qualifier

    !
    ! RMS definitions
    !
    infile_fab		: BLOCK [, BYTE],		! Input file FAB block
    infile_rab		: BLOCK [, BYTE],		! Input file RAB block
    infile_name		: VECTOR [, BYTE],		! Input file name after $OPEN
    infile_xname	: VECTOR [, BYTE],		! Input file name before $OPEN
    infile_nam_blk	: BLOCK [, BYTE],		! Primary input NAM block
    infile_xabfhc	: BLOCK [, BYTE],		! File header characteristics XAB block
    infile_xaball	: BLOCK [, BYTE],		! File allocation XAB block
    infile_cli_desc	: $BBLOCK,			! Input file name on command line
    in_name_desc	: VECTOR,			! Input file name descriptor
    outfile_fab		: BLOCK [, BYTE],		! Output file FAB block
    outfile_rab		: BLOCK [, BYTE],		! Output file RAB block
    outfile_name	: VECTOR [, BYTE],		! Output file name after $OPEN
    outfile_xname	: VECTOR [, BYTE],		! Output file name before $OPEN
    outfile_nam_blk	: BLOCK [, BYTE],		! Output file NAM block
    outfile_xabrdt	: BLOCK [, BYTE],		! Output file revision date/time XAB block
    outfile_xabpro	: BLOCK [, BYTE],		! Output file protection XAB block
    outfile_xabdat	: BLOCK [, BYTE],		! Output file date XAB block
    outfile_xaball	: BLOCK [, BYTE],		! Output file allocation XAB block
    outfile_xabfhc	: BLOCK [, BYTE],		! Output file file header characteristics XAB block
    out_name_desc	: VECTOR;			! Output file name descriptor

EXTERNAL LITERAL
    LIB$_FILFAIMAT,					! File failed to match command line criteria
    LIB$_QUIPRO						! User requested that processing cease
    ;

EXTERNAL ROUTINE
    COPY$GET_INFILE,					! Gets the name of the input file
    COPY$GET_OUTFIL,					! Gets the name of the output file
    COPY$OPN_INFILE,					! Opens the input file
    COPY$OPN_OUTFIL,					! Opens an output file
    CLI$GET_VALUE : ADDRESSING_MODE(GENERAL),		! Get a value from the command line
    LIB$FIND_FILE : ADDRESSING_MODE(GENERAL),		! Find a file which fits the given filespec
    LIB$GET_VM :  ADDRESSING_MODE(GENERAL),		! Virtual memory allocation
    LIB$QUAL_FILE_MATCH : ADDRESSING_MODE(GENERAL),	! Match a given file to the command line criteria
    LIB$CHECK_DIR :  ADDRESSING_MODE(GENERAL),		! Determine if file is a directory
    LIB$CREATE_DIR :  ADDRESSING_MODE(GENERAL);		! Create a directory file

ROUTINE COPY$COPY =					! Primary COPY control routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the primary control routine for the COPY utility.
!	It determines the basic logical flow and calls support routines
!	which perform each logical function.
!
! FORMAL PARAMETERS:
!
!	AP.rlu.va - Argument list passed from the Command Language Interpreter
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! COMPLETION CODES:
!
!	Most severe error encountered during processing or SS$_NORMAL
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;						! Declare the name of the argument pointer.

    BIND
	ARGUMENT_LIST = AP :  REF BLOCK[,BYTE];		! Declare the form of the argument list.

    LOCAL
	ptr,						! Temporary variables for character searching
	address,
	size,
	STATUS;						! General routine return code





!
! Get the output file-specification and all qualifiers from the CLI.
!

    IF NOT COPY$GET_OUTFIL (				! Get the output file spec from the CLI.
                            OUTFILE_FAB,		!    Specify the output FAB block address,
                            OUTFILE_NAM_BLK,		!    the output NAM block address,
                            OUTFILE_XABFHC)		!    and the output XABFHC block address.
    THEN
        RETURN .MOST_SEVERE_ERR;			!    On error, return to CLI.

!
! The remainder of this routine is executed for each input
! file-specification supplied by the user.  Get the first input file.
!

    IF NOT (status = CLI$GET_VALUE( $DESCRIPTOR('INFILE'), infile_cli_desc))
    THEN 
    	RETURN .status;

    WHILE 1 DO						! Beginning of repeat loop
	BEGIN

!
! Get the next input file-specification from the CLI.  This routine call is a
! NOP if a wildcard file-specification is currently being processed;
! that is, a wildcard specification is repeatedly used until no furthur
! match is found.
!

	STATUS = COPY$GET_INFILE (			! Get an input file-specification.
                                    INFILE_FAB,		!    Specify the address of the input FAB block,
                                    INFILE_NAM_BLK,	!    the address of the input NAM block,
                                    INFILE_XABALL);	!    and the address of the input XABALL block.

	IF .STATUS EQL NO_MORE_FILES			! If there are no more input file-specs,
	THEN						!
	    EXITLOOP;					! exit the input file-spec processing loop.

	IF .STATUS EQL OK				! If everything is OK so far,
	THEN						!
	    BEGIN					! begin normal input file processing.

!
! Open the current input file.
!

	    STATUS = COPY$OPN_INFILE (INFILE_FAB);	! Open the current input file.

!
! If the input file is a directory file, then create the directory file
! on the output side if the file does not already exist.  If the output
! directory already exists, then do nothing.
!

            IF .status EQL ok			! If input opened ok,
		AND lib$check_dir (infile_fab)	! and file is a directory,
		AND NOT .outfile_fab [$FAB_DEV(sdi)] ! and not magtape output,
	    THEN
		IF NOT .outfile_fab[$FAB_DEV(net)]
		    AND NOT .outfile_fab [$FAB_DEV(rec)] ! and not record device,
		THEN
			BEGIN
			IF (.outfile_nam_blk[nam$v_exp_name] AND
				(NOT .outfile_nam_blk[nam$v_wild_name])) OR
			    (.outfile_nam_blk[nam$v_exp_type] AND
				(NOT .outfile_nam_blk[nam$v_wild_type])) OR
			    (.outfile_nam_blk[nam$v_exp_ver] AND
			        (NOT .outfile_nam_blk[nam$v_wild_ver]))
			THEN
			    BEGIN
			    report_bypass(msg$_illdircopy);
			    close_infile();			! Close input file
			    END
			ELSE
			    BEGIN
			    status = create_dir (infile_fab, outfile_fab);
			    IF .status EQL ss$_created	! If file actually created,
			    THEN
				BEGIN
				report_names();		! Report file copied
				outfile_count = .outfile_count + 1;
				END;
			    IF NOT .status			! If successful,
			    THEN
				report_bypass(msg$_notcopied); ! Else report failure
			    close_infile();			! Close input file
			    END
			END
		ELSE
			BEGIN
			report_bypass(msg$_dirnotcre);	! Else report failure
			close_infile();			! Close input file
			END
	    ELSE
	    BEGIN
		

!
! Create (or simply open) the output file (if it is not already open due to
! input file concatenation) and then copy the entire input file to the
! output file.
!

	    IF .STATUS EQL OK				! If the input file was successfully opened,
	    THEN					!
		BEGIN					!
		IF (STATUS = COPY$OPN_OUTFIL (		! create or open the output file unless it is
                                                OUTFILE_FAB,
                                                OUTFILE_RAB,
                                                INFILE_FAB,
                                                OUTFILE_COUNT))
							! already open due to input concatenation.
		THEN
    		    BEGIN
		    IF (STATUS = RMS_SETUP())		! Setup the input and output RABs and buffers.
		    THEN
			BEGIN
			IF (STATUS = COPY_FILE())	! Copy the entire input file to the output file.
			THEN
			    BEGIN
		    	    IF .outfile_fab [$FAB_DEV(rec)] 
				AND NOT .outfile_fab [$FAB_DEV(net)] 
			    THEN
				BEGIN
				size = .out_name_desc[0];
				address = .out_name_desc[1];
				ptr = CH$FIND_CH(.size,.address,':');
				IF .ptr NEQ 0		! If there is anything past the device, remove it
				THEN
				    out_name_desc[0] =  .ptr - .address + 1;
				END;
			    REPORT_NAMES()		! Report the results if the copy was successful.
			    END
			ELSE				! Otherwise, report a partial copy.
			    REPORT_BYPASS( MSG$_NOTCMPLT );
			END
    		    ELSE
    			REPORT_BYPASS( MSG$_NOTCOPIED );
		    END
		ELSE					! If the output file couldn't be opened,
    		    BEGIN
    		    !
    		    ! If this is an APPEND operation, then stop processing. 
    		    ! There is no need to continue appending to a non-existant 
    		    ! file.
    		    !
    		    IF .append_command
    		    THEN EXITLOOP;

		    SELECTONE .status OF
    		    SET
			[ LIB$_FILFAIMAT ] : 	! Quietly skip this file
				status = ok;
			[ LIB$_QUIPRO ]    : 	! User wishes to stop at this point
				EXITLOOP;
			[ OTHERWISE ]      : 	! indicate the input file wasn't copied.
				REPORT_BYPASS( MSG$_NOTCOPIED);
		    TES;
    		    END; ! else stmt
		END;

	    CLOSE_INFILE();				! Close the input file.

	    END;					! End of ELSE clause
	    END;					! End of processing a single input file specification.


	! If the user wishes to quit processing, then exit with a successful
	! status.
	!
	IF .status EQL LIB$_QUIPRO
	THEN
	    status = ok;
    	!
    	! Bypass any concatenated input files if an error occurred during the 
    	! file copy.
    	!

	IF NOT .STATUS					! If the input file was not successfully copied,
	THEN						!
	    IF BYPASS_CONCAT()				! bypass any concatenated input files.
    	    THEN
    		EXITLOOP;
!
! Close the output file unless another input file is to be
! concatenated to the output file just written.
!

	IF .MULTIPLE_OUTPUT AND NOT .APPEND_COMMAND	! If multiple output files are being created,
	THEN						!    and the command was not APPEND,
            BEGIN
	    !
	    ! Set up protection if user specified explicitly.
	    !

	    IF qualifier_active( protect_qual, loc_protect_qual, neg_protect_qual )
	    THEN  
		BEGIN
		outfile_xabpro [xab$w_pro] = .outfile_xabpro[ xab$w_pro] AND
					    .curr_protection_and;
		outfile_xabpro [xab$w_pro] = .outfile_xabpro[ xab$w_pro] OR
    					    .curr_protection_or;
		END
	    ELSE
	        outfile_xabrdt [xab$l_nxt] = 0;

	    !
	    ! Close the current output file.
	    !

	    COPY$CLOSE_OUTF();				! close the current output file, if any.

	    !
	    ! Reinitialize the XAB chain, since it may have been mucked with
	    ! by COPY$OPN_OUTFIL among other routines.
	    !

	    outfile_xaball [xab$l_nxt] = outfile_xabdat;
	    outfile_xabdat [xab$l_nxt] = outfile_xabrdt;
	    outfile_xabrdt [xab$l_nxt] = outfile_xabpro;
            END;

	END;						! End of "WHILE 1 DO" input file-spec processing loop.

!
! Perform any necessary cleanup before exiting.
!

    !
    ! Set up protection if user specified explicitly.
    !

    IF qualifier_active( protect_qual, loc_protect_qual, neg_protect_qual )
    THEN  
	BEGIN
	outfile_xabpro [xab$w_pro] = .outfile_xabpro[ xab$w_pro] AND
				     .curr_protection_and;
	outfile_xabpro [xab$w_pro] = .outfile_xabpro[ xab$w_pro] OR
    				     .curr_protection_or;
	END
    ELSE
	outfile_xabrdt [xab$l_nxt] = 0;

    COPY$CLOSE_OUTF();					! close the current output file, if any.

    COPY$LOG_MSG( MSG$_NEWFILES );			! Report the number of files created.

!
! Return to the caller.
!

    RETURN .MOST_SEVERE_ERR;				! Use the most severe error encountered
							! as the completion code from this routine.

    END;

GLOBAL ROUTINE COPY$CHECK_FILE_FOR_MATCH =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets up the parameters for and calls LIB$QUAL_FILE_MATCH to see if the input
!	file matches the criteria given on the command line.  
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	IN_NAME_DESC	: Input file name descriptor
!	OUT_NAME_DESC	: Output file name descriptor
!	OUTFILE_OPEN	: Output file is currently open
!	COMMON_QUAL_CONTEXT : Common qualifier data area
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	Whatever LIB$QUAL_FILE_MATCH returns.
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

LOCAL
    out_desc	 :			! Temporary desc. for output file name
    		   VECTOR[ 2 ],
    prompt_string_desc,			! Desc. for /CONFIRM prompt string address
    prompt_args  : 			! Argument list for /CONFIRM prompt
    		   VECTOR[ 2 ] 
    ;



! Pick to appropriate propmt string, depending on whether the input file is
! being append to an output file or not.
!
IF .append_command OR  .outfile_open
    THEN prompt_string_desc = $DESCRIPTOR('Append !AS to !AS? [N]')
    ELSE prompt_string_desc = $DESCRIPTOR('Copy !AS to !AS? [N]');


! File in the file name descriptors.
!
prompt_args[ 0 ] = in_name_desc;
prompt_args[ 1 ] = out_desc;

IF .outfile_nam_blk[ NAM$B_RSL ] NEQ 0
THEN
    BEGIN
    out_desc[ 0 ] = .outfile_nam_blk[ NAM$B_RSL ];
    out_desc[ 1 ] = outfile_name;
    END
ELSE
    IF .outfile_nam_blk[ NAM$B_ESL ] NEQ 0
    THEN
	BEGIN
	out_desc[ 0 ] = .outfile_nam_blk[ NAM$B_ESL ];
	out_desc[ 1 ] = outfile_xname;
	END
    ELSE
    	prompt_args[ 1 ] = out_name_desc;


! Compare the current input file to the command line criteria.  Return the
! results of the comparison to the calling routine.
!
RETURN LIB$QUAL_FILE_MATCH( common_qual_context, infile_fab, 0,
    .prompt_string_desc, prompt_args, 0);

END;					! End of routine COPY$CHECK_FILE_FOR_MATCH

ROUTINE CREATE_DIR (input_fab, output_fab) =

!---
!
!	This routine is called to create a directory file on
!	the output side if the directory does not already exist.
!	If the directory already exists, do nothing.
!
! Inputs:
!
!	input_fab = Address of FAB describing opened directory file
!	output_fab = Address of FAB describing the device and directory
!			into which the directory file should be created.
!
! Outputs:
!
!	Routine value = status return
!---

BEGIN

MAP
    input_fab:	REF BLOCK[,BYTE],	! Input FAB
    output_fab:	REF BLOCK[,BYTE];	! Output FAB

BIND
    input_nam = .input_fab [fab$l_nam]: BLOCK[,BYTE],
    output_nam = .output_fab [fab$l_nam]: BLOCK[,BYTE];

LOCAL
    ptr,				! String temporary pointer
    addr,size,				! descriptor of search string
    buffer:	VECTOR [nam$c_maxrss,BYTE], ! file spec buffer
    bufdesc:	VECTOR [2],		! descriptor of above buffer
    terminator:	BYTE,			! Directory spec. terminator
    status;				! status variable

record_count = 0;			! Initialize the record count
block_count  = 0;			! Initialize the block count

status = $RMS_PARSE (FAB = .output_fab); ! Get full name of directory file

size = .output_nam [nam$b_esl];		! Get output expanded name
addr = .output_nam [nam$l_esa];

IF NOT .status
THEN
    BEGIN
    put_messagex(.status);
    RETURN .status;
    END;

ptr = CH$FIND_CH(.size, .addr, ']');	! Find end of directory spec
IF .ptr EQL 0				! If not found,
THEN
    BEGIN
    ptr = CH$FIND_CH(.size, .addr, '>');   ! Alternate syntax
    IF .ptr EQL 0			! If still not found,
    THEN
	put_message(rms$_esa);		! return invalid expanded string
    END;

size = .ptr + 1 - .addr;		! Figure length of device and dir.
CH$MOVE(.size, .addr, buffer);		! Copy device and directory into buffer
terminator = .buffer [.size-1];		! Remember terminator on dir. spec.
buffer [.size-1] = '.';			! and overwrite it with '.'

bufdesc [0] = .size;			! Setup buffer descriptor
bufdesc [1] = buffer;

size = .input_nam [nam$b_rsl];		! Get input result name
addr = .input_nam [nam$l_rsa];

ptr = CH$FIND_CH(.size, .addr, ']');	! Find start of file name on input side
IF .ptr EQL 0				! If not found,
THEN
    BEGIN
    ptr = CH$FIND_CH(.size, .addr, '>'); ! Alternate syntax
    IF .ptr EQL 0			! If still not found
    THEN
	put_message(rms$_esa);		! return invalid expanded string
    END;

size = .size - (.ptr + 1 - .addr);	! Figure descriptor of file name
addr = .ptr + 1;

ptr = CH$FIND_CH(.size, .addr, '.');	! Find where file name ends
IF .ptr EQL 0				! If not found,
THEN
    RETURN rms$_esa;			! return invalid expanded string
size = .ptr - .addr;			! Figure descriptor of file name only

CH$MOVE(.size, .addr, buffer+.bufdesc[0]); ! Append subdirectory name to buffer
buffer [.bufdesc[0]+.size] = .terminator;  ! Tack terminator on end of it
bufdesc [0] = .bufdesc[0] + .size + 1;	! Update string descriptor

out_name_desc [0] = .bufdesc [0];	! Copy length of string
CH$MOVE(.bufdesc[0], .bufdesc[1], .out_name_desc[1]);	! and string too

status = LIB$CREATE_DIR (bufdesc);	! Create directory file with defaults

IF NOT .status				! If error detected,
THEN
    put_messagex(.status);		! then signal status

RETURN .status;				! return with status

END;

ROUTINE RMS_SETUP =					! RMS RAB setup routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs all necessary setup of the input and output file RABs:
!
!		* determine if record-mode is required
!		* allocate I/O buffers
!		* connect the RABs to their respective FABs
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	EXTEND_OUTFILE - Indicates output file is being extended
!	IO_BUFFER_BASE - location of the I/O buffer pool
!	INFILE_FAB - Input file FAB
!	OUTFILE_FAB - Output file FAB
!	INFILE_XABs - Input file XABs
!
! IMPLICIT OUTPUTS:
!
!	INFILE_RAB - Input file RAB completed and connected
!	OUTFILE_RAB - Output file RAB completed and connected
!	IO_BUFFER_BASE - Address of dynamic I/O buffer (1st call only)
!	BLOCK_IO_SIZE - Length of block I/O operations
!
! COMPLETION CODES:
!
!	OK = normal completion
!	ERROR = RAB connect unsuccessful
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	IN_DEVICE :  BLOCK[1,BYTE],			! Selected input and output
	OUT_DEVICE :  BLOCK[1,BYTE],			! device characteristics

	FORCE_REC_MODE,					! Temporary record-mode I/O indicator
	STATUS,						! System service completion code
    	IO_BUFFER_LENGTH : INITIAL(max_io_length*2),	! Size of I/O buffer pool
    	GETSYI_ITEM_LIST : $ITMLST_DECL(ITEMS=1);	! Item list for $GETSYI call

    MACRO						! IN_DEVICE and OUT_DEVICE bit definitions:
	DISK = 0,0,1,0 %,				!    disk device
	TAPE = 0,1,1,0 %;				!    tape device

!
! Allocate a maximum size I/O buffer pool on the 1st call to this routine.
!

    IF .io_buffer_base EQL 0
    THEN
	BEGIN

	!
	! Allocate enough virtual memory for the I/O buffer pool.  It has to
	! be large enough to hold two of the largest possible RMS transfers.  
	! ****** NOTE ****** If COPY is ever made callable, the allocation of 
	! the I/O buffer pool will have to be rewritten to be more efficient.
	!

	IF NOT (status = LIB$GET_VM (io_buffer_length, io_buffer_base))
	THEN
	    PUT_MESSAGE( MSG$_BADLOGIC, 0, .STATUS, 0, 	MSG$_ATPC, 1 );
	END;

!
! Extract some device information from the input and output file FABs.
!

    IN_DEVICE = 0;					! Clear the input and output
    OUT_DEVICE = 0;					! device characteristics.

    IN_DEVICE[DISK] =					! Turn on the input file disk indicator
	.INFILE_FAB[$FAB_DEV(FOD)] AND			! if the input device is file-structured
	NOT .INFILE_FAB[$FAB_DEV(SQD)];			! and it is not a tape device.

    IN_DEVICE[TAPE] =					! Turn on the input file tape indicator
	.INFILE_FAB[$FAB_DEV(SQD)];			! if the input device is a tape.

    OUT_DEVICE[DISK] =					! Turn on the output file disk indicator
	.OUTFILE_FAB[$FAB_DEV(FOD)] AND			! if the output device is file-structured
	NOT .OUTFILE_FAB[$FAB_DEV(SQD)];		! and it is not a tape device.

    OUT_DEVICE[TAPE] =					! Turn on the output file tape indicator
	.OUTFILE_FAB[$FAB_DEV(SQD)];			! if the output device is a tape.

!
! Determine whether the input and output files have compatible attributes. This
! check can only be done if both the input and output devices are the same kind
! and they are file structured. The check should not be done if either the 
! input device or the output device is a network device.
!

    IF .in_device NEQ .out_device
    		OR
       .in_device EQL 0

    THEN
    	force_rec_mode = YES
    ELSE
	IF NOT(.infile_fab[$FAB_DEV(NET)]		! If neither input or output is network then
    		OR
           .outfile_fab[$FAB_DEV(NET)])
    		AND					! Compare the following input and output XAB fields:
    	   (IN_NEQ_OUT(XAB$B_RFO) OR			!    record format and file organization
	    IN_NEQ_OUT(XAB$B_ATR) OR			!    record attributes
	    IN_NEQ_OUT(XAB$B_BKZ) OR			!    bucket size
	    IN_NEQ_OUT(XAB$B_HSZ) OR			!    fixed header size
	    (.OUTFILE_XABFHC[XAB$W_MRZ] NEQ 0 AND	!    maximum output record size (if any)
	     .OUTFILE_XABFHC[XAB$W_MRZ] LSS		!       and longest input record
		    .INFILE_XABFHC[XAB$W_LRL]))		!
	THEN
	    BEGIN					! If the input and output attributes are not identical,
	    IF NOT .COPY$B_INCOMPAT			! and this message has not appeared yet
	    THEN					! for this output file,
		BEGIN
		PUT_MESSAGE( MSG$_INCOMPAT, 2,		! send the user a warning message
			IN_NAME_DESC, OUT_NAME_DESC );	!
		COPY$B_INCOMPAT = TRUE;			! Set flag saying that message is out.
		END;
	    FORCE_REC_MODE = YES;			! and force a record-mode copy.
	    END
	ELSE
	    FORCE_REC_MODE = NO;			! Otherwise, turn the record-mode indicator off.

!
! Initialize the input and output RABs.
!

    $RAB_INIT( RAB = INFILE_RAB,			! Setup the input file RAB as follows:
		RAC = SEQ,				!    Sequential record access
		ROP = <LOC,RAH>,			!    GET locate, read ahead
		FAB = INFILE_FAB);			!    Input file FAB address

    $RAB_INIT( RAB = OUTFILE_RAB,			! Setup the output file RAB as follows:
		RAC = SEQ,				!    Sequential access
		FAB = OUTFILE_FAB,			!    Output file FAB address
		ROP = <TPT,WBH> );			!    Force EOF on every write or put,
							!    and specify write behind for multi-buffering.

!
!
! Determine whether record-mode I/O is required for this file copy operation.
! At least one of the following conditions must be true for record mode
! operations to be performed:
! 	    - the input and output attributes are incompatible,
! 	    - the output file is being extended,
!	    - the input and output devices are not the same type,
!	    - both devices are record mode devices,
!	    - this is a tape-to-tape copy AND
!		the input and output blocksizes are not the same
!    			OR
!		one tape is mounted foreign and the other is ANSI.
!

    IF .FORCE_REC_MODE
	    OR
	.EXTEND_OUTFILE
	    OR
	.IN_DEVICE NEQ .OUT_DEVICE
	    OR
	.IN_DEVICE EQL 0
	    OR
	(
	.INFILE_FAB [$FAB_DEV (SQD)]
	    AND
	(
	    ( .INFILE_FAB [FAB$W_BLS] NEQ .OUTFILE_FAB [FAB$W_BLS] )
    	    OR
	    ( .INFILE_FAB [$FAB_DEV (FOR)] NEQ .OUTFILE_FAB [$FAB_DEV (FOR)] )
	)
	)
!
! Record mode I/O setup.
!

    THEN
	BEGIN

	!
	! Indicate that record mode is required, block i/o will not be used for
	! this file, and that the record operations will be synchronous.
	!
	record_mode = YES;
	infile_rab[RAB$V_BIO]  = NO;
	outfile_rab[RAB$V_BIO] = NO;
	infile_rab[RAB$V_ASY]  = NO;
	outfile_rab[RAB$V_ASY] = NO;

	!
	! Determine the size of the user's buffer which is passed to RMS.
	! If the input device is tape, then the user's buffer must be large
	! enough to contain one complete tape block.  Otherwise, (the input 
	! device is not tape) use either the the maximum record size or the 
	! the longest record length for the size of the user's buffer, if they
    	! are specfied.  If none of the above cases are met, use the longest
	! legal transfer size as the length of the user's buffer.
	!
	IF .in_device[tape]
	THEN
	    infile_rab[RAB$W_USZ] = .infile_fab[FAB$W_BLS]
	ELSE
            IF .infile_xabfhc[XAB$W_MRZ] NEQ 0
            THEN
                infile_rab[RAB$W_USZ] = .infile_xabfhc[XAB$W_MRZ]
            ELSE
		IF .infile_xabfhc[XAB$W_LRL] NEQ 0
		THEN
		    infile_rab[RAB$W_USZ] = .infile_xabfhc[XAB$W_LRL]
		ELSE
		    infile_rab[RAB$W_USZ] = max_io_length;


	!
	! Set up the user's buffer within the I/O buffer pool.  If the record 
	! format of the file is VFC, then allocate areas in the buffer pool 
	! for the fixed header and variable portions of the record.  Otherwise,
	! just use the start of the I/O buffer pool as the start of the user's 
	! buffer.
	!
	IF .infile_fab[FAB$B_RFM] EQL FAB$C_VFC
	THEN
	    BEGIN
	    infile_rab[RAB$L_RHB]  = .io_buffer_base;
	    outfile_rab[RAB$L_RHB] = .infile_rab[RAB$L_RHB];
    	    infile_rab[RAB$L_UBF]  = .io_buffer_base + .infile_xabfhc[XAB$B_HSZ];
	    END
    	ELSE
    	    infile_rab[RAB$L_UBF] = .io_buffer_base;

	!
	! Determine the best multi-block count for copying the input file.  Use
	! that MBC for both the input and output file RABs.
	!
	IF .infile_fab [FAB$W_BLS] GTR .outfile_fab [FAB$W_BLS]
	THEN
	    
	    ! The input device is tape or some other record oriented device.  
	    ! Have RMS allocate enough buffer space to hold a complete block.
	    !
	    infile_rab [RAB$B_MBC] = (.infile_fab [FAB$W_BLS] + 511) / disk_block_size
	ELSE
	    IF .outfile_fab [FAB$W_BLS] NEQ 0
	    THEN

	    	! The output device is record oriented and its block size is 
	    	! larger than the input device's.  Therefore, RMS should 
	    	! allocate enough buffer space to hold a comlete block for the 
		! output device.
	    	!
		infile_rab [RAB$B_MBC] = (.outfile_fab [FAB$W_BLS] + 511) / disk_block_size
	    ELSE

	    	! This is either a disk to disk transfer or something else.  
	    	! Just use the system default.
	    	!
	    	infile_rab [RAB$B_MBC] = .rms_mbc;

	outfile_rab [RAB$B_MBC] = .infile_rab [RAB$B_MBC];

	!
	! Have RMS set up two internal buffers, to speed up processing.
	!
	infile_rab [RAB$B_MBF]  = double_buffer;
	outfile_rab [RAB$B_MBF] = double_buffer;
	END

!
! Block mode I/O setup.
!

    ELSE
	BEGIN

	!
    	! Indicate that record mode is not desired and that block mode will be 
	! used for both input and output, and that reading and writing will be
	! synchronous.  However, ASY will be set after the $CONNECT to avoid
	! haveing to issue a $WAIT on the connect.
	!

	record_mode = NO;
	infile_rab[RAB$V_BIO] = YES;
	outfile_rab[RAB$V_BIO] = YES;
	infile_rab[RAB$V_ASY] = NO;
	outfile_rab[RAB$V_ASY] = NO;

	!
	! Determine the appropriate block size and user buffer size for copying
	! the current input file.
	!
	IF .in_device[tape]
	THEN
	    BEGIN
	    block_size = .infile_fab [FAB$W_BLS];
	    infile_rab[RAB$W_USZ] = .infile_fab[FAB$W_BLS];
	    END
	ELSE
	    BEGIN
	    block_size = disk_block_size;
	    infile_rab[RAB$W_USZ] = .rms_mbc * disk_block_size;
	    END;

	!
	! Set up the user's buffer, which are passed to RMS, within the I/O
	! buffer pool.
	!

	infile_rab[RAB$L_UBF]  = .io_buffer_base;
	outfile_rab[RAB$L_RBF] = .io_buffer_base + .infile_rab[RAB$W_USZ];
	END;

!
! Connect the input and output RABs to their respective FABs.
!

    IF NOT $RMS_CONNECT( RAB = INFILE_RAB,		! Connect the input file RAB to the FAB,
			 ERR = COPY$INOPN_ERR )		! specifying an error action routine.

    THEN						! If the connect was not successful,
	RETURN NO_FILE;					! return an error indication to the caller.

    IF .EXTEND_OUTFILE					! If the output file is being extended,
    THEN						!
	OUTFILE_RAB[RAB$V_EOF] = YES;			! force end-of-file positioning on the following CONNECT.

    IF NOT $RMS_CONNECT( RAB = OUTFILE_RAB,		! Connect the output file RAB to the FAB,
			 ERR = COPY$OUTOPN_ERR )	! specifying an error action routine.

    THEN						! If the connect was not successful,
	RETURN NO_FILE;					! return an error indication to the caller.

!
! Set ASY bit in ROP if block I/O mode.
!

    IF NOT .RECORD_MODE					! If block I/O mode
    THEN						!
	BEGIN						!
	INFILE_RAB[RAB$V_ASY] = YES;			! indicate that reading and
	OUTFILE_RAB[RAB$V_ASY] = YES;			! writing will be asynchronous
	END;						!

!
! Return to the caller
!

    RETURN OK;						! Return a success code to the caller.
    END;

PSECT CODE = COPY$COPY_FILE (ALIGN(9));			! Force page alignment for this routine.

ROUTINE COPY_FILE =					! Copies an entire input file to the output file

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine copies an entire input file into the output file,
!	using block mode I/O if possible.
!
!	This routine is page-aligned in order to minimize page faulting
!	due to executing the code which performs the actual file copying.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	RECORD_MODE - Indicates whether record mode I/O is required
!	INFILE_FAB - Input file FAB
!	INFILE_RAB - Input file RAB
!
! IMPLICIT OUTPUTS:
!
!	RECORD_COUNT - Number of input file records copied
!	BLOCK_COUNT - Number of input file blocks copied
!
! COMPLETION CODES:
!
!	OK = successful copy
!	ERROR = I/O error during copy
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	NEXT_READ;					! Temporary buffer pointer

!
! Initialization
!

    RECORD_COUNT = 0;					! Zero the input file record
    BLOCK_COUNT = 0;					! and block counters.

!
! If necessary, copy the input file to the output file one record at a time.
!

    IF .RECORD_MODE					! Test the record mode I/O indicator.
    THEN
	WHILE 1 DO					! Beginning of the record copying loop which
	    BEGIN					! will be terminated by a RETURN in the event
							! of an input end-of-file or any I/O error.

	    IF NOT $RMS_GET( RAB = INFILE_RAB )		! Get one record from the input file.

	    THEN					! If the get was not successful,
		BEGIN					! begin error processing.
							!
		IF .INFILE_RAB[RAB$L_STS] EQL RMS$_EOF	! If the error was an input end-of-file,
		THEN					!
		    RETURN OK;				! return a success code to the caller.

		IN_READ_ERROR();			! Otherwise, send an error message to the user
		RETURN ERROR;				! and return an error code to the caller.

		END;					! End of input error processing.

	    OUTFILE_RAB[RAB$L_RBF] =			! Copy the input record address
			.INFILE_RAB[RAB$L_RBF];		! and record length
	    OUTFILE_RAB[RAB$W_RSZ] =			! from the input file RAB
			.INFILE_RAB[RAB$W_RSZ];		! to the output file RAB.

	    IF $RMS_PUT( RAB = OUTFILE_RAB )		! Write one record into the output file.

	    THEN					! If the put was successful,
		RECORD_COUNT = .RECORD_COUNT + 1	! increment the record counter.
	    ELSE
		BEGIN					! Otherwise,
		OUT_WRITE_ERROR();			! send an error message to the user
		RETURN ERROR;				! and return to the caller.
		END;

	    END						! End of record mode copy loop.

!
! If possible, copy the input file to the output file a block at a time.
!

    ELSE
	WHILE 1 DO					! Beginning of the block copying loop which
	    BEGIN					! will be terminated by a RETURN in the event
							! of an input end-of-file or any I/O error.

	    $RMS_READ( RAB = INFILE_RAB );		! Begin an asynchronous read from the input file.

	    IF NOT $RMS_WAIT( RAB = OUTFILE_RAB )	! Wait for the previous write to complete.
	    THEN
		BEGIN					! If the write was not successful,
		OUT_WRITE_ERROR();			! send the user an error message,
		$RMS_WAIT( RAB = INFILE_RAB );		! wait for the previous read to complete,
		RETURN ERROR;				! and then return an error code to the caller.
		END;

	    IF $RMS_WAIT( RAB = INFILE_RAB )		! Wait for the previous read to complete.
	    THEN
		BEGIN					! If the read was successful,
		INFILE_RAB[RAB$L_UBF] =			! save the current output buffer address
			.OUTFILE_RAB[RAB$L_RBF];	!
		OUTFILE_RAB[RAB$L_RBF] =		! and copy the input block address and block size
			.INFILE_RAB[RAB$L_RBF];		! from the input file RAB into the output RAB.
		OUTFILE_RAB[RAB$W_RSZ] =		!
			.INFILE_RAB[RAB$W_RSZ];		!

		$RMS_WRITE( RAB = OUTFILE_RAB );	! Initiate an asynchronous write.

		BLOCK_COUNT = .BLOCK_COUNT +		! Increment the count of blocks written.
		    (.INFILE_RAB[RAB$W_RSZ] +		!
		    .BLOCK_SIZE - 1) / .BLOCK_SIZE;	!
		END
	    ELSE					! If the read was unsuccessful,
		BEGIN					! begin special input error processing.

		IF .INFILE_RAB[RAB$L_STS] EQL RMS$_EOF	! If the error was an input end-of-file,
		THEN					!
		    RETURN OK;				! return a success code to the caller.

		IN_READ_ERROR();			! Otherwise, send an error message to the user
		RETURN ERROR;				! and then return an error code to the caller.
		END;

	    END;					! End of block mode copy loop.

    RETURN OK;
    END;
PSECT CODE = $CODE$;					! Resume the default PSECT (see previous routine).

ROUTINE CLOSE_INFILE :  NOVALUE =			! Close the current input file

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine closes the current input file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	INFILE_OPEN - Input file open indicator
!	INFILE_FAB - Input file FAB
!
! IMPLICIT OUTPUTS:
!
!	INFILE_OPEN - Set to indicate that the input file is not open
!	INFILE_FAB - Input file FAB closed
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Return to the caller if the input file is not open.
!

    IF NOT .INFILE_OPEN					! If the input file is not open,
    THEN						!
	RETURN;						! return to the caller.

    INFILE_OPEN = NO;					! Otherwise, turn off the open indicator.

!
! Close the input file.
!

    $RMS_CLOSE( FAB = INFILE_FAB,			! Close the input file FAB,
		 ERR = IN_CLOSE_ERROR );		! specifying an error action routine.

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$CLOSE_OUTF :  NOVALUE =		! Close the current output file

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine closes the current output file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	OUTFILE_OPEN - Output file open indicator
!	OUTFILE_FAB - Output file FAB
!	TRUNCATE_BIT in COPY$CLI_STATUS if /TRUNCATE was specified.
!
! IMPLICIT OUTPUTS:
!
!	OUTFILE_OPEN - Set to indicate that the output file is not open
!	OUTFILE_FAB - Output file FAB closed
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	File is truncated if /TRUNCATE was specified.
!
!--

    BEGIN

!
! Return to the caller if the output file is not open.
!

    IF NOT .OUTFILE_OPEN				! If the output file is not open,
    THEN						!
	RETURN OK;					! return a success code to the caller.

    OUTFILE_OPEN = NO;					! Otherwise, turn off the open indicator.

!
! Close the output file.
!

    $RMS_CLOSE( FAB = OUTFILE_FAB,			! Close the output file FAB,
		 ERR = COPY$OCLOSE_ERR );		! specifying an error action routine.

!
! Reset the incompatible messages flag to FALSE for the next output file. This message
! indicates whether an incompatible attributes has been output for an output file.
!

    COPY$B_INCOMPAT = FALSE;				! Reset incompatible flag

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE BYPASS_CONCAT = 				! Bypass concatenated input files

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine scans past concatenated input file-specifications.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	Bits in the status words COPY$CLI_STATUS and COPY$SEM_STATUS:
!
!		APPEND_COMMAND	- APPEND command indicator
!		CONCAT_FOLLOWS	- concatentation is occurring
!
!	INFILE_DESC - Input file request descriptor
!	CLEANUP_DESC - Input file cleanup request descriptor
!
! IMPLICIT OUTPUTS:
!
!	CONCAT_FOLLOWS - Concatenation active indicator turned off
!	WILDCARD_ACTIVE - Wildcard active indicator turned off
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	INFILE_DESC - Input file request descriptor filled in by the CLI
!	CLEANUP_DESC - Input file cleanup request descriptor filled in by the CLI
!
!--

    BEGIN

    LOCAL
    	DESC : $BBLOCK[ DSC$C_S_BLN ]			! Descriptor for input file name
    	;

!
! Initialize descriptor.
!
    CH$FILL( 0, DSC$C_S_BLN, DESC);
    DESC[ DSC$B_CLASS ] = DSC$K_CLASS_D;

!
! Return to the caller if input concatenation is not active.
!

    IF NOT .APPEND_COMMAND AND				! If this is a COPY command
	NOT .CONCAT_FOLLOWS				! and no input concatentation is active,
    THEN						!
	RETURN false						!    then return to the caller.
    ELSE
	CONCAT_FOLLOWS = NO;				! Otherwise, turn off the concatenation indicator.

!
! Report an wildcard specification which has not been completely processed.
!

    IF .WILDCARD_ACTIVE					! If a wildcard spec is currently active,
    THEN						!
	BEGIN						!
	WILDCARD_ACTIVE = NO;				! turn off the wildcard indicator.

	IF .INFILE_NAM_BLK[NAM$B_RSL] NEQ 0		! If the wildcard spec is partially processed,
	THEN						!
	    BEGIN					!
	    INFILE_NAM_BLK[NAM$B_RSL] = 0;		! discard the current resultant name string,
	    REPORT_BYPASS( MSG$_NOTCMPLT );		! and report the bypass wildcard spec.
	    END;
	END;

!
! Scan past any concatenated input file-specifications.
!

    WHILE CLI$GET_VALUE( $DESCRIPTOR('INFILE'), DESC ) DO

	IF COPY$FIND_INPUT_FILE( DESC )			! Parse the input file-specification.
	THEN
	    REPORT_BYPASS( MSG$_NOTCOPIED );		! Report that the file was not processed.

!
! Return to the caller.
!

    RETURN true;					! Return to the caller.

    END;

GLOBAL ROUTINE COPY$FIND_INPUT_FILE ( INFILE_DESC : REF $BBLOCK ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls RMS to parse an input file-specification.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	INFILE_FAB - Input file FAB
!	INFILE_NAM_BLK - Input file name block
!
! IMPLICIT OUTPUTS:
!
!	INFILE_FAB - FNA and FNS fields filled in.
!
! COMPLETION CODES:
!
!	OK = Successful parse
!	ERROR = Error from RMS parse
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN
    
    OWN
	find_file_context : INITIAL(0);			! Context parameter for LIB$FIND_FILE

    LOCAL
	resultant_name_desc : $BBLOCK[ DSC$C_S_BLN ],	! Descriptor for filespec returned by LIB$FIND_FILE
    	find_file_nam : REF $BBLOCK[],			! Pointer to NAM block used by LIB$FIND_FILE
	status;						! Status returned by LIB$FIIND_FILE

    BIND
    	find_file_fab = find_file_context : REF $BBLOCK[];



    ! Initialize the descriptor for the resultant name string.
    !
    CH$FILL( 0, DSC$C_S_BLN, resultant_name_desc );
    resultant_name_desc[ DSC$B_CLASS ] = DSC$K_CLASS_D;


    ! Zero the expanded name sting length, so that COPY$INOPN_ERR can determine 
    ! if the expanded string was created by RMS or not.
    !
    INFILE_NAM_BLK[NAM$B_ESL] = 0;


    ! Call LIB$FIND_FILE to locate the file.  If something other than success is
    ! returned, then check to see if it is something we care about.  NMF, no 
    ! more files doesn't matter,  for any other error condition COPY should 
    ! issue a message.
    !
    IF NOT ( status = LIB$FIND_FILE( .infile_desc, resultant_name_desc, 
    		find_file_context, 0, 0, 0, %ref(2)))
    THEN
    	BEGIN
    	IF .status NEQ RMS$_NMF
    	THEN
	    COPY$INOPN_ERR( .find_file_context );
	RETURN .status;
	END;


    ! Copy the information from the resultant name string descripitor into
    ! the FAB's file name and the NAM block's resultant name descriptor fields. 
    ! Also, copy the file name status bits into the input file's NAM block and 
    ! copy the FID of the found file into the input file's name block. (COPY 
    ! does an open by name block. This guarantees that the correct file is 
    ! opened.).  Then return to the caller.
    !
    infile_fab[ FAB$L_FNA ]     = .resultant_name_desc[ DSC$A_POINTER ];
    infile_fab[ FAB$B_FNS ]     = .resultant_name_desc[ DSC$W_LENGTH ];
    infile_nam_blk[ NAM$B_RSL ] = .resultant_name_desc[ DSC$W_LENGTH ];
    in_name_desc[ 0 ] 		= .infile_nam_blk[ NAM$B_RSL ];
    CH$MOVE(.infile_fab[FAB$B_FNS], .infile_fab[FAB$L_FNA], .in_name_desc[1]);

    
    find_file_nam = .find_file_fab[ FAB$L_NAM ];
    infile_nam_blk[ NAM$L_FNB ]     = .find_file_nam[ NAM$L_FNB ];
    infile_nam_blk[ NAM$W_FID_NUM ] = .find_file_nam[ NAM$W_FID_NUM ];
    infile_nam_blk[ NAM$W_FID_SEQ ] = .find_file_nam[ NAM$W_FID_SEQ ];
    infile_nam_blk[ NAM$W_FID_RVN ] = .find_file_nam[ NAM$W_FID_RVN ];
    CH$MOVE( NAM$S_DVI, find_file_nam[NAM$T_DVI], infile_nam_blk[NAM$T_DVI] );

    RETURN ok;

    END;

GLOBAL ROUTINE COPY$CALC_ALQ =				! Allocation quantity calculation routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines the output file allocation/extension quantity.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	EXTEND_OUTFILE	- Output file extension indicator
!	INFILE_FAB	- Input file FAB
!	INFILE_XABALL	- Input file allocation XAB
!	INFILE_XABFHC	- Input file header characteristics XAB
!	COPY$CLI_STATUS bit TRUNCATE_BIT
!		means /TRUNCATE was specified
!	ALLOC_VALUE	- contains a value if /ALLOCATION was specified.
!	COPY_TRUN_QUAL  - CLI data block for the truncate qualifier; the
!			  "explicit bit" will be set if /NOTRUNCATE was 
!			  specified on the input line
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	Size of the input file (i.e., number of blocks)
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	ALQ;						! Temporary allocation quantity

!
! Return a zero allocation size if the output file is not a disk and it is being extended.
!

    IF .EXTEND_OUTFILE AND				! If the output file is being extended
	(NOT .OUTFILE_FAB[$FAB_DEV(FOD)] OR		! and it is not a file structured device
	 .OUTFILE_FAB[$FAB_DEV(SQD)])			! or it is a magnetic tape,
    THEN						!
	RETURN 0;					! return a zero allocation size to the caller.

!
! Determine the output file allocation size from the size and organization of the input file.
!

    IF NOT .INFILE_FAB[$FAB_DEV(FOD)] OR		! If the input device is not file structured
	.INFILE_FAB[$FAB_DEV(SQD)]			! or if it is a magnetic tape,
    THEN						!
	ALQ = DEFAULT_ALLOC				! assume a default input file size.
    ELSE
	BEGIN
!
! 	If the input file is a non-contiguous sequential file and /NOTRUNCATE was not explicitly given
! 		or 
!	the the input file is being appened to an existing file,
!		or
!	if /TRUNCATE and no /ALLOCATION was given,
!	the file should be truncated.  Otherwise, use the allocation of the input file as the size of
!	the output file.
!
	IF  (
	    (
	    .INFILE_FAB[ FAB$B_ORG ] EQL FAB$C_SEQ
	    	AND NOT 
	    ( .TRUNCATE_NEGATED OR .NEG_TRUNCATE_QUAL )
	    )
		AND
	    ( NOT .INFILE_XABALL[ XAB$V_CTG ] OR .EXTEND_OUTFILE )
	    )
	    	OR
	    ( (.TRUNCATE_QUAL OR .LOC_TRUNCATE_QUAL) AND .CURR_ALLOCATION_VALUE EQL 0 )
	THEN						!
	    IF .INFILE_XABFHC[XAB$W_FFB] EQL 0		! calculate only enough space to hold the actual
	    THEN					! data in the input file.  Note that this calculation
		ALQ = .INFILE_XABFHC[XAB$L_EBK] - 1	! includes the final block only if it actually
	    ELSE					! contains some data.
		ALQ = .INFILE_XABFHC[XAB$L_EBK]		!
	ELSE
	    ALQ = .INFILE_XABFHC[XAB$L_HBK];		! Otherwise, pickup the actual size of the input file.
	END;

    IF .EXTEND_OUTFILE					! If the output file is being extended,
    THEN						!
	ALQ = .OUTFILE_XABFHC[XAB$L_EBK] + .ALQ -	! subtract the remaining output file space
		.OUTFILE_XABFHC[XAB$L_HBK];		! from the calculated extension quantity.

!
! Return the calculated allocation (or extension) quantity to the caller.
!

    IF .ALQ GEQ 0					! If the calculated allocation/extension quantity
    THEN						! is greater than or equal to zero,
	RETURN .ALQ					! return that value to the caller.
    ELSE
	RETURN 0;					! Otherwise, return a zero value to the caller.

    END;

ROUTINE REPORT_NAMES					! Report the results of a file copy
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reports the results of copying a single input file
!	to the output file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	LOG - Indicator tested to see if activity reporting desired
!	EXTEND_OUTFILE - Indicator tested to see if input concatenation is active.
!	IN_NAME_DESC - Input file name descriptor
!	OUT_NAME_DESC - Output file name descriptor
!	BLOCK_COUNT - Number of input file blocks copied
!	RECORD_COUNT - Number of input file records copied
!	INFILE_FAB - Address of input file FAB
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	ptr,						! Temporary variables for character searching
	address,
	size;

!
! Determine which message, if any, is needed.
!

    IF NOT .LOG_MSG_QUAL				! If activity reporting is not requested,
    THEN						!
	RETURN;						! return to the caller.

!
! If this is a record oriented device (not network), the messages should 
! include only the device name.
!


    IF .infile_fab [$FAB_DEV(rec)] 
	AND NOT .infile_fab [$FAB_DEV(net)] 
    THEN
	BEGIN
	size = .in_name_desc[0];
	address = .in_name_desc[1];
	ptr = CH$FIND_CH(.size,.address,':');
	IF .ptr NEQ 0		! If there is anything past the device, remove it
	THEN
	    in_name_desc[0] =  .ptr - .address + 1;
	END;


    IF NOT .EXTEND_OUTFILE				! Test the record mode indicator to see
							! if this is the primary input file or a
							! concatenated input file.
!
! Create a "copied" message if the input file just copied was
! the first file copied into the output file.
!

    THEN						!
	IF .BLOCK_COUNT NEQ 0				! If the input file was copied in block mode,
	THEN						!
	    PUT_MESSAGE( MSG$_COPIEDB,			! signal "file copied" with the following arguments:
		    3,					!    Number of message arguments
		    IN_NAME_DESC,			!    Address of input file name descriptor
		    OUT_NAME_DESC,			!    Address of output file name descriptor
		    .BLOCK_COUNT )			!    Number of blocks copied

	ELSE						! Otherwise,
	    IF (.RECORD_COUNT NEQ 0) OR NOT (LIB$CHECK_DIR (INFILE_FAB)) ! If the input file is not 0 records or
									 !   is not a directory file
	    THEN
		    PUT_MESSAGE( MSG$_COPIEDR,		! signal "file copied" with the following arguments:
			    3,				!    Number of message arguments
			    IN_NAME_DESC,		!    Address of input file name descriptor
			    OUT_NAME_DESC,		!    Address of output file name descriptor
			    .RECORD_COUNT )		!    Number of records copied

	    ELSE					! Otherwise, its a directory file
		    PUT_MESSAGE( MSG$_CREATED,		! signal "created" with the following arguments:
			    1,				!    number of message arguments
			    OUT_NAME_DESC )		!    address of output file descriptor
!
! Create an "appended" message if the input file just copied was
! appended to an existing output file.
!

    ELSE						!
	IF .BLOCK_COUNT NEQ 0				! If the input file was copied in block mode,
	THEN						!
	    PUT_MESSAGE( MSG$_APPENDEDB,		! signal "file appended" with the following arguments:
		    3,					!    Number of message arguments
		    IN_NAME_DESC,			!    Address of input file name descriptor
		    OUT_NAME_DESC,			!    Address of output file name descriptor
		    .BLOCK_COUNT )			!    Number of blocks copied

	ELSE						! Otherwise,
	    PUT_MESSAGE( MSG$_APPENDEDR,		! signal "file appended" with the following arguments:
		    3,					!    Number of message arguments
		    IN_NAME_DESC,			!    Address of input file name descriptor
		    OUT_NAME_DESC,			!    Address of output file name descriptor
		    .RECORD_COUNT );			!    Number of records copied

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE REPORT_BYPASS (					! Report the bypassing of an input file
			NUMBER )			! Error number
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reports the name of an input file which has been bypassed.
!
! FORMAL PARAMETERS:
!
!	NUMBER.rlu.v - Error number
!
! IMPLICIT INPUTS:
!
!	INFILE_NAM_BLK - Input file name block
!	INFILE_NAME - Input file resultant name
!	INFILE_XNAME - Input file expanded name
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	NAME_DESC :  VECTOR[2];				! Input file name descriptor

!
! Setup the input file name descriptor.
!

    IF .INFILE_NAM_BLK[NAM$B_RSL] NEQ 0			! If RMS has setup a resultant name string,
    THEN						!
	BEGIN						!
	NAME_DESC[0] = .INFILE_NAM_BLK[NAM$B_RSL];	! setup the name descriptor to use
	NAME_DESC[1] = INFILE_NAME;			! the resultant name string.
	END
    ELSE
	BEGIN						!
	NAME_DESC[0] = .INFILE_NAM_BLK[NAM$B_ESL];	! Otherwise, use the expanded name string.
	NAME_DESC[1] = INFILE_XNAME;			!
	END;

!
! Report the name of the input file which is being bypassed.
!

    PUT_MESSAGEX( .NUMBER, 1, NAME_DESC );		! Report the name of the input file.

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$LOG_MSG (				! Signal a COPY message
		NUMBER )				! Error number
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sends an informational message to the user if
!	activity reporting has been requested.
!
! FORMAL PARAMETERS:
!
!	NUMBER.rlu.v - error number
!
! IMPLICIT INPUTS:
!
!	LOG_MSG - Activity reporting indicator
!	OUTFILE_COUNT - Number of output files created
!	OUT_NAME_DESC - Output file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Return to the caller if activity reporting has not been requested.
!

    IF NOT .LOG_MSG_QUAL				! If activity reporting is not requested,
    THEN						!
	RETURN;						! return to the caller.

!
! Call FAO to format the error message in the message buffer.
!

    SELECTONE .NUMBER OF				! Select error message processing based
	SET						! on the actual error number.

	[MSG$_NEWFILES]:
	    IF .OUTFILE_COUNT GEQU 2			! If at least 2 files was created,
	    THEN					!
		PUT_MESSAGE( MSG$_NEWFILES,		! signal "<number> files created" with the following args:
			1,				!    number of message arguments
			.OUTFILE_COUNT );		!    number of output files created

	[MSG$_REPLACED, MSG$_OVERLAY, MSG$_CREATED]:
	    PUT_MESSAGEX( .NUMBER,			! signal the message with the following arguments:
			1,				!    number of message arguments
			OUT_NAME_DESC );		!    address of the output name descriptor

	[OTHERWISE]:
	    PUT_MESSAGEX( .NUMBER );			! Signal the appropriate message.
	TES;

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$INOPN_ERR (				! RMS input open error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an input open error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	Input file name block
!	Input file name after open
!	Input file name before open
!	Input file cli descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

    LOCAL
	MESSAGE_ID,					! Local message identifier
    	NAM_BLK : REF $BBLOCK[],			! Pointer to NAM block
	NAME_DESC :  VECTOR[2];				! Input file name descriptor

!
! Fillin the file name descriptor with the most complete name possible.
!

    NAM_BLK = .FAB_RAB[FAB$L_NAM];

    IF .NAM_BLK[NAM$B_RSL] NEQ 0			! If a resultant name string exists,
    THEN						!
	BEGIN						!
	MESSAGE_ID = MSG$_OPENIN;			! indicate an open error
	NAME_DESC[0] = .NAM_BLK[NAM$B_RSL];		! and fillin the resultant name length
	NAME_DESC[1] = .NAM_BLK[NAM$L_RSA];		! and address.
	END
    ELSE
	IF .NAM_BLK[NAM$B_ESL] NEQ 0			! If RMS created an expanded string
	THEN						! but coundn't open the file,
	    BEGIN					!
	    MESSAGE_ID = MSG$_OPENIN;			! indicate an open error
	    NAME_DESC[0] = .NAM_BLK[NAM$B_ESL];		! and fillin the expanded name length
	    NAME_DESC[1] = .NAM_BLK[NAM$L_ESA];		! and address.
	    END
	ELSE
	    BEGIN
	    MESSAGE_ID = MSG$_OPENINX;			! Otherwise, indicate a fatal open error
	    NAME_DESC[0] = .INFILE_CLI_DESC[DSC$W_LENGTH];  ! and use the file name length
	    NAME_DESC[1] = .INFILE_CLI_DESC[DSC$A_POINTER]; ! and length passed by the CLI.
	    END;
!
! If mag tape and operator aborted the mount, make it fatal
!
	IF .FAB_RAB[$FAB_DEV(sdi)]
	    AND .FAB_RAB[FAB$L_STV] EQL SS$_ABORT
	THEN
	    MESSAGE_ID = MSG$_OPENINX;

!
! Signal the error condition.
!

    PUT_MESSAGEX( .MESSAGE_ID,				! Signal "input open error" with the following arguments:
		1,					!    Number of message arguments
		NAME_DESC,				!    Address of input name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE IN_READ_ERROR : NOVALUE =			! RMS input read error action routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an input read error message to the user.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	INFILE_RAB - Input file RAB
!	IN_NAME_DESC - Input file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Signal the input read error.
!

    PUT_MESSAGE( MSG$_READERR,				! Signal a "read error" with the following arguments:
		1,					!    Number of message arguments
		IN_NAME_DESC,				!    Address of input file name descriptor
		.INFILE_RAB[RAB$L_STS],			!    Primary RMS completion code
		.INFILE_RAB[RAB$L_STV] );		!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE IN_CLOSE_ERROR (				! RMS input close error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an input close error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	IN_NAME_DESC - Input file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

!
! Signal an input close error.
!

    PUT_MESSAGE( MSG$_CLOSEIN,				! Signal a "close error" with the following arguments:
		1,					!    Number of message arguments
		IN_NAME_DESC,				!    Address of input file name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$OUTOPN_ERR (			! RMS output open error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an output open error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	OUTFILE_NAM_BLK - Output file name block
!	OUTFILE_NAME - Output file name after open
!	OUTFILE_XNAME - Output file name before open
!	OUTFILE_DESC - Output file request descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

    LOCAL
	MESSAGE_ID,					! Local message identifier
	NAME_DESC :  VECTOR[2];				! Output file name descriptor

!
! Fillin the file name descriptor with the most complete name possible.
!

    IF .OUTFILE_NAM_BLK[NAM$B_RSL] NEQ 0		! If a resultant name string exists,
    THEN						!
	BEGIN						!
	MESSAGE_ID = MSG$_OPENOUT;			! indicate an open error
	NAME_DESC[0] = .OUTFILE_NAM_BLK[NAM$B_RSL];	! and fillin the resultant name length
	NAME_DESC[1] = OUTFILE_NAME;			! and address.
	END
    ELSE
	IF .OUTFILE_NAM_BLK[NAM$B_ESL] NEQ 0		! If RMS created an expanded string but couldn't open
	THEN						!
	    BEGIN					!
	    MESSAGE_ID = MSG$_OPENOUT;			! indicate an open error
	    NAME_DESC[0] = .OUTFILE_NAM_BLK[NAM$B_ESL];	! and fillin the expanded name length
	    NAME_DESC[1] = OUTFILE_XNAME;		! and address.
	    END
	ELSE
	    BEGIN
	    MESSAGE_ID = MSG$_OPENOUTX;			! Otherwise, indicate a fatal open error
	    NAME_DESC[0] = .OUT_NAME_DESC[ 0 ];		! and use the file name length
	    NAME_DESC[1] = .OUT_NAME_DESC[ 1 ];	! and length passed by the CLI.
	    END;
!
! If mag tape and operator aborted the mount, make it fatal
!
	IF .FAB_RAB[$FAB_DEV(sdi)]
	    AND .FAB_RAB[FAB$L_STV] EQL SS$_ABORT
	THEN
	    MESSAGE_ID = MSG$_OPENOUTX;

!
! Signal the error condition.
!

    PUT_MESSAGEX( .MESSAGE_ID,				! Signal "output open error" with the following arguments:
		1,					!    Number of message arguments
		NAME_DESC,				!    Address of output name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE OUT_WRITE_ERROR : NOVALUE =			! RMS output write error action routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an output read error message to the user.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	OUTFILE_RAB - Output file RAB
!	OUT_NAME_DESC - Output file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Signal the output write error.
!

    PUT_MESSAGE( MSG$_WRITEERR,				! Signal a "write error" with the following arguments:
		1,					!    Number of message arguments
		OUT_NAME_DESC,				!    Address of output file name descriptor
		.OUTFILE_RAB[RAB$L_STS],		!    Primary RMS completion code
		.OUTFILE_RAB[RAB$L_STV] );		!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$OCLOSE_ERR (			! RMS output close error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an output close error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	OUT_NAME_DESC - Output file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

!
! Signal an output close error.
!

    PUT_MESSAGE( MSG$_CLOSEOUT,				! Signal a "close error" with the following arguments:
		1,					!    Number of message arguments
		OUT_NAME_DESC,				!    Address of output file name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$MSG_NUMBER (			! COPY/APPEND message number generator
			MSG_ID ) =			! Message number

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine return a COPY-specific or APPEND-specific message id
!	by inserting the appropriate facility identifier in the high word
!	of the message id which is passed by the caller.  This routine also
!	records the highest severity message encountered.
!
! FORMAL PARAMETERS:
!
!	MSG_ID.rlu.v - Message id
!
! IMPLICIT INPUTS:
!
!	APPEND_COMMAND = APPEND command indicator
!	MOST_SEVERE_ERR - Current most severe error id
!	OUTFILE_NAM_BLK - Output file name block - wildcard indicator
!
! IMPLICIT OUTPUTS:
!
!	MOST_SEVERE_ERR - Most severe error id may be updated
!
! ROUTINE VALUE:
!
!	Actual message id
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    MAP							!
	MSG_ID :  BLOCK[,BYTE];				! Redefine the form of the input argument

    LOCAL
	ACTUAL_MSG_ID :  BLOCK[1];			! Actual message identifier

!
! Calculate the actual message identifier.
!

IF .MSG_ID<16,16> EQL 0					! If facility unspecified,
THEN
    IF .APPEND_COMMAND					! If this is an APPEND command,
    THEN						!
	ACTUAL_MSG_ID = .MSG_ID + (APPEND_ID * 65536)	! insert the APPEND facility code into the message id.
    ELSE						! If this is a COPY command,
	ACTUAL_MSG_ID = .MSG_ID + (COPY_ID * 65536)	! insert the COPY facility code into the message id.
ELSE
    ACTUAL_MSG_ID = .MSG_ID;				! else use existing code

!
! Update the "most severe error" if the current error is more severe.
!

    IF NOT .ACTUAL_MSG_ID AND				! If the current message is not a success message and
	(.MOST_SEVERE_ERR OR				! either this is the first error message
	.ACTUAL_MSG_ID[STS$V_SEVERITY] GTRU		! or the current message severity
		.MOST_SEVERE_ERR[STS$V_SEVERITY])	! is greater than the previous severity,
    THEN						!
	MOST_SEVERE_ERR = .ACTUAL_MSG_ID OR		! update the most severe message id
				STS$M_INHIB_MSG;	! and turn on the "suppress message" indicator.

!
! Return the actual message id to the caller.
!

    RETURN .ACTUAL_MSG_ID;				! Return the actual message id to the caller.

    END;

END
ELUDOM
