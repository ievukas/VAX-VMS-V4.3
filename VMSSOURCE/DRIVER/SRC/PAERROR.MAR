	.TITLE	PAERROR Error Handling & Logging Routines
	.IDENT	'V04-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:  ROUTINES TO HANDLE CI VIRTUAL CIRCUIT RECOVERY
;
; AUTHOR:  N. KRONENBERG,  DECEMBER 1981
;
; MODIFIED BY:
;
;	V04-001	NPK3066		N. Kronenberg		 7-Sep-1984
;		Disable invalid buffer name bugcheck since bug is found.
;		With this edit, all optional bugchecks are disabled
;		and maximum error recovery enabled.
;
;	V03-040	NPK3065		N. Kronenberg		23-Aug-1984
;		Disable MFQE optional bugcheck since bug is found.
;
;	V03-039	NPK3061		N. Kronenberg		 9-Aug-1984
;		Remove optional debug bugcheck on unexpected port
;		interrupt.
;
;	V03-038	NPK3060		N. Kronenberg		 1-Aug-1984
;		Remove remote port from OPA0 messages concerning
;		loopback dgs since no remote port is applicable.
;		Make loopback dg OPA0 messages be reported always.
;
;	V03-037	NPK3058		N. Kronenberg		25-Jul-1984
;		Add MFQE optional bugcheck enable flag and enable
;		three kinds of optional bugchecks.
;
;	V03-036	NPK3057		N. Kronenberg		23-Jul-1984
;		Change the OPA0 message descriptors for cpu/port
;		ucode not at required rev level not to include
;		offline messages since these are generated separately
;		in PAINIT, CLEANUP_PDT.
;
;	V03-035	NPK3055		N. Kronenberg		14-Jul-1984
;		Change OPA0 error log msgs for cpu/port ucode rev
;		error to include port offline msg.  Change wording
;		of cpu ucode rev error msg to say that rev is insufficient
;		for CI activity.
;		Add separate port ucode rev warning msg that does not
;		include offline announcement.
;		Add ELOG$CPU_REV, ELOG$UCODE_ERR, ELOG_UCODE_WARN.
;
;	V03-034	NPK3054		N. Kronenberg		24-Jun-1984
;		Add OPA0 messages to warn operator of either CPU
;		rev level insufficient to support ci, or the ci
;		ucode rev level is insufficient.
;
;	V03-033	NPK3053		N. Kronenberg		17-May-1984
;		Fix branch error in NPK3052.
;
;	V03-032	NPK3052		N. Kronenberg		 4-May-1984
;		Fix ERR$PWF_RECOV to properly handle a port failure
;		for a port with circuits in VC_FAIL state.
;
;	V03-031	NPK3048		N. Kronenberg		 9-Apr-1984
;		Add two new $DEBUGCHECK enable flags.
;
;	V03-030	TMK0005		Todd M. Katz		25-Mar-1984
;		Change the text of the remote system conflicts _OPA0 error 
;		logging message.
;
;	V03-029	TMK0004		Todd M. Katz		24-Mar-1984
;		When it is decided to log an error condition to _OPA0, a fork
;		process is created to format and broadcast an appropriate 
;		message. It is absolutely necessary that all messages be 
;		formated at fork IPL. This is because there is only one copy
;		of each message, but there maybe multiple CI ports making use
;		of each message. 
;
;		However, what is incorrect is that the optional data which maybe
;		used for formatting a _OPA0 error log message is being extracted
;		from the UCB error logging buffer or from the device registers 
;		within the context of the fork process. By the time the fork 
;		process gets a chance to execute and make use of this optional
;		data for formatting a message, it is possible (and in the case 
;		of device registers certain) that the values stored in these 
;		locations will have changed.
;
;		The solution to this problem is to store the needed information
;		within UCB$T_OPA0_TEMP (a new UCB field three longwards in size)
;		just before the creation of the fork process within OPA0_LOG. 
;		Then, whenever optional formatting of an _OPA0 error log message
;		is required, the routines which perform the formatting make use 
;		of the information stored in this UCB location. 
;
;		Three types of information maybe required for additional 
;		formatting - device registers, a remote port number, or CI 
;		packet information. I have defined a OPA0 error logging control 
;		flag for each information type. For a given error condition the
;		setting of these control flags will direct what information is 
;		saved within this new UCB location, before the fork process is 
;		created, to be used in the formatting of the appropriate _OPA0 
;		error log message.
;
;	V03-028	TMK0003		Todd M. Katz		06-Mar-1984
;		Add support for _OPA0 error logging. This involves determining,
;		whenever error logging is to be done, whether or not an attempt
;		should also be made to log the error condition at _OPA0. Such
;		logging will always be attempted for certain error conditions,
;		and it will also be done whenever it is found that the system 
;		device, which is presumed to also be the error logging device, 
;		is currently unavailable.
;
;		A table driven routine, OPA0_LOG, is used to determine whether 
;		or not _OPA0 error logging should always be done for a given 
;		error condition as well as to provide the error logging message 
;		to be broadcast to _OPA0 and optional formatting information. 
;		When a decision is made to perform this error logging, the UCB's
;		message fork block is used to create a fork process provided it 
;		is not already in use (in which case _OPA0 error logging will be
;		bypassed for this error condition). When this fork process 
;		resumes control at OPA0_LOG_FORK, it proceeds to format an error
;		logging message and broadcast it to _OPA0. In the case of 
;		certain unrecoverable port initialization errors, this fork 
;		process will also broadcast a second message indicating that the
;		port will be left offline.
;
;	V03-027	TMK0002		Todd M. Katz		21-Feb-1984
;		Make the following changes to fix several bugs, and in support 
;		of allowing port initialization to proceed at IPL 8 instead of 
;		at IPL$_POWER:
;
;		1. Do not disable all interrupts by raising IPL to IPL$_POWER
;		   before calling INI$PORT from within ERR$INIPORT. Port 
;		   initialization is now being done at fork IPL instead of at 
;		   IPL$_POWER.
;
;		2. Disable device interrupts within ERR$INIPORT before calling
;		   INI$PORT to re-initialize the port. This is done by 
;		   explicitely placing the port within the un-initialized state.
;		   If this is not done it is possible that the port maybe in the
;		   un-initialized state but with device interrupts enabled when
;		   port re-initializtion begins. Then if a device interrupt 
;		   occurs during port re-initialization it may prevent the 
;		   un-initialized -> disabled state transition from occurring 
;		   at the proper time. The end result is that a second attempt 
;		   at re-initializing the port will be required. 
;
;		3. The way in which ERR$PWF_RECOV is forking is incorrect. 
;		   It does not make proper use of the UCB_V_FKLOCK fork block
;		   interlock bit. It never sets the interlock bit before using
;		   the fork block if the fork block is currently not in use.
;		   This may result in this same fork block being used twice
;		   in succession. In such a situation the context saved by the 
;		   first fork, the fork initiated by ERR$PWF_RECOV, would be
;		   overwritten by the context of the second fork. 
;
;		   I have corrected this problem by utilizing the new routine 
;		   INI$FORK to control the forking. This routine knows how to 
;		   extract the fork block from the appropriate fork queue in an 
;		   atomic fashion, and how to make proper use of the fork block 
;		   interlock bit. This routine always returns control at fork 
;		   IPL by jumping to the address provided it as input in R3.
;
;		4. I have also corrected an error in how ERR$PWF_RECOV cleans up
;		   a local port's path blocks, and crashes the local port.
;		   This routine should only be crashing the port after every 
;		   SYSAP with a connection over the port has been notified and 
;		   has had a chance to issue a DISCONNECT. A DISCONNECT, under 
;		   such a circumstance, would result in the path block being 
;		   deleted, and the count of path blocks associated with the 
;		   port being decremented, if the disconnected connection 
;		   represented the path's last connection. Therefore, 
;		   ERR$PWF_RECOV should only be crashing the port when the count
;		   of path blocks associated with the port reaches zero 
;		   indicating that every SYSAP which had a connection over this 
;		   port has been notified and issued a DISCONNECT. 
;
;		   Unfortunately when the co-routine CNF$LKP_PB_PDT encounters 
;		   the end of the PB list, ERR$PWF_RECOV immediately crashes the
;		   port regardless of the number of path blocks still associated
;		   with the port. I have corrected this routine so that when the
;		   end of the port's path block list is encountered, 
;		   ERR$PWF_RECOV will only crash the port if the count of the 
;		   port's assocated path blocks is zero.
;
;	V03-026	TMK0001		Todd M. Katz		14-Feb-1984
;		Add support for error logging of the refusals of the local
;		port to open up a virtual circuit to a remote port because of 
;		conflictions between information provided by the remote system 
;		and a known system within the system-wide configuration data 
;		base. This support involves modification to ELOG$PACKET so that 
;		a special type of packet is logged whenever this event occurs. 
;		Instead of logging a data packet, this event results in the 
;		logging of the known system ID, the known system nodename, and 
;		the remote system nodename in addition to the usaul stuff which 
;		is always logged (local station address, etc... ).
;
;		Also, fix two small bugs within ELOG$PACKET. Currently, the
;		entire message logging area is not being used (or is not being
;		zeroed out if there is no packet to be logged). This is because
;		the destination sizes used in the MOVC5s only include 4 bytes
;		of the 8 bytes of CI packet command/control/status 
;		information, CI packet PPD type, and CI packet message data
;		length.
;
;	V03-025	NPK3044		N. Kronenberg		 6-Feb-1984
;		Add ELOG$ERROR_DG to log an error datagram.  Modify
;		ELOG$$LOG_LM to handle error log datagrams which are
;		larger than other logged messages.
;		Disable all optional bugchecks in ERR$DEBUGCHECK.
;
;	V03-024	NPK3043		N. Kronenberg		 6-Feb-1984
;		Fix ELOG$$LOG_LM to copy all 6 bytes of local sysid.
;
;	V03-023	NPK3039		N. Kronenberg		11-Jan-1984
;		Zero PB$L_CLSCKT_DG when closing vc in ERR$CRASHVC.
;		Add ERR$V_DEB_PSRX flag for enabling/disabling bugcheck
;		on interrupt with undefined bits set in PSR.
;
;	V03-022	NPK3038		N. Kronenberg		 6-Dec-1983
;		Disable the ERR$DEBUGCHECK flags for connect request
;		with no path block and SCS bookkeeping with no path
;		block.
;
;	V03-021	NPK3037		N. Kronenberg		11-Nov-1983
;		Add ERR$DEBUGCHECK flags definitions and flags longwd.
;		Make subroutine CLEANUP_PKTS a global routine,
;		ERR$CLEANUP_PKT.
;		Make subroutine CALL_INIT_PORT a global routine,
;		ERR$INIPORT.
;		Remove queue interlock clear from FLUSH_Q since it
;		is already done in routine UNLOCK_BADQ.
;
;	V03-020	NPK3029		N. Kronenberg		22-Jul-1983
;		Enhancements for V4.0:
;		Change ERR$CRASH_PORT to not fake a power off to
;		prevent reinit of port if ERTCNT is exhausted
;		(INI$PORT now handles that.)
;		Change IOFORK to FORK in ERR$PWF_RECOV.
;		Remove references to PB$L_SB in favor of PB$L_SBLINK.
;
;	V03-019	NPK3024		N. Kronenberg		18-May-1983
;		Add logic for variable net header size to routine
;		ELOG$LOG_LM.
;
;	V03-018	KTA3046		Kerbey T. Altmann	30-Mar-1983
;		Redo for SCS/PPD split.
;
;	V03-017 NPK3011		N. Kronenberg		22-Nov-1982
;		Fix ERR$CRASH_PORT to call ERR$PWF_RECOV at device IPL.
;
;	V03-016	ROW0133		Ralph O. Weber		14-OCT-1982
;		Correct PPD$W_LENGTH reference in ELOG$$LOG_LM to PPD$W_SIZE.  
;		This causes the allocated pool size value to be used, as 
;		documented, when the maximum size of the message region to be 
;		error logged is calculated.
;		This change will be distributed in Version 3.2.
;
;	V03-015	NPK3006		N. Kronenberg		 9-Sep-1982
;		Comment possible aux status input to ERR$PWF_RECOV better.
;		Fix data structure error path by zeroing locked queue
;		headers in ERR$PWF_RECOV prior to forking down from
;		device IPL.
;
;	V03-014	ROW0119		Ralph O. Weber		 9-AUG-1982
;		Modify ELOG$$LOG_LM so that it does not copy anything beyond 
;		the space allocated to a message packet as shown in the size 
;		word field of the standard pool unit header.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-013	ROW0115		Ralph O. Weber		30-JUN-1982
;		Modify ELOG$$LOG_LM to always copy first 68 bytes of message 
;		into UCB logged message buffer and to specially zero the 
;		buffer when no message packet exists.  Also replace 
;		ELOG$$LOG_LM system block search code with use of new 
;		PB$L_SBLINK pointer to SB.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-12	NPK3001		N. Kronenberg		28-Jun-1982
;		Clear UCB fork blk lock following power fail fork.
;		
;	V03-011	ROW0111		Ralph O. Weber		27-JUN-1982
;		Add ELOG$CABLES, a routine like ELOG$PACKET only with change 
;		of cable state error type.  This routine required for loopback 
;		datagram logging.  Add a clear for UCB$L_CICMD when there is 
;		no message packet so that it will be zero just like everything 
;		else.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-010	ROW0110		Ralph O. Weber		24-JUN-1982
;		Fix ELOG$$LOG_LM to adjust error count up by one while copying 
;		it into the UCB log message buffer, since UCB$W_ERRCNT has not 
;		yet been incremented.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-009	ROW0108		Ralph O. Weber		24-JUN-1982
;		Fix ELOG$PACKET and ELOG$$LOG_LM to handle case where no 
;		packet exists.  Also correct ELOG$PACKET so that error sub-
;		type information is retrieved after CNF$LKP_PB_MSG is called.
;		This change will be shipped with VAX/VMS Version 3.1.
;
;	V03-008 NPK3001		N. Kronenberg		22-Jun-1982
;		Fix to keep UCB fork block locked on power fail
;		recovery fork.
;
;	V03-007	ROW0098		Ralph O. Weber		 7-JUN-1982
;		Add call to error appropriate error logging routine at 
;		CONFIG_ERR in ERR$VCCLOSED_MSG.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-006	ROW0092		Ralph O. Weber		 3-JUN-1982
;		Add error logging routines which generate logged message error 
;		log entries; ELOG$PACKET, ELOG$PTH_ST_CHG, and ELOG$CBL_X_CHG. 
;		Also added necessary definition macro references.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-005	ROW0089		Ralph O. Weber		20-MAY-1982
;		Add error logging routines which generate device attention 
;		error log entries; ELOG$INIT_SWERR, ELOG$UCODE_NORD, 
;		ELOG$HARDWARE, and ELOG$INTRLOCK.  Also add register dump 
;		routine, ELOG$REGDUMP.  Add necessary definition macro 
;		references too.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-004	NPK2019		N. Kronenberg		6-Apr-1982
;		Changed DISP_ENTRY to global ERR$DISP_ENTRY.
;		Add routine ERR$CRASH_PORT.
;		Fix illegal CDT state in NOTIFY_SYSAP to be nonfatal
;		bugcheck with recovery rather than fatal bugcheck.
;		Fix PB lookup failure in ERR$VCCLOSED_MSG to crash VC.
;		Change queue interlock failure in FLUSH_Q to be non
;		fatal bugcheck.
;		Fix CHK_NO_CDTS to get remote port from PB and use
;		$TURNMSG.
;		Fix CLEANUP_PKTS to reset logout area longwd immediately
;		after processing entry.
;
;	V03-003	NPK2018		N. Kronenberg		29-Mar-1982
;		Modified ERR$CRASHVC_PB to use dg buffer in PB for
;		SETCKT instead of allocating buffer.
;		Broke ERR$DISC_VCFAIL into main routine and new
;		subroutine, CHK_NO_CDTS.
;		Made disconnect on power failure synchronous --
;		it suspends till CDT is actually removed.
;		Modified CONNECT_ABO and DCONNECT_OK in NOTIFY_SYSAP
;		to call CHK_NO_CDTS.
;
;	V03-002	NPK2018		N. Kronenberg		25-Mar-1982
;		Fix ERR$DISC_PWFAIL to purge out command queues again.
;
;	V03-001	NPK2016		N. Kronenberg		18-Mar-1982
;		Fixed .TITLE
;
;
;--

	.SBTTL	DEFINITIONS

;
; Set PSECT to driver code:
;

	.PSECT	$$$115_DRIVER, LONG

;
; System definitions (LIB.MLB)
;

	.nocross
	$CDTDEF				; Connection Descriptor offsets
	$CLUBDEF			; Cluster Block offsets
	$CRBDEF				; Channel Request Block offsets
	$DDBDEF				; Device Data Block format
	$DYNDEF				; Dynamic data structures types
	$EMBDEF				; Error log buffer offsets
	$EMBLTDEF			; Logged messages subtype values
	$IDBDEF				; Interrupt Data Block offsets
	$IPLDEF				; Define priority levels
	$MCHKDEF			; Protect from machine check codes
	$PBDEF				; Path Blk offsets
	$PDTDEF				; Port Descriptor offsets
	$SBDEF				; System Block offsets
	$SSDEF				; System service return codes
	$UCBDEF				; UCB definitions
	$VECDEF				; CRB vector segment offsets

;
; PADRIVER definitions (PALIB.MLB):
;

	$PAERDEF			; PADRIVER error code definitions
	$PAPBDEF			; PA-specific extension to PB
	$PAPDTDEF			; PA-specific extension to PDT
	$PAREGDEF			; CI port device register defns
	$PAUCBDEF			; PA extension to UCB
	$PPDDEF				; PPD layer of msg/dg header
	.cross

	.SBTTL	_OPA0 ERROR LOGGING DATA

;+
; The routine which logs errors to _OPA0 is table driven. There are separate
; tables for device attention and logged message errors. What follows is the
; the macro that is used to generate each table entry, the two tables, various 
; offsets to the fields within each table entry, and assorted constants.
;-

;
; Macro to generate an entry within an _OPA0 error logging table. The format
; of each entry is as follows:
;
;	.BYTE	<ERROR SUBTYPE>
;	.BYTE	<ERROR TYPE>
;	.BYTE	<CONTROL FLAGS>
;	.BYTE	<OPTIONAL OFFSET TO MSG FIELD TO BE FORMATTED>
;	.WORD	<OPTIONAL OFFSET (from PA$CTLINIT) TO FORMATTING ROUTINE>
;	.WORD	<OFFSET (from PA$CTLINIT) TO ERROR MSG>
;
; All of the _OPA0 error messages are placed within their own PSECT. Each 
; _OPA0 error logging table must be terminated by a word of -1.
;

	.MACRO	$OPA0_LOG	TYPE,SUBTYPE,FLAGS,FORMAT,MSG

	.IF	NB	TYPE
	.BYTE	<PAER$K_ES_'SUBTYPE>	; Error Subtype
	.BYTE	<PAER$K_ET_'TYPE>	; Error Type

	.IF	NB	FLAGS
	.BYTE	FLAGS			; Flags affecting logging to OPA0
	.ENDC
	.IF	B	FLAGS
	.BYTE	0
	.ENDC

	.IF	NB	FORMAT
	.BYTE	%LOCATE(<xx>,MSG)+11	; Offset to field to be formatted
	.WORD	<FORMAT-PA$CTLINIT>	; Optional formatting routine offset
	.ENDC
	.IF	B	FORMAT
	.BYTE	0
	.WORD	0
	.ENDC

	.SAVE
	.PSECT	$$$110_MSGS
$$MSG_PTR = .
	.ASCIC	<CR><LF><BELL>"%PAx0, 'MSG"<CR><LF> ; Message to display at OPA0
	.RESTORE
	.WORD	<$$MSG_PTR-PA$CTLINIT>	; OPA0 msg offset
	.ENDC

	.IF	B	TYPE
	.WORD	-1			; -1 marks the end of the table
	.ENDC
	.ENDM


;
; Offsets to the various fields within a _OPA0 error logging table entry.
;

SUBTYPE	= 0				; Offset to Error subtype 
TYPE	= 1				; Offset to Error type 
CFLAGS	= 2				; Offset to Control Flags
OFFSET	= 3				; Offset to Optional Formatting Offset
FORMAT	= 4				; Offset to Optional Format Routine Offset
MSG	= 6				; Offset to Error Message Offset

OPA0_LOG_SIZE	= 8			; _OPA0 Error Logging Table Entry Size 

;
; Define the bits within the control flags _OPA0 error logging table field.
;

V_ALWAYS  = 0				; Always print out this error message
M_ALWAYS  = 1

V_OFFLINE = 1				; Always print out a second message
M_OFFLINE = 2				; (Port has gone Offline)

V_RPORT	  = 2				; Store the remote port number in the
M_RPORT	  = 4				; _OPA0 error loggging UCB data area

V_PKT	  = 3				; Store the CICMD packet information in
M_PKT	  = 8				; the _OPA0 error loggging UCB data area

V_REGS	  = 4				; Store the device registers in the 
M_REGS	  = 16				; _OPA0 error loggging UCB data area

;
; Define ASCII symbols for various hexadecimal formatting characters.
;

CR	= 13				; ASCII for carriage return,
LF	= 10				;  linefeed,
BELL	= 7				;  and bell

CTRLR_NAME	= 6			; Byte offset to device controller
					; letter in error logging messages

;
; Define table for hexadecimal -> ASCII and hexadecimal -> decimal -> ASCII
; conversions.
;

CONV_TABLE:
	.ASCII	/0123456789ABCDEF/


;
; Device Attention _OPA0 Error Logging Table.
;

DA_OPA0_LOG_TAB:
	$OPA0_LOG	INSW,POOL,M_ALWAYS+M_OFFLINE,,-
		<Insufficient Non-paged Pool for Initialization>
	$OPA0_LOG	INSW,CODE,M_ALWAYS+M_OFFLINE,,-
		<Failed to Locate Port Micro-code Image>
	$OPA0_LOG	INSW,SCSID,M_ALWAYS+M_OFFLINE,,-
		<SCSSYSTEMID has NOT been set to a Non-zero Value>
	$OPA0_LOG	HW,UCDW,M_ALWAYS,,-
		<Micro-code Verification Error>
	$OPA0_LOG	HW,INIT,M_ALWAYS+M_REGS,FORMAT_REGS,-
		<Port Transition Failure - CNF/PMC/PSR  xxxxxxxx/xxxxxxxx/xxxxxxxx>
	$OPA0_LOG	HW,HWER,M_ALWAYS+M_REGS,FORMAT_REGS,-
		<Port Error Bit(s) Set - CNF/PMC/PSR  xxxxxxxx/xxxxxxxx/xxxxxxxx>
	$OPA0_LOG	HW,PDWN,M_ALWAYS,,-
		<Port Power Down>
	$OPA0_LOG	HW,PUP,M_ALWAYS,,-
		<Port Power Up>
	$OPA0_LOG	HW,UXIN,M_ALWAYS+M_REGS,FORMAT_REGS,-
		<Unexpected Interrupt - CNF/PMC/PSR  xxxxxxxx/xxxxxxxx/xxxxxxxx>
	$OPA0_LOG	HW,REVER,M_ALWAYS,FORMAT_REV,-
		<CI port ucode not at required rev level.  RAM/PROM rev is xxxx/xxxx>
	$OPA0_LOG	HW,REVCA,M_ALWAYS,FORMAT_REV,-
		<CI port ucode not at current rev level.  RAM/PROM rev is xxxx/xxxx>
	$OPA0_LOG	HW,CPUREV,M_ALWAYS,,-
		<CPU ucode not at required rev level for CI activity>
	$OPA0_LOG	ILCK,MQRM,M_ALWAYS,,-
		<Message Free Queue Remove Failure>
	$OPA0_LOG	ILCK,DQRM,M_ALWAYS,,-
		<Datagram Free Queue Remove Failure>
	$OPA0_LOG	ILCK,RQRM,M_ALWAYS,,-
		<Response Queue Remove Failure>
	$OPA0_LOG	ILCK,HCIN,M_ALWAYS,,-
		<High Priority Command Queue Insert Failure>
	$OPA0_LOG	ILCK,LCIN,M_ALWAYS,,-
		<Low Priority Command Queue Insert Failure>
	$OPA0_LOG	ILCK,MQIN,M_ALWAYS,,-
		<Message Free Queue Insert Failure>
	$OPA0_LOG	ILCK,DQIN,M_ALWAYS,,-
		<Datagram Free Queue Insert Failure>
	$OPA0_LOG


;
; Logged Message _OPA0 Error Logging Table.
;

LM_OPA0_LOG_TAB:
	$OPA0_LOG	PKT,UPKT,M_ALWAYS+M_PKT,FORMAT_PKT,-
		<Unrecognized SCA Packet - FLAGS/OPC/STATUS/PORT  xx/xx/xx/xx>
	$OPA0_LOG	PKT,PCVC,M_ALWAYS+M_RPORT,FORMAT_PORT,-
		<Port has Closed Virtual Circuit - REMOTE PORT xxx>
	$OPA0_LOG	PKT,CSHP,M_ALWAYS,,-
		<Software Shutting Down Port>
	$OPA0_LOG	PKT,SCVC,M_ALWAYS+M_RPORT,FORMAT_PORT,-
		<Software is Closing Virtual Circuit - REMOTE PORT xxx>
	$OPA0_LOG	PKT,CNPB,M_ALWAYS+M_PKT,FORMAT_PKT,-
		<Received Connect Without Path-Block - FLAGS/OPC/STATUS/PORT  xx/xx/xx/xx>
	$OPA0_LOG	PKT,SCA,M_ALWAYS+M_PKT,FORMAT_PKT,-
		<Inappropriate SCA Control Message - FLAGS/OPC/STATUS/PORT  xx/xx/xx/xx>
	$OPA0_LOG	PKT,NOPB,M_ALWAYS+M_RPORT,FORMAT_PORT,-
		<No Path-Block During Virtual Circuit Close - REMOTE PORT xxx>
	$OPA0_LOG	PKT,ERRDG,M_RPORT,FORMAT_PORT,-
		<HSC Error Logging Datagram Received - REMOTE PORT xxx>
	$OPA0_LOG	PKT,RSCKS,M_ALWAYS+M_RPORT,FORMAT_PORT,-
		<Remote System Conflicts with Known System - REMOTE PORT xxx>
	$OPA0_LOG	CBL,0GB,M_RPORT,FORMAT_PORT,-
		<Path #0. Has gone from GOOD to BAD - REMOTE PORT xxx>
	$OPA0_LOG	CBL,1GB,M_RPORT,FORMAT_PORT,-
		<Path #1. Has gone from GOOD to BAD - REMOTE PORT xxx>
	$OPA0_LOG	CBL,0BG,M_RPORT,FORMAT_PORT,-
		<Path #0. Has gone from BAD to GOOD - REMOTE PORT xxx>
	$OPA0_LOG	CBL,1BG,M_RPORT,FORMAT_PORT,-
		<Path #1. Has gone from BAD to GOOD - REMOTE PORT xxx>
	$OPA0_LOG	CBL,UC,M_RPORT,FORMAT_PORT,-
		<Cables have gone from UNCROSSED to CROSSED - REMOTE PORT xxx>
	$OPA0_LOG	CBL,CU,M_RPORT,FORMAT_PORT,-
		<Cables have gone from CROSSED to UNCROSSED - REMOTE PORT xxx>
	$OPA0_LOG	CBL,L0GB,M_ALWAYS,,-
		<Path #0. Loopback has gone from GOOD to BAD>
	$OPA0_LOG	CBL,L1GB,M_ALWAYS,,-
		<Path #1. Loopback has gone from GOOD to BAD>
	$OPA0_LOG	CBL,L0BG,M_ALWAYS,,-
		<Path #0. Loopback has gone from BAD to GOOD>
	$OPA0_LOG	CBL,L1BG,M_ALWAYS,,-
		<Path #1. Loopback has gone from BAD to GOOD>
	$OPA0_LOG	CBL,L0BX,M_RPORT,FORMAT_PORT,-
		<Path #0. Has become working but CROSSED to Path #1. - REMOTE PORT xxx>
	$OPA0_LOG	CBL,L1BX,M_RPORT,FORMAT_PORT,-
		<Path #1. Has become working but CROSSED to Path #0. - REMOTE PORT xxx>
	$OPA0_LOG

	.SBTTL	ERR$CRASHVC,		CRASH VC ON SPECIFIED
	.SBTTL	-			PATH BLOCK

;+
; These routines are called to crash an open virtual circuit on
; a specific path.  ERR$CRASHVC sets VC failure in progress
; status in the PB and does a SETCKT closed to the remote port.  Return
; is then taken since the SETCKT response will continue the process of
; cleaning up the broken VC.
;
; In case the response pkt is a REQID or other datagram type pkt,
; there may be no path block.  In this case, return is taken without
; doing anything.
;
; Inputs:
;
;	IPL			-Fork IPL
;	R1			-Addr of PB
;	R2			-Addr of msg/dg response
;	R4			-PDT addr
;
;	VC state		-open
;
;
; Outputs:
;
;	R0-R1			-Destroyed
;	Other registers		-Preserved;  in particular, the msg/dg
;				 pointed to by R2 is not disposed of --
;				 that is the caller's responsibility
;-

	.ENABL	LSB

ERR$CRASHVC::

	TSTL	R1			; Got a valid path block?
	BEQL	20$			; No, just leave
	PUSHL	R2			; Save caller's R2
	CMPW	PB$W_STATE(R1),-	; Is virtual circuit failure
		#PB$C_VC_FAIL		;  already in progress?
	BEQL	10$			; Branch if so
	MOVW	#PB$C_VC_FAIL,-		; Set VC failure in progress
		PB$W_STATE(R1)		;  on this PB
	MOVL	PB$L_CLSCKT_DG(R1),R2	; Get addr of SETCKT dg in PB
	CLRL	PB$L_CLSCKT_DG(R1)	; Zero dg address to show that port
					;  owns pkt now
	BISL3	#<PPD$M_RSP@24>!-	; Tell port to mark VC closed
		 <PPD$C_SETCKT@16>,-
		PB$B_RSTATION(R1),-	;  to this remote station
		PPD$B_PORT(R2)		; Do SETCKT at top priority
	MOVZWL	#PPD$M_CST,PPD$W_MASK(R2) ;  to close VC
	CLRL	PPD$W_M_VAL(R2)		; Get response to reclaim buffer
	MOVB	#PPD$M_DISPOSE,-
		PPD$B_SWFLAG(R2)	; Ask interrupt serv to notify us
	BSBW	INT$INS_COMQH		; Do it
10$:	POPL	R2			; Restore caller's R2
20$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	ERR$CRASH_PORT,		INIT PORT CRASH

;+
; ERR$CRASH_PORT is called by the driver at fork IPL detecting an error
; which might be either a software error or a port hardware or firmware error.
;
; Action is to maintenance init the port to prevent further activity,
; and, if there are any error retries left, to call ERR$PWF_RECOV
; in simulation of a power fail recovery.  If no retries are left,
; then PUP is cleared in PDT$W_LPORT_STS to prevent the port from being
; reinitialized.  ERR$PWF_RECOV initiates a fork process on the UCB
; which takes care of notifying SYSAPs and cleaning up the configuration
; database eventually.  The main difference between deliberately crashing
; the port and a real power failure is that in the crash case, cached
; packets are not written to the logout area by the port and hence may not
; be reclaimed.
;
; Inputs:
;
;	R4			-PDT addr
;
;	(SP)			-Caller's PC
;
; Outputs:
;
;	R0,R1			-Destroyed
;
;	Other registers		-Preserved
;-

	.ENABL	LSB

ERR$CRASH_PORT::

	BBSS	#PDT$V_PWF_CLNUP,-	; Set PWF cleanup in progress
		PDT$W_LPORT_STS(R4),20$	;  Branch if set already
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	#PA_PMC_M_MIN,-		; Maintenance init the port
		@PDT$L_PMC(R4)		;
	MOVL	PDT$L_UCB0(R4),R5	; Get UCB addr
	BICW	#UCB$M_ONLINE,-		; Set unit offline to show init
		UCB$W_STS(R5)		;  in progress
	MOVZWL	#SS$_ABORT,R1		; Assume we have more retries,
					;  but let SYSAP know not to
					;  expect cached entries back
	DECB	UCB$B_ERTCNT(R5)	; Decr retry count
	BGEQ	10$			; Branch if not out of retries
	MOVZWL	#SS$_CTRLERR,R1		; Else set aux status to tell
					;  SYSAP's port won't return

10$:	DSBINT	UCB$B_DIPL(R5)		; Set IPL up to device to block 
					;  interrupts
	BSBW	ERR$PWF_RECOV		; Treat like power failure from here on
	ENBINT				; Restore IPL to fork IPL
	POPR	#^M<R2,R3,R4,R5>	; Restore registers

20$:	RSB				; Return to caller

	.DSABL	LSB

	.SBTTL	ERR$PWF_RECOV,		NOTIFY SYSAPS WITH 
	.SBTTL	-			CONNECTIONS ON POWER
	.SBTTL	-			FAILED PORT

;+
; ERR$PWF_RECOV is called by unit initialization on power fail
; recovery or by port interrupt service on power down or by ERR$CRASH_PORT.
; ERR$PWF_RECOV first checks for packet queues that might be corrupted
; and for corrupted queues zeros the queue header, thus preventing
; future attempts to remove entries for the queue and causing bugchecks.
; ERR$PWF_RECOV then forks to lower IPL to the SCS syncronization
; level.  Next, all formative path blocks on this PDT (i.e., START
; handshakes in progress) are looked up and formative PB's and SB's are
; deallocated to pool.
;
; ERR$PWF_RECOV then calls CNF$LKP_PB_PDT to look up PB's associated with 
; the failed PDT.  CNF$LKP_PB_PDT calls us back as a coroutine for each
; PB found.  For each PB, the CDT list is searched and, for each open CDT,
; the SYSAP error address is called with appropriate status.  SYSAP 
; DISCONNECTs issued as a result of error routines being called continue 
; the failure process.  (See routine ERR$DISC_PWFAIL for more info.)
;
; CDT's in non-open states are handled the same as described in ERR$VCCLOSED_MSG.
;
; There is a difference between connection cleanup following a VC failure
; and connection cleanup following a port failure.  In the VC failure case,
; the port is still alive.  As sysap's with connections on the broken vc
; are notified and issue disconnects, CDT's are retained in the PB CDT list.
; They are retained because queued traffic may still be in the port which will
; be completing with appropriate status.  The CDT's are cleaned up after the
; last one is disconnected and after the cache clear msg has made it through
; the port.
;
; If the vc is breaking bacause of a port failure, the port is dead and
; no further traffic will be processed.  In this case, as sysap's disconnect,
; CDT's are cleaned up immediately.  (Implementation note:  this logic
; might be simplified overall by handling the simpler port crash case
; like the more comples vc failure case.  The two cases probably need to
; differ only in their dependency on the cache clear msg.)
;
; Given the difference in handling, a problem occurs if a port crash
; happens in the midst of a vc failure.  The port crash always results in 
; a call to ERR$PWF_RECOV which forks prior to processing all the path
; blocks.  Consequently, the code which notifies all sysap's in the
; event of a vc failures is not interrupted by the code in ERR$PWF_RECOV
; which processes PB's.  When we arrive at the point of processing each
; PB, we are in one of two situations if the PB is in VC_FAIL state:
;
;	-All CDT'sa re in VC_FAIL state also, and a cache clear has
;	 been issued which we have just cleaned up of one of the queues.
;
;	-Some CDT's are in VC_FAIL.  Sysap's have all been notified
;	 about the rest of the connections, but have not yet disconnected.
;
; So, if the PB is already in VC_FAIL state, CDT's in VC_FAIL state are
; closed out after completing the pending disconnect calls.  If no CDT's
; remain after this, PB (and SB) are also deleted and port reinit may
; be attempted.  If some CDT's remain,then place the PB in the PWR_FAIL
; state so that the remaining disconnects behave properly (like a port
; failure rather than a vc failure.)
;
; Inputs:
;
;	IPL			-IPL$_POWER, device IPL
;	
;	R1			-Aux status to report to SYSAP:
;				 
;				 SS$_POWERFAIL if called by unit init
;				 following CPU pwr fail recovery;
;
;				 SS$_POWERFAIL if called by int service
;				 on port pwr down;
;
;				 SS$_ABORT if called by int service or 
;				 ERR$CRASH_PORT with error necessitating
;				 reinit of port (buffers cached by port lost);
;
;				 SS$_CTRLERR if called by int service or
;				 ERR$CRASH_PORT with error necessitating
;				 reinit of port, but no retries are left
;				 so that the port will remain shutdown
;				 (buffers cached by port lost).
;
;	R5			-UCB 0 addr
;
;	Port state		-Uninitialized/maint;  PDT/PQB 
;				 logout area contains a list of
;				 port cached entries.
;
;	PDT$W_LPORT_STS		-PWF_CLNUP set to show powerfail
;				 cleanup in progress.
;				 PUP set if called from system 
;				 powerfail recovery to show power up.
;				 PUP clear if called from port interrupt
;				 on power down to show power not
;				 recovered yet.
;
;	(SP)			-Return to caller in unit initialization
;				 or interrupt service.
;
; Outputs:
;
;	IPL			-IPL --> IPL$_SCS and return taken to
;				 unit init;  The unit is set offline
;				 and registers preserved on return to
;				 unit init.
;-

	.ENABL	LSB

ERR$PWF_RECOV::

	BICW	#UCB$M_ONLINE,-		; Set unit offline to show
		UCB$W_STS(R5)		;  that it's uninitialized

	MOVL	UCB$L_PDT(R5),R4	; Get PDT addr
	MOVAL	PDT$Q_COMQBASE(R4),R3	; Get addr of 1st command queue hdr
	CLRL	R2			; Zero count of command + rsp queues

10$:
	BSBW	UNLOCK_BADQ		; Unlock and handle bad queue
	ADDL	#8,R3			; Step to next queue hdr
	AOBLEQ	#<<PDT$Q_RSPQ - PDT$Q_COMQBASE>/8>,-
		R2,10$			; Branch if more queues to check
	MOVL	PDT$L_MFQHDR(R4),R3	; Get addr of free msg queue hdr
	BSBW	UNLOCK_BADQ		; Check it
	MOVL	PDT$L_DFQHDR(R4),R3	; Get addr of free dg queue hdr
	BSBW	UNLOCK_BADQ		; Check it

	MOVL	R1,R4			; Copy aux status to reg preserved
					; that will be reserved over fork
	MOVAB	15$,R3			; Address of where to resume after fork
	BRW	INI$FORK		; Fork...

;
; Clean up formative path and system blocks on this PDT. From this point on
; we are at fork IPL.
;

15$:	MOVL	UCB$L_PDT(R5),R4	; Restore PDT address
	MOVAQ	PDT$Q_FORMPB(R4),R2	; Get addr of formative PB 
					;  listhead
	MOVL	(R2),R3			; Get next formative PB
	
20$:	CMPL	R3,R2			; Back at listhead?
	BEQL	50$			; Branch if so
	MOVL	PB$L_SBLINK(R3),R0	; Else get formative SB
	BEQL	30$			; Branch if no SB
	JSB	G^COM$DRVDEALMEM	; Else deallocate SB to pool

30$:	BBCC	PB$B_RSTATION(R3),-	; Turn off known port bit in
		PDT$B_PORTMAP(R4),40$	;  bitmap
40$:	MOVL	R3,R0			; Copy PB addr for deallocator
	MOVL	(R3),R3			; Get address of next formative PB
	JSB	G^COM$DRVDEALMEM	; Deallocate PB to pool
	BRB	20$			; Go for next formative PB

50$:	MOVL	R2,(R2)			; Set formative pathblock
	MOVL	R2,4(R2)		;  to empty

;
; Remove all packets from port command queues, response queue,
; free queues, and the logout area.  All packets are returned to
; pool except send datagrams which are flagged 'return to sysap.'
; These are returned to the SYSAP just as if they had gone out 
; normally.
;

	BSBW	ERR$CLEANUP_PKT		; Call packet cleanup routine

;
; Clean up fully open paths and system blocks on this PDT:
;

	BSBW	CNF$LKP_PB_PDT		; Look up 1st/next PB
					; Start of coroutine if PB found:
	BLBC	R0,115$			; Branch if no more PB's
	CMPW	#PB$C_VC_FAIL,-		; Is PB already cleaning up a 
		PB$W_STATE(R3)		;  vc failure?
	BNEQ	100$			; Branch if not

60$:	MOVAL	PB$L_CDTLST-CDT$L_CDTLST(R3),R0
					; Else set to scan all CDT's on PB

70$:	MOVL	CDT$L_CDTLST(R0),R0	; Get next CDT

80$:	BEQL	90$			; Branch if no more
	CMPW	CDT$W_STATE(R0),-	; SYSAP finished with connection?
		#CDT$C_VC_FAIL		;  (I.e., disconnect issued?)
	BNEQ	70$			; Branch if not
	PUSHL	CDT$L_CDTLST(R0)	; Save pointer to next CDT
	PUSHL	R3			; Save PB addr
	MOVL	R0,R3			; Put current CDT addr in standard reg
	MOVZWL	#SS$_NORMAL,R0		; Set status = success
	BSBW	SCS$CLOSE_CDT		; Complete SYSAP's pending disconnect
					;  call and deallocate CDT
	POPL	R3			; Retreive PB address
	POPL	R0			;  and addr of following CDT
	BRB	80$			; Process next CDT, if any

90$:	MOVW	#PB$C_PWR_FAIL,-	; Change PB state to power fail
		PB$W_STATE(R3)		;  recovery/port failure in progress
	TSTL	PB$L_CDTLST(R3)		; All CDT's gone?
	BEQL	110$			; Branch if so
	RSB				; Else done -- remaining CDT's
					;  will be cleaned up via disconnect calls

100$:	MOVW	#PB$C_PWR_FAIL,-	; Set PB state to pwr fail
		PB$W_STATE(R3)		;  in progress
	TSTL	PB$L_CDTLST(R3)		; Does this PB have any connections?
	BNEQ	120$			; Branch if so

110$:	BSBW	CNF$REMOVE_PB		; Else kill of this PB

115$:	TSTW	PDT$W_PBCOUNT(R4)	; Any PB's left on this PDT?
	BNEQ	130$			; Branch if so, can't clean up port
	BSBW	ERR$INIPORT		; Try port hardware init
	RSB				; Continue PB search

120$:	MOVZWL	UCB$L_FR4(R5),R0	; Set status info for SYSAP err routine
	BSBW	SCS$NOTIFY_SYSAP	; Handle all CDT's in list

130$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	UNLOCK_BADQ,		ZERO CORRUPTED QUEUE HDRS

;+
; UNLOCK_BADQ tests the interlock bit on the queue pointed to by
; R3.  If the queue is locked, it is presumed corrupted and the header
; zeroed so that any entries that should be in the queue are permanently
; lost.  The interlock bit should never be set in a power fail situation.
; If it is, the auxiliary status in R1 is changed from SS$_POWERFAIL to
; SS$_ABORT.  If the queue is not locked, then return is taken without
; altering anything -- the queue is purged later by ERR$CLEANUP_PKT.
;
; Inputs:
;
;	R1			-Aux status to pass to SYSAPs
;	R3			-Addr of queue header to check
;
; Outputs:
;
;	All registers		-Preserved
;-

UNLOCK_BADQ:

	BBC	#0,(R3),Q_UNLOCKED	; Branch if queue unlocked
	CLRQ	(R3)			; Else clear header
	CMPW	R1,#SS$_POWERFAIL	; Is this power failure?
	BNEQ	Q_UNLOCKED		; Branch if not
	MOVZWL	#SS$_ABORT,R1		; Else change status to show
					;  SYSAPs that pkts are lost

Q_UNLOCKED:

	RSB				; Return


	.DSABL	LSB

	.SBTTL	ERR$DISC_PWFAIL,	PROCESS DISCONNECT CALL
	.SBTTL	-			FOR CDT ON POWER 
	.SBTTL	-			FAILED PORT

;+
; ERR$DISC_PWFAIL is called by FPC$DCONNECT when the SYSAP issues
; a DISCONNECT for a connection associated with a power failed port.
; (Path block state = PB$C_PWR_FAIL.)  In this case the local
; port is nonfunctional and action is to deallocate CDTs as they
; are DISCONNECTed after purging out the command queues of any SEND's
; the SYSAP may have done since being notified at its error entry.
;
; If this is the last CDT on this path block, the path block (and
; system block) is removed and an attempt made to reinit the
; port hardware.
;
; Inputs:
;
;	IPL			-Fork IPL
;	
;	R1			-Addr of PB
;	R3			-Addr of CDT being DISCONNECTed
;	R4			-Addr of PDT
;
;	CDT$W_STATE		-Any except CLOSED or VC_FAIL
;
;	(SP)			-Addr of return to FPC$DCONNECT
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

ERR$DISC_PWFAIL::

	PUSHL	R1			; Save PB addr
	CMPW	CDT$W_STATE(R3),-	; Is this a listener with a
		#CDT$C_CON_REC		;  connect in hand?
	BNEQ	10$			; Branch if not
	BSBW	SCS$FREE_LISTEN		; Else just put it back to listening
	BRB	20$			; Join common check for no more CDT's

10$:	PUSHL	R3			; Save CDT addr
	BSBW	ERR$CLEANUP_PKT		; Purge out the command queues
					;  again in case SYSAP error routine
					;  did any more SENDs
	POPL	R3			; Restore CDT addr
	BSBW	SCS$DEAL_SCSREC		; Deallocate CDT's SCS recv buffer
	JSB	G^SCS$DEALL_CDT		; Deallocate CDT

20$:	POPL	R3			; Retrieve PB addr in R3
	TSTL	PB$L_CDTLST(R3)		; Any CDT's left on PB?
	BNEQ	30$			; Branch if so
	BSBW	CNF$REMOVE_PB		; Else deallocate PB/SB
	TSTW	PDT$W_PBCOUNT(R4)	; Any PB's left on this PDT?
	BNEQ	30$			; Branch if some left
	BSBW	ERR$INIPORT		; Try to init port hardware now

30$:	MOVZWL	#SS$_NORMAL,R0		; Set to return success to SYSAP
	RSB				;

	.DSABL	LSB

	.SBTTL	ERR$CLEANUP_PKT		CLEAN UP PACKETS QUEUED TO
	.SBTTL	-			PORT AND IN LOGOUT AREA

;+
; ERR$CLEANUP_PKT calls FLUSH_Q to remove and dispose of packets currently
; on each of the port queues.  It hen extracts each packet address
; recorded in the logout area and calls ERR$DISP_ENTRY to dispose of the
; entry.  The rule for disposing of packets is to return all packets
; to pool except send datagrams flagged as 'return to sysap.'  These
; are returned to the SYSAP.
;
; Inputs:
;
;	R4			-PDT addr
;
; Outputs:
;
;	R0-R3			-Destroyed
;-

ASSUME	PDT$Q_COMQBASE	EQ  PDT$Q_COMQL
ASSUME	PDT$Q_COMQL+8	EQ  PDT$Q_COMQH
ASSUME	PDT$Q_COMQH+8 	EQ  PDT$Q_COMQ2
ASSUME	PDT$Q_COMQ2+8	EQ  PDT$Q_COMQ3
ASSUME	PDT$Q_COMQ3+8	EQ  PDT$Q_RSPQ

	.ENABL	LSB

ERR$CLEANUP_PKT::

	MOVAL	PDT$Q_COMQBASE(R4),R1	; Get adr of 1st command queue
	MOVL	#<<PDT$Q_RSPQ - PDT$Q_COMQBASE>/8 + 1>,R3
					; Get count of command/rsp queues

10$:	BSBB	FLUSH_Q			; Purge next queue of all entries
	ADDL	#8,R1			; Step to next queue to flush
	SOBGTR	R3,10$			; Branch if more queues
	MOVL	PDT$L_MFQHDR(R4),R1	; Get addr of msg free queue header
	BSBB	FLUSH_Q			; Purge all entries
	MOVL	PDT$L_DFQHDR(R4),R1	; Get addr of dg free queue header
	BSBB	FLUSH_Q			; Purge all entries
	MOVAL	PDT$L_DQELOGOUT(R4),R3	; Get base of logout area
	MOVL	#<<PDT$C_PALENGTH - PDT$L_DQELOGOUT>/4>,R1
					; Get count of elmts in logout area

20$:	MOVL	(R3)+,R2		; Get addr of next entry
	CMPL	R2,#-1			; Port record anything here?
	BEQL	30$			; Branch if not
	BSBW	ERR$DISP_ENTRY		; Else dispose of entry
	MCOML	#0,-4(R3)		; Reset entry just processed

30$:	SOBGTR	R1,20$			; Branch if more entries in logout area
	RSB				; Return

	.DSABL	LSB



	.SBTTL	FLUSH_Q			REMOVE AND DISPOSE OF
	.SBTTL	-			ALL QUEUED ENTRIES
	.SBTTL	ERR$DISP_ENTRY		DISPOSE OF A SINGLE ENTRY

;+
; FLUSH_Q removes and processes all entries from a specified port queue.
;
; ERR$DISP_ENTRY processes a removed entry.  All packets are returned to
; pool except send datagrams flagged 'return to sysap.'  These are 
; handled exactly as if they had gone out successfully.
;
; Inputs:
;
;	IPL			-Fork IPL
;	R1			-Addr of queue header (FLUSH_Q)
;	R2			-Pkt addr (ERR$DISP_ENTRY)
;
; Outputs:
;
;	R0			-Destroyed
;	R2			-Destroyed (FLUSH_Q)
;	Other registers 	-Preserved
;

	.ENABL	LSB

FLUSH_Q:

	$QRETRY	 REMQHI (R1),R2,-	; Remove next entry from 
		 ERROR=FATALQ		;  queue head
	BVS	10$			; Branch if no more entries
	BSBB	ERR$DISP_ENTRY		; Else dispose of entry
	BRB	FLUSH_Q			; Go for another entry
	
10$:	RSB				; Return



ERR$DISP_ENTRY::

	BBC	#PPD$V_RSP,-		; Anybody expecting pkt?
		PPD$B_FLAGS(R2),20$	;  Branch if not
	CMPB	PPD$B_OPC(R2),-		; Was it a send datagram?
		#PPD$C_SNDDG		;
	BNEQ	20$			; Branch if not
	PUSHR	#^M<R1,R2,R3,R5>	; Save registers 
	BSBW	INT$DISP_SENDDG		; Else handle as interrupt
	POPR	#^M<R1,R2,R3,R5>	; Restore destroyed registers
	RSB				; Return

20$:	BSBW	INT$DEAL_PKT		; Return to pool
	RSB				; Return

FATALQ:					; Should never get here since
					;  queue lock cleared by UNLOCK_BADQ
	BUGCHECK  CIPORT,NONFATAL	; Nonfatal bugcheck

	CLRQ	(R1)			; If survive bugcheck, clear queue 
					;  header
	TSTL	(SP)+			; Clear return from error call
	RSB				; Return from FLUSH_Q

	.DSABL	LSB

	.SBTTL	ERR$INIPORT,		CALL PORT HARDWARE INIT

;+
; If port has power now, call port initialization routine in PAINIT.
;
; Inputs:
;
;	R4			-PDT address
;	IPL			-IPL$_SCS 
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers 	-Preserved
;-

	.DSABL	LSB

ERR$INIPORT::

	BICW	#PDT$M_PWF_CLNUP,-	; Show power fail cleanup
		PDT$W_LPORT_STS(R4)	;  bookkeeping done
	BBC	#PDT$V_PUP,-		; Has port got power now?
		PDT$W_LPORT_STS(R4),20$	;  Branch if not
	MOVQ	R4,-(SP)		; Save PDT addr and R5{
	MOVL	PDT$L_UCB0(R4),R5	; Get UCB addr for init
	BBS	#UCB$V_ONLINE,-		; If controller-unit already
		UCB$W_STS(R5),10$	;  initialized, branch
	MOVL	PDT$L_CNF(R4),R4	; Get config register addr
	MOVL	#PA_PMC_M_MIN,-		; Place port in un-initialized state
		PA_PMC(R4)		; and disable device interrupts
	BSBW	INI$PORT		; Call port initialization

10$:	MOVQ	(SP)+,R4		; Restore our registers
	
20$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	ERR$BUGCHECK,		RECORD PORT LOCAL STORE 
	.SBTTL	-			IN MEMORY
	.SBTTL	ERR$BUGCHECKNF,		RECORD LOCAL STORE CONDITIONALLY
	.SBTTL	-			IF NONFATAL BUGCHECKS ARE FATAL

;+
; This routine copies the port local store (device registers, VC
; descriptor table, transalation cache, work space, etc.) over the
; microcode in pool so that this info will be available in a dump.
;
; Inputs:
;
;	R4			-PDT addr
;
; Outputs:
;
;	All registers		-Preserved
;-

ASSUME	<^X1000>  LE  PA_C_WCSSIZ*6

	.ENABL	LSB

ERR$BUGCHECKNF::

	BBS	#EXE$V_FATAL_BUG,-	; Branch if nonfatal bugchecks
		G^EXE$GL_DEFFLAGS,-	;  are set to be fatal via
		ERR$BUGCHECK		;  SYSGEN parameter
	$DEBUGCHECK #ERR$V_DEB_BUGNF	; If flag enabled, do a fatal bugcheck
					;  anyway regardless of SYSGEN param
	RSB				; Else return doing nothing

ERR$BUGCHECK::

	PUSHR	#^M<R0,R1,R2,R3>	; Save caller's registers
	MOVL	PDT$L_CNF(R4),R2	; Get addr of base of device registers
	
10$:	MOVL	G^SCS$GL_MCADR,R3	; Get addr of ucode in pool
	MOVZWL	#<^X1000/4>,R1		; Get size of device register space
	
20$:	MOVL	(R2)+,(R3)+		; Copy next long wd of local store
	SOBGTR	R1,20$			; Branch if more to copy
	POPR	#^M<R0,R1,R2,R3>

	RSB

	.DSABL	LSB

	.SBTTL	ERR$DEBUGCHECK,		DEBUG BUGCHECK ENABLE FLAGS

;+
; For the ourpose of tracing intermittant problems that we normally
; attempt recovery from, a number of CIPORT bugchecks have been added.
; Each bugcheck is enabled or disabled by a separate flag.  Flags
; may be turned on or off by a quick patch to location ERR$DEBUGCHECK.
;-

;
; Flags are stored in the following longword:
;

ERR$DEBUGCHECK::

	.LONG	^X0			; The default is all bugchecks
					;  are disabled, and recovery enabled


;
; Flag definitions by bit number:
;

ERR$V_DEB_INVBN	== 0			; Invalid buffer name during blk
					;  xfer -- normally crashes port

ERR$V_DEB_BLV	== 1			; Local buffer length violation --
					;  normally crashes port

ERR$V_DEB_ACCV	== 2			; Access violation during blk
					;  xfer -- normally crashes port

ERR$V_DEB_PSV	== 3			; Packet size violation --
					;  normally crashes port

ERR$V_DEB_URP 	== 5			; Unrecognized packet --
					;  normally logged and discarded

ERR$V_DEB_INVDP	== 6			; Invalid destination port number --
					;  normally crashes port

ERR$V_DEB_URC	== 7			; Unrecognized local command --
					;  normally crashes port

ERR$V_DEB_ABO	== 8			; Aborted command (port disabled) --
					;  normally crashes port

ERR$V_DEB_NPUPD	== 9			; No path + SNDMSG + unrecognized
					;  PPD type -- normally crashes port

ERR$V_DEB_VCUPD	==10			; VC closed + SNDMSG + unrecognized
					;  PPD type -- normally crashes port

ERR$V_DEB_INVOP	==11			; Invalid opcode in response --
					;  normally crashes port

ERR$V_DEB_UNSTS	==12			; Undefined status subtype in response --
					;  normally crashes port

ERR$V_DEB_NOSTS	==13			; Unrecognized combination of status,
					;  opcode, and PPD type -- 
					;  normally crashes port
ERR$V_DEB_XCTER	==14			; XCT_ID sequence number check fails
					;  on DATREC/CNFREC.  Normally crashes
					;  port
ERR$V_DEB_SCERR	==15			; Source connection ID check fails --
					;  normally crashes port on MSGSNT
					;  and is ignored on DGSNT
ERR$V_DEB_NOPB	==16			; Rec'd connect request with no PB --
					;  normally crashes port

ERR$V_DEB_CNFER	==17			; Entered VC cleanup with no PB --
					;  normally crashes port

ERR$V_DEB_ILKQ	==18			; Interlock queue failure --
					;  normally crashes port

ERR$V_DEB_NEPQ	==19			; Reiniting port with non empty
					;  command/response queues --
					;  normally logged and recovered
ERR$V_DEB_BUGNF	==20			; Nonfatal bugcheck being logged --
					;  normally continues

ERR$V_DEB_PSRX  ==21			; Undefined bits in PSR set --
					;  normally crashes port

ERR$V_DEB_OSEQ	==22			; Port received response with 
					;  sequence number mismatch.  This
					;  is either a legitimate discard
					;  due to duplicate, or a sequence
					;  number error.  Software normally
					;  crashes the vc.

ERR$V_DEB_VCDCL	==23			; Port received sequenced message
					;  with VCD status set to closed.
					;  Software normally crashes the 
					;  vc.

ERR$V_DEB_MFQE ==24			; Port detected msg free queue
					;  empty.
					;  Normally, port crashes.



	.SBTTL	ELOG$INIT_SWERR,	LOG SOFTWARE ERROR 
	.SBTTL	-			ENCOUNTERED DURING 
	.SBTTL	-			PORT INITIALIZATION
	.SBTTL	ELOG$UCODE_NORD,	LOG MICROCODE NOT 
	.SBTTL	-			PROPERLY READ BACK 
	.SBTTL	-			ERROR
	.SBTTL	ELOG$HARDWARE,		LOG HARDWARE ERROR
	.SBTTL	ELOG$Q_INTRLOCK,	LOG QUEUE INTERLOCK 
	.SBTTL	-			FAILURE

;+
; These routines log those errors which use the device attention, EMB$C_DA, 
; error-log-entry format.  There are three such error types:
;	- Software errors detected during port initialization.
;	- Microcode failed to read-back as loaded (this is logged as a special 
;	  type hardware error).
;	- CPU or port ucode not at adequate rev level.
;	- Hardware error (typical to but more extensive than those found
;	  in more standard I/O devices).
;	- Failures to obtain access to a queue because of its interlock.
;
; After some entry specific processing, the body of this routine calls OPA0_LOG
; to broadcast the error to _OPA0, if indicated, and then uses ERL$DEVICEATTN 
; to log the error.  ERL$DEVICEATTN will call ELOG$REGDUMP which will actually 
; copy the appropriate information into the error log.
;
;
; ELOG$INIT_SWERR:
;
; Inputs:
;	R0		- Error subtype code in bits 0 through 7
;			  Sign bit set indicates that the error will crash port
;			  Sign bit not set indicates that it will not
;	R5		- Address of device UCB
;
;
; ELOG$UCODE_NORD:
;
; Inputs:
;	R0		- Correct microcode value
;	R4		- Base virtual address of CI port registers
;	R5		- Address of device UCB
;
;
; ELOG$CPU_REV:
;
; Inputs:
;	R1		-System ID Register which contains CPU rev level
;	R5		-UCB addr
;
; ELOG$UCODE_ERR, ELOG$UCODE_WARN:
;
; Inputs:		
;	R2		-Addr of IDREC pkt containing port ucode rev
;			 level at offset PPD$L_RPORT_REV
;	R5		-UCB addr
;
; ELOG$HARDWARE:
;
; Inputs:
;	R0		- Error subtype code in bits 0 through 7
;			  Sign bit set indicates that the error will crash port
;			  Sign bit not set indicates that it will not
;	R4		- Base virtual address of CI port registers
;	R5		- Address of device UCB
;
;
; ELOG$Q_INTRLOCK:
;
; Inputs:
;	R0		- Error subtype code in bits 0 through 7
;			  Sign bit set indicates that the error will crash port
;			  Sign bit not set indicates that it will not
;	R4		- Address of PDT
;
;
; ALL ROUTINES:
;
; Outputs:
;	R0 is destroyed.  All other registers are preserved.  An entry is made 
;	in the error log. The existance of this error might have been broadcast
;	to _OPA0.
;
;
; SPECIAL NOTES:
;
;   Proper operation of this routine, and ELOG$REGDUMP, depends upon 
;   ERL$DEVICEATTN passing R4 and R5 unaltered to ELOG$REGDUMP.  As of this 
;   routines writing, this was the case.
;-

;+
; The following are various values related to or controlling the size of a 
; device attention error log entry for this device.
;-

PORT_REGS_LOGGED = 6			; Number of port registers logged
NUM_EX_LONGWORDS = 3			; Number of extra longwords logged
TOTAL_LONGWORDS  =  2 -			; Longword count + error type code
		  + PORT_REGS_LOGGED -	; + port registers
		  + NUM_EX_LONGWORDS	; + extra longwords

ELOG$K_BYTES == <TOTAL_LONGWORDS * 4> -	; This is the number of bytes in a
		+ EMB$L_DV_REGSAV	; device attention error log entry 
					; from the CI as entered in the DDT.

	.MACRO	ZERO_EXTRA_LONGWORDS
	ASSUME	NUM_EX_LONGWORDS EQ 3
	CLRQ	-(SP)
	CLRL	-(SP)
	.ENDM	ZERO_EXTRA_LONGWORDS

DA_MASK = ^M<R1,R2,R3,R4,R5>

ELOG$INIT_SWERR::			; Software error during initialization

	PUSHR	#DA_MASK		; Save registers.
	CLRL	R4			; Zero port base VA implying don't log 
					; port registers.
	ZERO_EXTRA_LONGWORDS		; No extra longword to log here.
	ASSUME	PAER$K_ET_INSW EQ 0
	CLRB	-(SP)			; Build error type part of error code.
	BRB	ELOG$$LOG_DA		; Branch to common code.


ELOG$UCODE_NORD::

	PUSHR	#DA_MASK		; Save registers.
	ASSUME	NUM_EX_LONGWORDS EQ 3
	PUSHL	R0			; Ex. lw. 3 = correct ucode value.
	CLRQ	-(SP)			; Init ex. lw. 1 & 2 to zero.
	MOVL	SP, R5			; Save current stack pointer.
	$PRTCTINI -			; Protect the following device register
		B^10$, #MCHK$M_NEXM	; references from machine checks.
	MOVL	PA_MDATR(R4),4(R5)	; Ex. lw. 2 = wrong   ucode value.
	MOVL	PA_MADR(R4),(R5)	; Ex. lw. 1 = failing ucode address.
	$PRTCTEND 10$			; If check occurs, leave zero values(s).
	MOVL	3*4+4*4(SP),R5 		; Restore previously saved UCB addr.
	CVTWL	#<PAER$K_ES_UCDW ! ^X8000>, -	; Plant error subtype
		R0 				; w/ crash port code.
	BRB	LOG_AS_HARDWARE		; Branch to common hardware error
					; logging code.

ELOG$CPU_REV::

	PUSHR	#DA_MASK		; Save registers
	ASSUME	NUM_EX_LONGWORDS EQ 3
	PUSHL	R1			; 1st extra longwd gets CPU SID
	CVTWL	#<PAER$K_ES_CPUREV ! ^X8000>,-
		R0			; Set error subtype, port shutting down
	BRB	REV_ERROR		; Join common rev error logging


ELOG$UCODE_ERR::

	PUSHR	#DA_MASK		; Save registers
	CVTWL	#<PAER$K_ES_REVER ! ^X8000>,-
		R0			; Set error subtype, port shuts down
	BRB	PORT_UCODE		; Join common port rev error logging


ELOG$UCODE_WARN::

	PUSHR	#DA_MASK		; Save registers
	MOVZBL	#PAER$K_ES_REVCA,R0	; Set error subtype, non fatal to port
	
PORT_UCODE:

	ASSUME	NUM_EX_LONGWORDS EQ 3
	PUSHL	PPD$L_RPORT_REV(R2)	; 1st extra longwd gets port rev level
	MOVL	(SP),UCB$T_OPA0_TEMP(R5) ; Save rev level to format in opa0 msg
	
REV_ERROR:

	CLRQ	-(SP)			; 2nd and 3rd longwds not used
	CLRL	R4			; Zero port CNF addr to avoid logging
					;  device registers
	BRB	LOG_AS_HARDWARE		; Join common HW type error logging

ELOG$HARDWARE::

	PUSHR	#DA_MASK		; Save registers.
	ZERO_EXTRA_LONGWORDS		; No extra longword to log here.
LOG_AS_HARDWARE:
	MOVB	#PAER$K_ET_HW, -(SP)	; Build error type part of error code.
	BRB	ELOG$$LOG_DA		; Branch to common code.


ELOG$INTRLOCK::

	PUSHR	#DA_MASK		; Save registers.
	MOVL	PDT$L_UCB0(R4), R5	; Obtain UCB address.
	MOVL	UCB$L_CRB(R5), R4	; Get base VA of port regieters via
	ASSUME	IDB$L_CSR EQ 0		; UCB ==> CRB ==> IDB ==> CSR.
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4), R4
	ZERO_EXTRA_LONGWORDS		; No extra longword to log here.
	MOVB	#PAER$K_ET_ILCK, -(SP)	; Build error type part of error code.
;	BRB	ELOG$$LOG_DA		; Branch to common code.

CLN_BYTES = <NUM_EX_LONGWORDS * 4> + 8	; Number of bytes to clean from stack

ELOG$$LOG_DA:

	TSTL	R0			; Is the port going to be crashed?
	BGEQ	10$			; Branch if no.  Otherwise,
	BISB	#PAER$M_CPRT, (SP)	; set the right bit in error code.
10$:	MOVB	R0, -(SP)		; Add error subtype to error code.
	CLRW	-(SP)			; Longword align the stack.
	MOVL	R4, -(SP)		; Save VA of port registers.

	CLRL	R0			; Clear register
	BICW3	#^X8000,6(SP),R0	; Retrieve error subtype and type
	MOVAB	DA_OPA0_LOG_TAB,R1	; Retrieve device attention _OPA0 table
	MOVL	R5,R3			; Move UCB address into proper register
	BSBW	OPA0_LOG		; Broadcast error to _OPA0 if indicated
	SUBL2	#UCB$L_MSGFKBLK,R5	; Compute UCB address 

	MOVL	SP, R4			; Set pointer needed by ELOG$REGDUMP.
	JSB	G^ERL$DEVICEATTN	; Perform actual error logging.
	MOVAB	CLN_BYTES(SP), SP	; Clean saved information from stack.
	POPR	#DA_MASK		; Restore saved registers
	RSB				; Return to caller.

	.SBTTL	ELOG$REGDUMP,		DEVICE ATTENTION 
	.SBTTL	-			REGISTER DUMP ROUTINE

;+
; This routine is called by ERL$DEVICEATTN (which is called by ELOG$$LOG_DA) 
; to copy the appropriate device registers into an error log entry.
;
; Inputs:
;	    R0		- Starting address in error log buffer to be filled
;	00(R4)		- Base virtual address of CI port registers
;	04(R4)		- filler word of zeros
;	06(R4)		- Error code type, crash port, subtype fields
;	08(R4) 		- NUM_EX_LONGWORDS of additional data to be logged
;	    R5		- Address of the device UCB
;
; Outputs:
;	CI port register values and the additional data are copied to the 
;	location(s) pointed to by R0.  R0, R1 and R2 are destroyed.  If for 
;	any reason the CI port registers are inaccessable, zeros will be 
;	logged for thier values.
;-


ELOG$REGDUMP::

	MOVL	R0, R2			; Copy buffer address to a safe place.
	MOVZBL	#<TOTAL_LONGWORDS - 1>, - ; Insert count of longword 
		(R2)+			  ; "registers" to be logged.
	MOVW	6(R4), (R2)+		; Insert error retry counts, type,
	MOVW	UCB$B_ERTCNT(R5), (R2)+	; subtype, and crash port information
	ASSUME	PORT_REGS_LOGGED EQ 6	; to form PADRIVER error code.
	CLRQ	  (R2)			; Zero places where CI port registers
	CLRQ	 8(R2)			; may be copied.
	CLRQ	16(R2)
	ASSUME	NUM_EX_LONGWORDS EQ 3
	MOVQ	 8(R4), 24(R2)		; Copy extra longwords into
	MOVL	16(R4), 32(R2)		; into error log entry.
	MOVL	(R4), R1		; Obtain base VA of CI port registers.
	BEQL	100$			; If zero, don't log registers.
	$PRTCTINI -			; Protect the following device register
		B^10$, MCHK$M_NEXM	; references from machine checks.
	MOVL	PA_CNF(R1),    (R2)	; Plant configuration register.
	MOVL	PA_PMC(R1),   4(R2)	; Plant maintenance control/status reg.
	MOVL	PA_PS(R1),    8(R2)	; Plant port status register.
	MOVL	PA_PFAR(R1), 12(R2)	; Plant failing address register.
	MOVL	PA_PESR(R1), 16(R2)	; Plant port error status register.
	MOVL	PA_PPR(R1),  20(R2)	; Plant port parameter register.
	$PRTCTEND 10$			; End protected code.
100$:	RSB				; Return to ERL$DEVICEATTN.

	.SBTTL	ELOG$PACKET,		LOG PACKET RELATED 
	.SBTTL	-			ERROR, GENERAL CASE
	.SBTTL	ELOG$CABLES,		LOG CABLE STATUS
	.SBTTL	-			CHNAGE, GENERAL CASE
	.SBTTL	ELOG$PTH_ST_CHG		LOG PATH STATUS 
	.SBTTL	-			CHANGE
	.SBTTL	ELOG$CBL_X_CHG		LOG CABLES CROSSED OR 
	.SBTTL	-			NOT CROSSED STATUS 
	.SBTTL	-			CHANGE
	.SBTTL	ELOG$ERROR_DG		LOG ERROR LOG DATAGRAM

;+
; These routines log those errors which use the logged message, EMB$C_LM, 
; error-log-entry format.  All such errors result from detection of an 
; exceptional condition in a data packet.  The error log entry produced by 
; these routines will include upto 72 bytes of the packet which signaled the 
; exceptional condition starting with the 12th byte of the packet. 
;
; There is one exceptional case, and that is when what is being logged is the 
; refusal of the local system to open up a virtual circuit to a remote system 
; because the information provided by the remote system conflicts with 
; information that is already present within the system-wide configuration 
; data base. In such a case what is logged instead of a data packet is the
; remote system node name, the known system nodename, and the known system ID.
;
; Before calling ERL$LOGMESSAGE to log the error condition, these routines call
; OPA0_LOG to log the condition to _OPA0, if such a broadcast is warrented.
;
; As a matter of convenience, there are four entry points to the routine, one 
; for each of the following conditions:
;	- A path status change (good to bad, or bad to good)
;	- A cables crossed/uncrossed status change
;	- All other errors detected with in a packet
;	- An error log datagram, specified by the PPD type = 5 (PPD$C_ELOG)
;	  These are used for sending an error log message to a system without
;	  necessarily having a connection to the system over which to send
;	  error log info.
;
; ELOG$PTH_ST_CHG:
;
; Inputs:
;	R0		- Address of previous path status information byte.
;			  In this byte:
;				PB$M_CUR_PS eq 0 ==> path was broken
;				PB$M_CUR_PS ne 0 ==> path was good
;			  The address is assumed to be one of PB$B_P0_STS(R1) 
;			  or PB$B_P1_STS(R1).  This information is used to 
;			  determine which path is being described.
;	R1		- PB address
;	R2		- Packet address
;	R4		- PDT address
;
;
; ELOG$CBL_X_CHG:
;
; Inputs:
;	R1		- 0 ==> cables currently crossed
;			  1 ==> cables currently uncrossed
;	R2		- Packet address
;	R3		- PB address
;	R4		- PDT address
;
;
; ELOG$PACKET: and ELOG$CABLES:
;
; Inputs:
;	R0		- Error subtype code in bits 0 through 7
;			  Sign bit set indicates that the error will crash port
;			  Sign bit not set indicates that it will not
;	R1		- PB address (ELOG$PACKET only)
;	R2		- Packet address (zero if none exists)
;	R4		- PDT address
;	R5		- Known system SB address
;			  (ELOG$PACKET and subtype = PAER$K_ES_RSCKS only)
;
; ELOG$ERROR_DG:
;
; Inputs:
;	R2		-Error log packet address
;	R3		-PB address
;	R4		-PDT address
;
; ALL ROUTINES:
;
; Outputs:
;	All other registers are preserved.  An entry is made in the error log.
;	The existance of this error might have been broadcast to _OPA0.
;-

LM_MASK = ^M<R0,R1,R2,R3,R4,R5>
SAVEDR5 = 4*5

ELOG$PTH_ST_CHG::			; Path status change

	PUSHR	#LM_MASK		; Save registers.
	ASSUME	PAER$K_ES_0GB EQ 0
	CLRL	R5			; Assume it went from good to bad.
	BLBS	(R0), 10$		; Branch if old status was good.
	MOVZBL	#PAER$K_ES_0BG, R5	; Else, it went from bad to good.
10$:	; Determine which path was effected by subtracting the address of the 
	; path 0 status byte from the address of the status byte passed to us.
	; Then add the good-to-bad or bad-to-good subtype code base to form
	; the error subtype code.
	ASSUME	PB$B_P1_STS EQ PB$B_P0_STS+1
	ASSUME	PAER$K_ES_1GB EQ PAER$K_ES_0GB+1
	ASSUME	PAER$K_ES_1BG EQ PAER$K_ES_0BG+1
	MOVAB	PB$B_P0_STS(R1), R3	; Get path 0 status byte address.
	SUBL	R3, R0			; Subtract from passed address.
	ADDL	R5, R0			; Add error subtype code base.
	BRB	LOG_AS_CHANGE		; Branch to common state change code.


ELOG$CBL_X_CHG::			; Cables crossed/uncrossed change

	PUSHR	#LM_MASK		; Save registers.
	ASSUME	PAER$K_ES_CU EQ PAER$K_ES_UC+1
	ASSUME	PB$M_CUR_CBL EQ 1
	ADDL3	#PAER$K_ES_UC, R1, R0	; Form change crossing subtype.
	MOVL	R3, R1			; Move PB address to right place.
LOG_AS_CHANGE:
	MOVZBL	#PAER$K_ET_CBL, R5	; Set cable status change error type.
	BRB	ELOG$$LOG_LM		; Branch to common code.


ELOG$CABLES::				; Cables change of state, general case

	.ENABL	LSB

	PUSHR	#LM_MASK		; Save registers.
	MOVZBL	#PAER$K_ET_CBL, R5	; Set cable status change error type.
	CLRL	R1			; Assume no PB
	TSTL	R2			; Is there a message?
	BEQL	10$			; Branch if no message.
	BSBW	CNF$LKP_PB_MSG		; Attempt to find path block.
	BRB	10$			; Join common code


ELOG$PACKET::				; Packet error, general case

	PUSHR	#LM_MASK		; Save registers.
	SUBL	PDT$L_MSGHDRSZ(R4),R2	; Back the pointer up
	BRB	5$

ELOG$PACKET1::				; Packet error, general case

	PUSHR	#LM_MASK		; Save registers.
5$:	MOVZBL	#PAER$K_ET_PKT, R5	; Set packet error type.
10$:	MOVL	(SP), R0		; Restore caller's error subtype.
	BRB	ELOG$$LOG_LM		; Go to common code.

	.DSABL	LSB


ELOG$ERROR_DG::				; Error log datagram to log

	PUSHR	#LM_MASK		; Save registers
	MOVZBL	#PAER$K_ES_ERRDG,R0	; Get error subtype
	MOVL	R3,R1			; Copy PB address
	MOVZBL	#PAER$K_ET_PKT,R5	; Get error type
	BRB	ELOG$$LOG_LM		; Join common code to set up
					;  error log entry and log it

;+
; At this point the registers have the following values:
;
;	R0	- Error subtype code in bits 0 through 7
;		  Sign bit set indicates that the error will crash port
;		  Sign bit not set indicates that it will not
;	R1	- =0 ==> no PB exists
;		  Otherwise R1 = PB address
;	R2	- Packet address (zero if none exists)
;	R4	- PDT address
;	R5	- Error type code
;
; The following code will build the logged message buffer in a UCB extension, 
; and cause it to be placed in the error log.  It will also call OPA0_LOG
; to broadcast the error to _OPA0 if such a broadcast is required.  
; Synchronization on use of the UCB extension area for this purpose is 
; accomplished via the UCB$M_ERLOGIP bit in UCB$W_STS.
;
; Because some of the entities in a logged message have odd sizes, the 
; following code sometimes saves instructions by incorrectly writing longer 
; than necessary entities, and later overwriting the high order portions of 
; the written data with the correct information.
;-


ELOG$$LOG_LM:

	MOVL	PDT$L_UCB0(R4), R3	; Get the UCB address.
	BBCS	#UCB$V_ERLOGIP, -	; Flag error logging in progress and
		UCB$W_STS(R3), 5$ 	; branch if none previously in progress.
	BRW	90$			; Branch if error log is in progress.
5$:	MOVB	R0, UCB$B_LMEST(R3)	; Plant error subtype value.
	MOVB	R5, UCB$B_LMET(R3)	; Plant error type value.
	TSTL	R0			; Is the port going to be crashed?
	BGEQ	10$			; Branch if no.  Otherwise, set flag
	BISB	#PAER$M_CPRT, UCB$B_LMET(R3) ; bit in error code byte.
10$:	MOVW	UCB$B_ERTCNT(R3), -	; Plant error retry and max retry
		UCB$B_LMERTCNT(R3) 	; counts.
	ADDW3	#1, UCB$W_ERRCNT(R3), R0 ; Adjust unincremented error counter,
	MOVZWL	R0, UCB$W_LMERRCNT(R3)	 ; plant it, and zero word following it.
	ASSUME	UCB$S_LSADDR  EQ 6
	ASSUME	UCB$S_LSID    EQ 6
	ASSUME	UCB$S_RSADDR  EQ 6
	ASSUME	UCB$S_RSID    EQ 6
	ASSUME	SB$S_SYSTEMID EQ 6
	$PRTCTINI -			; Protect the following device register
		B^20$, MCHK$M_NEXM	; reference from machine checks.
	MOVL	@PDT$L_PPR(R4), -	; Get the local station address 
		UCB$N_LSADDR(R3)	; directly from the port.
	$PRTCTEND 20$			; End protected code.
	BLBS	R0, 25$			; Branch if no machine check occured.
	MNEGL	#1, UCB$N_LSADDR(R3)	; If couldn't get local station 
	MNEGW	#1, UCB$N_LSADDR+4(R3)	; address, put all ones in its place.
	BRB	30$			; Then, continue with processing.
25$:	CLRL	UCB$N_LSADDR+2(R3)	; If got address, clear high order bits.
30$:	MOVL	G^SCS$GB_SYSTEMID, -	; Get local system id from system
		UCB$N_LSID(R3)		; global address.
	MOVW 	G^SCS$GB_SYSTEMID+4,-	; Copy h.o. 2 bytes of system id
		UCB$N_LSID+4(R3)	; 
	CLRQ	UCB$N_RSID(R3)		; Assume remote system id won't be 
					; found and zero it (plus a little).

	ASSUME	UCB$N_RSADDR+6	EQ UCB$N_RSID
	ASSUME	UCB$N_RSID+6	EQ UCB$L_CICMD
	ASSUME	SB$S_NODENAME	EQ 16

	CMPW	UCB$B_LMEST(R3),-	; Logging known-remote system conflict?
		#<PAER$K_ET_PKT@8 + PAER$K_ES_RSCKS>
	BNEQ	32$			; Branch if not
	MOVL	SAVEDR5(SP),R5		; Otherwise restore known system SB addr
	MOVL	PB$L_SBLINK(R1),R2	; Retrieve remote system SB address
	MOVAB	UCB$N_RSADDR(R3),R0	; Position to remote system address 
					; field within logged msg working buffer
	MOVL	PB$B_RSTATION(R1),(R0)+	; Store remote station address
	CLRW	(R0)+
	MOVL	SB$B_SYSTEMID(R2),(R0)+	; Store remote system ID
	MOVW	SB$B_SYSTEMID+4(R2),(R0)+
	MOVL	SB$B_SYSTEMID(R5),(R0)+	; Store known system ID
	MOVW	SB$B_SYSTEMID+4(R5),(R0)+
	MOVQ	SB$T_NODENAME(R5),(R0)+	; Store known system nodename
	MOVQ	SB$T_NODENAME+8(R5),(R0)+
	MOVQ	SB$T_NODENAME(R2),(R0)+	; Store remote system nodename
	MOVQ	SB$T_NODENAME+8(R2),(R0)+
	PUSHL	R3			; Save UCB address
	MOVC5	#0,(R3),#0,-		; Clear remainder of logged msg buffer
		#<UCB$K_LMPKTBYTS-30>,(R0)
	BRB	66$			; Go finish logged message

32$:	TSTL	R2			; Is there a message packet?
	BNEQ	35$			; Branch if there is one.
	MNEGL	#1, UCB$N_RSADDR(R3)	; Else, can't get remote station
	MNEGW	#1, UCB$N_RSADDR+4(R3)	; address, so put all ones in its place.
	PUSHL	R3			; Save UCB address.
	MOVC5	#0, (R3), #0, -		; Zero all of logged message buffer
		#<UCB$K_LMPKTBYTS+8>, - ; in which message packet would
		UCB$L_CICMD(R3)		; normally be put.
	BRB	66$			; Go finish logged message.
35$:	MOVZBL	PPD$B_PORT(R2), -	; Get remote station address from 
		UCB$N_RSADDR(R3)	; packet.
	CLRW	UCB$N_RSADDR+4(R3)	; Zero extend it to 48 bits.
	TSTL	R1			; Do we have a PB address?
	BEQL	50$			; Branch if no and none exists.
	MOVL	PB$L_SBLINK(R1), R0	; Get SB address from PB.
	BEQL	50$			; Branch if no SB available
	MOVL	SB$B_SYSTEMID(R0), -	; Copy system id from system block
		UCB$N_RSID(R3)		; to the log entry.
	MOVW	SB$B_SYSTEMID+4(R0), -
		UCB$N_RSID+4(R3)
50$:	PUSHL	R3			; Save UCB address.
	CVTWL	PPD$W_SIZE(R2),R0	; Get possible neg offset to net hdr
	BGEQ	55$			; Branch if no net header
	MOVAB	PPD$W_SIZE(R2)[R0],R0	; Else get addr of net header
	ADDW3	PPD$W_SIZE(R2),(R0),R0	;  and get size stored in net header
					;  - size of net header
55$:	SUBW3	#PPD$B_PORT, R0, R5	; Compute maximum length of message
					; based upon allocated pool region.
	MOVC5	R5, PPD$B_PORT(R2), -	    ; Move all interesting parts of the
		#0, #<UCB$K_ERRDGBYTS+8>, - ; message packet to the logged
		UCB$L_CICMD(R3)		    ; message buffer.
66$:	POPL	R3			; Restore UCB address.
	MOVZBL	#EMB$C_PM, R0		; Get CI logged message sub-type code.
	MOVZWL	#UCB$K_LMBUFSIZ, R1	; Get size of logged message.
	CMPW	UCB$B_LMEST(R3),-	; Is it a plain (short) logged msg?
		#<PAER$K_ET_PKT@8 + PAER$K_ES_ERRDG>
	BNEQ	80$			; Branch if so
	MOVZWL	UCB$W_MSGBYTCNT(R3),R1	; Get a copy of the PPD length from
					;  the saved message
	ADDL	#<UCB$W_MSGPPDTYP - UCB$B_LMEST>,R1
					; Add in other parts of error log entry
	CMPL	R1,#UCB$K_ERRDGSIZ	; Is it more than we will log?
	BLEQ	80$			; Branch if not
	MOVL	#UCB$K_ERRDGSIZ,R1	; Else put in max errlog entry size

80$:	MOVQ	R0,-(SP)		; Save registers
	MOVAB	LM_OPA0_LOG_TAB,R1	; Retrieve logged message _OPA0 table
	BICL3	#^X00008000,-		; Retrieve error subtype and type and
		UCB$B_LMEST(R3),R0	; clearing port crash indicating bit
	BSBB	OPA0_LOG		; Log the error to _OPA0 if indicated
	SUBL3	#UCB$L_MSGFKBLK,R5,R3	; Compute UCB address
	MOVQ	(SP)+,R0		; Restore registers

	MOVAB	UCB$B_LMEST(R3), R2	; Get starting address of message.
	JSB	G^ERL$LOGMESSAGE	; Log the message.
	BICW	#UCB$M_ERLOGIP, UCB$W_STS(R3) ; Clear err. log in progress flag.
90$:	POPR	#LM_MASK		; Restore saved registers.
	RSB				; Return to caller.

	.SBTTL	OPA0_LOG,		_OPA0 ERROR LOGGING ROUTINE

;+
; This routine first determines whether or not _OPA0 error logging should be
; done. Then, if logging to _OPA0 is indicated, this routine saves what optional
; formatting information will be needed and creates a fork process, using the 
; port UCB's message fork block, to handle the formatting and broadcasting of 
; the appropriate error log message. If this fork block is currently in use, 
; presumably for the broadcasting of an earlier error log message, the 
; assumption is made that this earlier message is the more important one, and 
; the error condition currently being processed is not logged to _OPA0.
;
; Error logging to _OPA0 will be attempted whenever the system device, which
; is assummed to be the same as the error logging device, is currently 
; unavailable. Such error logging will also always be done for certain error 
; conditions, such as fatal port initialization errors.
;
; Inputs:
;
;	IPL			-Device or Fork IPL
;	R0			-High word 0, Error Subtype, Error Type
;	R1			-Address of an _OPA0 Error Logging Table
;	R3			-Address of UCB
;
;	It is assummed that the logged message buffer portion of the UCB has
;	been initialized for all error conditions which use the logged
;	message error log entry format.  The contents of device registers 
;	are always obtained via the PDT.
;
; Outputs:
;
;	R0-R1, R3-R4		-Destroyed
;	R5			-Address of UCB message fork block
;	Other registers		-Preserved
;-

	.ENABL	LSB
OPA0_LOG:
	MOVAB	UCB$L_MSGFKBLK(R3),R5	; Retrieve fork block address into R5

;
; Find the entry in the appropriate _OPA0 error log table that corresponds
; to the error condition currently being processed.
;

10$:	CMPW	R0,(R1)			; Entry for current error condition?
	BEQL	20$			; Branch if so
	TSTW	(R1)			; Have we reached the end of the table?
	BLSS	30$			; Don't perform logging if we have
	ADDL2	#OPA0_LOG_SIZE,R1	; Else, position to next table entry
	BRB	10$			; Continue search


;
; The current error condition will be logged to _OPA0 under the following
; circumstances:
;
; 1. It is indicated that such error conditions are always to be logged.
; 2. The system disk has not yet been mounted.
; 3. The system disk is currently being mounted.
; 4. The system disk is undergoing mount verification.
; 5. During mount verification it is discovered that the system disk drive
;    contains the wrong volume.
; 6. The system disk has timed out.
; 7. The local system is participating in a cluster and quorum has been lost.
;
; An implicit assumption is that the system and error logging disk are one and
; the same.
;

20$:	BBS	#V_ALWAYS,CFLAGS(R1),40$; Go log if this error is always logged

	MOVL	G^EXE$GL_SYSUCB,R0	; Retrieve UCB for system disk
	TSTL	UCB$L_VCB(R0)		; Has the system disk been mounted?
	BEQL	40$			; Go log if it hasn't
	BITW	#UCB$M_MOUNTING!-	; Is system disk in one of these states?
		UCB$M_WRONGVOL!-	; Currently being mounted?
		UCB$M_MNTVERIP!-	; Wrong volume in device?
		UCB$M_TIMOUT,-		; Mount verification in progress?
		UCB$W_STS(R0)		; Timed out?
	BNEQ	40$			; Go log if it is

	MOVL	G^CLU$GL_CLUB,R0	; Retrieve cluster block
	BEQL	30$			; No need to log if there isn't one
	BBC	#CLUB$V_QUORUM,-	; Go log if the system is participating
		CLUB$L_FLAGS(R0),40$	; in a cluster which has lost quorum
30$:	RSB				; Return
40$:	BBSS	#UCB_V_MSGFKLOCK,-	; Indicate msg fork block now in use
		UCB$W_DEVSTS(R3),30$	; If the fork block already in use, 
					; assume prior error condition is more
					; important & skip logging of this one


;
; A decision has been made to log the error condition to _OPA0. First, store
; within the UCB any optional information which will be required to format the 
; _OPA0 error log message. Finally setup and create a fork process to format 
; and broadcast the appropriate error log message to _OPA0. The fork process is 
; created using the UCB's message fork block.
;

	BBC	#V_RPORT,CFLAGS(R1),50$	; Remote port number required?
	MOVZBL	UCB$N_RSADDR(R3),-	; If so, then save the remote port
		UCB$T_OPA0_TEMP(R3)	; number in UCB, and go setup and
	BRB	70$			; create the fork process

50$:	BBC	#V_PKT,CFLAGS(R1),60$	; CI packet information required?
	MOVL	UCB$L_CICMD(R3),-	; If so, then save the CI packet
		UCB$T_OPA0_TEMP(R3)	; information in the UCB, and go setup
	BRB	70$			; and create the fork process

60$:	BBC	#V_REGS,CFLAGS(R1),70$	; Branch if device regs not required
	MOVL	UCB$L_PDT(R3),R4	; Retrieve PDT address
	CLRQ	UCB$T_OPA0_TEMP(R3)	; Clear UCB locations where the device
	CLRL	UCB$T_OPA0_TEMP+8(R3)	; registers will be saved
	$PRTCTINI -			; Protect device register references
		B^65$,#MCHK$M_NEXM	; from machine checks
	MOVL	@PDT$L_CNF(R4),-	; Store contents of configuration 
		UCB$T_OPA0_TEMP(R3)	; register
	MOVL	@PDT$L_PMC(R4),-	; Store contents of port maintenance
		UCB$T_OPA0_TEMP+4(R3)	; control register
	MOVL	@PDT$L_PS(R4),-		; Store contents of port status register
		UCB$T_OPA0_TEMP+8(R3)
	$PRTCTEND 65$			; If check occurs, leave zero values(s)

70$:	MOVL	R1,R4			; Save table entry for error in R4
	PUSHAB	OPA0_LOG_FORK		; Fork process routine address
	JMP	G^EXE$FORK		; Fork ...

	.DSABL	LSB

	.SBTTL	OPA0_LOG_FORK,		_OPA0 ERROR LOGGING 
	.SBTTL	-			FORK PROCESS ROUTINE

;+
; This is the routine which assumes control, within the context of a fork 
; process, when an error log message is to be broadcast to _OPA0. This routine
; formats and broadcasts the _OPA0 error log message as follows:
;
; 1. Optionally format the error log message utilizing information contained 
;    within the _OPA0 error log table entry for this specific error condition. 
;    The address of the appropriate table entry maybe found within R4 on input 
;    to the routine.
; 2. Release the message fork block by clearing the interlock bit. This step
;    must be delayed until after the optional formatting is completed because
;    the optional formatting makes use of UCB locations which we can not allow
;    to be overwritten until we are through with them.
; 3. Copy the device controller letter into the error log message.
; 4. Broadcast the _OPA0 error log message.
; 5. Broadcast a second message indicating that the port will be taken offline
;    if this is indicated for this error condition (Fatal port initialization 
;    errors only).
;
; Inputs:
;
;	R3			-Address of UCB
;	R4			-Address an _OPA0 Error Logging Table Entry
;	R5			-Address of Message Fork Block
;
;	It is assummed that the three longwords beginning at UCB$T_OPA0_TEMP
;	have been initialized with whatever values will be required to complete
;	any optional formatting of the current _OPA0 error log message.
;
; Outputs:
;
;	R0-R5			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB
OPA0_LOG_FORK:
	MOVL	UCB$L_CRB(R3),R0	; Retrieve CRB address
	PUSHL	CRB$L_INTD+-		; Retrieve and save address of 
		VEC$L_INITIAL(R0)	; controller initialization routine

	CVTWL	MSG(R4),R2		; Retrieve offset to counted message
	ADDL2	(SP),R2			; Compute address of counted message

	MOVZWL	FORMAT(R4),R0		; Retrieve offset to formatting routine
	BEQL	10$			; Branch if no special formatting 
	ADDL2	(SP),R0			; Else compute formatting routine addr
	JSB	(R0)			; Perform special formatting

10$:	BICB2	#UCB_M_MSGFKLOCK,-	; Mark message fork block as being 
		UCB$W_DEVSTS(R3)	; no longer in use

	MOVZBL	(R2)+,R1		; Retrieve size and address of message
	CLRL	(SP)			; Assume will not broadcast "Offline" 
	BBC	#V_OFFLINE,CFLAGS(R4),20$; Branch if this is true
	MOVL	#1,(SP)			; Else this second msg will be broadcast

20$:	MOVL	UCB$L_DDB(R3),R4	; Get DDB address into R4
	MOVAB	G^OPA$UCB0,R5		; Get _OPA0 UCB address into R5

	MOVB	DDB$T_NAME+3(R4),-	; Copy device controller letter from
		CTRLR_NAME(R2)		; DDB to ASCII message
	JSB	G^IOC$BROADCAST		; Send message to terminal driver

	TSTL	(SP)+			; Should the "Offline" msg be broadcast?
	BNEQ	30$			; Go do so if it should
	RSB				; Else return

30$:	MOVAB	INI$MSG_OFFL,R2		; Retrieve counted message address
	MOVZBL	(R2)+,R1		; Retrieve message size and address
	MOVB	DDB$T_NAME+3(R4),-	; Copy device controller letter from
		CTRLR_NAME(R2)		; DDB to ASCII message
	JMP	G^IOC$BROADCAST		; Send message to terminal driver and
					; return
	.DSABL	LSB

	.SBTTL	_OPA0 ERROR LOGGING FORMATTING ROUTINES
	.SBTTL	-	ERR$CNV_HEX_DEC	ROUTINE TO CONVERT A BINARY NUMBER
	.SBTTL	-			INTO ITS DECIMAL ASCII EQUIVALENCE

;+
; This routine takes a binary number, converts it into a decimal number, and
; then converts the decimal number into its ASCII equivalence. An implicit
; assumption is made that the binary number to be converted fits in a byte
; (ie - has a value in the range 0 - 255 decimal).
;
; Inputs:
;
;	R0			-Number to convert into its ASCII equivalence
;	R2			-Field in which to store the result
;
; Outputs:
;
;	R0-R1,R3		-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB
ERR$CNV_HEX_DEC::
	MOVAB	CONV_TABLE,R3		; Retrieve address of conversion table
	MOVW	#^A/  /,(R2)		; Blank out first two bytes of field

	CLRL	R1			; Clear high order longword
	EDIV	#100,R0,R1,R0		; Determine number of 100s and remainder
	BEQL	10$			; Branch if no 100s
	MOVB	(R3)[R1],(R2)		; Otherwise store number in 100s place
	
10$:	CLRL	R1
	EDIV	#10,R0,R1,R0		; Determine number of 10s and remainder
	BEQL	20$
	MOVB	(R3)[R1],1(R2)		; Store number in 10s place

20$:	MOVB	(R3)[R0],2(R2)		; store number in 1s place
	RSB				; Return
	.DSABL	LSB

	.SBTTL	-	FORMAT_PKT,	ROUTINE TO FORMAT PACKET
	.SBTTL	-			INFORMATION

;+
; This routine formats packet information fields within an _OPA0 error log
; message. The formatted packet field appears in the message as follows:
;
; 			FLAGS/OPC/STATUS/PORT	xx/xx/xx/xx
;
; The packet fields are formatted from left to right by calling the routine
; HEX_TO_ASCII for each packet field to be formatted.
;
; Inputs:
;
;	R2			-Address of _OPA0 Error Log Message
;	R3			-Address of the UCB
;	R4			-Address of an _OPA0 Error Logging Table Entry
;
;	It is assummed that UCB$T_OPA0_TEMP has been initialized with the packet
;	information to be formatted.
;
;
; Outputs:
;
;	R0-R1			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB
FORMAT_PKT:
	PUSHR	#^M<R2,R3,R4,R5,R6>	; Save some registers
	CVTBL	OFFSET(R4),R0		; Retrieve offset to field to format
	ADDL2	R0,R2			; Compute address of field to format
	MOVAB	UCB$T_OPA0_TEMP+4(R3),R5; Get addr of 1st byte past pkt fields
	MOVZBL	#4,R6			; Num of packets fields to be formatted

10$:	MOVZBL	-(R5),R1		; Get contents of next field to format
	MOVL	#2,R0			; Set number of nibbles in packet field
	BSBB	HEX_TO_ASCII		; Format the current packet field
	INCL	R2			; Step over the delimiter
	SOBGTR	R6,10$			; Continue until all fields formatted

	POPR	#^M<R2,R3,R4,R5,R6>	; Restore registers
	RSB				; Return
	.DSABL	LSB

	.SBTTL	-	FORMAT_PORT,	ROUTINE TO FORMAT A
	.SBTTL	-			REMOTE PORT NUMBER

;+
; This routine formats a remote port number field within an _OPA0 error log 
; message. The remote port number appears as a decimal number after formatting.
;
; Inputs:
;
;	R2			-Address of _OPA0 Error Log Message
;	R3			-Address of the UCB
;	R4			-Address of an _OPA0 Error Logging Table Entry
;
;	It is assummed that UCB$T_OPA0_TEMP has been initialized with the 
;	remote port number to be formatted.
;
;
; Outputs:
;
;	R0-R1			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB
FORMAT_PORT:
	MOVQ	R2,-(SP)		; Save registers
	CVTBL	OFFSET(R4),R0		; Retrieve offset to field to format
	ADDL2	R0,R2			; Compute address of field to format
	MOVL	UCB$T_OPA0_TEMP(R3),R0	; Retrieve remote port number
	BSBB	ERR$CNV_HEX_DEC		; Format the remote port number
	MOVQ	(SP)+,R2		; Restore registers
	RSB				; Return
	.DSABL	LSB

	.SBTTL	-	FORMAT_REGS,	ROUTINE TO FORMAT PORT
	.SBTTL	-			REGISTERS

;+
; This routine formats the port register fields within an _OPA0 error log
; message. Only the contents of selected port registers are formatted. The
; formatted register fields appear in the message as follows:
;
; 		CNF/PMC/PSR	xxxxxxxx/xxxxxxxx/xxxxxxxx
;
; The port register fields are formatted from left to right by calling the 
; routine HEX_TO_ASCII for each register field to be formatted.
;
; Inputs:
;
;	R2			-Address of _OPA0 Error Log Message
;	R3			-Address of the UCB
;	R4			-Address of an _OPA0 Error Logging Table Entry
;
;	It is assummed that the three longwords beginning at UCB$T_OPA0_TEMP 
;	have been initialized with the values of the device registers to be
;	formatted.
;
;
; Outputs:
;
;	R0-R1			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB
FORMAT_REGS:
	PUSHR	#^M<R2,R3,R4,R5,R6>	; Save some registers
	CVTBL	OFFSET(R4),R0		; Retrieve offset to field to format
	ADDL2	R0,R2			; Compute address of field to format
	MOVAB	UCB$T_OPA0_TEMP(R3),R5	; Get address of first port register 
	MOVZBL	#3,R6			; Num of register fields to be formatted

10$:	MOVL	(R5)+,R1		; Get contents of next port register
	MOVL	#8,R0			; Set number of nibbles in packet field
	BSBW	HEX_TO_ASCII		; Format the current port register field
	INCL	R2			; Step over the delimiter
	SOBGTR	R6,10$			; Continue until all registers formatted

	POPR	#^M<R2,R3,R4,R5,R6>	; Restore registers
	RSB				; Return
	.DSABL	LSB

	.SBTTL	-	FORMAT_REV,	FORMAT PORT UCODE REV LEVELS

;+
; This routine formats the PROM and RAM revision levels within an OPA0 message.
; The formatted field appears in the message as follows:
;
;	RAM/PROM rev is xxxx/xxxx
;
; The fields are formatted from left to right by calling the routine 
; HEX_TO_ASCII for each rev.
;
; Inputs:
;
;	R2			-Address of OPA0 error message
;	R3			-Addr of UCB
;	R4			-Addr of OPA0 error message table entry
;
;	It is assumed that UCB$T_OPA0_TEMP has been initialized with
; 	the rev level information to be formatted.
;
; Outputs:
;
;	R0,R1			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

FORMAT_REV:

	PUSHR	#^M<R2,R3,R4,R5,R6>	; Save caller's registers
	CVTBL	OFFSET(R4),R0		; Retreive offset to field to fmt
	ADDL2	R0,R2			; Compute addr of field to fmt
	MOVAW	UCB$T_OPA0_TEMP(R3),R5	; Get addr of RAM rev
	MOVZBL	#2,R6			; Two rev levels to fmt
	
10$:	MOVW	(R5)+,R1		; Get next rev level
	MOVL	#4,R0			; 4 hex digits/rev level
	BSBB	HEX_TO_ASCII		; Format this rev
	INCL	R2			; Step past slash delimiter, /
	SOBGTR	R6,10$			; Continue formatting revs
	POPR	#^M<R2,R3,R4,R5,R6>	; Restore registers
	RSB				; Return to caller

	.DSABL	LSB

	.SBTTL	-	HEX_TO_ASCII	ROUTINE TO CONVERT A BINARY NUMBER
	.SBTTL	-			INTO ITS ASCII EQUIVALENCE

;+
; This routine takes a binary number, converts it into its ASCII equivalence,
; and stores it in the field provided. The nibbles of the binary number are
; processed and stored in their ASCII equivalences from left to right. This 
; routine is capable of handling up to a longword at a time in this fashion. 
;
; Inputs:
;
;	R0			-Number of nibbles in field to be converted
;	R1			-Number to convert into its ASCII equivalence
;	R2			-Field in which to store the ASCII equivalences
;
; Outputs:
;
;	R0,R3-R4		-Destroyed
;	R2			-Address of first byte past field
;	Other registers		-Preserved
;-

	.ENABL	LSB
HEX_TO_ASCII:
	MOVAB	CONV_TABLE,R3		; Retrieve address of conversion table
	ASHL	#2,R0,R0		; Compute bit number of leftmost nibble
	SUBL2	#4,R0			; which is to be converted

10$:	EXTZV	R0,#4,R1,R4		; Extract the current nibble
	MOVB	(R3)[R4],(R2)+		; Move ASCII equivalence into field
	ACBB	#0,#-4,R0,10$		; Continue until all nibbles processed
	RSB				; Return
	.DSABL	LSB

	.END
