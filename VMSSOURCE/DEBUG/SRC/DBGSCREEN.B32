MODULE DBGSCREEN (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	March, 1983
!
! MODULE FUNCTION
!	This module contains all routines which implement DEBUG's
!	Screen Mode facility.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$KEY_INITIALIZE: NOVALUE,	! Initialize keypad definitions
    DBG$SCR_CREATE_DISPLAY,		! Create a new Screen Display Entry
    DBG$SCR_CREATE_WINDOW,		! Create a new Screen Window Entry
    DBG$SCR_DELETE_DISPLAY,		! Delete a specified screen display
    DBG$SCR_DELETE_WINDOW,		! Delete a specified screen window
    DBG$SCR_DISPLAY_COMMAND,		! Process the DISPLAY command semantics
    DBG$SCR_EMPTY_DISPLAY: NOVALUE,	! Empty a display of it contents
    DBG$SCR_EXECUTE_CANDISP_CMD:NOVALUE,! Execute the CANCEL DISPLAY command
    DBG$SCR_EXECUTE_CANWIND_CMD:NOVALUE,! Execute the CANCEL WINDOW command
    DBG$SCR_EXECUTE_DISPLAY_CMD:	! Execute the DISPLAY and SET DISPLAY
			NOVALUE,	!      commands
    DBG$SCR_EXECUTE_SAVE_CMD: NOVALUE,	! Execute the SAVE command
    DBG$SCR_EXECUTE_SCROLL_CMD: NOVALUE,! Execute the SCROLL command
    DBG$SCR_EXECUTE_SELECT_CMD: NOVALUE,! Execute the SELECT command
    DBG$SCR_EXECUTE_SETTERM_CMD:NOVALUE,! Execute the SET TERMINAL command
    DBG$SCR_EXECUTE_SETWIND_CMD:NOVALUE,! Execute the SET WINDOW command
    DBG$SCR_EXECUTE_SHODISP_CMD:NOVALUE,! Execute the SHOW DISPLAY command
    DBG$SCR_EXECUTE_SHOSEL_CMD: NOVALUE,! Execute the SHOW SELECT command
    DBG$SCR_EXECUTE_SHOWIND_CMD:NOVALUE,! Execute the SHOW WINDOW command
    DBG$SCR_GENERATE_SCREEN: NOVALUE,	! Generate contents of all automatically
					!      updated screen displays
    DBG$SCR_INITIALIZE: NOVALUE,	! Initialize Screen Debugging code
    DBG$SCR_LOOKUP_DISPLAY,		! Look up a screen display by its name
    DBG$SCR_LOOKUP_WINDOW,		! Look up a screen window by its name
    DBG$SCR_OUTPUT_LINE_MINIMAL:NOVALUE,! Output line to screen using a minimal
					!      screen update algorithm
    DBG$SCR_OUTPUT_SCREEN: NOVALUE,	! Output updated screen image
    DBG$SCR_PARSE_CANDISP_CMD: NOVALUE,	! Parse the CANCEL DISPLAY command
    DBG$SCR_PARSE_CANWIND_CMD: NOVALUE,	! Parse the CANCEL WINDOW command
    DBG$SCR_PARSE_DISPLAY_CMD: NOVALUE,	! Parse DISPLAY and SET DISPLAY commands
    DBG$SCR_PARSE_SAVE_CMD: NOVALUE,	! Parse the SAVE command
    DBG$SCR_PARSE_SCROLL_CMD: NOVALUE,	! Parse the SCROLL command
    DBG$SCR_PARSE_SELECT_CMD: NOVALUE,	! Parse the SELECT command
    DBG$SCR_PARSE_SETTERM_CMD: NOVALUE,	! Parse the SET TERMINAL command
    DBG$SCR_PARSE_SETWIND_CMD: NOVALUE, ! Parse the SET WINDOW command
    DBG$SCR_PARSE_SHODISP_CMD: NOVALUE,	! Parse the SHOW DISPLAY command
    DBG$SCR_PARSE_SHOWIND_CMD: NOVALUE, ! Parse the SHOW WINDOW command
    DBG$SCR_READ_LINE,			! Read a line of input
    DBG$SCR_SCREEN_MODE: NOVALUE,	! Execute SET MODE SCREEN and NOSCREEN
    DBG$SCR_SCREEN_NORMAL: NOVALUE,	! Make screen normal for SPAWN command
    DBG$SCR_SCREEN_TERM: NOVALUE,	! Make screen normal for exit handler
    DBG$SCR_SCREEN_TO_LOGFILE: NOVALUE,	! Write screen image to DEBUG log file
    DBG$SCR_SCROLL_DISPLAY: NOVALUE,	! Scroll a specified display
    DBG$SCR_SCROLL_SOURCE_DOWN,		! Scroll a source display down
    DBG$SCR_SCROLL_SOURCE_UP,		! Scroll a source display up
    DBG$SCR_SOURCE_BEGIN: NOVALUE,	! Begin retrieval of source lines
    DBG$SCR_SOURCE_END: NOVALUE,	! End retrieval of source lines
    DBG$SCR_SOURCE_LINE: NOVALUE,	! Insert a source line in a display
    DBG$SCR_UPDATE_PASTEBOARD: NOVALUE,	! Update contents of pasteboard
    DBG$SCR_WRITE_ERROR,		! Write an error message to a display
    DBG$SCR_WRITE_LINE: NOVALUE,	! Write a line of output to a display
    FORMAT_SOURCE_LINE: NOVALUE,	! Format a source line for display
    HANDLER_EXECUTE_SAVE,		! Handler for EXECUTE_SAVE_CMD routine
    HANDLER_SCROLL_SOURCE,		! Handler for SCROLL_SOURCE_xx routines
    PARSE_DISPLAY_NAME,			! Parse and look up a display name
    PARSE_WINDOW_NAME,			! Parse and look up a window name
    PARSE_WINDOW_PARAMETERS: NOVALUE,	! Parse window specification parameters
    REDIRECT_SCREEN_OUTPUT: NOVALUE,	! Redirect screen output to DBG$OUTPUT
    REGISTER_DISPLAY: NOVALUE,		! Fill in contents of a register display
    REGISTER_FILL: NOVALUE,		! Fill hex value into register display
    WINDOW_SOURCE_LINE;			! Find first source line number in a
					!      display's screen window

EXTERNAL ROUTINE
    DBG$FINAL_HANDL,			! DEBUG's Final condition handler
    DBG$GET_MEMORY,			! Get a permanent memory block
    DBG$GET_TEMPMEM,			! Get a temporary memory block
    DBG$NCIS_ADD: NOVALUE,		! Add buffer to the Command Input Stream
    DBG$NEWLINE: NOVALUE,		! Flush the current print line
    DBG$NMATCH,				! Match a specified string in parsing
    DBG$NSAVE_BREAK_BUFFER,		! Pick up a DEBUG command list
    DBG$NSAVE_DECIMAL_INTEGER,		! Parse a decimal integer constant
    DBG$PRINT: NOVALUE,			! Format and output print output
    DBG$REL_MEMORY: NOVALUE,		! Release a permanent memory block
    DBG$SRC_LNUM_RANGE: NOVALUE,	! Get a module's line number range
    DBG$SRC_TYPE_LNUM_SOURCE: NOVALUE,	! Type a range of source lines
    DBG$STA_SYMNAME,			! Returns ASCIC symbol name given SYMID
    DBG$SYNTAX_ERROR: NOVALUE,		! Report a syntax error in parsing
    DBG$WRITE_LOG_FILE: NOVALUE,	! Write a line to the DEBUG log file
    OTS$CVT_L_TZ,			! Convert a longword to hexadecimal text
    SCR$DOWN_SCROLL,			! Scroll screen down one line
    SCR$ERASE_LINE,			! Erase rest of line on screen
    SCR$PUT_BUFFER,			! Output screen buffer to terminal
    SCR$PUT_SCREEN,			! Output a line of text to the screen
    SCR$SCREEN_INFO,			! Get information about screen terminal
    SCR$SET_BUFFER,			! Set up screen buffer mode
    SCR$SET_CURSOR,			! Set the cursor on the screen
    SCR$SET_OUTPUT,			! Redirect output to DBG$OUTPUT
    SCR$SET_SCROLL,			! Set up scrolling region on the screen
    SCR$UP_SCROLL,			! Scroll screen up one line
    SMG$ADD_KEY_DEF,			! Add a keypad key definition
    SMG$SET_KEYPAD_MODE;		! Set terminal to numeric or applic.

EXTERNAL
    DBG$GB_KEYPAD_INPUT: BYTE,		! Keypad input flag
    DBG$GL_KEYBOARD_ID,			! Used by SMG routines
    DBG$GB_LANGUAGE: BYTE,		! The currently SET language code
    DBG$GL_CISHEAD: REF CIS$LINK,	! Pointer to first CIS entry on DEBUG's
					!      Command Input Stream
    DBG$GL_DEVELOPER: BITVECTOR[],	! Developer switches
    DBG$GL_KEY_TABLE_ID,		! Keypad input Key-Table Id number
    DBG$RUNFRAME: BLOCK[,BYTE],		! The current user run frame
    DBG$SRC_NEXT_LNUM,			! The next source line number
    DBG$SRC_TERM_WIDTH;			! Terminal width of output device

LITERAL
    CAR_RET		= 13,		! Carriage Return character
    TAB_CHAR		= 9;		! Horizontal Tab character

BIND
    DBG$CS_ALL		= UPLIT BYTE(%ASCIC 'ALL'),	! Counted ASCII strings
    DBG$CS_AS		= UPLIT BYTE(%ASCIC 'AS'),	!      used in parsing
    DBG$CS_AT		= UPLIT BYTE(%ASCIC 'AT'),
    DBG$CS_BOTTOM	= UPLIT BYTE(%ASCIC 'BOTTOM'),
    DBG$CS_CLEAR	= UPLIT BYTE(%ASCIC 'CLEAR'),
    DBG$CS_COLON	= UPLIT BYTE(%ASCIC ':'),
    DBG$CS_COMMA	= UPLIT BYTE(%ASCIC ','),
    DBG$CS_CR		= UPLIT BYTE(1, CAR_RET),	! Carriage return
    DBG$CS_DO		= UPLIT BYTE(%ASCIC 'DO'),
    DBG$CS_DOWN		= UPLIT BYTE(%ASCIC 'DOWN'),
    DBG$CS_EQUAL	= UPLIT BYTE(%ASCIC '='),
    DBG$CS_GENERATE	= UPLIT BYTE(%ASCIC 'GENERATE'),
    DBG$CS_HIDE		= UPLIT BYTE(%ASCIC 'HIDE'),
    DBG$CS_HISTORY	= UPLIT BYTE(%ASCIC 'HISTORY'),
    DBG$CS_INPUT	= UPLIT BYTE(%ASCIC 'INPUT'),
    DBG$CS_LEFT		= UPLIT BYTE(%ASCIC 'LEFT'),
    DBG$CS_LPAREN	= UPLIT BYTE(%ASCIC '('),
    DBG$CS_MARK_CHANGE	= UPLIT BYTE(%ASCIC 'MARK_CHANGE'),
    DBG$CS_NOMARK_CHANGE= UPLIT BYTE(%ASCIC 'NOMARK_CHANGE'),
    DBG$CS_NORMAL	= UPLIT BYTE(%ASCIC 'NORMAL'),
    DBG$CS_OUTPUT	= UPLIT BYTE(%ASCIC 'OUTPUT'),
    DBG$CS_REFRESH	= UPLIT BYTE(%ASCIC 'REFRESH'),
    DBG$CS_REGISTER	= UPLIT BYTE(%ASCIC 'REGISTER'),
    DBG$CS_REMOVED	= UPLIT BYTE(%ASCIC 'REMOVED'),
    DBG$CS_RIGHT	= UPLIT BYTE(%ASCIC 'RIGHT'),
    DBG$CS_RPAREN	= UPLIT BYTE(%ASCIC ')'),
    DBG$CS_SCROLLING	= UPLIT BYTE(%ASCIC 'SCROLLING'),
    DBG$CS_SIZE		= UPLIT BYTE(%ASCIC 'SIZE'),
    DBG$CS_SLASH	= UPLIT BYTE(%ASCIC '/'),
    DBG$CS_SOURCE	= UPLIT BYTE(%ASCIC 'SOURCE'),
    DBG$CS_TOP		= UPLIT BYTE(%ASCIC 'TOP'),
    DBG$CS_UP		= UPLIT BYTE(%ASCIC 'UP'),
    DBG$CS_WIDTH	= UPLIT BYTE(%ASCIC 'WIDTH');

GLOBAL
    DBG$GL_SCREEN_ERROR: INITIAL(0),	! Pointer to active error Display Entry
    DBG$GL_SCREEN_HISTORY: INITIAL(0),	! Pointer to active history Display Entry
    DBG$GL_SCREEN_INPUT: INITIAL(0),	! Pointer to active input Display Entry
    DBG$GL_SCREEN_LOG: INITIAL(FALSE),	! Flag set if screen logging is active
    DBG$GL_SCREEN_MODE: INITIAL(FALSE),	! Flag set if screen mode is active
    DBG$GL_SCREEN_NOGO: INITIAL(FALSE),	! Flag to turn off STEP and GO commands
    DBG$GL_SCREEN_OUTPUT: INITIAL(0),	! Pointer to active output Display Entry
    DBG$GL_SCREEN_SOURCE: INITIAL(0);	! Pointer to active source Display Entry

OWN
    BOT_OFFSET,				! Offset from DROW to bottom ref point
    BOT_REF_FILEID,			! FileId of bottom reference point
    BOT_REF_RECNUM,			! Record number of bottom reference point
    DBG$GL_VT100_FLAG: INITIAL(TRUE),	! Flag set if terminal is VT100 class
    DBG$SCR_CURDISP_INPUT:		! Pointer to the Display Entry for the
	REF DBG$DISP_ENTRY INITIAL(0),	!      current input display
    DBG$SCR_CURDISP_OUTPUT:		! Pointer to the Display Entry for the
	REF DBG$DISP_ENTRY INITIAL(0),	!      current output display
    DBG$SCR_CURDISP_SCROLL:		! Pointer to the Display Entry for the
	REF DBG$DISP_ENTRY INITIAL(0),	!      current scrolling display
    DBG$SCR_CURDISP_SOURCE:		! Pointer to the Display Entry for the
	REF DBG$DISP_ENTRY INITIAL(0),	!      current source line display
    DBG$SCR_DISPLAY_LIST:		! List head for doubly linked list of
	VECTOR[2,LONG] INITIAL(0,0),	!      Screen Display Entries
    DBG$SCR_WINDOW_LIST:		! List head for doubly linked list of
	VECTOR[2,LONG] INITIAL(0,0),	!      Screen Window Entries
    FIXED_SCROLL_AMOUNT,		! Flag set if fixed scrolling amount is
					!      used for source scrolling
    FIXED_SCROLL_VALID: INITIAL(FALSE),	! Flag set if above flag is valid
    INVSCR_FLAG,			! Flag to invalidate scrolling count
					!      for scrolling displays
    MARKLINE_DISABLE_FLAG:		! Flag set to disable marking of source
			INITIAL(FALSE),	!      line with "->" when scrolling
    OLD_CNT: VECTOR[DBG$K_PASTE_SIZE],	! Old screen image char count per line
    OLD_REND:				! Old screen image rendition bits
	VECTOR[DBG$K_PASTE_SIZE, BYTE],	!      per line
    OLD_SCREEN: VECTOR[			! Old screen image used to implement a
	DBG$K_PASTE_SIZE*132, BYTE],	!      minimal screen update scheme
    OLD_SCREEN_REND: VECTOR[		! Old screen image rendition codes used
	DBG$K_PASTE_SIZE*132, BYTE],	!      for minimal screen update scheme
    OLD_VALID:				! Flags to indicate old screen image
	BITVECTOR[DBG$K_PASTE_SIZE],	!      text for a line is valid
    PASTEBOARD: DBG$PASTEBOARD,		! The terminal screen pasteboard
    SAVED_SCROLL,			! Saved scrolling count when scrolling
					!      a source line display
    SCREEN_MODE_FIRST_TIME:		! Flag cleared the first time screen
			INITIAL(TRUE),	!      mode is set
    SCROLL_AMOUNT,			! Source display scrolling amount from
					!      SCROLL command
    SCROLL_TO_BOTTOM,			! Flag set when scrolling to bottom of
					!      a source display
    TOP_OFFSET,				! Offset from DROW to top ref point
    TOP_REF_FILEID,			! FileId of top reference point in display
    TOP_REF_RECNUM;			! Record number of top reference point

! MACRO TO CREATE A KEYPAD DEFINITION
!
!
!
! This macro creates a built-in keypad definition.  It is called as follows:
!
!	KEYPAD_DEF(IF_STATE, KEYNAME, FLAGS, COMMAND, SET_STATE)
!
! where IF_STATE is a string giving the "color key" that must have been pressed
! first, KEYNAME is a string giving the name of the key being defined, FLAGS is
! a bit-mask that indicates whether the key is echoed and whether it terminates
! the current input operation, COMMAND is the DEBUG command string to which the
! new key maps, and SET_STATE is a string giving the new "color state" that is
! set by the new key (if any).  IF_STATE and SET_STATE can both be null param-
! eters, and COMMAND can be a null string.
!
MACRO
    KEYPAD_DEF(IF_STATE, KEYNAME, FLAGS, COMMAND, SET_STATE) =
	BEGIN


	! Set up the pointers to the string descriptors for If-state and the
	! Set-state parameters.  For the default "color" state, these pointers
	! are zero; otherwise they point to descriptors for 'GOLD' or 'BLUE'.
	!
	%IF %NULL(IF_STATE)           %THEN IF_PTR = 0
	%ELSE %IF IF_STATE EQL 'GOLD' %THEN IF_PTR = GOLD_DESC
	%ELSE %IF IF_STATE EQL 'BLUE' %THEN IF_PTR = BLUE_DESC
	%FI %FI %FI;
	%IF %NULL(SET_STATE)           %THEN SET_PTR = 0
	%ELSE %IF SET_STATE EQL 'GOLD' %THEN SET_PTR = GOLD_DESC
	%ELSE %IF SET_STATE EQL 'BLUE' %THEN SET_PTR = BLUE_DESC
	%FI %FI %FI;


	! Set up the string descriptors for the key-name and the command
	! string parameters.  Also set up the attributes longword with the
	! noecho and noterminal flags.
	!
	KEY_DESC[DSC$W_LENGTH] = %CHARCOUNT(KEYNAME);
	KEY_DESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII KEYNAME);
	CMD_DESC[DSC$W_LENGTH] = %CHARCOUNT(COMMAND);
	CMD_DESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII COMMAND);
	ATTRIBUTES = FLAGS;


	! Call the Screen Management routine that defines a new keypad key.
	!
	STATUS = SMG$ADD_KEY_DEF(DBG$GL_KEY_TABLE_ID, KEY_DESC, .IF_PTR,
					ATTRIBUTES, CMD_DESC, .SET_PTR);
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	END %;

GLOBAL ROUTINE DBG$KEY_INITIALIZE: NOVALUE =
!
! FUNCTION
!	This routine initializes the keypad by creating all of the "built-in"
!	predeclared keypad definitions.  Each key definition is done by a call
!	on the KEYPAD_DEF macro which then sets up the appropriate call on the
!	SMG$ADD_KEY_DEF screen management routine to actually add the keypad
!	definition.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LITERAL
	DEFAULT		= 0,		! The default keypad state (no color)
	GOLD		= 1,		! The GOLD keypad state
	BLUE		= 2;		! The BLUE keypad state

    LITERAL
	ECHO_TERM	= 2,		! Echo command and terminate input
	NOECHO_TERM	= 3,		! Do not echo, but terminate input
	ECHO_NOTERM	= 0;		! Echo, but do not terminate input

    LOCAL
	ATTRIBUTES,			! Longword containing attribute flags
	BLUE_DESC: BLOCK[8,BYTE],	! String descriptor for BLUE keyword
	CMD_DESC: BLOCK[8,BYTE],	! DEBUG command string descriptor
	GOLD_DESC: BLOCK[8,BYTE],	! String descriptor for GOLD keyword
	IF_PTR,				! Pointer to If-state string descriptor
	KEY_DESC: BLOCK[8,BYTE],	! Keyname string descriptor
	SET_PTR,			! Pointer to Set-state string descriptor
	STATUS;				! Status code from the SMG routine


    ! Initialize all the string descriptors.
    !
    GOLD_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    GOLD_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    GOLD_DESC[DSC$W_LENGTH] = 4;
    GOLD_DESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII 'GOLD');
    BLUE_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    BLUE_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    BLUE_DESC[DSC$W_LENGTH] = 4;
    BLUE_DESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII 'BLUE');
    KEY_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    KEY_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    CMD_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    CMD_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;


    ! Define all "built-in" keypad keys which are pre-defined by DEBUG.
    ! First define the color keys GOLD and BLUE.
    !
    KEYPAD_DEF(,       'PF1', ECHO_NOTERM,   '', 'GOLD');
    KEYPAD_DEF('GOLD', 'PF1', ECHO_NOTERM,   '', 'GOLD');
    KEYPAD_DEF('BLUE', 'PF1', ECHO_NOTERM,   '', 'GOLD');
    KEYPAD_DEF(,       'PF4', ECHO_NOTERM,   '', 'BLUE');
    KEYPAD_DEF('BLUE', 'PF4', ECHO_NOTERM,   '', 'BLUE');
    KEYPAD_DEF('GOLD', 'PF4', ECHO_NOTERM,   '', 'BLUE');


    ! Define the PF2 and PF3 keys in the first row of keypad keys.
    !
    KEYPAD_DEF(,       'PF2', ECHO_TERM,     'Help Keypad Nocolor');
    KEYPAD_DEF('GOLD', 'PF2', ECHO_TERM,     'Help Keypad Gold');
    KEYPAD_DEF('BLUE', 'PF2', ECHO_TERM,     'Help Keypad Blue');
    KEYPAD_DEF(,       'PF3', ECHO_TERM,     'Set Mode Screen');
    KEYPAD_DEF('GOLD', 'PF3', ECHO_TERM,     'Set Mode Noscreen');
    KEYPAD_DEF('BLUE', 'PF3', NOECHO_TERM,   'Display/Generate');


    ! Define the second row of keypad keys (keys 7, 8, 9, and MINUS).
    !
    KEYPAD_DEF(,       'KP8', NOECHO_TERM,   'Scroll/Up');
    KEYPAD_DEF('GOLD', 'KP8', NOECHO_TERM,   'Scroll/Top');
    KEYPAD_DEF('BLUE', 'KP8', ECHO_NOTERM,   'Scroll/Up ');
    KEYPAD_DEF(,       'KP9', NOECHO_TERM,   'Display %Nextdisp');
    KEYPAD_DEF(,       'MINUS', NOECHO_TERM,
			'Display %Nextdisp At Fs; Select/Scroll %Curdisp');
    KEYPAD_DEF('BLUE', 'MINUS', NOECHO_TERM,
			'Display Src At H1, Out At H2; Select/Scroll Src');


    ! Display the third row of keypad keys (keys 4, 5, 6, and COMMA).
    !
    KEYPAD_DEF(,       'KP4', NOECHO_TERM,   'Scroll/Left');
    KEYPAD_DEF('GOLD', 'KP4', NOECHO_TERM,   'Scroll/Left:132');
    KEYPAD_DEF('BLUE', 'KP4', ECHO_NOTERM,   'Scroll/Left ');
    KEYPAD_DEF(,       'KP5', NOECHO_TERM,   'Examine/Source .0\%PC');
    KEYPAD_DEF('GOLD', 'KP5', ECHO_TERM,     'Show Calls');
    KEYPAD_DEF('BLUE', 'KP5', ECHO_TERM,     'Show Calls 3');
    KEYPAD_DEF(,       'KP6', NOECHO_TERM,   'Scroll/Right');
    KEYPAD_DEF('BLUE', 'KP6', ECHO_NOTERM,   'Scroll/Right ');
    KEYPAD_DEF(,       'COMMA', ECHO_TERM,   'Go');


    ! Define the fourth row of keypad keys (keys 1, 2, and 3).
    !
    KEYPAD_DEF(,       'KP1', ECHO_TERM,     'Examine');
    KEYPAD_DEF(,       'KP2', NOECHO_TERM,   'Scroll/Down');
    KEYPAD_DEF('GOLD', 'KP2', NOECHO_TERM,   'Scroll/Bottom');
    KEYPAD_DEF('BLUE', 'KP2', ECHO_NOTERM,   'Scroll/Down ');
    KEYPAD_DEF(,       'KP3', NOECHO_TERM,   'Select/Scroll %Nextscroll');
    KEYPAD_DEF('GOLD', 'KP3', NOECHO_TERM,   'Select/Output %Nextoutput');
    KEYPAD_DEF('BLUE', 'KP3', NOECHO_TERM,   'Select/Source %Nextsource');


    ! Define the fifth row of keypad keys (keys 0 and PERIOD).
    !
    KEYPAD_DEF(,       'KP0', ECHO_TERM,     'Step');
    KEYPAD_DEF('GOLD', 'KP0', ECHO_TERM,     'Step/Into');
    KEYPAD_DEF('BLUE', 'KP0', ECHO_TERM,     'Step/Over');
    KEYPAD_DEF(,       'PERIOD', ECHO_NOTERM, '');
    KEYPAD_DEF('GOLD', 'PERIOD', ECHO_NOTERM, '');
    KEYPAD_DEF('BLUE', 'PERIOD', ECHO_NOTERM, '');


    ! Define the meanings of the control characters we use.
    !
    KEYPAD_DEF(,       'CTRLW', NOECHO_TERM, 'Display/Refresh');
    KEYPAD_DEF('GOLD', 'CTRLW', NOECHO_TERM, 'Display/Refresh');
    KEYPAD_DEF('BLUE', 'CTRLW', NOECHO_TERM, 'Display/Refresh');


    ! Define some of the special keys found on the LK201 keyboard.  These
    ! keys are not available on the VT100.
    !
    KEYPAD_DEF(,       'HELP', ECHO_TERM, 'Help Keypad Summary');
    KEYPAD_DEF(,       'PREV_SCREEN', NOECHO_TERM, 'Scroll/Up');
    KEYPAD_DEF(,       'NEXT_SCREEN', NOECHO_TERM, 'Scroll/Down');
    KEYPAD_DEF(,       'SELECT', NOECHO_TERM, 'Select/Scroll %Nextscroll');


    ! All built-in keypad keys have been defined.  Now return.
    !
    RETURN;

    END;

ROUTINE DBG$SCR_CREATE_DISPLAY(NAMEPTR, KIND, WPTR, SIZE, CONTENT_PTR) =
!
! FUNCTION
!	This routine creates a new screen display.  It accepts the name of
!	the new display and its initial attributes as input.  If a display
!	by the same name already exists, an error is signalled, but other-
!	wise this routine creates a Screen Display Entry for the new display
!	and fills the display name and the other attributes into the Display
!	Entry.  The new display is then appended to the Screen Display List.
!
! INPUTS
!	NAMEPTR	- A pointer to the name of the display to be created.  The
!		  name is represented as a Counted ASCII string.
!
!	KIND	- The kind of display to be created.  This basically refers
!		  to how the contents are generated: it may be NORMAL, SOURCE,
!		  DO, etc.
!
!	WPTR	- A pointer to a Screen Window Entry.  This Window Entry
!		  defines the initial screen window for the new display.
!
!	SIZE	- The maximum size of the display in text lines.  If more
!		  than SIZE lines of text are later generated for this
!		  display, the oldest lines are discarded so that at most
!		  SIZE lines are kept at any one time.
!
!	CONTENT_PTR - A pointer to the DEBUG command list which determines
!		  the contents of this display if this is an automatically
!		  updated display.  If this is not an automatically updated
!		  display according to the KIND parameter, then CONTENT_PTR
!		  is ignored and should be zero.
!
! OUTPUTS
!	A pointer to the created Screen Display Entry is returned as this
!		  routine's value.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC display name
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to Screen Window Entry

    LOCAL
	BLINK: REF DBG$DISP_ENTRY,	! Pointer to last Screen Display Entry
					!      on the Screen Display List
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to new Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to label Display Line Entry
	FLINK: REF DBG$DISP_ENTRY;	! Pointer to the list head for the
					!      Screen Display List



    ! See if a display by the specified name already exists.  If it does, we
    ! signal an error and do not allow the new display to be created.
    !
    DISPTR = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
    IF .DISPTR NEQ 0 THEN SIGNAL(DBG$_DISPEXISTS, 1, .NAMEPTR);


    ! Allocate a memory block for the new Screen Display Entry and fill in all
    ! the relevant fields of that entry.
    !
    DISPTR = DBG$GET_MEMORY(DBG$K_DISP_ENTSIZE + (.NAMEPTR[0] + %UPVAL)/%UPVAL);
    DISPTR[DBG$B_DISP_KIND] = .KIND;
    DISPTR[DBG$W_DISP_RBEG] = .WPTR[DBG$W_WINDOW_RBEG];
    DISPTR[DBG$W_DISP_RLEN] = .WPTR[DBG$W_WINDOW_RLEN];
    DISPTR[DBG$W_DISP_CBEG] = .WPTR[DBG$W_WINDOW_CBEG];
    DISPTR[DBG$W_DISP_CLEN] = .WPTR[DBG$W_WINDOW_CLEN];
    DISPTR[DBG$W_DISP_DROW] = 1;
    DISPTR[DBG$W_DISP_DCOL] = 1;
    DISPTR[DBG$W_DISP_MAX_LINECNT] = MAX(1, .SIZE);
    DISPTR[DBG$V_DISP_NEWDISP] = TRUE;
    DISPTR[DBG$V_DISP_INVSCR] = TRUE;
    DISPTR[DBG$L_DISP_MARKLINE] = -1;
    DISPTR[DBG$L_DISP_CMDLIST] = .CONTENT_PTR;
    CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], DISPTR[DBG$A_DISP_NAME]);


    ! Initialize the list head for the list of Display Line Entries.  This
    ! sets up an empty Line Entry list.
    !
    DISPTR[DBG$L_DISP_START_LINE_PTR] = DISPTR[DBG$L_DISP_START_LINE_PTR];
    DISPTR[DBG$L_DISP_END_LINE_PTR] = DISPTR[DBG$L_DISP_START_LINE_PTR];


    ! Link the new Screen Display Entry into the Screen Display List.  The new
    ! entry is linked in at the end of the list.  Then return.
    !
    FLINK = DBG$SCR_DISPLAY_LIST;
    BLINK = .FLINK[DBG$L_DISP_BLINK];
    DISPTR[DBG$L_DISP_FLINK] = .FLINK;
    DISPTR[DBG$L_DISP_BLINK] = .BLINK;
    FLINK[DBG$L_DISP_BLINK] = .DISPTR;
    BLINK[DBG$L_DISP_FLINK] = .DISPTR;
    RETURN .DISPTR;

    END;

ROUTINE DBG$SCR_CREATE_TEMP_WINDOW(RBEG, RLEN, CBEG, CLEN) =
!
! FUNCTION
!	This routine creates a Temporary Screen Window Entry.  A "temporary"
!	Screen Window Entry is a Screen Window Entry created in temporary
!	memory in which the window name is null.  Such entries are used for
!	all unnamed windows used by DEBUG or specified by the user, that is
!	for all window which are not named and put on the Screen Window List.
!	All Temporary Screen Window Entries disappear at the end of the pro-
!	cessing of the current command.
!
! INPUTS
!	RBEG	- The beginning row location on the screen of this window.
!		  This value must be 1 or larger.
!
!	RLEN	- The row length (height) in lines of this window.
!		  This value must be 1 or larger.
!
!	CBEG	- The beginning column location on the screen of this window.
!		  This value must be 1 or larger.
!
!	CLEN	- The column length (width) in print positions of this window.
!		  This value must be 1 or larger.
!
! OUTPUTS
!	A pointer to the new Temporary Screen Window Entry is returned as the
!		  routine's value.
!

    BEGIN

    LOCAL
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to temporary Window Entry



    ! Check that the window parameters have valid values.
    !
    IF (.RBEG LSS 1) OR (.RLEN LSS 1) OR
       (.CBEG LSS 1) OR (.CLEN LSS 1)
    THEN
	$DBG_ERROR('DBGSCREEN\CREATE_TEMP_WINDOW');


    ! Create a Temporary Screen Window Entry and fill in its contents.  Then
    ! return the address of the new Screen Window Entry to the caller.
    !
    WPTR = DBG$GET_TEMPMEM(DBG$K_WINDOW_ENTSIZE + 1);
    WPTR[DBG$W_WINDOW_RBEG] = .RBEG;
    WPTR[DBG$W_WINDOW_RLEN] = .RLEN;
    WPTR[DBG$W_WINDOW_CBEG] = .CBEG;
    WPTR[DBG$W_WINDOW_CLEN] = .CLEN;
    RETURN .WPTR;

    END;

ROUTINE DBG$SCR_CREATE_WINDOW(NAMEPTR, RBEG, RLEN, CBEG, CLEN) =
!
! FUNCTION
!	This routine creates a Screen Window Entry.  It accepts a new window
!	name and the window parameters for a new screen window as input,
!	creates a Screen Window Entry for such a window, and adds the Window
!	Entry to the Screen Window List.  If a previous definition for a window
!	by the same name already exists on the Screen Window List, that previ-
!	ous entry is deleted before the new entry is added to the list.
!
! INPUTS
!	NAMEPTR	- A pointer to the Counted ASCII name of the screen window
!		  to be created.
!
!	RBEG	- The beginning row location on the screen of this window.
!		  This value must be 1 or larger.
!
!	RLEN	- The row length (height) in lines of this window.
!		  This value must be 1 or larger.
!
!	CBEG	- The beginning column location on the screen of this window.
!		  This value must be 1 or larger.
!
!	CLEN	- The column length (width) in print positions of this window.
!		  This value must be 1 or larger.
!
! OUTPUTS
!	A pointer to the created Screen Window Entry is returned as the
!		  routine's value.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to ASCIC name for window

    LOCAL
	BLINK: REF DBG$WINDOW_ENTRY,	! Pointer to the last Window Entry in
					!      the Screen Window List
	FLINK: REF DBG$WINDOW_ENTRY,	! Pointer to the list head for the
					!      Screen Window List
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to new Screen Window Entry



    ! Check that the window parameters have valid values.
    !
    IF (.RBEG LSS 1) OR (.RLEN LSS 1) OR
       (.CBEG LSS 1) OR (.CLEN LSS 1)
    THEN
	$DBG_ERROR('DBGSCREEN\CREATE_WINDOW');


    ! Create a new Screen Window Entry and fill in its contents.
    !
    WPTR = DBG$GET_MEMORY(DBG$K_WINDOW_ENTSIZE + (.NAMEPTR[0] + %UPVAL)/%UPVAL);
    CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], WPTR[DBG$A_WINDOW_NAME]);
    WPTR[DBG$W_WINDOW_RBEG] = .RBEG;
    WPTR[DBG$W_WINDOW_RLEN] = .RLEN;
    WPTR[DBG$W_WINDOW_CBEG] = .CBEG;
    WPTR[DBG$W_WINDOW_CLEN] = .CLEN;


    ! Now delete the current screen window by the same name, if one exists.
    !
    DBG$SCR_DELETE_WINDOW(.NAMEPTR);


    ! Finally link the new Window Entry into the Screen Window List.  The new
    ! entry is added to the end of the Screen Window List.  Then return a
    ! pointer to the new Window Entry.
    !
    FLINK = DBG$SCR_WINDOW_LIST;
    BLINK = .FLINK[DBG$L_WINDOW_BLINK];
    WPTR[DBG$L_WINDOW_FLINK] = .FLINK;
    WPTR[DBG$L_WINDOW_BLINK] = .BLINK;
    FLINK[DBG$L_WINDOW_BLINK] = .WPTR;
    BLINK[DBG$L_WINDOW_FLINK] = .WPTR;
    RETURN .WPTR;

    END;

ROUTINE DBG$SCR_DELETE_DISPLAY(NAMEPTR) =
!
! FUNCTION
!	This routine deletes a specified screen display.  It accepts the name
!	of the display to be deleted as input, looks up the corresponding
!	Screen Display Entry, and removes that entry from the Screen Display
!	List.  It then releases the Display Entry and all associated memory
!	blocks back to the DEBUG memory pool.
!
! INPUTS
!	NAMEPTR	- A pointer to the name of the display to be deleted.  The
!		  name is represented as a Counted ASCII string.
!
! OUTPUTS
!	One of the following two status codes is returned as the routine value:
!
!		STS$K_SUCCESS	- The specified display was deleted.
!
!		STS$K_SEVERE	- No display by the specified name exists and
!				  hence no display was deleted.
!

    BEGIN

    LOCAL
	BLINK: REF DBG$DISP_ENTRY,	! Pointer to the previous Display Entry
					!      on the Screen Display List
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Display Entry to delete
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to current Display Line Entry
	FLINK: REF DBG$DISP_ENTRY,	! Pointer to the next Display Entry on
					!      the Screen Display List
	NEXTDLE: REF DBG$DLINE_ENTRY;	! Pointer to next Display Line Entry



    ! Look up the Screen Display Entry to be deleted.  If no display by the
    ! desired name exists, return unsuccessfully.
    !
    DISPTR = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
    IF .DISPTR EQL 0 THEN RETURN STS$K_SEVERE;


    ! We found the desired display.  If this display is the selected current
    ! input, output, scrolling, or source display, remove that selection by
    ! zeroing the associated pointer to the Display Entry.
    !
    IF .DISPTR EQL .DBG$SCR_CURDISP_INPUT  THEN DBG$SCR_CURDISP_INPUT  = 0;
    IF .DISPTR EQL .DBG$SCR_CURDISP_OUTPUT THEN DBG$SCR_CURDISP_OUTPUT = 0;
    IF .DISPTR EQL .DBG$SCR_CURDISP_SCROLL THEN DBG$SCR_CURDISP_SCROLL = 0;
    IF .DISPTR EQL .DBG$SCR_CURDISP_SOURCE THEN DBG$SCR_CURDISP_SOURCE = 0;
    IF .DISPTR EQL .DBG$GL_SCREEN_ERROR   THEN DBG$GL_SCREEN_ERROR   = 0;
    IF .DISPTR EQL .DBG$GL_SCREEN_HISTORY THEN DBG$GL_SCREEN_HISTORY = 0;
    IF .DISPTR EQL .DBG$GL_SCREEN_INPUT   THEN DBG$GL_SCREEN_INPUT   = 0;
    IF .DISPTR EQL .DBG$GL_SCREEN_OUTPUT  THEN DBG$GL_SCREEN_OUTPUT  = 0;
    IF .DISPTR EQL .DBG$GL_SCREEN_SOURCE  THEN DBG$GL_SCREEN_SOURCE  = 0;


    ! Now unlink the Display Entry from the Screen Display List.
    !
    FLINK = .DISPTR[DBG$L_DISP_FLINK];
    BLINK = .DISPTR[DBG$L_DISP_BLINK];
    FLINK[DBG$L_DISP_BLINK] = .BLINK;
    BLINK[DBG$L_DISP_FLINK] = .FLINK;


    ! Release the DEBUG command list entry for this display (if any) back to
    ! the DEBUG memory pool.
    !
    IF .DISPTR[DBG$L_DISP_CMDLIST] NEQ 0
    THEN
	DBG$REL_MEMORY(.DISPTR[DBG$L_DISP_CMDLIST]);


    ! Release all the Screen Display Line Entries (all the actual text lines)
    ! that belong to this screen display.
    !
    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
    WHILE .DLEPTR NEQ DISPTR[DBG$L_DISP_START_LINE_PTR] DO
	BEGIN
	NEXTDLE = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .NEXTDLE;
	END;


    ! Release all error Display Line Entries (if any) attached to this Screen
    ! Display Entry.
    !
    DLEPTR = .DISPTR[DBG$L_DISP_ERROR_PTR];
    WHILE .DLEPTR NEQ 0 DO
	BEGIN
	NEXTDLE = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .NEXTDLE;
	END;


    ! Release all old-text Display Line Entries attached to this Display Entry.
    !
    DLEPTR = .DISPTR[DBG$L_DISP_OLDTXT_PTR];
    WHILE .DLEPTR NEQ 0 DO
	BEGIN
	NEXTDLE = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .NEXTDLE;
	END;


    ! Finally release the Screen Display Entry itself to the memory pool.  Then
    ! return successfully to the caller.
    !
    DBG$REL_MEMORY(.DISPTR);
    RETURN STS$K_SUCCESS;

    END;

ROUTINE DBG$SCR_DELETE_WINDOW(NAMEPTR) =
!
! FUNCTION
!	This routine deletes a specified screen window definition.  It accepts
!	the name of the window to be deleted as input, looks up the correspond-
!	ing Screen Window Entry, and removes that entry from the Screen Window
!	List.  It then releases the Window Entry back to the DEBUG memory pool.
!
! INPUTS
!	NAMEPTR	- A pointer to the name of the window to be deleted.  The name
!		  is represented as a Counted ASCII string.
!
! OUTPUTS
!	One of the following two status codes is returned as the routine value:
!
!		STS$K_SUCCESS	- The specified window definition was deleted.
!
!		STS$K_SEVERE	- No window by the specified name exists and
!				  hence no window was deleted.
!

    BEGIN

    LOCAL
	BLINK: REF DBG$WINDOW_ENTRY,	! Pointer to the previous Window Entry
					!      on the Screen Window List
	FLINK: REF DBG$WINDOW_ENTRY,	! Pointer to the next Window Entry on
					!      the Screen Window List
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to the Window Entry to delete



    ! Look up the Screen Window Entry to be deleted.  If no window by the
    ! desired name exists, return unsuccessfully.
    !
    WPTR = DBG$SCR_LOOKUP_WINDOW(.NAMEPTR);
    IF .WPTR EQL 0 THEN RETURN STS$K_SEVERE;


    ! We found the desired window definition.  Unlink that Window Entry from
    ! the Screen Window List.
    !
    FLINK = .WPTR[DBG$L_WINDOW_FLINK];
    BLINK = .WPTR[DBG$L_WINDOW_BLINK];
    FLINK[DBG$L_WINDOW_BLINK] = .BLINK;
    BLINK[DBG$L_WINDOW_FLINK] = .FLINK;


    ! Release the Screen Window Entry back to the memory pool.  Then return
    ! successfully to the caller.
    !
    DBG$REL_MEMORY(.WPTR);
    RETURN STS$K_SUCCESS;

    END;

ROUTINE DBG$SCR_DISPLAY_COMMAND(NAMEPTR, KIND, WPTR, SIZE,
						CONTENT_PTR, LIST_LOCATION) =
!
! FUNCTION
!	This routine performs the semantic actions of the DISPLAY command.  It
!	accepts the name of an existing display and its desired attributes as
!	input.  It then modifies all attributes of the display as specified by
!	the input parameters.  This may include changing the display's window,
!	its kind, its size, and its location on the display list (which affects
!	it "depth" on the screen relative to other displays).
!
! INPUTS
!	NAMEPTR	- A pointer to the name of the display to be displayed.  The
!		  name is represented as a Counted ASCII string.
!
!	KIND	- The new kind of the display (if the kind is being changed)
!		  or DBG$K_DISP_NOKIND (if the kind is not being changed).
!		  This basically refers to how the contents are generated:
!		  it may be NORMAL, SOURCE, DO, etc.
!
!	WPTR	- A pointer to a Screen Window Entry if the display's window
!		  parameters are being changed.  This Window Entry defines
!		  the new screen window for the display.  If the window is
!		  not being changed, WPTR is zero.
!
!	SIZE	- The new maximum size of the display in text lines (if the
!		  display size is being changed) or zero (if the size is not
!		  being changed).
!
!	CONTENT_PTR - A pointer to the DEBUG command list which determines
!		  the contents of this display if this is an automatically
!		  updated display.  If this is not an automatically updated
!		  display according to the KIND parameter or if the KIND
!		  parameter has the value DBG$K_DISP_NOKIND (no change to
!		  the display kind), then CONTENT_PTR is ignored and should
!		  be zero.
!
!	LIST_LOCATION - A parameter which specifies the display's location
!		  on the Screen Display List.  If LIST_LOCATION is zero, the
!		  list location is not changed.  If it is positive, the dis-
!		  play is put at the front of the list (so it occludes other
!		  displays on the screen), and if it is negative, the display
!		  is put at the back of the list (so that it is occluded by
!		  by any overlapping displays on the screen).
!
! OUTPUTS
!	A pointer to the Screen Display Entry of the specified display is
!		  returned as this routine's value.
!

    BEGIN

    MAP
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to Screen Window Entry

    LOCAL
	BLINK: REF DBG$DISP_ENTRY,	! Pointer to previous Screen Display
					!      Entry on the Screen Display List
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to new Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Display Line Entry to remove
	DL_BLINK: REF DBG$DLINE_ENTRY,	! Pointer to previous Display Line Entry
	DL_FLINK: REF DBG$DLINE_ENTRY,	! Pointer to next Display Line Entry
	FLINK: REF DBG$DISP_ENTRY,	! Pointer to next Screen Display Entry
					!      on the Screen Display List
	NEW_RLEN,			! New RLEN value when changing window
	OLD_RLEN;			! Old RLEN value when changing window



    ! Look up the desired display by its name.  If no such display exists,
    ! signal an error (no such screen display).
    !
    DISPTR = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
    IF .DISPTR EQL 0 THEN SIGNAL(DBG$_NOSUCHDISP, 1, .NAMEPTR);


    ! If the display kind is being changed, set the new values of the kind
    ! and command-list fields in the Screen Display Entry.  Note that we
    ! first clear the contents if we are switching from a source display to
    ! a non-source display or vice versa (normal and source Display Line
    ! Entries cannot be mixed in the same display).  We also release the old
    ! command-list block if one exists.
    !
    IF .KIND NEQ DBG$K_DISP_NOKIND
    THEN
	BEGIN


	! If we are changing from a non-source display to a source display, make
	! sure that this display is no longer the current input or output dis-
	! play.  Also clear its contents so that no normal Display Line Entries
	! are left in a source display.
	!
	IF (.DISPTR[DBG$B_DISP_KIND] NEQ DBG$K_DISP_SOURCE) AND
	   (.KIND EQL DBG$K_DISP_SOURCE)
	THEN
	    BEGIN
	    IF .DISPTR EQL .DBG$SCR_CURDISP_OUTPUT THEN DBG$SCR_CURDISP_OUTPUT = 0;
	    IF .DISPTR EQL .DBG$SCR_CURDISP_INPUT THEN DBG$SCR_CURDISP_INPUT = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_OUTPUT THEN DBG$GL_SCREEN_OUTPUT = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_INPUT THEN DBG$GL_SCREEN_INPUT = 0;
	    DBG$SCR_EMPTY_DISPLAY(.DISPTR);
	    END;


	! If we are changing from a source display to a non-source display, make
	! sure that this display is no longer the current source display.  Clear
	! its contents so that no source Display Line Entries are left in a nor-
	! mal output display.  Also zero out all source-display specific fields
	! in the Screen Display Entry.
	!
	IF (.DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_SOURCE) AND
	   (.KIND NEQ DBG$K_DISP_SOURCE)
	THEN
	    BEGIN
	    IF .DISPTR EQL .DBG$SCR_CURDISP_SOURCE THEN DBG$SCR_CURDISP_SOURCE = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_SOURCE THEN DBG$GL_SCREEN_SOURCE = 0;
	    DBG$SCR_EMPTY_DISPLAY(.DISPTR);
	    DISPTR[DBG$L_DISP_MODPTR] = 0;
	    DISPTR[DBG$L_DISP_CENTER] = 0;
	    DISPTR[DBG$L_DISP_MARKLINE] = 0;
	    DISPTR[DBG$L_DISP_MINLINE] = 0;
	    DISPTR[DBG$L_DISP_MAXLINE] = 0;
	    END;


	! Remove the old DEBUG command list, if present.  The change the Display
	! Entry's kind field and set the new DEBUG command list address.
	!
	IF .DISPTR[DBG$L_DISP_CMDLIST] NEQ 0
	THEN
	    DBG$REL_MEMORY(.DISPTR[DBG$L_DISP_CMDLIST]);

	DISPTR[DBG$B_DISP_KIND] = .KIND;
	DISPTR[DBG$L_DISP_CMDLIST] = .CONTENT_PTR;
	END;


    ! If the display window parameters are being changed, pick up the new
    ! window parameter values from the specified Screen Window Entry.
    !
    IF .WPTR NEQ 0
    THEN
	BEGIN


	! Set the new values of the window parameters for this display.
	!
	OLD_RLEN = .DISPTR[DBG$W_DISP_RLEN];
	NEW_RLEN = .WPTR[DBG$W_WINDOW_RLEN];
	DISPTR[DBG$W_DISP_RBEG] = .WPTR[DBG$W_WINDOW_RBEG];
	DISPTR[DBG$W_DISP_CBEG] = .WPTR[DBG$W_WINDOW_CBEG];
	DISPTR[DBG$W_DISP_RLEN] = .WPTR[DBG$W_WINDOW_RLEN];
	DISPTR[DBG$W_DISP_CLEN] = .WPTR[DBG$W_WINDOW_CLEN];


	! Adjust the DROW value (window row location in the display text) and
	! the window start pointer to fit the new vertical size of the display.
	! Essentially we try to keep the window centered on the same text as
	! before.  We also invalidate the scrolling count since it is no longer
	! usable by the OUTPUT_SCREEN routine.
	!
	DISPTR[DBG$V_DISP_INVSCR] = TRUE;
	DISPTR[DBG$W_DISP_DROW] = MAX(1, MIN(
		.DISPTR[DBG$W_DISP_LINECNT] - .NEW_RLEN + 1,
		.DISPTR[DBG$W_DISP_DROW] + (.OLD_RLEN - .NEW_RLEN)/2));
	IF .DISPTR[DBG$W_DISP_LINECNT] GTR 0
	THEN
	    BEGIN
	    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
	    INCR I FROM 1 TO .DISPTR[DBG$W_DISP_DROW] - 1 DO
		DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];

	    DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;
	    END;

	END;


    ! If the display size (the maximum number of lines of text the display may
    ! contain) is being changed, set the new size in the Screen Display Entry
    ! and delete any existing lines which cause the line count to exceed the
    ! new maximum.  Note that we always delete the oldest lines first.  Note
    ! that the scrolling count is also invalidated.
    !
    IF .SIZE GTR 0
    THEN
	BEGIN
	DISPTR[DBG$W_DISP_MAX_LINECNT] = .SIZE;
	DISPTR[DBG$V_DISP_INVSCR] = TRUE;


	! Delete enough of the oldest lines to bring the display size down to
	! the new maximum size.
	!
	INCR I FROM .SIZE + 1 TO .DISPTR[DBG$W_DISP_LINECNT] DO
	    BEGIN


	    ! Delete the oldest line still in the display and decrement the
	    ! line count.
	    !
	    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
	    DL_FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	    DL_BLINK = .DLEPTR[DBG$L_DLINE_BLINK];
	    DL_FLINK[DBG$L_DLINE_BLINK] = .DL_BLINK;
	    DL_BLINK[DBG$L_DLINE_FLINK] = .DL_FLINK;
	    DBG$REL_MEMORY(.DLEPTR);
	    DISPTR[DBG$W_DISP_LINECNT] = .DISPTR[DBG$W_DISP_LINECNT] - 1;


	    ! Decrement DROW so that the current window position is maintained.
	    ! However, if lines in the current window are being deleted, we
	    ! adjust DROW and WINDOW_PTR accordingly.
	    !
	    DISPTR[DBG$W_DISP_DROW] = .DISPTR[DBG$W_DISP_DROW] - 1;
	    IF .DISPTR[DBG$W_DISP_DROW] LEQ 0
	    THEN
		BEGIN
		DISPTR[DBG$W_DISP_DROW] = 1;
		DISPTR[DBG$L_DISP_WINDOW_PTR] = .DISPTR[DBG$L_DISP_START_LINE_PTR];
		END;

	    END;

	END;


    ! If the list location of this Display Entry is to be changed, unlink it
    ! from the Screen Display List and then relink it into the proper place
    ! (either at the beginning or at the end of the list).
    !
    IF .LIST_LOCATION NEQ 0
    THEN
	BEGIN


	! Unlink the specified Screen Display Entry from the Display List.
	!
	FLINK = .DISPTR[DBG$L_DISP_FLINK];
	BLINK = .DISPTR[DBG$L_DISP_BLINK];
	FLINK[DBG$L_DISP_BLINK] = .BLINK;
	BLINK[DBG$L_DISP_FLINK] = .FLINK;


	! Determine the proper list location for reinserting the Display Entry.
	!
	BLINK = DBG$SCR_DISPLAY_LIST;
	IF .LIST_LOCATION GTR 0 THEN BLINK = .BLINK[DBG$L_DISP_BLINK];
	FLINK = .BLINK[DBG$L_DISP_FLINK];


	! Then reinsert the Display Entry into the Screen Display List.
	!
	DISPTR[DBG$L_DISP_FLINK] = .FLINK;
	DISPTR[DBG$L_DISP_BLINK] = .BLINK;
	FLINK[DBG$L_DISP_BLINK] = .DISPTR;
	BLINK[DBG$L_DISP_FLINK] = .DISPTR;
	END;


    ! If the display kind changed so it now is automatically updated, we need
    ! to regenerate its contents.  This is done by calling the screen display
    ! generation routine.
    !
    IF (.KIND EQL DBG$K_DISP_DO)     OR
       (.KIND EQL DBG$K_DISP_SOURCE) OR
       (.KIND EQL DBG$K_DISP_REGISTER)
    THEN
	DBG$SCR_GENERATE_SCREEN(.DISPTR);


    ! The DISPLAY command is fully processed.  Now return.
    !
    RETURN .DISPTR;

    END;

ROUTINE DBG$SCR_EMPTY_DISPLAY(DISPTR): NOVALUE =
!
! FUNCTION
!	This routine empties a screen display of its contents, meaning that
!	all text lines in the display are deleted.  When this routine returns,
!	the specified Screen Display Entry is still around with all its attri-
!	butes intact, but all text lines in the display (i.e., all Display Line
!	Entries) have been deleted and released back to the memory pool.
!
! INPUTS
!	DISPTR	- A pointer to the Screen Display Entry for the display whose
!		  contents are to be emptied.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	DISPTR: REF DBG$DISP_ENTRY;	! Pointer to Screen Display Entry

    LOCAL
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to current Display Line Entry
	FLINK: REF DBG$DLINE_ENTRY;	! Pointer to next Display Line Entry



    ! Clear out all scroll settings, all Display Line Entry pointers, and the
    ! line count in the Screen Display Entry.
    !
    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
    DISPTR[DBG$L_DISP_START_LINE_PTR] = DISPTR[DBG$L_DISP_START_LINE_PTR];
    DISPTR[DBG$L_DISP_END_LINE_PTR] = DISPTR[DBG$L_DISP_START_LINE_PTR];
    DISPTR[DBG$L_DISP_WINDOW_PTR] = 0;
    DISPTR[DBG$W_DISP_LINECNT] = 0;
    DISPTR[DBG$W_DISP_DROW] = 1;
    DISPTR[DBG$W_DISP_SCROLL] = 0;
    DISPTR[DBG$V_DISP_INVSCR] = TRUE;


    ! Then delete all Screen Display Line Entries by releasing them back to
    ! the memory pool.
    !
    WHILE .DLEPTR NEQ DISPTR[DBG$L_DISP_START_LINE_PTR] DO
	BEGIN
	FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .FLINK;
	END;


    ! Also release all Error Line Entries attached to the display.
    !
    DLEPTR = .DISPTR[DBG$L_DISP_ERROR_PTR];
    DISPTR[DBG$L_DISP_ERROR_PTR] = 0;
    WHILE .DLEPTR NEQ 0 DO
	BEGIN
	FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .FLINK;
	END;


    ! The display contents are now empty, so we return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_CANDISP_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the CANCEL DISPLAY command.  It accepts the
!	address of the Verb Node for the command as input and then extracts
!	the command parameters and executes the command.  The command param-
!	eters are either a list of displays to be cancelled, each represented
!	by a Noun Node, or the /ALL qualifier, represented by having no Noun
!	Nodes.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the CANCEL DISPLAY command
!		  to be executed.  The Verb Node along with its attached Noun
!		  Nodes contains all information picked up during the parsing
!		  of the command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to current Display Entry
	NOUN_NODE: REF DBG$NOUN_NODE;	! Pointer to current Noun Node



    ! If there are no Noun Nodes, then the /ALL qualifier was specified and all
    ! displays are to be cancelled.  Hence we loop to delete all entries on the
    ! Screen Display List until no such entries are left.  We then return.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    IF .NOUN_NODE EQL 0
    THEN
	BEGIN
	WHILE .DBG$SCR_DISPLAY_LIST[0] NEQ DBG$SCR_DISPLAY_LIST DO
	    BEGIN
	    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
	    DBG$SCR_DELETE_DISPLAY(DISPTR[DBG$A_DISP_NAME]);
	    END;

	RETURN;
	END;


    ! Noun Nodes are present, one for each specified display to cancel.  Loop
    ! through the Noun Nodes and delete each corresponding display.  Then
    ! return.
    !
    WHILE .NOUN_NODE NEQ 0 DO
	BEGIN
	DBG$SCR_DELETE_DISPLAY(.NOUN_NODE[DBG$L_NOUN_VALUE]);
	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_CANWIND_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the CANCEL WINDOW command.  It accepts the
!	address of the Verb Node for the command as input and then extracts
!	the command parameters and executes the command.  The command param-
!	eters are either a list of windows to be cancelled, each represented
!	by a Noun Node, or the /ALL qualifier, represented by having no Noun
!	Nodes.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the CANCEL WINDOW command
!		  to be executed.  The Verb Node along with its attached Noun
!		  Nodes contains all information picked up during the parsing
!		  of the command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to current Window Entry



    ! If there are no Noun Nodes, then the /ALL qualifier was specified and all
    ! windows are to be cancelled.  Hence we loop to delete all entries on the
    ! Screen Window List until no such entries are left.  We then return.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    IF .NOUN_NODE EQL 0
    THEN
	BEGIN
	WHILE .DBG$SCR_WINDOW_LIST[0] NEQ DBG$SCR_WINDOW_LIST DO
	    BEGIN
	    WPTR = .DBG$SCR_WINDOW_LIST[0];
	    DBG$SCR_DELETE_WINDOW(WPTR[DBG$A_WINDOW_NAME]);
	    END;

	RETURN;
	END;


    ! Noun Nodes are present, one for each specified window to cancel.  Loop
    ! through the Noun Nodes and delete each corresponding window.  Then
    ! return.
    !
    WHILE .NOUN_NODE NEQ 0 DO
	BEGIN
	DBG$SCR_DELETE_WINDOW(.NOUN_NODE[DBG$L_NOUN_VALUE]);
	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_DISPLAY_CMD(VERB_NODE, SET_FLAG): NOVALUE =
!
! FUNCTION
!	This routine executes the DISPLAY and SET DISPLAY commands.  It
!	accepts the address of a Verb Node for the command as input and
!	it extracts the command parameters so that the command can be
!	executed.  Since DISPLAY and SET DISPLAY are very similar commands
!	in their semantic effects, most processing for these two commands
!	is identical, with the differences special-cased as necessary.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the command to be executed.
!		  The Verb Node, along with its attached Adverb and Noun
!		  Nodes, contains all information picked up during the
!		  parsing of the command.
!
!	SET_FLAG - TRUE if the command to be executed is the SET DISPLAY
!		  command and FALSE if the command is the DISPLAY command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	ADVERB_NODE:			! Pointer to the Adverb Node with the
		REF DBG$ADVERB_NODE,	!      command qualifier information
	CLEAR_FLAG,			! Flag set for /CLEAR qualifier
	CONTENT_PTR,			! Pointer to DEBUG command list which
					!      defines display contents
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to current Display Entry
	FLAGWORD,			! Flag & size longword from Adverb Node
	GENERATE_ALL_FLAG,		! Flag set for /GENERATE all displays
	GENERATE_FLAG,			! Flag set for /GENERATE qualifier
	HIDE_FLAG,			! Flag set for /HIDE qualifier
	KIND,				! The display kind (content spec kind)
	LIST_LOCATION,			! Display list location (for /HIDE)
	MARK_FLAG,			! Flag set for /MARK_CHANGE qualifier
	NOMARK_FLAG,			! Flag set for /NOMARK_CHANGE qualifier
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC display name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node with
					!      display and attribute info
	REFRESH_FLAG,			! Flag set for DISPLAY/REFRESH command
	REMOVED_FLAG,			! Flag set for /REMOVED qualifier
	SIZE,				! Size of display (maximum lines)
    	TEMP,				! Parameter for SMG$SET_KEYPAD_MODE
	WPTR;				! Pointer to current Screen Window Entry



    ! Extract all the qualifier information from the command Adverb Node.
    !
    ADVERB_NODE = .VERB_NODE[DBG$L_VERB_ADVERB_PTR];
    FLAGWORD = .ADVERB_NODE[DBG$L_ADVERB_VALUE];
    REFRESH_FLAG = .FLAGWORD<V_(0)>;
    CLEAR_FLAG = .FLAGWORD<V_(1)>;
    GENERATE_ALL_FLAG = .FLAGWORD<V_(2)>;
    GENERATE_FLAG = .FLAGWORD<V_(3)>;
    HIDE_FLAG = .FLAGWORD<V_(4)>;
    MARK_FLAG = .FLAGWORD<V_(5)>;
    NOMARK_FLAG = .FLAGWORD<V_(6)>;
    REMOVED_FLAG = .FLAGWORD<V_(7)>;
    SIZE = .FLAGWORD<V_(16,16)>;


    ! If this is the DISPLAY/REFRESH command, process that command right away.
    ! There are no Noun Nodes for this command.  Note that we reset "applica-
    ! tion mode" on the terminal (activate the keypad keys) if keypad mode is
    ! set.
    !
    IF .REFRESH_FLAG
    THEN
	BEGIN
	INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	    OLD_VALID[.I] = FALSE;

    	IF .DBG$GB_KEYPAD_INPUT
	THEN
	    BEGIN
	    TEMP = 1;
	    SMG$SET_KEYPAD_MODE(DBG$GL_KEYBOARD_ID, TEMP);
	    END;

	RETURN;
	END;


    ! If this is the DISPLAY/GENERATE command without a display list, we also
    ! process the command right away as there are no Noun Nodes.  Here we
    ! regenerate the contents of all non-removed, automatically updated screen
    ! displays. 
    !
    IF .GENERATE_ALL_FLAG
    THEN
	BEGIN
	DBG$SCR_GENERATE_SCREEN(0);
	RETURN;
	END;


    ! If this is the SET DISPLAY command and no display size was specified,
    ! use the default display size.
    !
    IF .SET_FLAG AND (.SIZE EQL 0) THEN SIZE = 50;


    ! Loop through all displays specified on the command and take the appro-
    ! priate semantic action for each such display.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    WHILE .NOUN_NODE NEQ 0 DO
	BEGIN


	! Extract all the parameter values from the Noun Node.
	!
	NAMEPTR = .NOUN_NODE[DBG$L_NOUN_VALUE];
	WPTR = .NOUN_NODE[DBG$L_NOUN_VALUE2];
	KIND = .NOUN_NODE[DBG$L_NOUN_VALUE3];
	CONTENT_PTR = .NOUN_NODE[DBG$L_NOUN_VALUE4];


	! Refetch the mark-changes and generate flags--these flags are modified
	! in the loop and must therefore be reset here.
	!
	GENERATE_FLAG = .FLAGWORD<V_(3)>;
	MARK_FLAG = .FLAGWORD<V_(5)>;


	! Set the list location in the Screen Display List where the display
	! should be inserted.  This is determined by the /HIDE qualifier.
	!
	LIST_LOCATION = +1;
	IF .HIDE_FLAG THEN LIST_LOCATION = -1;


	! If this is a SET DISPLAY command, call CREATE_DISPLAY to create the
	! desired new display.
	!
	IF .SET_FLAG
	THEN
	    DISPTR = DBG$SCR_CREATE_DISPLAY(.NAMEPTR, .KIND,
						.WPTR, .SIZE, .CONTENT_PTR)


	! Otherwise, this is a DISPLAY command, so we call DISPLAY_COMMAND to
	! execute the desired semantics on the specified display.
	!
	ELSE
	    DISPTR = DBG$SCR_DISPLAY_COMMAND(.NAMEPTR, .KIND, .WPTR,
					.SIZE, .CONTENT_PTR, .LIST_LOCATION);


	! If this display was marked as removed but is being "unremoved" with
	! this DISPLAY command, set the generate flag.  This ensures that an
	! automatically updated display has its contents regenerated whenever
	! it is unremoved.
	!
	IF .DISPTR[DBG$V_DISP_REMOVE] AND (NOT .REMOVED_FLAG)
	THEN
	    GENERATE_FLAG = TRUE;


	! If this display kind is not (or is no longer) DBG$K_DISP_DO, clear
	! the mark-change flag in the display entry.  If the /MARK_CHANGE or
	! /NOMARK_CHANGE qualifier was also specified on this command, signal
	! an informational message.
	!
	IF .DISPTR[DBG$B_DISP_KIND] NEQ DBG$K_DISP_DO
	THEN
	    BEGIN
	    DISPTR[DBG$V_DISP_MARKFLG] = FALSE;
	    IF .MARK_FLAG OR .NOMARK_FLAG
	    THEN
		SIGNAL(DBG$_NOMARKCHNG, 1, DISPTR[DBG$A_DISP_NAME]);

	    MARK_FLAG = FALSE;
	    END;


	! Set the remove and mark-changes flags as appropriate.
	!
	DISPTR[DBG$V_DISP_REMOVE] = .REMOVED_FLAG;
	IF .MARK_FLAG THEN DISPTR[DBG$V_DISP_MARKFLG] = TRUE;
	IF .NOMARK_FLAG THEN DISPTR[DBG$V_DISP_MARKFLG] = FALSE;


	! If the display is being removed, remove any permanent pointers to
	! the display's Screen Display Entry.  This means that any SELECT
	! setting to this display is cancelled.
	!
	IF .REMOVED_FLAG
	THEN
	    BEGIN
	    IF .DISPTR EQL .DBG$SCR_CURDISP_INPUT  THEN DBG$SCR_CURDISP_INPUT  = 0;
	    IF .DISPTR EQL .DBG$SCR_CURDISP_OUTPUT THEN DBG$SCR_CURDISP_OUTPUT = 0;
	    IF .DISPTR EQL .DBG$SCR_CURDISP_SCROLL THEN DBG$SCR_CURDISP_SCROLL = 0;
	    IF .DISPTR EQL .DBG$SCR_CURDISP_SOURCE THEN DBG$SCR_CURDISP_SOURCE = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_ERROR   THEN DBG$GL_SCREEN_ERROR   = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_HISTORY THEN DBG$GL_SCREEN_HISTORY = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_INPUT   THEN DBG$GL_SCREEN_INPUT   = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_OUTPUT  THEN DBG$GL_SCREEN_OUTPUT  = 0;
	    IF .DISPTR EQL .DBG$GL_SCREEN_SOURCE  THEN DBG$GL_SCREEN_SOURCE  = 0;
	    DISPTR[DBG$V_DISP_INVSCR] = TRUE;
	    END;


	! If the /CLEAR qualifier was specified, clear the display's entire
	! contents so there are no lines of text in the display.  Also clear
	! out all SOURCE display module context information.
	!
	IF .CLEAR_FLAG
	THEN
	    BEGIN
	    DBG$SCR_EMPTY_DISPLAY(.DISPTR);
	    DISPTR[DBG$L_DISP_MODPTR] = 0;
	    DISPTR[DBG$L_DISP_CENTER] = 0;
	    DISPTR[DBG$L_DISP_MARKLINE] = 0;
	    DISPTR[DBG$L_DISP_MINLINE] = 0;
	    DISPTR[DBG$L_DISP_MAXLINE] = 0;
	    END;


	! If this is the SET DISPLAY command or if the /GENERATE qualifier was
	! specified on the DISPLAY command, generate the display contents for
	! automatically generated displays.
	!
	IF .SET_FLAG OR .GENERATE_FLAG THEN DBG$SCR_GENERATE_SCREEN(.DISPTR);


	! Link to the next Noun Node and loop.
	!
	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];

	END;				! End of loop over noun nodes (displays)


    ! The command processing is completed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SAVE_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SAVE command which saves the contents of an
!	existing display in a new display with a specified name.  It accepts
!	the address of a Verb Node for a SAVE command as input and it extracts
!	the command parameters so that the command can be executed.  To execute
!	the SAVE command, a new display of kind NORMAL or SOURCE is created,
!	after which the entire contents of the original display is copied to
!	the new display.  The new display also inherits the window attributes
!	and scrolling position of the original display.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the command to be executed.
!		  The Verb Node, along with its attached Noun Nodes, contains
!		  all information picked up during the parsing of the command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to the command Verb Node

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to existing Display Entry
	DIS_BLINK: REF DBG$DISP_ENTRY,	! Pointer to previous Display Entry
	DIS_FLINK: REF DBG$DISP_ENTRY,	! Pointer to next Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to existing Display Line Entry
	DL_BLINK: REF DBG$DLINE_ENTRY,	! Pointer to previous Display Line Entry
	DL_FLINK: REF DBG$DLINE_ENTRY,	! Pointer to next Display Line Entry
	HANDLER_DISPTR: VOLATILE,	! New Display Entry pointer for handler
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to new display name
	NEWDISP: REF DBG$DISP_ENTRY,	! Pointer to new Screen Display Entry
	NEWDLE: REF DBG$DLINE_ENTRY,	! Pointer to new Display Line Entry
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to the current Noun Node
	TEXTCNT,			! Number of text characters to copy
	TEXTPTR: REF VECTOR[,BYTE];	! Pointer to display line's text

    ENABLE
	HANDLER_EXECUTE_SAVE(		! Set up a handler for NOFREE condition
			HANDLER_DISPTR);!      and pass in new Display pointer



    ! Loop through all the Noun Nodes attached to the Verb Node.  Each Node
    ! Node corresponds to a SAVE specification to be executed.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    WHILE .NOUN_NODE NEQ 0 DO
	BEGIN


	! See if a display already exists that has the same name as the speci-
	! fied new display.  If it does, we signal an error and do not allow
	! the new display to be created.
	!
	DISPTR = DBG$SCR_LOOKUP_DISPLAY(.NOUN_NODE[DBG$L_NOUN_VALUE2]);
	IF .DISPTR NEQ 0
	THEN
	    SIGNAL(DBG$_DISPEXISTS, 1, .NOUN_NODE[DBG$L_NOUN_VALUE2]);


	! Pick up the parameters for the current SAVE specification and allo-
	! cate a Screen Display Entry for the new display to be created.
	!
	DISPTR = .NOUN_NODE[DBG$L_NOUN_VALUE];
	NAMEPTR = .NOUN_NODE[DBG$L_NOUN_VALUE2];
	HANDLER_DISPTR = 0;
	NEWDISP = DBG$GET_MEMORY(DBG$K_DISP_ENTSIZE + .NAMEPTR[0]/%UPVAL + 1);
	HANDLER_DISPTR = .NEWDISP;


	! Fill the display name and the display kind into the new Screen
	! Display Entry.  Note that the kind becomes NORMAL unless this is
	! a source display and that the DEBUG Command List pointer is
	! always left zeroed out.
	!
	CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], NEWDISP[DBG$A_DISP_NAME]);
	IF .DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_SOURCE
	THEN
	    NEWDISP[DBG$B_DISP_KIND] = DBG$K_DISP_SOURCE

	ELSE
	    NEWDISP[DBG$B_DISP_KIND] = DBG$K_DISP_NORMAL;


	! Fill in the remaining contents of the new Screen Display Entry.
	!
	NEWDISP[DBG$B_DISP_REND] = .DISPTR[DBG$B_DISP_REND];
	NEWDISP[DBG$W_DISP_FLAGS] = .DISPTR[DBG$W_DISP_FLAGS];
	NEWDISP[DBG$W_DISP_RBEG] = .DISPTR[DBG$W_DISP_RBEG];
	NEWDISP[DBG$W_DISP_RLEN] = .DISPTR[DBG$W_DISP_RLEN];
	NEWDISP[DBG$W_DISP_CBEG] = .DISPTR[DBG$W_DISP_CBEG];
	NEWDISP[DBG$W_DISP_CLEN] = .DISPTR[DBG$W_DISP_CLEN];
	NEWDISP[DBG$W_DISP_DROW] = .DISPTR[DBG$W_DISP_DROW];
	NEWDISP[DBG$W_DISP_DCOL] = .DISPTR[DBG$W_DISP_DCOL];
	NEWDISP[DBG$W_DISP_MAX_LINECNT] = .DISPTR[DBG$W_DISP_MAX_LINECNT];
	NEWDISP[DBG$L_DISP_START_LINE_PTR] = NEWDISP[DBG$L_DISP_START_LINE_PTR];
	NEWDISP[DBG$L_DISP_END_LINE_PTR] = NEWDISP[DBG$L_DISP_START_LINE_PTR];
	NEWDISP[DBG$L_DISP_MODPTR] = .DISPTR[DBG$L_DISP_MODPTR];
	NEWDISP[DBG$L_DISP_CENTER] = .DISPTR[DBG$L_DISP_CENTER];
	NEWDISP[DBG$L_DISP_MARKLINE] = .DISPTR[DBG$L_DISP_MARKLINE];
	NEWDISP[DBG$L_DISP_MINLINE] = .DISPTR[DBG$L_DISP_MINLINE];
	NEWDISP[DBG$L_DISP_MAXLINE] = .DISPTR[DBG$L_DISP_MAXLINE];


	! Mark the new display as being removed and invalidate its scrolling
	! count.
	!
	NEWDISP[DBG$V_DISP_REMOVE] = TRUE;
	NEWDISP[DBG$V_DISP_INVSCR] = TRUE;


	! Loop over the old display's Display Line Entries to make copies of
	! all such lines in the new display.
	!
	DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
	WHILE .DLEPTR NEQ DISPTR[DBG$L_DISP_START_LINE_PTR] DO
	    BEGIN


	    ! If this is a Source Display Line Entry, allocate another such
	    ! entry and fill in the fields specific to this kind of line entry.
	    !
	    IF .DLEPTR[DBG$V_DLINE_SOURCEFLG]
	    THEN
		BEGIN
		TEXTPTR = DLEPTR[DBG$A_DLINE_TEXT2];
		NEWDLE = DBG$GET_MEMORY(DBG$K_DLINE_ENTSIZE2
						+ .TEXTPTR[0]/%UPVAL + 1);
		NEWDLE[DBG$B_DLINE_REND] = .DLEPTR[DBG$B_DLINE_REND];
		NEWDLE[DBG$V_DLINE_SOURCEFLG] = TRUE;
		NEWDLE[DBG$W_DLINE_FILEID] = .DLEPTR[DBG$W_DLINE_FILEID];
		NEWDLE[DBG$L_DLINE_RECNUM] = .DLEPTR[DBG$L_DLINE_RECNUM];
		NEWDLE[DBG$L_DLINE_LINUM] = .DLEPTR[DBG$L_DLINE_LINUM];
		CH$MOVE(.TEXTPTR[0] + 1, TEXTPTR[0], NEWDLE[DBG$A_DLINE_TEXT2]);
		END


	    ! And for any other kind of display, we allocate a normal Display
	    ! Line Entry and fill in the line's text.  Note that we include
	    ! the rendition vector at the end of the text if there is one.
	    !
	    ELSE
		BEGIN
		TEXTPTR = DLEPTR[DBG$A_DLINE_TEXT];
		TEXTCNT = .TEXTPTR[0];
		IF .DLEPTR[DBG$V_DLINE_RENDFLG] THEN TEXTCNT = 2*.TEXTCNT;
		NEWDLE = DBG$GET_MEMORY(DBG$K_DLINE_ENTSIZE + .TEXTCNT/%UPVAL + 1);
		NEWDLE[DBG$B_DLINE_REND] = .DLEPTR[DBG$B_DLINE_REND];
		NEWDLE[DBG$V_DLINE_RENDFLG] = .DLEPTR[DBG$V_DLINE_RENDFLG];
		NEWDLE[DBG$B_DLINE_LENGTH] = .TEXTPTR[0];
		CH$MOVE(.TEXTCNT + 1, TEXTPTR[0], NEWDLE[DBG$A_DLINE_TEXT]);
		END;



	    ! If this is the first line in the display's screen window, set
	    ! the window pointer accordingly.
	    !
	    IF .DLEPTR EQL .DISPTR[DBG$L_DISP_WINDOW_PTR]
	    THEN
		NEWDISP[DBG$L_DISP_WINDOW_PTR] = .NEWDLE;


	    ! Link the new Display Line Entry into the Display Line Entry List
	    ! for the new display.  Also increment the display's line count.
	    !
	    DL_BLINK = .NEWDISP[DBG$L_DISP_END_LINE_PTR];
	    DL_FLINK = .DL_BLINK[DBG$L_DLINE_FLINK];
	    NEWDLE[DBG$L_DLINE_FLINK] = .DL_FLINK;
	    NEWDLE[DBG$L_DLINE_BLINK] = .DL_BLINK;
	    DL_FLINK[DBG$L_DLINE_BLINK] = .NEWDLE;
	    DL_BLINK[DBG$L_DLINE_FLINK] = .NEWDLE;
	    NEWDISP[DBG$W_DISP_LINECNT] = .NEWDISP[DBG$W_DISP_LINECNT] + 1;


	    ! Loop for the next Display Line Entry in the display.
	    !
	    DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];

	    END;			! End of Display Line Entry loop


	! Link the new, fully built Screen Display Entry onto the Screen
	! Display Entry List.
	!
	DIS_FLINK = DBG$SCR_DISPLAY_LIST;
	DIS_BLINK = .DIS_FLINK[DBG$L_DISP_BLINK];
	NEWDISP[DBG$L_DISP_FLINK] = .DIS_FLINK;
	NEWDISP[DBG$L_DISP_BLINK] = .DIS_BLINK;
	DIS_FLINK[DBG$L_DISP_BLINK] = .NEWDISP;
	DIS_BLINK[DBG$L_DISP_FLINK] = .NEWDISP;


	! The current SAVE specification is fully processed.  Link to the next
	! Noun Node and loop.
	!
	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];

	END;				! End of loop over Noun Nodes


    ! All SAVE specifications have been executed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SCROLL_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SCROLL command.  It accepts the address of
!	the verb node for the command as input and then extracts the command
!	parameters and executes the command.  Most of the real work of scrol-
!	ling the specified display is actually done by DBG$SCR_SCROLL_DISPLAY
!	which is called from this routine.
!
! INPUTS
!	VERB_NODE - A pointer to the verb node for the SCROLL command to be
!		  executed.  The verb node, along with its attached noun node,
!		  contains all information picked up during the parsing of the
!		  command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input verb node

    LOCAL
	AMOUNT,				! Amount to scroll specified display
	DIRECTION,			! Direction to scroll the display
	DISPID: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	NOUN_NODE: REF DBG$NOUN_NODE;	! Pointer to Noun Node with Display ID



    ! Get the scrolling direction and amount and the Display ID of the display
    ! to be scrolled.  These all come from the Noun Node.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    DISPID = .NOUN_NODE[DBG$L_NOUN_VALUE];
    DIRECTION = .NOUN_NODE[DBG$L_NOUN_VALUE2];
    AMOUNT = .NOUN_NODE[DBG$L_NOUN_VALUE3];


    ! Now scroll the selected display in the desired direction and in the
    ! desired amount.  Then return.
    !
    DBG$SCR_SCROLL_DISPLAY(.DISPID, .DIRECTION, .AMOUNT);
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SELECT_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SELECT command.  It accepts the address of
!	a verb node for the command as input, extracts the command parameters
!	from that node, and executes the semantics of the command.  The seman-
!	tics is to set the appropriate own variables (DBG$SCR_CURDISP_xxx) and
!	global variables (DBG$GL_SCREEN_xxx) to point to the selected display's
!	Screen Display Entry.
!
! INPUTS
!	VERB_NODE - A pointer to the verb node for the SELECT command to be
!		  executed.  The verb node along with its attached noun node
!		  contains all information picked up during the parsing of
!		  the command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	DISPID: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to Noun Node with parse info
	SELECT_BITS: BITVECTOR[32];	! Selection bits for different kinds



    ! Get the selection kind bits (for history, input, output, scroll, or
    ! source) and the Display ID of the selected display from the Noun Node.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    SELECT_BITS = .NOUN_NODE[DBG$L_NOUN_VALUE];
    DISPID = .NOUN_NODE[DBG$L_NOUN_VALUE2];


    ! Select a new history output display.  Only displays of the NORMAL kind
    ! are allowed to be history displays.
    !
    IF .SELECT_BITS[0]
    THEN
	BEGIN
	IF .DISPID NEQ 0
	THEN
	    BEGIN
	    IF .DISPID[DBG$B_DISP_KIND] NEQ DBG$K_DISP_NORMAL
	    THEN
		SIGNAL(DBG$_INVSELDIS, 1, DISPID[DBG$A_DISP_NAME]);

	    END;

	DBG$GL_SCREEN_HISTORY = .DISPID;
	END;


    ! Select a new command input display.  Only displays of kind NORMAL or DO
    ! are allowed to be input displays.
    !
    IF .SELECT_BITS[1]
    THEN
	BEGIN
	IF .DISPID NEQ 0
	THEN
	    BEGIN
	    IF (.DISPID[DBG$B_DISP_KIND] NEQ DBG$K_DISP_NORMAL) AND
	       (.DISPID[DBG$B_DISP_KIND] NEQ DBG$K_DISP_DO)
	    THEN
		SIGNAL(DBG$_INVSELDIS, 1, DISPID[DBG$A_DISP_NAME]);

	    END;

	DBG$SCR_CURDISP_INPUT = .DISPID;
	IF .DISPID EQL 0 THEN DBG$GL_SCREEN_INPUT = 0;
	IF .DBG$GL_SCREEN_MODE THEN DBG$GL_SCREEN_INPUT = .DISPID;
	END;


    ! Select a new command output display.  Only displays of kinds NORMAL or DO
    ! are allowed to be output displays.
    !
    IF .SELECT_BITS[2]
    THEN
	BEGIN
	IF .DISPID NEQ 0
	THEN
	    BEGIN
	    IF (.DISPID[DBG$B_DISP_KIND] NEQ DBG$K_DISP_NORMAL) AND
	       (.DISPID[DBG$B_DISP_KIND] NEQ DBG$K_DISP_DO)
	    THEN
		SIGNAL(DBG$_INVSELDIS, 1, DISPID[DBG$A_DISP_NAME]);

	    END;

	DBG$SCR_CURDISP_OUTPUT = .DISPID;
	IF .DISPID EQL 0 THEN DBG$GL_SCREEN_OUTPUT = 0;
	IF .DBG$GL_SCREEN_MODE THEN DBG$GL_SCREEN_OUTPUT = .DISPID;
	END;


    ! Select a new default scrolling display for the SCROLL command.  Any kind
    ! of display can be scrolled.
    !
    IF .SELECT_BITS[3]
    THEN
	DBG$SCR_CURDISP_SCROLL = .DISPID;


    ! Select a new source output display.  Only displays with SOURCE content
    ! specifications can be selected as source output displays.
    !
    IF .SELECT_BITS[4]
    THEN
	BEGIN
	IF .DISPID NEQ 0
	THEN
	    BEGIN
	    IF .DISPID[DBG$B_DISP_KIND] NEQ DBG$K_DISP_SOURCE
	    THEN
		SIGNAL(DBG$_INVSELDIS, 1, DISPID[DBG$A_DISP_NAME]);

	    END;

	DBG$SCR_CURDISP_SOURCE = .DISPID;
	IF .DISPID EQL 0 THEN DBG$GL_SCREEN_SOURCE = 0;
	IF .DBG$GL_SCREEN_MODE THEN DBG$GL_SCREEN_SOURCE = .DISPID;
	END;


    ! The command processing is completed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SETTERM_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SET TERMINAL command.  The only information
!	the SET TERMINAL command can impart at present is the terminal width
!	via the /WIDTH:n qualifier.  This routine thus picks up the new termi-
!	nal width, stores it in the global variable DBG$SRC_TERM_WIDTH, and
!	invalidates all screen display lines currently on the screen to force
!	those lines to be rewritten using the new line width.  No attempt is
!	made to reset the terminal with through any escape sequence, however.
!	The global variable DBG$SRC_TERM_WIDTH controls the folding of all
!	print and source lines and the truncation of screen display output.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the SET TERMINAL command
!		  to be executed.  This Verb Node and the attached Noun Node
!		  contain all information picked up during the parsing of
!		  the command.
!
! OUTPUTS
!	NONE

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	NOUN_NODE: REF DBG$NOUN_NODE;	! Pointer to input Noun Node



    ! Extract the new terminal with from the input Noun Node.  If we are in
    ! Screen Mode, we also invalidate the current screen contents so the
    ! screen gets refreshed.  We then return.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    DBG$SRC_TERM_WIDTH = .NOUN_NODE[DBG$L_NOUN_VALUE];
    IF .DBG$GL_SCREEN_MODE
    THEN
	BEGIN
	INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	    OLD_VALID[.I] = FALSE;

	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SETWIND_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SET WINDOW command.  It accepts the address
!	of the Verb Node for the command as input and then extracts the command
!	parameters and executes the command.  The command parameters consist of
!	a window name and a window specification, all encoded in a Noun Node.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the SET WINDOW command to be
!		  executed.  The Verb Node along with its attached Noun Node
!		  contains all information picked up during the parsing of the
!		  command.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	CBEG,				! Beginning column location of window
	CLEN,				! Column length (width) of window
	COL_INFO,			! Encoded column parameters
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC window name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node
	RBEG,				! Beginning row location of window
	RLEN,				! Row length (height) of window
	ROW_INFO;			! Encoded row parameters



    ! Extract all the window parameters from the Noun Node.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    NAMEPTR = .NOUN_NODE[DBG$L_NOUN_VALUE];
    ROW_INFO = .NOUN_NODE[DBG$L_NOUN_VALUE2];
    RBEG = .ROW_INFO<W0_>;
    RLEN = .ROW_INFO<W1_>;
    COL_INFO = .NOUN_NODE[DBG$L_NOUN_VALUE3];
    CBEG = .COL_INFO<W0_>;
    CLEN = .COL_INFO<W1_>;


    ! Now allocate and build a Screen Window Entry for the new screen window.
    ! Then return.
    !
    DBG$SCR_CREATE_WINDOW(.NAMEPTR, .RBEG, .RLEN, .CBEG, .CLEN);
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SHODISP_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SHOW DISPLAY command.  It accepts the
!	address of the verb node for the command as input and then executes
!	the command.  Since there are no command parameters, the Verb Node
!	is actually ignored.  The command processing consists of going through
!	all displays on the Screen Display List and listing out the name and
!	attributes of each such display.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the SHOW DISPLAY command to
!		  be executed.  The Verb Node is actually ignored.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to current Display Entry
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to a Screen Window Entry



    ! If the Screen Display List is empty, print a message to that effect and
    ! return immediately.
    !
    IF .DBG$SCR_DISPLAY_LIST[0] EQL DBG$SCR_DISPLAY_LIST
    THEN
	BEGIN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'no displays defined'), 0);
	DBG$NEWLINE();
	RETURN;
	END;


    ! Loop through all displays in the Screen Display List and print out the
    ! name and attributes of each such display.
    !
    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
	BEGIN


	! Start by printing out the current display's name.
	!
	DBG$PRINT(UPLIT BYTE(%ASCIC 'display !AC'), DISPTR[DBG$A_DISP_NAME]);


	! Next print out the window name.  Here we search the Screen Window
	! List to see if there is a screen window with the same window param-
	! eters as those of the current display.  If so, we print out that
	! window's name.
	!
	WPTR = .DBG$SCR_WINDOW_LIST[0];
	WHILE .WPTR NEQ DBG$SCR_WINDOW_LIST DO
	    BEGIN
	    IF (.WPTR[DBG$W_WINDOW_RBEG] EQL .DISPTR[DBG$W_DISP_RBEG]) AND
	       (.WPTR[DBG$W_WINDOW_RLEN] EQL .DISPTR[DBG$W_DISP_RLEN]) AND
	       (.WPTR[DBG$W_WINDOW_CBEG] EQL .DISPTR[DBG$W_DISP_CBEG]) AND
	       (.WPTR[DBG$W_WINDOW_CLEN] EQL .DISPTR[DBG$W_DISP_CLEN])
	    THEN
		BEGIN
		DBG$PRINT(UPLIT BYTE(%ASCIC ' at !AC'), WPTR[DBG$A_WINDOW_NAME]);
		WPTR = 0;
		EXITLOOP;
		END;

	    WPTR = .WPTR[DBG$L_WINDOW_FLINK];
	    END;


	! If no window with the same window parameters could be found, print
	! out the window parameters as a string of numbers.  This situation
	! normally only occurs if the user cancelled the window definition
	! which was used to define the original display position.
	!
	IF .WPTR NEQ 0
	THEN
	    BEGIN				!<<-------- TEMPORARY ----------
	    IF .DBG$GL_DEVELOPER[7] THEN BEGIN	!<<-------- TEMPORARY ----------
	    DBG$PRINT(UPLIT BYTE(%ASCIC ' at (!SL,!SL,!SL,!SL)'),
			.DISPTR[DBG$W_DISP_RBEG], .DISPTR[DBG$W_DISP_RLEN],
			.DISPTR[DBG$W_DISP_CBEG], .DISPTR[DBG$W_DISP_CLEN]);
	    END ELSE BEGIN			!<<-------- TEMPORARY ----------
	    DBG$PRINT(UPLIT BYTE(%ASCIC ' at (!SL,!SL)'),	!<<-------------
			.DISPTR[DBG$W_DISP_RBEG], .DISPTR[DBG$W_DISP_RLEN]);!<--
	    END;				!<<-------- TEMPORARY ----------
	    END;				!<<-------- TEMPORARY ----------


	! Print out the maximum size of the display in lines.
	!
	DBG$PRINT(UPLIT BYTE(%ASCIC ', size = !SL'),
			.DISPTR[DBG$W_DISP_MAX_LINECNT]);


	! Print out the values of the removed and mark-changes flags if set.
	!
	IF .DISPTR[DBG$V_DISP_REMOVE]
	THEN
	    DBG$PRINT(UPLIT BYTE(%ASCIC ', removed'), 0);

	IF .DISPTR[DBG$V_DISP_MARKFLG]
	THEN
	    DBG$PRINT(UPLIT BYTE(%ASCIC ', mark changes'), 0);


	! Print out the display's kind and the associated DEBUG command list
	! (if any).
	!
	CASE .DISPTR[DBG$B_DISP_KIND] FROM DBG$K_DISP_MINKIND
						TO DBG$K_DISP_MAXKIND OF
	    SET


	    ! Handle the NORMAL kind.  Here there is no DEBUG command list so
	    ! we just print "kind = NORMAL" on the same line.
	    !
	    [DBG$K_DISP_NORMAL]:
		DBG$PRINT(UPLIT BYTE(%ASCIC ', kind = NORMAL'), 0);


	    ! Handle the DO kind.  Here we print out the DO command list.
	    ! The command list is printed on a separate line.
	    !
	    [DBG$K_DISP_DO]:
		BEGIN
    		LOCAL
    		    CMDPTR: REF VECTOR[,WORD];
		CMDPTR = .DISPTR[DBG$L_DISP_CMDLIST];
		DBG$NEWLINE();
		DBG$PRINT(UPLIT BYTE(%ASCIC '    kind = DO (!AD)'),
    		    .CMDPTR[0]-1, CMDPTR[1]);
		END;


	    ! Handle the SOURCE kind.  Here we print out the SOURCE command
	    ! list if there is one.  The command list is always printed on
	    ! a separate line.
	    !
	    [DBG$K_DISP_SOURCE]:
		BEGIN
		IF .DISPTR[DBG$L_DISP_CMDLIST] EQL 0
		THEN
		    DBG$PRINT(UPLIT BYTE(%ASCIC ', kind = SOURCE'), 0)

		ELSE
		    BEGIN
    		    LOCAL
    		     	CMDPTR: REF VECTOR[,WORD];
		    CMDPTR = .DISPTR[DBG$L_DISP_CMDLIST];
		    DBG$NEWLINE();
		    DBG$PRINT(UPLIT BYTE(%ASCIC '    kind = SOURCE (!AD)'),
    		    	.CMDPTR[0]-1, CMDPTR[1]);
		    END;

		END;


	    ! Handle the REGISTER display kind.  Simply print the kind on the
	    ! same line.
	    !
	    [DBG$K_DISP_REGISTER]:
		DBG$PRINT(UPLIT BYTE(%ASCIC ', kind = REGISTER'), 0);


	    ! Any other value is an internal DEBUG error.
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGSCREEN\EXECUTE_SHODISP_CMD');

	    TES;


	! Flush out this print line and loop for the next display.
	!
	DBG$NEWLINE();
	DISPTR = .DISPTR[DBG$L_DISP_FLINK];

	END;				! End of loop over Display List


    ! We are all done.  Return to the caller.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SHOSEL_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SHOW SELECT command.  It accepts the address
!	of the Verb Node for the command as input and then executes the command.
!	As there are no command parameters, the Verb Node is actually ignored.
!	The command simply prints out the display selections for the current
!	output display, the current scrolling display, and so on.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the SHOW SELECT command to
!		  be executed.  The Verb Node is actually ignored.
!
! OUTPUTS
!	NONE
!

    BEGIN

    BIND
	NONE_STRING = UPLIT BYTE(%ASCIC 'none');

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to selected Display Entry
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to display name string



    ! If screen mode is not set, say so before giving SELECT settings.
    !
    IF NOT .DBG$GL_SCREEN_MODE
    THEN
	BEGIN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'screen mode not set'), 0);
	DBG$NEWLINE();
	END;


    ! Print the header text.
    !
    DBG$PRINT(UPLIT BYTE(%ASCIC 'display selections:'), 0);
    DBG$NEWLINE();


    ! Print out the history SELECT setting.
    !
    IF .DBG$GL_SCREEN_HISTORY NEQ 0
    THEN
	BEGIN
	DISPTR = .DBG$GL_SCREEN_HISTORY;
	NAMEPTR = DISPTR[DBG$A_DISP_NAME];
	DBG$PRINT(UPLIT BYTE(%ASCIC '    history= !AC'), .NAMEPTR);
	DBG$NEWLINE();
	END;


    ! Print out the input SELECT setting.
    !
    IF .DBG$SCR_CURDISP_INPUT NEQ 0
    THEN
	BEGIN
	DISPTR = .DBG$SCR_CURDISP_INPUT;
	NAMEPTR = DISPTR[DBG$A_DISP_NAME];
	DBG$PRINT(UPLIT BYTE(%ASCIC '    input  = !AC'), .NAMEPTR);
	DBG$NEWLINE();
	END;


    ! Print out the output SELECT setting.
    !
    DISPTR = .DBG$SCR_CURDISP_OUTPUT;
    NAMEPTR = NONE_STRING;
    IF .DISPTR NEQ 0 THEN NAMEPTR = DISPTR[DBG$A_DISP_NAME];
    DBG$PRINT(UPLIT BYTE(%ASCIC '    output = !AC'), .NAMEPTR);
    DBG$NEWLINE();


    ! Print out the scrolling SELECT setting.
    !
    DISPTR = .DBG$SCR_CURDISP_SCROLL;
    NAMEPTR = NONE_STRING;
    IF .DISPTR NEQ 0 THEN NAMEPTR = DISPTR[DBG$A_DISP_NAME];
    DBG$PRINT(UPLIT BYTE(%ASCIC '    scroll = !AC'), .NAMEPTR);
    DBG$NEWLINE();


    ! Print out the source SELECT setting.
    !
    DISPTR = .DBG$SCR_CURDISP_SOURCE;
    NAMEPTR = NONE_STRING;
    IF .DISPTR NEQ 0 THEN NAMEPTR = DISPTR[DBG$A_DISP_NAME];
    DBG$PRINT(UPLIT BYTE(%ASCIC '    source = !AC'), .NAMEPTR);
    DBG$NEWLINE();


    ! All done--now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_EXECUTE_SHOWIND_CMD(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine executes the SHOW WINDOW command.  It accepts the address
!	of the Verb Node for the command as input and executes the command.
!
! INPUTS
!	VERB_NODE - A pointer to the Verb Node for the SHOW WINDOW command to
!		  be executed.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to current Window Entry



    ! If the Screen Window List is empty, print a message to that effect and
    ! return immediately.
    !
    IF .DBG$SCR_WINDOW_LIST[0] EQL DBG$SCR_WINDOW_LIST
    THEN
	BEGIN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'no windows defined'), 0);
	DBG$NEWLINE();
	RETURN;
	END;


    ! Loop through all Window Entries on the Screen Window List and print out
    ! the name and window parameters of each such screen window.
    !
    WPTR = .DBG$SCR_WINDOW_LIST[0];
    WHILE .WPTR NEQ DBG$SCR_WINDOW_LIST DO
	BEGIN


	! Print out the current window's name and window parameters.
	!
	DBG$PRINT(UPLIT BYTE(%ASCIC 'window !AC'), WPTR[DBG$A_WINDOW_NAME]);
	IF .DBG$GL_DEVELOPER[7] THEN BEGIN	!<<--------- TEMPORARY ---------
	DBG$PRINT(UPLIT BYTE(%ASCIC ' at (!SL,!SL,!SL,!SL)'),
		.WPTR[DBG$W_WINDOW_RBEG], .WPTR[DBG$W_WINDOW_RLEN],
		.WPTR[DBG$W_WINDOW_CBEG], .WPTR[DBG$W_WINDOW_CLEN]);
	END ELSE BEGIN				!<<--------- TEMPORARY ---------
	DBG$PRINT(UPLIT BYTE(%ASCIC ' at (!SL,!SL)'),			!<<-----
		.WPTR[DBG$W_WINDOW_RBEG], .WPTR[DBG$W_WINDOW_RLEN]);	!<<-----
	END;					!<<--------- TEMPORARY ---------


	! Flush out this print line and loop for the next Window Entry.
	!
	DBG$NEWLINE();
	WPTR = .WPTR[DBG$L_WINDOW_FLINK];

	END;				! End of loop over Window List


    ! All windows have been shown.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_GENERATE_SCREEN(DISPID): NOVALUE =
!
! FUNCTION
!	This routine is called when all automatically updated screen displays
!	are to have their contents regenerated.  It can also be called to
!	automatically regenerate the contents of a single specified display.
!	The way in which a display's contents is generated depends on the
!	display kind, but for a DO or SOURCE display it it accomplished by
!	adding the display's DEBUG command list to the Command Input Stream
!	in such a way that the output from that command list is redirected
!	to the desired display.
!
! INPUTS
!	DISPID	- If a single display is to have its contents automatically
!		  regenerated, DISPID is the Display ID (Screen Display Entry
!		  pointer) of that display.  If all automatically updated
!		  displays are to be regenerated, DISPTR is zero.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	BPTR: REF VECTOR[,WORD],	! Pointer to new command list buffer
	FLINK: REF DBG$DLINE_ENTRY,	! Pointer to next Error Line Entry
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to current Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Error Display Line Entry
	KIND,				! The kind of the current display
	TPTR: REF VECTOR[,WORD];	! Pointer to DEBUG command list buffer



    ! Set up a pointer to the first Screen Display Entry whose contents are to
    ! be regenerated.  Note that we go through the displays in reverse order
    ! since their DEBUG command lists will be stacked on the Command Input
    ! Stream and will be executed in Last-In First-Out (LIFO) order.
    !
    DISPTR = .DISPID;
    IF .DISPTR EQL 0 THEN DISPTR = .DBG$SCR_DISPLAY_LIST[1];


    ! Now loop for all displays on the Screen Display List to be updated.
    !
    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
	BEGIN


	! If the current display has an Error Line Entry List, throw away all
	! error Display Line Entries on that list.  (These errors apply to the
	! old display contents, not to the new contents we will generate.)
	!
	DLEPTR = .DISPTR[DBG$L_DISP_ERROR_PTR];
	DISPTR[DBG$L_DISP_ERROR_PTR] = 0;
	WHILE .DLEPTR NEQ 0 DO
	    BEGIN
	    FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	    DBG$REL_MEMORY(.DLEPTR);
	    DLEPTR = .FLINK;
	    END;


	! If the display still happens to have an old-text list of Display Line
	! Entries, clear out that list too and release all its entries.
	!
	DLEPTR = .DISPTR[DBG$L_DISP_OLDTXT_PTR];
	DISPTR[DBG$L_DISP_OLDTXT_PTR] = 0;
	WHILE .DLEPTR NEQ 0 DO
	    BEGIN
	    FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	    DBG$REL_MEMORY(.DLEPTR);
	    DLEPTR = .FLINK;
	    END;


	! Case on the kind of the current display.  Update the contents of only
	! those displays that can be automatically updated.  Note that we pre-
	! vent the automatic updating of removed displays by changing KIND.
	!
	KIND = .DISPTR[DBG$B_DISP_KIND];
	IF .DISPTR[DBG$V_DISP_REMOVE] THEN KIND = DBG$K_DISP_NOKIND;
	CASE .KIND FROM DBG$K_DISP_MINKIND TO DBG$K_DISP_MAXKIND OF
	    SET


	    ! Handle displays with DO command lists.  Here we add the display's
	    ! DO command list to the Command Input Stream with output redirected
	    ! to this display.  Note that we save the current output and source
	    ! displays in the CIS entry so that print and source output can be
	    ! directed back to those displays by DBG$NCIS_REMOVE at the end of
	    ! the command list processing.
	    !
	    [DBG$K_DISP_DO]:
		BEGIN


		! If changed lines are marked for this display, move the old
		! text of the display to the old-text list.  The old-text list
		! is made into a singly-linked, zero-terminated list.  The
		! new display contents are then cleared to zero lines.
		!
		IF .DISPTR[DBG$V_DISP_MARKFLG] AND
		   (.DISPTR[DBG$W_DISP_LINECNT] NEQ 0)
		THEN
		    BEGIN
		    DISPTR[DBG$L_DISP_OLDTXT_PTR] =
					.DISPTR[DBG$L_DISP_START_LINE_PTR];
		    DLEPTR = .DISPTR[DBG$L_DISP_END_LINE_PTR];
		    DLEPTR[DBG$L_DLINE_FLINK] = 0;
		    DISPTR[DBG$L_DISP_START_LINE_PTR] =
					DISPTR[DBG$L_DISP_START_LINE_PTR];
		    DISPTR[DBG$L_DISP_END_LINE_PTR] =
					DISPTR[DBG$L_DISP_START_LINE_PTR];
		    DISPTR[DBG$W_DISP_LINECNT] = 0;
		    DISPTR[DBG$L_DISP_WINDOW_PTR] = 0;
		    DISPTR[DBG$W_DISP_DROW] = 1;
		    DISPTR[DBG$W_DISP_SCROLL] = 0;
		    DISPTR[DBG$V_DISP_INVSCR] = TRUE;
		    END


		! Otherwise, simply empty the display of its present contents.
		!
		ELSE
		    DBG$SCR_EMPTY_DISPLAY(.DISPTR);


		! Create a copy of the DEBUG command list, add it to the Command
		! Input Stream, and redirect output to the present display.
		!
		TPTR = .DISPTR[DBG$L_DISP_CMDLIST];
		BPTR = DBG$GET_MEMORY((.TPTR[0]+5)/%UPVAL);
		CH$MOVE(.TPTR[0] + 2, TPTR[0], BPTR[0]);
		DBG$NCIS_ADD(BPTR[1], .BPTR[0], DBG$K_CIS_SCREEN, 0, 0, 0);
		DBG$GL_CISHEAD[CIS$L_SCREEN_OUTPUT] = .DBG$GL_SCREEN_OUTPUT;
		DBG$GL_CISHEAD[CIS$L_SCREEN_SOURCE] = .DBG$GL_SCREEN_SOURCE;
		DBG$GL_CISHEAD[CIS$L_SCREEN_ERROR] = .DBG$GL_SCREEN_ERROR;
		DBG$GL_CISHEAD[CIS$V_SCREEN_NOGO] = .DBG$GL_SCREEN_NOGO;
		DBG$GL_SCREEN_OUTPUT = .DISPTR;
		DBG$GL_SCREEN_SOURCE = 0;
		DBG$GL_SCREEN_ERROR = .DISPTR;
		DBG$GL_SCREEN_NOGO = TRUE;
		END;


	    ! Handle displays with SOURCE command lists.  (If the SOURCE display
	    ! has no command list, we do nothing.)  Here we add the display's
	    ! DEBUG command list to the Command Input Stream with source output
	    ! redirected to this display.  Note that we save the current output
	    ! and source displays in the CIS entry so that print and source
	    ! output can be directed back to those displays by DBG$NCIS_REMOVE
	    ! at the end of the command list processing.
	    !
	    [DBG$K_DISP_SOURCE]:
		BEGIN
		TPTR = .DISPTR[DBG$L_DISP_CMDLIST];
		IF .TPTR NEQ 0
		THEN
		    BEGIN
		    BPTR = DBG$GET_MEMORY((.TPTR[0]+5)/%UPVAL);
		    CH$MOVE(.TPTR[0] + 2, TPTR[0], BPTR[0]);
		    DBG$NCIS_ADD(BPTR[1], .BPTR[0], DBG$K_CIS_SCREEN, 0, 0, 0);
		    DBG$GL_CISHEAD[CIS$L_SCREEN_OUTPUT] = .DBG$GL_SCREEN_OUTPUT;
		    DBG$GL_CISHEAD[CIS$L_SCREEN_SOURCE] = .DBG$GL_SCREEN_SOURCE;
		    DBG$GL_CISHEAD[CIS$L_SCREEN_ERROR] = .DBG$GL_SCREEN_ERROR;
		    DBG$GL_CISHEAD[CIS$V_SCREEN_NOGO] = .DBG$GL_SCREEN_NOGO;
		    DBG$GL_SCREEN_OUTPUT = .DBG$SCR_CURDISP_OUTPUT;
		    DBG$GL_SCREEN_SOURCE = .DISPTR;
		    DBG$GL_SCREEN_ERROR = .DISPTR;
		    DBG$GL_SCREEN_NOGO = TRUE;
		    END;

		END;


	    ! Handle REGISTER displays.  Here we regenerate the display text
	    ! using the current register values.
	    !
	    [DBG$K_DISP_REGISTER]:
		REGISTER_DISPLAY(.DISPTR, DBG$RUNFRAME[DBG$L_USER_REGS]);


	    ! Any other display kind cannot be regenerated, so we do nothing.
	    ! Note that we get here for any removed displays as well.
	    !
	    [INRANGE, OUTRANGE]:
		0;

	    TES;


	! Loop for the next display unless only a single display was to be
	! regenerated.  Note that we loop in reverse order as mentioned above.
	!
	IF .DISPID NEQ 0 THEN EXITLOOP;
	DISPTR = .DISPTR[DBG$L_DISP_BLINK];

	END;				! End of loop over displays


    ! All requested displays have been regenerated.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_INITIALIZE: NOVALUE =
!
! FUNCTION
!	This routine initializes the Screen Debugging code.  It must be called
!	before any other Screen Debugging routines are called in order to set
!	up or initialize various data structures and locations needed by those
!	other routines.  This routine should be called exactly once.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN



    ! Initialize the Screen Display List and the Screen Window List list heads
    ! so that they constitute empty doubly linked lists.  This is done at run-
    ! time to keep DEBUG's code position-independent (PIC).
    !
    DBG$SCR_DISPLAY_LIST[0] = DBG$SCR_DISPLAY_LIST;
    DBG$SCR_DISPLAY_LIST[1] = DBG$SCR_DISPLAY_LIST;
    DBG$SCR_WINDOW_LIST[0] = DBG$SCR_WINDOW_LIST;
    DBG$SCR_WINDOW_LIST[1] = DBG$SCR_WINDOW_LIST;


    ! Create the predefined screen window definitions.
    !
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'FS'),   1, 19, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'H1'),   1,  9, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'H2'),  11,  9, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'T1'),   1,  6, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'T2'),   8,  6, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'T3'),  15,  5, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'T12'),  1, 13, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'T23'),  8, 12, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q1'),   1,  4, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q2'),   6,  4, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q3'),  11,  4, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q4'),  16,  4, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q123'), 1, 14, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q234'), 6, 14, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q23'),  6,  9, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'R1'),   1,  5, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'R2'),   7,  5, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'R3'),  13,  5, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'R12'),  1, 11, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'R23'),  7, 13, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'H12'),  1, 19, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'T123'), 1, 19, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q1234'),1, 19, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q12'),  1,  9, 1, 132);
    DBG$SCR_CREATE_WINDOW(UPLIT BYTE(%ASCIC 'Q34'), 11,  9, 1, 132);


    ! Mark all lines in the "old" screen image as invalid.  This ensures that
    ! DEBUG won't make any assumptions about the previous screen contents when
    ! first putting displays on the screen.
    !
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	OLD_VALID[.I] = FALSE;


    ! The initialization is complete.   Return to the caller.
    !
    RETURN;

    END;

ROUTINE DBG$SCR_LOOKUP_DISPLAY(NAMEPTR) =
!
! FUNCTION
!	This routine looks up the Screen Display Entry which corresponds to a
!	specified display name.  It accepts a Counted ASCII display name as
!	input and returns a pointer to the corresponding Screen Display Entry
!	as output.  If no display by that name exists, zero is returned.
!
!	This routine accepts several "pseudo-display" names, all of which
!	begin with a percent sign.  The pseudo-displays accepted are:
!
!		%CURDISP	- The last display on the Screen Display List.
!				  (The least occluded display.)
!		%NEXTDISP	- The first display on the Screen Display List.
!				  (The most occluded display.)
!		%NEXTSCROLL	- The next display on the Screen Display List
!				  after the current scrolling display.
!		%NEXTOUTPUT	- The next output display on the Screen Display
!				  List after the current output display.
!		%NEXTSOURCE	- The next source display on the Screen Display
!				  List after the current source display.
!
!	If the input display name is a pseudo-display name, it gets converted
!	into a pointer to the Screen Display Entry of the actual display that
!	matches the pseudo-display specification.  This is done by searching
!	the Screen Display List for the best match, always ignoring removed
!	displays in the search.
!
! INPUTS
!	NAMEPTR	- A pointer to the name of the display to be looked up.  The
!		  name is represented as a Counted ASCII string.
!
! OUTPUTS
!	A pointer to the Screen Display Entry of the named display is returned
!		  as the routine value.  (This pointer constitutes the display's
!		  Display ID.)  If no display by the specified name exists, zero
!		  is returned.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to ASCIC display name

    LOCAL
	DISPNAME: REF VECTOR[,BYTE],	! Pointer to current display's name
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to current Display Entry
	FIRST_DISP,			! Pointer to first display matching
					!      pseudo-display on display list
	PAST_CURRENT;			! Flag set if we are past current
					!      scrolling, etc. display in
					!      the display list



    ! See if the display name begins with a percent sign "%".  If so, this is a
    ! "pseudo-display", meaning that we must search the display list for the
    ! next display of a certain kind as determined by the pseudo-display name.
    !
    IF .NAMEPTR[0] EQL 0 THEN RETURN 0;
    IF .NAMEPTR[1] EQL '%'
    THEN
	BEGIN


	! If the %CURDISP pseudo-display is requested, we return a pointer to
	! the last (the most recent) display on the display list.  Note that we
	! scan the Screen Display List backwards to find the most recent non-
	! removed display.
	!
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1], 8, UPLIT BYTE(%ASCII '%CURDISP'), 0)
	THEN
	    BEGIN
	    DISPTR = .DBG$SCR_DISPLAY_LIST[1];
	    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
		BEGIN
		IF NOT .DISPTR[DBG$V_DISP_REMOVE] THEN RETURN .DISPTR;
		DISPTR = .DISPTR[DBG$L_DISP_BLINK];
		END;

	    RETURN 0;
	    END;


	! If the %NEXTDISP pseudo-display is requested, we return a pointer to
	! the first display on the display list.  This is the "next" display
	! after the last (most recent) display on the list.
	!
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1], 9, UPLIT BYTE(%ASCII '%NEXTDISP'), 0)
	THEN
	    BEGIN
	    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
	    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
		BEGIN
		IF NOT .DISPTR[DBG$V_DISP_REMOVE] THEN RETURN .DISPTR;
		DISPTR = .DISPTR[DBG$L_DISP_FLINK];
		END;

	    RETURN 0;
	    END;


	! If this is the %NEXTSCROLL pseudo-display, we find the next display
	! on the display list after the current scrolling display.  We make a
	! single scan of the display list, picking either the first display
	! after the current scrolling display or, if that does not exist, the
	! first display on the list.  In effect, the search wraps around at the
	! end of the list.
	!
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1],
				11, UPLIT BYTE(%ASCII '%NEXTSCROLL'), 0)
	THEN
	    BEGIN
	    FIRST_DISP = 0;
	    PAST_CURRENT = FALSE;
	    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
	    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
		BEGIN
		IF NOT .DISPTR[DBG$V_DISP_REMOVE]
		THEN
		    BEGIN
		    IF .FIRST_DISP EQL 0 THEN FIRST_DISP = .DISPTR;
		    IF .PAST_CURRENT THEN RETURN .DISPTR;
		    END;

		IF .DISPTR EQL .DBG$SCR_CURDISP_SCROLL THEN PAST_CURRENT = TRUE;
		DISPTR = .DISPTR[DBG$L_DISP_FLINK];
		END;

	    RETURN .FIRST_DISP;
	    END;


	! If this is the %NEXTOUTPUT pseudo-display, we find the next NORMAL
	! or DO display on the display list after the current output display.
	! We make a single scan of the display list, picking either the first
	! appropriate display after the current output display or the first
	! appropriate display on the list.  In effect, the search wraps around
	! at the end of the list.
	!
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1],
				11, UPLIT BYTE(%ASCII '%NEXTOUTPUT'), 0)
	THEN
	    BEGIN
	    FIRST_DISP = 0;
	    PAST_CURRENT = FALSE;
	    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
	    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
		BEGIN
		IF (NOT .DISPTR[DBG$V_DISP_REMOVE]) AND
		   ((.DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_NORMAL) OR
		    (.DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_DO))
		THEN
		    BEGIN
		    IF .FIRST_DISP EQL 0 THEN FIRST_DISP = .DISPTR;
		    IF .PAST_CURRENT THEN RETURN .DISPTR;
		    END;

		IF .DISPTR EQL .DBG$SCR_CURDISP_OUTPUT THEN PAST_CURRENT = TRUE;
		DISPTR = .DISPTR[DBG$L_DISP_FLINK];
		END;

	    RETURN .FIRST_DISP;
	    END;


	! If this is the %NEXTSOURCE pseudo-display, we find the next SOURCE
	! display on the display list after the current source output display.
	! We make a single scan of the display list, picking either the first
	! appropriate display after the current output display or the first
	! appropriate display on the list.  In effect, the search wraps around
	! at the end of the list.
	!
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1],
				11, UPLIT BYTE(%ASCII '%NEXTSOURCE'), 0)
	THEN
	    BEGIN
	    FIRST_DISP = 0;
	    PAST_CURRENT = FALSE;
	    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
	    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
		BEGIN
		IF (NOT .DISPTR[DBG$V_DISP_REMOVE]) AND
		   (.DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_SOURCE)
		THEN
		    BEGIN
		    IF .FIRST_DISP EQL 0 THEN FIRST_DISP = .DISPTR;
		    IF .PAST_CURRENT THEN RETURN .DISPTR;
		    END;

		IF .DISPTR EQL .DBG$SCR_CURDISP_SOURCE THEN PAST_CURRENT = TRUE;
		DISPTR = .DISPTR[DBG$L_DISP_FLINK];
		END;

	    RETURN .FIRST_DISP;
	    END;


	! If we got any other pseudo-display name, we return zero to indicate
	! that no such display exists.
	!
	RETURN 0;

	END;				! End of %pseudo-display code


    ! The display name is a normal name and does not begin with a percent sign.
    ! Loop through all the Display Entries in the Screen Display List until a
    ! Display Entry with the desired name is found.  When and if such a display
    ! is found, return a pointer to that Display Entry.
    !
    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
	BEGIN
	DISPNAME = DISPTR[DBG$A_DISP_NAME];
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1], .DISPNAME[0], DISPNAME[1], 0)
	THEN
	    RETURN .DISPTR;

	DISPTR = .DISPTR[DBG$L_DISP_FLINK];
	END;


    ! There is no display by the specified name.  Return zero.
    !
    RETURN 0;

    END;

ROUTINE DBG$SCR_LOOKUP_WINDOW(NAMEPTR) =
!
! FUNCTION
!	This routine looks up the Screen Window Entry which corresponds to a
!	specified window name.  It accepts a Counted ASCII window name as
!	input and returns a pointer to the corresponding Screen Window Entry
!	as output.  If no window by that name exists, zero is returned.
!
! INPUTS
!	NAMEPTR	- A pointer to the name of the window to be looked up.  The
!		  name is represented as a Counted ASCII string.
!
! OUTPUTS
!	A pointer to the Screen Window Entry of the named window is returned as
!		  the routine value.  If no window by the specified name exists,
!		  zero is returned.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to the ASCIC window name

    LOCAL
	WNAME: REF VECTOR[,BYTE],	! Pointer to current window's name
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to current Window Entry



    ! Loop through all the Window Entries in the Screen Window List until a
    ! Window Entry with the desired name is found.  When and if such a window
    ! is found, return a pointer to that Window Entry.
    !
    WPTR = DBG$SCR_WINDOW_LIST;
    WPTR = .WPTR[DBG$L_WINDOW_FLINK];
    WHILE .WPTR NEQ DBG$SCR_WINDOW_LIST DO
	BEGIN
	WNAME = WPTR[DBG$A_WINDOW_NAME];
	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1], .WNAME[0], WNAME[1], 0)
	THEN
	    RETURN .WPTR;

	WPTR = .WPTR[DBG$L_WINDOW_FLINK];
	END;


    ! There is no window by the specified name.  Return zero.
    !
    RETURN 0;

    END;

ROUTINE DBG$SCR_OUTPUT_LINE_MINIMAL(NEWLENGTH, NEWTEXT, NEWREND,
				OLDLENGTH, OLDTEXT, OLDREND, ROW): NOVALUE =
!
! FUNCTION
!	This routine outputs a line of text to a specified line on the terminal
!	screen.  The routine accepts both the new text (including rendition
!	attributes) and the old text currently on the screen as inputs.  It
!	then uses a minimal screen update algorithm to update the terminal
!	text with a minimal (more of less) number of characters being sent to
!	the terminal.
!
! INPUTS
!	NEWLENGTH - The length in characters of the new text line to be output
!		  to the screen.
!
!	NEWTEXT	- A pointer to the text of the new line to be output to the
!		  screen.
!
!	NEWREND	- A pointer to the rendition vector for the new text to be
!		  output to the screen.  This vector contains one byte of
!		  rendition bits for each character in the NEWTEXT vector.
!
!	OLDLENGTH - The length of the old text line currently on the screen.
!
!	OLDTEXT	- A pointer to the old text currently on the screen where the
!		  new text line will be written.  If the old text on the screen
!		  is unknown, the OLDTEXT pointer must be zero.
!
!	OLDREND	- A pointer to the rendition vector for the old text currently
!		  on the screen.
!
!	ROW	- The row (line number on the screen) of the line to be updated.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	NEWTEXT: REF VECTOR[,BYTE],	! Pointer to text of new screen line
	NEWREND: REF VECTOR[,BYTE],	! Pointer to renditions of new line
	OLDTEXT: REF VECTOR[,BYTE],	! Pointer to old text of line on screen
	OLDREND: REF VECTOR[,BYTE];	! Pointer to old renditions on screen

    LOCAL
	OUTEND,				! End index of string to output
	OUTSTART,			! Start index of string to output
	REND,				! Rendition codes for current section
	STATUS,				! Status code from screen routines
	TEXT_DESC: BLOCK[8,BYTE],	! Output string descriptor
	VALIDCOUNT;			! Number of valid characters in a row
					!      on the screen (in the old text)



    ! Initialize the output line string descriptor.
    !
    TEXT_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    TEXT_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;


    ! If the old screen contents is completely unknown (indicated by OLDTEXT
    ! being zero), the line is erased and then rewritten in its entirety.
    ! After that, we return.
    !
    IF .OLDTEXT EQL 0
    THEN
	BEGIN


	! Erase the current screen contents of the line.  If the new text has
	! zero length, we then return right away.
	!
	STATUS = SCR$SET_CURSOR(.ROW, 1);
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	STATUS = SCR$ERASE_LINE();
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	IF .NEWLENGTH LEQ 0 THEN RETURN;


	! Output the new text of the line.  Here we scan the line's rendition
	! codes and force a separate output operation each time the rendition
	! codes of the text change.
	!
	OUTSTART = 0;
	OUTEND = 0;
	REND = .NEWREND[0];
	WHILE TRUE DO
	    BEGIN
	    IF (.OUTEND GEQ .NEWLENGTH) OR (.NEWREND[.OUTEND] NEQ .REND)
	    THEN
		BEGIN
		TEXT_DESC[DSC$W_LENGTH] = .OUTEND - .OUTSTART;
		TEXT_DESC[DSC$A_POINTER] = NEWTEXT[.OUTSTART];
		STATUS = SCR$PUT_SCREEN(TEXT_DESC, .ROW, .OUTSTART + 1, .REND);
		IF NOT .STATUS THEN SIGNAL(.STATUS);
		IF .OUTEND GEQ .NEWLENGTH THEN EXITLOOP;
		OUTSTART = .OUTEND;
		REND = .NEWREND[.OUTSTART];
		END;

	    OUTEND = .OUTEND + 1;
	    END;

	RETURN;
	END;


    ! The old (current) contents of the line on the screen are known.  Hence
    ! we initialize all indecies, counters, and flags needed for the minimal
    ! screen update algorithm.
    !
    OUTSTART = 0;
    OUTEND = -1;
    VALIDCOUNT = 100;
    REND = .NEWREND[0];


    ! Loop through the text vector to be output to the screen to identify the
    ! sections of that text that must be updated on the screen.
    !
    INCR I FROM 0 TO .NEWLENGTH - 1 DO
	BEGIN


	! If the current character matches what already is on the screen, we
	! increment the count of the number of consecutive valid characters
	! on the screen but do no output.  Note that if the current character
	! has a different rendition than the beginning of the character block,
	! we set VALIDCOUNT to 100 to prevent characters of different rendi-
	! tions from being included in the same output operation.
	!
	IF (.I LSS .OLDLENGTH)             AND
	   (.NEWTEXT[.I] EQL .OLDTEXT[.I]) AND
	   (.NEWREND[.I] EQL .OLDREND[.I])
	THEN
	    BEGIN
	    IF .NEWREND[.I] NEQ .REND THEN VALIDCOUNT = 100;
	    VALIDCOUNT = .VALIDCOUNT + 1;
	    END


	! The current screen contents are invalid at this point.  Unless the
	! rendition is different or we just scanned past at least 5 consecutive
	! valid screen characters, we simply mark the current end position and
	! keep accumulating the text section to be output.  (Skipping over less
	! than 5 valid characters is not worth the cost of an extra cursor
	! positioning.)
	!
	ELSE IF (.NEWREND[.I] EQL .REND) AND (.VALIDCOUNT LSS 5)
	THEN
	    BEGIN
	    OUTEND = .I;
	    VALIDCOUNT = 0;
	    END


	! We are at the start of a new invalid text position on the screen.
	! Now output the text section we just scanned past, as delimited by
	! the OUTSTART and OUTEND indecies.  The screen contents of that
	! section is invalid, except possibly for small embedded sections of
	! valid characters (less than 5 in a row per embedded section).
	!
	ELSE
	    BEGIN
	    IF .OUTEND GEQ .OUTSTART
	    THEN
		BEGIN
		TEXT_DESC[DSC$W_LENGTH] = .OUTEND - .OUTSTART + 1;
		TEXT_DESC[DSC$A_POINTER] = NEWTEXT[.OUTSTART];
		STATUS = SCR$PUT_SCREEN(TEXT_DESC, .ROW, .OUTSTART + 1, .REND);
		IF NOT .STATUS THEN SIGNAL(.STATUS);
		END;

	    OUTSTART = .I;
	    OUTEND = .I;
	    REND = .NEWREND[.I];
	    VALIDCOUNT = 0;
	    END;

	END;				! End of character WHILE loop


    ! Write out the last text section which is invalid on the screen if there
    ! is such a section.
    !
    IF .OUTEND GEQ .OUTSTART
    THEN
	BEGIN
	TEXT_DESC[DSC$W_LENGTH] = .OUTEND - .OUTSTART + 1;
	TEXT_DESC[DSC$A_POINTER] = NEWTEXT[.OUTSTART];
	STATUS = SCR$PUT_SCREEN(TEXT_DESC, .ROW, .OUTSTART + 1, .REND);
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	END;


    ! Clear the tail end of the line if the new text for the line is shorter
    ! than the old screen contents for this line.
    !
    IF .OLDLENGTH GTR .NEWLENGTH
    THEN
	BEGIN
	STATUS = SCR$SET_CURSOR(.ROW, .NEWLENGTH + 1);
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	STATUS = SCR$ERASE_LINE();
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	END;


    ! The line has been updated on the screen.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_OUTPUT_SCREEN: NOVALUE =
!
! FUNCTION
!	This routine outputs the current pasteboard contents to the terminal
!	screen.  It is normally called just before prompting for user input
!	so that the screen is updated to show the results or consequences of
!	the last DEBUG command the user entered.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LITERAL
	WBUFSIZE = 256;			! Size in bytes of screen work buffer

    LOCAL
	BUFFER: VECTOR[132, BYTE],	! Buffer for screen output strings
	DCOL,				! Display column position for this line
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to current Display Line Entry
	END_LINE,			! Index of last line of scroll region
	LAST_USED_LINE,			! Index of last used line on screen
	N,				! Temporary index into output buffer
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to display name in ASCIC
	OLDTEXT,			! Pointer to old text for line or zero
	REGSIZE,			! Scrolling region size in lines
	RENDITION_LINE,			! Flag set for lines with rendition vector
	RENDPTR: REF VECTOR[,BYTE],	! Pointer to line's rendition vector
	REND_VECTOR: VECTOR[132,BYTE],	! Temporary vector of rendition codes
	R_INDEX,			! Rendition vector index (current index)
	R_START,			! Rendition vector index (start index)
	SCROLL_AMOUNT,			! Scrolling amount in lines (abs value)
	SCROLL_DOWN,			! Flag set if scroll direction is down
	START_LINE,			! Index of first line of scroll region
	STATUS,				! Status code returned by screen routines
	TEXTCNT,			! Number of characters in current line
	TEXT_DESCR: BLOCK[8,BYTE],	! String descriptor for screen text line
	TEXTPTR: REF VECTOR[,BYTE],	! Pointer to current line's ASCII text
	WORK_BUF: VECTOR[WBUFSIZE,BYTE],! Screen buffer mode work buffer
	WORK_BUF_DESCR: BLOCK[8,BYTE];	! String descriptor for work buffer



    ! Update the Pasteboard with the current contents and relative positions
    ! of all the displays on the Screen Display List.
    !
    DBG$SCR_UPDATE_PASTEBOARD();


    ! Set up screen buffering mode to optimize the screen output.
    !
    WORK_BUF_DESCR[DSC$B_CLASS] = DSC$K_CLASS_S;
    WORK_BUF_DESCR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    WORK_BUF_DESCR[DSC$W_LENGTH] = WBUFSIZE;
    WORK_BUF_DESCR[DSC$A_POINTER] = WORK_BUF;
    STATUS = SCR$SET_BUFFER(WORK_BUF_DESCR);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! Set the scrolling region to be the whole screen.  This is only necessary
    ! for VT100 terminals in which "Origin Mode" is set, meaning that all cursor
    ! positioning is relative to the current scrolling region.  The normal state
    ! is that cursor positioning is relative to the full physical screen, which
    ! is what we require for our screen update to work correctly.  By setting
    ! the scrolling region to be the whole screen, we make sure that the cursor
    ! positioning commands below work as intended regardless of the setting of
    ! the Origin Mode bit in the VT100.
    !
    STATUS = SCR$SET_SCROLL(1, 24);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! Initialize START_LINE and END_LINE to suppress an erroneous error message
    ! by the BLISS compiler about them not being initialized before use.  (They
    ! are in fact initialized before use even without these two assignments.)
    ! If the BLISS compiler is ever fixed, these two lines can be removed.
    !
    START_LINE = 0;
    END_LINE = 0;


    ! Loop through the lines of the pasteboard to discover all regions that can
    ! best be output by scrolling regions of the terminal screen.
    !
    REGSIZE = 0;
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	BEGIN


	! If this line is a regular text line, mark the start (if this is the
	! start) and end of the region of contiguous lines from the same dis-
	! play and increment the region size.
	!
	IF .PASTEBOARD[.I, DBG$B_PASTE_KIND] EQL DBG$K_PASTE_TEXT
	THEN
	    BEGIN
	    DISPTR = .PASTEBOARD[.I, DBG$L_PASTE_DISPID];
	    IF .REGSIZE EQL 0 THEN START_LINE = .I;
	    END_LINE = .I;
	    REGSIZE = .REGSIZE + 1;
	    END


	! If the next line is not a regular text line, the potential scrolling
	! region has ended and we see if scrolling a screen region is the best
	! action.  If it is, we then do so.  Note that scrolling is disabled
	! if this is not a VT100 class terminal.
	!
	ELSE IF (.REGSIZE NEQ 0) AND .DBG$GL_VT100_FLAG
	THEN
	    BEGIN


	    ! Determine the scrolling direction and amount from the Pasteboard
	    ! Entry for the start line of this screen region.
	    !
	    SCROLL_DOWN = TRUE;
	    SCROLL_AMOUNT = .PASTEBOARD[.START_LINE, DBG$W_PASTE_SCROLL];
	    IF .SCROLL_AMOUNT LSS 0
	    THEN
		BEGIN
		SCROLL_DOWN = FALSE;
		SCROLL_AMOUNT = - .SCROLL_AMOUNT;
		END;


	    ! If scrolling can be done on the region (the set of lines) we just
	    ! scanned, set up a scrolling region and then do the actual scroll-
	    ! ing in the appropriate direction.
	    !
	    IF (.SCROLL_AMOUNT NEQ 0) AND (.SCROLL_AMOUNT LSS .REGSIZE)
	    THEN
		BEGIN
		STATUS = SCR$SET_SCROLL(.START_LINE + 1, .END_LINE + 1);
		IF NOT .STATUS THEN SIGNAL(.STATUS);


		! If the scrolling direction is down, meaning that the window
		! moves down the display text (positive scrolling amount),
		! shift the screen contents up the specified number of lines.
		!
		IF .SCROLL_DOWN
		THEN
		    BEGIN


		    ! Start by updating the old screen image by moving all
		    ! lines up that we are about to scroll.
		    !
		    INCR J FROM .START_LINE + .SCROLL_AMOUNT TO .END_LINE DO
			BEGIN
			OLD_CNT[.J - .SCROLL_AMOUNT] = .OLD_CNT[.J];
			OLD_REND[.J - .SCROLL_AMOUNT] = .OLD_REND[.J];
			OLD_VALID[.J - .SCROLL_AMOUNT] = .OLD_VALID[.J];
			CH$MOVE(.OLD_CNT[.J], OLD_SCREEN[.J*132],
				OLD_SCREEN[(.J - .SCROLL_AMOUNT)*132]);
			CH$MOVE(.OLD_CNT[.J], OLD_SCREEN_REND[.J*132],
				OLD_SCREEN_REND[(.J - .SCROLL_AMOUNT)*132]);
			END;


		    ! Then do the actual scrolling on the screen.  Note that we
		    ! only shift up existing lines on the screen here.  The
		    ! new lines to be scrolled in are marked as invalid here so
		    ! that they get written during the screen update below.
		    !
		    STATUS = SCR$SET_CURSOR(.END_LINE + 1, 1);
		    IF NOT .STATUS THEN SIGNAL(.STATUS);
		    INCR J FROM 1 TO .SCROLL_AMOUNT DO
			BEGIN
			OLD_VALID[.END_LINE - .J + 1] = FALSE;
			STATUS = SCR$UP_SCROLL();
			IF NOT .STATUS THEN SIGNAL(.STATUS);
			END;

		    END


		! Otherwise, scroll the region up by SCROLL_AMOUNT lines.  This
		! means that we move toward the top of the display and shift
		! the corresponding lines on the screen down the same amount.
		!
		ELSE
		    BEGIN


		    ! Start by updating the old screen image by moving all
		    ! lines down that we are about to scroll.
		    !
		    DECR J FROM .END_LINE TO .START_LINE + .SCROLL_AMOUNT DO
			BEGIN
			OLD_CNT[.J] = .OLD_CNT[.J - .SCROLL_AMOUNT];
			OLD_REND[.J] = .OLD_REND[.J - .SCROLL_AMOUNT];
			OLD_VALID[.J] = .OLD_VALID[.J - .SCROLL_AMOUNT];
			CH$MOVE(.OLD_CNT[.J],
				OLD_SCREEN[(.J - .SCROLL_AMOUNT)*132],
				OLD_SCREEN[.J*132]);
			CH$MOVE(.OLD_CNT[.J],
				OLD_SCREEN_REND[(.J - .SCROLL_AMOUNT)*132],
				OLD_SCREEN_REND[.J*132]);
			END;


		    ! Then do the actual scrolling on the screen.  Note that we
		    ! only shift down existing lines on the screen here.  The
		    ! new lines to be scrolled in are marked as invalid here so
		    ! that they get written during the screen update below.
		    !
		    STATUS = SCR$SET_CURSOR(.START_LINE + 1, 1);
		    IF NOT .STATUS THEN SIGNAL(.STATUS);
		    INCR J FROM 1 TO .SCROLL_AMOUNT DO
			BEGIN
			OLD_VALID[.START_LINE + .J - 1] = FALSE;
			STATUS = SCR$DOWN_SCROLL();
			IF NOT .STATUS THEN SIGNAL(.STATUS);
			END;

		    END;

		END;


	    ! Set the region size back to zero for any non-text line.
	    !
	    REGSIZE = 0;
	    END;

	END;				! End of loop to find scrolling regions


    ! If this is not a VT100 class terminal (for example, if it is a VT52),
    ! invalidate all lines in the old screen image.  These lines are no good
    ! since the whole screen always scrolls when the user enters input.
    !
    IF NOT .DBG$GL_VT100_FLAG
    THEN
	BEGIN
	INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	    OLD_VALID[.I] = FALSE;

	END;


    ! Determine which is the last used line in the pasteboard.  Any null lines
    ! before this line (i.e., above at least one display) will be blanked out
    ! instead of being left alone as they are in the user program scrolling
    ! region.
    !
    DECR I FROM DBG$K_PASTE_SIZE - 1 TO 0 DO
	BEGIN
	LAST_USED_LINE = .I;
	IF .PASTEBOARD[.I, DBG$B_PASTE_KIND] NEQ DBG$K_PASTE_NULL THEN EXITLOOP;
	END;


    ! Loop through the lines in the pasteboard and output each such line to the
    ! terminal screen.  Note that we apply the necessary shift-count to each
    ! output line so that lines are correctly scrolled left or right.  Each
    ! line is written out by the OUTPUT_LINI_MINIMAL routine which applies a
    ! minimal screen update algorithm to update the screen with the new text.
    !
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	BEGIN
	RENDITION_LINE = FALSE;


	! Construct the line to be output to the screen based on the line's
	! kind.
	!
	CASE .PASTEBOARD[.I, DBG$B_PASTE_KIND]
				FROM DBG$K_PASTE_NULL TO DBG$K_PASTE_BORDER OF
	    SET


	    ! Handle the Null line.  A null line before the last line used for
	    ! part of a display is blanked out.  A null line after the last
	    ! used line is left alone since it is part of the user program
	    ! scrolling region on the terminal screen.
	    !
	    [DBG$K_PASTE_NULL]:
		BEGIN
		TEXTPTR = BUFFER;
		TEXTCNT = 0;
		IF .I GTR .LAST_USED_LINE THEN TEXTPTR = 0;
		END;


	    ! Handle an ordinary text line from some display.  Here we compute
	    ! the text start address and length by taking the column shift
	    ! count (DCOL) into account so that display lines can be correctly
	    ! scrolled left or right.  (Scrolling right means that the window
	    ! moves to the right over the display text--the actual screen con-
	    ! tents are then shifted to the left--and vice versa for scrolling
	    ! left.)  Note that lines from source displays are formatted by a
	    ! separate routine.  Also note that we check for lines with per-
	    ! character rendition information.
	    !
	    [DBG$K_PASTE_TEXT]:
		BEGIN
		DLEPTR = .PASTEBOARD[.I, DBG$L_PASTE_DLINE];
		IF .DLEPTR[DBG$V_DLINE_SOURCEFLG]
		THEN
		    FORMAT_SOURCE_LINE(.DISPTR, .DLEPTR,
						TEXTPTR, TEXTCNT, BUFFER)

		ELSE
		    BEGIN
		    DCOL = .DISPTR[DBG$W_DISP_DCOL];
		    TEXTPTR = DLEPTR[DBG$A_DLINE_TEXT];
		    IF .DLEPTR[DBG$V_DLINE_RENDFLG]
		    THEN
			BEGIN
			RENDITION_LINE = TRUE;
			RENDPTR = TEXTPTR[.TEXTPTR[0] + .DCOL];
			END;

		    TEXTCNT = MIN(.DBG$SRC_TERM_WIDTH,
					MAX(0, .TEXTPTR[0] - .DCOL + 1));
		    IF .TEXTCNT NEQ 0 THEN TEXTPTR = TEXTPTR[.DCOL];
		    END;

		END;


	    ! Handle a blank line which is part of a display's text.
	    !
	    [DBG$K_PASTE_BLANK]:
		BEGIN
		TEXTPTR = BUFFER;
		TEXTCNT = 0;
		END;


	    ! Handle a label line on top of a display.  This line consists of a
	    ! line of dashes into which the display name has been filled.  Note
	    ! that we also mark the label line accordingly if this display is
	    ! currently selected for input, output, scrolling, or source.
	    !
	    [DBG$K_PASTE_LABEL]:
		BEGIN


		! Fill in the name of the display in the label line.
		!
		TEXTPTR = BUFFER;
		TEXTCNT = .DBG$SRC_TERM_WIDTH;
		CH$FILL('-', .TEXTCNT, BUFFER);
		DISPTR = .PASTEBOARD[.I, DBG$L_PASTE_DISPID];
		NAMEPTR = DISPTR[DBG$A_DISP_NAME];
		CH$MOVE(MIN(80, .NAMEPTR[0]), NAMEPTR[1], BUFFER[2]);
		N = MIN(80, .NAMEPTR[0]) + 2;


		! If this is a source line display, fill in the module name of
		! the source text.  For example: "-DISPNAM: module MODNAM-".
		!
		IF (.DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_SOURCE) AND
		   (.DISPTR[DBG$L_DISP_MODPTR] NEQ 0)
		THEN
		    BEGIN
		    CH$MOVE(9, UPLIT BYTE(%ASCII ': module '), BUFFER[.N]);
		    N = .N + 9;
		    DBG$STA_SYMNAME(.DISPTR[DBG$L_DISP_MODPTR], NAMEPTR);
		    CH$MOVE(MIN(32, .NAMEPTR[0]), NAMEPTR[1], BUFFER[.N]);
		    N = .N + MIN(32, .NAMEPTR[0]);
		    END;


		! Fill in the display selections that apply to this display.
		! This can be -input-, -output-, -source-, and -scroll-.
		!
		N = MIN(50, .N + 2);
		IF .DISPTR EQL .DBG$SCR_CURDISP_INPUT
		THEN
		    BEGIN
		    CH$MOVE(7, UPLIT BYTE(%ASCII '-input-'), BUFFER[.N]);
		    N = .N + 6;
		    END;

		IF .DISPTR EQL .DBG$SCR_CURDISP_OUTPUT
		THEN
		    BEGIN
		    CH$MOVE(8, UPLIT BYTE(%ASCII '-output-'), BUFFER[.N]);
		    N = .N + 7;
		    END;

		IF .DISPTR EQL .DBG$SCR_CURDISP_SOURCE
		THEN
		    BEGIN
		    CH$MOVE(8, UPLIT BYTE(%ASCII '-source-'), BUFFER[.N]);
		    N = .N + 7;
		    END;

		IF .DISPTR EQL .DBG$SCR_CURDISP_SCROLL
		THEN
		    BEGIN
		    CH$MOVE(8, UPLIT BYTE(%ASCII '-scroll-'), BUFFER[.N]);
		    N = .N + 7;
		    END;

		END;


	    ! Handle the border line below the lowest display on the screen.
	    ! This line consists of nothing but a line of dashes.
	    !
	    [DBG$K_PASTE_BORDER]:
		BEGIN
		TEXTPTR = BUFFER;
		TEXTCNT = .DBG$SRC_TERM_WIDTH;
		CH$FILL('-', .TEXTCNT, BUFFER);
		END;


	    ! Any other kind value is an internal DEBUG error.
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGSCREEN\OUTPUT_SCREEN');

	    TES;


	! If the line of text is a "null" line, i.e. part of the user program
	! scrolling region or otherwise outside any screen display, simply
	! mark the line contents as "invalid" and do not output any text.
	!
	IF .TEXTPTR EQL 0
	THEN
	    OLD_VALID[.I] = FALSE


	! If this is a normal text line, we output that text with the appropri-
	! ate renditions using a minimal screen update algorithm.
	!
	ELSE
	    BEGIN


	    ! If the new line does not have a rendition vector (i.e., if it has
	    ! a single rendition for the whole line), create a rendition vector
	    ! for it.
	    !
	    IF NOT .RENDITION_LINE
	    THEN
		BEGIN
		RENDPTR = REND_VECTOR[0];
		CH$FILL(.PASTEBOARD[.I, DBG$B_PASTE_REND], .TEXTCNT, .RENDPTR);
		END;


	    ! Update the screen with the new text of this line.
	    !
	    OLDTEXT = 0;
	    IF .OLD_VALID[.I] THEN OLDTEXT = OLD_SCREEN[.I*132];
	    DBG$SCR_OUTPUT_LINE_MINIMAL(.TEXTCNT, .TEXTPTR, .RENDPTR,
		.OLD_CNT[.I], .OLDTEXT, OLD_SCREEN_REND[.I*132], .I + 1);


	    ! Update the old screen image to reflect the new screen contents.
	    !
	    CH$MOVE(.TEXTCNT, .TEXTPTR, OLD_SCREEN[.I*132]);
	    CH$MOVE(.TEXTCNT, .RENDPTR, OLD_SCREEN_REND[.I*132]);
	    OLD_CNT[.I] = .TEXTCNT;
	    OLD_REND[.I] = .PASTEBOARD[.I, DBG$B_PASTE_REND];
	    IF .RENDITION_LINE THEN OLD_REND[.I] = 255;
	    OLD_VALID[.I] = TRUE;
	    END;

	END;				! End of loop over pasteboard lines


    ! Set up a scrolling region on the screen which consists of those lines at
    ! the bottom of the screen which are not covered by any display. We dynami-
    ! cally determine how many such lines there are.
    !
    START_LINE = DBG$K_PASTE_SIZE + 1;
    END_LINE = 24;
    DECR I FROM DBG$K_PASTE_SIZE TO 1 DO
	BEGIN
	IF .PASTEBOARD[.I - 1, DBG$B_PASTE_KIND] NEQ DBG$K_PASTE_NULL
	THEN
	    EXITLOOP;

	START_LINE = .I;
	END;

    STATUS = SCR$SET_SCROLL(.START_LINE, .END_LINE);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! Finally position the cursor at the start of the last line of the screen.
    !
    STATUS = SCR$SET_CURSOR(24, 1);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! Output the buffer built up in screen buffer mode to force all output to
    ! the terminal screen.  The screen update is then complete.
    !
    STATUS = SCR$PUT_BUFFER(0);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! If screen logging is turned on, we output the current screen contents to
    ! the DEBUG log file.  After that, we return.
    !
    IF .DBG$GL_SCREEN_LOG THEN DBG$SCR_SCREEN_TO_LOGFILE();
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_CANDISP_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the CANCEL DISPLAY command. It accepts a command
!	line string descriptor as input and produces a Verb Node for the parsed
!	CANCEL DISPLAY command as output.  That Verb Node and its attached Noun
!	Nodes later serve as input to DBG$SCR_EXECUTE_CANDISP_CMD which actual-
!	ly executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the CANCEL DISPLAY keywords.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it and all
!		  its attached Noun Nodes contains all information picked up
!		  during the parse of the CANCEL DISPLAY command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	DISPID: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	NAMEPTR,			! Pointer to ASCIC display name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node
	OLDPTR: REF DBG$NOUN_NODE;	! Pointer to previous Noun Node in list



    ! First check for the /ALL qualifier.  If it is present, we return right
    ! away with zero Noun Nodes attached to the Verb Node.  No additional
    ! parameters are allowed in this case.
    !
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = 0;
    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_SLASH, 1)
    THEN
	BEGIN
	IF DBG$NMATCH(.INPUT_DESC, DBG$CS_ALL, 1) THEN RETURN;
	DBG$SYNTAX_ERROR(.INPUT_DESC);
	END;


    ! Otherwise, go into a loop to pick up the names of all displays to be
    ! cancelled.  For each such display name, look up the corresponding
    ! Display ID (thus ensuring that the display name is valid) and construct
    ! a Noun Node to hold a pointer to the display name.
    !
    NOUN_NODE = 0;
    WHILE TRUE DO
	BEGIN


	! Pick up the display name and look it up in the Display List to make
	! sure there is such a display.
	!
	NAMEPTR = PARSE_DISPLAY_NAME(.INPUT_DESC, FALSE);
	DISPID = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
	IF .DISPID EQL 0 THEN SIGNAL(DBG$_NOSUCHDISP, 1, .NAMEPTR);


	! The display name is good.  Create a new Noun Node to hold a pointer
	! to the display name and add that node to the Noun Node list attached
	! to the Verb Node.
	!
	OLDPTR = .NOUN_NODE;
	NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE);
	NOUN_NODE[DBG$L_NOUN_VALUE] = .NAMEPTR;
	IF .OLDPTR EQL 0
	THEN
	    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE

	ELSE
	    OLDPTR[DBG$L_NOUN_LINK] = .NOUN_NODE;


	! Check that the display name is properly followed by a comma (in which
	! case we loop for more) or a carriage return (which ends the command).
	!
	IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1) THEN EXITLOOP;
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	END;				! End of loop over display names


    ! The command is fully parsed and the Verb Node, complete with its list
    ! of Noun Nodes, is fully constructed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_CANWIND_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the CANCEL WINDOW command. It accepts a command
!	line string descriptor as input and produces a Verb Node for the parsed
!	CANCEL WINDOW command as output.  That Verb Node and its attached Noun
!	Nodes later serve as input to DBG$SCR_EXECUTE_CANWIND_CMD which actual-
!	ly executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the CANCEL WINDOW keywords.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it and all
!		  its attached Noun Nodes contains all information picked up
!		  during the parse of the CANCEL WINDOW command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	NAMEPTR,			! Pointer to ASCIC window name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node
	OLDPTR: REF DBG$NOUN_NODE,	! Pointer to previous Noun Node in list
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to Screen Window Entry



    ! First check for the /ALL qualifier.  If it is present, we return right
    ! away with zero Noun Nodes attached to the Verb Node.  No additional
    ! parameters are allowed in this case.
    !
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = 0;
    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_SLASH, 1)
    THEN
	BEGIN
	IF DBG$NMATCH(.INPUT_DESC, DBG$CS_ALL, 1) THEN RETURN;
	DBG$SYNTAX_ERROR(.INPUT_DESC);
	END;


    ! Otherwise, go into a loop to pick up the names of all windows to be
    ! cancelled.  For each such window name, look up the corresponding Screen
    ! Window Entry (thus ensuring that the window name is valid) and construct
    ! a Noun Node to hold a pointer to the window name.
    !
    NOUN_NODE = 0;
    WHILE TRUE DO
	BEGIN


	! Pick up the window name and look it up in the Screen Window List to
	! make sure there exists such a window.
	!
	NAMEPTR = PARSE_WINDOW_NAME(.INPUT_DESC);
	WPTR = DBG$SCR_LOOKUP_WINDOW(.NAMEPTR);
	IF .WPTR EQL 0 THEN SIGNAL(DBG$_NOSUCHWIND, 1, .NAMEPTR);


	! The window name is good.  Create a new Noun Node to hold a pointer to
	! the window name and add that node to the Noun Node list attached to
	! the Verb Node.
	!
	OLDPTR = .NOUN_NODE;
	NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE);
	NOUN_NODE[DBG$L_NOUN_VALUE] = .NAMEPTR;
	IF .OLDPTR EQL 0
	THEN
	    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE

	ELSE
	    OLDPTR[DBG$L_NOUN_LINK] = .NOUN_NODE;


	! Check that the window name is properly followed by a comma (in which
	! case we loop for more) or a carriage return (which ends the command).
	!
	IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1) THEN EXITLOOP;
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	END;				! End of loop over window names


    ! The command is fully parsed and the Verb Node, complete with its list
    ! of Noun Nodes, is fully constructed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_DISPLAY_CMD(INPUT_DESC,
						SET_FLAG, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the DISPLAY and SET DISPLAY commands.  It accepts
!	a command line string descriptor as input and produces a verb node
!	for the parsed command as output.  Since the DISPLAY and SET DISPLAY
!	commands are very similar in syntax, both commands are parsed by the
!	same code.  The SET_FLAG parameter, which is set to TRUE if this is
!	a SET DISPLAY command, is used to special-case those features which
!	differ between the two commands.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the DISPLAY or SET DISPLAY keyword.
!
!	SET_FLAG - This flag has the value TRUE if the command being parsed is
!		  a SET DISPLAY command and the value FALSE if the command
!		  being parsed is a DISPLAY command.
!
!	VERB_NODE - A pointer to the verb node to be built up for the command
!		  being parsed.  The verb node is assumed to have one attached
!		  noun node but no adverb node on input.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in verb node is filled in so that it and all
!		  its attached adverb and noun nodes contains all information
!		  picked up during the parse of the command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input verb node

    OWN
	DW_INDEX: INITIAL(0);		! Default window index (0=H1, 1=H2)

    LOCAL
	ADVERB_NODE:			! Pointer to Adverb Node to contain
		REF DBG$ADVERB_NODE,	!      qualifier information
	CBEG,				! CBEG parameter of window specification
	CLEAR_FLAG,			! Flag set if /CLEAR qualifier found
	CLEN,				! CLEN parameter of window specification
	CONTENT_PTR,			! Pointer to DEBUG command list which
					!      defines display contents
	EXPC_DESC: BLOCK[8,BYTE],	! String descriptor for default source
					!      DEBUG command list
	FLAGWORD,			! Flag longword with all qualifier
					!      information--saved in Adverb
					!      Node value field
	GENERATE_ALL_FLAG,		! Flag set for /GENERATE all displays
	GENERATE_FLAG,			! Flag set if /GENERATE qualifier found
	HIDE_FLAG,			! Flag set if /HIDE qualifier found
	KIND,				! The display kind (content spec kind)
	MARK_FLAG,			! Flag set if /MARK_CHANGE qualifier found
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to current ASCIC display name
	NOMARK_FLAG,			! Flag set if /NOMARK_CHANGE qual found
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node
	OLD_NOUN_PTR: REF DBG$NOUN_NODE,! Pointer to previous Noun Node
	RBEG,				! RBEG parameter of window specification
	REFRESH_FLAG,			! Flag set if /REFRESH qualifier found
	REMOVED_FLAG,			! Flag set if /REMOVED qualifier found
	RLEN,				! RLEN parameter of window specification
	SIZE,				! Display size from /SIZE:n qualifier
	WNAMEPTR: REF VECTOR[,BYTE],	! Pointer to current ASCIC window name
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to current Screen Window Entry



    ! Initialize various flags used to mark the various qualifiers specified.
    !
    REFRESH_FLAG = FALSE;
    HIDE_FLAG = FALSE;
    MARK_FLAG = FALSE;
    NOMARK_FLAG = FALSE;
    REMOVED_FLAG = FALSE;
    CLEAR_FLAG = FALSE;
    GENERATE_ALL_FLAG = FALSE;
    GENERATE_FLAG = FALSE;
    SIZE = 0;


    ! Loop to pick up all command qualifiers.  For each qualifier, set the
    ! appropriate flag to indicate that it was found.
    !
    WHILE DBG$NMATCH(.INPUT_DESC, DBG$CS_SLASH, 1) DO
	BEGIN


	! Determine which qualifier we have and mark its presence.
	!
	SELECTONE TRUE OF
	    SET


	    ! If this is the /REFRESH qualifier, mark its presence.  Note that
	    ! this qualifier is allowed only on the DISPLAY command.
	    !
	    [IF .SET_FLAG THEN FALSE ELSE
	     DBG$NMATCH(.INPUT_DESC, DBG$CS_REFRESH, 3)]:
		REFRESH_FLAG = TRUE;


	    ! If this is the /CLEAR qualifier, mark its presence.  This quali-
	    ! fier is only allowed on the DISPLAY command.
	    !
	    [IF .SET_FLAG THEN FALSE ELSE
	     DBG$NMATCH(.INPUT_DESC, DBG$CS_CLEAR, 2)]:
		CLEAR_FLAG = TRUE;


	    ! If this is the /GENERATE qualifier, mark its presence.  Note that
	    ! this qualifier is allowed only on the DISPLAY command.
	    !
	    [IF .SET_FLAG THEN FALSE ELSE
	     DBG$NMATCH(.INPUT_DESC, DBG$CS_GENERATE, 2)]:
		GENERATE_FLAG = TRUE;


	    ! If this is the /HIDE qualifier, mark its presence.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_HIDE, 2)]:
		HIDE_FLAG = TRUE;


	    ! If this is the /MARK_CHANGE qualifier, mark its presence.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_MARK_CHANGE, 2)]:
		BEGIN
		MARK_FLAG = TRUE;
		NOMARK_FLAG = FALSE;
		END;


	    ! If this is the /NOMARK_CHANGE qualifier, mark its presence.  This
	    ! qualifier is only allowed on the DISPLAY command.
	    !
	    [IF .SET_FLAG THEN FALSE ELSE
	     DBG$NMATCH(.INPUT_DESC, DBG$CS_NOMARK_CHANGE, 4)]:
		BEGIN
		NOMARK_FLAG = TRUE;
		MARK_FLAG = FALSE;
		END;


	    ! If this is the /REMOVED qualifier, mark its presence.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_REMOVED, 3)]:
		REMOVED_FLAG = TRUE;


	    ! If this is the /SIZE:n qualifier, pick up the requested display
	    ! size and check it for validity.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_SIZE, 2)]:
		BEGIN
		IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COLON, 1)
		THEN
		    BEGIN
		    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_EQUAL, 1)
		    THEN
			DBG$SYNTAX_ERROR(.INPUT_DESC);

		    END;

		DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, SIZE);
		IF (.SIZE LSS 1) OR (.SIZE GTR 1000)
		THEN
		    SIGNAL(DBG$_INVDSPSIZ, 1, .SIZE);

		END;


	    ! Any other qualifier constitutes a syntax error, which we
	    ! signal at this point.
	    !
	    [OTHERWISE]:
		DBG$SYNTAX_ERROR(.INPUT_DESC);

	    TES;

	END;				! End of qualifier scanning loop


    ! For the DISPLAY/GENERATE command, the parameter list is optional.  If
    ! there are no parameters, we set GENERATE_ALL_FLAG to indicate that all
    ! automatically generated displays should be regenerated.
    !
    IF .GENERATE_FLAG AND DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	GENERATE_ALL_FLAG = TRUE;


    ! Build an Adverb Node and fill all qualifier information into the value
    ! field of that node.
    !
    FLAGWORD = 0;
    FLAGWORD<V_(0)> = .REFRESH_FLAG;
    FLAGWORD<V_(1)> = .CLEAR_FLAG;
    FLAGWORD<V_(2)> = .GENERATE_ALL_FLAG;
    FLAGWORD<V_(3)> = .GENERATE_FLAG;
    FLAGWORD<V_(4)> = .HIDE_FLAG;
    FLAGWORD<V_(5)> = .MARK_FLAG;
    FLAGWORD<V_(6)> = .NOMARK_FLAG;
    FLAGWORD<V_(7)> = .REMOVED_FLAG;
    FLAGWORD<V_(16,16)> = .SIZE;
    ADVERB_NODE = DBG$GET_TEMPMEM(DBG$K_ADVERB_NODE_SIZE);
    ADVERB_NODE[DBG$L_ADVERB_VALUE] = .FLAGWORD;
    VERB_NODE[DBG$L_VERB_ADVERB_PTR] = .ADVERB_NODE;


    ! For the DISPLAY/REFRESH command, no further parameters are allowed.  We
    ! thus return right away.  We also return immediately for the parameter-
    ! less DISPLAY/GENERATE command.
    !
    IF .REFRESH_FLAG OR .GENERATE_ALL_FLAG THEN RETURN;


    ! Loop to pick up the names and attributes of all displays to be displayed
    ! or created.  For the SET DISPLAY command, we only go through this loop
    ! once since that is all the syntax allows.
    !
    NOUN_NODE = 0;
    WHILE TRUE DO
	BEGIN
	WPTR = 0;
	KIND = DBG$K_DISP_NOKIND;
	IF .SET_FLAG THEN KIND = DBG$K_DISP_NORMAL;
	CONTENT_PTR = 0;


	! Pick up the display name.
	!
	NAMEPTR = PARSE_DISPLAY_NAME(.INPUT_DESC, NOT .SET_FLAG);


	! Pick up the window specification if one is present.  The window spec-
	! ification may be either a parenthesized list of window parameters or
	! an already declared window name.
	!
	IF DBG$NMATCH(.INPUT_DESC, DBG$CS_AT, 2)
	THEN
	    BEGIN


	    ! If the user is specifying a window specification of the form
	    ! "(rbeg, rlen, cbeg, clen)", pick up the window parameters and
	    ! create a Temporary Screen Window Entry for those parameters.
	    !
	    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_LPAREN, 1)
	    THEN
		BEGIN
		PARSE_WINDOW_PARAMETERS(.INPUT_DESC, RBEG, RLEN, CBEG, CLEN);
		WPTR = DBG$SCR_CREATE_TEMP_WINDOW(.RBEG, .RLEN, .CBEG, .CLEN);
		END


	    ! Otherwise he must be specifying a window name.  Pick up that name,
	    ! look it up the in the Screen Window List, and signal an error if
	    ! there is no such window.
	    !
	    ELSE
		BEGIN
		WNAMEPTR = PARSE_WINDOW_NAME(.INPUT_DESC);
		WPTR = DBG$SCR_LOOKUP_WINDOW(.WNAMEPTR);
		IF .WPTR EQL 0 THEN SIGNAL(DBG$_NOSUCHWIND, 1, .WNAMEPTR);
		END;

	    END


	! If there is no window specification but this is a SET DISPLAY
	! command, we want a default window specification.  This is done
	! by creating a Temporary Screen Window Entry for window H1 or H2.
	! Subsequent default windows alternate between H1 and H2.
	!
	ELSE IF .SET_FLAG
	THEN
	    BEGIN
	    WPTR = DBG$SCR_CREATE_TEMP_WINDOW(10*.DW_INDEX + 1, 9, 1, 132);
	    IF .DW_INDEX EQL 0 THEN DW_INDEX = 1 ELSE DW_INDEX = 0;
	    END;


	! Pick up the display kind if one is present.
	!
	SELECTONE TRUE OF
	    SET


	    ! Check for the NORMAL display kind.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_NORMAL, 3)]:
		KIND = DBG$K_DISP_NORMAL;


	    ! Check for the DO(cmd-list) display kind.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_DO, 2)]:
		BEGIN
		KIND = DBG$K_DISP_DO;
		IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_LPAREN, 1)
		THEN
		    DBG$SYNTAX_ERROR(.INPUT_DESC);

		DBG$NSAVE_BREAK_BUFFER(.INPUT_DESC, CONTENT_PTR, FALSE);
		END;


	    ! Check for the SOURCE or SOURCE(cmd-list) display kind.  If the
	    ! (cmd-list) is missing, we leave CONTENT_PTR zeroed.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_SOURCE, 3)]:
		BEGIN
		KIND = DBG$K_DISP_SOURCE;
		IF DBG$NMATCH(.INPUT_DESC, DBG$CS_LPAREN, 1)
		THEN
		    DBG$NSAVE_BREAK_BUFFER(.INPUT_DESC, CONTENT_PTR, FALSE);

		END;


	    ! Check for the REGISTER display kind.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_REGISTER, 3)]:
		KIND = DBG$K_DISP_REGISTER;

	    TES;


	! Now build a Noun Node for this display specification and its
	! various attributes.  Add that Noun Node to the linked list of
	! Noun Nodes attached to the Verb Node.
	!
	OLD_NOUN_PTR = .NOUN_NODE;
	NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE_LONG);
	NOUN_NODE[DBG$L_NOUN_VALUE] = .NAMEPTR;
	NOUN_NODE[DBG$L_NOUN_VALUE2] = .WPTR;
	NOUN_NODE[DBG$L_NOUN_VALUE3] = .KIND;
	NOUN_NODE[DBG$L_NOUN_VALUE4] = .CONTENT_PTR;
	IF .OLD_NOUN_PTR EQL 0
	THEN
	    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE

	ELSE
	    OLD_NOUN_PTR[DBG$L_NOUN_LINK] = .NOUN_NODE;


	! If the next token is a carriage-return (end of command), we exit
	! the display specification loop.  However, if the next token is a
	! comma, we loop for the next display specification.
	!
	IF .INPUT_DESC[DSC$W_LENGTH] EQL 0 THEN EXITLOOP;
	IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1) THEN EXITLOOP;
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	END;				! End of loop over display specs


    ! The command processing is completed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SAVE_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SAVE command.  It accepts a command line
!	string descriptor as input and produces a Verb Node for the parsed
!	SAVE command as output.  That Verb Node and its attached Noun Node
!	list later serve as input to DBG$SCR_EXECUTE_SAVE_CMD which actually
!	executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SAVE keyword.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it and its
!		  attached Noun Nodes contains all information picked up
!		  during the parse of the SAVE command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to current display name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to the current Noun Node
	OLD_NOUN_PTR: REF DBG$NOUN_NODE;! Temporary Noun Node pointer



    ! Loop to pick up all the display SAVE specifications.  Each such specifi-
    ! cation is of the form "disp1 AS disp2", where disp1 is the existing dis-
    ! play to be saved and disp2 is the new display to be created with the same
    ! contents as disp1.  The SAVE specifications are separated by commas.
    !
    NOUN_NODE = 0;
    WHILE TRUE DO
	BEGIN


	! Pick up the name of the existing display to be saved (disp1) and make
	! sure there is such a display.
	!
	NAMEPTR = PARSE_DISPLAY_NAME(.INPUT_DESC, TRUE);
	DISPTR = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
	IF .DISPTR EQL 0 THEN SIGNAL(DBG$_NOSUCHDISP, 1, .NAMEPTR);


	! Scan past the AS keyword and pick up the name of the new display
	! to be created (disp2).
	!
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_AS, 2)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	NAMEPTR = PARSE_DISPLAY_NAME(.INPUT_DESC, FALSE);


	! Allocate and build a Noun Node for this SAVE specification.  Then
	! add it to the Verb Node's Noun Node chain.
	!
	OLD_NOUN_PTR = .NOUN_NODE;
	NOUN_NODE = DBG$GET_MEMORY(DBG$K_NOUN_NODE_SIZE);
	NOUN_NODE[DBG$L_NOUN_VALUE] = .DISPTR;
	NOUN_NODE[DBG$L_NOUN_VALUE2] = .NAMEPTR;
	IF .OLD_NOUN_PTR EQL 0
	THEN
	    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE

	ELSE
	    OLD_NOUN_PTR[DBG$L_NOUN_LINK] = .NOUN_NODE;


	! If we find a comma next, we loop for the next SAVE specification.
	! Otherwise, we exit the SAVE specification loop.
	!
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1) THEN EXITLOOP;

	END;				! End of loop over SAVE specifications


    ! The SAVE command is fully and successfully parsed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SCROLL_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SCROLL command. It accepts a command line
!	string descriptor as input and produces a Verb Node for the parsed
!	SCROLL command as output.  That Verb Node and its attached Noun
!	Node later serve as input to DBG$SCR_EXECUTE_SCROLL_CMD which
!	actually executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SCROLL keyword.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it and its
!		  attached Noun Node contains all information picked up
!		  during the parse of the SCROLL command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	AMOUNT,				! Amount to scroll specified display
	DIRECTION,			! Direction to scroll specified display
	DISPID: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC name of display
	NOUN_NODE: REF DBG$NOUN_NODE;	! Pointer to Noun Node



    ! Initialize the default direction and scrolling amount.
    !
    DIRECTION = DBG$K_SCROLL_DOWN;
    AMOUNT = -1;


    ! Parse the SCROLL command qualifier (if any).  The qualifier has the form
    ! /direction[:amount] or /TOP or /BOTTOM.  The qualifier thus indicates
    ! the scrolling direction and amount.
    !
    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_SLASH, 1)
    THEN
	BEGIN


	! Pick up the qualifier name (the scrolling direction).
	!
	SELECTONE TRUE OF
	    SET


	    ! Check for SCROLL/UP:n qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_UP, 1)]:
		DIRECTION = DBG$K_SCROLL_UP;


	    ! Check for SCROLL/DOWN:n qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_DOWN, 1)]:
		DIRECTION = DBG$K_SCROLL_DOWN;


	    ! Check for SCROLL/LEFT:n qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_LEFT, 1)]:
		DIRECTION = DBG$K_SCROLL_LEFT;


	    ! Check for SCROLL/RIGHT:n qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_RIGHT, 1)]:
		DIRECTION = DBG$K_SCROLL_RIGHT;


	    ! Check for SCROLL/TOP qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_TOP, 1)]:
		BEGIN
		DIRECTION = DBG$K_SCROLL_UP;
		AMOUNT = 65001;
		END;


	    ! Check for SCROLL/BOTTOM qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_BOTTOM, 1)]:
		BEGIN
		DIRECTION = DBG$K_SCROLL_DOWN;
		AMOUNT = 65001;
		END;


	    ! If the qualifier is none of the above, we have a syntax error.
	    !
	    [OTHERWISE]:
		DBG$SYNTAX_ERROR(.INPUT_DESC);

	    TES;


	! For all qualifiers except /TOP and /BOTTOM we now pick up the
	! scrolling amount if it is specified.
	!
	IF .AMOUNT EQL -1
	THEN
	    BEGIN
	    IF (IF DBG$NMATCH(.INPUT_DESC, DBG$CS_COLON, 1) THEN TRUE
		ELSE DBG$NMATCH(.INPUT_DESC, DBG$CS_EQUAL, 1))
	    THEN
		BEGIN
		DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, AMOUNT);
		IF .AMOUNT GTR 65000 THEN AMOUNT = 65000;
		END;

	    END;

	END;				! End of code to pick up qualifier


    ! Now pick up the name of the display to be scrolled.  If no display name
    ! is specified, use the default scrolling display.  If a name is specified,
    ! convert that display name to a Display ID and make sure that such a
    ! display exists.
    !
    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	BEGIN
	DISPID = .DBG$SCR_CURDISP_SCROLL;
	IF .DISPID EQL 0 THEN SIGNAL(DBG$_NOSCROLL);
	END

    ELSE
	BEGIN
	NAMEPTR = PARSE_DISPLAY_NAME(.INPUT_DESC, TRUE);
	DISPID = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
	IF .DISPID EQL 0 THEN SIGNAL(DBG$_NOSUCHDISP, 1, .NAMEPTR);
	END;


    ! If no scrolling amount was specified, we determine the actual scrolling
    ! amount based on the scrolling direction and the size of the display.
    !
    IF .AMOUNT EQL -1
    THEN
	BEGIN
	IF (.DIRECTION EQL DBG$K_SCROLL_UP) OR
	   (.DIRECTION EQL DBG$K_SCROLL_DOWN)
	THEN
	    AMOUNT = .DISPID[DBG$W_DISP_RLEN] - (.DISPID[DBG$W_DISP_RLEN]-1)/4

	ELSE
	    AMOUNT = 8;

	END;


    ! Now build the Noun Node to hold the scrolling direction and amount and
    ! the specified Display ID.  Link it to the Verb Node and then return.
    !
    NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE_LONG);
    NOUN_NODE[DBG$L_NOUN_VALUE] = .DISPID;
    NOUN_NODE[DBG$L_NOUN_VALUE2] = .DIRECTION;
    NOUN_NODE[DBG$L_NOUN_VALUE3] = .AMOUNT;
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SELECT_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SELECT command. It accepts a command line
!	string descriptor as input and produces a verb node for the parsed
!	SELECT command as output.  That verb node and its attached noun node
!	later serve as input to EXECUTE_SELECT_CMD which actually executes
!	the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SELECT keyword.
!
!	VERB_NODE - A pointer to the verb node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in verb node is filled in so that it and its
!		  attached noun node contain all information picked up during
!		  the parse of the SELECT command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input verb node

    LOCAL
	DISPID: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC name of display
	NO_QUALIFIERS,			! Flag set if no qualifiers are present
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to Noun Node
	SELECT_BITS: BITVECTOR[32];	! The selection kind bits



    ! Loop over all the qualifiers specified on the command.
    !
    SELECT_BITS = 0;
    NO_QUALIFIERS = TRUE;
    WHILE DBG$NMATCH(.INPUT_DESC, DBG$CS_SLASH, 1) DO
	BEGIN
	NO_QUALIFIERS = FALSE;


	! Now determine which specific qualifier we have and set the corre-
	! sponding selection kind bit.
	!
	SELECTONE TRUE OF
	    SET


	    ! Check for and process the /HISTORY qualifier.
	    !
	    [IF NOT .DBG$GL_DEVELOPER[7] THEN FALSE ELSE
	     DBG$NMATCH(.INPUT_DESC, DBG$CS_HISTORY, 1)]:
		SELECT_BITS[0] = TRUE;


	    ! Check for and process the /INPUT qualifier.
	    !
	    [IF NOT .DBG$GL_DEVELOPER[7] THEN FALSE ELSE
	     DBG$NMATCH(.INPUT_DESC, DBG$CS_INPUT, 1)]:
		SELECT_BITS[1] = TRUE;


	    ! Check for and process the /OUTPUT qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_OUTPUT, 1)]:
		SELECT_BITS[2] = TRUE;


	    ! Check for and process the /SCROLLING qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_SCROLLING, 2)]:
		SELECT_BITS[3] = TRUE;


	    ! Check for and process the /SOURCE qualifier.
	    !
	    [DBG$NMATCH(.INPUT_DESC, DBG$CS_SOURCE, 2)]:
		SELECT_BITS[4] = TRUE;


	    ! Any other qualifier constitutes a syntax error.
	    !
	    [OTHERWISE]:
		DBG$SYNTAX_ERROR(.INPUT_DESC);

	    TES;

	END;				! End of qualifier loop


    ! If no qualifiers were specified, assume that /SCROLLING was meant.
    !
    IF .NO_QUALIFIERS THEN SELECT_BITS[3] = TRUE;


    ! Pick up the name of the selected display and convert it to a Display ID.
    ! If no display name is specified, leave the Display ID as zero.
    !
    DISPID = 0;
    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	BEGIN
	NAMEPTR = PARSE_DISPLAY_NAME(.INPUT_DESC, TRUE);
	DISPID = DBG$SCR_LOOKUP_DISPLAY(.NAMEPTR);
	IF .DISPID EQL 0 THEN SIGNAL(DBG$_NOSUCHDISP, 1, .NAMEPTR);
	IF .DISPID[DBG$V_DISP_REMOVE] THEN SIGNAL(DBG$_DISNOTSEL);
	END;


    ! Fill in the selection kind and the specified Display ID into the Noun
    ! Node.  That completes the Verb and Noun Nodes, and we return.
    !
    NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE);
    NOUN_NODE[DBG$L_NOUN_VALUE] = .SELECT_BITS;
    NOUN_NODE[DBG$L_NOUN_VALUE2] = .DISPID;
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SETTERM_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SET TERMINAL command.  It accepts a command
!	line string descriptor as input and produces a Verb Node for the
!	command as output.  That Verb Node and its attached Noun Node later
!	serve as input to EXECUTE_SETTERM_CMD, which actually executes the
!	command.  The SET TERMINAL command accepts no parameters and only
!	one qualifier, the /WIDTH:n qualifier, which is mandatory at present.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SET TERMINAL keywords.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it and its
!		  attached Noun Node contain all information picked up during
!		  the parse of the SET TERMINAL command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to Noun Node
	WIDTH;				! The parsed terminal width



    ! Check for and parse the mandatory /WIDTH:n qualifier.
    !
    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_SLASH, 1)
    THEN
	DBG$SYNTAX_ERROR(.INPUT_DESC);

    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_WIDTH, 1)
    THEN
	DBG$SYNTAX_ERROR(.INPUT_DESC);

    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COLON, 1)
    THEN
	BEGIN
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_EQUAL, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	END;


    ! Pick up the specified terminal width and check it for validity.  (We
    ! force it to be in the range 72 - 132.)  Then allocate a Noun Node, store
    ! the new width in the Noun Node, and return.
    !
    DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, WIDTH);
    WIDTH = MAX(72, MIN(132, .WIDTH));
    NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE);
    NOUN_NODE[DBG$L_NOUN_VALUE] = .WIDTH;
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SETWIND_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SET WINDOW command. It accepts a command line
!	string descriptor as input and produces a Verb Node for the parsed SET
!	WINDOW command as output.  That Verb Node and its attached Noun Node
!	later serve as input to DBG$SCR_EXECUTE_SETWIND_CMD which actually
!	executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SET WINDOW keywords.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it and all
!		  its attached Noun Nodes contains all information picked up
!		  during the parse of the SET WINDOW command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	CBEG,				! Beginning column location of window
	CLEN,				! Column length (width) of window
	COL_INFO,			! Encoded column parameters
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to ASCIC window name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to current Noun Node
	RBEG,				! Beginning row location of window
	RLEN,				! Row length (height) of window
	ROW_INFO;			! Encoded row parameters



    ! Start by picking up the name of the screen window being defined.
    !
    NAMEPTR = PARSE_WINDOW_NAME(.INPUT_DESC);


    ! Next scan past the AT keyword and the opening parenthesis for the
    ! window parameters list.  After finding the open parenthesis, we
    ! parse all the window parameter values.
    !
    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_AT, 2)
    THEN
	DBG$SYNTAX_ERROR(.INPUT_DESC);

    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_LPAREN, 1)
    THEN
	DBG$SYNTAX_ERROR(.INPUT_DESC);

    PARSE_WINDOW_PARAMETERS(.INPUT_DESC, RBEG, RLEN, CBEG, CLEN);


    ! Allocate a Noun Node, attach it to the Verb Node, and fill all the
    ! window parameters into the Noun Node.  Then return.
    !
    NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE_LONG);
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;
    NOUN_NODE[DBG$L_NOUN_VALUE] = .NAMEPTR;
    ROW_INFO<W0_> = .RBEG;
    ROW_INFO<W1_> = .RLEN;
    NOUN_NODE[DBG$L_NOUN_VALUE2] = .ROW_INFO;
    COL_INFO<W0_> = .CBEG;
    COL_INFO<W1_> = .CLEN;
    NOUN_NODE[DBG$L_NOUN_VALUE3] = .COL_INFO;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SHODISP_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SHOW DISPLAY command.  It accepts a command
!	line string descriptor as input and produces a Verb Node for the parsed
!	SHOW DISPLAY command as output.  That Verb Node later serves as input
!	to DBG$SCR_EXECUTE_SHODISP_CMD which actually executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SHOW DISPLAY keywords.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it contains
!		  all information picked up during the parse of the SHOW
!		  DISPLAY command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	XXXXXXX;			!<<--------- Local declarations --------



    ! At present the SHOW DISPLAY command has no qualifiers or parameters.
    ! Hence there is nothing to parse and we return immediately.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_PARSE_SHOWIND_CMD(INPUT_DESC, VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine parses the SHOW WINDOW command. It accepts a command line
!	string descriptor as input and produces a Verb Node for the parsed SHOW
!	WINDOW command as output.  That Verb Node later serves as input to
!	DBG$SCR_EXECUTE_SHOWIND_CMD which actually executes the command.
!
! INPUTS
!	INPUT_DESC - A string descriptor pointing to the input line being
!		  parsed.  The descriptor is assumed to be pointing to the
!		  first character after the SHOW WINDOW keywords.
!
!	VERB_NODE - A pointer to the Verb Node to be built up for the command
!		  being parsed.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the end of the command.  This normally
!		  means that the input string is exhausted.
!
!	VERB_NODE - The passed-in Verb Node is filled in so that it contains
!		  all information picked up during the parse of the SHOW WINDOW
!		  command.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	XXXXXXX;			!<<--------- Local declarations --------



    ! At present the SHOW WINDOW command has no qualifiers or parameters.
    ! Hence there is nothing to parse and we return immediately.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_READ_LINE(RABPTR) =
!
! FUNCTION
!	This routine reads a line of command input from the user's terminal.
!	If a current input display has been selected, the input line is read
!	from that display; otherwise the line is read from the user program
!	scrolling window.  The routine in effect simulates a call to the $GET
!	system service: It accepts a pointer to a RAB as input and it produces
!	a status code as output.  All information about the the prompt string
!	to be used and the input buffer to be filled is gotten from the RAB
!	and all outputs other than the status code (for example, the actual
!	input length) are returned to the RAB.
!
!	This routine should not be called if input is coming from an indirect
!	command file--it handles terminal input only.
!
! INPUTS
!	RABPTR	- A pointer to an RMS Record Access Block (RAB) for the
!		  desired input operation.  This RAB must contain the proper
!		  input buffer and prompt string information for the I/O
!		  operation to be performed.
!
! OUTPUTS
!	RABPTR	- RABPTR itself is not modified, but the RAB it points to is
!		  changed to indicate the actual length of the input string
!		  that was read from the appropriate screen display.  Other
!		  fields that could be changed by a $GET operation may also
!		  by changed by this routine.
!
!	An RMS status code as could be produced by $GET is returned as this
!		  routine's value.  In particular, if the input operation is
!		  successful, SS$_NORMAL is returned.
!

    BEGIN

    MAP
	RABPTR: REF BLOCK[,BYTE];	! Pointer to input RAB

    LOCAL
	XXXXXXX;			!<<--------- Local declarations --------



    ! The text of the routine starts here.
    !
    !<<-------------------------- FIRST LINE OF CODE ---------------------------
    RETURN SS$_NORMAL;

    END;

GLOBAL ROUTINE DBG$SCR_SCREEN_MODE(SET_FLAG): NOVALUE =
!
! FUNCTION
!	This routine executes the SET MODE SCREEN and SET MODE NOSCREEN
!	commands to set or clear "screen mode".  When screen mode is set,
!	screen displays will be displayed on the terminal in the normal
!	manner.  However, when screen mode is cancelled, screen displays
!	are not shown on the terminal even though the user may have a
!	number of active displays defined.  Those displays can be re-
!	enabled by setting screen mode again.
!
!	Screen mode is set by setting the global flag DBG$GL_SCREEN_MODE
!	to TRUE.  The first time screen mode is set, the pre-define displays
!	SRC, REG, and OUT are also defined.  Terminal input and output are
!	directed to the appropriate screen displays as well.
!
!	Screen mode is cancelled by clearing DBG$GL_SCREEN_MODE.  In addi-
!	tion all screen input and output is cancelled so that subsequent
!	output goes through RMS in non-screen mode.
!
! INPUTS
!	SET_FLAG - If this flag is TRUE, screen mode is set by this routine.
!		  If the flag is FALSE, screen mode is cancelled.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	CMDPTR: REF VECTOR[,WORD],	! Pointer to the SRC command buffer
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	SCREEN_INFO: BLOCK[12,BYTE],	! Screen information control block
	STATUS,				! Screen package status code
	WPTR: REF DBG$WINDOW_ENTRY;	! Pointer to a Screen Window Entry



    ! If SET_FLAG is TRUE, we are executing the SET MODE SCREEN command and we
    ! set "screen mode".
    !
    IF .SET_FLAG
    THEN
	BEGIN
	DBG$GL_SCREEN_MODE = TRUE;


	! The first time screen mode is set, we direct screen output to logical
	! name DBG$OUTPUT if this name is defined.  We also "predefine" the SRC
	! source display, the REG register display, and the OUT output display.
	! SRC is marked as removed if the current language is MACRO or BASIC and
	! REG is marked as removed if the current language is anything else.
	!
	IF .SCREEN_MODE_FIRST_TIME
	THEN
	    BEGIN


	    ! If the logical name DBG$OUTPUT exists, redirect the screen output
	    ! to that logical name.  Otherwise it goes to SYS$OUTPUT.
	    !
	    REDIRECT_SCREEN_OUTPUT();


	    ! Now get some information on the screen terminal.  The only piece
	    ! of information we actually use is whether this is a VT100 class
	    ! terminal or not.  If it is not, we disable the use of scrolling
	    ! regions (VT52s do not support scrolling regions).
	    !
	    STATUS = SCR$SCREEN_INFO(SCREEN_INFO);
	    IF NOT .STATUS THEN SIGNAL(.STATUS);
	    IF NOT .SCREEN_INFO[0, V_(1)] THEN DBG$GL_VT100_FLAG = FALSE;


	    ! Create source display SRC, an automatically updated display
	    ! which displays a window around the currently executed source
	    ! line.  Select SRC to be the current source display and the
	    ! the current scrolling display unless the language is MACRO or
	    ! BASIC.  For languages MACRO and BASIC, which do not support
	    ! source display, we mark this display as being removed.
	    !
	    WPTR = DBG$SCR_CREATE_TEMP_WINDOW(1, 9, 1, 132);
	    CMDPTR = DBG$GET_MEMORY(24/%UPVAL + 1);
	    CH$MOVE(21, UPLIT BYTE(%ASCII 'EXAMINE/SOURCE .0\%PC'), CMDPTR[1]);
	    CMDPTR[0] = 22;
	    DISPTR = DBG$SCR_CREATE_DISPLAY(UPLIT BYTE(%ASCIC 'SRC'),
					DBG$K_DISP_SOURCE, .WPTR, 50, .CMDPTR);
	    IF (.DBG$GB_LANGUAGE EQL DBG$K_MACRO) OR
	       (.DBG$GB_LANGUAGE EQL DBG$K_BASIC)
	    THEN
		DISPTR[DBG$V_DISP_REMOVE] = TRUE

	    ELSE
		BEGIN
		DBG$SCR_CURDISP_SOURCE = .DISPTR;
		DBG$SCR_CURDISP_SCROLL = .DISPTR;
		END;


	    ! Create register display REG.  This display is marked as removed
	    ! for all languages other than MACRO and BASIC.
	    !
	    WPTR = DBG$SCR_CREATE_TEMP_WINDOW(1, 5, 1, 132);
	    DISPTR = DBG$SCR_CREATE_DISPLAY(UPLIT BYTE(%ASCIC 'REG'),
					DBG$K_DISP_REGISTER, .WPTR, 5, 0);
	    IF (.DBG$GB_LANGUAGE EQL DBG$K_MACRO) OR
	       (.DBG$GB_LANGUAGE EQL DBG$K_BASIC)
	    THEN
		REGISTER_DISPLAY(.DISPTR, DBG$RUNFRAME[DBG$L_USER_REGS])

	    ELSE
		BEGIN
		DISPTR[DBG$V_DISP_REMOVE] = TRUE;
		DISPTR[DBG$W_DISP_RBEG] = 7;
		END;


	    ! Create display OUT, the standard output display.  Select it as
	    ! the current output display.  If the current language is MACRO or
	    ! BASIC, we also select it as the current scrolling display and
	    ! adjust the window to fit with the REG display.
	    !
	    WPTR = DBG$SCR_CREATE_TEMP_WINDOW(11, 9, 1, 132);
	    DISPTR = DBG$SCR_CREATE_DISPLAY(UPLIT BYTE(%ASCIC 'OUT'),
					DBG$K_DISP_NORMAL, .WPTR, 100, 0);
	    DBG$SCR_CURDISP_OUTPUT = .DISPTR;
	    IF (.DBG$GB_LANGUAGE EQL DBG$K_MACRO) OR
	       (.DBG$GB_LANGUAGE EQL DBG$K_BASIC)
	    THEN
		BEGIN
		DBG$SCR_CURDISP_SCROLL = .DISPTR;
		DISPTR[DBG$W_DISP_RBEG] = 7;
		DISPTR[DBG$W_DISP_RLEN] = 13;
		END;


	    ! Clear the "first-time" flag so that we do not do the above
	    ! initialization the next time screen mode is entered.
	    !
	    SCREEN_MODE_FIRST_TIME = FALSE;
	    END;


	! Mark all lines in the "old" screen image as invalid.  This ensures
	! that DEBUG won't make any assumptions about the previous screen
	! contents when first putting displays on the screen.
	!
	INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	    OLD_VALID[.I] = FALSE;


	! Set up the active input and output displays.  Here we set them to be
	! the currently selected input and output displays.  We then return.
	!
	DBG$GL_SCREEN_INPUT = .DBG$SCR_CURDISP_INPUT;
	DBG$GL_SCREEN_OUTPUT = .DBG$SCR_CURDISP_OUTPUT;
	DBG$GL_SCREEN_SOURCE = .DBG$SCR_CURDISP_SOURCE;
	RETURN;
	END;


    ! If we get here, SET_FLAG is FALSE, so we cancel screen mode and return.
    !
    DBG$GL_SCREEN_MODE = FALSE;
    DBG$GL_SCREEN_ERROR = 0;
    DBG$GL_SCREEN_INPUT = 0;
    DBG$GL_SCREEN_OUTPUT = 0;
    DBG$GL_SCREEN_SOURCE = 0;
    STATUS = SCR$SET_SCROLL(1, 24);
    IF NOT .STATUS THEN SIGNAL(.STATUS);
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_SCREEN_NORMAL: NOVALUE =
!
! FUNCTION
!	This routine sets the screen back to "normal" if we are in Screen
!	Mode and it invalidates the current screen contents.  It is called
!	when we are about to break out from DEBUG with a SPAWN or ATTACH
!	command.  Hence the new process entered via SPAWN or ATTACH sees
!	a normal terminal screen with a full-screen scrolling region.  How-
!	ever, since the current screen contents are invalidated, the whole
!	screen is automatically refreshed when we later reenter DEBUG from
!	the SPAWN or ATTACH command.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	STATUS;				! Status code from screen package



    ! If Screen Mode is not set, there is nothing to do and we just return.
    !
    IF NOT .DBG$GL_SCREEN_MODE THEN RETURN;


    ! Screen Mode is set.  Invalidate the current screen contents and set the
    ! scrolling region to be the whole screen.  Then return.
    !
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	OLD_VALID[.I] = FALSE;

    STATUS = SCR$SET_SCROLL(1, 24);
    IF NOT .STATUS THEN SIGNAL(.STATUS);
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_SCREEN_TERM: NOVALUE =
!
! FUNCTION
!	This routine refreshes the screen and re-enables screen output
!	redirection on behalf of the DEBUG termination handler (exit
!	handler) that is called when the user program terminates.  In
!	effect, the purpose of this routine is to undo the effects of
!	the Screen Package Exit Handler which turns off output redirec-
!	tion and resets the scrolling region to the whole screen.  Hence
!	this routine turns on output redirection if DBG$OUTPUT is defined
!	and it invalidates the screen so that the whole screen is re-
!	freshed the next time it is updated.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN



    ! If Screen Mode is not set, there is nothing to do and we just return.
    !
    IF NOT .DBG$GL_SCREEN_MODE THEN RETURN;


    ! Screen Mode is set.  Redirect screen output to DBG$OUTPUT if this
    ! logical name is defined.  Then invalidate the current screen contents
    ! and set the scrolling region to be the whole screen.  Then return.
    !
    REDIRECT_SCREEN_OUTPUT();
    DBG$SCR_SCREEN_NORMAL();
    RETURN;

    END;

ROUTINE DBG$SCR_SCREEN_TO_LOGFILE: NOVALUE =
!
! FUNCTION
!	This routine logs the entire contents of the terminal screen to the
!	current log-file provided that screen mode is set and that screen
!	logging has been enabled.  It simply outputs all screen contents,
!	including the rendition information, to the log file in a readable
!	format.  Screen logging is useful for error reporting and is required
!	by the DEBUG Test System.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    BIND
	HEADER_LINE = UPLIT BYTE(%ASCII '!     +----+----1----+----2----+----3',
			'----+----4----+----5----+----6----+----7----+----8+'),
	HEADER_132 = UPLIT BYTE(%ASCII '!     +----+----9----+----0',
			'----+----1----+----2----+----3--+'),
	HEX_TABLE = UPLIT BYTE(%ASCII '0123456789ABCDEF'): VECTOR[,BYTE];

    LOCAL
	BUFFER: VECTOR[132,BYTE],	! Output formatting buffer
	FIRST_TIME_FLAG,		! Flag set first time line is output
	LENGTH;				! The length of the formatted log line



    ! Output the header line for the first 80 columns of screen image.
    !
    DBG$WRITE_LOG_FILE(88, HEADER_LINE);


    ! Output the first 80 columns of screen image to the log file.
    !
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	BEGIN


	! Format the log line for the current screen line and fill in the
	! text of the first 80 columns of screen image.
	!
	CH$FILL(' ', 112, BUFFER);
	BUFFER[0] = '!';
	BUFFER[2] = (((.I + 1)/10) MOD 10) + '0';
	IF .BUFFER[2] EQL '0' THEN BUFFER[2] = ' ';
	BUFFER[3] = ((.I + 1) MOD 10) + '0';
	BUFFER[4] = ':';
	BUFFER[6] = '|';
	BUFFER[87] = '|';
	LENGTH = 88;
	CH$MOVE(MIN(80, .OLD_CNT[.I]), OLD_SCREEN[.I*132], BUFFER[7]);


	! Format the length of the screen line and fill it in at the end of
	! the log line.
	!
	CH$MOVE(8, UPLIT BYTE(%ASCII 'length ='), BUFFER[90]);
	IF .OLD_CNT[.I] GTR 999 THEN BUFFER[98] = '*';
	BUFFER[99] = ((.OLD_CNT[.I]/100) MOD 10) + '0';
	BUFFER[100] = ((.OLD_CNT[.I]/10) MOD 10) + '0';
	BUFFER[101] = (.OLD_CNT[.I] MOD 10) + '0';
	LENGTH = 102;
	IF .BUFFER[99] EQL '0' THEN BUFFER[99] = ' ';
	IF (.BUFFER[99] EQL ' ') AND (.BUFFER[100] EQL '0')
	THEN
	    BUFFER[100] = ' ';


	! If this line has a single rendition attribute for the whole line,
	! include that rendition code at the end of the line.
	!
	IF .OLD_REND[.I] NEQ 255
	THEN
	    BEGIN
	    CH$MOVE(8, UPLIT BYTE(%ASCII ', rend ='), BUFFER[102]);
	    BUFFER[111] = .HEX_TABLE[.OLD_REND[.I] AND %X'0F'];
	    LENGTH = 112;
	    END;


	! Write the formatted line to the log file.  Then loop for more.
	!
	DBG$WRITE_LOG_FILE(.LENGTH, BUFFER);
	END;


    ! Output a trailing header line to the log file.
    !
    DBG$WRITE_LOG_FILE(88, HEADER_LINE);


    ! Output columns 81 - 132 of screen image to the log file for those lines
    ! on the screen that have text in that column range.
    !
    FIRST_TIME_FLAG = TRUE;
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	BEGIN


	! Output columns 81 - 132 of this screen line only if text actually
	! exists in those columns.  Otherwise ignore the line.
	!
	IF .OLD_CNT[.I] GTR 80
	THEN
	    BEGIN


	    ! If this is the first line of this kind, output the header line
	    ! just ahead of it.
	    !
	    IF .FIRST_TIME_FLAG
	    THEN
		BEGIN
		FIRST_TIME_FLAG = FALSE;
		DBG$WRITE_LOG_FILE(60, HEADER_132);
		END;


	    ! Format the line, fill in the text from columns 81 - 132, and
	    ! output it to the log file.
	    !
	    CH$FILL(' ', 60, BUFFER);
	    BUFFER[0] = '!';
	    BUFFER[2] = (((.I + 1)/10) MOD 10) + '0';
	    IF .BUFFER[2] EQL '0' THEN BUFFER[2] = ' ';
	    BUFFER[3] = ((.I + 1) MOD 10) + '0';
	    BUFFER[4] = ':';
	    BUFFER[6] = '|';
	    BUFFER[59] = '|';
	    CH$MOVE(MIN(52, .OLD_CNT[.I] - 80),
					OLD_SCREEN[.I*132 + 80], BUFFER[7]);
	    DBG$WRITE_LOG_FILE(60, BUFFER);
	    END;

	END;


    ! If anything was output just above, output a trailing header line too.
    !
    IF NOT .FIRST_TIME_FLAG THEN DBG$WRITE_LOG_FILE(60, HEADER_132);


    ! Output the rendition information for all lines of text that have per-
    ! character rendition information.  The rendition information is repre-
    ! sented as one hex digit of rendition bits per character position.
    !
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	BEGIN
	IF .OLD_REND[.I] EQL 255
	THEN
	    BEGIN


	    ! Format the line, fill in the rendition bits for columns 1 - 80,
	    ! and output the line to the log file.
	    !
	    CH$FILL(' ', 87, BUFFER);
	    BUFFER[0] = '!';
	    BUFFER[2] = (((.I + 1)/10) MOD 10) + '0';
	    IF .BUFFER[2] EQL '0' THEN BUFFER[2] = ' ';
	    BUFFER[3] = ((.I + 1) MOD 10) + '0';
	    BUFFER[4] = ':';
	    INCR J FROM 0 TO MIN(80, .OLD_CNT[.I]) - 1 DO
		BEGIN
		BUFFER[.J + 7] = .HEX_TABLE[
				.OLD_SCREEN_REND[.I*132 + .J] AND %X'0F'];
		END;

	    DBG$WRITE_LOG_FILE(87, BUFFER);


	    ! If the line is longer than 80 columns, format the excess on a
	    ! separate line and output that line to the log file.
	    !
	    IF .OLD_CNT[.I] GTR 80
	    THEN
		BEGIN
		CH$FILL(' ', 59, BUFFER);
		BUFFER[0] = '!';
		BUFFER[4] = ':';
		INCR J FROM 80 TO MIN(132, .OLD_CNT[.I]) - 1 DO
		    BEGIN
		    BUFFER[.J + 7 - 80] = .HEX_TABLE[
				.OLD_SCREEN_REND[.I*132 + .J] AND %X'0F'];
		    END;

		DBG$WRITE_LOG_FILE(59, BUFFER);
		END;

	    END;

	END;


    ! The screen image has been logged.  Now return.
    !
    RETURN;

    END;

ROUTINE DBG$SCR_SCROLL_DISPLAY(DISPID, DIRECTION, AMOUNT): NOVALUE =
!
! FUNCTION
!	This routine scrolls a specified display in a specified direction.
!	The scrolling is done by adjusting the window specification associ-
!	ated with this display and by also adjusting the pasteboard appro-
!	priately if this display is present on the pasteboard.
!
! INPUTS
!	DISPID	- The Display ID of the display to be scrolled.  This is a
!		  pointer to the Screen Display Entry of that display.
!
!	DIRECTION - The direction in which the display is to be scrolled.
!		  The following values are accepted:
!
!			DBG$K_SCROLL_UP    -- Scroll the window up over the
!					      display text.
!			DBG$K_SCROLL_DOWN  -- Scroll the window down over the
!					      display text.
!			DBG$K_SCROLL_LEFT  -- Scroll the window to the left
!					      over the display text.
!			DBG$K_SCROLL_RIGHT -- Scroll the window to the right
!					      over the display text.
!
!	AMOUNT	- The amount to scroll the display.  This is either the number
!		  of lines to scroll it up or down or the number of columns to
!		  scroll it to the left or right.  This amount must always be
!		  zero or positive.
!
! OUTPUTS
!	NONE.
!

    BEGIN

    MAP
	DISPID: REF DBG$DISP_ENTRY;	! Pointer to Screen Display Entry for
					!      display to be scrolled

    LOCAL
	DELTA,				! Actual scroll movement up or down
	NEW_DROW,			! New DROW value when scolling up or down
	WSPTR: REF DBG$DLINE_ENTRY;	! Pointer to first line in display window



    ! Check that the scrolling amount is zero or positive.  If it is not,
    ! signal an internal DEBUG error.
    !
    IF .AMOUNT LSS 0 THEN $DBG_ERROR('DBGSCREEN\SCROLL_DISPLAY 10');


    ! Case on the scrolling direction to select the proper window adjustment.
    !
    CASE .DIRECTION FROM DBG$K_SCROLL_UP TO DBG$K_SCROLL_RIGHT OF
	SET


	! Scroll up the display.  Compute the new DROW value (the new row
	! location of the display window in the display text) and then compute
	! the difference between the old and new DROW values.  Then shift the
	! window pointer up the display text that number of lines and set the
	! scrolling count.
	!
	[DBG$K_SCROLL_UP]:
	    BEGIN
	    IF .DISPID[DBG$B_DISP_KIND] EQL DBG$K_DISP_SOURCE
	    THEN
		IF DBG$SCR_SCROLL_SOURCE_UP(.DISPID, .AMOUNT) THEN RETURN;

	    NEW_DROW = MAX(1, MIN(
		.DISPID[DBG$W_DISP_LINECNT] - .DISPID[DBG$W_DISP_RLEN] + 1,
		.DISPID[DBG$W_DISP_DROW] - .AMOUNT));
	    DELTA = .DISPID[DBG$W_DISP_DROW] - .NEW_DROW;
	    DISPID[DBG$W_DISP_DROW] = .NEW_DROW;
	    IF .DELTA GTR 0
	    THEN
		BEGIN
		DISPID[DBG$W_DISP_SCROLL] = .DISPID[DBG$W_DISP_SCROLL] - .DELTA;
		WSPTR = .DISPID[DBG$L_DISP_WINDOW_PTR];
		INCR I FROM 1 TO .DELTA DO
		    WSPTR = .WSPTR[DBG$L_DLINE_BLINK];

		DISPID[DBG$L_DISP_WINDOW_PTR] = .WSPTR;
		END;

	    END;


	! Scroll down the display.  Compute the new DROW value (the new row
	! location of the display window in the display text) and then compute
	! the difference between the old and new DROW values.  Then shift the
	! window pointer down the display text that number of lines and set the
	! scrolling count.
	!
	[DBG$K_SCROLL_DOWN]:
	    BEGIN
	    IF .DISPID[DBG$B_DISP_KIND] EQL DBG$K_DISP_SOURCE
	    THEN
		IF DBG$SCR_SCROLL_SOURCE_DOWN(.DISPID, .AMOUNT) THEN RETURN;

	    NEW_DROW = MAX(1, MIN(
		.DISPID[DBG$W_DISP_LINECNT] - .DISPID[DBG$W_DISP_RLEN] + 1,
		.DISPID[DBG$W_DISP_DROW] + .AMOUNT));
	    DELTA = .NEW_DROW - .DISPID[DBG$W_DISP_DROW];
	    DISPID[DBG$W_DISP_DROW] = .NEW_DROW;
	    IF .DELTA GTR 0
	    THEN
		BEGIN
		DISPID[DBG$W_DISP_SCROLL] = .DISPID[DBG$W_DISP_SCROLL] + .DELTA;
		WSPTR = .DISPID[DBG$L_DISP_WINDOW_PTR];
		INCR I FROM 1 TO .DELTA DO
		    WSPTR = .WSPTR[DBG$L_DLINE_FLINK];

		DISPID[DBG$L_DISP_WINDOW_PTR] = .WSPTR;
		END;

	    END;


	! Scroll to the left side of the display.  This only requires adjusting
	! the display column value (DCOL).  Note, however, that we do not allow
	! DCOL to become less than 1.
	!
	[DBG$K_SCROLL_LEFT]:
	    DISPID[DBG$W_DISP_DCOL] = MAX(1, .DISPID[DBG$W_DISP_DCOL] - .AMOUNT);


	! Scroll to the right side of the display.  This also only requires
	! adjusting the display column value (DCOL).  Note that we do not allow
	! DCOL to exceed 133.
	!
	[DBG$K_SCROLL_RIGHT]:
	    DISPID[DBG$W_DISP_DCOL] = MIN(133, .DISPID[DBG$W_DISP_DCOL] + .AMOUNT);


	! Any other scrolling direction constitutes an internal DEBUG error.
	!
	[INRANGE, OUTRANGE]:
	    $DBG_ERROR('DBGSCREEN\SCROLL_DISPLAY 20');

	TES;


    ! The scrolling is completed.  Now return.
    !
    RETURN;

    END;

ROUTINE DBG$SCR_SCROLL_SOURCE_DOWN(DISPID, AMOUNT) =
!
! FUNCTION
!	This routine scrolls the window down over a source display a specified
!	number of lines.  It accepts as input a pointer to the Screen Display
!	Entry of a display to be scrolled down and the amount by which it is to
!	be scrolled.  It then determines if the display can be scrolled entire-
!	ly "in memory", i.e. within the Display Line Entries already attached
!	to the display.  If it can, this routine returns FALSE and lets the
!	caller (namely DBG$SCR_SCROLL_DISPLAY) do the actual scrolling.
!
!	If the display cannot be scrolled "in memory", this routine discards
!	the current display contents, computes a new central line number, and
!	calls DBG$SRC_TYPE_LNUM_SOURCE to read in a range of source lines
!	around that central line number.  It does the necessary bookkeeping
!	to allow a scrolling count to be computed for the display.  After the
!	display has been filled with the new source lines, this routine returns
!	TRUE to indicate that the scrolling operation has been fully completed.
!
! INPUTS
!	DISPID	- The Display ID (a pointer to the Screen Display Entry) of
!		  the source display to be scrolled.
!
!	AMOUNT	- The number of lines by which the DISPID display is to be
!		  scrolled down.  This number must be zero or positive.
!
! OUTPUTS
!	If this routine scrolled the DISPID display, then TRUE is returned as
!		  the routine value.  If the DISPID display was not scrolled
!		  because there is no need to read in more source lines into
!		  the display, then FALSE is returned as the routine value.
!

    BEGIN

    MAP
	DISPID: REF DBG$DISP_ENTRY;	! Pointer to Display Entry to scroll

    LOCAL
	CENTRAL_LINE,			! Central line number for new source
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Screen Display Line Entry
	FLINK,				! Temporary pointer to Error Line Entry
	INVSCR_FLAG,			! Saved invalidate-scroll-count flag
	SAVED_NEXT_LNUM,		! Saved value of DBG$SRC_NEXT_LNUM
	SAVED_SCREEN_SOURCE: VOLATILE;	! Saved value of DBG$GL_SCREEN_SOURCE

    ENABLE
	HANDLER_SCROLL_SOURCE(		! Condition handler to restore the
		SAVED_SCREEN_SOURCE);	!      value of DBG$GL_SCREEN_SOURCE
					!      in case of error condition



    ! We release all Error Line Entries attached to the display whenever it is
    ! scrolled vertically (up or down).
    !
    DLEPTR = .DISPID[DBG$L_DISP_ERROR_PTR];
    DISPID[DBG$L_DISP_ERROR_PTR] = 0;
    WHILE .DLEPTR NEQ 0 DO
	BEGIN
	FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .FLINK;
	END;


    ! If the source display can be scrolled the desired amount entirely within
    ! the Display Line Entries it already has in memory, return immediately
    ! with the value FALSE.  This tells the caller to do the scrolling.
    !
    IF .DISPID[DBG$V_DISP_ATBOT] THEN RETURN FALSE;
    IF (.DISPID[DBG$W_DISP_DROW] + .AMOUNT) LEQ
		(.DISPID[DBG$W_DISP_LINECNT] - .DISPID[DBG$W_DISP_RLEN] + 1)
    THEN
	RETURN FALSE;

    IF .DISPID[DBG$L_DISP_WINDOW_PTR] EQL 0 THEN RETURN FALSE;


    ! The display will have to be scrolled by reading in a new range of line
    ! numbers centered around the line to which the user wants to scroll.
    ! Compute the new central line number around which we will request a range
    ! of source lines.
    !
    DLEPTR = .DISPID[DBG$L_DISP_WINDOW_PTR];
    IF .DLEPTR[DBG$L_DLINE_LINUM] LSS 0
    THEN
	DLEPTR = WINDOW_SOURCE_LINE(.DISPID, TRUE);

    CENTRAL_LINE = MAX(.DISPID[DBG$L_DISP_MINLINE],
			MIN(.DISPID[DBG$L_DISP_MAXLINE],
				.DLEPTR[DBG$L_DLINE_LINUM] +
				(.DISPID[DBG$W_DISP_RLEN] - 1)/2 + .AMOUNT));


    ! If CENTRAL_LINE is the very last line of the module's source text, set
    ! the SCROLL_TO_BOTTOM flag for the DBG$SCR_SOURCE_END routine.
    !
    SCROLL_TO_BOTTOM = FALSE;
    IF .CENTRAL_LINE EQL .DISPID[DBG$L_DISP_MAXLINE]
    THEN
	SCROLL_TO_BOTTOM = TRUE;


    ! Now read in a new range of source lines centered around the new central
    ! line number.  Routines DBG$SCR_SOURCE_BEGIN, DBG$SCR_SOURCE_LINE, and
    ! DBG$SCR_SOURCE_END will do the actual scrolling of the source display.
    ! Note that we preserve DBG$SRC_NEXT_LNUM (the next line number for some
    ! of the source display commands) over a scrolling operation.
    !
    SCROLL_AMOUNT = .AMOUNT;
    FIXED_SCROLL_AMOUNT = TRUE;
    FIXED_SCROLL_VALID = TRUE;
    MARKLINE_DISABLE_FLAG = TRUE;
    SAVED_NEXT_LNUM = .DBG$SRC_NEXT_LNUM;
    SAVED_SCREEN_SOURCE = .DBG$GL_SCREEN_SOURCE;
    DBG$GL_SCREEN_SOURCE = .DISPID;
    DBG$SRC_TYPE_LNUM_SOURCE(.DISPID[DBG$L_DISP_MODPTR],
			.CENTRAL_LINE, 0, .CENTRAL_LINE, 0, FALSE, FALSE);
    DBG$GL_SCREEN_SOURCE = .SAVED_SCREEN_SOURCE;
    DBG$SRC_NEXT_LNUM = .SAVED_NEXT_LNUM;


    ! We are all done scrolling the source display.  Now return.
    !
    RETURN TRUE;

    END;

ROUTINE DBG$SCR_SCROLL_SOURCE_UP(DISPID, AMOUNT) =
!
! FUNCTION
!	This routine scrolls the window up over a source display a specified
!	number of lines.  It accepts as input a pointer to the Screen Display
!	Entry of a display to be scrolled up and the amount by which it is to
!	be scrolled.  It then determines if the display can be scrolled entire-
!	ly "in memory", i.e. within the Display Line Entries already attached
!	to the display.  If it can, this routine returns FALSE and lets the
!	caller (namely DBG$SCR_SCROLL_DISPLAY) do the actual scrolling.
!
!	If the display cannot be scrolled "in memory", this routine discards
!	the current display contents, computes a new central line number, and
!	calls DBG$SRC_TYPE_LNUM_SOURCE to read in a range of source lines
!	around that central line number.  It does the necessary bookkeeping
!	to allow a scrolling count to be computed for the display.  After the
!	display has been filled with the new source lines, this routine returns
!	TRUE to indicate that the scrolling operation has been fully completed.
!
! INPUTS
!	DISPID	- The Display ID (a pointer to the Screen Display Entry) of
!		  the source display to be scrolled.
!
!	AMOUNT	- The number of lines by which the DISPID display is to be
!		  scrolled up.  This number must be zero or positive.
!
! OUTPUTS
!	If this routine scrolled the DISPID display, then TRUE is returned as
!		  the routine value.  If the DISPID display was not scrolled
!		  because there is no need to read in more source lines into
!		  the display, then FALSE is returned as the routine value.
!

    BEGIN

    MAP
	DISPID: REF DBG$DISP_ENTRY;	! Pointer to Display Entry to scroll

    LOCAL
	CENTRAL_LINE,			! Central line number for new source
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Screen Display Line Entry
	FLINK,				! Temporary pointer to Error Line Entry
	INVSCR_FLAG,			! Saved invalidate-scroll-count flag
	SAVED_NEXT_LNUM,		! Saved value of DBG$SRC_NEXT_LNUM
	SAVED_SCREEN_SOURCE: VOLATILE;	! Saved value of DBG$GL_SCREEN_SOURCE

    ENABLE
	HANDLER_SCROLL_SOURCE(		! Condition handler to restore the
		SAVED_SCREEN_SOURCE);	!      value of DBG$GL_SCREEN_SOURCE
					!      in case of error condition



    ! We release all Error Line Entries attached to the display whenever it is
    ! scrolled vertically (up or down).
    !
    DLEPTR = .DISPID[DBG$L_DISP_ERROR_PTR];
    DISPID[DBG$L_DISP_ERROR_PTR] = 0;
    WHILE .DLEPTR NEQ 0 DO
	BEGIN
	FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .FLINK;
	END;


    ! If the source display can be scrolled the desired amount entirely within
    ! the Display Line Entries it already has in memory, return immediately
    ! with the value FALSE.  This tells the caller to do the scrolling.
    !
    IF .DISPID[DBG$V_DISP_ATTOP] THEN RETURN FALSE;
    IF (.DISPID[DBG$W_DISP_DROW] - .AMOUNT) GTR 0 THEN RETURN FALSE;
    IF .DISPID[DBG$L_DISP_WINDOW_PTR] EQL 0 THEN RETURN FALSE;


    ! The display will have to be scrolled by reading in a new range of line
    ! numbers centered around the line to which the user wants to scroll.
    ! Compute the new central line number around which we will request a range
    ! of source lines.
    !
    DLEPTR = .DISPID[DBG$L_DISP_WINDOW_PTR];
    IF .DLEPTR[DBG$L_DLINE_LINUM] LSS 0
    THEN
	DLEPTR = WINDOW_SOURCE_LINE(.DISPID, FALSE);

    CENTRAL_LINE = MAX(.DISPID[DBG$L_DISP_MINLINE],
			MIN(.DISPID[DBG$L_DISP_MAXLINE],
				.DLEPTR[DBG$L_DLINE_LINUM] +
				(.DISPID[DBG$W_DISP_RLEN] - 1)/2 - .AMOUNT));


    ! Now read in a new range of source lines centered around the new central
    ! line number.  Routines DBG$SCR_SOURCE_BEGIN, DBG$SCR_SOURCE_LINE, and
    ! DBG$SCR_SOURCE_END will do the actual scrolling of the source display.
    ! Note that we preserve DBG$SRC_NEXT_LNUM (the next line number for some
    ! of the source display commands) over a scrolling operation.
    !
    SCROLL_AMOUNT = -.AMOUNT;
    FIXED_SCROLL_AMOUNT = TRUE;
    FIXED_SCROLL_VALID = TRUE;
    SCROLL_TO_BOTTOM = FALSE;
    MARKLINE_DISABLE_FLAG = TRUE;
    SAVED_NEXT_LNUM = .DBG$SRC_NEXT_LNUM;
    SAVED_SCREEN_SOURCE = .DBG$GL_SCREEN_SOURCE;
    DBG$GL_SCREEN_SOURCE = .DISPID;
    DBG$SRC_TYPE_LNUM_SOURCE(.DISPID[DBG$L_DISP_MODPTR],
			.CENTRAL_LINE, 0, .CENTRAL_LINE, 0, FALSE, FALSE);
    DBG$GL_SCREEN_SOURCE = .SAVED_SCREEN_SOURCE;
    DBG$SRC_NEXT_LNUM = .SAVED_NEXT_LNUM;


    ! We are all done scrolling the source display.  Now return.
    !
    RETURN TRUE;

    END;

GLOBAL ROUTINE DBG$SCR_SOURCE_BEGIN(OLD_LOW, OLD_HIGH,
			NEW_LOW, NEW_HIGH, MODRSTPTR, ALL_DONE_FLAG): NOVALUE =
!
! FUNCTION
!	This routine sets up the output of source lines to a SOURCE screen
!	display.  It also computes the range to source lines to get for this
!	display based on the display size.  After this routine is called, calls
!	on DBG$SCR_SOURCE_LINE are used to actually output the individual lines
!	to the current SOURCE display.
!
!	This routine accepts a line number range and a Module RST Entry pointer
!	as input.  The line number range is derived from the source display
!	command which is being intercepted--it usually consists of only a
!	single line.  The output of this routine is a modified line number
!	range which is calculated to produce a suitable number of lines around
!	the central line of the original range, given the size of the screen
!	display.  The Module RST Entry pointer is saved in the selected SOURCE
!	Screen Display Entry and is later used to retrieve the module name.
!
!	In order to prevent unnecessary I/O, this routine checks whether the
!	screen display's Line Entry List already contains the entire range of
!	lines needed to fill the display's screen window.  If it does, the
!	display is simply scrolled (the window pointer, DROW, and scrolling
!	count are computed and set), and TRUE is returned to the ALL_DONE_FLAG
!	parameter.  This tells the caller to omit the reading of source lines.
!
! INPUTS
!	OLD_LOW	- The lower line number of the original line number range
!		  requested by the intercepted source line display command.
!
!	OLD_HIGH - The upper line number of the original line number range
!		  requested by the intercepted source line display command.
!
!	NEW_LOW	- The address of a longword location to receive the lower line
!		  number of the recomputed line number range.
!
!	NEW_HIGH - The address of a longword location to receive the upper line
!		  number of the recomputed line number range.
!
!	MODRSTPTR - A pointer to the Module RST Entry of the module from which
!		  source lines are being displayed.
!
!	ALL_DONE_FLAG - The address of a longword location to receive a flag
!		  value saying that the source operation is all done when
!		  this routine returns.
!
! OUTPUTS
!	NEW_LOW	- A recomputed lower line number is returned to the NEW_LOW
!		  location.  This recomputed lower bound will actually be
!		  used when source lines are retrieved from the source files.
!
!	NEW_HIGH - A recomputed upper line number is returned to the NEW_HIGH
!		  location.  This recomputed upper bound will actually be
!		  used when source lines are retrieved from the source files.
!
!	ALL_DONE_FLAG - The value TRUE is returned to ALL_DONE_FLAG if the
!		  desired range of source lines is already in the current
!		  source display data structure.  The significance of this
!		  is that there is no need to read in any more source lines
!		  since we already have the desired source lines.  FALSE is
!		  returned if we do not have all needed source lines, in
!		  which case more must be read in from the source files.
!

    BEGIN

    MAP
	NEW_LOW: REF VECTOR[1,LONG],	! Pointer to new lower line number
	NEW_HIGH: REF VECTOR[1,LONG],	! Pointer to new upper line number
	ALL_DONE_FLAG:			! Pointer to the all-done-flag which
		REF VECTOR[1,LONG];	!      says we already have the source
					!      lines being requested

    LOCAL
	CENTER_LINE,			! Central line number of display text
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Source Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Source Display Line Entry
	MAXLINE,			! Maximum line number in desired range
	MINLINE,			! Minimum line number in desired range
	SCROLL_AMOUNT,			! Amount to scroll display if display
					!      already has the desired lines
	SIZE;				! Number of source lines to get for
					!      this display

    LABEL
	CHECK_HAVE_LINES;		! Block that checks whether we already
					!      have the desired range of lines



    ! Pick up the pointer to the SOURCE Screen Display Entry.  Check it and
    ! the input parameters for validity.
    !
    DISPTR = .DBG$GL_SCREEN_SOURCE;
    IF .DISPTR[DBG$B_DISP_KIND] NEQ DBG$K_DISP_SOURCE
    THEN
	$DBG_ERROR('DBGSCREEN\SOURCE_BEGIN 10');

    IF .OLD_LOW GTR .OLD_HIGH THEN $DBG_ERROR('DBGSCREEN\SOURCE_BEGIN 20');


    ! If we came in because of a TYPE or EXAMINE/SOURCE command, mark the
    ! fixed-scroll-amount flag as false.  This flag should only be true if we
    ! came here because of SCROLL command which requires more source lines
    ! to be read into the scrolled display.  The flag is later used in the
    ! DBG$SCR_SOURCE_END routine to determine the scrolling count.
    !
    IF NOT .FIXED_SCROLL_VALID THEN FIXED_SCROLL_AMOUNT = FALSE;
    FIXED_SCROLL_VALID = FALSE;


    ! Check whether we already have the source lines to be display in the
    ! Screen Display Line Entry List for this source diplay.  If so, there
    ! is no need to read them in from the source file.
    !
    CHECK_HAVE_LINES:
	BEGIN


	! If the source module to be displayed is different from the module we
	! have in this screen display, we must read in the source lines from
	! the source file, so we leave CHECK_HAVE_LINES.  Similarly, if the
	! display does not at present have any lines, we leave.
	!
	IF (.MODRSTPTR NEQ .DISPTR[DBG$L_DISP_MODPTR]) OR
	   (.DISPTR[DBG$W_DISP_LINECNT] EQL 0)
	THEN
	    LEAVE CHECK_HAVE_LINES;


	! Compute the new range of line numbers we want to display in the
	! screen display's window.
	!
	CENTER_LINE = .OLD_LOW + (.OLD_HIGH - .OLD_LOW)/2;
	MINLINE = MAX(.DISPTR[DBG$L_DISP_MINLINE],
			.CENTER_LINE - (.DISPTR[DBG$W_DISP_RLEN] - 1)/2);
	MAXLINE = MIN(.DISPTR[DBG$L_DISP_MAXLINE],
			.MINLINE + .DISPTR[DBG$W_DISP_RLEN] - 1);
	MINLINE = MAX(.DISPTR[DBG$L_DISP_MINLINE],
			.MAXLINE - .DISPTR[DBG$W_DISP_RLEN] + 1);


	! See if this range of line numbers is already present in the Screen
	! Display Line Entry List for this screen display.  If not, we leave
	! CHECK_HAVE_LINES so that the lines are read in from the source file.
	!
	DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
	IF .DLEPTR[DBG$L_DLINE_LINUM] GTR .MINLINE THEN LEAVE CHECK_HAVE_LINES;
	DLEPTR = .DISPTR[DBG$L_DISP_END_LINE_PTR];
	IF .DLEPTR[DBG$L_DLINE_LINUM] LSS .MAXLINE THEN LEAVE CHECK_HAVE_LINES;


	! The desired range of source lines is already in the Screen Display
	! Line Entry List.  Now determine whether to scroll up or down the
	! display to get the desired lines in the screen window.  If we must
	! scroll up we determine the scrolling amount in the up direction by
	! counting how many lines the window pointer must be moved up.
	!
	SCROLL_AMOUNT = 0;
	DLEPTR = .DISPTR[DBG$L_DISP_WINDOW_PTR];
	IF .DLEPTR[DBG$L_DLINE_LINUM] GEQ .MINLINE
	THEN
	    BEGIN
	    WHILE .DLEPTR[DBG$L_DLINE_LINUM] GTR .MINLINE DO
		BEGIN
		SCROLL_AMOUNT = .SCROLL_AMOUNT - 1;
		DLEPTR = .DLEPTR[DBG$L_DLINE_BLINK];
		IF .DLEPTR EQL DISPTR[DBG$L_DISP_START_LINE_PTR]
		THEN
		    $DBG_ERROR('DBGSCREEN\SOURCE_BEGIN 30');

		END;

	    END


	! Else we must scroll down.  We determine the scrolling amount in the
	! down direction by counting how many lines the window pointer must be
	! moved down.
	!
	ELSE
	    BEGIN
	    WHILE .DLEPTR[DBG$L_DLINE_LINUM] LSS .MINLINE DO
		BEGIN
		SCROLL_AMOUNT = .SCROLL_AMOUNT + 1;
		DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
		IF .DLEPTR EQL DISPTR[DBG$L_DISP_START_LINE_PTR]
		THEN
		    $DBG_ERROR('DBGSCREEN\SOURCE_BEGIN 40');

		END;

	    END;


	! Now set the updated window pointer, adjust the DROW value (display
	! row location of start of window), and fill in the scrolling count.
	! Also set the center line number in the Display Entry.
	!
	DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;
	DISPTR[DBG$W_DISP_DROW] = .DISPTR[DBG$W_DISP_DROW] + .SCROLL_AMOUNT;
	DISPTR[DBG$W_DISP_SCROLL] = .DISPTR[DBG$W_DISP_SCROLL] + .SCROLL_AMOUNT;
	DISPTR[DBG$L_DISP_CENTER] = MAX(.DISPTR[DBG$L_DISP_MINLINE],
			MIN(.DISPTR[DBG$L_DISP_MAXLINE], .CENTER_LINE));


	! Set the next line number (as used by the parameter-less TYPE and
	! SEARCH commands) to be the specified center line plus one.
	!
	DBG$SRC_NEXT_LNUM = .DISPTR[DBG$L_DISP_CENTER] + 1;


	! Unless the user is typing a range of line numbers (as opposed to a
	! single line) and unless marking is disabled because we are simply
	! scrolling, mark the central line as the line to be marked with a
	! "->" in the display.
	!
	DISPTR[DBG$L_DISP_MARKLINE] = -1;
	IF (.OLD_LOW EQL .OLD_HIGH) AND (NOT .MARKLINE_DISABLE_FLAG)
	THEN
	    DISPTR[DBG$L_DISP_MARKLINE] = .CENTER_LINE;

	MARKLINE_DISABLE_FLAG = FALSE;


	! The screen display is now positioned correctly at the desired range
	! of source lines.  Since there is no further need to read in any
	! source lines, we set the ALL_DONE_FLAG and return to the caller.
	!
	ALL_DONE_FLAG[0] = TRUE;
	RETURN;

	END;				! End of CHECK_HAVE_LINES block


    ! We do not yet have the desired source lines in the Display Line Entry
    ! List.  Hence we set the ALL_DONE_FLAG to FALSE.
    !
    ALL_DONE_FLAG[0] = FALSE;


    ! Save all information from the current contents of the Screen Display
    ! Entry that we will need to compute a scrolling count at the end of
    ! the source retrieval operation.
    !
    INVSCR_FLAG = .DISPTR[DBG$V_DISP_INVSCR];
    IF (NOT .INVSCR_FLAG) AND (.DISPTR[DBG$W_DISP_LINECNT] GTR 0)
    THEN
	BEGIN
	SAVED_SCROLL = .DISPTR[DBG$W_DISP_SCROLL];
	TOP_OFFSET = .DISPTR[DBG$W_DISP_DROW] - 1;
	BOT_OFFSET = .DISPTR[DBG$W_DISP_LINECNT] - .DISPTR[DBG$W_DISP_DROW];
	DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
	TOP_REF_FILEID = .DLEPTR[DBG$W_DLINE_FILEID];
	TOP_REF_RECNUM = .DLEPTR[DBG$L_DLINE_RECNUM];
	DLEPTR = .DISPTR[DBG$L_DISP_END_LINE_PTR];
	BOT_REF_FILEID = .DLEPTR[DBG$W_DLINE_FILEID];
	BOT_REF_RECNUM = .DLEPTR[DBG$L_DLINE_RECNUM];
	END;


    ! Empty the specified display of all its current contents.
    !
    DBG$SCR_EMPTY_DISPLAY(.DISPTR);


    ! If the source text is coming from a new module than before, set the new
    ! Module RST Entry pointer in the Display Entry and invalidate the scroll-
    ! ing count.  We also initialize all source line number information for the
    ! display, including the line number range of the module.
    !
    IF .MODRSTPTR NEQ .DISPTR[DBG$L_DISP_MODPTR]
    THEN
	BEGIN
	DISPTR[DBG$L_DISP_MODPTR] = .MODRSTPTR;
	DISPTR[DBG$V_DISP_INVSCR] = TRUE;
	DISPTR[DBG$L_DISP_MARKLINE] = -1;
	DBG$SRC_LNUM_RANGE(.MODRSTPTR,
		DISPTR[DBG$L_DISP_MINLINE], DISPTR[DBG$L_DISP_MAXLINE]);
	INVSCR_FLAG = TRUE;
	END;


    ! Compute the central line number of the original line number range and
    ! then compute the new line number range to retrieve, given the size of
    ! the current display.  Save the central line number in the Display Entry.
    !
    DISPTR[DBG$V_DISP_ATTOP] = FALSE;
    DISPTR[DBG$V_DISP_ATBOT] = FALSE;
    CENTER_LINE = .OLD_LOW + (.OLD_HIGH - .OLD_LOW)/2;
    SIZE = MAX(.DISPTR[DBG$W_DISP_RLEN], .DISPTR[DBG$W_DISP_MAX_LINECNT]);
    NEW_LOW[0] = .CENTER_LINE - (.SIZE - 1)/2;
    NEW_HIGH[0] = .CENTER_LINE + .SIZE/2;
    IF .NEW_LOW[0] LSS .DISPTR[DBG$L_DISP_MINLINE]
    THEN
	BEGIN
	NEW_LOW[0] = .DISPTR[DBG$L_DISP_MINLINE];
	NEW_HIGH[0] = .NEW_LOW[0] + (2*.SIZE - 1)/2;
	DISPTR[DBG$V_DISP_ATTOP] = TRUE;
	END;

    IF .NEW_HIGH[0] GTR .DISPTR[DBG$L_DISP_MAXLINE]
    THEN
	BEGIN
	NEW_HIGH[0] = .DISPTR[DBG$L_DISP_MAXLINE];
	NEW_LOW[0] = MAX(.DISPTR[DBG$L_DISP_MINLINE],
				.NEW_HIGH[0] - (2*.SIZE - 1)/2);
	DISPTR[DBG$V_DISP_ATBOT] = TRUE;
	END;

    DISPTR[DBG$L_DISP_CENTER] = MAX(.DISPTR[DBG$L_DISP_MINLINE],
			MIN(.DISPTR[DBG$L_DISP_MAXLINE], .CENTER_LINE));


    ! Unless the user is typing a range of line numbers (as opposed to a single
    ! line) and unless marking is disabled because we are simply scrolling,
    ! mark the central line as the line to be marked with a "->" in the display.
    !
    IF (.OLD_LOW EQL .OLD_HIGH) AND (NOT .MARKLINE_DISABLE_FLAG)
    THEN
	DISPTR[DBG$L_DISP_MARKLINE] = .CENTER_LINE;

    MARKLINE_DISABLE_FLAG = FALSE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_SOURCE_END: NOVALUE =
!
! FUNCTION
!	This routine is called at the end of a source line output operation
!	to a screen display.  It is called from DBG$SRC_TYPE_LNUM_SOURCE if
!	source lines are being directed to a screen display.  The primary
!	purpose of this routine is to determine where the screen window of
!	the source output display should be positioned within the display
!	text.  This computation, plus the computation of a scrolling count
!	for the display, is accomplished by doing some bookkeeping based on
!	a number of OWN variables set up in routines DBG$SCR_SOURCE_BEGIN,
!	DBG$SCR_SCROLL_SOURCE_DOWN, and DBG$SCR_SCROLL_SOURCE_UP.
!
!	The fundamental idea behind the algorithm is that SOURCE_BEGIN has
!	marked the top and bottom lines of the previous display contents
!	as "reference points" with known source file File IDs and record
!	numbers.  SOURCE_END then searches the new display contents for a
!	line with the same File ID and record number as one of these two
!	reference points.  If such a line is found, the corresponding
!	scrolling count (if DROW is fixed by the user's TYPE or EXAM/SOURCE
!	command) or the corresponding DROW value (if the scrolling count is
!	fixed by the user's SCROLL command) can be computed for the display.
!	The whole purpose of all these computations is thus to permit proper
!	vertical scrolling of source displays on the terminal screen.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Display Line Entry
	DROW,				! Display row location of window top
	NEW_TOP_OFFSET,			! Offset from top of display to the
					!      source reference line
	REF_FLAG,			! Flag set if a reference line is found
	SCROLL_DOWN;			! Flag set if we should scroll down



    ! Set the next line number (as used by the parameter-less TYPE and SEARCH
    ! commands) to be the line after the center line for the current source
    ! display.
    !
    DISPTR = .DBG$GL_SCREEN_SOURCE;
    DBG$SRC_NEXT_LNUM = .DISPTR[DBG$L_DISP_CENTER] + 1;


    ! Search the new list of Display Line Entries to see if we can find the
    ! reference line that used to be at the top or the bottom of the previous
    ! display contents.  If we can, note whether this calls for scrolling up
    ! or down.
    !
    NEW_TOP_OFFSET = 0;
    REF_FLAG = FALSE;
    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
    WHILE .DLEPTR NEQ DISPTR[DBG$L_DISP_START_LINE_PTR] DO
	BEGIN
	IF (.DLEPTR[DBG$L_DLINE_RECNUM] EQL .TOP_REF_RECNUM) AND
	   (.DLEPTR[DBG$W_DLINE_FILEID] EQL .TOP_REF_FILEID)
	THEN
	    BEGIN
	    REF_FLAG = TRUE;
	    SCROLL_DOWN = FALSE;
	    EXITLOOP;
	    END;

	IF (.DLEPTR[DBG$L_DLINE_RECNUM] EQL .BOT_REF_RECNUM) AND
	   (.DLEPTR[DBG$W_DLINE_FILEID] EQL .BOT_REF_FILEID)
	THEN
	    BEGIN
	    REF_FLAG = TRUE;
	    SCROLL_DOWN = TRUE;
	    EXITLOOP;
	    END;

	NEW_TOP_OFFSET = .NEW_TOP_OFFSET + 1;
	DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
	END;


    ! If we did not find either reference line, we invalidate the scrolling
    ! count.
    !
    IF NOT .REF_FLAG THEN INVSCR_FLAG = TRUE;


    ! If we found a reference line and we are scrolling by a fixed amount
    ! specified by the user on a SCROLL/DOWN or SCROLL/UP command, we compute
    ! the new DROW location.  Here we use SCROLL_AMOUNT as set in routine
    ! DBG$SCR_SCROLL_SOURCE_DOWN or DBG$SCR_SCROLL_SOURCE_UP to compute DROW.
    ! DROW is the adjusted if it hits the top or bottom of the source display.
    !
    DROW = .DISPTR[DBG$W_DISP_DROW];
    IF .FIXED_SCROLL_AMOUNT AND .REF_FLAG
    THEN
	BEGIN


	! If we are scrolling down and the scrolling amount is fixed by the
	! user's SCROLL/DOWN command, we compute the resulting DROW value here.
	!
	IF .SCROLL_DOWN
	THEN
	    DROW = .NEW_TOP_OFFSET + (.SCROLL_AMOUNT - .BOT_OFFSET) + 1


	! If we are scrolling up and the scrolling amount is fixed by the
	! user's SCROLL/UP command, we compute the resulting DROW value here.
	!
	ELSE
	    DROW = .NEW_TOP_OFFSET + .SCROLL_AMOUNT + .TOP_OFFSET + 1;

	END				! End of fixed-scrolling-amount case


    ! If we found a reference line but the scrolling amount is not fixed, then
    ! the center line of the window was specified by the user on a TYPE or
    ! EXAMINE/SOURCE command.  Here we compute the corresponding scrolling
    ! amount for the window.  DROW has already been set in DBG$SCR_SOURCE_LINE
    ! in this case.
    !
    ELSE IF .REF_FLAG
    THEN
	BEGIN


	! If we are scrolling down and the center line of the window is fixed
	! by the source line number specified on the TYPE or EXAM/SOURCE com-
	! mand, we compute the resulting scrolling amount here.
	!
	IF .SCROLL_DOWN
	THEN
	    SCROLL_AMOUNT = .BOT_OFFSET + .DROW - 1 - .NEW_TOP_OFFSET


	! If we are scrolling up and the center line of the window is fixed by
	! the source line number specified on the TYPE or EXAM/SOURCE command,
	! we compute the resulting scrolling amount here.
	!
	ELSE
	    SCROLL_AMOUNT = -(.NEW_TOP_OFFSET + .TOP_OFFSET - .DROW+ 1);

	END				! End of fixed DROW case


    ! If no reference line was found but we are scrolling to the bottom of the
    ! display, simply set DROW to point to the last line of the display.  (This
    ! gets adjusted for the window size in the code immediately below.)
    !
    ELSE IF .FIXED_SCROLL_AMOUNT AND .SCROLL_TO_BOTTOM
    THEN
	DROW = .DISPTR[DBG$W_DISP_LINECNT];


    ! Then adjust the DROW value and the scrolling amount if we are below
    ! the bottom of the source file being scrolled.
    !
    IF .DROW - 1 GTR .DISPTR[DBG$W_DISP_LINECNT] - .DISPTR[DBG$W_DISP_RLEN]
    THEN
	BEGIN
	SCROLL_AMOUNT = .SCROLL_AMOUNT + .DISPTR[DBG$W_DISP_LINECNT]
					- .DISPTR[DBG$W_DISP_RLEN] - .DROW + 1;
	DROW = .DISPTR[DBG$W_DISP_LINECNT] - .DISPTR[DBG$W_DISP_RLEN] + 1;
	END;


    ! Next adjust the DROW value and the scrolling amount if we are above
    ! the top of the source file being scrolled.  DROW could be zero or
    ! negative due to either of the above DROW computations; here we make
    ! sure it does not get smaller that 1.
    !
    IF .DROW LSS 1
    THEN
	BEGIN
	SCROLL_AMOUNT = .SCROLL_AMOUNT - .DROW + 1;
	DROW = 1;
	END;


    ! Set the final DROW value into the Screen Display Entry.
    !
    DISPTR[DBG$W_DISP_DROW] = .DROW;


    ! Given the new DROW (display row) value, set up the display's window
    ! start pointer.
    !
    DLEPTR = DISPTR[DBG$L_DISP_START_LINE_PTR];
    INCR I FROM 1 TO .DISPTR[DBG$W_DISP_DROW] DO
	DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];

    DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;


    ! Compute the final scrolling count, mark its validity, and return.
    !
    DISPTR[DBG$W_DISP_SCROLL] = .SAVED_SCROLL + .SCROLL_AMOUNT;
    DISPTR[DBG$V_DISP_INVSCR] = .INVSCR_FLAG;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_SOURCE_LINE(LINENUM, FILEID, RECNUM,
						BUFLEN, BUFPTR): NOVALUE =
!
! FUNCTION
!	This routine inserts a source line into a SOURCE screen display.
!	It accepts the line number, source file location, and text string
!	of the source line as input and it inserts that text and other
!	information into the current source display as specified by the
!	global pointer DBG$GL_SCREEN_SOURCE.
!
! INPUTS
!	LINENUM	- The line number of the passed-in source line.  This is the
!		  line number which will be displayed to the left of the line
!		  on the screen display.
!
!	FILEID	- The source file File ID as understood by module DBGSOURCE.
!		  FILEID and RECNUM serve to uniquely identify this source
!		  line.
!
!	RECNUM	- The record number of the source line within the FILEID
!		  source file.  Again, the purpose of FILEID and RECNUM is
!		  to uniquely identify this source line.
!
!	BUFLEN	- The length of the source line text in characters.
!
!	BUFPTR	- The address of the source line text.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	BUFPTR: REF VECTOR[,BYTE];	! Pointer to source line text

    LOCAL
	BLINK: REF DBG$DLINE_ENTRY,	! Pointer to previous Display Line Entry
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to SOURCE Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Screen Display Line Entry
	FLINK: REF DBG$DLINE_ENTRY,	! Pointer to next Display Line Entry
	TEMPBUF: VECTOR[256, BYTE],	! Temporary buffer for de-tabbed text
	TLEN,				! Length of de-tabbed text
	TEXT_PTR: REF VECTOR[,BYTE];	! Pointer to text in Display Line Entry



    ! Expand all tabs to blanks.  This is necessary in order to make subsequent
    ! length computations and left scrolling work correctly.  The expanded text
    ! is copied into the TEMPBUF temporary buffer.
    !
    TLEN = 0;
    INCR I FROM 0 TO .BUFLEN - 1 DO
	BEGIN


	! If the current character is a tab character, expand it to blanks.
	!
	IF .BUFPTR[.I] EQL TAB_CHAR
	THEN
	    BEGIN
	    INCR J FROM 1 TO 8 - (.TLEN MOD 8) DO
		BEGIN
		TEMPBUF[.TLEN] = ' ';
		TLEN = .TLEN + 1;
		IF .TLEN GEQ 255 THEN EXITLOOP;
		END;

	    END


	! If the current character is not a tab, just copy it as is.
	!
	ELSE
	    BEGIN
	    TEMPBUF[.TLEN] = .BUFPTR[.I];
	    TLEN = .TLEN + 1;
	    END;

	IF .TLEN GEQ 255 THEN EXITLOOP;
	END;


    ! Allocate and build a Screen Display Line Entry to hold the contents of
    ! the present source line.
    !
    DISPTR = .DBG$GL_SCREEN_SOURCE;
    DLEPTR = DBG$GET_MEMORY(DBG$K_DLINE_ENTSIZE2 + .TLEN/%UPVAL + 1);
    DLEPTR[DBG$B_DLINE_REND] = .DISPTR[DBG$B_DISP_REND];
    DLEPTR[DBG$V_DLINE_SOURCEFLG] = TRUE;
    DLEPTR[DBG$W_DLINE_FILEID] = .FILEID;
    DLEPTR[DBG$L_DLINE_RECNUM] = .RECNUM;
    DLEPTR[DBG$L_DLINE_LINUM] = .LINENUM;


    ! Copy over the text of the source line to the Display Line Entry.
    !
    TEXT_PTR = DLEPTR[DBG$A_DLINE_TEXT2];
    TEXT_PTR[0] = .TLEN;
    CH$MOVE(.TLEN, TEMPBUF, TEXT_PTR[1]);


    ! Link this Display Line Entry onto the tail of the Display Line Entry list
    ! for this display.
    !
    FLINK = DISPTR[DBG$L_DISP_START_LINE_PTR];
    BLINK = .FLINK[DBG$L_DLINE_BLINK];
    DLEPTR[DBG$L_DLINE_FLINK] = .FLINK;
    DLEPTR[DBG$L_DLINE_BLINK] = .BLINK;
    FLINK[DBG$L_DLINE_BLINK] = .DLEPTR;
    BLINK[DBG$L_DLINE_FLINK] = .DLEPTR;
    DISPTR[DBG$W_DISP_LINECNT] = .DISPTR[DBG$W_DISP_LINECNT] + 1;
    IF .DISPTR[DBG$W_DISP_LINECNT] EQL 1
    THEN
	DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;


    ! Finally adjust the DROW parameter and window pointer so that the central
    ! line of the source display in fact winds up in the center of the center
    ! of the display's screen window.
    !
    IF .LINENUM EQL .DISPTR[DBG$L_DISP_CENTER]
    THEN
	BEGIN
	DISPTR[DBG$W_DISP_DROW] = MAX(1, .DISPTR[DBG$W_DISP_LINECNT] -
					(.DISPTR[DBG$W_DISP_RLEN] - 1)/2);
	INCR I FROM 1 TO
		.DISPTR[DBG$W_DISP_LINECNT] - .DISPTR[DBG$W_DISP_DROW] DO
	    DLEPTR = .DLEPTR[DBG$L_DLINE_BLINK];

	DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;
	END;


    ! The source line has been output to the display.  Now return.
    !
    RETURN;

    END;

ROUTINE DBG$SCR_UPDATE_PASTEBOARD: NOVALUE =
!
! FUNCTION
!	This routine updates the pasteboard to take into account the changes
!	made to the constituent displays since the last time the pasteboard
!	was updated.  It goes through the list of pasted displays to determine
!	which lines of which displays should be visible on the pasteboard, and
!	it updates the pasteboard line table accordingly.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to current Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Display Line Entry
	IROW,				! Temporary row index into pasteboard
	NEXTDLE,			! Pointer to next Display Line Entry
	RBEG,				! Beginning row location on pasteboard
					!      of the current display
	RLEN,				! Row length (height) of current display
	SCROLL_AMOUNT,			! Scrolling amount for current display
	TEMPTR: REF DBG$DISP_ENTRY;	! Temporary Display Entry pointer



    ! Initialize the pasteboard to contain nothing but user scrolling region.
    !
    INCR I FROM 0 TO DBG$K_PASTE_SIZE - 1 DO
	PASTEBOARD[.I, DBG$B_PASTE_KIND] = DBG$K_PASTE_NULL;


    ! Loop through the Screen Display list.  For each display on the list,
    ! fill the display lines of that display into the appropriate window on
    ! the pasteboard.
    !
    DISPTR = .DBG$SCR_DISPLAY_LIST[0];
    WHILE .DISPTR NEQ DBG$SCR_DISPLAY_LIST DO
	BEGIN


	! Unless the current display is marked as removed from the pasteboard,
	! we fill it into its window on the pasteboard.
	!
	IF NOT .DISPTR[DBG$V_DISP_REMOVE]
	THEN
	    BEGIN


	    ! Initialize the part of the pasteboard covered by this display to
	    ! contain blank lines.  This allows the actual display text to con-
	    ! sist of less lines than there are in the corresponding window.
	    !
	    SCROLL_AMOUNT = .DISPTR[DBG$W_DISP_SCROLL];
	    IF .DISPTR[DBG$V_DISP_INVSCR] THEN SCROLL_AMOUNT = 0;
	    RBEG = .DISPTR[DBG$W_DISP_RBEG];
	    RLEN = .DISPTR[DBG$W_DISP_RLEN];
	    INCR I FROM .RBEG TO MIN(.RBEG + .RLEN, DBG$K_PASTE_SIZE) - 1 DO
		BEGIN
		PASTEBOARD[.I, DBG$B_PASTE_KIND] = DBG$K_PASTE_BLANK;
		PASTEBOARD[.I, DBG$B_PASTE_REND] = .DISPTR[DBG$B_DISP_REND];
		PASTEBOARD[.I, DBG$W_PASTE_SCROLL] = .SCROLL_AMOUNT;
		PASTEBOARD[.I, DBG$L_PASTE_DISPID] = .DISPTR;
		END;


	    ! Now copy the actual text lines (represented by pointers to
	    ! Display Line Entries) from the display into the pasteboard.
	    !
	    DLEPTR = .DISPTR[DBG$L_DISP_WINDOW_PTR];
	    INCR I FROM .RBEG TO MIN(.RBEG + .RLEN, DBG$K_PASTE_SIZE) - 1 DO
		BEGIN
		IF .DLEPTR EQL 0 THEN EXITLOOP;
		IF .DLEPTR EQL DISPTR[DBG$L_DISP_START_LINE_PTR] THEN EXITLOOP;
		PASTEBOARD[.I, DBG$B_PASTE_KIND] = DBG$K_PASTE_TEXT;
		PASTEBOARD[.I, DBG$B_PASTE_REND] = .DLEPTR[DBG$B_DLINE_REND];
		PASTEBOARD[.I, DBG$W_PASTE_SCROLL] = .SCROLL_AMOUNT;
		PASTEBOARD[.I, DBG$L_PASTE_DISPID] = .DISPTR;
		PASTEBOARD[.I, DBG$L_PASTE_DLINE] = .DLEPTR;
		DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
		END;


	    ! If this display has Error Line Entries, replace the first part
	    ! of the display with the error lines.
	    !
	    DLEPTR = .DISPTR[DBG$L_DISP_ERROR_PTR];
	    INCR I FROM .RBEG TO MIN(.RBEG + .RLEN, DBG$K_PASTE_SIZE) - 1 DO
		BEGIN
		IF .DLEPTR EQL 0 THEN EXITLOOP;
		PASTEBOARD[.I, DBG$B_PASTE_KIND] = DBG$K_PASTE_TEXT;
		PASTEBOARD[.I, DBG$B_PASTE_REND] = .DLEPTR[DBG$B_DLINE_REND];
		PASTEBOARD[.I, DBG$W_PASTE_SCROLL] = .SCROLL_AMOUNT;
		PASTEBOARD[.I, DBG$L_PASTE_DISPID] = .DISPTR;
		PASTEBOARD[.I, DBG$L_PASTE_DLINE] = .DLEPTR;
		DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
		END;


	    ! If this display still has line entries on the old-text list,
	    ! release them all.  This only occurs for automatically updated
	    ! displays when changes are marked and when the display's new
	    ! text has less lines than the old text.  Also clear the flag
	    ! that marks this display as a new display.
	    !
	    DISPTR[DBG$V_DISP_NEWDISP] = FALSE;
	    DLEPTR = .DISPTR[DBG$L_DISP_OLDTXT_PTR];
	    DISPTR[DBG$L_DISP_OLDTXT_PTR] = 0;
	    WHILE .DLEPTR NEQ 0 DO
		BEGIN
		NEXTDLE = .DLEPTR[DBG$L_DLINE_FLINK];
		DBG$REL_MEMORY(.DLEPTR);
		DLEPTR = .NEXTDLE;
		END;


	    ! Fill in the top border for the display.  We use the display's
	    ! label line as the top border.
	    !
	    PASTEBOARD[.RBEG - 1, DBG$B_PASTE_KIND] = DBG$K_PASTE_LABEL;
	    PASTEBOARD[.RBEG - 1, DBG$B_PASTE_REND] = .DISPTR[DBG$B_DISP_REND];
	    PASTEBOARD[.RBEG - 1, DBG$L_PASTE_DISPID] = .DISPTR;


	    ! Fill in the bottom border of the display.  Unless this border
	    ! happens to overlay another display, we turn it into the normal
	    ! bottom-of-the-screen border.
	    !
	    IROW = MIN(.RBEG + .RLEN, DBG$K_PASTE_SIZE - 1);
	    IF (.PASTEBOARD[.IROW, DBG$B_PASTE_KIND] EQL DBG$K_PASTE_NULL) OR
	       (.PASTEBOARD[.IROW, DBG$B_PASTE_KIND] EQL DBG$K_PASTE_BORDER)
	    THEN
		BEGIN
		PASTEBOARD[.IROW, DBG$B_PASTE_KIND] = DBG$K_PASTE_BORDER;
		PASTEBOARD[.IROW, DBG$B_PASTE_REND] = .DISPTR[DBG$B_DISP_REND];
		PASTEBOARD[.IROW, DBG$L_PASTE_DISPID] = .DISPTR;
		END


	    ! But if this border happens to overlay another display, we turn
	    ! this line into a label line for the overlayed display.
	    !
	    ELSE
		BEGIN
		PASTEBOARD[.IROW, DBG$B_PASTE_KIND] = DBG$K_PASTE_LABEL;
		TEMPTR = .PASTEBOARD[.IROW, DBG$L_PASTE_DISPID];
		PASTEBOARD[.IROW, DBG$B_PASTE_REND] = .TEMPTR[DBG$B_DISP_REND];
		END;

	    END;			! End of code for non-removed displays


	! Clear the scrolling count in the current Display Entry.  Then link
	! to the next display on the Screen Display List and loop.
	!
	DISPTR[DBG$W_DISP_SCROLL] = 0;
	DISPTR[DBG$V_DISP_INVSCR] = FALSE;
	DISPTR = .DISPTR[DBG$L_DISP_FLINK];

	END;				! End of loop over Screen Display List


    ! The pasteboard is updated.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$SCR_WRITE_ERROR(RABPTR) =
!
! FUNCTION
!	This routine writes an error message line to a screen display.  It is
!	called from routine DBG$OUT_MESSAGE when an error has been signalled
!	and the corresponding message is about to be output.  If the global
!	variable DBG$GL_SCREEN_ERROR is non-zero, this routine is called in-
!	stead of the $PUT system service to output the message.  It does so
!	by attaching the error message text to the Screen Display Entry that
!	DBG$GL_SCREEN_ERROR points to.
!
!	Error messages are only directed to screen displays when the contents
!	of automatically generated displays are generated by invoking the DEBUG
!	command lists associated with such displays.  This allows the messages
!	associated with such displays to be displayed in the display's them-
!	selves, rather than being output to the input window at the bottom of
!	the screen.  Such messages would be quite confusing at the bottom of
!	the screen since they are not associated with the current DEBUG command
!	entered from the terminal.
!
! INPUTS
!	RABPTR	- A pointer to an RMS Record Access Block (RAB) which describes
!		  the line of error message text to be written to the currently
!		  active error display.
!
! OUTPUTS
!	This routine returns TRUE as its value if the error message was success-
!		  fully written to the current output display.  If the write
!		  did not succeed, the routine returns FALSE to indicate that
!		  the error message should be forced out to the user's terminal
!		  using the $PUT system service.
!

    BEGIN

    MAP
	RABPTR: REF BLOCK[,BYTE];	! Pointer to Record Access Block

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to the Display Line Entry for
					!      the new output line
	DLINE_TEXT: REF VECTOR[,BYTE],	! Pointer to text buffer in Line Entry
	MSGEND,				! Pointer to first byte after message
	MSGLEN,				! The length of the message text
	MSGPTR: REF VECTOR[,BYTE],	! The address of the message text
	NXTMSGPTR,			! Pointer to rest of message text--this
					!      is advanced as message is broken
					!      into separate lines
	PREVPTR: REF DBG$DLINE_ENTRY,	! Pointer to previous Display Line
					!      Entry on error message list
	TEMPBUF: VECTOR[256, BYTE],	! Temporary buffer for de-tabbed text
	TLEN;				! The length of the de-tabbed text

    ENABLE
	DBG$FINAL_HANDL;		! Enable the Final Handler during the
					!      processing of this error



    ! Pick up the pointer to the selected Screen Display Entry to receive the
    ! error message.  Then clear DBG$GL_SCREEN_ERROR so that any error in the
    ! processing of this error does not cause this routine to be re-entered.
    ! (Any such secondary error will thus be output using $PUT.)
    !
    DISPTR = .DBG$GL_SCREEN_ERROR;
    DBG$GL_SCREEN_ERROR = 0;


    ! Extract the message text's address and length from the RAB.
    !
    NXTMSGPTR = .RABPTR[RAB$L_RBF];
    MSGLEN = .RABPTR[RAB$W_RSZ];
    MSGEND = .NXTMSGPTR + .MSGLEN;


    ! Set up a loop through the lines of the error message.  This loop loops
    ! through the individual lines, separated by carriage-return/line-feeds,
    ! within the message text.  Each such line must be output separately to
    ! the appropriate screen display in order for the lines to be positioned
    ! correctly on the screen.
    !
    WHILE .NXTMSGPTR LSS .MSGEND DO
	BEGIN


	! Scan the message text for any carriage returns and line feeds.  When
	! a carriage return or carriage-return/line-feed is found, we break the
	! message text into two lines so that we can output the first line and
	! remember where the rest of the message starts.  If no carriage-return
	! is found, we output the entire remaining message as one line.
	!
	MSGPTR = .NXTMSGPTR;
	MSGLEN = .MSGEND - .MSGPTR;
	NXTMSGPTR = .MSGEND;
	INCR I FROM 0 TO .MSGLEN - 1 DO
	    BEGIN
	    IF .MSGPTR[.I] EQL DBG$K_CAR_RETURN
	    THEN
		BEGIN
		MSGLEN = .I;
		NXTMSGPTR = MSGPTR[.I + 1];
		IF .MSGPTR[.I + 1] EQL DBG$K_LINE_FEED
		THEN
		    NXTMSGPTR = MSGPTR[.I + 2];

		EXITLOOP;
		END;

	    END;


	! We now have one line of message text, given by MSGPTR and MSGLEN.
	! This is the message to be output this time through the WHILE loop.
	!
	! If the error message is being directed to a normal display which
	! is automatically generated with a DO command list, simply call
	! WRITE_LINE to output the error message to the desired display.
	!
	IF .DISPTR[DBG$B_DISP_KIND] EQL DBG$K_DISP_DO
	THEN
	    DBG$SCR_WRITE_LINE(.MSGLEN, .MSGPTR, .DISPTR)


	! If we do not have a SOURCE display at this point, we simply return
	! FALSE to cause the error message to be output the normal way (with
	! $PUT).
	!
	ELSE IF (.DISPTR[DBG$B_DISP_KIND] NEQ DBG$K_DISP_SOURCE) OR
		(.DISPTR[DBG$L_DISP_CMDLIST] EQL 0)
	THEN
	    BEGIN
	    DBG$GL_SCREEN_ERROR = .DISPTR;
	    RETURN FALSE;
	    END


	! The error message is associated with a source display.  Massage the
	! text by expanding all tabs to blanks.  This is necessary to make
	! subsequent length computations and scrolling to the right work
	! correctly.  The expanded text is copied into the TEMPBUF temporary
	! buffer.
	!
	ELSE
	    BEGIN
	    TLEN = 0;
	    INCR I FROM 0 TO .MSGLEN - 1 DO
		BEGIN


		! If the current character is a tab character, expand it to
		! blanks.
		!
		IF .MSGPTR[.I] EQL TAB_CHAR
		THEN
		    BEGIN
		    INCR J FROM 1 TO 8 - (.TLEN MOD 8) DO
			BEGIN
			TEMPBUF[.TLEN] = ' ';
			TLEN = .TLEN + 1;
			IF .TLEN GEQ 255 THEN EXITLOOP;
			END;

		    END


		! If the current character is not a tab, just copy it as is.
		!
		ELSE
		    BEGIN
		    TEMPBUF[.TLEN] = .MSGPTR[.I];
		    TLEN = .TLEN + 1;
		    END;

		IF .TLEN GEQ 255 THEN EXITLOOP;
		END;


	    ! Allocate a Screen Display Line Entry for the new error message.
	    ! Then fill in the fields of the Display Line Entry, including the
	    ! new text, and link that entry into the source display's Error
	    ! Line Entry List.  Note that we highlight the error message with
	    ! reverse video and bolding.
	    !
	    DLEPTR = DBG$GET_MEMORY(DBG$K_DLINE_ENTSIZE + .TLEN/%UPVAL + 1);
	    DLEPTR[DBG$B_DLINE_REND] = .DISPTR[DBG$B_DISP_REND] XOR
				(DBG$M_DISP_REND_RV OR DBG$M_DISP_REND_BLD);
	    DLEPTR[DBG$B_DLINE_LENGTH] = .TLEN;
	    DLINE_TEXT = DLEPTR[DBG$A_DLINE_TEXT];
	    DLINE_TEXT[0] = .TLEN;
	    CH$MOVE(.TLEN, TEMPBUF, DLINE_TEXT[1]);
	    PREVPTR = DISPTR[DBG$L_DISP_ERROR_PTR];
	    WHILE .PREVPTR[DBG$L_DLINE_FLINK] NEQ 0 DO
		PREVPTR = .PREVPTR[DBG$L_DLINE_FLINK];

	    PREVPTR[DBG$L_DLINE_FLINK] = .DLEPTR;

	    END;			! End of source display ELSE clause

	END;				! End of WHILE loop over error lines


    ! The error message has been successfully written to the error display.
    ! Now restore DBG$GL_SCREEN_ERROR and return.
    !
    DBG$GL_SCREEN_ERROR = .DISPTR;
    RETURN TRUE;

    END;

GLOBAL ROUTINE DBG$SCR_WRITE_LINE(LENGTH, TEXTPTR, DISPTR): NOVALUE =
!
! FUNCTION
!	This routine writes a line of DEBUG output to the current output
!	display or to a specified screen display.  A new Display Line
!	Entry is allocated for the new text line and is then appended to
!	the list of display lines assocated with this display.
!
! INPUTS
!	LENGTH	- The length of the text line, i.e. the number of bytes to be
!		  retrieved from the TEXTPTR location.
!
!	TEXTPTR	- A pointer to the first byte of the ASCII text which con-
!		  stitutes the line to be written to the output display.
!
!	DISPTR	- The Display ID (Display Entry pointer) of the display to
!		  which this line of output is to be written.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	TEXTPTR: REF VECTOR[,BYTE],	! Pointer to ASCII text of output line
	DISPTR: REF DBG$DISP_ENTRY;	! Pointer to output Screen Display Entry

    LOCAL
	BLINK: REF DBG$DLINE_ENTRY,	! Pointer to previous Display Line Entry
	CHANGE_FLAG,			! Flag set if line contents changed
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to the Display Line Entry for
					!      the new output line
	DLINE_TEXT: REF VECTOR[,BYTE],	! Pointer to text buffer in Line Entry
	FLINK: REF DBG$DLINE_ENTRY,	! Pointer to next Display Line Entry
	NEW_DROW,			! New DROW value if scrolling to bottom
	OLD_DROW,			! Old DROW value if scrolling to bottom
	OLDPTR: REF DBG$DLINE_ENTRY,	! Pointer to Display Line Entry for old
					!      text--used to mark changes
	OLDTXT: REF VECTOR[,BYTE],	! Pointer to line's old text buffer
	TEMPBUF: VECTOR[256, BYTE],	! Temporary buffer for de-tabbed text
	TEMP_PTR: REF DBG$DLINE_ENTRY,	! Temporary pointer to Display Line Entry
	TLEN,				! The length of the de-tabbed text
	WSPTR: REF DBG$DLINE_ENTRY;	! Pointer to window start line (points
					!      to a Display Line Entry)



    ! Check that the input parameters are valid.
    !
    IF .LENGTH LSS 0 THEN $DBG_ERROR('DBGSCREEN\WRITE_LINE 10');
    IF .DISPTR EQL 0 THEN $DBG_ERROR('DBGSCREEN\WRITE_LINE 20');


    ! Expand all tabs to blanks.  This is necessary in order to make subsequent
    ! length computations and scrolling to the right work correctly.  The
    ! expanded text is copied into the TEMPBUF temporary buffer.
    !
    TLEN = 0;
    INCR I FROM 0 TO .LENGTH - 1 DO
	BEGIN


	! If the current character is a tab character, expand it to blanks.
	!
	IF .TEXTPTR[.I] EQL TAB_CHAR
	THEN
	    BEGIN
	    INCR J FROM 1 TO 8 - (.TLEN MOD 8) DO
		BEGIN
		TEMPBUF[.TLEN] = ' ';
		TLEN = .TLEN + 1;
		IF .TLEN GEQ 255 THEN EXITLOOP;
		END;

	    END


	! If the current character is not a tab, just copy it as is.
	!
	ELSE
	    BEGIN
	    TEMPBUF[.TLEN] = .TEXTPTR[.I];
	    TLEN = .TLEN + 1;
	    END;

	IF .TLEN GEQ 255 THEN EXITLOOP;
	END;


    ! If the display is already full, meaning that it has the maximum number
    ! of text lines it is allowed to have, we remove the first line (the oldest
    ! line) of the display.  Note, however, that we reuse that same Display
    ! Line Entry if it is large enough to hold the new text line.
    !
    DLEPTR = 0;
    IF .DISPTR[DBG$W_DISP_LINECNT] EQL .DISPTR[DBG$W_DISP_MAX_LINECNT]
    THEN
	BEGIN


	! Unlink this entry from the doubly linked Display Line Entry list
	! associated with the DISPTR Screen Display Entry.
	!
	DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
	FLINK = .DLEPTR[DBG$L_DLINE_FLINK];
	BLINK = .DLEPTR[DBG$L_DLINE_BLINK];
	FLINK[DBG$L_DLINE_BLINK] = .BLINK;
	BLINK[DBG$L_DLINE_FLINK] = .FLINK;
	DISPTR[DBG$W_DISP_LINECNT] = .DISPTR[DBG$W_DISP_LINECNT] - 1;


	! Adjust the window start pointer and DROW if necessary to account
	! for the fact that the first line of the display is being removed.
	!
	IF .DISPTR[DBG$W_DISP_DROW] GTR 1
	THEN
	    DISPTR[DBG$W_DISP_DROW] = .DISPTR[DBG$W_DISP_DROW] - 1

	ELSE
	    BEGIN
	    IF .DISPTR[DBG$W_DISP_LINECNT] EQL 0 THEN FLINK = 0;
	    DISPTR[DBG$L_DISP_WINDOW_PTR] = .FLINK;
	    DISPTR[DBG$W_DISP_SCROLL] = .DISPTR[DBG$W_DISP_SCROLL] + 1;
	    END;


	! If the discarded Display Line Entry is too small to hold the new
	! text line, release it to the memory pool and clear DLEPTR to zero.
	! However, if it is big enough, we keep it and DLEPTR points to it.
	!
	IF .TLEN GTR .DLEPTR[DBG$B_DLINE_LENGTH]
	THEN
	    BEGIN
	    DBG$REL_MEMORY(.DLEPTR);
	    DLEPTR = 0;
	    END;

	END;


    ! Allocate a Screen Display Line Entry for the new text line unless we
    ! found that we can reuse the line entry for the discarded oldest line.
    !
    IF .DLEPTR EQL 0
    THEN
	BEGIN
	DLEPTR = DBG$GET_MEMORY(DBG$K_DLINE_ENTSIZE + .TLEN/%UPVAL + 1);
	DLEPTR[DBG$B_DLINE_LENGTH] = .TLEN;
	END;


    ! Fill in the fields of the Display Line Entry, including the new text, and
    ! then link that entry into the display's line entry list.
    !
    DLEPTR[DBG$B_DLINE_REND] = .DISPTR[DBG$B_DISP_REND];
    DLINE_TEXT = DLEPTR[DBG$A_DLINE_TEXT];
    DLINE_TEXT[0] = .TLEN;
    CH$MOVE(.TLEN, TEMPBUF, DLINE_TEXT[1]);
    FLINK = DISPTR[DBG$L_DISP_START_LINE_PTR];
    BLINK = .DISPTR[DBG$L_DISP_END_LINE_PTR];
    DLEPTR[DBG$L_DLINE_FLINK] = .FLINK;
    DLEPTR[DBG$L_DLINE_BLINK] = .BLINK;
    FLINK[DBG$L_DLINE_BLINK] = .DLEPTR;
    BLINK[DBG$L_DLINE_FLINK] = .DLEPTR;
    DISPTR[DBG$W_DISP_LINECNT] = .DISPTR[DBG$W_DISP_LINECNT] + 1;
    IF .DISPTR[DBG$W_DISP_LINECNT] EQL 1
    THEN
	DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;


    ! If we are supposed to mark changed lines for this display, compare the
    ! new text line to the first line on the old-text list.  If they differ,
    ! we highlight the new text line with reverse video and bolding.
    !
    IF .DISPTR[DBG$V_DISP_MARKFLG] AND (NOT .DISPTR[DBG$V_DISP_NEWDISP])
    THEN
	BEGIN
	CHANGE_FLAG = FALSE;
	IF .DISPTR[DBG$L_DISP_OLDTXT_PTR] EQL 0
	THEN
	    CHANGE_FLAG = TRUE

	ELSE
	    BEGIN
	    OLDPTR = .DISPTR[DBG$L_DISP_OLDTXT_PTR];
	    DISPTR[DBG$L_DISP_OLDTXT_PTR] = .OLDPTR[DBG$L_DLINE_FLINK];
	    OLDTXT = OLDPTR[DBG$A_DLINE_TEXT];
	    CHANGE_FLAG = CH$NEQ(.TLEN, TEMPBUF, .OLDTXT[0], OLDTXT[1], 0);
	    DBG$REL_MEMORY(.OLDPTR);
	    END;

	IF .CHANGE_FLAG
	THEN
	    DLEPTR[DBG$B_DLINE_REND] = .DLEPTR[DBG$B_DLINE_REND] XOR
				(DBG$M_DISP_REND_RV OR DBG$M_DISP_REND_BLD);
	END;


    ! If the screen window is not now positioned at the bottom of the display
    ! text, force it to the bottom of the text.
    !
    NEW_DROW = .DISPTR[DBG$W_DISP_LINECNT] - .DISPTR[DBG$W_DISP_RLEN] + 1;
    IF .DISPTR[DBG$W_DISP_DROW] LSS .NEW_DROW
    THEN
	BEGIN
	OLD_DROW = .DISPTR[DBG$W_DISP_DROW];
	DISPTR[DBG$W_DISP_DROW] = .NEW_DROW;
	WSPTR = .DISPTR[DBG$L_DISP_END_LINE_PTR];
	INCR I FROM 2 TO .DISPTR[DBG$W_DISP_RLEN] DO
	    WSPTR = .WSPTR[DBG$L_DLINE_BLINK];

	DISPTR[DBG$L_DISP_WINDOW_PTR] = .WSPTR;
	DISPTR[DBG$W_DISP_SCROLL] =
			.DISPTR[DBG$W_DISP_SCROLL] + .NEW_DROW - .OLD_DROW;
	END;


    ! The new text line has been written to the desired display.  Now return.
    !
    RETURN;

    END;

ROUTINE FORMAT_SOURCE_LINE(DISPTR, DLEPTR, TEXTPTR, TEXTCNT, BUFFER): NOVALUE =
!
! FUNCTION
!	This routine formats a source line for output as part of a Screen
!	Display.  Source lines are formatted differently than other lines
!	for two reasons: first, the Display Line Entry has a different format
!	for source lines, and second, scrolling to the right or left is done
!	in such a way that the line number cannot be scrolled off the left
!	end of the display.  In addition, the "mark line" of a source display
!	is marked with a small pointer "->", which does not happen with non-
!	source lines.
!
! INPUTS
!	DISPTR	- A pointer to the Screen Display Entry for the display that
!		  contains the line being formatted.
!
!	DLEPTR	- A pointer to the Display Line Entry for the source line
!		  being formatted.
!
!	TEXTPTR	- The address of a longword location to receive a pointer to
!		  formatted source line.
!
!	TEXTCNT	- The address of a longword location to receive the length
!		  of the formatted source line.
!
!	BUFFER	- A pointer to a 132-character buffer to be used for formatting
!		  the source line.
!
! OUTPUTS
!	TEXTPTR	- The address of the formatted source line is returned to the
!		  TEXTPTR location.
!
!	TEXTCNT	- The length of the formatted source line is returned to the
!		  TEXTCNT location.
!

    BEGIN

    MAP
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to source Display Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Display Line Entry
	TEXTPTR: REF VECTOR[1,LONG],	! Pointer to returned text pointer
	TEXTCNT: REF VECTOR[1,LONG],	! Pointer to returned text length
	BUFFER: REF VECTOR[,BYTE];	! Pointer to editing buffer

    LOCAL
	LINENUM,			! Line number of this source line
	TLEN,				! Length of edited source line
	TPTR: REF VECTOR[,BYTE];	! Pointer to edited source line



    ! Edit the source line number of this source line into the editing buffer.
    ! The number is truncated to six digits.  Note that we include a "->" in
    ! front of the line number if this is the "marked" line of the display.
    !
    CH$FILL(' ', 8, .BUFFER);
    BUFFER[6] = ':';
    IF .DLEPTR[DBG$L_DLINE_LINUM] GTR 0
    THEN
	BEGIN
	LINENUM = .DLEPTR[DBG$L_DLINE_LINUM];
	DECR I FROM 5 TO 0 DO
	    BEGIN
	    BUFFER[.I] = (.LINENUM MOD 10) + '0';
	    LINENUM = .LINENUM/10;
	    IF .LINENUM EQL 0 THEN EXITLOOP;
	    END;

	IF .DLEPTR[DBG$L_DLINE_LINUM] EQL .DISPTR[DBG$L_DISP_MARKLINE]
	THEN
	    BEGIN
	    BUFFER[0] = '-';
	    BUFFER[1] = '>';
	    END;

	END;


    ! Copy the actual text of the source line into BUFFER.  The right scrolling
    ! specified in DCOL is performed at this time.
    !
    TPTR = DLEPTR[DBG$A_DLINE_TEXT2];
    TLEN = MIN(.DBG$SRC_TERM_WIDTH - 8,
			MAX(0, .TPTR[0] - .DISPTR[DBG$W_DISP_DCOL] + 1));
    CH$MOVE(.TLEN, TPTR[.DISPTR[DBG$W_DISP_DCOL]], BUFFER[8]);


    ! Finally return the length and location of the edited source line and
    ! return control to the caller.
    !
    TEXTCNT[0] = .TLEN + 8;
    TEXTPTR[0] = .BUFFER;
    RETURN;

    END;

ROUTINE HANDLER_EXECUTE_SAVE(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the Condition Handler for the DBG$SCR_EXECUTE_SAVE_CMD
!	routine.  Its purpose is to release the Screen Display Entry and its
!	associated Display Line Entries in case the DEBUG Memory Pool runs out
!	of memory in the middle of building a new Display Entry while executing
!	a SAVE command.  After releasing all such memory (if any) in response
!	to the DBG$_NOFREE condition, this routine resignals the condition.
!	Any other condition is resignalled immediately.
!
! INPUTS
!	SIGARG	- The condition Signal Argument vector.
!
!	MECHARG	- The condition Mechanism Argument vector.
!
!	ENBLARG	- The condition Enable Argument vector.  This handler expects
!		  this vector to contain one element, ENBLARG[1], which points
!		  to the Screen Display Entry to be released in case the "no
!		  free storage" error occurred.
!
! OUTPUTS
!	This routine always returns SS$_RESIGNAL as its result.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG],	! Pointer to Signal Argument vector
	ENBLARG: REF VECTOR[,LONG];	! Pointer to Enable Argument vector

    LOCAL
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Display Entry to release
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to Display Line Entry
	NEXTDLE;			! Pointer to next Display Line Entry



    ! Unless this is the DBG$_NOFREE error condition, we resignal immediately.
    ! No other condition should occur, so we want to preserve the current state
    ! for debugging if something else did occur.  We also resignal immediately
    ! if there is no Screen Display Entry to release.
    !
    IF .SIGARG[1] NEQ DBG$_NOFREE THEN RETURN SS$_RESIGNAL;
    IF .ENBLARG[1] EQL 0 THEN RETURN SS$_RESIGNAL;


    ! There is a Screen Display Entry to release.  First loop to release all
    ! Display Line Entries attached to the Display Entry.
    !
    DISPTR = .ENBLARG[1];
    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
    WHILE .DLEPTR NEQ DISPTR[DBG$L_DISP_START_LINE_PTR] DO
	BEGIN
	NEXTDLE = .DLEPTR[DBG$L_DLINE_FLINK];
	DBG$REL_MEMORY(.DLEPTR);
	DLEPTR = .NEXTDLE;
	END;


    ! Then release the Screen Display Entry itself and resignal the condition.
    !
    DBG$REL_MEMORY(.DISPTR);
    RETURN SS$_RESIGNAL;

    END;

ROUTINE HANDLER_SCROLL_SOURCE(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the Condition Handler for the DBG$SCR_SCROLL_SOURCE_xx
!	routines.  Its purpose is to restore the value of DBG$GL_SCREEN_SOURCE
!	in case an error condition forces a premature exit from the current
!	source display scrolling operation.  The address of the value to be
!	restored is passed in as an Enable argument.
!
! INPUTS
!	SIGARG	- The condition Signal Argument vector.
!
!	MECHARG	- The condition Mechanism Argument vector.
!
!	ENBLARG	- The condition Enable Argument vector.  This handler expects
!		  this vector to contain one element, ENBLARG[1], which con-
!		  tains the the address of the location that contains the
!		  value to which DBG$GL_SCREEN_SOURCE should be restored.
!
! OUTPUTS
!	This routine always returns SS$_RESIGNAL as its result.
!

    BEGIN

    MAP
	ENBLARG: REF VECTOR[,LONG];	! Pointer to Enable Argument vector

    LOCAL
	PTR: REF VECTOR[1, LONG];	! Pointer to value to be restored



    ! Restore the value of DBG$GL_SCREEN_SOURCE and resignal the condition.
    !
    PTR = .ENBLARG[1];
    DBG$GL_SCREEN_SOURCE = .PTR[0];
    RETURN SS$_RESIGNAL;

    END;

ROUTINE PARSE_DISPLAY_NAME(INPUT_DESC, PERCENT_ALLOWED) =
!
! FUNCTION
!	This routine parses (scans and picks up) a screen display name.  It
!	is called during the parsing of all Screen Debugging commands which
!	have display names in their syntax.
!
! INPUTS
!	INPUT_DESC - A string descriptor to the input line being parsed.
!		  The descriptor is assumed to point to the start of the
!		  display name or to a blank or tab before it.
!
!	PERCENT_ALLOWED - If this flag is TRUE, the display name is allowed
!		  to begin with a percent sign, thus denoting one of the
!		  display pseudo-symbols such as %NEXTDISP, etc.  If this
!		  flag is FALSE, the percent sign is not allowed to start
!		  the display name.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the display name picked up by this
!		  routine.
!
!	A pointer to the display name in Counted ASCII format is returned as
!		  the routine's value.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE];	! Pointer to input string descriptor

    LOCAL
	CHARLEN,			! Character length of input string
	CHARPTR: REF VECTOR[,BYTE],	! Character pointer into input string
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to the ASCIC display name



    ! Set up the character pointer and string length we will use and update
    ! as the display name is scanned.  Also get a buffer to hold the name.
    !
    CHARPTR = .INPUT_DESC[DSC$A_POINTER];
    CHARLEN = .INPUT_DESC[DSC$W_LENGTH];
    NAMEPTR = DBG$GET_TEMPMEM(84/4);
    NAMEPTR[0] = 0;


    ! First scan past any leading blanks or tabs.
    !
    WHILE (.CHARPTR[0] EQL ' ') OR (.CHARPTR[0] EQL TAB_CHAR) DO
	BEGIN
	CHARPTR = .CHARPTR + 1;
	CHARLEN = .CHARLEN - 1;
	END;


    ! Then scan past the leading percent sign if there is one and if one is
    ! allowed on this command.
    !
    IF .PERCENT_ALLOWED AND (.CHARPTR[0] EQL '%')
    THEN
	BEGIN
	CHARPTR = .CHARPTR + 1;
	CHARLEN = .CHARLEN - 1;
	NAMEPTR[0] = 1;
	NAMEPTR[1] = '%';
	END;


    ! Now scan the display name.  Copy the name itself into the NAMEPTR buffer.
    !
    WHILE ((.CHARPTR[0] GEQ 'A') AND (.CHARPTR[0] LEQ 'Z')) OR
	  ((.CHARPTR[0] GEQ '0') AND (.CHARPTR[0] LEQ '9')) OR
	  (.CHARPTR[0] EQL '$') OR (.CHARPTR[0] EQL '_')
    DO
	BEGIN
	IF .NAMEPTR[0] GEQ 80 THEN SIGNAL(DBG$_NAMTOOLONG, 1, .NAMEPTR);
	NAMEPTR[0] = .NAMEPTR[0] + 1;
	NAMEPTR[.NAMEPTR[0]] = .CHARPTR[0];
	CHARPTR = .CHARPTR + 1;
	CHARLEN = .CHARLEN - 1;
	END;


    ! We are done scanning the display name.  Update the input string descriptor
    ! to indicate the new parse location.  Then return the display name pointer.
    !
    IF .NAMEPTR[0] EQL 0 THEN DBG$SYNTAX_ERROR(.INPUT_DESC);
    INPUT_DESC[DSC$A_POINTER] = .CHARPTR;
    INPUT_DESC[DSC$W_LENGTH] = .CHARLEN;
    RETURN .NAMEPTR;

    END;

ROUTINE PARSE_WINDOW_NAME(INPUT_DESC) =
!
! FUNCTION
!	This routine parses (scans and picks up) a screen window name.  It
!	is called during the parsing of all Screen Debugging commands which
!	have window names in their syntax.
!
! INPUTS
!	INPUT_DESC - A string descriptor to the input line being parsed.
!		  The descriptor is assumed to point to the start of the
!		  window name or to a blank or tab before it.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the window name picked up by this
!		  routine.
!
!	A pointer to the window name in Counted ASCII format is returned as
!		  the routine's value.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE];	! Pointer to input string descriptor

    LOCAL
	CHARLEN,			! Character length of input string
	CHARPTR: REF VECTOR[,BYTE],	! Character pointer into input string
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to the ASCIC window name



    ! Set up the character pointer and string length we will use and update
    ! as the window name is scanned.  Also get a buffer to hold the name.
    !
    CHARPTR = .INPUT_DESC[DSC$A_POINTER];
    CHARLEN = .INPUT_DESC[DSC$W_LENGTH];
    NAMEPTR = DBG$GET_TEMPMEM(84/4);
    NAMEPTR[0] = 0;


    ! First scan past any leading blanks or tabs.
    !
    WHILE (.CHARPTR[0] EQL ' ') OR (.CHARPTR[0] EQL TAB_CHAR) DO
	BEGIN
	CHARPTR = .CHARPTR + 1;
	CHARLEN = .CHARLEN - 1;
	END;


    ! Now scan the window name.  Copy the name itself into the NAMEPTR buffer.
    !
    WHILE ((.CHARPTR[0] GEQ 'A') AND (.CHARPTR[0] LEQ 'Z')) OR
	  ((.CHARPTR[0] GEQ '0') AND (.CHARPTR[0] LEQ '9')) OR
	  (.CHARPTR[0] EQL '$') OR (.CHARPTR[0] EQL '_')
    DO
	BEGIN
	IF .NAMEPTR[0] GEQ 80 THEN SIGNAL(DBG$_NAMTOOLONG, 1, .NAMEPTR);
	NAMEPTR[0] = .NAMEPTR[0] + 1;
	NAMEPTR[.NAMEPTR[0]] = .CHARPTR[0];
	CHARPTR = .CHARPTR + 1;
	CHARLEN = .CHARLEN - 1;
	END;


    ! We are done scanning the window name.  Update the input string descriptor
    ! to indicate the new parse location.  Then return the window name pointer.
    !
    IF .NAMEPTR[0] EQL 0 THEN DBG$SYNTAX_ERROR(.INPUT_DESC);
    INPUT_DESC[DSC$A_POINTER] = .CHARPTR;
    INPUT_DESC[DSC$W_LENGTH] = .CHARLEN;
    RETURN .NAMEPTR;

    END;

ROUTINE PARSE_WINDOW_PARAMETERS(INPUT_DESC, R_BEG, R_LEN, C_BEG, C_LEN): NOVALUE =
!
! FUNCTION
!	This routine parses a "screen window specification" of the form
!	"(RBEG, RLEN, CBEG, CLEN)".  The parse pointer is assumed to point
!	to the first character after the opening left parenthesis when this
!	routine is called.  This routine picks up and returns the values of
!	all the window parameters, and leaves the parse pointer pointing to
!	the first character after the closing right parenthesis.  The CBEG
!	and CLEN parameters are optional in the input string, and are given
!	default values if omitted.
!
! INPUTS
!	INPUT_DESC - The address of the input string descriptor for the command
!		  line to be parsed for a window specification.
!
!	R_BEG	- The address of a longword location to receive the RBEG value.
!
!	R_LEN	- The address of a longword location to receive the RLEN value.
!
!	C_BEG	- The address of a longword location to receive the CBEG value.
!
!	C_LEN	- The address of a longword location to receive the CLEN value.
!
! OUTPUTS
!	INPUT_DESC - The INPUT_DESC string descriptor is updated to reflect the
!		  new parse location after picking up the window parameters.
!
!	R_BEG	- The value of the RBEG parameter (the beginning row location
!		  of the screen window) is returned to the R_BEG location.
!
!	R_LEN	- The value of the RLEN parameter (the row length or height
!		  of the screen window) is returned to the R_LEN location.
!
!	C_BEG	- The value of the CBEG parameter (the beginning column loca-
!		  tion of the screen window) is returned to the C_BEG location.
!
!	C_LEN	- The value of the CLEN parameter (the column length or width
!		  of the screen window) is returned to the C_LEN location.
!

    BEGIN

    MAP
	R_BEG: REF VECTOR[1,LONG],	! Return location for RBEG parameter
	R_LEN: REF VECTOR[1,LONG],	! Return location for RLEN parameter
	C_BEG: REF VECTOR[1,LONG],	! Return location for CBEG parameter
	C_LEN: REF VECTOR[1,LONG];	! Return location for CLEN parameter

    LOCAL
	CBEG,				! Beginning column location of window
	CLEN,				! Column length (width) of window
	RBEG,				! Beginning row location of window
	RLEN;				! Row length (height) of window



    ! Pick up the RBEG parameter (the beginning row location) and check it
    ! for being within its valid range.
    !
    DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, RBEG);
    IF (.RBEG LSS 1) OR (.RBEG GTR DBG$K_PASTE_SIZE - 2)
    THEN
	SIGNAL(DBG$_INVWINPAR, 1, .RBEG);


    ! Pick up the RLEN parameter (the row length or height of the display) and
    ! check it for being within its valid range.  A comma must precede it.
    !
    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1)
    THEN
	DBG$SYNTAX_ERROR(.INPUT_DESC);

    DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, RLEN);
    IF (.RLEN LSS 1) OR (.RBEG + .RLEN GTR DBG$K_PASTE_SIZE - 1)
    THEN
	SIGNAL(DBG$_INVWINPAR, 1, .RLEN);


    ! Next pick up the optional column location and width (CBEG and CLEN).
    ! We do this only if there is not a closing parenthesis at this point.
    !
    CBEG = 1;
    CLEN = 132;
    IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_RPAREN, 1)
    THEN
	BEGIN
	IF NOT .DBG$GL_DEVELOPER[7] THEN DBG$SYNTAX_ERROR(.INPUT_DESC); !<<-----


	! Pick up the CBEG parameter (the beginning column location) and check
	! it for being within its valid range.  A comma must precede this
	! parameter.
	!
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, CBEG);
	IF (.CBEG LSS 1) OR (.CBEG GTR 132)
	THEN
	    SIGNAL(DBG$_INVWINPAR, 1, .CBEG);


	! Pick up the CLEN parameter (the column length or width of the
	! display) and check it for being within its valid range.  A comma
	! must precede it.
	!
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_COMMA, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC, CLEN);
	IF (.CLEN LSS 1) OR (.CBEG + .CLEN GTR 133)
	THEN
	    SIGNAL(DBG$_INVWINPAR, 1, .CLEN);


	! Finally make sure the closing parenthesis is there too.
	!
	IF NOT DBG$NMATCH(.INPUT_DESC, DBG$CS_RPAREN, 1)
	THEN
	    DBG$SYNTAX_ERROR(.INPUT_DESC);

	END;				! End of code for optional parameters


    ! All window parameters have been parsed.  Return the parameter values we
    ! found to the caller.  Then return.
    !
    R_BEG[0] = .RBEG;
    R_LEN[0] = .RLEN;
    C_BEG[0] = .CBEG;
    C_LEN[0] = .CLEN;
    RETURN;

    END;

ROUTINE REDIRECT_SCREEN_OUTPUT: NOVALUE =
!
! FUNCTION
!	This routine redirects screen output to logical name DBG$OUTPUT if
!	a translation exists for this logical name.  Such redirection is
!	useful for directing DEBUG output to a second terminal, for example.
!	If no translation for DBG$OUTPUT exists, no redirection is done and
!	all screen output goes to SYS$OUTPUT.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LOGNAMDESC: BLOCK[8,BYTE],	! String descriptor for DBG$OUTPUT name
	RESULTBUF: VECTOR[80,BYTE],	! Result string buffer for $TRNLOG
	RESULTDESC: BLOCK[8,BYTE],	! Result string descriptor for $TRNLOG
	STATUS;				! Screen package status code



    ! Set up the necessary descriptors and the attempt to translate logical
    ! name DBG$OUTPUT.
    !
    LOGNAMDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    LOGNAMDESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LOGNAMDESC[DSC$W_LENGTH] = 10;
    LOGNAMDESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII 'DBG$OUTPUT');
    RESULTDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    RESULTDESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    RESULTDESC[DSC$W_LENGTH] = 80;
    RESULTDESC[DSC$A_POINTER] = RESULTBUF;
    STATUS = $TRNLOG(LOGNAM = LOGNAMDESC, RSLBUF = RESULTDESC);


    ! If there is no translation, return immediately without redirecting the
    ! screen output.
    !
    IF .STATUS EQL SS$_NOTRAN THEN RETURN;


    ! There is a translation for DBG$OUTPUT.  Redirect screen output to
    ! DBG$OUTPUT.  If the redirection fails for any reason, redirect output
    ! back to SYS$OUTPUT.
    !
    STATUS = SCR$SET_OUTPUT(1, LOGNAMDESC);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL(DBG$_UNAOPESCR, 0, .STATUS);
	LOGNAMDESC[DSC$A_POINTER] = UPLIT BYTE(%ASCII 'SYS$OUTPUT');
	SCR$SET_OUTPUT(1, LOGNAMDESC);
	END;


    ! The redirection is completed.  Now return.
    !
    RETURN;

    END;

ROUTINE REGISTER_DISPLAY(DISPTR, REGVECTOR): NOVALUE =
!
! FUNCTION
!	This routine generates the contents of a REGISTER screen display.
!	It accepts a pointer to a REGISTER Screen Display Entry and a
!	pointer to a vector of register values as input, and generates
!	the full contents of that screen display using the register values
!	in the input register value vector.
!
! INPUTS
!	DISPTR	- A pointer to the Screen Display Entry for the register
!		  screen display to be generated.
!
!	REGVECTOR - A pointer to a register vector containing the register
!		  values to be printed in the DISPTR register screen display.
!		  The register vector is a vector of 17 longwords containing
!		  the values of registers R0 - R11, AP, FP, SP, PC, and PSL
!		  in that order.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	DISPTR: REF DBG$DISP_ENTRY,	! Pointer to Screen Display Entry
	REGVECTOR: REF VECTOR[,LONG];	! Pointer to register value vector

    BUILTIN
	PROBER;				! Probe a location for read access

    LOCAL
	APVAL: REF VECTOR[,LONG],	! The Argument Pointer value (AP)
	BLINK: REF DBG$DLINE_ENTRY,	! Pointer to previous Display Line Entry
	DLEPTR: REF DBG$DLINE_ENTRY,	! Pointer to current Display Line Entry
	FLINK: REF DBG$DLINE_ENTRY,	! Pointer to next Display Line Entry
	HEXDESC: BLOCK[8,BYTE],		! String descriptor for HEXSTRING
	HEXSTRING: VECTOR[8,BYTE],	! Hexadecimal format of register value
	LINE_TBL: VECTOR[5, LONG],	! Table of pointer to Display Lines
	MSG_LENGTH,			! Length of returned message text
	MSG_DESCR: BLOCK[8,BYTE],	! Message descriptor for $GETMSG
	PSLVAL,				! The Processor Status Longword value
	REND,				! Rendition code for changed values
	SPVAL: REF VECTOR[,LONG],	! The Stack Pointer value (SP)
	STATUS,				! Status returned by $GETMSG
	TPTR: REF VECTOR[,BYTE];	! Pointer to text contents for a line



    ! Check the DISPTR input parameter for validity.
    !
    IF .DISPTR[DBG$B_DISP_KIND] NEQ DBG$K_DISP_REGISTER
    THEN
	$DBG_ERROR('DBGSCREEN\REGISTER_DISPLAY 10');

    IF (.DISPTR[DBG$W_DISP_LINECNT] NEQ 0) AND
       (.DISPTR[DBG$W_DISP_LINECNT] NEQ 5)
    THEN
	$DBG_ERROR('DBGSCREEN\REGISTER_DISPLAY 20');


    ! If this register is empty (meaning that it does not yet contain any text
    ! lines), fill in the register display template.  If text lines exist, they
    ! are assumed to contain the original template with register values filled
    ! in, so that the template does not need to be regenerated.
    !
    REND = .DISPTR[DBG$B_DISP_REND] XOR
			(DBG$M_DISP_REND_RV OR DBG$M_DISP_REND_BLD);
    IF .DISPTR[DBG$W_DISP_LINECNT] EQL 0
    THEN
	BEGIN
	REND = .DISPTR[DBG$B_DISP_REND];
	DISPTR[DBG$W_DISP_DROW] = 1;


	! Loop to generate the templates for the five lines of the display.
	!
	INCR I FROM 0 TO 4 DO
	    BEGIN


	    ! Allocate the Display Line Entry for the current line and set up
	    ! its contents including the text of the line.
	    !
	    DLEPTR = DBG$GET_MEMORY(DBG$K_DLINE_ENTSIZE + (80*2)/%UPVAL + 1);
	    DLEPTR[DBG$B_DLINE_LENGTH] = 80;
	    DLEPTR[DBG$B_DLINE_REND] = .DISPTR[DBG$B_DISP_REND];
	    CASE .I FROM 0 TO 4 OF
		SET

		[0]:
		    TPTR = UPLIT BYTE(80, %ASCII 'R0: xxxxxxxx R1: xxxxxxxx ',
		     'R2: xxxxxxxx R3: xxxxxxxx  @AP:xxxxxxxx  @SP:xxxxxxxx ');

		[1]:
		    TPTR = UPLIT BYTE(80, %ASCII 'R4: xxxxxxxx R5: xxxxxxxx ',
		     'R6: xxxxxxxx R7: xxxxxxxx   +4:xxxxxxxx   +4:xxxxxxxx ');

		[2]:
		    TPTR = UPLIT BYTE(80, %ASCII 'R8: xxxxxxxx R9: xxxxxxxx ',
		     'R10:xxxxxxxx R11:xxxxxxxx   +8:xxxxxxxx   +8:xxxxxxxx ');

		[3]:
		    TPTR = UPLIT BYTE(80, %ASCII 'AP: xxxxxxxx FP: xxxxxxxx ',
		     'SP: xxxxxxxx PC: xxxxxxxx  +12:xxxxxxxx  +12:xxxxxxxx ');

		[4]:
		    TPTR = UPLIT BYTE(80, %ASCII '                          ',
		     '                                      N:x Z:x V:x C:x ');

		TES;

	    CH$MOVE(81, .TPTR, DLEPTR[DBG$A_DLINE_TEXT]);


	    ! Link the new Display Line Entry into the line entry chain for
	    ! the DISPTR display.  Also increment the display's line count.
	    ! Then loop for the next line.
	    !
	    FLINK = DISPTR[DBG$L_DISP_START_LINE_PTR];
	    BLINK = .FLINK[DBG$L_DLINE_BLINK];
	    DLEPTR[DBG$L_DLINE_FLINK] = .FLINK;
	    DLEPTR[DBG$L_DLINE_BLINK] = .BLINK;
	    FLINK[DBG$L_DLINE_BLINK] = .DLEPTR;
	    BLINK[DBG$L_DLINE_FLINK] = .DLEPTR;
	    DISPTR[DBG$W_DISP_LINECNT] = .DISPTR[DBG$W_DISP_LINECNT] + 1;
	    IF .I EQL 0 THEN DISPTR[DBG$L_DISP_WINDOW_PTR] = .DLEPTR;

	    END;			! End of line initialization loop

	END;				! End of display template initialization


    ! Set up the line table with pointer to the five display lines.  Also clear
    ! out the line's rendition vector (which immediately follows the text).
    !
    DLEPTR = .DISPTR[DBG$L_DISP_START_LINE_PTR];
    INCR I FROM 0 TO 4 DO
	BEGIN
	LINE_TBL[.I] = .DLEPTR;
	TPTR = DLEPTR[DBG$A_DLINE_TEXT];
	CH$FILL(.DISPTR[DBG$B_DISP_REND], 80, TPTR[81]);
	DLEPTR[DBG$V_DLINE_RENDFLG] = FALSE;
	DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
	END;


    ! Set up the string descriptor used for hexadecimal formatting.
    !
    HEXDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    HEXDESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    HEXDESC[DSC$W_LENGTH] = 8;
    HEXDESC[DSC$A_POINTER] = HEXSTRING;


    ! Fill all the register values into their respective slots in the register
    ! display.  All values are formatted in hexadecimal.
    !
    INCR I FROM 0 TO 15 DO
	BEGIN
	OTS$CVT_L_TZ(REGVECTOR[.I], HEXDESC, 8);
	DLEPTR = .LINE_TBL[.I/4];
	TPTR = DLEPTR[DBG$A_DLINE_TEXT];
	REGISTER_FILL(.DLEPTR, 8, HEXSTRING, TPTR[(.I MOD 4)*13 + 5], .REND);
	END;


    ! Fill the first few values from the Argument Vector and from the top of
    ! the stack into the register display.
    !
    APVAL = .REGVECTOR[12];
    SPVAL = .REGVECTOR[14];
    INCR I FROM 0 TO 3 DO
	BEGIN
	DLEPTR = .LINE_TBL[.I];
	TPTR = DLEPTR[DBG$A_DLINE_TEXT];


	! Fill the I-th value of the Argument Vector into the register display.
	! If that element is not readable, use "-noread-" instead.
	!
	IF PROBER(%REF(0), %REF(4), APVAL[.I])
	THEN
	    OTS$CVT_L_TZ(APVAL[.I], HEXDESC, 8)

	ELSE
	    CH$MOVE(8, UPLIT BYTE('-noread-'), HEXSTRING);

	REGISTER_FILL(.DLEPTR, 8, HEXSTRING, TPTR[58], .REND);


	! Fill the I-th value off the Stack Pointer (SP) into the register
	! display.  If that element is not readable, use "-noread-" instead.
	!
	IF PROBER(%REF(0), %REF(4), SPVAL[.I])
	THEN
	    OTS$CVT_L_TZ(SPVAL[.I], HEXDESC, 8)

	ELSE
	    CH$MOVE(8, UPLIT BYTE('-noread-'), HEXSTRING);

	REGISTER_FILL(.DLEPTR, 8, HEXSTRING, TPTR[72], .REND);

	END;				! End of loop for @AP+x and @SP+x


    ! Fill in the message text (if any) that corresponds to the value in R0.
    ! The message text is truncated to the first 60 characters.
    !
    DLEPTR = .LINE_TBL[4];
    TPTR = DLEPTR[DBG$A_DLINE_TEXT];
    CH$FILL(' ', 60, TPTR[1]);
    MSG_DESCR[DSC$B_CLASS] = DSC$K_CLASS_S;
    MSG_DESCR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    MSG_DESCR[DSC$W_LENGTH] = 60;
    MSG_DESCR[DSC$A_POINTER] = TPTR[1];
    STATUS = $GETMSG(MSGID = .REGVECTOR[0],
			MSGLEN = MSG_LENGTH, BUFADR = MSG_DESCR, FLAGS = 0);
    IF (.STATUS EQL SS$_MSGNOTFND) OR (NOT .STATUS)
    THEN
	CH$FILL(' ', 60, TPTR[1]);


    ! Fill in the values of the four condition codes (N, Z, V, and C) into the
    ! last line of the register display.
    !
    PSLVAL = .REGVECTOR[16];
    HEXSTRING[0] = .PSLVAL<V_(3)> + '0';
    REGISTER_FILL(.DLEPTR, 1, HEXSTRING, TPTR[67], .REND);
    HEXSTRING[0] = .PSLVAL<V_(2)> + '0';
    REGISTER_FILL(.DLEPTR, 1, HEXSTRING, TPTR[71], .REND);
    HEXSTRING[0] = .PSLVAL<V_(1)> + '0';
    REGISTER_FILL(.DLEPTR, 1, HEXSTRING, TPTR[75], .REND);
    HEXSTRING[0] = .PSLVAL<V_(0)> + '0';
    REGISTER_FILL(.DLEPTR, 1, HEXSTRING, TPTR[79], .REND);


    ! The register display is fully generated.  Now return.
    !
    RETURN;

    END;

ROUTINE REGISTER_FILL(DLEPTR, LENGTH, SRCPTR, DSTPTR, REND): NOVALUE =
!
! FUNCTION
!	This routine fills a source string, usually with a hexadecimal register
!	value, into a field in a register screen display.  In addition to
!	simply filling in the source characters into the destination location,
!	it checks to see if the field is changing value.  If so, the contents
!	of the field is marked to be put out in the rendition specified by the
!	REND input parameter (usually bolding).  Hence the register display
!	highlights changed register values by showing their new values in a
!	different rendition.
!
! INPUTS
!	DLEPTR	- A pointer to the Display Line Entry for the text line into
!		  which the new source string is to be filled.
!
!	LENGTH	- The length of the character string to be filled in.
!
!	SRCPTR	- A pointer to the source location containing the character
!		  string to be copied.
!
!	DSTPTR	- A pointer to the destination location into which the
!		  character string is to be copied.
!
!	REND	- The rendition codes to be used for fields which have
!		  changed their values.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	DLEPTR: REF DBG$DLINE_ENTRY;	! Pointer to the Display Line Entry

    LOCAL
	TPTR: REF VECTOR[,BYTE];	! Pointer to display line's text vector



    ! If the new character string is identical in value to the string that is
    ! already in the destination field, we return immediately.  This leaves
    ! the string as is and it leaves the rendition as normal video.
    !
    IF CH$EQL(.LENGTH, .SRCPTR, .LENGTH, .DSTPTR, 0) THEN RETURN;


    ! The character string is changing value.  Hence we copy the new value to
    ! the destination address and we mark its rendition as specified by the
    ! REND parameter.  Then return.
    !
    CH$MOVE(.LENGTH, .SRCPTR, .DSTPTR);
    DLEPTR[DBG$V_DLINE_RENDFLG] = TRUE;
    TPTR = DLEPTR[DBG$A_DLINE_TEXT];
    CH$FILL(.REND, .LENGTH, TPTR[1 + .TPTR[0] + (.DSTPTR - TPTR[1])]);
    RETURN;

    END;

ROUTINE WINDOW_SOURCE_LINE(DISPID, DOWN_FLAG) =
!
! FUNCTION
!	This routine returns the Display Line Entry which contains the first
!	source line number of the current screen window of a specified display.
!	Normally, this is simply the line number of the first Display Line
!	Entry in the display's screen window.  However, if that first line does
!	not have a line number (it could be an unnumbered page eject record in
!	the source file), then this routine searches forward and backward until
!	it finds the nearest source line with a line number.  A pointer to the
!	Display Line Entry for that source line is returned as this routine's
!	value.  This routine is called when scrolling source displays.
!
! INPUTS
!	DISPID	- A pointer to the Screen Display Entry for which the first
!		  window line number is desired.
!
!	DOWN_FLAG - A flag set to TRUE if the display is to be scrolled down
!		  and set to FALSE if the display is to be scrolled up.
!
! OUTPUTS
!	This routine returns a pointer to the Screen Display Line Entry for
!		  the source line with the first source line number in the
!		  current display window.
!

    BEGIN

    MAP
	DISPID: REF DBG$DISP_ENTRY;	! Pointer to Screen Display Entry

    LOCAL
	DLEPTR: REF DBG$DLINE_ENTRY;	! Pointer to current Display Line Entry



    ! Search the specified display's Display Line Entry list in the preferred
    ! direction until we find a Display Line Entry with a line number.  When
    ! we find such an entry, return its address to the caller.  The preferred
    ! direction is forward if we are scrolling down and backward if we are
    ! scrolling up.
    !
    DLEPTR = .DISPID[DBG$L_DISP_WINDOW_PTR];
    WHILE TRUE DO
	BEGIN
	IF .DLEPTR[DBG$L_DLINE_LINUM] GEQ 0 THEN RETURN .DLEPTR;
	IF .DOWN_FLAG
	THEN
	    BEGIN
	    IF .DLEPTR EQL .DISPID[DBG$L_DISP_END_LINE_PTR] THEN EXITLOOP;
	    DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
	    END

	ELSE
	    BEGIN
	    IF .DLEPTR EQL .DISPID[DBG$L_DISP_START_LINE_PTR] THEN EXITLOOP;
	    DLEPTR = .DLEPTR[DBG$L_DLINE_BLINK];
	    END;

	END;


    ! We did not find a Display Line Entry with a line number scanning in the
    ! preferred direction.  Hence we now scan the Display Line Entry list in
    ! the opposite direction (backward if scrolling down and forward if scroll-
    ! ing up).  When we find an entry with a line number, we return its address
    ! to the caller.
    !
    DLEPTR = .DISPID[DBG$L_DISP_WINDOW_PTR];
    WHILE TRUE DO
	BEGIN
	IF .DLEPTR[DBG$L_DLINE_LINUM] GEQ 0 THEN RETURN .DLEPTR;
	IF .DOWN_FLAG
	THEN
	    BEGIN
	    IF .DLEPTR EQL .DISPID[DBG$L_DISP_START_LINE_PTR] THEN EXITLOOP;
	    DLEPTR = .DLEPTR[DBG$L_DLINE_BLINK];
	    END

	ELSE
	    BEGIN
	    IF .DLEPTR EQL .DISPID[DBG$L_DISP_END_LINE_PTR] THEN EXITLOOP;
	    DLEPTR = .DLEPTR[DBG$L_DLINE_FLINK];
	    END;

	END;


    ! If we have not found a Display Line Entry with a line number, something
    ! is wrong and we signal an internal DEBUG error.
    !
    $DBG_ERROR('DBGSCREEN\WINDOW_SOURCE_LINE');
    RETURN 0;

    END;

END ELUDOM
