MODULE DBGEXADEP (IDENT = 'V04-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!
!	DEBUG
!
! ABSTRACT:
!
!	Parse networks for EXAMINE, DEPOSIT, and EVALUATE.
!
! ENVIRONMENT:
!
!	VAX/VMS
!
! AUTHOR:
!
!	David Plummer
!
! CREATION DATE:
!
!	9-Jul_80
!
! VERSION:
!
!	V02.2-001
!
! MODIFIED BY:
!	Richard Title	31-Jul-81
!
! REVISION HISTORY:
! 3.0	31-JUL-81	 RT	Added type qualifiers /FLOAT, /D_FLOAT, etc.
! 3.1	23-Jun-83	 WC3	Added support for EXAMINE/PACKED, EXAMINE/DATE_TIME
! 3.2	11-Jul-83	 WC3	Added support for DEP/PACKED:n
! 3.3	15-Jul-83	 WC3	Added support for DEP/DATE_TYPE and Fix EXAMINE/DATE_TIME
!				to use DBG$CVT_DX_DX.
! 3.4	20-JAN-84	 BAB	Made DEP/INSTR work right.
!
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	DBG$NPARSE_DEPOSIT,		! Parse network for DEPOSIT
	DBG$SET_PAGE_PROT,		! Sets protection for a page list
	DBG$NPARSE_EVALUATE,		! Parse network
	DBG$NPARSE_EXAMINE,		! Parse network
	DBG$NFORMAT_WITH_RADIX: NOVALUE;! Formats a value with radix override

! REQUIRE FILES:
!
REQUIRE 'SRC$:DBGPROLOG.REQ';
LIBRARY 'LIB$:DBGGEN.L32';

! EQUATED SYMBOLS
!
LITERAL			
    DEPOSIT 			= 1,
    DEPOSIT_INSTRUCTION 	= 2,
    DEPOSIT_REGISTER		= 3;

LITERAL
    EVALUATE 		= 1,		! Plain jane EVALUATE
    EVALUATE_ADDR	= 2,		! EVALUATE/ADDRESS
    EVALUATE_COND	= 3;		! EVALUATE/CONDITION_VALUE

LITERAL
    EXAMINE			= 1,
    EXAMINE_INSTRUCTION		= 2,
    EXAMINE_REGISTER		= 3,
    EXAMINE_SOURCE		= 4,
    EXAMINE_CONDITION_VALUE	= 5,
    EXAMINE_PSL			= 6,
    EXAMINE_PSW			= 7;

LITERAL
	DUMMY_TYPE = dbg$k_notype,	! Used in type node
	MAX_STRING_SIZE = 256;		! Max string size for SYS$GETMSG.


! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
    	DBG$CVT_DX_DX: NOVALUE,			! Convert any-any
    	DBG$DEF_SYM_FIND,			! Look up defined symbol
	DBG$FLUSHBUF:  NOVALUE,		! Initializes a new print line.
	DBG$GET_TEMPMEM,			! Allocates command temporary dynamic storage
	DBG$INS_DECODE,				! Decodes an instruction
	DBG$INS_ENCODE,				! Encodes an instruction
    	DBG$NCOPY_DESC,				! Copy a descriptor
	DBG$NEWLINE:  NOVALUE,		! Prints a buffer
	DBG$NGET_DEFAULT_TYPE,			! Obtains user set default type
	DBG$NGET_LENGTH,			! Obtains a primary's rvalue length
	DBG$NGET_LVAL,				! Obtains a primary's lvalue
	DBG$NGET_MODE,				! Returns true if SYMBOLS, false otherwise
	DBG$NGET_OVERRIDE_TYPE,			! Obtains user set override type
	DBG$NGET_PAGES,				! Obtains an rvalue page list
	DBG$NGET_POTENTIAL_TYPE : NOVALUE,	! Returns potential type and length for '.'
	DBG$NGET_TYPE,				! Obtains type of primary descriptor
	DBG$NMAKE_ARG_VECT,			! Creates a message arguent vector
	DBG$NMAKE_VAL_DESC,			! Constructs a value descriptor
	DBG$NMATCH,				! Matches input against counted strings
	DBG$NNEXT_WORD,				! Obtains next word of input
	DBG$NOUT_INFO,				! Outputs and informational message
	DBG$NPARSE_ADDRESS,			! Interface to Address Expression Interpreter
	DBG$NPARSE_EXPRESSION,			! Interface to Expression Interpreter
	DBG$NSAVE_INTEGER,			! Converts current radix input to integer
	DBG$NSAVE_LAST_LOC 	: NOVALUE,	! Saves '.'
	DBG$NSAVE_LAST_VAL 	: NOVALUE,	! Saves '\'
	DBG$NSET_LAST_TYPLEN	: NOVALUE,	! Saves pseudo type and length
	DBG$NSYMBOLIZE,				! Symbolizes from a primary descriptor
	DBG$NSYNTAX_ERROR,			! Formats a syntax error
	DBG$NTYPE_CONV,				! Type converter
	DBG$OUTPUT_PSL		: NOVALUE,	! Outputs the PSL in special format
	DBG$PRINT:  NOVALUE,			! Formats into output buffer
	DBG$READ_ACCESS,			! Probes for read access of virtual address
	DBG$SET_MOD_LVL,			! Sets MODE pointer
	DBG$SRC_TYPE_PC_SOURCE	: NOVALUE,	! Implements EX/SOURCE
	DBG$STA_SETREGISTERS : NOVALUE, 	! Resets registers context
	DBG$TRANS_TO_REGNAME,			! Translate address to register name
	SYS$GETMSG;				! Outputs system-type message.

EXTERNAL
	DBG$GB_MOD_PTR : REF VECTOR [,BYTE],	! Pointer to MODE structure
    	DBG$GB_RADIX: VECTOR[3,BYTE],		! Radix settings
	DBG$GL_CMND_RADIX,			! Holds radix of command
	DBG$RUNFRAME	    : BLOCK [,BYTE];	! Pointer to current runframe


GLOBAL ROUTINE DBG$NPARSE_DEPOSIT (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine comprises the ATN parse network for the DEPOSIT verb.
!	During parsing, calls are made to other routines to parse expressions
!	and address expressions for inclusion as operands in the command
!	execution tree. The competed tree is used as input to the command
!	execution network which performs the associated semantic actions.
!
!	DEPOSITs are affected by command override types, user set override types,
!	and user set default types. The strategy of this routine is to construct
!	a command execution tree that reflects this situation. Thus, whenver the
!	target of the DEPOSIT is described by anything other than a primary
!	descriptor, adverb nodes are created to describe the type for the
!	target. Primary descriptor entity types are overriden only by command
!	and user set override types, - not the default type.
!
!	When an instruction DEPOSIT is indicated, a kernal DEBUG routine is
!	called to obtain the source of the target. This MUST be a quoted string.
!	The source for all other DEPOSITs is obtained through the Expression
!	Interpreter.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC	- A longword containing the address of a standard ascii
!			  string descriptor representing the user's input
!
!	VERB_NODE	- A longword containing the address of the verb (head)
!			  node of the command execution tree
!
!	MESSAGE_VECT	- The address of a longword to contain the address of a
!			  message argument vector upon detection of errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the entire command execution tree is constructed.
!
!	On failure, a message argument vector is constructed and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1)	- Success. Input parsed and execution tree constructed.
!
!	STS$K_SEVERE  (4)	- Failure. Error detected. Message argument vector
!				  constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	VERB_NODE 		: REF dbg$verb_node;

    BIND			

	! Strings used at this level of parsing
	!
	DBG$CS_INSTRUCTION	= UPLIT BYTE (11, 'INSTRUCTION'),
	DBG$CS_PACKED		= UPLIT BYTE (6, 'PACKED'),		       	! A3.2
	DBG$CS_DATE_TIME	= UPLIT BYTE (9, 'DATE_TIME'),			! A3.3
	DBG$CS_ASCII		= UPLIT BYTE (5, 'ASCII'),
    	DBG$CS_ASCIC		= UPLIT BYTE (5, 'ASCIC'),
    	DBG$CS_AC 		= UPLIT BYTE (2, 'AC'),
    	DBG$CS_ASCIW		= UPLIT BYTE (5, 'ASCIW'),
    	DBG$CS_AW		= UPLIT BYTE (2, 'AW'),
    	DBG$CS_ASCIZ		= UPLIT BYTE (5, 'ASCIZ'),
    	DBG$CS_AZ		= UPLIT BYTE (2, 'AZ'),
    	DBG$CS_ASCID		= UPLIT BYTE (5, 'ASCID'),
    	DBG$CS_AD		= UPLIT BYTE (2, 'AD'),
	DBG$CS_BYTE		= UPLIT BYTE (4, 'BYTE'),
	DBG$CS_WORD		= UPLIT BYTE (4, 'WORD'),
	DBG$CS_LONGWORD		= UPLIT BYTE (8, 'LONGWORD'),
	DBG$CS_QUADWORD		= UPLIT BYTE (8, 'QUADWORD'),
	DBG$CS_OCTAWORD		= UPLIT BYTE (8, 'OCTAWORD'),
	DBG$CS_FLOAT		= UPLIT BYTE (5, 'FLOAT'),
	DBG$CS_F_FLOAT		= UPLIT BYTE (7, 'F_FLOAT'),
	DBG$CS_D_FLOAT		= UPLIT BYTE (7, 'D_FLOAT'),
	DBG$CS_G_FLOAT		= UPLIT BYTE (7, 'G_FLOAT'),
	DBG$CS_H_FLOAT		= UPLIT BYTE (7, 'H_FLOAT'),
	DBG$CS_COLON		= UPLIT BYTE (1, dbg$k_colon),
	DBG$CS_SLASH		= UPLIT BYTE (1, dbg$k_slash),
	DBG$CS_EQUAL_SIGN	= UPLIT BYTE (1, dbg$k_equal),
	DBG$CS_CR		= UPLIT BYTE (1, dbg$k_car_return);

    LOCAL
	ADDR_EXP_DESC	: REF dbg$aed,		! Address expression descriptor
	NOUN_NODE 	: REF dbg$noun_node,	! Object
	ADVERB_NODE 	: REF dbg$adverb_node,	! Adverb
	LINK,					! Pointer
	INP_RADIX,					! Radix for numeric literals
	TYPE,					! Type of target
	LENGTH,					! Length of target
	ADDRESS 	: VECTOR [2],		! Address of target
	STATUS,					! Return status
	VALPTR		: REF dbg$valdesc;	! Value descripter

    ! Create and link a noun node to contain the target
    !
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    verb_node [dbg$l_verb_object_ptr] = .noun_node;


    ! Initialize target type and length 
    !
    type = -1;		! -1 indicates that we have not found an override type
    length = 0;

    ! Accept any command switches. We start out with a verb composite representing
    ! a plain DEPOSIT. This may change as a result of command or user set overrides.
    ! We changes the composite to DEPOSIT_INSTRUCTION if we find /INSTRUCTION.
    ! We do not create an adverb node for radix switches - only types.
    !
    verb_node [dbg$b_verb_composite] = deposit;
    inp_radix = .dbg$gb_radix[dbg$b_radix_input];

    WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1)
    DO
	BEGIN
	SELECTONE true
	    OF
	    SET

	    [dbg$nmatch (.input_desc, dbg$cs_instruction, 1)] : !DEPOSIT/INSTRUCION
		BEGIN
		type = dsc$k_dtype_zi;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_byte, 1)] : ! DEPOSIT/BYTE
		BEGIN
		type = dsc$k_dtype_b;
		length = byte_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_word, 1)] : ! DEPOSIT/WORD
		BEGIN
		type = dsc$k_dtype_w;
		length = word_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_longword, 1)] : ! DEPOSIT/LONGWORD
		BEGIN
		type = dsc$k_dtype_l;
		length = long_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_quadword, 1)] : ! DEPOSIT/QUAD
		BEGIN
		type = dsc$k_dtype_q;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_date_time, 2)] : ! DEPOSIT/DATE_TIME
		BEGIN
		type = dsc$k_dtype_adt;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_octaword, 1)] : ! DEPOSIT/OCTAWORD
		BEGIN
		type = dsc$k_dtype_o;
		length = 16;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_float, 1),
	     dbg$nmatch (.input_desc, dbg$cs_f_float, 1)] : ! DEPOSIT/FLOAT
		BEGIN
		type = dsc$k_dtype_f;
		length = 4;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_d_float, 2)] : ! DEPOSIT/D_FLOAT
		BEGIN
		type = dsc$k_dtype_d;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_g_float, 1)] : ! DEPOSIT/G_FLOAT
		BEGIN
		type = dsc$k_dtype_g;
		length = 8;
		END;

	    [dbg$nmatch( .input_desc, dbg$cs_h_float, 2)] : ! DEPOSIT/H_FLOAT
		BEGIN
		type = dsc$k_dtype_h;
		length = 16;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_packed, 1)] :		       ! A3.2
		BEGIN							       ! A3.2
		type = dsc$k_dtype_p;					       ! A3.2
									       ! A3.2
		! Accept the ':' and integer. If there is no colon, use	       ! A3.2
		! a length or default of 10.				       ! A3.2
		!							       ! A3.2
		IF NOT dbg$nmatch (.input_desc, dbg$cs_colon, 1)	       ! A3.2
		THEN							       ! A3.2
		    BEGIN						       ! A3.2
		    length = 10;					       ! A3.2
		    END							       ! A3.2
		ELSE							       ! A3.2
		    BEGIN						       ! A3.2
									       ! A3.2
		    ! We found the colon. Accept the integer		       ! A3.2
		    !							       ! A3.2
		    IF NOT dbg$nsave_integer (.input_desc, length)             ! A3.2
		    THEN						       ! A3.2
			RETURN sts$k_severe;				       ! A3.2
									       ! A3.2
		    ! Check to see that the length is within 0 and 31	       ! A3.2
		    !							       ! A3.2
		    IF (.length LSS 0)  OR  (.length GTR 31)		       ! A3.2
		    THEN						       ! A3.2
			SIGNAL(dbg$_illpacsiz, 1, .length);		       ! A3.2
		    END;						       ! A3.2
		END;							       ! A3.2

	    [dbg$nmatch (.input_desc, dbg$cs_ascii, 1)] : ! DEPOSIT/ASCII
		BEGIN

		! Accept the ':' and integer. If there is no colon, we assume
		! a length of 4
		!
		IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
		THEN
		    BEGIN

		    ! We found the colon. Accept the integer
		    !
		    IF NOT dbg$nsave_integer (.input_desc, length)
		    THEN
		    RETURN sts$k_severe;

		    ! Check to see that the length of the ascii deposit is not 0
		    !
		    IF .length LEQ 0
	  	    THEN
			BEGIN
			OWN num_desc : dbg$stg_desc;

			num_desc [dsc$w_length] = 1;
			num_desc [dsc$a_pointer] = UPLIT TYPE ('0');
			.message_vect = dbg$nmake_arg_vect (dbg$_invnumber, 1, num_desc);
			RETURN sts$k_severe;
			END;

		    END;

		type = dsc$k_dtype_t;


		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_ascic, 5),
    	     dbg$nmatch (.input_desc, dbg$cs_ac, 2)] :	
    		BEGIN
    		type = dsc$k_dtype_ac;
    		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_asciw, 5),
    	     dbg$nmatch (.input_desc, dbg$cs_aw, 2)] :
    		BEGIN
    		type = dsc$k_dtype_vt;
    		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_asciz, 5),
    	     dbg$nmatch (.input_desc, dbg$cs_az, 2)] :
    		BEGIN
    		type = dsc$k_dtype_az;
    		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_ascid, 5),
    	     dbg$nmatch (.input_desc, dbg$cs_ad, 2)] :
    		BEGIN
    		type = dbg$k_dtype_ad;
    		END;

	    [OTHERWISE] :	! Some flavor of user error
		BEGIN
		.message_vect =
		( IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		  THEN
		      dbg$nmake_arg_vect (dbg$_needmore)
		  ELSE
		      dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		RETURN sts$k_severe;
		END;
	    
	    TES;

	END;


    ! Obtain the target of the DEPOSIT in the form of an address expression descriptor
    !
    STATUS = DBG$NPARSE_ADDRESS (.INPUT_DESC, NOUN_NODE [DBG$L_NOUN_VALUE],
				 .INP_RADIX, TOKEN$K_TERM_EQUAL, .MESSAGE_VECT);


    ! The Address Expression Interpreter MUST give us a warning return to
    ! indicate the '=' that seperates the target from the source.
    !
    IF .status NEQ sts$k_warning
    THEN
	BEGIN
	IF .status EQL sts$k_success ! Missing '='
	THEN
	    .message_vect = dbg$nmake_arg_vect (dbg$_needmore);
	RETURN sts$k_severe;
	END;


    ! Gobble the '='
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_equal_sign, 1)
    THEN
	BEGIN
	.message_vect =
	( IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
	  THEN
	      dbg$nmake_arg_vect (dbg$_needmore)
	  ELSE
	      dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
	RETURN sts$k_severe;
	END;


    ! Recover the target address expression descriptor
    !
    addr_exp_desc = .noun_node [dbg$l_noun_value];


    ! Create an adverb node which we may use to type the target, but don't link
    ! it to the verb node until we need to.
    !
    adverb_node = dbg$get_tempmem (dbg$k_adverb_node_size);


    ! Type the target based on command overrides, user set overrides, current
    ! location typing, address expression descriptor contents, or user set defaults.
    ! Check for command override.
    !
    IF .type NEQ -1
    THEN
	BEGIN
	verb_node [dbg$l_verb_adverb_ptr] = .adverb_node;
	adverb_node [dbg$b_adverb_literal] = .type;
	adverb_node [dbg$l_adverb_value] = .length;
	END
    ELSE
	BEGIN

	! There was no command override. Check for a type/override.
	!
	IF dbg$nget_override_type (type, length)
	THEN
	    BEGIN
	    verb_node [dbg$l_verb_adverb_ptr] = .adverb_node;
	    adverb_node [dbg$b_adverb_literal] = .type;
	    adverb_node [dbg$l_adverb_value] = .length;
	    END;
	END;
				

    ! The adverb node has been set up, and the command has been classified as
    ! either DEPOSIT or DEPOSIT_INSTRUCTION. The target has been placed in the
    ! first noun node. Now the source must be obtained. We allocate another
    ! noun node and link it to the first one for this purpose. This second
    ! noun node will point either to a value descriptor or to a buffer containing
    ! a potential instruction counted string.
    !
    link = noun_node [dbg$l_noun_link];

    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    .link = .noun_node;	! This links the new noun node


    ! For implementation level 3, we always just want to call the
    ! expression parser.
    !
    IF NOT (STATUS = DBG$NPARSE_EXPRESSION (.INPUT_DESC, .INP_RADIX,
				NOUN_NODE [DBG$L_NOUN_VALUE],
				TOKEN$K_TERM_NONE, .MESSAGE_VECT,
    				DBG$K_DEPOSIT_VERB))
    THEN
    	BEGIN

	! We do not expect more input after the expression
    	!
	IF .status EQL sts$k_warning
	THEN
	    .message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
	RETURN sts$k_severe;
	END;

    ! This assures that the DEPOSIT/INSTR has a quoted string.
    !
    IF .type EQL dsc$k_dtype_zi
    THEN
        BEGIN
        valptr = .noun_node [dbg$l_noun_value];
        IF .valptr [dbg$b_value_dtype] NEQ dsc$k_dtype_t
        THEN
            SIGNAL(dbg$_opnotallow, 1, uplit byte(%ascic 'DEPOSIT'));
        END;

    RETURN sts$k_success;
    END;

GLOBAL ROUTINE DBG$SET_PAGE_PROT (PAGE_LIST, RESET_FLAG, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine accepts the page list data structure produced by dbg$nget_pages
!	or create_page_list and changes the protection of each page so specified
!	to provide write access for DEPOSIT's. As this is done, a new data structure
!	is constructed in which each node in the tree is replace with a node that
!	has one more field. This extra field contains the old protection of the
!	page so that it may be reset after the deposit.
!
!	When called upon to reset the page protections, this routine uses the data
!	structure it produced in the first step, and changes all page protections
!	back to their original values.
!
! FORMAL PARAMETERS:
!
!	PAGE_LIST		- The address of a longword containing the address
!				  of the first node in the page list.
!
!	RESET_FLAG		- A longword containing true or false. If false,
!				  protection is changed to allow write access. If
!				  true, protection for each page is set back to
!				  the original value
!
!	MESSAGE_VECT		- The address of a longword to contain the address
!				  of a message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	When NOT .reset_flag, a new page list is constructed.
!	When .reset_flag, page protections are reset to original values.
!
!	On failure, a message argument vector is constructed.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success	(1) - Success. Page protection set or reset.
!
!	sts$k_severe	(4) - Failure. Message argument vector produced.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    FIELD PROT_NODE_FIELDS =
	SET
	NODE_LINK	= [0, 0, 32, 0],	! Link field
	PAGE_NUM	= [1, 0, 32, 0],	! Page number field
	OLD_PROT	= [2, 0, 8, 0]		! Old protection field
	TES;

    LITERAL
	PROT_NODE_SIZE	= 3;			! Length of node in longwords

    MACRO
	PROT_NODE	= BLOCK [prot_node_size] FIELD (prot_node_fields) %;

    LOCAL
	PAGE_VECT 	: VECTOR [2];		! Vector to hold page numbers

    ! Check to see if we are setting or resetting protections
    !
    IF .reset_flag
    THEN
	BEGIN

	! We are restoring protection. Therefore, page_list contains the address
	! of a longword that contains the address of the modified page list.
	!
	LOCAL
	    NODE : REF prot_node;	! Modified page list node

     	! Obtain the address of the list.
	!
	node = ..page_list;
	

	! Loop and reset the page protections
	!
	WHILE .node NEQA 0
	DO
	    BEGIN

	    ! Reset the old protection
	    !
	    page_vect [0] = .node [page_num];
	    page_vect [1] = .node [page_num];	! We don't use a range

	    $SETPRT (inadr = page_vect [0], prot = .node [old_prot]);


	    ! Obtain the next node
	    !
	    node = .node [node_link];

	    END;	! End of loop

    	END

    ELSE
	BEGIN
	BUILTIN PROBEW;

	! We are changing protections. Therefore, we must construct the modified
	! page list.
	!
	LOCAL
	    LINK,				! Temporary pointer
	    NEW_NODE : REF prot_node,		! Modified list node
	    OLD_NODE : REF dbg$link_node;	! Old list node

	! Recover the head node of the unmodified page list
	!
	old_node = ..page_list;

	(link = .page_list) = 0;

	! Loop changing the protection and constructing the new list
	!  Check to see if this page is already writeable, before we
	! attempt to set the protection!  This fixes a bug in trying
	! to deposit into a global section (mapped for write access)
	! when changing page protections is not allowed.

	WHILE .old_node NEQA 0 DO
	    BEGIN
	    IF NOT PROBEW(%REF(0),%REF(1),.old_node[dbg$l_link_node_value]) THEN
		BEGIN

		! Allocate a modified node and link it
		!
		new_node = dbg$get_tempmem (prot_node_size);
		.link = .new_node;
		link = new_node [node_link];

		! Copy over relevant info
		!
		new_node [page_num] = .old_node [dbg$l_link_node_value];

		! Change the protection, if possible
		!
		page_vect [0] = .new_node [page_num];
		page_vect [1] = .new_node [page_num];

		IF NOT $SETPRT (inadr = page_vect [0], 
				prot = prt$c_uw,
				prvprt = new_node [old_prot])
		THEN
		    BEGIN
		    .message_vect = dbg$nmake_arg_vect (dbg$_badtarget);
		    RETURN sts$k_severe;
		    END;

		END;

	    ! Pick up the next node
	    !
	    old_node = .old_node [dbg$l_link_node_link];

	    END;	! End of loop

	END;

    RETURN sts$k_success;
    END;	! End of dbg$set_page_prot

GLOBAL ROUTINE DBG$NPARSE_EVALUATE (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse network for the EVALUATE command. The parsing method used is that
!	of ATN's. This network constructs a command execution tree to be executed
!	by dbg$nexecute_evaluate.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC		- A longword containing the address of a standard
!				  string descriptor which reflects the input string
!
!	VERB_NODE		- A longword containing the address of the verb
!				  (head) node of the command execution tree
!
!	MESSAGE_VECT		- The address of a longword to contain the
!				  address of a standard message argument vector on errors
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, a command execution tree is constructed representing the parsed
!	input command.
!
!	On failure, a message argument vector is constructed.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1)	- Success. Input parsed and execution tree constructed.
!
!	sts$k_severe  (4)	- Failure. Tree not constructed. Message vector
!				  constructed.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	INPUT_DESC : REF BLOCK [, BYTE],
	VERB_NODE  : REF dbg$verb_node;

    ! Define counted strings used at this level
    !
    BIND
	DBG$CS_ADDRESS 		= UPLIT BYTE (7, 'ADDRESS'),
	DBG$CS_CONDITION	= UPLIT BYTE (15,'CONDITION_VALUE'),
    	DBG$CS_BINARY		= UPLIT BYTE (6, 'BINARY'),
	DBG$CS_HEXADECIMAL 	= UPLIT BYTE (11,'HEXADECIMAL'),
	DBG$CS_OCTAL   		= UPLIT BYTE (5, 'OCTAL'),
	DBG$CS_DECIMAL 		= UPLIT BYTE (7, 'DECIMAL'),
	DBG$CS_COMMA		= UPLIT BYTE (1, dbg$k_comma),
	DBG$CS_CR		= UPLIT BYTE (1, dbg$k_car_return),
	DBG$CS_SLASH   		= UPLIT BYTE (1, dbg$k_slash);

    LOCAL
	STATUS,					! Holds return status
	NOUN_NODE 	: REF dbg$noun_node,	! Object
	NEXT_NOUN_NODE  : REF dbg$noun_node,	! Next object
	ADVERB_NODE 	: REF dbg$adverb_node,	! Modifier
	RADIX;					! Radix

    ! Create and link a noun node
    !
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);

    verb_node [dbg$l_verb_object_ptr] = .noun_node;


    ! Start with default radix
    !
    radix = .dbg$gb_radix[dbg$b_radix_output_over];


    ! Accept any / switches. Start with plain jane evaluate - this may get changed.
    !
    verb_node [dbg$b_verb_composite] = evaluate;

    WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1)
    DO
	BEGIN

	! Try to match legal switches
	!
	SELECTONE true
	    OF
	    SET

	    [dbg$nmatch (.input_desc, dbg$cs_address, 1)]  : ! address switch
		BEGIN
		verb_node [dbg$b_verb_composite] = evaluate_addr;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_condition, 1)]  : ! condition switch
		BEGIN
		verb_node [dbg$b_verb_composite] = evaluate_cond;
		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_binary, 2)] :
    		BEGIN
    		radix = dbg$k_binary;
    		END;

	    [dbg$nmatch (.input_desc, dbg$cs_hexadecimal, 1)]	: ! Change radix to hex
		BEGIN
		radix = dbg$k_hex;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_octal, 1)] : ! Change radix to octal
		BEGIN
		radix = dbg$k_octal;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_decimal, 1)] : ! Change radix to decimal
		BEGIN
		radix = dbg$k_decimal;
		END;

	    [OTHERWISE] :	! Syntax error
		BEGIN
		.message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
		RETURN sts$k_severe;
		END;

	    TES

	END;


    ! Be sure the user has supplied us with some sort of input after the verb.
    !
    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    THEN
	BEGIN
	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
	RETURN sts$k_severe;
	END;


    ! Loop until input is exhausted.
    !
    WHILE TRUE DO
	BEGIN


    	! Obtain the object of the evaluate based on the verb composite
    	!
    	CASE .verb_node [dbg$b_verb_composite] FROM evaluate TO evaluate_addr
   	    OF
	    SET


	    ! Call the Expression Interpreter to obtain expression value.
	    !
	    [evaluate] :  
	        STATUS =  DBG$NPARSE_EXPRESSION (.INPUT_DESC, 
    			  .DBG$GB_RADIX[DBG$B_RADIX_INPUT],
		          NOUN_NODE [DBG$L_NOUN_VALUE],
		          TOKEN$K_TERM_COMMA, .MESSAGE_VECT);

	    ! Call Address Expression Interpreter.
	    !
	    [evaluate_addr] :
	    	STATUS =  DBG$NPARSE_ADDRESS (.INPUT_DESC,
		          NOUN_NODE [DBG$L_NOUN_VALUE],
		          .DBG$GB_RADIX[DBG$B_RADIX_INPUT], 
    			  TOKEN$K_TERM_COMMA, .MESSAGE_VECT);

	    TES;


	! Check the return status.
	!
	SELECTONE .status OF
	    SET


	    ! If successful, then continue.
	    !
	    [sts$k_success]:
		BEGIN
		0;
		END;


	    ! If a warning is returned, a comma may have been discovered in the
	    ! input stream.  Check for this.  If there is no comma, a syntax error
	    ! has occurred.  If a comma is present, there must be more input or else
	    ! error.  If all is OK, then link in another noun node.
	    !
	    [sts$k_warning]:
	    	BEGIN
	    	IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
	    	THEN
		    BEGIN
		    .message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
		    RETURN sts$k_severe;
		    END;
	    	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
	    	THEN
		    BEGIN
		    .message_vect = dbg$nmake_arg_vect (dbg$_needmore);
		    RETURN sts$k_severe;
		    END;
    		next_noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
	    	noun_node[dbg$l_noun_link] = .next_noun_node;
	    	noun_node = .next_noun_node;
	    	END;


	    ! Anything else, return severe error.
	    !
	    [OTHERWISE]:
	    	BEGIN
	    	RETURN sts$k_severe;
	    	END;

	    TES;


	! Check for exhausted input.
	!
	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1) OR
		       .input_desc[dsc$w_length] EQL 0
	THEN
	    EXITLOOP;

	END;  ! End while loop.


    ! Check for a modifier.
    !
    IF .radix NEQ dbg$k_default
    THEN
	BEGIN

	! Construct a radix modifier node and link to verb node
	!
    	adverb_node = dbg$get_tempmem (dbg$k_adverb_node_size);

	adverb_node [dbg$b_adverb_literal] = .radix;
	verb_node [dbg$l_verb_adverb_ptr] = .adverb_node;
	adverb_node [dbg$l_adverb_link] = 0;
	END;

    RETURN sts$k_success;

    END;			! End of dbg$nparse_evaluate

GLOBAL ROUTINE DBG$NPARSE_EXAMINE (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	ATN parse network for the EXAMINE verb. The network constructs a command
!	execution tree consisting of a linked list of command operands which the
!	execution network accepts as input to perform the command.
!
!	Three adverb nodes are ALWAYS created and linked. They are in the order:
!
!	1) Type node	- This node contains override or default type info. It may
!			  have the value of dummy_type when the source of the
!			  EXAMINE is described by a primary descriptor and
!			  no override type has been specified.
!
!	2) Radix node   - The radix to be used in outputting the value.
!			  For implementation level 2, DBG$K_DEFAULT is
!			  translated to the real radix.
!
!
!	3) Mode node	- Either true or false. True means symbolic output. False
!			  means no symbolic output.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC		- A longword containing the address of the command
!				  input descriptor
!
!	VERB_NODE		- A longword containing the address of the command
!				  execution tree verb (head) node
!
!	MESSAGE_VECT		- The address of a longword to contain the address
!				  of a standard message argument vector on errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the command execution tree is constructed.
!
!	On failure, a message argument vector is constructed or obtained.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1)	- Success. Command execution tree constructed.
!
!	sts$k_severe  (4)	- Failure. Error encountered. Message argument
!				  constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	INPUT_DESC	: REF BLOCK [ ,BYTE],
	VERB_NODE	: REF dbg$verb_node;

    BIND

	! Strings used at this level of parsing
	!
	DBG$CS_INSTRUCTION	= UPLIT BYTE (11,'INSTRUCTION'),
	DBG$CS_SYMBOLS		= UPLIT BYTE (8, 'SYMBOLIC'),
	DBG$CS_NOSYMBOLS	= UPLIT BYTE (10,'NOSYMBOLIC'),
	DBG$CS_BINARY		= UPLIT BYTE (6, 'BINARY'),
	DBG$CS_OCTAL		= UPLIT BYTE (5, 'OCTAL'),
	DBG$CS_DECIMAL		= UPLIT BYTE (7, 'DECIMAL'),
	DBG$CS_HEXADECIMAL	= UPLIT BYTE (11,'HEXADECIMAL'),
	DBG$CS_DEFAULT		= UPLIT BYTE (7, 'DEFAULT'),
	DBG$CS_AC		= UPLIT BYTE (2, 'AC'),
	DBG$CS_ASCIC		= UPLIT BYTE (5, 'ASCIC'),
	DBG$CS_AD		= UPLIT BYTE (2, 'AD'),
	DBG$CS_ASCID		= UPLIT BYTE (5, 'ASCID'),
	DBG$CS_AW		= UPLIT BYTE (2, 'AW'),
	DBG$CS_ASCIW		= UPLIT BYTE (5, 'ASCIW'),
	DBG$CS_AZ		= UPLIT BYTE (2, 'AZ'),
	DBG$CS_ASCIZ		= UPLIT BYTE (5, 'ASCIZ'),
	DBG$CS_ASCII		= UPLIT BYTE (5, 'ASCII'),
	DBG$CS_CONDITION_VALUE	= UPLIT BYTE (15,'CONDITION_VALUE'),
	DBG$CS_PSL		= UPLIT BYTE (3 ,'PSL'),
	DBG$CS_PSW		= UPLIT BYTE (3 ,'PSW'),
	DBG$CS_BYTE		= UPLIT BYTE (4, 'BYTE'),
	DBG$CS_WORD		= UPLIT BYTE (4, 'WORD'),
	DBG$CS_LONGWORD		= UPLIT BYTE (8, 'LONG'),
	DBG$CS_QUADWORD		= UPLIT BYTE (8, 'QUADWORD'),
	DBG$CS_OCTAWORD		= UPLIT BYTE (8, 'OCTAWORD'),
	DBG$CS_FLOAT		= UPLIT BYTE (5, 'FLOAT'),
	DBG$CS_F_FLOAT		= UPLIT BYTE (7, 'F_FLOAT'),
	DBG$CS_D_FLOAT		= UPLIT BYTE (7, 'D_FLOAT'),
	DBG$CS_G_FLOAT		= UPLIT BYTE (7, 'G_FLOAT'),
	DBG$CS_H_FLOAT		= UPLIT BYTE (7, 'H_FLOAT'),
	DBG$CS_SOURCE		= UPLIT BYTE (6, 'SOURCE'),
	DBG$CS_PACKED		= UPLIT BYTE (6, 'PACKED'),		       ! A3.1
	DBG$CS_DATE_TIME	= UPLIT BYTE (9, 'DATE_TIME'),		       ! A3.1
	DBG$CS_COMMA		= UPLIT BYTE (1, dbg$k_comma),
	DBG$CS_COLON		= UPLIT BYTE (1, dbg$k_colon),
	DBG$CS_SLASH		= UPLIT BYTE (1, dbg$k_slash),
	DBG$CS_CR		= UPLIT BYTE (1, dbg$k_car_return);

    LOCAL
	ADDR_EXP_DESC		: REF dbg$aed,		! Address expression descriptor
	NOUN_NODE		: REF dbg$noun_node,	! Object
	ADVERB_NODE		: REF dbg$adverb_node,	! Adverb
	LINK,						! Pointer
    	SYM_OVERRIDE_PRESENT,
    	INP_RADIX,					! Input radix
	RADIX,						! Radix for numeric literals
	TYPE,						! Type of source
	SYMBOL_FLAG,					! IF true then SYMBOLIC EXAMINE
	LOWER_PC_FLAG,					! TRUE if we are parsing
							! the lower pc in the
							! pc range.
	SOURCE_FLAG,					! TRUE for EX/SOURCE
	MSG_TEXT,					! TRUE for EX/CONDITION_VALUE
	LENGTH,						! Length of source
	ADDRESS			: VECTOR [2],		! Address of source
	STATUS;						! Return status

    ! Create and link a noun node to contain the target
    !
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);

    verb_node [dbg$l_verb_object_ptr] = .noun_node;


    ! Initialize target type and length
    !
    type = -1;		! -1 indicates that we have not found an override type
    length = 0;


    ! Initialize the symbolic - nosymbolic flag and source flag
    !
    symbol_flag = dbg$nget_mode ();
    sym_override_present = FALSE;
    source_flag = FALSE;
    msg_text = FALSE;

    ! Initialize the lower_pc flag
    !
    lower_pc_flag = TRUE;

    ! Initialize the radix.
    !
    inp_radix = .dbg$gb_radix[dbg$b_radix_input];
    radix = .dbg$gb_radix[dbg$b_radix_output_over];

    ! Accept any command switches. We start out with a verb composite representing
    ! a plain EXAMINE. This may change as a result of command or user set overrides.
    ! We changes the composite to EXAMINE_INSTRUCTION if we find /INSTRUCTION.
    ! The composite is changed to EXAMINE_CONDITION_VALUE if /CONDITION_VALUE
    ! is found.
    !
    verb_node [dbg$b_verb_composite] = examine;

    WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1)
    DO
	BEGIN
	SELECTONE true
	    OF
	    SET

	    [dbg$nmatch (.input_desc, dbg$cs_instruction, 1)] :
		BEGIN
		type = dsc$k_dtype_zi;
		length = 0;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_byte, 1)] :
		BEGIN
		type = dsc$k_dtype_b;
		length = byte_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_word, 1)] :
		BEGIN
		type = dsc$k_dtype_w;
		length = word_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_condition_value, 1)]:
		BEGIN
		type = dsc$k_dtype_l;
		length = long_length;
		msg_text = TRUE;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_date_time, 2)]:		       ! A3.1
		BEGIN							       ! A3.1
		type = dsc$k_dtype_adt;					       ! A3.1 M3.3
		length = 8;						       ! A3.1
		END;							       ! A3.1

	    [dbg$nmatch (.input_desc, dbg$cs_psl, 3)]:
		BEGIN
		type = dsc$k_dtype_lu;
		length = long_length;
		verb_node [dbg$b_verb_composite] = examine_psl;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_psw, 3)]:
		BEGIN
		type = dsc$k_dtype_wu;
		length = word_length;
		verb_node [dbg$b_verb_composite] = examine_psw;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_longword, 1)] :
		BEGIN
		type = dsc$k_dtype_l;
		length = long_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_ac, 2),
	     dbg$nmatch (.input_desc, dbg$cs_ascic, 5)]:
		BEGIN
		type = dsc$k_dtype_ac;
		length = byte_length;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_aw, 2),
	     dbg$nmatch (.input_desc, dbg$cs_asciw, 5)]:
		BEGIN
		type = dsc$k_dtype_vt;
		length = word_length;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_az, 2),
	     dbg$nmatch (.input_desc, dbg$cs_asciz, 5)]:
		BEGIN
		type = dsc$k_dtype_az;
		length = byte_length;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_ad, 2),
	     dbg$nmatch (.input_desc, dbg$cs_ascid, 5)]:
		BEGIN
		type = dbg$k_dtype_ad;
		length = 2 * long_length;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_ascii, 1)] :
		BEGIN

		! Accept the ':' and integer. If there is no colon, we assume
		! a length of 4
		!
		IF NOT dbg$nmatch (.input_desc, dbg$cs_colon, 1)
		THEN
		    BEGIN
		    length = 0;
		    END
		ELSE
		    BEGIN

		    ! We found the colon. Accept the integer
		    !
		    IF NOT dbg$nsave_integer (.input_desc, length)
		    THEN
			RETURN sts$k_severe;

		    ! Check to see that the length of the ascii examine is not 0
		    !
		    IF .length GTRU 2048
		    THEN
			BEGIN
			OWN
			    num_desc : dbg$stg_desc;

			num_desc [dsc$w_length] = 1;
			num_desc [dsc$a_pointer] = UPLIT TYPE ('0');
			.message_vect = dbg$nmake_arg_vect (dbg$_invnumber, 1, num_desc);
			RETURN sts$k_severe;
			END;
		    END;

		type = dsc$k_dtype_t;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_default, 3)] :
		BEGIN
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_binary, 2)] :
		BEGIN
		radix = dbg$k_binary;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_octal, 1)] :
		BEGIN
		radix = dbg$k_octal;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_d_float, 2)] :
		BEGIN
		type = dsc$k_dtype_d;
		length = 8;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_decimal, 1)] :
		BEGIN
		radix = dbg$k_decimal;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_hexadecimal, 1)] :
		BEGIN
		radix = dbg$k_hex;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_symbols, 1)] :
		BEGIN
		symbol_flag = true;
    		sym_override_present = TRUE;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_nosymbols, 1)] :
		BEGIN
		symbol_flag = false;
    		sym_override_present = TRUE;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_source, 2)] : ! EX/SOURCE
		BEGIN
		source_flag = TRUE;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_quadword, 1)] :
		BEGIN
		type = dsc$k_dtype_q;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_octaword, 5)] :
		BEGIN
		type = dsc$k_dtype_o;
		length = 16;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_float, 1),
	     dbg$nmatch (.input_desc, dbg$cs_f_float, 1)] :
		BEGIN
		type = dsc$k_dtype_f;
		length = 4;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_g_float, 1)] :
		BEGIN
		type = dsc$k_dtype_g;
		length = 8;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_h_float, 2)] :
		BEGIN
		type = dsc$k_dtype_h;
		length = 16;
		radix = dbg$k_default;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_packed, 2)] :		       ! A3.1
		BEGIN							       ! A3.1
		type = dsc$k_dtype_p;					       ! A3.1
		radix = dbg$k_default;					       ! A3.1
									       ! A3.1
		! Accept the ':' and integer. If there is no colon, use	       ! A3.1
		! a length or -1 to signal that we will have to find the length! A3.1
		! after its been converted from text.			       ! A3.1
		!							       ! A3.1
		IF NOT dbg$nmatch (.input_desc, dbg$cs_colon, 1)	       ! A3.1
		THEN							       ! A3.1
		    BEGIN						       ! A3.1
		    length = -1;					       ! A3.1
		    END							       ! A3.1
		ELSE							       ! A3.1
		    BEGIN						       ! A3.1
									       ! A3.1
		    ! We found the colon. Accept the integer		       ! A3.1
		    !							       ! A3.1
		    IF NOT dbg$nsave_integer (.input_desc, length)             ! A3.1
		    THEN						       ! A3.1
			RETURN sts$k_severe;				       ! A3.1
									       ! A3.1
		    ! Check to see that the length is within 0 and 31	       ! A3.1
		    !							       ! A3.1
		    IF (.length LSS 0)  OR  (.length GTR 31)		       ! A3.1
		    THEN						       ! A3.1
			SIGNAL(dbg$_illpacsiz, 1, .length);		       ! A3.1
		    END;						       ! A3.1
		END;							       ! A3.1

	    [OTHERWISE] :	! Some flavor of user error
		BEGIN
		.message_vect =
		( IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		  THEN
		      dbg$nmake_arg_vect (dbg$_needmore)
		  ELSE
		      dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		RETURN sts$k_severe;
		END;

	    TES;

	END;


    IF .sym_override_present
    THEN
    	BEGIN
    	dbg$set_mod_lvl (override_mode);
    	dbg$gb_mod_ptr[mode_symbols] = .symbol_flag;
    	END;

    ! Check for EXAMINE <CR>. If this is the case, we call the pseudo symbol
    ! interpreter to find the meaning of successor ourselves.
    !
    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    THEN
	BEGIN
	LOCAL
	    AE_DESC	: REF dbg$aed,	! Address expression descriptor
	    SYMBOL_TYPE,
	    SYMBOL_VALUE,
	    TYPE,
	    LENGTH;

    	MAP
    	    SYMBOL_VALUE: REF DBG$VALDESC;

    	LOCAL
    	    DUMMY,
    	    KIND;

    	! Look up the symbol in the DEFINE symbol table.
    	!
        IF DBG$DEF_SYM_FIND (UPLIT BYTE (%ASCIC '%NEXTLOC'),
    						 KIND, SYMBOL_VALUE, 
    						 DUMMY, DUMMY)
    	THEN 
    	    IF .KIND EQL DEFINE_ADDRESS
    	    OR .KIND EQL DEFINE_VALUE
    	    THEN
    		BEGIN

    		! Turn value descriptors into volatile value descriptors.
    		!
    		IF .SYMBOL_VALUE [DBG$B_DHDR_TYPE] EQL DBG$K_VALUE_DESC
    		THEN
    		    BEGIN
    		    SYMBOL_VALUE [DBG$B_DHDR_TYPE] = DBG$K_V_VALUE_DESC;
    		    SYMBOL_VALUE [DBG$L_VALUE_POINTER] = 
    			    .SYMBOL_VALUE [DBG$L_VALUE_VALUE0];
    		    IF .SYMBOL_VALUE [DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_V
    		    OR .SYMBOL_VALUE [DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU
    		    OR .SYMBOL_VALUE [DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SV
    		    OR .SYMBOL_VALUE [DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_SVU
    		    THEN
    		   	SYMBOL_VALUE [DBG$L_VALUE_POS] = 
    			    	.SYMBOL_VALUE [DBG$L_VALUE_VALUE1];
    		    END;

    		! We have found a matching DEFINEd symbol.
    		! Copy the descriptor into temporary memory.
    		! (Fourth parameter FALSE <-> copy into tempmem).
    		!
    		DBG$NCOPY_DESC (.SYMBOL_VALUE, SYMBOL_VALUE,
    				     DUMMY, FALSE);
    		END

    	    ELSE
    		SIGNAL (DBG$_NOCURLOC)
    	ELSE
    	    SIGNAL (DBG$_NOCURLOC);

	noun_node [dbg$l_noun_value]  = .symbol_value;
	noun_node [dbg$l_noun_value2] = .symbol_value;
	END

    ELSE

	! Loop through the examine list

	WHILE TRUE DO
	    BEGIN

	    ! Check for exhausted input

	    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		OR .input_desc[dsc$w_length] EQL 0
	    THEN
		EXITLOOP;

	    ! Input left. Let the AEI deal with it.
	    !
	    IF .LOWER_PC_FLAG
	    THEN
		BEGIN
		STATUS = DBG$NPARSE_ADDRESS(.INPUT_DESC,
				NOUN_NODE [DBG$L_NOUN_VALUE], .INP_RADIX,
				TOKEN$K_TERM_COMCOL, .MESSAGE_VECT);
		NOUN_NODE[DBG$L_NOUN_VALUE2] = .NOUN_NODE[DBG$L_NOUN_VALUE];
		END
	    ELSE
		STATUS = DBG$NPARSE_ADDRESS(.INPUT_DESC,
				NOUN_NODE [DBG$L_NOUN_VALUE2], .INP_RADIX,
				TOKEN$K_TERM_COMMA, .MESSAGE_VECT);

	    IF .status NEQ sts$k_success
	    THEN
		IF .status EQL sts$k_warning
		THEN
		    BEGIN

		    ! Check for comma.

		    IF dbg$nmatch (.input_desc, dbg$cs_comma, 1)
		    THEN

			BEGIN

			! Check for end of line after the comma.
			!
			IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
			THEN
			    SIGNAL(DBG$_NEEDMORE);


			! Link in another noun node
			!

			noun_node[dbg$l_noun_link] = dbg$get_tempmem (dbg$k_noun_node_size);
			noun_node = .noun_node[dbg$l_noun_link];

			! Set LOWER_PC_FLAG back to TRUE for the next
			! PC range in the list.
			!
			lower_pc_flag = TRUE;
			END

		    ELSE
			IF .lower_pc_flag
			THEN
			IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
			    THEN
				lower_pc_flag = FALSE
			ELSE
			    BEGIN
			    .message_vect = dbg$nsyntax_error(
				dbg$nnext_word (.input_desc));
			    RETURN sts$k_severe;
			    END;

		    END ! check for comma

		ELSE
		    RETURN sts$k_severe;


	! Set up for next time around loop
	!
	END; ! While loop


    ! The first adverb node we set up is the type node. We start by setting up a
    ! dummy type. If we find a real type, we change the adverb value.
    !
    ! We check to see if type is instruction. If so, we change the verb
    ! composite to an EXAMINE_INSTRUCTION.
    !
    ! Override types and default types apply, as well as command override
    ! types.
    !
    adverb_node = dbg$get_tempmem (dbg$k_adverb_node_size);

    verb_node [dbg$l_verb_adverb_ptr] = .adverb_node;
    adverb_node [dbg$b_adverb_literal] = dummy_type;


    ! Obtain the address expression descriptor
    !
    addr_exp_desc = .noun_node [dbg$l_noun_value];


    ! Check for command override
    !
    IF .type NEQ -1
    THEN
	BEGIN
	adverb_node [dbg$b_adverb_literal] = .type;
	adverb_node [dbg$l_adverb_value] = .length;

	! Check for EX/CONDITION_VALUE.
	!
	IF .msg_text
	THEN
	    verb_node [dbg$b_verb_composite] = examine_condition_value;
	END

    ELSE
	BEGIN

	! There was no command override. Check for a type/override.
	!
	IF dbg$nget_override_type (type, length)
	THEN
	    BEGIN
	    adverb_node [dbg$b_adverb_literal] = .type;
	    adverb_node [dbg$l_adverb_value] = .length;
	    END
	ELSE
	    BEGIN

	    ! There was no type override. We supply a type based on the contents
	    ! of the address expression descriptor, current location type,
	    ! and/or default type. We may also change the verb composite value.
	    !
	    ! Check for a current loc type. If this is other than 0 or notype,
	    ! then we use this type for display.
	    !
	    dbg$nget_potential_type (type, length);

	    IF .type NEQ dbg$k_notype AND .type NEQ 0
	    THEN
		BEGIN
		adverb_node [dbg$b_adverb_literal] = .type;
		adverb_node [dbg$l_adverb_value] = .length;
		END;
	    END;
	END;


    ! The adverb type node has been set up, and the command has been classified
    ! as either   EXAMINE,   EXAMINE_INSTRUCTION,   EXAMINE_CONDITION_VALUE, or
    ! EXAMINE_REGISTER. The source has been placed in the first noun node.
    ! Now we construct adverb nodes for radix and mode.
    !
    link = adverb_node [dbg$l_adverb_link];
    adverb_node = dbg$get_tempmem (dbg$k_adverb_node_size);

    .link = .adverb_node;
    adverb_node [dbg$b_adverb_literal] = .radix;
    dbg$gl_cmnd_radix = .radix;

    ! Create as adverb node for the mode (symbolic or nosymbolic).
    !
    link = adverb_node [dbg$l_adverb_link];
    adverb_node = dbg$get_tempmem (dbg$k_adverb_node_size);

    .link = .adverb_node;
    adverb_node [dbg$b_adverb_literal] = .symbol_flag;

    IF .source_flag
    THEN
	verb_node[dbg$b_verb_composite] = examine_source;

    RETURN sts$k_success;
    END;

GLOBAL ROUTINE DBG$NFORMAT_WITH_RADIX (ADDRESS, OFFSET, LENGTH, RADIX) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Formats the contents of a arbitrary number of bits into a printable
!	hex or octal number, or a sequence of unsigned decimal longwords.
!
! FORMAL PARAMETERS:
!
!	ADDRESS		-	A longword containing the byte address of the
!				location to be printed
!
!	OFFSET		-	A longword containing the starting bit offset
!
!	LENGTH		-	A longword containing the number of bits to be
!				printed
!
!	RADIX		-	A longword containing dbg$k_octal, dbg$k_decimal, or
!				dbg$k_hex, indicating the radix to be used for output
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The byte stream corresponding to the translated number is filled
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	CHAR_TABLE		: VECTOR [16],		! Character trans table
	NIBBLE			: BLOCK [1],		! Nexts bits for char trans
	BIT_VECT		: REF BITVECTOR,	! Bits to be translated
	BITS_PER_NIBBLE,				! Number of bits for 1 char
	FIRST_NIBBLE_BITS,				! Number of bits for first nibble
	FIRST_FLAG,					! Indicates first nibble
	START,						! Start bitvect position
	FINISH,						! End bitvect position
	LONG_WORD		: REF BLOCK,		! Longword for decimal output
	INDEX;						! Loop counter

    MACRO
	GET_NIBBLE	=

	BEGIN

	! This macro obtains the next nibble of bits for octal or hex output
	!
	nibble = 0;


	! Obtain the correct number of bits
	!
	IF .bits_per_nibble EQL 3
	THEN
	    BEGIN
	    nibble [0, 2, 1, 0] = .bit_vect [.start];
	    nibble [0, 1, 1, 0] = .bit_vect [.start - 1];
	    nibble [0, 0, 1, 0] = .bit_vect [.start - 2];
	    END
	ELSE
	    BEGIN
	    nibble [0, 3, 1, 0] = .bit_vect [.start];
	    nibble [0, 2, 1, 0] = .bit_vect [.start - 1];
	    nibble [0, 1, 1, 0] = .bit_vect [.start - 2];
	    nibble [0, 0, 1, 0] = .bit_vect [.start - 3];
	    END;

	start = .start - .bits_per_nibble;

	END %;


    ! Check for decimal or other radix
    !
    IF .radix EQL dbg$k_decimal
    THEN
	BEGIN

	! Line up the longword and take bits corresponding to the
	! the first longword and output them
	!
	long_word = .address;
	IF .length + .offset LEQU %BPVAL
	THEN
	    BEGIN

	    ! The entity has less than a longword of bits, counting the offset
	    !
	    nibble = .long_word [0, .offset, .length, 0];
	    length = 0;
	    END
	ELSE
	    BEGIN

	    ! Atleast a longword of bits counting the offset
	    !
	    nibble = .long_word [0, .offset, %BPVAL - .offset, 0];
	    length = .length - (%BPVAL - .offset);
	    END;


	! Output the first longword
	!
	dbg$print (UPLIT BYTE (%ASCIC '!ZL'), .nibble);


	! Loop, outputting the bits a longword at a time
	!
	index = 1;
	WHILE .length GEQU %BPVAL
	DO
	    BEGIN

	    ! Output a space
	    !
	    dbg$print (UPLIT BYTE (%ASCIC '!AC'), UPLIT BYTE (%ASCIC ' '));


	    ! Output the next longword
	    !
	     dbg$print (UPLIT BYTE (%ASCIC '!ZL'),
			  .long_word [.index, 0, 32, 0]);


	    ! Increase index and decrease length
	    !
	    index = .index + 1;
	    length = .length - %BPVAL;

	    END;

	! Output remaining bits, if any
	!
	IF .length GTRU 0
	THEN
	    BEGIN
	    dbg$print (UPLIT BYTE (%ASCIC '!AC'), UPLIT BYTE (%ASCIC ' '));
	    nibble = .long_word [.index, 0, .length, 0];
	    dbg$print (UPLIT BYTE (%ASCIC '!ZL'), .nibble);
	    END;

	END

    ELSE
	BEGIN

	! Octal or hex radix. Set up the bit vector and the start and finish
	! indicies
	!
	first_flag = true;
	bit_vect = .address;
	finish = .offset;
	start = .finish + .length - 1;


	! Set up bits_per_nibble based on radix
	!
	bits_per_nibble = (IF .radix EQL dbg$k_octal THEN 3 ELSE 4);


	! Load up the character trans table
	!
	char_table [0] =  UPLIT BYTE (%ASCIC '0');
	char_table [1] =  UPLIT BYTE (%ASCIC '1');
	char_table [2] =  UPLIT BYTE (%ASCIC '2');
	char_table [3] =  UPLIT BYTE (%ASCIC '3');
	char_table [4] =  UPLIT BYTE (%ASCIC '4');
	char_table [5] =  UPLIT BYTE (%ASCIC '5');
	char_table [6] =  UPLIT BYTE (%ASCIC '6');
	char_table [7] =  UPLIT BYTE (%ASCIC '7');
	char_table [8] =  UPLIT BYTE (%ASCIC '8');
	char_table [9] =  UPLIT BYTE (%ASCIC '9');
	char_table [10] = UPLIT BYTE (%ASCIC 'A');
	char_table [11] = UPLIT BYTE (%ASCIC 'B');
	char_table [12] = UPLIT BYTE (%ASCIC 'C');
	char_table [13] = UPLIT BYTE (%ASCIC 'D');
	char_table [14] = UPLIT BYTE (%ASCIC 'E');
	char_table [15] = UPLIT BYTE (%ASCIC 'F');


	! Determine how many bits go in the first nibble and format the first nibble
	!
	first_nibble_bits = .length MOD .bits_per_nibble;
	nibble = 0;

	CASE .first_nibble_bits FROM 0 TO 3
	    OF
	    SET

	    [0] :
		BEGIN
		0;		! Do nothing since no remainder
		END;

	    [1] :
		BEGIN
		nibble [0, 0, 1, 0] = .bit_vect [.start];
		END;

	    [2] :
		BEGIN
		nibble [0, 1, 1, 0] = .bit_vect [.start];
		nibble [0, 0, 1, 0] = .bit_vect [.start - 1];
		END;

	    [3] :
		BEGIN
		nibble [0, 2, 1, 0] = .bit_vect [.start];
		nibble [0, 1, 1, 0] = .bit_vect [.start - 1];
		nibble [0, 0, 1, 0] = .bit_vect [.start - 2];
		END;

	    TES;

	start = .start - .first_nibble_bits;

	IF .first_nibble_bits NEQ 0
	THEN
	    BEGIN
	    first_flag = false;
	    dbg$print (UPLIT BYTE (%ASCIC '!AC'), .char_table [.nibble]);
	    END;


	! Format the rest of the bits
	!
	WHILE .start GTR .finish
	    DO
		BEGIN
		get_nibble;


		! IF the first character emitted is alphabetic, prepend a '0'
		!
		IF .first_flag AND .nibble GTR 9
		THEN
		    dbg$print (UPLIT BYTE (%ASCIC '!AC'), UPLIT BYTE (%ASCIC '0'));

		dbg$print (UPLIT BYTE (%ASCIC '!AC'), .char_table [.nibble]);
		first_flag = false;
		END;

	END;

    RETURN;
    END;		! End of format_with_radix			       
END				!End of module
ELUDOM
