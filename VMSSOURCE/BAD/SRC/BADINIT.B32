MODULE badinit(	%TITLE 'Analyze/Media Initialization Module'
		IDENT = 'V04-000') =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! Facility:
!
!	Analyze/Media
!
! Abstract:
!
!	This module contains the procedures used to parse the command string
!	and allocate/initialize the control and storage structures which define
!	the device's analysis context.
!
! Environment:
!
!	VAX/VMS User Mode, Non-Privileged
!
! Author:
!
!	Michael T. Rhodes, 		Creation Date: July, 1982
!
! Modified By:
!
!	V03-004	MTR0009		Michael T. Rhodes	 3-Jul-1984
!		Fix processing of /SHOW=BEFORE qualifier to obtain
!		the correct SDBSF and generation of listings.
!
!	V03-003	MTR0003		Michael T. Rhodes	11-Feb-1983
!		Add support for Stand Alone BAD.  Routine 'alloc_mem'
!		has been changed to be a GLOBAL routine, renamed to
!		'bad$alloc_mem'.
!
!	V03-002	MTR0002		Michael T. Rhodes	20-Jan-1983
!		Use shared message BADVALUE instead of INVALNUM.
!
!	V03-001	MTR0001		Michael T. Rhodes	15-Dec-1982
!		Add the /LOG qualifier and the keyword PATTERN to the
!		/EXERCISE qualifier.  Several ROUTINEs have been added
!		to support these features:
!		    'bad_value', 'get_pattern', and 'parse_value'
!
!--


%SBTTL 'Declarations'
!
! Include Files:
!
REQUIRE	'lib$:baddef';					! Define BAD's structures.
LIBRARY	'SYS$LIBRARY:LIB';				! Define VMS structures.
LIBRARY	'SYS$LIBRARY:TPAMAC';				! TPARSE macro definitions.

!
! Table of Contents:
!
FORWARD ROUTINE
    bad$alloc_mem	: NOVALUE,			! Standard memory getter!
    bad$init		: NOVALUE,			! Process the command line qualifiers and init structures.
    addr_error,						! Handle address range errors.
    bad_value,						! Bad numeric value error routine.
    count_term,						! Number of terms in expression.
    get_mdbsf		: NOVALUE,			! Get a valid copy of the MDBSF.
    get_nlt_sdbsf,					! Get a valid copy of the SDBSF from a non last track device.
    get_pattern		: NOVALUE,			! Process user supplied test pattern(s).
    get_sdbsf		: NOVALUE,			! Get a valid copy of the SDBSF.
    init_sdbsf		: NOVALUE,			! Initialize the header of the SDBSF.
    parse_value		: NOVALUE,			! Parse and process bad block info.
    process_badblocks,					! Process user supplied bad block information.
    rebuild_dbsfs	: NOVALUE,			! Rebuild the MDBSF and SDBSF.
    recover_dbsfs,					! Attempt to rebuild/recover an SDBSF.
    syntax_err,						! Error action routine for TPARSE.
    val_log_adr,					! Validate the user supllied logical address.
    val_phy_adr;					! Validate the user supplied physical address.

!
! Private Storage
!
BIND							! The list below contains the
    after =	$DESCRIPTOR ('AFTER'),			! strings used to parse the 
    bad_blocks =$DESCRIPTOR ('BAD_BLOCKS'),		! command qualifiers and keywords.
    before =	$DESCRIPTOR ('BEFORE'),			! Also, some of the strings are
    command_lin=$DESCRIPTOR ('$LINE'),			! used in the various messages
    count =	$DESCRIPTOR ('COUNT'),			! issued from the utility.
    cylinder =	$DESCRIPTOR ('CYLINDER'),
    device =	$DESCRIPTOR ('DEVICE'),
    exercise =	$DESCRIPTOR ('EXERCISE'),
    full =	$DESCRIPTOR ('FULL'),
    keep =	$DESCRIPTOR ('KEEP'),
    log =	$DESCRIPTOR ('LOG'),
    logical_blk=$DESCRIPTOR ('LOGICAL_BLOCK'),
    mdbsf =	$DESCRIPTOR ('MDBSF'),
    output =	$DESCRIPTOR ('OUTPUT'),
    pattern =	$DESCRIPTOR ('PATTERN'),
    prompt =	$DESCRIPTOR ('BAD_BLOCKS = '),
    retry =	$DESCRIPTOR ('RETRY'),
    sdbsf =	$DESCRIPTOR ('SDBSF'),
    sector =	$DESCRIPTOR ('SECTOR'),
    show_qual =	$DESCRIPTOR ('SHOW'),
    track =	$DESCRIPTOR ('TRACK');

!
! External references:
!
EXTERNAL ROUTINE
    bad$check_ltk	: ADDRESSING_MODE (GENERAL),	! Check last track device for a user supplied entry.
    bad$check_nlt	: ADDRESSING_MODE (GENERAL),	! Check non last track device for a user supplied entry.
    bad$cvt_ltk_long	: ADDRESSING_MODE (GENERAL),	! Convert last track format to longwords.
    bad$cvt_nlt_long	: ADDRESSING_MODE (GENERAL),	! Convert non last track format to longwords.
    bad$cvt_phy_log	: ADDRESSING_MODE (GENERAL),	! Convert physical address to logical.
    bad$prepare_report	: ADDRESSING_MODE (GENERAL),	! Open the output file and generate report heading.
    bad$produce_report	: ADDRESSING_MODE (GENERAL),	! Produce a listing of the bad block file(s).
    bad$sta_init	: WEAK,				! Perform initialization for execution in the Stand Alone Env.
    bad$str_trim	: WEAK,				! Trim trailing blanks, tabs, and carriage return from sting.
    bad$sync_io		: ADDRESSING_MODE (GENERAL),	! Perform synchronous IO.
    bad$validate_pack	: WEAK,				! Set Volume Valid bit in the UCB when executing Stand Alone.
    CHECKSUM2		: ADDRESSING_MODE (GENERAL),	! Compute block checksum.
    CLI$GET_VALUE	: ADDRESSING_MODE (GENERAL),	! CLI call back routine.
    CLI$PRESENT		: ADDRESSING_MODE (GENERAL),	! CLI call back routine.
    LIB$GET_INPUT	: ADDRESSING_MODE (GENERAL),	! Library input routine.
    LIB$TPARSE		: ADDRESSING_MODE (GENERAL);	! Library State Table Parser.

EXTERNAL
    bad$gl_bad_term	: VECTOR [4, LONG],		! Bad block information vector.
    bad$gb_block_fact	: BYTE,				! Number of sectors per block.
    bad$gl_bytes_cyl,					! Total number of bytes per cylinder.
    bad$gl_bytes_trk,					! Total number of bytes per track.
    bad$gl_chan,					! Channel number for device.
    bad$ga_comnd_line	: $BBLOCK [dsc$c_s_bln],	! Address of command line buffer descriptor.
    bad$gl_context	: BITVECTOR [32],		! Global control context flags.
    bad$gl_cylinders,					! Number of cylinders on medium.
    bad$ga_bufadr	: VECTOR [2, LONG],		! Address vector of the data transfer buffers.
    bad$gl_devchar	: $BBLOCK,			! Device characteristics.
    bad$gl_devclass,					! Class of the device.
    bad$ga_device	: $BBLOCK [dsc$c_s_bln],	! Address of device name descriptor.
    bad$ga_devnam	: $BBLOCK [64],			! Device name buffer.
    bad$gl_devnam,					! Size of device name.
    bad$gq_devnam	: $BBLOCK [dsc$c_s_bln],	! Device name descriptor.
    bad$ga_filespec	: $BBLOCK [dsc$c_s_bln],	! Address of filespec buffer descriptor.
    bad$gl_func,					! IO function code for $QIO.
    bad$ga_getdvi	: $BBLOCK,			! Address of the $GETDVI item list.
    bad$ga_input_desc	: $BBLOCK [dsc$c_s_bln],	! Generic input descriptor.
    bad$gq_iosb		: VECTOR [4, LONG],		! IO status blocks.
    bad$gl_maxblock,					! Highest user addressable LBN on device.
    bad$ga_mdbsf	: REF $BBLOCK,			! Address of the Manufacturers Detected Bad Sector File.
    bad$gl_mdbsf_ptr,					! Disk address of the MDBSF.
    bad$gl_pagcnt,					! Number of 512 byte pages for 1 transfer.
    bad$ga_sdbsf	: REF $BBLOCK,			! Address of the Software Detected Bad Sector File.
    bad$gl_sdbsf_ptr,					! Pointer to the first available entry in the SDBSF.
    bad$gl_sectors,					! Number of sectors per track.
    bad$gl_sector_siz,					! Size of the physical sector on a drive.
    bad$gl_serialnum,					! Pack serial number.
    bad$gl_status,					! Global status.
    bad$gb_term_count	: BYTE,				! Number of terms used to describe bad block.
    bad$ga_tpb,						! Address of the Test Pattern Buffer.
    bad$gl_tracks,					! Number of tracks per cylinder.
    bad$gl_trnsfr_cnt;					! Number of bytes per transfer.

!
! Define message codes...
!
EXTERNAL LITERAL
    bad$_aligndisk,					! The cartridge is an alignment disk.
    bad$_assign,					! Failed to assign a channel.
    bad$_badvalue,					! Invalid keyword value.
    bad$_devnotblk,					! The device is not block structured.
    bad$_devnotfor,					! The device is not mounted foreign.
    bad$_devrct,					! Device has revector caching enabled.
    bad$_getdvi,					! $GETDVI failed.
    bad$_insvirmem,					! Insufficient virtual memory.
    bad$_invalqual,					! Invalid qualifier.
    bad$_ivblknum,					! Invalid block number.
    bad$_ivblkent,					! Misiing or invalid block entity.
    bad$_lststring,					! Used to list an ascid string.
    bad$_mdbsfcrupt,					! MDBSF is corrupt.
    bad$_mdbsfrfail,					! Failed to read MDBSF.
    bad$_nobadinfo,					! No bad block info.
    bad$_nooutqual,					! No /OUTPUT qualifier.
    bad$_rebldwarn,					! Failed to write enough new MDBSF and SDBSF files.
    bad$_sdbsffull,					! SDBSF is full.
    bad$_sdbsfrfail;					! Failed to read the SDBSF.

!
! Macros:
!
MACRO
    def_tparse_args =
        BUILTIN AP;
        BIND tparse_args = AP : REF $BBLOCK;
        %;


%SBTTL	'State table definitions'
!++
!
! Functional Description:
!
!	The state table provides the definition of legal grammar for the
!	acceptance of bad block information.  The legal forms of bad block
!	information are:
!
!		1.  lbn
!
!		2.  lbn:count
!
!		3.  sector.track.cylinder
!
!		4.  sector.track.cylinder:count
!
!	Each of the elements may be specified in any of the 3 valid radices,
!	OCTAL, DECIMAL, or HEXADECIMAL.  Note that ANY of the elements may be
!	of ANY radix, no restriction is imposed on the user requiring that the
!	same radix be used for all terms.  The default radix is DECIMAL.
!
!	A simple action routine "count_term" is called by TPARSE on our
!	behalf.  It increments a count of the number of terms processed and
!	stores the values taken from the TPARSE control block at the location
!	indicated by "bad$gl_bad_term [.bad$gb_term_count]".  The count will 
!	later be used to convert the bad block information into either logical
!	block number or in physical address form (plus a count value if included).
!
!	An additional state table is also defined, which provides a simple 
!	parsing mechanism for numeric values.  This is used by for parsing the
!	keyword PATTERN's value(s).
!
!--


$INIT_STATE (state_tbl, key_tbl);

$STATE	(,
	((number),, count_term),
	((syntax)));

$STATE	(,
	('.', track_number),
	(TPA$_LAMBDA)
	);

$STATE	(colon,
	(':', blkcnt),
	(TPA$_LAMBDA)
	);

$STATE	(blkend,
	(TPA$_EOS, TPA$_EXIT),
	((syntax)));

$STATE	(blkcnt,
	((number), blkend, count_term),
	((syntax)));

$STATE	(track_number,
	((number),, count_term),
	((syntax)));

$STATE	(,
	('.', cylinder_number),
	((syntax)));

$STATE	(cylinder_number,
	((number), colon, count_term),
	((syntax)));
!
! The following portion of the state table is shared to allow the parsing
! of integer numbers of various radices.
!
$INIT_STATE (number_tbl, numkey_tbl);

$STATE	(,
	((number),, count_term),
	((bad_val)));

$STATE	(number,
	(TPA$_DECIMAL, TPA$_EXIT),
	('%'));

$STATE	(,
	('d', decnum),
	('D', decnum),
	('x', hexnum),
	('X', hexnum),
	('o', octnum),
	('O', octnum));

$STATE	(octnum,
	(TPA$_OCTAL, TPA$_EXIT));

$STATE	(decnum,
	(TPA$_DECIMAL, TPA$_EXIT));

$STATE	(hexnum,
	(TPA$_HEX, TPA$_EXIT));

$STATE	(bad_val,
	(TPA$_SYMBOL,,	bad_value),
	(TPA$_STRING,,	bad_value),
	(TPA$_LAMBDA,,	bad_value),
	(TPA$_ANY,,	bad_value),
	(TPA$_EOS,,	bad_value)
	);

$STATE	(syntax,
	(TPA$_SYMBOL,,	syntax_err),
	(TPA$_STRING,,	syntax_err),
	(TPA$_LAMBDA,,	syntax_err),
	(TPA$_ANY,,	syntax_err),
	(TPA$_EOS,,	syntax_err)
	);


%SBTTL 'bad$init -- Initialization Procedure'

GLOBAL ROUTINE bad$init : NOVALUE =
!++
!
! Functional Description:
!
!    This procedure processes the qualifiers specified/defaulted in the command
!    line.  The device is validated and an IO channel established.  If an output
!    file is requested, it is opened at this time.
!
! Calling Sequence:
!
!    bad$init ();				! Parse the command line and
!						! process/initialize structures.
!
! Implicit Inputs:
!
!    Pointers to control and data structures.
!
! Implicit Outputs:
!
!    All of the global control and data structures have been allocated and
!    initialized.
!
!--
BEGIN

bad$gl_context [ctx_v_init] = TRUE;			! Flag initialization phase.

!
! Initialize descriptors.
!
CH$FILL (0, dsc$c_s_bln, bad$ga_comnd_line);
CH$FILL (0, dsc$c_s_bln, bad$ga_device);
CH$FILL (0, dsc$c_s_bln, bad$ga_input_desc);
CH$FILL (0, dsc$c_s_bln, bad$ga_filespec);
bad$ga_comnd_line [dsc$b_class] = dsc$k_class_d;	! Command line descriptor.
bad$ga_device [dsc$b_class] = dsc$k_class_d;		! Device name descriptor.
bad$ga_input_desc [dsc$b_class] = dsc$k_class_d;	! Input line descriptor.
bad$ga_filespec [dsc$b_class] = dsc$k_class_d;		! Output file spec descriptor.

IF bad$sta_init NEQ 0					! Are we executing Stand Alone or under VMS?
THEN    bad$sta_init ();				! Stand Alone -- perform required initialization.

!
! Save the command line and get the device spec.
!
CLI$GET_VALUE (command_lin, bad$ga_comnd_line);		! Get a local copy of the command line.
IF bad$str_trim NEQ 0					! Trim the command line if we are stand alone.
THEN    bad$str_trim (bad$ga_comnd_line);

CLI$GET_VALUE (device, bad$ga_device);			! Copy the device name.
IF bad$str_trim NEQ 0					! Trim the device specification if we are stand alone.
THEN    bad$str_trim (bad$ga_device);

IF NOT (bad$gl_status =
        $GETDVIW (DEVNAM = bad$ga_device,		! Get the device specifics.
                  ITMLST = bad$ga_getdvi))
THEN							! If not obtainable -- STOP!
    SIGNAL_STOP (bad$_getdvi, 1, bad$ga_device, .bad$gl_status);

IF .bad$gl_devclass NEQ dc$_disk			! Is this a valid device type?
THEN							! If not -- STOP!
    SIGNAL_STOP (bad$_devnotblk, 1, bad$ga_device);

IF .bad$gl_devchar [dev$v_rct]				! Revector cached device?
THEN							! If so, STOP, don't waste time
    SIGNAL_STOP (bad$_devrct, 1, bad$ga_device);	! essentially doing a NOP!

IF NOT .bad$gl_devchar [dev$v_for]			! Device must be mounted /FOREIGN
AND bad$sta_init EQL 0					! (while executing under VMS),
THEN							! because we do not have enough
    SIGNAL_STOP (bad$_devnotfor, 1, bad$ga_device);	! access privilege otherwise.

IF NOT (bad$gl_status =
        $ASSIGN (DEVNAM = bad$ga_device,		! If no IO channel, we must STOP!
                 CHAN = bad$gl_chan))
THEN
    SIGNAL_STOP (bad$_assign, 1, bad$ga_device, .bad$gl_status);

IF bad$validate_pack NEQ 0				! Are we executing Stand Alone?
THEN    bad$validate_pack ();				! Yes, set the Volume Valid bit in the UCB.

bad$gq_devnam [dsc$w_length] = .bad$gl_devnam;		! Build the device name descriptor.
bad$gq_devnam [dsc$b_dtype] = dsc$k_dtype_t;		! Data type is text.
bad$gq_devnam [dsc$b_class] = dsc$k_class_d;		! Dynamic descriptor.
bad$gq_devnam [dsc$a_pointer] = bad$ga_devnam;		! Buffer address.

IF .bad$gl_maxblock GTR bad$k_nltmaxblk			! Is this a last track device?
THEN 
    BEGIN
    bad$gl_context [ctx_v_ltdevice] = TRUE;		! Default the device type to "last track"
    bad$gb_block_fact = (.bad$gl_tracks *		! Compute blocking factor.
		         .bad$gl_cylinders *
		         .bad$gl_sectors) /
		         .bad$gl_maxblock;
    bad$gl_mdbsf_ptr = .bad$gl_maxblock -		! Set beginning address of last track.
                       .bad$gl_sectors /
                       .bad$gb_block_fact;
    bad$gl_sector_siz = bad$k_page_size / .bad$gb_block_fact;	! Compute the sector size (in bytes).
    bad$gl_bytes_trk = .bad$gl_sectors * .bad$gl_sector_siz;	! Compute number of bytes per track.
    bad$gl_bytes_cyl = .bad$gl_bytes_trk * .bad$gl_tracks;	! Compute number of bytes per cylinder.
    bad$gl_trnsfr_cnt = MINU (.bad$gl_bytes_cyl,		! Select largest transfer value.
                              bad$k_max_xfer_cnt);
    END
ELSE
    bad$gl_trnsfr_cnt = bad$k_max_xfer_cnt;		! Non last track device, make large transfers.
        
bad$gl_pagcnt = .bad$gl_trnsfr_cnt / bad$k_page_size;	! Compute memory allocation size in pages.

%SBTTL    'Process qualifiers'
!++
!
! Process qualifiers.
!
!    This portion of the procedure sets/clears the various bits in the
!    context bits according to the presence of the various qualifiers
!    and keywords.
!
!    The actual processing of the qualifiers/keywords will be performed
!    selectively below.
!
!--
bad$gl_context [ctx_v_badblocks] =	CLI$PRESENT (bad_blocks);	! /BAD_BLOCKS
bad$gl_context [ctx_v_exercise] =	CLI$PRESENT (exercise);		! /EXERCISE
bad$gl_context [ctx_v_keep] =		CLI$PRESENT (keep);		! /[NO]EXERCISE=KEEP
bad$gl_context [ctx_v_log] =		CLI$PRESENT (log);		! /LOG
bad$gl_context [ctx_v_output] =		CLI$PRESENT (output);		! /OUTPUT
bad$gl_context [ctx_v_retry] =		CLI$PRESENT (retry);		! /RETRY
bad$gl_context [ctx_v_show] =		CLI$PRESENT (show_qual);	! /SHOW

!
! END of generic qualifier/keyword processing...
!

!
!    If the device is a last track device, then allocate the MDBSF and SDBSF
!    buffers and attempt to obtain the MDBSF.  If the device is a non last
!    track device, simply allocate the SDBSF buffer.
!
!    (The SDBSF is only preserved if so directed by the KEEP keyword)
!
bad$gl_func = IO$_READLBLK;				! Set default IO function code.
IF .bad$gl_context [ctx_v_ltdevice]
THEN
    BEGIN
    bad$alloc_mem (bad$k_page_size * 2, bad$ga_mdbsf);	! Allocate the detected bad sector file buffers.
    bad$ga_sdbsf = .bad$ga_mdbsf + bad$k_page_size;	! Seperate the buffers.
    get_mdbsf ();					! Obtain a valid copy of the MDBSF.
    END
ELSE
    bad$alloc_mem (bad$k_page_size, bad$ga_sdbsf);	! Allocate a single buffer.

!
! *							  *
!*** Process individual qualifiers for specific actions. ***
! *							  *
!
SELECT TRUE OF SET


%SBTTL    'Process /OUTPUT qualifier'
!++
!
! Process /OUTPUT qualifier.
!
!    If requested get the file specified (or defaulted) by the user and
!    the output file.  The default specification of /SHOW=AFTER is also
!    set (just in case it wasn't specified in the command line).
!
!    The default is /NOOUTPUT.
!
!--
[.bad$gl_context [ctx_v_output]]:
    BEGIN
    CLI$GET_VALUE (output, bad$ga_filespec);		! Get the filespec if supplied.
    bad$prepare_report ();				! Open the file.
    bad$gl_context [ctx_v_show_after] = TRUE;		! Default to /SHOW=AFTER if it is not supplied.

    END;    ! of /OUTPUT processing


%SBTTL	'Process /SHOW qualifier'
!++
!
! Process /SHOW qualifier.
!
!    This procedure processes the /SHOW qualifier which will produce the
!    following actions:
!
!	1.  If /SHOW=BEFORE is specified the listing is produced from the
!	    the current bad block file(s) as they exist in our buffers.
!	    The AFTER qualifier value context switch will be toggled by a
!	    call to CLI$PRESENT.
!
!	2.  If /SHOW or /SHOW=AFTER is specified the the context bit
!	    "show_after" will be set, resulting in the contents of the bad
!	    block file(s) being listed at the conclusion of processing.
!
!--
[.bad$gl_context [ctx_v_show]]:
    BEGIN						! If /SHOW is specified without /OUTPUT,
    IF NOT .bad$gl_context [ctx_v_output]		! then -- STOP!  We do not have a valid
    THEN						! output file to write the report to!
        SIGNAL_STOP (bad$_nooutqual, 0, bad$_lststring, 1, bad$ga_comnd_line);

    IF (bad$gl_context [ctx_v_show_before] = CLI$PRESENT (before))
    THEN						! Should we produce a report before
        BEGIN						! testing the media?  If so, then
        IF .bad$gl_context [ctx_v_ltdevice]		! obtain a copy of the old SDBSF,
        THEN    get_sdbsf ()				! produce the report, and toggle the
        ELSE    bad$gl_context [ctx_v_nlt_sdbsf] = get_nlt_sdbsf (); ! show_after context flag.
        IF .bad$gl_context [ctx_v_ltdevice] OR .bad$gl_context [ctx_v_nlt_sdbsf]
        THEN    bad$produce_report ();	
        bad$gl_context [ctx_v_show_after] = CLI$PRESENT (after);
        END
    ELSE
        bad$gl_context [ctx_v_show_after] = TRUE;	! Otherwise the default is show_after.
    
    END;    ! of /SHOW processing


%SBTTL	'Process the KEEP keyword'
!++
!
! Process the KEEP keyword ** ALWAYS PERFORMED **.
!
!    This portion of the procedure will determine whether the contents of the
!    old SDBSF should be preserved.
!
!    The default is dependent on the EXERCISE context.  If the context is
!    to EXERCISE the device, the default is NOT to preserve the old SDBSF
!    contents.  This allows the user to purge the allocation of user supplied
!    bad blocks from the SDBSF.  IF the context is NOEXERCISE, then KEEP is
!    implicit (we must protect and preserve the contents of the SDBSF, since
!    it would be too easy to blow away the SDBSF in this mode), resulting in a
!    potentially useless piece of media (at least until it was analyzed again).
!
!--
[ALWAYS]:

    BEGIN
    IF .bad$gl_context [ctx_v_keep] OR			! Should we preserve the old SDBSF?
    (NOT .bad$gl_context [ctx_v_exercise] AND NOT .bad$gl_context [ctx_v_show_before])
    THEN
        IF .bad$gl_context [ctx_v_ltdevice]
        THEN    get_sdbsf ()				! Yes, obtain a valid copy of the SDBSF.
        ELSE    get_nlt_sdbsf ()			! Yes, obtain a valid copy of the non last track SDBSF.
    ELSE
        init_sdbsf ();					! No, create a new copy of the SDBSF.

    END;    ! of KEEP keyword processing


%SBTTL	'Process the /BAD_BLOCKS qualifier'
!++
!
! Process the /BAD_BLOCKS qualifier.
!
!    This qualifier may have an associated set of bad block information.
!    Any combination of the valid bad block information may be specified
!    (in a comma seperated list, utilizing any combination of radix directives).
!    The default radix is DECIMAL.
!
!    Bad block information formats:
!
!	none			- If no input is specified with the /BAD_BLOCKS
!				  qualifier, the utility will prompt the user
!				  for the required information.
!
!	lbn			- Allocate a single block to the bad block file.
!
!	lbn:count		- Allocate a range of contiguous blocks starting
!				  at lbn to the bad block file.
!
!	sec.trk.cyl		- Allocate a single physical sector to the bad
!				  block file.
!
!	sec.trk.cyl:count	- Allocate a range of contigous physical sectors 
!				  to the bad block file.
!
!    Depending on whether this is a last track or non last track device the bad
!    block information will be converted to the required format and entered into
!    the SDBSF, if it does not already exist in either the MDBSF or the SDBSF.
!
!--
[.bad$gl_context [ctx_v_badblocks]]:
    BEGIN
    LOCAL
        value_present;

    value_present = FALSE;
    WHILE bad$gl_status = CLI$GET_VALUE (bad_blocks, bad$ga_input_desc) DO 
        BEGIN						! Bad blocks have been specified
        value_present = TRUE;				! in the command line.
        process_badblocks ();				! Process the current bad block set.
        END;

    IF NOT .value_present				! Should we prompt for the bad blocks?
    THEN						! Yes.
        BEGIN
        bad$gl_context [ctx_v_interactive] = TRUE;	! Allow duplicate block messages to be displayed.
        WHILE bad$gl_status = LIB$GET_INPUT (bad$ga_input_desc, prompt)
        DO
            BEGIN					! Read a bad block set from the user.
            IF .bad$gl_status EQL RMS$_EOF		! Has he terminated the input?
            THEN EXITLOOP;				! Yes -- move on to the next phase.
            process_badblocks ();			! No, process the bad block set.
            END;
        END;
    bad$gl_context [ctx_v_interactive] = FALSE;		! Disallow duplicate block messages beyond here.

    END;  ! of /BAD_BLOCKS processing


%SBTTL    'Process /EXERCISE qualifier'
!++
!
! Process /EXERCISE qualifier.
!
!    If the device is supposed to be analyzed, then allocate the data
!    and test pattern buffers.
!
!    Check to see if the user requested a completion log of the number of
!    bad blocks detected.
!
!    If the user supplied a test pattern, then obtain a copy of it (upto
!    an OCTAWORD (128 bits) of pattern), which will be stored in the vector
!    'bad$gl_bad_term'.
!
!	**********************************************************************
!	***				N O T E				   ***
!	*** This MUST be the last operation performed on the vector before ***
!	*** returning to the driver, since the routine 'bad$init_buffers'  ***
!	*** expects the vector to contain the user supplied test pattern!  ***
!	**********************************************************************
!
!    The default is /NOEXERCISE.
!
!--

[.bad$gl_context [ctx_v_exercise]]:
    BEGIN
    bad$gl_context [ctx_v_exercise_full] = CLI$PRESENT (full);	! Set/Clear the FULL context bit.
    bad$gl_context [ctx_v_nlt_sdbsf] = true;			! A new/updated SDBSF will be written to the medium.

    IF (bad$gl_context [ctx_v_pattern] = CLI$PRESENT (pattern))	! Set/Clear the PATTERN context bit.
    THEN
        get_pattern ();						! Process the user supplied test pattern(s).

    bad$alloc_mem (.bad$gl_pagcnt * bad$k_page_size * 2,
               bad$ga_bufadr [0]);				! Allocate the data buffers.

    bad$ga_bufadr [1] =	.bad$ga_bufadr [0] +			! Seperate them into distinct entities.
			.bad$gl_pagcnt * 
			bad$k_page_size;			

    bad$alloc_mem (bad$k_page_size, bad$ga_tpb);		! Allocate the Test Pattern Buffer.

    END;  !of /EXERCISE processing

TES;    ! of Specific Qualifier processing.

bad$gl_context [ctx_v_init] = FALSE;			! Flag end of initialization phase.

END;	! Of GLOBAL ROUTINE bad$init


%SBTTL	'bad$alloc_mem -- Allocate Memory'
GLOBAL ROUTINE	bad$alloc_mem (byte_count, return_address) : NOVALUE =
!++
!
! Functional Description:
!
!    This routine will allocate page(s) of memory.  If an error occurs while
!    attempting to allocate the memory, the error will be signalled FATAL.
!
! Inputs:
!
!    byte_count		VALUE	Number of bytes to allocate.
!
! Outputs:
!
!    return_address	ADDRESS	Address of the location to store the 
!				beginning address of allocated memory.
!
! Side Effects:
!
!    If there is an error in allocating memory, this procedure will terminate
!    the analysis via a SIGNAL_STOP.
!
!--
BEGIN
MAP
    return_address : REF $BBLOCK;			! Point to return address.

LOCAL
    addr_vec : VECTOR [2, LONG],
    page_count;

IF (page_count = .byte_count / bad$k_page_size) LSS 1
THEN    page_count = 1;

IF NOT (bad$gl_status = $EXPREG (PAGCNT = .page_count,
			  RETADR = addr_vec))		! Allocate the requested amount
THEN							! of storage.
    SIGNAL_STOP (bad$_insvirmem, 0, .bad$gl_status);

.return_address = .addr_vec [0];

END;    ! Of GLOBAL ROUTINE bad$alloc_mem


%SBTTL	'get_mdbsf -- Get a valid copy of the MDBSF'
ROUTINE	get_mdbsf : NOVALUE =
!++
!
! Functional Description:
!
!    Obtain a valid copy of the Manufacturer's Detected Bad Sector File.
!
! Implicit Inputs:
!
!    bad$ga_mdbsf	the address of the MDBSF buffer.
!    bad$ga_sdbsf	the address of the SDBSF buffer.
!    bad$gl_mdbsf_ptr	the block number of the first block of the last track.
!
! Side Effects:
!
!    If unable to read the MDBSF, we will recreate BOTH the MDBSF and SDBSF
!    ONLY if we are going to exercise the medium and the user specified NOKEEP.
!    If he specified /EXERCISE=KEEP, we will abort the analysis.
!
!    If the request was something like /NOEXERCISE /OUTPUT we will attempt to
!    read a valid non last track format SDBSF.  Failing this we will
!    SIGNAL_STOP to inform the user of the situation.  If we were successful
!    in reading the non last track format SDBSF, we will convert the analysis
!    context to non last track by clearing the [ctx_v_ltdevice] context bit.
!    Thus allowing a listing to be produced.
!
!    In order to be able to exercise the media or update the bad block file,
!    the user must execute ANALYZE/MEDIA explicitly specifing /EXERCISE=NOKEEP.
!    This will convert the device to last track format and implies that the
!    user knows that data will be lost and the bad block files will be rebuilt.
!
!--
BEGIN
LOCAL
    first_found,
    value_present;

first_found = FALSE;					! Indicator for buffer usage (dup copies of MDBSF).
value_present = FALSE;					! Indicate whether we found a valid MDBSF.
INCR block FROM 0 TO 9 DO				! Search the first 10 blocks of the
    BEGIN						! last track for the MDBSF.  Once found
    IF bad$gl_status = bad$sync_io (IF NOT .first_found	! a second copy is obtained to validate
                            THEN    .bad$ga_mdbsf	! the contents (since no checksum is
                            ELSE    .bad$ga_sdbsf,	! available).
                            bad$k_page_size,
                            .bad$gl_mdbsf_ptr + .block)
    THEN
        BEGIN
        IF NOT .first_found				! If this is the first time an MDBSF
        THEN						! was found, check that it is not full,
            BEGIN					! switch to second buffer for verfication.
            IF .(.bad$ga_mdbsf + (bad$k_page_size - 4)) EQL -1
            THEN    first_found = TRUE;			! Indicate that we found one.
            END
        ELSE
            BEGIN					! Validate the MDBSF copies,
            IF CH$EQL (bad$k_page_size, .bad$ga_mdbsf,	! they should be identical.
            bad$k_page_size, .bad$ga_sdbsf,0)
            THEN
                BEGIN
                value_present = TRUE;			! We have a valid copy of the MDBSF,
                EXITLOOP;				! go finish the validation of the
                END;					! pack.
            END;
        END;
    END;

IF NOT .value_present					! If we did not find a valid MDBSF,
THEN							! see if we can either rebuild a new
    IF NOT recover_dbsfs ()				! set of bad block flies or recover 
    THEN						! a non lasttrack SDBSF.  If we can't,
        SIGNAL_STOP (bad$_mdbsfrfail, 1, bad$ga_device);! then abort the analysis.

IF NOT .bad$gl_context [ctx_v_ltdevice]			! Did we recover a non last track SDBSF?
THEN
    RETURN;						! Yes, bypass the pack validation.

!
! Validate the pack...
!
IF .bad$ga_mdbsf [ltk_w_cartridge] EQLU %X'FFFF'	! Assure that it's not an
THEN							! alignment cartridge.
    SIGNAL_STOP (bad$_aligndisk, 1, bad$ga_device)
ELSE
    BEGIN						! Has the header been corrrupted?
    IF (.bad$ga_mdbsf [ltk_l_serial_number] EQL 0) AND	! It should have a serial number
       (.bad$ga_mdbsf [ltk_w_unused] NEQ 0)		! followed by a zero word, and the
    THEN						! cartridge id (0's-data packs, 1's-diag pack)
        IF .bad$gl_context [ctx_v_exercise]		! in the header.
        THEN
            rebuild_dbsfs ()				! Rebuild the MDBSF and SDBSF if we can.
        ELSE
            SIGNAL_STOP (bad$_mdbsfcrupt, 1, bad$ga_device);
    END;

END;    ! of ROUTINE get_mdbsf


%SBTTL	'recover_dbsfs -- Attempt to rebuild/recover an SDBSF'
ROUTINE	recover_dbsfs =
!++
!
! Functional Description:
!
!    A valid MDBSF was not found.  Check to see if the analysis context
!    will allow either of the following actions to be performed.
!
!     1. Attempt to rebuild both the MDBSF and the SDBSF if we are going to
!        exercise the medium and not save the old bad block data.
!
!     2. Attempt to find the "old" non last track format SDBSF if the medium
!        is not going to be exercised and only a listing type of action
!        was requested.  If successful, then we will change the context to
!        non last track.
!
! Routine Value:
!
!    TRUE	If we were successful in rebuilding the MDBSF and SDBSF or
!		in locating the "old" format SDBSF and changing the analysis
!		context to non last track.
!
!    FALSE	If we could not (for one of several reasons) rebuild the 
!		the bad block files.
!
!--
BEGIN
LOCAL
    return_status;

return_status = FALSE;					! Assume we can't rebuild the bad block files.
IF .bad$gl_context [ctx_v_exercise]			! Check the context bits to see if we can
AND NOT .bad$gl_context [ctx_v_keep]			! attempt to rebuild them.
THEN
    BEGIN
    rebuild_dbsfs ();					! We can try ...
    return_status = TRUE;				! We have written them to the medium.
    END
ELSE
    BEGIN						! Otherwise, if we aren't exercising the
    IF NOT .bad$gl_context [ctx_v_exercise]		! medium and no attempt will be made to
    AND NOT .bad$gl_context [ctx_v_badblocks]		! modify a non last track format SDBSF
    THEN						! if one is found, then go look for one.
        IF get_nlt_sdbsf ()
        THEN
            BEGIN
            bad$gl_context [ctx_v_ltdevice] = FALSE;	! Found one, change to context.
            return_status = TRUE;			! Set the status to allow us to continue.
            END;
    END;

RETURN .return_status;

END;    ! of ROUTINE recover_dbsfs


%SBTTL	'rebuild_dbsfs -- Rebuild the MDBSF and SDBSF on last track devices'
ROUTINE	rebuild_dbsfs : NOVALUE =
!++
!
! Functional Description:
!
!    This procedure will rebuild the MDBSF and SDBSF on last track devices.
!    The context of the analysis MUST BE EXERCISE and NOKEEP.  This is to
!    assure that no data will be unintentionally lost due to the use of the
!    last track for the detected bad block files data.
!
! Implicit Inputs:
!
!    Global Data.
!
! Implicit Outputs:
!
!    The MDBSF and SDBSF will be recreated on the medium as empty files.
!
! Side Effects:
!
!    If we did not manage to write the new MDBSF and SDBSF onto at least
!    half of the last track, we will issue a diagnostic to the user warning
!    him of the unreliable nature of the last track data.
!
!--
BEGIN
LOCAL
    cnt : INITIAL (0);

bad$gl_func = IO$_WRITELBLK;				! Set up for writes.
CH$FILL (-1, bad$k_page_size, .bad$ga_mdbsf);		! Clean the buffer out.
bad$ga_mdbsf [ltk_l_serial_number] = bad$gl_serialnum = 1; ! Default Serial Number.
bad$ga_mdbsf [ltk_w_unused] = 0;			! Clear unused field.
bad$ga_mdbsf [ltk_w_cartridge] = 0;			! Define it as a Data Cartridge.

INCR offset FROM 0 TO .bad$gl_sectors / .bad$gb_block_fact DO
    IF NOT (bad$gl_status = bad$sync_io (.bad$ga_mdbsf,
					 bad$k_page_size,
					 .bad$gl_mdbsf_ptr + .offset))
    THEN
        cnt = .cnt + 1;

IF .cnt GEQ (.bad$gl_sectors / .bad$gb_block_fact) / 2	! If we did not manage to write at
THEN							! least half of the last track,
    SIGNAL (bad$_rebldwarn, 1, bad$ga_device);		! send out a warning...

END;    ! of ROUTINE rebuild_dbsfs


%SBTTL	'get_sdbsf -- Get a valid copy of the SDBSF'
ROUTINE	get_sdbsf : NOVALUE =
!++
!
! Functional Description:
!
!    Obtain a valid copy of the Software Detected Bad Sector File.
!
! Implicit Inputs:
!
!    bad$ga_mdbsf	the address of the MDBSF buffer.
!    bad$ga_sdbsf	the address of the SDBSF buffer.
!    bad$gl_mdbsf_ptr	the block number of the first block on the last track.
!    bad$gl_sdbsf_ptr	the address of the first free entry in the SDBSF buffer.
!
! Side Effects:
!
!    If we are unable to read the SDBSF, if the SDBSF is FULL, or if it does
!    not correspond the MDBSF we will stop the analysis by issuing a FATAL
!    diagnostic.
!
!--
BEGIN
LOCAL
    value_present;

value_present = FALSE;					! The MDBSF was found and validated,
							! now look for the SDBSF.
INCR block FROM 10 TO .bad$gl_sectors / .bad$gb_block_fact - 1 DO
    BEGIN						! Search the remainder of the last track
    IF bad$gl_status = bad$sync_io (.bad$ga_sdbsf,	! and validate the SDBSF's header.
                                    bad$k_page_size,
                                    .bad$gl_mdbsf_ptr + .block)
    THEN
        BEGIN
        IF .bad$ga_sdbsf [ltk_l_serial_number] EQL	! Validate the serial numbers.
           .bad$ga_mdbsf [ltk_l_serial_number]
        THEN 
            BEGIN
            value_present = TRUE;			! They matched, the rest of the
            EXITLOOP;					! header should also be good.
            END;
        END;
    END;

IF NOT .value_present
THEN
    SIGNAL_STOP (bad$_sdbsfrfail, 1, bad$ga_device);

!
! Point to the first free entry in the SDBSF.
!
value_present = FALSE;
INCR entry FROM .bad$ga_sdbsf TO .bad$ga_sdbsf + bad$k_page_size - 4 BY 4
DO
    BEGIN
    IF  ..entry EQL -1					! An entry of -1 implies 
    THEN						! the end of the bad block
        BEGIN						! information.
        value_present = TRUE;
        bad$gl_sdbsf_ptr = .entry;			! Set the address into
        EXITLOOP;					! the global pointer and
        END;						! return.
    END;

IF NOT .value_present					! If the bad block file
THEN							! is full, issue a diagnostic
    SIGNAL_STOP (bad$_sdbsffull, 1, bad$ga_device);	! and quit.

END;    ! of ROUTINE get_sdbsf


%SBTTL	'get_nlt_sdbsf -- Get a non last track SDBSF'
ROUTINE	get_nlt_sdbsf =
!++
!
! Functional Description:
!
!    This is a non last track device, so search the last 256 blocks of the
!    device for the SDBSF.  Once its found validate it by checksumming (shared
!    routine from F11AACP) and verification of the fixed value fields of the
!    header.
!
! Implicit Inputs:
!
!    bad$gl_maxblock	the total number of blocks on the device.
!    bad$ga_sdbsf	the address of the SDBSF buffer.
!
! Side Effects:
!
!    If there is no SDBSF on the medium, an informational message will be issued
!    and a new SDBSF will be created.
!
!--
BEGIN
LOCAL
    value_present;

value_present = FALSE;
DECR block FROM .bad$gl_maxblock TO .bad$gl_maxblock - 256 DO
    BEGIN
    bad$gl_status = bad$sync_io (.bad$ga_sdbsf,
                                  bad$k_page_size,
                                 .block);
    IF .bad$gl_status
    THEN 
        BEGIN
        IF CHECKSUM2 (.bad$ga_sdbsf, bad$k_page_size - 2)	! Sum of the entries, stored in the last word.
        AND .bad$ga_sdbsf [nlt_b_cntfldsiz] EQL nlt_k_cntfldsiz	! Size of the count field in bytes.
        AND .bad$ga_sdbsf [nlt_b_adrfldsiz] EQL nlt_k_adrfldsiz	! Size of the address field in bytes.
        AND .bad$ga_sdbsf [nlt_b_usedbbdsc] LEQ nlt_k_available	! Number of used bad block descriptor
        THEN							! (the count is in WORDs!)
            BEGIN
            value_present = TRUE;				! We found one, return.
            EXITLOOP;
            END;
        END;
    END;

IF NOT .value_present						! If the SDBSF is not available, issue
THEN								! a diagnostic and create a new one.
    BEGIN
    SIGNAL (bad$_nobadinfo, 1, bad$ga_device);
    init_sdbsf ();
    END;

!
! Point to the first free entry in the SDBSF before returning.
!
bad$gl_sdbsf_ptr = .bad$ga_sdbsf + nlt_k_headersiz +
                  (.bad$ga_sdbsf [nlt_b_usedbbdsc] * 2);

RETURN .value_present;

END;    ! of ROUTINE get_nlt_sdbsf


%SBTTL	'init_sdbsf -- Create and initialize the header of the SDBSF'
ROUTINE	init_sdbsf : NOVALUE =
!++
!
! Functional Description:
!
!    This procedure will initialize the contents of a new SDBSF.  The pointer
!    to the first free entry will also be set.
!
! Implicit Inputs:
!
!    bad$ga_sdbsf	the address of the SDBSF buffer.
!
! Side Effects:
!
!    The header fields of the selected format bad block buffer are initialized
!    to the statically defined values.
!
!--
BEGIN

IF .bad$gl_context [ctx_v_ltdevice]
THEN
    BEGIN	! Last track device (copy static fields from the MDBSF).
    bad$ga_sdbsf [ltk_l_serial_number] = .bad$ga_mdbsf [ltk_l_serial_number];
    bad$ga_sdbsf [ltk_w_unused] = .bad$ga_mdbsf [ltk_w_unused];
    bad$ga_sdbsf [ltk_w_cartridge] = .bad$ga_mdbsf [ltk_w_cartridge];
    bad$gl_sdbsf_ptr = .bad$ga_sdbsf + ltk_k_headersiz;
    END
ELSE
    BEGIN	! Non Last track device (use static defaults).
    bad$ga_sdbsf [nlt_b_cntfldsiz] = nlt_k_cntfldsiz;	! Fill in the count field size.
    bad$ga_sdbsf [nlt_b_adrfldsiz] = nlt_k_adrfldsiz;	! Fill in the address field size.
    bad$ga_sdbsf [nlt_b_usedbbdsc] = 0;			! No descriptors used.
    bad$ga_sdbsf [nlt_b_available] = nlt_k_available;	! Total number of available descriptors.
    bad$gl_sdbsf_ptr = .bad$ga_sdbsf + nlt_k_headersiz;
    END;

END;    ! of ROUTINE init_sdbsf


%SBTTL	'get_pattern -- Process user supplied test pattern(s)'
ROUTINE	get_pattern : NOVALUE =
!++
!
! Functional Description:
!
!    Process the user supplied test pattern(s).
!
! Implicit Inputs:
!
!    bad$gl_bad_term		the vector into which the pattern(s)
!				will be loaded.
!
!    bad$gb_term_count		the number of longwords which make
!				up the pattern.
!
! Side Effects:
!
!    If the user neglects to supply at least one pattern, the context bit
!    (ctx_v_pattern) will be cleared, and the default pattern(s) will be used.
!
!--
BEGIN
bad$gl_context [ctx_v_pattern] = FALSE;			! Assume the default.
bad$gl_bad_term [0] = bad$gl_bad_term [1] = 0;		! Clear the vector.
bad$gl_bad_term [2] = bad$gl_bad_term [3] = 0;		! 
bad$gb_term_count = 0;					! Clear the term count.

WHILE CLI$GET_VALUE (pattern, bad$ga_input_desc) DO	! Process all supplied values.
    BEGIN						! 
    bad$gl_context [ctx_v_pattern] = TRUE;		! Flag that there are valid patterns available.
    parse_value (number_tbl, numkey_tbl);		! Parse the string into a value.
    END;

END;    ! of ROUTINE get_pattern


%SBTTL	'process_badblocks -- Process user supplied bad block(s)'
ROUTINE	process_badblocks =
!++
!
! Functional Description:
!
!    Process the user supplied bad block information.  This is accomplished
!    by parsing the bad block(s) supplied by the user, validating them
!    against the device geometry, then if they are not already recorded in
!    a bad block file, they will be inserted.
!
! Implicit Inputs:
!
!    bad$gl_bad_term		the vector containing the terms used to describe
!				the bad block(s).
!    bad$gb_term_count		the number of term used to describe the bad
!				block(s).
!
! Side Effects:
!
!    If the block(s) specified are not already recorded in the bad block file(s)
!    they will be added.  If there are duplicate bad blocks specified, they will
!    cause a warning message to be displayed.
!
!    If we are prompting for the bad blocks, then if an invalid block number or
!    grammar error is encountered, we will issue a diagnostic, disregard the
!    last entry and prompt again.  If not prompting for bad blocks (they were
!    specified in the command), then we will issue a FATAL error diagnostic,
!    terminating the analysis.
!
!--
BEGIN
OWN
    hibound,
    lobound;

hibound = lobound = 0;					! Assure we start out fresh.
bad$gb_term_count = 0;					! Reset the count of terms
bad$gl_bad_term [0] = bad$gl_bad_term [1] = 0;		! and each of the terms also.
bad$gl_bad_term [2] = bad$gl_bad_term [3] = 0;
parse_value (state_tbl, key_tbl);			! Parse the bad block info.

IF .bad$gb_term_count EQL 0				! Did we encounter a syntax error?
THEN							! Yes, so return for more input
    RETURN FALSE;					! (if any) to process.
!
! Validate the address(es).  If validation fails, the validation routine
! will depending on the processing context (interactive or command)
! signal an error or halt execution of the image via a modification of
! the message severity (set to STS$K_SEVERE).
!
IF .bad$gb_term_count GEQ 3				! Is the address in physical
THEN							! or logical address format?
    BEGIN
    IF NOT val_phy_adr (.bad$gl_bad_term [0],		! Sector	
			.bad$gl_bad_term [1],		! Track
			.bad$gl_bad_term [2],		! Cylinder
			.bad$gl_bad_term [3])		! Count
    THEN
        RETURN FALSE;

    lobound = bad$cvt_phy_log (.bad$gl_bad_term [0],	! This is a valid address, form
                               .bad$gl_bad_term [1],	! its equivalent logical block
                               .bad$gl_bad_term [2]);	! number.

    hibound = .lobound + .bad$gl_bad_term [3] - 1;
    END
ELSE
    BEGIN
    IF NOT val_log_adr (.bad$gl_bad_term [0],		! Logical Block Number
			.bad$gl_bad_term [1])		! Count
    THEN
        RETURN FALSE;

    lobound = .bad$gl_bad_term [0];			! Set the address bounds.
    hibound = .lobound + .bad$gl_bad_term [1] - 1;
    END;

IF .hibound LSS .lobound				! Prevent mess up for one block,
THEN							! the hi must be same as low.
    hibound = .lobound;
!
! At this point we are satisfied with the addresses specified.  Determine
! if the media is last track or non last track and look for a duplicate block.
! If no duplicate is found, the block(s) will be entered in the SDBSF.
!
IF .bad$gl_context [ctx_v_ltdevice]
THEN
    bad$check_ltk (.lobound, .hibound)
ELSE
    bad$check_nlt (.lobound, .hibound);

RETURN TRUE;

END;    !of ROUTINE process_badblocks


%SBTTL	'parse_value -- Parse and process user supplied value(s)'
ROUTINE parse_value (state, key) : NOVALUE =
!++
!
! Functional Description:
!
!    This routine is responsible for parsing user supplied values which
!    are used by /BAD_BLOCKS, /EXERCISE=PATTERN, etc..
!
! Inputs:
!
!    state	adr	address of the state table to use.
!    key 	adr	address of the key table to use.
!
! Implicit Inputs:
!
!    The address of the TPARSE control block.
!    
!    The descriptor pointer to the string to be parsed (bad$ga_input_desc).
!
! Implicit Outputs:
!
!    The information vector bad$gl_bad_term [x] will contain the user
!    supplied data values.
!
!--
BEGIN
LOCAL
    tparse_blk	: BLOCK [TPA$K_LENGTH0, BYTE];		! TPARSE control block.

IF bad$str_trim NEQ 0					! Trim the input line if we are stand alone
THEN    bad$str_trim (bad$ga_input_desc);		! to preclude erroneous errors during the parse.

tparse_blk [tpa$l_count] = TPA$K_COUNT0;		! Initial longword count.
tparse_blk [tpa$l_options] = TPA$M_ABBREV;		! Allow abbreviations.
tparse_blk [tpa$l_stringcnt] = .bad$ga_input_desc [dsc$w_length];
tparse_blk [tpa$l_stringptr] = .bad$ga_input_desc [dsc$a_pointer];

LIB$TPARSE (tparse_blk, .state, .key);			! Parse the value.

IF bad$str_trim NEQ 0					! Restore the buffer size if we are stand alone
THEN    bad$ga_input_desc [dsc$w_length] = bad$k_input_len;

END;    ! of ROUTINE parse_value


%SBTTL 'TPARSE action routines'
ROUTINE count_term =
!++
!
! Functional Description:
!
!    This routine is called by TPARSE to indicate the number
!    of terms which describe the user supplied bad block(s).
!
! Implicit Outputs:
!
!    bad$gl_bad_term		The appropriate longword in this vector is
!				loaded with the current value of the parse.
!
!    bad$gb_term_count		The count value is used after parsing the
!				current term to describe the form of bad block
!				information specified.
!
!			        1 => lbn
!        			2 => lbn:count
!        			3 => sector.track.cylinder
!				4 => sector.track.cylinder:count
!
!--
BEGIN

def_tparse_args;

bad$gl_bad_term [.bad$gb_term_count] = .tparse_args [TPA$L_NUMBER];
bad$gb_term_count = .bad$gb_term_count + 1;

IF .bad$gb_term_count GTR 4
THEN RETURN FALSE;

RETURN TRUE;

END;    ! of ROUTINE count_term


ROUTINE	syntax_err =
!++
!
! Functional Description:
!
!    This routine issues a diagnotic to inform the user of an invalid
!    argument in the bad block specification.  The term count is reset
!    to indicate an invalid bad block specification was encountered.
!
! Implicit Outputs:
!
!    bad$gb_term_count		is reset, to indicate no value present.
!
! Side Effects:
!
!    Since there was a missing argument in this block spec, it constitutes
!    an unrecoverable error.  If we are prompting for bad blocks, issue the
!    diagnostic and prompt for the next block.  If we are processing bad
!    blocks issued from the command line, then terminate the analysis after
!    issuing the diagnostic.
!
!--
BEGIN
bad$gb_term_count = 0;

SIGNAL (IF .bad$gl_context [ctx_v_interactive]
	THEN bad$_ivblkent
	ELSE bad$_ivblkent + STS$K_SEVERE,
	1, bad$ga_input_desc);

RETURN	TRUE;

END;    ! of ROUTINE syntax_err


ROUTINE	bad_value =
!++
!
! Functional Description:
!
!    This routine issues a diagnotic to inform the user of an invalid
!    value on the PATTERN keyword.
!
! Side Effects:
!
!    Since there was an invalid pattern value, it constitutes an unrecoverable
!    error.  Since we are processing the value from the command line, terminate
!    the analysis after issuing the diagnostic.
!
!--
BEGIN

SIGNAL (bad$_badvalue, 1, bad$ga_input_desc);
RETURN TRUE;

END;    ! of ROUTINE bad_value


%SBTTL	'val_phy_adr -- Validate Physical Address'
ROUTINE	val_phy_adr (sec, trk, cyl, cnt) =
!++
!
! Functional Description:
!
!    Validate Physical Address Range
!
! Inputs:
!
!    sec	val	the sector number supplied by the user.
!    trk	val	the track number supplied by the user.
!    cyl	val	the cylinder number supplied by the user.
!    cnt	val	the count of contigous sectors to mark bad.
!
! Implicit Inputs:
!
!    bad$gl_cylinders	the number of cylinders on the device.
!    bad$gl_maxblock	the total number of blocks on the device.
!    bad$gl_sectors	the number of sectors per track on the device.
!    bad$gl_tracks	the number of tracks per cylinder on the device.
!
! Side Effects:
!
!    If any of the parts which constitute the physical address are not
!    valid, we will issue a diagnostic and select on of the following actions.
!
!	If prompting, disregard the last entry and prompt for more input.
!
!	If processing blocks from the command line, the severity will be set
!	to FATAL, resulting in termination of the analysis.
!
!--
BEGIN
OWN
    hibound,
    status;

status = TRUE;						! Assume address is ok.

IF .sec GTR .bad$gl_sectors - 1				! Is the sector number
THEN							! within range?
    status = addr_error (sector, .sec);

IF .trk GTR .bad$gl_tracks - 1				! Is the track number
THEN							! within range?
    status = addr_error (track, .trk);

IF .cyl GTR .bad$gl_cylinders - 1			! Is the cylinder number
THEN							! within range?
    status = addr_error (cylinder, .cyl);

IF .cnt NEQ 0						! Should we consider the count field?
THEN
    BEGIN						! Yes.
    hibound = bad$cvt_phy_log(.sec, .trk, .cyl);	! Convert to logical address.
    IF .hibound + .cnt GTR .bad$gl_maxblock - 1		! Does the COUNT field
    THEN						! push us over the end 
        status = addr_error (count, .cnt);		! of the media?
    END;						! Inform user of the 
	        					! invalid address generated.
RETURN .status;

END;    ! of ROUTINE val_phy_adr


%SBTTL	'val_log_adr -- Validate Logical Address'
ROUTINE	val_log_adr (lbn, cnt) =
!++
!
! Functional Description:
!
!    Validate Logical Block Number Address range.
!
! Inputs:
!
!    lbn	val	the block number to validate.
!    cnt	val	the number of contiguous block to validate.
!
! Implicit Inputs:
!
!    bad$gl_maxblock	the total number of blocks on the device.
!
! Side Effects:
!
!    If any of the logical block number or the count force us to generate an
!    invalid address, we will issue a diagnostic and select on of the following
!    actions.
!
!	If prompting, disregard the last entry and prompt for more input.
!
!	If processing blocks from the command line, the severity will be set
!	to FATAL, resulting in termination of the analysis.
!
!--
BEGIN
LOCAL
    status;

status = TRUE;						! Assume address is ok.

IF .lbn GTR .bad$gl_maxblock - 1			! Is this a valid lbn?
THEN
    status = addr_error (logical_blk, .lbn);

IF .cnt NEQ 0						! Should we consider the count?
THEN							! Yes.
    IF .lbn + .cnt GTR .bad$gl_maxblock - 1		! Does the count push
    THEN						! us off the end of the
        status = addr_error (count, .cnt);		! media.

RETURN .status;

END;    ! of ROUTINE val_log_adr


%SBTTL	'addr_error -- Address error handler'
ROUTINE addr_error (desc, val) =
!+
!
! Functional Description:
!
!    There is an error in the address specification, inform the user of the
!    problem area.
!
! Side Effects:
!
!    If prompting, disregard the last entry and prompt for more input.
!
!    If processing blocks from the command line, the severity will be set
!    to FATAL, resulting in termination of the analysis.
!
!--
BEGIN
bad$gb_term_count = 0;					! Reset the term count.

If bad$str_trim NEQ 0					! If we are stand alone, trim the string
THEN    bad$str_trim (bad$ga_input_desc);		! of trailing blanks, tabs and carriage return.

SIGNAL (IF .bad$gl_context [ctx_v_interactive]		! If the user is interactively entering
        THEN bad$_ivblknum				! bad blocks, reject this entry.
        ELSE bad$_ivblknum + STS$K_SEVERE,		! Otherwise, stop the analysis here.
        3,						! Three pieces of information...
        bad$ga_input_desc,				! The current input spec,
        .desc,						! the part of the bad block spec out of range,
        .val);						! and the offending value.

IF bad$str_trim NEQ 0					! Restore the buffer size if we are stand alone.
THEN    bad$ga_input_desc [dsc$w_length] = bad$k_input_len;

RETURN FALSE;

END;    ! of ROUTINE addr_error

END    ! of MODULE badinit
ELUDOM
