module uafparse (
		language (bliss32),
		ident = 'V04-000',
                addressing_mode(external=general, nonexternal=general)) =
begin
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	System Management Utility Program
!
! ABSTRACT:	Parsing subroutines for the AUTHORIZE utility
!
! ENVIRONMENT:
!
! AUTHOR:	Henry M. Levy	, CREATION DATE: 1-June-1977
!
! MODIFIED BY:
!
!	V03-022	JRL0035		John R. Lawson, Jr.	07-Aug-1984 15:49
!		Fix PWD_EXPIRED login flag to be set with passwords.
!
!	V03-021	JRL0022		John R. Lawson, Jr.	09-Jul-1984 13:40
!		Supply missing brackets (if necessary) on /DIRECTORY.
!
!	V03-020	JRL0011		John R. Lawson, Jr.	02-Jul-1984 14:40
!		Add literal WORD_UNSIGNED_LENGTH (=17) for unsigned
!		words in WS info.
!
!	V03-019	JRL0012		John R. Lawson, Jr.	21-Jun-1984 15:56
!		Add /GENERATE qualifier to generate random passwords.
!
!	V03-018	JRL0008		John R. Lawson, Jr.	20-Jun-1984 14:19
!		Add /PWDEXPIRED qualifier to allow pre-expired passwords.
!
!	V03-017	JRL0007		John R. Lawson, Jr.	20-Jun-1984 14:18
!		Add /PWDLIFETIME=NONE qualifier.
!
!	V03-016	JRL0002		John R. Lawson, Jr.	15-Jun-1984 12:54
!		Change all messages to calls to LIB$SIGNAL, place all
!		messages in a .MSG file
!
!	V03-015	LY0475		Larry Yetto		 9-APR-1984 08:34
!		If /NOEXPIRATION or /NOPWDLIFE is specified then
!		zero the field in the UAF record.
!
!	V03-014	LY0467		Larry Yetto		22-MAR-1984 13:53
!		Add support for the rights data base functions
!
!	V03-013	ACG0397		Andrew C. Goldstein,	6-Feb-1984  16:25
!		Add DISREPORT flag to UAF; fix bugs in storing secondary
!		password
!
!	V03-012	ACG0388		Andrew C. Goldstein,	12-Jan-1984  18:52
!		Add command input to handle new UAF features;
!		general code cleanup
!
!	V03-011	ACG0385		Andrew C. Goldstein,	6-Jan-1984  14:18
!		V4 UAF format change
!
!	V03-010	TMK0001		Todd M. Katz		11-Oct-1983
!		Add JTQUOTA (job-wide logical name table creation quota)
!		qualifier.
!
!	V03-009	LMP0153		L. Mark Pilant,		13-Sep-1983  11:41
!		Add minimal support for alphanumeric UICs.
!
!	008	JWT0105		Jim Teague	04-Apr-1983
!		Finish up long filename stuff.
!
!	007	JWT0104		Jim Teague	29-Mar-1983
!		Add CLITABLES qualifier.
!
!	006	WMC0001		Wayne Cardoza	15-Mar-1983
!		Add MAXDETACH qualifier
!
!	005	JWT0076		Jim Teague	13-Dec-1982
!		Fix bug in parsing UIC specs.
!
!	004	JWT0046		Jim Teague	30-Jul-1982
!		Check null password string earlier in GETPASSWORD
!
!	003	JWT0030		Jim Teague	03-May-1982
!		Accomodate ufd directory specs
!	
!	002	JWT0029		Jim Teague	20-Apr-1982
!		Completely disable /maxacctjobs
!
!	001 	JWT0023		Jim Teague	17-Mar-1982
!		Enforce default directory syntax more strictly by
!		cranking the spec through tparse.
!
!--

!
! Require files:
!
require 
	'lib$:uafreq';
!
! TABLE OF CONTENTS:
!

forward routine

	update_record,			! modify all specified fields
	getaccess,			! get access flag bits
	check_primary,			! verify "primary" keyword
	check_secondary,		! verify "secondary" keyword
	set_range,			! set hourly restriction bits
	getcputim,			! get cpu time quota
	getdevice,			! get default device name
	getdirectory,			! get default directory
	checkvalue,			! check UFD group and member value
	checklength,			! check directory name length
	getflags,			! get flag bits
	getpflags,			! get old per day login flags
	getrestrict,			! get old hourly restriction values
	getprimedays,			! get primary day list
	getpriv,			! get process privileges
	getuic,				! get user identification code
	parse_uic,			! obtain UIC group and member
	parse_wild,			! parse wildcarded user specification
	parse_wild_uic,			! parse wildcarded UIC
	getstring,			! get string from input
	getval,				! get numeric value from user
	cvtnum,				! convert decimal ascii to binary
	UAF$GENERATE,			! generate necessary passwords
	GETPASSWORD,			! update password fields
        AUTHORIZE_GENERATE;		! Interface to PL/I


external routine

	GENERATE_PASSWORDS,
	SYS$ASSIGN,
	SYS$DASSGN,
	SYS$QIOW,
	LIB$GET_VM,
	STR$UPCASE,
	STR$UPCASE,
	lib$tparse	: addressing_mode (general),
	lib$lookup_key	: addressing_mode (general),
	cli$dcl_parse,
	cli$present,
	cli$get_value,
	faoout,				! output formatted message
	lgi$hpwd,			! hash password routine
	lib$cvt_dtime,			! convert ASCII to system delta time
	lib$cvt_time,			! convert ASCII to system abs time
	prv$setpriv;			! set privilege bits based on
					! privilege names

!
! INCLUDE FILES:
!

library 'SYS$LIBRARY:TPAMAC';
library 'SYS$LIBRARY:LIB';

!
! MACROS:
!

macro
    cstring[] = (uplit byte (%charcount (%string (%remaining)),
		%string (%remaining)))%,

!
! Macro to create string descriptor for command parameters and
!	qualifiers
!
    sd[a] =
	bind %name ('SD_', a) = $descriptor (a)%;


     sd (
      	'token1',	'token2',	'account',	'astlm',
	'biolm',	'bytlm',	'cli',  	'cputime',
	'device',	'diolm',	'directory',	'enqlm',
	'fillm',	'flags',	'lgicmd',	'maxjobs',
	'owner',	'password',	'pbytlm',	'pflags',
  	'pgflquota',	'p_restrict',	'prclm',	'priority',
	'privileges',	'sflags',	's_restrict',	'shrfillm',
	'tqelm',	'uic',		'wsdefault', 	'wsextent',
	'wsquota',	'display',	'primedays',	'maxacctjobs',
	'maxdetach',	'clitables',	'jtquota',	'access',
	'batch',	'defprivileges','dialup',	'expiration',
	'interactive',	'local',	'network',	'pwdlifetime',
	'pwdminimum',	'quepriority',	'remote'
);

!
! The definition table for flag bits for UAF$B_FLAGS.
!
literal
	num_flags	= 13,		! number of FLAG_TABLE entries
	num_opflags	= 2,		! number of OPFLAG_TABLE entries
	num_pdflags	= 7;		! number of entries in prime days table

own
    flag_table : vector [2 * num_flags + 1, long] initial (
	2 * num_flags,
	uplit (%ascic 'DISCTLY'),	$bitposition (uaf$v_disctly),
	uplit (%ascic 'DEFCLI'),	$bitposition (uaf$v_defcli),
	uplit (%ascic 'LOCKPWD'),	$bitposition (uaf$v_lockpwd),
	uplit (%ascic 'CAPTIVE'),	$bitposition (uaf$v_captive),
	uplit (%ascic 'DISUSER'),	$bitposition (uaf$v_disacnt),
	uplit (%ascic 'DISWELCOME'),	$bitposition (uaf$v_diswelcom),
	uplit (%ascic 'DISNEWMAIL'),	$bitposition (uaf$v_dismail),
	uplit (%ascic 'DISMAIL'),	$bitposition (uaf$v_nomail),
	uplit (%ascic 'GENPWD'),	$bitposition (uaf$v_genpwd),
	uplit (%ascic 'PWD_EXPIRED'),	$bitposition (uaf$v_pwd_expired),
	uplit (%ascic 'PWD2_EXPIRED'),	$bitposition (uaf$v_pwd2_expired),
	uplit (%ascic 'AUDIT'),		$bitposition (uaf$v_audit),
	uplit (%ascic 'DISREPORT'),	$bitposition (uaf$v_disreport)
),
!
! The definition table for flag bits for UAF$B_PDAYFLAGS and  UAF$B_SDAYFLAGS.
!
    opflag_table : vector [2 * num_opflags + 1, long] initial (
	2 * num_opflags,
	uplit (%ascic 'DISDIALUP'),	uaf$k_disdialup,
	uplit (%ascic 'DISNETWORK'),	uaf$k_disnetwork	! Disneyworld ??
),
!
! The definition table for flag bits for UAF$B_PRIMEDAYS.
!
    pdflag_table : vector [2 * num_pdflags + 1, long] initial (
	2 * num_pdflags,
	uplit (%ascic 'MONDAY'),	$bitposition (uaf$v_monday),
	uplit (%ascic 'TUESDAY'),	$bitposition (uaf$v_tuesday),
	uplit (%ascic 'WEDNESDAY'),	$bitposition (uaf$v_wednesday),
	uplit (%ascic 'THURSDAY'),	$bitposition (uaf$v_thursday),
	uplit (%ascic 'FRIDAY'),	$bitposition (uaf$v_friday),
	uplit (%ascic 'SATURDAY'),	$bitposition (uaf$v_saturday),
	uplit (%ascic 'SUNDAY'),	$bitposition (uaf$v_sunday)
);


!
! EQUATED SYMBOLS:
!

literal
	false		= 0,		! logical false
	true		= 1,		! logical true

	network_access	= 1^0,		! mask representing /NETWORK_ACCESS
	batch_access	= 1^1,		! mask representing /BATCH_ACCESS
	local_access	= 1^2,		! mask representing /LOCAL_ACCESS
	dialup_access	= 1^3,		! mask representing /DIALUP_ACCESS
	remote_access	= 1^4,		! mask representing /REMOTE_ACCESS
	interactive_access =		! mask representing /INTERACTIVE_ACCESS
			local_access or dialup_access or remote_access,
	access_access	=		! mask representing /ACCESS
			interactive_access or network_access or batch_access,

	byte_length	= 8,		! bits per byte
	word_length	= 16,		! bits per word
	word_unsigned_length
			= 17,		! for WS info
	long_length	= 32,		! bits per longword


	blank		= ' ',		!  delimiters
	colon		= ':',
	comma		= ',',
	cr		= 13,
	equals		= '=',
	lf		= 10,
	lparen		= ' (',
	rparen		= ')',
	slash		= '/',
	tab		= '	',
	zero		= 0,

	counted_string	= 1,		! counted string type indicator
	filled_string	= 2;		! filled string type indicator

own
	status,
	cli_status,

	tparse_block	: block [tpa$c_length0, byte]
			  preset ([tpa$l_count]   = tpa$k_count0,
				  [tpa$l_options] = tpa$m_abbrev),
	converted_uic,
	address,
	left_bit,
	right_bit,
	primary_access	: bitvector [32],
	secondary_access: bitvector [32],
	no_flag		: initial (false),
	primary		: initial (false),
	secondary	: initial (false);

!
! ASCII numbers from '0' through hex 'F'
!

bind
	numbers		= uplit byte ('0123456789ABCDEF'),

!
! 'NO' prefix descriptor for negating privileges
!
	no_dsc		= $descriptor ('NO') : vector;

!
!	External messages
!

external routine

   LIB$SIGNAL: addressing_mode(general);

external literal

   UAF$_BADVALUE,	UAF$_EXTRAPARM,		UAF$_INVDEV,
   UAF$_INVSTR,		UAF$_INVUSERSPEC,	UAF$_KEYNOTFND,
   UAF$_NAMETOOBIG,	UAF$_NOARG,		UAF$_NOQUOTE,
   UAF$_NOUSERSPEC,	UAF$_PRVNOTFND,		UAF$_PRVNOTUNQ,
   UAF$_PWDSYNTAX,	UAF$_PWDNCH,		UAF$_PWDNOL,
   UAF$_UICERR,		UAF$_VALTOOBIG,		UAF$_ZCONFLICT;


!
! EXTERNAL REFERENCES:
!


external literal

	encrypt,			! encryption algorithm to use

	lib$_ambkey,			! status for ambiguous keyword
	lib$_unrkey,			! status for unrecognized keyword

	cli$_abkeyw,			! message symbol for "ambiguous keyword"
	cli$_ivkeyw,			! message symbol for "unrecognized keyword"
	cli$_negated,			! qualifier explicitly negated
	CLI$_ABSENT,			! Qualifier not given
	prv$_notunq,
	prv$_invnam;

external				! Global storage from UAFMAIN
	uaf$gl_ctlmsk	: block,
	authorize_commands : addressing_mode ( general ),
	cmdlindsc	: block [,byte],
	call_count,
	symbol_str,			! Symbolic character set
	match_tokenlen,
	match_token,
	tokendsc	: block [,byte],
	tokenlen	: word,		! Bound to TOKENDSC[DSC$W_LENGTH]
	tokenptr,			! Bound to TOKENDSC[DSC$A_POINTER]
	uic_flag,			! Wildcard parsing flags
	grp_wild,
	mem_wild,
	str_wild,

	time_buf	: block [,byte], ! Buffer to receive current system time
	pwd_flag,			! User did not supply password flag
	recbuf		: block [,byte]; ! The current UAF record

!
! TPARSE state table to parse /<access> qualifiers
!

$init_state (access_states, access_keys);

$state	 (,
	 ('PRIMARY', terminal, check_primary, true, primary),
	 ('SECONDARY', terminal, check_secondary, true, secondary),
	 (tpa$_decimal,,,, right_bit)
	);

$state	 (,
	 ('-'),
	 (tpa$_eos, tpa$_exit, set_range)
	);

$state	 (,
	 (tpa$_decimal,, set_range)
	);

$state 	 (terminal,
	 (tpa$_eos, tpa$_exit)
	);

!
! TPARSE state table for old /P_RESTRICT and /S_RESTRICT qualifiers.
!

$init_state (restrict_states, restrict_keys);

$state	 (,
	 (tpa$_decimal,,,, right_bit)
	);

$state	 (,
	 ('-'),
	 (tpa$_eos, tpa$_exit, set_range)
	);

$state	 (,
	 (tpa$_decimal,, set_range)
	);

$state 	 (,
	 (tpa$_eos, tpa$_exit)
	);

!
! TPARSE state table for UIC spec
!

$init_state (uic_states, uic_keys);

$state	 (,
	 (tpa$_ident, tpa$_exit,,, converted_uic)
	);

!
! TPARSE state table for directory string
!

$init_state (dir_states, dir_keys);

$state	 (,
	 ( (ufd), end_state),
	 ( (subdir), end_state),
	 ('['),
	 ('<')
	);

$state	 (,
	 ( (ufd)),
	 ( (subdir))
	);

$state	 (,
	 (']'),
	 ('>')
	);

$state	 (end_state,
	 (tpa$_eos, tpa$_exit)
	);

$state	 (ufd,
	 (tpa$_octal,, checkvalue)
	);

$state	 (,
	 (',')
	);

$state	 (,
	 (tpa$_octal, tpa$_exit, checkvalue)
	);

$state	 (subdir,
	 (tpa$_symbol,, checklength)
	);

$state	 (,
	 ('.',subdir),
	 (tpa$_lambda,tpa$_exit)
	);

%sbttl 'update_record - modify all specified fields'
global routine update_record =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Scan the remainder of the user's input command line for parameters
!	and parameter values.  Pull off each parameter keyword and check
!	that it is valid, then call the associated routine to process
!	the supplied value or string. 
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> all keywords and parameters were specified correctly
!
! SIDE EFFECTS:
!
!	none
!--
status = false;
primary = false;
secondary = false;
no_flag = false;

!
! If this is part of a series of calls from WILD_USER, the command
!    line must be reparsed after the first call

if .call_count neq 0
then
    cli$dcl_parse (cmdlindsc, authorize_commands);


if CLI$PRESENT(%ascid'GENERATE_PASSWORD')
and (CLI$PRESENT(SD_PASSWORD) neq CLI$_ABSENT) then
   begin

      LIB$SIGNAL(UAF$_ZCONFLICT);

   end
else if CLI$PRESENT(%ascid'GENERATE_PASSWORD')
or (CLI$PRESENT(SD_PASSWORD) neq CLI$_ABSENT) then
   begin

      if CLI$PRESENT(%ascid'GENERATE_PASSWORD') then
         UAF$GENERATE();
      if not GETPASSWORD() then
         return FALSE;
      RECBUF[UAF$V_PWD_EXPIRED] = FALSE;
      STATUS = TRUE;

   end;


if .uaf$gl_ctlmsk[uaf$v_rename]
then
    return true;

!
! Check that we're not at the end of the command line. Continue
! processing parameters until the end is reached.
!

cli_status = cli$present (sd_access);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_access, access_access, .cli_status)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_interactive);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_interactive, interactive_access, .cli_status)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_batch);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_batch, batch_access, .cli_status)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_dialup);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_dialup, dialup_access, .cli_status)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_network);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_network, network_access, .cli_status)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_local);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_local, local_access, .cli_status)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_remote);
if .cli_status
or .cli_status eql cli$_negated
then
    begin
    if not getaccess (sd_remote, remote_access, .cli_status)
    then return false;
    status = true;
    end;

if cli$present (sd_account)
then
    begin
    cli$get_value (sd_account, tokendsc);
!***    if not getstring (recbuf[uaf$t_account], uaf$s_account, filled_string)
    if not getstring (recbuf[uaf$t_account], 8, filled_string)
    then return false;
    status = true;
    end;

if cli$present (sd_astlm)
then
    begin
    cli$get_value (sd_astlm, tokendsc);
    if not getval (recbuf[uaf$w_astlm], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_biolm)
then
    begin
    cli$get_value (sd_biolm, tokendsc);
    if not getval (recbuf[uaf$w_biolm], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_bytlm)
then
    begin
    cli$get_value (sd_bytlm, tokendsc);
    if not getval (recbuf[uaf$l_bytlm], long_length)
    then return false;
    status = true;
    end;

if cli$present (sd_cli)
then
    begin
    cli$get_value (sd_cli, tokendsc);
    if not getstring (recbuf[uaf$t_defcli], uaf$s_defcli, counted_string)
    then return false;
    uaf$gl_ctlmsk[uaf$v_clitab_pres] =
	(.vector [recbuf[uaf$t_clitables], 0; ,byte] neq 0);
    uaf$gl_ctlmsk[uaf$v_cli] = true;
    status = true;
    end;

if cli$present (sd_clitables)
then
    begin
    cli$get_value (sd_clitables, tokendsc);
    if not getstring (recbuf[uaf$t_clitables], uaf$s_clitables, counted_string)
    then return false;
    uaf$gl_ctlmsk[uaf$v_clitables] = true;
    status = true;
    end;

if cli$present (sd_cputime)
then
    begin
    cli$get_value (sd_cputime, tokendsc);
    if not getcputim ()
    then return false;
    status = true;
    end;

if cli$present (sd_defprivileges)
then
    begin
    if not getpriv (sd_defprivileges, recbuf[uaf$q_def_priv])
    then return false;
    status = true;
    end;

if cli$present (sd_device)
then
    begin
    cli$get_value (sd_device, tokendsc);
    if not getdevice ()
    then return false;
    status = true;
    end;

if cli$present (sd_diolm)
then
    begin
    cli$get_value (sd_diolm, tokendsc);
    if not getval (recbuf[uaf$w_diolm], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_directory)
then
    begin
    cli$get_value (sd_directory, tokendsc);
    if not getdirectory ()
    then return false;
    status = true;
    end;

if cli$present (sd_enqlm)
then
    begin
    cli$get_value (sd_enqlm, tokendsc);
    if not getval (recbuf[uaf$w_enqlm], word_length)
    then return false;
    status = true;
    end;

cli_status = cli$present (sd_expiration) ;
if .cli_status eql cli$_negated
then
    begin
    ch$fill ( 0, uaf$s_expiration, recbuf[uaf$q_expiration] ) ;
    status = true ;
    end
else
    if .cli_status
    then
	begin
	cli$get_value (sd_expiration, tokendsc);
	if not (status = lib$cvt_time (tokendsc, recbuf[uaf$q_expiration]))
	then
	    begin
	    signal (.status);
	    return false;
	    end;
	status = true;
	end;

if cli$present (sd_fillm)
then
    begin
    cli$get_value (sd_fillm, tokendsc);
    if not getval (recbuf[uaf$w_fillm], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_flags)
then
    begin
    if not getflags ()
    then return false;
    status = true;
    end;

if cli$present (sd_jtquota)
then
    begin
    cli$get_value (sd_jtquota, tokendsc);
    if not getval (recbuf[uaf$l_jtquota], long_length)
    then return false;
    status = true;
    end;

if cli$present (sd_lgicmd)
then
    begin
    cli$get_value (sd_lgicmd, tokendsc);
    if not getstring (recbuf[uaf$t_lgicmd], uaf$s_lgicmd, counted_string)
    then return false;
    status = true;
    end;

if cli$present (sd_maxjobs)
then
    begin
    cli$get_value (sd_maxjobs, tokendsc);
    if not getval (recbuf[uaf$w_maxjobs], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_maxacctjobs)
then
    begin
    cli$get_value (sd_maxacctjobs, tokendsc);
    if not getval (recbuf[uaf$w_maxacctjobs], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_maxdetach)
then
    begin
    cli$get_value (sd_maxdetach, tokendsc);
    if not getval (recbuf[uaf$w_maxdetach], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_owner)
then
    begin
    cli$get_value (sd_owner, tokendsc);
    if not getstring (recbuf[uaf$t_owner], uaf$s_owner, counted_string)
    then return false;
    status = true;
    end;

if cli$present (sd_pbytlm)
then
    begin
    cli$get_value (sd_pbytlm, tokendsc);
    if not getval (recbuf[uaf$l_pbytlm], long_length)
    then return false;
    status = true;
    end;

if cli$present (sd_pgflquota)
then
    begin
    cli$get_value (sd_pgflquota, tokendsc);
    if not getval (recbuf[uaf$l_pgflquota], 3 * byte_length)
    then return false;
    status = true;
    end;

if cli$present (sd_p_restrict)
then
    begin
    if not getrestrict (sd_p_restrict)
    then return false;
    status = true;
    end;

if cli$present (sd_s_restrict)
then
    begin
    secondary = true;
    if not getrestrict (sd_s_restrict)
    then return false;
    status = true;
    end;

if cli$present (sd_pflags)
then
    begin
    primary = true;
    if not getpflags (sd_pflags)
    then return false;
    status = true;
    end;

if cli$present (sd_sflags)
then
    begin
    if not getpflags (sd_sflags)
    then return false;
    status = true;
    end;

if cli$present (sd_prclm)
then
    begin
    cli$get_value (sd_prclm, tokendsc);
    if not getval (recbuf[uaf$w_prccnt], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_primedays)
then
    begin
    if not getprimedays ()
    then return false;
    status = true;
    end;

if cli$present (sd_priority)
then
    begin
    cli$get_value (sd_priority, tokendsc);
    if not getval (recbuf[uaf$b_pri], byte_length)
    then return false;
    status = true;
    end;

if cli$present (sd_privileges)
then
    begin
    if not getpriv (sd_privileges, recbuf[uaf$q_priv])
    then return false;
    status = true;
    end;

CLI_STATUS = CLI$PRESENT(%ascid'PWDEXPIRED');
if .CLI_STATUS eql CLI$_NEGATED then
   begin
      local TIME: long;
      TIME = RECBUF[UAF$Q_PWD_DATE];
      .TIME = 0; (.TIME+%upval) = 0;
      RECBUF[UAF$V_PWD_EXPIRED] = FALSE;
      STATUS = TRUE;
   end
else if .CLI_STATUS then
   begin
      local TIME: long;
      TIME = RECBUF[UAF$Q_PWD_DATE];
      .TIME = -1; (.TIME+%upval) = -1;
      RECBUF[UAF$V_PWD_EXPIRED] = FALSE;
      STATUS = TRUE;
   end;

cli_status = cli$present (sd_pwdlifetime) ;
if .cli_status eql cli$_negated
then
    begin
    ch$fill ( 0, uaf$s_pwd_lifetime, recbuf[uaf$q_pwd_lifetime] ) ;
    RECBUF[UAF$V_PWD_EXPIRED] = FALSE;
    status = true ;
    end
else
    if .cli_status
    then
	begin
	cli$get_value (sd_pwdlifetime, tokendsc);
        if ch$eql(.tokendsc[dsc$w_length], .tokendsc[dsc$a_pointer],
              4, uplit(%ascii'NONE') ) then
           begin
              ch$fill(0, uaf$s_pwd_lifetime, recbuf[uaf$q_pwd_lifetime] );
              status = true;
           end
        else
	if not (status = lib$cvt_dtime (tokendsc, recbuf[uaf$q_pwd_lifetime]))
	then
	    begin
	    signal (.status);
	    return false;
	    end;
        RECBUF[UAF$V_PWD_EXPIRED] = FALSE;
	status = true;
	end;

if cli$present (sd_pwdminimum)
then
    begin
    cli$get_value (sd_pwdminimum, tokendsc);
    if not getval (recbuf[uaf$b_pwd_length], byte_length)
    then return false;
    status = true;
    end;

if cli$present (sd_quepriority)
then
    begin
    cli$get_value (sd_quepriority, tokendsc);
    if not getval (recbuf[uaf$b_quepri], byte_length)
    then return false;
    status = true;
    end;

if cli$present (sd_shrfillm)
then
    begin
    cli$get_value (sd_shrfillm, tokendsc);
    if not getval (recbuf[uaf$w_shrfillm], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_tqelm)
then
    begin
    cli$get_value (sd_tqelm, tokendsc);
    if not getval (recbuf[uaf$w_tqcnt], word_length)
    then return false;
    status = true;
    end;

if cli$present (sd_uic)
then
    begin
    cli$get_value (sd_uic, tokendsc);
    if not getuic ()
    then return false;
    status = true;
    end;

if cli$present (sd_wsdefault)
then
    begin
    cli$get_value (sd_wsdefault, tokendsc);
    if not getval (recbuf[uaf$l_dfwscnt], word_unsigned_length)
    then return false;
    (recbuf[uaf$l_dfwscnt])<16, 16> = 0; !** temp until longword is supported
    status = true;
    end;

if cli$present (sd_wsextent)
then
    begin
    cli$get_value (sd_wsextent, tokendsc);
    if not getval (recbuf[uaf$l_wsextent], word_unsigned_length)
    then return false;
    (recbuf[uaf$l_wsextent])<16, 16> = 0; !** temp until longword is supported
    status = true;
    end;

if cli$present (sd_wsquota)
then
    begin
    cli$get_value (sd_wsquota, tokendsc);
    if not getval (recbuf[uaf$l_wsquota], word_unsigned_length)
    then return false;
    (recbuf[uaf$l_wsquota])<16, 16> = 0; !** temp until longword is supported
    status = true;
    end;

if .uaf$gl_ctlmsk[uaf$v_copy] or .uaf$gl_ctlmsk[uaf$v_add]
then
    return true;

return .status;
end;

%sbttl 'getaccess - get hourly and daily access control flags'
routine getaccess (qual_name, access_type, qual_status) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Parse the value list for hourly login restrictions on the
!	selected access modes.
!
! INPUTS:
!
!	qual_name - descriptor of qualifier name to use
!	access_type - bitvector representing the access modes to be affected
!	qual_status - status from cli$present for qualifier
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> all keywords and parameters were specified correctly
!
! SIDE EFFECTS:
!
!	none
!--

map
	access_type	: bitvector;

STRUCTURE
    threebytevector [i; n, ext=0] =
	[n*3]
	(threebytevector+i*3)<0, 24, ext>;

$ASSUME ($BYTEOFFSET (uaf$b_network_access_s), EQL, $BYTEOFFSET (uaf$b_network_access_p)+3);
$ASSUME ($BYTEOFFSET (uaf$b_batch_access_p), EQL, $BYTEOFFSET (uaf$b_network_access_s)+3);
$ASSUME ($BYTEOFFSET (uaf$b_batch_access_s), EQL, $BYTEOFFSET (uaf$b_batch_access_p)+3);
$ASSUME ($BYTEOFFSET (uaf$b_local_access_p), EQL, $BYTEOFFSET (uaf$b_batch_access_s)+3);
$ASSUME ($BYTEOFFSET (uaf$b_local_access_s), EQL, $BYTEOFFSET (uaf$b_local_access_p)+3);
$ASSUME ($BYTEOFFSET (uaf$b_dialup_access_p), EQL, $BYTEOFFSET (uaf$b_local_access_s)+3);
$ASSUME ($BYTEOFFSET (uaf$b_dialup_access_s), EQL, $BYTEOFFSET (uaf$b_dialup_access_p)+3);
$ASSUME ($BYTEOFFSET (uaf$b_remote_access_p), EQL, $BYTEOFFSET (uaf$b_dialup_access_s)+3);
$ASSUME ($BYTEOFFSET (uaf$b_remote_access_s), EQL, $BYTEOFFSET (uaf$b_remote_access_p)+3);

bind
	access_vector	= recbuf[uaf$b_network_access_p]
			: threebytevector;

!
! Initialize output values.
!
primary_access = -1;
secondary_access = -1;
if not .qual_status then no_flag = true;

!
! Fetch value list items and parse them.
!
while true
do
    begin
    if not cli$get_value (.qual_name, tokendsc)
    then exitloop;

    tparse_block[tpa$l_stringcnt] = .tokenlen;
    tparse_block[tpa$l_stringptr] = .tokenptr;
    if not lib$tparse (tparse_block, access_states, access_keys)
    then return LIB$SIGNAL(UAF$_BADVALUE, 2, .tokenlen, .tokenptr);
    end;

!
! Default omitted values.
!
if not .primary and not .secondary
then secondary_access = .primary_access;
if .primary and not .secondary
then secondary_access = 0;
if .secondary and not .primary and .primary_access eql -1
then primary_access = 0;

if not .no_flag
then
    begin
    primary_access = not .primary_access;
    secondary_access = not .secondary_access;
    end;

!
! Write the specified fields in the UAF record.
!
incr j from 0 to 4
do
    begin
    if .access_type[.j]
    then
	begin
	access_vector [.j*2+0] = .primary_access;
	access_vector [.j*2+1] = .secondary_access;
	end;
    end;

true
end;

%sbttl 'check_primary - check presence of PRIMARY keyword'
routine check_primary =
begin
not .primary and not .secondary
end;

%sbttl 'check_secondary - check presence of SECONDARY keyword'
routine check_secondary =
begin
not .secondary
end;

%sbttl 'set_range - set hourly restriction bits'
global routine set_range  =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Set or clear appropriate hourly login restriction bits
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> successful completion
!	false -> error in flag name
!--

builtin
	ap;

map
	ap		: ref block [,byte];

local
	address,
	width,
	leftmost,
	wrap;

!
! Point to the flags longword to use.
!
if .secondary
then address = secondary_access
else address = primary_access;

!
! Get the ending bit - note that this is the same as the starting
! bit for a single hour.
!
left_bit = .ap[tpa$l_number];

!
! Make sure hour is not out of range
!
if .left_bit  gtru 23
or .right_bit gtru 23
then
    return false;

!
! Clear out the default field value if this is the first real value.
!
if ..address eql -1
then .address = 0;

wrap = false;
leftmost = .left_bit;

!
! If the starting bit is greater than the ending bit, allow field to wrap
!
if .left_bit lss .right_bit
then
    begin
    leftmost = 23;
    wrap = true;
    end;

!
! Set field width(s) and set appropriate bits
!
width = .leftmost - .right_bit + 1;

(.address)<.right_bit, .width> = -1;

if .wrap
then (.address)<0, .left_bit+1> = -1;

return true;

end;

%sbttl 'getcputim - get cpu time quota'
global routine getcputim =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Fill in the CPU time limit in the proper field in RECBUF.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> success
!	false -> invalid value supplied
!
!--

local
	delta_time	: vector [2, long], ! system delta time temporary
	cpu_time,			! CPU time work variables
	remainder;

builtin
	ediv;

!
! Convert ASCII to system delta time
!

if not lib$cvt_dtime (tokendsc, delta_time)
then
    return LIB$SIGNAL(UAF$_BADVALUE, 2, .tokenlen, .tokenptr);

!
! Convert system delta time to a longword value which is in .01 sec. units
!

if (ediv (%ref (-200000), delta_time, cpu_time, remainder) and psl$m_v) neq 0
then
    return LIB$SIGNAL(UAF$_VALTOOBIG, 2, .tokenlen, .tokenptr);

recbuf[uaf$l_cputim] = (.cpu_time ^ 1) + (if .remainder eql 0 then 0 else 1);

true
end;

%sbttl 'getdevice - get default device name'
global routine getdevice =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Fill in the default device name in RECBUF.
!	Will also append an ending colon if omitted.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> update successful
!	false -> error in specification
!--

local
	strlen;

if not getstring (recbuf[uaf$t_defdev], uaf$s_defdev, counted_string)
then
    return false;

!
! Check to see that string has ending ':'
! and add one if not.
! If string length is zero, then field has been removed so
! there's no need for the check.
!

strlen = .(recbuf[uaf$t_defdev])<0,8>;			! get string length

if .strlen eql 0
then
    return true;

if .(recbuf[uaf$t_defdev] + .strlen)<0,8> neq colon
then
    begin
    if .strlen geq uaf$s_defdev-1
    then
	return LIB$SIGNAL(UAF$_INVDEV, 2, .tokenlen, .tokenptr);
    (recbuf[uaf$t_defdev]+.strlen+1)<0,8> = colon;
    (recbuf[uaf$t_defdev])<0,8> = .strlen + 1;
    end;
return true;
end;

%sbttl 'getdirectory - get default directory'
global routine getdirectory =
begin
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the user default directory and places
!	it into the buffer if the form is correct.  If delimiters
!	are not present, they are added.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
! 	TOKENLEN = length of default directory string
!	TOKENPTR = pointer to default directory string 
!
!--
local BRACKETLESS;

!
! Crank directory spec through tparse
!
tparse_block [tpa$l_stringcnt] = .tokenlen;
tparse_block [tpa$l_stringptr] = .tokenptr;

if not lib$tparse (tparse_block, dir_states, dir_keys)
then
    return LIB$SIGNAL(UAF$_BADVALUE, 2, .tokenlen, .tokenptr);

!
! Did the string have enclosing brackets (matching is guaranteed
! by the command parser) ??
!
BRACKETLESS = (.(.tokenptr)<0,8> neq '[') and (.(.tokenptr)<0,8> neq '<');

!
! Make sure that the string isn't too long
!
if (((.tokenlen+1)  geq  uaf$s_defdir) and not .BRACKETLESS)
or ((.tokenlen+3) geq uaf$s_defdir)
then
    return LIB$SIGNAL(UAF$_INVSTR, 2, .tokenlen, .tokenptr);

!
! Move the string into the UAF record
!
if .BRACKETLESS then
   begin
      vector[recbuf[uaf$t_defdir], 0;, byte] = .tokenlen + 2;
      vector[recbuf[uaf$t_defdir], 1;, byte] = '[';
      ch$copy(.tokenlen, .tokenptr, ' ',
         uaf$s_defdir-2, recbuf[uaf$t_defdir]+2);
      vector[recbuf[uaf$t_defdir], .tokenlen+2;, byte] = ']';
   end
else
   begin
      (recbuf[uaf$t_defdir])<0,8> = .tokenlen;
      ch$copy(.tokenlen, .tokenptr, ' ',
         uaf$s_defdir-1, recbuf[uaf$t_defdir]+1);
   end;

return true;

end;

%sbttl 'checkvalue - check UFD group and member value'
routine checkvalue =
begin
builtin ap;
map ap: ref block [,byte];
if .ap[tpa$l_number] gtr %o'377' then return false else return true;
end;

%sbttl 'checklength - check directory name length'
routine checklength =
begin
builtin ap;
map ap: ref block [,byte];
if .ap[tpa$l_tokencnt] gtr 39 then return false else return true;
end;

%sbttl 'getflags - get flag bits'
global routine getflags =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get login flag bit settings.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	FLAG_TABLE - table of flag bit numbers and ascii names
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> successful completion
!	false -> error in flag name
!--

local
	status,
	keyword_dsc	: vector [2],
	no_flag,
	code,				! return from find_val
	ientry;

!
! Retrieve flag values as long as there are any present
!

while cli$get_value (sd_flags, tokendsc) do
    !
    ! Initialize keyword descriptor
    !
    begin
    keyword_dsc [0] = .tokenlen;
    keyword_dsc [1] = .tokenptr;
    no_flag = false;

    !
    ! If 'NO' prefix specified, set no_flag and adjust the
    !    keyword descriptor to remove the 'NO'
    !
    if ch$eql (2, .no_dsc [1], 2, .keyword_dsc [1])
    then
	begin
	keyword_dsc [0] = .keyword_dsc [0] - 2;
   	keyword_dsc [1] = .keyword_dsc [1] + 2;
	no_flag = true;
	end;

    if (status = lib$lookup_key (keyword_dsc, flag_table, code))
    then
        !
	! valid flag, set bit
	!
	(recbuf[uaf$l_flags])<.code,1> = not .no_flag
    else
	select .status of
	    set
	    !
	    ! ambiguous keyword?
	    !
	    [lib$_ambkey] : signal (cli$_abkeyw);
	    !
	    ! unrecognized keyword?
	    !
	    [lib$_unrkey] : signal (cli$_ivkeyw);
	    !
	    ! whatever, always return an error if we're in here
	    !
	    [always]      : return false;
	    tes;

    end;

return true;
end;

%sbttl 'getpflags - get old per day login flags'
global routine getpflags (qual_name) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get prime day login flag bit settings.
!
! INPUTS:
!
!	qual_name - address of descriptor for qualifier name
!
! IMPLICIT INPUTS:
!
!	OPFLAG_TABLE - table of flag bit numbers and ascii names
!	PRIMARY - true if getting primary day, false if secondary
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> successful completion
!	false -> error in flag name
!--

local
	status,
	keyword_dsc	: vector [2],
	no_flag,
	code,					! return from find_val
	ientry;

!
! Retrieve keywords as long as any are present
! 
while cli$get_value (.qual_name, tokendsc) do

    begin
    keyword_dsc [0] = .tokenlen;
    keyword_dsc [1] = .tokenptr;
    no_flag = 0;

    !
    ! Test for presence of 'NO'prefix.  If present, adjust descriptor
    !    to remove it, and set no_flag.
    !
    if ch$eql (2, .no_dsc [1], 2, .keyword_dsc [1])
    then

	begin
	keyword_dsc [0] = .keyword_dsc [0] - 2;
   	keyword_dsc [1] = .keyword_dsc [1] + 2;
	no_flag = -1;
	end;

    if (status = lib$lookup_key (keyword_dsc, opflag_table, code))
    then
        !
	! valid flag, set bit
	!
	case .code from uaf$k_disdialup to uaf$k_disnetwork of
	    set
	    [uaf$k_disdialup]:
		begin
		if .primary
		then recbuf[uaf$b_dialup_access_p] = not .no_flag
		else recbuf[uaf$b_dialup_access_s] = not .no_flag;
		end;
	    [uaf$k_disnetwork]:
		begin
		if .primary
		then recbuf[uaf$b_remote_access_p] = not .no_flag
		else recbuf[uaf$b_remote_access_s] = not .no_flag;
		end;
	    tes
    else
	select .status of
	    set
	    !
	    ! ambiguous keyword?
	    !
	    [lib$_ambkey] : signal (cli$_abkeyw);
	    !
	    ! unrecognized keyword?
	    !
	    [lib$_unrkey] : signal (cli$_ivkeyw);
	    !
	    ! whatever, always return an error if we're in here
	    !
	    [always]      : return false;
	    tes;

    end;

return true;
end;

%sbttl 'getrestrict - parse hourly restriction ranges'
global routine getrestrict (qual_name) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Parse hourly login restrictions for primary or secondary days
!
! INPUTS:
!
!	qual_name - descriptor of qualifier name to use
!
! IMPLICIT INPUTS:
!
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> successful completion
!	false -> error in flag name
!--

!
! Initialize output values.
!
primary_access = 0;
secondary_access = 0;

!
! Fetch value list items and parse them.
!
while true
do
    begin
    if not cli$get_value (.qual_name, tokendsc)
    then exitloop;

    tparse_block[tpa$l_stringcnt] = .tokenlen;
    tparse_block[tpa$l_stringptr] = .tokenptr;
    if not lib$tparse (tparse_block, access_states, access_keys)
    then return LIB$SIGNAL(UAF$_BADVALUE, 2, .tokenlen, .tokenptr);
    end;

!
! Write the modified fields into the UAF record.
!
if not .secondary
then
    begin
    recbuf[uaf$b_network_access_p] = .primary_access;
    recbuf[uaf$b_batch_access_p] = .primary_access;
    recbuf[uaf$b_local_access_p] = .primary_access;
    recbuf[uaf$b_dialup_access_p] = .primary_access;
    recbuf[uaf$b_remote_access_p] = .primary_access;
    end
else
    begin
    recbuf[uaf$b_network_access_s] = .secondary_access;
    recbuf[uaf$b_batch_access_s] = .secondary_access;
    recbuf[uaf$b_local_access_s] = .secondary_access;
    recbuf[uaf$b_dialup_access_s] = .secondary_access;
    recbuf[uaf$b_remote_access_s] = .secondary_access;
    end;

true
end;

%sbttl 'getprimedays - get primary day list'
global routine getprimedays =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get list of day considered prime days.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	PDFLAG_TABLE - table of flag bit numbers and ascii names
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> successful completion
!	false -> error in flag name
!--

local
	status,
	keyword_dsc	: vector [2],
	no_flag,
	code,					! return from find_val
	ientry;

!
! Retrieve keywords as long as they are present
!
while cli$get_value (sd_primedays, tokendsc) do

    begin
    keyword_dsc [0] = .tokenlen;
    keyword_dsc [1] = .tokenptr;
    no_flag = false;

    !
    ! Test for presence of the 'NO' prefix.  If present, adjust the
    !    descriptor to remove it, and set no_flag
    !
    if ch$eql (2, .no_dsc [1], 2, .keyword_dsc [1])
    then
	begin
	keyword_dsc [0] = .keyword_dsc [0] - 2;
   	keyword_dsc [1] = .keyword_dsc [1] + 2;
	no_flag = true;
	end;

    if (status = lib$lookup_key (keyword_dsc, pdflag_table, code))
    then
        !
	! valid flag, set bit
	!
	(recbuf[uaf$b_primedays])<.code,1> =  .no_flag
    else
	select .status of
	    set
	    !
	    ! ambiguous keyword?
	    !
	    [lib$_ambkey] : signal (cli$_abkeyw);
	    !
	    ! unrecognized keyword?
	    !
	    [lib$_unrkey] : signal (cli$_ivkeyw);
	    !
	    ! whatever, always return an error if we're in here
	    !
	    [always]      : return false;
	    tes;

    end;

return true;
end;

%sbttl 'getpriv - get process privileges'
global routine getpriv (qual_name, privadr) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Process privilege mask specification and set or
!	clear proper bits in privilege quadword in RECBUF.
!
! INPUTS:
!
!	qual_name - descriptor of qualifier name to use
!	privadr - address to store privilege bits
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> input processed successfully
!	false -> error in privilege specification
!
! SIDE EFFECTS:
!
!	none
!--

!
! Loop through if this is a list and check all of the names.
! Set or clear appropriate bits depending on the 'NO' prefix.
!

while cli$get_value (.qual_name, tokendsc) do
    begin

    select prv$setpriv (tokendsc, .privadr) of

	set
	!
	! Privilege name not found
	!
 	[prv$_invnam]:
	    return LIB$SIGNAL(UAF$_PRVNOTFND, 2, .tokenlen, .tokenptr);

	!
	! Privilege name not unique
	!
	[prv$_notunq]:
	    return LIB$SIGNAL(UAF$_PRVNOTUNQ, 2, .tokenlen, .tokenptr);

    tes;

    end;

return true;
end;

%sbttl 'getuic - get user identification code'
global routine getuic =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Process UIC specification
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!--

!
! Parse UIC and return error if invalid.
! Do not allow wild card group or member numbers
!

if not parse_uic (recbuf[uaf$w_grp], recbuf[uaf$w_mem], false)
then return LIB$SIGNAL(UAF$_UICERR, 2, .tokenlen, .tokenptr);

true
end;

%sbttl 'parse_uic - obtain UIC group and member'
global routine parse_uic (retgrp, retmem, allow_wild) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to parse and validate a UIC or directory string.
!	The UIC is returned as group and member elements.
!
! INPUTS:
!
!	RETGRP 		- address of a word to receive the group number
!	RETMEM 		- address of a word to receive the member number
!	ALLOW_WILD	- TRUE => allow wild card group/member numbers
!
! IMPLICIT INPUTS:
!
!	TOKENPTR - address of first character past delimiter
!
! OUTPUTS:
!
!	RETGRP and RETMEM receive group and member numbers if
!	no errors are encountered.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VAUE:
!
!	true -> no errors found
!	false -> error in UIC specification
!
! SIDE EFFECTS:
!
!	None
!--

!
! Crank UIC through tparse
!
tparse_block [tpa$l_stringcnt] = .tokenlen;
tparse_block [tpa$l_stringptr] = .tokenptr;

if not lib$tparse (tparse_block, uic_states, uic_keys)
then return false;
if .converted_uic<00,16> gtru uic$k_wild_member
or .converted_uic<16,16> gtru uic$k_wild_group
then return false;
if not .allow_wild
then
    if .converted_uic<00,16> eqlu uic$k_wild_member
    or .converted_uic<16,16> eqlu uic$k_wild_group
    then return false;

!
! UIC was successfully parsed.  Return correct data, plus true indicaton.
!

(.retgrp)<0,16> = .converted_uic<16,16>;
(.retmem)<0,16> = .converted_uic<0,16>;
return true;
end;

%sbttl 'parse_wild - parse wildcarded user specification'
global routine parse_wild (desc_addr,nulldefault) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Parse one of six methods by which User Authorization File
!	records may be specified.  This routine defines boolean
!	variables for input to the WILD_USER routine.
!
! INPUTS:
!
!	DESCADDR	Address of the token string descriptor
!	NULLDEFAULT	TRUE => A null user specification defaults to *
!
! IMPLICIT INPUTS:
!
!	The parsing variables NEXTTOKEN, TOKENLEN, and TOKENPTR are modified.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	The following boolean variables are decided:
!
!	UIC_FLAG - UIC form (instead of username)
!	GRP_WILD - Group wild card (implies UIC_FLAG)
!	MEM_WILD - Member wild card (implies UIC_FLAG)
!	STR_WILD - all users alphabetically (implies NOT UIC_FLAG)
!
!	RECBUF - The appropriate keys are initialized
!
! ROUTINE VALUE:
!
!	If the syntax does not follow one of the six methods the routine
!	returns FALSE.  The outputs are meaningful only when the value
!	returned is TRUE.
!
!--


! Identify the next token in the command buffer.
!

if not cli$present (.desc_addr) or
   not cli$get_value (.desc_addr, tokendsc) or
   .tokenlen eql 0
then
    if not .nulldefault
    then
        return LIB$SIGNAL(UAF$_NOUSERSPEC)
    else
        begin
	uic_flag = false;
	grp_wild = false;
	mem_wild = false;
	str_wild = true;
	match_token = '*';
	match_tokenlen = 1;
	return true;
	end
else
    begin
    tokenlen = .tokenlen;
    tokenptr = .tokenptr;
    end;


!
! Decide whether a UIC or a Username form was used.
!

if .(.tokenptr)<0,8> eql '['
then
    begin

    if not parse_wild_uic ( .tokenlen, .tokenptr )
    then
  	return LIB$SIGNAL(UAF$_INVUSERSPEC, 2, .tokenlen, .tokenptr);

    end
else
    begin
    uic_flag = false;
    grp_wild = false;
    mem_wild = false;

    !
    ! Decide whether or not the Username is wildcarded.
    !

    if not ch$fail (ch$find_ch (.tokenlen, .tokenptr, '*'))
	  or
       not ch$fail (ch$find_ch (.tokenlen, .tokenptr, '%'))
!	  OR
!       .by_account
    then
	begin
	match_tokenlen = .tokenlen;
	ch$move (.tokenlen, .tokenptr, match_token);
	str_wild = true;
	end
    else
	begin
	str_wild = false;
	ch$copy (.tokenlen, .tokenptr, %char (' '),
			uaf$s_username, recbuf[uaf$t_username]);
	end;
    end;

true
end;

%sbttl 'parse_wild_uic - parse wildcarded UIC'
global routine parse_wild_uic ( strlen, strptr ) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Parse the uic methods by which User Authorization File
!	records may be specified.  This routine defines boolean
!	variables for input to the WILD_USER routine.
!
! INPUTS:
!
!	STRLEN  - Length of UIC string
!	STRPTR	- Address of UIC string
!
! IMPLICIT INPUTS:
!
!
! OUTPUTS:
!
!	True  - success
!	False - failure
!
! IMPLICIT OUTPUTS:
!
!	The following boolean variables are decided:
!
!	UIC_FLAG - UIC form (instead of username)
!	GRP_WILD - Group wild card (implies UIC_FLAG)
!	MEM_WILD - Member wild card (implies UIC_FLAG)
!	STR_WILD - all users alphabetically (implies NOT UIC_FLAG)
!
!	RECBUF - The appropriate keys are initialized
!
! ROUTINE VALUE:
!
!	If the syntax does not follow one of the six methods the routine
!	returns FALSE.  The outputs are meaningful only when the value
!	returned is TRUE.
!
!--

uic_flag = true;
str_wild = false;

!
! Crank UIC through tparse
!
tparse_block [tpa$l_stringcnt] = .strlen;
tparse_block [tpa$l_stringptr] = .strptr;

if not lib$tparse (tparse_block, uic_states, uic_keys)
then
    return false ;

!
! Decide whether or not the Group subfield is wildcarded.
!
if .converted_uic<16,16> eql uic$k_wild_group
then
    begin
    grp_wild = true;
    recbuf[uaf$w_grp] = 0;
    end

else
    begin
    grp_wild = false;
    recbuf[uaf$w_grp] = .converted_uic<16,16>;
    end;

!
! Decide whether or not the Member subfield is wildcarded.
!

if .converted_uic<0,16> eql uic$k_wild_member
then
    begin
    mem_wild = true;

    !
    ! Whether it is wildcarded or not this subfield is initialized
    ! for the wildcard processor.
    !

    recbuf[uaf$w_mem] = 0;
    end
else
    begin
    mem_wild = false;
    recbuf[uaf$w_mem] = .converted_uic<0,16>;
    end;

return true ;
end ;

%sbttl 'getstring - get string from input'
global routine getstring (addr, maxsize, type) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a string variable and stores it as
!	a blank filled or counted string in the field supplied.
!	The first character is checked to see if it is a quote
!	or double quote and if so, a different terminator
!	set is used so that embedded blanks may be contained
!	in the string.
!
! INPUTS:
!
!	ADDR - address to store string
!	MAXSIZE - size of field in which string will be stored.
!		 If this is a counted string, the maximum input
!		 acceptable is MAXSIZE - 1
!	TYPE - string type, either COUNTED_STRING or FILLED_STRING
!
! IMPLICIT INPUTS:
!
!       none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> string inserted successfully
!	false -> string too long
!
! SIDE EFFECTS:
!
!	none
!--


if .type eql counted_string
then
    maxsize = .maxsize - 1;

if .tokenlen gtr .maxsize
then
    return
	LIB$SIGNAL(UAF$_INVSTR, 2, .tokenlen, .tokenptr);

if .type eql counted_string
then
    begin
    (.addr)<0,8> = .tokenlen;
    ch$copy (.tokenlen, .tokenptr, %char (blank),
		.maxsize-1, .addr+1);
    end 
else
    ch$copy (.tokenlen, .tokenptr, %char (blank),
		.maxsize, .addr);
return true;
end;

%sbttl 'getval - get numeric value from user'
global routine getval (addr, size) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to return binary value for next ASCII decimal
!	number in the input stream.
!
! INPUTS:
!
!	ADDR - address to return converted value
!	SIZE - size in bits of field in which to return value
!
! IMPLICIT INPUTS:
!
!	NEXTTOKEN - contains address of delimiter preceeding the number
!
! OUTPUTS:
!
!	field described by ADDR and SIZE receives binary value
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> value converted successfully
!	false -> non-numeric character encounted before next
!		delimiter found
!
! SIDE EFFECTS:
!
!	If error is encountered, an error message will be printed.
!
!--

local
	value;				! for value returned
					! by CVTNUM routine

!
! Check for no value supplied
!

if .tokenlen eql 0
then
    return LIB$SIGNAL(UAF$_NOARG, 2, .tokenlen, .tokenptr);

!
! Convert to decimal. Report error if any non-numerics encountered.
!

if not cvtnum (.tokenlen, .tokenptr, 10, value)
then
    return LIB$SIGNAL(UAF$_BADVALUE, 2, .tokenlen, .tokenptr);

!
! Check that the value supplied is within the size of
! the field to be stored.
!

if .value<.size - 1, 32 - .size + 1> neq 0
then
    return LIB$SIGNAL(UAF$_VALTOOBIG, 2, .tokenlen, .tokenptr);

!
! Finally, store the value in field specified .
!

(.addr)<0, .size> = .value;

return true;
end;

%sbttl 'cvtnum - convert decimal ascii to binary'
routine cvtnum (size, adr, radix, valadr) =
begin

!++
!
! FUNCTIONAL DESCIRPTION:
!
!	Routine to convert ascii digits to binary.
!
! INPUTS:
!
!	SIZE - number of digits in input buffer
!	ADR - address of the buffer containing ascii digits
!	RADIX - radix of number to be converted
!	VALADR - address of longword to receive converted value
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	longword pointed to by VALADR receives converted value
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> value successfully converted
!	false -> non-numeric encountered before end of string
!
! SIDE EFFECTS:
!
!	none
!--

bind
	sum = .valadr;			! address ref scaler


sum = 0;

!
! Loop thorugh buffer.  Stop on end of string or non-decimal digit.
!

incr i from .adr to  (.adr + .size - 1)
do
    begin
    local
	digit,
	pointer;

    digit = .(.i)<0,8>;

    !
    ! Check validity of digit depending on radix
    !


    if ch$fail (pointer = ch$find_ch (.radix, numbers, .digit)) 
    then
	return false
    else
	sum = (.sum*.radix) +  (.pointer - numbers)
    end;

return true;
end;

%sbttl 'PASSWORD MACROS -- for N-ary passwords'

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	These macros and the routines that follow allow for
!	the use of any number of passwords. At the time of 
!	this writing, only two (primary and secondary) pass-
!	words were in effect. When a change is made to the 
!	number of passwords, it will be necessary, only, to
!	update the argument list macros below.
!
!--

macro

   $NARY_LIST	= 'PRIMARY', '', 'SECONDARY', '2' %,
   $N_LIST	=            '',              '2' %;

!
!	The remainder of the text will need no modification for N-ary passwords
!

macro $PASSWORD(n) = %name('PASSWORD_',n) %;
macro $PRESENT(n) = %name('PRESENT_',n) %;

macro OWN_PASSWORD[n] =
   own $PASSWORD(n): block[DSC$K_D_BLN, byte]
      preset([DSC$B_CLASS] = DSC$K_CLASS_D); %;

OWN_PASSWORD($N_LIST);

%sbttl 'UAF$GENERATE -- Generate random passwords'
routine UAF$GENERATE =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Decide which passwords to generate
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	CLI$GET_VALUE(%ascid'GENERATE_PASSWORD')
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	Places new values in $PASSWORD(n)'s
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

   own WHICH: block[DSC$K_D_BLN, byte] preset([DSC$B_CLASS] = DSC$K_CLASS_D);

   macro ACTIVE_PASSWORD(n) =
      ch$neq(%name('UAF$S_PWD',n), RECBUF[%name('UAF$Q_PWD',n)], 0, 0, 0) %;
   macro WHICH_EQL[THIS] =
      ch$eql( .WHICH[DSC$W_LENGTH], .WHICH[DSC$A_POINTER],
                 %charcount(THIS), uplit(%ascii %string(THIS)) ) %;
   macro GENERATE_NEW_PASSWORD[THIS, n] =
      if (ACTIVE_PASSWORD(n) and (FALSE or WHICH_EQL('CURRENT')))
      or WHICH_EQL(THIS, 'BOTH', 'ALL') then
         AUTHORIZE_GENERATE($PASSWORD(n), uplit(%ascii THIS), %charcount(THIS))
      else
         $PASSWORD(n)[DSC$W_LENGTH] = 0; %;

   CLI$GET_VALUE(%ascid'GENERATE_PASSWORD', WHICH);
   GENERATE_NEW_PASSWORD($NARY_LIST);

   return TRUE;

end;

%sbttl 'GETPASSWORD - get user password'
routine GETPASSWORD =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Action routine to process password.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	sets hashed password field in recbuf
!
! ROUTINE VALUE:
!
!	true -> success
!	false -> failure
!
! SIDE EFFECTS:
!
!	none
!--

   own

      USER_DSC: $bblock[8],
      REC_ENCRYPT_DSC: $bblock[8];

   macro LOCAL_PRESENT[n] =
      local $PRESENT(n): initial(TRUE); %;

   LOCAL_PRESENT($N_LIST);

!
!	What are the passwords ???
!

   if CLI$PRESENT(SD_PASSWORD) eql CLI$_NEGATED then
      begin
         macro BLANK_PASSWORD[n] = $PRESENT(n) = FALSE; %;
         BLANK_PASSWORD($N_LIST);
      end
   else if CLI$PRESENT(SD_PASSWORD) then
      begin
         macro GET_PASSWORD[n] =
            $PASSWORD(n)[DSC$W_LENGTH] = 0;
            $PASSWORD(n)[DSC$A_POINTER] = 0;
            $PRESENT(n) = CLI$GET_VALUE(SD_PASSWORD, $PASSWORD(n)); %;
         GET_PASSWORD($N_LIST);
      end;

!
!	When is it being changed ???
!

   $GETTIM(timadr=TIME_BUF);

!
!	If this is a new password ...
!

   if .RECBUF[UAF$W_SALT] eql 0 then
      RECBUF[UAF$W_SALT] = .TIME_BUF<3*8,16>;

!
!	Find the length of the username
!

   begin

      builtin LOCC;
      builtin R0;
      LOCC(%ref(%char(BLANK)), %ref(UAF$S_USERNAME), RECBUF[UAF$T_USERNAME]);
      USER_DSC[DSC$W_LENGTH] = UAF$S_USERNAME - .R0;
      USER_DSC[DSC$A_POINTER] = RECBUF[UAF$T_USERNAME];

   end;

!
!	Check the new passwords for syntax
!

   begin

      macro CHECK_PASSWORD[n] =

         if .$PASSWORD(n)[DSC$W_LENGTH] gtru 31 then
            return LIB$SIGNAL(UAF$_PWDSYNTAX);
         incr COUNTER to .$PASSWORD(n)[DSC$W_LENGTH]-1 do
            if ch$fail( ch$find_ch(.SYMBOL_STR<0,8>, SYMBOL_STR+1,
                        .vector[.$PASSWORD(n)[DSC$A_POINTER],
                        .COUNTER;, byte]) )
            then
               return LIB$SIGNAL(UAF$_PWDSYNTAX); %;

      CHECK_PASSWORD($N_LIST);

   end;

!
!	Modify the passwords
!

   begin

      macro MODIFY_PASSWORD[n] =

         if not .$PRESENT(n) then
            begin ! Blank out the current values

               ch$fill(0, %name('UAF$S_PWD',n), RECBUF[%name('UAF$Q_PWD',n)]);
               ch$fill(0, %name('UAF$S_PWD',n,'_DATE'),
                          RECBUF[%name('UAF$Q_PWD',n,'_DATE')]);

               RECBUF[%name('UAF$V_PWD',n,'_EXPIRED')] = FALSE;
               PWD_FLAG = FALSE;

            end
         else if .$PASSWORD(n)[DSC$W_LENGTH] neq 0 then
            begin ! Encrypt the new values

               RECBUF[%name('UAF$B_ENCRYPT',n)] = ENCRYPT;
               REC_ENCRYPT_DSC[DSC$W_LENGTH] = %name('UAF$S_PWD',n);
               REC_ENCRYPT_DSC[DSC$A_POINTER] = RECBUF[%name('UAF$Q_PWD',n)];
               PWD_FLAG = FALSE;

               LGI$HPWD(REC_ENCRYPT_DSC, $PASSWORD(n),
                  .RECBUF[%name('UAF$B_ENCRYPT',n)], .RECBUF[UAF$W_SALT],
                  user_dsc);

               ch$move( %name('UAF$S_PWD',n,'_DATE'), TIME_BUF,
                        RECBUF[%name('UAF$Q_PWD',n,'_DATE')]);

            end; %;

      MODIFY_PASSWORD($N_LIST);

   end;

!
!	That's all folks ...
!

   return TRUE;

end;

%sbttl 'AUTHORIZE_GENERATE -- Interface to PL/I GENERATE_PASSWORDS routine'
routine AUTHORIZE_GENERATE( NEW_PASSWORD: ref block[DSC$K_D_BLN, byte],
                            THIS, TLENGTH ) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Interface to PL/I procedure GENERATE_PASSWORD, which
!	generates random, pronounceable passwords. This routine
!	must prompt the user for input with NOECHO in effect
!
! INPUTS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	Input from user terminal.
!
! OUTPUTS:
!
!	PASSWORD, by descriptor.
!
! IMPLICIT OUTPUTS:
!
!	User prompt.
!
! ROUTINE VALUE:
!
!	None
!
! NOTE:
!
!	PL/I apparently uses a form of ASCIC to represent its strings,
!	however, PL/I uses a word for the character count, not a byte.
!
!--

   macro

      DSC$L_L1 = 24, 0, 32, 0 %,
      DSC$L_U1 = 28, 0, 32, 0 %;

   literal

      MAX = 10,
      MIN = 6,
      N_WORDS = 5;

   own

      CHANNEL,
      DSC: block[DSC$K_S_BLN, byte] preset([DSC$B_CLASS]=DSC$K_CLASS_S),
      FUNCTION: initial(IO$_READPROMPT or IO$M_CVTLOW or IO$M_NOECHO),
      PLENGTH,
      PROMPT: vector[45, byte] preset([0]=13, [1]=10,
         [2]='E', [3]='n', [4]='t', [5]='e', [6]='r', [7]=' ');

   bind

      P2 = UPLIT(' password: ');

!
!	The password generator requires a complex descriptor
!

   macro PLI$VARYING_CHARACTER_ARRAY[NAME, LENGTH, WIDTH] =

      own

         %name(NAME): blockvector[LENGTH, (WIDTH+2), byte],
         %name(NAME,'_DSC'): block[32, byte]
            preset([DSC$W_MAXSTRLEN] = WIDTH,
                   [DSC$B_DTYPE] = 37,
                   [DSC$B_CLASS] = DSC$K_CLASS_VSA,
                   [DSC$A_POINTER] = %name(NAME),
                   [DSC$B_DIMCT] = 1,
                   [DSC$A_A0] = %name(NAME) - (WIDTH+2),
                   [DSC$L_S1] = (WIDTH+2),
                   [DSC$L_L1] = 1,
                   [DSC$L_U1] = LENGTH); %;

   PLI$VARYING_CHARACTER_ARRAY('PWD', N_WORDS, MAX, 'HYPH', N_WORDS, 2*MAX);

!
!	Build the prompt string
!

   ch$move(.TLENGTH, .THIS, PROMPT[8]);
   ch$move(11, P2, PROMPT[8+.TLENGTH]);

   PLENGTH = 8 + .TLENGTH + 11;

!
!	Open a channel to the user
!

   SYS$ASSIGN(%ascid'SYS$COMMAND:', CHANNEL, 0, 0);
   NEW_PASSWORD[DSC$W_LENGTH] = 0;

!
!	Generate random passwords ...
!

   while .NEW_PASSWORD[DSC$W_LENGTH] eql 0 do
      begin

         own
            BUFFER: vector[128, byte],
            IOSB: vector[4, word],
            LISTED;

         LISTED = FALSE;

         SYS$QIOW(0, .CHANNEL, IO$_WRITEVBLK, 0,0,0, 0, 0, 0, 32, 0,0);

         GENERATE_PASSWORDS(PWD_DSC, HYPH_DSC,
            uplit(MIN), uplit(MAX), uplit(N_WORDS));

         SYS$QIOW(0, .CHANNEL, IO$_WRITEVBLK, 0,0,0, 0, 0, 0, 32, 0,0);

         incr i to N_WORDS-1 do
            begin
               DSC[DSC$W_LENGTH] = .PWD[.i, 0, 0, 16, 0];
               DSC[DSC$A_POINTER] = PWD[.i, 2, 0, 0, 0];
               STR$UPCASE(DSC, DSC);
            end;

         while not .LISTED do
            begin

               SYS$QIOW(0, .CHANNEL, .FUNCTION, IOSB, 0, 0,
                  BUFFER, 127, 0, 0, PROMPT, .PLENGTH);

               if .BUFFER[.IOSB[1]] eql 26 then ! CTRL/Z
                  return LIB$SIGNAL(UAF$_PWDNCH, 2, .TLENGTH, .THIS)
               else if .IOSB[1] eql 0 then
                  exitloop;

               incr i to N_WORDS-1 do
                  LISTED = .LISTED or 
                     ch$eql(.IOSB[1], BUFFER,
                        .PWD[.i, 0, 0, 16, 0], PWD[.i, 2, 0, 0, 0]);

               if .LISTED then
                  begin
                     NEW_PASSWORD[DSC$W_LENGTH] = .IOSB[1];
                     LIB$GET_VM(%ref(.IOSB[1]), NEW_PASSWORD[DSC$A_POINTER]);
                     ch$move(.IOSB[1], BUFFER, .NEW_PASSWORD[DSC$A_POINTER]);
                  end
               else
                  LIB$SIGNAL(UAF$_PWDNOL);

            end;

      end;

!
!	That's all folks ...
!

   return SYS$DASSGN(.CHANNEL);

end;

end
eludom
