	.TITLE	READREC - READ AN INPUT RECORD
	.IDENT	'V04-000'
	.DEFAULT DISPLACEMENT,WORD

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ABSTRACT:
;
;	These routines are called by the lexical processing routines to
;	perform functions which are optional to the basic lexical routines,
;	but are required by CLI parsing.
;
; AUTHOR:
;
;	Tim Halvorsen, Jan-1982
;
; MODIFIED BY:
;
;	V03-021	HWS0092		Harold Schultz	22-Jul-1984
;		Add support for execute-only command procedures.
;
;	V03-020	HWS0077		Harold Schultz	29-Jun-9184
;		If EOF encountered when reading a command procedure
;		while processing a line continuation, ignore termination
;		and return EOL.
;
;	V03-019	HWS0072		Harold Schultz	08-Jun-1984
;		Partially undo HWS0006 (setting of the parse position).
;		Set the parse position prior to processing the @FILESPEC
;		construct, but save the old parse position set by the
;		higher level routines and restore it after the '@' processing
;		has successfully completed.
; 
;	V03-018	HWS0039		Harold Schultz	26-Mar-1984
;		When using arrow keys, don't duplicate command when changing
;		directions in recalling commands and are at the beginning of
;		the buffer.
;
;	V03-017	HWS0034		Harold Schultz	16-Mar-1984
;		Always use terminal RAB when outputting escape sequences
;		and arrow keys.
;
;	V03-016	HWS0006		Harold Schultz	13-Feb-1984
;		Remove parse location setting (DCL$MARK) when
;		processing an indirect command file. Let higher
;		level routines set parse location.
;		Use PRC_V_CARRCNTL to determine whether or not
;		a CR/LF is to be inserted before the prompt string.
;		Fix RECALL_NEXT so it will not skip first command
;		at bottom of command buffer when recall buffer
;		not full.
;		Save RMS STS and STV values in PRC data table
;
;	V03-015	PCG0017		Peter George	03-Jan-1984
;		Move location of test for PRC_V_FLUSH.
;
;	V03-014	PCG0017		Peter George	03-Jan-1984
;		Use PRC_V_FLUSH to deterime how to handle EOF when
;		peforming a flush.
;
;	V03-013	PCG0016		Peter George	18-Nov-1983
;		Support up and down arrow recall.
;		Do not automatically close command procedures when
;		flushing a record.  Add support for erase keypad attribute.
;
;	V03-012	PCG0015		Peter George	27-Sep-1983
;		Ignore spurious CTRL/Y's.
;		Only check for CTRL/B's and ESC if input is from terminal.
;
;	V03-011	PCG0014		Peter George	17-Jul-1983
;		Support 20 recalled commands.
;
;	V03-010	PCG0013		Peter George	01-May-1983
;		Correctly signal keypad buffer overflows.
;		Fix CTRL/Y interrupting GOTO bug.
;
;	V03-009	PCG0012		Peter George	20-Apr-1983
;		Check for CTRL/B with CMPB.
;
;	V03-008	PCG0011		Peter George	06-Apr-1983
;		Remove GOTO code.
;		Reformat DCL$INPUT code.
;		Change test for escape sequence.
;		Allow the RECALL command to accept letters as arguments.
;		Update recall buffer when at ctrl/y level.
;
;	V03-007	PCG0010		Peter George	01-Apr-1983
;		Change STV MOVZWL to MOVZBL.
;
;	V03-006	PCG0009		Peter George	24-Feb-1983
;		Do not verify lines in EXE-only command procedures.
;		Lookup terminating escape sequences in the keypad
;		symbol table and act on them.
;		Use new XABTRM and init appropriate fields in its item list.
;		Add RECALL command and CTRL/B processing.
;
;	V03-005	PCG0008		Peter George	10-Feb-1983
;		Close SYS$OUTPUT on silent logout.
;
;	V03-004	PCG0007		Peter George	15-Jan-1983
;		Supply more rigourous test of whether commands
;		should be verified.  Close PPF files before silent logout.
;
;	V03-003	PCG0006		Peter George	28-Dec-1982
;		If $GET fails because of insufficient quota,
;		then log the process out.
;
;	V03-002	PCG0005		Peter George	14-Nov-1982
;		Call DCL$UPCASE instead of DCL$REMBLANKS
;		Use prompt descriptor instead of WRK_L_PROMPT.
;
;	V03-001	PCG0004		Peter George	28-Oct-1982
;		Get prompt string from PRC.
;		Process escape sequences.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	ITRMDEF				;XABTRM ITEM LIST DEFINITIONS
	SYMDEF				;DEFINE SYMBOL TABLE ENTRY FORMAT
	PTRDEF				;DEFINE TOKEN DESCRIPTORS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$FABDEF				;DEFINE FAB OFFSETS
	$RABDEF				;DEFINE RAB OFFSETS
	$XABTRMDEF			;DEFINE TERMINAL XAB
	$DVIDEF				;DEFINE $GETDVI ITEM CODES
	$TT2DEF				;DEFINE DEVDEPEND2 BITS
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

ERASE:	.BYTE	4
	.LONG	^X4B5B1B0D		;<CR>ESC[K

	.SBTTL	READ NEXT INPUT RECORD
;+
; DCL$INPUT - READ NEXT INPUT RECORD
;
; READS THE NEXT INPUT RECORD AND PLACES IT INTO THE INPUT BUFFER.
; THE CHARACTER POINTER IS RESET TO THE BEGINNING OF THE RECORD.  A
; SYMBOL SUBSTITUTION PASS IS PERFORMED IF A SINGLE OCCURRENCE OF A
; SINGLE QUOTE IS DETECTED IN THE RECORD.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;	R10 = ADDRESS OF WRK AREA
;
; OUTPUTS:
;
;	WRK_L_CHARPTR POINTS TO BEGINNING OF INPUT RECORD, WHICH
;		HAS BEEN TERMINATED BY A NULL BYTE.
;
;	R0 = FIRST CHARACTER IN INPUT BUFFER
;-
DCL$INPUT::					;INPUT NEXT RECORD
	PUSHR	#^M<R2,R3,R4>			;SAVE REGISTERS

;
; IF AUTOLOGO FLAG SET AND WE ARE AT LEVEL 0 OR CTRL/Y LEVEL,
; THEN DELETE THIS PROCESS TO PERFORM AN IMPLIED LOGOUT BUT WITHOUT
; ANY LOGOUT MESSAGE.  THIS IS FOR THE SPAWN COMMAND.
;
REINP:	BBC	#PRC_V_AUTOLOGO,PRC_W_FLAGS(R11),20$ 	;BRANCH IF FLAG NOT SET
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),20$ 	;BRANCH IF INQUIRE
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ 	;IF SET, AT CONTROL Y/C LEVEL
	TSTL	PRC_L_INDEPTH(R11)			;INDIRECT LEVEL ZERO?
	BNEQ	20$					;BRANCH IF NOT
10$:	BRW	SILENT_LOGOUT				;PERFORM SILENT LOGOUT

;
; GET ADDRESS OF THE RAB ASSOCIATED WITH THIS INDIRECT LEVEL
;
20$:	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),30$ 	;IF SET, QUERY IN PROGRESS
	MOVL	PRC_L_INDINPRAB(R11),R4			;GET ADDRESS OF LEVEL N RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),40$ 	;IF CLR, NOT AT CONTROL Y/C LEVEL
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),40$	;IF SET, AT GOTO LEVEL
30$:	MOVL	PRC_L_INPRAB(R11),R4			;GET ADDRESS OF LEVEL 0 RAB

;
; SETUP PROMPT STRING
;
40$:	MOVL	PRC_L_TRMLIST(R11),R0			;GET ADDRESS OF XABTRM ITEM LIST
	MOVW	WRK_W_PMPTLEN(R10),ITRM_W_PMPTLEN(R0)	;SET LENGTH OF PROMPT STRING
	MOVL	WRK_L_PMPTADDR(R10),ITRM_L_PMPTADDR(R0)	;SET ADDRESS OF PROMPT STRING


;
; SETUP INPUT BUFFER AND POINTERS.
;
GET_INPUT:
	MOVW	#WRK_C_INPBUFSIZ,RAB$W_USZ(R4) 		;SET SIZE OF INPUT BUFFER
	MOVAB	WRK_G_INPBUF-2(R10),R2			;GET ADDRESS OF INPUT BUFFER
	MOVL	R2,RAB$L_UBF(R4)			;SET ADDRESS OF INPUT BUFFER
	MOVAB	-1(R2),WRK_L_CHARPTR(R10) 		;SET POINTER FOR GET CHARACTER

;
; READ THE NEXT INPUT RECORD AND CHECK FOR ERRORS.
;
	DISABLE						;DISABLE CONTROL Y/C AST'S
	BBC	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),10$	;SKIP IF NOT INQUIRING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)		;SET INDIRECT PPF
10$:	$GET	RAB=(R4)				;GET NEXT RECORD FROM INPUT FILE
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)		;CLEAR INDIRECT PPF
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),20$	;BRANCH IF NO CTRL/Y PENDING
	BBC	#DEV$V_TRM,RAB$L_CTX(R4),20$		;SKIP IF NOT TERMINAL
	CMPL	R0,#RMS$_CONTROLY			;DOUBLE CHECK FOR WINDOW
	BNEQ	15$					;SPURIOUS CTRL/Y
	MOVL	RAB$L_XAB(R4),R1			;GET ADDRESS OF XABTRM
	MOVL	#ITRM_K_MINLEN,-			;SET SHORT LENGTH OF ITEM LIST
		XAB$W_ITMLST_LEN(R1)			;
	BSBW	DCL$LOCKED_STATE			;RESTORE LOCKED STATE
	BRB	20$					;
15$:	CLRBIT	PRC_V_CNTRLY,PRC_W_FLAGS(R11)		;IGNORE THIS CTRL/Y
20$:	ENABLE						;ENABLE CONTROL Y/C AST'S
	BLBS	R0,PROCESS_INPUT			;IF LBC I/O ERROR
	CMPW	R0,#RMS$_SYS&^XFFFF			;ERROR IN QIO?
	BNEQ	ERROR1					;NO, THEN SKIP
	MOVL	RAB$L_STV(R4),R0			;GET PARTICULAR ERROR STATUS
ERROR1:	BRW	IO_ERROR				;ERROR


;
; READ COMPLETED SUCCESSFULLY.  CLEAN UP AND THEN PROCESS THE INPUT RECORD.
;
PROCESS_INPUT:
	MOVZWL	RAB$W_RSZ(R4),R3			;GET LENGTH OF INPUT RECORD
	MOVL	RAB$L_XAB(R4),R1			;GET ADDRESS OF XABTRM
	MOVL	#ITRM_K_MINLEN,-			;SET SHORT LENGTH OF ITEM LIST
		XAB$W_ITMLST_LEN(R1)			;
	MOVL	PRC_L_TRMLIST(R11),R0			;GET ADDRESS OF XABTRM ITEM LIST
	BBC	#PRC_V_CARRCNTL,PRC_W_FLAGS(R11),2$	;SKIP IF NO CR/LF INDICATED
	MOVW	DCL$CRLF,@ITRM_L_PMPTADDR(R0)		;INSERT A CR/LF OTHERWISE
;
; IF IN THE MIDST OF A GOTO SCAN, THEN SKIP THE UNNECCESSARY PROCESSING.
;
2$:	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),10$	;SKIP IF NOT GOTO READ
	CLRB	(R2)[R3]				;SET EOL
	BRW	RETURN					;RETURN
5$:	BRW	GET_INPUT				;

;
; CHECK FOR CTRL/B AND DEFINED KEYS.
;
10$:	BBC	#DEV$V_TRM,RAB$L_CTX(R4),12$		;SKIP IF NOT TERMINAL
	BSBW	PROCESS_RECALL				;CHECK FOR RECALL CHAR
	CMPL	R0,#3					;REPROMPT REQUESTED?
	BEQL	5$					;YES, DO IT
	BSBW	PROCESS_ESCAPE				;PROCESS ESCAPE SEQUENCES
	CMPL	R0,#3					;REPROMPT REQUESTED?
	BEQL	5$					;YES, DO IT
	CLRB	(R2)[R3]				;SET EOL INDICATOR
	BLBC	R0,ERROR1				;BRANCH IF ERROR

;
; IF INTERACTIVE AND IF THE RECORD IS NON-NULL, THEN COPY THE COMMAND LINE 
; TO THE RECALL BUFFER.
;
12$:	CLRB	(R2)[R3]				;SET EOL INDICATOR
	TSTL	R3					;NULL COMMAND?
	BEQL	40$					;YES, THEN SKIP
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),40$ 	;IF SET, BATCH JOB
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),15$	;IF SET, CTRL/Y LEVEL
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),15$	;IF SET, INQUIRING
	TSTL	PRC_L_INDEPTH(R11)			;INTERACTIVE LEVEL 0?
	BNEQ	40$					;IF NO, DON'T SAVE
15$:	PUSHL	R2					;PUSH COMMAND ADDR
	PUSHL	R3					;PUSH COMMAND LEN
	PUSHL	SP					;PUSH DESCR ADDR
	BBS	#WRK_V_CONTIN,WRK_W_FLAGS(R10),20$	;IS IT CONTIN TYPE PROMPT?
	CALLS	#1,DCL$PUT_COMMAND			;SAVE THE COMMAND AWAY
	BRB	30$					;BRANCH
20$:	CALLS	#1,DCL$PUT_SEGMENT			;SAVE THE SEGMENT AWAY
30$:	POPL	R3					;RESTORE R3
	POPL	R2					;RESTORE R2

;
; SUBSTITUTE ANY SYMBOLS WHICH ARE DELIMITED BY SINGLE QUOTES
;
40$:	LOCC	#^A/'/,R3,(R2)				;LINE HAVE POSSIBLE STRING SUBSTITUTION?
	BEQL	50$					;IF EQL NO
	BSBW	EXPAND					;EXPAND LINE IF APPROPRIATE

;
; IF VERIFY MODE, WRITE A COPY OF THE COMMAND LINE TO THE LOG FILE
;
50$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),70$	;IF CLR, NO LINE VERIFICATION
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),70$ 	;IF SET, AT CONTROL Y/C LEVEL
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),60$ 	;IF SET, BATCH JOB
	TSTL	PRC_L_INDEPTH(R11)			;INTERACTIVE LEVEL 0?
	BEQL	70$					;IF YES, DON'T ECHO
	TSTB	PRC_B_EXONLYL(R11)			;EXE-ONLY PROCEDURE?
	BNEQ	70$					;IF YES, DON'T ECHO
60$:	MOVL	R3,R1					;THE LENGTH OF THE LINE
	BSBW	DCL$MSGOUT				;OUTPUT INPUT LINE

;
; IF WE JUST READ A FULL-LINE COMMENT, RE-ISSUE READ NOW AS AN OPTIMIZATION.
; 
70$:	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),RETURN	;MUST TAKE IMMEDIATE ACTION
							;IF CTRLY HIT - SKIP OPTIMIZATION
	CLRL	R4					;SET NO DOLLAR SIGN SEEN FLAG
80$:	LOCC	(R2)+,#5,B^SPECIAL			;CHECK FOR SPECIAL CHARS
	BEQL	RETURN					;IF EQL NO MATCH
	SUBL	#3,R0					;BLANK OR TAB?
	BLSS	80$					;IF LSS YES
	BEQL	RETURN					;IF EQL END OF LINE
	DECL	R0					;DOLLAR SIGN OR COMMENT?
	BLEQU	90$					;IF LEQU DOLLAR SIGN
	BBS	#PRC_V_IND,PRC_W_FLAGS(R11),RETURN	;BRANCH IF FLUSHING RECORD
	BRW	REINP					;GET NEXT RECORD
90$:	BBCS	#0,R4,80$				;IF CLR, FIRST DOLLAR SIGN

;
; IF THE PREVIOUS RECORD ENDED WITH TRAILING SPACES OR TABS,
; INSERT A SPACE AT THE FRONT OF THE CURRENT INPUT RECORD SO
; THAT PARAMETERS ARE DELIMITED PROPERLY.
;
RETURN:	BBCC	#WRK_V_TRAILSPC,WRK_W_FLAGS(R10),10$ 	;IF CLR, NO TRAILING SPACE SEEN
	MOVB	#^A/ /,R0				;SET SPACE CHARACTER
	BSBW	DCL$BACKUPCHAR				;APPEND TO FRONT OF INPUT BUFFER
10$:	POPR	#^M<R2,R3,R4>				;RESTORE REGISTERS
	MOVB	#^A/_/,PRC_B_CONTINUE(R11) 		;SET FOR CONTINUATION PROMPT
	BSBW	DCL$GETCHAR				;GET FIRST CHARACTER OF NEW RECORD
	RSB
 
SPECIAL:
	.ASCII	/!$/<0>/ 	/			;SPECIAL CHARACTERS

;
; AN INPUT I/O ERROR HAS OCCURRED.  IF WE GOT "RECORD STREAM ACTIVE",
; TRY REPEATING THE READ 1000 TIMES.  IF THAT FAILS, TRY CANCELING ALL 
; I/O ON THE INPUT CHANNEL AND THEN REISSUING THE READ.
;
IO_ERROR:
	CMPW	R0,#RMS$_RSA&^XFFFF			;ERROR RECORD STREAM ACTIVE
	BNEQ	30$					;IF NO CHECK FOR END_OF_FILE

	;
	; WE DON'T WANT TO HAVE TO CANCEL AN RMS I/O UNLESS NECESSARY.
	; RETRY UP SEVERAL TIMES TO ALLOW CURRENT WRITE I/O TO COMPLETE.
	; THIS AVOIDS SPURIOUS WRITE ABORT MESSAGES FROM USER PROGRAMS,
	; CAUSED BY CANCELING AN RMS I/O OPERATION.
	;
	MOVZWL	#1000,R2				;SETUP RETRY COUNT
	BBC	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),10$ 	;SKIP IF NOT INQUIRING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)		;SET INDIRECT PPF
10$:	$GET	RAB=(R4)				;SEE IF THE WAITING GAVE RMS SOME TIME
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)		;CLEAR INDIRECT PPF
	BLBS	R0,20$					;THE WAIT DID THE TRICK, GO AHEAD NOW
	CMPW	R0,#RMS$_RSA&^XFFFF			;RECORD STREAM STILL ACTIVE?
	BNEQ	30$					;BRANCH IF NOT
	SOBGTR	R2,10$					;RETRY UNTIL STREAM BECOMES INACTIVE

	;
	; CONSTANT RETRYING DIDN'T HELP.  CANCEL ANY I/O AND TRY AGAIN.
	;
	$CANCEL_S PRC_W_INPCHAN(R11)			;IF NO LUCK, STOP THE I/O ON THAT CHANNEL
	$WAIT	RAB=(R4)				;WAIT FOR I/O TO COMPLETE
	BRB	40$					;TRY TO READ AGAIN

;
; READ FINALLY SUCCEEDED.  PROCESS THE INPUT RECORD.
;
20$:	MOVAB	WRK_G_INPBUF-2(R10),R2			;GET ADDRESS OF INPUT BUFFER
	BRW	PROCESS_INPUT				;PROCESS THE INPUT LINE

;
; WE HAVE ENCOUNTERED AN ERROR OTHER THAN RECORD STREAM ACTIVE.  RESTORE THE
; DEFAULT READ FORMAT OF NO INITIAL STRING, NO OFFSET AND RESTORE THE DEFAULT 
; KEYPAD STATE.
;
30$:	MOVL	RAB$L_XAB(R4),R1			;GET ADDRESS OF XABTRM
	MOVL	#ITRM_K_MINLEN,XAB$W_ITMLST_LEN(R1)	;SET SHORT LENGTH OF ITEM LIST
	BSBW	DCL$LOCKED_STATE			;RESTORE LOCKED KEYPAD STATE

;
; IF WE ARE AT END OF FILE, TERMINATE THE CURRENT PROCEDURE LEVEL AND
; READ THE NEXT RECORD FROM THE PREVIOUS PROCEDURE LEVEL.
;
	CMPW	R0,#RMS$_EOF&^XFFFF			;END OF FILE?
	BNEQ	110$					;IF NEQ NO
	CLRB	(R2)					;SET END OF LINE INDICATOR
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),50$ 	;IF SET, AT CONTROL Y/C LEVEL
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),50$	;BR IF DOING AN INQUIRE
	TSTL	PRC_L_INDEPTH(R11)			;INDIRECT LEVEL ZERO?
	BEQL	70$					;IF EQL, YES
	BSBW	DCL$UNSTACK				;UNSTACK INDIRECT FILE

;
; IF WE JUST RETURNED BACK TO LEVEL 0, FORCE THE PROMPT STRING BACK TO NORMAL
; BEFORE RE-ISSUING A READ FOR THE NEXT COMMAND.
;
	TSTL	PRC_L_INDEPTH(R11)			;INDIRECT LEVEL ZERO?
	BNEQ	40$					;BRANCH IF NOT
	CLRB	PRC_B_CONTINUE(R11) 			;SET FOR NORMAL PROMPT

;
; IF CURRENTLY PROCESSING A LINE CONTINUATION, RETURN AN EOL CHARACTER.
;
; IF INDIRECT FILE RECOGNITION IS DISABLED, THIS IS A FLUSH OF A COMMAND WITH 
; "-" AS THE LAST CHARACTER.  RETURN AN EOL CHARACTER.  OTHERWISE, PROCESS 
; THE LINE JUST READ
;
40$:	BBS	#PRC_V_FLUSH,PRC_W_FLAGS(R11),50$ 	;IF BIT IS SET,THEN FLUSH
	BBS	#PRC_V_IND,PRC_W_FLAGS(R11),50$ 	;IF BIT IS SET,THEN FLUSH
	BBS	#WRK_V_CONTIN,WRK_W_FLAGS(R10),50$	;IF BIT IS SET,THEN FLUSH
	BRW	REINP					;READ THE NEXT LINE
50$:	BRW	RETURN					;FLUSH THE RECORD

;
; IF WE GOT AN END OF FILE WHILE READING THE LEVEL 0 PROCEDURE IN A
; NON-INTERACTIVE JOB, TERMINATE THE JOB STEP.  IGNORE EOF'S (CTRL/Z)
; IN AN INTERACTIVE JOB.
;
70$:	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),90$ 	;BR IF NOT IN A GOTO
	BSBW	DCL$DEALGOTO				;DEALLOCATE GOTO SYMBOL
	STATUS	USGOTO					;SET FINAL STATUS OF UNSTATISFIED GOTO
	SETBIT WRK_V_COMMAND,WRK_W_FLAGS(R10) 		;MARK COMMAND EXECUTION ERROR
	ERRMSG						;PRINT THE ERROR
80$:	BSBW	DCL$SET_STATUS				;GIVE ERROR HANDLER A CHANCE
90$:	BBS	#PRC_V_EOFLOGO,PRC_W_FLAGS(R11),-	;IF SILENT LOGOUT REQUESTED
		SILENT_LOGOUT 				;
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),40$ 	;IF NOT BATCH JOB, IGNORE EOF
	BRW	DCL$ABORT				;LOG OUT BATCH JOB

;
; SOME OTHER TYPE OF I/O ERROR HAS OCCURRED.  ISSUE AN ERROR MESSAGE,
; THEN TERMINATE THE CURRENT PROCEDURE LEVEL AND PARSE THE NEXT COMMAND.
; IF THE ERROR WAS INSUFFICIENT QUOTA, THEN CANCEL THE CTRL/Y AST, OUTPUT
; THE ERROR MESSAGE, AND THEN LOG THE PROCESS OUT.
;
110$:	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) 		;MARK COMMAND EXECUTION ERROR
	CMPL	R0,#SS$_EXQUOTA				;IS ERROR DUE TO EXCEEDED QUOTA?
	BEQL	ABORT					;YES, THEN BRANCH
	ASSUME	PRC_L_STV EQ PRC_L_STS+4
	ASSUME	RAB$L_STV EQ RAB$L_STS+4
	MOVQ	RAB$L_STS(R4),PRC_L_STS(R11)		;STORE STS AND STV VALUES
120$:	ERRMSG						;OUTPUT ERROR MESSAGE
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),STATUS 	;IF SET, CNTL Y/C LEVEL
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),STATUS 	;SKIP IF IN INQUIRE
	TSTL	PRC_L_INDEPTH(R11)			;INDIRECT LEVEL ZERO?
	BNEQ	130$					;IF NEQ NO
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),80$ 	;BR IF BATCH
	BRB	STATUS					;	
130$:	PUSHL	R0					;SAVE ERROR/STATUS VALUE
	BSBW	DCL$UNSTACK				;UNSTACK INDIRECT FILE
	POPR	#^M<R0>					;RESTORE ERROR/STATUS VALUE
STATUS:	BSBW	DCL$SET_STATUS				;SET COMPLETION STATUS
	BRW	DCL$RESTART				;


;
; OUTPUT AN ERROR MESSAGE AND LOG THE PROCESS OUT
;
ABORT:	PUSHL	R0					;SAVE THE STATUS
	BSBW	DCL$DSBCONTRLY				;CANCEL THE CTRL/Y AST
	POPL	R0					;RESTORT THE STATUS
	ERRMSG						;OUTPUT THE ERROR MESSAGE
	BRW	DCL$ABORT				;LOG THE PROCESS OUT

;
; PERFORM A SILENT LOGOUT BY CANCELING THE SUPERVISOR MODE EXIT HANDLERS
; (SO THAT THE PROCESS IS DELETED), AND INVOKING $EXIT WITH THE LATEST
; STATUS FOR THIS PROCESS.
;
SILENT_LOGOUT::
	BSBW	DCL$CLOSE_PPFS				;CLOSE ALL PPF FILES STILL OPEN
	MOVL	PRC_L_INDFAB(R11),R0			;GET ADDR OF INDIRECT FAB
	MOVW	PRC_W_OUTIFI(R11),-			;GET INTERNAL FILE INDEX OF SYS$OUTPUT
		FAB$W_IFI(R0)				;
	$CLOSE	FAB=(R0)				;CLOSE INDIRECT OUTPUT FILE
	$CANEXH_S					;CANCEL SUPERVISOR MODE EXIT HANDLERS
	$EXIT_S	PRC_L_LSTSTATUS(R11)			;EXIT PROCESS WITH FINAL STATUS

	.SBTTL	PROCESS RECALL COMMANDS
;---
; PROCESS_RECALL - PROCESS RECALL COMMANDS
;
; SUBROUTINE TO CHECK FOR AND PROCESS CTRL/B AND ARROW RECALL COMMANDS.
;
; INPUTS:
;
;	R2 = ADDRESS OF NEW INPUT RECORD
;	R3 = LENGTH OF NEW INPUT RECORD, EXCLUDING NULL AT END OF LINE
;	R4 = ADDRESS OF RAB
;
; OUTPUTS:
;
;	INPUT BUFFER IS INITIALIZED
;	R0 IS SET
;---
PROCESS_RECALL:					;PROCESS RECALL COMMAND

;
; CHECK FOR CTRL/B.
;
	CMPB	#^X02,RAB$W_STV0(R4)		;TERMINATOR CTRL/B?
	BEQL	RECALL_PREV			;YES, THEN PROCESS IT
	MOVL	#1,R0				;RETURN
	RSB					;

;
; REPROMPT WITH THE PREVIOUS COMMAND.
;
RECALL_PREV:
	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED STATE
	TSTB	WRK_B_RECALLCNT(R10)		;FIRST TIME?
	BEQL	10$				;YES, THEN ALWAYS GO AHEAD
	TSTB	@WRK_L_RECALLPTR(R10)		;POINTER ADJUST. BY RECALL_NEXT?
	BEQL	5$				;NO, OK AS IS
	DECL	WRK_L_RECALLPTR(R10)		;YES, SET IT BACK TO NORMAL
;
5$:	CMPL	PRC_L_RECALLPTR(R11),-		;RETURNED TO THE ORIGIN?
		WRK_L_RECALLPTR(R10)		;
	BEQL	END_OF_LIST			;
	CMPB	WRK_B_RECALLCNT(R10),-		;MAX # OF COMMANDS DISPLAYED?
		#WRK_C_RECALLMAX+1		;
	BEQL	END_OF_LIST			;
10$:	CLRQ	-(SP)				;ALLOCATE A DESCRIPTOR
	PUSHL	SP				;PUSH DESCR ADDRESS
	CALLS	#1,DCL$GET_PREV_COMMAND		;RECALL THE SPECIFIED COMMAND
	BLBC	R0,20$				;BRANCH IF NO COMMAND WAS FOUND
	INCB	WRK_B_RECALLCNT(R10)		;INCR RECALL COUNT
	MOVAB	PRC_G_COMMANDS(R11),R0		;R0 = ADDR. OF BEGINNING OF BUFFER
	CMPL	R0,WRK_L_RECALLPTR(R10)		;ARE WE AT BEGINNING OF BUFFER?
	BNEQ	15$
	INCL	WRK_L_RECALLPTR(R10)		;YES, FIX POINTER TO INDICATE
						;THIS TO RECALL_NEXT.
15$:	CMPB	WRK_B_RECALLCNT(R10),-		;MAX # OF COMMANDS DISPLAYED?
		#WRK_C_RECALLMAX+1		;
	BNEQ	RECALL_CURR			;BRANCH IF NOT NOW MAX
20$:	ADDL	#8,SP				;RESTORE THE STACK
	BRB	END_OF_LIST			;OUTPUT A BLANK LINE

;
; REPROMPT WITH THE COMMAND THAT IS ON THE STACK.
;
RECALL_CURR:
	BSBW	ERASE_LINE			;ERASE THE PREVIOUS LINE
	MOVQ	(SP)+,R1			;GET COMMAND DESCRIPTOR
	BSBW	INSERT_COMMAND			;MODIFY THE XABTRM
	MOVL	#3,R0				;SET REPROMPT RETURN STATUS
	RSB					;RETURN

;
; REPROMPT WITH A BLANK LINE.
;
END_OF_LIST:
	BSBW	ERASE_LINE			;ERASE THE PREVIOUS LINE
	CLRQ	R1				;INIT COMMAND DESCRIPTOR
	BSBW	INSERT_COMMAND			;REPROMPT WITH THIS COMMAND
	MOVL	#3,R0				;SET REPROMPT RETURN STATUS
	RSB					;RETURN

;
; REPROMPT WITH THE NEXT COMMAND.
;
; NOTE:	WHEN AT BEGINNING OF BUFFER (NULL PRECEDING CURRENT RECORD),
;	SPECIAL PROCESSING IS DOWN. THE DCL$GET_CURR_COMMAND IS USED
;	INSTEAD OF DCL$GET_NEXT_COMMAND. THE WRK RECALL POINTER IS USED
;	AS A FLAG TO DETERMINE WHETHER OR NOT THE FIRST COMMAND IN THE
;	BUFFER HAS BEEN ALREADY PROCESSED. NORMALLY, THE POINTER IS POINTING
;	TO THE BEGINNING OF A COMMAND (FIRST BYTE ALWAYS NULL). IF THE
;	POINTER IS POINTING TO A NON-NULL BYTE, IT MEANS THAT THE FIRST
;	COMMAND IN THE BUFFER HAS ALREADY BEEN PROCESSED(THE POINTER WILL
;	BE POINTING TO THE LENGTH BYTE FOLLOWING THE NULL ).
;	IN THIS CASE, THE POINTER IS CORRECTED AND THE COMMAND IS
;	RETRIEVED WITH THE DCL$GET_NEXT_COMMAND INSTEAD OF DCL$GET_CURR_COMMAND.
;
RECALL_NEXT:
	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED STATE
	TSTB	WRK_B_RECALLCNT(R10)		;ANY NEXT COMMANDS TO RECALL?
	BEQL	END_OF_LIST			;NO, THEN REPEAT CURRENT COMMAND
;
	TSTB	@WRK_L_RECALLPTR(R10)		;POINTING TO BEGINNING OF COMMAND?
	BEQL	25$				;YES, HANDLE NORMALLY
;
	DECL	WRK_L_RECALLPTR(R10)		;NO, ADJUST POINTER
	BRB	30$				;AND GET NEXT COMMAND.
;
25$:	SUBL3	#1,WRK_L_RECALLPTR(R10),R0	;POINT R0 TO CURR. COMMAND-1
	MOVAB	PRC_G_COMMANDS(R11),R1		;R1 = ADDR. OF BEGINNING OF BUF.
	CMPL	R0,R1				;BUFFER UNDERFLOW?
	BGEQU	28$				;NO, R0 OK AS IS
	MOVAB	PRC_C_CMDBUFSIZ(R0),R0		;YES, POINT R0 TO TOP OF BUFFER
28$:	TSTB	(R0)				;PREVIOUS COMMAND EXIST?
	BNEQ	30$				;YES, PROCESS NORMALLY
;
;	SPECIAL CASE: THERE ARE EXACTLY 21 COMMANDS IN THE COMMAND BUFFER
;	AND RECALL_PREV HAS RETRIEVED THE LAST VALID COMMAND (IT LEAVES
;	POINTER TO FIRST COMMAND.) IN THIS CASE, DO A GET NEXT INSTEAD OF
;	GET CURRENT.
;
	CMPB	WRK_B_RECALLCNT(R10),-		;HAVE MAX. COMMANDS BEEN DISPL?
		#WRK_C_RECALLMAX+1
	BEQL	30$				;YES, GET NEXT COMMAND.
;
	CLRQ	-(SP)				;NO, ALLOCATE A DESCRIPTOR
	PUSHL	SP				;PUSH DESCRIPTOR ADDR.
	CALLS	#1,DCL$GET_CURR_COMMAND		;GET CURRENT COMMAND
	INCL	WRK_L_RECALLPTR(R10)		;INDICATE 1ST COMMAND PROCESSED.
	BRB	RECALL_CURR			;OUTPUT CURRENT COMMAND
;
30$:	CLRQ	-(SP)				;ALLOCATE A DESCRIPTOR
	PUSHL	SP				;PUSH DESCR ADDRESS
	CALLS	#1,DCL$GET_NEXT_COMMAND		;RECALL THE SPECIFIED COMMAND
	DECB	WRK_B_RECALLCNT(R10)		;DECREMENT THE RECALL COUNT
	BNEQ	RECALL_CURR			;BRANCH IF NOT NOW ZERO
	ADDL	#8,SP				;RESTORE THE STACK
	BRB	END_OF_LIST			;OUTPUT A BLANK LINE

;
; ERASE THE CURRENT LINE IF THE TERMINAL IS ANSI CRT.
;
;	R0,R5 ARE DESTROYED
;
ERASE_LINE:
	CLRQ	-(SP)				;CREATE ITEM LIST
	PUSHAB	-8(SP)				;SET BUFFER ADDRESS
	PUSHL	#DVI$_DEVDEPEND2@16+4		;SET ITEM CODE
	CLRQ	-(SP)				;ALLOCATE AN IOSB
	MOVL	SP,R0				;GET ADDRESS OF IOSB
	$GETDVIW_S  EFN=#EXE$C_SYSEFN,-		;GET DEVDEPEND2
		CHAN=PRC_W_INPCHAN(R11),-	;
		ITMLST=8(R0),-			;
		IOSB=(R0)			;
	BLBC	R0,90$				;BRANCH IF ERROR
	MOVZWL	(SP),R0				;GET IOSB STATUS
	BLBC	R0,90$				;BRANCH IF ERROR

	BBC	#TT2$V_ANSICRT,8(SP),90$	;BRANCH IF ANSI CRT BIT CLEAR
	MOVL	PRC_L_OUTRAB(R11),R5		;SET ADDRESS OF OUTPUT FILE RAB
10$:	MOVAB	ERASE+1,RAB$L_RBF(R5)		;SET ADDRESS OF OUTPUT RECORD
	MOVZBW	ERASE,RAB$W_RSZ(R5)		;SET SIZE OF OUTPUT RECORD
	DISABLE					;DISABLE CONTROL Y/C AST'S
	INSV	#0,#RAB$V_PPF_RAT,-		;DISABLE CR FORMAT WRITES
		#RAB$S_PPF_RAT,RAB$W_ISI(R5)	;
	$PUT	RAB=(R5)			;OUTPUT RECORD
	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,-	;ENABLE CR FORMAT WRITES
		#RAB$S_PPF_RAT,RAB$W_ISI(R5)	;
	ENABLE					;ENABLE CONTROL Y/C AST'S

	MOVL	PRC_L_TRMLIST(R11),R0		;GET ADDRESS OF XABTRM ITEM LIST
	CLRW	@ITRM_L_PMPTADDR(R0)		;REMOVE CR/LF FROM PROMPT STRING

90$:	ADDL	#6*4,SP				;RESTORE STACK
	RSB					;

;
; REPROMPT WITH RECALLED COMMAND.
;
INSERT_COMMAND:
	MOVL	PRC_L_TRMLIST(R11),R0		;GET ADDRESS OF XABTRM ITEM LIST
	CLRL	ITRM_L_OFFSET(R0)		;REQUEST A FRESH READ
	MOVW	R1,ITRM_W_INILEN(R0)		;SET LENGTH OF INITIAL STRING
	MOVL	R2,ITRM_L_INIADDR(R0)		;SET ADDRESS OF INITIAL STRING
	MOVL	RAB$L_XAB(R4),R0		;GET ADDRESS OF XABTRM
	MOVL	#ITRM_K_LENGTH,-		;SET EXPANDED LENGTH OF ITEM LIST
		XAB$W_ITMLST_LEN(R0)		;
	RSB					;RETURN

	.SBTTL	PROCESS ESCAPE SEQUENCES
;---
; PROCESS_ESCAPE - PROCESS ESCAPE SEQUENCES
;
; SUBROUTINE TO CHECK FOR AND PROCESS ESCAPE SEQUENCES.
;
; INPUTS:
;
;	R2 = ADDRESS OF NEW INPUT RECORD
;	R3 = LENGTH OF NEW INPUT RECORD, EXCLUDING NULL AT END OF LINE
;	R4 = ADDRESS OF RAB
;
; OUTPUTS:
;
;	R2 = ADDRESS OF NEW INPUT RECORD
;	R3 = LENGTH OF NEW INPUT RECORD, EXCLUDING NULL AT END OF LINE
;---
 
PROCESS_ESCAPE:					;PROCESS ESCAPE SEQUENCES

;
; CHECK FOR ESCAPE SEQUENCES.
;
	CMPB	#1,RAB$W_STV2(R4)		;ESCAPE SEQUENCE?
	BLSSU	5$				;YES, THEN PROCESS
	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED KEYPAD STATE
	MOVL	#1,R0				;SET REPROMPT STATUS
	RSB					;RETURN
	
;
; REPROMPT IF NO KEY OR SYMBOL FOUND.
;
70$:	MOVQ	(SP)+,R4			;RESTORE R4/R5
80$:	MOVQ	(SP)+,R2			;RESTORE R2/R3
	MOVL	R3,R1				;CREATE R1/R2 DESCRIPTOR
	BSBB	INSERT_COMMAND			;REPROMPT WITH THIS COMMAND
	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED KEYPAD STATE
	MOVL	#3,R0				;SET REPROMPT STATUS
	RSB					;RETURN

;
; FIND ASSOCIATED META-KEY NAME.
;
5$:	MOVQ	R2,-(SP)			;SAVE R2/R3
	CLRL	-(SP)				;ALLOCATE SPACE FOR RETURN ADDRESS
	PUSHL	SP				;POINT AT IT
	MOVZBL	RAB$W_STV2(R4),-(SP)		;GET TERMINATOR LENGTH
	PUSHAB	(R2)[R3]			;GET TERMINATOR ADDRESS
	CALLS	#3,G^GET_KEY_NAME		;LOOK UP THE ESCAPE SEQUENCE
	MOVL	(SP)+,R2			;GET ADDRESS OF ASCIC META-KEY NAME
	BLBC	R0,80$				;SKIP IF NONE

;
; SPECIAL CASE UP AND DOWN ARROW KEYS.
;
	CMPB	(R2),#4				;IS THE STRING SHORT ENOUGH?
	BGTR	10$				;NO, THEN SKIP
	CMPW	1(R2),#^A'UP'			;CHECK FOR UP ARROW
	BEQL	8$				;BRANCH IF MATCH
	CMPL	1(R2),#^A'DOWN'			;CHECK FOR DOWN ARROW
	BNEQ	10$				;BRANCH IF NO MATCH
7$:	MOVQ	(SP)+,R2			;RESTORE R2/R3
	BRW	RECALL_NEXT			;DO THE RECALL
8$:	MOVQ	(SP)+,R2			;RESTORE R2/R3
	BRW	RECALL_PREV			;DO THE RECALL

;
; FIND ASSOCIATED SYMBOL VALUE.
;
;	(SP) = INITIAL OFFSET
;	4(SP) = NEW COMMAND LENGTH
;	8(SP) = RAB ADDRESS
;	12(SP) = R5
;	16(SP) = INITIAL COMMAND ADDRESS
;	20(SP) = INITIAL (LATER NEW) COMMAND LENGTH
;
10$:	MOVQ	R4,-(SP)			;SAVE R4/R5
	MOVZBL	(R2)+,R1			;GET DESCRIPTOR OF SYMBOL NAME
	BSBW	DCL$SEARCH_KEYPAD		;SEARCH SYMBOL TABLE FOR MATCH
	BLBC	R0,70$				;SKIP IF NOT FOUND

;
; /ERASE - COPY STRING INTO INPUT BUFFER.
;
	BBC	#SYM_V_ERASE,R4,20$		;IF /NOERASE, THEN SKIP
	PUSHL	R1				;SAVE NEW LENGTH
	CLRL	-(SP)				;SET INITIAL OFFSET
	MOVL	16(SP),R5			;GET INITIAL ADDRESS
	PUSHL	R4				;SAVE FLAGS
	MOVC3	R1,(R2),(R5)			;COPY VALUE TO INPUT BUFFER
	POPL	R4				;RESTORE FLAGS
	BRB	30$				;

95$:	STATUS	BUFOVF				;SET OVERFLOW STATUS
	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED KEYPAD STATE
	BRW	67$				;RETURN ERROR

96$:	STATUS	SYMOVF				;SET OVERFLOW STATUS
	BRW	66$				;RETURN

;
; /NOERASE - COPY STRING INTO INPUT BUFFER.
;
20$:	ADDL3	R1,12(SP),-(SP)			;SAVE NEW LENGTH
	CMPL	(SP),#WRK_C_INPBUFSIZ		;WILL STRING FIT IN BUFFER?
	BGTRU	95$				;NO, THEN RETURN ERROR
	ADDL3	16(SP),12(SP),R5		;FIND CURRENT EOL
	MOVL	4(SP),R0			;GET ADDRESS OF RAB
	MOVZBL	RAB$W_STV2+1(R0),R3		;GET CURSOR OFFSET FROM EOL
	SUBL	R3,R5				;BACK UP TO INSERTION POINT
	SUBL3	R3,16(SP),-(SP)			;SAVE INITIAL OFFSET
	PUSHR	#^M<R1,R2,R3,R4,R5>		;SAVE REGISTERS
	MOVC3	R3,(R5),(R5)[R1]		;MOVE THE TEXT
	POPR	#^M<R1,R2,R3,R4,R5>		;RESTORE REGISTERS
	PUSHL	R4				;SAVE FLAGS
	MOVC3	R1,(R2),(R5)			;COPY VALUE TO INPUT BUFFER
	POPL	R4				;RESTORE FLAGS

;
; PROCESS /SET_STATE AND /LOCK
;
30$:	BSBW	DCL$LOCKED_STATE		;RESTORE LOCKED KEYPAD STATE
	BBC	#SYM_V_STATE,R4,50$		;BRANCH IF NO SET_STATE SPECIFIED
	MOVL	R1,R2				;GET LENGTH/ADDR OF STATE STRING
	MOVZBL	(R2)+,R1			;
	BSBW	DCL$ALLOC_STATE			;ALLOCATE IT
	BLBC	R0,96$				;BRANCH IF NO ROOM FOR SYMBOL
	BBC	#SYM_V_LOCK,R4,50$		;BRANCH IF NOT /LOCK
	MOVL	PRC_L_LASTKEY(R11),R0		;GET OLD LOCKED STATE
	BSBW	DCL$DEALLOC_STATE		;DEALLOCATE IT
	MOVL	PRC_L_CURRKEY(R11),-		;LOCK NEW KEY STATE
		PRC_L_LASTKEY(R11)		;

;
; PROCESS /ERASE.
;
50$:	BBC	#SYM_V_ERASE,R4,52$		;IF /NOERASE, THEN SKIP
	BSBW	ERASE_LINE			;ERASE THE LINE
	BBC	#SYM_V_TERMINATE,R4,52$		;IF /NOTERMINATE, THEN SKIP
	MOVL	PRC_L_OUTRAB(R11),R5		;SET ADDRESS OF OUTPUT FILE RAB
51$:	MOVL	PRC_L_TRMLIST(R11),R0		;GET ADDRESS OF XABTRM ITEM LIST
	MOVL	ITRM_L_PMPTADDR(R0),-		;WRITE THE PROMPT STRING
		RAB$L_RBF(R5)			;
	MOVW	ITRM_W_PMPTLEN(R0),-		;
		RAB$W_RSZ(R5)			;
	DISABLE					;DISABLE CONTROL Y/C AST'S
	INSV	#0,#RAB$V_PPF_RAT,-		;DISABLE CR FORMAT WRITES
		#RAB$S_PPF_RAT,RAB$W_ISI(R5)	;
	$PUT	RAB=(R5)			;OUTPUT RECORD
	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,-	;ENABLE CR FORMAT WRITES
		#RAB$S_PPF_RAT,RAB$W_ISI(R5)	;
	ENABLE					;ENABLE CONTROL Y/C AST'S

;
; PROCESS /ECHO.
;
52$:	BBC	#SYM_V_TERMINATE,R4,60$		;IF /NOTERMINATE, THEN SKIP
	BBC	#SYM_V_ECHO,R4,65$		;IF /NOECHO, THEN SKIP
	MOVL	PRC_L_OUTRAB(R11),R5		;SET ADDRESS OF OUTPUT FILE RAB
55$:	MOVL	4(SP),R0			;GET SIZE OF OUTPUT RECORD
	ADDL3	R0,16(SP),R1			;FIND END OF OUTPUT RECORD
	MOVB	#^X0D,(R1)			;INSERT CR AT END
	SUBL	(SP),R0				;SUBTRACT OUT INITIAL OFFSET
	SUBL3	R0,R1,RAB$L_RBF(R5)		;SET ADDRESS OF OUTPUT RECORD
	ADDW3	#1,R0,RAB$W_RSZ(R5)		;SET SIZE OF OUTPUT RECORD
	DISABLE					;DISABLE CONTROL Y/C AST'S
	INSV	#0,#RAB$V_PPF_RAT,-		;DISABLE CR FORMAT WRITES
		#RAB$S_PPF_RAT,RAB$W_ISI(R5)	;
	$PUT	RAB=(R5)			;OUTPUT RECORD
	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,-	;ENABLE CR FORMAT WRITES
		#RAB$S_PPF_RAT,RAB$W_ISI(R5)	;
	ENABLE					;ENABLE CONTROL Y/C AST'S

65$:	MOVL	#1,R0				;SET NORMAL RETURN STATUS
66$:	TSTL	(SP)+				;POP INITIAL OFFSET
67$:	MOVL	(SP)+,12(SP)			;REPLACE OLD LENGTH WITH NEW
	MOVQ	(SP)+,R4			;RESTORE R4/R5
	MOVQ	(SP)+,R2			;RESTORE R2/R3
	RSB					;RETURN

;
; PROCESS /NOTERMINATE.
;
60$:	MOVL	PRC_L_TRMLIST(R11),R0		;GET ADDRESS OF XABTRM ITEM LIST
	MOVL	(SP)+,ITRM_L_OFFSET(R0)		;SET CHARACTER TO START ECHOING AT
	INCL	ITRM_L_OFFSET(R0)		;
	BBC	#SYM_V_ERASE,R4,61$		;IF /NOERASE, THEN SKIP
	CLRL	ITRM_L_OFFSET(R0)		;START WITH FIRST CHARACTER
61$:	MOVL	(SP)+,12(SP)			;REPLACE OLD LENGTH WITH NEW
	MOVW	12(SP),ITRM_W_INILEN(R0)	;SET LENGTH OF INITIAL STRING
	MOVL	8(SP),ITRM_L_INIADDR(R0)	;SET ADDRESS OF INITIAL STRING
	MOVQ	(SP)+,R4			;RESTORE R4/R5
	MOVL	RAB$L_XAB(R4),R0		;GET ADDRESS OF XABTRM
	MOVL	#ITRM_K_LENGTH,-		;SET EXPANDED LENGTH OF ITEM LIST
		XAB$W_ITMLST_LEN(R0)		;
	MOVQ	(SP)+,R2			;RESTORE R2/R3
	MOVL	#3,R0				;SET REPROMPT RETURN STATUS
	RSB					;RETURN

	.SBTTL	RESTORE LOCKED KEYPAD STATE
;---
; DCL$LOCKED_STATE - RESTORE LOCKED KEYPAD STATE
;
; DELETE ANY TEMPORARY KEYPAD STATE THAT MAY HAVE BEEN SET AND RESTORE THE
; LOCKED KEYPAD STATE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC DATA STRUCTURE
;	PRC_L_CURRKEY = CURRENT, POSSIBLY TERMPORARY, KEYPAD STATE
;	PRC_L_LASTKEY = DEFAULT LOCKED KEYPAD STATE
;
; OUTPUTS:
;
;	PRC_L_CURRKEY IS UPDATED.
;
;---
 
DCL$LOCKED_STATE::				;RESTORE LOCKED KEYPAD STATE
	PUSHL	R0				;SAVE R0
	CMPL	PRC_L_CURRKEY(R11),-		;IS TEMPORARY STATE IN EFFECT?
		PRC_L_LASTKEY(R11)		;
	BEQL	90$				;NO, THEN DONE
	MOVL	PRC_L_CURRKEY(R11),R0		;GET ADDRESS OF ASCIC STATE
	BSBW	DCL$DEALLOC_STATE		;DEALLOCATE TEMPORARY STATE
	MOVL	PRC_L_LASTKEY(R11),-		;RESTORE THE LOCKED STATE
		PRC_L_CURRKEY(R11)		;
90$:	POPL	R0				;RESTORE R0
	RSB					;RETURN


	.SBTTL	EXPAND INPUT LINE
;---
; EXPAND - EXPAND INPUT LINE WITH SYMBOL SUBSTITUTIONS
;
; SUBROUTINE TO EXPAND INPUT LINE BY EXECUTING ALL STRING SUBSTITUTION
; COMMANDS.  THE UNUSED AREA IN THE EXPANSION BUFFER IS USED TEMPORARILY
; TO HOLD THE EXPANDED COPY OF THE COMMAND LINE.  AFTER ALL SUBSTITUTIONS
; ARE PERFORMED, THE EXPANDED COPY IS COPIED BACK INTO THE INPUT RECORD
; BUFFER SO THAT SEMANTIC PARSING CAN CONTINUE.
;
; INPUTS:
;
;	WRK_L_CHARPTR = POINTER TO NEW INPUT RECORD
;
; OUTPUTS:
;
;	R2 = ADDRESS OF NEW INPUT RECORD
;	R3 = LENGTH OF NEW INPUT RECORD, EXCLUDING NULL AT END OF LINE
;	WRK_L_CHARPTR = POINTER TO EXPANDED INPUT RECORD
;---
 
EXPAND:					;EXPAND INPUT LINE
	PUSHR	#^M<R4,R5,R6,R7,R8,R9>	;SAVE REGISTERS
	PUSHL	WRK_L_MARKPTR(R10)	;SAVE MARKER POINTER
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE EXPANSION BUFFER POINTER
	MOVW	WRK_W_FLAGS(R10),-(SP)	;SAVE CURRENT PARSING FLAGS
	BISW	#WRK_M_INPSUBST!WRK_M_NOUPCASE!WRK_M_STAR,WRK_W_FLAGS(R10)
					;PREVENT PROCESSING OF !,-,@,ETC.
					;AND PREVENT UPCASING OF INPUT CHARS
					;AND ACCEPT '*' AS A TERMINATOR
	CLRW	-(SP)			;INITIALIZE ITERATION COUNTER
;
; GET NEXT CHARACTER FROM INPUT RECORD
;
10$:	BSBW	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT LINE
	CMPB	R0,#^A/'/		;STRING SUBSTITUTION COMMAND?
	BNEQ	70$			;IF NEQ NO
	BBC	#WRK_V_QUOTE,WRK_W_FLAGS(R10),20$ ;IF LBC NOT IN QUOTE
	BSBW	DCL$SETCHAR		;CHECK NEXT CHARACTER
	CMPB	R0,#^A/'/		;NEXT CHARACTER ALSO SINGLE QUOTE?
	BNEQ	60$			;IF NEQ NO
	BSBW	DCL$GETCHAR		;GOBBLE SECOND SINGLE QUOTE
	BRB	20$			;TRY SYMBOL SUBSTITUTION
;
; ONE SINGLE QUOTE WAS DETECTED IN A DOUBLE QUOTED STRING - TREAT LITERALLY
;
60$:	MOVZBL	#^A/'/,R0		;INSERT SINGLE QUOTE WITHIN STRING
;
; IF COMMENT IS DETECTED, THEN DO SUBSTITUTIONS BUT IF AN ERROR IS
; DETECTED, THEN NO ERROR IS ISSUED AND A NULL STRING IS SUBSTITUTED.
;
70$:	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(R10),80$ ;BRANCH IF IN QUOTED STRING
	CMPB	R0,#^A'!'		;START OF COMMENT STRING?
	BNEQ	80$			;BRANCH IF NOT A COMMENT
	SETBIT	WRK_V_COMMENT,WRK_W_FLAGS(R10) ;MARK WE ARE IN A COMMENT
					;SO THAT ERRORS ARE NOT REPORTED
;
; WRITE THE CURRENT CHARACTER INTO THE EXPANSION BUFFER AND LOOP
;
80$:	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN EXPANSION BUFFER
	BNEQ	10$			;IF NOT EOL, KEEP SCANNING
	BRW	90$			;END OF LINE - TERMINATE SCAN
;
; SYMBOL SUBSTITUTION REQUESTED.  GET THE SYMBOL AND SEARCH THE SYMBOL
; TABLE, AND IF NOT FOUND THERE, TRY AS A LEXICAL FUNCTION.
;
20$:	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE PLACE IN EXPANSION BUFFER
	MOVW	WRK_W_FLAGS(R10),-(SP)	;SAVE LEXICAL FLAGS
	BICW	#WRK_M_QUOTE,WRK_W_FLAGS(R10)
	BBS	#WRK_V_COMMENT,-	;ARE WE IN A COMMENT?
		WRK_W_FLAGS(R10),22$
	BICW	#WRK_M_NOUPCASE,WRK_W_FLAGS(R10)  ;NO, THEN UPCASE THE SYMBOL
					;PRETEND WE'RE NOT IN A STRING
					;SO GETOKEN STOPS BEFORE END-OF-STRING
22$:	MOVZBL	#^A/'/,R0		;INSERT SINGLE QUOTE WITHIN STRING
	BSBW	DCL$PUTCHAR		;IN CASE SUBSTITION NOT ALLOWED
	BSBW	DCL$GETOKEN		;GET/COPY NEXT TOKEN
;
; IF IN COMMENT, ONLY ALLOW F$VERIFY TO BE SUBSTITUTED
;
	BBC	#WRK_V_COMMENT,WRK_W_FLAGS(R10),28$ ;BRANCH IF NOT IN COMMENT
	CMPL	R1,#4			;AT LEAST 4 CHARACTER TOKEN?
	BLSS	25$			;IF NOT, SKIP SYMBOL SUBSTITUTION
	MOVL	(R2),-(SP)		;PUSH FIRST FOUR CHARACTERS
	MOVQ	R1,-(SP)		;SAVE DESCRIPTOR
	MOVZBL	#4,R1			;CREATE TEMPORARY DESCRIPTOR
	MOVAB	8(SP),R2
	BSBW	DCL$UPCASE		;UPCASE THE SYMBOL
	MOVQ	(SP)+,R1		;RESTORE THE REGISTERS
	CMPL	(SP)+,#^A'F$VE'		;IS IT F$VERIFY WITHIN A COMMENT?
	BEQL	28$			;IF SO, ALLOW SUBSTITUTION
25$:	MOVL	WRK_L_EXPANDPTR(R10),2(SP) ;COPY 'SYMBOL TO EXPANSION BUFFER
	BRB	50$
28$:	TSTL	R1			;ZERO LENGTH SYMBOL?
	BEQL	40$			;IF EQL YES
	MOVQ	R1,R6			;SAVE STRING PARAMETERS
	BSBW	DCL$SEARCH		;SEARCH FOR SYMBOL
	BLBS	R0,40$			;IF LBS SYMBOL DEFINITION FOUND
	CLRBIT	WRK_V_INPSUBST,WRK_W_FLAGS(R10) ;DO PROCESSING OF !,-,@,ETC.
					;TO ALLOW CONTINUATIONS IN FUNCT. ARGS
	BBC	#WRK_V_COMMENT,-	;ARE WE IN A COMMENT?
		WRK_W_FLAGS(R10),32$
	MOVQ	R6,R1			;YES, THEN UPCASE "F$VERIFY"
	BSBW	DCL$UPCASE
	MOVQ	R1,R6	
32$:	BSBW	DCL$LEXIF		;EVALUATE LEXICAL FUNCTION
40$:	BSBW	DCL$CVT_STRING		;CONVERT RESULT TO CHARACTER STRING
	SETBIT	WRK_V_INPSUBST,WRK_W_FLAGS(R10) ;DISABLE !,-,@,ETC.
;
; TRAILING SINGLE QUOTES ARE OPTIONAL AFTER SYMBOL - GOBBLE IT
;
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER
	CMPB	R0,#^A/'/		;SYMBOL END WITH SINGLE QUOTE?
	BNEQ	30$			;BRANCH IF TRAILING SINGLE QUOTE
	BSBW	DCL$GETCHAR		;GOBBLE TRAILING QUOTE
;
; APPEND THE SYMBOL TRANSLATION TO THE FRONT OF THE INPUT BUFFER
; AND RESET THE INPUT POINTER TO POINT TO IT.  THIS IS DONE IN CASE
; THERE ARE ANY SINGLE QUOTES IN THE TRANSLATION WHICH REQUIRE SUBSTITUTION.
;
30$:	SUBL	R1,WRK_L_CHARPTR(R10)	;CALCULATE ADDRESS TO COPY STRING
	MOVL	WRK_L_CHARPTR(R10),R0	;POINT TO NEW POSITION IN INBUF
	MOVC	R1,(R2),1(R0)		;CONCATENATE STRING TO INPUT BUFFER
;
; A MAXIMUM OF 1000 SUBSTITUTIONS IS ALLOWED PER LINE, TO PREVENT ANY
; INFINITE LOOPS FROM OCCURRING DUE TO RECURSIVE SUBSTITUTIONS.
;
50$:	MOVW	(SP)+,WRK_W_FLAGS(R10)	;RESTORE FLAGS QUOTE AND NOUPCASE
	POPL	WRK_L_EXPANDPTR(R10)	;RETRIEVE ADDRESS IN EXPANSION BUFFER
	ACBW	#1000,#1,(SP),10$	;CHECK FOR SUBSTITUTION LOOP
	STATUS	EXPSYN			;EXPRESSION SYNTAX ERROR
	ADDL3	R6,R7,WRK_L_EXPANDPTR(R10) ;POINT AT END OF SYMBOL
	MOVAB	-(R7),WRK_L_MARKPTR(R10) ;SET ADDRESS OF "'"
	BRW	DCL$PARSERR		;REPORT ERROR
;
; END OF LINE DETECTED.  MOVE EXPANDED LINE BACK INTO THE INPUT BUFFER
; FOR THE LEXICAL PROCESSING.
;
90$:	MOVL	4(SP),R7		;GET SAVED EXPANSION POINTER
	SUBL3	R7,WRK_L_EXPANDPTR(R10),R9 ;CALCULATE LENGTH OF EXPANDED LINE
	MOVAB	WRK_G_INPBUF+WRK_C_INPBUFSIZ(R10),R8 ;FIND END OF INPUT BUFFER
	SUBL	R9,R8			;COMPUTE ADDRESS TO MOVE LINE TO
	MOVC	R9,(R7),(R8)		;MOVE EXPANDED LINE TO END OF INPUT BUFFER
	MOVQ	R8,R2			;SET INPUT LINE PARAMETERS
	DECL	R3			;DECREMENT LENGTH TO EXCLUDE EOL CHAR
	MOVAB	-1(R2),WRK_L_CHARPTR(R10);SET ADDRESS OF EXPANDED INPUT LINE
	TSTW	(SP)+			;REMOVE ITERATION COUNTER FROM STACK
	MOVW	(SP)+,WRK_W_FLAGS(R10)	;RESTORE CURRENT PARSING FLAGS
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	POPL	WRK_L_MARKPTR(R10)	;RESTORE MARKER POINTER
	POPR	#^M<R4,R5,R6,R7,R8,R9>	;RESTORE REGISTERS
	RSB

	.SBTTL	SPECIAL TOKEN LEXICAL PROCESSING
;---
;
; THIS ROUTINE IS CALLED TO PROCESS LEXICAL TOKENS WITH SPECIAL CHARACTERS.
; THE LIST OF CHARACTERS ARE:
;
;	&SYMBOL		- TOKEN IS SUBSTITUTED WITH SYMBOL VALUE
;	@FILESPEC	- TOKEN IS SUBSTITUTED WITH FIRST RECORD CONTAINED
;			  IN THE ASSOCIATED PROCEDURE FILE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;	R10 = ADDRESS OF WRK AREA
;	R0 = FIRST CHARACTER IN TOKEN
;
; ADDITIONAL INPUT AND OUTPUT SPECIFICATIONS ARE GIVEN WITH EACH ROUTINE.
;
;---

DCL$SPECIAL::
	CMPB	R0,#^A'&'		;SUBSTITUTION?
	BEQL	AMPERSAND		;BRANCH IF SO
	CMPB	R0,#^A'@'		;INDIRECTION?
	BEQL	INDIRECT		;BRANCH IF SO
	RSB				;IF NOT KNOWN, IGNORE IT

	.SBTTL	PROCESS &SYMBOL CONSTRUCT
;---
;
; HANDLE &SYMBOL CONSTRUCT.
;
; INPUTS:
;
;	R0 = CHARACTER IN INPUT BUFFER (&)
;	R1/R2 = DESCRIPTOR OF TOKEN, INCLUDING "&" CHARACTER
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;	R1/R2 = DESCRIPTOR OF UPDATED TOKEN
;
;	THE EXPANSION BUFFER WILL BE OVERWRITTEN WITH SYMBOL VALUE
;
;---
AMPERSAND:
	PUSHR	#^M<R2,R3,R4,R5>	;SAVE REGISTERS
	INCL	R2			;POINT TO SYMBOL NAME
	DECL	R1			;ADJUST LENGTH OF SYMBOL NAME
	BEQL	40$			;BRANCH IF NULL SYMBOL NAME
	BSBW	DCL$SYM_STRING		;SEARCH LOCAL/GLOBAL SYMBOL TABLES
40$:	MOVC	R1,(R2),@(SP)		;OVERWRITE "&SYMBOL" WITH ITS VALUE
	MOVL	R3,WRK_L_EXPANDPTR(R10)	;SET NEW EXPANSION BUFFER POINTER
	POPR	#^M<R2,R3,R4,R5>	;RESTORE REGISTERS
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;CALCULATE LENGTH OF NEW TOKEN
	RSB

	.SBTTL	PROCESS @FILESPEC CONSTRUCT
;---
;
; HANDLE @FILESPEC CONSTRUCT.
;
; INPUTS:
;
;	R0 = CHARACTER IN INPUT BUFFER (@)
;
;	AT THIS POINT, ONLY THE @ HAS BEEN SEEN, AND THE FILESPEC
;	HAS NOT YET BEEN PROCESSED.
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;---
INDIRECT:
	BBSS	#PRC_V_IND,PRC_W_FLAGS(R11),90$ ;SKIP IF INDIRECTION DISABLED
					;AND DISABLE WHILE PROCESSING FILESPEC
	PUSHL	WRK_L_MARKPTR(R10)	;SAVE OLD PARSE POSITION
	BSBW	DCL$MARK		;SET PARSE POSITION FOR '@' PROCESSING
	BSBW	DCL$STACKIND		;STACK CURRENT INDIRECT LEVEL
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECTION AGAIN
	BLBC	R0,DCL$CHARERROR	;BRANCH IF ERROR DETECTED
	MOVL	(SP)+,WRK_L_MARKPTR(R10) ;RESTORE OLD PARSE POSITION
	BSBW	DCL$INPUT		;GET FIRST LINE, CHARACTER OF PROCEDURE
90$:	RSB

	.SBTTL	ERROR HANDLER IN CHARACTER INPUT ROUTINES
;---
;
; THIS ROUTINE IS CALLED TO PERFORM ANY SPECIAL PROCESSING WHEN AN
; ERROR IS DETECTED BY THE CHARACTER INPUT ROUTINES.
;
; INPUTS:
;
;	R0 = STATUS CODE
;
; OUTPUTS:
;
;	NONE
;---
DCL$CHARERROR::
	BSBW	DCL$ERRORMSG		;REPORT ERROR MESSAGE
	PUSHL	R0			;SAVE STATUS CODE
	BSBW	DCL$FLUSH		;FLUSH INPUT BUFFER
	POPL	R0			;RESTORE STATUS CODE
	BSBW	DCL$SET_STATUS		;SET COMPLETION STATUS
	BRW	DCL$RESTART		;START THE PARSING ALL OVER AGAIN

	.SBTTL RECALL COMMAND
;+
; DCL$RECALL - RECALL COMMAND
;
; THIS ROUTINE IS CALLED TO EXECUTE THE DCL RECALL COMMAND.  THE RECALL
; COMMAND REPROMPTS THE USER WITH A COMMAND THAT HE HAS PREVIOUSLY ENTERED
; OR DISPLAYS FOR THE USER THE LIST OF ALL THE COMMANDS IN THE COMMAND BUFFER.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR
;	R9 = ADDRESS OF SCRATCH STACK
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;-
 
DCL$RECALL::

;
; SKIP IF ENTERED FROM A COMMAND PROCEDURE.
;
	BBS	#PRC_V_MODE,-		; IF SET, NOT INTERACTIVE
		PRC_W_FLAGS(R11),3$	;
	BBS	#PRC_V_YLEVEL,-		; IF SET, AT CONTROL Y/C LEVEL
		PRC_W_FLAGS(R11),5$ 	;
	TSTL	PRC_L_INDEPTH(R11)	; INDIRECT LEVEL ZERO?
	BEQL	5$			; BRANCH IF YES
3$:	BRW	90$			; RETURN


;
; REMOVE THIS COMMAND FROM THE RECALL BUFFER.
;
5$:	MOVL	PRC_L_RECALLPTR(R11),-	; UPDATE WRK RECALL PTR
		WRK_L_RECALLPTR(R10)	;
	CLRQ	-(SP)			; ALLOCATE COMMAND DESCRIPTOR
	PUSHL	SP			; POINT TO IT
	CALLS	#1,DCL$GET_PREV_COMMAND	; GET THE RECALL COMMAND
	CLRQ	(SP)+			; DISCARD THE DESCRIPTOR
	MOVL	WRK_L_RECALLPTR(R10),-	; UPDATE PRC RECALL PTR
		PRC_L_RECALLPTR(R11)	;

;
; PARSE THE COMMAND.
;
	MOVL	#1,R6			; ASSUME BACKING UP ONE COMMAND
	BSBW	DCL$GETDVAL		; GET NEXT DESCRIPTOR
	CMPL	#PTR_K_ENDLINE,R5	; EOL?
	BEQL	30$			; YES, EXECUTE THE COMMAND
	CMPL	#PTR_K_PARAMETR,R5	; NUMBER?
	BNEQ	20$			; NO, MUST BE /ALL
	MOVQ	R1,R2			; COPY DESCRIPTOR
	MOVQ	R2,-(SP)		; SAVE IT ON THE STACK
	MOVL	#1,R1			; SET DECIMAL RADIX
	BSBW	DCL$CNVNOEDIT		; CONVERT NUMBER TO BINARY
	MOVQ	(SP)+,R2		; RESTORE THE DESCRIPTOR
	TSTL	R0			; WAS IT A NUMBER?
	BEQL	10$			; YES, CHECK BOUNDS
	MOVQ	R2,R6			; SAVE THE STRING DESCRIPTOR
	BRB	35$			; GET THE COMMAND
10$:	CMPL	R1,#WRK_C_RECALLMAX	; WITHIN BOUNDS?
	BGTRU	95$			; NO, SIGNAL ERROR
	MOVL	R1,R6			; GET BACKUP COUNT
	BEQL	95$			; SIGNAL ERROR IF ZERO
	BRB	30$			; GET THE COMMAND
20$:	MOVL	#WRK_C_RECALLMAX,R6	; /ALL WAS SPECIFIED
	BRB	50$			; DISPALY THE COMMANDS

95$:	STATUS	IVVALU			; SET INVALID VALUE STATUS
	RSB				; RETURN

;
; FETCH SPECIFIED COMMAND BY STRING.
;
35$:	MOVL	#WRK_C_RECALLMAX,R9	; /ALL WAS SPECIFIED
	CLRQ	-(SP)			; ALLOCATE COMMAND DESCRIPTOR
36$:	PUSHL	SP			; PUSH DESCR ADDRESS
	CALLS 	#1,DCL$GET_PREV_COMMAND	; GET THE PREVIOUS COMMAND
	MOVC3	(SP),@4(SP),@4(R8)	; COPY COMMAND TO SCRATCH BUFFER
	MOVL	(SP),(R8)		; COPY INITIAL LENGTH
	MOVQ	(R8),R1			; SET COMMAND DESCRIPTOR
	BSBW	DCL$TRIM		; UPCASE AND TRIM THE COMMAND
	CMPL	R6,R1			; MAKE SURE WE ARE CHECKING A SUBSTRING
	BGTRU	361$			; SKIP THIS ONE IF NOT
	CMPC5	R6,(R7),#0,R6,(R2)	; DO THE STRINGS MATCH?
	BEQL	37$			; YES, THEN REPROMPT
361$:	SOBGTR	R9,36$			; LOOP TILL SEARCHED ALL COMMANDS
	ADDL	#8,SP			; RESTORE THE STACK
	MOVL	#CLI$_CMDNOTFND,R0	; SET COMMAND NOT FOUND STATUS
	RSB				; RETURN
	
;
; FETCH SPECIFIED COMMAND BY NUMBER.
;
30$:	CLRQ	-(SP)			; ALLOCATE COMMAND DESCRIPTOR
32$:	PUSHL	SP			; PUSH DESCR ADDRESS
	CALLS 	#1,DCL$GET_PREV_COMMAND	; GET THE PREVIOUS COMMAND
	SOBGTR	R6,32$			; LOOP TILL BACKED UP FAR ENOUGH

;
; SET UP RAB TO REPROMPT WITH THE COMMAND.
;
37$:	MOVQ	(SP)+,R1		; GET COMMAND DESCRIPTOR
	MOVL	PRC_L_INDINPRAB(R11),R4	; ASSUME USING INDIRECT INPUT RAB
	BBC	#PRC_V_YLEVEL,-		; BRANCH IF NOT AT CTRL/Y LEVEL
		PRC_W_FLAGS(R11),40$	;
	MOVL	PRC_L_INPRAB(R11),R4	; USE LEVEL 0 INPUT RAB
40$:	BSBW	INSERT_COMMAND		; INSERT THE COMMAND 
	BRB	90$			;

;
; DISPLAY ALL COMMANDS
;
50$:	MOVL	#^X20312000,-		; SET INITIAL NUMBER STRING
		WRK_G_INPBUF-6(R10)	;
55$:	MOVL	WRK_L_RECALLPTR(R10),R0	; HAVE WE ALREADY DISPLAYED THEM ALL?
	MOVAB	-1(R0),R0		;
	MOVAB	PRC_G_COMMANDS(R11),R1	; WRAP IF NECESSARY
	CMPL	R0,R1			; 
	BGEQU	57$			;
	MOVAB	PRC_G_COMMANDS+PRC_C_CMDBUFSIZ-1(R11),R0
57$:	TSTB	(R0)			; BRANCH IF NO COMMANDS LEFT  
	BEQL	90$			; 
	CLRQ	-(SP)			; ALLOCATE COMMAND DESCRIPTOR
	PUSHL	SP			; PUSH DESCR ADDRESS
	CALLS 	#1,DCL$GET_PREV_COMMAND	; GET THE PREVIOUS COMMAND
	MOVQ	(SP)+,R1		; GET COMMAND DESCRIPTOR
	ADDL	#3,R1			; INSERT THE COMMAND NUMBER
	SUBL	#3,R2			;
	MOVQ	R1,-(SP)		; SAVE COMMAND DESCRIPTOR
	BSBW	DCL$MSGOUT		; OUTPUT THE COMMAND
	MOVQ	(SP)+,R1		; RESTORE COMMAND DESCRIPTOR
	CMPB	1(R2),#^X39 		; IS ONES DIGIT A 9?
	BNEQ	60$			; NO, THEN SKIP
	CMPB	(R2),#^X31 		; IS TENS DIGIT A 1?
	BNEQ	58$			; NO, THEN SKIP
	MOVW	#^X2F32,(R2)		; YES, INSERT "2/"
	BRB	60$			; BRANCH
58$:	MOVW	#^X2F31,(R2)		; INSERT "1/"
60$:	INCB	1(R2)			; INCREMENT THE COMMAND NUMBER

;
; CHECK FOR NO MORE COMMANDS.  
;
	CMPL	PRC_L_RECALLPTR(R11),-	; HAVE WE RETURNED TO THE ORIGIN?
		WRK_L_RECALLPTR(R10)	;
	BEQL	90$			;
	SOBGTR	R6,55$			; OR DISPLAYED THE MAX # OF COMMANDS?

90$:	STATUS	NORMAL			; SET SUCCESS
	RSB				; ALL DONE

	.END
