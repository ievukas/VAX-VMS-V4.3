MODULE DBGLEVEL1 (IDENT = 'V04-000') =
BEGIN
!++
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!--

!++
! FACILITY:	DEBUG (DBG)
!
! ABSTRACT:
!	This module contains all the miscellaneous routines left over from
!	the early days of the debugger. That is, the debugger was mostly
!	rewritten in 1982-1983 but after the rewrite there were still 
!	a handful of routines in different modules that were still used.
!	These routines have all been lumped together in this one module.
!
! Version:	4.0
!
! History:
!	Created by:
!		R. Title , May 1983
!

! Require files:
!
REQUIRE 'SRC$:DBGPROLOG.REQ';
LIBRARY 'LIB$:DBGGEN.L32';

! Table of contents:
!
FORWARD ROUTINE
	dbg$end_of_cmd : NOVALUE,	! END OF COMMAND PROCESSING ROUTINE
	dbg$end_of_line : NOVALUE,	! end of line processing routine
	dbg$write_mem,			! WRITES data TO MEMORY
	dbg$set_context: NOVALUE,	! ROUTINE TO INITIALIZE CONTEXT BITS
	dbg$init_debug : NOVALUE,	! ROUTINE TO INITIALIZE DEBUG UNDER STARLET
	dbg$cis_connecticf : NOVALUE,	! Places icf into input stream
	dbg$cis_remove : NOVALUE,	! Remove a link from the cis
	dbg$cis_add : NOVALUE,		! Add a link to the cis
     	dbg$ins_opcodes: NOVALUE,
	dbg$conv_r_50,			! SPECIAL-PURPOSE RAD50 CONVERSION ROUTINE.
	dbg$out_regname,		! Match and symbolize register names
	dbg$reg_match,			! MATCHES A STRING TO A REGISTER NAME
	dbg$digit_scan,			! scan string for valid numeric
	dbg$output_psl      : NOVALUE,	! ROUTINE TO OUTPUT PSL IN SPECIAL FORMAT
	dbg$map_to_reg_addr,		! Tries to map input address to an address
					! in the reg area in user_runframe
	dbg$exact_map_to_reg,		! Tries to map input address to the address
					! of a reg in user_runframe
    	DBG$LANGUAGE,			! Produce name of given language.
    	DBG$SET_LANG;			! Changes the DEBUG syntax

! Externals
!
EXTERNAL ROUTINE
	dbg$ins_decode,				! ROUTINE TO OUTPUT MEMORY AS
						!  SYMBOLIC INSTRUCTIONS.
	dbg$ins_encode,				! routine to encode a symbolic instruction
	dbg$newline : NOVALUE,			! ACTUALLY DO TERMINAL I/O.
    	dbg$pop_tempmem: NOVALUE,		! Pop a temporary memory pool
    	dbg$push_tempmem,			! Create a new temporary memory pool
	dbg$sta_getsourcemod,			! looks up module rst pointer
						! given the RST pointer
	dbg$src_type_lnum_source : NOVALUE,	! types a range of source line nums
	dbg$src_type_pc_source : NOVALUE,	! types source for a range
						! of PCs.
    	dbg$def_pr_entry,			! Procedure entry code
   	dbg$get_tempmem,			! allocate temporary memory
  	dbg$ncis_add,				! add a CIS to the cis chain

        DBG$CANCEL_LOC_VAL: NOVALUE,	! Cancels '.' and '\'
	dbg$check_prot,				! CHECKS THE PROTECTION OF A PAGE
	DBG$EVENT_INITIALIZATION : NOVALUE,	! Initialize event structures
    	dbg$fao_out: NOVALUE,
    	DBG$FLUSHBUF: NOVALUE,			! Flush the print buffer
    	dbg$get_memory,				! Allocate permanent memory
    	dbg$init_define: NOVALUE,		! Initializes define settings
    	dbg$init_memory: NOVALUE,		! Initialize the free memory pool
	dbg$init_modes,				! INITIALIZES MODES
    	dbg$init_search: NOVALUE,		! Initializes search settings
        DBG$NCANCEL_LOC_AND_VAL : NOVALUE,	! Cancels '.' and '\'
        DBG$NCHANGE_TO_NEW : NOVALUE,	! Switch to new debugger
    	dbg$ncis_remove,
    	dbg$nget_trans_radix,			! Translate radix
    	DBG$PARSER_SET_LANGUAGE : NOVALUE,	! Set up parse table for new language
	dbg$print : NOVALUE,			! FORMATTED BUFFERED OUTPUT.
    	DBG$PRINT_CONTROL,			! Set print control functions
	dbg$read_access,			! verify access to memory
	dbg$redo_prot,				! RESETS THE PROTECTION OF A PAGE TO READ ONLY
	dbg$rel_memory : NOVALUE,		! Release memory
	DBG$REL_TEMPMEM: NOVALUE,		! Release all temporary memory
	DBG$RST_TEMP_RELEASE: NOVALUE,		! Release temporary RST entries
    	dbg$set_define_def: NOVALUE,		! Initializes DEFINE data struc
    	dbg$set_define_lvl: NOVALUE,		! Sets define level back
    	DBG$SET_MOD_DEF,			! initializes mode settings
	dbg$set_mod_lvl,			! SETS MODE pointer
	dbg$set_out_def : NOVALUE,		! Initializes OUTPUT config.
    	DBG$SET_SEARCH_DEF : NOVALUE,	! inititialize search settings
    	dbg$set_search_lvl: NOVALUE,		! Sets search level back
        DBG$SET_STP_DEF,			! initializes step settings
	dbg$sta_setcontext : NOVALUE,		! Sets registers context
    	dbg$sta_symname : NOVALUE,		! Get symbol's name
	for$cnv_in_defg,			! converts a floating or real
    	smg$create_key_table,			! /Initialize data structures
    	smg$create_virtual_keyboard,		! \   used for keypad input.
    	sys$trnlog,				! Translate logical name
	dbg$sta_symvalue : NOVALUE,
	dbg$free_mem_left,			! Longwords remaining in free storage.
    	dbg$nmake_arg_vect,
    	dbg$nout_info,
	for$cnv_out_i,				! Converts integer to ascii string.
	dbg$npathdesc_to_cs	: NOVALUE,	! Get full name of data item
    	lib$get_ef,				! Get event flag
    	lib$free_ef;				! Free event flag

EXTERNAL
    	dbg$gb_set_break_flag: BYTE,		! Flag set to true when parsing
    						!    a SET BREAK command.
    	dbg$gb_radix: VECTOR[3,BYTE],		! Radix settings
	dbg$gl_context: BITVECTOR, 		! CONTEXT WORD
    	dbg$gl_developer: BITVECTOR,		! Developer flags
    	dbg$gl_ind_com_file: REF VECTOR[,BYTE],	! Points to counted string with
    						!    indirect command file name
	dbg$gl_inpfab: BLOCK [, BYTE],		! FAB FOR 'INPUT'
	dbg$gl_inprab: BLOCK [, BYTE],		! RAB FOR 'INPUT'
	dbg$gl_outpfab: BLOCK [, BYTE],		! FAB FOR 'OUTPUT'
	dbg$gl_outprab: BLOCK [, BYTE],		! RAB FOR 'OUTPUT'
	dbg$gl_symhead,				! LIST HEAD FOR SYMBOL TABLE
    	dbg$gl_global_define_ptr,		! Head of DEFINE list for
    						!    globally defined symbols
    	dbg$gl_local_define_ptr,		! Head of DEFINE list for
    						!    locally defined symbols
    	dbg$gl_lis_ptr,
    	dbg$gl_key_table_id,			! Used for DEFINE/KEY
    	dbg$gl_keyboard_id,			! Used for DEFINE/KEY
    	dbg$gb_keypad_input: BYTE,		! TRUE if we are trying to do
    						!    keypad input.
    	dbg$src_term_width,			! Terminal set width
    	dbg$gb_exc_bre_flag: BYTE,		! TRUE during an exception break
    	dbg$gb_go_arg_flag: BYTE,		! TRUE if there is an argument
    						!    to GO.
	dbg$gl_help_input,			! Pointer to HELP input
    	dbg$gb_search_ptr: REF VECTOR[,BYTE],	! Pointer to search structure
	dbg$gb_mod_ptr: REF VECTOR [,BYTE],	! Pointer to the mode structure
    	dbg$gb_set_module_flag: BYTE,		! TRUE during SET MODULE command.
	dbg$gb_resignal: BYTE,			! FLAG FOR RESIGNALING EXCEPTIONS
	dbg$gb_take_cmd: BYTE,			! FLAG WHICH SAYS CONTINUE TO ACCEPT COMMANDS
	dbg$gw_loclngth: word,			! Length field of command override type
	dbg$gl_dimenlst : VECTOR,		! FORTRAN dimension list
    	dbg$gl_nest_level,			! Nesting level of subscripts
    	dbg$gl_nest_stack: VECTOR,		! Stack of saved subscripts
    	dbg$gl_search_verb,			! Head of command execution tree
    						!    for SEARCH
    	dbg$gl_set_source,
    	dbg$gl_set_source2,
	dbg$gl_current_primary,			! The primary being processed
	dbg$gl_list: VECTOR,			! LIST FOR EXPRESSIONS
	dbg$gl_loctyp,				! command override type.
	dbg$gl_dflttyp,				! type given in SET TYPE.
	dbg$gl_gbltyp,				! type given in SET TYPE/OVERRIDE.
	dbg$gl_stk : semantic_stack,		! semantic stack for tokens etc.
	DBG$GB_STP_PTR :    REF EVENT$STEPPING_DESCRIPTOR, ! POINTER TO CURRENT STEP TYPE
	dbg$gl_step_num,			! number of steps to take in single step mode
	dbg$pseudo_prog,			! Used for DEBUG's CALL command.
	dbg$gl_logfab : BLOCK [,BYTE],		! FAB for LOG file
	dbg$gl_cishead : REF cis$link,		! Head of command input stream
	dbg$gl_modrstptr2,			! Holds module pointer during
						! TYPE command.
	dbg$gl_module,				! Hold module pointer during
						! SET SOURCE/MODULE= command.
	dbg$gl_dirlist,				! Holds pointer to directory
						! list during 
						! SET SOURCE dir-list
						! command.
    	dbg$src_left_margin,			! left margin for source display
    	dbg$src_right_margin,			! right margin for source display
	dbg$gv_control	: dbg$control_flags,	! DEBUG control bits
	dbg$gw_gbllngth : WORD,			! OVERRIDE LENGTH
	dbg$gl_next_loc,			! NEXT location TO DISPLAY
	dbg$gb_language : BYTE,			! LANGUAGE INDEX
	dbg$reg_values : VECTOR,		! Context regs save area
	dbg$runframe : BLOCK [, BYTE],		! current run frame
	dbg$src_next_modrstptr,			! module pointer used by 
						! dbg$type_cmd.
	dbg$src_next_lnum,			! Contains next line num to
						! typed if no line num is 
						! specified in the TYPE
						! command.
	dbg$src_next_stmt,			! as above with stmt num
    	DBG$GL_GET_LEX,				! Holds name of current get lex routine
    	DBG$GL_PARTBPTR : VECTOR,		! List of parse table addresses
    	DBG$GL_REDUC_RT,			! Name of action routine for a syntax
	dbg$gb_def_out : VECTOR [,BYTE],	! Current OUTPUT configuration
	dbg$gw_dfltleng : WORD,			! The length specified in a SET TYPE statement.
	rst$start_addr: REF rst$entry,		! Pointer to the module chain (MC).	
	dbg$gl_asci_len,			! Length of ascii string.
	dbg$gb_loc_type: BYTE,			! TYPE OF LAST LOCATION EXAMINED
	dbg$gl_csp_ptr,				! pointer to current scope
	dbg$gl_last_loc,			! CURRENT LOCATION
	dbg$gl_last_val;			! CURRENT VALUE

! Link symbol saying whether we are linking a debugger to run on a
! version 3B system.
!
EXTERNAL LITERAL
    	dbg$gl_3b_system: WEAK;

GLOBAL ROUTINE DBG$NCOB_PATHDESC_TO_CS(pathname,name_string) : NOVALUE =
    BEGIN
    MAP pathname	: REF pth$pathname;

    LOCAL
	name_vector	: REF VECTOR[,LONG],
	name_count,
	top_name	: REF VECTOR[,BYTE],
	sub_name	: REF VECTOR[,BYTE],
	pointer,length;

    name_vector = pathname[pth$a_pathvector];
    name_vector = name_vector[.pathname[pth$b_pathcnt]];
    name_count  = .pathname[pth$b_totcnt] - .pathname[pth$b_pathcnt];
    pathname[pth$b_totcnt]   = .pathname[pth$b_pathcnt];
    dbg$npathdesc_to_cs(.pathname,top_name);
    length = .(.top_name)<0,8,0>;
    DECR index FROM .name_count-1 TO 0 DO
	BEGIN
	sub_name = .name_vector[.index];
	IF .(.sub_name)<0,8,0> GTR 0 THEN length=.length+.(.sub_name)<0,8,0>+4;
	END;
    .name_string = pointer = dbg$get_tempmem((.length/%UPVAL)+1);
    ch$wchar_a(.length,pointer);
    DECR index FROM .name_count-1 TO 0 DO
	BEGIN
	sub_name = .name_vector[.index];
	IF .(.sub_name)<0,8,0> GTR 0
	THEN
	    BEGIN
	    ch$move(.(.sub_name)<0,8,0>,sub_name[1],.pointer);
	    pointer = .pointer + .(.sub_name)<0,8,0>;
	    ch$move(4,UPLIT BYTE(' of '),.pointer);
	    pointer = .pointer + 4;
	    END;
	END;
    ch$move(.(.top_name)<0,8,0>,top_name[1],.pointer);
    END;		! end of routine dbg$ncob_pathdesc_to_cs

GLOBAL ROUTINE DBG$END_OF_CMD : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Resets all DEBUG context that is exclusive to a single
!	DEBUG command. This includes resetting default
!	modes from single line overrides back to the actual default
!	modes and resetting a large number of context bits.
!
!	This routine also releases all temporary memory allocated in the
!	course of processing the command, and it releases all unreferenced
!	RST entries on the Temporary RST Entry List.
!
! FORMAL PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!	The default modes, step-modes, and context bits are established.
!	Some global storage is re-initialized and all excess storage is released.
!
! ROUTINE VALUE:
!	novalue
!
! SIDE EFFECTS:
!	none
!--

    BEGIN

	!+
	! Set the exit flag to true so that if an error occurs during
	! the processing of this routine, that error is perceived
	! as fatal. This routine guarantees the internal consistency
	! of DEBUG, and must succeed or give up.
	!-
	dbg$gv_control[dbg$v_control_exit] = TRUE;

    	! Clear the ALLOCATE flag. This is set during SET MODULE/ALLOCATE
    	! to allow the allocation of additional memory.
    	!
    	dbg$gv_control[dbg$v_control_allocate] = FALSE;

    	! Reset the Print control for DBG$PRINT.  And flush out the print 
    	! buffer.
    	!
    	DBG$PRINT_CONTROL(DBG$K_PRT_RESET);
    	DBG$FLUSHBUF();

    	! Reset mode level to user default level
    	!
	dbg$init_modes (override_mode, user_def_mode);
	dbg$set_mod_lvl (user_def_mode);

    	! Reset search settings back to user default level
    	!
    	dbg$init_search (override_search, user_def_search);
    	dbg$set_search_lvl (user_def_search);

    	! Reset define settings back to user default level
    	!
    	dbg$init_define (override_define, user_def_define);
    	dbg$set_define_lvl (user_def_define);

	dbg$set_context ();

	DBG$REL_TEMPMEM();
	DBG$RST_TEMP_RELEASE();
	dbg$gl_list [0] = 0;		! Zero out the locations that hold breakpoint setting data.
	dbg$gl_list [1] = 0;
	dbg$gl_list [2] = 0;
	dbg$gl_lis_ptr  = 0;		! Zero current ptr to command arg list
	dbg$gl_asci_len = .dbg$gb_mod_ptr[mode_length];	! Initialize ascii length
	dbg$gl_loctyp = -1;		! Zero command override type.
	dbg$gw_loclngth= 0;		! And its associated length.

	dbg$gl_module = 0;		! Zero out global used to hold 
					! module pointer during
					! SET SOURCE/MODULE= command.
	dbg$gl_modrstptr2 = 0;		! Zero out global used to hold 
					! module pointer during
					! TYPE command.
    	dbg$gl_set_source = 0;
    	dbg$gl_set_source2 = 0;
	dbg$gl_current_primary = 0;	! Clear the current primary cause there isn't one anymore
    	dbg$gb_set_module_flag = FALSE;	! This flag is TRUE during a SET MODULE 
    					!    command.
	zerocor (dbg$gl_dimenlst, 10);	! Zero storage to hold array dimensions.
    	zerocor (dbg$gl_nest_stack, 25);! Zero storage to hold array dimensions
    					!     during nested subscript evaluation
    	dbg$gl_nest_level = 0;		! Nesting level of subscript expressions
    					!     set back to zero.
    	dbg$gb_set_break_flag = FALSE;	! Initialize a flag saying whether we
    					! are in the middle of processing a
    					! SET BREAK command. This is used in
    					! DBGPARSER to resolve ambiguities
    					! involving SET BREAK . DO (command).
    					! This flag gets set to TRUE in DBGEVENT
    					! when we discover we are indeed 
    					! processing a SET BREAK command.

	dbg$sta_setcontext (0);		! Set default register context

					! Now cancel exit flag since all went well.
	dbg$gv_control[dbg$v_control_exit] = FALSE;
    END;

GLOBAL ROUTINE dbg$end_of_line : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Calls dbg$end_of_cmd to reset all single command context.
!	Then frees the storage that was allocated to hold the command
!	line. The top link of the command input stream is removed, but
!	only if it is of type "buffer".
!
! FORMAL PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	The head of the command argument list.
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	Defaults are reestablished. Storage for input line is freed.
!	A link may be removed from the command argument list.
!--
    BEGIN
    LOCAL 
    	type;

	dbg$end_of_cmd ();		! Perform end of command cleanup
	dbg$gv_control[dbg$v_control_exit] = TRUE;	! Set the exit flag to return to CLI on errors

	! We only want to remove the top link of the cis if that link is a
	! buffer of some flavor. If the top link is of type cis_rab, it has
	! just been put there by an @... command and not yet read from.

    	type = .dbg$gl_cishead [cis$b_input_type];
	IF .type EQL cis_inpbuf
	OR .type EQL cis_acbuf
   	OR .type EQL cis_while
    	OR .type EQL cis_repeat
    	OR .type EQL cis_if
	THEN
		dbg$cis_remove();

	dbg$gv_control[dbg$v_control_exit] = FALSE;	! Reset exit flag.

    END;


GLOBAL ROUTINE dbg$write_mem (dest_address, src_address, length) =
!++
! FUNCTIONAL DESCRIPTION:
!	Writes a sequence of values (bytes) to memory in
!	the user program.  The destination, source, and
!	number of bytes to write are all passed as parameters.
!
!	THE PROTECTION OF THE FIRST BYTE TO BE WRITTEN AND THE LAST
!	BYTE TO BE WRITTEN ARE BOTH CHECKED. THE STATUS OF BOTH PAGES
!	(THEY MAY BE THE SAME PAGE) IS SAVED. THEN THE VALUE IS WRITTEN
!	TO THE ADDRESS (THE PAGE PROTECTION IS CHANGED DURING THE
!	CHECKING OPERATION).
!
!	THEN, IF THE PROTECTION WAS CHANGED IN EITHER CASE, THE
!	PROTECTION IS REESTABLISHED. IF EVERYTHING WAS SUCCESSFUL,
!	THE ROUTINE RETURNS TRUE. OTHERWISE, IT RETURNS FALSE.
!
! Formal Parameters:
!	dest_address	- THE ADDRESS OF THE LOCATION TO BE CHANGED
!	src_address	- The address of where the bytes are stored.
!	length		- The number of bytes to be written.
!
! IMPLICIT INPUTS:
!	None.
!
! IMPLICIT OUTPUTS:
!	THE PAGE PROTECTION MAY BE MOMENTARILY ALTERED, THEN REINSTALLED.
!
! ROUTINE VALUE:
!	TRUE OR FALSE
!
! SIDE EFFECTS:
!	THE VALUE IS WRITTEN TO MEMORY
!--
	BEGIN

	MAP
		dest_address	: REF VECTOR[,BYTE],
		src_address	: REF VECTOR[,BYTE];

	LOCAL
		prot_status_1,
		protection_1: BYTE,
		prot_status_2,
		protection_2: BYTE;

	IF ((prot_status_1 = dbg$check_prot (.dest_address, protection_1)) NEQ 0) 
		AND ((prot_status_2 = dbg$check_prot (.dest_address + .length - 1, protection_2)) NEQ 0)
	THEN
		BEGIN

		!++
		! PROTECTION HAS EITHER BEEN ALTERED SUCCESSFULLY, OR IT
		! DID NOT NEED TO BE ALTERED. NOW WRITE THE VALUE INTO THE
		! ADDRESS.
		!--

		CH$MOVE (.length, src_address [0], dest_address [0]);

		!++
		! IF EITHER OF THE PROTECTION STATUSES SAY RESET THE PROTECTION
		! (TO READ ONLY), THEN RESET THE PROTECTION ON THAT PAGE.
		!--

		IF .prot_status_1 EQL dbg$k_reset_prt
		THEN
			BEGIN
			dbg$redo_prot (.dest_address, protection_1);
			END;

		IF .prot_status_2 EQL dbg$k_reset_prt
		THEN
			BEGIN
			dbg$redo_prot (.dest_address + .length - 1, protection_2);
			END;

		RETURN TRUE			! User program updated correctly
		END
	ELSE
		RETURN FALSE

	END;

GLOBAL ROUTINE dbg$set_context : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!	initializes context bits that are necessary for command
!	processing. These bits are valid only during the processing
!	of a single command. They are all reset after each command.
!
! CALLING SEQUENCE:
!	dbg$set_context ()
!
! INPUTS:
!	none
!
! IMPLICIT INPUTS:
!	the names of the context bits that are to be turned off
!
! OUTPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	novalue
!
! SIDE EFFECTS:
!	the context bits are set to false
!--

	BEGIN
 	dbg$gl_context [dbg$k_all]	 = FALSE;
	dbg$gl_context [dbg$k_all_break] = FALSE;
	dbg$gl_context [dbg$k_all_trace] = FALSE;
	dbg$gl_context [dbg$k_all_watch] = FALSE;
 	dbg$gl_context [dbg$k_break]	 = FALSE;
 	dbg$gl_context [dbg$k_cancel]	 = FALSE;
 	dbg$gl_context [dbg$k_examine]	 = FALSE;
 	dbg$gl_context [dbg$k_language]	 = FALSE;
 	dbg$gl_context [dbg$k_mode]	 = FALSE;
 	dbg$gl_context [dbg$k_module]	 = FALSE;
 	dbg$gl_context [dbg$k_override]	 = FALSE;
 	dbg$gl_context [dbg$k_resignal]	 = FALSE;
 	dbg$gl_context [dbg$k_scope]	 = FALSE;
    	dbg$gl_context [dbg$k_search] 	 = FALSE;
 	dbg$gl_context [dbg$k_set_break] = FALSE;
	dbg$gl_context [dbg$k_step]	 = FALSE;
 	dbg$gl_context [dbg$k_trce_call] = FALSE;
 	dbg$gl_context [dbg$k_trace]	 = FALSE;
 	dbg$gl_context [dbg$k_traceback] = FALSE;
	dbg$gl_context [dbg$k_watch]	 = FALSE;
	dbg$gl_context [dbg$k_trce_brch] = FALSE;
	dbg$gl_context [dbg$k_thread]	 = FALSE;
	dbg$gl_context [dbg$k_output]	 = FALSE;
	dbg$gl_context [dbg$k_log]	 = FALSE;
	dbg$gl_context [dbg$k_source]	 = FALSE;
    	dbg$gl_context [dbg$k_margins]   = FALSE;
	dbg$gl_context [dbg$k_maxfiles]	 = FALSE;
	END;

GLOBAL ROUTINE DBG$INIT_DEBUG: NOVALUE =
!
! FUNCTION
!	This routine drives the DEBUG initialization when DEBUG first comes up.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    BIND
	DBG_INPUT_DEVICE	= UPLIT BYTE (%ASCII 'DBG$INPUT'),
	DBG_INP_DEV_SIZE	= %CHARCOUNT (%ASCII 'DBG$INPUT'),
	DBG_OUTPUT_DEVICE	= UPLIT BYTE (%ASCII 'DBG$OUTPUT'),
	DBG_OUT_DEV_SIZE	= %CHARCOUNT (%ASCII 'DBG$OUTPUT'),

	SYS_INPUT_DEVICE	= UPLIT BYTE (%ASCII 'SYS$INPUT'),
	SYS_INP_DEV_SIZE	= %CHARCOUNT (%ASCII 'SYS$INPUT'),
	SYS_OUTPUT_DEVICE	= UPLIT BYTE (%ASCII 'SYS$OUTPUT'),
	SYS_OUT_DEV_SIZE	= %CHARCOUNT (%ASCII 'SYS$OUTPUT');

    LOCAL
	DEF_RADIX,			! Default radix
	DEVCHAR: REF BLOCK[,BYTE],	! Device characteristics field
	DUMMY: VECTOR[2],		! Output area for $TRNLOG
	DUMMY_BUFFER: VECTOR[256,BYTE],	! "
    	EVNT_FLAG,
	FILESPEC: DBG$STG_DESC,		! String descriptor
	HEADER: REF DEFINE$HEADER, 	! Header block for define
					!     symbol table.
    	ITEM: BLOCK[6, LONG],		! Item list for $GETSYI
    	LEN,
    	OPEN_STATUS,			! Save the failing status from $OPEN 
    					!     DBG$INPUT
    	OUTPUT_STATUS,			! Save the failing status from $CREATE
    					!     DBG$OUTPUT
	SDBGINIT_STGDESC: BLOCK[8,BYTE],! String descriptor
	SDBGINIT_STG: VECTOR [9, BYTE],	! String in string descriptor
	STATUS,
	STATUS1,
    	VERSION_BUFFER: VECTOR[8, BYTE];



    ! Initialize an area of free storage.  This must be done first since many
    ! of the things below will call the memory allocation routines.
    !
    DBG$INIT_MEMORY();

    
    ! Initialize the bit that says whether we are on a V4 system.
    ! We call the system service $GETSYI to find out this information.
    !
    ! Note - the code to call GETSYI is commented out because this
    ! turned out to be unreliable (could get back a variety of things,
    ! such as "V3.5", "X3.5", "X29T", "X4.0", "V4.0"). We are instead
    ! just using a link-time symbol (see below).
    !
    ! ITEM[0,0,16,0] = 8;
    ! ITEM[0,16,16,0] = SYI$_VERSION;
    ! ITEM[1,0,32,0] = VERSION_BUFFER;
    ! ITEM[2,0,32,0] = LEN;
    ! CH$FILL(0, 12, ITEM[3, A_]);
    ! STATUS = LIB$GET_EF(EVNT_FLAG);
    ! IF NOT .STATUS THEN EVNT_FLAG = 0;
    ! STATUS = $GETSYI(EFN=.EVNT_FLAG, ITMLST=ITEM);
    ! IF .STATUS
    ! THEN

    	! Version 3 systems will return "V3.x" in VERSION_BUFFER.
    	!
    	! DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4] = NOT
    	!     ((.VERSION_BUFFER[0] EQL 'V') AND (.VERSION_BUFFER[1] EQL '3'))

    ! ELSE

    	! $GETSYI failed. Make a guess that we are a 3B system.
    	!
    	! DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4] = 1;

    ! LIB$FREE_EF(EVNT_FLAG);

    
    ! Initialize the bit that says whether we are on a 3B system.
    ! We rely on a link-time symbol DBG$GL_3B_SYSTEM.
    !
    DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4] = DBG$GL_3B_SYSTEM;


    ! Initialize the global which says whether we are trying to do
    ! keypad input. 
    !
    DBG$GB_KEYPAD_INPUT = .DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4];


    ! Open the input device for reading.  If the OPENs and CONNECTs cannot be
    ! done successfully for logical devices 'DBG$INPUT' and 'DBG$OUTPUT', then
    ! try 'SYS$INPUT' and 'SYS$OUTPUT'.  If these fail, signal an error.  This
    ! causes a return to the command line interpreter in the operating system.
    !
    DBG$GL_INPFAB [FAB$L_FNA] = DBG_INPUT_DEVICE;
    DBG$GL_INPFAB [FAB$B_FNS] = DBG_INP_DEV_SIZE;
    OPEN_STATUS = $OPEN (FAB = DBG$GL_INPFAB);
    IF NOT .OPEN_STATUS 
    THEN
	BEGIN
	DBG$GL_INPFAB [FAB$L_FNA] = SYS_INPUT_DEVICE;
	DBG$GL_INPFAB [FAB$B_FNS] = SYS_INP_DEV_SIZE;
	STATUS = $OPEN (FAB = DBG$GL_INPFAB);
	IF NOT .STATUS THEN $EXIT(CODE = .STATUS OR FATAL_BIT);
	END;


    ! Connect the input file.
    !
    DBG$GL_INPRAB[RAB$L_FAB] = DBG$GL_INPFAB;
    STATUS = $CONNECT(RAB = DBG$GL_INPRAB);
    IF NOT .STATUS THEN $EXIT(CODE = .STATUS OR FATAL_BIT);


    ! CREATE and OPEN the output file.
    !
    DBG$GL_OUTPFAB [FAB$L_FNA] = DBG_OUTPUT_DEVICE;
    DBG$GL_OUTPFAB [FAB$B_FNS] = DBG_OUT_DEV_SIZE;
    OUTPUT_STATUS = $CREATE (FAB = DBG$GL_OUTPFAB);
    IF NOT .OUTPUT_STATUS
    THEN
	BEGIN
	DBG$GL_OUTPFAB [FAB$L_FNA] = SYS_OUTPUT_DEVICE;
	DBG$GL_OUTPFAB [FAB$B_FNS] = SYS_OUT_DEV_SIZE;
	STATUS = $CREATE (FAB = DBG$GL_OUTPFAB);
	IF NOT .STATUS THEN $EXIT(CODE = .STATUS OR FATAL_BIT);
	END;


    ! CONNECT the output file.
    !
    DBG$GL_OUTPRAB[RAB$L_FAB] = DBG$GL_OUTPFAB;
    STATUS = $CONNECT(RAB = DBG$GL_OUTPRAB);
    IF NOT .STATUS THEN $EXIT(CODE = .STATUS OR FATAL_BIT);


    ! We need to delay this message output till SYS$INPUT, SYS$OUTPUT are 
    ! established. Otherwise, DBG$PUTMSG in DBG$FINAL_HANDL does not know
    ! where to output the message.
    !
    IF NOT .OPEN_STATUS THEN SIGNAL(DBG$_UNAOPEDBGI, 0, .OPEN_STATUS);
    IF NOT .OUTPUT_STATUS THEN SIGNAL(DBG$_UNACREDBGO, 0, .OUTPUT_STATUS);


    ! Get the terminal width.
    !
    DEVCHAR = DBG$GL_OUTPFAB[FAB$L_DEV];
    IF .DEVCHAR[DEV$V_TRM]
    THEN
    	BEGIN
    	LOCAL
    	    DEV_DESC: VECTOR[2,LONG],
    	    INFO_4: VECTOR[4,LONG],
    	    RETURN_LENGTH;

    	DEV_DESC[0] = %X'010E0000' OR .	DBG$GL_OUTPFAB [FAB$B_FNS];
    	DEV_DESC[1] = .DBG$GL_OUTPFAB [FAB$L_FNA];
    	INFO_4[0] = DVI$_DEVBUFSIZ^16 OR 4;
    	INFO_4[1] = DBG$SRC_TERM_WIDTH;
    	INFO_4[2] = RETURN_LENGTH;
    	INFO_4[3] = 0;
	STATUS = $GETDVI(DEVNAM=DEV_DESC, ITMLST=INFO_4);
    	IF NOT .STATUS THEN SIGNAL(.STATUS);
    	END

    ELSE
	DBG$SRC_TERM_WIDTH = 80;


    ! Set the flag that says resignal all exceptions from the user
    ! program except for user-set breakpoints and tracepoints.
    !
    DBG$GB_RESIGNAL = TRUE;


    ! Initialize the define settings.
    !
    DBG$SET_DEFINE_DEF();


    ! Initialize the DEFINE symbol table by allocating space for
    ! the header blocks, and initializing the fields to be zero.
    ! Note that this must be done before DBG$SET_LANG.
    !
    HEADER = DBG$GET_MEMORY (DBG$K_DEFINE_HEADER_SIZE_W);
    HEADER [DEF$A_NEXT_LINK] = 0;
    HEADER [DEF$A_PREV_LINK] = 0;
    HEADER [DEF$A_DEFINE_LIST] = 0;
    DBG$GL_GLOBAL_DEFINE_PTR = .HEADER;
    HEADER = DBG$GET_MEMORY (DBG$K_DEFINE_HEADER_SIZE_W);
    HEADER [DEF$A_NEXT_LINK] = 0;
    HEADER [DEF$A_PREV_LINK] = 0;
    HEADER [DEF$A_DEFINE_LIST] = 0;
    DBG$GL_LOCAL_DEFINE_PTR = .HEADER;


    ! Set the default language, namely MACRO.
    !
    DBG$SET_LANG(0,DBG$K_MACRO);


    ! Set all the single command context bits to FALSE.  These bits refer to
    ! context that is valid only during a single command, not across multiple
    ! commands.
    !
    DBG$SET_CONTEXT ();


    ! Initialize the new eventpoint data structures.
    !
    DBG$EVENT_INITIALIZATION ();


    ! Initialize the Command Input Stream to DBG$INPUT
    !
    DBG$GL_CISHEAD = DBG$GET_MEMORY ((CIS_ELEMENTS+3)/%UPVAL);
    DBG$GL_CISHEAD[CIS$A_NEXT_LINK] = 0;
    DBG$GL_CISHEAD[CIS$B_INPUT_TYPE] = CIS_DBG$INPUT;
    DBG$GL_CISHEAD[CIS$A_INPUT_PTR] = DBG$GL_INPRAB;


    ! Initialize the OUTPUT configuration
    !
    DBG$SET_OUT_DEF();


    ! Note - processing initialization files must be done last.  If there was
    ! an initialization file, add it to the command input stream. For DEBUG,
    ! the initialization file is specified by the logical name DBG$INIT, and
    ! for SUPERDEBUG, it is specified by the logical name SDBG$INIT.
    !
    DUMMY[0] = %X'010E0000'+256;
    DUMMY[1] = DUMMY_BUFFER;


    ! We need to allocate space for the file name and copy 'DBG$INIT' or
    ! 'SDBG$INIT' into this space.  The reason for this is that DBG$CIS_REMOVE
    ! will free up the space.  Also, fill in the string descriptor to
    ! be used in SYS$TRNLOG.  Note - do NOT replace this with a %ASCID
    ! declaration.  %ASCID causes the code to be non-shareable and thus
    ! degrades performance. 
    !
    DBG$GL_IND_COM_FILE = DBG$GET_MEMORY (3);
    SDBGINIT_STGDESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    SDBGINIT_STGDESC [DSC$B_DTYPE] = DSC$K_DTYPE_T; 
    SDBGINIT_STGDESC [DSC$A_POINTER] = SDBGINIT_STG;
    IF .DBG$GV_CONTROL[DBG$V_CONTROL_SDBG]
    THEN
	BEGIN
	SDBGINIT_STGDESC [DSC$W_LENGTH] = 9;
	CH$MOVE(9, UPLIT BYTE(%ASCII 'SDBG$INIT'), SDBGINIT_STG);
	STATUS = SYS$TRNLOG(SDBGINIT_STGDESC, 0, DUMMY, 0, 0, 0);
	IF .STATUS EQL SS$_NORMAL
	THEN
	    BEGIN
	    DBG$GL_IND_COM_FILE[0] = 9;
	    CH$MOVE(9, UPLIT BYTE(%ASCII 'SDBG$INIT'), DBG$GL_IND_COM_FILE[1]);
	    DBG$CIS_CONNECTICF(FALSE);
	    END;

	END

    ELSE
	BEGIN
	SDBGINIT_STGDESC [DSC$W_LENGTH] = 8;
	CH$MOVE(8, UPLIT BYTE(%ASCII 'DBG$INIT'), SDBGINIT_STG);
	STATUS = SYS$TRNLOG(SDBGINIT_STGDESC, 0, DUMMY, 0, 0, 0);
	IF .STATUS EQL SS$_NORMAL
	THEN
	    BEGIN
	    DBG$GL_IND_COM_FILE[0] = 8;
	    CH$MOVE(8, UPLIT BYTE(%ASCII 'DBG$INIT'), DBG$GL_IND_COM_FILE[1]);
	    DBG$CIS_CONNECTICF(FALSE);
	    END;

	END;


    ! Initialization is complete and successful.  Output the DEBUG header
    ! message with the version number and return.
    !
    IF .DBG$GV_CONTROL[DBG$V_CONTROL_SDBG]
    THEN
	$FAO_TT_OUT('!/	 VAX SUPERDEBUG Version 4.0-8!/')

    ELSE
	$FAO_TT_OUT('!/	 VAX DEBUG Version 4.0-8!/');

    RETURN;
    END;

GLOBAL ROUTINE dbg$ins_opcodes (user_pc_value) : NOVALUE =
BEGIN
0
END;

GLOBAL ROUTINE dbg$conv_r_50( OPWORD, DST_PTR ) =
!++
! FUNCTIONAL DESCRIPTION:
!	THIS ROUTINE IS A SPECIAL-PURPOSE RAD50-TO-ASCII CONVERSION
!	ROUTINE.  IT TAKES A LONGWORD CONTAINING 2 RAD50 WORDS,
!	CONVERTS THEM TO A 6-character STRING, AND 'STUFFS' THESE 
!	characters INTO THE BYTE VECTOR WE ARE PASSED A POINTER TO.
!
! WARNING:
!	THE REST OF THE CODE WHICH INTERFACES TO THIS USES THE
!	LITERAL 'OP_CH_SIZE' TO REFER TO THIS 6-character STRING,
!	BUT THIS SIZE IS IMPLICIT IN THE CODE HERE.  IF THIS
!	CODE IS CHANGED, THE LITERAL MUST ALSO BE CHANGED.  JUST
!	CHANGING THE LITERAL IS NOT ENOUGH.
!
! CALLING SEQUENCE:
!	dbg$conv_r_50 ( LONGWORD, BYTE_POINTER );
!
! INPUTS:
!	OPWORD	- THE LONGWORD WHICH CONTAINS THE 6 RAD50 characters.
!		- THIS WORD COMES FROM THE OP_NAME FIELD OF THE
!		  dbg$GB_OPINFO DATA VECTOR.
!	DST_PTR - ANY BYTE ADDRESS INTO WHICH THIS ROUTINE WILL
!		  STUFF THE 6 ASCII characters OBTAINED FROM OPWORD.
!
! IMPLICIT INPUTS:
!	OP_CH_SIZE - FROM VAXOPS.REQ, WHICH MUST BE 6 TO MATCH THIS CODE.
!
! OUTPUTS:
!	NONE.
!
! IMPLICIT OUTPUTS:
!	THE 6 ASCII chars ARE STUFFED BACK INTO THE USER-SUPPLIED
!	STRING.
!
! ROUTINE VALUE:
!	The number of non-blank characters stuffed into
!	the output string.
!
! SIDE EFFECTS:
!	SEE IMPLICIT OUTPUTS.
!--

    BEGIN

    MAP
	DST_PTR : REF VECTOR[,BYTE];	! WHERE TO STUFF THE chars.

    LOCAL
	non_blanks,
	J,	! INDEX.
	W,	! THE LONGWORD.
	PTR : REF VECTOR[,BYTE];

    BIND
	DIVTAB = UPLIT(1, %O'50', %O'3100') : VECTOR;

	! JUST EXTRACT EACH OF THE TWO WORDS, CONVERT THEM,
	! AND STUFF BACK THE RESTULS.

	PTR = .DST_PTR;
	non_blanks = 0;

	INCR K FROM 0 TO 16 BY 16
	    DO
	    BEGIN ! DO THE CONVERSION ON BOTH WORDS SEPARATELY.
	
	    W = .OPWORD<.K,16>;
	
	    DECR I FROM 2 TO 0 DO
		BEGIN
		J = .W/.DIVTAB[.I]; W = .W - .J*.DIVTAB[.I];
		IF .J NEQ 0
		THEN
		    BEGIN
		    IF .J NEQ %O'33'
		    THEN
			BEGIN
			IF .J LSS %O'33' THEN J = .J + %O'56';
			J = .J + %O'11';
			END;
		    J = .J + %O'11';
		    END
		ELSE
		    J = %O'40';
	
		! AT THIS POINT, A SINGLE char IS IN BYTE 0 OF J.
		! Stuff the character back and tally up the
		! number of non-blank ones.
	
		IF( ((.PTR)<0,8> = .J) NEQ %O'40' )
		then
			non_blanks = .non_blanks +1;

		PTR = .PTR + 1;
		END;
	
	END;
	! END OF K LOOP.
	
    !Return the number of non-blank characters
    ! we stuffed back.

    RETURN(.non_blanks);
    END; ! OF conv_r_50 ROUTINE.

global routine dbg$octal_valtostg_cvt(value, count) =

! ++
! Functional Description:
! 	Convert a value to an ascii string. The string, when
!	printed, displays the octal representation of the value.
!
! Inputs
!	value - the actual value we are to convert.
!	count - the number of characters in the result string.
!
! Routine Value
!	A pointer to a counted string.
! Side effects
!	Allocates space for the result. This should be
!	freed by the caller when he is finished with it.
! --

    begin

    own
	result_ptr : ref vector[,byte],
    
	tran_table : vector[8,byte]
		     initial( byte( %ascii '01234567'));

    ! allocate space for the string.
    result_ptr = dbg$get_memory(((1+.count)/%upval)+1);

    if .result_ptr eql 0 then signal(dbg$_nofree)
    else 

	! fill in result string from right to left.
	decr i from .count to 1 do
	    begin
	    result_ptr[.i] = .tran_table[.value mod 8];
	    value = .value / 8
	    end;

    ! fill in the count.
    result_ptr[0] = .count;

    .result_ptr

    end; ! of dbg$octal_valtostg_cvt


global routine dbg$decimal_valtostg_cvt(in_value_ptr,len) =
!++
! Functional description:
!	Converts a value to an ascii string to be printed.
! Inputs
!	in_value_ptr -	points to the place in memory where the
!			value is stored.
!	len       -	length in bytes of the value
! Routine value
!	A pointer to a counted string with the result.
!	Storage for the result string is allocated dynamically
!	by calling dbg$get_memory.
! Side effects
!	Allocates space for the result. This should be
!	released by the caller.
!--
    begin
    map 
        in_value_ptr : ref bitvector [] ;

    local
        value_copy : bitvector[128],
    	value_ptr : ref bitvector[],
	sign_flag,
	string : ref vector[,byte],
	power_of_two,
	new_string : ref vector[,byte],
	new_power_of_two;


			! define extended precision add routine which
			! operates on counted ascii strings.
			routine addc(a,b) =
			    begin
			    map a : ref vector [,byte],
				b : ref vector [,byte];
			    local 
				temp,
				m,
				n,
				carry,
				result : ref vector [,byte];
			    own ctable : vector[20,byte]
				initial(byte('01234567890123456789')); 
			    ! n is size of larger argument
			    n = (if .a[0] gtr .b[0] then .a[0] else .b[0]);
			    ! m is size of smaller argument.
			    m = (if .a[0] gtr .b[0] then .b[0] else .a[0]);
			    ! dbg$get_memory takes longword sizes.
			    result = dbg$get_memory((2+.n)/4+1);
			    carry = 0;
			    decr i from .n to 1+.n-.m do
				begin
				result[.i+1] = .ctable[temp =
				    (.carry+
					(if .a[0] gtr .b[0]
					then .a[.i] +
					    .b[.i-(.n-.m)]
					else .b[.i] +
					    .a[.i-(.n-.m)])
					    - 2*%C'0')];
				carry = .temp geq 10;
				end;
			    decr i from .n-.m to 1 do
				begin
				result[.i+1] = .ctable[temp=
					(.carry+
					(if .a[0] gtr .b[0] 
					then .a[.i]
					else .b[.i]) -
					%C'0')];
				carry = .temp geq 10;
				end;
			    if .carry eql 1 then
				begin
				result[0] = .n+1;
				result[1] = %C'1';
				end
			    else
				begin
				result[0] = .n;
				ch$move(.n,
				    result[2],result[1]);
				end;
			    .result
			    end; ! addc

    			! Copy the value to be examined into a local variable
    			!
    			value_ptr = value_copy;
    			ch$move (16, .in_value_ptr, .value_ptr);

			! now build up print string representing the
			! octaword integer.
			string = dbg$get_memory(1);
			power_of_two = dbg$get_memory(1); 
			(.string) = %ASCIC'0';
			(.power_of_two) = %ASCIC'1';
			sign_flag = 0;
			IF .value_ptr[8*.len-1] EQL 1 
			THEN ! sign bit set.
			    BEGIN
			    sign_flag = 1;
			    ! negate number.
			    incr i from 0 to .len/4-1 do
				(.value_ptr+4*.i) =
				    NOT .(.value_ptr+4*.i);
			    END;
			incr i from 0 to (8*.len)-2 do
			    begin
			    ! look at the ith bit of the integer.
			    IF .value_ptr[.i] EQL 1
			    THEN 
				BEGIN
				! if the bit is set, must add in the
				! appropriate power of two.
				new_string = addc(.string,.power_of_two);
				dbg$rel_memory(.string);
				string = .new_string;
				END;
			    new_power_of_two = addc(
				.power_of_two,.power_of_two);
			    dbg$rel_memory(.power_of_two);
			    power_of_two = .new_power_of_two;
			    end; ! loop
			IF .sign_flag EQL 1 
			THEN
			    BEGIN
			    ! un-complement number
			    ! (we complemented earlier)
			    incr i from 0 to .len/4-1 do
				(.value_ptr+4*.i) =
				    NOT .(.value_ptr+4*.i);
			    ! add 1 (we complemented earlier)
			    new_string = addc(.string, 
				UPLIT BYTE(%ASCIC '1'));
			    ! append minus sign.
			    string = dbg$get_memory(1+(2+.new_string[0])/4);
			    string[0] = 1+.new_string[0];
			    string[1] = %C'-';
			    ch$move(.new_string[0],new_string[1],string[2]);
			    dbg$rel_memory(.new_string);
			    END;
    dbg$rel_memory(.power_of_two);
    .string
    end; ! of dbg$decimal_valtostg_cvt

! THE REGISTER_TABLE HOLDS ONE ENTRY PER REGISTER. EACH ENTRY IS MADE
! UP OF ONE LONGWORD. THE FIRST BYTE HOLDS THE CHARACTER COUNT OF
! THE REGISTER NAME. THE SECOND THROUGH FOURTH BYTES HOLD THE REGISTER
! NAME STRING. A SAMPLE ENTRY FOLLOWS:
!
!	----------------------------------------------------
!	!            !      0     !      R     !     2     !
!	!--------------------------------------------------!
!--

MACRO
	register_entry (string) =
		%CHARCOUNT (STRING), %ASCII STRING, REP 3 - %CHARCOUNT (STRING) OF BYTE (0)%;

BIND
	register_table = UPLIT BYTE (

		register_entry ('R0'),
		register_entry ('R1'),
		register_entry ('R2'),
		register_entry ('R3'),
		register_entry ('R4'),
		register_entry ('R5'),
		register_entry ('R6'),
		register_entry ('R7'),
		register_entry ('R8'),
		register_entry ('R9'),
		register_entry ('R10'),
		register_entry ('R11'),
		register_entry ('AP'),
		register_entry ('FP'),
		register_entry ('SP'),
		register_entry ('PC'),
		register_entry ('PSL')):

	BLOCK [, LONG];

!++
! THESE FIELD DEFINITIONS CONTROL ACCESS TO THE REGISTER TABLE
!--
MACRO
	REG_NAME	=8, 24, 0%,
	ctd_reg_name	=0, 24, 0%,
	REG_CH_CNT	=0, 8, 0%;

!++
! COMMON ASCII COUNTED STRINGS USED IN FAO CALLS.
!--

BIND
	cs_ascii	= UPLIT ( %ASCIC '!AD'),
	colon_tab_stg	= UPLIT ( %ASCIC ':  ');

!++
! The following macros translate addresses to register offsets and
! vice versa.
!--
	MACRO
		this_is_reg (location) =
			(((location) GEQA dbg$runframe [dbg$l_user_r0]) AND
				((location) LEQA dbg$runframe [dbg$l_user_psl]))%,

		reg_offset (location) =
			(location - dbg$runframe [dbg$l_user_regs]) / %UPVAL%;

GLOBAL ROUTINE dbg$out_regname( address ) =
!++
! Functional Description
!
!	Given an address, see if it falls within the current
!  runframe in such a way as one could say that this address
!  corresponds to one of the general registers.  If this is
!  not the case, we return FALSE.  Otherwise we output the
!  name of the indicated register and return TRUE.
!
! Formal Parameters:
!
!	address	-the address which we are trying to symbolize
! Implicit Inputs:
!
!	The format and use of the register table
!  which is local to this module.
!
! Return Value
!	TRUE or FALSE.  See above.
!
! Side Effects:
!
!	We may output a register name to the output buffer.
!
!--
BEGIN
	BIND
		register_vector = dbg$runframe [ DBG$L_USER_REGS ] : VECTOR;
	LOCAL
		reg_index;

	IF( NOT this_is_reg(.address) )
	then
		return(false);

	reg_index = reg_offset(.address);

	! Check that the address EXACTLY matches one which
	! we currently bind to a register name.

	IF( register_vector[.reg_index] NEQA .address )
	then
		return(FALSE);

	! An exact match has been found.
	! Output the register name and return
	! a success status.

	dbg$print( UPLIT( %ASCIC '!AC' ),
		register_table[.reg_index, ctd_reg_name ]);

	return(TRUE);
END;

GLOBAL ROUTINE dbg$reg_match (string_desc) =
!++
! Functional description:
!	Compares a string described by the string descriptor passed
!	as the routine formal to each of the names of the machine
!	registers. If the string matches a register name, return the
!	number of the register (0-16, where 16 is the PSL). Otherwise,
!	return a -1.
!
! Inputs:
!	string_desc	- string descriptor to symbol string
!
! Implicit inputs:
!	the VAX machine register table
!
! Implicit outputs:
!	none
!
! Routine value:
!	The register number 0 - 16 if a match is found.
!	-1 if no match is found.
!
! Side effects:
!	none
!--

	BEGIN

	MAP
		string_desc : REF BLOCK [, BYTE];



	INCR index from 0 to register_count-1 DO
	    BEGIN
	    IF ch$eql (.string_desc[dsc$w_length], ch$ptr(.string_desc [dsc$a_pointer]),
			.register_table[.index, reg_ch_cnt],
			ch$ptr(register_table[.index, reg_name]))
	    THEN
		RETURN .index;
	    END;

	RETURN (-1);

	END;

GLOBAL ROUTINE dbg$output_psl (value) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Formats and outputs two lines of specially
!	formatted data contained in the PSL. The fields shown are
!
!		CMP	- compatibility mode
!		TP	- trace trap pending
!		FPD	- first part done
!		IS	- interrupt stack
!		CURMOD	- current access mode
!		PRVMOD	- previous access mode
!		IPL	- interrupt priority level
!		DV	- decimal overflow trap enable
!		FU	- floating underflow trap enable
!		IV	- integer overflow trap enable
!		T	- trace trap
!		N	- condition code
!		Z	- condition code
!		V	- condition code
!		C	- condition code
!
! CALLING SEQUENCE:
!	dbg$output_psl ()
!
! INPUTS:
!	value	-The current contents of the PSL
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE value:
!	NOVALUE
!
! SIDE EFFECTS:
!	Two lines are output to the output device.
!--

BEGIN
	MAP
		value: BLOCK;
	MACRO
		position_field	= 0, 8, 1%,
		size_field	= 8, 8, 1%,
		mode_field	= 16, 4, 1%,
		blanks_field	= 20, 4, 1%,
		width_field	= 24, 8, 1%,

		psl_field (name, position, size, mode, width, leading_blanks) =
			position, size, mode OR (leading_blanks ^ 4), width%;

	LITERAL
		decimal		= 0,
		max_psl_field	= 15;

	BIND
		psl_table = UPLIT BYTE (

		psl_field (CMP, 31, 1, 0, 1, 1),
		psl_field (TP, 30, 1, 0, 1, 3),
		psl_field (FPD, 27, 1, 0, 1, 2),
		psl_field (IS, 26, 1, 0, 1, 3),
		psl_field (CURMOD, 24, 2, 1, 4, 2),
		psl_field (PRVMOD, 22, 2, 1, 4, 3),
		psl_field (IPL, 16, 5, 0, 2, 3),
		psl_field (DV, 7, 1, 0, 1, 2),
		psl_field (FU, 6, 1, 0, 1, 2),
		psl_field (IV, 5, 1, 0, 1, 2),
		psl_field (T, 4, 1, 0, 1, 1),
		psl_field (N, 3, 1, 0, 1, 1),
		psl_field (Z, 2, 1, 0, 1, 1),
		psl_field (V, 1, 1, 0, 1, 1),
		psl_field (C, 0, 1, 0, 1, 1))

		: BLOCK,

		hex_number	= UPLIT BYTE (%ASCIC '!AD!#XB'),
		stg_desc	= UPLIT BYTE (%ASCIC '!AD!AD'),
		blanks		= UPLIT BYTE (%ASCII '    '),

		priv_modes	= UPLIT BYTE (

		%ASCII 'KERN',
		%ASCII 'EXEC',
		%ASCII 'SUPR',
		%ASCII 'USER')

		: VECTOR;

	! Write out the standard title which describes the PSL fields.

	dbg$print( UPLIT (%ASCIC '!_CMP TP FPD IS CURMOD PRVMOD IPL DV FU IV T N Z V C'));
	dbg$newline();
	dbg$print (UPLIT (%ASCIC '!_'));
	INCR count FROM 0 TO max_psl_field - 1 DO
		IF .psl_table [.count, mode_field] EQL decimal
		THEN
			BEGIN
			dbg$print (hex_number,
				.psl_table [.count, blanks_field], blanks,
				.psl_table [.count, width_field],
				.value [0, .psl_table [.count, position_field],
				.psl_table [.count, size_field], 0]);
			END
		ELSE
			BEGIN
			dbg$print (stg_desc,
				.psl_table [.count, blanks_field], blanks,
				.psl_table [.count, width_field],
				priv_modes [.value [0, .psl_table [.count, position_field],
					.psl_table [.count, size_field], 0]]);
			END;
END;

GLOBAL ROUTINE dbg$digit_scan(a,l,nd)=
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine will scan the string pointed to by 'a' with
!	length 'l' to determine if it is a valid digit string.
!	it will also build a new descriptor for the input
!
! INPUTS:
!
!	a - address of string
!	l - length of string
!	nd - pointer to new descriptor
!
! IMPLICIT INPUTS:
!
! OUTPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!	1 - a valid digit string
!	3 - a valid digit string beginning with a sign   + or -
!	0 - not a valid digit string
!
! SIDE EFFECTS:
!
!--
BEGIN
builtin cvtsp,cvtpl;
MAP  a : ref vector[,byte],nd : ref block[,byte];
LOCAL s,i,dp,dpp,ep,esn,p : vector [40,byte],ln,f,nwl;
BIND max_packed_size = uplit(31);

! Quick fix for a problem: this routine was returning "true" on the 
! string "e".
!
IF .L EQL 1 AND (.A[0] EQL 'E' OR .A[0] EQL 'e')
THEN
    RETURN 0;

    i = 0 ;
    s = 1 ;
    f = dp=ep=dpp=esn=0;
!
! get possible trailing spaces
    nwl = .l ;
    WHILE .a[.nwl-1] EQL %c' '
    DO
	if (nwl = .nwl-1) leq 0 then return 0;
! skip over possible leading spaces
    WHILE .a[.i] eql %c' '
	DO
	BEGIN
	INCR c from 0 to .nwl-1
	    DO
		a[.c] = .a[.c+1];
	if (nwl = .nwl-1) leq 0 then return 0;
	END;

    nd[dsc$w_length] = .nd[dsc$w_length] - (.l-.nwl);

    IF .a[.i] eql %C'+' OR .a[.i] eql %C'-'
    THEN
	BEGIN
	s = 3 ;
	i = .i + 1 ;
	nd[dsc$b_dtype] = dsc$k_dtype_nl ;
	END
    ELSE
	nd[dsc$b_dtype] = dsc$k_dtype_nro ;

    INCR c from .i to .nwl-1 
    DO
	BEGIN
	if .a[.c] eql %c'.'
	then
	    if .dp
	    then 
		return 0
	    else
		begin
		dp = 1;
		dpp = .c;
		end
	else
	    if .a[.c] eql %c'd' or .a[.c] eql %c'D' or 
		.a[.c] eql %c'e' or .a[.c] eql %c'E'
	    then
		if .ep neq 0
		then
		    return 0
		else
		    ep = .c
	    else
		if .a[.c] eql %c'+' or .a[.c] eql %c'-'
		then
		    if .esn neq 0 or .ep eql 0
		    then
			return 0
		    else
			esn =(if .a[.c] eql %c'+' then 1 else -1)
		else
		    if not (.a[.c] geq %c'0' and .a[.c] leq %c'9')
		    then
			return 0
	END;

! now construct scale factor for desc and redo the length


    if .ep neq 0
    then
	begin
	i =.nwl-.ep-1;
	if .esn eql 0
	then
	    begin
	    a[.ep] = %c'+';
	    cvtsp(i,a[.ep],max_packed_size,p[0]);
	    end
	else
	    begin
	    i = .i -1 ;
	    cvtsp(i,a[.ep+1],max_packed_size,p[0]);
	    end;
	cvtpl(max_packed_size,p[0],ln);
	nd[dsc$b_scale] = .ln ;
	nd[dsc$w_length] = .ep ;
	nwl = .ep ;
	end;


    if .dp eql 0
    then
	0
    else
	begin
	ln = (.nwl-.dpp-1);
	nd[dsc$b_scale] = .nd[dsc$b_scale] - .ln ;
	nd[dsc$w_length] = .nd[dsc$w_length] - 1 ;
	ch$move(.ln,a[.dpp+1],p[0]);
	ch$move(.ln,p[0],a[.dpp]);
	end;
    if .nd[dsc$b_dtype] eql dsc$k_dtype_nl
    then
	nd[dsc$w_length] = .nd[dsc$w_length] - 1;


    return .s 				! catch all return
END;		! End of digit_scan


GLOBAL ROUTINE DBG$MAP_TO_REG_ADDR (INPUT_ADDR, OUTPUT_ADDR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine examines the input address to see if it corresponds to some
!	address in the dbg$reg_values register save area maintained by the
!	routines dbg$sta_setcontext and dbg$sta_setregisters routines. If the
!	address represents some address in the register value save area, then
!	the address is mapped to the corresponding address in the dbg$l_user_regs
!	register save area.
!
! FORMAL PARAMETERS:
!
!	INPUT_ADDR	- A longword containing the address on which to attempt 
!			  the mapping
!
!	OUTPUT_ADDR	- The address of a longword to contain the resulting mapped
!			  address
!
! IMPLICIT INPUTS:
!
!	The address of the register context save area, dbg$reg_values, and the
!	address of the user runframe register save area, dbg$runframe [dbg$l_user_regs].
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Input address mapped, and mapped address
!				  returned.
!
!	STS$K_SEVERE	(4)	- Failure. No mapping.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	RUNFRAME_ADDRS_VECT	: REF VECTOR [,BYTE]; ! Runframe regs area

    runframe_addrs_vect = dbg$runframe [dbg$l_user_regs];

    ! Check to see if the input address falls in the register context save area.

    IF .input_addr GEQA dbg$reg_values [0]
			AND
       .input_addr LSSA dbg$reg_values [17] ! The register vector has only 17 longwords
    THEN
	BEGIN

	! Input_addr definitely coresponds to some address in the context area.
        ! Map it to the user runframe.

	.output_addr = runframe_addrs_vect [.input_addr - dbg$reg_values [0]];

	RETURN sts$k_success;
	END
    ELSE
	BEGIN

	! No match

	RETURN sts$k_severe;
	END;
    END;		! End of dbg$map_to_reg_addr


GLOBAL ROUTINE DBG$EXACT_MAP_TO_REG (INPUT_ADDR, REG_ADDR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks to see if the input address can be mapped to the
!	exact starting address of one of the context register value save areas.
!	If it can, then the address is mapped to the starting address of the
!	corresponding runframe registers.
!
! FORMAL PARAMETERS:
!
!	INPUT_ADDR	- A longword containing the address to be mapped
!
!	REG_ADDR	- The address of a longword to contain the address of
!			  the mapped-to register
!
! IMPLICIT INPUTS:
!
!	dbg$runframe [dbg$l_user_regs] - the beginning address of the runframe
!					    registers
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Input address mapped to register address.
!
!	STS$K_SEVERE	(4)	- Failure. Input address not mapped.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	RUNFRAME_ADDRESS;				! Address within runframe
							! area

    ! See if the input address maps to any place in the runframe regs

    IF dbg$map_to_reg_addr (.input_addr, runframe_address)
    THEN
	BEGIN

	! See if the resulting mapped address corresponds exactly to a reg
	! beginning address

	IF ((.runframe_address - dbg$runframe [dbg$l_user_regs]) MOD 4) EQL 0
	THEN
	    BEGIN

	    ! Exact match to runframe reg

	    .reg_addr = .runframe_address;
	    RETURN sts$k_success;
	    END;
	END;

    ! No match

    RETURN sts$k_severe;

    END;		! End of dbg$exact_map_to_reg

! MACROS:
!
!
! The keyword_table is made of four-tuple entries,
! 1) the language index (0 - n),
! 2) the number of characters in the minimal abbreviation,
! 3) the number of characters in the language name,
! 4) the language name as an ASCII string.
!
! Macro KEY_NAME formats table entries for the language name table.
! Each entry has three formals:
! 1) the ASCII string representing a language name,
! 2) the length of that ASCII string abbreviated,
! 3) the  language index for that language
!
MACRO
    KEY_NAME (KNAME, KABBREV, KEQUIV) =
			KEQUIV, KABBREV, %CHARCOUNT (KNAME), %ASCII KNAME%;

BIND
    LANGUAGE_TABLE = UPLIT BYTE(

	KEY_NAME ('MACRO',	2, DBG$K_MACRO),
	KEY_NAME ('FORTRAN',	2, DBG$K_FORTRAN),
	KEY_NAME ('BLISS',	2, DBG$K_BLISS),
	KEY_NAME ('COBOL',	2, DBG$K_COBOL),
	KEY_NAME ('BASIC',	2, DBG$K_BASIC),
	KEY_NAME ('PLI',	2, DBG$K_PLI),
	KEY_NAME ('PASCAL',	2, DBG$K_PASCAL),
	KEY_NAME ('C',		1, DBG$K_C),
	KEY_NAME ('RPG',	2, DBG$K_RPG),
	KEY_NAME ('ADA',	2, DBG$K_ADA),
	KEY_NAME ('UNKNOWN',	3, DBG$K_UNKNOWN),

	0	) : VECTOR [, BYTE];

GLOBAL ROUTINE DBG$SET_LANG (LANG_STR_DESC, LANGUAGE_MODULE) =
!
! FUNCTION
!	This routine loads the pointers to the current parsing tables
!	with those of the new language.  
!
! INPUTS
!	LANG_STR_DESC	- no longer used (always 0). Eventually, this
!			  parameter should be eliminated (requires 
!			  changing the 4 places this routine is called.)
!	LANGUAGE_MODULE	- If "lang_str_desc" is zero this parameter holds the
!			  language number as defined in DBGLIB.REQ.
!
! OUTPUTS
!	The language index of the language to which DEBUG will be set is
!			  returned as the routine value.
!

    BEGIN
    LOCAL
    	DEF_RADIX;

    ! Change language setting
    !
    DBG$GB_LANGUAGE = .LANGUAGE_MODULE;
    DBG$PARSER_SET_LANGUAGE (.DBG$GB_LANGUAGE);
    DBG$NCHANGE_TO_NEW ();
    DBG$SET_MOD_DEF ();
    DBG$SET_STP_DEF ();
    DBG$SET_SEARCH_DEF ();

    ! Set up the default radix settings for this language.
    !
    def_radix = dbg$nget_trans_radix(dbg$k_default);
    dbg$gb_radix[dbg$b_radix_input] = .def_radix;
    dbg$gb_radix[dbg$b_radix_output] = .def_radix;
    dbg$gb_radix[dbg$b_radix_output_over] = dbg$k_default;

    RETURN .LANGUAGE_MODULE;
    END;

GLOBAL ROUTINE DBG$LANGUAGE (LANG_ENCODING) =
!
! FUNCTION
!	Return a pointer to a counted string which is
!	the name of the given language.
!	This function exists simply to consolidate this nameing
!	translation into one place.
!
! INPUTS
!	LANG_ENCODING	- The numeric encoding used internally to
!			  represent the language.  This is the same
!			  value that comes in the DST MODULE records for
!			  each language, and it is the same value that we
!			  store in DBG$GL_LANGUAGE.
!
! OUTPUTS
!	A pointer to a counted string which names the indicated language
!			  is returned as the routine value.
!

    BEGIN


    ! Just return the desired pointer.
    !
    CASE .LANG_ENCODING FROM DBG$K_MACRO TO DBG$K_UNKNOWN OF
	SET

	[DBG$K_MACRO]:
	    RETURN UPLIT BYTE(%ASCIC 'MACRO');

	[DBG$K_FORTRAN]:
	    RETURN UPLIT BYTE(%ASCIC 'FORTRAN');

	[DBG$K_BLISS]:
	    RETURN UPLIT BYTE(%ASCIC 'BLISS');

	[DBG$K_COBOL]:
	    RETURN UPLIT BYTE(%ASCIC 'COBOL');

	[DBG$K_BASIC]:
	    RETURN UPLIT BYTE(%ASCIC 'BASIC');

	[DBG$K_PLI]:
	    RETURN UPLIT BYTE(%ASCIC 'PLI');

	[DBG$K_PASCAL]:
	    RETURN UPLIT BYTE(%ASCIC 'PASCAL');

	[DBG$K_C]:
	    RETURN UPLIT BYTE(%ASCIC 'C');

	[DBG$K_RPG]:
	    RETURN UPLIT BYTE(%ASCIC 'RPG');

	[DBG$K_ADA]:
	    RETURN UPLIT BYTE(%ASCIC 'ADA');

	[INRANGE, OUTRANGE]:
	    RETURN UPLIT BYTE(%ASCIC 'UNKNOWN');

	TES;

    END;

BIND
	deficf_name	= UPLIT BYTE(%ASCII 'DEBUG.COM'),
	deficf_size	= %CHARCOUNT(%ASCII 'DEBUG.COM');
MACRO
	icf_message (prefix) =
	
	BEGIN
	BIND
		enter_phrase = UPLIT BYTE(8, %ASCII 'entering'),
		exit_phrase  = UPLIT BYTE(7, %ASCII 'exiting');

	LOCAL
		phrase;
	
	IF prefix EQL 1
	THEN
		phrase = enter_phrase
	ELSE
		phrase = exit_phrase;


	SIGNAL (dbg$_verifyicf, 3, .phrase, .fab_ptr[fab$b_fns], .fab_ptr[fab$l_fna]);	! Info message
    
	END % ;

GLOBAL ROUTINE DBG$CIS_CONNECTICF (SIGNAL_FLAG) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!	SIGNAL_FLAG	- TRUE if called from normal command procesing and
!			  we should signal warning message on failure.
!			  FALSE if called from setting up DEBUG initialization
!			  file. In this case just signal informational.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
     BEGIN

	LOCAL
    		dummy_mess_vect,
		status,				! Return status
		fab_ptr : REF $FAB_DECL,	! ptr to allocated FAB storage
		rab_ptr : REF $RAB_DECL,	! ptr to allocated RAB storage
		ind_com_filesp : REF VECTOR [,BYTE];	! Filespec counted string

	ind_com_filesp = .dbg$gl_ind_com_file;

	! Allocate FAB and RAB storage

	fab_ptr = dbg$get_memory ((fab$c_bln + 3)/ %UPVAL);
	rab_ptr = dbg$get_memory ((rab$c_bln + 3)/ %UPVAL);

	! Initialize the FAB and the RAB

	$FAB_INIT (FAB=.fab_ptr, FAC=GET, FNA=.ind_com_filesp + 1, FNS=.ind_com_filesp[0],
		   DNA=deficf_name, DNS=deficf_size);
	$RAB_INIT (RAB=.rab_ptr, FAB=.fab_ptr);

	! Put them on the command input stream

	dbg$cis_add (.rab_ptr, 0, cis_rab, 0, 0);

    	! Set up the local define list for the command procedure.
    	!
    	IF NOT dbg$def_pr_entry (dummy_mess_vect)
    	THEN

    	    ! Signal the error.
    	    !
    	    BEGIN
    	    EXTERNAL ROUTINE
    		lib$signal: ADDRESSING_MODE(GENERAL);
    	    BUILTIN
    	 	CALLG;
    	    CALLG (.dummy_mess_vect, lib$signal);
    	    END;

	! Open and connect the file
    	!
	status = $OPEN (FAB=.fab_ptr);
	IF NOT .status
	THEN
		BEGIN
		

		LOCAL
			msg_desc : BLOCK [8,BYTE];

		msg_desc[dsc$w_length]  = .fab_ptr[fab$b_fns];
		msg_desc[dsc$a_pointer] = .fab_ptr[fab$l_fna];


		! Flag link for removal so we won't try to read from it again

		dbg$gl_cishead[cis$v_rem_flag] = 1;

    		IF .signal_flag
    		THEN
		    SIGNAL (shr$_openin + dbg_fac_code, 1, msg_desc, 
			.fab_ptr[fab$l_sts], .fab_ptr[fab$l_stv])
    		ELSE
    		    BEGIN
    		    SIGNAL (dbg$_unaopnini, 1, msg_desc,
			.fab_ptr[fab$l_sts], .fab_ptr[fab$l_stv]);
    		    RETURN;
    		    END;
		END;

	! Connect the RAB to the just opened FAB

	status = $CONNECT (RAB=.rab_ptr);
	IF NOT .status
	THEN
		BEGIN
		LOCAL
			msg_desc : BLOCK [8,BYTE];

		msg_desc[dsc$w_length]  = .fab_ptr[fab$b_fns];
		msg_desc[dsc$a_pointer] = .fab_ptr[fab$l_fna];


		! Flag link for removal so we won't try to read from it again

		dbg$gl_cishead[cis$v_rem_flag] = 1;

    		IF .signal_flag
    		THEN
		    SIGNAL (shr$_openin + dbg_fac_code, 1, msg_desc, 
			.fab_ptr[fab$l_sts], .fab_ptr[fab$l_stv])
    		ELSE
    		    SIGNAL (dbg$_unaopnini, 1, msg_desc,
			.fab_ptr[fab$l_sts], .fab_ptr[fab$l_stv]);


		END;

	IF .dbg$gb_def_out [out_verify]
	THEN
		icf_message(1);

	RETURN;

END;		! End of dbg$cis_connecticf

GLOBAL ROUTINE dbg$cis_remove (exit_flag) : NOVALUE =
!++
! FUNCTIONAL DECSRIPTION:
!	Removes the top link from the command input stream and delete the 
!	storage for it. If the link has additional dynamic storage related to
!	it, such as a FAB,RAB, input buffer etc., that storage is freed also.
!	Note - this routine now just calls the routine DBG$NCIS_REMOVE in
!	the module DBGNEXCTE.
!
! FORMAL PARAMETERS:
!
!	exit_flag -	TRUE if called from EXIT command.
!
! IMPLICIT INPUTS:
!	The head of the command input stream
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	None
!
! SIDE EFFECTS:
!	The head of the command input stream is reset to what was the
!	"next" link before this routine was called. If SET OUTPUT VERIFY,
!	then a message is generated saying we are exiting the indirect
!	command file.
!--

    BEGIN

    LOCAL 
    	message_vect;		! Dummy message argument vector.

    ! Call the 'new debugger' routine. This returns a condition code
    ! of 'severe', together with an error message vector, if something
    ! goes wrong.
    !
    IF NOT dbg$ncis_remove (.exit_flag, message_vect)
    THEN
   	BEGIN
    	! Set up to signal error.
    	!
    	EXTERNAL ROUTINE
    	    lib$signal : ADDRESSING_MODE (GENERAL);
    	BUILTIN
    	    callg;
    	callg (.message_vect, lib$signal);
    	END;
    END;

GLOBAL ROUTINE dbg$cis_add (pointer, length, type, 
    			    repeat_count, while_clause): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Adds a link to the command input stream
!	Note - this routine now just calls the routine DBG$NCIS_ADD in
!	the module DBGNEXCTE.
!
! FORMAL PARAMETERS:
! 	pointer	-	The address of either a buffer or a RAB to be placed
!			in the dsc$a_pointer field of the new link.
!	length	-	The length of the above buffer. (0 for RAB)
!	type	-	The type of the link to be added
!	repeat_count - 	For a link of type "doloop" [Created during processing
!			of REPEAT N TIMES ( ... ) command], this represents the
!			number of remaining iterations.
!	while_clause -	For a link of type "while", this points to a counted
!			ascii string with the while clause. 
!
! IMPLICIT INPUTS:
!	The head of the command input stream
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	None
!
! SIDE EFFECTS:
!	None
!--

    BEGIN
    LOCAL
    	message_vect;	! Holds message argument vector.	    

    ! DBG$NCIS_ADD will return 'success' (1) if all goes well.
    !
    IF NOT dbg$ncis_add (.pointer, .length, .type, 
    			 .repeat_count, .while_clause, 0,
    		 	  message_vect)
    THEN
    	BEGIN
    	! Set up to signal error.
    	!
    	EXTERNAL ROUTINE
    	    lib$signal : ADDRESSING_MODE (GENERAL);
    	BUILTIN
    	    callg;
    	callg (.message_vect, lib$signal);
    	END;
    END;    	

MACRO
	IF_SIGNAL (code)  =
	    IF .signal_flag NEQ 0
	    THEN
		BEGIN
		    IF NOT
		    	( IF %LENGTH GTR 1
			  THEN dbg$nout_info (code, %REMAINING)
			  ELSE dbg$nout_info (code))
		    THEN
			BEGIN
			    .signal_flag = (IF %LENGTH GTR 1
					    THEN
						dbg$nmake_arg_vect (code, %REMAINING)
					    ELSE
						dbg$nmake_arg_vect (code));
			    RETURN sts$k_severe;
			END
		END
	    ELSE
		BEGIN
		    IF %LENGTH GTR 1
		    THEN
			SIGNAL (code, %REMAINING)
		    ELSE
			SIGNAL (code)
		END %;

MACRO
	SET_FLAG (param_num) =
	    LOCAL
		signal_flag;

	    signal_flag = (IF actualcount () GTR param_num
			   THEN
				actualparameter (actualcount())
			   ELSE
				0) %;

END
ELUDOM
