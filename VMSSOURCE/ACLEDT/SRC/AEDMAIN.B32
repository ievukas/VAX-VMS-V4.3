MODULE AED$MAIN (
		 LANGUAGE (BLISS32),
		 IDENT = 'V04-000'
		 ) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	Miscellaneous utilities
!
! ABSTRACT:
!
!	This module contains the routines for processing the user's input and
!	updating the object's ACL in the appropriate manner.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, user mode utilities.
!
!--
!
!
! AUTHOR:	L. Mark Pilant		CREATION DATE:	12-Nov-1982  9:50
!
! MODIFIED BY:
!
!	V03-016	LMP0291		L. Mark Pilant,		31-Jul-1984  13:15
!		Correct a bug that caused the editor to loop forever in the
!		ACE after the one being deleted was more than one line.
!
!	V03-015	LMP0268		L. Mark Pilant,		28-Jun-1984  15:01
!		Don't explicitly save the journal file on a QUIT.
!
!	V03-014	LMP0267		L. Mark Pilant,		28-Jun-1984  12:15
!		Add support for an ADVANCE FIELD key.
!
!	V03-013	LMP0250		L. Mark Pilant,		4-May-1984  15:42
!		Fix a bug introduced by LMP0238 that caused the wrong item
!		code to be used when updating ACLs.
!
!	V03-012	LMP0238		L. Mark Pilant,		19-Apr-1984  13:32
!		Use the size of the ACE for twiddling, when possible.
!
!	V03-011	LMP0230		L. Mark Pilant,		16-Apr-1984  9:25
!		Track changes made to the $CHANGE_ACL system service.
!
!	V03-010	LMP0213		L. Mark Pilant,		24-Mar-1984  12:23
!		Add support for locking and unlocking the object's ACL.
!
!	V03-009	LMP0193		L. Mark Pilant,		15-Feb-1984  9:59
!		Add support for additional editor actions: delete to EOL,
!		reset, and quit.  Also move the actual ACL updating to the
!		session termination routine.
!
!	V03-008	LMP0172		L. Mark Pilant,		28-Nov-1983  12:11
!		Numerous bug fixes, support for VT2xx terminals, and a
!		session keystroke logger.
!
!	V03-007	LMP0161		L. Mark Pilant,		5-Oct-1983  10:36
!		Make sure that the modified ACE gets written out when
!		crossing ACE boundaries during a search operation.
!
!	V03-006	LMP0147		L. Mark Pilant,		29-Aug-1983  12:46
!		Fix a bug that caused the display to be incorrect when
!		un-deleting an ACE as the last line.  Also fix a bug that
!		caused te display to be wrong when a ^U is given in the
!		middle of a line.
!
!	V03-005	LMP0138		L. Mark Pilant,		16-Aug-1983  13:23
!		Misc fixes to prompting mode input.
!
!	V03-004	LMP0103		L. Mark Pilant,		20-Apr-1983  11:23
!		Add support for HIDDEN ACEs.  Also misc fixes to prompting.
!
!	V03-003	LMP0081		L. Mark Pilant,		16-Feb-1983  10:20
!		Correct some minor bugs with the string searching routines.
!
!	V03-002	LMP0076		L. Mark Pilant,		1-Feb-1983  13:07
!		Add support for a key definition file.
!
!	V03-001	LMP0074		L. Mark Pilant,		21-Jan-1983  16:54
!		Random fixes and support for RMS journaling ACE's.
!
!**

LIBRARY 'SYS$LIBRARY:LIB.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';
REQUIRE 'SRC$:ACLEDTDEF';

FORWARD ROUTINE
	AED_PROCESSACL	: NOVALUE,		! Main processing routine

! The following are routines called based upon the editor action desired.

	ACT_RUB_CHR,
	ACT_RUB_WRD,
	ACT_RUB_BOL,
	ACT_DEL_CHR,
	ACT_DEL_WRD,
	ACT_DEL_EOL,
	ACT_DEL_ACE,
	ACT_UNDEL_CHR,
	ACT_UNDEL_WRD,
	ACT_UNDEL_LIN,
	ACT_UNDEL_ACE,
	ACT_MOVE_WRD,
	ACT_MOVE_ACE,
	ACT_MOVE_BOL,
	ACT_MOVE_EOL,
	ACT_UP,
	ACT_DOWN,
	ACT_RIGHT,
	ACT_LEFT,
	ACT_TOP,
	ACT_BOTTOM,
	ACT_FIND_STR,
	ACT_FIND_NXT,
	ACT_ADV_FIELD,
	ACT_SEL_FIELD,
	ACT_SEL_ITEM,
	ACT_HELP,
	ACT_REFRESH,
	ACT_ENTER,
	ACT_INSERT,
	ACT_EXIT,

! The following are common ACE text manipulating routines.

	FINISH_ACE	: NOVALUE;		! Tie off the ACE

EXTERNAL ROUTINE
	AED_PUTOUTPUT,				! General purpose output routine
	AED_GIVEHELP,				! Interactive help routine
	AED_UPDATEACL,				! Update file's ACL
	AED_SET_CURSOR,				! Set cursor position
	AED_SELECTFIELD	: NOVALUE,		! Select next ACE field
	AED_SELECTITEM	: NOVALUE,		! Select next ACE item
	AED_SETACETYPE	: NOVALUE,		! Set ACE type text
	AED_COMPRESS	: NOVALUE,		! Compress the display
	AED_POSITION	: NOVALUE,		! Position to selected line
	AED_COPSEGMENT,				! Copy segment to working storage
	AED_REPSEGMENT,				! Replace with working storage segment
	AED_SEGSPLIT,				! Split segment into two pieces
	AED_SEGCOMBINE,				! Combine two line segments
	AED_DECODEKEY;				! Key action decoder

! Macros to make working with line segments easier.

MACRO
	BUFFER_CHAR = INPUT_BUFFER[.BUFFER_INDEX] %;

! Storage used by all the routines in this module.

OWN
	BUFFER_INDEX,				! Index into input storage
	ECHO_DESC	: $BBLOCK [DSC$C_S_BLN],	! Text echoing descr
	TEMP_LINE,				! Temp copy of line number
	REMOVED_LINE	: REF $BBLOCK,		! Address of line removed
	REMOVED_ACE	: REF $BBLOCK,		! Address of ACE removed
	NEW_TEXT_LINE	: REF $BBLOCK,		! Address of new line storage
	CHAR_PROCESSED,				! Chars checked by ACL parser
	APPEND_INDEX,				! Index for combining segments
	DUMMY_LINE	: REF $BBLOCK,		! Temp line pointer
	TERM_CHAR	: VECTOR [1,BYTE],	! Character/code input
	SEARCH_SIZE	: VECTOR [1,WORD],	! Search string size
	SEARCH_STRING	: VECTOR [512,BYTE];	! Search string buffer

BIND
	SEGMENT_SIZE	= AED_T_CURLINE[LINE_W_SIZE] : WORD,
						! Input line segment size
	INPUT_BUFFER	= AED_T_CURLINE[LINE_T_TEXT] : VECTOR [,BYTE];
						! Input line segment text

%SBTTL	'AED_PROCESSACL - main processing loop'
GLOBAL ROUTINE AED_PROCESSACL : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the main processing loop for the ACL editor.  It 
!	accepts the users input, which may be a new ACE or modifications
!	to an existing ACE, and updates the in core ACL as appropriate.
!
! CALLING SEQUENCE:
!	AED_PROCESSACL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	AED_W_TERMIN: terminal input channel
!	AED_Q_LINETABLE: input line text queue
!	AED_L_CURACE: address of current ACE
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	AED_L_FIRSTLINE: address of first line segment of ACE
!	AED_L_LASTLINE: address of last line segment of ACE
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	The object's ACL is appropriately modified.
!
!--

BEGIN

LABEL
	INPUT;					! User input loop

LOCAL
	LOCAL_STATUS,				! Local routine exit status
	SPLIT_SEGMENT	: REF $BBLOCK,		! Pointer to remaining text
	SPLIT_SIZE;				! Size of remaining text

! Initialize all variables and flags.

CH$FILL (0, DSC$C_S_BLN, ECHO_DESC);
CH$MOVE (DSC$C_S_BLN, ECHO_DESC, AED_Q_DEL_WORD);
CH$MOVE (DSC$C_S_BLN, ECHO_DESC, AED_Q_DEL_LINE);
AED_B_DEL_CHAR = 0;
BUFFER_INDEX = 0;

! Set up initial display variables.

AED_Q_DEL_ACE[LINE_L_FLINK] = AED_Q_DEL_ACE[LINE_L_FLINK];
AED_Q_DEL_ACE[LINE_L_BLINK] = AED_Q_DEL_ACE[LINE_L_FLINK];

AED_L_FLAGS[AED_V_FIRSTCHAR] = 1;

AED_L_FLAGS[AED_V_ACERROR] = 1;			! Clear message area

! If there is no ACL (the display is empty), set up to append the text
! entered.  Otherwise, set up to modify the first segment of the display.

IF .AED_Q_LINETABLE[LINE_L_FLINK] EQLA AED_Q_LINETABLE[LINE_L_FLINK]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_ENDACL] = 1;		! At the end of the ACL
    AED_L_FLAGS[AED_V_INSERTEXT] = 1;
    AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_Q_LINETABLE[LINE_L_BLINK]);
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
    AED_L_CURACE = 0;
    IF .AED_L_FLAGS[AED_V_PROMPT]
    THEN
	BEGIN
	AED_B_ACETYPE = 0;
	AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	AED_SELECTFIELD (BUFFER_INDEX);
	ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
	ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
	SCR$SET_CURSOR (.AED_B_LINE, 1);
	AED_PUTOUTPUT (ECHO_DESC);
	SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	END;
    END
ELSE
    BEGIN
    AED_COPSEGMENT (.AED_Q_LINETABLE[LINE_L_FLINK]);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], AED_Q_LINETABLE[LINE_L_FLINK]);
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
    UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
    DO
	BEGIN
	IF .AED_L_LASTLINE EQLA AED_T_CURLINE
	THEN AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
	END;
    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
    IF .AED_L_FLAGS[AED_V_PROMPT]
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_NOITEMSEL] = 1;
	AED_SELECTFIELD (BUFFER_INDEX);
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	END;
    END;
AED_L_BEGINLINE = .AED_Q_LINETABLE[LINE_L_FLINK];

! Loop getting characters from the user until an End-Of-File is seen.  When
! an EOF is seen, it indicates the end of the session.

WHILE 1
DO
    INPUT: BEGIN
    TERM_CHAR = AED_DECODEKEY ();
    IF .TERM_CHAR EQL 0 THEN RETURN;
    IF .AED_L_FLAGS[AED_V_ACERROR] AND .AED_L_FLAGS[AED_V_SCOPE]
    THEN
	BEGIN
	SCR$ERASE_PAGE (21, 1);
	AED_SET_CURSOR (.AED_B_LINE, .BUFFER_INDEX + 1);
	AED_L_FLAGS[AED_V_ACERROR] = 0;
	END;

! Choose the appropriate action based upon the character typed.

    WHILE .AED_L_FLAGS[AED_V_ACTIONKEY]
    DO
	BEGIN
	CASE .TERM_CHAR FROM 1 TO KEY_C_MAX_CODE-1 OF
	SET

! Actions to delete text.

	[KEY_C_RUB_CHR]:	ACT_RUB_CHR ();

	[KEY_C_RUB_WRD]:
	    BEGIN
	    LOCAL_STATUS = ACT_RUB_WRD ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_RUB_BOL]:	ACT_RUB_BOL ();

	[KEY_C_DEL_CHR]:	ACT_DEL_CHR ();

	[KEY_C_DEL_WRD]:
	    BEGIN
	    LOCAL_STATUS = ACT_DEL_WRD ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_DEL_EOL]:
	    BEGIN
	    LOCAL_STATUS = ACT_DEL_EOL ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_DEL_ACE]:
	    BEGIN
	    LOCAL_STATUS = ACT_DEL_ACE ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

! Actions to restore deleted text.

	[KEY_C_UNDEL_CHR]:	ACT_UNDEL_CHR ();

	[KEY_C_UNDEL_WRD]:	ACT_UNDEL_WRD ();

	[KEY_C_UNDEL_LIN]:	ACT_UNDEL_LIN ();

	[KEY_C_UNDEL_ACE]:
	    BEGIN
	    LOCAL_STATUS = ACT_UNDEL_ACE ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

! Actions to move through the ACL independant of the direction.

	[KEY_C_UP]:
	    BEGIN
	    LOCAL_STATUS = ACT_UP ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_DOWN]:
	    BEGIN
	    LOCAL_STATUS = ACT_DOWN ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_RIGHT]:	ACT_RIGHT ();

	[KEY_C_LEFT]:	ACT_LEFT ();

	[KEY_C_TOP]:
	    BEGIN
	    LOCAL_STATUS = ACT_TOP ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_BOTTOM]:
	    BEGIN
	    LOCAL_STATUS = ACT_BOTTOM ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

! Set the direction of the move.

	[KEY_C_ADVANCE]:
	    BEGIN
	    AED_L_FLAGS[AED_V_BACKWARD] = 0;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    END;

	[KEY_C_BACKUP]:
	    BEGIN
	    AED_L_FLAGS[AED_V_BACKWARD] = 1;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    END;

! Advance through the ACL based upon the direction chosen.

	[KEY_C_MOVE_WRD]:	ACT_MOVE_WRD ();

	[KEY_C_MOVE_BOL]:	ACT_MOVE_BOL ();

	[KEY_C_MOVE_EOL]:	ACT_MOVE_EOL ();

	[KEY_C_MOVE_ACE]:
	    BEGIN
	    LOCAL_STATUS = ACT_MOVE_ACE ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_FIND_STR]:
	    BEGIN
	    LOCAL_STATUS = ACT_FIND_STR ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_FIND_NXT]:
	    BEGIN
	    LOCAL_STATUS = ACT_FIND_NXT ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

! Advance through an ACE using fields and items.

	[KEY_C_ADV_FIELD]:
	    BEGIN
	    LOCAL_STATUS = ACT_ADV_FIELD ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_SEL_FIELD]:
	    BEGIN
	    LOCAL_STATUS = ACT_SEL_FIELD ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_SEL_ITEM]:
	    BEGIN
	    LOCAL_STATUS = ACT_SEL_ITEM ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

! Miscellaneous editor actions.

	[KEY_C_GOLD]:
	    BEGIN
	    AED_L_FLAGS[AED_V_GOLDKEY] = 1;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    END;

	[KEY_C_HELP]:
	    BEGIN
	    AED_L_FLAGS[AED_V_ACEFORMAT] = 0;
	    ACT_HELP ();
	    END;

	[KEY_C_HELPFMT]:
	    BEGIN
	    AED_L_FLAGS[AED_V_ACEFORMAT] = 1;
	    ACT_HELP ();
	    END;

	[KEY_C_ENTER]:
	    BEGIN
	    LOCAL_STATUS = ACT_ENTER ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_INSERT]:
	    BEGIN
	    LOCAL_STATUS = ACT_INSERT ();
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_REFRESH]:	ACT_REFRESH (0);

	[KEY_C_RESET]:		ACT_REFRESH (1);

	[KEY_C_EXIT]:
	    BEGIN
	    LOCAL_STATUS = ACT_EXIT (0);
	    IF NOT .LOCAL_STATUS THEN RETURN;
	    END;

	[KEY_C_QUIT]:
	    BEGIN
	    ACT_EXIT (1);
	    RETURN;
	    END;

	[KEY_C_OVERSTRIKE]:
	    BEGIN
	    AED_L_FLAGS[AED_V_OVERSTRIKE] = NOT .AED_L_FLAGS[AED_V_OVERSTRIKE];
	    LEAVE INPUT;
	    END;

	[KEY_C_DEBUG]:
	    BEGIN
	    LOCAL	PREV_HANDLER;
	    EXTERNAL ROUTINE	LIB$SIGNAL : ADDRESSING_MODE (GENERAL);

! If the debugger is not present, this is a no-op.

	    $SETEXV (VECTOR = 0, PRVHND = PREV_HANDLER);
	    IF .PREV_HANDLER EQL 0 THEN LEAVE INPUT;
	    $SETEXV (VECTOR = 0, ADDRES = .PREV_HANDLER);

! Enter the debugger.

	    SCR$SET_CURSOR (21, 1);
	    LIB$SIGNAL (SS$_DEBUG);
	    SCR$SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	    LEAVE INPUT;
	    END;

! End of the ACTIONKEY case statement.

	[INRANGE,OUTRANGE]:	LEAVE INPUT;

	TES;
	END;

! See if it is necessary to continue.

    IF .TERM_CHAR EQL 0 THEN LEAVE INPUT;

! If the current ACE is marked as untouchable, no modifications are allowed.

    IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
    THEN
	BEGIN
	SIGNAL (AED$_NOMODIFY);
	LEAVE INPUT;
	END;

! Carriage return - terminate current line segment

    IF NOT .AED_L_FLAGS[AED_V_ACTIONKEY]
    THEN SELECTONE .TERM_CHAR OF
    SET
	[%X'0D']:
	    BEGIN

! Tie off the end of the current segment.

	    AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
	    IF .AED_L_FLAGS[AED_V_PROMPT]
	    AND .BUFFER_INDEX GEQ .SEGMENT_SIZE
	    THEN
		BEGIN
		IF .INPUT_BUFFER[.BUFFER_INDEX - 1] NEQ ','
		AND .INPUT_BUFFER[.BUFFER_INDEX - 1] NEQ '='
		AND .INPUT_BUFFER[.BUFFER_INDEX - 1] NEQ ')'
		AND NOT .AED_L_FLAGS[AED_V_OPENUIC]
		AND .AED_B_FIELD LSS 2
		AND .SEGMENT_SIZE GTR 0
		THEN
		    BEGIN
		    BUFFER_CHAR = ',';
		    ECHO_DESC[DSC$W_LENGTH] = 1;
		    ECHO_DESC[DSC$A_POINTER] = BUFFER_CHAR;
		    AED_PUTOUTPUT (ECHO_DESC);
		    AED_B_COLUMN = .AED_B_COLUMN + 1;
		    BUFFER_INDEX = .BUFFER_INDEX + 1;
		    SEGMENT_SIZE = .SEGMENT_SIZE + 1;
		    END;
		END;

! Split the line.

	    NEW_TEXT_LINE = AED_SEGSPLIT (BUFFER_INDEX, 1, 0, 0);

! See if a new prompt string is necessary.

	    IF .AED_L_FLAGS[AED_V_PROMPT]
	    AND NOT .AED_L_FLAGS[AED_V_OPENUIC]
	    AND NOT .AED_L_FLAGS[AED_V_NOITEMSEL]
	    AND .AED_L_LASTLINE EQLA AED_T_CURLINE[LINE_L_FLINK]
	    AND .AED_L_FIRSTLINE[LINE_L_BINACE] EQL 0
	    THEN
		BEGIN
		AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
		AED_SELECTFIELD (BUFFER_INDEX);
		ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
		ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
		SCR$SET_CURSOR (.AED_B_LINE, 1);
		AED_PUTOUTPUT (ECHO_DESC);
		SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
		AED_B_COLUMN = .BUFFER_INDEX + 1;
		END;
	    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	    AED_L_FLAGS[AED_V_INSERTEXT] = 1;
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    LEAVE INPUT;
	    END;

! All other characters

	[OTHERWISE]:
	    BEGIN

! Check for special characters.

	    IF .TERM_CHAR LSS ' ' THEN LEAVE INPUT;	! Ignore control chars
	    AED_L_FLAGS[AED_V_MODIFIED] = 1;
	    AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
	    IF .TERM_CHAR GEQ 'a' AND .TERM_CHAR LEQ 'z'
	    OR .TERM_CHAR GEQ %X'E0' AND .TERM_CHAR LEQ %X'FE'
	    THEN TERM_CHAR = .TERM_CHAR - 32;	! Lower to upper case letters

! Echo the character just typed at the current position or split the line and
! echo the character.

	    IF (.BUFFER_INDEX GEQ .AED_L_PAGEWIDTH)
	    OR (NOT .AED_L_FLAGS[AED_V_OVERSTRIKE]
		AND .SEGMENT_SIZE GEQ .AED_L_PAGEWIDTH)
	    THEN AED_SEGSPLIT (BUFFER_INDEX, 0, 0, 0);

	    ECHO_DESC[DSC$W_LENGTH] = 1;
	    ECHO_DESC[DSC$A_POINTER] = TERM_CHAR;
	    AED_PUTOUTPUT (ECHO_DESC);

! If the character was entered in insert mode, move all of the characters
! over one position.

	    IF .BUFFER_INDEX  LSS .SEGMENT_SIZE
	    AND NOT .AED_L_FLAGS[AED_V_OVERSTRIKE]
	    THEN
		BEGIN
		ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .BUFFER_INDEX;
		ECHO_DESC[DSC$A_POINTER] = BUFFER_CHAR;
		AED_PUTOUTPUT (ECHO_DESC);
		AED_SET_CURSOR (.AED_B_LINE, .BUFFER_INDEX + 2);
		CH$COPY (.ECHO_DESC[DSC$W_LENGTH], BUFFER_CHAR,
			 0,
			 512 - .BUFFER_INDEX - 1, INPUT_BUFFER[.BUFFER_INDEX + 1]);
		END;

	    IF .TERM_CHAR EQL '[' THEN AED_L_FLAGS[AED_V_OPENUIC] = 1;
	    IF .TERM_CHAR EQL ']' THEN AED_L_FLAGS[AED_V_OPENUIC] = 0;

! Now put the entered character into the line buffer.

	    BUFFER_CHAR = .TERM_CHAR;
	    BUFFER_INDEX = .BUFFER_INDEX + 1;
	    AED_B_COLUMN = .BUFFER_INDEX + 1;

! If in insert mode, the segment size has grown by one character.

	    IF NOT .AED_L_FLAGS[AED_V_OVERSTRIKE]
	    OR .BUFFER_INDEX GEQ .SEGMENT_SIZE
	    THEN SEGMENT_SIZE = .SEGMENT_SIZE + 1;
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    END;
    TES;
    END;

RETURN;
END;						! End of routine AED_PROCESSACL

%SBTTL	'ACT_RUB_CHR - rubout a single character'
ROUTINE ACT_RUB_CHR =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes the character immediately preceeding the current
!	cursor position.  The deleted character is placed in storage for
!	later retrieval.
!
! CALLING SEQUENCE:
!	ACT_RUB_CHR ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	PREV_LINE	: REF $BBLOCK,		! Addr of previous segment
	COMBINED_LINE	: REF $BBLOCK;		! Addr of combined segments

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;
AED_L_FLAGS[AED_V_MODIFIED] = 1;
AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;

IF .BUFFER_INDEX GTR 0
THEN
    BEGIN

! Delete the previous character.

    AED_B_DEL_CHAR = .INPUT_BUFFER[.BUFFER_INDEX - 1];
    IF .AED_B_DEL_CHAR EQL '[' THEN AED_L_FLAGS[AED_V_OPENUIC] = 0;
    IF .AED_B_DEL_CHAR EQL ']' THEN AED_L_FLAGS[AED_V_OPENUIC] = 0;
    SCR$SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN - 1);
    IF .BUFFER_INDEX LSS .SEGMENT_SIZE
    THEN
	BEGIN
	ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .BUFFER_INDEX;
	ECHO_DESC[DSC$A_POINTER] = BUFFER_CHAR;
	AED_PUTOUTPUT (ECHO_DESC);
	CH$COPY (.ECHO_DESC[DSC$W_LENGTH], BUFFER_CHAR,
		 0,
		 512 - .BUFFER_INDEX + 1, INPUT_BUFFER[.BUFFER_INDEX - 1]);
	END;
    BUFFER_INDEX = .BUFFER_INDEX - 1;
    AED_B_COLUMN = .BUFFER_INDEX + 1;
    SEGMENT_SIZE = .SEGMENT_SIZE - 1;
    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    END

! Combine the current and previous line segments.

ELSE AED_SEGCOMBINE (BUFFER_INDEX, 0);

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_RUB_CHR

%SBTTL	'ACT_RUB_WRD - rubout previous word'
ROUTINE ACT_RUB_WRD =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes the word (all characters stopping with the first
!	non alphanumeric character) immediately preceeding the current cursor
!	position.  The deleted word is placed in storage for later retrieval.
!
! CALLING SEQUENCE:
!	ACT_RUB_WRD ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	DEL_WORD_BEGIN,				! Beginning offset of word
	DEL_WORD_END;				! End offset of word

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Deallocate anything in the saved word buffer.

IF .AED_Q_DEL_WORD[DSC$W_LENGTH] NEQ 0
THEN DEALLOCATE (.AED_Q_DEL_WORD[DSC$W_LENGTH],
		 AED_Q_DEL_WORD[DSC$A_POINTER]);
AED_Q_DEL_WORD[DSC$W_LENGTH] = 0;

AED_L_FLAGS[AED_V_MODIFIED] = 1;	! ACE has been modified
AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;

IF .BUFFER_INDEX GTR 0
THEN
    BEGIN

! Delete the previous word.

    DEL_WORD_END = .BUFFER_INDEX;
    BUFFER_INDEX = .BUFFER_INDEX - 2;	! Backup over delimiter
    IF .BUFFER_INDEX GEQ 0
    THEN
	BEGIN
	WHILE (.BUFFER_CHAR GEQ 'A' AND .BUFFER_CHAR LEQ 'Z')
	   OR (.BUFFER_CHAR GEQ '0' AND .BUFFER_CHAR LEQ '9')
	DO
	    BEGIN
	    BUFFER_INDEX = .BUFFER_INDEX - 1;
	    IF .BUFFER_INDEX LSS 0 THEN EXITLOOP;
	    END;
	END
    ELSE BUFFER_INDEX = -1;
    BUFFER_INDEX = .BUFFER_INDEX + 1;	! First char of word
    DEL_WORD_BEGIN = .BUFFER_INDEX;
    AED_B_COLUMN = .BUFFER_INDEX + 1;
    AED_Q_DEL_WORD[DSC$W_LENGTH] = .DEL_WORD_END - .DEL_WORD_BEGIN;
    AED_L_STATUS = ALLOCATE (.AED_Q_DEL_WORD[DSC$W_LENGTH],
			     AED_Q_DEL_WORD[DSC$A_POINTER]);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 0;
	END;
    CH$MOVE (.AED_Q_DEL_WORD[DSC$W_LENGTH],
	     INPUT_BUFFER[.DEL_WORD_BEGIN],
	     .AED_Q_DEL_WORD[DSC$A_POINTER]);
    AED_L_FLAGS[AED_V_RUBWORD] = 1;
    ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .DEL_WORD_END;
    ECHO_DESC[DSC$A_POINTER] = INPUT_BUFFER[.DEL_WORD_END];
    IF .ECHO_DESC[DSC$W_LENGTH] GEQ 1
    THEN
	BEGIN
	SCR$SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_PUTOUTPUT (ECHO_DESC);
	END;
    CH$COPY (.ECHO_DESC[DSC$W_LENGTH], INPUT_BUFFER[.DEL_WORD_END],
	     0,
	     512 - .BUFFER_INDEX, INPUT_BUFFER[.DEL_WORD_BEGIN]);
    SEGMENT_SIZE = .SEGMENT_SIZE - .AED_Q_DEL_WORD[DSC$W_LENGTH];
    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    END

! Combine the current and previous line segments.

ELSE AED_SEGCOMBINE (BUFFER_INDEX, 0);

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_RUB_WRD

%SBTTL	'ACT_RUB_BOL - erase to beginning of line'
ROUTINE ACT_RUB_BOL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes all characters between the current cursor
!	position and the beginning of the line segment.  These characters
!	are NOT stored.
!
! CALLING SEQUENCE:
!	ACT_RUB_BOL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! If at the beginning of the line, this is a no-op.

IF .BUFFER_INDEX EQL 0
THEN
    BEGIN
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Deallocate anything in the saved line buffer.

IF .AED_Q_DEL_LINE[DSC$W_LENGTH] NEQ 0
THEN DEALLOCATE (.AED_Q_DEL_LINE[DSC$W_LENGTH], .AED_Q_DEL_LINE[DSC$A_POINTER]);
AED_Q_DEL_LINE[DSC$W_LENGTH] = 0;

! Delete to the beginning of the line.

AED_L_FLAGS[AED_V_DELBOL] = 1;			! Note direction of delete

AED_Q_DEL_LINE[DSC$W_LENGTH] = .BUFFER_INDEX;
AED_L_STATUS = ALLOCATE (.AED_Q_DEL_LINE[DSC$W_LENGTH], AED_Q_DEL_LINE[DSC$A_POINTER]);
IF NOT .AED_L_STATUS
THEN
    BEGIN
    SIGNAL (.AED_L_STATUS);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    RETURN 0;
    END;

! Copy the deleted portion of the line.

CH$MOVE (.AED_Q_DEL_LINE[DSC$W_LENGTH], INPUT_BUFFER[0], .AED_Q_DEL_LINE[DSC$A_POINTER]);
SEGMENT_SIZE = .SEGMENT_SIZE - .BUFFER_INDEX;
CH$COPY (.SEGMENT_SIZE, BUFFER_CHAR, 0, 512, INPUT_BUFFER);
BUFFER_INDEX = 0;

! Echo any remaining portion of the line.

IF .SEGMENT_SIZE GTR 0
THEN
    BEGIN
    ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE;
    ECHO_DESC[DSC$A_POINTER] = BUFFER_CHAR;
    SCR$SET_CURSOR (.AED_B_LINE, 1);
    AED_PUTOUTPUT (ECHO_DESC);
    END;

! Now clear the rest of the line.

SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
AED_SET_CURSOR (.AED_B_LINE, 1);

AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
AED_L_FLAGS[AED_V_MODIFIED] = 1;
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_RUB_BOL

%SBTTL	'ACT_DEL_CHR - delete current character'
ROUTINE ACT_DEL_CHR =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes the character immediately under the current
!	cursor position.  The deleted character is placed in storage for
!	later retrieval.
!
! CALLING SEQUENCE:
!	ACT_DEL_CHR ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Delete the character.

AED_B_DEL_CHAR = 0;

AED_L_FLAGS[AED_V_MODIFIED] = 1;
AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;

IF .SEGMENT_SIZE GTR 0
AND .BUFFER_INDEX LSS .SEGMENT_SIZE
THEN
    BEGIN
    AED_B_DEL_CHAR = .BUFFER_CHAR;
    IF .AED_B_DEL_CHAR EQL ']' THEN AED_L_FLAGS[AED_V_OPENUIC] = 1;
    ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .BUFFER_INDEX - 1;
    ECHO_DESC[DSC$A_POINTER] = INPUT_BUFFER[.BUFFER_INDEX + 1];
    IF .ECHO_DESC[DSC$W_LENGTH] GEQ 1
    THEN AED_PUTOUTPUT (ECHO_DESC);
    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE);
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    CH$COPY (.ECHO_DESC[DSC$W_LENGTH], INPUT_BUFFER[.BUFFER_INDEX + 1],
	     0,
	     512 - .BUFFER_INDEX, INPUT_BUFFER[.BUFFER_INDEX]);
    SEGMENT_SIZE = .SEGMENT_SIZE - 1;
    END
ELSE AED_SEGCOMBINE (BUFFER_INDEX, 1);

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_DEL_CHR

%SBTTL	'ACT_DEL_WRD - delete current word'
ROUTINE ACT_DEL_WRD =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes the word (all characters until the first non
!	alphanumeric character) starting at the current cursor position.
!	The deleted word is placed in storage for later retrieval.
!
! CALLING SEQUENCE:
!	ACT_DEL_WRD ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	DEL_WORD_BEGIN,				! Beginning offset of word
	DEL_WORD_END;				! End offset of word

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Deallocate anything in the saved word buffer.

IF .AED_Q_DEL_WORD[DSC$W_LENGTH] NEQ 0
THEN DEALLOCATE (.AED_Q_DEL_WORD[DSC$W_LENGTH], AED_Q_DEL_WORD[DSC$A_POINTER]);
AED_Q_DEL_WORD[DSC$W_LENGTH] = 0;

AED_L_FLAGS[AED_V_MODIFIED] = 1;
AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;

! Delete the word.

IF .SEGMENT_SIZE GTR 0
AND .BUFFER_INDEX LSS .SEGMENT_SIZE
THEN
    BEGIN
    DEL_WORD_BEGIN = .BUFFER_INDEX;
    WHILE (.BUFFER_CHAR GEQ 'A' AND .BUFFER_CHAR LEQ 'Z')
       OR (.BUFFER_CHAR GEQ '0' AND .BUFFER_CHAR LEQ '9')
    DO
	BEGIN
	BUFFER_INDEX = .BUFFER_INDEX + 1;
	IF .BUFFER_INDEX GEQ .SEGMENT_SIZE
	THEN
	    BEGIN
	    BUFFER_INDEX = .BUFFER_INDEX - 1;
	    EXITLOOP;
	    END;
	END;
    BUFFER_INDEX = .BUFFER_INDEX + 1;	! First char past delimiter
    DEL_WORD_END = .BUFFER_INDEX;
    AED_Q_DEL_WORD[DSC$W_LENGTH] = .DEL_WORD_END - .DEL_WORD_BEGIN;
    AED_L_STATUS = ALLOCATE (.AED_Q_DEL_WORD[DSC$W_LENGTH],
			     AED_Q_DEL_WORD[DSC$A_POINTER]);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	RETURN 0;
	END;
    CH$MOVE (.AED_Q_DEL_WORD[DSC$W_LENGTH],
	     INPUT_BUFFER[.DEL_WORD_BEGIN],
	     .AED_Q_DEL_WORD[DSC$A_POINTER]);
    AED_L_FLAGS[AED_V_RUBWORD] = 0;
    ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .DEL_WORD_END;
    ECHO_DESC[DSC$A_POINTER] = INPUT_BUFFER[.DEL_WORD_END];
    SEGMENT_SIZE = .SEGMENT_SIZE - .AED_Q_DEL_WORD[DSC$W_LENGTH];
    IF .ECHO_DESC[DSC$W_LENGTH] GEQ 1
    THEN
	BEGIN
	SCR$SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_PUTOUTPUT (ECHO_DESC);
	END;
    CH$COPY (.ECHO_DESC[DSC$W_LENGTH], INPUT_BUFFER[.DEL_WORD_END],
	     0,
	     512 - .BUFFER_INDEX, INPUT_BUFFER[.DEL_WORD_BEGIN]);
    BUFFER_INDEX = .DEL_WORD_BEGIN;
    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    END
ELSE AED_SEGCOMBINE (BUFFER_INDEX, 1);

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_DEL_WRD

%SBTTL	'ACT_DEL_EOL - delete to end of line'
ROUTINE ACT_DEL_EOL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes from the current position in the line to the
!	end of the current line segment.
!
! CALLING SEQUENCE:
!	ACT_DEL_EOL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary.
!
!--

BEGIN

! Check to see if the ACE is untouchable.  If so, it cannot be modified.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Delete anything currently in the saved line buffer.

IF .AED_Q_DEL_LINE[DSC$W_LENGTH] NEQ 0
THEN DEALLOCATE (.AED_Q_DEL_LINE[DSC$W_LENGTH], .AED_Q_DEL_LINE[DSC$A_POINTER]);
AED_Q_DEL_LINE[DSC$W_LENGTH] = 0;

! Note that the line has been modified.

AED_L_FLAGS[AED_V_MODIFIED] = 1;
AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;

! Delete to the end of the line.

AED_L_FLAGS[AED_V_DELBOL] = 0;			! Note direction of delete

IF .SEGMENT_SIZE GTR 0
AND .BUFFER_INDEX LSS .SEGMENT_SIZE
THEN
    BEGIN
    AED_L_STATUS = ALLOCATE ((.SEGMENT_SIZE - .BUFFER_INDEX),
			     AED_Q_DEL_LINE[DSC$A_POINTER]);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 0;
	END;
    AED_Q_DEL_LINE[DSC$W_LENGTH] = .SEGMENT_SIZE - .BUFFER_INDEX;
    CH$MOVE (.AED_Q_DEL_LINE[DSC$W_LENGTH], INPUT_BUFFER[.BUFFER_INDEX],
					  .AED_Q_DEL_LINE[DSC$A_POINTER]);
    SEGMENT_SIZE = .BUFFER_INDEX;
    SCR$ERASE_LINE (.AED_B_LINE, .AED_B_COLUMN);
    END
ELSE AED_SEGCOMBINE (BUFFER_INDEX, 1);

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;

%SBTTL	'ACT_DEL_ACE - delete current ACE'
ROUTINE ACT_DEL_ACE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes the current ACE (bounded by the first and last
!	line segment pointers) and stores it for later retrieval.  The ACE
!	is also deleted from the object's ACL is necessary.
!
! CALLING SEQUENCE:
!	ACT_DEL_ACE ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

! Check to see if the ACE is untouchable.  If so, it cannot be deleted.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Delete anything currently in the delete ACE buffer.

UNTIL REMQUE (.AED_Q_DEL_ACE[LINE_L_FLINK], REMOVED_LINE)
DO
    BEGIN
    REMOVED_ACE = .REMOVED_LINE[LINE_L_BINACE];
    IF .REMOVED_LINE[LINE_V_BEGINACE]
    AND .REMOVED_ACE NEQ 0
    THEN DEALLOCATE (.REMOVED_ACE[ACE$B_SIZE], REMOVED_ACE);
    DEALLOCATE (.REMOVED_LINE[LINE_W_SIZE] + $BYTEOFFSET (LINE_T_TEXT),
		REMOVED_LINE);
    END;
NEW_TEXT_LINE = AED_REPSEGMENT ();
AED_POSITION (.AED_L_FIRSTLINE);
AED_L_BEGINLINE = .AED_L_BEGINLINE[LINE_L_BLINK];
TEMP_LINE = .AED_B_LINE - 1;
NEW_TEXT_LINE = .AED_L_FIRSTLINE;
DO
    BEGIN
    AED_L_FIRSTLINE = .AED_L_FIRSTLINE[LINE_L_FLINK];
    REMQUE (NEW_TEXT_LINE[LINE_L_FLINK], REMOVED_LINE);
    IF NOT .REMOVED_LINE[LINE_V_DUMMY]
    THEN INSQUE (REMOVED_LINE[LINE_L_FLINK],
		 .AED_Q_DEL_ACE[LINE_L_BLINK]);
    TEMP_LINE = .TEMP_LINE + 1;
    NEW_TEXT_LINE = .AED_L_FIRSTLINE;
    END
UNTIL .REMOVED_LINE EQL .AED_L_LASTLINE;
AED_L_STATUS = AED_UPDATEACL (0);
AED_L_FLAGS[AED_V_INSERT] = AED_L_FLAGS[AED_V_INSERTEXT] = 0;
AED_L_FLAGS[AED_V_MODIFIED] = 0;
IF NOT .AED_L_STATUS
THEN
    BEGIN
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    RETURN 0;
    END;
IF .AED_L_FIRSTLINE EQLA AED_Q_LINETABLE[LINE_L_FLINK]
THEN
    BEGIN
    BUFFER_INDEX = 0;
    AED_L_FLAGS[AED_V_ENDACL] = 1;
    AED_L_FLAGS[AED_V_INSERTEXT] = 1;
    AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
	    .AED_Q_LINETABLE[LINE_L_BLINK]);
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
    AED_L_CURACE = 0;
    IF .AED_L_FLAGS[AED_V_PROMPT]
    THEN
	BEGIN
	AED_B_ACETYPE = 0;
	AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	AED_SELECTFIELD (BUFFER_INDEX);
	END;
    END
ELSE
    BEGIN
    BUFFER_INDEX = 0;
    AED_COPSEGMENT (.AED_L_FIRSTLINE);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
	    .AED_L_FIRSTLINE[LINE_L_BLINK]);
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
    UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
    DO
	BEGIN
	IF .AED_L_LASTLINE EQLA AED_T_CURLINE
	THEN AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
	END;
    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
    END;
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_L_BEGINLINE = .AED_L_BEGINLINE[LINE_L_FLINK];

! Now repaint the display.  This is done by either scrolling down and repainting
! the first part of the display or repainting from the current position to the
! end of the display (or the end of the ACL).

IF .AED_B_LINE LEQ 10
THEN
    BEGIN
    INCR J FROM 0 TO .TEMP_LINE - .AED_B_LINE
    DO
	BEGIN
	IF .J EQL 0 THEN SCR$SET_CURSOR (20,1);		! **** TEMP ****
	SCR$UP_SCROLL ();
	END;
    NEW_TEXT_LINE = .AED_L_BEGINLINE;
    INCR J FROM 1 TO .AED_B_LINE
    DO
	BEGIN
	ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
	ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
	SCR$SET_CURSOR (.J, 1);
	AED_PUTOUTPUT (ECHO_DESC);
	SCR$ERASE_LINE (.J, .ECHO_DESC[DSC$W_LENGTH] + 1);
	IF .NEW_TEXT_LINE[LINE_V_REPLACE] THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	END;
    END
ELSE
    BEGIN
    IF .AED_L_FLAGS[AED_V_ENDACL]
    THEN NEW_TEXT_LINE = AED_T_CURLINE
    ELSE NEW_TEXT_LINE = .AED_T_CURLINE[LINE_L_FLINK];
    INCR J FROM .AED_B_LINE TO 20
    DO
	BEGIN
	IF .NEW_TEXT_LINE EQLA AED_Q_LINETABLE[LINE_L_FLINK]
	THEN
	    BEGIN
	    IF .J LSS 20 THEN SCR$ERASE_PAGE (.J, 1);
	    EXITLOOP;
	    END;
	ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
	ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
	SCR$SET_CURSOR (.J, 1);
	AED_PUTOUTPUT (ECHO_DESC);
	SCR$ERASE_LINE (.J, .ECHO_DESC[DSC$W_LENGTH] + 1);
	NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	END;
    END;
AED_L_FLAGS[AED_V_FIRSTCHAR] = 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_DEL_ACE

%SBTTL	'ACT_UNDEL_CHR - insert deleted character'
ROUTINE ACT_UNDEL_CHR =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine retrieves the previously deleted character and inserts
!	it into the line segment at the current cursor position.  The
!	cursor position is unchanged.
!
! CALLING SEQUENCE:
!	ACT_UNDEL_CHR ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
IF .AED_B_DEL_CHAR EQL 0
THEN
    BEGIN
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Retrieve the deleted character.

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = .AED_B_DEL_CHAR;
RETURN 1;

END;						! End of routine ACT_UNDEL_CHR

%SBTTL	'ACT_UNDEL_WRD - insert deleted word'
ROUTINE ACT_UNDEL_WRD =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine retrieves the previously deleted word and inserts it
!	into the current line segment starting at the current cursor position.
!	If a delete word was used previously, the cursor position is not
!	changed.  If a rubout word was used, the cursor is moved to the end
!	in the retrieved word.
!
! CALLING SEQUENCE:
!	ACT_UNDEL_WRD ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Retrieve the deleted word.

CH$COPY (.SEGMENT_SIZE - .BUFFER_INDEX,
	 INPUT_BUFFER[.BUFFER_INDEX],
	 0,
	 512 - .BUFFER_INDEX - .AED_Q_DEL_WORD[DSC$W_LENGTH],
	 INPUT_BUFFER[.BUFFER_INDEX +
		      .AED_Q_DEL_WORD[DSC$W_LENGTH]]);
CH$MOVE (.AED_Q_DEL_WORD[DSC$W_LENGTH],
	 .AED_Q_DEL_WORD[DSC$A_POINTER],
	 INPUT_BUFFER[.BUFFER_INDEX]);
SEGMENT_SIZE = .SEGMENT_SIZE + .AED_Q_DEL_WORD[DSC$W_LENGTH];
ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .BUFFER_INDEX;
ECHO_DESC[DSC$A_POINTER] = INPUT_BUFFER[.BUFFER_INDEX];
IF .AED_L_FLAGS[AED_V_RUBWORD]
THEN BUFFER_INDEX = .BUFFER_INDEX + .AED_Q_DEL_WORD[DSC$W_LENGTH];
IF .SEGMENT_SIZE GEQ .AED_L_PAGEWIDTH
THEN AED_SEGSPLIT (BUFFER_INDEX, 0, 1, 0)
ELSE AED_PUTOUTPUT (ECHO_DESC);
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
IF .AED_Q_DEL_WORD[DSC$W_LENGTH] NEQ 0
THEN
    BEGIN
    AED_L_FLAGS[AED_V_MODIFIED] = 1;
    AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_UNDEL_WRD

%SBTTL	'ACT_UNDEL_LIN - insert deleted line'
ROUTINE ACT_UNDEL_LIN =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine retrieves the previously deleted line and inserts it
!	into the current line segment starting at the current cursor position.
!	If a delete line was used previously, the cursor position is not
!	changed.  If a rubout line was used, the cursor is moved to the end
!	in the retrieved line.
!
! CALLING SEQUENCE:
!	ACT_UNDEL_LIN ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

! If the current ACE is marked as untouchable, no modifications are allowed.

IF .AED_L_FIRSTLINE[LINE_V_NOTOUCH]
THEN
    BEGIN
    SIGNAL (AED$_NOMODIFY);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

! Retrieve the deleted line.

CH$COPY (.SEGMENT_SIZE - .BUFFER_INDEX,
	 INPUT_BUFFER[.BUFFER_INDEX],
	 0,
	 512 - .BUFFER_INDEX - .AED_Q_DEL_LINE[DSC$W_LENGTH],
	 INPUT_BUFFER[.BUFFER_INDEX + .AED_Q_DEL_LINE[DSC$W_LENGTH]]);
CH$MOVE (.AED_Q_DEL_LINE[DSC$W_LENGTH],
	 .AED_Q_DEL_LINE[DSC$A_POINTER],
	 INPUT_BUFFER[.BUFFER_INDEX]);
SEGMENT_SIZE = .SEGMENT_SIZE + .AED_Q_DEL_LINE[DSC$W_LENGTH];
ECHO_DESC[DSC$W_LENGTH] = .SEGMENT_SIZE - .BUFFER_INDEX;
ECHO_DESC[DSC$A_POINTER] = INPUT_BUFFER[.BUFFER_INDEX];
IF .AED_L_FLAGS[AED_V_DELBOL]
THEN BUFFER_INDEX = .BUFFER_INDEX + .AED_Q_DEL_LINE[DSC$W_LENGTH];
IF .SEGMENT_SIZE GEQ .AED_L_PAGEWIDTH
THEN AED_SEGSPLIT (BUFFER_INDEX, 0, 1, 0)
ELSE AED_PUTOUTPUT (ECHO_DESC);
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
IF .AED_Q_DEL_LINE[DSC$W_LENGTH] NEQ 0
THEN
    BEGIN
    AED_L_FLAGS[AED_V_MODIFIED] = 1;
    AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_UNDEL_LIN

%SBTTL	'ACT_UNDEL_ACE - insert deleted ACE'
ROUTINE ACT_UNDEL_ACE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine retrieves the previously deleted ACE and inserts it
!	into the ACL before the first line of the current ACE.
!
! CALLING SEQUENCE:
!	ACT_UNDEL_ACE ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	CURRENT_LINE	: REF $BBLOCK;		! Address of current line segment

IF .AED_Q_DEL_ACE[LINE_L_FLINK] EQLA AED_Q_DEL_ACE[LINE_L_FLINK]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;
NEW_TEXT_LINE = AED_REPSEGMENT ();
IF .AED_L_FLAGS[AED_V_MODIFIED]
OR .AED_L_FLAGS[AED_V_INSERT]
OR .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    FINISH_ACE ();
    IF .AED_L_FLAGS[AED_V_PROMPT]
    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
    THEN
	BEGIN
	NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
	AED_W_TOTALSIZE = 0;
	END;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    IF .AED_W_TOTALSIZE EQL 0
    THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    AED_COMPRESS ();
    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ACERROR] = 1;
	AED_POSITION (.AED_L_FIRSTLINE);
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_LASTLINE = AED_T_CURLINE;
	IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE = AED_T_CURLINE;
	IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	AND .AED_L_FLAGS[AED_V_ENDACL]
	THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
    END;
AED_W_TOTALSIZE = 0;
AED_L_LASTLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
AED_L_FIRSTLINE = 0;
REMOVED_LINE = .AED_Q_DEL_ACE[LINE_L_FLINK];
CURRENT_LINE = .AED_Q_DEL_ACE[LINE_L_FLINK];
UNTIL .CURRENT_LINE EQLA AED_Q_DEL_ACE[LINE_L_FLINK]
DO
    BEGIN
    AED_L_STATUS = ALLOCATE (.CURRENT_LINE[LINE_W_SIZE] + $BYTEOFFSET (LINE_T_TEXT),
			     NEW_TEXT_LINE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	RETURN .AED_L_STATUS;
	END;
    CH$MOVE (.CURRENT_LINE[LINE_W_SIZE] + $BYTEOFFSET (LINE_T_TEXT),
	     .CURRENT_LINE, .NEW_TEXT_LINE);
    INSQUE (NEW_TEXT_LINE[LINE_L_FLINK], AED_L_LASTLINE[LINE_L_FLINK]);
    IF .AED_L_FIRSTLINE EQL 0 THEN AED_L_FIRSTLINE = .NEW_TEXT_LINE;
    AED_L_LASTLINE = .NEW_TEXT_LINE;
    AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .NEW_TEXT_LINE[LINE_W_SIZE];
    CURRENT_LINE = .CURRENT_LINE[LINE_L_FLINK];
    END;
IF .AED_W_TOTALSIZE GTR 0 THEN AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
AED_POSITION (.AED_L_FIRSTLINE);
AED_COPSEGMENT (.AED_L_FIRSTLINE);
INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_L_FIRSTLINE[LINE_L_BLINK]);
IF .AED_L_FLAGS[AED_V_ENDACL]
THEN AED_L_CURACE = 0
ELSE AED_L_CURACE = .$BBLOCK [.AED_L_LASTLINE[LINE_L_FLINK], LINE_L_BINACE];
IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE THEN AED_L_BEGINLINE = AED_T_CURLINE;
IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE THEN AED_L_LASTLINE = AED_T_CURLINE;
AED_L_FIRSTLINE = AED_T_CURLINE;
AED_L_FIRSTLINE[LINE_L_BINACE] = 0;
AED_L_FLAGS[AED_V_INSERT] = AED_L_FLAGS[AED_V_MODIFIED] = 1;

! Determine where the last line of the newly added ACE falls.

TEMP_LINE = .AED_B_LINE;
NEW_TEXT_LINE = .AED_L_FIRSTLINE;
UNTIL .NEW_TEXT_LINE EQL .AED_L_LASTLINE
DO
    BEGIN
    TEMP_LINE = .TEMP_LINE + 1;
    IF .NEW_TEXT_LINE[LINE_V_REPLACE] THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    END;

! Now repaint the display.  This is done by either scrolling down and repainting
! the first part of the display or repainting from the current position to the
! end of the display (or the end of the ACL).

IF .AED_B_LINE GTR 1
THEN
    BEGIN
    IF .TEMP_LINE LEQ 10
    THEN
	BEGIN
	INCR J FROM 0 TO .TEMP_LINE - .AED_B_LINE
	DO
	    BEGIN
	    IF .J EQL 0 THEN SCR$SET_CURSOR (1,1);	! **** TEMP ****
	    SCR$DOWN_SCROLL ();
	    END;
	NEW_TEXT_LINE = .AED_L_BEGINLINE;
	INCR J FROM 1 TO .TEMP_LINE
	DO
	    BEGIN
	    ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.J, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.J, .ECHO_DESC[DSC$W_LENGTH] + 1);
	    IF .NEW_TEXT_LINE[LINE_V_REPLACE] THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	    NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	    END;
	END
    ELSE
	BEGIN
	NEW_TEXT_LINE = .AED_T_CURLINE[LINE_L_FLINK];
	INCR J FROM .AED_B_LINE TO 20
	DO
	    BEGIN
	    ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.J, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.J, .ECHO_DESC[DSC$W_LENGTH] + 1);
	    NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	    IF .NEW_TEXT_LINE EQLA AED_Q_LINETABLE[LINE_L_FLINK] THEN EXITLOOP;
	    END;
	END;
    END;
BUFFER_INDEX = 0;
AED_B_COLUMN = 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_UNDEL_ACE

%SBTTL	'ACT_MOVE_WRD - move to word boundary'
ROUTINE ACT_MOVE_WRD =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine goes to the next word boundary (first non-alphanumeric
!	character) in either the forward or backward direction.
!
! CALLING SEQUENCE:
!	ACT_MOVE_WRD ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

IF NOT .AED_L_FLAGS[AED_V_BACKWARD]
THEN
    BEGIN
    IF .BUFFER_INDEX GEQ .SEGMENT_SIZE
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    WHILE (.BUFFER_CHAR GEQ 'A' AND .BUFFER_CHAR LEQ 'Z')
       OR (.BUFFER_CHAR GEQ '0' AND .BUFFER_CHAR LEQ '9')
    DO
	BEGIN
	BUFFER_INDEX = .BUFFER_INDEX + 1;
	IF .BUFFER_INDEX GEQ .SEGMENT_SIZE
	THEN
	    BEGIN
	    BUFFER_INDEX = .BUFFER_INDEX - 1;
	    EXITLOOP;
	    END;
	END;
    END
ELSE
    BEGIN
    BUFFER_INDEX = .BUFFER_INDEX - 2;
    IF .BUFFER_INDEX GEQ 0
    THEN
	BEGIN
	WHILE (.BUFFER_CHAR GEQ 'A' AND .BUFFER_CHAR LEQ 'Z')
	   OR (.BUFFER_CHAR GEQ '0' AND .BUFFER_CHAR LEQ '9')
	DO
	    BEGIN
	    BUFFER_INDEX = .BUFFER_INDEX - 1;
	    IF .BUFFER_INDEX LSS 0 THEN EXITLOOP;
	    END;
	END
    ELSE BUFFER_INDEX = -1;
    END;
BUFFER_INDEX = .BUFFER_INDEX + 1;	! First char of word
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_MOVE_WRD

%SBTTL	'ACT_MOVE_ACE - move to ACE boundary'
ROUTINE ACT_MOVE_ACE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine advances or backs up over an ACE depending on the
!	state of the BACKWARD flag.
!
! CALLING SEQUENCE:
!	ACT_MOVE_ACE ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

NEW_TEXT_LINE = AED_REPSEGMENT ();
IF .AED_L_FLAGS[AED_V_MODIFIED]
OR .AED_L_FLAGS[AED_V_INSERT]
OR .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    FINISH_ACE ();
    IF .AED_L_FLAGS[AED_V_PROMPT]
    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
    THEN
	BEGIN
	NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
	AED_W_TOTALSIZE = 0;
	END;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    IF .AED_W_TOTALSIZE EQL 0 THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    AED_COMPRESS ();
    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ACERROR] = 1;
	AED_POSITION (.AED_L_FIRSTLINE);
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_LASTLINE = AED_T_CURLINE;
	IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE = AED_T_CURLINE;
	IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	AND .AED_L_FLAGS[AED_V_ENDACL]
	THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
    END;

IF NOT .AED_L_FLAGS[AED_V_BACKWARD]
THEN
    BEGIN
    AED_L_FIRSTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
    IF .AED_L_FIRSTLINE EQLA AED_Q_LINETABLE[LINE_L_FLINK]
    THEN AED_L_FLAGS[AED_V_ENDACL] = 1;
    AED_POSITION (.AED_L_FIRSTLINE);

! If at the end of the ACL, set up to append.  Otherwise setup the next line.

    IF .AED_L_FLAGS[AED_V_ENDACL]
    THEN
	BEGIN
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_L_FLAGS[AED_V_INSERTEXT] = 1;
	AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
	AED_L_CURACE = 0;
	IF .AED_L_FLAGS[AED_V_PROMPT]
	THEN
	    BEGIN
	    AED_B_ACETYPE = 0;
	    AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	    AED_SELECTFIELD (BUFFER_INDEX);
	    ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.AED_B_LINE, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
	    AED_B_COLUMN = .BUFFER_INDEX + 1;
	    END;
	END
    ELSE
	BEGIN
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
	UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
	DO
	    BEGIN
	    IF .AED_L_LASTLINE EQLA AED_T_CURLINE
	    THEN AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	    AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	    AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
	    END;
	AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	END;
    END
ELSE
    BEGIN
    AED_L_LASTLINE = AED_L_FIRSTLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
    UNTIL .AED_L_FIRSTLINE[LINE_V_BEGINACE]
    DO
	BEGIN
	IF .AED_L_BEGINLINE EQLA .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
	AED_L_FIRSTLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
	AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_FIRSTLINE[LINE_W_SIZE];
	END;
    AED_POSITION (.AED_L_FIRSTLINE);
    AED_COPSEGMENT (.AED_L_FIRSTLINE);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
	    .AED_L_FIRSTLINE[LINE_L_BLINK]);
    IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE THEN AED_L_BEGINLINE = AED_T_CURLINE;
    IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE THEN AED_L_LASTLINE = AED_T_CURLINE;
    AED_L_FIRSTLINE = AED_T_CURLINE;
    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
    AED_L_FLAGS[AED_V_ENDACL] = 0;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    BUFFER_INDEX = 0;
    AED_B_COLUMN = 1;
    END;
AED_SET_CURSOR (.AED_B_LINE, .BUFFER_INDEX + 1);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_MOVE_ACE

%SBTTL	'ACT_MOVE_BOL - move to beginning of line'
ROUTINE ACT_MOVE_BOL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine positions the cursor to the beginning of the current
!	line segment.
!
! CALLING SEQUENCE:
!	ACT_MOVE_BOL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

BUFFER_INDEX = 0;
AED_W_ITEMEND = 0;
AED_B_COLUMN = 1;
AED_SET_CURSOR (.AED_B_LINE, 1);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_MOVE_BOL

%SBTTL	'ACT_MOVE_EOL - move to end of line'
ROUTINE ACT_MOVE_EOL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine positions the cursor to the end of the current line
!	segment.
!
! CALLING SEQUENCE:
!	ACT_MOVE_EOL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

BUFFER_INDEX = .SEGMENT_SIZE;
AED_W_ITEMEND = .BUFFER_INDEX;
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_MOVE_EOL

%SBTTL	'ACT_UP - move up to previous line'
ROUTINE ACT_UP =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine moves the cursor up to the previous line segment.  If
!	the current ACE has been modified but not entered, it is done before
!	moving the cursor.  The cursor position in the new line segment
!	is minimized with the current cursor position and the end of the
!	line segment.
!
! CALLING SEQUENCE:
!	ACT_UP ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	UP_LINE_SEGMENT	: REF $BBLOCK;		! Address of previous line

AED_L_FLAGS[AED_V_INSERTEXT] = 0;		! No item selection

IF .AED_T_CURLINE[LINE_L_BLINK] NEQA AED_Q_LINETABLE[LINE_L_FLINK]
THEN
    BEGIN
    NEW_TEXT_LINE = AED_REPSEGMENT ();
    IF .NEW_TEXT_LINE[LINE_V_BEGINACE]
    THEN
	BEGIN
	IF .AED_L_FLAGS[AED_V_MODIFIED]
	OR .AED_L_FLAGS[AED_V_INSERT]
	OR .AED_L_FLAGS[AED_V_INSERTEXT]
	THEN
	    BEGIN
	    FINISH_ACE ();
	    IF .AED_L_FLAGS[AED_V_PROMPT]
	    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
	    THEN
		BEGIN
		NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
		AED_W_TOTALSIZE = 0;
		END;
	    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
	    IF .AED_W_TOTALSIZE EQL 0
	    THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	    AED_COMPRESS ();
	    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
	    IF NOT .AED_L_STATUS
	    THEN
		BEGIN
		AED_L_FLAGS[AED_V_ACERROR] = 1;
		AED_POSITION (.AED_L_FIRSTLINE);
		AED_COPSEGMENT (.AED_L_FIRSTLINE);
		INSQUE (AED_T_CURLINE[LINE_L_FLINK],
			.AED_L_FIRSTLINE[LINE_L_BLINK]);
		IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
		THEN AED_L_LASTLINE = AED_T_CURLINE;
		IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
		THEN AED_L_BEGINLINE = AED_T_CURLINE;
		AED_L_FIRSTLINE = AED_T_CURLINE;
		IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
		AND .AED_L_FLAGS[AED_V_ENDACL]
		THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
		BUFFER_INDEX = 0;
		AED_B_COLUMN = 1;
		AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
		AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		TERM_CHAR = 0;
		RETURN 1;
		END;
	    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
	    END;
	END;
    UP_LINE_SEGMENT = .NEW_TEXT_LINE[LINE_L_BLINK];
    AED_POSITION (.UP_LINE_SEGMENT);
    AED_COPSEGMENT (.UP_LINE_SEGMENT);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], .UP_LINE_SEGMENT[LINE_L_BLINK]);
    IF .AED_L_BEGINLINE EQL .UP_LINE_SEGMENT
    THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .AED_L_FIRSTLINE EQL .UP_LINE_SEGMENT
    THEN AED_L_FIRSTLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .AED_T_CURLINE[LINE_V_ENDACE]
    THEN
	BEGIN
	AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	AED_W_TOTALSIZE = .AED_L_LASTLINE[LINE_W_SIZE];
	UNTIL .AED_L_FIRSTLINE[LINE_V_BEGINACE]
	DO
	    BEGIN
	    AED_L_FIRSTLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
	    AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_FIRSTLINE[LINE_W_SIZE];
	    END;
	AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
	END;
    BUFFER_INDEX = MIN (.SEGMENT_SIZE, .AED_B_COLUMN - 1);
    END
ELSE AED_B_LINE = 1;
AED_SET_CURSOR (.AED_B_LINE, .BUFFER_INDEX + 1);
AED_L_FLAGS[AED_V_ENDACL] = 0;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_UP

%SBTTL	'ACT_DOWN - move down to next line'
ROUTINE ACT_DOWN =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine moves the cursor down to the next line segment.  The
!	cursor position in the new line segment is minimized with the
!	current cursor position and the end of the line segment.
!
! CALLING SEQUENCE:
!	ACT_DOWN ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	DOWN_LINE_SEGMENT	: REF $BBLOCK;	! Address of next line segment

IF NOT .AED_L_FLAGS[AED_V_ENDACL]
OR .AED_W_TOTALSIZE GTR 0 OR .SEGMENT_SIZE GTR 0
THEN
    BEGIN
    NEW_TEXT_LINE = AED_REPSEGMENT ();
    IF .AED_L_LASTLINE EQLA NEW_TEXT_LINE[LINE_L_FLINK]
    THEN
	BEGIN
	IF .AED_L_FLAGS[AED_V_MODIFIED]
	OR .AED_L_FLAGS[AED_V_INSERT]
	OR .AED_L_FLAGS[AED_V_INSERTEXT]
	THEN
	    BEGIN
	    FINISH_ACE ();
	    IF .AED_L_FLAGS[AED_V_PROMPT]
	    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
	    THEN
		BEGIN
		NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
		AED_W_TOTALSIZE = 0;
		END;
	    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
	    IF .AED_W_TOTALSIZE EQL 0
	    THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_BLINK];
	    AED_COMPRESS ();
	    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
	    IF NOT .AED_L_STATUS
	    THEN
		BEGIN
		AED_L_FLAGS[AED_V_ACERROR] = 1;
		AED_POSITION (.AED_L_FIRSTLINE);
		AED_COPSEGMENT (.AED_L_FIRSTLINE);
		INSQUE (AED_T_CURLINE[LINE_L_FLINK],
			.AED_L_FIRSTLINE[LINE_L_BLINK]);
		IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
		THEN AED_L_LASTLINE = AED_T_CURLINE;
		IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
		THEN AED_L_BEGINLINE = AED_T_CURLINE;
		AED_L_FIRSTLINE = AED_T_CURLINE;
		IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
		AND .AED_L_FLAGS[AED_V_ENDACL]
		THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
		BUFFER_INDEX = 0;
		AED_B_COLUMN = 1;
		AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
		AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		TERM_CHAR = 0;
		RETURN 1;
		END;
	    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
	    END;
	END;
    DOWN_LINE_SEGMENT = .NEW_TEXT_LINE[LINE_L_FLINK];
    AED_POSITION (.DOWN_LINE_SEGMENT);
    AED_COPSEGMENT (.DOWN_LINE_SEGMENT);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], .DOWN_LINE_SEGMENT[LINE_L_BLINK]);
    IF .AED_L_LASTLINE EQL .DOWN_LINE_SEGMENT
    THEN AED_L_LASTLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .AED_L_BEGINLINE EQL .DOWN_LINE_SEGMENT
    THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .DOWN_LINE_SEGMENT NEQA AED_Q_LINETABLE[LINE_L_FLINK]
    THEN
	BEGIN
	IF .AED_T_CURLINE[LINE_V_BEGINACE]
	THEN
	    BEGIN
	    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
	    UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
	    DO
		BEGIN
		IF .AED_L_LASTLINE EQLA AED_T_CURLINE
		THEN AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
		AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
		AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
		END;
	    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
	    END;
	BUFFER_INDEX = MIN (.SEGMENT_SIZE, .AED_B_COLUMN - 1);
	AED_SET_CURSOR (.AED_B_LINE, .BUFFER_INDEX + 1);
	END
    ELSE
	BEGIN
	AED_L_FLAGS[AED_V_ENDACL] = 1;
	AED_L_FLAGS[AED_V_INSERTEXT] = 1;
	AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
	AED_L_CURACE = 0;
	IF .AED_L_FLAGS[AED_V_PROMPT]
	THEN
	    BEGIN
	    AED_B_ACETYPE = 0;
	    AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	    AED_SELECTFIELD (BUFFER_INDEX);
	    ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.AED_B_LINE, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
	    AED_B_COLUMN = .BUFFER_INDEX + 1;
	    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	    AED_L_FLAGS[AED_V_FIRSTCHAR] = 1;
	    END;
	END;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_DOWN

%SBTTL	'ACT_RIGHT - move right one character'
ROUTINE ACT_RIGHT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine advances the cursor one character to the right.  If
!	the end of the line segment is reached, the cursor is set to the
!	first character of the next line.
!
! CALLING SEQUENCE:
!	ACT_RIGHT ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

IF .BUFFER_INDEX LSS .SEGMENT_SIZE
THEN
    BEGIN
    BUFFER_INDEX = .BUFFER_INDEX + 1;
    AED_B_COLUMN = .BUFFER_INDEX + 1;
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

BUFFER_INDEX = 0;
AED_B_COLUMN = 1;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
TERM_CHAR = KEY_C_DOWN;
RETURN 1;

END;						! End of routine ACT_RIGHT

%SBTTL	'ACT_LEFT - move left one character'
ROUTINE ACT_LEFT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine advances the cursor one character to the left.  If
!	the beginning of the line segment is reached, the cursor is set
!	to the last character of the previous line.
!
! CALLING SEQUENCE:
!	ACT_LEFT ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

IF .BUFFER_INDEX GTR 0
THEN
    BEGIN
    BUFFER_INDEX = .BUFFER_INDEX - 1;
    AED_B_COLUMN = .BUFFER_INDEX + 1;
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;

AED_B_COLUMN = .$BBLOCK [.AED_T_CURLINE[LINE_L_BLINK], LINE_W_SIZE] + 1;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
TERM_CHAR = KEY_C_UP;
RETURN 1;

END;						! End of routine ACT_LEFT

%SBTTL	'ACT_TOP - move to beginning of ACL'
ROUTINE ACT_TOP =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine moves the cursor to the first character in the first
!	line segment of the first ACE in the ACL.  The display is scrolled
!	as necessary.
!
! CALLING SEQUENCE:
!	ACT_TOP ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

AED_L_FLAGS[AED_V_INSERTEXT] = 0;			! No item selection

NEW_TEXT_LINE = AED_REPSEGMENT ();
IF .AED_L_FLAGS[AED_V_MODIFIED]
OR .AED_L_FLAGS[AED_V_INSERT]
OR .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    FINISH_ACE ();
    IF .AED_L_FLAGS[AED_V_PROMPT]
    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
    THEN
	BEGIN
	NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
	AED_W_TOTALSIZE = 0;
	END;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    IF .AED_W_TOTALSIZE EQL 0
    THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    AED_COMPRESS ();
    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ACERROR] = 1;
	AED_POSITION (.AED_L_FIRSTLINE);
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_LASTLINE = AED_T_CURLINE;
	IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE = AED_T_CURLINE;
	IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	AND .AED_L_FLAGS[AED_V_ENDACL]
	THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
    END;
AED_COMPRESS ();
AED_L_FIRSTLINE = .AED_Q_LINETABLE[LINE_L_FLINK];
AED_POSITION (.AED_L_FIRSTLINE);
AED_COPSEGMENT (.AED_L_FIRSTLINE);
INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_L_FIRSTLINE[LINE_L_BLINK]);
AED_L_BEGINLINE = AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE[LINE_L_FLINK];
AED_W_TOTALSIZE = .AED_L_LASTLINE[LINE_W_SIZE];
UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
DO
    BEGIN
    AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
    AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
    END;
AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
BUFFER_INDEX = 0;
AED_B_LINE = AED_B_COLUMN = 1;
AED_SET_CURSOR (1, 1);
AED_L_FLAGS[AED_V_ENDACL] = 0;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_TOP

%SBTTL	'ACT_BOTTOM - move to end of ACL'
ROUTINE ACT_BOTTOM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine positions the cursor to the first character position
!	in a new ACE at the end of the ACL.  The screen is scrolled as
!	necessary.
!
! CALLING SEQUENCE:
!	ACT_BOTTOM ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

NEW_TEXT_LINE = AED_REPSEGMENT ();
IF .AED_L_FLAGS[AED_V_MODIFIED]
OR .AED_L_FLAGS[AED_V_INSERT]
OR .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    FINISH_ACE ();
    IF .AED_L_FLAGS[AED_V_PROMPT]
    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
    THEN
	BEGIN
	NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
	AED_W_TOTALSIZE = 0;
	END;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    IF .AED_W_TOTALSIZE EQL 0
    THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_BLINK];
    AED_COMPRESS ();
    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ACERROR] = 1;
	AED_POSITION (.AED_L_FIRSTLINE);
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_LASTLINE = AED_T_CURLINE;
	IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE = AED_T_CURLINE;
	IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	AND .AED_L_FLAGS[AED_V_ENDACL]
	THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
    END;
AED_COMPRESS ();
AED_POSITION (AED_Q_LINETABLE[LINE_L_FLINK]);
INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_Q_LINETABLE[LINE_L_BLINK]);
AED_L_FLAGS[AED_V_ENDACL] = 1;
AED_L_FLAGS[AED_V_INSERTEXT] = 1;
AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
BUFFER_INDEX = 0;
AED_B_COLUMN = 1;
AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
AED_L_CURACE = 0;
IF .AED_L_FLAGS[AED_V_PROMPT]
THEN
    BEGIN
    AED_B_ACETYPE = 0;
    AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
    AED_SELECTFIELD (BUFFER_INDEX);
    ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
    ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
    SCR$SET_CURSOR (.AED_B_LINE, 1);
    AED_PUTOUTPUT (ECHO_DESC);
    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
    AED_B_COLUMN = .BUFFER_INDEX + 1;
    AED_L_FLAGS[AED_V_FIRSTCHAR] = 1;
    END;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_BOTTOM

%SBTTL	'ACT_FIND_STR - locate specific string'
ROUTINE ACT_FIND_STR =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine obtains the string to be searched for.  If the search
!	string is terminated by the ADVANCE action key, the search is in
!	the forward direction.  If the search string is terminated by the
!	BACKUP action key, the search is in the backward direction.  The
!	screen is scrolled as necessary to accomodate the next occurrance
!	of the search string.
!
! CALLING SEQUENCE:
!	ACT_FIND_STR ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	STRING_INDEX	: VECTOR [1,WORD];	! Index into search string buffer

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
SCR$SET_CURSOR (21, 1);
AED_PUTOUTPUT ($DESCRIPTOR ('Search string: '));
STRING_INDEX = 0;
WHILE 1
DO
    BEGIN
    TERM_CHAR = AED_DECODEKEY ();
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    IF .TERM_CHAR EQL 0 THEN RETURN 1;
    IF .AED_L_FLAGS[AED_V_ACTIONKEY]
    OR .TERM_CHAR EQL AED_C_CHAR_ESC
    THEN
	BEGIN
	IF .TERM_CHAR EQL KEY_C_RUB_BOL
	THEN
	    BEGIN
	    SCR$ERASE_PAGE (21, 1);
	    SCR$SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    RETURN 1;
	    END
	ELSE IF .TERM_CHAR EQL KEY_C_RUB_CHR
	THEN
	    BEGIN
	    IF .STRING_INDEX GTR 0
	    THEN
		BEGIN
		STRING_INDEX = .STRING_INDEX - 1;
		AED_PUTOUTPUT ($DESCRIPTOR (%CHAR (AED_C_CHAR_BS),
					    ' ',
					    %CHAR (AED_C_CHAR_BS)));
		END;
	    END
	ELSE EXITLOOP;
	END
    ELSE IF .TERM_CHAR GEQ ' '
    THEN
	BEGIN
	IF .TERM_CHAR GEQ 'a' AND .TERM_CHAR LEQ 'z'
	THEN TERM_CHAR = .TERM_CHAR - 32;	! Convert lower to upper case
	ECHO_DESC[DSC$W_LENGTH] = 1;
	ECHO_DESC[DSC$A_POINTER] = TERM_CHAR;
	AED_PUTOUTPUT (ECHO_DESC);
	SEARCH_STRING[.STRING_INDEX] = .TERM_CHAR;
	STRING_INDEX = .STRING_INDEX + 1;
	END;
    END;
SEARCH_SIZE = .STRING_INDEX;
SCR$ERASE_PAGE (21, 1);
IF .SEARCH_SIZE EQL 0
THEN
    BEGIN
    SCR$SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;
IF .AED_L_FLAGS[AED_V_ACTIONKEY]
THEN
    BEGIN
    IF .TERM_CHAR EQL KEY_C_ADVANCE THEN AED_L_FLAGS[AED_V_BACKWARD] = 0;
    IF .TERM_CHAR EQL KEY_C_BACKUP THEN AED_L_FLAGS[AED_V_BACKWARD] = 1;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
TERM_CHAR = KEY_C_FIND_NXT;
RETURN 1;

END;						! End of routine ACT_FIND_STR

%SBTTL	'ACT_FIND_NXT - locate next occurrance of string'
ROUTINE ACT_FIND_NXT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches for the next occurrence of the selected search
!	string.  The direction of the search depends of the state of the
!	BACKWARD flag.
!
! CALLING SEQUENCE:
!	ACT_FIND_NXT ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	START_SEGMENT	: REF $BBLOCK,		! Line where search started
	SEARCH_BEGIN	: VECTOR [1,WORD],	! Where to start the search
	SEARCH_END	: VECTOR [1,WORD],	! Where the search ends
	STRING_LOCATION,			! Location of the found string or 0
	NEW_ACE,				! String found in new ACE flag
	MATCH_SEGMENT	: REF $BBLOCK;		! Address of line that matched

IF .SEARCH_SIZE EQL 0
THEN
    BEGIN
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END;
IF NOT .AED_L_FLAGS[AED_V_BACKWARD]
THEN
    BEGIN

! See if the specified string is within the current line.

    SEARCH_BEGIN = .BUFFER_INDEX + .SEARCH_SIZE;
    IF .SEARCH_BEGIN GEQ .SEGMENT_SIZE
    OR .SEARCH_BEGIN + .SEARCH_SIZE GTR .SEGMENT_SIZE
    THEN STRING_LOCATION = 0
    ELSE STRING_LOCATION = CH$FIND_SUB (.SEGMENT_SIZE - .SEARCH_BEGIN,
					INPUT_BUFFER[.SEARCH_BEGIN],
					.SEARCH_SIZE, SEARCH_STRING);
    IF .STRING_LOCATION NEQ 0
    THEN
	BEGIN
	BUFFER_INDEX = .STRING_LOCATION - INPUT_BUFFER[0];
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;

! The specified search string is not within the current line.  Update the
! text ACE with the current line segment.  Then loop through the remaining
! line segments in the line table looking for the search string.  If it is
! found beyond the end of the current ACE, update the ACL with the current
! ACE.  Otherwise, simply set the various pointers to point to the line
! segment where the search string was found.

    NEW_TEXT_LINE = AED_REPSEGMENT ();
    START_SEGMENT = .NEW_TEXT_LINE;
    AED_L_FLAGS[AED_V_ENDACL] = 0;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    MATCH_SEGMENT = .NEW_TEXT_LINE[LINE_L_FLINK];
    NEW_ACE = .AED_L_LASTLINE EQL .NEW_TEXT_LINE;
    SEARCH_BEGIN = 0;
    UNTIL .MATCH_SEGMENT EQLA AED_Q_LINETABLE[LINE_L_FLINK]
    DO
	BEGIN
	STRING_LOCATION = CH$FIND_SUB (.MATCH_SEGMENT[LINE_W_SIZE] -
				       .SEARCH_BEGIN,
				       VECTOR [MATCH_SEGMENT[LINE_T_TEXT],
					       .SEARCH_BEGIN; ,BYTE],
				       .SEARCH_SIZE, SEARCH_STRING);
	IF .STRING_LOCATION NEQ 0
	THEN
	    BEGIN
	    IF .NEW_ACE
	    AND (.AED_L_FLAGS[AED_V_MODIFIED]
		 OR .AED_L_FLAGS[AED_V_INSERT]
		 OR .AED_L_FLAGS[AED_V_INSERTEXT])
	    THEN
		BEGIN
		FINISH_ACE ();
		IF .AED_L_FLAGS[AED_V_PROMPT]
		AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
		THEN
		    BEGIN
		    NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
		    AED_W_TOTALSIZE = 0;
		    END;
		AED_L_FLAGS[AED_V_INSERTEXT] = 0;
		IF .AED_W_TOTALSIZE EQL 0
		THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
		AED_COMPRESS ();
		AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
		IF NOT .AED_L_STATUS
		THEN
		    BEGIN
		    AED_L_FLAGS[AED_V_ACERROR] = 1;
		    AED_POSITION (.AED_L_FIRSTLINE);
		    AED_COPSEGMENT (.AED_L_FIRSTLINE);
		    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
			    .AED_L_FIRSTLINE[LINE_L_BLINK]);
		    IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
		    THEN AED_L_LASTLINE = AED_T_CURLINE;
		    IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
		    THEN AED_L_BEGINLINE = AED_T_CURLINE;
		    AED_L_FIRSTLINE = AED_T_CURLINE;
		    IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
		    AND .AED_L_FLAGS[AED_V_ENDACL]
		    THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
		    BUFFER_INDEX = 0;
		    AED_B_COLUMN = 1;
		    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
		    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		    TERM_CHAR = 0;
		    RETURN 1;
		    END;
		AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
		END;
	    AED_L_FIRSTLINE = AED_L_LASTLINE = .MATCH_SEGMENT;
	    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
	    UNTIL .AED_L_FIRSTLINE[LINE_V_BEGINACE]
	    DO
		BEGIN
		AED_L_FIRSTLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
		AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_FIRSTLINE[LINE_W_SIZE];
		END;
	    DO
		BEGIN
		AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
		AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
		END
	    UNTIL .AED_L_LASTLINE[LINE_V_BEGINACE]
	       OR .AED_L_LASTLINE EQLA AED_Q_LINETABLE[LINE_L_FLINK];
	    AED_W_TOTALSIZE = .AED_W_TOTALSIZE - .AED_L_LASTLINE[LINE_W_SIZE];
	    AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_BLINK];
	    AED_POSITION (.MATCH_SEGMENT);
	    AED_COPSEGMENT (.MATCH_SEGMENT);
	    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		    .MATCH_SEGMENT[LINE_L_BLINK]);
	    IF .AED_L_BEGINLINE EQL .MATCH_SEGMENT
	    THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
	    IF .AED_L_FIRSTLINE EQL .MATCH_SEGMENT
	    THEN AED_L_FIRSTLINE = AED_T_CURLINE[LINE_L_FLINK];
	    IF .AED_L_LASTLINE EQL .MATCH_SEGMENT
	    THEN AED_L_LASTLINE = AED_T_CURLINE[LINE_L_FLINK];
	    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
	    BUFFER_INDEX = .STRING_LOCATION - MATCH_SEGMENT[LINE_T_TEXT];
	    AED_B_COLUMN = .BUFFER_INDEX + 1;
	    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    RETURN 1;
	    END;
	IF .AED_L_LASTLINE EQL .MATCH_SEGMENT THEN NEW_ACE = 1;
	MATCH_SEGMENT = .MATCH_SEGMENT[LINE_L_FLINK];
	SEARCH_BEGIN = 0;
	END;
    END
ELSE
    BEGIN
    NEW_TEXT_LINE = AED_REPSEGMENT ();
    START_SEGMENT = .NEW_TEXT_LINE;
    MATCH_SEGMENT = NEW_TEXT_LINE[LINE_L_FLINK];
    AED_L_FLAGS[AED_V_ENDACL] = 0;
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    NEW_ACE = 0;
    SEARCH_END = .BUFFER_INDEX;
    UNTIL .MATCH_SEGMENT EQLA AED_Q_LINETABLE[LINE_L_FLINK]
    DO
	BEGIN
	STRING_LOCATION = CH$FIND_SUB (.SEARCH_END, MATCH_SEGMENT[LINE_T_TEXT],
				       .SEARCH_SIZE, SEARCH_STRING);
	IF .STRING_LOCATION NEQ 0
	THEN
	    BEGIN
	    IF .NEW_ACE
	    AND (.AED_L_FLAGS[AED_V_MODIFIED]
		 OR .AED_L_FLAGS[AED_V_INSERT]
		 OR .AED_L_FLAGS[AED_V_INSERTEXT])
	    THEN
		BEGIN
		FINISH_ACE ();
		IF .AED_L_FLAGS[AED_V_PROMPT]
		AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
		THEN
		    BEGIN
		    NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
		    AED_W_TOTALSIZE = 0;
		    END;
		IF .AED_W_TOTALSIZE EQL 0
		THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
		AED_COMPRESS ();
		AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
		IF NOT .AED_L_STATUS
		THEN
		    BEGIN
		    AED_L_FLAGS[AED_V_ACERROR] = 1;
		    AED_POSITION (.AED_L_FIRSTLINE);
		    AED_COPSEGMENT (.AED_L_FIRSTLINE);
		    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
			    .AED_L_FIRSTLINE[LINE_L_BLINK]);
		    IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
		    THEN AED_L_LASTLINE = AED_T_CURLINE;
		    IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
		    THEN AED_L_BEGINLINE = AED_T_CURLINE;
		    AED_L_FIRSTLINE = AED_T_CURLINE;
		    IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
		    AND .AED_L_FLAGS[AED_V_ENDACL]
		    THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
		    BUFFER_INDEX = 0;
		    AED_B_COLUMN = 1;
		    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
		    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		    TERM_CHAR = 0;
		    RETURN 1;
		    END;
		AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
		END;
	    SEARCH_BEGIN = .SEARCH_END;
	    WHILE 1
	    DO
		BEGIN
		SEARCH_BEGIN = .SEARCH_BEGIN - .SEARCH_SIZE;
		STRING_LOCATION = CH$FIND_SUB (.SEARCH_END - .SEARCH_BEGIN,
					       VECTOR [MATCH_SEGMENT[LINE_T_TEXT],
						       .SEARCH_BEGIN; ,BYTE],
					       .SEARCH_SIZE, SEARCH_STRING);
		IF .STRING_LOCATION NEQ 0
		THEN
		    BEGIN
		    AED_L_FIRSTLINE = AED_L_LASTLINE = .MATCH_SEGMENT;
		    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
		    UNTIL .AED_L_FIRSTLINE[LINE_V_BEGINACE]
		    DO
			BEGIN
			AED_L_FIRSTLINE = .AED_L_FIRSTLINE[LINE_L_BLINK];
			AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_FIRSTLINE[LINE_W_SIZE];
			END;
		    DO
			BEGIN
			AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
			AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
			END
		    UNTIL .AED_L_LASTLINE[LINE_V_BEGINACE]
		       OR .AED_L_LASTLINE EQLA AED_Q_LINETABLE[LINE_L_FLINK];
		    AED_W_TOTALSIZE = .AED_W_TOTALSIZE - .AED_L_LASTLINE[LINE_W_SIZE];
		    AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_BLINK];
		    AED_POSITION (.MATCH_SEGMENT);
		    AED_COPSEGMENT (.MATCH_SEGMENT);
		    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
			    .MATCH_SEGMENT[LINE_L_BLINK]);
		    IF .AED_L_BEGINLINE EQL .MATCH_SEGMENT
		    THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
		    IF .AED_L_FIRSTLINE EQL .MATCH_SEGMENT
		    THEN AED_L_FIRSTLINE = AED_T_CURLINE[LINE_L_FLINK];
		    IF .AED_L_LASTLINE EQL .MATCH_SEGMENT
		    THEN AED_L_LASTLINE = AED_T_CURLINE[LINE_L_FLINK];
		    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
		    BUFFER_INDEX = .STRING_LOCATION - MATCH_SEGMENT[LINE_T_TEXT];
		    AED_B_COLUMN = .BUFFER_INDEX + 1;
		    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
		    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		    TERM_CHAR = 0;
		    RETURN 1;
		    END;
		END;
	    END;
	IF .AED_L_FIRSTLINE EQL .MATCH_SEGMENT THEN NEW_ACE = 1;
	MATCH_SEGMENT = .MATCH_SEGMENT[LINE_L_BLINK];
	SEARCH_END = .MATCH_SEGMENT[LINE_W_SIZE];
	END;
    END;
SIGNAL (AED$_NOTFOUND);
AED_COPSEGMENT (.START_SEGMENT);
INSQUE (AED_T_CURLINE[LINE_L_FLINK], .START_SEGMENT[LINE_L_BLINK]);
IF .AED_L_BEGINLINE EQL .START_SEGMENT THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
IF .AED_L_FIRSTLINE EQL .START_SEGMENT THEN AED_L_FIRSTLINE = AED_T_CURLINE[LINE_L_FLINK];
IF .AED_L_LASTLINE EQL .START_SEGMENT THEN AED_L_LASTLINE = AED_T_CURLINE[LINE_L_FLINK];
AED_L_FLAGS[AED_V_ACERROR] = 1;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_FIND_NXT

%SBTTL	'ACT_ADV_FIELD - advance to the next field'
ROUTINE ACT_ADV_FIELD =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine moves the cursor to the beginning of the next major
!	field or inserts the text for the first item in the next major
!	field depending on the state of the PROMPT flag.  The cursor is
!	left positioned to the end of the selected field.
!
! CALLING SEQUENCE:
!	ACT_ADV_FIELD ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

IF .AED_L_FLAGS[AED_V_OPENUIC]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_ACERROR] = 1;
    SIGNAL (AED$_BADUIC);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END
ELSE
    BEGIN
    IF NOT .AED_L_FLAGS[AED_V_NOITEMSEL]
    THEN
	BEGIN
	IF .BUFFER_INDEX GTR 0
	AND (IF .AED_B_ACETYPE EQL ACE$C_DIRDEF
	     THEN .AED_B_FIELD LSS 5
	     ELSE .AED_B_FIELD LSS 6)
	THEN
	    BEGIN
	    IF .INPUT_BUFFER[.BUFFER_INDEX - 1] EQL '+'
	    THEN INPUT_BUFFER[.BUFFER_INDEX - 1] = ','
	    ELSE
		BEGIN
		IF .BUFFER_INDEX GEQ .AED_L_PAGEWIDTH
		THEN AED_SEGSPLIT (BUFFER_INDEX, 0, 0, 0);
		INPUT_BUFFER[.BUFFER_INDEX] = ',';
		ECHO_DESC[DSC$W_LENGTH] = 1;
		ECHO_DESC[DSC$A_POINTER] = INPUT_BUFFER[.BUFFER_INDEX];
		AED_PUTOUTPUT (ECHO_DESC);
		SEGMENT_SIZE = .SEGMENT_SIZE + 1;
		BUFFER_INDEX = .BUFFER_INDEX + 1;
		AED_B_COLUMN = .AED_B_COLUMN + 1;
		END;
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    TERM_CHAR = KEY_C_SEL_FIELD;
	    RETURN 1;
	    END;
	END
    ELSE
	BEGIN
	WHILE .BUFFER_INDEX LSS .SEGMENT_SIZE
	DO
	    BEGIN
	    AED_SELECTFIELD (BUFFER_INDEX);
	    IF .INPUT_BUFFER[.BUFFER_INDEX] EQL ',' THEN EXITLOOP;
	    END;
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	END;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_ADV_FIELD

%SBTTL	'ACT_SEL_FIELD - select the next field'
ROUTINE ACT_SEL_FIELD =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine moves the cursor to the beginning of the next field or
!	inserts the text for the first item in the next field depending on
!	the state of the PROMPT flag.  The cursor is left positioned to the
!	end of the selected field.
!
! CALLING SEQUENCE:
!	ACT_SEL_FIELD ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

IF .AED_L_FLAGS[AED_V_OPENUIC]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_ACERROR] = 1;
    SIGNAL (AED$_BADUIC);
    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
    TERM_CHAR = 0;
    RETURN 1;
    END
ELSE
    BEGIN
    IF .BUFFER_INDEX LSS .SEGMENT_SIZE
    OR NOT .AED_L_FLAGS[AED_V_NOITEMSEL]
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
	AED_SELECTFIELD (BUFFER_INDEX);
	IF NOT .AED_L_FLAGS[AED_V_NOITEMSEL]
	THEN
	    BEGIN
	    ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.AED_B_LINE, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
	    END;
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	END;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_SEL_FIELD

%SBTTL	'ACT_SEL_ITEM - select the next item'
ROUTINE ACT_SEL_ITEM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine selects the next item based upon the selected field.
!	The cursor is left positioned at the end of the selected item.  This
!	is only valid for an ACE being entered in PROMPT mode.
!
! CALLING SEQUENCE:
!	ACT_SEL_ITEM ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

! Clear all key indicators in case an error is seen.

AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;

! Check to see if item selection is allowed.

IF NOT .AED_L_FLAGS[AED_V_PROMPT] OR NOT .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_ACERROR] = 1;
    SIGNAL (AED$_NOITEMSEL);
    RETURN 1;
    END;

IF .AED_L_FLAGS[AED_V_OPENUIC]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_ACERROR] = 1;
    SIGNAL (AED$_BADUIC);
    RETURN 1;
    END;

! No error conditions have been found, select the next item.

AED_L_FLAGS[AED_V_FIRSTCHAR] = 0;
AED_SELECTITEM (BUFFER_INDEX);
ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
SCR$SET_CURSOR (.AED_B_LINE, 1);
AED_PUTOUTPUT (ECHO_DESC);
SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
AED_B_COLUMN = .BUFFER_INDEX + 1;
AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);

RETURN 1;

END;						! End of routine ACT_SEL_ITEM

%SBTTL	'ACT_HELP - provide interactive help'
ROUTINE ACT_HELP =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine supplies the interactive help to the user.
!
! CALLING SEQUENCE:
!	ACT_HELP ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

SCR$SET_SCROLL (1, 24);
AED_GIVEHELP ();
ACT_REFRESH (0);					! Refersh the screen
RETURN 1;

END;						! End of routine ACT_HELP

%SBTTL	'ACT_REFRESH - refresh the display'
ROUTINE ACT_REFRESH (RESET) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine clears the screen and repaints the display to eliminate
!	any extraneous garbage that may have appeared on the screen.
!
! CALLING SEQUENCE:
!	ACT_REFRESH (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: 1 = reinitialize display from object's original ACL
!	      0 = reinitialize display from in core copy of object's ACL
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	CURRENT_LINE	: REF $BBLOCK,		! Address of current line segment
	ATR_ARGLIST	: BLOCKVECTOR [2, ITM$S_ITEM, BYTE],	! ACL attribute descriptor
	ACL_CONTEXT,				! ACL context for $CHANGE_ACL
	ACE_POINTER	: REF $BBLOCK,		! Address of current ACE
	ACE_NEWADDR	: REF $BBLOCK,		! Copy of current ACE
	ACE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Binary ACE descr
	ACE_TEXT_DESC	: $BBLOCK [DSC$C_S_BLN],	! Text ACE descriptor
	ACE_TEXT	: $BBLOCK [3072],	! ACE text storage
	ACE_TEXT_SIZE,				! ACE text size
	FIRST_CHAR,				! Addr of first char in segment
	LAST_CHAR,				! Addr of last char in segment
	NEW_TEXT_LINE	: REF $BBLOCK,		! Converted line storage addr
	LINE_SEG_SIZE;				! Size of line segment

! If this is a reset operation, deallocate all the in core ACL information
! and rebuild it from the object's actual ACL.

IF .RESET
THEN
    BEGIN
    CH$FILL (0, 2*ITM$S_ITEM, ATR_ARGLIST);

! Go through the line segment table and deallocate all the old segments.
! In addition, get rid of the copies of the binary ACEs.

    UNTIL REMQUE (.AED_Q_LINETABLE[LINE_L_FLINK], CURRENT_LINE)
    DO
	BEGIN
	IF .CURRENT_LINE[LINE_V_BEGINACE]
	THEN IF .CURRENT_LINE[LINE_L_BINACE] NEQ 0
	     THEN DEALLOCATE (.($BBLOCK[.CURRENT_LINE[LINE_L_BINACE], ACE$B_SIZE]),
			      CURRENT_LINE[LINE_L_BINACE]);
	DEALLOCATE (.CURRENT_LINE[LINE_W_SIZE] + $BYTEOFFSET (LINE_T_TEXT),
			 CURRENT_LINE);
	END;

! Allocate storage for the temporary ACL segment buffer.

    AED_L_STATUS = ALLOCATE (512, AED_A_ACLBUFFER);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;

! Re-read any ACL associated with the object.

    ACL_CONTEXT = 0;
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_READACL;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = 512;
    ATR_ARGLIST[0, ITM$L_BUFADR] = .AED_A_ACLBUFFER;
    WHILE 1
    DO
	BEGIN
	AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
				    OBJTYP = AED_L_OBJTYP,
				    OBJNAM = AED_Q_OBJNAM,
				    ITMLST = ATR_ARGLIST,
				    CONTXT = ACL_CONTEXT);
	IF NOT .AED_L_STATUS
	THEN
	    BEGIN
	    IF .AED_L_STATUS EQL SS$_ACLEMPTY
	    OR .AED_L_STATUS EQL SS$_NOMOREACE
	    THEN EXITLOOP;
	    SIGNAL (AED$_READERR, 1, AED_Q_OBJNAM, .AED_L_STATUS, 0);
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	    END;
	ACE_POINTER = .AED_A_ACLBUFFER;
	UNTIL .ACE_POINTER GEQA .AED_A_ACLBUFFER + 512
	DO
	    BEGIN
	    IF .ACE_POINTER[ACE$B_SIZE] EQL 0 THEN EXITLOOP;
	    AED_L_STATUS = ALLOCATE (.ACE_POINTER[ACE$B_SIZE], ACE_NEWADDR);
	    IF NOT .AED_L_STATUS
	    THEN
		BEGIN
		SIGNAL (.AED_L_STATUS);
		AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		TERM_CHAR = 0;
		RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
		END;
	    CH$MOVE (.ACE_POINTER[ACE$B_SIZE], .ACE_POINTER, .ACE_NEWADDR);
	    ACE_DESC[DSC$A_POINTER] = .ACE_POINTER;
	    ACE_DESC[DSC$W_LENGTH] = .ACE_POINTER[ACE$B_SIZE];
	    ACE_TEXT_DESC[DSC$A_POINTER] = ACE_TEXT;
	    ACE_TEXT_DESC[DSC$W_LENGTH] = 3072;
	    AED_L_STATUS = $FORMAT_ACL (ACLENT = ACE_DESC,
					ACLLEN = ACE_TEXT_DESC,
					ACLSTR = ACE_TEXT_DESC,
					WIDTH = AED_L_PAGEWIDTH,
					TRMDSC = $DESCRIPTOR (0),
					INDENT = 0);
	    ACE_TEXT_SIZE = .ACE_TEXT_DESC[DSC$W_LENGTH];
	    FIRST_CHAR = ACE_TEXT;
	    AED_L_FIRSTLINE = AED_L_LASTLINE = 0;
	    WHILE (LAST_CHAR = CH$FIND_CH (.ACE_TEXT_SIZE, .FIRST_CHAR, 0)) GTR 0
	    DO
		BEGIN
		LINE_SEG_SIZE = .LAST_CHAR - .FIRST_CHAR;
		AED_L_STATUS = ALLOCATE (.LINE_SEG_SIZE + $BYTEOFFSET (LINE_T_TEXT),
					 NEW_TEXT_LINE);
		IF NOT .AED_L_STATUS
		THEN
		    BEGIN
		    SIGNAL (.AED_L_STATUS);
		    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		    TERM_CHAR = 0;
		    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
		    END;
		NEW_TEXT_LINE[LINE_W_SIZE] = .LINE_SEG_SIZE;
		NEW_TEXT_LINE[LINE_L_BINACE] = .ACE_NEWADDR;
		CH$MOVE (.ACE_TEXT_SIZE, .FIRST_CHAR, NEW_TEXT_LINE[LINE_T_TEXT]);
		INSQUE (.NEW_TEXT_LINE, .AED_Q_LINETABLE[LINE_L_BLINK]);
		IF .AED_L_FIRSTLINE EQL 0 THEN AED_L_FIRSTLINE = .NEW_TEXT_LINE;
		AED_L_LASTLINE = .NEW_TEXT_LINE;
		FIRST_CHAR = .LAST_CHAR + 1;
		ACE_TEXT_SIZE = .ACE_TEXT_SIZE - .LINE_SEG_SIZE - 1;
		END;
	    IF .ACE_TEXT_SIZE GTR 0
	    THEN
		BEGIN
		AED_L_STATUS = ALLOCATE (.ACE_TEXT_SIZE + $BYTEOFFSET (LINE_T_TEXT),
					 NEW_TEXT_LINE);
		IF NOT .AED_L_STATUS
		THEN
		    BEGIN
		    SIGNAL (.AED_L_STATUS);
		    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
		    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
		    TERM_CHAR = 0;
		    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
		    END;
		NEW_TEXT_LINE[LINE_W_SIZE] = .ACE_TEXT_SIZE;
		NEW_TEXT_LINE[LINE_L_BINACE] = .ACE_NEWADDR;
		CH$MOVE (.ACE_TEXT_SIZE, .FIRST_CHAR, NEW_TEXT_LINE[LINE_T_TEXT]);
		INSQUE (.NEW_TEXT_LINE, .AED_Q_LINETABLE[LINE_L_BLINK]);
		IF .AED_L_FIRSTLINE EQL 0 THEN AED_L_FIRSTLINE = .NEW_TEXT_LINE;
		AED_L_LASTLINE = .NEW_TEXT_LINE;
		END;
	    AED_L_FIRSTLINE[LINE_V_BEGINACE] = 1;
	    IF .ACE_POINTER[ACE$V_HIDDEN]
	    OR (.ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_KEYID
		AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_BIJNL
		AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_AIJNL
		AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_ATJNL
		AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_AUDIT
		AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_ALARM
		AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_DIRDEF)
	    THEN AED_L_FIRSTLINE[LINE_V_NOTOUCH] = 1;
	    AED_L_LASTLINE[LINE_V_ENDACE] = 1;
	    ACE_POINTER = .ACE_POINTER + .ACE_POINTER[ACE$B_SIZE];
	    END;
	END;
    DEALLOCATE (512, AED_A_ACLBUFFER);

! If there is no ACL (the display is empty), set up to append the text
! entered.  Otherwise, set up to modify the first segment of the display.

    IF .AED_Q_LINETABLE[LINE_L_FLINK] EQLA AED_Q_LINETABLE[LINE_L_FLINK]
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ENDACL] = 1;		! At the end of the ACL
	AED_L_FLAGS[AED_V_INSERTEXT] = 1;
	AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
	INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_Q_LINETABLE[LINE_L_BLINK]);
	AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
	AED_L_CURACE = 0;
	IF .AED_L_FLAGS[AED_V_PROMPT]
	THEN
	    BEGIN
	    AED_B_ACETYPE = 0;
	    AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	    AED_SELECTFIELD (BUFFER_INDEX);
	    AED_B_COLUMN = .BUFFER_INDEX + 1;
	    END;
	END
    ELSE
	BEGIN
	AED_COPSEGMENT (.AED_Q_LINETABLE[LINE_L_FLINK]);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK], AED_Q_LINETABLE[LINE_L_FLINK]);
	AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
	AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
	UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
	DO
	    BEGIN
	    IF .AED_L_LASTLINE EQLA AED_T_CURLINE
	    THEN AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	    AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	    AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
	    END;
	AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
	IF .AED_L_FLAGS[AED_V_PROMPT]
	THEN
	    BEGIN
	    AED_L_FLAGS[AED_V_NOITEMSEL] = 1;
	    AED_SELECTFIELD (BUFFER_INDEX);
	    AED_B_COLUMN = .BUFFER_INDEX + 1;
	    END;
	END;
    AED_L_BEGINLINE = .AED_Q_LINETABLE[LINE_L_FLINK];
    AED_B_SAVE_LIN = 1;
    AED_B_SAVE_COL = .AED_B_COLUMN;
    END;

! Now repaint the display.

SCR$ERASE_PAGE (1, 1);
SCR$SET_SCROLL (1, 20);			! Set up the scrolling region
IF .AED_L_FLAGS[AED_V_VT5X] OR .AED_L_FLAGS[AED_V_VT1XX]
THEN AED_PUTOUTPUT ($DESCRIPTOR (%CHAR(AED_C_CHAR_ESC),'='));
TEMP_LINE = 1;
NEW_TEXT_LINE = .AED_L_BEGINLINE;
DO
    BEGIN
    SCR$SET_CURSOR (.TEMP_LINE, 1);
    ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
    ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
    AED_PUTOUTPUT (ECHO_DESC);
    TEMP_LINE = .TEMP_LINE + 1;
    IF .NEW_TEXT_LINE[LINE_V_REPLACE]
    THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
    END
UNTIL (.TEMP_LINE GTR 20)
   OR (.NEW_TEXT_LINE EQLA AED_Q_LINETABLE[LINE_L_FLINK]);
SCR$SET_CURSOR (.AED_B_SAVE_LIN, .AED_B_SAVE_COL);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_REFRESH

%SBTTL	'ACT_ENTER - enter the current ACE'
ROUTINE ACT_ENTER =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine updates the object's ACL with the newly modified ACE.
!	The cursor is left positioned at the first character of the next
!	ACE.
!
! CALLING SEQUENCE:
!	ACT_ENTER ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

BUFFER_INDEX = 0;
AED_B_COLUMN = 1;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
NEW_TEXT_LINE = AED_REPSEGMENT ();
IF .AED_L_FLAGS[AED_V_MODIFIED]
OR .AED_L_FLAGS[AED_V_INSERT]
OR .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    FINISH_ACE ();
    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
    AED_COMPRESS ();
    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ACERROR] = 1;
	AED_POSITION (.AED_L_FIRSTLINE);
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		.AED_L_FIRSTLINE[LINE_L_BLINK]);
	IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_LASTLINE = AED_T_CURLINE;
	IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE = AED_T_CURLINE;
	IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	AND .AED_L_FLAGS[AED_V_ENDACL]
	THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
    END;

! Set up the display for the next line.

AED_POSITION (.AED_L_LASTLINE[LINE_L_FLINK]);
IF .AED_L_LASTLINE[LINE_L_FLINK] EQLA AED_Q_LINETABLE[LINE_L_FLINK]
THEN
    BEGIN
    AED_L_FLAGS[AED_V_ENDACL] = 1;
    AED_L_FLAGS[AED_V_INSERTEXT] = 1;
    AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
	    .AED_Q_LINETABLE[LINE_L_BLINK]);
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
    AED_L_CURACE = 0;
    IF .AED_L_FLAGS[AED_V_PROMPT]
    THEN
	BEGIN
	AED_B_ACETYPE = 0;
	AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	AED_SELECTFIELD (BUFFER_INDEX);
	ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
	ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
	SCR$SET_CURSOR (.AED_B_LINE, 1);
	AED_PUTOUTPUT (ECHO_DESC);
	SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	END;
    END
ELSE
    BEGIN
    AED_COPSEGMENT (.AED_L_LASTLINE[LINE_L_FLINK]);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], AED_L_LASTLINE[LINE_L_FLINK]);
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_W_TOTALSIZE = .AED_L_FIRSTLINE[LINE_W_SIZE];
    UNTIL .AED_L_LASTLINE[LINE_V_ENDACE]
    DO
	BEGIN
	IF .AED_L_LASTLINE EQLA AED_T_CURLINE
	THEN AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	AED_L_LASTLINE = .AED_L_LASTLINE[LINE_L_FLINK];
	AED_W_TOTALSIZE = .AED_W_TOTALSIZE + .AED_L_LASTLINE[LINE_W_SIZE];
	END;
    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
    IF .AED_L_FLAGS[AED_V_PROMPT]
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_NOITEMSEL] = 1;
	AED_SELECTFIELD (BUFFER_INDEX);
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	END;
    END;
AED_L_FLAGS[AED_V_FIRSTCHAR] = 1;
IF .AED_B_COLUMN GTR .SEGMENT_SIZE + 1
THEN BUFFER_INDEX = .SEGMENT_SIZE
ELSE BUFFER_INDEX = .AED_B_COLUMN - 1;
AED_SET_CURSOR (.AED_B_LINE, .BUFFER_INDEX + 1);
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_ENTER

%SBTTL	'ACT_INSERT - insert an ACE'
ROUTINE ACT_INSERT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when it is desired to insert a new ACE at
!	a random position in the ACL.
!
! CALLING SEQUENCE:
!	ACT_INSERT ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

IF NOT .AED_L_FLAGS[AED_V_ENDACL]
AND NOT .AED_L_FLAGS[AED_V_INSERTEXT]
AND NOT .AED_L_FLAGS[AED_V_INSERT]
THEN
    BEGIN
    NEW_TEXT_LINE = AED_REPSEGMENT ();
    IF .AED_L_FLAGS[AED_V_MODIFIED]
    THEN
	BEGIN
	FINISH_ACE ();
	IF .AED_L_FLAGS[AED_V_PROMPT]
	AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
	THEN
	    BEGIN
	    NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
	    AED_W_TOTALSIZE = 0;
	    END;
	AED_L_FLAGS[AED_V_INSERTEXT] = 0;
	IF .AED_W_TOTALSIZE EQL 0
	THEN NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_BLINK];
	AED_COMPRESS ();
	AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
	IF NOT .AED_L_STATUS
	THEN
	    BEGIN
	    AED_L_FLAGS[AED_V_ACERROR] = 1;
	    AED_POSITION (.AED_L_FIRSTLINE);
	    AED_COPSEGMENT (.AED_L_FIRSTLINE);
	    INSQUE (AED_T_CURLINE[LINE_L_FLINK],
		    .AED_L_FIRSTLINE[LINE_L_BLINK]);
	    IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	    THEN AED_L_LASTLINE = AED_T_CURLINE;
	    IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	    THEN AED_L_BEGINLINE = AED_T_CURLINE;
	    AED_L_FIRSTLINE = AED_T_CURLINE;
	    IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	    AND .AED_L_FLAGS[AED_V_ENDACL]
	    THEN AED_L_FLAGS[AED_V_ENDACL] = 0;
	    BUFFER_INDEX = 0;
	    AED_B_COLUMN = 1;
	    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	    AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	    AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	    TERM_CHAR = 0;
	    RETURN 1;
	    END;
	AED_L_FLAGS[AED_V_MODIFIED] = AED_L_FLAGS[AED_V_INSERT] = 0;
	END;
    AED_COMPRESS ();
    AED_POSITION (.AED_L_FIRSTLINE);
    AED_L_CURACE = .AED_L_FIRSTLINE[LINE_L_BINACE];
    AED_W_TOTALSIZE = SEGMENT_SIZE = 0;
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_L_FIRSTLINE[LINE_L_BLINK]);
    IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
    THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
    AED_L_FIRSTLINE = AED_L_LASTLINE = AED_T_CURLINE;
    AED_L_FIRSTLINE[LINE_W_FLAGS] = LINE_M_BEGINACE;
    AED_POSITION (AED_T_CURLINE);

! Now repaint the display.  This is done by either scrolling down and repainting
! the first part of the display or repainting from the current position to the
! end of the display (or the end of the ACL).  This is necessary to echo the
! text from the split portion of the line.

    IF .AED_B_LINE LEQ 10
    THEN
	BEGIN
	SCR$SET_CURSOR (1,1);		! **** TEMP ****
	SCR$DOWN_SCROLL ();
	NEW_TEXT_LINE = .AED_L_BEGINLINE;
	INCR J FROM 1 TO .AED_B_LINE
	DO
	    BEGIN
	    ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.J, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.J, .ECHO_DESC[DSC$W_LENGTH] + 1);
	    NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	    END;
	END
    ELSE
	BEGIN
	NEW_TEXT_LINE = AED_T_CURLINE;
	INCR J FROM .AED_B_LINE TO 20
	DO
	    BEGIN
	    ECHO_DESC[DSC$W_LENGTH] = .NEW_TEXT_LINE[LINE_W_SIZE];
	    ECHO_DESC[DSC$A_POINTER] = NEW_TEXT_LINE[LINE_T_TEXT];
	    SCR$SET_CURSOR (.J, 1);
	    AED_PUTOUTPUT (ECHO_DESC);
	    SCR$ERASE_LINE (.J, .ECHO_DESC[DSC$W_LENGTH] + 1);
	    NEW_TEXT_LINE = .NEW_TEXT_LINE[LINE_L_FLINK];
	    IF .NEW_TEXT_LINE EQLA AED_Q_LINETABLE[LINE_L_FLINK] THEN EXITLOOP;
	    END;
	END;
    BUFFER_INDEX = 0;
    AED_B_COLUMN = 1;
    IF .AED_L_FLAGS[AED_V_PROMPT]
    THEN
	BEGIN
	AED_B_ACETYPE = 0;
	AED_L_FLAGS[AED_V_NOITEMSEL] = 0;
	AED_SELECTFIELD (BUFFER_INDEX);
	ECHO_DESC[DSC$W_LENGTH] = .AED_T_CURLINE[LINE_W_SIZE];
	ECHO_DESC[DSC$A_POINTER] = AED_T_CURLINE[LINE_T_TEXT];
	SCR$SET_CURSOR (.AED_B_LINE, 1);
	AED_PUTOUTPUT (ECHO_DESC);
	SCR$ERASE_LINE (.AED_B_LINE, .SEGMENT_SIZE + 1);
	AED_B_COLUMN = .BUFFER_INDEX + 1;
	END;
    AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
    AED_L_FLAGS[AED_V_FIRSTCHAR] = 1;
    AED_L_FLAGS[AED_V_INSERTEXT] = 1;
    AED_L_FLAGS[AED_V_INSERT] = 1;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;
AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
TERM_CHAR = 0;
RETURN 1;

END;						! End of routine ACT_INSERT

%SBTTL	'ACT_EXIT - leave the ACL editor'
ROUTINE ACT_EXIT (QUIT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles two ACL editor actions.  If the action is a
!	QUIT, then any existing journal file is closed (but not deleted),
!	any unentered ACE is left untouched, and the session is terminated.
!
!	If the action is an EXIT, the object's ACL is updated to reflect the
!	current state.  This done by first deleting any existing ACL, and
!	adding the current in core one.
!
! CALLING SEQUENCE:
!	ACT_EXIT (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: 1 = terminate the session with the object's ACL untouched
!	      0 = terminate the session and update the object's ACL
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error status otherwise
!
! SIDE EFFECTS:
!	The line segment table is updated as necessary, ACE line pointers
!	are updated, and the object's ACL is updated as necessary.
!
!--

BEGIN

LOCAL
	ATR_ARGLIST	: BLOCKVECTOR [2, ITM$S_ITEM, BYTE],	! ACL attributes
	ACL_CONTEXT,				! ACL context for $CHANGE_ACL
	DUMMY_ACE	: $BBLOCK [ACL$S_DELACLENT],	! Dummy ACE for delete
	CURRENT_LINE	: REF $BBLOCK;		! Current line segment address

! Determine if this is a QUIT or EXIT.

IF .QUIT
THEN
    BEGIN
    SIGNAL (AED$_NOCHANGE);
    RETURN 0;
    END;

NEW_TEXT_LINE = AED_REPSEGMENT ();
IF .AED_L_FLAGS[AED_V_MODIFIED]
OR .AED_L_FLAGS[AED_V_INSERT]
OR .AED_L_FLAGS[AED_V_INSERTEXT]
THEN
    BEGIN
    FINISH_ACE ();
    IF .AED_L_FLAGS[AED_V_PROMPT]
    AND .AED_L_FLAGS[AED_V_FIRSTCHAR]
    THEN
	BEGIN
	NEW_TEXT_LINE[LINE_V_DUMMY] = 1;
	AED_W_TOTALSIZE = 0;
	END;
    AED_COMPRESS ();
    AED_L_STATUS = AED_UPDATEACL (.AED_W_TOTALSIZE);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_ACERROR] = 1;
	AED_POSITION (.AED_L_FIRSTLINE);
	AED_COPSEGMENT (.AED_L_FIRSTLINE);
	INSQUE (AED_T_CURLINE[LINE_L_FLINK], .AED_L_FIRSTLINE[LINE_L_BLINK]);
	IF .AED_L_LASTLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_LASTLINE = AED_T_CURLINE;
	IF .AED_L_BEGINLINE EQL .AED_L_FIRSTLINE
	THEN AED_L_BEGINLINE = AED_T_CURLINE;
	AED_L_FIRSTLINE = AED_T_CURLINE;
	IF .AED_L_FIRSTLINE NEQ .AED_L_LASTLINE
	AND .AED_L_FLAGS[AED_V_ENDACL]
	THEN
	    BEGIN
	    AED_L_FLAGS[AED_V_ENDACL] = 0;
	    AED_L_FLAGS[AED_V_INSERTEXT] = 0;
	    END;
	BUFFER_INDEX = 0;
	AED_B_COLUMN = 1;
	AED_SET_CURSOR (.AED_B_LINE, .AED_B_COLUMN);
	AED_L_FLAGS[AED_V_GOLDKEY] = 0;
	AED_L_FLAGS[AED_V_ACTIONKEY] = 0;
	TERM_CHAR = 0;
	RETURN 1;
	END;
    END;
AED_L_FLAGS[AED_V_GOLDKEY] = 0;

! Now for the fun part.  Because the real ACL on the object hasn't been
! touched, it is necessary to update it at this time.  This is done by
! first deleting the object's ACL, and then applying the ACL as modified
! by the user.

CH$FILL (0, 2*ITM$S_ITEM, ATR_ARGLIST);
ACL_CONTEXT = 0;

! Now delete the entire ACL.  This will catch all but the protected ACEs.

ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELETEACL;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = 12;
ATR_ARGLIST[0, ITM$L_BUFADR] = DUMMY_ACE;
AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
			    OBJTYP = AED_L_OBJTYP,
			    OBJNAM = AED_Q_OBJNAM,
			    ITMLST = ATR_ARGLIST,
			    CONTXT = ACL_CONTEXT);
IF NOT .AED_L_STATUS
THEN
    BEGIN
    AED_B_OPTIONS[AED_V_KEEPJNL] = 1;		! Keep the journal file
    RETURN 0;
    END;

! Now delete any protected ACEs remaining in the ACL.

WHILE 1
DO
    BEGIN
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_READACE;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_READACE;
    ATR_ARGLIST[0, ITM$L_BUFADR] = DUMMY_ACE;
    ACL_CONTEXT = 0;
    AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
				OBJTYP = AED_L_OBJTYP,
				OBJNAM = AED_Q_OBJNAM,
				ITMLST = ATR_ARGLIST,
				CONTXT = ACL_CONTEXT);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	IF .AED_L_STATUS EQL SS$_ACLEMPTY
	OR .AED_L_STATUS EQL SS$_NOMOREACE
	THEN EXITLOOP;
	AED_B_OPTIONS[AED_V_KEEPJNL] = 1;		! Keep the journal file
	SIGNAL (.AED_L_STATUS);
	RETURN 0;
	END;
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELACLENT;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = .DUMMY_ACE[ACE$B_SIZE];
    ATR_ARGLIST[0, ITM$L_BUFADR] = DUMMY_ACE;
    AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
				OBJTYP = AED_L_OBJTYP,
				OBJNAM = AED_Q_OBJNAM,
				ITMLST = ATR_ARGLIST,
				CONTXT = ACL_CONTEXT);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	AED_B_OPTIONS[AED_V_KEEPJNL] = 1;		! Keep the journal file
	SIGNAL (.AED_L_STATUS);
	RETURN 0;
	END;
    END;

! Now that the object's original ACL has been removed, update the ACL with the
! one modified by the user.

CURRENT_LINE = .AED_Q_LINETABLE[LINE_L_FLINK];
UNTIL .CURRENT_LINE EQL AED_Q_LINETABLE[LINE_L_FLINK]
DO
    BEGIN
    IF .CURRENT_LINE[LINE_V_BEGINACE]
    AND .CURRENT_LINE[LINE_L_BINACE] NEQ 0
    THEN
	BEGIN
	ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_ADDACLENT;
	ATR_ARGLIST[0, ITM$W_BUFSIZ] = .$BBLOCK [.CURRENT_LINE[LINE_L_BINACE], ACE$B_SIZE];
	ATR_ARGLIST[0, ITM$L_BUFADR] = .CURRENT_LINE[LINE_L_BINACE];
	ACL_CONTEXT = %X'00FFFFFF';
	AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
				    OBJTYP = AED_L_OBJTYP,
				    OBJNAM = AED_Q_OBJNAM,
				    ITMLST = ATR_ARGLIST,
				    CONTXT = ACL_CONTEXT);
	IF NOT .AED_L_STATUS
	THEN
	    BEGIN
	    AED_B_OPTIONS[AED_V_KEEPJNL] = 1;		! Keep the journal file
	    SIGNAL (.AED_L_STATUS);
	    RETURN 0;
	    END;
	END;
    CURRENT_LINE = .CURRENT_LINE[LINE_L_FLINK];
    END;

SIGNAL (AED$_ACLUPDATED);

RETURN 0;

END;						! End of routine ACT_EXIT

%SBTTL	'FINISH_ACE - Tie off the current ACE'
ROUTINE FINISH_ACE : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine ties off the current ACE.  I.e., it adds a final right
!	paren if necessary.
!
! CALLING SEQUENCE:
!	FINISH_ACE ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT IMPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	PREV_LINE	: REF $BBLOCK;		! Address of the previous line

IF .AED_W_TOTALSIZE GTR 0 OR .SEGMENT_SIZE GTR 0
THEN
    BEGIN
    PREV_LINE = .AED_L_LASTLINE;
    TEMP_LINE = .AED_B_LINE;
    UNTIL .PREV_LINE[LINE_V_BEGINACE]
       OR .PREV_LINE[LINE_W_SIZE] GTR 0
    DO
	BEGIN
	PREV_LINE = .PREV_LINE[LINE_L_BLINK];
	TEMP_LINE = .TEMP_LINE - 1;
	END;
    IF .PREV_LINE[LINE_W_SIZE] EQL 0 THEN RETURN;
    AED_COPSEGMENT (.PREV_LINE);
    INSQUE (AED_T_CURLINE[LINE_L_FLINK], .PREV_LINE[LINE_L_BLINK]);
    IF .AED_L_BEGINLINE EQL .PREV_LINE
    THEN AED_L_BEGINLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .AED_L_FIRSTLINE EQL .PREV_LINE
    THEN AED_L_FIRSTLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .AED_L_LASTLINE EQL .PREV_LINE
    THEN AED_L_LASTLINE = AED_T_CURLINE[LINE_L_FLINK];
    IF .INPUT_BUFFER[.SEGMENT_SIZE - 1] EQL '+'
    THEN
	BEGIN
	AED_SET_CURSOR (.AED_B_LINE, .SEGMENT_SIZE);
	SEGMENT_SIZE = .SEGMENT_SIZE - 1;
	END;
    IF .INPUT_BUFFER[.SEGMENT_SIZE - 1] NEQ %C')'
    THEN
	BEGIN
	INPUT_BUFFER[.SEGMENT_SIZE] = ')';
	SEGMENT_SIZE = .SEGMENT_SIZE + 1;
	END;
    AED_L_LASTLINE[LINE_V_ENDACE] = 1;
    NEW_TEXT_LINE = AED_REPSEGMENT ();
    IF .TEMP_LINE GEQ 1
    THEN
	BEGIN
	AED_POSITION (.NEW_TEXT_LINE);
	AED_SET_CURSOR (.AED_B_LINE,.NEW_TEXT_LINE[LINE_W_SIZE]);
	ECHO_DESC[DSC$W_LENGTH] = 1;
	ECHO_DESC[DSC$A_POINTER] = VECTOR [NEW_TEXT_LINE[LINE_T_TEXT],
					   .NEW_TEXT_LINE[LINE_W_SIZE] - 1; ,BYTE];
	AED_PUTOUTPUT (ECHO_DESC);
	AED_POSITION (.AED_L_LASTLINE);
	END;
    END;

RETURN;

END;						! End of routine FINISH_ACE

END
ELUDOM
