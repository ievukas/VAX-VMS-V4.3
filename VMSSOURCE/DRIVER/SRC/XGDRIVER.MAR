	.TITLE	XGDRIVER - VAX/VMS DMF32 Sync Line Device Driver
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS DMF32 Sync Line Device driver
;
; ABSTRACT:
;
;	This module contains the DMF32 Sync Line driver FDT routines,
;	interrupt dispatcher, interrupt service and fork routines.
;
; AUTHOR:
;
;	Meg Dumont 1-May-81
;
; MODIFIED BY:
;
;	V03-028	MMD0325		Meg Dumont,	24-Aug-1984  16:12
;		Move setting up some of the DDCMP default fields from
;		AWAIT_CONT to ALLOC_PROT_BUFFER. This is a fix for
;		a problem found during powerfail testing.
;
;	V03-027	MMD0321		Meg Dumont,	13-Aug-1984  8:49
;		Fix to SENSEMODE_CTRL where we could get into the  situation
;		of calling DDCMP without makin sure the protocol buffer was
;		allocated. Also a fix to SHUTDOWN_LINE to clear the 
;		protocol buffer field in the UCB when the  buffer has been
;		deallocated.
;
;	V03-026	MMD0320		Meg Dumont,	1-Aug-1984  14:07
;		Fix to zero the IRP$L_MEDIA field for all the cases of a 
;		SENSEMODE CLEAR/READ count, for PSI and BISYNC. This 
;		fixes a bug where PSI systems would occasionally crash
;		if the user tried a SHOW/CLEAR CIRCUIT on a line that
;		was defined but not turned on.
;
;	V03-025	MMD0307		Meg Dumont,	5-Jul-1984  10:20
;		Add support for a timeout on transmits in progress. There
;		is a bug in the DMF32 hardware where it occasionally
;		loses clocking. If a transmit was inprogress that transmit
;		hangs. This fix incorporates a timer which times a 
;		transmit and if the transmit doesn't complete in the
;		specified time than the device is shut down and the
;		error count is incremented.
;
;		Fix to check only low byte on XMT errors.
;
;	V03-024	MMD0303		Meg Dumont,	26-Jun-1984  16:26
;		Fix to test that the protocol buffer has been allocated before
;		we try to use it in the SENSEMODE and XMIT FDT routines. Also
;		a fix for PSI the shutdown code where we didn't set up the
;		protocol buffer address before we jumped to finish the CLEAN
;		processing.
;
;	V03-023	MMD0298		Meg Dumont,	18-May-1984  10:25
;		Fix to returning quota on line startup. Add the DEV$M_AVL
;		bit to UCB$L_DEVCHAR to allow PSI and BISYNC to work.
;
;	V03-022	MMD0295		Meg Dumont,	23-Apr-1984  16:21
;		Fix to support a new interface with the protocol. This
;		interface is designed to ensure that retransmit DDCMP messages
;		will not be done so out of order.
;
;	V03-021	MMD0260		Meg Dumont,	22-Mar-1984  14:35
;		Fix so that the buffer quota for device isn't returned twice.
;
;	V03-020	MMD0255		Meg Dumont,	28-Feb-1984  17:29
;		Fixes that make the driver less suspetible to hardware errors.
;
;	V03-019	WHM0001		Bill Matthews	16-Feb-1984
;		Second part of change to control_init to support
;		multiple comm devices on one board.
;
;	V03-018	MMD0216		Meg Dumont,	6-Jan-1984  12:56
;		Fix to SENSEMODE, where we were not returning the 
;		correct value in R0. Fixes a problem which showed
;		up in the UETP.
;
;	V03-017	MMD0212		Meg Dumont,	9-Dec-1983  12:59
;		Fix to clear the XG_DS_V_XMTING bit on transmit for
;		the BISYNC mode, which allows users to transmit a
;		message after an error has occured. Change to control_init
;		to support the possiblity of mutlitple dmfs on a given
;		board.
;
;	V03-016	MMD0210		Meg Dumont,	8-Dec-1983  15:30
;		New driver on master pack with all of FT2 support including
;		BISYNC.
;
;		Fix to the Clean routine to take advantage of a microcode
;		fix where by xmts can be aborted on teh board if the enable 
;		bit is cleared. Fix the SENSEMODE fdts' to return the correct
;		status in the IOSB if only a P1 parameter was specified.
;
;	V03-015	 These two fixes pertianed to necessary FT1 fixes and are
;	V03-014	 incorporated in this driver.
;
;	V03-013	MMD0191		Meg Dumont,	13-Jun-1983  11:33
;		Took out setting the retransmit timer on the circuit. Added
;		a check so that is a buffer is being transmited a time out
;		on the line will not cause the buffer to be lost. Added
;		code to set the xmter on when a time out occurs in
;		DDCMP. This will ensure that the message gets send.
;
;	V03-012	MMD0168		Meg Dumont,	3-May-1983  12:45
;		Take out starting of the DDCMP timer from UNIT_INIT and
;		make it part on the line startup and shutdown via
;		the normal DDCMP interface. ALso include the fix where 
;		SETMODE on the controller would fail if a P2 buffer was
;		not included in the QIO.
;
;	V03-011	MMD0165		Meg Dumont,	27-Apr-1983  17:50
;		Fix to change the dropping of DTR from SHUTDOWN_CIRCUIT to
;		SHUTDOWN_LINE. Fix to RECEIVE_INTERRUPT routine to include
;		XG$M_ABORT as a non-fatal receive error.
;
;	V03-010	MMD0013		Meg Dumont,	1-Dec-1982  13:59
;		Fixes for support of HDLC
;		   a) Added support for CLEAN via QIO and enhanaced the CLEAN
;		      code in general
;		   b) Changed the use of NMA$C_LINPR_LAP to NMA$C_LINPR_LAPB
;		   c) Added check for device inactive on LAPB XMT's
;
;	V03-009	MMD0012		Meg Dumont,	13-Oct-1982  12:58
;		Fix problem doing straight QIO's over LAPB.
;
;	V03-008	MMD0011		Meg Dumont,	8-Oct-1982  18:45
;		Added LAPB support. ALso a fix for the problem running the
;		DMF32 in half duplex over real modems. Force the line to
;		wait at least 10 milliseconds before trying to transmit
;		a message after it has received control of the line.
;
;	V03-007	MMD0010		Meg Dumont,	7-Jul-1982  13:25
;		Add $VADEF to System definitions.
;
;	V03-006	MMD0009		Meg Dumont,	23-Jun-1982  13:40
;		Add check to ensure that all outstanding XMT's have been
;		sent before processing any RCV'd messages when the device
;		is running half duplex or trib modes. Fixed a bug in
;		CTS_TIMER where a message could get sent even when XMt'r
;		was active.
;
;	V03-005	MMD0008		Meg Dumont,	18-Jun-1982  17:01
;		Fix a bug in POKE_USER, and Change where the TFB address
;		gets loaded in RECEIVE_DONE
;
;	V03-004	MMD0007		Meg Dumont,	2-Jun-1982  9:57
;		Add conditional code to clear fields in UCB for ERR$$$.
;
;	V03-003	MMD0006		Meg Dumont,	25-May-1982  16:05
;		Fix to sync to IPL$_TIMER before queueing entires onto the
;		timer queue. Fix to CONTROL_INIT wrong register was being
;		used. Added some conditional code for journaling IRP's
;		and some to do extra error counting.
;
;	V03-002	MMD0005		Meg Dumont,	23-Apr-1982  14:03
;		Added a TQE which times CTS coming high for half duplex and 
;		multipoint cases. Also added a clear on UCB$L_DEVDEPEND for
;		start up on line and circuit.
;
;	V03-001	MMD0004		Meg Dumont,	23-Mar-1982  13:21
;		Fix to use executive routine to PROBE user P2 buffer. Deleted
;		work around code for micro code bugs. Fix to set transmitter
;		state to IDLE on circuit shutdown.
;
;	V03-003	MMD0003		Meg Dumont,		11-Feb-1982  10:51
;		in trib mode do not time out waiting for CTS to come back.
;		Add fields to count latency errors. Add support for 
;		retransmit timer as a line parameter.
;
;	V03-002	MMD0002		Meg Dumont,		5-Feb-1982  15:23
;		Fix bug in the Sensemode read parameters.
;
;	V03-001	MMD0001		Meg Dumont,		2-Feb-1982  13:37
;		Add a check for Maxium Receive Buffer parameter. And fixed
;		a couple problems with Clear_Counters.
;--

;
; System definitions
;
	$ACBDEF					; AST control block
	$BISYNCDEF				; Struct for BISYNC protocol buffer
	$CRBDEF					; Controller request block
	$CXBDEF					; Complex buffer block
	$DDBDEF					; Device data block
	$DDCMPDEF				; Constant def's for DDCMP
	$DEVDEF					; Device charateristics
	$DLADEF					; Driver/protocol command defs
	$DLKDEF					; Driver/protocol command defs
	$DYNDEF					; Dynamic data structures
	$DPTDEF					; Driver prologue table
	$GFDEF					; Global field definitions
	$IDBDEF					; Interrupt data block
	$IODEF					; I/O function codes
	$IPLDEF					; Interrupt priority levels
	$IRPDEF					; I/O packets
	$JIBDEF					; Job information block
	$LAPBDEF				; Lapb buffer def's
	$MFDDEF					; Message field descriptor
	$NMADEF					; Network management def's
	$PCBDEF					; Process control block
	$PRDEF					; Processor registers
	$PRVDEF					; Priv def's
	$SSDEF					; System service status
	$TFDEF					; DDCMP buffer def's
	$TQEDEF					; Timer queue element def's
	$UBADEF					; UNIBUS adapter registers
	$UCBDEF					; Unit control block
	$XGDEF					; XGDRIVER symbols
	$XMDEF					; XMDRIVER symbols
	$XMTQDEF				; Transmit Q def's
	$VADEF					; Virtual address defs
	$VECDEF					; Interrupt vector

;
; Local macros
;
	.MACRO	SETBIT	POS,BAS,?L		; Set a single bit
		BBSS	POS,BAS,L
	L:
	.ENDM	SETBIT

	.MACRO	CLRBIT	POS,BAS,?L		; Clear a single bit
		BBCC	POS,BAS,L
	L:
	.ENDM 	CLRBIT
 
	.MACRO	PARAM	TYPE,OFFSET,WIDTH,MIN,MAX,INVALID,BASE
;
; Inputs:
;
;	TYPE = Parameter type
;	OFFSET = Offset in the data structure to current value
;	WIDTH = Width of field in the data structure (B,W,L)
;	MIN = Minimum value parameter is allowed to take
;	MAX = Maximum value parameter is allowed to take
;	INVALID = Invalid flags in status word
;	BASE = Data base (LINE,TRIB)
;
	.IF BLANK TYPE
	.WORD	0
	.IF_FALSE
	$$$TYP = TYPE & PRM_M_TYPE		; Isolate type code
	.IIF NOT_BLANK	<MIN>, $$$TYP = $$$TYP!PRM_M_MIN
	.IIF NOT_BLANK	<MAX>, $$$TYP = $$$TYP!PRM_M_MAX
	.IIF NOT_BLANK	<INVALID>, $$$TYP = $$$TYP!PRM_M_INVALID
		.WORD	$$$TYP
	$$$OFF = OFFSET & OFF_M_VALUE		; Isolate offset only
	$$$WID = 0				; Set null width
	.IIF IDN <WIDTH><B>, $$$WID = <1@OFF_V_WIDTH>
	.IIF IDN <WIDTH><W>, $$$WID = <2@OFF_V_WIDTH>
	.IIF IDN <WIDTH><L>, $$$WID = <3@OFF_V_WIDTH>
		.WORD	$$$OFF!$$$WID
	.IIF NOT_BLANK	<MIN>, .WORD	MIN
	.IIF NOT_BLANK	<MAX>, .WORD	MAX
	.IIF NOT_BLANK	<INVALID>, .WORD	INVALID
	'BASE'_PRM_BUFSIZ = 'BASE'_PRM_BUFSIZ + 6
	.ENDC
	.ENDM	PARAM
 
	.MACRO	SKIP	BIT,LOC,REG,CONTEXT=W,?L	; SKIP FIELD
	BBC	#BIT,LOC,L		; Br if field not present
	TST'CONTEXT	(REG)+		; Skip next field
L:
	.ENDM	SKIP


;
; This macro translates into the CASEx instruction.  It calculates the
; "base" and "limit" parameters from the <index,displacement> list
; specfied in the 'vector' parameter.  The dispatch table is set up
; such that any unspecified index value within the bounds of the
; transfer vector is associated with a diplacement which transfers 
; control to the first location after the CASE statement, i.e., behaves
; as if the index were out of bounds.
;
; Example:
;	$DISPATCH	R0,<-			; Message type in R0
;
;		;index	displacement
;
;		<CI,	NSP$RCV_CI>,-		; Process CI message
;		<CC,	NSP$RCV_CC>,-		; Process CC message
;		<DI,	NSP$RCV_DI>,-		; Process DI message
;		<DC,	NSP$RCV_DI>,-		; Process DC message
;	>
;	BRW	NSP$RCV_ILLMSG			; Message type unknown
;
.MACRO	$DISPATCH,	INDX,VECTOR,TYPE=W,NMODE=S^#,?MN,?MX,?S,?SS,?ZZ
SS:

	.MACRO	$DSP1,$DSP1_1
		.IRP	$DSP1_2,$DSP1_1
			$DSP2	$DSP1_2
		.ENDR
	.ENDM

	.MACRO	$DSP2,$DSP2_1,$DSP2_2
		.=<$DSP2_1-MN>*2 + S
		.WORD	$DSP2_2-S
	.ENDM


	.MACRO	$BND1,$BND1_1,$BND1_2,$BND1_3
		$BND2	$BND1_1,$BND1_2
	.ENDM

	.MACRO	$BND2,$BND2_1,$BND2_2
		.IIF	$BND2_1,$BND2_2-.,	.=$BND2_2
	.ENDM

	.MACRO	$BND	$BND_1,$BND_2
		.IRP	$BND_3,<$BND_2>
			$BND1	$BND_1,$BND_3
		.ENDR
	.ENDM

	.=0
ZZ:
	$BND	GT,<VECTOR>
MX:
	$BND	LT,<VECTOR>
MN:
	.=SS

CASE'TYPE	INDX,#<MN-ZZ>,NMODE'<MX-MN>
S:
	.REPT	MX-MN+1
	.WORD	<MX-MN>*2 + 2
	.ENDR

	.=S

	$DSP1	<<VECTOR>>

	.=<MX-MN>*2 + S + 2

.ENDM

;	JNX$$$ = 1				; Define for Journalling IRP's
;	CTS$$$ = 1				; Define for CTS debug
;	ERR$$$ = 1				; Define for fatal error logging
;	DBG$$$ = 1				; Define for debug ver of driver
;	BISYNC$$$ = 1				; Define for version of driver 
						; to test out BISYNC

;
; Local symbol definitions
;
; The following symbols are defined to work with the various CASE statements
; used within this driver when different actions must be taken according
; to protocol type. These are specified so tht the DDMCP case always falls
; thru the CASE.

XG$C_PROTYPE_LAPB = 0
XG$C_PROTYPE_BISYNC = 1
XG$C_PROTYPE_DDCMP = 2

XG$C_CTS_DELTA	= 10*1000*10			; Delta for CTS timer
						; 10 milli seconds
XG$C_BISYNC_DELTA = 25*1000*10			; Delta for Bisync TQE
						; 25 milliseconds
XG$C_BPC_DEFAULT = 8
XG$C_BRG_DEFAULT = 300
XG_DEF_BUFSIZ	= 256				; Default buffer size
XG$C_SIZEOFQ	= DDCMP$C_SIZEOFQ
XG$C_HEADER	= DDCMP$C_HEADER
XG$C_LINE_PAR	= ^X<FFF3F300>			; Bits to clear in DEVDEPEND 
						; on start of line
XG$C_CIR_PAR	= ^X<FFFFF700>			; Bits to clear in DEVDEPEND
						; on start circuit
XG$C_IDLE	= 0				; State of transmitter "Off"
XG$C_XMTING	= 1 				; State of transmitter "On"
XG$C_WFCTS	= 2				; State of transmitter "Waiting
						; for clear to send"
XG$C_SWFCTS	= 4				; Short wait CTS to come high
XG$C_DRPCTS	= 6				; Drop RTS and wait for CTS to
						; go away
XG$C_WFCTS_SEC	= 6				; # of ticks to wait for CTS

DSC$A_POINTER	= 4				; Descriptor buffer address

DMF_CSR = -4					; DMF offset to Sync line CSR
INT_VEC = 4
NUM_MAP_REG = 4					; Number of mapping registers
						; to allocate
MAX_RCVS = 4					; Max number of RCVS before

;
; $QIO parameter offsets
;
P1	= 0					; Parameter 1
P2	= 4					; Parameter 2
P3	= 8					; Parameter 3
P4	= 12					; Parameter 4
P5	= 16					; Parameter 5

						; a transmit must happen
;
; Overlay of IRP
;

	$DEFINI	IRP

. = IRP$W_FUNC+1				; Overlay function word

$DEF	IRP$B_XGFUNC	.BLKB	1		; DMF driver internal func code

. = IRP$Q_STATION

$DEF IRP$W_QUOTA	.BLKW	1		; DMF driver byte quota needed

; Define driver internal function codes stored in IRP$B_XGFUNC of IRP.
; NOTE:  These are not used as bit offsets, but as values.
;
	_VIELD	XG_FC,0,<-			; Internal function codes
		<STRT_CIR>,-			; Start a tributary
		<STRT_LIN>,-			; Init the device inc UCB
		<STOP_CIR>,-			; Stop a tributary
		<STOP_LIN>,-			; Stop the device (inc stopping
		-				; the trib as well)
		<CLEAN>,-			; Abort all outstanding XMT's
		<READ_MODEM>,-			; Read modem register
		>

	$DEFEND	IRP				; End of IRP overlays

;
; XGDRIVER UCB extensions
;
	$DEFINI
			.BLKB	UCB$C_LENGTH
$DEF	UCB$L_XG_AST	.BLKL	1		; Attention AST list
$DEF	UCB$L_XG_TQE	.BLKL	15		; CTS TQE block
$DEF	UCB$A_XG_PRO_BUFFER .BLKL	1	; Place to store the address of
						; the buffer allocated for prot
$DEF	UCB$Q_XG_ATTN	.BLKQ	1		; Received message list
$DEF	UCB$Q_XG_RCVS	.BLKQ	1		; Receive I/O packet queue
$DEF	UCB$Q_XG_FREE	.BLKQ	1		; Free receive buffer queue
	UCB$L_XG_RCV_INPR =.			; Rcv buffer awaiting data for BISYNC
	UCB$W_XG_RCV_INPR_INDX =.+4		; Index into the rcv buffer
	UCB$W_XG_RCV_INIT =.+6			; Initial value of rcv byte count
$DEF	UCB$Q_XG_RCV_INPR .BLKQ 1		; Rcv buffer awaiting data
$DEF	UCB$Q_XG_POST 	.BLKQ 1			; Receive buffers to I/O comp
$DEF	UCB$Z_XG_XMT_INPR .BLKQ 1		; Inpr list for XMT's
$DEF	UCB$L_XG_XMTEND	.BLKL	1		; Timeout time for xmt inpr
$DEF	UCB$L_XG_XMT_TIMEOUT .BLKL 1		; Length of timeout (in seconds)

$DEF	UCB$W_XG_QUOTA	.BLKW	1		; Byte quota for RCV's
$DEF	UCB$B_XG_INUS	.BLKB	1		; Bit set for each slot in use
$DEF	UCB$B_XG_COUNT	.BLKB	1		; Limit the number of RCVs
						; before a transmit must happen
$DEF	UCB$Z_XG_VECTOR	.BLKL	4		; Control slot vector XMT
						; slot 0 and 1 RCV slot 2 and 3
$DEF	UCB$B_XG_XSTATE	.BLKB	1		; Transmitter state
$DEF	UCB$B_XG_WFCTS_SEC .BLKB 1		; Number of seconds to wait for
						; clear to send to come up
$DEF	UCB$W_XG_RCVCSR	.BLKW	1		; Last RCV csr value
$DEF	UCB$W_XG_XMTCSR	.BLKW	1		; Last XMT csr value
$DEF	UCB$W_XG_RCVERR	.BLKW	1		; Last RCV error value
$DEF	UCB$W_XG_XMTERR	.BLKW	1		; Last XMT error value
$DEF	UCB$W_XG_DSC	.BLKW	1		; Last data set change csr

$DEF	UCB$L_XG_PID	.BLKL	1		; Process ID
$DEF	UCB$W_XG_CHANL	.BLKW	1		; Line channel number
$DEF	UCB$W_XG_CHANC	.BLKW	1		; Circuit channel number

$DEF	UCB$Z_XG_DDCMP	.BLKL	4		; Block for setable DDCMP param
$DEF	UCB$Z_XG_SYNC	.BLKL	3		; Block for setable SYNC params
$DEF	UCB$B_XG_SETPRM				; Start of UCB/line params
$DEF	UCB$B_XG_PRO	.BLKB	1		; Protocol selection
$DEF	UCB$B_XG_DUP	.BLKB	1		; Duplex setting
$DEF	UCB$B_XG_CON	.BLKB	1		; Controller loopback
$DEF	UCB$B_XG_BFN	.BLKB	1		; Number of receive buffers
$DEF	UCB$B_XG_SPD	.BLKB	1		; Set the line speed
$DEF	UCB$B_XG_TIMEOUT .BLKB	1		; Length of CTS timeout
$DEF	UCB$B_XG_MODEM_CLR .BLKB 1		; Determines modem status after deassign
$DEF	UCB$B_XG_MNT_LOOPB .BLKB 1		; Tyoe of loopb wanted
$DEF	UCB$A_XG_FRAME_ADDR .BLKL 1		; Address of framing routine passed on BISYNC startup
	UCB$L_XG_STATE_INFO1 =.			; used by framing routine
	UCB$L_XG_STATE_INFO2 =.+4
$DEF	UCB$Q_XG_STATE_INFO .BLKQ 1		; Quadword of BISYNC state info
$DEF	UCB$B_XG_XMTCNT	.BLKB	1		; Number of outstanding XMT's
$DEF	UCB$W_XG_MFDLEN	.BLKW	1		; Size of protocol header
$DEF	UCB$B_XG_PROTYPE .BLKB	1		; Protocol type used for CASE's
$DEF	UCB$A_XG_CLEAN	.BLKL	1		; Field for CLEAN IRP address
$DEF	UCB$Z_XG_DLA_ADDR .BLKB DLA$C_ADDR_LENGTH ; Buffer to pass to protocol
						  ; various address prot needs
						  ; for DDCMP retransmit of messages

; Notice default for CHAR is Full duplex control station on a sync line

;$DEF	TF$A_TFB				; Start of trib control block
; $EQU	TF$V_STATYP	0		; 0 = Control		1 = Tributary
; $EQU	TF$M_STATYP	1
; $EQU	TF$V_POINT	1		; 0 = Point to point	1 = Multipoint
; $EQU	TF$M_POINT	2
; $EQU	TF$V_DUPLEX	2		; 0 = Full duplex	1 = Half dplx
; $EQU	TF$M_DUPLEX	4
; $EQU	TF$V_LNTYP	3		; 0 = Synchronous	1 = Async
; $EQU	TF$M_LNTYP	8
; $DEF	TF$B_CHAR	.BLKB		; Device characteristics
; $DEF	TF$B_ADDR	.BLKB		; Station address, default is 1
; $DEF	TF$B_XADDR	.BLKB		; XMT station address default is 1
; $DEF	TF$B_RADDR	.BLKB		; RCV stattion address default is 1
; $EQU	TF$V_SNAK	0		; Send a NAK
; $EQU	TF$M_SNAK	1
; $EQU	TF$V_SACK	1		; Send an ACK
; $EQU	TF$M_SACK	2
; $EQU	TF$V_SREP	2		; Send a REP
; $EQU	TF$M_SREP	4
;
;; Message exchange fields
;
; $DEF	TF$B_SFLAGS	.BLKB		; Send an ENQ message flags
; $DEF	TF$B_R	.BLKB			; Highest sequential msg RCV'd
; $DEF	TF$B_N	.BLKB			; Highest sequential msg XMT'd
; $DEF	TF$B_A	.BLKB			; Highest sequential msg ACK'd
; $DEF	TF$B_T	.BLKB			; Next data msg to XMT
; $DEF	TF$B_X	.BLKB			; Last data msg to be XMT'd
;
;; Timers
;
; $EQU	TF$V_SELECT	0		; When set then send the select flag
; $EQU	TF$M_SELECT	1
; $EQU	TF$V_TIMER	1		; If set then the timer is running
; $EQU	TF$M_TIMER	2
; $EQU	TF$V_RCVDET	2		; Set when a msg is rcv'd used to
; $EQU	TF$M_RCVDET	4		; determine if a seletion has been
;					; acknowledged in some way
; $DEF	TF$B_SELTIM	.BLKB		; Selection and timer flags
; $DEF	TF$B_REPTIM	.BLKB		; Type of reply timer
; $DEF	TF$W_REPWAI	.BLKW		; Amount of time to wait before timing
; 					; the reply timer out. This field is
; 					; only used for timing via a real clock
; $DEF	TF$B_MAXRTO	.BLKB		; Max number of reply timeouts allowed
; $DEF	TF$B_CURRTO	.BLKB		; Current number of reply timeouts
; $DEF	TF$B_MSGCNT	.BLKB		; Max number of messages allowed to
; 					; send in one selection interval
; $DEF	TF$B_MMCTR	.BLKB		; Counter of these msgs
; $DEF	TF$W_TEB	.BLKW		; Size of trib error block
; $DEF	TF$Q_XMTQ	.BLKQ		; List head for the XMTQ
; $DEF	TF$Q_CTLQ	.BLKQ		; List head for control message queue
; $DEF	TF$Q_RTOQ	.BLKQ		; List head for the RTOQ
; $DEF	TF$Q_CMPQ	.BLKQ		; List head for the CMPQ
; $DEF 	TF$Q_XMTOVF	.BLKQ		; List head for XMt over flow queue
; $DEF	TF$A_BUFPTR	.BLKL		; This field gets the value of
; 					; R8 on entry to the protocol
; $DEF	TF$A_GFB	.BLKL		; Address of the global field block
; $DEF	TF$A_DEV_TIMER  .BLKL		; Address of the device timer routine
;
; Xmit queue blocks for the control messages
;
; $DEF	TF$L_QACK	.BLKL	12	; Queue block for an ACK message
; $DEF	TF$L_QNAK	.BLKL	12	; Queue block for an NAK message
; $DEF	TF$L_QREP	.BLKL	12	; Queue block for an REP message
; $DEF	TF$L_QSTRT	.BLKL	12	; Queue block for an STRT message
; $DEF	TF$L_QSTACK	.BLKL	12	; Queue block for an STACK message
;
; $DEF	TF$L_TQE	.BLKL	15	; Timer queue entry block
;
; $DEF	TF$B_NAKRSN	.BLKB		; NAK reason code
; $DEF	TF$B_XQCNT	.BLKB		; Count of number of free slots on XMTQ
;
;; Beginning of error counters
;
; $DEF	TF$K_ERRSTRT			; Start of error counters
; $DEF	TF$W_DBRTYP	.BLKW		; NMA definitions for the field
; $DEF	TF$L_DBYTR	.BLKL		; Records bytes RCV'd by station
; $DEF	TF$W_DBXTYP	.BLKW		; NMA definitions for the field
; $DEF	TF$L_DBYTX	.BLKL		; Records bytes XMT'd by station
; $DEF	TF$W_DMRTYP	.BLKW		; NMA definitions for the field
; $DEF	TF$L_DMSGR	.BLKL		; Records msgs RCV'd by station
; $DEF	TF$W_DMXTYP	.BLKW		; NMA definitions for the field
; $DEF	TF$L_DMSGX	.BLKL		; Records msgs XMT'd by station
; $DEF	TF$W_SELTYP	.BLKW		; NMA definitions for the field
; $DEF	TF$W_SELSP	.BLKW		; Records selection interval expired
; $DEF	TF$W_DEOTYP	.BLKW		; NMA def for field
; $DEF	TF$W_DEOBC	.BLKW		; Data errors outbound bit counters
; $EQU	TF$V_OHCRC	0		; NAK's RCV'd header CRC reason code 1
; $EQU	TF$M_OHCRC	1
; $EQU	TF$V_ODCRC	1		; NAK's RCV'd data CRC reason code 2
; $EQU	TF$M_ODCRC	2
; $EQU	TF$V_OREPS	2		; NAK's RCV'd REP response rsn code 3
; $EQU	TF$M_OREPS	4
; $DEF	TF$B_DEO	.BLKB		; Data errors outbound
;	UCB$C_XG_LAPBCTR =.		; Start of LAPB error ctrs
; $DEF	TF$W_DEITYP	.BLKW		; NMA def for fields
; $DEF	TF$W_DEIBC	.BLKW		; Data error inbound error counters
; $EQU	TF$V_IHCRC	0		; NAK's XMT'd header CRC reason code 1
; $EQU	TF$M_IHCRC	1
; $EQU	TF$V_IDCRC	1		; NAK's XMT'd data CRC reason code 2
; $EQU	TF$M_IDCRC	2
; $EQU	TF$V_IREPS	2		; NAK's XMT'd REP response rsn code 3
; $EQU	TF$M_IREPS	4
; $DEF	TF$B_DEI	.BLKB		; Data error inbound
;	UCB$C_XG_LAPBCTR_LEN =.-UCB$C_XG_LAPBCTR ; Size of error ctrs
; $DEF	TF$W_LBETYP	.BLKW		; NMA definition for the field
; $DEF	TF$W_LBEBC	.BLKW		; Local buffer error bit counters
; $EQU	TF$V_LBUF_NAVL	0		; Local buffer unavl SNAK set rsn 8
; $EQU	TF$M_LBUF_NAVL	1
; $EQU	TF$V_LBUF_SML	1		; Local bfr too small SNAK set rsn 16
; $EQU	TF$M_LBUF_SML	2
;; $DEF	TF$B_LBE	.BLKB		; Local buffer error
; $DEF	TF$W_RBETYP	.BLKW		; NMA definition for the field
; $DEF	TF$W_RBEBC	.BLKW		; Remote buffer error bit counters
; $EQU	TF$V_RBUF_NAVL	0		; Remote buffer unavl NAK RCV'd rsn 8
; $EQU	TF$M_RBUF_NAVL	1
; $EQU	TF$V_RBUF_SML	1		; Remote bfr too small NAK RCV'd rsn 16
; $EQU	TF$M_RBUF_SML	2
; $DEF	TF$B_RBE	.BLKB		; Remote buffer error
; $DEF	TF$W_STOTYP	.BLKW		; NMA definition for the fields
; $DEF	TF$W_STOBC	.BLKW		; Selection timeout bit counters
; $EQU	TF$V_NOREP_SEL	0		; When no attempt to respond was made
; $EQU	TF$M_NOREP_SEL	1
; $EQU	TF$V_INCREP_SEL	1		; When attempt is made but the timeout
; $EQU	TF$M_INCREP_SEL	2
; $DEF	TF$B_STO	.BLKB		; Selection timeout
; $DEF	TF$W_LRTOTYP	.BLKW		; NMA definition for field
;; $DEF	TF$B_LRTO	.BLKB		; Records setting of SREP
; $DEF	TF$W_RRTOTYP	.BLKW		; NMA definition for field
; $DEF	TF$B_RRTO	.BLKB		; Records setting SACK when REP RCV'd
; 					; with NUMB = R
; $DEF	TF$W_THRES	.BLKW		; Threshold errors
; 					; Bits 0-2 RCV threshold errors
; 					; Bits 3-5 XMT threshold errors
; 					; Bits 6-8 Selection threshold errors
; 			.BLKB	1	; Reserved
;$DEF	GF$A_GFB			; Start of global control block
; $DEF	GF$B_STATE	.BLKB		; State of protocol
; $EQU	GF$V_TIMER_RUNNING 0		; 0 = Timer not running 
; $EQU	GF$M_TIMER_RUNNING 1		; 1 = timmer running
; $DEF	GF$B_TIMER_STATE .BLKB	1	; State of DDCMP timer
; $EQU	GF$V_CRC	0		; 0 = Device does CRC checking
; $EQU	GF$M_CRC	1
; $DEF	GF$B_DRVCHR	.BLKB		; Device charateristics
; $DEF	GF$W_SELWAI	.BLKW		; Amount of time to wait before timing
; 					; the selection interval out
; $DEF	GF$W_NEXTCNT	.BLKW	1	; Count on which interval to deselect
;					; the station when running in trib mode
; $DEF	GF$B_MAXSEL	.BLKB		; Max number of selection intervals
; $DEF	GF$B_CURSEL	.BLKB		; Current number of selection intervals
; $DEF	GF$B_FIPL	.BLKB	1	; Fork IPL for DDCMP
; $DEF	GF$B_DIPL	.BLKB	1	; Device IPL for DDCMP
; $DEF	GF$W_GEB	.BLKW	1	; Size of global error block
; $DEF	GF$L_SELEND	.BLKL	1	; Time the selection int expires
; $DEF	GF$L_TQE_STS	.BLKL	1	; Timeout return status
; $DEF	GF$B_STRTIM	.BLKB		; Amount of time to wait before setting
; 					; station streaming flag
; $DEF	GF$B_BABTIM	.BLKB		; Amount of time to wait before setting
; 					; station babbling flag
; $DEF	GF$L_STRTMR	.BLKL		; Stream timer
; $DEF	GF$L_BABTMR	.BLKL		; Babbling timer
;
;; Station error counters
;
; $DEF	GF$K_ERRSRT			; Start of global error counters
;; $DEF	GF$W_LSETYP	.BLKW		; NMA definition for field
; $DEF	GF$W_LSE_BCTRS	.BLKW		; Local station error bit counters
; $EQU	GF$V_LRCV_OVR	0		; Receive overrun SNAK set reason 9
; $EQU	GF$M_LRCV_OVR	1
; $EQU	GF$V_LNRCV_OVR	1		; Receive overrun SNAK not set
; $EQU	GF$M_LNRCV_OVR	2
; $EQU	GF$V_LXMT_UNDER	2		; XMT underrun
; $EQU	GF$M_LXMT_UNDER	4
; $EQU	GF$V_LMSGHDR_FMT	3	; NAK RCV'd reason code 17
; $EQU	GF$M_LMSGHDR_FMT	8
; $DEF	GF$B_LSE	.BLKB		; Local station errors
;
; $DEF	GF$W_RSETYP	.BLKW		; NMA definition for field
; $DEF	GF$W_RSE_BCTRS	.BLKW		; Remote station error bit counters
; $EQU	GF$V_RRCV_OVR	0		; NAK's RCV'd reason code 9
; $EQU	GF$M_RRCV_OVR	1
; $EQU	GF$V_RMHDR_FMT	1		; SNAK set reason code 17
; $EQU	GF$M_RMHDR_FMT	2
; $EQU	GF$V_SADR_ERR	2		; Message RCV'd by an unselected trib
; $EQU	GF$M_SADR_ERR	4
; $EQU	GF$V_STR_TRIB	3		; Streaming trib
; $EQU	GF$M_STR_TRIB	8
; $DEF	GF$B_RSE	.BLKB		; Remote station errors
; $DEF	GF$B_GH_CRC	.BLKB		; Global header CRC error
; $DEF	GF$B_MDF_CRC	.BLKB		; Maintenance data field CRC error
;			.BLKB		; spare
;
	.IF	DF ERR$$$
$def	ucb$w_xg_xmtlat	.blkw	1		; count on XMT latency err's
$def	ucb$w_xg_rcvlat	.blkw	1		; count on RCV latency err's
$def	ucb$w_xg_xmtnxm	.blkw	1		; count on XMT nxm err's
$def	ucb$w_xg_rcvnxm	.blkw	1		; count on RCV nxm err's
$def	ucb$w_xg_strt	.blkw	1		; count on START rcv'd errors
$def	ucb$w_xg_prst	.blkw	1		; count on perstitant errors
$def	ucb$w_xg_disc	.blkw	1		; count on modem disconnet err
			.blkw	1		; reserved
	.ENDC	;DF ERR$$$

	.IF	DF CTS$$$
	cts_size = 32				; set size of buffer to keep
			.blkb	3		; spare
$def	ucb$b_cts_last	.blkb	1		; set last used location
$def	ucb$b_cts_buf	.blkb	cts_size	; set size of buffer
	ucb$c_cts_len	=.-ucb$b_cts_last	; set length
	.ENDC					; DF CTS$$$ end

	.IF	DF JNX$$$
		.blkb	3
	jnx_size = 32
$def	ucb$b_last	.blkb	1
$def	ucb$l_buffer	.blkl	jnx_size
	ucb$c_last_len = .-ucb$b_last
	.ENDC	;DF JNX$$$

	UCB$C_XG_LENGTH	=.		; Size of XGDRIVER UCB


;
; Device status bits
;

.=0
	_VIELD	XG_DS,0,<-			; UCB$W_DEVSTS bits
		<XMTING,,M>,-			; Device XMTing if 0
		<RCVING,,M>,-			; Device RCVing if 0
		<INITED,,M>,-			; Unit initialized
		<FORK_PEND,,M>,-		; Fork pending
		<RCVPS,,M>,-			; On interrupt if bit is 0
		<LOADRPS,,M>,-			; Which RCV buff to load next
		<RCV_DONEP,,M>,-		; Bit set when pri buff loaded
		<RCV_DONES,,M>,-		; Bit set when sec buff loaded
		<XMTPS,,M>,-			; comp prim else comp secondary
		<LOADXPS,,M>,-			; Which XMT buff to load next
		<XMT_DONEP,,M>,-		; Bit set when pri buff loaded
		<XMT_DONES,,M>,-		; Bit set when sec buff loaded
		<RCVENB,,M>,-			; Set to enable the board
		<XMTENB,,M>,-			; to rcv or xmt 
		<CTSTQE_RUN,,M>,-		; Set when CTS TQE is queued
		<CLEAN,,M>,-			; If XMT INPR when CLEAN req
		>				; set saying abort after XMT'd

;
; Receive buffer definition
;
; This structure must be the same size as the CXB
;
	$DEFINI	RCV
. = 0
$DEF	RCV_L_LINK	.BLKL	2		; Forward and backward links
$DEF	RCV_W_BLKSIZE	.BLKW	1		; Total block size
$DEF	RCV_B_BLKTYPE	.BLKB	1		; Block type
$DEF	RCV_B_FIPL	.BLKB	1		; Fork IPL
$DEF	RCV_W_MSGSIZ	.BLKW	1		; Size of message received
$DEF	RCV_W_ERROR	.BLKW	1		; Error status
$DEF	RCV_L_BACC	.BLKL	1		; Buffer addr / char count
$DEF	RCV_B_SLT	.BLKB	1		; Receive slot number used

$DEF	RCV_CXB_SPARE	.BLKB	CXB$K_HEADER-XG$C_HEADER-.
						; Spare bytes to allow for CXB
$DEF	RCV_Z_HEADER	.BLKB	XG$C_HEADER	; Size in bytes of msg header
$DEF	RCV_T_DATA				; Receive data

	ASSUME	RCV_Z_HEADER+6 EQ CXB$K_HEADER
	ASSUME 	RCV_T_DATA GE CXB$K_HEADER

;
; P2 buffer header definition
;
	$DEFINI	P2B
.=0
$DEF	P2B_L_POINTER	.BLKL	1	; Pointer to start of data
$DEF	P2B_L_BUFFER	.BLKL	1	; Address of user's data buffer
$DEF	P2B_W_SIZE	.BLKW	1	; Size of P2 buffer
$DEF	P2B_B_TYPE	.BLKB	1	; Type of structure
$DEF	P2B_B_SPARE	.BLKB	1	; Spare byte
$DEF	P2B_C_LENGTH			; Size of P2 buffer header
$DEF	P2B_T_DATA			; Start of data
 
	$DEFEND	P2B



	.SBTTL	Standard Driver Tables
;
; Driver Prologue Table
;
	DPTAB	-				;
		END=DRIVER_END,-		; End of driver
		ADAPTER=UBA,-			; UNIBUS device
		UCBSIZE=UCB$C_XG_LENGTH,-	; UCB size
		NAME=XGDRIVER			; Driver name

	DPT_STORE INIT				; Initialization data
	DPT_STORE UCB,UCB$B_FIPL,B,8		; Fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,21		; Device IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-	; Device characteristics
		DEV$M_AVL!DEV$M_NET!DEV$M_IDV!DEV$M_ODV>
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_SCOM ; Device class
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_DMF32 ; Device type
	DPT_STORE UCB,UCB$W_DEVSTS,W,0		; Internal status

	DPT_STORE REINIT			; Init data also for reload
	DPT_STORE DDB,DDB$L_DDT,D,XG$DDT	; Driver dispatch table 
	DPT_STORE CRB,CRB$L_INTD+4,D,RECEIVE_INTR ; RCV intr service routine
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,CONTROL_INIT ; Controller init
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,UNIT_INIT ; Unit init routine
	DPT_STORE CRB,CRB$L_INTD2+4,D,TRANSMIT_INTR ; Transmit interrupt service
	DPT_STORE END

	.PSECT	$$$115_DRIVER,LONG
	
;
; Driver Dispatch Table
;
	DDTAB	DEVNAM=XG,-			; Device name
		START=STARTIO,-			; Start I/O routine
		FUNCTB=FUNCTABLE,-		; Function decision table
		CANCEL=CANCEL,-			; Cancel I/O routine
		REGDMP=REGDUMP,-		; Register dump routine
		DIAGBF=<36+12>,-		; Diagnostic buffer size
		ALTSTART=ALT_ENTRY		; Alternate entry routine
;
; Function Decision Table
;
FUNCTABLE:
	FUNCTAB,-				; Legal functions
		<WRITEVBLK,WRITELBLK,WRITEPBLK,-; Transmit functions
		 READVBLK,READLBLK,READPBLK,-	; Receive functions
		 SETMODE,SENSEMODE,SETCHAR,-	; Set mode functions
		 CLEAN>				; Clean for LAPB
	FUNCTAB,-				; Buffered I/O functions
		<WRITEVBLK,WRITELBLK,WRITEPBLK,-; Transmit functions
		 READLBLK,READPBLK,READVBLK,-	;
		 SETMODE,SENSEMODE,SETCHAR,-	; Set mode functions
		 CLEAN>				; Clean for LAPB

	.IF	DF JNX$$$
	functab	fillbuffer,-			; Buffered I/O functions
		<writevblk,writelblk,writepblk,-; Transmit functions
		 readvblk,readlblk,readpblk,-	; Receive functions
		 setmode,sensemode,setchar,-	; Set mode functions
		 clean>				; Clean for LAPB
	.ENDC	;DF JNX$$$

	FUNCTAB	XMITFDT,-			; Transmit function dispatcher
		<WRITELBLK,WRITEPBLK,WRITEVBLK>	;
	FUNCTAB	RCVFDT,-			; Receive function dispatcher
		<READLBLK,READPBLK,READVBLK>	;
	FUNCTAB	SETMODEFDT,-			; FDT for set mode and set char
		<SETMODE,SETCHAR>		; 
	FUNCTAB	SENSEMODEFDT,-			; FDT sensemode routine
		<SENSEMODE>
	FUNCTAB	CLEANFDT,-			; FDT clean routine
		<CLEAN>


	.SBTTL	P2 buffer verification tables
 
;
; Define P2 buffer verification offsets
;
	$DEFINI	PARAM
 
	_VIELD	PRM,0,<-			; Parameter bits and sizes
		<TYPE,12,M>,-			; Parameter type
		<MIN,1,M>,-			; Parameter minimum value
		<MAX,1,M>,-			; Parameter maximum value
		<INVALID,1,M>,-			; Parameter invalid flags
		>
 
	_VIELD	OFF,0,<-			; Offset word fields
		<VALUE,14,M>,-			; Offset value
		<WIDTH,2,M>,-			; Size of field in structure
		>
 
	$DEFEND	PARAM
 
;
; Define UCB (line) parameters
;
LINE_PRM_BUFSIZ	= 0				; Line parameter buffer size
LINE_PARAM:					; Start of line parameters

	PARAM	NMA$C_PCLI_PRO,-		; Protocol selection
		OFFSET=UCB$B_XG_PRO,WIDTH=B,-
		MAX=NMA$C_LINPR_BSY,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE
 
	PARAM	NMA$C_PCLI_DUP,-		; Duplex mode
		OFFSET=UCB$B_XG_DUP,WIDTH=B,-
		MAX=NMA$C_DPX_HAL,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_CON,-		; Controller mode
		OFFSET=UCB$B_XG_CON,WIDTH=B,-
		MAX=NMA$C_LINCN_LOO,-
		INVALID=XG_DS_M_INITED,-	; Device can't be On
		BASE=LINE
 
	PARAM	NMA$C_PCLI_BFN,-		; Number of receives
		OFFSET=UCB$B_XG_BFN,WIDTH=B,-
		MIN=1,MAX=255,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE
 
	PARAM	NMA$C_PCLI_BUS,-		; Buffer size
		OFFSET=UCB$W_DEVBUFSIZ,WIDTH=W,-
		MIN=1,MAX=16383,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_RTT,-		; Retransmit timer
		OFFSET=UCB$Z_XG_DDCMP+DLK$W_REPWAIT,-
		WIDTH=W,-
		MIN=50,-
		BASE=LINE

	PARAM	NMA$C_PCLI_FRA,-		; Address of BISYNC 
		OFFSET=UCB$A_XG_FRAME_ADDR,-	; framing routine
		WIDTH=L,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_STI1,-		; BISYNC state info 1ST
		OFFSET=UCB$L_XG_STATE_INFO1,-	; longword
		WIDTH=L,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_STI2,-		; BISYNC state info 2ND
		OFFSET=UCB$L_XG_STATE_INFO2,-	; longword
		WIDTH=L,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_TMO,-		; Timeout value
		OFFSET=UCB$B_XG_TIMEOUT,-
		WIDTH=B,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_MCL,-		; Drop DTR on deassign
		OFFSET=UCB$B_XG_MODEM_CLR,-	; except last deassign, where
		WIDTH=B,-			; DTR is always droped
		MIN=0,-
		MAX=1,-
		INVALID=XG_DS_M_INITED,-	; Device can't be ON
		BASE=LINE

; Define DMF32 specific parameters

	PARAM	NMA$C_PCLI_SYC,-		; Value for the sync char
		OFFSET=UCB$Z_XG_SYNC+XG$B_SYNC_REG,-
		WIDTH=B,-
		INVALID=XG_DS_M_INITED,-
		BASE=LINE

	PARAM	NMA$C_PCLI_NMS,-		; Number of sync char to send
		OFFSET=UCB$Z_XG_SYNC+XG$B_NUM_SYNC,-
		WIDTH=B,-
		INVALID=XG_DS_M_INITED,-
		BASE=LINE

	PARAM	NMA$C_PCLI_BPC,-		; Number of bits per char
		OFFSET=UCB$Z_XG_SYNC+XG$B_BPC,-
		WIDTH=B,-
		MIN=5,-
		MAX=8,-
		INVALID=XG_DS_M_INITED,-
		BASE=LINE

	PARAM	NMA$C_PCLI_MNTL,-		; Maintenance loopback mode
		OFFSET=UCB$Z_XG_SYNC+XG$B_MNTLOOP,- ; for devices which support 
		WIDTH=B,-			; several different loopback
		MAX=NMA$C_PCLI_INTL3,-		; modes
		INVALID=XG_DS_M_INITED,-
		BASE=LINE

	PARAM					; End of table
;
; Define Trib parameters
;
TRIB_PRM_BUFSIZ  = 0				; Trib parameter buffer size
TRIB_PARAM:					; Start of trib parameters
 
	PARAM	NMA$C_PCCI_TRI,-		; Trib address
		OFFSET=DLK$B_TRIB,WIDTH=B,-
		MIN=1,-
		INVALID=XM$M_STS_ACTIVE,-	; Trib can't be established
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_MTR,-		; Max number of messages sent
		OFFSET=DLK$B_MSGCNT,WIDTH=B,-	; in a selection interval
		MIN=1,-
		MAX=100,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_MST,-		; Maintenance state
		OFFSET=DLK$B_MAINT,WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		BASE=TRIB

	PARAM	NMA$C_PCCI_MRB,-		; Maxium receive buffers
		OFFSET=DLK$B_MRB,WIDTH=B,-
		MIN=1,-
		INVALID=XM$M_STS_ACTIVE,-
		BASE=TRIB

	PARAM					; End of trib tables



;
; DEFAULT TRIBUTARY PARAMETERS for DDCMP
;
DEF_TRIB_PARAM::
	ASSUME	DLK$B_MSGCNT EQ DLK$B_TRIB+1
	ASSUME	DLK$B_MAXREP EQ DLK$B_MSGCNT+1
	ASSUME	DLK$B_MAXSEL EQ DLK$B_MAXREP+1
	ASSUME	DLK$W_REPWAIT EQ DLK$B_MAXSEL+1
	ASSUME	DLK$W_SELWAIT EQ DLK$W_REPWAIT+2
	ASSUME	DLK$B_MAINT EQ DLK$W_SELWAIT+2
	ASSUME	DLK$B_MRB EQ DLK$B_MAINT+1
	.BYTE	1				; Default Trib address
	.BYTE	4				; Max nmb of msgs sent / select
	.BYTE	4				; Max nmb of sel intls allowed
	.BYTE	3				; Max times to reXMT a msg
	.WORD	3000				; Reply timeout timer
	.WORD	3000				; Selection timer in sec
	.BYTE	NMA$C_STATE_OFF			; Default is no maint mode
	.BYTE	255				; Default to unlimited rcv buff
	DEF_TRIB_PARAMSZ = .-DEF_TRIB_PARAM
;
; Default line parameter values
;
DEF_LINE_PARAM::
	ASSUME	UCB$B_XG_PRO EQ UCB$B_XG_SETPRM
	ASSUME	UCB$B_XG_DUP EQ UCB$B_XG_PRO+1
	ASSUME	UCB$B_XG_CON EQ UCB$B_XG_DUP+1
	ASSUME	UCB$B_XG_BFN EQ UCB$B_XG_CON+1
	ASSUME	UCB$B_XG_SPD EQ UCB$B_XG_BFN+1
	ASSUME	UCB$B_XG_TIMEOUT EQ UCB$B_XG_SPD+1
	ASSUME	UCB$B_XG_MODEM_CLR EQ UCB$B_XG_TIMEOUT+1
	ASSUME	UCB$B_XG_MNT_LOOPB EQ UCB$B_XG_MODEM_CLR+1
	ASSUME	UCB$A_XG_FRAME_ADDR EQ UCB$B_XG_MNT_LOOPB+1
	ASSUME	UCB$Q_XG_STATE_INFO EQ UCB$A_XG_FRAME_ADDR+4
	.BYTE	NMA$C_LINPR_POI			; Protocol is point-point
	.BYTE	NMA$C_DPX_FUL			; Duplex is full
	.BYTE	NMA$C_LINCN_NOR			; Controller mode is normal
	.BYTE	1				; Number of receive buffers
;& Currently not implemented
	.BYTE	0				; Set default line speed
	.BYTE	XG$C_WFCTS_SEC			; Timeout on CTS
	.BYTE	0				; Modem status after deassign
	.BYTE	0				; Type of loopb
	.LONG	0				; Address of BISYNC framing routine
	.QUAD	0				; BISYNC state info


	DEF_LINE_PARAMSZ = .-DEF_LINE_PARAM

;
; Default device parameters for DDCMP
;
DEF_SYNC_PARAM::
	ASSUME	XG$B_PROTOCOL EQ XG$B_ERR_CNTRL+1
	ASSUME	XG$B_TX_BPC EQ XG$B_PROTOCOL+1
	ASSUME	XG$B_RX_BPC EQ XG$B_TX_BPC+1
	ASSUME	XG$B_BAUD EQ XG$B_RX_BPC+1
	ASSUME	XG$B_NUM_SYNC EQ XG$B_BAUD+1
	ASSUME	XG$B_SYNC_REG EQ XG$B_NUM_SYNC+1
	ASSUME	XG$B_ICLK EQ XG$B_SYNC_REG+1
	.BYTE	XG$C_ERR_CRC16			; Error control CRC16
	.BYTE	XG$C_PRO_DDCMP			; Protocol is DDCMP
	.BYTE	XG$C_BPC_8			; Bits per char - 8
	.BYTE	XG$C_BPC_8			; Bits per char - 8
	.BYTE	XG$C_BRG_19200			; Line speed 19.2 kbs
	.BYTE	8				; Number of syncs to send
	.BYTE	XG$C_SYNC_DDCMP			; Sync character
	.BYTE	XG$C_INTCLK_OFF			; No internal clock
	DEF_SYNC_PARAMSZ = .-DEF_SYNC_PARAM

;
; Default device params for LAPB
;
DEF_LAPB_PARAM::
	.BYTE	XG$C_ERR_CRC1			; Err control CRC-CCITT to 1's
	.BYTE	XG$C_PRO_HDLC			; Set protocol
	.BYTE	XG$C_BPC_8			; Set BPC rcv
	.BYTE	XG$C_BPC_8			; Set BPC xmt
	.BYTE	XG$C_BRG_19200			; Line speed 19.2 kbs
	.BYTE	0				; No syncs to send
	.BYTE	XG$C_SYNC_HDLC			; no sync character
	.BYTE	XG$C_INTCLK_OFF			; Set internal clock off
	DEF_LAPB_PARAMSZ = .-DEF_LAPB_PARAM
;
; Default device parameters for BISYNC
;
DEF_BISYNC_PARAM::
	.BYTE	XG$C_NOCON			; No error control
	.BYTE	XG$C_GENBYTE			; Set protocol type
	.BYTE	XG$C_BPC_8			; Set default rcv bits per char
	.BYTE	XG$C_BPC_8			; Set default xmt bits per char
	.BYTE	XG$C_BRG_19200			; Set default line speed
	.BYTE	8				; Set default number of syncs
	.BYTE	XG$C_SYNC_BISYNC		; Set sync char
	.BYTE	XG$C_INTCLK_OFF			; Set no internal clock
	DEF_BISYNC_PARAMSZ =.-DEF_BISYNC_PARAM


	.SBTTL	CONTROL_INIT - Initialize Sync line device
;++
; CONTROL_INIT - Initialize Sync line unit
;
; FUNCTINAL DESCRIPTION:
;
; This routine is entered at SYSTARTUP to initialize the sync line. The action
; is to set the interrupt vector on the combo.
;
; INPUTS:
;	R4 = Address of device CSR
;	R5 = Address of device IDB
;	R6 = Address of device DDB
;	R8 = Address of device CRB
;
; OUTPUTS:
;	R4,R5,R8 are preserved
;--
CONTROL_INIT:

; Set interrupt vector in controller

	CVTBL	IDB$B_COMBO_CSR_OFFSET(R5),R0
	SUBB3	IDB$B_COMBO_VECTOR_OFFSET(R5),-
		IDB$B_VECTOR(R5),(R4)[R0]
	RSB


	.SBTTL	UNIT_INIT - Initialize the device unit
;++
; UNIT_INIT - Initialize the device unit
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called when the driver is loaded and during powerfailure
; recovery.  It sets the unit status to ONLINE.  Also, if called during
; powerfail recovery, it shuts down the device.
;
; INPUTS:
;
;	R4 = Address of the device CSR
;	R5 = UCB address
;
; OUTPUTS:
;
;	R5 preserved
;--
UNIT_INIT:					; Initialize the unit
	.IF	DF JNX$$$
	pushr	#^m<r0,r1,r2,r3,r4,r5>
	movc5	#0,ucb$l_buffer(r5),#0,#ucb$c_last_len,ucb$l_buffer(r5)
	popr	#^m<r0,r1,r2,r3,r4,r5>
	.ENDC	;DF JNX$$$

	.IF	DF DBG$$$
	jsb	g^ini$brk
	.ENDC	;DF DBG$$$

	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$	; Br if not powerfail recovery
	BBC	#XM$V_STS_ACTIVE,-		; Br if not previously active
		UCB$L_DEVDEPEND(R5),10$		;
	PUSHR	#^M<R0,R1,R2,R3>		; Save all registers
	MOVZWL	#SS$_POWERFAIL,R4		; Indicate powerfail
	BSBW	SCHED_FORK
	POPR	#^M<R0,R1,R2,R3>
	RSB

5$:	BUG_CHECK NOBUFPCKT,FATAL

;
; This driver makes the assumption that IPL$_SYNC, IPL$_TIMER and the drivers
; fork IPL are all equal. If any of these change the integrity of the driver
; can not be assured. THIS DRIVER WILL NOT WORK ON PRE VERSION 4 SYSTEMS.
;

	ASSUME IPL$_SYNCH EQ IPL$_TIMER

;
; Also ASSUME that the following fields are equal, else the driver will get
; very confused as to where transmits and completes are coming from when
; running in any protocol mode other than DDCMP.

	ASSUME	LAPB$Q_XMTQ EQ TF$Q_CTLQ
	ASSUME	LAPB$Q_CLEANQ EQ TF$Q_CMPQ
	ASSUME	LAPB$Q_BLANK EQ TF$Q_XMTQ
	ASSUME	LAPB$B_XQCNT EQ TF$B_XQCNT
	ASSUME	LAPB$Q_CLEANQ EQ BISYNC$Q_CLEANQ
	ASSUME	BISYNC$Q_BLANK EQ TF$Q_CTLQ
	ASSUME	BISYNC$Q_CLEANQ EQ TF$Q_CMPQ
	ASSUME	BISYNC$Q_XMTQ EQ TF$Q_XMTQ
	ASSUME	BISYNC$B_XQCNT EQ TF$B_XQCNT
;
; We must also be sure that SYNCH and the drivers FIPL are the same. If this
; changes the integrity of the driver can not be assured with out some
; major changes.
;
10$:	CMPB 	#IPL$_SYNCH,UCB$B_FIPL(R5)	; If the IPLs are not equal then
	BNEQ	5$				; cause a fatal bugcheck 
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>

;
; Set queue headers
;
	MOVAB	UCB$Q_XG_RCVS(R5),UCB$Q_XG_RCVS(R5)	; Receive list
	MOVAB	UCB$Q_XG_RCVS(R5),UCB$Q_XG_RCVS+4(R5)
	MOVAB	UCB$Q_XG_FREE(R5),UCB$Q_XG_FREE(R5)	; Free buffer list
	MOVAB	UCB$Q_XG_FREE(R5),UCB$Q_XG_FREE+4(R5)
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR(R5) ; Rcv inpr list
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR+4(R5)
	MOVAB	UCB$Q_XG_POST(R5),UCB$Q_XG_POST(R5) 	; Post list
	MOVAB	UCB$Q_XG_POST(R5),UCB$Q_XG_POST+4(R5)
	MOVAB	UCB$Q_XG_ATTN(R5),UCB$Q_XG_ATTN(R5)	; Full buffer list
	MOVAB	UCB$Q_XG_ATTN(R5),UCB$Q_XG_ATTN+4(R5)
	CLRQ	UCB$Z_XG_XMT_INPR(R5)
	CLRL	UCB$L_XG_AST(R5)			; Attention AST listhead

	.IF	DF ERR$$$
	ASSUME	UCB$W_XG_RCVLAT EQ UCB$W_XG_XMTLAT+2
	CLRL	UCB$W_XG_XMTLAT(R5)		; Set no errors on device
	.ENDC	;DF ERR$$$

	BSBB	INIT_PARAM			; Set all default values in device
	MOVAL	UCB$L_XG_TQE(R5),R4		; Set the CTS TQE address
	MOVQ	#XG$C_CTS_DELTA,TQE$Q_DELTA(R4)	; Set the delta time
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; Set software status ONLINE
	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>
	RSB


	.SBTTL	INIT_PARAM,  Initialize parameters
 
;++
; INIT_PARAM - Initialize parameters
;
; Functional description:
;
; This routine is called to reset parameters when the unit is initialized.
;
; Inputs:
;
;	R5 = UCB address
;
;	IRP = FIPL or higher
;
; Outputs:
;
;	R0-R2 are destroyed.
;
;--
 
INIT_PARAM:					; Initialize the UCB
	MOVW	#XG_DEF_BUFSIZ,-		; Set default buffer size
		UCB$W_DEVBUFSIZ(R5)
	MOVZWL	#DEF_LINE_PARAMSZ,R0		; Set size of defaults in bytes
	MOVAB	DEF_LINE_PARAM,R1		; Set address of defaults
	MOVAB	UCB$B_XG_SETPRM(R5),R2		; Set address of parameters
10$:	MOVB	(R1)+,(R2)+			; Set next default
	SOBGTR	R0,10$				; Loop on all parameters
	MOVZWL	#DEF_TRIB_PARAMSZ,R0		; Set size of defaults in bytes
	MOVAB	DEF_TRIB_PARAM,R1		; Set address of defaults
	MOVAB	UCB$Z_XG_DDCMP(R5),R2		; Set address of parameters
20$:	MOVB	(R1)+,(R2)+			; Set next default
	SOBGTR	R0,20$				; Loop on all parameters
	MOVZWL	#DEF_SYNC_PARAMSZ,R0		; Set size of defaults in bytes
	MOVAB	DEF_SYNC_PARAM,R1		; Set address of defaults
	MOVAB	UCB$Z_XG_SYNC(R5),R2		; Set address of parameters
30$:	MOVB	(R1)+,(R2)+			; Set next default
	SOBGTR	R0,30$				; Loop on all parameters
	RSB

	.IF	DF JNX$$$
fillbuffer:
	movzbl	ucb$b_last(r5),r0
	movl	r3,ucb$l_buffer(r5)[r0]
	movq	#0,irp$l_media(r3)
	incl	r0
	bicl	#^c<jnx_size-1>,r0
	movb	r0,ucb$b_last(r5)
	rsb
	.ENDC	;DF JNX$$$


	.SBTTL XMITFDT - Transmit I/O FDT routine
;++
; XMITFDT - Transmit I/O FDT routine
;
; FUNCTIONAL DESCRIPTION:
;
; This routine allocates a system buffer for the QIO. Then calls the
; common FDT routine give the buffer to DDCMP.
;
; INPUTS:
;
;	R3 = I/O packet address
;	R4 = Current PCB address
;	R5 = UCB address
;	R6 = CCB address
;
; OUTPUTS:
;
;	R3,R4,R5,R6,R7,R8,R9 are preserved
;
;--
XMITFDT:					; Transmit FDT routine
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9>
	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; BISYNC?
	BNEQ	4$				; Branch if not
	MOVL	P4(AP),R0			; See if any state info was specifed
	BEQL	4$				; IF EQL then none
	MOVL	#8,R1				; Set size of buffer to check
	JSB	G^EXE$WRITECHK			; Check for write access
	MOVQ	(R0),R0				; Mov the info into R0 and R1
	DSBINT	UCB$B_FIPL(R5)			; SYnc to gain access to UCB
	MOVQ	R0,UCB$Q_XG_STATE_INFO(R5)	; Move the info into the UCB
	ENBINT					; Resync to lower IPL
4$:	MOVL	P1(AP),R7			; Get address of buffer
	MOVL	P2(AP),R9			; Get the size of buffer
	BEQL	10$				; If EQL then size is zero
	CMPW	R9,UCB$W_DEVBUFSIZ(R5)		; If GTR then report as error
	BGTRU	10$
	MOVL	R7,R0				; Set up R0 and R1 for
	MOVL	R9,R1				; write access check
	JSB	G^EXE$WRITECHK			; Check the acc of users buffer
	ADDL3	#XMTQ$K_LENGTH,R9,R1		; Get length of buffer to alloc
	MOVL	R3,R6				; Save the IRP address
	JSB	G^EXE$BUFFRQUOTA		; Check quota
	BLBC	R0,20$				; If LBC not enough quota
	JSB	G^EXE$ALLOCBUF			; Allocated the buffer
	BLBC	R0,20$				; If LBC not buffer allocated
	MOVL	R6,R3				; Retreive the IRP
	MOVL	R2,R8				; Get buffer address in R8
	MOVL	PCB$L_JIB(R4),R0		; Get the JIB address
	SUBL2	R1,JIB$L_BYTCNT(R0)		; Adjust buffered I/O
	MOVW	R1,IRP$W_BOFF(R3)		; Save byte offset
	MOVL	R2,IRP$L_SVAPTE(R3)		; Save system PTE
	CLRB	XMTQ$B_FLAG(R8)			; Clr bits, not "Internal" IRP
	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		30$,-				; LAPB
		40$,-				; BISYNC
		>				; Fall thru on DDCMP
5$:	BSBW	COP_BUFF			; Branch to copy into my buff
	SETIPL	UCB$B_FIPL(R5)			; Sync to FIPL
	BSBB	COM_XMITFDT			; Branch to common processing
	BLBC	R0,20$				; If BC then error
8$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>
	JMP	G^EXE$QIORETURN

10$:	MOVZWL	S^#SS$_BADPARAM,R0		; Set status for abort
20$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>
	JMP	G^EXE$ABORTIO

30$:	BSBW	COM_XMITLAPB			; Call LAPB FDT routine
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>
	JMP	G^EXE$QIORETURN

40$:	BSBW	COM_XMITBISYNC			; Call BISYNC FDT routine
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>
	JMP	G^EXE$QIORETURN
	

	.SBTTL	COM_XMITFDT - Common transmit FDT routine
;COM_XMITFDT - 	Common transmit FDT routine
;
; The allocated buffer is given to DDCMP where a header is added and if 
; possible the buffer is added to the transmit queue. The buffer keeps various
; information on the transmit as it progresses from the transmit to the
; completion queues.
;
;	INPUTS
;		R3 = IRP address
;		R5 = UCB address
;		R7 = Address of the user/"Internal" IRP buffer
;		R8 = Address of allocated buffer
;		R9 = Size of user/"Internal" IRP buffer
;
;	IPL = Fork IPL
;
;	OUTPUTS:
;		R0 = Status of operation
;		R5,R8 are preserved
;
COM_XMITFDT:
	PUSHL	R5				; Save these registers
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Get addr of start of TFB
	BEQL	45$				; If EQL device not active
	MOVZBL	#DLK$C_XMTMSG,R6		; Set that this is a msg to XMT
	CLRL	R7				; Clear error bits
	BSBW	DDCMP				; Branch to set up the header
	POPL	R5				; Restore the registers
	CMPB	#DLK$C_ACTNOTCOM,R6		; If EQL then protocol has not
	BEQL	45$				; been started
	BBS	#DLK$V_XMTERR,R7,35$		; If BS then problem with XMT
	BBC	#DLK$V_XMTCMP,R7,20$		; If BC no XMT's to complete
	BSBW	FINISH_XMT_IO			; Complete all XMT's
20$:	BBS	#DLK$V_PRSTERR,R7,40$		; Branch BS persisent error
	BITW	#<DLK$M_XMTACK!-		; If EQL then XMT not put on 
		DLK$M_QFULERR>,R7		; either queue so abort it
	BEQL	35$
	TSTB	UCB$B_XG_XSTATE(R5)		; If NEQ then XMT'r is going
	BNEQ	30$
	CLRL	R1				; Set no status for start_transmit
	BSBW	START_TRANSMIT			; Else start the xmt'r
30$:	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	BRB	50$

35$:	MOVZWL	S^#SS$_BADPARAM,R0		; Set status
	BRB	50$

40$:	SETBIT	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5) ; Set fatal error

	.IF	DF ERR$$$
	incw	ucb$w_xg_prst(r5)		; inc persitant error count
	.ENDC	;DF ERR$$$

	BRB	30$				; Complete as normal timer 
						; will shutdown the device
45$:	MOVZWL	#SS$_DEVINACT,R0		; Set the device is not active
50$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set status for abort
	RSB

;COP_BUFF
;
; This routine takes the user or "Internal" IRP buffer which contains the
; message to send and writes it into the allocated buffer. 
;
;	INPUTS
;		R1 = Size of allocated buffer
;		R3 = IRP address
;		R8 = Address of allocated buffer
;		R7 = Address of buffer from which to move data
;		R9 = Size of user/"Internal" IRP buffer
;
;		IPL = FIPL from ALT_ENTRY and ASTDEL from XMITFDT
;
;	OUTPUTS
;		Buffer is copied into allocated buffer
;		R5,R8,R9 are preserved
;
COP_BUFF:	
	MOVW	R1,XMTQ$W_BUFLEN(R8)		; Save the size of the buffer
	MOVB	S^#DYN$C_BUFIO,-		; Set that this is an XMT
		XMTQ$B_BUFTYP(R8)
	MOVL	R3,XMTQ$L_IRP(R8)		; Save address of the IRP
	ADDW3	#MFD$K_LENGTH,R9,-		; Get the msg size plus header
		XMTQ$W_MSGSIZE(R8)		; for character count
	PUSHL	R5				; Save R5 before the MOV
	MOVC	R9,(R7),XMTQ$K_LENGTH(R8)	; Move data into system buffer
	POPL	R5				; Restore R5
	RSB

	.SBTTL	ALT_ENTRY - Alternate I/O entry
;++
; ALT_ENTRY - Alternate I/O entry point
;
; This routine is called by the other drivers to pass an "internal" I/O
; request to the driver.  "Internal" IRP's are not built via $QIO.
; The action here is to setup the IRP fields as if the packet had been 
; processed by the FDT routines.
;
; In this driver, the alternate entry point is called by the DECnet
; Transport layer driver.
;
; INPUTS:
;
;	  R3 = IRP address
;	  R5 = UCB address
;
;	  IPL = Fork IPL
;
;	  All pertinent fields of the IRP are assumed to be valid.
;
; OUTPUTS:
;
;	R0 = Status of the request
;
;	R3 and R5 preserved
;--
ALT_ENTRY:					; Accept an "internal" IRP
	.IF	DF JNX$$$
	bsbw	fillbuffer
	.ENDC	;DF jnx$$$

	MOVZWL	#SS$_DEVINACT,IRP$L_MEDIA(R3)	; Assume device inactive
	BBS	#XM$V_STS_ACTIVE,-		; If BS status active 
		UCB$L_DEVDEPEND(R5),5$		; device is on line
	BRW	IO_DONE				; Else comp request in error
5$:	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		25$,-				; LAPB
		27$,-				; BISYNC
		>				; Fall thru on DDCMP
	BBS	#IRP$V_FUNC,-			; If BS then receive function
		IRP$W_STS(R3),ALT_RCVFDT
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Save registers
	MOVZWL	IRP$W_BCNT(R3),R9		; Get the length of the buffer
	BEQL	10$				; If EQL then bad parameter
	CMPW	R9,UCB$W_DEVBUFSIZ(R5)		; If GTR then report as error
	BGTRU	10$
	ADDL3	R9,#XMTQ$K_LENGTH,R1		; Add the XMTQ length
	MOVL	R3,R6				; Save the IRP
	JSB	G^EXE$ALONONPAGED		; Allocated the buffer
	BLBC	R0,20$				; If LBC not buffer allocated
	MOVL	R6,R3				; Retreive the IRP
	MOVL	R2,R8				; Get buffer address in R8
	MOVB	#XMTQ$M_INTERNAL,-		; Set that the I/O is from
		XMTQ$B_FLAG(R8)			; an "Internal" IRP

	.IF	DF JNX$$$
	movl	r2,irp$L_fr4(r3)
	.ENDC	;DF jnx$$$

	MOVL	@IRP$L_SVAPTE(R3),R7		; Get interal IRP buffer addr
	BSBW	COP_BUFF			; Copy buffer into allcd buff
	BSBW	COM_XMITFDT			; Branch for common processng
	BLBC	R0,30$				; If BC complete in error
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	RSB

10$:	MOVZWL	S^#SS$_BADPARAM,IRP$L_MEDIA(R3)	; Set abort status
20$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	BRW	IO_DONE				; Complete the request

25$:	BRB	ALT_ENTRY_LAPB			; Branch to LAPB support
27$:	BRW	ALT_ENTRY_BISYNC		; Branch to BISYNC support

30$:	MOVL	R8,R1				; Save R8 it contains XMTQ buff
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	MOVL	R0,IRP$L_MEDIA(R3)		; Set status
	BRW	TRANSMIT_IO_DONE		; Complete deall the buffer

ALT_RCVFDT:
RCVLAPB:
	MOVL	IRP$L_SVAPTE(R3),R2		; Is there a buffer to reuse
	BEQL	10$				; If EQL then no
	CLRL	IRP$L_SVAPTE(R3)		; Clear so not deallocated
	BSBW	ADDFREELIST			; Else add it to the free list
10$:	BSBW	COM_RCVFDT			; Do common processing
	BLBC	R0,20$				; Br if unsuccessful
	RSB

20$:	MOVL	R0,IRP$L_MEDIA(R3)		; Set status
	BRW	IO_DONE				; Complete IRP in error
;++
;
; This routine is the alt entry point for the device when running LAPB or BISYNC
; mode. Instead of simply checking the function bit in STS it must explicity
; check the function code in FUNC. It processes READ's ,WRITE's and CLEAN's
; via this interface. This routine makes some assumptions. First that the
; interface will only take Logical read's and write's. Second that the 
; io fields will not change.
;
;	NOTE:	When looking at this ASSUME statement, pleaser remember that
;		the values specified are in decimal not in HEX.
;--
ALT_ENTRY_LAPB:
ALT_ENTRY_BISYNC:
	ASSUME	IO$_WRITELBLK EQ 32
	ASSUME 	IO$_READLBLK EQ 33
	ASSUME	IO$_CLEAN EQ 30

	MOVZBL	IRP$W_FUNC(R3),R0		; Get the function code
	BICB	#^XFC,R0			; clear all but the low 2 bits
	CASE	R0,TYPE=B,<-			; Do the case off this
		XMITLAPB,-
		RCVLAPB>
;		ALT_CLEANFDT>			; Fall thru on Clean
		

	.SBTTL	CLEANFDT/ALT_CLEANFDT - Perform CLEAN FDT processing
;++
;CLEANFDT/ALT_CLEANFDT  - Perform CLEAN FDT processing
; 
; This routine sets up to ABORT all outstanding XMT's. This function is
; valid only when the device is running LAPB. 
;
;	Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
;	ALT_CLEANFDT only:
;
;	IPL = FIPL
;
;	Outputs:
;
;	R0 = status return for request
;
;	R3-R5 are preserved.
;
;--
ALT_CLEANFDT:
	BBS	#XG_DS_V_CLEAN,UCB$W_DEVSTS(R5),10$ ; If BS then don't allow
	BRW	CLEAN				    ; another clean to happen

10$:	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set abort status
	BRW	IO_DONE				; Complete the request in err
CLEANFDT:
	BBS	#XG_DS_V_CLEAN,UCB$W_DEVSTS(R5),10$ ; If BS then don't allow
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Save registers
	SETIPL	UCB$B_FIPL(R5)			; Set IPL to fork
	BSBW	CLEAN				; Do the Clean processing
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>
	JMP	G^EXE$QIORETURN			; Return from processing 
						; IRP will get posted thru
						; IO_DONE
10$:	JMP	G^EXE$ABORTIO			; If clean in progress abort 
						; any others that may be issued


	.SBTTL	XMITLAPB - Transmit LAPB/BISYNC FDT routine

;++
; XMITLAPB - Special LAPB/BISYNC transmit routine
;
; This routine is called after a transmit buffer has been allocated
; and the transmit is to be given to the device. It's called
; to get around the special checks done for DDCMP transmits.
;
;	INPUTS	R1 = Size of allocated buffer
;		R3 = IRP address
;		R5 = UCB address
;		R7 = Address of user or "Internal" IRP buffer
;		R8 = Address of allocated buffer
;
;	OUTPUTS Transmit given to the board
;
;	*** NOTE ***
;
; All messages for LAPB get inserted on an XMTQ, which sits at the same offset 
; as DDCMP's CTLQ. This  is done to decrease the overhead involved on the queue
; management. Notice  however that the bit indicating that the message was a
; control message is  never set in the block. This means that when the interrupt
; for the message  is gotten the message will be complete via FORK_DONE and
; eventually given  to POST instead of being dropped as normal DDCMP control
; messages are 
; are dropped.
;
; These routines are also called when the driver is running in BISYNC mode.
; The handling of tranmits for the two protocols are very similar, therefor
; they share this code. There is a difference in that the BISYNC  messages
; and the LAPB messages are queued to different queues. Bisync mode can not
; take advantage of being queued to the DDCMP CTLQ because it runs
; in half duplex. This means that the protocol must some times must wait 
; for CTS to come high before transmitting. The way the transmit code works 
; is that is gets the first message off the CTLQ and if empty then off the XMTQ.
; If it can send the message then it will otherwise it must put the message 
; back on a queue according to the XMTQ$B_FLAG's 
; CONTROL bit is set. This bit also governs whether or not the message
; is complete via IOPOST. Since the BISYNC XMT message may be put on
; the queue and must go thru IOPOST processing we can not use the same
; short cut used to queue LAPB XMT messages. Thus BISYNC messages are queued
; to the DDCMP XMTQ, which is the second of the queues. The side effect is to
; increase the overhead slightly, but BISYNC is not destined to be a high 
; speed prototcol
;
	.ENABL	LSB
COM_XMITLAPB:
COM_XMITBISYNC:
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Save registers
	BRB	5$
XMITLAPB:
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Save registers
	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; BISYNC?
	BNEQ	3$				; Branch if not
	MOVL	IRP$L_ABCNT(R3),R0		; Should we update the state info
	BEQL	3$				; If EQL then don't
	MOVQ	(R0),UCB$Q_XG_STATE_INFO(R5)	; Update the state info
3$:	MOVZWL	IRP$W_BCNT(R3),R9		; Get the length of the buffer
	BEQL	30$				; If EQL then bad parameter
	CMPW	R9,UCB$W_DEVBUFSIZ(R5)		; If GTR then report as error
	BGTRU	30$
	ADDL3	R9,#XMTQ$K_LENGTH,R1		; Add the XMTQ length
	MOVL	R3,R6				; Save the IRP
	JSB	G^EXE$ALONONPAGED		; Allocated the buffer
	BLBC	R0,40$				; If LBC not buffer allocated
	MOVL	R6,R3				; Retreive the IRP
	MOVL	R2,R8				; Get buffer address in R8
	MOVB	#XMTQ$M_INTERNAL,-		; Set that the I/O is from
		XMTQ$B_FLAG(R8)			; an "Internal" IRP
	MOVL	@IRP$L_SVAPTE(R3),R7		; Get interal IRP buffer addr

5$:	MOVW	R1,XMTQ$W_BUFLEN(R8)		; Save the size of the buffer
	MOVB	S^#DYN$C_BUFIO,XMTQ$B_BUFTYP(R8) ; Set that buffer is an XMT
	MOVL	R3,XMTQ$L_IRP(R8)		; Save address on the IRP
	MOVW	R9,XMTQ$W_MSGSIZE(R8)		; Set message size
	PUSHL	R5
	MOVC	R9,(R7),XMTQ$B_MSGHDR(R8)	; Copy the msg to send into buf
	POPL	R5
	BBS	#XMTQ$V_INTERNAL,XMTQ$B_FLAG(R8),10$ ; If BS then  at FIPL
	SETIPL	UCB$B_FIPL(R5)			; Else set to FIPL
10$:	BBC	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5),50$ ; If BC device inactv
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get protocol buffer
	BEQL	50$				; If eql then dev inactive
	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5); If EQL then LAPB
	BEQL	60$
	INSQUE	(R8),@LAPB$Q_XMTQ+4(R4)		; Insert XMT at end of queue
14$:	TSTB	UCB$B_XG_XSTATE(R5)		; If NEQL then XMT'r is busy
	BNEQ	20$
	CLRL	R1				; Set no status for start transmit
	BSBW	START_TRANSMIT			; Else start the transmit
20$:	MOVZWL	S^#SS$_NORMAL,R0		; Set for normal return
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device depend field
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	RSB

30$:	MOVZWL	S^#SS$_BADPARAM,IRP$L_MEDIA(R3)	; Set abort status
40$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	BRW	IO_DONE				; Complete the request
50$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	MOVZWL	#SS$_DEVINACT,IRP$L_MEDIA(R3)	; Assume device inactive
	BRW	TRANSMIT_IO_DONE		; Complete the request in error
;
; If the device is running BISYNC half duplex mode the set the SELECT 
; flag in the the field XMTQ$B_FLAG so that RTS is dropped after each 
; message
;
60$:	BBC	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5),65$ ; IF BC not half duplex
	SETBIT	#XMTQ$V_SELECT,XMTQ$B_FLAG(R8)	; Set select in XMT buffer
65$:	INSQUE	(R8),@BISYNC$Q_XMTQ+4(R4)	; Insert XMT at end of queue
	BRB	14$

	.DSABL	LSB

	.SBTTL	RCVFDT - Receive I/O FDT routine
;++
; RCVFDT - Receive I/O FDT routine
;
; FUNCTIONAL DESCRIPTION:
;
; The specified buffer is checked for accessibility. The buffer address and 
; count are saved in the packet. Then IPL is set to device fork IPL and if 
; a message is available the operation is completed.  Otherwise the packet 
; is queued onto the waiting receive list.
;
; For requests specifing IO$M_NOW, the I/O is completed with status of
; SS$_ENDOFILE if no message is available when the test is made.
;
;
; INPUTS:
;
;	R3 = I/O packet address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first I/O request parameter
;
; OUTPUTS:
;
;	R0 = Status of the receive request
;
;	R3-R7 preserved.
;--
RCVFDT:						; Receive function routine
	MOVZWL	#SS$_BADPARAM,R0		; Assume illegal size
	MOVZWL	P2(AP),R1			; Get size
	BEQL	ABORTIO				; Br if none specified
	MOVL	P1(AP),R0			; Get buffer address
	MOVL	R0,IRP$L_MEDIA(R3)		; Save address
	CLRW	IRP$W_BOFF(R3)			; No quota to return during
						; completion
	JSB	G^EXE$READCHK			; Check buffer accessibility
						; (no return on no access)
	SETIPL	UCB$B_FIPL(R5)			; Synchronize access to the UCB
	BSBB	COM_RCVFDT			; Process the request
	BLBC	R0,ABORTIO			; Br if error
	JMP	G^EXE$QIORETURN			; Return to await completion
ABORTIO:					; Abort the I/O request
	CLRL	R1				; Don't return device status
	JMP	G^EXE$ABORTIO			; 

;
; Common receive processing
;
COM_RCVFDT:					; Common receive processing
	BBS	#XM$V_STS_ACTIVE,-		; Br if device active
		UCB$L_DEVDEPEND(R5),10$
	MOVZWL	#SS$_DEVINACT,R0		; Set return status
	RSB

;
; Check for an avaiable message and complete the receive
;

10$:	REMQUE	@UCB$Q_XG_ATTN(R5),R2		  ; Dequeue a received message
	BVS	15$				  ; Br if none
	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		30$,-				; LAPB
		30$,-				; BISYNC
		>				; Fall thru on DDCMP
	BRW	FINISH_RCV_IO			; Comp the I/O request
;
; Queue the requst for future message arrival unless IO$M_NOW specified.
; Receives are queued to the special receive wait queue.
;
15$:	BBS	#IO$V_NOW,IRP$W_FUNC(R3),20$	; Br BS read NOW
	INSQUE	(R3),@UCB$Q_XG_RCVS+4(R5)	; Queue the I/O packet
	MOVZWL	S^#SS$_NORMAL,R0		; Set QIO status
	RSB					; 

20$:	MOVZWL	#SS$_ENDOFFILE,IRP$L_MEDIA(R3)	; Set no message status
	BSBW	IO_DONE				; Complete the I/O
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal completetion
	RSB					; And return
;
; The RCV finish IO routines are the same for both
; the LAPB and BISYNC protocols
;
30$:	MOVAL	RCV_Z_HEADER(R2),(R2)		; Set up point to data
	MOVZWL	RCV_W_MSGSIZ(R2),R0		; Get size of transfer
	BRW	FINISH_RCV_IO_LAPB		; Go thru LAPB finish IO


	.SBTTL	SETMODEFDT,  Set mode I/O operation FDT routine
 
;++
; SETMODEFDT - Set mode I/O operation FDT routine
;
; Functional description:
;
; This routine is used to set the configuration of the DMF32 hardware device
; including configuration of software DDCMP. Subfunction modifier bits are used
; to specify the type of action to be taken. The two characteristics buffers
; (P1 and P2) are used to describe specific characteristics. 
;
; The QIO parameters for SETMODE are:
;
;	P1 = Optional address of quadword or longword buffer
;	P2 = Optional address of buffer descriptor for extended characteristics
;	P3 = Number of receive buffers to pre-allocate. Required on
;	     controller startup.
;
;
; The subfunction modifiers are as follows:
;
;
; 	 o STARTUP - start the device - this modifier is used to
;		start the device.
;
; 	o SHUTDOWN - shutdown the device - this modifier
; 		is used to stop the device.
;
; 	o ATTNAST - request an attention AST - this modifier is used
;	 	to set up an AST to be delivered when a change of
;		status occurs on this device.
;
;	o CTRL - perform the request on the Controller not the
;		 tributary.
;
;	o SET_MODEM - set line unit's mode register.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = address of first QIO parameter
;
; Outputs:
;
;	R0 = status of setmode request
;
;	R3-R5 are preserved.
;
;	R7-R9 = destroyed
;
;--

SETMODEFDT:					; Setmode FDT processing
	MOVZWL	IRP$W_FUNC(R3),R7		; Get entire function code
	BBC	#IO$V_CTRL,R7,5$		; Br if not controller request
	BRW	SETMODE_CTRL			; Process controller request
;
; Perform setmode request on a tributary
;
5$:	CMPB	#XG$C_PROTYPE_DDCMP,UCB$B_XG_PROTYPE(R5) ; NEQ then abort io
	BNEQ	40$
	BBC	#IO$V_ATTNAST,R7,30$		; Branch if not attention AST
 
;
; User is requesting an attention AST.
;
	MOVAL	UCB$L_XG_AST(R5),R7		; Get addr of AST list
	JSB	G^COM$SETATTNAST		; Set up attention AST
	MOVAB	UCB$Q_XG_ATTN(R5),R1		; Check for empty rcv list
	CMPL	R1,(R1)				; Empty?
	BEQL	20$				; Yes, no need to inform user
10$:	PUSHL	R3				; Else, save IRP address
	BSBW	POKE_USER			; Inform the user
	POPL	R3				; Restore IRP address
20$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Get device characteristics
23$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success
25$:	JMP	G^EXE$FINISHIO			; Complete the I/O
 
 
30$:	BSBW	GET_CHAR_BUFS			; Get P1 and P2 characteristics
	BLBC	R0,40$				; Br if error - abort I/O
	BBC	#IO$V_SHUTDOWN,R7,50$		; Branch if not trib shutdown
;
; Shutdown tributary modifier specified.
;
; Validate P2 buffer. Then update trib parameter block.
;
	MOVB	S^#XG_FC_V_STOP_CIR,-		; Set internal function code
		IRP$B_XGFUNC(R3)
	MOVZWL	UCB$L_DEVDEPEND(R5),R2		; Else, get status
35$:	DSBINT	UCB$B_FIPL(R5)			; Sync to get the UCB
	BSBW	VALIDATE_P2_TRIB		; Validate the P2 buffer
	ENBINT					; Restore IPL
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Assume no error
	BLBC	R0,25$				; Br if error
	DSBINT	UCB$B_FIPL(R5)			; Sync to get the UCB
	BSBW	CHG_TRIB			; Change trib parameters
	ENBINT					; Restore IPL
	BRW	QUEPKT				; Queue packet to driver
 
40$:	JMP	G^EXE$ABORTIO			; Abort the I/O request

50$:	MOVZWL	UCB$L_DEVDEPEND(R5),R2		; Get status
	DSBINT	UCB$B_FIPL(R5)			; Sync to get the UCB
	BSBW	VALIDATE_P2_TRIB		; Validate the P2 buffer
	ENBINT					; Restore IPL
	BLBC	R0,40$				; Br if error
60$:	DSBINT	UCB$B_FIPL(R5)			; Sync to get the UCB
	BSBW	CHG_TRIB			; Change trib parameters
	ENBINT					; Restore IPL
	BBS	#IO$V_STARTUP,R7,80$		; Br if startup request
	MOVZWL	S^#SS$_NORMAL,R0		; Else, set successful return
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set IOSB return status
	JMP	G^EXE$FINISHIO			; Finish the I/O request
80$:	MOVB	S^#XG_FC_V_STRT_CIR,-		; Set internal function code
		IRP$B_XGFUNC(R3)
	BRW	QUEPKT


	.SBTTL	SETMODE_CTRL,  Perform setmode FDT operation on controller
 
;++
; SETMODE_CTRL - Perform setmode FDT operation on controller
;
; Functional description:
;
; This routine performs the SETMODE FDT setup for the controller.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = IRP function word
;
; Outputs:
;
;	R0 = status of setmode request
;
;	R3-R5 are preserved.
;
;--
 
SETMODE_CTRL:					; Perform setmode on controller
	BSBW	GET_CHAR_BUFS			; Get P1 and P2 characteristics
	BLBC	R0,20$				; Br if error - Abort I/O

	BITW	#<XM$M_CHR_CTRL!-		; If NEQ then not multipoint 
		XM$M_CHR_DMC>,-			; control or DMC mode
		IRP$L_MEDIA+4(R3)
	BEQL	5$
	MOVZWL	#SS$_BADPARAM,R0		; Else set bad parameter
	BRB	20$

; This clear of R6 assumes no protocol was specified. If this is true then
; the driver assumes that the user wanted DDCMP, and if a P1 buffer
; was speficied the driver will use the characteristics set in the buffer.
; The P1 buffer is not valid for BISYNC and LAPB modes, and will not be checked.

5$:	CLRL	R6				; Assume no protocol specified
	MOVZWL	#NMA$C_PCLI_PRO,R1		; Check P2 buffer for multi
	DSBINT	UCB$B_FIPL(R5)			; Sync to get the UCB
	BSBW	UNPACK_P2_BUF			; point control specification
	ENBINT					; Restore IPL
	BLBC	R0,14$				; If BC then no prot specified
	MOVL	R2,R6				; Set protocol type in R6
	CMPB	#NMA$C_LINPR_CON,R2		; If EQL then multipoint contrl
	BEQL	10$				; specified
	CMPB	#NMA$C_LINPR_DMC,R2		; If EQL then DDCMP DMC mode
	BEQL	10$				; specified
	BRB	14$
10$:	MOVZWL	#SS$_BADPARAM,R0		; Else set bad parameter
	BRB	17$
14$:	MOVZWL	UCB$W_DEVSTS(R5),R2		; Get device status
	DSBINT	UCB$B_FIPL(R5)			; Sync to get the UCB
	BSBW	VALIDATE_P2_UCB			; Validate the P2 buffer
	ENBINT					; Restore IPL
	BLBC	R0,20$				; Br if error
	BBC	#IO$V_SHUTDOWN,R7,30$		; Br if not shutdown request
;
; Shutdown modifier specified
;
	MOVB	S^#XG_FC_V_STOP_LIN,-		; Set internal function code
		IRP$B_XGFUNC(R3)
	MOVZBL	UCB$B_XG_PRO(R5),R6		; Set the protocol type for shutdown
	DSBINT	UCB$B_FIPL(R5)			; Sync to get UCB
	BSBW	CHG_UCB				; Update the UCB
	ENBINT					; Lower IPL
	BBC	#XG_DS_V_INITED,-		; Br if controller not up
		UCB$W_DEVSTS(R5),15$		;
	BRW	QUEPKT				; Queue packet to driver
 
15$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Get IOSB1 return
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
17$:	JMP	G^EXE$FINISHIO			; Complete the I/O request

20$:	JMP	G^EXE$ABORTIO			; Abort the I/O request

25$: 	BRW	50$				; Branch to compl request
 
30$:	CMPB	#NMA$C_LINPR_BSY,R6		; If BIYSNC mode check privs
	IFPRIV	CMKRNL,32$			; If priv ok
	MOVZWL	#SS$_NOPRIV,R0			; else abort the io request
	BRB	20$
32$:	BBC	#IO$V_STARTUP,R7,25$		; Br if not startup request
	MOVB	S^#XG_FC_V_STRT_LIN,-		; Set internal function code
		IRP$B_XGFUNC(R3)
	MOVZWL	P3(AP),R1			; If EQL then P3 not set up
	BEQL	35$
	BBC	#XG_DS_V_INITED,-		; If BC then device not inited
		UCB$W_DEVSTS(R5),33$		; set number of buffers
	CMPB	R1,UCB$B_XG_BFN(R5)		; Are the buffer nmb's the same
	BEQL	35$				; Br if yes
	MOVZWL	#NMA$C_PCLI_BFN,R1		; Set IOSB1 return
	MOVZWL	#SS$_BADPARAM,R0		; Set error return
	BRB	17$				; Finish the I/O request
33$:	DSBINT	UCB$B_FIPL(R5)			; Sync to get UCB
	MOVB	R1,UCB$B_XG_BFN(R5)		; Store new rcve buffer number
	ENBINT					; Restore IPL
;
; Set new P1, P2 parameters
;
35$:	BBC	#XG_DS_V_INITED,-		; Br if device not already
		UCB$W_DEVSTS(R5),36$		; inited
	BRW	70$
36$:	DSBINT	UCB$B_FIPL(R5)			; Sync to get UCB
	BLBC	IRP$L_MEDIA(R3),37$		; Br if no P1
	CLRB	UCB$L_DEVDEPEND(R5)		; Clear old characteristics
37$:	BSBW	CHG_UCB				; Change the UCB charac
	ENBINT					; Restore IPL
	MOVZBL	UCB$B_XG_BFN(R5),R1		; Get number of receive buffers
	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; If neq then branch
	BNEQ	38$
;
; For BISYNC mode add an extra receive buffer. This buffer will be 
; permenantly allocated to the device to do the acutal receiving of
; data off the line. The other buffers allocated will be used to
; receive the data after the data has been passed thru the framing routine
;
	ADDL2	S^#1,R1
38$:	MOVZWL	IRP$L_MEDIA+2(R3),R2		; Get message size from P1
	BLBS	IRP$L_MEDIA(R3),40$		; Br if P1 buffer valid
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R2		; Else, get buff size from UCB
40$:	MOVZWL	#SS$_BADPARAM,R0		; Assume bad parameter
	MULL	R1,R2				; Compute total needed for buff
	BEQL	60$				; Br if zero - error
	MOVZWL	R2,R7				; Copy quota
	CMPL	R2,R7				; Overflow?
	BNEQ	60$				; Br if error
	PUSHL	R3				; Save R3
	JSB	G^EXE$BUFQUOPRC			; Check caller's quota
	POPL	R3				; Restore R3
	BLBC	R0,60$				; Br if error
	MOVW	R7,IRP$W_QUOTA(R3)		; Save quota in packet
	MOVL	PCB$L_JIB(R4),R0		; Get JIB address
	SUBL	R7,JIB$L_BYTCNT(R0)		; Charge user for rec. bufs
; 
; The following call is used to allocate a buffer size dependant on
; the protocol, for use with the various protocols supported. If the
; routine returns with LBC then the buffer could not be allocated and
; the device can not be started.
;
	BSBW	ALLOC_PROT_BUFFER
	BLBC	R0,60$				; If LBC then abort startup
	BRW	QUEPKT				; Queue request to driver
;
; No modifier specified - change controller parameters
;
50$:	SETIPL	UCB$B_FIPL(R5)			; Sync access to UCB
	BBS	#XG_DS_V_INITED,-		; Br if already inited
		UCB$W_DEVSTS(R5),70$		;
	BLBC	IRP$L_MEDIA(R3),53$		; Br if no P1 buffer
	CLRB	UCB$L_DEVDEPEND(R5)		; Clear old UCB characteristics
53$:	BSBW	CHG_UCB				; Change UCB parameters
	MOVZWL	S^#SS$_NORMAL,R0		; Else, set success
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set IOSB1 return
55$:	JMP	G^EXE$FINISHIO			; Finish the I/O request
 
60$:	JMP	G^EXE$ABORTIO			; Abort the I/O request
;
; Device already inited - set new parameters and give them to device
;
70$:	BLBC	IRP$L_MEDIA(R3),80$		; Br if no P1 buffer
	CMPB	IRP$L_MEDIA+4(R3),-		; Are characteristics okay?
		UCB$L_DEVDEPEND(R5)
	BEQL	80$				; Yes - let it go
	MOVZWL	#SS$_BADPARAM,R0		; Return error
	MNEGL	S^#1,R1				; No specific parameter
	BRB	55$				; Complete the I/O
 
80$:	SETIPL	UCB$B_FIPL(R5)			; Sync to get UCB
	BSBW	CHG_UCB				; Change UCB parameters
	MOVB	#<15@4>,R0			; Set only four parameters
	MOVW	S^#SS$_NORMAL,R0
	MOVL	UCB$L_DEVDEPEND(R5),R1
	JMP	G^EXE$FINISHIO

	.SBTTL	ALLOC_PROT_BUFFER, Allocate a buffer to be used by the protocol
;++
;ALLOC_PROT_BUFFER - Allocate protocol buffer routine
;
; This routine allocates the  buffer needed for operation of each of the 
; protocols that the driver supports. By allocating the buffer on startup
; of the device rather than in the UCB we can eliminate some overhead 
; involved in having the device but using a protocol other than DDCMP
; over it.
;
;	INPUTS 	R4 = Address of the PCB
;
;	OUTPUTS	R2,R3 are preserved
;
;--
ALLOC_PROT_BUFFER:
	PUSHR	#^M<R2,R3>
	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		10$,-				; LAPB
		20$,-				; BISYNC
		>				; Fall thru on DDCMP
;
; Alloc DDCMP buffer the TFB and GFB are allocated contiguously
;
	ADDL3	#TF$K_LENGTH,#GF$K_LENGTH,R1
	BRB	30$
10$:	MOVL	#LAPB$K_LENGTH,R1		; Set LAPB buffer size
	BRB	30$
20$:	MOVL	#BISYNC$K_LENGTH,R1		; Set BISYNC buffer size
30$:	JSB	G^EXE$BUFFRQUOTA		; Does the user have quota
	BLBC	R0,40$				; If LBC no quota
	JSB	G^EXE$ALLOCBUF			; Allocate the buffer
	BLBC	R0,40$				; If LBC then not allocated
	MOVL	PCB$L_JIB(R4),R0		; Get the users JIB
	SUBL2	R1,JIB$L_BYTCNT(R0)		; Subtract the quota
	DSBINT	UCB$B_FIPL(R5)			; Synch to gain access to UCB
	MOVL	R2,UCB$A_XG_PRO_BUFFER(R5)	; Save the buffer address
	ENBINT					; Enable interrupts
	MOVW	R1,UCB$W_SIZE(R2)		; Save the size of BUFFER allocated
	MOVW	S^#DYN$C_BUFIO,UCB$B_TYPE(R2)	; Set buffer type
	CMPB	#XG$C_PROTYPE_DDCMP,UCB$B_XG_PROTYPE(R5)
	BNEQ	35$
	PUSHR	#^M<R1,R2,R3,R4,R5>
	MOVC5	#0,(R5),#0,#GF$K_LENGTH,TF$K_LENGTH(R2)
	POPR	#^M<R1,R2,R3,R4,R5>
	MOVB	UCB$B_FIPL(R5),GF$B_FIPL+TF$K_LENGTH(R2) ; Set fork IPL for DDCMP
	MOVB	UCB$B_DIPL(R5),GF$B_DIPL+TF$K_LENGTH(R2) ; Set device IPL for DDCMP
	MOVAL	TF$K_LENGTH(R2),TF$A_GFB(R2) 	; Set address of global field
35$:	MOVZWL	S^#SS$_NORMAL,R0		; Set successful return
40$:	POPR	#^M<R2,R3>
	RSB



	.SBTTL	SENSEMODEFDT,  Sense Mode I/O operation FDT routine

;++
; SENSEMODEFDT - Sense Mode FDT routine
;
; Functional Description:
;
;  This routine returns information to the caller about the configuration
;  and status of the DMF32 device.  Depending on the function modifier,
;  either the device characteristics, error counters contents are returned.
;
;
;  The QIO parameters for SENSEMODE are:
;
;	P1 = optional address of quadword or longword buffer
;	P2 = optional address of buffer descriptor for extended characteristics
;	
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
; Outputs:
;
;	R0 = status return of sensemode request
;
;	R3-R5 are preserved.
;
;--

SENSEMODEFDT:					; Sensemode FDT I/O processing
	MOVW	IRP$W_FUNC(R3),R7		; Get entire function code
 
	BBC	#IO$V_CTRL,R7,5$		; Br if not controller request
	BRW	SENSEMODE_CTRL			; Else, process controller req.
5$:	CMPB	#XG$C_PROTYPE_DDCMP,UCB$B_XG_PROTYPE(R5) ; NEQ then abort io
	BNEQ	30$
	BITW	#<IO$M_RD_COUNT!-		; Check to see if either bit is
		IO$M_CLR_COUNT>,R7		; Is set
	BEQL	40$				; If EQL then read parameters
	CLRL	R0				; Assume clear count
	MOVZWL	S^#SS$_NORMAL,R1		; Assume success
	BBC	#IO$V_RD_COUNT,R7,15$		; If BC then not read count
;
; Read tributary counters - modifier RD_COUNT
;
	BSBW	CHECK_P2			; Check P2 buffer
	MOVZWL	#SS$_BADPARAM,R0		; Assume zero length buffer
	MOVW	R1,IRP$L_MEDIA+4(R3)		; Save user size of P2 buffer
	BEQL	30$				; Br if none
	PUSHL	R4
	MOVZWL	S^#SS$_NORMAL,R1		; Assume success
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get prot buffer address
	BNEQ	8$				; If NEQ then buffer exists
	MOVW	#0,IRP$W_BCNT(R3)		; Else return no errors read
	CLRL	R0				; And complete the request
	BRB	20$

8$:	MOVZWL	TF$W_TEB(R4),R0			; Get size of buffer needed
	CMPW	IRP$L_MEDIA+4(R3),R0		; IF GEQU then buffer ok
	BGEQU	10$
	MOVZWL	#SS$_BUFFEROVF,R1		; Return partial success
	MOVZWL	IRP$L_MEDIA+4(R3),R0		; Set size of copy
10$:	PUSHR	#^M<R0,R1,R3,R4,R5>		; Save the registers
	MOVC3	R0,TF$K_ERRSTRT(R4),(R2)	; Get the errors
	POPR	#^M<R0,R1,R3,R4,R5>
	BBC	#IO$V_CLR_COUNT,R7,20$		; Br if not clear counts
15$:	MOVZWL	#<DLK$M_TRIB!DLK$M_CLEAR>,R7	; Set counters to read/clear
	SETIPL	UCB$B_FIPL(R5)			; Set to fork IPL
	PUSHR	#^M<R0,R1,R3,R5>		; Save registers
	CLRL	R8				; Set no parameters to return
	MOVL	R4,R5				; Set address of trib block
	MOVZBL	#DLK$C_REQEBA,R6		; Set operation to perform
	BSBW	DDCMP				; Branch to protocol
	POPR	#^M<R0,R1,R3,R5>
20$:	ASHL	#16,R0,R0			; Shift size of buffer return
	MOVW	R1,R0				; Set success status
	POPL	R4
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set devdepend info
	JMP	G^EXE$FINISHIO			; Complete the request

30$:	JMP	G^EXE$ABORTIO			; Abort the I/O request

;
; Read tributary parameters 
;
40$:	MOVZWL	S^#8,R1				; Size of P1 buffer if present
	BSBW	CHECK_BUFS			; Check P1 and P2 buffers
	MOVZWL	S^#SS$_NORMAL,R0		; Assume success
	MOVW	R1,IRP$L_MEDIA+4(R3)		; Save user P2 buffer length
	BEQL	60$				; Br if no P2 buffer present

	MOVW	S^#SS$_NORMAL,IRP$L_MEDIA+6(R3)	; Assume success
	MOVW	#TRIB_PRM_BUFSIZ,IRP$W_BCNT(R3)	; Set size of required buffer
	CMPW	R1,#TRIB_PRM_BUFSIZ		; If GEQU then user buffer is
	BGEQU	50$				; large enough
	MOVW	#SS$_BUFFEROVF,IRP$L_MEDIA+6(R3) ; Return partial success
	MOVW	R1,IRP$W_BCNT(R3)		; Set size to use in move
50$:	MOVAB	TRIB_PARAM,R1			; Get address of return table
	MOVAB	UCB$Z_XG_DDCMP(R5),R4		; Get trib param block address
	BSBW	RETURN_P2			; Return the P2 parameters
	MOVW	IRP$W_BCNT(R3),R0		; Return size of buffer
	ASHL	#16,R0,R0			; Shift size of buffer return
	MOVW	IRP$L_MEDIA+6(R3),R0		; Set success of return
 
60$:	MOVL	IRP$L_MEDIA(R3),R2		; Retrieve P1 buffer address
	BEQL	70$				; Br if none
	MOVQ	UCB$B_DEVCLASS(R5),(R2)		; Else, return characteristics
70$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Get device dependend info
	JMP	G^EXE$FINISHIO			; Complete the I/O request

	.SBTTL	SENSEMODE_CTRL,  Perform SENSEMODE FDT processing for controller
 
;++
; SENSEMODE_CTRL - Perform SENSEMODE FDT processing for controller
;
; Functional description:
;
; This routine performs all FDT checking for a controller SENSEMODE request.
; The P2 buffer if present is check for write access and if okay, a system
; buffer is allocated for temporarily saving the needed information. The
; P1 sensemode information is returned through IRP$L_MEDIA and IRP$L_MEDIA+4.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 = status return for request
;
;	R3-R5 are preserved.
;
;--
SENSEMODE_CTRL:					; Process controller sensemode FDT
	BBC	#IO$V_RD_MODEM,R7,2$		; If BC not a read modem IO
	BRW	SENSE_MODEM			; Else branch to read modem FDT
2$:	BITW	#<IO$M_RD_COUNT!-		; Check to see if either bit is
		IO$M_CLR_COUNT>,R7		; Is set
	BNEQ	5$				; If NEQ then not read parameter
	BRW	40$				; else read parameters
5$:	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		35$,-				; LAPB
		37$,-				; BISYNC
		>				; Fall thru on DDCMP
	CLRL	R0				; Assume clear count
	MOVZWL	S^#SS$_NORMAL,R1		; Assume success
	TSTL	UCB$A_XG_PRO_BUFFER(R5)		; Check for addr of protocol buffer
	BNEQ	8$				; If NEQ then buffer exists
	MOVW	#0,IRP$W_BCNT(R3)		; Else return no errors read
	CLRL	R0				; And complete the request
	BRW	20$
8$:	BBC	#IO$V_RD_COUNT,R7,15$		; Br if not read counters
;
; Read controller counters - modifier RD_COUNT for DDCMP mode only
;
	BSBW	CHECK_P2			; Check P2 buffer
	MOVZWL	#SS$_BADPARAM,R0		; Assume zero length buffer
	MOVW	R1,IRP$L_MEDIA+4(R3)		; Save user size of P2 buffer
	BEQL	30$				; Br if none
	MOVZWL	S^#SS$_NORMAL,R1		; Assume success
	PUSHL	R4
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Set address of protocol buffer
	MOVZWL	GF$W_GEB+TF$K_LENGTH(R4),R0	; Get size of buffer needed
	CMPW	IRP$L_MEDIA+4(R3),R0		; IF GEQU then buffer ok
	BGEQU	10$
	MOVZWL	#SS$_BUFFEROVF,R1		; Return partial success
	MOVZWL	IRP$L_MEDIA+4(R3),R0		; Set size of copy
10$:	PUSHR	#^M<R0,R1,R3,R4,R5>		; Save the registers
	MOVC3	R0,GF$K_ERRSRT+TF$K_LENGTH(R4),(R2) ; Get the errors
	POPR	#^M<R0,R1,R3,R4,R5>
	POPL	R4				; Restore R4
	BBC	#IO$V_CLR_COUNT,R7,20$		; Br if not clear counts
15$:	MOVZWL	#<DLK$M_GLOB!DLK$M_CLEAR>,R7	; Set counters to read/clear
	SETIPL	UCB$B_FIPL(R5)			; Set to fork IPL
	PUSHR	#^M<R0,R1,R3,R4,R5>		; Save registers
	CLRL	R8				; Set no parameters to return
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Set address of protocol buffer
	MOVZBL	#DLK$C_REQEBA,R6		; Set operation to perform
	BSBW	DDCMP				; Branch to protocol
	POPR	#^M<R0,R1,R3,R4,R5>
20$:	ASHL	#16,R0,R0			; Shift size of buffer return
	MOVW	R1,R0				; Set success status
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set devdepend info
	JMP	G^EXE$FINISHIO			; Complete the request

30$:	JMP	G^EXE$ABORTIO			; Abort the I/O request

35$:	BRB	80$

37$:	MOVZWL	S^#SS$_NORMAL,R0		; SET success and no data returned
	BRB	70$				; Exit from sensemode
;
; Read controller parameters
;
40$:	MOVZWL	S^#8,R1				; Size of P1 buffer if present
	BSBW	CHECK_BUFS			; Check P1 and P2 buffers
	MOVZWL	S^#SS$_NORMAL,R0		; Assume success
	MOVL	R1,IRP$L_MEDIA+4(R3)		; Save user P2 buffer length
	BEQL	60$				; Br if no P2 buffer

	MOVW	S^#SS$_NORMAL,IRP$L_MEDIA+6(R3)	; Assume success
	MOVW	#LINE_PRM_BUFSIZ,IRP$W_BCNT(R3)	; Set size of required buffer
	CMPW	R1,#LINE_PRM_BUFSIZ		; If GEQU then user buffer is
	BGEQU	50$				; large enough
	MOVW	#SS$_BUFFEROVF,IRP$L_MEDIA+6(R3) ; Return partial success
	MOVW	R1,IRP$W_BCNT(R3)		; Set size to use in move
50$:	MOVAB	LINE_PARAM,R1			; Get address of return table
	MOVL	R5,R4				; Get line param block address
	BSBW	RETURN_P2			; Return the P2 parameters
55$:	MOVW	IRP$W_BCNT(R3),R0		; Return size of buffer
	ASHL	#16,R0,R0			; Shift size of buffer return
	MOVW	IRP$L_MEDIA+6(R3),R0		; Set size of return

60$:	MOVL	IRP$L_MEDIA(R3),R2		; Retrieve P1 buffer address
	BEQL	70$				; Br if none
	MOVQ	UCB$B_DEVCLASS(R5),(R2)		; Else, return characteristics
70$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Get device dependend info
	JMP	G^EXE$FINISHIO			; Complete the I/O request

80$:	BSBW	CHECK_P2			; Check P2 buffer
	CLRL	IRP$L_MEDIA(R3)			; Clear PSI never passes P1
	PUSHR	#^M<R4,R6>
	MOVW	S^#SS$_NORMAL,IRP$L_MEDIA+6(R3)	; Assume success
	SUBL3	#LAPB$K_ERREND,#LAPB$K_ERRSTRT,R6 ; Set size of LAPB error buffr
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Set address of protocol buffer
	BNEQ	85$				; If NEQ then buffer exists
	MOVW	#0,IRP$W_BCNT(R3)		; Else return no errors read
	BRB	55$
85$:	CMPW	R1,R6				; IF gequ then buff is large
	BGEQU	90$				; enough
	MOVW	#SS$_BUFFEROVF,IRP$L_MEDIA+6(R3) ; Set error
	MOVW	R1,R6
90$:	MOVW	R6,IRP$W_BCNT(R3)		; Set size of transfer
	PUSHR	#^M<R3,R4,R5>
	MOVC3	R6,LAPB$K_ERRSTRT(R4),(R2)	; Copy counters to user buffer
	POPR	#^M<R3,R4,R5>
	CLRB	LAPB$B_DEI(R4)			; Clear the counter
	POPR	#^M<R4,R6>
	BRB	55$				; Jump to complete the req

	.SBTTL	SENSE_MODEM - Perform SENSEMODE READ_MODEM FDT processing
;++
;SENSE_MODEM - Perform SENSEMODE READ_MODEM FDT processing
;
; This routine performs all FDT checking for a SENSEMODE read modem reqeust.
; The P1 buffer is checked for write access and the request is queued to
; the driver.
;
;	Inputs:
;		R3 = IRP address
;		R4 = PCB address
;		R5 = UCB address
;		R7 = Fucntion code
;
;	Outputs
;		R0 = Status for return 
;		R3-R5 are preserved
;--
SENSE_MODEM:
	MOVZWL	S^#4,R1				; Size of P1 buffer
	BSBW	CHECK_P1			; Check access to P1
						; (no return on no access)
	BSBW	ALLOC_P2BUF			; Allocate a P2 buffer
	BLBS	R0,10$				; Branch if success
	BRW	ABORTIO				; Else abort the request

10$:	MOVL	IRP$L_SVAPTE(R3),R1		; Get system buffer address
	MOVL	IRP$L_MEDIA(R3),P2B_L_BUFFER(R1) ; Set user buffer VA
	CLRL	IRP$L_MEDIA(R3)			; Clear buffer
	MOVB	#XG_FC_V_READ_MODEM,IRP$B_XGFUNC(R3) ; Set funcition
	;BRB	QUEPKT				;Give request o driver


;
; I/O request packet to driver
;
QUEPKT:
	SETIPL	UCB$B_FIPL(R5)			; Queue packet to driver
	JSB	G^IOC$INITIATE			; Initiate I/O reuqest
	JMP	G^EXE$QIORETURN			; Lower IPL, and return


	.SBTTL	GET_CHAR_BUFS,  Get P1 and P2 characteristics buffers
 
;++
; GET_CHAR_BUFS - Get P1 and P2 characteristics buffers
;
; Functional description:
;
; This routine saves the P1 and P2 buffers for later use by the driver.
; The P1 buffer is saved in the IRP (IRP$L_MEDIA) as a quadword value.
; The P2 buffer is saved by allocating the appropriate amount of memory from
; non-paged pool.   The user's quota is checked before the allocation is made.
; And the non-paged pool buffer is charged against the user's quota. The P2
; system buffer address is passed in IRP$L_SVAPTE of the IRP.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status of buffers
;
;	R3-R5 are preserved.
;
;--
 
GET_CHAR_BUFS:					; Get characteristics buffers
;
; Check access to P1 buffer and save P1 characteristics
;
	CLRQ	IRP$L_MEDIA(R3)			; Reset P1 chars
	MOVL	P1(AP),R2			; Get address of P1 char buf
	BEQL	10$				; Branch if no P1 buffer
	MOVZWL	#SS$_ACCVIO,R0			; Assume access violation
	IFNORD	#8,(R2),20$			; Check access
	MOVQ	(R2),IRP$L_MEDIA(R3)		; Save P1 characteristics
	MOVB	#1,IRP$L_MEDIA(R3)		; Indicate valid P1 buffer
;
; Check access to P2 buffer and check process's buffer quota
;
10$:	MOVL	P2(AP),R2			; Get address P2 char buf desc
	BEQL	40$				; Br if no P2 buffer
	MOVZWL	#SS$_ACCVIO,R0			; Assume access violation
	IFNORD	#8,(R2),20$			; Check access to descriptor
	MOVZWL	(R2),R1				; Get buffer length in bytes
	BICL	#1,R1				; Must be multiple of 2 bytes
	BEQL	40$				; Br if size is zero
	MOVL	DSC$A_POINTER(R2),R2		; Get buffer address
	MOVL	R2,R0				; Copy buffer address
	PUSHR	#^M<R2,R3>			; Save R2, R3
	JSB	G^EXE$WRITECHKR			; Check entire buffer
	BLBC	R0,15$				; Branch if error
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
15$:	POPR	#^M<R2,R3>			; Restore R2, R3
	BLBS	R0,30$				; Branch if quota ok
20$:	RSB					; Return
 
;
; Quota OKAY, allocate buffer and copy info.
;
30$:	BSBW	ALLOC_P2BUF			; Allocate buffer
	BLBC	R0,50$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R0		; Get P2 buffer address
	PUSHR	#^M<R3,R4,R5>			; Save sacred registers
	MOVC3	R1,(R2),P2B_T_DATA(R0)		; Save P2 char buffer
	POPR	#^M<R3,R4,R5>			; Restore registers
40$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success
50$:	RSB					; Return

	.SBTTL	CHECK_BUFS,  Check P1 and P2 buffers for write access
 
;++
; CHECK_BUFS - Check P1 and P2 buffers for write access
;
; Functional description:
;
; This routines checks the P1 and P2 buffers for write access if supplied.
;
; Inputs:
;
;	R1 = Size of P1 buffer needed for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;	R9 = CDB address
;
; Outputs:
;
;	R1 = Length of P2 buffer (zero if no P2 buffer)
;	R2 = Address of P2 buffer in user's process space
;
;	R0-R2 are destroyed.
;
;	No RETURN on NO ACCESS
;
; Implicit Outputs:
;
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--
 
CHECK_BUFS:
	BSBB	CHECK_P1			; Check P1 buffer
CHECK_P2:
	CLRL	R1				; Assume no P2 buffer desc
	MOVL	P2(AP),R2			; Get address of P2 desc
	BEQL	10$				; Br if no P2
	IFNORD	#8,(R2),ACCESS			; Br if no access
	MOVZWL	(R2),R1				; Get length of buffer
	BICL	#1,R1				; Must be multiple of 2 bytes
	BEQL	10$				; Br if zero
	MOVL	DSC$A_POINTER(R2),R0		; Get buffer address
	JSB	G^EXE$READCHK			; Check write access to buffer
						; (no return no access)
						; Also sets IRP$V_FUNC in IRP
	MOVL	R0,R2				; Copy buffer address
10$:	RSB					; Return to caller
 
ACCESS:	MOVZWL	#SS$_ACCVIO,R0			; Return access violation
	BRW	ABORTIO				; Abort the I/O request

	.SBTTL	CHECK_P1,  Check P1 buffer address for write access
 
;++
; CHECK_P1 - Check P1 buffer address for write access
;
; Functional description:
;
;  This routine checks the P1 buffer and if okay, the buffer address
;  is saved in IRP$L_MEDIA of the IRP.
;
; Inputs:
;
;	R1 = Size of buffer for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;	R9 = CDB address
;
; Outputs:
;
;	R0 is destroyed.
;
;	No RETURN on NO ACCESS.
;
; Implicit Outputs:
;
;	IRP$L_MEDIA(R3) = User P1 buffer address.
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--

CHECK_P1:
	CLRL	IRP$L_MEDIA(R3)			; Assume no P1 buffer
	MOVL	P1(AP),R0			; Get address of user buffer
	BEQL	10$				; Br if none
	JSB	G^EXE$READCHK			; Check access to buffer
						; (No return - no access)
	MOVL	R0,IRP$L_MEDIA(R3)		; Save P1 buffer address in IRP
10$:	RSB					; Return to caller

	.SBTTL	ALLOC_P2BUF,  Allocate a P2 buffer and charge user's quota
 
;++
; ALLOC_P2BUF - Allocate a P2 buffer and charge user's quota
;
; Functional description:
;
; This routine allocates a system buffer and returns the address in the IRP at
; IRP$L_SVAPTE.  The size of the allocation, including buffer header must
; be at least 24 bytes in length.
;
; Inputs:
;
;	R1 = Size of allocation desired
;	R3 = IRP address
;
; Outputs:
;
;	R0 = status of request
;
;	R1-R5 are preserved.
;
; Implicit Outputs:
;
;	IRP$L_SVAPTE(R3) = address of system buffer
;	IRP$W_BOFF(R3) = byte count charged to user's process
;	IRP$W_BCNT(R3) = original byte count requested
;
;	All parts of the P2 buffer header are initialized, except for the
;	user's P2 buffer address.
;
;--
 
ALLOC_P2BUF:					; Allocate a non-paged buffer
	TSTL	R1				; Zero length buffer?
	BEQL	30$				; Br if yes
	PUSHR	#^M<R1,R2,R3>			; Save registers
	MOVW	R1,IRP$W_BCNT(R3)		; Save original byte count
	CMPL	R1,S^#24-P2B_C_LENGTH		; Is buffer big enough?
	BGTRU	5$				; Br if yes
	MOVL	S^#24-P2B_C_LENGTH,R1		; Else, set size to minimum
5$:	ADDL2	S^#P2B_C_LENGTH,R1		; Add in size of header
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	BLBC	R0,10$				; Branch if quota bad
;
; Quota OKAY, allocate buffer and copy info.
;
	PUSHL	R1				; Save size to charge user
	JSB	G^EXE$ALONONPAGED		; Go allocate a buffer
	BLBS	R0,20$				; Br if success
	TSTL	(SP)+				; Pop saved size
10$:	POPR	#^M<R1,R2,R3>			; Restore registers
	RSB					; Return with error code in R0
;
; System buffer allocated decrement user's quota
;
20$:	POPL	R3				; Restore user quota charge
	MOVAB	P2B_T_DATA(R2),P2B_L_POINTER(R2) ; Set address to start of data
	MOVW	R3,P2B_W_SIZE(R2)		; Save buffer size in buffer
	MOVB	S^#DYN$C_BUFIO,P2B_B_TYPE(R2)	; Set structure type
	MOVL	R2,R0				; Save P2 char buf addr
	MOVL	PCB$L_JIB(R4),R2		; Get JIB address
	SUBL	R3,JIB$L_BYTCNT(R2)		; Decrement user's quota
	POPR	#^M<R1,R2,R3>			; Restore registers
	MOVL	R0,IRP$L_SVAPTE(R3)		; Save P2 buffer address in IRP
	MOVW	P2B_W_SIZE(R0),IRP$W_BOFF(R3)	; Return buffer size in IRP
30$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success
	RSB					; Return to caller

	.SBTTL	CHG_UCB,  Change UCB parameter values
 
;++
; CHG_UCB - Change UCB parameter values
;
; Functional description:
;
; This routine is called to initialize the UCB with new P1 and P2 buffer
; characteristics. It is assumed here that the parameters have already
; been validated.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R6 = Protocol mode in which to run the driver 
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 = destroyed.
;
;--
 
CHG_UCB:					; Change UCB parameters
	PUSHL	R4				; Save R4
;
; Call to set the start up default characteristics for a given protocol
;
	BSBW	SET_DEFAULT_CHAR

	BLBC	IRP$L_MEDIA(R3),10$		; Br if no P1 buffer
;
; Set new P1 buffer characteristics. We will use the P1 buffer if no
; protocol or the DDCMP protocol was specified in the P2 buffer.
; There is no interface to set LAPB or BISYNC via the P1 buffer.
;
	CMPB	#XG$C_PROTYPE_DDCMP,UCB$B_XG_PROTYPE(R5) ; If not DDCMP then can
	BNEQ	10$				; not use P1 buffer
	BBS	#XG_DS_V_INITED,-		; Br if device inited
		UCB$W_DEVSTS(R5),5$ 
	MOVW	IRP$L_MEDIA+2(R3),-		 ; Set new buffer size
		UCB$W_DEVBUFSIZ(R5)
5$:	INSV	#0,#8,#24,UCB$L_DEVDEPEND(R5)	; Reset all Read/Write flags
	BISL	IRP$L_MEDIA+4(R3),-		; Set new characteristics
		UCB$L_DEVDEPEND(R5) 
;
; Now update UCB based on P1 buffer
;
	ASSUME	NMA$C_LINPR_POI EQ 0

	CLRB	UCB$B_XG_PRO(R5)		; Assume point to point mode
	BBC	#XM$V_CHR_TRIB,UCB$L_DEVDEPEND(R5),6$ ; Branch BC ddcmp point
	MOVB	#NMA$C_LINPR_TRI,UCB$B_XG_PRO(R5) ; Else must be a trib station

	ASSUME	NMA$C_LINCN_NOR EQ 0

6$:	CLRB	UCB$B_XG_CON(R5)		; Assume normal mode
	BBC	#XM$V_CHR_LOOPB,-		; Br if not loopback mode
		UCB$L_DEVDEPEND(R5),7$		;
	ASSUME	NMA$C_LINCN_LOO EQ 1
	INCB	UCB$B_XG_CON(R5)		; Must be loopback mode
7$:	ASSUME	NMA$C_DPX_FUL EQ 0
	CLRB	UCB$B_XG_DUP(R5)		; Assume full duplex
	BBC	#XM$V_CHR_HDPLX,-		; Br if not half duplex
		UCB$L_DEVDEPEND(R5),10$		;
	ASSUME	NMA$C_DPX_HAL EQ 1
	INCB	UCB$B_XG_DUP(R5)		; Must be half duplex

;
; Set new P2 buffer characteristics
;
10$:	MOVL	R5,R4				; Copy UCB address
	MOVAB	LINE_PARAM,R1			; Get address of verification table
	BSBW	UPDATE_P2			; Update the UCB
;
; Set device characteristics and device mode definition
;
	CLRB	UCB$L_DEVDEPEND(R5)		; Reset all characteristics

	ASSUME	NMA$C_LINPR_POI EQ 0
	ASSUME	NMA$C_LINPR_TRI EQ 2
	ASSUME	NMA$C_LINPR_LAPB EQ 5
	ASSUME	NMA$C_LINPR_BSY EQ 9

	MOVZBL	UCB$B_XG_PRO(R5),R2		; Get protocol mode
	BEQL	20$				; Br if point to point mode
	CMPB	R2,#NMA$C_LINPR_LAPB		; If LAPB or BISYNC branch
	BGEQU	20$ 
	SETBIT	#XM$V_CHR_TRIB,-		; Indicate tributary station
		UCB$L_DEVDEPEND(R5) 		; If noother prot set then TRIB
20$:	SETBIT	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5) ; Assume half duplex mode
	ASSUME	NMA$C_DPX_FUL EQ 0
	TSTB	UCB$B_XG_DUP(R5)		; Full duplex mode?
	BNEQ	30$				; Br if no - okay
	CLRBIT	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5) ; Set to full duplex mode
30$:	ASSUME	NMA$C_LINCN_NOR EQ 0
	TSTB	UCB$B_XG_CON(R5)		; Is line in normal mode?
	BEQL	40$				; Br if yes
	SETBIT	#XM$V_CHR_LOOPB,UCB$L_DEVDEPEND(R5) ; Set loopback mode
40$:	POPL	R4				; Restore R4
	RSB


	.SBTTL	SET_DEFAULT_CHAR, Set default characteristics for given protocol

;++
; SET_DEFAULT_CHAR - Set default characteristics for given protocol
;
; This routine sets the default start up characteristics for a given
; protocol supported by the driver.
;
;	INPUTS	R5 = UCB address
;		R6 = Protocol type 
;
;	OUTPUTS All registers are preserved
;
;--
SET_DEFAULT_CHAR:
	PUSHR	#^M<R0,R1,R2>
	MOVAB	UCB$Z_XG_SYNC(R5),R2		; Set address of parameters
;
; Assume that the protocol type will be DDCMP, thus set all the block of
; defaults to point to DDCMPS'.
;

	MOVZWL	#DEF_SYNC_PARAMSZ,R0		; Set size of defaults
	MOVAB	DEF_SYNC_PARAM,R1		; Set address of defaults
	MOVB	#XG$C_PROTYPE_DDCMP,UCB$B_XG_PROTYPE(R5) ; Set prot type
;
; Check to see if one of the other protocols has been specified and it so
; then change the pointers to point at their defaults. We must use the
; compares here, becaues the UCB$B_XG_PROTYPE field has not as yet been
; set up.
;
	CMPB	#NMA$C_LINPR_LAPB,R6
	BEQL	20$
	CMPB	#NMA$C_LINPR_BSY,R6
	BEQL	30$
10$:	MOVB	(R1)+,(R2)+			; Set next default
	SOBGTR	R0,10$				; Loop on all parameters
	POPR	#^M<R0,R1,R2>
	RSB
;
; Set default pointers for LAPB
;
20$:	MOVZWL	#DEF_LAPB_PARAMSZ,R0		; Set size of defaults
	MOVAB	DEF_LAPB_PARAM,R1		; Set address of defaults
	MOVB	#XG$C_PROTYPE_LAPB,UCB$B_XG_PROTYPE(R5) ; Set prot type
	BRB	10$
;
; Set default pointers for BISYNC
30$:	MOVZWL	#DEF_BISYNC_PARAMSZ,R0		; Set size of defaults
	MOVAB	DEF_BISYNC_PARAM,R1		; Set address of defaults
	MOVB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; Set prot type
	BRB	10$


	.SBTTL	CHG_TRIB,  Change trib parameter values
 
;++
; CHG_TRIB - Change trib parameter values
;
; Functional description:
;
; This routine is called to initialize the trib parameter block with 
; new P1 and P2 buffer characteristics. It is assumed here that the 
; parameters have already been validated.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R1,R2 = destroyed.
;--
 
CHG_TRIB:					; Validate P2 buffer
	PUSHL	R4				; Save R4
	MOVAB	TRIB_PARAM,R1			; Get addre of verify table
	MOVAB	UCB$Z_XG_DDCMP(R5),R4		; Get the addr of param block
	BLBC	IRP$L_MEDIA(R3),10$		; Br if no P1 buffer
;
; Set new P1 buffer characteristics
;
	BISL	IRP$L_MEDIA+4(R3),UCB$L_DEVDEPEND(R5) ; Set new char

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	CLRB	DLK$B_MAINT(R4)			; Assume MOP
	BBS	#XM$V_CHR_MOP,UCB$L_DEVDEPEND(R5),10$ ; Branch BS if true
	INCB	DLK$B_MAINT(R4)			; Set NORMAL mode
;
; Set new P2 buffer characteristics
;
10$:	BSBW	UPDATE_P2			; Update trib parameters
	CLRBIT	#XM$V_CHR_MOP,UCB$L_DEVDEPEND(R5) ; Assume NORMAL mode
	BLBS	DLK$B_MAINT(R4),20$		; Branch LBS if true
	SETBIT	#XM$V_CHR_MOP,UCB$L_DEVDEPEND(R5) ; Set MOP mode
20$:	POPL	R4				; Restore R4
	RSB					; Return to caller


	.SBTTL	STARTIO - Start setmode I/O operation
;++
; STARTIO - Start setmode operation
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is entered to process a setmode request.  All setmode requests
; are queued through the UCB to single-stream them.
;
; SETMODE FUNCTIONS --
;
;	For all functions a change in the characteristics is done.
;
;	For control startup, the UCB is initialized; mapping registers for
;	receives and transmits are allocated and saved in the UCB; and the
;	DMF sync line is master reset.
;	For trib startup, the DMF sync line is loaded with its char; the
;	protocol is set up with charateristics and started; and finally
; 	transmits and receives are started on the board.
;
;	For control shutdown, mapping registers are deallocated and returned;
;	all quotas are returned; and a call is made to trib shutdown to shut
;	the trib.
;	For trib shutdown, the device is master cleared; all buffers and
;	IRP's are returned; and the protocol is halted.
;
; INPUTS:
;
;	R3 = I/O packet address
;	R5 = UCB address
;
; OUTPUTS:
;
;	R3 and R5 preserved.
;--
	.ENABL	LSB
STARTIO:					; Start I/O routine
	MOVZBL	IRP$B_XGFUNC(R3),R1		; Get the function code
	CMPB	#XG_FC_V_STRT_LIN,R1		; If EQL then start the line
	BEQL	10$
	BSBB	START_DISP			; Branch to case
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device characteristics
	REQCOM					; Complete the request

START_DISP:
	$DISPATCH	R1,TYPE=B,-
	<-	; Function		Action
		<XG_FC_V_STRT_CIR	START_CIRCUIT>,-
		<XG_FC_V_STRT_LIN		5$>,-
		<XG_FC_V_STOP_CIR	SHUTDOWN_CIRCUIT>,-
		<XG_FC_V_STOP_LIN	SHUTDOWN_LINE>,-
		<XG_FC_V_READ_MODEM	READ_MODEM>,-
	>

5$:	BUG_CHECK NOBUFPCKT,FATAL		; Anything else is fatal

10$:	BRW	START_LINE			; Branch to start the line

	.DSABL	LSB


	.SBTTL	START_TRANSMIT - Start transmit I/O
;++
; START_TRANSMIT - Start transmit I/O
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is entered to start a transmit I/O operation. It will call the
; routine LOAD_XMT_MPR to see if there is a transmit to give the board. If a 
; transmit is loaded, this routine sets the enable bit on the board to initiate
; sending of the data.
;
;
; **** NOTE ****
;
; Must be sure when setting up the indirect register in misc register
; that Master Reset is not accidentially set!!!!
;
;
; INPUTS:
;	R1 = Status information from routine calling START_TRANSMIT
;	     More specifically it is an interface between the protocol
;	     timer routine and this routine to tell start transmit that
;	     the protocol timer has expired therefore send the message.
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	NONE
;
;	*** NOTE ***
; 
; If the device is running in LAPB 30$ should never be called!
;--
START_TRANSMIT:
;
; If the DDCMP timer has expired a message may need to be sent
;
	BBS	#DLK$V_TMREXPD,R1,5$
	BBS	#XG_DS_V_XMTING,-		; If BS then the xmt'r is off
		UCB$W_DEVSTS(R5),10$
5$:	CMPB	#XG$C_DRPCTS,UCB$B_XG_XSTATE(R5) ; If EQL CTS has not gone away
	BEQL	10$				; do not bring up RTS until
						; we are sure CTS has been
						; dropped - for real modems
	DSBINT	UCB$B_DIPL(R5)			; Disable device interrupts

	ASSUME XG$C_PRIXMT EQ 0

	BBS	#XG_DS_V_XMT_DONEP,UCB$W_DEVSTS(R5),9$ ; If BS do not q new xmt
	CLRL	R3				; Set to set up prim BACC
	MOVZBL	#XG$C_PRI_XMT,R2		; Set ind reg addr of prim
	BSBW	LOAD_XMT_MPR			; Load map registers and BACC
	BLBC	R0,30$				; No tranmsit given to board
	SETBIT	#XG_DS_V_XMT_DONEP,UCB$W_DEVSTS(R5) ; Set indicating that the
						; XMTCSR are is use
	SETIPL					; Sync to highest IPL
	BBS	#UCB$V_POWER,UCB$W_STS(R5),20$	; If BS then power fail occured
8$:	BISW	#XG$M_ENABLE,XG$C_XMT_CSR(R4)	; Else enable transmitter
	MOVL	G^EXE$GL_ABSTIM,R0		; get current time
	ADDL3	R0,UCB$L_XG_XMT_TIMEOUT(R5),UCB$L_XG_XMTEND(R5) ; Set timeout time
9$:	ENBINT					; Enable interrupts
10$:	MOVZWL	S^#SS$_NORMAL,R0		; Set status
	RSB

20$:	ENBINT					; Enable interrupts
	MOVZWL	#SS$_POWERFAIL,R0		; Set status
	RSB

30$:	ENBINT					; Enable interrupts
	MOVL	UCB$B_XG_PROTYPE(R5),R1		; Get protocol type
	CASE	R1,TYPE=B,<-
		35$,-				; LAPB
		35$,-				; Bisync
		>				; Fall thru on DDCMP
	TSTB	R0				; If EQL XMTer is idle
	BNEQ	35$				; Else wait for the interrupt 
						; from CTS being asserted
	MOVZBL	#DLK$C_XMTMSG,R6		; Inform DDCMP that the last
	MOVZBL	#DLK$M_QEMPTY,R7		; msg on queue was sent
	PUSHL	R5				; Save register
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Get addr of start of TFB
	BSBW	DDCMP				; Branch to protocol
	POPL	R5				; Restore register

	ASSUME DLK$V_MSGSENT EQ 0
	CMPB	#DLK$C_XMTMSG,R6		; If NEQ no ACK to be xmted
	BNEQ	35$
	BLBC	R7,35$				; If BC no  ACK need be sent
	CLRL	R1				; Set no status info
	BRW	START_TRANSMIT			; Else send the ACK
35$:	MOVZWL	S^#SS$_NORMAL,R0		; Set status
	RSB



	.SBTTL	Load Mapping registers and give to COMBO
;++
;LOAD_XMT_MPR - Load transmit mapping registers
;
; This routine gets a transmit out of the queue and sets up the mapping
; registers and BACC to give to COMBO. For simplicity only the primary
; buffer and character count is used. The tansmitter is allowed to be in
; three different states. The stopped state when there is no data to be
; transmitted. The wait for clear to send state when the transmitter
; has aserted request to send and is waiting for clear to send to come back.
; Finally the xmitting state when the transmitter has control of the line
; and can send data.
;
; This routine also does modem signal processing. For half duplex and tributary
; lines it sets RTS then puts the driver in a "Wait" for CTS to come back. If
; CTS dosen't come up in 1 microsecond the driver continues processing and 
; expects a special CTS timer or the device timer routine to watch for CTS to 
; come back. If the timer routine doesn't see CTS in a reasonable amount of 
; time (2 to 3 seconds) and the line is half duplex point to point , a fatal
; error is assumed. If the line is in trib then the timer will wait indefinitly
; for CTS to come high.If the line is in loopback these signals are not 
; checked. If the line is in full duplex RTS is never dropped.
;
;
;	INPUTS	R2 = Primary/secondary register to use
;		R3 = Vector slot to use
;		R5 = Address of the UCB
;		IPL = DIPL
;
;	OUTPUT
;		R4 = CSR address
;--
	.ENABL LSB
LOAD_XMT_MPR:
	PUSHR	#^M<R6,R8>
	MOVL	UCB$L_CRB(R5),R1		; Get the address of the CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; Get CSR address
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R6	; Set protocol buffer address
	REMQUE	@TF$Q_CTLQ(R6),R8		; Get next control message
	BVS	1$
	BRW	10$
1$:	REMQUE	@TF$Q_XMTQ(R6),R8		; Get the next message to XMT
	BVC	2$				; If VC then data to give COMBO
	CLRB	UCB$B_XG_XSTATE(R5)		; Set XMTer IDLE
	CLRL	R0				; Clear normal status
	POPR	#^M<R6,R8>			; Restore the reg
	RSB
;
; Return from CTS start timer
;
CTSRET:
	MOVB	#TQE$C_SSSNGL,TQE$B_RQTYPE(R5)	; Set single shot timer
	POPL	R5				; Restore R5
	MOVB	UCB$B_XG_XSTATE(R5),R0		; Set R0 for return
	RSB	

2$:	CMPB	XMTQ$B_BUFTYP(R8),S^#DYN$C_BUFIO ; If EQL then buff ok
	BEQL	10$
	BUG_CHECK	NOBUFPCKT,FATAL

4$:	CMPB	#XG$C_SWFCTS,UCB$B_XG_XSTATE(R5) ; If EQL then special wait
	BEQL	5$				; for CTS state from CTS TQE

	.IF	DF CTS$$$
	pushl	r0
	addl3	#1,ucb$b_cts_last(r5),r0	; get next free slot
	bicl	#^c<cts_size-1>,r0		; make mod of cts_size
	movb	r0,ucb$b_cts_last(r5)		; set new location to incr
	clrb	ucb$b_cts_buf(r5)[r0]		; make sure loc is zero
	popl	r0
	.ENDC					; DF CTS$$$ end

	MOVB	UCB$B_XG_TIMEOUT(R5),-		; Set number of seconds to wait
		UCB$B_XG_WFCTS_SEC(R5)		; for CTS to be detected
5$:	BBC	#XMTQ$V_CONTROL,XMTQ$B_FLAG(R8),6$ ; If cntrl msg put on CTLQ
	INSQUE	(R8),TF$Q_CTLQ(R6)		; Put the CTL msg back on queue
	BRB	8$				; Branch to start up tiemr
6$:	CMPB	XMTQ$B_BUFTYP(R8),S^#DYN$C_BUFIO ; If EQL then buff ok
	BEQL	7$
	BUG_CHECK	NOBUFPCKT,FATAL
7$:	INSQUE	(R8),TF$Q_XMTQ(R6)		; Put the XMT back on queue
8$:	MOVZBL	#XG$C_WFCTS,R0			; Set status in R0
	MOVB	R0,UCB$B_XG_XSTATE(R5)		; Set new XMTer state
	POPR	#^M<R6,R8>			; Restore regs
	BBSS	#XG_DS_V_CTSTQE_RUN,UCB$W_DEVSTS(R5),9$ ; If BS timer is q'd
	PUSHL	R5				; Save R5 across fork
	MOVAL	UCB$L_XG_TQE(R5),R5		; Get the CTS TQE block
	MOVB	#IPL$_QUEUEAST,TQE$B_RQTYPE(R5)	; Set IPL of fork process
	PUSHAB	B^CTSRET			; Set return address
	PUSHAW	W^START_TIMER			; Set addr of CTS TQE start 
	JMP	G^EXE$FORK

9$:	RSB	

; Set RTS and wait for CTS

10$:	BBS	#XM$V_CHR_LOOPB,-		; If BS then loopb don't check
		UCB$L_DEVDEPEND(R5),12$		; modem signals
	CMPB	#NMA$C_LINPR_LAPB,UCB$B_XG_PRO(R5) ; If EQL LAPB don't check
	BEQL	12$				; modem signals
	CMPB	#XG$C_SWFCTS,UCB$B_XG_XSTATE(R5) ; If EQL then special wait
	BEQL	13$				; for CTS state from CTS TQE
	TSTB	UCB$B_XG_XSTATE(R5)		; If NEQ then XMTer not idle
	BNEQ	15$
11$:	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Get the indr modem reg
	BISW	#XG$M_RTS,XG$C_IND_ADDR(R4)	; Set RTS
	BBC	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5),13$
;	BITW	#XG$M_CARRIER,XG$C_IND_ADDR(R4)
;	BNEQ	14$
	BRB	4$				; Always wait for CTS

13$:	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Get the indr modem reg
	TIMEWAIT #1,#XG$M_CTS,XG$C_IND_ADDR(R4),W
	BLBS	R0,12$				; If LBS then CTS was detected
14$:	BRW	4$				; Else, start timers

12$:	MOVB	#XG$C_XMTING,-			; Set XMTer state on
		UCB$B_XG_XSTATE(R5)
15$:	CMPB	#XG$C_WFCTS,UCB$B_XG_XSTATE(R5)	; If EQL then XMTer waiting for
	BNEQ	17$				; CTS
	BRW	5$				; Else, check timers

; Else mark the slot inuse and create buffer address / character count image

17$:	PUSHR	#^M<R2,R4>			; Save registers
	BICB2	#XMTQ$M_ONQUEUE,XMTQ$B_FLAG(R8)	; Mark that the msg was sent
	BBS	#XMTQ$V_CONTROL,XMTQ$B_FLAG(R8),18$ ; If control msg don't incr
;
; The INCB applies only when the driver is running in DDCMP mode. The 
;  next instruction is a NOOP when running in BISYNC and LAPB mode. However,
; since DDCMP is the protocol that needs to run the fastest, we opted
; note to code around this instruction, but instead just allocate a byte
; in each of the protocol buffers to allow falling thru this instruction.
; When reading the code you will notice that there is an XQCNT location
; in the data structures of each of the buffers allocated to the protocols.
;
	INCB	TF$B_XQCNT(R6)			; Incr implies 1 less msg on Q
18$:	BBCC	#XMTQ$V_SELECT,-		; If BC then select flag not
		XMTQ$B_FLAG(R8),20$		; set don't turn link
	BISW2	#XG_DS_M_XMTING,-		; Set transmitter off but 
		UCB$W_DEVSTS(R5)		; finish sending this msg
20$:	MOVAL	XMTQ$B_MSGHDR(R8),R2		; Get address of data to send
	MOVAL	UCB$Z_XG_VECTOR(R5)[R3],R4	; Get the slot to use
	MOVL	R2,XMTQ$L_BACC(R8)		; Get the message offset
	MOVW	XMTQ$W_MSGSIZE(R8),-		; Set the char count
		XMTQ$L_BACC+2(R8)
	INSV	(R4),#9,#7,XMTQ$L_BACC(R8)	; Insert the map register
	EXTZV	#7,#2,(R4),R0			; Get the high two bits
	INSV	R0,#30,#2,XMTQ$L_BACC(R8)	; Insert into high bits
	TSTL	UCB$Z_XG_XMT_INPR(R5)[R3]	; Check to make sure we aren't
	BNEQ	40$				; overwriting a XMT inprogress
	MOVL	R8,UCB$Z_XG_XMT_INPR(R5)[R3]	; Store the addr of buff'r sent
	INCB	UCB$B_XG_XMTCNT(R5)		; Incr the no of outstndng XMTs

; Build UBA map registers and load the map

	BICW3	#^C<VA$M_BYTE>,R2,-		; Store the message offset
		UCB$W_BOFF(R5)
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R2	; Get the virtual page number
	MOVL	G^MMG$GL_SPTBASE,R0		; Get the address of SPT entry
	MOVAL	(R0)[R2],UCB$L_SVAPTE(R5)	; Set address of SPT entry
	MOVW	XMTQ$W_MSGSIZE(R8),-		; Get the byte count
		UCB$W_BCNT(R5)
	MOVL	UCB$L_CRB(R5),R1		; Get the address of the CRB
	MOVL	(R4),-				; Set starting map register
		CRB$L_INTD+VEC$W_MAPREG(R1)
	JSB	G^IOC$LOADUBAMAPA		; Load the map register
	POPR	#^M<R2,R4>			; Restore the registers
	MOVW	R2,XG$C_MISC_REG(R4)		; Load into indirect register
	MOVW	XMTQ$L_BACC(R8),-		; Load buffer address
		XG$C_IND_ADDR(R4)
	MOVW	XMTQ$L_BACC+2(R8),-		; and character count
		XG$C_IND_ADDR(R4)
	BICW2	#XG$M_PRM_SEC,XG$C_XMT_CSR(R4)	; Since only one is ever loaded
						; be sure this bit is always
						; cleared
	MOVZWL	S^#SS$_NORMAL,R0		; Set BACC loaded
30$:	POPR	#^M<R6,R8>
	RSB
	.DSABL	LSB

40$:	BUG_CHECK	NOBUFPCKT,FATAL



;++
;START_TIMER - Start up for CTS TQE
;
; This routine starts up the CTS TQE which times the return of CTS after
; setting RTS.
;
;	INPUTS	R5 = Adress of TQE block
;		IPL = Queueast IPL
;
;	OUTPUT: Entry added to timer queue
;
;--
START_TIMER:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save the registers
	MOVAL 	G^CTS_TIMER,TQE$L_FPC(R5)	; Set the addr of timer wakeup
	MOVQ	G^EXE$GQ_SYSTIME,R0		; Set time
	DSBINT	#IPL$_TIMER			; Sync to timer IPL
	JSB	G^EXE$INSTIMQ			; Give to timer queue
	ENBINT
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	RSB

	.SBTTL	READ_MODEM - Read device modem register
;++
;READ_MODEM - Read device modem register
;
; This routine returns the device modem register in the buffer passed.
; These are set according to the XMDEF's for modem bits.
;
;	Inputs:
;		R3 = IRP address
;		R5 = UCB address
;
;--
READ_MODEM:
	BBS	#XG_DS_V_INITED,UCB$W_DEVSTS(R5),5$ ; If BS then read register
	MOVZWL	#SS$_DEVINACT,R0		; Else return device inactive
	RSB

5$:	PUSHL	R4
	MOVL	UCB$L_CRB(R5),R4		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get device CSR
	DSBINT	UCB$B_DIPL(R5)			; Sync to device IPL
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Set to read modem register
	MOVZWL	XG$C_IND_ADDR(R4),R1		; Read modem register
	ENBINT					; Enable interrupts
	MOVL	IRP$L_SVAPTE(R3),R4		; Get address of buffer
	CLRL	R0
	BBC	#XG$V_CTS,R1,10$		; BC CTS is not set
	SETBIT	#XM$V_MDM_CTS,R0		; Set CTS for return
10$:	BBC	#XG$V_CARRIER,R1,20$
	SETBIT	#XM$V_MDM_CARRDET,R0
20$:	BBC	#XG$V_RING_IND,R1,30$
	SETBIT	#XM$V_MDM_RING,R0
30$:	BBC	#XG$V_DSR,R1,40$
	SETBIT	#XM$V_MDM_DSR,R0
40$:	BBC	#XG$V_DTR,R1,50$
	SETBIT	#XM$V_MDM_DTR,R0
50$:	BBC	#XG$V_RTS,R1,60$
	SETBIT	#XM$V_MDM_RTS,R0
60$:	MOVL	R0,P2B_T_DATA(R4)		; Return modem signals
	POPL	R4
	MOVZWL	S^#SS$_NORMAL,R0
	RSB


	.SBTTL	CLEAN - Abort all outstanding XMT's (All IO's for BISYNC)
;++
; CLEAN - Abort all outstanding XMT's (all IO's for BISYNC)
;
; This routine aborts all outstanding XMT's on the device when running
; in LAPB mode and all outstanding IO's when running in BISYNC protocol
; mode. To do this it syncs to device IPL takes all XMT's off
; the queues, puts them temporarily on another queue, then check for 
; in XMT inprogress. If an XMT is in progress, we can not just stop it
; the board won't like it, therefore we set a bit saying when
; this XMT ends complete it with an abort status and complete all the 
; outstanding XMT's then complete the CLEAN request. If no XMT is
; in progress then all XMT's are taken from the temporary queue and
; complete via IOPOST. Remember they are completed at FIPL, therefore
; if we took them from the device queue at a lowered IPL, completed the xmt
; then raised IPL; we may allow xmt's to complete normally.
;
; Note any XMT in the post queue is complete in error. This is done because
; there is no way to determine if the clean was issued before or after
; the XMT actually completes. This method also provides less risk of getting
; XMT's completed out of order
;
;	INPUTS: R3 = IRP address
;		R5 = UCB address
;		IPL = FIPL
;
;	OUTPUTS R0 = Status
;		R3 = IRP address
;		R5 = UCB address
;
; Clean_fork_entry
;	Input	R1 = Allocated buffer address
;		R3 = IRP of outstanding IO
;		R4 = Address of the protoocl work buffer
;		R5 = UCB address
;		IPL = FIPL
;
;--
	.ENABL LSB
CLEAN:
	MOVL	R3,UCB$A_XG_CLEAN(R5)		; Save CLEAN IRP address
	CLRL	R3				; Clear R3
	DSBINT	UCB$B_DIPL(R5)			; Sync to clear device queue
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Set protocol buffer address
	ASSUME	XG$C_PROTYPE_LAPB EQ 0
	TSTB	UCB$B_XG_PROTYPE(R5)		; If neql then must be bisync
	BNEQ	15$				; so take xmts off bisycn queue
10$:	REMQUE	@LAPB$Q_XMTQ(R4),R1		; Get next xmt
	BVS	20$
	INSQUE	(R1),@LAPB$Q_CLEANQ+4(R4)	; Put on clean queue
	BRB	10$				; get next xmt

15$:	REMQUE	@BISYNC$Q_XMTQ(R4),R1		; Get next xmt
	BVS	20$
	INSQUE	(R1),@BISYNC$Q_CLEANQ+4(R4)	; Put on clean queue
	BRB	15$				; get next xmt

20$:	MOVL	UCB$L_CRB(R5),R1		; Get CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1	; Get CSR address
	BICW2	#XG$M_ENABLE,XG$C_XMT_CSR(R1)	; Clear the enable bit
	TSTB	UCB$B_XG_XMTCNT(R5)		; IF NEQ zero xmt inpr
	BNEQ	50$				; Branch to await completion
	ENBINT					; Set to FIPL

CLEAN_FORK_ENTRY:
	CMPB	#XG$C_PROTYPE_DDCMP,UCB$B_XG_PROTYPE(R5) ; If EQL then BUG
	BEQL	60$
	TSTL	R3				; IF EQL then not from FORK
	BEQL	30$
	MOVL	R0,IRP$L_MEDIA(R3)		; Status of IO is set in R0
	BSBW	TRANSMIT_IO_DONE		; Complete req in R3
30$:	MOVAL	UCB$Q_XG_POST(R5),R0		; Get the address of queue head
	MOVL	(R0),R1				; Get the first entry
32$:	CMPL	R0,R1				; If equal than end of queue
	BEQL	37$
	CMPB	S^#DYN$C_BUFIO,IRP$B_TYPE(R1)	; If NEQ then not a transmit
	BNEQ	35$				; get next entry
	REMQUE	(R1),R1				; Else complete the request 
	MOVL	XMTQ$L_IRP(R1),R3		; Get address of IRP
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set abort status
	MOVL	(R1),R2				; Get next entry on queue
	PUSHR	#^M<R0,R2,R4>			; Save addr start of q and 
						; next entry
	BSBW	TRANSMIT_IO_DONE		; Complete request 
	POPR	#^M<R0,R1,R4>			; Restore address in of q head
						; and entry
	BRB	32$				; branch to check if XMT
35$:	MOVL	(R1),R1				; Get next entry
	BRB	32$				; branch to check for XMT
37$:	REMQUE	@LAPB$Q_CLEANQ(R4),R1		; Get buffer to complete
	BVS	40$				; If VS then done
	MOVL	XMTQ$L_IRP(R1),R3		; Get IRP address
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set abort status
	PUSHL	R4
	BSBW	TRANSMIT_IO_DONE		; Complete the request
	POPL	R4
	BRB	37$				; Get next buffer to complete
40$:	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; BISYNC?
	BNEQ	45$				; If NEQ then not
	BSBW	CLEAN_BISYNC			; Call to abort all IO'S
45$:	MOVL	UCB$A_XG_CLEAN(R5),R3		; Get REQ address
	CLRL	UCB$A_XG_CLEAN(R5)		; In case it gets called again
	MOVZWL	S^#SS$_NORMAL,IRP$L_MEDIA(R3)	; Set success
	BRW	IO_DONE

50$:	SETBIT	#XG_DS_V_CLEAN,UCB$W_DEVSTS(R5)	; Set to abort the xmt inpr
	ENBINT					; and other I/O and clean irp
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal ret
	MOVL	UCB$L_DEVDEPEND(R5),R1
	RSB
60$:	BUG_CHECK	NOBUFPCKT,FATAL

	.DSABL	LSB

;++
; CLEAN_BISYNC - Handle remainder of CLEAN work for BISYNC
;
; This routine aborts the remainder of the outstanding IO's from the driver,
; to statify the BISYNC clean request. Unlike in LAPB the receive
; IRP's must also be aborted when running in BISYNC mode. It also resets the
; state (UCB$Q_XG_STATE_INFO) of the framming routine.
;
; 	INPUTS	R4 = Address of protocol work buffer
;		R5 = Address of UCB
;
;	OUTPUTS All outstanding receive IRPs are aborted
;--
CLEAN_BISYNC:
	CLRBIT	#XG_DS_V_XMTING,UCB$W_DEVSTS(R5) ; Set transmitter back on
	BSBW	STOP_RCV_BISYNC			; Stop the device from rcving
	TSTL	R2				; Branch if eql no buffer 
	BEQL	10$				; to return to free list
	INSQUE	(R2),@UCB$Q_XG_FREE+4(R5)	; Return buffer to the list
10$:	REMQUE	@UCB$Q_XG_RCVS(R5),R3		; Abort all RCV IRP's
	BVS	20$
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)
	PUSHL	R4
	BSBW	IO_DONE
	POPL	R4
	BRB	10$
20$:	DSBINT	UCB$B_DIPL(R5)
	BSBW	START_RECEIVE_BISYNC		; Startup receiver
	ENBINT
	RSB


	.SBTTL	START - Start unit, device and/or protocol
;++
; START_LINE - Start unit
;
; Functional description:
;
; This routine initializes the UCB; allocates the map registers for
; transmits and receives; and master clears the device.
;
; If a failure occurs the line shutdown sequence is entered.
;
; INPUTS:
;
;	R3 = I/O packet
;	R5 = UCB address
;
; IMPLICIT INPUTS:
;
;	IRP$L_MEDIA contains a copy of the mode buffer specified by the user.
;	IRP$W_QUOTA contains the quota taken from the user for the unit.
;
; OUTPUTS:
;
;	The request is completed.
;--
START_LINE:					; Start protocol operation
	BBC	#XG_DS_V_INITED,-		; If BC then device not inited
		UCB$W_DEVSTS(R5),5$		; Branch to set up idle UCB
	MOVZWL	#SS$_DEVACTIVE,R0		; Set device active
	RSB					; ... and return

5$:	CLRB	UCB$B_XG_INUS(R5)		; Clear rcv slots in use mask
	BICL	#XG$C_LINE_PAR,UCB$L_DEVDEPEND(R5) ; Reset all Read/Write flags
	MOVW	IRP$W_QUOTA(R3),UCB$W_XG_QUOTA(R5) ; Set quota for RCV's
	CLRW	IRP$W_QUOTA(R3)			; Make quota consistent

; Using the default buffer size and the minimum line speed set up the 
; maximum amount of time to wait before timing out a transmit inprogress
; (that is after it has been given to the DMF32). This is to get around
; a problem where the DMF32 occasionaly loses clocking on the line and
; the transmit appears to get stuck. The alogorithm for this calculation
; is the following:
;
;	timeout_time = ((default_buffer_size * bits_per_char)/ minimum_baud_rate))+fudge_factor
;

	MOVZWL	UCB$W_DEVBUFSIZ(R5),R0
	MOVZBL	#XG$C_BPC_DEFAULT,R1
	MULL2	R0,R1
	DIVL2	#XG$C_BRG_DEFAULT,R1
	ADDL3	#2,R1,UCB$L_XG_XMT_TIMEOUT(R5)

	CLRL	UCB$L_XG_XMTEND(R5)		; make sure timeout time is zero

; Initialize the vector, which contains mapping information
; for each of the possible outstanding buffers.

	MOVZBL	#NUM_MAP_REG,R0			; Number of rcv vector slots
	MOVAL	UCB$Z_XG_VECTOR(R5),R1		; Get vector address
10$:	CLRW	(R1)+				; Init data path
	MNEGW	#1,(R1)+			; Indicate no map regs
	SOBGTR	R0,10$				; Continue for entire vector
	MOVL	IRP$L_PID(R3),UCB$L_XG_PID(R5)	; Save starter's PID
	MOVW	IRP$W_CHAN(R3),-		; Save channel number
		UCB$W_XG_CHANL(R5)
	BISW	#XG_DS_M_INITED,-		; Indicate UCB initialized
		UCB$W_DEVSTS(R5)
;
; Allocate map registers
;
	MOVW	UCB$W_DEVBUFSIZ(R5),-		; Set up to alloc the map regs
		UCB$W_BCNT(R5)
	MOVW	#511,UCB$W_BOFF(R5)		; Set worst case page cross
	MOVL	UCB$L_CRB(R5),R4		; Address unit CRB

	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1

	CLRL	CRB$L_INTD+VEC$W_MAPREG(R4) 	; Clear map register + datapath
	PUSHR	#^M<R6,R7>			; Save regs
	MOVAL	UCB$Z_XG_VECTOR(R5),R6		; Get vector address
	MOVZBL	#NUM_MAP_REG,R7			; Get number of slots to use
15$:	JSB	G^IOC$ALOUBAMAP			; Get map regs
	BLBC	R0,20$				; Br on error
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),-	; Save mapping info
		(R6)+ 
	SOBGTR	R7,15$				; Continue until done
20$:	POPR	#^M<R6,R7>			; Restore regs
	BLBC	R0,START_CTRL_ERROR		; Branch LBC error on start up
;
; Master clear the device
;
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get the CSR
	MOVL	UCB$L_IRP(R5),R3		; Pick up packet address

	BSBW	AWAIT_UNIT			; Await the unit
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	RSB

START_CTRL_ERROR:
	PUSHL	R0				; Save abort reason
	BSBW	SHUTDOWN_LINE			; Shut down the device
	POPL	R0				; Restore abort reason
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device charateristics
	REQCOM					; Complete the request




;++
; START_CIRCUIT- Start device and protocol
;
; Functional description:
;
; This routine sets up the protocol and device charateristics; sets up receive
; buffers for the device; starts the protocol; and finally gives the first
; transmit and receives to the board.
;
; If a failure occurs the circuit shutdown sequence is entered.
;
; INPUTS:
;
;	R3 = I/O packet
;	R5 = UCB address
;
; IMPLICIT INPUTS:
;
;	IRP$L_MEDIA contains a copy of the mode buffer specified by the user.
;
; OUTPUTS:
;
;	The request is completed.
;--
START_CIRCUIT:					; Start the circuit
	BBC	#XM$V_STS_ACTIVE,-		; If BC then device and
		UCB$L_DEVDEPEND(R5),5$		; protocol are not active
	MOVZWL	#SS$_DEVACTIVE,R0		; Return error
	RSB

5$:	BBS	#XG_DS_V_INITED,-		; If BS then line started
		UCB$W_DEVSTS(R5),8$
	MOVZWL	#SS$_DEVINACT,R0		; Else return device inactive
	RSB

8$:	BICW	#^C<XG_DS_M_INITED!-		; Reset bit fields
		XG_DS_M_CTSTQE_RUN>,-
		UCB$W_DEVSTS(R5)
	BICL	#XG$C_CIR_PAR,UCB$L_DEVDEPEND(R5) ; Reset all Read/Write flags

	ASSUME	XG$C_IDLE EQ 0
	ASSUME	XG$C_XMTING EQ 1
	ASSUME	XG$C_WFCTS EQ 2
	ASSUME	XG$C_SWFCTS EQ 4

	CLRB	UCB$B_XG_XSTATE(R5)		; Set XMTer state to idle
	CLRB	UCB$B_XG_XMTCNT(R5)		; Clear the no xmt's outstnd'n
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR(R5) ; Rcv inpr list
;
; Reinitialize the queue headers is case BISYNC protocol was run last 
; in which case these fields will no longer look like queues.
;
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR(R5) ; Rcv inpr list
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR+4(R5)
	BSBW	SET_CHAR			; Set protocol char
	MOVL	UCB$L_CRB(R5),R4		; Get the CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get the CSR address
	DSBINT	UCB$B_DIPL(R5)			; Lock out interupt from device
	BSBW	SET_UNIT_DDCMP			; Set char for DDCMP
	SETIPL	#IPL$_POWER			; Interlock powerfail
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$	; BR if no power failed
	ENBINT					; Enable intterrupts at FIPL
	BRB	START_POWERFAIL			; Branch to report powerfail
10$:	BISW	#XM$M_STS_ACTIVE,-
		UCB$L_DEVDEPEND(R5)		; Set active state
	ENBINT					; Return to fork IPL
	MOVZBL	#DLK$C_USRINT,R6		; Set to start the protocol
	BBC	#XM$V_CHR_MOP,-			; If BC then don't enter
		UCB$L_DEVDEPEND(R5),15$		; maint mode
	MOVZBL	#DLK$M_MAINT,R7			; Set to start maint mode
	BRW	20$
15$:	MOVZBL	#DLK$M_START,R7			; Else simply start the prot
20$:	PUSHR	#^M<R3,R5>			; Save registers
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Get addr of start of TFB
	CLRQ	R8
	BSBW	DDCMP				; Jump to the protocol
	POPR	#^M<R3,R5>			; Restore registers
	CMPB	#DLK$C_ACTNOTCOM,R6		; If EQL then protocol not
	BEQL	25$				; in halted state don't reinit
	BSBW	FILLFREELIST			; Fill rcv free buffer Q
	BLBC	R0,START_CIRCUIT_ERROR		; Branch to shutdown the device
	CLRL	R1				; Set no status for start transmit
	BSBW	START_TRANSMIT			; Branch to send STRT message
	BLBC	R0,START_CIRCUIT_ERROR		; Branch to shutdown the device
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	BRB	START_CIRCUIT_COMP		; Comp the request

25$:	MOVZWL	#SS$_DEVACTIVE,R0		; Set reason for abort
	SETBIT	#XM$V_ERR_TRIB,-		; Set to restart ciruit
		UCB$L_DEVDEPEND(R5)
	BRB	START_CIRCUIT_ERROR
START_POWERFAIL:
	MOVZWL	#SS$_POWERFAIL,R0		; Set reason to abort
START_CIRCUIT_ERROR:
	PUSHL	R0				; Save reason to abort
	BSBW	SHUTDOWN_CIRCUIT		; Shutdown the circuit
	POPL	R0				; Restore reason for abort
START_CIRCUIT_COMP:
	MOVL	UCB$L_IRP(R5),R3		; Retreive packet address
	MOVW	R0,UCB$W_BOFF(R5)		; Set success
	RSB					; Jump to complete the request


	.SBTTL	Unit access routines
;++
;AWAIT_UNIT - Wait for unit master reset
;
; This routine uses the WFIKPCH macro to wait for the device to be master
; cleared. The interrupt should never occur  only the timeout. 
;
; Waiting for the device to clear in this manner is a nonstandard use of
; the WFIPKCH macro. There are some things to note when we continue execution
; after the timeout has occured. First we come into the routine at DIPL instead
; of FIPL. Since most of the work we have to do after the timeout has
; happened is a FIPL then we do a SETIPL to the driver's fork ipl. We can do 
; this because we have put in numereous checks int UNIT_INIT to make sure that
; IPL$_SYNCH, IPL$_TIMER and the drivers FIPL are the same. Please take all 
; these things into consideration when changing this code.
;
;	INPUTS:   R5 = UCB address
;
;	OUTPUTS:  R0 contains the status of wait
;
;--
AWAIT_UNIT:					; Wait for unit only
	DSBINT	UCB$B_DIPL(R5)			; Lock out interrupt from dev

	BISW	#XG$M_MASTER_RESET,-		; Master clear the unit
		XG$C_MISC_REG(R4)

	WFIKPCH AWAIT_CONT,#2			; Wait for two seconds for
						; master clear
AWAIT_CONT:
	CLRBIT	#UCB$V_TIMOUT,UCB$W_STS(R5)	; Clear timeout
	MOVZWL	#SS$_CTRLERR,R0			; Assume failure
	BITW	#XG$M_MASTER_RESET,XG$C_MISC_REG(R4) ; If NEQL then error
	BEQL	1$
	SETIPL	#IPL$_SYNCH			; Return to the drivers fork	
	BRW	10$
1$:	SETIPL	#IPL$_SYNCH			; Return to the drivers fork	
	DSBINT	#IPL$_POWER
	BBC	#UCB$V_POWER,UCB$W_STS(R5),3$	; If BC then NO power failure
	BRW	5$
3$:	ENBINT					; Set to DIPL
	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		START_UNIT_LAPB,-		; LAPB
		20$,-				; BISYNC
		>				; Fall thru on DDCMP
;
; Set up DDCMP defaults and other information necessary for the prptocol
;
	PUSHR	#^M<R6,R7,R8,R9>
	PUSHR	#^M<R3,R5>
	MOVAB	UCB$Z_XG_DDCMP(R5),R8		; Set addr of buf with param
	MOVAB	UCB$Z_XG_DLA_ADDR(R5),R9	; Set addr of buf with address
	MOVAB	UCB$Z_XG_XMT_INPR(R5),R0	; Set up address
	MOVL	R0,DLA$A_XMT_INPR(R9)
	MOVAB	UCB$Q_XG_POST(R5),R0
	MOVL	R0,DLA$A_POSTQ(R9)
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Get protocol buffer
	MOVZBL	#DLK$C_CHAR,R6			; Set DDCMP default char
	CLRL	R7				; Zero the register
	BISW	#<DLK$M_MSGCNT!-		; indicate chara to set
		DLK$M_SELTIM!-
		DLK$M_SELWAIT!-
		DLK$M_REPTIM!-
		DLK$M_REPWAIT!-
		DLK$M_SETDEF>,R7
	BSBW	DDCMP
	POPR	#^M<R3,R5>
;
; Before starting up the DDCMP timer make sure that the driver can not
; be reloaded while the timer is running.
;
	BISB	#DPT$M_NOUNLOAD,DPT$TAB+DPT$B_FLAGS
;
; Start up the DDCMP timer. First set up registers with params for call
; then make the call to the protocol.
;
	PUSHR	#^M<R3,R5>
	MOVZBL	#DLK$C_START_TIMER,R6		; Set up R6 with the DDCMP comm
	MOVAL	W^DEVTIMER,R7			; R7 must have device timer addr
	MOVL	R5,R8				; R8 must have UCB addr
	CLRL	R9				; Clear R9
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Get addr of start of TFB
	BSBW	DDCMP				; Call protocol
	POPR	#^M<R3,R5>
	POPR	#^M<R6,R7,R8,R9>
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device charateristics
	REQCOM					; Complete the request

5$:	MOVZWL	#SS$_POWERFAIL,R0		; Treat as failure to init
	ENBINT					; Set to FIPL
10$:	PUSHL	R0				; Save abort reason
	BSBW	SHUTDOWN_LINE			; Shut down the device
	POPL	R0				; Restore abort reason
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device charateristics
	REQCOM					; Complete the request
20$:	BRW	START_UNIT_BISYNC


;++
; START_UNIT_LAPB - Start line and set char for LAPB
;
; Lapb does not have a seperate start up for line and circuit, therefore
; when a start up on the line is received then it must also start
; up the circuit. This includes setting up the proper fields in the
; UCB and setting the board with the proper fields
;
;	INPUT	R3 = IRP address
;		R5 = UCB address
;--
START_UNIT_LAPB:
	BBC	#XM$V_STS_ACTIVE,-		; If BC then device and
		UCB$L_DEVDEPEND(R5),5$		; protocol are not active
	MOVZWL	#SS$_DEVACTIVE,R0		; Return error
	BRW	SET_UNIT_LAPB_ERROR

5$:	BBS	#XG_DS_V_INITED,-		; If BS then line started
		UCB$W_DEVSTS(R5),8$
	MOVZWL	#SS$_DEVINACT,R0		; Else return device inactive
	BRW	SET_UNIT_LAPB_ERROR

8$:	BICW	#^C<XG_DS_M_INITED!-		; Reset bit fields
		XG_DS_M_CTSTQE_RUN>,-
		UCB$W_DEVSTS(R5)
	BICL	#XG$C_CIR_PAR,UCB$L_DEVDEPEND(R5) ; Reset all Read/Write flags
	CLRB	UCB$B_XG_XSTATE(R5)		; Set XMTer state to idle
	CLRB	UCB$B_XG_XMTCNT(R5)		; Clear the no xmt's outstnd'n
	CLRW	UCB$W_XG_MFDLEN(R5)		; Set zero protocol header
;
; Reinitialize the queue headers is case BISYNC protocol was run last 
; in which case these fields will no longer look like queues.
;
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR(R5) ; Rcv inpr list
	MOVAB	UCB$Q_XG_RCV_INPR(R5),UCB$Q_XG_RCV_INPR+4(R5)
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Set protocol buffer

	ASSUME	LAPB$W_DEIBC EQ LAPB$W_DEITYP+2

	MOVZWL	#NMA$C_CTCIR_DEI,LAPB$W_DEITYP(R4) ; Set kind of error
	CLRB	LAPB$B_DEI(R4)			; Clear the field
	CLRB	LAPB$B_XQCNT(R4)		; Clear the xmt cnt field
	MOVAB	LAPB$Q_XMTQ(R4),LAPB$Q_XMTQ(R4) ; Initialize queues
	MOVAB	LAPB$Q_XMTQ(R4),LAPB$Q_XMTQ+4(R4)
	MOVAB	LAPB$Q_CLEANQ(R4),LAPB$Q_CLEANQ(R4) ; Initialize queues
	MOVAB	LAPB$Q_CLEANQ(R4),LAPB$Q_CLEANQ+4(R4)
	MOVAB	LAPB$Q_BLANK(R4),LAPB$Q_BLANK(R4) ; Initialize queues
	MOVAB	LAPB$Q_BLANK(R4),LAPB$Q_BLANK+4(R4) ; Initialize queues
	MOVL	UCB$L_CRB(R5),R4		; Get the CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get the CSR address
	DSBINT	UCB$B_DIPL(R5)			; Lock out interupt from device
	MOVAL	UCB$Z_XG_SYNC(R5),R2		; Get the addr of SYNC params
	MOVW	#0,XG$C_MISC_REG(R4)		; Set the first Ind reg
	MOVZBW	XG$B_ERR_CNTRL(R2),R0		; Set type of error checking
	INSV	XG$B_PROTOCOL(R2),#XG$V_PROTOCOL,- ; Set type of protocol
		#XG$S_PROTOCOL,R0
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR0
	MOVW	#0,XG$C_IND_ADDR(R4)		; Init IR1
	CLRW	R0
	INSV	XG$B_BAUD(R2),#XG$V_XMT_BRG,-	; Set baud rate
		#XG$S_XMT_BRG,R0
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR2	
	MOVW	#0,XG$C_IND_ADDR(R4)		; Init IR3
	MOVW	#0,XG$C_IND_ADDR(R4)		; Init IR4
	MOVW	#0,XG$C_IND_ADDR(R4)		; Init IR5

; Set the receive and transmit csr's

	MOVZBW	#XG$M_INT_ENABLE,R0		; Set to enable interrupts
	ASSUME	NMA$C_LINCN_NOR EQ 0
	TSTB	UCB$B_XG_CON(R5)		; Normal controller?
	BEQL	20$				; If EQL then yes
	BISW2	#XG$M_ILP_XCS,R0		; Set internal clock src
						; and internal loopback
20$:	MOVL	R0,R1				; Move into R1
	INSV	UCB$B_XG_MNT_LOOPB(R5),-	; Set LOOPB type
		#XG$V_LOOP_TYPE,#XG$S_LOOP_TYPE,R1
	MOVW	R1,XG$C_RCV_CSR(R4)		; Set for RCV's
	BISW2	#XG$M_TERM_IDL,R0		; Set XMTer to IDLE
	MOVW	R0,XG$C_XMT_CSR(R4)		; Set for XMT's
	MOVZWL	#XG$M_DTR,R0			; Set DTR on
	BISW	#XG$M_RTS,R0			; Set RTS on
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)
	MOVW	R0,XG$C_IND_ADDR(R4)
	SETIPL	#IPL$_POWER			; Interlock powerfail
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$	; BR if no power failed
	ENBINT					; Enable intterrupts at FIPL
	MOVZWL	#SS$_POWERFAIL,R0		; Set reason to abort
	BRB	SET_UNIT_LAPB_ERROR
10$:	BISW	#XM$M_STS_ACTIVE,-
		UCB$L_DEVDEPEND(R5)		; Set active state
	ENBINT					; Return to fork IPL
	BSBW	FILLFREELIST			; Fill rcv free buffer Q
	BLBC	R0,SET_UNIT_LAPB_ERROR		; Branch to shutdown the device
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	BRB	SET_UNIT_LAPB_COMP		; Comp the request

SET_UNIT_LAPB_ERROR:
	PUSHL	R0				; Save reason to abort
	BSBW	SHUTDOWN_LINE			; Shutdown the line
	POPL	R0				; Restore reason for abort
SET_UNIT_LAPB_COMP:
	MOVL	UCB$L_IRP(R5),R3		; Retreive packet address
	MOVW	R0,UCB$W_BOFF(R5)		; Set success
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device depend char
	REQCOM					; Jump to complete the request


;++
;SET_UNIT_DDCMP - Set default characters on board protocol support is DDCMP
;
; Sets the device characteristics to be that for DDCMP
;
; The defaults are as follows
;
;	IR0:	Proctol = DDCMP, Error = CRC16; Bits/char = 8
;	IR1:	Clear RCV error
;	IR2:	Clear XMT error, Set default baud rate = 19.2kb/sec
;	IR3:	Set number of syncs = 8  Set sync char = 150
;	IR4:	Clear data set change bits
;	IR5:	Set station address
;
;	INPUTS:	R4 = CSR address
;		R5 = UCB address
;
;--
SET_UNIT_DDCMP:
	MOVAL	UCB$Z_XG_SYNC(R5),R2		; Get the addr of SYNC params
	MOVW	#0,XG$C_MISC_REG(R4)		; Set the first Ind reg
	MOVZBW	XG$B_ERR_CNTRL(R2),R0		; Set type of error checking
	BISB2	#XG$M_STRIP_SYNC,R0		; Set to strip excess sync char
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR0
	MOVW	#0,XG$C_IND_ADDR(R4)		; Init IR1
	CLRW	R0
	INSV	XG$B_BAUD(R2),#XG$V_XMT_BRG,-	; Set baud rate
		#XG$S_XMT_BRG,R0
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR2	
	MOVZBW	XG$B_NUM_SYNC(R2),R0		; Set number of syncs
	INSV	XG$B_SYNC_REG(R2),#XG$V_SYNC,-	; Set sync char
		#XG$S_SYNC,R0
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR3
	MOVW	#0,XG$C_IND_ADDR(R4)		; Init IR4
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R0	; Get protocol buffer type
	MOVZBW	TF$B_ADDR(R0),R0		; Get trib address into word
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR5

; Set the receive and transmit csr's

	MOVZBW	#XG$M_INT_ENABLE,R0		; Set to enable interrupts
	ASSUME	NMA$C_LINCN_NOR EQ 0
	TSTB	UCB$B_XG_CON(R5)		; Normal controller?
	BEQL	20$				; If EQL then yes
	BISW2	#XG$M_ILP_XCS,R0		; Set internal clock src
						; and internal loopback
20$:	MOVL	R0,R1				; Move into R1
	INSV	UCB$B_XG_MNT_LOOPB(R5),-	; Set LOOPB type
		#XG$V_LOOP_TYPE,#XG$S_LOOP_TYPE,R1
	CMPB	#NMA$C_LINPR_TRI,-		; If trib then set bit on board
		UCB$B_XG_PRO(R5)		; so that address is checked
	BNEQ	30$
	BISW	#XG$M_PRI_SEC_STN,R1		; Set that this is a trib
30$:	MOVW	R1,XG$C_RCV_CSR(R4)		; Set for RCV's
	MOVW	R0,XG$C_XMT_CSR(R4)		; Set for XMT's
	MOVZWL	#XG$M_DTR,R0			; Set DTR on
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)
	MOVW	R0,XG$C_IND_ADDR(R4)
	RSB
		



	.SBTTL	Set protocol characteristic
;++
; SET_CHAR - Set characteristics of protocol
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is entered to set characteristic on a halted protocol.
;
; INPUTS:
;
;	R5 = UCB address
;
;
; OUTPUTS:
;
;	New protocol characteristics given to protocol.
;--
SET_CHAR:
	CLRL	R7				; Set no charac to change
	MOVW	#MFD$K_LENGTH,UCB$W_XG_MFDLEN(R5) ; Set protocol header sz
	MOVAB	UCB$Z_XG_DDCMP(R5),R8		; Get trib parameter block
	MOVB	DLK$B_MSGCNT(R8),-		; Use this field for RTO's
		DLK$B_MAXREP(R8)
	MOVB	DLK$B_MSGCNT(R8),-		; And for number of Select
		DLK$B_MAXSEL(R8)		; intervals
	MOVW	DLK$W_REPWAIT(R8),-		; Use repwait for selwait
		DLK$W_SELWAIT(R8)
	BISW	#<DLK$M_MSGCNT!-		; Set to reset these param
		DLK$M_SELTIM!-
		DLK$M_SELWAIT!-
		DLK$M_REPTIM!-
		DLK$M_REPWAIT>,R7

	ASSUME	NMA$C_LINPR_POI EQ 0
	SETBIT	#DLK$V_SETDEF,R7		; Set default char
	TSTB	UCB$B_XG_PRO(R5)		; If EQL then point to point
	BEQL	10$
	CLRBIT	#DLK$V_SETDEF,R7		; Use user given char
	SETBIT	#DLK$V_STATYP,R7		; Else set trib
10$:	ASSUME	NMA$C_DPX_FUL EQ 0
	TSTB	UCB$B_XG_DUP(R5)		; If EQL the full duplex
	BEQL	20$
	SETBIT	#DLK$V_DUPLEX,R7		; Else set half duplex
20$:	PUSHR	#^M<R3,R5>			; Save registers
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Get addr of start of TFB
	MOVZBL	#DLK$C_CHAR,R6			; Set charac in DDCMP
	CLRL	R9
	BSBW	DDCMP
	POPR	#^M<R3,R5>			; Restore the registers
30$:	RSB


	.SBTTL	START_UNIT_BISYNC - Start up device in BISYNC mode
;++
; START_UNIT_BISYNC - Start up device in Bisync mode
;
; As in LAPB, Bisync does not have a seperate start up for the line and circuit,
; therefore when issuing a startup on the line, we must start the entire
; protocol. It must also set the necessary field both in the UCB and on the
; device.
;
;	INPUTS:
;		R5 = Address of UCB
;
;	OUTPUTS
;		R0 = Status of request
;		R1 = Contents of UCB$L_DEVDEPEND 
;		R3 = IRP address
;		R5 = UCB address
;--
START_UNIT_BISYNC:
	BBC	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5),10$ ; If BC device not active
	MOVZWL	#SS$_DEVACTIVE,R0		; Set device active
	BRW	START_UNIT_BISYNC_ERROR		; Complete in error

10$:	BBS	#XG_DS_V_INITED,UCB$W_DEVSTS(R5),20$ ; If BS then line started
	MOVZWL	#SS$_DEVACTIVE,R0		; Else complete request
	BRW	START_UNIT_BISYNC_ERROR		; in error

20$:	.IF	DF BISYNC$$$
	moval	w^bisync_framing_routine,ucb$a_xg_frame_addr(r5) ; For testing BISYNC
	.ENDC	;DF BISYNC$$$

	BICW	#^C<XG_DS_M_INITED!-		; Reset flags
		    XG_DS_M_CTSTQE_RUN>,UCB$W_DEVSTS(R5)
	BICL	#XG$C_CIR_PAR,UCB$L_DEVDEPEND(R5) ; Reset read/write flags
	CLRB	UCB$B_XG_XSTATE(R5)		; Set XMTer state to idle
	CLRB	UCB$B_XG_XMTCNT(R5)		; Clear XMT's outstanding
	CLRW	UCB$W_XG_MFDLEN(R5)		; Set zero protocol header
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get protocol buffer address
	MOVAB	BISYNC$Q_XMTQ(R4),BISYNC$Q_XMTQ(R4) ; Initialize queues
	MOVAB	BISYNC$Q_XMTQ(R4),BISYNC$Q_XMTQ+4(R4)
	MOVAB	BISYNC$Q_CLEANQ(R4),BISYNC$Q_CLEANQ(R4) ; Initialize queues
	MOVAB	BISYNC$Q_CLEANQ(R4),BISYNC$Q_CLEANQ+4(R4)
	MOVAB	BISYNC$Q_BLANK(R4),BISYNC$Q_BLANK(R4) ; Initialize queues
	MOVAB	BISYNC$Q_BLANK(R4),BISYNC$Q_BLANK+4(R4) ; Initialize queues
	MOVL	UCB$L_CRB(R5),R4		; Get the CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get the CSR 
	DSBINT	UCB$B_DIPL(R5)			; Disable interrupts
	MOVAL	UCB$Z_XG_SYNC(R5),R2		; Get the addr of sync params
	MOVW	#0,XG$C_MISC_REG(R4)		; Set the first indirect reg
	MOVZBW	XG$B_ERR_CNTRL(R2),R0		; Set type of error control
	INSV	XG$B_PROTOCOL(R2),#XG$V_PROTOCOL,- ; Set type of protocol
		#XG$S_PROTOCOL,R0
	SETBIT	#XG$V_STRIP_SYNC,R0		; Set to strip sync characters
	MOVW	R0,XG$C_IND_ADDR(R4)		; Set IR0
	MOVW	#0,XG$C_IND_ADDR(R4)		; Set IR1
	CLRL	R0
	INSV	XG$B_BAUD(R2),#XG$V_XMT_BRG,-	; Set baud rate
		#XG$S_XMT_BRG,R0
	MOVW	R0,XG$C_IND_ADDR(R4)		; Set IR2
	MOVZBW	XG$B_NUM_SYNC(R2),R0		; Set number of syncs
	INSV	XG$B_SYNC_REG(R2),#XG$V_SYNC,-	; Set sync char
		#XG$S_SYNC,R0
	MOVW	R0,XG$C_IND_ADDR(R4)		; Init IR3
	MOVW	#0,XG$C_IND_ADDR(R4)		; Set IR4
	MOVW	#0,XG$C_IND_ADDR(R4)		; Set IR5
;
; Set the receive and tranmit register. Do not enable interrupts on the
; receiver side.
;
	CLRL	R0

	ASSUME	NMA$C_LINCN_NOR EQ 0

	TSTB	UCB$B_XG_CON(R5)		; If EQL then controller not
	BEQL	30$				; loopbacked
	BISW2	#XG$M_ILP_XCS,R0		; Else set loopback
30$:	MOVL	R0,R1
	INSV	UCB$B_XG_MNT_LOOPB(R5),-	; Set loop back type
		#XG$V_LOOP_TYPE,#XG$S_LOOP_TYPE,R1
	MOVW	R1,XG$C_RCV_CSR(R4)		; Set the RCV csr
	BISW2	#XG$M_INT_ENABLE,R0		; Set XMT char's
	MOVW	R0,XG$C_XMT_CSR(R4)		; Set the XMT csr
	MOVZWL	#XG$M_DTR,R0			; Set DTR high
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Set to set up the modem IR
	MOVW	R0,XG$C_IND_ADDR(R4)		; Set up modem IR4
	SETIPL	#IPL$_POWER			; Lock out interrupts
	BBC	#UCB$V_POWER,UCB$W_STS(R5),40$	; Check for power failure
	ENBINT					; Return to fork IPL
	MOVZWL	#SS$_POWERFAIL,R0		; Set power failed
	BRB	START_UNIT_BISYNC_ERROR		; Complete startupin error
40$:	SETBIT	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5) ; Set active bit
	ENBINT					; Enable interrupts
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get protocol buffer
	MOVQ	UCB$Q_XG_STATE_INFO(R5),BISYNC$Q_INIT_STATE_INFO(R4) ; Set init state
	
	ASSUME	BISYNC$W_STATUS EQ BISYNC$W_RCV_INDEX+2
	ASSUME  BISYNC$W_DROP_RCV EQ BISYNC$B_XQCNT+1

	CLRL	BISYNC$W_RCV_INDEX(R4)		; Clear index and statsu fields
	CLRL	BISYNC$B_XQCNT(R4)		; Clear xqcnt and drop rcv field
	PUSHL	R4
	BSBW	FILLFREELIST			; Fill free list with buffers
	POPL	R4
;
; Take a buffer from the FREELIST to use as the receive buffer. Because of
; the nature of how the device works in BISYNC mode, we will not use the 
; double buffer capability of the DMF32 sync port for receives. Receives
; on this device will work on a timer base. Whenever the timer goes off we
; will check to see if anymore characters have been input. It they have
; then we will give them to the framming routine and depending on what the 
; framming routine decides the buffer may or may not be completed. If the
; buffer is completed then all fields necesary for receiving are reset.
;
	REMQUE	@UCB$Q_XG_FREE(R5),R0		; Get a buffer for rv's
	BVS	START_UNIT_BISYNC_ERROR		; If VS then no buffers alloc
	MOVL	R0,BISYNC$A_RCV_BUFFER(R4)	; Save the rcv buffer
	CLRQ	UCB$Q_XG_RCV_INPR(R5)		; Clear no buffer rcving 
;
; Now go off and start the timer to start looking for receive characters. The 
; timer is responsible for starting up the receive requests. This means that 
; START_RECEIVE routine is not called when running in BISYNC mode
;
	BSBW	START_BISYNC_TIMER		; Start timer and rcv's
	BLBC	R0,START_UNIT_BISYNC_ERROR	; If LBC then error on startup
	MOVZWL	S^#SS$_NORMAL,R0		; Else set success
	BRB	START_UNIT_BISYNC_COMP

START_UNIT_BISYNC_ERROR:
	PUSHL	R0
	BSBW	SHUTDOWN_LINE
	POPL	R0

START_UNIT_BISYNC_COMP:
	MOVL	UCB$L_IRP(R5),R3		; Get IRP
	MOVW	R0,UCB$W_BOFF(R5)		; Set QIO status
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set device depend char
	REQCOM					; Jump to complete the request	

	.SBTTL	START_BISYNC_TIMER - Start up the BISYNC timer
;++
; START_BISYNC_TIMER - Start up the BISYNC timer
;
; This routine is called to start up the timer and the receiver on the DMF32.
; The reasons we can't use START_RECEIVE to start up receives are two fold.
; First we will never have more than one receive posted on the device at any 
; time. Second because of the way we have to handle receive characters. That is
; running a timer, which when ticks looks in the receive buffer to see if any 
; characters were input. This makes having two buffers posted rather
; useless.
;
;	INPUTS
;		R4 = Address of protocol buffer
;		R5 = UCB address
;
;	OUTPUT
;		R5 = UCB address
;		The receive for BISYNC is started up.
;
;--
START_BISYNC_TIMER:
	PUSHL	R5				; Save R5
	MOVL	R5,R3				; Keep the UCB ADDRESS
	MOVAB	BISYNC$L_TQE(R4),R5		; Get TQE address
	MOVAW	G^BISYNC_TIMER,TQE$L_FPC(R5) 	; Set address of timer routine
	MOVQ	#XG$C_BISYNC_DELTA,TQE$Q_DELTA(R5) ; Set delta
	MOVL	R3,TQE$L_FR3(R5)		; Set TQE with UCB address
	MOVL	R4,TQE$L_FR4(R5)		; Set TQE with pro buffer addr
	MOVB	#TQE$C_SSREPT,TQE$B_RQTYPE(R5)	; Set system and repeatable
	CLRB	TQE$B_RMOD(R5)			; Set no access mode
	MOVQ	G^EXE$GQ_SYSTIME,R0		; Set system time
	JSB	G^EXE$INSTIMQ			; Insert on timer queue
	POPL	R5				; Reset UCB address
	SETBIT	#BISYNC$V_TIMER_RUNNING,BISYNC$W_STATUS(R4)
	BISB	#DPT$M_NOUNLOAD,DPT$TAB+DPT$B_FLAGS ; Set driver not reloadable
	DSBINT	UCB$B_DIPL(R5)
	BSBW	START_RECEIVE_BISYNC
	ENBINT
	RSB
	
	

	.SBTTL	FILLFREELIST - FILL MESSAGE FREE LIST
;++
; FILLFREELIST - Fill message block free list
; ADDFREELIST - Add a buffer to receive list
;
; Functional description:
;
; This routine fills the receive buffer free list up to the quota specified
; at device startup.
;
; Inputs:
;
;	R2 = Buffer address (ADDFREELIST only)
;	R5 = UCB address
; 
;	IPL = FIPL
;
; Outputs:
;
;	R5 = UCB address
;	R3 is preserved
;	R1,R2,R4 destroyed.
;--
FILLFREELIST:					; Fill free list
	CLRL	R2				; Clear buffer address
	BBS	#XM$V_STS_ACTIVE,-		; Continue if device active
		UCB$L_DEVDEPEND(R5),ADDFREELIST	;
	RSB					;
ADDFREELIST:					; Add to receive buffer list
	PUSHL	R3				; Save registers
5$:	CMPW	UCB$W_DEVBUFSIZ(R5),-		; Can new block be allocated ?
		UCB$W_XG_QUOTA(R5)		;
	BGTRU	20$				; Br if no - list filled
	CLRL	R1				; Zero size 
	ADDW3	#RCV_T_DATA+CXB$C_TRAILER,-	; Compute needed block size
		UCB$W_DEVBUFSIZ(R5),R1		; 
	TSTL	R2				; Buffer allocated already?
	BNEQ	7$				; Br if yes
	JSB	G^EXE$ALONONPAGED		; Allocate nonpaged memory
	BLBC	R0,10$				; Br if failure
7$:	MOVW	R1,RCV_W_BLKSIZE(R2)		; Insert block size
	MOVB	S^#DYN$C_NET,RCV_B_BLKTYPE(R2)	; Insert block type
	CLRW	RCV_W_ERROR(R2)			; Clear error status
	INSQUE	(R2),UCB$Q_XG_FREE(R5)		; Insert block on list
	SUBW	UCB$W_DEVBUFSIZ(R5),-		; Decrement quota
		UCB$W_XG_QUOTA(R5)		;
	CLRL	R2				; Clear buffer pointer
	BRB	5$				;

10$:	SETBIT	#XM$V_STS_BUFFAIL,-		; Set buffer alloc failure
		UCB$L_DEVDEPEND(R5) 		;
	BRB	30$				;

20$:	CLRBIT	#XM$V_STS_BUFFAIL,-		; Clear buffer alloc failure
		UCB$L_DEVDEPEND(R5) 		;
	MOVL	R2,R0				; Set address of buffer
	BEQL	30$				; Br if none
	JSB	G^COM$DRVDEALMEM		; Deallocate it
30$:	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; If EQL do not 
	BEQL	50$				; start receives
	DSBINT	UCB$B_DIPL(R5)			; Disable interrupts
	BSBB	START_RECEIVE			; Start then next  receive
	ENBINT					; Enable interrupts
40$:	POPL	R3				; Restore registers
	RSB
50$:	MOVZWL	S^#SS$_NORMAL,R0		; Set for normal return
	POPL	R3				; Restore registers
	RSB


	.SBTTL	START_RECEIVE_BISYNC - Start receives in BISYNC mode
;++
; START_RECEIVE_BISYNC - Start receives in BISYNC mode
;
; This routine starts up the receiver in BISYNC mode. The receiver  in
; BISYNC mode works differently from the other modes because in this
; mode there is no way for the device to tell when the receive is
; complete thus we must check each character comming off the line to
; see if it is part of the message we are receiving. In order to do this
; the following has been implemented. At device startup a buffer is 
; taken from the freelist and stored in BISYNC$A_RCV_BUFFER, this
; buffer purpose is to act as a holder for characters comming off the wire.
; BISYNC$W_RCV_INDEX will point to the next character from the line
; with in that buffer. As we detect that a new character has come into
; the buffer we will pass that character to the FRAMING ROUTINE provided
; by the starter. The character will either be buffered or not in the
; actual receive buffer (See BISYNC_TIMER for an explanation).
;
;	INPUTS
;		R4 = Address of protocol buffer
;		R5 = UCB address
;		IPL = device IPL
; 
;	OUTPUTS
;		R5 = UCB address
;		The receive is started
;
;--
START_RECEIVE_BISYNC:
	BBS	#XG_DS_V_RCVING,UCB$W_DEVSTS(R5),10$	; If BS not rcving
	BBS	#XG_DS_V_RCV_DONEP,UCB$W_DEVSTS(R5),10$ ; If set then rcv is loaded
	MOVL	UCB$L_CRB(R5),R1		; Get the CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; Get the CSR address
	MOVZWL	#XG$C_PRI_RCV,R1		; Set ind reg primary buffer
	MOVZBL	#XG$C_PRIRCV,R3			; Set mapping vector to use
	REMQUE	@UCB$Q_XG_FREE(R5),R2		; See if any RCV buffers free
	BVS	10$
	MOVL	R2,UCB$L_XG_RCV_INPR(R5)	; Set rcv buffer
	CLRW	UCB$W_XG_RCV_INPR_INDX(R5)	; Clear index
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R0	; Get the protocol buffer
	MOVL	BISYNC$A_RCV_BUFFER(R0),R2	; Give board the buffer to rcv into
	BSBW	LOAD_RCV_MPR			; Load the receive buffer
	MOVW	RCV_L_BACC+2(R2),UCB$W_XG_RCV_INIT(R5) ; Save char count of buffer
	INSV	#0,#15,#2,UCB$W_XG_RCV_INIT(R5)	; Clear high order bits
	BICW2	#XG$M_PRM_SEC,XG$C_RCV_CSR(R4)	; Make sure we are usin the primayr reg
	SETBIT	#XG_DS_V_RCV_DONEP,UCB$W_DEVSTS(R5) ; Set receiver is loaded
	CLRBIT	#XG_DS_V_RCVENB,UCB$W_DEVSTS(R5) ; Clear enable receive bit
	DSBINT					; Lock out interrupts
	BBS	#UCB$V_POWER,UCB$W_STS(R5),20$	; If BS then powerfail
	BISW	#XG$M_ENABLE,XG$C_RCV_CSR(R4)	; Set the enable bit
	ENBINT
10$:	MOVZWL	S^#SS$_NORMAL,R0
	RSB

20$:	ENBINT	
	MOVZWL	#SS$_POWERFAIL,R0
	RSB


	.SBTTL	START_RECEIVE - Start any receives
;++
; START_RECEIVE - Start receives 
;
; FUNCTIONAL DESCRIPTION:
;
; This routine oversees giving receive buffers to the board. It's job is to
; check and set the copy of the DMF32 receive bits that the driver keeps to
; tell which buffer (primary or secondary) it must load next. If there is no
; receive buffer to give the board, the routine must be smart enough not
; to try to enable the receiver. Unsolicited interrupts can happen if the
; board is enabled and the buffers haven't been loaded. Otherwise the
; routine enables the board after each buffer is loaded whether the board
; is already enabled or not. Remember that this routine may load more
; than one buffer a call.
;
; INPUTS:
;
;	R5 = UCB address
;	IPL = Device IPL
;
; OUTPUTS:
;
;	R5 = UCB address
;
;	R0 - R4 destroyed
;--
START_RECEIVE:					; Start receive operation
	BBS	#XG_DS_V_RCVING,-		; If BS then device not
		UCB$W_DEVSTS(R5),12$		; not receiving
	MOVL	UCB$L_CRB(R5),R1		; Get the CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; Get the CSR
	BBS	#XG_DS_V_LOADRPS,-		; If BS then load sec buff
		UCB$W_DEVSTS(R5),20$		; else load this buffer
10$:	BBC	#XG_DS_V_RCV_DONEP,-		; If BC then not loaded
		UCB$W_DEVSTS(R5),13$

	BRW	30$				; Jump enable the device
12$:	BRW	35$				; Jump to return

13$:	MOVZWL	#XG$C_PRI_RCV,R1		; Set ind reg pri buffer
	MOVZBL	#XG$C_PRIRCV,R3			; Set mapping vector to use
	REMQUE	@UCB$Q_XG_FREE(R5),R2		; Get next buffer to input into
	BVS	30$				; Branch if none
	BSBW	LOAD_RCV_MPR			; Load the receive buffer
	INSQUE	(R2),@UCB$Q_XG_RCV_INPR+4(R5)	; Insert it on the inpr queue
	BISW2	#<XG_DS_M_LOADRPS!-		; Set to load sec buff and
		XG_DS_M_RCV_DONEP>,-		; to indicate the pri buff
		UCB$W_DEVSTS(R5)		; was loaded
20$:	BBS	#XG_DS_V_RCV_DONES,-		; If BS then sec loaded
		UCB$W_DEVSTS(R5),30$
	MOVZWL	#XG$C_SEC_RCV,R1		; Set ind reg sec buffer
	MOVZBL	#XG$C_SECRCV,R3			; Set mapping vector to use
	REMQUE	@UCB$Q_XG_FREE(R5),R2		; Get next buffer to input into
	BVS	30$				; Branch if none
	BSBW	LOAD_RCV_MPR			; Load the receive buffer
	INSQUE	(R2),@UCB$Q_XG_RCV_INPR+4(R5)	; Insert it on the inpr queue
	BICW	#XG_DS_M_LOADRPS,-		; Clear to load pri next
		UCB$W_DEVSTS(R5)
	BISW	#XG_DS_M_RCV_DONES,-		; Set to indicate sec buff
		UCB$W_DEVSTS(R5)		; was loaded
30$:	BBCC	#XG_DS_V_RCVENB,-		; If BC then nothing to
		UCB$W_DEVSTS(R5),35$		; give the board
	DSBINT					; Disable all interrupts
	BBS	#UCB$V_POWER,UCB$W_STS(R5),40$	; Branch BS power fail
	BISW	#XG$M_ENABLE,XG$C_RCV_CSR(R4)	; Enble XMTer
	ENBINT					; Restore IPL
35$:	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	RSB

40$:	ENBINT					; Enable interrupts
45$:	MOVZWL	#SS$_POWERFAIL,R0		; Set powerfail status
	RSB



;++
;LOAD_RCV_MPR - Load receive map registers and character count
;
; This routine gets a free recevie out of the queue and sets up the mapping
; registers and BACC to give to COMBO. In this case the double buffering
; is used so that the board will always have a buffer in which in can receive.
; If too few buffers are allocated or if they are not completed quick enough
; i.e. too few IRP's given to complete the buffer, then no action is taken and
; it is left to the caller to decide what must be done.
;
;	INPUTS:
;		R1 = Address of the indirect register to load
;		R2 = Address of a buffer to receive into
;		R3 = Vector slot to use
;		R4 = CSR address
;		IPL = DIPL
;
;	OUTPUTS
;		R2,R4, and R5 are preserved
;--
LOAD_RCV_MPR:
;
; Mark slot in use and create buffer address / character count image
;
	PUSHR	#^M<R1,R4>			; Save registers
	MOVAL	UCB$Z_XG_VECTOR(R5)[R3],R4 	; Get slot address
	ADDW3	UCB$W_XG_MFDLEN(R5),UCB$W_DEVBUFSIZ(R5),-
		RCV_L_BACC+2(R2)		; Insert character count
	MOVAL	RCV_Z_HEADER(R2),R1		; Get normal buffer address
	MOVW	R1,RCV_L_BACC(R2)		; Insert buffer offset
	INSV	(R4),#9,#7,RCV_L_BACC(R2)	; Insert map register data
	EXTZV	#7,#2,(R4),R3			; Get two high bits
	INSV	R3,#30,#2,RCV_L_BACC(R2)	; Insert in BA/CC

;
; Build UBA map register data and load map
;
	BICW3	#^C<VA$M_BYTE>,R1,UCB$W_BOFF(R5); Set byte offset
	MOVW	UCB$W_DEVBUFSIZ(R5),UCB$W_BCNT(R5) ; Set byte count
	EXTZV	#VA$V_VPN,#VA$S_VPN,R1,R1	; Get virtual page number
	MOVL	G^MMG$GL_SPTBASE,R0		; Get SPT address
	MOVAL	(R0)[R1],UCB$L_SVAPTE(R5)	; Set address of SPT entry
	MOVL	UCB$L_CRB(R5),R1		; Get CRB address
	MOVL	(R4),CRB$L_INTD+VEC$W_MAPREG(R1); Set starting map reg number
	PUSHL	R2				; Save registers
	JSB	G^IOC$LOADUBAMAPA		; Load the map registers
	POPL	R2				; Restore register
	POPR	#^M<R1,R4>			; Restore registers
	MOVW	R1,XG$C_MISC_REG(R4)		; Load into indirect register
	MOVW	RCV_L_BACC(R2),-		; Load buffer address
		XG$C_IND_ADDR(R4)
	MOVW	RCV_L_BACC+2(R2),-		; and character count
		XG$C_IND_ADDR(R4)
	BISW	#XG_DS_M_RCVENB,-		; Set to indicate that there
		UCB$W_DEVSTS(R5)		; is work for the board
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
10$:	RSB


		.SBTTL	INTERRUPTS
;++
; TRANSMIT_INTR
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called when an interrupt from the transmit vector occurs.
; The action is to check for errors on the tranmsit. If they occur then the
; device must be shut down because only fatal errors occur on transmits.
; Otherwise it makes sure the board and the driver agree as to what bits
; should be set and if all is OK then it puts the buffer on the POST queue
; to be handled at fork processing time. Finally, it tries to start up the
; next transmit. When the line is running Half duplex or in trib mode
; ddcmp only then if this is the last message to be transmitted in this
; selection interval the XMTer is shut off. For half duplex this includes
; starting up a TQE on waiting for CTS to be dropped because on real
; modems this may not happen right away. The modem must have dropped CTS
; before we reasscert RTS otherwise it gets all confused.
;
;	INPUTS	00(SP) = IDB address
;		04(SP) = R0 - R5
;
;	OUTPUTS 
;		An entry is added to the post queue.
;
;--
TRANSMIT_INTR:					; Transmit interrupt
	.ENABL	LSB
	MOVL	@(SP)+,R4			; Get IDB address
	MOVL	IDB$L_UCBLST(R4),R5		; Get Ucb address
	BBS	#XM$V_STS_ACTIVE,-		; Branch BS device active
		UCB$L_DEVDEPEND(R5),5$
	BRW	INTEXIT				; If device not active
5$:	CLRL	UCB$L_XG_XMTEND(R5)		; Reset timeout
	MOVL	(R4),R4				; Get CSR address
	MOVW	XG$C_XMT_CSR(R4),-		; Save last XMT csr
		UCB$W_XG_XMTCSR(R5)
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Load the IR with dsc reg
	MOVW	XG$C_IND_ADDR(R4),-		; Save last DSC csr
		UCB$W_XG_DSC(R5)
	BBC	#XG$V_ERROR,-			; Branch BC no fatal error
		UCB$W_XG_XMTCSR(R5),8$		; on the transmit
	MOVW	#XG$C_XMT_ERR,XG$C_MISC_REG(R4)	; Load the IR with error reg
	MOVZBW	XG$C_IND_ADDR(R4),-		; Get the error only low byte
		UCB$W_XG_XMTERR(R5)		; is significant
	BEQL	10$				; if no error set (XMT's were aborted)
	BBS	#XG$V_MSG_LEN,-			; If message length error then
		UCB$W_XG_XMTERR(R5),10$		; non-fatal

	.IF	DF ERR$$$
	bbc	#xg$v_latency_xmt,-		; if BC fatal error not due
		ucb$w_xg_xmterr(R5),6$		; to a latency problem
	incw	ucb$w_xg_xmtlat(R5)		; inc the latency error count
	brb	7$
6$:	incw	ucb$w_xg_xmtnxm(r5)		; inc nxm count
	.ENDC	;DF ERR$$$

7$:	CLRL	R4				; Set fatal error on device
	BSBW	SCHED_FORK			; Schedule a fork
	BRW	INTEXIT

8$:	CLRW	UCB$W_XG_XMTERR(R5)		; Set no error
10$:	BBC	#XG$V_DONE_P,-			; If BC then may be from
		UCB$W_XG_XMTCSR(R5),30$		; Data.Set.Change
	CLRL	R3				; Set to set up prim BACC
	MOVL	UCB$Z_XG_XMT_INPR(R5)[R3],R2	; Get the buffer to complete
	BEQL	15$				; If EQL nothing ot complete
	DECB	UCB$B_XG_XMTCNT(R5)		; Decr the no of outstndng XMTs
	CLRL	UCB$Z_XG_XMT_INPR(R5)[R3]	; Clear the address from slot
	CLRBIT	#XG_DS_V_XMT_DONEP,UCB$W_DEVSTS(R5) ; Clear indicating that the
						; XMT CSR is now free to use
	BBS	#XMTQ$V_CONTROL,-		; If BS then control msg do
		XMTQ$B_FLAG(R2),15$		; put on post queue
	MOVW	UCB$W_XG_XMTERR(R5),-		; Set error status
		XMTQ$W_ERROR(R2)
	INSQUE	(R2),@UCB$Q_XG_POST+4(R5)	; Insert it onto the post Q
15$:	BBS	#XG_DS_V_XMTING,-		; If BS then time to turn link
		UCB$W_DEVSTS(R5),40$		; and drop RTS
18$:	MOVZBL	#XG$C_PRI_XMT,R2		; Set ind reg addr of prim
	BSBW	LOAD_XMT_MPR			; Load map registers and BACC
	BLBC	R0,20$				; No tranmsit given to board
	SETBIT	#XG_DS_V_XMT_DONEP,UCB$W_DEVSTS(R5) ; Set indicating that the
						; XMT CSR is not free to use
	DSBINT					; Sync to highest IPL
	BBS	#UCB$V_POWER,UCB$W_STS(R5),25$	; If BS then power fail occured
	BISW	#XG$M_ENABLE,XG$C_XMT_CSR(R4)	; Else enable transmitter
	ENBINT					; Enable interrupts
20$:	MOVZWL	S^#SS$_NORMAL,R4		; Set no errors
	BSBW	SCHED_FORK
	BRW	INTEXIT

25$:	ENBINT					; Enable interrupts
30$:	BRW	INTERR

40$:	CLRB	UCB$B_XG_XSTATE(R5)		; Assume IDLE state
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Set to get modem indirect reg
	BICW	#XG$M_RTS,XG$C_IND_ADDR(R4)	; Clear RTS
	BBS	#XM$V_CHR_TRIB,UCB$L_DEVDEPEND(R5),50$ ; If BS then ignore chck
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Set to get modem indirect reg
	TIMEWAIT #1,#XG$M_CTS,XG$C_IND_ADDR(R4),W,EQL
	BLBS	R0,50$				; If LBS then CTS was dropped
	MOVB	#XG$C_DRPCTS,UCB$B_XG_XSTATE(R5) ; Set wait for CTS to drop
	BBSS	#XG_DS_V_CTSTQE_RUN,UCB$W_DEVSTS(R5),60$ ; If BS timer is q'd
	PUSHL	R5				; Save R5 across fork
	MOVAL	UCB$L_XG_TQE(R5),R5		; Get the CTS TQE block
	MOVB	#IPL$_QUEUEAST,TQE$B_RQTYPE(R5)	; Set IPL of fork process
	PUSHAB	B^DRPCTSRET			; Set return address
	PUSHAW	W^START_TIMER			; Set addr of CTS TQE start 
	JMP	G^EXE$FORK

DRPCTSRET:
	MOVB	#TQE$C_SSSNGL,TQE$B_RQTYPE(R5)	; Set single shot timer
	POPL	R5				; Restore R5
50$:	MOVZWL	S^#SS$_NORMAL,R4
	BSBW	SCHED_FORK
	BRW	INTEXIT

60$:	BUG_CHECK	NOBUFPCKT,FATAL
	.DSABL	LSB



;++
;RECEIVE_INTR
;
; FUNCTINAL DESCRIPTION:
;
; This routine is called when an interrupt from the receive vector occurs. It
; checks for errors and if the error is non-fatal to the device then the  error
; is squirled away in the buffer to be handled at fork processing time. It does
; checking on the driver receive bits against the DMF receive bits to be sure
; that all is still kosher. Next it removes a buffer from the receive
; inprogress queue checks to be sure that it is the buffer expected and if OK
; gives the buffer to the post queue to be handled at fork processing time.
; Finally, it gives a receive buffer to the device.
; 
;	INPUTS	00(SP) = IDB address
;		04(SP) = R0 - R5
;
;	OUTPUTS 
;		An entry is added to the post queue.
;
;__
RECEIVE_INTR:
	MOVL	@(SP)+,R4			; Get IDB address
	MOVL	IDB$L_UCBLST(R4),R5		; Get Ucb address
	BBS	#XM$V_STS_ACTIVE,-		; Branch BC device active
		UCB$L_DEVDEPEND(R5),5$
2$:	BRW	INTEXIT				; Branch device not active
5$:	MOVZBL	#2,R2				; Set for max # of tms to loop
	MOVL	(R4),R4				; Get CSR address
	MOVW	XG$C_RCV_CSR(R4),-		; Save the receive csr
		UCB$W_XG_RCVCSR(R5)
;
; If the device is running in BISYNC mode then we should never get a receive
; interrupt. If we do get one then just dismiss it.
;
10$:	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5)	; BISYNC?
	BEQL	2$				; If EQL then dismiss intr
	BITW	#XG$M_ERROR,XG$C_RCV_CSR(R4)	; Branch NEQ no fatal error
	BEQL	13$				; on the receive
	MOVW	#XG$C_RCV_ERR,-			; Load the addr of error IR
		XG$C_MISC_REG(R4)
	MOVW	XG$C_IND_ADDR(R4),-		; Get the error
		UCB$W_XG_RCVERR(R5)
	BISW	#XG_DS_M_RCVENB,-		; Set to restart rcv'r won't
		UCB$W_DEVSTS(R5)		; get retsrted in fatal error
						; device will be shut down
	BITW	#<XG$M_BCC_ERR!XG$M_BUFOVR!-	; If any set error not fatal
		XG$M_RES_BIT_CNT!XG$M_ABORT>,-
		UCB$W_XG_RCVERR(R5)	
	BNEQ	15$

	.IF	DF ERR$$
	bbc	#xg$v_latency_rcv,-		; if BC fatal error not due
		ucb$w_xg_rcverr(r5),110$	; to a latency problem
	incw	ucb$w_xg_rcvlat(r5)		; inc the latency error count
	brb	120$
110$:	incw	ucb$w_xg_rcvnxm(r5)
120$:
	.ENDC	;DF ERR$$$

	CLRL	R4				; Set fatal error on device
	BSBW	SCHED_FORK			; Schedule the fork
	BRW	INTEXIT

13$:	CLRW	UCB$W_XG_RCVERR(R5)		; Set no error
15$:	BBS	#XG_DS_V_RCVPS,-		; If BS then complete sec buffr
		UCB$W_DEVSTS(R5),20$
	BITW	#XG$M_DONE_P,XG$C_RCV_CSR(R4)	; If EQL buffer not compl
	BEQL	30$				; unexpected condition
	REMQUE	@UCB$Q_XG_RCV_INPR(R5),R1	; Get next buffer to complete
	BVS	17$				; If BS then unexpected interrupt
16$:	BICW	#XG_DS_M_RCV_DONEP,-		; Set that the buffer can be
		UCB$W_DEVSTS(R5)		; reloaded
	MOVW	UCB$W_XG_RCVERR(R5),-		; Set any errors
		RCV_W_ERROR(R1)
	MOVW	#XG$C_PRI_RCV1,XG$C_MISC_REG(R4) ; Set up to get bytes xfered
	MOVW	XG$C_IND_ADDR(R4),R0		; Get bytes transfered
	BICW	#^X<C000>,R0			; Clear high order bits
	SUBW3	R0,UCB$W_DEVBUFSIZ(R5),RCV_W_MSGSIZ(R1) ; Get actual xfered
	INSQUE	(R1),@UCB$Q_XG_POST+4(R5)	; Insert into post queue
	BISW	#XG_DS_M_RCVPS,-		; Flip the bit to say that the
		UCB$W_DEVSTS(R5)		; next inter is expected on Sec
17$:	SOBGTR	R2,10$				; If GTR more work
	BRB	30$				; Else return 
20$:	BITW	#XG$M_DONE_S,XG$C_RCV_CSR(R4)	; If EQL sec buf has not comp'd
	BEQL	30$				; Branch unexpected interr
	REMQUE	@UCB$Q_XG_RCV_INPR(R5),R1	; Get next buffer to complete
	BVS	17$				; If VS then unexpected interr
	BICW	#XG_DS_M_RCV_DONES,-		; Set that the sec buff can be
		UCB$W_DEVSTS(R5)		; reloaded
	MOVW	UCB$W_XG_RCVERR(R5),-		; Set any errors
		RCV_W_ERROR(R1)
	MOVW	#XG$C_SEC_RCV1,XG$C_MISC_REG(R4) ; Set up to get bytes xfered
	MOVW	XG$C_IND_ADDR(R4),R0		; Get bytes transfered
	BICW	#^X<C000>,R0			; Clear high order bits
	SUBW3	R0,UCB$W_DEVBUFSIZ(R5),RCV_W_MSGSIZ(R1) ; Get actual xfered
	INSQUE	(R1),@UCB$Q_XG_POST+4(R5)	; Insert into post queue
	BICW	#XG_DS_M_RCVPS,-		; Flip the bit to say that the
		UCB$W_DEVSTS(R5)		; next inter is expected on pri
	BRB	17$				; Any more work?

30$:	BSBW	START_RECEIVE			; Start any receives
	BLBC	R0,INTERR			; If clear then problem
	MOVZWL	S^#SS$_NORMAL,R4		; Set no errors
35$:	BITL	#<XM$M_CHR_HDPLX!-		; If EQL then mode of device is
		XM$M_CHR_TRIB>,-		; not Half dup or Trib
		UCB$L_DEVDEPEND(R5)
	BEQL	36$
	TSTB	UCB$B_XG_XMTCNT(R5)		; Else check to make sure all
	BGTR	38$				; outstandng XMT's have comp'd
36$:	BSBB	SCHED_FORK			; Fork			
38$:	BRB	INTEXIT				; Exit interrupt

40$:	ENBINT					; Retore IPL
	BRB	INTERR				; Exit setting error
;
; Exit interrupt
;
INTEXIT:					; Exit interrupt
	MOVQ	(SP)+,R0
	MOVQ	(SP)+,R2		
	MOVQ	(SP)+,R4		
	REI				
;
; An unexpected interrupt occured.  Since there is no NOP function to initiate,
; the device must be shutdown.
;
;
INTERR:						; 
	BSBW	TIMEOUT				; Fake a timeout error
	BRB	INTEXIT
;
;	INPUT	R4 = Device status
;		R5 = UCB address
;
SCHED_FORK:
	BBSS	#XG_DS_V_FORK_PEND,-		; Set fork pending
		UCB$W_DEVSTS(R5),10$
	PUSHAB	B^FORK_DONE			; Push return address
	JMP	G^EXE$FORK			; Fork down to  FIPL
10$:	BLBS	R4,20$				; If BS then no need to set err
	MOVL	R4,UCB$L_FR4(R5)		; Else set error in fork block
20$:	RSB



	.SBTTL	FORKDONE - Fork process
;++
; FORKDONE - Fork process 
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is entered at device fork level when a buffer done
; has occured. 
;
; INPUTS:
;
;	R4 = Status from interrupt
;	R5 = UCB address
;
;	IPL = FIPL
;
; OUTPUTS:
;
;	R5 = UCB address
;	R6 - R9 are preserved.
;
;	If a receive I/O request is pending, the receive is completed.
;	Otherwise, queue the message for a future I/O.
;
;--
FORK_DONE:
	BLBC	R4,23$				; If LBC then fatal error
	CLRBIT	#XG_DS_V_FORK_PEND,-		; Clear fork pending
		UCB$W_DEVSTS(R5)

	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		FORK_DONE_LAPB,-		; LAPB
		40$,-				; BISYNC
		>				; Fall thru on DDCMP
	PUSHR	#^M<R6,R7,R8,R9>		; Save registers
5$:	REMQUE	@UCB$Q_XG_POST(R5),R2		; Get next buffer to complete 
	BVS	20$				; If VS then no buffer found
	CMPB	IRP$B_TYPE(R2),S^#DYN$C_BUFIO	; If NEQ then not XMT buffer
	BNEQ	10$
	BSBW	TRANSMIT_DONE			; Complete the transmit
	BLBC	R0,25$				; If BC then error on buffer
	BRB	15$
10$:	CMPB	IRP$B_TYPE(R2),S^#DYN$C_NET	; If EQL then RCV buffer
	BNEQ	30$
	BSBW	RECEIVE_DONE			; Complete the Receive
	BLBC	R0,25$				; If BC then error on buffer
15$:	TSTB	UCB$B_XG_XSTATE(R5)		; If NEQ then transmitter going
	BNEQ	17$
	CLRL	R1				; Set no status for start xmt
	BSBW	START_TRANSMIT			; Else try to start up a xmt
	BLBC	R0,25$				; Branch BC error
17$:	BRB	5$
20$:	TSTB	UCB$B_XG_XSTATE(R5)		; If NEQ then transmitter going
	BNEQ	22$
	CLRL	R1				; Set no status for start xmt
	BSBW	START_TRANSMIT			; Else try to start up a xmt
	BLBC	R0,25$				; Branch BC error
22$:	MOVZWL	S^#SS$_NORMAL,R0		; Set status
	POPR	#^M<R6,R7,R8,R9>		; Restore registers
	RSB					; Return

23$:	INCW	UCB$W_ERRCNT(R5)		; Adjust count
	SETBIT	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5) ; Set fatal error
	BSBW	POKE_USER			; Tell owner
	BRW	SHUTDOWN_LINE			; Shutdown the line
						; shut down device

25$:	POPR	#^M<R6,R7,R8,R9>		; Restore registers
	BBC	#XM$V_ERR_TRIB,-		; Assume trib shutdown
		UCB$L_DEVDEPEND(R5),28$
	BRW	SHUTDOWN_CIRCUIT
28$:	BRW	SHUTDOWN_LINE			; Br to shut down the device

30$:	BUG_CHECK NOBUFPCKT,FATAL		; Else fatal, error

40$:	BRW	FORK_DONE_BISYNC


	.SBTTL	FORK_DONE_LAPB
;++
; FORK_DONE_LAPB - Fork process for LAPB
;
; This routine does fork processing for LAPB.
;
;	INPUTS	R5 = UCB address
;
;	IPL = FIPL
;
;	OUTPUTS R5-R8 are preserved
;
;++
FORK_DONE_LAPB:
5$:	REMQUE	@UCB$Q_XG_POST(R5),R1		; Get next buffer to complete
	BVS	40$
	CMPB	IRP$B_TYPE(R1),S^#DYN$C_BUFIO	; If NEQ then not XMT buffer
	BNEQ	20$
	MOVL	XMTQ$L_IRP(R1),R3		; Get IRP address
	MOVW	XMTQ$W_MSGSIZE(R1),R0		; Get size of transfer
	ASHL	#16,R0,R0			; Move to high word
	BNEQ	10$				; If NEQ then ok
	MOVW	#SS$_CTRLERR,R0			; Set error
	BRB	15$
10$:	MOVW	S^#SS$_NORMAL,R0		; Set normal return assume suc
	BBSC	#XG_DS_V_CLEAN,UCB$W_DEVSTS(R5),35$ ; If BC then do not abort
15$:	MOVL	R0,IRP$L_MEDIA(R3)		; Set status and size
	BSBW	TRANSMIT_IO_DONE		; Complete the I/O
	BRB	5$
20$:	CMPB	IRP$B_TYPE(R1),S^#DYN$C_NET	; If NEQ then not RCV buf
	BNEQ	50$
	BITW	#<XG$M_BCC_ERR!XG$M_RES_BIT_CNT>,- ; If neq then no error
		RCV_W_ERROR(R1)
	BNEQ	45$
	REMQUE	@UCB$Q_XG_RCVS(R5),R3		; Get free I/O packet
	BVS	30$				; If VS then none waiting
	MOVL	R1,R2				; Set up buffer for done
	MOVAL	RCV_Z_HEADER(R2),(R2)		; Set address of data
	MOVZWL	RCV_W_MSGSIZ(R2),R0		; Get size of transfer
	BSBW	FINISH_RCV_IO_LAPB		; Complete the request
	BRB	5$
30$:	INSQUE	(R1),@UCB$Q_XG_ATTN+4(R5)	; Queue buffer to await I/O
	BRB	5$				; Get next buffer to complete
35$:	MOVW	#SS$_ABORT,R0			; Else set abort status
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Set protocol buffer address
	BSBW	CLEAN_FORK_ENTRY		; Clean outstanding on device
40$:	MOVZWL	S^#SS$_NORMAL,R0		; Set status
	RSB

; On error come here
45$:	MOVL	UCB$A_XG_PRO_BUFFER(R5),R0	; Get protocol buffer
	INCB	LAPB$B_DEI(R0)			; Incr error counter
	BCC	48$			; If BC then carry not set
	DECB	LAPB$B_DEI(R0)			; Else set to max value
48$:	INSQUE	(R1),@UCB$Q_XG_FREE+4(R5)	; Return the buff to free list
	DSBINT	UCB$B_DIPL(R5)			; Disable interrupts
	BSBW	START_RECEIVE			; Start any receives
	ENBINT					; Enable interrupts
	BRW	5$				; Complete next req

50$:	BUG_CHECK NOBUFPCKT,FATAL		; fatal error


	.SBTTL	FORK_DONE_BISYNC - Fork routine for BISYNC mode
;++
; FORK_DONE_BISYNC - Fork routine for BISYNC mode
;
; This routine does the fork processing for BISYNC. Only XMT's will
; come thru here. Rcv's are complete via the BISYNC timer routine
;
;--
FORK_DONE_BISYNC:
5$:	REMQUE	@UCB$Q_XG_POST(R5),R1		; Get next buffer
	BVS	40$				; If VS then none
	CMPB	XMTQ$B_BUFTYP(R1),S^#DYN$C_BUFIO ; If NEQ then something wrong
	BNEQ	50$

; This bit must be cleared to allow retransmits over the bisync protocol.

	CLRBIT	#XG_DS_V_XMTING,UCB$W_DEVSTS(R5) 
	MOVL	XMTQ$L_IRP(R1),R3		; Get the IRP address
	MOVZWL	XMTQ$W_MSGSIZE(R1),R0		; Get the message size
	ASHL	#16,R0,R0			; Shift size into high word
	BNEQ	10$
	MOVW	#SS$_CTRLERR,R0			; Set error
	BRB	20$				; Branch to complete the IO
10$:	MOVW	S^#SS$_NORMAL,R0		; Set successful status
	BBSC	#XG_DS_V_CLEAN,UCB$W_DEVSTS(R5),30$ ; If BS then clean outstanding
20$:	MOVL	R0,IRP$L_MEDIA(R3)		; Set status
	BSBW	TRANSMIT_IO_DONE		; Complete the request
	BRB	5$				; Get next XMT to complete
30$:	MOVW	#SS$_ABORT,R0			; Set abort status
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get the protocol buffer
	BSBW	CLEAN_FORK_ENTRY
40$:	MOVZWL	S^#SS$_NORMAL,R0
	RSB

50$:	BUG_CHECK	NOBUFPCKT,FATAL


	.SBTTL	RECEIVE_DONE - Complete a receive buffer

;++
;RECEIVE_DONE
;
; FUNCTIONAL DESCRIPTION:
;
; When the board receives a buffer this routine is called to complete it. First
; a call is made to the protocol to strip off the header and use the
; appropriate information. If a non-fatal error is detected then the error is
; recorded in the protocol and the buffer os returned to the free buffer pool,
; and NOT given to the user. If no error occurs and the buffer is a protocol
; control message then the buffer is returned to the free buffer pool. if this
; is a data message and a IRP is free the buffer is completed with the IRP,
; else it is put on a queue to await I/O completion.
;
;	INPUTS:	R2 = Message buffer address
;		R5 = UCB address
;
;	OUTPUTS R0 = Status
;		R2,R3,R5 are preserved
;--
RECEIVE_DONE:					; Receive done 
	PUSHR	#^M<R2,R3,R5>			; Save registers
	MOVZBL	#DLK$C_RCVMSG,R6		; Set that this is a RCV
	CLRL	R7				; Clear error bits
	BITW	#<XG$M_BCC_ERR!XG$M_RES_BIT_CNT>,- ; If EQL then no CRC error
		RCV_W_ERROR(R2)
	BEQL	10$
	MOVZWL	RCV_L_BACC+2(R2),R0		; Else check for header or data
	SUBW2	UCB$W_DEVBUFSIZ(R5),R0		; error
	CMPB	#XG$C_HEADER,R0			; If EQL then data crc error
	BEQL	5$
	BISW	#DLK$M_HDRCRC,R7		; Set header CRC error
	BRB	15$
5$:	BISW	#DLK$M_DATACRC,R7		; Set data CRC error
	BRB	15$
10$:	BBC	#XG$V_BUFOVR,-			; If BC then no buffer overrun
		RCV_W_ERROR(R2),15$
	BISW	#DLK$M_RCVOVR,R7		; Else set rcv overrun
	SETBIT	#XM$V_ERR_LOST,UCB$L_DEVDEPEND(R5) ; Set data lost error
15$:	MOVAL	RCV_Z_HEADER(R2),R8		; Get buffer address
	CLRL	R9				; Clear reg
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Set protocol buffer address
	BSBW	DDCMP
	POPR	#^M<R2,R3,R5>			; Restore registers
	MOVW	R9,RCV_W_MSGSIZ(R2)		; Set transfer size
	CMPB	#DLK$C_ACTNOTCOM,R6		; If EQL then protl not active
	BEQL	40$
	BITW	#<DLK$M_PRSTERR!-		; If NEQ then fatal protocol
		DLK$M_HDRERR>,R7		; error go to shutdown the
	BNEQ	55$				; circuit
	BITW	#<DLK$M_STRTRCV!-		; If NEQ then trib error
		DLK$M_MNTRCV>,R7		; go to shutdown the circuit
	BNEQ	60$
	BBC	#DLK$V_TRNLK,R7,20$		; If BC don't turn link
	BICW	#XG_DS_M_XMTING,-		; Start transmitter
		UCB$W_DEVSTS(R5)
	PUSHR	#^M<R2,R7>			; Save the register
	CLRL	R1				; Set no status for start xmt
	BSBW	START_TRANSMIT			; Start the tranmsit
	POPR	#^M<R2,R7>			; Restore the register
	BLBC	R0,70$				; Branch on error
20$:	BBC	#DLK$V_XMTCMP,R7,23$		; If BC no transmit to complete
	PUSHL	R2				; Save receive buffer
	BSBW	FINISH_XMT_IO			; Else branch to post the I/O
	POPL	R2				; Restore receive buffer
23$:	BBC	#DLK$V_RCVACK,R7,40$		; If BC then not a data message

	REMQUE	@UCB$Q_XG_RCVS(R5),R3		; Remov waiting rcv I/O request
	BVS	25$				; VS then no packet to complete
	BRB	FINISH_RCV_IO			; If found then finish the I/O

25$:	INSQUE	(R2),@UCB$Q_XG_ATTN+4(R5)	; Else, queue message buffer
30$:	BSBW	POKE_USER			; Poke the user
	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	RSB

40$:	INSQUE	(R2),@UCB$Q_XG_FREE+4(R5)	; Return the buff to free list
	DSBINT	UCB$B_DIPL(R5)			; Disable interrupts
	BSBW	START_RECEIVE			; Start any receives
	ENBINT					; Enable interrupts
50$:	RSB

55$:	SETBIT	#XM$V_ERR_FATAL,-		; Set that a fatal error occurd
		UCB$L_DEVDEPEND(R5)

	.IF	DF ERR$$$
	incw	ucb$w_xg_prst(r5)		; inc persitant error count
	.ENDC	;DF ERR$$$

	BRB	65$	
60$:	BISL	#<XM$M_ERR_START!-		; Assume the trib error occurrd
		XM$M_ERR_TRIB>,-		; because a STRT was received
		UCB$L_DEVDEPEND(R5)

	.IF	DF ERR$$$
	incw	ucb$w_xg_strt(r5)		; inc start rcv'd error count
	.ENDC	;DF ERR$$$

	BBC	#DLK$V_MNTRCV,R7,65$		; If BC then true
	CLRBIT	#XM$V_ERR_START,UCB$L_DEVDEPEND(R5)
	SETBIT	#XM$V_ERR_MAINT,UCB$L_DEVDEPEND(R5) ; Else set maint msg rcv'd
65$:	MOVZWL	#SS$_DEVINACT,R0		; Set protocol inactive
70$:	INSQUE	(R2),@UCB$Q_XG_FREE+4(R5)	; Return the buff to free list
	RSB


	.SBTTL	FINISH_RCV_IO - Finish receive I/O processing
;++
; FINISH_RCV_IO - Finish receive I/O processing
;
; FUNCTIONAL DESCRIPTION:
;
; This routine completes a receive operation that has been matched with a
; message block. After the receive has been completed the message free list is 
; filled and a receive is started if needed.
;
; INPUTS:
;
;	R2 = message buffer address
;	   = 0 if I/O is being aborted
;	R3 = I/O packet address
;	R5 = UCB address
;
;	IPL = FIPL
;
;	For FINISH_RCV_IO_LAPB (R2) = address of data
;				R0  = transfer size of message
;
; OUTPUTS:
;
;	R5 = UCB address
;
;	The request is completed via I/O post.
;--
FINISH_RCV_IO:					; Finish receive I/O request
	MOVAL	RCV_T_DATA(R2),(R2)		; Insert address of the data
	MOVZWL	RCV_W_MSGSIZ(R2),R0		; Get size of transfer
FINISH_RCV_IO_LAPB:
FINISH_RCV_IO_BISYNC:
	CLRL	R1				; Assume error
	MOVL	R2,IRP$L_SVAPTE(R3)		; Save block address
	MOVL	IRP$L_MEDIA(R3),4(R2)		; Insert saved user VA
	ADDW	UCB$W_DEVBUFSIZ(R5),-		; Adjust unit quota
		UCB$W_XG_QUOTA(R5)
	CMPW	R0,IRP$W_BCNT(R3)		; Request larger than actual?
	BLEQU	20$				; Br if no
	MOVZWL	IRP$W_BCNT(R3),R0		; Set size to min. of two sizes
20$:	MOVW	R0,IRP$W_BCNT(R3)		; Set size to transfer
	ASHL	#16,R0,R0			; Set up status
	BNEQ	25$				; Br if success
	MOVW	#SS$_CTRLERR,R0			; Set data path error
	BRB	30$
25$:	MOVW	S^#SS$_NORMAL,R0		; Set success
30$:	MOVL	R0,IRP$L_MEDIA(R3)		; Set status and size

	MOVB	#DYN$C_BUFIO,IRP$B_TYPE(R2)	; PSI expects this in all buffs
	BSBB	IO_DONE				; Post the I/O request
	BSBW	FILLFREELIST			; Return rcv buffer to free q
	RSB					; and start next RCV

;
; Complete a transfer I/O operation
;
TRANSMIT_IO_DONE:
	BBC	#XMTQ$V_INTERNAL,-		; If BC then not an "Interal"
		XMTQ$B_FLAG(R1),IO_DONE		; IRP, else must dealloc the
						; buffer used to transmit
	PUSHR	#^M<R3,R5>			; Save registers
	MOVL	R1,R0				; Set to dealloc the buffer
	JSB	G^COM$DRVDEALMEM		; Deall the buffer
	POPR	#^M<R3,R5>			; Restore registers
IO_DONE:					; Comp a transfer I/O operation
	MOVL	UCB$L_DEVDEPEND(R5),-		; Set other info
		IRP$L_MEDIA+4(R3) 

; Clear bit because it has been reported to the user

	CLRBIT	#XM$V_STS_ORUN,UCB$L_DEVDEPEND(R5) 
	BBC	#IRP$V_DIAGBUF,-		; Br if no diagnostic buffer
		IRP$W_STS(R3),20$ 
	ADDL3	#8,@IRP$L_DIAGBUF(R3),R0 	; Addr buffer past start time
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+		; Insert stop time
	MOVZWL	UCB$W_ERRCNT(R5),(R0)+		; Insert error counter
	BSBW	REGDUMP
20$:	JMP	G^COM$POST			; Post the I/O



	.SBTTL	TRANSMIT_DONE - Transmit completion routine
;++
; TRANSMIT_DONE - Transmit completion routine
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called when a transmit buffer needs completion. If the
; transmit buffer completed was a protocol control buffer then nothing
; happens with the buffer. In fact it should be part of a permantly allocated
; structure such as the UCB. If the transmit was a data buffer, the routine
; calls the protocol to deal with the buffer. If the protocol notifies the
; driver that it has XMT's to send to I/O completion, the driver pulls these
; buffers off the complete queue and sends them off to complete via COM$POST.
;
; INPUTS:
;	R2 = Address of buffer to complete
;	R3 = If error then contains the error from the device
;	R5 = UCB address
;
;	IPL = FIPL
;
; OUTPUTS:
;
;	R5 = UCB address
;
;--
TRANSMIT_DONE:
	MOVL	R2,R8				; Put buffer addr into R8
	PUSHR	#^M<R2,R3,R5>			; Save registers
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Set protocol buffer address
	MOVZBL	#DLK$C_XMTMSG,R6		; Set up to put on RTOQ if the
	MOVZBL	#DLK$M_MSGSENT,R7		; msg needs to be timed out
	CLRL	R9
	BSBW	DDCMP				; Branch to protocol
	POPR	#^M<R2,R3,R5>			; Restore registers
	BBC	#DLK$V_XMTCMP,R7,30$		; If BC then no XMT's to compl
	BSBB	FINISH_XMT_IO			; Else complete the XMT
30$:	MOVZWL	S^#SS$_NORMAL,R0		; Set normal return
	RSB

FINISH_XMT_IO:
	PUSHR	#^M<R6,R7,R8,R9>		; Save registers
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R6	; Get protocol buffer address
5$:	REMQUE	@TF$Q_CMPQ(R6),R8		; Get the next entry on queue
	BVS	20$				; If VS then branch to finish
	MOVL	XMTQ$L_IRP(R8),R3		; Get IRP associated with XMT
	MOVZWL	XMTQ$W_MSGSIZE(R8),R0		; Get transfer size
	SUBW2	#XG$C_HEADER,R0			; Subtract out the protocol hdr
	ASHL	#16,R0,R0			; Set up status
	BNEQ	10$				; Br if data transmitted
	MOVW	#SS$_CTRLERR,R0			; Set device error
	BRB	15$
10$:	MOVW	#SS$_NORMAL,R0			; Assume success
15$:	MOVL	R0,IRP$L_MEDIA(R3)
	MOVL	R8,R1				; Set XMTQ buff address
	BSBW	TRANSMIT_IO_DONE		; Complete the IO
	BRB	5$				; Get next to complete
20$:	POPR	#^M<R6,R7,R8,R9>		; Restore registers
	RSB

	.SBTTL	TIMER - CTS and Device timer wakeup routines

;++
;CTS_TIMER - CTS wakeup routine
;
; This routine is called to check if CTS has come high
;
; Inputs:
;		R5 = Address of CTS TQE entry in UCB
;
;--
CTS_TIMER:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Save the registers
	SUBL	#UCB$L_XG_TQE,R5		; Point to start of UCB
	DSBINT	UCB$B_FIPL(R5)			; Sync access to unit
	BICW2	#XG_DS_M_CTSTQE_RUN,UCB$W_DEVSTS(R5) ; Set timer not q'd
	BBC	#XG_DS_V_INITED,UCB$W_DEVSTS(R5),20$ ; If BC then device not active
	TSTB	UCB$B_XG_XSTATE(R5)		; If EQL then idle
	BEQL	20$
	BLBS	UCB$B_XG_XSTATE(R5),20$		; If set then XMT'r is "ON"
	CMPB	#XG$C_DRPCTS,UCB$B_XG_XSTATE(R5) ; If NEQ then not drop 
	BNEQ	5$				; CTS state
	CLRB	UCB$B_XG_XSTATE(R5)		; Set up to see if we can
	BRB	10$				; transmit and try to start up
5$:
	.IF	DF CTS$$$
	movzbl	ucb$b_cts_last(r5),r0		; set slot to incr
	incb	ucb$b_cts_buf(r5)[r0]
	.ENDC					; DF CTS$$$ end

	MOVB	#XG$C_SWFCTS,UCB$B_XG_XSTATE(R5) ; Short WCTS state
10$:	CLRL	R1				; Set no status for start xmt
	BSBW	DEVTIMER_ALT			; Restart transmit
20$:	ENBINT					; Reset IPL
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Restore registers
	RSB


;++
; DEVTIMER - Device wakeup routine
;
; Functional Description:
;
; This routine is called when the protocol timer every second when the
; protocol timer ticks to start any transmits the protocol may
; have queued as a result of the timer going off. It also checks for CTS coming
; high as a result of RTS being asserted.
;
;	INPUTS:
;		R1 = Error status from protocol specific timer routine
;		R5 = Address of the UCB
;
;
;	OUTPUTS:
;		R0 = Status of line is LBS then line is up
;				       LBC then line is down
;		R1 = Return error status from driver
;		On error the line is shut down
;
	.ENABL	LSB
DEVTIMER:
	
; First check to see if the timer on the xmt inprogress has expired
; If it has then we will increment the error counter for the device
; and shutdown the board.

	DSBINT	UCB$B_DIPL(R5)
	MOVL	UCB$L_XG_XMTEND(R5),R2		; If EQL no xmt inporgress
	BEQL	2$
	MOVL	G^EXE$GL_ABSTIM,R0		; Get time
	CMPL	R0,R2				; If LEQ then no expired
	BLEQ	2$
	ENBINT
	INCW	UCB$W_ERRCNT(R5)		; Incr the error counter
	BRW	30$				; Go to shut down the device

2$:	ENBINT
	BBS	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5),30$ ; If BS then fatal err
	BBS	#DLK$V_PRSTERR,R1,30$		; If BS then psrt err shut down
						; the device
	TSTB	UCB$B_XG_XSTATE(R5)		; If NEQ then transmitter going
	BNEQ	10$
;
; If the protocol timer has expired then clear the XMTING flag so that
; the control message which must be sent can be. This is true when the
; device is running half duplex. If the message with the select flag is dropped
; then we must be sure that we can send anouthe message with a select flag.
;
	BBC	#DLK$V_TMREXPD,R1,5$
	CLRBIT	#XG_DS_V_XMTING,UCB$W_DEVSTS(R5)
5$:	PUSHL	R1
	BSBW	START_TRANSMIT			; Else try to start a transmit
	POPL	R1
	BLBC	R0,30$				; If LBC then fatal error
	BICW	#DLK$M_TMREXPD,R1		; Clear timer expired
	RSB

10$:	MOVL	#SS$_NORMAL,R0			; Assume device is ok.
	BLBS	UCB$B_XG_XSTATE(R5),15$		; If LBC then XMTer is on
	BBS	#XG_DS_V_CTSTQE_RUN,UCB$W_DEVSTS(R5),15$ ; Br if CTS timer is
						;   running
	DSBINT	UCB$B_DIPL(R5)			; Disable interr
	MOVL	UCB$L_CRB(R5),R1		; Get the CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; Get the CSR
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Set to get modem IR
	BITW	#XG$M_CTS,XG$C_IND_ADDR(R4)	; Has CTS been detected
	ENBINT					; Enable interrupts
	BEQL	20$				; If EQL then not detected
	MOVB	#XG$C_XMTING,-			; Set state to XMTing
		UCB$B_XG_XSTATE(R5)

DEVTIMER_ALT:
	BSBW	START_TRANSMIT			; Start the transmit
	BLBC	R0,30$				; If LBC then problem
15$:	RSB

20$:	BBS	#XM$V_CHR_TRIB,-		; If BS then trib mode don't
		UCB$L_DEVDEPEND(R5),22$		; time the return of CTS
	DECB	UCB$B_XG_WFCTS_SEC(R5)		; If EQL then device hasn't
	BEQL	25$				; repsonded in a reasonable tim
22$:	RSB

25$:	SETBIT	#XM$V_STS_DISC,UCB$L_DEVDEPEND(R5)  ; Set modem disconnect sts

	.IF	DF ERR$$$
	incw	ucb$w_xg_disc(r5)		; inc disconect modem err count
	.ENDC	;DF ERR$$$

;
; TFB/GFB blocks are deallocated on shutdown. Make sure R0 is
; clear so that the timer routine does not try to access them.
;
30$:	SETBIT	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5) ; Set fatal error
	BSBW	SHUTDOWN_LINE			; Shut down the device
 	CLRL	R0
	RSB
	.DSABL	LSB


	.SBTTL	BISYNC_TIMER - Bisync timer
;++
; BISYNC_TIMER - Bisync mode timer routine
;
; This is the timer routine for BISYNC operation. Each time the clock ticks,
; it calls this routine to check first if a XMT is waiting for CTS to come
; high. Second to see if any characters were received by the RCVer. If
; characters were received then it will call the framming routine to
; find out what to do with the character. That is how the character gets put
; into the actual receive buffer that will get posted to the  user.
; The following is a diagram of the possible status the framing 
; routine may retrun.
;
; The following indicates bits returned in R0 from the framming routine:
;
; BIT 0: BCHAR = Buffer the character
; BIT 1: BCHRP = Buffer the character in the previous position
; BIT 2: CMPBF	= Complete the receive to the user
;
;	 _____________________________
;	!  CMPBF !  BCHRP   !  BCHAR  !
;	!-----------------------------!
;	!   0     !   0     !   0     ! Buffer the character in next position
;	!   0     !   0     !   1     ! Ignore the character
;	!   0     !   1     !   0     ! Illegal state
;	!   0     !   1     !   1     ! Buffer the character in previous position
;	!   1     !   0     !   0     ! Buffer the character in the next postion and complete the read
;	!   1     !   0     !   1     ! Ignore the character and complete the read
;	!   1     !   1     !   0     ! Illegal state
;	!   1     !   1     !   1     ! Buffer character in previous position and complete the read
;       ! ----------------------------!
;
;	INPUTS 
;		R5 = TQE address
; 		IPL = timer IPL
;
;	OUTPUTS 
;		All regs preserved.
;		IRP may be completed VIA IOPOST
;--
BISYNC_TIMER:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVL	TQE$L_FR4(R5),R4		; Set R4 with protocol buffer address
	MOVL	TQE$L_FR3(R5),R5		; Set R5 with UCB address
	TSTB	UCB$B_XG_XSTATE(R5)		; If EQL XMTer is idle
	BEQL	CHECK_RCV
	BRW	CHECK_XMT			; Else go see what the XMTr is 
						; waiting for
CHECK_RCV:
	PUSHL	R4				; Save R4 addr of protocol buffer
	MOVL	UCB$L_CRB(R5),R1		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; Get device CSR
	DSBINT	UCB$B_DIPL(R5)			; Sync to DIPL to read device regs
	BITW	#XG$M_ERROR,XG$C_RCV_CSR(R4)
	BEQL	5$
	ENBINT
	POPL	R4
	BRB	RCV_ERROR
5$:	ENBINT
	BBC	#XG_DS_V_RCV_DONEP,UCB$W_DEVSTS(R5),10$ ; BC buff not queued
	MOVZWL	UCB$W_XG_RCV_INIT(R5),R2	; Get count of # of bytes to input
	DSBINT	UCB$B_DIPL(R5)			; Sync to DIPL to read device regs
	MOVW	#XG$C_PRI_RCV1,XG$C_MISC_REG(R4) ; Set char count reg to read
	MOVZWL	XG$C_IND_ADDR(R4),R3		; Get the count
	BEQL	30$				; Br EQL no more chars to rcv
	ENBINT					; Reset interrupts
	POPL	R4				; Restore protocol buffer address
	INSV	#0,#15,#2,R3			; Clear high order bits
	SUBW2	R3,R2				; Get number of char input since last tick
	BEQL	20$				; If eql then none
	MOVL	UCB$L_XG_RCV_INPR(R5),R8	; Get buffer to move rcv data to
	BEQL	20$				; If EQL then buffer complete
	MOVAL	RCV_Z_HEADER(R8),R8		; Get the start of the data
	MOVZWL	UCB$W_XG_RCV_INPR_INDX(R5),R9	; Get the index into the buffer
	MOVW	R3,UCB$W_XG_RCV_INIT(R5)	; Update saved count
	MOVL	BISYNC$A_RCV_BUFFER(R4),R6	; Get address of buffer given to device
	MOVAL	RCV_Z_HEADER(R6),R6		; Get address of data
	MOVZWL	BISYNC$W_RCV_INDEX(R4),R7	; Get the index into that buffer
	CLRBIT	#BISYNC$V_RCV_COMPLETE,BISYNC$W_STATUS(R4)
	BRB	CHECK_NEXT

10$:	POPL	R4
20$:	BRW	TIMER_END 

30$:	ENBINT					; Reset interrupts
	POPL	R4				; Restore protocol buffer address
	BRW	TIMER_END_CHKCMP

RCV_ERROR:
	SETBIT	#XM$V_STS_ORUN,UCB$L_DEVDEPEND(R5)
	REMQUE	@UCB$Q_XG_RCVS(R5),R3		; If there is an rcv posted
	BVS	10$				; complete it in error 
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)
	PUSHL	R4
	BSBW	IO_DONE
	POPL	R4
10$:	BRW	TIMER_END_CHKCMP_ALT

CHECK_NEXT:
	MOVZBL	(R6)[R7],R1			; Get next char
	INCW	R7				; Incr the index
	MOVAL	UCB$Q_XG_STATE_INFO(R5),R0	; Pass address of state info
	JSB	@UCB$A_XG_FRAME_ADDR(R5)	; Branch to the framing routine

	ASSUME	XG$V_BUFFER_CHAR EQ 0
	ASSUME	XG$V_BUFFER_IN_PREV_POS EQ 1
	ASSUME 	XG$V_COMPLETE_READ EQ 2

	CASE	R0,TYPE=B,<-			; Case according to result in R0
		BCHAR_NPOS,-			; Buffer char in next position
		IGN_CHAR,-			; Ignore character
		ILLEGAL,-			; Illegal state
		BCHAR_PPOS,-			; Buffer char in prev position
		BCHAR_NPOS_CMP,-		; Buffer char in nxt pos and cmp
		IGN_CHAR_CMP,-			; Ignore char and complete read
		ILLEGAL,-			; Illegal state
		BCHAR_PPOS_CMP>			; Buffer char in prev pos and cmp read

ILLEGAL: 	BUG_CHECK	NOBUFPCKT,FATAL

; 
; For the following routines please remember:
;
;	R1 = Character to buffer
;	R4 = Protocol buffer address
; 	R5 = UCB address
;	R6 = Address of rcv buffer given to board
;	R7 = Index into above buffer
;	R8 = Address of rcv buffer which will be completed to the user
;	R9 = Index into above buffer
;

BCHAR_NPOS:
	MOVB	R1,(R8)[R9]		; Mov byte into position
	INCW	R9			; Incr the index
					; Fall thru to do next char
IGN_CHAR:
	SOBGTR	R2,CHECK_NEXT		; Branch to check next char
	BRB	TIMER_END_UPD		; If out of chars go to timer end

BCHAR_PPOS:
	SUBL3	#1,R9,R0		; Set index to previous position
	MOVB	R1,(R8)[R0]		; Buffer the character
	SOBGTR	R2,CHECK_NEXT		; Branch to check the next char
	BRB	TIMER_END_UPD		; If out of chars go to timer end

BCHAR_NPOS_CMP:
	MOVB	R1,(R8)[R9]		; Buffer char in position
	INCW	R9			; Incr the index
	DECW	R2			; Decr in count
					; Fall thru to jump to complete
IGN_CHAR_CMP:
	BRB	TIMER_END_COMP

BCHAR_PPOS_CMP:
	SUBL3	#1,R9,R0		; Set the index to the previous pos
	MOVB	R1,(R8)[R0]		; Buffer char
	DECW	R2			; Decr char count
					; Fall thru to complete the message
TIMER_END_COMP:
	SETBIT	#BISYNC$V_RCV_COMPLETE,BISYNC$W_STATUS(R4) ; Set that the rcv is cmp
	BSBW	STOP_RCV_BISYNC		; Stop the receiver
	REMQUE	@UCB$Q_XG_RCVS(R5),R3	; Get an IRP to complete the RCV
	BVS	10$			; If VS then none
	MOVAL	RCV_Z_HEADER(R2),(R2)	; Set address of the data
	MOVL	R9,R0			; Set address of buffer
	BSBW	FINISH_RCV_IO_BISYNC	; Post Rcv
	DSBINT	UCB$B_DIPL(R5)
	BSBW	START_RECEIVE_BISYNC	; Start next receive
	ENBINT
	BRB	20$
10$:	MOVW	R9,RCV_W_MSGSIZ(R2)	; Set msg size
	INSQUE	(R2),@UCB$Q_XG_ATTN+4(R5) ; Insert on waiting for IO list

; If the device is running in half duplex mode, check to see if a transmit can 
; be send after we receive a message.

20$:	BBC	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5),30$	; If BC not in half duplex
	CLRBIT	#XG_DS_V_XMTING,UCB$W_DEVSTS(R5) ; Set ok to transmit
	CLRL	R1
	BSBW	START_TRANSMIT		 ; try to send a message
30$:	BRB	TIMER_END

TIMER_END_UPD:
	MOVW	R3,UCB$W_XG_RCV_INIT(R5) ; Update # of chars left to input in rcv buffer
	MOVW	R9,UCB$W_XG_RCV_INPR_INDX(R5) ; Update index of buffer to be given to user
	MOVW	R7,BISYNC$W_RCV_INDEX(R4) ; Update index of buffer given to device

TIMER_END:
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9>
	RSB

TIMER_END_CHKCMP:	
	BBS	#BISYNC$V_RCV_COMPLETE,BISYNC$W_STATUS(R4),TIMER_END ; If BS ignore
TIMER_END_CHKCMP_ALT:
	BSBW	STOP_RCV_BISYNC		; Stop receiver
	TSTL	R2
	BEQL	10$	
	INSQUE	(R2),@UCB$Q_XG_FREE+4(R5) ; Return buffer to free list
	INCW	BISYNC$W_DROP_RCV(R4)	; Incr the number of droppped msgs	
10$:	DSBINT	UCB$B_DIPL(R5)
	BSBW	START_RECEIVE_BISYNC	; Start the receiver
	ENBINT
; If the device is running in half duplex mode, check to see if a transmit can 
; be send after we receive a message.

	BBC	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5),20$	; If BC not in half duplex
	CLRBIT	#XG_DS_V_XMTING,UCB$W_DEVSTS(R5) ; Set ok to transmit
	CLRL	R1
	BSBW	START_TRANSMIT		 ; try to send a message
20$:	BRB	TIMER_END

CHECK_XMT:
	BLBS	UCB$B_XG_XSTATE(R5),10$	; IF LBS then XMTer is running
	BBS	#XG_DS_V_CTSTQE_RUN,UCB$W_DEVSTS(R5),10$ ; If BS then CTS TQE running
	DSBINT	UCB$B_DIPL(R5)			; Sync to device IPL to test for CTS high
	MOVL	UCB$L_CRB(R5),R1		; Get CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1 	; Get CSR address
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R1) 	; Set to get modem IR
	BITW	#XG$M_CTS,XG$C_IND_ADDR(R1) 	; If EQL then CTS is high
	ENBINT
	BEQL	20$
	MOVB	#XG$C_XMTING,UCB$B_XG_XSTATE(R5) ; Set that device is XMTing
	PUSHL	R4
	BSBW	START_TRANSMIT			; Start up the transmit
	POPL	R4
10$:	BRW	CHECK_RCV			; Check for receive chars
20$:	DECB	UCB$B_XG_WFCTS_SEC(R5)		; if GTR then there is time 
	BGTR	10$				; to wait for CTS 
;
; Else set that a modem dsiconnect occured and then abort the transmits
;	
	SETBIT	#XM$V_STS_DISC,UCB$L_DEVDEPEND(R5)
30$:	REMQUE	@BISYNC$Q_XMTQ(R4),R1		; Get next xmt off queue
	BVS	40$				; If VS then no more
	CMPB	XMTQ$B_BUFTYP(R1),S^#DYN$C_BUFIO
	BNEQ	50$
	MOVL	XMTQ$L_IRP(R1),R3		; get the IRP address
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set abort status
	BSBW	TRANSMIT_IO_DONE
	BRB	30$				; Get next transmit IRP
40$:	CLRB	UCB$B_XG_XSTATE(R5)
	BRW	CHECK_RCV			; Branch to check receive

50$:	BUG_CHECK	NOBUFPCKT,FATAL

	.IF	DF BISYNC$$$
;
; The following is a test framing routine to be included when using the
; driver to test bisync mode in a non-bisync environment.
;
bisync_framing_routine:
	pushl	r2
	movl	r0,r2
	clrl	r0
	incl	(r2)
	cmpl	#20,(r2)
	bgtr	10$
	setbit	#2,r0
10$:	popl	r2
	rsb
	.ENDC	;DF BISYNC$$$


	.SBTTL	STOP_RECEIVE_BISYNC - Stop the BISYNC mode receiver
;++
; STOP_RECEIVE_BISYNC - Stop the BISYNC mode receiver
;
; This routine stops the current RCV in progress and resets the state of
; the receiver.
;
;	INPUTS
;		R4 = Address of protocol buffer
;		R5 = Address of the UCB  
;
;	OUTPUTS
;		R4,R5 are preserved
;		R2 =  Address of buffer to post
;
;--
STOP_RCV_BISYNC:
	MOVQ	BISYNC$Q_INIT_STATE_INFO(R4),-	; Reset state information
		UCB$Q_XG_STATE_INFO(R5)
	MOVL	UCB$L_CRB(R5),R1		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1	; Get CSR address
	DSBINT	UCB$B_DIPL(R5)			; Sync to device IPL
	BICW2	#XG$M_ENABLE,XG$C_RCV_CSR(R1)	; Disable the receiver
	ENBINT					; Lower IPL 
	CLRBIT	#XG_DS_V_RCV_DONEP,UCB$W_DEVSTS(R5) ; Clear that the rcver is busy
	SETBIT	#BISYNC$V_RCV_COMPLETE,BISYNC$W_STATUS(R4) ; Set that the rcv is comp
	MOVL	UCB$L_XG_RCV_INPR(R5),R2	; Get receive buffer address
	CLRL	UCB$L_XG_RCV_INPR(R5)		; Clear buffer address from inpr
	CLRW	UCB$W_XG_RCV_INPR_INDX(R5)	; Clear the indices
	CLRW	BISYNC$W_RCV_INDEX(R4)
	RSB


	.SBTTL	REGDUMP - Error log and diagnostics register dump
;++
; REGDUMP -Diagnostics register dump routine
;
; Functional description:
;
; This routine is used to return the DMF-32 diagnostics buffer on error 
; or diagnostic QIO function.
;
; INPUTS:
;
;	R0 = ADDRESS OF THE BUFFER
;	R5 = UCB ADDRESS OF THE UNIT
;
; OUTPUTS:
;
;	R0,R1 ARE USED
;	R5 = UCB ADDRESS OF THE UNIT
;--
REGDUMP:
	MOVZBL	#3,(R0)+		; Insert number of returned long words
	BBC	#XM$V_STS_ACTIVE,-	; BR if not active
		UCB$L_DEVDEPEND(R5),20$	

	ASSUME	UCB$W_XG_XMTCSR EQ UCB$W_XG_RCVCSR+2
	ASSUME	UCB$W_XG_RCVERR EQ UCB$W_XG_XMTCSR+2
	ASSUME	UCB$W_XG_XMTERR EQ UCB$W_XG_RCVERR+2
	ASSUME	UCB$W_XG_DSC EQ UCB$W_XG_XMTERR+2

	MOVQ	UCB$W_XG_RCVCSR(R5),(R0)+
	MOVZWL	UCB$W_XG_DSC(R5),(R0)+
	BRB	30$			; Continue
20$:	CLRQ	(R0)+			; Return no errors
	CLRL	(R0)			;
30$:	RSB


	.SBTTL  Poke user process on attention condition

;++
; POKE_USER - Poke user process on attention condition
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is used when data is avaliable or the unit is shutdown.
; The action is to declare the ast's and send a message to the assoc. mailbox.
;
; INPUTS:
;
;	R4 = Message type -- 0 if no message
;	R5 = Unit UCB address
;
; OUTPUTS:
;
;	R0 = Low bit clear only if user is not notified
;	R5 = UCB ADDRESS
;--
POKE_USER:					; POKE USER
	DSBINT	UCB$B_FIPL(R5)			; Sync to Fork
	CLRL	-(SP)				; Assume failure
	MOVAB	UCB$L_XG_AST(R5),R1		; Get AST listhead
	TSTL	(R1)				; Empty ?
	BEQL	17$				; If so, branch
	INCL	(SP)				; Indicate success
	MOVL	R1,R4				; Copy list head address
10$:	MOVL	(R1),R1				; Address a block
	BEQL	15$				; If EQL then done
	MOVL	UCB$L_DEVDEPEND(R5),^X01C(R1)	; Change param
	BRB	10$
15$:	JSB	G^COM$DELATTNAST		; Deliver AST'S
17$:	POPL	R0				; Set status
	ENBINT					; Enable interrupts
	RSB

	.SBTTL	TIMEOUT - TIMEOUT 
;++
; TIMEOUT - Timeout 
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is entered on device timeout. The action is to shut
; the unit down.
;
; INPUTS:
;
;	R5 = UCB address
;
; OUTPUTS:
;
;	NONE
;--
	.WORD	TIMEOUT-.
TIMEOUT:				; TIMEOUT OR POWERFAIL
	BBC	#XM$V_STS_ACTIVE,-	; Br BC device is not active
		 UCB$L_DEVDEPEND(R5),20$
	MOVZWL	#SS$_TIMEOUT,R4		; Assume timeout
10$:	BBC	#UCB$V_POWER,-		; Br unless powerfail
		 UCB$W_STS(R5),20$
	MOVZWL	#SS$_POWERFAIL,R4	; Indicate powerfail
	BSBW	SCHED_FORK		; Create the error fork process
20$:	RSB


	.SBTTL	STOP_BISYNC_TIMER - Stop the bisync mode timer
;++
; STOP_BISYNC_TIMER - Stop the bisync mode timer
;
; This routine is called to stop the timer from running.
;
;	INPUTS
;		R5 = UCB address
;
;	OUTPUTS
;		The BISYNC mode timer is taken off the TQE queue
;
;--
STOP_BISYNC_TIMER:
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get protocol buffer address
	PUSHR	#^M<R4,R5>	
	MOVAL	BISYNC$L_TQE(R4),R0		; Get protocol TQE address
	MOVL	TQE$L_FR4(R0),R5		; Get address of protocol buffer

; Set in FPC to ensure proper deletion of the TQE, that is not more than
; one is deleted. If just the FPC is check then all TQEs' using this code
; (any device running BISYNC) would be affected.

	MOVL	R5,TQE$L_FPC(R0)
	MOVZBL	#TQE$C_SSSNGL,R4		; SET system proc not repeatable
	JSB	G^EXE$RMVTIMQ			; Call system routine to remove TQE
	POPR	#^M<R4,R5>
	CLRBIT	#BISYNC$V_TIMER_RUNNING,BISYNC$W_STATUS(R4) ; Set timer not running
	BICB	#DPT$M_NOUNLOAD,DPT$TAB+DPT$B_FLAGS ; Set driver reloadable
	RSB

	.SBTTL	CANCEL - Cancel I/O rotuine
;++
;CANCEL - Cancels all I/O in progress
;
; By looking at the channel number saved at line startup time, cancel 
; determines which entity (line or circuit) to shut down. 
; 
;	INPUTS	R2 = channel number
;		R3 = current IRP address
;		R4 = PCB address
;		R5 = UCB address
;		R8 = Cancel reason code (zero vanilla flavored cancel)
;
;		IPL = FIPL
;
;	OUTPUTS	R0 - R3 are destroyed
;
;--
CANCEL:

; On  CANCEL or DEASSIGN of the channel check to see if the line should 
; drop DTR. If this is the last DEASSIGN then the line must drop DTR and
; we should reinitialize the settable parameters to their default values.

	CLRL	R1				; Assume DTR can be dropped
	TSTW	UCB$W_REFC(R5)			; If reference count is zero
	BEQL	10$				; this is last the DEASSIGN
	MOVZBL	UCB$B_XG_MODEM_CLR(R5),R1	; Set whether or not DTR 
						; should be dropped 
	BRB	20$				; Do not reinit param values

10$:	PUSHR	#^M<R1,R2>
	BSBW	INIT_PARAM			; Init params to known values
	POPR	#^M<R1,R2>

20$:	MOVL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol 
	CASE	R0,TYPE=B,<-
		30$,-				; Lapb
		30$,-				; Bisync
		>				; Fall thru on DDCMP
	CMPW	UCB$W_XG_CHANL(R5),R2		; If EQL then matches channel
	BEQL	SHUTDOWN_LINE_ALT		; assigned to line
	BRW	SHUTDOWN_CIRCUIT		; Else shutdown the circuit

30$:	BRB	SHUTDOWN_LINE_ALT



	.SBTTL SHUTDOWN - Shut down unit, device and/or protocol
;++
; SHUTDOWN_LINE - Shut down unit 
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is used to shut down the unit as a result of a 
; setmode shutdown on the controller or a fatal error. The mapping 
; registers are returned, a call is made to shutdown the circuit; and
; all quotas are returned.
;
; INPUTS:
;
;	R5 = UCB address
;
; For SHUTDOWN_LINE_ALT
;
;	R1 = 0 if DTR can be dropped on shut down
;	     1 if DTR can not be dropped on shut down
;
; OUTPUTS:
;
;	R5 = UCB address
;	R6 - R9 are preserved
;
;	R0-R3 are destroyed.
;--
SHUTDOWN_LINE:					; Shut down unit
	CLRL	R1
SHUTDOWN_LINE_ALT:
	BBC	#XG_DS_V_INITED,-
		UCB$W_DEVSTS(R5),5$		; BR if not inited
	BBS	#UCB$V_ONLINE,-
		UCB$W_STS(R5),10$		; Br if online
5$:	MOVZWL	#SS$_DEVINACT,R0		; Set status 
	RSB					; ... and return

10$:	PUSHR	#^M<R2,R3,R4,R6,R7,R8,R9>	; Save the registers

	BICW	#UCB$M_INT!UCB$M_POWER!-
		UCB$M_TIM,UCB$W_STS(R5)		; Reset device status
	BICW	#^C<XG_DS_M_XMTING!-		; Clear all but xmt off
		    XG_DS_M_RCVING!-		; rcv off
		    XG_DS_M_FORK_PEND!-		; and fork pending bits
		    XG_DS_M_CTSTQE_RUN!-	; CTSTQE running
		    XG_DS_M_CLEAN>,-		; Clean IRP outstanding
		UCB$W_DEVSTS(R5)

;
; Clear the modem register on the shutdown. Includes dropping DTR.
;

	BLBS	R1,15$				; If BS then don't drop DTR
	MOVL	UCB$L_CRB(R5),R4		; Get unit csr
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4
	DSBINT	UCB$B_DIPL(R5)			; Disable device interrupts
	MOVW	#XG$C_MODEM,XG$C_MISC_REG(R4)	; Get the modem indirect reg
	MOVW	#0,XG$C_IND_ADDR(R4)		; Clear modem flags
	ENBINT					; Return to FIPL
15$:	BSBW	SHUTDOWN_CIRCUIT		; Shutdown the circuit
	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	CASE	R0,TYPE=B,<-			; Case on protocol type
		18$,-				; LAPB
		16$,-				; BISYNC
		>				; Fall thru on DDCMP

;
; Stop the DDCMP timer. First set up registers with params for call
; then make the call to the protocol.
;
	PUSHL	R5
	MOVZBL	#DLK$C_STOP_TIMER,R6		; Set up R6 with the DDCMP comm
	CLRQ	R7				; CLR all registers
	CLRL	R9				; Clear R9
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Set up R5 with TF block addr
	BSBW	DDCMP				; Call protocol
	POPL	R5

; After the timer has been stopped it is ok to reload the driver.
;
	BICB	#DPT$M_NOUNLOAD,DPT$TAB+DPT$B_FLAGS
	BRB	18$

16$:	BSBW	STOP_BISYNC_TIMER		; Stop the BISYNC timer

;
; Release the map registers
;
18$:	MOVL	UCB$L_CRB(R5),R4		; Address CRB
	MOVZBL	#NUM_MAP_REG,R7			; Set number of rcv blocks
	MOVAB	UCB$Z_XG_VECTOR(R5),R6		; Address rcv block vector
20$:	MOVL	(R6)+,-				; Setup for call
		CRB$L_INTD+VEC$W_MAPREG(R4)
	BLSS	30$				; If LSS then done
	RELMPR					; Give map regs to EXEC
	MNEGL	#1,-4(R6)			; Indicate done
30$:	SOBGTR	R7,20$				; If EQL then done
;
; Deallocate the protocol buffer
;
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R0	; Get the address of the buffer
	CLRL	UCB$A_XG_PRO_BUFFER(R5)		; Clear knowledge of the buffer
	MOVZWL	UCB$W_SIZE(R0),R2		; Get the size
	PUSHR	#^M<R2,R5>
	JSB	G^COM$DRVDEALMEM		; Dealloc the buffer
	POPR	#^M<R2,R5>		

;
; Restore the buffered I/O quota and protocol buffer quota to the starter
;
	MOVZWL	UCB$L_XG_PID(R5),R0		; Get pid of last starter
	MOVL	G^SCH$GL_PCBVEC,R1		; Address PCB vector
	MOVL	(R1)[R0],R0			; Get PCB of owner
	CMPL	PCB$L_PID(R0),-
		UCB$L_XG_PID(R5)		; Still there?
	BNEQ	40$				; If NOT then BR
	MOVL	PCB$L_JIB(R0),R0		; Get JIB address
	MOVZWL	UCB$W_XG_QUOTA(R5),R1		; Convert to longword
	ADDL	R1,R2				; Get bytes quota to return
	ADDL	R2,JIB$L_BYTCNT(R0)		; Return byte count quota
	CLRW	UCB$W_XG_QUOTA(R5)		; Prevent this from being
						; returned again
40$:	MOVZWL	S^#SS$_NORMAL,R0		; Set status
	POPR	#^M<R2,R3,R4,R6,R7,R8,R9>	; Save the registers
	RSB



;++
; SHUTDOWN_CIRCUIT - Shut down device and protocol
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is used to shut down the circuit as a result of a setmode
; shutdown on the tributary or on the controller or by a fatal error on
; the device. The routines frees allocated blocks; completes IRP's with
; the active bit clear; and halts the protocol.
;
; INPUTS:
;
;	R5 = UCB address
;
; OUTPUTS:
;
;	R5 = UCB address
;	R6 - R9 are preserved
;
;	R0-R3 are destroyed.
;--
SHUTDOWN_CIRCUIT:
	BBS	#XM$V_STS_ACTIVE,-		; If BS then trib is active
		UCB$L_DEVDEPEND(R5),5$		; Else return with 
	MOVZWL	#SS$_DEVINACT,R0		; status set
	RSB

5$:	PUSHR	#^M<R2,R3,R4,R6,R7,R8,R9>	; Save the registers
	MOVL	UCB$L_CRB(R5),R4		; Get unit csr
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4
	DSBINT	UCB$B_DIPL(R5)			; Raise IPL for master clear
	BICW	#XM$M_STS_ACTIVE,-
		UCB$L_DEVDEPEND(R5)		; Set inactive
	BISW	#<XG_DS_M_XMTING!-		; Set the XMTer and
		  XG_DS_M_RCVING>,-		; RCVer off
		UCB$W_DEVSTS(R5)

	ASSUME XG$C_IDLE EQ 0

	CLRB	UCB$B_XG_XSTATE(R5)		; Reset xmter state

	TIMEWAIT #50,#XG$M_ENABLE,XG$C_XMT_CSR(R4),W,EQL ; Wait till XMT'r 
						; completes

	BISW	#XG$M_MASTER_RESET,-		; Master clear the unit
		XG$C_MISC_REG(R4)

	CLRL	UCB$L_XG_XMTEND(R5)		; Clear XMT timeout
	BBC	#XG_DS_V_INITED,-
		UCB$W_DEVSTS(R5),10$		; BR if not inited
	PUSHR	#^M<R0,R1,R2,R3,R4>		; Save registers
	MOVL	UCB$L_CRB(R5),R4		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_ADP(R4),R4	; Get addr of configuration reg
	MOVL	#NUM_MAP_REG,R0			; Set number of mapping regs
	MOVAL	UCB$Z_XG_VECTOR(R5),R2		; Get mapping slot
6$:	EXTZV	#VEC$V_MAPREG,-			; Get start of mapping regs
		#VEC$S_MAPREG,(R2),R1

	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2

	MOVZBL	2(R2),R3			; Get number of map regs
	MOVAL	UBA$L_MAP(R4)[R1],R1		; Get first register
8$:	BICL	#UBA$M_MAP_VALID,(R1)+		; Mark the register invalid
	SOBGTR	R3,8$				; Loop thru all registers
	TSTL	(R2)+				; Get next slot
	SOBGTR	R0,6$				; Loop thru all slots
	POPR	#^M<R0,R1,R2,R3,R4>		; Restore registers

;
; Clear any RCV's or XMT's pending
;
; Special case the BISYNC case, because we do not use the inpr queu as
; a queue. For Bisync, we can have only one receive outstanding at a time
; thus there is no need to use the queue and in fact the second long
; word is used for other information necessary to receive data.
;
10$:	CMPB	#XG$C_PROTYPE_BISYNC,UCB$B_XG_PROTYPE(R5) ; Bisync?
	BEQL	11$				; If eql then yes
	REMQUE	@UCB$Q_XG_RCV_INPR(R5),R6	; Anything on the inpr queues
	BVS	13$				; If VS then no
	INSQUE	(R6),@UCB$Q_XG_FREE+4(R5)	; Else queue to free queue
	BRB	10$
11$:	MOVL	UCB$L_XG_RCV_INPR(R5),R6	; Get the rcv buffer
	BEQL	12$				; No buffer
	CLRL	UCB$L_XG_RCV_INPR(R5)		; Clear the address from slot
	INSQUE	(R6),@UCB$Q_XG_FREE+4(R5)	; Insert on free queue
12$:	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Get protocol buffer address
	MOVL	BISYNC$A_RCV_BUFFER(R4),R6	; Get addr of buff given to dev
	BEQL	13$				; No buffer
	INSQUE	(R6),@UCB$Q_XG_FREE+4(R5)	; Insert on free queue
13$:	CLRL	R3				; Get prim buffer to compl
	MOVL	UCB$Z_XG_XMT_INPR(R5)[R3],R1	; Comp XMT's on inprogress Q
	BEQL	14$				; If EQL none to complete
	CLRL	UCB$Z_XG_XMT_INPR(R5)[R3]
	DECB	UCB$B_XG_XMTCNT(R5)		; Decr # of outstanding XMT's
	BBS	#XMTQ$V_CONTROL,-		; If BS then control message
		XMTQ$B_FLAG(R1),14$		; don't put on post queue
	INSQUE	(R1),@UCB$Q_XG_POST+4(R5)	; Insert to be completed
14$:	ENBINT					; Return to fork level

;
; Deallocate all the attention AST control blocks
;
15$:	MOVAB	UCB$L_XG_AST(R5),R7		; Address list head for AST's
	MOVL	(R7),R0				; Anything in the list?
	BEQL	20$				; If EQL then empty
	MOVZWL	ACB$L_KAST+10(R0),R6		; Force channel
	MOVZWL	ACB$L_KAST+12(R0),R2		; Get PID index
	MOVL	G^SCH$GL_PCBVEC,R4
	MOVL	(R4)[R2],R4			; Get PCB
	JSB	G^COM$FLUSHATTNS		; Flush the attention AST's
	BRB	15$				; Continue until done
;
; Clear the post queue
;

20$:	REMQUE	@UCB$Q_XG_POST(R5),R6		; Get next buffer to complete 
	BVS	30$				; If VS then no buffer found
	CMPB	IRP$B_TYPE(R6),S^#DYN$C_BUFIO	; If NEQ then not XMT buffer
	BNEQ	25$
	MOVL	XMTQ$L_IRP(R6),R3		; If EQL then no IRP to comp
	BEQL	20$
	MOVL	R6,R1				; Set up R1 for branch
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set abort status and compl
	BSBW	TRANSMIT_IO_DONE		; the request
	BRB	20$
25$:	CMPB	IRP$B_TYPE(R6),S^#DYN$C_NET	; If EQL then RCV buffer
	BNEQ	55$
	INSQUE	(R6),@UCB$Q_XG_FREE+4(R5)	; Put on free Q to complete
	BRB	20$
;
; Deallocate all receive buffers
;
30$:	MOVAB	UCB$Q_XG_FREE(R5),R6		; Get queue listhead
	BSBB	40$				; Empty queue
	MOVAB	UCB$Q_XG_ATTN(R5),R6		; Get queue listhead
	BSBB	40$				; Empty queue
	CLRB	UCB$B_XG_INUS(R5)		; Free all slots
	BRB	60$				; Continue
40$:	REMQUE	@(R6),R0			; Get buffer
	BVS	50$				; If VS then none
	ADDW	UCB$W_DEVBUFSIZ(R5),-		; Restore quota
		UCB$W_XG_QUOTA(R5)
	JSB	G^COM$DRVDEALMEM		; Deallocate buffer
	BRB	40$				; Loop
50$:	RSB

55$:	BUG_CHECK NOBUFPCKT,FATAL

;
; Complete all associated receive IO packets
;
60$:	REMQUE	@UCB$Q_XG_RCVS(R5),R3		; If VS then queue is empty
	BVS	70$
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set status and size
	BSBW	IO_DONE				; Complete the request
	BRB	60$				; Branch to get next IRP
;
; Complete all XMITS
;
70$:	DSBINT	UCB$B_DIPL(R5)			; Lock out interrupts

	BICW	#UCB$M_TIM!UCB$M_INT,-		;   "	"	"
		UCB$W_STS(R5)
	ENBINT					; Reset interrupts
	BBCC	#XG_DS_V_CLEAN,UCB$W_DEVSTS(R5),73$ ; IF BS then do clean handling
	CLRL	R3				; Set no buffer to post
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R4	; Set protocol buffer address
	BSBW	CLEAN_FORK_ENTRY
73$:	PUSHR	#^M<R3,R5>			; Save registers
	MOVZBL	UCB$B_XG_PROTYPE(R5),R0		; Get protocol type
	MOVL	UCB$A_XG_PRO_BUFFER(R5),R5	; Set protocol buffer address
	CASE	R0,TYPE=B,<-			; Case on protocol type
		75$,-				; LAPB
		75$,-				; BISYNC
		>				; Fall thru on DDCMP
	MOVZBL	#DLK$C_USRINT,R6		; Set up to halt the protocol
	MOVZBL	#DLK$M_STOP,R7
	CLRQ	R8
	BSBW	DDCMP
	MOVAB	TF$Q_CMPQ(R5),R6		; Get queue to complete from
	POPR	#^M<R3,R5>			; Restore the registers
	BRB	80$
75$:	MOVAB	LAPB$Q_XMTQ(R5),R6		; Get start of device queue
	POPR	#^M<R3,R5>			; Restore the registers
	BRB	80$
78$:	MOVAB	BISYNC$Q_XMTQ(R5),R6		; Get start of device queue
	POPR	#^M<R3,R5>			; Restore the registers
80$:	REMQUE	@(R6),R1			; Complete all XMT's 
	BVS	90$				; If VS then no more to cmplt
	CMPB	XMTQ$B_BUFTYP(R1),S^#DYN$C_BUFIO ; Branch NEQ not a valid buff
	BNEQ	100$
	MOVL	XMTQ$L_IRP(R1),R3		; Get associated IRP
	MOVZWL	#SS$_ABORT,IRP$L_MEDIA(R3)	; Set aborted status
	BSBW	TRANSMIT_IO_DONE		; Complete the I/O
	BRB	80$				; Branch to get next
90$:	MOVZWL	S^#SS$_NORMAL,R0		; Assume shutdown
	POPR	#^M<R2,R3,R4,R6,R7,R8,R9>	; Save the registers
	RSB

100$:	BUG_CHECK	NOBUFPCKT,FATAL


	.SBTTL	VALIDATE_P2,  Validate P2 buffer parameters
	.SBTTL	VALIDATE_P2_TRIB,  Validate P2 buffer with Trib param
	.SBTTL	VALIDATE_P2_UCB,  Validate P2 buffer with UCB
 
;++
; VALIDATE_P2 - Validate P2 buffer parameters
; VALIDATE_P2_TRIB - Validate P2 buffer with trib parameters
; VALIDATE_P2_UCB - Validate P2 buffer with UCB
;
; This routine is called to validate the P2 buffer parameters. The parameters
; are checked against a parameter table which verifies that the minimum value
; and maximum value is not violated, and that invalid status flags are not set.
;
; Inputs:
;
;	R1 = Address of parameter verification table (VALIDATE_P2 entry only)
;	R2 = Status word from UCB
;	R3 = IRP address
;	R4 = UCB or trib parameter block address for value 
;	     checking (VALIDATE_P2 entry only)
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status return of parameters
;
; If no error:
;	R1 = Address of parameter verification table
; If error:
;	R1 = Bad parameter value
;
;	All other registers are preserved.
;
;--
	.ENABL	LSB
VALIDATE_P2_TRIB:				; Validate P2 buffer with TFB
	PUSHL	R4				; Save R4
	MOVAB	TRIB_PARAM,R1			; Get address of verification table
	MOVAB	UCB$Z_XG_DDCMP(R5),R4		; Get address of block to set
						; DDCMP parameters
	BRB	10$				;
VALIDATE_P2_UCB:				; Validate P2 buffer with UCB
	PUSHL	R4				; Save R4
	MOVAB	LINE_PARAM,R1			; Get address of verification table
	MOVL	R5,R4				; Copy UCB address
10$:	BSBB	VALIDATE_P2			; Do the validation
	POPL	R4				; Restore R4
	RSB					; Return to caller
	.DSABL	LSB
 
VALIDATE_P2:					; Validate P2 buffer parameters
	PUSHR	#^M<R1,R2,R3,R5,R6,R7,R8,R9>	; Save registers
						; NB:R1 must be on top of stack
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BNEQ	10$				; Br if a system buffer
	BRW	150$				; Else, leave
10$:	MOVZWL	IRP$W_BCNT(R3),R8		; Get size of P2 buffer
	DIVL	#6,R8				; Calculate number of parameters
	MOVL	P2B_L_POINTER(R6),R6		; Point to start of P2 data
;
; Loop to check next parameter in P2 buffer
;
30$:	MOVZWL	(R6)+,R0			; Get parameter type from P2
	MOVL	(R6)+,R5			; Get parameter value from P2
	MOVL	(SP),R7				; Get parameter table address
;
; Loop to check P2 buffer parameter to Line parameter table
;
40$:	MOVW	(R7)+,R9			; Get parameter + flags
	BEQL	170$				; Br if end of verify table
	CMPZV	#PRM_V_TYPE,#PRM_S_TYPE,R9,R0	; Parameters match?
	BEQL	50$				; Br if yes
	TSTW	(R7)+				; Skip offset word
	SKIP	PRM_V_MIN,R9,R7			; Skip minimum value
	SKIP	PRM_V_MAX,R9,R7			; Skip maximum value
	SKIP	PRM_V_INVALID,R9,R7		; Skip invalid flags
	BRB	40$				; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
50$:	MOVW	(R7)+,R1			; Get offset + width
	TSTL	R4				; Is data structure present?
	BEQL	100$				; Br if not - check values
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R1,R3	; Get width only
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R1,R1	; Get offset only
	ADDL	R4,R1				; Calculate address of datum
	CASE	R3,TYPE=B,LIMIT=#1,<-		; Br to handler
		60$,-				;   Byte value
		70$,-				;   Word value
		80$>				;   Longword value
;
; Byte value in structure
;
60$:	CMPB	R5,(R1)				; Is this the same?
	BRB	90$				; Check result
;
; Word value
;
70$:	CMPW	R5,(R1)				; Is this the same?
	BRB	90$				; Check result
 
80$:	CMPL	R5,(R1)				; Is this the same?
90$:	BNEQ	100$				; Br if no - continue checks
	CLRW	-6(R6)				; Nullify the parameter code
	BRB	140$				; Try next parameter - skip checks

100$:	BBC	#PRM_V_MIN,R9,110$		; Br if no minimum value
	CMPW	R5,(R7)+			; Is the value too small?
	BLSSU	170$				; Br if yes - error
110$:	BBC	#PRM_V_MAX,R9,130$		; Br if no maximum value
	CMPW	R5,(R7)+			; Is the value too big?
	BGTRU	170$				; Br if yes - error
130$:	BBC	#PRM_V_INVALID,R9,140$		; Br if no invalid flags
	BITW	(R7)+,R2			; Check invalid bits
	BNEQ	170$				; Br if on - error
140$:	SOBGTR	R8,30$				; Loop if more parameters
 
150$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success return
	BRB	180$				; And return
 
170$:	MOVZWL	R0,(SP)				; Return bad parameter code
						; * R1 Must be on top of stack
	MOVZWL	#SS$_BADPARAM,R0		; Set error return
180$:	POPR	#^M<R1,R2,R3,R5,R6,R7,R8,R9>	; Restore registers
	RSB					; Return to caller

	.SBTTL	UPDATE_P2,  Update UCB/TRIB based on P2 buffer parameters
 
;++
; UPDATE_P2 - Update UCB/TRIB with P2 buffer parameters
;
; This routine is called to update the UCB/TRIB with the P2 buffer parameters.
; The parameters are stored in the appropriate cells of the UCB/TRIB.
;
; Inputs:
;
;	R1 = Address of parameter verification table
;	R3 = IRP address
;	R4 = UCB or ddcmp parameter block  address for storing
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
 
UPDATE_P2:					; Update the UCB/DDCMP parametr
	PUSHR	#^M<R1,R2,R5,R6,R7,R8,R9>	; Save registers
						; NB:R1 must be on top of stack
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BEQL	80$				; Br if no system buffer
	MOVZWL	IRP$W_BCNT(R3),R8		; Get size of P2 buffer
	DIVL	#6,R8				; Calculate number of parameters
	MOVL	P2B_L_POINTER(R6),R6		; Point to start of data
;
; Loop to get next parameter from P2 buffer
;
10$:	MOVZWL	(R6)+,R0			; Get parameter type from P2
	MOVL	(R6)+,R5			; Get parameter value from P2
	MOVL	(SP),R7				; Get parameter table address
;
; Loop to store buffer parameter in UCB/DDCMP parameter block
;
20$:	MOVW	(R7)+,R9			; Get parameter + flags
	BEQL	70$				; Br if end of verify table
	EXTZV	#PRM_V_TYPE,#PRM_S_TYPE,R9,R1	; Get type field
	CMPW	R0,R1				; Parameters match?
	BEQL	30$				; Br if yes
	TSTW	(R7)+				; Skip offset word
	SKIP	PRM_V_MIN,R9,R7			; Skip minimum value
	SKIP	PRM_V_MAX,R9,R7			; Skip maximum value
	SKIP	PRM_V_INVALID,R9,R7		; Skip invalid flags
	BRB	20$				; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
30$:	MOVW	(R7)+,R1			; Get offset + width
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R1,R2	; Get width only
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R1,R1	; Get offset only
	ADDL	R4,R1				; Calculate address of datum
	CASE	R2,TYPE=B,LIMIT=#1,<-		; Br to handler
		40$,-				;   Byte value
		50$,-				;   Word value
		60$>				;   Longword value
;
; Byte, word, longword value in structure
;
40$:	MOVB	R5,(R1)				; Store byte value
	BRB	70$				; 
50$:	MOVW	R5,(R1)				; Store word value
	BRB	70$				;
60$:	MOVL	R5,(R1)				; Store longword value
70$:	SOBGTR	R8,10$				; Br if more parameters
 
80$:	POPR	#^M<R1,R2,R5,R6,R7,R8,R9>	; Restore registers
	RSB					; Return to caller

	.SBTTL	RETURN_P2,  Return UCB/DDCMP buffer parameters
 
;++
; RETURN_P2 - Return P2 buffer parameters
;
; This routine is called to return the UCB/DDCMP buffer parameters.
;
; Inputs:
;
;	R1 = Address of return table (same format as verification table)
;	R2 = Address of user buffer in which to return the parameters
;	R3 = IRP address
;	R4 = UCB or DDCMP paramter block address for storing
;	R5 = UCB address
;	IRP$W_BCNT(R3) = Size of transfer
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
 
RETURN_P2:					; Return P2 buffer parameters
	PUSHR	#^M<R1,R2,R5,R6,R7,R8>		; Save registers
	MOVL	R2,R6				; Get user buffer address
	BEQL	60$				; Br if no system buffer
	MOVZWL	IRP$W_BCNT(R3),R8		; Get size of buffer
	DIVL	#6,R8				; Calculate the number of param
;
; Loop to return next parameter
;
10$:	MOVW	(R1)+,R5			; Get parameter + flags
	BEQL	60$				; Br if end of verify table
	EXTZV	#PRM_V_TYPE,#PRM_S_TYPE,R5,R7	; Get type field
	MOVW	R7,(R6)+			; Return parameter
	MOVW	(R1)+,R7			; Get offset + width
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R7,R2	; Get width only
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R7,R7	; Get offset only
	ADDL	R4,R7				; Calculate address of datum
	CASE	R2,TYPE=B,LIMIT=#1,<-		; Br to handler
		20$,-				;   Byte value
		30$,-				;   Word value
		40$>				;   Longword value
;
; Byte, word, longword value in structure
;
20$:	MOVZBL	(R7),(R6)+			; Store byte value
	BRB	50$				; 
30$:	MOVZWL	(R7),(R6)+			; Store word value
	BRB	50$				;
40$:	MOVL	(R7),(R6)+			; Store longword value
50$:	SKIP	PRM_V_MIN,R5,R1			; Skip minimum value
	SKIP	PRM_V_MAX,R5,R1			; Skip maximum value
	SKIP	PRM_V_INVALID,R5,R1		; Skip invalid flags
	SOBGTR	R8,10$				; Try for more parameters
 
60$:	POPR	#^M<R1,R2,R5,R6,R7,R8>		; Restore registers
	RSB					; Return to caller

	.SBTTL	UNPACK_P2_BUF,  Unpack a P2 parameter from P2 buffer
 
;++
; UNPACK_P2_BUF - Unpack a P2 parameter from P2 buffer
;
; Functional description:
;
; This routine is called to get a P2 parameter from the P2 buffer.
;
; Inputs:
;
;	R1 = Parameter type code
;	R3 = IRP address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Low bit set if specified Parameter type code is found in P2
;	R2 = Parameter value if success else destroyed
;
;	All other registers are preserved.
;
;--
 
UNPACK_P2_BUF:					; Unpack P2 buffer
	PUSHR	#^M<R5,R6,R7>			; Save registers
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BEQL	20$				; Br if none
	MOVZWL	IRP$W_BCNT(R3),R7		; Get size of P2 buffer
	DIVL	#6,R7				; Caculate number of parameters
	MOVAB	P2B_T_DATA(R6),R6		; Point to start of data
	MOVZWL	S^#SS$_NORMAL,R0		; Assume success
;
; Loop to check next parameter in P2 buffer
;
10$:	MOVZWL	(R6)+,R5			; Get parameter type from P2
	MOVL	(R6)+,R2			; Get parameter value from P2
	CMPW	R1,R5				; Parameters match?
	BEQL	30$				; Br if yes
	SOBGTR	R7,10$				; Br if more parameters
 
20$:	CLRL	R0				; Return error
30$:	POPR	#^M<R5,R6,R7>			; Restore registers
	RSB					; Return to caller

XG_END:
	.END

