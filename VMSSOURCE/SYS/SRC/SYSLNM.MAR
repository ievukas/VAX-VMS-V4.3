	.TITLE	SYSLNM - SYSTEM SERVICES TO MANIPULATE LOGICAL NAMES AND TABLES.
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; TODD M. KATZ	01-APR-83
;
; SYSTEM SERVICES TO MANIPULATE LOGICAL NAMES
;
;	CREATE LOGICAL NAME TABLES
;	CREATE LOGICAL NAME
;	DELETE LOGICAL NAME
;	TRANSLATE LOGICAL NAME
;
; MODIFICATION HISTORY:
;
;	V03-027	RAS0327		Ron Schaefer		24-Jul-1984
;		Back out RAS0322 and make the LNM$_LENGTH itemcode
;		be a longword value.
;
;	V03-026	RAS0322		Ron Schaefer		10-Jul-1984
;		Fix $TRNLNM item LNM$_LENGTH to only write a word field.
;
;	V03-025	RAS0312		Ron Schaefer		21-Jun-1984
;		Fix ORB alignment within logical name table.
;
;	V03-024	TMK0014		Todd M. Katz		21-Apr-1984
;		The interface to the internal logical name routine 
;		LNM$DELETE_LNMB has been changed. Update $DELLNM, which calls
;		this routine, to reflect this new interface.
;
;		The performance measurement cell used to monitor the rate of 
;		logical name translations is currently located within the 
;		internal logical name routine LNM$SEARCHLOG. Unfortunately,
;		because of its current placement, any attempts to delete 
;		specific logical names will also increment this counter. This
;		is because the system service $DELLNM will call the routine 
;		LNM$SEARCHLOG in such a situation. Therefore, in order to be
;		able to make a more accurate measurement of the overall rate
;		of logical name translations, I have decided to move this 
;		performance measurement cell from its current single location
;		to several more appropriate locations. One of these new 
;		locations is within the system service $TRNLNM, just before the 
;		call to LNM$SEARCHLOG.
;
;	V03-023	TMK0013		Todd M. Katz		29-Mar-1984
;		Modify the logical name system services to make use of the 
;		updated internal protection checking mechanisms. What this
;		requires is a modification to SYS$CRELNT so that all shareable 
;		logical name tables are created with a quad-word aligned Object 
;		Rights Block in place of a un-aligned CHIP protection template.
;
;		Restrict all names which appear with a directory table to 31
;		characters consisting of the DEC multi-national alphanumeric
;		character set plus $ and _. This restriction applies to both
;		logical names and logical name table names. The reason for this
;		restriction is that in the future we might want to support
;		hierarchial name spaces. If we decide to do so we would have to
;		invent and then impose a structure on logical name table names. 
;		This restriction gives us sufficient leeway (and more 
;		importantly sufficient available characters) to be able to 
;		define a hierarchial name space structure in the future.
;
;	V03-022	TMK0012		Todd M. Katz		07-Mar-1984
;		The fixed portion of each and every translation block has been
;		increased by a word, LNMX$W_HASH, in order to potentially hold 
;		the translation's hash code value. Furthermore, SYS$CRELNT and 
;		SYS$CRELNM have been modified so that this field within each
;		and every translation block is initialized to 0. This hash code 
;		field will be used in an optimization of logical name table name
;		processing. As such, only certain logical names, those that are
;		contained within the process or system directory and may be used
;		in logical name table processing, need to have the hash code
;		fields of each of their translations initialized to their
;		equivalence string's hash code value. This initialization
;		actually takes place within the routine LNM$INSLOGTAB in the
;		module LNMSUB.
;
;	V03-021	TMK0011		Todd M. Katz		13-Feb-1984
;		Add SS$_NOLOGTAB to the list of errors than can be returned
;		by SYS$CRELNT, SYS$CRELNM, and SYS$DELLNM.
;
;		Fix a bug in $TRNLNM. At the present time the very first
;		longword in the item list is not being probed. Obviously this
;		could result in a disasterous kernel mode ACCVIO.
;
;		Fix up $TRNLNM's processing of the PARENT item. The most
;		important change I have made here, besides a general fixup
;		of the code, is to return 0 bytes in the parent item if the LNMB
;		being looked at is not for a logical name table. This is because
;		logical names, with the exception of logical name tables, do not
;		have parents. 
;
;		Optimize the processing of $TRNLNM's item list. This is done
;		by having two separate code segments - one to probe and return
;		variable length character string items (TABLE, STRING, PARENT),
;		and the other to probe and return longword length items (LENGTH,
;		ATTRIBUTES, MAX_INDEX). In addition, since ACMODEs are only a
;		byte, ACMODE items are now being probed and filled in in-line.
;		Also, optimize a few instructions within this system service.
;
;	V03-020	TMK0010		Todd M. Katz		29-Dec-1983
;		Re-write SYS$DELLNM for the case when the name of the logical
;		name table entry to be deleted has been specified. What was
;		being done was incorrect. It allowed the possibility of deleting
;		several logical names from different tables. The correct way
;		to implement this is as follows:
;
;		1. Search for the first instance of a logical name table entry
;		   in one of the specified logical name tables which possesses
;		   the specified access mode.
;
;		2. Check to make sure that the caller has write access to the 
;		   containing logical name table.
;
;		3. Delete the logical name table entry and all outermode
;		   aliases within the same logical name table.
;
;		The process and system directory logical name tables are now
;		being created with the LNMB$V_NODELETE bit set within their
;		LNMB$B_FLAGS fields to indicate that these tables should
;		never be deleted. Therefore, it is no longer necessary for
;		SYS$CRELNT to set this bit within the appropriate directory 
;		table to protect it from being deleted during the insertion of
;		the table entry for the new logical name table, and conversely 
;		SYS$CRELNT must never clear this bit within a directory table
;		after the attempt at insertion has been made.
;
;		Fix a bug in the creation of logical names without translations
;		by SYS$CRELNM. This used to work, but has broken mysteriously.
;		The problem is that during the first processing of the item
;		list, the number of translations specified by the list and
;		the cumulated size of their translation strings is saved on the
;		stack for use in computing the amount of storage required to be
;		allocated for the new logical name block. These stack associated
;		counters were not being appropriately initialized to zero in the
;		case when no item list (and thus no translations) was present.
;		This resulted in the size of the table name and the address of
;		the table name buffer being popped off the stack and used as 
;		the values of these counters. As might be expected this would
;		cause the system service to fail in a variety of interesting 
;		ways. Often, since the saved logical name table name descriptor 
;		had been removed from the stack but the pointer to the saved 
;		descriptor in R9 had not changed, this would lead to a failure
;		to find a logical name table and termination of the system
;		service. Also, since the values used in computing the amount
;		of storage required for the new logical name were random, the 
;		value computed could be so large as to cause the storage 
;		allocation attempt to fail.
;
;	V03-019	TMK0009		Todd M. Katz		18-Dec-1983
;		Remove all mention of LNM$V_SYSTEM and LNM$V_GROUP from 
;		SYS$CRELNT. The system table and all group tables will be
;		handcrafted, and there will not be a way to create such a
;		table by means of the system service interface.
;
;		Also, change some PUSHRs into PUSHLs (or MOVQs) and POPRs into
;		POPLs (or MOVQs) where appropriate for performance reasons.
;
;	V03-018	TMK0008		Todd M. Katz		26-Oct-1983
;		Quota checking when logical name tables are being created 
;		is presently incorrect. Currently, when a logical name 
;		table is created only one type of quota check is made. That
;		check makes sure that the quota holder of the parent logical
;		name table has sufficient quota for both the logical name table
;		itself and any quota which will be specifically allocated to it.
;		Actually, two quota checks should be made. The quota holder of
;		the parent logical name table should have sufficient quota for 
;		the quota that will be specifically allocated to the new table;
;		but in addition, the containing table (the system or process 
;		directory table) must have sufficient quota for the logical 
;		name table itself. This is consistant with how quota deductions
;		are made for logical names, and it is consistant with the 
;		philosophy that logical name tables are just logical names with 
;		a special type of translation.
;
;	V03-017	TMK0007		Todd M. Katz		26-Sep-1983
;		Change the default protection that is assigned to new shareable 
;		logical name tables to SYSTEM:RWED OWNER:RWED GROUP: WORLD: 
;		so that by default, the system can access and modify any
;		shareable logical name table.
;
;	V03-016	TMK0006		Todd M. Katz		16-Sep-1983
;		Fix a branch in EXE$CRELNT. If no attributes were specified,
;		this service should branch to check out the table name 
;		parameter; however, it is branching into the wrong place. This
;		results in an inability to create a logical name table if
;		attributes are not specified. This fixes the problem.
;
;	V03-015	TMK0005		Todd M. Katz		08-Aug-1983
;		Make several modifications to each of the logical name system
;		services.
;
;		Changes to EXE$CRELNT:
;
;		1. Change access mode processing. The new logical name table 
;		   may not be created in an access mode inner to that of the 
;		   caller unless the user has SYSNAM privilege and has 
;		   specified an access mode as an optional system service 
;		   arguement. A new logical name table may still be created 
;		   with an access mode outer to the mode of the caller, even if
;		   the caller does not have SYSNAM privilege, if the caller
;		   explicitely specifies an access mode as an optional system 
;		   service parameter.
;
;		2. A new logical name table maybe marked within the table 
;		   header as either the system table or a group table (but not 
;		   both) by setting one of the new attribute bits (reserved to 
;		   DIGITAL) LNM$V_SYSTEM or LNM$V_GROUP respectively. The 
;		   caller must be in executive or kernel mode to do so.
;
;		3. It is necessary to have quota access to the parent logical
;		   name table in order to be able create a subtable. In 
;		   addition if the table being creating is shareable, and the 
;		   caller is specifying a name, then the caller must have write
;		   access to the system directory table. Previously, read and 
;		   write access to the parent logical name table was what was 
;		   being checked. This is not only insufficient but wrong. I 
;		   have also moved these access checks so that they are 
;		   performed immediately after the parent logical name table is
;		   located.
;
;		4. SYSNAM was formerly required to specify the name of a 
;		   shareable logical name table and not let the system default
;		   name it (ie - insert the name into the system directory
;		   table). The meaning of SYSNAM has been restricted to refer 
;		   only to the access of the system logical name table, 
;		   LNM$SYSTEM_TABLE, and to the creation and deletion of inner 
;		   access mode logical names and tables. 
;
;		5. If no protection mask was specified, then default the 
;		   protection to O:RWED.
;
;		6. It is never necessary to do any protection checking when
;		   process-private logical name tables are involved. Therefore,
;		   do not allocate or fill in the CHIP protection structure
;		   template when creating a process-private logical name table,
;		   and do not perform any protection checking during the 
;		   creation of such tables.
;
;		Changes to EXE$CRELNM:
;
;		1. Change access mode processing. The new logical name may not 
;		   be created in an access mode inner to that of the caller 
;		   unless the user has SYSNAM privilege and has specified an 
;		   access mode as an optional system service arguement. A new 
;		   logical name may still be created with an access mode outer 
;		   to the mode of the caller, even if the caller does not have 
;		   SYSNAM privilege, if the caller explicitely specifies an 
;		   access mode as an optional system service parameter.
;
;		2. It is only necessary to have write access to the logical 
;		   name table in order to be able to insert a logical name 
;		   within it. Previously, both read and write access was 
;		   required.
;
;		3. In order to be able to insert a logical name into the system
;		   directory table a caller must be able to write access the 
;		   table itself. Previously, the caller could perform such an 
;		   insertion if they had SYSNAM privilege. The meaning of 
;		   SYSNAM has been restricted to refer only to the access of 
;		   the system logical name table, LNM$SYSTEM_TABLE, and to the 
;		   creation and deletion of inner access mode logical names and 
;		   tables.
;
;		4. It is never necessary to do any protection checking when
;		   process-private logical name tables are involved. Therefore,
;		   do not perform any protection checking prior to the insertion
;		   of new logical names into such tables.
;
;		Changes to EXE$DELLNM:
;
;		1. Change access mode processing. Logical names or logical
;		   name tables in access modes inner to that of the caller
;		   may not be deleted unless the user has SYSNAM privilege and 
;		   has specified an access mode as an optional system service 
;		   arguement. Logical names or logical name tables in access
;		   modes outer to the mode of the caller may still be deleted
;		   if the caller explicitely specifies an access mode as an 
;		   optional system service parameter, even if the caller does 
;		   not have SYSNAM privilege.
;
;		2. When a single logical name table entry was to be deleted
;		   this system service was requiring delete access to the
;		   containing logical name table before allowing the deletion
;		   to proceed. When all logical name table entries within a
;		   logical name table were to be deleted, no access checking
;		   was being done. This is incorrect. The access requirements
;		   for the deletion of logical name tables and logical names
;		   are as follows:
;
;		   a. To delete a logical name, write access to the containing 
;		      logical name table is required.
;		   b. To delete a logical name table, either delete access to
;		      the table itself or write access to its containing 
;		      logical name table (the system directory table) is 
;		      required.
;
;		3. It is never necessary to do any protection checking when
;		   process-private logical name tables are involved. Therefore,
;		   do not perform any protection checking prior to the deletion
;		   of any process-private logical name table entry.
;
;		Changes to EXE$TRNLNM:
;
;		1. This system service would accept an invalid access mode as
;		   an optional system service parameter without returning an
;		   error. Add access mode error checking.
;
;		2. It is never necessary to do any protection checking when
;		   process-private logical name tables are involved. Therefore,
;		   do not perform any protection checking if the target logical 
;		   name table entry is process-private.
;
;	V03-014	RAS0166		Ron Schaefer		 5-Jul-1983
;		Reverse polarity of branch in positioning to a translation
;		index within a $TRNLNM itmlst.  Also optimize #-1s.
;
;	V03-013	WMC0001		Wayne Cardoza		23-Jun-1983
;		Add chained item lists, parent item code.
;
;	V03-012	RAS0160		Ron Schaefer		16-Jun-1983
;		Change all arguments to be by-reference. This affects
;		    ACMODE	all services
;		    ATTR	$CRELNM, $CRELNT and $TRNLNM
;		    PROMSK	$CRELNT
;		    QUOTA	$CRELNT
;
;	V03-011	DMW4046		DMWalp			 9-Jun-1983
;		Post intergration of new logical name structures
;		    1.)  MAX_INDEX in TRNLNM returns the maximum index
;			 if non-negative, else -1
;		    2.)  Clean up the setting default index value of
;			 zero in TRNLNM
;		    3.)  Replace ^XFFFF with LNM$_LNMB_ADDR as item value
;
;	V03-010 DMW4038		DMWalp			25-May-1983
;		Fix check for LNM$_LNMB_ADDR item
;
;	V03-009	RAS0158		Ron Schaefer		25-May-1983
;		Add protection structure and checking to logical
;		name tables.   Currenly, only SOGW protection is implemented.
;		Correct item list buffer probing in $TRNLNM to make
;		it tolerate longer than necessary buffers.
;
;	V03-008	DMW4029		DMWalp			25-May-1983
;		Added code to CRELNM to allow MTL and mailbox UCB to be
;		intergrated with the new logical name structures. This 
;		includes the addition of LNM$_LNMB_ADDR and work to allow
;		LNM$C_BACKPTR to be accpeted thru system service interface.
;
;	V03-007	TMK0004		Todd M. Katz		30-Apr-1983
;		When VMS must default name a new logical name table, it is
;		given a name of the form LNM$xxxxxxxx instead of a name of 
;		the form LNT$xxxxxxxx.
;
;	V03-006	TMK0003		Todd M. Katz		25-Apr-1983
;		Make multiple to changes to the routines within this module:
;
;		EXE$CRELNT: 
;
;		1. Un-comment the SETIPL that was commented out for debugging 
;		   purposes.
;
;		2. Change several instructions to conform to VMS coding 
;		   requirements.
;
;		3. If a process-private logical name table is to be created, 
;		   the size of the logical name block is saved on the stack, 
;		   the system pool logical name block is deallocated, the size 
;		   is retrieved, and process-private P1 space is allocated. I 
;		   was saving this size as a word on the stack, and this was 
;		   creating problems allocating P1 space, after the size was
;		   popped off the stack because I neglected to zero out the
;		   high order word. To fix this problem, size is now saved as
;		   a longword on the stack.
;
;		4. R2 is now saved before calling LNM$LOCKW (which destroys it)
;		   instead of after.
;
;		5. Instead of picking up the QUOTA arguement twice from the 
;		   user's parameter list, it is picked up and saved the first
;		   time it is needed.
;
;		6. Pickup ACMODE as a byte instead of a longword.
;
;		7. Change the name of TABNAM to RESNAM, TABLEN to RESLEN, and
;		   LOGNAM to TABNAM.
;
;		8. If the new table is mapped to an existing table, then save
;		   the address of the existing LNMB on the stack before
;		   deleting the new LNMB so that the table's name maybe
;		   returned if required.
;
;		EXE$CRELNM: 
;
;		1. Fix an incorrect probing of the TABNAM parameter.
;
;		2. Un-comment the SETIPL that was commented out for debugging 
;		   purposes.
;
;		3. Do not perform any validation of the item list (except for 
;		   the STRING item) during the first pass.
;
;		4. Return SS$_NOGRPNAM instead of SS$_NOPRIV is the user does
;		   not have sufficient privilege to create a shareable logical
;		   name.
;
;		5. If a process-private logical name is to be created, the size
;		   of the logical name block is saved on the stack, the system
;		   pool logical name block is deallocated, the size is 
;		   retrieved, and process-private P1 space is allocated. I was
;		   saving this size as a word on the stack, and this was 
;		   creating problems allocating P1 space, after the size was
;		   popped off the stack because I neglected to zero out the
;		   high order word. To fix this problem, size is now saved as
;		   a longword on the stack.
;
;		6. Pickup the address of all item buffers before probing. After
;		   probing refer only to system service copies of these 
;		   addresses, and not to user copies.
;
;		7. As each translation block is created, check to make sure that
;		   creation of this block would not result in the exceeding of
;		   the space allocated for the logical name block.
;
;		8. Change several instructions to conform to VMS coding 
;		   requirements.
;
;		9. Pickup ACMODE as a byte instead of a longword.
;
;		EXE$DELLNM:
;
;		1. Un-comment the SETIPL that was commented out for debugging 
;		   purposes.
;
;		2. When the deletion of a specific logical name in an access 
;		   mode other than user has been requested, all outer access 
;		   mode logical names with the same name and in the same table
;		   are also deleted.
;
;		3. Pickup ACMODE as a byte instead of a longword.
;
;		EXE$TRNLNM: 
;
;		1. Fix an incorrect probing of the TABNAM parameter.
;
;		2. Un-comment the SETIPL that was commented out for debugging 
;		   purposes.
;
;		3. Pickup the address of all item buffers before probing. After
;		   probing refer only to system service copies of these 
;		   addresses, and not to user copies.
;
;		4. Change how the index of INDEX items are validated.
;
;		5. Change several instructions to conform to VMS coding 
;		   requirements.
;
;		6. Return the attribute bit LNM$V_SHAREABLE in the ATTRIBUTES
;		   item whenever the name being translated is shareable.
;
;		7. Pickup ACMODE as a byte instead of a longword.
;
;		8. Change how the ACMODE arguement is interrupted. If the
;		   arguement is 0, maximize with the mode of the caller;
;		   otherwise, the specified mode is used to qualify the
;		   search.
;
;		9. Change the attribute bit LNM$V_NOT_EXIST to LNM$V_EXISTS.
;		   This bit will be set in the ATTRIBUTES item buffers of those
;		   indexes that do exist, and clear in the ATTRIBUTES item 
;		   buffers of those indexes that do not exist.
;
;	V03-005	BLS0219		Benn Schreiber		19-Apr-1983
;		Make some BSBW's into JSB's with longword displacements.
;
;	V03-004	TMK0002		Todd M. Katz		18-Apr-1983
;		Fix a broken ASSUME statement. This ASSUME broke when I changed
;		the structure of a table header by removing the field 
;		LNMTH$L_LOGNAM. Also, no longer fill in this "non-existant"
;		field when creating a logical name table.
;
;	V03-003	TMK0001		Todd M. Katz		18-Mar-1983
;		Re-write SYS$CRELNT. Add SYS$CRELNM, SYS$DELLNM, SYS$TRNLNM.
;
;--

	.SBTTL	DECLARATIONS

;
; MACRO LIBRARY CALLS
;
 
	$ARMDEF				;DEFINE ACCESS RIGHTS MASK
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY SWITCHES
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$LNMDEF				;DEFINE LOGICAL NAME ATTRIBUTES
	$LNMSTRDEF			;DEFINE LOGICAL NAME STRUCTURES OFFSETS
	$ORBDEF				;DEFINE OBJECT RIGHTS BLOCK OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR CREATE LOGICAL NAME TABLE.
;

CTATTR=4			;ADDRESS OF TABLE ATTRIBUTES
CTRESNAM=8			;ADDRESS OF TABLE NAME STRING DESCRIPTOR
CTRESLEN=12			;ADDRESS OF WORD TO RECEIVE LENGTH OF TABLE NAME
CTQUOTA=16			;ADDRESS OF TABLE QUOTA
CTPROT=20			;ADDRESS OF PROTECTION MASK
CTTABNAM=24			;ADDRESS OF TABLE NAME STRING DESCRIPTOR
CTPARTAB=28			;PARENT TABLE NAME DESCRIPTOR
CTACMODE=32			;ADDRESS OF ACCESS MODE

;
; ARGUMENT LIST OFFSET DEFINITIONS FOR CREATE LOGICAL NAME.
;
 
CNATTR=4			;ADDRESS OF ATTRIBUTES
CNTABNAM=8			;ADDRESS OF TABLE NAME STRING DESCRIPTOR
CNLOGNAM=12			;ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
CNACMODE=16			;ADDRESS OF ACCESS MODE
CNITMLST=20			;ADDRESS OF ITEM LIST
 
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR DELETE LOGICAL NAME.
;
 
DNTABNAM=4			;ADDRESS OF TABLE NAME STRING DESCRIPTOR
DNLOGNAM=8			;ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
DNACMODE=12			;ADDRESS OF ACCESS MODE
 
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR TRANSLATE LOGICAL NAME.
;
 
TRATTR=4			;ADDRESS OF TRANSLATION FLAGS
TRTABNAM=8			;ADDRESS OF TABLE NAME STRING DESCRIPTOR
TRLOGNAM=12			;ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
TRACMODE=16			;ADDRESS OF ACCESS MODE
TRITMLST=20			;ADDRESS OF ITEM LIST

;
; PROTECTION MASK CONSTANTS FOR CHECKING.
;

READ_ACCESS	= ARM$M_READ
WRITE_ACCESS	= ARM$M_WRITE
QUOTA_ACCESS	= ARM$M_EXECUTE
DELETE_ACCESS	= ARM$M_DELETE

;
; ASSUME STATEMENTS FOR LOGICAL NAME BLOCK, LOGICAL NAME TRANSLATION, AND 
; LOGICAL NAME TABLE HEADER.
;

	ASSUME	LNMB$B_TYPE+1,	   EQ,	LNMB$B_ACMODE
	ASSUME	LNMB$B_ACMODE+1,   EQ,	LNMB$L_TABLE
	ASSUME	LNMB$L_TABLE+4,	   EQ,	LNMB$B_FLAGS
	ASSUME	LNMB$B_FLAGS+1,	   EQ,	LNMB$T_NAME

	ASSUME	LNMX$B_FLAGS,	   EQ,	0
	ASSUME	LNMX$B_FLAGS+1,	   EQ,	LNMX$B_INDEX
	ASSUME	LNMX$B_INDEX+1,	   EQ,	LNMX$W_HASH
	ASSUME	LNMX$W_HASH+2,	   EQ,	LNMX$T_XLATION

	ASSUME	LNMTH$B_FLAGS,	   EQ,	0
	ASSUME	LNMTH$B_FLAGS+1,   EQ,	LNMTH$L_HASH
	ASSUME	LNMTH$L_HASH+4,	   EQ,	LNMTH$L_ORB
	ASSUME	LNMTH$L_ORB+4,	   EQ,	LNMTH$L_NAME
	ASSUME	LNMTH$L_NAME+4,	   EQ,	LNMTH$L_PARENT
	ASSUME	LNMTH$L_PARENT+4,  EQ,	LNMTH$L_CHILD
	ASSUME	LNMTH$L_CHILD+4,   EQ,	LNMTH$L_SIBLING
	ASSUME	LNMTH$L_SIBLING+4, EQ,	LNMTH$L_QTABLE
	ASSUME	LNMTH$L_QTABLE+4,  EQ, 	LNMTH$L_BYTESLM
	ASSUME	LNMTH$L_BYTESLM+4, EQ,	LNMTH$L_BYTES

	.PSECT	YF$$LNM

;
; LOCAL DATA
;

LNM_HEX_TAB_LEN = 4 + 8 + 8		;SIZE OF "LNM$" + pid + addr
HEXDIGITS:
	.ASCII	/0123456789ABCDEF/	;TABLE TO CONVERT INTEGER TO HEX DIGIT

;	.PAGE

	.SBTTL	EXE$CRELNT	- CREATE LOGICAL NAME TABLE

;+
; EXE$CRELNT - CREATE LOGICAL NAME TABLE
;
; THIS SERVICE PROVIDES THE CAPABILITY TO CREATE A LOGICAL NAME TABLE.
;
; INPUTS:
;
;	CTATTR(AP) 	= ADDRESS OF TABLE ATTRIBUTES.
;	CTRESNAM(AP) 	= ADDRESS OF DESCRIPTOR TO RECEIVE TABLE NAME STRING.
;	CTRESLEN(AP) 	= ADDRESS OF WORD TO RECEIVE LENGTH OF TABLE NAME.
;	CTQUOTA(AP) 	= ADDRESS OF BYTE QUOTA FOR TABLE AND NAMES CONTAINED THEREIN.
;	CTPROT(AP) 	= ADDRESS OF SOGW PROTECTION MASK.
;	CTTABNAM(AP) 	= ADDRESS OF TABLE NAME STRING DESCRIPTOR.
;	CTPARTAB(AP) 	= ADDRESS OF PARENT TABLE NAME DESCRIPTOR.
;	CTACMODE(AP) 	= ADDRESS OF ACCESS MODE OF LOGICAL NAME TABLE TO BE CREATED.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CREATE LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_ACCVIO	- TABLE NAME DESCRIPTOR, LOGICAL NAME 
;			DESCRIPTOR, LOGICAL NAME STRING, PARENT TABLE NAME 
;			DESCRIPTOR, PARENT TABLE NAME STRING CANNOT BE READ BY 
;			CALLING ACCESS MODE. TABLE NAME LENGTH WORD, TABLE NAME 
;			STRING BUFFER CANNOT BE WRITTEN BY CALLING ACCESS MODE.
;
;		R0 = SS$_BADPARAM - INVALID ATTRIBUTE OR ACCESS MODE SPECIFIED.
;			PARENT LOGICAL NAME TABLE NAME NOT SPECIFIED.
;
;		R0 = SS$_DUPLNAM - ATTEMPT MADE TO SUPERSEDE NON-ALIASABLE 
;			LOGICAL NAME TABLE ENTRY OF THE SAME OR AN INNER ACCESS
;			MODE.
;
;		R0 = SS$_EXLNMQUOTA - INSUFFICIENT QUOTA AVAILABLE IN THE 
;			PARENT LOGICAL NAME TABLE'S QUOTA TABLE FOR THE 
;			CREATION OF THE NEW LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_INSFMEM - SUFFICIENT SYSTEM DYNAMIC MEMORY DOES NOT
;			EXIST TO ALLOCATE THE NEW LOGICAL NAME TABLE ENTRY AND
;			IMPLICIT RESOURCE WAIT IS NOT ENABLED.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			LOGICAL OR PARENT TABLE NAME STRING SPECIFIED.
;
;		R0 = SS$_IVLOGTAB - INVALID PARENT TABLE NAME SPECIFIED OR
;			INVALID LOGICAL NAME TABLE NAME SPECIFIED.
;
;		R0 = SS$_NOLOGTAB - PARENT TABLE SPECIFIED DOES NOT EXIST.
;
;		R0 = SS$_NOPRIV - PROCESS DOES NOT HAVE PRIVILEGE TO CREATE
;			SPECIFIED LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_PARENT_DEL - INSERTION OF NEW LOGICAL NAME TABLE ENTRY
;			WOULD HAVE RESULTED IN THE DELETION OF A (GRAND)PARENT
;			LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_RESULTOVF - BUFFER NOT LARGE ENOUGH TO CONTAIN NAME
;			OF NEW LOGICAL NAME TABLE.
;
;		R0 = SS$_TOOMANYLNM - TOO MANY LEVELS OF RECURSION IN SEARCH
;			FOR PARENT TABLE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_LNMCREATED - NORMAL COMPLETION, NEW LOGICAL NAME TABLE
;			ENTRY CREATED.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION, LNM$V_CREATE_IF SET AND 
;			THE LOGICAL NAME TABLE ENTRY ALREADY EXISTED.
;
;		R0 = SS$_SUPERSEDE - NORMAL COMPLETION, NEW LOGICAL NAME TABLE 
;			ENTRY SUPERSEDED A PREVIOUSLY EXISTING ENTRY AT THE SAME
;			OR OUTER ACCESS MODE IN THE SPECIFIED PARENT LOGICAL 
;			NAME TABLE.
;
; SIDE EFFECTS:
;
;	THIS ROUTINE EXITS AT IPL 2, AND MUST CONTINUE TO DO SO, BECAUSE 
;	IT IS CALLED AT SYSTEM INITIALIZATION TIME.
;
;-

	.PSECT	Y$EXEPAGED
	.ENTRY	EXE$CRELNT,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXECRELNT

	.PSECT	YF$$LNM
	.ENABLE	LSB
900$:	MOVZWL	#SS$_ACCVIO,R0		;ACCESS VIOLATION
	RET
910$:	MOVZWL	#SS$_BADPARAM,R0	;BAD SYSTEM SERVICE PARAMETER
	RET
920$:	MOVZWL	#SS$_INSFMEM,R0		;NO PRIVILEGE TO CREATE TABLE ENTRY
930$:	RET
940$:	MOVZWL	#SS$_IVLOGTAB,R0	;INVALID LOGICAL NAME TABLE NAME
	RET

;
; VALIDATE AND COPY PARAMETERS AS NECESSARY. REGISTER ASSIGNMENT FOR THE 
; PARAMETERS ARE AS FOLLOWS:
;
;	R5  = ACCESS MODE.
;	R6  = PROTECTION MASK.
;	R7  = ATTRIBUTE BITS.
;	R8  = ADDRESS OF PROBED AND COPIED PARENT TABLE NAME DESCRIPTOR.
;	R9  = ADDRESS OF PROBED AND COPIED TABLE NAME DESCRIPTOR.
;	R10 = ADDRESS OF PROBED AND COPIED LOGICAL NAME DESCRIPTOR.
;	R11 = ADDRESS OF WORD TO RECEIVE TABLE NAME LENGTH.
;

EXECRELNT:
	MOVL	CTRESLEN(AP),R11	;ADDRESS OF TABLE NAME LENGTH WORD
	BEQL	10$			;BRANCH IF NOT PRESENT
	IFNOWRT	#2,(R11),900$		;CHECK WRITE ACCESS TO WORD
10$:
	MOVL	CTPROT(AP),R6		;ADDRESS OF PROTECTION MASK WORD
	BNEQ	15$			;BRANCH IF ONE PRESENT
	MOVZWL	#^XFF00,R6		;DEFAULT THE PROTECTION TO S:RWED O:RWED
	BRB	20$
15$:	IFNORD	#2,(R6),900$		;CHECK READ ACCESS TO WORD
	MOVZWL	(R6),R6			;GET VALUE

20$:	MOVL	CTRESNAM(AP),R9		;ADDRESS OF TABLE NAME DESCRIPTOR 
	BEQL	30$			;BRANCH IF NOT PRESENT
	MOVL	R9,R1			;SET UP CALL
	JSB	L^EXE$PROBEW_DSC	;PROBE DESCRIPTOR AND WRITE PROBE BUFFER
	BLBC	R0,930$			;CAN'T WRITE BUFFER OR READ DESCRIPTOR
	MOVQ	R1,-(SP)		;SAVE TABLE NAME DESCRIPTOR
	MOVL	SP,R9			;ADDRESS OF TABLE NAME DESCRIPTOR
30$:
	MOVL	CTATTR(AP),R7		;TABLE ATTRIBUTES
	BEQL	35$			;BRANCH IF NOT PRESENT
	IFNORD	#4,(R7),900$		;CHECK READ ACCESS TO VALUE
	MOVL	(R7),R7			;GET VALUE
	BITL	#^C< -
		LNM$M_CONFINE! -	;CONFINE TO PROCESS
		LNM$M_CREATE_IF! -	;SUPERCEDE VS. MAP
		LNM$M_NO_ALIAS -	;DO NOT ALLOW ALIASES
		>,R7
	BNEQ	910$			;INVALID TABLE ATTRIBUTES 

	ASSUME	LNM$C_TABNAMLEN,LE,512
35$:
	MOVL	CTTABNAM(AP),R10	;ADDRESS OF TABLE NAME DESCRIPTOR
	BEQL	40$			;BRANCH IF NOT PRESENT
	IFNORD	#8,(R10),900$		;CHECK ACCESS TO DESCRIPTOR
	MOVQ	(R10),R1		;RETRIEVE TABLE NAME DESCRIPTOR
	MOVZWL	R1,R1			;ZERO HIGH ORDER WORD OF LENGTH
	BEQL	940$			;ERROR IF ZERO LENGTH TABLE NAME
	CMPW	R1,#LNM$C_TABNAMLEN	;CHECK SIZE OF TABLE NAME STRING?
	BGTRU	940$			;ERROR IF SPECIFIED SIZE EXCEEDS MAXIMUM
	IFNORD	R1,(R2),44$		;CHECK ACCESS TO TABLE NAME BUFFER
	MOVQ	R1,-(SP)		;SAVE TABLE NAME DESCRIPTOR
	MOVL	SP,R10			;ADDRESS OF TABLE NAME DESCRIPTOR
40$:
	MOVL	CTPARTAB(AP),R8		;ADDRESS OF PARENT TABLE DESCRIPTOR 
	BEQL	42$			;ERROR IF NOT PRESENT
	IFNORD	#8,(R8),44$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R8),R0			;ADDRESS OF DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE PARENT TABLE NAME STRING
	BLBC	R0,43$			;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE PARENT TABLE NAME DESCRIPTOR
	MOVL	SP,R8			;ADDRESS OF PARENT TABLE NAME DESCRIPTOR

	MOVL	CTACMODE(AP),R0		;GET SPECIFIED ACCESS MODE
	BEQL	50$			;BRANCH IF NOT PRESENT
	IFNORD	#1,(R0),44$		;CHECK READ ACCESS TO BYTE
	MOVZBL	(R0),R0			;GET VALUE
	CMPL	#PSL$C_USER,R0		;CHECK FOR VALID ACCESS MODE
	BGEQU	45$			;OKAY
42$:	BRW	910$			;INVALID ACCESS MODE
43$:	BRW	930$			;RETURN
44$:	BRW	900$			;ACCESS VIOLATION

;
; IF THE ACCESS MODE OF THE NEW LOGICAL NAME TABLE WAS EXPLICITELY SPECIFIED
; AND THE CALLER HAS THE SYSNAM PRIVILEGE, THEN THE NEW LOGICAL NAME TABLE IS
; CREATED WITH THE SPECIFIED ACCESS MODE. OTHERWISE, THE ACCESS MODE OF THE
; CALLER IS MAXIMIZED WITH ANY EXPLICTELY SPECIFIED ACCESS MODE AND USED TO
; CREATE THE NEW LOGICAL NAME TABLE.
;

45$:	IFPRIV	SYSNAM,60$		;SYSNAM REQUIRED TO SPECIFY INNER MODE
50$:	JSB	G^EXE$MAXACMODE		;MAXIMIZE SPECIFIED MODE WITH CALLER'S 
60$:	MOVL	R0,R5			;MODE TO DETERMINE MODE OF NEW TABLE

;
; RAISE IPL TO AST DELIVERY LEVEL SO THAT THERE ARE NO INTERRUPTIONS WHILE
; THE LOGICAL NAME TABLE ENTRY IS BEING CREATED.
;

	SETIPL	S^#IPL$_ASTDEL		;RAISE TO AST DELIVERY LEVEL
	PUSHL	R4			;SAVE THE PCB ADDRESS 

;
; ALLOCATE A LOGICAL NAME BLOCK FOR THE NEW LOGICAL NAME TABLE ENTRY. ASSUME
; THAT THE NEW LOGICAL NAME TABLE WILL BE SHAREABLE, SO ALLOCATE THE SPACE
; FROM SYSTEM PAGED POOL. UNTIL THE PARENT LOGICAL TABLE BLOCK IS LOCATED,
; WHETHER THE NEW LOGICAL NAME TABLE WILL BE IN SYSTEM POOL AND SHAREABLE
; OR IN P1 SPACE AND NOT SHAREABLE IS NOT KNOWN. HOWEVER, THE LOGICAL NAME 
; MUTEX MUST BE LOCKED BEFORE A SEARCH CAN BE MADE FOR THE PARENT LOGICAL NAME 
; TABLE, AND ONCE THE MUTEX IS LOCKED, SYSTEM POOL CAN NOT ALTHOUGH P1 POOL CAN 
; BE ALLOCATED. THEREFORE, THE NEW LOGICAL NAME TABLE ENTRY IS ASSUMED TO BE
; SHAREABLE, AND IF THE PARENT TABLE IS FOUND TO RESIDE IN SYSTEM POOL, THEN THE
; SYSTEM POOL ALLOCATED FOR THE NEW ENTRY IS DEALLOCATED, AND PROCESS-PRIVATE
; POOL IS ALLOCATED IN ITS PLACE.
;

	TSTL	R10			;LOGICAL NAME EXPLICITELY SPECIFIED?
	BEQL	70$			;NO  - GO GET FIXED SIZE TO USE
	MOVL	(R10),R1		;YES - LOGICAL NAME SIZE IS USED AS
	BRB	75$			;      SIZE OF LNMB NAME
70$:	MOVL	#LNM_HEX_TAB_LEN,R1	;FIXED SIZE QUANTITY 

75$:	ADDL2	#<-			;LENGTH OF ENTRY =
		LNMB$T_NAME+1+ -	;SIZE OF LNMB + NAME SIZE COUNT FIELD 
		LNMX$T_XLATION+1+ -	;SIZE OF LNMX + HEADER SIZE COUNT FIELD 
		LNMTH$K_LENGTH+ - 	;SIZE OF LNMTH 
		ORB$C_LENGTH+ -		;ORB SIZE
		1+ -			;TRAILER BYTE 
		^X07 -			;(ROUND LNMB TO NEXT QUADWORD BOUNDARY)
		>,R1			;SIZE OF LNMB NAME
	BICL2	#^X07,R1		;TRUNCATE LNMB SIZE TO QUADWORD MULTIPLE
	JSB	G^EXE$ALOPAGED		;ALLOCATE THE LOGICAL NAME TABLE ENTRY
	BLBS	R0,77$			;BRANCH IF SUFFICIENT MEMORY
	BRW	920$			;OTHERWISE RETURN ERROR
77$:	MOVW	R1,LNMB$W_SIZE(R2)	;SAVE NEW BLOCK SIZE WITHIN THE BLOCK

;
; WRITE LOCK THE LOGICAL NAME MUTEX AND THEN POSITION TO THE PARENT LOGICAL
; NAME TABLE. DEALLOCATE THE NEW LNMB IF UNABLE TO POSITION TO THE PARENT
; TABLE ENTRY.
;

	PUSHL	R2			;SAVE LOGICAL NAME BLOCK ADDRESS
	BSBW	LNM$LOCKW		;LOCK TABLES FOR WRITING
	MOVL	R5,R1			;ACCESS MODE
	MOVQ	(R8),R2			;TABLE NAME DESCRIPTOR
	BSBW	LNM$FIRSTTAB		;SEARCH FOR SPECIFIED PARENT TABLE
	POPL	R4			;RESTORE LOGICAL NAME BLOCK ADDRESS
	BLBS	R0,80$			;BRANCH ON FAILURE
	BRW	160$

;
; IF THE PARENT LOGICAL NAME TABLE IS SHAREABLE THEN: 
;
; 1. MARK THE NEW TABLE AS SHAREABLE. 
; 2. MAKE SURE THE NEW TABLE IS NOT MARKED AS CONFINED.
; 3. MAKE SURE THE CALLER HAS QUOTA ACCESS TO THE PARENT LOGICAL NAME TABLE.
; 3. MAKE SURE THAT THE CALLER HAS WRITE ACCESS TO THE SYSTEM DIRECTORY TABLE
;    PROVIDED THE USER IS SPECIFYING THE NAME OF THE SHAREABLE TABLE AND NOT 
;    LETTING VMS DEFAULT NAME IT.
;

80$:	BBC	#LNMTH$V_SHAREABLE,-	;BRANCH IF THE PARENT TABLE ENTRY IS IN
		LNMTH$B_FLAGS(R1),90$	;PROCESS-PRIVATE SPACE 
	BICL2	#LNM$M_CONFINE,R7	;SHAREABLE TABLES CAN'T BE CONFINED
	BBCS	#LNM$V_SHAREABLE,R7,83$	;MARK NEW TABLE AS SHAREABLE

83$:	MOVZBL	#QUOTA_ACCESS,R2	;CODE FOR ACCESS CHECK
	PUSHL	R4			;SAVE LNMB PTR
	MOVL	4(SP),R4		;RESTORE PCB
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	MOVL	(SP)+,R4		;RESTORE LNMB
	BLBS	R0,85$			;EXIT ON FAILURE
	BRW	160$

85$:	TSTL	R10			;WAS A NAME SPECIFIED FOR THE NEW TABLE
	BEQL	100$			;BRANCH IF ONE WASN'T

	MOVZBL	#WRITE_ACCESS,R2	;CODE FOR ACCESS CHECK
	PUSHR	#^M<R1,R4>		;SAVE LNMB AND PARENT TABLE HEADER ADDR
	MOVL	LNMTH$L_NAME(R1),R1	;RETRIEVE ADDRESS OF PARENT LNMB
	MOVL	LNMB$L_TABLE(R1),R1	;RETRIEVE SYSTEM DIRECTORY TABLE HEADER
	MOVL	8(SP),R4		;RESTORE PCB
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	POPR	#^M<R1,R4>		;RESTORE LNMB AND PARENT TABLE HEADER 
	BLBC	R0,105$			;EXIT ON FAILURE
	BRB	100$

;
; IF THE PARENT TABLE IS DISCOVERED TO EXIST IN PROCESS-PRIVATE SPACE, THEN
; THIS IS ALSO WHERE THE NEW LOGICAL NAME TABLE ENTRY SHOULD GO. DEALLOCATE
; THE SYSTEM SPACE LNMB, AND ALLOCATE A SUFFICIENTLY SIZED BLOCK FROM P1 
; SPACE.
;

90$:	PUSHL	R1			;SAVE ADDRESS OF PARENT'S TABLE HEADER
	MOVZWL	LNMB$W_SIZE(R4),-(SP)	;SAVE SIZE OF LNMB AND COMPUTE SIZE
	SUBL2	#ORB$K_LENGTH,(SP)	;OF BLOCK TO BE ALLOCATED FROM P1 POOL
	MOVL	R4,R0			;ADDRESS OF SYSTEM SPACE LNMB
	BSBW	LNM$DELBLK		;DEALLOCATE SYSTEM SPACE LNMB

	POPL	R1			;SIZE OF STORAGE TO ALLOCATE
	JSB	G^EXE$ALOP1PROC		;ALLOCATE NEW LNMB FROM P1 SPACE
	BLBS	R0,95$			;BRANCH IF SUCCESSFUL
	MOVZWL	#SS$_INSFMEM,(SP)	;OTHERWISE RETURN INSUFFICIENT MEMORY
	BRW	190$			;ERROR AFTER RELEASING MUTEX

95$:	MOVL	R2,R4			;ADDRESS OF NEW LNMB
	MOVW	R1,LNMB$W_SIZE(R4)	;SAVE SIZE WITHIN BLOCK
	POPL	R1			;ADDRESS OF PARENT'S TABLE HEADER
	MOVL	LNMTH$L_NAME(R1),R2	;ADDRESS OF PARENT'S LNMB
	BBC	#LNMB$V_CONFINE,-	;IS THE PARENT ENTRY MARKED CONFINE?
		LNMB$B_FLAGS(R2),100$	;BRANCH IF NOT
	BBCS	#LNM$V_CONFINE,R7,100$	;MAKE SURE NEW ENTRY IS IF SO

;
; PERFORM QUOTA CHECKS. TWO SUCH QUOTA CHECKS ARE MADE:
; 
; 1. THE CONTAINING TABLE (SYSTEM OR PROCESS DIRECTORY TABLE) IS CHECKED TO
;    MAKE SURE IT HAS SUFFICIENT QUOTA TO CONTAIN THE NEW LOGICAL NAME TABLE
;    ENTRY. NOTE THAT AN ASSUMPTION IS MADE THAT THE DIRECTORY TABLES ARE
;    THEIR OWN QUOTA HOLDERS.
;
; 2. THE PARENT LOGICAL NAME TABLE'S QUOTA HOLDER IS CHECKED TO MAKE SURE IT HAS
;    SUFFICIENT QUOTA FOR THE QUOTA WHICH WILL BE DEDUCTED FROM IT AND ALLOCATED
;    SPECIFICALLY TO THE NEW TABLE.
;

100$:	MOVL	LNMTH$L_NAME(R1),R2	;RETRIEVE PARENT'S TABLE HEADER ADDRESS
	MOVL	LNMB$L_TABLE(R2),R2	;RETRIEVE CONTAINING TABLE'S ADDRESS
	MOVZWL	LNMB$W_SIZE(R4),R0	;SIZE OF NEW TABLE ENTRY
	CMPL	R0,LNMTH$L_BYTES(R2)	;IS THERE SUFFICIENT QUOTA?
	BGTRU	103$			;NO  - DEALLOCATE LNMB AND RETURN ERROR
	
	MOVL	CTQUOTA(AP),R8		;RETRIEVE NEW TABLE'S QUOTA
	BEQL	110$			;SKIP SECOND QUOTA CHECK IF NOT PRESENT
	IFNORD	#4,(R8),107$		;CHECK READ ACCESS TO VALUE
	MOVL	(R8),R8			;GET VALUE

101$:	MOVL	LNMTH$L_QTABLE(R1),R2	;RETRIEVE PARENT QUOTA HOLDER'S ADDRESS
	CMPL	R8,LNMTH$L_BYTES(R2)	;IS THERE SUFFICIENT QUOTA?
	BLEQU	110$			;YES - THEN CONTINUE
103$:	MOVZWL	#SS$_EXLNMQUOTA,R0	;NO  - THEN DEALLOCATE LNMB AND RETURN
105$:	BRW	160$			;      EXCEEDED QUOTA ERROR

107$:	MOVZWL	#SS$_ACCVIO,R0		;NO ACCESS
	BRB	105$			;EXIT

;
; FILL IN THE LNMB PORTION OF THE LOGICAL NAME BLOCK FOR THE NEW LOGICAL NAME
; TABLE ENTRY.
;
; REGISTER USAGE IS AS FOLLOWS:
;
;	R1  = ADDRESS OF TABLE HEADER FOR PARENT LOGICAL NAME TABLE.
;	R3  = SIZE OF NEW LOGICAL NAME TABLE ENTRY'S NAME.
;	R4  = ADDRESS OF LOGICAL NAME BLOCK FOR NEW LOGICAL NAME TABLE.
;	R5  = ACCESS MODE.
;	R6  = ADDRESS OF PROTECTION MASK.
;	R7  = ATTRIBUTE BITS.
;	R8  = QUOTA.
;	R9  = ADDRESS OF PROBED AND COPIED TABLE NAME DESCRIPTOR.
;	R10 = ADDRESS OF PROBED AND COPIED LOGICAL NAME DESCRIPTOR.
;	R11 = ADDRESS OF WORD TO RECEIVE TABLE NAME LENGTH.
;

110$:	MOVAB	LNMB$B_TYPE(R4),R0	;POSITION TO BLOCK TYPE
	MOVB	#DYN$C_LNM,(R0)+	;SET DATA STRUCTURE TYPE
	MOVB	R5,(R0)+		;SET OWNER ACCESS MODE

	MOVL	LNMTH$L_NAME(R1),R2	;ADDRESS OF PARENT'S LOGICAL NAME BLOCK
	MOVL	LNMB$L_TABLE(R2),(R0)+	;STORE DIRECTORY TABLE HEADER ADDRESS

	BISB3	R7,#LNMB$M_TABLE,(R0)+	;STORE NAME ATTRIBUTES

;
; IF THE CALLER HAS SPECIFIED A LOGICAL NAME STRING THEN THAT STRING BECOMES
; THE NAME OF THE LNMB FOR THE NEW LOGICAL NAME TABLE ENTRY BY MOVING IT INTO 
; THE LOGICAL NAME BLOCK. OTHERWISE, THE UNIQUE NAME OF THE LNMB IS A 
; CONSTRUCTED QUANTITY OF FIXED (12 BYTES) SIZE.
;

	TSTL	R10			;LOGICAL NAME STRING SPECIFIED?
	BEQL	120$			;NO  - BRANCH TO CONSTRUCT UNIQUE NAME
	MOVB	(R10),(R0)+		;STORE LENGTH OF NAME
	MOVQ	R4,-(SP)		;SAVE NEEDED REGISTERS OVER MOVTUC
	PUSHL	R1
	MOVTUC	(R10),@4(R10),#0,-	;CHECK FOR PROPER TABLE NAME SYNTAX AND 
		EXE$LNM_SYNTAX_DAT,-	;AT THE SAME TIME MOVE THE TABLE NAME
		(R10),(R0)		;INTO THE LOGICAL NAME TABLE ENTRY
	BVS	115$			;BRANCH IF TABLE NAME HAS INVALID CHARS
	MOVL	R5,R0			;POSITION PAST LNMB NAME STRING
	POPL	R1			;RESTORE SAVED REGISTERS
	MOVQ	(SP)+,R4
	BRB	130$			;BRANCH AROUND UNIQUE NAME CONSTRUCTION

115$:	POPR	#^M<R1,R4,R5>		;RESTORE REGISTERS
	MOVZWL	#SS$_IVLOGTAB,R0	;INVALID TABLE NAME STRING SPECIFIED
	BRB	105$			;SO GO RETURN THE APPROPRIATE ERROR

120$:	MOVB	#LNM_HEX_TAB_LEN,(R0)+	;STORE LENGTH OF NAME
	MOVL	#^A/LNM$/,(R0)+		;STORE BEGINNING OF NAME
	MOVL	#<8-1>*4,R3		;STARTING NIBBLE POSITION
125$:	EXTZV	R3,#4,R4,R2		;EXTRACT HEX DIGIT
	MOVB	HEXDIGITS[R2],(R0)+	;STORE ASCII EQUIVALENT
	SUBL	#4,R3			;ADJUST POSITION TO SUCCEEDING NIBBLE
	BGEQ	125$			;ITERATE OVER 8 DIGITS
	PUSHL	R4			;SAVE ADDR OF LNMB
	MOVL	4(SP),R4		;GET PCB ADDR
	MOVL	PCB$L_EPID(R4),R4	;GET PID
	MOVL	#<8-1>*4,R3		;STARTING NIBBLE POSITION
126$:	EXTZV	R3,#4,R4,R2		;EXTRACT HEX DIGIT
	MOVB	HEXDIGITS[R2],(R0)+	;STORE ASCII EQUIVALENT
	SUBL	#4,R3			;ADJUST POSITION TO SUCCEEDING NIBBLE
	BGEQ	126$			;ITERATE OVER 8 DIGITS
	MOVL	(SP)+,R4		;RESTORE LNMB ADDR
;
; FILL IN THE LNMX PORTION OF THE LOGICAL NAME BLOCK FOR THE NEW LOGICAL NAME
; TABLE ENTRY. FOR LOGICAL NAME TABLES THE SOLE TRANSLATION CONSISTS OF THE 
; TABLE HEADER.
;

130$:	MOVB	#LNMX$M_TERMINAL,(R0)+	;STORE TRANSLATION ATTRIBUTES
	MOVB	#LNMX$C_TABLE,(R0)+	;STORE TRANSLATION INDEX (SPECIAL)
	CLRW	(R0)+			;INITIALIZE HASH CODE LOCATION TO 0
	MOVB	#LNMTH$K_LENGTH,(R0)+	;STORE LENGTH OF TABLE HEADER

;
; FILL IN THE LNMTH PORTION OF THE LOGICAL NAME BLOCK FOR THE NEW LOGICAL NAME
; TABLE ENTRY. THE TABLE HEADER OF THE NEW ENTRY CONSTIUTES THE SOLE 
; TRANSLATION OF THE NEW LOGICAL NAME TABLE ENTRY.
;

	MOVL	R0,R2			;SAVE ADDRESS OF TABLE HEADER
	ROTL	#16,R7,R3		;TABLE ATTRIBUTES TO LOW BYTE OF R3
	MOVB	R3,(R0)+		;STORE TABLE HEADER ATTRIBUTES

	MOVL	LNMTH$L_HASH(R1),(R0)+	;HASH TABLE ADDRESS IS SAME AS PARENTS

	CLRL	(R0)+			;ZERO OBJECT RIGHTS BLOCK ADDR FOR NOW
	MOVAB	(R4),(R0)+		;STORE CONTAINING LNMB BLOCK ADDRESS
	MOVL	R1,(R0)+		;STORE PARENT TABLE HEADER ADDRESS
	CLRQ	(R0)+			;STORE CHILD TABLE HEADER ADDRESS 
					;STORE SIBLING TABLE HEADER ADDRESS

	MOVL	LNMTH$L_QTABLE(R1),(R0)+;ASSUME QUOTA HOLDER IS SAME AS PARENTS
	MOVL	R8,(R0)			;STORE TABLE QUOTA
	BEQL	135$			;BRANCH IF POOLED QUOTA
	MOVL	R2,LNMTH$L_QTABLE(R2)	;NEW ENTRY IS A QUOTA TABLE
135$:	MOVL	(R0)+,(R0)+		;STORE QUOTA BYTES REMAINING (= QUOTA)

;
; FILL IN THE NEXT LNMX PORTION OF THE LOGICAL NAME BLOCK FOR THE NEW LOGICAL 
; NAME TABLE ENTRY. THE LAST TRANSLATION BLOCK CONSISTS SOLELY OF A FLAGS
; FIELD, AND IS MARKED WITHIN THIS FLAGS FIELD AS THE LAST LNMX.
;

	MOVB	#LNMX$M_XEND,(R0)+	;STORE END FLAG

;
; INITIALIZE THE OBJECT RIGHTS BLOCK WHICH EXISTS FOR ALL SHAREABLE LOGICAL NAME
; TABLES. PROCESS-PRIVATE LOGICAL NAME TABLES DO NOT REQUIRE SUCH A ORB BECAUSE
; BECAUSE PROTECTION CHECKING IS NOT REQUIRED, AND IS NEVER PERFORMED ON THEM.
;

	BBC	#LNMTH$V_SHAREABLE,-	;IS PARENT LOGICAL NAME TABLE SHAREABLE?
		LNMTH$B_FLAGS(R1),137$	;IF NOT, SKIP INITIALIZATION OF ORB
	BSBW	LNM$INIT_PROT		;INITIALIZE TABLE'S OBJECT RIGHTS BLOCK
137$:	MOVL	R2,R6			;SAVE TABLE HEADER ADDRESS

;
; SET THE TEMPORARY BIT LNMB$V_NODELETE IN THE FLAGS BYTE OF THE LNMB BLOCK OF
; THE NEW LOGICAL NAME TABLE ENTRY'S PARENT, GRANDPARENT ETC... THIS WILL 
; PREVENT THE NEW ENTRY FROM BEING INSERTED IF ITS INSERTION WOULD RESULT IN 
; THE DELETION OF ANY LOGICAL NAME TABLE ENTRY IN ITS DIRECT LINE OF DESCENT;
; AND THUS, THE DELETION OF ITS PARENT TABLE. 
;

140$:	BBS	#LNMTH$V_DIRECTORY,-	;SYSTEM/PROCESS DIRECTORY TABLE?
		LNMTH$B_FLAGS(R1),150$	;YES - GO INSERT NEW TABLE ENTRY 
	MOVL	LNMTH$L_NAME(R1),R2	;ADDRESS OF PARENT'S LNMB BLOCK
	BISB2	#LNMB$M_NODELETE,-	;SET THE TEMPORARY BIT BLOCKING DELETION
		LNMB$B_FLAGS(R2)	;OF THIS LOGICAL NAME TABLE ENTRY
	MOVL	LNMTH$L_PARENT(R1),R1	;NO  - RETRIEVE PARENT'S TABLE HEADER 
	BRB	140$			;      ADDRESS AND CONTINUE

; 
; AT THIS POINT ALL CHECKS HAVE BEEN MADE, AND THE TABLE STRUCTURES MAY NOW
; BE MODIFIED FOR THE FIRST TIME. INSERT THE NEW LOGICAL NAME TABLE ENTRY AND
; THEN CLEAR THE TEMPORARY DO NOT DELETE BIT, LNMB$V_NODELETE REGARDLESS OF THE 
; OUTCOME OF THE INSERTION.
;
; THIS INSERTION MAY TAKE ONE OF THREE FORMS:
;
; 1. THE NEW LOGICAL NAME TABLE ENTRY MAYBE INSERTED AS A NEW LOGICAL NAME 
;    TABLE. FOR THIS CASE TO OCCUR THE FOLLOWING CONDITIONS MUST HOLD TRUE.
;
;    A. THERE IS NO EXISTING LOGICAL NAME TABLE ENTRY IN THE SAME DIRECTORY
;	(PROCESS OT SYSTEM) WITH THE SAME NAME AND ACCESS MODE.
;
;    B. THERE IS NO EXISTING LOGICAL NAME TABLE ENTRY IN THE SAME DIRECTORY
;	(PROCESS OR SYSTEM) WITH THE SAME NAME AND AN INNER ACCESS MODE THAT 
;	DOES NOT ALLOW ALIASES.
;
; 2. THE LOGICAL NAME TABLE ENTRY MAYBE "MAPPED" INTO AN EXISTING LOGICAL NAME 
;    TABLE ENTRY. FOR THIS CASE TO OCCUR THE FOLLOWING CONDITIONS MUST BE MET.
;
;    A. THE LNM$V_CREATE_IF BIT MUST HAVE BEEN SET IN THE ATTRIBUTES FIELD.
;
;    B. THERE MUST EXIST A LOGICAL NAME TABLE ENTRY WITH THE SAME NAME AND
;	ACCESS MODE WITHIN THE SAME DIRECTORY (PROCESS OR SYSTEM).
;
; 3. THE LOGICAL NAME TABLE ENTRY MAYBE INSERTED SUPERSEDING AN EXISTING ENTRY 
;    IN THE SAME DIRECTORY (PROCESS OR SYSTEM) WITH THE SAME NAME AND ACCESS 
;    MODE. THE OLD LOGICAL NAME TABLE ENTRY TOGETHER WITH ITS ENTIRE HIERARCHY
;    OF LOGICAL NAMES AND LOGICAL NAME TABLE ENTRIES IS DELETED, PROVIDED OF
;    COURSE, THAT THE OLD ENTRY WAS FOR A LOGICAL NAME TABLE. THE CONDITIONS
;    WHICH MUST BE MET FOR THIS CASE TO OCCUR ARE:
;
;    A. THE LNM$V_CREATE_IF BIT MUST NOT HAVE BEEN SET IN THE ATTRIBUTES FIELD.
;
;    B. THERE MUST EXIST A LOGICAL NAME TABLE ENTRY WITH THE SAME NAME AND
;	ACCESS MODE WITHIN THE SAME DIRECTORY (PROCESS OR SYSTEM).
;
; IF A CASE 1 OR 3 INSERTION IS PERFORMED, AND THE NEW LOGICAL NAME TABLE ENTRY
; DOES NOT ALLOW ALIASES, THEN ANY LOGICAL NAME TABLE ENTRIES IN THE SAME 
; DIRECTORY (PROCESS OR SYSTEM) WITH THE SAME NAME BUT AT AN OUTER ACCESS MODES
; ARE DELETED ALONG WITH THEIR HIERARCHY OF LOGICAL NAMES AND LOGICAL NAME 
; TABLE ENTRIES, PROVIDED THEY TOO ARE LOGICAL NAME TABLES.
;

150$:	MOVL	R4,R1			;ADDRESS OF NEW LOGICAL NAME TABLE ENTRY
	MOVL	R7,R2			;ATTRIBUTES
	BSBW	LNM$INSLOGTAB		;INSERT NEW LOGICAL NAME TABLE ENTRY
	MOVL	R1,R3			;SAVE LNMB ADDRESS OF MAPPED-TO ENTRY
					;IF SUCH A MAPPING HAS TAKEN PLACE

	MOVL	LNMTH$L_PARENT(R6),R1	;RETRIEVE PARENT'S TABLE HEADER
155$:	BBS	#LNMTH$V_DIRECTORY,-	;SYSTEM/PROCESS DIRECTORY TABLE?
		LNMTH$B_FLAGS(R1),160$	;YES - GO CHECK INSERTION
	MOVL	LNMTH$L_NAME(R1),R2	;ADDRESS OF PARENT'S LNMB BLOCK
	BICB2	#LNMB$M_NODELETE,-	;CLEAR THE TEMPORARY BIT BLOCKING 
		LNMB$B_FLAGS(R2)	;DELETION OF THIS LNMB
	MOVL	LNMTH$L_PARENT(R1),R1	;NO  - RETRIEVE PARENT'S TABLE HEADER
	BRB	155$			;      ADDRESS AND CONTINUE

160$:	PUSHL	R0			;SAVE STATUS
	BLBS	R0,170$			;BRANCH ON SUCCESS
	MOVL	R4,R0			;LOGICAL NAME BLOCK FOR NEW TABLE ENTRY
	BSBW	LNM$DELBLK		;DELETE BLOCK CONTAINING NEW TABLE ENTRY
	BRB	190$			;JOIN MAIN EXIT - STATUS ON STACK

;
; AT THIS POINT THE NEW LOGICAL NAME TABLE HAS SUCCESSFULLY BEEN INSERTED.
; FILL IN ANY SPECIFIED OUTPUT PARAMETERS (TABLEN AND/OR TABNAM) BEFORE 
; RETURNING THE STATUS TO THE CALLER OF THE SYSTEM SERVICE. IF THE NEW TABLE
; ENTRY WAS JUST MAPPED TO AN EXISTING TABLE ENTRY, THEN THE LOGICAL NAME BLOCK
; CONTAINING THE NEW TABLE ENTRY IS DELETED BEFORE RETURNING.
;

170$:	CMPL	#SS$_NORMAL,R0		;WAS NEW ENTRY MAPPED TO EXISTING ONE?
	BNEQ	175$			;BRANCH IF NOT
	MOVL	R4,R0			;ADDRESS OF NEW ENTRY
	PUSHL	R3			;SAVE ADDRESS OF ENTRY MAPPED TO
	BSBW	LNM$DELBLK		;DELETE NEW ENTRY
	POPL	R3			;ADDRESS OF ENTRY MAPPED TO

175$:	MOVAB	LNMB$T_NAME(R4),R1	;ADDRESS OF TABLE NAME COUNTED STRING
	MOVZBL	(R1)+,R0		;LENGTH OF NAME STRING

	TSTL	R11			;RETURN LENGTH?
	BEQL	180$			;BRANCH IF NO
	MOVW	R0,(R11)		;RETURN LENGTH

180$:	TSTL	R9			;WANT LOGICAL NAME TABLE NAME RETURNED?
	BEQL	190$			;BRANCH IF NO
	CMPW	R0,(R9)			;ENOUGH ROOM?
	BGTR	185$			;BRANCH IF NOT ENOUGH ROOM
	MOVC3	R0,(R1),@4(R9)		;RETURN NAME STRING
	BRB	190$
185$:	MOVZWL	#SS$_RESULTOVF,(SP)	;NOT ENOUGH ROOM FOR NAME

190$:	MOVL	4(SP),R4		;RETRIEVE PCB ADDRESS
	BSBW	LNM$UNLOCK		;UNLOCK TABLES
	POPL	R0			;RESTORE STATUS
	RET				;RETURN TO CALLER

	.DISABLE	LSB
;	.PAGE

		.SBTTL	EXE$CRELNM	- CREATE LOGICAL NAME
;+
; EXE$CRELNM - CREATE LOGICAL NAME 
;
; THIS SERVICE PROVIDES THE CAPABILITY TO CREATE A LOGICAL NAME ENTRY WITH
; SOME NUMBER OF EQUIVALENCE STRINGS.
;
; INPUTS:
;
;	CNATTR(AP)	= ADDRESS OF LOGICAL NAME ATTRIBUTES.
;	CNTABNAM(AP)	= ADDRESS OF TABLE NAME STRING DESCRIPTOR.
;	CNLOGNAM(AP)	= ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
;	CNACMODE(AP)	= ADDRESS OF ACCESS MODE OF LOGICAL NAME TO BE CREATED.
;	CNITMLST(AP)	= ADDRESS OF ITEM LIST DEFINING TRANSLATIONS.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CREATE LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_ACCVIO	- LOGICAL NAME DESCRIPTOR, LOGICAL NAME STRING, 
;			TABLE NAME DESCRIPTOR, TABLE NAME STRING, AN ITEM IN THE
;			ITEM LIST, AN INDEX ITEM BUFFER, AN ATTRIBUTES ITEM 
;			BUFFER, A STRING ITEM BUFFER, CANNOT BE READ BY CALLING 
;			ACCESS MODE. TABLE ITEM BUFFER, TABLE ITEM SIZE BUFFER 
;			CANNOT BE WRITTEN BY CALLING ACCESS MODE.
;
;		R0 = SS$_BADPARAM - INVALID ATTRIBUTE, ACCESS MODE, ITEM TYPE,
;			ITEM LENGTH, ITEM SPECIFIED. LOGICAL NAME DESCRIPTOR,
;			TABLE NAME DESCRIPTOR NOT SPECIFIED.
;
;		R0 = SS$_DUPLNAM - ATTEMPT MADE TO SUPERSEDE NON-ALIASABLE 
;			LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_EXLNMQUOTA - INSUFFICIENT QUOTA AVAILABLE IN THE QUOTA
;			TABLE FOR THE CREATION OF THE NEW LOGICAL NAME TABLE 
;			ENTRY.
;
;		R0 = SS$_INSFMEM - SUFFICIENT SYSTEM DYNAMIC MEMORY DOES NOT
;			EXIST TO ALLOCATE LOGICAL NAME TABLE ENTRY AND
;			IMPLICIT RESOURCE WAIT IS NOT ENABLED.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			LOGICAL NAME STRING, TABLE NAME STRING, OR EQUIVALENCE
;			STRING SPECIFIED, OR THE LOGICAL NAME IS TO BE CONTAINED
;			WITHIN A DIRECTORY TABLE AND IS EITHER GREATER THAN 31
;			CHARACTERS IN SIZE OR HAS INVALID CHARACTERS FOR SUCH 
;			NAMES.
;
;		R0 = SS$_IVLOGTAB - INVALID LOGICAL NAME TABLE NAME SPECIFIED.
;
;		R0 = SS$_NOLOGTAB - LOGICAL NAME TABLE SPECIFIED DOES NOT EXIST.
;
;		R0 = SS$_TOOMANYLNM - TOO MANY LEVELS OF RECURSION IN SEARCH
;			FOR LOGICAL NAME TABLE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_BUFFEROVF - REQUEST SUCCESSFULLY COMPLETED. AN ITEM
;			BUFFER IS NOT LARGE ENOUGH TO HOLD REQUESTED DATA.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION, NEW ENTRY ENTERED IN
;			SPECIFIED LOGICAL NAME TABLE.
;
;		R0 = SS$_SUPERSEDE - NORMAL COMPLETION, NEW ENTRY SUPERSEDED
;			PREVIOUS ENTRY IN SPECIFIED LOGICAL NAME TABLE.
;
; SIDE EFFECTS:
;
;	THIS ROUTINE EXITS AT IPL 2, AND MUST CONTINUE TO DO SO, BECAUSE 
;	IT IS CALLED AT SYSTEM INITIALIZATION TIME.
;
;-
 
	.PSECT	Y$EXEPAGED
	.ENTRY	EXE$CRELNM,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXECRELNM

	.PSECT	YF$$LNM
	.ENABLE	LSB

;
; ERROR MESSAGES AND RETURNS
;

9000$:	MOVZWL	#SS$_ACCVIO,R0		;ACCESS VIOLATION
	RET
9010$:	MOVZWL	#SS$_BADPARAM,R0	;BAD SYSTEM SERVICE PARAMETER
	RET
9020$:	MOVZWL	#SS$_INSFMEM,R0		;INSUFFICIENT MEMORY 
9030$:	RET

EXECRELNM:

;
; VALIDATE AND COPY PARAMETERS AS NECESSARY. REGISTER ASSIGNMENT FOR THE 
; PARAMETERS ARE AS FOLLOWS:
;
;	R5  = ACCESS MODE.
;	R7  = ATTRIBUTE BITS.
;	R9  = ADDRESS OF PROBED AND COPIED TABLE NAME DESCRIPTOR.
;	R10 = ADDRESS OF PROBED AND COPIED LOGICAL NAME DESCRIPTOR.
;	R11 = ADDRESS OF START OF ITEM LIST.
;
;---

	MOVL	CNACMODE(AP),R0		;GET SPECIFIED ACCESS MODE
	BEQL	50$			;BRANCH IF NOT PRESENT
	IFNORD	#1,(R0),9000$		;CHECK READ ACCESS TO BYTE
	MOVZBL	(R0),R0			;GET VALUE
	CMPL	#PSL$C_USER,R0		;CHECK FOR VALID ACCESS MODE
	BLSSU	9010$			;INVALID ACCESS MODE

;
; IF THE ACCESS MODE OF THE NEW LOGICAL NAME WAS EXPLICITELY SPECIFIED AND THE
; CALLER HAS THE SYSNAM PRIVILEGE, THEN THE NEW LOGICAL NAME IS CREATED WITH 
; THE SPECIFIED ACCESS MODE. OTHERWISE, THE ACCESS MODE OF THE CALLER IS 
; MAXIMIZED WITH ANY EXPLICTELY SPECIFIED ACCESS MODE AND USED TO CREATE THE 
; NEW LOGICAL NAME.
;

	IFPRIV	SYSNAM,60$		;PRIVILEGE
50$:	JSB	G^EXE$MAXACMODE		;MAXIMIZED WITH MODE OF CALLER TO
60$:	MOVL	R0,R5			;DETERMINE ACCESS MODE OF NEW TABLE

	MOVL	CNATTR(AP),R7		;TABLE ATTRIBUTES
	BEQL	200$			;BRANCH IF NOT PRESENT
	IFNORD	#4,(R7),9000$		;CHECK READ ACCESS
	MOVL	(R7),R7			;GET VALUE
	BITL	#^C< -
		LNM$M_CONFINE! -	;CONFINE TO PROCESS
		LNM$M_CRELOG! - 	;$CRELOG USED TO CREATE NAME
		LNM$M_NO_ALIAS -	;DO NOT ALLOW ALIASES
		>,R7
	BNEQ	9010$			;INVALID TABLE ATTRIBUTES 

200$:	MOVL	CNLOGNAM(AP),R10	;ADDRESS OF LOGICAL NAME DESCRIPTOR
	BEQL	9010$			;ERROR IF NOT PRESENT
	IFNORD	#8,(R10),9000$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R10),R0		;ADDRESS OF DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE LOGICAL NAME STRING
	BLBC	R0,9030$		;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE LOGICAL NAME DESCRIPTOR
	MOVL	SP,R10			;ADDRESS OF LOGICAL NAME DESCRIPTOR

	MOVL	CNTABNAM(AP),R9		;ADDRESS OF TABLE NAME DESCRIPTOR 
	BEQL	9010$			;ERROR IF NOT PRESENT
	IFNORD	#8,(R9),9000$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R9),R0			;SET UP CALL
	BSBW	LNM$PROBER		;PROBE TABLE NAME STRING
	BLBC	R0,9030$		;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE TABLE NAME DESCRIPTOR
	MOVL	SP,R9			;ADDRESS OF TABLE NAME DESCRIPTOR

;
; PROBE AND VERIFY THE ITEM LIST. THIS IS THE FIRST OF TWO PASSES DOWN
; THE ITEM LIST.  THIS FIRST PASS IS BEING DONE TO ACCUMULATE
; INFORMATION AS TO THE NUMBER OF TRANSLATION STRINGS BEING DEFINED AND
; THEIR COLLECTIVE SIZE FOR USE IN DETERMINING THE AMOUNT OF SPACE TO
; ALLOCATE FOR THE NEW LOGICAL NAME TABLE ENTRY.  VALID ITEM TYPES FOR
; THIS SYSTEM SERVICE ARE:
;
;	ATTRIBUTES  - ATTRIBUTES FOR NEXT TRANSLATION STRING
;	INDEX	    - INDEX TO BE ASSIGNED TO NEXT TRANSLATION STRING
;	STRING	    - EQUIVALENCE STRING
;	TABLE	    - LOGICAL NAME TABLE NAME   (OUTPUT ITEM)
;	LNMBADDR    - LOGICAL NAME LNMB ADDRESS (OUTPUT ITEM)
;

	CLRQ	-(SP)			;CLEAR COUNTERS
	MOVL	CNITMLST(AP),R11	;ADDRESS OF ITEM LIST
	BEQL	2010$			;BRANCH IF NONE
	CLRL	R0			;CHAINED ITEM LIST COUNTER
	MOVL	R11,R8			;USER R8 TO VERIFY ITEM LIST
1005$:	IFNORD	#4,(R8),1021$		;CHECK IF FIRST LONGWORD READABLE
1010$:
	MOVZWL	2(R8),R2		;GET ITEM TYPE
	BEQL	2010$			;DONE IF ITEM TYPE IS ZERO
	IFNORD	#12,4(R8),1021$		;CHECK REST OF THIS DESCRIPTOR 
					;PLUS FIRST LONGWORD OF NEXT ONE

	CASE	R2,<-			;HANDLE EACH ITEM TYPE SEPARATELY
		     1040$, -		;INDEX ITEM
		     1030$, -		;STRING ITEM
		     1040$, -		;ATTRIBUTES ITEM
		     1040$, -		;TABLE ITEM
		>,W,#1
	CMPW	#LNM$_LNMB_ADDR, R2	;TEST FOR LNMB_ADDR
	BEQL	1040$	
	CMPW	#LNM$_CHAIN,R2		;TEST FOR CHAINED LIST
	BEQL	1050$
1015$:	BRW	9010$			;ILLEGAL ITEM TYPE
1020$:	RET				;RETURN ANY ERRORS

1021$:	BRW	9000$			;ACCESS VIOLATION

;
; STRING ITEM.
;
; VALIDATE THE ITEM.  IF THE STRING SPECIFIED IS A VALID EQUIVALENCE 
; STRING THEN INCREMENT THE TRANSLATION STRING COUNTER, AND ADD THE
; SIZE OF THIS STRING TO THE TOTAL STRING SIZE BEING ACCUMULATED.
;	

1030$:	MOVAQ	(R8),R0			;ADDRESS OF STRING ITEM DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE TRANSLATION STRING
	BLBC	R0,1020$		;BRANCH IF CAN'T READ OR NOT PRESENT
	INCL	(SP)			;INCREMENT EQUIVALENCE STRING COUNTER 
	ADDL2	R1,4(SP)		;ADD SIZE OF STRING TO TOTAL SIZE

;
; POSITION TO THE NEXT ITEM IN THE ITEM LIST. 
;

1040$:	ADDL2	#12,R8			;POSITION TO NEXT ITEM
	BRW	1010$			;AND CONTINUE ITEM LIST VERIFICATION

;
; POSITION TO THE NEXT CHAIN OF THE CHAINED ITEM LIST.
;

1050$:	INCL	R0			;COUNT ONE MORE
	CMPW	R0,#1024
	BGTR	1015$			;TOO MANY - ASSUME A LOOP
	MOVL	4(R8),R8		;GET POINTER TO NEXT LIST
	BEQL	2010$			;LAST ITEM
	BRB	1005$			;PROCESS THIS ONE	

;
; RAISE  IPL  TO AST DELIVERY LEVEL SO THAT THERE ARE NO
; INTERRUPTIONS WHILE THE NEW LOGICAL NAME ENTRY IS BEING CREATED.
;

2010$:	SETIPL	S^#IPL$_ASTDEL		;RAISE TO AST DELIVERY LEVEL

;
; ALLOCATE A LOGICAL NAME BLOCK FOR THE NEW LOGICAL NAME TABLE ENTRY.
; ASSUME THAT THE NEW LOGICAL NAME TABLE WILL BE SHAREABLE, SO ALLOCATE
; THE SPACE FROM SYSTEM PAGED POOL.  UNTIL THE LOGICAL NAME TABLE IN
; WHICH THE NEW ENTRY WILL BE LOCATED IS FOUND, WHETHER THE NEW
; LOGICAL NAME TABLE ENTRY WILL BE IN SYSTEM POOL AND SHAREABLE OR IN
; P1 SPACE AND NOT SHAREABLE IS NOT KNOWN.  HOWEVER, THE LOGICAL NAME
; MUTEX MUST BE LOCKED BEFORE A SEARCH CAN BE MADE FOR THE LOGICAL
; NAME TABLE, AND ONCE THE MUTEX IS LOCKED, SYSTEM POOL CAN NOT 
; ALTHOUGH P1 POOL CAN BE ALLOCATED.  THEREFORE, THE NEW LOGICAL NAME
; TABLE ENTRY IS ASSUMED TO BE SHAREABLE, AND IF THE LOGICAL NAME
; TABLE WHICH TO TO CONTAIN THE NEW ENTRY IS FOUND TO RESIDE IN
; SYSTEM POOL, THEN THE SYSTEM POOL ALLOCATED FOR THE NEW ENTRY IS
; DEALLOCATED, AND PROCESS-PRIVATE POOL IS ALLOCATED IN ITS PLACE.
;

	MULL3	#LNMX$T_XLATION,(SP),R1	;LNMXS OVERHEAD +
	ADDL2	(SP)+,R1		;TRANSLATION STRING COUNT FIELDS +
	ADDL2	(SP)+,R1		;TRANSLATION STRINGS SIZES +
	ADDL2	(R10),R1		;LOGICAL NAME SIZE +
	ADDL2	#<-			;LOGICAL NAME COUNT FIELD +
		LNMB$T_NAME+1+ -	;LNMB OVERHEAD +
		1 -			;TRAILER BYTE =
		>,R1			;SIZE OF SYSTEM POOL TO ALLOCATE

	JSB	G^EXE$ALOPAGED		;ALLOCATE THE LOGICAL NAME TABLE ENTRY
	BLBS	R0,2040$		;BRANCH IF SUFFICIENT MEMORY
	BRW	9020$			;OTHERWISE RETURN ERROR
2040$:	MOVW	R1,LNMB$W_SIZE(R2)	;SAVE NEW BLOCK SIZE WITHIN THE BLOCK

;
; WRITE LOCK THE LOGICAL NAME MUTEX AND THEN POSITION TO THE LOGICAL NAME 
; TABLE THAT IS TO CONTAIN THE NEW LOGICAL NAME TABLE ENTRY. DEALLOCATE THE NEW 
; LNMB  IF UNABLE TO POSITION TO ANY TABLE ENTRY.
;

	PUSHR	#^M<R2,R4>		;SAVE ADDRESS OF PCB AND NEW LNMB
	BSBW	LNM$LOCKW		;LOCK TABLES FOR WRITING
	MOVL	R5,R1			;ACCESS MODE
	MOVQ	(R9),R2			;TABLE NAME DESCRIPTOR
	BSBW	LNM$FIRSTTAB		;SEARCH FOR SPECIFIED TABLE
	POPL	R4			;RESTORE ADDRESS OF NEW LNMB
	PUSHL	R0			;SAVE RETURN STATUS
	BLBS	R0,2050$		;BRANCH ON FAILURE
	BRW	4020$

;
; IF THE NEW LOGICAL NAME TABLE ENTRY WILL BE SHAREABLE BECAUSE THE LOGICAL 
; NAME TABLE WHICH WILL CONTAIN THE NEW ENTRY HAS BEEN FOUND TO BE, THEN MAKE 
; SURE THE NEW LOGICAL NAME TABLE ENTRY WILL NOT BE MARKED AS CONFINED AND
; MAKE SURE THE CALLER HAS WRITE ACCESS TO THE CONTAINING TABLE.

2050$:	BBC	#LNMTH$V_SHAREABLE,-	;BRANCH IF THE CONTAINING TABLE ENTRY 
		LNMTH$B_FLAGS(R1),2070$	;IS IN PROCESS-PRIVATE SPACE 
	BICL2	#LNM$M_CONFINE,R7	;SHAREABLE NAMES CAN'T BE CONFINED

	MOVZBL	#WRITE_ACCESS,R2	;CODE FOR ACCESS CHECK
	PUSHL	R4			;SAVE LNMB PTR
	MOVL	8(SP),R4		;RESTORE PCB
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	MOVL	(SP)+,R4		;RESTORE LNMB
	BLBS	R0,2090$		;OK
	MOVL	R0,(SP)			;SAVE STATUS
	BRW	4020$			;AND EXIT

;
; IF THE LOGICAL NAME TABLE THAT IS TO CONTAIN THE NEW LOGICAL NAME TABLE ENTRY 
; IS DISCOVERED TO EXIST IN PROCESS-PRIVATE SPACE, THEN THIS IS ALSO WHERE THE  
; NEW LOGICAL NAME ENTRY SHOULD GO.  DEALLOCATE THE SYSTEM SPACE LNMB, AND 
; ALLOCATE THE SAME SIZE BLOCK FROM P1 SPACE. 
;

2070$:	PUSHL	R1			;SAVE ADDRES OF CONTAINING TABLE HEADER
	MOVZWL	LNMB$W_SIZE(R4),-(SP)	;SAVE SIZE OF LNMB
	MOVL	R4,R0			;ADDRESS OF SYSTEM SPACE LNMB
	BSBW	LNM$DELBLK		;DEALLOCATE SYSTEM SPACE LNMB

	POPL	R1			;SIZE OF STORAGE TO ALLOCATE
	JSB	G^EXE$ALOP1PROC		;ALLOCATE NEW LNMB FROM P1 SPACE
	BLBS	R0,2080$		;BRANCH IF SUCCESSFUL
	MOVZWL	#SS$_INSFMEM,4(SP)	;OTHERWISE RETURN INSUFFICIENT MEMORY
	ADDL2	#4,SP			;THROW AWAY TABLE HEADER ADDRESS
	BRW	4030$			;RETURN ERROR AFTER RELEASING MUTEX

2080$:	MOVL	R2,R4			;ADDRESS OF NEW LNMB
	MOVW	R1,LNMB$W_SIZE(R4)	;SAVE NEW BLOCKS SIZE WITHIN BLOCK
	POPL	R1			;ADDRESS OF CONTAINING TABLE HEADER
	MOVL	LNMTH$L_NAME(R1),R2	;ADDRESS OF TABLE'S LNMB
	BBC	#LNMB$V_CONFINE,-	;IS THE ENTRY MARKED CONFINE?
		LNMB$B_FLAGS(R2),2090$	;BRANCH IF NOT
	BBCS	#LNM$V_CONFINE,R7,2090$	;MAKE SURE NEW ENTRY IS IF SO

;
; MAKE SURE THAT THE QUOTA HOLDER OF THE LOGICAL NAME TABLE WHICH IS TO CONTAIN 
; THE NEW LOGICAL NAME TABLE ENTRY HAS SUFFICIENT QUOTA FOR THE CREATION OF 
; THIS NEW LOGICAL NAME TABLE ENTRY.
;

2090$:	MOVL	LNMTH$L_QTABLE(R1),R2	;RETRIEVE QUOTA HOLDER'S ADDRESS
	MOVZWL	LNMB$W_SIZE(R4),R0	;SIZE OF QUOTA TO BE WITHDRAWN 

	CMPL	R0,LNMTH$L_BYTES(R2)	;IS THEIR SUFFICIENT QUOTA?
	BLEQU	3000$			;YES - THEN CONTINUE
	MOVZWL	#SS$_EXLNMQUOTA,(SP)	;NO  - THEN DEALLOCATE LNMB AND RETURN
	BRW	4020$			;      EXCEEDED QUOTA ERROR

;
; BUILD THE LOGICAL NAME TABLE ENTRY. REGISTER USAGE IS AS FOLLOWS:
;
;	R1  = ADDRESS OF THE LOGICAL NAME TABLE'S TABLE HEADER.
;	R4  = ADDRESS OF LOGICAL NAME BLOCK FOR NEW LOGICAL NAME TABLE ENTRY.
;	R5  = ACCESS MODE.
;	R7  = ATTRIBUTE BITS.
;	R9  = ADDRESS OF PROBED AND COPIED TABLE NAME DESCRIPTOR.
;	R10 = ADDRESS OF PROBED AND COPIED LOGICAL NAME DESCRIPTOR.
;	R11 = ADDRESS OF ITEM LIST.
;

3000$:	MOVAB	LNMB$B_TYPE(R4),R0	;POSITION TO BLOCK TYPE
	MOVB	#DYN$C_LNM,(R0)+	;SET DATA STRUCTURE TYPE
	MOVB	R5,(R0)+		;SET OWNER ACCESS MODE
	MOVL	R1,(R0)+		;ADDRESS OF CONTAINING TABLE HEADER
	MOVB	R7,(R0)+		;STORE NAME ATTRIBUTES
	MOVB	(R10),(R0)+		;STORE LENGTH OF NAME
	PUSHL	R4			;SAVE LNMB ADDRESS ON STACK
	BBS	#LNMTH$V_DIRECTORY,-	;BRANCH IF THIS LOGICAL NAME TO BE 
		LNMTH$B_FLAGS(R1),3005$	;CONTAINED WITHIN A DIRECTORY HEADER
	MOVC3	(R10),@4(R10),(R0)	;MOVE LOGICAL NAME INTO LNMB NAME FIELD
	BRB	3010$			;JOIN COMMON CODE

3005$:	CMPW	(R10),#LNM$C_TABNAMLEN	;SIZE EXCEED MAX FOR NAME IN DIRECTORY?
	BLEQU	3009$			;CONTINUE IF IT DOESNT
3007$:	POPL	R4			;OTHERWISE RESTORE LNMB ADDRESS
	MOVZWL	#SS$_IVLOGNAM,(SP)	;SET ERROR CODE
	BRW	4020$			;GO RETURN ERROR

3009$:	MOVTUC	(R10),@4(R10),#0,-	;CHECK FOR PROPER LOGICAL NAME SYNTAX 
		EXE$LNM_SYNTAX_DAT,-	;AND AT THE SAME TIME MOVE THE LOGICAL 
		(R10),(R0)		;NAME INTO THE LNMB NAME FIELD
	BVS	3007$			;GO RETURN ERROR IF IMPROPER SYNTAX
	MOVL	R5,R3			;ELSE SHIFT LNMX ADDR INTO PROPER REG
3010$:	POPL	R4			;RESTORE LNMB ADDRESS FROM STACK

;
; FILL IN THE LNMX PORTION OF THE LOGICAL NAME BLOCK FOR THE NEW LOGICAL NAME 
; TABLE ENTRY.  THIS INVOLVES PROCESSING THE ITEM LIST FOR A SECOND TIME SO 
; THAT THE LOGICAL NAME TRANSLATION BLOCKS MAYBE CONSTRUCTED, AND ANY OUTPUT 
; INFORMATION RETURNED. 
;

	TSTL	R11			;WAS AN ITEM LIST DEFINED?
	BNEQ	3030$			;YES - GO PROCESS IT
3020$:	BRW	3950$			;NO  - SKIP ITEM LIST PROCESSING

3030$:	CLRL	R6			;0 IS THE DEFAULT INDEX
	CLRL	R8			;NO ATTRIBUTES DEFINED AS YET
3035$:	IFNORD	#4,(R11),3060$		;CHECK IF FIRST LONGWORD READABLE
3040$:
	MOVZWL	2(R11),R2		;GET ITEM TYPE
	BEQL	3020$			;DONE IF ITEM TYPE IS ZERO
	IFNORD	#12,4(R11),3060$		;CHECK REST OF THIS DESCRIPTOR 
					;PLUS FIRST LONGWORD OF NEXT ONE

        CASE	R2,<-			;HANDLE EACH ITEM TYPE SEPARATELY
		     3200$, -		;INDEX ITEM
		     3300$, -		;STRING ITEM
		     3200$, -		;ATTRIBUTES ITEM
		     3400$, -		;TABLE ITEM
		>,W,#1
	CMPW	#LNM$_LNMB_ADDR, R2	;TEST FOR SPECIAL ITEM
	BEQL	3100$	
	CMPW	#LNM$_CHAIN,R2		;TEST FOR CHAINED ITEM LIST
	BEQL	3070$
3050$:	BRW	3930$			;ILLEGAL ITEM
3060$:	BRW	3920$			;REPORT ACCESS VIOLATION

;
; POSITION TO THE NEXT CHAIN IN THE CHAINED ITEM LIST.
;

3070$:	MOVL	4(R11),R11		;GET POINTER
	BEQL	3020$			;LAST ITEM
	BRB	3035$			;GO PROCESS IT

;
; LOGICAL NAME BLOCK ADDRESS
;
; TEST IF THE LOGICAL NAME BLOCK ADDRESS CAN BE WRITTEN IN THE
; REQUESTED PLACE.  ( CURRENT USE IS TO LINK A LOGICAL NAME BLOCK
; WITH MTL OR MAILBOX UCB )
;

3100$:	CMPW	#4,(R11)		;IS THE ITEM A LONGWORD
	BNEQ	3050$			;ERROR IF NOT
	MOVL	4(R11),R0		;RETRIEVE ITEM BUFFER ADDRESS
	IFNOWRT #4,(R0),3060$		;ACCVIO IF ITEM BUFFER NOT WRITEABLE
	MOVL	R4,(R0)			;MOVE THE ADDRESS OF LNM TO BUFFER
	BRW	3910$			;GO POSITION TO NEXT ITEM

;
; INDEX OR ATTRIBUTES ITEM.
;
; VALIDATE THE ITEM.  SAVE THE INDEX OR ATTRIBUTES FOR APPLICATION TO
; THE NEXT  TRANSLATION BLOCK THAT IS TO BE CREATED.
;

3200$:	CMPW	#4,(R11)		;IS ITEM BUFFER AT LEAST A LONGWORD?
	BGTRU	3050$			;ERROR IF NOT
	MOVL	4(R11),R0		;RETRIEVE ITEM BUFFER ADDRESS
	IFNORD	(R11),(R0),3060$	;ACCVIO IF ITEM BUFFER NOT READABLE
	MOVL	(R0),R0			;PICK UP THE LONGWORD

	CMPW	#LNM$_INDEX,R2		;IS IT AN INDEX ITEM?
	BEQL	3210$			;YES - BRANCH AND VERIFY INDEX ITEM 
	BITL	#^C< -			;TEST FOR INVALID ATTRIBUTES
		LNM$M_CONCEALED! -	;TRANSLATION IS CONCEALED
		LNM$M_TERMINAL -	;TRANSLATION IS TERMINAL
		>,R0
	BNEQ	3050$			;INVALID ATTRIBUTES ITEM
	ROTL	#-8,R0,R8		;SAVE ATTRIBUTES FOR LNMX CREATION
	BRW	3910$			;GO POSITION TO NEXT ITEM

3210$:	BITL	#^C127,R0		;IS INDEX BETWEEN 0 AND 127?
	BEQL	3220$			;YES - NO PRIVILEGE NEEDED

;
; THIS IS HERE SO THAT MTL OR MAILBOX UCB CAN HAVE ITS ADDRESS
; STORED IN THE LOGICAL NAME BLOCK.
;


	MOVPSL	R2			;GET THE PSL
	BITL	#PSL$M_PRVMOD,R2	;TEST IF PREVIOUS MODE WAS KERNEL
	BNEQ	3050$			;NO - BAD INDEX VALUE
	CMPL	#LNMX$C_BACKPTR,R0	;CORRECT INDEX
	BNEQ	3050$			;NO - BAD INDEX VALUE
        BRB	3225$
3220$:	CMPL	R0,R6			;IS INDEX LESS THAN LAST ONE SEEN?
	BLSS	3050$			;YES  - INVALID INDEX ITEM
3225$:	MOVL	R0,R6			;SAVE INDEX FOR LNMX CREATION
	BRW	3910$			;GO POSITION TO NEXT ITEM

;
; STRING ITEM.
;
; VALIDATE THE ITEM, INCLUDING THAT THE STRING SPECIFIED IS A VALID EQUIVALENCE  
; STRING.  VERIFY THAT THE CREATION OF THIS TRANSLATION BLOCK WILL NOT EXCEED 
; THE AMOUNT OF SPACE ALLOCATED.  FILL IN THE NEXT TRANSLATION BLOCK UTILIZING 
; THE  STRING SPECIFIED AS THE TRANSLATION STRING AS WELL AS THE CURRENT INDEX 
; AND  ATTRIBUTES SETTINGS. INCREMENT THE CURRENT INDEX.
;

3300$:	MOVAQ	(R11),R0		;ADDRESS OF STRING ITEM DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE TRANSLATION STRING
	BLBC	R0,3410$		;BRANCH IF CAN'T READ OR NOT PRESENT

	SUBL3	R4,R3,R0		;NUMBER OF BYTES CURRENTLY IN USE
	ADDL2	#LNMX$T_XLATION+2,R0	;ADD OVERHEAD FOR CURRENT TRANSLATION
	ADDL2	R1,R0			;ADD IN SIZE OF CURRENT TRANSLATION
	CMPW	R0,LNMB$W_SIZE(R4)	;EXCEED LOGICAL NAME BLOCK SIZE?
	BGTRU	3930$			;YES - RETURN AN ERROR

	MOVB	R8,(R3)+		;CURRENT ATTRIBUTES BECOME LNMX FLAGS
	MOVB	R6,(R3)+		;CURRENT INDEX LEVEL BECOMES LNMX LEVEL
	CLRW	(R3)+			;INITIALIZE HASH CODE LOCATION 
	INCL	R6			;INCREMENT INDEX LEVEL BY 1
	MOVB	R1,(R3)+		;STORE SIZE OF TRANSLATION STRING
	PUSHL	R4			;SAVE NEEDED REGISTERS OVER MOVC3
	MOVC3	R1,(R2),(R3)		;MOVE TRANSLATION STRING INTO LNMX
	POPL	R4			;RESTORE REGISTERS
	BRB	3910$			;GO POSITION TO NEXT ITEM

;
; TABLE ITEM.
;
; VALIDATE THE ITEM.  STORE THE NAME OF THE LOGICAL NAME TABLE WHICH IS TO  
; CONTAIN THIS NEW LOGICAL NAME TABLE ENTRY IN THE ITEM BUFFER PROVIDED, AND  
; THE SIZE OF THE NAME STORED IN THE ITEM SIZE BUFFER, IF PROVIDED.
;

3400$:	MOVQ	(R11),-(SP)		;SAVE DESCRIPTOR OF TABLE ITEM BUFFER
	MOVZWL	(SP),R1			;SIZE OF TABLE ITEM BUFFER
	MOVL	4(SP),R0		;ADDRESS OF TABLE ITEM BUFFER
	PUSHL	R3			;SAVE CURRENT LNMX POSITION
	CLRL	R3			;ACCESS MODE
	JSB	G^EXE$PROBEW		;PROBE TABLE ITEM BUFFER FOR WRITTING
	POPL	R3			;RESTORE CURRENT LNMX POSITION
	MOVQ	(SP)+,R1		;RESTORE TABLE ITEM BUFFER DESCRIPTOR
3410$:	BLBC	R0,3940$		;RETURN IF NOT WRITEABLE

	MOVL	LNMB$L_TABLE(R4),R5	;ADDRESS OF CONTAINING TABLE HEADER
	MOVL	LNMTH$L_NAME(R5),R5	;ADDRESS OF CONTAINING LNMB
	MOVAB	LNMB$T_NAME(R5),R5	;ADDRESS OF COUNT FIELD
	MOVZBL	(R5)+,R0		;SIZE OF CONTAINING TABLE'S NAME

	CMPW	R0,R1			;ENOUGH ROOM IN BUFFER FOR NAME?
	BLEQ	3420$			;BRANCH IF SUFFICIENT ROOM
	MOVZWL	#SS$_BUFFEROVF,(SP)	;CHANGE RETURN STATUS
	MOVZWL	R1,R0			;RETURN AS MUCH AS POSSIBLE

3420$:	MOVL	8(R11),R1		;WAS A RETURN LENGTH BUFFER SPECIFIED
	BEQL	3430$			;NO  - DON'T RETURN LENGTH
	IFNOWRT	#2,(R1),3920$		;YES - PROBE RETURN LENGTH BUFFER
	MOVW	R0,(R1)			;      AND RETURN LENGTH

3430$:	MOVQ	R3,-(SP)		;SAVE REGISTERS OVER MOVC3
	MOVC3	R0,(R5),(R2)		;RETURN CONTAINING TABLE NAME STRING
	MOVQ	(SP)+,R3		;RESTORE SAVED REGISTERS 

3910$:	ADDL2	#12,R11			;POSITION TO NEXT ITEM
	BRW	3040$			;AND CONTINUE ITEM LIST VERIFICATION

3920$:	MOVZWL	#SS$_ACCVIO,(SP)	;ACCESS VIOLATION
	BRB	4020$			;DEALLOCATE NEW LNMB AND RETURN ERROR

3930$:	MOVZWL	#SS$_BADPARAM,(SP)	;BAD PARAMETER SEEN
	BRB	4020$			;DEALLOCATE NEW LNMB AND RETURN ERROR

3940$:	MOVL	R0,(SP)			;SAVE RETURN STATUS
	BRB	4020$			;DEALLOCATE NEW LNMB AND RETURN ERROR

;
; FILL IN THE LAST LNMX PORTION OF THE LOGICAL NAME BLOCK FOR THE NEW LOGICAL  
; NAME TABLE ENTRY. THE LAST TRANSLATION BLOCK CONSISTS SOLELY OF A FLAGS FIELD, 
; AND IS MARKED WITHIN THIS FLAGS FIELD AS THE LAST LNMX. 
;

3950$:	MOVB	#LNMX$M_XEND,(R3)+	;STORE END FLAG

; 
; AT THIS POINT ALL CHECKS HAVE BEEN MADE, AND THE TABLE STRUCTURES MAY NOW
; BE MODIFIED FOR THE FIRST TIME.  INSERT THE NEW LOGICAL NAME TABLE ENTRY.
;
; THIS INSERTION MAY TAKE ONE OF TWO FORMS:
;
; 1.) THE LOGICAL NAME TABLE ENTRY MAYBE INSERTED AS A NEW LOGICAL NAME. THE
;     FOLLOWING CONDITIONS MUST HOLD TRUE.
;
;	A.) THERE IS NO LOGICAL NAME TABLE ENTRY WITH THE SAME NAME AND ACCESS
;	    MODE WITHIN THE SAME CONTAINING LOGICAL NAME TABLE.
;
;	B.) THERE IS NO LOGICAL NAME TABLE ENTRY WITH THE SAME NAME AND AN
;	    INNER ACCESS MODE WITHIN THE SAME CONTAINING LOGICAL NAME TABLE 
;	    THAT DOES NOT ALLOW ALIASES.
;
; 2.) THE ENTRY MAYBE INSERTED SUPERSEDING AN EXISTING ENTRY WITHIN THE SAME
;     CONTAINING LOGICAL NAME TABLE WITH THE SAME NAME AND ACCESS MODE. THE
;     OLD LOGICAL NAME TABLE ENTRY IS DELETED.  
;
; IF EITHER CASE OCCURS, AND THE NEW LOGICAL NAME TABLE ENTRY DOES NOT ALLOW 
; ALIASES, THEN ANY LOGICAL NAME TABLE ENTRIES IN THE SAME CONTAINING LOGICAL
; NAME TABLE WITH THE SAME NAME BUT AT AN OUTER ACCESS MODE ARE DELETED.
; 

	MOVL	R4,R1			;ADDRES OF NEW LOGICAL NAME TABLE ENTRY
	MOVL	R7,R2			;ATTRIBUTES
	BSBW	LNM$INSLOGTAB		;INSERT NEW LOGICAL NAME TABLE ENTRY
	CMPW	#SS$_SUPERSEDE,R0	;INSERTION SUCCEED WITH SUPERSEDE?
	BNEQ	4010$			;BRANCH IF NO
	CMPW	#SS$_BUFFEROVF,(SP)	;BUFFER OVERFLOW SEEN?
	BEQL	4030$			;YES - THEN RETURN THAT STATUS
	MOVL	R0,(SP)			;OTHERWISE RETURN SUPERSEDE SUCCESS
4010$:	BLBS	R0,4030$		;BRANCH ON SUCCESS
	MOVL	R0,(SP)			;OTHRWISE SAVE ERROR STATUS

4020$:	MOVL	R4,R0			;LOGICAL NAME BLOCK FOR NEW TABLE ENTRY
	BSBW	LNM$DELBLK		;DELETE BLOCK CONTAINING NEW TABLE ENTRY

4030$:	MOVL	4(SP),R4		;RETRIEVE PCB ADDRESS
	BSBW	LNM$UNLOCK		;UNLOCK TABLES
	POPL	R0			;RESTORE STATUS
	RET				;RETURN TO CALLER

	.DISABLE	LSB

;	.PAGE

	.SBTTL	EXE$DELLNM	- DELETE LOGICAL NAME
;+
; EXE$DELLNM - DELETE LOGICAL NAME
;
; THIS SERVICE PROVIDES THE CAPABILITY TO:
;
;	1. DELETE A SPECIFIED LOGICAL NAME.
;	2. DELETE A SPECIFIED LOGICAL NAME TABLE.
;	3. DELETE ALL THE LOGICAL NAME TABLE ENTRIES CONTAINED WITHIN A
;	   SPECIFIED LOGICAL NAME TABLE.
;
; INPUTS:
;
;	DNACMODE(AP) 	= ADDRESS OF ACCESS MODE OF LOGICAL NAMES(S) TO BE DELETED.
;	DNLOGNAM(AP) 	= ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
;	DNTABNAM(AP) 	= ADDRESS OF TABLE NAME STRING DESCRIPTOR.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO DELETE LOGICAL NAME(S).
;
;		R0 = SS$_ACCVIO	- TABLE NAME DESCRIPTOR, TABLE NAME STRING 
;			LOGICAL NAME DESCRIPTOR, LOGICAL NAME STRING, CANNOT
;			BE READ BY CALLING ACCESS MODE. 
;
;		R0 = SS$_BADPARAM - INVALID ACCESS MODE SPECIFIED. NO TABLE
;			NAME DESCRIPTOR SPECIFIED.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			LOGICAL OR TABLE NAME STRING SPECIFIED.
;
;		R0 = SS$_IVLOGTAB - INVALID TABLE NAME SPECIFIED. 
;
;		R0 = SS$_NOLOGNAM - LOGICAL NAME TABLE OR LOGICAL NAME 
;			SPECIFIED DOES NOT EXIST.
;
;		R0 = SS$_NOLOGTAB - LOGICAL NAME TABLE SPECIFIED DOES NOT EXIST.
;
;		R0 = SS$_NOPRIV - PROCESS DOES NOT HAVE PRIVILEGE TO DELETE
;			THE SPECIFIED LOGICAL NAME(S).
;
;		R0 = SS$_TOOMANYLNM - TOO MANY LEVELS OF RECURSION IN SEARCH
;			FOR LOGICAL NAME TABLE OR LOGICAL NAME.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION. LOGICAL NAME(S) HAVE BEEN
;			DELETED.
;
; SIDE EFFECTS:
;
;	THIS ROUTINE EXITS AT IPL 2.
;
;-

	.PSECT	Y$EXEPAGED
	.ENTRY	EXE$DELLNM,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXEDELLNM

	.PSECT	YF$$LNM
	.ENABLE	LSB
900$:	MOVZWL	#SS$_ACCVIO,R0		;ACCESS VIOLATION
	RET
910$:	MOVZWL	#SS$_BADPARAM,R0	;BAD SYSTEM SERVICE PARAMETER
930$:	RET

;
; VALIDATE AND COPY PARAMETERS AS NECESSARY. REGISTER ASSIGNMENT FOR THE 
; PARAMETERS ARE AS FOLLOWS:
;
;	R5  = ACCESS MODE.
;	R9  = ADDRESS OF PROBED AND COPIED TABLE NAME DESCRIPTOR.
;	R10 = ADDRESS OF PROBED AND COPIED LOGICAL NAME DESCRIPTOR.
;

EXEDELLNM:

	MOVL	DNLOGNAM(AP),R10	;ADDRESS OF LOGICAL NAME DESCRIPTOR
	BEQL	10$			;BRANCH IF NOT PRESENT
	IFNORD	#8,(R10),900$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R10),R0		;ADDRESS OF DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE LOGICAL NAME STRING
	BLBC	R0,930$			;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE LOGICAL NAME DESCRIPTOR
	MOVL	SP,R10			;ADDRESS OF LOGICAL NAME DESCRIPTOR
10$:
	MOVL	DNTABNAM(AP),R9		;ADDRESS OF TABLE NAME DESCRIPTOR 
	BEQL	910$			;ERROR IF NOT PRESENT
	IFNORD	#8,(R9),900$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R9),R0			;SET UP CALL
	BSBW	LNM$PROBER		;PROBE TABLE NAME STRING
	BLBC	R0,930$			;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE TABLE NAME DESCRIPTOR
	MOVL	SP,R9			;ADDRESS OF TABLE NAME DESCRIPTOR

	MOVL	DNACMODE(AP),R0		;GET SPECIFIED ACCESS MODE
	BEQL	20$			;BRANCH IF NOT PRESENT
	IFNORD	#1,(R0),900$		;CHECK ACCESS TO VALUE
	MOVZBL	(R0),R0			;GET VALUE	
	CMPL	#PSL$C_USER,R0		;CHECK FOR VALID ACCESS MODE
	BLSSU	910$			;INVALID ACCESS MODE

;
; IF THE ACCESS MODE OF THE LOGICAL NAME TABLE ENTRY(S) TO BE DELETED WAS
; EXPLICITELY SPECIFIED AND THE CALLER HAS THE SYSNAM PRIVILEGE, THEN THE 
; SPECIFIED ACCESS MODE IS USED TO QUALIFY THE LOGICAL NAME TABLE ENTRY(S) 
; DELETION. OTHERWISE, THE ACCESS MODE OF THE CALLER IS  MAXIMIZED WITH ANY 
; EXPLICTELY SPECIFIED ACCESS MODE AND USED TO QUALIFY THE LOGICAL NAME TABLE 
; ENTRY(S) DELETION. 
;

	IFPRIV	SYSNAM,30$		;CALLER HAS SYSNAM PRIVILEGE
20$:	JSB	G^EXE$MAXACMODE		;MAXIMIZED WITH MODE OF CALLER TO
30$:	MOVL	R0,R5			;DETERMINE ACCESS MODE OF TABLE ENTRY(S)

;
; RAISE IPL TO AST DELIVERY LEVEL SO THAT THERE ARE NO INTERRUPTIONS WHILE
; THE DELETION OF THE LOGICAL NAME TABLE ENTRY(S) IS BEING CARRIED OUT, AND
; LOCK THE LOGICAL NAME MUTEX FOR WRITING.
;

	SETIPL	S^#IPL$_ASTDEL		;RAISE TO AST DELIVERY LEVEL
	BSBW	LNM$LOCKW		;LOCK TABLES FOR WRITING

;
; IF A LOGICAL NAME WAS SPECIFIED, THEN IT REPRESENTS THE LOGICAL NAME TABLE 
; ENTRY WITH THE SPECIFIED ACCESS MODE WHICH IS TO BE DELETED FROM THE LOGICAL 
; NAME TABLE WITH THE SPECIFIED LOGICAL NAME TABLE NAME. FIND THE FIRST SUCH
; LOGICAL NAME TABLE ENTRY AND DELETE IT. IF THE ACCESS MODE REQUESTED IS OTHER 
; THAN USER, THAN ALL OUTER ACCESS MODE ALIASES IN THIS TABLE ARE ALSO DELETED.
;
; NOTE THAT IF THE FIRST SUCH LOGICAL NAME TABLE ENTRY IS THAT OF A LOGICAL 
; NAME TABLE, THEN ALL LOGICAL NAMES CONTAINED WITHIN THE TABLE TOGETHER WITH 
; ALL ITS SUBTABLES AND THE LOGICAL NAMES CONTAINED WITHIN THEM ARE DELETED.
;

	TSTL	R10			;IS A SPECIFIC ENTRY TO BE DELETED?
	BEQL	60$			;BRANCH IF SUPPOSED TO DELETE THEM ALL

	MOVQ	(R10),R0		;LOGICAL NAME DESCRIPTOR
	MOVQ	(R9),R2			;TABLE NAME DESCRIPTOR
	BSBW	LNM$SEARCHLOG		;SEARCH FOR JUST SUCH A LOGICAL NAME 
	BLBC	R0,80$			;EXIT IF NO NAME FOUND

	CMPB	R5,LNMB$B_ACMODE(R1)	;DO THE ACCESS MODES MATCH
	BEQLU	40$			;IF SO THEN HAVE FOUND ENTRY TO DELETE
	MOVZWL	#SS$_NOLOGNAM,R0	;OTHERWISE GO RETURN ERROR
	BRB	80$

;
; DETERMINE WHETHER THE CALLER CAN DELETE THE LOGICAL NAME TABLE ENTRY, AND
; THEN DELETE IS IF SUCH ACCESS IS ALLOWED. THE ACCESS REQUIREMENTS FOR DELETION
; ARE AS FOLLOWS:
;
; LOGICAL NAME:	      THE CALLER NEEDS WRITE ACCESS TO THE CONTAINING LOGICAL 
;		      NAME TABLE.
;
; LOGICAL NAME TABLE: THE CALLER NEEDS EITHER WRITE ACCESS TO THE CONTAINING
;		      LOGICAL NAME TABLE (THE SYSTEM OR PROCESS DIRECTORY 
;		      TABLE), OR DELETE ACCESS TO THE LOGICAL NAME TABLE
;		      ITSELF.
;
; NOTE THAT IF THE LOGICAL NAME TABLE ENTRY IS PROCESS-PRIVATE THEN NO 
; PROTECTION CHECKING IS PERFORMED, AND THE CALLER CAN ALWAYS DELETE THE ENTRY.
;

40$:	BBC	#31,R1,50$		;SKIP CHECK IF PROCESS-PRIVATE ENTRY
	MOVZBL	#WRITE_ACCESS,R2	;CODE FOR ACCESS CHECK
	PUSHL	R1			;SAVE LNMB ADDRESS
	MOVL	LNMB$L_TABLE(R1),R1	;GET TABLE HEADER ADDRESS
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	POPL	R1			;RESTORE LNMB
	BLBS	R0,50$			;DELETE THE ENTRY ON SUCCESS
	BBC	#LNMB$V_TABLE,-		;RETURN AN ERROR ON FAILURE IF THE
		LNMB$B_FLAGS(R1),80$	;ENTRY TO BE DELETED IS NOT A TABLE
	
	MOVZBL	#DELETE_ACCESS,R2	;CODE FOR ACCESS CHECK
	PUSHL	R1			;SAVE LNMB ADDRESS
	MOVZBL	LNMB$T_NAME(R1),R0	;RETRIEVE SIZE OF NAME STRING
	MOVAB	LNMB$T_NAME+1(R1)[R0],R1;POSITION TO LNMX
	MOVAB	LNMX$T_XLATION+1(R1),R1	;POSITION TO TABLE HEADER
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	POPL	R1			;RESTORE LNMB
	BLBC	R0,80$			;QUIT ON FAILURE

50$:	BSBW	LNM$DELETE_LNMB		;DELETE ALL APPROPRIATE LOGICAL NAMES
	BRB	80$			;AND RETURN STATUS OF DELETION

;
; IF NO LOGICAL NAME WAS SPECIFIED, THEN ALL THE LOGICAL NAME TABLE ENTRIES
; CONTAINED WITHIN THE SPECIFIED LOGICAL NAME TABLE AND POSSESSING AN ACCESS
; MODE EQUAL TO OR GREATER THEN THE DESIGNATED ACCESS MODE ARE TO BE DELETED. 
; POSITION TO THE SPECIFIED LOGICAL NAME TABLE, AND PERFORM THE ACTUAL DELETION 
; OF THE NAMES CONTAINED WITHIN THE TABLE. 
;
; TWO POSSIBLE CASES EXIST:
;
; CASE 1: THE SPECIFIED LOGICAL NAME TABLE NAME IS THAT OF A LOGICAL NAME TABLE
;	  OTHER THAN THE SYSTEM/PROCESS DIRECTORY TABLE. IN THIS CASE ALL THE 
;	  LOGICAL NAMES, BUT NOT THE LOGICAL NAME TABLE SUB-STRUCTURE, THAT 
;	  POSSESS AN ACCESS MODE EQUAL TO OR GREATER THAN THE DESIGNATED ACCESS
;	  MODE ARE DELETED. THE LOGICAL NAME TABLE SUB-STRUCTURE IS NOT DELETED
;	  BECAUSE ALL LOGICAL NAME TABLES ARE CONTAINED WITHIN THE SYSTEM OR
;	  PROCESS DIRECTORY TABLES AND NOT WITHIN INDIVIDUAL LOGICAL NAME 
;	  TABLES.
;
; CASE 2: THE SPECIFIED LOGICAL NAME TABLE NAME IS THAT OF THE SYSTEM/PROCESS 
;	  DIRECTORY TABLE. IN THIS CASE ALL OF THE LOGICAL NAME TABLE ENTRIES
;	  (INCLUDING ALL LOGICAL NAME TABLES) CONTAINED WITHIN THE SPECIFIED 
;	  DIRECTORY TABLE AND POSSESSING AN ACCESS MODE EQUAL TO OR GREATER 
;	  THAN THE DESIGNATED ACCESS MODE ARE DELETED. 
;
; NOTE THAT IF THE LOGICAL NAME TABLE IS PROCESS-PRIVATE THEN NO PROTECTION 
; CHECKING IS PERFORMED, AND THE CALLER CAN ALWAYS DELETE THE ENTRY(S) IN THE
; TABLE.
;

60$:	MOVL	R5,R1			;ACCESS MODE
	MOVQ	(R9),R2			;TABLE NAME DESCRIPTOR
	BSBW	LNM$FIRSTTAB		;SEARCH FOR SPECIFIED LOGICAL NAME TABLE
	BLBC	R0,80$			;BRANCH ON FAILURE

;
; MAKE SURE THAT THE CALLER HAS WRITE ACCESS TO THE LOGICAL NAME TABLE BEFORE
; DELETING ALL THE ENTRIES THAT IT CONTAINS.
;

	BBC	#LNMTH$V_SHAREABLE,-	;IS THE TABLE PROCESS-PRIVATE?
		LNMTH$B_FLAGS(R1),70$	;IF SO THEN SKIP ACCESS CHECK
	MOVZBL	#WRITE_ACCESS,R2	;CODE FOR ACCESS CHECK
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	BLBC	R0,80$			;QUIT ON FAILURE

70$:	MOVL	R5,R2			;ACCESS MODE
	BSBW	LNM$DELETE_TAB		;DELETE ALL ENTIRES IN SPECIFIED TABLE

;
; UNLOCK THE LOGICAL NAME TABLE MUTEX AND RETURN STATUS TO CALLER.
;

80$:	PUSHL	R0			;SAVE RETURN CODE OVER UNLOCKING
	BSBW	LNM$UNLOCK		;UNLOCK TABLES
	POPL	R0			;RESTORE RETURN CODE
	RET				;RETURN TO CALLER

	.DISABLE	LSB

;	.PAGE

	.SBTTL	EXE$TRNLNM	- TRANSLATE LOGICAL NAME
;+
; EXE$TRNLNM - TRANSLATE LOGICAL NAME
;
; THIS SERVICE PROVIDES THE CAPABILITY TO LOOKUP A LOGICAL NAME IN THE SPECIFIED
; LOGICAL NAME TABLE, AND TO RETURN INFORMATION ABOUT IT IN THE CALLER SPECIFIED
; ITEM LIST.
;
; INPUTS:
;
;	TRATTR(AP)	= ADDRESS OF LOGICAL NAME TRANSLATION ATTRIBUTES.
;	TRTABNAM(AP)	= ADDRESS OF TABLE NAME STRING DESCRIPTOR.
;	TRLOGNAM(AP)	= ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
;	TRACMODE(AP)	= ADDRESS OF ACCESS MODE.
;	TRITMLST(AP)	= ADDRESS OF ITEM LIST.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO TRANSLATE LOGICAL NAME.
;
;		R0 = SS$_ACCVIO	- LOGICAL NAME DESCRIPTOR, LOGICAL NAME STRING, 
;			TABLE NAME DESCRIPTOR, TABLE NAME STRING, AN ITEM IN THE
;			ITEM LIST, AN INDEX ITEM BUFFER CANNOT BE READ BY 
;			CALLING ACCESS MODE. A TABLE ITEM BUFFER, A TABLE ITEM 
;			SIZE BUFFER, AN ATTRIBUTES ITEM BUFFER, AN ATTRIBUTES 
;			ITEM SIZE BUFFER, A STRING ITEM BUFFER, A STRING ITEM 
;			SIZE BUFFER, A LENGTH ITEM BUFFER, A LENGTH ITEM SIZE 
;			BUFFER, AN ACMODE ITEM BUFFER, AN ACMODE ITEM SIZE 
;			BUFFER CANNOT BE WRITTEN BY CALLING ACCESS MODE.
;
;		R0 = SS$_BADPARAM - INVALID ATTRIBUTE, ACCESS MODE, ITEM TYPE,
;			ITEM LENGTH, SPECIFIED. LOGICAL NAME DESCRIPTOR OR
;			TABLE NAME DESCRIPTOR NOT SPECIFIED.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			LOGICAL OR TABLE NAME STRING SPECIFIED.
;
;		R0 = SS$_IVLOGTAB - INVALID TABLE NAME SPECIFIED.
;
;		R0 = SS$_NOLOGNAM - LOGICAL TABLE NAME ENTRY SPECIFIED DOES NOT 
;			EXIST.
;
;		R0 = SS$_NOPRIV - PROCESS DOES NOT HAVE PRIVILEGE TO ACCESS
;			THE SPECIFIED LOGICAL NAME TABLE ENTRY.
;
;		R0 = SS$_TOOMANYLNM - TOO MANY LEVELS OF RECURSION IN SEARCH
;			FOR LOGICAL NAME TABLE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_BUFFEROVF - REQUEST SUCCESSFULLY COMPLETED. AN ITEM
;			BUFFER IS NOT LARGE ENOUGH TO HOLD REQUESTED DATA.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;
; SIDE EFFECTS:
;
;	THIS ROUTINE EXITS AT IPL 2.
;
;-
 
	.PSECT	Y$EXEPAGED
	.ENTRY	EXE$TRNLNM,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXETRNLNM

	.PSECT	YF$$LNM
	.ENABLE	LSB
900$:	MOVZWL	#SS$_ACCVIO,R0		;ACCESS VIOLATION
	RET
910$:	MOVZWL	#SS$_BADPARAM,R0	;BAD SYSTEM SERVICE PARAMETER
920$:	RET

EXETRNLNM:

;
; VALIDATE AND COPY PARAMETERS AS NECESSARY. REGISTER ASSIGNMENT FOR THE 
; PARAMETERS ARE AS FOLLOWS:
;
;	R5  = ACCESS MODE.
;	R7  = ATTRIBUTE BITS.
;	R9  = ADDRESS OF PROBED AND COPIED TABLE NAME DESCRIPTOR.
;	R10 = ADDRESS OF PROBED AND COPIED LOGICAL NAME DESCRIPTOR.
;	R11 = ADDRESS OF START OF THE ITEM LIST.
;
;---

	CLRL	-(SP)			;THIS WILL EVENTUALLY BE CHAIN COUNTER

	MOVL	TRATTR(AP),R7		;TRANSLATION ATTRIBUTES
	BEQL	10$			;BRANCH IF NOT PRESENT
	IFNORD	#4,(R7),900$		;CHECK ACCESS
	MOVL	(R7),R7			;GET VALUE
	BITL	#^C< -
		LNM$M_CASE_BLIND -	;CASE SENSITIVE VS. CASE INSENSITIVE
		>,R7
	BNEQ	910$			;INVALID TRANSLATION ATTRIBUTES 

10$:	MOVL	TRLOGNAM(AP),R10	;ADDRESS OF LOGICAL NAME DESCRIPTOR
	BEQL	910$			;ERROR IF NOT PRESENT
	IFNORD	#8,(R10),900$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R10),R0		;ADDRESS OF DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE LOGICAL NAME STRING
	BLBC	R0,920$			;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE LOGICAL NAME DESCRIPTOR
	MOVL	SP,R10			;ADDRESS OF LOGICAL NAME DESCRIPTOR

	MOVL	TRTABNAM(AP),R9		;ADDRESS OF TABLE NAME DESCRIPTOR 
	BEQL	910$			;ERROR IF NOT PRESENT
	IFNORD	#8,(R9),900$		;CHECK ACCESS TO DESCRIPTOR
	MOVAQ	(R9),R0			;ADDRESS OF DESCRIPTOR
	BSBW	LNM$PROBER		;PROBE TABLE NAME STRING
	BLBC	R0,920$			;BRANCH IF CAN'T READ OR NOT PRESENT
	MOVQ	R1,-(SP)		;SAVE TABLE NAME DESCRIPTOR
	MOVL	SP,R9			;ADDRESS OF TABLE NAME DESCRIPTOR

	MOVZBL	#PSL$C_USER,R5		;DEFAULT IS USER MODE(ALL ACCESS)
	MOVL	TRACMODE(AP),R0		;GET SPECIFIED ACCESS MODE
	BEQL	2000$			;BRANCH IF NOT PRESENT
	IFNORD	#1,(R0),900$		;CHECK ACCESS
	MOVZBL	(R0),R5			;DETERMINE ACCESS MODE OF LOGICAL NAME
	CMPL	#PSL$C_USER,R5		;INVALID ACCESS MODE?
	BLSSU	910$			;RETURN ERROR IF THIS IS THE CASE

;
; RAISE IPL TO AST DELIVERY LEVEL SO THAT THERE ARE NO INTERRUPTIONS WHILE THE 
; TRANSLATION OF THE LOGICAL NAME IS BEING CARRIED OUT, LOCK THE LOGICAL NAME 
; MUTEX FOR READING, AND THEN SEARCH FOR THE SPECIFIED LOGICAL NAME.
;

2000$:	SETIPL	S^#IPL$_ASTDEL		;RAISE TO AST DELIVERY LEVEL
	BSBW	LNM$LOCKR		;LOCK TABLES FOR READING
	PUSHL	R4			;SAVE PCB ADDRESS

	MOVQ	(R10),R0		;LOGICAL NAME DESCRIPTOR
	MOVQ	(R9),R2			;TABLE NAME DESCRIPTOR
	BBC	#LNM$V_CASE_BLIND,R7,2010$;CASE INSENSITIVE SEARCH?
	BBSS	#8,R5,2010$		;YES - SET CORRESPONDING BIT

2010$:	
	.IF NE CA$_MEASURE		;CHECK FOR MEASUREMENT ENABLED
	INCL	L^PMS$GL_LOGNAM		;IF YES COUNT CURRENT TRANSLATION
	.ENDC

	BSBW	LNM$SEARCHLOG		;SEARCH FOR JUST SUCH A LOGICAL NAME 
	PUSHL	R0			;SAVE THE SEARCH STATUS
	BLBC	R0,3020$		;BRANCH IF NO NAME FOUND

;
; CHECK THE CALLER'S ACCESS TO THE LOGICAL TABLE THAT HAS BEEN FOUND TO CONTAIN
; THE SPECIFIED LOGICAL NAME. NOTE THAT ACCESS CHECKING IS NOT REQUIRED IF THE
; LOGICAL NAME IS A PROCESS-PRIVATE LOGICAL NAME.
;

	MOVL	R1,R8			;ADDRESS OF LOGICAL NAME BLOCK
	BBC	#31,R1,3010$		;SKIP ACCESS CHECK IF PROCESS-PRIVATE
	MOVL	#READ_ACCESS,R2		;CODE FOR ACCESS CHECK
	MOVL	4(SP),R4		;RESTORE PCB ADDR
	MOVL	LNMB$L_TABLE(R8),R1	;ADDRESS OF TABLE HEADER
	BSBW	LNM$CHECK_PROT		;CHECK THE PROTECTION
	BLBS	R0,3010$		;CONTINUE IF OKAY
	MOVL	R0,(SP)			;SAVE ERROR STATUS
	BRB	3020$			;AND EXIT

;
; PROCESS THE ITEM LIST RETURNING WHAT INFORMATION THE CALLER WANTS INTO THE 
; SPECIFIED ITEM BUFFERS.
;
; VALID ITEMS ARE:
;	ACMODE		- ACCESS MODE OF LOGICAL NAME TABLE ENTRY.
;	ATTRIBUTES	- ATTRIBUTES OF LOGICAL NAME AND CURRENT TRANSLATION.
;	INDEX		- INDEX OF TRANSLATION (INPUT ITEM).
;	LENGTH		- LENGTH OF CURRENT TRANSLATION STRING.
;	MAX_INDEX	- MAXIMUM INDEX IN LOGICAL NAME TABLE ENTRY.
;	STRING		- TRANSLATION STRING.
;	TABLE		- LOGICAL NAME TABLE NAME STRING.
;	PARENT		- PARENT LOGICAL NAME TABLE NAME STRING.
;
;
; REGISTER USAGE IS AS FOLLOWS:
;
;	R6  = CURRENT TRANSLATION INDEX.
;	R7  = ADDRESS OF FIRST LOGICAL NAME TRANSLATION BLOCK
;	R8  = ADDRESS OF LOGICAL NAME TABLE ENTRY.
;	R9  = ADDRESS OF CURRENT LOGICAL NAME TRANSLATION BLOCK.
;	R11 = ADDRESS OF CURRENT ITEM IN ITEM LIST.
;

3010$:	MOVL	TRITMLST(AP),R11	;ADDRESS OF ITEM LIST
	BNEQ	3030$			;PROCESS ITEM LIST IF THERE IS ONE
3020$:	BRW	4010$			;BRANCH IF NONE

3030$:	MOVZBL	LNMB$T_NAME(R8),R0	;SIZE OF LOGICAL NAME STRING
	MOVAB	LNMB$T_NAME+1(R8)[R0],R9;ADDRESS OF FIRST TRANSLATION BLOCK
	MOVL	R9,R7			;SAVE THIS ADDRESS
	CLRL	R6			;DEFAULT INDEX IS 0
3035$:	BBS	#LNMX$V_XEND,-		;LAST TRANSLATION BLOCK?
		LNMX$B_FLAGS(R9),3038$	;YES - THEN POSITION TO GET ITEM
	TSTB	LNMX$B_INDEX(R9)	;POSITION TO (OR PAST) 0 LNMX?
	BGEQ	3038$			;YES - THEN POSITION TO GET ITEM
	MOVZBL	LNMX$T_XLATION(R9),R0	;SIZE OF TRANSLATION STRING
	MOVAB	LNMX$T_XLATION+1(R9)[R0],R9 ;POSITION TO NEXT TRANSLATION BLOCK
	BRB	3035$			;CONTINUE LOOKING FOR SPECIFIED LNMX
3038$:	IFNORD	#4,(R11),3060$		;CHECK IF FIRST LONGWORD READABLE
3040$:
	MOVZWL	2(R11),R2		;GET ITEM TYPE
	BEQL	3020$			;DONE IF ITEM TYPE IS ZERO
	IFNORD	#12,4(R11),3060$	;CHECK REST OF THIS DESCRIPTOR 
					;PLUS FIRST LONGWORD OF NEXT ONE

	CASE	R2,<-			;HANDLE EACH ITEM TYPE SEPARATELY
		     3100$, -		;INDEX ITEM
		     3200$, -		;STRING ITEM
		     3300$, -		;ATTRIBUTES ITEM
		     3400$, -		;TABLE ITEM
		     3500$, -		;LENGTH ITEM
		     3600$, -		;ACMODE ITEM
		     3700$, -		;MAX_INDEX ITEM
		     3800$, -		;PARENT ITEM
		>,W,#1
	CMPW	R2,#^XLNM$_CHAIN		;CHECK FOR CHAINED ITEM LIST
	BEQL	3070$
3050$:	BRW	3980$			;ILLEGAL ITEM
3060$:	BRW	3970$			;ACCVIO

;
; PROCESS A CHAINED ITEM LIST.
;

3070$:	INCL	-4(FP)			;UPDATE ITEM LIST CHAIN COUNTER
	CMPW	-4(FP),#1024
	BGTR	3050$			;TOO MANY - ASSUME LOOP
	MOVL	4(R11),R11		;GET POINTER
	BRB	3038$			;GO PROCESS IT

;
; INDEX ITEM.
;
; VALIDATE THE ITEM. POSITION TO THE TRANSLATION BLOCK WITH THE SAME
; OR A GREATER INDEX THEN THAT SPECIFIED BY THE ITEM.
;

3100$:	CMPW	#4,(R11)		;IS ITEM BUFFER AT LEAST A LONGWORD?
	BGTRU	3050$			;ERROR IF NOT
	MOVL	4(R11),R6		;PICK UP THE ITEM BUFFER ADDRESS
	IFNORD	(R11),(R6),3060$	;PROBE IT FOR READABILITY
	CVTLB	(R6),R6			;IS THE INDEX BETWEEN -127 AND 127?
	BVS	3050$			;NO  - INVALID INDEX ITEM
	MOVZBL	R6,R6			;ZERO OUT HIGH ORDER THREE BYTES
	MOVL	R7,R9			;ADDRESS OF FIRST TRANSLATION BLOCK

3110$:	BBS	#LNMX$V_XEND,-		;LAST TRANSLATION BLOCK?
		LNMX$B_FLAGS(R9),3120$	;YES - THEN POSITION TO NEXT ITEM
	CMPB	R6,LNMX$B_INDEX(R9)	;POSITION TO (OR PAST) REQUESTED LNMX?
	BLEQ	3120$			;YES - THEN POSITION TO NEXT ITEM
	MOVZBL	LNMX$T_XLATION(R9),R0	;SIZE OF TRANSLATION STRING
	MOVAB	LNMX$T_XLATION+1(R9)[R0],R9 ;POSITION TO NEXT TRANSLATION BLOCK
	BRB	3110$			;CONTINUE LOOKING FOR SPECIFIED LNMX
3120$:	BRW	3960$			;GO POSITION TO NEXT ITEM

;
; STRING ITEM.
;
; VALIDATE THE ITEM. IF THE CURRENT TRANSLATION BLOCK IS THE LAST
; TRANSLATION BLOCK, OR IF THE INDEX OF THE CURRENT TRANSLATION BLOCK
; DOES NOT MATCH THE INDEX LAST SPECIFIED, THEN NOTHING IS RETURNED
; (A ZERO IS STORED IN THE RETURN ADDRESS LENGTH BUFFER). OTHERWISE,
; THE EQUIVALENCE STRING OF THE SPECIFIED TRANSLATION IS RETURNED.
;

3200$:	CLRQ	R0			;ASSUME 0 BYTES WILL BE RETURNED
	BBS	#LNMX$V_XEND,-		;POSITION TO LAST LNMX?
		LNMX$B_FLAGS(R9),3210$	;YES - 0 BYTES WILL BE RETURNED
	CMPB	R6,LNMX$B_INDEX(R9)	;POSITIONED TO SPECIFIED LNMX?
	BNEQ	3210$			;NO  - 0 BYTES WILL BE RETURNED
	
	MOVAB	LNMX$T_XLATION(R9),R1	;RETRIEVE ADDRESS AND SIZE OF 
	MOVB	(R1)+,R0		;TRANSLATION STRING
3210$:	BRW	3900$			;GO MOVE STRING INTO CURRENT ITEM

;
; ATTRIBUTES ITEM.
;
; VALIDATE THE ITEM. THE ATTRIBUTES OF THE LOGICAL NAME BLOCK ARE
; ALWAYS RETURNED. IF A TRANSLATION WITH THE CURRENT INDEX EXISTS
; THEN THE TRANSLATION ATTRIBUTES ARE RETURNED AND LNM$V_EXIST IS SET.
;

3300$:	MOVZBL	LNMB$B_FLAGS(R8),R2	;LOGICAL NAME BLOCK FLAGS
	BBS	#LNMX$V_XEND,-		;POSITION TO LAST LNMX?
		LNMX$B_FLAGS(R9),3310$	;YES - TRANSLATION DOES NOT EXIST
	CMPB	R6,LNMX$B_INDEX(R9)	;POSITIONED TO SPECIFIED LNMX?
	BNEQ	3310$			;NO  - TRANSLATION DOES NOT EXIST
	
	MOVZBL	LNMX$B_FLAGS(R9),R0	;TRANSLATION BLOCK FLAGS	
	ROTL	#8,R0,R0		;ROTATE THEM INTO THEIR PROPER PLACE
	BISL2	R0,R2			;STORE THEM
	BISL2	#LNM$M_EXISTS,R2	;SET THE TRANSLATION DOES EXIST BIT

3310$:	MOVL	LNMB$L_TABLE(R8),R1	;GET CONTAINING TABLE HEADER ADDRESS
	BBC	#LNMTH$V_SHAREABLE,-	;IS THE CONTAINING TABLE SHAREABLE?
		LNMTH$B_FLAGS(R1),3320$	;GO MOVE ATTRIBUTES IF NOT
	BISL2	#LNM$M_SHAREABLE,R2	;SET SHAREABLE BIT
3320$:	BRW	3940$			;GO MOVE ATTRIBUTES INTO CURRENT ITEM

;
; TABLE ITEM.
;
; VALIDATE THE ITEM. RETURN THE TABLE NAME STRING OF THE LOGICAL
; NAME TABLE IN WHICH THIS LOGICAL NAME TABLE ENTRY IS FOUND.
;

3400$:	MOVL	LNMB$L_TABLE(R8),R1	;ADDRESS OF TABLE HEADER
	MOVL	LNMTH$L_NAME(R1),R1	;ADDRESS OF TABLE LNMB
	MOVAB	LNMB$T_NAME(R1),R1	;RETRIEVE ADDRESS AND SIZE OF
	MOVZBL	(R1)+,R0		;TABLE NAME
	BRW	3900$			;GO MOVE TABLE INTO CURRENT ITEM

;
; LENGTH ITEM.
;
; VALIDATE THE ITEM. IF THE CURRENT TRANSLATION BLOCK IS THE LAST
; TRANSLATION BLOCK, OR IF THE INDEX OF THE CURRENT TRANSLATION
; BLOCK DOES NOT MATCH THE INDEX LAST SPECIFIED, THEN NOTHING IS
; RETURNED (A ZERO IS STORED IN THE  RETURN ADDRESS LENGTH BUFFER).
; OTHERWISE, THE LENGTH OF THE TRANSLATION  STRING OF THE SPECIFIED
; TRANSLATION IS RETURNED.
;

3500$:	CLRL	R2			;ASSUME 0 BYTES WILL BE RETURNED

	BBS	#LNMX$V_XEND,-		;POSITION TO LAST LNMX?
		LNMX$B_FLAGS(R9),3510$	;YES - GO RETURN 0 LENGTH
	CMPB	R6,LNMX$B_INDEX(R9)	;POSITIONED TO SPECIFIED LNMX?
	BNEQ	3510$			;NO  - GO RETURN 0 LENGTH
	MOVZBL	LNMX$T_XLATION(R9),R2	;LENGTH OF TRANSLATION STRING
3510$:	BRW	3940$			;MOVE LONGOWRD ITEM VALUE
3520$:	BRW	3980$			;BADPARAM

;
; ACMODE ITEM.
;
; VALIDATE THE ITEM. RETURN THE ACCESS MODE OF THE LOGICAL NAME TABLE
; ENTRY.
;

3600$:	CMPW	#1,(R11)		;IS ITEM BUFFER AT LEAST A BYTE? 
	BGTRU	3520$			;ERROR IF NOT

	MOVL	4(R11),R0		;RETRIEVE ADDRESS OF ITEM BUFFER
	IFNOWRT	#1,(R0),3620$		;PROBE ITEM BUFFER
	MOVB	LNMB$B_ACMODE(R8),(R0)	;RETURN ACMODE IN CURRENT ITEM
	MOVL	8(R11),R0		;WAS A RETURN LENGTH BUFFER SPECIFIED?
	BEQL	3610$			;DON'T RETURN LENGTH IF ONE WASN'T
	IFNOWRT	#2,(R0),3620$		;PROBE RETURN LENGTH BUFFER
	MOVW	#1,(R0)			;MOVE IN NUMBER OF BYTES RETURNED
3610$:	BRW	3960$			;GO POSITION TO NEXT ITEM 
3620$:	BRW	3970$			;ACCVIO

;
; MAX_INDEX ITEM.
;
; VALIDATE THE ITEM. RETURN THE MAXIMUM POSITIVE INDEX DEFINED FOR
; THE LOGICAL  NAME TABLE ENTRY.
;

3700$:	MNEGL	#1,R2			;INITIALIZE MAX_INDEX TO -1
	MOVL	R7,R1			;ADDRESS OF FIRST TRANSLATION BLOCK

3710$:	BBS	#LNMX$V_XEND,-		;POSITION TO LAST LNMX?
		LNMX$B_FLAGS(R1),3720$	;YES - HAVE FOUND MAXIMUM INDEX
	CVTBL	LNMX$B_INDEX(R1),R2	;NO  - SAVE INDEX
	MOVZBL	LNMX$T_XLATION(R1),R0	;SIZE OF TRANSLATION STRING
	MOVAB	LNMX$T_XLATION+1(R1)[R0],R1 ;POSITION TO NEXT TRANSLATION BLOCK
	BRB	3710$			;CONTINUE LOOKING FOR LAST LNMX

3720$:	TSTL	R2			;IS MAXIMUM INDEX A NEGATIVE NUMBER?
	BGEQ	3940$			;NO -  GO RETURN MAXIMUM INDEX
	MNEGL	#1,R2			;YES - SET MAXIMUM INDEX TO -1
	BRB	3940$			;GO MOVE MAXIMUM INDEX INTO CURRENT ITEM

;
; PARENT TABLE ITEM.
;
; VALIDATE THE ITEM. IF THIS LNMB IS FOR A LOGICAL NAME TABLE, THEN RETURN
; THE TABLE NAME STRING OF THIS TABLE'S PARENT LOGICAL NAME TABLE; OTHERWISE,
; RETURN 0.
; 

3800$:	CLRQ	R0			;ASSUME 0 BYTES WILL BE RETURNED
	BBC	#LNMB$V_TABLE,-		;RETURN 0 BYTES IF THIS IS NOT A LNMB
		LNMB$B_FLAGS(R8),3900$	;FOR A LOGICAL NAME TABLE
	MOVAB	LNMX$T_XLATION+1(R7),R2	;POSITION TO TABLE HEADER
	MOVL	LNMTH$L_PARENT(R2),R2	;RETRIEVE PARENT TABLE HEADER ADDRESS
	BEQL	3900$			;RETURN 0 BYTES IF NO PARENT TABLE
	MOVL	LNMTH$L_NAME(R2),R1	;RETRIEVE PARENT LNMB ADDRESS
	MOVAB	LNMB$T_NAME(R1),R1	;RETRIEVE ADDRESS AND SIZE OF 
3810$:	MOVB	(R1)+,R0		;PARENT TABLE NAME STRING

;
; THE CURRENT ITEM IS TO BE FILLED IN WITH A VARIABLE LENGTH CHARACTER STRING
; (TABLE, STRING, OR PARENT ITEM). IF THE ITEM BUFFER PROVIDED IS NOT 
; SUFFICIENTLY LARGE TO CONTAIN ALL OF THE STRING, THEN THE RETURN STATUS IS 
; CHANGED TO INDICATE THIS, AND AS MUCH OF THE INFORMATION AS CAN BE STORED IS 
; RETURNED.
;

3900$:	MOVQ	R0,-(SP)		;SAVE CHARACTER STRING DESCRIPTOR
	MOVQ	(R11),-(SP)		;SAVE ITEM BUFFER DESCRIPTOR
	MOVZWL	(SP),R1			;SIZE OF ITEM BUFFER
	MOVL	4(SP),R0		;ADDRESS OF ITEM BUFFER
	CLRL	R3			;ACCESS MODE
	JSB	G^EXE$PROBEW		;PROBE ITEM BUFFER 
	MOVQ	(SP)+,R1		;RESTORE ITEM BUFFER DESCRIPTOR
	BLBS	R0,3910$		;CONTINUE IF WRITEABLE
	ADDL2	#8,SP			;REMOVE STRING DESCRIPTOR FROM STACK
	MOVL	R0,(SP)			;SAVE NEW STATUS
	BRB	4010$			;GO RELEASE MUTEX AND RETURN

3910$:	MOVL	(SP),R0			;SIZE OF CHARACTER STRING TO BE RETURNED
	BEQL	3930$			;NOTHING TO RETURN IF SIZE IS 0
	CMPW	R0,R1			;ENOUGH ROOM IN BUFFER?
	BLEQU	3920$			;YES - GO MOVE INFORMATION
	MOVZWL	#SS$_BUFFEROVF,8(SP)	;NO  - CHANGE STATUS TO BUFFER OVERFLOW
	MOVZWL	R1,R0			;      AND MOVE ONLY PART OF STRING

3920$:	PUSHL	R0			;SAVE SIZE OF STRING TO BE MOVED
	MOVC3	R0,@8(SP),(R2)		;MOVE THE CHARACTER STRING
	POPL	R0			;RESTORE NUMBER OF BYTES MOVED
	
3930$:	ADDL2	#8,SP			;REMOVE STRING DESCRIPTOR FROM STACK
	MOVL	8(R11),R2		;WAS A RETURN LENGTH BUFFER SPECIFIED?
	BEQL	3960$			;DON'T PROBE IF ONE WASN'T
	IFNOWRT	#2,(R2),3970$		;PROBE RETURN LENGTH BUFFER
	MOVW	R0,(R2)			;MOVE IN NUMBER OF BYTES RETURNED
	BRB	3960$			;GO POSITION TO NEXT ITEM

;
; THE CURRENT ITEM IS TO BE FILLED IN WITH A LONGWORD OF INFORMATION
; (LENGTH, MAX_INDEX, OR ATTRIBUTES ITEM).
;

3940$:	CMPW	#4,(R11)		;IS ITEM BUFFER AT LEAST A LONGWORD?
	BGTRU	3980$			;ERROR IF NOT
	MOVL	4(R11),R0		;RETRIEVE ADDRESS OF ITEM BUFFER
	IFNOWRT	#4,(R0),3970$		;PROBE ITEM BUFFER
	MOVL	R2,(R0)			;RETURN VALUE IN CURRENT ITEM
	MOVL	8(R11),R0		;HAS A RETURN LENGTH BUFFER SPECIFIED?
	BEQL	3960$			;DON'T RETURN LENGTH IF ONE WASN'T
	IFNOWRT	#2,(R0),3970$		;PROBE RETURN LENGTH BUFFER
	MOVW	#4,(R0)			;MOVE IN NUMBER OF BYTES RETURNED

;
; POSITION TO THE NEXT ITEM IN THE ITEM LIST.
;

3960$:	ADDL2	#12,R11			;POSITION TO NEXT ITEM
	BRW	3040$			;AND CONTINUE 

3970$:	MOVZWL	#SS$_ACCVIO,(SP)	;ACCESS VIOLATION
	BRB	4010$			;DEALLOCATE NEW LNMB AND RETURN ERROR

3980$:	MOVZWL	#SS$_BADPARAM,(SP)	;BAD PARAMETER SEEN


;
; RELEASE THE READ LOCK ON THE LOGICAL NAME MUTEX AND RETURN.
; 

4010$:	MOVL	4(SP),R4		;ADDRESS OF PCB
	BSBW	LNM$UNLOCK		;RELEASE LOCK ON LOGICAL NAME MUTEX
	POPL	R0			;RESTORE RETURN STATUS
	RET				;RETURN
	.DISABLE	LSB

;	.PAGE

	.END
