	.TITLE	PROCSTRT - PROCESS STARTUP AND INITIALIZATION
	.IDENT	'V04-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, PROCESS CREATION SYSTEM SERVICE
;
; ABSTRACT:
;	PROCSTRT CONTAINS THE CODE NECESSARY TO CONCLUDE THE CREATION
;	OF A PROCESS WHICH MUST BE EXECUTED IN THE CONTEXT OF THAT PROCESS.
;
; ENVIRONMENT:
;	MODE=KERNEL, EXECUTING IN CONTEXT OF NEW PROCESS
;
; AUTHOR: R. I. HUSTVEDT	, CREATION DATE: 27-DEC-76
;
; MODIFIED BY:
;
;	V03-002	RAS0332		Ron Schaefer		14-Sep-1984
;		Check for RMS$_BUSY status in the RMS exit handler
;		so as to prevent an infinite loop if the handler
;		has interrupted RMS rundown badly.   In that case,
;		give up on trying to do rundown cleanly.
;		Also, change the rundown type to do a full PPF rundown.
;
;	V04-001	JWT0195		Jim Teague		11-Sep-1984
;		Replace RMS exec mode exit handler for proper rundown
;		of single-image processes.
;
;	V03-043	LJK0288		Lawrence J. Kenah	9-Aug-1984
;		The AUTHPRI cell now exists in both the PCB and the PHD.
;
;	V03-042	ACG0440		Andrew C. Goldstein,	24-Jul-1984  10:45
;		Add ref count field to ORB
;
;	V03-041	HH0040		Hai Huang		19-Jul-1984
;		Add routine EXE$CRE_GTABLE.
;	
;	V03-040	LMP0275		L. Mark Pilant,		12-Jul-1984  20:14
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-039	RAS0319		Ron Schaefer		29-Jun-1984
;		Initialize the logical name table name translation
;		cache queue to empty.
;
;	V03-038	LJK0272		Lawrence J. Kenah	10-Apr-1984
;		Initialize VECSET array at the same time that the VECRESET
;		array is set up.
;
;	V03-037	MHB0121		Mark Bramhall		 9-Apr-1984
;		Move new spawn CLI information to P1 space.
;
;	V03-036	TMK0010		Todd M. Katz		27-Mar-1984
;		Modify the logical name system services to make use of the 
;		updated internal protection checking mechanisms. What this
;		involves is replacing the CHIP protection template in the
; 		templates for the group and job-wide logical name table with
;		a template for a quad-word aligned Object Rights Block, and 
;		making sure that the appropriate fields within the Object Rights
;		blocks are initialized when group and job-wide logical name 
;		tables are created.
;
;	V03-035	WMC0007		Wayne Cardoza		21-Mar-1984
;		Create the default image I/O segment.
;
;	V03-034	TMK0009		Todd M. Katz		07-Mar-1984
;		Add a hash code field, LNMX$W_HASH, to every translation block
;		of every logical name and logical name table template defined.
;		This hash code field will be used in an optimization of logical
;		name table name processing.
;
;	V03-033	TMK0008		Todd M. Katz		17-Feb-1984
;		Fix alignment problems with LNM$GROUP and LNM$JOB introduced
;		by one of the two logical name table alignment bug fixes
;		below. This is done by defining the symbols GROUP_XEND_SIZE
;		and JOB_XEND_SIZE. These two symbols represent the actual
;		amount of storage utilized by LNM$GROUP and LNM$JOB 
;		respectively while the two symbols GROUP_SIZE and JOB_SIZE
;		represent the amount of storage actually allocated for these
;		logical names. These two new symbols are needed by the PROCSTRT
;		code that constructs the equivalence strings for these logical
;		names. This code depends upon knowledge of the actual amount of 
;		storage, allocated to the logical names, which is utilized by 
;		the logical names.
;
;	V03-032	LY00b8		Larry Yetto		17-FEB-1984 14:36
;		Fix alignment of logical name tables
;
;	V03-031	LY00b6		Larry Yetto		16-FEB-1984 14:21
;		Fix alignment of logical name tables
;
;	V03-030	WMC0006		Wayne Cardoza		12-Jan-1983
;		Create DZRO space for XQP, CRF no longer an option.
;
;	V03-029	TMK0007		Todd M. Katz		26-Jan-1984
;		Fix a bug introduced in TMK0006. In EXE$CRE_JGTABLE, if an
;		existing group table is found when an attempt is made to
;	   	create-if a new group table, then the paged pool for what would
;		have become a new group logical name table must be deleted. This
;		was not being done. This resulted in multiple group tables with 
;		identical names, and had the further undesirable affect of
;		causing paged pool to disappear over time as more and more of 
;		these duplicate group logical name tables were created as a 
;		by-product of process creation.
;
;	V03-028	LJK0258		Lawrence J. Kenah	18-Jan-1984
;		Fix bug introduced in LJK0257. Save R4 and R5 before they
;		are destroyed by a MOVC3 instruction.
;
;	V03-027	LJK0257		Lawrence J. Kenah	28-Dec-1983
;		Add support for longer text strings in the PQB. Fix error
;		paths. Add initialization code for P1 lookaside list.
;
;	V03-026	SHZ0001		Stephen H. Zalewski	27-Dec-1983
;		Remove RMS executive mode exit handler.
;
;	V03-025	TMK0006		Todd M. Katz		10-Nov-1983
;		Optimize the logical name and logical name table creations that 
;		are required to be done at process creation time. This is done 
;		by replacing all $CRELNT and $CRELNM system service calls with 
;		the corresponding code that hand constructs the logical name 
;		blocks and oversees their insertion into the overall logical 
;		name structure. In addition, group logical name tables will no
;		longer be created for sub-processes. As in the case of the 
;		job-wide logical name table, it will be assumed that the group
;		logical name table for a sub-process already exists.
;
;	V03-024	TMK0005		Todd M. Katz		12-Oct-1983
;		If the process being created is not a sub-process, create the 
;		job-wide logical name table.
;
;	V03-023	TMK0004		Todd M. Katz		26-Sep-1983
;		Change the protection on the group logical name table to 
;		SYSTEM:RWED OWNER: GROUP:R WORLD: so that processes with system
;		access rights can access and modify any group table.
;
;	V03-022	RAS0181		Ron Schaefer		 5-Sep-1983
;		Convert creation of SYS$INPUT, SYS$OUTPUT, SYS$ERROR,
;		SYS$DISK and TT logical names to use $CRELNM.
;
;	V03-021	TMK0003		Todd M. Katz		22-Aug-1983
;		Create the Group Logical Name Table with the protection mask
;		G:R as part of the changes being made to the logical name table
;		protection mechanism to provide for upwards compatibility 
;		between V3 and V4. In addition, specify the GROUP and NO_ALIAS
;		attributes while creating the Group Logical Name Table so that
;		the table can not be aliased, and so it will get marked 
;		specially as a Group Logical Name Table.
;
;		There is no need to perform any protection checking of 
;		process-private logical name tables; therefore, process-private
;		logical name tables are no longer created with CHIP protection
;		structures. Remove the CHIP protection structure from the
;		process space logical name directory template as well as
;		any fixing up of this CHIP which was being done as part of
;		process creation. 
;
;	V03-020	WMC0005		Wayne Cardoza		02-Jul-1983
;		 assorted performance improvements.
;
;	V03-019	RAS0176		Ron Schaefer		28-Jul-1983
;		Fix group logical name table creation to be in octal;
;		and clean up the code somewhat.
;		
;	V03-018	LJK0221		Lawrence J. Kenah	5-Jul-1983
;		Initialize listheads for image descriptor blocks.
;
;	V03-017	DMW4061		DMWalp			23-Jun-1983
;		Change $xxLNM value parameters to be by reference
;
;	V03-016 DMW4048		DMWalp			13-Jun-1983
;		Fix proctection problems with new logical name structures.
;		Add execmode entry point to IMGDMP.
;
;	V03-015	ADE9005		Alan D. Eldridge	31-May-1983
;		Make BSBW to MMG$IMGRESET a JSB.
;
;	V03-014	RAS0158		Ron Schaefer		23-May-1983
;		Add CHIP protection to logical name structures.
;		Currently only SOGW protection is supported.
;		Fix quota of LNM$PROCESS_DIRECTORY.
;
;	V03-103	WMC0003		Wayne Cardoza		10-May-1983
;		Change XQP merge to use global sections rather than IMGACT.
;
;	V03-012	TMK0002		Todd M. Katz		26-Apr-1983
;		Create the following logical name structures at process creation
;		time:
;
;		1. LNM$PROCESS_TABLE.
;		2. LNM$GROUP_xxxxxxxx (The Group Logical Name Table).
;		3. LNM$GROUP.
;		4. LNM$PROCESS.
;
;		Change the name of LNT$PROCESS_DIRECTORY to 
;		LNM$PROCESS_DIRECTORY.
;
;	V03-011	CDS0003		Christian D. Saether	20-Apr-1983
;		Fix to V03-009.  Don't merge xqp if EXE$V_INIT is clear.
;
;	V03-010	TMK0001		Todd M. Katz		14-Apr-1983
;		Make the following changes to the setting up of the process
;		directory logical name table:
;
;		1. Make the table a kernel mode access table.
;		2. The address of the process directory table's table header
;		   is placed in LNMB$L_TABLE.
;		3. The bit LNMTH$V_DIRECTORY is set in LNMTH$B_FLAGS.
;		4. The field LNMTH$L_LOGNAM is eliminated.
;
;	V03-009	CDS0002		Christian D. Saether	12-Apr-1983
;		Always merge f11bxqp.  Check for xqpmerge errors.
;
;	V03-008	WMC0002		Wayne Cardoza		01-Apr-1983
;		Add second half of IMGDMP.
;
;	V03-007	WMC0001		Wayne Cardoza		14-Mar-1983
;		Add image dump interface.
;
;	V03-006	ACG0305		Andrew C. Goldstein,	16-Dec-1982  14:03
;		Get hibernate flag correctly in EXE$PROCIMGACT entry
;
;	V03-005	CDS0001		Christian D. Saether	16-Dec-1982
;		Add routine to merge F11BXQP into P1 space.
;
;	V03-004	DMW4017		DMWalp			15-Dec-1982
;		Added creation of new logical name hash table and
;		logical name process directory
;
;	V03-003	JWH0117		Jeffrey W. Horn		01-Nov-1982
;		Make the sizes of the RMS Process IO Segment and the
;		Process Allocation Region controlable via SYSGEN
;		parameters.
;
;	V03-002	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Add $DYNDEF.
;
;--
	.PAGE

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$CCBDEF				; CHANNEL CONTROL BLOCK DEFINITIONS
	$CHFDEF				; CONDITION HANDLER DEFINITIONS
	$CLIMSGDEF			; COMMAND INTERPRETER STATUS CODES
	$DYNDEF				; DYNAMIC STRUCTURE TYPE CODES
	$IACDEF				; IMAGE ACTIVATION FLAGS
	$IHDDEF				; IMAGE HEADER DESCRIPTOR DEFINITIONS
	$IMGACTDEF			; IMAGE ACTIVATOR ARGUMENTS
	$JIBDEF				; DEFINE JIB OFFSETS
	$JPIDEF				; JPI ITEM CODES
	$IMPDEF				; RMS IMPURE AREA DEFINITIONS
	$LNMDEF				; LOGICAL NAME DEFINITIONS
	$LNMSTRDEF			; LOGICAL NAME STRUCTURE DEFINITIONS
	$OPDEF				; SYMBOLIC NAMES FOR INSTRUCTION OPCODES
	$ORBDEF				; DEFINE OBJECT RIGHTS BLOCK OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PHDDEF				; DEFINE PROCESS HEADER
	$PQBDEF				; DEFINE PROCESS QUOTA BLOCK OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRTDEF				; DEFINE PAGE PROTECTION VALUES
	$PRVDEF				; PRIVILEGE BIT DEFINITIONS
	$PSLDEF				; DEFINE PSL FIELDS
	$RMSDEF				; DEFINE RMS ERROR STATUSES
	$SECDEF				; SECTION FLAGS
	$SGNDEF				; DEFINE SYSGEN CONSTANTS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$STSDEF				; DEFINE STATUS CODE FIELDS

;
; ASSUMPTIONS ABOUT THE STRUCTURE OF LOGICAL NAME AND OBJECT RIGHTS BLOCKS:
;

	ASSUME	LNMB$L_FLINK,      EQ,	0
	ASSUME	LNMB$L_FLINK+4,    EQ,	LNMB$L_BLINK
	ASSUME	LNMB$L_BLINK+4,    EQ,	LNMB$W_SIZE
	ASSUME 	LNMB$W_SIZE+2,     EQ,	LNMB$B_TYPE
	ASSUME	LNMB$B_TYPE+1,     EQ,	LNMB$B_ACMODE
	ASSUME	LNMB$B_ACMODE+1,   EQ,	LNMB$L_TABLE
	ASSUME	LNMB$L_TABLE+4,    EQ,	LNMB$B_FLAGS
	ASSUME	LNMB$B_FLAGS+1,    EQ, 	LNMB$T_NAME

	ASSUME	LNMX$B_FLAGS,      EQ,	0
	ASSUME	LNMX$B_FLAGS+1,    EQ,	LNMX$B_INDEX
	ASSUME	LNMX$B_INDEX+1,    EQ,	LNMX$W_HASH
	ASSUME	LNMX$W_HASH+2,     EQ,	LNMX$T_XLATION

	ASSUME	LNMTH$B_FLAGS,	   EQ,	0
	ASSUME	LNMTH$B_FLAGS+1,   EQ,	LNMTH$L_HASH
	ASSUME	LNMTH$L_HASH+4,    EQ,	LNMTH$L_ORB
	ASSUME	LNMTH$L_ORB+4,     EQ,	LNMTH$L_NAME
	ASSUME	LNMTH$L_NAME+4,    EQ,	LNMTH$L_PARENT
	ASSUME	LNMTH$L_PARENT+4,  EQ,	LNMTH$L_CHILD
	ASSUME	LNMTH$L_CHILD+4,   EQ,	LNMTH$L_SIBLING
	ASSUME	LNMTH$L_SIBLING+4, EQ,	LNMTH$L_QTABLE
	ASSUME	LNMTH$L_QTABLE+4,  EQ,	LNMTH$L_BYTESLM
	ASSUME	LNMTH$L_BYTESLM+4, EQ,	LNMTH$L_BYTES

	ASSUME	ORB$L_OWNER,	   EQ,	0
	ASSUME	ORB$L_OWNER+4,	   EQ,	ORB$L_ACL_MUTEX
	ASSUME	ORB$L_ACL_MUTEX+4, EQ,	ORB$W_SIZE
	ASSUME	ORB$W_SIZE+2,	   EQ,	ORB$B_TYPE
	ASSUME	ORB$B_TYPE+1,	   EQ,	ORB$B_FLAGS
	ASSUME	ORB$B_FLAGS+3,	   EQ,	ORB$W_REFCOUNT
	ASSUME	ORB$W_REFCOUNT+2,  EQ,	ORB$Q_MODE_PROT
	ASSUME	ORB$Q_MODE_PROT+8, EQ,	ORB$L_SYS_PROT
	ASSUME	ORB$L_SYS_PROT+4,  EQ,	ORB$L_OWN_PROT
	ASSUME	ORB$L_OWN_PROT+4,  EQ,	ORB$L_GRP_PROT
	ASSUME	ORB$L_GRP_PROT+4,  EQ,	ORB$L_WOR_PROT
	ASSUME	ORB$L_WOR_PROT+4,  EQ,	ORB$L_ACL_COUNT
	ASSUME	ORB$L_ACL_COUNT+4, EQ,	ORB$L_ACL_DESC
	ASSUME	ORB$L_ACL_DESC+4,  EQ,	ORB$R_MIN_CLASS
	ASSUME	ORB$R_MIN_CLASS+ORB$S_MIN_CLASS,-
				   EQ,	ORB$R_MAX_CLASS
	ASSUME	ORB$R_MAX_CLASS+ORB$S_MAX_CLASS,-
				   EQ,	ORB$K_LENGTH

;
; MACROS:
;

	.MACRO	CRELNM,XLATION,XLATION_ATTR,LNMX,LNMB
	BSBW	CRELNM
	.WORD	<XLATION>
	.WORD	<XLATION_ATTR>
	.WORD	<LNMX>
	.WORD	<LNMB>
	.END	CRELNM

;
; EQUATED SYMBOLS:
;

NXTKVEC=0			;OFFSET TO NEXT FREE KERNEL VECTOR
NXTEVEC=256			;OFFSET TO NEXT FREE EXEC VECTOR
NXTRVEC=512			;OFFSET TO NEXT FREE RUNDWN VECTOR
NXTMVEC=768			;OFFSET TO NEXT MESSAGE VECTOR


;
; OWN STORAGE:
;

	.PSECT	YYPROCSTRT,5		; PAGED PSECT

EXE$GQ_SYSDISK::			; DESCRIPTOR FOR SYS$DISK
	.ASCID	/SYS$DISK/	
DEFDESC:				; DEFAULT IMAGE FILE NAME
	.ASCID	/.EXE/

CHARS:	.ASCII	/0123456789ABCDEF/	; CHARS FOR OCTAL (HEX) -> ASCII CONVS

;
; CATCH ALL HANDLER FATAL CONDITION MESSAGE SUFFIX.
;
 
SUFFIX:	.ASCIZ	/image exit forced./	;

;
; STRINGS FOR IMAGE DUMP MERGE.
;

DEFAULTNAMDSC:
	.ASCID	/SYS$LIBRARY:.EXE/
IMGDMPNAM:
	.ASCID	/IMGDMP/

;
; TEMPLATES FOR THE LOGICAL NAME TABLES AND NAMES CREATED WITHIN PROCSTRT.
;

	.ALIGN  QUAD
PROC_DIR:				; LNM$PROCESS_DIRECTORY TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   PROC_DIR_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   LNMB$M_NO_ALIAS!-	; NO ALIAS ALLOWED
		LNMB$M_TABLE!-		; THIS IS A TABLE
		LNMB$M_NODELETE		; ... THAT CANNOT BE DELETED
	.ASCIC  "LNM$PROCESS_DIRECTORY"	; DIRECTORY NAME AS COUNTED STRING

	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION 
	.BYTE   LNMX$C_TABLE		; SPECIAL TABLE TRANSLATION INDEX 
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMTH$K_LENGTH		; SIZE OF TABLE HEADER BLOCK

PROC_DIR_LNMTH = . - PROC_DIR
	.BYTE   LNMTH$M_DIRECTORY	; TABLE IS FOR A DIRECTORY
	.LONG   0			; ADDRESS OF HASH TABLE
	.LONG   0			; ADDRESS OF OBJECT RIGHTS BLOCK
	.LONG   0			; ADDRESS OF CONTAINING LNMB BLOCK
	.LONG   0			; ADDRESS OF PARENT TABLE
	.LONG   0			; ADDRESS OF CHILD TABLE
	.LONG   0			; ADDRESS OF SIBLING TABLE
	.LONG   0			; ADDRESS OF TABLE HOLDING QUOTA
	.LONG   ^X7FFFFFFF		; INITIAL QUOTA   ( POSITIVE INFINITY )
	.LONG   ^X7FFFFFFF		; REMAINING QUOTA ( POSITIVE INFINITY )

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
PROC_DIR_SIZE = . - PROC_DIR

PROC_TABLE = . - PROC_DIR		; LNM$PROCESS_TABLE TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   PROC_TABLE_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   LNMB$M_NO_ALIAS!-	; NON-ALIASABLE 
		LNMB$M_TABLE		; A TABLE
	.ASCIC  "LNM$PROCESS_TABLE"	; TABLE NAME AS COUNTED STRING

	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION 
	.BYTE   LNMX$C_TABLE		; SPECIAL TABLE TRANSLATION INDEX 
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMTH$K_LENGTH		; SIZE OF TABLE HEADER BLOCK

PROC_TABLE_LNMTH = . - PROC_DIR
	.BYTE   0			; FLAGS BYTE
	.LONG   0			; ADDRESS OF HASH TABLE
	.LONG   0			; ADDRESS OF OBJECT RIGHTS BLOCK
	.LONG   0			; ADDRESS OF CONTAINING LNMB BLOCK
	.LONG   0			; ADDRESS OF PARENT TABLE
	.LONG   0			; ADDRESS OF CHILD TABLE
	.LONG   0			; ADDRESS OF SIBLING TABLE
	.LONG   0			; ADDRESS OF TABLE HOLDING QUOTA
	.LONG   0			; INITIAL QUOTA   ( POOLED )
	.LONG   0			; REMAINING QUOTA ( POOLED )

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
PROC_TABLE_SIZE = . - PROC_DIR - PROC_TABLE


PROCESS = . - PROC_DIR			; LNM$PROCESS TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   PROCESS_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "LNM$PROCESS"		; LOGICAL NAME AS COUNTED STRING

	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.ASCIC  "LNM$PROCESS_TABLE"	; TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
PROCESS_SIZE = . - PROC_DIR - PROCESS

GROUP = . - PROC_DIR			; LNM$GROUP TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   GROUP_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "LNM$GROUP"		; LOGICAL NAME AS COUNTED STRING

	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.ASCIC  "LNM$GROUP_xxxxxx"	; TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
GROUP_XEND_SIZE = . - PROC_DIR - GROUP
	.ALIGN  QUAD
GROUP_SIZE = . - PROC_DIR - GROUP

JOB = . - PROC_DIR			; LNM$JOB TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   JOB_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "LNM$JOB"		; LOGICAL NAME AS COUNTED STRING

	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.ASCIC  "LNM$JOB_xxxxxxxx"	; TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
JOB_XEND_SIZE = . - PROC_DIR - JOB
	.ALIGN  QUAD
JOB_SIZE = . - PROC_DIR - JOB

SYS$INPUT = . - PROC_DIR		; SYS$INPUT TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   SYS$INPUT_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_EXEC		; EXECUTIVE ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "SYS$INPUT"		; LOGICAL NAME AS COUNTED STRING

SYS$INPUT_LNMX = . - PROC_DIR
	.BYTE   0			; TRANSLATION ATTRIBUTES
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMX$M_XEND[PQB$S_INPUT]; WORST CASE TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
SYS$INPUT_SIZE = . - PROC_DIR - SYS$INPUT

TT = . - PROC_DIR			; TT TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   TT_SIZE			; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_EXEC		; EXECUTIVE ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "TT"			; LOGICAL NAME AS COUNTED STRING

TT_LNMX = . - PROC_DIR
	.BYTE   0			; TRANSLATION ATTRIBUTES
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMX$M_XEND[PQB$S_INPUT]; WORST CASE TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
TT_SIZE = . - PROC_DIR - TT

SYS$OUTPUT = . - PROC_DIR		; SYS$OUTPUT TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   SYS$OUTPUT_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_EXEC		; EXECUTIVE ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "SYS$OUTPUT"		; LOGICAL NAME AS COUNTED STRING

SYS$OUTPUT_LNMX = . - PROC_DIR
	.BYTE   0			; TRANSLATION ATTRIBUTES
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMX$M_XEND[PQB$S_OUTPUT]; WORST CASE TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
SYS$OUTPUT_SIZE = . - PROC_DIR - SYS$OUTPUT

SYS$ERROR = . - PROC_DIR		; SYS$ERROR TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   SYS$ERROR_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_EXEC		; EXECUTIVE ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "SYS$ERROR"		; LOGICAL NAME AS COUNTED STRING

SYS$ERROR_LNMX = . - PROC_DIR
	.BYTE   0			; TRANSLATION ATTRIBUTES
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMX$M_XEND[PQB$S_ERROR]; WORST CASE TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
SYS$ERROR_SIZE = . - PROC_DIR - SYS$ERROR

SYS$DISK = . - PROC_DIR			; SYS$DISK TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   SYS$DISK_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_EXEC		; EXECUTIVE ACCESS MODE
	.LONG   0			; CONTAINING TABLE HEADER ADDRESS
	.BYTE   0			; FLAGS BYTE
	.ASCIC  "SYS$DISK"		; LOGICAL NAME AS COUNTED STRING

SYS$DISK_LNMX = . - PROC_DIR
	.BYTE   0			; TRANSLATION ATTRIBUTES
	.BYTE   0			; TRANSLATION INDEX IS 0
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMX$M_XEND[PQB$S_DISK]	; WORST CASE TRANSLATION AS COUNTED STRING

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION
	.ALIGN  QUAD
SYS$DISK_SIZE = . - PROC_DIR - SYS$DISK
P1_ALLOC_SIZE = . - PROC_DIR

    .ALIGN  5
GROUP_TABLE:				; LNM$GROUP_xxxxxx TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   GROUP_TABLE_SIZE	; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; CONTAINING TABLE HEADER ADDRESS
	.BYTE   LNMB$M_NO_ALIAS!-	; NON-ALIASABLE 
		LNMB$M_TABLE		; A TABLE
	.ASCIC  "LNM$GROUP_xxxxxx"	; TABLE NAME AS COUNTED STRING

	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION
	.BYTE   LNMX$C_TABLE		; SPECIAL TABLE TRANSLATION INDEX 
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMTH$K_LENGTH		; SIZE OF TABLE HEADER BLOCK

GROUP_TABLE_LNMTH = . - GROUP_TABLE
	.BYTE   LNMTH$M_SHAREABLE!-	; TABLE IS SHAREABLE 
		LNMTH$M_GROUP 		; A GROUP TABLE
	.LONG   0			; ADDRESS OF HASH TABLE
	.LONG   0			; ADDRESS OF OBJECT RIGHTS BLOCK
	.LONG   0			; ADDRESS OF CONTAINING LNMB BLOCK
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF PARENT TABLE
	.LONG   0			; ADDRESS OF CHILD TABLE
	.LONG   0			; ADDRESS OF SIBLING TABLE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF TABLE HOLDING QUOTA
	.LONG   0			; INITIAL QUOTA   ( POOLED )
	.LONG   0			; REMAINING QUOTA ( POOLED )

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION

	.ALIGN	QUAD
GROUP_TABLE_ORB = . - GROUP_TABLE
	.LONG	0			; GROUP NUMBER + 0 MEMBER NUMBER
	.WORD	-1, 0			; INITIALIZED ACL MUTEX
	.WORD	GROUP_TABLE_ORB_SIZ	; SIZE OF OBJECT RIGHTS BLOCK
	.BYTE	DYN$C_ORB		; BLOCK TYPE
	.BYTE	0			; NOTE NO ACL AS YET
	.LONG	0			; ZERO RESERVED WORD & REF COUNT
	.QUAD	0			; OBJECT DOES NOT HAVE AN ACCESS MODE
	.LONG	^X00000000		; SYSTEM PROTECTION IS RWED
	.LONG	^X0000000F		; OWNER PROTECTION 
	.LONG	^X0000000E		; GROUP PROTECTION IS R
	.LONG	^X0000000F		; WORLD PROTECTION 
	.LONG	0,0			; NULL INITIAL ACL
	.BYTE   0[ORB$S_MIN_CLASS]	; MINIMUM CLASSIFICATION MASK
	.BYTE   0[ORB$S_MAX_CLASS]	; MAXIMUM CLASSIFICATION MASK
	.ALIGN  5
GROUP_TABLE_ORB_SIZ = . - GROUP_TABLE - GROUP_TABLE_ORB
GROUP_TABLE_SIZE = . - GROUP_TABLE

JOB_TABLE = . - GROUP_TABLE		; LNM$JOB_xxxxxxxx TEMPLATE
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   JOB_TABLE_SIZE		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; CONTAINING TABLE HEADER ADDRESS
	.BYTE   LNMB$M_NO_ALIAS!-	; NON-ALIASABLE 
		LNMB$M_TABLE		; A TABLE
	.ASCIC  "LNM$JOB_xxxxxxxx"	; TABLE NAME AS COUNTED STRING
	
	.BYTE   LNMX$M_TERMINAL		; TERMINAL TRANSLATION
	.BYTE   LNMX$C_TABLE		; SPECIAL TABLE TRANSLATION INDEX 
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMTH$K_LENGTH		; SIZE OF TABLE HEADER BLOCK

JOB_TABLE_LNMTH = . - GROUP_TABLE
	.BYTE   LNMTH$M_SHAREABLE	; SHAREABLE TABLE
	.LONG   0			; ADDRESS OF HASH TABLE
	.LONG   0			; ADDRESS OF OBJECT RIGHTS BLOCK
	.LONG   0			; ADDRESS OF CONTAINING LNMB BLOCK
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF PARENT TABLE
	.LONG   0			; ADDRESS OF CHILD TABLE
	.LONG   0			; ADDRESS OF SIBLING TABLE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF TABLE HOLDING QUOTA
	.LONG   0			; INITIAL QUOTA   
	.LONG   0			; REMAINING QUOTA 

	.BYTE   LNMX$M_XEND		; LAST TRANSLATION

	.ALIGN	QUAD
JOB_TABLE_ORB = . - GROUP_TABLE
	.LONG	0			; OWNER OF JOB TABLE
	.WORD	-1, 0			; INITIALIZED ACL MUTEX
	.WORD	JOB_TABLE_ORB_SIZ	; SIZE OF OBJECT RIGHTS BLOCK
	.BYTE	DYN$C_ORB		; BLOCK TYPE
	.BYTE	0			; NOTE NO ACL AS YET
	.LONG	0			; ZERO RESERVED WORD & REF COUNT
	.QUAD	0			; OBJECT DOES NOT HAVE AN ACCESS MODE
	.LONG	^X00000000		; SYSTEM PROTECTION IS RWED
	.LONG	^X00000000		; OWNER PROTECTION IS RWED
	.LONG	^X0000000F		; GROUP PROTECTION 
	.LONG	^X0000000F		; WORLD PROTECTION 
	.LONG	0,0			; NULL INITIAL ACL
	.BYTE   0[ORB$S_MIN_CLASS]	; MINIMUM CLASSIFICATION MASK
	.BYTE   0[ORB$S_MAX_CLASS]	; MAXIMUM CLASSIFICATION MASK
	.ALIGN  5
JOB_TABLE_ORB_SIZ = . - GROUP_TABLE - JOB_TABLE_ORB
JOB_TABLE_SIZE = . - GROUP_TABLE - JOB_TABLE
S0_ALLOC_SIZE = . - GROUP_TABLE

;
; OFFSETS FROM R6 USED BY THE IMAGE DUMP MERGE.
;

	$OFFSET	0,POSITIVE,<-
		<,<<IMGACT$_NARGS+1>*4>>,- ; ARGUMENT LIST FOR $IMGACT CALL
		<IMGACT_INADR,8>,-	; INPUT ADDRESS RANGE TO MAP IMAGE AT
		<IMGACT_RETADR,8>,-	; RET ADR RANGE WHERE IMAGE WAS MAPPED
		<HDRBUF,512>,-		; IMAGE HEADER BUFFER FOR $IMGACT
		<PROCPRIV,8>,-		; PROCESS DEFAULT PRIVILEGES
		<IMAGPRIV,8>,-		; IMAGE PRIVILEGES
		<PHD_FLAGS,4>,-		; PROCESS HEADER FLAGS
		<JPI_PROC,12>,-		; GETJPI LIST ITEM FOR PROCESS PRIVILEGES
		<JPI_IMAG,12>,-		; GETJPI LIST ITEM FOR IMAGE PRIVILEGES
		<JPI_FLAG,12>,-		; GETJPI LIST ITEM FOR FLAGS
		<JPI_END,4>,-		; GETJPI LIST TERMINATOR
		<SCRATCHSIZE,0>,-	; SIZE OF AREA ADDRESS OFF OF FP
		>

	.PAGE

	.SBTTL	EXE$PROCSTRT - STARTUP NEW PROCESS

;++
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;	NONE
;
; INPUT PARAMETERS:
;	SCH$GL_CURPCB - POINTS TO PCB OF CURRENT PROCESS
;	PCB$L_PQB - POINTER TO PROCESS QUOTA BLOCK
;
; IMPLICIT INPUTS:
;	IPL = IPL$_ASTDEL
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	LOGICAL NAMES ARE DEFINED FOR 'SYS$INPUT', 'SYS$OUTPUT', AND 'SYS$ERROR'
;	BASED ON THE STRINGS PASSED IN THE PROCESS QUOTA BLOCK.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--


;
;  The PQB address must be stored before any instruction that can cause a page 
;  fault. If a page fault occurs and the process is put into a resource wait
;  state, then the PQB address will be lost because the EFWM field, used to
;  store the resource number, overlaps PCB$L_PQB. This forces the first
;  two instructions into a nonpaged program section.
;

	.PSECT	AEXENONPAGED

EXE$PROCSTRT::				; STARTUP NEW PROCESS
	MOVL	SCH$GL_CURPCB,R4	; GET POINTER TO CURRENT PCB
	MOVL	PCB$L_PQB(R4),R6	; GET POINTER TO PROCESS QUOTA BLOCK
	JMP	G^EXE_PROCSTRT		; CONTINUE IN PAGEABLE EXEC

	.PSECT	YYPROCSTRT

EXE_PROCSTRT:
;
;	N O T E :   THERE CAN BE NO I/O TO A PROCESS CHANNEL BETWEEN HERE
;		    AND THE END OF THE NEW CHANNEL CREATION CODE.
;
	MOVL	G^MMG$GL_RMSBASE,G^CTL$GL_RMSBASE ; SET RMS DISPATCHER BASE
	MOVL	G^MMG$GL_CTLBASVA,G^CTL$GL_CTLBASVA ; SET CTL BASE ADDRESS
;
; INITIALIZE THE DISPATCH VECTORS.
;
	MOVAB	@#CTL$A_DISPVEC,R5	; GET ADR OF 1ST VECTOR PAGE
	MOVZBL	#04,NXTKVEC(R5)		; SET OFFSET TO 1ST FREE KERNEL VECTOR
	MOVZBL	#04,NXTEVEC(R5)		; SET OFFSET TO 1ST FREE EXEC VECTOR
	MOVZBL	#04,NXTRVEC(R5)		; SET OFFSET TO 1ST FREE RUNDWN VECTOR
	MOVZBL	#04,NXTMVEC(R5)		; SET OFFSET TO 1ST FREE MESSAGE VECTOR
	MOVZBL	#OP$_RSB,NXTKVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVZBL	#OP$_RSB,NXTEVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVZBL	#OP$_RSB,NXTRVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVZBL	#OP$_RSB,NXTMVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVAB	NXTKVEC+4(R5),G^CTL$GL_USRCHMK ; SET POINTER TO START OF VECTOR
	MOVAB	NXTEVEC+4(R5),G^CTL$GL_USRCHME ; SET POINTER TO START OF VECTOR
	MOVAB	NXTRVEC+4(R5),G^CTL$GL_USRUNDWN ; SET POINTER TO START OF VECTOR
	MOVAB	NXTMVEC+4(R5),G^CTL$GL_GETMSG ; SET POINTER TO START OF VECTOR
	MOVL	R4,G^CTL$GL_PCB		; SET POINTER TO PCB
	ASSUME PHD$Q_PRIVMSK EQ 0
	MOVL	@#CTL$GL_PHD,R5		; GET SAFE POINTER TO PROCESS HEADER WINDOW
	BBC	#PQB$V_IMGDMP,PQB$W_FLAGS(R6),10$
	BISW	#PHD$M_IMGDMP,PHD$W_FLAGS(R5) ; IMAGE DUMP WAS REQUESTED

; SET UP P1 SPACE LOOKASIDE LIST FOR KERNEL MODE BUFFERS

10$:	MOVAB	G^CTL$GL_KRPFL,R2	; GET LISTHEAD ADDRESS
	MOVAB	G^CTL$GL_KRP,R1		; GET 
	MOVL	S^#CTL$C_KRP_COUNT,R0
	BLEQ	30$
20$:	INSQUE	(R1),@4(R2)
	ADDL	#CTL$C_KRP_SIZE,R1
	SOBGTR	R0,20$
30$:
	.ENABL	LSB
					; SET PROPER QUOTAS FROM PQB
	MOVL	PQB$L_CPULM(R6),PHD$L_CPULIM(R5) ; SET CPU TIME LIMIT
	CVTLW	PQB$L_ASTLM(R6),PHD$W_ASTLM(R5)  ; SET AST LIMIT
	MOVL	SGN$GL_MAXWSCNT,R1	; GET MAXIMUM WORKING SET LIST LENGTH
	SUBL3	SCH$GL_FREELIM,PFN$GL_PHYPGCNT,R0 ; GET AVAILABLE PAGES
	CMPL	R0,R1			; MINIMIZE WITH SPECIFIED QUOTA
	BLEQ	10$			; USE QUOTA
	MOVL	R1,R0			; USE MAXIMUM WORKING SET COUNT
10$:	MOVZWL	PQB$L_WSEXTENT(R6),R1	; GET MAXIMUM PAGES FOR WORKING SET
	MOVZWL	PQB$L_WSQUOTA(R6),R2	; GET MAXIMUM QUOTA FOR WORKING SET
	MOVZWL	PQB$L_WSDEFAULT(R6),R3	; GET DESIRED DEFAULT
	CMPL	R1,R2			; EXTENT MUST BE BIGGER THAN QUOTA
	BGEQ	20$			; YES, USE IT AS IS
	MOVL	R2,R1			; FORCE TO QUOTA (EXTENT MAY BE 0)
20$:	CMPL	R1,R0			; EXTENT MUST BE LESS THAN MAX PAGES
	BLEQ	30$			; BRANCH IF OK AS IS
	MOVL	R0,R1			; SET EXTENT TO MAX MEMORY
30$:	CMPL	R2,R1			; QUOTA MUST BE LESS THAN EXTENT
	BLEQ	40$			; BRANCH IF OK AS IS
	MOVL	R1,R2			; SET QUOTA TO EXTENT
40$:	CMPL	R3,R2			; DEFAULT MUST BE LESS THAN QUOTA
	BLEQ	50$			; BRANCH IF OK AS IS
	MOVL	R2,R3			; SET DEFAULT TO QUOTA
50$:	SUBW3	#1,PHD$W_WSLIST(R5),R0	; GET BASE OFFSET TO WORKING SET LIST
	ADDW	R0,R1			; GET EXTENT
	MOVW	R1,PHD$W_WSEXTENT(R5)	; SET EXTENT
	MOVW	R1,PHD$W_WSAUTHEXT(R5)	; SET AUTHORIZED EXTENT
	ADDW	R0,R2			; GET QUOTA
	MOVW	R2,PHD$W_WSQUOTA(R5)	; QUOTA VALUE
	MOVW	R2,PHD$W_WSAUTH(R5)	; AUTHORIZED VALUE
	ADDW3	R0,R3,PHD$W_DFWSCNT(R5)	; SAVE DEFAULT WORKING SET SIZE

; THE AUTHPRI CELL EXISTS IN TWO PLACES. THE $SETPRI SYSTEM SERVICE USES
; THE PCB CELL BUT THE PHD CELL MUST EXIST FOREVER BECAUSE THAT IS WHERE
; THE JPI ITEM CODE BELIEVES THAT AUTHPRI IS LOCATED.

	MOVB	PCB$B_PRIB(R4),PCB$B_AUTHPRI(R4)    ; SET INITIAL PROCESS PRIORITY
	MOVB	PCB$B_PRIB(R4),PHD$B_AUTHPRI(R5)    ; ... IN BOTH PCB AND PHD
	MOVQ	PQB$Q_PRVMSK(R6),@PCB$L_PHD(R4)     ; SET PRIVILEGES FOR PROCESS
	MOVQ	PQB$Q_PRVMSK(R6),@#CTL$GQ_PROCPRIV  ; BOTH PERMANENT AND CURRENT
	MOVQ	PQB$Q_PRVMSK(R6),PHD$Q_AUTHPRIV(R5) ; AND AUTHORIZED MASKS
	MOVB	PQB$B_MSGMASK(R6),@#CTL$GB_MSGMASK  ; GET DEFAULT MESSAGE FLAGS
	MOVQ	EXE$GQ_SYSTIME,@#CTL$GQ_LOGIN	    ; SAVE LOGIN TIME
	MOVQ	R4,-(SP)			    ; SAVE PCB AND PHD POINTERS

; MOVE MINIMUM AND MAXIMUM AUTHORIZED SECURITY CLEARANCE RECORDS INTO THE PHD.
; THE FOLLOWING ASSUME STATEMENTS GUARANTEE THAT WE CAN SAFELY PERFORM THIS
; WITH A SINGLE MOVC3 INSTRUCTION.

	ASSUME PQB$S_MIN_CLASS EQ PHD$S_MIN_CLASS 
	ASSUME PQB$S_MAX_CLASS EQ PHD$S_MAX_CLASS 
	ASSUME PQB$R_MAX_CLASS EQ <PQB$R_MIN_CLASS + PQB$S_MIN_CLASS>
	ASSUME PHD$R_MAX_CLASS EQ <PHD$R_MIN_CLASS + PHD$S_MIN_CLASS>

	MOVC3	#<PQB$S_MIN_CLASS+PQB$S_MAX_CLASS>,-
		PQB$R_MIN_CLASS(R6),-
		PHD$R_MIN_CLASS(R5)

; INITIALIZE LISTHEADS FOR DOUBLY LINKED LISTS USED BY IMAGE ACTIVATOR

	MOVAB	@#IAC$GL_IMAGE_LIST,R0	; LIST OF ACTIVATED IMAGES
	MOVL	R0,(R0)			; INITIALIZE FLINK
	MOVL	R0,4(R0)		; ... AND BLINK

	MOVAB	@#IAC$GL_WORK_LIST,R0	; LIST OF WORK IN PROGRESS
	MOVL	R0,(R0)			; INITIALIZE FLINK
	MOVL	R0,4(R0)		; ... AND BLINK

	MOVAB	@#IAC$GL_ICBFL,R0	; ADDRESS OF ICB LOOKASIDE LIST
	MOVL	R0,(R0)			; INITIALIZE FLINK
	MOVL	R0,4(R0)		; ... AND BLINK

;
; CREATE THE PAGES FOR THE CCB TABLE, PROCESS ALLOCATION REGION, AND DEFAULT
;	IMAGE I/O SEGMENT
;

	MOVZWL	G^SGN$GW_PCHANCNT,R3	; PICK UP SYSGEN PARAM FOR # CHANS
	INCL	R3			; ALLOW FOR WASTED CCB
	MULL	#CCB$C_LENGTH,R3	; CONVERT TO # BYTES
	ADDL	#511,R3			; ROUND UP TO EVEN PAGES
	BICL	#511,R3
	MOVZWL	G^SGN$GW_CTLPAGES,R4	; GET # PAGES FOR PROCESS ALL REGION
	ASHL	#9,R4,R4		; CONVERT TO # BYTES
	ADDL	R4,R3			; GET TOTAL # BYTES NEEDED SO FAR
	MOVZWL	G^SGN$GW_PIOPAGES,R7	; GET # PAGES FOR PIO SEGMENT
	ASHL	#9,R7,R7		; CONVERT TO NUMBER OF BYTES
	ADDL	R7,R3			; GET TOTAL # BYTES NEEDED
	MOVZWL	G^SGN$GW_IMGIOCNT,R8	; GET # PAGES FOR IIO SEGMENT
	ASHL	#9,R8,R8		; CONVERT TO NUMBER OF BYTES
	ADDL	R8,R3			; GET TOTAL # BYTES NEEDED
	MOVAL	CTL$GL_CTLBASVA,R5	; GET POINTER TO 'TOP' OF P1
	SUBL3	#1,(R5),-(SP)		; 'LAST' PAGE IN P1
	SUBL3	R3,(R5),-(SP)		; 'TOP' OF CREATED REGION
	MOVAQ	-(SP),R2		; SPACE FOR RETADR
	PUSHL	#PSL$C_KERNEL+<PRT$C_UREW@8> ; ACCESS MODE AND PROTECTION
	PUSHL	R2			; RETADR ARRAY
	PUSHAB	8(R2)			; INADR ARRAY
	PUSHL	#3			; ARGUMENT COUNT
	MOVL	SP,R0
	$CMKRNL_S -			; CALL INTERNAL ENTRY POINT FOR $CRETVA
		ROUTIN = G^MMG$CRETVA,-
		ARGLST = (R0)
	BLBC	R0,VABUG		; GET OUT ON ERROR
	CMPL	(R2),8(R2)		; DID WE GET FULL REQUEST?
	BNEQ	VABUG			; NO, ERROR OUT
	CMPL	4(R2),12(R2)		; MAKE DOUBLY SURE
	BEQL	DIVR			; NO, ERROR OUT

VABUG:	INSQUE	(R6),@EXE$GL_PQBBL	; DEALLOCATE PQB TO LOOKASIDE LIST
	SETIPL	#0			; ALLOW PROCESS TO BE DELETED
	BRW	EXE$EXIT_IMAGE		; DELETE THE PROCESS
;
; NOW DIVIDE THE CREATED SPACE INTO FOUR AREAS
;

DIVR:	MOVL	(R2),PIO$GQ_IIODEFAULT+4		; DEFAULT IMAGE I/O AREA
	MOVL	R8,PIO$GQ_IIODEFAULT			; SIZE
	MOVAL	@#PIO$GW_PIOIMPA+IMP$L_IOSEGADDR,R0	; GET POINTER ADDRESS
	ADDL	(R2),R8					; START OF REMAINING SPACE
	MOVL	R8,(R0)+				; SET UP THE PIO SEG ADDR
	MOVL	R7,(R0)					; SET LENGTH
	ADDL3	R8,R7,R0				; GET POINTER TO FREE SPACE
	MOVL	R0,@#CTL$GQ_ALLOCREG			; SET UP PROCESS ALLOCATION REGION
	CLRL	(R0)+					; NULL FORWARD POINTER
	MOVL	R4,(R0)					; SET SIZE OF REGION
	MOVZWL	G^SGN$GW_CTLIMGLIM,R0			; GET IMAGE LIMIT
	ASHL	#9,R0,@#CTL$GL_PRCALLCNT		; CONVERT TO # BYTES
	SUBL3	#CCB$C_LENGTH-1,4(R2),@#CTL$GL_CCBBASE	; STORE BASE OF CHANNEL TABLE

	MOVZWL	G^SGN$GW_PCHANCNT,@#CTL$GW_NMIOCH ; SET NUMBER OF CHANNELS

;
; NOTE(!!!!):	THE ABOVE ASSIGNMENT MUST BE DONE AT THE VERY END OF THIS
;		SECTION OF CODE, AS THE CELL NMIOCH BEING NON-ZERO IS AN
;		INDICATOR TO IOC$FFCHAN THAT THERE IS ACTUALLY A REAL
;		CHANNEL TABLE TO LOOK AT.
;

	MOVL	(R2),(R5)		; UPDATE BASE OF VA IN CTL REGION
	MOVAL	32(SP),SP		; POP $CRETVA ARGS
	
;
; ALLOCATE P1 SPACE FOR THE PROCESS-PRIVATE LOGICAL NAME HASH TABLE, FOR
; THE PROCESS DIRECTORY LOGICAL NAME TABLE, AND FOR ALL PROCESS-PRIVATE
; LOGICAL NAMES AND LOGICAL NAME TABLES THAT NEED TO BE SETUP AT PROCESS
; CREATION TIME. INITIALLY FORMAT THE LOGICAL NAMES AND LOGICAL NAME TABLES
; BY COPYING THEIR TEMPLATES ONTO THE P1 SPACE ALLOCATED FOR THEM, AND THEN
; FORMAT THE PROCESS-PRIVATE LOGICAL NAME HASH TABLE.
;

	MOVL	G^LNM$GL_HTBLSIZP,R1	; RETRIEVE NUMBER OF HASH TABLE ENTRIES
	MOVAL	@#LNMHSH$K_BUCKET[R1],R1; MULTIPLY BY 4 AND ADD OVERHEAD
	MOVL	R1,R7			; SAVE SIZE OF HASH TABLE
	ADDL2	#P1_ALLOC_SIZE,R1	; ADD IN SIZE OF LOGICAL NAME BLOCKS
	JSB	G^EXE$ALOP1PROC		; ALLOCATE TOTAL AMOUNT OF SPACE NEEDED
	MOVL	R2,R8			; SAVE ADDRESS OF ALLOCATED SPACE

	MOVC5	#P1_ALLOC_SIZE,-	; COPY TEMPLATE FOR ALL LOGICAL NAMES
		PROC_DIR,#0,R1,(R2)	; AND ZERO PROCESS-PRIVATE HASH TABLE
	ADDL3	#P1_ALLOC_SIZE,R8,R3	; COMPUTE HASH TABLE ADDRESS

	MOVL	R3,@#CTL$GL_LNMHASH	; STORE ADDRESS OF HASH TABLE AWAY
	SUBL3	#1,G^LNM$GL_HTBLSIZP,R0 ; CALCULATE UPPER BOUND OF HASH INDEX
	MCOML	R0,LNMHSH$L_MASK(R3)	; STORE HASH INDEX MASK IN HASH TABLE
	MOVW	R7,LNMHSH$W_SIZE(R3)	; STORE HASH TABLE SIZE IN HEADER
	MOVB	#DYN$C_RSHT,-		; STORE HASH TABLE STRUCTURE TYPE IN
		LNMHSH$B_TYPE(R3)	; HASH TABLE HEADER

;
; FIXUP THE PROCESS DIRECTORY LOGICAL NAME TABLE, LNM$PROCESS_DIRECTORY, AND
; LINK IT INTO THE APPROPRIATE HASH BUCKET OF THE PROCESS-PRIVATE LOGICAL NAME
; HASH TABLE.
;

	MOVAB	PROC_DIR_LNMTH(R8),R7	; COMPUTE DIRECTORY'S TABLE HEADER ADDR
	MOVL	R3,LNMTH$L_HASH(R7)	; STORE HASH TABLE ADDR IN TABLE HEADER
	MOVL	R7,LNMB$L_TABLE(R8)	; DIRECTORIES ALWAYS CONTAIN THEMSELVES
	MOVL	R8,LNMTH$L_NAME(R7)	; STORE LNMB ADDRESS IN TABLE HEADER
	MOVL	R7,LNMTH$L_QTABLE(R7)	; DIRECTORIES ARE QUOTA HOLDERS
	MOVL	R8,@#CTL$GL_LNMDIRECT	; STORE ADDR OF PROCESS DIRECTORY AWAY

	MOVAB	LNMB$T_NAME(R8),R1	; RETRIEVE THE SIZE AND ADDRESS OF THE
	MOVZBL	(R1)+,R0		; PROCESS DIRECTORY'S NAME
	JSB	G^LNM$HASH		; HASH THE DIRECTORY NAME

	BICL2	LNMHSH$L_MASK(R3),R0	; MODIFY THE HASH INDEX TO BE IN RANGE
	MOVL	R8,LNMHSH$C_BUCKET(R3)[R0] ; INSERT THE PROCESS DIRECTORY TABLE
	MOVAL	LNMHSH$C_BUCKET(R3)[R0],-  ; INTO THE APPROPRIATE HASH BUCKET
		LNMB$L_BLINK(R8)

;
; FIXUP THE PROCESS LOGICAL NAME TABLE, LNM$PROCESS_TABLE, AND INSERT IT INTO
; THE APPROPRIATE HASH BUCKET OF THE PROCESS-PRIVATE LOGICAL NAME HASH TABLE.
;

	MOVAB	PROC_TABLE(R8),R1	; COMPUTE ADDRESS OF LNM$PROCESS_TABLE
	MOVAB	PROC_TABLE_LNMTH(R8),R9 ; COMPUTE AND SAVE ADDRESS OF LNMTH
	MOVL	R7,LNMB$L_TABLE(R1)	; STORE CONTAINING TABLE HEADER'S ADDR
	MOVL	R3,LNMTH$L_HASH(R9)	; STORE HASH TABLE ADDR IN TABLE HEADER
	MOVL	R1,LNMTH$L_NAME(R9)	; STORE LNMB ADDRESS IN TABLE HEADER
	MOVL	R7,LNMTH$L_PARENT(R9)	; LNM$PROCESS_DIRECTORY IS PARENT AND
	MOVL	R7,LNMTH$L_QTABLE(R9)	; QUOTA HOLDER OF LNM$PROCESS_TABLE
	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$PROCESS_TABLE

;
; FIXUP LNM$PROCESS LNM$GROUP AND LNM$JOB AND INSERT THEM INTO THE APPROPRIATE 
; HASH BUCKET OF THE PROCESS-PRIVATE LOGICAL NAME HASH TABLE. LNM$GROUP AND 
; LNM$JOB REQUIRE THAT THEIR EQUIVALENCE STRINGS BE CONSTRUCTED FROM THE UIC
; AND JIB ADDRESS OF THE NEW PROCESS RESPECTIVELY.
;

	MOVL	(SP),R4			; RESTORE PCB ADDRESS TO R4
	MOVAB	PROCESS(R8),R1		; COMPUTE ADDRESS OF LNM$PROCESS
	MOVL	R7,LNMB$L_TABLE(R1)	; STORE CONTAINING TABLE HEADER'S ADDR
	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$PROCESS

	MOVAB	JOB(R8),R1		; COMPUTE ADDRESS OF LNM$JOB
	MOVL	R7,LNMB$L_TABLE(R1)	; STORE CONTAINING TABLE HEADER'S ADDR
	MOVAB	JOB_XEND_SIZE-1(R1),R3	; COMPUTE ADDRESS OF LAST LNMX
	CLRL	R2			; CLEAR INDEX REGISTER
60$:	EXTZV	R2,#4,PCB$L_JIB(R4),R0	; EXTRACT OUT HEX BITS AND TRANSFORM
	MOVB	CHARS[R0],-(R3)		; THEM INTO THEIR ASCII EQUIVALENT
	ACBB	#31,#4,R2,60$		; CONTINUE FROM RIGHT -> LEFT UNTIL DONE
	MOVL	R3,R10			; SAVE THE ADDRESS OF THE ASCII JIB ADDR
	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$JOB

	MOVAB	GROUP(R8),R1		; COMPUTE ADDRESS OF LNM$GROUP
	MOVL	R7,LNMB$L_TABLE(R1)	; STORE CONTAINING TABLE HEADER'S ADDR
	MOVAB	GROUP_XEND_SIZE-1(R1),R3; COMPUTE ADDRESS OF LAST LNMX
	CLRL	R2			; CLEAR INDEX REGISTER
61$:	EXTZV	R2,#3,PCB$W_GRP(R4),R0	; EXTRACT OUT OCTAL BITS AND TRANSFORM
	MOVB	CHARS[R0],-(R3)		; THEM INTO THEIR ASCII EQUIVALENT
	ACBB	#14,#3,R2,61$		; CONTINUE FROM RIGHT -> LEFT UNTIL DONE
	MOVB	#^A/0/,-(R3)		; ASSUME HIGH ORDER BIT IS 0
	BBC	#15,PCB$W_GRP(R4),62$	; IF SO THEN GO INSERT LNM$GROUP
	MOVB	#^A/1/,(R3)		; OTHERWISE INSERT A 1
62$:	MOVL	R3,R11			; SAVE THE ADDRESS OF THE ASCII GROUP
	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$GROUP

;
; FIXUP THE LOGICAL NAME BLOCKS FOR SYS$INPUT, TT, SYS$OUTPUT, SYS$ERROR, AND
; SYS$DISK, AND INSERT THEM INTO THE APPROPRIATE HASH BUCKET OF THE 
; PROCESS-PRIVATE LOGICAL NAME HASH TABLE.
;

	CRELNM	-			; FIXUP AND INSERT SYS$INPUT
		PQB$T_INPUT,-
		PQB$L_INPUT_ATT,-
		SYS$INPUT_LNMX,-
		SYS$INPUT	
	
	CRELNM	-			; FIXUP AND INSERT SYS$OUTPUT
		PQB$T_OUTPUT,-
		PQB$L_OUTPUT_ATT,-
		SYS$OUTPUT_LNMX,-
		SYS$OUTPUT	
	
	CRELNM	-			; FIXUP AND INSERT SYS$ERROR
		PQB$T_ERROR,-
		PQB$L_ERROR_ATT,-
		SYS$ERROR_LNMX,-
		SYS$ERROR	
	
	CRELNM	-			; FIXUP AND INSERT TT
		PQB$T_INPUT,-
		PQB$L_INPUT_ATT,-
		TT_LNMX,-
		TT	
	
	CRELNM	-			; FIXUP AND INSERT SYS$DISK
		PQB$T_DISK,-
		PQB$L_DISK_ATT,-
		SYS$DISK_LNMX,-
		SYS$DISK

;
; IF THE PROCESS BEING CREATED IS NOT A SUB-PROCESS THEN CREATE THE JOB AND
; GROUP LOGICAL NAME TABLES. 
;

	MOVL	(SP)+,R4		; RETRIEVE PCB ADDRESS
	TSTL	PCB$L_OWNER(R4)		; SUB-PROCESS?
	BNEQ	65$			; IF YES THEN SKIP TABLE CREATION
	MOVL	PQB$L_JTQUOTA(R6),R7	; RETRIEVE JOB TABLE CREATION QUOTA
	BSBW	EXE$CRE_JGTABLE		; CREATE JOB AND GROUP TABLES
	BLBS	R0,65$			; CONTINUE IF SUCCESS
64$:	BRW	VABUG			; OTHERWISE, TAKE COMMON EXIT PATH

;
; ALLOCATE P1 SPACE FOR THE PROCESS-PRIVATE LOGICAL NAME TABLE NAME CACHE
;

65$:	MULL3	#8,G^LNM$GL_HTBLSIZP,R1	; ALLOCATE TWICE HASH TABLE SIZE
	DIVL3	#LNMC$K_LENGTH,R1,R8	; COMPUTE # OF ENTRIES
	BEQL	67$			; IF ANY
	JSB	G^EXE$ALOP1PROC		; ALLOCATE TOTAL AMOUNT OF SPACE NEEDED
	BLBC	R0,64$			; IF POSSIBLE
66$:	MOVW	#LNMC$K_LENGTH,LNMC$W_SIZE(R2)	; SET SIZE
	CLRL	LNMC$L_TBLADDR(R2)		; MARK EMPTY
	INSQUE	(R2),@#CTL$GQ_LNMTBLCACHE	; INSERT IN QUEUE	
	ADDL2	#LNMC$K_LENGTH,R2		; POINT TO NEXT
	SOBGTR	R8,66$			; LOOP

;
; RESTORE PCB AND PHD ADDRESS, SET IPL TO 0 TO ALLOW FOR PROCESS DELETION
; (IF DESIRED), RESET ADDRESS SPACE, AND SET WSLAST.
;

67$:	MOVL	(SP)+,R5		; RESTORE PHD ADDRESS

	MOVAL	@#MMG$IMGHDRBUF,AP	; IMAGE HEADER BUFFER ADDRESS
	JSB	G^MMG$IMGRESET		; RESET ADDRESS SPACE AND SET WSLAST

; THE FOLLOWING MOVC SEQUENCES DESTROY R0 THROUGH R5

IMGNAM:	MOVZBL	PQB$T_IMAGE(R6),(AP)	; SIZE OF IMAGE NAME STRING
	MOVAL	8(AP),4(AP)		; ADDRESS OF IMAGE NAME STRING
	MOVC3	(AP),PQB$T_IMAGE+1(R6),8(AP) ; MOVE THE NAME STRING

	TSTB	PQB$T_DDSTRING(R6)	; CHECK FOR NULL STRING
	BEQL	70$			; YES, DONT MOVE ANYTHING
	MOVC3	#PQB$S_DDSTRING,-
		PQB$T_DDSTRING(R6),@#PIO$GT_DDSTRING ; AND DEFAULT DIRECTORY
70$:					; CONTINUE

; Move CLI and CLI table information to P1 space in one fell swoop:
;	PQB$T_CLI_NAME    -> CTL$GT_CLINAME
;	PQB$T_CLI_TABLE   -> CTL$GT_TABLENAME
;	PQB$T_SPAWN_CLI   -> CTL$GT_SPAWNCLI
;	PQB$T_SPAWN_TABLE -> CTL$GT_SPAWNTABLE

	ASSUME PQB$T_CLI_TABLE   EQ <PQB$T_CLI_NAME  + PQB$S_CLI_NAME>
	ASSUME PQB$T_SPAWN_CLI   EQ <PQB$T_CLI_TABLE + PQB$S_CLI_TABLE>
	ASSUME PQB$T_SPAWN_TABLE EQ <PQB$T_SPAWN_CLI + PQB$S_SPAWN_CLI>

	MOVC3	#<PQB$S_CLI_NAME+-
		  PQB$S_CLI_TABLE+-
		  PQB$S_SPAWN_CLI+-
		  PQB$S_SPAWN_TABLE>,-
		PQB$T_CLI_NAME(R6),@#CTL$GT_CLINAME

; STORE EVERYTHING ELSE OF INTEREST BEFORE WE GET RID OF THE PQB

	MOVL	PQB$L_CREPRC_FLAGS(R6),@#CTL$GL_CREPRC_FLAGS
	MOVL	PQB$L_UAF_FLAGS(R6),@#CTL$GL_UAF_FLAGS

; ****************************** TEMP ****************************** 
;
; THE FOLLOWING CODE WILL BE REMOVED WHEN WE DECIDE WHAT TO DO WITH THE
; ACCOUNT AND USERNAME FIELDS IN THE P1 POINTER PAGE.
;
	assume jib$t_account eq <jib$t_username + jib$s_username>

	movl	g^ctl$gl_pcb,r0		; get pcb address ...
	movl	pcb$l_jib(r0),r0	; so that we can get jib address
	movc3	#<jib$s_username + jib$s_account>,-
		jib$t_username(r0),- 	; move username and account 
		@#ctl$t_username 	; in one instruction
;
; **************************** END TEMP ****************************

	INSQUE	(R6),@EXE$GL_PQBBL	; DEALLOCATE PQB TO LOOKASIDE LIST
	SETIPL	#0			; DROP IPL AND ALLOW PROCESS DELETION

;
; INITIALIZE FIXUP VECTOR LINKED LISTS TO CONTAIN A SINGLE DUMMY ENTRY
;

	MOVAL	@#CTL$GL_IAFPERM,@#CTL$GL_IAFLINK
	MOVAL	@#CTL$GL_IAFPERM,@#CTL$GL_IAFLAST

;
; INITIALIZE ARRAYS THAT DETERMINE HOW PRIVILEGED VECTORS ARE RESET
;
	MOVAW	@#IAC$AW_VECRESET,R0	; STORE RESET ARRAY ADDRESS
	MOVW	#4,(R0)+		; KERNEL VECTOR
	MOVW	#4,(R0)+		; EXEC VECTOR
	MOVW	#4,(R0)+		; RUNDOWN VECTOR
	MOVW	#4,(R0)+		; MESSAGE VECTOR

	MOVAW	@#IAC$AW_VECSET,R0	; STORE START ARRAY ADDRESS
	MOVW	#4,(R0)+		; KERNEL VECTOR
	MOVW	#4,(R0)+		; EXEC VECTOR
	MOVW	#4,(R0)+		; RUNDOWN VECTOR
	MOVW	#4,(R0)+		; MESSAGE VECTOR

EXE$PROCIMGACT::			; ENTRY POINT FOR STAND-ALONE SYSGEN
	MOVL	@#CTL$GL_PCB,R4		; GET PCB ADDRESS
	EXTZV	#PCB$V_HIBER,#1,PCB$L_STS(R4),R8; SAVE HIBERNATE CONTROL
	CALLS	#0, XQPMERGE		; MERGE XQP INTO PROCESS
	BBC	S^#EXE$V_INIT, G^EXE$GL_FLAGS, 72$ ; DON'T MERGE IF NOT INIT
	BLBC	R0, 75$			; EXIT IF MERGE FAILS
72$:	ROTL	#PSL$V_PRVMOD,#<PSL$C_EXEC@2+PSL$C_EXEC>,-(SP) ; FORM EXEC PSL
	BSBB	80$			; CHANGE MODE TO EXECUTIVE

; ********** THE FOLLOWING CODE EXECUTES IN EXEC MODE **********

	MOVZBL	(AP),R2			; GET ADR OF FILENAME STRING DESC
	ADDL	#3,R2			; ROUND THE NUMBER OF BYTES IN
	BICL	#3,R2			; THE NAME UP TO A LONGWORD BOUNDRY
	SUBL	R2,SP			; ALLOCATE SPACE FOR NAME ON STACK
	PUSHAB	(SP)			; BUILD STRING DESCRIPTOR FOR
	MOVZBL	(AP),-(SP)		; FILENAME ON THE STACK
	MOVL	SP,R1			; GET ADR OF STRING DESCRIPTOR
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC3	R2,@4(AP),@4(R1)	; MOVE FILENAME TO STACK
	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	$IMGACT_S -			; ACTIVATE THE IMAGE
		NAME  =(AP),-		; DESCRIPTOR FOR IMAGE NAME
		DFLNAM=DEFDESC,-	; DEFAULT NAME DESCRIPTOR
		HDRBUF=(AP)		; ADDRESS IF IMAGE HEADER BUFFER
	ADDL	#8,R2			; CALCULATE # OF BYTES ON STACK
	ADDL	R2,SP			; AND CLEAN THEM OFF
	BLBC	R0,75$			; BRANCH IF IMGACT FAILED
	MOVAB	@#PIO$AL_RMSEXH,R0	; GET ADDRESS OF EXIT HANDLER CONTROL BLOCK
	MOVAB	W^EXE$RMSEXH,4(R0)	; SET ADDRESS OF RMS EXIT HANDLER
	$DCLEXH_S (R0)			; DECLARE EXEC MODE EXIT HANDLER
75$:	BLBC	R0,120$			; IF LBC ERROR
	MOVAB	W^EXE$CLI_UTILSRV+2,G^CTL$AL_CLICALBK ; SET CLI CALL BACK ADDRESS
	ROTL	#PSL$V_PRVMOD,#<PSL$C_USER@2+PSL$C_USER>,-(SP) ; FORM USER PSL
	BSBB	80$			; CHANGE TO USER MODE

; ********** THE FOLLOWING CODE EXECUTES IN USER MODE **********

	CLRL	FP			; TERMINATE CALL FRAME CHAIN
	CALLG	(AP),B^90$		; CREATE TOP FRAME
80$:	REI				; CHANGE TO NEW MODE
90$:	.WORD	0			; ENTRY MASK 
	MOVAB	B^EXE$CATCH_ALL,(FP)	; SET EXCEPTION HANDLER ADDRESS
	$SETEXV_S #2,B^EXE$CATCH_ALL	; DECLARE LAST CHANCE HANDLER
	$IMGFIX_S			; PERFORM ADDRESS RELOCATION
	BLBC	R0,120$			; QUIT IF ERROR OCCURS
	PUSHL	R8			; SAVE HIBERNATE FLAG
100$:	MOVQ	(AP),R2			; GET IMAGE HEADER BLOCK DESCRIPTOR
	CLRL	-(SP)			; CLEAR COMMAND INTERPRETER FLAGS
	PUSHL	IHD$L_LNKFLAGS(R2)	; PUSH LINKER FLAGS
	MOVQ	R2,-(SP)		; THIRD AND FOURTH ARGUMENTS TO PROG
	PUSHAB	B^EXE$CLI_UTILSRV	; PUSH ADDRESS OF CLI CALL BACK ROUTINE
	MOVZWL	IHD$W_ACTIVOFF(R2),R1	; OFFSET TO TRANSFER VECTOR
	ADDL	R1,R2			; FORM ADDRESS OF START VECTOR
	PUSHAL	(R2)			; MOVE TO ARGUMENT LIST
	BLBC	24(SP),110$		; BR IF NO HIBERNATE
	$HIBER_S			; SET, HIBERNATE UNTIL SOME WAKE
110$:	CALLS	#6,@(R2)+		; CALL IMAGE
	BLBC	R0,120$			; EXIT IF NOT SUCCESS
	BLBS	(SP),100$		; CHECK FOR HIBERNATE AGAIN
120$:	BRB	EXE$EXIT_IMAGE		;
 
;
; DUMMY COMMAND INTERPRETER CALL BACK ROUTINE
;
 
	.ENTRY	EXE$CLI_UTILSRV,^M<>
	MOVL	#CLI$_INVREQTYP,R0	; SET INVALID REQUEST TYPE STATUS
	RET				;
	.DSABL	LSB
	.PAGE

	.SBTTL	EXIT IMAGE AND RUN DOWN FILES
;+
;
; EXE$EXIT_IMAGE - EXIT IMAGE AND RUN DOWN FILES
;
; THIS ROUTINE IS JUMPED TO AT THE CONCLUSION OF IMAGE EXECUTION TO RUN DOWN
; RMS FILES AND TO RETURN THE FINAL IMAGE STATUS.
;
; INPUTS:
;
;	R0 = FINAL IMAGE STATUS.
;
; OUTPUTS:
;
;	IMAGE EXIT IS EXECUTED.
;-
 
EXE$EXIT_IMAGE::			; EXIT IMAGE
	PUSHL	R0			; SAVE FINAL IMAGE STATUS
	PUSHL	#1			; SET NUMBER OF ARGUMENTS
10$:	CALLG	(SP),@#SYS$EXIT		; EXIT IMAGE
	BRB	10$			;
	.PAGE

	.SBTTL	CATCH ALL CONDITION HANDLER
;+
; EXE$CATCH_ALL - CATCH ALL CONDITION HANDLER
;
; THIS ROUTINE IS ENTERED AS THE RESULT OF AN UNFIELDED OR IMPROPERLY HANDLED
; EXCEPTION CONDITION OR SOFTWARE SIGNAL.
;
; INPUTS:
;
;	CHF$L_MCHARGLST(AP) = ADDRESS OF MECHANISM ARGUMENT LIST.
;	CHF$L_SIGARGLST(AP) = ADDRESS OF CONDITION ARGUMENT LIST.
;
; OUTPUTS:
;
;	A MESSAGE IS ISSUED USING THE SYS$PUTMSG SYSTEM SERVICE AND A TEST IS
;	MADE ON THE CONDITION NAME TO DETERMINE IF THE IMAGE SHOULD BE ALLOWED
;	TO CONTINUE EXECUTION. THE FOLLOWING CONDITIONS CAUSE A FORCED IMAGE
;	EXIT:
;
;		1. ANY ENTRY TO THIS ROUTINE VIA THE LAST CHANCE VECTOR.
;
;		2. THE CONDITION NAME HAS A SEVERITY OF "SEVERE ERROR".
;
;	IF A FORCED IMAGE EXIT IS PERFORMED, THEN A SUMMARY OF THE CONDITION
;	ARGUMENTS AND FINAL REGISTERS ARE WRITTEN TO SYS$OUTPUT.
;-
 
	.ENTRY	EXE$CATCH_ALL,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	PUSHL	#0			; SET EXCEPTION NAME FLAG FALSE
	PUSHL	R2			; SAVE REGISTER
	MOVL	CHF$L_SIGARGLST(AP),R2	; GET ADDRESS OF SIGNAL ARGUMENTS
	PUSHL	(R2)			; SAVE NUMBER OF ARGUMENTS
	CMPW	CHF$L_SIG_NAME(R2),#SS$_SSFAIL	; IS EXCEPTION SYS. SERV. FAIL.?
	BNEQ	5$			; NO
	$SETSFM_S	#0		; YES, TURN OFF SYS. SERV. FAIL. EXCEP.
5$:	TSTW	CHF$L_SIG_NAME+2(R2)	; POSSIBLY SYSTEM EXCEPTION NAME?
	BNEQ	20$			; IF NEQ NO
	INCL	8(SP)			; SET EXCEPTION NAME FLAG TRUE
	MOVAB	L^EXE$EXCEPTABLE,R1	; GET ADDRESS OF EXCEPTION TABLE
	MOVZBL	(R1)+,R0		; SET LOOP COUNT
10$:	TSTB	(R1)+			; SKIP NUMBER OF ARGUMENTS
	MOVZWL	(R1)+,-(SP)		; GET NEXT HARDWARE EXCEPTION CODE
	CMPZV	#STS$V_CODE,#STS$S_CODE,- ; CONDITION VALUE HARDWARE CODE?
		CHF$L_SIG_NAME(R2),(SP)+ ;
	BEQL	30$			; IF EQL YES
	SOBGTR	R0,10$			; ANY MORE TO COMPARE?
	CLRL	8(SP)			; SET EXCEPTION NAME FALG FALSE
20$:	SUBL	#2,(R2)			; ADJUST LENGTH OF ARGUMENT LIST
30$:	TSTB	@#CTL$GB_SSFILTER	; SYSTEM SERVICE INHIBITED NOW?
	BNEQ	35$			; YES, DO NOT TRY TO PRINT ANYTHING
	PUSHL	#0			; CLEAR ADDRESS OF FACILITY NAME DESCRIPTOR
	PUSHL	#0			; CLEAR ADDRESS OF ACTION ROUTINE
	PUSHAB	(R2)			; SET ADDRESS OF MESSAGE VECTOR
	CALLS	#3,@#SYS$PUTMSG		; OUTPUT MESSAGE
35$:	POPL	(R2)			; RESTORE ARGUMENT COUNT
	MOVL	CHF$L_SIG_NAME(R2),R0	; GET CONDITION NAME
	POPL	R2			; RESTORE REGISTER
	MOVL	CHF$L_MCHARGLST(AP),R1	; GET ADDRESS OF MECHANISM ARRAY
	ADDL3	#3,CHF$L_MCH_DEPTH(R1),-(SP) ; LAST CHANCE ENTRY?
	BEQL	50$			; IF EQL YES
	BLBS	R0,40$			; IF LBS SUCCESS CODE
	CMPZV	#STS$V_SEVERITY,#STS$S_SEVERITY,- ; SEVERE ERROR OR GREATER?
		R0,#STS$K_SEVERE 	;
	BGEQ	50$			; IF GEQ YES
40$:	MOVZWL	#SS$_CONTINUE,R0	; SET CONTINUATION CODE
	RET				;

50$:	PUSHL	R0			; SAVE EXCEPTION NAME
	TSTB	@#CTL$GB_SSFILTER	; SYSTEM SERVICES INHIBITED NOW?
	BNEQ	70$			; YES, DON'T TRY TO PRINT ANYTHING
	BLBC	8(SP),60$		; IF LBC NOT EXCEPTION
	PUSHAB	(AP)			; SET ADDRESS OF SIGNAL ARGUMENTS
	PUSHAB	SUFFIX			; SET ADDRESS OF MESSAGE SUFFIX
	CALLS	#2,EXE$EXCMSG		; OUTPUT EXCEPTION SUMMARY
60$:	BSBW	EXE$IMGDMP_MERGE	; TRY TO TAKE A DUMP
70$:	POPL	R0			; RESTORE EXCEPTION NAME
	BBSS	#STS$V_INHIB_MSG,R0,80$	; SET INHIBIT MESSAGE BIT
80$:	BRW	EXE$EXIT_IMAGE		;
	.PAGE

	.SBTTL EXE$RMSEXH - EXEC Mode Exit Handler
;+
; EXE$RMSEXH - Executive mode exit handler
;
; This routine is called as the result of an attempt to exit from exec mode.
; It's function is to run down all RMS files.
;
; INPUTS:
;	
;	NONE.
;
; OUTPUTS:
;
;	NONE.
;
; SIDE EFFECTS:
;	
;	RMS files are run down.
;-

	.ENTRY	EXE$RMSEXH,^M<>
	MOVAB	-128(SP),SP		; ALLOCATE STRING BUFFER
	PUSHAB	(SP)			; BUILD BUFFER DESCRIPTOR
	PUSHL	#0			; 
10$:	MOVZBL	#128,(SP)		; SET LENGTH OF STRING BUFFER
	PUSHL	#1			; RUN DOWN IMAGE AND ALL PPFS
	PUSHAB	4(SP)			; PUSH ADDRESS OF BUFFER DESCRIPTOR
	CALLS	#2,@#SYS$RMSRUNDWN	; RUN DOWN THE NEXT FILE
	CMPL	R0,#RMS$_BUSY		; BUSY ERROR IMPLIES DON'T TRY
	BEQL	20$			;  TO DO RUNDOWN AT ALL
	BLBC	R0,10$			; IF LBC, THEN MORE TO GO
20$:	RET

	.PAGE

	.SBTTL XQPMERGE - Merge the XQP into P1 Space
;++
; FUNCTIONAL DESCRIPTION:
;
; This routine merges the XQP into P1 space. 
;
; The number of global sections specified by XQP$GL_SECTIONS is mapped into
; the end of P1 space.  The sections have names of the form SYSXQP_nnn where
; nnn ranges from zero to XQP$W_SECTIONS-1.  The section is mapped writeable-CRF
; if the corresponding bit in XQP$GL_SECPROT is set.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,XQPMERGE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUT:
;
;	none
;
; OUTPUT PARAMETERS:
;
;	none
;
; IMPLICIT OUTPUT:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 low bit set => XQP successfully merged
;
;		SS$_NORMAL
;
;	R0 low bit clear => Error occurred while merging XQP
;
;		Various errors returned by $IMGACT and $MGBLSC
;
; SIDE EFFECTS:
;
;	The permanent portion of P1 space is
;	expanded to accommodate the merged image. 
;
;--

XQPMERGE:
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;REGISTER SAVE MASK
;
	TSTL	XQP$GL_DZRO		;IS THERE ANY DZRO
	BEQL	5$			;NO
	$EXPREG_S -			;CREATE THE XQP OWN STORAGE
		PAGCNT = XQP$GL_DZRO,-
		REGION = #1,-
		ACMODE = #PSL$C_EXEC
	BLBC	R0,20$
;
5$:	SUBL	#<XQP_NAMSIZ+3>&^C3,SP	;RESERVE SPACE FOR GSD NAME
	MOVL	SP,R6			;SAVE ADDRESS OF GSD NAME
	MOVC3	#XQP_NAMSIZ,XQP_NAM,(R6) ;PUT GSD NAME IN WRITEABLE STORAGE
	MOVL	XQP$GL_SECTIONS,R3	;COUNT OF SECTIONS TO MAP
	ADDB	R3,XQP_NAMSIZ-1(R6)	;START WITH LAST GSD NAME
	PUSHL	R6			;BUILD DESCRIPTOR FOR GSD NAME
	PUSHL	#XQP_NAMSIZ
	MOVL	SP,R2			;ADDRESS OF DESCRIPTOR
	MOVL	#^X7FFFFFFF,-(SP)	;END VA FOR BLUEPRINT P0 VA RANGE
	MOVL	(SP),-(SP)		;START VA FOR BLUEPRINT P0 VA RANGE
	MOVL	SP,R4			;ADR OF INPUT VA RANGE
	CLRQ	-(SP)			;RETURN VA RANGE
	MOVL	SP,R5			;ADR OF RETURN VA RANGE
	DECL	R3			;MAKE COUNT ZERO-BASED
10$:	DECB	XQP_NAMSIZ-1(R6)	;NEXT GSD NAME
	$MGBLSC_S -
		INADR  = (R4),-
		RETADR = (R5),-
		FLAGS  = #<SEC$M_EXPREG!SEC$M_SYSGBL>,-
		GSDNAM = (R2),-
		ACMODE = #PSL$C_EXEC
	BLBC	R0,20$
	SOBGEQ	R3,10$
;
	MOVL	(R5),G^CTL$GL_CTLBASVA	;SET A NEW CONTROL REGION BASE
	JMP	@(R5)			;XQP SELF-INITIALIZATION
20$:	RET				; AND RETURN TO CALLER

XQP_NAM:
	.ASCII	/SYSXQP_000/
	XQP_NAMSIZ = .-XQP_NAM
	.PAGE

	.SBTTL	IMAGE DUMP MERGE
;+
; EXE$IMGDMP_MERGE - MERGE IN THE IMAGE DUMP FACILITY AND CALL IT
;
; THIS ROUTINE IS ENTERED AS THE RESULT OF A FATAL CONDITION WHICH WILL FORCE
; IMAGE EXIT
;
; INPUTS:
;
;	CHF$L_MCHARGLST(AP) = ADDRESS OF MECHANISM ARGUMENT LIST.
;	CHF$L_SIGARGLST(AP) = ADDRESS OF CONDITION ARGUMENT LIST.
;
; OUTPUTS:
;
;	AFTER PRIVILEGE CHECKS, THE IMAGE DUMP FACILITY IS MERGED INTO THE 
;	ADDRESS SPACE AND CALLED.
;
;-

EXE$IMGDMP_EXEC::			; EXEC MODE ENTRY POINT
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRB	EXEC_M

	.ENABL	LSB

EXE$IMGDMP_MERGE::
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVPSL	R0			; GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R0,R0
	CMPL	R0,#PSL$C_USER		; IS IT USER MODE
	BNEQ	5$			; NO - DUMP NOT ALLOWED
EXEC_M:	MOVAL	-SCRATCHSIZE(SP),SP	; RESERVE SCRATCH SPACE ON STACK
	MOVL	SP,R6
	MOVC5	#0,(SP),#0,#SCRATCHSIZE,(SP) ; ZERO IT
	MOVL	#<JPI$_PROCPRIV@16>+4,JPI_PROC(R6) ;INITIALIZE TO GET PROCESS PRIV
	MOVAB	PROCPRIV(R6),JPI_PROC+4(R6)
	MOVL	#<JPI$_IMAGPRIV@16>+4,JPI_IMAG(R6) ;INITIALIZE TO GET IMAGE PRIV
	MOVAB	IMAGPRIV(R6),JPI_IMAG+4(R6)
	MOVL	#<JPI$_PHDFLAGS@16>+4,JPI_FLAG(R6) ;INITIALIZE TO GET PHD FLAGS
	MOVAB	PHD_FLAGS(R6),JPI_FLAG+4(R6)
	MOVAB	JPI_PROC(R6),R0	; ADDRESS OF ITEM LIST
	$GETJPI_S EFN = #EXE$C_SYSEFN,-
		  ITMLST = (R0)
	BLBS	R0,10$
5$:	BRW 30$				; ERROR - GIVE UP
10$:	BBC	#PHD$V_IMGDMP,PHD_FLAGS(R6),5$ ; NO DUMP REQUESTED	
	BICL	PROCPRIV(R6),IMAGPRIV(R6) ; TEST THAT IMAGE PRIVILEGES AREN'T GREATER
	BICL	PROCPRIV+4(R6),IMAGPRIV+4(R6)
	BISL	IMAGPRIV+4(R6),IMAGPRIV(R6)
	BEQL	20$			; NO EXCESS IMAGE PRIVILEGES
	BBS	#PRV$V_CMKRNL,PROCPRIV(R6),20$
	BBS	#PRV$V_SETPRV,PROCPRIV(R6),20$
	BRB	5$			; INSUFFICIENT PRIVILEGES
20$:	MOVL	#IMGACT$_NARGS,(R6)	; SET ARGUMENT COUNT FOR $IMGACT CALL
	MOVAB	IMGDMPNAM,IMGACT$_NAME(R6) ; SET ADR OF INPUT FILE NAME DESC
	MOVAB	DEFAULTNAMDSC,IMGACT$_DFLNAM(R6) ; SET ADR OF DEFAULT NAME STR
	MOVL	#<IAC$M_MERGE ! IAC$M_EXPREG>,IMGACT$_IMGCTL(R6) ; SET CTL FLAGS
	MOVAB	HDRBUF(R6),IMGACT$_HDRBUF(R6) ; SET ADR OF IMAGE HEADER BUFFER
	MOVAB	IMGACT_INADR(R6),IMGACT$_INADR(R6) ; SET ADR OF INPUT VA RANGE
	MOVAB	IMGACT_RETADR(R6),IMGACT$_RETADR(R6) ; SET ADR OF RETURN RANGE
	CLRL	IMGACT$_IDENT(R6)	; NO MATCH IDENT SPECIFIED
	MOVZWL	#^X200,IMGACT_INADR(R6) ; SET A BLUEPRINT P0 ADDRESS RANGE FOR
	MOVL	#1@30-1,IMGACT_INADR+4(R6) ; MAPPING TO FIRST FREE VA SPACE
	$IMGACT_G (R6)			; MAP IN THE DUMP IMAGE
	BLBC	R0,30$			; ERROR - GIVE UP
	$IMGFIX_S
	BLBC	R0,30$
	MOVL	IMGACT_RETADR(R6),R1	; START OF THE MERGED IN CODE
	ADDL3	8(R1),R1,R1		; START ADDRESS OF THE DUMP ROUTINE
	MOVAL	SCRATCHSIZE(R6),SP	; GET RID OF SCRATCH STORAGE
	JSB	(R1)
	BRB	40$
;
30$:	MOVAL	SCRATCHSIZE(R6),SP	; GET RID OF SCRATCH STORAGE
40$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	RSB
	.DSABL	LSB

	.SBTTL CRELNM - FIXUP AND INSERT A LOGICAL NAME BLOCK
;++
; FUNCTIONAL DESCRIPTION:
;
; THE PURPOSE OF THIS ROUTINE IS TO FIXUP A LNMB FOR A LOGICAL NAME AND INSERT 
; IT INTO THE APPROPRIATE HASH BUCKET OF THE PROCESS-PRIVATE LOGICAL NAME HASH 
; TABLE. THE LOGICAL NAME BEING FIXED REQUIRES THAT ITS EQUIVALENCE STRING BE 
; MOVED FROM THE PQB INTO THE STORAGE ALLOCATED FOR IT. IF THE LENGTH OF THE 
; EQUIVALENCE STRING IS 0 THEN THE BLOCK OF STORAGE FOR THIS LOGICAL NAME IS 
; DEALLOCATED AND THE ROUTINE EXITS.
;
; CALLING SEQUENCE:
;
;	BSBW	CRELNM
;	.WORD	PQB$T_<OFFSET>
;	.WORD	PQB$T_<OFFSET>_ATT
;	.WORD	<NAME>_LNMX - PROC_DIR
;	.WORD	<NAME> - PROC_DIR
;
; INPUT PARAMETERS:
;
;	R6	- ADDRESS OF PQB
;	R7	- ADDRESS OF PROCESS DIRECTORY'S TABLE HEADER
;	R8	- ADDRESS OF ALLOCATED P1 STORAGE
;	R9	- ADDRESS OF PROCESS TABLE'S TABLE HEADER
;
; IMPLICIT INPUT:
;
;	IT IS ASSUMED THAT THE LOGICAL NAME BEING CREATED HAS ALREADY BEEN
;	FORMATTED WITH THE EXCEPTION OF:
;
;	1. THE CONTAINING TABLE ADDRESS WITHIN ITS LNMB.
;	2. THE TRANSLATION STRING AND ATTRIBUTES WITHIN ITS LNMX.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUT:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;
;	R0 - R3, R5, AND AP ARE DESTROYED.
;--

CRELNM:					; FIXUP AND INSERT THE LOGICAL NAME
	MOVL	(SP),AP			; RETRIEVE ARGUEMENT POINTER
	ADDL2	#8,(SP)			; CORRECT RETURN PC VALUE
	MOVZWL	(AP)+,R1		; RETRIEVE OFFSET TO TRANSLATION
	MOVZBL	(R6)[R1],R0		; RETRIEVE THE SIZE OF THE TRANSLATION
	BNEQ	10$			; IF ITS NOT 0 THEN CONTINUE
	MOVZWL	4(AP),R0		; RETRIEVE OFFSET TO LNMB
	ADDL2	R8,R0			; COMPUTE ADDRESS OF LNMB
	MOVZWL	LNMB$W_SIZE(R0),R1	; RETRIEVE SIZE OF BLOCK TO DEALLOCATE
	JSB	EXE$DEAP1		; DEALLOCATE THE LNMB 
	BRB	20$			; GO RETURN

10$:	MOVZWL	(AP)+,R2		; RETRIEVE OFFSET TO TRANSLATION ATTRIBUTES
	MOVZWL	(AP)+,R3		; RETRIEVE OFFSET TO LNMX
	MOVB	1(R6)[R2],-		; STORE THE TRANSLATION ATTRIBUTES FROM
		LNMX$B_FLAGS(R8)[R3]	; THE PQB INTO THEN LNMX FLAG FIELD
	INCL	R0			; MOVE COUNT ALONG WITH TRANSLATION
	MOVC3	R0,(R6)[R1],-		; MOVE TRANSLATION COUNT AND STRING FROM
		LNMX$T_XLATION(R8)[R3]	; THE PQB INTO THE APPROPRIATE LNMX FIELD
	MOVZWL	(AP)+,R1		; RETRIEVE OFFSET TO LNMB
	ADDL2	R8,R1			; COMPUTE ADDRESS OF LNMB
	MOVL	R9,LNMB$L_TABLE(R1)	; STORE CONTAINING TABLE HEADER'S ADDR
	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	LNM$INSLOGTAB		; APPROPRIATELY INSERT SYS$ERROR
20$:	RSB				; RETURN

	.SBTTL EXE$CRE_JGTABLE - CREATE GROUP AND JOB-WIDE LOGICAL NAME TABLES
;++
; FUNCTIONAL DESCRIPTION:
;
; THE PURPOSE OF THIS ROUTINE IS TO HANDCRAFT GROUP AND JOB-WIDE LOGICAL
; NAME TABLES AND DIRECT THEIR INSERTION INTO THE APPROPRIATE HASH BUCKET
; OF THE SYSTEM LOGICAL NAME HASH TABLE. GROUP LOGICAL NAME TABLES ARE INSERTED
; SUCH THAT IF THERE IS AN EXISTING GROUP TABLE FOR THAT GROUP, THE CALLER OF
; THIS ROUTINE IS MAPPED TO IT.
;
; CALLING SEQUENCE:
;
;	BSBW	EXE$CRE_JGTABLE
;
; INPUT PARAMETERS:
;
;	R7	- JOB TABLE QUOTA
;	R10	- ADDRESS OF ASCII EQUIVALENT OF JIB ADDRESS
;	R11	- ADDRESS OF ASCII EQUIVALENT OF GROUP NUMBER
;
; IMPLICIT INPUT:
;
;	LNM_SYSTEM_DIR_LNMTH	- ADDRESS OF SYSTEM DIRECTORY TABLE HEADER
;
;	LNM$AL_HASHTBL		- ADDRESS OF POINTER TO SYSTEM HASH TABLE
;
;	SCH$GL_CURPCB		- ADDRESS OF PCB
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUT:
;
;	R4			- ADDRESS OF PCB
;
; COMPLETION CODES:
;
;	1		- SUCCESS
;	SS$_EXLNMQUOTA	- INSUFFICIENT QUOTA IN SYSTEM DIRECTORY TABLE
;	SS$_INSFMEM	- INSUFFICIENT PAGED POOL TO ALLOCATE LNMBS
;
; SIDE EFFECTS:
;
;	R0 - R5 AND R8 ARE DESTROYED.
;
;	THE JOB-WIDE LOGICAL NAME TABLE WILL HAVE BEEN CREATED POTENTIALLY
;	RESULTING IN THE DELETION OF ANY SHAREABLE TABLE WITH THE SAME NAME.
;
;	THE GROUP LOGICAL NAME TABLE WILL HAVE BEEN CREATED PROVIDED A GROUP
;	TABLE WITH THAT NAME DOES NOT ALRADY EXIST IN WHICH CASE NOTHING IS
;	DONE.
;
;--

	.ENABL	LSB

EXE$CRE_GTABLE::

;
; THIS ROUTINE EXE$CRE_GTABLE IS IDENTICAL TO THE ROUTINE EXE$CRE_JGTABLE
; WITH EXCEPTION THAT THE JOB LOGICAL NAME TABLE IS NOT CREATED. THUS THE
; ONLY INPUT PARAMETER IS R11, WHICH HAS THE ADDRESS OF ASCII EQUIVALENT 
; OF GROUP NUMBER.
;

	MOVZWL	#GROUP_TABLE_SIZE,R1	; SET SIZE OF GROUP TABLE TO BE CREATED
	JSB	G^EXE$ALOPAGED		; ALLOCATE REQUIRED AMOUNT OF PAGED POOL
	BLBS	R0,2$			; CONTINUE IF ALLOCATION IS SUCCESSFUL
	MOVZWL	#SS$_INSFMEM,R0		; OTHERWISE SETUP R0 WITH ERROR CODE
	BRW	40$			; AND EXIT

2$:	MOVL	G^SCH$GL_CURPCB,R4	; RETRIEVE PCB ADDRESS 
	JSB	G^LNM$LOCKW		; LOCK LOGICAL NAME MUTEX FOR WRITING

	CMPL	R1,LNMTH$L_BYTES+-	; IS THERE ENOUGH QUOTA IN THE SYSTEM
		LNM_SYSTEM_DIR_LNMTH	; DIRECTORY TABLE?
	BLEQ	4$			; CONTINUE IF ENOUGH QUOTA
	MOVL	R2,R0			; SETUP TO DEALLOCATE THE PAGED POOL
	JSB	G^EXE$DEAPGDSIZ		; DEALLOCATE IT
	JSB	G^LNM$UNLOCK		; UNLOCK THE LOGICAL NAME MUTEX
	MOVZWL	#SS$_EXLNMQUOTA,R0	; SETUP REASON FOR PREMATURE TERMINATION
	BRW	40$			; AND GO RETURN TO CALLER
	
4$:	MOVL	R2,R8			; SAVE ADDRESS OF STORAGE ALLOCATED
	MOVC3	R1,GROUP_TABLE,(R2)	; FORMAT THE LOGICAL NAME TABLE(S)
	MOVL	G^SCH$GL_CURPCB,R4	; RETRIEVE PCB ADDRESS 
	BRW	CREATE_GTABLE		; GO CREATE GROUP TABLE

EXE$CRE_JGTABLE::	

;
; ALLOCATE PAGED POOL FOR THE GROUP AND JOB-WIDE LOGICAL NAME TABLES. AFTER 
; ALLOCATING SUFFICIENT PAGED POOL, WRITE LOCK THE LOGICAL NAME MUTEX, AND MAKE
; SURE THAT THE PARENT LOGICAL NAME TABLE, THE SYSTEM DIRECTORY TABLE, HAS 
; SUFFICIENT QUOTA FOR THE CREATION OF BOTH LOGICAL NAME TABLES AND FOR ANY 
; SEPARATE QUOTA THAT WILL BE RELEGATED TO THEM. IF THE SYSTEM DIRECTORY TABLE 
; DOES NOT CONTAIN SUFFICIENT QUOTA THEN EXIT IMMEDIATELY WITH THE APPROPRIATE
; ERROR; OTHERWISE, THE BLOCK OF STORAGE THAT HAS BEEN ALLOCATED FOR THE LOGICAL
; NAME TABLES IS FORMATED.
;

	MOVZWL	#S0_ALLOC_SIZE,R1	; ASSUME BOTH TABLES WILL BE CREATED
	JSB	G^EXE$ALOPAGED		; ALLOCATE REQUIRED AMOUNT OF PAGED POOL
	BLBS	R0,1$			; CONTINUE IF ALLOCATION IS SUCCESSFUL
	MOVZWL	#SS$_INSFMEM,R0		; OTHERWISE SETUP R0 WITH ERROR CODE
	BRB	10$			; AND EXIT

1$:	MOVL	G^SCH$GL_CURPCB,R4	; RETRIEVE PCB ADDRESS 
	JSB	G^LNM$LOCKW		; LOCK LOGICAL NAME MUTEX FOR WRITING

	ADDL3	R7,R1,R0		; DETERMINE TOTAL AMOUNT OF QUOTA 
	CMPL	R0,LNMTH$L_BYTES+-	; IS THERE ENOUGH QUOTA IN THE SYSTEM
		LNM_SYSTEM_DIR_LNMTH	; DIRECTORY TABLE?
	BLEQ	20$			; CONTINUE IF ENOUGH QUOTA
	MOVL	R2,R0			; SETUP TO DEALLOCATE THE PAGED POOL
	JSB	G^EXE$DEAPGDSIZ		; DEALLOCATE IT
	JSB	G^LNM$UNLOCK		; UNLOCK THE LOGICAL NAME MUTEX
	MOVZWL	#SS$_EXLNMQUOTA,R0	; SETUP REASON FOR PREMATURE TERMINATION
10$:	BRW	40$			; AND GO RETURN TO CALLER
	
20$:	MOVL	R2,R8			; SAVE ADDRESS OF STORAGE ALLOCATED
	MOVC3	R1,GROUP_TABLE,(R2)	; FORMAT THE LOGICAL NAME TABLE(S)
	MOVL	G^SCH$GL_CURPCB,R4	; RETRIEVE PCB ADDRESS 

;
; FIXUP THE LOGICAL NAME BLOCK FOR THE JOB TABLE THAT IS BEING CREATED, AND
; THEN INSERT IT INTO THE APPROPRIATE HASH BUCKET OF THE SHAREABLE LOGICAL NAME 
; HASH TABLE. THIS FIXING UP OF THE JOB TABLE'S LOGICAL NAME BLOCK INCLUDES 
; APPENDING TO THE "LNM$JOB_" ASCII STRING ALREADY PRESENT WITHIN THE NAME FIELD
; OF THE LNMB, THE ASCII EQUIVALENT OF THE JIB'S HEXADECIMAL ADDRESS. A POINTER
; TO THIS ASCII EQUIVALENCE IS PASSED TO THIS ROUTINE IN R7.
;

	MOVAB	JOB_TABLE(R8),R1	; RETRIEVE ADDRESS OF JOB TABLE'S LNMB
	MOVQ	(R10),LNMB$T_NAME+9(R1)	; MOVE ASCII HEX JIB ADDR INTO NAME FIELD
	MOVL	@LNM$AL_HASHTBL,-	; MOVE THE ADDRESS OF THE SHAREABLE 
		JOB_TABLE_LNMTH+-	; LOGICAL NAME HASH TABLE INTO THE JOB
		LNMTH$L_HASH(R8)	; TABLE'S TABLE HEADER
	MOVAB	JOB_TABLE_ORB(R8),-	; MOVE THE ADDRESS OF THE JOB TABLE'S
		JOB_TABLE_LNMTH+-	; OBJECT RIGHTS BLOCK INTO THE JOB
		LNMTH$L_ORB(R8)		; TABLE'S TABLE HEADER
	MOVL	R1,JOB_TABLE_LNMTH+-	; MOVE THE ADDRESS OF THE JOB TABLE'S
		LNMTH$L_NAME(R8)	; LNMB INTO THE JOB TABLE'S TABLE HEADER

	MOVL	PCB$L_UIC(R4),-		; MOVE THE PROCESS'S UIC INTO THE
		JOB_TABLE_ORB+-		; APPROPRIATE FIELD OF THE JOB TABLE'S
		ORB$L_OWNER(R8)		; OBJECT RIGHTS BLOCK
	CLRQ	JOB_TABLE_ORB+-		; SET INITIAL NULL ACL
		ORB$L_ACL_COUNT(R8)

	TSTL	R7			; IS JOB TABLE QUOTA POOLED?
	BEQL	30$			; IF SO THEN GO INSERT LNMB
	MOVAB	JOB_TABLE_LNMTH(R8),-	; OTHERWISE SET UP THE JOB TABLE'S
		JOB_TABLE_LNMTH+-	; TABLE HEADER AS THE QUOTA HOLDER FOR
		LNMTH$L_QTABLE(R8)	; THE JOB TABLE
	MOVL	R7,JOB_TABLE_LNMTH+-	; SET THE BYTE LIMIT FIELD TO THE
		LNMTH$L_BYTESLM(R8)	; INITIAL AMOUNT OF JOB TABLE QUOTA
	MOVL	R7,JOB_TABLE_LNMTH+-	; SET THE BYTE REMAINING FIELD TO THE
		LNMTH$L_BYTES(R8)	; INITIAL AMOUNT OF JOB TABLE QUOTA
30$:	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$GROUP_xxxxxx

;
; FIXUP THE LOGICAL NAME BLOCK FOR THE GROUP TABLE THAT IS BEING CREATED, AND
; THEN INSERT IT INTO THE APPROPRIATE HASH BUCKET OF THE SHAREABLE LOGICAL NAME 
; HASH TABLE PROVIDED A TABLE FOR THAT GROUP DOES NOT ALREADY EXIST. THIS 
; FIXING UP OF THE GROUP TABLE'S LOGICAL NAME BLOCK INCLUDES APPENDING TO THE
; "LNM$GROUP_" ASCII STRING ALREADY PRESENT WITHIN THE NAME FIELD OF THE LNMB, 
; THE ASCII EQUIVALENT OF THE "OCTAL GROUP" THE PROCESS BELONGS TO. A POINTER
; TO THIS ASCII EQUIVALENCE IS PASSED TO THIS ROUTINE IN R8.
;

CREATE_GTABLE:				;
	MOVL	R8,R1			; SETUP TO INSERT THE GROUP TABLE'S LNMB
	MOVL	(R11),LNMB$T_NAME+11(R1); APPEND THE ASCII "OCTAL GROUP" TO THE
	MOVW	4(R11),LNMB$T_NAME+15(R1); "LNM$GROUP_" ALREADY IN THE NAME FIELD
	MOVL	@LNM$AL_HASHTBL,-	; MOVE THE ADDRESS OF THE SHAREABLE 
		GROUP_TABLE_LNMTH+-	; LOGICAL NAME HASH TABLE INTO THE GROUP
		LNMTH$L_HASH(R8)	; LOGICAL NAME TABLE'S YABLE HEADER
	MOVAB	GROUP_TABLE_ORB(R8),-	; MOVE THE ADDRESS OF THE GROUP TABLE'S
		GROUP_TABLE_LNMTH+-	; OBJECT RIGHTS BLOCK INTO THE GROUP
		LNMTH$L_ORB(R8)		; TABLE'S TABLE HEADER
	MOVL	R1,GROUP_TABLE_LNMTH+-	; MOVE THE ADDRESS OF THE LNMB INTO THE
		LNMTH$L_NAME(R8)	; GROUP TABLE'S TABLE HEADER

	MOVW	PCB$W_GRP(R4),-		; MOVE THE PROCESS'S GROUP NUMBER
		GROUP_TABLE_ORB+-	; INTO THE APPROPRIATE FIELD OF THE
		ORB$L_OWNER+2(R8)	; GROUP TABLE'S OBJECT RIGHTS BLOCK
	CLRQ	GROUP_TABLE_ORB+-	; SET INITIAL NULL ACL
		ORB$L_ACL_COUNT(R8)

	MOVL	#LNM$M_CREATE_IF,R2	; GROUP TABLES ARE INSERTED CREATE_IF
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$GROUP_xxxxxx
		
	CMPW	#SS$_NORMAL,R0		; DID THE GROUP TABLE ALREADY EXIST?
	BNEQ	35$			; GO UNLOCK THE MUTEX IF IT DIDN'T
	MOVL	R8,R0			; DELETE THE LNMB FOR WHAT WOULD HAVE
	JSB	G^EXE$DEAPAGED		; BECOME A GROUP LOGICAL NAME TABLE
;
; UNLOCK THE LOGICAL NAME MUTEX AND RETURN STATUS.
;

35$:	JSB	G^LNM$UNLOCK		; UNLOCK THE LOGICAL NAME MUTEX
	MOVZBL	#1,R0			; SUCCESS
40$:	RSB				; RETURN

	.DSABL	LSB

	.END
