.TITLE	MAIL$ADDRLIST	ADDRESSEE LIST ROUTINES
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX/VMS MAIL UTILITY
;
; ABSTRACT:	ADDRESSEE LIST ROUTINES
;
;
; ENVIRONMENT:	NATIVE/USER MODE 
;
; AUTHOR:	LEN KAWELL, CREATION DATE: 22-NOV-78
;
; MODIFICATION HISTORY:
;
;	V03-015	BLS0340		Benn Schreiber		10-AUG-1984
;		Correct handling of alternate protocol if nodename
;		specified.
;
;	V03-014	ROP0002		Robert Posniak		30-MAY-1984
;		Check for prot%"quoted@gibberish".  Strip
;		quotes from gibberish.
;
;	V03-013	BLS0310		Benn Schreiber		27-APR-1984
;		Check for blank line before checking comment in
;		address list parsing.
;
;	V03-012	BLS0292		Benn Schreiber		30-MAR-1984
;		Correct call to free_vm to only pass two args.
;
;	V03-011	BLS0263		Benn Schreiber		22-Jan-1984
;		Honor terminal logical name attribute. Remove resultant
;		file spec substitution. Too much work required to make
;		it work right now.
;
;	V03-010	BLS0261		Benn Schreiber		17-Jan-1984
;		Correct references to uaf$b_flags and uaf$v_disnewmail
;
;	V03-009	BLS0255		Benn Schreiber		28-Dec-1983
;		Substitute resultant dist. file spec if only item in
;		the list.  Correct errors when protocol spec used.
;		Add call to see if addressee already in the list.
;
;	V03-008	BLS0246		Benn Schreiber		28-Nov-1983
;		Fix loop detection counter reset.  Add call to see if
;		destination node is in current cluster and skip network
;		setup if so.
;
;	V03-007	BLS0235		Benn Schreiber		23-Aug-1983
;		Standardize file error reporting in distribution list handling.
;		Fix reference to UAF buffer.  Catch more junky addressee specs
;		at parse time.
;
;	V03-006	BLS0222		Benn Schreiber		15-May-1983
;		Ignore blank lines in addressee lists
;
;	V03-005	BLS0214		Benn Schreiber		27-Mar-1983
;		Enhance error detection.  Correct stack offset in
;		distribution list handling.  Set SQO when reading
;		distribution list.
;
;	V03-004	BLS0211		Benn Schreiber		13-Mar-1983
;		Extensive rework for optional protocol spec and multi-threaded
;		server
;
;	V03-003	BLS0184		Benn Schreiber		24-Sep-1982
;		If addressee is on same node, skip setting up logical
;		link.  This can be forced by using "__node" to use decnet
;
;	V03-002	BLS0179		Benn Schreiber		25-Jul-1982
;		Allow hyphens in user names.
;
;	V03-001	BLS0177		Benn Schreiber		22-Jun-1982
;		Allow periods in user names.  Check for recursive logical name
;		translation loop that does not terminate.  Implement the mail
;		disabled flag (UAF$V_DISMAIL in the UAF record).  Implement
;		MAIL logical names (honor forwarding address in
;		SYS$SYSTEM:VMSMAIL.DAT)
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

ADDR		= 4			;ADDRESSEE NAME DESC ADDR ARG
FAB		= 4			;MESSAGE FILE FAB ADDR ARG
RAB		= 8			;MESSAGE FILE RAB ADDR ARG

COMMA		= 44			;ASCII COMMA
CH_SPACE	= ^A/ /
CH_TAB		= ^A/	/
MAIL$K_INBUFFSZ	= 255			;INPUT BUFFER SIZE

	$CHFDEF				;CONDITION HANDLER DEFINITIONS
	$FABDEF				;FILE ACCESS BLOCK DEFINITIONS
	$LNMDEF				;LOGICAL NAME DEFINITIONS
	$MAILMSGDEF			;MAIL MESSAGES
	$NAMDEF				;NAM BLOCK DEFINITIONS
	$RABDEF				;RECORD ACCESS BLOCK DEFINITIONS
	$STSDEF				;STATUS CODE DEFINITIONS
	$TPADEF				;TPARSE DEFINITIONS
	ADRDEF				;ADDRESSEE LIST DESCRIPTORS
	CNCTDEF				;CONNECT BLOCK OFFSETS
	LNKDEF				;LOGICAL LINK BLOCK OFFSETS
	MAIFDEF				;DEFINE MAIL GLOBAL FLAGS
	VMDDEF				;VMS MAIL FILE OFFSETS

;
; DEFINE LOCAL NAMES FOR SHARED MESSAGES
;
	$SHR_MSGDEF	MAIL,126,LOCAL,<<READERR,ERROR>,<OPENIN,ERROR>>
	
;
; DEFINE EXTENSION TO THE TPARSE BLOCK
;
TPA_L_LCOUNT = TPA$L_PARAM+4		;LOOP COUNT
TPA_Q_ONAME = TPA_L_LCOUNT+4		;DESCRIPTOR OF ORIGINAL NAME
TPA_L_LLNK = TPA_Q_ONAME+8		;LOGICAL LINK OR 0 IF LOCAL
TPA_Q_LOGNAM = TPA_L_LLNK+4		;DESCRIPTOR
TPA_Q_PNAM = TPA_Q_LOGNAM+8		;PROTOCOL NAME DESCRIPTOR
TPA_L_CNCT = TPA_Q_PNAM+8		;ADDR OF CNCT DESC
TPA_L_PTPA = TPA_L_CNCT+4		;ADDR OF PREV. TPARSE BLOCK
TPA_L_SPST = TPA_L_PTPA+4		;START OF SPEC IN STRING
TPA_Q_UNAME = TPA_L_SPST+4		;USERNAME DESCRIPTOR
TPA_W_UENT = TPA_Q_UNAME+8		;# USERS (CALLS TO ENTER_ADDR, ACTUALLY)
TPA_W_FLAGS = TPA_W_UENT+2		;FLAGS
    TPA_V_TERMINAL = 0			;LAST LOGICAL USERNAME WAS TERMINAL
    TPA_M_TERMINAL = 1			;MASK FOR FLAG
TPA_C_EXTRA = TPA_W_FLAGS+2-TPA_L_LCOUNT;LENGTH OF EXTENSION

;
; OWN STORAGE:
;

	.PSECT	$PLIT$,LONG,RD,NOWRT,NOEXE

DIST_TYPE:				;DISTRIBUTION LIST FILE TYPE
	.ASCII	/.DIS/
DIST_TYPE_SIZ = .-DIST_TYPE

AT_STRING:
	.ASCII	/@/

	.PSECT	$CODE$,LONG,RD,NOWRT,EXE

	.SBTTL	ADD ADDRESSEE TO ADDRESSEE LIST
;++
; FUNCTIONAL DESCRIPTION:
;
;	PARSE ADDRESSEE NAMES AND ADD TO ADDRESSEE LIST.
;
; CALLING SEQUENCE:
;	CALL MAIL$ADD_ADDR(ADDR,CNCTDESC)
;
; INPUT PARAMETERS:
;	4(AP) = ADDRESSEE NAME(S) DESC
;	8(AP) = ADDRESS OF CONNECT BLOCK DESCRIPTOR
;
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	ADDRESSEE LIST ENTRIES CREATED FOR ADDRESSEE(S) AND ENTERED
;	INTO ADDRESSEE LIST.  IF AN ADDRESSEE IS LOCATED ON A REMOTE
;	SYSTEM, A LOGICAL LINK AND LOGICAL LINK LIST ENTRY ARE ALSO
;	CREATED.
;
; COMPLETION CODES:
;	R0 = SUCCESS IF ALL ADDRESSEES FOUND SUCCESSFULLY,
;	   = WARNING IF AT LEAST ONE ADDRESSEE FOUND SUCCESSFULLY,
;	   = ERROR IF NO ADDRESSEES FOUND OR SYNTAX ERROR IN LIST.
;
; SIDE EFFECTS:
;	IF FAILURE, ERROR IS SIGNALED.
;
;--
MAIL_ADD_ADDR:				;INTERNAL ROUTINE WHICH IS CALLED
	.WORD	^M<R2,R3,R4>		; TO RECURSIVELY ADD AN ADDRESS
				;  (CALLED FROM WITHIN MAIL$ADD_ADDR ONLY)
	MOVL	8(FP),R4		;GET CALLER'S TPARSE BLOCK
	DECL	TPA_L_LCOUNT(R4)	;DECREMENT THE COUNT
	BGTR	60$			;BRANCH OF NOT LOOPING
	MOVL	TPA_L_CNCT(R4),R0	;GET CNCT BLOCK ADDRESS
	CLRQ	-(SP)			;MAKE NULL DESCRIPTOR
	MOVL	SP,R2			;SAVE ITS ADDRESS
	PUSHAB	CNCT_Q_ADRLST(R0)	;STACK ADDRESS OF LISTHEAD
	PUSHAB	TPA_Q_LOGNAM(R4)	;STACK USERNAME DESCRIPTOR ADDR
	PUSHL	R2			;USE NULL NODENAME
	PUSHL	R2			;AND NULL USERNAME
	CALLS	#4,MAIL$ADDR_EXISTS	;SEE IF ALREADY IN LIST
	BLBS	R0,50$			;BRANCH IF YES
	MOVAB	TPA_Q_LOGNAM(R4),R2	;SET USERNAME DESCR ADDR IN R2
	MOVL	TPA_L_CNCT(R4),R3	;SET CNCT ADDR IN R3
	BSBW	CREATE_ENTRY		;CREATE THIS ENTRY
	BLBC	R0,40$			;BRANCH IF FAILED
	BISB2	#ADR_M_NOSEND,ADR_B_FLAGS(R1) ;FLAG NO SEND
40$:	PUSHAB	TPA_Q_ONAME(R4)		;STACK ADDRESS OF DESCIRPTOR
	PUSHL	#1			;STACK NUMBER OF ARGUMENTS
	PUSHL	#MAIL$_FORWLOOP		;FORWARDING LOOP ERROR
	CALLS	#3,G^LIB$SIGNAL
50$:	MOVL	#STS$K_ERROR,R0		;RETURN ERROR STATUS
	RET
60$:	MOVL	R4,R3			;SET R3 POINTING TO PREV. CNCT
	CLRL	R4			;CLEAR PRESET UENT VALUE
	BBC	#MAIF_V_CTRLCFL,MAIL$GL_FLAGS,ADD_ADDR ;BRANCH IF NOT CTRL/C
	MOVL	#MAIL$_CONABORT,R0	;FLAG ABORTED BY CTRL/C
	RET

AT_LIST_ADD_ADDR:
	.WORD	^M<R2,R3,R4>		;ENTRY FOR DISTRIBUTION LIST RECURSION
	CLRL	R3			;CLEAR PREVIOUS FLAG
	MOVL	#1,R4			;SET UENT FLAG
	BRB	ADD_ADDR

	.ENTRY	MAIL$ADD_ADDR,-		;ADD ADDRESSEE TO LIST
		^M<R2,R3,R4>		;(ENTRY MASK)
	CLRQ	R3			;SET NO PREVIOUS CALL AND NO UENT
ADD_ADDR:
	MOVL	ADDR(AP),R0		;GET ADDRESSEE DESC ADDR
	MOVAB	-<TPA$K_LENGTH0+TPA_C_EXTRA>(SP),SP ;CREATE TPARSE BLOCK
	MOVL	SP,R2			;GET ADDR OF IT
	MOVL	#TPA$K_COUNT0,(R2)	;SET PARAMETER COUNT
	MOVL	#1,TPA$L_PARAM(R2)	;USE PARAMETER FOR STATUS - ASSUME SUCCESS
	MOVZWL	(R0),TPA$L_STRINGCNT(R2) ;SET SIZE OF ADDRESSEE
	MOVL	4(R0),TPA$L_STRINGPTR(R2) ;SET ADDR OF ADDRESSEE
	TSTL	R3			;PREVIOUS BLOCK PRESENT?
	BEQL	5$			;IF EQL NO
	MOVL	TPA_L_LCOUNT(R3),TPA_L_LCOUNT(R2)
	MOVQ	TPA_Q_ONAME(R3),TPA_Q_ONAME(R2)
	MOVL	TPA_L_CNCT(R3),TPA_L_CNCT(R2)
	MOVW	TPA_W_UENT(R3),TPA_W_UENT(R2)
	MOVW	TPA_W_FLAGS(R3),TPA_W_FLAGS(R2)
	MOVL	R3,TPA_L_PTPA(R2)	;COPY TPARSE BLOCK ADDRESS
	BRB	7$
5$:	MOVL	#10,TPA_L_LCOUNT(R2)	;SET LOOP COUNT LIMIT
	MOVQ	TPA$L_STRINGCNT(R2),TPA_Q_ONAME(R2);SET ORIGINAL NAME
	CLRL	TPA_L_LLNK(R2)		;CLEAR LLNK
	CLRQ	TPA_Q_LOGNAM(R2)	;CLEAR DESCRIPTOR
	MOVL	8(AP),TPA_L_CNCT(R2)	;SET CNCT BLOCK ADDRESS
	CLRL	TPA_L_PTPA(R2)		;CLEAR PREV TPARSE BLOCK POINTER
	CLRL	TPA_W_UENT(R2)		;CLEAR # ENTER_ADDRS (AND FLAGS)
	MOVW	R4,TPA_W_UENT(R2)	;SET PRESET UENT
7$:	CLRQ	TPA_Q_PNAM(R2)		;PROTOCOL NAME DESCRIPTOR
	CLRQ	TPA_Q_UNAME(R2)		;CLEAR USERNAME DESCRIPTOR
	PUSHL	R2
	CALLS	#1,W^CALL_TPARSE
	BLBS	R0,10$			;BR IF SUCCESS
	CMPL	R0,#MAIL$_CONABORT	;ABORT BY ^C?
	BEQL	30$			;BRANCH IF YES
	PUSHAL	TPA$L_TOKENCNT(R2)	;SET ADDR OF TOKEN DESCRIPTOR
	PUSHL	#1			;ONE FAO ARGUMENT
	PUSHL	#SHR$_SYNTAX ! -	;SET SYNTAX ERROR MESSAGE
		<MAIL$_FACILITY @ STS$V_FAC_NO> ! STS$K_ERROR
	CALLS	#3,G^LIB$SIGNAL		;SIGNAL THE ERROR
	RET				;RETURN
10$:
	BLBS	TPA$L_PARAM(R2),25$	;BR IF COMPLETE SUCCESS
	PUSHL	#STS$K_WARNING		;ASSUME AT LEAST PARTIAL SUCCESS
	MOVL	TPA_L_CNCT(R2),R1	;GET ADDR OF CNCT BLOCK
	PUSHAB	CNCT_Q_ADRLST(R1)	;GET ADDR OF LISTHEAD
	CALLS	#1,MAIL$ANY_ADDRESSEES	;SEE IF ANY ADDRESSEES FOUND
	BLBS	R0,20$			;BRANCH IF YES
	MOVL	#STS$K_ERROR,(SP)	;NO--SET ERROR
20$:	POPL	R0			;GET RETURN STATUS
25$:	RET				;RETURN

;
; CTRL/C was typed while attempting connection
;
30$:	MOVL	TPA_L_CNCT(R2),R3	;GET CNCT BLOCK ADDRESS
	PUSHAB	CNCT_Q_LNKLST(R3)	;STACK LOGICAL LINK LIST
	CALLS	#1,MAIL$DELETELINK	;DELETE ANY OUTSTANDING LINKS
	PUSHL	R3			;STACK CNCT BLOCK ADDRESS
	CALLS	#1,MAIL$INI_ADDR	;RE-INITIALIZE LIST
	MOVL	#STS$K_ERROR,R0		;RETURN ERROR
	RET

CALL_TPARSE:
	.WORD	0
	MOVAL	MAIL$PRUNW_HANDLER,(FP)
	PUSHAL	ADDR_KEY		;SET KEYWORD TABLE ADDRESS
	PUSHAL	ADDR_STATE		;SET STATE TABLE ADDRESS
	PUSHL	4(AP)			;SET PARAMETER BLOCK ADDRESS
	CALLS	#3,G^LIB$TPARSE		;PARSE ADDRESSEE NAME
	RET

	.SBTTL	ADDRESSEE PARSING STATE TABLE
;++
;
; PARSE "TO:" LIST AND FILL IN LINK AND ADDRESSEE TABLES
;
;	PARSES LISTS WITH THE FOLLOWING FORMAT:
;
;		ADDRESSEE,ADDRESSEE,...,ADDRESSEE
;
;	WHERE "ADDRESSEE" HAS THE FOLLOWING FORMAT:
;
;		[NODE1::][NODE2::]...[NODEN::]USERNAME
;
;	WHERE USERNAME CAN ALSO BE A UIC/PPN FOR RSX/RSTS SYSTEMS.
;
;	LIST CAN ALSO HAVE A "@FILESPEC" AS LAST TOKEN, WHERE
;	THE FILE CONTAINS A LIST OF ADDRESSEES.
;
;--
	$INIT_STATE ADDR_STATE,ADDR_KEY
	$STATE	NEXT_ADDR
	$TRAN	TPA$_LAMBDA,,SET_SPST

	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	CH_SPACE,NEXT_ADDR
	$TRAN	CH_TAB,NEXT_ADDR
	$TRAN	'!',TPA$_EXIT
	$TRAN	COMMA,NEXT_ADDR
	$TRAN	'+',NEXT_ADDR
	$TRAN	'@',DIST_PARSE
	$TRAN	'"',QDIST_PARSE
	$TRAN	!PROTOCOL_SPEC,,STORE_PROTOCOL
	$TRAN	TPA$_LAMBDA

	$STATE
	$TRAN	!NODE1_SPEC
	$TRAN	!CHECK_QUOTE,QUOTED_SPEC
	$TRAN	!GET_SYMBOL,,STORE_LOGNAME
	$TRAN	TPA$_LAMBDA,FIND_ADDRESSEE

	$STATE
	$TRAN	!SCAN_ADDR,SPEC_CONTINUE,STORE_UNAME
	$TRAN	TPA$_LAMBDA,FIND_ADDRESSEE

	$STATE  SPEC_CONTINUE
	$TRAN	!CHECK_SEP,NEXT_ADDR,ENTER_ADDR
	$TRAN	TPA$_LAMBDA
;
; FIND NEXT ADDRESSEE AFTER BAD USERNAME AND REPORT ERROR ON THIS ONE
; EXIT WITH TPA$_EXIT BECAUSE MESSAGE WILL HAVE BEEN ISSUED ALREADY
;
	$STATE	FIND_ADDRESSEE
	$TRAN	TPA$_EOS
	$TRAN	'!'
	$TRAN	COMMA
	$TRAN	'+'
	$TRAN	TPA$_ANY,FIND_ADDRESSEE

	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,REPORT_SYNTAX_ERROR

	$STATE	SCAN_ADDR
	$TRAN	!PROTOCOL_SPEC,SCAN_ADDR
	$TRAN	!NODE_SPEC,SCAN_ADDR
	$TRAN	!USER_SPEC,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

;
; DISTRIBUTION LIST PARSING
;
	$STATE	DIST_PARSE
	$TRAN	TPA$_FILESPEC,NEXT_ADDR,GET_DIST_LIST
;
; QUOTED DISTRIBUTION LIST PARSING
;
	$STATE	QDIST_PARSE
	$TRAN	'@'
	$STATE
	$TRAN	!QFILE_SPEC,TPA$_EXIT,GET_DIST_LIST
	$STATE	QFILE_SPEC
	$TRAN	!NOT_QEOS,QFILE_SPEC
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE	NOT_QEOS
	$TRAN	'"'
	$TRAN	TPA$_ANY,TPA$_EXIT
	$STATE
	$TRAN	TPA$_EOS,TPA$_FAIL
	$TRAN	TPA$_ANY,TPA$_EXIT
;
; NODE SPECIFICATION SUB-EXPRESSION PARSING
;
	$STATE	NODE1_SPEC			;FIRST NODENAME PARSING
	$TRAN	!GET_SYMBOL,NODE_SPECC,STORE_LOGNAME
	$STATE	NODE_SPEC			;NODENAME PARSING
	$TRAN	!GET_SYMBOL
	$STATE	NODE_SPECC			;NODENAME CONTINUATION PARSING
	$TRAN	!ACCESS_LIST
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	':'
	$STATE
	$TRAN	':',TPA$_EXIT

	$STATE	ACCESS_LIST			;DECNET ACCESS LIST PARSING
	$TRAN	'"'
	$STATE	ACCESS_SCAN
	$TRAN	'"',TPA$_EXIT
	$TRAN	TPA$_ANY,ACCESS_SCAN
;
; USERNAME/PPN SPECIFICATION SUB-EXPRESSION PARSING
;
	$STATE	USER_SPEC			;USERNAME SPEC PARSING
	$TRAN	!GET_SYMBOL,TPA$_EXIT
	$TRAN	'['
	$TRAN	'('
	$TRAN	'"',QUSER_SPEC
	$STATE					;UIC/PPN USERSNAME SPEC PARSING
	$TRAN	TPA$_DECIMAL
	$STATE
	$TRAN	COMMA
	$STATE
	$TRAN	TPA$_DECIMAL
	$STATE
	$TRAN	']',TPA$_EXIT
	$TRAN	')',TPA$_EXIT

	$STATE	QUSER_SPEC			;QUOTED USERNAME SPEC PARSING
	$TRAN	'"',TPA$_EXIT
	$TRAN	TPA$_ANY,QUSER_SPEC

	$STATE	QUOTED_SPEC
	$TRAN	!USER_SPEC,SPEC_CONTINUE,STORE_LOGNAME

;
; PROTOCOL NAME PARSING
;
	$STATE	PROTOCOL_SPEC
	$TRAN	!GET_SYMBOL

	$STATE
	$TRAN	'"',QPROT_SPEC
	$TRAN	'%',TPA$_EXIT

	$STATE	QPROT_SPEC
	$TRAN	'"'
	$TRAN	TPA$_ANY,QPROT_SPEC

	$STATE
	$TRAN	'%',TPA$_EXIT
;
; SYMBOL PARSING
;
	$STATE	GET_SYMBOL
	$TRAN	'.',GETSYM1
	$TRAN	'-',GETSYM1
	$TRAN	TPA$_SYMBOL,GETSYM1
	$TRAN	TPA$_LAMBDA,TPA$_FAIL

	$STATE	GETSYM1
	$TRAN	'.',GETSYM1
	$TRAN	'-',GETSYM1
	$TRAN	TPA$_SYMBOL,GETSYM1
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

;
; CHECK THAT NEXT CHARACTER IS LEGAL ADDRESSEE TERMINATOR
;
	$STATE	CHECK_SEP
	$TRAN	!LEGAL_SEP,TPA$_EXIT

	$STATE	LEGAL_SEP
	$TRAN	!LEGAL_SEP1,TPA$_FAIL
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE	LEGAL_SEP1
	$TRAN	TPA$_EOS,TPA$_FAIL
	$TRAN	'!',TPA$_FAIL
	$TRAN	COMMA,TPA$_FAIL
	$TRAN	'+',TPA$_FAIL
	$TRAN	CH_SPACE,TPA$_FAIL
	$TRAN	CH_TAB,TPA$_FAIL
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

;
;  Check to see if the next character is a quote
;
	$STATE	CHECK_QUOTE
	$TRAN	!QUOTE_SPEC,TPA$_EXIT

	$STATE	QUOTE_SPEC
	$TRAN	!SPEC_QUOTE,TPA$_FAIL
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE	SPEC_QUOTE
	$TRAN	'"',TPA$_FAIL
	$TRAN	TPA$_LAMBDA,TPA$_EXIT


	$END_STATE


	.PSECT	$CODE$,LONG,RD,NOWRT,EXE


	.SBTTL	STORE_PROTOCOL - STORE PROTOCOL NAME IN TPA BLOCK EXTENSION
;++
; ROUTINE CALLED BY TPARSE TO STORE THE PROTOCOL NAME
;
;--

STORE_PROTOCOL:
	.WORD	0
	MOVQ	TPA$L_TOKENCNT(AP),TPA_Q_PNAM(AP)	;COPY PROTOCOL NAME
	DECW	TPA_Q_PNAM(AP)				;DON'T COUNT THE '%'
	RET

;++
; THIS ROUTINE STORES THE ADDRESS OF THE START OF A USER SPEC
; AND CLEARS THE DESCRIPTORS IN THE TPARSE EXTENSION BLOCK
;--
	.DEBUG	SET_SPST
SET_SPST:
	.WORD	0
	MOVL	TPA$L_STRINGPTR(AP),TPA_L_SPST(AP);SAVE START
	CLRL	TPA_Q_PNAM(AP)		;CLEAR PROTOCOL NAME LENGTH
	CLRL	TPA_Q_LOGNAM(AP)	;CLEAR LOGNAM DESCRIPTOR
	CLRL	TPA_Q_UNAME(AP)		;CLEAR USERNAME DESCRIPTOR
	RET
;++
; THIS TPARSE ACTION ROUTINE REPORTS A SYNTAX ERROR.
;--
	.DEBUG	REPORT_SYNTAX_ERROR
REPORT_SYNTAX_ERROR:
	.WORD	0
	PUSHL	TPA_L_SPST(AP)		;FORM A DESCRIPTOR
	SUBL3	(SP),TPA$L_TOKENPTR(AP),-(SP) ;COMPUTE LENGTH OF STRING
	BNEQ	10$			;BRANCH IF SOMETHING THERE
	INCL	(SP)			;COUNT THE ILLEGAL TERMINATOR TOO
	BRB	20$
10$:	TSTL	TPA$L_STRINGCNT(AP)	;DID WE GET HERE AT END OF STRING?
	BEQL	20$			;IF EQL YES
	DECL	(SP)			;NO--DON'T PRINT THE TERMINATOR
20$:	PUSHL	SP			;STACK ADDRESS OF DESCRIPTOR
	PUSHL	#1			;ONE FAO ARG
	PUSHL	#<SHR$_SYNTAX!<MAIL$_FACILITY@STS$V_FAC_NO>!STS$K_ERROR>
	CALLS	#3,G^LIB$SIGNAL
	MOVL	#STS$K_WARNING,TPA$L_PARAM(AP) ;SET WARNING STATUS
	MOVL	#1,R0
	RET
;++
; THIS TPARSE ACTION ROUTINE STORES THE USERNAME IN TPA$L_TOKENCNT/TOKENPTR
; INTO THE TPARSE BLOCK EXTENSION
;--
STORE_UNAME:
	.WORD	0
	MOVQ	TPA$L_TOKENCNT(AP),TPA_Q_UNAME(AP)
	RET
;++
; THIS TPARSE ACTION ROUTINE STORES THE LOGICAL NAME IN TPA$L_TOKENCNT/TOKENPTR
; INTO THE TPARSE BLOCK EXTENSION
;
;--

	ASSUME	TPA$L_TOKENPTR EQ TPA$L_TOKENCNT+4

STORE_LOGNAME:
	.WORD	0
	MOVQ	TPA$L_TOKENCNT(AP),TPA_Q_LOGNAM(AP)	;COPY DESCRIPTOR
	RET
;++
; THIS ROUTINE RESETS TPA_L_LCOUNT WHEN A NEW ADDRESSEE IS ENCOUNTERED
;
;--

RESET_LCOUNT:
	MOVL	AP,R1				;GET PTR TO TPARSE BLOCK
10$:	MOVL	#10,TPA_L_LCOUNT(R1)		;RESET LOOP COUNT
	BICB2	#TPA_M_TERMINAL,TPA_W_FLAGS(R1)	;RESET TERMINAL ATTRIBUTE FLAG
	MOVL	TPA_L_PTPA(R1),R1		;GO UP AND GET THEM ALL
	BNEQ	10$
	RSB
;++
; ALREADY_IN_LIST - See if addressee already in list
;
; Inputs:
;
;	AP = pointer to tparse arg block
;
; outputs:
;
;	true if already entered, false if not
;
;	note**this routine is bsbw'd to to save code space
;
ALREADY_IN_LIST:
	MOVL	TPA_L_CNCT(AP),R0	;GET CNCT BLOCK ADDRESS
	PUSHAB	CNCT_Q_ADRLST(R0)	;STACK ADDRESS OF ADDRESSEE LISTHEAD
	PUSHAB	TPA_Q_UNAME(AP)		;STACK USERNAME DESCRIPTOR ADDR
	PUSHAB	TPA_Q_LOGNAM(AP)	;STACK NODENAME DESCR ADDR
	PUSHAB	TPA_Q_PNAM(AP)		;STACK PROTOCOL DESCR ADDR
	CALLS	#4,MAIL$ADDR_EXISTS	;SEE IF EXISTS IN ADDRESSEE LIST
	RSB				;RETURN WITH RESULT IN R0

	.SBTTL	ENTER_ADDR - ENTER ADDRESSEE IN ADDRESSEE LIST
;++
;
; ENTER_ADDR - ENTER ADDRESSEE IN ADDRESSEE LIST
;
; THIS ACTION ROUTINE IS CALLED TO ENTER AN ADDRESSEE IN THE ADDRESSEE
; LIST.  FIRST, AN ATTEMPT IS MADE TO TRANSLATE THE FIRST SYMBOL IN THE
; ADDRESSEE NAME.  FOR A REMOTE ADDRESSEE THE FIRST SYMBOL IS A NODE NAME,
; OTHERWISE, IT'S JUST A LOGICAL NAME OR A USERNAME.
;
; IF THE SYMBOL TRANSLATES, THE TRANSLATION IS PREFIXED TO THE REST OF THE
; ADDRESSEE STRING (IF ANY) AND THE PARSER IS RECURSIVELY CALLED TO PARSE THE
; NEW ADDRESSEE SPEC AND ENTER THE RESULT IN THE ADDRESSEE LIST.
;
; IF THE SYMBOL DOESN'T TRANSLATE, AND IT'S A USERNAME, LOOK IT UP IN
; SYS$SYSTEM:VMSMAIL.DAT TO SEE IF IT IS FORWARDED.  IF IT IS, TAKE THE
; FORWARDING ADDRESS AND CALL THE PARSER RECURSIVELY TO PARSE THE NEW
; ADDRESSEE SPEC.
;
; IF THE SYMBOL DOESN'T TRANSLATE, AND IT WAS A NODE NAME, A LOGICAL LINK
; IS CREATED TO A SLAVE MAIL JOB AND THE REST OF THE ADDRESSEE IS PASSED
; TO THE SLAVE MAIL JOB FOR VERIFICATION.  IF THE SYMBOL ISN'T A NODE NAME,
; IT MUST BE A USER NAME, AND IT'S VERIFIED BY LOOKING FOR A CORRESPONDING
; AUTHORIZATION FILE RECORD.
;
; THE ADDRESSEE IS THEN ENTERED INTO THE ADDRESSEE LIST FOR LATER USE
; WHEN THE MAIL IS ACTUALLY TO BE SENT.
;
; INPUTS:
;
;	TPA_Q_LOGNAM(AP) = NODENAME/USERNAME LOGICAL NAME DESCRIPTOR
;
;	IF TPA_Q_LOGNAM(AP) IS A NODE NAME:
;
;		TPA_Q_UNAME(AP) = DESCRIPTOR OF ADDRESSEE NAME
;
; OUTPUTS:
;
;	ADDRESSEE LIST ENTRY CREATED AND ENTERED INTO ADDRESSEE LIST.
;--
CASE_BLIND:
	.LONG	LNM$M_CASE_BLIND
ENTER_ADDR:				;ENTER  ADDRESSEE IN LIST
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8>;(ENTRY MASK)
	INCW	TPA_W_UENT(AP)		;COUNT ANOTHER TIME THROUGH
	MOVAQ	TPA_Q_LOGNAM(AP),R7	;GET ADDR OF LOGICAL NAME DESC
	BBS	#TPA_V_TERMINAL,TPA_W_FLAGS(AP),4$ ;BRANCH IF PREVIOUSLY TERMINAL
	CMPB	@4(R7),#^A'_'		;IS IT PREFIXED WITH UNDERSCORE?
	BNEQ	41$			;BR IF NOT
	DECW	(R7)			;REMOVE UNDERSCORE FROM COUNT
	INCL	4(R7)			;AND FROM ADDRESS OF LOGICAL NAME
4$:	BRW	CHECK_ADDR		;SKIP TRANSLATION
;
; SEE IF NODENAME/USERNAME IS PREFIXED WITH A QUOTE IF SO
; STRIP QUOTES FROM FIRST AND LAST POSITIONS IN STRING
;
41$:	CMPB	@4(R7),#^A/"/		;IS IT PREFIXED WITH A QUOTE
	BNEQ	5$			;NO, THEN BRANCH
	SUBW2	#2,(R7)			;REMOVE QUOTES FROM COUNT
	INCL	4(R7)			;SKIP OVER FIRST QUOTE
;
; SEE IF NODENAME/USERNAME TRANSLATES AS A LOGICAL NAME. IF IT IS, USE 
; TRANSLATION AND RECURSIVELY CALL ADD_ADDR.
;
5$:	MOVAB	-LNM$C_NAMLENGTH(SP),SP;CREATE TRANSLATION BUFFER
	PUSHL	SP			;CREATE BUFFER DESCRIPTOR
	MOVZBL	#LNM$C_NAMLENGTH,-(SP)	;...
	MOVL	SP,R6			;GET ADDRESS OF DESC
	CLRL	-(SP)			;CREATE LONGWORD TO GET ATTRIBUTES
	MOVL	SP,R5			;SAVE THE ADDRESS
	CLRL	-(SP)			;CREATE TRNLNM ITEM LIST
	CLRL	-(SP)			; NO RETURN ADDRESS
	PUSHL	R5			; ADDRESS TO RETURN ATTRIBUTES
	PUSHL	#<LNM$_ATTRIBUTES@16>!4	;STACK BUFFER LENGTH AND ITEM
	PUSHL	R6			; RETURN LENGTH ADDRESS
	PUSHL	4(R6)			; BUFFER ADDRESS
	MOVZWL	(R6),R0			; GET BUFFER LENGTH
	ADDL3	#<LNM$_STRING@16>,R0,-(SP) ;FINISH ITEM LIST
	MOVL	SP,R1			;SAVE ADDRESS
	$TRNLNM_S ATTR=CASE_BLIND,-
		  TABNAM=MAIL$SD_LNM_FILE_DEV,-
		  LOGNAM=(R7),-
		  ITMLST=(R1)
	BLBC	R0,20$			;BR IF FAILURE
	BISW3	TPA_Q_UNAME(AP),TPA_Q_PNAM(AP),R0 ;WAS THERE MORE THAN USERNAM?
	BNEQ	6$			;BRANCH IF YES
	BITW	#LNM$M_TERMINAL,(R5)	;NO--WAS THIS TERMINAL?
	BEQL	6$			;IF EQL NO
	BISB2	#TPA_M_TERMINAL,TPA_W_FLAGS(AP) ;YES--FLAG FOR NEXT TIME
6$:	PUSHL	R6			;STACK ADDRESS OF DESCRIPTOR
	CALLS	#1,MAIL$UPCASE_Q	;MAKE SURE IT'S UPPER CASE
7$:	ADDL3	(R6),TPA_Q_UNAME(AP),R0 ;COMPUTE SIZE OF NEW ADDRESSEE
	MOVZWL	TPA_Q_PNAM(AP),R1	;GET PROTOCOL SIZE
	BEQL	71$			;BRANCH IF NONE
	ADDL2	R1,R0			;INCLUDE PROTOCOL SIZE
	INCL	R0			; AND ALLOW DELIMITER (%)
71$:	SUBL	R0,SP			;CREATE NEW ADDRESSEE BUFFER
	PUSHL	SP			;CREATE BUFFER DESCRIPTOR
	PUSHL	R0			;...
	MOVL	4(SP),R3		;GET BUFFER ADDRESS
	TSTW	TPA_Q_PNAM(AP)		;PROTOCOL SPECIFIED?
	BEQL	75$			;IF EQL NO
	MOVC	TPA_Q_PNAM(AP),-	;COPY PROTOCOL SPEC FIRST
		@TPA_Q_PNAM+4(AP),(R3)
	MOVB	#^A/%/,(R3)+		;STORE DELIMITER
75$:	MOVC	(R6),@4(R6),(R3)	;MOVE TRANSLATION TO BUFFER
	MOVC	TPA_Q_UNAME(AP),-	;MOVE REST OF OLD ADDRESSEE TO BUFFER
		@TPA_Q_UNAME+4(AP),(R3)
	TSTW	TPA_Q_UNAME(AP)		;NODENAME SPECIFIED ALSO?
	BEQL	76$			;IF EQL NO, LOGNAM ALREADY SET UP
	MOVQ	TPA_Q_UNAME(AP),TPA_Q_LOGNAM(AP) ;POSITION USERNAME DESC.
76$:	MOVQ	TPA_Q_LOGNAM(AP),TPA_Q_ONAME(AP) ;AND SET ORIGINAL NAME
	PUSHL	SP			;SET ADDRESS OF ADDRESSEE DESC
	CALLS	#1,MAIL_ADD_ADDR	;ADD NEW ADDRESSEE TO LIST
	BLBS	R0,10$			;BR IF SUCCESS
8$:	MOVL	R0,TPA$L_PARAM(AP)	;SAVE STATUS
	MOVL	#1,R0			;ALWAYS SET SUCCESS
10$:	RET				;
;
; SEE IF USERNAME EXISTS IN SYS$SYSTEM:VMSMAIL.DAT, AND IF SO,
; FEED FORWARDING ADDRESS BACK INTO MAIL_ADD_ADDR
;
20$:	BISW3	TPA_Q_UNAME(AP),TPA_Q_PNAM(AP),R0 ;WAS THIS A NODE NAME?
						;(OR A PROTOCOL?)
	BNEQ	CHECK_ADDR		;IF NEQ YES. DON'T BOTHER LOOKING
	PUSHAB	8(SP)			;STACK OUTPUT BUFFER ADDR
	PUSHAB	(R7)			;STACK DESCRIPTOR FOR NAME
	CALLS	#2,W^MAIL$CHECK_FORW	;SEE IF USER IS FORWARDING
	BLBC	R0,CHECK_ADDR		;BRANCH IF NO FORWARDING
	MOVZBL	VMD_B_FWDLNG+8(SP),(R6)	;SETUP DESCRIPTOR FOR NEW DESTINATION
	MOVAB	VMD_T_FWDNAM+8(SP),4(R6); (ASSUME R6 STILL POINTS AT BUFFER)
	BRB	7$			;PROCESS NEW DESTINATION
	.ENABLE	LOCAL_BLOCK
CHECK_PROT:
	TSTW	TPA_Q_UNAME(AP)		;WAS NODENAME ALSO SPECIFIED?
	BNEQ	8$			;IF NEQ YES
	MOVQ	(R7),TPA_Q_UNAME(AP)	;NO, SET USERNAME
	CLRL	(R7)			;AND ZERO NODENAME LENGTH
	BRB	8$			; CONTINUE
;
; CHECK IF ADDRESSEE EXISTS
;
CHECK_ADDR:				;
	MOVL	TPA_L_CNCT(AP),R3	;GET CNCT BLOCK ADDRESS
	TSTW	TPA_Q_PNAM(AP)		;PROTOCOL SPECIFIED?
	BNEQ	CHECK_PROT		;IF NEQ YES
	TSTW	TPA_Q_UNAME(AP)		;WAS NODENAME SPECIFIED?
	BNEQ	5$			;IF NEQ YES
	BRW	10$			;NO--GO HANDLE LOCAL USER
1$:	BRW	15$			;BRANCH AID
;
; IF DESTINATION NODE IS SAME AS OUR NODE, THEN IGNORE AND SEND
; REST OF ADDRESSEE NAME BACK INTO ADD_ADDR
;
5$:	MOVAB	MAIL$Q_SYSNODE,R1	;POINT TO OUR NODE NAME DESCRIPTOR
	CMPC5	(R7),@4(R7),#0,(R1),@4(R1);DEST. NODE SAME AS OUR NODE?
	BNEQ	7$			;BRANCH IF NOT
6$:	MOVQ	TPA_Q_UNAME(AP),-(SP)	;YES--STACK DESCRIPTOR OF ADDRESSEE
	PUSHL	SP			;STACK ADDRESS OF DESCRIPTOR
	MOVQ	TPA_Q_UNAME(AP),TPA_Q_LOGNAM(AP) ;SET IN CASE FORWARD ERROR
	MOVQ	TPA_Q_UNAME(AP),TPA_Q_ONAME(AP) ;SET ORIGINAL NAME
	CALLS	#1,MAIL_ADD_ADDR	;RECURSE TO PEEL OFF NEXT NODE NAME
	BRW	20$			;GO RETURN
7$:	PUSHL	R7			;STACK NODE DESCRIPTOR ADDRESS
	CALLS	#1,MAIL$CHK_CLUNODES	;SEE IF SENDING TO NODE IN OUR CLUSTER
	BLBS	R0,6$			;BRANCH IF YES
8$:	BSBW	ALREADY_IN_LIST		;SEE IF THIS ONE ALREADY ENTERED
	BLBS	R0,1$			;IF SO, ALL DONE
	PUSHAL	TPA_L_LLNK(AP)		;SET ADDRESS OF RETURN ADDRESS BUFFER
	MOVL	TPA_L_CNCT(AP),R3	;REFETCH CNCT BLOCK BECAUSE OF CMPC
	PUSHL	R3			;STACK CNCT BLOCK ADDRESS
	PUSHAQ	(R7)			;SET ADDRESS OF NODENAME DESCRIPTOR
	PUSHAQ	TPA_Q_PNAM(AP)		;STACK PROTOCOL NAME ADDRESS
	CALLS	#4,MAIL$CREATELINK	;CREATE A LOGICAL LINK TO THE NODE
	BLBC	R0,9$			;BRANCH IF FAILURE
	MOVL	TPA_L_LLNK(AP),R2	;GET THE LNK BLOCK ADDRESS
	BBS	#LNK_V_ALTP,LNK_B_FLAGS(R2),81$ ;BRANCH IF ALTERNATE PROTOCOL
	TSTW	TPA_Q_PNAM(AP)		;NO--WAS PROTOCOL SPECIFIED?
	BEQL	81$			;IF EQL NO
;
; SPECIAL "%NODNAME::"TASK=" CONNECTION.  WE MUST RECOMBINE THE NODE
; AND USERNAME
;
	MOVAB	-LNM$C_NAMLENGTH(SP),SP	;ALLOCATE A BUFFER
	MOVL	SP,R8			;SAVE ITS ADDRESS
	PUSHR	#^M<R2,R3,R4,R5>	;SAVE SOME REGISTERS
	MOVC3	(R7),@4(R7),(R8)	;COPY THE NODE NAME
	TSTW	(R7)			;WAS THERE A NODE NAME?
	BEQL	801$			;IF EQL NO
	MOVW	#^A/::/,(R3)+		;TERMINATE THE NODE NAME
801$:	MOVC3	TPA_Q_UNAME(AP),@TPA_Q_UNAME+4(AP),(R3) ;AND THE USERNAME
	SUBL3	R8,R3,TPA_Q_UNAME(AP)	;CREATE NEW DESCRIPTOR OF USERNAME
	MOVL	R8,TPA_Q_UNAME+4(AP)
	CLRQ	(R7)			;AND CLEAR THE NODENAME
	POPR	#^M<R2,R3,R4,R5>	;RESTORE REGISTERS
81$:	PUSHAB	CNCT_Q_FROMDESC(R3)	;STACK ADDR OF FROM DESCRIPTOR
	PUSHL	TPA_L_LLNK(AP)		;STACK LOGICAL LINK ENTRY
	CALLS	#2,MAIL$NET_FROM	;SEND "FROM" STRING
	BLBC	R0,9$			;BRANCH IF FAILURE
	PUSHAL	TPA_Q_UNAME(AP)		;SET ADDRESS OF ADDRESSEE DESC
	PUSHL	TPA_L_LLNK(AP)		;SET ADDRESS OF LOGICAL LINK ENTRY
	CALLS	#2,MAIL$NET_ADDR	;CHECK IF ADDRESSEE EXISTS
	BLBS	R0,CREATE_ADDR		;BR IF SUCCESS
9$:	PUSHL	R0			;SAVE ERROR CODE
	MOVAB	TPA_Q_UNAME(AP),R2	;GET USERNAME DESCR ADDR
	BSBW	CREATE_ENTRY		;ALLOCATE USERNAME BLOCK
	BLBC	R0,91$			;BRANCH IF ERROR
	BISB2	#ADR_M_NOSEND,ADR_B_FLAGS(R1) ;SET NOSEND TO THIS USER
91$:	POPL	R0			;RESTORE ERROR CODE
92$:	BRW	20$			;

10$:	MOVQ	(R7),TPA_Q_UNAME(AP)	;MOVE USERNAME DESC TO COMMON DESC
	CLRQ	(R7)			;CLEAR NODE NAME
	BSBW	ALREADY_IN_LIST		;SEE IF ALREADY ENTERED
15$:	BLBS	R0,25$			;IF SO, ALL DONE
	CLRL	TPA_L_LLNK(AP)		;LOCAL ADDRESSEE
	PUSHAQ	TPA_Q_UNAME(AP)		;SET ADDRESS OF USERNAME DESC
	CALLS	#1,MAIL$GET_USER	;CHECK IF USER EXISTS
	BLBC	R0,20$			;BRANCH IF USER DOES NOT EXIST
	MOVL	MAIL$T_UAF_BUFF,R0	;GET BUFFER ADDRESS
	BBS	#UAF$V_NOMAIL,-		;BRANCH IF MAIL DISABLED
			UAF$L_FLAGS(R0),30$
	BRB	CREATE_ADDR		;NOW ENTER IN ADDRESSEE LIST
20$:
	MOVL	R0,TPA$L_PARAM(AP)	;SAVE FAILURE STATUS
25$:	MOVL	#1,R0			;SET SUCCESS TO CONTINUE PARSE
	RET				;
;
; USER IS DISABLED FROM RECEIVING MAIL
;
30$:	PUSHAB	TPA_Q_UNAME(AP)		;STACK ADDRESS OF NAME DESCRIPTOR
	PUSHL	#1			;STACK COUNT OF ARGUMENTS
	PUSHL	#MAIL$_USERDSABL	;SIGNAL THAT USER CANNOT RECEIVE MAIL
	CALLS	#3,G^LIB$SIGNAL
	MOVAB	TPA_Q_UNAME(AP),R2	;GET USERNAME DESCR ADDR
	BSBW	CREATE_ENTRY		;ALLOCATE USERNAME BLOCK
	BLBC	R0,35$			;BRANCH IF ERROR
	BISB2	#ADR_M_NOSEND,ADR_B_FLAGS(R1) ;SET NOSEND TO THIS USER
35$:	MOVL	#MAIL$_USERDSABL,R0	;SET RETURN STATUS
	BRW	20$			;GO RETURN
	.DISABLE LOCAL_BLOCK
;
; CREATE ADDRESSEE LIST ENTRY FOR ADDRESSEE
;
CREATE_ADDR:				;CREATE ADDRESSEE LIST ENTRY
	MOVAB	TPA_Q_UNAME(AP),R2	;GET ADDR OF USERNAME DESCRIPTOR
	BSBW	CREATE_ENTRY		;CREATE THE ADR LIST ENTRY
	BLBC	R0,10$			;BR IF FAILURE
	MOVL	R1,R2			;GET ADDR OF NEW ENTRY
	MOVL	TPA_L_LLNK(AP),-	;SET ADDR OF LOGICAL LINK ENTRY
		ADR_L_LLNK(R2)		;
	INCL	CNCT_L_NADDRS(R3)	;COUNT ANOTHER ACTUAL ADDRESSEE
	PUSHL	ADR_L_LLNK(R2)		;STACK LOGICAL LINK ENTRY
	CALLS	#1,MAIL$INCLINKADR	;INCREMENT LINK ADDRESSEE COUNT IF NET
	BSBW	RESET_LCOUNT		;RESET LOOP COUNTER
	MOVL	#1,R0			;SET SUCCESS
	RET				;
10$:
	PUSHL	R0			;SET FAILURE STATUS
	PUSHL	R0			;SAVE STATUS
	CALLS	#1,G^LIB$SIGNAL		;SIGNAL THE FAILURE
	MOVL	(SP)+,TPA$L_PARAM(AP)	;SAVE STATUS
	MOVL	#1,R0			;SET SUCCESS TO CONTINUE PARSE
	RET				;

;
; ALLOCATE ENTRY AND LINK INTO LIST
;
; R2 = ADDR OF DESCRIPTOR OF USERNAME
; R3 = ADDR OF CNCT BLOCK
;
CREATE_ENTRY:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8>
	MOVQ	R2,R7			;SAVE USERNAME DESCR. AND CNCT ADDR
	MOVZWL	(R7),-(SP)		;GET LENGTH OF NAME
	ADDL2	#ADR_C_LENGTH,(SP)	;COMPUTE SIZE OF ENTRY
	PUSHAL	-(SP)			;SET RETURN ADDR BUFFER
	PUSHAL	8(SP)			;STACK ADDR OF SIZE
	CALLS	#2,G^LIB$GET_VM		;ALLOCATE IT
	BLBC	R0,10$			;BRANCH IF ERROR
	MOVL	(SP)+,R6		;GET ADDR OF NEW ENTRY
	POPL	R0
	MOVC5	#0,(SP),#0,#ADR_C_LENGTH,(R6) ;ZERO THE ENTRY
	MOVC3	(R7),@4(R7),ADR_T_NAME(R6);COPY USERNAME INTO BLOCK
	MOVB	(R7),ADR_B_NAMLNG(R6)	;SET ADDRESSEE NAME LENGTH
	INSQUE	(R6),@CNCT_Q_ADRLST+4(R8) ;INSERT AT END OF LIST
	MOVL	R6,R1			;SET ADDR OF BLOCK TO RETURN
	MOVL	#1,R0			;SET RETURN STATUS
10$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8>;RESTORE REGISTERS
	RSB

	.SBTTL	GET_DIST_LIST - GET DISTRIBUTION LIST
;++
;
; GET_DIST_LIST - GET DISTRIBUTION LIST ACTION ROUTINE
;
; THIS ACTION ROUTINE IS CALLED TO OPEN AND READ A DISTRIBUTION LIST FILE.
;
; INPUTS:
;
;	TPA$L_TOKENCNT(AP) = SIZE OF FILE SPECIFICATION.
;	TPA$L_TOKENPTR(AP) = ADDR OF FILE SPECIFICATION.
;
; OUTPUTS:
;
;	EACH ADDRESSEE IS READ FROM THE DISTRIBUTION LIST FILE AND 
;	ADDED TO THE ADDRESSEE LIST BY RECURSIVELY CALLING ADD_ADDR.
;	IF THIS IS THE FIRST (AND HENCE ONLY) ADDRESSEE ITEM IN THE
;	LIST, WE WILL MODIFY THE TO LIST TO CONTAIN THE FULL FILE SPEC.
;--
GET_DIST_LIST:				;GET DISTRIBUTION LIST
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;(ENTRY MASK)
;
; CREATE A FAB AND A RAB
;
	MOVAB	-FAB$K_BLN(SP),R6	;ALLOCATE FAB
	MOVAB	-RAB$K_BLN(R6),R7	;ALLOCATE RAB
	MOVAB	-NAM$K_BLN(R7),R8	;ALLOCATE NAM
	MOVAB	-NAM$C_MAXRSS(R8),R9	;AND A BUFFER
	MOVL	R9,SP			;ALLOCATE THE SPACE
	MOVC5	#0,(SP),#0,-
		#FAB$K_BLN+RAB$K_BLN+NAM$K_BLN+NAM$C_MAXRSS,(SP) ;ZERO FAB,RAB,NAM
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$K_BLN@8!FAB$C_BID,- ;SET BLOCK LENGTH AND ID FIELDS
		FAB$B_BID(R6)
	BISB	#FAB$M_GET,FAB$B_FAC(R6);GET ACCESS ONLY
	BISL	#FAB$M_SQO,FAB$L_FOP(R6) ;SET SEQUENTIAL ACCESS ONLY
	MOVL	R8,FAB$L_NAM(R6)	;SET NAM ADDRESS
	MOVL	#MAIL$_OPENIN,FAB$L_CTX(R6) ;SET ERROR CODE
	ASSUME	RAB$B_BLN EQ RAB$B_BID+1
	MOVW	#RAB$K_BLN@8!RAB$C_BID,- ;SET BLOCK LENGTH AND ID FIELDS
		RAB$B_BID(R7)
	ASSUME	RAB$C_SEQ EQ 0
	MOVL	R6,RAB$L_FAB(R7)	;SET FAB ADDRESS
	MOVL	#MAIL$_OPENIN,RAB$L_CTX(R7)
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$K_BLN@8!NAM$C_BID,-;SET UP NAM BLOCK
		NAM$B_BID(R8)
	MOVL	R9,NAM$L_RSA(R8)
	MOVL	R9,NAM$L_ESA(R8)
	MOVB	#NAM$C_MAXRSS,NAM$B_RSS(R8)
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R8)
	MOVAB	-MAIL$K_INBUFFSZ(SP),SP	;ALLOCATE USER BUFFER
	MOVW	#MAIL$K_INBUFFSZ,RAB$W_USZ(R7) ;SET USER BUFFER SIZE
	MOVL	SP,RAB$L_UBF(R7)	;SET USER BUFFER ADDRESS
;
; OPEN THE DISTRIBUTION LIST FILE
;
	MOVB	TPA$L_TOKENCNT(AP),FAB$B_FNS(R6) ;SET FILE NAME SIZE
	MOVL	TPA$L_TOKENPTR(AP),FAB$L_FNA(R6) ;SET FILE NAME ADDRESS
	MOVAB	DIST_TYPE,FAB$L_DNA(R6)	;SET DEFAULT FILE NAME ADDRESS
	MOVB	#DIST_TYPE_SIZ,FAB$B_DNS(R6) ;SET DEFAULT FILE NAME SIZE
	$OPEN	FAB=(R6),ERR=UTIL$REPORT_IO_ERROR	;OPEN THE FILE
	BLBC	R0,5$			;BR IF FAILURE
	$CONNECT RAB=(R7),ERR=UTIL$REPORT_IO_ERROR	;CONNECT THE RAB
	BLBS	R0,10$			;BRANCH ON SUCCESS
5$:	BRW	DIST_ERROR
;
; IF THIS IS THE ONLY ITEM IN THE TO LIST, THEN MODIFY IT TO CONTAIN
; RESULTANT FILE SPEC
;
10$:;	TSTW	TPA_W_UENT(AP)		;ANYTHING ENTERED?
;	BNEQ	20$			;YES--TOO BAD
;	PUSHL	R6			;STACK FAB ADDRESS
;	CALLS	#1,G^UTIL$GETFILENAME	;GET FILE SPEC FOR FILE
;	PUSHAB	AT_STRING		;CREATE DESCRIPTOR
;	PUSHL	#1			;OF '@'
;	PUSHL	R0			;STACK FILE DESCRIPTOR ADDRESS
;	PUSHAB	4(SP)			;PREFIX IT WITH '@'
;	PUSHAB	MAIL$Q_TO		;AND THE TO-LIST ADDRESS
;	CALLS	#3,G^STR$CONCAT		;MAKE A NEW TO-LIST
;
; READ ALL THE ADDRESSEES AND ADD THEM TO THE ADDRESSEE LIST
;
20$:	MOVL	#MAIL$_READERR,RAB$L_CTX(R7)
	CLRQ	-(SP)			;CREATE ADDRESSEE DESC BUFFER
DIST_LOOP:
	$GET	RAB=(R7),ERR=UTIL$REPORT_IO_ERROR ;GET A RECORD
	BLBC	R0,DIST_ERROR		;BR IF EOF OR ERROR
	MOVW	RAB$W_RSZ(R7),(SP)	;SET RECORD SIZE IN DESCRIPTOR
	BEQLU	DIST_LOOP		;SKIP BLANK LINES
	CMPB	#^A"!",@RAB$L_RBF(R7)	;IS RECORD A COMMENT?
	BEQLU	DIST_LOOP		;BR IF YES - IGNORE IT
	MOVL	RAB$L_RBF(R7),4(SP)	;SET RECORD ADDRESS IN DESCRIPTOR
	PUSHL	SP			;SET ADDRESS OF DESCRIPTOR
	CALLS	#1,MAIL$UPCASE_Q	;CONVERT RECORD TO UPPER CASE
	PUSHL	TPA_L_CNCT(AP)		;STACK CNCT BLOCK ADDRESS
	PUSHAB	4(SP)			;SET ADDRESS OF DESCRIPTOR
	CALLS	#2,AT_LIST_ADD_ADDR	;ADD THE ADDRESSEE TO THE LIST
	BLBS	R0,DIST_LOOP		;BR IF SUCCESS
	MOVL	R0,TPA$L_PARAM(AP)	;SAVE FAILURE STATUS
	BRB	DIST_LOOP		;
;
; ERROR ACCESSING THE FILE
;
DIST_ERROR:
	CMPL	R0,#RMS$_EOF		;END OF FILE?
	BEQL	DIST_DONE		;YES, OK
	MOVL	R0,TPA$L_PARAM(AP)	;NO, SET CODE
DIST_DONE:				;
	$CLOSE	(R6)			;CLOSE THE FILE
	MOVL	#1,R0			;SET SUCCESS FOR PARSER
	RET


	.SBTTL	MAIL$ANY_ADDRESSEES - SEE IF ANY ADDRESSEES FOUND
;++
; FUNCTIONAL DESCRIPTION:
;
;	LOOK THROUGH THE ADDRESSEE LIST AND SEE IF ANY FOUND
;	THAT WE WILL BE SENDING TO
;
; INPUTS:
;
;	4(AP)	ADDRESS OF ADDRESSEE LISTHEAD
;
; ROUTINE VALUE:
;
;	TRUE = THERE IS AT LEAST ONE
;	FALSE = NONE
;
;--

	.ENTRY	MAIL$ANY_ADDRESSEES,^M<R2,R3>
	MOVL	4(AP),R1		;GET ADDRESSEE LISTHEAD
	MOVL	(R1),R2			;GET FIRST ENTRY
10$:	CMPL	R2,R1			;SEE IF DONE
	BEQL	30$			;BRANCH IF YES
	BBS	#ADR_V_NOSEND,ADR_B_FLAGS(R2),20$ ;BRANCH IF NOSEND SET
	MOVL	ADR_L_LLNK(R2),R0	;GET LOGICAL LINK DESCRIPTOR
	BEQL	40$			;BRANCH IF NONE--WE FOUND ONE
	BBC	#LNK_V_DEAD,LNK_B_FLAGS(R0),40$	;BRANCH IF NOT DEAD--FOUND ONE
20$:	MOVL	ADR_L_FLINK(R2),R2	;GET NEXT ADDRESSEE
	BRB	10$			;AND CONTINUE
30$:	CLRL	R0			;NONE FOUND
	RET
40$:	MOVL	#1,R0
	RET

	.SBTTL	INITIALIZE ADDRESSEE LIST
;++
; FUNCTIONAL DESCRIPTION:
;
;	INITIALIZE ADDRESSEE LIST BY REMOVING ANY OLD ENTRIES FROM
;	THE LIST.
;
; CALLING SEQUENCE:
;	CALL MAIL$INI_ADDR(CNCTDESC)
;
; INPUT PARAMETERS:
;	CNCTDESC = ADDRESS OF THE CONNECT DESCRIPTOR.  IF THIS IS THE FIRST
;		CALL, THE ADRLST MUST BE INITIALIZED.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	ADDRESSEE AND LOGICAL LINK LIST ENTRIES REMOVED
;	AND DEALLOCATED.
;
;--
	.ENTRY	MAIL$INI_ADDR,-		;INITIALIZE ADDRESSEE LIST
		^M<R2,R3>		;(ENTRY MASK)
	MOVL	4(AP),R3		;GET ADDRESS OF ADDRESSEE LIST
	CLRL	CNCT_L_NADDRS(R3)	;INIT NUMBER OF ACTUAL ADDRESSEES
	MOVAB	CNCT_Q_ADRLST(R3),R3	;POINT TO THE ADDRESSEE LIST HEAD
10$:	REMQUE	@(R3),R2		;GET NEXT ENTRY
	BVS	20$			;BR IF NONE
	BSBB	DEALLOC_ENTRY		;DEALLOCATE THE ENTRY
	BRB	10$			;
20$:	RET
;
; DEALLOCATE AN ADDRESSEE LIST ENTRY
;
DEALLOC_ENTRY:
	PUSHL	R2			;SET ADDR OF ENTRY
	MOVZBL	ADR_B_NAMLNG(R2),-(SP)	;STACK LENGTH OF NAME
	ADDL2	#ADR_C_LENGTH,(SP)	;COMPUTE SIZE OF BLOCK
	PUSHAL	4(SP)			;SET ADDR OF ADDR OF ENTRY
	PUSHAL	4(SP)			;SET ADDR OF SIZE OF ENTRY
	CALLS	#2,G^LIB$FREE_VM	;DEALLOCATE ENTRY
	ADDL2	#8,SP			;CLEAR TWO LONGWORDS FROM STACK
	RSB				;

	.END
