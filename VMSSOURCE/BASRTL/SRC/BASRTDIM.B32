MODULE BAS$RT_DIM (				! Run time dimension
		IDENT = '1-011'		! File: BASRTDIM.B32 Edit: MDL1011
		) =
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
BEGIN

!++
! FACILITY:	Basic Language Support
!
! ABSTRACT:
!
!	This routine is called by the generated code to dimension an
!	array at run-time.
!
! ENVIRONMENT:	Runs at any access mode - AST reentrant
!
! AUTHOR: Pamela L. Levesque, CREATION DATE: 14-May-1982
!
! MODIFIED BY:
!
! 1-001 Original.  PLL 14-May-1982
! 1-002 Allow an upper bound of 0.  PLL 20-May-1982
! 1-003 Make routine global.  PLL 3-Jun-1982
! 1-004 Check return status from LIB$FREE_VM and LIB$GET_VM.  PLL 7-Jun-1982
! 1-005 Row 0 should be included in ARSIZE.  Also, the counter in the INCR
!	loop for setting the bounds should start at 0, not 1.  PLL 30-Jun-1982
! 1-006 Initialize BNDSARG outside of the loop which sets the lower and
!	upper bounds.  PLL 27-Sep-1982
! 1-007 Fix initialization of array elements to not write beyond the space
!	allocated by LIB$GET_VM.  (End_addr was incorrectly computed.)
! 	PLL 1-Oct-1982
! 1-008 - Add RECORD datatype.  Since there is no datatype by this name on the
!	  VAX, Basic uses DSC$K_DTYPE_Z (none).  MDL 26-May-1983
! 1-009 - correct array initialization.  use a loop of CH$FILL's; the MOVC5
!	  generated by one CH$x comes nowhere near writing all of a large array,
!	  as the length operands for the instruction are words.  MDL 20-Dec-1983
! 1-010 - the size to return to FREE_VM should be calculated from the array size
!	  field in the array descriptor, in the same fashion as for the call to
!	  GET_VM when the array is first allocated.  MDL 9-Feb-1984
! 1-011 - check to see if there's enough virtual address space available before
!	  calling GET_VM.  also, free dynamic strings if returning an array of
!	  them.  MDL 22-Feb-1984
!--


%SBTTL 'Declarations'
!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!
!	NONE
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$RT_DIM : NOVALUE;			! run time dimension

!
! INCLUDE FILES:
!

LIBRARY 'RTLSTARLE';				! System symbols, typically from SYS$LIBRARY:STARLET.L32

REQUIRE 'RTLIN:RTLPSECT';			! Define PSECT declarations macros

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! FIELDS:
!
!	NONE
!
! PSECTS:
!
DECLARE_PSECTS (BAS);				! Declare PSECTs for BAS$ facility
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BAS$$STOP : NOVALUE,			! Signal a fatal error
    LIB$GET_EF,					! get an event flag
    LIB$FREE_EF,				! free an event flag
    LIB$STOP : NOVALUE,				! signal if error from GET_EF or $GETJPI
    LIB$FREE_VM,				! Deallocate virtual space
    LIB$GET_VM,					! Allocate virtual space
    STR$FREE1_DX;				! Deallocate string space

EXTERNAL LITERAL 				! Condition value symbols
    BAS$K_ARGDONMAT : UNSIGNED (8),		! Arguments don't match
    BAS$K_NOTIMP : UNSIGNED (8),		! Not implemented
    BAS$K_SUBOUTRAN : UNSIGNED (8),		! Subscript out of range
    BAS$K_TOOFEWARG : UNSIGNED (8),		! Too few arguments
    BAS$K_TOOMANARG : UNSIGNED (8),		! Too many arguments 
    BAS$K_MAXMEMEXC : UNSIGNED (8),		! Maximum memory exceeded
    BAS$K_PROLOSSOR : UNSIGNED (8);		! Program lost sorry


%SBTTL 'BAS$RT_DIM - run time dimension'
GLOBAL ROUTINE BAS$RT_DIM (			! run time dimension
	ARRAY,					! array to re-dim
	BOUND1					! 1st upper bound
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes the size of an array.  It does this by
!	deleting any virtual memory previously allocated for the array
!	elements, updating the upper bounds with the parameters passed,
!	and then allocating enough virtual memory for the new size. 
!
!	Numeric array elements are initialized to zero, and string array
!	elements (descriptors) have their length and pointer set to zero.
!
! CALLING SEQUENCE:
!
!	BAS$RT_DIM (ARRAY.mx.da, BOUND1.rl.v [,BOUND2.rl.v, ... BOUND32.rl.v])
!
! FORMAL PARAMETERS:
!
!	ARRAY		desc. of array to re-dimension
!	BOUND1		new value of 1st upper bound
!	[BOUND2,..	optional parameters - the number of bounds
!	  BOUND32]	passed must agree with the number of dimensions
!			up to 32 dimensions are possible
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The following fields in the array descriptor are updated:
!		DSC$A_POINTER
!		DSC$A_A0
!		DSC$L_ARSIZE
!		bounds and multipliers
!
! COMPLETION STATUS: 
!
!	Signals if any error is encountered
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,				
	ACTUALPARAMETER,
	ASHP;

    MAP
	ARRAY : REF BLOCK [,BYTE];

    LOCAL
	AR_SIZE : INITIAL (1),			! temp used to compute array size
	BNDSARG : INITIAL (2),			! 1st bounds is 2nd arg
	BOUNDS,					! upper or lower bounds of array
	MULTIPLIERS,				! mult in array desc
	LENGTH,					! temp used to compute element size
	STATUS,					! return status from calls
	EVENT_FLAG,				! for use with $GETJPI
	NUM_FREE_PAGES: INITIAL(0),		! written by $GETJPI
	JPI_RETURN_LENGTH: INITIAL(0),		! # bytes returned from $GETJPI
	JPI_ITEMS: VECTOR [4, LONG] INITIAL (	((JPI$_FREPTECNT^16) OR 4),
						NUM_FREE_PAGES,
						JPI_RETURN_LENGTH,
						0 );

!+
! First perform some checks to make sure the proper number of bounds have
! been passed, etc.
!-

    IF (ACTUALCOUNT () - 1) NEQ .ARRAY [DSC$B_DIMCT]
    THEN
	BEGIN
	IF (ACTUALCOUNT () - 1) LSS .ARRAY [DSC$B_DIMCT]
	THEN
	    BAS$$STOP (BAS$K_TOOFEWARG)
	ELSE
	    BAS$$STOP (BAS$K_TOOMANARG);
	END;

    IF (NOT (.ARRAY [DSC$V_FL_COEFF] AND .ARRAY [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);		! bounds and mult must be present

!+
! Free previously used space for elements, if any.
!-
    IF.ARRAY [DSC$A_POINTER] NEQ 0
    THEN
	BEGIN
	!+
	! if this was an array of descriptors, there is some cleanup necessary
	! prior to freeing the space for the array itself.
	!
	! for dynamic string descriptors, each descriptor with space allocated
	! must be freed.
	! a static string descriptor implies that the element is FIELDed,
	! and the FIELD variable must be marked invalid.
	!-
	IF .ARRAY [DSC$B_DTYPE] EQL DSC$K_DTYPE_DSC
	THEN
	    BEGIN
	    LOCAL
		END_ADDR;
	    END_ADDR = .ARRAY [DSC$A_POINTER] + .ARRAY [DSC$L_ARSIZE] -
		.ARRAY [DSC$W_LENGTH];	
	    !+
	    ! walk through the descriptors one at a time.
	    !-
	    INCR DSC_ADDR FROM .ARRAY [DSC$A_POINTER] TO .END_ADDR BY .ARRAY [DSC$W_LENGTH] DO
		BEGIN
		MAP
		   DSC_ADDR : REF BLOCK [8,BYTE]; 

		!+
		! dynamic? call STR$FREE1_DX.
		!-
		IF .DSC_ADDR [DSC$B_CLASS] EQL DSC$K_CLASS_D
		THEN
		    BEGIN
		    STATUS = STR$FREE1_DX (.DSC_ADDR);
		    END;

		!+
		! static?  mark length as 0 to prevent illicit usage as
		! a FIELDed variable.
		!-
		IF .DSC_ADDR [DSC$B_CLASS] EQL DSC$K_CLASS_S
		THEN
		    BEGIN
		    DSC_ADDR [DSC$W_LENGTH] = 0;
		    END;

		END;	! Incr dsc_addr

	    END;    ! If .array [dsc$b_dtype] eql dsc$k_dtype_dsc

	!+
	! finally, free the old array itself up.
	!-
	LENGTH = (IF .ARRAY [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	      THEN
		(.ARRAY [DSC$L_ARSIZE]/ .ARRAY [DSC$W_LENGTH]) * 
		(.ARRAY [DSC$W_LENGTH]/ 2 + 1)	! compute length in bytes
	      ELSE
		.ARRAY [DSC$L_ARSIZE]);
	STATUS = LIB$FREE_VM ( LENGTH, ARRAY [DSC$A_POINTER]);
	IF NOT (.STATUS) 
	THEN 
	    BAS$$STOP (BAS$K_PROLOSSOR);

	END;	! If .array [dsc$a_pointer] neq 0

!+
! Calculate the amount of space needed for the new size.
!-

    INCR COUNTER FROM 1 TO .ARRAY [DSC$B_DIMCT] DO
	BEGIN
	IF ACTUALPARAMETER (.COUNTER + 1) LSS 0
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);	! don't allow bounds < 0
	AR_SIZE = .AR_SIZE * (ACTUALPARAMETER (.COUNTER + 1) + 1);
	END;

    AR_SIZE = .AR_SIZE * .ARRAY [DSC$W_LENGTH];
    ARRAY [DSC$L_ARSIZE] = .AR_SIZE;

!+
! Update the bounds and multipliers in the array descriptor.
!-

    BOUNDS = ARRAY [DSC$L_M1] + (%UPVAL * .ARRAY [DSC$B_DIMCT]);
    MULTIPLIERS = ARRAY [DSC$L_M1];

    INCR COUNTER FROM 0 TO ((.ARRAY [DSC$B_DIMCT] * 2)  - 1) BY 2 DO
	BEGIN
	MAP
	    BOUNDS : REF VECTOR;

	BOUNDS [.COUNTER] = 0;			! set lower bounds to 0
	BOUNDS [.COUNTER + 1] = ACTUALPARAMETER (.BNDSARG);
						! take upper bound that was passed
	BNDSARG = .BNDSARG + 1;			! point to next bounds arg, if any

	END;

    INCR COUNTER FROM 0 TO (.ARRAY [DSC$B_DIMCT] - 1) DO
	BEGIN
	MAP
	    MULTIPLIERS : REF VECTOR;
	MULTIPLIERS [.COUNTER] = ACTUALPARAMETER (.COUNTER + 2) + 1;
	END;

!+
! compute the total amount of space needed for the array, in bytes.
!-
    LENGTH = (IF .ARRAY [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	      THEN
		(.ARRAY [DSC$L_ARSIZE]/ .ARRAY [DSC$W_LENGTH]) * 
		(.ARRAY [DSC$W_LENGTH]/ 2 + 1)	! compute length in bytes
	      ELSE
		.ARRAY [DSC$L_ARSIZE]);

!+
! see if there's enough room to expand this process' virtual address space
! that much.  get the number of free pages available, multiply it by 512
! to get number of free bytes available, and see if this is more than the
! number of bytes needed (computed above).
!-
    STATUS = LIB$GET_EF (EVENT_FLAG);
    IF (NOT .STATUS) THEN LIB$STOP (.STATUS);

    STATUS = $GETJPIW ( EFN = .EVENT_FLAG, ITMLST = JPI_ITEMS );
    IF (NOT .STATUS) THEN LIB$STOP (.STATUS);

    STATUS = LIB$FREE_EF (EVENT_FLAG);
    IF (NOT .STATUS) THEN LIB$STOP (.STATUS);

    IF (.NUM_FREE_PAGES * 512) LSSU .LENGTH 
    THEN 
	BAS$$STOP (BAS$K_MAXMEMEXC);

!+
! Allocate space for the new size and store it's address in the pointer field
! of the array descriptor.
!-
    STATUS = LIB$GET_VM (LENGTH, ARRAY [DSC$A_POINTER]);
    IF NOT (.STATUS) 
    THEN 
	BAS$$STOP (BAS$K_MAXMEMEXC);
    ARRAY [DSC$A_A0] = .ARRAY [DSC$A_POINTER];

!+
! Initialize the space according to the data type of the array elements.
!-

    SELECTONE .ARRAY [DSC$B_DTYPE] OF
	SET

	[DSC$K_DTYPE_B, DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_F,
	 DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H, DSC$K_DTYPE_Z] :
	    BEGIN
	    LOCAL
		CURR_SIZE:	INITIAL(.ARRAY [DSC$L_ARSIZE]),
		CURR_ADDR: 	INITIAL(.ARRAY [DSC$A_POINTER]);

	    !+
	    ! initialize the array in chunks of %Xffff bytes at a time.  We do this 
	    ! because CH$FILL generates a MOVC5, and the length operand for MOVC5
	    ! is a WORD.  The total length of the array can be much longer than can
	    ! be addressed by a WORD.
	    !-
	    WHILE .CURR_ADDR LSS (.ARRAY [DSC$A_POINTER] + .ARRAY [DSC$L_ARSIZE]) DO
		BEGIN
	    	CH$FILL (%C'', MIN ( .CURR_SIZE, %X'0000FFFF'), .CURR_ADDR);
		CURR_SIZE = .CURR_SIZE - %X'0000FFFF';
		CURR_ADDR = .CURR_ADDR + %X'0000FFFF';
		END;
	    END;

	[DSC$K_DTYPE_P] :
	    BEGIN
	    LOCAL
		COUNT,
		END_ADDR;
	    BIND
		PACKED_ZERO = UPLIT BYTE (REP 15 OF (%X'00'), %X'0C');
	    COUNT = - .ARRAY [DSC$B_SCALE];
	    END_ADDR = .ARRAY [DSC$A_POINTER] + .LENGTH -
		(.ARRAY [DSC$W_LENGTH]/ 2 + 1);
	    INCR ELE_PTR FROM .ARRAY [DSC$A_POINTER] TO .END_ADDR 
		BY (.ARRAY [DSC$W_LENGTH]/ 2 + 1) DO
		BEGIN
		ASHP (COUNT, %REF(15), PACKED_ZERO, %REF(0),
		      ARRAY [DSC$W_LENGTH], .ELE_PTR);
		END;				! ele by ele copy to
	    END;				! accomodate scaling

	[DSC$K_DTYPE_DSC] :
	    BEGIN
	    LOCAL
		END_ADDR;
	    END_ADDR = .ARRAY [DSC$A_POINTER] + .ARRAY [DSC$L_ARSIZE] -
		.ARRAY [DSC$W_LENGTH];	
	    INCR DSC_ADDR FROM .ARRAY [DSC$A_POINTER] TO .END_ADDR BY .ARRAY [DSC$W_LENGTH] DO
		BEGIN
		MAP
		   DSC_ADDR : REF BLOCK [8,BYTE]; 
	    	DSC_ADDR [DSC$B_CLASS] = DSC$K_CLASS_D;
	    	DSC_ADDR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    	DSC_ADDR [DSC$W_LENGTH] = 0;
	    	DSC_ADDR [DSC$A_POINTER] = 0;
	    	END;
	    END;

	[OTHERWISE] :
	    BAS$$STOP (BAS$K_NOTIMP);

	TES;


    END;					! End of routine BAS$RT_DIM
!<BLF/PAGE>

END						! End of module BAS$RT_DIM

ELUDOM
