	.TITLE	KEYPAD - KEYPAD SYMBOL TABLE MANIPULATION ROUTINES
	.IDENT	'V04-000'
 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; KEYPAD SYMBOL TABLE MANIPULATION ROUTINES
;
; AUTHOR: Peter George 15-March-1983
;
; 	These routines all assume the structure of a keypad symbol
;	block, starting with the symbol name (SYM_T_SYMBOL), is as follows:
;
;		Byte - length of symbol name
;		ASCII symbol name
;		Word - combined lengths of next three strings + 4
;		Byte - length of if_state string
;		ASCII if_state string
;		Word - length of symbol value
;		ASCII symbol value
;		Byte - length of set_state string
;		ASCII set_state string
;
; MODIFIED BY:
;
;	V03-006	HWS0058		Harold Schultz		18-Apr-1984
;		Use DCL$ALLOC_STATE when setting temporary key states
;		and DCL$LOCKED_STATE to restore original state.
;		Exchange the synonym keypad names with the common key names.
;		(i.e. translate "FIND" to "E1" instead of "E1" to "FIND")
;
;	V03-006	HWS0052		Harold Schultz		09-Apr-1984
;		Translate synonym keypad names to a common key name.
;		(i.e. Translate "E1" to "FIND")
;		Add SHOW KEY/LOG.
;
;	V03-005	PCG0005		Peter George		09-Feb-1984
;		Change format of SHOW KEY display.
;		Add SHOW KEY/FULL.
;		Zero the input buffer at the end of DCL$DEFKEY.
;
;	V03-004	PCG0004		Peter George		01-Dec-1983
;		Add /ERASE.
;
;	V03-003	PCG0003		Peter George		27-Jul-1983
;		Move PSECT declaration.
;
;	V03-002	PCG0002		Peter George		27-May-1983
;		Validate key names before defining them.
;
;	V03-001	PCG0001		Peter George		07-Apr-1983
;		Tolerate omission of SET KEY qualifiers.
;		Add SHOW KEY/BRIEF/DIRECTORY.
;---

;
; MACRO LIBRARY CALLS
;
	PRCDEF				;DEFINE PROCESS DATA STRUCTURE
	WRKDEF				;DEFINE COMMAND DATA STRUCTURE
	PTRDEF				;DEFINE TOKEN DESCRIPTORS
	SYMDEF				;DEFINE SYMBOL ENTRY OFFSETS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$STSDEF				;DEFINE STATUS LONGWORD

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

;
; ASCIC TEXT STRINGS FOR SHOW KEYS DISPLAY.
;
SHOWHDR:
	.ASCIC	'!AC keypad definitions:'
BRIEFFAO:
	.ASCIC	'  !AS = "!AS"'
FULLFAO:
	.ASCIC	'  !AS = "!AS"  (!ACecho,!ACterminate,!ACerase,!AClock!AC!AC!AS)'
NO:	.ASCIC	'no'
STATE:	.ASCIC	'state='
NULL:	.BYTE	0
COMMA:	.ASCIC	','
;
; SYNONYM KEY NAME TABLES
;
;
; DEFINE SYNONYM KEY NAMES
;
; SYNONYM_NAME  SETS UP THE RELATIONSHIP BETWEEN THE SYNONYM (NAME1) AND
; THE COMMON KEY NAME (NAME2) THAT THE SYNONYM IS TRANSLATED TO. IF A NEW
; SYNONYM IS CREATED THAT TRANSLATES TO AN EXISTING COMMON KEY NAME (IN
; SYNDEF_TAB), ONLY AN ENTRY IN SYNNAME_TAB NEEDS TO BE ADDED. IF A NEW
; COMMON KEY NAME IS NEEDED, THEN ADD IT TO SYNDEF_TAB.
;
	.MACRO SYNONYM_NAME NAME1,NAME2
	.ASCIC	"NAME1"
	.WORD	'NAME2'_ADR - SYNDEF_TAB
	.ENDM
;
;
SYNNAME_TAB:
	SYNONYM_NAME	FIND,E1		;DEFINE SYNONYM KEY NAMES
	SYNONYM_NAME	INSERT_HERE,E2
	SYNONYM_NAME	REMOVE,E3
	SYNONYM_NAME	SELECT,E4
	SYNONYM_NAME	PREV_SCREEN,E5
	SYNONYM_NAME	NEXT_SCREEN,E6
	.BYTE		0		;END OF TABLE MARKER
;
; DEFINE COMMON SYNONYM KEY NAMES
;
; NAME = COMMON TRANSLATED NAME (I.E. "FIND")
;
	.MACRO	SYNONYM_TRN	NAME
'NAME'_ADR:
	.ASCIC	"NAME"
	.ENDM


SYNDEF_TAB:
	SYNONYM_TRN	E1
	SYNONYM_TRN	E2
	SYNONYM_TRN	E3
	SYNONYM_TRN	E4
	SYNONYM_TRN	E5
	SYNONYM_TRN	E6


	.SBTTL	DEFINE KEYPAD SYMBOL
;+
; DCL$DEFKEY - DEFINE KEYPAD SYMBOL
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEFINE/KEY
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED META-KEY IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. 
;-

DCL$DEFKEY::				;DEFINE META-KEY EQUIVALENCE

;
; SET INITIAL PARSE STATE.
;
	MOVL	#SYM_M_ECHO,R6			;INITIALIZE KEYPAD FLAGS
	MOVL	#1,R7				;INITIALIZE LOCAL FLAGS (/LOG)
	CLRL	R8				;CLEAR IF_STATE TOKEN PTR
	CLRQ	-(R9)				;ALLOCATE SET_STATE DESCRIPTOR

;
; PROCESS THE TOKENS ON THE COMMAND LINE.
;
	BSBW	DCL$GETDVAL			;SKIP PAST /KEY DESCRIPTOR
10$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_ENDLINE,R5		;EOL?
	BNEQ	15$				;NO, CONTINUE PARSING
	BRW	70$				;YES, THEN DONE PARSING
15$:	CMPB	#PTR_K_PARAMETR,R5		;ITEM TYPE PARAMETER?
	BNEQ	20$				;NO, THEN PROCESS QUALIFIER
	MOVQ	R1,-(R9)			;SAVE PARAMETER DESCRIPTOR
	BRB	10$				;GET NEXT TOKEN
20$:	BSBW	DCL$GETNVAL			;GET QUALIFIER NUMBER
	CMPL	R1,#CLI$K_DEFK_TERM		;QUALIFIER MATCH?
	BEQL	30$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DEFK_ECHO		;QUALIFIER MATCH?
	BEQL	35$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DEFK_LOCK		;QUALIFIER MATCH?
	BEQL	40$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DEFK_LOG		;QUALIFIER MATCH?
	BEQL	43$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DEFK_SET_		;QUALIFIER MATCH?
	BEQL	45$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DEFK_IF_S		;QUALIFIER MATCH?
	BEQL	50$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DEFK_ERAS		;QUALIFIER MATCH?
	BEQL	55$				;YES, THEN PROCESS
25$:	BRB	10$				;GET NEXT

30$:	SETBIT	SYM_V_TERMINATE,R6		;ASSUME /TERMINATE
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /NOTERMINATE
	CLRBIT	SYM_V_TERMINATE,R6		;CLEAR TERMINATE FLAG
	BRB	25$				;GET NEXT
35$:	SETBIT	SYM_V_ECHO,R6			;ASSUME /ECHO
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /NOECHO
	CLRBIT	SYM_V_ECHO,R6			;CLEAR ECHO FLAG
	BRB	25$				;GET NEXT
40$:	SETBIT	SYM_V_LOCK,R6			;ASSUME /LOCK
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /NOLOCK
	CLRBIT	SYM_V_LOCK,R6			;CLEAR LOCK FLAG
	BRB	25$				;GET NEXT
43$:	MOVL	#1,R7				;ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /NOLOG
	CLRL	R7				;CLEAR FLAG
	BRB	25$				;GET NEXT
55$:	SETBIT	SYM_V_ERASE,R6			;ASSUME /ERASE
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /NOERASE
	CLRBIT	SYM_V_ERASE,R6			;CLEAR ERASE FLAG
	BRB	25$				;GET NEXT

45$:	CLRBIT	SYM_V_STATE,R6			;ASSUME /NOSET_STATE
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /SET_STATE
	SETBIT	SYM_V_STATE,R6			;SET STATE FLAG
	BSBW	DCL$GETDVAL			;GET THE ASSOCIATED VALUE
	MOVQ	R1,(R9)				;SAVE THAT VALUE
	BRB	25$				;GET NEXT

50$:	CLRL	R8				;ASSUME /NOIF_STATE
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,25$;IGNORE IF NOT /IF_STATE
	MOVL	WRK_L_RSLNXT(R10),R8		;SAVE VALUE TOKEN PTR
52$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	CMPL	#PTR_K_COMMA,R4			;TERMINATOR A COMMA?
	BEQL	52$				;GET NEXT VALUE
	BRB	25$				;GET NEXT

;
; INSERT THE META-KEY SYMBOL IN THE SPECIFIED KEYPAD SYMBOL TABLES.
;
; SCRATCH STACK LOOKS LIKE:
;	(R9)	EQUIVALENCE STRING DESCRIPTOR
;	8(R9)	META-KEY NAME DESCRIPTOR
;	16(R9)	SET_STATE DESCRIPTOR
; R6 CONTAINS SYMBOL FLAGS
; 
70$:	PUSHAQ	8(R9)				;PUSH THE DESCRIPTOR ADDRESS
	CALLS	#1,VALIDATE_KEY_NAME		;IS IT VALID?
	BLBC	R0,97$				;NO, THEN RETURN ERROR
	MOVL	R7,R0				;GET /LOG FLAG
	MOVQ	8(R9),R1			;GET KEY NAME DESCRIPTOR
	BSBW	DCL$SYNONYM			;CHECK FOR SYNONYMS
	MOVQ	R1,8(R9)			;SAVE RETURNED KEYPAD NAME
	BBS	#SYM_V_TERMINATE,R6,71$		;BRANCH IF /TERMINATE
	BICL	#SYM_M_ECHO,R6			;IGNORE THE ECHO FLAG
71$:	ASSUME	PTR_K_COMMA NE 0
	MOVL	R8,WRK_L_RSLNXT(R10)		;RESET FOR FIRST IF_STATE VALUE
	BEQL	75$				;SKIP IF NONE
72$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	MOVL	R4,R8				;SAVE THE TERMINATOR
	BSBW	DCL$ALLOC_STATE			;SET NEW STATE
75$:	BSBW	DCL$ALLOCKEY			;ALLOCATE THE KEYPAD SYMBOL
	BLBC	R0,95$				;BRANCH IF ERROR

;
; OUTPUT /LOG MESSAGE.
;
	BLBC	R7,80$				;SKIP IF /NOLOG
	PUSHAB	8(R9)				;SET ADDRESS OF META-KEY NAME DESCR
	PUSHL	PRC_L_CURRKEY(R11)		;SET ADDRESS OF ASCIC STATE NAME
	MOVL	#2,R1				;SET ARGUMENT COUNT
	MOVL	#CLI$_DEFKEY,R0			;SET STATUS
	BSBW	DCL$FORMMSG			;OUTPUT THE LOG MESSAGE
80$:	CMPL	#PTR_K_COMMA,R8			;TERMINATOR A COMMA?
	BNEQ	90$				;NO, TIME TO EXIT
	BSBW	DCL$LOCKED_STATE		;YES, RESTORE LOCKED KEY STATE
						;  BEFORE GETTING NEXT STATE
	BRB	72$				;GET NEXT VALUE

;
; RESTORE KEYPAD STATE AND RETURN.
;
90$:	MOVC5	#0,(SP),#0,#WRK_C_INPBUFSIZ,-	;RESET THE INPUT BUFFER
		WRK_G_INPBUF(R10)		;
	STATUS	NORMAL				;SET NORMAL COMPLETION
95$:	BSBW	DCL$LOCKED_STATE		;RESTORE KEY STATE
	RSB					;
97$:	MOVL	#CLI$_IVKEYNAM,R0		;SET STATUS
	BRB	95$				;RETURN

	.SBTTL	DELETE KEYPAD SYMBOL
;+
; DCL$DELKEY - DELETE KEYPAD SYMBOL
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DELETE/KEY
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED META-KEY IS DELETED FROM THE SYMBOL TABLE.
;-

DCL$DELKEY::					;DELETE KEYPAD DEFINITION
;
; SET INITIAL PARSE STATE.
;
	CLRL	R8				;CLEAR STATE TOKEN PTR
	PUSHL	#3				;INITIALIZE LOCAL FLAGS 
						; /LOG, /ALL, NO UNDEFINED SYMBOLS

;
; PROCESS THE TOKENS ON THE COMMAND LINE.
;
	BSBW	DCL$GETDVAL			;SKIP PAST /KEY DESCRIPTOR
10$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_ENDLINE,R5		;EOL?
	BNEQ	15$				;NO, CONTINUE PARSING
	BRW	50$				;YES, THEN DONE PARSING
15$:	CMPB	#PTR_K_PARAMETR,R5		;ITEM TYPE PARAMETER?
	BNEQ	20$				;NO, THEN PROCESS QUALIFIER
	MOVQ	R1,R6				;SAVE PARAMETER DESCRIPTOR
	BICL	#2,(SP)				;CLEAR /ALL FLAG
	BRB	10$				;GET NEXT TOKEN
20$:	BSBW	DCL$GETNVAL			;GET QUALIFIER NUMBER
	CMPL	R1,#CLI$K_DELK_LOG		;QUALIFIER MATCH?
	BEQL	25$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_DELK_STAT		;QUALIFIER MATCH?
	BEQL	30$				;YES, THEN PROCESS
	BRB	10$				;GET NEXT

25$:	BISL	#1,(SP)				;ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$;IGNORE IF NOT /NOLOG
	BICL	#1,(SP)				;CLEAR FLAG
	BRB	10$				;GET NEXT

30$:	CLRL	R8				;ASSUME /NOSTATE
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$;IGNORE IF NOT /STATE
	MOVL	WRK_L_RSLNXT(R10),R8		;SAVE VALUE TOKEN PTR
32$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	CMPL	#PTR_K_COMMA,R4			;TERMINATOR A COMMA?
	BEQL	32$				;GET NEXT VALUE
	BRB	10$				;GET NEXT

;
; SET KEYPAD STATE.
;
50$:	ASSUME	PTR_K_COMMA NE 0
	MOVL	R8,WRK_L_RSLNXT(R10)		;RESET FOR FIRST STATE VALUE
	BEQL	53$				;SKIP IF NONE
52$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	MOVL	R4,R8				;SAVE THE TERMINATOR
	BSBW	DCL$ALLOC_STATE			;SET NEW STATE
;
; DETERMINE WHETHER DELETING ONE SYMBOL OR /ALL SYMBOLS.
;
53$:	BBS	#1,(SP),60$			;BRANCH IF /ALL

;
; FIND SPECIFIED SINGLE SYMBOL VALUE.
;
54$:	MOVQ	R6,R1			;GET DESCRIPTOR OF SYMBOL NAME
	MOVL	(SP),R0			;GET /LOG FLAG
	BSBW	DCL$SYNONYM		;CHECK FOR SYNONYM KEY NAME
	MOVQ	R1,R6			;SAVE DESCRIPTOR IN CASE OF UNDKEY
	BSBW	DCL$FIND_KEYPAD		;SEARCH FOR SYMBOL
	BLBS	R0,55$			;BRANCH IF SUCCESSFUL

;
; OUTPUT WARNING MESSAGE.
;
	BISL	#4,(SP)			;SET UNDEFINED SYMBOL FLAG
	BSBW	UNDKEY			;OUTPUT UNDEFINED KEY MSG
	BRB	58$			;GET NEXT TABLE

;
; OUTPUT LOG MESSAGE IF REQUESTED.  DELETE THE SYMBOL.
;
55$:	BSBW	DELKEY			;OUTPUT DELKEY MSG AND DELETE THE KEY
58$:	CMPL	#PTR_K_COMMA,R8		;TERMINATOR A COMMA?
	BNEQ	90$			;NO, TIME TO EXIT
	BSBW	DCL$LOCKED_STATE	;YES, RESTORE LOCKED KEY STATE
					;  BEFORE GETTING NEXT STATE
	BRB	52$			;GET NEXT STATE

;
; RESTORE KEYPAD STATE, SET STATUS, AND EXIT.
;
90$:	STATUS	NORMAL			;ASSUME SUCCESSFUL COMPLETION
	MOVL	(SP)+,R1		;GET FLAGS
	BBC	#2,R1,95$		;BRANCH IF NO UNDEFINED SYMBOLS
	MOVL	#CLI$_UNDKEY!STS$M_INHIB_MSG,R0 ;SET STATUS, INHIBIT RESIGNAL
95$:	BSBW	DCL$LOCKED_STATE	;RESTORE KEY STATE
	RSB

;
; DELETE ALL SYMBOL ENTRIES FOR THE SPECIFIED OR CURRENT STATE.
;
60$:	MOVAQ	PRC_Q_KEYPAD(R11),R6	;GET ADDRESS OF KEYPAD SYMBOL TABLE
	MOVL	R6,AP			;COPY ADDRESS OF TABLE LISTHEAD

;
; GET NEXT SYMBOL.  
;
70$:	MOVL	(R6),R6			;GET ADDRESS OF NEXT ENTRY
	CMPL	R6,AP			;END OF TABLE?
	BEQL	58$			;IF EQL YES

;
; IF STATE DOES NOT MATCH, THEN SKIP THIS SYMBOL.
;
	MOVAB	SYM_T_SYMBOL(R6),R4	;GET ADDRESS OF SYMBOL NAME
	MOVZBL	(R4)+,R1		;GET LENGTH OF SYMBOL NAME
	MOVAB	2(R4)[R1],R4		;GET ADDRESS OF IF_STATE		
	MOVL	PRC_L_CURRKEY(R11),R2	;GET CURRENT STATE LENGTH/ADDRESS
	MOVZBL	(R2)+,R1		;
	CMPB	R1,(R4)+ 		;STATE LENGTH THE SAME?
	BNEQ	70$			;IF DIFF THEN GET NEXT
	CMPC	R1,(R2),(R4)		;STATES MATCH?
	BNEQ	70$			;NO, THEN GET NEXT

;
; STATE DID MATCH.  OUTPUT LOG MESSAGE IF REQUESTED.  DELETE THE SYMBOL.
;
	MOVL	R6,R3			;COPY SYMBOL ADDRESS
	BSBB	DELKEY			;OUTPUT LOG MESSAGE AND DELETE THE KEY
	BRB	60$			;GET NEXT

;+
; DELKEY - OUTPUT THE DELKEY /LOG MESSAGE AND DELETE THE SPECIFIED KEY.
;-
DELKEY:					;OUTPUT DELKEY MSG AND DELETE THE KEY
	BLBC	4(SP),80$		;SKIP IF /NOLOG SPECIFIED
	MOVAB	SYM_T_SYMBOL(R3),-(SP)	;SET ADDR OF ASCIC STRING
	PUSHL	PRC_L_CURRKEY(R11)	;SET ADDRESS OF ASCIC STATE NAME
	MOVL	#2,R1			;SET FAO COUNT
	MOVL	#CLI$_DELKEY,R0		;SET STATUS
	BSBW	DCL$FORMMSG		;OUTPUT THE MESSAGE
80$:	BSBW	DCL$DEALLOCSYM		;DEALLOCATE KEYPAD ENTRY
	RSB				;RETURN

;+
; UNDKEY - OUTPUT THE UNDKEY WARNING MESSAGE.
;-
UNDKEY:					;OUTPUT UNDKEY WARNING 
	MOVQ	R6,-(SP)		;PUSH DESC OF SYMBOL NAME
	PUSHL	SP			;PUSH DESCR ADDRESS
	PUSHL	PRC_L_CURRKEY(R11)	;PUSH ADDR OF ASCIC STATE 	
	MOVL	#2,R1			;SET FAO COUNT
	MOVL	#CLI$_UNDKEY,R0		;SET UNDEFINED SYMBOL STATUS
	BSBW	DCL$FORMMSG		;OUTPUT THE MESSAGE
	ADDL	#8,SP			;RESTORE THE STACK
	RSB				;RETURN

	.SBTTL	SHOW KEYPAD SYMBOL TABLE ENTRIES
;+
; DCL$SHOWKEY - SHOW KEYPAD SYMBOL TABLE ENTRIES
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW KEYS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED KEYPAD SYMBOL TABLE ENTRY OR ALL KEYPAD SYMBOL TABLE 
;	ENTRIES FOR THE CURRENT OR SPECIFIED STATE ARE WRITTEN TO THE OUTPUT
;	STREAM.
;-
 
DCL$SHOWKEY::				;SHOW KEYPAD SYMBOL TABLE ENTRIES
;
; INIT PARSE STATE.
; FLAG BITS ARE:    0 = /ALL, 1 = /BRIEF, 2 = FIRST STATE, 
;		    3 = UNDKEY, 4 = /DIRECTORY.
;
	PUSHL	#1				;INIT MESSAGE FLAG (ASSUME /LOG)
	CLRL	-(SP)				;CLEAR STATE TOKEN PTR
	MOVL	#2,-(SP)			;INIT FLAGS (ASSUME /ALL /BRIEF)
	CLRQ	R6				;ZERO DESCRIPTOR OF SYMBOL NAME

;
; PROCESS THE TOKENS ON THE COMMAND LINE.
;
10$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	CMPB	#PTR_K_ENDLINE,R5		;END OF LINE?
	BEQL	11$				;BRANCH IF SO
	CMPB	#PTR_K_PARAMETR,R5		;PARAMETER?
	BNEQ	12$				;BRANCH IF QUALIFIER
	ASSUME	PTR_V_KEYWORD EQ 21
	BBS	#1,R3,10$			;SKIP IF OPTION KEYWORD
	MOVQ	R1,R6				;SAVE DESCRIPTOR OF SYMBOL NAME
	BISL	#1,(SP)				;INDICATE NOT /ALL
	BRB	10$				;GET NEXT TOKEN
11$:	BRW	20$				;AT END OF LINE. EXECUTE COMMAND

;
; PROCESS QUALIFIERS.
;
12$:	BSBW	DCL$GETNVAL			;GET QUALIFIER NUMBER
	CMPL	R1,#CLI$K_SHKY_FULL		;/FULL QUALIFIER?
	BEQL	16$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_SHKY_BRIE		;/BRIEF QUALIFIER?
	BEQL	18$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_SHKY_DIRE		;/DIRECTORY QUALIFIER?
	BEQL	19$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_SHKY_LOG		;/LOG QUALIFIER?
	BEQL	14$				;YES, THEN PROCESS
	CMPL	R1,#CLI$K_SHKY_STAT		;/STATE QUALIFIER?
	BNEQ	10$				;NO, THEN IGNORE

;
; PROCESS /STATE=state QUALIFIER.
;
	CLRL	4(SP)				;ASSUME /NOSTATE
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$;IGNORE IF NOT /STATE
	MOVL	WRK_L_RSLNXT(R10),4(SP)		;SAVE VALUE TOKEN PTR
13$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	CMPL	#PTR_K_COMMA,R4			;TERMINATOR A COMMA?
	BEQL	13$				;GET NEXT VALUE
	BRB	10$				;GET NEXT

;
; PROCESS /LOG QUALIFIER
;
14$:	BISL	#1,8(SP)			;ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$ ;IGNORE IF /NOLOG
	BICL	#1,8(SP)			;SET FLAG TO /NOLOG
	BRB	10$				;GET NEXT TOKEN	
;
; PROCESS /FULL /BRIEF AND /DIRECTORY QUALIFIERS.
;
16$:	BICL	#2,(SP)				;ASSUME /FULL
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$;IGNORE IF NOT /NOBRIEF
	BISL	#2,(SP)				;SET FLAG
	BRB	10$				;GET NEXT
18$:	BISL	#2,(SP)				;ASSUME /BRIEF
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,190$;IGNORE IF NOT /NOBRIEF
	BICL	#2,(SP)				;CLEAR FLAG
	BRW	10$				;GET NEXT
19$:	BISL	#16,(SP)			;ASSUME /DIRECTORY
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,190$;IGNORE IF NOT /NODIRECTORY
	BICL	#16,(SP)			;CLEAR FLAG
190$:	BRW	10$				;GET NEXT

;
; EXECUTE /DIRECTORY.
;
20$:	BBC	#4,(SP),21$			;BRANCH IF /NODIRECTORY
	MOVAQ	PRC_Q_KEYPAD(R11),AP		;GET ADDRESS OF KEYPAD SYMBOL TABLE
	PUSHL	AP				;SAVE R6
	CLRQ	R6				;SET INITIAL STATE DESCRIPTOR
210$:	MOVL	(AP),AP				;GET ADDRESS OF NEXT ENTRY
	CMPL	AP,(SP)				;END OF TABLE?
	BEQL	230$				;IF EQL, THEN DONE
	MOVZBL	SYM_T_SYMBOL(AP),R1		;GET LENGTH OF SYMBOL
	MOVAB	SYM_T_SYMBOL+3(AP)[R1],R2 	;GET ADDRESS OF IF_STATE LENGTH
	MOVZBL	(R2)+,R1			;GET IF_STATE LENGTH
	CMPL	R1,R6				;STATES MATCH
	BNEQ	220$				;NO, LIST IT
	MOVQ	R1,-(SP)			;SAVE STATE DESCRIPTOR
	CMPC3	R1,(R2),(R7)			;STATES MATCH?
	BNEQ	215$				;NO, THEN OUTPUT THE STATE
	MOVQ	(SP)+,R1			;RESTORE STATE DESCRIPTOR
	BRB	210$				;YES, THEN SKIP
215$:	MOVQ	(SP)+,R1			;RESTORE STATE DESCRIPTOR
220$:	MOVQ	R1,R6				;SAVE NEW STATE
	BSBW	DCL$MSGOUT			;OUTPUT THE STATE
	BRB	210$				;GET NEXT STATE
230$:	TSTL	(SP)+				;RESTORE THE STACK
	BRB	90$				;EXIT

;
; SET KEYPAD STATE.
;
	ASSUME	PTR_K_COMMA NE 0
21$:	MOVL	4(SP),WRK_L_RSLNXT(R10)		;RESET FOR FIRST STATE VALUE
	BEQL	23$				;SKIP IF NONE
22$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
	MOVL	R4,4(SP)			;SAVE THE TERMINATOR
	BSBW	DCL$ALLOC_STATE			;SET NEW STATE
;
; DETERMINE WHETHER DISPLAYING ONE SYMBOL OR /ALL SYMBOLS.
;
23$:	BLBC	(SP),40$			;BRANCH IF /ALL

;
; DISPLAY SPECIFIED SINGLE SYMBOL VALUE.
;
	MOVQ	R6,R1				;GET DESCRIPTOR OF SYMBOL NAME
	MOVL	8(SP),R0			;GET /LOG FLAG
	BSBW	DCL$SYNONYM			;CHECK FOR SYNONYM KEY NAMES
	MOVQ	R1,R6				;SAVE DESCRIPTOR IN CASE OF UNDKEY
	BSBW	DCL$FIND_KEYPAD			;FIND SPECIFIED SYMBOL
	BLBS	R0,35$				;BRANCH IF FOUND

;
; OUTPUT WARNING MESSAGE.
;
	BBCS	#2,(SP),33$			;SKIP BLANK LINE IF FIRST LINE
	CLRQ	R1				;SET NULL STRING
	BSBW	DCL$MSGOUT			;OUTPUT THE BLANK LINE
33$:	BISL	#8,(SP)				;SET UNDEFINED SYMBOL FLAG
	BSBW	UNDKEY				;OUTPUT UNDEFINED KEY MSG
	BRB	38$				;GET NEXT TABLE

;
; DISPLAY THE SYMBOL DATA.
;
35$:	BSBW	DISPHDR				;DISPLAY KEYPAD TABLE NAME
	BSBW	DISPSYMB			;DISPLAY THE SYMBOL DATA
38$:	CMPL	#PTR_K_COMMA,4(SP)		;TERMINATOR A COMMA?
	BNEQ	90$				;NO, TIME TO EXIT
	BSBW	DCL$LOCKED_STATE		;YES, RESTORE LOCKED KEY STATE
						;  BEFORE GETTING NEXT STATE
	BRB	22$				;GET NEXT STATE

;
; RESTORE KEYPAD STATE, SET NORMAL STATUS, AND EXIT.
;
90$:	STATUS	NORMAL				;ASSUME SUCCESSFUL COMPLETION
	MOVL	(SP)+,R1			;GET FLAGS
	BBC	#3,R1,95$			;BRANCH IF NO UNDEFINED SYMBOLS
	MOVL	#CLI$_UNDKEY!STS$M_INHIB_MSG,R0 ;SET STATUS, INHIBIT RESIGNAL
95$:	ADDL	#8,SP				;RESTORE THE STACK
	BSBW	DCL$LOCKED_STATE		;RESTORE KEY STATE
	RSB

;
; DISPLAY ALL SYMBOL ENTRIES FOR THE SPECIFIED OR CURRENT STATE.
;
40$:	BSBW	DISPHDR				;DISPLAY KEYPAD TABLE NAME
	MOVAQ	PRC_Q_KEYPAD(R11),R6		;GET ADDRESS OF KEYPAD SYMBOL TABLE
	MOVL	R6,AP				;COPY ADDRESS OF TABLE LISTHEAD

;
; GET NEXT SYMBOL.  
;
50$:	MOVL	(R6),R6				;GET ADDRESS OF NEXT ENTRY
	CMPL	R6,AP				;END OF TABLE?
	BEQL	38$				;IF EQL YES

;
; IF STATE DOES NOT MATCH, THEN SKIP THIS SYMBOL.
;
	MOVAB	SYM_T_SYMBOL(R6),R4		;GET ADDRESS OF SYMBOL NAME
	MOVZBL	(R4)+,R1			;GET LENGTH OF SYMBOL NAME
	MOVAB	2(R4)[R1],R4			;GET ADDRESS OF IF_STATE
	MOVZBL	(R4)+,R0			;GET IF_STATE LENGTH
	MOVL	PRC_L_CURRKEY(R11),R2		;GET CURRENT STATE LENGTH/ADDRESS
	MOVZBL	(R2)+,R1			;
	CMPC5	R1,(R2),#0,R0,(R4)		;STATES MATCH?
65$:	BLSS	38$				;NO, GET NEXT STATE
	BGTR	50$				;NO, GET NEXT SYMBOL

;
; STATE DID MATCH.  DISPLAY THE SYMBOL.
;
70$:	MOVL	R6,R3				;SET ADDRESS OF SYMBOL
	BSBB	DISPSYMB			;FORMAT AND OUTPUT ENTRY
	BRB	50$				;GET NEXT

;+
; DISPSYMB - DISPLAY THE VALUE AND ATTRIBUTES OF A GIVEN KEYPAD SYMBOL.
;
; INPUTS:
;
;	4(SP) = FLAGS LONGWORD - BIT 1 IS SET IF /BRIEF
;	R3 = ADDRESS OF SYMBOL TABLE ENTRY
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;-
DISPSYMB:				;FORMAT A SYMBOL
	MOVL	4(SP),R0		;GET THE FLAGS
	PUSHR	#^M<R6,R7,R9>		;SAVE REGISTERS
	PUSHL	(R8)			;SAVE SCRATCH DESCR LENGTH
	PUSHL	R8			;SAVE ADDR OF SCRATCH DESCR
	MOVL	R0,R8			;COPY THE FLAGS
	
;
; GET AND SAVE DESCRIPTOR OF SYMBOL NAME.
;
	MOVAB	SYM_T_SYMBOL(R3),R2	;POINT TO SYMBOL NAME
	MOVZBL	(R2)+,R1		;GET NAME LENGTH
	MOVQ	R1,-(R9)		;BUILD NAME DESCRIPTOR
	MOVL	R9,R7			;COPY SCRATCH STACK POINTER

;
; GET AND SAVE DESCRIPTOR OF SYMBOL VALUE.
;
	MOVAB	2(R2)[R1],R2		;GET ADDRESS OF IF_STATE LENGTH
	MOVZBL	(R2)+,R1		;GET LENGTH OF IF_STATE
	MOVAB	(R2)[R1],R2		;GET ADDRESS OF SYMBOL VALUE LENGTH
	MOVZWL	(R2)+,R1		;GET LENGTH/ADDRESS OF VALUE
	MOVQ	R1,-(R9)		;SAVE VALUE DESCRIPTOR
	MOVL	R9,R6			;COPY SCRATCH STACK POINTER

;
; GET AND SAVE DESCRIPTOR OF SET_STATE STRING.
;
	MOVAB	(R2)[R1],R2		;GET ADDRESS OF SET_STATE LENGTH
	MOVZBL	(R2)+,R1		;GET LENGTH/ADDRESS OF STATE
	BBC	#1,R8,10$		;SKIP IF /NOBRIEF
	CLRL	R1			;PUSH NULL STRING
10$:	MOVQ	R1,-(R9)		;SAVE STATE DESCRIPTOR
	MOVL	R9,R5			;COPY SCRATCH STACK POINTER
	
;
; CREATE AND SAVE DESCRIPTOR OF ASCIC FAO STRING.  OUTPUT WILL LOOK LIKE:
;
; 	symbol = "value"	(ECHO,TERMINATE,ERASE,LOCK,STATE=state)
;
	MOVAB	FULLFAO,R2		;ASSUME FULL DISPLAY
	BBC	#1,R8,20$		;SKIP IF /NOBRIEF
	MOVAB	BRIEFFAO,R2		;SET BRIEF DISPLAY
20$:	MOVZBL	(R2)+,R1		;MAKE INTO DESCRIPTOR
	MOVQ	R1,-(R9)		;AND PUSH ONTO STACK
	MOVL	R9,R4			;COPY SCRATCH STACK POINTER
	BBS	#1,R8,30$		;SKIP IF /BRIEF

;
; CREATE FAO PARAMETER LIST.  ASSUME NO ATTRIBUTES.
;
	MOVL	R5,-(R9)		;SET ADDR OF STATE DESCR
	MOVAB	NULL,-(R9)		;ASSUME STATE FLAG NOT SET
	MOVAB	NULL,-(R9)		;ASSUME STATE FLAG NOT SET
	MOVAB	NULL,-(R9)		;ASSUME LOCK FLAG SET
	MOVAB	NULL,-(R9)		;ASSUME ERASE FLAG SET
	MOVAB	NULL,-(R9)		;ASSUME TERMINATE FLAG SET
	MOVAB	NULL,-(R9)		;ASSUME ECHO FLAG SET
30$:	MOVL	R6,-(R9)		;SET ADDR OF VALUE DESCR
	MOVL	R7,-(R9)		;SET ADDR OF NAME DESCR
	MOVL	R9,R7			;SAVE ADDRESS OF PARAMETER LIST

;
; NOW RESET FAO ARGUMENTS FOR ANY ATTRIBUTES THAT WERE ABSENT.
;
	BBC	#1,R8,40$		;SKIP IF /NOBRIEF
	BRW	90$			;BRANCH IF /BRIEF

40$:	BBS	#SYM_V_ECHO,-		;IS ECHO SET?
		SYM_B_FLAGS(R3),50$	;
	MOVAB	NO,8(R9)		;

50$:	BBS	#SYM_V_TERMINATE,-	;IS TERMINATE SET?
		SYM_B_FLAGS(R3),60$	;
	MOVAB	NO,12(R9)		;

60$:	BBS	#SYM_V_ERASE,-		;IS ERASE SET?
		SYM_B_FLAGS(R3),70$	;
	MOVAB	NO,16(R9)		;

70$:	BBS	#SYM_V_LOCK,-		;IS LOCK SET?
		SYM_B_FLAGS(R3),80$	;
	MOVAB	NO,20(R9)		;

80$:	BBC	#SYM_V_STATE,-		;IS STATE SET?
		SYM_B_FLAGS(R3),90$	;
	MOVAB	COMMA,24(R9)		;
	MOVAB	STATE,28(R9)		;

;
; FORMAT AND OUTPUT THE MESSAGE
;
90$:	POPL	R8			;RESTORE SCRATCH DESCRIPTOR
	$FAOL_S	(R4),(R8),(R8),(R7)	;FORMAT OUTPUT MESSAGE
	MOVQ	(R8),R1			;GET OUTPUT MESSAGE PARAMETERS
	BSBW	DCL$MSGOUT		;OUTPUT THE MESSAGE
	POPL	(R8)			;RESTORE SCRATCH DESCR LENGTH
	POPR	#^M<R6,R7,R9>		;RESTORE REGISTERS
	RSB				;RETURN

;+
; DISPHDR - DISPLAY A KEYPAD TABLE HEADER
;
; INPUTS:
;
;	4(SP) = FLAGS LONGWORD - BIT 2 IS CLEAR IF FIRST TABLE
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	PRC_L_CURRKEY(R11) = ADDDRESS OF ASCIC TABLE NAME
;-
DISPHDR:				;DISPLAY KEYPAD TABLE HEADER
	BBCS	#2,4(SP),10$		;SKIP BLANK LINE IF FIRST HEADER
	CLRQ	R1			;SET NULL STRING
	BSBW	DCL$MSGOUT		;OUTPUT THE BLANK LINE
10$:	PUSHL	(R8)			;SAVE BUFFER SIZE
	MOVAB	SHOWHDR,R2		;GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R2)+,R1		;MAKE INTO DESCRIPTOR
	MOVQ	R1,-(SP)		;AND PUSH ONTO STACK
	MOVL	SP,R0			;SAVE ITS ADDRESS
	MOVAB	PRC_L_CURRKEY(R11),R1	;GET ADDRESS OF ASCIC STATE
	$FAO_S	(R0),(R8),(R8),(R1)	;FORMAT OUTPUT MESSAGE
	MOVQ	(R8),R1			;GET OUTPUT MESSAGE PARAMETERS
	BSBW	DCL$MSGOUT		;OUTPUT THE MESSAGE
	ADDL	#8,SP			;RESTORE THE STACK
	MOVL	(SP)+,(R8)		;RESTORE BUFFER SIZE	
	RSB				;RETURN

	.SBTTL	ALLOCATE AND INSERT ENTRY IN KEYPAD SYMBOL TABLE
;+
; DCL$ALLOCKEY - ALLOCATE AND INSERT ENTRY IN KEYPAD SYMBOL TABLE
;
; THIS ROUTINE IS CALLED TO ALLOCATE AND INSERT AN ENTRY IN THE KEYPAD
; SYMBOL TABLE.
;
; INPUTS:
;
;	R6 = KEYPAD FLAGS
;	R9 = ADDRESS OF BUFFER FORMATTED AS FOLLOWS
;
;		(R9) = DESCRIPTOR OF SYMBOL VALUE
;		8(R9) = DESCRIPTOR OF SYMBOL NAME
;		16(R9) = DESCRIPTOR OF SET_STATE NAME
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;	PRC_L_CURRKEY = STATE IN WHICH KEY IS TO BE ALLOCATED
;
; OUTPUTS:
;
;	THE KEYPAD TABLE IS SEARCHED FOR THE SPECIFIED ENTRY, AND IF FOUND, 
;	THE OLD ENTRY IS DEALLOCATED. A SYMBOL TABLE ENTRY IS THEN ALLOCATED, 
;	FILLED WITH THE SYMBOL, VALUE, AND STATE INFORMATION, AND THEN 
;	INSERTED IN THE SYMBOL TABLE.
;
;	R0 LOW BIT CLEAR INDICATES ALLOCATION FAILURE WITH CLI$_SYMOVF.
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R1,R2,R3,R4,R5 ARE DESTROYED.
;-
 
DCL$ALLOCKEY::
	DISABLE					;DISABLE CTRL/Y'S
	CLRQ	(SP)+				;REMOVE RETURN INFO FROM STACK

;
; SEARCH FOR PREVIOUS DEFINITION OF IDENTICAL SYMBOL.  IF FOUND, THEN
; DEALLOCATE IT.  FIND THE SPOT IN THE LINKED LIST TO INSERT THE NEW SYMBOL
; AT.
;
	MOVQ	8(R9),R1			;SET SYMBOL NAME DESCRIPTOR
	BSBW	DCL$FIND_KEYPAD			;SEARCH FOR SYMBOL
	BLBC	R0,10$				;IF LBC SEARCH FAILURE
	MOVQ	R1,-(SP)			;SAVE R1/R2
	BSBW	DCL$DEALLOCSYM			;DEALLOCATE KEYPAD ENTRY
	MOVQ	(SP)+,R1			;RESTORE R1/R2
	BSBW	DCL$FIND_KEYPAD			;SEARCH FOR SYMBOL

;
; CALCULATE SIZE OF NEW SYMBOL AND ALLOCATE IT.
;
10$:	MOVL	PRC_L_CURRKEY(R11),R1		;GET ADDR OF ASCIC IF_STATE
	MOVZBL	(R1),R1				;GET LENGTH OF IF_STATE
	ADDL	16(R9),R1			;ADD IN SET_STATE LENGTH
	ADDL	(R9),R1				;ADD IN VALUE LENGTH 
	ADDL	#4,R1				;ADD IN SIZE OF LENGTH FIELDS
	PUSHL	R1				;SAVE FOR FUTURE USE
	ADDL	8(R9),R1			;ADD IN META-KEY LENGTH 
	ADDL	#SYM_T_SYMBOL+3,R1		;ADD IN FIXED OVERHEAD
	PUSHL	R3				;SAVE SYMBOL TABLE PTR
	BSBW	DCL$ALLDYNMEM			;ALLOCATE DYNAMIC MEMORY
	POPL	R3				;RESTORE SYMBOL TABLE PTR
	BLBC	R0,90$				;IF LBC ALLOCATION FAILURE

;
; INITIALIZE THE STATICALLY PLACED FIELDS AND INSERT IT IN THE LINKED LIST.
;
	MOVW	R1,SYM_W_SIZE(R2)		;SET SIZE OF ALLOCATED BLOCK
	MOVB	R6,SYM_B_FLAGS(R2) 		;SET KEYPAD FLAGS
	MOVB	#SYM_K_KEYPAD,SYM_B_TYPE(R2)	;SET KEYPAD VALUE TYPE
	INSQUE	SYM_L_FL(R2),@SYM_L_BL(R3)	;INSERT ENTRY IN SYMBOL TABLE

;
; INITIALIZE THE DYNAMICALLY PLACED ASCIC FIELDS.
;
	MOVQ	8(R9),R3			;GET SYMBOL NAME
	MOVB	R3,SYM_T_SYMBOL(R2)		;INSERT LENGTH OF SYMBOL
	MOVC	R3,(R4),SYM_T_SYMBOL+1(R2) 	;INSERT SYMBOL NAME

	CVTLW	(SP)+,(R3)+			;INSERT LENGTH OF FOLLOWING

	MOVL	PRC_L_CURRKEY(R11),R2		;GET CURRENT STATE LENGTH/ADDRESS
	MOVZBL	(R2)+,R1			;GET LENGTH OF STRING VALUE
	MOVB	R1,(R3)+			;INSERT LENGTH OF STRING VALUE
	MOVC	R1,(R2),(R3)			;INSERT STRING VALUE

	MOVQ	(R9),R1				;GET SYMBOL VALUE
	MOVW	R1,(R3)+			;INSERT LENGTH OF STRING VALUE
	MOVC	R1,(R2),(R3)			;INSERT STRING VALUE

	MOVQ	16(R9),R1			;GET SET_STATE VALUE
	MOVB	R1,(R3)+			;INSERT LENGTH OF STRING VALUE
	MOVC	R1,(R2),(R3)			;INSERT STRING VALUE

	MOVL	#1,R0				;SET SUCCESS INDICATOR
	RSB					;

;
; RETURN SYMBOL TABLE OVERFLOW STATUS.
;
90$:	TSTL	(SP)+				;RESTORE THE STACK
	STATUS	SYMOVF				;SET SYMBOL TABLE OVERFLOW STATUS
	RSB

	.SBTTL	CHECK FOR SYNONYM KEY NAMES
;+
; DCL$SYNONYM - CHECK FOR SYNONYM KEY NAMES
;
; THIS ROUTINE IS CALLED TO DETERMINE WHETHER OR NOT THE KEY NAME INPUT
; HAS A SYNONYM NAME. IF SO, IT TRANSLATES THE KEY NAME TO A COMMON KEY NAME
; FOR THAT PARTICULAR KEY, WHICH IS THEN USED IN CONSTRUCTING THE KEYPAD
; SYMBOL TABLE. IF /LOG IS SPECIFIED IN THE COMMAND LINE, A CONVERSION MESSAGE
; IS OUTPUT INDICATING WHAT THE SYNONYM KEY WAS CHANGED TO IN THE KEYPAD
; SYMBOL TABLE.
;
;
; INPUTS:
;
;	R0 = /LOG FLAG (LBS = /LOG, LBC = /NOLOG)
;	R1 = LENGTH OF ENTERED KEY NAME
;	R2 = ADDRESS OF ENTERED KEY NAME
;
; OUTPUTS:
;
;	IF SYNONYM FOUND:
;
;	R1 = LENGTH OF TRANSLATED KEY NAME
;	R2 = ADDR. OF TRANSLATED KEY NAME
;
;
;	IF SYNONYM NOT FOUND:
;
;	R1  UNCHANGED
;	R2  UNCHANGED
;
;-

DCL$SYNONYM::
	MOVQ	R6,-(SP)		;SAVE WORK REGISTERS
	MOVL	R0,-(SP)		;SAVE /LOG FLAG
	MOVAB	SYNNAME_TAB,R6		;GET ADDR OF SYNONYM TABLE

10$:	MOVZBL	(R6),R7			;GET LENGTH OF THIS ENTRY
	BEQL	100$			;EXIT IF NO MATCHING ENTRY FOUND
	CMPW	R1,R7			;DOES THE LENGTH MATCH THIS ENTRY?
	BNEQ	40$			;NO, SKIP TO NEXT ENTRY IN TABLE
	MOVQ	R1,-(SP)		;SAVE POINTERS
	CMPC5	R1,(R2),#0,R7,1(R6)	;IS THERE A MATCH ON THIS ENTRY?
	BEQL	50$			;YES, GET NEW KEY NAME FROM TRANSLATION TABLE
	MOVQ	(SP)+,R1		;RESTORE POINTERS

40$:	MOVAB	3(R6)[R7],R6		;MOVE TO NEXT ENTRY IN SYNONYM TABLE
	BRB	10$
;
; HAVE FOUND A MATCH IN SYNONYM TABLE. GET ACTUAL KEY NAME FROM TRANSLATION TABLE.
;
50$:	MOVQ	(SP)+,R1		;RESTORE POINTERS
	MOVAB	1(R6)[R7],R6		;GET ADDR. OF OFFSET INTO TRANS. TABLE
	MOVZWL	(R6),R6			;GET ACTUAL OFFSET
	MOVAB	SYNDEF_TAB[R6],R6	;GET ADDR. OF COMMON KEY NAME STRING
	MOVQ	R1,R3			;SAVE ENTERED KEY NAME FOR CONV. MESSAGE.
	MOVZBL	(R6)+,R1		;FORM DESCRIPTOR FOR TRANS. NAME
	MOVAB	(R6),R2			;
;
; OUTPUT CONVERSION MESSAGE IF /LOG SPECIFIED
;
	BLBC	(SP),100$		;SKIP MESSAGE IF /NOLOG
	SUBL	#16,SP			;MAKE A TEMPORARY SCRATCH BUFFER
	MOVQ	R1,(SP)			;GET TRANSLATED KEY NAME
	MOVQ	R3,8(SP)		;GET ENTERED KEY NAME
	PUSHAB	(SP)			;SET ADDR. OF TRANS. KEY NAME
	PUSHAB	12(SP)			;SET ADDR. OF ENTERED KEY NAME
	MOVL	#2,R1			;SET ARGUMENT COUNTER
	MOVL	#CLI$_KEYCNV,R0		;SET CONVERTED KEY STATUS
	BSBW	DCL$FORMMSG		;OUTPUT CONVERSION MESSAGE
	MOVQ	(SP),R1			;RESTORE TRANSLATED  DESCRIPTOR
	ADDL	#16,SP			;REMOVE TEMPORARY SCRATCH BUFFER

100$:	TSTL	(SP)+			;REMOVE /LOG FLAG
	MOVQ	(SP)+,R6		;RESTORE WORK REGISTERS
	RSB				;EXIT

	.SBTTL	SEARCH FOR SYMBOL ENTRY IN KEYPAD SYMBOL TABLE
;+
; DCL$SEARCH_KEYPAD - SEARCH FOR SYMBOL ENTRY IN KEYPAD SYMBOL TABLE
;
; THIS ROUTINE IS CALLED TO SEARCH THE KEYPAD SYMBOL TABLE FOR AN ENTRY.  
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R1 = LENGTH OF SYMBOL.
;	R2 = ADDRESS OF SYMBOL.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = QUADWORD DESCRIBING SYMBOL VALUE:
;		IF R2 NONZERO, QUADWORD IS A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;	R3 = ADDRESS OF SYMBOL ENTRY
;	R4 = KEYPAD FLAGS
;
;-
 
DCL$SEARCH_KEYPAD::			;SEARCH FOR SYMBOL ENTRY IN KEYPAD TABLE
	BSBB	DCL$FIND_KEYPAD		;SEARCH KEYPAD SYMBOL TABLE FOR ENTRY
	BLBC	R0,10$			;IF LBC NO MATCH FOUND

	MOVZBL	SYM_T_SYMBOL(R3),R1	;GET LENGTH OF SYMBOL
	MOVAB	SYM_T_SYMBOL+3(R3)[R1],R2 ;GET ADDRESS OF IF_STATE LENGTH
	MOVZBL	(R2)+,R1		;GET LENGTH OF IF_STATE
	MOVAB	(R2)[R1],R2		;GET ADDRESS OF VALUE LENGTH
	MOVZWL	(R2)+,R1		;GET LENGTH OF VALUE
	MOVZBL	SYM_B_FLAGS(R3),R4	;GET KEYPAD FLAGS

10$:	RSB				;

	.SBTTL	SEARCH KEYPAD SYMBOL TABLE FOR ENTRY
;+
; DCL$FIND_KEYPAD - SEARCH KEYPAD SYMBOL TABLE FOR ENTRY
;
; THIS ROUTINE IS CALLED TO SEARCH THE KEYPAD SYMBOL TABLE FOR AN ENTRY.
; ONLY DEFINITIONS FOR THE PRC_L_CURRKEY STATE ARE CHECKED.
;
; INPUTS:
;
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;	R11 = ADDRESS OF PRC DATA STRUCTURE
;	PRC_L_CURRKEY = CURRENT KEY STATE	
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R1 = LENGTH OF SYMBOL NAME.
;		R2 = ADDRESS OF SYMBOL NAME.
;		R3 = ADDRESS OF NEXT GREATEST SYMBOL ENTRY.
;		R4 ARE DESTROYED.
;
;	R0 LOW BIT SET INDICATES SYMBOL FOUND WITH:
;
;		R1 = LENGTH OF SYMBOL NAME.
;		R2 = ADDRESS OF SYMBOL NAME.
;		R3 = ADDRESS OF SYMBOL ENTRY.
;		R4 IS DESTROYED
;-
 
DCL$FIND_KEYPAD::			;SEARCH KEYPAD SYMBOL TABLE FOR ENTRY

;
; SET ADDRESS OF SYMBOL TABLE.
;
	MOVAB	PRC_Q_KEYPAD(R11),R3	;SET ADDRESS OF KEYPAD SYMBOL TABLE LISTHEAD
	MOVL	R3,R0			;COPY ADDRESS OF SYMBOL TABLE LISTHEAD

;
; SEARCH FOR THE SPECIFIED SYMBOL.
;
10$:	MOVL	SYM_L_FL(R3),R3		;GET ADDRESS OF NEXT ENTRY
	CMPL	R0,R3			;END OF TABLE?
	BEQL	90$			;IF EQL YES

;
; CHECK THAT THE SYMBOL STATE MATCHES.
;
	PUSHR	#^M<R0,R1,R2,R3>	;SAVE SEARCH PARAMETERS
	MOVZBL	SYM_T_SYMBOL(R3),R1	;GET LENGTH OF SYMBOL
	MOVAB	SYM_T_SYMBOL+3(R3)[R1],R4 ;GET ADDRESS OF IF_STATE LENGTH
	MOVZBL	(R4)+,R0 		;GET IF_STATE LENGTH
	MOVL	PRC_L_CURRKEY(R11),R2	;GET CURRENT STATE LENGTH/ADDRESS
	MOVZBL	(R2)+,R1		;
	CMPC5	R1,(R2),#0,R0,(R4)	;STATES MATCH?
20$:	POPR	#^M<R0,R1,R2,R3>	;RESTORE SEARCH PARAMETERS
	BGTR	10$			;IF NEQ NO
	BLSS	90$			;

;
; CHECK THAT THE SYMBOL NAME MATCHES.
;
	MOVAB	SYM_T_SYMBOL(R3),R4	;GET ADDRESS OF SYMBOL NAME
	PUSHR	#^M<R0,R1,R2,R3>	;SAVE SEARCH PARAMETERS
	MOVZBL	(R4)+,R0		;GET LENGTH OF SYMBOL NAME
	CMPC5	R1,(R2),#0,R0,(R4)	;SYMBOLS MATCH?
	POPR	#^M<R0,R1,R2,R3>	;RESTORE SEARCH PARAMETERS
	BGTR	10$			;IF NEQ NO
	BLSS	90$			;

	INCL	R0			;SET SUCCESS INDICATOR
90$:	RSB				;


	.SBTTL	SET KEYPAD STATE
;+
; DCL$SETKEY - SET KEYPAD STATE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET KEYPAD
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED KEYPAD STATE BECOMES THE LOCKED CURRENT STATE.
;-
 
DCL$SETKEY::				;SET KEYPAD SYMBOL TABLE STATE
	MOVL	#1,R8			;ASSUME /LOG 
	CLRQ	R6			;INIT STATE NAME DESCRIPTOR

;
; PROCESS THE TOKENS ON THE COMMAND LINE.
;
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUE
	CMPB	#PTR_K_ENDLINE,R5	;END OF LINE?
	BEQL	50$			;BRANCH IF SO
	CMPB	#PTR_K_PARAMETR,R5	;PARAMETER?
	BEQL	10$			;IGNORE IF SO
	BSBW	DCL$GETNVAL		;GET QUALIFIER NUMBER
	CMPB	R1,#CLI$K_STKY_STAT	;/STATE?
	BEQL	20$			;YES, PROCESS IT
	CMPB	R1,#CLI$K_STKY_LOG	;/LOG?
	BEQL	30$			;YES, PROCESS IT
	BRB	10$			;NO, GET NEXT TOKEN

20$:	CLRQ	R6			;INIT STATE NAME DESCRIPTOR
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$ ;IGNORE IF NOT /STATE
	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUE
	MOVQ	R1,R6			;SAVE IT AWAY
	BRB	10$			;GET NEXT

30$:	BISL	#1,R8			;ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$ ;IGNORE IF NOT /NOLOG
	BICL	#1,R8			;CLEAR FLAG
	BRB	10$			;GET NEXT

;
; SET THE SPECIFIED STATE.
;
50$:	MOVQ	R6,R1			;GET STATE DESCRIPTOR
	BEQL	90$			;EXIT IF NONE SPECIFIED
	BSBB	DCL$ALLOC_STATE		;SET NEW STATE
	BLBC	R0,90$			;EXIT IF ERROR
	MOVL	PRC_L_LASTKEY(R11),R0	;CLEAR LAST STATE
	BSBW	DCL$DEALLOC_STATE	;
	MOVL	PRC_L_CURRKEY(R11),-	;COPY KEY DEFINITION
		PRC_L_LASTKEY(R11)	;

;
; OUTPUT LOG MESSAGE IF REQUESTED.
;
	BLBC	R8,90$			;SKIP IF /NOLOG SPECIFIED
	PUSHL	PRC_L_CURRKEY(R11)	;SET ADDRESS OF ASCIC STATE NAME
	MOVL	#1,R1			;SET ARGUMENT COUNT
	MOVL	#CLI$_SETKEY,R0		;SET STATUS
	BSBW	DCL$FORMMSG		;OUTPUT THE LOG MESSAGE

90$:	STATUS	NORMAL			;SET NORMAL SUCCESS STATUS
	RSB				;RETURN


	.SBTTL	ALLOCATE AND INIT A KEYPAD STATE SYMBOL
;+
; DCL$ALLOC_STATE - ALLOCATE AND INIT A KEYPAD STATE SYMBOL
;
; THIS ROUTINE IS CALLED TO ALLOCATE AND INIT A KEYPAD STATE SYMBOL.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF NEW KEYPAD STATE
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	PRC_L_CURRKEY = SET TO THE NEWLY ALLOCATED STATE SYMBOL
;
;	R0 LBC INDICATES SYMBOL TABLE OVERFLOW
;-
 
DCL$ALLOC_STATE::				;ALLOCATE STATE SYMBOL
	PUSHR	#^M<R1,R2,R3,R4,R5>		;SAVE R1-R5
	DISABLE					;DISABLE CTRL/Y'S
	MOVQ	R1,R4				;SAVE STATE DESCRIPTOR
	INCL	R1				;ADD ROOM FOR BYTE COUNT
	BSBW	DCL$ALLDYNMEM			;GET MEMORY TO SAVE STATE IN	
	BLBC	R0,90$				;BRANCH IF NO ROOM FOR SYMBOL
	MOVL	R2,PRC_L_CURRKEY(R11)		;SET CURRENT KEY STATE
	MOVB	R4,(R2)+			;MOVE THE STRING LENGTH
	MOVC3	R4,(R5),(R2)			;MOVE THE STRING
	STATUS NORMAL				;SET NORMAL STATUS
	ENABLE					;ENABLE CTRL/Y'S
	POPR	#^M<R1,R2,R3,R4,R5>		;RESTORE R1-R5
	RSB					;

90$:	ENABLE					;ENABLE CTRL/Y'S
	POPR	#^M<R1,R2,R3,R4,R5>		;RESTORE R1-R5
	STATUS	SYMOVF				;
	RSB					;


	.SBTTL	DEALLOCATE A KEYPAD STATE SYMBOL
;+
; DCL$DEALLOC_STATE - DEALLOCATE A KEYPAD STATE SYMBOL
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A KEYPAD STATE SYMBOL.
;
; INPUTS:
;
;	R0 = ADDRESS OF ASCIC KEYPAD STATE
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	NONE
;-
 
DCL$DEALLOC_STATE::				;DEALLOCATE STATE SYMBOL
	DISABLE					;DISABLE CTRL/Y'S
	MOVQ	R0,-(SP)			;SAVE R0-R3
	MOVQ	R2,-(SP)			;
	MOVZBL	(R0),R1				;GET LENGTH OF TEMPORARY STATE
	INCL	R1				;INCR TO INCLUDE BYTE COUNT
	BSBW	DCL$DEADYNMEM			;DEALLOCATE THE BLOCK
	MOVQ	(SP)+,R2			;RESTORE R0-R3
	MOVQ	(SP)+,R0			;
	ENABLE					;ENABLE CTRL/Y'S
	RSB					;

	.END
