	.IF	NDF,CONFIGSW
	.TITLE	SYSGEN - SYSGEN UTILITY AND PARAMETER FILE EDITOR
	.IFF
	.TITLE	CONFIGUTL - SYSGEN UTILITIES FOR CONFIGURE PROCESS
	.ENDC
	.IDENT	'V04-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; Facility:  System generation and initialization
;
; Abstract: SYSGEN is the main routine to provide all SYSBOOT parameter
;	alteration commands in an online environment.
;
; Environment:
;
; Author:  RICHARD I. HUSTVEDT, Creation date:  4-MAY-1978
;
; MODIFIED BY:
;
;	V04-002 WHM0011		Bill Matthews		14-Sep-1984
;		Changed the defaults for the MSCP command.
;
;	V04-001	WHM0010		Bill Matthews		04-Sep-1984
;		Changed IO PRIORITY default for the MSCP command and
;		disallow loading of the MSCP server multiple times.
;
;	V03-023	WHM0009		Bill Matthews		23-Jul-1984
;		Changed defaults for the MSCP command.
;
;	V03-022	WHM0008		Bill Matthews		20-Apr-1984
;		Removed WRITE CURRENT code that wrote the SYSGEN parameters
;		to SYS.EXE.
;
;	V03-021	WHM0007		Bill Matthews		04-Apr-1984
;		Added support to write current to write to a seperate
;		default system parameter file.
;		Added support to use file to accept long ascii sysgen parameters
;
;	V03-020	WHM0006		Bill Matthews		14-Mar-1984
;		Modify SGN$GET_DEVICE to take out the I/O database MUTEX and
;		raise IPL before calling IOC$SEARCHALL.
;
;	V03-019	WHM0005		Bill Matthews		13-Mar-1984
;		Move definition of BOO$GL_LOAD_ARGS from SYSBOOCMD to
;		this module.
;
;	V03-018	ACG0399		Andrew C. Goldstein,	10-Mar-1984  0:36
;		Change check for SS$_NODEVAVL to SS$_NOSUCHDEV due to
;		rewrite of IOC$SEARCHDEV.
;
;	V03-016	WHM0004		Bill Matthews	23-Feb-1984
;		Added support for loading and starting the MSCP server.
;
;	V03-015	WHM0003		Bill Matthews	04-Feb-1984
;		Added support for ACF$B_COMBO_VECTOR_OFFSET to clean up support
;		of combo style devices.
;
;	V03-014	TMK0001		Todd M. Katz	31-Jan-1984
;		Change a BSBW to a JSB.
;
;	V03-013	WHM0002		Bill Matthews		13-Dec-1983
;		Fixed several calls to SGN$GET_DEVICE to pass the unit number
;		to be connected not the maximum units.
;		Added support for the new CONNECT command qualifiers
;		/CSR_OFFSET and /VECTOR_OFFSET.
;
;	V03-012	JLV0312		Jake VanNoy		26-Oct-1983
;		Fix bug for microVAX that allows nexus 0 in CONNECT.
;
;	V03-011	WHM0001		Bill Matthews		09-Dec-1983
;		Changed some bsbw's to jsb's
;
;	V03-010	WMC0003		Wayne Cardoza		09-Aug-1983
;		Fix loadable code error handling.
;		USEACTIVE should be in configutl.
;
;	V03-009	WMC0002		Wayne Cardoza		29-Jul-1983
;		More features for code loading.
;
;	V03-008	WMC0001		Wayne Cardoza		27-Jul-1983
;		Support general code loading.
;
;	V03-007	MSH0006		Maryann Hinden 		24-Jun-1983
;		Use $BOOCMDDEF instead of $BOODEF.
;
;	V03-006 MSH0005		Maryann Hinden		04-May-1983
;		Changes to support CONFIGURE process.
;
;	V03-005	MSH0004		Maryann Hinden		13-May-1983
;		Change some BSBW PUTERROR instructions to JSB instead.
;
;	V03-004 MSH0003		Maryann Hinden		31-Jan-1983
;		Add support for cluster device names.
;
;	V03-003	TCM0001		Trudy C. Matthews	8-Nov-1982
;		Use new ADP$L_AVECTOR field in calculation of ACF$W_AVECTOR,
;		instead of calculating it from the adapter's TR number.
;
;	V03-002 MSH0002		Maryann Hinden		22-Oct-1982
;		Fix broken BSBW.
;
;	V03-001 MSH0001		Maryann Hinden		30-Sep-1982
;		Check for DDB$L_UCB = 0.
;--

;
; Include files:
;
	$ACFDEF				; Define autoconfiguration block
	$ADPDEF				; Define adapter control block
	$BOOCMDDEF			; Define SYSGEN command options
	$CLIDEF				; Define CLI codes and values
	$CRBDEF				; Define CRB offsets
	$DDBDEF				; Define DDB offsets
	$DYNDEF				; Block types
	$HLPDEF				; Define HELP symbols
	$IDBDEF				; Define IDB offsets
	$IHDDEF				; Image header offsets
	$IPLDEF				; Define IPLs
	$JPIDEF				; $GETJPI definitions
	$LBRDEF				; Librarian symbols
	$OPCDEF				; Operator message definitions
	$PRDEF				; Define processor registers
	$PRMDEF				; Parameter descriptor definitions
	$SBDEF				; SCS system block definitions
	$SHRDEF				; Error codes
	$SLVDEF				; Loadable code header
	$SSDEF				; Define system status values
	$SYSGMSGDEF			; Sysgen messages
	$TPADEF				; TPARSE definitions
	$UCBDEF				; Define UCB offsets
	$VECDEF				; Define VEC offsets
	
;
; Equated Symbols:
;
	CR=13				; Character value for carriage return
	FF=12				; Character value for form feed
	LF=10				; Character value for line feed
	UBA_IOBASE=8*512		; Offset from UBA configuration register
					; to base of I/O page
;
; Own Storage
;
	.PSECT	$$$$000,NOEXE,NOWRT	; PSECT to mark lower address
BOO$LOLIM::				; Marker definition
	.PSECT	____ZZZ,WRT,PAGE	; PSECT to mark upper address limit
BOO$HILIM::				;
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

BOO$AB_PATCH::				; Non-paged Patch area
	.BLKB	512			; One page
BOO$AB_PRMBUF::				; Parameter buffer
	.BLKB	512*16			; A generous buffer
BOO$AB_LOADBUF:				; Buffer for code loader
	.BLKB	512
ACF$GL_DDB::
	.LONG	0
ACF$GL_UCB::
	.long	0
ACF$GL_IDB::
	.long	0
ACF$GL_CRB::
	.long	0
ACF$GL_LASTDDB::
	.long	0
ACF$GL_DPT::
	.long	0
ACF$GL_SB::
	.LONG	0
BOO$GL_COMBO_VECTOR_OFFSET::		; Offset to vector from start of combo
	.LONG	0			; device's vectors
BOO$GL_COMBO_CSR_OFFSET::		; Offset to CSR from start of combo
	.LONG	0			; device's CSR
BOO$GL_CONADP::				; Adapter TR number
	.LONG	-2			; Null value
BOO$GL_CONCREG::			; Control register
	.LONG	-1			; Null value
BOO$GL_CONCUNIT::			; Controller unit
	.LONG	-1			; Null value
BOO$GL_CONNUMU::			; Number of Units to configure
	.LONG	1			; Default value is 1 unit
BOO$GL_CONVECT::			; Vector offset
	.LONG	-1			; Null value
BOO$GL_CONNUMV::			; Number of vectors
	.LONG	-1			; Null value
BOO$GL_CONAUNIT::			; Adapter unit
	.LONG	-1			; Null value
BOO$GL_CONDEV::				; Device name string address
	.LONG	-1			; Null value
BOO$GL_CONDRV::				; Driver name string address
	.LONG	-1			; Null value
BOO$GL_CONUNITS::			; Maximum units
	.LONG	0			;
BOO$GQ_CONSYSID::			; System ID
	.LONG	0			; quadword
	.LONG	0			;
BOO$GL_CONCRB::				; CRB address
	.LONG	0			;
BOO$GL_CONFLAGS::			; Flags
	.LONG	0			;
BOO$GL_NEXTSTR::			; Next string location
	.LONG	0			;
BOO$GL_SELECT::				; Address of select list
	.LONG	0			;
BOO$AL_CLIBLK::				; CLI call back block
	$CLIREQDESC	-		; Get command call back block
		RQTYPE=CLI$K_GETCMD	;
BOO$GQ_CMDESC==BOO$AL_CLIBLK+CLI$W_RQSIZE	; Command descriptor address
BOO$GT_PROMPT::				; Prompt string
	.ASCIZ	<CR><LF>%SYSGEN>  %	;
BOO$AL_ACF::				; Auto-configuration block
	.BLKB	ACF$C_LENGTH		; Allocate space for it
BOO$GQ_LIMITS::				; High and low address limits for lockdown
	.LONG	BOO$LOLIM		; Lower address bound
	.LONG	BOO$HILIM-1		;
BOO$GQ_RETADR::				; Return address receiver
	.LONG	0,0			;
BOO$GL_RETSAVE::			; Saved co-routine return address
	.LONG	0			;
FACNAMED::				; Facility name descriptor
	.LONG	FACNAMSZ,FACNAME	;
FACNAME:.ASCII	/SYSGEN/		;
FACNAMSZ=.-FACNAME			; Length of facility name
CONSNAME:				; Console block storage 
	.ASCIC	/CSA/			; device name
BOO$GT_OPNAME::				; Console terminal device name
	.ASCIC	/OPA/			;
BOO$GT_CVNAME::				; Name of RL02 driver
	.ASCIC	/CVDRIVER/
BOO$GT_DXNAME::				; Name of floppy driver
	.ASCIC	/DXDRIVER/
BOO$GT_DDNAME::				; Name of TU58 driver
	.ASCIC	/DDDRIVER/

BOO$GL_FILEADDR::			; File spec address
	.LONG	0			;
BOO$GB_FILELEN::			; File spec length
	.BYTE	0			;

BOO$GL_PARINUSE::	.LONG	0
BOO$GT_CURRENT::	.ASCIC	/Current/
BOO$GT_ACTIVE::		.ASCIC	/Active/
BOO$GT_DEFAULT::	.ASCIC	/Default/
BOO$GT_FILE::		.BLKB	64

HELP_FILE:				; Help library file name
	.ASCID	/SYS$HELP:SYSGEN.HLB/
HELP_FLAG:	.long		hlp$m_prompt
HELP_DESC:	.ascid	//		; Filled in as pointer

VALID_PAR_FILE:				; Valid parameter file flag
	.LONG	0
SAVE_DOT:				; Save dot through USE filespec
	.LONG	0			
FULL_NAME_PTR::				; Full device name
	.LONG	0

; MSCP initialization routine default argument list

MSCP_ARG_LIST:
	.LONG	8		; Number of arguments
	.LONG	1		; Function code(load and start server)
	.LONG	32768		; Default buffer size
	.LONG	4		; Default number of receive credits for each host
	.LONG	15		; Default number of hosts supported
	.LONG	20		; Default time out
	.LONG	4		; Default priority
	.LONG	4096		; Default for minimum qualifier
	.LONG	16384		; Default for maximum qualifier
	.BLKL	3		; Space for new args
MSCP_ARG_LIST_SIZE = .-MSCP_ARG_LIST

BOO$GL_LOAD_ARGS::			; Argument list block loadable code init
	.BLKB	MSCP_ARG_LIST_SIZE	; routine


MSCP_NAME:	.ASCIC	/MSCP/	;MSCP server name

; AUTO ALL /LOG storage

CTRSTR_AUTOLOG:		.ascid	/ !AC!UW/
CTRSTR_AUTOLOG_UNIT:	.ascid	/,!UW/
Outlen_unit:		.long	0
Outlen:			.long	0
Boo$gt_save_devname:	.blkb	20
outbuf:			.ascid	//
outbuf_str:		.blkb	100

; Send operator message data

OPERGETJPI:					; $GETJPI item list
	.WORD		4				; Buffer length
	.WORD		JPI$_PID			; Process ID code
	.ADDRESS	OPERMSGPID			; Buffer address
	.LONG		0				; Don't return length
	.LONG		0				; List terminator

OPERMSGVEC:					; $PUTMSG message vector
	.WORD	3					; Argument count
	.WORD	^B1111					; Default message flags
OPERMSGID:
	.LONG	0					; Message ID
OPERMSGFAO:
	.WORD	1					; FAO argument count
	.WORD	0					; No new message flags
OPERMSGPID:						; PID of this process
	.LONG	0
OPERMSGNAM:						; File specification
	.ADDRESS	OPERNAMDESC

OPERNAMDESC:
	.LONG	0,0

OPERMSG:					; Message descriptor
	.LONG		0
	.ADDRESS	OPERMSGBUF

OPERMSGBUF:					; Message buffer
	.LONG	OPC$_RQ_RQST!<OPC$M_NM_CENTRL@8>	; Message type and target
	.LONG	0					; No reply message
OPERMSGTXT:						; Message text
	.BLKB	256	

	.IF	NDF,CONFIGSW			; SYSGEN-specific code
	.PAGE
	.SBTTL	BOO$USEFILE - Use parameter file
;++
; Functional description:
;	BOO$USEFILE reads the specified file in response to the USE
;	command and merges all of the values specified in that file into
;	the working copy of the parameter values.  This is accomplished
;	by looking up each value specified and merging the associated 
;	value.
;
; Calling sequence:
;	CALLG	arglist,BOO$USEFILE
;
; Input Parameters:
;	TPA$L_TOKENCNT(AP) - Length of file name string
;	TPA$L_TOKENPTR(AP) - Address fo file name string
; Output Parameters:
;	R0 - Completion status code
;
;--

.PSECT	PAGED_CODE	rd,nowrt,exe,long

.Entry	BOO$USEFILE, ^M<R2,R3,R4,R5,R6,R7,R8,R9>	; Entry mask


	BBSS	#EXE$V_WRITESYSPARAMS,-	; Use a file => write current needed
		G^EXE$GL_DYNAMIC_FLAGS,1$;
1$:
	MOVL	BOO$GL_DOT,L^SAVE_DOT	; Save dot
	MOVAB	TPA$L_TOKENCNT(AP),R7	; Set address of file name descriptor
	BSBW	BOO$FILOPEN		; Open specified file
	BLBS	R0,20$			; Continue if success
10$:	MOVZWL	#1,R0			; Force success
	RET				;
20$:	MOVAB	BOO$AB_PRMBUF,R6	; Set address of parameter buffer
	MOVL	#16,R9			; Set size of buffer
	BSBW	BOO$READFILE		; Read file content into parameter buffer
	BLBC	R0,10$			; Exit if error
	MOVAB	BOO$AB_PRMBUF,R8	; Init pointer to parameter buffer
	MOVC3	#32,(R8),EXE$GT_STARTUP	; Set startup command file name
	ADDL	#32,R8			;  and advance buffer pointer
	CLRL	VALID_PAR_FILE		; Initialize valid parameter file flag
30$:	TSTL	(R8)			; Check for end of list
	BEQL	DONE			; Branch if yes
	MOVZBL	(R8),TPA$L_TOKENCNT(AP)	; Set token count for search
	MOVAB	1(R8),TPA$L_TOKENPTR(AP); And address of string
	ADDL	#16,R8			; Advance to value
	MOVL	(R8)+,TPA$L_NUMBER(AP)	; Set number 
	CALLG	(AP),L^BOO$SEARCH	; Search for parameter
	BLBC	R0,30$			; Next parameter if not found
	MOVL	#1,VALID_PAR_FILE	; Indicate valid parameter file
	MOVL	TPA$L_PARAM(AP),R4	; Get a pointer to the parameter descripttor
	BBC	#PRM$V_ASCII,PRM$L_FLAGS(R4),40$; Branch if not an ascii parameter
	MOVAL	-(R8),TPA$L_TOKENPTR(AP); Get a pointer to the parameter value
	MOVZBL	PRM$B_SIZE(R4),R0	; Get parameter size in bits
	ASHL	#-3,R0,R0		; Set parameter size
	MOVZBL	R0,TPA$L_TOKENCNT(AP)	;
	ADDL2	#3,R0			; Round size up to the next longword
	BICL2	#3,R0			;
	ADDL2	R0,R8			; Advance past value
	CALLG	(AP),W^BOO$SETASCII	; Set the value of the parameter
	BRW	30$			; Continue with the next parameter
40$:	CALLG	(AP),L^BOO$SETVALUE	; Set value of parameter
	BRW	30$			; Continue with next parameter
DONE:	BSBW	BOO$FILCLOSE		; Close the file
	BLBS	VALID_PAR_FILE,10$	; If LBS, valid parameter file
	MOVL	#SYSG$_NOTPARAM,R0	; Set error
	BRB	20$			; Branch
10$:
;
; Set file name in BOO$GL_PARINUSE
;
	MOVAL	BOO$GT_FILE,R8		; Set address of String
	MOVL	R8,BOO$GL_PARINUSE	; Set address
	MOVZBL	BOO$GB_FILELEN,(R8)	; Set count
	MOVC3	(R8),@BOO$GL_FILEADDR,-
		1(R8)			; Move string

	MOVZWL	#SS$_NORMAL,R0		; Return success
20$:	MOVL	L^SAVE_DOT,BOO$GL_DOT	; Restore dot
	RET				;
	.ENDC				; End of SYSGEN-specific code
	.PAGE
	.SBTTL	BOO$USEACT - Use active parameters
;++
; Functional description:
;	This routine copies the parameter values from the running
;	system to the working copy of the parameter values.
; Calling sequence:
;
;	CALLS	#0,BOO$USEACT
;
; Input parameters:
;	None
; Output Parameters:
;	R0 - Completion status code
;--

.Entry	BOO$USEACT,^M<R2,R3,R4,R5>

	MOVC3	#EXE$C_SYSPARSZ,-	; Move parameters
		MMG$A_SYSPARAM,EXE$A_SYSPARAM
	MOVAL	BOO$GT_ACTIVE,-
		BOO$GL_PARINUSE		; Set parameter in use
	MOVL	#1,R0			; Return success
	RET
	.IF	NDF,CONFIGSW			; SYSGEN-specific code

	.SBTTL	BOO$WRTACT - Write parameters to system
;++
; Functional Description:
;	This routine writes the parameters in the working parameter
;	buffer to the system's parameter area.  Only dynamic
;	parameters are copied.
;
; Calling Sequence:
;	CALLS	#0,BOO$WRTACT
;
; Input Parameters:
;	None
;
; Output Parameters:
;	R0 - Completion status code
;--

.PSECT	NONPAGED_CODE	rd,nowrt,exe,long

.Entry 	BOO$WRTACT, ^M<>

	$CMKRNL_S	B^10$,(AP)	; Do it in kernel mode
	BLBC	R0,1$			; If LBC, error
	JSB	BOO$SENDOPER		; Notify operator of WRITE ACTIVE
		.LONG	SYSG$_WRITEACT
	BLBS	R0,5$			; If LBS, success
1$:	JSB	PUTERROR		; Report error
	MOVL	#1,R0			; Force success
5$:	RET

10$:	.WORD	^M<R2,R3,R4,R5>
	MOVAB	L^BOO$A_PRMBLK,R5	; Get base of parameter blocks
	DSBINT	#IPL$_SCHED		; Raise IPL to prevent being unscheduled
					; (Assumes pages are locked in W.S.)

	ASSUME	PRM$L_ADDR  EQ  0

20$:	MOVL	PRM$L_ADDR(R5),R3	; Get address of parameter
	BEQL	40$			; Reached the end
	BBC	#PRM$V_DYNAMIC,-	; Branch if this is not a 
		PRM$L_FLAGS(R5),30$	; dynamic parameter
	MOVZBL	PRM$B_POS(R5),R1	; Get position of parameter
	EXTZV	R1,PRM$B_SIZE(R5),(R3),R2  ; Extract parameter value
	MOVAB	L^EXE$A_SYSPARAM,R0	; Get address of working buffer
	SUBL	R0,R3			; Get parameter offset
	INSV	R2,R1,PRM$B_SIZE(R5),-	; Store in system
		L^MMG$A_SYSPARAM(R3)

30$:	ADDL	#PRM$C_LENGTH,R5	; Point to next paramter block
	BRB	20$			; Repeat

; Copy dynamic flags from default flags to R0

40$:	BICL3	#^C<PRM$M_DYNFLAGS>,-
		MMG$A_SYSPARAM+<EXE$GL_DEFFLAGS-EXE$A_SYSPARAM>,R0
	BICL	#PRM$M_DYNFLAGS,-	; Clear dynamic flags in real flags
		EXE$GL_FLAGS
	BISL	R0,EXE$GL_FLAGS		; Set dynamic flags in real flags

	ENBINT				; Lower IPL
	MOVL	#1,R0			; Set success
	RET

	.SBTTL	BOO$WRTCUR - Write Current Parameters
;++
; Functional Description:
;	This routine writes the parameters from the working parameter
;	buffer to the system parameter file on disk.  They will take effect the
;	next time the system is booted.
;
; Calling Sequence:
;	CALLS	#0,BOO$WRTCUR
;
; Input parameters:
;	None
;
; Output Parameters:
;	R0 - Completion status code
;--

.PSECT	PAGED_CODE	rd,nowrt,exe,long

.Entry	BOO$WRTCUR, ^M<R2,R3,R4,R5,R6,R7,R8,R9>

	BBCC	#EXE$V_WRITESYSPARAMS,-	; Don't do WRITE CURRENT again in startup
		G^EXE$GL_DYNAMIC_FLAGS,10$;
10$:	MOVAB	BOO$GT_SYSPARNAME,R0	; Get address of system .PAR file name
	MOVZBL	(R0)+,TPA$L_TOKENCNT(AP); Set up for call to BOO$WRTSYSPARFILE
	MOVL	R0,TPA$L_TOKENPTR(AP)	;
	CALLG	(AP),G^BOO$WRTSYSPARFILE; Call the routine to write out the file
	BLBC	R0,20$			; Branch if error
	BSBW	BOO$SENDOPER		; Notify operator of WRITE CURRENT
		.LONG	SYSG$_WRITECUR
	BLBS	R0,30$			; If LBS, success
20$:	BSBW	PUTERROR		; Report error
30$:	MOVL	#1,R0			; Return success
	RET


	.SBTTL	BOO$SENDOPER - Output facility error message to operator
;
; Functional Description:
;	BOO$SENDOPER outputs an error message to the operator.
;
; Calling Sequence:
;	BSBW	BOO$SENDOPER
;		.LONG	<msg-id>
;
BOO$SENDOPER::
	MOVL	@(SP),OPERMSGID			; Put message ID in vector
	ADDL2	#4,(SP)				; Advance return address
	$GETJPI_S	ITMLST=OPERGETJPI	; Get process ID
	BLBC	R0,10$				; If LBC, error
	MOVL	#3,OPERMSGVEC			; Assume WRITE ACTIVE
	MOVL	#1,OPERMSGFAO
	CLRL	OPERMSGNAM
	CMPL	#SYSG$_WRITECUR,OPERMSGID	; WRITE CURRENT ?
	BNEQ	5$				; If NEQ, no
	INCL	OPERMSGVEC			; Set up WRITE CURRENT
	INCL	OPERMSGFAO
	MOVAB	OPERNAMDESC,OPERMSGNAM
	MOVZBL	RIO_INPNAM+NAM$B_RSL,OPERNAMDESC; Build descriptor
	MOVL	RIO_INPNAM+NAM$L_RSA,OPERNAMDESC+4
5$:	$PUTMSG_S -				; Get and format message
			MSGVEC=OPERMSGVEC, -
			ACTRTN=666$
	BLBC	R0,10$				; If LBC, error
	$SNDOPR_S	MSGBUF=OPERMSG
	BLBS	R0,20$				; If LBS, success
10$:	BSBW	PUTERROR			; Report error
	MOVL	#1,R0				; Force success
20$:
	RSB
666$:
	.WORD	^M<R2,R3,R4,R5>
	MOVQ	@4(AP),R0		; Get string descriptor
	ADDL3	#OPC$L_MS_TEXT,R0,OPERMSG; Store total operator message size
	MOVC3	R0,(R1),OPERMSGTXT	; Copy text to operator message buffer
	CLRL	R0			; Prevent message output to SYS$OUTPUT
	RET
	
	.ENDC				; End of SYSGEN-specific code
	.PAGE
	.SBTTL	BOO$CONFIGALL - Auto-configure all adapters
;++
; Functional Description:
;	BOO$CONFIGALL is called to implement the "AUTOCONFIGURE ALL"
;	command. All standard devices supported by VAX/VMS will be 
;	located and connected for use with any necessary drivers being
;	loaded.
;
; Calling Sequence:
;	CALLG	ARGLIST,BOO$CONFIGALL
;
; Output parameters:
;	R0 - Completion status code
;--

.PSECT	NONPAGED_CODE	rd,nowrt,exe,long

.Entry	BOO$CONFIGALL, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Entry mask

	BBC	#EXE$V_NOAUTOCNF,EXE$GL_DEFFLAGS,5$; do we allow auto configure
	MOVL	#SYSG$_NOAUTOCNF,R0	;Give them a no autoconfigure error
	RET				; and return

5$:	BSBW	BOO$LOCK_GEN		; Lock SYSGEN database
	BLBS	R0,7$			; If no error, continue
	JSB	PUTERROR
	RET

7$:	BSBW	IOC$AUTORESET		; Reset controller characters for device
					; names
	CLRL	R11			; Indicate no ADP address yet
10$:	PUSHL	R11			; Set as argument
	CALLS	#1,NEXTADP		; Get next ADP address
	BLBC	R0,CONFIG_EXIT		; Branch if error (NOPRIV)
	MOVL	R1,R11			; Check return status
	BGEQ	20$			; Branch if done
	PUSHL	R11			; Set as ADP argument
	CALLS	#1,W^CONFIGADP		; Configure the entire adapter
	BLBS	R0,10$			; Continue if no error
	JSB	PUTERROR		; Report error
20$:	MOVL	#1,R0			; Set success

	BBC	#BOOCMD$V_AUTOLOG,L^BOO$GL_CMDOPT,CONFIG_EXIT ; Branch if not /LOG
	CLRL	BOO$GT_SAVE_DEVNAME	; Clear name
	BSBW	AUTOLOG			; Output last line if there is one

CONFIG_EXIT:
	PUSHL	R0			; Save status
	BSBW	BOO$UNLOCK_GEN		; Unlock SYSGEN database
	BLBS	R0,35$			; If no error, continue
	JSB	PUTERROR		; Give error message
35$:	POPL	R0			; Restore status
	RET				;

.Entry	BOO$CONFIGONE, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Entry mask

	BSBW	BOO$LOCK_GEN		; Lock SYSGEN database
	BLBS	R0,5$			; If no error, continue
	JSB	PUTERROR		; Give error message
	RET				;

5$:	BSBW	IOC$AUTORESET		; Reset controller characters for device
					; device names
	PUSHL	TPA$L_NUMBER(AP)	; Set TR number of adapter
	CALLS	#1,B^LOCADP		; Locate adapter control block
	BLBC	R0,CONFIG_EXIT		; Branch if error (NOPRIV)
	PUSHL	R1			; Set as argument to CONFIGADP
	BEQL	10$			; Done if no adapter
	CALLS	#1,B^CONFIGADP		; Configure adapter
	BLBS	R0,10$			; Continue if no error
	JSB	PUTERROR		; Give error status
10$:	MOVL	#1,R0			; Set success for parse
	BBC	#BOOCMD$V_AUTOLOG,L^BOO$GL_CMDOPT,CONFIG_EXIT ; Branch if not /LOG
	CLRL	BOO$GT_SAVE_DEVNAME	; Clear name
	BSBW	AUTOLOG			; Output last line if there is one
20$:	BRB	CONFIG_EXIT		; 

NEXTADP:				; Return next ADP address in R0
	.WORD	0			; Null entry mask
	$CMEXEC_S	B^10$,(AP)	; Call real routine in exec mode
	RET				;

10$:	.WORD	0			; Null entry mask
	MOVL	4(AP),R1		; Get current address
	BEQL	20$			; 0 => start of list
	MOVL	ADP$L_LINK(R1),R1	; Flink onward
	BRB	30$
20$:	MOVL	IOC$GL_ADPLIST,R1	; Return head of list
30$:	MOVL	#1,R0
	RET				;

LOCADP:					; Return address of ADP for TR number
	.WORD	0			;
	$CMEXEC_S	B^5$,(AP)	; Call routine in exec mode
	RET				;

5$:	.WORD	0			; Null entry mask
	MOVAB	IOC$GL_ADPLIST-ADP$L_LINK,R1 ; Set starting address
10$:	MOVL	ADP$L_LINK(R1),R1	; Flink onward
	BEQL	20$			; Done if at end
	CMPW	4(AP),ADP$W_TR(R1)	; Is this the specified TR?
	BNEQ	10$			; No, try another
20$:	MOVL	#1,R0
	RET				;

.Entry	CONFIGADP, ^M<R2,R3,R4,R5,R6,R7>; Entry mask 

	CLRL	BOO$GL_RETSAVE		; Zap return address for initial call
	BBC	#BOOCMD$V_SELECT,L^BOO$GL_CMDOPT,10$ ; Mutually exclusive - test
	BBC	#BOOCMD$V_EXCLUDE,L^BOO$GL_CMDOPT,10$ ; to make sure one bit clear
	MOVL	#SYSG$_CONFQUAL,R0 	; Conflicting qualifiers
	RET

10$:	CALLG	(AP),W^50$		; Call configure one device
	BLBS	R0,20$			; Branch if not done with this adapter
	CMPW	#SS$_NOPRIV,R0		; Was there a privilege error
	BEQL	15$			; Yes, branch
	MOVL	#1,R0			; Set success
15$:	RET				; and return

20$:	MOVAB	BOO$AL_ACF,R5		; Set address of arguments describing device

	CLRW	ACF$W_MAXUNITS(R5)	; Always use driver specified max units
	MOVL	L^BOO$GL_SELECT,R6	; Get pointer to select list
	BEQL	35$			; Branch if null
	BSBW	SELECT			; Check select/exclude string
	BLBC	R0,10$			; Branch if device is not to be configured

35$:	BBS	#ACF$V_NOLOAD_DB,ACF$B_AFLAG(R5),38$ ; Branch if not loading database
	BBC	#BOOCMD$V_AUTOLOG,L^BOO$GL_CMDOPT,38$ ; Branch if not logging
	BSBW	AUTOLOG			; Branch to output log
	BLBS	R0,38$			; Branch if no error
	BSBW	PUTERROR		; Give error message

38$:	CALLG	(R5),W^IOGEN$LOADER	; Load database and driver if necessary
	BLBS	R0,10$			; Branch if no error
	BSBW	PUTERROR		; Give error message
	BRW	10$			; continue loop

50$:	.WORD	0			; 
	$CMKRNL_S	B^55$,(AP)	; Call auto configure in kernel mode
	RET				;

55$:	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	;
	MOVL	BOO$GL_RETSAVE,R0	; Get saved return address
	BNEQ	60$			; Branch if one present
	MOVAB	IOC$AUTOCONFIG,R0	; Else use main entry point
60$:	PUSHL	R0			; Stack call back address
	MOVL	4(AP),R8		; Get address of ADP
	MOVL	ADP$L_CSR(R8),R6	; Get Configuration register address
	MOVAB	BOO$AL_ACF,R7		; Address of configuration control block
	SETIPL	#31			; Disable interrupts
	JSB	@(SP)+			; Call Auto configurtation code
	SETIPL	#0			; Enable interrupts
	MOVL	(SP)+,BOO$GL_RETSAVE	; Save return
	BLBS	R0,70$			; Continue if another device
	CLRL	BOO$GL_RETSAVE		; Else clear return 

70$:	BBC	#ACF$V_NOLOAD_DB,ACF$B_AFLAG(R7),80$ ; Branch if loading database
	MOVZWL	ACF$W_CUNIT(R7),-(SP)	; Get unit number
	PUSHL	ACF$L_DEVNAME(R7)	; Get device name
	BSBW	SGN$GET_DEVICE_LOCK_IODB; Get device database
	ADDL2	#8,SP			; Clear stack
80$:	RET				; And return
90$:	MOVZWL	#1,R0			; Set success status
	RET				; and return
;
; SELECT - decide whether current device name is one of those either
; 	   specified in /SELECT or /EXCLUDE
;
; Returns: R0 = 1   ==> configure device
;	   R0 = 0   ==> don't configure device
;

SELECT:
10$:	MOVL	ACF$L_DEVNAME(R5),R7	; Get pointer to device name
	MOVZBL	(R6)+,R4		; Get length of select entry
	BEQL	20$			; End of list, no match
	CMPB	(R7)+,R4		; Compare with device entry
	BLSS	15$			; Branch if select longer than device
	CMPC3	R4,(R6),(R7)		; Do we have a match?
	BEQL	40$			; Yes, check SELECT or EXCLUDE
15$:	ADDL	R4,R6			; Advance to next entry in select list
	BRB	10$			; And try again

20$:	CLRL	R0			; Assume don't configure
	BBC	#BOOCMD$V_EXCLUDE,BOO$GL_CMDOPT,30$ ; Branch if SELECT
	MOVL	#1,R0			; EXCLUDE - configure device
30$:	RSB

40$:	CLRL	R0			; Assume don't configure
	BBS	#BOOCMD$V_EXCLUDE,BOO$GL_CMDOPT,50$ ; Branch if EXCLUDE
	MOVL	#1,R0			; SELECT - configure device
50$:	RSB
.PAGE
.SBTTL	AUTOLOG - AUTO ALL /LOG formating

AUTOLOG::
	MOVAB	BOO$AL_ACF,R5		; Address of configuration control block
	MOVL	ACF$L_DEVNAME(R5),R6	; Get address of current device
	MOVZBL	(R6)+,R7		; Get count and addr.
	CMPC3	R7,(R6),BOO$GT_SAVE_DEVNAME ; Compare to previous string
	BNEQ	50$			; Branch if new device

	$FAO_S	CTRSTR=CTRSTR_AUTOLOG_UNIT ,- ; Format Unit Number
		OUTBUF=OUTBUF,-
		OUTLEN=OUTLEN_UNIT ,-
		P1=ACF$W_CUNIT(R5)
	BLBS	R0,40$			; Branch if OK
	BRW	100$			; Branch if error

40$:	ADDL2	W^OUTLEN_UNIT,W^OUTLEN	; Add to total length
	ADDL2	W^OUTLEN_UNIT,W^OUTBUF+4; Add to descriptor
	SUBW2	W^OUTLEN_UNIT,W^OUTBUF	; Subtract from length
	BRB	100$			; Return with success

50$:	TSTL	W^OUTLEN		; Is this a first call to this routine?
	BEQL	70$			; Branch if yes

	MOVAL	W^OUTBUF_STR,W^OUTBUF+4	; reset descriptor
	MOVW	W^OUTLEN,W^RIO$GW_OUTLEN ; Length of string
	MOVC3	W^RIO$GW_OUTLEN,-
		W^OUTBUF_STR,-
		W^RIO$AB_BUFFER		; Move text into global buffer

	JSB	RIO$OUTPUT_LINE
	BLBC	R0,100$			; Branch on error
	
70$:	MOVW	#100,W^OUTBUF		; Set full buffer length
	MOVC3	R7,(R6),BOO$GT_SAVE_DEVNAME ; Save new devname
	MOVAB	BOO$AL_ACF,R5		; Reset R5
	$FAO_S	CTRSTR=CTRSTR_AUTOLOG,-	; Format device name
		OUTBUF=OUTBUF,-
		OUTLEN=OUTLEN,-
		P1=ACF$L_DEVNAME(R5),-
		P2=ACF$W_CUNIT(R5)
	ADDL2	W^OUTLEN,W^OUTBUF+4	; Add to descriptor
	SUBW2	W^OUTLEN,W^OUTBUF	; Subtract from length
					; Return with FAO status
100$:	RSB

.PAGE
.SBTTL	SGN$GET_DEVICE - Locate device database

;
; Inputs: 
;	4(SP) - Address of Device name in ascic format
;       8(SP) - Unit number
;
; Outputs:
;	(Any of these are 0 if the data block doesn't exist)
;	ACF$GL_DDB - Address of DDB
;	ACF$GL_UCB - Address of UCB
;	ACF$GL_IDB - Address of IDB
;	ACF$GL_CRB - Address of CRB
;	ACF$GL_SB  - Address of SB
;	ACF$GL_LASTDDB - If ACF$GL_DDB is non-zero, then equal to that,
;		     otherwise, last DDB in DEVLIST
;	R0 = 0 - error
;	   = 1 - success
;
; Must be called at IPL=0 and KERNEL mode
;
	.ENABL	LSB

SGN$GET_DEVICE::			; Entry with IODB MUTEX & raised IPL

	PUSHR	#^M<R2,R3,R4,R5,R6>	; ADDS 20 to offset to input

	MOVL	G^CTL$GL_PCB,R4		; PICK UP PCB POINTER
	BSBB	10$			; Call real routine

	POPR	#^M<R2,R3,R4,R5,R6>	; restore regs
	RSB				; Return

SGN$GET_DEVICE_LOCK_IODB:		; Entry without IODB MUTEX and IPL 0

	PUSHR	#^M<R2,R3,R4,R5,R6>	; ADDS 20 to offset to input

	MOVL	G^CTL$GL_PCB,R4		;PICK UP PCB POINTER
	JSB	G^SCH$IOLOCKR		;GET THE IODB MUTEX FOR READ & RAISE IPL
	BSBB	10$			;
	PUSHL	R0			;SAVE RETURN STATUS
	MOVL	G^CTL$GL_PCB,R4		;PICK UP PCB POINTER
	JSB	G^SCH$IOUNLOCK		;RELEASE THE IODB MUTEX
	SETIPL	#0			;LOWER IPL

	POPL	R0			;RESTORE RETURN STATUS FROM LOCAL ROUTINE
	POPR	#^M<R2,R3,R4,R5,R6>
	RSB

10$:	CLRL	W^ACF$GL_DDB		;INIT TO ZERO
	CLRL	W^ACF$GL_UCB		;INIT TO ZERO
	CLRL	W^ACF$GL_IDB		;INIT TO ZERO
	CLRL	W^ACF$GL_CRB		;INIT TO ZERO
	CLRL	W^ACF$GL_SB		;INIT TO ZERO

	SAVIPL	-(SP)			;SAVE THE CURRENT IPL
	MOVL	32(SP),R6		;GET ADDR OF DEVICE NAME
	MOVZBL	(R6)+,R5		;GET SIZE OF DEVICE NAME
	MOVQ	R5,-(SP)		;FORM DESCRIPTOR
	MOVL	SP,R1			;ADDRESS OF DESCRIPTOR
	JSB	G^IOC$SEARCHALL		;SEARCH FOR DEVICE
	CLRQ	(SP)+			;GET RID OF TRASH
	SETIPL	(SP)+			;RESTORE OLD IPL
	MOVL	R3,W^ACF$GL_SB		;STUFF THE SYSTEM BLOCK
	BNEQ	20$			;NO ERROR, CONTINUE
	CLRL	R0			;INDICATE ERROR
	BRB	70$			;EXIT

20$:	BLBS	R0,25$			;SUCCES - FOUND DEVICE
	CMPW	R0,#SS$_NOSUCHDEV	;CHECK IF ERROR WAS "UNIT NOT FOUND"
	BNEQ	60$			;IF NOT, PUNT
	TSTL	R1			;SEE IF WE GOT BACK A UCB ADDRESS
	BNEQ	60$			;IF NON-ZERO, IS LISTHEAD - NO DDB FOUND
25$:	MOVL	R2,L^ACF$GL_DDB		;ADDRESS OF DDB
	MOVL	DDB$L_UCB(R2),R4	;GET ADDRESS OF FIRST UCB
	BEQL	60$			;IF NO UCB, EXIT WITH OTHER FIELDS ZERO
	MOVL	UCB$L_CRB(R4),R1	;GET ADDR OF CRB
	MOVL	R1,L^ACF$GL_CRB		;SAVE
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),W^ACF$GL_IDB ;GET ADDR OF IDB

30$:	CMPW	32(SP),UCB$W_UNIT(R4)	;IS UCB ALREADY LOADED?
	BEQL	50$			;BRANCH IF IT IS
40$:	MOVL	UCB$L_LINK(R4),R4	;GET ADDR OF NEXT UCB
	BNEQ	30$			;BR IF THERE IS ONE
	BRB	60$			;EXIT WITH UCB = 0

50$:	MOVL	R4,W^ACF$GL_UCB
60$:	MOVL	R2,ACF$GL_LASTDDB	;LAST DDB IN LIST AS SEARCHED
	MOVAL	G^SCS$GA_LOCALSB,R0	;GET ADDRESS OF LOCAL SYSTEM BLOCK
	CMPL	R3,R0			;IS THIS SB LOCAL?
	BEQL	65$			;YES, LEAVE NOW
	MOVQ	SB$B_SYSTEMID(R3),-
		L^BOO$GQ_CONSYSID	;NO, SET IN THE SYSTEM ID

65$:	MOVL	#1,R0			;SUCCESS
70$:	RSB

	.DSABL	LSB

	.PAGE
	.SBTTL	Reset routines BOO$RESETLIST and BOO$CONRESET and BOO$MSCP_RESET
;
; BOO$CONRESET - Reset values for connect command
;

.PSECT	PAGED_CODE	rd,nowrt,exe,long

.Entry	BOO$CONRESET, ^M<>			; Null entry mask

	MOVAB	L^BOO$AB_PRMBUF,BOO$GL_NEXTSTR	; Reset for string allocation
	MNEGL	#1,BOO$GL_CONCREG	; Null control register
	MNEGL	#1,BOO$GL_CONAUNIT	; Null adapter unit
	MNEGL	#1,BOO$GL_CONVECT	; Null vector
	MOVL	#1,BOO$GL_CONNUMV	; Default number of vectors
	MNEGL	#2,BOO$GL_CONADP	; Invalidate adapter TR value
	CLRL	BOO$GL_CONDEV		; Clear device name pointer
	CLRL	BOO$GL_CONDRV		; and driver name pointer
	CLRL	BOO$GL_CONUNITS		; and maximum units
	CLRQ	BOO$GQ_CONSYSID		; and system id
	CLRL	BOO$GL_CONFLAGS		; and flags
	MOVL	#1,L^BOO$GL_CONNUMU	; Set number of units to 1
	CLRL	BOO$GL_COMBO_VECTOR_OFFSET; Set vector offset from combo vectors to 0
	CLRL	BOO$GL_COMBO_CSR_OFFSET	; Set CSR offset from combo CSR to 0
	RET				; Return
;
;	BOO$RESETLIST - Reset select list values
;
.Entry	BOO$RESETLIST, ^M<>		; Null entry mask

	CLRL	BOO$GL_SELECT		; Zap select list pointer
	MOVAB	BOO$AB_PRMBUF,BOO$GL_NEXTSTR ; Set next string address
	CLRL	BOO$GT_SAVE_DEVNAME	; Clear autolog string
	CLRL	OUTLEN			; Clear autolog output size
	MOVAL	OUTBUF_STR,OUTBUF+4	; Set address in descriptor of block
	CLRB	BOO$AL_ACF+ACF$B_AFLAG	; Clear ACF flags
	MOVL	#1,L^BOO$GL_CONNUMU	; Set number of units to 1
	RET				; and return

;
; BOO$MSCP_RESET - Reset the MSCP server initialization argument list
;
.Entry	BOO$MSCP_RESET, ^M<R2,R3,R4,R5>	; Entry mask

	CALLS	#0,BOO$CONRESET		; Reset the connect command globals
	MOVZWL	#SS$_DEVOFFLINE,R0	; Assume error
	TSTL	G^SCS$GL_CDL		; SCS loaded?
	BEQL	10$			; If eql no, error
	MOVZWL	#SS$_DEVACTIVE,R0	; Assume error
	INSV	#2,#0,#3,R0		; Set E class error status
	TSTL	G^SCS$GL_MSCP		; If neq already loaded
	BNEQ	10$			; Exit with error
	MOVAL	MSCP_NAME,G^BOO$GL_CONDRV; Set pointer to MSCP server name
	MOVC3	#MSCP_ARG_LIST_SIZE,-	; Set up default argument list for
		MSCP_ARG_LIST,G^BOO$GL_LOAD_ARGS; MSCP server init routine
	MOVL	#1,R0			; Set success
10$:	RET				; and return

;
; BOO$MSCP_ARG - Load MSCP arguments
;
.Entry	BOO$MSCP_ARG, ^M<>		; Entry mask

	MOVL	TPA$L_PARAM(AP),R0	; Get longword offset
	MOVL	TPA$L_NUMBER(AP),-	; Load argument value
		G^BOO$GL_LOAD_ARGS[R0]	;
	MOVL	#1,R0			; Set success
	RET				; and return

;
;
; BOO$MAKLIST - Make a select list entry
;
.Entry	BOO$MAKLIST, ^M<R2,R3,R4,R5,R6>	; Entry mask

	MOVL	L^BOO$GL_NEXTSTR,R6	; Get pointer to next available string space
	TSTL	L^BOO$GL_SELECT		; Is selection pointer already set
	BNEQ	10$			; Yes, continue to add entry
	MOVL	R6,L^BOO$GL_SELECT	; Else set pointer to first select entry
10$:	MOVL	TPA$L_TOKENCNT(AP),R0	; Get string length
	MOVB	R0,(R6)+		; Set count for string
	MOVC3	R0,@TPA$L_TOKENPTR(AP),(R6) ; Copy string body
	CLRB	(R3)			; Mark end of list
	MOVL	R3,L^BOO$GL_NEXTSTR	; Save next string address
	MOVL	#1,R0			; Set success status
	RET				;
	.PAGE
	.SBTTL	BOO$CONADP - Set connect adapter number

.Entry	BOO$CONADP, ^M<>		;
	MOVL	TPA$L_NUMBER(AP),L^BOO$GL_CONADP ; Set adapter number
	RET				; and return

.Entry	BOO$CONNLADP ^M<>		; Connect with null adapter
	MNEGL	#1,L^BOO$GL_CONADP	; Clear adapter number
	RET				; and return

.Entry	BOO$CONVECOFFSET, ^M<>		; Offset from start of combo vectors
	MOVL	TPA$L_NUMBER(AP),-	; Set offset value
		L^BOO$GL_COMBO_VECTOR_OFFSET
	RET				; and return

.Entry	BOO$CONCSROFFSET, ^M<>		; Offset from start of combo CSRs
	MOVL	TPA$L_NUMBER(AP),-	; Set offset value
		L^BOO$GL_COMBO_CSR_OFFSET
	RET				; and return

.Entry	BOO$CONCREG, ^M<>		; Control register address
	EXTZV	#0,#13,TPA$L_NUMBER(AP),L^BOO$GL_CONCREG; Set control register 
	RET				; and return

.Entry	BOO$CONCVEC, ^M<>		; Set controller vector 
	BICL3	#^XFFFFFE03,TPA$L_NUMBER(AP),L^BOO$GL_CONVECT ; Set vector offset
	RET				; and return

.Entry	BOO$CONCNUM, ^M<>		; Number of vectors
	MOVL	TPA$L_NUMBER(AP),L^BOO$GL_CONNUMV ; Set number of vectors
	RET				; and return

.Entry	BOO$CONAUNIT, ^M<>		; Adapter unit number
	MOVL	TPA$L_NUMBER(AP),L^BOO$GL_CONAUNIT; Set adapter unit number
	RET				; and return

.Entry	BOO$CONDRVNAM, ^M<R2,R3,R4,R5,R6> ; Entry mask (R2-R6)

	MOVL	L^BOO$GL_NEXTSTR,R6	; Address of next string storage
	MOVL	R6,BOO$GL_CONDRV	; Save pointer to driver name
	MOVB	TPA$L_TOKENCNT(AP),(R6)+	; Set count for string
	ADDL3	TPA$L_TOKENCNT(AP),R6,BOO$GL_NEXTSTR ; Mark string allocated
	MOVC3	TPA$L_TOKENCNT(AP),@TPA$L_TOKENPTR(AP),(R6)	; Copy string
	MOVL	#1,R0			; and return success
	RET				;

.Entry	BOO$DEVNAME, ^M<R2,R3,R4,R5,R6,R7> ; Device name/unit

	MOVL	BOO$GL_NEXTSTR,R6	; Get pointer to next available string
	MOVL	TPA$L_TOKENPTR(AP),R4	; Get pointer to string
	MOVL	TPA$L_TOKENCNT(AP),R3	; And number of characters
	CLRL	FULL_NAME_PTR		; Initialize full device name
	MOVAB	(R6)+,R7		; Save pointer
	LOCC	#^A/$/,R3,(R4)		; Find any possible "$"
	BEQL	8$			; None, just continue
	MOVL	R7,FULL_NAME_PTR	; Store pointer
	SUBL3	R0,R3,R5		; Number of characters in node
	ADDB3	#1,R5,(R7)		; Set in size (incl "$")
	PUSHR	#^M<R0,R1>		; Save registers
	MOVC3	R3,(R4),(R6)		; Copy full string
	MOVL	R3,R6			; Save ending address
	POPR	#^M<R0,R1>		; Restore registers
	SUBL3	#1,R0,R3		; Number of characters left
	ADDL3	#1,R1,R4		; Pointer to string
8$:	MOVAB	(R6)+,R5		; Save pointer to count byte
	CLRB	(R5)			; Initialize count to zero
	CLRL	R2			; Initialize unit accumulator
10$:	MOVZBL	(R4)+,R0		; Get a character from device name
	CMPB	R0,#^A/0/		; And check for a digit
	BLSSU	20$			; Branch if not
	CMPB	R0,#^A/9/		; Final check for digit
	BLEQU	40$			; Yes it is
20$:	MOVB	R0,(R6)+		; Part of device name
	INCB	(R5)			; Increase count
	INCB	(R7)			; Including nodename
	SOBGTR	R3,10$			; Continue
	BRB	50$			;
30$:	MOVZBL	(R4)+,R0		; Get another digit
40$:	SUBL	#^A/0/,R0		; Get value
	MULL	#10,R2			; Scale accumulator before adding digit
	BLSS	60$			; Error
	CMPL	#9,R0			; Check for numeric
	BLSS	60$			; Error if not
	ADDL	R0,R2			; And add new digit
	SOBGTR	R3,30$			; Continue for entire unit number
50$:	MOVL	R6,BOO$GL_NEXTSTR	; Save updated string pointer
	MOVL	R2,BOO$GL_CONCUNIT	; Set unit number
	MOVL	R2,BOO$GL_CONAUNIT	; Assume same for adapter unit
	MOVL	R5,BOO$GL_CONDEV	; Save device name pointer
	TSTB	(R5)			; Must not be null device name
	BEQL	60$			; Error if so
	MOVL	#1,R0			; Return success
	RET				; and return
60$:	CLRL	R0			; Return error status
	RET				;

.Entry	BOO$CONUNITS, ^M<>		; Maximun units to be connected
	MOVL	TPA$L_NUMBER(AP),L^BOO$GL_CONUNITS ; Set maximum units
	RET				; and return

.Entry	BOO$CONSYSID_LOW, ^M<>		; System ID
	MOVL	TPA$L_NUMBER(AP), -
		L^BOO$GQ_CONSYSID 	; Set System ID (low longword)
	RET				; and return

.Entry	BOO$CONSYSID_HIGH, ^M<>		; System ID
	MOVL	TPA$L_NUMBER(AP), -
		L^BOO$GQ_CONSYSID+4 	; Set System ID (high longword)
	RET				; and return

.Entry	BOO$CONSOLE, ^M<>		; Connect console block stor. device

	MNEGL	#1,L^BOO$GL_CONADP	; No adapter
	MOVL	#1,L^BOO$GL_CONAUNIT	; Set adapter unit = 1 (not used)
	MOVL	#1,L^BOO$GL_CONCUNIT	; Set unit = 1
	MOVAB	L^CONSNAME,L^BOO$GL_CONDEV  ; Set device name pointer
	MOVL	#2,L^BOO$GL_CONNUMV	; Set 2 vectors
	CLRL	L^BOO$GL_CONCREG	; No control register
	MOVL	#1,L^BOO$GL_CONNUMU	; Set number of units to 1
	MOVL	#2,L^BOO$GL_CONUNITS	; Set max units to 2 (OPA0 is 1st unit)
	JSB	IOGEN$CONSOLE		; Do cpu dependent stuff
	MOVL	#1,R0
	RET
	.PAGE
	.SBTTL	BOO$CONNECT - Connnect specified device and load driver
;
; BOO$CONNECT - Allows a single device to be introduced, appropriate data
;		structures allocated and initialized, the driver loaded if 
;		required and the controller and device initialized.
;
.Entry	BOO$CONNECT, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	;

	BSBW	BOO$LOCK_GEN		; Lock SYSGEN database
	BLBC	R0,70$			; If error, exit

;
; Value of BOO$GL_CONADP
;
;	0 or greater	=> /ADADPTER=n specified
;	-1		=> /NOADAPTER specified
;	-2		=> not specified
;

5$:	TSTL	L^BOO$GL_CONADP		; Has an adapter been specified?
	BGEQ	20$			; If so, branch
	CMPL	#-1,L^BOO$GL_CONADP	; Null adapter?
	BEQL	10$			; Branch if yes
	CMPL	#-2,L^BOO$GL_CONADP	; None specified in CONNECT?
	BEQL	7$			; Figure it out from the database
	MOVL	#SYSG$_NOADAPTER,R0	; Set no adapter specified error
	BRB	60$			; exit

7$:	$CMKRNL_S W^CONN_ADAP		; Get adapter number from I/O database
	BLBC	R0,60$			; Exit with error
	BRB	5$			; Dispatch now on adapter type

10$:	$CMKRNL_S	W^CONNLADP	; Change mode to see data base
	BRB	30$			; Continue

20$:	$CMKRNL_S	W^CONNECT	; Change mode to see data base
30$:	BLBC	R0,40$			; Error occured
	CALLG	L^BOO$AL_ACF,IOGEN$LOADER ; Load database and driver
	BLBS	R0,50$			; Branch if success
40$:	BSBW	PUTERROR		; Give error message
50$:	MOVL	#1,R0			; Set success for parser
60$:	PUSHL	R0			; Save error status
	BSBW	BOO$UNLOCK_GEN		; Unlock SYSGEN database
	BLBS	R0,65$			; If no error, continue
	BSBW	PUTERROR		; Give error message
65$:	POPL	R0			; Restore status
	RET				;
70$:	BSBW	PUTERROR		; Give error message
	RET				;
;
; Local routine to get adapter number from I/O database
; Must be called by a CMKRNL since SGN$GET_DEVICE must be called
; in Kernel mode.
;
.Entry	CONN_ADAP, ^M<>

	MOVZWL	L^BOO$GL_CONCUNIT,-(SP)	; Unit number
	PUSHL	L^BOO$GL_CONDEV		; Device name
	JSB	SGN$GET_DEVICE_LOCK_IODB; Get device data base addresses
	ADDL2	#8,SP			; Pop off input parameters

	MOVL	L^ACF$GL_IDB,R0		; Address of IDB
	BNEQ	5$			; Error if zero
	MOVL	#SYSG$_NOADAPTER,R0	; Set no adapter specified error
	BRB	20$			; Branch to exit
	
5$:	MNEGL	#1,L^BOO$GL_CONADP 	; Assume null adapter
	MOVL	IDB$L_ADP(R0),R0	; Address of ADP block
	BEQL	10$			; Null adapter if zero
	MOVZWL	ADP$W_TR(R0),L^BOO$GL_CONADP ;Set adapter number

10$:	MOVL	#1,R0			; Set success
20$:	RET				; Return

.PAGE
.ENABL	LSB
; Connect with null adapter

.Entry	CONNLADP, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	L^FULL_NAME_PTR,R0	; Try full device name
	BNEQ	5$			; Good, continue
	MOVL	L^BOO$GL_CONDEV,R0	; Use normal name
5$:	MOVAB	L^BOO$AL_ACF,R10	; Address ACF
	CLRL	ACF$L_ADAPTER(R10)	; Set no adapter
	CLRL	ACF$L_CONFIGREG(R10)	; Set address of config reg
	CLRW	ACF$W_AVECTOR(R10)	; Set SCB offset for adapter
	BBC	#ACF$V_CRBBLT,-		; Br. if CRB built flag is clear
		BOO$GL_CONFLAGS,17$
	MOVL	BOO$GL_CONCRB,ACF$L_ADAPTER(R10)  ; Store CRB address
	BRB	17$			; Join common code

.Entry	CONNECT, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	;

	MOVAB	G^IOC$GL_ADPLIST-ADP$L_LINK,R11	; Get address of adapter list
10$:	MOVL	ADP$L_LINK(R11),R11	; Flink onward through adapter list
	BNEQ	15$			; Continue if another adapter
	MOVL	#SYSG$_INVADAP,R0	; Set invalid adapter error
	RET				; Return

15$:	CMPW	ADP$W_TR(R11),L^BOO$GL_CONADP	; Is this the specified TR?
	BNEQ	10$			; No, try another
	MOVAB	L^BOO$AL_ACF,R10	; Get address of ACF
	MOVL	R11,ACF$L_ADAPTER(R10)	; Set address of ADP
	MOVL	ADP$L_CSR(R11),ACF$L_CONFIGREG(R10)	; Set address of config reg
	SUBL3	G^EXE$GL_SCB, -		; Calculate offset into SCB of
		ADP$L_AVECTOR(R11),R0	; adapter's interrupt vectors.
	MOVW	R0,ACF$W_AVECTOR(R10)	; Store offset in ACF.
	MOVL	L^BOO$GL_CONDEV,R0	; Device name

17$:
	MOVL	BOO$GL_CONDEV,ACF$L_DEVNAME(R10); Set pointer to device name

; Now try to get driver name from DDB if it exists and load BOO$GQ_CONSYSID
; if HSC device.

	MOVZWL	L^BOO$GL_CONCUNIT,-(SP)	; Unit number
	PUSHL	R0			; Device name
	JSB	SGN$GET_DEVICE_LOCK_IODB; Get device data base addresses
	ADDL2	#8,SP			; Pop off input parameters
	BLBS	R0,20$			; All okay
	MOVL	#SYSG$_NODEV,R0		; Set error code - "Device not known"
	RET				; Leave

20$:	BBSS	#ACF$V_GETDONE,-
		L^BOO$GL_CONFLAGS,21$	; Notify LOADER that GET was done

21$:	MOVL	BOO$GL_CONDRV,ACF$L_DRVNAME(R10); And driver name
	BGTR	30$			; Branch if driver specified
	MOVL	ACF$GL_DDB,R1		; DDB address
	BEQL	25$			; Branch if none
	MOVAL	DDB$T_DRVNAME(R1),ACF$L_DRVNAME(R10) ; Address from DDB
	BRB	30$			; Branch around name hackery

25$:	MOVL	L^BOO$GL_NEXTSTR,R6	; Get address of next free space
	MOVL	R6,ACF$L_DRVNAME(R10)	; Set as driver name address
	MOVB	#8,(R6)+		; Set count for string
	MOVQ	#^A/  DRIVER/,(R6)	; Set driver suffix
	MOVL	ACF$L_DEVNAME(R10),R1	; Pointer to device name
	MOVW	1(R1),(R6)		; Form default driver name

30$:	MOVB	BOO$GL_CONAUNIT,ACF$B_AUNIT(R10); Set adapter unit
	MOVB	L^BOO$GL_CONNUMU,ACF$B_NUMUNIT(R10)
					; Store number of units to configure
	MOVB	BOO$GL_CONFLAGS,ACF$B_AFLAG(R10)  ; Store flags
	ADDW3	BOO$GL_CONVECT,BOO$GL_COMBO_VECTOR_OFFSET,-;
		ACF$W_CVECTOR(R10)	; Set vector address
	EXTZV	#2,#8,BOO$GL_COMBO_VECTOR_OFFSET,R0; Save vector offset in longwords
	MOVB	R0,ACF$B_COMBO_VECTOR_OFFSET(R10);
;
; Set up ACF$L_CONTRLREG - can either be UNIBUS CSR or address of CI
; 			   System id.
;
	TSTL	BOO$GQ_CONSYSID		; See if SYSIDLOW was specified
	BEQL	40$			; Branch if not
	MOVAB	BOO$GQ_CONSYSID, -
		ACF$L_CONTRLREG(R10)	; Set system id address
	BRB	50$			; Branch 
;
; Calculate system virtual address of UNIBUS CSR
;
40$:	ADDL3	#UBA_IOBASE, -
		BOO$GL_CONCREG, -
		ACF$L_CONTRLREG(R10)	; control register address
	ADDL	ACF$L_CONFIGREG(R10), -
		ACF$L_CONTRLREG(R10) 	; Add adapter va base
	ADDL	BOO$GL_COMBO_CSR_OFFSET,-; Add offset to get true CSR address
		ACF$L_CONTRLREG(R10)	;
	MNEGB	BOO$GL_COMBO_CSR_OFFSET,-; Calculate offset back to CSR start
		ACF$B_COMBO_CSR_OFFSET(R10); Save offset

50$:	MOVW	BOO$GL_CONCUNIT, -
		ACF$W_CUNIT(R10) 	; Set controller unit number
	MOVW	BOO$GL_CONUNITS, -
		ACF$W_MAXUNITS(R10) 	; Set maximum units
	MOVB	BOO$GL_CONNUMV, -
		ACF$B_CNUMVEC(R10)	; Set count of vectors
55$:	MOVL	#1,R0			; Set success
	RET				;

		.DSABL LSB

	.PAGE
	.SBTTL	BOO$LOAD - Load a driver or misc code if not already loaded
;
; BOO$LOAD - 	Loads the driver or misc code if not already loaded.
;
.Entry	BOO$LOAD, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	CLRL	R2			; Clear reload flag
	BRB	LOADRV			; And merge with common code
	.PAGE
	.SBTTL	BOO$RELOAD - Reload a specified driver
;
; BOO$RELOAD -	Reloads the specified driver replacing any existing copy
;		unless there are busy units requiring the driver that would
;		be replaced.
;
.Entry	BOO$RELOAD, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	;

	MOVB	#ACF$M_RELOAD,R2	; Set flag to force reload
LOADRV:
;
; The first block of the file will be read to determine if it is a driver or
; misc code by looking at the type field.
;
	PUSHL	BOO$GL_CONDRV		; File name string
	INCL	(SP)			; Get past the count
	MOVZBL	@BOO$GL_CONDRV,-(SP)	; Length of file name
	MOVL	SP,R7			; Address of desriptor for file name
	BSBW	BOO$EXEOPEN		; Open the file (default SYS$SYSTEM:.EXE)
	BLBC	R0,40$			; Error
	ADDL	#8,SP			; Clean up stack
	MOVAB	BOO$AB_LOADBUF,R6	; Buffer for file read
	MOVL	#2,R8			; First block after image header
	MOVL	#1,R9			; One page
	BSBW	BOO$READFILE
	BLBC	R0,40$			; Error
	BSBW	BOO$FILCLOSE		; Close the currently open file
	BLBC	R0,40$			; Error
	CMPB	BOO$AB_LOADBUF+SLV$B_TYPE,-
		#DYN$C_LOADCODE		; Check for misc code
	BEQL	LOADCODE
	BSBW	BOO$LOCK_GEN		; Lock SYSGEN database
	BLBC	R0,40$			; If lbc, didn't get lock
	MOVAB	L^BOO$AL_ACF,R10	; Get base address for ACF block
	MOVL	BOO$GL_CONDRV,ACF$L_DRVNAME(R10)	;
	MOVB	R2,ACF$B_AFLAG(R10)	; Set flags for load or reload
	CLRL	ACF$L_DEVNAME(R10)	; No device name
	CALLG	(R10),L^IOGEN$LOADER	; Load requested driver
	BLBS	R0,20$			; Continue if no error
	BSBW	PUTERROR		; Give error message
20$:	PUSHL	R0			; Save status
	BSBW	BOO$UNLOCK_GEN		; Unlock SYSGEN database
	BLBS	R0,30$			; If no error, continue
	BSBW	PUTERROR		; Give error message
30$:	POPL	R0			; Restore status
	RET				; Exit
40$:	BSBW	PUTERROR		; Give error message
	RET				; Exit
;
LOADCODE:
	PUSHL	BOO$GL_CONDRV		; File name string
	INCL	(SP)			; Get past the count
	MOVZBL	@BOO$GL_CONDRV,-(SP)	; Length of file name
	MOVL	SP,R7			; Address of desriptor for file name
	BSBW	BOO$UFOOPEN		; Open the file for user access (default SYS$SYSTEM:.EXE)
	BLBC	R0,10$			; Error
	ADDL	#8,SP			; Clean up stack
	PUSHAB	BOO$AB_LOADBUF		; Use code buffer for return address array
	PUSHL	R1			; Channel
	PUSHL	#2			; Arg count
	MOVL	SP,R0
	$CMKRNL_S ROUTIN = EXE$LOAD_CODE,-
		  ARGLST = (R0)
	BLBS	R0,20$
10$:	BSBW	PUTERROR
	RET

20$:	$CMKRNL_S ROUTIN = LINK_CODE
	BLBC	R0,10$
	RET
;
LINK_CODE:
	.WORD	^M<R2,R3,R4>
	MOVL	G^BOO$AB_LOADBUF,R2	; Address of loaded code
	MOVL	R2,R4			; Save address of loaded code
	MOVL	SLV$A_SYSVECS(R4),R3	; Get address of vectors in SYS.EXE
	JSB	G^EXE$LINK_VEC		; Connect vectors to loaded routines.
	BLBC	R0,10$			; Leave on error
	MOVAL	G^BOO$GL_LOAD_ARGS,AP	; Argument list for initialization routine
	MOVL	SLV$L_INITRTN(R4),R0	; Possible initialization routine
	BEQL	10$			; None, leave
	JSB	(R0)[R4]		; Call it
10$:	RET

	.PAGE
	.SBTTL	BOO$GIVEHELP - Print Help information
;
; 	Print Help Information
;
.Entry	BOO$GIVEHELP, ^M<R2,R3,R4,R5>	;

	PUSHAB	G^LIB$GET_INPUT		; Input routine
	PUSHAB	HELP_FLAG		; Flags
	PUSHAB	L^HELP_FILE		; Library
	MOVW	TPA$L_STRINGCNT(AP),-
		HELP_DESC		; Set length
	MOVL	TPA$L_STRINGPTR(AP),-
		HELP_DESC+4		; Set address
	PUSHAB	HELP_DESC		; Input string
	CLRL	-(SP)			; Width
	PUSHAB	G^LIB$PUT_OUTPUT	; Output routine
	CALLS	#6,G^LBR$OUTPUT_HELP	; Call help routine

	RET				; Return with status

	.END
