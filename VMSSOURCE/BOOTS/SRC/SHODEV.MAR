	.TITLE	SHODEV - DISPLAY DEVICE DATABASE TOPOLOGY
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; Facility:  System generation and initialization
;
; Abstract: This module contains routines to show the device database
;	topology.
;
; Environment:
;
; Author:  Len Kawell, Creation date:  14-JUL-1978
;
; Modification History:
;
;	V03-005	WHM0003		Bill Matthews		25-Jun-1984
;		Use the ucb chain in the ddb to display the first 63 units
;		if there is no idb for a device. Fix register usage across
;		calls to SCH$IOUNLOCK.
;
;	V03-004	WHM0002		Bill Matthews		15-Mar-1984
;		Rewrite SHOW/DEVICE algorithm to have the IO database MUTEX
;		for read when accessing UCB's or pointers to UCB's.
;
;	V03-003 MSH0003		Maryann Hinden		31-Jan-1983
;		Changes for cluster device names.
;
;	V03-002	MSH0002		Maryann Hinden 		19-Oct-1982
;		Modify display format for 0 UCB pointer.
;
;	V03-001	MSH0001		Maryann Hinden		30-Sep-1982
;		Check for DDB$L_UCB = 0.
;--

;
; LOCAL MACROS
;
	.MACRO	STRING_DESC STRING,?L1,?L2
	.LONG	L2-L1
	.LONG	L1
L1:
	.ASCII	\STRING\
L2:
	.ENDM	STRING_DESC

;
; EXTERNAL SYMBOLS
;
	$DPTDEF				;DRIVER PROLOGUE DEFINTIONS
	$DDBDEF				;DDB DEFINITIONS
	$DYNDEF				;DEFINE TYPE CODES
	$IDBDEF				;IDB DEFINITIONS
	$UCBDEF				;UCB DEFINITIONS
	$CRBDEF				;CRB DEFINITIONS
	$VECDEF				;INTERRUPT VECTOR DEFINITIONS
	$TPADEF				;TPARSE DEFINTIONS
;
; EQUATED VALUES:
;
	CR=13				; CHARACTER CODE FOR CARRIAGE RETURN
	LF=10				; CHARACTER CODE FOR LINEFEED
;
; OWN STORAGE
;
	.PSECT	PAGED_DATA	rd,wrt,noexe,quad

HEADER:					;PAGE HEADER
	.ASCII	<CR><LF>
	.ASCII	/__Driver___/
	.ASCII	/__Start__/
	.ASCII	/__End___/
HEADER2:
	.ASCII	/_Dev_/
	.ASCII	/__DDB____/
	.ASCII	/__CRB____/
	.ASCII	/__IDB____/
	.ASCII	/_Unit/
	.ASCII	/__UCB____/
HEADER_LEN=.-HEADER
HEADER_LEN2=HEADER2-HEADER

DRIVER_FAO:				;DRIVER FAO DESCRIPTOR
	STRING_DESC	<!10AC !XL !XL>
DDB_FAO:				;DDB FAO DESCRIPTOR
	STRING_DESC	<!3(_)     !AC !XL !XL !XL>
UCB_FAO:				;UCB FAO DESCRIPTOR
	STRING_DESC	<!7(_)    !4UB !XL>
DDB_NF_FAO:				;DDB FAO DESCRIPTOR (WITH NULL FIELDS)
	STRING_DESC	<!3(_)     !AC !XL>

OUTBUF_DESC:				;OUTPUT BUFFER DESCRIPTOR
	.LONG	OUTBUF_LEN
	.LONG	OUTBUF



OUTBUF_SIZE:				;OUTPUT BUFFER SIZE
	.BLKL	1
OUTBUF:					;OUTPUT BUFFER
	.BLKB	128
OUTBUF_LEN=.-OUTBUF
	.PAGE
	.SBTTL	DISPLAY DEVICE DATABASE TOPOLOGY
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the names and addresses of one or all the
;	drivers, DDBs, CRBs, IDBs, and UCBs.
;
; CALLING SEQUENCE:
;
;	CALL BOO$SHODEV(PARMBLK) ;Called as a TPARSE action routine
;				 ; TPA$L_TOKENPTR(AP) is driver name descriptor
;
;	CALL BOO$SHODEV_ALL(PARMBLK) ;Called as a TPARSE action routine
;
;	SHOW/DEVICE is called with 0 in TPA$L_PARAM(AP)
;	SHOW/DRIVER is called with 1 in TPA$L_PARAM(AP)
;
;--
	.PSECT	PAGED_CODE	rd,nowrt,exe,long
	.ENABL	LSB
BOO$SHODEV_ALL::
	.WORD	0
	CLRL	TPA$L_TOKENCNT(AP)	;MAKE ANYTHING MATCH
	BRB	10$

BOO$SHODEV::
	.WORD	0
10$:	SUBL2	#<64*8>,SP		;ALLOCATE A BUFFER ON THE USER STACK
	MOVL	SP,R9			;GET PTR TO THE BUFFER
	$CMEXEC_S W^DEVTOP_DISP,(AP)	;DO IT ALL IN EXEC MODE
	BLBS	R0,20$			;BR IF SUCCESS
	PUSHL	R0			;SET ERROR ARG
	CALLS	#1,G^LIB$SIGNAL		;SIGNAL THE ERROR
20$:	MOVL	#1,R0			;SET SUCCESS FOR PARSER
	RET

	.DSABL	LSB


;
; DISPLAY THE HEADER
;
DEVTOP_DISP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVC	#HEADER_LEN,W^HEADER,-
		W^RIO$AB_BUFFER		   	;PUT HEADER IN OUTPUT BUFFER
	MOVZBW	#HEADER_LEN,W^RIO$GW_OUTLEN	;SET SIZE OF STRING
	BLBC	TPA$L_PARAM(AP),10$	   	;BRANCH IF SHOW/DEVICE
	MOVZBW	#HEADER_LEN2,W^RIO$GW_OUTLEN	;SET SIZE OF STRING FOR SHOW/DRIVER

10$:	BSBW	RIO$OUTPUT_LINE			;WRITE IT TO OUTPUT DEVICE
;
; DISPLAY THE DRIVER INFO
;
	MOVL	G^IOC$GL_DPTLIST,R8	;GET ADDR OF FIRST DRIVER

DISP_DRIV:
	CMPC	TPA$L_TOKENCNT(AP),@TPA$L_TOKENPTR(AP),- ;NAMES MATCH?
		DPT$T_NAME+1(R8)
	BNEQ	NEXT_DRIV		;BR IF NOT
	MOVZWL	DPT$W_SIZE(R8),R0	;GET SIZE OF DRIVER
	ADDL2	R8,R0			;SET ADDR OF END OF DRIVER
	MOVAL	DPT$T_NAME(R8),R1	;SET ADDR OF DRIVER NAME

	$FAO_S	CTRSTR = W^DRIVER_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = R1,-
		P2     = R8,-
		P3     = R0

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE
	BLBC	TPA$L_PARAM(AP),DISP_DEV;BRANCH IF SHOW/DEVICE
NEXT_DRIV:				;FIND NEXT DRIVER
	MOVL	DPT$L_FLINK(R8),R8	;GET ADDR OF NEXT DRIVER
	CMPL	R8,#IOC$GL_DPTLIST	;END OF DRIVER LIST?
	BNEQ	DISP_DRIV		;BR IF NOT
	MOVL	#1,R0			;SET SUCCESS
	RET


;
; DISPLAY THE DEVICE INFO
;
DISP_DEV:
	CLRL	R11			;INITIALIZE
NEXT_DDB:
	$CMKRNL_S 1$,(AP)		;CALL ROUTINE IN KERNAL MODE
	TSTL	R11			;IF NO DDB CHECK FOR ANOTHER DRIVER
	BEQL	NEXT_DRIV		;R0 = 0 IMPLIED DONE WITH THIS DEVICE
	BRW	DISP_UCB		;DISPLAY THE UCB INFO

1$:	.WORD	^M<>			;
	MOVL	G^CTL$GL_PCB,R4		;GET PCB POINTER
	JSB	G^SCH$IOLOCKR		;GET IO DATABASE MUTEX FOR READ
10$:	CLRL	R10			;ONLY WANT DDB'S
	JSB	G^IOC$SCAN_IODB		;GET ADDR OF FIRST DDB
	BLBC	R0,30$			;FINISHED THE ENTIRE CHAIN?
	MOVAL	DDB$T_DRVNAME(R11),R1	;GET ADDR OF DRIVER NAME
	MOVZBL	(R1)+,R0		;GET SIZE OF DRIVER NAME
	MOVAB	DPT$T_NAME(R8),R3	;GET ADDR OF DRIVER NAME
	MOVZBL	(R3)+,R2		;GET SIZE OF DRIVER NAME
	CMPC5	R0,(R1),#0,R2,(R3)	;DOES DRIVER NAME MATCH?
	BNEQ	10$			;ELSE - GET ADDR OF NEXT DDB
	MOVAL	DDB$T_NAME(R11),R7	;GET ADDR OF DEV NAME
	MOVL	DDB$L_UCB(R11),R10	;GET ADDR OF FIRST UCB
	BEQL	20$			;IF EQL, NO UCB LINK THERE
	MOVL	UCB$L_CRB(R10),R5	;GET ADDR OF CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R5),R6;GET ADDR OF IDB
20$:	MOVL	G^CTL$GL_PCB,R4		;GET PCB POINTER
	JSB	G^SCH$IOUNLOCK		;RELEASE THE IO DATABASE MUTEX
	SETIPL	#0			;AND LOWER IPL
	RET				;AND RETURN TO EXEC MODE
30$:	CLRL	R11			;SET END OF DDB CHAIN FLAG
	BRB	20$			;USE COMMON RETURN

;
; DISPLAY THE UCB-RELATED DATA
;
OUTPUT_UCB_INFO:
	SUBL2	#2,R10			;BACK UP BUFFER INDEX
	CLRL	R2			;CLEAR NEW BUFFER INDEX
10$:	$FAO_S	CTRSTR = W^UCB_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = 4(R9)[R2],-	;SAVED UNIT NUMBER
		P2     = (R9)[R2]	;SAVED UCB ADDRESS

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE
	ACBL	R10,#2,R2,10$		;LOOP THROUGH THE BUFFER
	RSB				;RETURN



; NO UCB-RELATED DATA FOR DISPLAY
;
NO_UCB:
	$FAO_S	CTRSTR = W^DDB_NF_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = R7,-
		P2     = R11

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE
	BRW	NEXT_DDB		


DISP_UCB:
	TSTL	R10			;ANY UCB'S?
	BEQL	NO_UCB			;IF EQL NO

	$FAO_S	CTRSTR = W^DDB_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = R7,-
		P2     = R11,-
		P3     = R5,-
		P4     = R6		;SET ADDR OF IDB

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE

	MOVZWL	IDB$W_UNITS(R6),R5	;GET THE MAXIMUM NUMBER OF UNITS
	CMPL	R5,#63			;MORE THAN 63 UNITS?
	BLEQ	DISP_UCB_FROM_DDB	;IF LEQ THEN USE UCB CHAIN IN DDB
	CMPB	IDB$B_TYPE(R6),#DYN$C_IDB;IS THIS REALLY AN IDB?
	BEQL	DISP_UCB_FROM_IDB	;IF EQL USE THE UCB LIST IN THE IDB

;
; DISPLAY THE UCB INFO FROM THE DDB
;
DISP_UCB_FROM_DDB:

	$CMKRNL_S 1$,(AP)		;CALL ROUTINE IN KERNAL MODE
	BSBW	OUTPUT_UCB_INFO		;OUTPUT THE UCB INFO GATHERED SO FAR
	BRW	NEXT_DDB		;ELSE GET NEXT DDB

1$:	.WORD	^M<>			;
	JSB	G^SCH$IOLOCKR		;GET IO DATABASE MUTEX FOR READ
	MOVL	DDB$L_UCB(R11),R7	;GET FIRST ADDRESS OF FIRST UCB
	BEQL	NO_UCB			;IF EQL UCB LIST HAS GONE AWAY
	CLRL	R10			;SET BUFFER INDEX TO ZERO
10$:	MOVL	R7,(R9)[R10]		;LOAD UCB ADDRESS INTO BUFFER
	MOVZWL	UCB$W_UNIT(R7),4(R9)[R10];LOAD UNIT NUMBER INTO BUFFER
	ADDL2	#2,R10			;INCREMENT INDEX INTO BUFFER
	CMPL	R10,#<63*2>		;EXIT LOOP IF BUFFER IS FULL
	BGTR	20$			;IF GTR BUFFER IS FULL
	MOVL	UCB$L_LINK(R7),R7	;GET ADDRESS OF NEXT UCB
	BNEQ	10$			;IF NEQ THEN PROCESS NEXT UCB
20$:	JSB	G^SCH$IOUNLOCK		;RELEASE THE IO DATABASE MUTEX
	SETIPL	#0			;AND LOWER IPL
	RET				;RETURN TO EXEC MODE


;
; DISPLAY THE UCB INFO FROM THE IDB
;
DISP_UCB_FROM_IDB:

	CLRL	R7			;SET UNIT NUMBER TO ZERO
1$:	$CMKRNL_S 5$,(AP)		;CALL ROUTINE IN KERNAL MODE
	BSBW	OUTPUT_UCB_INFO		;OUTPUT THE UCB INFO GATHERED SO FAR
	CMPL	R7,R5			;HAVE ALL UNITS BEEN PROCESSED?
	BLSS	1$			;IF LEQ NO, CONTINUE PROCESSING UNITS
	BRW	NEXT_DDB		;ELSE GET NEXT DDB

5$:	.WORD	^M<>			;
	CLRL	R10			;SET BUFFER INDEX TO ZERO
	JSB	G^SCH$IOLOCKR		;GET IO DATABASE MUTEX FOR READ
10$:	MOVL	IDB$L_UCBLST(R6)[R7],R1	;UCB EXIST?
	BEQL	20$			;IF EQL NO
	MOVL	R1,(R9)[R10]		;IF UCB EXISTS LOAD ADDRESS INTO BUFFER
	MOVZWL	UCB$W_UNIT(R1),4(R9)[R10];LOAD UNIT NUMBER INTO BUFFER
	ADDL2	#2,R10			;INCREMENT INDEX INTO BUFFER
	CMPL	R10,#<63*2>		;EXIT LOOP IF BUFFER IS FULL
	BGTR	30$			;IF GEQ BUFFER IS FULL
20$:	AOBLSS	R5,R7,10$		;LOOP FOR ALL UNITS
30$:	JSB	G^SCH$IOUNLOCK		;RELEASE THE IO DATABASE MUTEX
	SETIPL	#0			;AND LOWER IPL
	RET				;AND RETURN TO EXEC MODE

	.END
