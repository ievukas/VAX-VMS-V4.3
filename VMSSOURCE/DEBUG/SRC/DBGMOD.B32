MODULE DBGMOD (IDENT = 'V04-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!
! ABSTRACT:
!
! Version:	1.08
!
! History:
!	Author:
!		Carol Peters, 03 Jul 1976: Version 01
!
!	Modified by:
!		Mike Candela, 18 October 1979
!		Richard Title, 12 AUG 1981
!
! Revision history:
! 3.00  21-Aug-81	 RT	Added support for SET STEP SOURCE and
!				SET STEP NOSOURCE
! 3.01	20-Oct-81	 RT	Added support for SEARCH command.
! 3.02  06-May-82	 RT	Added support for SET DEFINE and SHOW DEFINE
!       17-Aug-83        PS     Added mode G/NOG_FLOAT
!--

! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	dbg$init_modes:  NOVALUE,		! SETS MODES TO A SPECIFIED level
    	dbg$set_mod_lvl: NOVALUE,
	dbg$set_mod_def: NOVALUE,		! SETS DEFAULT MODES TO INITIALIZATION values
	dbg$show_mode:   NOVALUE,		! ACTION ROUTINE TO SHOW DEFAULT modes
	dbg$init_step:   NOVALUE,		! SETS step LEVELS AS SPECIFIED
	dbg$set_stp_def: NOVALUE,		! RESETS step LEVELS TO INITIALIZATION VALUES
	dbg$set_stp_lvl: NOVALUE,		! SETS level OF step
	dbg$show_step:   NOVALUE,		! ACTION ROUTINE TO SHOW step
    	dbg$init_search: NOVALUE,		! resets search levels to initial
    	dbg$set_search_def: NOVALUE,		! sets search levels as specified
    	dbg$set_search_lvl: NOVALUE,		! set level of search
    	dbg$show_search: NOVALUE,		! action routine for show search
    	dbg$init_define: NOVALUE,		! resets define levels to initial
    	dbg$set_define_def: NOVALUE,		! sets define levels as specified
    	dbg$set_define_lvl: NOVALUE,		! set level of define
    	dbg$show_define: NOVALUE,		! action routine for show define
 	dbg$set_out_def: NOVALUE,		! Sets default OUTPUT config
	dbg$show_output: NOVALUE,		! Displays OUTPUT configuration
	dbg$set_log:     NOVALUE,		! Set a new LOG file name
	setup_log:       ,			! Creates & opens log file
	dbg$verify_out:	 NOVALUE;		! Decides whether to VERIFY input
!
! REQUIRE FILES:
!
REQUIRE 'SRC$:DBGPROLOG.REQ';
LIBRARY 'LIB$:DBGGEN.L32';

EXTERNAL ROUTINE
    	dbg$fao_out: NOVALUE,
	dbg$get_memory,				! allocate block of free storage
    	dbg$newline: NOVALUE,			! output a line
    	dbg$nget_trans_radix,			! returns translation of default radix
	DBG$CONV_R_50,				! converts from radix 50
    	dbg$print: NOVALUE,			! put a line in the output buffer
	dbg$rel_memory : NOVALUE,		! return storage to free pool
    	dbg$show_radix: NOVALUE;

EXTERNAL
    	DBG$GB_KEYPAD_INPUT: BYTE,
    	DBG$GL_SCREEN_MODE,
	DBG$GB_DEF_STP :    BLOCKVECTOR
			    [STEP_LEVELS, EVENT$K_STEPPING_DESC_SIZE]
			    FIELD (EVENT$STEPPING_DESC_FIELDS),
	DBG$GB_STP_PTR :    REF EVENT$STEPPING_DESCRIPTOR, ! current stepping
    	dbg$gb_def_search: VECTOR [, BYTE],	! Block for SEARCH settings
    	dbg$gb_search_ptr: REF VECTOR [, BYTE],	! pointer to search settings
    	dbg$gb_def_define: VECTOR [, BYTE],	! Block for DEFINE settings
    	dbg$gb_define_ptr: REF VECTOR [, BYTE],	! pointer to define settings
	dbg$gb_def_mod: VECTOR [, BYTE],	! BLOCK FOR MODES
	dbg$gb_def_out: VECTOR [, BYTE],	! Vector for output config
	dbg$gl_cishead: REF cis$link,		! Head of cis
	dbg$gb_verptr : REF VECTOR [,BYTE],	! Verify pointer
	dbg$gb_mod_ptr: REF VECTOR [, BYTE],	! pointer TO MODES
	dbg$gl_context : BITVECTOR,		! CONTEXT WORD
	dbg$gb_language: BYTE,			! contains index to current language
	dbg$gl_lognam : REF $NAM_DECL,		! NAM block for LOG file
	dbg$gl_logfab : BLOCK [,BYTE],		! FAB for LOG file
	dbg$gl_lograb : BLOCK [,BYTE],		! RAB for LOG file
	dbg$gb_logfsr : REF VECTOR [,BYTE],	! Resultant LOG filespec buffer
	dbg$gb_logfse : REF VECTOR [,BYTE],	! Expanded LOG filespec buffer
	dbg$gl_log_buf,				! pointer to buffer containing
						! filespec from SET LOG cmd.
    	DBG$OPCODE_KIND_TABLE: VECTOR[512,WORD],
    	DBG$OPCODE_NAME_TABLE: BLOCKVECTOR[,10,BYTE];

LITERAL
	dbg_mod		= 0,			! DEBUGGING AID FOR mode
	dbg_mod1	= 0,			! DEBUGGING AID FOR step
	dbg_mod2	= 0;			!      "     "   "  log file 

!++
! The following table holds the valid mode settings and values
! relevant to them. Each entry in the table is three bytes long.
! The entry has three fields, each of them one byte
! long.
!
!	-------------------------------
!	! keyword !  offset ! value !
!	-------------------------------
!
! The keyword field holds the token value that represents the particular
! mode, e.g., byte_token indicates that the mode is BYTE.
! The offset field holds the location of the mode setting in any of
! the mode levels.
! The value field holds the value that represents a particular mode
! to DEBUG in an internal sense.
!
LITERAL
	keyword_field	= 0,
	offset_field	= 1,
	value_field	= 2,
	mode_entry_len	= 3,
	step_entry_len  = 3,
    	search_entry_len = 3;

BIND
	deflog_name = UPLIT BYTE(%ASCII 'DEBUG.LOG'),
	deflog_size = %CHARCOUNT(%ASCII 'DEBUG.LOG');

! build_err_desc creates a descriptor that contains the filespec for RMS error
! reporting using the shared message file
	
MACRO
	build_err_desc (msg_desc) = 

	IF .dbg$gl_log_buf NEQ 0
	THEN
		BEGIN
		msg_desc [dsc$w_length]  = .dbg$gl_logfab [fab$b_fns];
		msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_fna];
		END
	ELSE
		BEGIN
		msg_desc [dsc$w_length]  = .dbg$gl_logfab [fab$b_dns];
		msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_dna];
		END %,

! signal_rms_err reports RMS errors caused by $CREATE, $OPEN or $CONNECT 

	signal_rms_err (block_type) =
		BEGIN
		LOCAL
			msg_desc : BLOCK [8,BYTE], 
			sts,
			stv ;

		build_err_desc (msg_desc) ;
		IF block_type EQL 1
		THEN
			BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			END
		ELSE
			BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
			END;
		SIGNAL (shr$_openout+dbg_fac_code, 1, msg_desc, .sts, .stv);
		END %,

! restore_nam restores an RMS NAM block 

	restore_nam =
		BEGIN
		LOCAL
			err,
			type_b;

		! release storage for the aborted log file

		dbg$rel_memory ( .temp_nam);
		dbg$rel_memory ( .temp_fsr);
		dbg$rel_memory ( .temp_fse);
		dbg$gl_lognam = .old_nam_ptr;
		old_nam_ptr = 0;
		dbg$gl_logfab [fab$l_nam] = .dbg$gl_lognam;
		dbg$gl_logfab [fab$l_fna] = .fna;
		dbg$gl_logfab [fab$b_fns] = .fns;

		dbg$gl_logfab [fab$v_nam] = 1;
		dbg$gl_logfab [fab$v_cif] = 1;
		dbg$gl_logfab [fab$v_mxv] = 0;
		err = setup_log(type_b);
		IF NOT .err
		THEN
			signal_rms_err (.type_b) ;

		dbg$gb_def_out [out_log] = .log_temp ;
		END%;

GLOBAL ROUTINE dbg$init_modes (goal_level, source_level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from local level to the goal level specified
!	with the mode settings of the source level.
!
! FORMAL PARAMETERS:
!	goal_level	- highest level to set
!	source_level	- level from which to obtain mode settings
!
! IMPLICIT INPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!	THE mode settings of the local level to the goal level
!	are reset to the mode settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

%IF dbg_mod
%THEN
	$fao_tt_out ('copying level !SL modes to level !SL thru !SL',
			 .source_level, .goal_level, local_mode);
%FI

	temp_level = dbg$gb_def_mod [.source_level * mode_lvl_size];
	DECR I FROM local_mode TO .goal_level DO
		BEGIN
		dbg$gb_mod_ptr = dbg$gb_def_mod [.I * mode_lvl_size];
		dbg$gb_mod_ptr [mode_radix] = .temp_level [mode_radix];
		dbg$gb_mod_ptr [mode_length] = .temp_level [mode_length];
		dbg$gb_mod_ptr [mode_symbols] = .temp_level [mode_symbols];
    		dbg$gb_mod_ptr [mode_g_floats] = .temp_level [mode_g_floats];
		dbg$gb_mod_ptr [mode_instruc] = .temp_level [mode_instruc];
		dbg$gb_mod_ptr [mode_ascii] = .temp_level [mode_ascii];
		dbg$gb_mod_ptr [mode_scope] = .temp_level [mode_scope];
		dbg$gb_mod_ptr [mode_globals] = .temp_level [mode_globals];
		dbg$gb_mod_ptr [mode_immediate] = .temp_level [mode_immediate];
		dbg$gb_mod_ptr [mode_fortran] = .temp_level [mode_fortran];
		END;
	END;

!++
! THE FOLLOWING ROUTINES CONTROL INTERPRETATION AND TYPEOUT MODES.
!
!	ADDRESS INTERPRETATION AND DATA TYPEOUT ARE CONTROLLED BY FOUR MODE
!	SETTINGS. THEY ARE 'DEFAULT_MODE', WHICH IS THE MODE SET BY
!	DEBUG INITIALIZATION; 'user_def_mode', WHICH IS THE MODE SET
!	BY USER 'SET DEFAULT' COMMANDS; 'override_mode', WHICH IS
!	THE MODE SET BY A SINGLE LINE OVERRIDE MODE COMMAND; AND
!	'local_mode', WHICH IS THE MODE SET FOR A SINGLE VARIABLE.
!	WHICH MODE IS USED DEPENDS ON THE pointer INTO THE BLOCK
!	dbg$gb_def_mod.
!
!	AT INITIALIZATION TIME, THE FOUR MODE SETTINGS ARE INITIALIZED
!	TO THE SAME values. WHEN THESE values ARE CHANGED BY USER COMMANDS,
!	SOME PROPAGATION OF MODE values MUST MOVE UP AND DOWN THROUGH THE
!	DIFFERENT BLOCKS SO THAT THE ITEMS DISPLAYED OR INTERPRETED WILL
!	HAVE VALID AND TIMELY MODE SETTINGS FOR BOTH RADIX AND LENGTH.
!
!	THE ROUTINES THAT FOLLOW SET THE MODE BLOCK pointerS TO THEIR NEW
!	value AND PROPAGATE values AS NECESSARY.
!
!	THE GENERAL STRATEGY IS AS FOLLOWS:
!	DEFAULT_MODE SETTINGS ARE NEVER CHANGED
!	user_def_mode SETTINGS ARE NEVER CHANGED AS A RESULT OF pointer JIGGLING.
!		THEY ARE ONLY CHANGED EXPLICITLY IN ACTION ROUTINES.
!	override_mode SETTINGS ARE CHANGED TO REFLECT USER-SET DEFAULTS 
!		WHEN THEY ARE THE OBJECT OF THE pointer.
!	local_mode SETTINGS ARE COPIED FROM override_mode SETTINGS WHEN THEY
!		ARE THE OBJECT OF THE pointer.
!	WHEN THE pointer IS MOVING UP THE BLOCK, FROM local_mode TOWARD
!		DEFAULT_MODE, NO values ARE PROPAGATED.
!	SETTING OF local_mode AND override_mode TO DEFAULT SETTINGS AT THE END OF
!		A COMMAND LINE IS THE EXPLICIT RESPONSIBILITY OF EOC ACTION
!		ROUTINE.
!--

GLOBAL ROUTINE dbg$set_mod_lvl (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	SEE DESCRIPTION ON PAGE 2
!
! FORMAL PARAMETERS:
!	level	- The structure level to set the pointer to.
!		  user_def_mode
!		  override_mode
!		  local_mode
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	IF (dbg$gb_def_mod[.level * mode_lvl_size] LEQA .dbg$gb_mod_ptr)
	OR (.level EQL user_def_mode)
	THEN
	    BEGIN
	    dbg$gb_mod_ptr = dbg$gb_def_mod [.level * mode_lvl_size];
	    RETURN
	    END;

	SELECT .level OF

		SET

		[override_mode]:
			BEGIN
			temp_level = dbg$gb_def_mod [user_def_mode * mode_lvl_size];
			dbg$gb_mod_ptr = dbg$gb_def_mod [override_mode * mode_lvl_size];
			END;

		[local_mode]:
			BEGIN
			temp_level = .dbg$gb_mod_ptr;
			dbg$gb_mod_ptr = dbg$gb_def_mod [local_mode * mode_lvl_size];
			END;

		TES;
	dbg$gb_mod_ptr [mode_radix] = .temp_level [mode_radix];
	dbg$gb_mod_ptr [mode_length] = .temp_level [mode_length];
	dbg$gb_mod_ptr [mode_symbols] = .temp_level [mode_symbols];
    	dbg$gb_mod_ptr [mode_g_floats] = .temp_level [mode_g_floats];
	dbg$gb_mod_ptr [mode_instruc] = .temp_level [mode_instruc];
	dbg$gb_mod_ptr [mode_ascii] = .temp_level [mode_ascii];
	dbg$gb_mod_ptr [mode_scope] = .temp_level [mode_scope];
	dbg$gb_mod_ptr [mode_globals] = .temp_level [mode_globals];
	dbg$gb_mod_ptr [mode_immediate] = .temp_level [mode_immediate];
	dbg$gb_mod_ptr [mode_fortran] = .temp_level [mode_fortran];
	END;

GLOBAL ROUTINE dbg$set_mod_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR MODE SETTINGS.
!	RESETS ALL MODE LEVELS TO LANGUAGE DEFAULTS.
!	Called from  DBG$INIT_DEBUG as part of the
!	once-only initialization phase of DEBUG.
!
! FORMAL PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE DEFAULT MODES
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	!+
	! Set up the MODE data structure
	!-

	dbg$gb_mod_ptr = dbg$gb_def_mod [default_mode * mode_lvl_size];

	dbg$gb_mod_ptr [mode_radix] = dbg$k_default;
	dbg$gb_mod_ptr [mode_length] = long_length;
	dbg$gb_mod_ptr [mode_symbols] = TRUE;
    	dbg$gb_mod_ptr [mode_g_floats] = FALSE;
	dbg$gb_mod_ptr [mode_instruc] = FALSE;
	dbg$gb_mod_ptr [mode_ascii] = FALSE;
	dbg$gb_mod_ptr [mode_scope] = TRUE;
	dbg$gb_mod_ptr [mode_globals] = FALSE;
	dbg$gb_mod_ptr [mode_immediate] = TRUE;
	dbg$gb_mod_ptr [mode_fortran] = 0;
	dbg$init_modes (user_def_mode, default_mode);
	END;

GLOBAL ROUTINE dbg$show_mode : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO SHOW MODES
!
! FORMAL PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE POINTER TO THE CURRENT MODE STRUCTURE.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE MODES ARE DISPLAYED ON THE OUTPUT DEVICE
!--
    BEGIN
    dbg$print(UPLIT BYTE(%ASCIC 'modes: '));
    IF NOT .dbg$gb_mod_ptr[mode_symbols]
    THEN
        dbg$print(UPLIT BYTE(%ASCIC 'no'));
    dbg$print(UPLIT BYTE(%ASCIC 'symbolic, '));
    IF NOT .dbg$gb_mod_ptr[mode_g_floats]
    THEN
        dbg$print(UPLIT BYTE(%ASCIC 'd_float, '))
    ELSE
    	dbg$print(UPLIT BYTE(%ASCIC 'g_float, '));
    IF NOT .dbg$gl_screen_mode
    THEN
        dbg$print(UPLIT BYTE(%ASCIC 'no'));
    dbg$print(UPLIT BYTE(%ASCIC 'screen, '));
    IF NOT .dbg$gb_keypad_input
    THEN
        dbg$print(UPLIT BYTE(%ASCIC 'no'));
    dbg$print(UPLIT BYTE(%ASCIC 'keypad'));
    dbg$newline();
    dbg$show_radix(0);
    END;

GLOBAL ROUTINE DBG$INIT_STEP (GOAL_LEVEL, SOURCE_LEVEL) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from override level to the goal level specified
!	with the step settings of the source level.
!
!
! INPUTS:
!	goal_level	- highest level to set
!	source_level	- level from which to obtain step settings
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	THE step settings of the override level to the goal level
!	are reset to the step settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--
    BEGIN
    LOCAL
	TEMP_LEVEL :    REF EVENT$STEPPING_DESCRIPTOR;

    TEMP_LEVEL = DBG$GB_DEF_STP [.SOURCE_LEVEL,
				 EVENT$A_STEPPING_DESCRIPTOR
				];
    DECR I FROM OVERRIDE_STEP TO .GOAL_LEVEL DO
	BEGIN
	DBG$GB_STP_PTR = DBG$GB_DEF_STP [.I, EVENT$A_STEPPING_DESCRIPTOR];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_LINE] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_LINE];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSYSTEM] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_NOSYSTEM];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_OVER] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_OVER];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_SOURCE] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_SOURCE];
    	DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSILENT] =
    	    .TEMP_LEVEL [EVENT$V_STEPPING_NOSILENT];

	DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND] =
	    .TEMP_LEVEL [EVENT$B_STEPPING_KIND];
	DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST] =
	    .TEMP_LEVEL [EVENT$L_STEPPING_OP_LIST];
	END;
    END;

GLOBAL ROUTINE DBG$SET_STP_DEF : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR STEP SETTINGS.
!	RESETS ALL STEP LEVELS TO SYSTEM DEFAULTS FOR THE CURRENT LANGUAGE.
!
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE DEFAULT STEP SETTINGS
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	RESETS DEFAULT values FOR STEP.
!--
    BEGIN


    ! Set up the step data structure
    !
    DBG$GB_STP_PTR = DBG$GB_DEF_STP [DEFAULT_STEP,
				     EVENT$A_STEPPING_DESCRIPTOR
				    ];
    IF .DBG$GB_LANGUAGE EQL DBG$K_MACRO 
    THEN
	BEGIN
	DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND] = EVENT$K_INS_EVRY;
	DBG$GB_STP_PTR [EVENT$V_STEPPING_LINE] = FALSE;
	END
    ELSE
	BEGIN
	DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND] = EVENT$K_INS_LINE;
	DBG$GB_STP_PTR [EVENT$V_STEPPING_LINE] = TRUE;
	END;
    DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSYSTEM] = TRUE;
    DBG$GB_STP_PTR [EVENT$V_STEPPING_OVER] = TRUE;
    DBG$GB_STP_PTR [EVENT$V_STEPPING_SOURCE] = TRUE;
    DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSILENT] = TRUE;

    DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST] = 0;

    DBG$INIT_STEP (USER_DEF_STEP, DEFAULT_STEP);
    END;

GLOBAL ROUTINE DBG$SET_STP_LVL (LEVEL) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	This routine sets the pointer to the step structure to the specified
!	level.  If the level is not user_def_step the step values there are
!	copied to override_step level.  If the level is user_def_step the
!	pointer is just reset to that level.
!
! FORMAL PARAMETERS:
!	LEVEL	- The new step structure level.
!		  user_def_step
!		  override_step
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--
    BEGIN

    LOCAL
	TEMP_LEVEL: REF EVENT$STEPPING_DESCRIPTOR;

    IF .LEVEL EQL USER_DEF_STEP
    THEN
	DBG$GB_STP_PTR = DBG$GB_DEF_STP [USER_DEF_STEP,
					 EVENT$A_STEPPING_DESCRIPTOR
					]
    ELSE
	BEGIN
	TEMP_LEVEL = DBG$GB_DEF_STP [USER_DEF_STEP,
				     EVENT$A_STEPPING_DESCRIPTOR
				    ];
	DBG$GB_STP_PTR = DBG$GB_DEF_STP [OVERRIDE_STEP,
					 EVENT$A_STEPPING_DESCRIPTOR
					];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_LINE] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_LINE];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSYSTEM] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_NOSYSTEM];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_OVER] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_OVER];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_SOURCE] =
	    .TEMP_LEVEL [EVENT$V_STEPPING_SOURCE];
    	DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSILENT] =
    	    .TEMP_LEVEL [EVENT$V_STEPPING_NOSILENT];

	DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND] =
	    .TEMP_LEVEL [EVENT$B_STEPPING_KIND];
	DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST] =
	    .TEMP_LEVEL [EVENT$L_STEPPING_OP_LIST];
	END;
    END;

GLOBAL ROUTINE DBG$SHOW_STEP : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO DISPLAY THE CURRENT SETTING OF THE
!	"STEP TYPE" DATA STRUCTURE
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	none.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE STEP SETTINGS ARE DISPLAYED ON THE OUTPUT DEVICE
!--
    BEGIN


    ! Setup a UPLIT %ASCIC string.
    !
    MACRO
	$AC (STRING) =
	    UPLIT BYTE (%ASCIC STRING)
	%;


    ! Step type...
    !
    DBG$PRINT   ($AC    ('step type: '));


    ! [NO] SYSTEM....
    !
    IF .DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSYSTEM]
    THEN
	DBG$PRINT   ($AC    ('no'));
    DBG$PRINT   ($AC    ('system, '));


    ! [NO] SOURCE....
    !
    IF NOT .DBG$GB_STP_PTR [EVENT$V_STEPPING_SOURCE]
    THEN
	DBG$PRINT   ($AC    ('no'));
    DBG$PRINT   ($AC    ('source, '));


    ! [NO] SILENT....
    !
    IF .DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSILENT]
    THEN
	DBG$PRINT   ($AC    ('no'));
    DBG$PRINT   ($AC    ('silent, '));


    ! INTO/OVER....
    !
    IF .DBG$GB_STP_PTR [EVENT$V_STEPPING_OVER]
    THEN
	DBG$PRINT   ($AC    ('over'))
    ELSE
	DBG$PRINT   ($AC    ('into'));
    DBG$PRINT   ($AC    (' routine calls, '));


    ! Display the instruction type (calls, branches, all, or user
    ! list.
    !
    DBG$PRINT   ($AC ('by !AC'),
		 SELECTONE .DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND] OF
		    SET
		    [EVENT$K_INS_CALL] :
			$AC ('calls:');
		    [EVENT$K_INS_BRAN] :
			$AC ('branches:');
    		    [EVENT$K_EXC_EXC] :
    			$AC ('exceptions');
		    [EVENT$K_INS_EVRY] :
			$AC ('instruction');
		    [EVENT$K_INS_USER] :
			$AC ('instruction(s):');
		    [EVENT$K_INS_LINE] :
			$AC ('line');
		    [EVENT$K_ACC_RTRN] :
			$AC ('return');
		    TES
		);


    ! If this entry is an instruction type (/CALL, /BRANCH, etc.) and
    ! has an opcode bit map (i.e., is not for all instructions),
    ! display the opcode mnemonics indicated.
    !
    IF .DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST] NEQA 0
    THEN
	BEGIN
	LOCAL
	    OPCODE_LIST :   REF BITVECTOR [512],
	    COLUMN;

	! Point to the opcode list, and set the column to 0.
	!
	OPCODE_LIST = .DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST];
	COLUMN = -1;
	INCR OPCODE FROM 0 TO 511 DO
	  IF .OPCODE_LIST [.OPCODE] THEN
	    BEGIN
	    LOCAL INDEX;

	    IF (COLUMN = (.COLUMN + 1) AND 7) EQLU 0 THEN DBG$NEWLINE ();
	    INDEX = .DBG$OPCODE_KIND_TABLE[.OPCODE];
	    DBG$PRINT ($AC ('!_!AD'),6,DBG$OPCODE_NAME_TABLE[.INDEX,0,0,0,0]);
	    END;
	DBG$NEWLINE ();
	END


    ! Otherwise, just print the line.
    !
    ELSE
	DBG$NEWLINE ();
    END;

GLOBAL ROUTINE dbg$init_search (goal_level, source_level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from override level to the goal level specified
!	with the search settings of the source level.
!
!
! INPUTS:
!	goal_level	- highest level to set
!	source_level	- level from which to obtain search settings
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	THE search settings of the override level to the goal level
!	are reset to the search settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	temp_level = dbg$gb_def_search [.source_level * search_lvl_size];
	DECR I FROM override_search TO .goal_level DO
		BEGIN
		dbg$gb_search_ptr = dbg$gb_def_search [.I * search_lvl_size];
		dbg$gb_search_ptr [search_all] = .temp_level [search_all];
		dbg$gb_search_ptr [search_ident] = .temp_level [search_ident];
		END;
	END;

GLOBAL ROUTINE dbg$set_search_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR SEARCH SETTINGS.
!	RESETS ALL SEARCH LEVELS TO SYSTEM DEFAULTS FOR THE CURRENT LANGUAGE.
!
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE DEFAULT SEARCH SETTINGS
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	RESETS DEFAULT values FOR SEARCH.
!--

	BEGIN


	!+
	! Set up the search data structure
	!-
   
	dbg$gb_search_ptr = dbg$gb_def_search[default_search * search_lvl_size];
     
	dbg$gb_search_ptr[search_all] = FALSE;
	dbg$gb_search_ptr[search_ident] = FALSE;
	dbg$init_search (user_def_search, default_search);
	END;

GLOBAL ROUTINE dbg$set_search_lvl (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	This routine sets the pointer to the search structure to the specified
!	level.  If the level is not user_def_search the search values there are
!	copied to override_search level.  If the level is user_def_search the
!	pointer is just reset to that level.
!
! FORMAL PARAMETERS:
!	LEVEL	- The new search structure level.
!		  user_def_search
!		  override_search
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	IF .level EQL user_def_search
	THEN
		BEGIN
		dbg$gb_search_ptr = dbg$gb_def_search [user_def_search * search_lvl_size];
		END
	ELSE
		BEGIN
		temp_level = dbg$gb_def_search [user_def_search * search_lvl_size];
		dbg$gb_search_ptr = dbg$gb_def_search [override_search * search_lvl_size];

		dbg$gb_search_ptr [search_all] = .temp_level [search_all];
		dbg$gb_search_ptr [search_ident] = .temp_level [search_ident];
		END;

	END;

GLOBAL ROUTINE dbg$show_search : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO DISPLAY THE CURRENT SETTING OF THE
!	"SEARCH TYPE" DATA STRUCTURE
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	none.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE SEARCH SETTINGS ARE DISPLAYED ON THE OUTPUT DEVICE
!--

BEGIN
	LOCAL
		all_cs		: REF VECTOR[,byte],
		ident_cs	: REF VECTOR[,byte];

	!+
	! We simply put out one line describing the
	! current search types, based on the TRUE/FALSE
	! indicators given in the SEARCH structure.
	!-

	! If the search mode is not ALL, then it 
	! must be NEXT.

	if( .dbg$gb_search_ptr[ search_all ] )
	then
		all_cs = uplit( %ascic 'all occurences' )
    	else
    		all_cs = uplit( %ascic 'next occurence' );

	! If the search mode is not IDENT, then it 
	! must be STRING.

	if( .dbg$gb_search_ptr[ search_ident] )
	then
		ident_cs = uplit( %ascic 'an identifier' )
    	else
    		ident_cs = uplit( %ascic 'a string');

	! Put out the line and return.

	$fao_tt_out('search settings: search for !AC, as !AC',
		.all_cs,.ident_cs);
END;

GLOBAL ROUTINE dbg$init_define (goal_level, source_level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from override level to the goal level specified
!	with the define settings of the source level.
!
! INPUTS:
!
!	goal_level	- highest level to set
!	source_level	- level from which to obtain define settings
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	THE define settings of the override level to the goal level
!	are reset to the define settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	temp_level = dbg$gb_def_define [.source_level * define_lvl_size];
	DECR I FROM override_define TO .goal_level DO
		BEGIN
		dbg$gb_define_ptr = dbg$gb_def_define [.I * define_lvl_size];
		dbg$gb_define_ptr [define_only] = .temp_level [define_only];
		END;
	END;

GLOBAL ROUTINE dbg$set_define_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR define SETTINGS.
!	RESETS ALL define LEVELS TO SYSTEM DEFAULTS FOR THE CURRENT LANGUAGE.
!
! INPUTS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE DEFAULT define SETTINGS
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	RESETS DEFAULT values FOR define.
!--

	BEGIN


	!+
	! Set up the define data structure
	!-
   
	dbg$gb_define_ptr = dbg$gb_def_define[default_define * define_lvl_size];
     
	dbg$gb_define_ptr[define_only] = define_address;
	dbg$init_define (user_def_define, default_define);
	END;

GLOBAL ROUTINE dbg$set_define_lvl (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	This routine sets the pointer to the define structure to the specified
!	level.  If the level is not user_def_define the define values there are
!	copied to override_define level.  If the level is user_def_define the
!	pointer is just reset to that level.
!
! FORMAL PARAMETERS:
!	LEVEL	- The new define structure level.
!		  user_def_define
!		  override_define
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	IF .level EQL user_def_define
	THEN
		BEGIN
		dbg$gb_define_ptr = dbg$gb_def_define [user_def_define * define_lvl_size];
		END
	ELSE
		BEGIN
		temp_level = dbg$gb_def_define [user_def_define * define_lvl_size];
		dbg$gb_define_ptr = dbg$gb_def_define [override_define * define_lvl_size];

		dbg$gb_define_ptr [define_only] = .temp_level [define_only];
		END;

	END;

GLOBAL ROUTINE dbg$show_define : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO DISPLAY THE CURRENT SETTING OF THE
!	"define TYPE" DATA STRUCTURE
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	none.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE define SETTINGS ARE DISPLAYED ON THE OUTPUT DEVICE
!--

BEGIN

    	LOCAL
    	    def_cs : REF VECTOR [,BYTE];

	!+
	! We simply put out one line describing the
	! current define types, based on the values
	! given in the define structure.
	!-

    	CASE .dbg$gb_define_ptr [define_only] 
    		FROM define_lowest TO define_highest OF
    	    SET

    	    [define_address] : 
    		def_cs = UPLIT (%ASCIC 'ADDRESS');

    	    [define_command] :
    		def_cs = UPLIT (%ASCIC 'COMMAND');

    	    [define_procedure] :
    		def_cs = UPLIT (%ASCIC 'PROCEDURE');

    	    [define_string] :
    		def_cs = UPLIT (%ASCIC 'STRING');
    
    	    [define_value] :
    		def_cs = UPLIT (%ASCIC 'VALUE');

    	    [INRANGE, OUTRANGE] :
    		$DBG_ERROR('DBGMOD\DBG$SHOW_DEFINE');

    	    TES;

	$fao_tt_out('current setting is: DEFINE/!AC',.def_cs);
END;

GLOBAL ROUTINE dbg$set_out_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets OUTPUT configuration to default settings. Is called from
!	DBG$INIT_DEBUG as part of the once only initialization phase.
!	Also initializes the default LOG filespec and the string buffers and
!	location of the LOG file's NAM block.
!
! FORMAL PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	The default modes
!
! IMPLICIT OUTPUTS:
!	The vector dbg$gb_def_out is initialized
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!--

	BEGIN


	dbg$gb_def_out [out_log] 	= FALSE;	! nolog
	dbg$gb_def_out [out_term]	= TRUE;		! terminal
	dbg$gb_def_out [out_verify]	= FALSE;	! noverify

	! This variable is used to hold pointer to a user defined filespec

	dbg$gl_log_buf = 0;
	
	! initialize default log file spec

	dbg$gl_logfab [fab$l_dna] = deflog_name;
	dbg$gl_logfab [fab$b_dns] = deflog_size;

	! Initialize address of related NAM block and the resultant string buffers

	dbg$gl_lognam = dbg$get_memory((nam$c_bln+3)/%UPVAL);
	$nam_init (nam=.dbg$gl_lognam);
	dbg$gb_logfse = dbg$get_memory((nam$c_maxrss+3)/%UPVAL);
	dbg$gb_logfsr = dbg$get_memory((nam$c_maxrss+3)/%UPVAL);
	dbg$gl_logfab [fab$l_nam] = .dbg$gl_lognam;
	dbg$gl_lognam [nam$l_esa] = .dbg$gb_logfse;
	dbg$gl_lognam [nam$l_rsa] = .dbg$gb_logfsr;
	dbg$gl_lognam [nam$b_ess] = nam$c_maxrss;
	dbg$gl_lognam [nam$b_rss] = nam$c_maxrss;

	END;

GLOBAL ROUTINE dbg$show_output(full_rep) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:  
!	Action routine to show OUTPUT configuration
!
! FORMAL PARAMETERS:
!	full_rep    equals 1 for a full report (i.e. "SHOW OUTPUT")
!		           2 for just "SHOW LOG"
!
! IMPLICIT INPUTS:
!	The OUTPUT configuration data structure, dbg$gb_def_out
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
! 	none
!
! SIDE EFFECTS:
! 	A message is generated that displays the current output configuration
!	and the log file name
!--

	BEGIN

	LOCAL
		verify_cs :	REF VECTOR [,BYTE],
		term_cs :	REF VECTOR [,BYTE],
		log_cs :	REF VECTOR [,BYTE],
		no_count: 	word,
		string_count:	word;			! count of chars in output string

	no_count = 0;				! count of "no" characters

	IF .full_rep 
	THEN
		BEGIN
		IF .dbg$gb_def_out [out_verify]
		THEN
			verify_cs = UPLIT(%ASCIC '')
		ELSE
			BEGIN
			verify_cs = UPLIT(%ASCIC 'no');
			no_count = .no_count + 2;
			END;
	
		IF .dbg$gb_def_out [out_term]
		THEN
			term_cs = UPLIT(%ASCIC '')
		ELSE
			BEGIN
			term_cs = UPLIT(%ASCIC 'no');
			no_count = .no_count + 2
			END;
		END;

	IF .dbg$gb_def_out [out_log]
	THEN
		log_cs = UPLIT(%ASCIC '')
	ELSE
		BEGIN
		log_cs = UPLIT(%ASCIC 'not ');
		no_count = .no_count + 3;
		END;

%IF dbg_mod2
%THEN
$fao_tt_out('show_output: rss !SB, rsa !XL',.dbg$gl_lognam[nam$b_rss], .dbg$gl_lognam[nam$l_rsa]);
%FI

	! If a LOG file is open report the filespec in the NAM block, otherwise
	! use the default filespec


	IF .dbg$gl_logfab [fab$w_ifi] LEQ 0
	THEN
		IF .full_rep
		THEN
		$fao_tt_out('output: !ACverify, !ACterminal, !AClogging to !AD', 
		.verify_cs, .term_cs, .log_cs, deflog_size, deflog_name) 
		ELSE
		$fao_tt_out('!AClogging to !AD',.log_cs, deflog_size, deflog_name)

	ELSE
	    IF .full_rep
	    THEN
	    BEGIN
            ! string count is initialized to the no. of characters in the output
            ! string (not counting "no"s and the log filespec).

	    string_count = 38;
	    string_count = .string_count + .no_count + .dbg$gl_lognam[nam$b_rsl];

	    ! If we exceed the max record length, output two lines

	    IF .string_count LEQ tty_out_width
	    THEN
	    $fao_tt_out('output: !ACverify, !ACterminal, !AClogging to !AD', 
	    .verify_cs, .term_cs, .log_cs, .dbg$gl_lognam[nam$b_rsl], .dbg$gl_lognam[nam$l_rsa])
	
	    ELSE
     		BEGIN
	        $fao_tt_out('output: !ACverify, !ACterminal, !AClogging to :', 
			.verify_cs, .term_cs, .log_cs); 
		$fao_tt_out('!AD', .dbg$gl_lognam[nam$b_rsl], .dbg$gl_lognam[nam$l_rsa]);
		END;
	    END
	
	    ELSE
	    $fao_tt_out('!AClogging to !AD', .log_cs, .dbg$gl_lognam[nam$b_rsl],
		        .dbg$gl_lognam[nam$l_rsa]);

	END;

GLOBAL ROUTINE dbg$set_log : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine closes any log file that is currently open and opens
! the file specified by the user in SET LOG "filespec"
!
! FORMAL PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	The RMS-set IFI (internal file identifier field) bit is used to
! determine if a previous log file is still open.
!
! The user specified LOG filespec is pointed to by dbg$gl_log_buf
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	Any previously open log file is closed and a new log file is opened.
! Logging is inhibited for the duration of this routine.
!--

	BEGIN
	
	LOCAL
		status,
		opened_log,
		fns : BYTE,
		fna,
		old_nam_ptr,
		b_type,
		temp_nam : REF $NAM_DECL,
		temp_fse : REF VECTOR [,BYTE],
		temp_fsr : REF VECTOR [,BYTE],
		log_temp : BYTE;
	
	opened_log = FALSE ;

	! inhibit logging until we can redirect the log file

	log_temp = .dbg$gb_def_out [out_log];
	dbg$gb_def_out [out_log] = FALSE;

	! see if a log file has been previously opened. If so, close it,
	! since it must be CLOSEd befor we can do the new $PARSE.

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		BEGIN

		opened_log = TRUE;
		fna = .dbg$gl_logfab [fab$l_fna];
		fns = .dbg$gl_logfab [fab$b_fns];

		status = $CLOSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN
			LOCAL
				msg_desc : BLOCK [8,BYTE];
			build_err_desc (msg_desc);
			SIGNAL (shr$_closeout+dbg_fac_code, 1, msg_desc,
			       .dbg$gl_logfab[fab$l_sts], .dbg$gl_logfab[fab$l_stv]); 
			END;

		! get new NAM block, preserve the original

		temp_nam = dbg$get_memory((nam$c_bln+3)/%UPVAL);
		$nam_init (nam = .temp_nam);
		temp_fse = dbg$get_memory((nam$c_maxrss+3)/%UPVAL);
		temp_fsr = dbg$get_memory((nam$c_maxrss+3)/%UPVAL);
		temp_nam [nam$l_esa] = .temp_fse;
		temp_nam [nam$l_rsa] = .temp_fsr;
		temp_nam [nam$b_ess] = nam$c_maxrss;
		temp_nam [nam$b_rss] = nam$c_maxrss;
		dbg$gl_logfab [fab$l_nam] = .temp_nam;
		old_nam_ptr = .dbg$gl_lognam;
		dbg$gl_lognam = .temp_nam;

		END;

%IF dbg_mod2
%THEN
$fao_tt_out('dbg$gl_log_buf- !XL',.dbg$gl_log_buf);
%FI

	! reset the appropriate FAB file process options

	dbg$gl_logfab [fab$v_cif] = 0;
	dbg$gl_logfab [fab$v_mxv] = 1;
	dbg$gl_logfab [fab$v_nam] = 0;

	! Set up file name, dbg$gl_log_buf contains the pointer to the user
	! specified filespec.

	IF .dbg$gl_log_buf NEQ 0
	THEN
		BEGIN

		MAP
			dbg$gl_log_buf : REF VECTOR [,BYTE];

		dbg$gl_logfab [fab$l_fna] = .dbg$gl_log_buf + 1; ! filename addr starts in 2nd byte
		dbg$gl_logfab [fab$b_fns] = .dbg$gl_log_buf[0];  ! 1st byte is count
%IF dbg_mod2
%THEN
$fao_tt_out('fna !AD',.dbg$gl_logfab[fab$b_fns], .dbg$gl_logfab[fab$l_fna]);
%FI

		! Parse the filespec to see if an explicit version number was
		! given. If so set the CIF bit, otherwise we must maximize
		! the version number.

		status = $PARSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN
			LOCAL
				sts,
				stv,
				msg_desc : BLOCK [8,BYTE];

			! save these because restore_nam will reset them

			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			build_err_desc (msg_desc);

			IF .opened_log
			THEN
				restore_nam 
			ELSE
				BEGIN
				dbg$gl_logfab [fab$l_fna] = 0;
				dbg$gl_logfab [fab$b_fns] = 0;
				dbg$gl_log_buf	= 0;
				END;

			SIGNAL (shr$_syntax + dbg_fac_code, 1, msg_desc, .sts, .stv);
			END;

%IF dbg_mod2
%THEN
$fao_tt_out('status; !XL', .status);
$fao_tt_out('nam esa- !AD',.dbg$gl_lognam[nam$b_esl], .dbg$gl_lognam[nam$l_esa]);
%FI
		IF .dbg$gl_lognam [nam$v_exp_ver]
		THEN
			BEGIN
			dbg$gl_logfab [fab$v_cif] = 1;
			dbg$gl_logfab [fab$v_mxv] = 0;
			END;

		dbg$gl_logfab [fab$v_nam] = 1;		! open by NAM block since
		END;					! we've already parsed the filespec


%IF dbg_mod2
%THEN
$fao_tt_out('fna !AD',.dbg$gl_logfab[fab$b_fns], .dbg$gl_logfab[fab$l_fna]);
%FI

	! now open the new log file

	status = setup_log(b_type);
	IF NOT .status
	THEN
		BEGIN
		LOCAL 
			msg_desc : BLOCK [8,BYTE],
			sts,
			stv;

		build_err_desc (msg_desc);
		IF .b_type EQL 1
		THEN
			BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			END
		ELSE
			BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
			END;

		IF .opened_log
		THEN
			restore_nam 
		ELSE
			BEGIN
			dbg$gl_logfab [fab$l_fna] = 0;
			dbg$gl_logfab [fab$b_fns] = 0;
			dbg$gl_log_buf	= 0;
			dbg$gl_logfab [fab$v_nam] = 0;
			END;

		SIGNAL (shr$_openout+dbg_fac_code, 1, msg_desc, .sts, .stv);
		END;

	! restore logging status and free temp storage

	dbg$gb_def_out [out_log] = .log_temp;		
	IF .opened_log
	THEN
	
		! Cleanup the "original" NAM block

		BEGIN
		dbg$rel_memory (.old_nam_ptr);
		dbg$rel_memory (.dbg$gb_logfse);
		dbg$rel_memory (.dbg$gb_logfsr);
		dbg$gb_logfsr = .temp_fsr;
		dbg$gb_logfse = .temp_fse;

		! Release the buffer that holds the log file spec. Since this
		! is a counted string we have to adjust the address to free

		IF .fns NEQ 0
		THEN
			dbg$rel_memory(.fna-1);
		END;
	END;

ROUTINE setup_log (block_type)  =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine creates and opens the log file.
!
! FORMAL PARAMETERS:
!	block_type - indicates whether error to report is for 
!		     FAB ( = 1) or RAB ( = 2)
!
! IMPLICIT INPUTS:
!	The name of the log file to be opened
!
! IMPLICIT OUTPUTS:
!	The resultant LOG file-spec as resolved by RMS
!
! ROUTINE VALUE:
!	Returns the RMS status code if there's an error, otherwise returns TRUE
!
! SIDE EFFECTS:
!	The log file is created and a RAB connected to it.
!--

	BEGIN
	
	LOCAL 
		status;
	MAP
		dbg$gl_log_buf : REF VECTOR [,BYTE];


%IF dbg_mod2
%THEN
$fao_tt_out ('setup esa 1 !AD', .dbg$gl_lognam[nam$b_esl], .dbg$gl_lognam[nam$l_esa]);
$fao_tt_out ('rsa 1 !AD', .dbg$gl_lognam[nam$b_rsl],.dbg$gl_lognam[nam$l_rsa]);
%FI

	! See if a log file is already open

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		RETURN (TRUE);

	.block_type = 1;
	status = $CREATE(FAB = dbg$gl_logfab);

	IF NOT .status
	THEN
		RETURN (.status) ;

%IF dbg_mod2
%THEN
$fao_tt_out(' about to connect');
%FI
	dbg$gl_lograb [rab$l_fab] = dbg$gl_logfab;
	.block_type = 2;
	status = $CONNECT (RAB = dbg$gl_lograb);

%IF dbg_mod2
%THEN
$fao_tt_out(' after connect, status : !XL' , .status);
$fao_tt_out('block_type !XL' , .block_type);
%FI
	IF NOT .status
	THEN
		RETURN (.status) ;


	! Eventually put out the title line here
	RETURN (TRUE)
	END;

GLOBAL ROUTINE dbg$verify_out (parse_stg_desc) : NOVALUE =
!++
! Functional Description:
! 	Routine figures out whether or not to verify input commands by
! consulting the command input stream. It always updates dbg$gb_verptr, even
! if VERIFY is not set. This is so we can support an imbedded SET OUTPUT VERIFY
! in a command sequence
!
! Formal Parameters:
!	parse_stg_desc -- The input buffer from which we are taking commands
!
! Implicit Inputs:
!	dbg$gl_cishead : The head of the command input stream 
!	dbg$gb_verptr  : The pointer to the beginning of the command to 
!			 be verified
!
! Outputs:
!	None.
!
! Routine Value:
!	None.
!
! Side Effects:
!	An input command is "VERIFYed" (copied) to the terminal and/or log file
!--

BEGIN


MAP
	parse_stg_desc 	: REF BLOCK [,BYTE];

LOCAL
	prev_link	: REF cis$link,
	ok_to_verify,
	buf_len;

	! get address of previous link in cis

	prev_link = .dbg$gl_cishead [cis$a_next_link];

	CASE .dbg$gl_cishead[cis$b_input_type] FROM cis_dbg$input TO cis_acbuf OF
	SET
	
	[cis_dbg$input]:	ok_to_verify = FALSE;

	[cis_rab]:		IF .prev_link [cis$b_input_type] NEQ cis_inpbuf
				THEN
					ok_to_verify = TRUE
				ELSE
					BEGIN
					LOCAL pre_prev : REF cis$link;
					pre_prev = .prev_link [cis$a_next_link];
					IF .pre_prev[cis$b_input_type] NEQ cis_dbg$input
					THEN
						ok_to_verify = TRUE
					ELSE
						ok_to_verify = FALSE;
					END;

	[cis_inpbuf]:		IF .prev_link [cis$b_input_type] EQL cis_dbg$input
				THEN
					ok_to_verify = FALSE
				ELSE
					ok_to_verify = TRUE;

	[cis_acbuf]:		ok_to_verify = TRUE;

	TES;

	! buf_len is the number of characters for VERIFY to print from the
	! command input buffer

	buf_len = .parse_stg_desc[dsc$a_pointer] - .dbg$gb_verptr;

	! Exclamation point (!) is mapped as end-of-line by the lexical
	! analysers. In order to capture comments for inclusion in VERIFY
	! reporting we must check each EOL for "!".


	IF .dbg$gb_verptr [.buf_len - 1] EQL %C'!'
	AND (.parse_stg_desc [dsc$w_length] AND %X'8000') EQL 0
	THEN
		buf_len = .buf_len + .parse_stg_desc [dsc$w_length] ;

	IF  .dbg$gb_def_out [out_verify]
	AND .buf_len GTR 1
	AND .ok_to_verify
	THEN
		$fao_tt_out (' !AD',.buf_len, .dbg$gb_verptr);

	dbg$gb_verptr =  .parse_stg_desc [dsc$a_pointer];
	RETURN
	END;

END
ELUDOM
