	.TITLE	VAX$HANDLER - Condition Handlers for VAX-11 Instruction Emulator
	.IDENT	/V04-000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: 
;
;	VAX-11 Instruction Emulator
;
; Abstract:
;
;	This module contains all interfaces between the VAX-11 instruction
;	emulator and the VAX/VMS condition handling facility. That is, this is
;	the only module in the entire VAX-11 instruction emulator package that
;	has any knowledge of VMS-specific aspects of condition handling. All
;	exception knowledge contained in other modules is defined by the
;	VAX-11 Architecture (microVAX subset). If this emulator is to be used
;	in an environment other than VMS, this is the only module that needs
;	to be changed. 
;
;	Note that control flows through this module in two directions. On the
;	one hand, certain exceptions such as access violation can occur while
;	the emulator is executing. These exceptions are reported by VMS to a
;	special access violation routine in this module. These routines and
;	instruction-specific exception handling routines manipulate this
;	exception so that it appears to have occurred at the site of the
;	reserved instruction, rather than within the emulator. 
;
;	Other exceptions such as reserved operand abort for illegal decimal
;	string length or decimal overflow trap are detected by emulator
;	routines. These must be reported by the emulator to VMS, again in such
;	a way that it appears to the running code that the exception occurred
;	at the site of the reserved instruction. 
;
; Environment: 
;
;	These routines run at any access mode, at any IPL, and are AST 
;	reentrant. 
;
; Author: 
;
;	Kathleen D. Morse
;
; Creation Date
;
;	17 August 1982
;
; Modified by:
;
;	V01-005	LJK0036		Lawrence J. Kenah	17-Jul-1984
;		Fix INSV bug in REFLECT_FAULT that was causing PSL bits
;		to be incorrectly cleared.
;
;	V01-004	LJK0022		Lawrence J. Kenah	9-Feb-1984
;		Final cleanup pass. Eliminate stack switch logic. VMS now
;		transfers control here in the mode of the exception and not
;		in kernel mode. Add logic to distinguish a stack that
;		contains a signal array from a stack that also contains a
;		mechanism array and a CHF argument list. 
;
;	V01-003	LJK0019		Lawrence J. Kenah	25-Jan-1984
;		Revise the way that exceptions are handled. Eliminate code
;		that is not being used.
;
;	V01-002	LJK0002		Lawrence J. Kenah	15-Mar-1983
;		Handle software detected exceptions from decimal and EDITPC
;		emulation. Modify initial and final dispatching to use registers
;		instead of stack space for parameter passing. Include stack
;		format generated by microVAX exceptions.
;
;	V01-001	Original	Kathleen D. Morse	17-Aug-1982
;		Intercept access violations and machine checks and conditionally
;		dispatch them to emulator for modification. Reflect exceptions 
;		from emulator to regular VMS exception dispatcher.
;--

	.SUBTITLE	Declarations

; Include files:

	$CHFDEF				; Offsets into signal array
	$OPDEF				; Symbolic names for opcodes
	$PRDEF				; Get definitions of processor registers
	$PSLDEF				; Define bit fields in PSL
	$SRMDEF				; Arithmetic trap codes
	$SSDEF				; Status codes in VMS

	.NOCROSS			; No cross reference for these
	.ENABLE		SUPPRESSION	; No symbol table entries either

	STACK_DEF			; Stack storage of exception parameters
	PACK_DEF			; Stack usage for reflecting exceptions

	.DISABLE	SUPPRESSION	; Turn on symbol table again
	.CROSS				; Cross reference is OK now

; Macro definitions

	.MACRO	DELTA_PC_TABLE_ENTRY	OPCODE
	SIGN_EXTEND	OP$_'OPCODE , ...OPCODE
	.IIF	LESS_THAN <...OPCODE - OPCODE_BASE>,-
		.ERROR			; Opcode not supported by emulator
	.IIF	GREATER <...OPCODE - OPCODE_MAX>,-
		.ERROR			; Opcode not supported by emulator
		.NOCROSS
		.ENABLE		SUPPRESSION
	OPCODE'_DEF			; Register usage for OPCODE instruction
		.DISABLE	SUPPRESSION
		.CROSS
	. = DELTA_PC_TABLE_BASE + <...OPCODE-OPCODE_BASE>
	.BYTE	OPCODE'_B_DELTA_PC
	.ENDM	DELTA_PC_TABLE_ENTRY

	.MACRO	CMP_L_TO_A	SRC,DSTADR,DST,TYPE=B
	.IF	BLANK	DST
		PUSHA'TYPE	DSTADR
		CMPL	SRC,(SP)+
	.IF_FALSE
		MOVA'TYPE	DSTADR,DST
		CMPL	SRC,DST
	.ENDC		
	.ENDM

; Symbol definitions

	JSB_ABSOLUTE = <^X9F@8> ! OP$_JSB
	JSB_SIZE = 6			; Size of JSB @#VAX$xxxxxx instruction

; External declarations

	.DISABLE	GLOBAL

	.EXTERNAL	VAX$EXIT_EMULATOR	; Return PC to dispatcher

	.EXTERNAL	EXE$REFLECT	; Entry point in VMS

;;; THE FOLLOWING DECLARATIONS ARE NOT NEEDED UNLESS WE DEFINE ENTRY POINTS
;;; INTO THE EMULATOR THROUGH THE SYSTEM SERVICE VECTOR PAGES.
;;;
;;;	.EXTERNAL	SYS$VAX_BEGIN,-	; Lower and upper bounds of JSB
;;;			SYS$VAX_END	;  entry points in vector page

; Default Addressing Mode

	.DEFAULT	DISPLACEMENT , WORD

; PSECT Declarations:

;	This label defines the beginning of the emulator image

	.PSECT _VAX$$$BEGIN PIC, USR, CON, REL, LCL, SHR, EXE, RD, NOWRT, PAGE

VAX$BEGIN:

;	This label locates the end of the emulator image

	.PSECT _VAX$__END   PIC, USR, CON, REL, LCL, SHR, EXE, RD, NOWRT, BYTE

VAX$END:

	.SUBTITLE	VAX$AL_DELTA_PC_TABLE
;+
; Functional Description:
;
;	The following table contains a byte entry for each emulated 
;	instruction. That byte describes where in the saved register set the 
;	delta-PC quantity is stored in the event that the instruction is 
;	interrupted and restarted.
;-

	.PSECT _VAX$DATA    PIC, USR, CON, REL, LCL, SHR, NOEXE, RD, NOWRT, LONG

; Because the assembler does not understand sign extension of byte and
; word quantities, we must accomplish this sign extension with macros. The
; assignment statements that appear as comments illustrate the sense of the
; macro invocations that immediately follow.

;	OPCODE_BASE = OP$_ASHP		; Smallest (in signed sense) opcode

	SIGN_EXTEND	OP$_ASHP , OPCODE_BASE

;	OPCODE_MAX = OP$_SKPC		; Largest opcode in this emulator

	SIGN_EXTEND	OP$_SKPC , OPCODE_MAX

DELTA_PC_TABLE_SIZE = -
	<OPCODE_MAX - OPCODE_BASE> + 1	; Define table size

DELTA_PC_TABLE_BASE:			; Locate start of table for macro

; Initialize entire table to empty

	.BYTE	0[DELTA_PC_TABLE_SIZE]	; Lots of bytes that contain zero

; Define table entries for string instructions

	DELTA_PC_TABLE_ENTRY	MOVTC
	DELTA_PC_TABLE_ENTRY	MOVTUC
	DELTA_PC_TABLE_ENTRY	CMPC3
	DELTA_PC_TABLE_ENTRY	CMPC5
	DELTA_PC_TABLE_ENTRY	LOCC
	DELTA_PC_TABLE_ENTRY	SKPC
	DELTA_PC_TABLE_ENTRY	SCANC
	DELTA_PC_TABLE_ENTRY	SPANC
	DELTA_PC_TABLE_ENTRY	MATCHC
	DELTA_PC_TABLE_ENTRY	CRC

; Define table entries for decimal instructions

	DELTA_PC_TABLE_ENTRY	ADDP4
	DELTA_PC_TABLE_ENTRY	ADDP6
	DELTA_PC_TABLE_ENTRY	ASHP
	DELTA_PC_TABLE_ENTRY	CMPP3
	DELTA_PC_TABLE_ENTRY	CMPP4
	DELTA_PC_TABLE_ENTRY	CVTLP
	DELTA_PC_TABLE_ENTRY	CVTPL
	DELTA_PC_TABLE_ENTRY	CVTPS
	DELTA_PC_TABLE_ENTRY	CVTPT
	DELTA_PC_TABLE_ENTRY	CVTSP
	DELTA_PC_TABLE_ENTRY	CVTTP
	DELTA_PC_TABLE_ENTRY	DIVP
	DELTA_PC_TABLE_ENTRY	MOVP
	DELTA_PC_TABLE_ENTRY	MULP
	DELTA_PC_TABLE_ENTRY	SUBP4
	DELTA_PC_TABLE_ENTRY	SUBP6

; Don't forget good old EDITPC

	DELTA_PC_TABLE_ENTRY	EDITPC

; Locate the table through entry 0

VAX$AL_DELTA_PC_TABLE == DELTA_PC_TABLE_BASE + <0 - OPCODE_BASE>

; Finally, set the location counter to the end of the table

. = DELTA_PC_TABLE_BASE + DELTA_PC_TABLE_SIZE

;	The code that does useful work is put into this section.

	.PSECT _VAX$CODE    PIC, USR, CON, REL, LCL, SHR, EXE, RD, NOWRT, QUAD

	.SUBTITLE	VAX$ACVIOLAT - Modify Access Violation
;+
; Functional Description:
;
;	This routine receives control from the exception dispatcher in VMS
;	after the mechanism and signal arrays have been moved from the kernel
;	stack to the stack of the mode in which the access violation occurred.
;	This routine determines whether the exception occurred inside the
;	emulator and, if so, passes control to an instruction-specific routine
;	that performs further consistenct checks. 
;
;	The purpose of all this work is to allow exceptions that occur inside
;	the emulator to be modified before being passed on to the user. There
;	are two important pieces of this modification. 
;
;		The exception PC is changed from a PC within the emulator to
;		the PC of the instruction that caused the emulator to be
;		invoked in the first place. 
;
;		Any stack usage by the emulator is dissolved. This allows
;		the exception stack to be placed directly on top of the
;		user's stack usage, removing any overt indication that an
;		emulator is being used. 
;
;	Although the only exception that can be modified in this fashion is an 
;	access violation, the routine is written in terms of a general signal 
;	array to allow expansion at a future time.
;
; Input Parameters:
;
;	If this exception is one that the emulator is capable of modifying,
;	then R10 must contain the address of an instruction-specific routine
;	to store context information in the general registers before passing
;	control back to this module.
;
;	Although VMS places the mechanism array directly underneath the
;	argument list and, with one intervening longword, places the signal
;	array directly underneath that, these lists display general signal and
;	mechanism arrays. 
;
;		00(SP) - Return PC in VMS exception dispatcher
;		04(SP) - Argument count (always 2)
;		08(SP) - Address of signal array
;		12(SP) - Address of mechanism array
;
;	The mechanism array looks like this
;
;		00(mech) - Argument count (always 4)
;		04(mech) - Value of FP when exception occurred
;		08(mech) - Depth value (initially -3)
;		12(mech) - Value of R0 when exception occurred
;		16(mech) - Value of R1 when exception occurred
;		
;	In the general caseof an exception with M optional parameters, the
;	signal array looks like this 
;
;		00(signal) - Argument count (M+3)
;		04(signal) - Exception name
;		08(signal) - First optional parameter if M GTRU 0
;		  .
;		  .
;		4*M +  4(signal) - Last parameter if M GTRU 0
;		4*M +  8(signal) - PC of faulting instruction
;		4*M + 12(signal) - PSL at time of exception
;
;	For the case of an access violation, which has two optional
;	parameters, the signal array takes this form. 
;
;		00(signal) - Argument count (always 5)
;		04(signal) - SS$_ACCVIO
;		08(signal) - Access violation reason mask
;		12(signal) - Inaccessible virtual address
;		16(signal) - PC of faulting instruction
;		20(signal) - PSL at time of exception
;
;	The longword immediately following the exception PSL was on top of the
;	stack when the exception occurred.
;
; Output Parameters:
;
;	If the exception passes the small number of tests performed here, 
;	control is passed to the routine whose address is stored in R10
;	with the following output parameters.
;
;		R0 - Address of top of stack (value of SP) when exception occurred
;		R1 - Exception PC
;
;	R0 to R3 are saved on the stack to allow this routine and the 
;	instruction-specific routines to do useful work without juggling
;	registers.
;
;		00(SP) - Value of R0 when exception occurred
;		04(SP) - Value of R1 when exception occurred
;		08(SP) - Value of R2 when exception occurred
;		12(SP) - Value of R3 when exception occurred
;		16(SP) - Return PC in VMS exception dispatcher
;		20(SP) - Argument count (always 2)
;		24(SP) - Address of signal array
;		28(SP) - Address of mechanism array
;
;	If the tests performed here determine that the exception does not
;	fit the pattern for a candidate to be modified, control is passed
;	back to VMS with an RSB instruction.
;
; Notes:
;
;	Some of the code here assumes that it knows what a VMS exception stack
;	looks like. If it finds the stack in a different shape, it does not
;	continue. The reason is that, if VMS changes these insignificant pieces
;	of the stack, it may also change things that this routine relies on that
;	are more difficult to detect.
;-

VAX$MODIFY_EXCEPTION::
	MOVQ	R2,-(SP)		; Start with two scratch registers
	MOVAL	12(SP),R3		; R3 locates argument list
	CMPL	#2,(R3)			; Is argument count 2?
	BNEQ	20$			; Quit if not
	MOVL	CHF$L_SIGARGLST(R3),R2	; R2 locates the signal array
	MOVL	CHF$L_MCHARGLST(R3),R3	; R3 locates the mechanism array
	CMPL	#4,CHF$L_MCH_ARGS(R3)	; Is this argument count 4?
	BNEQ	20$			; Quit if not
	MOVQ	CHF$L_MCH_SAVR0(R3),-(SP)	; Save original R0 and R1
	MOVL	CHF$L_SIG_ARGS(R2),R0	; R0 contains signal argument count
	MOVL	<8-12>(R2)[R0],R1	; Get exception PC

; Check that exception PC and R10 are both within the bounds of the emulator.

	MOVAB	VAX$BEGIN,R3		; Put base address in convenient place
	CMPL	R1,R3			; Is exception PC within this limit?
	BLSSU	10$			; Quit if PC is at smaller address
	CMPL	R10,R3			; Is R10 within this limit?
	BLSSU	10$			; Quit if R10 is at smaller address

; Do the same checks with the ending address

	MOVAB	VAX$END,R3		; Put end address in convenient place
	CMPL	R1,R3			; Is exception PC within this limit?
	BGEQU	10$			; Quit if PC is too large
	CMPL	R10,R3			; Is R10 within this limit?
	BGEQU	10$			; Quit if R10 is too large

; Load R0 with the value of SP when the exception occurred

	MOVAL	<16-12>(R2)[R0],R0	; Get top of stack at time of exception
	JMP	(R10)			; Call instruction-specific routine

10$:	MOVQ	(SP)+,R0		; Restore R0 and R1
20$:	MOVQ	(SP)+,R2		; ... and R2 and R3
	RSB

	.SUBTITLE	Reserved Operand or Addressing Mode Exception
;+
; Functional Description:
;
;	This routine receives control from the emulator routines for the
;	decimal instructions or EDITPC when those routines have detected a
;	condition that requires signalling of an exception. The exception can
;	either be a reserved addressing mode fault from CVTPL or a reserved
;	operand exception, either a fault or an abort, signalled from a
;	variety of places. This  routine simply makes the stack look like the
;	stack on entry to VAX$REFLECT_FAULT and passes control to that routine
;	to perform the instruction backup in common code. 
;
; Input Parameters:
;
;	00(SP) - Offset in packed register array to delta PC byte
;	04(SP) - Return PC from VAX$xxxxxx routine
;
; Output Parameters:
;
;	R0 - Locates return PC in middle of stack
;	R1 - Contains delta PC originally stored on top of stack
;
;	00(SP) - Saved R0
;	04(SP) - Saved R1
;	08(SP) - Saved R2
;	12(SP) - Saved R3
;	16(SP) - Size of signal array (always 3)
;	20(SP) - Exception name (SS$_ROPRAND or SS$_RADRMOD)
;	24(SP) - Place holder for PC of exception
;	28(SP) - PSL of exception
;	32(SP) - Offset to delta PC byte (no longer needed)
; R0 ->	36(SP) - Return PC from VAX$xxxxxx routine
;
; Implicit Output:
;
;	This routine exits by dropping into the VAX$REFLECT_FAULT routine
;	that decides the particular form the instruction backup will take.
;
; Notes:
;
;	There are three ways that a reserved operand exception can occur.
;
;	1. Digit count of packed decimal string GTRU 31 
;
;		This is an abort where the PC points to the offending 
;		decimal or EDITPC instruction.
;
;	2. Illegal numeric or sign digit detected by CVTSP or CVTTP
;
;		An illegal numeric digit was detected by one of these 
;		instructions or an illegal sign character was detected by 
;		CVTSP. This exception is also not restartable.
;
;	3. Illegal EDITPC pattern operator
;
;		The EDITPC decoder detected an illegal pattern operator. This
;		exception stores the intermediate state in registers and may
;		be restarted.
;
;	A reserved addressing mode exception can only occur when the PC is 
;	used as the destination operand in the CVTPL instruction.
;-

	.ENABLE		LOCAL_BLOCK

VAX$RADRMOD::
	MOVPSL	-(SP)			; Store exception PSL
	CLRL	-(SP)			; Save space for the exception PC
	PUSHL	#SS$_RADRMOD		; Store exception name
	BRB	10$			; Join common code

VAX$ROPRAND::
	MOVPSL	-(SP)			; Store exception PSL
	CLRL	-(SP)			; Save space for the exception PC
	PUSHL	#SS$_ROPRAND		; Store exception name

10$:	PUSHL	#3			; Store signal array size
	PUSHR	#^M<R0,R1,R2,R3>	; Store the usual registers
	MOVL	32(SP),R1		; R1 gets delta PC offset
	MOVAL	36(SP),R0		; R0 locates the return PC
					; Drop through to VAX$REFLECT_FAULT 

	.DISABLE	LOCAL_BLOCK

	.SUBTITLE	VAX$REFLECT_FAULT - Reflect Fault to User
;+
; Functional Description:
;
;	This routine reflects a fault (such as an access violation that 
;	occurred inside the emulator) back to the user. The signal array, in 
;	particular, the exception PC, is modified to point to the reserved 
;	instruction or the JSB instruction into the emulator.
;
; Input Parameters:
;
;	R0 - Address on stack of return PC
;	R1<7:0> - Byte offset from top of stack into saved register array
;		  (R0..R3) where delta-PC will be stored if original path into
;		  emulator was through a reserved instruction exception 
;	R1<8>   - distinguishes restartable exceptions (faults) from
;		  exceptions that cannot be restarted (aborts)
;	R1<9>   - distinguishes software generated exceptions from exceptions
;		  detected by hardware, detoured through the emulator, and
;		  modified by instruction-specific routines.
;
;	Note that the condition codes in the exception PSL are significant for
;	faults, primarily to make the EDITPC illegal pattern operator
;	exception conform to the architecture. 
;
;	00(SP) - Saved R0
;	04(SP) - Saved R1
;	08(SP) - Saved R2
;	12(SP) - Saved R3
;
;	16(SP) - Number of additional longwords in signal array (called N)
;	20(SP) - Exception name 
;
;	IF N GTRU 3 THEN
;	  24(SP)             - First exception-specific parameter
;	    .
;	    .
;	  <4*<N-2> + 16>(SP) - Last exception specific parameter
;
;	<4*<N-1> + 16>(SP)   - PC of exception
;	<4*N + 16>(SP)       - PSL of exception
;
;	<4*N + 16 + 4>(SP)   - Instruction specific storage (no longer needed)
;	    .
;	    .
;	-04(R0)		     - Last longword of instruction specific storage
;
;	(R0) - Return PC from VAX$xxxxxx routine in emulator
;
; There are three possibilities for the return PC. The action of this 
; routine depends on this return PC value.
;
; Case 1. 	(R0) - VAX$EXIT_EMULATOR
;
;	This is the usual case where the emulator was entered as a result of
;	an emulated instruction exception. The signal array from the second
;	exception is put on top of the original exception array, the rest of
;	the stack is evaporated, and the exception is reflected to the user. 
;
;	The FPD bit in the exception PSL is set for those exceptions that are
;	restartable. 
;
; Case 2. 	(R0) - Address of instruction following 
;
;			JSB	@#VAX$xxxxxx
;
;	In this case, the signal array that is passed back to the user is
;	reflected has the address of the JSB instruction as the exception PC.
;	The FPD bit is ALWAYS clear. Note that it is much more difficult (if
;	not impossible) to back up an arbitrary instruction that transfers
;	control to the emulator. 
;
; Case 3. 	(R0) - Anything else
;
;	In this case, the emulator was entered in some other way. Because
;	instruction state has already been modified, it is no longer possible to
;	simply reflect the secondary exception (as we did with unrecognized
;	exceptions in routine VAX$MODIFY_EXCEPTION). We add an additional longword
;	to the signal array (VAX$_ABORT) and report this slightly modified
;	exception to the original caller without modifying the return PC. 
;-

VAX$REFLECT_FAULT::
	MOVL	(R0)+,R2		; Get return PC from stack
	CMP_L_TO_A	R2,VAX$EXIT_EMULATOR,R3
	BNEQU	NO_SIGNAL_ARRAY		; Branch if no secondary signal array

; If we drop through the branch, we are examining Case 1. We can use the signal
; array that already exists to hold the modified exception parameters.

; Case 1. 	(R0) - VAX$EXIT_EMULATOR
;
;	More Input Parameters:
;
;		04(R0) - Opcode of reserved instruction
;		08(R0) - PC of reserved instruction (old PC)
;		12(R0) - First operand specifier (no longer needed)
;		  .
;		  .
;		40(R0) - Eight operand specifier (place holder)
;		44(R0) - PC of instruction following reserved instruction 
;			 (new PC)
;		48(R0) - PSL at time of exception
;
;	Output Parameters for Case 1:
;
;		R0 through R3 restored from top of stack
;
;		00(SP) - Size of signal array (called N)
;		04(SP) - Exception name 
;
;		IF N GTRU 3 THEN
;		  08(SP)        - First exception-specific parameter
;		    .
;		    .
;		  <4*<N-2>>(SP) - Last exception specific parameter
;
;		<4*<N-1>>(SP)   - Old PC (PC of reserved instruction)
;		<4*N>(SP)       - PSL of second exception (FPD set)
;

	.ENABLE		LOCAL_BLOCK

; We need to capture the FPD information stored in R1 before that register
; is modified (or used as an index register).

	BBCC	#PACK_V_FPD,R1,10$	; Branch if FPD bit remains clear
	BBSS	#PSL$V_FPD,-
		EXCEPTION_PSL(R0),10$	; Set FPD bit in exception PSL
10$:	SUBL3	OLD_PC(R0),NEW_PC(R0),R2	; Calculate delta PC
	MOVZBL	R1,R3			; Isolate delta-PC offset in R3
	MOVB	R2,(SP)[R3]		; Store delta PC in one of R0..R3
	BBS	#PACK_V_ACCVIO,R1,20$	; Branch if more than signal array

; In this case, the signal array is located immediately underneath the
; saved register array. 

	MOVZBL	<PACK_L_SIGNAL_ARRAY+CHF$L_SIG_ARGS>(SP),R3
					; Get signal array size
	MOVAL	PACK_L_SIGNAL_ARRAY(SP)[R3],R2	
					; R2 points to exception PSL
	BRB	30$			; Rejoin common code

; In this case, there is other information on the stack between the saved
; register array and the signal array, namely a return address in VMS, an
; argument list that would have been passed to condition hanlders had the
; exception not been detoured through this code, and a mechanism array.
; All of this extra data is discarded and the exception as the modified
; stack is passed back to the VMS exception dispatcher.

20$:	MOVL	PACK_L_SIGNAL_ARRAY_POINTER(SP),R2
					; R2 locates signal array
	MOVL	CHF$L_SIG_ARGS(R2),R3	; Get signal array size
	MOVAL	CHF$L_SIG_ARGS(R2)[R3],R2
					; R2 points to exception PSL
30$:	MOVAL	EXCEPTION_PSL(R0),R1	; R1 points to original PSL

;+
; R0 - Address of VAX$_OPCDEC exception array
; R1 - Address of PSL of original VAX$_OPCDEC exception
; R2 - Address of PSL in signal array of exception being backed up
; R3 - Number of longwords in signal array
;-

	MOVL	OLD_PC(R0),-4(R2)	; This extra MOVL actually saves code!

; There are two more operations that need to be performed on the PSL that
; will appear in the signal array. These operations are only significant for
; faults. The affected PSL fields are defined to be UNPREDICTABLE in the case
; of aborts. Rather than complicate the code with unnecessary branches,
; however, the condition codes will be propogated and the TP bit will be
; cleared in all cases. 

	INSV	(R2),#0,#4,(R1)		; Copy condition codes to PSL	
	BBSC	#PSL$V_TP,(R1),40$	; Clear the TP bit

; We now move a modified signal array down the stack, from the back (PSL) end
; to the front (argument count) end. The PSL has already been moved before
; the loop executes to allow the FPD bit to get set and to make the loop
; count work correctly. 

40$:	MOVL	-(R2),-(R1)		; Move next longword
	SOBGTR	R3,40$			; Check for any more

; At the end of this loop, R1 points to what we want to report as the top of the
; stack to the VMS exception dispatcher. We store R1 on the stack following the 
; saved R0 through R3 and set the new stack pointer as part of the POPR 
; instruction.

	MOVL	R1,PACK_L_SAVED_SP(SP)	; Load new SP underneath R0..R3 array
	POPR	#^M<R0,R1,R2,R3,SP>	; Restore registers and set SP
	BRW	VAX$REFLECT_TO_VMS	; Use common exit path to VMS

; Case 2. 	(R0) - Address of instruction following 
;
;			JSB	@#VAX$xxxxxx
;
;	More Input Parameters:
;
;		There is nothing else of interest on the stack in this case.
;
;	Output Parameters for Case 2:
;
;		R0 through R3 restored from top of stack
;
;		00(SP) - Size of signal array (called N)
;		04(SP) - Exception name 
;
;		IF N GTRU 3 THEN
;		  08(SP)        - First exception-specific parameter
;		    .
;		    .
;		  <4*<N-2>>(SP) - Last exception specific parameter
;
;		<4*<N-1>>(SP)   - Address of JSB instruction
;		<4*N>(SP)       - PSL of second exception (FPD clear!)
;

;+
; This is either Case 2 or Case 3, depending on the instruction located by
; the return PC. If this is a return PC from a JSB @# into the emulator,
; then the instruction that we wish to examine lies six bytes before the
; location pointed to by R2.
;-

NO_SIGNAL_ARRAY:
	CMPW	-6(R2),#JSB_ABSOLUTE	; Is the opcode JSB @# ?
	BNEQ	UNKNOWN			; Branch if not

;;; IF WE EVER INSTALL ENTRY POINTS INTO THE EMULATOR THROUGH THE SYSTEM
;;; SERVICE VECTOR PAGE, THE FOLLOWING CHECKS CAN BE TURNED ON. THE INTENT
;;; IS THAT, LIKE SYSTEM SERVICE CALLS, THE EMULATOR REFERENCES WOULD
;;; GENERATE JSB @# VAX$xxxxxx INSTRUCTIONS TO JMP INSTRUCTIONS IN THE
;;; VECTOR PAGES. IT IS ONLY THIS SET OF JSB INSTRUCTIONS THAT WOULD BE
;;; BACKED UP ACCORDING TO METHOD 2. ALL OTHER PATHS INTO THE EMULATOR
;;; WILL GENERATE EXCEPTIONS WITH AN EXCEPTION PC INSIDE THE EMULATOR ITSELF.

;;;	MOVL	-4(R2),R2		; Get destination of JSB @#
;;;	CMP_L_TO_A	R2,SYS$VAX_BEGIN,R3	; Make lower bounds check 
;;;	BLSSU	UNKNOWN			; Branch if too small
;;;	CMP_L_TO_A	R2,SYS$VAX_END,R3	; Make upper bounds check 
;;;	BGEQU	UNKNOWN			; Branch if too large

; This is Case 2 as described above. It differs from Case 1 in two ways. There
; is no signal array on the stack underneath the stack that is overwritten.
; The FPD bit in the saved PSL is not set.

	MOVZBL	<PACK_L_SIGNAL_ARRAY+CHF$L_SIG_ARGS>(SP),R3
					; Get signal array size
	INCL 	R3			; Make loop count correct
	MOVAL	PACK_L_SIGNAL_ARRAY(SP)[R3],R2	; R2 points beyond exception PSL
	SUBL3	#JSB_SIZE,-4(R0),-8(R2)	; PC of JSB becomes exception PC
	MOVL	R0,R1			; Start writing signal array at return PC
	BRB	40$			; Join common exit at top of loop

; Case 3. 	(R0) - Anything else
;
;		This is a case where the emulator was entered in a nonstandard
;		way. This code has no way of creating an exception PC that
;		will cause the emulator to be reentered. Instead, the
;		exception is redefined to be VAX$_ABORT with the rest of the
;		original signal array comprising the exception parameters. The
;		PC is not modified so that knowledgable code in the form of a
;		condition handler could conceivably restart such an exception
;		if it knew how to reenter the emulator. 
;
;	More Input Parameters:
;
;		There is nothing else of interest on the stack in this case.
;
;	Output Parameters for Case 3:
;
;		R0 through R3 restored from top of stack
;
;		00(SP) - Size of new signal array (N + 1)
;		04(SP) - New exception name (VAX$_ABORT)
;		08(SP) - Original exception name 
;
;		IF N GTRU 3 THEN
;		  12(SP)          - First exception-specific parameter
;		    .
;		    .
;		  <4*<N-2>+4>(SP) - Last exception specific parameter
;
;		<4*<N-1>+4>(SP)   - "Anything else" (original return PC)
;		<4*N+4>(SP)       - PSL of second exception (FPD clear!)
;-

;+
; This is Case 3. The emulator was entered in some unorthodox fashion. We leave
; the exception PC alone but change the facility field in the exception name
; located in the signal array to VAX$_.
;-

UNKNOWN:
	MOVZBL	<PACK_L_SIGNAL_ARRAY+CHF$L_SIG_ARGS>(SP),R3
					; Get signal array size
	INCL 	R3			; Make loop count correct
	MOVAL	PACK_L_SIGNAL_ARRAY(SP)[R3],R2	; R2 points beyond exception PSL
	MOVL	-4(R0),-8(R2)		; Unmodified return PC is exception PC
	MOVL	R0,R1			; Start writing signal array at return PC

	BRB	40$			; Join common exit at top of loop

	.DISABLE	LOCAL_BLOCK

	.SUBTITLE	VAX$REFLECT_TRAP - Reflect Arithmetic Traps
;+
; Functional Description:
;
;	This routine receives control from the various instruction specific
;	emulator routines in order to reflect arithmetic traps back to the
;	caller. There are three arithmetic traps that can occur.
;
;	Decimal overflow
;
;		This can occur in most of the decimal instructions and EDITPC
;		when there is not enough room in the destination string to 
;		store all of the nonzero digits in the source.
;
;	Integer overflow
;
;		CVTPL can incur this exception when the input decimal string
;		converts into a longword that cannot fit into 31 bits.
;
;	Divide by zero
;
;		DIVP generates this exception when the divisor is zero.
;
; Input Parameters:
;
;	00(SP) - Arithmetic Trap Code (from $SRMDEF)
;	04(SP) - PSL on exit from VAX$xxxxxx routine
;	08(SP) - Return PC from VAX$xxxxxx routine
;
;	The return PC will determine whether an exception frame (signal array)
;	already exists or must be built. Briefly, if 08(SP) is equal to the
;	address called VAX$EXIT_EMULATOR, then the emulator was entered as
;	a result of execution of a reserved instruction and a signal array
;	already exists. If 08(SP) is anything else, then it is treated as the
;	address of an instruction following a JSB into the emulator.
;
; Implicit Input:
;
;	If 08(SP) is VAX$EXIT_EMULATOR, then the rest of the stack that is
;	relevant looks like this.
;
;	12(SP) - Opcode of reserved instruction
;	16(SP) - PC of reserved instruction
;	20(SP)
;	  .
;	  .
;	48(SP)
;	52(SP) - PC of next instruction
;	56(SP) - PSL of original exception
;
; Output Parameters:
;
;	00(SP) - Count of longwords in signal array (always equal to 3)
;	04(SP) - Signal name (modified form of trap code)
;	08(SP) - PC of next instruction 
;	12(SP) - PSL on exit from VAX$xxxxxx routine
;
; Implicit Output:
;
;	This routine passes control to EXE$REFLECT, which will eventually
;	reflect the arithmetic trap back to the user.
;-

; Insure that architectural status codes for arithmetic traps are consistent
; with the VMS status codes that they are mapped onto.

	ASSUME SS$_INTOVF EQ <SS$_ARTRES + <8 * SRM$K_INT_OVF_T>>
	ASSUME SS$_FLTDIV EQ <SS$_ARTRES + <8 * SRM$K_FLT_DIV_T>>
	ASSUME SS$_DECOVF EQ <SS$_ARTRES + <8 * SRM$K_DEC_OVF_T>>

VAX$REFLECT_TRAP::
	MOVQ	R0,-(SP)		; Get some scratch registers
	MULL3	#8,8(SP),R1		; Turn trap code into status
	ADDL2	#SS$_ARTRES,R1		; ... by adding in base status code
	MOVAB	VAX$EXIT_EMULATOR,R0	; This allows address comparisons
	CMPL	R0,16(SP)		; Compare with return PC
	BEQL	10$			; Some signal array already exists
	
;+
; This code path is taken if the emulator was entered in any way other than
; by executing one of the reserved instructions. We assume that the longword
; on the stack represents a return PC, the address of the next instruction
; that will execute.
;
;	R0 - Scratch
;	R1 - Modified Trap Code
;
;	00(SP) - Saved R0
;	04(SP) - Saved R1
;	08(SP) - Space for trap code
;	12(SP) - PSL on exit from VAX$xxxxxx routine
;	16(SP) - Return PC
;-

	MOVL	R1,8(SP)		; Store exception code
	MOVL	12(SP),R0		; Save PSL in R0 to start switch
	MOVL	16(SP),12(SP)		; Put PC into proper place
	MOVL	R0,16(SP)		; Store new exception PSL
	MOVQ	(SP)+,R0		; Restore saved R0 and R1
	PUSHL	#3			; Store size of signal array
	BRB	VAX$REFLECT_TO_VMS	; Join common exit to VMS

;+
; This code path is taken if the emulator was entered as a result of executing
; one of the reserved instructions. There is lots of extra space on the stack
; to fool around with so the juggling act exhibited by the previous block of
; code is not necessary here.
;
;	R0 - Scratch
;	R1 - Modified Trap Code
;
;	00(SP) - Saved R0
;	04(SP) - Saved R1
;	08(SP) - Initial trap code (no longer needed)
;	12(SP) - PSL on exit from VAX$xxxxxx routine
;	16(SP) - VAX$EXIT_EMULATOR (no longer needed)
;	20(SP)
;	  .
;	  .
;	56(SP)
;	60(SP) - PC of next instruction (preserved by this code)
;	64(SP) - PSL of original exception (with modified condition codes)
;
; The condition codes that were generated by the VAX$xxxxxx routine are
; stored in the exception PSL.
;-

10$:	INSV	12(SP),#0,#4,<EXCEPTION_PSL+20>(SP)
					; Store new condition codes
	MOVL	R1,<OPERAND_8+20>(SP)	; ... and modified trap code
	MOVQ	(SP)+,R0		; Restore saved registers
	MOVAB	<OPERAND_8+12>(SP),SP	; Eliminate unneeded stack space
	PUSHL	#3			; Store signal array size and ...
					;  drop through to VAX$REFLECT_TO_VMS

	.SUBTITLE	VAX$REFLECT_TO_VMS - Let VMS Reflect the Exception
;+
; Functional Description:
;
;	This routine is the common exit path to the VMS exception dispatcher.
;	It executes in three different sets of circumstances. 
;	
;    1. Software detected exceptions 
;	
;	There are several exceptions that are detected by software.
;	Exception-specific and context-specific routines build a signal array
;	om the stack. This code then passes that signal array to VMS. 
;	
;    2. Modified hardware exceptions 
;	
;	Certain forms of access violation are modified to appear as if they
;	occurred at the site of a reserved instruction rather than within the
;	emulator. Any extraneous stack storage is removed. The PC within the
;	access violation signal array is modified. This code then passes the
;	modified signal array to VMS. 
;	
;    3. All unmodified exceptions 
;	
;	Certain exceptions cause the emulator to receive control, even though
;	the exception in question will be passed intact to VMS. These include
;	exceptions caused by a random control transfer into the emulator and
;	access violations such as stack overflow that would not have occurred
;	in the first place if the reserved instructions were being executed by
;	the base machine rather than by a software emulator. 
;
; Input Parameters:
;
;	The signal array is on the stack of the access mode in which the 
;	exception occurred.
;
;		00(SP) - Number of signal array elements (called N)
;		04(SP) - Signal name (integer value)
;		08(SP) - First exception-specific parameter (if any)
;		12(SP) - Second exception-specific parameter (if any)
;		  .
;		  .
;		<8+4*N>(SP)  - Exception PC that will be reported
;		<12+4*N>(SP) - Exception PSL that will be reported
;
; Implicit Output:
;
;	Control is passed to the VMS exception dispatcher at label EXE$REFLECT.
;-

VAX$REFLECT_TO_VMS::
	JMP	G^EXE$REFLECT		; Let VMS handle this exception

	.END
