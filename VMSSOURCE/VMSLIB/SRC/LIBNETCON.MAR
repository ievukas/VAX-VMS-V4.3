.TITLE	UNS$NET_CONNECT	Make a (pass through) DECnet connection
.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: DECnet library support routines
;
; ABSTRACT:
;
;	Makes a DECnet logical link connection, possibly passing
;	through many nodes to get to some non-adjacent node.
;
; ENVIRONMENT: VMS - USER MODE
;
; AUTHOR: Mark Bramhall		 CREATION DATE: 25-Feb-1980
;
; MODIFICATION HISTORY:
;
;	V03-004		DAS0001		David Solomon		14-Apr-1984
;		Remove reference to unused RMS NOP bit, NAM$M_ROD.
;
;	V03-003		MHB0098		Mark Bramhall		10-Jan-1984
;		Handle lack of NETMBX privilege correctly.
;
;	V03-002		MHB0095		Mark Bramhall		25-Mar-1983
;		Preserve optional data with NAM$M_ROD in NAM$B_NOP.
;
;	V03-001		MHB0083		Mark Bramhall		14-Jan-1983
;		Use $PARSE to parse the "device name" specification.
;
;	V02-002		MHB0077		Mark Bramhall		 9-Jun-1981
;		Added data message buffer size for "pass through" responders.
;
;--

.SBTTL	UNS$NET_CONNECT	Make a (pass through) DECnet connection

;+
; UNS$NET_CONNECT - Make a (pass through) DECnet connection.
;
;	Makes a DECnet logical link connection, possibly using the
;	"pass through" protocol to get to a non-adjacent node.  The
;	connection can be made in either "transparent" mode (no mailbox
;	channel word argument) or "non-transparent" mode (mailbox channel
;	specified).  Note that for non-adjacent nodes (i.e., when the
;	"pass through" protocol is in use), the link mailbox is connected
;	to the adjacent node's "pass through" object type responder.
;	While most "pass through" object type responders will forward
;	interrupt messages in both directions, other DECnet generated
;	messages (especially the connection confirm/reject) are for the
;	first hop only.
;
;	Additionally, optional arguments allow for:
;
;	1) Obtaining the final node path used.
;
;	2) Obtaining the Access Control String (ACS), if any, specified
;		for the final target node.  If the final ACS is asked for,
;		it is stripped from the actual connection request, thus
;		applying the default ACS for the target node connection.
;		[Note: All intermediate connections using the "pass through"
;		protocol strip any user specified ACS and always use the
;		default ACS.]
;
;	3) If any informational, warning, and/or failure messages are
;		generated by the "pass through" protocol, they can also be
;		obtained.  As each message is generated, a user supplied
;		routine is called with a $PUTMSG message argument vector.
;		The status code used is SHR$_TEXT (shared message of simply
;		text) with the severity level set according to the message
;		type and with the facility code set to "LIB".
;
;	4) Passing a data message buffer size to any "pass through" object
;		responders.
;
;	Call format:
;
;	ret-status.wlc.v = UNS$NET_CONNECT ( device-name.rt.dx,
;					     link-chan.ww.r,
;			    ** optional **   mailbox-chan.ww.r,
;			    ** optional **   path-list.wt.dx,
;			    ** optional **   final-acs.wt.dx,
;			    ** optional **   msg-routine.fz.rp,
;			    ** optional **   buffer-size.rw.r,
;    ** "pass through" object type only **   num-hops.rb.r )
;
;	Inputs:
;
;		00(AP) = Argument count (must be 2 or greater)
;		04(AP) = Address of "device name" descriptor
;		08(AP) = Address of word for assigned DECnet channel number
;		12(AP) = Address of word for assigned mailbox channel number
;		16(AP) = Address of descriptor for resultant path list
;		20(AP) = Address of descriptor for final Access Control String
;		24(AP) = Address of routine to call with messages
;		28(AP) = Address of "pass through" data buffer size word
;	***** This argument is for the "pass through" object type only *****
;		32(AP) = Address of "number of hops" byte to pass if passing
;	***** This argument is for the "pass through" object type only *****
;
;	Outputs:
;
;		R0 = Status code
;		Word @08(AP) = Assigned DECnet channel number
;				(zero if connection failure)
;				(non-zero if "pass through" protocol failure)
;		Word @12(AP) = Assigned mailbox channel number
;				(zero if connection failure)
;				(non-zero if "pass through" protocol failure)
;		Desc @16(AP) = Resultant path list descriptor
;				(attempted connection node name if failure)
;		Desc @20(AP) = Final Access Control String descriptor
;		Rout @24(AP) = Called with a $PUTMSG message argument vector
;				for "pass through" protocol generated messages
;
;	Assumptions:
;
;		The "device name" string is of the general format
;
;			[node-list]dest-node["ACS"]::"object-type"
;
;		where <node-list> is (spaces are for clairity only!)
;
;			node-1:: [ node-2:: [ node-3:: [ ... ] ] ]
;
;		where any node name (<dest-node> and/or <node-n>) can
;		contain a leading underscore.
;-

; Argument offsets

DEV_NAME_DESC	=	 4		; Offset to "device name" descriptor
NET_CHAN_WORD	=	 8		; Offset to DECnet channel number word
MBX_CHAN_WORD	=	12		; Offset to mailbox channel number word
RSL_PATH_DESC	=	16		; Offset to resultant list descriptor
FINL_ACS_DESC	=	20		; Offset to final ACS descriptor
MSG_ROUT_ADDR	=	24		; Offset to message call routine
BUF_SIZE_WORD	=	28		; Offset to data buffer size word
NUM_HOPS_BYTE	=	32		; Offset to "number of hops" byte

; Local definitions

	$FABDEF				; FAB definitions
	$NAMDEF				; NAM definitions
	$SHRDEF				; Shared message definitions
	$STSDEF				; Status code definitions

IO_BUF_LEN	=	256		; Size of I/O buffer for protocol I/O

; Local offsets

WAIT_EFN	=	 -8		; FP offset to our Event Flag Number
RET_STATUS	=	 -4		; FP offset to saved return status

; .PSECT definition

.PSECT	_LIB$CODE	PIC, USR, CON, REL, LCL, SHR, EXE, RD, NOWRT, LONG

; Local data

DOUBLE_COLON:				; Double colon for finding a node name
	.ASCII	/::/

PASS_OBJECT:				; Pass through protocol object type
	.ASCII	'::"123=/'
	.WORD	0
10$:	.BYTE	0
	.BYTE	0 [16]
	.ASCII	'"'
PASS_OBJECT_CNT =	10$-.
PASS_OBJECT_LEN	=	.-PASS_OBJECT

NET_DEV_NAM:				; DECnet "device name"
	.ASCII	/_NET0:/
NET_DEV_NAM_LEN	=	.-NET_DEV_NAM

CREMBX_BUFQUO:				; Link mailbox buffer quota (defaults)
	.LONG	0

CREMBX_MAXMSG:				; Link mailbox max msg len (DECnet=40)
	.LONG	40

.SHOW	MEB

STRING_FETCH:				; Fetch a string's length/address
	.WORD	^M<>

	MOVAB	G^LIB$SIG_TO_RET, (FP)	; Return signals as status codes
	CALLG	(AP), G^LIB$ANALYZE_SDESC ; Go fetch string's length/address
	RET				; Return.

STRING_COPY:				; Copy a string to caller's desc
	.WORD	^M<>

	MOVAB	G^LIB$SIG_TO_RET, (FP)	; Return signals as status codes
	CALLG	(AP), G^STR$COPY_DX	; Go copy string to caller's desc
	RET				; Return.

.ENTRY	UNS$NET_CONNECT, ^M<R2,R3,R4,R5,R6,R7> ; Entry point and register mask

	CLRQ	-(SP)			; Make room for return status & EFN
ASSUME	RET_STATUS EQ -4
ASSUME	WAIT_EFN EQ -8
	CLRW	@NET_CHAN_WORD(AP)	; Pre-clear DECnet channel number word
	CLRL	R7			; Guess at no mailbox handling
	CMPB	(AP), #MBX_CHAN_WORD/4	; Do we have this argument?
	BLSSU	10$			; Nope
	TSTL	MBX_CHAN_WORD(AP)	; Yep, but was it really supplied?
	BEQL	10$			; Not really there...
	CLRW	@MBX_CHAN_WORD(AP)	; Pre-clear mailbox channel number word
	INCL	R7			;  and say we're handling a mailbox
10$:					; Continue

PARSE_STRING:				; Parse the "device name" string
	CLRQ	-(SP)			; Form a cleared descriptor
	MOVAQ	(SP), R6		;  and get a pointer to it
	MOVAL	-<NAM$C_MAXRSS+PASS_OBJECT_LEN+- ; Form connect buffer
			<4-1>&^C<4-1>>(SP), SP ;  rounded up to a longword
	MOVAB	(SP), 4(R6)		;   and save its address
	MOVAL	-<FAB$C_BLN+NAM$C_BLN>(SP), SP ; Allocate a FAB and NAM
	MOVC5	#0, (SP), #0, #FAB$C_BLN+NAM$C_BLN, (SP) ;  then clear them
	MOVAL	(SP), R2		; Address the FAB
	MOVAL	FAB$C_BLN(SP), R3	;  and the NAM
	MOVW	#<FAB$C_BLN@8>!FAB$C_BID, FAB$B_BID(R2) ; Set up the FAB
ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVAL	(R3), FAB$L_NAM(R2)	; Link the NAM to the FAB
	MOVW	#<NAM$C_BLN@8>!NAM$C_BID, NAM$B_BID(R3) ; Set up the NAM
ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVB	#NAM$M_PWD, NAM$B_NOP(R3) ; Keep password
	MOVAB	@4(R6), NAM$L_ESA(R3)	; Set expanded string address
	MOVB	#NAM$C_MAXRSS, NAM$B_ESS(R3) ;  and expanded string length
	PUSHAL	FAB$L_FNA(R2)		; Arg #3 is the returned address
	PUSHAW	FAB$B_FNS(R2)		; Arg #2 is the returned length
ASSUME	FAB$B_DNS EQ FAB$B_FNS+1
	PUSHAQ	@DEV_NAME_DESC(AP)	; Arg #1 is the "device name" desc
	CALLS	#3, STRING_FETCH	; Go fetch the string's length/address
	BSBW	LOWBIT_ELSE_DIE		; Check the completion code
	MOVL	#RMS$_NOD, R0		; Preset "Illegal node name" error
	TSTB	FAB$B_DNS(R2)		; Was the "device name" too long?
ASSUME	FAB$B_DNS EQ FAB$B_FNS+1
	BNEQ	10$			; Yes, go call it an error...
	$PARSE -			; Parse
		FAB = (R2)		;  the "device name"
	CMPL	R0, #RMS$_CHN		; Did the channel assignment fail?
	BNEQ	10$			; Nope
	MOVL	FAB$L_STV(R2), R1	; Yep, get the STV from the parse
	BEQL	10$			; None
	MOVL	R1, R0			; One, use STV as failure code
10$:	BSBW	LOWBIT_ELSE_DIE		; Check the completion code
	MOVZBL	NAM$B_NODE(R3), R4	; Form descriptor to the node name
	MOVAB	@NAM$L_NODE(R3), R5	;  part of string (to extract ACS)
	MOVZBL	NAM$B_ESL(R3), (R6)	; Set expanded string's real length
	MOVAB	@4(R6), SP		; Flush (now) unused stack space
	MOVL	#RMS$_NOD, R0		; Preset "Illegal node name" error
	CMPL	R5, SP			; Is the node name the first thing?
	BNEQ	10$			; Nope, go call it an error...

GET_FINAL_ACS:				; Extract final ACS if needed
	CMPB	(AP), #FINL_ACS_DESC/4	; Do we have this argument?
	BLSSU	30$			; Nope
	TSTL	FINL_ACS_DESC(AP)	; Yep, but was it really supplied?
	BEQL	30$			; Not really there...
	MOVQ	(R6), -(SP)		; It's there, save current desc
10$:	MOVQ	R4, (R6)		; Set new string length/pointer
	MATCHC	#2, DOUBLE_COLON, (R6), @4(R6) ; Find a node name
	MOVQ	R2, R4			; Save length/pointer past node name
	MATCHC	#2, DOUBLE_COLON, R2, (R3) ; Another node name?
	BEQL	10$			; Yes, loop...
	SUBL	R4, (R6)		; Isolate the last node name
	LOCC	#^A/"/, (R6), @4(R6)	; Find the ACS if any
	MOVQ	R0, R4			; Save descriptor of ACS
	MOVL	R0, R2			; Really an ACS?
	BEQL	20$			; Nope
	DECL	R4			; Yep, skip the leading quote in count
	INCL	R5			;  and bump pointer over it
	LOCC	#^A/"/, R4, (R5)	; Find the trailing quote
	SUBL	R0, R4			;  and remove rest of string
20$:	MOVQ	R4, (R6)		; Load descriptor of ACS
	PUSHAQ	(R6)			; Arg #2 is the src string desc
	PUSHAQ	@FINL_ACS_DESC(AP)	; Arg #1 is the dst string desc
	CALLS	#2, STRING_COPY		; Go copy final ACS to caller's desc
	MOVQ	(SP)+, (R6)		; Restore original descriptor
	BSBW	LOWBIT_ELSE_DIE		; Check the completion code
	TSTL	R2			; Really any ACS?
	BEQL	30$			; Nope
	ADDL	#2, R4			; Yep, add back in the quotes
	SUBL	R4, (R6)		;  and decrease original string's size
	DECL	R5			; Correct pointer for initial quote
	SUBL3	4(R6), R5, R2		; Find size of left half of string
	SUBL3	R2, (R6), R2		;  then size of new right half
	MOVC	R2, (R5)[R4], (R5)	; Shuffle up string...
30$:					; Continue

CHK_PASS_PROTO:				; Check for needing pass through
	PUSHAL	WAIT_EFN(FP)		; Arg #1 is the EFN return longword
	CALLS	#1, G^LIB$GET_EF	; Go allocate us an EFN
	BSBW	LOWBIT_ELSE_DIE		; Check the completion code
	CLRL	-(SP)			; Guess at a direct connection
	MATCHC	#2, DOUBLE_COLON, (R6), @4(R6) ; Find first node name
	MOVQ	R2, R4			; Save size/pointer to rest of string
	MATCHC	#2, DOUBLE_COLON, R2, (R3) ; Is there another node name?
	BNEQ	20$			; Nothing more, a direct connection
	MOVAB	-<IO_BUF_LEN-4-4>(SP), SP ; Make room for I/O buffer on stack
	CLRQ	-(SP)			; Preset number of hops to zero, etc.
	CMPB	(AP), #NUM_HOPS_BYTE/4	; Do we have this argument?
	BLSSU	10$			; Nope
	TSTL	NUM_HOPS_BYTE(AP)	; Yep, but was it really supplied?
	BEQL	10$			; Not really there...
	MOVB	@NUM_HOPS_BYTE(AP), 4(SP) ; Yep, set number of hops to far
10$:	ADDL3	#1, R4, -(SP)		; Save path list's length
	SUBL	R4, (R6)		; Take path list size from string
	MOVC5	R4, (R5), #0, #IO_BUF_LEN-1, 8+1(SP) ; Move list to I/O buffer
	SUBL	#2, (R6)		; Take the double colon from node name
	LOCC	#^A/"/, (R6), @4(R6)	; Find any ACS in node name
	SUBL	R0, (R6)		;  and take it away
	ADDL	#PASS_OBJECT_LEN, (R6)	; Update count for object type
	MOVC	#PASS_OBJECT_LEN, PASS_OBJECT, (R1) ;  and move it in
	CMPB	(AP), #BUF_SIZE_WORD/4	; Do we have this argument?
	BLSSU	20$			; Nope
	TSTL	BUF_SIZE_WORD(AP)	; Yep, but was it really supplied?
	BEQL	20$			; Not really there...
	MOVB	#2, PASS_OBJECT_CNT(R3)	; Set connect data count to two bytes
	MOVW	@BUF_SIZE_WORD(AP), PASS_OBJECT_CNT+1(R3) ;  and fill them in
20$:	PUSHAB	NET_DEV_NAM		; Form a descriptor to
	PUSHL	#NET_DEV_NAM_LEN	;  the DECnet "device name"
	MOVAQ	(SP), R0		;   and get a pointer to it
	BLBS	R7, 30$			; Are we doing a mailbox?
	$ASSIGN_S -			; Assign a channel
		DEVNAM = (R0), -	;  use the DECnet "device name"
		CHAN = @NET_CHAN_WORD(AP) ;  place channel number back here
	BRB	40$			; Go check the completion status

30$:	PUSHAW	@MBX_CHAN_WORD(AP)	; Arg #5 is the mailbox channel word
	PUSHAW	@NET_CHAN_WORD(AP)	; Arg #4 is the DECnet channel word
	PUSHAL	CREMBX_BUFQUO		; Arg #3 is the buffer quota
	PUSHAL	CREMBX_MAXMSG		; Arg #2 is the maximum message
	PUSHAQ	(R0)			; Arg #1 is the DECnet "device name"
	CALLS	#5, G^LIB$ASN_WTH_MBX	; Assign channel with a mailbox
40$:	BLBC	R0, 50$			; Go die unless success completion
	MOVAQ	(R6), R4		; Get pointer to connect information
	MOVAQ	(SP), R5		;  and a pointer to an IOSB
	$QIOW_S -			; Request connect initiate
		CHAN = @NET_CHAN_WORD(AP), - ;  on the destination
		FUNC = S^#IO$_ACCESS, -	;  using the access function
		EFN = WAIT_EFN(FP), -	;  waiting for it to complete
		IOSB = (R5), -		;  use an IOSB
		P2 = R4			;  use the connect information
	BLBC	R0, 50$			; Go die unless success completion
	MOVZWL	(R5), R0		; Get the I/O completion code
	ADDL	#8, SP			;  and pop the IOSB from stack
	CMPL	R0, S^#SS$_NORMAL	; Is it simply a success completion?
	BNEQ	50$			; Nope
	MOVZWL	#SS$_REMOTE, R0		; Yep, change to connection confirmed
50$:	MOVL	R0, RET_STATUS(FP)	; Store assign's completion code
	MATCHC	#2, DOUBLE_COLON, (R6), @4(R6) ; Find node name again
	ADDL	#2, R2			; Put double colon back into remainder
	SUBL	R2, (R6)		;  and take away all but node name
	LOCC	#^A/"/, (R6), @4(R6)	; Scan for an ACS
	SUBL	R0, (R6)		;  and take it away
	MOVW	#^A/::/, (R1)		; Add a double colon to it
	ADDL	#2, (R6)		;  and count the double colon
	BLBS	RET_STATUS(FP), 60$	; Did the channel assign make it?
	$DASSGN_S -			; Deassign a channel
		CHAN = @NET_CHAN_WORD(AP) ;  from the destination
	CLRW	@NET_CHAN_WORD(AP)	; Clear the channel number word
	BLBC	R7, EXIT		; Using a mailbox?
	$DASSGN_S -			; Deassign a channel
		CHAN = @MBX_CHAN_WORD(AP) ;  from the mailbox
	CLRW	@MBX_CHAN_WORD(AP)	; Clear mailbox channel number word
	BRB	EXIT			; Go exit

60$:	MOVL	(SP), R0		; A path list to send?
	BNEQ	DO_PASS_PROTO		; Yep, go do it

EXIT:					; Exit after clean ups
	CMPB	(AP), #RSL_PATH_DESC/4	; Do we have this argument?
	BLSSU	10$			; Nope
	TSTL	RSL_PATH_DESC(AP)	; Yep, but was it really supplied?
	BEQL	10$			; Not really there...
	PUSHAQ	(R6)			; Arg #2 is the src string desc
	PUSHAQ	@RSL_PATH_DESC(AP)	; Arg #1 is the dst string desc
	CALLS	#2, STRING_COPY		; Go copy result path to caller's desc
10$:	TSTL	WAIT_EFN(FP)		; Did we allocate us an EFN?
	BEQL	20$			; Nope
	PUSHAL	WAIT_EFN(FP)		; Arg #1 is the allocated EFN longword
	CALLS	#1, G^LIB$FREE_EF	; Go free up our EFN
20$:	MOVL	RET_STATUS(FP), R0	; Get the return status
	RET				; Return.

.ENABLE	LSB

LOWBIT_ELSE_END:			; End unless success status
	BLBS	R0, 10$			; Exit if success
	BLBC	R4, LOWBIT_ELSE_DIE	; Have we gotten any messages?
	MOVZWL	#SS$_REJECT, R0		; Yes, change into connect reject
LOWBIT_ELSE_DIE:			; Die unless success status
	BLBS	R0, 10$			; Exit if success
	MOVL	R0, RET_STATUS(FP)	; Else set the status code
	MOVZWL	@NET_CHAN_WORD(AP), R0	; Get the assigned channel number
	BEQL	EXIT			; None, just go exit
	$DASSGN_S -			; Deassign a channel
		CHAN = R0		;  from the destination
	BLBC	R7, EXIT		; Using a mailbox?
	MOVZWL	@MBX_CHAN_WORD(AP), R0	; Get the assigned mailbox channel
	BEQL	EXIT			; None
	$DASSGN_S -			; Deassign a channel
		CHAN = R0		;  from the mailbox
	BRB	EXIT			;   then go exit

10$:	RSB				; Exit

.DISABLE LSB

DO_PASS_PROTO:				; Do the pass through protocol
	MOVAQ	(SP), R5		; Get pointer to the IOSB, buffer
	$QIOW_S -			; Write the path list
		CHAN = @NET_CHAN_WORD(AP), - ;  to the destination
		FUNC = S^#IO$_WRITEVBLK, - ;  writing obviously
		EFN = WAIT_EFN(FP), -	;  waiting for it to complete
		IOSB = (R5), -		;  use an IOSB
		P1 = 8(R5), -		;  use pre-loaded I/O buffer
		P2 = R0			;   with this preset size
	BSBB	LOWBIT_ELSE_DIE		; Go check the completion code
	MOVZWL	(R5), R0		; Get the I/O completion code
	BSBB	LOWBIT_ELSE_DIE		; Go check the completion code
	CLRL	R4			; Say no messages received yet
10$:	$QIOW_S -			; Read a response
		CHAN = @NET_CHAN_WORD(AP), - ;  from the destination
		FUNC = S^#IO$_READVBLK, - ;  reading obviously
		EFN = WAIT_EFN(FP), -	;  waiting for it to complete
		IOSB = (R5), -		;  use an IOSB
		P1 = 8(R5), -		;  use the I/O buffer
		P2 = #IO_BUF_LEN	;   with its length
	BSBW	LOWBIT_ELSE_END		; Go check the completion code
	MOVZWL	(R5), R0		; Get the I/O completion code
	BSBW	LOWBIT_ELSE_END		; Go check the completion code
	MOVZWL	2(R5), R0		; Get size of response
	BEQL	10$			; No length??
	DECL	R0			; Remove status code from message size
	MOVAB	8(R5), R1		; Point to message in the I/O buffer
	MOVZBL	(R1)+, R2		;  and extract its status code
	CMPB	R2, #STS$K_SUCCESS	; Is it success?
	BEQL	30$			; We're done if success
	MOVL	#1, R4			; Else say some message(s) received
	CMPB	(AP), #MSG_ROUT_ADDR/4	; Do we have this argument?
	BLSSU	10$			; Nope
	TSTL	MSG_ROUT_ADDR(AP)	; Yep, but was it really supplied?
	BEQL	10$			; Not really there...
	TSTL	R0			; Anything to look at in the message?
	BEQL	20$			; Nope??
	CMPB	(R1), #^A/%/		; Yep, a leading percent ("%")?
	BNEQ	20$			; No leading percent, all set
	DECL	R0			; Remove the percent from the count
	INCL	R1			;  and skip the pointer over it
20$:	MOVQ	R0, -(SP)		; Put message descriptor onto stack
	PUSHAQ	(SP)			;  then stack the address of that desc
	PUSHL	#1			; FAO count is one
	BISL3	R2, -			; Use the severity level .OR.'d into
		#<LIB$_STRTRU&STS$M_FAC_NO>!- ;  a facility code of "LIB"
			SHR$_TEXT, -(SP) ;  and a general text shared message
	CALLS	#3, @MSG_ROUT_ADDR(AP)	; Call for message output ($PUTMSG)
	ADDL	#8, SP			; Clean up the stack again
	BRB	10$			;  then loop for more...

30$:	MOVQ	(R6)+, R2		; Get descriptor of connection node
	SUBL3	R2, R1, SP		; Back up stack for the node name
	MOVAB	(SP), -(R6)		; Store new address of resultant path
	ADDL	R0, -(R6)		;  and path's length
	MOVC	R2, (R3), (SP)		; Move connection node to path list
	BRW	EXIT			; Go exit...

.END

