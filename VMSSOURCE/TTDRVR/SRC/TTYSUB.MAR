	.TITLE	TTYSUB - Terminal driver miscellaneous subroutines
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES COMMON TO ALL TERMINAL DRIVER FUNCTIONS.
;
; AUTHOR:
;
;	R.HEINEN  11-AUG-1976
;
; Revision history:
;
;
;	V04-001	MIR1100		Michael I. Rosenblum	7-Sep-1984
;		Add code to catch fired hangup ast's.
;
;	V03-057	JLV0394		Jake VanNoy		13-AUG-1984
;		Change exit path in read error such that condition code is
;		is correctly on return to port driver.
;
;	V03-056	MIR0460		Michael I. Rosenblum		07-Aug-1984
;		Fix bug described in QAR 915 that points out a condition
;		Where the DMF hardware XON/XOFF handling get's out of synch
;		With the terminal driver's reconing.
;
;	V03-055	MIR0455		MICHAEL I. ROSENBLUM		20-JUN-1984
;		Add check to catch late rtimout ast's.
;		make detach cause a hangup if the line is set as such.
;
;	V03-054 RKS0054		RICK SPITZ			10-APR-1984
;		Show Physical terminal UCB redirected when associated
;		with logical TT UCB. Remove characteristics logic on rebind
;		as it is done in the connect startio I/O action code.
;
;	V03-053	MIR0390		Michael I. Rosenblum		04-Apr-1984
;		Return the offset when a readverify read terminates
;		Due to timeout.  Terminate a Read verify read if
;		it is restarted by another io also return the correct
;		offset.
;
;	V03-052 MIR0370		Michael I. Rosenblum		20-Mar-1984
;		Remove local definition of TTY$V_ST_CTSLOW.
;
;	V03-051	RKS0051		RICK SPITZ			15-MAR-1984
;
;		Cleanup modem disconnect routines and
;		add login timeout logic to modem processing.
;		Cleanup routine headers.
;
;	V03-050	RKS0050		RICK SPITZ			05-MAR-1984
;		Enhance virtual terminal timeout code to delete
;		a virtual terminal when specified time period expires.
;
;	V03-048	MIR0310		Michael Rosenblum		09-Feb-1984
;		Fix bugs.
;		Clear breakthru classes on last deassign.
;		Maintnance functions shold not always return abort.
;		Add entry point to Transition to not check modem in
;		Devdepend so that the modem can be shutdown when 
;		modem is turned off.
;
;	V03-047	MHB0100		Mark H. Bramhall		 1-Feb-1984
;		Add the setting/resetting of DEV$M_DET in DEVCHAR2 during
;		LUCB unlinks/(re-)links.
;
;	V03-046	MIR0200		Michael I. Rosenblum		15-Oct-1983
;		make calls to EXE$FORK call TTY$SYNCH to allow the terminal
;		driver to provide different synchronization methods.
;		Change input IPL to the RTIMOU routine to allow the
;		class driver to provide it's own synchronization.
;
;	V03-045	MIR0082		Michael I. Rosenblum		19-Aug-1983
;		Add argument in R0 to the PORT DISCONNECT routine.
;
;	V03-044	MIR1080		Michael I. Rosenblum		11-Aug-1983
;		remove restriction that modem state table routines must
;		be forward references.
;
;	V03-043	MIR0080		Michael I. Rosenblum		28-Jul-1983
;		Reposition the routines in the module.
;
;	V03-042	MIR0070		Michael I. Rosenblum		13-Jul-1983
;		Re-write the code that handles modem timers to allow
;		any number of lines of modem control per controler.
;		Make the UNLINK routine turn around reads with timers
;		rather than requeueing them.
;		change setup ucb to  not setup the ucb if there are
;		channels assigned.
;		Cause transition when called from the ports to turn
;		a call to INIT with channels assigned to a SHUTDOWN.
;		This will blow the processes away when a power fail
;		happens.
;
;	V03-041	MIR0051		Michael I. Rosenblum		23-Jun-1983
;		Add TTY$NOTIFY service.  Cause break on NON-autobaud terminals
;		to login.  Remove unnecessary jsb's and replace with bsbw's.
;
;	V03-040	RKS0040		RICK SPITZ			8-JUN-1983
;		ADD SUPPORT FOR CLONING DETACHED TERMINAL UCB AND LOGIC
;		TO LINK AND UNLINK LOGICAL AND PHYSICAL UCBs.
;		RESTRUCTURE CANCEL I/O CODE TO BE MORE MODULAR.
;		MOVE UCB$V_TT_HANGUP INTO LUCB (EXCEPT FOR CANCEL_RESET SPECIAL CASE).
;
;		REMOVE STOP BROADCASTS CODE SINCE THEY ARE NOW BREAKTHRU WRITES
;
;	V03-039	MIR0050		Michael	I. Rosenblum		11-May-1983
;		Remove code that specail cases broadcasts.
;		Remove TTY$STOP2
;
;	V03-038	MIR0041		Michael I. Rosenblum		29-Apr-1983
;		Add code to allow autobaud to work with parity, autoparity
;		for even parity checking.  Change autobaud code to
;		require a readable <CR> before invoking LOGINOUT.
;
;	V03-037	MIR0032		Michael I. Rosenblum		05-Apr-1983
;		Change control character echoing representation.
;
;	V03-036	MIR0031		Michael I. Rosenblum		01-Apr-1983
;		add code to disable the transmiting of characters with
;		parity errors to the user.
;
;	V03-035	RKS0035		RICK SPITZ			14-MAR-1983
;		ADD SUPPORT FOR LOGICAL UCB
;
;	V03-034	MIR8026		Michael I. Rosenblum		14-Mar-1983
;		Fix problem with initial string offsets and origional
;		cursor position
;
;	V03-033	MIR0026		Michael I. Rosenblum		01-Mar-1983
;		Clear out the size of the recall buffer when creating
;		the typeahead buffer.
;
;	V03-032	MIR0024		Michael I. Rosenblum		28-Jan-1983
;		Change code to reflect the new read buffer.
;
;	V03-031	MIR0022		Michael I. Rosenblum		18-Jan-1983
;		Move common code from port drivers into class jacket routines.
;		Change  references to UCB$B_ERTCNT to UCB$W_TT_UNITBIT to
;		allow more maintainability.
;
;	V03-030	MIR0017		Michael I. Rosenblum		05-Jan-1983
;		Move common powerfail code into this module, and change
;		the ATTENTION routine to use this common code.  Add
;		TTY$POWERACTION routine as a class survice to the port
;		drivers that will setup everything for postive action
;		when a powerfail occurs.
;
;	V03-029	MIR0015		Michael I. Rosenblum		20-Dec-1982
;		Change fork dispatching code to use state dispatch 
;		Class entry vectors:
;			CLASS_FORK - Schedules a fork interupt for the
;				     port driver
;			CLASS_DISCONNECT - Performs cleanup then delivers
;				     DCL's hangup ast.
;		Add class survice:
;			CLASS_MODEM_DIS - Forces modem shutdown transision
;		Make CLASS_DISCONNECT fork to FIPL
;		Add class jacket routines for all port functions.
;
;	V03-028 MIR0014		Michael I. Rosenblum		17-Dec-1982
;		Add CLASS_XON and CLASS_XOFF to remove some of the
;		code duplicated in all of the port drivers.
;
;	V03-027 MIR0013		Michael I. Rosenblum		16-Dec-1982
;		Fix up refferences to new ucb structure
;
;	V03-026	MIR0011		Michael I. Rosenblum		18-Nov-1982
;		Remove HOLDSCREEN code.
;		Change RESTARTIO to use new EDITREAD state and the
;		new MULTIECHO functionality.
;
;	V03-025	MIR0010		Michael I Rosenblum	9-Nov-1982
;		Moved the count of characters in the typeahead buffer
;		from the UCB into the typeahead structure.
;
;	V03-024	RKS0024		RICK SPITZ		8-NOV-1982
;		PREVENT PURGE TYPEAHEAD ROUTINE FROM DESTROYING CONTENTS
;		OF R4 (ADDRESS OF TYPEAHAED STRUCTURE)
;
;	V03-023	RKS0023		RICK SPITZ		04-OCT-1982
;		CORRECT ATTENTION ROUTINE TO CALL START OUTPUT
;		AFTER CALLING RESUME FOR BROADCAST. THIS FIXES A PROBLEM
;		WITH DMF CONTROLLERS HANGING SHUTDOWN IN MWAIT
;
;	V03-022	RKS0022		RICK SPITZ		23-SEP-1982
;		ABORT PORT OUTPUT IN MODEM HANGUP SERVICE ROUTINE.
;		THIS PREVENTS A TERMINAL IN CONTROL S STATE FROM
;		KEEPING A PROCESS RUNNING LOGINOUT AROUND UNTIL
;		NEXT CONTROL Q IS ISSUED.
;
;		MOVE LOGOUT MODEM ACTION ROUTINE CALL FROM SHUTDOWN
;		STATE TO SHUT1. THIS GUARANTEES THAT A TIMER INTERRUPT
;		OCCURS BETWEEN MODEM TRANSITION AND DELIVERY OF ANY
;		ATTENTION AST. IT IS NEEDED TO KEEP FROM
;		CALLING COM$DELATTNAST
;		AT DEVICE IPL (IN THE CASE OF CONTROLLERS WHICH
;		INTERRUPT ON MODEM TRANSITIONS).
;
;	V03-021	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF.
;
;
;--

	.SBTTL	Declarations


;
; EXTERNAL SYMBOLS
;

	$ACBDEF				; 
	$CANDEF				; DEFINE CANCEL DEFINITIONS
	$CRBDEF				; DEFINE CRB
	$IDBDEF				; DEFINE IDB OFFSETS
	$DCDEF				; DEFINE DEVICE CODES
	$DEVDEF				; DEFINE DEV STATUS AND DEVCHAR BITS
	$DPTDEF				; DEFINE DPT OFFSETS
	$DYNDEF				; DEFINE DYNAMIC REGION TYPES
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				; DEFINE IRP
	$MSGDEF				; DEFINE MESSAGE TYPES
	$PCBDEF				; DEFINE PCB
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$UCBDEF				; DEFINE UCB
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE TERMINAL CHARACTERISTICS
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$VECDEF				; DEFINE CRB VECTOR
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
	$TTYMODEM			; DEFINE TERMINAL MODEM SYMBOLS
	$TQEDEF				; TIMER QUEUE DEFINITIONS
 
	.PSECT	$$$115_DRIVER,QUAD	; DEFINE NON-PAGED PSECT

	.SBTTL	TTY$ABORT_IO - ABORT I/O 
;++
;
; TTY$ABORT_IO - Cancel I/O as a result of ABORT out-of-band.
;
; INPUTS:
;	R2 - STATE VECTOR
; 	R5 - UCB
;
;--

TTY$ABORT_IO::

	BSBW	TTY$PURGE_AHEAD		; PURGE THE TYPEAHEAD

	MOVAB	UCB$L_TT_WFLINK(R5),R1	; Get start of write queue.
	MOVL	R1,R3			; Copy it to check for end.
30$:
	MOVL	TTY$L_WB_FLINK(R3),R3	; Get next entry.
	CMPL	R3,R1			; At end of queue?
	BEQL	50$			; Yes. Branch forward.
	MOVL	TTY$L_WB_IRP(R3),R4	; Get associated IRP address.
	BEQL	30$			; If no IRP, it's a broadcast,
					; leave it in the queue.
	MOVL	TTY$L_WB_BLINK(R3),R3	; Get entry's backward link.
	REMQUE	@TTY$L_WB_FLINK(R3),R4	; Remove the link.
	BSBW	TTY$WRITEPOST		; Queue it for completion
	BRB	30$			; Try for next link.

50$:					; Stop the current I/Os.
	IF_NOT_STATE -			; Branch forward if no read is
		READ,60$		; currently in progress.
	CLR_STATE -			; Clear escape bits.
		<ESC,BADESC>
	MOVL	UCB$L_SVAPTE(R5),R3	; GET THE PACKET ADDRESS
	MOVL	UCB$L_IRP(R5),R4	; Get address of IRP.
	IF_STATE EOL,55$		; IF END OF LINE THEN ALREADY SUBTRACTED
	MOVZBW	IRP$L_MEDIA+2(R4),R1	; GET THE LENGTH OF THE TERMINATOR
	SUBW	R1,TTY$W_RB_TXTOFF(R3)	; AND FIXUP THE COUNT
55$:
	CLRL	IRP$L_MEDIA(R4)		; Clear terminators.
	BSBW	TTY$READONE		; Complete the read.

60$:					; Check for a write to complete.
	TSTW	UCB$W_TT_MULTILEN(R5)	; Test for non-zero
	BEQL	65$			; Skip if zero
	SET_STATE MULTI			; Set multiecho here because
					;  READONE will clear it if called
65$:	IF_NOT_STATE -			; Branch forward if no write is
		WRITE,70$		; in progress.
	BSBW	TTY$ABORT		; Abort any current output activity
	BSBW	TTY$RESUME		; Restart output
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write packet.
	MOVW	UCB$W_BOFF(R5),-	; Put status code in the
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete the I/O.

70$:					; And echo the control char.
	RSB

	.SBTTL	TTY$AUTOBAUD -  SENSE AND SET BAUD RATE 

;++
; TTY$AUTOBAUD - Sense and Set baud rate 
;
; Functional description:
;
; This routine is called from the TTYCHARI module when a job controller  
; character has been detected. It assumes the character typed was a carriage
; return. The default sampling speed is 9600. If the terminal is set at baud
; rates 1200 - 9600, the algorithm will detect the proper baud rate on one
; character and set to it. If the baud rate is other than that, READERROR will
; detect a framing error and set the sampling rate to 600. A second carriage
; return then sampled at 600 baud can map the 50-600 baud range. Using the 9600
; or 600 baud table the algorithm matches the character read to a specific baud
; rate. No split speed detection is allowed. 
;
; Inputs:
;
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	Baud rate can change.
;	R3 will be changed to <CR>, or a space
;	R4 is destroyed.
;	R5 is preserved.
;--

TTY$AUTOBAUD::

	CMPL	UCB$L_TT_RDUE(R5),-
		G^EXE$GL_ABSTIM		; compare to current
	BEQL	50$			; branch if too soon

	BBCC	#7,R3,10$		; Clear high order bit

; check baud rate

10$:	MOVAB	TTY$AB_9600,R4		; set 9600 baud table
	CMPB	#TT$C_BAUD_9600,UCB$W_TT_SPEED(R5) ; speed at 9600 ?
	BEQL	20$			; branch if yes

	MOVAB	TTY$AB_600,R4		; set 600 baud table
	CMPB	#TT$C_BAUD_600,UCB$W_TT_SPEED(R5) ; speed at 600 ?
	BEQL	20$			; branch if no

	MOVZBL	#TT$C_BAUD_9600,R4	; Wrong baud baud rate for sampling
	BSBW	SET_SPEED		; Set to 9600
	BRB	50$			; Exit

; now test character

20$:	CMPB	R3,(R4)+		; input same as table ?
	BEQL	30$			; branch to set speed if yes
	INCL	R4			; increment past baud rate
	TSTB	(R4)			; end of list
	BGEQ	20$			; loop if >= 0
	BRB	50$			; no match

; Set speed, zero speed+1 to indicate not split speed

30$:	MOVZBW	(R4),R4			; set baud rate
	BSBB	SET_SPEED		; Set line speed

	BICW	#UCB$M_TIM,UCB$W_STS(R5) ; Clear timeout expected
	CLR_STATE <AUTOP>		; Clear AUTOBAUD pending
	MOVZBL	#TTY$C_CR,R3		; Set carriage return as input
	MOVL	G^EXE$GL_ABSTIM,-
		UCB$L_TT_RDUE(R5)	; Set time this path taken

40$:
;
; No appropriate mapping was found, make sure that character isn't a terminator
;
50$:	MOVZBL	#TTY$C_BLANK,R3		; Invalidate character
	RSB

SET_SPEED:
	MOVZBW	R4,UCB$W_TT_SPEED(R5) 	; set speed, zero out speed+1
	BSBW	TTY$SET_LINE		; Set line speed
	RSB				; Return

	.SBTTL	TTY$CANCELIO - CANCEL I/O ON TERMINAL

;++
; TTY$CANCELIO - CANCEL I/O, DEASSIGN, AND DEALLOCATE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO STOP CURRENT I/O  ON A TERMINAL UNIT.
;
; THE ASSOCIATED CHANNEL'S READ OR WRITE I/O IS CANCELED ALONG WITH
; A FLUSH OF CONTROL-C AST REQUESTS. 
; IF THIS OPERATION IS DONE ON A UNIT WITH A ZERO REFERENCE COUNT, THE CONTROL
; Y ASTS ARE FLUSHED, THE TYPEAHEAD BUFFER IS DEALLOCATED AND THE UNIT
; IS INITIALIZED FOR THE NEXT USER.
;
; This routine always clears the control-O state bit, and also clears
; the control-S state bit if the UCB reference count is zero.
;
; INPUTS:
;
;	R2 = NEGATIVE OF THE CHANNEL NUMBER
;	R3 = CURRENT I/O PACKET ADDRESS
;	R4 = PCB OF CANCELING PROCESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R4,R5 ARE PRESERVED
;--

TTY$CANCELIO::				; CANCELIO TTY USAGE
	MOVL	R2,R3			; SAVE THE CHANNEL NUMBER
	BSBW	TTY$LOCK		; SETUP IPL AND REGISTERS

	PUSHR	#^M<R4,R6,R7,R9>
	MOVL	R3,R6			; COPY CHANNEL NUMBER
	MOVL	UCB$L_IRP(R5),R3	; GET THE CURRENT IRP
	MOVL	R5,R9			; SAVE LOGICAL UCB ADDRESS
	MOVL	UCB$L_TL_PHYUCB(R5),R5	; GET THE PHYSICAL UCB
	BNEQ	5$			; CHECK AGAIN AFTER LOCKING THE DAT BASE
	BRW	CANCEL_DETACH
5$:	PUSHAB	CANCEL_DONE		; EXIT TO HERE WHEN FINISHED
;
; Empty the write queue.
;

	MOVAB	UCB$L_TT_WFLINK(R5),R1	; Get first buffer in queue.
	MOVL	R1,R7			; Copy buffer address.

10$:					; Empty write queue.
	MOVL	TTY$L_WB_FLINK(R7),R7	; Get next buffer.
	CMPL	R7,R1			; Is this the end of queue?
	BEQL	40$			; Yes. Branch past loop.
	MOVL	TTY$L_WB_IRP(R7),R0	; Get address of associated IRP.
	BEQL	10$			; Branch if broadcast buffer
					; (leave these in queue).
	BBS	#IRP$V_VIRTUAL,-	; Don't dequeue virtual I/O
		IRP$W_STS(R0),10$	; packet.
	CMPL	IRP$L_PID(R0),-		; Compare packet's PID with
		PCB$L_PID(R4)		; current process' PID.
	BNEQ	10$			; No match. Go to next packet.
	CMPW	R6,IRP$W_CHAN(R0)	; Does the channel match?
	BNEQ	10$			; No. Go to next packet.
	BBC	#IRP$V_BUFIO,-		; Branch on direct I/O.
		IRP$W_STS(R0),20$
	BICW	#IRP$M_FUNC,-		; Otherwise, clear function of
		IRP$W_STS(R0)		; buffered I/O.

20$:					; Set up I/O completion.
	MOVZWL	#SS$_CANCEL,-		; Return CANCEL error status
		UCB$W_BOFF(R5)		; code.
	PUSHL	R4			; Save R4
	MOVL	TTY$L_WB_BLINK(R7),R7	; Get backward link.
	REMQUE	@TTY$L_WB_FLINK(R7),R4	; Remove buffer from queue.
	BSBW	TTY$WRITEPOST		; QUEUE IT FOR COMPLETION
	POPL	R4			; Restore R4
	BRB	10$			; Get next buffer in queue.

;
; See if a read is in progress. Cancel it if it was initiated by the
; canceling process.
;

40$:
	
					; Check for read in progress.
	BBC	#UCB$V_BSY,-		; Branch if no read in progress.
		UCB$W_STS(R9),50$
	CMPL	PCB$L_PID(R4),IRP$L_PID(R3); PID MATCH?
	BNEQ	50$			; Branch if no match.
	CMPW	R6,IRP$W_CHAN(R3)	; CHANNEL MATCH?
	BNEQ	50$			; Branch if no match.
	IF_NOT_STATE -			; Proceed if this is not a read.
		READ,50$
	CLR_STATE -			; Clear escape bits.
		<ESC,BADESC>
	PUSHR	#^M<R4>			; Save the PCB address.
	MOVL	UCB$L_IRP(R5),R4	; Get address of IRP.
	CLRL	IRP$L_MEDIA(R4)		; Clear terminators.
	MOVZWL	#SS$_ABORT,-		; Set up abort status code.
		UCB$W_BOFF(R5)
	BSBW	TTY$READONE		; Complete the read.

45$:					; Remember to restore register.
	POPR	#^M<R4>			; Restore PCB address.

50$:					; Check for a write in progress.
	IF_NOT_STATE -			; If no write request is in
		WRITE,60$		; progress, branch.
	MOVL	UCB$L_TT_WRTBUF(R5),R7	; Get address of write buffer.
	MOVL	TTY$L_WB_IRP(R7),R0	; Get associated IRP.
	BEQL	60$			; no irp then don't cancel
	CMPL	IRP$L_PID(R0),-		; See if packet's PID matches
		PCB$L_PID(R4)		; process' PID.
	BNEQ	60$			; Branch if no match.
	CMPW	R6,IRP$W_CHAN(R0)	; See if channels match.
	BNEQ	60$			; No. Don't stop this write.
	BSBW	TTY$ABORT		; Abort any current output activity
	MOVZWL	#SS$_ABORT,-		; Set abort status in the
		UCB$W_BOFF(R5)		; UCB status word.
	PUSHR	#^M<R4>			; Save the PCB address.
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write packet.
	MOVW	UCB$W_BOFF(R5),-	; Put status code in the
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete the I/O.
	POPR	#^M<R4>			; Restore PCB address.

;
;	PROCESS CONTROL AND OUT OF BAND ASTS
;

60$:	BSBW	CANCEL_AST		; CANCEL OUTSTANDING ASTS

;
; SEE IF THIS IS THE LAST DEASSIGN
;
	TSTW	UCB$W_REFC(R9)		; REF COUNT 0?
	BNEQ	65$


	BICB	#UCB$M_TIM,UCB$W_STS(R9); RESET HANGUP TIMER IN LUCB

	BBSC	#TTY$V_SX_RECONNECT,-
		UCB$Q_TT_STATE(R5),70$

	BSBW	CANCEL_MODEM		; SIGNAL HANGUP IF NEEDED
	BSBW	CANCEL_RESET		; RESET PHYSICAL UCB
65$:
	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS
	CLR_STATE	<CTRLO>		; Clear control-O state always.
	BRW	TTY$STARTOUTPUT		; RESTART ANY STOPPED OUTPUT


70$:
	PUSHL	R4			; PRESERVE R4
	MOVL	#TTY$V_FD_LINK,R4	; SCHEDULE LINK FORK FUNCTION
	BSBW	TTY$CRE_FORK
	POPL	R4
	RSB


;
;	CANCEL CONTROL AND OUT OF BAND ASTS
;
;	INPUTS:	R9 - LUCB
;

CANCEL_AST:
;
; RELEASE THE CONTROL C AST BLOCKS
;
	MOVAB	UCB$L_TL_CTRLC(R9),R7	; ADDRESS THE CONTROL C ENABLE LIST 
	CLRL	R2			; SPECIFY NULL MASK
	JSB	G^COM$FLUSHATTNS	; FLUSH THE LIST
;
; FLUSH OUT OF BAND ASTS
;
	MOVAB	UCB$L_TL_BANDQUE(R9),R7	; ADDRESS THE OUT OF BAND LIST
	MOVAL	UCB$L_TL_OUTBAND(R9),R2	; GET CURRENT SUMMARY MASK
	JSB	G^COM$FLUSHCTRLS	; DO IT
;
; FLUSH CONTROL Y AST QUEUE
;
	CMPW	R8,#CAN$C_DASSGN	; IS THIS A DEASSIGN?
	BNEQ	10$			; NO, SKIP
	MOVAB	UCB$L_TL_CTRLY(R9),R7	; ADDRESS LIST HEAD FOR CONTROL Y ENABLE
	CLRL	R2			; SPECIFY NULL MASK
	JSB	G^COM$FLUSHATTNS	; FLUSH LIST
	CLRL	UCB$L_TL_CTLPID(R5)	; RESET CONTROLLING PID
10$:
	RSB




;
;	PROCESS CANCEL FOR DETACHED LOGICAL UCB.
;	THIS ROUTINE CANCELS ANY INTERNAL STRUCTURES FOR
;	A DETACHED LUCB.
;
;	INPUTS:	R9 - LUCB
;

CANCEL_DETACH:
	MOVL	R9,R5			; RESTORE LOGICAL UCB ADDRESS
	BSBW	CANCEL_AST		; PROCESS OUTSTANDING CONTROL ASTS
	TSTW	UCB$W_REFC(R5)		; CHECK FOR LAST DEASSIGN
	BNEQ	10$
	BICB	#UCB$M_TIM,UCB$W_STS(R9); RESET HANGUP TIMER IN LUCB
	CLRL	UCB$L_DUETIM(R9)	; RESET HANGUP TIMEOUT VALUE IN LUCB
	MOVL	UCB$L_PDT(R5),R0	; CHECK FOR PENDING REBIND FUNCTION
	BEQL	10$			; NONE
	CLRL	UCB$L_PDT(R0)		; SIGNAL THAT THIS UCB IS DELETED
10$:	POPR	#^M<R4,R6,R7,R9>	; Restore registers.
	RSB				; RETURN





CANCEL_DONE:
	MOVL	R9,R5			; RESTORE LOGICAL UCB ADDRESS
	POPR	#^M<R4,R6,R7,R9>	; Restore registers.
	RSB				; RETURN




;
;	FINAL MODEM PROCESSING FOR LAST DEASSIGN
;
;
;	INPUTS:	R5 - PUCB
;
CANCEL_MODEM:

;
; CHECK FOR HANGUP  
;
	BBC	#TT2$V_HANGUP,-
		UCB$L_DEVDEPND2(R5),15$	; BRANCH IF LOGOUT/NOHANGUP
	BSBW	CLASS_MODEM_DIS		; RESET SPEED AND UCB
15$:

;
; CHECK FOR NEED TO REACTIVATE MODEM PROCESSING
;

	BBS	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),20$	; CURRENT STATE IS MODEM
	BBC	#TT$V_MODEM,UCB$L_TT_DECHAR(R5),25$	; NO CHANGE
	MOVZBL	#MODEM$C_INIT,R1			; NEED TO RESTART MODEM
	BSBW	TRANSITION
	BRB	25$

20$:
	BBS	#TT$V_MODEM,UCB$L_TT_DECHAR(R5),25$	; NO CHANGE
	MOVZBL	#MODEM$C_SHUTDWN,R1			; SHUT DOWN MODEM
	BSBW	TRANSITION
25$:
	RSB


;
;	RESET PHYSICAL UCB AND MAKE IT AVAILABLE FOR FUTURE USE
;
;
;	INPUTS:	R5 - PUCB
;
CANCEL_RESET:

	BICW	#UCB$M_TT_HANGUP,UCB$W_DEVSTS(R5); RESET HANGUP FLAG
						; NOTE THIS IS CORRECTLY REFERENCED IN THE PUCB HERE
						; BUT IS NORMALLY MANIPULATED IN THE LUCB
;
;	DELETE TYPEAHEAD BUFFER
;
	MOVL	UCB$L_TT_TYPAHD(R5),R0	; GET ADDRESS OF TYPE AHEAD
	BEQL	10$			; NONE
	CLRL	UCB$L_TT_TYPAHD(R5)
	JSB	G^COM$DRVDEALMEM	; DEALLOCATE TYPE AHEAD BUFFER
10$:	BSBW	TTY$PURGE_AHEAD		; PURGE TYPE AHEAD BUFFER
	
;
; SET UP DISCONNECT SIGNAL TYPE FOR PORT
;
	MOVL	#1,-(SP)		; INDICATE NOHANGUP
	BBC	#TT2$V_HANGUP,-
		UCB$L_DEVDEPND2(R5),15$	; BRANCH IF LOGOUT/NOHANGUP
	CLRL	(SP)			; ASSUME HANGUP
15$:
					; OF LAST DEASSIGN 
;
; RESTORE PERM CHARACTERISTICS
;

	CLRQ	UCB$Q_TL_BRKTHRU(R5)	; RESET ALL THE BREAKTHRU CLASSES
	BSBW	TTY$SETUP_UCB		; SETUP UCB FIELDS, AND RESET PUCB

	MOVL	G^EXE$GL_ABSTIM,-
		UCB$L_TT_RDUE(R5)   	; SET TIME TO "TURN OFF" AUTOBAUD
	BSBW	TTY$SET_LINE		; RESET SPEED AND UCB

	BBCC	#UCB$V_JOB,UCB$W_DEVSTS(R5),30$; RESET JOB CONTROLLER OWNERSHIP BIT
30$:	
	MOVW	UCB$W_TT_PRTCTL(R5),-(SP); SAVE THE PORT CONTROL WORD
	BICW	#TTY$M_PC_XOFENA,UCB$W_TT_PRTCTL(R5); MAKE SURE THAT THE CONTROL
					; AND THE DRIVER AGREE ON XOFF SETTING
	BSBW	TTY$RESUME		; CONTINUE ANY PORT OUTPUT
	MOVW	(SP)+,UCB$W_TT_PRTCTL(R5)

	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS
	CLR_STATE	<CTRLO>		; Clear control-O state always.

	POPL	R0			; GET HANGUP INFO AS ARGUMENT TO
	BSBW	TTY$DISCONNECT		; INFORM THE PORT
	RSB



	.SBTTL	TTY$SETUP_READ - Set up UCB and states for a read

;++
; TTY$SETUP_READ - get ready to initiate a read operation
;
; Functional description:
;
;	This routine copies IRP fields into the UCB, disables mailbox,
;	sets up a timed-out read, cancels control-O, purges the type
;	ahead buffer, etc. as instructed by the IRP.
;
;	This routine is called by both TTY$STARTIO to start a read, and
;	TTY$RESTARTIO to restart a read after a powerfailure or after
;	a write completes.
;
; Inputs:
;
;	R2	- address of the UCB state bits
;	R3	- address of the IRP
;	R5	- address of the UCB
;
; Outputs:
;
;	R0, R2, R3, and R5 must be preserved.
;
;	R1,R4 destroyed.
;
;--

TTY$SETUP_READ::
	MOVL	IRP$L_SVAPTE(R3),R4	; Get buffered block address.
	MOVW	UCB$W_TT_CURSOR(R5),-	; Save the current cursor
		TTY$W_RB_CPZORG(R4)	; position.

;
; Check to see if mailbox should be disabled.
;

	CMPB	TTY$A_RB_PRM(R4),#TTY$C_CR; IS THE FIRST CHARACTER A <CR>
	BNEQ	5$			; NO THEN LEAVE CPZORG HERE
	CLRW	TTY$W_RB_CPZORG(R4)	; ELSE ZERO THE CURSOR POSITION
5$:	BBC	#IO$V_DSABLMBX,-	; Branch forward if disable
		IRP$W_FUNC(R3),10$	; mailbox not requested.

	MOVL	UCB$L_TT_LOGUCB(R5),R1	; GET LUCB ADDRESS
	BISL	#TT$M_MBXDSABL,UCB$L_DEVDEPEND(R5)
	BISL	#TT$M_MBXDSABL,UCB$L_DEVDEPEND(R1)
;
; Set up read with time out if necessary.
;
10$:
	BBC	#IO$V_TIMED,-		; Branch forward if read with
		IRP$W_FUNC(R3),30$	; timeout not requested.
	MOVL	TTY$A_MAXTIME,-		; Assume zero second timeout
		UCB$L_TT_RDUE(R5)	; (meaning just empty typeahead
					; buffer into read buffer).
	MOVZWL	TTY$W_RB_TIMOS(R4),R4	; Get number of seconds to wait
					; between each character.
	BEQL	20$			; Branch if none.
	ADDL3	R4,G^EXE$GL_ABSTIM,-	; Calculate and store the due
		UCB$L_TT_RDUE(R5)	; time.

20$:
	BISW	#UCB$M_TT_TIMO,-	; Set the "this is a read with
		UCB$W_DEVSTS(R5)	; timeout" bit.

;
; Always turn off control-O state.
;

30$:
	CLR_STATE -			; Always clear control-O state.
		<CTRLO>

;
; Handle a readsync terminal.
;

	BBC	#TT$V_READSYNC,-	; Branch forward if terminal is
		UCB$L_DEVDEPEND(R5),40$	; not in readsync mode.
	IF_STATE -			; If in EOL state, don't issue
		<TYPFUL,EOL>,40$	; an XON code.
	BSBW	TTY$XON			; Send XON

40$:
	RSB				; Return to caller.

	.SBTTL	TTY$NOTIFY - NOTIFY JOB CONTROLER OF LOGIN IF NECESSARY
;++
; TTY$NOTIFY - NOTIFY THE JOB CONTROLER OF LOGIN PENDING IF NECESSARY
;
; FUCNTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL VALIDATE A REQUEST TO NOTIFY THE JOB CONTROLLER
; OF A LOGIN REQUEST. IF THERE IS A TYPEAHEAD BUFFER, THE JOB CONTROLER 
; HAS NOT ALREADY BEEN NOTIFIED AND TERMINALS ARE ENABLED A FORK IS
; QUEUED TO PERFORM THE FUNCTION.
;
; INPUTS:
;
;	R5 = PHYSICAL UCB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS SAVED
;--
TTY$NOTIFY::
	PUSHL	R0			; SAVE A SCRATCH REGISTER
	BBS	#TT$V_NOTYPEAHD,UCB$L_DEVDEPEND(R5),100$; IF SLAVED TERMINAL, IGNORE CHARACTER
	MOVL	UCB$L_TT_LOGUCB(R5),R0	; GET LOGICAL UCB ADDRESS
	TSTW	UCB$W_REFC(R0)		; UNIT REF COUNT 0?
	BEQL	10$			; IF EQL THEN JOB CONTROLLER POSSIBILITY
	TSTL	UCB$L_AMB(R0)		; USER ASSOCIATED MAILBOX?
	BEQL	100$			; IF EQL THEN NO
	BBS	#TT$V_MBXDSABL,UCB$L_DEVDEPEND(R5),100$; BR IF NOT ENABLED
	BBS	#UCB$V_TT_NOTIF,UCB$W_DEVSTS(R5),100$; BR IF ALREADY NOTIFIED
	BRB	15$			; CONTINUE IN COMMON
10$:	BBS	#UCB$V_JOB,UCB$W_DEVSTS(R5),100$; IF ALREADY NOTIFIED THEN GO
	BBS	#DEV$V_SPL,UCB$L_DEVCHAR(R5),100$;IGNORE IF DEVICE IS SPOOLED
	MOVAB	G^OPA$UCB0,R0		; ADDRESS CONSOLE UCB
	CMPL	R0,R5			; IS THIS THE CONSOLE
	BEQLU	15$			; IF EQL THEN SKIP TERMINAL ENABLED TEST
	TSTW	G^SYS$GL_JOBCTLMB+UCB$W_DEVSTS; TERMINALS ENABLED FOR JOBCTLR?
	BLEQ	100$			; IF LEQ THEN DISMISS
15$:	PUSHR	#^M<R3,R4>		; SAVE THESE REGISTERS OVER THE FORK
	MOVL	#TTY$V_FD_UNSOL,R4	; ASK FOR UNSOLICITED DATA FORK
	BSBW	TTY$CRE_FORK		; FORK TO SEND MESSAGE
20$:	POPR	#^M<R3,R4>
	
100$:	POPL	R0
	RSB

	.SBTTL TTY$PURGE_AHEAD - PURGE TYPEAHEAD BUFFER 

;++
; TTY$PURGE_AHEAD - PURGE THE CONTENTS OF THE TYPEAHEAD BUFFER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RESETS THE TYPEAHEAD BUFFER POINTERS TO REFLECT NO 
; DATA PRESENT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R4 = ADDRESS OF TYPEAHEAD BUFFER STRUCTURE
;	R2,R3,R5 ARE PRESERVED.
;--

TTY$PURGE_AHEAD::			; PURGE TYPEAHEAD
	MOVL	UCB$L_TT_TYPAHD(R5),R4	; GET TYPE AHEAD BUFFER ADDRESS
	BEQL	55$			; IF EQL THEN NONE
	CLRW	TTY$W_TA_INAHD(R4)	; SET NO DATA IN TYPEAHEAD BUFFER
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_PUT(R4); RESET PUT POINTER
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_GET(R4); RESET GET POINTER
50$:	BBCC	#TTY$V_ST_TYPFUL,4(R2),55$; TYPE AHEAD FULL AND INPUT STOPPED?
	CLR_STATE <OVRFLO>		; RESET OVERFLOW CONDITION
	BSBW	TTY$XON			; SEND XON
55$:	RSB

	.SBTTL	TTY$READERROR - Line error occured.
;++
; TTY$READERROR - READ ERROR OCCURED ON LINE
;
; Functional description:
;
; This routine is called from a terminal port driver to report
; a read error on a line. It completes the read with error in the
; event a read is active, or just returns if no read is active.
;
; Inputs:
;
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	R0,R1,R2,R3 are destroyed.
;	R4,R5 are preserved.
;--
	.ENABLE	LSB

TTY$READERROR::
	PUSHR	#^M<R0,R4>			; SAVE REGISTERS
	MOVZWL	#SS$_PARITY,R4			; ASSUME PARITY
	MOVAB	UCB$Q_TT_STATE(R5),R2		; ADDRESS STATE DATA
	BBS	#12,R3,10$			; BRANCH IF PARITY ERROR
	BBS	#13,R3,TTY$FRAMERROR		; BRANCH IF FRAME ERROR
	MOVZWL	#SS$_DATAOVERUN,R4		; OVERUN ERROR
10$:	MOVL	UCB$L_TT_LOGUCB(R5),R1		; Get logical UCB  address
	TSTW	UCB$W_REFC(R1)			; Terminal in use ?
	BNEQ	12$				; Branch if yes
	BBC	#TT2$V_AUTOBAUD,UCB$L_DEVDEPND2(R5),12$; Check AUTOBAUD
	CMPB	#TTY$C_CR,R3			; IS THIS CHARACTER A <CR>
	BEQL	11$				; YES THEN DO AUTOPARITY
	BSBW	TTY$AUTOBAUD			; YES THEN JUMP THERE
	BRW	15$				; RETURN TO THE USER

11$:	BBCC	#UCB$V_TT_PARTY,UCB$B_TT_PARITY(R5),70$; CLEAR PARITY
	BBS	#UCB$V_TT_USERFRAME,UCB$B_TT_PARITY(R5),70$; DON'T CHANGE THE FRAME SIZE
						; IF THE USER SPECIFYED IT.
	BISB	#UCB$M_TT_LEN,UCB$B_TT_PARITY(R5); SET EIGHT BIT FRAME SIZE
70$:	BSBW	TTY$SET_LINE			; THEN TELL THE PORT
	BRW	15$				; NOW EXIT

12$:	IF_NOT_STATE	READ,90$		; SKIP IF NO READ ACTIVE
	BBC	#UCB$V_TT_DISPARERR,UCB$B_TT_PARITY(R5),13$
	CMPL	R4,#SS$_PARITY			; IS THIS A PARITY ERROR
	BEQL	15$				; YES THEN IGNORE IT
13$:	MOVW	R4,UCB$W_BOFF(R5)		; SET ERROR CODE TO RETURN
	BSBW	TTY$READONE			; COMPLETE THE REQUEST
	BRB	15$

90$:	CMPL	R4,#SS$_DATAOVERUN		; IS THIS A DATA OVERRUN
	BNEQ	15$				; NO THEN EXIT
	SET_STATE <TYPFUL,OVRFLO>		; YES THEN MAKE SURE IT
						; IS SIGNALED
15$:
	POPR	#^M<R0,R4>			; RESTORE REGISTERS
	CLRB	UCB$B_TT_OUTYPE(R5)		; ASSUME NO CHARACTER TO OUTPUT
	TSTB	R3				; TEST FOR DATA
	BEQL	16$				; BRANCH IF ZERO
	MOVB	#1,UCB$B_TT_OUTYPE(R5)		; SET CHARACTER VALID
16$:	RSB					; RETURN TO PORT

18$:
	MOVZWL	#SS$_PARITY,R4			; SET ERROR TYPE
	BBC	#TT$V_PARITY,-
		UCB$B_TT_PARITY(R5),15$		; IF NOT ENABLED, THEN DROP
	BRB	10$				; DROP CHARACTER, NO ERROR

	.SBTTL	TTY$FRAMERROR - FRAME ERROR ON A READ
;++
; TTY$FRAMERROR - FRAME READ ERROR OCCURED ON LINE
;
; Functional description:
;
; This routine is branched to from a TTY$READERROR to report a frame
; read error on a line. It compares time against the
; last autobaud attempt, and if a "sufficient" (avg 0.5 seconds) has
; passed, the sampling baud rate is toggled between 9600 and 600. 
; The toggling to 600 baud will time out in less than 3 seconds.
; 
; Inputs:
;
;	R0,R4 saved on stack
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	Baud rate may change.
;	R4,R5 are preserved.
;--
TTY$FRAMERROR:

; Check if we should attempt autobaud on this line

	MOVL	UCB$L_TT_LOGUCB(R5),R4	; Get logical UCB  address
	TSTW	UCB$W_REFC(R4)		; Terminal in use ?
	BEQL	40$			; Branch if yes

	BBC	#TT2$V_SECURE,UCB$L_DEVDEPND2(R5),18$	; NOT SECURE THEN
					; GIVE ERROR
	TSTB	R3			; NOT NULL DATA THEN NOT A BREAK
	BNEQ	18$			; SO GIVE AN ERROR
	BSBW	TTY$CLASS_DISCONNECT	; ELSE SIGNAL HANGUP STATUS
	BRW	15$			; THEN RETURN NOTHING

40$:	BBS	#TT2$V_AUTOBAUD,UCB$L_DEVDEPND2(R5),43$ ; Check AUTOBAUD
	TSTB	R3			; BREAK?
	BNEQ	18$			; NO THEN GIVE ERROR
	BSBW	TTY$NOTIFY		; LET THE JOB CONTROLER KNOW ABOUT
	BRW	15$			; THE BREAK

; check time to see that it's been "awhile".
; note that you want to throw away multiple-character, single-keystroke
; characters after the first. This check gives between 0 and one second.
; It doesn't seem necessary to make it be at least one second.
43$:
	CMPL	UCB$L_TT_RDUE(R5),-
		G^EXE$GL_ABSTIM		; check against current
	BEQL	18$			; exit if equal

; make sure there is no valid data in R3, if so, leave it for TTY$AUTOBAUD and
; don't toggle baud rate

	MOVB	#1,UCB$B_TT_OUTYPE(R5)	; ASSUME GOOD DATA
	TSTB	R3			; test
	BNEQ	30$			; Branch if data there
	CLRB	UCB$B_TT_OUTYPE(R5)	; BUT WE FOUND NO GOOD DATA

; time is OK - continue by checking baud rate

	MOVZBL	#TT$C_BAUD_9600,R4	; Assume set to 9600 baud
	CMPB	#TT$C_BAUD_9600,-
		UCB$W_TT_SPEED(R5) 	; At 9600 ?
	BNEQ	20$			; no, set 9600
;
; Toggle to 600 baud for 2 to 3 seconds
;
	MOVZBL	#TT$C_BAUD_600,R4	; otherwise, set 600 baud
80$:	SET_STATE -
		<AUTOP>			; Set state autobaud pending
	TIMSET	2

20$:	BSBW	SET_SPEED		; Set line speed
	MOVL	G^EXE$GL_ABSTIM,-
		UCB$L_TT_RDUE(R5)   	; set time
30$:	BRW	15$			; and exit via main module


	.DISABLE LSB

	.SBTTL	TTY$RESTARTIO - RESTART CURRENT I/O

;
;++
; TTY$RESTARTIO - RESTART CURRENT I/O
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine restarts an interrupted read or write request. Such
;	requests may have been interrupted due to a powerfail or
;	to coincident read and write requests.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UNIT UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R5 ARE PRESERVED.
;--

TTY$RESTARTIO::				; RESTART THE I/O
	IF_NOT_STATE WRITE,10$		; IF NOT WRITE THEN CONTINUE
	IF_STATE WRTALL,30$		; If passall mode, no special
					; restart is required.
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Get address of write buffer.
	BSBW	TTY$ABORT		; Abort any output activity
	CLRW	TTY$W_WB_BCNT(R4)	; No. Clear output byte count.
	MOVAB	TTY$L_WB_DATA(R4),-	; And reset the start of data
		TTY$L_WB_NEXT(R4)	; pointer.
	RSB				; Return.

10$:
	IF_NOT_STATE READ,30$		; BR IF READ NOT IN PROGRESS
	MOVL	UCB$L_IRP(R5),R3	; Get address of IRP.
	IF_STATE RDVERIFY,40$		; NOTHING SPECIAL FOR READ VERIFY
	BSBW	TTY$SETUP_READ		; Setup for the read operation.
	IF_STATE -			; Continue without special
		 PASALL,20$		; handling if PASSALL
	IF_NOT_STATE -			; or NOECHO ...
		NOECHO,15$		;
	BBC	#TT2$V_LOCALECHO, -	; without local echo.
		UCB$L_DEVDEPND2(R5),20$	; 
15$:	IF_NOT_STATE -			; Also no special handling if
		REFRSH,30$		; REFRESH state is not set.
	MOVAB	W^TTY$A_CTRLU+1,-	; GET A <CR> TO MULTIECHO
		UCB$L_TT_MULTI(R5)
	MOVW	#1,UCB$W_TT_MULTILEN(R5)	; AND ONLY 1 CHARACTER HERE.
	CLR_STATE -
		<CTRLR,SKIPCRLF>
	SET_STATE -			; Set the control-R and
		<EDITREAD,MULTI,SKIPLF>; send a linefeed and then control-r the read
20$:
	BBS	#IO$V_REFRESH,-		; If the read specified a
		IRP$W_FUNC(R3),30$	; refresh, don't cancel it.
	CLR_STATE -			; Otherwise, cancel refresh
		REFRSH			; state.

30$:
	RSB				; CONTINUE
40$:	MOVW	#SS$_OPINCOMPL,UCB$W_BOFF(R5) ; Set I/O completion status
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE READ BUFFER ADDRESS
	CLRL	IRP$L_MEDIA(R3)		; ZERO ALL OTHER READ VERIFY FIELDS
	MOVB	TTY$W_RB_LINOFF(R4),-	; PUT THE INDEX INTO THE IOSB
		IRP$L_MEDIA+3(R3)
	BRW	TTY$READONE		; Go complete the read


	.SBTTL	TTY$RTIMOU - READ TIMED OUT ENTRY

;++
; TTY$RTIMOU - Read timed out entry (from time dependent schedular)
;
; Functional description:
;
; This routine is called from the time dependent schedular via the UCB
; offset UCB$L_TT_RTIMOU whenever a timed read times out.  It completes
; the read with time SS$_TIMEOUT error and, then, continues terminal
; processing.
;
; Inputs:
;
;	IPL = IPL$_POWER
;	R5 = UCB address
;
; Outputs:
;
;	R0,R1,R2,R3,R4 are destroyed.
;	R5 is preserved.
;--

TTY$RTIMOU:				; Read timed out entry
	SETIPL	#IPL$_TIMER		; REDUCE IPL TO BEFORE LOCKING THE DATA BASES
	BSBW	TTY$LOCK		; MAKE SURE THE UCB IS LOCKED
	MOVAB	UCB$Q_TT_STATE(R5),R2	; Address state vector
	IF_NOT_STATE READ,20$		; IF THE AST IS LATE (I.E. THE READ IS
					; NO LONGER ACTIVE) THEN EXIT.
	MOVW	#SS$_TIMEOUT,UCB$W_BOFF(R5) ; Set I/O completion status
	IF_NOT_STATE RDVERIFY,5$	; NOTHING SPECIAL FOR OTHER THAN READ VERIFY
	MOVL	UCB$L_IRP(R5),R3	; GET THE IRP ADDRESS IN R3
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE READ BUFFER ADDRESS
	CLRL	IRP$L_MEDIA(R3)		; ZERO ALL OTHER READ VERIFY FIELDS
	MOVB	TTY$W_RB_LINOFF(R4),-	; PUT THE INDEX INTO THE IOSB
		IRP$L_MEDIA+3(R3)
5$:	BSBW	TTY$READONE		; Go complete the read
10$:	BRW	TTY$STARTOUTPUT		; then startup any waiting activity
20$:	RSB


	.SBTTL TTY$VT_TIMEOUT - DETACHED TERMINAL TIMEOUT

;++
; TTY$VT_TIMEOUT - DETACHED TERMINAL TIMEOUT ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED BY THE SYSTEM TIMER SERVICE WHEN
; A LUCB HAS BEEN DETACHED FOR A SPECIFIED PERIOD OF TIME
; WITHOUT BEING REATTACHED. A HANGUP AST IS FIRED FOR THAT
; LUCB TO GET THE PROCESS KILLED. ALL PENDING IO ON THE INPUT QUEUE
; IS COMPLETED WITH SS$_HANGUP STATUS. IN THIS STATE THERE SHOULD BE
; NO CURRENT READ OR WRITE. LAST DEASSIGN CODE IN CANCEL
; WILL CLEAN UP THE LUCB, AND DEASSIGN WILL DELETE IT BACK TO POOL.
;
; INPUTS:
;	INTERLOCKED AT DIPL
;	R5 = LUCB ADDRESS
;
;--
	.WORD	TTY$VT_TIMEOUT-.
TTY$VT_TIMEOUT:
	PUSHL	R6		; SAVE SCRATCH REGISTER
	MOVL	R5,R6		; LUCB REQUIRED IN R6
	MOVL	UCB$L_PDT(R6),R3; GET ADDRESS OF ANY REBINDING PUCB
	BEQL	5$		; NONE
	CLRL	UCB$L_PDT(R3)	; CANCEL ANY PENDING REBIND OPERATION
5$:	BICW	#UCB$M_ONLINE,-	; SET LUCB OFFLINE TO PREVENT ANY MORE IO
		UCB$W_STS(R6)
	BSBW	DISC_FIREAST	; SIGNAL HANGUP AST TO OWNER
10$:	REMQUE	@UCB$L_IOQFL(R6),R3	; DRAIN IO QUEUE
	BVS	20$		; NO MORE PACKETS QUEUED
	MOVZWL	#SS$_HANGUP,-	; FILL IN COMPLETION STATUS
		IRP$L_MEDIA(R3)
	BICW	#IRP$M_FUNC,IRP$W_STS(R3) ; RESET ANY BUFFERED READS
	JSB	G^COM$POST	; AND COMPLETE THE IO	
	BRB	10$

20$:	POPL	R6		
	RSB



	.SBTTL	TTY$SETUP_UCB - SETUP TERMINAL UCB

;++
; TTY$SETUP_UCB - SETUP TERMINAL UCB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED DURING SYSTEM STARTUP TO SET UP TERMINAL UCBS.
; THE UCB IS ZEROED EXCEPT FOR THE SPEED AND FILL COUNTS. THE CURSOR IS
; SET TO 1 TO FORCE A CR-LF. THE HOLDING TANK IS INVALIDATED. THE FORK BLOCK
; IS INITIALIZED.
;
; If the write queue is not yet initialized (indicated by zeroes in the
; listhead), initialize the queue.
;
; Initialize the read timed out dispatch (UCB$L_TT_RTIMOU).
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;
;	R0-R4 ARE PRESERVED.
;--

TTY$SETUP_UCB::				; SET UP THE UCB (PORT INTERFACE)
	PUSHL	R0
	MOVL	UCB$L_TT_LOGUCB(R5),R0	; GET THE LOGICAL UCB ADDRESS
	BEQL	3$			; NONE THEN INIT THE UCB
	TSTW	UCB$W_REFC(R0)		; IS THIS UCB ACTIVE?
	BEQL	3$			; NO THEN INIT IT
	POPL	R0			; IF ACTIVE THEN RETURN NORMALY
	RSB
3$:
	MOVL	R5,UCB$L_TT_LOGUCB(R5)	; INIT LOGICAL UCB ADDRESS
	MOVL	R5,UCB$L_TL_PHYUCB(R5)	; INIT PHYSICAL UCB

	BISL	#DEV$M_AVL,-		; SHOW PUCB AVALABLE FOR USE
		UCB$L_DEVCHAR(R5)
	BICL	#DEV$M_RED,UCB$L_DEVCHAR2(R5) ; SHO PUCB NOT REDIRECTED

	CLRL	UCB$L_TL_CTLPID(R5)	; CLEAN OUT A LEFT OVER PID
	MOVW	#1,UCB$W_TT_CURSOR(R5)	; SET BAD CURSOR TO FORCE CRLF
	CLRW	UCB$W_TT_HOLD(R5)	; INIT HOLDING TANK
	MOVAB	W^TTY$FORK_ADDR,UCB$L_FPC(R5); SET UP FORK ADDRESS
	MOVL	UCB$W_TT_DESPEE(R5),UCB$W_TT_SPEED(R5); SET UP TEMP CHARS
	MOVB	UCB$B_TT_DEPARI(R5),UCB$B_TT_PARITY(R5);SET UP DEFAULT PARITY
	MOVL	UCB$B_TT_DETYPE(R5),UCB$B_DEVTYPE(R5);

	BICL3	#^C<TT$M_REMOTE>,UCB$L_DEVDEPEND(R5),R0; SAVE CURRENT REMOTE STATE
	BICL3	#TT$M_REMOTE,UCB$L_TT_DECHAR(R5),UCB$L_DEVDEPEND(R5);
	BISL	R0,UCB$L_DEVDEPEND(R5)	; KEEP PREVIOUS SETTING
	BICB3	#^C<TT$M_PASSALL!TT$M_NOECHO>,UCB$L_DEVDEPEND(R5),R0; GET PASSALL AND NOECHO STATE

;	Set up default DMA characteristics

	MOVL	UCB$L_TT_DECHA1(R5),UCB$L_DEVDEPND2(R5)	; SET UP DEFAULT CHAR WORD 2
	BBC	#TT2$V_DMA,UCB$L_DEVDEPND2(R5),8$	; SKIP IF NOT SET
	BBS	#TTY$V_PC_DMAAVL,UCB$W_TT_PRTCTL(R5),5$ ; DMA FEATURE AVAILABLE
	BICL	#TT2$M_DMA,UCB$L_TT_DECHA1(R5)		; SHOW DMA NOT AVAILABLE
	BICL	#TT2$M_DMA,UCB$L_DEVDEPND2(R5)		; IF DMA IS NOT AVAILABLE
	BRB	8$
5$:
	BISW	#TTY$M_PC_DMAENA,UCB$W_TT_PRTCTL(R5)	; ENABLE DMA USAGE	
8$:

	INSV	R0,#TTY$V_ST_PASALL,#2,UCB$Q_TT_STATE+4(R5); RESET CURRENT STATE
	POPL	R0

;
; Initialize the write queue.
;

	TSTL	UCB$L_TT_WFLINK(R5)	; Is the queue initialized?
	BNEQ	10$			; Yes. Don't redo it.
	MOVAB	UCB$L_TT_WFLINK(R5),-	; Initialize queue to point to
		UCB$L_TT_WFLINK(R5)	; itself in both directions.
	MOVAB	UCB$L_TT_WFLINK(R5),-	; Now the backward link.
		UCB$L_TT_WBLINK(R5)

10$:

;
; Initialize read timed out dispatch.
;

	MOVAB	TTY$RTIMOU,UCB$L_TT_RTIMOU(R5) ; Set read timed out dispatch

	RSB				; Return.


	.SBTTL	TTY$CLASS_FORK - PORT DRIVER FORK ROUTINE
;++
; TTY$CLASS_FORK
;
; DESCRIPTION 
;
;	WILL CAUSE A FORK TO BE CREATED FOR A PORT DRIVER.
; WHEN THE FORK IS CREATED THE DRIVER IS CALLED BACK AT IT'S PORT_FORKRET
; DISPATCH VECTOR.
;
; INPUTS:
;
;	R2 = UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;	R4,R3 DESTROYED
;	R2,R5 ARE PRESERVED
;--
TTY$CLASS_FORK::			; CREATE A FORK FOR THE TERMINAL PORT
	MOVL	#TTY$V_FD_PORTFORK,R4	; SET THE PORT FORK BIT.
					; AND FALL INTO CREATING THE FORK

	.SBTTL	TTY$CRE_FORK - General purpose driver fork routine
;++
; TTY$CRE_FORK - CREATE FORK ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE FORKS IN THE UCB FOR EITHER OF TWO REASONS:
;
;	1. UNSOLICITED DATA - SEND MESSAGE TO OWNER
;	2. NO TYPEAHEAD BUFFER - ALLOCATE ONE
;
; INPUTS:
;
;	R2 = UNIT STATE VECTOR ADDRESS
;	R3 = CHARACTER TO BUFFER FOR TYPEAHEAD NEEDED
;	R4 = FORK REASON STATE BIT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4 ARE DESTROYED
;	R2,R5 ARE PRESERVED
;--
TTY$CRE_FORK::				; CREATE FORK
	BBSS	#TTY$V_FD_BUSY,UCB$L_FR4(R5),20$; ARE WE BUSY
	BBSS	R4,UCB$L_FR4(R5),3$	; SET THE APROPRIATE BIT
3$:	MOVL	UCB$L_FR4(R5),R4	; AND GET THE BIT INTO R4
5$:	PUSHL	UCB$L_PID(R5)		; SAVE THE PID ON THE STACK
	PUSHAB	B^TTY$FORK_ADDR		; SET FORK ROUTINE ADDRESS
	JMP	TTY$SYNCH		; CREATE FORK PROCESS
;
; FORK ALREADY ACTIVE
;
20$:	BBSS	R4,UCB$L_FR4(R5),25$	; SET THE APROPRIATE BIT
25$:	RSB				; AND RETURN TO THE CALLER


	.SBTTL	FORK DISPATCHER
	.WORD	ATTENTION-.		; SET UP ATTENTION INTERRUPT
TTY$FORK_ADDR::
;
; ATTENTION FORK PROCESS
;
10$:	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS UNIT STATE
	
	DSBINT	UCB$B_DIPL(R5)		; DISABLE INTERUPTS FOR THE CHECK
	FFS	#0,#TTY$V_FD_BUSY+1,UCB$L_FR4(R5),R4; FIND THE FIRST BIT SET
	BBSC	R4,UCB$L_FR4(R5),15$	; CLEAR THAT BIT
15$:	ENBINT				; ENABLE INTERUPTS

	PUSHAL	10$			; SAVE A RETURN ADDRESS
	CASE	R4,TYPE=B,<-		; AND DISPATCH TO THE NECESSARY ROUTINE
	UNSOL -
	GETAHD -
	DISCONNECT -
	PORTFORK -
	UNLINKFORK -
	LINKFORK -
	FORKEXIT>

FORKEXIT:
	POPL	R4			; POP OFF  THE ADDRESS OF THE DISPATCHER
	RSB				; THEN RETURN

PORTFORK:
	MOVL	UCB$L_TT_PORT(R5),R1	; GET THE PORT ADDRESS
	JMP	@PORT_FORKRET(R1)	; AND CALL THE PORTS FORK ADDRESS



	.SBTTL	FORK TO DISCONNECT THE TERMINAL AND DELIVER THE HANGUP AST
;++
;DISCONNECT
;
; Descrpition:
;	Delivers all AST's, aborts all IO and then sends a terminal hangup
; message to the job controler.
;
; Inputs:
;	R2 = Unit state vector
;	R5 = PUcb address
;
; Outputs:
;
;	R5 = PRESERVED
;--
DISCONNECT:
	PUSHR	#^M<R6>
	MOVL	UCB$L_TT_LOGUCB(R5),R6	; GET LOGICAL UCB ADDRESS

	DSBINT	UCB$B_DIPL(R5)
	BSBW	TTY$ABORT		; ABORT ANY OUTPUT,
	BSBW	TTY$RESUME		; AND RESET CONTROL S
	ENBINT

	BBCC	#TT$V_REMOTE,UCB$L_DEVDEPEND(R5),10$	;RESET REMOTE TERMINAL
10$:	MOVL	UCB$L_DEVDEPEND(R5),UCB$L_DEVDEPEND(R6)	;UPDATE MODIFIED FIELD

	BBC	#TT2$V_DISCONNECT,UCB$L_DEVDEPND2(R5),15$;SKIP IF DISCONNECT NOT AVAILABLE
	CMPL	R5,R6					; MAKE SURE ITS REASONABLE
	BEQL	15$					; NO, LUCB/PUCB THE SAME
	BRW	50$

15$:
	BSBW	DISC_FIREAST				; FIRE HANGUP AST
	MOVZWL	#SS$_HANGUP,UCB$W_BOFF(R5) 		; SET THE RETURN STATUS
	BSBW	DISC_STOPIO				; STOP CURRENT I/O


	MOVL	#MSG$_TRMHANGUP,R4	; SET MESSAGE TYPE
	MOVL	R6,R5			; SWITCH TO LUCB CONTEXT
	MOVL	UCB$L_AMB(R5),R3	; GET ASSOC MAILBOX
	BEQL	20$			; IF EQL THEN NONE
	JSB	G^EXE$SNDEVMSG		; INSERT MAILBOX MESSAGE

20$:	MOVL	UCB$L_TL_PHYUCB(R5),R5	; SWITCH BACK TO PUCB CONTEXT
	POPR	#^M<R6>
	RSB

50$:
	POPR	#^M<R6>			; RESTORE SAVED REGISTERS
	BRW	UNLINKFORK		; AND DO UNLINK OPERATION

;
;	FIRE HANGUP AST
;
;	THIS ROUTINE DELIVERS ALL OUTSTANDING ^Y ASTS WITH
;	HANGUP STATUS TO REQUEST THE PROCESS BE RUN DOWN. IN THE
;	EVENT NONE ARE CURRENTLY QUEUED, THEN A FLAG IS SET TO 
;	SIGNAL THIS CONDITION WHEN THE NEXT ^Y AST IS QUEUED.
;	*NOTE* THIS ROUTINE MAY NOT UTILIZE ANY FIELDS IN THE PUCB 
;	AS IT IS ALSO USED BY DISCONNECTED LOGICAL UCB'S.
;
;	INPUTS: 
;		R6 - LUCB
;	OUTPUTS:
;		R5,R6 PRESERVED

DISC_FIREAST:
	DSBINT	UCB$B_DIPL(R6)		; INTERLOCK TO DEVICE IPL
	MOVAB	UCB$L_TL_CTRLY(R6),R4	; ADDRESS CONTROL Y AST LIST
	MOVL	R4,R0			; COPY LIST ADDRESS
	MOVL	ACB$L_AST(R0),UCB$Q_TL_BRKTHRU(R6)
	TSTL	(R0)			;LIST HEAD EMPTY?
	BNEQ	5$			;NO,PROCESS HANGUP ASTS
	TSTW	UCB$W_REFC(R6)		;IS THIS UNIT OWNED OR ACTIVE?
					;(OR IS IT LOGGED OUT)
	BEQL	5$			;NOT ACTIVE,SO SKIP FLAG SETTING
	BISW	#UCB$M_TT_HANGUP,-
		UCB$W_DEVSTS(R6)	;SET HANGUP FLAG TO NOTIFY NEXT CTRL-Y
					;ATTENTION AST WHEN IT IS QUEUED.
5$:	MOVL	(R0),R0			; GET NEXT ENTRY
	BEQL	10$			; IF EQL THEN DONE
	MOVL	ACB$L_AST(R0),UCB$Q_TL_BRKTHRU+4(R6)
	MOVZWL	#SS$_HANGUP,ACB$L_KAST+4(R0); INSERT NEW PARAM FOR AST
	BRB	5$			; CONTINUE UNTIL DONE
10$:	JSB	G^COM$DELATTNAST	; DELIVER THE AST'S
	ENBINT
	RSB




;	ABORT CURRENT AND QUEUED READS AND WRITES
;
;	THIS ROUTINE IS USED TO ABORT INTERNALLY QUEUED WRITES AND
;	ANY ACTIVE READ. IT RUNS IN THE CONTEXT OF THE PUCB.
;
;	INPUT:	R5 - PUCB
;	OUPUT:	R5 - PRESERVED

DISC_STOPIO:
	DSBINT	UCB$B_DIPL(R5)		; INTERLOCK TO DEVICE IPL
	MOVAB	UCB$Q_TT_STATE(R5),R2	; SET UP LUCB STATE POINTER
	MOVAB	UCB$L_TT_WFLINK(R5),R1	; Get start of write queue.
	MOVL	R1,R3			; Copy it to check for end.

10$:
	MOVL	TTY$L_WB_FLINK(R3),R3	; Get next entry.
	CMPL	R3,R1			; At end of queue?
	BEQL	15$			; Yes. Branch forward.
					; leave it in the queue.
	MOVL	TTY$L_WB_BLINK(R3),R3	; Get entry's backward link.
	REMQUE	@TTY$L_WB_FLINK(R3),R4	; Remove the link.
	BSBW	TTY$WRITEPOST		; Queue it for completion
	BRB	10$			; Try for next link.

15$:					; Stop the current I/Os.
	IF_NOT_STATE -			; Branch forward if no read is
		READ,20$		; currently in progress.
	CLR_STATE -			; Clear escape bits.
		<ESC,BADESC>
	MOVL	UCB$L_IRP(R5),R4	; Get address of IRP.
	CLRL	IRP$L_MEDIA(R4)		; Clear terminators.
	BSBW	TTY$READONE		; Complete the read.
20$:					; Check for a write to complete.
	IF_NOT_STATE -			; Branch forward if no write is
		WRITE,30$		; in progress.
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write packet.
	MOVW	UCB$W_BOFF(R5),-	; Put status code in the
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete the I/O.
30$:
	ENBINT
	RSB


	.SBTTL	FORK TO CHECK FOR TYPEAHEAD BUFFER FETCH
;++
; GETAHD
;
; Description:
;	Will create a typeahead buffer for the user, then insert
; the character that caused the buffer to be allocated and cause
; that character to be processed.
;
; Inputs:
;
;	R2 = UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;	UCB$L_FR3 = CHARACTER THAT CAUSED TYPEAHEAD BUFFER TO BE CREATED
;
; Outputs:
;
;	R1,R4 are Destroyed
;	R2, R5 are Preserved
;--
GETAHD:
	TSTL	UCB$L_TT_TYPAHD(R5)	; ALREADY ALLOCATED?
	BNEQ	100$			; IF NEQ THEN YES
	BBC	#TT2$V_ALTYPEAHD,-	; SKIP IF NORMAL SIZE
		UCB$L_DEVDEPND2(R5),72$
	MOVZWL	G^TTY$GW_ALTYPAHD,R1	; ALLOCATE THE TYPEAHEAD BUFFER
	BRB	73$
72$:	MOVZWL	G^TTY$GW_TYPAHDSZ,R1	; ALLOCATE THE TYPEAHEAD BUFFER
73$:	ADDL	#TTY$L_TA_DATA,R1	; PLUS SPACE FOR HEADER
	JSB	G^EXE$ALONONPAGED	; ALLOCATE THE TYPEAHEAD BUFFER
	MOVL	R2,R4			; COPY BLOCK ADDRESS
	BLBC	R0,100$			; IF FAILURE THEN TOUGH
	MOVW	R1,TTY$W_TA_SIZE(R4)	; SET UP SIZE
	MOVAB	(R4)[R1],TTY$L_TA_END(R4); SET UP END POINTER
	MOVB	#DYN$C_TYPAHD,TTY$B_TA_TYPE(R4);
	CLRW	TTY$W_TA_RCLSIZ(R4)	; CLEAR OUT THE RECALL SIZE
	DSBINT	UCB$B_DIPL(R5)		; LOCK TERMINAL DATA BASE
	MOVL	R4,UCB$L_TT_TYPAHD(R5)	; STORE ADDRESS
	MOVAB	UCB$Q_TT_STATE(R5),R2	; RESTORE THE UNIT STATE VECTOR ADDRESS
	BSBW	TTY$PURGE_AHEAD		; SET UP THE BLOCK
	MOVB	UCB$L_FR3(R5),TTY$L_TA_DATA(R4); INSERT DATA
	BEQL	80$			; SKIP INSERT IF NULL
	INCL	TTY$L_TA_PUT(R4)	; POINT TO NEXT PLACE
	INCW	TTY$W_TA_INAHD(R4)	; AND BUMP THE COUNT
	BSBW	TTY$STARTOUTPUT		; BEGIN NEXT STATE
80$:	BBSC	#TTY$V_FD_GETAHD,UCB$L_FR4(R5),90$; CLEAN THE BIT OUT AGAIN
90$:	ENBINT				; LOWER IPL
100$:	RSB				; THEN RETURN

	.SBTTL LINKFORK - RECONNECT LUCB/PUCB

;++
; LINKFORK - LINK LOGICAL AND PHYSICAL UCB
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS FORK ROUTINE IS QUEUED TO LINK A PUCB AND LUCB.
;	THE LUCB ADDRESS TO BE LINKED TO IS CONTAINED IN PUCB
;	OFFSET UCB$L_PDT. THIS ROUTINE RESETS BSY IN UCB$W_STS
;	AND RESTARTS PENDING IRP'S IN THE I/O QUEUE.
;
; INPUTS:
;
;	R5 = PUCB ADDRESS
;
;--
LINKFORK:
	MOVL	UCB$L_PDT(R5),R4			; GET SPECIFIED LUCB
	MOVB	UCB$B_FIPL(R5),UCB$B_FIPL(R4)		; FORK IPL
	MOVB	UCB$B_DIPL(R5),UCB$B_DIPL(R4)		; DEVICE IPL
	BICB	#UCB$M_TIM,UCB$W_STS(R4)		; AND TURN OFF TIMER BIT IN LUCB

	BISL	#TT2$M_DISCONNECT,UCB$L_DEVDEPND2(R5)	; SET DISCONNECT BIT
							; BECAUSE WE ARE DISCONNECTABLE
	MOVL	UCB$L_DEVDEPEND(R5),UCB$L_DEVDEPEND(R4)	; MAKE SURE LUCB IS 
	MOVL	UCB$L_DEVDEPND2(R5),UCB$L_DEVDEPND2(R4)	; IMAGE COPY OF PUCB

	MOVL	R5,UCB$L_TL_PHYUCB(R4)			; LINK LUCB TO PUCB
	MOVL	R4,UCB$L_TT_LOGUCB(R5)			; LINK PUCB TO LUCB
	MOVL	R5,UCB$L_TL_PHYUCB(R5)			; SHOW PUCB=PUCB
	CLRL	UCB$L_PDT(R4)				; RESET REBIND FIELDS
	CLRL	UCB$L_PDT(R5)				; RESET REBIND FIELDS

	BICL	#DEV$M_DET,UCB$L_DEVCHAR2(R4)		; LUCB NOW NOT DETACHED
	BICL	#DEV$M_AVL,-				; SHOW PUCB NOT AVALABLE FOR USE
		UCB$L_DEVCHAR(R5)
	BISL	#DEV$M_RED,UCB$L_DEVCHAR2(R5) 		; SHO PUCB REDIRECTED

	MOVL	R4,R5					; SWITCH TO LUCB CONTEXT
	REMQUE	@UCB$L_IOQFL(R5),R3			; GET A PACKET OFF QUEUE
	BVS	10$					; QUEUE EMPTY
	PUSHAL	20$					; SAVE RETURN ADDRESS
	JMP	G^IOC$INITIATE				; START THE PACKET
10$:	BICW	#UCB$M_BSY,UCB$W_STS(R5)		; RESET BSY BIT IN LUCB
							; TO ALLOW NEW OUTPUT
20$:	MOVL	UCB$L_TL_PHYUCB(R5),R5			; SWITCH BACK TO PUCB
	RSB						; DONE


	.SBTTL UNLINKFORK - DISCONNECT LUCB/PUCB

;++
; UNLINKFORK - UNLINK LOGICAL AND PHYSICAL UCB
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS FORK ROUTINE IS QUEUED TO ALLOW ANY READS AND WRITE FORKS
;	TO FINISH PRIOR TO UNLINKING LOGICAL AND PHYSICAL UCBS.
;	CURRENTLY QUEUED WRITES ARE COMPLETED WITH SS$_NORMAL. ANY
;	CURRENT READ, IS INSERTED AT THE HEAD OF THE I/O QUEUE. THE
;	UCB "BUSY" BIT IS SET TO PREVENT ANY NEW I/O FROM STARTING.
;
; INPUTS:
;
;	R5 = PUCB ADDRESS
;
;--
UNLINKFORK:
	MOVL	UCB$L_TT_LOGUCB(R5),R4		; GET LOGICAL UCB ADDRESS
	MOVAB	UCB$Q_TT_STATE(R5),R2		; GET STATE ADDRESS

;	CHECK FOR ANY ACTIVE I/O
	IF_STATE READ,40$
	IF_STATE WRITE,30$
	
;	THE LUCB IS IDLE, SO WE FORCE BSY TO PREVENT ANY NEW I/O FROM
;	BEING STARTED.	THIS WILL ALLOW THE LUCB TO BE DETACHED, AND THE
;	PUCB TO BE FREE FOR FUTURE CONNECTS

	BISW	#UCB$M_BSY,UCB$W_STS(R4)	; FORCE BSY
	CLRL	UCB$L_IRP(R4)			; SHOW NO I/O ACTIVE
	CLRL	UCB$L_TL_PHYUCB(R4)		; AND BREAK LINK TO PUCB
	MOVL	R5,UCB$L_TT_LOGUCB(R5)		; AND MAKE PUCB=LUCB
	BISL	#DEV$M_DET,UCB$L_DEVCHAR2(R4)	; LUCB IS NOW DETACHED

;	INIT TIMER ON LUCB TO INSURE IT DISCONNECTS
;	IF NOONE RECLAIMS IT WITHIN 30 MINUTES

	MOVAB	TTY$VT_TIMEOUT,UCB$L_FPC(R4)	; LOAD VECTOR FOR TIMEOUT ENTRY
	ADDL3	G^TTY$GL_TIMEOUT,G^EXE$GL_ABSTIM,-; AND SET TIMER 
		UCB$L_DUETIM(R4)
	BISB	#UCB$M_TIM,UCB$W_STS(R4)	; AND TURN ON TIMER BIT IN LUCB


;	IF REBINDING STATE, THEN GOTO LINKFORK
	BBSC	#TTY$V_SX_RECONNECT,-
		UCB$Q_TT_STATE(R5),20$

	BSBW	CANCEL_MODEM			; CANCEL THE MODEM (HANGUP IF
						; NECESSARY)
	JSB	CANCEL_RESET			; GO RESET PUCB. THIS WILL ALSO
						; MAKE IT AVAILABLE 
	RSB

20$:	BRW	LINKFORK			; GO LINK PUCB TO REQUESTED LUCB


;	STOP IO ON PUCB PRIOR TO DISCONNECT
30$:
	MOVZWL	#SS$_NORMAL,UCB$W_BOFF(R5) ; SET THE RETURN STATUS
	BSBW	DISC_STOPIO		; STOP CURRENT IO
	BBCC	#TTY$V_FD_BUSY,-	; FORCE NEW FORK TO QUEUE BEHIND ALL OTHERS
		UCB$L_FR4(R5),35$
35$:	MOVL	#TTY$V_FD_UNLINK,R4	; AND QUEUE THE FORK
	BSBW	TTY$CRE_FORK
	POPL	R4			; POP OFF TERMINAL FORK CONTROL RETURN PC
	RSB				; AND EXIT

;	REQUEUE ANY ACTIVE READ TO THE HEAD OF THE QUEUE
40$:
	DSBINT	UCB$B_DIPL(R5)		; INTERLOCK WITH DEVICE INTERRUPTS
	MOVL	UCB$L_IRP(R5),R3	; GET IRP OF ACTIVE READ

;	INIT READ STATUS FIELDS

	BBSC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),50$; RESET ANY TIMED READ STATE

	INSQUE	(R3),UCB$L_IOQFL(R4)	; AND PUT AT HEAD OF THE QUEUE

	CLR_STATE -
		<READ,DEL,EOL,-		; RESET READ STATE BITS, BUT LEAVE "BSY" SET
		PROMPT,CTRLR,NOFLTR,-
		ESC,ESC_O,BADESC,PRE,-
		REFRSH,EDITREAD,SKIPCRLF,RDVERIFY,-
		MULTI,RECALL,OVERSTRIKE,EDITING,-
		QUOTING,BACKSPACE,TERMNORM>

45$:	ENBINT
	BRB	30$			; AND FULSH COMPLETE ANY WRITES

50$:	MOVZWL	#SS$_HANGUP,UCB$W_BOFF(R5) 		; SET THE RETURN STATUS
	BSBW	TTY$READONE		; AND COMPLETE THE READ
	BRB	45$



	.SBTTL 	FORK TO SEND UNSOLICITED DATA MESSAGE
;++
; UNSOL
;
; Description:
;	Will send a message to the job controler indicating that
; unsoliced input has been recieved
;
; Note: This routine runs in context of the logical UCB. 
;
; INPUTS:
;	R2 = UNIT STATE VECTOR
;	R5 = UCB ADDRESS 
;
; OUTPUTS:
;	R3 IS DESTROYED
;	R2,R5 ARE PRESERVED
;
; REGISTER USAGE:
;	R5 = LOGICAL UCB
;	R6 = PHYSICAL UCB
;--
UNSOL:
	PUSHR	#^M<R5,R6>		; SAVE REGISTERS
	MOVL	UCB$L_TT_LOGUCB(R5),R5	; LOAD LUCB ADDRESS
	MOVL	UCB$L_TL_PHYUCB(R5),R6	; LOAD PUCB ADDRESS

	MOVZBL	#MSG$_TRMUNSOLIC,R4	; SET MESSAGE TYPE
	TSTW	UCB$W_REFC(R5)		; IF REF COUNT 0 THEN 
	BEQL	50$			; JOB CONTROLLER
	MOVL	UCB$L_AMB(R5),R3	; GET USER'S MAILBOX
	BEQL	65$			; IF EQL THEN NONE
	BBS	#UCB$V_TT_NOTIF,UCB$W_DEVSTS(R6),65$; BR IF ALREADY NOTIFIED
	BRB	55$			; CONTINUE
50$:
	MOVL	G^TTY$GL_JOBCTLMB,R3	; ADDRESS JOB CONTROLLER MAILBOX
	BBS	#UCB$V_JOB,UCB$W_DEVSTS(R6),65$; BR IF NOTIFIED ALREADY

	BBC	#TT2$V_DISCONNECT,-	; SKIP IF UNIT NOT ABLE TO DISCONNECT
		UCB$L_DEVDEPND2(R6),55$

	BSBW	CLONE_UCB		; GO CREATE LOGICAL UCB

55$:	JSB	G^EXE$SNDEVMSG		; SEND THE MESSAGE
	BLBC	R0,65$			; IF FAILED THEN LEAVE DATA BASE UNCHANGED
	TSTW	UCB$W_REFC(R5)		; REF COUNT 0?
	BNEQ	60$			; IF NEQ THEN USER
	BISW	#UCB$M_JOB,UCB$W_DEVSTS(R6); SET NOTIFIED
	BRB	65$			; LOOK TO UNSOLICITED DATA
60$:	BISW	#UCB$M_TT_NOTIF,UCB$W_DEVSTS(R6); SET NOTIFIED
65$:	POPR	#^M<R5,R6>		; RESTORE REGISTERS AND SWITCH BACK TO PUCB
	RSB				; RETURN TO THE DISPATCHER

	.page
	.SBTTL	CLONE NEW LOGICAL UCB 
;++
; CLONE_UCB
;
; Description:
;	This routine will clone a logical ucb and cross link it to the
;	specified physical ucb. The logical ucb fields are initialized 
;	as appropriate.
;
; Inputs:
;
;	R6 = PHYSICAL UCB ADDRESS
;
; Outputs:
;
;	R5 = LOGICAL UCB ADDRESS
;	R6 = PHYSICAL UCB ADDRESS
;	
;	R0-R4 DESTROYED
;--
CLONE_UCB:
	PUSHR	#^M<R3,R4>
	MOVL	VT$UCB,R5		; GET ADDRESS OF TEMPLATE UCB ADDRESS
	BEQL	50$			; NONE ESTABLISHED
	JSB	G^IOC$CLONE_UCB		; GO CREATE A DETACHED UCB
	BLBC	R0,50$			; ERROR, SO SKIP ITS USE
	MOVL	R2,R5			; GET NEW LUCB ADDRESS
	CLRW	UCB$W_REFC(R5)		; INIT REFERENCE COUNT

	BISL	#UCB$M_DELETEUCB,-	; MARK THIS LUCB TO BE DELETED ON LAST DEASSIGN
		UCB$L_STS(R5)
	BICL	#DEV$M_AVL,-		; SHOW PUCB NOT AVALABLE FOR USE
		UCB$L_DEVCHAR(R6)
	BISL	#DEV$M_RED,UCB$L_DEVCHAR2(R6) ; SHO PUCB REDIRECTED

	
;	INIT LUCB FIELDS

	MOVB	UCB$B_DEVTYPE(R6),UCB$B_DEVTYPE(R5)	; TERMINAL TYPE
	MOVB	UCB$B_FIPL(R6),UCB$B_FIPL(R5)		; FORK IPL
	MOVB	UCB$B_DIPL(R6),UCB$B_DIPL(R5)		; DEVICE IPL
	MOVW	UCB$W_DEVBUFSIZ(R6),UCB$W_DEVBUFSIZ(R5)	; BUFFER SIZE
	MOVL	UCB$L_DEVDEPEND(R6),UCB$L_DEVDEPEND(R5)	; DEVICE CHARACTERISTICS
	MOVL	UCB$L_DEVDEPND2(R6),UCB$L_DEVDEPND2(R5)	; 
	MOVB	UCB$B_AMOD(R6),UCB$B_AMOD(R5)		; DEVICE PROTECTION
	MOVL	R6,UCB$L_TL_PHYUCB(R5)			; LINK LUCB TO PUCB
	MOVL	R5,UCB$L_TT_LOGUCB(R6)			; LINK PUCB TO LUCB	
	BRB	55$
	
50$:	MOVL	R6,R5				; ERROR, NO LOGICAL UCB CREATED
55$:	POPR	#^M<R3,R4>
	RSB



	.SBTTL	ATTENTION - UNIT TIMEOUT, POWERFAIL ATTENTION ROUTINE

;++
; ATTENTION - UNIT TIMEOUT, POWERFAIL ATTENTION ROUTINE
;
; THIS ROUTINE IS ENTERED VIA THE UCB$L_FPC ON POWERFAIL OR TIMEOUT.
; THE ACTION IS TO RESTART THE I/O IF THE POWER FAILED AND TO CANCEL IT
; IF A TIMEOUT OCCURRED.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--

ATTENTION:				; ATTENTION INTERRUPT
	BSBW	TTY$LOCK		; SET IPL AND REGISTERS
	BBC	#UCB$V_POWER,UCB$W_STS(R5),20$; CANCEL IF NOT POWERFAIL

;
; POWER FAILED WHILE THIS UNIT WAS WAITING FOR AN INTERRUPT.
;

	BSBW	RESTART			; Restart in progress I/O.
	BRW	TTY$STARTOUTPUT		; BEGIN THE I/O AGAIN
20$:
;
; CHECK FOR AUTOBAUD AT 600 BAUD TIMEOUT
;
	IF_NOT_STATE	AUTOP,50$	; SKIP IF NOT
	MOVZBW	#TT$C_BAUD_9600,-
		UCB$W_TT_SPEED(R5)	; SET 9600 BAUD
	MOVB	UCB$B_TT_DEPARI(R5),UCB$B_TT_PARITY(R5); RESET THE PARITY
	BSBW	TTY$SET_LINE		; RESET SPEED ON LINE,
					;  SINCE TIMER EXPIRED
	RSB

;
; ACTUAL HARDWARE TIMEOUT
;

50$:					; Handle timeout.
	INCW	UCB$W_ERRCNT(R5)	; BUMP ERROR COUNTER
	MOVZWL	#SS$_TIMEOUT,-		; Load status code into the
		UCB$W_BOFF(R5)		; UCB status word.

60$:
	IF_NOT_STATE -			; Branch forward if not in a
		 WRITE,70$		; write state.
	BSBW	TTY$ABORT		; Abort any output activity
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write buffer.
	MOVW	UCB$W_BOFF(R5),-	; Save status in the write
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete this write.

70$:					; Check for a read.
	IF_NOT_STATE -			; Branch forward if not reading.
		READ,80$
	CLR_STATE -			; Clear escape states.
		<ESC,BADESC>
	MOVL	UCB$L_IRP(R5),R4	; GET CURRENT PACKET
	CLRL	IRP$L_MEDIA(R4)		; SET NO TERMINATORS
	BSBW	TTY$READONE		; COMPLETE READ
80$:
	RSB

	.SBTTL	RESTART - RESTART EVERYTHING ON POWERFAIL
;++
; RESTART
;
; Description:
;
;	Power fail recovery code.  Called by the state dispatcher when
; a powerfail is detected by the port unit-init routines.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R2 = UNIT state vector
;	R5 = UCB address
;
RESTART::
	BICW	#UCB$M_POWER,UCB$W_STS(R5); RESET POWERFAIL
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE VECTOR
	BSBW	TTY$ABORT		; ABORT PORT ACTIVITY
	BSBW	TTY$RESUME		; AND THEN RESUME PORT ACTIVITY
	CLR_STATE POWER			; RESET POWER FAIL STATE
	SET_STATE REFRSH		; FORCE READS TO BE REFRESHED
	JMP	TTY$RESTARTIO		; SET UP THE CURRENT I/O


	.SBTTL	TTY$POWERACTION - PORT ENTRY FOR POWERFAIL RECOVERY ACTION
;++
; TTY$POWERACTION
;
; Description:
;
;	Called by the port driver's unit-init routine when a powerfail is
; detected.  This routine will clear the interupt expected bit and setup
; a timer to call us back during the first pass of the timer survice routine.
; This routine also sets the POWER bit in the unit state vector to perform
; powerfail recovery if the timer is reset by a burst or character output.
;
; Inputs:
;
; 	R5 = UCB address
;
; Outputs:
;
;	All registers are preserved
;
;--
TTY$POWERACTION::
	BICW	#UCB$M_INT,UCB$W_STS(R5)
	BISW	#UCB$M_TIM,UCB$W_STS(R5)
	CLRL	UCB$L_DUETIM(R5)
	BISL	#TTY$M_ST_POWER,UCB$Q_TT_STATE(R5)
	RSB


	.SBTTL	CLASS DRIVER JACKET INTERFACE TO PORT DRIVERS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	These routines are the only place in the driver that the terminal
; port driver is actually called.  These routines allow the terminal class
; driver to add code that would have been duplicated in every port driver.
;
; Inputs to all routines:
;
;	R5 - ucb address
;
;--
;
; TTY$ABORT - Abort current output activity
;

TTY$ABORT::
	PUSHR	#^M<R0>			; SAVE A REGISTER
	BBCC	#TTY$V_ST_CTRLS,UCB$Q_TT_STATE(R5),-	; ALLOW CLASS OUTPUT
		5$
5$:
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_ABORT(R0)		; GOTO THE ROUTINE
	POPR	#^M<R0>
	RSB				; and return


;
; TTY$DISCONNECT - Indicates last deassign.
;
; INPUTS:
;
;	R5 - UCB address
;
TTY$DISCONNECT::
	PUSHR	#^M<R1>			; SAVE A REGISTER
	MOVL	UCB$L_TT_PORT(R5),R1	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_DISCONNECT(R1)	; GOTO THE ROUTINE
	POPR	#^M<R1>
	RSB				; and return



; TTY$DS_SET - SET OUTPUT MODEM SIGNALS 
;
; INPUTS:
;
;	R2 - LOW BYTE - SIGNALS TO ACTIVATE
;	     HIGH BYTE - SIGNALS TO DEACTIVATE
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;	R1 - R3 ARE USED
;--
TTY$DS_SET::
	PUSHR	#^M<R0>			; SAVE A REGISTER
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_DS_SET(R0)	; GOTO THE ROUTINE
	POPR	#^M<R0>
	RSB				; and return

;
; TTY$MAINT - MAINTNENCE ROUTINES
;
TTY$MAINT::
	PUSHR	#^M<R1>			; SAVE A REGISTER
	MOVL	UCB$L_TT_PORT(R5),R1	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_MAINT(R1)		; GOTO THE ROUTINE
	POPR	#^M<R1>
	RSB				; and return

;
; TTY$RESUME - CONTINUE OUTPUT ON A LINE
;
TTY$RESUME::
	PUSHR	#^M<R0>			; SAVE A REGISTER
	BBS	#TTY$V_ST_CTSLOW,UCB$Q_TT_STATE+4(R5),10$;IF CLEAR TO SEND IS LOW
					; THEN DON'T RESUME YET
	BBCC	#TTY$V_ST_CTRLS,UCB$Q_TT_STATE(R5),-	; ALLOW CLASS OUTPUT
		5$
5$:
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_RESUME(R0)	; GOTO THE ROUTINE
10$:	POPR	#^M<R0>
	RSB				; and return

; TTY$SET_LINE - SET SPEED AND PARITY
;
; IMPLICIT INPUTS:
;	UCB$B_TT_PARITY - CONTAINS PARITY, STOP BIT AND FRAME SIZE INFO
;	UCB$W_TT_SPEED - LOW BYTE XMIT SPEED
;			 HIGH BYTE ZERO OR RECIEVE SPEED
;	UCB$B_TT_PRTCTL - DMA AND AUTOXON ENABLE FLAGS
;
TTY$SET_LINE::
	PUSHR	#^M<R0>			; SAVE A REGISTER
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_SET_LINE(R0)	; GOTO THE ROUTINE
	POPR	#^M<R0>
	RSB				; and return

; TTY$SET_MODEM - START MODEM POLLING
;
; R0 - R4 USED
;
TTY$SET_MODEM:
	PUSHR	#^M<R0>			; SAVE A REGISTER
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_SET_MODEM(R0)	; GOTO THE ROUTINE
	POPR	#^M<R0>
	RSB				; and return

; TTY$STOP - STOP OUTPUT TO THE TERMINAL LINE
;
TTY$STOP::
	PUSHR	#^M<R0>			; SAVE A REGISTER
	BBSS	#TTY$V_ST_CTRLS,-
		UCB$Q_TT_STATE(R5),5$		; BLOCK NEW OUTPUT
5$:
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE ADDRESS OF THE PORT
	JSB	@PORT_STOP(R0)		; GOTO THE ROUTINE
	POPR	#^M<R0>
	RSB				; and return


; TTY$XOFF - CALCULATE CHARACTER TO SEND FOR XOFF AND SEND IT TO THE PORT
; TTY$XON  - SAME AS XOFF FOR XON FLOW CONTROL.
.ENABLE	LSB
TTY$XOFF::
	PUSHR	#^M<R1,R3>		; SAVE REGISTERS
	MOVZBL	#TTY$C_XOFF,R3		; USE XOFF
	BBC	#TTY$V_SX_TYPFUL,-
		UCB$Q_TT_STATE(R5),30$	; SKIP IF NOT TYPEAHEAD FULL
	BBS	#TT$V_HOSTSYNC,UCB$L_DEVDEPEND(R5),10$ ; XOFF CORRECT
	BBS	#TTY$V_SX_PASALL,-
		UCB$Q_TT_STATE(R5),20$	; SKIP IF PASSALL MODE
	MOVZBL	#TTY$C_BELL,R3		; USE BELL CHARACTER
10$:	MOVL	UCB$L_TT_PORT(R5),R1	; GET THE ADDRESS OF THE PORT VECTOR
	JSB	@PORT_XOFF(R1)		;
20$:	POPR	#^M<R1,R3>
	RSB

30$:	BITL	#TT$M_HOSTSYNC!TT$M_READSYNC,-
		UCB$L_DEVDEPEND(R5)	; HOST OR READ SYNC TERMINAL?
	BNEQ	10$			; YES THEN OUTPUT THE CHARACTER
	BRB	20$			; NO, SKIP OUTPUT

TTY$XON::
	PUSHR	#^M<R1,R3>
	MOVZBL	#TTY$C_XON,R3		; SEND XON
	BITL	#TT$M_HOSTSYNC!TT$M_READSYNC,-
		UCB$L_DEVDEPEND(R5)	; HOST OR READ SYNC TERMINAL?
	BEQL	20$			; NO, SKIP OUTPUT
	MOVL	UCB$L_TT_PORT(R5),R1	; GET THE ADDRESS OF THE PORT VECTOR
	JSB	@PORT_XON(R1)		;
	BRB	20$			; GO BACK AND RETURN
.DISABLE LSB

	.SBTTL	MODEM ROUTINES

;	MODEM CONTROL DATA AREA



TT$L_DIALUP::					;ROOT OF MODEM TIMER CRB LIST
	.LONG	0
TT$W_REFCNT:
	.WORD	0				;COUNT OF TIMERS IN USE
TT$W_TIMCTRL:
	.WORD	0				;FLAG WORD 


	.ALIGN	QUAD
TT$TIMQUENT:					;TIMER QUE ENTRY FOR MODEM TIMER
	.BLKB	TQE$C_LENGTH			;ALLOCATE BLOCK HERE
	STO_TQE	TQE$W_SIZE,WORD,TQE$C_LENGTH,TT$TIMQUENT
	STO_TQE	TQE$B_TYPE,BYTE,DYN$C_TQE,TT$TIMQUENT
	STO_TQE	TQE$B_RQTYPE,BYTE,TQE$C_SSREPT,TT$TIMQUENT


	.page
;++
; TRANSITION_NOCHECK -  process transition element without the devdepend bit cc heck
; TRANSITION	-	PROCESS TRANSITION ELEMENTS ON MODEM/TIMER STATUS EVENT
; PORT_TRANSITION -	PROCESSES PORT CALLS THEN FALLS INTO TRANSITION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED ON ALL MODEM TRANSITIONS SUCH AS MODEM SIGNAL CHANGES,
; TIMER EXPIRATIONS AND CONTROL. THE TRANSITION ELEMENTS CONTAINED IN THE
; STATE TABLE ASSOCIATED WITH THE CURRENT STATE ARE SCANNED. IF A MATCH IS 
; FOUND, THEN A NEW STATE IS DECLARED. UPON DECLARING A NEW STATE,
; OUTPUT MODEM SIGNALS MAY BE SET OR RESET, TIMERS MAY BE STARTED OR
; CANCELLED AND ACTION ROUTINES MAY BE INVOKED.
;
; PORT_TRANSITION
;	THIS ROUTINE PRE-PROCESSES THE CALLS FROM THE PORT DRIVERS
; TO SCREEN OUT CALLS TO MODEM INIT WITH REF-COUNT NON-ZERO AND CHANGE
; THOSE CALLS INTO SHUTDOWN CALLS.  ALL INPUTS AND OUTPUTS ARE THE SAME
; AS TRANSITION.
;
; INPUTS:
;
;	R1 =	TRANSITION TYPE
;	R2 =	TYPE SPECIFIC ARGUMENT
;			DATASET - NEW RCV MODEM MASK
;	R5 =	UCB ADDRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
PORT_TRANSITION::
	CMPL	#MODEM$C_INIT,R1		; IS THIS AN INIT?
	BNEQ	TRANSITION			; NO THEN DON'T INTERPRET
	MOVL	UCB$L_TT_LOGUCB(R5),R3		; GET THE LOGICAL UCB ADDRESS
	BEQL	TRANSITION			; NO LOGICAL THEN EXIT
	TSTW	UCB$W_REFC(R3)			; ANY REFCOUNT IN LOGICAL
	BEQL	TRANSITION			; NO THEN INIT THE LINE
	MOVZBL	#MODEM$C_SHUTDWN,R1		; ELSE SHUT IT DOWN
TRANSITION::
	TSTW	UCB$W_TT_DS_ST(R5)		; IS MODEM STATE IDLE?
	BNEQ	TRANSITION_NOCHECK		; NO, SO ALLOW CLEANUP TO FINISH
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),END;DON'T BOTHER IF NOT MODEM
TRANSITION_NOCHECK::
	MOVAL	STATE_INIT+MODEM$C_ST_LENGTH,R3	;ROOT OF STATE TABLE + OFFSET
	MOVZWL	UCB$W_TT_DS_ST(R5),R4
	ADDL	R3,R4
	CASE	R1,TYPE=B,<INIT,SHUTDWN,TRAN_LOOP,TRAN_LOOP,TRAN_LOOP>
INIT:
	BSBW	MODEM$LINK_CRB			;LINK INTO CRB CHAIN
	MOVL	#IDLE-STATE_INIT,R2
	BRW	DECLARE_STATE			;INIT MODEM CONTROL
SHUTDWN:
	MOVL	#SHUTDOWN-STATE_INIT,R2		;DECLARE SHUTDOWN STATE
	BRW	DECLARE_STATE			;TRANSITION TO NEW STATE
TRAN_LOOP:
	MOVZBL	(R4),R3				;GET TRANSITION ELEMENT TYPE
	CASE	R3,TYPE=B,<DATASET,TIME,END,DIALTYPE,DZ11,NOMODEM>
						;DISPATCH TO TRANSITION SERVICE
;
END:		;LAST TRANSITION FOR STATE
	RSB

;
TIME:		;TIMEOUT TRANSITION ELEMENT TYPE
	CMPB	#MODEM$C_TIMER,R1		;TIMEOUT TRANSITION CALL
	BNEQ	NEXT_TRAN			;NO PROCESS NEXT ELEMENT
	BRW	NEW_STATE			;DECLARE NEW STATE

;
DATASET:	;DATASET TRANSITION ELEMENT TYPE
	CMPB	#MODEM$C_DATASET,R1		;MODEM INTERRUPT?
	BNEQ	10$				;NO , DONT UPDATE STATUS
	MOVB	R2,UCB$B_TT_DS_RCV(R5)		;UPDATE STATUS
10$:
	MOVZBL	UCB$B_TT_DS_RCV(R5),R2		;GET CURRENT STATUS
	TSTB	MODEM$B_TRAN_ONMASK(R4)		;MASK ACTIVE
	BEQL	15$				;NO
	MCOMB	MODEM$B_TRAN_ONMASK(R4),R3	;GET COMPLEMENT OF MASK
	BICB	R3,R2				;ISOLATE BITS OF INTEREST
	XORB	MODEM$B_TRAN_ONMASK(R4),R2	;TEST IF BOTH ON
	BEQL	20$				;YES
15$:
	MOVZBL	UCB$B_TT_DS_RCV(R5),R2		;GET CURRENT STATUS
	TSTB	MODEM$B_TRAN_OFFMASK(R4)	;MASK ACTIVE
	BEQL	NEXT_TRAN			;NO
	BITB	MODEM$B_TRAN_OFFMASK(R4),R2	;TEST SIGNALS OFF CASE
	BEQL	20$				;YES OFF, DECLARE NEW STATE
	BRW	NEXT_TRAN
20$:
	BRW	NEW_STATE			;ENTER NEW STATE

;
DIALTYPE:
	BITB	MODEM$B_TRAN_ONMASK(R4),-	;CHECK FOR MATCH
		G^TTY$GB_DIALTYP
	BEQL	NEXT_TRAN			;NO MATCH
	BRW	NEW_STATE			;ENTER NEW STATE
DZ11:
	MOVL	UCB$L_CRB(R5),R1		;GET CRB ADDRESS
	CMPB	CRB$B_TT_TYPE(R1),#DT$_DZ11	;IS CONTROLLER A DZ11?
	BNEQ	NEXT_TRAN
	BRW	NEW_STATE
NOMODEM:
	BBS	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),-
		10$				;IF MODEM LINE, CONTINUE
	BRW	NEW_STATE			;LINE NO LONGER MODEM
10$:
	BRB	NEXT_TRAN

;
NEXT_TRAN:	;LOOK AT NEXT TRANSITION ELEMENT
	ADDL	#MODEM$C_TRAN_LENGTH,R4		;POINT TO NEXT ELEMENT
	BRW	TRAN_LOOP


	.page
;++
; DECLARE_STATE	-	DECLARE NEW STATE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO DECLARE A NEW MODEM STATE. IT HANDLES STARTING
; OR CANCELLING TIMERS, SETTING NEW MODEM OUTPUT SIGNALS (VIA THE PORT)
; AND INVOKING ACTION ROUTINES.
;
; INPUTS:
;
;	R2 =	NEW STATE BEING DECLARED
;	R5 =	UCB ADDRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
NEW_STATE:					;ALTERNATE ENTRY FOR CHANGING 
						;STATE FOR TRANSITION ELEMENT
	MOVZWL	MODEM$W_TRAN_NSTATE(R4),R2	;GET OFFSET TO NEXT STATE

DECLARE_STATE:
	MOVW	R2,UCB$W_TT_DS_ST(R5)		;SET NEW STATE
	MOVAL	STATE_INIT,R4			;ROOT OF STATE TABLE
	ADDL	R2,R4				;POINT TO STATE ENTRY
	MOVZWL	MODEM$W_ST_TIMER(R4),R2		;GET TIMER VALUE
	BSBW	MODEM_TIMER			;SET NEW TIMER OR
						;CANCEL PREVIOUS IF ZERO
	MOVZWL	MODEM$B_ST_ONMASK(R4),R2	;GET SET SIGNAL MASK
						;TURN LOW BYTE ON,HIGH BYTE OFF
	BEQL	5$				;NULL FIELDS
	BSBW	TTY$DS_SET			;SET NEW MODEM SIGNAL(S)
5$:
	CVTWL	MODEM$W_ST_ROUTINE(R4),R2	;ACTION ROUTINE PRESENT?
	BEQL	10$				;NO
	MOVAL	STATE_INIT,R0
	ADDL	R0,R2				;COMPUTE ADDRESS OF ACTION ROUTINE
	JSB	(R2)				;INVOKE ACTION ROUTINE
	BLBC	R0,15$				;SPECIAL TRANSITION TYPE IF ERROR
10$:
	MOVL	#MODEM$C_NULL,R1
15$:	BRW	TRANSITION_NOCHECK		;DECLARE NULL TRANSITION IN NEW STATE
						;(TO PROCESS ANY PRESET 
						; MODEM SIGNALS)


	.PAGE
;++
; MODEM_TIMER	-	SET/RESET MASTER MODEM TIMER ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE STARTS OR CANCELS A MODEM PROTECOL TIMER FOR A LINE.
; ONE TQE IS USED TO TIME ALL ACTIVE LINES. THE TQE ONLY REMAINS ACTIVE
; SO LONG AS AT LEAST ONE TIMER IS NEEDED. SUBSEQUENT TIMERS USE THE
; SAME TQE. WHEN ALL CURRENT TIMERS EXPIRE THE TQE IS REMOVED FROM
; THE SYSTEM TIMER QUEUE UNTIL NEEDED AGAIN.
; SINCE TIMERS ARE ONLY NEEDED DURING TRANSITIONS, THIS IS A LOW OVERHEAD
; ACTIVITY. 
;
; INPUTS:
;
;	R2 =	NEW TIMEOUT VALUE OR 0 TO CANCEL ANY OUTSTANDING
;	R5 =	UCB ADDRESS
;
; OUTPUTS:
;	R0-R3	DESTROYED
;--
MODEM_TIMER:
	PUSHL	R4
	MOVL	UCB$L_CRB(R5),R4		;CRB ADDRESS
	TSTL	R2				;CANCEL?
	BEQL	TIMER_CANCEL			;YES

	;NEED TO INIT TIMER FOR LINE
	TSTW	UCB$W_TT_DS_TIM(R5)		; ANY CURRENT TIMER ACTIVE
	BNEQ	5$				; YES THEN JUST CHANGE THE TIME
	INCB	CRB$B_TT_TIMREFC(R4)		; BUMP THE REFCOUNT IN THE CRB
	INCW	TT$W_REFCNT			;BUMP IN USE COUNTER
5$:	MOVW	R2,UCB$W_TT_DS_TIM(R5)	;SET TIME TO WAIT

	BICW	#TIMCTRL$M_CANCEL,TT$W_TIMCTRL	;RESET ANY CANCEL REQUEST
	BBC	#TIMCTRL$V_ACTIVE,TT$W_TIMCTRL,10$ ;TIMER NOT CURRENTLY ACTIVE
	BRB	TIMER_END
10$:						;NEED TO RESTART TIMER
	PUSHL	R5				;SAVE UCB ADDRESS
	MOVAL	TT$TIMQUENT,R5			;
	MOVB	#IPL$_QUEUEAST,TQE$B_RQTYPE(R5)	;SET UP FORK IPL
	PUSHAB	20$				;RETURN ADDRESS
	BRB	30$				;QUEUE FORK

20$:	POPL	R5				;RESTORE UCB ADDRESS
	BISW	#TIMCTRL$M_ACTIVE,TT$W_TIMCTRL	;SHOW TIMER ACTIVE
	BRB	TIMER_END
30$:
	JSB	G^EXE$FORK
	DSBINT	#IPL$_SYNCH			;INTERLOCK TO ENTER TIMER ENTRY
	MOVAB	W^TT$TIMER,TQE$L_FPC(R5)	;SET TIMEOUT ROUTINE ADDRESS
	MOVL	#5000000,TQE$Q_DELTA(R5)	;SET REPEAT AMOUNT (500MS)
	MOVB	#TQE$C_SSREPT,TQE$B_RQTYPE(R5)	;SET REPEATING TYPE
	MOVQ	G^EXE$GQ_SYSTIME,R0		;CURRENT SYSTEM TIME
	ADDL	#5000000,R0			;TIMEOUT DUE IN 500MS
	ADWC	#0,R1				;
	JSB	G^EXE$INSTIMQ			;INSERT IN TIMER QUEUE
	ENBINT					;RESTORE IPL
	RSB

TIMER_CANCEL:
	TSTW	UCB$W_TT_DS_TIM(R5)		; IS THE TIMER
	BEQL	20$				; ACTIVE NO THEN EXIT
	CLRW	UCB$W_TT_DS_TIM(R5)		;RESET TO INDICATE IDLE
	DECB	CRB$B_TT_TIMREFC(R4)		; DECREMENT THE REFCOUNTS
	DECW	TT$W_REFCNT
20$:
	TSTW	TT$W_REFCNT			;ANY ACTIVE TIMERS?
	BNEQ	TIMER_END			;YES

	;NO ACTIVE TIMERS  SO,	
	;TIMER NEEDS TO BE CANCELLED

	BISW	#TIMCTRL$M_CANCEL,TT$W_TIMCTRL	;REQUEST TIMER CANCEL

TIMER_END:
	POPL	R4
	RSB

	.PAGE
;++
; TT$TIMER	-	TIMER INTERRUPT ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS INVOKED UPON THE EXPIRATION OF THE MODEM PROTECOL TQE.
; IT COUNTS DOWN ALL ACTIVE TIMERS AND INVOKES THE TRANSITION
; ROUTINE FOR ANY LINES THAT HAVE TIMED OUT. THE ROUTINE REQUEUES THE
; TQE INTO THE SYSTEM TIMER QUEUE UNLESS ALL ACTIVE TIMERS HAVE
; EXPIRED.
;
; INPUTS:
;
;	R5 =	TQE ADDRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
TT$TIMER:
	PUSHR	#^M<R5>
	MOVAL	TT$L_DIALUP,R4			;GET ROOT OF CRB LIST
10$:
	MOVL	(R4),R4				;GET NEXT CRB ADDRESS
	BEQL	60$				;PROCESS LINES FOR CRB
	TSTB	CRB$B_TT_TIMREFC-CRB$L_TT_MODEM(R4); ANY TIMERS ON THIS LINE?
	BEQL	10$				; NO  THEN EXIT
;
; TIMERS ARE ACTIVE ON THIS CONTROLER
;
	PUSHL	R4				;SAVE TIMER THREAD
	SUBL	#CRB$L_TT_MODEM,R4		;GET ACTUAL CRB ADDRESS

	;PROCESS LINES WITH ACTIVE TIMERS
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R3	;GET ADRESS OF IDB
	MOVZWL	IDB$W_UNITS(R3),R2		; GET THE NUMBER OF UNITS
	DECL	R2				; ON THIS CONTROLER (ZERO BASED)
20$:
	MOVL	IDB$L_UCBLST(R3)[R2],R5		;GET UCB FOR THAT LINE
	BEQL	35$				; NO UNIT THEN GO ON TO THE NEXT
	DSBINT	UCB$B_DIPL(R5)			;INTERLOCK WITH DEVICE INTERRUPTS
	TSTW	UCB$W_TT_DS_TIM(R5)		; DOES THIS UNIT HAVE THE TIMER 
	BNEQ	50$				; YES THEN HANDLE IT
30$:	ENBINT					; NO MORE THEN ENABLE THE INTERRUPTS
35$:	SOBGEQ	R2,20$				; NO THEN GO ON
40$:	POPL	R4				; RESTORE TIMER THREAD
	BRW	10$
;
; DECREMENT/FIRE TIMER REQUESTS
;
50$:	MOVB	#MODEM$C_TIMER,R1		;SET TRANSITION TYPE
	DECW	UCB$W_TT_DS_TIM(R5)		;COUNT DOWN LINE
	BNEQ	30$				;NOT TIME YET
	DECW	TT$W_REFCNT			;
	PUSHR	#^M<R2,R3,R4>			; SAVE SOME REGISTERS
	BSBW	TRANSITION			;INVOKE TRANSITION ROUTINE
	POPR	#^M<R2,R3,R4>
	DECW	CRB$B_TT_TIMREFC(R4)		; DECREMENT THE REFCOUNT
	BNEQ	30$				; CONTINUE
	ENBINT					; RE-ENABLE INTERUPTS IF
	BRB	40$				; NO MORE TIMERS ON THIS 
						; CONTROLER AND MOVE TO THE NEXT
						; CONTROLER
;
; CHECK TO SEE IF WE ARE TO CANCEL THE TIMER OR RE-ENABLE IT
;
60$:	POPR	#^M<R5>
	DSBINT	#31				;INTERLOCK 
	BBC	#TIMCTRL$V_CANCEL,TT$W_TIMCTRL,70$;DONT CANCEL TIMER
	BICW	#<TIMCTRL$M_ACTIVE!TIMCTRL$M_CANCEL>-
		,TT$W_TIMCTRL			;RESET CANCEL +TIMER ACTIVE BITS
	MOVAL	G^EXE$AL_TQENOREPT, R5		; Point R5 to no-repeat TQE
						; thus ending timer thread.
70$:
	ENBINT
	RSB

	.PAGE
;++
; MODEM$LINK_CRB	
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO LINK THE ASSOCIATED CRB OF A UCB
; REQUIRING MODEM CONTROL INTO THE MODEM PROTECOL TIMER QUEUE.
; NOTE THAT THIS QUEUE IS SEPERATE FROM THE DZ-11 SPECIFIC
; MODEM TRANSITION POLLING QUEUE.
;
; INPUTS:
;
;	R5 =	UCB ADDRRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
;
;	CHECK IF CRB NEEDS INSERTION ON MODEM TIMER QUEUE
;
MODEM$LINK_CRB:

	MOVL	UCB$L_CRB(R5),R4		; GET CRB ADDRESS
	MOVAL	TT$L_DIALUP,R1			; ADDRESS OF LIST HEAD
	MOVAL	CRB$L_TT_MODEM(R4),R3		; GET CRB THREAD
	MOVL	R1,R2
10$:
	CMPL	(R2),R3				; CRB ON LIST
	BEQL	20$				; YES
	MOVL	(R2),R2				; POINT TO NEXT
	BNEQ	10$				; IF NOT END, LOOK AGAIN
	MOVL	(R1),(R3)			; LINK AT LIST HEAD
	MOVL	R3,(R1)
20$:	
	BSBW	TTY$SET_MODEM			; INVOKE ANY PORT SPECIFIC SETUP
	RSB

	.page
	.sbttl	MODEM STATE TABLES
;++
; MODEM CONTROL STATE TABLES
;
; FUNCTIONAL DESCRIPTION:
;
;	 THIS TABLE CONTAINS STATE ENTRIES. EACH STATE CORRESPONDS TO
; A MODEM PROTECOL STATE. EACH STATE ENTRY CONSISTS OF A MODEM SIGNAL
; MASK TO BE SET ON STATE ENTRY, AN INITIAL TIMER VALUE TO BE STARTED ON 
; STATE ENTRY AND AN OPTIONAL ACTION ROUTINE.
;	FOLLOWING THE STATE ENTRY ARE TRANSITION ELEMENTS. ON ANY
; TRANSITION : TIMEOUT, MODEM INTERRUPT, OR PROGRAM DECLARED, EACH
; TRANSITION ELEMENT IS PROCESSED SEQUENTIALLY. THE LAST TRANSITION ELEMENT
; IS ALWAYS AN END TRANSITION ELEMENT WHICH SIGNALS THAT
; NO TRANSITION OCCURS IF IT IS PROCESSED. OTHER TRANSITION ELEMENT TYPES
; MAKE CONDITIONAL TESTS AND MAY DECLARE A NEW STATE IF THE APPROPRIATE
; CONDITIONS HOLD TRUE. 
;--


;	MODEM STATE MACRO DEFINITIONS
;

	.macro	state	name,onmask=0,offmask=0,timer,routine
name:
	.byte	onmask
	.byte	offmask
	.if	nb	timer
	.word	<timer*2>
	.if_false
	.word	0
	.endc
	.if	nb	routine
	.word	routine-state_init
	.if_false
	.word	0
	.endc
	.endm	state

	.macro	tran	type,nstate,onmask=0,offmask=0
	.if	idn type,end
	.byte	modem$c_tran_end
	.if_false
	.byte	modem$c_tran_'type',0
	.word	nstate-state_init
	.byte	offmask
	.byte	onmask
	.endc
	.endm	tran

	.PAGE

STATE_INIT:

;
; LINE NOT UNDER MODEM CONTROL
;
	STATE	OFF			
	TRAN	END

;
; INITIAL MODEM STATE
;
	STATE	IDLE,OFFMASK=<TT$M_DS_DTR!TT$M_DS_RTS>,TIMER=2
	TRAN	DIALTYPE,ONMASK=02,NSTATE=RINGWAIT
	TRAN	TIME,NSTATE=WAIT
	TRAN	END

;
; WAIT FOR RING PRIOR TO SETTING DTR
;

	STATE	RINGWAIT
	TRAN	DATASET,ONMASK=<TT$M_DS_RING>,NSTATE=INIT2
	TRAN	END

;
; WAIT FOR DTR AND RTS
; (IF DZ-11 GO DO SUBSET SUPPORT)
;
	STATE	WAIT,ONMASK=<TT$M_DS_DTR!TT$M_DS_RTS>
	TRAN	DZ11,NSTATE=DZWAIT
	TRAN	DATASET,ONMASK=TT$M_DS_DSR,NSTATE=INIT1
	TRAN	END

;
; DZ-11 SUBSET SUPPORT
; WAIT FOR CARRIER OR RING
;
	STATE	DZWAIT
	TRAN	DATASET,ONMASK=<TT$M_DS_CARRIER>,NSTATE=TRANSMIT0
	TRAN	DATASET,ONMASK=<TT$M_DS_RING>,NSTATE=INIT2
	TRAN	END

;
; DELAY 
;
	STATE	INIT1,TIMER=1
	TRAN	TIME,NSTATE=INIT2
	TRAN	END

;
; START TIMER AND WAIT FOR CTS AND CARRIER
; IF TIMER EXPIRES, SHUTDOWN LINE
;
	STATE	INIT2,ONMASK=<TT$M_DS_DTR!TT$M_DS_RTS>,TIMER=30
	TRAN	TIME,NSTATE=SHUTDOWN
	TRAN	DATASET,ONMASK=<TT$M_DS_CTS!TT$M_DS_CARRIER!TT$M_DS_DSR>,-
		NSTATE=TRANSMIT0
	TRAN	END

;
; TRANSMIT0 STATE (SIGNAL CONNECT AND ALLOW TIME TO ASSIGN CHANNELS)
; 
	STATE	TRANSMIT0,ROUTINE=LOGIN,TIMER=30
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=SHUTDOWN
	TRAN	DATASET,OFFMASK=TT$M_DS_CARRIER,NSTATE=TRANSMIT1
	TRAN 	TIME,NSTATE=TRANSMIT
	TRAN	END
;
; NORMAL TRANSMIT STATE 
; 
	STATE	TRANSMIT,ROUTINE=VERIFY	; ROUTINE VERIFY WILL SHUTDOWN IF REFC=0
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=SHUTDOWN
	TRAN	DATASET,OFFMASK=TT$M_DS_CARRIER,NSTATE=TRANSMIT1
	TRAN	DATASET,OFFMASK=TT$M_DS_CTS,NSTATE=CTSLOW
	TRAN	END

;
; LOSS OF CARRIER DETECTED
;
	STATE	TRANSMIT1,TIMER=2,ROUTINE=CTSHIGH
	TRAN	DIALTYPE,ONMASK=01,NSTATE=SHUTDOWN
	TRAN	TIME,NSTATE=SHUTDOWN
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=SHUTDOWN
	TRAN	DATASET,ONMASK=<TT$M_DS_CARRIER!TT$M_DS_CTS>,NSTATE=TRANSMIT
	TRAN	END

;
; DELAY PRIOR TO COMPLETE SHUTDOWN
;
	STATE	SHUTDOWN,TIMER=1,OFFMASK=TT$M_DS_DTR,ROUTINE=LOGOUT
	TRAN	TIME,NSTATE=SHUT1
	TRAN	END

;
; COMPLETE SHUTDOWN
; AND THEN REINIT
;
	STATE	SHUT1,TIMER=2
	TRAN	NOMODEM,NSTATE=OFF
	TRAN	TIME,NSTATE=IDLE
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=IDLE
	TRAN	END
;
; CTSLOW
; STOP SENDING DATA AND WAIT FOR CTS TO GO HIGH
;
	STATE	CTSLOW,ROUTINE=LOSTCTS
	TRAN	DATASET,ONMASK=TT$M_DS_CTS,NSTATE=TRANSMIT
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=SHUTDOWN
	TRAN	DATASET,OFFMASK=TT$M_DS_CARRIER,NSTATE=TRANSMIT1
	TRAN	END

	.PAGE
	.SBTTL	MODEM ACTION ROUTINES
;

;	THESE ROUTINES ACT AS ACTION ROUTINES FOR MODEM CONNECTION
; 	AND DISCONECTION. ON CONNECTION THE REMOTE BIT IS SET.
;	ON DISCONNECT A CONTROL Y AST IS FIRED WITH HANGUP STATUS
;	TO SIGNAL THE CLI. ALSO ANY OUTSTANDING ATTENTION ASTS ARE
; 	FIRED.
;
LOGIN:
	MOVL	UCB$L_TT_LOGUCB(R5),R1		; GET LUCB ADDRESS
	BISL	#TT$M_REMOTE,UCB$L_DEVDEPEND(R5); UPDATE CHARACTERISTIC 
	BISL	#TT$M_REMOTE,UCB$L_DEVDEPEND(R1)
	BSBB	CTSHIGH				; SAY CTS IS HIGH
	BRB	ACTION_EXIT

LOGOUT:
	BSBW	CTSHIGH
	MOVL	#TTY$V_FD_DISCONNECT,R4		; SIGNAL HANGUP CONDITION
	BSBW	TTY$CRE_FORK
	BRB	ACTION_EXIT
	
LOSTCTS:
	BISL	#TTY$M_ST_CTSLOW,UCB$Q_TT_STATE+4(R5); SAY CTS IS LOW
	BSBW	TTY$STOP
	BRB	ACTION_EXIT
CTSHIGH:
	BBSC	#TTY$V_ST_CTSLOW,UCB$Q_TT_STATE+4(R5),10$; SAY CTS IS HIGH
	BRW	TTY$RESUME
10$:	BSBW	TTY$RESUME
	BSBW	TTY$STARTOUTPUT

ACTION_EXIT:
	MOVZBL	#SS$_NORMAL,R0
	RSB

;
; VERIFY THAT UNIT HAS CHANNELS ASSIGNED
;
VERIFY:
	BSBB	CTSHIGH				; SAY CTS IS HIGH
	MOVL	UCB$L_TT_LOGUCB(R5),R1		; GET LUCB ADDRESS
	TSTW	UCB$W_REFC(R1)			; CHANNELS ASSIGNED
	BNEQ	ACTION_EXIT			; YES, RETURN SUCCESS
	CLRL	R0				; SIGNAL FAILURE
	MOVZBL	#MODEM$C_SHUTDWN,R1		; AND RETURN TRANSITION CODE IN R1
	RSB


	.SBTTL	CLASS_MODEM_DIS - CLASS SERVICE TO FORCE MODEM SHUTDOWN
	.SBTTL	TTY$CLASS_DISCONNECT - CLASS SERVICE TO SIGNAL HANGUP CONDITION
;++
; CLASS_MODEM_DIS
;
; FUNCTION:
;	WILL FORCE MODEM SIGNALS TO HANGUP THE LINE AND SIGNAL HANGUP STATUS
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4 DESTROYED
;	R0,R1,R2 ARE PRESERVED
;--
CLASS_MODEM_DIS::			; INITIATE MODEM DISCONNECT
	PUSHR	#^M<R0,R1,R2>
	MOVL	#MODEM$C_SHUTDWN,R1	; SIGNAL RESET
	BSBW	TRANSITION		; INVOKE MODEM TRANSITION ROUTINE
	POPR	#^M<R0,R1,R2>
	RSB				; RESTORE THE REGISTERS AND RETURN

; GENERALIZED CLASS ROUTINE TO SIGNAL HANGUP STATUS

TTY$CLASS_DISCONNECT::
	PUSHR	#^M<R0,R1,R2>
	MOVL	UCB$L_TT_LOGUCB(R5),R4		; GET THE LOGICAL UCB TO CHECK
	TSTW	UCB$W_REFC(R4)			; THE REFCOUNT.
	BNEQ	5$				; IF CHANNELS THEN AST'S TO FIRE OR PROCESSES TO KEEP
	CLRL	R0				; ALWAYS INDICATE HANGUP IF
	BSBW	TTY$DISCONNECT			; NO CHANNELS THEN NONE OF THE ABOFE
5$:	BSBW	LOGOUT				; AND QUEUE FORK TO SIGNAL HANGUP STATUS
	POPR	#^M<R0,R1,R2>
	RSB

	.SBTTL	End of module

TT_END::				; End of Terminal Class Driver
	.END

