	.TITLE	NETCNFACT  - Configuration data base access action routines
	.IDENT	'V04-000'
	.DEFAULT DISPLACEMENT,LONG

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

; FACILITY:	NETWORK ACP
;
; ABSTRACT:
;		This module provides support to the NETACP database management
;		including database entry insertion and action routines to
;		retrieve data for parameters which are not stored in any of 
;		the CNF control blocks.  
;
; ENVIRONMENT:
;		The module runs in kernel mode and at possibly elevated IPL.
;		It is therefore locked into the ACP's virtural address space
;		in order to prevent the need for paging.
;
;		Since the ACP is work-queue driven, and since it is the ACP
;		that modifies the structure of the non-paged pool data base
;		including the RCB (actually a VCB) and the private structures
;		hanging off of the RCB, there is no need to obtain the system
;		data base mutex -- no races can occur.   However, it is
;		necessary to raise IPL in order to stop any races with
;		NETDRIVER.
;		
;
; AUTHOR:	A.Eldridge	14-Feb-80
;
; MODIFIED BY:
;
;	V03-038	PRB0336		Paul Beck	24-Jun-1984  14:04
;		Allow SCSSYSTEMID match in area 1 without area in SCSSYSTEMID
;		SYSGEN parameter.
;
;	V03-037	RNG0037		Rod Gamache		18-Jun-1984
;		Add logging of Data Base Entry re-used to log_counters routine.
;		Fix termination of 'adjacency vector' search on NDI scan
;		when max address is 1023.
;
;	V03-036	PRB0326		Paul Beck	28-Mar-1984  15:51
;		Use SYS$SYSTEM instead of SYS$SYSROOT:[SYSEXE] for the default 
;		file spec in the FAB, to allow search lists to work correctly.
;		Fix NDI_SCAN routine when used with LOOP NODES.
;
;	V03-035	RNG0035		Rod Gamache		15-Mar-1984
;		Fix routines that access new LLI structure to get the XWB
;		address from the LLI first.
;
;	V03-034	ADE0054		Alan D. Eldridge	16-Feb-1984
;		Make changes to support converting the LLI to a 'real' database.
;
;	V03-033	PRB0312		Paul Beck	4-Feb-1984  19:12
;		Require local node name match SYSGEN parameters SCSNODEL/H
;		if they are defined.
;
;	V03-032	PRB0310		Paul Beck	26-Jan-1984  11:18
;		Strip trailing ";" from parsed object filename string if it 
;		wasn't present in OBI,S,FID. This allows NETSERVER to make use 
;		of the installed version of an image (image activator will ignore
;		installed version if explicit version number is specified).
;		Also remove reference to NET$T_TSKFAB, no longer used.
;
;	V031	RNG0031		Rod Gamache	13-Jan-1984
;		Fix problem in previous fix, where it was attempting to
;		delete the "dummy NDI".
;
;	V030	RNG0030		Rod Gamache	14-Nov-1983
;		Fix deletion of NDI data block when entry was re-inserted
;		into binary trees.
;
;	V029	TMH0029		Tim Halvorsen	10-Jul-1983
;		Allow normal NDI entries to use the CIRCUIT parameter
;		so that a user can explicitly specify the path to a
;		node.  This is different than loop nodes, which always
;		use our own address so that they are looped back to us,
;		but similar in that the CIRCUIT parameter is used.
;		Add support for local alias addresses.
;
;	V028	TMH0028		Tim Halvorsen	17-May-1983
;		If we are an endnode, then return the designated router
;		for the nearest level 2 router in the area database.
;
;	V027	TMH0027		Tim Halvorsen	20-Apr-1983
;		Add Service (DLE) database support.
;		Don't return dummy NDI in special NDI scanner if the
;		starting CNF is non-zero or not the CNR.
;
;	V026	RNG0026		Rod Gamache	29-Mar-1983
;		Add code to support the binary balanced trees for the
;		NDI database.
;
;	V025	TMH0025		Tim Halvorsen	03-Mar-1983
;		Use default filespec of SYS$SYSTEM for object procedure
;		name if object name starts with a "$".
;		Handle new Level routing routing enable flag in RCB.
;		Always return "unreachable" if we cannot determine the
;		"next node to destination" of a remote node.
;		For non-area routers, make area database consist of the
;		local area, with cost/hops/nexthop referring to the "nearest
;		level 2 router".
;
;	V024	TMH0024		Tim Halvorsen	14-Feb-1983
;		Remove node proxy access parameter.
;		Add code so that the next hop on way to remote areas are
;		returned with "next hop to destination" and "output circuit".
;		Add endnode key defaulting.
;		Do not check new NDI address against executor max address
;		if the NDI refers to another area, since our max address
;		doesn't apply to other areas.
;		Add support for EPIDs.
;
;	V023	TMH0023		Tim Halvorsen	08-Jan-1983
;		Fix some subroutine calls which were linked out of range.
;
;	V022	TMH0022		Tim Halvorsen	17-Dec-1982
;		Fix logical link scanning (for things like "active
;		links", etc.) so that it correctly matches the entire
;		node address, including area number.
;		Add LLI PNA action routine, which suppresses the area
;		number in the node address if necessary.
;		Reformat TAD search key as well as ADD search key so
;		that addresses without areas matching the corresponding
;		NDI object key.
;		Optimize NDI_BY_ADD a bit.
;
;	V021	TMH0021		Tim Halvorsen	05-Dec-1982
;		Fix code which re-defines an NDI so that it correctly
;		adjusts the NDI vector.
;		Fix SHOW NODE nnn (by number).
;		Add NNN parameter, which is the node name corresponding
;		to NND (to speed up the SHOW KNOWN NODES request).
;
;	V020	TMH0020		Tim Halvorsen	14-Oct-1982
;		Add area routing support.
;		If it cannot be determined if a node is reachable or not
;		(because we are an endnode, or because its in another area),
;		then return failure for the REA parameter ("don't know").
;
;	V019	TMH0019		Tim Halvorsen	01-Oct-1982
;		Make Phase II nodes 1 hop away, even though the minimum
;		cost/hops vector says it's unreachable (it's unreachable
;		in the vector so that the routing messages to other nodes
;		reflect it).
;
;	V018	TMH0018		Tim Halvorsen	16-Sep-1982
;		Change name of routine to reset automatic counter timers.
;		Add support for AJI Adjacency database.
;
;	V017	TMH0017		Tim Halvorsen	01-Jul-1982
;		Add node action routine NND, to return the node address
;		of the next node in the path to the remote node.
;		Add executor PHA action routine, to return the NI physical
;		address used by the current node.
;		Modify TEST_REACH to return the ADJ index, rather than
;		the LPD index, and modify all callers to lookup the
;		appropriate information in the ADJ block.
;
;	V016	TMH0016		Tim Halvorsen	30-Jun-1982
;		Add entry point for applying a set of default values
;		given a default table address.
;
;	V015	TMH0015		Tim Halvorsen	16-Jun-1982
;		Add support for SPI database.
;		Fix a second bug in the logical link collating sequence,
;		which caused a loop in the database traversal.
;
;	V014	TMH0014		Tim Halvorsen	04-Apr-1982
;		Remove all code specific to CRI and PLI databases, and
;		move it into a new module NETCNFDLL.
;		Remove all explicit displacement specifiers from operands,
;		and make the default = word for the entire module.
;		Change all CNF action routines to use the new action routine
;		interface (NETCNF now automatically allocates a TMP buffer).
;		Remove obsolete NUL action routines.
;		Rename CNF$T_MASK to CNF$L_MASK.
;		Fix bug in logical link collating order, which sometimes
;		caused a loop (sometimes finite) in the SHOW KNOWN LINKS
;		display.
;		Rewrite NET$TEST_REACH to use NET$FIND_LPD to get LPD address.
;
;	V013	TMH0013		Tim Halvorsen	27-Mar-1982
;		Fix code to translate an NMA parameter code returned by
;		a datalink driver validation error to a NFB code.
;
;	V02-12	ADE0052		A.Eldridge	25-Jan-82
;		Get the number of DMC receive buffers from the PLI database
;		instead of the CRI database.
;
;	V02-11	ADE0051		A.Eldridge	22-Jan-82
;		Disallow NFB$C_NDI_PRX values of "both" or "outbound" if
;		explicit outbound defaults exist.
;
;	V02-10	ADE0050		A.Eldridge	19-Jan-82
;		Added routine NET$APPLY_DFLT which applies default values
;		to selected CNF parameters.
;
;	V02-09	ADE0044		A.Eldridge	06-Jan-82
;		Removed the 'retransmit timer' (RTT) parameter from the
;		circuit database
;
;	V02-08	ADE0043		A.Eldridge	31-Dec-81
;		Rename the CI DECnet class driver mnemonic to "CN".
;
;	V02-07	ADE0042		A.Eldridge	22-Dec-81
;		Added support for the logical-link "RID" field
;
;	V02-06	ADE0041		A.Eldridge	14-Dec-81
;		Added support for line counters.
;
;	V02-05	ADE0040		A.Eldridge	11-Dec-81
;		Fix node counter bug that was returning the Executor node
;		counters for nodes which are unreachable.
;
;	V02-04	ADE0030		A.Eldridge	30-Nov-81
;		Added support for zero counter event.
;
;	V02-03	ADE0029		A.Eldridge	21-Jul-81
;		Replace datalink (DLI) database with circuit (CRI) and
;		phsyical line (PLI) databases.
;
;	V02-02	ADE0028		A.Eldridge	21-Jul-81
;		Updated to support modified CNF data base interface.
;
;

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$FABDEF		; File Access Block
	$NAMDEF		; File name block
	$JPIDEF		; $GETJPI definitions

	$NFBDEF		; Network Function Block (ACP control QIO definitions)
	$NMADEF		; Network Management (NICE protocol) definitions
	$EVCDEF		; DECnet Event logging symbols
	$DRDEF		; Disconnect reason codes
	$CNRDEF		; Configuration Root block
	$CNFDEF		; Configuration data block
	$ICBDEF		; Internal Connect Block
	$LLIDEF		; Logical link information block
	$LNIDEF		; Local node information
	$LPDDEF		; Logical path descriptor
	$ADJDEF		; Adjacency control block
	$LTBDEF		; Logical-link table
	$NETSYMDEF	; Miscellaneous network symbols
	$NETUPDDEF	; Symbols used in private NETACP interface to NETDRIVER
	$NSPMSGDEF	; DNA architecture definitions & message formats
	$NDIDEF		; Node information block
	$RCBDEF		; Routing Control Block (analogous to Volume Control
			; block)
	$WQEDEF		; Work Queue Element
	$XWBDEF		; Network Window Block -- logical-link context block
	$DWBDEF		; DLE window block
	$UCBDEF		; UCB definitions

	UCB$Q_DWB_LIST = UCB$C_LENGTH	; && TEMP - MUST BE SAME AS NDDRIVER

;
; EQUATED SYMBOLS:
;

NDI_ADD = CNF$C_LENGTH+NDI$W_ADD 	; Define symbol for convenience

;
; Define special CNF flags for each database
;
NDI_V_LOOP	= CNF$V_FLG_MRK1	; Set for "loop" nodes
NDI_V_LOCAL	= CNF$V_FLG_MRK2	; Set for the "local" node
NDI_V_MARKER	= CNF$V_FLG_MRK3	; Set for "marker" node

;
; OWN STORAGE
;

	.PSECT	NET_IMPURE,WRT,NOEXE,LONG

NDI_L_NACS:	.LONG	0		; Remember number of non-null access
NDI_Z_COL:	.BLKB	15+3		; Size of collate string, Device name
					;  + node id + size.
		.ALIGN	LONG
NDI_Q_NAME:	.QUAD	0		; Descriptor of new nodename
NDI_Q_LNAME:	.QUAD	0		; Descriptor of new logical nodename
NDI_LNAMEBUF:	.BLKB	16		; Buffer for build logical node-name
IOSB:		.BLKB	8		; I/O status block


	.PSECT	NET_PURE,NOWRT,NOEXE,LONG


SYSNODE_DESC:	.ASCID	'SYS$NODE'	; Descriptor for logical name
CLUNODE_DESC:	.ASCID	'SYS$CLUSTER_NODE' ; Descriptor for logical name

NDI_NLOGIN_VEC:				; Vector of NDI nonpriv login field id's
		.CNFFLD	ndi,s,nus	;  nonpriv user
		.CNFFLD	ndi,s,npw	;  nonpriv password
		.CNFFLD	ndi,s,nac	;  nonpriv account
		.LONG	0		; Terminate the vecvtor

NDI_PLOGIN_VEC:				; Vector of NDI priv login field id's
		.CNFFLD	ndi,s,pus	;  priv user
		.CNFFLD	ndi,s,ppw	;  priv password
		.CNFFLD	ndi,s,pac	;  priv account
		.LONG	0		; Terminate the vecvtor

OBI_LOGIN_VEC:				; Vector of OBI login field id's
		.CNFFLD	obi,s,usr	;  user
		.CNFFLD	obi,s,psw	;  password
		.CNFFLD	obi,s,acc	;  account
		.LONG	0		; Terminate the vecvtor



;
;  The following macroes build a conversion table for formatting counters
;  into NICE format.  Each counter i.d. contain is bit encoded to contain
;  formatting information as follows:
;
;   15   14    13  12   11	    0		Bit
;
;  < 1 >< width >< 0 >< counter i.d. >		Field
;
;
	$WIDTH_B = 1	; Counter width specifier for bytes
	$WIDTH_W = 2	; Counter width specifier for words
	$WIDTH_L = 3	; Counter width specifier for longwords

NET$C_NMACNT_SLZ = <1@15>!<<$WIDTH_W>@13>!0	; Seconds since last zeroed

.MACRO $COUNT_ENT  base,nice,pre,mod,count,width; Insert table entry
						;
	.WORD	<1@15>!<<$WIDTH_'width'>@13>!-	; Counter flag, Counter width
		<NMA$C_'nice'_'count'>		; Nice counter i.d.
	.WORD	'pre'$'width'_'mod''count' -	; Offset into internal structure
		- base				; minus internal structure base
.ENDM	$COUNT_ENT				;


.MACRO	$COUNT_TAB  base,nice,pre,mod,list	; Create counter formatting table
						;
	.IRP	A,<list>			;
		$COUNT_ENT  base,nice,pre,mod,A	; Insert table entry
	.ENDR					;
						;
	.LONG	0				; Terminate the table

.ENDM	$COUNT_TAB
	


CNT_FMT_BUFSIZ = 100		; Size required to accomodate largest formatted
				; counter buffer

NDC$L_MRC = NDC$L_PRC		;& Setup synonyms until NETNPAGED.MDL is fixed
NDC$L_MSN = NDC$L_PSN

NDC_CNT_TAB:			; Common node counter table

    $COUNT_TAB  NDC$L_ABS_TIM,CTNOD,NDC,,-
		<-
		<BRC,L>,-	; Bytes received
		<BSN,L>,-	; Bytes sent
		<MRC,L>,-	; Packets received
		<MSN,L>,-	; Packets sent
		<CRC,W>,-	; Connects received
		<CSN,W>,-	; Connects sent
		<RTO,W>,-	; Response timeouts
		<RSE,W>,-	; Transmitted connect rejects due to resource
		-		; errors
    >

RCB_CNT_TAB:			; Local node counters

    $COUNT_TAB	RCB$L_ABS_TIM,CTNOD,RCB,CNT_,-
		<-
		<MLL,W>,-	; Maximum logical links active
		<APL,B>,-	; Aged packet loss
		<NUL,W>,-	; Node unreachable packet loss
		<NOL,B>,-	; Node out-of-range packet loss
		<OPL,B>,-	; Oversized packet loss
		<PFE,B>,-	; Packet format error
		<RUL,B>,-	; Partial routing update loss
		<VER,B>,-	; Verification rejects
	-;	<XRE,W>,-	; Xmitted connect resource errors 
    >

	.PSECT	NET_IMPURE,WRT,NOEXE


UNAMES:		.LONG	0		; Returns resultant user name length
UNAME:		.BLKB	12		; Returns user name
PNAMES:		.LONG	0		; Returns resultant process name length
PNAME:		.BLKB	16		; Returns process name
		.ALIGN	LONG

ITEM_LIST:				; $GETJPI item list for logical links
		.WORD	12		; Size of username buffer
		.WORD	JPI$_USERNAME	; I.d. of username parameter
		.ADDRESS UNAME		; Address of username buffer
		.ADDRESS UNAMES		; Address of buffer to return length

		.WORD	15		; Size of process name buffer
		.WORD	JPI$_PRCNAM	; I.d. of process name parameter
		.ADDRESS PNAME		; Address of process name buffer
		.ADDRESS PNAMES		; Address of buffer to return length

		.LONG	0		; Terminate the list


NET$T_PRSNAM:	$NAM	ESS =  255
NET$T_SYSFAB:	$FAB	DNM = <SYS$SYSTEM:.COM>,-
			NAM =  NET$T_PRSNAM

	.PSECT	NET_CODE,NOWRT,EXE

	.SBTTL	NET$SCAN_xxx - DEFAULT DATABASE SCANNER
;+
; NET$SCAN_xxx - Scan database
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  These routines establish
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;  ***  These routines must be abortable via a RET  ***
;---

NET$SCAN_LLI::				; Logical-link scanner co-routine
NET$SCAN_LNI::				; Local node CNF scanner co-routine
NET$SCAN_OBI::				; Object CNF scanner co-routine
NET$SCAN_EFI::				; Event filter CNF scanner co-routine
NET$SCAN_ESI::				; Event sink CNF scanner co-routine
NET$SCAN_SPI::				; Server process CNF scanner co-routine
DEFAULT_SCAN::				; Default CNF scanner co-routine

	ASSUME	CNF$L_FLINK  EQ  0
	ASSUME	CNF$L_FLINK  EQ  CNR$L_FLINK
	ASSUME	CNF$B_FLG    EQ  CNR$B_FLG

	TSTL	R10			; Already pointing to a CNF ?
	BNEQ	10$			; If NEQ then yes
	MOVAB	CNR$L_FLINK(R11),R10	; Get address of ptr to 1st CNF
10$:	MOVL	#1,R0			; Indicate success
20$:	JSB	@(SP)+			; Call back our caller
	$DISPATCH  R0,<-

	    <CNF$_ADVANCE,   30$>	-; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 40$>	-; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      50$>	-; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 60$>	-; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

30$:	MOVL	CNF$L_FLINK(R10),R10	; Advance to next CNF
	BBC	#CNF$V_FLG_CNR,-	;
		    CNF$B_FLG(R10),10$	; If BC then R10 is not the CNR
	CLRL	R0			; Say "no more CNFs"
	BRB	20$			; Call back with the bad news
40$:	MOVL	CNF$L_BLINK(R10),R10	; Go back to previous CNF
	BRB	60$			; Continue
50$:	CLRL	R10			; Nullify CNF pointer
60$:	RSB				; Return to caller, terminate dialogue

	.SBTTL	NDIDEF_SCAN - DEFAULT NDI DATABASE SCANNER
;+
; NDIDEF_SCAN - Default NDI database scanner
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  ThIS routine establishS
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;	R1,R2 are destroyed.
;
;  ***  These routines must be abortable via a RET  ***
;---

NDIDEF_SCAN::				; Default NDI scanner co-routine
	;
	;   Allocate some storage on the stack to hold the last NDI
	;   returned to the caller.  This makes backing up to the
	;   previous entry very easy.
	;
		ORIGAP = 00
		CALLER = 04
		BTECOR = 08
		TEMPRG = 12
		CNFADD = 20
		NODADD = 24
	CLRQ	-(SP)			; CNFADD(AP) = CNF address.
					; NODADD(AP) = Node number (in vector)
	CLRQ	-(SP)			; Make room on stack for temp save regs
					; REF: TEMPRG(AP)
	PUSHAB	NET$TRAVERSE_NDI	; Push next co-routine address
					; REF: BTECOR(AP)
	CLRL	-(SP)			; Return address to caller
					; REF: CALLER(AP)
	PUSHL	AP			; Save the AP
	MOVL	SP,AP			; Save current stack pointer
	PUSHL	28(SP)			; Copy return address to caller
	;
	;
	;   Initialize "last CNF" pointer.  This is the pointer to the last
	;   CNF processed and may actually be the CNR.
	;
	TSTL	R10			; Is there a current NDI
	BNEQ	5$			; If NEQ then yes
	MOVL	R11,R10			; Else start at the head of the list
5$:	;
	;   Return to caller with "initialization complete"
	;
	MOVL	#1,R0			; Initialization successful
	JSB	@(SP)+			; Call back the caller, on return
					; R0 = function to perform
	;
	;   The following code insures that if we are not called recursively,
	;   then we will always find the next NDI after the last one.
	;
	CMPL	R10,R11			; Are we starting from beginning?
	BEQL	8$			; Br if yes, okay to proceed
	MOVL	(SP)+,CALLER(AP)	; Save caller's return address
	MOVL	R10,CNFADD(AP)		; Save last CNF returned
	MOVW	CNF$W_ID(R10),NODADD(AP); Save last node address returned
	MOVAB	NET$TRAVERSE_ALT,BTECOR(AP) ; Set address of resume code
	MOVQ	R7,TEMPRG(AP)		; Save R7, R8
	;
	;  Get the collating value for this NDI (R10)
	;
	MOVAB	NDI_Z_COL,R8		; Get address of collate buffer
	MOVL	R8,R3			; Copy output buffer address
	
	PUSHR	#^M<R0,R1,R2,R5,R6,R8,R9> ; Save registers
	BSBW	NET$NDI_S_COL		; Get the collating value
	POPR	#^M<R0,R1,R2,R5,R6,R8,R9> ; Restore registers

	SUBL3	R8,R3,R7		; Calculate length of collate string

	PUSHAB	W^160$			; Push address of return
	JSB	NET$RESUME_NDI		; Call routine to build up stack
	MOVQ	TEMPRG(AP),R7		; Restore R7, R8
	BLBC	R0,20$			; Br if failure to proceed
	BBS	#1,R0,10$		; Br if take current
	MOVAB	160$,R1			; Store return address
	BRW	140$			; And continue processing
	;
	;   Engage in a co-routine dialogue with the user.  The scanner half
	;   of the dialogue owns the stack until the calling routine calls
	;   back with any function code other than CNF$_ADVANCE;  the other
	;   function codes causes the scanner to return to the caller with a
	;   clean stack thus terminating the co-routine dialogue.
	;
	;   Register useage:
	;	R1 may be destroyed, by this routine, but must be preserved
	;	on calls to the co-routine calls to the SCAN routine. Therefore
	;	on initial input R1 will be zero, but will be what the caller
	;	requires on output. The same goes for R2.
	;
8$:	MOVL	(SP)+,CALLER(AP)	; Save callers address on stack
	MOVQ	TEMPRG(AP),R1		; Restore R1,R2
	$DISPATCH  R0,-			; Dispatch on function code returned by
	<-				; co-routine
	    <CNF$_ADVANCE,   100$>,-	; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 200$>,-	; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      300$>,-	; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 400$>,-	; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

10$:	MOVL	#1,R0			; Indicate success

20$:	MOVQ	R1,TEMPRG(AP)		; Save R1,R2
	JSB	@CALLER(AP)		; Call back the caller with status
	BRB	8$

100$:	;
	;   Advance to the next CNF.
	;
	MOVL	R10,CNFADD(AP)		; Save last CNF given back to caller
	MOVW	CNF$W_ID(R10),NODADD(AP); Save last node # given to caller
	;
	;   Skip to next node in data base
	;
140$:	JSB	@BTECOR(AP)		; Skip to next node, call BTE co-routine
160$:	BLBC	R0,20$			; Br if error, don't pop stack
	MOVL	(SP)+,BTECOR(AP)	; Else, save return address
	BBS	#NDI_V_MARKER,-		; Never return the marker CNF
		CNF$B_FLG(R10),140$
	BRB	10$			; And return CNF

200$:	;
	;   The caller wants to take the previous CNF
	;
	MOVL	CNFADD(AP),R10		; Get previous CNF address
	BNEQ	400$			; Branch if none
	;
	;   The caller wants to call it quits
	;
300$:	CLRL	R10			; Nullify CNF pointer
	;
	;   The caller is done with the scan and wants the stack back.
	;
400$:	MOVL	CALLER(AP),R0		; Get caller's return address
	MOVL	AP,SP			; Restore original stack pointer
	POPL	AP			; Restore original AP
	ADDL	#7*4,SP			; Pop scratch storage
	JMP	(R0)			; Return to caller


	.SBTTL	NET$SCAN_NDI - SCAN NDI DATABASE
;+
; NET$SCAN_NDI - Scan NDI database
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  These routines establish
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;	R1,R2 are destroyed.
;
;  ***  These routines must be abortable via a RET  ***
;---

NET$SCAN_NDI::				; Find next NDI block
	
	ASSUME	CNF$L_FLINK  EQ  0
	ASSUME	CNF$L_FLINK  EQ  CNR$L_FLINK
	ASSUME	CNF$B_FLG    EQ  CNR$B_FLG

	BBC	#NET$V_INTRNL,-		; If BC then external and so we are
		NET$GL_FLAGS,10$	; interested in "phantom" NDI CNFs
	BRW	NDIDEF_SCAN		; Else, only "real" NDI CNFs
10$:	;
	;   Allocate some storage on the stack to hold the last NDI
	;   returned to the caller.  This makes backing up to the
	;   previous entry very easy.
	;
		ORIGAP = 00
		CALLER = 04
		BTECOR = 08
		SAVREG = 12
		TEMPRG = 20
		CNFADD = 28
		NODADD = 32
	CLRQ	-(SP)			; CNFADD(AP) = CNF address.
					; NODADD(AP) = Node number (in vector)
	CLRQ	-(SP)			; Make room on stack for temp save regs
	CLRQ	-(SP)			; REF: TEMPRG(AP)
	PUSHAB	NET$TRAVERSE_NDI	; Push next co-routine address
					; REF: BTECOR(AP)
	CLRL	-(SP)			; Caller's return address
					; REF: CALLER(AP)
	PUSHL	AP			; Save the AP
	MOVL	SP,AP			; Save current stack pointer
	PUSHL	36(SP)			; Copy return address to caller
	;
	;
	;   Initialize "last CNF" pointer.  This is the pointer to the last
	;   CNF processed and may actually be the CNR.
	;
	TSTL	R10			; Is there a current NDI
	BNEQ	20$			; If NEQ then yes
	MOVL	R11,R10			; Else start at the head of the list
20$:	;
	;   Return to caller with "initialization complete"
	;
	MOVL	#1,R0			; Initialization successful
	JSB	@(SP)+			; Call back the caller, on return
					; R0 = function to perform
	;
	;   The following code insures that if we are not called recursively,
	;   then we will always find the next NDI after the last one.
	;
	CMPL	R10,R11			; Are we starting from beginning?
	BEQL	40$			; Br if yes, okay to proceed
	CMPL	#CNF$_ADVANCE,R0	; Are we advancing?
	BNEQ	40$			; Br if not, don't have to setup stack
	MOVL	(SP)+,CALLER(AP)	; Save caller's return address
	MOVQ	R3,TEMPRG(AP)		; Save R3,R4
	MOVAB	NET$TRAVERSE_ALT,BTECOR(AP) ; Set address of resume code
	MOVQ	R7,SAVREG(AP)		; Save R7, R8
	;
	;  Get the collating value for this NDI (R10)
	;
	BSBW	GET_COLLATE		; Get the collate value from NDI
	;
	;  Contine where we left off in previous call, use collate value to
	;  find BTE entries to rebuild the stack for subsequent calls.
	;
	MOVL	R10,R4			; Save original CNF address
	PUSHAB	W^185$			; Push address of return
	JSB	NET$RESUME_NDI		; Call routine to build up stack, using
					;  the collating value
	MOVQ	SAVREG(AP),R7		; Restore R7, R8
	MOVZWL	NDI_ADD(R4),R3		; Get the last node address
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R3,R3
	PUSHL	R4			; Save old CNF address
	MOVL	NET$GL_PTR_VCB,R4	; Get the RCB address
	CMPB	R3,RCB$B_HOMEAREA(R4)	; Is this in our area?
	BEQL	90$			; Br if yes, continue with our area
	ADDL	#4,SP			; Else, clean up stack
	BLBC	R0,30$			; Br if failure to proceed
	BBS	#1,R0,60$		; Br if take this one (next in tree)
	BRW	180$			; Else continue processing of tree
30$:	;
	;   We could not continue with last node given, so we will
	;   see if last was the DUM NDI and if so, try to continue anyway.
	;
	BRB	80$			; Should always leave now
;;&&	CMPL	R10,NET$GL_DUM_NDI	; Is this the dummy NDI?
;;&&	BNEQ	80$			; Br if not, no more NDIs
;;&&	MOVL	R11,R10			; Start from beginning of list again
;;&&	MOVL	CNR$L_COLBTE(R11),R2	; Get the collate tree root
;;&&	BRB	110$			; And start with our area
40$:	;
	;   Engage in a co-routine dialogue with the user.  The scanner half
	;   of the dialogue owns the stack until the calling routine calls
	;   back with any function code other than CNF$_ADVANCE;  the other
	;   function codes causes the scanner to return to the caller with a
	;   clean stack thus terminating the co-routine dialogue.
	;
	;   Register useage:
	;	R1 may be destroyed, by this routine, but must be preserved
	;	on calls to the co-routine SCAN routine. Therefore, on intial
	;	input R1 will be zero, but will be what the caller requires
	;	on output. The same goes for R2.
	;
	MOVL	(SP)+,CALLER(AP)	; Save caller's return address
	MOVQ	SAVREG(AP),R1		; Restore R1,R2
	MOVQ	R3,TEMPRG(AP)		; Save R3,R4
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB pointer
	$DISPATCH  R0,-			; Dispatch on function code returned by
	<-				; co-routine
	    <CNF$_ADVANCE,   100$>,-	; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 200$>,-	; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      300$>,-	; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 400$>,-	; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

60$:	MOVL	#1,R0			; Indicate success

80$:	MOVQ	R1,SAVREG(AP)		; Save R1,R2
	MOVQ	TEMPRG(AP),R3		; Restore R3,R4
	JSB	@CALLER(AP)		; Call back the caller with status
	BRB	40$

90$:	MOVL	(SP)+,R10		; Restore CNF address

100$:	;
	;   Advance to the next CNF.
	;
	;;&& NOTE that the following 2 instructions don't work too well when
	;;&& R10 is pointing to the CNR.
	;;&&
	MOVL	R10,CNFADD(AP)		; Save last CNF given back to caller
	MOVZWL	CNF$W_ID(R10),R3	; Get current node address
110$:	MOVW	R3,NODADD(AP)		; Save last node # given to caller
120$:	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area of the current node
		#TR4$S_ADDR_AREA,R3,R0
	CMPB	R0,RCB$B_HOMEAREA(R4)	; Is this our area?
	BEQL	140$			; Br if yes, check all nodes in area
	BRW	180$			; Else, traverse the tree
	;
	;   Process nodes in our area. Use NDIs if they exist, else
	;   use the DUM_NDI if the node is reachable.
	;
140$:	INCW	R3			; Get next node address
	CMPW	R3,RCB$W_ADDR(R4)	; Is this the local node?
	BEQL	140$			; Br if yes
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node number within the area
		#TR4$S_ADDR_DEST,R3,R0	;
	BEQL	150$			; Br if wrap-around (max address = 1023)
	CMPW	R0,RCB$W_MAX_ADDR(R4)	; Is the node still in our area?
	BGTRU	150$			; Br if not
	CLRL	-(SP)			; Clean up stack
	MOVB	R3,2(SP)		; Stuff low byte of address
	ASHL	#-8,R3,R0		; Shift down the high byte
	MOVB	R0,1(SP)		; Stuff high byte of address
	MOVZBL	#3,R7			; Set length of string
	MOVL	SP,R8			; Point to string
	CLRL	R10			; Start from begining
	PUSHQ	R3			; Save node address, RCB address
	BSBW	NET$FIND_NDI		; Try to get the real NDI
	POPQ	R3			; Restore node address, RCB address
	ADDL	#4,SP			; Clean up stack
	BLBS	R0,60$			; Call back caller with success
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node number within the area
		#TR4$S_ADDR_DEST,R3,R0	;
	TSTW	@RCB$L_PTR_OA(R4)[R0]	; Is it reachable?
	BEQL	140$			; If EQL then unreachable
	;
	;   Point R10 to the dummy NDI, and set up the NDI fields
	;
	MOVL	NET$GL_DUM_NDI,R10	; Else, use the dummy NDI
	CLRQ	(R10)			; Clear BTE pointers
	MOVW	R3,NDI_ADD(R10)		; Stuff the address
	MOVW	R3,CNF$W_ID(R10)	; Here too
	BRW	60$			; Call back caller with success
150$:	;
	;   We have exhausted all NDIs within our area, so we must now
	;   find out where to pick up again in the collating tree. Skip
	;   all NDIs in our area.
	;
	DECL	R3			; Back up in case we have full area
	TSTL	R2			; Was there a last node?
	BEQL	190$			; Br if not, failure
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area of the current node
		#TR4$S_ADDR_AREA,R3,R3
160$:	JSB	@BTECOR(AP)		; Skip to next NDI, call BTE co-routine
	BLBC	R0,190$			; Br if failure, don't pop stack
	MOVL	(SP)+,BTECOR(AP)	; Clean up stack
	BBS	#NDI_V_LOOP,-		; Br if this is a LOOP NODE
		CNF$B_FLG(R10),170$
	CMPZV	#TR4$V_ADDR_AREA,-	; Is this our area?
		#TR4$S_ADDR_AREA,-	;
		CNF$W_ID(R10),R3	;
	BLEQ	160$			; Br if yes, skip this CNF
170$:	BRW	60$			; Else, return the CNF

180$:	;
	;   Skip to next node in data base
	;
	JSB	@BTECOR(AP)		; Call back co-routine
185$:	BLBC	R0,190$			; Br if failure, don't pop stack
	MOVL	(SP)+,BTECOR(AP)	; Else, save return address
	BBC	#NDI_V_MARKER,-		; Never return the NDI marker
		CNF$B_FLG(R10),170$
	MOVZWL	NDI_ADD(R10),R3		; Else, get the node address
	BRW	120$			; Skip this CNF

190$:	CLRL	R0			; Say "no more CNFs"
	BRW	80$			; Tell caller the bad news

200$:	;
	;   The caller wants to take the previous CNF
	;
	MOVL	CNFADD(AP),R10		; Get previous CNF address
	BEQL	300$			; Branch if none
	CMPL	R10,NET$GL_DUM_NDI	; Is this a phantom NDI (from vector)?
	BNEQ	400$			; If not, go with it
	MOVW	NODADD(AP),R0		; Get previous node address
	MOVW	R0,NDI_ADD(R10)		; Stuff the address
	MOVW	R0,CNF$W_ID(R10)	; Here too
	BRB	400$			; Take common exit

300$:	;
	;   The caller wants to quit
	;
	CLRL	R10			; Nullify CNF pointer
	;
	;   The caller is done with the scan and wants the stack back.
	;
400$:	MOVQ	TEMPRG(AP),R3		; Restore R3,R4
	MOVL	CALLER(AP),R0		; Get caller's return address
	MOVL	AP,SP			; Restore original SP
	POPL	AP			; Restore AP
	ADDL	#9*4,SP			; Pop scratch storage
	JMP	(R0)			; Return to caller

;+
;  Get the collating value for this NDI, whether it's a real NDI or not.
;
; Inputs:
;	R10 = NDI address (maybe DUMMY NDI)
;	R7,R8 are scratch
;
; Outputs:
;	R10 = NDI address
;	R7,R8 desciptor for NDI collate string
;
;	R3 is destroyed.
;-

GET_COLLATE:
	MOVAB	NDI_Z_COL,R8		; Get address of collate buffer
	CMPL	R10,NET$GL_DUM_NDI	; Is this the dummy NDI?
	BNEQ	50$			; Br if no, get real collate value
	CLRL	(R8)			; Else, dummy up COLLATE VALUE
	MOVB	NDI_ADD(R10),2(R8)	; Set low byte of node address
	MOVB	NDI_ADD+1(R10),1(R8)	; Set high byte of node address
	MOVL	#3,R7			; Set size of string
	BRB	90$			; Continue with collate value

50$:	MOVL	R8,R3			; Copy output buffer address
	
	PUSHR	#^M<R0,R1,R2,R5,R6,R8,R9> ; Save registers
	BSBW	NET$NDI_S_COL		; Get the collating value
	POPR	#^M<R0,R1,R2,R5,R6,R8,R9> ; Restore registers

	SUBL3	R8,R3,R7		; Calculate size of collate string

90$:	RSB


	.SBTTL	NET$SCAN_AJI - SCAN AJI DATABASE
;+
; NET$SCAN_AJI - Scan AJI database
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  These routines establish
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; The search uses a dummy CNF which contains two pieces of information
; (as well as supplying a valid CNF address):  A identifier describing
; the current adjacency being processed, and an identifier describing
; the previous adjacency (so we can go backwards).
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;  ***  These routines must be abortable via a RET  ***
;---

NET$SCAN_AJI::				; Adjacency scanner co-routine
	TSTL	R10			; Already pointing to a CNF ?
	BEQL	5$			; If EQL no, point to common CNF
	CMPL	R11,R10			; At head of list ?
	BNEQ	10$			; If NEQ no, assume R10 is valid
5$:	MOVAB	NET$T_CNF_AJI,R10	; Point to internal dummy CNF
	MOVW	#LPD$C_LOC_INX,CNF$W_ID(R10)	; Initialize search context
	CLRW	CNF$C_LENGTH(R10)	; Initialize previous entry context
10$:	MOVL	#1,R0			; Indicate success
20$:	JSB	@(SP)+			; Call back our caller
	$DISPATCH  R0,<-

	    <CNF$_ADVANCE,   30$>	-; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 40$>	-; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      50$>	-; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 60$>	-; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

30$:	MOVW	CNF$W_ID(R10),-		; Save current position
		CNF$C_LENGTH(R10)
35$:	INCW	CNF$W_ID(R10)		; Advance to next ADJ slot
	MOVZWL	CNF$W_ID(R10),R8	; Get ADJ index
	MOVL	NET$GL_PTR_VCB,R0	; Get RCB address
	CMPW	R8,RCB$W_MAX_ADJ(R0)	; Within range?
	BGTRU	38$			; If not, terminate search
	MOVL	@RCB$L_PTR_ADJ(R0)[R8],R0 ; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R0),35$ ; If slot not in use, continue
	BRB	10$			; Else, call back with success
38$:	CLRL	R0			; No more adjacencies
	BRB	20$			; Call back with failure

40$:	MOVW	CNF$C_LENGTH(R10),-	; Go back to previous link index
		CNF$W_ID(R10)
	BNEQ	60$			; If EQL then no previous link exists
50$:	CLRL	R10			; Nullify CNF pointer
60$:	RSB				; Return to caller, terminate dialogue

	.SBTTL	NET$SCAN_SDI - SCAN SDI DATABASE
;+
; NET$SCAN_SDI - Scan SDI database
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  These routines establish
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; Each entry in this database corresponds to a DWB in the global linked
; list of DWBs.  Each DWB represents a DLE session between a MOM process
; and a remote node.
;
; The search uses a dummy CNF which contains two pieces of information
; (as well as supplying a valid CNF address):  An identifier describing
; the current DWB being processed, and an identifier describing
; the previous DWB (so we can go backwards).
;
; The database is collated on a identifier in the DWB which is unique
; among all the DWBs in the system.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;  ***  These routines must be abortable via a RET  ***
;---

NET$SCAN_SDI::				; DLE scanner co-routine
	TSTL	R10			; Already pointing to a CNF ?
	BEQL	5$			; If EQL no, point to common CNF
	CMPL	R11,R10			; At head of list ?
	BNEQ	10$			; If NEQ no, assume R10 is valid
5$:	MOVAB	NET$T_CNF_SDI,R10	; Point to internal dummy CNF
	CLRW	CNF$W_ID(R10)		; Initialize search context
	CLRW	CNF$C_LENGTH(R10)	; Initialize previous entry context
10$:	MOVL	#1,R0			; Indicate success
20$:	JSB	@(SP)+			; Call back our caller
	$DISPATCH  R0,<-

	    <CNF$_ADVANCE,   30$>	-; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 40$>	-; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      50$>	-; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 60$>	-; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

30$:	MOVW	CNF$W_ID(R10),-		; Save current position
		CNF$C_LENGTH(R10)
	MOVL	#1,R1			; Indicate that we want the "next one"
	BSBB	GET_DWB			; Locate next DWB
	MOVL	R1,CNF$C_LENGTH+2(R10)	; Store address of DWB for action routines
	BRB	20$			; Return to caller with status

40$:	MOVW	CNF$C_LENGTH(R10),-	; Go back to previous link index
		CNF$W_ID(R10)
	BEQL	50$			; If EQL then no previous link exists
	CLRL	R1			; Indicate that we want "this one"
	BSBB	GET_DWB			; Locate next DWB
	MOVL	R1,CNF$C_LENGTH+2(R10)	; Store address of DWB for action routines
	BRB	60$			; Abort dialogue, return with CNF

50$:	CLRL	R10			; Nullify CNF pointer
60$:	RSB				; Return to caller, terminate dialogue

;
; Local subroutine to locate a DWB in the global DWB list given it's
; unique NETACP channel number.
;

GET_DWB:
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	NET$GL_DLE_UCB0,R0	; Get ND's UCB0
	MOVAB	UCB$Q_DWB_LIST(R0),R2	; Get address of listead
	MOVL	R2,R5			; Setup for loop
10$:	MOVL	(R5),R5			; Get next entry
	CMPL	R5,R2			; End of list?
	BEQL	50$			; Branch if so
	CMPW	DWB$W_ID(R5),-		; Have we found the right spot?
		CNF$W_ID(R10)
	BLSSU	10$			; If still LSS, keep scanning
	BEQL	15$			; Branch if same
	;
	;   We have found the "next entry" in the collating sequence,
	;   if the current one went away.
	;
	BLBC	R1,50$			; If caller wanted current,
	BRB	20$			; then too bad, else use next
	;
	;   We have found the "current entry" in the collating sequence.
	;
15$:	BLBC	R1,20$			; If caller wanted next one,
	MOVL	(R5),R5			; Skip to next one
	CMPL	R5,R2			; End of list?
	BEQL	50$			; If so, report error
20$:	MOVL	#1,R0			; Success
	MOVL	R5,R1			; Return DWB address in R1
	MOVW	DWB$W_ID(R5),-		; Stuff the collating value in
		CNF$W_ID(R10)		; the CNF
	BRB	90$
50$:	CLRL	R0			; Failure
	CLRL	R1			; Make sure DWB address is 0
90$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB

	.SBTTL	NET$SCAN_ARI - SCAN ARI DATABASE
;+
; NET$SCAN_ARI - Scan ARI (area) database
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  These routines establish
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; The search uses a dummy CNF which contains two pieces of information
; (as well as supplying a valid CNF address):  A identifier describing
; the current area being processed, and an identifier describing
; the previous area (so we can go backwards).
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;  ***  These routines must be abortable via a RET  ***
;---

NET$SCAN_ARI::				; Area scanner co-routine
	TSTL	R10			; Already pointing to a CNF ?
	BEQL	5$			; If EQL no, point to common CNF
	CMPL	R11,R10			; At head of list ?
	BNEQ	10$			; If NEQ no, assume R10 is valid
5$:	MOVAB	NET$T_CNF_ARI,R10	; Point to internal dummy CNF
	CLRW	CNF$W_ID(R10)		; Initialize search context
	CLRW	CNF$C_LENGTH(R10)	; Initialize previous entry context
10$:	MOVL	#1,R0			; Indicate success
20$:	JSB	@(SP)+			; Call back our caller
	$DISPATCH  R0,<-

	    <CNF$_ADVANCE,   30$>	-; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 40$>	-; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      50$>	-; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 60$>	-; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

30$:	MOVW	CNF$W_ID(R10),-		; Save current position
		CNF$C_LENGTH(R10)
35$:	INCW	CNF$W_ID(R10)		; Advance to next area number
	MOVZWL	CNF$W_ID(R10),R8	; Get area number
	MOVL	NET$GL_PTR_VCB,R0	; Get RCB address
	CMPB	R8,RCB$B_HOMEAREA(R0)	; Our own area?
	BEQL	10$			; If so, return it
	CMPW	R8,RCB$B_MAX_AREA(R0)	; Within range?
	BGTRU	38$			; If not, terminate search
	TSTL	RCB$L_PTR_AOA(R0)	; Are we a level 2 router?
	BEQL	35$			; If not, skip the following
	TSTW	@RCB$L_PTR_AOA(R0)[R8]	; Is area reachable?
	BEQL	35$			; If not, then skip to next one
	BRB	10$			; Else, return it
38$:	CLRL	R0			; No more adjacencies
	BRB	20$			; Call back with failure

40$:	MOVW	CNF$C_LENGTH(R10),-	; Go back to previous entry
		CNF$W_ID(R10)
	BNEQ	60$			; If EQL then no previous entry exists
50$:	CLRL	R10			; Nullify CNF pointer
60$:	RSB				; Return to caller, terminate dialogue

	.SBTTL	NET$SPCSCAN_XXX - SPECIAL DATABASE SCAN ROUTINES
;+
; NET$SPCSCAN_XXX - Special database scan routines
;
; These routines are called to scan a CNF entry if the search operator is EQL.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R9  = Field ID of search field.
;	R7,R8  = Descriptor of search key value
;
; Outputs:
;
;	R0  = Always clear.
;		Bit 0: Set if success, else clear.
;	        Bit 1: Set if key is recognized, else clear.
;
;-

NET$SPCSCAN_CRI::			; Circuit CNF real SCAN routine
NET$SPCSCAN_PLI::			; Line CNF real SCAN routine
NET$SPCSCAN_LNI::			; Local node CNF real SCAN routine
NET$SPCSCAN_OBI::			; Object CNF scanner SCAN routine
NET$SPCSCAN_EFI::			; Event filter CNF SCAN routine
NET$SPCSCAN_ESI::			; Event sink CNF SCAN routine
NET$SPCSCAN_SPI::			; Server process CNF SCAN routine
NET$SPCSCAN_LLI::			; Logical link CNF SCAN routine
NET$SPCSCAN_AJI::			; Adjacency CNF SCAN routine
NET$SPCSCAN_SDI::			; DLE CNF SCAN routine
NET$SPCSCAN_ARI::			; AREA Adjacency CNF SCAN routine
	CLRL	R0			; Always return false
	RSB

	.SBTTL	NET$SPCSCAN_NDI - SPECIAL SCAN OF NDI DATABASE
;+
; NET$SPCSCAN_NDI - Special scan of NDI database
;
; This routine is used to scan the NDI database and return to the caller
; the address of the CNF. This routine can only be called if the operation
; is an EQL or FNDPOS operation. This routine will return any NDI except
; for the MARKER NDI.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;	R9  = Field ID of search field.
;	R7,R8  = Descriptor of search key or value 
;
; Outputs:
;
;	R10 = Address of CNF if success, else 0.
;	R0  = Bit 0: Set if success, else clear.
;	      Bit 1: Set if key is recognized, else clear.
;
;---

NET$SPCSCAN_NDI::			; Find NDI block
	PUSHR	#^M<R3,R4,R7,R8>	; Save registers
	CLRL	R0			; Assume failure
	CMPL	R9,#NFB$C_NDI_COL	; Searching by collating value?
	BEQL	20$			; If so, take it
	CMPL	R9,#NFB$C_NDI_ADD	; Searching by node address?
	BEQL	50$			; If so, take it
	CMPL	R9,#NFB$C_NDI_TAD	; Searching by transformed node address?
	BEQL	30$			; If so, take it
	CMPL	R9,#NFB$C_NDI_NNA	; Searching by node name?
	BEQL	10$			; If so, take it
	BRW	110$			; Else, leave with no match
	;
	; Name value, search the NAME tree for match
	;
10$:	BSBW	NET$FIND_NAME		; Search the name tree
	BRW	100$			; Exit
	;
	; Collate value, search the COLLATE tree for match
	;
20$:	BSBW	NET$FIND_NDI		; Search the collate tree
	BRW	100$			; Exit
	;
	; Transformed node address
	;
	;	If the node address equals the executors node address
	;	   then change it to zero;
	;	Swap the bytes of the node address field
	;
30$:	MOVL	NET$GL_PTR_VCB,R0	; Get the RCB address
	CMPW	R8,RCB$W_ADDR(R0)	; Is this the executors address?
	BNEQ	50$			; Br if no, then okay
	CLRL	R8			; Else, zero the node address
	;
	; Node address
	;
50$:	PUSHL	R8			; Save node address
	CLRL	-(SP)			; Make some room on the stack
	MOVB	R8,2(SP)		; Store low byte
	ASHL	#-8,R8,R0		; Swap down high byte
	MOVB	R0,1(SP)		; Store high byte
	MOVZBL	#3,R7			; Set string length
	MOVL	SP,R8			; Point R8 to string
	BSBW	NET$FIND_NDI		; Search the collate tree
	ADDL	#4,SP			; Cleanup stack
	POPL	R8			; Restore node address
	BLBS	R0,80$			; Br if success
	BBS	#NET$V_INTRNL,-		; If internal, then not interested
		NET$GL_FLAGS,100$	;  in "phantom" NDIs
	
	TSTL	R10			; Was starting CNF zero?
	BEQL	60$			; Br if yes, okay
	CMPL	R10,R11			; Else, is starting CNF the CNR?
	BNEQ	100$			; Br if not, return error
60$:	MOVL	NET$GL_PTR_VCB,R4	; Get the RCB address
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area address
		#TR4$S_ADDR_AREA,R8,R3	;
	CMPB	R3,RCB$B_HOMEAREA(R4)	; Is this our area?
	BNEQ	100$			; Br if not, return failure
	CMPW	R8,RCB$W_ADDR(R4)	; Is this for the local node?
	BEQL	100$			; Br if yes, return error
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node address
		#TR4$S_ADDR_DEST,R8,R3
	BEQL	100$			; Br if zero, return error
	CMPW	R3,RCB$W_MAX_ADDR(R4)	; Is it still in the area?
	BGTRU	100$			; Br if not, return error
	TSTW	@RCB$L_PTR_OA(R4)[R3]	; Is the node reachable?
	BEQL	100$			; Br if not, return error
	MOVL	NET$GL_DUM_NDI,R10	; Else, use the dummy NDI
	MOVW	R8,CNF$W_ID(R10)	; Stuff the node address
	MOVW	R8,NDI_ADD(R10)		; ..here also
	MOVZBL	#1,R0			; Return success
	BRB	100$			; Exit
80$:	BBC	#NDI_V_MARKER,-		; Never return the marker CNF
		CNF$B_FLG(R10),100$	;
90$:	CLRL	R0			; Indicate failure
	CLRL	R10			; Return error
100$:	BISB	#2,R0			; Return indicator that key accepted
110$:	POPR	#^M<R3,R4,R7,R8>	; Restore registers
	RSB				; Return to caller

	.SBTTL	NET$PRE_QIO_xxx - PRE-QIO PROCESSING
;+
; NET$PRE_QIO_xxx - Perform pre-QIO database processing
;
; This routine is called just after validating the NFB for a database
; function to do any special pre-processing before the request is attempted.
;
; Inputs:
;
;	R11 = Address of CNR
;	NET$GQ_SRCH_KEY = Descriptor of search key value
;	NET$GL_SRCH_ID = Field ID of search field.
;
; Outputs:
;
;	NET$GQ_SRCH_KEY = New search key value (if reformatted)
;---
NET$PRE_QIO_NDI::
	CMPL	NET$GL_SRCH_ID,#NFB$C_NDI_TAD ; Searching by node address?
	BEQL	10$			; If so, transform key
	CMPL	NET$GL_SRCH_ID,#NFB$C_NDI_ADD ; Searching by node address?
	BNEQ	90$			; If not, skip it
10$:	MOVL	NET$GQ_SRCH_KEY+4,R1	; Get the node address
	BEQL	90$			; If 0, skip it
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R1,R0
	BNEQ	90$			; Check it if non-zero
	MOVL	NET$GL_PTR_VCB,R2	; Get RCB address
	INSV	RCB$B_HOMEAREA(R2),-	; If area = 0, then use our area
		#TR4$V_ADDR_AREA,-	; (accept 0 as synonym for our area)
		#TR4$S_ADDR_AREA,R1
	BSBW	SUPPRESS_AREA		; Suppress area, if necessary, to be
					; consistent with the TAD which is also
					; suppressed (so that it will match)
	MOVL	R1,NET$GQ_SRCH_KEY+4	; Set new search key
90$:
NET$PRE_QIO_LNI::
NET$PRE_QIO_OBI::
NET$PRE_QIO_EFI::
NET$PRE_QIO_ESI::
NET$PRE_QIO_LLI::
NET$PRE_QIO_SPI::
NET$PRE_QIO_AJI::
NET$PRE_QIO_SDI::
NET$PRE_QIO_ARI::
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

	.SBTTL	NET$SHOW_xxx - PRE-SHOW PROCESSING
;+
; NET$SHOW_xxx - Show QIO pre-processing
;
; This routine is called for each CNF which is about to be returned
; to a "show" QIO.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code
;
;	The CNF may be updated.
;-

NET$SHOW_LNI::
NET$SHOW_NDI::
NET$SHOW_OBI::
NET$SHOW_EFI::
NET$SHOW_ESI::
NET$SHOW_LLI::
NET$SHOW_SPI::
NET$SHOW_AJI::
NET$SHOW_SDI::
NET$SHOW_ARI::
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

	.SBTTL	NET$DEFAULT_xxx - APPLY DEFAULT VALUES
;+
; NET$DEFAULT_xxx  -  Apply default values to selected CNF parameters.
;
; This routine is called by CNF$INSERT just prior to validating a CNF
; entry which is to be inserted into the database.  Its purpose is to
; supply default values to selected parameters.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R0	SS$_NORMAL -- this routine always succeeds.
;
;		All other registers contain garbage.
;-
NET$DEFAULT_LNI::
	$GETFLD	lni,l,ety		; Get executor type
	BLBS	R0,NET$APPLY_DFLT	; If specified, then continue
	JSB	NET$GET_END		; Get endnode info
	BLBC	R0,NET$APPLY_DFLT	; If failure, then use default
	MOVL	#ADJ$C_PTY_PH4N,R8	; Use endnode as default
	BSBW	CNF$PUT_FIELD		; Store it in the CNF
NET$DEFAULT_OBI::
NET$DEFAULT_EFI::
NET$DEFAULT_ESI::
NET$DEFAULT_LLI::
NET$DEFAULT_SPI::
NET$DEFAULT_AJI::
NET$DEFAULT_SDI::
NET$DEFAULT_ARI::
NET$APPLY_DFLT::			; Apply default CNF parameter values
	MOVZBL	CNR$B_TYPE(R11),R0	; Get database i.d.
	MOVL	NET$AL_CNF_DFLT[R0],R6	; Get parameter id,value table

NET$TABLE_DFLT::			; Apply defaults given table address
					; R6 = default table address
10$:	MOVL	(R6)+,R9		; Get parameter i.d., advance R6
	BEQL	50$			; Done if EQL
	BSBW	CNF$GET_FIELD		; See if field is already setup
	MOVL	(R6)+,R8		; Get parameter value, advance R6
	BLBS	R0,10$			; If LBS the no need for default
	BSBW	CNF$PUT_FIELD		; Store it in the CNF
	BRB	10$			; Ignore errors
50$:	MOVL	S^#SS$_NORMAL,R0	; Always successful
	RSB				; Done

	.SBTTL	NET$DEFAULT_NDI - APPLY DEFAULT VALUES TO NDI CNF
;+
; NET$DEFAULT_NDI  -  Apply default values to NDI CNF parameters -
;		also set the LOOP bit in the FLG byte if needed.
;
; This routine is called by CNF$INSERT just prior to validating a CNF
; entry which is to be inserted into the database.  Its purpose is to
; supply default values to selected parameters.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R0	SS$_NORMAL -- this routine always succeeds.
;
;		All other registers contain garbage.
;-
NET$DEFAULT_NDI::
	BSBB	NET$APPLY_DFLT		; Apply defaults
	$GETFLD	ndi,l,add		; Get the node address
	BLBC	R0,90$			; Br if none, will fail later
	TSTL	R8			; Is node address zero?
	BNEQ	90$			; Br if no, not a loop node
	$GETFLD	ndi,s,nli		; Get the optional circuit name
	BLBC	R0,90$			; Br if none, not a loop node
	BISB	#1@NDI_V_LOOP,-		; Mark this as a "LOOP" node
		 CNF$B_FLG(R10)
90$:	MOVL	S^#SS$_NORMAL,R0	; Always successful
	RSB				; Done

	.SBTTL	NET$INSERT_LNI - PRE-INSERTION PROCESSING
;+
; NET$INSERT_LNI - Insert an LNI entry into database
;
; This routine is called to validate the CNF entry before inserting
; it into the database.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code.  If error, entry is not inserted.
;-

NET$INSERT_LNI::
	$GETFLD	lni,l,add		; Get the node address 
	BLBS	R0,5$			; If LBC then report bad node address
	BRW	110$			; ...
5$:	MOVL	R8,R5			; Has the address been set yet?
	BEQL	10$			; If not set, skip address checks
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	CMPW	R8,RCB$W_ADDR(R4)	; Is the address being changed?
	BNEQ	20$			; If so, perform address checks
10$:	BRW	140$			; Skip all address checks
20$:	;
	;   If we are running in a cluster, ensure that the address specified
	;   in the SYSGEN parameter SCSSYSTEMID matches the DECnet node
	;   address with the area number. If SCSSYSTEMID contains no area, and
	;   the node address is in area 1, don't compare area...
	;
	TSTL	G^CLU$GL_CLUB		; Are we in a cluster?
	BEQL	50$			; If EQL, no, skip the test
	MOVL	R5,R1			; Make copy of address for CMPW
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number of SCSSYSTEMID
		#TR4$S_ADDR_AREA,G^SCS$GB_SYSTEMID,R0
	BNEQ	30$			; If NEQ, compare full address
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number of node address
		#TR4$S_ADDR_AREA,R5,R0
	CMPL	R0,#1			; Is it area 1?
	BNEQ	40$			; If NEQ, no: areas do not match.
	;
	;   Just compare the node address portions.
	;
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node within area
		#TR4$S_ADDR_DEST,R5,R1
	;
	;   Note: R1 contains node address, or node with area if area = 1
	;
30$:	CMPW	R1,G^SCS$GB_SYSTEMID	; Does the node address match?
	BEQL	50$			; If EQL, yes
40$:	BRW	190$			; No, report error
50$:	;
	;   If we are acting as a Phase IV router, then if no area number
	;   has been specified as the executor address, then default it to
	;   "1", and set a flag indicating that we should suppress the area
	;   number on all node addresses returned to higher layers (NML/EVL).
	;
	$GETFLD	lni,l,ety		; Get executor type
	BLBC	R0,60$			; If not set, then error
	CMPB	R8,#ADJ$C_PTY_AREA	; Are we an area router?
	BEQL	70$			; If so, bypass checks
	CMPZV	#TR4$V_ADDR_AREA,-	; Is the area number 0?
		#TR4$S_ADDR_AREA,R5,#0
	BNEQ	80$			; If not, then it's ok
	INSV	#1,#TR4$V_ADDR_AREA,-	; Default it to "1"
		#TR4$S_ADDR_AREA,R5
	MOVL	R5,R8			; Set new address
	$PUTFLD	lni,l,add		; Store it
	BLBC	R0,80$			; If error trying to store, skip it
	MOVL	#1,R8			; Remember to suppress area from now on
	$PUTFLD	lni,v,sup		; Store the area suppression flag
60$:	BLBC	R0,110$			; Exit if error trying to store
	BRB	80$
	;
	;   For area routers, all we need is to make sure the area
	;   number is never 0, since it would wreak havoc on the routing
	;   algorithms.
	;
70$:	$CNFFLD	lni,l,add,R9		; Assume problem with address
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R5,R2
	BEQL	110$			; If 0 at this point, then error
					; (area number can NEVER be zero)
	BRB	90$			; Apply area routing defaults
80$:	;
	;   If we are dealing with an area router, or a router which
	;   is using explicit area specifications, then provide the
	;   additional LNI defaults for area routers.
	;
	$GETFLD	lni,v,sup		; Is the area suppression flag set?
	BLBS	R8,100$			; If so, then skip area defaults
90$:	MOVAB	NET$G_LNI_AREA,R6	; Set address of area defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
100$:	;
	;   Breakup the new executor address into area and node number
	;
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R5,R2
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node within area
		#TR4$S_ADDR_DEST,R5,R3
	;
	;   Make sure that the area number specified is within MAX AREAS
	;
	$GETFLD	lni,v,sup		; Is the area suppression flag set?
	BLBS	R8,120$			; If so, skip check
	$GETFLD	lni,l,mar		; Get MAX AREAS
	BLBC	R0,110$			; Branch if not set
	CMPB	R2,R8			; Within MAX AREAS?
	BLEQU	120$			; Branch if ok
110$:	MOVZWL	S^#SS$_BADPARAM,R0	; Indicate error
	BRB	170$			; Report the error
120$:	;
	;   Make sure that the node number specified is within MAX ADDRESS
	;
	$GETFLD	lni,l,mad		; Get MAX ADDRESS
	BLBC	R0,110$			; Branch if not set
	CMPW	R3,R8			; Within MAX ADDRESS?
	BGTRU	110$			; Branch if out of range
	;
	;   Make sure that there are no NDI entries with the new LNI node
	;   address.  Refer to NET$INSERT_NDI for more information.
	;
	MOVQ	R10,-(SP)		; Save registers
	MOVL	R5,R8			; New executor address
	BSBW	NET$NDI_BY_ADD		; Lookup NDI for this address
	CMPL	R10,NET$GL_LOCAL_NDI	; Did we find the local NDI?
	BNEQ	130$			; If so, branch
	CLRL	R0			; Else, indicate address already in use
130$:	MOVQ	(SP)+,R10		; Restore LNI pointers
	BLBS	R0,180$			; Error if already in use
140$:	;
	;   Update the ACP control layer
	;
	;	Inputs:	 R11	LNI CNR pointer
	;		 R10	New LNI CNF pointer
	;
	;	Outputs: R9	I.D. of faulty parameter if LBC in R0
	;		 R0	Status
	;
	;		 All other regs may be clobbered.
	;
	;
150$:	BSBW	NET$UPD_LOCAL		; Make ACP transistion
	BLBC	R0,170$			; If error detected, then exit
	$GETFLD	lni,v,sup		; If areas were suppressed,
	BLBC	R8,160$			;
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVB	#1,RCB$B_MAX_AREA(R4)	; Stuff Max Area to 1, but not in the
160$:	;
	;   Now that there is no more possibility for error, we must
	;   reposition the fake "area.0" NDI CNF which marks the position
	;   in the NDI linked list of the beginning of the current area.
	;   (This marker is needed to determine when a scan needs to shift
	;   to using the OA vector or not).  If no marker currently
	;   exists, then one is created assuming that this is the first
	;   LNI insertion.
	;
	BSBB	NDI_MARKER		; Insert the marker in the right place
	MOVL	S^#SS$_NORMAL,R0	; CNF, where it might by seen by user
170$:	RSB

180$:	MOVZWL	#SS$_DEVACTIVE,R0	; Executor address is used elsewhere
	RSB

190$:	MOVL	#SS$_WRONGNAME,R0	; Executor address does not match 
	RSB				;   VAXcluster system ID.

	.SBTTL	NDI_MARKER - Insert executor NDI marker
;+
; NDI_MARKER - Insert marker into NDI linked list for executor node
;
; This routine inserts a dummy CNF block into the NDI linked list at
; the position where the executor address would normally go.  This marker
; is needed when scanning the database in order to know when to begin
; using the OA vector, rather than the linked list, and where to
; return again after finishing with the vector.  See SCAN_NDI for more
; details.
;
; Inputs:
;
;	RCB$W_ADDR = New executor address
;
; Outputs:
;
;	None
;
;	All registers are preserved.
;-
NDI_MARKER:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Save registers
	MOVL	NET$GL_CNR_NDI,R11	; Point to NDI root
	MOVL	R11,R10			; Start at beginning of tree
	;
	;   The executor node address is always stored as 0, in the
	;   collating tree. Therefore we will insert a marker in the
	;   collating tree as n.0 where n it the current area field
	;   of the executor node address. To make finding this NDI as
	;   easy as possible, it will be searched in the name tree as
	;   "++++". Since this is an invalid node name string, it will
	;   be a unique entry in the name tree.
	;
	MOVL	#^A"++++",-(SP)		; Store string on the stack
	MOVZBL	#4,R7			; Set string length
	MOVL	SP,R8			; Point R8 to string
	BSBW	NET$FIND_NAME		; Search the name tree for NDI
	ADDL	#4,SP			; Cleanup stack
	BLBC	R0,20$			; Br if not found
	BSBW	NET$DELETE_BTE		; Else, delete the old BTEs
	BRB	40$			; And continue
	;
	;   If the old NDI cannot be found, then we will create one.
	;
20$:	MOVZWL	CNR$W_SIZ_CNF(R11),R1	; Set size of CNF block
	ADDL	#8,R1			; Add in enough room for name
	JSB	NET$ALLOCATE		; Allocate block from ACP pool
	BLBC	R0,90$			; Br if error, skip it
	MOVL	R2,R10			; Save address of marker CNF
	BSBW	CNF$INIT		; Initialize CNF block
	BISB	#1@NDI_V_MARKER,-	; Initialize flags
		CNF$B_FLG(R10)
	CLRQ	CNF$L_MASK(R10)		; Initialize 12 byte bitmask
	CLRL	CNF$L_MASK+8(R10)
40$:	;
	;   Common processing
	;
	MOVL	NET$GL_PTR_VCB,R5	; Get RCB address	
	MOVZWL	RCB$W_ADDR(R5),R8	; Get executor node address
	MOVW	R8,CNF$W_ID(R10)	; Copy/reset new executor address
	INSV	#0,#TR4$V_ADDR_DEST,-	; Zero the address within the area
		#TR4$S_ADDR_DEST,R8	;
	$PUTFLD	ndi,l,add		; Store it in CNF
	MOVL	#^A"++++",-(SP)		; Store string on the stack
	MOVZBL	#4,R7			; Set string length
	MOVL	SP,R8			; Point R8 to string
	$PUTFLD	ndi,s,nna		; Set the node name field
	ADDL	#4,SP			; Cleanup stack
	BSBW	NET$ADD_NDI		; Add new NDI to trees
90$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Restore registers
	RSB

	.SBTTL	NET$INSERT_NDI - PRE-INSERTION PROCESSING
;+
; NET$INSERT_NDI - Insert an NDI entry into database
;
; This routine is called to validate the CNF entry before inserting
; it into the database.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code.  If error, entry is not inserted.
;-
	.ENABL	LSB

NET$INSERT_NDI::
	;
	;   Use this opportunity to keep the NDI and LNI databases consistent
	;   by using the following rules.  These rules are needed because the
	;   the local node address exists in both data bases.  By forcing the
	;   address of the local node NDI and all loop nodes to be zero and by
	;   using a zero NDI node address to implicitly refer to the RCB$W_ADDR
	;   value, changing the local node address in the LNI data base will
	;   automatically update the addresses of the peritinent NDI entries.
	;   The fact that the local node's address is stored as zero throughout
	;   the NDI data base is used throughout the ACP -- it will be very 
	;   difficult to modify the design.
	;
	;	Upon new NDI insertion:
	;
	;		1. if   new NDI node address = RCB$W_ADDR
	;		   then zero the NDI node address
	;
	;		2. if   old NDI node address = 0
	;		   then
	;			if   new NDI node address NEQ 0
	;			then error
	;
	;	Upon new LNI insertion:  (see UPD_LOCAL above)
	;
	;		1. if   new LNI node address exists anywhere in the
	;		        NDI data base
	;		   then error
	;
	MOVL	R10,R5			; Save the new NDI
	BICB	#<1@NDI_V_LOCAL>!-	; Init special flags
		 <1@NDI_V_LOOP>,-	;
		CNF$B_FLG(R5)		;
	BSBW	CHK_LOGIN_NDI		; Check default login strings for
					; combined length
	BLBC	R0,5$			; If LBC then too long
	MOVL	R4,NDI_L_NACS		; Remember number of non-null access
					; control strings
	$GETFLD	ndi,s,nna   		; Get the node name descriptor
	MOVQ	R7,NDI_Q_NAME		; Save it
	$GETFLD	ndi,l,add		; Get new node address
	TSTL	R8			; Address = 0?
	BEQL	10$			; If so, then br (for loop nodes)
	MOVL	NET$GL_PTR_VCB,R2	; Get the RCB pointer
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node # within area
		#TR4$S_ADDR_DEST,R8,R0
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R8,R1
	BNEQ	4$			; Check it if non-zero
	INSV	RCB$B_HOMEAREA(R2),-	; If area = 0, then use our area
		#TR4$V_ADDR_AREA,-	; (accept 0 as synonym for our area)
		#TR4$S_ADDR_AREA,R8
	BSBW	CNF$PUT_FIELD		; Replace node address
	EXTZV	#TR4$V_ADDR_DEST,-	; Restore the node # within area
		#TR4$S_ADDR_DEST,R8,R0
	MOVZBL	RCB$B_HOMEAREA(R2),R1	; Use our area as the area number
4$:	CMPB	R1,RCB$B_MAX_AREA(R2)	; Check against max allowed area
	BGTRU	30$			; If GTRU then out of range
	CMPB	R1,RCB$B_HOMEAREA(R2)	; Is this our area?
	BNEQ	10$			; If not, then no limit on max address
	CMPW	R0,RCB$W_MAX_ADDR(R2)	; Check against max allowed address
	BGTRU	30$			; If GTRU then out of range
	CMPW	R8,RCB$W_ADDR(R2)	; Is it the local node?
	BNEQ	10$			; If NEQ no
	CLRL	R8			; Local node is stored in the NDI data
	BSBW	CNF$PUT_FIELD		; base as zero
	BLBS	R0,10$			; If LBS, continue
	MOVZWL	#SS$_INSFMEM,R0		; Report "insufficient memory"
5$:	BRW	220$			; Take common exit
10$:	MOVW	R8,CNF$W_ID(R5)		; Save the new NDI node address
	;
	;   A "loop" node is an NDI for which an output line has been permanently
	;   assigned in the database.  Such an NDI must have a name field 
	;   (ndi,s,nna) specified and, for now, must have the node address of 
	;   the local node.  By creating a logical link to this nodename, the 
	;   link is made to the local node but all traffic is transmitted over
	;   the specified line.  The intent of "loop" nodes is to allow loopback
	;   testing of a line or the testing of the transport layer on the node
	;   at the other end of the line.
	;
	;   A "loop" node NDI cannot be converted to a normal NDI or vice-versa
	;   The rules governing NDI updates with respect to the associated 
	;   loopback linename are as follows:
	;
	;	   If  there's a loopback line associated with the new NDI
	;	   then
	;		 if the old NDI is a "loop" node
	;		 then
	;		       if  new NDI node address = 0
	;		       then  okay
	;		       else  node address is invalid
	;		 else
	;		       loopback line is an invalid parameter
	;
	;	   else
	;		 if the old NDI was a "loop" node
	;		 then 
	;		      mark the new NDI for delete and return success
	;		 else 
	;		      neither old nor new NDI are "loop" nodes, continue
	;
	;
	$GETFLD	ndi,s,nli		; Get optional circuit name
	BLBC	R0,NOT_LOOPNODE		; If LBC, new NDI not a "loop"
	TSTW	CNF$W_ID(R10)		; Non-zero node address?
	BNEQ	NOT_LOOPNODE		; Loop nodes always use address 0
	BISB	#1@NDI_V_LOOP,-		; Mark it as being a "loop" node
		    CNF$B_FLG(R10)	;
	TSTL	R6			; Is there an old NDI ?
	BEQL	20$			; If EQL no
	BBC	#NDI_V_LOOP,-		; If BC, old was not a loop node
		    CNF$B_FLG(R6),30$	; - therefore cannot set linename
20$:	$CNFFLD	ndi,s,nna,R9		; Assume no name was specified
	TSTL	NDI_Q_NAME		; Is the name null?
	BEQL	35$			; If EQL report 'insufficient args'
	BRW	210$			; Report success

30$:	MOVZWL	S^#SS$_BADPARAM,R0	; Indicate error
	BRW	220$			; Take common exit
35$:	MOVZWL	#SS$_INSFARG,R0		; Set error code
	BRW	220$			; Take common exit

NOT_LOOPNODE:
	TSTL	R6			; Is there an old NDI ?
	BEQL	110$			; If EQL no
	BBC	#NDI_V_LOOP,-		; If BC old was not a loop node
		    CNF$B_FLG(R6),110$	;
	BISB	#CNF$M_FLG_DELETE!-	; Mark new NDI for delete
		    <1@NDI_V_LOOP>,-	; ...it's still a "loop node"
		    CNF$B_FLG(R10)	;
	BRW	210$			; Report success
110$:	;
	;   Neither the old or new NDIs are loop nodes
	;
	TSTW	CNF$W_ID(R5)		; Is this the local node?
	BNEQ	120$			; If NEQ then no
	BISB	#1@NDI_V_LOCAL,-	; Mark it as "local"
		    CNF$B_FLG(R5)
120$:	TSTL	R6			; Is there an old NDI
	BEQL	130$			; If EQL then no
	CMPW	CNF$W_ID(R5),CNF$W_ID(R6) ; Are old and new address the same?
	BEQL	130$			; If so, branch
	;
	;  The old and new address are different.  If either has address "zero"
	;  then report that the local NDI is being falsely modified.
	;
	BBS	#NDI_V_LOCAL,-		; If BS then old NDI is local
		     CNF$B_FLG(R6),140$	; -- report error
	BBS	#NDI_V_LOCAL,-		; If BS then new NDI is local
		     CNF$B_FLG(R5),140$	; -- report error
125$:	BRW	200$			; Insert new NDI into vector
130$:	;
	;   There has been no NDI node address change.
	;
	;   If  the current local NDI CNF address = NET$GL_DUM_NDI
	;	(which means the ACP is undergoing its initialzation cycle)
	;
	;	OR
	;
	;	the new NDI node address not= 0	(0 implies NDI for local node)
	;   then
	;	we're done, return success
	;
	;   else
	;	if "old" NDI CNF address = current local NDI CNF address
	;	then
	;	    the local node NDI is undergoing a valid update.
	;	else
	;	    the local node NDI is being falsely modified, i.e., the
	;	    NDI specified via the QIO P2 key was not the local node
	;	    NDI but the node address parameter specified in the QIO P4
	;	    equals the local node address.  Report the error.
	;	    
	BBC	#NDI_V_LOCAL,-		; If BC then new NDI is not for the
		     CNF$B_FLG(R5),125$	; local node -- we're done
	TSTL	NET$GL_LOCAL_NDI	; Has the local NDI been init'd yet?
	BEQL	125$			; If EQL no, we're done
	CMPL	NET$GL_LOCAL_NDI,R6	; Is the "old" CNF really the current
					; local node CNF
	BEQL	150$			; If EQL yes, br to continue
140$:	$CNFFLD	ndi,l,add,r9		; Specify field i.d. as node address
	MOVZWL	#SS$_DEVACTIVE,R0	; Specify it as already in use 
					; elsewhere in the database
145$:	BRW	220$			; Report error
	;
	;   Update the logical name for the local node only if the RCB contains
	;   a non-zero node address.  The RCB contains node address 0 while the
	;   ACP is initializing.
	;
150$:	MOVL	NET$GL_PTR_VCB,R2	; Get the RCB address
	TSTW	RCB$W_ADDR(R2)		; Has the local node address been
					; established yet?
	BEQL	200$			; If EQL no, we're done
	MOVQ	NDI_Q_NAME,R7		; Get NDI name descriptor
	;
	; If this is a VAXcluster, the node name must match the name set up
	; in the SYSGEN parameter SCSNODE. 
	;
	TSTL	G^CLU$GL_CLUB		; See if this is a VAXcluster
	BEQL	160$			; If EQL, no - don't check name
	CMPC5	R7,(R8),#^A" ",#6,G^SCS$GB_NODENAME ; Verify that names match
	BEQL	160$			; If EQL, names match
	MOVL	#SS$_WRONGNAME,R0	; Else, report error
	BRW	220$			; ...
	;
	; Create SYS$NODE logical name
	;
160$:	MOVAB	NDI_LNAMEBUF,R1		; Get buffer for building logical name
	MOVL	R1,NDI_Q_LNAME+4	; Setup pointer in descriptor
	MNEGL	R1,NDI_Q_LNAME		; Bias the count field
	MOVB	#^A'_',(R1)+		; Build logical nodename
	BRB	180$			; Continue
170$:	MOVB	(R8)+,(R1)+		; Enter the name text
180$:	SOBGEQ	R7,170$			; Loop
	MOVW	#^A'::',(R1)+		; Enter nodename delimiter
	ADDL	R1,NDI_Q_LNAME		; Setup the count field
	$CRELOG_S	-		; Create a system logical name
		LOGNAM = SYSNODE_DESC,-	; Logical name
		EQLNAM = NDI_Q_LNAME	; Equivalence name
	BLBC	R0,220$			; If LBC then error
	;
	;   Update the logical name for the alias node only if the RCB contains
	;   a non-zero alias address.
	;
200$:	MOVL	NET$GL_PTR_VCB,R2	; Get the RCB address
	TSTW	RCB$W_ALIAS(R2)		; Is there an alias local address?
	BEQL	204$			; If not, we're done
	CMPW	CNF$W_ID(R5),RCB$W_ALIAS(R2) ; Is this the alias NDI entry?
	BNEQ	204$			; Skip if not
	MOVQ	NDI_Q_NAME,R7		; Get NDI name descriptor
	MOVAB	NDI_LNAMEBUF,R1		; Get buffer for building logical name
	MOVL	R1,NDI_Q_LNAME+4	; Setup pointer in descriptor
	MNEGL	R1,NDI_Q_LNAME		; Bias the count field
	MOVB	#^A'_',(R1)+		; Build logical nodename
	BRB	203$			; Continue
202$:	MOVB	(R8)+,(R1)+		; Enter the name text
203$:	SOBGEQ	R7,202$			; Loop
	MOVW	#^A'::',(R1)+		; Enter nodename delimiter
	ADDL	R1,NDI_Q_LNAME		; Setup the count field
	$CRELOG_S	-		; Create a system logical name
		LOGNAM = CLUNODE_DESC,-	; Logical name
		EQLNAM = NDI_Q_LNAME	; Equivalence name
	BLBC	R0,220$			; If LBC then error
204$:	;
	;   New will be inserted into the data base, start/reset counter timer.
	;
	TSTW	CNF$W_ID(R5)		; Is this the local node's NDI?
	BNEQ	205$			; If so,
	MOVL	R5,G^NET$GL_LOCAL_NDI	; Remember address of local NDI CNF
205$:	BSBW	NET$SET_CTR_TIMER	; Start/reset automatic counter timer
210$:	MOVL	#1,R0			; Success if not changing local node
220$:	RSB				; Done

	.DSABL	LSB

	.SBTTL	NET$INSERT_OBI - PRE-INSERTION PROCESSING
;+
; NET$INSERT_OBI - Insert an OBI entry into database
;
; This routine is called to validate the CNF entry before inserting
; it into the database.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code.  If error, entry is not inserted.
;-

NET$INSERT_OBI::			; New CNF OBI special processing
	BSBW	CHK_LOGIN_OBI		; Check default login strings for
					; combined length
	BLBC	R0,20$			; If LBC then too long
	;
	;   If an OBI is merely the result of a "declare name/object" QIO then
	;   when the channel over which the object is declared is broken it is
	;   appropriate to delete the OBI entry from the data base.  However,
	;   in order to prevent a defined (via NCP) object from being removed
	;   if it is subsequently declared and then "undeclared" (by having its
	;   associated channel broken) it is necessary to mark each OBI if it
	;   at any time exists without being in a "declared" state.
	;
	;   Note that it is sufficient to mark the OBI whenever it is being
	;   (re)inserted into the database and it is not currently declared.
	;
	$GETFLD	obi,l,ucb		; Is the OBI currently "declared"
	BLBS	R0,10$			; If LBS yes, don't mark it
	MOVL	#1,R8			; Set next bit value to "true"
	$PUTFLD	obi,v,set		; Mark the OBI as having existed
					; without being declared
10$:	MOVL	#1,R0			; Set success
20$:	RSB

	.SBTTL	NET$INSERT_xxx - PRE-INSERTION PROCESSING
;+
; NET$INSERT_xxx - Insert an entry into database
;
; This routine is called to validate the CNF entry before inserting
; it into the database.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code.  If error, entry is not inserted.
;-

NET$INSERT_ESI::			; New ESI CNF special processing
	BRW	NET$DBC_ESI		; Event logger Sink database change
NET$INSERT_EFI::			; New EFI CNF special processing
	BRW	NET$DBC_EFI		; Event logger Filter database change

NET$INSERT_LLI::			; Insert LLI special processing
NET$INSERT_SPI::			; Insert SPI database entry
	MOVL	#1,R0			; No special checking
	RSB

NET$INSERT_AJI::			; Insert AJI special processing
	MOVZWL	#SS$_ILLCNTRFUNC,R0	; Illegal ACP control function
	MOVZBL	#NFB$C_DB_AJI,R9	; Qualify error -- not valid for this
					; data base
	RSB				; Done

NET$INSERT_SDI::			; Insert SDI special processing
	MOVZWL	#SS$_ILLCNTRFUNC,R0	; Illegal ACP control function
	MOVZBL	#NFB$C_DB_SDI,R9	; Qualify error -- not valid for this
					; data base
	RSB				; Done

NET$INSERT_ARI::			; Insert ARI special processing
	MOVZWL	#SS$_ILLCNTRFUNC,R0	; Illegal ACP control function
	MOVZBL	#NFB$C_DB_ARI,R9	; Qualify error -- not valid for this
					; data base
	RSB				; Done

	.SBTTL	CHK_LOGIN_xxx - CHECK LOGIN STRING LENGTH
;+
; CHK_LOGIN_xxx - Check if access control string is too long
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code
;-
	.ENABL	LSB

CHK_LOGIN_OBI:				; Check combined login string length
	CLRL	R4			; Count of number of non-null strings
	MOVAB	OBI_LOGIN_VEC,R3	; Setup field i.d. vector
	BRB	5$			; Continue in common
CHK_LOGIN_NDI:				; Check combined login string length
	CLRL	R4			; Count of number of non-null strings
	MOVAB	NDI_PLOGIN_VEC,R3	; Setup field i.d. vector
	BSBB	10$			; Check the combined length
	MOVAB	NDI_NLOGIN_VEC,R3	; Get the address of field i.d.'s
5$:	BSBB	10$			; Check the comined length
7$:	MOVL	S^#SS$_NORMAL,R0	; Inicate success
	RSB


10$:	MOVZWL	#ICB$C_ACCESS-4,R2	; Get max size of string text (the -4
					; is for 3 string count fields plus a 
					; count field for the combined strings)
20$:	MOVL	(R3)+,R9		; Get next field i.d.
	BEQL	30$			; If EQL then done
	BSBW	CNF$GET_FIELD		; Get the string
	BLBC	R0,20$			; If LBC then string is not defined
	INCL	R4			; Count number of non-null strings
	SUBL	R7,R2			; Subtract string size
	BGEQ	20$			; If GEQ then okay
	MOVZWL	#SS$_BADPARAM,R0	; Else indicate error
					;!a better error code is needed
	TSTL	(SP)+			; Pop stack to return to origin. caller
30$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	NET$SPCINS_XXX - SPECIAL DATABASE INSERTION ROUTINES
	.SBTTL	NET$SPCINS_DEF - DEFAULT DATABASE INSERTION ROUTINE
;+
; NET$SPCINS_DEF - Default database insertion routine
;
; This routine is called to insert a CNF entry in the standard linked list.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R6  = Address of old CNF (or 0 if no old CNF)
;
; Outputs:
;
;	R0  = Always True.
;
;	R5,R9 are destroyed.
;
;-

NET$SPCINS_CRI::			; Circuit CNF insertion routine
NET$SPCINS_PLI::			; Line CNF insertion routine
NET$SPCINS_LNI::			; Local node CNF real insertion routine
NET$SPCINS_OBI::			; Object CNF insertion routine
NET$SPCINS_EFI::			; Event filter CNF insertion routine
NET$SPCINS_ESI::			; Event sink CNF insertion routine
NET$SPCINS_SPI::			; Server process CNF insertion routine
NET$SPCINS_LLI::			; Logical link CNF insertion routine
NET$SPCINS_AJI::			; Adjacency CNF insertion routine
NET$SPCINS_SDI::			; DLE CNF insertion routine
NET$SPCINS_ARI::			; AREA Adjacency CNF insertion routine
NET$SPCINS_DEF::			; Insert block
	MOVL	CNR$L_FLD_COLL(R11),R9	; Get the collating field i.d.
	BSBW	CNF$GET_FIELD		; Get the field value/descriptor
	MOVL	R10,R5			; Save ptr to "new" CNF
	CLRL	R10			; Start search form head of list
	MOVL	S^#NFB$C_OP_FNDPOS,R1	; Search database to find the CNF after
	BSBW	CNF$KEY_SEARCH		; which to insert the new CNF
	BLBS	R0,50$			; If LBS then successful
	MOVL	CNR$L_BLINK(R11),R10	; Else locate last CNF in the queue
50$:	INSQUE	(R5),CNF$L_FLINK(R10)	; Insert after item found
	MOVL	R5,R10			; Point to the "new" CNF
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	TSTL	R6			; Is there an "old" CNF ?
	BEQL	70$			; If EQL no
	BBS	#CNF$V_FLG_ACP,-	; If BS then CNF is not linked into the
		     CNF$B_FLG(R6),70$	; CNF queue
	REMQUE	(R6),R5			; Remove "old" CNF from database
60$:	INSQUE	(R5),@NET$GQ_TMP_BUF	; Queue CNF block for deallocation
70$:	RSB				; Return to caller

	.SBTTL	NET$SPCINS_NDI - INSERT NDI DATABASE INTO BINARY TREE
;+
; NET$SPCINS_NDI - Insert NDI database into binary tree
;
; This routine is called to create an entry in the collate and name
; AVL tree for the new NDI.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R6  = Address of old CNF (or 0 if no old CNF)
;
; Outputs:
;
;	R0  = Always True.
;
;	R5 is destroyed.
;
;-

NET$SPCINS_NDI::			; Insert NDI block
	MOVL	R10,R5			; Save new CNF address
	MOVL	R6,R10			; Copy old CNF address
	BEQL	40$			; Br if no old CNF
	CMPL	R6,NET$GL_DUM_NDI	; Is this the phantom NDI?
	BEQL	40$			; Br if yes, skip deletion business
	BSBW	NET$DELETE_BTE		; Delete the old BTEs
	CMPL	R6,R5			; Is new CNF same as old CNF?
	BEQL	40$			; Br if yes, don't deallocate
	INSQUE	(R6),@NET$GQ_TMP_BUF	; Queue old CNF block for deallocation
40$:	MOVL	R5,R10			; Restore new CNF address
	BSBW	NET$ADD_NDI		; Insert the new BTEs pointing to CNF
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
90$:	RSB				; Return to caller


	.SBTTL	NET$DELETE_xxx - PRE-DELETE PROCESSING
;+
; NET$DELETE_xxx - Special processing before an entry is marked for delete
;
; This routine is called to perform any special action that may need to be
; taken before marking a CNF for delete.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11,R10	Preserved
;		R0	LBS if successful
;			LBC if CNF should not be marked for delete
;
;		All registers may be destroyed.
;-
NET$DELETE_LNI::			; Special processing before marking
NET$DELETE_AJI::
NET$DELETE_SDI::
NET$DELETE_ARI::
	CLRL	R0			; ABSOLUTELY NOT
	RSB

NET$DELETE_NDI::			; CNF for delete
	CLRL	R0			; Assume not delete-able
	BBS	#CNF$V_FLG_ACP,-	; Not deleteable if the ACP owns
		    CNF$B_FLG(R10),10$	; this block
	BBS	#NDI_V_LOCAL,-		; If set then this is the "local" node
		    CNF$B_FLG(R10),5$	; and cannot be deleted
	PUSHR	#^M<R1,R2,R8,R9>	; Save regs
	$GETFLD	ndi,s,col		; Get the collating value
	BSBW	NET$DELETE_BTE		; Delete the BTEs for this CNF
	POPR	#^M<R1,R2,R8,R9>	; Restore regs
	INSQUE	(R10),@NET$GQ_TMP_BUF	; Insert buffer on TMP_BUF queue.
5$:	MOVZBL	#1,R0			; Indicate success
10$:	RSB

NET$DELETE_OBI::
	$GETFLD	obi,l,pid		; See if declared name
	INCB	R0			; Invert status -- not delete-able if
	RSB				;  declared name

NET$DELETE_ESI::
	$GETFLD	esi,v,lck		; See if its locked
	CLRL	R0			; Assume not not delete-able
	BLBS	R8,10$			; If locked then not delete-able
	INCB	R0			; Else its delete-able
10$:	RSB				; 

NET$DELETE_EFI::
	$GETFLD	efi,v,lck		; See if its locked
	CLRL	R0			; Assume not not delete-able
	BLBS	R8,10$			; If locked then not delete-able
	INCB	R0			; Else its delete-able
10$:	RSB				; 

NET$DELETE_LLI::			; Delete Logical-link action routine
	MOVL	CNF$C_LENGTH + -	; Get XWB
		LLI$L_XWB(R10),R0	; 
	BEQL	10$			; If EQL, then its not there
	MOVL	NET$GL_NET_UCB,  R5	; Provide a "NET" UCB address
	MOVZWL	XWB$W_LOCLNK(R0),R3	; Get logical link number
	MOVZBL	#NET$C_DR_THIRD, R2	; Disconnect reason
	MOVZWL	XWB$W_REMNOD(R0),R1	; Get partner node address
	MOVZBL	#NETUPD$_DSCLNK, R0	; Setup function code
	BSBW	CALL_NETDRIVER		; Call the driver
10$:	MOVL	S^#SS$_NORMAL,R0	; Setup status
	RSB				; Done

NET$DELETE_SPI::			; Delete SPI database entry
	MOVL	#1,R0			; No special checking
	RSB

	.SBTTL	NET$REMOVE_xxx - PROCESS THE REMOVE REQUEST
	.SBTTL	NET$REMOVE_DEF - DEFAULT PROCESSING OF THE REMOVE REQUEST
;+
; NET$REMOVE_xxx - Processing after a block has been removed.
; NET$REMOVE_DEF - Default processing of the remove request.
;
; This routine is called to perform special processing after a CNF block has 
; been removed from the database.  On return, the block is deallocated.
;
; INPUTS:	R11	CNR pointer
;
; OUTPUTS:	All registers are preserved.
;-
NET$REMOVE_LNI::			; Remove Local node CNF action routine
NET$REMOVE_OBI::			; Remove Object CNF action routine
NET$REMOVE_SPI::
NET$REMOVE_AJI::
NET$REMOVE_SDI::
NET$REMOVE_ARI::
NET$REMOVE_DEF::				; Default CNF removal routine
	PUSHQ	R0				; Save registers
						;
	MOVL	R11,R1				; Start at head of queue
	BRB	30$				; Continue
	ASSUME	CNR$L_FLINK  EQ  CNF$L_FLINK
20$:	MOVL	CNF$L_FLINK(R1),R1		; Advance the pointer
30$:	MOVL	CNF$L_FLINK(R1),R0		; Advance to next CNF
	BBS    #CNF$V_FLG_CNR,CNF$B_FLG(R0),40$	; If BS then at root -- done
	BBCC   #CNF$V_FLG_DELETE,-		;
		 CNF$B_FLG(R0),20$		; If BC not marked for delete
	ASSUME	CNF$L_FLINK  EQ  0
	REMQUE	(R0),R0				; Remove this entry
	;
	;   Deallocate the CNF block
	;
	JSB	NET$DEALLOCATE			; Deallocate the block
	BRB	30$				;
						;
40$:	POPQ	R0				; Restore registers
	RSB

NET$REMOVE_LLI::				; Try to remove LLI entries
	PUSHQ	R0				; Save registers
						;
	MOVL	R11,R1				; Start at head of queue
	BRB	30$				; Continue
	ASSUME	CNR$L_FLINK  EQ  CNF$L_FLINK
20$:	MOVL	CNF$L_FLINK(R1),R1		; Advance the pointer
30$:	MOVL	CNF$L_FLINK(R1),R0		; Advance to next CNF
	BBS    #CNF$V_FLG_CNR,CNF$B_FLG(R0),40$	; If BS then at root -- done
	BICB   #CNF$M_FLG_DELETE,CNF$B_FLG(R0)	; Erase delete marker
	TSTL	CNF$C_LENGTH+LLI$L_XWB(R0)	; Still pointing to an XWB ?
	BNEQ	20$				; If NEQ yes, don't remove
	ASSUME	CNF$L_FLINK  EQ  0
	REMQUE	(R0),R0				; Remove this entry
	;
	;   Deallocate the CNF block
	;
	JSB	NET$DEALLOCATE			; Deallocate the block
	BRB	30$				;
						;
40$:	POPQ	R0				; Restore registers
	RSB

NET$REMOVE_EFI::				; Remove Event filter CNF action routine
NET$REMOVE_ESI::				; Remove Event sink CNF action routine
	PUSHQ	R0				; Save registers
	MOVL	R11,R1				; Start at head of queue
	BRB	30$				; Continue
	ASSUME	CNR$L_FLINK  EQ  CNF$L_FLINK
20$:	MOVL	CNF$L_FLINK(R1),R1		; Advance the pointer
30$:	MOVL	CNF$L_FLINK(R1),R0		; Advance to next CNF
	BBS    #CNF$V_FLG_CNR,CNF$B_FLG(R0),40$	; If BS then at root -- done
	BBC    #CNF$V_FLG_DELETE,-		;
		 CNF$B_FLG(R0),20$		; If BC not marked for delete
	ASSUME	CNF$L_FLINK  EQ  0
	REMQUE	(R0),R0				; Remove this entry
	;
	;   Deallocate the CNF block
	;
	PUSHL	R0			; Save block address
	BSBW	NET$DBC_EFI		; Inform EVL of database change
	POPL	R0			; Restore block address

	JSB	NET$DEALLOCATE		; Deallocate the block
	BRB	30$
40$:	POPQ	R0			; Restore registers
	RSB

NET$REMOVE_NDI::			; Remove NDI from the list
	RSB

	.SBTTL	SCAN_XWB - SCAN XWB LIST
;+
; SCAN_XWB - Scan XWB list to total active links and delay
;
; INPUTS:	R11 	NDI CNR address
;		R10 	NDI CNF address
;		R9	scratch
;		R8	Node address
;		R7 	RCB address
;		R1 - R0 scratch
;
; OUTPUTS:	R7	Average delay found
;		R8	Total number of active links
;-
	.SAVE_PSECT
	.PSECT	NET_LOCK_CODE,NOWRT,GBL

SCAN_XWB:				; Scan XWB list
	PUSHR	#^M<R2,R6>		; Save some reg(s)
	MOVL	R8,R1			; Copy the address
	BNEQ	5$			; If NEQ then not local
	MOVZWL	RCB$W_ADDR(R7),R1	; Copy the local address
	MOVZWL	RCB$W_ALIAS(R7),R2	; Copy the local alias address
5$:	DSBINT	#NET$C_IPL		; Synchronize with NETDRIVER
	MOVL	RCB$L_PTR_LTB(R7),R0	; Get LTB address
	MOVZWL	LTB$W_SLT_TOT(R0),R9	; Get no. of XWB's to check
	CLRQ	R7			; Init link count and delay
10$:	MOVL	LTB$L_SLOTS(R0)[R9],R6	; Get the next XWB
	BLBS	R6,20$			; If LBS slot not in use
	CMPW	XWB$W_REMNOD(R6),R1	; Remote node match?
	BEQL	15$			; Branch if match
	CMPW	XWB$W_REMNOD(R6),R2	; Alias match?
	BNEQ	20$			; Branch if not
15$:	INCL	R8			; Increment total active links
	MOVZWL	XWB$W_DELAY(R6),-(SP)	; Get delay
	ADDL	(SP)+,R7		; Add to total
20$:	SOBGTR	R9,10$			; Increment slot number and loop
	ENBINT				; Restore IPL
	CLRL	R0			; Assume node links
	TSTL	R8			; Any links?
	BEQL	30$			; If EQL no
	DIVL	R8,R7			; Compute average delay
	MOVL	#1,R0			; Indicate success
30$:	POPR	#^M<R2,R6>		; Restore registers
	RSB				;

	.RESTORE_PSECT

	.SBTTL	LNI PARAMETER ACTION ROUTINES
;+
; NET$LNI_V_LCK -  Get status of conditionally writeable fields
;
; NET$LNI_L_ADD -  Read or write executor address
; NET$LNI_L_ACL -  Get number of currently active links
;
; NET$LNI_S_COL -  Get collating value
; NET$LNI_S_NAM -  Get local node name
; NET$LNI_S_CNT -  Get (optionally clear) local counters
; NET$LNI_S_PHA -  Get NI physical address to be used by this node
;
; INPUTS:	R11	LNI CNR address
;		R10	LNI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$LNI_V_LCK::				; Get status of cond. writeable fields
	BSBW	NET$GET_LOC_STA		; Return local state in R0
	CMPB	#LNI$C_STA_OFF,R0	; Is the ACP off?
	BEQL	5$			; If so okay to write fields
	CMPB	#LNI$C_STA_INIT,R0	; Is the ACP init'ing
	BEQL	5$			; If so okay to write fields	
	MOVB	#1,R1			; Indicate fields are locked
	BRB	10$			; Continue
5$:	CLRL	R1			; Fields are not locked
10$:	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$LNI_L_STA::				; Executor state (read/write parameter)
	BLBC	R0,50$			; Branch if to be read
	MOVB	R8,CNF$C_LENGTH+LNI$B_STA(R10) ; Store in LNI
	BRB	80$
50$:	MOVZBL	CNF$C_LENGTH+LNI$B_STA(R10),R1 ; Get executor state
	CMPB	R1,#LNI$C_STA_INIT	; "Initializing" state?
	BNEQ	80$			; If not, then ok
	MOVZBL	#NMA$C_STATE_OFF,R1	; Assume OFF
80$:	MOVL	S^#SS$_NORMAL,R0	; Return success
	RSB

NET$LNI_L_ADD::				; Executor address (read/write parameter)
	BLBC	R0,50$			; Branch if to be read
	MOVW	R8,CNF$C_LENGTH+LNI$W_ADD(R10) ; Store in LNI
	BRB	80$
50$:	MOVZWL	CNF$C_LENGTH+LNI$W_ADD(R10),R1 ; Get node address
	BSBW	SUPPRESS_AREA		; Suppress area, if necessary
80$:	MOVL	S^#SS$_NORMAL,R0	; Return success
	RSB

NET$LNI_L_ACL::				; Get number of currently active links
	MOVL	NET$GL_PTR_VCB,R0	; Get RCB pointer
	BEQL	10$			; Br on error
	MOVZWL	RCB$W_MCOUNT(R0),R1	; Get number of links + 1
	DECL	R1			; Subtract out the ACP reference
	MOVB	#1,R0			; Indicate success
10$:	RSB

NET$LNI_S_COL::				; Get collating value
	MOVB	#1,(R3)+		; Enter a static value
	MOVB	#SS$_NORMAL,R0		; Indicate success
	RSB

NET$LNI_S_NAM::				; Get local node name
	MOVL	NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	NET$GL_LOCAL_NDI,R10	; Get the local NDI CNF
	$GETFLD	ndi,s,nna		; Get node name field
	BLBC	R0,10$			; Branch if not present
	MOVC	R7,(R8),(R3)		; Copy into buffer
	MOVB	#SS$_NORMAL,R0		; Indicate success
10$:	RSB				; Return status in R0

NET$LNI_S_CNT::				; Get (optionally clear) local counters
	MOVL	NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	NET$GL_LOCAL_NDI,R10	; Get the local NDI CNF
	BSBW	NET$NDI_S_CNT		; Get the counter block
	RSB				; Return status in R0

NET$LNI_S_PHA::
	$GETFLD	lni,l,add		; Get node address
	BLBC	R0,90$			; Error if not set
	MOVL	#TR$C_NI_PREFIX,(R3)+	; Set NI Phase IV prefix
	MOVW	R8,(R3)+		; Append Phase IV node address
90$:	RSB				; Success

	.SBTTL	NDI PARAMETER ACTION ROUTINES
;+
; NET$NDI_V_REA -  Get node reachability status
; NET$NDI_V_LCK -  Get status of conditionally writeable fields
; NET$NDI_V_LOO	-  Get bit which is set if the CNF is for a "loopback" nodename
;
; NET$NDI_L_ADD -  Read or write node address
; NET$NDI_L_ACL -  Get number of active links to the node
; NET$NDI_L_DEL -  Get delay to node
; NET$NDI_L_DTY -  Get node type
; NET$NDI_L_DCO -  Get total cost to node
; NET$NDI_L_DHO -  Get total hops to node
; NET$NDI_L_TAD -  Get transformed node address
; NET$NDI_L_NND -  Get next hop node address on path to remote node
;
; NET$NDI_S_HAC -  Get merged node address/loopback linename value
; NET$NDI_S_COL	-  Get collating sequence value
; NET$NDI_S_DLI -  Get line for normal traffic to node
; NET$NDI_S_CNT -  Get (optionally clear) node counters
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
;	*								  *
;	**								 **
;	***   This set of routines assumes that the node address field	***
;	***   is not an action routine and that it is always set.	***
;	**								 **
;	*								  *
;
NET$NDI_V_LOO::				; See if CNF is for a loopback node
	MOVL	#1,R1			; Assume loop node
	BBS	#NDI_V_LOOP,-		; If BS then loop node
		    CNF$B_FLG(R10),10$	;
	CLRL	R1			; Not a loop node
10$:	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Done

NET$NDI_V_LCK::				; Get status of cond. writeable fields
	CLRL	R1			; Say "not locked"
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$NDI_V_REA::				; Get node reachability status
	BSBW	NDI_SETUP		; Use common setup
	;
	;   See if we know what the next hop is to the remote node.
	;   If we can't determine the next hop, it is definitely
	;   unreachable.
	;
	BSBW	NEXT_HOP_ADJ		; Locate next hop ADJ
	BLBC	R0,42$			; If we don't have a next hop,
					; then it is definitely unreachable
	;
	;   Either we know it's reachable, or we are relying on another
	;   node to determine if it's reachable.  If we don't really know,
	;   then return "don't know".
	;
	MOVL	NET$GL_PTR_VCB,R7	; Get the RCB address
	MOVZWL	NDI_ADD(R10),R2		; Get the node address
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the remote area number
		#TR4$S_ADDR_AREA,R2,R0
	BEQL	39$			; If area = 0, then use our area
	CMPB	R0,RCB$B_HOMEAREA(R7)	; Our area?
	BNEQ	45$			; If not, we don't know it's status
39$:	BBS	#NDI_V_LOCAL,CNF$B_FLG(R10),40$ ; Skip check if local NDI
	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_PH4N ; Are we an endnode?
	BEQL	45$			; If so, skip reachability check
40$:	BSBW	NET$TEST_REACH		; Return reachability bit in R0
42$:	MOVZBL	R0,R1			; Return as param value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

45$:	CLRL	R0			; Failure ("don't know")
	RSB

NET$NDI_L_ADD::				; Node address (read/write parameter)
	BLBC	R0,50$			; Branch if to be read
	MOVW	R8,CNF$C_LENGTH+NDI$W_ADD(R10) ; Store in NDI
	BRB	80$
50$:	MOVZWL	CNF$C_LENGTH+NDI$W_ADD(R10),R1 ; Get node address
	BSBW	SUPPRESS_AREA		; Suppress area, if necessary
80$:	MOVL	S^#SS$_NORMAL,R0	; Return success
	RSB

NET$NDI_L_DCO::				; Get total cost to node
	BSBB	GET_COST_HOPS		; Get cost/hops to node
	BLBC	R0,90$			; Exit if error detected
	EXTZV	#0,#10,R1,R1		; Get cost
90$:	RSB

NET$NDI_L_DHO::				; Get total hops to node
	BSBB	GET_COST_HOPS		; Get cost/hops to node
	BLBC	R0,90$			; Exit if error detected
	EXTZV	#10,#5,R1,R1		; Get hops
90$:	RSB

GET_COST_HOPS:				; Get cost/hops to node
	BSBW	NDI_SETUP		; Call common setup
	TSTL	R8			; Address 0?
	BNEQ	5$			; If so,
	MOVZWL	RCB$W_ADDR(R7),R8	; then use our local address
	BRB	8$			; and skip following endnode check
5$:	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_PH4N ; Are we an endnode?
	BEQL	90$			; If so, then cost/hops "not known"
8$:	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R8,R4
	BEQL	10$			; If area = 0, assume our area
	CMPB	R4,RCB$B_HOMEAREA(R7)	; Our area?
	BNEQ	90$			; If not, then "not known"
10$:	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node number within area
		#TR4$S_ADDR_DEST,R8,R5
	CMPW	R5,RCB$W_MAX_ADDR(R7)	; Is node within range?
	BGTRU	90$			; If GTRU then no
	BSBW	TEST_REACH		; Get the node's type
	BLBC	R0,50$			; If we don't have it, not Phase II
	ASHL	#-16,R1,R0		; Isolate node type code
	CMPW	R0,#ADJ$C_PTY_PH2	; Phase II direct adjacency?
	BNEQ	50$			; Branch if not
	MOVZWL	#1@10+0,R1		; Return cost=0, hops=1
	BRB	80$			; Exit with success

50$:	MOVZWL	G^NET$AW_MIN_C_H[R5],R1	; Get cost/hops to node
80$:	MOVL	S^#SS$_NORMAL,R0	; Success
90$:	RSB

NET$NDI_L_ACL::				; Get number of active links
	BSBW	NDI_SETUP		; Call common setup
	JSB	SCAN_XWB		; Scan XWB list and total up links
	MOVL	R8,R1			; Store number of links
	RSB

NET$NDI_L_DEL::				; Get delay to node
	BSBW	NDI_SETUP		; Call common setup
	JSB	SCAN_XWB		; Scan XWB list and get average delay
	MOVL	R7,R1			; Store average delay
	RSB

NET$NDI_L_DTY::				; Get node type
	BSBW	NDI_SETUP		; Call common setup
	BSBW	TEST_REACH		; See if node is reachable
	BLBC	R0,30$			; If LBC then no
	ROTL	#16,R1,R1		; We only want the type
	MOVZWL	R1,R1			; Extract off the type
	CMPW	#ADJ$C_PTY_UNK,R1	; Is the type "unknown" ?
	BNEQ	30$			; If not return LBS in R0
	CLRL	R0			; Else indicate failure
30$:	RSB

NET$NDI_L_TAD::				; Get node transformed address
	BSBW	NDI_SETUP		; Call common setup
NDI_L_TAD:				; Get node transformed address
	MOVL	R8,R1			; Copy the address for returned value
	BNEQ	10$			; If NEQ then not local
	MOVZWL	RCB$W_ADDR(R7),R1	; Copy the local address
10$:	BSBW	SUPPRESS_AREA		; Suppress area if necessary
	MOVB	#1,R0			; Indicate success
	RSB

NET$NDI_L_NND::
	BSBW	NDI_SETUP		; Call common setup
	BSBB	NEXT_HOP_ADJ		; Locate next hop ADJ
	BLBC	R0,30$			; If LBC then no
	MOVZWL	ADJ$W_PNA(R7),R1	; Get partner's node address
	BSBW	SUPPRESS_AREA		; Suppress area if necessary
30$:	RSB

;
; Locate next hop ADJ
;
; Inputs:
;
;	R10 = CNF address
;	R8 = Node address
;	R7 = RCB address
;
; Outputs:
;
;	R7 = ADJ address
;	R1 = ADJ index
;	R0 = status
;
;	R8 is destroyed.

NEXT_HOP_ADJ:
	BBS	#NDI_V_LOCAL,-		; If not local node,
		CNF$B_FLG(R10),1$
	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_PH4N ; Are we an endnode?
	BNEQ	1$			; Skip if not
	MOVZWL	RCB$W_DRT(R7),R1	; Setup ADJ to designated router
	BRB	8$			; Get next hop ADJ
1$:	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R8,R0
	BEQL	10$			; If area = 0, then use our area
	CMPB	R0,RCB$B_HOMEAREA(R7)	; Is this in our area?
	BEQL	10$			; If so, then it's ok
	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_AREA ; Do we know about outside areas?
	BEQL	5$			; If so, lookup next hop for area
4$:	MOVZWL	RCB$W_LVL2(R7),R1	; Get ADJ to nearest level 2 router
	BRB	8$			; Get next hop ADJ
5$:	BBC	#RCB$V_LVL2,-		; If we are not enabled for Level 2
		RCB$B_STATUS(R7),4$	; routing, then act like a Level 1 router
	CMPB	R0,RCB$B_MAX_AREA(R7)	; Within range?
	BGTRU	70$			; If out of range, unreachable
	MOVZWL	@RCB$L_PTR_AOA(R7)[R0],R1 ; Get ADJ to area router
8$:	MOVL	R1,R8			; Pass ADJ index argument
	BSBW	NET$FIND_ADJ		; Get next hop ADJ address
	BRB	20$			; Return with R0/R1/R7 set

10$:	BSBW	TEST_REACH		; See if node is reachable & get ADJ
20$:	RSB

70$:	CLRL	R0			; Unreachable
	RSB

NET$NDI_S_CNT::				; Get node counters
	MOVZWL	#SS$_BADPARAM,R0	; Assume loop-node
	BBS	#NDI_V_LOOP,-		; If BS then loop node
		    CNF$B_FLG(R10),30$	; ...no counters for loop nodes
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
					;
	PUSHL	R3			; Save original output pointer
	PUSHAB	B^20$			; Setup return address
	MOVZWL	CNF$W_ID(R10),R8	; Get node address
	BEQL	LOCAL_NODE_CNT		; If EQL then local node
	BRW	NODE_CNT		; Else remote node
20$:	POPL	R2			; Recover orginal counter block ptr
					;
	BLBC	R0,30$			; Br on error
	MOVL	S^#EVC$C_SRC_NOD,R0	; Setup event database i.d.
	BSBW	LOG_COUNTERS		; Log the counter block if needed
	MOVL	#1,R0			; Success
30$:	RSB				; Done

LOCAL_NODE_CNT:
	;
	;   Get local node counters.  First get the common node counters, the
	;   first block of which is the 'seconds since last zeroed' counter.
	;   Append the local-node-only counters, the first block of which is
	;   also the 'seconds since last zeroed' counter.  Shift the counters
	;   to squeeze out this redundant counter.
	;
	MOVZWL	RCB$W_ADDR(R4),R8	; Get local node address
	BSBB	NODE_CNT		; Get common node counters
	;
	;	Now get snap-shot of local node counters from RCB
	;
	MOVAB	RCB$L_ABS_TIM(R4),R1	; Point to start of local node
					; counters
	MOVZWL	#RCB$C_CNT_SIZE+4,R2	; Total size of block 
	;
	;   Now format the counters
	;
	MOVAB	RCB_CNT_TAB,R5		; Point to counter formatting table
	MOVL	R3,R7			; Save output buffer pointer
	JSB	MOVE_FMT_CNT		; Move and format the counters
	SUBL3	R7,R3,R2		; Get number of bytes just moved
	SUBL	#4,R2			; Account for superfulous 'seconds
					; since last zeroed'
	BLSS	60$			; If LSS then no NDI counts were moved
	MOVC3	R2,4(R7),(R7)		; Shift the counters, update R3
60$:	MOVB	#1,R0			; Indicate success
	RSB				; Return status to co-routine

NODE_CNT:				; Move common node counters
	PUSHR	#^M<R4,R6>		; Save regs
	SUBL	#CNT_FMT_BUFSIZ,SP	; Create work area on stack
	MOVL	SP,R6			; Point to it with R6
	CLRL	R4			; Assume we don't clear counters
	BBC	#NET$V_CLRCNT,-		; If BC, don't clear the counters
		    NET$GL_FLAGS,20$	;
	INCL	R4			; Else, zero the counters
20$:	BSBW	NET$READ_NDI_CNT	; Get the node counters
	BLBC	R0,50$			; Br if no node counters
	MOVZWL	#NDC$C_LENGTH,R2	; Get size of node counter area
	MOVAB	NDC_CNT_TAB,R5		; Set counter formatting table
	JSB	FMT_CNT			; Format the counters
30$:	;
	;   Done, restore the stack and return
	;
	ADDL	#CNT_FMT_BUFSIZ,SP	; Create work area on stack
	POPR	#^M<R4,R6>		; Restore regs
	RSB				; Done, return status in R0

50$:	MOVZWL	#SS$_NOSUCHNODE,R0	; Node counters unavailable
	BRB	30$			; And leave


NET$NDI_S_DLI::				; Get line for normal traffic to node
	$CNFFLD	ndi,s,nli,R9		; Identify loopback linename
	BBS	#NDI_V_LOOP,-		; If BS then loopback node
		    CNF$B_FLG(R10),5$	;
	BSBW	NDI_SETUP		; Call standard setup
	BSBW	NEXT_HOP_ADJ		; Get next hop ADJ address
	BLBC	R0,10$			; Skip if not found
	MOVZWL	R1,R8			; Setup ADJ index for subroutine call
	BSBW	NET$ADJ_LPD_CRI		; Get the CRI for this adjacency
	BLBC	R0,10$			; If LBC then index is invalid
	CLRL	R0			; Assume no CRI
	TSTL	R10			; Is there an associate CRI ?
	BEQL	10$			; If EQL no (could be "local" LPD)
	$CNFFLD	cri,s,nam,R9		; Identify the line name field
5$:	BSBW	CNF$GET_FIELD		; Get it
	BLBC	R0,10$			; Branch if not present
	MOVC	R7,(R8),(R3)		; Copy into buffer
	MOVZWL	#SS$_NORMAL,R0		; Indicate successful
10$:	RSB				; Return status in R0

	;
	;    Return the collating sequence string used to determine where
	;    in the CNF list this particular NDI should be inserted.  The
	;    expected order here is: 
	;
	;	- NDI's are sorted first according to the collating value of
	;	  their associated "loopback" line -- the collating value of
	;	  the null "loopback" line is zero and therefore NDI's without
	;	  a "loopback" line will appear first in the list.
	;
	;	- NDI's with the same "loopback" line are sorted in ascending
	;	  order of their node address -- since the node address 
	;	  associated with the local node's NDI is zero by convention
	;	  it will appear first.
	;
NET$NDI_S_COL::				; Get collating sequence string
	CLRB	(R3)+			; Begin with lowest possible value
	BBC	#NDI_V_LOOP,-		; If BC then not loop node
		    CNF$B_FLG(R10),10$	;
	MNEGB	#1,-1(R3)		; Start string with huge value
10$:	MOVB	NDI_ADD+1(R10),(R3)+	; Enter high order node address byte
	MOVB	NDI_ADD+0(R10),(R3)+	; Enter low  order node address byte
	BSBB	HAC1			; Append loopback linename, if any
	BBC	#NDI_V_MARKER,-		; If marker CNF,
		CNF$B_FLG(R10),20$
	MOVB	#1,(R3)+		; Then add a byte to make the node
					; number unique from normal CNFs
20$:	RSB
	
NET$NDI_S_HAC::				; Get hashed node addr/loopback
					; linename value
	;
	;    This value is used in a uniqueness check to enforce the rule
	;    that "no two NDI entries that have the same node address
	;    will be associated with the same loopback circuit name".  
	;
	MOVW	NDI_ADD(R10),(R3)+	; Store the node address
HAC1:	$CNFFLD	ndi,s,nli,R9		; Identify loopback linename field
	BSBW	MOVSTR			; Append it to address
	MOVB	#1,R0			; Indicate success if we got this far
	RSB				; Retrun to co-routine

NDI_SETUP:
	MOVZWL	NDI_ADD(R10),R8		; Get the address
	MOVL	NET$GL_PTR_VCB,R7	; Get the RCB address
	MOVZWL	#SS$_NOSUCHNODE,R0	; Assume failure
	RSB

TEST_REACH:
	PUSHL	R2			; Save reg
	MOVL	R8,R2			; Copy address
	BSBW	NET$TEST_REACH		; Make test
	POPL	R2
	RSB

NET$NDI_S_NNN::				; Name of next node to destination
	BSBW	NET$NDI_L_NND		; Get node number of "next node"
	BLBC	R0,90$			; Skip if failure
	MOVL	R1,R8			; Set node number to lookup
	BSBW	NET$NDI_BY_ADD		; Lookup NDI entry
	BLBC	R0,90$			; If not found, then no name
	$GETFLD	ndi,s,nna		; Get node name field
	BLBC	R0,90$			; Branch if not present
	MOVC	R7,(R8),(R3)		; Copy into buffer
	MOVZWL	S^#SS$_NORMAL,R0	; Success
90$:	RSB

	.SBTTL	SUPPRESS_AREA - Suppress area from node address
;+
; SUPPRESS_AREA - Suppress area from node address, if necessary
;
; For compatibility with older versions of DECnet at the network
; management layer, we must provide a mechanism so that area numbers
; are not returned to network management (NML or EVL) if the user
; doesn't know about areas.  This is done by setting a flag when
; the executor address is set, based on whether the user explicitly
; set the executor to a specific area or not.
;
; This routine expects to be called from a parameter action routine,
; where NET$V_INTRNL has been set up properly.
;
; Inputs:
;
;	R1 = Node address
;
; Outputs:
;
;	R1 = New node address, with area possibly suppressed
;
;	All other registers are preserved.
;-

SUPPRESS_AREA::
	RSB				; Just return for now
	PUSHR	#^M<R0,R7,R8,R9,R10,R11>	; Save registers
	MOVL	NET$GL_CNR_LNI,R11	; Set CNR address
	MOVL	NET$GL_PTR_LNI,R10	; Set CNF address
	BEQL	90$			; If none, then address must be 0
	$GETFLD	lni,v,sup		; If areas not suppressed,
	BLBC	R8,90$			; then skip it
	BBS	#NET$V_INTRNL,NET$GL_FLAGS,90$ ; If internal, do not suppress
	INSV	#0,#TR4$V_ADDR_AREA,-	; Suppress the area number
		#TR4$S_ADDR_AREA,R1
90$:	POPR	#^M<R0,R7,R8,R9,R10,R11>	; Restore registers
	RSB

	.SBTTL	NET$TEST_REACH - Test node reachability
;+
; NET$TEST_REACH - Test node reachability
;
;  This routine tests the reachability of a node independent of the
;  presence of a NDI data block.  Note that a Phase III non-adjacent
;  node can be reached even though there is no NDI block for that node
;  since the output line is mapped by address -- no other information
;  is required.
;
;  This routine returns:
;
;	1) whether it is reachable or not
;	2) the ADJ to get to the node
;	3) the "node type" (only if node is a direct adjacency)
;
;  Inputs:  R2  Node address
;	    R1	Scratch
;	    R0	Scratch
;
;  Outputs: R7	ADJ address
;	    R1	Adjacency index of path used to reach the node
;		High word has node type
;	    R0  Status
;
;	All other registers are preserved.
;-

NET$TEST_REACH::			; Test for node reachablity
	PUSHR	#^M<R3,R4,R6,R8>	; Save registers
	PUSHL	#0			; Init storage on stack
	MOVZWL	#SS$_NOSUCHNODE,R0	; Assume node out of range
	MOVL	NET$GL_PTR_VCB,R1	; Get the RCB
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R2,R3
	BNEQ	5$			; If area = 0,
	MOVZBL	RCB$B_HOMEAREA(R1),R3	; then use our area
5$:	EXTZV	#TR4$V_ADDR_DEST,-	; Get the node number within area
		#TR4$S_ADDR_DEST,R2,R4
	CMPB	R3,RCB$B_HOMEAREA(R1)	; Is this in our area?
	BNEQ	100$			; If not, then return unreachable
	CMPW	R4,RCB$W_MAX_ADDR(R1)	; Within range ?
	BGTRU	100$			; If GTRU then out of range
	MOVZWL	@RCB$L_PTR_OA(R1)[R4],(SP)  ; Get ADJ index to the node
	MOVL	(SP),R8			; Get index
	BSBW	NET$FIND_ADJ		; Get ADJ & LPD address
	BLBC	R0,80$			; If error, report node unreachable
	MOVW	#ADJ$C_PTY_UNK,2(SP)	; Assume type is unknown
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area of the adjacency
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R7),R0
	BEQL	10$			; If area = 0, skip area match
	CMPL	R0,R3			; Does area match?
	BNEQ	50$			; If not, then not adjacent
10$:	CMPZV	#TR4$V_ADDR_DEST,-	; Does node number match?
		#TR4$S_ADDR_DEST,ADJ$W_PNA(R7),R4
	BNEQ	50$			; If not, we don't know the type
	MOVZBW	ADJ$B_PTYPE(R7),2(SP)	; Store type of partner node
50$:	MOVL	S^#SS$_NORMAL,R0	; Indicate reachable
	BRB	100$			; And exit with success
80$:	MOVZWL	#SS$_UNREACHABLE,R0	; Node is known, but unreachable
100$:	POPL	R1			; Recover path and type
	POPR	#^M<R3,R4,R6,R8>	; Restore registers
	RSB

	.SBTTL	OBI PARAMETER ACTION ROUTINES
;+
; NET$OBI_V_LCK -  Get status of conditionally writeable fields
;
; NET$OBI_S_COL -  Get collating value
; NET$OBI_S_ZNA -  Get combined number,name
; NET$OBI_S_IAC -  Get default inbound access
; NET$OBI_S_SFI -  Startup file id string
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-

NET$OBI_V_LCK::				; Get status of cond. writeable fields
	;
	;   If the UCB field is active then the object is a "declared" object
	;   or name and the conditionally writeable fields are locked.
	;
	$GETFLD	obi,l,ucb		; Fetch UCB field
	MOVL	R0,R1			; If UCB field is active then CNF is
					; locked
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return to co-routine

NET$OBI_S_COL::				; Get collating value
NET$OBI_S_ZNA::				; Get combined number,name
	;
	;   This string is used for collating and uniqueness checking.  The
	;   blocks are to be collated by number and all non-zero numbers must
	;   be unique (not two CNFs may share a object number) unless that
	;   number is zero -- since declared names will all have the object
	;   type zero.   Thus the value of this field is the object number
	;   alone if the number is non-zero, or the object number followed
	;   by the name if the number is zero.
	;
	;   Note: If the name itself is required to be unique then that
	;	  check must be made elsewhere.
	;
	$GETFLD	obi,l,num		; Get the object number
	BLBC	R0,20$			; Br on error
	MOVB	R8,(R3)+		; Move the number
	BNEQ	20$			; If NEQ then we're done
	$CNFFLD	obi,s,nam,R9		; Identify the object name
	BSBW	MOVSTR			; Append it to buffer
	BLBC	R0,20$			; Br on error
	TSTW	R7			; Is the length zero ?
	BNEQ	20$			; If NEQ then okay
	CLRL	R0			; Else illegal ZNA value
20$:	RSB				; Return status to co-routine


NET$OBI_S_IAC::				; Get default inbound access
	PUSHAB	3(R3)			; Null access strings are 3 null bytes
	$CNFFLD	obi,s,usr,R9		; Setup field id
	BSBW	MOVCSTR			; Move the username
	$CNFFLD	obi,s,psw,R9		; Setup password field id
	BSBW	MOVCSTR			; Move it
	$CNFFLD	obi,s,acc,R9		; Setup account id
	BSBW	MOVCSTR			; Move it
	CMPL	(SP)+,R3		; Is the access control null?
	BNEQ	10$			; If NEQ no - proceed
	MOVQ	R10,-(SP)		; Save OBI CNF,CNR
	MOVL	NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	NET$GL_LOCAL_NDI,R10	; Get the local NDI CNF
	SUBL	#3,R3			; Reset R3
	$CNFFLD	ndi,s,nus,R9		; Setup field id
	BSBW	MOVCSTR			; Move the username
	$CNFFLD	ndi,s,npw,R9		; Setup password field id
	BSBW	MOVCSTR			; Move it
	$CNFFLD	ndi,s,nac,R9		; Setup account id
	BSBW	MOVCSTR			; Move it
5$:	MOVQ	(SP)+,R10		; Restore OBI CNF,CNR
10$:	MOVL	#1,R0			; Always successful
	RSB				; Return to co-routine to return desc.

NET$OBI_S_SFI::				; Startup file id string
	;
	;  Build .COM filename spec for image activation.
	;
	;   filename =  SYS$SYSTEM:file.COM if the object number NEQ 0
	;				or if object name starts with "$"
	;		file			     if the object number EQL 0
	;
	;		where "file" comes from OBI,S,FID if its defined
	;		or OBI,S,NAM otherwise.
	;
	$GETFLD	obi,l,num		; Get the object number
	MOVL	R8,R1			; Save object number
	$GETFLD	obi,s,fid		; Setup field id
	BLBS	R0,10$			; If LBS then field is non-null
	$GETFLD	obi,s,nam		; Else use the object's name
	BLBC	R0,30$			; If LBC then null, filename is illegal
10$:	TSTL	R1			; Is this for object number 0?
	BNEQ	20$			; If NEQ no, use system defaults
	CMPB	(R8),#^A"$"		; Does name start with "$"?
	BEQL	15$			; If so, use system defaults
	MOVC3	R7,(R8),(R3)		; Else allow LOGIN to use user's defaults
	MOVB	#1,R0			; Indicate success
	BRB	30$			; Continue
15$:	INCL	R8			; Strip off "$"
	DECL	R7
20$:	MOVAB	NET$T_SYSFAB,R0		; Setup for "non-zero object" defaults
	MOVB	R7,FAB$B_FNS(R0)	; Set the current filename size
	MOVL	R8,FAB$L_FNA(R0)	; Set the current filename ptr
	MOVAB	NET$T_PRSNAM,R2		; Get output descriptor address
	MOVAB	(R3),NAM$L_ESA(R2)	; Set the buf ptr to rcv parse
	$PARSE	FAB = R0		; Get the filename
	MOVZBL	NAM$B_ESL(R2),R2	; Get the size of the filename
	;
	; If the source string did not contain a trailing semicolon,
	; strip it from the parsed string so that the image activator 
	; will use the installed version of the image (if any).
	;
	PUSHR	#^M<R0,R1>		; Preserve volatile registers
	LOCC	#^A";",R7,(R8)		; Find address of trailing ";"
	BNEQ	25$			; If NEQ, found it 
	LOCC	#^A";",R2,(R3)		; Find version number in parsed string
	SUBL2	R0,R2			; Reduce size of string by size of ver.
	MOVB	R2,NET$T_PRSNAM+NAM$B_ESL ; ...also in the $NAM block
25$:	POPR	#^M<R0,R1>		; Restore volatile registers
	ADDL	R2,R3			; Advance buffer pointer
30$:	RSB				; Return status in R0

	.SBTTL	ESI PARAMETER ACTION ROUTINES
;+
; NET$ESI_V_LCK -  Get status of conditionally writeable fields
; NET$ESI_S_COL -  Get collating value
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-

NET$ESI_V_LCK::				; Get status of cond. writeable fields
	;
	;   If the state is not "OFF" then the CNF is writelocked
	;
	$GETFLD	esi,l,sta		; Fetch UCB field
	BLBC	R0,10$			; If field isn't set then CNF not locked
	CMPL	S^#NMA$C_STATE_OFF,R8	; Is the state "OFF"
	BNEQ	10$			; If not with R0=1
	CLRL	R0			; Otherwize, CNF is not locked	
10$:	MOVL	R0,R1			; Setup field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return to co-routine

NET$ESI_S_COL::				; Get collating value
	$CNFFLD	esi,l,snk,R9		; Specify sink type
	BRB	CONVERT			; Store it as a string


	.SBTTL	EFI PARAMETER ACTION ROUTINES
;+
; NET$EFI_V_LCK -  Get status of conditionally writeable fields
; NET$EFI_S_COL -  Get collating value
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-

NET$EFI_V_LCK::				; Get status of cond. writeable fields
	CLRL	R0			; CNF is never locked	
	MOVL	#1,R0			; Success
	RSB				; Return

NET$EFI_S_COL::				; Get collating value
	$CNFFLD	efi,l,sin,R9		; Specify sink node address
CONVERT:BSBW	CNF$GET_FIELD		; Get its value
	BLBC	R0,10$			; If LBC then not active
	PUSHL	R8			; Push it onto the stack
	MOVB	(SP)+,(R3)+		; Move all 4 bytes to buffer, high
	MOVB	(SP)+,(R3)+		; order byte first
	MOVB	(SP)+,(R3)+
	MOVB	(SP)+,(R3)+
10$:	RSB				; Retrun to co-routine

	.SBTTL	LLI PARAMETER ACTION ROUTINES
;+
; NET$LLI_V_LCK	- See if CNF is write-locked
;
; NET$LLI_L_PID - Get process I.D. (external format)
; NET$LLI_L_IPID- Get process internal I.D.
; NET$LLI_L_DLY - Get round trip delay time
; NET$LLI_L_STA - Get link state
; NET$LLI_L_RLN - Get remote link number
; NET$LLI_L_LLN - Get local link number
; NET$LLI_L_PNA - Get remote node address from XWB
;
; NET$LLI_S_PNN	- Get Partner node name
; NET$LLI_S_COL	- Get collating value
; NET$LLI_S_PRC	- Get owner process name
; NET$LLI_S_USR	- Get owner user name
; NET$LLI_S_RID	- Get remote user i.d.
; NET$LLI_S_CNT - Get link counters
;
; INPUTS:	R11	LLI CNR address
;		R10	LLI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		R2-R5 may be destroyed.
;
;		All other register values are preserved.
;
;-

NET$LLI_V_LCK::				; See if CNF is write-locked
;;&&	MOVZBL	#1,R1			; Field value
;;&&	MOVZBL	#SS$_NORMAL,R0		; Indicate success
;;&&	RSB				; Return

	CLRL	R1			; Assume LLI is locked
	$GETFLD	LLI,L,STA		; Get the current STATE
	BLBC	R0,30$			; Br if error in obtaining field
	CMPL	#XWB$C_STA_RUN,R8	; Is this link running?
	BEQL	30$			; Br if yes, LLI is locked
	MOVZBL	#1,R1			; Else, LLI is unlocked
30$:	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB

NET$LLI_L_PID::				; Get external PID
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVL	XWB$L_PID(R0),R0	; Get PID
	JSB	G^EXE$IPID_TO_EPID	; Convert it
	MOVL	R0,R1			; Return it
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return

NET$LLI_L_IPID::			; Get Internal PID
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVL	XWB$L_PID(R0),R1	; Return PID
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return

NET$LLI_L_DLY::
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZWL	XWB$W_DELAY(R0),R1	; Return the round trip delay
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return
	
NET$LLI_L_RLN::
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZWL	XWB$W_REMLNK(R0),R1	; Return the remote link number
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB
				; Return
NET$LLI_L_LLN::
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZWL	XWB$W_LOCLNK(R0),R1	; Return the remote link number
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return

NET$LLI_L_PNA::
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZWL	XWB$W_REMNOD(R0),R1	; Return the remote link number
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return

NET$LLI_L_STA::
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZBL	XWB$B_STA(R0),R1	; Return the link state
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return

NET$LLI_S_CNT::				; Get link counters
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return

NET$LLI_S_RID::				; Get remote user i.d.
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZBL	XWB$B_RID(R0),R1	; Get remote user i.d. string length
	BEQL	10$			; If EQL return with LBC in R0
	MOVC3	R1,XWB$T_RID(R0),(R3)	; Move the name
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
10$:	RSB				; Return


NET$LLI_S_PRC::				; Get owner process name
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVL	XWB$L_PID(R0),R0	; Get PID
	BSBB	GET_JPI			; Get Job/process info
	BLBC	R0,10$			; If LBC then info not found
	MOVZBL	PNAMES,R0		; Get string size
	BEQL	10$			; If EQL return with LBC in R0
	MOVC3	R0,PNAME,(R3)		; Move the process name
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
10$:	RSB				; Return

NET$LLI_S_USR::				; Get owner user name
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVL	XWB$L_PID(R0),R0	; Get PID
	BSBB	GET_JPI			; Get Job/process info
	BLBC	R0,10$			; If LBC then info not found
	MOVZBL	UNAMES,R0		; Get string size
	BEQL	10$			; If EQL return with LBC in R0
	MOVC3	R0,UNAME,(R3)		; Move the username
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
10$:	RSB				; Return

GET_JPI:				; Get Job/process info
	TSTL	R0			; Any PID yet?
	BEQL	10$			; If EQL no, return LBC in R0
	JSB	G^EXE$IPID_TO_EPID	; Convert to EPID
	PUSHL	R0			; Save EPID on stack for call
	MOVL	SP,R0			; Get address of EPID
	$GETJPI_S -			;
	    PIDADR = (R0),-		; EPID of process of interest
	    EFN    = #NET$C_EFN_WAIT,-	; Event flag
	    IOSB   = IOSB,-		; IOSB
	    ITMLST = ITEM_LIST		; Item list for return
	ADDL	#4,SP			; Pop EPID off stack
	BLBC	R0,10$			; Br on error
	$WAITFR_S  EFN = #NET$C_EFN_WAIT; Wait for $GETJPI to finish
	MOVZWL	IOSB,R0			; Setup status
10$:	RSB				; Return status in R0

NET$LLI_S_COL::				; Collating value
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVB	XWB$W_REMNOD+1(R0),(R3)+; Insert remode node address
					; ... high order first
	MOVB	XWB$W_REMNOD(R0),(R3)+	; 
	MOVW	XWB$W_LOCLNK(R0),R0	; Get logical link number
	BICW3	#^C<NET$M_MAXLNKMSK>,R0,-(SP) ; Use index bits only
	TSTB	(SP)+			; Pop low order bits (they're in R0)
	MOVB	(SP)+,(R3)+		; Insert high order
	MOVB	R0,(R3)+		; Insert low order
	MOVZBL	#SS$_NORMAL,R0		; Indicate success
	RSB

NET$LLI_S_PNN::				; Partner node name
	MOVL	NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	CNF$C_LENGTH -		; Get address of XWB
		+LLI$L_XWB(R10),R0
	MOVZWL	XWB$W_REMNOD(R0),R8	; Get node address
	BSBW	NET$NDI_BY_ADD		; Get associated NDI CNF address
	BLBC	R0,10$			; If LBC then no NDI
	$GETFLD	ndi,s,nna		; Get node name
	BLBC	R0,10$			; Branch if not present
	MOVC	R7,(R8),(R3)		; Copy into buffer
	MOVZBL	#SS$_NORMAL,R0		; Indicate successful
10$:	RSB				; Return status in R0

	.SBTTL	SPI PARAMETER ACTION ROUTINES
;+
; NET$SPI_S_COL -  Get collating value
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R9	FLD i.d. of field being read
;		R3	Address of result buffer
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;-

NET$SPI_V_LCK::				; "CNF locked" flag
	MOVL	#1,R0			; Mark all "cond write" fields as
	RSB				; cannot be written.

NET$SPI_S_COL::				; Get collating value
	$GETFLD	spi,l,pid		; Get server process PID
	BLBC	R0,90$			; Branch if not set
	MOVW	R8,-(SP)		; Push low order word (process index)
	MOVB	(SP)+,(R3)+		; Invert bytes, move to buffer
	MOVB	(SP)+,(R3)+
90$:	RSB

	.SBTTL	AJI PARAMETER ACTION ROUTINES
;+
; NET$AJI_V_REA -  Get adjacency "run" status
;
; NET$AJI_L_ADD -  Get partner node address
; NET$AJI_L_TYP -  Get partner node type
; NET$AJI_L_LIT -  Get adjacency listen interval
; NET$AJI_L_BLO -  Get partner block size
; NET$AJI_L_RPR -  Get partner broadcast router priority
;
; NET$AJI_S_COL -  Get collating value
; NET$AJI_S_NNA -  Get partner node name
; NET$AJI_S_CIR -  Get circuit name
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R9	FLD i.d. of field being read
;		R3	Address of result buffer
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;-

NET$AJI_V_LCK::				; "CNF locked" flag
	MOVL	#1,R0			; Mark all "cond write" fields as
	RSB				; cannot be written.

NET$AJI_V_REA::
	BSBW	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	EXTZV	#ADJ$V_RUN,#1,ADJ$B_STS(R7),R1 ; Get flag
90$:	RSB

NET$AJI_L_ADD::
	BSBW	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	MOVZWL	ADJ$W_PNA(R7),R1	; Return node address
	BEQL	80$			; If none, then return "not set"
	BSBW	SUPPRESS_AREA		; Suppress area if necessary
	RSB

80$:	CLRL	R0			; Indicate parameter "not set"
90$:	RSB

NET$AJI_L_TYP::
	BSBW	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	MOVZBL	ADJ$B_PTYPE(R7),R1	; Return node type
90$:	RSB

NET$AJI_L_LIT::
	BSBW	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	BBC	#ADJ$V_RUN,ADJ$B_STS(R7),80$ ; Branch if ADJ not up
	MOVZWL	ADJ$W_INT_LSN(R7),R1	; Return listen interval
	BNEQ	90$			; Ok if non-zero
80$:	CLRL	R0			; Indicate parameter "not set"
90$:	RSB

NET$AJI_L_BLO::
	BSBW	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	BBC	#ADJ$V_RUN,ADJ$B_STS(R7),80$ ; Branch if ADJ not up
	MOVZWL	ADJ$W_BUFSIZ(R7),R1	; Return partner block size
	BNEQ	90$			; Ok if non-zero
80$:	CLRL	R0			; Indicate parameter "not set"
90$:	RSB

NET$AJI_L_RPR::
	BSBW	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	CLRL	R0			; Assume failure
	BBC	#ADJ$V_RUN,ADJ$B_STS(R7),90$ ; Branch if ADJ not up
	MOVZBL	ADJ$B_BCPRI(R7),R1	; Return broadcast router priority
	MOVL	S^#SS$_NORMAL,R0	; Successful
90$:	RSB

NET$AJI_S_COL::				; Get collating value
	MOVW	CNF$W_ID(R10),-(SP)	; Push ADJ index
	MOVB	(SP)+,(R3)+		; Invert bytes, move to buffer
	MOVB	(SP)+,(R3)+
	MOVL	S^#SS$_NORMAL,R0	; Successful
	RSB

NET$AJI_S_NNA::
	BSBB	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	CLRL	R0			; Assume failure
	BBC	#ADJ$V_RUN,ADJ$B_STS(R7),90$ ; Branch if ADJ not up
	MOVZWL	ADJ$W_PNA(R7),R8	; Get partner node address
	MOVL	NET$GL_CNR_NDI,R11	; Get NDI root address
	BSBW	NET$NDI_BY_ADD		; Locate NDI CNF block
	BLBC	R0,90$			; Branch if not found
	$CNFFLD	ndi,s,nna,R9		; Set node name field ID
	BSBW	MOVSTR			; Copy it to output buffer
90$:	RSB

NET$AJI_S_CIR::
	BSBB	LOCATE_ADJ		; Lookup adjacency
	BLBC	R0,90$			; Branch if error
	$CNFFLD	cri,s,nam,R9		; Set circuit name field ID
	BSBW	MOVSTR			; Copy it to output buffer
90$:	RSB

LOCATE_ADJ:
	MOVZWL	CNF$W_ID(R10),R8	; Get ADJ index
	BSBW	NET$ADJ_LPD_CRI		; Get CRI CNF, LPD & ADJ pointers
	RSB

	.SBTTL	SDI PARAMETER ACTION ROUTINES
;+
; NET$SDI_L_SUB -  Get DLE substate
; NET$SDI_L_PID -  Get PID of process owning DLE link
;
; NET$SDI_S_COL -  Get collating value
; NET$SDI_S_CIR -  Get circuit for DLE link
; NET$SDI_S_PHA -  Get DLE physical address (BC only)
; NET$SDI_S_PRC -  Get name of process owning DLE link
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R9	FLD i.d. of field being read
;		R3	Address of result buffer
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;-

NET$SDI_V_LCK::				; "CNF locked" flag
	MOVL	#1,R0			; Mark all "cond write" fields as
	RSB				; cannot be written.

GET_DWB_ADR:
	MOVL	CNF$C_LENGTH+2(R10),R6	; Get saved DWB address from scan routine
	RSB

NET$SDI_L_SUB::
	BSBB	GET_DWB_ADR		; Get DWB address
	MOVZBL	DWB$B_SUBSTA(R6),R1	; Return value
	MOVL	#1,R0			; Success
	RSB

NET$SDI_L_PID::
	BSBB	GET_DWB_ADR		; Get DWB address
	MOVL	DWB$L_PID(R6),R1	; Return value
	MOVL	#1,R0			; Success
	RSB

NET$SDI_S_COL::
	MOVW	CNF$W_ID(R10),-(SP)	; Push DWB identifier
	MOVB	(SP)+,(R3)+		; Copy reversing all the bytes
	MOVB	(SP)+,(R3)+
	MOVL	#1,R0			; Success
	RSB

NET$SDI_S_CIR::
	BSBB	GET_DWB_ADR		; Get DWB address
	MOVZWL	DWB$W_PATH(R6),R8	; Get LPD ID
	BSBW	NET$GET_LPD_CRI		; Get CRI CNF, LPD pointers
	BLBC	R0,90$			; Branch if error
	$CNFFLD	cri,s,nam,R9		; Set circuit name field ID
	BSBW	MOVSTR			; Copy it to output buffer
90$:	RSB

NET$SDI_S_PHA::
	BSBB	GET_DWB_ADR		; Get DWB address
	MOVL	DWB$G_REMNOD(R6),(R3)+	; Copy into buffer
	MOVW	DWB$G_REMNOD+4(R6),(R3)+
	MOVL	#1,R0			; Success
	RSB

NET$SDI_S_PRC::
	BSBB	GET_DWB_ADR		; Get DWB address
	MOVL	DWB$L_PID(R6),R0	; Pass process PID
	BSBW	GET_JPI			; Get process name
	MOVZBL	PNAMES,R0		; Get string size
	BEQL	90$
	MOVC3	R0,PNAME,(R3)		; Copy process name into buffer
	MOVL	#1,R0			; Success
90$:	RSB

	.SBTTL	ARI PARAMETER ACTION ROUTINES
;+
; NET$ARI_V_REA -  Get adjacency "run" status
;
; NET$ARI_L_ADD -  Get partner node address
; NET$ARI_L_DCO -  Get cost to area
; NET$ARI_L_DHO -  Get hops to area
; NET$ARI_L_NND -  Get next node to area
;
; NET$ARI_S_COL -  Get collating value
; NET$ARI_S_CIR -  Get circuit name
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R9	FLD i.d. of field being read
;		R3	Address of result buffer
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;-

NET$ARI_V_LCK::				; "CNF locked" flag
	MOVL	#1,R0			; Mark all "cond write" fields as
	RSB				; cannot be written.

NET$ARI_V_REA::				; Area reachability
	MOVZWL	CNF$W_ID(R10),R2	; Get area number
	BSBW	NET$AREA_REACH		; Determine if area reachable
	MOVZBL	R0,R1			; Return boolean true/false
	MOVL	S^#SS$_NORMAL,R0	; Return successful
	RSB

NET$ARI_L_ADD::				; Area address
	MOVZWL	CNF$W_ID(R10),R1	; Return area number
	MOVL	S^#SS$_NORMAL,R0	; Return successful
	RSB

NET$ARI_L_DCO::				; Cost to area
	BSBB	AREA_COST_HOPS		; Get cost/hops value
	BLBC	R0,90$			; Exit if don't know
	EXTZV	#0,#10,R1,R1		; Get cost
	MOVL	S^#SS$_NORMAL,R0	; Successful
90$:	RSB

NET$ARI_L_DHO::				; Hops to area
	BSBB	AREA_COST_HOPS		; Get cost/hops value
	BLBC	R0,90$			; Exit if don't know
	EXTZV	#10,#5,R1,R1		; Get hops
	MOVL	S^#SS$_NORMAL,R0	; Successful
90$:	RSB

AREA_COST_HOPS:
	MOVZBL	S^#SS$_NORMAL,R0	; Assume success
	MOVZWL	CNF$W_ID(R10),R1	; Get area number
	MOVL	NET$GL_PTR_VCB,R7	; Get RCB address
	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_AREA ; Are we an area router?
	BNEQ	10$			; Branch if not
	BBC	#RCB$V_LVL2,-		; If we are not enabled for Level 2
		RCB$B_STATUS(R7),10$	; routing, then act like a Level 1 router
	MOVZWL	G^NET$AW_AREA_C_H[R1],R1 ; Get cost/hops for area
	RSB
10$:	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_PH4N ; Are we an endnode?
	BEQL	20$			; Branch if so
	MOVZWL	G^NET$AW_MIN_C_H,R1	; Get cost/hops to "nearest level 2 router"
	RSB
20$:	CLRL	R0			; Don't know cost/hops
	RSB

NET$ARI_L_NND::				; Next node on way to area
	MOVZWL	CNF$W_ID(R10),R2	; Get area number
	BSBW	NET$AREA_REACH		; Determine output ADJ to area
	BLBC	R0,90$			; If not reachable, then failure
	MOVZWL	R1,R8			; Set ADJ index
	BSBW	NET$FIND_ADJ		; Get next hops ADJ address
	BLBC	R0,90$			; If not found, then failure
	MOVZWL	ADJ$W_PNA(R7),R1	; Return partner's node address
	BSBW	SUPPRESS_AREA		; Suppress area if necessary
90$:	RSB

NET$ARI_S_COL::				; Get collating value
	MOVW	CNF$W_ID(R10),-(SP)	; Push area number
	MOVB	(SP)+,(R3)+		; Invert bytes, move to buffer
	MOVB	(SP)+,(R3)+
	MOVL	S^#SS$_NORMAL,R0	; Successful
	RSB

NET$ARI_S_DLI::				; Circuit used to get to area
	MOVZWL	CNF$W_ID(R10),R2	; Get area number
	BSBW	NET$AREA_REACH		; Determine output ADJ to area
	MOVZWL	R1,R8			; Set ADJ index to area
	BSBW	NET$ADJ_LPD_CRI		; Get CRI CNF, LPD & ADJ pointers
	BLBC	R0,90$			; Branch if error detected
	$CNFFLD	cri,s,nam,R9		; Set circuit name field ID
	BSBW	MOVSTR			; Copy it to output buffer
90$:	RSB

	.SBTTL	NET$AREA_REACH - Test area reachability
;+
; NET$AREA_REACH - Test area reachability
;
;  This routine tests the reachability of an area, and returns:
;
;	1) whether it is reachable or not
;	2) the ADJ to get to the area
;
;  Inputs:  R2  Area address
;	    R1	Scratch
;	    R0	Scratch
;
;  Outputs: R2	Area address
;	    R1	Adjacency index of path used to reach the area
;	    R0  Status
;-

NET$AREA_REACH::			; Test for area reachability
	PUSHL	#0			; Init storage on stack
	MOVZWL	#SS$_NOSUCHNODE,R0	; Assume area out of range
	MOVL	NET$GL_PTR_VCB,R1	; Get the RCB
	CMPB	R2,RCB$B_MAX_AREA(R1)	; Within range?
	BGTRU	100$			; If GTRU then out of range
	CMPB	RCB$B_ETY(R1),#ADJ$C_PTY_AREA ; Are we a level 2 router?
	BNEQ	50$			; If not, use nearest level 2 router
	MOVZWL	@RCB$L_PTR_AOA(R1)[R2],(SP)  ; Get ADJ index to the area
	BEQL	80$			; If 0, then unreachable
40$:	MOVL	S^#SS$_NORMAL,R0	; Indicate reachable
	BRB	100$			; And exit with success
50$:	CMPB	RCB$B_ETY(R1),#ADJ$C_PTY_PH4N ; Are we an endnode?
	BEQL	60$			; Branch if so
	MOVZWL	RCB$W_LVL2(R1),(SP)	; Get ADJ index to nearest level2 router
	BRB	40$			; and always exit with success
60$:	MOVZWL	RCB$W_DRT(R1),(SP)	; Get ADJ index to designated router
	BNEQ	40$			; and exit with success if we have one
80$:	MOVZWL	#SS$_UNREACHABLE,R0	; Node is known, but unreachable
100$:	POPL	R1			; Return path in R1
	RSB

	.SBTTL	NET$GET_LOC_STA - GET EXECUTOR STATE
;++
; NET$GET_LOC_STA - Get the state of the local node
;
; INPUTS:	None
;
; OUTPUTS:	R0	State value
;
;		All other registers are preserved
;
;--
NET$GET_LOC_STA::			; Return local state in R0
	PUSHR	#^M<R7,R8,R9,R10,R11>	; Save regs
	MOVL	NET$GL_CNR_LNI,R11	; Setup the Root block ptr
	MOVL	CNR$L_FLINK(R11),R10	; Get the first CNF block
	BBS	#CNF$V_FLG_CNR,-	; If its the root then the CNF list
		    CNF$B_FLG(R10),10$	; is empty
	$GETFLD	lni,l,sta		; Get the local state
	BLBS	R0,20$			; Br if valid
10$:	MOVW	#LNI$C_STA_OFF,R8	; Assume the "off" state
20$:	MOVL	R8,R0			; Get the state value
	POPR	#^M<R7,R8,R9,R10,R11>	; Restore regs
	RSB

	.SBTTL	NET$NDI_BY_ADD  - Find NDI CNF by node address
;+
; NET$NDI_BY_ADD	- Find NDI CNF by node address
;
; FUNCTIONAL DESCRIPTION:
;
; The node address is used as an index into the NDI vector in order to locate
; corresponding CNF block.  Only "real" NDI CNF blocks are considered valid,
; the so called "phantom" and "loop" node CNFs are not returned.
;
; This routine is merely an optimization.  It could be replaced with a call
; to  $SEARCH  eql,ndi,l,add.   The optimization is desireable since this
; is done so often.
;
; INPUTS:	R10	Scratch
;		R8	Node address
;		R0	Scratch
;
; OUTPUTS:	R10	NDI address if found, else 0
;		R0	LBS if found
;			LBC otherwise
;
;		All other registers are unchanged
;-
NET$NDI_BY_ADD::			; Get NDI by node address
	PUSHR	#^M<R8,R11>		; Save registers
	MOVL	NET$GL_PTR_VCB,R0	; Get the RCB pointer
	CMPZV	#TR4$V_ADDR_AREA,-	; Is this for area zero?
		#TR4$S_ADDR_AREA,R8,#0
	BNEQ	10$			; Br if not, okay as it is
	INSV	RCB$B_HOMEAREA(R0),-	; Else, stuff our area into node address
		#TR4$V_ADDR_AREA,-
		#TR4$S_ADDR_AREA,R8
10$:	MOVL	NET$GL_CNR_NDI,R11	; Point at root of NDI database
	CLRL	R10			; Start at beginning of list
	$SEARCH	eql,ndi,l,add		; Search for the right NDI
	POPR	#^M<R8,R11>		; Restore registers
	BLBS	R0,15$			; Br if success
	MOVL	NET$GL_LOCAL_NDI,R10	; Get the local NDI CNF
	MOVL	NET$GL_PTR_VCB,R0	; Get the RCB pointer
	CMPW	R8,RCB$W_ADDR(R0)	; Is this the local node?
	BEQL	15$			; If EQL then yes
	CLRL	R0			; Indicate failure
	CLRL	R10			; Invalidate the NDI pointer
	BRB	20$			; Take common exit
15$:	MOVL	#1,R0			; Assume success
20$:	RSB

	.SBTTL	NET$LOCATE_NDI - Find phantom or real NDI CNF
;+
; NET$LOCATE_NDI	- Find NDI CNF (phantom or real) by node address
;
; FUNCTIONAL DESCRIPTION:
;
; If an NDI entry exists for the specified node, it is returned.  Otherwise,
; the address of a dummy NDI is returned as a "phantom" NDI, so that the NDI
; block can be used on operations (such as event logging) for nodes that are
; reachable without being defined.
;
; INPUTS:	R10	Scratch
;		R8	Node address
;		R0	Scratch
;
; OUTPUTS:	R10	NDI address if found, else 0
;		R0	LBS if found
;			LBC otherwise
;
;		All other registers are unchanged
;-
NET$LOCATE_NDI::			; Get NDI by node address
	PUSHR	#^M<R8,R11>		; Save registers
	MOVL	NET$GL_PTR_VCB,R0	; Get the RCB pointer
	CMPZV	#TR4$V_ADDR_AREA,-	; Is this for area zero?
		#TR4$S_ADDR_AREA,R8,#0
	BNEQ	10$			; Br if not, okay as it is
	INSV	RCB$B_HOMEAREA(R0),-	; Else, stuff our area into node address
		#TR4$V_ADDR_AREA,-
		#TR4$S_ADDR_AREA,R8
10$:	MOVL	NET$GL_CNR_NDI,R11	; Point at root of NDI database
	CLRL	R10			; Start at beginning of list
	$SEARCH	eql,ndi,l,add		; Search for the right NDI
	POPR	#^M<R8,R11>		; Restore registers
	BLBS	R0,15$			; Br if success
	MOVL	NET$GL_DUM_NDI,R10	; Return address of dummy NDI
	MOVW	R8,NDI_ADD(R10)		; Stuff the address
	MOVW	R8,CNF$W_ID(R10)	; Here too
15$:	MOVL	#1,R0			; Assume success
	RSB

	.SBTTL	MOVE PARAMETER SUBROUTINES
;
; Subroutine to move CNF string field
;
MOVCSTR:
	BSBW	CNF$GET_FIELD		; Set field descriptor
	PUSHL	R0			; Save status
	MOVB	R7,(R3)+		; Enter count (could be zero)
	BRB	MOVIT			; Move the string
MOVSTR:
	BSBW	CNF$GET_FIELD		; Set field descriptor
	PUSHL	R0			; Save status
MOVIT:	MOVC3	R7,(R8),(R3)		; Move the string
	POPL	R0			; Restore status
	RSB

	.SBTTL	FMT_CNT - FORMAT COUNTERS
;+
; FMT_CNT	- Format counters
;
; INPUTS:	R6	Address of source counter block (FMT_CNT only)
;		R5	Address of table to drive counter formatting
;		R3	Address of next byte in output buffer
;		R2	Number of bytes in source counter block
;		R1	Pointer to source counter block (MOVE_FMT_CNT only)
;		R0	Scratch
;
; OUTPUTS:	R3	Updated to next free byte in output buffer
;		R2,R1	Garbage
;		R0	SS$_NORMAL
;
;		All other registers are preserved
;-
	.SAVE_PSECT
	.PSECT	NET_LOCK_CODE,NOWRT,GBL

MOVE_FMT_CNT::				; Move and format counters
	PUSHL	R6			; Save R6
	SUBL	#CNT_FMT_BUFSIZ,SP	; Create work area on stack
	MOVL	SP,R6			; Point to it with R6
	;
	;   Lock out NETDRIVER and take a snapshot of the counters.  While
	;   NETDRIVER is locked out, clear the counters if its called for.
	;
	DSBINT	#NET$C_IPL		; Lock out Netdriver
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save regs
	MOVC3	R2,(R1),(R6)		; Move counters
	MOVQ	(SP),R1			; Get R1,R2 (counter descriptor)
	BBC	#NET$V_CLRCNT,-		; If BC, don't clear the counters
		    NET$GL_FLAGS,20$	;
	MOVL	G^EXE$GL_ABSTIM,(R1)+	; Reset Abs-time since last zeroed
	SUBL	#4,R2			; Adjust bytes left in counter block
	MOVC5	#0,(SP),#0,R2,(R1)	; Zero remaining counters
20$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore regs
	ENBINT				; Restore IPL
	BSBB	FMT_CNT			; Format the counters
	;   Done, restore the stack and return
	;
	ADDL	#CNT_FMT_BUFSIZ,SP	; Create work area on stack
	POPL	R6			; Restore R6
	RSB				; Return to caller

FMT_CNT::				; Format counters
	;
	;   Move 'seconds since last zeroed' in NICE format to output buffer
	;
	SUBL3	(R6),G^EXE$GL_ABSTIM,(R6) ; Get seconds since last zeroed
	CMPL	(R6),#^X<FFFF>		; Has counter overflowed?
	BLEQU	30$			; If LEQU no
	MNEGW	#1,(R6)			; Latch counter at max value
30$:	MOVW	#NET$C_NMACNT_SLZ,(R3)+	; Enter i.d. of counter
	CVTLW	(R6),(R3)+		; Enter 'seconds since last zeroed'
	;
	;   Move each counter one at a time in NICE format to the output buffer
	;
40$:	MOVW	(R5)+,R2		; Get the next NICE counter i.d.
	BEQL	100$			; If EQL then done
	MOVZWL	(R5)+,R1		; Get offset to counter value
	ADDL	R6,R1			; Get pointer to counter value
	MOVW	R2,(R3)+		; Enter NICE counter i.d.
	EXTZV	#13,#2,R2,R2		; Get width of counter
	$DISPATCH  R2,-			; Dispatch on width
	<-				;
		<1, 70$>,-		; Byte
		<2, 60$>,-		; Word
		<3, 50$>,-		; Longword
	>				;
	BUG_CHECK	NETNOSTATE,FATAL

50$:	MOVW	(R1)+,(R3)+		; Counter is a longword
60$:	MOVB	(R1)+,(R3)+		; Counter is a word
70$:	MOVB	(R1)+,(R3)+		; Counter is a byte
	BRB	40$			; Loop
100$:	;
	;  Done
	;
	MOVZWL	#SS$_NORMAL,R0		; Always successful
	RSB				; Return

	.RESTORE_PSECT

	.SBTTL	LOG_COUNTERS - LOG ZERO COUNTER EVENT
;+
; LOG_COUNTERS	-	Conditionally log zero counter event
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R5	Scratch
;		R3	Address of first byte past counter  block
;		R2	Address of counter block
;		R0	EVC database i.d.
;
; OUTPUT:	R5,R0	Garbage
;
;		All other registers are preserved.
;-
LOG_COUNTERS::				; Conditionally log zero counter event
	BBC	#NET$V_CLRCNT,-		; If BC then counters weren't zeroed
		NET$GL_FLAGS,20$	;
	MOVAB	NET$AB_EVT_WQE,R5	; Point to the common WQE
	MOVW	CNF$W_ID(R10),-		;
		WQE$W_REQIDT(R5)	; Setup the CNF i.d.
	MOVL	R2,WQE$L_EVL_PKT(R5)	; Setup pointer to counter block
	SUBB3	R2,R3,WQE$B_EVL_DT2(R5)	; Setup size of counter block
	MOVB	R0,WQE$B_EVL_DT1(R5)	; Setup database i.d.
	MOVW	#EVC$C_NSL_DBR,-	; Assume data base re-used event
		WQE$W_EVL_CODE(R5)	;
	BBS	#NET$V_LOGDBR,-		; If BS then data base re-used event
		NET$GL_FLAGS,10$	;
	MOVW	#EVC$C_NMA_ZER,-	; Else, assume zero counters event
		WQE$W_EVL_CODE(R5)	;
	BBC	#NET$V_TIMER,-		; If BC then zero counters event
		NET$GL_FLAGS,10$	;
	MOVW	#EVC$C_NMA_CTR,-	; Else counter timer event
		WQE$W_EVL_CODE(R5)	;
10$:	BSBW	NET$EVT_INTRAW		; Log it
20$:	RSB				; Done


.END
