	.TITLE	INITIAL - COMMAND INTERPRETER INITIALIZATION
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 29-MAR-77
;
; COMMAND LANGUAGE INTERPRETER INITIALIZATION
;
; MODIFICATIONS:
;
;	V03-022	HWS0091		Harold Schultz		22-Jul-1984
;		Initialize PRC_B_EXONLYL, PRC_V_SAVCMDV, and
;		PRC_V_SAVIMGV
;
;	V03-021	HWS0043		Harold Schultz		30-Mar-1984
;		Don't preset CTL$GT_CLINAME.
;
;	V03-020	HWS0033		Harold Schultz		15-Mar-1984
;		When spawning a sub-process, pass on to RMS the verify
;		image flag setting of the parent process.
;
;	V03-019	TMK0001		Todd M. Katz		07-Mar-1984
;		A hash code field, LNMX$W_HASH, has been added to every 
;		translation block of every logical name and logical name table.
;		This hash code field will be used in an optimization of logical
;		name table name processing. However, within the context of a
;		spawned process, during processing of the logical name table
;		records, the contents of the hash code field in every 
;		translation block should just be ignored.
;
;	V03-018	HWS0009		Harold Schultz	13-Feb-1984
;		Add PRC_V_CARRCNTL flag processing to indicate
;		presence or absence of carriage control in prompt
;		field instead of using contents of prompt field.
;
;	V03-017	HWS0001		Harold Schultz	03-Feb-1984
;		Don't set protection mask for private logical name
;		tables.
;
;	V03-016	PCG0018		Peter George	22-Sep-1983
;		Fill in IDF_L_FILENAME for initial stack frame.
;		Correctly turn off image verification in subprocesses.
;
;	V03-015	PCG0017		Peter George	12-Sep-1983
;		Expect unwanted logical names to have confine attribute.
;		Propagate CCL bits from PPD data structure.
;		Set CTL$GT_CLINAME.
;
;	V03-014	PCG0016		Peter George	16-Aug-1983
;		Correctly supply address of IOSB to IO$M_TT_PROCESS QIO.
;		Do not perfrom IO$M_TT_PROCESS QIO in nowait subprocesses.
;		Remove code that deassigns transmitted SYS$INPUT and SYS$OUTPUT.
;
;	V03-013	PCG0015		Peter George	29-Jun-1983
;		Use event flags more intelligently.
;		Do an IO$M_TT_PROCESS set mode QIO when creating an 
;		interactive process.
;
;	V03-012	PCG0014		Peter George	13-Jun-1983
;		Fix bug in initial command procedure parameter creation.
;		Call RMS rundown for loginout.
;		Reformat new system service calls.
;		Remove DCL_L_TAB_VEC.
;
;	V03-011	RAS0157		Ron Schaefer	27-May-1983
;		Add support for new logical names structures.
;
;	V03-010	PCG0013		Peter George	27-May-1983
;		Add support for output log flushing and image verification.
;
;	V03-009	PCG0012		Peter George	20-Apr-1983
;		Expect prompt and keypad state to be passed by spawn.
;		Do not treat %XFF from LOGINOUT as a null string.
;
;	V03-008	PCG0011		Peter George	29-Mar-1983
;		Sort out CTX_C_KEY* definitions.
;
;	V03-007	PCG0010		Peter George	15-Feb-1983
;		Convert to new structure level.
;		Init P1-P8 for login command procedures.
;		Create and define $RESTART and BATCH$RESTART.
;		Increase logical name buffers from 64 to LNM$C_NAMLENGTH.
;		Make P1-P8 global symbols in batch jobs.
;		Add support for keypad symbol definitions.
;		Speed up spawn symbol allocation.
;		Hook up terminal XAB.
;
;	V03-006	PCG0009		Peter George	28-Jan-1983
;		Change default PRC_W_ONLEVEL.
;		Override SYS$OUTPUT definition transmitted in a SPAWN.
;
;	V03-005	PCG0008		Peter George	10-Jan-1983
;		Define MAX_DEPTH symbolically.
;		Remove all references to ERRIFI and ERRRAB.
;		Init PRC_W_OUTISI, PRC_W_OUTIFI, PRC_L_OUTRABCTX, and
;		PRC_T_OUTDVI.  Create initial SYS$OUTPUT.
;		Set up exit handler once here, instead of on every
;		image activation.  Terminate process if captive account
;		and cannot open command procedure.
;
;	V03-004	PCG0007		Peter George	29-Dec-1982
;		Do not reset global symbols in succeeding
;		procedures in a batch job.
;
;	V03-003	PCG0006		Peter George	01-Dec-1982
;		Comment out references to the recall buffer.
;
;	V03-002	PCG0005		Peter George	19-Nov-1982
;		Make prompt string constants global.
;		Allow up to 16 stack levels.
;
;	V03-001	PCG0004		Peter George	20-Aug-1982
;		Initialize PRC_L_NXTCMDPTR.
;		Set initial prompt string.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				; CLI PROCESS WORK AREA
	PRDDEF				; CLI PROCESS RMS AREA
	WRKDEF				; COMMAND WORK AREA
	IDFDEF				; INDIRECT PROCEDURE FRAME
	SYMDEF				; SYMBOL TABLE DEFINITIONS
	CTXDEF				; SPAWN CONTEXT RECORD FORMATS
	ITRMDEF				; TERMINAL XAB ITEM LIST
	$FABDEF				; FILE ACCESS BLOCK
	$RABDEF				; RECORD ACCESS BLOCK
	$XABTRMDEF			; TERMINAL XAB
	$TRMDEF				; TERMINAL DRIVER ITEM LIST SYMBOLS
	$PPDDEF				; PROCESS PERMANENT DATA AREA
	$PSLDEF				; PROCESSOR STATUS FIELDS
	$DIBDEF				; GETDEV CHARACTERISTICS BLOCK
	$LOGDEF				; LOGICAL NAME TABLE CODES
	$DEVDEF				; DEVICE CHARACTERISTICS DEFINITIONS
	$LNMSTRDEF			; NEW LOGICAL NAME STRUCTURES
	$LNMDEF				; NEW LOGICAL NAME DEFINITIONS
	$CLIMSGDEF			; CLI MESSAGE CODES
	$IODEF				; DEFINE QIO CODES

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

DCL:
	.ASCIC	'DCL'
SYS$ERROR:
	.ASCIC	'SYS$ERROR'
TRUE:
	.ASCIC	'TRUE'
FALSE:
	.ASCIC	'FALSE'
BATCH$RESTART:
	.ASCIC	'BATCH$RESTART'
DEFAULT:
	.ASCIC	'DEFAULT'
FLUSH_RATE:				; ONE MINUTE IN DELTA TIME REPRESENTATION
	.LONG	^XDC3CBA00
	.LONG	^XFFFFFFFF
DCL$CRLF::
	.BYTE	^X0D
	.BYTE	^X0A
DCL$T_PROMPT::
	.ASCII	' $  '
DCL$C_PROMPTLEN == 5
MAX_DEPTH == 16

;
; TABLE OF RESERVED SYMBOLS
;
RESERVED:				;
	.BYTE	5			;MAXIMUM LENGTH OF RESTART VALUE
	.ASCIC	'$RESTART'		;RESTART VALUE SYMBOL
	.BYTE	PRC_L_RESTART		;OFFSET TO RESTART VALUE ADDRESS
	.BYTE	1			;MAXIMUM LENGTH OF SEVERITY LEVEL
	.ASCIC	'$SEVERITY'		;ERROR SEVERITY LEVEL SYMBOL
	.BYTE	PRC_L_SEVERITY		;OFFSET TO SEVERITY VALUE ADDRESS
	.BYTE	10			;MAXIMUM LENGTH OF STATUS VALUE
	.ASCIC	'$STATUS'		;STATUS VALUE SYMBOL
	.BYTE	PRC_L_STATUS		;OFFSET TO STATUS VALUE ADDRESS
	.BYTE	0			; --- END OF TABLE

	.SBTTL	COMMAND INTERPRETER START UP
;+
; DCL$STARTUP - COMMAND INTERPRETER START UP
;
; THIS ENTRY POINT IS JUMPED TO AT THE CONCLUSION OF LOGGING A USER ONTO
; THE SYSTEM. ALL INPUT AND OUTPUT FILES ARE OPEN AND THE COMMAND LANGUAGE
; INDEPENDENT DATA AREA HAS BEEN INITIALIZED.
;-
 
	.PSECT	DCL$$BASE,BYTE,RD,NOWRT

	MOVL	G^CTL$AL_STACK+8,SP	;RELOAD SUPERVISOR STACK POINTER
	CLRL	FP			;INDICATE NO PREVIOUS FRAME
	CALLG	(SP),W^DCL$STARTUP	;SETUP INITIAL CALL FRAME
	$EXIT_S

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
DCL$STARTUP::				;COMMAND INTERPRETER START UP
	.WORD	^M<>			;ENTRY MASK
	CLRL	-(SP)			;SETUP DUMMY PSL (@PRC_L_SAVAP=PRVPSL)
	CALLG	(SP),B^10$		;CREATE DUMMY FP AFTER DUMMY AP
	RET
10$:	.WORD	0
	MOVAB	W^DCL$CONDHAND,(FP)	;ESTABLISH CONDITION HANDLER
	MOVAB	L^DCL$UTLSERV+2,G^CTL$AL_CLICALBK ; SET CALL BACK VECTOR
	MOVAB	G^CTL$AG_CLIDATA,R10	;GET ADDRESS OF PPD

;
; INITIALIZE CLI PROCESS WORK AREA.  IF SECOND OR GREATER STEP OF A BATCH
; JOB, THEN DO NOT RESET PRC_Q_ALLOCREG, PRC_Q_GLOBAL, PRC_L_LSTSTATUS, 
; PRC_L_STATUS, OR PRC_L_SEVERITY.
;
	MOVL	PPD$Q_CLIREG+4(R10),R11		; GET ADDRESS OF CLI PRIVATE STORAGE
	BBC	#PPD$V_CONTINUE,-		; FIRST STEP IN BATCH JOB?
		PPD$W_FLAGS(R10),15$		; 
	MOVQ	PRC_Q_ALLOCREG(R11),-(SP)	; NO, SAVE PRC_Q_ALLOCREG 
	MOVQ	PRC_Q_GLOBAL(R11),-(SP)		;   AND PRC_Q_GLOBAL
	MOVL	PRC_L_LSTSTATUS(R11),-(SP)	;   AND PRC_L_LSTSTATUS
	ASSUME PRC_L_STATUS EQ PRC_L_SEVERITY+4	;   AND PRC_L_STATUS
	MOVQ	PRC_L_SEVERITY(R11),-(SP)	;   AND PRC_L_SEVERITY
	MOVC5	#0,(SP),#0,-			; ZERO ALL STORAGE
		PPD$Q_CLIREG(R10),(R11) 	; 
	MOVQ	(SP)+,PRC_L_SEVERITY(R11)	; RESTORE PRC FIELDS
	MOVL	(SP)+,PRC_L_LSTSTATUS(R11)	; 
	MOVQ	(SP)+,PRC_Q_GLOBAL(R11)		; 
	MOVQ	(SP)+,PRC_Q_ALLOCREG(R11)	; 
	BRB	16$				; 
15$:	MOVC5	#0,(SP),#0,-			; ZERO ALL STORAGE
		PPD$Q_CLIREG(R10),(R11) 	; 
16$:	MOVQ	AP,PRC_L_SAVAP(R11)		; SAVE INITIAL AP AND FP

;
; SET UP PRC BASED EXIT HANDLER BLOCK (REST OF BLOCK IS ZERO).
;
	MOVAB	W^DCL$EXITHAND,-		; SET ADDRESS OF EXIT HANDLER
		PRC_L_EXTHND(R11) 		;
	MOVAB	PRC_L_EXTCOD(R11),-		; SET ADDRESS OF REASON FOR EXIT
		PRC_L_EXTPRM(R11) 		;

;
; COPY AND ACT ON INFORMATION IN PPD
;
	MOVW	PPD$W_INPCHAN(R10),-		; COPY INPUT CHANNEL
		PRC_W_INPCHAN(R11)		; 
	BBC	#PPD$V_MODE,PPD$W_FLAGS(R10),20$; COPY JOB MODE
	BISW	#PRC_M_MODE!PRC_M_VERIFY,-	; AND TURN VERIFY ON IF BATCH
		PRC_W_FLAGS(R11) 		; 
	BISB	#PRC_M_VERIMAGE,PRC_B_FLAGS2(R11);
20$:	BISL	#PRC_M_CTRLY,-			; ENABLE CTRL/Y 
		PRC_L_OUTOFBAND(R11) 		; 
	BBC	#PPD$V_NOCTLY,-			; COPY NOCONTROLY MODE
		PPD$W_FLAGS(R10),25$		; 
	CLRBIT	PRC_V_CTRLY,PRC_L_OUTOFBAND(R11); 
25$:	MOVW	#4,PRC_B_EXMDEPWID(R11)		; SET EXAMINE MODE TO HEX,WIDTH TO 4
	MOVAB	PRC_G_COMMANDS(R11),-		; ADDRESS OF RECALL BUFFER
		PRC_L_RECALLPTR(R11)		; 

;
; SET UP INITIAL PROMPT.
;
	MOVW	DCL$CRLF,PRC_W_PMPTCTRL(R11)	; SET CARRIAGE CONTROL
	SETBIT	PRC_V_CARRCNTL,PRC_W_FLAGS(R11)	; INDICATE CR LF IN PROMPT
	MOVL	DCL$T_PROMPT,PRC_B_CONTINUE(R11); SET DEFAULT PROMPT
	MOVB	#DCL$C_PROMPTLEN,-		; SET PROMPT LENGTH
		PRC_B_PROMPTLEN(R11)		; 

;
; FOR BATCH JOBS, SETUP TO EXIT ON ERRORS.  FOR INTERACTIVE JOBS,
; DO AN IMPLIED "SET NOON".
;
	MOVW	#2@8!2,PRC_W_ONLEVEL(R11)	; ASSUME "ON ERROR THEN EXIT"
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),30$; IF BATCH JOB, THIS IS OK
	MOVW	#8@8!8,PRC_W_ONLEVEL(R11) 	; IF INTERACTIVE, "SET NOON"

;
; INITIALIZE CLI SYMBOL TABLE AND GLOBAL, LOCAL, LABEL, AND KEYPAD 
; TABLE HEADERS.
;
30$:	BBS	#PPD$V_CONTINUE,-		; IF FIRST STEP IN BATCH JOB
		PPD$W_FLAGS(R10),35$		; THEN INIT HEADER AND GLOBAL TABLE
	MOVQ	PPD$Q_CLISYMTBL(R10),R0		; GET LENGTH/ADDRESS OF REGION
	MOVL	R1,PRC_Q_ALLOCREG(R11)		; INIT LISTHEAD OF ALLOCATION REGION
	CLRL	(R1)+				; CLEAR LINK TO NEXT FREE BLOCK
	MOVL	R0,(R1)				; SET LENGTH OF THIS FREE BLOCK
	MOVAB	PRC_Q_GLOBAL(R11),R0		; GET ADDRESS OF GLOBAL TABLE LISTHEAD
	MOVL	R0,(R0)				; INIT GLOBAL SYMBOL TABLE EMPTY
	MOVL	(R0)+,(R0)+			; 
35$:	MOVAB	PRC_Q_LABEL(R11),R0		; GET ADDRESS OF LABEL TABLE LISTHEAD
	MOVL	R0,(R0)				; INIT LABEL TABLE EMPTY
	MOVL	(R0)+,(R0)+			; 
	MOVAB	PRC_Q_LOCAL(R11),R0		; GET ADDRESS OF LOCAL TABLE LISTHEAD
	MOVL	R0,(R0)				; INIT CURRENT LOCAL SYMBOL TABLE EMPTY
	MOVL	(R0)+,(R0)+			; 
	MOVAB	PRC_Q_KEYPAD(R11),R0		; GET ADDRESS OF KEYPAD TABLE LISTHEAD
	MOVL	R0,(R0)				; INIT KEYPAD TABLE EMPTY
	MOVL	(R0)+,(R0)+			; 

;
; INITIALIZE PRC_B_EXONLYL, PRC_V_SAVCMDV, AND PRC_V_SAVIMGV
;
	CLRB	PRC_B_EXONLYL(R11)		; CLEAR EXE-ONLY PROCEDURE FLAG
	BICB	#PRC_M_SAVCMDV!PRC_M_SAVIMGV,-	; INIT. SAVED COMM. AND IMG.
		PRC_B_OUTFLAGS(R11)		;    VERIFICATION FLAGS.
;
; INITIALIZE PRC_L_CURRKEY AND PRC_L_LASTKEY.
;
	MOVAB	DEFAULT,R2			; GET NORMAL STATE DESCRIPTOR
	MOVZBL	(R2)+,R1			;
	BSBW	DCL$ALLOC_STATE			; ALLOCATE NORMAL STATE SYMBOL
	MOVL	PRC_L_CURRKEY(R11),-		; LOCK THAT STATE
		PRC_L_LASTKEY(R11)		;

;
; CREATE RESERVED SYMBOLS $STATUS, $SEVERITY, AND $RESTART.
;
	BBSS	#PPD$V_CONTINUE,-		; IF FIRST STEP IN JOB
		PPD$W_FLAGS(R10),48$		; THEN INIT GLOBAL SYMBOLS
	MOVAB	RESERVED,R6			; GET ADDRESS OF RESERVED SYMBOLS
	MOVAB	PRC_Q_GLOBAL(R11),R5		; GET ADDRESS OF SYMBOL TABLE LISTHEAD
40$:	MOVZBL	(R6)+,R1			; GET MAXIMUM LENGTH OF VALUE STRING
	BEQL	50$				; IF EQL END OF TABLE
	MOVL	R6,R2				; SET ANY ADDRESS FOR SYMBOL VALUE
	MOVZBL	(R6)+,R3			; CONSTRUCT DESCRIPTOR OF SYMBOL NAME
	MOVL	R6,R4				;
	ADDL	R3,R6				; ADJUST TO ADDRESS OFFSET
	MOVZBL	#SYM_K_PERM,R0			; DEFINE SYMBOL AS PERMANENT
	BSBW	DCL$ALLOCSYM			; ALLOCATE AND INSERT PERMENENT SYMBOL
	MOVZBL	SYM_T_SYMBOL(R1),R0		; GET LENGTH OF SYMBOL NAME
	MOVAB	SYM_T_SYMBOL+1(R1)[R0],R0	; GET ADDRESS OF SYMBOL VALUE
	CLRW	(R0)+				; CLEAR LENGTH OF SYMBOL VALUE
	MOVZBL	(R6)+,R1			; GET OFFSET TO ADDRESS OF SYMBOL VALUE
	ADDL	R11,R1				; CALCULATE ADDRESS TO STORE VALUE ADDRESS
	MOVL	R0,(R1)				; SET ADDRESS OF SYMBOL VALUE
	BRB	40$				;
48$:	BRW	58$				; SKIP TO PARAMETER PROCESSING
49$:	BRW	70$				; SKIP TO END OF BATCH PROCESSING

;
; INITIALIZE $RESTART AND BATCH$RESTART SYMBOLS.
;
50$:	MOVL	PRC_L_RESTART(R11),R6		; GET ADDRESS OF RESTART VALUE
	MOVAB	FALSE,R1			; GET ADDRESS OF ASCIC FALSE
	BBC	#PPD$V_RESTART,-		; BRANCH IF SHOULD BE FALSE
		PPD$W_FLAGS(R10),55$		;
	MOVAB	TRUE,R1				; GET ADDRESS OF ASCIC TRUE
55$:	MOVZBL	(R1)+,R0			; GET LENGTH OF VALUE STRING
	MOVW	R0,-2(R6)			; STORE THE LENGTH
	MOVC3	R0,(R1),(R6)			; SET VALUE

	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),49$; BRANCH IF NOT BATCH JOB
	BBC	#PPD$V_RESTART,-		; BRANCH IF NOT RESTARTED
		PPD$W_FLAGS(R10),58$		;
	MOVAB	PRC_Q_GLOBAL(R11),R5		; SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVAB	-LNM$C_NAMLENGTH(SP),SP		; ALLOCATE BUFFER ON STACK
	PUSHL	SP				; CONSTRUCT DESCRIPTOR OF BUFFER
	PUSHL	#LNM$C_NAMLENGTH		;
	MOVAB	BATCH$RESTART,R0		; GET ADDRESS OF LOGICAL NAME
	PUSHAB	1(R0)				; CONSTRUCT DESCRIPTOR OF LOGICAL NAME
	MOVZBL	(R0),-(SP)			; 
	MOVL	SP,R6				; GET ADDRESS OF DESCRIPTOR
	$TRNLOG_S LOGNAM=(R6),-			; TRANSLATE LOGICAL NAME
		RSLBUF=8(R6),-			; INTO BUFFER ON STACK
		RSLLEN=8(R6),-			;
		DSBMSK=#3			; DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPL	R0,#SS$_NORMAL			; SUCCESS?
	BNEQ	57$				; IF NOT, CLEAN UP
	MOVQ	8(R6),R1			; GET DESCRIPTOR OF SYMBOL VALUE
	MOVQ	(R6),R3				; GET DESCRIPTOR OF SYMBOL NAME
	MOVZBL	#SYM_K_STRING,R0		; DEFINE SYMBOL AS A STRING
	BSBW	DCL$ALLOCSYM			; DEFINE SYMBOL IN SYMBOL TABLE
57$:	MOVAB	8+8+LNM$C_NAMLENGTH(SP),SP	; DEALLOCATE SCRATCH STORAGE

;
; CREATE LOCAL SYMBOLS P1 THRU P8 AS THE JOB PARAMETERS
;
58$:	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),70$; BRANCH IF NOT BATCH JOB
	MOVAB	PRC_Q_LOCAL(R11),R5		;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVAB	-LNM$C_NAMLENGTH(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP				;CONSTRUCT DESCRIPTOR OF BUFFER
	PUSHL	#LNM$C_NAMLENGTH		;
	PUSHL	#^A'P0'				;PUSH PROTOTYPE LOGICAL/SYMBOL NAME
	PUSHL	SP				;AND CONSTRUCT DESCRIPTOR OF IT
	PUSHL	#2				;
	MOVL	SP,R6				;GET ADDRESS OF DESCRIPTOR
	MOVL	#8,R7				;LOOP 8 TIMES
60$:	MOVL	#LNM$C_NAMLENGTH,12(R6)		;RESET LENGTH OF BUFFER
	INCB	9(R6)				;INCREMENT SYMBOL NAME
	$TRNLOG_S LOGNAM=(R6),-			;TRANSLATE LOGICAL NAME P#
		RSLBUF=12(R6),-			;INTO BUFFER ON STACK
		RSLLEN=12(R6),-			;
		DSBMSK=#3			;DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPL	R0,#SS$_NORMAL			;SUCCESS?
	BEQL	65$				;IF NOT,
	CLRL	12(R6)				;SET THE SYMBOL TO NULL STRING
65$:	MOVQ	12(R6),R1			;GET DESCRIPTOR OF SYMBOL VALUE
	MOVQ	(R6),R3				;GET DESCRIPTOR OF SYMBOL NAME
	MOVZBL	#SYM_K_STRING,R0		;DEFINE SYMBOL AS A STRING
	BSBW	DCL$ALLOCSYM			;DEFINE SYMBOL IN SYMBOL TABLE
	SOBGTR	R7,60$				;LOOP UNTIL ALL SYMBOLS DONE
	MOVAB	8+4+8+LNM$C_NAMLENGTH(SP),SP	;DEALLOCATE SCRATCH STORAGE

;
; INITIALIZE PROCESS RMS DATA AREA
;
; INIT AND CONNECT FAB, NAM, INPRAB, OUTRAB.
;
70$:	MOVAB	PRC_C_LENGTH(R11),R8			;SET ADDRESS OF RMS STRUCTURES (PRD)
	MOVAB	PRD_G_FAB(R8),PRC_L_INDFAB(R11)		;ADDRESS OF GENERAL PURPOSE FAB
	ASSUME	PRD_G_FAB EQ 0
	ASSUME	FAB$B_BID EQ 0
	ASSUME	FAB$B_BLN EQ 1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,PRD_G_FAB(R8)	;SET FAB ID/LENGTH
	MOVAB	PRD_G_NAM(R8),FAB$L_NAM(R8) 		;SET ADDRESS OF NAM BLOCK
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,PRD_G_NAM(R8)	;SET NAM ID/LENGTH
	MOVAB	PRD_G_INPRAB(R8),R9			;SET ADDRESS OF INPUT RAB
	MOVAB	PRD_G_OUTRAB(R8),R7			;SET ADDRESS OF OUTPUT RAB
	MOVW	#RAB$C_BID+<RAB$C_BLN@8>,RAB$B_BID(R9)	;SET RAB ID/LENGTH
	MOVW	RAB$B_BID(R9),RAB$B_BID(R7)		;
	MOVL	R8,RAB$L_FAB(R9)			;SET ADDRESS OF FAB
	MOVL	R8,RAB$L_FAB(R7)			;

;
; SET ISI'S OF INITIAL INPUT/OUTPUT FILES.
;
	MOVW	PPD$W_INPISI(R10),RAB$W_ISI(R9)		;SET INPUT ISI
	MOVW	PPD$W_OUTISI(R10),RAB$W_ISI(R7)		;SET OUTPUT ISI

;
; SET PPF DIRECT ACCESS, SO THAT RMS USER-MODE EOF CHECKING IS NOT DONE
;
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R9)		;ENABLE DIRECT ACCESS
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R7)		;TO INPUT STREAMS

;
; STORE DEVICE CHARACTERISTICS IN THE RAB$L_CTX FIELD SO THAT RAB IS ENOUGH
;
	MOVL	PPD$L_INPDEV(R10),RAB$L_CTX(R9)		;INPUT DEVICE CHARACTERISTICS
	MOVL	PPD$L_OUTDEV(R10),RAB$L_CTX(R7)		;OUTPUT DEVICE CHARACTERISTICS

;
; INIT ALTINPRAB, ALTOUTRAB.
;
	ASSUME	RAB$W_ISI EQ RAB$B_BLN+1
	MOVL	RAB$B_BID(R9),PRD_G_ALTINPRAB(R8)	;SET RAB ID/LENGTH/ISI
	MOVL	RAB$B_BID(R7),PRD_G_ALTOUTRAB(R8)	;SET RAB ID/LENGTH/ISI

;
; LIMIT ALLOCATION OF BLOCKS/BUFFERS ON PPF STREAM (PIOSEG SPACE IS LIMITED)
; IN ALL RABS.
;
	MOVB	#1,RAB$B_MBC(R9)			;ONLY ALLOCATE 1 BLOCK/BUFFER
	MOVB	#-1,RAB$B_MBF(R9)			;ONLY ALLOCATE 1 BUFFER/STREAM
	ASSUME	RAB$B_MBC EQ RAB$B_MBF+1
	MOVW	RAB$B_MBF(R9),RAB$B_MBF(R7)		; SET MBC/MBF FOR ALL RABS
	MOVW	RAB$B_MBF(R9),-				;
		PRD_G_ALTINPRAB+RAB$B_MBF(R8)		;
	MOVW	RAB$B_MBF(R9),-				;
		PRD_G_ALTOUTRAB+RAB$B_MBF(R8)		;

;
; INIT XABTRM.  
;
	MOVW	#XAB$C_TRM+<XAB$C_TRMLEN@8>,-		;SET XABTRM ID/LENGTH
		PRD_G_XABTRM(R8)			;
	MOVAB	PRD_G_XABTRM(R8),R0			;GET ADDRESS OF XABTRM BLOCK
	MOVAB	PRD_G_TRMLIST(R8),XAB$L_ITMLST(R0)	;SET ADDRESS OF ITEM LIST
	MOVW	#ITRM_K_MINLEN,XAB$W_ITMLST_LEN(R0)	;SET MIN SIZE OF ITEM LIST

;
; CONNECT XABTRM TO THE INPUT RABS.
;
	MOVL	R0,PRD_G_INPRAB+RAB$L_XAB(R8) 		;SET ADDRESS OF XABTRM BLOCK
	MOVL	R0,PRD_G_ALTINPRAB+RAB$L_XAB(R8) 	;
	SETBIT	RAB$V_ETO,PRD_G_ALTINPRAB+RAB$L_ROP(R8) ;SET READ WITH XABTRM
	SETBIT	RAB$V_ETO,PRD_G_INPRAB+RAB$L_ROP(R8)    ;

;
; INIT XABTRM ITEM LIST.
;
	MOVAB	PRD_G_TRMLIST(R8),R0			;GET ADDRESS OF ITEM LIST
	MOVL	R0,PRC_L_TRMLIST(R11)			;SAVE ADDRESS IN PRC
	CLRW	ITRM_W_MODLEN(R0)			;SET READ MODIFIERS
	MOVW	#TRM$_MODIFIERS,ITRM_W_MODCODE(R0)	;
	MOVL	#TRM$M_TM_ESCAPE!TRM$M_TM_NORECALL,-	;
		ITRM_L_MODIFIERS(R0)			;
	MOVW	#TRM$_PROMPT,ITRM_W_PMPTCODE(R0)	;SET READ WITH PROMPT
	MOVW	#TRM$_INISTRNG,ITRM_W_INICODE(R0)	;SET USE INITIAL STRING
	MOVW	#TRM$_INIOFFSET,ITRM_W_OFFCODE(R0)	;SET USE INITIAL STRING OFFSET

;
; USE SAME RAB FOR BOTH INPUT AND OUTPUT IF THEY BOTH POINT TO THE SAME STREAM
; (THIS IS FOR CODE SEGMENTS WHICH DECIDE IF THEY ARE THE SAME BY COMPARING
; THE INPUT AND OUTPUT RAB ADDRESSES RATHER THAN THEIR ISI'S)
;
	CMPW	RAB$W_ISI(R7),RAB$W_ISI(R9) 		;ARE INPUT AND OUTPUT THE SAME?
	BNEQ	75$					;BRANCH IF NOT
	MOVL	R9,R7					;USE INPUT RAB FOR OUTPUT

;
; STORE FAB/RAB ADDRESSES IN PRC AREA FOR EASY ACCESS
;
75$:	MOVL	R7,PRC_L_OUTRAB(R11)			;SET ADDRESS OF OUTPUT RAB
	MOVL	R9,PRC_L_INPRAB(R11)			;SET ADDRESS OF INPUT RAB
	MOVL	R7,PRC_L_INDOUTRAB(R11)			;SET ADDRESS OF INDIRECT OUTPUT RAB
	MOVL	R9,PRC_L_INDINPRAB(R11)			;SET ADDRESS OF INDIRECT INPUT RAB

;
; IF IN BATCH JOB, SET THE DEFAULT FLUSH RATE.
;
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),76$	;BRANCH IF NOT BATCH JOB
	MOVQ	FLUSH_RATE,PRC_Q_FLUSHTIME(R11)		;SET DEFAULT FLUSH RATE
	BSBW	DCL$SET_TIMER				;SET FLUSH TIMER

;
; INITIALIZE INDIRECT FRAME STACK & LEVEL 0 FRAME.  IF WE HAVE ENOUGH SPACE,
; ALLOCATE ROOM FOR EXACTLY 16 FRAMES.  IF NOT, GET AS MANY FRAMES AS POSSIBLE.
;
76$:	MOVAB	PRC_C_LENGTH+PRD_C_XLENGTH(R11),- 	;SET LIMIT OF INDIRECT FRAMES
		PRC_L_STACKLM(R11)			;TO WHAT IS AVAILABLE
	ADDL3	PPD$Q_CLIREG(R10),-			;GET END+1 OF REGION
		PPD$Q_CLIREG+4(R10),R0 
;*****
;***** DO NOT USE LAST PAGE - TO CATCH BUG IN DCL WHICH REFERENCES OFF
;***** THE END OF THE INDIRECT STACK BEYOND OUR STORAGE AREA.
;*****
	MOVAB	-512(R0),R0
	MOVAB	-IDF_K_LENGTH(R0),R9			;ADDRESS OF LEVEL 0 FRAME
	MOVAB	-MAX_DEPTH*IDF_K_LENGTH(R9),R0		;COMPUTE BASE OF STACK W/16 FRAMES
	CMPL	R0,PRC_L_STACKLM(R11)			;ROOM FOR EXACTLY 16 FRAMES?
	BLEQU	77$					;IF NOT, USE WHATEVER ROOM WE HAVE
	MOVL	R0,PRC_L_STACKLM(R11)			;ELSE, LIMIT TO EXACTLY 16 FRAMES
77$:	MOVL	R9,PRC_L_STACKPT(R11)			;SET INDIRECT FRAME STACK POINTER
	MOVL	R9,PRC_L_IDFLNK(R11)			;SET LINK POINTER
	MOVC5	#0,(SP),#0,#IDF_C_LENGTH,(R9)		;ZERO LEVEL 0 FRAME
							;(IDF_L_LNK=0 TO TERMINATE LIST)
							;(IDF_L_SEARCHCTX=0 TO INITIALIZE LIST)
	MOVAB	PPD$T_FILENAME(R10),IDF_L_FILENAME(R9)	;GET ADDRESS OF INPUT FILE NAME
	MOVW	PPD$W_OUTIFI(R10),IDF_W_OUTIFI(R9) 	;SAVE OUTPUT IFI
	MOVW	PPD$W_OUTIFI(R10),PRC_W_OUTIFI(R11) 	;SAVE OUTPUT IFI
	MOVW	PPD$W_INPIFI(R10),IDF_W_INPIFI(R9) 	;SAVE INPUT IFI
	MOVW	RAB$W_ISI(R7),IDF_W_OUTISI(R9)		;SAVE OUTPUT ISI
	MOVW	RAB$W_ISI(R7),PRC_W_OUTISI(R11)		;SAVE OUTPUT ISI
	MOVL	PPD$L_OUTDEV(R10),IDF_L_OUTRABCTX(R9) 	;SAVE OUTPUT DEVCHAR
	MOVL	PPD$L_OUTDEV(R10),PRC_L_OUTRABCTX(R11)	;SAVE OUTPUT DEVCHAR
	MOVL	PPD$L_INPDEV(R10),IDF_L_INPRABCTX(R9) 	;SAVE INPUT DEVCHAR
	MOVC	#PPD$C_DVIFID,PPD$T_INPDVI(R10),- 	;COPY INPUT DEVICE NAME/IDS
		IDF_T_INPDVI(R9)
	MOVC	#16,PPD$T_OUTDVI(R10),IDF_T_OUTDVI(R9) 	;COPY OUTPUT DEVICE NAME
	MOVC	#16,PPD$T_OUTDVI(R10),PRC_T_OUTDVI(R11) ;COPY OUTPUT DEVICE NAME
	CLRB	IDF_B_OUTFLAGS(R9)			;CLEAR CCL BITS
	BBC	#PPD$V_INPCCL,PPD$W_FLAGS(R10),771$	;SKIP IF INPUT NOT CCL
	SETBIT	IDF_V_INPCCL,IDF_B_OUTFLAGS(R9)		;SET INPCCL BIT
771$:	BBC	#PPD$V_OUTCCL,PPD$W_FLAGS(R10),772$	;SKIP IF OUTPUT NOT CCL
	SETBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R9)		;SET OUTCCL BIT
772$:	MOVB	IDF_B_OUTFLAGS(R9),PRC_B_OUTFLAGS(R11)	;COPY CCL BITS

;
; CREATE SYS$OUTPUT LOGICAL NAME AND ENABLE IMAGE VERIFICATION IF IN BATCH JOB.
;
	MOVL	R9,R8					;SET ADDRESS OF IDF BLOCK
	BSBW	DCL$CREATE_OUTPUT			;CREATE SYS$OUTPUT LOGICAL NAME
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),78$	;BRANCH IF NOT BATCH JOB
	MOVL	PRC_L_INDFAB(R11),R1			;GET ADDRESS OF FAB
	MOVW	IDF_W_INPIFI(R8),FAB$W_IFI(R1)		;SET INPUT IFI
	JSB	DCL$VERIFY_IMAGE			;SET IMAGE VERIFICATION

;
; STACK INITIALIZATION PROCEDURES PROC1 THRU PROC(PPD$B_NPROCS)
;
78$:	MOVAB	-LNM$C_NAMLENGTH(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP				;CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZBL	#LNM$C_NAMLENGTH,-(SP)		;
	MOVQ	#^A'PROC0',-(SP)		;PUSH PROTOTYPE PROCEDURE NAME
	PUSHL	SP				;AND CONSTRUCT DESCRIPTOR OF IT
	PUSHL	#5				;
	MOVL	SP,R6				;GET ADDRESS OF DESCRIPTOR
	MOVZBL	PPD$B_NPROCS(R10),R7		;GET NUMBER OF INITIAL PROCEDURES
	ADDB	R7,12(R6)			;SET TO LAST PROCEDURE NAME
80$:	MOVZBL	#LNM$C_NAMLENGTH,16(R6)		;RESET LENGTH OF BUFFER
	$TRNLOG_S LOGNAM=(R6),-			;TRANSLATE LOGICAL NAME PROC#
		RSLBUF=16(R6),-			;INTO BUFFER ON STACK
		RSLLEN=16(R6),-			;
		DSBMSK=#3			;DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPW	R0,#SS$_NOTRAN			;NO TRANSLATION?
	BEQL	86$				;IF SO, SKIP THIS ONE
	MOVQ	16(R6),R2			;GET DESCRIPTOR OF PROCEDURE NAME
	CLRL	R4				;SPECIFY PRIMARY OUTPUT FILE
	MOVL	#1,R1				;SUPPRESS RMS ERROR MESSAGES
	BSBW	DCL$PUSHPROC			;PUSH PROCEDURE ONTO INDIRECT STACK
	BLBS	R0,85$				;BRANCH IF SUCCESS
	BBC	#PPD$V_CAPTIVE,-		;CAPTIVE ACCOUNT?
		PPD$W_FLAGS(R10),86$		;NO, THEN SKIP
	MOVL	#CLI$_NOCMDPROC,R0		;SET ERROR STATUS
	BRW	INITIAL_ERROR			;TERMINATE THE PROCESS
85$:	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	CLRL	R6				;SET NO INITIAL VALUES
	BSBW	DCL$DEFINE_P1_TO_P8		;DEFINE P1 THROUGH P8
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
86$:	DECB	12(R6)				;DECREMENT PROCEDURE NUMBER
	SOBGTR	R7,80$				;LOOP UNTIL ALL SYMBOLS DONE
	MOVAB	8+8+8+LNM$C_NAMLENGTH(SP),SP	;DEALLOCATE SCRATCH STORAGE


;
; RUNDOWN LOGINOUT IMAGE, THUS DELETING ALL USER-MODE LOGICAL NAMES
;
	BSBW	DCL$RMSRUNDWN			;RUNDOWN RMS FILES
	$RUNDWN_S #PSL$C_USER			;RUNDOWN LOGINOUT IMAGE


;
; IF THIS PROCESS IS A SUBPROCESS WHICH WAS CREATED BY THE DCL SPAWN
; COMMAND, THEN OPEN THE MAILBOX CONTAINING THE PROCESS CONTEXT AND
; INITIALIZE THIS PROCESS.
;
	CLRQ	-(SP)			;CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		;SET BUFFER ADDRESS
	PUSHL	#JPI$_OWNER@16+4	;REQUEST PARENT PID, SET BUFFER LENGTH
	CLRQ	-(SP)			;ALLOCATE AN IOSB
	MOVL	SP,R0			;
	$GETJPIW_S  ITMLST=8(R0),-	;GET PID OF PARENT PROCESS
		EFN=#EXE$C_SYSEFN,-	;
		IOSB=(R0)		;
	ADDL	#2*4,SP			;POP IOSB
	POPL	R9			;GET PID
	ADDL	#3*4,SP			;CLEANUP STACK
	TSTL	R9			;IS THIS A SUBPROCESS?
	BEQL	120$			;IF NOT, SKIP SPAWN INITIALIZATION
	MOVAB	-LNM$C_NAMLENGTH(SP),SP	;ALLOCATE BUFFER ON STACK
	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZBL	#LNM$C_NAMLENGTH,-(SP)	;
	MOVL	SP,R6			;POINT TO BUFFER DESCRIPTOR
	SUBL	#4,SP			;ALLOCATE SCRATCH LONGWORD FOR ACMODE
	MOVAB	SYS$ERROR,R2		;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R2)+,R1		;CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R1,-(SP)		;PUSH DESCRIPTOR OF SYS$ERROR
	$TRNLOG_S LOGNAM=-12(R6),-	;TRANSLATE SYS$ERROR
		RSLBUF=(R6),-
		RSLLEN=(R6),-
		DSBMSK=#3,-		;ONLY SEARCH PROCESS LOGNAME TABLE
		ACMODE=-4(R6)
	CMPB	-4(R6),#PSL$C_SUPER	;SUPERVISOR MODE SYS$ERROR?
	BNEQ	100$			;IF NOT, THEN NO CONTEXT WAS PASSED
	CMPL	@4(R6),#^A'_MBA'	;IS MAILBOX NAME A PHYSICAL DEVICE?
	BNEQ	90$			;IF NOT, INVALID SPAWN - DELETE LOGNAM
	BSBW	SPAWN_CONTEXT		;INITIALIZE BASED ON SPAWN CONTEXT
90$:	MOVL	SP,R0			;GET ADDRESS OF 'SYS$ERROR' DESCRIPTOR
	$DELLOG_S LOGNAM=(R0),-		;DELETE SUPERVISOR MODE SYS$ERROR
		TBLFLG=#LOG$C_PROCESS,-	;LEAVING EXECUTIVE MODE SYS$ERROR
		ACMODE=#PSL$C_SUPER	;(WHICH IS EQUIVALENT TO SYS$OUTPUT)
100$:	MOVAB	8+4+8+LNM$C_NAMLENGTH(SP),SP	;DEALLOCATE SCRATCH STORAGE


;
; MAKE SURE COMMAND TABLES HAVE A VALID STRUCTURE LEVEL NUMBER
;
120$:	PUSHL	G^CTL$AG_CLITABLE	; GET ADDRESS OF COMMAND TABLES
	CALLS	#1,G^CDU$UPGRADE_TABLE	; VALIDATE TABLE STRUCTURE
	BLBC	R0,INITIAL_ERROR	; SIGNAL ERROR STATUS AND ABORT

;
; TELL THE TERMINAL DRIVER THAT WE NOW OWN THE TERMINAL.
;
	BBCC	#PRC_V_DETACHED,PRC_W_FLAGS(R11),125$ ; BRANCH IF NOWAIT SUBPROCESS
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),125$ ; BRANCH IF NOT INTERACTIVE
	CLRQ	-(SP)				; ALLOCATE AN IOSB
	MOVL	SP,R0				; GET ADDRESS OF IOSB
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_TT_PROCESS,- ; ASSUME TERMINAL OWNERSHIP
		CHAN=PRC_W_INPCHAN(R11),-	;
		IOSB=(R0),-			;
		EFN=#EXE$C_SYSEFN		;
	ADDL	#8,SP				; RESTORE THE STACK

;
; ENABLE CONTROL/Y AST ROUTINE AND OUT-OF-BAND AST ROUTINES.
;
125$:	BSBW	DCL$ENBCONTRLY		; ENABLE CONTROL Y AST'S
	MOVL	PRC_L_OUTOFBAND(R11),R1	; GET AST CHARACTER MASK
	CLRL	PRC_L_OUTOFBAND(R11)	; FORCE INITIALIZATION
	BSBW	DCL$RESETOOB		; ENABLE/DISABLE APPROPRIATE AST'S

;
; ENABLE CHANGE MODE TO SUPERVISOR HANDLING ROUTINE
;
	$DCLCMH_S W^DCL$CHANGE_MODE	; SET CHANGE MODE TO SUPER HANDLER
	BLBC	R0,INITIAL_ERROR	; BRANCH IF ERROR DETECTED

;
; PROCESS FIRST COMMAND LINE
;
	BRW	DCL$RESTART		; START COMMAND INTERPRETATION

;
; ERROR OCCURED SOMEWHERE IN STARTUP PROCEDURE.  SIGNAL IT AND ABORT.
;
INITIAL_ERROR:
	MOVL	SP,R10			;SET BASE ADDRESS OF WRK
	MOVAB	WRK_C_LENGTH(SP),SP	;ALLOCATE WRK TO SIGNAL MESSAGE
	MOVW	#WRK_M_COMMAND,WRK_W_FLAGS(R10)	;CLEAR FLAGS, SET WRK_V_COMMAND
					;TO MARK NO ERROR TEXT SEGMENT
	BSBW	DCL$ERRORMSG		;ISSUE ERROR MESSAGE
	BRW	DCL$ABORT		;AND EXIT PROCESS

	.SBTTL	SPAWN_CONTEXT, INITIALIZE BASED ON SPAWN CONTEXT
;---
;
; THIS ROUTINE IS CALLED TO INITIALIZE THE SUBPROCESS FROM THE CONTEXT
; PASSED FROM THE PARENT PROCESS DURING EXECUTION OF A SPAWN COMMAND.
;
; INPUTS:
;
;	R6 = ADDRESS OF DESCRIPTOR OF MAILBOX DEVICE NAME
;		(PASSED TO SUBPROCESS AS SYS$ERROR TRANSLATION)
;	R9 = PID OF PARENT PROCESS
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	THE CONTEXT IS INITIALIZED, IF POSSIBLE.
;
;	R0-R8 DESTROYED.
;---

SPAWN_CONTEXT:
	ASSUME	DIB$C_LENGTH LE CTX_C_MAXLEN
	MOVAB	-CTX_C_MAXLEN(SP),SP		;ALLOCATE DIB/CTX STORAGE
	PUSHL	SP				;CREATE DESCRIPTOR OF DIB BUFFER
	MOVZWL	#CTX_C_MAXLEN,-(SP)		;
	MOVAL	-(SP),R2			;ALLOCATE CHANNEL LONGWORD
	$ASSIGN_S DEVNAM=(R6),-			;ASSIGN A CHANNEL TO THE MAILBOX
		CHAN=(R2)			;
	BLBC	R0,90$				;IF ERROR, SKIP IT
	$GETCHN_S CHAN=(R2),-			;GET DEVICE CHARACTERISTICS
		PRIBUF=4(R2)			;
	BLBC	R0,50$				;IF ERROR, SKIP IT
	BBC	#DEV$V_MBX,DIB$L_DEVCHAR+12(R2),50$ ;IF NOT MAILBOX, SKIP IT

;
; READ NEXT RECORD FROM MAILBOX AND PROCESS IT
;
10$:	MOVL	SP,R2				;GET ADDRESS OF CHAN,IOSB,BUFFER
	$QIOW_S FUNC=#IO$_READVBLK,-		;READ NEXT RECORD
		CHAN=(R2),-			;
		IOSB=4(R2),-			;RE-USE DESCRIPTOR AS IOSB
		EFN=#EXE$C_SYSEFN,-		;USE SYSTEM EFN
		P1=12(R2),-			;ADDRESS OF RECEIVE BUFFER
		P2=#CTX_C_MAXLEN		;SIZE OF RECEIVE BUFFER
	BLBC	R0,50$				;IF SUBMIT ERROR, SKIP IT
	BLBC	4(R2),50$			;IF I/O ERROR (OR EOF), EXIT
	CMPL	8(R2),R9			;IS TRANSMITTER OUR PARENT PROCESS?
	BNEQ	50$				;IF NOT, SKIP IT
	MOVZWL	6(R2),R4			;GET SIZE OF RECORD
	MOVAB	12(R2),R5			;POINT TO CTX RECORD
	PUSHAB	10$				;RETURN TO TOP OF LOOP AFTER PROCESSING

	;
	; THESE ROUTINES MAY DESTROY R0-R8
	; ON ENTRY, R4/R5 = DESCRIPTOR OF CTX RECORD
	;
	CASE	CTX_W_TYPE(R5),TYPE=W,<- 	;CASE ON TYPE OF RECORD
		SPAWN_HEADER,-			;HEADER RECORD
		SPAWN_CMDSTR,-			;COMMAND STRING
		SPAWN_LOGNAM,-			;LOGICAL NAME
		SPAWN_CLISYM,-			;CLI SYMBOL
		SPAWN_KEYSTATE,-		;KEYPAD STATE
		SPAWN_LNMTABLE,-		;LOGICAL NAME TABLE
		SPAWN_LNMNAME,-			;SIMPLE LOGICAL NAME
		SPAWN_LNMTRAN>			;ADDITIONAL TRANSLATIONS
	RSB					;IF UNKNOWN, SKIP RECORD

50$:	$DASSGN_S CHAN=(R2)			;DEASSIGN CHANNEL TO MAILBOX
90$:	MOVAB	4+8+CTX_C_MAXLEN(SP),SP		;DEALLOCATE SCRATCH STORAGE
	RSB

;
; PROCESS A SPAWN HEADER CONTEXT RECORD
;
SPAWN_HEADER:
	MNEGL	#1,-(SP)			;CREATE PRIVILEGE MASK WITH ALL
	MNEGL	#1,-(SP)			;THE PRIVILEGE BITS SET
	MOVL	SP,R0				;GET ADDRESS OF IT
	$SETPRV_S PRVADR=(R0),-			;DISABLE ALL PRIVILEGES
		  PRMFLG=#1,-			;
		  ENBFLG=#0			;
	ADDL	#8,SP				;DEALLOCATE PRIVILEGE MASK ON STACK
	$SETPRV_S PRVADR=CTX_Q_PROCPRIV(R5),- 	;ENABLE NEW PRIVILEGES
		  PRMFLG=#1,-			;
		  ENBFLG=#1			;
	BBC	#CTX_V_WAIT,CTX_B_FLAGS(R5),5$		;COPY WAIT FLAG
	SETBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)
5$:	BBC	#CTX_V_AUTOLOGO,CTX_B_FLAGS(R5),10$	;COPY SILENT LOGOUT FLAG
	SETBIT	PRC_V_AUTOLOGO,PRC_W_FLAGS(R11)
10$:	BBC	#CTX_V_MODE,CTX_B_FLAGS(R5),20$ 	;IF BATCH, SET EOF SILENT LOGOUT FLAG
	SETBIT	PRC_V_EOFLOGO,PRC_W_FLAGS(R11)
20$:	CLRBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11)		;ASSUME FLAG OFF
	BBC	#CTX_V_VERIFY,CTX_B_FLAGS(R5),25$ 	;COPY VERIFICATION FLAG
	SETBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11)
25$:	MOVL	#1,R6					;ASSUME FLAG ON
	BBS	#CTX_V_VERIMAGE,CTX_B_FLAGS(R5),30$ 	;IF SET, FLAG OK AS IS
	CLRL	R6					;SET FLAG TO TURN OFF VERIIFY
30$:	JSB	DCL$SETVERIFY_IMAGE			;TURN IMAGE VERIFY ON/OFF
	MOVL	CTX_L_OUTOFBAND(R5),-			;COPY OUT-OF-BAND AST MASK
		PRC_L_OUTOFBAND(R11)  
	MOVZBL	CTX_B_PROMPTLEN(R5),R0		;COPY PROMPT STRING LENGTH
	MOVB	R0,PRC_B_PROMPTLEN(R11)		;
	MOVC	R0,CTX_W_PMPTCTRL(R5),-		;COPY PROMPT STRING
		PRC_W_PMPTCTRL(R11)		;
	CMPW	#0,PRC_W_PMPTCTRL(R11)		;CR/LF CURRENTLY IN USE?
	BNEQ	35$				;YES, CARRCNTL FLAG OK AS IS
	CLRBIT	PRC_V_CARRCNTL,PRC_W_FLAGS(R11)	;NO, INDICATE NO CR/LF IN USE.
35$:	RSB

;
; PROCESS COMMAND STRING RECORD
;
SPAWN_CMDSTR:
	MOVAB	PRC_Q_COMMAND(R11),R6	;POINT TO COMMAND DESCRIPTOR AREA
	SUBW3	#CTX_T_CMDSTR,R4,R7	;COMPUTE SIZE OF COMMAND STRING
	MOVW	R7,2(R6)		;SET SIZE OF COMMAND STRING
	BSBW	DCL$ALLDEACMD		;ALLOCATE BUFFER TO HOLD COMMAND
	BLBC	R0,90$			;IF ERROR, SKIP IT
	MOVQ	R1,(R6)			;STORE DESCRIPTOR OF BUFFER
	MOVC	R7,CTX_T_CMDSTR(R5),(R2) ;STORE COMMAND STRING IN BUFFER
	CLRB	(R3)			;AND ENSURE THAT ITS TERMINATED
	SETBIT	PRC_V_CMD,PRC_B_FLAGS2(R11) ;MARK COMMAND PENDING
90$:	RSB

;
; PROCESS SPAWN KEYPAD STATE
;
SPAWN_KEYSTATE:
	MOVZBL	CTX_B_KEYLENGTH(R5),R1		;GET LENGTH OF STATE
	MOVAB	CTX_T_KEYSTATE(R5),R2		;GET ADDRESS OF STRING
	BSBW	DCL$ALLOC_STATE			;ALLOCATE STATE SYMBOL
	MOVL	PRC_L_CURRKEY(R11),-		;LOCK THAT STATE
		PRC_L_LASTKEY(R11)		;
	RSB

;
; PROCESS SPAWN LOGICAL NAME RECORDS
;
SPAWN_LOGNAM:
	MOVZBL	CTX_B_ACMODE(R5),R0	;GET ACMODE OF LOGICAL NAME
	CMPB	R0,#PSL$C_SUPER		;IS ACMODE HIGHER THAN SUPER?
	BLSS	90$			;IF EXEC OR KERNEL, CANNOT DEFINE IT
	PUSHAB	CTX_T_LOGNAM+1(R5)	;PUSH DESCRIPTOR OF LOGNAM
	MOVZBL	CTX_T_LOGNAM(R5),-(SP)	;
	ADDL3	(SP),4(SP),R2		;POINT TO WORD COUNTED EQLNAM
	MOVZWL	(R2)+,R1		;CONSTRUCT DESCRIPTOR OF EQLNAM
	PUSHR	#^M<R1,R2>		;PUSH DESCRIPTOR OF EQLNAM
	MOVL	SP,R3			;GET ADDRESS OF STACK
	$CRELOG_S LOGNAM=8(R3),-	;CREATE LOGICAL NAME
		EQLNAM=(R3),-
		ACMODE=R0,-
		TBLFLG=#LOG$C_PROCESS
	ADDL	#4*4,SP			;CLEANUP STACK
90$:	RSB

;
; PROCESS SPAWN CLI SYMBOL RECORDS
;
SPAWN_CLISYM:
	ASSUME	CTX_C_STRING EQ SYM_K_STRING
	ASSUME	CTX_C_PERM EQ SYM_K_PERM
	ASSUME	CTX_C_BINARY EQ SYM_K_BINARY
	ASSUME	CTX_C_KEYPAD EQ SYM_K_KEYPAD
	MOVZBL	CTX_B_SYMTYPE(R5),R0	; R0 = SYMBOL TYPE
	MOVAB	CTX_T_SYMBOL(R5),R4	; GET ADDRESS OF ASCIC NAME
	MOVZBL	(R4)+,R3		; R3/R4 = DESCRIPTOR OF SYMBOL NAME
	ADDL3	R3,R4,R2		; POINT TO JUST AFTER SYMBOL NAME
	ASSUME	CTX_C_STRING EQ 0
	ASSUME	CTX_C_PERM EQ 1
	ASSUME	CTX_C_BINARY EQ 2
	ASSUME	CTX_C_KEYPAD EQ 4
	CASE	R0,TYPE=B,<-		; CASE ON SYMBOL TYPE
		10$,-			; STRING
		5$,-			; IGNORE PERMANENT STRINGS
		20$,-			; BINARY
		5$,-			; UNKNOWN
		10$>			; KEYPAD SYMBOL
5$:	RSB				; SKIP UNKNOWN TYPES
10$:	MOVZWL	(R2)+,R1		; R1/R2 = DESCRIPTOR OF STRING VALUE
	BRB	40$
20$:	MOVL	(R2),R1			; R1 = LONGWORD BINARY VALUE
40$:	MOVL	R5,R6			; COPY ADDRESS OF CTX RECORD
	ASSUME	CTX_C_GLOBAL EQ 0
	ASSUME	CTX_C_LOCAL EQ 1
	ASSUME	CTX_C_KEYTABL EQ 2
	CASE	CTX_B_SYMTAB(R5),TYPE=B,<-	; CASE ON SYMBOL TABLE
		50$,-			; GLOBAL SYMBOL TABLE
		60$,-			; LOCAL SYMBOL TABLE
		65$>			; KEYPAD SYMBOL TABLE
	RSB				; IGNORE UNKNOWN SYMBOL TABLE NUMBER
50$:	MOVAB	PRC_Q_GLOBAL(R11),R5	; R5 = ADDRESS OF GLOBAL SYMBOL LISTHEAD
	BRB	70$
60$:	MOVAB	PRC_Q_LOCAL(R11),R5	; R5 = ADDRESS OF LOCAL TABLE LISTHEAD
	BRB	70$
65$:	MOVAB	PRC_Q_KEYPAD(R11),R5	; R5 = ADDRESS OF KEYPAD SYMBOL TABLE
70$:	BSBW	DCL$RESTORE_SYM		; ADD SYMBOL (R1-R6 ARE ARGUMENTS)
	RSB

;
; PROCESS SPAWN LOGICAL NAME TABLE RECORDS
;
SPAWN_LNMTABLE:
	CMPB	CTX_B_ACMODE(R5),-	; IS ACMODE HIGHER THAN SUPER?
		#PSL$C_SUPER		;
	BLSS	90$			; IF EXEC OR KERNEL, CANNOT DEFINE IT
	MOVZBL	CTX_B_ACMODE(R5),-(SP)	; GET ACMODE OF LOGICAL NAME
	MOVZBL	CTX_B_TFLAGS(R5),-(SP)	; GET ATTR FLAGS
	MOVAL	CTX_T_LNMTABLE(R5),R4	; PTR TO NAME
	MOVZBL	(R4)+,R1		; GET SIZE
	PUSHL	R4			; PUSH ADDR
	PUSHL	R1			; AND SIZE
	ADDL2	R1,R4			; ADVANCE TO PARENT TABLE NAME
	MOVZBL	(R4)+,R1		; GET SIZE
	PUSHL	R4			; PUSH ADDR
	PUSHL	R1			; AND SIZE
	MOVL	SP,R1			; REMEMBER DESCR ADDR
	
	$CRELNT_S	-
		ATTR=16(R1),-		; ATTRIBUTES
		QUOTA=CTX_L_QUOTA(R5),-	; QUOTA
		ACMODE=20(R1),-		; ACCESS MODE
		TABNAM=8(R1),-		; DESC OF TABLE NAME		
		PARTAB=(R1)		; DESC OF PARENT TABLE NAME
	ADDL2	#<6*4>,SP		; REMOVE DESCRIPTORS
90$:	RSB

;
; THE FOLLOWING ASSUMES ARE NEEDED BECAUSE THIS CODE PROCESSES LOGICAL
; NAME BLOCKS IN THEIR INTERNAL FORMAT.
;
	ASSUME	LNMX$B_FLAGS	EQ	0
	ASSUME	LNMX$B_INDEX	EQ	LNMX$B_FLAGS+1
	ASSUME	LNMX$W_HASH	EQ	LNMX$B_INDEX+1
	ASSUME	LNMX$T_XLATION	EQ	LNMX$W_HASH+2

;
; PROCESS SPAWNED LOGICAL NAMES
;
SPAWN_LNMNAME:
	CMPB	CTX_B_ACMODE(R5),#PSL$C_SUPER	;IS ACMODE HIGHER THAN SUPER?
	BGEQ	5$
3$:	RSB				;IF EXEC OR KERNEL, CANNOT DEFINE IT
5$:	MOVZBL	CTX_B_TRANCNT(R5),R1	; COUNT OF XLATIONS
	MULL2	#<3*3*4>,R1		; 3 DESCRIPTORS OF 3 LONGWORDS EACH
	ADDL2	#4,R1			; ZERO TERMINATOR
	BSBW	DCL$ALLDYNMEM		; GET SPACE FOR ITMLST
	BLBC	R0,3$			; GIVE UP IF NO ROOM
	MOVQ	R1,R6			; SAVE SPACE DESCRIPTION
	MOVAB	CTX_T_LNMNAME(R5),R0	; PTR TO NAME
	PUSHAB	1(R0)			; MAKE DESCRIPTOR OF TABLE
	MOVZBL	(R0)+,-(SP)		;  NAME
	ADDL2	(SP),R0			; SKIP OVER TABLE NAME
	PUSHAB	1(R0)			; MAKE DESCRIPTOR OF LOGICAL
	MOVZBL	(R0)+,-(SP)		;  NAME
	ADDL2	(SP),R0			; SKIP OVER LOGICAL NAME
	MOVL	SP,R4			; REMEMBER ADDRESS
10$:	BBS	#LNMX$V_XEND,LNMX$B_FLAGS(R0),20$ ; END OF LIST
	MOVZBL	(R0)+,-(SP)		; PUSH ATTRIBUTE VALUE (LNMX$B_FLAGS)
	ROTL	#8,(SP),(SP)		; PUT ATTRIBUTES IN 2ND BYTE
	MOVL	#<<LNM$_ATTRIBUTES@16>+4>,(R2)+ ; MAKE ITMLST ENTRY FOR XL ATTR
	MOVAL	(SP),(R2)+		; ADDR OF XL ATTR
	CLRL	(R2)+			; IGNORE RETURN LENGTH
	MOVZBL	(R0)+,-(SP)		; PUSH INDEX VALUE (LNMX$B_INDEX)
	MOVL	#<<LNM$_INDEX@16>+4>,(R2)+ ; MAKE ITMLST ENTRY FOR XL INDEX
	MOVAL	(SP),(R2)+		; ADDR OF XL INDEX
	CLRL	(R2)+			; IGNORE RETURN LENGTH
	ADDL2	#2,R0			; SKIP OVER THE HASH CODE FIELD
	MOVZBL	(R0)+,R1		; STRING LENGTH
	MOVW	R1,(R2)+		; MAKE ITMLST ENTRY FOR XL STRING
	MOVW	#LNM$_STRING,(R2)+ 	;  (LNMX$T_XLATION)
	MOVAL	(R0),(R2)+		; ADDR OF XL STRING
	CLRL	(R2)+			; IGNORE RETURN LENGTH
	ADDL2	R1,R0			; SKIP OVER STRING
	BRB	10$			; GET NEXT STRING
20$:	CLRL	(R2)+			; MARK END OF ITMLST
	MOVZBL	CTX_B_ACMODE(R5),-(SP)	; GET ACCESS MODE
	MOVZBL	CTX_B_NFLAGS(R5),-(SP)	; GET NAME ATTRIBUTES
	MOVL	SP,R0			; GET ADDRESS OF STACK

	$CRELNM_S	-		; CREATE THE NAME
		ATTR=(R0),-		; ATTRIBUTES
		TABNAM=8(R4),-		; TABLE NAME
		LOGNAM=(R4),-		; LOGICAL NAME
		ACMODE=4(R0),-		; ACCESS MODE
		ITMLST=(R7)		; ITMLST
	MOVAB	16(R4),SP		; CLEAN THE STACK
	MOVL	R6,R1			; SIZE OF DYN MEMORY
	MOVL	R7,R0			; ADDR OF DYN MEMORY	
	BSBW	DCL$DEADYNMEM		; FREE THE SPACE
90$:	RSB

SPAWN_LNMTRAN:
	RSB				; RETURN


	.SBTTL	CLI$GET_PRC, GET ADDRESS OF PRC STRUCTURE
;---
;
;	THIS ROUTINE IS CALLED TO GET THE ADDRESS OF THE CLI
;	OWN STORAGE AREA (PRC).
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;---

CLI$GET_PRC::
	MOVAB	G^CTL$AG_CLIDATA,R11	;GET ADDRESS OF PPD
	MOVL	PPD$L_PRC(R11),R11	;SET ADDRESS OF CLI OWN STORAGE
	RSB
 
	.END	DCL$STARTUP
