MODULE DISMOU (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  DISMOUNT Utility Structure Level 1
!
! ABSTRACT:
!
!	This is the main routine of the DISMOUNT command.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  28-Oct-1977  14:12
!
! MODIFIED BY:
!
!	V03-016	HH0035		Hai Huang		10-Jul-1984
!		Fix truncation errors.
!
!	V03-015	HH0027		Hai Huang		26-Jun-1984
!		Prevent race condition between two simultaneous dismounts
!		on the same volume.
!
!	V03-014	MHB0154		Mark Bramhall		27-Apr-1984
!		Correct NSA$B_ARG_FLAG setting for multiple audits enabled.
!
!	V03-013	LMP0229		L. Mark Pilant,		12-Apr-1984  12:24
!		Remove references to the CHIP block.
!
!	V03-012	HH0014		Hai Huang		10-Apr-1984
!		Synchronize $GETDVIW on MOUNT_EFN.
!
!	V03-011	HH0013		Hai Huang		09-Apr-1984
!		Use LNM$C_MAXDEPTH to represent maximum number of times to 
!		recursively translate a logical name.
!
!	V03-010	HH0009		Hai Huang		28-Mar-1984
!		Add security auditing support.
!
!	V03-009	LMP0221		L. Mark Pilant,		26-Mar-1984  16:27
!		Change the device owner location to the ORB from the UCB.
!
!	V03-008	HH0007		Hai Huang		22-Mar-1984
!		Add cluster-wide group volume support.
!
!	V03-007	HH0004		Hai Huang		28-Feb-1984
!		Add cluster-wide mount support.
!
!	V03-006	HH0006		Hai Huang		05-Mar-1984
!		Fix bug introduced by HH0003 when dismounting a 
!		foreign magtape.
!
!	V03-005	HH0003		Hai Huang		07-Feb-1984
!		Add forced dismount support.
!
!	V03-004 HH0002		Hai Huang		23-Jan-1984
!		Add job-wide mount support.
!
!	V03-003	RAS0168		Ron Schaefer		12-Jul-1983
!		Interlock the logical name mutex when interogating
!		MTL$L_LOGNAME.
!
!	V03-002	DMW4051		DMWalp			20-Jun-1983
!		Intergration of new logical name structures
!
!	V03-001	STJ0240		Steven T. Jeffreys,	23-Mar-1982
!		Use system routines to check descriptors.
!
!	V02-010	STJ0231		Steven T. Jeffreys,	02-Mar-1982
!		Copy buffer descriptor to internal storage before probing.
!
!	V02-009	STJ0227		Steven T. Jeffreys,	17-Feb-1982
!		Fix incorrect probe of the user-specified device name.
!		Also fix typos in update packet.
!
!	V02-008	STJ0176		Steven T. Jeffreys,	07-Jan-1981
!		Set BUGCHECK and EXQUOTA privileges for the user, and
!		clear them when we are done with them.
!
!	V02-007	ACG0248		Andrew C. Goldstein,	31-Dec-1981  13:14
!		Interlock mounted volume list with I/O database mutex
!
!	V02-006	STJ0075		Steven T. Jeffreys	24-Jul-1981
!		Liberal rewrite to convert the existing dismount code
!		to a system service.
!
!	V02-005	PCG0001		Peter C. George		03-Feb-1981 10:00
!		Change MOUNTMSG require to DISMOUMSG.
!
!	V02-004	ACG0181		Andrew C. Goldstein,	9-Oct-1980  15:59
!		Fix cross facility source reference
!
!	X0103	ACG0072		Andrew C. Goldstein,	15-Oct-1979  16:21
!		Check primary and secondary device characteristics
!
!	X0102	ACG0025		Andrew C. Goldstein,  6-Mar-1979  21:03
!	Fix magtape testing code
!
!	X0101	ACG0003		Andrew C. Goldstein,  10-Jan-1979  20:02
!	Add multi-volume disk support
!
!	X0100	ACG0001		Andrew C. Goldstein,  24-Oct-1978  13:47
!	Previous revision history moved to [DISMOU.SRC]DISMOUNT.REV
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'LIB$:MOUDEF.B32';
REQUIRE 'LIBD$:[VMSLIB.OBJ]DISMOUMSG.B32';


FORWARD ROUTINE
	SYS$DISMOU,			! main program
	MAKE_DISMOUNT,			! kernel mode routine
	TRAN_LOGNAME,			! recursive logical name translator
	SEARCH_MOUNT,			! find MTL entry
	SETUP_MTL,			! set up local MTL database
	MOVE_MTL,			! set up MTL database for a volume set
	FIND_MTL,			! set up MTL database for a volume
	CHECK_PRIV,			! privilege check routine
	DISMOUNT_CLUSTER,		! cluster-wide dismount routine
	DISMOUNT_ENCIPHER,		! create a cluster-dismount packet
	DISMOUNT_AUDIT	: NOVALUE,	! security auditing
	LABEL_LENGTH;			! return the length of a label

GLOBAL
	CLUSTER_DEVICE;			! global area to hold cluster device 
					! characterstic bit


! Define the CODE psect so that the generated code has PIC and SHR attributes.
!

PSECT	CODE = Z$DISMOUNT (PIC,SHARE);

GLOBAL ROUTINE SYS$DISMOU (DEVNAM, FLAGS) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is the main routine of the DISMOUNT command.
!
! INPUT PARAMETERS:
!	DEVNAM	: Address of a device name descriptor.
!	FLAGS	: A longword bit mask.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	assorted status values
!
! SIDE EFFECTS:
!	volume(s) dismounted, device data base updated
!
!--

BEGIN

!
! Allocate plits in the Z$DISMOUNT psect to avoid truncation error when
! linking mountshr.
!
PSECT
	PLIT = Z$DISMOUNT;

LINKAGE
	L_PDESC		= JSB (REGISTER=1; REGISTER=1, REGISTER=2):
				NOPRESERVE (3)
				NOTUSED (4,5,6,7,8,9,10,11);

EXTERNAL ROUTINE
	EXE$PROBER_DSC	: L_PDESC ADDRESSING_MODE (GENERAL);

LOCAL
	LENGTH		: LONG,		! Output from EXE$PROBER_DSC
	ADDRESS		: LONG,		! Output from EXE$PROBER_DSC
	DEV_NAME	: BBLOCK [DSC$K_S_BLN],
	USER_PRIVS	: BBLOCK [8],	! storge for initial user privs
	DISMOUNT_PRIVS	: BBLOCK [8],	! privileges needed for $DISMOU
	CHANNEL		: LONG,		! channel number for I/O
	PHYS_NAME	: BBLOCK [DSC$K_S_BLN],
					! descriptor of physical device name
	NAME_BUFFER	: VECTOR [NAMEBUF_LEN, BYTE],
					! string buffer for physical device name
	STATUS,				! system service status
	LOCK_STATUS	: VECTOR [2, LONG],
					! lock status block
	DMTLCKNAM_BUF	: VECTOR [NAMEBUF_LEN, BYTE]
			  INITIAL (BYTE ('DMT$', REP NAMEBUF_LEN-4 OF (' '))),
					! DMT resource name buffer
	DMTLCKNAM_DSC	: VECTOR [2, LONG]
			  INITIAL (0, DMTLCKNAM_BUF),
					! DMT resource name descriptor	
	ITMLST 		: BBLOCK [(1*12) + 4] INITIAL
			  ! 
			  ! Item: Allocation device name
			  !
			  (WORD (NAMEBUF_LEN-4),	
			   WORD (DVI$_ALLDEVNAM),	
			   LONG (DMTLCKNAM_BUF+4),
			   LONG (DMTLCKNAM_DSC),
			  !
			  ! Item list stopper
			  !
			   LONG (0));
	

! Probe the device descriptor and the string it describes for read access.
! The string descriptor is copied to DEV_NAME for future reference.
!
IF NOT (STATUS = EXE$PROBER_DSC (.DEVNAM; LENGTH, ADDRESS))
THEN
    RETURN (.STATUS);
DEV_NAME [DSC$W_LENGTH] = .LENGTH;
DEV_NAME [DSC$B_DTYPE]  = 0;
DEV_NAME [DSC$B_CLASS]  = 0;
DEV_NAME [DSC$A_POINTER]= .ADDRESS;

! Set up the physical device name descriptor.
!

PHYS_NAME[DSC$B_CLASS]		= 0;	! set up physical device name descriptor
PHYS_NAME[DSC$B_DTYPE]		= 0;
PHYS_NAME[DSC$W_LENGTH]		= NAMEBUF_LEN;
PHYS_NAME[DSC$A_POINTER]	= NAME_BUFFER;

! Translate the logical name and then assign a channel to the device.
! The channel is needed for two reasons; first, the device UCB address
! is needed, and it can easily be gotten once a channel has been assigned
! to the device, and second, having a channel assigned to the device will
! act as an interlock, and will prevent premature deallocation of the VCB.
!

CHANNEL = 0;
IF NOT (STATUS = TRAN_LOGNAME (DEV_NAME, PHYS_NAME[DSC$W_LENGTH]))
THEN
    RETURN .STATUS;
IF NOT (STATUS = $ASSIGN (CHAN = CHANNEL, DEVNAM = PHYS_NAME[DSC$W_LENGTH]))
THEN
    RETURN .STATUS;

! Give the user the necessary privileges and dismount the volume.
!

DISMOUNT_PRIVS = 0;
DISMOUNT_PRIVS+4 = 0;
DISMOUNT_PRIVS [PRV$V_BUGCHK]  = 1;		! Grant BUGCHECK privilege
DISMOUNT_PRIVS [PRV$V_EXQUOTA] = 1;		! Grant EXQUOTA privilege
$SETPRV (ENBFLG=1, PRVADR=DISMOUNT_PRIVS, PRVPRV=USER_PRIVS);

!
! Take out the DMT$ interlock on this device to prevent race condition 
! between simultaneous dismounts on the same volume.
!

$GETDVIW (   CHAN = .CHANNEL,			! Get the full device name
	   ITMLST = ITMLST,
	      EFN = MOUNT_EFN );

DMTLCKNAM_DSC [0] = .DMTLCKNAM_DSC [0] + 4;	! Add in "DMT$" prefix

$ENQW   (  LKMODE = LCK$K_EXMODE,		! Take out the DMT$ interlock
	     LKSB = LOCK_STATUS,
	    FLAGS = LCK$M_SYSTEM,
	   RESNAM = DMTLCKNAM_DSC,
	      EFN = MOUNT_EFN  );

!
! Go dismount the volume.
!

STATUS = MAKE_DISMOUNT (.FLAGS, .CHANNEL);

!
! Dequeue the DMT interlock.
!

IF ( .LOCK_STATUS [1] NEQ 0 )			! Release the DMT$ interlock
THEN
    $DEQ ( LKID = .LOCK_STATUS [1] );

!
! If the dismount was successful, send this dismount request cluster-wide
! when appropriate.
!

IF .STATUS THEN
    STATUS = DISMOUNT_CLUSTER (PHYS_NAME, .FLAGS); ! Do cluster-wide dismount
						! with the physical device name

! Revoke whatever special privileges were
! granted, deassign the channel, and exit.
!

$SETPRV (ENBFLG=0, PRVADR=DISMOUNT_PRIVS);	! Revoke granted privileges
$SETPRV (ENBFLG=1, PRVADR=USER_PRIVS);		! Restore old privileges
$DASSGN (CHAN = .CHANNEL);
RETURN .STATUS;

END;					! end of routine DISMNT_COMMAND

ROUTINE MAKE_DISMOUNT (FLAGS, CHANNEL) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine does the kernel mode validation and initial setup
!	of the dismount operation.
!
!
! INPUT PARAMETERS:
!	FLAGS	: A longword bit mask.
!	CHANNEL	: The channel number of the channel assigned to the device.
!
! IMPLICIT INPUTS:
!	NONE.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1 if successful, various statuses if not
!
! SIDE EFFECTS:
!	Volume dismounted, logical name and MTL entry deleted.
!	The cluster device characteristic bit is save in global
!	area.
!
!--

BEGIN

MAP
	FLAGS		: BBLOCK;	! flag bits for dismount options

BUILTIN
	REMQUE;				! remove an item from a queue

LINKAGE
	IOC_DISMOUNT	= JSB (REGISTER = 6, REGISTER = 3, REGISTER = 4) :
			NOPRESERVE (2);

LITERAL
	DEVCHAR_SIZE	= 4;		! Length (in bytes) of device characteristics

LOCAL
	DEVICE_CHAR	: BBLOCK [DEVCHAR_SIZE],
					! buffer for device characteristics
	DEVICE_CHAR2	: BBLOCK [DEVCHAR_SIZE],
					! buffer for sec. device characteristics
	DEVCHAR_DESC	: BBLOCK [DSC$K_S_BLN],
					! descriptor for device characteristics
	DEVCHAR_DESC2	: BBLOCK [DSC$K_S_BLN],
					! descriptor for sec. device characteristics
	MAGTAPE,			! flag indicating that device is magtape
	J,				! RVT loop index
	PRIVATE,			! flag indicating private mount found
	RVT_LENGTH,			! number of entries in RVT
	LIST_HEAD	: REF VECTOR,	! pointer to current mount list head
	CCB		: REF BBLOCK,	! CCB of channel (points to UCB)
	UCB		: REF BBLOCK,	! UCB of device
	VCB		: REF BBLOCK,	! VCB of device
	RVT		: REF BBLOCK,	! address of relative volume table
	MTL		: REF BBLOCK,	! address of found MTL entry
	STATUS;				! status of various routines

EXTERNAL
	CTL$GL_CCBBASE	: ADDRESSING_MODE (GENERAL),
					! base address of CCB table
	SCH$GL_CURPCB	: REF BBLOCK ADDRESSING_MODE (GENERAL),
					! address of our PCB
	CTL$GL_PHD	: REF BBLOCK ADDRESSING_MODE (GENERAL),
					! address of our process header
	EXE$GL_SYSUCB	: REF BBLOCK ADDRESSING_MODE (GENERAL),
					! address of system device UCB
	CTL$GQ_MOUNTLST : VECTOR ADDRESSING_MODE (GENERAL),
					! temporary mount list head
	IOC$GQ_MOUNTLST	: VECTOR ADDRESSING_MODE (GENERAL);
					! system mounted volume listhead

EXTERNAL ROUTINE
	LOCK_IODB,			! lock I/O database
	UNLOCK_IODB,			! unlock I/O database
	IOC$DISMOUNT	: IOC_DISMOUNT ADDRESSING_MODE (GENERAL);
					! system dismount routine


! Get the device characteristics and make sure it can be dismounted at all.
! i.e., that it is file oriented, etc. A mismatch between primary and
! secondary device characteristics indicates a spooled device or something
! else strange - reject it if so.
!

DEVCHAR_DESC[DSC$B_CLASS]	= 0;	! set up primary characteristics buffer descriptor
DEVCHAR_DESC[DSC$B_DTYPE]	= 0;
DEVCHAR_DESC[DSC$W_LENGTH]	= DEVCHAR_SIZE;
DEVCHAR_DESC[DSC$A_POINTER]	= DEVICE_CHAR;

DEVCHAR_DESC2[DSC$B_CLASS]	= 0;	! set up secondary characteristics buffer descriptor
DEVCHAR_DESC2[DSC$B_DTYPE]	= 0;
DEVCHAR_DESC2[DSC$W_LENGTH]	= DEVCHAR_SIZE;
DEVCHAR_DESC2[DSC$A_POINTER]	= DEVICE_CHAR2;

$GETCHN (CHAN = .CHANNEL, PRIBUF = DEVCHAR_DESC, SCDBUF = DEVCHAR_DESC2);

IF CH$NEQ (DEVCHAR_SIZE, DEVICE_CHAR, DEVCHAR_SIZE, DEVICE_CHAR2, 0)
OR NOT .DEVICE_CHAR[DEV$V_FOD]
THEN RETURN (SS$_NOTFILEDEV);

IF NOT .DEVICE_CHAR[DEV$V_AVL]
THEN RETURN (SS$_DEVOFFLINE);

IF NOT .DEVICE_CHAR[DEV$V_MNT] OR .DEVICE_CHAR[DEV$V_DMT]
THEN RETURN (SS$_DEVNOTMOUNT);


! Get the UCB and VCB addresses for the channel. If this is a volume set also
! get the RVT address; for a disk volume set we will iterate for all volumes
! (provided /UNIT was not specified). First we search the process mounted volume
! list for entries of the volume; if found, we remove them and proceed with the
! dismount. If none were found, we try the system mounted volume list for
! volumes mounted /GROUP or /SYSTEM. Dismounting these requires the appropriate
! privilege.
!
CCB = .CTL$GL_CCBBASE - .CHANNEL;
UCB = .CCB[CCB$L_UCB];
VCB = .UCB[UCB$L_VCB];
PRIVATE = 0;
RVT = 0;
RVT_LENGTH = 0;
MAGTAPE = .BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_SQD];
CLUSTER_DEVICE = .BBLOCK [UCB [UCB$L_DEVCHAR2], DEV$V_CLU]; ! Save cluster device characteristic bit

IF NOT .BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_FOR]
AND ((.VCB[VCB$W_RVN] NEQ 0 AND NOT .FLAGS [DMT$V_UNIT])
    OR .MAGTAPE
    )
THEN
    BEGIN
    RVT = .VCB[VCB$L_RVT];
    RVT_LENGTH = .RVT[RVT$B_NVOLS];
    END;

STATUS = CHECK_PRIV (.UCB, .FLAGS);	! check privilege
IF NOT .STATUS THEN RETURN (.STATUS);	! if failed, return immediately

SETUP_MTL (.UCB,.FLAGS);		! set up local mounted volume database

LIST_HEAD = CTL$GQ_MOUNTLST[0];		! point to local mounted volume database



WHILE 1 DO				! loop forever	

BEGIN

DECR K FROM 2 TO 1 DO			! loop for process, then system mount list
    BEGIN
    J = 0;

    DO					! loop for all entries in RVT
	BEGIN
	IF .RVT NEQ 0
	THEN UCB = .VECTOR [RVT[RVT$L_UCBLST], .J];

	IF .UCB NEQ 0
	THEN
	    BEGIN
	    VCB = .UCB[UCB$L_VCB];
	    !
	    ! Note: With job-wide mount support, the check below is no longer
	    ! appropriate. With job-wide mount, any process in the process
	    ! tree can mount/dismount the volume. In a private mount, the 
	    ! device is allocated to the parent process, and a subprocess
	    ! should be able to dismount the volume.
	    !
	    ! IF .BBLOCK[UCB[UCB$L_DEVCHAR], DEV$V_ALL]
	    ! AND .UCB[UCB$L_PID] NEQ .SCH$GL_CURPCB[PCB$L_PID]
	    ! THEN RETURN (SS$_DEVALLOC);
	    !
	    LOCK_IODB ();
	    MTL = SEARCH_MOUNT (.LIST_HEAD, .UCB);
	    IF .MTL NEQ 0
	    THEN
		BEGIN

		IF NOT .K		! if first pass (private list)
		THEN
		    BEGIN
		    PRIVATE = 1;
		    END

		ELSE			! if second pass (system list)
		    BEGIN
!
! Clear the /SYSTEM or /GROUP bits to correctly show residual /SHARE mounts.
!

		    VCB[VCB$V_GROUP] = 0;
		    VCB[VCB$V_SYSTEM] = 0;
		    END;

! Having passed all the checks, take the MTL entry out of the list and call
! the system dismount routine with it.
!

		REMQUE (.MTL, MTL);
		UNLOCK_IODB ();
		DISMOUNT_AUDIT (.FLAGS, .CHANNEL, .UCB, .MTL);
		IOC$DISMOUNT (.MTL, .FLAGS[DMT$V_NOUNLOAD], .SCH$GL_CURPCB);

! On RVN 1 of a disk volume set, there are two MTL entries. Find and process
! the second.
!

		IF .J EQL 0
		AND (.RVT NEQ 0 OR .FLAGS[DMT$V_UNIT])
		AND NOT .MAGTAPE
		THEN
		    BEGIN
		    LOCK_IODB ();
		    MTL = SEARCH_MOUNT (.LIST_HEAD, .UCB);
		    IF .MTL NEQ 0
		    THEN
			BEGIN
			REMQUE (.MTL, MTL);
			UNLOCK_IODB ();
			IOC$DISMOUNT (.MTL, .FLAGS[DMT$V_NOUNLOAD], .SCH$GL_CURPCB);
			END
		    ELSE
			UNLOCK_IODB ();
		    END;
		END

! If normal dismount, failure to find an MTL entry on the second pass is an error.
! If a forced dismount, keep looping for more MTL entries.

	    ELSE
		BEGIN
		UNLOCK_IODB ();
		IF .K  AND NOT .FLAGS [DMT$V_ABORT]
		THEN RETURN (SS$_DEVNOTMOUNT);
		END;

! We exit the RVT scan loop if this is magtape or a single disk volume.
!

	    IF .MAGTAPE
	    OR .RVT EQL 0
	    THEN EXITLOOP;

	    END;			! end of UCB NEQ 0 condition

	J = .J + 1;
	END				! end of RVT scan loop
    UNTIL .J GEQU .RVT_LENGTH;

! If any entries were found in the process mounted volume list, we are now
! done. If not, go back to try the whole volume set against the system list.
!

    IF NOT .PRIVATE
    THEN
	BEGIN
	IF .MAGTAPE
	THEN RETURN (SS$_DEVNOTMOUNT);
	END
    ELSE
	IF NOT .FLAGS [DMT$V_ABORT] THEN EXITLOOP; ! If normal dismount, get out
					! for forced dismount, keep looping


    LIST_HEAD = IOC$GQ_MOUNTLST[0];	! switch to system-wide mount list

    END;				! end of private/system scan loop


IF NOT .FLAGS [DMT$V_ABORT] 		! If normal dismount, get out
THEN EXITLOOP				
ELSE
    IF .CTL$GQ_MOUNTLST[1] EQL CTL$GQ_MOUNTLST[0] 
    THEN EXITLOOP;			! for forced dismount, if mount list
					! is empty, exit while loop

!
! Reinitialize critical variables for another iteration for forced dismount
!
UCB = .CCB[CCB$L_UCB];			! reinitialize UCB address
PRIVATE = 0;				! and privately mounted flag

LIST_HEAD = CTL$GQ_MOUNTLST[0];		! point to local mounted volume database


END;					! forever loop


RETURN 1;

END;					! end of routine MAKE_DISMOUNT

ROUTINE TRAN_LOGNAME (LOG_NAME, RESULT)  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs simple recursive logical name translation.
!
!
! CALLING SEQUENCE:
!	TRAN_LOGNAME (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: descriptor of logical name to translate
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	ARG2: descriptor of result string buffer
!		(first word receives length of result)
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL	: The translation was a success
!	SS$_NONLOCAL	: The device is not local to the host machine
!	SS$_NOTRAN	: The logical name did not translate
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	LOG_NAME	: REF BBLOCK,	! logical name descriptor
	RESULT		: REF BBLOCK;	! result string descriptor

LOCAL
	NAME_DESC	: BBLOCK [DSC$K_S_BLN],	! descriptor of current logical name string
	STATUS,				! system service status
	P;				! string search pointer

! We iterate on logical name translation until the service returns SS$_NOTRAN.
! Perform device name extraction by using only the part of the logical name to
! the left of the colon (if any), also checking for node names.
!

NAME_DESC[DSC$W_LENGTH] = .LOG_NAME[DSC$W_LENGTH];	! get initial logical name
NAME_DESC[DSC$A_POINTER] = .RESULT[DSC$A_POINTER];
CH$COPY	(.LOG_NAME[DSC$W_LENGTH],			! copy input to output
	 .LOG_NAME[DSC$A_POINTER],
	 0,
	 .RESULT[DSC$W_LENGTH],
	 .RESULT[DSC$A_POINTER]
	);

IF BEGIN
DECR N FROM LNM$C_MAXDEPTH TO 1 DO
    BEGIN
    P = CH$FIND_CH (.NAME_DESC[DSC$W_LENGTH], .NAME_DESC[DSC$A_POINTER], ':');
    IF NOT CH$FAIL (.P)
    THEN
	BEGIN
	IF .P - .NAME_DESC[DSC$A_POINTER] LSSU .NAME_DESC[DSC$W_LENGTH] - 1
	AND .(.P)<0,16> EQL '::'
	THEN RETURN (SS$_NONLOCAL);
	NAME_DESC[DSC$W_LENGTH] = .P - .NAME_DESC[DSC$A_POINTER];
	END;

    IF CH$RCHAR (.NAME_DESC[DSC$A_POINTER]) EQL '_'
    THEN EXITLOOP 0;

    STATUS = $TRNLOG (LOGNAM = NAME_DESC[DSC$W_LENGTH],
		      RSLLEN = NAME_DESC[DSC$W_LENGTH],
		      RSLBUF = RESULT[DSC$W_LENGTH]);
    IF .STATUS EQL SS$_NOTRAN THEN EXITLOOP 0;
    IF NOT .STATUS THEN RETURN (.STATUS);
    END
END
THEN RETURN (SS$_NOTRAN);

! Return the result length.
! The high-order word in the first longword of the result descriptor
! is zeroed to allow a more relaxed interpretation of the descriptor.
!

RESULT[DSC$B_DTYPE]  = 0;
RESULT[DSC$B_CLASS]  = 0;
RESULT[DSC$W_LENGTH] = .NAME_DESC[DSC$W_LENGTH];

RETURN SS$_NORMAL;
END;					! end of routine TRAN_LOGNAME

ROUTINE SEARCH_MOUNT (MTL_HEAD, UCB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches the given mounted volume list for the entry
!	representing the indicated UCB.
!
!
! CALLING SEQUENCE:
!	SEARCH_MOUNT (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of mounted volume list head
!	ARG2: address of desired UCB
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	address of entry or 0
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	MTL_HEAD	: REF VECTOR,	! mounted volume list head
	UCB		: REF BBLOCK;	! desired UCB

LOCAL
	MTL		: REF BBLOCK;	! list entry in question


! Simply scan through the doubly linked list, checking consistency as we go.
!

MTL = .MTL_HEAD[0];

UNTIL .MTL EQL MTL_HEAD[0] DO
    BEGIN
    IF .MTL[MTL$B_TYPE] NEQ DYN$C_MTL
    THEN BUG_CHECK (NOTMTLMTL, FATAL, 'Corrupted mounted volume list');
    IF .MTL[MTL$L_UCB] EQL .UCB THEN RETURN .MTL;
    MTL = .MTL[MTL$L_MTLFL];
    END;

RETURN 0;

END;					! end of routine SEARCH_MOUNT




ROUTINE SETUP_MTL ( UCB, FLAGS ) = 

!+
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets up a local mounted volume database by collecting
!	the appropriate mount list entries (MTLs) from the system's mounted
!	database.
!
! CALLING SEQUENCE:
!	SETUP_MTL (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1	: Address of the desired UCB
!	ARG2	: A longword bit mask
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	Appropriate MTLs in the system are removed from the system's
!	mount database and inserted into the local mounted volume
!	database.
!
!-	

BEGIN

MAP
    UCB		: REF BBLOCK,
    FLAGS	: BBLOCK;

LOCAL
    PIX,				! process index counter
    LIST_HEAD	: REF BBLOCK,		! local mount listhead
    MTL		: REF BBLOCK,		! variable for MTL
    NULL	: REF BBLOCK,		! PCB of the null process
    PCB		: REF BBLOCK,		! variable for PCB
    JIB		: REF BBLOCK;		! variable for JIB

EXTERNAL
    SCH$GL_PCBVEC : REF VECTOR ADDRESSING_MODE (GENERAL),
					! PCB vector
    SCH$GL_CURPCB : REF BBLOCK ADDRESSING_MODE (GENERAL),
					! address of current PCB
    SCH$GL_MAXPIX : ADDRESSING_MODE (GENERAL);
					! max number of processes

EXTERNAL ROUTINE
    LOCK_IODB,	
    UNLOCK_IODB;


IF .FLAGS [DMT$V_ABORT]				
THEN					! for dismount /abort
    BEGIN
    ! 
    ! Set up the local MTL database
    !
    NULL = .SCH$GL_PCBVEC [0]; 		! remeber pcb of the null process
    LOCK_IODB ();			! lock I/O database
    INCR PIX FROM 1 TO .SCH$GL_MAXPIX	! look thru each process in system
    DO
        BEGIN
	SET_IPL (IPL$_SYNCH);		! raise IPL 
	IF (( PCB = .SCH$GL_PCBVEC [.PIX] ) NEQ .NULL ) ! non-null process
	AND ( .PCB [PCB$L_OWNER] EQL 0 )		! master process
	AND (( JIB = .PCB [PCB$L_JIB] ) NEQ 0 )		! forget the swapper
	AND (.JIB [JIB$L_MTLBL] NEQ JIB [JIB$L_MTLFL] ) ! something in mountlist
	THEN
	    BEGIN
	    ! 
	    ! Note that at this point, we have a JIB with at least one volume
	    ! mounted. Lower the IPL to ASTDEL since MTLs are located in
	    ! paged-pool. We can safely do this because the existence of
	    ! an MTL entry means that this process will not be deleted
	    ! until we give up the I/O database mutex.
	    !
	    SET_IPL (IPL$_ASTDEL);	! lower IPL to ASTDEL since we
					! still have the I/O database mutex
	    LIST_HEAD = JIB [JIB$L_MTLFL];
	    DO				! now loop until we have all MTLs for
		MTL = MOVE_MTL ( .LIST_HEAD, .UCB, .FLAGS ) ! this process
	    UNTIL ( .MTL EQL 0 );
	    END;	
        END;				! end for loop
    UNLOCK_IODB ();			! unlock I/O databse
    END					! of dismount abort setup
ELSE				
    BEGIN				! normal dismount path        	
    JIB = .SCH$GL_CURPCB [PCB$L_JIB];	! get our JIB address
    LIST_HEAD = JIB [JIB$L_MTLFL];	! get job-wide mount listhead
    LOCK_IODB ();			! lock I/O database
    MTL = MOVE_MTL ( .LIST_HEAD, .UCB, .FLAGS ); ! set up local MTL database
    UNLOCK_IODB ();			! unlock I/O database
    END;				! of normal dismount setup

RETURN 1;

END;					! of routine SETUP_MTL






ROUTINE MOVE_MTL ( LIST_HEAD, UCB, FLAGS ) =

!+
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is an envolope to set up the local mounted
! 	volume database by calling a routine to move each MTL entry.
!	If the requested UCB is a member of the volume set, 
!	then this routine iterates over the entire volume set, 
!	unless the DMT$V_UNIT flag is specified.
!
! CALLING SEQUENCE:
!	MOVE_MTL (ARG1, ARG2,ARG3)
!
! INPUT PARAMETERS:
!	ARG1	: Address of a mount listhead
!	ARG2	: Address of the desired UCB
!	ARG3	: A longwork bit mask
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! ROUTINE VALUE:
!	0  : If no MTL entry is found for the desired UCB
!	1  : If an MTL entry is successfully set up in the local database
!
!
! SIDE EFFECTS:
!	Appropriate MTLs in the system are removed from the mount database 
!	and inserted into the local mounted volume database.
!
!-

BEGIN

MAP
    LIST_HEAD 	: REF BBLOCK,
    UCB		: REF BBLOCK,
    FLAGS	: BBLOCK;

LOCAL
    MAGTAPE,				! magtape indicator
    J,					! loop counter
    VCB		: REF BBLOCK,		! address of VCB
    RVT		: REF BBLOCK,		! address of RVT
    RVT_LENGTH	: REF BBLOCK,		! length of RVT
    MTL		: REF BBLOCK,		! local variable for MTL
    LUCB	: REF BBLOCK,		! local variable for UCB
    VAL		: REF BBLOCK;		! local variable for MTL

    
MAGTAPE = .BBLOCK [UCB [UCB$L_DEVCHAR], DEV$V_SQD]; ! magtape flag
VCB = .UCB [UCB$L_VCB];			! get VCB address

IF NOT .BBLOCK [UCB[UCB$L_DEVCHAR], DEV$V_FOR]
AND ((.VCB[VCB$W_RVN] NEQ 0 AND NOT .FLAGS [DMT$V_UNIT])
    OR .MAGTAPE
    )
THEN

    BEGIN				! process a volume set
    RVT = .VCB [VCB$L_RVT];		! get RVT address
    RVT_LENGTH = .RVT [RVT$B_NVOLS];	! get number of volumes
    MTL = 0;
    J = 0;
    DO
	BEGIN				! loop for each volume in RVT
	LUCB = .VECTOR [RVT [RVT$L_UCBLST], .J]; ! get UCB address
	IF .LUCB NEQ 0			! if UCB still mounted 
	THEN
	    BEGIN
	    IF ( VAL = FIND_MTL ( .LIST_HEAD, .LUCB ) NEQ 0 )
	    THEN MTL = .VAL;
	    IF .J EQL 0 		! RVN 1 of a volume set, there
	    THEN			! are two MTL entries
		IF ( VAL = FIND_MTL ( .LIST_HEAD, .LUCB ) NEQ 0 )
	        THEN MTL = .VAL;
	    END;			! end of UCB eql 0 condition
	J = .J + 1;			! bump index
	END
    UNTIL  .J GEQU .RVT_LENGTH;		! 
    END					! of volume set processing

ELSE					

    MTL = FIND_MTL ( .LIST_HEAD, .UCB );  ! single volume, find one MTL

RETURN .MTL;

END;					! routine MOVE_MTL




ROUTINE FIND_MTL ( LIST_HEAD, UCB ) = 

!+
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches the mount list entries (MTLs) in the
!	given listhead for a given UCB. If an entry is found, it
!	is removed from the list and inserted into the local
!	MTL database.
!
!	Note: This routine must be called with the I/O database locked,
!	i.e. it assumes the calling routine has locked the I/O database
!	mutex.
!
! CALLING SEQUENCE:
!	FIND_MTL (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1	: Address of the mounted volume listhead
!	ARG2	: Address of the desired UCB
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! ROUTINE VALUE:
!	0	: If no MTL entry is found
!	1	: Address of the MTL entry
!
! SIDE EFFECTS:
!	One MTL entry for the desired UCB is removed from the mount 
!	database and inserted into the local mounted volume database.
!
!-

BEGIN

MAP
    LIST_HEAD	: REF BBLOCK,		! mount listhead
    UCB		: REF BBLOCK;		! UCB address

LOCAL
    LOCAL_MOUNTLST  : REF BBLOCK,	! local mount listhead
    MTL		    : REF BBLOCK;	! local variable for MTL

BUILTIN
    INSQUE,
    REMQUE;

EXTERNAL
    CTL$GQ_MOUNTLST : VECTOR ADDRESSING_MODE (GENERAL);


MTL = SEARCH_MOUNT ( .LIST_HEAD, .UCB );  ! search for MTL
IF .MTL NEQ 0				! found one
THEN	
    BEGIN
    LOCAL_MOUNTLST = CTL$GQ_MOUNTLST [1]; ! set up local MTL listhead
    REMQUE ( .MTL, MTL );		! remove from old mountlist
    INSQUE ( .MTL, ..LOCAL_MOUNTLST);	! insert into local mountlist
    END;				! done for this MTL

RETURN .MTL;

END;					! of routine FIND_MTL




ROUTINE CHECK_PRIV ( UCB, FLAGS ) = 

!+
!
! FUNCTIONAL DESCRIPTION:
!
! 	This routine performs the privilege checks for the attempted
!	dismount operation.
!
! CALLING SEQUENCE:
!	PRIV_CHECK (ARG1,ARG2)
!
! INPUT PARAMETER:
!	ARG1: Address of the desired UCB
!	ARG2: A longword bit mask
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE CALUES:
!	SS$_NORMAL	: Success
!	SS$_NOPRIV	: No privilege for attempted operation
!	SS$_NOGRPNAM	: Operation requires GRPNAM privilege
!	SS$_NOSYSNAM	: Operation requires SYSNAM privilege
!	DISM$_SYSDEV	: Attempt to dismount the system disk
!
! SIDE EFFECTS:
! 	NONE
!
!-

BEGIN

MAP
    UCB		: REF BBLOCK,
    FLAGS	: BBLOCK;

LOCAL
    LIST_HEAD	: REF BBLOCK,		! local mount listhead
    MTL		: REF BBLOCK,		! variable for MTL
    VCB		: REF BBLOCK,		! VCB
    ORB		: REF BBLOCK,		! ORB
    JIB 	: REF BBLOCK,		! address of the JIB
    PRIVILEGE_MASK : REF BBLOCK,	! process privilege mask
    UIC;				! process UIC

EXTERNAL
    IOC$GQ_MOUNTLST	: VECTOR ADDRESSING_MODE (GENERAL),
					! system-wide mount list
    CTL$GL_PHD		: REF BBLOCK ADDRESSING_MODE (GENERAL),
					! address of process header
    EXE$GL_SYSUCB 	: REF BBLOCK ADDRESSING_MODE (GENERAL),
					! address of system device UCB
    SCH$GL_CURPCB 	: REF BBLOCK ADDRESSING_MODE (GENERAL);
					! address of current PCB

EXTERNAL ROUTINE
    LOCK_IODB,		
    UNLOCK_IODB,
    LOCK_LNM,
    UNLOCK_LNM;


!
! If this UCB is mounted by the current process and this is a normal
! dismount request, we immediately return without further privilege
! checks.
!
! If this is a dismount /abort or /cluster request, then there are three 
! seperate checks:
!
! 1. If the volume is mounted /system, the dismounter must have SYSNAM
!    privilege.
!
! 2. If the volume is mounted /group, the dismounter must:
!	a. have SYSNAM privilege, or
!       b. be in the same group with GRPNAM privilege.
!
! 3. If neither, then the dismounter must have the same owner UIC as the
!    device, or have VOLPRO privilege.
!


IF NOT (  .FLAGS [DMT$V_ABORT] 
       OR .FLAGS [DMT$V_CLUSTER] )	! if normal dismount
THEN
    BEGIN
    JIB = .SCH$GL_CURPCB [PCB$L_JIB];	! get the JIB of current process
    LIST_HEAD = JIB [JIB$L_MTLFL];	! point to our job-wide mount list head
    LOCK_IODB ();		
    MTL = SEARCH_MOUNT ( .LIST_HEAD, .UCB ); ! see if volume is privately mounted
    UNLOCK_IODB ();
    IF ( .MTL NEQ 0 ) 
    THEN				! normal dismount of a privately mounted volume
        RETURN 1;			! return immediately
    END;	

PRIVILEGE_MASK = CTL$GL_PHD [PHD$Q_PRIVMSK]; ! Get process privilege mask
VCB = .UCB [UCB$L_VCB];			! get VCB
LIST_HEAD = IOC$GQ_MOUNTLST[0];		! search system wide list 

LOCK_IODB ();				! lock I/O database
MTL = SEARCH_MOUNT ( .LIST_HEAD, .UCB );

IF .MTL EQL 0 				! if not mounted system or group
THEN					! check proper privilege

    BEGIN
    ORB = .UCB[UCB$L_ORB];		! get ORB address
    UNLOCK_IODB ();			! unlock I/O database
    UIC = .SCH$GL_CURPCB [PCB$L_UIC];	! get process UIC	
    IF   ( .FLAGS [DMT$V_ABORT] )	! check privilege
    AND  ( .UIC NEQ .ORB [ORB$L_OWNER] )
    AND  ( NOT .PRIVILEGE_MASK [PRV$V_VOLPRO] )
        THEN
	RETURN SS$_NOPRIV;		! no privilege to dismount /abort
    END

ELSE
    !
    ! If this is a disk mounted /GROUP, the dismounter must be in the group 
    ! that mounted the disk, or have SYSNAM privilege.
    !
    BEGIN

    IF .VCB[VCB$V_GROUP]		! volume mounted /group
    THEN
	BEGIN
	IF NOT (
	    .PRIVILEGE_MASK[PRV$V_SYSNAM]
	    OR (.PRIVILEGE_MASK[PRV$V_GRPNAM]
		AND (IF .MTL[MTL$L_LOGNAME] NEQ 0
		    THEN
			(LOCAL
			    LNMB     : REF BBLOCK,
			    LNMTH    : REF BBLOCK,
			    ORB      : REF BBLOCK,
			    FULL_UIC : LONG;
			LOCK_LNM();
			LNMB     = .MTL[MTL$L_LOGNAME];
			LNMTH	 = .LNMB[LNMB$L_TABLE];
			ORB	 = .LNMTH[LNMTH$L_ORB];
			FULL_UIC = .ORB[ORB$L_OWNER];
			UNLOCK_LNM();
			.FULL_UIC <16,16>
				EQL .SCH$GL_CURPCB[PCB$W_GRP]
			)
		    ELSE 1)
		)
	    )
   	THEN
	    BEGIN
	    UNLOCK_IODB ();
	    RETURN (SS$_NOGRPNAM);
	    END;
	END
    ELSE 
	IF .VCB[VCB$V_SYSTEM]		! volume mounted /system
	THEN
	    IF NOT .PRIVILEGE_MASK[PRV$V_SYSNAM]
	    THEN
		BEGIN
		UNLOCK_IODB ();
 	        RETURN (SS$_NOSYSNAM);
		END;		

    UNLOCK_IODB ();			! unlock I/O database
    IF .UCB EQL .EXE$GL_SYSUCB		! check for dismount of system device
    THEN
        RETURN (DISM$_SYSDEV);

    END;				! mounted /GROUP or /SYSTEM checks


RETURN 1;

END;					! routine CHECK_PRIV




ROUTINE DISMOUNT_CLUSTER (DEV_NAME, FLAGS) =		

!+
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the cluster-wide dismount operation.
!	It calls another routine to create a cluster-dismount packet 
!	and then sends this dismount request to other nodes in the 
!	cluster.
!
! CALLING SEQUENCE:
!
!	DISMOUNT_CLUSTER (ARG1,ARG2)
!
! INPUTS:
!
!	ARG1	: Address of the device descriptor
!	ARG2	: A longword bit mask
! 
! OUTPUTS:
!
!	None.
! 
! IMPLICIT INPUTS:
!	
!	None.
!
! OUTPUT PARAMETERS:
!
!	1	  : If success
!	Otherwise : Status from comm primitive.
!
! IMPLICIT OUTPUTS:
!	
!	None.
!
! ROUTINE VALUE:
!
!	None.
!
! SIDE EFFECTS:
!
!	The dismount request is sent to other nodes in the cluster.
! 
!-


BEGIN						! Start of DISMOUNT_CLUSTER

MACRO	ITEM_LENG =  0,0,16,0%;			! Define item list offsets
MACRO	ITEM_CODE =  2,0,16,0%;
MACRO	ITEM_ADDR =  4,0,32,0%;
MACRO	ITEM_LADR =  8,0,32,0%;
MACRO	ITEM_STOP = 12,0,32,0%;			! Item list stopper
LITERAL	ITEM_SIZE = 16;

LITERAL BUF_SIZE  = DSC$K_S_BLN + NAMEBUF_LEN + 4; ! Define cluster-dismount buffer size


MAP
	DEV_NAME	: REF BBLOCK,
	FLAGS  		: BBLOCK;

EXTERNAL ROUTINE
	IN_CLUSTER,
	SEND_CLUSTER;

LOCAL
	STATUS,
	LENGTH,					
	BUFFER		: BBLOCK [BUF_SIZE], 	! Buffer area

	ITEM		: BBLOCK [ITEM_SIZE],	! Item list for $GETDVI
	FUL_DEV_DSC	: BBLOCK[DSC$K_S_BLN],	! Descriptor for full device name
	FUL_DEV_STR	: VECTOR[NAMEBUF_LEN,BYTE]; ! Full device name


IF ( NOT (.FLAGS [DMT$V_CLUSTER] ))		! If not /cluster 
OR ( NOT  .CLUSTER_DEVICE )			! or not a cluster device
OR NOT ( STATUS = IN_CLUSTER() )		! or not in a cluster environment
THEN						! return immediately
   RETURN 1;

FLAGS [DMT$V_CLUSTER] = 0;			! Clear cluster-wide flag
LENGTH = 0;					! Initialize work area
CH$FILL (0, BUF_SIZE, BUFFER); 			! Zero buffer area

ITEM [ITEM_LENG] = NAMEBUF_LEN;			! Set up item descriptor to
ITEM [ITEM_CODE] = DVI$_FULLDEVNAM;		! get full device name
ITEM [ITEM_ADDR] = FUL_DEV_STR;			! ...
ITEM [ITEM_LADR] = LENGTH;
ITEM [ITEM_STOP] = 0;				! End of item list

!
! Since the dismount request will be sent to other nodes in the cluster, we
! must use the full device name. Obtain the full device name. 
!
STATUS = $GETDVIW ( EFN    = MOUNT_EFN,
		    DEVNAM = .DEV_NAME, 
		    ITMLST = ITEM ); 		! Get full device name
IF NOT .STATUS 					! If error, return
THEN
    RETURN .STATUS;

FUL_DEV_DSC [DSC$W_LENGTH] = .LENGTH;		! Create a descriptor for the
FUL_DEV_DSC [DSC$A_POINTER] = FUL_DEV_STR;	! full device name

STATUS = DISMOUNT_ENCIPHER (FUL_DEV_DSC, .FLAGS, BUFFER, LENGTH); ! Encipher the dismount request
IF NOT .STATUS 					! If error, return
THEN 
    RETURN .STATUS;				

STATUS = SEND_CLUSTER (BUFFER, .LENGTH, 0);	! Broadcast the request
						! Arg3=0 means a cluster-dismount

RETURN .STATUS;
	
END;						! End of DISMOUNT_CLUSTER




ROUTINE DISMOUNT_ENCIPHER (DEV_DSC, FLAGS, BUFFER, LENGTH) =

!+
!
! FUNCTIONAL DESCRIPTION:
!
! 	This routine takes the parameters of the dismount request
!	and enciphers the parameters into a cluster-dismount packet.
!
! CALLING SEQUENCE:
!
!	DISMOUNT_ENCIPHER (ARG1,ARG2,ARG3,ARG4)
! 
! INPUTS:
!
!	ARG1	: Address of the device descriptor
!	ARG2	: A longword bit mask
!
! OUTPUTS:
!
!	ARG3	: Address of the output buffer to receive the
!		    cluster-dismount packet
!	ARG4	: Address of a longword to receive the length of 
!		    the output buffer
!
! IMPLICIT INPUTS:
!
!	None.
!
! OUTPUT PARAMETERS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUES:
!
!	1	      : If successful
!	SS$_BUFFEROVF : Insufficient internal buffer space
!
! SIDE EFFECTS:
!
!	None.
!
!
! NOTES:
!
! This encipher routine takes the given device descriptor and turns it
! into a cluster-dismount packet of the form:
!
!			      Offset
!	+---------------+	
!	|     flags	|  0  BUF_FLAGS
!	+---------------+	
!	| dev descrptor |  4  BUF_DSC
!	+---------------+	
!	|		|  8
!	+---------------+	
!	| device string | 12  BUF_STR
!	+---------------+	
!	|    ...	|
!	+---------------+	
!
! 	1. This cluster-dismount packet is to be sent to other nodes in
!	   the cluster and processed by CSP (the Cluster Server Process).
!
!	2. The address in the device descriptor is "relocated" to be the 
!	   offset from the beginning of the packet (i.e. self-relative). 
!	   This is done for consistency's sake with the cluster-mount packets.
!
!-


BEGIN						! Start of DISMOUNT_ENCIPHER

MAP	
	DEV_DSC	: REF BBLOCK,
	BUFFER	: REF BBLOCK;

LOCAL
	LOC_DSC	: REF BBLOCK;

	
MACRO BUF_FLAG	 =  0,0,32,0%;			! Define buffer offsets
MACRO BUF_DSC	 =  4,0,32,0%;
MACRO BUF_STR	 = 12,0,32,0%;
LITERAL BUF_HDR_LEN = 12;


IF (.DEV_DSC [DSC$W_LENGTH]  GTRU NAMEBUF_LEN)	! Check if internal buffer large
THEN 						! enough
    RETURN SS$_BUFFEROVF;			! If not, return error

.LENGTH = BUF_HDR_LEN + .DEV_DSC[DSC$W_LENGTH];	! Compute length of output,
						! including parameters
BUFFER[BUF_FLAG] = .FLAGS;			! Set flags in buffer
LOC_DSC = BUFFER[BUF_DSC];			! 			

!
! Copy the device descriptor into the output buffer
!
CH$COPY (DSC$K_S_BLN,
	 .DEV_DSC,
	 0,
	 DSC$K_S_BLN,
	 BUFFER[BUF_DSC]);

LOC_DSC[DSC$A_POINTER] = BUF_HDR_LEN;		! "Relocate" the string pointer

!
! Copy the device string into the output buffer
!
CH$COPY (.DEV_DSC[DSC$W_LENGTH],
	 .DEV_DSC[DSC$A_POINTER],
	 0,
	 .DEV_DSC[DSC$W_LENGTH],
	 BUFFER[BUF_STR]);

RETURN 1;
END;						! End of DISMOUNT_ENCIPHER



ROUTINE DISMOUNT_AUDIT (FLAGS, CHANNEL, UCB, MTL): NOVALUE = 

!+
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines if a security auditing packet should
!	be logged. If so, it creates the security auditing packet and
!	logs the event.
!
! CALLING SEQUENCE:
!
!	DISMOUNT_AUDIT (ARG1,ARG2,ARG3)
! 
! INPUTS:
!
!	ARG1	: A longword bit mask
!	ARG2	: The channel number of the channel assigned to the device
!	ARG3	: Address of the desired UCB
!	ARG4	: Address of the mount list entry
!
! OUTPUTS:
!
!	None.
!
! IMPLICIT INPUTS:
!
!	None.
!
! OUTPUT PARAMETERS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUES:
!
!	None.
!
! SIDE EFFECTS:
!
!	If security auditing is enabled, then create a security auditing
!	packet and log this event.	
!
!-


BEGIN						! Start of DISMOUNT_AUDIT

MAP	
	FLAGS	: BBLOCK,
	UCB	: REF BBLOCK,
	MTL	: REF BBLOCK;

BUILTIN
	CALLG;

EXTERNAL
	SCH$GL_CURPCB 	: REF BBLOCK ADDRESSING_MODE (GENERAL),
						! address of current PCB
	NSA$GR_ALARMVEC	: BBLOCK ADDRESSING_MODE (GENERAL),
						! Alarm enable bit vector
	NSA$GR_JOURNVEC	: BBLOCK ADDRESSING_MODE (GENERAL);
						! Journal enable bit vector

LINKAGE
	ARGLST_IMGNAM	= JSB (REGISTER = 2;) :
			  NOPRESERVE (0,1)
			  NOTUSED (3,4,5,6,7,8,9,10,11);

EXTERNAL ROUTINE
	NSA$EVENT_AUDIT	: ADDRESSING_MODE (GENERAL),
						! Security auditing routine
	NSA$ARGLST_IMGNAM : ARGLST_IMGNAM ADDRESSING_MODE (GENERAL);
						! Insert IMGNAM into ARGLST

PSECT
	PLIT	= Z$DISMOUNT;			! Define PLITS in Z$DISMOUNT psect to
						! avoid truncation errors
LOCAL
	VCB	: REF BBLOCK,			! Address of the VCB
	RVT	: REF BBLOCK,			! Address of the RVT
	LNMB	: REF BBLOCK,			! Address of the LNMB
	ARGLIST	: BBLOCK[NSA$K_ARG3_LENGTH],
						! Security auditing argument list
	DEV_LEN	: INITIAL (0),			! Length of full device name
	DEV_STR	: VECTOR [LOG$C_NAMLENGTH], 	! Full device name buffer
	ITEM_LIST : BBLOCK [12+4] 
		      INITIAL			! Item list to get full device name
		      ( WORD (LOG$C_NAMLENGTH),	! Length of buffer
			WORD (DVI$_FULLDEVNAM),	! Get full device name
			LONG (DEV_STR),		! Full device name buffer address
			LONG (DEV_LEN),		! Length of full device name
			LONG (0) );		! Item list stopper


IF (.SCH$GL_CURPCB [PCB$V_SECAUDIT]
OR  .NSA$GR_ALARMVEC [NSA$V_EVT_MOUNT]
OR  .NSA$GR_JOURNVEC [NSA$V_EVT_MOUNT])
THEN
    BEGIN

    CH$FILL (0, NSA$K_ARG3_LENGTH, ARGLIST);	! Zero argument list

    !
    ! Set up the security auditing argument list header
    !

    ARGLIST [NSA$L_ARG_COUNT] = ( NSA$K_ARG3_LENGTH/4 ) - 4;
						! Initialize length of argument list
						! Less vol-set pkt and arg count
    ARGLIST [NSA$L_ARG_ID] = NSA$K_RECID_VOL_DMOU;
						! Initialize record id as dismount
    IF .SCH$GL_CURPCB [PCB$V_SECAUDIT]		! Set up proper flags
    THEN
	ARGLIST [NSA$V_ARG_FLAG_MANDY] = 1;	! Mandatory auditing
    IF .NSA$GR_ALARMVEC [NSA$V_EVT_MOUNT]
    THEN
	ARGLIST [NSA$V_ARG_FLAG_ALARM] = 1;	! Generate alarm for this record
    IF .NSA$GR_JOURNVEC [NSA$V_EVT_MOUNT]
    THEN
	ARGLIST [NSA$V_ARG_FLAG_JOURN] = 1;	! Journal this record

    ARGLIST [NSA$B_ARG_PKTNUM] = 5;		! Initialize number of items 
						! less vol-set pkt
    
    !
    ! Set up the security auditing argument list for dismount
    !

    ARGLIST [NSA$L_ARG3_DMOUFLG_TM] = NSA$K_ARG_MECH_WORD^16 + NSA$K_PKTTYP_DMOUFLG;
						! Note: set mech to word, OPCOM expects it
    ARGLIST [NSA$L_ARG3_DMOUFLG ] = .FLAGS;	! Set dismount flags

    NSA$ARGLST_IMGNAM (ARGLIST [NSA$L_ARG3_IMGNAM_TM]);	! Set image name

    ARGLIST [NSA$L_ARG3_DEVNAM_TM] = NSA$K_ARG_MECH_DESCR^16 + NSA$K_PKTTYP_DEVNAM;
    $GETDVIW  ( EFN    = MOUNT_EFN,
		CHAN   = .CHANNEL,		
		ITMLST = ITEM_LIST );		! Obtain full device name
    ARGLIST [NSA$L_ARG3_DEVNAM_SIZ] = .DEV_LEN;	! Set size of full device name 
    ARGLIST [NSA$L_ARG3_DEVNAM_PTR] = DEV_STR;	! Set full device name buffer address
	
    ARGLIST [NSA$L_ARG3_LOGNAM_TM] = NSA$K_ARG_MECH_DESCR^16 + NSA$K_PKTTYP_LOGNAM;
    LNMB = .MTL [MTL$L_LOGNAME];		! Get address of LNM block
    IF .LNMB NEQ 0				! If the LNM block exists
    THEN
 	BEGIN
	ARGLIST [NSA$L_ARG3_LOGNAM_SIZ] = .LNMB [LNMB$T_NAME];	! Set size of logical name
	ARGLIST [NSA$L_ARG3_LOGNAM_PTR] = LNMB [LNMB$T_NAME]+1; ! Set logical name buffer address
	END
    ELSE
	BEGIN
	ARGLIST [NSA$L_ARG3_LOGNAM_SIZ] = 0;	! Set size of logical name as null
	ARGLIST [NSA$L_ARG3_LOGNAM_PTR] = 0;	! Set logical name buffer address as null
	END;

    ARGLIST [NSA$L_ARG3_VOLNAM_TM] = NSA$K_ARG_MECH_DESCR^16 + NSA$K_PKTTYP_VOLNAM;
    VCB = .UCB [UCB$L_VCB];			! Get address of VCB
    ARGLIST [NSA$L_ARG3_VOLNAM_SIZ] = 
	LABEL_LENGTH (VCB$S_VOLNAME, VCB [VCB$T_VOLNAME]); ! Set size of volume name
    ARGLIST [NSA$L_ARG3_VOLNAM_PTR] = VCB [VCB$T_VOLNAME]; ! Set volume name buffer address

    !
    ! If the volume is a member of a volume set, then
    !    a. increment argument count
    !    b. increment number of packets
    !    c. set up volume set descriptor
    !
  
    IF (NOT .BBLOCK [UCB [UCB$L_DEVCHAR], DEV$V_FOR])
    AND  (  .VCB [VCB$W_RVN] NEQ 0 )
    THEN
        BEGIN
	ARGLIST [NSA$L_ARG_COUNT] = .ARGLIST [NSA$L_ARG_COUNT] + 3; ! Count vol-set pkt 
	ARGLIST [NSA$B_ARG_PKTNUM] = .ARGLIST [NSA$B_ARG_PKTNUM] + 1;
	ARGLIST [NSA$L_ARG3_VOLSNAM_TM] = NSA$K_ARG_MECH_DESCR^16 + NSA$K_PKTTYP_VOLSNAM;
	RVT = .VCB [VCB$L_RVT];			
	ARGLIST [NSA$L_ARG3_VOLSNAM_SIZ] = 
	    LABEL_LENGTH (RVT$S_STRUCNAME, RVT [RVT$T_STRUCNAME]); ! Set size of vol-set name
	ARGLIST [NSA$L_ARG3_VOLSNAM_PTR] = RVT [RVT$T_STRUCNAME];  ! Set vol-set name buffer address
	END;	    
   
    CALLG (ARGLIST, NSA$EVENT_AUDIT);		! Call event audit routine     

    END;					! End of security auditing block

RETURN;						! Back to caller
END;						! End of DISMOUNT_AUDIT



ROUTINE LABEL_LENGTH (STR_LENGTH, STR_TEXT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will return the length of a given string.
!	Trailing blanks at the end of the string are not counted
!	as part of the string.
!
! CALLING SEQUENCE:
!
!	LABEL_LENGTH (ARG1, ARG2)
!
! INPUT PARAMETERS:
!
!	ARG1	: Input string length
!	ARG2	: Input string address
!
! IMPLICIT INPUTS:
!
!	None.
!
! OUTPUT PARAMETERS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	None.
!
! SIDE EFFECTS:
!
!	None.
!
!--

BEGIN

MAP
	STR_TEXT	: REF VECTOR [,BYTE];	! Input string

LOCAL
	PTR		: LONG;			! Pointer to current char.

! Starting at the end of the string, decrement the string length
! until a nonblank character is found, or the beginning of the string
! is encountered.
!

PTR = .STR_LENGTH;
WHILE (.PTR GTR 0) AND (.STR_TEXT [.PTR-1] EQL %ASCII' ') DO
    PTR = .PTR - 1;

RETURN (.PTR)
END;

END
ELUDOM
