	.TITLE	SYSDCLEXH - SYSTEM SERVICES CANCEL AND DECLARE EXIT HANDLER
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; 	SYSTEM SERVICES CANCEL AND DECLARE EXIT HANDLER
;
; ENVIRONMENT:
;	MODE=KERNEL, PAGED CODE
;
; AUTHOR:	D. N. CUTLER	 CREATION DATE: 10-AUG-76
;
; MODIFIED BY:
;
;	V03-001	LJK0287		Lawrence J. Kenah	26-Jun-1984
;		Count the number of exit handlers declared for each mode for
;		use by $EXIT and $CANEXH.
;--

	.SUBTITLE	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
 
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
DESBLK=4				;EXIT CONTROL BLOCK ADDRESS
	.PAGE
	.SBTTL	CANCEL EXIT HANDLER
;+
; EXE$CANEXH - CANCEL EXIT HANDLER
;
; THIS SERVICE PROVIDES THE CAPABILITY TO DELETE AN EXIT CONTROL BLOCK OR
; ALL EXIT CONTROL BLOCKS FROM THE EXIT HANDLER LIST FOR THE CALLING ACCESS
; MODE.
;
; INPUTS:
;
;	DESBLK(AP) = ADDRESS OF EXIT CONTROL BLOCK (ZERO IMPLIES ALL).
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CANCEL EXIT HANDLER.
;
;		R0 = SS$_ACCVIO - FIRST LONGWORD OF EXIT CONTROL BLOCK
;			CANNOT BE READ BY THE CALLING ACCESS MODE, FIRST
;			LONGWORD OF A EXIT CONTROL BLOCK IN THE LIST CANNOT
;			BE READ BY THE CALLING ACCESS MODE, OR THE FIRST
;			LONGWORD OF THE PREVIOUS EXIT CONTROL BLOCK CANNOT
;			BE WRITTEN.
;
;		R0 = SS$_NOHANDLER - SPECIFIED HANDLER CANNOT BE FOUND IN
;			EXIT HANLDER CONTROL BLOCK LIST.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENABL	LSB
	.PSECT	Y$EXEPAGED
	.ENTRY	EXE$CANEXH,^M<R2,R3,R4,R5>
	BSBB	GETPARM			;GET EXIT CONTROL BLOCK PARAMETERS
	BEQL	25$			;IF EQL CANCEL ALL EXIT HANDLERS
	MOVL	R0,R2			;COPY ADDRESS OF LISTHEAD
	MOVL	(R4),R5			;GET COUNT FOR LOOP CONTROL
10$:	MOVL	R2,R3			;SAVE ADDRESS OF PREVIOUS ENTRY
	IFNORD	#4,(R3),50$		;CAN NEXT EXIT CONTROL BLOCK ADDRESS BE READ?
	MOVL	(R3),R2			;GET ADDRESS OF NEXT EXIT CONTROL BLOCK
	BEQL	60$			;IF EQL END OF LIST
	CMPL	R1,R2			;EXIT CONTROL BLOCK ADDRESS MATCH?
	BEQL	15$			;IF EQUAL, ADDRESSES MATCH
	SOBGEQ	R5,10$			;GO BACK FOR NEXT BLOCK IN LIST
	MOVZWL	#SS$_INVEXHLIST,R0	;REPORT INCONSISTENT LIST 
	RET				;RETURN FAILURE STATUS TO CALLER

15$:	IFNORD	#4,(R2),50$		;CAN NEXT EXIT CONTROL BLOCK ADDRESS BE READ?
	CMPL	R0,R3			;PREVIOUS EXIT CONTROL BLOCK LISTHEAD?
	BEQL	20$			;IF EQL YES
	IFNOWRT	#4,(R3),50$		;CAN PREVIOUS EXIT CONTROL BLOCK BE WRITTEN?
20$:	MOVL	(R2),(R3)		;REMOVE EXIT CONTROL BLOCK FROM LIST
	DECL	(R4)			;INDICATE THAT HANDLER WAS REMOVED
	BRB	40$			;EXIT WITH SUCCESS

25$:	CLRL	(R4)			;SET COUNT TO REFLECT EMPTY LIST
	BRB	30$			;EXIT BY CLEARING LISTHEAD
	.PAGE
	.SBTTL	DECLARE EXIT HANDLER
;+
; EXE$DCLEXH - DECLARE EXIT HANDLER
;
; THIS SERVICE PROVIDES THE CAPABILITY TO INSERT AN EXIT CONTROL BLOCK AT
; THE FRONT OF THE EXIT HANDLER LIST FOR THE CALLING ACCESS MODE.
;
; INPUTS:
;
;	DESBLK(AP) = ADDRESS OF EXIT CONTROL BLOCK.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO DECLARE EXIT HANDLER.
;
;		R0 = SS$_ACCVIO - FIRST LONGWORD OF EXIT CONTROL BLOCK
;			CANNOT BE WRITTEN BY CALLING ACCESS MODE.
;
;		R0 = SS$_NOHANDLER - NO EXIT CONTROL BLOCK ADDRESS SPECIFIED.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENTRY	EXE$DCLEXH,^M<R2,R3,R4>
	BSBB	GETPARM			;GET EXIT CONTROL BLOCK PARAMETERS
	BEQL	60$			;IF EQL NO EXIT CONTROL BLOCK SPECIFIED
	IFNOWRT	#4,(R1),50$		;CAN FIRST LONGWORD BE WRITTEN?
	MOVL	(R0),(R1)		;LINK OLD FIRST TO NEW FIRST
	INCL	(R4)			;COUNT ANOTHER DECLARED HANDLER
30$:	MOVL	R1,(R0)			;SET ADDRESS OF NEW FIRST ENTRY
40$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	RET				;
50$:	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION
	RET				;
60$:	MOVZWL	#SS$_NOHANDLER,R0	;SET NO HANLDER STATUS
	RET				;
	.DSABL	LSB
	.PAGE
	.SBTTL	GET EXIT CONTROL BLOCK PARAMETERS
;+
; This routine obtains the parameters that characterize this call to
; SYS$DCLEXH or SYS$CANEXH.
;
; Input Parameter:
;
;	DESBLK(AP) - Address of termination handler control block
;
; Implicit Input:
;
;	PSL<PRVMOD> - Access mode of caller of system service
;
;	CTL$GL_THEXEC - Address of three-longword array of listheads of
;		termination handler control blocks, one each for exec, 
;		supervisor, and user mode.
;
;	CTL$GL_THCOUNT - Address of three-longword array of counts of
;		termination handlers for each of the three access modes.
;
; Output Parameters:
;
;	R0 - Address of listhead for the correct access mode
;	R1 - Address of termination handler control block 
;	R4 - Address of count cell for the correct access mode.
;
; Implicit Ouptut:
;
;	PSL<Z> - Indicates whether R1 contains a nonzero termination
;		handler control block address.
;-
 
GETPARM:
	MOVPSL	R0			;READ CURRENT PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R0,R0 ;EXTRACT PREVIOUS MODE FIELD
	DECL	R0			;SUBTRACT OUT EXECUTIVE MODE BIAS
	BLSS	10$			;IF LSS CALL FROM KERNEL MODE
	MOVAL	@#CTL$GL_THCOUNT[R0],R4	;GET ADDRESS OF COUNT CELL
	MOVAL	@#CTL$GL_THEXEC[R0],R0	;GET ADDRESS OF EXIT HANDLER LISTHEAD
	MOVL	DESBLK(AP),R1		;GET ADDRESS OF EXIT CONTROL BLOCK
	RSB				;

10$:	BUG_CHECK IVSSRVRQST		;INVALID SYSTEM SERVICE REQUEST
	MOVZWL	#SS$_IVSSRQ,R0		;SET INVALID SYSTEM SERVICE REQUEST
	RET				;
 
	.END
