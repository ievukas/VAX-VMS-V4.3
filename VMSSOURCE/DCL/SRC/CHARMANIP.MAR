	.TITLE	CHARMANIP - CHARACTER MANIPULATION ROUTINES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; CHARACTER MANIPULATION ROUTINES
;
; D. N. CUTLER 28-MAR-77
;
; MODIFIED BY:
;
;	V03-008	PCG0008		Peter George	15-Jul-1983
;		Check for maximum token size.
;		Modify upcase algorithm to allow multinational chars.
;		Move "+" back to insignificant blank separators.
;
;	V03-007	PCG0007		Peter George	15-Jun-1983
;		Make "+-(" significant blank separators.
;
;	V03-006	PCG0006		Peter George	30-Apr-1983
;		Change WRK_L_PARMCNT to WRK_B_PARMCNT.
;
;	V03-005	PCG0005		Peter George	24-Feb-1983
;		Set PTR_B_NUMBER, PTR_B_PARMCNT, and PTR_L_ENTITY 
;		when creating a PTR block.
;
;	V03-004	PCG0004		Peter George	28-Oct-1982
;		Remove ASCIC user prompt.  Read escape sequences.
;
;	V03-003	PCG0003		Peter George	15-Oct-1982
;		Do not supply a prompt string to the user input
;		routine.
;
;	V03-002	PCG0002		Peter George	19-Jul-1982
;		Support CLI$DCL_PARSE continuation routines.
;		Add value level support to DCL$GENDESCR.
;		Set continuation flag for reprompt I/O.
;
;	V03-001	PCG0001		Peter George	09-Jun-1982
;		Do not perform indirection when looking ahead with
;		DCL$TESTBLANK.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

DCL$HYPHEN::				;HYPHEN STRING
	.ASCII	/-/<0>			;
TERMCLASS:				;ITEM TERMINATOR STRING
	.ASCII	\),+/: \		;
TERMTAB:				;TERMINATOR TABLE
	.ASCII	\/,+)]>?=^#\<0>		;
BLANKTAB:				;SIGNIFICANT BLANK SEPARATOR
	.ASCII	\:@*-'([<.; !	\	;
ENDTERM:				;REF LABEL

	.SBTTL	LOCATE STRING BY INDEX NUMBER
;+
; DCL$LOCATE - LOCATE STRING BY INDEX NUMBER
;
; THIS ROUTINE IS CALLED TO LOCATE A STRING IN A CHARACTER ARRAY BY COUNTING
; THE OCCURANCES OF CHARACTERS WITH BIT 7 SET.
;
; INPUTS:
;
;	R2 = ADDRESS OF CHARACTER ARRAY.
;	R3 = STRING INDEX NUMBER.
;
; OUTPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;-
 
DCL$LOCATE::				;LOCATE STRING BY INDEX NUMBER
	CLRL	R1			;CLEAR INITIAL LENGTH
10$:	ADDL	R1,R2			;POINT TO NEXT ENTRY IN TABLE
	MOVZBL	(R2)+,R1		;GET COUNT
	SOBGEQ	R3,10$			;ANY MORE STRINGS TO SKIP OVER?
	RSB				;

	.SBTTL	GENERATE RESULT PARSE DESCRIPTOR
;+
; DCL$GENDESCR - GENERATE RESULT PARSE DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO GENERATE A LONGWORD DESCRIPTOR FOR A RESULT PARSE
; ITEM.
;
; INPUTS:
;
;	R4 = ITEM NUMBER.
;	R5 = ITEM TYPE.
;	R6 = ITEM FLAGS.
;	R7 = ITEM VALUE.
;	R8 = STARTING ADDRESS OF ITEM.
;	R9 = ITEM ENTITY BLOCK ADDRESS.
;	WRK_L_EXPANDPTR = ADDRESS OF TERMINATOR CHARACTER IN EXPANSION BUFFER.
;	WRK_B_VALLEV = VALUE DEPTH OF DESCRIBED ITEM.
;	WRK_B_PARMCNT = NUMBER OF LAST PARAMETER PARSED.
;
; OUTPUTS:
;
;	THE SPECIFIED FIELDS ARE PACKED TOGETHER TO FORM A RESULT PARSE
;	DESCRIPTOR LONGWORD AND THE RESULTANT VALUE IS STORED IN THE RESULT
;	PARSE TABLE.
;-
 
DCL$GENDESCR::					;GENERATE RESULT PARSE DESCRIPTOR
	MOVL	WRK_L_RSLNXT(R10),R1		;GET ADDRESS OF NEXT FREE DESCRIPTOR
	PUSHAB	WRK_G_RESULT+WRK_C_RSLBUFSIZ(R10) ;GET ENDING ADDRESS OF RESULT BUFFER
	CMPL	(SP)+,R1			;ROOM FOR ANOTHER DESCRIPTOR?
	BGTRU	20$				;BRANCH IF OK
	STATUS	RSLOVF				;SET ERROR STATUS
10$:	BRW	ERROR				;
20$:	STATUS	TKNOVF				;SET ERROR STATUS
	CMPL	#255,R7				;CHECK SIZE OF TOKEN
	BLSSU	10$				;BRANCH IF TOO LARGE
	INSV	R7,#PTR_V_VALUE,#PTR_S_VALUE,-	;INSERT VALUE FIELD
		PTR_L_DESCR(R1)			;
	PUSHAB	WRK_G_BUFFER(R10)		;GET ADDRESS OF EXPANSION BUFFER
	SUBL3	(SP)+,R8,R0			;CALCULATE OFFSET TO ITEM
	INSV	R0,#PTR_V_OFFSET,- 		;INSERT OFFSET TO ITEM
		#PTR_S_OFFSET,PTR_L_DESCR(R1)	;
	INSV	R6,#PTR_V_FLAGS,#PTR_S_FLAGS,-	;INSERT ITEM FLAGS
		PTR_L_DESCR(R1)			;
	INSV	R5,#PTR_V_TYPE,#PTR_S_TYPE,-	;INSERT ITEM TYPE
		PTR_L_DESCR(R1)			;
	MOVB	R4,PTR_B_NUMBER(R1)		;INSERT ITEM NUMBER
	MOVL	R9,PTR_L_ENTITY(R1)		;INSERT ENTITY BLOCK ADDRESS
	MOVB	WRK_B_PARMCNT(R10),-		;INSERT LAST PARAMETER NUMBER
		PTR_B_PARMCNT(R1)		;
	MOVB	WRK_B_VALLEV(R10),-		;INSERT VALUE DEPTH
		PTR_B_LEVEL(R1) 		;

	ADDL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10)	;POINT TO NEXT ITEM IN BUFFER
	MOVL	WRK_L_RSLNXT(R10),-		;REMEMBER LAST TOKEN
		WRK_L_RSLEND(R10) 		;
	MOVZBL	@WRK_L_EXPANDPTR(R10),R0 	;GET TERMINATOR CHARACTER

	.SBTTL	SET TERMINATOR CLASS IN LAST DESCRIPTOR
;+
; DCL$GENTERM - SET TERMINATOR CLASS IN PREVIOUS TOKEN DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO SET THE TERMINATOR CLASS IN THE TOKEN
; DESCRIPTOR MOST RECENTLY STORED VIA DCL$GENDESCR.
;
; INPUTS:
;
;	R0 = TERMINATOR CHARACTER
;
; OUTPUTS:
;
;	NONE
;-

DCL$GENTERM::
	CMPB	R0,#^A'='		;EQUAL TERMINATOR?
	BEQL	20$			;IF YES, SET CLASS=COLON
	CMPB	R0,#^A'('		;LEFT PARENTHESIS?
	BEQL	30$			;IF YES, SET CLASS
	LOCC	R0,#TERMTAB-TERMCLASS,TERMCLASS ;SEARCH FOR TERMINATOR IN TABLE
	BNEQ	50$			;IF FOUND - USE INDEX # AS CLASS
	ASSUME	PTR_K_BLANK EQ 1
	INCL	R0			;SET TERMINATOR CLASS TO BLANK
	BRB	50$
20$:	MOVZBL	#PTR_K_COLON,R0		;SET TERMINATOR CLASS TO COLON
	BRB	50$
30$:	MOVZBL	#PTR_K_LPAREN,R0	;SET TERMINATOR CLASS TO LPAREN
50$:	MOVL	WRK_L_RSLNXT(R10),R1	;GET ADDRESS OF NEXT FREE DESCRIPTOR
	INSV	R0,#PTR_V_TERM,#PTR_S_TERM,- ;INSERT TERMINATOR CLASS NUMBER
		-PTR_C_LENGTH(R1)	;IN LAST TOKEN DESCRIPTOR STORED
	RSB

	.SBTTL	COMPRESS QUOTED STRING IN EXPANSION BUFFER
;+
; DCL$COMPRESS - COMPRESS QUOTED STRING IN EXPANSION BUFFER
;
; THIS ROUTINE IS CALLED TO COMPRESS A QUOTED STRING WHICH IS
; THE LAST TOKEN IN THE EXPANSION BUFFER.  THE QUOTES ARE REMOVED
; FROM THE STRING AND THE EXPANSION BUFFER POINTER IS RESET TO THE
; NEW END OF THE STRING.
;
; INPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF COMPRESSED STRING.
;	R2 = ADDRESS OF COMPRESSED STRING.
;
;	WRK_L_EXPANDPTR POINTS TO THE END OF THE COMPRESSED STRING.
;
;	R3,R4 DESTROYED.
;-
 
DCL$COMPRESS::
	BSBB	DCL$COMPSTRING		;COMPRESS STRING IN PLACE
	ADDL3	R1,R2,WRK_L_EXPANDPTR(R10) ;RESET POINTER JUST PAST NEW STRING
	RSB

	.SBTTL	COMPRESS QUOTED STRING IN-PLACE
;+
; DCL$COMPSTRING - COMPRESS QUOTED STRING IN PLACE
;
; THIS ROUTINE IS CALLED TO COMPRESS A QUOTED STRING.
;
; INPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;
; OUTPUTS:
;
;	THE SPECIFIED STRING IS COMPRESSED REMOVING PAIRED QUOTES.
;
;		R1 = LENGTH OF COMPRESSED STRING.
;		R2 = ADDRESS OF COMPRESSED STRING.
;
;	R3,R4 DESTROYED.
;-

DCL$COMPSTRING::			;COMPRESS QUOTED STRING
	MOVL	R2,R3			;COPY BASE ADDRESS OF STRING
	MOVL	R3,R4			;COPY BASE ADDRESS OF STRING
	CLRL	R0			;CLEAR QUOTATION FLAG
10$:	CMPB	#^A/"/,(R3)		;NEXT CHARACTER A QUOTE?
	BNEQ	20$			;IF NEQ NO
	INCL	R3			;ADJUST PAST QUOTE
	BBCS	#0,R0,30$		;IF CLR, JUST ENTERING QUOTE
	DECL	R1			;DECREMENT NUMBER OF CHARACTERS REMAINING
	BLEQ	40$			;IF LEQ NONE
	CMPB	#^A/"/,(R3)		;NEXT CHARACTER ALSO A QUOTE?
	BEQL	20$			;IF EQL YES
	BICL	#1,R0			;CLEAR QUOTE IN PROGRESS
20$:	MOVB	(R3)+,(R4)+		;COPY CHARACTER AND COMPRESS
30$:	SOBGTR	R1,10$			;ANY MORE CHARACTERS TO SCAN?
40$:	SUBL3	R2,R4,R1		;CALCULATE LENGTH OF COMPRESSED STRING
	RSB

	.SBTTL	MARK POSITION IN EXPANSION BUFFER
;+
; DCL$MARK - MARK CURRENT POSITION IN EXPANSION BUFFER
;
; MARK THE CURRENT POSITION OF THE SEGMENT BEING PARSED
; SO THAT IF ANY ERROR OCCURS LATER, THE SEGMENT CAN BE
; SHOWN IN THE ERROR MESSAGE.  THE MARKED POSITION IS
; ALSO USED TO OBTAIN THE LENGTH AND ADDRESS OF THE STRING
; MOVED INTO THE EXPANSION BUFFER SINCE THE LAST MARK.
;
; INPUTS:
;
;	WRK_L_EXPANDPTR = CURRENT POINTER INTO EXPANSION BUFFER
;
; OUTPUTS:
;
;	WRK_L_MARKPTR = POSITION OF SEGMENT NOW BEING PARSED
;---
DCL$MARK::
	MOVL	WRK_L_EXPANDPTR(R10),WRK_L_MARKPTR(R10)	;COPY CURRENT EXPANSION BUFFER ADDRESS
	RSB

	.SBTTL	GET DESCRIPTOR OF EXPANSION STRING
;+
; DCL$MARKEDTOKEN - GET DESCRIPTOR OF MARKED EXPANSION STRING
;
; THIS ROUTINE IS CALLED TO OBTAIN THE LENGTH AND ADDRESS OF THE
; STRING COMPOSED OF ALL CHARACTERS WRITTEN INTO THE EXPANSION BUFFER
; SINCE THE LAST CALL TO DCL$MARK.
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1 = LENGTH OF STRING
;	R2 = ADDRESS OF STRING
;	Z SET IF R1=0
;-
DCL$MARKEDTOKEN::
	MOVL	WRK_L_MARKPTR(R10),R2	;GET ADDRESS OF STRING
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;COMPUTE LENGTH OF STRING
	RSB

	.SBTTL	GET NEXT NONBLANK CHARACTER
;+
; DCL$GETNBLK - GET NEXT NONBLANK CHARACTER FROM INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE NEXT NONBLANK CHARACTER FROM THE INPUT
; BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CHARACTERS ARE OBTAINED FROM THE INPUT BUFFER UNTIL A NONBLANK
;	CHARACTER IS ENCOUNTERED.
;
;	R0 = NONBLANK CHARACTER.
;-
 
DCL$GETNBLK::				;GET NEXT NONBLANK CHARACTER
	BSBW	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	BRW	DCL$GETCHAR		;RETURN NEXT CHARACTER TO CALLER

	.SBTTL	MOVE CHARACTER TO EXPANSION BUFFER AND GET BLANK TOKEN
;+
; DCL$MOVBTOKN - MOVE CHARACTER TO EXPANSION BUFFER AND GET BLANK TOKEN
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED OPERATION OF MOVING THE NEXT
; CHARACTER TO THE EXPANSION BUFFER AND THEN OBTAINING THE NEXT BLANK TOKEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS MOVED TO THE EXPANSION BUFFER AND THEN THE NEXT
;	BLANK TOKEN IS OBTAINED.
;-
 
DCL$MOVBTOKN::				;MOVE CHARACTER AND GET TOKEN
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO EXPANSION BUFFER
	BRB	DCL$GTBTOKEN		;GET NEXT BLANK TOKEN

	.SBTTL	MOVE CHARACTER TO EXPANSION BUFFER AND GET TOKEN
;+
; DCL$MOVTOKN - MOVE CHARACTER TO EXPANSION BUFFER AND GET TOKEN
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED OPERATION OF MOVING THE NEXT
; CHARACTER TO THE EXPANSION BUFFER AND THEN OBTAINING THE NEXT TOKEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS MOVED TO THE EXPANSION BUFFER AND THEN THE NEXT
;	TOKEN IS OBTAINED.
;-
 
DCL$MOVTOKN::				;MOVE CHARACTER AND GET TOKEN
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO EXPANSION BUFFER

	.SBTTL	GETOKEN - GET NEXT TOKEN
;+
; DCL$GETOKEN - GET TOKEN FROM INPUT BUFFER WITH INSIGNIFICANT LEADING BLANKS
; DCL$GTBTOKEN - GET TOKEN FROM INPUT BUFFER WITH SIGNIFICANT LEADING BLANKS
;
; THIS ROUTINE IS CALLED TO SCAN THE INPUT BUFFER UNTIL A DELIMITER IS FOUND.
; WHILE THE BUFFER IS BEING SCANNED, THE RESULTANT TOKEN IS COPIED INTO THE
; EXPANSION BUFFER. WHEN A TERMINATOR IS RECOGNIZED, THE DESCRIPTOR FOR THE
; TOKEN IS RETURNED TO THE CALLER ALONG WITH THE TERMINATOR.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 = TERMINATOR CHARACTER.
;	R1 = LENGTH OF OUTPUT TOKEN.
;	R2 = ADDRESS OF OUTPUT TOKEN.
;
;	Z = 1 IF NO TOKEN IS BEING RETURNED.
;	Z = 0 IF A TOKEN IS BEING RETURNED.
;-

DCL$GETOKEN::				;GET TOKEN FROM INPUT BUFFER
	BSBB	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
DCL$GTBTOKEN::				;GET TOKEN FROM INPUT BUFFER
	SUBL3	R10,-			;FIND OFFSET OF FIRST BYTE IN TOKEN
		WRK_L_EXPANDPTR(R10),R2 ;
10$:	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO EXPANSION BUFFER
	BBS	#WRK_V_QUOTE,-		;IF SET, QUOTE IN PROGRESS
		WRK_W_FLAGS(R10),10$ 	;
	BBS	#WRK_V_STAR,-		;IF SET, ASTERISK IS TERMINATOR
		WRK_W_FLAGS(R10),20$ 	;
	CMPB	#^A'*',R0		;ASTERISK?
	BEQL	10$			;IF EQL YES
	BBC	#WRK_V_ESCAPE,-		;IF SET, NULL IS TERMINATOR
		WRK_W_FLAGS(R10),20$ 	;
	CMPB	#^X00,R0		;NULL?
	BNEQ	10$			;NO, THEN LOOP
20$:	LOCC	R0,#ENDTERM-TERMTAB,-	;SEARCH FOR TERMINATOR
		TERMTAB 		;
	BEQL	10$			;IF EQL TERMINATOR NOT FOUND
	BICW	#WRK_M_ESCAPE,-		;CLEAR ESCAPE FLAG
		WRK_W_FLAGS(R10)	;
	DECL	WRK_L_EXPANDPTR(R10)	;BACK UP TO TERMINATOR
	MOVZBL	(R1),R0			;RETRIEVE TERMINATOR
	CMPB	#^A' ',R0		;WAS TERMINATOR A BLANK?
	BNEQ	30$			;IF NEQ NO
	MOVL	WRK_L_CHARPTR(R10),R1	;GET CURRENT CHARACTER POINTER
	LOCC	1(R1),#BLANKTAB-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BNEQ	10$			;IF NEQ INSIGNIFICANT BLANK
	MOVZBL	#^A' ',R0		;RESET BLANK TERMINATOR
30$:	BSBW	DCL$BACKUPCHAR		;RESTORE TERMINATOR TO INPUT BUFFER
	ADDL	R10,R2			;FIND ADDRESS OF FIRST BYTE IN TOKEN
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;CALCULATE LENGTH OF ITEM
	BEQL	50$			;IF EQL NO TOKEN
	CMPB	(R2),#^A'&'		;TOKEN START WITH AMPERSAND?
	BNEQ	50$			;IF NEQ NO
	TSTL	WRK_L_SPECRTN(R10)	;ANY SPECIAL PROCESSING ROUTINE?
	BEQL	50$			;IF NOT, SKIP IT
	MOVZBL	(R2),R0			;PICK UP CHARACTER
	JSB	@WRK_L_SPECRTN(R10)	;CALL SPECIAL PROCESSING ROUTINE
					;AND RETURN WITH SUBSTITUTED VALUE
50$:	RSB

	.SBTTL	FORCE NONBLANK CHARACTER
;+
; DCL$FORNBLK - FORCE NONBLANK CHARACTER
;
; THIS ROUTINE IS CALLED TO FORCE AN INPUT AND THEN SET THE CHARACTER POINTER
; TO THE NEXT NONBLANK CHARACTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER POINTER IS SET TO POINT TO A STRING CONTAINING
;	A HYPHEN FOLLOWED BY AN END OF LINE. A SET NONBLANK OPERATION IS
;	THEN PERFORMED.
;-
 
DCL$FORNBLK::				;FORCE NONBLANK CHARACTER
	MOVAB	DCL$HYPHEN-1,WRK_L_CHARPTR(R10) ;SET TO FORCE INPUT ON NEXT GET

	.SBTTL	POINT TO NEXT NONBLANK CHARACTER
;+
; DCL$SETNBLK - POINT TO NEXT NONBLANK CHARACTER IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO SET THE INPUT BUFFER POINTER TO THE NEXT NONBLANK
; CHARACTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CHARACTERS ARE OBTAINED FROM THE INPUT BUFFER UNTIL A NONBLANK CHAR-
;	ACTER IS ENCOUNTERED AND THE INPUT BUFFER POINTER IS RETURNED TO ITS
;	POSITION BEFORE THE LAST GET CHARACTER OPERATION.
;
;	R0 = NONBLANK CHARACTER.
;-
 
	.ENABL	LSB
DCL$SETNBLK::				;POINT TO NEXT NONBLANK CHARACTER
	EXTZV	#WRK_V_QUOTE,#1,WRK_W_FLAGS(R10),-(SP) ; SAVE QUOTATION FLAG
10$:	BSBW	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	50$			;IF EQL END OF LINE
	CMPB	R0,#^A' '		;BLANK?
	BEQL	10$			;IF EQL YES
	BRB	30$			;BACKUP BEFORE CHARACTER AND EXIT

	.SBTTL	PEEK AT NEXT CHARACTER
;+
; DCL$SETCHAR - PEEK AT NEXT CHARACTER IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE NEXT CHARACTER IN THE INPUT BUFFER
; WITHOUT MOVING THE BUFFER POINTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS OBTAINED FROM THE INPUT BUFFER AND THE CHARACTER
;	POINTER IS RETURNED TO ITS POSITION BEFORE THE GET CHARACTER OPERATION.
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER.
;+
 
DCL$SETCHAR::				;PEEK AT NEXT CHARACTER
	EXTZV	#WRK_V_QUOTE,#1,WRK_W_FLAGS(R10),-(SP) ; SAVE QUOTATION FLAG
	BSBB	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	50$			;IF EQL END OF LINE
30$:	DECL	WRK_L_CHARPTR(R10)	;BACK UP INPUT BUFFER POINTER
40$:	INSV	(SP)+,#WRK_V_QUOTE,#1,WRK_W_FLAGS(R10);RESTORE QUOTATION FLAG
	RSB				;
50$:	TSTL	(SP)+			;IGNORE SAVED QUOTATION FLAG ON EOL
	RSB
	.DSABL	LSB

	.SBTTL	BYPASS INSIGNIFICANT BLANKS
;+
; DCL$TESTBLANK - BYPASS INSIGNIFICANT BLANKS IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO TEST IF THE NEXT CHARACTER IN THE INPUT BUFFER IS
; A SIGNIFICANT BLANK, AND IF IT IS NOT SIGNIFICANT, THROW IT AWAY.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;-
 
DCL$TESTBLANK::				;TEST FOR SIGNIFICANT BLANK
	BSBB	DCL$MOVCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	DCL$BACKUPMOVE		;IF NEQ NO
	BBC	#WRK_V_USRMODE,-	;IF SET THEN USER MODE PARSE
		WRK_W_FLAGS(R10),10$ 	;
	BSBB	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BRB	20$			;SKIP SUPERVISOR MODE PEEK AHEAD
10$:	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT DURING LOOK AHEAD
	BSBB	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;RE-ENABLE INDIRECT
20$:	LOCC	R0,#BLANKTAB-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BEQL	DCL$BACKUPMOVE		;BR IF BLANK IS SIGNIFICANT
	MOVL	WRK_L_EXPANDPTR(R10),R0	;GET POINTER INTO EXPANSION BUFFER
	MOVB	(R1),-1(R0)		;PUT REAL TERMINATOR OVER BLANK
	INCL	WRK_L_CHARPTR(R10)	;ADJUST POINTER FOR THE BLANK

	.SBTTL	BACKUP CHARACTER FROM EXPANSION TO INPUT BUFFER
;+
; DCL$BACKUPMOVE - BACKUP ONE CHARACTER FROM EXPANSION TO INPUT BUFFER
;
; THIS ROUTINE RESTORES THE CHARACTER MOST RECENTLY WRITTEN INTO THE EXPANSION
; BUFFER BACK INTO THE INPUT BUFFER AND RESETS THE POINTERS.  THIS EFFECTIVELY
; TAKES BACK THE MOST RECENT "MOVCHAR".
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	THE CHARACTER IS COPIED BACK INTO THE INPUT BUFFER AND THE POINTERS
;	ARE RESET.
;-
DCL$BACKUPMOVE::
	DECL	WRK_L_EXPANDPTR(R10)	;BACK UP EXPANSION BUFFER POINTER
	MOVB	@WRK_L_EXPANDPTR(R10),R0 ;GET CHARACTER

	.SBTTL	BACKUP CHARACTER TO INPUT BUFFER
;+
; DCL$BACKUPCHAR - BACKUP ONE CHARACTER TO INPUT BUFFER
;
; THIS ROUTINE WRITES A GIVEN CHARACTER BACK INTO THE INPUT BUFFER (AT THE
; BEGINNING) AND RESETS THE INPUT POINTER.
;
; INPUTS:
;
;	R0 = CHARACTER TO BE WRITTEN
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	THE CHARACTER IS APPENDED TO THE FRONT OF THE INPUT BUFFER
;	AND THE POINTERS ARE RESET.
;-
DCL$BACKUPCHAR::
	MOVB	R0,@WRK_L_CHARPTR(R10)	;WRITE CHARACTER INTO INPUT BUFFER
	DECL	WRK_L_CHARPTR(R10)	;BACK UP INPUT BUFFER POINTER
	RSB

	.SBTTL	MOVE CHARACTER FROM INPUT TO EXPANSION BUFFER
;+
; DCL$MOVCHAR - MOVE CHARACTER TO EXPANSION BUFFER
;
; THIS ROUTINE IS CALLED TO MOVE A CHARACTER FROM THE INPUT BUFFER TO THE
; EXPANSION BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS OBTAINED FROM THE INPUT BUFFER AND WRITTEN INTO
;	THE EXPANSION BUFFER.
;
;	R0 = CHARACTER MOVED
;	Z SET IF R0=0
;-
 
DCL$MOVCHAR::				;MOVE CHARACTER TO EXPANSION BUFFER
	BSBB	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER

	.SBTTL	PUT CHARACTER IN EXPANSION BUFFER
;+
; DCL$PUTCHAR - PUT CHARACTER IN EXPANSION BUFFER
;
; THIS ROUTINE IS CALLED TO WRITE A CHARACTER INTO THE EXPANSION BUFFER.
;
; INPUTS:
;
;	R0 = CHARACTER TO BE WRITTEN IN EXPANSION BUFFER.
;	WRK_L_EXPANDPTR = ADDRESS OF NEXT BYTE IN EXPANSION BUFFER.
;
; OUTPUTS:
;
;	THE SPECIFIED CHARACTER IS WRITTEN INTO THE EXPANSION BUFFER AFTER
;	HAVING CHECKED FOR BUFFER OVERFLOW.
;
;	R0 = CHARACTER WRITTEN
;	Z SET IF R0=0
;-
 
DCL$PUTCHAR::				;PUT CHARACTER IN EXPANSION BUFFER
	PUSHAB	WRK_G_BUFFER+WRK_C_CMDBUFSIZ(R10) ;END OF EXPANSION AREA
	CMPL	(SP)+,WRK_L_EXPANDPTR(R10) ;ROOM FOR ANOTHER CHARACTER?
	BLEQU	10$			;IF LEQU NO
	MOVB	R0,@WRK_L_EXPANDPTR(R10) ;STORE CHARACTER IN EXPANSION BUFFER
	INCL	WRK_L_EXPANDPTR(R10)	;INCREMENT EXPANSION POINTER
	TSTB	R0			;RETURN WITH PSL SET FOR CHARACTER
	RSB				;
10$:	STATUS	BUFOVF			;SET ERROR STATUS
	BBS	#WRK_V_USRMODE,-	;IF SET THEN USER MODE PARSE
		WRK_W_FLAGS(R10),20$ 	;
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;CLEAR INDIRECT IN PROGRESS
20$:	BRW	ERROR			;

	.SBTTL	GET CHARACTER FROM INPUT BUFFER
;+
; DCL$GETCHAR - GET CHARACTER FROM INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO GET THE NEXT CHARACTER FROM THE INPUT BUFFER.
; IT HANDLES INDIRECT FILES, QUOTES, CONTINUATION, AND BLANK SUPPRESSION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS READ FROM THE INPUT BUFFER AND RETURNED TO THE
;	CALLER.
;
;	R0 = CHARACTER READ.
;-
DCL$GETCHAR::				;GET NEXT CHARACTER FROM INPUT BUFFER
	PUSHL	R1			;SAVE REGISTER
NEXTCHAR:				;GET NEXT CHARACTER
	INCL	WRK_L_CHARPTR(R10)	;UPDATE INPUT BUFFER POINTER
CURRCHAR:				;GET CURRENT CHARACTER
	MOVL	WRK_L_CHARPTR(R10),R1	;GET CHARACTER POINTER
	MOVZBL	(R1)+,R0		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	EOL			;IF EQL END OF LINE
	CMPB	#^A/"/,R0		;QUOTE?
	BEQL	QUOTE			;IF EQL YES
	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(R10),EXITCHAR ;EXIT IF IN QUOTED STRING
	BBS	#WRK_V_INPSUBST,WRK_W_FLAGS(R10),20$ ;IF SUBSTITUTITION PASS
	CMPB	#^A/@/,R0		;AT SIGN?
	BEQL	INDIRECT
	CMPB	#^A/!/,R0		;EXCLAMATION?
	BEQL	TRUNCATE
	CMPB	#^A/	/,R0		;TAB?
	BEQL	TAB
	CMPB	#^A/ /,R0		;BLANK?
	BEQL	BLANK
	CMPB	#^A/-/,R0		;HYPHEN?
	BEQL	CONTINUATION
20$:	BBS	#WRK_V_NOUPCASE,WRK_W_FLAGS(R10),EXITCHAR ;SKIP IF NO UPCASING
	CMPB	R0,#^A/a/		;CHECK LOW LIMIT OF LOW RANGE
	BLSSU	EXITCHAR		;BR IF FAILED
	CMPB	R0,#^A/z/		;CHECK HIGH LIMIT OF LOW RANGE
	BLEQU	25$			;BR IF VALID CHARACTER
	CMPB	R0,#^XE0		;CHECK LOW LIMIT OF HIGH RANGE
	BLSSU	EXITCHAR		;BR IF FAILED
	CMPB	R0,#^XFE		;CHECK HIGH LIMIT OF HIGH RANGE
	BGTRU	EXITCHAR		;BR IF FAILED
25$:	BICB	#^X20,R0		;UPCASE THE CHARACTER

EXITCHAR:				;EXIT WITH CHARACTER
	POPL	R1			;RESTORE REGISTER
	TSTB	R0			;SET CONDITION CODES BASED ON CHARACTER
	RSB				;
;
; STRING QUOTATION DELIMITER DETECTED.  INVERT QUOTE FLAG.
;
QUOTE:	XORW	#WRK_M_QUOTE,WRK_W_FLAGS(R10) ;INVERT QUOTE FLAG
	BRB	EXITCHAR		;

;
; INDIRECTION (@) REQUESTED
;
INDIRECT:
	TSTL	WRK_L_SPECRTN(R10)	;ANY SPECIAL PROCESSING ROUTINE?
	BEQL	EXITCHAR		;IF NOT, RETURN @ CHARACTER
	JSB	@WRK_L_SPECRTN(R10)	;CALL SPECIAL PROCESSING ROUTINE
	BRB	EXITCHAR		;EXIT WITH NEXT CHARACTER

;
; COMMENT CHARACTER DETECTED.  FAKE AN END OF LINE CONDITION.
;
TRUNCATE:
	CLRB	-(R1)			;SET END OF LINE IN BUFFER
	BRB	CURRCHAR
;
; END OF LINE DETECTED.  TERMINATE ANY STRING AND EXIT
;
EOL:	BICW	#WRK_M_QUOTE,WRK_W_FLAGS(R10) ;CLEAR QUOTE IN PROGRESS
	DECL	WRK_L_CHARPTR(R10)	;BACK UP INPUT BUFFER POINTER
	BRB	EXITCHAR
;
; TAB DETECTED.  CONVERT TO A SPACE.
;
TAB:	MOVZBL	#^A/ /,R0		;SET CHARACTER TO A BLANK
;
; COMPRESS MULTIPLE SPACES AND TABS INTO A SINGLE SPACE
;
BLANK:	MOVB	R0,@WRK_L_CHARPTR(R10)	;STORE BLANK IN INPUT BUFFER
	CMPB	#^A/ /,(R1)+		;NEXT CHARACTER A BLANK?
	BEQL	30$			;IF EQL YES
	CMPB	#^A/	/,-1(R1)	;NEXT CHARACTER A TAB?
	BNEQ	40$			;IF NEQ NO
30$:	INCL	WRK_L_CHARPTR(R10)	;INCREMENT CHARACTER POINTER
	BRB	BLANK			;
;
; STRIP ANY TRAILING SPACES ON THE END OF THE LINE
;
40$:	TSTB	-(R1)			;NEXT CHARACTER END OF LINE?
	BEQL	TRUNCATE		;IF EQL YES
	CMPB	#^A/!/,(R1)		;NEXT CHARACTER EXCLAMATION?
	BEQL	TRUNCATE		;IF EQL YES
	CMPB	#^A/-/,(R1)+		;HYPHEN?
	BNEQ	EXITCHAR		;IF NEQ NO
	SETBIT	WRK_V_TRAILSPC,WRK_W_FLAGS(R10) ;INDICATE TRAILING SPACES SEEN
;
; CONTINUATION CHARACTER DETECTED.  IF ITS THE LAST CHARACTER ON
; THE LINE, READ THE NEXT INPUT RECORD AND READ ITS FIRST CHARACTER.
;
CONTINUATION:
	TSTB	(R1)			;NEXT CHARACTER END OF LINE?
	BEQL	NEXT_RECORD		;IF EQL YES
	CMPB	#^A/!/,(R1)		;NEXT CHARACTER EXCLAMATION?
	BEQL	NEXT_RECORD		;IF EQL YES
	CMPB	#^A/ /,(R1)+		;NEXT CHARACTER A BLANK?
	BEQL	CONTINUATION		;IF EQL YES
	CMPB	#^A/	/,-1(R1)	;NEXT CHARACTER A TAB?
	BEQL	CONTINUATION		;IF EQL YES
	CLRBIT	WRK_V_TRAILSPC,WRK_W_FLAGS(R10) ;CLEAR TRAILING SPACE FLAG
	BRB	EXITCHAR		;

;
; READ THE NEXT RECORD, AND RESTART THE GETCHAR SCAN.
;
NEXT_RECORD:
	TSTL	WRK_L_READRTN(R10)	;ANY INPUT ROUTINE?
	BEQL	EXITCHAR		;IF NOT, RETURN EOL CHARACTER
	BBC	#WRK_V_USRMODE,-	;BRANCH IF DCL INPUT ROUTINE
		WRK_W_FLAGS(R10),10$	
	MOVL	WRK_L_READRTN(R10),R0	;GET ADDRESS OF USER CONTIN ROUTINE
	CLRL	R1			;DO NOT SUPPLY A PROMPT
	BSBW	DCL$USER_INPUT		;CALL USER'S ROUTINE FOR INPUT
	BSBW	DCL$GETCHAR		;GET FIRST CHARACTER IN INPUT LINE
	BRW	EXITCHAR		;EXIT WITH FIRST CHARACTER
10$:	MOVAB	DCL$HYPHEN+1,R0		;GET ADDRESS OF FORCED INPUT CHARACTER
	CMPL	R0,R1			;ARE WE FAKING A CONTINUATION?
	BEQL	15$			;YES, THEN DON'T SET THE FLAG
	BISW	#WRK_M_CONTIN,WRK_W_FLAGS(R10) ;SET CONTINUATION IN PROGRESS 
15$:	JSB	@WRK_L_READRTN(R10)	;CALL INPUT ROUTINE
	BICW	#WRK_M_CONTIN,WRK_W_FLAGS(R10) ;SET CONTINUATION IN PROGRESS 
	BRW	EXITCHAR		;EXIT WITH FIRST CHARACTER

;
; ERROR EXIT FROM CHARACTER INPUT ROUTINES
;
 
ERROR:	TSTL	WRK_L_ERRORRTN(R10)	;ANY ERROR HANDLER ROUTINE?
	BEQL	90$			;IF NOT, IGNORE ERROR
	JSB	@WRK_L_ERRORRTN(R10)	;CALL ERROR HANDLER
90$:	RSB

	.END
