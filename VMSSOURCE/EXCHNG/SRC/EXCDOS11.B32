MODULE	exch$dos11				%TITLE 'dos11 file and directory routines'
		(
		IDENT = 'V04-000',
		ADDRESSING_MODE (EXTERNAL=LONG_RELATIVE, NONEXTERNAL=WORD_RELATIVE)
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	EXCHANGE - Foreign volume interchange facility
!
! ABSTRACT:	DOS-11 volume specific routines
!
! ENVIRONMENT:	VAX/VMS User mode
!
! AUTHOR:	CW Hobbs		CREATION DATE: 22-Mar-1983
!
! MODIFIED BY:
!
!	V03-003	CWH3003		CW Hobbs		12-Apr-1984
!		Make /TRANSFER=BLOCK a global qualifier by looking at
!		both input and output specs.
!
!	V03-002	CWH3002		CW Hobbs		6-Feb-1984
!		Change calculation of DOS11 date to use signed INCR to
!		avoid looping in January.
!
!
!--

! Include files:
!
MACRO $module_name_string = 'exch$dos11' %;	! The require file needs to know our module name
REQUIRE 'SRC$:EXCREQ'				! Facility-wide require file
    ;

%SBTTL 'Module table of contents'

! Module table of contents:
!
FORWARD ROUTINE
    exch$dos11_close_file,			! DOS-11 specific file close routine
    exch$dos11_create_file,			! DOS-11 volume file create
    exch$dos11_directory,			! DOS-11 volume directory command
    exch$dos11_dire_put_item	: NOVALUE,	! Add an file item to the directory line
    exch$dos11_exit_handler	: NOVALUE,	! Write tape marks if an exit occurs with an open output file
    exch$dos11_expand_filename	: NOVALUE,	! Convert tape label to ASCII filename
    exch$dos11_find_file,			! Find a file entry in the temporary
    exch$dos11_form_cur_date : NOVALUE jsb_r1,	! Put the current date into a directory entry
	 dos11_match_uic	: jsb_r0r1,	! Check uic directory matches
    exch$dos11_mount,				! DOS-11 specific volume mount routine
    exch$dos11_next_entry,			! Retrieve a pointer to the next file name entry
    exch$dos11_open_file,			! DOS-11 specific file open routine
    exch$dos11_position_tape			! Move the tape to the start of a particular file
    ;

! EXCHANGE facility routines
!
EXTERNAL ROUTINE
    exch$cmd_fetch_recfmt_implied : NOVALUE,	! Get or assume the value for /RECORD_FORMAT
    exch$cmd_match_filename,			! Compare expanded file names for match
    exch$cmd_related_file_parse,		! Build an output file name
    exch$dire_get_columns,			! Get number of colums for the output file
    exch$dire_get_width,			! Get the output file width
    exch$dire_put,				! Put a line to the output file
    exch$io_dos11_count_blocks,			! Count blocks to the next tape mark
    exch$io_dos11_read,				! Read blocks from a sequential device
    exch$io_dos11_read_label,			! Read sequential device file label
    exch$io_dos11_rewind,			! Rewind a sequential device
    exch$io_dos11_skip_file,			! Skip a file on a sequential device
    exch$io_dos11_skip_record,			! Skip a physical record on a sequential device
    exch$io_dos11_write,			! Write blocks to a sequential device
    exch$io_dos11_write_label,			! Write a label on a sequential device
    exch$io_dos11_write_tape_mark,		! Write a tape mark on a sequential device
    exch$pdp_filter_filename,			! Remove invalid characters from a filename
    exch$pdp_flush_write_buffer,		! Flush any records waiting in the write buffer
    exch$pdp_get,				! Get functions for small PDP record structure
    exch$pdp_put,				! Put functions for small PDP record structure
    exch$util_fao_buffer,			! Do an FAO conversion
    exch$util_radix50_from_ascii,		! Convert characters to Radix-50 from Ascii
    exch$util_radix50_to_ascii,			! Convert characters from Radix-50 to Ascii
    exch$util_dos11ctx_allocate,		! Get an DOS-11 context block
    exch$util_dos11ctx_release	: NOVALUE,	! Give it back
    exch$util_vm_allocate,			! Get some virtual memory
    exch$util_vm_allocate_zeroed,		! Get some virtual memory, initialized to zero
    exch$util_vm_release			! Return some virtual memory
    ;

! Store some constants in read-only own
!
OWN
    months : VECTOR [13, LONG] INITIAL
		('Jan-','Feb-','Mar-','Apr-','May-','Jun-','Jul-','Aug-','Sep-','Oct-','Nov-','Dec-','***-'),
    days_of_months : VECTOR [12, BYTE] PRESET
		([0] = 31, [1] = 28, [2] = 31, [3] = 30,  [4] = 31,  [5] = 30, 
		 [6] = 31, [7] = 31, [8] = 30, [9] = 31, [10] = 30, [11] = 31),
    days_of_months_leapyear : VECTOR [12, BYTE] PRESET
		([0] = 31, [1] = 29, [2] = 31, [3] = 30,  [4] = 31,  [5] = 30, 
		 [6] = 31, [7] = 31, [8] = 30, [9] = 31, [10] = 30, [11] = 31)
    ;

! Equated symbols:
!
!LITERAL
!    ;

! Bound declarations:
!
BIND
    null_string = %ASCID ''
    ;

GLOBAL ROUTINE exch$dos11_close_file (filb : $ref_bblock) =	%SBTTL 'exch$dos11_close_file (filb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Perform DOS-11 volume specific close processing
!
! INPUT/OUTPUT:
!
!	filb - pointer to block describing the file
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	filb - receive info pertaining to the file to be closed
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true if able to close the file, false otherwise
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('exch$dos11_close_file> ');

LOCAL
    status
    ;

BIND
    ctx  = filb [filb$a_context]	: $ref_bblock,
    namb = filb [filb$a_assoc_namb]	: $ref_bblock,
    volb = filb [filb$a_assoc_volb]	: $ref_bblock,
    dosv = volb [volb$a_vfmt_specific]	: $ref_bblock,
    ent  = dosv [dos11$a_current_entry] : $ref_bblock
    ;

$debug_print_lit ('entry');

$block_check (2, .filb, filb, 580);			!?? definitely over-zealous checking
$block_check (2, .namb, namb, 581);
$block_check (2, .volb, volb, 582);
$block_check (2, .dosv, dos11, 442);
$block_check (2, .ctx, dos11ctx, 583);
$logic_check (4, (.ctx [dos11ctx$a_assoc_filb] EQL .filb), 241);
$logic_check (4, (.ctx [dos11ctx$a_assoc_volb] EQL .volb), 248);

! Output files need some directory tweaks and a buffer flush
!
IF .ctx [dos11ctx$v_output_file]
THEN
    BEGIN

    ! Flush any blocks that are sitting in the output buffer
    !
    status = exch$pdp_flush_write_buffer (.ctx);

    ! Write two tape marks to mark the end of the tape, try even if buffer flush failed
    !
    exch$io_dos11_write_tape_mark (.volb);
    exch$io_dos11_write_tape_mark (.volb);

    ! Cancel the exit handler which was declared to write the tape marks
    !
    $canexh (desblk=exch$a_gbl [excg$r_exit_block]);
    exch$a_gbl [excg$a_exh_routine] = 0;	! Clear address, means no exit handler is active

    ! If the buffer flush failed, exit now
    !
    IF NOT .status
    THEN
	RETURN .status;

    ! We have finished this file, and we are sitting on the tape mark ready for the next file
    !
    dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;
    $trace_print_fao ('dosv file number updated to !UL', .dosv [dos11$l_current_file]);

    END

! Input file, we just need to see if we got to the tape mark
!
ELSE
    BEGIN

    ! If we didn't get to see the tape mark at the end of the file, something happened and we may be lost
    !
    IF NOT .dosv [dos11$v_tape_mark]
    THEN
	BEGIN

	! Rewind the tape so that the exact position will be known again
	!
	$exch_signal (exch$_dos11_position);	! This might take a while, warn 'em
	exch$io_dos11_rewind (.volb);
	END

    ! We have finished this file, and we are sitting on the tape mark ready for the next file
    !
    ELSE
	BEGIN
	dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;
	$trace_print_fao ('dosv file number updated to !UL', .dosv [dos11$l_current_file]);
	END;
    END;

! If the block count in the entry is not valid, then update the count from the context and mark it valid
!
IF NOT .ent [dos11ent$v_blocks_valid]
THEN
    BEGIN
    REGISTER
	count;

    ! Update the block count in the entry
    !
    count = .ctx [dos11ctx$l_eof_block] + 1;
    IF .count NEQ 0
    THEN
	BEGIN
	ent [dos11ent$w_blocks] = .count;
	ent [dos11ent$v_blocks_valid] = true;
	END;
    END;

! Clear the stream active bit and all other context flags
!
ctx [dos11ctx$l_flags] = 0;

RETURN true;					
END;

GLOBAL ROUTINE exch$dos11_create_file =	%SBTTL 'exch$dos11_create_file'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Perform DOS-11 volume specific create processing
!
! INPUT:
!
!	none
!
! IMPLICIT INPUTS:
!
!	copy [copy$a_out_filb] - pointer to the filb for the output file
!	copy [copy$a_inp_filb] - pointer to the filb for the input file
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	copy [copy$a_out_filb] - block receives info pertaining to the created file

!
! ROUTINE VALUE:
!
!	true if able to create a file, false otherwise
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('dos11_create_file> ');

LOCAL
    rfp : $bblock [nam$c_bln+nam$c_maxrss],	! output file parse - an RMS NAM block plus expanded string buffer
    nam_len,					! temporary to hold length of name
    typ_len,					! temporary to hold length of type
    tot_len,					! temporary to hold length of name + type
    ent	: $ref_bblock,				! a pointer to the entry we are adding
    start_block,				! the pbn where this file will start
    temp,
    status
    ;

BIND
    copy     = exch$a_gbl [excg$a_copy_work]	: $ref_bblock,
    out_name = copy [copy$q_output_filename]	: $desc_block,
    inp_filb = copy [copy$a_inp_filb]		: $ref_bblock,
    inp_namb = inp_filb [filb$a_assoc_namb]	: $ref_bblock,
    inp_volb = inp_filb [filb$a_assoc_volb]	: $ref_bblock,
    inp_ctx  = inp_filb [filb$a_context]	: $ref_bblock,
    out_filb = copy [copy$a_out_filb]		: $ref_bblock,
    out_namb = out_filb [filb$a_assoc_namb]	: $ref_bblock,
    out_ctx  = out_filb [filb$a_context]	: $ref_bblock,
    volb     = out_filb [filb$a_assoc_volb]	: $ref_bblock,
    dosv     = volb [volb$a_vfmt_specific]	: $ref_bblock
    ;

$debug_print_lit ('entry');

$block_check (2, .out_filb, filb, 584);
$block_check (2, .inp_filb, filb, 585);
$block_check (2, .out_namb, namb, 586);
$block_check (2, .inp_namb, namb, 587);
$block_check (2, .volb, volb, 588);
$block_check_if_nonzero (2, .inp_volb, volb, 634);
$block_check (2, .dosv, dos11, 595);


! Make certain that write access is permitted, this should be checked long before we get here
!
$logic_check (2, (.volb [volb$v_write]), 253);

! If the context pointer is null, then allocate and initialize it.
!
IF .out_ctx EQL 0
THEN
    out_ctx = exch$util_dos11ctx_allocate (.volb, .out_filb)	! Get an dos11 context block

ELSE
    $block_check (2, .out_ctx, dos11ctx, 589);			! Make sure that it is what we think it is

! Make sure that we haven't crossed signals someplace
!
$logic_check (4, (.out_ctx [dos11ctx$a_assoc_filb] EQL .out_filb), 254);
$logic_check (4, (.out_ctx [dos11ctx$a_assoc_volb] EQL .volb), 255);

! Set the rest of the block to nulls, nothing carries over from one output file to the next
!
CH$FILL (0, dos11ctx$k_end_zero - dos11ctx$k_start_zero,	! Set rest of block to nulls
		.out_ctx + dos11ctx$k_start_zero);

! Perform an RMS output file parse on the related name (the result name for the input file) and the
! requested output name from the command line.
!
IF NOT (status = exch$cmd_related_file_parse (
		.out_name [dsc$w_length], .out_name [dsc$a_pointer],			! Command line out parameter
		.inp_filb [filb$l_result_name_len], inp_filb [filb$t_result_name],	! Related name
		rfp))									! Gets new name
THEN
    BEGIN

    ! Move the raw name to where it is accessible for the outer signal
    !
    CH$MOVE (.out_name [dsc$w_length], .out_name [dsc$a_pointer], out_filb [filb$t_result_name]);
    RETURN .status;

    END;

! Create the result file name in the filb
!
out_filb [filb$v_name_change] = false;		! Assume no name change
tot_len = .rfp [nam$b_name];			! Remember starting length of name
rfp [nam$b_name] = exch$pdp_filter_filename (.rfp [nam$b_name], .rfp [nam$l_name]);	! Remove invalid characters
nam_len = MINU (.rfp [nam$b_name], 9);		! Maximum name is nine letters
IF .tot_len NEQ .nam_len			! If length not same as start, then it has changed
THEN
    out_filb [filb$v_name_change] = true;

tot_len = .rfp [nam$b_type];			! Remember starting length of type
rfp [nam$b_type] = 1 + exch$pdp_filter_filename (.rfp [nam$b_type] - 1, .rfp [nam$l_type] + 1);
typ_len = MINU (.rfp [nam$b_type], 4);		! Maximum type is three (plus the separating dot)
IF .tot_len NEQ .typ_len			! If length not same as start, then it has changed
THEN
    out_filb [filb$v_name_change] = true;

tot_len = .nam_len + .typ_len;			! Final length of both
out_filb [filb$l_result_name_len] = .volb [volb$l_vol_ident_len] + .tot_len;	! Length of volume ident
$logic_check (2, (.out_filb [filb$l_result_name_len] LEQU filb$s_result_name), 256);
CH$COPY (.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident],			! Volume name
		.nam_len, .rfp [nam$l_name], .typ_len, .rfp [nam$l_type],
		0, filb$s_result_name, out_filb [filb$t_result_name]);

$debug_print_fao ('Looking for "!AF"', .out_filb [filb$l_result_name_len], out_filb [filb$t_result_name]);

! Make sure that the input and output files are not on the same device
!
IF .volb EQL .inp_volb
THEN
    RETURN exch$_illmtcopy;

! Reset the rest of the block to nulls, nothing carries over from before
!
CH$FILL (0, dos11ctx$k_end_zero - dos11ctx$k_start_zero,	! Set rest of block to nulls
		.out_ctx + dos11ctx$k_start_zero);

! If an /ALLOCATION qualifier has been seen, tell user we are ignoring
!
IF .inp_filb [filb$l_q_allocation] NEQ 0	! If specified on the input
 OR
   .copy [copy$l_q_allocation] NEQ 0		!   or on the output
THEN
    $exch_signal (exch$_noalloc);		!?? also /CONT /BEST ...

! Make sure that the record format in the filb is correct
!
exch$cmd_fetch_recfmt_implied (.out_filb, .rfp [nam$l_type]+1);	! Pass it the type from the parse

! Save the addresses of our routines for this volume and record format.
!
out_filb [filb$a_close_routine] = exch$dos11_close_file;
out_filb [filb$a_delete_routine] = exch$dos11_close_file;
out_filb [filb$a_get_routine] = 0;
out_filb [filb$a_put_routine] = exch$pdp_put;

! Carriage control doesn't mean anything for DOS-11 output, tell him we are ignoring
!
IF .inp_filb [filb$v_cctl_explicit]
 OR
   .out_filb [filb$v_cctl_explicit]
THEN
    $exch_signal (exch$_nocarriage);

! For DOS-11 we can treat block transfer mode as fixed 512
!
IF .out_filb [filb$b_transfer_mode] EQL filb$k_xfrm_block
  OR
   .inp_filb [filb$b_transfer_mode] EQL filb$k_xfrm_block
THEN
    BEGIN
    out_filb [filb$b_rec_format]  = filb$k_rfmt_fixed;
    out_filb [filb$l_fixed_len]   = 512;
    END;

! In some circumstances we can do block mode I/O rather than record mode
!
IF  (.inp_filb [filb$b_transfer_mode] EQL filb$k_xfrm_automatic	! Both input and output must be automatic transfer
     AND .out_filb [filb$b_transfer_mode] EQL filb$k_xfrm_automatic)
  AND
    ( NOT (.inp_filb [filb$v_rfmt_explicit] 			! Both the input and output files must have 
	OR .out_filb [filb$v_rfmt_explicit]))			!  implied record formats
  AND
    (.inp_namb [namb$b_vol_format] EQL volb$k_vfmt_dos11	! The input must be DOS-11
     OR .inp_namb [namb$b_vol_format] EQL volb$k_vfmt_rt11)	!  or RT-11
THEN
    BEGIN
    $debug_print_lit ('using block transfer mode');
    inp_filb [filb$b_rec_format]  = filb$k_rfmt_fixed;
    inp_filb [filb$l_fixed_len]   = 512;
    out_filb [filb$b_rec_format]  = filb$k_rfmt_fixed;
    out_filb [filb$l_fixed_len]   = 512;
    END;

! Make sure that the directory list is complete
!
ent = exch$util_dos11ctx_allocate (.volb, 0);		! Grab a context block for the loop
temp = dosnxt$m_rewind OR dosnxt$m_count_blocks;	! Rewind for the first file
WHILE exch$dos11_next_entry (.ent, .temp) NEQ 0
DO
    temp = dosnxt$m_count_blocks;			! Just count for later files
exch$util_dos11ctx_release (.ent);			! Return the context block

! Position the tape, if the directory list is empty, we must rewind the tape so that we don't put
! the files after the initial tape mark
!
IF $queue_empty (dosv [dos11$q_entry_header])
THEN
    BEGIN
    $trace_print_lit ('empty queue, rewinding');
    IF NOT exch$io_dos11_rewind (.volb)
    THEN
	RETURN 0;
    END

! Move to the end of the tape
!
ELSE
    BEGIN

    ! Our end_of_tape is actually after the second tape mark, so backspace if we are at EOT
    !
    IF .dosv [dos11$v_end_of_tape]
    THEN
	BEGIN
	dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;	! Adjust the file number for the skip
	dosv [dos11$v_end_of_tape] = false;		! The skip file routine looks at this bit, we need to hide the
	temp = -1;					! fact that we are at end-of-tape
	END

    ! Not at EOT, skip a very, very large number of files to find the end
    !
    ELSE
	temp = 32767;

    ! No do the actual skip
    !
    IF NOT exch$io_dos11_skip_file (.volb, .temp)
    THEN
	RETURN 0;
    END;

! Create an entry
!
ent = exch$util_vm_allocate_zeroed (dos11ent$k_length);	! Allocate the memory

! Get the date into dos11 format
!
exch$dos11_form_cur_date (.ent);

! Convert the file name to radix 50 and store in the entry
!
exch$util_radix50_from_ascii (MINU (.nam_len, 6),		! First 6 bytes
		.rfp [nam$l_name], 6, ent [dos11ent$l_filename_1]);
IF .nam_len GTR 6						! Last 3 bytes
THEN
    exch$util_radix50_from_ascii (.nam_len-6,			
		.rfp [nam$l_name] + 6, 3, ent [dos11ent$w_filename_2]);
exch$util_radix50_from_ascii (.typ_len-1,
		.rfp [nam$l_type]+1, dos11ctx$s_exp_type, ent [dos11ent$w_filetype]);

! Move the standard protection code
!
ent [dos11ent$w_protection] = %O '233';

! Set the uic to that of the current process, unless the /BY_OWNER qualifier is in effect in which case use
! the uic of the input (Files-11 only) file.  !?? no /by_owner yet
!
ent [dos11ent$b_member] = MINU (.exch$a_gbl [excg$w_uic_member], 255);
ent [dos11ent$b_group]  = MINU (.exch$a_gbl [excg$w_uic_group], 255);

$trace_print_fao ('dosv current file !UL', .dosv [dos11$l_current_file]);
$trace_print_fao ('     beg_of_tape  !UL', .dosv [dos11$v_beg_of_tape]);
$trace_print_fao ('     tape_mark    !UL', .dosv [dos11$v_tape_mark]);
$trace_print_fao ('     end_of_tape  !UL', .dosv [dos11$v_end_of_tape]);

! Store the file number in the entry
!
$trace_print_fao ('storing dosv file number !UL into entry', .dosv [dos11$l_current_file]);
ent [dos11ent$w_file_number] = .dosv [dos11$l_current_file];

! Declare an exit handler to "close" the file if an exit occurs while it is open
!
$logic_check (1, (.exch$a_gbl [excg$a_exh_routine] EQL 0), 311);
$logic_check (2, (NOT (.out_ctx [dos11ctx$v_output_file] OR .out_ctx [dos11ctx$v_stream_active])), 312);
exch$a_gbl [excg$a_exh_routine]		= exch$dos11_exit_handler;		! Routine to write the tapemarks
exch$a_gbl [excg$l_exh_arg_count]	= 2;					! Status and volb
exch$a_gbl [excg$a_exh_status]		= exch$a_gbl [excg$l_exh_condvalu];	! Address to store status
exch$a_gbl [excg$a_exh_volb]		= .volb;				! Pass address of volb

IF NOT (status = $dclexh (desblk=exch$a_gbl [excg$r_exit_block]))
THEN
    $exch_signal_stop (.status);

! Now write the label and put a copy of the label into the context block
!
IF NOT (status = exch$io_dos11_write_label (.volb, ent [dos11ent$l_filename_1]))
THEN
    BEGIN

    ! If the tape went into the end region
    !
    IF .status EQL ss$_endoftape
    THEN
	BEGIN

	! We did actually write the label, so backspace and put a tapemark on top of it and adjust the file count
	!
	exch$io_dos11_skip_record (.volb, -1);
	exch$io_dos11_write_tape_mark (.volb);
!??	dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] - 1;		! Adjust the file number

	! Rewind the tape so that the exact position will be known again
	!
!??	$exch_signal (exch$_dos11_position);	! This might take a while, warn 'em
!??	dosv [dos11$v_error_rewind] = true;	! Remember that we have had to forcibly reposition the tape
	dosv [dos11$v_directory] = true;	! Keep it from shooting off the end to find the directory
!??	exch$io_dos11_rewind (.volb);
	END;

    ! Cancel the exit handler which was declared to write the tape marks
    !
    $canexh (desblk=exch$a_gbl [excg$r_exit_block]);
    exch$a_gbl [excg$a_exh_routine] = 0;	! Clear address, means no exit handler is active

    RETURN 0;
    END;

! Add the label entry to the end of the list, now that we have written the label
!
$queue_insert_tail (.ent, dosv [dos11$q_entry_header]);	! Add it to the tail
dosv [dos11$a_current_entry] = .ent;			! Make it the current entry (but not the current file)

! Copy the label entry to the context block
!
CH$MOVE (dos11ctx$s_entry, ent [dos11ent$l_filename_1], out_ctx [dos11ctx$t_entry]);

! Define a record stream for this file
!
out_ctx [dos11ctx$l_cur_byte]	= 0;					! Context is the first byte in
out_ctx [dos11ctx$l_cur_block]	= 0;					!  the first block of the file
out_ctx [dos11ctx$l_eof_block]	= -1;
out_filb [filb$a_record]	= 0;					! No valid record or length
out_filb [filb$l_record_len]	= 0;

! Expand the radix-50 filename into the standard ascii text fields
!
exch$dos11_expand_filename (.out_ctx);

! Clear all the flags except the ones we want by writing the masks into the longword
!
out_ctx [dos11ctx$l_flags] =    dos11ctx$m_stream_active	! A record stream is currently active
			     OR dos11ctx$m_output_file;		!  and it is an output file

! Set up the i/o and record buffer
!
IF .out_ctx [dos11ctx$a_buffer] EQL 0
THEN
    out_ctx [dos11ctx$a_buffer] = exch$util_vm_allocate (ctx$k_buffer_length);

! Set the block pointers to the chunk we are ready to write (i.e. nothing, 'cuz we've done no puts)
!
out_ctx [dos11ctx$l_buf_base_block] = 0;
out_ctx [dos11ctx$l_buf_high_block] = ctx$k_buffer_blocks - 1;

RETURN true;
END;

GLOBAL ROUTINE exch$dos11_directory (volb : $ref_bblock) =	%SBTTL 'exch$dos11_directory'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Traverse the DOS-11 directory and display the contents
!
! INPUTS:
!
!	volb - pointer to volb which has been connected to the DOS-11 device
!
! IMPLICIT INPUTS:
!
!	dire - directory work area
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true if valid, false if not
!
! SIDE EFFECTS:
!
!	error conditions will be signaled
!--

$dbgtrc_prefix ('dos11_directory> ');

LOCAL
    nam : $ref_bblock,				! a pointer to the namb block
    ctx : $ref_bblock,				! a pointer to an DOS-11 context block
    wid,
    blocks_displayed,
    files_displayed,
    faop : $ref_bblock,				! pointer to an fao output
    status,
    flags
    ;

BIND
    dire = exch$a_gbl [excg$a_dire_work]	: $ref_bblock,	! pointer to work area
    fab  = dire [dire$a_outfab]		: $ref_bblock,	! pointer to fab for output file
    rab  = dire [dire$a_outrab]		: $ref_bblock,	! pointer to rab for output file
    dosv = volb [volb$a_vfmt_specific]	: $ref_bblock	! pointer to dos11 structure
    ;

$block_check (2, .dire, dire, 617);		! Check that the directory work area is valid
$block_check (2, .volb, volb, 618);
$block_check (2, .dosv, dos11, 622);

$trace_print_lit ('calling dump_dosv');
$check_call (4, exch$dbg_dump_dosv, .volb);
%IF switch_check				! If checking is on look at all the nambs
%THEN
    nam = .volb [volb$a_namb_head];		! Get the address of the first namb chained to the volb
    $logic_check (2, (.nam NEQ 0), 264);
    WHILE .nam NEQ 0
    DO
	BEGIN
	$block_check (2, .nam, namb, 597);
	nam = .nam [namb$a_next];
	END;
%FI

! Determine the width of a directory item
!
wid = dos11ctx$s_exp_fullname;					! Name and pointer are always there

IF .dire [dire$v_q_owner]					! Is /OWNER present?
THEN
    wid = .wid + dos11ctx$s_exp_directory;

IF .dire [dire$v_q_size]					! Is /SIZE present?
THEN
    wid = .wid + (IF .dire [dire$v_q_octal] THEN 7 ELSE 5);

IF .dire [dire$v_q_date]					!  or /DATE?
THEN
    wid = .wid + dos11ctx$s_exp_date + 1;

IF .dire [dire$v_q_full]					!  or /FULL? (add protection)
THEN
    wid = .wid + 6;						! Protection is always in octal

! Compute the number of columns for the listing
!
dire [dire$l_item_width] = .wid;				! Put the value in the work area
dire [dire$l_list_width] = .dire [dire$l_list_width] -1;	! Make a place for the '>' against left column
exch$dire_get_columns ();					! Fetch the number of columns
dire [dire$l_list_width] = .dire [dire$l_list_width] +1;	! Restore the original listing width

! Print the header information
!
exch$dire_put (null_string);							! Print a blank line
faop = exch$util_fao_buffer (%ASCID 'Directory of DOS-11 volume !AF      !%D',	! Format the header line
		.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], 0);
faop [dsc$w_length] = .faop [dsc$w_length] - 6;					! Remove the seconds field from the date-time
exch$dire_put (.faop);								! Print the header line
exch$dire_put (null_string);							!  and another blank line

! Initialize the local variables
!
status = true;					! Assume that we will find some files
blocks_displayed = 0;
files_displayed = 0;

! Purchase an DOS11 context block
!
ctx = exch$util_dos11ctx_allocate (.volb, 0);

! Loop through all the labels in the directory
!
dosv [dos11$v_current_marked] = false;
flags = dosnxt$m_rewind OR dosnxt$m_count_blocks;	! Rewind for the first file
WHILE exch$dos11_next_entry (.ctx, .flags) NEQ 0
DO
    BEGIN

    ! If we have aborted, exit the loop
    !
    IF .exch$a_gbl [excg$v_control_c]
    THEN
	EXITLOOP;

    flags = dosnxt$m_count_blocks;		! Just count for later files
    nam = .volb [volb$a_namb_head];		! Get first namb
    WHILE .nam NEQ 0				!  and loop through them all
    DO
	BEGIN
	BIND						! Need the name and type from the
	    nam_nam = nam [namb$q_name] : $desc_block,	!  command input because we need
	    nam_typ = nam [namb$q_type] : $desc_block;	!  to compare this name against
							!  any selections in the command
	IF exch$cmd_match_filename
		(.ctx [dos11ctx$l_exp_fullname_len], ctx [dos11ctx$t_exp_fullname],
		.nam_nam [dsc$w_length] + .nam_typ [dsc$w_length], .nam_nam [dsc$a_pointer])
	  AND
	   dos11_match_uic (.ctx, .nam)
	THEN
	    BEGIN
	    exch$dos11_dire_put_item (.ctx);
	    files_displayed = .files_displayed + 1;			! update trailer statistics
	    blocks_displayed = .blocks_displayed + .ctx [dos11ctx$w_blocks];
	    EXITLOOP;
	    END;
	nam = .nam [namb$a_next];					! to next namb in chain
	END;
    END;

! If we have canceled the listing, tell about it
!
IF .exch$a_gbl [excg$v_control_c]
THEN
    $exch_signal ($info_stat_copy (exch$_canceled))

ELSE
    BEGIN

    ! If the tape is at eof and we have printed some files, print the eot marker
    !
    IF  (NOT .dosv [dos11$v_current_marked])
      AND
        (.dire [dire$v_items_printed])
      AND
	(NOT .dosv [dos11$v_error_rewind])
    THEN
	exch$dos11_dire_put_item (1);		! 1 means print a "-> (end-of-tape)"

    IF .dire [dire$l_cur_column] NEQ 0		! If anything is waiting, print it
    THEN
	exch$dos11_dire_put_item (0);		! 0 means flush the buffer

    ! If we printed some items, then add an extra blank line
    !
    IF .dire [dire$v_items_printed]
    THEN
	exch$dire_put (null_string, true)		! Cancel CTRL/O with second parm

    ! Nothing was printed, return a warning status so that command procedures can see whether files were found.
    !
    ELSE
	status = $info_stat_copy (rms$_fnf);	! Let a guy see that $ EXC DIR CS1:DEFBOO.CMD didn't work

    ! Print the statistics line
    !
    faop = (IF .dire [dire$v_q_octal]
	    THEN
		%ASCID 'Total of !OW file!%S, !OW block!%S.  (octal)'
	    ELSE
		%ASCID 'Total of !UL file!%S, !UL block!%S.      (">" marks current tape position)');
    faop = exch$util_fao_buffer (.faop, .files_displayed, .blocks_displayed);
    exch$dire_put (.faop);
    END;

! Free up the context block.
!
exch$util_dos11ctx_release (.ctx);

RETURN .status;
END;

GLOBAL ROUTINE exch$dos11_dire_put_item (ctx : $ref_bblock) : NOVALUE =	%SBTTL 'exch$dos11_dire_put_item'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Add a single item to the output listing, writing the record if we hit the column count
!
! INPUTS:
!
!	ctx  - an DOS11 directory entry context block, if address is zero, means write buffer.
!
! IMPLICIT INPUTS:
!
!	dire - directory work area
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true if put succeeded, false if not
!
! SIDE EFFECTS:
!
!	error conditions will be signaled
!--

$dbgtrc_prefix ('dos11_dire_put_item> ');

LOCAL
    desc : VECTOR [2, LONG],
    status
    ;

REGISTER
    wid						! current listing width
    ;

BIND
    dire = exch$a_gbl [excg$a_dire_work]	: $ref_bblock,			! pointer to work area
    buf = dire [dire$t_list_buffer] : VECTOR [dire$s_list_buffer, BYTE]	! output buffer
    ;


$block_check (2, .dire, dire, 598);

! Perform a couple of sanity checks
!
$logic_check (2, (.dire [dire$l_cur_column] LSSU .dire [dire$l_q_columns]), 265);
$logic_check (2, (.dire [dire$l_cur_width]  LSSU .dire [dire$l_list_width]), 266);

! Perform required initializations
!
dire [dire$v_items_printed] = true;		! one or more items has been printed
wid = .dire [dire$l_cur_width];			! a fast register for the current width

! An input address of 0 means that we should flush the buffer
!
IF (.ctx EQL 0)
THEN
    BEGIN

    IF .wid GTR 0
    THEN
	BEGIN
	desc [0] = .wid;
	desc [1] = buf [0];
	exch$dire_put (desc);
	END;

    dire [dire$l_cur_column] = 0;
    dire [dire$l_cur_width] = 0;
    RETURN true;
    END;

! Add the separator to the buffer
!
IF .dire [dire$l_cur_column] NEQ 0
THEN
    BEGIN
    CH$FILL (%C ' ', dire$k_item_spacing, buf [.wid]);
    wid = .wid + dire$k_item_spacing;
    END
ELSE
    BEGIN
    buf [.wid] = %C ' ';
    wid = .wid + 1;
    END;

! If the ctx is a 1, then print a "->(end-of-tape)"
!
IF .ctx EQL 1
THEN
    BEGIN
    CH$MOVE (%CHARCOUNT ('> (end-of-tape)'),  UPLIT BYTE ('> (end-of-tape)'), buf [.wid -1]);
    wid = .wid + %CHARCOUNT ('> (end-of-tape)') -1;
    END

! CTX should be a valid pointer, print the file info
!
ELSE
    BEGIN
    $block_check (2, .ctx, dos11ctx, 621);

    ! We always add the pointer to the directory if this is the current file
    !
    IF .ctx [dos11ctx$v_pointer]
    THEN
	buf [.wid -1] = %C '>';

    ! Add the owner directory to the buffer if requested
    !
    IF .dire [dire$v_q_owner]
    THEN
	BEGIN
	CH$MOVE (dos11ctx$s_exp_directory, ctx [dos11ctx$t_exp_directory], buf [.wid]);
	wid = .wid + dos11ctx$s_exp_directory;
	END;

    ! We always add the filename and directory to the buffer
    !
    CH$MOVE (dos11ctx$s_exp_fullname, ctx [dos11ctx$t_exp_fullname], buf [.wid]);
    wid = .wid + dos11ctx$s_exp_fullname;

    ! Add the file size if requested
    !
    IF .dire [dire$v_q_size]
    THEN
	BEGIN
	LOCAL
	    addwid,
	    ctrstr;
	IF .dire [dire$v_q_octal]
	THEN
	    BEGIN
	    addwid = 7;
	    ctrstr = %ASCID ' !6OW';
	    END
	ELSE
	    BEGIN
	    addwid = 5;
	    ctrstr = %ASCID '!5UL';
	    END;
	desc [0] = .addwid;
	desc [1] = buf [.wid];
	IF NOT (status = $fao (.ctrstr, 0, desc, .ctx [dos11ctx$w_blocks]))
	THEN
	    $exch_signal_stop (.status);

	wid = .wid + .addwid;
	END;

    ! Add the date if requested
    !
    IF .dire [dire$v_q_date]
    THEN
	BEGIN
	CH$MOVE (1, UPLIT BYTE (' '), buf [.wid]);
	wid = .wid + 1;
	CH$MOVE (dos11ctx$s_exp_date, ctx [dos11ctx$t_exp_date], buf [.wid]);
	wid = .wid + dos11ctx$s_exp_date;
	END;

    ! Add the protection if /FULL requested
    !
    IF .dire [dire$v_q_full]
    THEN
	BEGIN
	LOCAL
	    addwid,
	    ctrstr;
	addwid = 6;
	ctrstr = %ASCID ' <!3OB>';
	desc [0] = .addwid;
	desc [1] = buf [.wid];
	IF NOT (status = $fao (.ctrstr, 0, desc, .ctx [dos11ctx$w_protection]))
	THEN
	    $exch_signal_stop (.status);

	wid = .wid + .addwid;

	END;
    END;

! Do we need to flush?
!
IF (dire [dire$l_cur_column] = .dire [dire$l_cur_column] + 1) GEQU .dire [dire$l_q_columns]
THEN
    BEGIN

    desc [0] = .wid;
    desc [1] = buf [0];
    exch$dire_put (desc);
    dire [dire$l_cur_column] = 0;
    wid = 0;
    END;

dire [dire$l_cur_width] = .wid;

RETURN;
END;

GLOBAL ROUTINE exch$dos11_exit_handler (status,	%SBTTL 'exch$dos11_exit_handler (status, volb)'
					volb : $ref_bblock) : NOVALUE = 
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write two tapemarks at the end of the tape
!
! INPUTS:
!
!	status - pointer to status code
!	volb - pointer to volb which has been connected to the DOS-11 device
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	any modified directory segments will be written
!--

$dbgtrc_prefix ('dos11_exit_handler> ');

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 431);
$block_check (2, .dosv, dos11, 432);

$trace_print_fao ('entry - volb !XL', .volb);

! If it looks like the tape can be written (i.e. no serious errors have occurred) try to write the tapemarks
!
IF .dosv [dos11$v_position_valid]		! We should know where we are
  AND
   .dosv [dos11$v_end_of_tape]			!  and that should be at the end.
THEN
    BEGIN

    ! Write two tape marks to mark the end of the tape
    !
    exch$io_dos11_write_tape_mark (.volb);
    exch$io_dos11_write_tape_mark (.volb);

    END;

RETURN;
END;

GLOBAL ROUTINE exch$dos11_expand_filename (ctx : $ref_bblock) : NOVALUE =	%SBTTL 'exch$dos11_expand_filename (ctx)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Convert the information in a directory entry to ascii text.  This involves changing the RADIX-50
!	filename to ASCII and converting the date to ASCII.
!
! INPUTS:
!
!	ctx - pointer to an dos11ctx structure which contains a copy of the directory entry
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	ctx - receives ASCII filename info
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	success or failure if the entry is invalid
!
! SIDE EFFECTS:
!
!	error conditions will be signaled
!--

$dbgtrc_prefix ('dos11_expand_filename> ');

LOCAL
    dayomon : REF VECTOR [12, BYTE],
    year,
    mon,
    day,
    date_desc : VECTOR [2, LONG],
    status,
    ch
    ;

BIND
    volb = ctx [dos11ctx$a_assoc_volb]		: $ref_bblock,
    dosv = volb [volb$a_vfmt_specific]		: $ref_bblock
    ;

$debug_print_fao ('entry - ctx !XL', .ctx);
$block_check (2, .ctx, dos11ctx, 599);
$block_check (2, .volb, volb, 619);
$block_check (2, .dosv, dos11, 620);

! Convert the file name from 3 Radix-50 words to 'dos11ctx$s_exp_name' ASCII characters, type from 1 R50 word to
! 'dos11ctx$s_exp_type' chars
!
exch$util_radix50_to_ascii (6, ctx [dos11ctx$l_filename_1], ctx [dos11ctx$t_exp_name]);
exch$util_radix50_to_ascii (3, ctx [dos11ctx$w_filename_2], ctx [dos11ctx$t_exp_name]+6);
ch = CH$FIND_CH (dos11ctx$s_exp_name, ctx [dos11ctx$t_exp_name], ' ');
ctx [dos11ctx$l_exp_name_len] = (IF .ch EQL 0 THEN dos11ctx$s_exp_name ELSE .ch - ctx [dos11ctx$t_exp_name]);

exch$util_radix50_to_ascii (dos11ctx$s_exp_type, ctx [dos11ctx$w_filetype], ctx [dos11ctx$t_exp_type]);
ch = CH$FIND_CH (dos11ctx$s_exp_type, ctx [dos11ctx$t_exp_type], ' ');
ctx [dos11ctx$l_exp_type_len] = (IF .ch EQL 0 THEN dos11ctx$s_exp_type ELSE .ch - ctx [dos11ctx$t_exp_type]);

! Create a filename in the standard, non-embedded blank format by concatenating the name, a "." and the type.
!
ctx [dos11ctx$l_exp_fullname_len] = .ctx [dos11ctx$l_exp_name_len] + 1 + .ctx [dos11ctx$l_exp_type_len];
CH$COPY (.ctx [dos11ctx$l_exp_name_len], ctx [dos11ctx$t_exp_name],		! the file name
	 1, UPLIT BYTE ('.'),							! the "." separator
	 .ctx [dos11ctx$l_exp_type_len], ctx [dos11ctx$t_exp_type],		! the file type
	%C ' ', dos11ctx$s_exp_fullname, ctx [dos11ctx$t_exp_fullname]);	! the blank-padded result

! Create an ASCII representation of the date
!
IF .ctx [dos11ctx$w_date] EQL 0
THEN
    CH$MOVE (dos11ctx$s_exp_date, UPLIT BYTE (' < nodate >'), ctx [dos11ctx$t_exp_date])
ELSE
    BEGIN
    year = 1970 + (.ctx [dos11ctx$w_date]/1000);! 1970 is stored as zero
    day  = .ctx [dos11ctx$w_date] MOD 1000;	! Day of year is stored as remainder
    dayomon =  (IF .year <0,2,0> EQL 0		! Pick leap year or regular depending
		THEN days_of_months_leapyear	!  on whether year is divisible by 4
		ELSE days_of_months);
    mon = 0;
    WHILE .day GTRU .dayomon [.mon] 		! Subtract out number of days in each month until we are within
	AND					!  a month
	  .mon LSSU 12				! (Print *** if we didn't find it)
    DO
	BEGIN
	day = .day - .dayomon [.mon];
	mon = .mon + 1;
	END;
    date_desc [0] = dos11ctx$s_exp_date;		! set up a descriptor for FAO
    date_desc [1] = ctx [dos11ctx$t_exp_date];
    IF NOT (status = $fao (%ASCID '!2UL-!AF!4UL', 0, date_desc, .day, 4, months [.mon], .year))
    THEN
	$exch_signal_stop (.status);
    END;

! If the tape is currently at this file, mark for the pointer
!
IF .ctx [dos11ctx$w_file_number] EQL .dosv [dos11$l_current_file]
THEN
    BEGIN
    ctx [dos11ctx$v_pointer] = true;
    dosv [dos11$v_current_marked] = true;
    END
ELSE
    ctx [dos11ctx$v_pointer] = false;

! Create an ASCII representation of the UIC format directory
!
date_desc [0] = dos11ctx$s_exp_directory;	! set up a descriptor for FAO
date_desc [1] = ctx [dos11ctx$t_exp_directory];
IF NOT (status = $fao (%ASCID '[!3OB,!3OB] ', 0, date_desc, .ctx [dos11ctx$b_group], .ctx [dos11ctx$b_member]))
THEN
    $exch_signal_stop (.status);

END;

GLOBAL ROUTINE exch$dos11_find_file (ctx : $ref_bblock, name, name_len) =	%SBTTL 'exch$dos11_find_file (ctx, name, name_len)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Search for a specific file on a DOS-11 magtape
!
! INPUT:
!
!	ctx	 - pointer to a DOS11CTX structure
!	name	 - pointer to the start of the file name for which to search
!	name_len - length of the name
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	ctx	 - if a file is found, the context block will describe it
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true if able to find the file, false otherwise
!
! SIDE EFFECTS:
!
!	none
!--
$dbgtrc_prefix ('dos11_find_file> ');

LOCAL
    flags
    ;

BIND
    copy = exch$a_gbl [excg$a_copy_work]	: $ref_bblock,
    inp_filb = copy [copy$a_inp_filb]		: $ref_bblock,
    namb     = inp_filb [filb$a_assoc_namb]	: $ref_bblock    
    ;

! Loop through all the labels in the directory
!
flags = (IF .copy [copy$v_q_rewind] THEN dosnxt$m_rewind ELSE 0);	! Rewind for the first file
copy [copy$v_q_rewind] = 0;						! But only for the first file

WHILE exch$dos11_next_entry (.ctx, .flags) NEQ 0
DO
    BEGIN

    flags = 0;					! Don't rewind for later files

    IF exch$cmd_match_filename
		(.ctx [dos11ctx$l_exp_fullname_len], ctx [dos11ctx$t_exp_fullname], .name_len, .name)
      AND
	   dos11_match_uic (.ctx, .namb)
    THEN
	RETURN 1;

    END;

RETURN 0;
END;

GLOBAL ROUTINE exch$dos11_form_cur_date (ent : $ref_bblock) : NOVALUE jsb_r1 =	%SBTTL 'exch$dos11_form_cur_date (ent)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Format the current date, placing it into the date field of an DOS-11 directory entry
!
! INPUT:
!
!	ent - pointer to the directory entry
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('dos11_form_cur_date> ');

LOCAL
    date : WORD,
    dayomon : REF VECTOR [12, BYTE],
    timbuf : VECTOR [7, WORD]
    ;

BIND
    year = timbuf [0] : WORD, month = timbuf [1] : WORD, day = timbuf [2] : WORD;

$numtim (timbuf=timbuf);

date = (.year - 1970) * 1000;			! Multiply years since 1970 times 100

dayomon =  (IF .year <0,2,0> EQL 0		! Pick leap year or regular depending
	    THEN days_of_months_leapyear	!  on whether year is divisible by 4
	    ELSE days_of_months);

INCR mon FROM 0 TO .month-2			! Subtract 1 to convert 1-12 to 0-11 and one because we do not want
DO						!  current month, add days of previous months to the year
    date = .date + .dayomon [.mon];

date = .date + .day;				! Add days of this month

ent [dos11ent$w_date] = .date;			! Store the final DOS-11 date

RETURN;
END;

GLOBAL ROUTINE dos11_match_uic (ctx : $ref_bblock, namb : $ref_bblock) : jsb_r0r1 =	%SBTTL 'dos11_match_uic'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Check to see if the uic info from the nam block match those of the file
!
! INPUTS:
!
!	ctx  - pointer to dos11ctx block
!	namb - pointer to namb block
!
! ROUTINE VALUE:
!
!	true if the file is selected by the namb, false if not
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('dos11_match_uic> ');

IF NOT .namb [namb$v_uic_directory]		! If no directory specified, it matches
THEN
    RETURN 1;

IF NOT .namb [namb$v_wild_group]		! If group not wild, we must check group
THEN
    IF .namb [namb$b_uic_group] NEQ .ctx [dos11ctx$b_group]
    THEN
	RETURN 0;

IF NOT .namb [namb$v_wild_member]		! If member not wild, we must check member
THEN
    IF .namb [namb$b_uic_member] NEQ .ctx [dos11ctx$b_member]
    THEN
	RETURN 0;

RETURN 1;
END;

GLOBAL ROUTINE exch$dos11_mount (volb : $ref_bblock) =	%SBTTL 'exch$dos11_mount (volb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Perform DOS-11 volume specific mount processing
!
! INPUTS:
!
!	volb - pointer to volb which has been connected to the DOS-11 device
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('dos11_mount> ');

LOCAL
    dosv : $ref_bblock,				! a pointer to the dos11 volb extension
    status
    ;

$debug_print_lit ('entry');

$block_check (2, .volb, volb, 590);
$logic_check (3, (.volb [volb$a_vfmt_specific] EQL 0), 259);

! Allocate and initialize our volb extension
!
dosv = exch$util_vm_allocate (exchblk$s_dos11);
CH$FILL (0, dos11$k_end_zero - dos11$k_start_zero, .dosv + dos11$k_start_zero);	! Set part of block to nulls

volb [volb$a_vfmt_specific] = .dosv;			! Store the address of the extension

$block_init (.dosv, dos11);				! Set the block type and size fields

$queue_initialize (dosv [dos11$q_entry_header]);	! Init the queue of directory entries

! Rewind the magtape, since that is the only way we can know what the initial position is
!
IF NOT (status = exch$io_dos11_rewind (.volb))
THEN
    RETURN .status;

! Read the magtape label as a sanity check, we should have either a label or end of tape
!
IF NOT (status = exch$io_dos11_read_label (.volb))
THEN
    IF NOT .dosv [dos11$v_end_of_tape]
    THEN
	RETURN .status;

! Rewind the magtape again, since the beginning is a good place to start
!
IF NOT (status = exch$io_dos11_rewind (.volb))
THEN
    RETURN .status;

! Set the volume type field
!
CH$MOVE (6, UPLIT BYTE ('DOS-11'), volb [volb$t_vol_type]);
volb [volb$l_vol_type_len] = 6;

RETURN 1;
END;

GLOBAL ROUTINE exch$dos11_next_entry (ctx : $ref_bblock, flags : $bblock) =	%SBTTL 'exch$dos11_next_entry (ctx, flags)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Return the next entry from an DOS-11 directory
!
! INPUT:
!
!	ctx   - pointer to an dos11ctx structure
!	flags - a structure of bits with the following meanings:
!
!			  flags [dosnxt$v_rewind]	- start at the beginning of the tape
!			  flags [dosnxt$v_count_blocks]	- make sure that the block count is valid
!
! IMPLICIT INPUTS:
!
!	anything we can find hanging off the context block
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	the context block is updated with context necessary for wildcard processing
!
! ROUTINE VALUE:
!
!	true if next entry is now inside ctx, 0 if no more entries
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('dos11_next_entry> ');

LOCAL
    ent : $ref_bblock,
    status
    ;

BIND
    volb = ctx [dos11ctx$a_assoc_volb]	: $ref_bblock,
    dosv = volb [volb$a_vfmt_specific]	: $ref_bblock
    ;

$debug_print_fao ('entry - ctx !XL', .ctx);
$block_check (2, .ctx, dos11ctx, 608);
$block_check (2, .volb, volb, 609);
$block_check (2, .dosv, dos11, 610);

! If the rewind flag is set, then point the current entry at the queue header
!
IF .flags [dosnxt$v_rewind] 
THEN
    BEGIN
    $debug_print_lit ('"rewinding"');
    dosv [dos11$a_current_entry] = dosv [dos11$q_entry_header];
    dosv [dos11$v_error_rewind]  = false;
    END;

! Move to the next entry, by moving to the entry after the current entry
!
$debug_print_fao ('entry before moving !XL', .dosv [dos11$a_current_entry]);
ent = ..dosv [dos11$a_current_entry];
$debug_print_fao ('entry after  moving !XL', .ent);

! If the pointer points to the queue header, we have reached the end of the list
!
IF .ent EQL dosv [dos11$q_entry_header]
THEN
    BEGIN

    ! If there has been a rewind due to error, we want to fake the directory as being complete
    !
    IF .dosv [dos11$v_error_rewind]
    THEN
	dosv [dos11$v_directory] = true;

    ! If the directory bit is set, then the list contains the entire directory and we are done
    !
    IF .dosv [dos11$v_directory]
    THEN
	BEGIN
	dosv [dos11$a_current_entry] = .ent;	! Save the pointer, effectively rewounds to beginning of tape
	RETURN 0;				! We return 0, which signals that there is no next entry
	END

    ! Directory bit is not set, we need to read an additional label and create an entry
    !
    ELSE
	BEGIN
	LOCAL
	    last : $ref_bblock;			! pointer to last entry

	! Make sure that the tape is correctly positioned after the last known file
	!
	last = .dosv [dos11$a_entry_blink];		! Get a pointer to the last entry in the queue
	IF .last NEQ dosv [dos11$q_entry_header]	! If there are no entries, skip the position
	THEN
	    BEGIN

	    ! If the tape position has been lost, rewind the tape so that the position will be known again
	    !
	    IF NOT .dosv [dos11$v_position_valid]
	    THEN
		BEGIN
		$exch_signal (exch$_dos11_position);	! This might take a while, warn 'em about it
		IF NOT exch$io_dos11_rewind (.volb)
		THEN
		    RETURN 0;
		END;

	    ! Check to see if the current tape position is right after the last file
	    !
	    IF NOT (
		((.last [dos11ent$w_file_number] + 1) EQL .dosv [dos11$l_current_file])	! Is current one past last
		AND
		(.dosv [dos11$v_tape_mark])						! And are we at the mark
		   )
	    THEN
		BEGIN

	   	! Position to the last known entry, then skip to the next file
		!
		IF NOT exch$dos11_position_tape (.volb, .dosv [dos11$a_entry_blink])
		THEN
		    RETURN 0;
		IF NOT exch$io_dos11_skip_file (.volb, 1)
		THEN
		    RETURN 0;
		END;
	    END;

	! Read the label
	!
	status = exch$io_dos11_read_label (.volb);
	IF NOT .status
	THEN
	    BEGIN

	    ! If we found the end of the tape, record this fact and "rewind" the directory
	    !
	    IF .dosv [dos11$v_end_of_tape]	! Normal double tape mark end
	      OR
	       .status EQL ss$_endoftape	! Hit the physical end of tape in QIO
	    THEN
		BEGIN
		dosv [dos11$v_directory] = true;				! Directory is complete
		dosv [dos11$a_current_entry] = dosv [dos11$q_entry_header];	! Rewind the directory
		END;
		
	    RETURN 0;
	    END;

	! Create an entry and add it to the end of the list
	!
	ent = exch$util_vm_allocate_zeroed (dos11ent$k_length);	! Allocate the memory
	$queue_insert_tail (.ent, dosv [dos11$q_entry_header]);	! Add it to the tail

	! Copy the label information to the entry
	!
	CH$MOVE (dos11$s_label_buf, dosv [dos11$t_label_buf], ent [dos11ent$l_filename_1]);

	! Fill in the file number for this entry
	!
	$trace_print_fao ('storing dosv file number !UL into entry', .dosv [dos11$l_current_file]);
	ent [dos11ent$w_file_number] = .dosv [dos11$l_current_file];

	! If requested, fill in the size of the file
	!
	IF .flags [dosnxt$v_count_blocks]
	THEN
	    BEGIN
	    LOCAL
		stat2;

	    ! Count the blocks in the file, and store the count
	    !
	    stat2 = exch$io_dos11_count_blocks (.volb);		! Count the blocks
	    ent [dos11ent$w_blocks] = .dosv [dos11$w_block_count];	! Save the blocks even if an error, since
	    ent [dos11ent$v_blocks_valid] = true;			!  we don't want to try later (we won't
								    !  be able to do any better then)
	    $trace_print_fao ('count stat2 !XL', .stat2);
	    IF NOT .stat2
	    THEN
		BEGIN

		! If we hit the physical end of tape, treat it like a double tape mark and flag the directory
		! as being complete
		!
		IF .stat2 EQL ss$_endoftape
		THEN
		    BEGIN
		    $trace_print_lit ('ss$_endoftape, setting end of directory');
		    dosv [dos11$v_directory] = true;				! Directory is complete
		    dosv [dos11$a_current_entry] = dosv [dos11$q_entry_header];	! Rewind the directory
		    END
		ELSE
		    RETURN 0;			! Return failure
		END;
	    END;
	END;
    END;

!+
!
!  ENT now points to the directory entry
!
!-

! If we need the block count, but we don't have it, we will need to locate the file and count the blocks
!
IF .flags [dosnxt$v_count_blocks]
THEN
    IF NOT .ent [dos11ent$v_blocks_valid]
    THEN
	BEGIN

   	! Position to the last known entry, then skip to the next file
	!
	IF NOT exch$dos11_position_tape (.volb, .ent)
	THEN
	    RETURN 0;

	! Count the number of blocks to the next tape mark, value will be stored in dosv structure
	!
	IF NOT exch$io_dos11_count_blocks (.volb)
	THEN
	    RETURN 0;

	! Save the values in the entry
	!
	ent [dos11ent$w_blocks] = .dosv [dos11$w_block_count];
	ent [dos11ent$v_blocks_valid] = true;

	END;

! Copy the entry to the context block
!
$logic_check (3, ($BYTEOFFSET(dos11ctx$t_entry) EQL $BYTEOFFSET(dos11ctx$l_filename_1)), 252);
CH$MOVE (dos11ctx$s_entry, ent [dos11ent$l_filename_1], ctx [dos11ctx$t_entry]);

! Expand the directory entry filename information into the context block
!
exch$dos11_expand_filename (.ctx);

! Make this the current entry
!
dosv [dos11$a_current_entry] = .ent;

$debug_print_fao ('Found "!AF!AF", File number !UL, entry !XL',
		.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident],
		.ctx [dos11ctx$l_exp_fullname_len] + dos11ctx$s_exp_directory, ctx [dos11ctx$t_exp_directory],
		.ctx [dos11ctx$w_file_number], .ent);

RETURN 1;
END;

GLOBAL ROUTINE exch$dos11_open_file =	%SBTTL 'exch$dos11_open_file'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Perform DOS-11 volume specific open processing
!
! INPUT:
!
!	none
!
! IMPLICIT INPUTS:
!
!	copy work area
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	filb - receive info pertaining to the open file
!
! ROUTINE VALUE:
!
!	true if able to open a file, false otherwise
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('dos11_open_file> ');

LOCAL
    out_filb 	: $ref_bblock,
    status
    ;

BIND
    copy     = exch$a_gbl [excg$a_copy_work]	: $ref_bblock,
    inp_filb = copy [copy$a_inp_filb]		: $ref_bblock,
    ctx      = inp_filb [filb$a_context]	: $ref_bblock,
    namb     = inp_filb [filb$a_assoc_namb]	: $ref_bblock,
    nam_nam  = namb [namb$q_name]		: $desc_block,		! Get name and type components from
    nam_typ  = namb [namb$q_type]		: $desc_block,		!  the namb
    volb     = inp_filb [filb$a_assoc_volb]	: $ref_bblock,
    inp_namb = copy [copy$a_inp_namb]		: $ref_bblock
    ;

$debug_print_lit ('entry');

$block_check (2, .inp_filb, filb, 591);
$block_check (2, .namb, namb, 592);
$block_check (2, .volb, volb, 593);

! Make sure that the output filb points to a valid filb
!
IF (out_filb = .copy [copy$a_out_filb]) EQL 0
THEN
    out_filb = .inp_filb;
$block_check (2, .out_filb, filb, 473);

! If the context pointer is null, then allocate and initialize it.
!
IF .ctx EQL 0
THEN
    ctx = exch$util_dos11ctx_allocate (.volb, .inp_filb)	! Create an dos11 context block

! If non-null, we are doing a subsequent lookup in a wildcard search
!
ELSE
    BEGIN
    LITERAL
	wilds = (namb$m_wild_name OR namb$m_wild_type OR namb$m_wild_group OR namb$m_wild_member);

    ! If not wildcard, then we must be done
    !
    IF (.namb [namb$l_nameflags] AND wilds) EQL 0
    THEN
	RETURN false;

    $block_check (2, .ctx, dos11ctx, 594);

    END;

! Make sure that we haven't crossed signals someplace
!
$logic_check (4, (.ctx [dos11ctx$a_assoc_filb] EQL .inp_filb), 260);
$logic_check (4, (.ctx [dos11ctx$a_assoc_volb] EQL .volb), 261);

! We assume that the file name and type fields in the namb are adjacent.  If they aren't, the next call to
! exch$dos11_find_file will choke.
!
$logic_check (3, (.nam_typ [dsc$a_pointer] EQL (.nam_nam [dsc$w_length] + .nam_nam [dsc$a_pointer])), 262);

IF (
    IF .copy [copy$v_reopen_input]		! If we are retrying, then reuse the context block
    THEN
	1
    ELSE					! Otherwise skip to the next file
	exch$dos11_find_file (.ctx, .nam_nam [dsc$a_pointer], .nam_nam [dsc$w_length] + .nam_typ [dsc$w_length])
   )
THEN
    BEGIN

    ! Create the result name string in the filb
    !
    inp_filb [filb$l_result_name_len] = .volb [volb$l_vol_ident_len]	! Length of volume ident
				+ .ctx [dos11ctx$l_exp_fullname_len];	!  plus dos fullname
    $logic_check (3, (.inp_filb [filb$l_result_name_len] LEQU filb$s_result_name), 263);
    CH$COPY (.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident],	! Volume name
		.ctx [dos11ctx$l_exp_fullname_len], ctx [dos11ctx$t_exp_fullname],
		0, filb$s_result_name, inp_filb [filb$t_result_name]);

    $trace_print_fao ('Found "!AF"', .inp_filb [filb$l_result_name_len], inp_filb [filb$t_result_name]);

    ! Physically position the tape to this file, since the routine expects the address of a dos11ent
    ! structure, we alter the address so that the offsets of the label fields will match
    !
    IF NOT exch$dos11_position_tape (.volb, (ctx [dos11ctx$t_entry] - $byteoffset (dos11ent$l_filename_1)))
    THEN
	RETURN 0;

    ! Define a record stream for this file
    !
    ctx [dos11ctx$l_cur_byte]	  = 0;					! Context is the first byte in
    ctx [dos11ctx$l_cur_block]	  = 0;					!  the first block of the file
    ctx [dos11ctx$l_eof_block]	  = -1;					! Pick a huge number
    inp_filb [filb$l_block_count] = .ctx [dos11ctx$w_blocks];		! Put the size in the filb (if we know it)
    inp_filb [filb$a_record]	  = 0;					! No valid record or length
    inp_filb [filb$l_record_len]  = 0;

    ! Make sure that the record format in the filb is correct
    !
    exch$cmd_fetch_recfmt_implied (.inp_filb, ctx [dos11ctx$t_exp_type]);

    ! For DOS-11 we can treat block transfer mode as fixed 512
    !
    IF .out_filb [filb$b_transfer_mode] EQL filb$k_xfrm_block
      OR
       .inp_filb [filb$b_transfer_mode] EQL filb$k_xfrm_block
    THEN
	BEGIN
	inp_filb [filb$b_rec_format]  = filb$k_rfmt_fixed;
	inp_filb [filb$l_fixed_len]   = 512;
	END;

    ! Clear all the flags except the ones we want by writing the masks into the longword
    !
    ctx [dos11ctx$l_flags] = dos11ctx$m_stream_active;	! A record stream is currently active
    inp_filb [filb$v_files_found] = true;		! One or more files have been opened

    ! Set up the i/o and record buffer
    !
    IF .ctx [dos11ctx$a_buffer] EQL 0		! If doing wildcards buffer might be there
    THEN
	ctx [dos11ctx$a_buffer] = exch$util_vm_allocate (ctx$k_buffer_length);

    ! Set the block pointers so that we will advance the buffer on the first get
    !
    ctx [dos11ctx$l_buf_base_block] = 0;
    ctx [dos11ctx$l_buf_high_block] = -1;

    ! Save the addresses of our routines for this volume and record format.
    !
    inp_filb [filb$a_close_routine] = exch$dos11_close_file;
    inp_filb [filb$a_put_routine] = 0;
    inp_filb [filb$a_get_routine] = exch$pdp_get;

    RETURN true;				! True means its open
    END;

! If no files were found, then scream and shout
!
IF NOT .inp_filb [filb$v_files_found]
THEN
    BEGIN
    REGISTER
	fao_desc = 0 : $ref_bblock;

    ! Concatenate the volume name to the file name and type fields
    !
    fao_desc = exch$util_fao_buffer (%ASCID '!AF!AF', .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident],
			.nam_nam [dsc$w_length] + .nam_typ [dsc$w_length], .nam_nam [dsc$a_pointer]);
    $exch_signal (exch$_filenotfound, 1, .fao_desc);
    RETURN rms$_fnf;

    END;

! Normal exit, return a 0
!
RETURN 0;
END;

GLOBAL ROUTINE exch$dos11_position_tape (volb : $ref_bblock, ent : $ref_bblock) =	%SBTTL 'exch$dos11_position_tape (volb, ent)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Position the tape to the first data block of the file described by ent.
!
! INPUT:
!
!	volb	- the volume block for the device
!	ent	- a pointer to the entry in the directory queue
!
! IMPLICIT INPUTS:
!
!	anything we can find hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	the volb (and dos11 extension) are updated
!
! ROUTINE VALUE:
!
!	true if able to position, 0 if not
!
! SIDE EFFECTS:
!
!	the tape may be moved
!--

$dbgtrc_prefix ('dos11_position_tape> ');

LOCAL
    skip,
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific]	: $ref_bblock
    ;

$debug_print_fao ('entry');
$block_check (2, .volb, volb, 615);
$block_check (2, .dosv, dos11, 616);

$trace_print_fao ('entry file_number !UL, name_1,2,type !XL,!XW,!XW',
		.ent [dos11ent$w_file_number], .ent [dos11ent$l_filename_1],
		.ent [dos11ent$w_filename_2], .ent [dos11ent$w_filetype]);
$trace_print_lit ('dosv at entry');
$check_call (4, exch$dbg_dump_dosv, .volb, (dmpdsv$m_status OR dmpdsv$m_position));

! If the tape position has been lost, rewind the tape so that the position will be known again
!
IF NOT .dosv [dos11$v_position_valid]
THEN
    BEGIN
    $exch_signal (exch$_dos11_position);	! This might take a while, warn 'em about it
    IF NOT exch$io_dos11_rewind (.volb)
    THEN
	RETURN 0;
    END;

! If the desired file is the first file, then rewind.  Otherwise, use the skipfile routine to go there
!
IF .ent [dos11ent$w_file_number] EQL 0
THEN
    BEGIN

    ! Rewind the tape so that we will know the position
    !
    IF NOT exch$io_dos11_rewind (.volb)
    THEN
	RETURN 0;
    END;

! Determine how far we are from where we should be
!
skip = .ent [dos11ent$w_file_number] - .dosv [dos11$l_current_file];
$trace_print_fao ('skip file count !SL', .skip);

! Move the tape that number of files, routine simply returns if skip count is zero
!
IF NOT exch$io_dos11_skip_file (.volb, .skip)
THEN
    RETURN 0;

$trace_print_lit ('after skip ->');
$check_call (4, exch$dbg_dump_dosv, .volb, (dmpdsv$m_status OR dmpdsv$m_position OR dmpdsv$m_entries));

IF .dosv [dos11$v_end_of_tape]
THEN
    BEGIN
    $trace_print_lit ('forcing -1 skip ***************************** dosv file number !UL', .dosv [dos11$l_current_file]);
    dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;	! Adjust the file number for the skip
    IF NOT exch$io_dos11_skip_file (.volb, -1)
    THEN
	RETURN 0;
    $trace_print_lit ('dosv file number !UL after skip', .dosv [dos11$l_current_file]);
    END;

! Read the label if we are at a tape mark
!
IF .dosv [dos11$v_tape_mark]
THEN
    BEGIN
    status = exch$io_dos11_read_label (.volb);
    IF NOT .status
    THEN
	RETURN 0;
    END;

! Make sure that the correct file has been read
!
IF CH$NEQ (dos11$s_label_buf, dosv [dos11$t_label_buf], dos11$s_label_buf, ent [dos11ent$l_filename_1], %C ' ')
THEN
    BEGIN
    BIND
	got = dosv [dos11$t_label_buf] : VECTOR [,BYTE], 
	want = ent [dos11ent$l_filename_1] : VECTOR [,BYTE];

    $trace_print_fao ('wanted  !14(3XB)', .want [0], .want [1], .want [2], .want [3], .want [4], .want [5],
		.want [6], .want [7], .want [8], .want [9], .want [10], .want [11], .want [12], .want [13]); 

    $trace_print_fao ('got     !14(3XB)', .got [0], .got [1], .got [2], .got [3], .got [4], .got [5],
		.got [6], .got [7], .got [8], .got [9], .got [10], .got [11], .got [12], .got [13]); 

    ! Tell them we have to rewind
    !
    $exch_signal (exch$_dos11_position);

    ! Rewind the tape so that we will know the position
    !
    IF NOT exch$io_dos11_rewind (.volb)
    THEN
	RETURN 0;

    ! Call ourselves again now that the position is known
    !
    RETURN exch$dos11_position_tape (.volb, .ent);
    END;

$trace_print_lit ('exiting with position');
$check_call (4, exch$dbg_dump_dosv, .volb, (dmpdsv$m_status OR dmpdsv$m_position));

RETURN 1;
END;

END
ELUDOM
