	.TITLE UETINIT00 VAX/VMS UETP USER INTERFACE PROGRAM
	.IDENT	'V04-001'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This program handles all UETP user interface dialogue.
;
; ENVIRONMENT:
;	This program requires the following privileges and quotas:
;		GRPNAM, CMEXEC
;
;--
;
; AUTHOR: Larry D. Jones,	CREATION DATE: November, 1980
;
; MODIFIED BY:
;
;	V04-001	RNH0015		Richard N. Holstein,	07-Sep-1984
;		Change BIOLM and ENQLM quotas to reflect new minima.
;
;	V03-015	RNH0014		Richard N. Holstein,	17-Aug-1984
;		Remove BYTLM quota check; BYTLM is used for WCBs.
;
;	V03-014	PEL0001		Patti E. Lutsky,	21-Jun-1984
;		Change reference to VENUS from 11/790 to 8600.
;
;	V03-013	RNH0013		Richard N. Holstein,	06-Mar-1984
;		Fix minor bugs in V03-011.
;
;	V03-012	KPL0100		Peter Lieberwirth	 6-Mar-1984
;		Change CONFREG reference to CONFREGL.
;
;	V03-011	RNH0012		Richard N. Holstein,	27-Feb-1984
;		Take advantage of new UETP message codes.  Fix SSERROR
;		interaction with RMS_ERROR.  Get rid of SHOW MEMORY
;		subprocess in favor of new $GETSYI capabilities.  Incorporate
;		fixes from the device test template.  Rework message indicating
;		load test calculations.
;
;	V03-010	RNH0011		Richard N. Holstein,	02-Feb-1984
;		Allow a user to select any subset of UETP phases.  Remove the
;		"LOCAL" subset of phases as an option.  Remove old code which
;		was conditionally assembled in case we needed to include
;		non-paged pool in estimating loads.
;
;	V03-009	RNH0010		Richard N. Holstein,	01-Aug-1983
;		Fix bug in RNH0009 which picked the wrong CPU for variations
;		on a basic CPU type.
;
;	V03-008	RNH0009		Richard N. Holstein,	29-Jul-1983
;		Add CLUSTER and LOCAL "phase names".  Support new CPU types,
;		SUPERSTAR, VENUS, SCORPIO, NAUTILUS, SEAHORSE I, microVAX chip.
;
;	V03-007	RNH0008		Richard N. Holstein,	26-May-1983
;		Change ASTLM and DIOLM to 55, each.
;
;	V03-006	BAA0002		Brian A. Axtell,	14-Dec-1982
;		Removed phase names for RMS32, system services, native 
;		utilities, and compatibility mode tests from phase inquire.
;
;	V03-005	BAA0001		Brian A. Axtell,	14-Dec-1982
;		Fixed problem when prompting for phase names so that it
;		doesn't drop a phase if there is an input error.
;
;	V03-004	RNH0007		Richard N. Holstein,	18-Oct-1982
;		Check for errors upon termination of the subprocess which
;		does a SHOW MEMORY command into a file.
;
;	V03-003	RNH0006		Richard N. Holstein,	12-Jul-1982
;		Change our dependency on SHOW MEMORY so that we expect a
;		second line of paging file info for shorter filespecs.
;
;	V03-002	LDJ0006		Larry D. Jones,		30-Mar-1982
;		Fix dump mode equation output, modified by history and
;		set the 11/782 cpu scale value.
;
;	V03-001	RNH0005		Richard N. Holstein,	23-Mar-1982
;		Fix confusing error message.
;
;**

	.SBTTL	Declarations
	.ENABLE SUPPRESSION
;
; INCLUDE FILES:
;
;	SYS$SYSTEM:SYS.STB		; To get EXE$GB_CPUTYPE
;	SYS$LIBRARY:LIB.MLB		; To get definitions
;	SHRLIB$:UETP.MLB		; To get UETP definitions
;
; MACROS:
;
	$ACCDEF				; Accounting info - termination mailbox
	$CHFDEF				; Condition handler frame definitions
	$CLIDEF				; CLI definitions
	$CLISERVDEF			; CLI callback definitions
	$JPIDEF				; $GETJPI definitions
	$NDTDEF				; SBI nexus definitions
	$PRDEF				; Processor register definitions
	$RPBDEF				; Restart parameter block definitions
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$SYIDEF				; $GETSYI definitions
	$UETPDEF			; UETP

	.MACRO ITMENT NAME,POSITION,EXPECTED
	.=PC1...
	.BYTE	^X'POSITION		; Bit of priv or quota to check
	PC1...=PC1...+1
	.=PC2...
	.LONG	EXPECTED		; Expected results
	PC2...=PC2...+4
	.=PC3...
	.ADDRESS PC5...			; Address of priv or quota ASCIC name
	PC3...=PC3...+4
	.=PC5...
NAME:					; Ascic name
	.ASCIC	/NAME/
	PC5...=.
	.ENDM ITMENT

;
; EQUATED SYMBOLS:

;   Facility number definitions:
	RMS$_FACILITY = 1

;   SHR message definitions:
	UETP = UETP$_FACILITY@STS$V_FAC_NO ; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_TEXT   = UETP!SHR$_TEXT
	UETP$_BADKEY = UETP!SHR$_BADKEY

;   Miscellany:
	LOGNAM_SIZE   = 255		; Maximum logical name size
	SYMBOL_CNT    = 4		; Number of local syms to be evaluated
	TEXT_BUFFER   = 300		; Internal text buffer size
	MAXSYM_SZ     = 255		; Maximum symbol size
	CR            = ^XD		; Carriage return
	LF	      = ^XA		; Line feed
	M 	      = ^A/M/		; M character
	SPACE	      = ^A/ /		; Space character
	TAB           = ^A/	/	; Tab character
	LCBIT	      = ^X20		; Lower case bit
	PROMPTV       = 1		; Flag set if must prompt for input
	PROMPTM       = 1@PROMPTV
	TERMINALV     = 2		; Flag set if SYS$COMMAND is a terminal 
	TERMINALM     = 1@TERMINALV
	PRIV_PRNTV    = 3		; Flag set if already printed priv msg
	DUMPV	      = 4		; Flag set if running in dump mode
	DUMPM	      = 1@DUMPV
	PRIV_CNT      = 30		; Privilege count
	QUOT_CNT      = 9		; Quota count
	PP_PAGE_USAGE = 1000		; Est. of per process use of page & pool
	PER_WS_INUSE = ^F0.20		; Est. %age of proc continuous use of its WS

	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETINIT00/

MODE:					; Run mode logical name
	.ASCID	/MODE/

DUMP:					; String to match...
	.ASCID	/DUMP/			; ...if we're to run in dump mode

SYS$COMMAND:				; Name of device from which...
	.ASCID	/SYS$COMMAND/		; ...the test can be aborted

COMMAND_ITMLST:				; $GETDVI arg list for SYS$COMMAND
	.WORD	4,DVI$_DEVCLASS		; We need the device class...
	.LONG	DEVBUF,0
	.WORD	64,DVI$_DEVNAM		; ...and the equivalence name
	.LONG	BUFFER,BUFFER_PTR
	.LONG	0			; Terminate the list

USERS:					; Load count logical name
	.ASCID	/LOADS/

PASS_NAME:				; Local pass count logical name
	.ASCID	/PASSCNT/

REPORT_NAME:				; Long or short report indicator name
	.ASCID	/REPORT/

SYSDISK:				; Name of device we are booted from
	.ASCID	/SYS$SYSROOT/

NO_RMS_AST_TABLE:			; List of errors for which...
	.LONG	RMS$_BLN		; ...RMS cannot deliver an AST...
	.LONG	RMS$_BUSY		; ...even if one has an ERR= arg
	.LONG	RMS$_CDA		; Note that we can search table...
	.LONG	RMS$_FAB		; ...via MATCHC since <31:16>...
	.LONG	RMS$_RAB		; ...pattern can't be in <15:0>
NRAT_LENGTH = .-NO_RMS_AST_TABLE

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

SYNTAX_ERROR_MSG:
	.ASCID	/Syntax error in response.  Please try again./

INVALID_PHASE_MSG:
	.ASCID	/!AS is not a valid phase name!/

INVALID_PASS_MSG:
	.ASCID	/!AS is not a valid pass count!/

INVALID_LOADCNT_MSG:
	.ASCID 	/!AS is not a valid load count!/

INVALID_REPORT_MSG:
	.ASCID	/!AS is not a valid report type!/

COMMAND_DVI_FAILED:
	.ASCID	\$GETDVI failed for SYS$COMMAND.  Status returned was:\

WRONG_ACCOUNT:
	.ASCID	\You are logged into the wrong account.\<CR><LF>-
		\	Please login to the SYSTEST account.\

STRSTR:
	.ASCID	\The following:\<CR><LF>

ENDSTR:
	.ASCID	<CR><LF>\are non-standard for the SYSTEST account and may\-
		\ result in UETP errors.\

CTRSTR:
	.ASCID	\!_!AC !AC,\
PRV_STR:
	.ASCIC	\privilege\
QUO_STR:
	.ASCIC	\quota\
FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/

RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/

RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/
SYSTEM:
	.ASCID	\!/You are running on an !AC CPU with !UL pages of memory.\
DISK:
	.ASCID	\The system was booted from !AS.\
PASS_PROMPT:
	.ASCID	\How many passes of UETP do you wish to run [1]? \
LOAD_PROMPT:
	.ASCID	\How many simulated user loads do you want [!UL]? \
REPORT_PROMPT:
	.ASCID	\Do you want Long or Short report format [Long]? \
START_MESSAGE:
	.ASCID	\!/UETP starting at !%D with parameters:\
PHASES:
	.ASCID	\ phases\
LONG_MSG:
	.ASCID	/, long report./<CR><LF>
SHORT_MSG:
	.ASCID	/, short report./<CR><LF>

DUMP_MSG_PTR:				; $PUTMSG MSGVEC for load calc msgs
	.WORD	3,1
	.LONG	UETP$_TEXT!STS$K_SUCCESS
	.LONG	1
	.ADDRESS BUFFER_PTR

DUMP_MSG1:
	.ASCID	\!/The default number of loads is the minimum result of!/!/\-
	\1) CPU_SCALE * ((MEM_FREE + MEM_MODIFY) / (WS_SIZE * PER_WS_INUSE))!/\-
	\        !AS * ((!8UL + !10UL) / (!7UL *         !4AS))  = !UL!/\
DUMP_MSG2:
	.ASCID	\2) Free process slots                                       \-
	\         = !UL!/!/\-
	\3) Free page file pages / Typical use of page file pages per process!/\-
	\!23UL / !42UL = !UL!/\

LOGINOUT:				; Name of login image
	.ASCID	/SYS$SYSTEM:LOGINOUT.EXE/

OFFSET:					; Offset table
	.BLKB	PRIV_CNT+QUOT_CNT
EXPECTED:				; Results expected table
	.BLKL	PRIV_CNT+QUOT_CNT
NAM_PTRS:				; Name pointer table
	.BLKL	PRIV_CNT+QUOT_CNT
NAME_TBL:				; ASCIC name table
	PC1... = OFFSET
	PC2... = EXPECTED
	PC3... = NAM_PTRS
	PC5... = .
	.LIST MEB
	ITMENT ALLSPOOL , 04, 0		; Privilege entries
	.NLIST MEB
	ITMENT BUGCHK   , 17, 0
	ITMENT BYPASS   , 1D, 0
	ITMENT CMEXEC   , 01, 1
	ITMENT CMKRNL   , 00, 1
	ITMENT DETACH   , 05, 1
	ITMENT DIAGNOSE , 06, 1
	ITMENT EXQUOTA  , 13, 0
	ITMENT GROUP    , 08, 1
	ITMENT GRPNAM   , 03, 1
	ITMENT LOG_IO   , 07, 1
	ITMENT MOUNT    , 11, 0
	ITMENT NETMBX   , 14, 1
	ITMENT NOACNT   , 09, 0
	ITMENT OPER     , 12, 0
	ITMENT PFNMAP   , 1A, 0
	ITMENT PHY_IO   , 16, 1
	ITMENT PRMCEB   , 0A, 1
	ITMENT PRMGBL   , 18, 0
	ITMENT PRMMBX   , 0B, 1
	ITMENT PSWAPM   , 0C, 0
	ITMENT SETPRI   , 0D, 0
	ITMENT SETPRV   , 0E, 1
	ITMENT SHMEM    , 1B, 0
	ITMENT SYSGBL   , 19, 0
	ITMENT SYSNAM   , 02, 1
	ITMENT SYSPRV   , 1C, 1
	ITMENT TMPMBX   , 0F, 1
	ITMENT VOLPRO   , 15, 1
	ITMENT WORLD    , 10, 0

	ITMENT ASTLM    , 00, 55	; Quota entries
	ITMENT BIOLM    , 01, 18
	ITMENT CPULIM   , 03, 0
	ITMENT ENQLM    , 04, 30
	ITMENT DIOLM    , 05, 55
	ITMENT FILLM    , 06, 20
	ITMENT PGFLQUOTA, 07, 10000
	ITMENT PRCLM    , 08, 8
	ITMENT TQLM     , 09, 20

GETSYI_ITMLST:				; $GETSYI arg list for...
	.WORD	4,SYI$_SID		; ...SID register...
	.ADDRESS SID,0
	.WORD	4,SYI$_PAGEFILE_FREE	; ...space remaining in page file(s)
	.ADDRESS PAGE_SIZE,0
	.LONG	0

; NOTE:  The code which searches CPU tables should limit itself to looking at
; PR$_SID_TYPMAX (+1, to include illegal or unknown entries) entries.  In
; order to prepare for planned CPUs though, we define a constant, CTT_LENGTH,
; based on what we know is down the road.  This constant in the code must also
; be patched if entries for new CPUs are patched in.
;
; Negative entries in the following tables apply to CPUs for which there is no
; explicit CPU type defined, e.g., tightly coupled, multiple CPU configurations
; such as the 11/782, or jacked up CPUs like the 11/785.

; No negative entries for this table
CPU_TYPE_TABLE:				; Table of known CPU types
	.BYTE	0			; Illegal or unknown type
	.BYTE	PR$_SID_TYP780		; STAR
	.BYTE	PR$_SID_TYP750		; COMET
	.BYTE	PR$_SID_TYP730		; NEBULA
	.BYTE	PR$_SID_TYP790		; VENUS
	.BYTE	5			; SCORPIO (reserved)
	.BYTE	6			; NAUTILUS (reserved)
	.BYTE	PR$_SID_TYPUV1		; SEAHORSE I
	.BYTE	PR$_SID_TYPUV2		; microVAX chip
CTT_LENGTH = .-CPU_TYPE_TABLE		; Item count of known CPUs + unknown
	.BLKB	2			; Expansion room for new CPU's
; End of CPU_TYPE_TABLE

; Negative entries for CPU_NAME_TABLE
	.BLKA	9			; Expansion for new CPU configurations
	.ADDRESS A787			; Dual SUPERSTAR
	.ADDRESS A785			; SUPERSTAR
	.ADDRESS A782			; ATLAS
CPU_NAME_TABLE:				; CPU names address table
	.ADDRESS UNKNOWN_CPU		; Illegal or unknown CPU type
	.ADDRESS A780			; STAR
	.ADDRESS A750			; COMET
	.ADDRESS A730			; NEBULA
	.ADDRESS A8600			; VENUS
	.ADDRESS ASCORPIO		; SCORPIO
	.ADDRESS ANAUTILUS		; NAUTILUS
	.ADDRESS AUV1			; SEAHORSE I
	.ADDRESS AUV2			; microVAX chip
	.BLKA	2			; Expansion room for new CPUs
; End of CPU_NAME_TABLE

; Negative entries for CPU_SCALE_TABLE
	.BLKF	9			; Expansion for new CPU configurations
	.FLOAT	2.25			; Dual SUPERSTAR
	.FLOAT	1.5			; SUPERSTAR
	.FLOAT	1.4			; ATLAS
CPU_SCALE_TABLE:			; Scale to balance loads vs CPU perf
	.FLOAT	1.0			; Illegal or unknown CPU
	.FLOAT	1.0			; STAR
	.FLOAT	0.8			; COMET
	.FLOAT	0.5			; NEBULA
	.FLOAT	4.0			; VENUS
	.FLOAT	1.0			; SCORPIO
	.FLOAT	1.0			; NAUTILUS
	.FLOAT	1.0			; SEAHORSE I
	.FLOAT	1.0			; microVAX chip
	.BLKF	2			; Expansion room for new CPUs
; End of CPU_SCALE_TABLE

UNKNOWN_CPU:				; Illegal or unknown CPU
	.ASCIC	\UNKNOWN\
A780:					; STAR
	.ASCIC	\11/780\
A750:					; COMET
	.ASCIC	\11/750\
A730:					; NEBULA
	.ASCIC	\11/730\
A8600:					; VENUS
	.ASCIC	\8600\
ASCORPIO:				; SCORPIO
	.ASCIC	\SCORPIO\
ANAUTILUS:				; NAUTILUS
	.ASCIC	\NAUTILUS\
AUV1:					; SEAHORSE I
	.ASCIC	\SEAHORSE I\
AUV2:					; microVAX chip
	.ASCIC	\microVAX chip\
A782:					; ATLAS
	.ASCIC	\11/782\
A785:					; SUPERSTAR
	.ASCIC	\11/785\
A787:					; Dual SUPERSTAR
	.ASCIC	\11/787\

USER_LIST:				; GETJPI item list for USERNAME and WS size
	.WORD	12
	.WORD	JPI$_USERNAME
	.LONG	BUFFER
	.LONG	OUTLEN
	.WORD	4
	.WORD	JPI$_WSQUOTA
	.LONG	WS_SIZE
	.LONG	0
	.WORD	4
	.WORD	JPI$_ASTLM
	.LONG	JPI_ASTLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_BIOLM
	.LONG	JPI_BIOLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_BYTLM
	.LONG	JPI_BYTLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_CPULIM
	.LONG	JPI_CPULIM
	.LONG	0
	.WORD	4
	.WORD	JPI$_ENQLM
	.LONG	JPI_ENQLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_DIOLM
	.LONG	JPI_DIOLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_FILLM
	.LONG	JPI_FILLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_PGFLQUOTA
	.LONG	JPI_PGFLQUOTA
	.LONG	0
	.WORD	4
	.WORD	JPI$_PRCLM
	.LONG	JPI_PRCLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_TQLM
	.LONG	JPI_TQLM
	.LONG	0
	.WORD	8
	.WORD	JPI$_CURPRIV
	.LONG	PRIVS
	.LONG	0
	.LONG	0

SYM_NAM_TABLE:	; Names of parameters in local symbol table
					; If defined they represent:
SYM_P1:			 		; phase
	.WORD	P1_LEN,0 
	.ADDRESS P1_NAM
SYM_P2:					; pass count
	.WORD	P2_LEN,0
	.ADDRESS P2_NAM
SYM_P3:					; number of loads
	.WORD	P3_LEN,0
	.ADDRESS P3_NAM
SYM_P4:					; long or short report
	.WORD	P4_LEN,0
	.ADDRESS P4_NAM
P1_NAM:
	.ASCII	/P1/
	P1_LEN = .-P1_NAM
P2_NAM:
	.ASCII	/P2/
	P2_LEN = .-P2_NAM
P3_NAM:
	.ASCII	/P3/
	P3_LEN = .-P3_NAM
P4_NAM:
	.ASCII	/P4/
	P4_LEN = .-P4_NAM

PHASE_PROMPT:				; See if full UETP run is wanted
	.ASCID	<CR><LF><LF>\Run "ALL" UETP phases or a "SUBSET" [ALL]? \

COMMA_BLANK:				; Separator between phase names...
	.ASCIC	\, \			; ...for WHICH_PHASE $FAOL string

NEW_LINE:				; Continue list of phase names...
	.ASCIC	<CR><LF>\	\	; ...on a new line

WHICH_PHASE1:				; Allow selection of UETP phases
	.ASCID -
	\!/!/You can choose one or more of the following phases:!/!/!_!#(AC)\

WHICH_PHASE2:
	.ASCIC	<CR><LF><LF>\Phase(s):  \

; We here take advantage of the Run Time Library $LIB_KEY_TABLE's internal
; code so that we may generate descriptors of the keyword strings in
; parallel with generating the strings and their pointers.  The sequence
; of .ERROR statements below should guard us against internal changes to
; the documented macro.

;LIB$$K_NPAIRS counts entries in $LIB_KEY_TABLE
.MACRO		$$LIB_KEY_ENTRY STRING, VALUE
.IF EQ LIB$$A_HERE+1	; First time expanding this macro, define new stuff
	UETP$$A_THERE = LIB$$A_STRLOC
	LIB$$A_STRLOC = LIB$$A_STRLOC + <8 * LIB$$K_NPAIRS>
.ENDC ; EQ LIB$$A_HERE+1
		.ADDRESS	LIB$$A_STRLOC
		.LONG		VALUE
	LIB$$A_HERE=.
	.=UETP$$A_THERE
	KEY_'STRING'_DESC:
		.WORD		%LENGTH(STRING),0
		.ADDRESS	LIB$$A_STRLOC + 1	; 1 char into ASCIC str
	UETP$$A_THERE=.
	.=LIB$$A_STRLOC
		.ASCIC		\STRING\
	LIB$$A_STRLOC=.
	.=LIB$$A_HERE
.ENDM		$$LIB_KEY_ENTRY

LIB$$A_HERE=-1				; Flags first $$LIB_KEY_ENTRY expansion
SELECT_PHASE:				; Allow user to select between ALL...
	$LIB_KEY_TABLE	< -		; ...phases or a subset of them
		<ALL,0> -
		<SUBSET,1> -
	> ; End of $LIB_KEY_TABLE

LIB$$A_HERE=-1				; Flags first $$LIB_KEY_ENTRY expansion
PHASE_TABLE:
	$LIB_KEY_TABLE	< -
		<<DEVICE>,>-
		<<LOAD>,>-
		<<DECNET>,>-
		<<CLUSTER>,>-
	> ; End of $LIB_KEY_TABLE

.MDELETE	$$LIB_KEY_ENTRY		; Remove our own version of the macro
.IF NDF UETP$$A_THERE
	.ERROR	; This program depends on the existence
	.ERROR	; of $$LIB_KEY_ENTRY within the $LIB_KEY_TABLE
	.ERROR	; definition.  It must be fixed to use some
	.ERROR	; new definition so that it can generate
	.ERROR	; tables parallel to the ones from
	.ERROR	; $LIB_KEY_TABLE.
.ENDC ; NDF UETP$$A_THERE

UETPPHASE:				; Logical name for UETP.COM phase names
	.ASCID	\UETPPHASE\

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

WELCOME:
	.LONG	WELCOML
	.ADDRESS .+4
	.ASCII	<CR><LF><LF><LF>\	Welcome to VAX/VMS UETP Version \
VERSION:
	.BLKB	8
	.ASCII	<CR><LF>
	WELCOML = .-WELCOME-8

TTCHAN:					; Channel for the terminal
	.WORD	0

ERROR_COUNT:				; Error count
	.LONG	0

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

PASS_MSG:				; Used in startup msg
	.ASCID	\, !UL passes\

LOAD_MSG:				; More for startup msg
	.ASCID	\, !UL load!%S\

PARAM_MSG:				; Here is where the parameter portion
	.WORD	0,0			; ...of the startup msg gets assembled
	.ADDRESS PARAM_BUF
PARAM_BUF:
	.BLKB	TEXT_BUFFER

LOADS_DESC:				; Loads general purpose desc.
	.LONG	0
	.ADDRESS 0

CPU_SCALE_DES:				; Descriptor for CPU scale value
	.ASCID	/    /

WS_INUSE_DES:				; Descriptor for percent of WS in use
	.ASCID	/    /

WS_INUSE:				; Storage for percent of WS in use
	.LONG	PER_WS_INUSE		; This is a floating point constant

DISK_BUFFER:				; System disk name
	.LONG	LOGNAM_SIZE
	.ADDRESS .+4
	.BLKB	LOGNAM_SIZE

DEVBUF:					; Gets device class of SYS$COMMAND...
	.BLKL	1			; ...from $GETDVI

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

PAGE_COUNT:				; Floating point format memory page count
	.FLOAT	0
PAGE_BUF:				; String storage for memory size
	.LONG	5
	.ADDRESS .+4
	.BLKB	5

QUAD_STATUS:				; IOSB for misc. system services
	.QUAD	0

STATUS:					; Status value on program exit
	.LONG	0

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

FLAGS:					; Miscellaneous flags.
	.BYTE	0			; See Equated Symbols for definitions

SYM_VAL_TABLE:				; Buffers for parameters P1-P4

P1_DESC:
	.LONG	0
	.ADDRESS P1_BUF
P2_DESC:
	.LONG	0
	.ADDRESS P2_BUF
P3_DESC:
	.LONG	0
	.ADDRESS P3_BUF
P4_DESC:
	.LONG	0
	.ADDRESS P4_BUF
P1_BUF:
	.BLKB	MAXSYM_SZ
P2_BUF:
	.BLKB	MAXSYM_SZ
P3_BUF:
	.BLKB	MAXSYM_SZ
P4_BUF:
	.BLKB	MAXSYM_SZ


ANSWER:					; Answer buffer desc
	.LONG	TEXT_BUFFER
	.ADDRESS .+4
	.BLKB	TEXT_BUFFER

OUTLEN:					; Output string desc
	.LONG	0
	.ADDRESS ANSWER+8

CPU_SCALE:				; This CPU's scale factor
	.FLOAT	0.0
PASS_COUNT:				; Total pass count
	.LONG	0
LOAD_COUNT:				; Total load count
	.LONG	0

VECTOR:					; Message vector for $PUTMSG
	.WORD	3			; Arg count - total number of longwords
	.WORD	^B0001			; Message flag
	.LONG	UETP$_TEXT		; Message ID
	.WORD	1			; FAO arg count
	.WORD	0			; New message flags
MSG_DESC:
	.LONG	BUFFER_PTR		; Address of message descriptor

WS_SIZE:				; GETJPI results list
	.LONG	0
JPI_ASTLM:
	.LONG	0
JPI_BIOLM:
	.LONG	0
JPI_BYTLM:
	.LONG	0
JPI_CPULIM:
	.LONG	0
JPI_ENQLM:
	.LONG	0
JPI_DIOLM:
	.LONG	0
JPI_FILLM:
	.LONG	0
JPI_PGFLQUOTA:
	.LONG	0
JPI_PRCLM:
	.LONG	0
JPI_TQLM:
	.LONG	0
PRIVS:
	.QUAD	0

MEM_SIZE:				; Total physical memory size in pages
	.LONG	0

MEM_FREE:				; Physical memory not being used now
	.LONG	0

MEM_MODIFY:				; Physical memory on the modified list
	.LONG	0

SWAP_SIZE:				; Count of free process entry slots
	.LONG	0

PAGE_SIZE:				; Secondary storage for paging in pages
	.LONG	0

SID:					; $GETSYI returns SID register here
	.BLKL	1

;
; CLI call back request descriptor
;
CLI_REQ_DESC:
	.BYTE	CLI$K_CLISERV
	.WORD	CLI$K_GETSYM		; Get local sym is what we want to do
	.BYTE	CLI$K_LOCAL_SYM
	.QUAD	0			; Desc of symbol name - CLI$Q_NAMDESC
	.QUAD	0			; Desc of returned value -CLI$Q_VALDESC

	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

LOG_FAB:				; Log file FAB
	$FAB	FNM = <UETP.LOG>,-
		RAT = CR,-
		FAC = PUT
LOG_RAB:				; Log file RAB
	$RAB	FAB = LOG_FAB,-
		RBF = BUFFER,-
		RSZ = TEXT_BUFFER

	.SBTTL	Main Program
	.PSECT	UETINIT00,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

;+
;	UETINIT00 queries the user for UETP run-time information and welcomes
;	the user to UETP. The user is told what CPU type, memory configuration,
;	and system disk type he/she is running on. The user is prompted for the
;	number of complete passes he/she wants and if he/she responds with a
;	carriage return the default is one pass. The user is prompted for the
;	number of parallel simulated users that he wishes to have used in the
;	load test portion of the UETP. If he/she responds with a carriage return
;	UETINIT00 calculates an appropriate value for the configuration that is
;	being used and informs the user as to what that value is. The user is
;	prompted for the report format (long or short) that is desired. If a
;	carriage return is the response, then long report format is used.
;	The UETP.LOG file is first created in this program as well.  The user
;	is allowed to choose to run the entire UETP or a subset of its phases,
;	with the default being the entire UETP.
;-

.ENTRY UETINIT00,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler

	$CREATE FAB = LOG_FAB,-		; Create the log file
		ERR = RMS_ERROR
	$CONNECT RAB = LOG_RAB,-
		ERR = RMS_ERROR

	MOVQ	G^SYS$GQ_VERSION,VERSION ; Get the system version number
	MOVAL	WELCOME,MSG_DESC	; Message desc
	$PUTMSG_S MSGVEC = VECTOR,-	; Go ahead and output msg
		  ACTRTN = ACTRTN	; Output it to log file as well
	$SETPRN_S PRCNAM = TEST_NAME	; Set the process name

	$GETJPI_S ITMLST = USER_LIST	; Get the username, privs and quotas
	CMPC3	ACNT_NAME,ACNT_NAME+8,-	; Are we in the right account?
		BUFFER
	BEQL	10$			; BR if no...
	PUSHAL	WRONG_ACCOUNT		; ...else report and exit
	PUSHL	#1			; Arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Signal name
	PUSHL	#3			; Parameter count
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT		; Give the user the last rights
10$:
	$GETDVI_S DEVNAM = SYS$COMMAND,- ; Get the name of...
		  IOSB   = QUAD_STATUS,- ; ...device which may abort test
		  ITMLST = COMMAND_ITMLST
	BLBS	QUAD_STATUS,20$		; BR if all went OK
	MOVZWL	QUAD_STATUS,R2		; We had a problem. Extract error code
	$GETMSG_S MSGID = R2,-		; Get message text associated with error
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF
	PUSHAQ	BUFFER_PTR		; Let user know what went wrong...
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHAQ	COMMAND_DVI_FAILED
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#6
	BRW	ERROR_EXIT		; ...and bail out
20$:	CMPB	#DC$_TERM,DEVBUF	; Were we invoked from a terminal?
	BNEQ	30$			; BR if not
	BISB2	#TERMINALM,FLAGS	; Set terminal flag
	$ASSIGN_S DEVNAM = BUFFER_PTR,-	; Set up for CTRL/C ASTs if we were
		  CHAN   = TTCHAN
	$QIOW_S	CHAN     = TTCHAN,-	; Enable CTRL/C ASTs...
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND
	PUSHAL	TEST_NAME		; ...and tell the user...
	PUSHL	#1
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS
	CALLS	#3,G^LIB$SIGNAL		; ...how to abort gracefully
30$:
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	PUSHAQ	BUFFER_PTR		; Convert to upper case
	PUSHAQ	BUFFER_PTR
	CALLS	#2,G^STR$UPCASE
	MATCHC	DUMP,@DUMP+4,-		; Are we to run in dump mode?
		BUFFER_PTR,BUFFER
	BNEQ	35$			; BR if not
	BISB2	#DUMPM,FLAGS		; Else set the flag bit
35$:

;+
;	Go through this process' privileges and quotas.  If something
;	nonstandard shows up, give a warning.
;-
	CLRL	R2			; Init an index variable

	MOVAL	PRV_STR,R6		; List non-standard privs first
40$:	MOVZBL	OFFSET[R2],R4		; Get the offset of the priv
	EXTZV	R4,#1,PRIVS,R3		; Get the priv
	CMPL	EXPECTED[R2],R3		; Check it
	BSBB	80$			; Br if bad
	AOBLSS	#PRIV_CNT,R2,40$	; Do all privs

	MOVAL	QUO_STR,R6		; Now we're listing non-standard quotas
60$:	MOVZBL	OFFSET[R2],R4		; Get the offset of the quota
	CMPL	EXPECTED[R2],JPI_ASTLM[R4] ; Check it
	BSBB	80$			; Br if bad
	AOBLSS	#PRIV_CNT+QUOT_CNT,R2,60$ ; Do all quotas

	BBCC	#PRIV_PRNTV,FLAGS,70$	; Only print the ending message once
	PUSHAL	ENDSTR			; push the message address
	PUSHL	#^X10001		; push the arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; push the signal name
	CALLS	#3,G^LIB$SIGNAL		; print the ending error message
70$:	BRB	110$

; Subroutine to list non-standard privileges and quotas.
80$:	BEQL	100$			; Don't complain if priv/quota is OK
	BBSS	#PRIV_PRNTV,FLAGS,90$	; Only print error message header once
	INCL	ERROR_COUNT		; Bump the error count
	PUSHAL	STRSTR			; Push the string address
	PUSHL	#^XF0001		; Push the arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Push the signal name
	PUSHL	ERROR_COUNT		     ; Finish off arg list...
	PUSHAL	TEST_NAME		     ; ...
	PUSHL	#^X10002		     ; ...
	PUSHL	#UETP$_ERBOXPROC!STS$K_ERROR ; ...for error box message
	CALLS	#7,G^LIB$SIGNAL		; Print the error message
90$:
	$FAO_S	CTRSTR = CTRSTR,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = NAM_PTRS[R2],-
		P2     = R6		; Generate the string
	PUSHAL	BUFFER_PTR		; Push the address...
	PUSHL	#^X10001		; ...the arg count...
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; ...the signal name...
	CALLS	#3,G^LIB$SIGNAL		; ...and print the message
100$:	RSB				; Return for further checking

;+
;	Figure out the CPU type in preparation for defining the number of load
;	test loads to run.  In their wisdom, the engineers who designed
;	closely-coupled CPUs and "mid-life kicker" CPUs have chosen to keep
;	the same CPU type as the base CPU, but there are other hints to figure
;	out what one is running on.  Figuring whether we have a multiple CPU
;	configuration uses the VMS location EXE$GL_MP, which indicates the
;	presence of a tightly-coupled, second processor if non-zero.  SUPERSTAR
;	sets a bit in the SID register.  Note that we don't use the VMS macro,
;	CPUDISP.
;-
110$:
	$GETSYI_S ITMLST = GETSYI_ITMLST ; Get misc system info
	EXTZV	#PR$V_SID_TYPE,-	; Figure the CPU type from that
		#PR$S_SID_TYPE,SID,R8
	LOCC	R8,#CTT_LENGTH,-	; See if VMS knows of that CPU...
		CPU_TYPE_TABLE
	SUBL3	R0,#CTT_LENGTH,R0	; ...and convert to that type's offset
	CASEB	R0,#0,#CTT_LENGTH	; BR to set up for the correct CPU
120$:		.WORD 140$-120$		; Illegal or unknown CPU
		.WORD 121$-120$		; STAR-based CPUs
		.WORD 140$-120$		; COMET
		.WORD 140$-120$		; NEBULA
		.WORD 140$-120$		; VENUS
		.WORD 140$-120$		; SCORPIO
		.WORD 140$-120$		; NAUTILUS
		.WORD 140$-120$		; SEAHORSE I
		.WORD 140$-120$		; microVAX chip
	.REPEAT	4
	NOP				; Fudge so we can patch in new CPUs
	.ENDR
	CLRL	R8			; Default value - illegal CPU
	BRB	140$
121$:
	TSTL	G^EXE$GL_MP		; Are we multiprocessing?
	BEQL	122$			; BR to check SUPERSTAR if not
	MNEGL	#1,R8			; Use a different offset if we are
122$:
	BBC	#23,SID,140$		; We're already correct if 11/780
	MNEGL	#2,R8			; Set up SUPERSTAR offset
	TSTL	G^EXE$GL_MP		; Are we multiprocessing as well?
	BEQL	140$			; BR to get scale & text if not
	MNEGL	#3,R8			; Use a different offset if we are
;	BRB	140$			; Fall into default processing
140$:
	MOVF	CPU_SCALE_TABLE[R8],-	; Save the CPU scale factor
		CPU_SCALE
	MOVL	CPU_NAME_TABLE[R8],R8	; Ah! that's what kind of CPU it is
	$CMEXEC_S ROUTIN = GET_MEM_INFO	; Figure various memory limits
	$FAO_S	CTRSTR = SYSTEM,-	; Generate the string
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R8,-
		P2     = MEM_SIZE
	MOVAL	BUFFER_PTR,MSG_DESC
	$PUTMSG_S MSGVEC = VECTOR,-	; Go ahead and output msg
		  ACTRTN = ACTRTN	; Output it to log file as well
	$TRNLOG_S LOGNAM = SYSDISK,-	; Get the system disk designation
		  RSLLEN = DISK_BUFFER,-
		  RSLBUF = DISK_BUFFER
	$FAO_S	CTRSTR = DISK,-		; Format system disk msg
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DISK_BUFFER
	MOVAL	BUFFER_PTR,MSG_DESC
	$PUTMSG_S MSGVEC = VECTOR,-	; Go ahead and output msg
		  ACTRTN = ACTRTN	; Output it to log file as well

;+
; 	Here we call the CLI to get values for local symbols P1-P4.  If they
;	are not defined SYS$CLI returns LIB$_NOSUCHSYM and each associated
;	descriptor is left with length zero. 
;-
	CLRL	R9			; Symbols found counter
	MOVAL	CLI_REQ_DESC,R6		; CLI request block
	MOVAL	SYM_NAM_TABLE,R7	; Parameter names
	MOVAL	SYM_VAL_TABLE,R8	; Table for returned values
	MOVL	#SYMBOL_CNT,R11		; Loop count
150$:
	MOVQ	(R7)+,CLI$Q_NAMDESC(R6) ; Put symbol name desc in req block
	CLRQ	CLI$Q_VALDESC(R6)	; Init return desc
	PUSHAL	(R6)			; Push address of the req block
	CALLS	#1,G^SYS$CLI		; Callback to the CLI
	CMPL	R0,#SS$_NORMAL		; Did we find it
	BNEQ	160$			; BR if not
	TSTW	CLI$Q_VALDESC(R6)	; Test for zero length
	BEQL	160$			; Br if zero length
	SKPC	#^A/ /,CLI$Q_VALDESC(R6),- ; Make sure we did not get all spaces
		@<CLI$Q_VALDESC+4>(R6)
	BEQL	160$			; BR if only spaces
	INCL	R9			; Count this one found
	MOVL	CLI$Q_VALDESC(R6),(R8)+	; Save return length
	MOVC3	CLI$Q_VALDESC(R6),-	; ...and value
		@<CLI$Q_VALDESC+4>(R6),@(R8) 
	SUBL2	#4,R8			; Reset R8 to start of present descriptor
160$:
	ADDL2	#8,R8			; Move PTR to next value descriptor
	SOBGTR	R11,150$		; Repeat until we tried them all
	TSTL	R9			; Were any symbols defined?
	BNEQ	PHASE			; BR if we found at least one
	BBC	#TERMINALV,FLAGS,PHASE	; BR if we are not connected to a 
					;  terminal -we will use default values
	BISB2	#PROMPTM,FLAGS		; No parameters were defined and we are
					;  connected to a terminal so set the
					;  flag for prompting

;+
;	See if the user wants to run the entire UETP or a subset of its phases.
;	Define a logical name, UETPPHASE, with the result.  UETP.COM will use
;	the translation of UETPPHASE to execute the appropriate phase(s).
;-

PHASE:
	BBS	#PROMPTV,FLAGS,10$	; BR if we need to prompt
	MOVW	P1_DESC,OUTLEN		; No prompting, phase is P1 param...
	BEQL	40$			; ...but supply default if null
	PUSHAQ	P1_DESC			; We have some request, so...
	PUSHAQ	P1_DESC			; ...for matching's sake...
	CALLS	#2,G^STR$UPCASE		; ...get it all uppercase
	CMPC3	P1_DESC,P1_BUF,-	; Did user specifically request...
		@KEY_ALL_DESC+4		; ...to run all phases?
	BEQL	40$			; BR if so
	MOVC3	P1_DESC,P1_BUF,@OUTLEN+4 ; Use user's reply since there is one
	BRW	200$			; Join code which has user's selection
10$:
	PUSHAW	OUTLEN			; Get user's choice - reply length...
	PUSHAQ	PHASE_PROMPT		; ...prompt string...
	PUSHAQ	ANSWER			; ...reply string...
	CALLS	#3,G^LIB$GET_COMMAND	; ...- for the phase(s) to execute
	BLBS	R0,20$			; BR if we could read response
	MOVL	R0,STATUS		; Use error code as exit status
	BRW	FINI
20$:	TSTW	OUTLEN			; Was there some explicit request?
	BEQL	40$			; BR if not - supply default
	PUSHAQ	OUTLEN			; We have some request, so...
	PUSHAQ	OUTLEN			; ...for matching's sake...
	CALLS	#2,G^STR$UPCASE		; ...get it all uppercase
	PUSHAL	BUFFER			; This will tell which reply we got...
	PUSHAL	SELECT_PHASE		; ...this tells the possibilities...
	PUSHAQ	OUTLEN			; ...and this is the text of the reply
	CALLS	#3,G^LIB$LOOKUP_KEY	; See if we want all or a subset
	CMPL	S^#SS$_NORMAL,R0	; Did we find a reasonable reply?
	BEQL	30$			; BR if we did
	BSBW	SYNTAX_ERROR		; Complain if we did not...
	BRW	PHASE			; ...and start all over
30$:	TSTL	BUFFER			; Was a subset requested (add'l prompt)?
	BNEQ	100$			; Yes, go do second prompt
	; The user requested all phases.  Fall into that code.

40$:	; The user wants all UETP phases, either explicitly or implicitly.
	MOVAL	PHASE_TABLE,R6		; Get the list of phase names...
	ASHL	#-1,(R6)+,R7		; ...their count...
	CLRW	PARAM_MSG		; ...an accumulator for total length...
	MOVAL	PARAM_BUF,R3		; ...a place to concatenate them...
50$:	MOVL	(R6),R5			; ...the pointer to a name...
	MOVZBW	(R5),R8			; ...the length of an individual name...
	MOVC3	R8,1(R5),(R3)		; ...the text forming the name...
	ADDW2	R8,PARAM_MSG
	MOVB	#^A/ /,(R3)+		; ...and a separator between names...
	INCW	PARAM_MSG
	TSTD	(R6)+
	SOBGTR	R7,50$			; ...to form the default of all names
	BRW	300$			; Go process the default list

;
; Form on the stack an $FAOL PRMLST of UETP phase names, based on the list to be
; passed to LIB$LOOKUP_KEY.  Be somewhat clever in listing the names, inserting
; proper spacing and new lines.  In doing so, remember that $FAOL uses a FIFO
; algorithm for removing items from the PRMLST.  We'll preallocate a worst case
; amount of space on the stack (which is normally LIFO!) and stick pointers to
; .ASCIC strings on the list in FIFO order. The space needed takes into account
; that we could need three longwords per phase name (the name, separator
; characters and newline), that the list of names has a count of longwords at
; its front instead of a count of entries, and that we're allocating bytes, not
; longwords.  Use the $FAOL results as the prompt for the phase we want to
; execute.
;
100$:
	MOVL	SP,R6			; R6 will clean up the stack later
	CLRL	R7			; R7 counts the .ASCIC strings
	MOVAL	PHASE_TABLE,R8		; R8 points to the phase name list
	MULL3	#6,(R8),R9		; Figure worst case of space we'll need
	SUBL2	R9,SP			; Preallocate space on the stack
	MOVL	SP,R9			; R9 points to base of FIFO list
	ASHL	#-1,(R8)+,R10		; R10 counts phase names remaining
					; (R8 now points to ptr to first name)
	MOVL	#8,R11			; R11 counts characters on a line
					; (The listing of phases starts one...
					; ...tab stop from the left margin)
110$:
	ADDB3	@(R8),R11,R5		; If phase name + current line width...
	ACBB	#80,COMMA_BLANK,R5,120$	; ...+ separator chars .GT. 80...
	MOVAL	NEW_LINE,(R9)+		; ...then start a new line,...
	MOVL	#8,R5			; ...figure what column we're on,...
	INCL	R7			; ...and count another .ASCIC string
120$:
	MOVL	(R8)+,(R9)+		; Put a phase name on $FAOL PRMLST
	TSTL	(R8)+			; Skip over LIB$LOOKUP_KEY assoc. value
	MOVAL	COMMA_BLANK,(R9)+	; Put separator chars on $FAOL PRMLST
	ADDL2	#2,R7			; Count the .ASCIC strings we've pushed
	MOVL	R5,R11			; Update current line width
	SOBGTR	R10,110$		; Loop if there are more phase names
	MOVAL	WHICH_PHASE2,-(R9)	; Use second half of prompt to...
					; ...overwrite trailing separator chars
	PUSHL	R7			; Put .ASCIC count in front of PRMLST
	MOVL	SP,R8			; Save pointer to the PRMLST
	$FAOL_S	CTRSTR = WHICH_PHASE1,-	; Form prompt for...
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		PRMLST = (R8)
	MOVL	R6,SP			; (Restore stack: rid it of PRMLST)
	PUSHAL	OUTLEN
	PUSHAL	BUFFER_PTR
	PUSHAL	ANSWER
	CALLS	#3,G^LIB$GET_COMMAND	; ...deciding which phase to run
	BLBS	R0,200$			; Can we read SYS$COMMAND?
	MOVL	R0,STATUS		; Supply an exit status...
	BRW	FINI			; ...and bail out if we can't

;
; Now that we've got a (list of) phase name(s) from P1 or prompt, see if it
; (they) is (are) valid.  P1_DESC can be scratch.  Accumulate in PARAM_MSG.
;
200$:	PUSHAQ	OUTLEN			; Convert possible...
	PUSHAQ	OUTLEN			; ...lowercase answer...
	CALLS	#2,G^STR$UPCASE		; ...to uppercase
	MOVL	#^A/	/,R2		; We'll want a list containing only...
	BSBB	220$			; ...blanks and phase names...
	MOVL	#^A/,/,R2		; ...so convert other separators...
	BSBB	220$			; ...to blanks
	MOVQ	OUTLEN,R6		; Prime pump to form desc for first...
					; ...possible phase name
	CLRW	PARAM_MSG		; We have no phase names accepted yet...
	MOVL	PARAM_MSG+4,R3		; ...but when we do, they're copied here
	TSTW	OUTLEN			; Special case: have we an empty list?
	BNEQ	210$			; BR if not, we can parse it
	CLRW	P1_DESC			; Set up to call our error routine...
	MOVL	#UETP$_BADKEY,R0	; ...
	BRB	400$			; ...and complain
210$:
	SKPC	#^A/ /,R6,(R7)		; Pass over leading/intervening blanks
	BEQL	300$			; BR if no possible phase names left
	MOVQ	R0,P1_DESC		; Save desc for possible phase name
	LOCC	#^A/ /,R0,(R1)		; Find end of the possible phase name
	SUBL2	R0,P1_DESC		; Now get the true length of the name
	MOVQ	R0,R6			; Set up pointers for the next name
	MOVZWL	#TEXT_BUFFER,BUFFER_PTR
	PUSHAL	BUFFER_PTR		; See which phase: out-len...
	PUSHAL	BUFFER_PTR		; ...full-dsc-adr...
	PUSHL	#0			; ...key-value-adr...
	PUSHAL	PHASE_TABLE		; ...key-table-adr...
	PUSHAL	P1_DESC			; ...str-dsc-adr...
	CALLS	#5,G^LIB$LOOKUP_KEY	; ...
	CMPW	S^#SS$_NORMAL,R0	; Did we get a unique match?
	BNEQ	400$			; BR if not - go to our error routine
	MOVC3	BUFFER_PTR,BUFFER,(R3)	; Copy an unabbreviated phase name
	ADDW2	BUFFER_PTR,PARAM_MSG	; Include its length in the descriptor
	MOVB	#^A/ /,(R3)+		; Separate phase names...
	INCW	PARAM_MSG		; ...and count the separators, too
	BRB	210$			; Loop for another phase name

220$:	LOCC	R2,OUTLEN,@OUTLEN+4	; Find a separator we want to convert
	BEQL	230$			; BR if none are left
	MOVB	#^A/ /,(R1)		; Convert it to a blank...
	BRB	220$			; ...and look for another
230$:	RSB

;
; We've got our phase name list.  We define a group logical name so that it
; will persist beyond running this image.  Note that PARAM_MSG and PARAM_BUF
; are preserved for the FINAL_MESSAGE routine.
;
300$:	$CRELOG_S LOGNAM = UETPPHASE,-	; Define logical name for UETP.COM label
		  EQLNAM = PARAM_MSG,-
		  TBLFLG = #1		; It's a group logical name
	BRW	PASS			; Process the next question

;
; We were passed a bum phase name.  That's not too bad if we're interactive,
; (just reprompt) but give up if we're not interactive (we were passed a bad
; parameter).
;
400$:
	BBS	#PROMPTV,FLAGS,410$	; BR if we are prompting because...
	PUSHL	S^#SS$_BADPARAM		; ...if not we'll want add'l message
410$:
	PUSHR	#^M<R0>			; Save LOOKUP_KEY status over $GETMSG
	$GETMSG_S MSGID = R0,-		; Figure out...
		 MSGLEN = BUFFER_PTR,-	; ...if the message...
		 BUFADR = FAO_BUF,-	; ...associated with our fail code...
		 FLAGS  = #0,-		; ...needs any $FAO args
		 OUTADR = MSG_BLOCK
	POPR	#^M<R0>			; Restore failure code
	MOVZBL	MSG_BLOCK+1,R2		; Make $FAO arg count more useable
	BEQL	420$			; BR if there are no associated args
	PUSHAL	P1_DESC			; Assume that the arg is the bad string
	PUSHL	#1
	MOVL	#2,R2
420$:
	PUSHL	R0			; Yell at the user if bad reply
	$FAO_S	CTRSTR = INVALID_PHASE_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P1_DESC
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	BBC	#PROMPTV,FLAGS,430$	; BR if not prompting
	PUSHAL	SYNTAX_ERROR_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	ADDL2	#7,R2			; Add to old count for LIB$SIGNAL args
	CALLS	R2,G^LIB$SIGNAL
	BRW	100$			; Politely ask again
430$:
	ADDL3	#5,R2,-(SP)		; Add to old count for ERROR_EXIT args
	MOVL	S^#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT		; Bitch and quit

;+
;	If the prompt flag is set prompt the user for the number of passes.  If
;	it is not set, try to use P2 for the pass count.  If the prompt returns
;	null, or if not prompting and P2 is null, we use the default, one pass.
;-

PASS:
	BBC	#PROMPTV,FLAGS,3$	; BR if not prompting
	PUSHAL	OUTLEN			; Set response length location
	PUSHAL	PASS_PROMPT		; Set prompt string
	PUSHAL	ANSWER			; Set answer address
	CALLS	#3,G^LIB$GET_COMMAND	; Ask for the pass count
	BLBS	R0,5$			; If no failure than continue
	MOVL	R0,STATUS		; else save error and
	BRW	FINI			; bail out
3$:
	MOVL	P2_DESC,OUTLEN		; Set P2 param length in buffer
	MOVC3	P2_DESC,P2_BUF,@OUTLEN+4 ; Put in defined pass count
5$:
	TSTL	OUTLEN			; Do we have a value yet?
	BNEQ	10$			; Br if yes...
	MOVL	#1,PASS_COUNT		; ...else save the integer default...
	MOVL	#1,OUTLEN		; ...and fill in the default pass count
	MOVB	#^A/1/,ANSWER+8
	BRB	20$			; Go to logical name create

10$:	; Here we test for valid input - either from P2 or response to prompt

	PUSHL	#4			; Push size of results
	PUSHAL	PASS_COUNT		; Push place for results
	PUSHAL	OUTLEN			; Push ascii results
	CALLS	#3,G^OTS$CVT_TI_L	; Save the long word pass count
	CMPL	R0,#OTS$_INPCONERR	; Did it get input right?
	BNEQ	20$			; Br if yes...
	BBC	#PROMPTV,FLAGS,15$	; BR if not prompting
	BSBW	SYNTAX_ERROR		; ...else report the error...
	BRB	PASS			; ...and try again

15$:	; P2 is an invalid string for pass count - bitch and quit

	$FAO_S	CTRSTR = INVALID_PASS_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P2_DESC
	PUSHL	#SS$_BADPARAM
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#4
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT
20$:
	$CRELOG_S LOGNAM = PASS_NAME,-
		  EQLNAM = OUTLEN,-
		  TBLFLG = #1		; Make the pass count group logical name

;+
;	The default LOADS value is determined by several system parameters.
;	These parameters are extracted from the system and crunched to a
;	final value.  The system parameters are:
;
;		SID		CPU type, modified if multiprocessor config
;		MEM_FREE	Free main memory
;		MEM_MODIFY	Modified main memory
;		WS_SIZE		Current process working set size
;		FREE_PAGE	Free page file space
;		SWAP_SIZE	Free process swap slots
;
;	Constants are defined in this program for the calculation:
;
;		PP_PAGE_USAGE	Estimated amount of page file used per process
;		PER_WS_INUSE	Estimated amount of WS in constant use
;		CPU_SCALE	Estimated CPU performance ratio where 11/780 = 1
;
;	The equation used with these values is given in the strings DUMP_MSG1
;	and DUMP_MSG2.
;-

LOAD:
	ADDL3	MEM_MODIFY,MEM_FREE,R7	; Calculate total amount of free memory
	CVTLF	R7,R7			; Convert free memory size to float
	CVTLF	WS_SIZE,R8		; Convert WS to floating format
	MULF2	#PER_WS_INUSE,R8	; Scale the WS
	DIVF2	R8,R7			; Create a rough process capacity count
	MULF2	CPU_SCALE,R7		; Scale the count for the CPU type
	CVTFL	R7,R7			; Convert back to integer
	DIVL3	#PP_PAGE_USAGE,-	; Calculate page process count limit
		PAGE_SIZE,R6

	PUSHL	#2			; Push # of digits in the fraction
	PUSHAL	CPU_SCALE_DES		; Push string storage desc adr
	PUSHAF	CPU_SCALE		; Push adr of floating number
	CALLS	#3,G^FOR$CNV_OUT_F	; Make the number a string
	PUSHL	#2			; Push # of digits in the fraction
	PUSHAL	WS_INUSE_DES		; Push string storage desc adr
	PUSHAF	WS_INUSE		; Push adr of floating number
	CALLS	#3,G^FOR$CNV_OUT_F	; Make the number a string
	BBC	#DUMPV,FLAGS,10$	; BR if not in dump mode - no message
	$FAO_S	CTRSTR = DUMP_MSG1,-	; Make the first output string
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #CPU_SCALE_DES,-
		P2     = MEM_FREE,-
		P3     = MEM_MODIFY,-
		P4     = WS_SIZE,-
		P5     = #WS_INUSE_DES,-
		P6     = R7
	$PUTMSG_S MSGVEC = DUMP_MSG_PTR,- ; Print the filled in equation
		  ACTRTN = ACTRTN
	$FAO_S	CTRSTR = DUMP_MSG2,-	; Make the second output string
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = SWAP_SIZE,-
		P2     = PAGE_SIZE,-
		P3     = #PP_PAGE_USAGE-
		P4     = R6
	$PUTMSG_S MSGVEC = DUMP_MSG_PTR,- ; Print the filled in equation
		  ACTRTN = ACTRTN
10$:
	MOVL	R6,PAGE_SIZE		; Page process count limit
	MOVL	R7,MEM_SIZE		; Available main memory
	PUSHAL	SWAP_SIZE		; Find the minimum of swap slots...
	PUSHAL	PAGE_SIZE		; ...free page file space...
	PUSHAL	MEM_SIZE		; ...usable main memory...
	CALLS	#3,G^MTH$JMIN0		; ...and leave the results in R0
	MOVL	R0,LOAD_COUNT		; save the MIN
	MOVL	#4,OUTLEN		; Set the results length
	PUSHAQ	OUTLEN			; Push output string desc
	PUSHAL	LOAD_COUNT		; Push the load count value
	CALLS	#2,G^OTS$CVT_L_TI	; Convert the load count to a string

	$SETSFM_S ENBFLG = #0		; Disable SS failure mode if no match
	$DELLOG_S LOGNAM = USERS,-	; Clean out any possible name that...
		  TBLFLG = #1		; ...might be left from a previous run
	$SETSFM_S ENBFLG = #1		; Re-enable system service failure mode

	BBC	#PROMPTV,FLAGS,40$	; BR if we need not prompt at all
	MATCHC	KEY_LOAD_DESC,-		; We need only prompt...
		@KEY_LOAD_DESC+4,-	; ...if the LOAD phase...
		PARAM_MSG,PARAM_BUF	; ...was among the phases selected
	BEQL	20$			; BR if user has a choice
	BRW	80$			; No choice - use default
20$:	$FAO_S  CTRSTR = LOAD_PROMPT,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = LOAD_COUNT	; Create the prompt string

30$:	MOVW	#MAXSYM_SZ,P3_DESC	; Define desc for response
	PUSHAW	P3_DESC			; Set response length location
	PUSHAL	BUFFER_PTR		; Set prompt string
	PUSHAQ	P3_DESC			; Set answer address
	CALLS	#3,G^LIB$GET_COMMAND	; Ask for the load count
	BLBC	R0,50$			; BR if failure

40$:	; Test for valid input from P3 or prompt response
	MOVAQ	P3_DESC,R2		; Point to desc for response
	TSTW	(R2)			; Any response?
	BEQL	80$			; BR if not - use default
	MOVZWL	(R2),OUTLEN		; Set P3 param length in buffer
	MOVC3	(R2),@4(R2),@OUTLEN+4	; Use P3 for load count
	PUSHAL	ARG_COUNT		; Push place for results
	PUSHAL	OUTLEN			; Push ascii results
	CALLS	#2,G^OTS$CVT_TI_L	; Save the long word load count
	BLBS	R0,70$			; BR if we got a reasonable number
	BBC	#PROMPTV,FLAGS,50$	; BR if not prompting
	BSBW	SYNTAX_ERROR		; ...else report the error...
	BRB	30$			; ...and try again

50$:	MOVL	#4,R2			; Assume we are prompting
	BBS	#PROMPTV,FLAGS,60$	; BR if that's the case
	PUSHL	S^#SS$_BADPARAM		; We give an additional error if not
	INCL 	R2
	EXTZV	#STS$V_FAC_NO,-		; Was this a System or RMS error?
		#STS$S_FAC_NO,R0,R3
	DECL	R3			; They're facilities 0 & 1, respectively
	BLEQ	60$			; BR if System or RMS
	PUSHL	#0			; Dummy arg count needed...
	INCL	R2			; ...for other facilities' messages
60$:
	PUSHL	R0			; Save the error status
	$FAO_S	CTRSTR = INVALID_LOADCNT_MSG,- 	; P3 is an invalid load count
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P3_DESC
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	R2
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT		; Bitch and quit

70$:	MOVL	ARG_COUNT,LOAD_COUNT	; It converted OK save it away
80$:	$CRELOG_S LOGNAM = USERS,-
		  EQLNAM = OUTLEN,-
		  TBLFLG = #1		; Make the load count group logical name

;+
; If the prompt flag is set we prompt the user for LONG or SHORT report format 
; to be used by the rest of the UETP, else if P4 is defined we use that.
; If P4 is not defined or the prompt returns null, we use the default which
; is LONG report.
;-

REPORT_Q:
	BBS	#PROMPTV,FLAGS,3$	; BR if prompting
	MOVL	P4_DESC,OUTLEN		; Set P4 param length in buffer
	MOVC3	P4_DESC,P4_BUF,@OUTLEN+4 ; Put specified mode in buffer 
	BRB	5$
3$:
	PUSHAL	OUTLEN			; Set response length location
	PUSHAL	REPORT_PROMPT		; Set prompt string
	PUSHAL	ANSWER			; Set asnwer address
	CALLS	#3,G^LIB$GET_COMMAND	; Ask for the report format
	BLBS	R0,5$			; If no failure than continue
	MOVL	R0,STATUS		; else save error and
	BRW	FINI			; bail out
5$:
	TSTL	OUTLEN			; Any format specified?
	BNEQ	10$			; Br if yes...
	BRB	20$			; Go fill in LONG
10$:
	BICB2	#LCBIT,ANSWER+8		; Make sure that it is upper case
	CMPB	#^A/L/,ANSWER+8		; Is it long report format?
	BEQL	20$			; Br if yes
	CMPB	#^A/S/,ANSWER+8		; Is it short report format?
	BEQL	30$			; Br if yes...
	BBC	#PROMPTV,FLAGS,15$	; BR if not prompting
	BSBW	SYNTAX_ERROR		; ...else report a syntax error...
	BRB	REPORT_Q		; ...and ask again

15$:	; P4 is an invalid report type - bitch and quit

	$FAO_S	CTRSTR = INVALID_REPORT_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P4_DESC
	PUSHL	#SS$_BADPARAM
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#4
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT
20$:	; Long format
	MOVW	#4,OUTLEN
	MOVL	#^A/LONG/,ANSWER+8
	BRB	40$
30$:	; Short format
	MOVW	#5,OUTLEN
	MOVQ	#^A/SHORT/,ANSWER+8
40$:
	$CRELOG_S LOGNAM = REPORT_NAME,-
		  EQLNAM = OUTLEN,-
		  TBLFLG = #1		; Make the report format group logical name

;+
;
; Any additional UETP prompting code should be inserted at this point
; in the code.
;
;-

;+
;	All the interaction needed to set up a run of the UETP has been done.
;	Clean up and form a message summarizing what the user wants.
;-
FINAL_MESSAGE:
	$FAO_S	CTRSTR = START_MESSAGE,-; Make the startup message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #0
	MOVAL	BUFFER_PTR,MSG_DESC
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well
	MOVZWL	PARAM_MSG,R6		; Get current length
	MOVC3	PHASES,@PHASES+4,-	; Add "PHASE(S)" to  msg
		PARAM_BUF[R6]
	ADDW2	PHASES,PARAM_MSG	; Update msg length

	CMPL	#1,PASS_COUNT		; Are we running only 1 pass
	BNEQ	20$			; Br if not 1	
	SUBW2	#2,PASS_MSG		; Drop "ES" off "PASSES"
20$:
	$FAO_S	CTRSTR = PASS_MSG,-	; Create pass count portion of start msg
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = PASS_COUNT
	MOVZWL	PARAM_MSG,R6		; Get current length
	MOVC3	BUFFER_PTR,@BUFFER_PTR+4,- ; Add number of pass(es) to  msg
		PARAM_BUF[R6]
	ADDW2	BUFFER_PTR,PARAM_MSG	; Update msg length
	$FAO_S	CTRSTR = LOAD_MSG,-	; Create loads count part of start msg
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = LOAD_COUNT
	MOVZWL	PARAM_MSG,R6		; Get current length
	MOVC3	BUFFER_PTR,@BUFFER_PTR+4,- ; Add number of load(s) to msg
		PARAM_BUF[R6]
	ADDW2	BUFFER_PTR,PARAM_MSG	; Update msg length
30$:
	MOVZWL	PARAM_MSG,R6		; Get current length
	CMPB	#^A/L/,ANSWER+8		; Long report?
	BNEQ	40$			; Br if not Long
	MOVC3	LONG_MSG,@LONG_MSG+4,-	; Add "LONG REPORT" to msg
		PARAM_BUF[R6]
	ADDW2	LONG_MSG,PARAM_MSG	; Update length
	BRB	50$			; Go output message
40$:
	MOVC3	SHORT_MSG,@SHORT_MSG+4,- ; Add "SHORT REPORT" too msg
		PARAM_BUF[R6]
	ADDW2	SHORT_MSG,PARAM_MSG	; Update msg length
50$:
	MOVAL	PARAM_MSG,MSG_DESC
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status

	.SBTTL	Figure Various Limits of This Configuration
;++
; This code was stolen from the CLI Utility program for SHOW MEMORY.  It runs
; in EXEC mode.
;
; It uses the memory descriptors in the Restart Parameter Block
; to determine the amount of physical memory in use.  A check is made to
; see if multiport memory should be counted as local memory.
;
; The following set of assumptions state that all multiport memory adapter
; type codes are bounded by NDT$_MPM0 and NDT$_MPM3 and that no adapter
; type codes in this range represent anything other than multiport memory.
;
	ASSUME	NDT$_MPM0 LT NDT$_MPM1
	ASSUME	NDT$_MPM1 LT NDT$_MPM2
	ASSUME	NDT$_MPM2 LT NDT$_MPM3
;--

GET_MEM_INFO:
	.WORD	^M<R2,R3,R4,R5,R6,R7>

	MOVL	G^EXE$GL_CONFREGL,R0	; Get address of TR/adapter type array
	MOVL	G^EXE$GL_RPB,R1		; Get addr of RPB
	MOVAL	RPB$L_MEMDSC(R1),R2	; Get addr of memory descriptors
	CLRQ	R6			; Init local and shared page counts
10$:	TSTL	(R2)			; End of memdsc list?
	BEQL	40$			; Yes - finished collecting info
	EXTZV	#RPB$V_TR,#RPB$S_TR,(R2),R3 ; Get TR number
	MOVL	(R0)[R3],R3		; Convert to adapter type
	EXTZV	#RPB$V_PAGCNT,-		; Get page count
		#RPB$S_PAGCNT,(R2),R4
	CMPB	R3,#NDT$_MPM0		; Is adapter number below MPM range?
	BLSSU	20$			; If so, this is local memory
	CMPB	R3,#NDT$_MPM3		; Is adapter number above MPM range
	BGTRU	20$			; If so, this is also local memory
	ADDL2	R4,R7			; Otherwise, this is multiport memory
	BRB	30$			; Go to end of loop

20$:	ADDL2	R4,R6			; This is local memory
30$:	ADDL2	#RPB$C_MEMDSCSIZ,R2	; Point to next memory descriptor
	BRB	10$			;  and go back to top of loop

; There are four cases that can occur here.
;
; 1.  There are no multiport memory controllers on the system.  R7 is 0 already.
;
; 2.  Multiport memory is being used as global shared memory.  Must clear R7.
;
; 3.  Multiport memory is being used as local memory.  This case is 
;     distinguished by RPB$V_USEMPM being set in the RPB copy of R5.
;
; 4.  Only multiport memory is being used as local memory.  Any memory
;     in local controllers is ignored.  This is the multiprocessor
;     configuration.  This case is distinguished by RPB$V_MPM 
;     being set in the RPB copy of R5.  Must clear R6.

40$:	BBC	#RPB$V_MPM,-		; BR if not multiprocessor config
		RPB$L_BOOTR5(R1),50$
	CLRL	R6			; We don't count any local memory...
	BRB	60$			; ...but always count shared memory
50$:	BBS	#RPB$V_USEMPM,-		; Also count shared memory?
		RPB$L_BOOTR5(R1),60$
	CLRL	R7			; No
60$:	ADDL2	R6,R7			; Calculate total available memory
	CMPL	G^MMG$GL_PHYPGCNT,R7	; How does that compare with SYSGEN?
	BGEQU	70$			; BR if we may use all we have
	MOVL	G^MMG$GL_PHYPGCNT,R7	; Use only as much as we are allowed
70$:	MOVL	R7,MEM_SIZE		; Return what's around and allowed

	MOVL	G^SCH$GL_FREECNT,MEM_FREE ; Get number of free memory pages
	MOVL	G^SCH$GL_MFYCNT,MEM_MODIFY ; Get number of memory pages modified
	SUBW3	G^SCH$GW_PROCCNT,-	; Process slots free = total slots...
		G^SCH$GW_PROCLIM,R0	; ...less slots in use...
	SUBW2	#2,R0			; ...less slots for swapper and null...
	MOVZWL	R0,SWAP_SIZE		; ...converted to a form we can use
	MOVL	S^#SS$_NORMAL,R0
	RET

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a system service or RMS error occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	The messages are output to SYS$OUTPUT and to UETP.LOG.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	PUSHL	#1			; Assume ASTs were enabled
	CMPL	S^#SS$_WASSET,R0	; Were ASTs enabled?
	BEQL	10$			; BR if they were
	CLRL	(SP)			; Set ASTs to remain disabled
10$:
	$SETSFM_S ENBFLG = #0		; Disable SS failure mode
	PUSHL	#1			; Assume SS failure mode was enabled
	CMPL	S^#SS$_WASSET,R0	; Was SS failure mode enabled?
	BEQL	20$			; BR if it was
	CLRL	(SP)			; Set SS failure mode to remain off
20$:
	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	MOVQ	CHF$L_SIG_NAME(R6),R9	; Get NAME in R9 and ARG1 in R10
	CMPZV	#STS$V_FAC_NO,-		; Is this a message from LIB$SIGNAL?
		#STS$S_FAC_NO,-
		R9,#UETP$_FACILITY
	BNEQ	30$			; BR if this is not a UETP exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6),- ; Print the message
		  ACTRTN = ACTRTN
	BRB	40$			; Restore ASTs and SS fail mode
30$:
	CMPL	#SS$_SSFAIL,R9		; RMS failures are SysSvc failures
	BNEQ	50$			; BR if this can't be an RMS failure
	CMPZV	#STS$V_FAC_NO,-		; Is it an RMS failure?
		#STS$S_FAC_NO,-
		R10,#RMS$_FACILITY
	BNEQ	50$			; BR if not
	BICL2	#^XF0000000,R10		; Strip control bits from status code
	MATCHC	#4,CHF$L_SIG_ARG1(R6),-	; Is it an RMS failure for which...
		#NRAT_LENGTH,-
		NO_RMS_AST_TABLE	; ...no AST can be delivered?
	BEQL	50$			; BR if so - must give error here
40$:
	POPR	#^M<R0>			; Restore SS failure mode...
	$SETSFM_S ENBFLG = R0		; ...
	POPR	#^M<R0>			; Restore AST enable...
	$SETAST_S ENBFLG = R0		; ...
	MOVL	S^#SS$_NORMAL,R0	; Supply a standard status for exit
	RET				; Resume processing (or goto RMS_ERROR)
50$:
	MOVL	R9,STATUS		; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,R9		; But is it a System Service failure?
	BNEQ	70$			; BR if not - no special case message
	$GETMSG_S MSGID = R10,-		; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	60$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	R10,#STS$V_SEVERITY,-	; Give the message...
		#STS$S_SEVERITY,(SP)	; ...the correct severity code
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	70$
60$:
	PUSHL	R10			; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
70$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			   ; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT

ACTRTN:
	.WORD	^M<R2>
	MOVL	4(AP),R2		; get the message descriptor address
	MOVZWL	(R2),LOG_RAB+RAB$W_RSZ	; set the message size
	MOVL	4(R2),LOG_RAB+RAB$L_RBF	; set the message address
	$PUT	RAB = LOG_RAB		; write to the log file
	MOVL	#SS$_NORMAL,R0		; set the return status code
	RET


	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	The FAB or RAB associated with the RMS call.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get file name size for implicit PUSHL
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	Syntax Error Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles syntax errors.
;
; CALLING SEQUENCE:
;	BSBW SYNTAX_ERROR
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

SYNTAX_ERROR:

	PUSHAL	SYNTAX_ERROR_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	#3,G^LIB$SIGNAL
	RSB

	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	TEST_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	MOVL	#<STS$M_INHIB_MSG!-	; Set the exit status
		SS$_CONTROLC--
		STS$K_SUCCESS+STS$K_WARNING>,-
		STATUS
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	ADDL3	(SP)+,#8,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	TEST_NAME		; Push test name...
	PUSHL	#^XF0002		; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		     ; Finish off arg list...
	PUSHAL	TEST_NAME		     ; ...
	PUSHL	#^X10002		     ; ...
	PUSHL	#UETP$_ERBOXPROC!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch
FINI:
	TSTL	STATUS			; Was an exit status supplied?
	BNEQ	10$			; BR if one was
	MOVL	#UETP$_ABENDD!STS$K_ERROR,- ; None there, supply a default
		STATUS
10$:
	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup on exits.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	Location STATUS contains the exit status
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$CLOSE FAB = LOG_FAB		; Close the log file
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETINIT00
