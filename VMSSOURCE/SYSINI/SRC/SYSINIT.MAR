	.TITLE	SYSINIT	- SYSTEM INITIALIZATION PROCESS
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	SYSTEM INITIALIZATION
;
; ABSTRACT:	PERFORMS OPERATIONS NECESSARY TO GET
;		THE SYSTEM TO A POINT THAT IT CAN
;		SUPPORT ITSELF.
;
; ENVIRONMENT:	OPERATES WITHIN THE LIMITED CAPABILITIES
;		THE BOOT STRAPPED OPERATING SYSTEM.
;
; AUTHOR:  W.H.BROWN, CREATION DATE:  6-JAN-77
;
; MODIFIED BY:
;
;	V03-033	HH0052		Hai Huang		28-Aug-1984
;		Correctly bias the reference count for the system device.
;
;	V03-032	RAS0304		Ron Schaefer		 4-May-1984
;		Re-define SYS$SYSDEVICE and SYS$DISK so that the
;		correct allocation-class is available to define the name.
;
;	V03-031	CDS0001		Christian D. Saether	 1-May-1984
;		Set the device characteristic CLU before mounting the
;		system disk if we intend to be a cluster.
;
;	V03-030	TMK0002		Todd M. Katz		28-Apr-1984
;		Completely redo how the system logical names are created.
;		I have done this to eliminate the last vestiges of the old
;		logical name system services and to optimize this code in
;		the process.
;
;	V03-029	DWT0212		David W. Thiel		09-Apr-1984
;		Add call to CNX$DISK_CHANGE when CLUB$T_QDNAME is
;		filled in.
;
;	V03-028	WMC0022		Wayne Cardoza		02-Apr-1984
;		Use XQP_RESIDENT SYSGEN parameter.
;
;	V03-027	RSH0120		R. Scott Hanna		19-Mar-1984
;		Make changes to SIP_LOOKUP_QFILE due to new quorum
;		file algorithm. Add SIP_START_QUORUM_TIMER.
;
;	V03-026	WMC0021		Wayne Cardoza		14-Mar-1984
;		Don't give message for NOSUCHFILE errors.
;
;	V03-025	WMC0020		Wayne Cardoza		10-Mar-1984
;		Make XQP a resident global section.
;
;	V03-024	ACG0399		Andrew C. Goldstein,	27-Feb-1984  12:33
;		Rename EXE$LOCK_DEV to IOC$LOCK_DEV
;
;	V03-023	WHM0001		Bill Matthews		17-Jan-1984
;		Add definition of SYS$SYSROOT and SYS$COMMON. Convert
;		CRELOG'S and TRNLOG to the LNM form.
;
;	V03-022	WMC0019		Wayne Cardoza		12-Jan-1984
;		XQP now has DZRO space, no CRF allowed.
;
;	V03-021	RSH0086		R. Scott Hanna		23-Nov-1983
;		Remove all timeout checks in SIP_LOOKUP_QFILE.
;
;	V03-020	RSH0080		R. Scott Hanna		11-Nov-1983
;		Use SIP_A_INDEXFHDR and SIP_A_FILEHDR as the index file
;		header and file header buffers in the call to FIL$OPENFILE_1 
;		from SIP_LOOKUP_QFILE.
;
;	V03-019	TMK0001		Todd M. Katz		08-Nov-1983
;		Add a PQL$_JTQUOTA (job-wide logical name table creation
;		quota) quota item to the standalone configure process's
;		$CREPRC quota list.
;
;	V03-018	WMC0006		Wayne Cardoza		13-Oct-1983
;		Better error reporting on file open errors.
;
;	V03-017	DWT0126		David W. Thiel		12-Sep-1983
;		Define system time early without writing anything to
;		the system disk.  Set cluster-wide time when joining or
;		forming a cluster.
;		Use correct synchronization when deallocating the file
;		cache.
;		Remove temporary crock to force use of XQP with system
;		disk.
;		
;	V03-016	RSH0058		R. Scott Hanna		24-Aug-1983
;		Add the routine SIP_LOOKUP_QFILE. This routine attempts
;		to open the disk quorum file using FILEREAD.
;
;	V03-015	TCM0001		Trudy C. Matthews	08-Aug-1983
;		Take out a shared lock on the system disk as soon as locking
;		is enabled.
;
;	V03-014	WMC0005		Wayne Cardoza		06-Aug-1983
;		Logical names not available when STACONFIG started.
;		STACONFIG needs all privileges.
;
;	V03-013	WMC0004		Wayne Cardoza		01-Aug-1983
;		Boot with an XQP system disk.
;
;	V03-012	DWT0112		David W. Thiel		29-July-1983
;		Add stand-alone configure invocation, lock state
;		setting, and waiting for cluster formation.
;
;	V03-011	ACG0344		Andrew C. Goldstein,	21-Jul-1983  16:40
;		Do mount of system disk in exec mode
;
;	V03-010	KDM0057		Kathleen D. Morse	12-Jul-1983
;		Change SIP_SETTIME into a loadable, cpu-dependent
;		routine, EXE$INIT_TODR.
;
;	V03-009	LJK0222		Lawrence J. Kenah	5-Jul-1983
;		Correct bug in $ENQW call introduced in LJK0211.
;
;	V03-008	LJK0211		Lawrence J. Kenah	22-Jun-1983
;		Several changes related to the new image activator and INSTALL
;
;		Remove the code that handcrafts a known file entry for the
;		ACP image. The process based XQP makes this unnecessary.
;
;		Remove the code that initializes the various KFE lists. This
;		is now done by INSTALL.
;
;		Add code to take out a lock for the system ID resource.
;
;		Change the name of a routine in the exec to FIL$INIWCB.
;
;	V03-007	WMC0003		Wayne Cardoza		10-May-1983
;		Use EXE$SYS_SECTION to map system sections.
;
;	V03-006	WMC0002		Wayne Cardoza		09-May-1983
;		Map the XQP image sections.
;
;	V03-005	JWH0204		Jeffrey W. Horn		28-Mar-1983
;		Replace BOO$CRMPSC with EXE$LOAD_PAGED.
;
;	V03-004	WMC0001		Wayne Cardoza		08-Mar-1983
;		Save the system boot time.
;		If no TOY clock, increment time by 10 msec
;
;	V03-003	ACG53600	Andrew C. Goldstein,	10-Feb-1983  17:08
;		Make time validation checks more liberal
;
;
;--
	.PAGE

	.SBTTL	DECLARATIONS
	.nocross

;
; MACROS:
;
;
; PROGRAM SECTION DEFINITION MACROS
;	ARGUMENTS ARE:
;		1) SECTION NAME (KEY WORD IS NAME)
;		2) ALIGNMENT    (KEY WORD IS ALIGN)
;
;	IN ALL CASE, ARGUMENTS ARE OPTIONAL
;
; MACRO TO GENERATE A PROGRAM SECTION FOR EXECUTABLE CODE
;
	.MACRO	PURE_SECT NAME=SIP_PURE,ALIGN=BYTE
 
	.PSECT	NAME	EXE,RD,NOWRT,ALIGN
 
	.ENDM	PURE_SECT
;
; MACRO TO GENERATE IMPURE DATA SEGMENT
;
	.MACRO	IMPURE_DATA  NAME=SIP_RWDATA,ALIGN=LONG
 
	.PSECT	NAME	NOEXE,WRT,RD,ALIGN
 
	.ENDM	IMPURE_DATA
;
; MACRO TO GENERATE A STRING WITH DESCRIPTOR
;
;	STRING_DESC <STRING> 
;
; WHERE:
;	<STRING> IS THE STRING TO BE USED
;
	.MACRO	STRING_DESC ST,?L1,?L2
 
	.LONG	L2-L1
	.LONG	L1
L1:	.ASCII	\ST\
L2:
 
	.ENDM

;
; MACRO TO GENERATE A LIST OF SELFRELATIVE WORD POINTERS
;
	.MACRO	OFFSET	LIST
	.IRP	$$$,<LIST>
	.WORD	<$$$-.-2>
	.ENDR
	.ENDM	OFFSET

;
; EQUATED SYMBOLS:
;
	$ATRDEF				; FILE ATTRIBUTE DEFINITIONS
	$BOODEF				; BOOT CONTROL BLOCK DEFINITIONS
	$CCBDEF				; CHANNEL CONTROL BLOCK DEFINITIONS
	$CLUBDEF			; CLUSTER BLOCK DEFINITION
	$CLUDCBDEF			; CLUSTER QUORUM DISK CONTROL BLOCK DEFINITIONS
	$DEVDEF				; DEVICE BIT DEFINITIONS
	$DMPDEF				; SYSTEM DUMP FILE HEADER DEFINITONS
	$DVIDEF				; $GETDVI ITEM LIST CODES
	$DYNDEF				; STRUCTURE TYPE DEFINITIONS
	$EMBDEF CR			; ERROR LOG MESSAGE BUFFER FORMAT
	$ERLDEF				; ERROR LOG BUFFER DEFINITIONS
	$FIDDEF				; FILE ID OFFSET DEFINITIONS
	$IACDEF				; IMAGE ACTIVATOR INTERFACE BITS
	$IHDDEF				; IMAGE FILE HEADER DEFINITIONS
	$IHPDEF				; IMAGE HEADER PATCH DEFINITIONS
	$IHSDEF				; IMAGE HEADER SYMBOLIC DEBUGGING DEFS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$ISDDEF				; IMAGE SECTION DESCRIPTIONS
	$LCKDEF				; FLAG BITS FOR CALL TO $ENQW
	$LNMDEF				; DEFINE LOG OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFLDEF				; PAGE FILE OFFSET DEFINITONS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PQLDEF				; PROCESS QUOTA DEFINITIONS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRTDEF				; PAGE PROTECTION DEFINITIONS
	$PRVDEF				; PRIVILEGE DEFINITIONS
	$PSLDEF				; PSL DFINITIONS
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$PTRDEF				; POINTER CONTROL BLOCK OFFSETS
	$RPBDEF				; DEFINE RPB OFFSETS
	$SECDEF				; DEFINE PROCESS SECTION
	$TQEDEF				; DEFINE TIMER QUEUE ENTRY OFFSETS
	$UCBDEF				; UNIT CONTROL BLOCK DEFINITIONS
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$WCBDEF				; WINDOW CONTROL BLOCK DEFINITIONS

	SIP_C_DUMPVER = 2		; DUMP FILE HEADER VERSION
	SIP_C_MINPAGFIL = 2500-2048	; MINIMUM PAGE FILE REQUIRED
;
; OFFSETS INTO FILE ATTRIBUTES ARRAY
;
	$OFFSET	0,POSITIVE,<-
	<STATBLK,0>,-			; 8 BYTE STATISTICS BLOCK CONSISTING OF
	FILELBN,-			; STARTING LBN OR 0 IF NOT CONTIG
	FILESIZE,-			; SIZE OF FILE IN 512 BYTE BLOCKS
	IMAGEVBN,-			; FIRST VBN IF IMAGE FORMAT
	IMAGESIZE,-			; SIZE IF IMAGE FORMAT
	RTRVLEN,-			; BYTE COUNT OF RETRIEVAL POINTERS
	<RTRVPTRS,0>-			; FIRST RETRIEVAL POINTER
	>

	.WEAK	XDT$START		; IF DEBUGGING, THEN DEFINED

	.cross

;
; OWN STORAGE:
;
	PURE_SECT
 
SIP_Q_TTNAME:
	STRING_DESC	<OPA0>		; DEVICE NAME FOR TERMINAL
 
SIP_Q_FIBDESC:
	.LONG	SIP_C_FIB_SIZE,SIP_A_FIB ; DESCRIPTOR FOR FILE IDENT BLOCK
SIP_A_ATRLIST:
	.WORD	ATR$S_ASCNAME,ATR$C_ASCNAME ; ASCII NAME ATTRIBUTE
	.LONG	SIP_A_ERLBUFFER		; SET ADR TO STORE NAME HERE
	.LONG	0			; END OF ATTRIBUTE LIST
 
SIP_Q_STARTUP:				; STARTUP PROCESS NAME
	STRING_DESC	<STARTUP>	;


SIP_Q_SPOUTPUT:				; STARTUP PROCESS OUTPUT
	STRING_DESC	<OPA0:>		; CONSOLE
SIP_Q_SPOUTXDT:				; STARTUP PROCESS OUTPUT (DELTA)
	STRING_DESC	<NLA0:>		; NULL DEVICE

SIP_Q_SPIMAGE:				; STARTUP PROCESS IMAGE
	STRING_DESC	<SYS$SYSTEM:LOGINOUT.EXE>	; NORMAL LOGINOUT IMAGE

SIP_Q_PRVMSK:
	.LONG	-1,-1			; INITIAL PRIVILEGES
 
FAOERR:	STRING_DESC  <%SYSINIT-E- !AC, status = !XL>
CRELNMERR:
	.ASCIC	\failed to create system logical names\
PAGFILERR:
	.ASCIC	\lookup failure on paging file\
MSGFILERR:
	.ASCIC	\message file not found, or insufficient SPT to map it\
 
ACPINIERR:
	.ASCIC	\F11ACP initialization error\
 
MOUERR:	.ASCIC	\error mounting system device\

LOCKERR:
	.ASCIC	\error taking out lock on system disk\
 
INIPAGFIL:				; ERROR INITIALIZING THE PAGE OR SWAP FILE
	.ASCIC	\page file or swap file control block initialization error\
 
RMSMAPERR:				; ERROR ON RMS FILE MAP
	.ASCIC	\RMS.EXE not found, or insufficient SPT to map it\

FILOPNERR:				; ANY FILE OPEN ERROR - MORE MESSAGES LATER
	.ASCIC	/error opening file/
 
INIWCBERR:				; ERROR INITING A WINDOW CONTROL BLOCK
	.ASCIC	\error initializing a window control block\
 
XQPERR:	.ASCIC	/error opening or mapping F11BXQP/

SYSID_LOCK_ERR:
	.ASCIC	\unable to obtain lock for system ID resource\

SIP_CLU_MSG:
	.ASCIC	\waiting to form or join VAXcluster\
 
INIKNOWNFIL:
	.ASCIC	\known file list initialization error\
 
PAGFILNAM:
	.ASCIC	\PAGEFILE.SYS\
SWPFILNAM:
	.ASCIC	\SWAPFILE.SYS\
RMSFILNAM:
	.ASCIC	\RMS.EXE\
MSGFILNAM:
	.ASCII	\SYS$MESSAGE:SYSMSG.EXE\
	MSGFILNAMSZ=.-MSGFILNAM
 
;
; ***** PAGE FILE MUST BE FIRST
;
SIP_A_NAMES:
	.LONG	PAGFILNAM		; FILENAME AND ERROR POINTER
	.LONG	SWPFILNAM		;
	.LONG	RMSFILNAM		;
	.LONG	0			; END OF LIST
;
XQPNAM:	.ASCII	/SYS$SYSTEM:F11BXQP.EXE/
	XQPNAMSIZ = .-XQPNAM
;
;
	IMPURE_DATA SIP_RWDATA_PAGE,PAGE
;
;	THIS BUFFER IS USED FOR THE QUORUM FILE LOOKUP AND TO READ
;	THE SYSTEM DUMP FILE FOR ERROR LOG INFORMATION
;
SIP_A_ERLBUFFER:			; 
	.BLKB	<3*512>			; 3 PAGES
SIP_A_INDEXFHDR	= SIP_A_ERLBUFFER	; INDEX FILE HEADER BUF (FIL$OPENFILE)
SIP_A_FILEHDR	= SIP_A_ERLBUFFER+512	; FILE HEADER BUFFER (FIL$OPENFILE)

	IMPURE_DATA
 
MSGFILFAB:	$FAB	FAC=GET,-	; FILE ACCESS IS GET (READ)
		FOP=<UFO>,-		; USER FILE OPEN
		FNA=MSGFILNAM,-		; ADDRESS OF FILE NAME STRING
		FNS=MSGFILNAMSZ,-		; 
		RFM=FIX,-		; FIXED RECORD FORMAT
		MRS=512,-		; MAXIMUM RECORD SIZE OF ONE PAGE
		RTV=255,-		; LET ACP COMPUTE LARGEST RETRIEVAL WINDOW
		XAB=MSGFILXAB		; EXTENDED ATTRIBUTE BLOCK
MSGFILXAB:	$XABFHC			; EXTENDED ATTRIBUTE BLOCK FOR FILE HEADER

XQPFAB:	$FAB	FAC=GET,-		; FILE ACCESS IS GET (READ)
		FOP=<UFO>,-		; USER FILE OPEN
		FNA=XQPNAM,-		; ADDRESS OF FILE NAME STRING
		FNS=XQPNAMSIZ,-		; 
		RFM=FIX,-		; FIXED RECORD FORMAT
		MRS=512,-		; MAXIMUM RECORD SIZE OF ONE PAGE
		RTV=255			; LET ACP COMPUTE LARGEST RETRIEVAL WINDOW

SIP_A_FIB:				; FILE IDENTIFICATION BLOCK
	.LONG	0			; ACCESS CONTROL INFORMATION
	.WORD	0,0,0			; RETURNED FILE ID
	.WORD	FID$C_MFD,FID$C_MFD,0	; DIRECTORY ID OF MFD
	SIP_C_FIB_SIZE=.-SIP_A_FIB
SIP_L_TTCHAN:
	.BLKL	1			; CHANNEL FOR TERMINAL HERE
 
SIP_Q_RETADR:				; RETURN ADDRESS RANGE FROM EXPREG
	.BLKQ	1
SIP_Q_TMPDESC:				; TEMPORY STRING DESCRIPTOR
	.BLKQ	1
SIP_Q_STATBLK:
	.BLKQ	1			; STATISTICS BLOCK RETURNED BY FIL$OPENFILE
SIP_Q_RTRVBUF:				; DESCRIPTOR FOR RTRV PTR BUFFER
	.BLKQ	1
SIP_L_RTRVLEN:				; RETURNED RTRV PTR BUFFER LENGTH
	.BLKL	1
SIP_A_OPENARG:				; ARGUMENT LIST TO FIL$OPENFILE
	.LONG	7			; 7 ARGUMENTS TO FIL$OPENFILE
	.LONG	SIP_L_DSKCHAN		; ADDRESS TO RETURN DISK CHANNEL
	.LONG	SIP_Q_TMPDESC		; ADDRESS OF FILE NAME DESCRIPTOR
	.LONG	SIP_A_INDEXFHDR		; BUFFER ADDRESS FOR INDEX FILE HEADER
	.LONG	SIP_A_FILEHDR		; BUFFER ADDRESS FOR FILE HEADER
	.LONG	SIP_Q_STATBLK		; ADDRESS TO RETURN STATISTICS BLOCK
					;    STARTING LBN IF CONTIG, 0 IF NOT
					;    FILE SIZE IN BLOCKS
	.LONG	SIP_L_RTRVLEN		; ADR TO RETURN RTRV PTR BUF LENGTH
	.LONG	SIP_Q_RTRVBUF		; ADR OF RTRV PTR BUF DESCRIPTOR
 
SIP_L_ERRSEQ:
	.LONG	0			; SAVED ERROR SEQUENCE NUMBER
					; FROM DUMP FILE HEADER
SIP_A_FILATT:				; LIST OF FILE ATTRIBUTE AREAS
SIP_L_PAGATT:				; PAGE FILE
	.BLKL	1
SIP_L_SWPATT:				; SWAP FILE
	.BLKL	1
SIP_L_RMSATT:				; RMS
	.BLKL	1

SIP_L_DSKCHAN:
	.BLKL	1			; CHANNEL FOR DISK HERE

SIP_Q_LINBUF:
	.WORD	0,SIP_C_LINBUFSIZ	; DESCRIPTOR FOR LINE BUFFER
	.LONG	SIP_T_LINBUF
 
SIP_T_LINBUF:
	.BLKB	132
 
SIP_C_LINBUFSIZ=.-SIP_T_LINBUF
 
CREPRCERR:				; CREATE PROCESS ERROR
	.BYTE	CREERREND-.-1		; LENGTH OF STRING
	.ASCII	\create process error on \
CREPRCNAM:				;
	.BLKB	15			;
CREERREND:

SIP_Q_SPINPUT:				; STARTUP PROCESS INPUT
	.LONG	0			; COUNT FOR STRING
	.LONG	EXE$GT_STARTUP+1	; ADDRESS 

XQP_GSDNAM:
	.ASCII	/SYSXQP_000/
	XQP_GSDNAM_SIZ = .-XQP_GSDNAM
XQP_GSD_DESC:
	.LONG	XQP_GSDNAM_SIZ
	.ADDRESS XQP_GSDNAM
XQP_NAME: 
	.ASCID /SYS$SYSTEM:F11BXQP.EXE/
XQP_DEF: 
	.ASCID /SYS$SYSTEM:.EXE/
XQP_INADDR: 
	.LONG 0,0
XQP_RETADDR: 
	.LONG 0,0
XQP_HEADER: 
	.BLKB 512

	.SUBTITLE	Data Used by $ENQW Request
;+
; The following data area is used by the $ENQW request that obtains a lock
; whose name contains the system ID
;-

LOCK_FLAGS = -				; Flags used by $ENQW call
	LCK$M_SYSTEM ! -		;  Do not qualify lock name with UIC
	LCK$M_NOQUEUE ! -		;  There should be nothing to wait for
	LCK$M_CVTSYS ! -		;  The lock will be owned by the system
	LCK$M_SYNCSTS

; Lock status block. The lock ID will be stored in an exec data cell after
; the service successfully completes.

LOCK_STATUS_BLOCK:
LOCK_STATUS:	.BLKW	2
LOCK_ID:	.LONG	0

; The lock name begins with the facility name in ASCII. The guts of the lock
; name consists of the six-byte system ID. The "ID" suffix is a cute way of
; rounding the name up to multiple of four.

LOCK_NAME:	.ASCII	/SYS$SYS_ID/
SYS_ID:		.BLKB	6
LOCK_NAME_SIZE = . - LOCK_NAME

LOCK_NAME_DESC:
	.LONG		LOCK_NAME_SIZE
	.ADDRESS	LOCK_NAME

	.SUBTITLE	Data Used To Create Stand-Alone Configure Process

;
; The following data is used in creating the stand-alone Configure Process
;

; Image name
;
STAC_IMAGE:	.ASCID	/STACONFIG.EXE/

; Input/output/error names
;
STAC_OPER:	.ASCID  /_OPA0:/

; Process privilege mask
;
STAC_PRV_MSK:	.LONG	-1,-1

; Process name
;
STAC_PRC:	.ASCID  /STACONFIG/

; Process quotas
;
STAC_QLIST:
	.BYTE	PQL$_ASTLM
	.LONG	200
	.BYTE	PQL$_BIOLM
	.LONG	200
	.BYTE	PQL$_BYTLM
	.LONG	100000
	.BYTE	PQL$_CPULM
	.LONG	0
	.BYTE	PQL$_DIOLM
	.LONG	200
	.BYTE	PQL$_ENQLM
	.LONG	200
	.BYTE	PQL$_FILLM
	.LONG	200
	.BYTE	PQL$_PGFLQUOTA
	.LONG	20480
	.BYTE	PQL$_PRCLM
	.LONG	200
	.BYTE	PQL$_TQELM	
	.LONG	200
	.BYTE	PQL$_WSDEFAULT
	.LONG	100
	.BYTE	PQL$_WSQUOTA
	.LONG	512
	.BYTE	PQL$_JTQUOTA
	.LONG	1024
	.BYTE	PQL$_LISTEND

SIP_CLU_TIMOUT:				; 100 milli-second quadword value
	.LONG	-1000*1000,-1

	.SUBTITLE	Data Used For Quorum disk

SIP_QD_CHAN:				; Quorum disk channel number
	.LONG	0

SIP_QD_IOSB:				; I/O status block
SIP_QD_STATBUF:				; Statistics buffer
	.QUAD	0

SIP_QD_DESCR:				; Quorum disk name descriptor
	.WORD	CLUDCB$S_DISK_QUORUM
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.LONG	CLU$GB_QDISK

SIP_QF_DESCR:				; Full quorum file name descriptor
	.WORD	0
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.LONG	SIP_QF_BUFFER

SIP_QF_NAME:
	.ASCII	/[000000]QUORUM.DAT;1/
	SIP_QF_NAME_SIZE = .-SIP_QF_NAME

SIP_QF_BUFFER:
	.BLKB	64+SIP_QF_NAME_SIZE

SIP_QD_ITMLST:
	.WORD	64,DVI$_FULLDEVNAM
	.LONG	SIP_QF_BUFFER
	.LONG	SIP_QF_DESCR
	.LONG	0

	.SBTTL	IMPURE DATA FOR $CRELNM AND $TRNLNM CALLS

SYS_COMMON_ITMLST:
	.WORD	4,LNM$_ATTRIBUTES
	.LONG	TERMINAL_CONCEALED_ATTR	;SYS$COMMON BOTH TERMINAL AND CONCEALED
	.LONG	0
SYS_SYSROOT_CMNSYS_LEN:
	.WORD	0
	.WORD	LNM$_STRING
SYS_SYSROOT_CMNSYS:
	.LONG	0
	.QUAD	0

SYS_SYSDEVICE_ITMLST:
	.WORD	4,LNM$_ATTRIBUTES
	.LONG	SYS_SYSDEVICE_ATTR
	.LONG	0
SYS_SYSDEVICE_DEV_LEN:
	.WORD	32
	.WORD	LNM$_STRING
SYS_SYSDEVICE_DEV:
	.LONG	SIP_A_ERLBUFFER
	.LONG	SYS_SYSDEVICE_DEV_LEN
	.LONG	0

SYS_SYSDEVICE_ATTR:
	.LONG	0

SYS_SYSDEVICE_DVI_LST:
	.WORD	32
	.WORD	DVI$_FULLDEVNAM
	.LONG	SIP_A_ERLBUFFER
	.LONG	SYS_SYSDEVICE_DEV_LEN
	.LONG	0

SYS_SYSROOT_ITMLST:
	.WORD	4,LNM$_ATTRIBUTES
	.LONG	TERMINAL_CONCEALED_ATTR	;TOPSYS BOTH TERMINAL AND CONCEALED
	.LONG	0
SYS_SYSROOT_TOPSYS_LEN:
	.WORD	0
	.WORD	LNM$_STRING
SYS_SYSROOT_TOPSYS:
	.LONG	0
	.LONG	0
	.WORD	4,LNM$_ATTRIBUTES
	.LONG	NO_ATTR			;CMNSYS NEITHER TERMINAL NOR CONCEALED
	.LONG	0
	.WORD	SYS_COMMON_LENGTH
	.WORD	LNM$_STRING
	.LONG	SYS_COMMON
	.QUAD	0

SYS_TOPSYS_ITMLST:
SYS_TOPSYS_DIRNAM_LEN:
	.WORD	0
	.WORD	LNM$_STRING
SYS_TOPSYS_DIRNAM:
	.LONG	0
	.QUAD	0

	.SBTTL	PURE DATA FOR $CRELNM AND $TRNLNM CALLS

	PURE_SECT

CMNSYS:
	.ASCIC	/SYSCOMMON.]/

LNM_FILE_DEV:
	.ASCID	/LNM$FILE_DEV/

LNM_SYSTEM_DESC:
	.ASCID	/LNM$SYSTEM/

SYS_COMMON:
	.ASCII	/SYS$COMMON:/
SYS_COMMON_LENGTH = . - SYS_COMMON

SYS_COMMON_DESC:
	.ASCID	/SYS$COMMON/

SYS_MESSAGE:
	.ASCII	/SYS$SYSROOT:[SYSMSG]/
SYS_MESSAGE_LEN = . - SYS_MESSAGE

SYS_MESSAGE_DESC:
	.ASCID	/SYS$MESSAGE/

SYS_SHARE:
	.ASCII	/SYS$SYSROOT:[SYSLIB]/
SYS_SHARE_LEN = . - SYS_SHARE

SYS_SHARE_DESC:
	.ASCID	/SYS$SHARE/

SYS_SYSDEVICE_DESC:
	.ASCID	/SYS$SYSDEVICE/

SYS_DISK_DESC:
	.ASCID	/SYS$DISK/

SYS_SYSROOT_DESC:
	.ASCID	/SYS$SYSROOT/

SYS_SYSTEM:
	.ASCII	/SYS$SYSROOT:[SYSEXE]/
SYS_SYSTEM_LEN = . - SYS_SYSTEM

SYS_SYSTEM_DESC:
	.ASCID	/SYS$SYSTEM/

SYS_TOPSYS_DESC:
	.ASCID	/SYS$TOPSYS/

SYSUAFALT:
	.ASCII	/SYSUAFALT/
SYSUAFALT_LEN = . - SYSUAFALT

SYSUAF_DESC:
	.ASCID	/SYSUAF/

EXEC_MODE:	.LONG	PSL$C_EXEC

TERMINAL_CONCEALED_ATTR:
		.LONG	LNM$M_TERMINAL!LNM$M_CONCEALED

NO_ATTR:	.LONG	0

SYS_MESSAGE_ITMLST:
	.WORD	SYS_MESSAGE_LEN,LNM$_STRING
	.LONG	SYS_MESSAGE
	.QUAD	0

SYS_SHARE_ITMLST:
	.WORD	SYS_SHARE_LEN,LNM$_STRING
	.LONG	SYS_SHARE
	.QUAD	0

SYS_SYSTEM_ITMLST:
	.WORD	SYS_SYSTEM_LEN,LNM$_STRING
	.LONG	SYS_SYSTEM
	.QUAD	0

SYSUAF_ITMLST:
	.WORD	SYSUAFALT_LEN,LNM$_STRING
	.LONG	SYSUAFALT
	.QUAD	0
 

	.SBTTL	SYSTEM INITIALIZATION PROCESS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS PROCESS IS INITIATED BY THE OPERATING SYSTEM AFTER
;	IT HAS BEEN BOOT STRAPPED AND PROCESSOR INITIALIZTION
;	HAS BEEN COMPLETED. THE FOLLOWING FUNCTIONS ARE
;	PERFORMED:
;
;		1) THE PER-SYSTEM ROOT LOCK IS CREATED
;		2) CLUSTER INITIALIZATION
;		   IF NO CLUSTER:
;			ENABLE UNCONSTRAINED LOCKING
;		   IF CLUSTER:
;			STALL ROOT LOCK REQUESTS
;			CREATE STAND-ALONE CONFIGURE PROCESS
;			WAIT FOR CLUSTER TO FORM
;		3) SYSTEM LOGICAL NAMES ARE CREATED
;		4) PAGEFILE, SWAPFILE, AND RMS ARE INITIALIZED
;		5  MERGE FILE SYSTEM XQP.
;		6) THE SYSTEM DISK IS MOUNTED (ACP STARTED UP)
;		7) THE SYSTEM MESSAGE FILE IS OPENED AND MAPPED
;		8) STARTUP PROCESS IS INITIATED, WHICH NOW STARTS UP
;		   JOBCTL, OPCOM, AND ERRFMT.
;
;
; CALLING SEQUENCE:
;
;	NONE-ENTERED DIRECTLY FROM THE IMAGE ACTIVATOR
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LOGICAL NAME "SYS$SYSDEVICE" IS ASSIGNED TO THE SYSTEM DISK
;	FIL$GQ_CACHE CONTAINS A DESCRIPTOR FOR THE FIL$OPENFILE CACHE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	FILE ADDRESS ARE STORED, THE SPECIFIED PROCESSES ARE CREATED
;
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	PURE_SECT

SIP_START:
	.WORD	0			; ENTRY MASK
	$CMKRNL_S	-
		W^SIP_GET_SYSID_LOCK	; OBTAIN LOCK FOR SYSTEM ID NAME

	$CMKRNL_S W^SIP_SETTIME		; SET THE INTERNAL SYSTEM TIME

	$CMKRNL_S	-
		W^SIP_CLUSTER_INIT	; CLUSTER RELATED INITIALIZATION

	CALLS	#0,W^LOCKDOWN		; LOCK PAGES THAT MUST BE LOCKED

;
; CREATE THE SYSTEM LOGICAL NAMES. AN ASSUMPTION MADE IS THAT AN INDEX 0
; TRANSLATION EXISTS FOR SYS$SYSDEVICE IF THE LOGICAL NAME IS SUCCESSFULLY
; TRANSLATED.
;

	$TRNLNM_S -			; GET TRANSLATION ATTR OF THE SYSTEM DISK
		ITMLST = SYS_SYSDEVICE_ITMLST,-
		LOGNAM = SYS_SYSDEVICE_DESC,-
		TABNAM = LNM_FILE_DEV
	BLBC	R0,5$			; QUIT ON FAILURE

	BICL2	#^C<LNM$M_TERMINAL!LNM$M_CONCEALED>,-
		SYS_SYSDEVICE_ATTR	; CLEAR UN-NEEDED ATTRIBUTES

	$GETDVIW_S -			; GET FULL DEVICENAME OF THE SYSTEM DISK
		EFN = #1,-		;
		IOSB = W^SIP_Q_STATBLK,-
		ITMLST = SYS_SYSDEVICE_DVI_LST,-
		DEVNAM = SYS_SYSDEVICE_DESC
	BLBC	R0,5$			; QUIT ON FAILURE

	CMPB	#^A\_\,@SYS_SYSDEVICE_DEV
	BNEQ	2$
	INCL	SYS_SYSDEVICE_DEV	; DISCARD LEADING "_"
	DECW	SYS_SYSDEVICE_DEV_LEN

2$:	$CRELNM_S -			; SET UPTODATE TRANSLATION OF THE SYSTEM DISK
		ITMLST = SYS_SYSDEVICE_ITMLST,-
		LOGNAM = SYS_SYSDEVICE_DESC,-
		ACMODE = EXEC_MODE,-	;
		TABNAM = LNM_SYSTEM_DESC
	BLBC	R0,5$			; QUIT ON FAILURE

	$CRELNM_S -			; SET UPTODATE TRANSLATION OF THE SYSTEM DISK
		ITMLST = SYS_SYSDEVICE_ITMLST,-
		LOGNAM = SYS_DISK_DESC,-
		ACMODE = EXEC_MODE,-	;
		TABNAM = LNM_SYSTEM_DESC

	BLBS	R0,10$			; CONTINUE IF TRANSLATION EXISTS
5$:	BRW	CRELNM_FATAL		; ELSE GENERATE ERROR

;
; CREATE LOGICAL NAMES FOR SYS$COMMON AND SYS$SYSROOT.
;

10$:	MOVZWL	SYS_SYSDEVICE_DEV_LEN,R6; SIZE OF DEVICE NAME TRANSLATION
	MOVL	SYS_SYSDEVICE_DEV,R7	; ADDRESS OF DEVICE NAME TRANSLATION
	ADDL3	R6,R7,R3		; ADDRESS OF FIRST BYTE BEYOND DEVICE
					; NAME TRANSLATION

20$:	MOVAL	FIL$GT_TOPSYS,R1	; TOP LEVEL SYSTEM DIRECTORY IF ANY
	MOVZBL	(R1)+,R0		; GET SIZE OF STRING
	BEQL	30$			; BRANCH IF NO TOP LEVEL DIRECTORY
	MOVB	#^A/[/,(R3)+		; BEGIN DIRECTORY STRING
	MOVC3	R0,(R1),(R3)		; MOVE THE TOP LEVEL DIRECTORY NAME
	MOVW	#^A/.]/,(R3)+		; AND THE SEPARATOR

30$:	SUBL3	R7,R3,R6		; GET SIZE OF THE EQUIVALENCE NAME
	MOVW	R6,SYS_SYSROOT_TOPSYS_LEN; STORE THE LENGTH IN THE ITEM LIST
	MOVL	R7,SYS_SYSROOT_TOPSYS	; STORE THE ADDRESS IN THE ITEM LIST
	$CRELNM_S -			; CREATE SYS$SYSROOT LOGICAL NAME
		ACMODE = EXEC_MODE,-	;
		ITMLST = SYS_SYSROOT_ITMLST,-
		LOGNAM = SYS_SYSROOT_DESC,-
		TABNAM = LNM_SYSTEM_DESC
	BLBC	R0,5$			; GENERATE ERROR MESSAGE ON FAILURES

	ADDL3	R6,R7,R3		; ADDRESS OF FIRST BYTE BEYOND 
					; SYS$SYSROOT CONSTRUCTED EQUIVALENCE
	MOVAL	CMNSYS,R1		; COMMON SYSTEM ROOT IF ANY
	MOVZBL	(R1)+,R0		; GET SIZE OF STRING
	MOVC3	R0,(R1),-1(R3)		; COPY THE COMMON SYSTEM ROOT NAME
	SUBL3	R7,R3,R6		; GET SIZE OF EQUIVALENCE NAME
	MOVW	R6,SYS_SYSROOT_CMNSYS_LEN; SET EQUIVALENCE NAME SIZE IN ITEM LIST
	MOVL	R7,SYS_SYSROOT_CMNSYS	; SET EQUIVALENCE NAME ADDR IN ITEM LIST
	$CRELNM_S -			; CREATE SYS$COMMON LOGICAL NAME
		ACMODE = EXEC_MODE,-
		ITMLST = SYS_COMMON_ITMLST,-
		LOGNAM = SYS_COMMON_DESC,-
		TABNAM = LNM_SYSTEM_DESC
	BLBC	R0,CRELNM_FATAL		; GENERATE ERROR MESSAGE ON FAILURES

;
; CREATE LOGICAL NAMES FOR SYS$MESSAGE, SYS$SHARE, AND SYS$SYSTEM.
;

	$CRELNM_S -			; CREATE SYS$MESSAGE LOGICAL NAME
		ACMODE = EXEC_MODE, -	
		ITMLST = SYS_MESSAGE_ITMLST,-
		LOGNAM = SYS_MESSAGE_DESC,-
		TABNAM = LNM_SYSTEM_DESC
	BLBC	R0,CRELNM_FATAL		; GENERATE ERROR MESSAGE ON FAILURES

	$CRELNM_S -			; CREATE SYS$SHARE LOGICAL NAME
		ACMODE = EXEC_MODE, -	
		ITMLST = SYS_SHARE_ITMLST,-
		LOGNAM = SYS_SHARE_DESC,-
		TABNAM = LNM_SYSTEM_DESC
	BLBC	R0,CRELNM_FATAL		; GENERATE ERROR MESSAGE ON FAILURES

	$CRELNM_S -			; CREATE SYS$SYSTEM LOGICAL NAME
		ACMODE = EXEC_MODE, -	
		ITMLST = SYS_SYSTEM_ITMLST,-
		LOGNAM = SYS_SYSTEM_DESC,-
		TABNAM = LNM_SYSTEM_DESC
	BLBS	R0,CRELNM_DONE		; GENERATE ERROR MESSAGE ON FAILURES

;
; FAILED TO CREATE THE SYSTEM LOGICAL NAMES.
;

CRELNM_FATAL:
	MOVAL	W^CRELNMERR,R1		; ERROR MESSAGE TEXT
	BSBW	SIP_FATAL		; REPORT ERROR AND QUIT

;
; SUCCESSFULLY CREATED THE SYSTEM LOGICAL NAMES.
;

CRELNM_DONE:				; SUCCESSFULLY CREATED LOGICAL NAMES
	BBC	#EXE$V_SYSUAFALT,EXE$GL_FLAGS,10$ ; BR IF NORMAL NAME FOR SYSUAF
	$CRELNM_S -			; EQUATE SYSUAF TO ALTERNATE NAME
		ITMLST = W^SYSUAF_ITMLST,-
		LOGNAM = W^SYSUAF_DESC,-
		TABNAM = W^LNM_SYSTEM_DESC

;
; THE FILE SYSTEM AND RMS ARE NOT YET AVAILABLE, USE THE BOOTSTRAP
; FIL$OPENFILE CODE TO "OPEN" THE FILES THAT MUST BE PRESENT BEFORE
; THE FILE SYSTEM CAN BE INITIALIZED.
;
10$:	CLRQ	R6			; R6 = SIZE OF ATTRIBUTE REGION
					; R7 = ADDRESS OF ATTRIBUTE REGION
	MOVAL	W^SIP_A_FILATT,R8	; ARRAY OF FILE ATTRIBUTE POINTERS
	MOVAL	W^SIP_A_NAMES,R9	; ARRAY OF FILE NAME POINTERS
	BBC	S^#EXE$V_PAGFILDMP,EXE$GL_FLAGS,30$ ; BRANCH IF DUMP
					; IS NOT IN PAGE FILE
	CMPL	(R8)+,(R9)+		; SYSBOOT "OPENED" PAGEFILE.SYS
					; DON'T BOTHER DOING IT AGAIN
30$:	MOVL	(R9)+,R1		; ADR OF ASCIC FILE NAME STRING
	BNEQ	32$			; PROCESS IT
	BRW	50$			; BRANCH IF THIS IS THE END
32$:	MOVZBL	(R1)+,R0		; SIZE IN R0, ADR IN R1
	MOVQ	R0,W^SIP_Q_TMPDESC	; STORE FILE NAME DESCRIPTOR
	CMPL	R6,#RTRVPTRS+8		; ENOUGH ROOM IN RTRV BUFFER
					; FOR FILE ATTRIBUTES AND AT LEAST
					; ONE RETRIEVAL POINTER?
	BGEQ	36$			; BRANCH IF YES
;
; NEED TO ALLOCATE (MORE) SPACE FOR FILE ATTRIBUTES
;
34$:	ADDL3	#1,W^SIP_Q_RETADR+4,R2	; FIRST ADDRESS OF NEXT PAGE TO
					; BE EXPANDED INTO.  1 IF NO
					; RTRV PTR BUFFER ALLOCATED YET.
	$EXPREG_S -
		REGION=#0 -		; GET THE NEXT PAGE IN P0 SPACE
		PAGCNT=#1 -		; 1 PAGE
		RETADR=W^SIP_Q_RETADR	; RETURN ADDRESS RANGE
	MOVAL	512(R6),R6		; FILE ATTRIBUTES BUFFER IS NOW 
					; 1 PAGE BIGGER (ASSUMING IT WAS
					; ALLOCATED ADJACENT TO THE CURRENT BUF)
	
	CMPL	W^SIP_Q_RETADR,R2	; DID WE ALLOCATE THE ADJACENT PAGE?
	BEQL	36$			; BRANCH IF YES
	MOVL	W^SIP_Q_RETADR,R7	; SET NEW STARTING ADDRESS
	MOVZWL	#512,R6			; AND SIZE FOR FILE ATTRIBUTES BUFFER
36$:	SUBL3	#RTRVPTRS,R6,W^SIP_Q_RTRVBUF ; SET UP SIZE AND ADDRESS
	ADDL3	#RTRVPTRS,R7,W^SIP_Q_RTRVBUF+4 ; OF RTRV PTR BUFFER
	$DASSGN_S W^SIP_L_DSKCHAN	; FIL$OPENFILE ASSIGN CHANNEL EACH CALL
					; LEAVE IT ASSIGNED AFTER LAST CALL
	CALLG	W^SIP_A_OPENARG,FIL$OPENFILE ; GET RETRIEVAL POINTERS
					; FOR SPECIFIED FILE
	BLBS	R0,40$			; BRANCH IF SUCCESSFUL
	CMPW	R0,#SS$_NOSUCHFILE
	BEQL	38$			; IGNORE NO SUCH FILE
	MOVAL	W^FILOPNERR,R1
	BSBW	SIP_SYSMSG		; DISPLAY ERROR
38$:	MNEGL	#1,FILELBN(R7)		; SET IMPOSSIBLE STARTING LBN
	CLRL	FILESIZE(R7)		; SET SIZE=0
	CLRL	RTRVLEN(R7)		; NO RETRIEVAL POINTERS
	MOVL	#RTRVPTRS,R0		; NO. OF BYTE USED FOR ATTRIBUTES
	BRB	44$
;
; SUCCESS RETURN FROM FIL$OPENFILE
;
40$:	MOVQ	W^SIP_Q_STATBLK,STATBLK(R7) ; STORE STATISTICS BLOCK
	MOVL	W^SIP_L_RTRVLEN,RTRVLEN(R7) ; AND RTRV PTR BYTE COUNT
	ADDL3	#RTRVPTRS,RTRVLEN(R7),R0 ; FORM BYTE COUNT USED IF ALL
					; THE RETRIEVAL POINTERS FIT IN
					; THE SPECIFIED BUFFER SPACE.
	CMPL	R0,R6			; WAS THERE ENOUGH SPACE?
	BLEQ	44$			; BRANCH IF NOT, GET MORE SPACE
	BRW	34$			; AND TRY THE FIL$OPENFILE AGAIN
;
; R0 = THE NUMBER OF BYTE USED FOR THE FILE ATTRIBUTES FOR THIS FILE
;
44$:	MOVL	#1,IMAGEVBN(R7)		; INIT IMAGE ATTRIBUTES
	MOVL	FILESIZE(R7),IMAGESIZE(R7) ; AS IF NOT AN IMAGE FILE
	MOVL	R7,(R8)+		; STORE THE POINTER TO THE
					; ATTRIBUTES FOR THIS FILE
	ADDL	R0,R7			; UPDATE BUFFER ADDRESS
	SUBL	R0,R6			; AND SIZE
	BRW	30$			; GO PROCESS THE NEXT FILE

50$:	MOVL	W^SIP_L_RMSATT,R7	; RMS FILE ATTRIBUTES
	MOVZWL	W^SIP_L_DSKCHAN,R0	; CHANNEL TO READ FROM
	MOVL	RTRVPTRS+4(R7),R1	; LBN OF FIRST BLOCK OF FILE
	MOVL	#IO$_READLBLK,R3	; FUNCTION CODE
	MOVL	IMAGESIZE(R7),R2	; ACTUAL LAST VBN IN FILE
	BSBW	SIP_IMAGE_ATT		; GET IMAGE ATTRIBUTES
	BLBC	R0,52$			; BRANCH IF ERROR
	ADDL3	#1,R1,IMAGEVBN(R7)	; SAVE STARTING VBN OF IMAGE
	SUBL3	R1,R2,IMAGESIZE(R7)	; SAVE BLOCKS OF IMAGE TO MAP
52$:	$CMKRNL_S	W^SIP_KERNELRTN	; EXECUTE THIS AT KERNEL ACCESS MODE
	$CMEXEC_S	SIP_XQP_MERGE
	BLBS	R0,60$
	MOVAB	W^XQPERR,R1
	BSBW	SIP_SYSMSG
60$:	MOVZWL	W^SIP_L_DSKCHAN,-(SP)	; GET CHANNEL ASSIGNED TO SYSTEM DISK
	PUSHL	#1			; BUILD ARG LIST
	PUSHL	SP			; FOR $CMEXEC CALL
	PUSHAB	MOUNT_SYSTEM		; SYSTEM DISK MOUNT ROUTINE
	CALLS	#4,G^SYS$CMEXEC		; GO MOUNT SYSTEM DISK
	BLBS	R0,65$			; BR IF MOUNT WENT OK
	MOVAB	W^MOUERR,R1		; SET ERROR MESSAGE
	BSBW	SIP_SYSMSG		; OUTPUT SYSTEM MESSAGE
65$:
;
; STORE THE SYSTEM TIME AND THE SYSGEN PARAMETERS IN THE SYSTEM IMAGE
; ON THE SYSTEM DISK.  THIS IS DONE AFTER THE SYSTEM DISK IS MOUNTED IN
; ORDER TO AVOID WRITING TO THE DISK PRIOR TO MOUNTING IT.
;
	$SETIME_S			; UPDATE TIME AND SYSGEN PARAMETERS
;
; DEALLOCATE THE FIL$OPENFILE CACHE, WE NOW HAVE THE FILE SYSTEM UP
;
	$CMKRNL_S W^SIP_CACHE_DALC	; DONE WITH FIL$OPENFILE CACHE
;
; IF THERE IS A TOP LEVEL SYSTEM DIRECTORY, ASK THE FILES ACP FOR ITS
; REAL NAME SO THAT THIS NAME WILL APPEAR IN THE SYSTEM WIDE LOGICAL
; NAMES RATHER THAN "SYSX".
;
SIP_GET_TOPSYS:
	MOVAB	FIL$GT_TOPSYS,R1	; TOP LEVEL SYSTEM DIRECTORY STRING
	MOVZBL	(R1)+,R6		; SIZE OF STRING IF PRESENT
	BNEQ	5$			; BRANCH IF NO TOP LEVEL DIR
	BRW	20$

5$:	MOVAB	W^SIP_A_ERLBUFFER,R8	; FORM ADDRESSES FOR 2
	MOVAB	ATR$S_ASCNAME(R8),R7	; FILE NAME SCRATCH BUFFERS
	MOVC3	R6,(R1),(R7)		; FORM NAME OF DIRECTORY TO LOOK UP
	MOVL	#^A/.DIR/,(R3)+		; TACK ON THE FILE TYPE
	MOVW	#^A/;1/,(R3)+		; AND VERSION NUMBER
	PUSHAB	(R7)			; FORM DESCRIPTOR FOR DIR NAME
	PUSHAB	6(R6)			; SIZE OF NAME + 6 CHARS
	MOVL	SP,R0			; ADDRESS OF NAME DESCRIPTOR
	$QIOW_S -
		CHAN=W^SIP_L_DSKCHAN -	; CHANNEL
		FUNC=#IO$_ACCESS -	; FUNCTION CODE = ACCESS
		EFN=#1 -		; EVENT FLAG TO WAIT FOR
		IOSB=W^SIP_Q_STATBLK -	; I/O STATUS BLOCK
		P1=W^SIP_Q_FIBDESC -	; FILE ID BLOCK DESCRIPTOR
		P2=R0 -			; FILE NAME DESCRIPTOR TO LOOK UP
		P5=#SIP_A_ATRLIST	; ATTRIBUTE LIST ADDRESS
	ADDL	#8,SP			; CLEAN OFF NAME DESCRIPTOR
	BLBC	R0,10$			; BRANCH IF I/O DID NOT GET QUEUED
	BLBC	W^SIP_Q_STATBLK,10$	; BRANCH IF I/O FAILED
	LOCC	#^A/./,#ATR$S_ASCNAME,(R8) ; FIND THE END OF THE DIR NAME
	BEQL	10$			; BRANCH IF NO NAME RETURNED
	SUBL3	R8,R1,R6		; GET SIZE OF NAME
	MOVL	R8,R7			; AND ADDRESS
10$:	MOVW	R6,SYS_TOPSYS_DIRNAM_LEN; SET SIZE OF EQUIVALENCE NAME
	MOVL	R7,SYS_TOPSYS_DIRNAM	; SET ADDRESS OF EQUIVALENCE NAME
	$CRELNM_S -			; CREATE LOGICAL NAME FOR SYS$TOPSYS
		ITMLST = W^SYS_TOPSYS_ITMLST,-
		LOGNAM = W^SYS_TOPSYS_DESC,-
		TABNAM = W^LNM_SYSTEM_DESC

;
; OPEN AND CREATE GLOBAL SECTIONS FOR THE XQP
;

20$:	$OPEN	FAB = W^XQPFAB		; OPEN IT
	BLBC	R0,40$			; ERROR OPENING FILE
	$QIOW_S CHAN = XQPFAB+FAB$L_STV,- ; READ IMAGE HEADER
		FUNC = #IO$_READVBLK,-
		IOSB = W^SIP_Q_STATBLK,-
		P1   = W^SIP_A_ERLBUFFER,-
		P2   = #512,-
		P3   = #1
	BLBC	R0,40$			; ERROR READING FILE
	MOVZWL	W^SIP_Q_STATBLK,R0
	BLBC	R0,40$
	$CMKRNL_S W^SIP_MAPXQP		; GO MAP XQP IN KERNEL MODE
	BLBS	R0,50$
40$:	MOVAB	W^XQPERR,R1
	BSBW	SIP_SYSMSG
50$:
;
; NOW OPEN AND MAP THE SYSTEM WIDE MESSAGE FILE (SYS$MESSAGE:SYSMSG.EXE)
;
	$OPEN	FAB=W^MSGFILFAB		; OPEN THE FILE
	BLBC	R0,74$			; BRANCH IF ERROR
	MOVZWL	W^MSGFILFAB+FAB$L_STV,R0 ; CHANNEL TO READ FROM
	MOVL	#1,R1			; READ VIRTUAL BLOCK 1
	MOVL	#IO$_READVBLK,R3	; FUNCTION CODE
	MOVL	MSGFILXAB+XAB$L_EBK,R2	; END OF FILE BLOCK NUMBER
	TSTW	MSGFILXAB+XAB$W_FFB	; UNLESS FIRST FREE BYTE = 0
	BNEQ	72$
	DECL	R2			; IN WHICH CASE IT IS ONE TOO BIG
72$:	BSBW	SIP_IMAGE_ATT		; GET IMAGE ATTRIBUTES
	BLBC	R0,74$			; BRANCH IF ERROR
	SUBL	R1,R2			; NUMBER OF BLOCKS TO ACTUALLY MAP
	BLEQ	74$			; BRANCH IF NOTHING TO MAP
;
; MAP THE MESSAGE FILE AS A SYSTEM SECTION
;
	PUSHAL	EXE$GL_SYSMSG		; LOCATION TO STORE SYSTEM 
					; ADDRESS AT WHICH SYSMSG IS MAPPED
	PUSHL	#PRT$C_UR		; PROTECTION FOR PAGES
	PUSHL	R2			; PAGE COUNT TO MAP
	ADDL3	#1,R1,-(SP)		; STARTING VBN TO MAP
	MOVZWL	MSGFILFAB+FAB$L_STV,-(SP) ; CHANNEL ON WHICH SYSMSG IS OPEN
	PUSHL	#5			; NO. OF ARGUMENTS IN THE ARG LIST
	MOVL	SP,R0			; ADDRESS OF ARGUMENT LIST
	$CMKRNL_S W^EXE$SYS_SECTION,(R0)	; MAP THE SECTION
	ADDL	#<6*4>,SP		; CLEAN OFF ARGUMENT LIST
	BLBS	R0,90$			; BRANCH IF SUCCESSFUL
74$:	MOVAB	W^MSGFILERR,R1		; "FAILED TO OPEN OR MAP SYSMSG.EXE"
	BSBW	SIP_SYSMSG		; ISSUE A WARNING DIAGNOSTICE
90$:					;
	MOVZBL	EXE$GT_STARTUP,W^SIP_Q_SPINPUT	; SET CORRECT COUNT IN DESCR
	MOVAB	W^SIP_Q_SPOUTPUT,R0	; STARTUP PROCESS OUTPUT
	CMPL	#XDT$START,#0		; DEBUGGING WITH DELTA?
	BEQL	95$			; BRANCH IF NOT
	MOVAB	W^SIP_Q_SPOUTXDT,R0	; USE DIFFERENT OUTPUT FOR DELTA
95$:	$CREPRC_S	INPUT=W^SIP_Q_SPINPUT,-	; INPUT FROM STARTUP FILE
			OUTPUT=(R0),-	; OUTPUT TO CONSOLE TERMINAL
			ERROR=(R0),-	; ERRORS ALSO
			BASPRI=#4,-	; BASE PRIORITY
			IMAGE=W^SIP_Q_SPIMAGE,-	; RUN LOGIN IMAGE
			UIC=#^X10004,-		; RUN IN UIC [1,4]
			STSFLG=#<1@6>,-		; FLAG FOR AUTO LOGIN
			PRVADR=W^SIP_Q_PRVMSK,-	; ALL PRIVILEGES
			QUOTA=PQL$AB_SYSPQL,-	; QUOTA LIST
			PRCNAM=W^SIP_Q_STARTUP	; NAME IS STARTUP
	BLBS	R0,100$			; BR IF SUCCESS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAQ	W^SIP_Q_STARTUP,R0	; GET PROCESS NAME DESCRIPTOR
	MOVC5	(R0),@4(R0),#0,#15,W^CREPRCNAM ; COPY NAME INTO MESSAGE
	MOVAB	W^CREPRCERR,R1		; SET ADDR OF MESSAGE
	MOVL	(SP),R0			; SET FAILURE STATUS VALUE
	BSBW	SIP_SYSMSG		; PRINT THE MESSAGE
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	$GETMSG_S R0,SIP_Q_TMPDESC,SIP_Q_LINBUF ; GET STATUS MESSAGE
	MOVZWL	SIP_Q_TMPDESC,R0	; GET SIZE OF MESSAGE
	MOVAB	SIP_T_LINBUF,R1		; GET ADDR OF MESSAGE
	BSBW	SIP_TYPOUT		; TYPE IT ON CONSOLE
100$:
	RET				; THATS ALL FOR NOW

	.SUBTITLE	SIP_GET_SYSID_LOCK - Obtain Lock for System ID
;+
; Functional Description:
;
;	This routine obtains a system-owned lock whose name contains the
;	system ID. If this system is to join a cluster, a test will be made
;	for a unique system ID when this system's lock data base is merged
;	into the cluster-wide data base. The lock is system wide because the
;	various sublocks that will use this as a parent are locking system
;	wide data structures.
;
;	If $ENQW returns an error, a message will be issued and the SYSINIT
;	image will go away, preventing further system initialization
;
;	Locking is enabled before this lock is requested and sub-locks are
;	enabled after the lock is granted.
;
; Calling Sequence:
;
;	CALLS	#0, SIP_GET_SYSID_LOCK 
;
; Environment:
;
;	This routine must execute in kernel mode
;
; Input Parameters:
;
;	none
;
; Output Parameters:
;
;	none
;
; Implicit Output:
;
;	If the lock request is successful, the lock ID is stored in the
;	exec cell called EXE$GL_SYSID_LOCK for use as a parent ID by other
;	lock requests.
;
;	If the lock request fails, the image exits (and initialization
;	terminates) after an error message is typed.
;-

SIP_GET_SYSID_LOCK:
	.WORD	0				; Save no registers

; Enable locking

	CLRB	G^LCK$GB_STALLREQS

; Take out an exclusive lock with the system ID as the lock name

	MOVL	G^SCS$GB_SYSTEMID, SYS_ID	; Move first four bytes of ID
	MOVW	G^SCS$GB_SYSTEMIDH, SYS_ID + 4	;  and the last two bytes, too

	$ENQW_S		EFN = #32,-
			LKMODE = #LCK$K_EXMODE,-	
			LKSB = LOCK_STATUS_BLOCK,-
			FLAGS = #LOCK_FLAGS,-
			RESNAM = LOCK_NAME_DESC,-
			ACMODE = #PSL$C_EXEC

	BLBC	R0, ERROR			; Abort image if an error occurs

; Store the lock ID where other folks can find it and return success

	MOVL	LOCK_ID, G^EXE$GL_SYSID_LOCK	; Store the lock ID

; Enable sub-locking, but not creation of additional roots

	MOVB	#2,G^LCK$GB_STALLREQS

	MOVZWL	S^#SS$_NORMAL,R0		; Indicate success
	RET					;  and return

ERROR:
	MOVAB	SYSID_LOCK_ERR, R1		; Store error message address
	BRW	SIP_FATAL			; This is the death step

	.SUBTITLE	SIP_CLUSTER_INIT - Cluster related initialization
;+
; Functional Description:
;
;	This routine performs cluster related initializations.
;
;	If the node is not even going to participate in a cluster, locking
;	is enabled and the routine returns.
;
;	If the node will participate in a cluster:
;
;	1.  The stand-alone configure process is created.  The purpose of
;	    this process is to configure communications drivers supporting
;	    SCS and the disk driver supporting the disk potentially
;	    containing the quorum file.
;
;	2.  A bit is set triggering cluster formation/joining.
;
;	3.  Wait for a cluster to be joined or formed.  It is assumed that
;	    locking is enabled as a side effect of joining or forming the
;	    cluster.
;
;	4.  Time is updated to set a consistent, cluster-wide time.
;			
;
; Calling Sequence:
;
;	CALLS	#0, SIP_CLUSTER_INIT
;
; Environment:
;
;	This routine must execute in kernel mode
;
; Input Parameters:
;
;	none
;
; Output Parameters:
;
;	none
;
; Implicit Output:
;
;-

SIP_CLUSTER_INIT:
	.WORD	^M<R2,R3,R4,R5>

	IFCLSTR	2$				; Branch if cluster system
;
; This system will never participate in a cluster; enable unrestricted locking
;
	CLRB	G^LCK$GB_STALLREQS
	BRW	30$

; Create the stand-alone configure process
;
2$:	$CREPRC_S	IMAGE = W^STAC_IMAGE,-
			INPUT = W^STAC_OPER,-
			OUTPUT = W^STAC_OPER,-
			ERROR = W^STAC_OPER,-
			PRVADR = W^STAC_PRV_MSK,-
			QUOTA = W^STAC_QLIST,-
			PRCNAM = W^STAC_PRC,-
			BASPRI = #8,-
			UIC = #^x10004
	BLBS	R0,3$				; Branch on success
	BRW	100$				; Can't create process
3$:

; Tell the connection manager to proceed with cluster formation/creation
;
	MOVL	G^CLU$GL_CLUB,R0		; Address of CLUster Block
	BISL2	#CLUB$M_INIT,CLUB$L_FLAGS(R0)	; Set initialization flag

; Output message indicating that we are waiting to join/form a cluster
;
	MOVAB	W^SIP_CLU_MSG,R1		; Address of counted string
	MOVZBL	(R1)+,R0			; Character count
	BSBW	SIP_TYPOUT

; Loop waiting for node to join cluster
;
10$:	$SETIMR_S	EFN=#0,DAYTIM=W^SIP_CLU_TIMOUT
	BLBC	R0,15$				; Branch on error
	$WAITFR_S	EFN=#0			; Wait for time-out
15$:	BSBW	SIP_LOOKUP_QFILE		; Perform quorum file lookup
	MOVL	G^CLU$GL_CLUB,R0		; Address of CLUster Block
	BBC	#CLUB$V_CLUSTER, -		; Loop until node is a
		CLUB$L_FLAGS(R0),10$		;   cluster member
						; If it was not already, start
	BSBW	SIP_START_QUORUM_TIMER		; ...the quorum disk timer	
;
; When the cluster if formed or joined, the locking will be enabled --
; i.e., it is enabled when we reach this point.  Take out a lock on the
; system disk.
;
	MOVL	G^CTL$GL_PCB,R4			; PCB address
	JSB	G^SCH$IOLOCKW			; Lock I/O data base for writing
	MOVL	#LCK$K_CRMODE,R0		; Signal shared lock
	CLRL	R1				; Don't return lock status block
	MOVL	G^EXE$GL_SYSUCB,R5		; System disk UCB address
	BISB2	#DEV$M_CLU, UCB$L_DEVCHAR2(R5)	; It is cluster accessible.
	JSB	G^IOC$LOCK_DEV			; Take out lock on system disk
;
; The UCB for the system disk was created with a reference count of 1 to 
; avoid having the first $ASSIGN try to take out a lock on it before locking 
; is enabled. If SYSINIT fails for any reason (e.g. failure to mount the
; system disk), this extra reference count will prevent the device lock from 
; being released in the last channel $DASSGN. Decrement the reference count 
; to avoid this scenario.
;
	DECW	UCB$W_REFC(R5)			; Decrement reference count
	PUSHL	R0				; Save LOCK_DEV status
	JSB	G^SCH$IOUNLOCK			; Unlock the I/O data base
	SETIPL	#0				; Restore IPL
	MOVL	(SP)+,R0			; Retrieve LOCK_DEV status
	BLBC	R0,90$				; Branch if LOCK_DEV failed
;
; Set internal cluster-wide system time using data that was stored in the CLUB
; when the cluster was formed/joined.
;
	MOVQ	G^EXE$GQ_SYSTIME,-(SP)		; Current system time
	MOVL	G^CLU$GL_CLUB,R0		; Address of CLUB
	SUBL2	CLUB$Q_NEWTIME_REF(R0),(SP)	; Subtract local time corresponding to
	SBWC	CLUB$Q_NEWTIME_REF+4(R0),4(SP)	;  cluster time
	ADDL2	CLUB$Q_NEWTIME(R0),(SP)		; Add cluster time corresponding to
	ADWC	CLUB$Q_NEWTIME+4(R0),4(SP)	;  reference base
	PUSHAQ	(SP)				; Address of new system time
	CALLS	#1,G^EXE$SETIME_INT		; Establish cluster-wide time internally
	ADDL2	#8,SP				; Clear stack
30$:	MOVZWL	S^#SS$_NORMAL,R0		; Indicate success
	RET					;  and return

;
; Error locking system disk - this is fatal.
;
90$:	MOVAB	W^LOCKERR,R1			; Message address
	BRW	SIP_FATAL			; No recovery possible

; Error creating stand-alone configure process
;
100$:	PUSHL	R0				; Save failure status
	MOVAQ	W^STAC_PRC,R0			; Get process name descriptor
	MOVC5	(R0),@4(R0),#0,#15,W^CREPRCNAM	; Copy name into message
	MOVAB	W^CREPRCERR,R1			; Message address
	POPR	#^M<R0>				; Failure status value
	BRW	SIP_FATAL			; This is the death step

	.SUBTITLE	SIP_LOOKUP_QFILE - Perform quorum file lookup
;+
; Functional Description:
;
;	This routine attempts to assign a channel to the quorum disk, get
;	the quorum file logical block number, and store it in the cluster
;	quorum disk control block (CLUDCB).
;
; Calling Sequence:
;
;	BSBW	SIP_LOOKUP_QFILE
;
; Environment:
;
;	This routine must execute in kernel mode
;
; Input Parameters:
;	none
;
; Output Parameters:
;	none
;-

SIP_LOOKUP_QFILE:

	MOVL	G^CLU$GL_CLUB,R4		; Get CLUB address
	MOVL	CLUB$L_CLUDCB(R4),R3		; Get CLUDCB address
	BEQLU	1$				; If zero, there is no quorum file
	TSTL	CLUDCB$L_QFLBN(R3)		; Have we already found it?
	BNEQU	1$				; Br if yes
;
; Get the full device name, store it in the CLUB, and form the full quorum
; file specification.
;
	TSTB	CLUB$T_QDNAME(R4)		; Is name already in CLUB?
	BNEQU	3$				; Br if yes
	PUSHR	#^M<R3,R4>			; Save CLUDCB and CLUB pointers
	LOCC	#^A/ /,#CLUDCB$S_DISK_QUORUM,-	; Locate end of quorum disk name
		G^CLU$GB_QDISK
	SUBW3	R0,#CLUDCB$S_DISK_QUORUM,-	; Adjust descriptor size
		W^SIP_QD_DESCR
	$GETDVIW_S	EFN = #0,-		; Get full device name
			DEVNAM = W^SIP_QD_DESCR,-
			ITMLST = W^SIP_QD_ITMLST,-
			IOSB = W^SIP_QD_IOSB
	BLBC	R0,7$				; Br if error
	MOVZWL	W^SIP_QD_IOSB,R0		; Get completion status
	BLBS	R0,2$				; Br if success
7$:	POPR	#^M<R3,R4>			; Restore registers
1$:	BRW	6$
2$:	SUBW3	#2,W^SIP_QF_DESCR,R0		; Get adjusted size
	MOVC3	R0,W^SIP_QF_BUFFER+1,-		; Put name in CLUB
		CLUB$T_QDNAME+1(R4)
	MOVQ	(SP),R3				; Restore CLUDCB and CLUB pointers
	MOVZWL	W^SIP_QF_DESCR,R0		; Get size
	SUBB3	#2,R0,CLUB$T_QDNAME(R4)		; Put adjusted size in CLUB
	ADDL3	R0,#SIP_QF_BUFFER,R0		; Get address to put file name
	ADDW	#SIP_QF_NAME_SIZE,W^SIP_QF_DESCR ; Add file name size into descr
	MOVC3	#SIP_QF_NAME_SIZE,-		; Move file name into buffer
		W^SIP_QF_NAME,(R0)
	JSB	G^CNX$DISK_CHANGE		; Tell connection manager
	POPR	#^M<R3,R4>			; Restore CLUDCB and CLUB pointers
;
; Assign a channel to the quorum disk and use the channel number to
; get the quorum disk UCB.
;
3$:	MOVAW	W^SIP_QD_CHAN,R2		; R2 is channel word pointer
	MOVL	CLUDCB$L_UCB(R3),R5		; Get the quorum disk UCB address
	BNEQU	4$				; Br if we have it
	$ASSIGN_S DEVNAM = W^SIP_QF_DESCR,-	; Assign channel to quorum disk
		  CHAN = (R2)
	BLBC	R0,6$				; Br if error
	MOVZWL	(R2),R5				; Get channel number
	SUBL3	R5,@#CTL$GL_CCBBASE,R5		; Form CCB address
	MOVL	CCB$L_UCB(R5),R5		; Get UCB address
	MOVL	R5,CLUDCB$L_UCB(R3)		; Store UCB address in CLUDCB
;
; The quorum disk may not be mounted. Check to see if the volume valid
; bit is set in the UCB.
;
4$:	BBS	#UCB$V_VALID,UCB$L_STS(R5),5$	; Br if volume is valid
;
; The volume is not valid, issue a PACKACK QIO.
;
	$QIOW_S	EFN  = #0,-			; Issue packack QIO
		CHAN = (R2),-
		FUNC = #IO$_PACKACK,-
		IOSB = W^SIP_QD_IOSB
	BLBC	R0,6$				; Br if error on qio request
	MOVZWL	W^SIP_QD_IOSB,R0		; Get I/O status
	BLBC	R0,6$				; Br if I/O error	
;
; Do the file lookup with FILEREAD.
;
5$:	PUSHL	#3				; Don't use cache or root directory
	CLRQ	-(SP)				; We don't want retrieval pointers
	PUSHAL	W^SIP_QD_STATBUF		; Address of 2 longword block to
						; return LBN of the first block
						; and the file size. (in blocks)
	PUSHAL	W^SIP_A_FILEHDR			; Address of file hdr buffer
	PUSHAL	W^SIP_A_INDEXFHDR		; Address of index file hdr buffer
	PUSHAL	W^SIP_QF_DESCR			; Address of file name descriptor
	PUSHAL	(R2)				; Address of channel number
	CALLS	#8,G^FIL$OPENFILE_1		; Open quorum file
	BLBC	R0,6$				; Br if error
;
; We have found the quorum file. Store the logical block number in the CLUDCB.
;
	MOVL	W^SIP_QD_STATBUF,-		; Store LBN in CLUDCB
		CLUDCB$L_QFLBN(R3)
	MOVW	#CLUDCB$M_QS_READY,-		; State is now READY
		CLUDCB$W_STATE(R3)
	BSBW	SIP_START_QUORUM_TIMER		; Start the quorum disk timer	
	$DASSGN_S CHAN = (R2)			; Deassign channel
6$:	RSB

	.SUBTITLE	SIP_START_QUORUM_TIMER - Start the quorum disk timer
;+
; Functional Description:
;
;	This routine starts the quorum disk timer by inserting the quorum
;	TQE in the system time queue. It first checks to see if it has
;	already been placed in the queue and if not requests an immediate
;	timeout.
;
; Calling Sequence:
;
;	BSBW	SIP_START_QUORUM_TIMER
;
; Environment:
;
;	This routine must execute in kernel mode
;
; Input Parameters:
;
;	none
;
; Output Parameters:
;
;	none
;-

SIP_START_QUORUM_TIMER:
	MOVL	G^CLU$GL_CLUB,R5		; Get CLUB address
	MOVL	CLUB$L_CLUDCB(R5),R5		; Get CLUDCB address
	BEQLU	1$				; If zero, there is no quorum file
	MOVL	CLUDCB$L_TQE(R5),R5		; Get TQE
	TSTL	TQE$L_TQFL(R5)			; Is it in queue already?
	BNEQU	1$				; Br if yes
	MOVQ	G^EXE$GQ_SYSTIME,R0		; Request an immediate timeout
	JSB	G^EXE$INSTIMQ			; Insert in queue
1$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	Merge the XQP into this process.
;
; INPUT PARAMETERS:
;
;	None
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
;--
SIP_XQP_MERGE:
	.WORD 0
	$IMGACT_S NAME = XQP_NAME,-
		  DFLNAM = XQP_DEF,-
		  INADR = XQP_INADDR,-
		  IMGCTL = #IAC$M_MERGE+IAC$M_EXPREG,-
		  RETADR = XQP_RETADDR,-
		  HDRBUF = XQP_HEADER
	BLBC	R0,10$
	$IMGFIX_S
	BLBC	R0,10$
	JMP	@XQP_RETADDR
10$:	RET

	.SBTTL	SIP_MAPXQP - Create global sections for XQP
;++
; FUNCTIONAL DESCRIPTION:
;
;	Create the global sections needed to map the XQP into processes
;	The SYSGEN parameter controls whether or not they are resident sections.
;
; INPUT PARAMETERS:
;
;	XQP IMAGE HEADER
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
;--

SIP_MAPXQP:
	.WORD	^M<R2,R3,R4,R5>
	MOVZWL	W^SIP_A_ERLBUFFER+IHD$W_SIZE,R2 ; OFFSET IN IMAGE HEADER TO ISD
	ADDL	#SIP_A_ERLBUFFER,R2	; ADDRESS OF FIRST ISD
10$:	TSTW	ISD$W_SIZE(R2)		; ARE WE DONE
	BEQL	25$			; YES
	BLSS	20$			; ERROR - THERE CAN'T BE THIS MANY ISD'S
	TSTL	XQP$GL_DZRO		; HAVE WE ALREADY SEEN DZRO
	BNEQ	20$			; YES - IT WAS SUP[POSED TO BE LAST
	BITL	#ISD$M_DZRO ! ISD$M_VECTOR ! ISD$M_GBL ! ISD$M_FIXUPVEC -
		,ISD$L_FLAGS(R2)
	BNEQ	20$			; ILLEGAL ISD TYPES
	MOVZWL	ISD$W_PAGCNT(R2),R5	; PAGES IN THIS SECTION
	BBC	#ISD$V_CRF,ISD$L_FLAGS(R2),30$ ; A NORMAL SECTION
	MOVL	R5,XQP$GL_DZRO		; REMEMBER HOW BIG DZRO IS
	BRB	50$			; NEXT
;
20$:	MOVL	#SS$_BADIMGHDR,R0
25$:	RET
;
30$:	MOVL	#<SEC$M_GBL!SEC$M_PERM!SEC$M_SYSGBL>,R0 ; DEFAULT CHARACTERISTICS
	BBC	#EXE$V_XQP_RESIDENT,EXE$GL_STATIC_FLAGS,40$ ;CHECK SYSGEN PARAMETER
	BBSS	#SEC$V_RESIDENT,R0,40$	; REQUEST A RESIDENT SECTION
40$:	$CRMPSC_S -			; MAP A GLOBAL SECTION
		FLAGS  = R0,-
		GSDNAM = XQP_GSD_DESC,-
		VBN    = ISD$L_VBN(R2),-
		CHAN   = XQPFAB+FAB$L_STV,-
		ACMODE = #PSL$C_EXEC,-
		PAGCNT = R5
	BLBC	R0,25$
	INCL	XQP$GL_SECTIONS		; COUNT THIS SECTION
	CMPB	XQP$GL_SECTIONS,#32
	BEQL	20$			; TOO MANY ISD'S
	INCB	XQP_GSDNAM+XQP_GSDNAM_SIZ-1 ; NEXT GLOBAL SECTION NAME
;
50$:	MOVZWL	ISD$W_SIZE(R2),R3
	ADDL	R3,R2
	BRW	10$			; NEXT ISD

	.SBTTL	SIP_IMAGE_ATT - Read header, get image attributes
;++
; FUNCTIONAL DESCRIPTION:
;
;	READ THE IMAGE HEADER OF AN IMAGE AND RETURN THE COUNT OF
;	IMAGE HEADER BLOCKS AND THE HIGHEST VBN THAT IS PART OF THE
;	IMAGE, I.E. EXCLUDING SYMBOL TABLE AND PATCH STUFF.
;
; INPUT PARAMETERS:
;
;	R0 = CHANNEL TO READ FROM
;	R1 = DISK ADDRESS TO READ (LBN OR VBN)
;	R2 = LAST VBN IN FILE
;	R3 = FUNCTION CODE (READ LOGICAL OR READ VIRTUAL)
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R1 = HEADER BLOCK COUNT
;	R2 = LAST VIRTUAL BLOCK NUMBER IN IMAGE
;	     EXCLUDING DEBUG SYMBOL TABLE AND PATCH AUDIT TRAIL TEXT.
;	R3 = IMAGE HEADER ADDRESS
;
;--

SIP_IMAGE_ATT:
	$QIOW_S	-			; READ THE IMAGE HEADER
		EFN  = #1 -		; EVENT FLAG
		CHAN = R0 -		; CHANNEL TO READ ON
		FUNC = R3 -		; READ VIRTUAL OR LOGICAL
		IOSB = W^SIP_Q_STATBLK - ; I/O STATUS BLOCK ADDRESS
		P1   = W^SIP_A_ERLBUFFER - ; BUFFER TO READ INTO
		P2   = #512 -		; NUMBER OF BYTES TO READ
		P3   = R1		; DISK BLOCK TO READ
	BLBC	R0,100$			; BRANCH IF ERROR
	MOVZWL	W^SIP_Q_STATBLK,R0	; GET I/O STATUS
	BLBC	R0,100$			; BRANCH IF ERROR
	MOVAL	W^SIP_A_ERLBUFFER,R3	; HEADER BUFFER ADDRESS
	BSBW	BOO$IMAGE_ATT		; GET IMAGE ATTRIBUTES
	MOVL	S^#SS$_NORMAL,R0
100$:	RSB
	.PAGE

	.SBTTL	BOO$IMAGE_ATT - Get image attributes from image header
;++
; Functional Description:
;
;	BOO$IMAGE_ATT returns to the caller some attributes of the image
;
; Calling Sequence:
;
;	BSBW	BOO$IMAGE_ATT
;
; Inputs:
;
;	R2 = Size of file in blocks
;	R3 = Address of image header block (first one only)
;
; Outputs:
;
;	R1 = Number of image header blocks at the front of the image
;	R2 = Size of image in blocks excluding the blocks at the end
;	     containing local symbols, global symbols, or patch text
;
;--

BOO$IMAGE_ATT::
	MOVZWL	IHD$W_SYMDBGOFF(R3),R0	; ANY SYMBOL TABLE INFORMATION?
	BEQL	20$			; BRANCH IF NOT
	MOVAB	IHS$L_DSTVBN(R0)[R3],R1	; ADR OF 1ST VBN IN DEBUG SYMBOL TABLE
	BSBB	40$			; PROCESS IT
	MOVAB	IHS$L_GSTVBN(R0)[R3],R1	; ADR OF 1ST VBN IN GLOBAL SYMBOL TABLE
	BSBB	40$			; PROCESS IT
20$:	MOVZWL	IHD$W_PATCHOFF(R3),R0	; ANY PATCH CONTROL INFORMATION?
	BEQL	30$			; BRANCH IF NOT
	MOVAB	IHP$L_PATCOMTXT(R0)[R3],R1 ; ADR OF 1ST VBN OF PATCH COMMAND TEXT
	BSBB	40$			; PROCESS IT
30$:	MOVZBL	IHD$B_HDRBLKCNT(R3),R1	; GET IMAGE HEADER BLOCK COUNT
	RSB
;
; SEE IF VBN IS NON ZERO AND THEN IF IT IS SMALLER THAN THE CURRENT SMALLEST
;
40$:	SUBL3	#1,(R1),R1		; FETCH VBN - 1
	BLSS	50$			; BRANCH IF NO VBN IS PRESENT
	CMPL	R2,R1			; IS IT SMALLER THAN THE CURRENT ONE
	BLEQ	50$			; BRANCH IF NOT
	MOVL	R1,R2			; YES, USE IT
50$:	RSB
	.PAGE

	.SBTTL	SYSTEM INITIALIZATION KERNEL LEVEL
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PERFORM SYSTEM INITIALIZATION
;	FUNCTIONS WHICH REQUIRE KERNEL LEVEL ACCESS.
;	THE FOLLOWING ARE PERFORMED:
;
;		1) SET UP THE KNOWN FILE DATA BASE
;		2) INIT THE PAGING FILE
;		3) INIT THE SWAP FILE
;		4) MAP RMS INTO SYSTEM SPACE
;		6) RECOVER UNLOGGED ERROR LOG ENTRIES FROM CRASH DUMP
;		   AND MAKE SURE THEY ARE PROPERLY LOGGED.
;
; CALLING SEQUENCE:
;
;	ENTER VIA THE CHANGE MODE TO SYSTEM SERVICE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LOCATION "SIP_A_FILATT" CONTAINS A LIST OF ADDRESSES OF
;	FILE ATTRIBUTES BUFFERS FOR:
;		1) PAGE FILE
;		2) SWAP FILE
;		3) RMS
;
;	THE FORMAT OF THE ATTRIBUTES BUFFERS IS:
;		.LONG	STARTING LBN IF CONTIGUOUS, 0 IF NOT, -1 IF NO SUCH FILE
;		.LONG	SIZE OF FILE IN 512 BYTE BLOCKS
;		.LONG	FIRST VBN IF IMAGE FORMAT
;		.LONG	SIZE IF IMAGE FORMAT
;		.LONG	BYTE COUNT OF RETRIEVAL POINTERS THAT FOLLOW
;		.LONG	BLOCK COUNT FOR RTRV PTR 1
;		.LONG	LBN FOR RTRV PTR 1
;		...
;		...
;		...
;		.LONG	BLOCK COUNT FOR RTRV PTR N
;		.LONG	LBN FOR RTRV PTR N
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 IS RETURNED TRUE OF FALSE DEPENDING ON
;	INITIALIZATION SUCESS OR FAILURE
;
; SIDE EFFECTS:
;
SIP_KERNELRTN:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; ENTRY MASK
	MOVL	@#MMG$GL_GPTE,R3	; GET BASE ADDRESS OF GPTE
	ASHL	#2,@#SGN$GL_MAXGPGCT,4(R3); SET THE GLOBAL PAGE TABLE ENTRY 
					; MAX CNT
	MOVL	EXE$GL_SYSUCB,R0	; PICK UP ADDRESS OF SYSTEM UCB
	BICL	#<DEV$M_FOR!DEV$M_MNT>,-; CLEAR FOREIGN AND MOUNTED FORM INIT IN
		UCB$L_DEVCHAR(R0)	; SYSTEM DISK UCB CHARACTERISTICS WORD
	MOVL	SCH$GL_CURPCB,R1	; GET CURRENT PROCESS PCB ADDRESS
	MOVL	PCB$L_PID(R1),UCB$L_PID(R0) ; ALLOCATE SYSTEM DEVICE
	.PAGE	

	.SUBTITLE	SIP_INITPAGFIL		Initialize PAGEFILE.SYS
;
;  Now initialize PAGEFILE.SYS if it exists
;

;
; The following register conventions are used in INITPAGFIL
;
;	R5 = Address of the first block of the dump header
;	R6 = Address of the Boot Control Block
;	R7 = Number of blocks of page file to permanently reserve for
;	     a dump file header.  0 if dump file is not in the page file
;	     4 if the dump file is in the page file.
;	R8 = Number of blocks of page file to initially mark "in use"
;	     because the dump is in the page file and is supposed to
;	     be analyzed before the pages are released to the page file.
;	R9 = Contents of SIP_L_PAGATT, 0 if page file contains the dump.
;	     The page file attributes block address if not.
;
SIP_INITPAGFIL:
;
; Since the dump file may be at the front of the page file,
; we will read the 3 header blocks of the dump file and
; process some information now.  Later the "restore error log"
; code will not have to read or update the dump.  It will only
; have to process and save the error log entries if any.
;
	CLRQ	R7			; Init for separate dump and page files
	MOVL	W^SIP_L_PAGATT,R9	; Page file attribute block address
	BNEQ	5$			; Branch if separate page and dump files
	MOVL	#4,R7			; Dump is in page file
					; never page to first 4 blocks
5$:	MOVL	EXE$GL_BOOTCB,R6	; Address of Boot Control Block
	MOVAB	W^SIP_A_ERLBUFFER,R5	; Buffer to read into
	PUSHL	W^SIP_L_DSKCHAN		; Channel to read disk
	PUSHL	#IO$_READLBLK		; Read function
	ROTL	#9,#3,-(SP)		; Assume reading 3 pages
	CMPL	BOO$L_DMP_SIZE(R6),#3	; Is dump file at least that big?
	BGEQ	10$			; Branch if yes
	CLRL	(SP)			; No blocks to be read
10$:	PUSHAB	(R5)			;
	PUSHL	BOO$L_DMP_MAP(R6)	; Virtual to logical map for dump file
	PUSHL	BOO$L_DMP_VBN(R6)	; Starting VBN of dump file
	PUSHL	#6			; 6 arguments to RWVB
;
; At this point there is an argument list at the top of the stack 
; for the call to QIO_RWVB.  This argument list is kept until
; exiting this "paragraph" when a write of the first block of the
; dump header may be needed.
;
	CLRL	W^SIP_L_ERRSEQ		; Zero saved sequence number
	TSTL	16(SP)			; Any blocks to read?
	BEQL	60$			; Branch if not
	CALLG	(SP),W^QIO_RWVB		; Issue QIO Read Virtual Block
	CLRL	16(SP)			; Init for no write of page
	BLBC	R0,60$			; Skip if error reading file
	CMPW	DMP$W_DUMPVER(R5),#SIP_C_DUMPVER ; Must be known dump version
	BNEQ	60$			; Branch if earlier system or garbage
	MCOML	DMP$L_SYSVER(R5),R0	; Get complement of system version
	CMPL	R0,DMP$L_CHECK(R5)	; Does check match?
	BNEQ	60$			; Branch if earlier system or garbage
;
; The dump file header looks OK, indicate that we can save error log
; entries if any are present.
;
	MOVL	DMP$L_ERRSEQ(R5),W^SIP_L_ERRSEQ ; Save sequence number
	BEQL	20$			; Branch if already zero on disk
	CLRL	DMP$L_ERRSEQ(R5)	; Save these ERL entries only once
	ROTL	#9,#1,16(SP)		; Indicate that block is to be written
;
; See if the dump is in the page file and if it should be preserved
;
20$:	TSTL	R9			; Separate dump and page files?
	BNEQ	65$			; Branch if yes
	BBC	S^#EXE$V_SAVEDUMP,EXE$GL_FLAGS,50$ ; Branch if not
					; supposed to preserve the dump
	BBS	#DMP$V_OLDDUMP,DMP$W_FLAGS(R5),50$ ; Don't preserve dump
					; if already analyzed once.
	BICL3	#7,DMP$L_CRASHERL+EMB$K_LENGTH+EMB$L_CR_CODE(R5),R0
					; Fetch crash code, zero severity
	CMPL	R0,#BUG$_OPERATOR	; "Operator Requested Shutdown?"
	BEQL	50$			; Branch if yes, don't preserve
;
; Loop through the memory descriptors and calculate the number of pages
; of dump to preserve.
;
	ASSUME	DMP$C_NMEMDSC EQ RPB$C_NMEMDSC
	MOVZBL	#DMP$C_NMEMDSC,R1	; Max # of memory descriptors
	MOVAB	DMP$L_MEMDSC(R5),R2	; Get adr of memory descriptors
30$:	EXTZV	#DMP$V_PAGCNT,#DMP$S_PAGCNT,(R2),R0 ; Get page cnt for this mem
	BEQL	40$			; BR if no more memory descriptors used
	ADDL2	R0,R8			; Accumulate total # of pages
	ASSUME	DMP$C_MEMDSCSIZ EQ RPB$C_MEMDSCSIZ
	ADDL2	#DMP$C_MEMDSCSIZ,R2	; Get next memory descriptor
	SOBGTR	R1,30$			; Loop once for each memory descriptor
40$:	TSTL	R8			; Any dump blocks to preserve?
	BGTR	60$			; Branch if yes
50$:	ROTL	#9,#1,16(SP)		; Note that we must write the block
	BBSS	#DMP$V_EMPTY,DMP$W_FLAGS(R5),60$ ; Mark dump empty for SDA
					; so it will not try to analyze
					; a (partially) overwritten dump
60$:	TSTL	R9			; Address of page file attributes buffer
	BNEQ	65$			; Branch if SYSINIT looked up page file
;
; Dump file is in page file.  SYSBOOT "opened" PAGEFILE.SYS and called
; it the dump file.  So the retrieval information and the file size
; are in the boot control block fields for the dump file.
;
	MOVL	BOO$L_DMP_MAP(R6),R2	; Address of page file mapping data
	MOVL	BOO$L_DMP_SIZE(R6),R4	; Size of page file
	BRB	70$			;
65$:	MOVAL	RTRVLEN(R9),R2		; Address of page file mapping data
	MOVL	FILESIZE(R9),R4		; Size of page file
70$:	BICL3	#7,R4,R0		; A zero length file is also useless
	SUBL	R8,R0			; Enough room left in page file
	CMPL	R0,#SIP_C_MINPAGFIL	; after reserving the dump portion
	BGEQ	80$			; Branch if yes
	TSTL	R8			; No, then don't preserve the dump
	BEQL	100$			; Branch if too small anyway
	CLRL	R8			; No dump data preserved
	BRB	50$
80$:	BSBW	SIP_INIWCB		; Allocate and init a window control block
;
; Set up argument list to BOO$INITPAGFIL on the stack. Ignore returned
; page file index. Default MAXVBN parameter. Use WCB address returned
; by SIP_INIWCB.
;
90$:	MOVQ	R7,-(SP)		; Count of blocks to mark "in use"
					; Starting VBN - 1 for page file
	CLRQ	-(SP)			; Default these two parameters
	PUSHL	R2			; Store WCB address
	PUSHL	R4			;  ... and file size
	CALLS	#6,G^BOO$INITPAGFIL	; Allocate and initialize a PFL
	BLBS	R0,120$			; Go on to next step if successful
	BSBB	CHECK_CACHE		; Can FIL$OPENFILE cache be deallocated?
	BLBS	R0,90$			; If so, try again
	MOVAB	W^INIPAGFIL,R1		; Otherwise, report an error message
	BSBW	SIP_FATAL		;  and abort the startup sequence
;
; Page file does not exist, or is too small to be useful
;
100$:	MOVAB	PAGFILERR,R1		; Display paging file error message
	BSBW	SIP_SYSMSG		; 
;
; All exits from the init page file logic must flow through here in
; order to conditionally write the first dump header block back
; and unconditionally clean the argument list off the stack.
;
120$:	MOVL	R8,EXE$GL_SAVEDUMP	; Note count of blocks reserved
	TSTL	16(SP)			; Write the dump file header?
	BEQL	140$			; Branch if not
	MOVL	#IO$_WRITELBLK,20(SP)	; Change read to write
	CALLG	(SP),W^QIO_RWVB		; Write the block
140$:	ADDL	#7*4,SP			; Clean argument list off stack
	BRB	SIP_INITSWPFIL
	.PAGE	

	.SUBTITLE	CHECK_CACHE

;+
; This routine checks whether there is a FIL$OPENFILE cache to be deallocated.
; The reason why this routine is necessary here is that the BOO$INITxxxFIL
; procedures cannot use the local nonpaged pool allocation routine. Those
; procedures are shared with SYSGEN and cannot know about such specialized
; items as this cache in nonpaged pool.
;
; If the cache is still allocated, it is deallocated and a success status
; is returned.
;
; Input Parameter:
;
;	R0 low bit clear
;
; Status Code:
;
;	R0 low bit set    => FILEREAD cache successfully deallocated
;
;	R0 low bit clear  => FILEREAD cache was already  deallocated
;			     (previous error stands)
;-

CHECK_CACHE:
	TSTL	G^FIL$GQ_CACHE		; Cache still allocated?
	BEQL	10$			; Branch if not -- original error stands
	CALLS	#0,SIP_CACHE_DALC	; Otherwise, deallocate the cache
10$:	RSB				;  and return to caller
	.PAGE

	.SUBTITLE	SIP_INITSWPFIL		Initialize SWAPFILE.SYS
;
;  Now initialize SWAPFILE.SYS if it exists
;

SIP_INITSWPFIL:
	TSTW	G^SGN$GW_SWPFILES	; If requested number of swap files is
	BEQL	SIP_INITRMS		;  zero, then skip this entire section
	MOVL	W^SIP_L_SWPATT,R4	; Address of swap file attributes buffer
	BICL3	#7,FILESIZE(R4),R0	; If file is empty or does not exist
	BEQL	SIP_INITRMS		;  then skip to the next step
	MOVZWL	G^SWP$GW_SWPINC,-(SP)	; Get value of SWPALLOCINC parameter
	CMPL	R0,(SP)+		; File size must be at least as large
	BLSSU	SIP_INITRMS		; ... so skip to next step if too small
	MOVAB	RTRVLEN(R4),R2		; Address of mapping data
	BSBW	SIP_INIWCB		; Allocate and init a window control block
;
; Set up argument list to BOO$INITSWPFIL on the stack. Ignore returned
; page file index. Default MAXVBN parameter. Use WCB address returned
; by SIP_INIWCB.
;
10$:	CLRQ	-(SP)			; Default last two parameters
	PUSHL	R2			; Store WCB address
	PUSHL	FILESIZE(R4)		;  ... and file size
	CALLS	#4,G^BOO$INITSWPFIL	; Allocate and initialize a PFL
	BLBS	R0,SIP_INITRMS		; Go on to next step if successful
	BSBB	CHECK_CACHE		; Can FIL$OPENFILE cache be deallocated?
	BLBS	R0,10$			; If so, try again
	MOVAB	W^INIPAGFIL,R1		; Otherwise, report an error message
	BSBW	SIP_FATAL		;  and abort the startup sequence
	.PAGE

	.SBTTL	SIP_INITRMS - Install RMS Image
;
;	INSTALL RMS IMAGE AS A PAGEABLE SYSTEM SECTION
;

SIP_INITRMS:
	MOVL	W^SIP_L_RMSATT,R4	; ADDRESS OF RMS FILE ATTRIBUTES BUF
	MOVL	IMAGESIZE(R4),R6	; ANY PAGES TO MAP?
	BLEQ	10$			; BRANCH IF NOT, ERROR
	BBC	S^#EXE$V_SYSPAGING,EXE$GL_FLAGS,30$ ; BRANCH IF NOT
					; PAGING SYSTEM SPACE
	MOVAB	RTRVLEN(R4),R2		; ADDRESS OF MAPPING DATA
	BSBW	SIP_INIWCB		; MAKE A WINDOW CONTROL BLOCK
	PUSHAL	MMG$GL_RMSBASE		; ADDRESS TO STORE BASE OF SECTION
	PUSHL	S^#PRT$C_UR		; PROTECTION FOR RMS PAGES
	PUSHL	R6			; NUMBER OF PAGES TO MAP
	PUSHL	IMAGEVBN(R4)		; STARTING VBN TO MAP
	PUSHL	R2			; WINDOW CONTROL BLOCK ADDRESS
	CALLS	#5,EXE$SYS_SECTION	; MAP RMS AS A SYSTEM SECTION
	BLBS	R0,60$			; BRANCH IF SUCCESSFUL
10$:	MOVAB	W^RMSMAPERR,R1		; FAILED TO MAP RMS
	BSBW	SIP_FATAL		; ISSUE FATAL DIAGNOSTIC
;
; IF SYSPAGING = 0 (NOT PAGING THE PAGED PORTION OF THE SYSTEM CODE),
; THEN CREATE SOME (WRITABLE) ADDRESS SPACE FOR RMS AND READ IT IN.
; RMS WILL STILL PAGE IN THE SYSTEM WORKING SET WHICH MEANS THAT THE
; SYSTEM WORKING SET MUST BE LARGE IF THE PAGES ARE TO STAY IN MEMORY.
;
30$:	ADDL3	R6,BOO$GL_SPTFREL,R1	; ALLOCATE SPT FOR RMS PAGES
	CMPL	R1,BOO$GL_SPTFREH	; ENOUGH LEFT?
	BGTR	10$			; BRANCH IF NOT
	MOVL	R1,BOO$GL_SPTFREL	; RECORD THE ALLOCATION
	SUBL	R6,R1			; FIRST SPT INDEX
	ASHL	#9,R1,R2		; FORM SYSTEM VA OF RMS
	BBSS	#VA$V_SYSTEM,R2,35$	; OR IN THE SYSTEM BIT
35$:
;
; SET UP THE ARGUMENT LIST FOR THE READ VIRTUAL CALL
;
	PUSHL	W^SIP_L_DSKCHAN		; CHANNEL FOR THE I/O REQUEST
	PUSHL	#IO$_READLBLK		; FUNCTION CODE
	ASHL	#9,R6,-(SP)		; BYTE COUNT TO READ (MAY BE > 65KB)
	PUSHL	R2			; VA TO READ INTO
	PUSHAL	RTRVLEN(R4)		; VIRTUAL TO LOGICAL MAP
	PUSHL	IMAGEVBN(R4)		; STARTING VBN IN IMAGE
;
; NOW FILL IN THE SPT WITH DEMAND ZERO ENTRIES
;
	MOVAL	@MMG$GL_SPTBASE[R1],R1	; ADDRESS OF FIRST SPT ENTRY
40$:	ASHL	#PTE$V_PROT,S^#PRT$C_URKW,(R1)+ ; STORE THE NEXT PTE
	SOBGTR	R6,40$			; LOOP THROUGH ALL PAGES
	CALLS	#6,W^QIO_RWVB		; READ RMS
	BLBC	R0,10$			; BRANCH IF ERROR
	MOVL	R2,MMG$GL_RMSBASE	; SET RMS BASE ADDRESS
60$:	MOVL	MMG$GL_RMSBASE,CTL$GL_RMSBASE ; SET RMS BASE FOR THIS PROCESS
	MOVL	EXE$GL_SYSUCB,R1	; GET SYSTEM DEVICE UCB ADDRESS
	CLRL	UCB$L_PID(R1)		; DEALLOCATE SYSTEM DEVICE
	.PAGE

	.SBTTL	RESTORE ERROR LOG BUFFERS
;
;	THE FOLLOWING LOOKS AT THE FIRST 3 PAGES OF THE DUMP FILE.  IF THERE
;	IS INFORMATION IN THE FILE, IT THEN LOOKS FOR ERROR LOG ENTRIES THAT
;	REMAINED IN THE BUFFERS AT THE TIME OF THE CRASH.  THESE ARE REMOVED
;	AND PLACED IN THE CURRENT ERROR LOG BUFFERS.  THE ERROR LOG ENTRY
;	FOR THE BUG_CHECK WILL BE CONTAINED IN THE ERROR LOG BUFFER PAGES
;	IN THE DUMP (PAGES 2 AND 3), IF THE DUMP WAS FOR A SYSTEM PRIOR TO
;	RELEASE 2.0.  RELEASE 2.0 AND SUBSEQUENT RELEASES PLACE BUG_CHECK
;	ERROR LOG IN THE FIRST PAGE OF THE DUMP FILE.  THIS WAS DONE BECAUSE
;	THE ERROR LOG BUFFERS COULD BE FULL AND THE BUG_CHECK INFORMATION LOST.
;
RESTORERL:				; RESTORE ERROR LOG INFORMATION
	MOVAB	W^SIP_A_ERLBUFFER,R4	; BUFFER TO READ INTO
	TSTL	W^SIP_L_ERRSEQ		; TEST SAVED SEQUENCE NUMBER
	BNEQ	10$			; BRANCH IF ERROR LOG ENTRIES TO SAVE
	BRW	NOERL			; NO ERROR LOG ENTRIES
10$:	MOVL	#2,R5			; SET NUMBER OF ERROR LOG BUFFERS
20$:	MOVAB	512(R4),R4		; POINT TO NEXT BUFFER
	MOVZBL	ERL$B_MSGCNT(R4),R11	; GET COUNT OF COMPLETED MSGS IN BUFFER
	BEQL	80$			; NO, TRY NEXT BUFFER
	MOVZBL	ERL$B_BUSY(R4),R7	; GET COUNT OF INCOMPLETE MSGS IN BUFFER
	ADDL	R7,R11			; GET TOTAL # OF MESSAGES TO SCAN
	MOVZWL	#<512-ERL$C_LENGTH>,R7	; SET BYTES IN BUFFER
	SUBL3	ERL$L_NEXT(R4),ERL$L_END(R4),R6 ; EMPTY BUFFER SIZE
	CMPL	R6,R7			; CHECK FOR REASONABLE POINTERS
	BGTRU	80$			; NO, TRY NEXT BUFFER
	SUBL	R6,R7			; COMPUTE ALLOCATED SPACE IN BUFFER
	MOVZBL	#ERL$C_LENGTH,R10	; SET INITIAL OFFSET IN ERL BUFFER
30$:	MOVAB	(R4)[R10],R8		; COMPUTE MESSAGE BASE ADDRESS
	ADDL	#EMB$K_LENGTH,R8	; POINT PAST MESSAGE HEADER
	MOVZWL	EMB$W_SIZE(R8),R9	; GET MESSAGE SIZE
	BEQL	80$			; NULL - ERROR
	SUBL	R9,R7			; CHECK FOR FIT IN ALLOCATED BUFFER
	BLSS	80$			; NO SKIP REST OF BUFFER
	TSTB	EMB$B_VALID(R8)		; IS THIS A VALID MESSAGE?
	BEQL	40$			; BRANCH IF NOT
	CMPB	EMB$B_BUFIND(R8),#1	; FURTHER CHECK MESSAGE VALIDITY
	BGTRU	80$			; BR IF NOT TO SKIP BUFFER
	SUBL	#EMB$K_LENGTH,R9	; SIZE OF BUFFER TO ALLOCATE
	MOVL	R9,R1			; SIZE OF BUFFER TO ALLOCATE
	JSB	ERL$ALLOCEMB		; ALLOCATE BUFFER FOR MESSAGE
	BLBC	R0,40$			; SKIP IF NO SPACE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	R9,(R8),(R2)		; COPY MESSAGE ENTIRELY
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	JSB	ERL$RELEASEMB		; MARK MESSAGE COMPLETE
	ADDL	#EMB$K_LENGTH,R9	; SIZE OF MESSAGE BUFFER W/HEADER
40$:	ADDL	R9,R10			; POINT TO NEXT MESSAGE
50$:	SOBGTR	R11,30$			; GET NEXT MESSAGE IF ANY
80$:	SOBGTR	R5,20$			; NEXT BUFFER
	MOVAB	W^SIP_A_ERLBUFFER,R4	; GET ADDRESS OF FIRST PAGE FROM DUMP
	MOVAB	DMP$L_CRASHERL+EMB$K_LENGTH(R4),R4 ; GET ADR OF CRASH ERL ENTRY
	MOVZWL	EMB$W_SIZE(R4),R9	; GET SIZE OF ERL ENTRY
	SUBL	#EMB$K_LENGTH,R9	; SET SIZE OF BUFFER TO ALLOCATE
	MOVL	R9,R1			; REMEMBER SIZE
	JSB	ERL$ALLOCEMB		; ALLOCATE SPACE IN ERROR LOG BUFFER
	BLBC	R0,90$			; BR ON ERROR, NO SPACE AVAILABLE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	R9,(R4),(R2)		; COPY ERL ENTRY INTO ERROR LOG BUFFER
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	JSB	ERL$RELEASEMB		; MARK MESSAGE COMPLETE
90$:	MOVL	W^SIP_L_ERRSEQ,ERL$GL_SEQUENCE	; RESTORE CURRENT SEQUENCE MESSAGE
NOERL:					; 
	JSB	ERL$COLDSTART		; LOG STARTUP
;
; INITIALIZATION KERNEL ROUTINE COMPLETE
;
	MOVZWL	#1,R0			; GIVE SUCCESS
	RET
	.PAGE

	.SBTTL	QIO_RWVB - Read or Write Virtual Block
;++
; Functional Description:
;	This routine maps the specified virtual blocks to logical blocks
;	and reads or writes the desired number of bytes to or from the
;	specified location in memory.
;
; Calling sequence:
;	CALLG	arglist,QIO_RWVB
;
; Inputs:
;	QIO_RWVB_VBN(AP)    = Virtual Block Number
;	QIO_RWVB_MAP(AP)    = Mapping info for virtual to logical mapping:
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;	QIO_RWVB_BUF(AP)    = Buffer Address to read into
;	QIO_RWVB_BYTCNT(AP) = Byte count to read (up to 31 bits)
;	QIO_RWVB_FUNC(AP)   = #IO$_READLBLK or #IO$_WRITELBLK
;	QIO_RWVB_CHAN(AP)   = Channel assigned to disk
;
; Outputs:
;	R0 = Status
;	R1 altered
;	All other registers preserved
;
;--

	$OFFSET	4,POSITIVE,<-
	QIO_RWVB_VBN,-
	QIO_RWVB_MAP,-
	QIO_RWVB_BUF,-
	QIO_RWVB_BYTCNT,-
	QIO_RWVB_FUNC,-
	QIO_RWVB_CHAN -
	>

QIO_RWVB:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	ASSUME	QIO_RWVB_MAP EQ QIO_RWVB_VBN+4
	MOVQ	QIO_RWVB_VBN(AP),R3	; R3 = VBN, R4 = Map
	MOVL	QIO_RWVB_BUF(AP),R6	; R6 = Buffer address

	ASSUME	QIO_RWVB_FUNC EQ QIO_RWVB_BYTCNT+4
	MOVQ	QIO_RWVB_BYTCNT(AP),R9	; R9 = byte count, R10 = function
	MOVL	QIO_RWVB_CHAN(AP),R11	; R11 = RPB adr or channel
	ASHL	#-3,(R4)+,R5		; R5 = # of rtrv ptr quad words
					; R4 = adr of 1st rtrv ptr
10$:	MOVQ	(R4)+,R0		; R0 = # of LBN's in this rtrv ptr
					; R1 = Starting LBN in this rtrv ptr
	SUBL	R0,R3			; Is desired VBN covered 
					; by this retrieval pointer?
	BLSS	20$			; Branch if yes
	SOBGTR	R5,10$			; No, get the next rtrv ptr
	BRB	60$			; Desired VBN beyond EOF
20$:	MOVAB	-(R3)[R0],R3		; R3 = R3 + R0 - 1
					; Number of blocks from the
					; beginning of this rtrv ptr
	ADDL	R3,R1			; Adjust starting LBN
	SUBL	R3,R0			; and LBN count
	BRB	40$
30$:	MOVQ	(R4)+,R0		; Get the next rtrv ptr
;
; R0 = number of blocks that can be read in this portion
; R1 = starting LBN to read from
;
40$:	PUSHL	R9			; Save desired byte count
	ASHL	#9,R0,R0		; # of bytes that can be read
	CMPL	R9,R0			; If fewer are needed
	BLEQ	50$			; Then read the smaller number
	MOVL	R0,R9			; Otherwise read all we can
50$:	SUBL	R9,(SP)			; Note how much is left to be read
	MOVL	R1,R8			; Starting LBN of read request
	BSBB	QIO_RWLB		; Read or write the file
	MOVL	(SP)+,R9		; Recover byte left to be read
	BLEQ	90$			; Branch if all done
	BLBC	R0,90$			; Branch if read error
	SOBGTR	R5,30$			; Get the next retrieval pointer
60$:	MOVZWL	#SS$_ENDOFFILE,R0	; Indicate EOF error
90$:	RET
	.PAGE

	.SBTTL	QIO_RWLB - Read or Write Logical Block
;++
; Functional Description:
;	This routine reads/writes the specified logical block numbers
;	from/to the boot disk.
;
; Calling Sequence:
;	BSBW	QIO_RWLB
;
; Inputs:
;	R6  = Buffer address (updated)
;	R8  = Logical block number (updated)
;	R9  = Byte count to transfer (up to 31 bits)
;	R10 = #IO$_READLBLK or #IO$_WRITELBLK
;	R11 = Channel assigned to disk
; Outputs:
;	R0 = Status
;	R1,R6-R9 altered
;	All other registers preserved
;--
	IOSIZE=127
QIO_RWLB:
	SUBL	#8,SP			; Reserve an IOSB
10$:	MOVZWL	#IOSIZE*512,R7		; Assume maximum transfer
	CMPL	R7,R9			; Minimize with file size
	BLEQ	20$			; Smaller than remaining file size
	MOVL	R9,R7			; Set to remaining file size
20$:	MOVL	SP,R0			; Address of IOSB
	$QIOW_S -
		EFN = #0 -		; Event flag
		CHAN = R11 -		; Channel
		FUNC = R10 -		; Read or write logical block
		IOSB = (R0) -		; I/O Status block address
		P1 = (R6) -		; Buffer address
		P2 = R7 -		; Byte count to transfer
		P3 = R8 		; Logical block number
	BLBC	R0,50$			; Branch if error
	MOVZWL	(SP),R0			; Get completion status
	BLBS	R0,90$			; Branch if completed successfully
	BEQL	70$			; Branch if I/O is still in progress
;
; Error from QI/O
;
50$:	CMPW	R0,#SS$_INSFWSL		; Insufficient working set?
	BNEQ	100$			; Branch if not, report error
	ASHL	#-1,R7,R7		; Try again with half the byte count
	BICL	#^X1FF,R7		; Use an integral number of pages
	BNEQ	20$			; Branch if something left to transfer
	BRB	100$			; Couldn't even transfer 1 page
;
; The following magic with event flag 0 and the IOSB is to take care
; of the case that the event flag was set for some reason other than 
; the completion of this particular I/O request.  In that case, the
; only real completion information is the IOSB itself.  The sequence
; must be to clear the event flag, check the IOSB, and then wait again
; for the event flag.
;
60$:	$WAITFR_S #0			; Wait for event flag
70$:	$CLREF_S #0			; Clear the event flag
	MOVZWL	(SP),R0			; Fetch I/O status
	BEQL	60$			; Branch if I/O not completed
	BLBC	R0,100$			; Branch if error
;
; I/O completed successfully, see if there is any more to do
;
90$:	ASHL	#-9,R7,R1		; Block count
	ADDL	R1,R8			; Starting LBN for next piece
	ADDL	R7,R6			; Starting Buf Adr for next piece
	SUBL	R7,R9			; Count bytes tranferred
	BGTR	10$			; Branch if another transfer to do
100$:	ADDL	#8,SP			; Clean off IOSB
	RSB				; and return
	.PAGE

	.SBTTL	SIP_INIWCB - ALLOCATE AND INIT A WINDOW CONTROL BLOCK
;
; INPUTS:
;
;	R2 = ADDRESS OF MAPPING DATA
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;
; OUTPUTS:
;
;	R2 = WINDOW CONTROL BLOCK ADDRESS
;	R0,R1,R3 ALTERED
;	R4,R5 PRESERVED
;	RETURNS IN LINE ONLY IF SUCCESSFUL
;	FATAL ERROR IF FAIL TO ALLOCATE A WINDOW
;
SIP_INIWCB:
	MOVL	(R2)+,R1		;SIZE OF RETRIEVAL POINTER
	MOVL	EXE$GL_SYSUCB,R3	;SYSTEM UCB ADDRESS
	JSB	G^FIL$INIWCB		;ALLOCATE AND INIT THE WINDOW
	BLBC	R0,10$			;BRANCH IF FAILED
	RSB

10$:	MOVAB	W^INIWCBERR,R1		; ERROR INITING WINDOW CONTROL BLOCK
	BSBW	SIP_FATAL		;
	.PAGE

	.SBTTL	ALLOCATE NON-PAGED DYNAMIC MEMORY
;++
; Functional Description:
;	This routine allocates and zeroes the specified number of
;	bytes of non-paged dynamic memory.  If the allocation fails
;	it deallocates the FIL$OPENFILE cache if has not already been
;	deallocated and tries again.
;
; Calling Sequence:
;	BSBW	SIP_ALONONPAGED
;
; Inputs:
;	R1 = Desired number of bytes to allocate
;
; Outputs:
;	R0 = Status
;	R1 = No. of bytes allocated if successful
;	R2 = Address of block allocated if successful
;	     Block is zeroed
;	All other registers preserved
;--

SIP_ALONONPAGED:
	PUSHR	#^M<R1,R3,R4,R5>	; REMEMBER SIZE FOR RETRY
					; SAVE OTHERS FROM MOVC5
10$:	JSB	G^EXE$ALONONPAGED	; ALLOCATE NON-PAGED MEMORY
	BLBS	R0,30$			; BRANCH IF SUCCESSFUL
	TSTL	G^FIL$GQ_CACHE		; CACHE STILL ALLOCATED?
	BEQL	40$			; BRANCH IF NOT, ALLOC ERROR
	CALLS	#0,B^SIP_CACHE_DALC	; DEALLOCATE FIL$OPENFILE CACHE
	MOVL	(SP),R1			; RECOVER SIZE TO ALLOCATE
	BRB	10$			; AND TRY AGAIN
30$:	PUSHR	#^M<R0,R1,R2>		; SAVE RETURN INFO FROM MOVC5
	MOVC5	#0,(R2),#0,R1,(R2)	; ZERO THE ALLOCATED BLOCK
	POPR	#^M<R0,R1,R2>		; RECOVER STATUS, SIZE, ADR
40$:	ADDL	#4,SP			; CLEAN OFF SAVED SIZE TO ALLOCATE
	POPR	#^M<R3,R4,R5>		; RESTORE OTHER REGISTERS
	RSB

	.SBTTL	DEALLOCATE FIL$OPENFILE CACHE
;
; KERNEL MODE ROUTINE TO DEALLOCATE THE FIL$OPENFILE CACHE
;
SIP_CACHE_DALC:
	.WORD	^M<R2,R3>
	MOVQ	G^FIL$GQ_CACHE,R1	; R1 = SIZE, R2 = ADR OF CACHE
	BEQL	10$			; BRANCH IF NOT PRESENT
	CLRQ	G^FIL$GQ_CACHE		; DISABLE THE CACHE
	MOVL	R2,R0
	JSB	G^EXE$DEANONPGDSIZ	; DEALLOCATE FIL$OPENFILE CACHE
10$:	MOVL	S^#SS$_NORMAL,R0	; INDICATE SUCCESSFUL COMPLETION
	RET
	.PAGE

	.SBTTL	SIP ERROR/MESSAGE OUTPUT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE IS CALL TO DISPLAY AN ERROR FOR THE
;	SYSTEM INITIALIZATION PROCESS.
;
; CALLING SEQUENCE:
;
;	BSB	SIP_FATAL		; DISPLAY ERROR AND EXIT
;	BSB	SIP_SYSMSG		; TO DISPLAY A SYSTEM ERROR AND RETURN
;	BSB	SIP_R0MSG		; TO DISPLAY AN ERROR WITH VALUE IN R0
	BSB	SIP_TYPOUT		; TYPE OUT A MESSAGE
;
; INPUT PARAMETERS:
;
; FOR SIP_FATAL AND SIP_SYSMSG:
;
;	R0 IS ERROR CODE
;	R1 IS ADDRESS OF COUNTED MESSAGE STRING
;
; CALL AT SIP_TYPOUT WITH:
;
;	R0 = BYTE COUNT
;	R1 = ADDRESS OF STRING
;
; OUTPUT PARAMETERS:
;
;	THE MESSAGE IS DISPLAYED AND AN IMAGE EXIT IS EFFECTED IF
;	ENTERED AT SIP_FATAL.
;--
;
SIP_FATAL:
	PUSHL	R0			; SAVE ERROR
	BSB	SIP_SYSMSG		; OUTPUT MESSAGE
	CALLS	#1,@#SYS$EXIT		; TAKE EXIT WITH STATUS
 
;
; ROUTINE TO PRINT MESSAGE WITH SYSTEM ERROR CODE
;
 
SIP_SYSMSG:
	PUSHR	#<^M<R0,R2>>		; SAVE ARGUMENT AND A REGISTER
	PUSHL	R1			; PUSH ADDRESS OF THE TEXT STRING
	MOVAL	W^SIP_Q_LINBUF+2,R2	; GET THE BUFFER DESCRIPTOR
	MOVW	(R2),-(R2)		; SET BUFFER LENGTH
	PUSHAQ	(R2)			; ADDRESS OF BUFFER DESCRIPTOR
	PUSHAW	(R2)			; PLACE TO RETURN LENGTH
	PUSHAB	W^FAOERR		; FORMAT STRING
	CALLS	#5,@#SYS$FAO		; FORMAT THE MESSAGE
	MOVZWL	(R2),R0			; GET LENGTH
	MOVL	4(R2),R1		; BUFFER ADDRESS
	POPR	#^M<R2>			; RESTORE CALLER R2
					; FALL INTO TYPE OUT
 
SIP_TYPOUT:				;
	PUSHR	#^M<R0,R1>		; SAVE BUFFER AND COUNT
	$ASSIGN_S  W^SIP_Q_TTNAME,W^SIP_L_TTCHAN ; ASSIGN A CHANNEL TO TERMINAL
	BLBC	R0,30$			; BR IF ERROR ASSIGNING CHANNEL
	POPR	#^M<R0,R1>		; RESTORE COUNT AND BUFFER
	$QIOW_S	#0,W^SIP_L_TTCHAN,-	; EVENT FLAG 0, TERMINAL CHANNEL
		#IO$_WRITEVBLK,-	; WRITE OPERATION
		,,,-			; NO I/O STATUS,AST ADDRESS OR PARAMETER
		(R1),R0,-		; BUFFER ADDRESS IN R1,R0 CONTAINS COUNT
		#0,#32			; NULL PARAMETER PLUS CARRAIGE CONTROL
	BLBC	R0,30$			; BR IF ERROR WRITING TERMINAL
	$DASSGN_S W^SIP_L_TTCHAN	; REMOVE TERMINAL ASSIGNMENT
	BLBC	R0,30$			; BR ON DEASSIGN ERROR
	RSB				; RETURN TO CALLER
30$:	$CMKRNL_S B^100$		; GET TO KERNEL MODE
;
; FATAL ERROR ROUTINE
;
100$:	.WORD	0			; ERROR ATTEMPTING OUTPUT TO TERMINAL
	BUG_CHECK  SYSTRMERR,FATAL	; REPORT FATAL ERROR
	.PAGE

	.SBTTL	SIP_SETTIME  -  SET SYSTEM TIME TO CORRECT VALUE AT STARTUP
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CALLS THE LOADABLE, CPU-DEPENDENT ROUTINE, EXE$INIT_TODR,
;	TO INITIALIZE THE TIME-OF-DAY REGISTER AND SYSTEM TIME.
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	TIME-OF-DAY PROCESSOR CLOCK.
;
; OUTPUT PARAMETERS:
;
;	R0,R1 - DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	EXE$GQ_SYSTIME - SET TO CURRENT TIME IN 100 NANOSECOND UNITS SINCE
;			 17-NOV-1858  00:00:00.
;
;--

SIP_SETTIME:				; SET CORRECT TIME
	.WORD	0			; ENTRY MASK
	JSB	EXE$INIT_TODR		; CALL CPU-DEPENDENT ROUTINE
	MOVZWL	S^#SS$_NORMAL,R0	; INDICATE SUCCESS
	RET				;

	.END	SIP_START
