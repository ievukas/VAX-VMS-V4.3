	.TITLE	SYMBOL - SYMBOL TABLE MANIPULATION ROUTINES
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; SYMBOL TABLE MANIPULATION ROUTINES
;
; D. N. CUTLER 29-APR-77
;
; MODIFIED BY:
;
;	V03-006	HWS0031		Harold Schultz	14-Mar-1984
;		Add DELETE/SYMBOL/LOG
;
;	V03-005	PCG0009		Peter George	16-Aug-1983
;		Fix bug in binary symbol restoration logic.
;
;	V03-004	PCG0008		Peter George	27-May-1983
;		Add PTRDEF reference.
;
;	V03-003	PCG0007		Peter George	27-May-1983
;		Add DCL$DELSYM.
;
;	V03-002	PCG0006		Peter George	09-Mar-1983
;		Call DCL$FIND_KEYPAD.
;		Add DCL$RESTORE_SYM.
;
;	V03-001	PCG0005		Peter George	15-Nov-1982
;		Do roundup in DEADYNMEM.  Signal SPR error.
;---

;
; MACRO LIBRARY CALLS
;
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE TOKEN DESCRIPTORS
	SYMDEF				;DEFINE SYMBOL ENTRY OFFSETS
	IDFDEF				;DEFINE INDIRECT STACK OFFSETS
	CTXDEF				;DEFINE SPAWN CTX SYMBOLS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
;
;	SYMBOL TYPE DESCRIPTION STRINGS FOR DEL/SYM/LOG
;
LOCTAB:	.ASCIC	/Local/

GBLTAB:	.ASCIC	/Global/

	.SBTTL	ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE
;+
; DCL$ALLOCSYMABR - ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE W/ ABBREVIATION
; DCL$ALLOCSYM - ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE
;
; THIS ROUTINE IS CALLED TO ALLOCATE AND INSERT A SYMBOL ENTRY IN EITHER THE
; LOCAL OR GLOBAL SYMBOL TABLE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R0 = TYPE OF SYMBOL VALUE (SYM_K_STRING OR SYM_K_BINARY)
;	R1/R2 = DESCRIPTOR OF SYMBOL VALUE
;	R3/R4 = DESCRIPTOR OF SYMBOL NAME.
;	R5 = ADDRESS OF SYMBOL TABLE LISTHEAD.
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED.
;
; OUTPUTS:
;
;	THE SPECIFIED SYMBOL TABLE IS SEARCHED FOR THE SPECIFIED ENTRY, AND
;	IF FOUND, THE OLD ENTRY IS DEALLOCATED. A SYMBOL TABLE ENTRY IS THEN
;	ALLOCATED, FILLED WITH THE SYMBOL AND VALUE INFORMATION, AND THEN
;	INSERTED IN THE SPECIFIED SYMBOL TABLE.
;
;	R0 LOW BIT CLEAR INDICATES ALLOCATION FAILURE WITH:
;
;		R0 = DCL$_SYMOVF - NO ROOM FOR SYMBOL DEFINITIONS.
;		R0 = DCL$_SYMDEL - ABBREVIATED SYMBOL NOT ALLOWED.
;		R0 = DCL$_ABSYMD - AMBIGUOUS SYMBOL DEFINITION.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R1 = ADDRESS OF ALLOCATED SYMBOL ENTRY.
;		R2,R3,R4,R5 ARE DESTROYED.
;-
 
DCL$GT_SYMABR::				;ABBREVIATED SYMBOL COUNTED STRING
	.ASCIC	'*'

DCL$ALLOCSYMABR::			;ALLOCATE AND INSERT SYMBOL IN TABLE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE SYMBOL ENTRY PARAMETERS
	LOCC	#^A'*',R3,(R4)		;FIND THE ABBREVIATION FLAG
	PUSHL	R0			;SAVE NUMBER OF EXTRA CHARACTERS
	BEQL	ALLOCSYM		;BRANCH IF NOT ABBREVIATED
	DECL	(SP)			;REMOVE THE ABBR CHAR FROM EXTRA COUNT
	DECL	16(SP)			;REMOVE THE ABBR CHAR FROM NAME COUNT
	MOVC	(SP),1(R1),(R1)		;SLIDE REMAINING CHARACTERS OVER IT
	BRB	ALLOCSYM

DCL$ALLOCSYM::				;ALLOCATE AND INSERT SYMBOL IN TABLE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE SYMBOL ENTRY PARAMETERS
	CLRL	-(SP)			;SET NO ABBREVIATION
	LOCC	#^A'*',R3,(R4)		;FIND THE ABBREVIATION FLAG
	BEQL	ALLOCSYM		;OK IF NONE FOUND
	MOVAB	7*4(SP),SP		;CLEAN STACK
	MOVL	#CLI$_SYMABR,R0		;SET NO SYMBOL ABBREVIATIONS STATUS
	RSB

;
;	(SP) = # NONUNIQUE CHARACTERS (AFTER *)
;	4(SP) = TYPE OF SYMBOL VALUE
;	8(SP) = DESCRIPTOR OF SYMBOL VALUE
;	16(SP) = DESCRIPTOR OF SYMBOL NAME
;	24(SP) = ADDRESS OF SYMBOL TABLE LISTHEAD
;
ALLOCSYM:
	CLRL	R5			;START WITH FULL SYMBOL NAME
10$:	MOVQ	16(SP),R1		;RESET SYMBOL PARAMETERS
	SUBL	R5,R1			;FIND SIZE TO SEARCH FOR THIS TIME
	MOVL	24(SP),R0		;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	BSBW	DCL$SEARCHT		;SEARCH FOR SYMBOL
	BLBC	R0,30$			;IF LBC SEARCH FAILURE
	CMPB	SYM_B_TYPE(R3),#SYM_K_PERM ;PERMANENT SYMBOL?
	BEQL	SYMOVF			;IF YES - REFUSE TO ALLOCATE
	ASSUME	SYM_B_NONUNIQUE EQ SYM_T_SYMBOL-1
	SUBB3	R1,-(R4),R1		;FIND SYMBOL'S NEW
	DECB	R1			; UNIQUENESS POINT
	BGEQU	ABSYMD			;IF GEQ, AMBIGUOUS SYMBOL
	BSBW	DCL$DEALLOCSYM		;DEALLOCATE SYMBOL ENTRY
30$:	AOBLEQ	(SP),R5,10$		;LOOP IF MORE SYMBOLS TO CHECK

	ADDL3	8(SP),16(SP),R1		;CALCULATE LENGTH OF SYMBOL STRINGS
	CMPL	4(SP),#SYM_K_BINARY	;BINARY VALUE?
	BNEQ	40$			;BRANCH IF NOT
	ADDL3	#4,16(SP),R1		;SET LENGTH OF SYMBOL PLUS LONGWORD
40$:	ADDL	#SYM_T_SYMBOL+3,R1	;ADD IN FIXED OVERHEAD AND ROUND
	BSBB	DCL$ALLDYNMEM		;ALLOCATE DYNAMIC MEMORY
	BLBC	R0,SYMOVF		;IF LBC ALLOCATION FAILURE
	MOVL	R1,SYM_W_SIZE(R2)	;SET SIZE OF ALLOCATED BLOCK, ETC.
	CVTLB	(SP)+,SYM_B_NONUNIQUE(R2) ;SET UNIQUENESS POINT
	CVTLB	(SP)+,SYM_B_TYPE(R2)	;SET SYMBOL VALUE TYPE
	INSQUE	SYM_L_FL(R2),@16(SP)	;INSERT ENTRY IN SYMBOL TABLE
	MOVL	R2,16(SP)		;SAVE ADDRESS OF NEW ENTRY
	MOVQ	8(SP),R3		;GET SYMBOL NAME
	MOVB	R3,SYM_T_SYMBOL(R2)	;INSERT LENGTH OF SYMBOL
	MOVC	R3,(R4),SYM_T_SYMBOL+1(R2) ;INSERT SYMBOL NAME
	MOVQ	(SP),R1			;GET SYMBOL VALUE
	MOVL	16(SP),R0		;RETRIEVE ADDRESS OF ENTRY
	CMPB	SYM_B_TYPE(R0),#SYM_K_BINARY ;BINARY VALUE?
	BNEQ	50$			;BRANCH IF STRING VALUE
	MOVL	R1,(R3)+		;STORE LONGWORD BINARY VALUE
	BRB	60$
50$:	MOVW	R1,(R3)+		;INSERT LENGTH OF STRING VALUE
	MOVC	R1,(R2),(R3)		;INSERT STRING VALUE
60$:	POPR	#^M<R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	MOVL	R5,R1			;RETURN ADDRESS OF SYMBOL ENTRY
	MOVL	#1,R0			;SET SUCCESS INDICATOR
	RSB				;

	.ENABL	LSB

ABSYMD:	STATUS	ABSYMD			;SET AMBIGUOUS SYMBOL STATUS
	BRB	90$

SYMOVF:	STATUS	SYMOVF			;SET SYMBOL TABLE OVERFLOW STATUS
90$:	ADDL	#8,SP			;POP OFF TOP 2 LONGWORDS
	POPR	#^M<R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	RSB

	.DSABL	LSB

;+
; DCL$ALLDYNMEM - DISPATCH TO MEMORY ALLOCATION SUBROUTINE
;
; ENTER HERE TO DISPATCH TO THE MEMORY ALLOCATION ROUTINE
;
; INPUT:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R1 = SIZE OF BLOCK
;
; OUTPUTS:
;
;	R1 = SIZE OF BLOCK ALLOCATED
;	R2 = ADDRESS OF BLOCK
;	R3 IS DESTROYED
;-
 
DCL$ALLDYNMEM::				;ALLOCATE DYNAMIC MEMORY
	MOVAB	PRC_Q_ALLOCREG(R11),R3	;GET ADDRESS OF ALLOCATION LISTHEAD
	ADDL	#7,R1			;ROUND UP TO QUADWORD BOUNDARY
	BICL	#7,R1			;TRUNCATE TO QUADWORD MULTIPLE
	JMP	@#EXE$ALLOCATE		;ALLOCATE SYMBOL TABLE ENTRY

	.SBTTL	DEALLOCATE SYMBOL TABLE ENTRY
;+
; DCL$DEALLOCSYM - DEALLOCATE SYMBOL TABLE ENTRY
; DCL$DEADYNMEM  - DEALLOCATE DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO REMOVE A SYMBOL FROM ITS TABLE AND/OR
; DEALLOCATE DYNAMIC MEMORY USED.
;
; INPUTS TO DEALLOCSYM:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R3 = ADDRESS OF SYMBOL ENTRY.
;
; INPUTS TO DEALDYNMEM:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R0 = ADDRESS OF BLOCK TO DEALLOCATE
;	R1 = SIZE OF BLOCK
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED.
;
; OUTPUTS:
;
;	THE SYMBOL IS REMOVED FROM ITS TABLE AND/OR ITS STORAGE IS DEALLOCATED.
;-
 
DCL$DEALLOCSYM::			;DEALLOCATE SYMBOL TABLE ENTRY
	REMQUE	SYM_L_FL(R3),R0		;REMOVE SYMBOL ENTRY FROM ITS TABLE
	MOVZWL	SYM_W_SIZE(R0),R1	;GET SIZE OF BLOCK TO DEALLOCATE
DCL$DEADYNMEM::				;DEALLOCATE DYNAMIC MEMORY
	ADDL	#7,R1			;ROUND UP TO QUADWORD BOUNDARY
	BICL	#7,R1			;TRUNCATE TO QUADWORD MULTIPLE
	MOVAB	PRC_Q_ALLOCREG(R11),R3	;GET ADDRESS OF ALLOCATION LISTHEAD
	JMP	@#EXE$DEALLOCATE	;DEALLOCATE SYMBOL ENTRY STORAGE

	.SBTTL	CONVERT SYMBOL VALUE TO STRING
;+
; DCL$SYM_STRING - GET SYMBOL VALUE AND CONVERT TO A STRING
;
; THIS ROUTINE IS CALLED TO SEARCH ALL LOCAL AND GLOBAL SYMBOL TABLES FOR
; A SPECIFIED SYMBOL, AND TO RETURN THE STRING FORM OF THE SYMBOL VALUE.
; THAT IS, IF THE SYMBOL VALUE IS NUMERIC, IT IS CONVERTED TO ASCII DECIMAL
; BEFORE BEING RETURNED.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R1 = LENGTH OF SYMBOL.
;	R2 = ADDRESS OF SYMBOL.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = LENGTH OF VALUE STRING
;	R2 = ADDRESS OF VALUE STRING
;	R3 = DESTROYED
;	R4 = TABLE FLAG
;		1 ==> FOUND IN LOCAL SYMBOL TABLE
;		2 ==> FOUND IN GLOBAL SYMBOL TABLE
;
;	THE STRING MAY ACTUALLY RESIDE IN EITHER THE SYMBOL TABLE OR
;	IN THE UNUSED PORTION OF THE EXPANSION BUFFER.  IT IS THE CALLER'S
;	RESPONSIBILITY TO COPY THE STRING BEFORE USING THE EXPANSION BUFFER.
;-

DCL$SYM_STRING::
	BSBB	DCL$SEARCH		; SEARCH ALL SYMBOL TABLES
	BLBS	R0,DCL$CVT_STRING	; BRANCH IF NOT FOUND
	CLRL	R1			; RETURN NULL STRING ON ERROR
	RSB

	.SBTTL	CONVERT EXPRESSION RESULT TO STRING
;+
; DCL$CVT_STRING - CONVERT EXPRESSION RESULT TO A STRING
;
; IF THE SYMBOL VALUE IS NUMERIC, IT IS CONVERTED TO ASCII DECIMAL.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R1/R2 = QUADWORD DESCRIBING VALUE:
;		IF R2 NONZERO, QUADWORD IS A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = LENGTH OF VALUE STRING
;	R2 = ADDRESS OF VALUE STRING
;	R3 = DESTROYED
;	R4 = PRESERVED
;
;	THE STRING MAY ACTUALLY RESIDE IN EITHER THE SYMBOL TABLE OR
;	IN THE UNUSED PORTION OF THE EXPANSION BUFFER.  IT IS THE CALLER'S
;	RESPONSIBILITY TO COPY THE STRING BEFORE USING THE EXPANSION BUFFER.
;-

DCL$CVT_STRING::
	TSTL	R2			; NUMERIC VALUE?
	BNEQ	90$			; BRANCH IF STRING
	MOVL	R1,R0			; GET BINARY VALUE
	PUSHL	R4			; SAVE R4 (JUST IN CASE)
	BSBW	DCL$CBTA_DEC		; CONVERT TO ASCII IN EXPANSION BUFFER
	MOVL	(SP)+, R4		; RESTORE SAVED R4
90$:	MOVL	#1,R0			; SET SUCCESS
	RSB

	.SBTTL	SEARCH FOR SYMBOL ENTRY
;+
; DCL$SEARCH - SEARCH FOR SYMBOL ENTRY
;
; THIS ROUTINE IS CALLED TO SEARCH ALL LOCAL AND GLOBAL SYMBOL TABLES FOR
; AN ENTRY.  THE LOCAL SYMBOL TABLES FOR EACH OF THE INDIRECT LEVELS ARE
; FIRST SEARCHED.  IF NOTHING FOUND, THE GLOBAL SYMBOL TABLE IS SEARCHED.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R1 = LENGTH OF SYMBOL.
;	R2 = ADDRESS OF SYMBOL.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = QUADWORD DESCRIBING SYMBOL VALUE:
;		IF R2 NONZERO, QUADWORD IS A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;	R3 = ADDRESS OF SYMBOL ENTRY.
;	R4 = TABLE FLAG
;		1 ==> FOUND IN LOCAL SYMBOL TABLE
;		2 ==> FOUND IN GLOBAL SYMBOL TABLE
;
;-
 
DCL$SEARCH::				;SEARCH FOR SYMBOL ENTRY
	BSBW	DCL$SEARCH_LOCAL	;SEARCH LOCAL SYMBOL TABLES
	MOVL	#1,R4			;INDICATE LOCAL SYMBOL TABLE MATCH FOUND
	BLBS	R0,10$			;IF LBS MATCH FOUND
	BSBW	DCL$SEARCH_GLOBAL	;SEARCH GLOBAL SYMBOL TABLE
	MOVL	#2,R4			;INDICATE GLOBAL SYMBOL TABLE MATCH FOUND
	BLBS	R0,10$			;IF LBS MATCH FOUND
	CLRL	R1			;RETURN NULL STRING IF NO MATCH
10$:	RSB				;

	.SBTTL	SEARCH FOR SYMBOL ENTRY IN A LOCAL SYMBOL TABLE
;+
; DCL$SEARCH_LOCAL - SEARCH FOR SYMBOL ENTRY IN A LOCAL SYMBOL TABLE
;
; THIS ROUTINE IS CALLED TO SEARCH ALL LOCAL SYMBOL TABLES FOR AN ENTRY.  
; THE LOCAL SYMBOL TABLES FOR EACH OF THE INDIRECT LEVELS ARE SEARCHED.  
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R1 = LENGTH OF SYMBOL.
;	R2 = ADDRESS OF SYMBOL.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = QUADWORD DESCRIBING SYMBOL VALUE:
;		IF R2 NONZERO, QUADWORD IS A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;	R3 = ADDRESS OF SYMBOL ENTRY.
;
;-
 
DCL$SEARCH_LOCAL::			;SEARCH FOR SYMBOL ENTRY IN LOCAL TABLE
	DISABLE				;DISABLE CTRL/Y'S TO GUARANTEE INTEGRITY
					;OF PRC_Q_LOCAL(R11)
	MOVQ	PRC_Q_LOCAL(R11),-(SP)	;SAVE CURRENT LOCAL SYMBOL TABLE LISTHEAD
	PUSHL	PRC_L_STACKPT(R11)	;SAVE ADDRESS OF INDIRECT STACK POINTER
5$:	MOVAB	PRC_Q_LOCAL(R11),R0	;SET ADDRESS OF LOCAL SYMBOL TABLE LISTHEAD
	BSBB	DCL$SEARCHT		;SEARCH LOCAL SYMBOL TABLE FOR ENTRY
	BLBS	R0,10$			;IF LBS MATCH FOUND
	MOVL	(SP)+,R0		;RETRIEVE ADDRESS OF INDIRECT FRAME
	PUSHAB	IDF_K_LENGTH(R0)	;CALCULATE ADDRESS OF NEXT FRAME
	MOVQ	IDF_Q_LOCAL+IDF_K_LENGTH(R0),PRC_Q_LOCAL(R11) ;REPLACE LISTHEAD
	BBS	#IDF_V_INPOPN,IDF_W_FLAG(R0),5$ ;IF SET, SEARCH NEXT TABLE
	CLRL	R0			;NO MATCH FOUND
	BRB	20$
10$:	BSBB	GET_VALUE		;GET THE SYMBOL VALUE
20$:	TSTL	(SP)+			;CLEAN STACK
	MOVQ	(SP)+,PRC_Q_LOCAL(R11)	;RESTORE LOCAL SYMBOL TABLE LISTHEAD
	ENABLE				;REENABLE CTRL/Y'S
	RSB				;

;
; GET DESCRIPTOR (R1/R2) OF SYMBOL VALUE.
;	R2=0 ==> VALUE IS AN INTEGER
;

GET_VALUE:
	MOVZBL	SYM_T_SYMBOL(R3),R2	;GET LENGTH OF SYMBOL
	MOVAB	SYM_T_SYMBOL+1(R3)[R2],R2 ;GET ADDRESS OF VALUE LENGTH
	CMPB	SYM_B_TYPE(R3),#SYM_K_BINARY ;NUMERIC BINARY VALUE?
	BNEQ	10$			;BRANCH IF NOT
	MOVL	(R2),R1			;GET LONGWORD BINARY VALUE
	CLRL	R2			;MARK NOT A STRING
	BRB	20$
10$:	MOVZWL	(R2)+,R1		;GET LENGTH OF VALUE
20$:	RSB


	.SBTTL	SEARCH FOR SYMBOL ENTRY IN GLOBAL SYMBOL TABLE
;+
; DCL$SEARCH_GLOBAL - SEARCH FOR SYMBOL ENTRY IN GLOBAL SYMBOL TABLE
;
; THIS ROUTINE IS CALLED TO SEARCH THE GLOBAL SYMBOL TABLE FOR AN ENTRY.  
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;	R1 = LENGTH OF SYMBOL.
;	R2 = ADDRESS OF SYMBOL.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = QUADWORD DESCRIBING SYMBOL VALUE:
;		IF R2 NONZERO, QUADWORD IS A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;	R3 = ADDRESS OF SYMBOL ENTRY.
;
;-
 
DCL$SEARCH_GLOBAL::			;SEARCH FOR SYMBOL ENTRY IN GLOBAL TABLE
	MOVAB	PRC_Q_GLOBAL(R11),R0	;SET ADDRESS OF GLOBAL SYMBOL TABLE LISTHEAD
	BSBB	DCL$SEARCHT		;SEARCH GLOBAL SYMBOL TABLE FOR ENTRY
	BLBC	R0,10$			;IF LBC NO MATCH FOUND
	BSBB	GET_VALUE		;GET THE SYMBOL VALUE
10$:	RSB				;


	.SBTTL	SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY
;+
; DCL$SEARCHT - SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY
;
; THIS ROUTINE IS CALLED TO SEARCH A SPECIFIC SYMBOL TABLE FOR AN ENTRY.
;
; INPUTS:
;
;	R0 = ADDRESS OF SYMBOL TABLE LISTHEAD.
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R1 = LENGTH OF SYMBOL NAME.
;		R2 = ADDRESS OF SYMBOL NAME.
;		R3,R4 ARE DESTROYED.
;
;	R0 LOW BIT SET INDICATES SYMBOL FOUND WITH:
;
;		R1 = LENGTH OF SYMBOL NAME.
;		R2 = ADDRESS OF SYMBOL NAME.
;		R3 = ADDRESS OF SYMBOL ENTRY.
;		R4 = ADDRESS OF SYMBOL NAME STRING (JUST PAST THE COUNT).
;-
 
DCL$SEARCHT::				;SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY
	MOVAB	PRC_Q_KEYPAD(R11),R3	;GET ADDRESS OF KEYPAD TABLE
	CMPL	R0,R3			;IS IT THE ONE WE WANT?
	BEQL	30$			;YES, THEN BRANCH
	MOVL	R0,R3			;COPY ADDRESS OF SYMBOL TABLE LISTHEAD
10$:	MOVL	SYM_L_FL(R3),R3		;GET ADDRESS OF NEXT ENTRY
	CMPL	R0,R3			;END OF TABLE?
	BEQL	20$			;IF EQL YES
	MOVAB	SYM_T_SYMBOL(R3),R4	;GET ADDRESS OF SYMBOL NAME
	CMPB	R1,(R4)			;SYMBOL LENGTH TOO LONG?
	BGTRU	10$			;IF GTRU YES
	SUBB3	SYM_B_NONUNIQUE(R3),(R4)+,-(SP) ;FORM UNIQUE LENGTH
	CMPB	R1,(SP)+		;SYMBOL LENGTH TOO SHORT?
	BLSSU	10$			;IF LSSU YES
	PUSHR	#^M<R0,R1,R2,R3>	;SAVE SEARCH PARAMETERS
	CMPC	R1,(R2),(R4)		;SYMBOLS MATCH?
	POPR	#^M<R0,R1,R2,R3>	;RESTORE SEARCH PARAMETERS
	BNEQ	10$			;IF NEQ NO
	INCL	R0			;SET SUCCESS INDICATOR
20$:	RSB				;

30$:	BSBW	DCL$FIND_KEYPAD		;CALL KEYPAD SYMBOL SEARCH ROUTINE
	RSB				;RETURN

	.SBTTL	RESTORE SYMBOL DEFINITION AFTER A SPAWN
;+
; DCL$RESTORE_SYM - RESTORE SYMBOL DEFINITION AFTER A SPAWN
;
; THIS ROUTINE IS CALLED TO RESTORE A SYMBOL AFTER A SPAWN.
;
; INPUTS:
;
;	R0 = SYMBOL TYPE
;	R1/R2 = DESCRIPTOR OF SYMBOL VALUE
;	R3/R4 = DESCRIPTOR OF SYMBOL NAME
;	R5 = ADDRESS OF SYMBOL TABLE LISTHEAD
;	R6 = ADDRESS OF CTX BLOCK
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	THE SYMBOL IS ADDED TO THE TAIL OF THE SYMBOL TABLE.
;
;	R0 LOW BIT CLEAR INDICATES ALLOCATION FAILURE WITH CLI$_SYMOVF.
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;-
 
DCL$RESTORE_SYM::
	PUSHR	#^M<R0,R1,R2,R3,R4>		;SAVE THE REGISTERS

;
; ALLOCATE THE SYMBOL.
;
	ADDL	#SYM_T_SYMBOL+3,R1		;GET SIZE OF SYMBOL NEEDED
	CMPB	#SYM_K_BINARY,R0		;BINARY SYMBOL?
	BNEQ	5$				;NO, THEN SKIP
	MOVL	#SYM_T_SYMBOL+3+4,R1		;SET SIZE OF SYMBOL NEEDED
5$:	ADDL	R3,R1				;
	BSBW	DCL$ALLDYNMEM			;ALLOCATE DYNAMIC MEMORY
	BLBC	R0,90$				;IF LBC ALLOCATION FAILURE

;
; INITIALIZE THE STATICALLY PLACED FIELDS AND INSERT IT IN THE LINKED LIST.
;
	MOVW	R1,SYM_W_SIZE(R2)		;SET SIZE OF ALLOCATED BLOCK
	MOVB	CTX_B_NONUNIQUE(R6),SYM_B_FLAGS(R2) ;SET KEYPAD FLAGS
	MOVB	(SP),SYM_B_TYPE(R2)		;SET VALUE TYPE
	CMPB	#SYM_K_KEYPAD,(SP)		;KEYPAD SYMBOL?
	BNEQ	10$				;NO, SKIP
	INSQUE	(R2),@4(R5)			;INSERT ENTRY AT TAIL OF TABLE
	BRB	20$				;SKIP
10$:	INSQUE	(R2),(R5)			;INSERT ENTRY AT HEAD OF TABLE

;
; INITIALIZE THE DYNAMICALLY PLACED ASCIC FIELDS.
;
20$:	MOVQ	12(SP),R3			;GET SYMBOL NAME
	MOVB	R3,SYM_T_SYMBOL(R2)		;INSERT LENGTH OF SYMBOL
	MOVC	R3,(R4),SYM_T_SYMBOL+1(R2) 	;INSERT SYMBOL NAME
	CMPB	#SYM_K_BINARY,(SP)		;BINARY VALUE
	BNEQ	30$				;NO, THEN SKIP
	MOVL	4(SP),(R3)+			;INSERT THE VALUE
	BRB	40$				;SKIP
30$:	MOVW	4(SP),(R3)+			;INSERT LENGTH OF VALUE
	MOVC	4(SP),@8(SP),(R3)		;INSERT SYMBOL VALUE
40$:	POPR	#^M<R0,R1,R2,R3,R4>		;RESTORE THE REGISTERS
	MOVL	#1,R0				;SET SUCCESS INDICATOR
	RSB					;

;
; RETURN SYMBOL TABLE OVERFLOW STATUS.
;
90$:	POPR	#^M<R0,R1,R2,R3,R4>		;RESTORE THE REGISTERS
	STATUS	SYMOVF				;SET SYMBOL TABLE OVERFLOW STATUS
	RSB

	.SBTTL	DELETE SYMBOL FROM SYMBOL TABLE
;+
; DCL$DELSYM - DELETE SYMBOL FROM SYMBOL TABLE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO DELETE EITHER A
; SPECIFIC SYMBOL OR ALL SYMBOLS FROM A SPECIFIED SYMBOL TABLE.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED SYMBOL,IF IT EXISTS, IS DELETED,
;		ELSE NO SUCH SYMBOL IS RETURNED;
;	OR THE ENTIRE CONTENTS OF THE SPECIFIED TABLE IS DELETED.
;	PERMANENT SYMBOLS ARE NEVER DELETED.
;-
 
DCL$DELSYM::				; DELETE SYMBOL FROM TABLE
	MOVAQ	PRC_Q_LOCAL(R11),R7	; ASSUME DELETING A SPECIFIC SYMBOL
	CLRL	R8			; FROM THE LOC. TABLE WITH /NOLOG
	MOVAB	LOCTAB,R9		;
10$:	BSBW	DCL$GETDVAL		; GET NEXT RESULT DESCRIPTOR
	CMPB	#PTR_K_ENDLINE,R5	; IS THIS THE END OF THE LINE?
	BEQL	30$			; BR IF YES
	CMPB	#PTR_K_PARAMETR,R5	; IS THIS A PARAMETER?
	BEQL	30$			; BR IF YES
	CMPB	#PTR_K_COMDQUAL,R5	; IS THIS A QUALIFIER?
	BNEQ	10$			; BR IF NO
	BSBW	DCL$GETNVAL		; GET QUALIFIER NUMBER
	CMPB	R1,#CLI$K_DLSY_ALL	; /ALL?
	BEQL	20$			; BR IF ALL
	CMPB	R1,#CLI$K_DLSY_LOCA	; /LOCAL?
	BEQL	15$			; BR IF LOCAL TABLE
	CMPB	R1,#CLI$K_DLSY_GLOB	; /GLOBAL?
	BEQL	12$			; BR IF GLOBAL TABLE
	CMPB	R1,#CLI$K_DLSY_LOG	; /LOG?
	BNEQ	10$			; IF NOT, IGNORE
	BICB	#1,R8			; ASSUME /NOLOG
	BLBS	R3,10$			; IT IS /NOLOG. FLAG OK AS IS
	BISB	#1,R8			; IT IS /LOG. SET FLAG ACCORDINGLY
	BRB	10$			; BR FOR MORE
12$:	MOVAQ	PRC_Q_GLOBAL(R11),R7	; SET PROPER TABLE ADDRESS
	MOVAB	GBLTAB,R9		; SET GLOBAL STRING ADDR. FOR /LOG MESS.
	BRB	10$			; BR FOR MORE
15$:	MOVAQ	PRC_Q_LOCAL(R11),R7	; MAKE SURE TABLE ADDRESS IS CORRECT
	MOVAB	LOCTAB,R9		; SET LOCAL STRING ADDR. FOR /LOG MESS.
	BRB	10$			;
20$:	BISB	#2,R8			; SET DOING ALL FLAG
	BRB	10$			;
30$:	BBS	#1,R8,50$		; BR IF DOING ALL
	MOVL	R7,R0			; SET TABLE ADDRESS
	BSBW	DCL$SEARCHT		; SEARCH THE TABLE FOR THE SYMBOL
	BLBC	R0,40$			; DEALLOCTE
	BSBB	55$			; TEST AND DEALLOCATE
	BRB	70$			;
40$:	STATUS	UNDSYM			; NO SUCH SYMBOL
	RSB				; EXIT WITH ERROR STATUS
50$:	MOVL	(R7),R3			; GET ADDRESS OF NEXT SYMBOL
	CMPL	R7,R3			; DONE?
	BEQL	70$			; BR IF YES
	PUSHAB	50$			; RETURN ADDRESS FOR DEALLOCATE
55$:	CMPB	SYM_B_TYPE(R3),#SYM_K_PERM ; PERMANENT SYMBOL?
	BEQL	60$			; BR IF YES - DON'T DEALLOCATE IT
	BLBC	R8,59$			; SKIP IF /NOLOG
	PUSHAB	SYM_T_SYMBOL(R3)	; GET SYMBOL NAME
	PUSHL	R9			; SET GLOBAL/LOCAL ASCIC ADDR.
	MOVL	#2,R1			; SET FAO COUNT TO 2
	MOVL	#CLI$_DELSYM,R0		; SET MESSAGE STATUS
	BSBW	DCL$FORMMSG		; OUTPUT THE MESSAGE
59$:	BRW	DCL$DEALLOCSYM		; DEALLOCATE IT
60$:	TSTL	(SP)+			; CLEAR INTERMEDIATE RETURN
70$:	STATUS	NORMAL			;
	RSB
 
	.END
