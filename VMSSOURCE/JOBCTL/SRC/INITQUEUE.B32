MODULE INITQUEUE(%TITLE	'Initialize system job queue file'
		IDENT = 'V04-001'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Job controller.
!
! ABSTRACT:
!	This module contains the routines that initialize and validate the
!	system job queue file.
!
! ENVIRONMENT:
!	VAX/VMS user and kernel mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 16-Feb-1982
!
! MODIFIED BY:
!
!
!	V04-001	JAK0236		J A Krycka	14-Sep-1984
!		Collect more diagnostic information.
!
! 	V03-018	KPL0001		P Lieberwirth,	22-Jul-1984
!		Add COLD_START_CURRENT_LIST routine to detect and repair
!		SMQ current list corruption.  Rework WARM_START_EXISTING_FILE
!		to be tolerant of system failures.
!
!	V03-017	JAK0221		J A Krycka	16-Jul-1984
!		Always open the queue file shared (retract V03-013) because
!		non-shared access effectively disables use of the process-local
!		I/O buffer cache.
!
!	V03-016	JAK0219		J A Krycka	13-Jul-1984
!		Use the SJC$_BUFFER_COUNT and SJC$_EXTEND_QUANTITY items for the
!		SJC$_START_QUEUE_MANAGER function to override default values for
!		the MBF and ALQ fields during RMS operations on the queue file.
!		(These correspond to the /BUFFER_COUNT and /EXTEND_QUANTITY
!		qualifiers on the START/QUEUE/MANAGER command.)
!
!	V03-015	JAK0213		J A Krycka	18-May-1984
!		Use newly created LCK$M_NODLCKBLK (no deadlock on blocking AST)
!		option on enqueue service calls that specify a blocking AST
!		routine that will immediately relinquish the lock.
!
!	V03-014	JAK0212		J A Krycka	15-May-1984
!		Examine timer queue on warm start of the job queue file.
!
!	V03-013	JAK0211		J A Krycka	14-May-1984
!		Continuation of V03-012.
!
!	V03-012	JAK0210		J A Krycka	10-May-1984
!		If this node is not part of a cluster or the job queue file is
!		not on a cluster-wide accessible device, then reopen the queue
!		file for non-shared access (SHR=UPI) to avoid having RMS take
!		out locks on records in the local buffer cache.
!
!	V03-011	JAK0209		J A Krycka	08-May-1984
!		Display JBC$_STRUCT_LEVEL message if structure level of existing
!		queue file is incompatible with job controller implementation.
!		Also, log diagnostic information in DIAG_TRACE vector.
!
!	V03-010	JAK0202		J A Krycka	16-Apr-1984
!		Update selected queue file creation parameters.
!
!	V03-009	JAK0201		J A Krycka	10-Apr-1984
!		Use LCK$M_NODLCKWT (no deadlock wait) option on enqueue service
!		for the master queue file lock to avoid having the lock manager
!		declare a deadlock situation.
!
!	V03-008	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Implement page setup.
!
!	V03-007	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!	V03-006	MLJ0114		Martin L. Jack,	23-Jun-1983
!		Changes for job controller baselevel.
!
!	V03-005	MLJ0113		Martin L. Jack,	26-May-1983
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0112		Martin L. Jack,	29-Apr-1983
!		Changes for job controller baselevel.
!
!	V03-003	MLJ0111		Martin L. Jack,	20-Apr-1983
!		Correct another problem in warm start.
!
!	V03-002	MLJ0110		Martin L. Jack,	18-Apr-1983
!		Correct problem in warm start and missing test for unwind.
!
!	V03-001	MLJ0109		Martin L. Jack,	14-Apr-1983
!		Changes for job controller baselevel.
!
!**

REQUIRE 'SRC$:JOBCTLDEF';


LINKAGE
	L_TREE = CALL: GLOBAL(RTM=10, SQH=11);


FORWARD ROUTINE
	REFERENCE_ENTRY_NUMBER:		L_TREE NOVALUE,
	ENQUEUE:			L_TREE NOVALUE,
	TREE:				L_TREE NOVALUE,
	COLD_START_CURRENT_LIST:	NOVALUE,
	COLD_START_EXISTING_FILE:	NOVALUE,
	COLD_START_NEW_FILE:		NOVALUE,
	WARM_START_EXISTING_FILE:	NOVALUE,
	INITIALIZE_QUEUE_FILE_HANDLER,
	INITIALIZE_QUEUE_FILE;


EXTERNAL ROUTINE
	AFTER_AST:			NOVALUE,
	COMPLETE_JOB:			NOVALUE,
	DEALLOCATE_MEMORY:		NOVALUE,
	DELETE_SJH_RECORD:		NOVALUE,
	ENQUEUE_JOB:			L_OUTPUT_2 NOVALUE,
	FLUSH_RECORD:			NOVALUE,
	JOB_SCHEDULING_POLICY,
	LOCK_QUEUE_FILE:		NOVALUE,
	QUEUE_MASTER_AST:		NOVALUE,
	READ_RECORD,
	RELEASE_RECORD:			NOVALUE,
	REMOTE_BLOCKING_AST:		NOVALUE,
	REWRITE_RECORD:			NOVALUE,
	SCAN_INCOMPLETE_SERVICES:	NOVALUE,
	SIGNAL_FILE_ERROR:		NOVALUE,
	UPDATE_GETQUI_DATA:		NOVALUE,
	WRITE_ACCOUNTING_RECORD:	NOVALUE;


BIND

	! KBF values for known block numbers.
	!
	SQH_KBF=	UPLIT(1),
	SFM_KBF=	UPLIT(2),	! Initial form definition
	SFX_KBF=	UPLIT(3);	! Initial form index block


MACRO

	! Structure of TYPE parameter to TREE routine.
	!
	B_TYPE=		0,0,8,0 %,	! Expected record type
	V_NO_MARK=	0,8,1,0 %,	! Inhibit entering in record type map
	V_NO_QUEUE=	0,9,1,0 %,	! Inhibit enqueuing jobs
	V_NO_TRAVERSE=	0,10,1,0 %,	! Inhibit traversing list
	V_SMQ_P2=	0,11,1,0 %,	! SMQ pass 2
	V_SMQ_P3=	0,12,1,0 %;	! SMQ pass 3


LITERAL
	M_NO_MARK=	$FIELDMASK(V_NO_MARK),
	M_NO_QUEUE=	$FIELDMASK(V_NO_QUEUE),
	M_NO_TRAVERSE=	$FIELDMASK(V_NO_TRAVERSE),
	M_SMQ_P2=	$FIELDMASK(V_SMQ_P2),
	M_SMQ_P3=	$FIELDMASK(V_SMQ_P3);


BUILTIN
	EDIV,
	TESTBITSC,
	TESTBITSS;

ROUTINE REFERENCE_ENTRY_NUMBER(ENTRY_NUMBER): L_TREE NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine notes a reference to an entry number during the cold start
!	of an existing file.
!
! INPUT PARAMETERS:
!	ENTRY_NUMBER	- Entry number.
!
! IMPLICIT INPUTS:
!	SQH		- Pointer to SQH.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
EXTERNAL REGISTER
	SQH = 11:	REF BBLOCK;	! Pointer to SQH
LOCAL
	BIT_NUMBER;			! Normalized entry number


! Range check the entry number.
!
IF .ENTRY_NUMBER EQLU 0
OR .ENTRY_NUMBER GTRU .SQH[SQH$L_HIGHEST_ENTRY_NUMBER]
THEN
    RETURN;


! Normalize the entry number to a bit number.  If it lies in the queue
! header, set it there.  Otherwise, convert it to an extension bitmap
! block offset and bit number and set it there.
!
BIT_NUMBER = .ENTRY_NUMBER - 1;
IF .BIT_NUMBER LSSU SQH$S_ENTRY_BITMAP * 8
THEN
    BITVECTOR[SQH[SQH$B_ENTRY_BITMAP], .BIT_NUMBER] = TRUE
ELSE
    BEGIN
    LOCAL
	BLOCK_NUMBER,			! Offset in bitmap vector
	Q:		VECTOR[2],	! Temporary for EDIV
	SEB_N,				! Record number of extension bitmap
	SEB:		REF BBLOCK;	! Pointer to extension bitmap


    Q[0] = .BIT_NUMBER - SQH$S_ENTRY_BITMAP * 8;
    Q[1] = 0;
    EDIV(%REF(SYM$S_DATA * 8), Q, BLOCK_NUMBER, BIT_NUMBER);
    IF .BLOCK_NUMBER LSSU SQH$S_ENTRY_BITMAP_VECTOR/4
    THEN
	BEGIN
	SEB_N = .VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .BLOCK_NUMBER];
	IF .SEB_N NEQ 0
	THEN
	    BEGIN
	    SEB = READ_RECORD(.SEB_N);
	    BITVECTOR[SEB[SYM$T_DATA], .BIT_NUMBER] = TRUE;
	    REWRITE_RECORD(.SEB_N);
	    END;
	END;
    END;
END;

ROUTINE ENQUEUE(SMQ,SJH_N,SJH): L_TREE NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine enqueues a job during the cold start of an existing file.
!
! INPUT PARAMETERS:
!	SMQ		- Pointer to job's SMQ.
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	SQH		- Pointer to SQH.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	SJH:		REF BBLOCK;	! Pointer to SJH
EXTERNAL REGISTER
	SQH = 11:	REF BBLOCK;	! Pointer to SQH


! Reinitialize the forward link.
!
SJH[SYM$L_LINK] = 0;


! If appropriate, enter the job on the hold queue.
!
IF .SJH[SJH$V_HOLDING]
OR .SJH[SJH$V_REFUSED]
OR .SJH[SJH$V_RETAINED]
THEN
    BEGIN
    LOCAL
	SJH_NP,				! Record number of predecessor of SJH
	SJH_P:		REF BBLOCK;	! Pointer to predecessor of SJH


    IF .SMQ[SMQ$L_HOLD_LIST] EQL 0
    THEN
	SMQ[SMQ$L_HOLD_LIST] = .SJH_N
    ELSE
	BEGIN
	SJH_P = READ_RECORD(SJH_NP = .SMQ[SMQ$L_HOLD_LIST_END]);
	SJH_P[SYM$L_LINK] = .SJH_N;
	REWRITE_RECORD(.SJH_NP);
	END;	
    SMQ[SMQ$L_HOLD_LIST_END] = .SJH_N;
    END


! Enter the job on the pending or timer queue, as appropriate.
!
ELSE
    BEGIN
    LOCAL
	TIMER_QUEUE,			! True if entering on timer queue
	LIST_HEAD:	REF VECTOR,	! Pointer to appropriate list head
	SJH_NP,				! Record number of precedessor of SJH
	SJH_P:		REF BBLOCK,	! Pointer to predecessor of SJH
	SJH_NS,				! Record number of successor of SJH
	SJH_S:		REF BBLOCK;	! Pointer to successor of SJH


    ! Establish the queue on which the job should be entered and increase
    ! the reference count.
    !
    IF TIME_GTRU(SJH[SJH$Q_AFTER_TIME], CUR_TIME)
    THEN
	BEGIN
	TIMER_QUEUE = TRUE;
	LIST_HEAD = SQH[SQH$L_TIMER_LIST];
	SMQ[SMQ$W_TIMER_JOB_COUNT] = .SMQ[SMQ$W_TIMER_JOB_COUNT] + 1;
	END
    ELSE
	BEGIN
	TIMER_QUEUE = FALSE;
	IF .SMQ[SMQ$V_BATCH]
	    THEN LIST_HEAD = SQH[SQH$L_PENDING_BATCH_LIST]
	    ELSE LIST_HEAD = SQH[SQH$L_PENDING_PRINT_LIST];
	SMQ[SMQ$W_PENDING_JOB_COUNT] = .SMQ[SMQ$W_PENDING_JOB_COUNT] + 1;
	END;


    ! Check for the special case that the job goes at the end.
    !
    IF .LIST_HEAD[1] NEQ 0
    THEN
	BEGIN
	SJH_S = READ_RECORD(SJH_NS = .LIST_HEAD[1]);
	IF
	    BEGIN
	    IF .TIMER_QUEUE
		THEN TIME_GEQU(SJH[SJH$Q_AFTER_TIME], SJH_S[SJH$Q_AFTER_TIME])
		ELSE JOB_SCHEDULING_POLICY(.SMQ, .SJH_S, .SJH)
	    END
	THEN
	    BEGIN
	    SJH_S[SYM$L_LINK] = .SJH_N;
	    LIST_HEAD[1] = .SJH_N;
	    REWRITE_RECORD(.SJH_NS);
	    RETURN;
	    END;
	END;


    ! Search for the correct insertion point.
    !
    SJH_NP = SQH$K_RECNO;
    SJH_P = .SQH;
    SJH_NS = .LIST_HEAD[0];
    WHILE .SJH_NS NEQ 0 DO
	BEGIN
	SJH_S = READ_RECORD(.SJH_NS);
	IF
	    BEGIN
	    IF .TIMER_QUEUE
		THEN TIME_GTRU(SJH_S[SJH$Q_AFTER_TIME], SJH[SJH$Q_AFTER_TIME])
		ELSE JOB_SCHEDULING_POLICY(.SMQ, .SJH, .SJH_S)
	    END
	THEN
	    BEGIN
	    RELEASE_RECORD(.SJH_NS);
	    EXITLOOP;
	    END;
	IF .SJH_NP NEQ SQH$K_RECNO THEN RELEASE_RECORD(.SJH_NP);
	SJH_NP = .SJH_NS;
	SJH_P = .SJH_S;
	SJH_NS = .SJH_S[SYM$L_LINK];
	END;


    ! Enqueue the job at the correct insertion point.
    !
    IF .SJH_NP EQL SQH$K_RECNO
    THEN
	LIST_HEAD[0] = .SJH_N
    ELSE
	BEGIN
	SJH_P[SYM$L_LINK] = .SJH_N;
	REWRITE_RECORD(.SJH_NP);
	END;
    SJH[SYM$L_LINK] = .SJH_NS;
    IF .SJH_NS EQL 0 THEN LIST_HEAD[1] = .SJH_N;
    END;
END;

ROUTINE TREE(RECNO,TYPE,DEL,P1): L_TREE NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine recursively processes a record tree during the cold start
!	of an existing file.
!
! INPUT PARAMETERS:
!	RECNO		- Record number.
!	TYPE		- Expected record type and control flags.
!	DEL		- True if this subtree is being deleted.
!	P1		- Function-dependent parameter.
!
! IMPLICIT INPUTS:
!	SQH		- Pointer to SQH.
!	RTM		- Pointer to record type map.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	TYPE:		BBLOCK;		! Control flags
EXTERNAL REGISTER
	RTM = 10:	REF VECTOR[,BYTE,SIGNED], ! Record type map
	SQH = 11:	REF BBLOCK;	! Pointer to SQH
LOCAL
	REC_N;				! Current record number


MACRO

	! Process extension records linked to a variable data area.
	!
	MARK_VARIABLE_DATA(LENGTH,ADDRESS,TYPE,DELETE)=
	    BEGIN
	    IF .BBLOCK[ADDRESS, FVDF_LENGTH] GTRU (LENGTH - 2)
	    THEN
		TREE(
		    .BBLOCK[ADDRESS, FVDF_LINK],
		    TYPE,
		    DELETE);
	    END %,


	! Check that a link to another record is either zero or valid.
	!
	VALIDATE_OPTIONAL_LINK(RECNO,TYPE)=
	    BEGIN
	    IF (RECNO) NEQ 0
	    THEN
		VALIDATE_REQUIRED_LINK(RECNO,TYPE);
	    END %,


	! Check that a link to another record contains a valid record number
	! and that the record is of the correct type.
	!
	VALIDATE_REQUIRED_LINK(RECNO,TYPE)=
	    BEGIN
	    IF
		BEGIN
		IF (RECNO) LSSU 2
		OR (RECNO) GTRU .SQH[SQH$L_HIGHEST_RECORD]
		THEN
		    TRUE
		ELSE
		    .RTM[(RECNO)-1] NEQ (TYPE)
		END
	    THEN
		SIGNAL(JBC$_QUEFORMAT);
	    END %;


! Loop over all records in the list.
!
REC_N = .RECNO;
WHILE .REC_N NEQ 0 DO
    BEGIN
    LOCAL
	REC:		REF BBLOCK,	! Pointer to current record
	MODIFIED,			! True if record modified
	DELETE,				! True if record should be deleted
	REC_NS;				! Record number of successor


    DIAG_TRACE[9] = .REC_N;		! ***** diagnostic info *****
    ! Range check the record number.
    !
    IF .REC_N LSSU 2
    OR .REC_N GTRU .SQH[SQH$L_HIGHEST_RECORD]
    THEN
	SIGNAL(JBC$_QUEFORMAT);


    ! Read the record and initialize to process it.
    !
    REC = READ_RECORD(.REC_N);
    MODIFIED = FALSE;
    DELETE = .DEL;
    REC_NS = .REC[SYM$L_LINK];


    ! Check the record type.
    !
    IF .REC[SYM$B_TYPE] NEQ .TYPE[B_TYPE]
    THEN
	SIGNAL(JBC$_QUEFORMAT);


    ! Unless this action is inhibited, note the record type in the record type
    ! map and check for multiply allocated records.
    !
    IF NOT .TYPE[V_NO_MARK]
    THEN
	BEGIN
	IF .RTM[.REC_N-1] GEQ 0 THEN SIGNAL(JBC$_QUEFORMAT);
	RTM[.REC_N-1] = .REC[SYM$B_TYPE];
	END;


    ! Dispatch to type-dependent processing.
    !
    CASE .REC[SYM$B_TYPE] FROM SYM$K_SCX TO SYM$K_REFUSAL_REASON OF
	SET


	[INRANGE, OUTRANGE]:
	    0;


	[SYM$K_SFM]:
	    BEGIN

	    ! Traverse substructures of the form record.
	    !
	    MARK_VARIABLE_DATA(
		SFM$S_FORM_SETUP_MODULES, REC[SFM$T_FORM_SETUP_MODULES],
		SYM$K_FORM_SETUP_MODULES, FALSE);
	    MARK_VARIABLE_DATA(
		SFM$S_PAGE_SETUP_MODULES, REC[SFM$T_PAGE_SETUP_MODULES],
		SYM$K_PAGE_SETUP_MODULES, FALSE);
	    END;


	[SYM$K_SFX]:
	    BEGIN
	    LOCAL
		SFE:		REF BBLOCK;	! Pointer to SFE

	    SFE = REC[SYM$T_DATA];
	    INCR SFE_N FROM 0 TO SFX$K_ENTRIES-1 DO
		BEGIN
		IF CH$RCHAR(SFE[SFX$T_NAME]) EQL 0
		THEN
		    EXITLOOP
		ELSE
		    BEGIN
		    TREE(.SFE[SFX$L_FORM_LINK], SYM$K_SFM, FALSE);
		    SFE = .SFE + SFX$S_SFX;
		    END;
		END;
	    END;


	[SYM$K_SQX]:
	    BEGIN
	    LOCAL
		T:		BBLOCK[4],	! Local type
		SQE:		REF BBLOCK;	! Pointer to SQE

	    T = .TYPE;  T[B_TYPE] = SYM$K_SMQ;
	    SQE = REC[SYM$T_DATA];
	    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
		BEGIN
		IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
		THEN
		    EXITLOOP
		ELSE
		    BEGIN
		    TREE(.SQE[SQX$L_QUEUE_LINK], .T, FALSE);
		    SQE = .SQE + SQX$S_SQX;
		    END;
		END;
	    END;


	[SYM$K_SMQ]:
	    BEGIN

	    ! Third queue header pass.  This pass traverses the current
	    ! list, which must occur on a pass after the hold list because
	    ! failed jobs that are retained are enqueued to the hold list.
	    !
	    IF .TYPE[V_SMQ_P3]
	    THEN
		BEGIN
		TREE(.REC[SMQ$L_CURRENT_LIST], SYM$K_SJH, FALSE);
		REC[SMQ$L_CURRENT_LIST] = 0;
		REC[SMQ$L_CURRENT_LIST_END] = 0;
		END


	    ! Second queue header pass.  This pass traverses all substructures
	    ! except the current list.
	    !
	    ELSE IF .TYPE[V_SMQ_P2]
	    THEN
		BEGIN
		VALIDATE_OPTIONAL_LINK(
		    .REC[SMQ$L_ASSIGNED_QUEUE_LINK], SYM$K_SMQ);
		VALIDATE_OPTIONAL_LINK(
		    .REC[SMQ$L_FORM_LINK], SYM$K_SFM);
		TREE(.REC[SMQ$L_GENERIC_TARGET], SYM$K_GENERIC_TARGET, FALSE);
		TREE(.REC[SMQ$L_HOLD_LIST], SYM$K_SJH OR M_NO_QUEUE, FALSE);
		MARK_VARIABLE_DATA(
		    SMQ$S_JOB_RESET_MODULES, REC[SMQ$T_JOB_RESET_MODULES],
		    SYM$K_JOB_RESET_MODULES, FALSE);
		END


	    ! First queue header pass.  This reinitializes fields and notes
	    ! the record number.
	    !
	    ELSE
		BEGIN
		REC[SMQ$L_STATUS] = 0;
		REC[SMQ$V_STOPPED] = TRUE;
		CLEAR_TIME(REC[SMQ$Q_ACM_BEGTIM]);
		REC[SMQ$L_ACM_GETCNT] = 0;
		REC[SMQ$L_ACM_PAGECNT] = 0;
		REC[SMQ$L_ACM_QIOCNT] = 0;
		REC[SMQ$L_ACM_SYMCPUTIM] = 0;
		REC[SMQ$L_STREAM_SCT] = 0;
		REC[SMQ$W_OPEN_JOB_COUNT] = 0;
		REC[SMQ$W_PENDING_JOB_COUNT] = 0;
		REC[SMQ$W_TIMER_JOB_COUNT] = 0;
		REC[SMQ$B_CURRENT_JOB_COUNT] = 0;
		REC[SMQ$B_STREAM_INDEX] = 0;
		END;


	    MODIFIED = TRUE;
	    END;


	[SYM$K_SJH]:
	    BEGIN
	    LOCAL
		SMQ_N,				! Record number of job's SMQ
		SMQ:		REF BBLOCK;	! Pointer to job's SMQ


	    ! Validate the job's SMQ pointer and read the record.
	    !
	    SMQ_N = .REC[SJH$L_QUEUE_LINK];
	    VALIDATE_REQUIRED_LINK(.SMQ_N, SYM$K_SMQ);
	    SMQ = READ_RECORD(.SMQ_N);


	    ! If the job was executing, write an accounting record and
	    ! determine whether it is to be deleted, requeued, or retained.
	    !
	    IF .REC[SJH$V_EXECUTING]
	    THEN
		BEGIN
		IF NOT .REC[SJH$V_RESTART]
		THEN
		    IF NOT .SMQ[SMQ$V_RETAIN_ALL_JOBS]
		    AND NOT .SMQ[SMQ$V_RETAIN_ERROR_JOBS]
		    THEN
			DELETE = TRUE
		    ELSE
			REC[SJH$V_RETAINED] = TRUE;


		REC[SJH$V_RESTARTING] = TRUE;
		REC[SJH$L_CONDITION_1] = JBC$_SYSFAIL OR STS$K_ERROR;
		REC[SJH$L_CONDITION_2] = 0;
		REC[SJH$L_CONDITION_3] = 0;
		WRITE_ACCOUNTING_RECORD(
		    .REC, .SMQ,
		    0,
		    .REC[SJH$L_CONDITION_1]);
		END;


	    ! Reinitialize fields of the job header.
	    !
	    REC[SJH$L_CURRENT_FILE_LINK] = 0;
	    REC[SJH$V_ABORTED] = FALSE;
	    REC[SJH$V_ABORTING] = FALSE;
	    REC[SJH$V_EXECUTING] = FALSE;
	    REC[SJH$V_FILE_STARTING] = FALSE;
	    REC[SJH$V_OPEN] = FALSE;
	    REC[SJH$V_REQUEUE] = FALSE;
	    REC[SJH$V_REQUEUE_HOLD] = FALSE;
	    REC[SJH$V_STARTING] = FALSE;
	    REC[SJH$V_SYNCHRONIZE] = FALSE;
	    REC[SJH$V_SYSTEM_FAILURE] = FALSE;
	    REC[SJH$L_EXECUTOR_PID] = 0;
	    REC[SJH$L_REQUEUE_QUEUE_LINK] = 0;
	    REC[SJH$B_REQUEUE_PRIORITY] = 0;	    


	    ! Traverse substructures of the job header.
	    !
	    MARK_VARIABLE_DATA(
		SJH$S_CHECKPOINT, REC[SJH$T_CHECKPOINT],
		SYM$K_CHECKPOINT, .DELETE);
	    TREE(.REC[SJH$L_FILE_LIST], SYM$K_SQR, .DELETE);
	    VALIDATE_OPTIONAL_LINK(
		.REC[SJH$L_FORM_LINK], SYM$K_SFM);
	    VALIDATE_OPTIONAL_LINK(
		.REC[SJH$L_LOG_QUEUE_LINK], SYM$K_SMQ);
	    MARK_VARIABLE_DATA(
		SJH$S_LOG_SPECIFICATION, REC[SJH$T_LOG_SPECIFICATION],
		SYM$K_LOG_SPECIFICATION, .DELETE);
	    MARK_VARIABLE_DATA(
		SJH$S_NOTE, REC[SJH$T_NOTE],
		SYM$K_NOTE, .DELETE);
	    MARK_VARIABLE_DATA(
		SJH$S_OPERATOR_REQUEST, REC[SJH$T_OPERATOR_REQUEST],
		SYM$K_OPERATOR_REQUEST, .DELETE);
	    MARK_VARIABLE_DATA(
		SJH$S_PARAMETERS, REC[SJH$T_PARAMETERS],
		SYM$K_PARAMETERS, .DELETE);
	    MARK_VARIABLE_DATA(
		SJH$S_REFUSAL_REASON, REC[SJH$T_REFUSAL_REASON],
		SYM$K_REFUSAL_REASON, .DELETE);


	    ! If the job is not to be deleted, reference the entry number and
	    ! enqueue the job.
	    !
	    IF .DELETE
	    THEN
		RELEASE_RECORD(.SMQ_N)
	    ELSE
		BEGIN
		REFERENCE_ENTRY_NUMBER(.REC[SYM$L_ENTRY_NUMBER]);
		IF NOT .TYPE[V_NO_QUEUE] THEN ENQUEUE(.SMQ, .REC_N, .REC);
		REWRITE_RECORD(.SMQ_N);
		END;


	    MODIFIED = TRUE;
	    END;


	[SYM$K_SQR]:
	    BEGIN

	    ! Traverse substructures of the file record.
	    !
	    MARK_VARIABLE_DATA(
		SQR$S_FILE_SETUP_MODULES, REC[SQR$T_FILE_SETUP_MODULES],
		SYM$K_FILE_SETUP_MODULES, .DELETE);
	    END;


	[SYM$K_ENTRY_BITMAP]:
	    BEGIN

	    ! Reinitialize the bitmap.
	    !
	    CH$FILL(0, SYM$S_DATA, REC[SYM$T_DATA]);
	    MODIFIED = TRUE;
	    END;


	[SYM$K_GENERIC_TARGET]:
	    BEGIN

	    ! Validate count.
	    !
	    IF .VECTOR[REC[SYM$T_DATA], 0] GTRU 124
	    THEN
		VECTOR[REC[SYM$T_DATA], 0] = 124;


	    ! Validate queue pointers.
	    !
	    INCR N FROM 1 TO .VECTOR[REC[SYM$T_DATA], 0] DO
		BEGIN
		VALIDATE_REQUIRED_LINK(
		    .VECTOR[REC[SYM$T_DATA], .N], SYM$K_SMQ);
		END;
	    END;


	TES;


    ! If the record is to be deleted, link it to the free list.
    !
    IF .DELETE
    THEN
	BEGIN
	RTM[.REC_N-1] = 0;
	CH$COPY(4, SQH[SQH$L_FREE_LIST], 0, SYM$S_SYM, .REC);
	SQH[SQH$L_FREE_LIST] = .REC_N;
	MODIFIED = TRUE;
	END;


    ! If the record was modified, write it back; otherwise release it.
    !
    IF .MODIFIED
	THEN REWRITE_RECORD(.REC_N)
	ELSE RELEASE_RECORD(.REC_N);


    ! Advance to next record.
    !
    IF .TYPE[V_NO_TRAVERSE] THEN EXITLOOP;
    REC_N = .REC_NS;
    END;
END;

ROUTINE COLD_START_CURRENT_LIST: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine scans each executor queue's CURRENT_LIST looking
!	for deallocated SJH records.  If any are found they are unlinked
!	from the CURRENT_LIST.
!
!	This routine is called just before the third pass of the queue
!	index list.
!
! INPUT PARAMETERS:
!	None.
!
! IMPLICIT INPUTS:
!	None.
!
! OUTPUT PARAMETERS:
!	None.
!
! IMPLICIT OUTPUTS:
!	None.
!
! ROUTINE VALUE:
!	None.
!
! SIDE EFFECTS:
!	None.
!
!--

BEGIN

LOCAL
	SQX_N,				! Record Number of Queue Index
	SQH:	REF BBLOCK;		! Queue Header Record

! Read queue header record.
!
SQH = READ_RECORD(SQH$K_RECNO);

! Validate each Queue's CURRENT_LIST.
!
SQX_N = .SQH[SQH$L_QUEUE_INDEX_LIST];
WHILE .SQX_N NEQ 0 DO
    BEGIN

    LOCAL
	    SQX_NS,			! Successor of Queue Index
	    SQX:	REF BBLOCK,	! Queue Index Record
	    SQE_N,			! Queue Entry Number
	    SQE:	REF BBLOCK;	! Queue Entry

    ! Read the queue index record.
    !
    SQX = READ_RECORD(.SQX_N);


    ! Scan the queue index record.
    !
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    IF .SQE[SQX$V_EXECUTOR]
	    THEN
		BEGIN

		LOCAL
			SMQ:	REF BBLOCK,	! Queue Record
			SMQ_N;			! Queue Record Number
			
		SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);
		
		! Scan the current list.  Verify that any jobs on the list
		! have valid back pointers to the SMQ record.  Unlink any
		! that does not.
		!
		IF .SMQ[SMQ$L_CURRENT_LIST] NEQ 0
		THEN
		    BEGIN
		    LOCAL
			    SJH:	REF BBLOCK,	! Job Record
			    SJH_N,			! " Number
			    SJH_P:	REF BBLOCK,	! Predecessor
			    SJH_NP;			! "" Record Number

		    ! Initialize predecessor to SMQ.
		    !
		    SJH_NP = .SMQ_N;
		    SJH_P = .SMQ;

		    SJH_N = .SMQ[SMQ$L_CURRENT_LIST];
		    WHILE .SJH_N NEQ 0 DO
			BEGIN

			! Verify each SJH.
			!
			SJH = READ_RECORD(.SJH_N);
			IF .SJH[SJH$L_QUEUE_LINK] EQL 0
			THEN
			    BEGIN

			    ! Unlink deallocated SJH from CURRENT_LIST.
			    !
			    IF .SJH_NP EQL .SMQ
			    THEN
				BEGIN

				! Predecessor is SMQ.
				!
				SMQ[SMQ$L_CURRENT_LIST] = 0;
				SMQ[SMQ$L_CURRENT_LIST_END] = 0;
				FLUSH_RECORD(.SMQ_N);
				END
			    ELSE
				BEGIN

				! Predecessor is previous SJH.  First update
				! SMQ's current list end, then unlink bad SJH.
				!
				SMQ[SMQ$L_CURRENT_LIST_END] = .SJH_NP;
				FLUSH_RECORD(.SMQ_N);
				SJH_P[SYM$L_LINK] = 0;
				FLUSH_RECORD(.SJH_NP);
				END;

			    EXITLOOP;
			    END;

			! Set up for next iteration.  Current SJH becomes
			! predecessor, next SJH read will be successor of
			! current SJH, if one exists.
			!
			SJH_P = .SJH;
			SJH_NP = .SJH_N;
			SJH_N = .SJH_P[SYM$L_LINK];
			END
		    END
		ELSE
		    RELEASE_RECORD(.SMQ_N);
		END;
	    END;


	SQE = .SQE + SQX$S_SQX;
	END;


    ! Advance to the next index block.
    !
    SQX_NS = .SQX[SYM$L_LINK];
    RELEASE_RECORD(.SQX_N);
    SQX_N = .SQX_NS;
    END;
END;

ROUTINE COLD_START_EXISTING_FILE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reinitializes an existing queue file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	HIGHEST_ENTRY_NUMBER,		! Expected highest entry number
	HIGHEST_ENTRY_OFFSET,		! Highest nonzero bitmap slot
	FREE_N,
	BUFFER:			BBLOCK[SYM$S_SYM],
	BITMAP_RETADR:		VECTOR[2],
	SAVED_PENDING_BATCH_LIST,
	SAVED_PENDING_PRINT_LIST,
	SAVED_TIMER_LIST,
	STATUS;
GLOBAL REGISTER
	RTM = 10:		REF VECTOR[,BYTE,SIGNED],
	SQH = 11:		REF BBLOCK;


! Allocate and initialize the record type map.  This vector records the
! record type of each record encountered.  It is initially -1, so that
! multiply allocated and lost records can be readily distinguished.
!
STATUS = $EXPREG(
    PAGCNT=(.QUEUE_FAB[FAB$L_ALQ] + 511) ^ -9,
    RETADR=BITMAP_RETADR);
IF NOT .STATUS THEN SIGNAL(JBC$_ALLOCMEM OR STS$K_SEVERE, 0, .STATUS);
INCRA P FROM .BITMAP_RETADR[0] TO .BITMAP_RETADR[1] AND NOT 511 BY 512 DO
    CH$FILL(-1, 512, .P);


! Read the queue header and initialize global registers for the TREE routine.
!
RTM = .BITMAP_RETADR[0];
SQH = READ_RECORD(SQH$K_RECNO);


! Process a discrepancy between the queue file allocation and the highest
! record number recorded in the queue file.
!
IF .SQH[SQH$L_HIGHEST_RECORD] NEQ .QUEUE_FAB[FAB$L_ALQ]
THEN
    BEGIN

    ! If the highest record number is beyond the allocated space, it is
    ! an error.
    !
    IF .SQH[SQH$L_HIGHEST_RECORD] GTRU .QUEUE_FAB[FAB$L_ALQ]
    THEN
	SQH[SQH$L_HIGHEST_RECORD] = .QUEUE_FAB[FAB$L_ALQ];


    ! Presumably a crash occurred while the file was being extended. Ensure that
    ! records beyond the highest recorded record number are initialized and
    ! process them later as lost records.
    !
    CH$FILL(0, SYM$S_SYM, BUFFER);
    QUEUE_RAB[RAB$L_RBF] = BUFFER;
    IF .FLAGS[FLAGS_V_QUEUE_SHARED]
	THEN QUEUE_RAB[RAB$L_ROP] = RAB$M_UIF OR RAB$M_NLK
	ELSE QUEUE_RAB[RAB$L_ROP] = RAB$M_UIF;
    DECR REC_N FROM .QUEUE_FAB[FAB$L_ALQ] TO .SQH[SQH$L_HIGHEST_RECORD] + 1 DO
	BEGIN
	QUEUE_RAB[RAB$L_KBF] = REC_N;
	DIAG_COUNT[1] = .DIAG_COUNT[1] + 1;
	IF NOT $PUT(RAB=QUEUE_RAB)
	THEN
	    SIGNAL_FILE_ERROR(
		JBC$_WRITEERR + STS$K_SEVERE,
		QUEUE_FAB, QUEUE_RAB);
	END;
    SQH[SQH$L_HIGHEST_RECORD] = .QUEUE_FAB[FAB$L_ALQ];
    END;


! Traverse the free list.  This action must precede the deletion of any
! other records.
!
DIAG_TRACE[8] = 1;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_FREE_LIST], 0, FALSE);


! Traverse the characteristic definition list.
!
DIAG_TRACE[8] = 2;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_CHARACTERISTIC_LIST], SYM$K_SCX, FALSE);


! Compute the expected value of the highest entry number based on the
! existing extension bitmap records, and correct the value recorded in the
! queue header.
!
DIAG_TRACE[8] = 3;			! ***** diagnostic info *****
HIGHEST_ENTRY_NUMBER =
    SQH$S_ENTRY_BITMAP * 8 +
    (SYM$S_DATA * 8) * (SQH$S_ENTRY_BITMAP_VECTOR/4);
HIGHEST_ENTRY_OFFSET = -1;
DECR N FROM SQH$S_ENTRY_BITMAP_VECTOR/4-1 TO 0 DO
    BEGIN
    IF .VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .N] NEQ 0
    THEN
	BEGIN
	HIGHEST_ENTRY_OFFSET = .N;
	EXITLOOP;
	END;	
    HIGHEST_ENTRY_NUMBER = .HIGHEST_ENTRY_NUMBER - (SYM$S_DATA * 8);
    END;
SQH[SQH$L_HIGHEST_ENTRY_NUMBER] = .HIGHEST_ENTRY_NUMBER;


! Correct the next entry number value if necessary.
!
IF .SQH[SQH$L_NEXT_ENTRY_NUMBER] EQLU 0
OR .SQH[SQH$L_NEXT_ENTRY_NUMBER] GTRU .HIGHEST_ENTRY_NUMBER + 1
THEN
    SQH[SQH$L_NEXT_ENTRY_NUMBER] = 1;


! Traverse and reinitialize the extension bitmap records, ensuring that each one
! exists.  This must occur before any job lists are scanned.
!
INCR N FROM 0 TO .HIGHEST_ENTRY_OFFSET DO
    BEGIN
    LOCAL
	SEB_N;			! Record number of extension bitmap

    SEB_N = .VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .N];
    IF .SEB_N EQL 0 THEN SIGNAL(JBC$_QUEFORMAT);
    TREE(.SEB_N, SYM$K_ENTRY_BITMAP, FALSE);
    END;
CH$FILL(0, SQH$S_ENTRY_BITMAP, SQH[SQH$B_ENTRY_BITMAP]);


! Traverse the form index list.  This must occur before any job lists are
! scanned and before the queue list second pass.
!
DIAG_TRACE[8] = 4;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_FORM_INDEX_LIST], SYM$K_SFX, FALSE);


! Traverse and delete the incomplete service list.
!
DIAG_TRACE[8] = 5;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_INCOMPLETE_SERVICE_LIST], SYM$K_SRQ, TRUE);
SQH[SQH$L_INCOMPLETE_SERVICE_LIST] = 0;


! Traverse the queue index list.  This must occur before any job lists are
! scanned.
!
DIAG_TRACE[8] = 6;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_QUEUE_INDEX_LIST], SYM$K_SQX, FALSE);


! Traverse and delete the open job list.
!
DIAG_TRACE[8] = 7;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_OPEN_LIST], SYM$K_SJH, TRUE);
SQH[SQH$L_OPEN_LIST] = 0;
SQH[SQH$L_OPEN_LIST_END] = 0;


! Save and reinitialize the pending and timer lists.  This must occur before
! any job lists are scanned.
!
SAVED_PENDING_BATCH_LIST = .SQH[SQH$L_PENDING_BATCH_LIST];
SAVED_PENDING_PRINT_LIST = .SQH[SQH$L_PENDING_PRINT_LIST];
SAVED_TIMER_LIST = .SQH[SQH$L_TIMER_LIST];
SQH[SQH$L_PENDING_BATCH_LIST] = 0;
SQH[SQH$L_PENDING_BATCH_LIST_END] = 0;
SQH[SQH$L_PENDING_PRINT_LIST] = 0;
SQH[SQH$L_PENDING_PRINT_LIST_END] = 0;
SQH[SQH$L_TIMER_LIST] = 0;
SQH[SQH$L_TIMER_LIST_END] = 0;


! Traverse the queue index list (pass 2).
!
DIAG_TRACE[8] = 8;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_QUEUE_INDEX_LIST], SYM$K_SQX OR M_SMQ_P2 OR M_NO_MARK, FALSE);

! Find any deallocated job records that remain in the CURRENT_LIST of any
! queues.
!
DIAG_TRACE[8] = 9;			! ***** diagnostic info *****
COLD_START_CURRENT_LIST();

! Traverse the queue index list (pass 3).
!
DIAG_TRACE[8] = 10;			! ***** diagnostic info *****
TREE(.SQH[SQH$L_QUEUE_INDEX_LIST], SYM$K_SQX OR M_SMQ_P3 OR M_NO_MARK, FALSE);


! Traverse the pending lists and the timer list.
!
DIAG_TRACE[8] = 11;			! ***** diagnostic info *****
TREE(.SAVED_PENDING_BATCH_LIST, SYM$K_SJH, FALSE);
DIAG_TRACE[8] = 12;			! ***** diagnostic info *****
TREE(.SAVED_PENDING_PRINT_LIST, SYM$K_SJH, FALSE);
DIAG_TRACE[8] = 13;			! ***** diagnostic info *****
TREE(.SAVED_TIMER_LIST, SYM$K_SJH, FALSE);


! Pass over the lost blocks looking for lost job headers.
!
DIAG_TRACE[8] = 14;			! ***** diagnostic info *****
INCR REC_N FROM 2 TO .QUEUE_FAB[FAB$L_ALQ] DO
    BEGIN
    IF .RTM[.REC_N-1] LSS 0
    THEN
	BEGIN
	LOCAL
	    REC:	REF BBLOCK;	! Pointer to lost record

	REC = READ_RECORD(.REC_N);
	IF .REC[SYM$B_TYPE] EQL SYM$K_SJH
	    THEN TREE(.REC_N, SYM$K_SJH OR M_NO_TRAVERSE, FALSE);
	RELEASE_RECORD(.REC_N);
	END;
    END;

! Indicate last pass is complete.
!
DIAG_TRACE[8] = -65536;			! ***** diagnostic info *****

! Link all remaining lost blocks to the free list.
!
FREE_N = .SQH[SQH$L_FREE_LIST];
CH$FILL(0, SYM$S_SYM, BUFFER);
QUEUE_RAB[RAB$L_RBF] = BUFFER;
IF .FLAGS[FLAGS_V_QUEUE_SHARED]
    THEN QUEUE_RAB[RAB$L_ROP] = RAB$M_UIF OR RAB$M_NLK
    ELSE QUEUE_RAB[RAB$L_ROP] = RAB$M_UIF;
DECR REC_N FROM .QUEUE_FAB[FAB$L_ALQ] TO 2 DO
    BEGIN
    IF .RTM[.REC_N-1] LSS 0
    THEN
	BEGIN
	BUFFER[SYM$L_LINK] = .FREE_N;
	FREE_N = .REC_N;
	QUEUE_RAB[RAB$L_KBF] = REC_N;
	DIAG_TRACE[10] = .DIAG_TRACE[10] + 1;	! Count lost blocks recovered
	DIAG_COUNT[1] = .DIAG_COUNT[1] + 1;
	IF NOT $PUT(RAB=QUEUE_RAB)
	THEN
	    SIGNAL_FILE_ERROR(
		JBC$_WRITEERR + STS$K_SEVERE,
		QUEUE_FAB, QUEUE_RAB);
	END;
    END;
SQH[SQH$L_FREE_LIST] = .FREE_N;
SQH[SQH$L_HIGHEST_RECORD] = .QUEUE_FAB[FAB$L_ALQ];


! Ensure that the end of file pointer is correct.
!
IF NOT $FLUSH(RAB=QUEUE_RAB)
THEN
    SIGNAL_FILE_ERROR(
	JBC$_WRITEERR + STS$K_SEVERE,
	QUEUE_FAB, QUEUE_RAB);


! If the timer list is not empty, set a timer on the first job.
!
IF .SQH[SQH$L_TIMER_LIST] NEQ 0
THEN
    BEGIN
    LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	STATUS;				! Status return

    SJH = READ_RECORD(SJH_N = .SQH[SQH$L_TIMER_LIST]);
    STATUS = $SETIMR(
	DAYTIM=SJH[SJH$Q_AFTER_TIME],
	ASTADR=AFTER_AST,
	REQIDT=JBC$K_AFTER_IDT);
    IF NOT .STATUS
    THEN
	SIGNAL(JBC$_SETIMR OR STS$K_ERROR, 0, .STATUS);
    RELEASE_RECORD(.SJH_N);
    END;


! Rewrite the queue header.
!
REWRITE_RECORD(SQH$K_RECNO);


! Release the record type bitmap to the free memory list.
!
DECRA P FROM .BITMAP_RETADR[1] AND NOT 511 TO .BITMAP_RETADR[0] BY 512 DO
    DEALLOCATE_MEMORY(.P);
END;

ROUTINE COLD_START_NEW_FILE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes a newly created queue file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	BUFFER:		BBLOCK[SYM$S_SYM];	! Record buffer


! Link all records to the free list.
!
CH$FILL(0, SYM$S_SYM, BUFFER);
QUEUE_RAB[RAB$L_RBF] = BUFFER;
IF .FLAGS[FLAGS_V_QUEUE_SHARED]
    THEN QUEUE_RAB[RAB$L_ROP] = RAB$M_UIF OR RAB$M_NLK
    ELSE QUEUE_RAB[RAB$L_ROP] = RAB$M_UIF;
DECR REC_N FROM .QUEUE_FAB[FAB$L_ALQ] TO 4 DO
    BEGIN
    QUEUE_RAB[RAB$L_KBF] = REC_N;
    DIAG_COUNT[1] = .DIAG_COUNT[1] + 1;
    IF NOT $PUT(RAB=QUEUE_RAB)
    THEN
	SIGNAL_FILE_ERROR(
	    JBC$_WRITEERR + STS$K_SEVERE,
	    QUEUE_FAB, QUEUE_RAB);
    BUFFER[SYM$L_LINK] = .REC_N;
    END;


! Initialize the queue header record.
!
CH$FILL(0, SYM$S_SYM, BUFFER);
BUFFER[SYM$B_TYPE] = SYM$K_SQH;
BUFFER[SQH$W_STRUCTURE_LEVEL] = SQH$K_STRUCTURE_LEVEL;
BUFFER[SQH$L_FORM_INDEX_LIST] = .SFX_KBF;
BUFFER[SQH$L_FREE_LIST] = 4;
BUFFER[SQH$L_HIGHEST_RECORD] = .QUEUE_FAB[FAB$L_ALQ];
BUFFER[SQH$L_NEXT_ENTRY_NUMBER] = 1;
BUFFER[SQH$L_HIGHEST_ENTRY_NUMBER] = SQH$S_ENTRY_BITMAP * 8;
QUEUE_RAB[RAB$L_KBF] = SQH_KBF;
DIAG_COUNT[1] = .DIAG_COUNT[1] + 1;
IF NOT $PUT(RAB=QUEUE_RAB)
THEN
    SIGNAL_FILE_ERROR(
	JBC$_WRITEERR + STS$K_SEVERE,
	QUEUE_FAB, QUEUE_RAB);


! Initialize the default form definition record.
!
CH$FILL(0, SYM$S_SYM, BUFFER);
BUFFER[SYM$B_TYPE] = SYM$K_SFM;
BUFFER[SFM$V_TRUNCATE] = TRUE;
BUFFER[SFM$B_LENGTH] = 66;
BUFFER[SFM$B_MARGIN_BOTTOM] = 6;
CH$MOVE(
    %CHARCOUNT('DEFAULT') + 1,
    UPLIT BYTE (%ASCIC 'DEFAULT'),
    BUFFER[SFM$T_NAME]);
CH$MOVE(
    %CHARCOUNT('System-defined default') + 1,
    UPLIT BYTE (%ASCIC 'System-defined default'),
    BUFFER[SFM$T_DESCRIPTION]);
CH$MOVE(SFM$S_NAME, BUFFER[SFM$T_NAME], BUFFER[SFM$T_STOCK]);
BUFFER[SFM$W_WIDTH] = 132;
QUEUE_RAB[RAB$L_KBF] = SFM_KBF;
DIAG_COUNT[1] = .DIAG_COUNT[1] + 1;
IF NOT $PUT(RAB=QUEUE_RAB)
THEN
    SIGNAL_FILE_ERROR(
	JBC$_WRITEERR + STS$K_SEVERE,
	QUEUE_FAB, QUEUE_RAB);


! Initialize the initial form index record.
!
CH$FILL(0, SYM$S_SYM, BUFFER);
BUFFER[SYM$B_TYPE] = SYM$K_SFX;
CH$MOVE(
    %CHARCOUNT('DEFAULT') + 1,
    UPLIT BYTE (%ASCIC 'DEFAULT'),
    BBLOCK[BUFFER[SYM$T_DATA], SFX$T_NAME]);
BBLOCK[BUFFER[SYM$T_DATA], SFX$L_FORM_LINK] = .SFM_KBF;
QUEUE_RAB[RAB$L_KBF] = SFX_KBF;
DIAG_COUNT[1] = .DIAG_COUNT[1] + 1;
IF NOT $PUT(RAB=QUEUE_RAB)
THEN
    SIGNAL_FILE_ERROR(
	JBC$_WRITEERR + STS$K_SEVERE,
	QUEUE_FAB, QUEUE_RAB);


! Update the end of file pointer.
!
IF NOT $FLUSH(RAB=QUEUE_RAB)
THEN
    SIGNAL_FILE_ERROR(
	JBC$_WRITEERR + STS$K_SEVERE,
	QUEUE_FAB, QUEUE_RAB);
END;

GLOBAL ROUTINE WARM_START_EXISTING_FILE(SYSID): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reinitializes an existing queue file if this job controller
!	is not the first accessor.
!
! INPUT PARAMETERS:
!	SYSID		- Pointer to system ID.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_N,				! Record number of SQX
	SQX_NS,				! Record number of successor of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	SJH_NP,				! Record number of predecessor of SJH
	SJH_P:		REF BBLOCK,	! Pointer to predecessor of SJH
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SJH_NS;				! Record number of successor of SJH


! Read the queue header.
!
SQH = READ_RECORD(SQH$K_RECNO);


! Reinitialize all executor queues that were assigned to the failing or
! restarting node.
!
SQX_N = .SQH[SQH$L_QUEUE_INDEX_LIST];
WHILE .SQX_N NEQ 0 DO
    BEGIN

    ! Read the queue index record.
    !
    SQX = READ_RECORD(.SQX_N);


    ! Scan the queue index record.
    !
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    IF .SQE[SQX$V_EXECUTOR]
	    THEN
		BEGIN
		SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);
		IF SYSID_EQL(.SYSID, SMQ[SMQ$T_SYSID])
		THEN
		    BEGIN

		    ! Reinitialize the queue header as appropriate.
		    !
		    SMQ[SMQ$L_STATUS] = 0;
		    SMQ[SMQ$V_STOPPED] = TRUE;
		    CLEAR_TIME(SMQ[SMQ$Q_ACM_BEGTIM]);
		    SMQ[SMQ$L_ACM_GETCNT] = 0;
		    SMQ[SMQ$L_ACM_PAGECNT] = 0;
		    SMQ[SMQ$L_ACM_QIOCNT] = 0;
		    SMQ[SMQ$L_ACM_SYMCPUTIM] = 0;
		    SMQ[SMQ$L_STREAM_SCT] = 0;
		    SMQ[SMQ$B_CURRENT_JOB_COUNT] = 0;
		    SMQ[SMQ$B_STREAM_INDEX] = 0;
		    REWRITE_RECORD(.SMQ_N);
		    END
		ELSE
		    RELEASE_RECORD(.SMQ_N);
		END;
	    END;


	SQE = .SQE + SQX$S_SQX;
	END;


    ! Advance to the next index block.
    !
    SQX_NS = .SQX[SYM$L_LINK];
    RELEASE_RECORD(.SQX_N);
    SQX_N = .SQX_NS;
    END;


! Requeue or delete jobs that were executing on the failed or restarting queues.
!
SQX_N = .SQH[SQH$L_QUEUE_INDEX_LIST];
WHILE .SQX_N NEQ 0 DO
    BEGIN

    ! Read the queue index record.
    !
    SQX = READ_RECORD(.SQX_N);


    ! Scan the queue index record.
    !
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    IF .SQE[SQX$V_EXECUTOR]
	    THEN
		BEGIN
		SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);
		IF SYSID_EQL(.SYSID, SMQ[SMQ$T_SYSID])
		THEN
		    BEGIN

		    ! Requeue or delete each job, as appropriate.
		    !
		    WHILE .SMQ[SMQ$L_CURRENT_LIST] NEQ 0 DO
			BEGIN
			LOCAL
			    SJH_N,			! Record number of SJH
			    SJH:	REF BBLOCK;	! Pointer to SJH


			SJH = READ_RECORD(SJH_N = .SMQ[SMQ$L_CURRENT_LIST]);

			! Check for a deallocated SJH on the current list.
			!
			IF .SJH[SJH$L_QUEUE_LINK] EQL 0
			THEN
			    BEGIN
			    SMQ[SMQ$L_CURRENT_LIST] = 0;
			    EXITLOOP;
			    END;

			UPDATE_GETQUI_DATA(.SJH_N, .SJH);
			SMQ[SMQ$L_CURRENT_LIST] = .SJH[SYM$L_LINK];

			! Flush the SMQ so as not to corrupt current list.
			!
			FLUSH_RECORD(.SMQ_N);
			SJH[SJH$V_SYSTEM_FAILURE] = TRUE;
			COMPLETE_JOB(
			    .SJH_N, .SJH,
			    .SMQ,
			    0,
			    JBC$_SYSFAIL OR STS$K_ERROR);
			END;
		    SMQ[SMQ$L_CURRENT_LIST_END] = 0;
		    REWRITE_RECORD(.SMQ_N);
		    END
		ELSE
		    RELEASE_RECORD(.SMQ_N);
		END;
	    END;



	SQE = .SQE + SQX$S_SQX;
	END;


    ! Advance to the next index block.
    !
    SQX_NS = .SQX[SYM$L_LINK];
    RELEASE_RECORD(.SQX_N);
    SQX_N = .SQX_NS;
    END;


! Purge references to this system from the incomplete service list.
!
SCAN_INCOMPLETE_SERVICES(ISRV_K_PURGE_SYSID, .SYSID);


! Purge open jobs for this system from the open job queue.
!
SJH_NP = 0;
SJH_N = .SQH[SQH$L_OPEN_LIST];
WHILE .SJH_N NEQ 0 DO
    BEGIN
    SJH = READ_RECORD(.SJH_N);
    SJH_NS = .SJH[SYM$L_LINK];


    IF SYSID_EQL(.SYSID, SJH[SJH$T_SYSID])
    THEN
	BEGIN
	IF .SJH_NP EQL 0
	THEN
	    BEGIN
	    SQH[SQH$L_OPEN_LIST] = .SJH[SYM$L_LINK];
	    IF .SJH[SYM$L_LINK] EQL 0 THEN SQH[SQH$L_OPEN_LIST_END] = 0;
	    END
	ELSE
	    BEGIN
	    SJH_P[SYM$L_LINK] = .SJH[SYM$L_LINK];
	    IF .SJH[SYM$L_LINK] EQL 0 THEN SQH[SQH$L_OPEN_LIST_END] = .SJH_NP;
	    END;
	SMQ = READ_RECORD(SMQ_N = .SJH[SJH$L_QUEUE_LINK]);
	SMQ[SMQ$W_OPEN_JOB_COUNT] = .SMQ[SMQ$W_OPEN_JOB_COUNT] - 1;
	REWRITE_RECORD(.SMQ_N);
	DELETE_SJH_RECORD(.SJH_N, .SJH);
	END
    ELSE
	BEGIN
	IF .SJH_NP NEQ 0 THEN REWRITE_RECORD(.SJH_NP);
	SJH_NP = .SJH_N;
	SJH_P = .SJH;
	END;
    SJH_N = .SJH_NS;
    END;
IF .SJH_NP NEQ 0 THEN REWRITE_RECORD(.SJH_NP);


! If the timer list is not empty, set a timer on the first job.
!
IF .SQH[SQH$L_TIMER_LIST] NEQ 0
THEN
    BEGIN
    LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	STATUS;				! Status return

    SJH = READ_RECORD(SJH_N = .SQH[SQH$L_TIMER_LIST]);
    STATUS = $SETIMR(
	DAYTIM=SJH[SJH$Q_AFTER_TIME],
	ASTADR=AFTER_AST,
	REQIDT=JBC$K_AFTER_IDT);
    IF NOT .STATUS
    THEN
	SIGNAL(JBC$_SETIMR OR STS$K_ERROR, 0, .STATUS);
    RELEASE_RECORD(.SJH_N);
    END;


! Rewrite the queue header.
!
REWRITE_RECORD(SQH$K_RECNO);
END;

ROUTINE INITIALIZE_QUEUE_FILE_HANDLER(SIG,MCH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is a condition handler for INITIALIZE_QUEUE_FILE.  It
!	unwinds the stack and returns status if an error occurs.
!
! INPUT PARAMETERS:
!	Standard VMS condition handler parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	If the signal is a success status, SS$_RESIGNAL; otherwise an unwind
!	to caller of establisher with the failure status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SIG:		REF BBLOCK,	! Pointer to signal vector
	MCH:		REF BBLOCK;	! Pointer to mechanism vector


! If the signal is a failure status, unwind to the caller with that status as
! the routine value.
!
IF .SIG[CHF$L_SIG_NAME] NEQ SS$_UNWIND AND NOT .SIG[CHF$L_SIG_NAME]
THEN
    BEGIN
    MCH[CHF$L_MCH_SAVR0] = .SIG[CHF$L_SIG_NAME];
    $UNWIND();
    END;


SS$_RESIGNAL
END;

GLOBAL ROUTINE INITIALIZE_QUEUE_FILE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine opens and initializes the system job queue file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	BUFFER:		BBLOCK[SYM$S_SYM],
	DESC:		VECTOR[2],	! Utility descriptor
	RESNAM:		BBLOCK[30],	! Buffer for resource name
	STATUS_1,			! Status return
	STATUS_2,			! Status return
	STATUS_3;			! Status return
BUILTIN
	FP;


! Ensure that the queue reference count is zero, and establish the handler.
! If this routine encounters any errors, the logic in UNLOCK_QUEUE_FILE will
! ensure that all resources are properly released.
!
QUEUE_REFERENCE_COUNT = 0;
.FP = INITIALIZE_QUEUE_FILE_HANDLER;


! Determine values for the initial file allocation (ALQ) and multibuffer count
! (MBF) fields.
!
! If the SJC$_EXTEND_QUANTITY item code is not present or specified as 0, then
! use the job contoller default value. Likewise, if the SJC$_BUFFER_COUNT item
! code is not present or specified as 0, then use the job controller default
! value.
!
QUEUE_ALQ = .VALUE_EXTEND_QUANTITY;
IF .QUEUE_ALQ EQL 0 THEN QUEUE_ALQ = JBC$K_QUEUE_ALQ;
IF .QUEUE_ALQ LSSU 10 THEN QUEUE_ALQ = 10;
QUEUE_MBF = .VALUE_BUFFER_COUNT;
IF .QUEUE_MBF EQL 0 THEN QUEUE_MBF = JBC$K_QUEUE_MBF;


! The following loop is executed once if the file is created or if it already
! exists and has satisfactory attributes.  Otherwise it is executed twice to
! unconditionally create the file.  However, if the /NEW_VERSION qualifier is
! given, only execute the loop once to unconditionally create the file.
!
DECR I FROM (IF .ITEM_PRESENT[SJC$_NEW_VERSION] THEN 0 ELSE 1) TO 0 DO
    BEGIN
    $FAB_INIT(FAB=QUEUE_FAB,
	ALQ=.QUEUE_ALQ,
	DNA=UPLIT BYTE('SYS$SYSTEM:JBCSYSQUE.DAT'),
	DNS=%CHARCOUNT('SYS$SYSTEM:JBCSYSQUE.DAT'),
	FAC=<GET,PUT,UPD>,
	FNA=.VALUE_QUEUE_FILE_SPECIFICATION[SDSC_A_POINTER],
	FNS=.VALUE_QUEUE_FILE_SPECIFICATION[SDSC_W_LENGTH],
	FOP=CBT,
	GBC=JBC$K_QUEUE_GBC,
	MRS=SYM$S_SYM,
	NAM=QUEUE_NAM,
	ORG=SEQ,
	RFM=FIX,
	SHR=<SHRGET,SHRPUT,SHRUPD>,
	XAB=QUEUE_XAB);

    $RAB_INIT(RAB=QUEUE_RAB,
	FAB=QUEUE_FAB,
	KSZ=4,
	MBC=JBC$K_QUEUE_MBC,
	MBF=.QUEUE_MBF,
	RAC=KEY,
	RSZ=SYM$S_SYM,
	USZ=SYM$S_SYM);

    $NAM_INIT(NAM=QUEUE_NAM,
	ESA=QUEUE_RSA,
	ESS=NAM$C_MAXRSS,
	RSA=QUEUE_RSA,
	RSS=NAM$C_MAXRSS);

    $XABPRO_INIT(XAB=QUEUE_XAB,
	PRO=<RWED,RWED,,>,
	UIC=[1,4]);

    QUEUE_FAB[FAB$V_CIF] = .I;


    ! Create the queue file or open an existing queue file,
    ! and connect the RAB.
    !
    IF $CREATE(FAB=QUEUE_FAB)
    THEN
	BEGIN
	IF NOT $CONNECT(RAB=QUEUE_RAB)
	THEN
	    RETURN .QUEUE_RAB[RAB$L_STS];
	END
    ELSE
	BEGIN
	IF .I EQL 0 THEN RETURN .QUEUE_FAB[FAB$L_STS];
	QUEUE_FAB[FAB$W_MRS] = 0;
	END;


    ! Determine whether or not a new file was created.
    !
    IF .QUEUE_FAB[FAB$L_STS] EQL RMS$_CREATED OR NOT .QUEUE_FAB[FAB$V_CIF]
    THEN FLAGS[FLAGS_V_QUEUE_CREATED] = TRUE
    ELSE FLAGS[FLAGS_V_QUEUE_CREATED] = FALSE;


    ! Check the file attributes and the first block of the file to ensure that
    ! the file is suitable.
    !
    IF
	BEGIN
	IF .QUEUE_FAB[FAB$W_MRS] EQL SYM$S_SYM
	AND .QUEUE_FAB[FAB$B_ORG] EQL FAB$C_SEQ
	AND .QUEUE_FAB[FAB$B_RAT] EQL 0
	AND .QUEUE_FAB[FAB$B_RFM] EQL FAB$C_FIX
	THEN
	    IF .FLAGS[FLAGS_V_QUEUE_CREATED]
	    THEN
		TRUE
	    ELSE
		BEGIN
		QUEUE_RAB[RAB$L_KBF] = SQH_KBF;
		QUEUE_RAB[RAB$L_ROP] = RAB$M_NLK OR RAB$M_RRL;
		QUEUE_RAB[RAB$L_UBF] = BUFFER;
		DIAG_COUNT[0] = .DIAG_COUNT[0] + 1;
		IF $GET(RAB=QUEUE_RAB)
		THEN
		    .BUFFER[SYM$B_TYPE] EQL SYM$K_SQH AND
		    .BUFFER[SQH$W_STRUCTURE_LEVEL] EQL SQH$K_STRUCTURE_LEVEL
		ELSE
		    FALSE
		END
	ELSE
	    FALSE
	END
    THEN
	EXITLOOP;


    ! Close the file and loop to unconditionally create a new file. Display an
    ! informational message stating that the file found has an incompatible
    ! structure level.
    !
    IF NOT $CLOSE(FAB=QUEUE_FAB)
    THEN RETURN .QUEUE_FAB[FAB$L_STS];
    IF .BUFFER[SYM$B_TYPE] EQL SYM$K_SQH AND
       .BUFFER[SQH$W_STRUCTURE_LEVEL] NEQ SQH$K_STRUCTURE_LEVEL
    THEN
	SIGNAL(JBC$_STRUCT_LEVEL OR STS$K_INFO,
	1, .BUFFER[SQH$W_STRUCTURE_LEVEL]);
    END;


! Issue a message if the queue file was created.
!
IF .FLAGS[FLAGS_V_QUEUE_CREATED]
THEN
    BEGIN
    DESC[0] = .QUEUE_NAM[NAM$B_RSL];
    DESC[1] = .QUEUE_NAM[NAM$L_RSA];
    SIGNAL(JBC$_NEWQUEUE OR STS$K_INFO, 1, DESC);
    END;


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Disable the following code segment as currently the queue file must be opened
! for shared access in order for RMS to support more than two local buffers.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
WORK_AREA[0] = 1;				! Non-zero value disables option

! First check to see if the use of a global buffer cache (FAB$W_GBC) has been
! specified (to be used in place of a local buffer cache (RAB$B_MBF)). If global
! buffers are to be used, then file sharing must remain enabled (FAB$B_SHR) and
! the FLAGS_V_QUEUE_SHARED flag set. Otherwise, try to optimize the access.
!
! The queue file has been opened optimized for a cluster environment, that is,
! it is open for shared access. Next determine whether or not the queue file
! really can be accessed by another job controller. If this node (1) is not
! <or cannot become> a member of a cluster, or (2) the queue file is on a device
! that is not cluster-wide accessible, then we should optimize for a non-cluster
! environment. To do this, we'll close the queue file and reopen it with the
! user-provided-interlocking (UPI) option selected. This will prevent RMS from
! taking out locks on records in the local buffer cache which should reduce
! locking overhead considerably in a non-cluster environment.
!
FLAGS[FLAGS_V_QUEUE_SHARED] = TRUE;

IF .QUEUE_FAB[FAB$W_GBC] EQL 0 AND .WORK_AREA[0] EQL 0
THEN
    BEGIN
    OWN
	DEVCHAR2:		BBLOCK[4],	! 2nd device char longword
	CLUSTER_MEMBER:		BBLOCK[4];	! Cluster member status

    DESC[0] = .(QUEUE_NAM[NAM$T_DVI])<0,8>;	! Form a string descriptor from
    DESC[1] = QUEUE_NAM[NAM$T_DVI] + 1;		!  a counted string
    STATUS_1 = $GETDVIW(
	EFN=JBC$K_SYNC_EFN,
	DEVNAM=DESC,
	ITMLST=UPLIT(
	    WORD(4, DVI$_DEVCHAR2), LONG(DEVCHAR2, 0),
	    LONG(0)));
    STATUS_2 = $GETSYIW(
	EFN=JBC$K_SYNC_EFN,
	ITMLST=UPLIT(
	    WORD(1, SYI$_CLUSTER_MEMBER), LONG(CLUSTER_MEMBER, 0),
	    LONG(0)));

    IF .STATUS_1 AND .STATUS_2
    THEN
	BEGIN
	IF (NOT .DEVCHAR2[DEV$V_CLU]) OR (NOT .CLUSTER_MEMBER<0,1>)
	THEN
	    BEGIN
	    FLAGS[FLAGS_V_QUEUE_SHARED] = FALSE;
	    IF NOT $CLOSE(FAB=QUEUE_FAB)
		THEN RETURN .QUEUE_FAB[FAB$L_STS];
	    QUEUE_FAB[FAB$B_SHR] = FAB$M_SHRGET OR FAB$M_UPI;
	    IF $OPEN(FAB=QUEUE_FAB)
	    THEN
		BEGIN
		IF NOT $CONNECT(RAB=QUEUE_RAB)
		    THEN RETURN .QUEUE_RAB[RAB$L_STS];
		END
	    ELSE RETURN .QUEUE_FAB[FAB$L_STS];
	    END;
	END;
END;


! Take out the queue file master lock. The first job controller to access
! the queue file holds this lock, and is said to be the queue master.  If
! that job controller should fail, the next job controller to queue for the
! lock receives the completion AST, and can take necessary actions.
!
DESC[0] = 26;
DESC[1] = RESNAM;
RESNAM[0,0,32,0] = 'JBC$';
CH$MOVE(22, QUEUE_NAM[NAM$T_DVI], RESNAM[4,0,0,0]);
STATUS_1 = $ENQ(
    LKMODE=LCK$K_EXMODE,
    LKSB=QUEUE_FILE_LKSB,
    FLAGS=LCK$M_SYNCSTS OR LCK$M_NODLCKWT,
    RESNAM=DESC,
    ASTADR=QUEUE_MASTER_AST);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Take out the queue lock.
!
DESC[0] = 30;
RESNAM[26,0,32,0] = 'LOCK';
STATUS_2 = $ENQW(
    EFN=JBC$K_SYNC_EFN,
    LKMODE=LCK$K_EXMODE,
    LKSB=QUEUE_LOCK_LKSB,
    RESNAM=DESC);
IF .STATUS_2 THEN STATUS_2 = .QUEUE_LOCK_LKSB[0];
IF NOT .STATUS_2 THEN RETURN .STATUS_2;
FLAGS[FLAGS_V_QUEUE_LOCKED] = TRUE;


! If this is not the first access to the file, do a brief reconstruction.
! Otherwise, if the file was just created then initialize it. If not, then
! this is the first access to an existing file, so do a full reconstruction.
!
IF .FLAGS[FLAGS_V_OMIT_QF_INIT]		! For debugging purposes omit
THEN					!  initialization processing to examine
    DIAG_TRACE[8] = -1			!  a corrupted queue file on-line
ELSE
    IF .STATUS_1<0,16> NEQ SS$_SYNCH
    THEN
	WARM_START_EXISTING_FILE(THIS_SYSID)
    ELSE
	IF .FLAGS[FLAGS_V_QUEUE_CREATED]
	THEN COLD_START_NEW_FILE()
	ELSE COLD_START_EXISTING_FILE();


! Enable this job controller's remote request lock.
!
DESC[0] = 10;
DESC[1] = RESNAM;
RESNAM[0,0,32,0] = 'JBC$';
COPY_SYSID(THIS_SYSID, RESNAM[4,0,0,0]);
STATUS_3 = $ENQW(
    EFN=JBC$K_SYNC_EFN,
    LKMODE=LCK$K_EXMODE,
    LKSB=REMOTE_REQUEST_LKSB,
    FLAGS=LCK$M_NOQUEUE OR LCK$M_NODLCKBLK,
    RESNAM=DESC,
    BLKAST=REMOTE_BLOCKING_AST);
IF .STATUS_3 THEN STATUS_3 = .REMOTE_REQUEST_LKSB[0];
IF NOT .STATUS_3 AND .STATUS_3<0,16> NEQ SS$_NOTQUEUED THEN RETURN .STATUS_3;


! Increment the queue's reference count to indicate a successful operation,
! and return success.
!
QUEUE_REFERENCE_COUNT = 1;
SS$_NORMAL
END;

END
ELUDOM
