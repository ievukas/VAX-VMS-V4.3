MODULE BAS$VIRTUAL_ARR (			! Virtual Array interface
		IDENT = '1-033'		! File: BASVIRTUA.B32 Edit: DG1033
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  VAX-11 BASIC Virtual Array Support
!
! ABSTRACT:
!
!	This module contains the support for VAX-11 BASIC virtual
!	arrays.  This consists of the various FETCH and STORE routines
!	called by compiled code and the interface to the I/O system.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: John Sauter, CREATION DATE: 02-FEB-1979
!
! MODIFIED BY:
!
! 1-001	- Original.  This version handles only non-virtual arrays.
!	   JBS 02-FEB-1979
! 1-002	- Make the JSB entry points take arguments in registers.
!	   JBS 26-FEB-1979
! 1-003	- Take linkage definitions from BASVIRTUA.REQ.  JBS 20-FEB-1979
! 1-004	- Based on a review of the virtual array concept with part
!	   of the VAX ECO board, virtual arrays are a BASIC-only
!	   feature.  Therefore, change OTS$ to BAS$ in the entry
!	   points.  Also, only longwords need be passed as indexes.
!	   JBS 03-APR-1979
! 1-005	- Since virtual array descriptors will have their indicies
!	   computed in the same way as ordinary arrays, rearrange
!	   the code to compute the location in the array of the value
!	   before checking the class of the descriptor.  This also
!	   helps support arrays of dynamic strings.  JBS 03-APR-1979
! 1-006	- Add calls to internal virtual array subroutines.  These are
!	   just stubs for now.  JBS 04-APR-1979
! 1-007	- Call temporary I/O routines so we can check out the indexing
!	   subroutines.  JBS 04-APR-1979
! 1-008	- Make those temporary I/O routines permanent, and handle
!	   trailing NULs properly when fetching and storing strings.
!	   JBS 18-MAY-1979
! 1-009	- Change OTS$S to STR$ facility.  JBS 18-MAY-1979
! 1-010	- Change STR$COPY_R_DX to STR$COPY_R  JBS 20-MAY-1979
! 1-011	- Correct a typo which caused normal array fetches to fail.
!	   JBS 31-MAY-1979
! 1-012	- Correct the local definition of DSC$K_DTYPE_DSC.  We must
!	   remember to remove this when the definition goes into
!	   RTLSTARLE.  JBS 01-JUN-1979
! 1-013	- Make the index parameters to BAS$FETCH_VA and BAS$STORE_VA
!	   be by value.  JBS 01-JUN-1979
! 1-014	- Correct an error in storing a string.  JBS 05-JUN-1979
! 1-015	- Debug string virtual arrays.  JBS 11-JUN-1979
! 1-016	- Remove local definitions of DSC$ symbols.  JBS 19-JUN-1979
! 1-017	- Use BASLNK.  JBS 26-JUN-1979
! 1-018	- Add BAS$STO_FA_RDX.  JBS 13-JUL-1979
! 1-019	- Change calls to STR$COPY.  JBS 19-JUL-1979
! 1-020	- Change BAS$$COPY_D and BAS$$COPY_F to end in _R1.  JBS 23-AUG-1979
! 1-021	- Allow the INDEX2 argument of BAS$STO_FA_RDX to be zero.
!	   JBS 06-NOV-1979
! 1-022	- Speed up storing into a string virtual array by creating the
!	   nulls with a single call to STR$DUPL_CHAR instead of with
!	   multiple calls to STR$CONCAT.  JBS 19-MAY-1980
! 1-023 - Add support for byte, g and h floating.  PLL 9-Sep-81
! 1-024 - Add support for records.  Dtype Z indicates a record -
!	  it is handled the same as text.  PLL 26-Feb-82
! 1-025 - Fix bug from edit 024 - Dtype Z required extending the range
!	  of CASE statements.  PLL 5-Mar-82
! 1-026 - Add support for decimal arrays.  Decimal lengths are the number
!	  of digits (not including the sign) rather than the number of bytes,
!	  so the calculation of the linear index is slightly different.
!	  PLL 12-Mar-82
! 1-027 - Remove a couple of dots from the ASHP instruction.  PLL 12-Apr-82
! 1-028 - The last edit corrected FETCH_BFA - also correct STORE_BFA.
!	  12-Apr-82
! 1-029 - Change call to VA_FETCH, VA_STORE for decimal arrays.  PLL 12-Apr-82
! 1-030 - Add entry point BAS$STORE_BFA_OFF.  PLL 8-Jun-1982
! 1-031 - Modify BAS$STORE_BFA_OFF so that no checking is performed on
!	  the source and destination data types.  PLL 26-Jul-1982
! 1-032 - modified all length calculations that used to round up to the
!	  nearest multple of 2 to round up to the nearest POWER of 2.
!	  added a kludge to dummy up the length of a record in the array
!	  descr just prior to the call to BAS$VA_STORE in BAS$STORE_BFA_OFF.
!	  MDL 3-Aug-1982
! 1-033 - Add support for dynamically mapped arrays.  DG 6-Feb-1984
! 	  NOTE - these changes did not have to be incorporated into the
!	  BAS$STO_FA... routines because the routine that calls the STORE
!	  routines specifically calls BAS$STORE_BFA for dynamically mapped 
!	  arrays.
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

LINKAGE
    COPY_JSB = JSB (REGISTER = 0, REGISTER = 1)	!
    : NOTUSED (2, 3, 4, 5, 6, 7, 8, 9, 10, 11);

REQUIRE 'RTLIN:BASLNK';				! Define linkage VA_JSB

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$FETCH_BFA : NOVALUE,			! Fetch a value by descriptor
    BAS$STORE_BFA : NOVALUE,			! Store a value by descriptor
    BAS$STORE_BFA_OFF : NOVALUE,		! Store value by desc w/offset
    BAS$STO_FA_RDX : NOVALUE,			! Store a string by reference
    BAS$FET_FA_W_R8 : VA_JSB,			! Fetch a word
    BAS$STO_FA_W_R8 : VA_JSB NOVALUE,		! Store a word
    BAS$FET_FA_L_R8 : VA_JSB,			! Fetch a longword
    BAS$STO_FA_L_R8 : VA_JSB NOVALUE,		! Store a longword
    BAS$FET_FA_F_R8 : VA_JSB,			! Fetch a floating value
    BAS$STO_FA_F_R8 : VA_JSB NOVALUE,		! Store a floating value
    BAS$FET_FA_D_R8 : VA_JSB NOVALUE,		! Fetch a double-floating value
    BAS$STO_FA_D_R8 : VA_JSB NOVALUE,		! Store a double-floating value
    BAS$FET_FA_B_R8 : VA_JSB,			! Fetch a byte
    BAS$STO_FA_B_R8 : VA_JSB NOVALUE,		! Store a byte
    BAS$FET_FA_G_R8 : VA_JSB NOVALUE,		! Fetch a g floating value
    BAS$STO_FA_G_R8 : VA_JSB NOVALUE,		! Store a g floating value
    BAS$FET_FA_H_R8 : VA_JSB NOVALUE,		! Fetch an h floating value
    BAS$STO_FA_H_R8 : VA_JSB NOVALUE;		! Store an h floating value

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';			! Macros for defining psects

LIBRARY 'RTLSTARLE';				! System symbols

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! PSECTS:
!
DECLARE_PSECTS (BAS);				! Declare psects for BAS$ facility
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BAS$$STOP : NOVALUE,			! signals fatal error
    BAS$$COPY_F_R1 : COPY_JSB NOVALUE,		! Copy a floating number
    BAS$$COPY_D_R1 : COPY_JSB NOVALUE,		! Copy a double number
    BAS$$COPY_G_R1 : COPY_JSB NOVALUE,		! Copy a g float number
    BAS$$COPY_H_R3 : COPY_JSB NOVALUE,		! Copy an h float number
    BAS$$VA_FETCH : NOVALUE,			! Fetch from virt. array
    BAS$$VA_STORE : NOVALUE,			! Store in virt. array
    STR$GET1_DX,				! Allocate a string
    STR$FREE1_DX,				! Deallocate a string
    STR$COPY_DX,				! Copy by descriptor
    STR$COPY_R,					! Copy by reference
    STR$CONCAT,					! Concatenate two strings
    STR$DUPL_CHAR;				! Make lots of a character

!+
! The following are the error codes used in this module.
!-

EXTERNAL LITERAL
    BAS$K_MATARRTOO : UNSIGNED (8),		! Matrix or array too large
    BAS$K_VIRARROPE : UNSIGNED (8),
    BAS$K_VIRARRDIS : UNSIGNED (8),
    BAS$K_SUBOUTRAN : UNSIGNED (8),
    BAS$K_FATSYSIO_ : UNSIGNED (8),
    BAS$K_DATTYPERR : UNSIGNED (8),
    BAS$K_TOOFEWARG : UNSIGNED (8),
    BAS$K_TOOMANARG : UNSIGNED (8),
    BAS$K_ARGDONMAT : UNSIGNED (8),
    BAS$K_FLOPOIERR : UNSIGNED (8),
    BAS$K_RECBUCLOC : UNSIGNED (8),
    BAS$K_ONEOR_TWO : UNSIGNED (8),
    BAS$K_NOTIMP : UNSIGNED (8);


GLOBAL ROUTINE BAS$FETCH_BFA (			! Fetch a value by descriptor
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor
	VALUE : REF BLOCK [8, BYTE],		! Where to put it
	INDEX1					! First index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a value from an array or virtual array.  The location in
!	which to place the value is passed by descriptor.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	VALUE.wx.dx	The place to put the value fetched
!	INDEX1.rl.v	The first index into the array.  More indicies
!			may follow this one in the calling sequence.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	ASHP;

    LOCAL
	INDEX_VALUE,
	VALUE_LOCATION,
	MULTIPLIERS : REF VECTOR,
	BOUNDS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	INDEX_NUMBER,
	VALUE_DESCR : BLOCK [12, BYTE],
	VALUE_DESC_ADDR,
	LENGTH;

!+
! Be sure the number of array subscripts matches the number of
! indicies given to us.
!-

    IF ((ACTUALCOUNT () - 2) NEQU .DESCRIP [DSC$B_DIMCT])
    THEN
	BEGIN

	IF ((ACTUALCOUNT () - 2) LSSU .DESCRIP [DSC$B_DIMCT])
	THEN
	    BAS$$STOP (BAS$K_TOOFEWARG)
	ELSE
	    BAS$$STOP (BAS$K_TOOMANARG);

	END;

!+
! The coefficients and bounds must be present.
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! If this is a decimal array, the length is the number of 4 bit digits
! (not including the sign).  Convert this to the number of bytes.
! Decimal virtual arrays and record virtual arrays are stored with
! a length that is a multiple of 2 - check for that here also.
!-
    CASE .DESCRIP [DSC$B_DTYPE] FROM DSC$K_DTYPE_Z TO DSC$K_DTYPE_H OF
	SET
	
	[DSC$K_DTYPE_P]:		! decimal
	    BEGIN
	    LENGTH = (.DESCRIP [DSC$W_LENGTH]/2) + 1;
	    IF .DESCRIP [DSC$B_CLASS] EQL DSC$K_CLASS_BFA
	    THEN
		BEGIN

		LENGTH = ( INCR I FROM 1 TO 9 BY 1 DO
			       IF .LENGTH LSS (1 ^ .I)
			       THEN EXITLOOP (1 ^ .I) );
		END;
	    END;

	[DSC$K_DTYPE_Z]:		! record
	    BEGIN
	    LENGTH = .DESCRIP [DSC$W_LENGTH];
	    IF .DESCRIP [DSC$B_CLASS] EQL DSC$K_CLASS_BFA
	    THEN
		BEGIN

		LENGTH = ( INCR I FROM 1 TO 9 BY 1 DO
			       IF .LENGTH LSS (1 ^ .I)
			       THEN EXITLOOP (1 ^ .I) );
		END;
	    END;

	[INRANGE,OUTRANGE]:
	    LENGTH = .DESCRIP [DSC$W_LENGTH];
	TES;

!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = ACTUALPARAMETER (.INDEX_NUMBER + 2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.LENGTH) + .DESCRIP [DSC$A_A0];
!+
! Build a descriptor pointing to the value cell in the array.  If this
! is an array of descriptors, the descriptor is copied, otherwise it
! is constructed.
!-

    IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
    THEN
	BEGIN

	MAP
	    VALUE_LOCATION : REF BLOCK [8, BYTE];

	VALUE_DESCR [DSC$W_LENGTH] = .VALUE_LOCATION [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .VALUE_LOCATION [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = (IF (.VALUE_LOCATION [DSC$B_CLASS] EQLU DSC$K_CLASS_D) THEN DSC$K_CLASS_S
	    ELSE .VALUE_LOCATION [DSC$B_CLASS]);
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION [DSC$A_POINTER];
	VALUE_DESC_ADDR = .VALUE_LOCATION;
	IF .VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    BEGIN
	    MAP
		VALUE_LOCATION : REF BLOCK [12,BYTE];
	    VALUE_DESCR [DSC$B_SCALE] = .VALUE_LOCATION [DSC$B_SCALE];
	    END;
	END
    ELSE
	BEGIN
	VALUE_DESCR [DSC$W_LENGTH] = .DESCRIP [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .DESCRIP [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = DSC$K_CLASS_S;
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION;
	VALUE_DESC_ADDR = VALUE_DESCR;
	IF .VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    BEGIN
	    MAP
		DESCRIP : REF BLOCK [12,BYTE];
	    VALUE_DESCR [DSC$B_SCALE] = .DESCRIP [DSC$B_SCALE];	
	    END;
	END;

!+
! Make sure that the data type of the array element agrees with
! that of the result descriptor.
!-

    IF (.VALUE_DESCR [DSC$B_DTYPE] NEQU .VALUE [DSC$B_DTYPE]) THEN BAS$$STOP (BAS$K_DATTYPERR);

!+
! Special handling if this is a virtual array.  
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! If this is a string, remove trailing NULs when fetching it.
!-

	IF (.DESCRIP [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)
	THEN
	    BEGIN

	    LOCAL
		TEMP_DESC : BLOCK [8, BYTE],
		DATA_BUF : REF VECTOR [65535, BYTE],
		LEN;

	    TEMP_DESC [DSC$W_LENGTH] = 0;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    TEMP_DESC [DSC$A_POINTER] = 0;
	    STR$GET1_DX (DESCRIP [DSC$W_LENGTH], TEMP_DESC);
	    BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, .TEMP_DESC [DSC$A_POINTER]);
!+
! Now that we have it in temporary storage, remove its trailing NULs
!-
	    LEN = .TEMP_DESC [DSC$W_LENGTH];
	    DATA_BUF = .TEMP_DESC [DSC$A_POINTER];

	    WHILE ((.LEN GTR 0) AND (.DATA_BUF [.LEN - 1] EQL 0)) DO
		LEN = .LEN - 1;

!+
! Send the shortened string to the user.
!-
	    STR$COPY_R (.VALUE, LEN, .DATA_BUF);
!+
! Deallocate our temporary string.
!-
	    STR$FREE1_DX (TEMP_DESC);
	    END
	ELSE
	    BEGIN
	    IF .DESCRIP [DSC$B_DTYPE] NEQ DSC$K_DTYPE_P
	    THEN
	        BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, .VALUE [DSC$A_POINTER])
	    ELSE
		BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, .VALUE);
	    END
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Copy the array element to the value cell.  The form of the copy is
! based on the type of data.
!-

	CASE .VALUE [DSC$B_DTYPE] FROM DSC$K_DTYPE_Z TO DSC$K_DTYPE_H OF
	    SET

	    [DSC$K_DTYPE_B] :			! byte
		BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPUNIT, 1]
		= .BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPUNIT, 1];

	    [DSC$K_DTYPE_W] : 			! 16-bit word
		BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL/2, 1]	!
		= .BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL/2, 1];

	    [DSC$K_DTYPE_L] : 			! 32-bit longword
		BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL, 1]	!
		= .BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL, 1];

	    [DSC$K_DTYPE_F] : 			! 32-bit floating point
		BAS$$COPY_F_R1 (.VALUE_DESCR [DSC$A_POINTER], .VALUE [DSC$A_POINTER]);

	    [DSC$K_DTYPE_D] : 			! 64-bit double floating
		BAS$$COPY_D_R1 (.VALUE_DESCR [DSC$A_POINTER], .VALUE [DSC$A_POINTER]);

	    [DSC$K_DTYPE_G] :			! G floating
		BAS$$COPY_G_R1 (.VALUE_DESCR [DSC$A_POINTER], .VALUE [DSC$A_POINTER]);

	    [DSC$K_DTYPE_H] :			! H floating
		BAS$$COPY_H_R3 (.VALUE_DESCR [DSC$A_POINTER], .VALUE [DSC$A_POINTER]);

	    [DSC$K_DTYPE_T, DSC$K_DTYPE_Z] :	! Text string or record
		STR$COPY_DX (.VALUE, .VALUE_DESC_ADDR);

	    [DSC$K_DTYPE_P] :			! decimal
		BEGIN
		LOCAL
		    COUNT;
		COUNT = .VALUE_DESCR [DSC$B_SCALE] - .VALUE [DSC$B_SCALE];
		ASHP (COUNT, VALUE_DESCR [DSC$W_LENGTH],
		    .VALUE_DESCR [DSC$A_POINTER], %REF(0), VALUE [DSC$W_LENGTH],
		    .VALUE [DSC$A_POINTER]);
		END;

	    [INRANGE, OUTRANGE] :
		BAS$$STOP (BAS$K_DATTYPERR);

	    TES;

	END;

    END;					! end of BAS$FETCH_BFA


GLOBAL ROUTINE BAS$STORE_BFA (			! Store a value by descriptor
	VALUE : REF BLOCK [8, BYTE],		! Where to find the value
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store it
	INDEX1					! First index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a value in an array or virtual array.  The location from
!	which to fetch the value is passed by descriptor.
!
! FORMAL PARAMETERS:
!
!	VALUE.rx.dx	The place from which to get the value stored
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array.  More indicies
!			may follow this one in the calling sequence.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	ASHP;

    LOCAL
	INDEX_VALUE,
	VALUE_LOCATION,
	MULTIPLIERS : REF VECTOR,
	BOUNDS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	INDEX_NUMBER,
	VALUE_DESCR : BLOCK [12, BYTE],
	VALUE_DESC_ADDR,
	LENGTH;

!+
! Be sure the number of array subscripts matches the number of
! indicies given to us.
!-

    IF ((ACTUALCOUNT () - 2) NEQU .DESCRIP [DSC$B_DIMCT])
    THEN
	BEGIN

	IF ((ACTUALCOUNT () - 2) LSSU .DESCRIP [DSC$B_DIMCT])
	THEN
	    BAS$$STOP (BAS$K_TOOFEWARG)
	ELSE
	    BAS$$STOP (BAS$K_TOOMANARG);

	END;

!+
! The coefficients and bounds must be present.
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! If this is a decimal array, the length in the descriptor is the number of
! 4 bit digits (not including the sign).  Convert this length to the number
! of bytes.
! Also, if this is a virtual array, the size must be a multiple of 2.  This
! is true for arrays of records as well.
!-
    CASE .DESCRIP [DSC$B_DTYPE] FROM DSC$K_DTYPE_Z TO DSC$K_DTYPE_H OF
	SET

	[DSC$K_DTYPE_P] :		! decimal
	    BEGIN
	    LENGTH = (.DESCRIP [DSC$W_LENGTH]/2) + 1;
	    IF .DESCRIP [DSC$B_CLASS] EQL DSC$K_CLASS_BFA
	    THEN
		BEGIN

		LENGTH = ( INCR I FROM 1 TO 9 BY 1 DO
			       IF .LENGTH LSS (1 ^ .I)
			       THEN EXITLOOP (1 ^ .I) );
		END;
	    END;

	[DSC$K_DTYPE_Z] :		! record
	    BEGIN
	    LENGTH = .DESCRIP [DSC$W_LENGTH];
	    IF .DESCRIP [DSC$B_CLASS] EQL DSC$K_CLASS_BFA
	    THEN
		BEGIN

		LENGTH = ( INCR I FROM 1 TO 9 BY 1 DO
			       IF .LENGTH LSS (1 ^ .I)
			       THEN EXITLOOP (1 ^ .I) );
		END;
	    END;

	[INRANGE, OUTRANGE] :
	    LENGTH = .DESCRIP [DSC$W_LENGTH];
	TES;
	
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = ACTUALPARAMETER (.INDEX_NUMBER + 2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.LENGTH) + .DESCRIP [DSC$A_A0];
!+
! Build a descriptor pointing to the value cell in the array.  If this
! is an array of descriptors, the descriptor is copied, otherwise it
! is constructed.
!-

    IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
    THEN
	BEGIN

	MAP
	    VALUE_LOCATION : REF BLOCK [8, BYTE];

	VALUE_DESCR [DSC$W_LENGTH] = .VALUE_LOCATION [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .VALUE_LOCATION [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = (IF (.VALUE_LOCATION [DSC$B_CLASS] EQLU DSC$K_CLASS_D) THEN DSC$K_CLASS_S
	    ELSE .VALUE_LOCATION [DSC$B_CLASS]);
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION [DSC$A_POINTER];
	VALUE_DESC_ADDR = .VALUE_LOCATION;
	IF .VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    BEGIN
	    MAP
		VALUE_LOCATION : REF BLOCK [12,BYTE];
	    VALUE_DESCR [DSC$B_SCALE] = .VALUE_LOCATION [DSC$B_SCALE];
	    END;
	END
    ELSE
	BEGIN
	VALUE_DESCR [DSC$W_LENGTH] = .DESCRIP [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .DESCRIP [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = DSC$K_CLASS_S;
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION;
	VALUE_DESC_ADDR = VALUE_DESCR;
	IF .VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    BEGIN
	    MAP
		DESCRIP : REF BLOCK [12,BYTE];
	    VALUE_DESCR [DSC$B_SCALE] = .DESCRIP [DSC$B_SCALE];
	    END;
	END;

!+
! Make sure that the data type of the array element agrees with
! that of the source descriptor.
!-

    IF (.VALUE_DESCR [DSC$B_DTYPE] NEQU .VALUE [DSC$B_DTYPE]) THEN BAS$$STOP (BAS$K_DATTYPERR);

!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! If this is a string, we must pad it with NULs.  To do this, we need
! a temporary string.
!-

	IF (.DESCRIP [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)
	THEN
	    BEGIN

	    LOCAL
		NULLS_COUNT,
		TEMP_DESC : BLOCK [8, BYTE];

!+
! Copy the caller's string to our temporary.
!-
	    TEMP_DESC [DSC$W_LENGTH] = 0;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    TEMP_DESC [DSC$A_POINTER] = 0;
	    STR$COPY_DX (TEMP_DESC, .VALUE);
!+
! Concatenate enough NULs onto the string to make it the right length.
!-
	    NULLS_COUNT = .DESCRIP [DSC$W_LENGTH] - .TEMP_DESC [DSC$W_LENGTH];

	    IF (.NULLS_COUNT GTR 0)
	    THEN
		BEGIN

		LOCAL
		    NULLS_DESC : BLOCK [8, BYTE];

		NULLS_DESC [DSC$W_LENGTH] = 1;
		NULLS_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		NULLS_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
		NULLS_DESC [DSC$A_POINTER] = 0;
		STR$DUPL_CHAR (NULLS_DESC, %REF (.NULLS_COUNT), %REF (0));
		STR$CONCAT (TEMP_DESC, TEMP_DESC, NULLS_DESC);
		STR$FREE1_DX (NULLS_DESC);
		END;

!+
! Now store the (possibly lengthened) string in the file.
!-
	    BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .TEMP_DESC [DSC$A_POINTER]);
!+
! Free our temporary string.
!-
	    STR$FREE1_DX (TEMP_DESC);
	    END
	ELSE
	    BEGIN
	    IF .DESCRIP [DSC$B_DTYPE] NEQ DSC$K_DTYPE_P
	    THEN
	        BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .VALUE [DSC$A_POINTER])
	    ELSE
		BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .VALUE);
	    END
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Copy the value cell to the array element.  The form of the copy is
! based on the type of data.
!-

	CASE .VALUE [DSC$B_DTYPE] FROM DSC$K_DTYPE_Z TO DSC$K_DTYPE_H OF
	    SET

	    [DSC$K_DTYPE_B] :			! byte
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPUNIT, 1]
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPUNIT, 1];

	    [DSC$K_DTYPE_W] : 			! 16-bit word
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL/2, 1]	!
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL/2, 1];

	    [DSC$K_DTYPE_L] : 			! 32-bit longword
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL, 1]	!
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL, 1];

	    [DSC$K_DTYPE_F] : 			! 32-bit floating point
		BAS$$COPY_F_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_D] : 			! 64-bit double floating
		BAS$$COPY_D_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_G] :			! G floating
		BAS$$COPY_G_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_H] :			! H floating
		BAS$$COPY_H_R3 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_T, DSC$K_DTYPE_Z] :	! Text string or record
		STR$COPY_DX (.VALUE_DESC_ADDR, .VALUE);

	    [DSC$K_DTYPE_P] : 			! decimal
	 	BEGIN
		MAP
		    VALUE : REF BLOCK [12,BYTE];
		LOCAL
		    COUNT;
		COUNT = .VALUE [DSC$B_SCALE] - .VALUE_DESCR [DSC$B_SCALE];
		ASHP (COUNT, VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
		    %REF(0), VALUE_DESCR [DSC$W_LENGTH], .VALUE_DESCR [DSC$A_POINTER]);
		END;

	    [INRANGE, OUTRANGE] :
		BAS$$STOP (BAS$K_DATTYPERR);

	    TES;

	END;

    END;					! end of BAS$STORE_BFA


GLOBAL ROUTINE BAS$STORE_BFA_OFF (		! Store a value by desc w/offset
	VALUE : REF BLOCK [8, BYTE],		! Where to find the value
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store it
	OFFSET,					! Offset into record
	STR_LENGTH,				! String length (if string VALUE)
	INDEX1					! First index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a value in an array or virtual array.  The location from
!	which to fetch the value is passed by descriptor.  This is a special
!	routine to handle record arrays - the offset specifies an element
!	in the record.
!
! FORMAL PARAMETERS:
!
!	VALUE.rx.dx	The place from which to get the value stored
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	OFFSET.rlu.v	Offset into the record
!	STR_LENGTH.rlu.v Length if string VALUE, 0 otherwise
!	INDEX1.rl.v	The first index into the array.  More indicies
!			may follow this one in the calling sequence.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	ASHP;

    LOCAL
	INDEX_VALUE,
	VALUE_LOCATION,
	MULTIPLIERS : REF VECTOR,
	BOUNDS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	INDEX_NUMBER,
	VALUE_DESCR : BLOCK [12, BYTE],
	VALUE_DESC_ADDR,
	LENGTH;

!+
! Be sure the number of array subscripts matches the number of
! indicies given to us.
!-

    IF ((ACTUALCOUNT () - 4) NEQU .DESCRIP [DSC$B_DIMCT])
    THEN
	BEGIN

	IF ((ACTUALCOUNT () - 4) LSSU .DESCRIP [DSC$B_DIMCT])
	THEN
	    BAS$$STOP (BAS$K_TOOFEWARG)
	ELSE
	    BAS$$STOP (BAS$K_TOOMANARG);

	END;

!+
! The coefficients and bounds must be present.
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! If this is a decimal array, the length in the descriptor is the number of
! 4 bit digits (not including the sign).  Convert this length to the number
! of bytes.
! Also, if this is a virtual array, the size must be a multiple of 2.  This
! is true for arrays of records as well.
!-
    CASE .DESCRIP [DSC$B_DTYPE] FROM DSC$K_DTYPE_Z TO DSC$K_DTYPE_H OF
	SET

	[DSC$K_DTYPE_P] :		! decimal
	    BEGIN
	    LENGTH = (.DESCRIP [DSC$W_LENGTH]/2) + 1;
	    IF .DESCRIP [DSC$B_CLASS] EQL DSC$K_CLASS_BFA
	    THEN
		BEGIN

		LENGTH = ( INCR I FROM 1 TO 9 BY 1 DO
			       IF .LENGTH LSS (1 ^ .I)
			       THEN EXITLOOP (1 ^ .I) );
		END;
	    END;

	[DSC$K_DTYPE_Z] :		! record
	    BEGIN
	    LENGTH = .DESCRIP [DSC$W_LENGTH];
	    IF .DESCRIP [DSC$B_CLASS] EQL DSC$K_CLASS_BFA
	    THEN
		BEGIN

		LENGTH = ( INCR I FROM 1 TO 9 BY 1 DO
			       IF .LENGTH LSS (1 ^ .I)
			       THEN EXITLOOP (1 ^ .I) );
		END;
	    END;

	[INRANGE, OUTRANGE] :
	    LENGTH = .DESCRIP [DSC$W_LENGTH];
	TES;
	
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = ACTUALPARAMETER (.INDEX_NUMBER + 4);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.LENGTH) + .DESCRIP [DSC$A_A0];

!+
! Add the offset to the linear index to arrive at the desired element within
! the record.
!-
    VALUE_LOCATION = .VALUE_LOCATION + .OFFSET;

!+
! Build a descriptor pointing to the value cell in the array.  If this
! is an array of descriptors, the descriptor is copied, otherwise it
! is constructed.
!-

    IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
    THEN
	BEGIN

	MAP
	    VALUE_LOCATION : REF BLOCK [8, BYTE];

	VALUE_DESCR [DSC$W_LENGTH] = .VALUE_LOCATION [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .VALUE_LOCATION [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = (IF (.VALUE_LOCATION [DSC$B_CLASS] EQLU DSC$K_CLASS_D) THEN DSC$K_CLASS_S
	    ELSE .VALUE_LOCATION [DSC$B_CLASS]);
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION [DSC$A_POINTER];
	VALUE_DESC_ADDR = .VALUE_LOCATION;
	IF .VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    BEGIN
	    MAP
		VALUE_LOCATION : REF BLOCK [12,BYTE];
	    VALUE_DESCR [DSC$B_SCALE] = .VALUE_LOCATION [DSC$B_SCALE];
	    END;
	END
    ELSE
	BEGIN
	VALUE_DESCR [DSC$W_LENGTH] = (IF .VALUE [DSC$B_DTYPE] EQL DSC$K_DTYPE_T
				      OR .VALUE [DSC$B_DTYPE] EQL DSC$K_DTYPE_Z
				      THEN .STR_LENGTH
				      ELSE .VALUE [DSC$W_LENGTH]);
	VALUE_DESCR [DSC$B_DTYPE] = .VALUE [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = DSC$K_CLASS_S;
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION;
	VALUE_DESC_ADDR = VALUE_DESCR;
	IF .VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    BEGIN
	    MAP
		DESCRIP : REF BLOCK [12,BYTE];
	    VALUE_DESCR [DSC$B_SCALE] = .DESCRIP [DSC$B_SCALE];
	    END;
	END;

!+
! Make sure that the data type of the array element agrees with
! that of the source descriptor.
!-

    IF (.VALUE_DESCR [DSC$B_DTYPE] NEQU .VALUE [DSC$B_DTYPE]) THEN BAS$$STOP (BAS$K_DATTYPERR);

!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    SAVE_LENGTH;
	!+
	! KLUDGE!!! dummy up the array length descriptor to contain
	! 	    the length of the element in the record we are
	!	    interested in.
	!-
	SAVE_LENGTH = .DESCRIP [DSC$W_LENGTH];
	DESCRIP [DSC$W_LENGTH] = ( IF DESCRIP [DSC$B_DTYPE] EQL DSC$K_DTYPE_P
				   THEN .VALUE_DESCR [DSC$W_LENGTH] / 2 + 1
				   ELSE	.VALUE_DESCR [DSC$W_LENGTH] );

	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! If this is a string, we must pad it with SPACES.  To do this, we need
! a temporary string.
!-

	IF (.VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)
	OR (.VALUE_DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_Z)
	THEN
	    BEGIN

	    LOCAL
		SPACES_COUNT,
		TEMP_DESC : BLOCK [8, BYTE];

!+
! Copy the caller's string to our temporary.
!-
	    TEMP_DESC [DSC$W_LENGTH] = 0;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    TEMP_DESC [DSC$A_POINTER] = 0;
	    STR$COPY_DX (TEMP_DESC, .VALUE);
!+
! Concatenate enough SPACES onto the string to make it the right length.
!-
	    SPACES_COUNT = .VALUE_DESCR [DSC$W_LENGTH] - .TEMP_DESC [DSC$W_LENGTH];

	    IF (.SPACES_COUNT GTR 0)
	    THEN
		BEGIN

		LOCAL
		    SPACES_DESC : BLOCK [8, BYTE];

		SPACES_DESC [DSC$W_LENGTH] = 1;
		SPACES_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		SPACES_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
		SPACES_DESC [DSC$A_POINTER] = 0;
		STR$DUPL_CHAR (SPACES_DESC, %REF (.SPACES_COUNT), %REF (%X'20'));
		STR$CONCAT (TEMP_DESC, TEMP_DESC, SPACES_DESC);
		STR$FREE1_DX (SPACES_DESC);
		END;

!+
! Now store the (possibly lengthened) string in the file.
!-
	    BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .TEMP_DESC [DSC$A_POINTER]);
!+
! Free our temporary string.
!-
	    STR$FREE1_DX (TEMP_DESC);
	    END
	ELSE
	    BEGIN
	        BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .VALUE [DSC$A_POINTER])
	    END;

	!+
	! put length field in array descriptor back the way
	! it was before we KLUDGED it!
	!-
	DESCRIP [DSC$W_LENGTH] = .SAVE_LENGTH;
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Copy the value cell to the array element.  The form of the copy is
! based on the type of data.
!-

	CASE .VALUE [DSC$B_DTYPE] FROM DSC$K_DTYPE_Z TO DSC$K_DTYPE_H OF
	    SET

	    [DSC$K_DTYPE_B] :			! byte
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPUNIT, 1]
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPUNIT, 1];

	    [DSC$K_DTYPE_W] : 			! 16-bit word
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL/2, 1]	!
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL/2, 1];

	    [DSC$K_DTYPE_L] : 			! 32-bit longword
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL, 1]	!
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL, 1];

	    [DSC$K_DTYPE_F] : 			! 32-bit floating point
		BAS$$COPY_F_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_D] : 			! 64-bit double floating
		BAS$$COPY_D_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_G] :			! G floating
		BAS$$COPY_G_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_H] :			! H floating
		BAS$$COPY_H_R3 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_T, DSC$K_DTYPE_Z] :	! Text string or record
		STR$COPY_DX (.VALUE_DESC_ADDR, .VALUE);

	    [DSC$K_DTYPE_P] : 			! decimal
	 	BEGIN
		MAP
		    VALUE : REF BLOCK [12,BYTE];
		LOCAL
		    COUNT;
		COUNT = .VALUE [DSC$B_SCALE] - .VALUE_DESCR [DSC$B_SCALE];
		ASHP (COUNT, VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
		    %REF(0), VALUE_DESCR [DSC$W_LENGTH], .VALUE_DESCR [DSC$A_POINTER]);
		END;

	    [INRANGE, OUTRANGE] :
		BAS$$STOP (BAS$K_DATTYPERR);

	    TES;

	END;

    END;					! end of BAS$STORE_BFA_OFF


GLOBAL ROUTINE BAS$STO_FA_RDX (			! Store a string by reference
	VALUE_LEN, 				! Length of value
	VALUE_ADDR, 				! Address of value
	DESCRIP, 				! The descriptor to store it
	INDEX1, 				! First index
	INDEX2					! Optional second index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a string in an array or virtual array.  The string is
!	passed by reference.  The compiler uses this entry point
!	to avoid creating a descriptor for a string constant.
!
! FORMAL PARAMETERS:
!
!	VALUE_LEN.rl.v	The length of the string to be stored
!	VALUE_ADDR.rt.r	The address of the string to be stored
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array.
!	INDEX2.rl.v	The second index.  This is optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	VALUE : BLOCK [8, BYTE];		! Build descriptor here

    VALUE [DSC$W_LENGTH] = .VALUE_LEN;
    VALUE [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    VALUE [DSC$B_CLASS] = DSC$K_CLASS_S;
    VALUE [DSC$A_POINTER] = .VALUE_ADDR;

    IF (ACTUALCOUNT () LSS 5)
    THEN
	BAS$STORE_BFA (VALUE, .DESCRIP, .INDEX1)
    ELSE
	BAS$STORE_BFA (VALUE,
	    .DESCRIP, .INDEX1, .INDEX2);

    END;					! end of BAS$STO_FA_RDX


GLOBAL ROUTINE BAS$FET_FA_W_R8 (		! Fetch a word
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a 16-bit word from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rw.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The word from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds words.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_W) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+ 
	    ! Special handling for dynamically mapped arrays.
 	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_W)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);


!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+ 
	! Special handling for dynamically mapped arrays.
 	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
	
!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	VALUE = 0;
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    RETURN (.BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL/2, 1]);
    END;					! end of BAS$FET_FA_W_R8


GLOBAL ROUTINE BAS$STO_FA_W_R8 (		! Store a word
	VALUE, 					! The value to store
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 16-bit word in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rw.v	The value to store
!	DESCRIP.rw.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds words.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_W) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL/2, 1] = .VALUE;
	END;

    END;					! end of BAS$STO_FA_W_R8


GLOBAL ROUTINE BAS$FET_FA_L_R8 (		! Fetch a longword
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a 32-bit longword from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rl.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The longword from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
    	TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds longwords.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_L) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+ 
	    ! Special handling for dynamically mapped arrays.
 	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_L)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+ 
	! Special handling for dynamically mapped arrays.
 	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    RETURN (.BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL, 1]);
    END;					! end of BAS$FET_FA_L_R8


GLOBAL ROUTINE BAS$STO_FA_L_R8 (		! Store a longword
	VALUE, 					! The value to store
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 32-bit longword in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rl.v	The value to store
!	DESCRIP.rl.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds longwords.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_L) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL, 1] = .VALUE;
	END;

    END;					! end of BAS$STO_FA_L_R8


GLOBAL ROUTINE BAS$FET_FA_F_R8 (		! Fetch a floating number
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a single precision floating number from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rf.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The number from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE,
        TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_F) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+ 
	    ! Special handling for dynamically mapped arrays.
 	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_F)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+ 
	! Special handling for dynamically mapped arrays.
 	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Fetch the value using the MOVF instruction to be sure that it is not
! a floating reserved operand.
!-
    BAS$$COPY_F_R1 (.VALUE_LOCATION, VALUE);
!+
! Return the array element as our value.
!-
    RETURN (.VALUE);
    END;					! end of BAS$FET_FA_F_R8


GLOBAL ROUTINE BAS$STO_FA_F_R8 (		! Store a floating value
	VALUE, 					! The value to store
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a single-precision value in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rf.v	The value to store
!	DESCRIP.rf.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_F) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BAS$$COPY_F_R1 (VALUE, .VALUE_LOCATION);
	END;

    END;					! end of BAS$STO_FA_F_R8


GLOBAL ROUTINE BAS$FET_FA_D_R8 (		! Fetch a double-floating
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a double-floating number from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The double floating number from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [2],
        TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds double-floating numbers.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_D) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+
	    ! Special handling for dynamically mapped arrays.
	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_D)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+
	! Special handling for dynamically mapped arrays.
	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	BEGIN

	REGISTER
	    R0 = 0,
	    R1 = 1;

	R0 = .VALUE [0];
	R1 = .VALUE [1];
	RETURN;
	END;
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    BEGIN

    REGISTER
	R0 = 0,
	R1 = 1;

    BAS$$COPY_D_R1 (.VALUE_LOCATION, VALUE);
    R0 = .VALUE [0];
    R1 = .VALUE [1];
    RETURN;
    END;
    END;					! end of BAS$FET_FA_D_R8


GLOBAL ROUTINE BAS$STO_FA_D_R8 (		! Store a double-floating value
	VALUE0, 				! The value to store
	VALUE1, 
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 64-bit double floating value in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.v	The value to store
!			(Passed as two longwords: VALUE0 and VALUE1)
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [2];

!+
! Put the double-precision input value into a local where it will be
! safe.
!-
    VALUE [0] = .VALUE0;
    VALUE [1] = .VALUE1;
!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds double-floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_D) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BAS$$COPY_D_R1 (VALUE [0], .VALUE_LOCATION);
	END;

    END;					! end of BAS$STO_FA_D_R8

GLOBAL ROUTINE BAS$FET_FA_B_R8 (		! Fetch a byte
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a byte from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rw.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The byte from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
    	TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds bytes.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_B) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+ 
	    ! Special handling for dynamically mapped arrays.
 	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_B)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+ 
	! Special handling for dynamically mapped arrays.
 	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	VALUE = 0;
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    RETURN (.BLOCK [.VALUE_LOCATION, 0, 0, %BPUNIT, 1]);
    END;					! end of BAS$FET_FA_B_R8

GLOBAL ROUTINE BAS$FET_FA_G_R8 (		! Fetch a g floating
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a g floating number from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The g floating number from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [2],
        TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds g floating numbers.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_G) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+
	    ! Special handling for dynamically mapped arrays.
	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_G)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+
	! Special handling for dynamically mapped arrays.
	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	BEGIN

	REGISTER
	    R0 = 0,
	    R1 = 1;

	R0 = .VALUE [0];
	R1 = .VALUE [1];
	RETURN;
	END;
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    BEGIN

    REGISTER
	R0 = 0,
	R1 = 1;

    BAS$$COPY_G_R1 (.VALUE_LOCATION, VALUE);
    R0 = .VALUE [0];
    R1 = .VALUE [1];
    RETURN;
    END;
    END;					! end of BAS$FET_FA_G_R8


GLOBAL ROUTINE BAS$FET_FA_H_R8 (		! Fetch an h floating
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch an h floating number from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The h floating number from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [4],
        TEMP_DESCRIP: REF BLOCK[,BYTE];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds h floating numbers.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_H) 
    THEN 
	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
	THEN
	    !+
	    ! Special handling for dynamically mapped arrays.
	    !-
	    BEGIN

	    TEMP_DESCRIP = .DESCRIP [DSC$A_POINTER];
	    IF (.TEMP_DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_H)
	    THEN
		BAS$$STOP (BAS$K_ARGDONMAT);
	
	    END
	ELSE
	    BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
    IF .DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC
    THEN
	!+
	! Special handling for dynamically mapped arrays.
	!-
	BEGIN

	TEMP_DESCRIP = .VALUE_LOCATION;
	VALUE_LOCATION = .TEMP_DESCRIP [DSC$A_POINTER];

	END;
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	BEGIN

	REGISTER
	    R0 = 0,
	    R1 = 1,
	    R2 = 2,
	    R3 = 3;

	R0 = .VALUE [0];
	R1 = .VALUE [1];
	R2 = .VALUE [2];
	R3 = .VALUE [3];
	RETURN;
	END;
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    BEGIN

    REGISTER
	R0 = 0,
	R1 = 1,
	R2 = 2,
	R3 = 3;

    BAS$$COPY_H_R3 (.VALUE_LOCATION, VALUE);
    R0 = .VALUE [0];
    R1 = .VALUE [1];
    R2 = .VALUE [2];
    R3 = .VALUE [3];
    RETURN;
    END;
    END;					! end of BAS$FET_FA_H_R8


GLOBAL ROUTINE BAS$STO_FA_B_R8 (		! Store a byte
	VALUE, 					! The value to store
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a byte in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rb.v	The value to store
!	DESCRIP.rw.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds words.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_B) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BLOCK [.VALUE_LOCATION, 0, 0, %BPUNIT, 1] = .VALUE;
	END;

    END;					! end of BAS$STO_FA_B_R8

GLOBAL ROUTINE BAS$STO_FA_G_R8 (		! Store a g floating value
	VALUE0, 				! The value to store
	VALUE1, 
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 64-bit g floating value in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rg.v	The value to store
!			(Passed as two longwords: VALUE0 and VALUE1)
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [2];

!+
! Put the g floating input value into a local where it will be
! safe.
!-
    VALUE [0] = .VALUE0;
    VALUE [1] = .VALUE1;
!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds g floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_G) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BAS$$COPY_G_R1 (VALUE [0], .VALUE_LOCATION);
	END;

    END;					! end of BAS$STO_FA_G_R8

GLOBAL ROUTINE BAS$STO_FA_H_R8 (		! Store an h floating value
	VALUE0, 				! The value to store
	VALUE1,					!
	VALUE2,					!
	VALUE3,					!
	DESCRIP : REF BLOCK [8, BYTE],		! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store an h floating value in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rl.v	The value to store
!			(Passed as four longwords)
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [4];

!+
! Put the h floating input value into a local where it will be
! safe.
!-
    VALUE [0] = .VALUE0;
    VALUE [1] = .VALUE1;
    VALUE [2] = .VALUE2;
    VALUE [3] = .VALUE3;
!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds h floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_H) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BAS$$COPY_H_R3 (VALUE [0], .VALUE_LOCATION);
	END;

    END;					! end of BAS$STO_FA_H_R8

END						! end of module BAS$VIRTUAL_ARR

ELUDOM
