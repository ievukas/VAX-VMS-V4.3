MODULE	DBGVALUES(IDENT = 'V04-000') =
BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 DEBUG
!
! ABSTRACT:
!
!	Language-Independent Value Descriptor support routines
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR:	J. Francis,	CREATION DATE: 19-Apr-1982
!
! MODIFIED BY:
!
!	001	WC3	21-Jun-83
!		Add support for /PACKED and /DATE_TIME
!
!	002	WC3	15-Jul-83
!		Fix /DATE_TIME to use DBG$CVT_DX_DX
!
!	003	WC3	15-Sep-83
!		Update DBG$GL_CURRENT_PRIMARY for self-referential records
!
!	004	WC3	22-Sep-83
!		Check for variant records that have been optomized away
!		but the DST is still around.
!--

!
! Table of Contents
!
FORWARD ROUTINE
! Global Routines :
    dbg$data_length,
    dbg$make_skeleton_desc,
    dbg$make_integer_desc,
    dbg$fill_in_vms_desc,			! fill in vms descriptor
    dbg$make_val_desc,				! Create  value  descriptor
    dbg$make_vms_desc,				! Create VAX/VMS descriptor
    dbg$prim_to_val,				! Get value of a primary
    dbg$print_aggregate 	: NOVALUE,	! Print aggregate value
    dbg$print_value		: NOVALUE,	! Print value from DEBUG descriptor
    dbg$print_value_as_integer	: NOVALUE,	! Print integer in given radix
    dbg$print_vms_value		: NOVALUE;	! Print value from VMS descriptor

!
! INCLUDE FILES
!
REQUIRE 'SRC$:DBGPROLOG';
!
!
! EXTERNALS
!
EXTERNAL
    dbg$gl_current_primary,			! Ponter to the primary being processed
    dbg$gb_radix	: VECTOR[3, BYTE],	! Radix settings
    dbg$gb_language	: BYTE,			! Current language
    dbg$gv_control	: dbg$control_flags,	! DEBUG status information
    dbg$gl_call_context,			! Context for 'Bound' values
    dbg$gl_convert_token,			! "Integerize" operator token
    dbg$gl_dflttyp,				! Default type from "SET TYPE"
    dbg$gw_dfltleng	: WORD,			! Length of default data-type
    dbg$gl_sign_flag;				! Print '+' before the signed
    						!        variable.

EXTERNAL ROUTINE
    dbg$build_primary_subnode	: NOVALUE,	! Add sub-node to primary
    dbg$collect			: NOVALUE,	! Sanitize character vectors
    dbg$cvt_dx_dx		: NOVALUE,	! Convert data-types by descriptor
    dbg$enum_pos,				! Convert value->pos for enum type
    dbg$enum_succ,				! Find successor of enum type
    dbg$enum_val,				! Convert pos->value for enum type
    dbg$get_tempmem,				! Storage space allocator
    dbg$is_it_entry,				! Check for CALL entry-mask address
    dbg$ins_decode,				! Print an instruction
    dbg$language_format,			! Language override output
    dbg$newline			: NOVALUE,	! Print buffer contents
    dbg$nget_radix,				! Obtain radix
    dbg$print			: NOVALUE,	! Print under FAO format
    dbg$print_control		: NOVALUE,	! Control print format
    dbg$print_identifier,			! Print name of data item
    dbg$print_set_value		: NOVALUE,	! Print value of set
    dbg$print_symbol_name	: NOVALUE,	! Print name from a SYMID
    dbg$push_tempmem,				! Mark current position
    dbg$pop_tempmem		: NOVALUE,	! Release marked storage
    dbg$save_val		: NOVALUE,	! Save value for %CURVAL
    dbg$sta_setcontext		: NOVALUE,	! Establish RST context
    dbg$sta_sympathname		: NOVALUE,	! Get fully-qualified data name
    dbg$sta_symkind		: NOVALUE,	! Get  kind   of data item
    dbg$sta_symname		: NOVALUE,	! Get  name   of data item
    dbg$sta_symsize		: NOVALUE,	! Get length  of data item
    dbg$sta_symtype		: NOVALUE,	! Get  type   of data item
    dbg$sta_symvalue		: NOVALUE,	! Get address of data item
    dbg$sta_typefcode,				! Get  FCODE  of data item
    dbg$sta_typ_atomic		: NOVALUE,	! Get symbol table information
    dbg$sta_typ_descr		: NOVALUE,	! Get symbol table information
    dbg$sta_typ_enum		: NOVALUE,	! Get symbol table information
    dbg$sta_typ_record		: NOVALUE,	! Get symbol table information
    dbg$sta_typ_subrng		: NOVALUE,	! Get symbol table information
    dbg$sta_typ_typedptr	: NOVALUE,	! Get symbol table information
    dbg$sta_variant_value,			! Check value of Variant Tag
    dbg$sta_variant_select,			! Get variant entry (by tag)
    for$cvt_d_tg,				! Conversion routine
    for$cvt_g_tg,				! Conversion routine
    for$cvt_h_tg;				! Conversion routine

OWN
    signed_dtype	: BITVECTOR[dbg$k_maximum_dtype+1] PRESET(
	[dsc$k_dtype_f  ] = 1,
	[dsc$k_dtype_d  ] = 1,
	[dsc$k_dtype_g  ] = 1,
	[dsc$k_dtype_h  ] = 1,
	[dsc$k_dtype_b  ] = 1,
	[dsc$k_dtype_w  ] = 1,
	[dsc$k_dtype_l  ] = 1,
	[dsc$k_dtype_q  ] = 1,
	[dsc$k_dtype_o  ] = 1,
	[dsc$k_dtype_p  ] = 1,
	[dsc$k_dtype_nz ] = 1,
	[dsc$k_dtype_nl ] = 1,
	[dsc$k_dtype_nlo] = 1,
	[dsc$k_dtype_nr ] = 1,
	[dsc$k_dtype_nro] = 1,
	[dsc$k_dtype_sv ] = 1,
	[dsc$k_dtype_svu] = 1);


BIND
    Format_AC = UPLIT BYTE(%ASCIC '!AC'),
    Format_AD = UPLIT BYTE(%ASCIC '!AD');

GLOBAL ROUTINE DBG$DATA_LENGTH (vms_desc : REF dbg$stg_desc) =
!
! FUNCTION
!	Given a VMS descriptor, this routine returns the length in
!	bits of the object described by the descriptor.
!
!	Note - for array descriptors, this routine returns the length
!	in bits of an element of the array. Do not change it to
!	return the length of the entire array - things will break.
!
    BEGIN
    LOCAL length;
    
    ! Obtain the length from the descriptor. We do not yet know whether
    ! this length is in bits, nibbles, or bytes.
    !
    length = .vms_desc[dsc$w_length];

    ! Decide whether the length is in bits, nibbles, or bytes, based
    ! on the dtype.
    !
    IF .vms_desc[dsc$b_dtype] EQL dst$k_bool
    THEN
    	length = .length * 1

    ELSE CASE .vms_desc[dsc$b_dtype] FROM dbg$k_minimum_dtype TO dbg$k_maximum_dtype OF
	SET
	[dsc$k_dtype_f  ,dsc$k_dtype_fc ,dsc$k_dtype_d  ,dsc$k_dtype_dc ,
	 dsc$k_dtype_g  ,dsc$k_dtype_gc ,dsc$k_dtype_h  ,dsc$k_dtype_hc ,
	 dsc$k_dtype_b  ,dsc$k_dtype_bu ,dsc$k_dtype_w  ,dsc$k_dtype_wu ,
	 dsc$k_dtype_l  ,dsc$k_dtype_lu ,dsc$k_dtype_q  ,dsc$k_dtype_qu ,
	 dsc$k_dtype_o  ,dsc$k_dtype_ou ,dsc$k_dtype_t,  dsc$k_dtype_z  ,
	 dsc$k_dtype_nl ,dsc$k_dtype_nlo,dsc$k_dtype_nr ,dsc$k_dtype_nro,
	 dsc$k_dtype_nu ,dsc$k_dtype_nz ,dsc$k_dtype_zi ,dsc$k_dtype_zem,
	 dsc$k_dtype_dsc,dsc$k_dtype_bpv,dsc$k_dtype_blv,dsc$k_dtype_adt]:	! M002

				length = .length * %BPUNIT;

	[dsc$k_dtype_vt] :	length = (.length + 2) * %BPUNIT;

	[dsc$k_dtype_p] :    length = (.length/2 + 1) * %BPUNIT;

	[dsc$k_dtype_tf,dsc$k_dtype_vu,dsc$k_dtype_svu] :	0;

	[dsc$k_dtype_v ,dsc$k_dtype_sv] :   IF (.length EQL 0) AND
			      (.vms_desc[dsc$b_class] EQL dsc$k_class_z) THEN
				length = .vms_desc[dsc$l_pos];

	[dsc$k_dtype_ac] :	length = (1 + 
				.(.vms_desc[dsc$a_pointer])<0,8,0>) * %BPUNIT;
				
	[dsc$k_dtype_az] :	BEGIN
				BIND chrvec = vms_desc[dsc$a_pointer] : REF VECTOR [,BYTE];
				LOCAL index;
    				index = 0;
				WHILE .index LEQ 2046 DO
    				  BEGIN
				  IF .chrvec[.index] EQL 0 THEN EXITLOOP;
    				  index = .index + 1;
    				  END;
				length = (.index+1) * %BPUNIT;
				END;

	[INRANGE,OUTRANGE] :	length = .length * %BPUNIT;
	TES;

    RETURN .length;
    END;			! End of 'dbg$data_length'

GLOBAL ROUTINE DBG$MAKE_SKELETON_DESC(desc_type,data_length) =
    BEGIN
    BUILTIN ACTUALCOUNT;
    LOCAL
	desc_length,
	result_desc	: REF BLOCK [,LONG] FIELD(dbg$dhdr_fields);

    SELECTONE .desc_type OF
	SET
	[dbg$k_v_value_desc]:	desc_length = %UPVAL*dbg$k_valdesc_base_size + 16;

	[dbg$k_value_desc]:	BEGIN
				desc_length = %UPVAL*dbg$k_valdesc_base_size + 16;
				IF actualcount() GTR 1 THEN
				  IF .data_length GTR 16 THEN
				    desc_length = .data_length + %UPVAL*dbg$k_valdesc_base_size;
				END;

	[dbg$k_primary_desc]:	BEGIN
				desc_length = 20;
				IF actualcount() GTR 1 THEN
				    desc_length = .desc_length + .data_length;
				END;

	[OTHERWISE]:		SIGNAL();
	TES;

    result_desc = dbg$get_tempmem((.desc_length + (%UPVAL-1)) / %UPVAL);
    result_desc[dbg$b_dhdr_lang]   = %X'FF';
    result_desc[dbg$b_dhdr_type]   = .desc_type;
    result_desc[dbg$w_dhdr_length] = .desc_length;
    RETURN .result_desc;

    END;			! End of 'dbg$make_skeleton_desc'

GLOBAL ROUTINE DBG$MAKE_INTEGER_DESC(VALUE) =
!
! ROUTINE DESCRIPTION
!	Given an integer value, this routine builds a value descriptor
!	for that integer.
!
! INPUTS
!	VALUE	- The integer value
!
! OUTPUTS
!	A pointer to the constructed value descriptor is returned.
!	The descriptor is built out of temporary memory.
!
    BEGIN
    LOCAL
    	TEMP_DESC: REF DBG$VALDESC;

    TEMP_DESC = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC);
    TEMP_DESC[DBG$B_DHDR_KIND] = RST$K_DATA;
    TEMP_DESC[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    TEMP_DESC[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    TEMP_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    TEMP_DESC[DBG$W_VALUE_LENGTH] = 4;
    TEMP_DESC[DBG$L_VALUE_POINTER] = TEMP_DESC[DBG$A_VALUE_ADDRESS];
    TEMP_DESC[DBG$L_VALUE_VALUE0] = .VALUE;
    RETURN .TEMP_DESC;
    END;

GLOBAL ROUTINE DBG$MAKE_VAL_DESC (desc_ptr,target_type) =
! 
! ROUTINE DESCRIPTION
!	Given a VMS descriptor, this routine builds either a Value Descriptor
!	or a Volatile Value Descriptor around the VMS descriptor.
!	In the case where a Value Descriptor is constructed, we need to 
!	extract the value represented by the VMS descriptor, and put
!	this value inside the Value Descriptor. So, for descriptors 
!	representing bitfields, this routine is where the actual extraction
!	of the bits takes place.
!
! INPUTS
!	DESC_PTR	- Points to a Vax-standard VMS descriptor
!	TARGET_TYPE	- A constant which can be one of:
!			  DBG$K_VALUE_DESC   or   DBG$K_V_VALUE_DESC
! OUTPUTS
!	A Value Descriptor or a Volatile Value Descriptor is constructed
!	out of temporary memory. A pointer to this descriptor is returned.
!
    BEGIN
    LOCAL
	vms_desc	: dbg$stg_desc,
	bits,bytes,
	result_desc	: REF dbg$valdesc;

    !+
    ! The first thing we do is to 'de-reference' data items of type
    ! descriptor which is what we get for arrays of dynamic strings.
    !-
    ch$move(12,.desc_ptr,vms_desc);
    IF .target_type EQL dbg$k_value_desc THEN
      WHILE .vms_desc[dsc$b_dtype] EQL dsc$k_dtype_dsc DO
	BEGIN
	BUILTIN PROBER;
	LOCAL addr;
	addr = .vms_desc[dsc$a_pointer];
	IF NOT PROBER(%REF(0),%REF(8),.addr) THEN SIGNAL(dbg$_noaccessr,1,.addr);
	ch$move(8,.addr,vms_desc);
	CASE .vms_desc[dsc$b_class] FROM dsc$k_class_z TO dsc$k_class_ubs
	 OF SET
	    [dsc$k_class_s,dsc$k_class_d,dsc$k_class_vs] :
		BEGIN
		IF  .vms_desc[dsc$b_class] EQL dsc$k_class_d
		THEN vms_desc[dsc$b_class]  =  dsc$k_class_s;
		IF  .vms_desc[dsc$b_dtype] EQL dsc$k_dtype_vt
		THEN vms_desc[dsc$b_class]  =  dsc$k_class_vs;
		IF  .vms_desc[dsc$b_class] EQL dsc$k_class_vs
		AND .vms_desc[dsc$b_dtype] EQL dsc$k_dtype_t
		THEN vms_desc[dsc$b_dtype]  =  dsc$k_dtype_vt;
		vms_desc[dsc$l_pos] = 0;
		END;

	    [dsc$k_class_sd,dsc$k_class_ubs] :
		BEGIN
		IF NOT PROBER(%REF(0),%REF(4),.addr+8) THEN SIGNAL(dbg$_noaccessr,1,.addr+8);
		vms_desc[dsc$l_pos] = .(.addr+8)<0,32,0>;
		END;

	    [INRANGE,OUTRANGE] :	SIGNAL(dbg$_illtype);
	    TES;
	END;
    !+
    ! Obtain the length in bits and the length in bytes of the data
    ! represented by the VMS descriptor.
    !-
    bits  = dbg$data_length(vms_desc);
    bytes = (.bits + (%BPUNIT-1)) / %BPUNIT;

    !+
    ! Allocate either enough space for a Volatile Value Descriptor,
    ! or enough space for a Value Descriptor which contains the value.
    !-
    IF (.target_type EQL dbg$k_v_value_desc) OR (.bytes GTR 512)
    THEN
	result_desc = dbg$make_skeleton_desc(dbg$k_v_value_desc)
    ELSE
	result_desc = dbg$make_skeleton_desc(dbg$k_value_desc,.bytes);

    !+
    ! Copy the VMS descriptor into the Value Descriptor. Also fill in
    ! the kind and fcode fields.
    !-
    ch$move(12,vms_desc,result_desc[dbg$a_value_vmsdesc]);
    result_desc[dbg$b_dhdr_kind]   = rst$k_data;
    result_desc[dbg$b_dhdr_fcode]  = rst$k_type_descr;

    !+
    ! If the target type is a value descriptor then we want to extract
    ! the value represented by the VMS descriptor and
    ! right-align the result in the value descriptor.
    !-
    IF .result_desc[dbg$b_dhdr_type] EQL dbg$k_value_desc THEN
	BEGIN
	BUILTIN PROBER;
	LOCAL addr,pos;
	result_desc[dbg$l_value_pointer] = result_desc[dbg$a_value_address];
	!+
	! Compute the byte address by adding (bit_offset/8).
	! Then set the bit offset to (bit_offset mod 8).
	!-
	IF .vms_desc[dsc$b_class] EQL dsc$k_class_ubs
	THEN 
	    BEGIN
	    pos   = .(vms_desc[dsc$l_pos])<0,3,0>;
	    addr = .vms_desc[dsc$a_pointer] + .(vms_desc[dsc$l_pos])<3,29,1>;
	    END
	ELSE
	    BEGIN
	    pos = 0;
	    addr = .vms_desc[dsc$a_pointer];
	    END;
	!+
	! Check for read access.
	!-
	bytes = (.pos + .bits + 7)/8;
    	IF .bytes NEQ 0
    	THEN
	    IF NOT PROBER(%REF(0),bytes,.addr) 
    	    THEN 
    		SIGNAL(dbg$_noaccessr,1,.addr);
	!+
	! Don't support bit extractions bigger than 32 bits for now.
	! This restriction may be relaxed at a later time.
	!-
	IF .bits LEQU 32
	THEN
	    BEGIN
	    !+
	    ! Decide whether to do a signed or an unsigned extraction based on
	    ! the dtype.
	    !-
	    SELECTONE .vms_desc[dsc$b_dtype] OF
		SET
		[dsc$k_dtype_sv,dsc$k_dtype_svu,dsc$k_dtype_b,dsc$k_dtype_w] :
		    .result_desc[dbg$l_value_pointer] = .(.addr)<.pos,.bits,1>;
		[OTHERWISE] :
		    .result_desc[dbg$l_value_pointer] = .(.addr)<.pos,.bits,0>;
		TES;
    	    !+
    	    ! Since we have performed the bit extraction, the bit offset is
    	    ! now zero. Zero the POS field to reflect this.
    	    !-
    	    IF .result_desc[dbg$b_value_class] EQL dsc$k_class_ubs
    	      THEN result_desc[dbg$l_value_pos] = 0;
	    END
	ELSE
	    BEGIN
	    !+
	    ! The value is longer than 32 bits. 
	    !-

    	    IF .pos EQL 0
    	    THEN
    	      !+
    	      ! Copy the bytes.
    	      !-
	      ch$move(.bytes,.addr,.result_desc[dbg$l_value_pointer])

    	    ELSE
    	      BEGIN
    	      !+
    	      ! We used to disallow this.
    	      ! SIGNAL(dbg$_unimplent);
    	      !-
    	      INCR i FROM 0 TO (.bits-1)/32 DO
		(4*.i + .result_desc[dbg$l_value_pointer]) = 
    		    .(4*.i + .addr)<.pos,32,0>;
    	      
    	      !+
    	      ! Since we have performed the bit extraction, the bit offset is
    	      ! now zero. Zero the POS field to reflect this.
    	      !-
    	      IF .result_desc[dbg$b_value_class] EQL dsc$k_class_ubs
    	        THEN result_desc[dbg$l_value_pos] = 0;
    	      END;
	    END;
	END;

    !+
    ! We are all done. Return a pointer to the newly constructed Value
    ! Descriptor.
    !-
    RETURN .result_desc;
    END;		! end of routine dbg$make_val_desc

GLOBAL ROUTINE DBG$FILL_IN_VMS_DESC(fcode,typeid,symid,
    				    vms_desc,bit_length,bit_offset) =
! 
! ROUTINE DESCRIPTION
!
    BEGIN
    MAP
    	symid		: REF rst$entry,
	vms_desc	: REF dbg$stg_desc,
	bit_length	: REF VECTOR [1,LONG],
	bit_offset	: REF VECTOR [1,LONG];

    CASE .fcode FROM rst$k_type_minimum TO rst$k_type_maximum OF
	SET
	[rst$k_type_atomic] :
	    BEGIN
	    LOCAL typecode;
	    !+
	    ! Atomic data types - the routine dbg$sta_typ_atomic can be
	    ! used to obtain the dtype and length in bits. Class is set
	    ! to S or VS here; it may later be changed to UBS if there 
	    ! is a bit offset present.
	    ! -
	    dbg$sta_typ_atomic(.typeid,typecode,bit_length[0]);
	    IF .typecode EQL dst$k_bool THEN
		BEGIN
		vms_desc[dsc$b_class]  = dsc$k_class_s;
		vms_desc[dsc$b_dtype]  = dsc$k_dtype_tf;
		vms_desc[dsc$w_length] = .bit_length[0];
		END
	    ELSE
		BEGIN
		vms_desc[dsc$b_dtype]  = .typecode;
		IF .typecode EQL dsc$k_dtype_vt
		THEN
		    vms_desc[dsc$b_class] = dsc$k_class_vs
		ELSE
		    vms_desc[dsc$b_class] = dsc$k_class_s;
		!+
		! Length is in bits for the five data types below, and
		! bytes for all others.
		!-
		vms_desc[dsc$w_length] = .bit_length[0]/
		    (IF .typecode EQL dsc$k_dtype_v
		     OR .typecode EQL dsc$k_dtype_vu
		     OR .typecode EQL dsc$k_dtype_sv
		     OR .typecode EQL dsc$k_dtype_svu
		     OR .typecode EQL dsc$k_dtype_tf
		       THEN 1
		       ELSE %BPUNIT);
		END;
	    END;


	[rst$k_type_pict] :
	    BEGIN
	    !+
	    ! "Pictured" data item. This is really an item of data-type
	    ! dsc$k_dtype_t, but we need to retain extra information in
	    ! case we want to deposit a numeric value into this item.
	    !-
	    dbg$sta_symsize (.typeid,bit_length[0]);
	    vms_desc[dsc$b_class]  = dsc$k_class_s;
	    vms_desc[dsc$b_dtype]  = dsc$k_dtype_t;
	    vms_desc[dsc$w_length] = .bit_length[0]/%BPUNIT;
	    END;


	[rst$k_type_record,rst$k_type_ptr,rst$k_type_tptr,
	 rst$k_type_enum,rst$k_type_set,rst$k_type_subrng,
	 rst$k_type_file, rst$k_type_rfa]:
	    !+
	    ! Non-atomic (i.e., non-VAX standard) data types. For these,
	    ! we do not attempt to fill in the VMS descriptor. We just
	    ! fill in the bit_length.
	    !-
	    dbg$sta_symsize(.typeid,bit_length[0]);


	! For variants, there is nothing to fill in.
	!
	[rst$k_type_variant]:
	    0;

	[rst$k_type_descr] :
	    BEGIN
	    !+
	    ! Types described by descriptors. We use the routine dbg$sta_typ_descr
	    ! to obtain the class, dtype, and length information.
	    !-
	    LOCAL dst_desc : REF dbg$stg_desc;
	    dbg$sta_typ_descr(.typeid,dst_desc);

    	    ! If we got a symid passed in to this routine, 
    	    ! try calling SYMVALUE to get a
    	    ! descriptor. If we get one, then use this
    	    ! descriptor instead of the one we got back from STA_TYP_DESCR.
    	    !
    	    ! Note - normally, these 2 descriptors will be the same.
    	    ! However, for dynamic arrays in PASCAL, the runtime descriptor
    	    ! (which we get back when we call SYMVALUE with the symid) is
    	    ! correct, but the compile-time descriptor (which is part of
    	    ! the typespec) is wrong. This code is a workaround for this
    	    ! problem in the PASCAL DST. The same workaround appears
    	    ! in DBGPARSER for array descriptors.
    	    !
    	    IF .SYMID NEQ 0
    	    THEN
    	        BEGIN
    	        LOCAL
    		    DESC: VECTOR[3],
    		    RSTPTR: REF RST$ENTRY,
    		    VALUE_KIND;
    	        RSTPTR = .SYMID;
    		WHILE .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
    		    RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
    		IF .RSTPTR[RST$B_LANGUAGE] EQL DBG$K_PASCAL
    		THEN
    		    BEGIN
    		    DBG$STA_SETCONTEXT(.SYMID);
    	            DBG$STA_SYMVALUE(.SYMID, DESC, VALUE_KIND);
    	            IF .VALUE_KIND EQL DBG$K_VAL_DESCR
    	            THEN
    		        DST_DESC = .DESC[0];
    		    END;
    	        END;

	    vms_desc[dsc$b_class]  = .dst_desc[dsc$b_class];
	    vms_desc[dsc$b_dtype]  = .dst_desc[dsc$b_dtype];
	    vms_desc[dsc$w_length] = .dst_desc[dsc$w_length];

    	    !+
    	    ! Fix things up so that dtype VT always corresponds to class VS.
    	    ! (This seems to be necessary for PL/I varying strings).
    	    !-
    	    IF .vms_desc[dsc$b_dtype] EQL dsc$k_dtype_vt
    	    THEN
    	      vms_desc[dsc$b_class] = dsc$k_class_vs;

	    SELECTONE .vms_desc[dsc$b_class] OF
		SET
		[dsc$k_class_s,dsc$k_class_d,dsc$k_class_vs] : 0;

		[dsc$k_class_sd] :
		    BEGIN
		    vms_desc[dsc$b_digits] = .dst_desc[dsc$b_digits];
		    vms_desc[dsc$b_scale]  = .dst_desc[dsc$b_scale];
    		    vms_desc[dsc$v_fl_binscale] = .dst_desc[dsc$v_fl_binscale];

    		    !+
    		    !*** Workaround for a problem in the PL/I DST.
    		    !*** The scale they are giving us is the negative
    		    !*** of what we expect.
    		    !-
    		    IF .symid NEQ 0
    		    THEN
    			BEGIN
      		        WHILE .symid[rst$b_kind] NEQ rst$k_module DO
    			    symid = .symid[rst$l_upscopeptr];
    		        IF (.symid[rst$b_language] EQL dbg$k_pli) AND
    			    .symid[rst$v_oldpliflag]
    		        THEN
    			    vms_desc[dsc$b_scale] = - .dst_desc[dsc$b_scale];
    			END;
		    END;

		[dsc$k_class_ubs] :
		    SELECTONE .dst_desc[dsc$b_dtype] OF
			SET
			[dsc$k_dtype_svu,dsc$k_dtype_vu,dsc$k_dtype_tf]:
			    bit_offset[0] = .bit_offset[0] + .dst_desc[dsc$l_pos];

			[dsc$k_dtype_ubs]:
			    BEGIN
			    bit_offset[0] = .bit_offset[0] + .(.dst_desc+8)<0,16,1>;
			    IF .(.dst_desc+10)<0,1,0>
				THEN vms_desc[dsc$b_dtype] = dsc$k_dtype_svu
				ELSE vms_desc[dsc$b_dtype] = dsc$k_dtype_vu;
			    END;

			[OTHERWISE]:
			    0;
			TES;

		[OTHERWISE] :
		    SIGNAL(dbg$_unimplent);
		TES;

	    IF .vms_desc[dsc$b_dtype] EQL dsc$k_dtype_bpv
	    THEN
		BEGIN
		vms_desc[dsc$b_class]  = dsc$k_class_z;
		vms_desc[dsc$b_dtype]  = dsc$k_dtype_zem;
		vms_desc[dsc$w_length] = 2;
		dbg$gl_call_context = .dst_desc[dsc$a_frame];
		END
	    ELSE IF .vms_desc[dsc$b_dtype] EQL dsc$k_dtype_blv
	    THEN
		BEGIN
		vms_desc[dsc$b_class]  = dsc$k_class_z;
		vms_desc[dsc$b_dtype]  = dsc$k_dtype_zi;
		vms_desc[dsc$w_length] =
		    (dbg$ins_decode(.vms_desc[dsc$a_pointer],false,false) -
				    .vms_desc[dsc$a_pointer]);
		dbg$gl_call_context = .dst_desc[dsc$a_frame];
		END;

	    bit_length[0] = dbg$data_length(.vms_desc);
	    END;

    	! Self relative labels in PL/I (i.e., arrays of labels).
    	! The value of one of these is equal to the contents of the 
    	! memory location plus its own address. In other words, the
    	! values actually stored in the label array are offsets to
    	! the actual place to branch to.
    	!
    	[rst$k_type_self_rel_lab]:
    	    BEGIN
    	    vms_desc[dsc$b_class] = dsc$k_class_z;
    	    vms_desc[dsc$b_dtype] = dsc$k_dtype_zi;
    	    vms_desc[dsc$a_pointer] = .vms_desc[dsc$a_pointer] +
    		.(.vms_desc[dsc$a_pointer]);
	    vms_desc[dsc$w_length] =
		    (dbg$ins_decode(.vms_desc[dsc$a_pointer],false,false) -
				    .vms_desc[dsc$a_pointer]);
    	    bit_length[0] = .vms_desc[dsc$w_length] * 8;
    	    END;

    	! We do not handle any other fcodes.
    	!
    	[INRANGE,OUTRANGE] :
	    SIGNAL(dbg$_unimplent);
	TES;

    RETURN sts$k_success;
    END;			! End of routine 'dbg$fill_in_vms_desc'

GLOBAL ROUTINE DBG$MAKE_VMS_DESC (prm_desc,vms_desc) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine constructs a VAX/VMS descriptor that points to the
!	value of a symbol (described by a primary symbol descriptor).
!	It first materializes the address by resolving all array and/or
!	record component references, and then determines the length and
!	data type.  Finally it checks for sub references, and if one is
!	present updates the length and address fields accordingly.
!
! FORMAL PARAMETERS:
!
!	prm_desc	- A longword containing the address of a primary descriptor
!
!	vms_desc	- A longword containing the address of a block of at least
!			  12 bytes where a VAX/VMS descriptor will be constructed.
!

!dbg$make_vms_desc (prm_desc,vms_desc)
    BEGIN
    MAP
	prm_desc	: REF dbg$primary,
	vms_desc	: REF dbg$stg_desc;

    LOCAL
	adr_kind,
	adr_ptrs	: VECTOR [3,LONG],
	addr_offset,
	bit_offset,
	bit_length,
	result_desc	: BLOCK [12,BYTE],
	data_subnode	: REF dbg$prim_node,
	prim_subnode	: REF dbg$prim_node,
    	typeid: REF rst$entry,
    	s_value;

    BUILTIN
    	PROBER;

    dbg$gl_current_primary = .prm_desc;						! A003

    ! It is illegal to call DBG$MAKE_VMS_DESC with a type.
    !
    IF .prm_desc[dbg$b_dhdr_kind] EQL rst$k_type
    THEN
    	BEGIN
    	LOCAL
    	    name;
    	IF .prm_desc[dbg$l_dhdr_symid0] NEQ 0
        THEN
    	    BEGIN
    	    dbg$sta_symname(.prm_desc[dbg$l_dhdr_symid0], name);
    	    SIGNAL (dbg$_novaltyp, 1, .name);
    	    END
    	ELSE
    	    SIGNAL (dbg$_novalue);
    	END;

    !+
    ! The first thing we do is to set the symbol table access context to
    ! the correct stack frame (in case of values whose address is given by
    ! an offset from an address in a register such as FP or AP), and clear
    ! the initial byte and bit addresses and descriptor fields.
    !-
    dbg$sta_setcontext(.prm_desc[dbg$l_dhdr_symid0]);
    bit_offset = bit_length = 0;
    ch$fill(0,12,result_desc);

    ! Loop for all except the last sub-node in the primary descriptor,
    ! building up the address of the element within the structure.
    ! This address is represented by a byte address, stored in the
    ! dsc$a_pointer field of result_desc, and a bit offset, stored
    ! (for now) in the local variable bit_offset.
    !
    ! N.B.  This MUST be done 'top-down' to deal with POINTER data-types.
    !-
    prim_subnode = .prm_desc[dbg$l_prim_flink];
    data_subnode = .prm_desc[dbg$l_prim_blink];
    WHILE .prim_subnode NEQA .data_subnode DO
	BEGIN
	result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + .prim_subnode[dbg$l_pnode_reloc];
	!+
	! Get the address of this element by calling dbg$sta_symvalue.
	! This should return either the address of a data item (offset
	! from the start of the record, if this is a record component)
	! or the address of a descriptor. Anything else is an error.
	!-
	IF (.prim_subnode[dbg$l_pnode_symid] NEQ 0) AND
    	NOT .prim_subnode[dbg$v_pnode_ignore]
        THEN
	    BEGIN
	    dbg$sta_symvalue(.prim_subnode[dbg$l_pnode_symid],adr_ptrs,adr_kind);
	    SELECTONE .adr_kind OF
		SET
		[dbg$k_val_addr]:
		    BEGIN
		    result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + .adr_ptrs[0];
		    bit_offset = .bit_offset + .adr_ptrs[1];
		    END;
		[dbg$k_val_descr]:
		    BEGIN
		    BIND adr_desc = adr_ptrs[0]	: REF dbg$stg_desc;
		    result_desc[dsc$a_pointer]  = .result_desc[dsc$a_pointer] + .adr_desc[dsc$a_pointer];
		    END;
    		[dbg$k_val_unalloc]:
    		    BEGIN
    		    LOCAL name;
    		    dbg$sta_symname(.prim_subnode[dbg$l_pnode_symid],name);
    		    SIGNAL(dbg$_unallocated, 1, .name);
    		    END;
		[OTHERWISE]:
		    SIGNAL(dbg$_novalue);
		TES;
	    END;

	SELECTONE .prim_subnode[dbg$b_pnode_fcode] OF
	    SET
	    [rst$k_type_array]:
		BEGIN
		!+
		! If this is an array (of records or pointers, presumably),
		! get the address of an individual element of the array.
		!-
		BIND pnsub = prim_subnode[dbg$a_pnarr_svector] : dbg$prim_node_subs;
		addr_offset = .prim_subnode[dbg$l_pnarr_offset];

    		! Loop through the dimensions of the array. 
    		!
		DECR index FROM .prim_subnode[dbg$b_pnarr_dimcnt]-1 TO 0 DO
    		  BEGIN
    		  s_value = .pnsub[.index,dbg$l_pnsub_svalue];
    		  typeid = .pnsub[.index,dbg$l_pnsub_typeid];

    		  ! If the array is indexed by an enumeration type,
    		  ! then index by the position and not by
    		  ! the value. This cases arises only in ADA for
    		  ! enumerated types with representation specs.
    		  !
    		  IF (.dbg$gb_language EQL dbg$k_ada) AND
    		     (.typeid NEQ 0)
    		  THEN 
    		    IF (.typeid[rst$b_fcode] EQL rst$k_type_enum)
    		    THEN
    		      s_value = dbg$enum_pos(.typeid,.s_value);	

		  addr_offset = .addr_offset + (.s_value*.pnsub[.index,dbg$l_pnsub_stride]);
    		  END;

		IF .prim_subnode[dbg$v_pnarr_bitref]
		  THEN bit_offset = .bit_offset + .addr_offset
		  ELSE result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + .addr_offset;
		END;

	    [rst$k_type_ptr,rst$k_type_tptr]:
		BEGIN
		BUILTIN PROBER;
		LOCAL addr;
		!+
		! Check for read access before trying to fetch a value.
		!-
		addr = .result_desc[dsc$a_pointer] + .bit_offset<3,29,1>;
		IF NOT PROBER(%REF(0),%REF(5),.addr)
	 	  THEN SIGNAL(dbg$_noaccessr,1,.addr);
		!+
		! If this is a POINTER, fetch a longword value
		!-
		result_desc[dsc$a_pointer] = .(.addr)<.bit_offset,32,0>;
		bit_offset = 0;
		END;

	    [rst$k_type_record]:
		0;

	    [rst$k_type_variant]:
		IF NOT .prim_subnode[dbg$v_pnvar_valid] THEN
		    BEGIN
		    LOCAL tag_value,tag_size,tag_name : REF VECTOR[,BYTE];
		    prim_subnode[dbg$v_pnvar_valid] = true;
		    IF .prim_subnode[dbg$l_pnvar_tagid] NEQ 0 THEN
			BEGIN
			BUILTIN PROBER;									! A004
			dbg$sta_symname(.prim_subnode[dbg$l_pnvar_tagid],tag_name);
			dbg$sta_symsize(.prim_subnode[dbg$l_pnvar_tagid],tag_size);
			IF (.tag_size NEQ 0) AND (.tag_name[0] NEQ 0) THEN
			    BEGIN
			    dbg$sta_symvalue(.prim_subnode[dbg$l_pnvar_tagid],adr_ptrs,adr_kind);
			    adr_ptrs[0] = .adr_ptrs[0] + .result_desc[dsc$a_pointer];
			    adr_ptrs[1] = .adr_ptrs[1] + .bit_offset;

			    !++
			    ! Check that the address is accessable
			    !--
			    IF NOT PROBER( %REF(0), %REF(4), .adr_ptrs[0] )				! A004
			    THEN									! A004
				 SIGNAL(dbg$_noaccessr,1,.adr_ptrs[0]);					! A004

			    tag_value = .(.adr_ptrs[0])<.adr_ptrs[1],.tag_size,0>;
			    IF NOT dbg$sta_variant_value(.tag_value,.prim_subnode[dbg$l_pnvar_dstptr])
			      THEN SIGNAL(dbg$_badtagval,2,.tag_value,tag_name[0]);
			    END;
			END;
		    END;

	    [rst$k_type_file]:
		BEGIN
		BUILTIN PROBER;
		LOCAL addr: REF BITVECTOR[];
		!+
		! For file types what we have in the vms descriptor is a 
		! pointer to a PASCAL file descriptor. Bit 16 in the 
		! second longword of this descriptor is a "valid" bit which
		! basically says whether the file is open. If bit 16 is set
		! then the first longword of the descriptor is a pointer
		! to a buffer from which we can read the next item 
		! in the file. 
		!-
		!+
		! Note in the calculations below, bit_offset will normally
		! be zero. It might conceivably be non-zero in obscure cases,
		! such as a file variable which is an element of a packed
		! record.
		!-
		!+
		! Check for read access.
		!-
		addr = .result_desc[dsc$a_pointer] + .bit_offset<3,29,1>;
		bit_offset = .bit_offset<0,3,0>;
		IF NOT PROBER(%REF(0),%REF(8),.addr) THEN SIGNAL(dbg$_illfilptr);
		!+
		! Check "valid" bit.
		!-
		IF NOT .addr[48+.bit_offset] THEN SIGNAL(dbg$_illfilptr);
		!+
		! Put the buffer address back into result_desc.
		!-
		result_desc[dsc$a_pointer] = .(.addr)<.bit_offset,32,0>;
		bit_offset = 0;
		END;

	    [OTHERWISE]:
		SIGNAL(dbg$_illtype);

	    TES;
	prim_subnode = .prim_subnode[dbg$l_pnode_flink];
	END;

    !+
    ! We now have resolved all earlier record component and array references,
    ! and have to determine the actual data item address. The first thing to
    ! do is to calculate the base address (much as we did above).
    !-
    IF (.data_subnode[dbg$l_pnode_symid] NEQ 0) AND
    NOT .data_subnode[dbg$v_pnode_ignore]
    THEN
	BEGIN
	dbg$sta_symvalue(.data_subnode[dbg$l_pnode_symid],adr_ptrs,adr_kind);
	SELECTONE .adr_kind OF
	    SET
	    [dbg$k_val_addr]:
		BEGIN
		result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + .adr_ptrs[0];
		bit_offset = .bit_offset + .adr_ptrs[1];
		END;
	    [dbg$k_val_descr]:
		BEGIN
		BIND adr_desc = adr_ptrs[0]	: REF dbg$stg_desc;
		result_desc[dsc$a_pointer]  = .result_desc[dsc$a_pointer] + .adr_desc[dsc$a_pointer];
		END;
	    [dbg$k_val_literal]:
		BEGIN
		result_desc[dsc$a_pointer] = .adr_ptrs[0];
		bit_offset = .adr_ptrs[1];
		END;
    	    [dbg$k_val_unalloc]:
    		BEGIN
    		LOCAL name;
    		dbg$sta_symname(.data_subnode[dbg$l_pnode_symid],name);
    		SIGNAL(dbg$_unallocated, 1, .name);
    		END;
	    [OTHERWISE]:
		SIGNAL(dbg$_novalue);
	    TES;
	END;

    !+
    ! Having determined the address of the data object, we now attempt to
    ! fill in the rest of the fields in the VMS descriptor (class, dtype,
    ! and length). We use the information that we have in the bottom subnode:
    ! a kind, an fcode, and a typeid.
    !-
    CASE .data_subnode[dbg$b_pnode_kind] FROM rst$k_kind_minimum TO rst$k_kind_maximum OF
	SET

	[rst$k_routine,rst$k_block,rst$k_entry,rst$k_line,rst$k_label]:
	    BEGIN
    	    !+
	    ! Special case for MACRO - since MACRO declares everything to
	    ! be a label, then we want to instead use the default type
	    ! that has been specified with a SET TYPE command.
	    !-
	    IF (.data_subnode[dbg$b_pnode_kind] EQL rst$k_label)
	    AND (.prm_desc[dbg$b_dhdr_lang] EQL dbg$k_macro)
	    AND (NOT .prm_desc[dbg$v_dhdr_override])
	    AND (.dbg$gl_dflttyp NEQ dsc$k_dtype_zi) 	! If instruction, the we
							! already have correct type
							! and length
	    THEN
		BEGIN
		result_desc[dsc$b_class] = dsc$k_class_z;
		result_desc[dsc$b_dtype]  = .dbg$gl_dflttyp;
		result_desc[dsc$w_length] = .dbg$gw_dfltleng; ! All default types
		bit_length = 8*.dbg$gw_dfltleng;	      ! have length in bytes.
		END

	    ELSE
		BEGIN
	        !+
	    	! This must be a primary representing an instruction or an entry
	    	! mask in the user program.
	    	!-
	    	IF .bit_offset NEQ 0 THEN SIGNAL(dbg$_unimplent);
	    	result_desc[dsc$b_class] = dsc$k_class_z;
	    	IF dbg$is_it_entry(.result_desc[dsc$a_pointer])
	    	THEN
		    BEGIN
		    result_desc[dsc$b_dtype] = dsc$k_dtype_zem;
		    bit_length = 16;
		    END
	        ELSE
		    BEGIN
		    result_desc[dsc$b_dtype] = dsc$k_dtype_zi;
		    bit_length = %BPUNIT*(dbg$ins_decode(.result_desc[dsc$a_pointer],false,false) -
						     	 .result_desc[dsc$a_pointer]);
		    END;
		END;
	    END;

	[rst$k_data,rst$k_typcomp]:
	    BEGIN
	    !+
	    ! The Primary represents data in the user program. Note that
	    ! record components come back with kind=typcomp (this is a quirk
	    ! in the parsing that may eventually be fixed).
	    !-
	    IF .data_subnode[dbg$b_pnode_fcode] EQL rst$k_type_array
	    THEN
		BEGIN
		BIND pnsub = data_subnode[dbg$a_pnarr_svector] : dbg$prim_node_subs;
		addr_offset = .data_subnode[dbg$l_pnarr_offset];

    		! Loop through the dimensions of the array. 
    		!
		DECR index FROM .data_subnode[dbg$b_pnarr_dimcnt]-1 TO 0 DO
    		  BEGIN
    		  s_value = .pnsub[.index,dbg$l_pnsub_svalue];
    		  typeid = .pnsub[.index,dbg$l_pnsub_typeid];

    		  ! If the array is indexed by an enumeration type,
    		  ! then index by the position and not by
    		  ! the value. This cases arises only in ADA for
    		  ! enumerated types with representation specs.
    		  !
    		  IF (.dbg$gb_language EQL dbg$k_ada) AND
    		     (.typeid NEQ 0)
    		  THEN 
    		    IF (.typeid[rst$b_fcode] EQL rst$k_type_enum)
    		    THEN
    		      s_value = dbg$enum_pos(.typeid,.s_value);

		  addr_offset = .addr_offset + (.s_value*.pnsub[.index,dbg$l_pnsub_stride]);
    		  END;

		IF .data_subnode[dbg$v_pnarr_bitref]
		  THEN bit_offset = .bit_offset + .addr_offset
		  ELSE result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + .addr_offset;

		!+
		! Figure out the class field. This class may get fixed up later -
		! we want class=ubs to reflect the fact that there is a bit
		! offset present. But for now, we just fill in class VS for
		! dtype vt, class SD if digits or scale are present, and
		! class s for all other dtypes.
		!-
		IF .data_subnode[dbg$b_pnarr_dtype] EQL dsc$k_dtype_vt
		THEN
		    result_desc[dsc$b_class]  = dsc$k_class_vs
		ELSE
		    BEGIN
		    IF (.data_subnode[dbg$b_pnarr_digits] NEQ 0) OR
		       (.data_subnode[dbg$b_pnarr_scale] NEQ 0)
		    THEN
			BEGIN
			result_desc[dsc$b_class]  = dsc$k_class_sd;
			result_desc[dsc$b_digits] = .data_subnode[dbg$b_pnarr_digits];
			result_desc[dsc$b_scale]  = .data_subnode[dbg$b_pnarr_scale];
			END
		    ELSE
			result_desc[dsc$b_class]  = dsc$k_class_s;
		    END;


		! Fill in dtype and length. For arrays, we have this information
		! in the array subnode.
		!
		result_desc[dsc$b_dtype]  = .data_subnode[dbg$b_pnarr_dtype];
		result_desc[dsc$w_length] = .data_subnode[dbg$w_pnarr_length];
		!+
		! Fix up boolean to use the new type code dsc$k_dtype_tf.
		!-
		IF .result_desc[dsc$b_dtype] EQL dst$k_bool
		THEN
		    BEGIN
		    result_desc[dsc$b_class]  = dsc$k_class_s; ! This will get
							       ! changed to UBS
							       ! if there is a
							       ! bit offset
		    result_desc[dsc$b_dtype]  = dsc$k_dtype_tf;
		    result_desc[dsc$w_length] = bit_length = 1;
		    END
		ELSE
		    bit_length = dbg$data_length(result_desc);
		END
	    ELSE
		!+
		! For everything except arrays, we call a routine to fill
		! in the fields of the VMS descriptor, passing to this
		! routine all the information we have collected so far.
		!-
		dbg$fill_in_vms_desc(.data_subnode[dbg$b_pnode_fcode],
				     .data_subnode[dbg$l_pnode_typeid],
    				     .prm_desc[dbg$l_dhdr_symid0],
				     result_desc,bit_length,bit_offset);

	    !+
	    ! Fix things up so class VS always has dtype VT. Class VS and
	    ! type T is the older way of expressing varying string data
	    ! type, so we fix it up to use the newer dtype VT.
	    !-
	    IF  .result_desc[dsc$b_class] EQL dsc$k_class_vs
	    AND .result_desc[dsc$b_dtype] EQL dsc$k_dtype_t
	      THEN result_desc[dsc$b_dtype] = dsc$k_dtype_vt;
	    END;

	!+
	! We should not see other kinds.
	!-
	[INRANGE,OUTRANGE]:
	    SIGNAL(dbg$_unimplent);
	TES;


    ! Dereference descriptors of type DSC.
    !
    IF .result_desc[dsc$b_dtype] EQL dsc$k_dtype_dsc
    THEN
    	BEGIN
    	IF NOT PROBER(%REF(0),%REF(8),.result_desc[dsc$a_pointer]) 
    	THEN 
    	    SIGNAL(dbg$_noaccessr,1,.result_desc[dsc$a_pointer]);
    	ch$move(.result_desc[dsc$w_length], 
    		.result_desc[dsc$a_pointer], result_desc);
    	END;


    ! Dereference descriptors of type BPV or BLV.
    !
    IF (.result_desc[dsc$b_dtype] EQL dsc$k_dtype_blv) OR
       (.result_desc[dsc$b_dtype] EQL dsc$k_dtype_bpv)
    THEN
    	BEGIN
    	IF NOT PROBER(%REF(0),%REF(8),.result_desc[dsc$a_pointer]) 
    	THEN 
    	    SIGNAL(dbg$_noaccessr,1,.result_desc[dsc$a_pointer]);
    	result_desc[dsc$a_pointer] = ..result_desc[dsc$a_pointer];
    	IF .result_desc[dsc$b_dtype] EQL dsc$k_dtype_blv
    	THEN
    	    result_desc[dsc$b_dtype] = dsc$k_dtype_zi;
    	IF .result_desc[dsc$b_dtype] EQL dsc$k_dtype_bpv
    	THEN
    	    result_desc[dsc$b_dtype] = dsc$k_dtype_zem;
    	END;

    result_desc[dsc$a_pointer] = 
    	    .result_desc[dsc$a_pointer] + .data_subnode[dbg$l_pnode_reloc];


    IF .prm_desc[dbg$v_dhdr_subref] THEN
	BEGIN
	!+
	! If there was an offset in the Primary (either a bit offset or
	! a byte offset) then take care of that here.
	!-
	IF .prm_desc[dbg$v_dhdr_bitref]
	THEN
	    BEGIN
	    bit_offset = .prm_desc[dbg$w_prim_offset] + .bit_offset;
	    bit_length = .prm_desc[dbg$w_prim_length];
	    result_desc[dsc$b_class]  = dsc$k_class_z;	! These get fixed up 
	    result_desc[dsc$b_dtype]  = dsc$k_dtype_z;	! below.
	    result_desc[dsc$w_length] = 0;
	    IF (.bit_offset AND (%BPUNIT-1)) EQL 0 THEN
	      SELECTONE .bit_length OF
		SET

		[ 8]:
		    result_desc[dsc$b_dtype] = (IF .prm_desc[dbg$v_dhdr_sgnext]
				     THEN dsc$k_dtype_b ELSE dsc$k_dtype_bu);
		[16]:
		    result_desc[dsc$b_dtype] = (IF .prm_desc[dbg$v_dhdr_sgnext]
				     THEN dsc$k_dtype_w ELSE dsc$k_dtype_wu);
		[32]:
		    result_desc[dsc$b_dtype] = (IF .prm_desc[dbg$v_dhdr_sgnext]
				     THEN dsc$k_dtype_l ELSE dsc$k_dtype_lu);

		[OTHERWISE]:
		    0;

		TES;
	    END

	ELSE
	    BEGIN
	    IF .result_desc[dsc$b_dtype] EQL dsc$k_dtype_vt
	    THEN
		BEGIN
		result_desc[dsc$b_class]   = dsc$k_class_s;
		result_desc[dsc$b_dtype]   = dsc$k_dtype_t;
		result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + 2;
		END;
	    result_desc[dsc$a_pointer] = .prm_desc[dbg$w_prim_offset] + .result_desc[dsc$a_pointer];
	    bit_length = .prm_desc[dbg$w_prim_length] * %BPUNIT;

    	    !+
    	    ! For the string data types (which include ascii and also the
    	    ! numeric string types NU, NL, NLO, NR, NRO, and NZ), fill
    	    ! in the length of the result descriptor, but leave the class
    	    ! and dtype unchanged. Note that the code below relies on the
    	    ! fact that these dtype codes span the range from 14 (dsc$k_dtype_t)
    	    ! to 20 (dsc$k_dtype_nz).
    	    !-
	    IF (.result_desc[dsc$b_dtype] GEQ dsc$k_dtype_t) AND
    	       (.result_desc[dsc$b_dtype] LEQ dsc$k_dtype_nz)
	    THEN
		result_desc[dsc$w_length] = .prm_desc[dbg$w_prim_length]
	    ELSE
		BEGIN
		result_desc[dsc$b_class]  = dsc$k_class_z;	! (0)
		result_desc[dsc$b_dtype]  = dsc$k_dtype_z;	! (0)
		result_desc[dsc$w_length] = 0;
		END;
	    END;
	END;

    !+
    ! At this point, if the bit_offset variable is not a multiple of 8 then
    ! there really is a bit offset. Fix up the class field to be UBS in
    ! this case.
    !-
    IF (.bit_offset AND (%BPUNIT-1)) NEQ 0 THEN
	BEGIN
	!+
	! We used to not support unaligned bit fields longer than 32 bits.
	! IF .bit_length GTRU 32 THEN SIGNAL(dbg$_unimplent);
	!-
	result_desc[dsc$b_class] = dsc$k_class_ubs;
	IF .result_desc[dsc$b_dtype] EQL dsc$k_dtype_z
	  THEN result_desc[dsc$b_dtype] = dsc$k_dtype_vu;
	!+
	! Bit length is in bits for these five data types, and in bytes
	! for all others.
	!-
	result_desc[dsc$w_length] = .bit_length /
	  (IF .result_desc[dsc$b_dtype] EQL dsc$k_dtype_vu
	   OR .result_desc[dsc$b_dtype] EQL dsc$k_dtype_v
	   OR .result_desc[dsc$b_dtype] EQL dsc$k_dtype_svu
	   OR .result_desc[dsc$b_dtype] EQL dsc$k_dtype_sv
	   OR .result_desc[dsc$b_dtype] EQL dsc$k_dtype_tf
	   THEN 1 ELSE 8);
	result_desc[dsc$l_pos]   = .bit_offset;
	END
    ELSE
	BEGIN
	!+
	! If we get here then we have byte-aligned data.
	! Fix up the pointer field to point to the byte where the data
	! data actually begins.
	!-
	result_desc[dsc$a_pointer] = .result_desc[dsc$a_pointer] + (.bit_offset/%BPUNIT);
	IF (.result_desc[dsc$b_class] EQL dsc$k_class_z)
	THEN
	    BEGIN
	    IF ((.bit_length AND (%BPUNIT-1)) EQL 0)
	    THEN
		!+
		! If the length of the data is exactly a multiple of 8 then
		! leave the dtype Z and express the length in bytes.
		!-
		result_desc[dsc$w_length] = .bit_length/%BPUNIT
	    ELSE
		BEGIN
		!+
		! If the length is not expressible in bytes then change the dtype
		! to V and fill in the length field with a bit length.
		!-
		result_desc[dsc$b_dtype] = dsc$k_dtype_v;
		IF .bit_length LSSU %X'10000'
		THEN
		    BEGIN
		    result_desc[dsc$w_length] = .bit_length;
		    result_desc[dsc$l_pos]    = 0;
		    END
		ELSE
		    BEGIN
		    !+
		    ! Special handling for the case where the length does
		    ! not fit in the word field.
		    !-
		    result_desc[dsc$w_length] = 0;
		    result_desc[dsc$l_pos] = .bit_length;
		   END;
		END;
	    END;
	END;

    ch$move(12,result_desc,.vms_desc);

    RETURN sts$k_success;

    END;		! End of routine dbg$make_vms_desc

GLOBAL ROUTINE DBG$PRIM_TO_VAL (prm_desc,target_type,val_desc) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Translates language independent descriptors to language independent
!	value descriptors.  Normally the input descriptor will be a primary
!	descriptor (a symbolic address reference),  but it is also possible
!	to call this routine passing it a 'volatile value descriptor' (used
!	for absolute addressing) or a normal value descriptor (indirection).
!	This routine should be able to use the symbol table access routines
!	and the information contained within the primary descriptor to make
!	a descriptor representing a 'value  materialization' for the object
!	described by the input descriptor.
!
!	Note that this routine must be able to use life-time, invocation, and
!	generation information to produce an accurate value descriptor of the
!	input object, or to decide when the value of an object cannot be
!	materialized (such as when the user's PC is not within the scope of
!	a dynamic variable).
!
!	Value descriptors produced by this routine must be marked (within the
!	type field of the language independent header block) as to whether
!	they are non-volatile (dbg$k_value_desc) or volatile (dbg$k_v_value_desc).
!	Volatile value descriptors will NOT be stored to represent '\', 'last value'.
!
!	Since value descriptors may be used as target descriptors ( as input to
!	dbg$ncob_type_conv ), some provision must be made for incorporating
!	a value pointer field within the value descriptor. This type of value
!	descriptor is loosely defined as a volatile type.
!
! FORMAL PARAMETERS:
!
!	prm_desc	- A longword containing the address of a primary descriptor
!
!	target_type	- A longword containing the type of value descriptor
!			  (dbg$k_value_desc or dbg$k_v_value_desc).
!
!	val_desc	- The address of a longword to contain the address of the
!			  resulting value descriptor
!

! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the resulting value descriptor must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Value descriptor constructed and returned.
!
!	STS$K_ERROR   (2) - Failure. Data-type is not known to DEBUG kernel.
!
! SIDE EFFECTS:
!
!	In case of a severe error, this routine will SIGNAL the error.
!
!--

!DBG$PRIM_TO_VAL(prm_desc,val_desc,target_type)
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP
	prm_desc	: REF dbg$primary;
    !
    !
    ! Declare routine-level local variables
    !
    LOCAL
	result_desc	: REF dbg$valdesc,
	data_desc	: BLOCK [dbg$k_valdesc_base_size+1,LONG]
				FIELD(dbg$dhdr_fields,dbg$value_fields);

    BIND vms_desc = data_desc[dbg$a_value_vmsdesc] : dbg$stg_desc;

    dbg$gl_current_primary = .prm_desc;						! A003

    ! It is illegal to call DBG$PRIM_TO_VAL with a type.
    !
    IF .prm_desc[dbg$b_dhdr_kind] EQL rst$k_type
    THEN
    	BEGIN
    	LOCAL
    	    name;
    	IF .prm_desc[dbg$l_dhdr_symid0] NEQ 0
        THEN
    	    BEGIN
    	    dbg$sta_symname(.prm_desc[dbg$l_dhdr_symid0], name);
    	    SIGNAL (dbg$_novaltyp, 1, .name);
    	    END
    	ELSE
    	    SIGNAL (dbg$_novalue);
    	END;

    !+
    ! First construct a VAX/VMS descriptor that for the desired value
    !-
    IF .prm_desc[dbg$l_dhdr_symid0] NEQ 0 THEN dbg$sta_setcontext(.prm_desc[dbg$l_dhdr_symid0]);
    dbg$collect(.prm_desc);

    SELECTONE .prm_desc[dbg$b_dhdr_type] OF
	SET
	[dbg$k_primary_desc]:
	    IF NOT dbg$make_vms_desc(.prm_desc,vms_desc) THEN RETURN sts$k_error;
	[dbg$k_v_value_desc]:
	    ch$move(12,prm_desc[dbg$a_value_vmsdesc],vms_desc);
	[dbg$k_value_desc]:
	    BEGIN
	    ch$fill(0,(dbg$k_valdesc_base_size+1)*%UPVAL,data_desc);
	    data_desc[dbg$b_dhdr_lang]   = .prm_desc[dbg$b_dhdr_lang];
	    data_desc[dbg$b_dhdr_type]   = .prm_desc[dbg$b_dhdr_type];
	    data_desc[dbg$l_dhdr_symid0] = .prm_desc[dbg$l_dhdr_symid0];
	    data_desc[dbg$w_dhdr_length] = dbg$k_valdesc_base_size*%UPVAL;
	    data_desc[dbg$b_dhdr_kind]   = rst$k_data;
	    data_desc[dbg$b_dhdr_fcode]  = rst$k_type_descr;

	    !+
	    ! Passing a pointer value into DBG$PRIM_TO_VAL results in a 
	    ! value which is obtained by dereferencing the pointer.
	    !-
	    IF .prm_desc[dbg$b_dhdr_fcode] EQL rst$k_type_tptr
	    THEN
		BEGIN
		LOCAL bit_length,bit_offset;
		dbg$sta_typ_typedptr(.prm_desc[dbg$l_dhdr_typeid],data_desc[dbg$l_dhdr_typeid]);
		data_desc[dbg$b_dhdr_fcode] = dbg$sta_typefcode(data_desc[dbg$l_dhdr_typeid]);
		IF .data_desc[dbg$b_dhdr_fcode] EQL rst$k_type_array THEN RETURN 0;
		bit_length = 0;
		bit_offset = 0;
		vms_desc[dsc$b_class]  = 0;
		vms_desc[dsc$b_dtype]  = 0;
		vms_desc[dsc$w_length] = 0;
		vms_desc[dsc$a_pointer] = .(.prm_desc[dbg$l_value_pointer]);
		dbg$fill_in_vms_desc(.data_desc[dbg$b_dhdr_fcode],
				 .data_desc[dbg$l_dhdr_typeid],
    				 .prm_desc[dbg$l_dhdr_symid0],
				 vms_desc,bit_length,bit_offset);
		END;
	    END;
	[OTHERWISE]:
	    SIGNAL(dbg$_illtype);
	TES;

    result_desc = dbg$make_val_desc(vms_desc,.target_type);

    result_desc[dbg$b_dhdr_lang]   = .prm_desc[dbg$b_dhdr_lang];
    result_desc[dbg$b_dhdr_kind]   = .prm_desc[dbg$b_dhdr_kind];
    result_desc[dbg$b_dhdr_fcode]  = .prm_desc[dbg$b_dhdr_fcode];
    result_desc[dbg$l_dhdr_typeid] = .prm_desc[dbg$l_dhdr_typeid];
    result_desc[dbg$l_dhdr_symid0] = .prm_desc[dbg$l_dhdr_symid0];
    result_desc[dbg$v_dhdr_override] = .prm_desc[dbg$v_dhdr_override];


    !+ 
    ! Special case in COBOL.  Treat the cobol record as text string.
    !-
    IF .result_desc[dbg$b_dhdr_fcode] EQL rst$k_type_record
    THEN
    	BEGIN
    	LOCAL tmp_symid: REF rst$entry;

    	tmp_symid = .result_desc[dbg$l_dhdr_symid0];
    	WHILE .tmp_symid[rst$b_kind] NEQ rst$k_module DO
    	    tmp_symid = .tmp_symid[rst$l_upscopeptr];
    	IF .tmp_symid[rst$b_language] EQL dbg$k_cobol
    	THEN
    	    BEGIN
    	    result_desc[dbg$b_dhdr_fcode] = rst$k_type_descr;
    	    result_desc[dbg$b_value_class] = dsc$k_class_s;
    	    result_desc[dbg$b_value_dtype] = dsc$k_dtype_t;
    	    END;
    	END;

    !+ 
    ! Special case for subrange - if we are turning a subrange primary into
    ! a value descriptor, then change the type to reflect the parent type.
    ! This is because, in all operations, a subrange is treated the same
    ! as its parent type. This thus simplifies the operator tables.
    !-
    IF .target_type EQL dbg$k_value_desc THEN
      WHILE .result_desc[dbg$b_dhdr_fcode] EQL rst$k_type_subrng DO
	BEGIN
	LOCAL parent,fcode,typeid,bit_length,bit_offset,dummy;
	dbg$sta_typ_subrng(.result_desc[dbg$l_dhdr_typeid],parent,dummy,dummy,bit_length);
	bit_offset = 0;
	dbg$sta_symtype(.parent,fcode,typeid);
	result_desc[dbg$b_dhdr_fcode]  = .fcode;
	result_desc[dbg$l_dhdr_typeid] = .typeid;
	result_desc[dbg$b_value_class]  = 0;
	result_desc[dbg$b_value_dtype]  = 0;
	result_desc[dbg$w_value_length] = 0;
	dbg$fill_in_vms_desc(.fcode,.typeid,.prm_desc[dbg$l_dhdr_symid0],
    			      result_desc[dbg$a_value_vmsdesc],bit_length,bit_offset);
	END;

    .val_desc = .result_desc;
    RETURN sts$k_success;

    END;				! End of dbg$prim_to_val

GLOBAL ROUTINE DBG$PRINT_AGGREGATE(prm_desc,radix) : NOVALUE =
    BEGIN
    MAP prm_desc	: REF dbg$primary;
    BUILTIN REMQUE;
    LOCAL
	subnode		: REF dbg$prim_node,
	val_desc	: REF dbg$valdesc,
	symid,kind,fcode,typeid,dummy,mark_one,mark_two;

    dbg$gl_current_primary = .prm_desc;						! A003

    dbg$newline();
    dbg$print_control(dbg$k_prtset_rlmargin,+4);	! Indent by +4
    subnode = .prm_desc[dbg$l_prim_blink];
    subnode[dbg$v_pnode_eval] = true;
    SELECTONE .subnode[dbg$b_pnode_fcode] OF
	SET
	[rst$k_type_array]:
	    BEGIN
	    LABEL cell;
	    LOCAL s_vector	: REF dbg$prim_node_subs;

	    s_vector = subnode[dbg$a_pnarr_svector];

    	    ! Check for the array being empty (i.e., if any of the 
    	    ! dimensions has zero or negative length). If this is the
    	    ! case, indicate that this is an empty array,
    	    ! and then clean up and return.
    	    !
    	    INCR i FROM 0 to .subnode[dbg$b_pnarr_dimcnt]-1 DO
    		BEGIN
    		IF .s_vector[.i,dbg$l_pnsub_lbound] GTR
    		   .s_vector[.i,dbg$l_pnsub_ubound]
    		THEN
    		    BEGIN
    		    dbg$print(UPLIT (%ASCIC '[empty array]'));
    		    dbg$newline();
    		    subnode[dbg$v_pnode_eval] = false;
    		    dbg$print_control(dbg$k_prtset_rlmargin,-4);
    		    RETURN;
    		    END;
    		END;

	    mark_one = dbg$push_tempmem();
	    dbg$sta_symtype(.subnode[dbg$l_pnarr_celltype],fcode,typeid);
	    dbg$build_primary_subnode(.prm_desc,rst$k_data,0,.fcode,.typeid,0);
	    dbg$collect(.prm_desc);
	    WHILE NOT .dbg$gv_control[dbg$v_control_stop] DO
cell:		BEGIN
		mark_two = dbg$push_tempmem();
		dbg$print_identifier(.prm_desc,0);
		IF .prm_desc[dbg$v_dhdr_aggr]
		  THEN dbg$print_aggregate(.prm_desc,.radix)
		  ELSE
		    BEGIN
		    dbg$print(UPLIT BYTE(%ASCIC '!AD!_'),1,UPLIT BYTE(':'));
    			
    		    ! If you examine a label array in PLI then you see the
    		    ! instructions at the labels. Instructions must always
    		    ! be represented as volatile value descriptors (since
    		    ! if you copy the bits, then the operands may change).
    	  	    !
    		    IF .fcode EQL rst$k_type_self_rel_lab
    		    THEN
    			dbg$prim_to_val(.prm_desc,dbg$k_v_value_desc,val_desc)
    		    ELSE
		        dbg$prim_to_val(.prm_desc,dbg$k_value_desc,val_desc);
		    dbg$print_value(.val_desc,.radix, .dbg$gl_sign_flag);
		    dbg$newline();
		    END;
		dbg$pop_tempmem(.mark_two);
		INCR dimension FROM 1 TO .subnode[dbg$b_pnarr_dimcnt] DO
		    BEGIN
		    LOCAL s,typeid: REF rst$entry;
		    s = (IF .subnode[dbg$v_pnarr_column]
			THEN .dimension - 1
			ELSE .subnode[dbg$b_pnarr_dimcnt] - .dimension);

    		    typeid  = .s_vector[.s,dbg$l_pnsub_typeid];    
		    IF  .s_vector[.s,dbg$l_pnsub_svalue] GEQ (
    		  	IF (.dbg$gb_language EQL dbg$k_ada) AND
    		           (.typeid NEQ 0)
    		  	THEN 
    		    	    IF (.typeid[rst$b_fcode] EQL rst$k_type_enum)
    		    	    THEN
    				dbg$enum_val(.typeid, .s_vector[.s,dbg$l_pnsub_ubound])
    			    ELSE
    				.s_vector[.s,dbg$l_pnsub_ubound]
    			ELSE
    			    .s_vector[.s,dbg$l_pnsub_ubound])
		    THEN
    			BEGIN

    			! For arrays indexed by enumeration types in ADA, the lower bound field gives
    			! the position, which we need to translate into a value.
    			!
    		        typeid  = .s_vector[.s,dbg$l_pnsub_typeid];    			
    		  	IF (.dbg$gb_language EQL dbg$k_ada) AND
    		           (.typeid NEQ 0)
    		  	THEN 
    		    	    IF (.typeid[rst$b_fcode] EQL rst$k_type_enum)
    		    	    THEN
    				s_vector[.s,dbg$l_pnsub_svalue] = dbg$enum_val(.typeid, .s_vector[.s,dbg$l_pnsub_lbound])
    			    ELSE
			        s_vector[.s,dbg$l_pnsub_svalue]  =  .s_vector[.s,dbg$l_pnsub_lbound]
    			ELSE
			    s_vector[.s,dbg$l_pnsub_svalue]  =  .s_vector[.s,dbg$l_pnsub_lbound];
    			END
		    ELSE
			BEGIN
    			LOCAL
    			    s_value;

    			! For arrays indexed by enumeration types in ADA, we need to use ENUM_SUCC to get
    			! the successor subscript. In all other cases, we can just add one.
    			!
    			s_value = .s_vector[.s,dbg$l_pnsub_svalue];
    		        typeid  = .s_vector[.s,dbg$l_pnsub_typeid];    			
    		  	IF (.dbg$gb_language EQL dbg$k_ada) AND
    		           (.typeid NEQ 0)
    		  	THEN 
    		    	    IF (.typeid[rst$b_fcode] EQL rst$k_type_enum)
    		    	    THEN
    				s_vector[.s,dbg$l_pnsub_svalue] = dbg$enum_succ(.typeid, .s_value)
    			    ELSE
			        s_vector[.s,dbg$l_pnsub_svalue]  =  .s_vector[.s,dbg$l_pnsub_svalue] + 1
    			ELSE
			    s_vector[.s,dbg$l_pnsub_svalue]  =  .s_vector[.s,dbg$l_pnsub_svalue] + 1;
			LEAVE cell;
			END;
		    END;
		EXITLOOP;
		END;			! End of block 'cell'
	    REMQUE(.prm_desc[dbg$l_prim_blink],dummy);
	    dbg$pop_tempmem(.mark_one);
	    END;

	[rst$k_type_record,rst$k_type_variant]:
	    BEGIN
	    LOCAL n_comps,s_vector : REF VECTOR [,LONG];
	    IF .subnode[dbg$b_pnode_fcode] EQL rst$k_type_record
	      THEN
		dbg$sta_typ_record(.subnode[dbg$l_pnode_typeid],n_comps,s_vector,dummy)
	      ELSE
		BEGIN
		n_comps  = .subnode[dbg$w_pnvar_ncomps];
		s_vector = .subnode[dbg$l_pnvar_complst];
		END;
	    INCR component FROM 0 TO .n_comps-1 DO
	      IF (symid = .s_vector[.component]) NEQ 0 THEN
		BEGIN
		IF .dbg$gv_control[dbg$v_control_stop] THEN EXITLOOP;
		IF .prm_desc[dbg$v_dhdr_tmpref] THEN
		    BEGIN
		    prm_desc[dbg$v_dhdr_tmpref] = false;
		    prm_desc[dbg$v_dhdr_subref] = false;
		    prm_desc[dbg$w_prim_offset] = 0;
		    prm_desc[dbg$w_prim_length] = 0;
		    END;
		mark_one = dbg$push_tempmem();
		dbg$sta_symkind(.symid,kind);
		IF .kind EQL rst$k_variant
		  THEN
		    BEGIN
		    LOCAL
			tagid,tag_val,
			tag_name	: REF VECTOR[,BYTE],
			variant		: REF rst$var_entry;
		    MAP symid		: REF rst$entry;

		    variant = 0;
		    IF (tagid = .symid[rst$l_vartagptr]) NEQ 0 THEN
			BEGIN
			dbg$sta_symname(.tagid,tag_name);
			IF .tag_name[0] NEQ 0 THEN
			    BEGIN
			    dbg$sta_symtype(.tagid,fcode,typeid);
			    dbg$build_primary_subnode(.prm_desc,rst$k_data,.tagid,.fcode,.typeid,0);
			    dbg$prim_to_val(.prm_desc,dbg$k_value_desc,val_desc);
			    tag_val = .val_desc[dbg$l_value_value0];
			    variant = dbg$sta_variant_select(.tag_val,.symid);
			    REMQUE(.prm_desc[dbg$l_prim_blink],dummy);
			    END;
			END;
		    IF .variant EQL 0
		      THEN
			BEGIN
			dbg$print(UPLIT(%ASCIC '!AD'),52,UPLIT BYTE('[Variant Record omitted - null or illegal Tag Value]'));
			dbg$newline();
			END
		      ELSE
			BEGIN
			dbg$build_primary_subnode(.prm_desc,rst$k_variant,0,rst$k_type_variant,0,0);
			subnode = .prm_desc[dbg$l_prim_blink];
			subnode[dbg$l_pnvar_tagid]   = .tagid;
			subnode[dbg$w_pnvar_index]   = 1;
			subnode[dbg$v_pnvar_valid]   = true;
			subnode[dbg$w_pnvar_ncomps]  = .variant[rst$l_var_compcnt];
			subnode[dbg$l_pnvar_complst] =  variant[rst$a_var_complst];
			subnode[dbg$l_pnvar_dstptr]  = .variant[rst$l_var_dstptr];
			dbg$print(UPLIT(%ASCIC '!AD'),30,UPLIT BYTE('Variant Record with Tag Value '));
			dbg$print_value(.val_desc,.radix, .dbg$gl_sign_flag);
			dbg$print_aggregate(.prm_desc,.radix);
			REMQUE(.prm_desc[dbg$l_prim_blink],dummy);
			END;
		    END
		  ELSE
		    BEGIN
		    dbg$sta_symtype(.symid,fcode,typeid);
		    dbg$build_primary_subnode(.prm_desc,.kind,.symid,.fcode,.typeid,0);
		    dbg$collect(.prm_desc);
		    IF .prm_desc[dbg$v_dhdr_aggr]
		      THEN
			BEGIN
			dbg$print_identifier(.prm_desc,0);
			dbg$print_aggregate(.prm_desc,.radix);
			END
		      ELSE
			BEGIN
			LOCAL name : REF VECTOR[,BYTE];
			dbg$sta_symname(.symid,name);
			IF .name[0] NEQ 0 THEN
			    BEGIN
			    dbg$print_identifier(.prm_desc,0);
			    dbg$print(UPLIT BYTE(%ASCIC '!AD!_'),1,UPLIT BYTE(':'));
			    dbg$prim_to_val(.prm_desc,dbg$k_value_desc,val_desc);
			    dbg$print_value(.val_desc,.radix, .dbg$gl_sign_flag);
			    dbg$newline();
			    END;
			END;
		    REMQUE(.prm_desc[dbg$l_prim_blink],dummy);
		    END;
		dbg$pop_tempmem(.mark_one);
		END;
	    END;

	[OTHERWISE]:
	    SIGNAL(dbg$_illtype);

	TES;

    subnode[dbg$v_pnode_eval]   = false;
    prm_desc[dbg$v_dhdr_aggr]   = true;
    prm_desc[dbg$b_dhdr_kind]   = .subnode[dbg$b_pnode_kind];
    prm_desc[dbg$b_dhdr_fcode]  = .subnode[dbg$b_pnode_fcode];
    prm_desc[dbg$l_dhdr_typeid] = .subnode[dbg$l_pnode_typeid];
    dbg$print_control(dbg$k_prtset_rlmargin,-4);	! Reset indentation
    END;				! End of dbg$print_aggregate

GLOBAL ROUTINE DBG$PRINT_VALUE(val_desc: REF dbg$valdesc,radix) : NOVALUE =
    BEGIN
    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;

    LOCAL
    	sign_flag,
	save_flag,
	vms_desc	: dbg$stg_desc;

    sign_flag = (actualcount() GTR 2 AND actualparameter(3));
    save_flag = (actualcount() LSS 4 OR  actualparameter(4));
    
    IF .save_flag THEN dbg$save_val(.val_desc);
    ch$move(12,val_desc[dbg$a_value_vmsdesc],vms_desc);

    IF .val_desc[dbg$v_dhdr_format] NEQ 0 THEN
	BEGIN
	SELECTONE .val_desc[dbg$v_dhdr_format] OF
	    SET
	    [1]:BEGIN		! Condition Value
		LOCAL
		    msgbuffer	: VECTOR [256,BYTE],
		    msg_desc	: dbg$stg_desc;

		msg_desc[dsc$b_class]   = dsc$k_class_s;
		msg_desc[dsc$b_dtype]   = dsc$k_dtype_t;
		msg_desc[dsc$w_length]  = 256;
		msg_desc[dsc$a_pointer] = msgbuffer;
		$GETMSG(MSGID  = .val_desc[dbg$l_value_value0],
			MSGLEN =  msg_desc[dsc$w_length],
			BUFADR =  msg_desc);
		dbg$print(UPLIT BYTE(%ASCIC '!AS'),msg_desc);
		END;

	    [2,3]:
		BEGIN
		BIND format_tab = UPLIT BYTE(%ASCIC '!_'),
		     header_one = UPLIT BYTE(%ASCIC 'CMP TP FPD IS CURMOD PRVMOD IPL'),
		     header_two = UPLIT BYTE(%ASCIC ' DV FU IV T N Z V C'),
		     mode_names = UPLIT ('KRNL','EXEC','SUPR','USER') : VECTOR[4,LONG];


		dbg$newline();
		dbg$print(format_tab);
		IF NOT .val_desc[dbg$v_dhdr_format] THEN dbg$print(header_one);
		dbg$print(header_two);
		dbg$newline();
		dbg$print(format_tab);
		IF NOT .val_desc[dbg$v_dhdr_format]
		  THEN dbg$print(UPLIT BYTE(%ASCIC '!2UL!4UL!3UL!4UL  !AD   !AD!5UL'),
				.(val_desc[dbg$l_value_value0])<31,1,0>,
				.(val_desc[dbg$l_value_value0])<30,1,0>,
				.(val_desc[dbg$l_value_value0])<27,1,0>,
				.(val_desc[dbg$l_value_value0])<26,1,0>,
				4,mode_names[.(val_desc[dbg$l_value_value0])<24,2,0>],
				4,mode_names[.(val_desc[dbg$l_value_value0])<22,2,0>],
				.(val_desc[dbg$l_value_value0])<16,5,0>);
		dbg$print(UPLIT BYTE(%ASCIC '!3(3UL)!5(2UL)'),
				.(val_desc[dbg$l_value_value0])<7,1,0>,
				.(val_desc[dbg$l_value_value0])<6,1,0>,
				.(val_desc[dbg$l_value_value0])<5,1,0>,
				.(val_desc[dbg$l_value_value0])<4,1,0>,
				.(val_desc[dbg$l_value_value0])<3,1,0>,
				.(val_desc[dbg$l_value_value0])<2,1,0>,
				.(val_desc[dbg$l_value_value0])<1,1,0>,
				.(val_desc[dbg$l_value_value0])<0,1,0>);
		END;

	    [OTHERWISE]:	SIGNAL(dbg$_interr,1,UPLIT BYTE(
			%ASCIC 'DBGVALUES\DBG$PRINT_VALUE - unknown format code'));
	    TES;
	RETURN;
	END;

    !+
    ! Radix will come in as something other than default if a radix was
    ! explicitly specified in the command as in EX/HEX or if a radix
    ! override was specified as in SET RADIX/OVERRIDE.
    !-
    IF .radix NEQ dbg$k_default
    THEN
	dbg$print_value_as_integer(vms_desc,.radix)
    ELSE
    	BEGIN
    	!+
	! Unless this is a "DEBUG" descriptor (created because a type override
	! switch has been given),  we first see if we can find any
	! language-specific formatting rules.
	!-
	IF (.val_desc[dbg$b_dhdr_fcode] NEQ rst$k_type_descr)
	 OR (.val_desc[dbg$b_value_class] NEQ dsc$k_class_z)
	  THEN IF dbg$language_format(.val_desc) THEN RETURN;
	!+
	! We get here if there are no language-specific formatting
	! rules applicable to this data item,  either because this
	! is a "DEBUG"-built value descriptor or because there are
	! no applicable language-specific format exception entries.
	!-
	SELECTONE .val_desc[dbg$b_dhdr_fcode]
	 OF SET
	    [rst$k_type_enum]:
		BEGIN
		LOCAL
		    size,n_elems,elem_vect : REF VECTOR[,LONG];

		dbg$sta_typ_enum(.val_desc[dbg$l_dhdr_typeid],n_elems,elem_vect,size);
		INCR e FROM 0 TO .n_elems-1 DO
		    BEGIN
		    LOCAL adr_kind,adr_ptrs : VECTOR[3,LONG];
		    dbg$sta_symvalue(.elem_vect[.e],adr_ptrs,adr_kind);
		    IF .adr_kind NEQ dbg$k_val_literal THEN SIGNAL(dbg$_unimplent);
		    IF .(.adr_ptrs[0])<.adr_ptrs[1],.size,0> EQL .val_desc[dbg$l_value_value0] THEN
			BEGIN
			dbg$print_symbol_name(.elem_vect[.e]);
			RETURN;
			END;
		    END;
		!+
		! Warn value out of range for enumeration type.
		!-
		SIGNAL(dbg$_enumrange);
		dbg$print_value_as_integer(vms_desc);
		END;

	    [rst$k_type_blifld]:
		BEGIN
		LOCAL
		    count,
		    fields: REF VECTOR[,LONG];

		fields = .val_desc[dbg$l_value_pointer];
		count = .fields[0];
		dbg$print(UPLIT BYTE(%ASCIC '['));
		INCR e from 1 to .count-1 DO
		    BEGIN
		    dbg$print(UPLIT BYTE(%ASCIC '!UL'), .fields[.e]);
		    dbg$print(UPLIT BYTE(%ASCIC ', '));
		    END;

		dbg$print(UPLIT BYTE(%ASCIC '!UL'), .fields[.count]);
		dbg$print(UPLIT BYTE(%ASCIC ']'));
		END;

	    [rst$k_type_set]:
		dbg$print_set_value(.val_desc);

	    [rst$k_type_file]:
		!++
		! Just print the information that this is a file pointer.
		!--
		dbg$print(UPLIT BYTE(%ASCIC 'file variable'));

	    [OTHERWISE]:
		BEGIN
		!+
		! Here if there are no special formatting rules for this FCODE.
		! Just look at the DTYPE in the descriptor, and print the value
		! in a type-dependent format.  However, we first have to ensure
		! that we have a valid CLASS field for LIB$CVT_DX_DX.
		!-
		IF .vms_desc[dsc$b_class] EQL dsc$k_class_z THEN vms_desc[dsc$b_class] = dsc$k_class_s;
		CASE .vms_desc[dsc$b_dtype] FROM dbg$k_minimum_dtype TO dbg$k_maximum_dtype OF
		    SET
		    !+
		    ! The first few case entries are for the various types of
		    ! ASCII text (ASCIC, ASCIZ, ASCIW).
		    ! These all get translated to ASCII (DTYPE dsc$k_dtype_t).
		    !-
    
		    [dsc$k_dtype_vt]:
			BEGIN
			vms_desc[dsc$w_length]  = .(.vms_desc[dsc$a_pointer])<0,16,0>;
			vms_desc[dsc$a_pointer] = 2+.vms_desc[dsc$a_pointer];
			vms_desc[dsc$b_class]   = dsc$k_class_s;
			vms_desc[dsc$b_dtype]   = dsc$k_dtype_t;
			dbg$print_vms_value(vms_desc);
			END;

		    [dsc$k_dtype_ac]:
			BEGIN
			vms_desc[dsc$w_length]  = .(.vms_desc[dsc$a_pointer])<0,8,0>;
			vms_desc[dsc$a_pointer] = 1+.vms_desc[dsc$a_pointer];
			vms_desc[dsc$b_class]   = dsc$k_class_s;
			vms_desc[dsc$b_dtype]   = dsc$k_dtype_t;
			dbg$print_vms_value(vms_desc);
			END;

		    [dsc$k_dtype_az]:
			BEGIN
			BUILTIN LOCC;
			LOCAL length;
			LOCC(%REF(0),vms_desc[dsc$w_length],.vms_desc[dsc$a_pointer];length);
			vms_desc[dsc$w_length] = .vms_desc[dsc$w_length] - .length;
			vms_desc[dsc$b_class]  = dsc$k_class_s;
			vms_desc[dsc$b_dtype]  = dsc$k_dtype_t;
			dbg$print_vms_value(vms_desc);
			END;

		    [dsc$k_dtype_b,dsc$k_dtype_bu,dsc$k_dtype_w,dsc$k_dtype_wu,
		     dsc$k_dtype_l,dsc$k_dtype_lu,dsc$k_dtype_q,dsc$k_dtype_qu,
		     dsc$k_dtype_o,dsc$k_dtype_ou]:
    			IF .dbg$gb_radix[dbg$b_radix_output] NEQ dbg$k_decimal
    			THEN
			    dbg$print_value_as_integer(vms_desc)
			ELSE
			    dbg$print_vms_value(vms_desc, .sign_flag);
    
		    [dsc$k_dtype_f ,dsc$k_dtype_d  ,dsc$k_dtype_g ,dsc$k_dtype_h  ,
		     dsc$k_dtype_fc,dsc$k_dtype_dc ,dsc$k_dtype_gc,dsc$k_dtype_hc ,
		     dsc$k_dtype_nl,dsc$k_dtype_nlo,dsc$k_dtype_nr,dsc$k_dtype_nro,
		     dsc$k_dtype_nu,dsc$k_dtype_nz ,dsc$k_dtype_p,dsc$k_dtype_t]:
			dbg$print_vms_value(vms_desc, .sign_flag);

		    [dsc$k_dtype_zi]:
			dbg$ins_decode(.vms_desc[dsc$a_pointer],true,false);

		    [dsc$k_dtype_zem]:
			dbg$ins_decode(.vms_desc[dsc$a_pointer],true,true);

		    [dsc$k_dtype_tf]:
			dbg$print(Format_AC,(IF .(.vms_desc[dsc$a_pointer])
						THEN UPLIT BYTE(%ASCIC 'True')
						ELSE UPLIT BYTE(%ASCIC 'False')));

		    [dsc$k_dtype_adt]:					       ! A002
			dbg$print_vms_value(vms_desc);			       ! A002

!		    [dsc$k_dtype_dsc]:

		    [INRANGE,OUTRANGE]:
			dbg$print_value_as_integer(vms_desc);
		    TES;	! CASE .vms_desc[dsc$b_dtype]
		END;
	    TES;		! SELECTONE .val_desc[dbg$b_dhdr_fcode]
	END;
    END;			! End of 'dbg$print_value'

GLOBAL ROUTINE DBG$PRINT_VALUE_AS_INTEGER(vms_desc: REF dbg$stg_desc) : NOVALUE =
    BEGIN
    BUILTIN ACTUALCOUNT,ACTUALPARAMETER,MOVC5;
    LOCAL
	radix,
    	radix_override_flag,	! TRUE if radix override was applied
	data_bytes,
	byte_size,
	data_size,
	data_addr,
	data_buff	: VECTOR [512+4,BYTE],
	digit_count,
	digit_value	: BYTE,
	text_index,
	text_buff	: VECTOR [512*9,BYTE];

    BIND digit = UPLIT BYTE('0123456789ABCDEF')	: VECTOR [16,BYTE];

    radix_override_flag = FALSE;
    IF actualcount() GTR 1
    THEN
    	BEGIN
    	radix = actualparameter(2);
    	IF .radix EQL dbg$k_default
    	THEN
    	    radix = dbg$nget_radix()
    	ELSE
    	    radix_override_flag = TRUE;
    	END
    ELSE
    	radix = dbg$nget_radix();

    text_index = 512*9;

    data_addr = .vms_desc[dsc$a_pointer];
    IF (data_size = dbg$data_length(.vms_desc)) GTR 512*%BPUNIT THEN
	BEGIN
	! ****	 SIGNAL(truncation)	***************************
	data_size = 512*%BPUNIT;
	END;
    data_bytes = (.data_size + (%BPUNIT-1))/%BPUNIT;
    MOVC5(data_bytes,.data_addr,%REF(0),%REF(512+4),data_buff);
    IF (.data_size AND (%BPUNIT-1)) NEQ 0
      THEN data_buff[.data_bytes-1] =
	  .data_buff[.data_bytes-1] AND NOT (-1^(.data_size AND (%BPUNIT-1)));

    SELECTONE .radix OF
	SET
	[dbg$k_decimal]:
	    BEGIN
	    SELECTONE .vms_desc[dsc$b_dtype] OF
		SET
		[dsc$k_dtype_bu,dsc$k_dtype_wu,
		 dsc$k_dtype_lu,dsc$k_dtype_qu,
		 dsc$k_dtype_ou,dsc$k_dtype_z ,
		 dsc$k_dtype_v,dsc$k_dtype_vu]:	
    		    IF .radix_override_flag
    		    THEN
		      IF .(data_buff)<.data_size-1,1,0> THEN
			BEGIN
			dbg$print(Format_AD,1,UPLIT BYTE('-'));
			INCR m FROM 0 TO .data_bytes-1 DO
			  IF .data_buff[.m] NEQ 0 THEN
			    BEGIN
			    data_buff[.m] = -.data_buff[.m];
			    INCR n FROM .m+1 TO .data_bytes-1 DO
			      data_buff[.n] = NOT .data_buff[.n];
			    EXITLOOP;
			    END;
			IF (.data_size AND (%BPUNIT-1)) NEQ 0
			  THEN data_buff[.data_bytes-1] =
			      .data_buff[.data_bytes-1] AND NOT (-1^(.data_size AND (%BPUNIT-1)));
			END;

		[OTHERWISE]:
		    IF .(data_buff)<.data_size-1,1,0> THEN
			BEGIN
			dbg$print(Format_AD,1,UPLIT BYTE('-'));
			INCR m FROM 0 TO .data_bytes-1 DO
			  IF .data_buff[.m] NEQ 0 THEN
			    BEGIN
			    data_buff[.m] = -.data_buff[.m];
			    INCR n FROM .m+1 TO .data_bytes-1 DO
			      data_buff[.n] = NOT .data_buff[.n];
			    EXITLOOP;
			    END;
			IF (.data_size AND (%BPUNIT-1)) NEQ 0
			  THEN data_buff[.data_bytes-1] =
			      .data_buff[.data_bytes-1] AND NOT (-1^(.data_size AND (%BPUNIT-1)));
			END;
		TES;

	    WHILE (data_size = .data_bytes) GTR 0 DO
		BEGIN
		LOCAL digit_val;
		data_bytes = 0;
		digit_val  = 0;
		DECR d FROM .data_size-1 TO 0 DO
		    BEGIN
		    digit_val = (.digit_val^8)+.data_buff[.d];
		    IF (data_buff[.d] = .digit_val/10) NEQ 0
		      THEN IF .data_bytes EQL 0 THEN data_bytes = .d+1;
		    digit_val = .digit_val - 10*(.digit_val/10);
		    END;
		text_buff[(text_index=.text_index-1)] = .digit_val<0,8,0>+'0';
		END;
	    dbg$print(Format_AD,512*9-.text_index,text_buff[.text_index]);
	    RETURN;
	    END;

	[dbg$k_binary]:	byte_size = 1;
	[dbg$k_octal]:	byte_size = 3;
	[dbg$k_hex]:	byte_size = 4;
!	[OTHERWISE]:
	TES;

    digit_count = (.data_size + (.byte_size-1))/.byte_size;

    INCR index FROM 0 TO .digit_count-1 DO
	BEGIN
	IF (.byte_size NEQ 3) AND ((.index AND 7) EQL 0) AND (.index NEQ 0)
	  THEN text_buff[(text_index = .text_index-1)] = ' ';
	digit_value = .digit[.(data_buff)<.index*.byte_size,.byte_size,0>];
	text_buff[(text_index = .text_index-1)] = .digit_value;
	END;

    IF .digit_value GTRU '9' THEN text_buff[(text_index = .text_index-1)] = '0';

    dbg$print(Format_AD,512*9-.text_index,text_buff[.text_index]);
    END;			! End of routine 'dbg$print_value_as_integer'

ROUTINE DBG$PRINT_VMS_VALUE(vms_desc: REF dbg$stg_desc) : NOVALUE =
    BEGIN
    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;
    BIND exp_zero = UPLIT BYTE('E+0000');	! Hack to fix FOR$CVT bug
    LOCAL
	local_desc	: dbg$stg_desc,
	buffer_desc	: dbg$stg_desc,
	status,
	text_buffer	: VECTOR [64,BYTE],
	text_length	: WORD;

    ch$move(12,.vms_desc,local_desc);
    buffer_desc[dsc$b_class]   = dsc$k_class_s;
    buffer_desc[dsc$b_dtype]   = dsc$k_dtype_t;
    buffer_desc[dsc$w_length]  = 64;
    buffer_desc[dsc$a_pointer] = text_buffer;

    SELECTONE .vms_desc[dsc$b_dtype] OF
	SET
	[dsc$k_dtype_fc,dsc$k_dtype_dc,dsc$k_dtype_gc,dsc$k_dtype_hc]:
	    BEGIN
	    local_desc[dsc$w_length] = .local_desc[dsc$w_length]/2;
	    local_desc[dsc$b_dtype]  = .local_desc[dsc$b_dtype] -2;
	    local_desc[dsc$b_class]  =  dsc$k_class_s;
	    dbg$print(FORMAT_AD,1,UPLIT BYTE('('));
	    dbg$print_vms_value(local_desc);
	    dbg$print(FORMAT_AD,1,UPLIT BYTE(','));
	    local_desc[dsc$a_pointer] = .local_desc[dsc$a_pointer] + .local_desc[dsc$w_length];
	    dbg$print_vms_value(local_desc);
	    dbg$print(FORMAT_AD,1,UPLIT BYTE(')'));
	    END;

	[dsc$k_dtype_f]:
    	    BEGIN
    	    BUILTIN CVTFD;
	    LOCAL dvalue : BLOCK[8,BYTE];
	    LOCAL digits,spaces,length;
	    BUILTIN SKPC,LOCC;

    	    ! Use the FORTRAN "G" format routine, which only prints the
    	    ! answer in exponential form if it has to.
    	    ! Since there is not FOR$CVT_F_TG routine, convert the source
    	    ! to d_float.
    	    !
    	    CVTFD(.local_desc[dsc$a_pointer], dvalue);
    	    IF NOT for$cvt_d_tg( dvalue,
    			         buffer_desc,
    			  	 7,		! Significant digits
    				 0,		! Scale factor
    				 1,		! Digits before decimal point
    						! in exponential form
    				 2)		! Digits after "E" 
    						! in exponential form
    	    THEN
    		$DBG_ERROR('DBGVALUES\DBG$PRINT_VMS_VALUE');

    	    ! The result is right-justified. Find the position where
    	    ! the result begins (the first non-blank character in the
    	    ! buffer) and print the result.
    	    !
    	    SKPC(%REF(' '),%REF(64),text_buffer;length,digits);
	    LOCC(%REF(' '),length,.digits;,spaces);
	    IF ch$eql(4,.spaces-4,4,exp_zero) THEN spaces = .spaces-4;
	    IF (actualcount() GTR 1 AND actualparameter(2))
	      AND (.(.digits)<0,8,0> NEQ '-')
		THEN DBG$PRINT(Format_AD,1,UPLIT BYTE('+'));
	    dbg$print(Format_AD, .spaces - .digits, .digits);
    	    END;

	[dsc$k_dtype_d]:
    	    BEGIN
	    LOCAL digits,spaces,length;
	    BUILTIN SKPC,LOCC;

    	    ! Use the FORTRAN "G" format routine, which only prints the
    	    ! answer in exponential form if it has to.
    	    !
    	    IF NOT for$cvt_d_tg(.local_desc[dsc$a_pointer], 
    			         buffer_desc,
    			  	 16,		! Significant digits
    				 0,		! Scale factor
    				 1,		! Digits before decimal point
    						! in exponential form
    				 2)		! Digits after "E" 
    						! in exponential form
    	    THEN
    		$DBG_ERROR('DBGVALUES\DBG$PRINT_VMS_VALUE');

    	    ! The result is right-justified. Find the position where
    	    ! the result begins (the first non-blank character in the
    	    ! buffer) and print the result.
    	    !
    	    SKPC(%REF(' '),%REF(64),text_buffer;length,digits);
	    LOCC(%REF(' '),length,.digits;,spaces);
	    IF ch$eql(4,.spaces-4,4,exp_zero) THEN spaces = .spaces-4;
	    IF (actualcount() GTR 1 AND actualparameter(2))
	      AND (.(.digits)<0,8,0> NEQ '-')
		THEN DBG$PRINT(Format_AD,1,UPLIT BYTE('+'));
	    dbg$print(Format_AD, .spaces - .digits, .digits);
    	    END;

	[dsc$k_dtype_g]:
    	    BEGIN
	    LOCAL digits,spaces,length;
	    BUILTIN SKPC,LOCC;

    	    ! Use the FORTRAN "G" format routine, which only prints the
    	    ! answer in exponential form if it has to.
    	    !
    	    IF NOT for$cvt_g_tg(.local_desc[dsc$a_pointer], 
    			         buffer_desc,
    			  	 15,		! Significant digits
    				 0,		! Scale factor
    				 1,		! Digits before decimal point
    						! in exponential form
    				 3)		! Digits after "E" 
    						! in exponential form
    	    THEN
    		$DBG_ERROR('DBGVALUES\DBG$PRINT_VMS_VALUE');

    	    ! The result is right-justified. Find the position where
    	    ! the result begins (the first non-blank character in the
    	    ! buffer) and print the result.
    	    !
    	    SKPC(%REF(' '),%REF(64),text_buffer;length,digits);
	    LOCC(%REF(' '),length,.digits;,spaces);
	    IF ch$eql(5,.spaces-5,5,exp_zero) THEN spaces = .spaces-5;
	    IF (actualcount() GTR 1 AND actualparameter(2))
	      AND (.(.digits)<0,8,0> NEQ '-')
		THEN DBG$PRINT(Format_AD,1,UPLIT BYTE('+'));
	    dbg$print(Format_AD, .spaces - .digits, .digits);
    	    END;

	[dsc$k_dtype_h]:
    	    BEGIN
	    LOCAL digits,spaces,length;
	    BUILTIN SKPC,LOCC;

    	    ! Use the FORTRAN "G" format routine, which only prints the
    	    ! answer in exponential form if it has to.
    	    !
    	    IF NOT for$cvt_h_tg(.local_desc[dsc$a_pointer], 
    			         buffer_desc,
    			  	 33,		! Significant digits
    				 0,		! Scale factor
    				 1,		! Digits before decimal point
    						! in exponential form
    				 4)		! Digits after "E" 
    						! in exponential form
    	    THEN
    		$DBG_ERROR('DBGVALUES\DBG$PRINT_VMS_VALUE');

    	    ! The result is right-justified. Find the position where
    	    ! the result begins (the first non-blank character in the
    	    ! buffer) and print the result.
    	    !
    	    SKPC(%REF(' '),%REF(64),text_buffer;length,digits);
	    LOCC(%REF(' '),length,.digits;,spaces);
	    IF ch$eql(6,.spaces-6,6,exp_zero) THEN spaces = .spaces-6;
	    IF (actualcount() GTR 1 AND actualparameter(2))
	      AND (.(.digits)<0,8,0> NEQ '-')
		THEN DBG$PRINT(Format_AD,1,UPLIT BYTE('+'));
	    dbg$print(Format_AD, .spaces - .digits, .digits);
    	    END;

	[dsc$k_dtype_t]:
	    BEGIN
    	    BUILTIN
    		PROBER;
    	    LOCAL
    		addr,
    		bytes;

	    local_desc[dsc$w_length] = MIN(.local_desc[dsc$w_length],2048);
    		
    	    ! Check for read access to the address. There are certain
    	    ! cases where we can get here with the address in the descriptor
    	    ! not readable. One example is EXAMINE/ASCID X, where X points
    	    ! to the descriptor
    	    !     0000FFFF
    	    !     00000000 
    	    ! In this case the VMS descriptor came from a volatile value
    	    ! descriptor, and the address "0" in the descriptor was never
    	    ! checked for readability.
    	    !
    	    addr = .local_desc[dsc$a_pointer];
    	    bytes = .local_desc[dsc$w_length];
	    IF NOT PROBER(%REF(0),bytes,.addr) 
    	    THEN 
    		SIGNAL(dbg$_noaccessr,1,.addr);
    	
	    dbg$print(UPLIT BYTE(%ASCIC '"!AF"'),.local_desc[dsc$w_length],
						 .local_desc[dsc$a_pointer]);
	    END;

	[OTHERWISE]:
	    BEGIN

    	    !+
    	    ! Somewhat of a hack for FORTRAN - the FORTRAN compiler gives
    	    ! us types BU, WU, LU for LOGICAL variables even though they
    	    ! are really treated as signed integers. Change the dtype here
    	    ! so we print them right.
    	    !-
    	    IF .dbg$gb_language EQL dbg$k_fortran
    	    THEN
    		IF .local_desc[dsc$b_dtype] EQL dsc$k_dtype_bu
    		THEN local_desc[dsc$b_dtype] = dsc$k_dtype_b
    		ELSE IF .local_desc[dsc$b_dtype] EQL dsc$k_dtype_wu
    		THEN local_desc[dsc$b_dtype] = dsc$k_dtype_w
    		ELSE IF .local_desc[dsc$b_dtype] EQL dsc$k_dtype_lu
    		THEN local_desc[dsc$b_dtype] = dsc$k_dtype_l;

	    dbg$cvt_dx_dx(local_desc,buffer_desc,text_length);

	    IF .signed_dtype[.local_desc[dsc$b_dtype]] AND
	     (actualcount() GTR 1 AND actualparameter(2)) AND
	     (.text_buffer[0] NEQ '-') AND (.text_buffer[0] NEQ '+') THEN
		BEGIN
		ch$move(.text_length,text_buffer[0],text_buffer[1]);
		text_buffer[0] = '+';
		text_length = .text_length + 1;
		END;

	    dbg$print(Format_AD,.text_length,text_buffer);
	    END;
	TES;
    END;			! End of dbg$print_vms_value

END
ELUDOM
