MODULE gencode2		(IDENT='V04-000',
			ADDRESSING_MODE(EXTERNAL=GENERAL))
= BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! Facility:	Command Definition Utility, Table Generator Module 2
!
! Abstract:	This module is one of a few modules that is responsible
!		for generating the blocks that make up the DCL tables.
!		The blocks are generated by traversing the intermediate
!		representation of the CLD file created by the parsing
!		modules.
!
!		It is recommended that you read over the CLIDEF.SDL file
!		before reading this code.
!
! Environment:	Standard CDU environment.
!
! Author:	Paul C. Anagnostopoulos
! Creation:	12 January 1983
!
! Modifications:
!--


library 'sys$library:lib';
require 'clitabdef';
require 'cdureq';

!	T A B L E   O F   C O N T E N T S
!	---------   ---   ---------------

forward routine
	cdu$generate_command: novalue,
	cdu$generate_outputs_list,
	cdu$generate_type: novalue;


!	E X T E R N A L   R E F E R E N C E S
!	---------------   -------------------

external routine
	cdu$add_verb_name,
	cdu$generate_entity,
	cdu$generate_expression,
	cdu$lookup_child,
	cdu$report_semantic_error,
	cli$present,
	lib$get_vm,
	lookup_verb_type;

external
	cdu$gl_table: pointer;

global
	clitype: byte;			! Temporary hack for ROUTINES.

!++
! Description:	This routine is called to generate a command block which
!		defines a verb or a syntax change.  Additional blocks
!		may be generated and chained off the command block.
!
! Parameters:	top_node	By reference, the node that represents the
!				verb or syntax change definition.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE cdu$generate_command(top_node: ref node)		: novalue
= BEGIN

local
	status: long,
	doing_verb: boolean,
	command: pointer,
	verb_name_dsc: descriptor,
	variable_ptr: pointer,
	child: ref node,
	grandchild: ref node,
	last_parm: pointer,
	qual_counter: long initial(0),
	last_qual: pointer,
	disallow_count: long initial(0),
	outputs_node: ref node initial(0),
	expression: ref node;


! Set a flag to say whether this is a verb definition or not.

doing_verb = .top_node[node_w_type] eqlu node_k_define_verb;

! Allocate enough space to contain the largest possible command block.

allocate_largest_table_block(cmd_k_length + cmd_k_max_name + cmd_k_max_image +
			     cmd_k_max_outputs + cmd_k_max_prefix, command);

! Begin by initializing the command block.  This includes any fields that
! don't depend on the intermediate representation.

command[cmd_b_type] = block_k_command;
command[cmd_b_subtype] = (if .doing_verb then cmd_k_verb else cmd_k_syntax);
command[cmd_w_flags] = 0;
command[cmd_w_tro_count] = 3;
command[cmd_l_parms] = command[cmd_l_quals] = command[cmd_l_disallow] = 0;
command[cmd_b_handler] = cmd_k_none;
command[cmd_v_minparm] = command[cmd_v_maxparm] = 0;
clitype = (if cli$present(dtext('CLI_MCR')) then vec_k_mcr else vec_k_dcl);
build_descriptor(verb_name_dsc,.top_node[node_b_text_length],top_node[node_t_text]);
command[cmd_b_verbtyp] = lookup_verb_type(verb_name_dsc);
command[cmd_w_name] = command[cmd_w_image] = command[cmd_w_outputs] = command[cmd_w_prefix] = 0;

! Set up to add information to the variable portion of the block.

variable_ptr = command[cmd_z_variable];

! Process the verb name(s) or the syntax name.

if .doing_verb then (
	local
		work_ptr: pointer;

	! The variable portion of the command block will contain an ASCIC
	! string of ASCIC strings, the first of which is the verb name and
	! the remainder the verb synonyms.  Move in the verb name.

	ch$move(1+.top_node[node_b_text_length],top_node[node_b_text_length], .variable_ptr+1);
	work_ptr = .variable_ptr+1 + 1+.top_node[node_b_text_length];

	! Add the verb name to verb name table.

	cdu$add_verb_name(verb_name_dsc,.command);

	! Scan the children of this definition looking for synonym nodes.

	scan_children(top_node,child,

		! If we have a synonym node, then move in the synonym.
		! Also add the synonym to the verb name table.

		if .child[node_w_type] eqlu node_k_synonym then (
			ch$move(1+.child[node_b_text_length],child[node_b_text_length],
				.work_ptr);
			work_ptr = .work_ptr + 1+.top_node[node_b_text_length];
			build_descriptor(verb_name_dsc,.child[node_b_text_length],child[node_t_text]);
			cdu$add_verb_name(verb_name_dsc,.command);

		);
	);

	! Set the length of the overall ASCIC string.

	variable_ptr[0,0,8,0] = .work_ptr - .variable_ptr - 1;

) else

	! The variable portion of the command block will contain the syntax
	! name as an ASCIC string.

	ch$move(1+.top_node[node_b_text_length],top_node[node_b_text_length], .variable_ptr);

! Store the BRO of the variable part we just generated, and adjust the
! variable portion pointer.

command[cmd_w_name] = .variable_ptr - .command;
variable_ptr = .variable_ptr + 1+.variable_ptr[0,0,8,0];

! Now we scan the children of the top-level node in order to collect the
! various attributes of the command and place them in the command block.

scan_children(top_node,child,

	! Case on the type of the child.

	case .child[node_w_type] from 0 to node_k_max_type of set
	[node_k_cliflags]:

		! For the CLIFLAGS clause, we scan the children, each of
		! which specifies a flag to be set.

		scan_children(child,grandchild,

			selectoneu .grandchild[node_w_type] of set
			[node_k_abbrev]:	command[cmd_v_abbrev] = true;
			[node_k_foreign]:	command[cmd_v_foreign] = true;
			[node_k_immed]:		command[cmd_v_immed] = true;
			[node_k_mcrparse]:	command[cmd_v_mcrparse] = true;
			[node_k_nostat]:	command[cmd_v_nostat] = true;
			[otherwise]:		cdu$report_semantic_error(msg(cdu$_igncliflag),1,
							.grandchild[node_w_line]);
			tes;
		);

	[node_k_cliroutine]:

		! The CLIROUTINE clause specifies the name of an internal
		! CLI routine which is called to perform the command.  Set
		! the handler code accordingly.

		(command[cmd_b_handler] = cmd_k_cli;

		! Copy the name of the CLI routine into the variable portion
		! of the command block.

		command[cmd_w_image] = .variable_ptr - .command;
		ch$move(1+.child[node_b_text_length],child[node_b_text_length],
			.variable_ptr);
		variable_ptr = .variable_ptr + 1+.child[node_b_text_length];);

	[node_k_disallow]:

		! A DISALLOW clause specifies a boolean combination of
		! entities which are invalid.  Generate code for the
		! boolean expression.

		(grandchild = .child[node_l_child];
		cdu$generate_expression(.top_node,.grandchild);

		! Propagate the TRO of the resulting expression block up
		! to the disallow node.

		child[node_l_code] = .grandchild[node_l_code];

		! Set the flag saying that disallow info has been supplied.

		command[cmd_v_disallows] = true;

		! Count the number of DISALLOW statements for use below.

		increment(disallow_count););

	[node_k_nodisallows]:

		! The NODISALLOWS clause specifies that this verb or syntax
		! change has no disallow expressions.  Set the flag saying
		! that the disallow info is relevent.  The absence of a
		! disallows expression block will tell DCL that there are
		! none.

		command[cmd_v_disallows] = true;

	[node_k_image]:

		! The IMAGE clause specifies the file spec of the image to
		! be run when the verb is entered.  This is treated exactly
		! as the CLIROUTINE case above, except that the handler code
		! is different.

		(command[cmd_b_handler] = cmd_k_image;
		command[cmd_w_image] = .variable_ptr - .command;
		ch$move(1+.child[node_b_text_length],child[node_b_text_length],
			.variable_ptr);
		variable_ptr = .variable_ptr + 1+.child[node_b_text_length];);

	[node_k_outputs]:

		! Remember the address of the OUTPUTS node so we can process
		! it later.

		outputs_node = .child;

	[node_k_parameter]:

		! We have a PARAMETER clause, which defines a parameter.
		! Generate an entity block for it, which will tell us
		! if the parameter is required.

		(increment(command[cmd_v_maxparm]);
		cdu$generate_entity(.child,.command[cmd_v_maxparm]);

		! Form the entity blocks into a list, with the TRO of the
		! first one in the command block.

		if .command[cmd_v_maxparm] eqlu 1 then
			command[cmd_l_parms] = .child[node_l_code]
		else
			last_parm[ent_l_next] = .child[node_l_code];
		last_parm = .cdu$gl_table + .child[node_l_code];

		! Set the flag saying that parameter info has been supplied.

		command[cmd_v_parms] = true;

		! If the parameter is required, then increment the minimum
		! parameter count.  Required parameters cannot follow optional
		! ones.

		begin
		bind
			entity = .cdu$gl_table + .child[node_l_code]: block[,byte];

		if .entity[ent_v_valreq] then (
			increment(command[cmd_v_minparm]);
			if .command[cmd_v_maxparm] gtru .command[cmd_v_minparm] then
				cdu$report_semantic_error(msg(cdu$_invreqparm),1,.child[node_w_line]);
		);
		end;);

	[node_k_noparameters]:

		! The NOPARAMETERS clause specifies that this verb or syntax
		! change takes no parameters.  Set the flag saying that the
		! parameter info is relevent.  The absence of a list of
		! entity blocks will tell DCL that there are no parameters.

		command[cmd_v_parms] = true;

	[node_k_prefix]:

		! Save the symbol prefix specified in the PREFIX clause as
		! an ASCIC string.

		(command[cmd_w_prefix] = .variable_ptr - .command;
		ch$move(1+.child[node_b_text_length],child[node_b_text_length],
			.variable_ptr);
		variable_ptr = .variable_ptr + 1+.child[node_b_text_length];);

	[node_k_qualifier]:

		! We have a QUALIFIER clause, which defines a qualifier.
		! Generate an entity block for it.

		(increment(qual_counter);
		cdu$generate_entity(.child,.qual_counter);

		! Form the entity blocks into a list, with the TRO of the
		! first one in the command block.

		if .qual_counter eqlu 1 then
			command[cmd_l_quals] = .child[node_l_code]
		else
			last_qual[ent_l_next] = .child[node_l_code];
		last_qual = .cdu$gl_table + .child[node_l_code];

		! Set the flag saying that qualifier info has been supplied.

		command[cmd_v_quals] = true;);

	[node_k_noqualifiers]:

		! The NOQUALIFIERS clause specifies that this verb or syntax
		! change takes no qualifiers.  Set the flag saying that the
		! qualifier info is relevent.  The absence of a list of
		! entity blocks will tell DCL that there are no qualifiers.

		command[cmd_v_quals] = true;

	[node_k_routine]:

		! The ROUTINE clause specifies the name of a routine in the
		! user's program which is called to perform the command.
		! Set the handler type accordingly.

		(command[cmd_b_handler] = cmd_k_user;

		! Allocate a longword in the variable portion of the block
		! which will be filled in with the routine address by the
		! Linker.

		command[cmd_w_image] = .variable_ptr - .command;
		variable_ptr = .variable_ptr + 4;

		! Place the name of the routine after the longword, stored
		! as an ASCIC string.

		ch$move(1+.child[node_b_text_length],child[node_b_text_length],
			.variable_ptr);
		variable_ptr = .variable_ptr + 1+.child[node_b_text_length];);

	[node_k_synonym]:

		! These nodes were already processed up above.

		;

	[inrange,
	 outrange]:

		! Oops, we have some kind of internal error.

		signal(msg(cdu$_intinvnode));
	tes;
);

! Now we may need to do some additional processing for DISALLOW clauses.
! This involves creating an expression block which ORs together all of the
! boolean expressions specified in DISALLOW clauses.  We have counted the
! number of clauses, so allocate space for the expression block.

if .disallow_count nequ 0 then (
	allocate_largest_table_block(exp_k_length + .disallow_count*4, expression);

	! Initialize the header of the expression block.

	expression[exp_b_type] = block_k_expression;
	expression[exp_b_subtype] = exp_k_or;
	expression[exp_w_flags] = 0;
	expression[exp_w_tro_count] = 0;

	! Find all of the DISALLOW clauses and store the TRO of the
	! corresponding expression blocks as the operands of this OR block.

	begin
	bind
		operand_list = expression[exp_l_operand_list]: vector[,long];

	scan_children(top_node,child,
		if .child[node_w_type] eqlu node_k_disallow then (
			operand_list[.expression[exp_w_tro_count]] = .child[node_l_code];
			increment(expression[exp_w_tro_count]);
		);
	);
	end;

	! Set the size of the expression block in its header.

	set_table_block_size(exp_k_length + .disallow_count*4, expression);

	! Store the TRO of this new OR expression block in the command block.

	command[cmd_l_disallow] = .expression - .cdu$gl_table;
);

! If there was an outputs clause, then we can process it now.

if .outputs_node neqa 0 then (
	command[cmd_w_outputs] = .variable_ptr - .command;
	variable_ptr = .variable_ptr +
		       cdu$generate_outputs_list(.top_node, .outputs_node, .variable_ptr);
);

! Once we have processed all of the clauses, we need to handle additional
! cases which are implied by the clauses.
!
!	If no command handler has been specified, then apply some defaults.
!	Object files can only have user routine handlers, and CLI table
!		images cannot.

if .command[cmd_b_handler] eqlu cmd_k_none then
	if .doing_verb then (
		if not cli$present(dtext('OBJECT')) then (
			command[cmd_b_handler] = cmd_k_image;
			command[cmd_w_image] = .command[cmd_w_name] + 1;
		)
	) else
		command[cmd_b_handler] = cmd_k_same;

if cli$present(dtext('OBJECT')) then (
	if .command[cmd_b_handler] eqlu cmd_k_cli or
	   .command[cmd_b_handler] eqlu cmd_k_image then
		cdu$report_semantic_error(msg(cdu$_routreq),1,.top_node[node_w_line]);
) else
	if .command[cmd_b_handler] eqlu cmd_k_user then
		cdu$report_semantic_error(msg(cdu$_invrout),1,.top_node[node_w_line]);

! Set the final size of the command block in its header.

set_table_block_size(.variable_ptr - .command, command);

! Place the TRO of the new block in its top-level representation node.

top_node[node_l_code] = .command - .cdu$gl_table;
return;

END;

!++
! Description:	This routine is called when an outputs list must be added
!		to a command block.  An outputs list is the result of an
!		OUTPUTS clause in the CLD, which contains a list of
!		parameters or qualifiers which specify output files.
!		Such clauses are only needed for the old CLI interface.
!
!		The outputs list consists of a counted sequence of bytes,
!		one for each item in the OUTPUTS clause.  Each byte
!		contains the negative of the parameter number (for
!		parameters), or the qualifier number (for qualifiers).
!
! Parameters:	parent		By reference, the parent of the outputs
!				node, which has the parameters and qualifiers
!				as its children.
!		outputs		By reference, the outputs node.
!		outputs_list	By reference, the location which is to
!				receive the outputs list.
!
! Returns:	By value, the length of the outputs list.
!
! Notes:
!--

GLOBAL ROUTINE cdu$generate_outputs_list(parent: ref node,
					 outputs: ref node,
					 outputs_list: pointer)
= BEGIN

local
	outputs_ptr: pointer,
	outputs_item: ref node,
	entity: ref node;


! Scan each of the children of the outputs node, placing one byte in the
! outputs list for each one.

outputs_ptr = .outputs_list + 1;
scan_children(outputs,outputs_item,

	! Each output item specifies an entity which is an output of the
	! command.  The entity is specified by its label (as given in a
	! LABEL clause), or, if there is no label, by its name.  Scan the
	! children of the parent node looking for the one which represents
	! the output entity.

	scan_children(parent,entity,

		if .entity[node_w_type] eqlu node_k_parameter or
		   .entity[node_w_type] eqlu node_k_qualifier then (

			if cdu$lookup_child(.entity,node_k_label,.outputs_item[node_b_text_length],
					    outputs_item[node_t_text]) neqa 0 then
				exitloop
			else if ch$eql(.outputs_item[node_b_text_length],outputs_item[node_t_text],
				       .entity[node_b_text_length],entity[node_t_text],%x'00') then
				exitloop;
		);
	);

	! If we found the parameter or qualifier, then set up a pointer to
	! the entity block generated for it.

	if .entity neqa 0 then (
		bind
			entity_block = .cdu$gl_table + .entity[node_l_code]: block[,byte];

		! If the entity is a parameter, store the negative of its
		! number in the outputs list.  If a qualifier, store the
		! qualifier number.

		outputs_ptr[0,0,8,1] = (if .entity_block[ent_b_subtype] eqlu ent_k_parameter then
						-.entity_block[ent_b_number]
					else
						.entity_block[ent_b_number]);
		increment(outputs_ptr);

	) else

		! We didn't find the parameter or qualifier.

		cdu$report_semantic_error(msg(cdu$_undefoutput),2,.outputs_item[node_w_line],
					  outputs_item[node_b_text_length]);
);

! Store the count of outputs at the front of the outputs list.

outputs_list[0,0,8,0] = .outputs_ptr - .outputs_list - 1;

! Return the length of the outputs list.

return 1+.outputs_list[0,0,8,0];

END;

!++
! Description:	This routine is called to generate a type block and the list
!		of entity blocks which represent the keywords.  The entity
!		blocks are linked together and hung off the type block.
!
! Parameters:	top_node	By reference, the node that represents the
!				type definition.  Its children are the
!				keyword nodes.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE cdu$generate_type(top_node: ref node)	: novalue
= BEGIN

local
	status: long,
	type: pointer,
	variable_ptr: pointer,
	child: ref node,
	keyword_counter: long initial(0),
	last_block: pointer;


! Allocate enough space to contain the largest possible type block.

allocate_largest_table_block(type_k_length + type_k_max_name + type_k_max_prefix, type);

! Begin by initializing the type block.  This includes any fields that
! don't depend on the intermediate representation.

type[type_b_type] = block_k_type;
type[type_b_subtype] = type_k_type;
type[type_w_flags] = 0;
type[type_w_tro_count] = 1;
type[type_w_name] = type[type_w_prefix] = 0;

! Set up to add information to the variable portion of the block.

variable_ptr = type[type_z_variable];

! Add the type name to the type block as an ASCIC string.

type[type_w_name] = .variable_ptr - .type;
ch$move(1+.top_node[node_b_text_length],top_node[node_b_text_length],
	.variable_ptr);
variable_ptr = .variable_ptr + 1+.top_node[node_b_text_length];

! Scan the children of the node representing the type definition.

scan_children(top_node,child,

	! Determine our action based on the type of child node.

	selectoneu .child[node_w_type] of set
	[node_k_prefix]:

		! Save the symbol prefix specified in the PREFIX clause as
		! an ASCIC string.

		(type[type_w_prefix] = .variable_ptr - .type;
		ch$move(1+.child[node_b_text_length],child[node_b_text_length],
			.variable_ptr);
		variable_ptr = .variable_ptr + 1+.child[node_b_text_length];);


	[node_k_keyword]:

		! We have a keyword definition.  Generate an entity block
		! for it.

		(increment(keyword_counter);
		cdu$generate_entity(.child,.keyword_counter);

		! If this is the first keyword, then store its TRO in the
		! type block.  Otherwise, chain this new entity block onto
		! the previous one to form a list.

		if .keyword_counter eqlu 1 then
			type[type_l_keywords] = .child[node_l_code]
		else
			last_block[ent_l_next] = .child[node_l_code];
		last_block = .cdu$gl_table + .child[node_l_code];);

	[otherwise]:

		! Oops, we have some kind of internal error.

		signal(msg(cdu$_intinvnode));
	tes;
);

! Set the final size of the type block.

set_table_block_size(.variable_ptr - .type, type);

! Place the TRO of the new block in its top-level representation node.

top_node[node_l_code] = .type - .cdu$gl_table;
return;

END;

END
ELUDOM
