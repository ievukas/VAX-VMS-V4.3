MODULE PAS$HANDLER ( %TITLE 'Handler established by compiled code'
		IDENT = '1-002'		! File: PASANDLE.B32 Edit: SBL1002
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Pascal Language Support
!
! ABSTRACT:
!
!	This module contains PAS$HANDLER, the condition handler established
!	by Pascal compiled code routines which have local files or checking.
!
! ENVIRONMENT:	User mode - AST reentrant
!
! AUTHOR: Steven B. Lionel, CREATION DATE: 1-April-1981
!
! MODIFIED BY:
!
! 1-001	- Original.  SBL 1-April-1981
! 1-002 - Add enable of PAS$$GOTO_HANDLER, call of PAS$$UNWIND_GOTO to
!	  support revised PAS$GOTO.  SBL 28-Jan-1983
!--


%SBTTL 'Declarations'
!
! PROLOGUE DEFINITIONS:
!

REQUIRE 'RTLIN:PASPROLOG';			! Externals, linkages, PSECTs, structures

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    PAS$HANDLER;				! Compiled code handler

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! FIELDS:
!
!	NONE
!
! OWN STORAGE:
!
!	NONE

%SBTTL 'PAS$HANDLER - Compiled code handler'
GLOBAL ROUTINE PAS$HANDLER (
    	SIGNAL_ARGS: REF BLOCK [, BYTE], 	! Signal arguments array
    	MECH_ARGS: REF BLOCK [, BYTE]		! Mechanism arguments array
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This condition handler is established by VAX-11 Pascal compiled
!	code in the procedure prologue.  It performs the following
!	services:
!
!	   If the current exception is PAS$_GOTO, generated by an up-level
!	   GOTO, PAS$$UNWIND_GOTO is called and control returns to CHF.
!
!	   Otherwise:
!		1.  Calls user condition handler declared with
!		    ESTABLISH, including the environment value.
!		    The user handler address and the environment
!		    value are at offsets -8 and -4 from the establisher's FP.
!
!		2.  Intercepts certain exceptions generated by compiled
!		    code for run-time error checking, and converts them
!		    into Pascal-specific messages.
!
!		3.  Closes any locally-declared files upon an unwind.
!
! CALLING SEQUENCE:
!
!	status.wlc.v = PAS$HANDLER (SIGNAL_ARGS.ml.ra, MECH_ARGS.rl.ra)
!
! FORMAL PARAMETERS:
!
!	SIGNAL_ARGS	- The signal argument list.  This may be modified.
!
!	MECH_ARGS	- The mechanism argument list.
!
! IMPLICIT INPUTS:
!
!	For certain exceptions, the instruction stream pointed to by the
!	signaled PC is used to determine the correct Pascal-specific
!	message.
!
!	User-established condition handler and environment value at -8 and
!	-4 of users FP.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	SS$_RESIGNAL, or as returned from user handler
!
! SIDE EFFECTS:
!
!	May close local files.
!
!--

    BEGIN

    LOCAL
	USERS_FRAME: REF VECTOR [, LONG],	! User's stack frame
	RETURN_STATUS;				! Handler return status

    LABEL
	INSTR_BLOCK;				! Block looking at instruction stream

    BUILTIN
	AP,					! Argument pointer
	CALLG,					! CALLG instruction
	PROBER;					! Probe for read

    !+
    ! Declare special linkage used for calling user condition handlers.
    !-

    LINKAGE
	CALL_USER_HANDLER = CALL (REGISTER=1,	! Environment pointer
				  STANDARD,	! Signal argument list
				  STANDARD);	! Mechanism argument list
    !+
    ! Establish PAS$$GOTO_HANDLER as our handler to catch up-level GOTOs
    ! while doing condition handling.
    !-

    ENABLE
	PAS$$GOTO_HANDLER;

    !+
    ! Get the stack frame pointer of our establisher.
    !-

    USERS_FRAME = .MECH_ARGS [CHF$L_MCH_FRAME];

    !+
    ! Initialize handler return status to SS$_RESIGNAL.
    !-

    RETURN_STATUS = SS$_RESIGNAL;

    !+
    ! Determine if this is an up-level GOTO.  If so, call PAS$$UNWIND_GOTO
    ! and return.  It may only return SS$_RESIGNAL, but we don't want
    ! the user handlers to see PAS$_GOTO.
    !-

    IF .SIGNAL_ARGS [CHF$L_SIG_NAME] EQLU PAS$_GOTO
    THEN
	RETURN (CALLG (.AP, PAS$$UNWIND_GOTO));

    !+
    ! Determine if this is an unwind.
    !-

    IF .SIGNAL_ARGS [CHF$L_SIG_NAME] EQLU SS$_UNWIND
    THEN
	BEGIN

	!+
	! This is an unwind.  First, call the user's handler, if there
	! is one.
	!-

	IF .USERS_FRAME [-2] NEQ 0	! Handler present?
	THEN
	    RETURN_STATUS = CALL_USER_HANDLER (
	    	.USERS_FRAME [-2],	! Handler address
		.USERS_FRAME [-1],	! Environment
		.SIGNAL_ARGS,		! Signal arguments
		.MECH_ARGS);		! Mechanism arguments

	!+
	! Now call PAS$$CLOSE_LOCAL to close any local files.
	!-

	PAS$$CLOSE_LOCAL (.USERS_FRAME);

	END	! End of actions for unwind

    ELSE

	BEGIN

	!+
	! This is not an unwind.  Check to see if it is an exception generated
	! by compiled code.  If so, information in the instruction stream
	! tells us which PAS$ message to turn the signal into.
	!
	! The following table gives the combinations we are interested in,
	! and the location of the code (0-63)
	!	Exception	Instruction	Code byte location
	!	---------	-----------	------------------
	!	SS$_OPCDEC	HALT		.BYTE after HALT
	!	SS$_SUBRNG	INDEX		TSTB #x (current instruction)
	!	SS$_INTOVF	any		TSTB #x (current instruction)
	!
	! Special case:  If the exception is SS$_SUBRNG and the next instruction
	! is not a TSTB #x, signal PAS$_ARRINDVAL.
	!-

	IF  .MECH_ARGS [CHF$L_MCH_DEPTH] EQL 0 AND
	    ((.SIGNAL_ARGS [CHF$L_SIG_NAME] EQLU SS$_OPCDEC) OR
	     (.SIGNAL_ARGS [CHF$L_SIG_NAME] EQLU SS$_SUBRNG) OR
	     (.SIGNAL_ARGS [CHF$L_SIG_NAME] EQLU SS$_INTOVF))
	THEN
	    !+
	    ! Create labelled block to contain code that looks at the
	    ! instruction stream.  If at any time, the conditions are not
	    ! consistent with converting the exception to a PAS$ exception,
	    ! just leave the block. 
	    !-
	    INSTR_BLOCK: BEGIN

	    LOCAL
		INSTR_PC: REF VECTOR [, BYTE],	! Signaled PC
		OPCODE: WORD,			! Opcode at signaled PC
		NEW_MESSAGE: BLOCK [4, BYTE];	! Replacement message code

	    LITERAL
		OPC_HALT = %X'00',		! Opcode for HALT
		OPC_BPT = %X'03',		! Opcode for BPT
		OPC_TSTB = %X'95';		! Opcode for TSTB

	    !+
	    ! Are there just 3 signal arguments?  There should be just the
	    ! condition name, PC and PSL.  If not, resignal.
	    !-

	    IF .SIGNAL_ARGS [CHF$L_SIG_ARGS] NEQ 3
	    THEN
		LEAVE INSTR_BLOCK;		! Just resignal

	    !+
	    ! Can we read the instruction byte and the following byte?
	    !-

	    INSTR_PC = .SIGNAL_ARGS [8,0,32,0];	! Get PC of instruction
	    IF NOT PROBER (%REF(0), %REF(2), INSTR_PC [0])	! PC
	    THEN
		LEAVE INSTR_BLOCK;		! Resignal if can't access

	    !+
	    ! Get the opcode byte.
	    !-

	    OPCODE = .INSTR_PC [0];

	    !+
	    ! If the opcode byte is BPT, then it looks like the user
	    ! set a breakpoint on this instruction.  Call LIB$GET_OPCODE
	    ! to find out what the byte really is.
	    !-

!! Don't call LIB$GET_OPCODE on VMS V2
%IF %VARIANT
%THEN
%ELSE
	    IF .OPCODE EQLU OPC_BPT	! BPT opcode
	    THEN
		OPCODE = LIB$GET_OPCODE (INSTR_PC [0]);
%FI

	    !+
	    ! Now, if the exception is SS$_OPCDEC, then the instruction
	    ! must be HALT.  Otherwise, it must be TSTB.
	    !-

	    IF .SIGNAL_ARGS [CHF$L_SIG_NAME] EQL SS$_OPCDEC
	    THEN
		BEGIN
		IF .OPCODE NEQ OPC_HALT
		THEN
		    LEAVE INSTR_BLOCK;		! Just resignal
		END
	    ELSE IF .OPCODE NEQ OPC_TSTB	! SUBRNG or INTOVF
	    THEN
		BEGIN
		IF .SIGNAL_ARGS [CHF$L_SIG_NAME] EQL SS$_SUBRNG
		THEN
		    SIGNAL_ARGS [CHF$L_SIG_NAME] = PAS$_ARRINDVAL;
		LEAVE INSTR_BLOCK;		! Just resignal
		END;

	    !+
	    ! Ok, we now know that the current instruction is
	    ! one that the compiler uses to signal us that we should
	    ! translate the exception.  The next byte must be in the
	    ! range 0-63.  This is either a .BYTE following the
	    ! HALT or a short literal following the TSTB.
	    !-

	    IF .INSTR_PC [1] GTRU 63
	    THEN
		LEAVE INSTR_BLOCK;		! Just resignal

	    !+
	    ! If the code is PAS$K_IGNORE, meaning that the compiled
	    ! code wants us to ignore this exception, continue execution
	    ! by returning SS$_CONTINUE.
	    !-

	    IF .INSTR_PC [1] EQLU PAS$K_IGNORE
	    THEN
		RETURN SS$_CONTINUE;

	    !+
	    ! Ok, construct the PAS$ message, replacing the system
	    ! message.
	    !-

	    NEW_MESSAGE = PAS$_BASE;		! Base message
	    NEW_MESSAGE [STS$V_CODE] = .INSTR_PC [1] + PAS$$K_MSGCHKBAS;
	    SIGNAL_ARGS [CHF$L_SIG_NAME] = .NEW_MESSAGE;

	    !+
	    ! Step the PC over the two bytes.
	    !-

	    SIGNAL_ARGS [8,0,32,0] = .SIGNAL_ARGS [8,0,32,0] + 2;

	    END;

	!+
	! Call the user's handler, if any.
	!-

	IF .USERS_FRAME [-2] NEQ 0	! Handler present?
	THEN
	    RETURN_STATUS = CALL_USER_HANDLER (
	    	.USERS_FRAME [-2],	! Handler address
		.USERS_FRAME [-1],	! Environment
		.SIGNAL_ARGS,		! Signal arguments
		.MECH_ARGS);		! Mechanism arguments

	END; 	
	
    RETURN .RETURN_STATUS;			! Return to CHF

    END;					! End of routine PAS$HANDLER

!<BLF/PAGE>

END						! End of module PAS$HANDLER

ELUDOM
