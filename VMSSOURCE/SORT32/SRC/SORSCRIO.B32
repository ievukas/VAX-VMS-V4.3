MODULE SOR$SCR_IO (
		IDENT = 'V04-000'	! File: SORSCRIO.B32 Edit: PDG3053
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:	VAX-11 SORT/MERGE
!
! ABSTRACT:
!
!	This module contains RMS I/O support for work/scratch files.
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: Peter D Gilbert, CREATION DATE: 10-May-1982
!
! MODIFIED BY:
!
!	T03-015		Original
!	T03-016	Fix problem with computing COM_BUF_SIZE (due to DDB not set).
!		Check status after calling COM_INPUT.  PDG 13-Dec-1982.
!	T03-017	Errors opening scratch files now recoverable.  PDG 16-Dec-1982
!	T03-018	Make write errors to a work file fatal.  PDG 22-Dec-1982
!	T03-019	Make the size of the buffer passed to the user-written input
!		routine for merges equal to the LRL (rather than larger).
!		PDG 26-Dec-1982.
!	T03-020	Changed to use QIOWs for work file I/O.
!		Added protection XAB.  PDG 28-Dec-1982
!	T03-021	Make work-file description blocks (WFBs) distinct from DDBs.
!		PDG 31-Dec-1982
!	T03-022	Added clean-up routines.  PDG 4-Jan-1983
!	T03-023	Added a FNS parameter to WORK_OPEN.  PDG 6-Jan-1983
!	T03-024	Remove declaration of unreferenced externals.  PDG 26-Jan-1983
!	T03-025	Added WFB_USE field.  Set COM_MRG_STREAM to the file or stream
!		number.  PDG 27-Jan-1983
!	T03-026	Use COM_MERGE (rather than COM_MRG_ORDER) to indicate a merge.
!		PDG 31-Jan-1983
!	T03-027	Changes for hostile environment.  PDG 3-Feb-1983
!	T03-028	Pass the context address to callback routines.  PDG 11-Feb-1983
!	T03-029	Make SOR$_NO_WRK fatal in WORK_OPEN.  PDG 9-Mar-1983
!	T03-030	Maximize DEQ with TUN_K_BUFSIZE.  PDG 31-Mar-1983
!	T03-031	Information hiding of WFB structure.  PDG 12-Apr-1983
!	T03-032	Remove declaration of WFB_DEV.  PDG 13-Apr-1983
!	T03-033	Make DELRUN and POSITION non-global routines.  Call FLUSH with
!		COM_RUN_CURR in SOR$$WORK_MERGE.  Remove DST parameter from
!		WORK_MERGE routines.  PDG 14-Apr-1983
!	T03-034	Move definitions of fields specific to scratch-i/o from SORLIB
!		into this module.  PDG 18-Apr-1983
!	T03-035	Massive changes; better use of scratch file space, by allowing
!		runs to be composed of little pieces (RDBs).  PDG 22-Apr-1983
!	T03-036	Page align the work file buffers.  PDG 27-Apr-1983
!	T03-037	Check for more than 127 pages in WORK_WRITE.  PDG 28-Apr-1983
!	T03-038	Add stuff for operator assistance (in comments).  29-Apr-1983
!	T03-039	Free RDBs linked to RUN_BLOCKs in CLEAN_UP.
!		Free file name string on error in WORK_OPEN.  PDG 2-May-1983
!	T03-040	Change BLOCK[.NEW[RDB_WFB],WFB_FULL] to BBLOCK.  PDG 9-May-1983
!	T03-041	Change severity of LIB$FREE_EF errors.  PDG 6-Sep-1983
!		Don't FREE_VM pieces of memory gotten from GET_VM.
!	T03-042	Apply Jack's Law to identical pieces of code in POSITION and
!		SOR$$WORK_READ.
!	T03-043	Use the CHECKPOINT facility.  PDG 19-Sep-1983
!	T03-044	SOR$$BEST_FILE_NAME assumes NAM$B_RSL and NAM$B_ESL are zero
!		before the OPEN or CREATE.  PDG 10-Nov-1983
!	T03-045	Conditionalize checkpointing code.  PDG 17-Jan-1984
!	T03-046	Make CFT_CON_ADR relative.  PDG 25-Jan-1984
!	T03-046	Correct the calculation finding the address for work file names
!		gotten from COM_CFT_ADR.  PDG 1-Feb-1984
!	T03-047	Correct version ident.
!	T03-048	Add support for VAXELN.  Jeff East 1/2/84
!	T03-049	Add recovery from RMS$_RLK errors.  PDG 2-Apr-1984
!	T03-050	Code improvements in MRG_WORK_READ.  Clear VFC area for merges.
!		Improve error reporting when NO scratch files can be found.
!		PDG 9-Apr-1984
!	T03-051	Fix minor R0 problem in MRG_WORK_READ for hostile environment.
!		PDG 15-May-1984
!	T03-052	Add WFB_ERRORS to avoid infinite loop when we run out of
!		work file space.  PDG 19-JUN-1984
!	T03-053	Change COM_RHB to COM_RHB_INP and COM_RHB_OUT.
!		This is to avoid problems with merge, where an incoming
!		record overwrites the VFC area for the outgoing record.
!		PDG 24-Jul-1984
!--

LIBRARY	'SYS$LIBRARY:STARLET';
LIBRARY	'SYS$LIBRARY:XPORT';
REQUIRE	'SRC$:COM';

%IF %DECLARED(%QUOTE $DESCRIPTOR) %THEN UNDECLARE %QUOTE $DESCRIPTOR; %FI

FORWARD ROUTINE
    SOR$$WORK_MERGE:	CAL_CTXREG NOVALUE,	! Determine which runs to merge
    SOR$$WORK_NEWRUN:	JSB_NEWRUN NOVALUE,	! Start a new LONG run
    SOR$$WORK_WRITE:	JSB_OUTPUT,		! Write to a work file
    SOR$$WORK_READ:	JSB_INPUT,		! Read from a work file
%IF FUN_K_CHECKPOINT %THEN
    SOR$$CHECKPOINT:	CAL_CTXREG NOVALUE,	! Take a checkpoint
    PSH_CHECKPOINT,				! Post-checkpoint handler
%FI
    SOR$$WRK_ALQ:	CAL_CTXREG,		! Calculate work file allocation
    GET_BUFFER:		CAL_CTXREG NOVALUE,	! Get a buffer
    FREE_BUFFER:	CAL_CTXREG NOVALUE,	! Put a buffer on the free list
    POSITION:		CAL_CTXREG NOVALUE,	! Position to start of a run
    MRG_WORK_MERGE:	CAL_CTXREG NOVALUE,	! Set up for merge
    MRG_WORK_READ:	JSB_INPUT,		! Read from a file for merge
    WORK_OPEN:		CAL_CTXREG NOVALUE,	! Open a work file
    FLUSH:		CAL_CTXREG NOVALUE,	! Flush a buffer
    GET_RDB:		CAL_CTXREG NOVALUE,	! Get a hole
    FREE_RDB:		CAL_CTXREG NOVALUE,	! Free a hole
    NEWRUN:		CAL_CTXREG NOVALUE,	! Start a new run
    DELRUN:		CAL_CTXREG,		! Indicate run no longer needed
    CLEAN_UP:		CAL_CTXREG NOVALUE;	! Release resources

SOR$$END_ROUTINE_(CLEAN_UP);			! Declare a clean-up routine

%IF HOSTILE %THEN
    MACRO
	LIB$GET_VM = SOR$LIB$GET_VM %,
	SYS$QIOW = SOR$SYS$QIOW %,
	SYS$CREATE = SOR$SYS$CREATE %,
	SYS$DASSGN = SOR$SYS$DASSGN %;
%FI

EXTERNAL ROUTINE
    SOR$$BEST_FILE_NAME:CAL_CTXREG NOVALUE,
    SOR$$FREE_FILE_NAME:CAL_CTXREG NOVALUE,
    SOR$$ALLOCATE:	CAL_CTXREG,			! Allocate storage
    SOR$$DEALLOCATE:	CAL_CTXREG NOVALUE,		! Deallocate storage
    %IF NOT HOSTILE %THEN
    LIB$GET_EF:		ADDRESSING_MODE(GENERAL),	! Get an event flag
    LIB$FREE_EF:	ADDRESSING_MODE(GENERAL),	! Free event flag
    %FI
    LIB$GET_VM:		ADDRESSING_MODE(GENERAL),
    %IF FUN_K_CHECKPOINT %THEN
    CHK$CHKPNT:		ADDRESSING_MODE(GENERAL) WEAK,
    CHK$DCLPSH:		ADDRESSING_MODE(GENERAL) WEAK,
    CHK$DCLRSH:		ADDRESSING_MODE(GENERAL) WEAK,
    CHK$CANPSH:		ADDRESSING_MODE(GENERAL) WEAK,
    CHK$CANRSH:		ADDRESSING_MODE(GENERAL) WEAK,
    %FI
    SOR$$ERROR;						! Issue diagnostics

%IF FUN_K_CHECKPOINT %THEN
EXTERNAL LITERAL
    CHK$_NOTINIT:	WEAK;
%FI

LITERAL
    FUN_K_ASSIST =	FALSE	AND NOT HOSTILE;

! This literal determines how frequently checkpoints are done.
! A count-down counter, COM_COUNTDOWN is decremented by one for:
!	each record released to / read by the sort/merge,
!	each record returned from / written by the sort/merge, and
!	each block written to / read from a scratch file.
! When the counter goes negative, a checkpoint is taken.
!
LITERAL
    TUN_K_ONE_MINUTE =	60000,		! About one minute???, standalone 780
    TUN_K_COUNTDOWN =	TUN_K_ONE_MINUTE * 10;	! Every ten minutes

MACRO
    FREE_RDB_(X, FLD) = FREE_RDB(X, %FIELDEXPAND(FLD,0)) %,
    MOVE_ALL_RDBS_(Q, FLD) = WHILE .Q NEQ 0 DO FREE_RDB_(Q, FLD) %;

!			CONTEXT AREA
!
!	The following fields in the context area are referenced only by this
!	module.
!
$FIELD
    S_FIELDS =
	SET
	$OVERLAY(COM_SCRATCH_IO)
	S_0=		[$BYTES(0)],
	S_BUF_FREE=	[XADDR],	! Pointer to free list of buffers
	S_BUF_SIZE=	[XLONG],	! Size in bytes of a buffer
	S_RUN_CURR=	[XADDR],	! Address of current run block
	S_RUN_INFO=	[XADDR],	! Address of list of run descriptions
	S_WRK_DEQ=	[XLONG],	! Default extend amount for work files
	S_WRK_EFN=	[XLONG],	! Event flag to use for work files
	S_WRK_WFB=	[XADDR],	! Address of work file WFBs
	S_BUF_ALLOC=	[XADDR],	! Pointer to list of allocated buffers
	S_PSH_HANDLER=	[XLONG],	! Handler-id for post-checkpoint handler
	S_RSH_HANDLER=	[XLONG],	! Handler-id for restart handler
	S_1=		[$BYTES(0)]
	TES;

LITERAL	TMP_K_SCRATCH = %FIELDEXPAND(S_1,0)-%FIELDEXPAND(S_0,0);
ASSERT_(TMP_K_SCRATCH LEQ COM_K_SCRATCH)
%IF TMP_K_SCRATCH LSS COM_K_SCRATCH
%THEN %MESSAGE('COM_K_SCRATCH can be reduced from ', %NUMBER(COM_K_SCRATCH),
	' to ', %NUMBER(TMP_K_SCRATCH)) %FI

STRUCTURE
	BBLOCK[O,P,S,E;BS=0] = [BS](BBLOCK+O)<P,S,E>;

!			WORK FILE DESCRIPTION BLOCK
!
!	The WFB contains information for reading/writing a work file.
!
!	The media storage for each WFB is described by non-overlapping RDBs,
!	with each media block represented in exactly one RDB.  To simplify
!	processing, a distinguished end-of-file RDB represents a near-infinite
!	amount of media blocks that would be available if the work file were
!	extended.  The RDBs that are not currently holding part of a run are
!	linked into one of three lists in the WFB.
!
!	WFB_FULL contains RDBs that are the least desirable for holding runs.
!	Usually, only the end-of-file RDB is on this list; this causes other
!	RDBs to be reused rather than increasing the work file allocation.
!
!	WFB_FREE and WFB_NOUSE contain RDBs that are available to hold runs.
!	The distinction is important when checkpointing is done.  Because the
!	information in the work files is not checkpointed, the checkpointed
!	data structures in memory must represent a valid interpretation of the
!	data stored in the work files, so that a restart from the previous
!	checkpoint will still result in a correct sort.  We may overwrite data
!	in media blocks only if the checkpointed data structures indicate that
!	there is no useful data in those blocks.
!
!	WFB_NOUSE contains RDBs that have been checkpointed as containing no
!	useful data.  WFB_FREE contains the other RDBs that contain no useful
!	data.  Thus, RDBs should be allocated from WFB_NOUSE and released to
!	WFB_FREE.  Just after a checkpoint is taken, the RDBs are moved from
!	WFB_FREE to WFB_NOUSE.
!
$UNIT_FIELD
	WFB_FIELDS =
	SET
	WFB_NEXT=	[XADDR],		! Pointer to next WFB
	WFB_NAME=	[$SUB_BLOCK(2)],	! File name length/address
	WFB_ALQ=	[XLONG],		! Allocation
	WFB_FREE=	[XADDR],		! Free RDBs for this work file
	WFB_NOUSE=	[XADDR],		! Free RDBs for this work file
	WFB_FULL=	[XADDR],		! Unusable RDBs for this WFB
	WFB_ERRORS=	[XWORD],		! Error count
	WFB_CHAN=	[XWORD]			! Channel number
!	WFB_DEV=	[XLONG]			! Device characteristics
!	WFB_DVI=	[$BYTES(1+NAM$S_DVI)]	! ASCIC Device name
	TES;
LITERAL
	WFB_K_SIZE=	$FIELD_SET_UNITS;	! Size in bytes
MACRO
	WFB_BLOCK=	%EXPAND $UNIT_BLOCK(WFB_K_SIZE) FIELD(WFB_FIELDS) %;

%MESSAGE('WFB_K_SIZE = ', %NUMBER(WFB_K_SIZE), ' bytes')

!			R U N   B L O C K
!
!
!	A run is a sequence of records that are known to be in order.
!	The merge pass merges these runs.  The information necessary to
!	position to the start of each run is stored in the following data
!	structure.
!
!	Run blocks on the S_RUN_INFO list:
!		identify the location and length of a run of records.
!
!	On output:
!		RUN_VBN   - VBN of the next block to write.
!		RUN_SIZE  - number of blocks written to the run so far.
!		RUN_BUFF0 - number of free bytes in the buffer.
!		RUN_BUFF1 - address of the first free byte in the buffer.
!
!	On input:
!		RUN_VBN   - VBN of the next block to read.
!		RUN_SIZE  - number of blocks in this run.
!		RUN_BUFF0 - bytes in the buffer that haven't been read yet.
!		RUN_BUFF1 - address of first byte that hasn't been read yet.
!
$UNIT_FIELD
	RUN_FIELDS=
	SET
	RUN_NEXT=	[XADDR],		! Pointer to next run block
	RUN_DDB=	[XADDR],		! Addr of DDB for merge stream
	RUN_VBN=	[XLONG],		! VBN of first block in run
	RUN_SIZE=	[XLONG],		! Blocks in this run
	RUN_RDB_CURR=	[XADDR],		! Current RDB
	RUN_BUFFER=	[XADDR],		! Pointer to buffer
	RUN_BUFF0=	[XLONG],		! Remaining length in buffer
	RUN_BUFF1=	[XADDR],		! Address of remainder of buffer
	RUN_COUNT=	[XLONG],		! Records in this run
	RUN_RDB=	[XADDR]			! List of RDBs in this run
	TES;
LITERAL
	RUN_K_SIZE=	$FIELD_SET_UNITS;	! Length in bytes
MACRO
	RUN_BLOCK=	%EXPAND $UNIT_BLOCK(RUN_K_SIZE) FIELD(RUN_FIELDS) %;

%MESSAGE('RUN_K_SIZE = ', %NUMBER(RUN_K_SIZE), ' bytes')

!			R U N   D E S C R I P T I O N   B L O C K
!
!
!	This block describes a chunk of mass storage that can be used to hold
!	some blocks of a run.
!
$UNIT_FIELD
	RDB_FIELDS=
	SET
	RDB_NEXT=	[XADDR],		! Pointer to next RDB block
	RDB_WFB=	[XADDR],		! Pointer to WFB for RDB
	RDB_VBN=	[XLONG],		! VBN of first block in RDB
	RDB_SIZE=	[XLONG]			! Blocks in this RDB
	TES;
LITERAL
	RDB_K_SIZE=	$FIELD_SET_UNITS;	! Length in bytes
MACRO
	RDB_BLOCK=	%EXPAND $UNIT_BLOCK(RDB_K_SIZE) FIELD(RDB_FIELDS) %;

%MESSAGE('RDB_K_SIZE = ', %NUMBER(RDB_K_SIZE), ' bytes')

$UNIT_FIELD
	BUF_FIELDS=
	SET
	BUF_NEXT=	[XADDR],		! Ptr to next free buffer
	BUF_ADDR=	[XADDR]			! Address of this block
	TES;
MACRO	BUF_BLOCK=	%EXPAND $UNIT_BLOCK(0) FIELD(BUF_FIELDS) %;

! Macroes to insert/remove items into/from a list, at the head/tail
!
MACRO	INSLH_(LIST,ITEM,NEXT) =	! Insert at head of list
	    BEGIN
	    ITEM[NEXT] = .LIST;
	    LIST = ITEM[BASE_];
	    END %;
MACRO	INSLT_(LIST,ITEM,NEXT) =	! Insert at tail of list
	    BEGIN
	    LOCAL
		PPTR: REF VECTOR[1];
	    PPTR = LIST - BBLOCK[0,NEXT];
	    WHILE .BBLOCK[PPTR[0],NEXT] NEQ 0 DO
		PPTR = .BBLOCK[PPTR[0],NEXT];
	    BBLOCK[PPTR[0],NEXT] = ITEM[BASE_];
	    END %;
MACRO	REMLH_(LIST,ITEM,NEXT,ALQ) =	! Remove from head of list
	    BEGIN
	    %IF %NULL(ALQ)
	    %THEN
		IF (ITEM = .LIST) NEQ 0
		    THEN (LIST = .ITEM[NEXT]; ITEM[NEXT] = 0; TRUE)
		    ELSE (FALSE)
	    %ELSE
		SOR$$DEALLOCATE(ALQ, LIST, .ITEM[NEXT]);
	    %FI
	    END %;

ROUTINE GET_BUFFER
	(
	RUNBLOCK:	REF RUN_BLOCK		! Addr of run description block
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets a buffer for the run.
!	It first attempts to get a buffer from the free list of buffers.
!	If this fails, it allocates more memory for the buffer.
!
! FORMAL PARAMETERS:
!
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK;		! Addr of run description block


    ! See whether we already have a buffer
    !
    RUN = RUNBLOCK[BASE_];
    IF .RUN[RUN_BUFFER] EQL 0
    THEN
	BEGIN
	LOCAL
	    BUFPTR:	REF BUF_BLOCK;	! Pointer to buffer

	! Remove the buffer from the beginning of the list.
	! If nothing in the list, create a new buffer.
	! Store the address of the buffer
	!
	IF NOT REMLH_(CTX[S_BUF_FREE], BUFPTR, BUF_NEXT)
	THEN
	    BEGIN
	    !
	    ! We want the storage to be aligned on a page boundary.
	    ! Get an extra page, to guarantee sufficient page-aligned pages.
	    ! Instead of deallocating the unused portions, they are used to
	    ! maintain a linked list of the allocated blocks, using fields
	    ! BUF_NEXT and BUF_ADDR.  The field BUF_NEXT is also used in the
	    ! page-aligned portion when it is put on the free list.
	    !
	    LOCAL
		DEL,
		P:	REF BUF_BLOCK,
		STATUS;
	    STATUS = LIB$GET_VM(%REF(.CTX[S_BUF_SIZE]+COM_K_BPERPAGE),BUFPTR);
	    IF NOT .STATUS
	    THEN
		RETURN SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS);

	    ! Determine how much free space is at the beginning.
	    !
	    DEL = (-.BUFPTR AND (COM_K_BPERPAGE-1));

	    ! Put the memory on the S_BUF_ALLOC list
	    !
	    P = BUFPTR[BASE_];
	    IF .DEL LSS 2*%UPVAL	! Enough room for BUF_NEXT and BUF_ADDR?
	    THEN
		P = P[BASE_] + .CTX[S_BUF_SIZE] + 2*%UPVAL;
	    P[BUF_ADDR] = BUFPTR[BASE_];
	    INSLH_(CTX[S_BUF_ALLOC], P, BUF_NEXT);

	    ! Adjust BUFPTR to be page aligned
	    !
	    BUFPTR = .BUFPTR + .DEL;
	    END;

	RUN[RUN_BUFFER] = BUFPTR[BASE_];
	END;

    RUN[RUN_BUFF0] = .CTX[S_BUF_SIZE];
    RUN[RUN_BUFF1] = .RUN[RUN_BUFFER];

    END;

ROUTINE FREE_BUFFER
	(
	RUNBLOCK:	REF RUN_BLOCK		! Addr of run description block
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine puts a buffer on the free list.
!	It also frees the unused portion of RDB connected to the RUN block.
!
! FORMAL PARAMETERS:
!
!	RUNBLOCK	Address of run description block
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	BUFPTR:	REF BUF_BLOCK,
	RUN:	REF RUN_BLOCK;

    RUN = RUNBLOCK[BASE_];
    BUFPTR = .RUN[RUN_BUFFER];
    RUN[RUN_BUFFER] = 0;	! Not necessary, but by doing this ...
    RUN[RUN_BUFF0] = 0;		! ... an error elsewhere ...
    RUN[RUN_BUFF1] = 0;		! ... should cause an access violation

    ! Insert the buffer on the list (at the head)
    !
    INSLH_(CTX[S_BUF_FREE], BUFPTR, BUF_NEXT);

    ! Update the run's current RDB.
    ! Put the unused space at the end of the RDB on the WFB_NOUSE list.
    !
    BEGIN
    LOCAL
	RDB:	REF RDB_BLOCK;
    RDB = .RUN[RUN_RDB_CURR];
    IF RDB[BASE_] NEQ 0 THEN
    IF .RUN[RUN_VBN] - .RDB[RDB_VBN] LSSU .RDB[RDB_SIZE]
    THEN
	BEGIN
	LOCAL
	    NEW:	REF RDB_BLOCK;
	NEW = SOR$$ALLOCATE(RDB_K_SIZE);
	NEW[RDB_WFB]  = .RDB[RDB_WFB];
	NEW[RDB_SIZE] = .RDB[RDB_SIZE];
	NEW[RDB_VBN]  = .RDB[RDB_VBN];
	RDB[RDB_SIZE] = .RUN[RUN_VBN]  - .RDB[RDB_VBN];
	NEW[RDB_SIZE] = .NEW[RDB_SIZE] - .RDB[RDB_SIZE];
	NEW[RDB_VBN]  = .RDB[RDB_VBN]  + .RDB[RDB_SIZE];
	FREE_RDB_(%REF(NEW[BASE_]), WFB_NOUSE);
	END;
    END;

    END;

%IF %SWITCHES(DEBUG) %THEN
GLOBAL ROUTINE DUMP_RDBS(PARAM): CAL_CTXREG =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    EXTERNAL ROUTINE
	SOR$$OUTPUT;
    MACRO
	DESC_(A) = UPLIT(%CHARCOUNT(A), UPLIT BYTE(A)) %;
    LOCAL
	P:	REF RDB_BLOCK;
    P = .PARAM;
    WHILE .P NEQ 0 DO
	BEGIN
	SOR$$OUTPUT(DESC_(%STRING(
	    '!_!XL:  NEXT!_!XL    WFB!_!XL    VBN!_!XL   SIZE!_!XL')),
	    P[BASE_],
	    .P[RDB_NEXT],
	    .P[RDB_WFB],
	    .P[RDB_VBN],
	    .P[RDB_SIZE]);
	P = .P[RDB_NEXT];
	END;
    RETURN 0;
    END;

GLOBAL ROUTINE DUMP_RUNS: CAL_CTXREG =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    EXTERNAL ROUTINE
	SOR$$OUTPUT;
    MACRO
	DESC_(A) = UPLIT(%CHARCOUNT(A), UPLIT BYTE(A)) %;
    LOCAL
	Q:	REF WFB_BLOCK,
	P:	REF RUN_BLOCK;
    SOR$$OUTPUT(DESC_('DUMP_RUNS'));
    P = .CTX[S_RUN_INFO];
    WHILE .P NEQ 0 DO
	BEGIN
	SOR$$OUTPUT(DESC_(%STRING(
	    '!XL:  NEXT!_!XL    DDB!_!XL    VBN!_!XL   SIZE!_!XL!/',
	    '!_ BUFFER!_!XL  BUFF0!_!XL  BUFF1!_!XL  COUNT!_!XL!/',
	    '!_ RDB_CURR!_!XL!/')), P[BASE_],
	    .P[RUN_NEXT], .P[RUN_DDB], .P[RUN_VBN], .P[RUN_SIZE],
	    .P[RUN_BUFFER], .P[RUN_BUFF0], .P[RUN_BUFF1], .P[RUN_COUNT],
	    .P[RUN_RDB_CURR]);
	DUMP_RDBS(.P[RUN_RDB]);
	P = .P[RUN_NEXT];
	END;
    SOR$$OUTPUT(DESC_('DUMP_WFBS'));
    Q = .CTX[S_WRK_WFB];
    WHILE .Q NEQ 0 DO
	BEGIN
	SOR$$OUTPUT(DESC_(%STRING(
	    '!XL:   ALQ!_!XL   FREE!_!XL   FULL!_!XL   CHAN!_!XW',
	    '!/!_  NOUSE!_!XL')),
	    Q[BASE_],
	    .Q[WFB_ALQ],
	    .Q[WFB_FREE],
	    .Q[WFB_FULL],
	    .Q[WFB_CHAN],
	    .Q[WFB_NOUSE]);
	DUMP_RDBS(.Q[WFB_FREE]);
	DUMP_RDBS(.Q[WFB_FULL]);
	DUMP_RUNS(.Q[WFB_NOUSE]);
	Q = .Q[WFB_NEXT];
	END;
    RETURN 0;
    END;
%FI

ROUTINE MRG_WORK_MERGE
	(
	CNT,					! Number of runs to find
	LIST:		REF VECTOR		! Counted list of runs to merge
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets up the run information for a merge process.
!
!	It creates run description blocks for the runs, and allocates buffer
!	space for each run.
!
! FORMAL PARAMETERS:
!
!	CNT		Number of runs to find
!	LIST		Counted list of runs to merge (output parameter)
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
!	The output run is automatically handled by the SOR$$WORK_xxx routines.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	LST:	REF VECTOR,
	DDB:	REF DDB_BLOCK,
	RUN:	REF RUN_BLOCK;		! Ptr to run block

    ! Zero the count of runs to merge, and the output run.
    !
    LST = LIST[0];


    ! Calculate the buffer size that will be needed.
    ! If the record interface is being used on input, this size must include
    ! both the actual record, and the internal format record.
    !
    CTX[S_BUF_SIZE] = .CTX[COM_LRL_INT];
    DDB = .CTX[COM_INP_DDB];
    IF DDB[BASE_] EQL 0
    THEN
	CTX[S_BUF_SIZE] = .CTX[S_BUF_SIZE] + .CTX[COM_LRL];
    CTX[S_BUF_SIZE] = ROUND_(.CTX[S_BUF_SIZE], COM_K_BPERPAGE);


    ! Set up the run description blocks
    !
    LST[0] = .CNT;
    INCR I FROM 1 TO .LST[0] DO
	BEGIN
	!
	! Allocate another run description block, and link to the list
	!
	RUN = SOR$$ALLOCATE(RUN_K_SIZE);	! Allocate a new run block
	INSLH_(CTX[S_RUN_INFO], RUN, RUN_NEXT);	! Link this run block into list
	!
	! Make the run description block reference the DDB
	!	(or the stream number for user-written input routines)
	! Put a pointer to the run description block into the list
	! Allocate a buffer for the internal-format records
	!	(only .CTX[COM_LRL_INT] bytes needed for the buffer)
	!
	IF .CTX[COM_INP_DDB] EQL 0
	THEN
	    BEGIN
	    RUN[RUN_DDB] = .I;			! Input stream number
	    END
	ELSE
	    BEGIN
	    RUN[RUN_DDB] = DDB[BASE_];		! Reference the DDB
	    DDB = .DDB[DDB_NEXT];		! Advance to next DDB
	    END;
	LST[.I] = RUN[BASE_];			! Put into the list
	GET_BUFFER(RUN[BASE_]);			! Get a buffer for this run
	IF DDB[BASE_] EQL 0
	THEN
	    BEGIN
	    !
	    ! RUN_BUFFER is the address of the internal format record
	    ! RUN_BUFF0/1 is the descriptor for the actual record
	    !
	    ! Note that RUN_BUFF0 is set to the specified LRL value, rather
	    ! than the actual amount of space available.  This means that the
	    ! buffer passed to the user-written input routine is exactly the
	    ! size specified by the LRL.  Also, this does not affect
	    ! deallocating the buffer.
	    !
	    RUN[RUN_BUFF0] = .CTX[COM_LRL];
	    RUN[RUN_BUFF1] = .RUN[RUN_BUFF1] + .CTX[COM_LRL_INT];
	    END;
	END;

    ! The output should be counted as another run.
    !
    CTX[COM_RUNS] = .CTX[COM_RUNS] + 1;		! One more run batted in

    END;

GLOBAL ROUTINE SOR$$WORK_MERGE			! Determine runs to merge
	(
	CNT,					! Number of runs to find
	LIST:		REF VECTOR		! Counted list of runs to merge
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine decides which runs to merge.
!
! FORMAL PARAMETERS:
!
!	CNT		Number of runs to find
!	LIST		Counted list of runs to merge (output parameter)
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
!	The output run is automatically handled by the SOR$$WORK_xxx routines.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	LST:	REF VECTOR,
	RUN:	REF RUN_BLOCK;		! Ptr to run block
    MACRO
	SIZE_(A) = (BIND X = .LST[A]: RUN_BLOCK; .X[RUN_SIZE]) %,
	SWAP_(X,Y) = (LOCAL Z; Z=.X; X=.Y; Y=.Z) %;


    ! If we were invoked for a merge process, call a different routine
    ! to set up the run information.
    !
    IF .CTX[COM_MERGE]
    THEN
	BEGIN
	BUILTIN
	    AP,
	    CALLG;
	CALLG(.AP, MRG_WORK_MERGE);
	RETURN;
	END;


    ! If there is anything left to be written in the last run,
    ! write it out, and free the buffer.
    !
    RUN = .CTX[S_RUN_CURR];
    FLUSH(RUN[BASE_]);
    FREE_BUFFER(RUN[BASE_]);


    ! Zero the count of runs to merge, and the output run.
    !
    LST = LIST[0];
    LST[0] = 0;


    ! Start looking at active runs.
    !
    RUN = .CTX[S_RUN_INFO];


    ! Put the first active runs into the list of runs to be merged,
    ! while maintaining LST[1] as the the largest run in the list.
    !
    DECR I FROM .CNT-1 TO 0 DO
	BEGIN
	IF RUN[BASE_] EQL 0 THEN EXITLOOP;
	LST[0] = .LST[0] + 1;
	LST[.LST[0]] = RUN[BASE_];
	IF .RUN[RUN_SIZE] GTR SIZE_(1) THEN SWAP_(LST[.LST[0]], LST[1]);
	RUN = .RUN[RUN_NEXT];
	END;


    ! Look through the rest of the active runs, trying to find shorter runs.
    ! Since LST[1] is the largest run in the list, we compare with it first.
    !
    WHILE RUN[BASE_] NEQ 0 DO				! While more active runs
	BEGIN
	IF .RUN[RUN_SIZE] LEQ SIZE_(1)
	THEN
	    BEGIN
	    LST[1] = RUN[BASE_];		! Replace largest with this one
	    !
	    ! Put the next largest run into LST[1]
	    !
	    DECR I FROM .CNT TO 2 DO
		IF SIZE_(.I) GTR SIZE_(1) THEN SWAP_(LST[.I], LST[1]);
	    END;
	RUN = .RUN[RUN_NEXT];
	END;		


    ! Position to each of the runs, and start reading them.
    !
    DECR I FROM .LST[0] TO 1 DO POSITION(.LST[.I]);


    ! Start a new run, after making sure we really need it
    !
    IF .LST[0] NEQ 0 THEN NEWRUN();


    %IF %SWITCHES(DEBUG)
    %THEN
	BEGIN
	EXTERNAL ROUTINE SOR$$OUTPUT;
	MACRO
	    DESC_(A) = UPLIT(%CHARCOUNT(A), UPLIT BYTE(A)) %;
	DUMP_RUNS();
	SOR$$OUTPUT(DESC_('WORK_MERGE'));
	INCR I FROM 1 TO .LIST[0] DO
	    SOR$$OUTPUT(DESC_('!_Run !XL'), .LIST[.I]);
	SOR$$OUTPUT(DESC_('!_--> !XL'), .CTX[S_RUN_CURR]);
	END;
    %FI


    END;

ROUTINE FULL_RDB(STATUS):	CAL_CTXREG NOVALUE =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK,
	NEW:	REF RDB_BLOCK,
	WFB:	REF WFB_BLOCK,
	RDB:	REF RDB_BLOCK;
    RUN = .CTX[S_RUN_CURR];
    RDB = .RUN[RUN_RDB_CURR];
    WFB = .RDB[RDB_WFB];
    SOR$$ERROR(SOR$_SHR_WRITEERR, 1, WFB[WFB_NAME], .STATUS);
    IF .WFB[WFB_FULL] EQL 0 THEN WFB[WFB_ERRORS] = .WFB[WFB_ERRORS] + 1;
    NEW = SOR$$ALLOCATE(RDB_K_SIZE);
    NEW[RDB_WFB]  = .RDB[RDB_WFB];
    NEW[RDB_SIZE] = .RDB[RDB_SIZE];
    NEW[RDB_VBN]  = .RDB[RDB_VBN];
    RDB[RDB_SIZE] = .RUN[RUN_VBN]  - .RDB[RDB_VBN];
    NEW[RDB_SIZE] = .NEW[RDB_SIZE] - .RDB[RDB_SIZE];
    NEW[RDB_VBN]  = .RDB[RDB_VBN]  + .RDB[RDB_SIZE];
    INSLH_(WFB[WFB_FULL], NEW, RDB_NEXT);

    ! The first time we get errors on this file, it may be due to
    ! a failure to extend the work file.
    ! The second time may be due to a few bad RDBs, but hopefully the
    ! end-of-file RDB is okay (the user may have EXQUOTA privilege).
    ! The third time, it's clear that the end-of-file RDB is also bad.
    !
    ! If the file is that bad, throw the RDBs away.
    !
    IF .WFB[WFB_ERRORS] GEQ 3
    THEN
	REMLH_(WFB[WFB_FULL], NEW, RDB_NEXT, RDB_K_SIZE);

    END;

ROUTINE FILE_EXTEND
	(
	WFB:	REF WFB_BLOCK,			! Work file to extend
	EXSZ					! Extension quantity
	):	CAL_CTXREG NOVALUE =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	FIB:	BLOCK[FIB$K_EXTDATA, BYTE],	! File ident block
	FIBD:	VECTOR[2],			! File ident block descriptor
	IOSB:	VECTOR[2],			! Virtual addresses
	STATUS;

    ! Set up the file identification block and its descriptor. Then issue
    ! the QIOs which do the extend and write attributes to update the end of
    ! file block.
    !
    CH$FILL (0, FIB$K_EXTDATA, FIB[BASE_]);
    FIB[FIB$W_EXCTL] = FIB$M_EXTEND OR FIB$M_ALCONB OR FIB$M_ALDEF;
    FIB[FIB$L_EXSZ] = MAXU(.EXSZ, .CTX[S_WRK_DEQ]);

    FIBD[0] = FIB$K_EXTDATA;
    FIBD[1] = FIB;

    STATUS = $QIOW(
	EFN=	.CTX[S_WRK_EFN],
	CHAN=	.WFB[WFB_CHAN],
	FUNC=	IO$_MODIFY,
	P1=	FIBD,
	IOSB=	IOSB
	%IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
    IF .STATUS THEN STATUS = .IOSB[0];

    IF NOT .STATUS
    THEN
	BEGIN
	!
	! Complain and put remainder of the current RDB on FULL list
	!
	FULL_RDB(.STATUS);
	END
    ELSE
	BEGIN
	!
	! Update the current allocation for this file
	!
	WFB[WFB_ERRORS] = 0;
	WFB[WFB_ALQ] = .FIB[FIB$L_EXSZ] + .FIB[FIB$L_EXVBN];
	END;
    END;

ROUTINE FLUSH					! Flush the buffer for a run
	(
	RUNBLOCK:	REF RUN_BLOCK
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine flushes a buffer.
!	Important note: This routine does not update RUN_BUFF1 or RUN_BUFF0.
!
! FORMAL PARAMETERS:
!
!	RUNBLOCK	Address of the run description block.
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN: REF RUN_BLOCK;
    LOCAL
	P:	VECTOR[2];

    RUN = RUNBLOCK[BASE_];

    ! Store the number of bytes to write, and the address of the storage
    !
    P[0] = ROUND_(.RUN[RUN_BUFF1]-.RUN[RUN_BUFFER], COM_K_BPERPAGE);
    P[1] = .RUN[RUN_BUFFER];

    ! Write out the buffer.
    !
    WHILE .P[0] GTR 0 DO
	BEGIN
	LOCAL
	    RDB:	REF RDB_BLOCK,
	    WFB:	REF WFB_BLOCK,
	    SIZE;			! Number of blocks to write

	! Compute the number of block we will write
	!
	RDB = .RUN[RUN_RDB_CURR];
	WFB = .RDB[RDB_WFB];
	SIZE = MINU(
	    .P[0] ^ -LN2_(COM_K_BPERPAGE),
	    .RDB[RDB_VBN] + .RDB[RDB_SIZE] - .RUN[RUN_VBN],
	    127);
	IF
	    .SIZE EQL 0		! Was this RDB full?
	THEN
	    GET_RDB()		! Get another RDB to use
	ELIF
	    .RUN[RUN_VBN] + .SIZE GTRU .WFB[WFB_ALQ]
	THEN
	    BEGIN
	    !
	    ! Extend the file
	    !
	    FILE_EXTEND(WFB[BASE_],
		.RUN[RUN_VBN] + .SIZE - .WFB[WFB_ALQ]);
	    END
	ELSE
	    BEGIN
	    LOCAL
		IOSB:	VECTOR[4,WORD],
	    	STATUS;
	    !
	    ! Actually write some stuff
	    !
	    STATUS = $QIOW(
		EFN=	.CTX[S_WRK_EFN],
		CHAN=	.WFB[WFB_CHAN],
		FUNC=	IO$_WRITEVBLK,
		IOSB=	IOSB,
		ASTADR=	0,
		ASTPRM=	0,
		P1=	.P[1],
		P2=	.SIZE ^ LN2_(COM_K_BPERPAGE),
		P3=	.RUN[RUN_VBN]
		%IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
	    IF .STATUS THEN STATUS = .IOSB[0];

	    IF NOT .STATUS
	    THEN
		BEGIN
		!
		! Complain and put remainder of the current RDB on FULL list
		!
		FULL_RDB(.STATUS);
		END
	    ELSE
		BEGIN
		!
		! Update the next virtual block number to write.
		! Update the number of blocks in this run.
		! Update blocks read/written since last checkpoint.
		! Update the size/address of the buffer to write.
		!
		WFB[WFB_ERRORS] = 0;
		RUN[RUN_VBN]  = .RUN[RUN_VBN]  + .SIZE;
		RUN[RUN_SIZE] = .RUN[RUN_SIZE] + .SIZE;
%IF FUN_K_CHECKPOINT
%THEN
		CTX[COM_COUNTDOWN] = .CTX[COM_COUNTDOWN] - .SIZE;
%FI
		P[0] = .P[0] - .SIZE ^ LN2_(COM_K_BPERPAGE);
		P[1] = .P[1] + .SIZE ^ LN2_(COM_K_BPERPAGE);
		END;
	    END;
	END;

%IF FUN_K_CHECKPOINT
%THEN
    IF .CTX[COM_COUNTDOWN] LSS 0
    THEN
	SOR$$CHECKPOINT();
%FI

    END;

%IF FUN_K_CHECKPOINT
%THEN
REQUIRE 'SRC$:CHKPNT';
%FI

GLOBAL ROUTINE SOR$$WORK_NEWRUN			! Start a new run
	: JSB_NEWRUN NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine starts a new run.
!
! FORMAL PARAMETERS:
!
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK,
	STATUS;

    ! See whether there is a current run being processed.
    !
    RUN = .CTX[S_RUN_CURR];
    IF .RUN EQL 0				! Any current run?
    THEN
	BEGIN
	!
	! No runs yet.  Open scratch files.
	!
	IF .CTX[COM_WRK_FILES] EQL 0
	THEN
	    BEGIN
	    SOR$$ERROR(SOR$_NO_WRK);			! We can recover
	    CTX[COM_WRK_FILES] = DEF_WORK_FILES;	! Use some work files
	    END;
	WORK_OPEN();					! Open the work files

%IF FUN_K_CHECKPOINT
%THEN
	! Declare a post-checkpoint handler
	!
	IF CHK$DCLPSH NEQ 0 AND NOT .CTX[COM_NOCHKPNT]
	THEN
	    BEGIN
	    STATUS = CHK$DCLPSH(PSH_CHECKPOINT, CTX[BASE_], CTX[S_PSH_HANDLER]);
	    IF .STATUS THEN
	    STATUS = CHK$DCLRSH(PSH_CHECKPOINT, CTX[BASE_], CTX[S_RSH_HANDLER]);
	    IF NOT .STATUS
	    THEN
		BEGIN
		SOR$$ERROR(SOR$_SHR_SYSERROR AND NOT STS$M_SEVERITY OR STS$K_ERROR,
		    0, .STATUS);
		CTX[COM_NOCHKPNT] = TRUE;
		END;
	    END;
%FI
	END
    ELSE
	BEGIN
	!
	! There is an outstanding run.  Flush it to the output file,
	! so we can start the new run on a block boundary.
	!
	FLUSH(RUN[BASE_]);
	FREE_BUFFER(RUN[BASE_]);
	END;


    ! Start a new run
    !
    NEWRUN();


    ! From now on, use SOR$$WORK_WRITE to output records
    !
    CTX[COM_OUTPUT] = SOR$$WORK_WRITE;


    RETURN SS$_NORMAL;
    END;

ROUTINE GET_RDB: CAL_CTXREG NOVALUE =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK,
	RDB:	REF RDB_BLOCK,
	PREV:	REF VECTOR[1],		! Ptr to previous
	TRIES:	INITIAL(0);
    LITERAL
	K_TRIES = 3;
    LABEL
	AGAIN;

    ! Find a hole that we can use.
    !
    WHILE TRUE DO
AGAIN:	BEGIN
	LOCAL
	    MAX_SIZE:	INITIAL(%X'80000000'),	! Smallest signed longword
	    WFB:	REF WFB_BLOCK;
	LOCAL
	    ANY_FREE:	INITIAL(0);
	MACRO
	    TRY_AGAIN = LEAVE AGAIN %;

	! Find the largest hole.
	!
	PREV = 0;
	WFB = CTX[S_WRK_WFB] - BBLOCK[0,WFB_NEXT];
	WHILE (WFB = .WFB[WFB_NEXT]) NEQ 0 DO		! For all work files
	    BEGIN
	    LOCAL
		CURR_PREV: REF VECTOR[1];
	    ANY_FREE = .ANY_FREE OR .WFB[WFB_FREE];
	    CURR_PREV = WFB[WFB_NOUSE];
	    WHILE (RDB = .CURR_PREV[0]) NEQ 0 DO	! For RDBs in WFB_NOUSE 
		BEGIN
		IF .MAX_SIZE LSS .RDB[RDB_SIZE]
		THEN
		    BEGIN
		    MAX_SIZE = .RDB[RDB_SIZE];
		    PREV = CURR_PREV[0];
		    END;
		CURR_PREV = RDB[RDB_NEXT];
		END;
	    END;


	! Did we find something?
	!
	IF .MAX_SIZE GTR 0 THEN EXITLOOP;	! Exit if no extend needed
%IF FUN_K_CHECKPOINT
%THEN
	IF NOT .CTX[COM_NOCHKPNT] AND .ANY_FREE NEQ 0
	THEN
	    BEGIN
	    !
	    ! Request a checkpoint.  This will cause the RDBs to move
	    ! from the WFB_FREE list to the WFB_NOUSE list.
	    !
	    SOR$$CHECKPOINT();
	    TRY_AGAIN;
	    END;
%FI
	IF PREV[0] NEQ 0 THEN EXITLOOP;		! Extend as needed


%IF FUN_K_ASSIST
%THEN
	! Request operator intervention
	!
	BEGIN
	EXTERNAL ROUTINE
	    UTIL$ASSIST:	ADDRESSING_MODE(GENERAL);
	GLOBAL LITERAL
	    UTIL$_OPERFAIL = SOR$_OPERFAIL,
	    UTIL$_OPREPLY  = SOR$_OPREPLY;
	LOCAL
	    REPLY_DESC: VECTOR[2],
	    REPLY_BUFF: VECTOR[255,BYTE],
	    STATUS;
	REPLY_DESC[0] = %ALLOCATION(REPLY_BUFF);
	REPLY_DESC[1] = REPLY_BUFF;
	STATUS = UTIL$ASSIST(REPLY_DESC[0],	! Response
	    UPLIT(1,				! Signal message
		SOR$_EXTEND AND NOT STS$M_SEVERITY OR STS$K_ERROR),
	    5*60,				! Timeout period (in seconds)
	    UPLIT(1,SOR$_REQ_ALT));		! Prompt message
	IF .STATUS
	THEN
	    BEGIN
	    TRIES = 0;
	    IF .REPLY_DESC[0] NEQ 0 THEN WORK_OPEN(REPLY_DESC[0]);
	    END;
	END;
%FI
	! Try RDBs that had gotten errors.
	! Move the RDB's from WFB_FULL to WFB_FREE
	!
	WFB = CTX[S_WRK_WFB] - BBLOCK[0,WFB_NEXT];
	WHILE (WFB = .WFB[WFB_NEXT]) NEQ 0 DO
	    MOVE_ALL_RDBS_( WFB[WFB_FULL], WFB_FREE );

	! Check how many times we've tried to get more space
	!
	IF (TRIES = .TRIES + 1) LSS K_TRIES THEN TRY_AGAIN;

	! At this point, just give up
	!
	SOR$$FATAL(SOR$_EXTEND);
	END;

    ! Remove the RDB from the free list
    !
    REMLH_(PREV[0], RDB, RDB_NEXT);

    ! Link the RDB at the end of RDB blocks for the current run.
    !
    RUN = .CTX[S_RUN_CURR];
    INSLT_(RUN[RUN_RDB], RDB, RDB_NEXT);	! Insert at end of list

    ! Copy relevant information into the RUN block
    !
    RUN[RUN_RDB_CURR] = RDB[BASE_];
    RUN[RUN_VBN]  = .RDB[RDB_VBN];

    END;

ROUTINE FREE_RDB(
	Q:	REF VECTOR[1],
	OFFSET				! %FIELDEXPAND(WFB_FREE/NOUSE, 0)
	): CAL_CTXREG NOVALUE =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	P:	REF RDB_BLOCK,
	R:	REF RDB_BLOCK,
	LOFF;

    ! Get a pointer to the RDB being freed
    !
    P = .Q[0];

    ! If we aren't checkpointing, free directly to the WFB_NOUSE list
    !
%IF FUN_K_CHECKPOINT
%THEN
    LOFF = .OFFSET;
    IF .CTX[COM_NOCHKPNT]
    THEN
%FI
	LOFF = %FIELDEXPAND(WFB_NOUSE,0);

    ! Hook the RDB onto the WFB's free list
    !
    R = BBLOCK[.P[RDB_WFB],.LOFF,0,%BPVAL,0] - BBLOCK[0,RDB_NEXT];
    WHILE (R = .R[RDB_NEXT]) NEQ 0 DO
	BEGIN
	IF .P[RDB_VBN] + .P[RDB_SIZE] EQL .R[RDB_VBN]
	OR .R[RDB_VBN] + .R[RDB_SIZE] EQL .P[RDB_VBN]
	THEN
	    EXITLOOP;
	END;

    IF R[BASE_] EQL 0
    THEN
	BEGIN
	!
	! Cannot coalesce the holes
	! Remove from the current list, and add to the free list
	!
	REMLH_(Q[0], P, RDB_NEXT);
	INSLH_(BBLOCK[.P[RDB_WFB],.LOFF,0,%BPVAL,0], P, RDB_NEXT);
	END
    ELSE
	BEGIN
	!
	! Coalesce the holes, remove from current list, and deallocate.
	!
	R[RDB_VBN] = MINU(.R[RDB_VBN], .P[RDB_VBN]);
	R[RDB_SIZE] = .P[RDB_SIZE] + .R[RDB_SIZE];
	REMLH_(Q[0], P, RDB_NEXT, RDB_K_SIZE);
	END;

    END;

ROUTINE NEWRUN: CAL_CTXREG NOVALUE =		! Start a new run

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine starts a new run.
!
! FORMAL PARAMETERS:
!
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK;		! Ptr to run block


    ! Bump the number of runs
    !
    CTX[COM_RUNS] = .CTX[COM_RUNS] + 1;		! One more run batted in

    ! Create a run desription block for this new run.
    ! Link the new run description block into the list.
    ! Find a large hole to hold the merged run
    !
    RUN = SOR$$ALLOCATE(RUN_K_SIZE);
    INSLH_(CTX[S_RUN_INFO], RUN, RUN_NEXT);
    CTX[S_RUN_CURR] = RUN[BASE_];		! This is the current run
    RUN[RUN_SIZE] = 0;				! Nothing written here yet
    GET_RDB();

    ! Get a buffer for this run
    !
    GET_BUFFER(RUN[BASE_]);

    END;

GLOBAL ROUTINE SOR$$WORK_WRITE		! Write to a work file
	(
	SRC_ADDR:	REF BLOCK	! Address of internal format record
	):	JSB_OUTPUT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes to a work file.
!
! FORMAL PARAMETERS:
!
!	SRC_ADDR.ral.v	Address of internal format record
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The address of where the record was written.
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK,	! Current run block
	LEN,			! Length of record to write
	STATUS;			! Status

    RUN = .CTX[S_RUN_CURR];

    RUN[RUN_COUNT] = .RUN[RUN_COUNT] + 1;	! One more record in this run


    ! Set the length and address of the record to be written.
    !
    LEN = .CTX[COM_LRL_INT];
    IF (RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] - .LEN) GEQ 0
    THEN
	BEGIN
	LOCAL
	    TMP1;
	CH$MOVE(.LEN, SRC_ADDR[BASE_], .RUN[RUN_BUFF1]);
	TMP1 = .RUN[RUN_BUFF1];
	RUN[RUN_BUFF1] = .RUN[RUN_BUFF1] + .LEN;
	RETURN .TMP1;		! Return address of the output record
	END
    ELSE
	RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] + .LEN;	! Reset


    ! There isn't enough room in the buffer for this record
    !
    BEGIN
    LOCAL
	TMP1,		! U div BPERPAGE * BPERPAGE
	TMP2,		! U mod BPERPAGE
	BEND;		! BUFF0 + BUFF1

    !+
    ! We want to return the address of the record, so we must have the entire
    ! record available in the buffer.
    !
    ! In the equations below,
    !	U = BUFF1-BUFFER
    ! Write out the first part of the buffer
    !	LEN:	ROUND_(U-BPERPAGE, BPERPAGE)
    !	ADR:	BUFFER
    ! Move the remaining bytes to the beginning of the buffer
    !	SRCLEN:	U     -ROUND_(U-BPERPAGE, BPERPAGE)
    !	SRCADR:	BUFFER+ROUND_(U-BPERPAGE, BPERPAGE)
    !	DSTLEN:	U     -ROUND_(U-BPERPAGE, BPERPAGE)
    !	DSTADR:	BUFFER
    ! Move the new record into the buffer
    !	DSTADR:	BUFFER+U-ROUND_(U-BPERPAGE, BPERPAGE)
    !-

    ! Compute ROUND_(U-BPERPAGE, BPERPAGE) and
    !	U - ROUND_(U-BPERPAGE, BPERPAGE)
    !
    TMP1 = .RUN[RUN_BUFF1] - .RUN[RUN_BUFFER];	! This is momentarily U
    TMP2 = .TMP1 AND     (COM_K_BPERPAGE-1);
    TMP1 = .TMP1 AND NOT (COM_K_BPERPAGE-1);
    BEND = .RUN[RUN_BUFF0] + .RUN[RUN_BUFF1];

    ! Adjust BUFF0/BUFF1 to indicate a full buffer, and write it out
    !
    RUN[RUN_BUFF1] = .RUN[RUN_BUFFER] + .TMP1;
    RUN[RUN_BUFF0] = 0;
    FLUSH(RUN[BASE_]);

    ! Move the remaining bytes to the beginning of the buffer
    !
    CH$MOVE(.TMP2, .RUN[RUN_BUFFER] + .TMP1, .RUN[RUN_BUFFER]);
    RUN[RUN_BUFF1] = .RUN[RUN_BUFFER] + .TMP2;
    RUN[RUN_BUFF0] = .BEND - .RUN[RUN_BUFF1];

    ! Move the new record into the buffer
    !
    CH$MOVE(.LEN, SRC_ADDR[BASE_], .RUN[RUN_BUFF1]);
    TMP1 = .RUN[RUN_BUFF1];
    RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] - .LEN;
    RUN[RUN_BUFF1] = .RUN[RUN_BUFF1] + .LEN;
    RETURN .TMP1;
    END;

    END;

ROUTINE MRG_WORK_READ			! Read a record for merge
	(
	RUNBLOCK:	REF RUN_BLOCK	! Address of run description block
	):	JSB_INPUT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a record for a merge, either by
!	using RMS to get the record, or
!	calling the user-written input routine.
!
! FORMAL PARAMETERS:
!
!	RUNBLOCK	Address of run description block
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Address of record, or zero if end-of-run (end-of-file)
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    BUILTIN
	R0;
    MACRO
	RETURN_ = RETURN R0 = %;
    MACRO
	CH$FILL_(FILL,DN,DPTR) =
	    BEGIN
	    BUILTIN MOVC5;
	    MOVC5(%REF(0), .R0, %REF(FILL), %REF(DN), DPTR; R0);
	    END %;

    ! Read one record from the file
    !
    WHILE TRUE DO
	BEGIN
	LOCAL
	    D:	VECTOR[2];		! Descriptor

	! Grab a pointer to the DDB (if this is a merge with a user-written input
	! routine, this is really the number of the stream for him to read).
	!
	! Note that this assignment is inside the loop, because there aren't
	! any registers that we can use (for DDB) that last across the call
	! to the input routine.
	!
	REGISTER
	    DDB:	REF DDB_BLOCK;		! Pointer to DDB
	DDB = .RUNBLOCK[RUN_DDB];


	! Clear this, since the user-input routine only stores a word.
	!
	D[0] = 0;

	IF .CTX[COM_MRG_INPUT] NEQ 0
	THEN
	    BEGIN

	    ! If there is a user-written input routine, call it.
	    !
	    IF .CTX[COM_HACK_2ARGS]
	    THEN
		R0 = (.CTX[COM_MRG_INPUT])
		    (RUNBLOCK[RUN_BUFF0], %REF(.DDB), D[0])
	    ELSE
		R0 = (.CTX[COM_MRG_INPUT])
		    (RUNBLOCK[RUN_BUFF0], %REF(.DDB), D[0], .CTX[COM_CTXADR]);
	    IF NOT .R0
	    THEN
		BEGIN
		IF .R0 NEQ SS$_ENDOFFILE	! Unexpected error status?
		THEN
		    R0 = SOR$$ERROR(SOR$_RTNERROR, 0, .R0);
		RETURN_ DELRUN(RUNBLOCK[BASE_]);	! Return 0 to indicate EOF
		END;
	    D[1] = .RUNBLOCK[RUN_BUFF1];
	    CTX[COM_MRG_STREAM] = .DDB;
	    END
	ELSE
	    BEGIN
	    %IF NOT HOSTILE %THEN

	    ! Clear the VFC area
	    !
	    IF .CTX[COM_MINVFC] NEQ 0
	    THEN
		CH$FILL_(0, .CTX[COM_MAXVFC], .CTX[COM_RHB_INP]);

	    ! Now get the record
	    !
	    R0 = $GET(RAB=DDB[DDB_RAB+BASE_]);

	    ! Create a descriptor for the input record
	    !
	    D[0] = .DDB[DDB_RAB+RAB$W_RSZ];
	    D[1] = .DDB[DDB_RAB+RAB$L_RBF];
	    CTX[COM_MRG_STREAM] = .DDB[DDB_FIL];

	    %ELSE
	    RETURN_ SOR$$ERROR(SOR$_SHR_BADLOGIC);
	    %FI
	    END;

	IF .R0
	THEN
	    BEGIN

	    CTX[COM_INP_RECNUM] = .CTX[COM_INP_RECNUM] + 1;

	    IF
		BEGIN
		!
		! Check the length
		!
		IF .D[0] GTRU .CTX[COM_LRL]
		THEN
		    BEGIN
		    !
		    ! If too long, complain and shorten the record
		    !
		    R0 = SOR$$ERROR(SOR$_BAD_LRL, 1, .D[0],
			SOR$_SHR_READERR, 1, DDB[DDB_NAME]);
		    D[0] = .CTX[COM_LRL];
		    TRUE
		    END
		ELIF .D[0] LSSU .CTX[COM_SRL]
		THEN
		    BEGIN
		    !
		    ! If too short, complain and ignore the record
		    !
		    R0 = SOR$$ERROR(SOR$_BAD_SRL, 1, .D[0],
			SOR$_SHR_READERR, 1, DDB[DDB_NAME]);
		    CTX[COM_OMI_RECNUM] = .CTX[COM_OMI_RECNUM] + 1;
		    FALSE
		    END
		ELSE
		    TRUE
		END
	    THEN
		BEGIN
		!
		! Convert the record to the internal format, and return the
		! address of the internal format record.
		!
		IF NOT (R0 = JSB_INPUT(.CTX[COM_INPUT], D[0],
			.RUNBLOCK[RUN_BUFFER]))
		THEN
		    CTX[COM_OMI_RECNUM] = .CTX[COM_OMI_RECNUM] + 1
		ELSE
		    RETURN_ .RUNBLOCK[RUN_BUFFER];
		END;
	    END
	%IF NOT HOSTILE %THEN
	ELIF
	    .R0 EQL RMS$_RSA			! Record Stream Active
	THEN
	    R0 = $WAIT(RAB=DDB[DDB_RAB+BASE_])	! Wait until not so active
	ELIF
	    .R0 EQL RMS$_RLK
	THEN
	    BEGIN
	    !
	    ! Try setting the "read regardless of lock" bit.
	    ! If we had already tried that, exit with the error.
	    !
	    BUILTIN
		TESTBITSS;
	    IF TESTBITSS(DDB[DDB_RAB+RAB$V_RRL]) THEN EXITLOOP;
	    R0 = SOR$$ERROR(
		SOR$_SHR_READERR AND NOT STS$M_SEVERITY OR STS$K_WARNING,
		1, DDB[DDB_NAME],
		.DDB[DDB_RAB+RAB$L_STS], .DDB[DDB_RAB+RAB$L_STV],
		RMS$_OK_RRL);
	    END
	%FI
	ELSE
	    EXITLOOP;				! Some other error
	END;


    ! Check for the expected status
    !
    IF .R0 NEQ RMS$_EOF
    THEN
	BEGIN
	REGISTER
	    DDB:	REF DDB_BLOCK;		! Pointer to DDB
	DDB = .RUNBLOCK[RUN_DDB];
	R0 = SOR$$ERROR(SOR$_SHR_READERR, 1, DDB[DDB_NAME],
		.DDB[DDB_RAB+RAB$L_STS], .DDB[DDB_RAB+RAB$L_STV]);
	END;

    RETURN_ DELRUN(RUNBLOCK[BASE_]);	! Return 0
    END;

ROUTINE FILL				! Read from a scratch file
	(
	RUNBLOCK:	REF RUN_BLOCK,	! Address of run description block
	P:		REF VECTOR[2]	! Length/address
	):	JSB_INPUT =
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK;
    LOCAL
	IOSB:	VECTOR[4,WORD];

    RUN = RUNBLOCK[BASE_];

    WHILE .P[0] GTR 0 DO
	BEGIN
	LOCAL
	    RDB:	REF RDB_BLOCK,
	    WFB:	REF WFB_BLOCK,
	    SIZE;			! Number of blocks to write

	! Compute the number of blocks we will read
	!
	RDB = .RUN[RUN_RDB_CURR];
	WFB = .RDB[RDB_WFB];
	SIZE = MINU(
	    .P[0] ^ -LN2_(COM_K_BPERPAGE),
	    .RDB[RDB_VBN] + .RDB[RDB_SIZE] - .RUN[RUN_VBN],
	    127);
	IF
	    .SIZE EQL 0		! Was this RDB depleted?
	THEN
	    BEGIN
	    FREE_RDB_(RUN[RUN_RDB], WFB_FREE);
	    RUN[RUN_RDB_CURR] = .RUN[RUN_RDB];
	    RDB = .RUN[RUN_RDB_CURR];
	    IF RDB[BASE_] EQL 0 THEN EXITLOOP;
	    RUN[RUN_VBN] = .RDB[RDB_VBN];
	    END
	ELSE
	    BEGIN
	    LOCAL
		STATUS;

	    STATUS = $QIOW(
		EFN=	.CTX[S_WRK_EFN],
		CHAN=	.WFB[WFB_CHAN],
		FUNC=	IO$_READVBLK,
		IOSB=	IOSB,
		ASTADR=	0,
		ASTPRM=	0,
		P1=	.P[1],
		P2=	.SIZE ^ LN2_(COM_K_BPERPAGE),
		P3=	.RUN[RUN_VBN]
		%IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
	    IF .STATUS THEN STATUS = .IOSB[0];

	    IF NOT .STATUS
	    THEN
		BEGIN
		RETURN SOR$$ERROR(SOR$_SHR_READERR, 1, WFB[WFB_NAME], .STATUS);
		END
	    ELSE
		BEGIN
		!
		! Update the next virtual block number to read.
		! Update blocks read/written since last checkpoint.
		! Update the size/address of the buffer to write
		!
		RUN[RUN_VBN]  = .RUN[RUN_VBN]  + .SIZE;
%IF FUN_K_CHECKPOINT
%THEN
		CTX[COM_COUNTDOWN] = .CTX[COM_COUNTDOWN] - .SIZE;
%FI
		P[0] = .P[0] - .SIZE ^ LN2_(COM_K_BPERPAGE);
		P[1] = .P[1] + .SIZE ^ LN2_(COM_K_BPERPAGE);
		END;
	    END;
	END;

%IF FUN_K_CHECKPOINT
%THEN
    IF .CTX[COM_COUNTDOWN] LSS 0
    THEN
	SOR$$CHECKPOINT();
%FI

    RETURN SS$_NORMAL;
    END;

GLOBAL ROUTINE SOR$$WORK_READ		! Read from a work file
	(
	RUNBLOCK:	REF RUN_BLOCK	! Address of run description block
	):	JSB_INPUT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads from a work file.
!
! FORMAL PARAMETERS:
!
!	RUNBLOCK	Address of run description block
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Address of record, or zero if end-of-run.
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK,
	LEN;					! Length of record
    LOCAL
	IOSB:	VECTOR[4,WORD];

    RUN = RUNBLOCK[BASE_];


    ! If we were invoked for a merge, call MRG_WORK_READ to get the record
    !
    IF .CTX[COM_MERGE]
    THEN
	RETURN MRG_WORK_READ(RUN[BASE_]);


    RUN[RUN_COUNT] = .RUN[RUN_COUNT] - 1;	! One less record
    IF .RUN[RUN_COUNT] LSS 0
    THEN
	RETURN DELRUN(RUN[BASE_]);		! Return now if no more records


    ! Set the length of the record to be read.
    !
    LEN = .CTX[COM_LRL_INT];


    ! If everything fine, return now with the address of the record.
    !
    IF (RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] - .LEN) GEQ 0
    THEN
	BEGIN
	RUN[RUN_BUFF1] = .RUN[RUN_BUFF1] + .LEN;	! Next free byte
	RETURN .RUN[RUN_BUFF1] - .LEN;
	END
    ELSE
	RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] + .LEN;	! Reset


    ! Not all of this record is in the buffer.
    !
    ! We move the first part of the record backwards in the buffer, so that
    ! the first part ends at a page boundary.  Then we request that the rest
    ! of the buffer be filled.
    !
    BEGIN
    LOCAL
	TMP,
	P:	VECTOR[2];

    ! Compute the address of the next free byte following the copied string.
    ! Then actually copy the first part of the string.
    !
    P[1] = .RUN[RUN_BUFFER] + ROUND_(.RUN[RUN_BUFF0], COM_K_BPERPAGE);
    TMP = .P[1] - .RUN[RUN_BUFF0];
    CH$MOVE(.RUN[RUN_BUFF0], .RUN[RUN_BUFF1], .TMP);

    ! Set BUFF0/1 to the length/address of the start of the (moved) record.
    !
    RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] + .RUN[RUN_BUFF1] - .TMP;
    RUN[RUN_BUFF1] = .TMP;

    ! Set up for the read
    !
    P[0] = .RUN[RUN_BUFF1] + .RUN[RUN_BUFF0] - .P[1];

    ! Fill the buffer
    !
    IF NOT FILL(RUN[BASE_], P[0])
    THEN
	RETURN DELRUN(RUN[BASE_]);	! Return 0 to indicate end of file

    RUN[RUN_BUFF0] = .RUN[RUN_BUFF0] - .LEN;
    RUN[RUN_BUFF1] = .RUN[RUN_BUFF1] + .LEN;
    RETURN .RUN[RUN_BUFF1] - .LEN;
    END;

    END;

GLOBAL ROUTINE POSITION				! Position to start of run
	(
	RUNBLOCK:	REF RUN_BLOCK		! Run to be positioned to
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine positions to a run in a work file.
!	It also starts reading that run.
!
! FORMAL PARAMETERS:
!
!	RUNBLOCK	Address of run description block to be positioned to
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	RUN:	REF RUN_BLOCK,			! Pointer to run block
	STATUS;
    LOCAL
	P:	VECTOR[2],
	IOSB:	VECTOR[4,WORD];


    ! Get a pointer to the run description block, and a buffer for the run
    !
    RUN = RUNBLOCK[BASE_];
    GET_BUFFER(RUN[BASE_]);


    ! Set up for the read.
    ! Set the starting virtual block address of this run.
    ! Set the length and address of the buffer.
    !
    RUN[RUN_RDB_CURR] = .RUN[RUN_RDB];
    RUN[RUN_VBN] = .BBLOCK[.RUN[RUN_RDB_CURR],RDB_VBN];

    P[0] = MINU(.RUN[RUN_BUFF0], .RUN[RUN_SIZE]^LN2_(COM_K_BPERPAGE));
    P[1] = .RUN[RUN_BUFFER];

    ! Fill the buffer
    !
    IF NOT FILL(RUN[BASE_], P[0])
    THEN
	BEGIN
	RUN[RUN_COUNT] = 0;		! Indicate end of file
	RETURN;
	END;

    END;

ROUTINE DELRUN				! Indicate this run is through
	(
	RUNBLOCK:	REF RUN_BLOCK		! Run description block
	):	CAL_CTXREG =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine indicates that processing for a run is complete.
!
! FORMAL PARAMETERS:
!
!	RUNBLOCK	Address of run description block of run to delete
!	CTX		Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Zero.
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	P:	REF RUN_BLOCK,
	Q:	REF VECTOR[1],
	R:	REF RDB_BLOCK,
	STATUS;


    ! One less outstanding run
    !
    CTX[COM_RUNS] = .CTX[COM_RUNS] - 1;		! One less run

    ! Free all RDBs connected to this RUN block
    !
    Q = RUNBLOCK[RUN_RDB];
    RUNBLOCK[RUN_RDB_CURR] = 0;
    MOVE_ALL_RDBS_( Q[0], WFB_FREE );

    ! Find the run description block in the list of active runs,
    ! and remove it from this list.
    !
    Q = CTX[S_RUN_INFO];
    WHILE (P = .Q[0]) NEQ 0 DO
	BEGIN
	IF P[BASE_] EQL RUNBLOCK[BASE_] THEN EXITLOOP;
	Q = P[RUN_NEXT];
	END;
    IF P[BASE_] EQL 0
    THEN
	RETURN SOR$$FATAL(SOR$_SHR_BADLOGIC);	! We couldn't find it

    ! Free the buffer associated with this run.
    ! Unlink and deallocate the run block.
    !
    FREE_BUFFER(P[BASE_]);			! Free this run's buffer
    REMLH_(Q[0], P, RUN_NEXT, RUN_K_SIZE);	! Unlink this RUN block

    ! Return zero, since most of our callers want to immediately return 0
    ! after calling us.
    !
    RETURN 0;
    END;

ROUTINE WORK_OPEN
	(
	FNS:	REF VECTOR[2]		! Work file name string
	) : CAL_CTXREG NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine creates/opens the work files.
!
! FORMAL PARAMETERS:
!
!	FNS	File name string of work file to be opened (optional)
!		If not present, all COM_WORK_FILES work files are opened.
!		If present, only one work file is opened.
!	CTX	Longword pointing to work area (passed in COM_REG_CTX)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	CTX[S_BUF_SIZE] is calculated.
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    BUILTIN
	NULLPARAMETER;
    LOCAL
	FAB:	$FAB_DECL,			! FAB for the work file
	NAM:	$NAM_DECL VOLATILE,		! NAM for the work file
	FNA:	VECTOR[NAM$C_MAXRSSLCL,BYTE],	! File name string
	WFB:	REF WFB_BLOCK,			! Pointer to WFB for work files
	WFB_PTR:	REF VECTOR[1,LONG],	! Addr of pointer to WFB
	XABPRO:	$XABPRO_DECL,			! XAB for file protection
	STATUS;					! Status


    ! Set the default extend amount to half the tree size
    !
    CTX[S_WRK_DEQ] = MAXU(
	.CTX[COM_TREE_LEN] ^ -LN2_(COM_K_BPERBLOCK*2),
	TUN_K_BUFSIZE / COM_K_BPERBLOCK);

    ! Get an event flag to use for work file I/O
    !
    %IF NOT HOSTILE %THEN
    STATUS = LIB$GET_EF(CTX[S_WRK_EFN]);
    IF NOT .STATUS
    THEN
	RETURN SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS);
    %FI

    $FAB_INIT(
	FAB = FAB[BASE_],
	NAM = NAM[BASE_],
	FNA = FNA[0],
!	FNS = 0,		! Set below
	DNA = UPLIT BYTE(STR_DEF_WORKFILE),
	DNS = %CHARCOUNT(STR_DEF_WORKFILE),
%IF TUN_K_WRK_PREALL 
%THEN
	ALQ = 2 * .CTX[S_WRK_DEQ]		! Tree size
		/ .CTX[COM_WRK_FILES],		! Divided by number of files
%FI
	DEQ = .CTX[S_WRK_DEQ],			! Default extension quantity
!	BKS = 0,		! Only for relative or indexed files
!	BLS = 0,		! Only for magnetic tape files
	FAC = <BIO,DEL,GET,PUT,UPD>,
	FOP = <CBT,DFW,DLT,SUP,TMD,TMP,SQO,UFO>,	! TMD,TMP???
	FSZ = 0,
	MRN = 0,
	MRS = COM_K_BPERBLOCK,
	ORG = SEQ,
!	RAT = 0,		! No special record attributes
	RFM = FIX,		! Fixed format records
	RTV = 10,		! 10 retrieval pointers
!	SHR = GET,		! Allow others to read this file
	XAB = XABPRO[BASE_]);	! File protection XAB
    $NAM_INIT(
	NAM = NAM[BASE_],
	ESS = NAM$C_MAXRSSLCL,
	ESA = FNA[0],
	RSS = NAM$C_MAXRSSLCL,
	RSA = FNA[0]);


    WFB_PTR = CTX[S_WRK_WFB];
    WHILE .WFB_PTR[0] NEQ 0 DO WFB_PTR = BBLOCK[.WFB_PTR[0],WFB_NEXT];
    DECR I FROM .CTX[COM_WRK_FILES]-1 TO 0 DO
	BEGIN
	STRUCTURE
	    BVECTOR[I;N,EXT=0] = [N](BVECTOR+I)<0,8,EXT>;
	!
	! Allocate WFB and link into list (advance to next file at end of loop)
	! These are put at the end of the list so that SORTWORK0 is used first,
	! followed by SORTWORK1, et cetera.
	!
	WFB = SOR$$ALLOCATE(WFB_K_SIZE);
	WFB_PTR[0] = WFB[WFB_NEXT];	! Store address of the next pointer

	! Get the name of this file
	!
	IF NOT NULLPARAMETER(1)
	THEN
	    BEGIN
	    CH$MOVE(
		(FAB[FAB$B_FNS] = MINU(.FNS[0], %ALLOCATION(FNA))),
		.FNS[1], FNA[0]);
	    END
	ELIF .I GEQU .BVECTOR[CTX[COM_WF_NAMES], 0]
	THEN
	    BEGIN
	    FAB[FAB$B_FNS] = %CHARCOUNT(STR_LOG_WORKFILE)+1;
	    CH$MOVE(
		%CHARCOUNT(STR_LOG_WORKFILE),
		UPLIT BYTE(STR_LOG_WORKFILE),
		FNA[0]);
	    ASSERT_(%CHARCOUNT(STR_LOG_WORKNUM) GEQ MAX_WORK_FILES)
	    FNA[%CHARCOUNT(STR_LOG_WORKFILE)] = .BVECTOR[UPLIT BYTE(
		%EXACTSTRING(MAX_WORK_FILES,0,STR_LOG_WORKNUM)), .I];
	    END
	ELSE
	    %IF NOT HOSTILE %THEN
	    BEGIN
	    LIBRARY 'SRC$:SRTSPC';
	    LOCAL
		CFT: REF CFT_TAB[1];
	    CFT = CFT_TAB[.CTX[COM_CFT_ADR],
		.BVECTOR[CTX[COM_WF_NAMES], .I+1], BASE_];
	    CH$MOVE(
		(FAB[FAB$B_FNS] = MINU(.CFT[0,CFT_CON_LEN], %ALLOCATION(FNA))),
		.CFT[0,CFT_CON_ADR]+.CTX[COM_CFT_ADR], FNA[0]);
	    END;
	    %ELSE
	    RETURN SOR$$FATAL(SOR$_SHR_BADLOGIC);
	    %FI

	! Clear these fields, since we are reusing the NAM, FAB and XAB blocks
	!
	NAM[NAM$B_RSL] = 0;
	NAM[NAM$B_ESL] = 0;
	FAB[FAB$W_IFI] = 0;
	$XABPRO_INIT(
	    XAB = XABPRO[BASE_],
	    PRO = <D,RWED>);

	! Actually create the work file
	!
	STATUS = $CREATE(FAB = FAB[BASE_]
	    %IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );

	! Get the best file name string available into NAM$B_RSL/NAM$L_RSA
	!
	SOR$$BEST_FILE_NAME(FAB[BASE_], WFB[WFB_NAME]);

	! Check status
	!
	IF NOT .FAB[FAB$L_STS]
	THEN
	    BEGIN
	    SOR$$ERROR(SOR$_SHR_OPENOUT AND NOT STS$M_SEVERITY OR STS$K_ERROR,
		1, WFB[WFB_NAME], .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
	    END
	ELIF NOT .BBLOCK[FAB[FAB$L_DEV], DEV$V_RND] OR .NAM[NAM$V_NODE]
	THEN
	    BEGIN
	    !
	    ! Device must be local and random access.
	    !
	    $DASSGN(CHAN=.FAB[FAB$L_STV]
		%IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
	    SOR$$ERROR(SOR$_WORK_DEV, 1, WFB[WFB_NAME]);
	    END
	ELSE
	    BEGIN
	    !
	    ! Save the channel number (returned in STV)
	    ! Create a large hole describing available space.
	    !
	    LOCAL
		RDB:	REF RDB_BLOCK;
	    WFB[WFB_CHAN] = .FAB[FAB$L_STV];
	    RDB = SOR$$ALLOCATE(RDB_K_SIZE);
	    INSLH_(WFB[WFB_NOUSE], RDB, RDB_NEXT);
	    RDB[RDB_WFB] = WFB[BASE_];		! Reference the WFB
	    RDB[RDB_VBN] = 1;			! First virtual block number
	    RDB[RDB_SIZE] = -1;			! A very large hole
	    END;


	! Check for an error
	!
	IF .WFB[WFB_CHAN] EQL 0
	THEN
	    BEGIN
	    !
	    ! Deallocate and unlink
	    !
	    SOR$$FREE_FILE_NAME(WFB[WFB_NAME]);	! Free name string
	    REMLH_(WFB_PTR[0], WFB, WFB_NEXT, WFB_K_SIZE);
	    CTX[COM_WRK_FILES] = .CTX[COM_WRK_FILES] - 1;
	    END
	ELSE
	    BEGIN
	    IF NOT NULLPARAMETER(1)
	    THEN
		SOR$$ERROR(SOR$_USE_ALT,
		    2, UPLIT(%ASCIC 'work'), WFB[WFB_NAME]);
	    WFB_PTR = WFB[WFB_NEXT];		! Advance to next WFB
	    END;
	END;

    ! If we didn't get enough work files, abort.
    !
    IF NOT NULLPARAMETER(1) THEN RETURN;
    IF .CTX[COM_WRK_FILES] LSS MIN_WORK_FILES
    THEN
	BEGIN
	LOCAL
	    SYS_DISK: VECTOR[2] INITIAL(
		%CHARCOUNT('SYS$DISK:'),
		UPLIT BYTE('SYS$DISK:'));

	! Try using SYS$DISK for the work files
	!
	CTX[COM_WRK_FILES] = MIN_WORK_FILES;
	ASSERT_(MIN_WORK_FILES EQL 1)
	WORK_OPEN(SYS_DISK);
	IF .CTX[COM_WRK_FILES] LSS MIN_WORK_FILES
	THEN
	    RETURN SOR$$FATAL(SOR$_NO_WRK);
	END;


    ! CTX[S_BUF_SIZE] is the number of bytes to use for each buffer.
    ! It may have been calculated earlier, but that calculation may have been
    ! too small.  We need at least enough room for a record (rounded up to a
    ! full number of pages) plus an extra page.
    !
    ASSERT_(COM_K_BPERPAGE EQL COM_K_BPERBLOCK)
    ASSERT_(TUN_K_BUFSIZE GEQ 2*COM_K_BPERPAGE)
    CTX[S_BUF_SIZE] = MAX(
	TUN_K_BUFSIZE,
	.CTX[COM_LRL_INT] + COM_K_BPERPAGE,
	.CTX[S_BUF_SIZE]);
    CTX[S_BUF_SIZE] = ROUND_(.CTX[S_BUF_SIZE], COM_K_BPERPAGE);

    END;

GLOBAL ROUTINE SOR$$WRK_ALQ: CAL_CTXREG =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Calculate work file allocation.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Total work file allocation.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	WFB:	REF WFB_BLOCK,
	WFALQ:	INITIAL(0);

    ! Loop through all the work files,
    ! computing the total number of blocks allocated to them.
    !
    WFB = .CTX[S_WRK_WFB];
    WHILE WFB[BASE_] NEQ 0 DO
	(WFALQ = .WFALQ + .WFB[WFB_ALQ]; WFB = .WFB[WFB_NEXT]);
    RETURN .WFALQ;

    END;

ROUTINE CLEAN_UP: CAL_CTXREG NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Release resources allocated by this module.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE (signals errors)
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK_(S_FIELDS);
    LOCAL
	WFB:	REF WFB_BLOCK,
	WFB_ADR:REF VECTOR[1],
	STATUS;


    ! Cancel the post-checkpoint handler
    !
    %IF FUN_K_CHECKPOINT %THEN
    IF CHK$CANPSH NEQ 0 THEN
    IF .CTX[S_PSH_HANDLER] NEQ 0
    THEN
	BEGIN
	STATUS = CHK$CANPSH(CTX[S_PSH_HANDLER]);
	IF .STATUS AND .CTX[S_RSH_HANDLER] NEQ 0 THEN
	STATUS = CHK$CANRSH(CTX[S_RSH_HANDLER]);
	IF NOT .STATUS
	THEN
	    SOR$$ERROR(SOR$_SHR_SYSERROR AND NOT STS$M_SEVERITY OR STS$K_WARNING,
		0, .STATUS);
	END;
    %FI

    ! Deallocate the work file event flag
    !
    %IF NOT HOSTILE %THEN
    IF .CTX[S_WRK_EFN] NEQ 0
    THEN
	BEGIN
	LOCAL
	    STATUS;
	STATUS = LIB$FREE_EF(CTX[S_WRK_EFN]);
	IF NOT .STATUS THEN SOR$$ERROR(
		SOR$_SHR_SYSERROR AND NOT STS$M_SEVERITY OR STS$K_ERROR,
		0, .STATUS);
	END;
    %FI


    ! Deallocate the run description blocks from the active list.
    !
    BEGIN
    LOCAL
	Q:	REF VECTOR[1],
	RUN:    REF RUN_BLOCK;
    Q = CTX[S_RUN_INFO];
    WHILE (RUN = .Q[0]) NEQ 0 DO DELRUN(RUN[BASE_]);
    END;


    ! For each WFB linked into this list
    !
    WFB_ADR = CTX[S_WRK_WFB];
    WHILE (WFB = .WFB_ADR[0]) NEQ 0 DO
	BEGIN

	! Deassign the channel
	!
	IF .WFB[WFB_CHAN] NEQ 0
	THEN
	    BEGIN
	    STATUS = $DASSGN(CHAN=.WFB[WFB_CHAN]
		%IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
	    IF NOT .STATUS THEN SOR$$ERROR(
		SOR$_SHR_SYSERROR AND NOT STS$M_SEVERITY OR STS$K_ERROR,
		0, .STATUS);
	    WFB[WFB_CHAN] = 0;
	    END;

	! Free the file name string
	!
	SOR$$FREE_FILE_NAME(WFB[WFB_NAME]);	! Free name string

	! Free the RDBs linked to this WFB
	!
	BEGIN
	LOCAL
	    Q:		REF VECTOR[1],
	    RDB:	REF RDB_BLOCK;
	Q = WFB[WFB_FREE];
	WHILE (RDB = .Q[0]) NEQ 0 DO REMLH_(Q[0], RDB, RDB_NEXT, RDB_K_SIZE);
	Q = WFB[WFB_NOUSE];
	WHILE (RDB = .Q[0]) NEQ 0 DO REMLH_(Q[0], RDB, RDB_NEXT, RDB_K_SIZE);
	Q = WFB[WFB_FULL];
	WHILE (RDB = .Q[0]) NEQ 0 DO REMLH_(Q[0], RDB, RDB_NEXT, RDB_K_SIZE);
	END;

	! Free the WFB
	!
	REMLH_(WFB_ADR[0], WFB, WFB_NEXT, WFB_K_SIZE);

	END;


    ! Deallocate the buffers
    !
    BEGIN
    LOCAL
	Q:	REF VECTOR[1],
	BUF:	REF BUF_BLOCK,
	P:	REF BUF_BLOCK;
    Q = CTX[S_BUF_ALLOC];
    WHILE (P = .Q[0]) NEQ 0 DO
	BEGIN
	BUF = .P[BUF_ADDR];
	BUF[BUF_NEXT] = .P[BUF_NEXT];
	BUF[BUF_ADDR] = .P[BUF_ADDR];
	Q[0] = BUF[BASE_];
	REMLH_(Q[0], BUF, BUF_NEXT, .CTX[S_BUF_SIZE]+COM_K_BPERPAGE);
	END;
    END;


    END;

END
ELUDOM
