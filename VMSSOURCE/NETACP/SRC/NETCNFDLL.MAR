	.TITLE	NETCNFDLL  - Datalink database action routines
	.IDENT	'V04-000'
	.DEFAULT DISPLACEMENT,LONG

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

; FACILITY:	NETWORK ACP
;
; ABSTRACT:
;		Action routines for CRI and PLI databases.
;
;		This module provides support to the NETACP database management
;		including database entry insertion and action routines to
;		retrieve data for parameters which are not stored in any of 
;		the datalink CNF control blocks (CRI and PLI).
;
; ENVIRONMENT:
;		The module runs in kernel mode and at possibly elevated IPL.
;		It is therefore locked into the ACP's virtural address space
;		in order to prevent the need for paging.
;
;		Since the ACP is work-queue driven, and since it is the ACP
;		that modifies the structure of the non-paged pool data base
;		including the RCB (actually a VCB) and the private structures
;		hanging off of the RCB, there is no need to obtain the system
;		data base mutex -- no races can occur.   However, it is
;		necessary to raise IPL in order to stop any races with
;		NETDRIVER.
;		
;
; AUTHOR:	A.Eldridge	14-Feb-80
;
; MODIFIED BY:
;
;	V021	RNG0021		Rod Gamache	17-Jul-1984
;		Add more checks to insure the DEV$V_NET bit is set for
;		datalink drivers.
;
;	V020	RNG0020		Rod Gamache	16-Mar-1984
;		Make sure DEV$V_NET bit is on before attempting to use any
;		device driver.
;
;	V019	RNG0019		Rod Gamache	13-Jan-1984
;		Add DPV and KMV support for X.25.
;
;	V018	RNG0018		Rod Gamache	18-Nov-1983
;		Add QNA support for communication over the NI.
;
;	V017	TMH0017		Tim Halvorsen	27-Apr-1983
;		Add pseudo-point-to-point version of PPUNA circuit for
;		testing of point-to-point circuits over the NI.
;
;	V016	RNG0016		Rod Gamache	15-Apr-1983
;		Allow driver NMA parameter i.d.'s to be returned which
;		the NETACP doesn't know about. This allows drivers the
;		flexibility of adding parmeters which the NETACP can ignore.
;
;	V015	RNG0015		Rod Gamache	11-Apr-1983
;		Make the REMOVE_XXX routines call the REMOVE_DEF routine
;		to remove the PLI or CRI CNF structure.
;
;	V014	TMH0014		Tim Halvorsen	04-Mar-1983
;		Add new DEVNAM circuit parameter action routine.
;		Return second longword of IOSB from datalink setmode
;		to issuer of SET LINE STATE ON function.
;
;	V013	TMH0013		Tim Halvorsen	14-Feb-1983
;		Make datalink BUS parameter variable, depending on the
;		type of datalink.  It now returns a larger value for NI
;		datalinks, to account for the additional Phase IV Ethernet
;		route header.
;		Make BUS return line BFS parameter if system manager
;		wants to override the executor buffer size on a per-line
;		basis.
;		Conditionally allow the DMC to perform I/O functions on the
;		controller.
;
;	V012	TMH0012		Tim Halvorsen	20-Dec-1982
;		Add new UNA parameter to table of parameters to ignore
;		on sensemode requests.
;		If the error qualifier returned by a datalink driver is
;		"physical address", meaning that DECnet's requested physical
;		address is in conflict with another user of the device,
;		then map the qualifier to "hardware address", for which
;		a NICE parameter exists.  This is so that when an NCP
;		user requests to have the line turned on, and it fails
;		due to address conflict, then a parameter is returned with
;		"bad parameter value".
;		Suppress node addresses if areas have been hidden.
;
;	V011	TMH0011		Tim Halvorsen	29-Nov-1982
;		Remove one lagging reference to NMA$C_CIRTY_LAP symbol.
;		Add support for Ethernet protocol type parameter, rather
;		than using a hard-coded constant.  This is so that a UNA
;		can be used on another protocol type without interfering
;		with the normal DECnet traffic on an experimental basis.
;
;	V010	TMH0010		Tim Halvorsen	13-Oct-1982
;		Journal I/O requests to PSIACP.
;		Replace all occurrences of NMA$C_CIRTY_LAP with
;		NMA$C_CIRTY_LAPB.
;		Remove defaulting of USAGE to OUTGOING if NUMBER
;		is set, since NUMBER now is used for both incoming
;		and outgoing DLM circuits.
;		Fix bug in SET LINE if mnemonic doesn't parse correctly.
;
;	V009	TMH0009		Tim Halvorsen	27-Sep-1982
;		Change meaning of LPD DRT cell from the designated
;		router's node address to it's ADJ index.
;		Modify circuit substate action routine so that value
;		is returned if circuit is in "S" state.
;
;	V008	TMH0008		Tim Halvorsen	14-Sep-1982
;		Deassign channel if error detected trying to start
;		a broadcast line and the executor type is not Phase IV.
;		(channel was getting left assigned).
;		If an INCOMING DLM circuit is defined, then declare
;		NETACP as able to receive incoming calls, in case it
;		wasn't already defined in the SET EXECUTOR (PSI might
;		not have been up then).
;		Make USAGE default to OUTGOING if the NUMBER parameter
;		is set on a DLM circuit.
;		Add DLM circuit defaulting (separate from transport defaults).
;		Add support for automatic line counters and automatic PSI
;		native circuit counters.
;
;	V007	TMH0007		Tim Halvorsen	31-Aug-1982
;		Add action routine to return designated router on NI.
;		Fix counter returns for DLM switched circuits.
;
;	V006	TMH0006		Tim Halvorsen	01-Jul-1982
;		Add Phase IV line, circuit support.
;		Add journalling of SETMODE QIOWs.
;		Fix error path in PSI counter sensing.
;		Modify PNA, PNN, BLO and add LIT to work with adjacencies.
;		Add PLI DEVNAM action routine, which returns the physical
;		device name being used by the line, in VMS format, including
;		the unit number.
;		Do not allow user to turn on an NI line device unless
;		the executor type is set to Phase IV, since Phase III
;		doesn't handle broadcast circuits.
;		Fix bug in preallocation of receive buffers - it wasn't
;		including the CXB overhead in the buffer size.
;		Clear PLI MCD before each SHOW function.
;
;	V005	TMH0005		Tim Halvorsen	30-Jun-1982
;		Change defaulting of line and circuit parameters, to
;		be dependant on the type of line or circuit.  This is
;		done because the default parameters for a DDCMP circuit
;		are not the same as for a X25 circuit, or an NI circuit.
;		The same thing is true for DDCMP or LAPB lines.
;		Add code to ask PSI for it's line/circuit parameters on
;		SHOW functions, so that a show returns the sum for both
;		NETACPs and PSIs databases.
;		Change mneumonic of KMS to KMX, marking it "multiple-unit
;		controller" and add KMY.
;
;	V004	TMH0004		Tim Halvorsen	16-Jun-1982
;		Always give null context area on PSI control QIOs.
;		Fix list of line/circuit parameters which are passed to PSI.
;		Add support for asking PSI for its line/circuit counters.
;		Fix bug in sensing of datalink counters, to correctly
;		detect and remove the "seconds since last zeroed" counter
;		(it never worked, but no driver ever returned it either).
;		Don't tell PSI about SVCs, since it doesn't want to know
;		about them.
;		Add kludge to SEND_TO_PSI, so that all ACPCONTROL functions
;		to PSIACP are terminated with NFB$C_ENDOFLIST, to avoid the
;		check which doesn't allow 0 field identifiers.
;
;	V003	TMH0003		Tim Halvorsen	15-Jun-1982
;		Remove code to disable error reporting from PSI control QIOs.
;
;	V002	TMH0002		Tim Halvorsen	04-Apr-1982
;		Make this new module from the CRI and PLI routines in CNFACT
;		in an attempt to reduce the size of that module.
;		Remove code to make the start key canonical, since
;		the start key no longer exists.
;		Add code to check if we are dealing with a LAPB line,
;		and if so, give it to PSIACP.
;		Remove some obsolete symbols.
;		Remove X.25 parameters from NICE-NFB translation table,
;		since we will never have to translate PSI NICE parameters.
;		Clean up code in INSERT_CRI and INSERT_PLI.
;		Fix code to "update" volatile fields in CNF from values given
;		by the datalink driver, so that it doesn't stop when it can't
;		modify a particular field, but continues thru all the rest of
;		the parameters returned by the driver.  A single field which
;		is conditionally writable might stop the code from ever
;		processing the rest of the fields.
;		Make default word displacement.
;		Send DELETE requests to PSI.
;		Clean up SHOW_xxx routines.
;		Pre-allocate receive buffers before issuing a SETMODE
;		startup function to a datalink driver, so that pool
;		expansion can be done to accomodate the buffers.  It
;		is done here because pool expansion can't be done on
;		the interrupt stack in the datalink driver.
;		Default the line protocol based on the line name mnemonic.
;		Add X25 to the list of allowed mnemonics for circuit names.
;		Send all circuits set/clears with TYPE=X25 to PSI.
;		Change all CNF action routines to use the new action routine
;		interface (NETCNF now automatically allocates a TMP buffer).
;		Remove obsolete NUL action routines.
;		Do not send "show-only" datalink parameters (returned by the
;		driver and stored into the CNF) back to the driver in the
;		next setmode.  Mark show-only datalink parameters in the
;		translation table.
;		Make circuits of the form X25-x default to TYPE=X25 so that
;		you don't have to enter TYPE all the time.
;		Reformat secondary search key into cononical form if the
;		field is the line or circuit name.
;		Add KMS to device list for X.25 network management.
;		Add X.25 datalink mapping support.
;		Allow any characters to appear after circuit names of the
;		form "X25-xxx"
;
;	V001	TMH0001		Tim Halvorsen	27-Mar-1982
;		Fix code to translate an NMA parameter code returned by
;		a datalink driver validation error to a NFB code.
;---

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$DEVDEF		; Define device characteristics bits
	$DVIDEF		; $GETDVI item codes
	$DCDEF		; Device classs definitions
	$CCBDEF		; Channel Control Block
	$CXBDEF		; Complex-chained buffers
	$UCBDEF		; Unit Control Block
	$XMDEF		; XMDRIVER (general communications device driver)

	$NFBDEF		; Network Function Block (ACP control QIO definitions)
	$NMADEF		; Network Management (NICE protocol) definitions
	$EVCDEF		; DECnet Event logging symbols
	$CNRDEF		; Configuration Root block
	$CNFDEF		; Configuration data block
	$DEVTRNDEF	; Device translation (VMS vs. Nice protocol) info
	$DLLQIODEF	; Data-Link Layer QIO definitions	
	$RCBDEF		; Routing Control Block (analogous to Volume Control
			; block)
	$LPDDEF		; Logical path descriptor
	$ADJDEF		; Adjacency control block
	$NETSYMDEF	; Miscellaneous network symbols
	$NETUPDDEF	; Symbols used in private NETACP interface to NETDRIVER
	$NSPMSGDEF	; DNA architecture definitions & message formats

;
; Macros
;

	.MACRO	SWAP,ARG1,ARG2		; Swap arguments in-place
	XORL	ARG1,ARG2
	XORL	ARG2,ARG1
	XORL	ARG1,ARG2
	.ENDM

;
; Define the following symbol to allow controller I/O functions on the DMC.
;
;DMC_MODEM	= 0

;
; Define special CNF flags for each database
;

PLI_V_NEW	= CNF$V_FLG_MRK1	; New PLI being built for first time

;
; OWN STORAGE
;

	.PSECT	NET_PURE,NOWRT,NOEXE,LONG

;
;  The following macroes build a conversion table for formatting counters
;  into NICE format.  Each counter i.d. contain is bit encoded to contain
;  formatting information as follows:
;
;   15   14    13  12   11	    0		Bit
;
;  < 1 >< width >< 0 >< counter i.d. >		Field
;
;
	$WIDTH_B = 1	; Counter width specifier for bytes
	$WIDTH_W = 2	; Counter width specifier for words
	$WIDTH_L = 3	; Counter width specifier for longwords

NET$C_NMACNT_SLZ = <1@15>!<<$WIDTH_W>@13>!0	; Seconds since last zeroed

.MACRO $COUNT_ENT  base,nice,pre,mod,count,width; Insert table entry
						;
	.WORD	<1@15>!<<$WIDTH_'width'>@13>!-	; Counter flag, Counter width
		<NMA$C_'nice'_'count'>		; Nice counter i.d.
	.WORD	'pre'$'width'_'mod''count' -	; Offset into internal structure
		- base				; minus internal structure base
.ENDM	$COUNT_ENT				;


.MACRO	$COUNT_TAB  base,nice,pre,mod,list	; Create counter formatting table
						;
	.IRP	A,<list>			;
		$COUNT_ENT  base,nice,pre,mod,A	; Insert table entry
	.ENDR					;
						;
	.LONG	0				; Terminate the table

.ENDM	$COUNT_TAB
	

LPD_CNT_TAB:			; Circuit counter formatting table

    $COUNT_TAB	LPD$L_ABS_TIM,CTCIR,LPD,CNT_,-
		<-
		<APR,L>,-	; Arriving packets received	
		<DPS,L>,-	; Departing packets sent
		<ACL,W>,-	; Arriving congestion loss
		<TPR,L>,-	; Transit packets received
		<TPS,L>,-	; Transit packets sent
		<TCL,W>,-	; Transit congestion loss
		<LDN,B>,-	; Line down events
		<IFL,B>,-	; Initialization failures
    >

X25_CNT_TAB:			; X.25 native circuit counter formatting table

    $COUNT_TAB	,,,,		; Currently only "seconds since last zeroed"
				; is maintained outside PSIACP

PLI_CNT_TAB:			; Line counter formatting table

    $COUNT_TAB	,,,,		; Currently only "seconds since last zeroed"
				; is maintained outside the driver


;
;  Build a table to driver the translation between Network Management (NICE)
;  device names to VMS devices names and to supply miscellaneous information
;  about known devices
;
NMA$C_LINPR_ = -1			; Define protocol type for protocols
					; not defined by the NICE protocol

MAX_C_DEVNAM = 15			; Maximum device name string
					; (dev-c-u.t)

.MACRO	.devtrn	netman,vms,type,prot,char	; Create table entry

	$$devtrn = .			; Remember where we are
	.ascic	"NETMAN"		; Enter Net Man device mnemonic
	. = $$devtrn + devtrn$b_vms	; Advance to next field
	.ascic	"VMS"			; Enter VMS device mnemonic
	. = $$devtrn + devtrn$b_dev	; Advance to next field
	.byte	devtrn$c_dev_'TYPE'
	. = $$devtrn + devtrn$b_prot	; Advance to next field
	.byte	nma$c_linpr_'PROT'	; Enter default protocol type
	. = $$devtrn + devtrn$b_char	; Advance to device characteristics
	.if nb,char			; Enter device characteristics
		.byte	devtrn$m_'CHAR'
	.iff
		.byte	0
	.endc
	. = $$devtrn + devtrn$c_length	; Advance to next table entry

.ENDM	.devtrn

DEVTRN_TABLE:				; Device translation table

	.devtrn	<DMC>, <XM>, <DMC>, <POI>, <>		; DMC-11
	.devtrn	<DMP>, <XD>, <DMP>, <POI>, <>		; DMP-11
	.devtrn	<PCL>, <XP>, <PCL>, <MAS>, <>		; PCL-11
	.devtrn	<DMF>, <XG>, <DMF>, <POI>, <>		; DMF-11 (combo board)
	.devtrn <CI>,  <CN>, <CI>,  <>,    <>		; CI-780
	.devtrn	<UNA>, <XE>, <UNA>, <NI>,  <>		; UNA (Ethernet)
	.devtrn	<PPUNA>,<_XE>,<PPUNA>,<POI>, <MULTI>	; "point-to-point" UNA
							; (internal only)
	; "_XE" must be used to distinguish PPUNA datalinks from UNA datalinks,
	; since they both use the same driver, and since matching of lines and
	; and circuits is done by the VMS device name given here.
	.devtrn	<QNA>, <XQ>, <UNA>, <NI>,  <>		; QNA (Ethernet)
	.devtrn	<UE>,  <XX>, <UNA>, <NI>,  <>		; 3COM UE (Ethernet)
	.devtrn	<DUP>, <>,   <DUP>, <LAPB>, <>		; DUP-11 (for X.25)
	.devtrn	<DPV>, <>,   <DUP>, <LAPB>, <>		; DPV-11 (for X.25)
	.devtrn	<KMX>, <>,   <KMS>, <LAPB>, <MULTI>	; KMS-11 (for X.25)
	.devtrn <KMY>, <>,   <KMS>, <LAPB>, <>		; KMS-11 (for X.25)
	.devtrn	<KMV>, <>,   <KMS>, <LAPB>, <>		; KMV-11 (for X.25)
	.devtrn <X25>, <NW>, <X25>, <>,    <>		; X25 DLM circuits
	.devtrn	<>,    <>,   <UNK>, <>,    <MULTI>	; Terminate the table
							; with foreign device
	.ALIGN	LONG

;
;  The following tables contain a list of parameters which need to be cleared
;  in a given (PLI or CRI) CNF block before that block is process for a "show"
;  QIO.  The reason for this is that the parameters are maintained only by the 
;  device driver and the copy of this information stored in the CNF is stale.
;
PLI_CLR_TAB:	.CNFFLD	pli,s,mcd	; X.25 microcode dump file [write only]
		.LONG	0		; Terminate the table

CRI_CLR_TAB:	.CNFFLD	cri,l,pls	; Polling sub-state
		.LONG	0		; Terminate the table

;
; The following table lists those CRI parameters which must be processed by
; PSIACP if the circuit is of TYPE X25.  This table is used to build
; a control QIO to send the parameters to PSIACP.  PSIACP only needs to "know"
; about the parameters listed in this table.
;

CRI_PSI_TAB:
	.CNFFLD	cri,l,STA	; State
	.CNFFLD	cri,l,USE	; Circuit usage
	.CNFFLD	cri,l,TYP	; Circuit type
	.CNFFLD	cri,l,CHN	; Channel
	.CNFFLD	cri,l,MBL	; Maximum data
	.CNFFLD	cri,l,MWI	; Maximum window
	.CNFFLD	cri,s,DTE	; DTE

	.LONG	0		; Terminate table
CRI_PSI_SIZ = . - CRI_PSI_TAB

;
; The following table lists those PLI parameters which must be processed by
; PSIACP if the line is using PROTOCOL LAPB.  This table is used to build
; a control QIO to send the parameters to PSIACP.  PSIACP only needs to "know"
; about the parameters listed in this table.
;

PSI_PLI_CLR_TAB:		; Params cleared before every SET function
	.CNFFLD	pli,l,sub	; Line substate
	.LONG	0		; Terminate the table

PLI_PSI_TAB:
	.CNFFLD	pli,v,DUP	; Duplex
	.CNFFLD	pli,v,CON	; Controller mode
	.CNFFLD	pli,l,STA	; State
	.CNFFLD	pli,l,SUB	; Substate [SHOW only]
	.CNFFLD	pli,l,PRO	; Protocol
	.CNFFLD	pli,l,HTI	; Holdback timer
	.CNFFLD	pli,l,MBL	; Maximum block
	.CNFFLD	pli,l,MRT	; Maximum retransmits
	.CNFFLD	pli,l,MWI	; Maximum window
	.CNFFLD	pli,l,BFN	; Receive buffers
	.CNFFLD	pli,l,RTT	; Retransmit timer
	.CNFFLD	pli,l,MOD	; X.25 mode (DCE, DTE, etc.)
	.CNFFLD	pli,s,MCD	; Microcode dump filespec  [SET only]

	.LONG	0		; Terminate table
PLI_PSI_SIZ = . - PLI_PSI_TAB

;
;  Build the tables which drive datalink QIO parameter translation.  The
;  datalink QIO parameter buffers are stored in NICE protocol format.
;
CNVTAB$C_INTRNL = ^X3FFF		; Index = INTRNL means datalink only

$VIELD	CNVTAB,0,<-			; Define conversion table enter
		  <NMA,12,M>,-		; NICE protocol param i.d.
		  <RO,1,M>,-		; Read-only flag
		  <,3>,-		; 3 spare bits
		  <INT,14,M>,-		; Internal parameter index
		  <FMT, 2,M>,-		; Parameter format (string,value,etc)
	>

.MACRO	.cnvtab	nma,db,param,readonly=0	; Insert parameter i.d. table entry

	.LONG   <<nma$c_'nma'_'param'>            @ <cnvtab$v_nma>> -
	      + <'readonly'			  @ cnvtab$v_ro> -
	      + <<nfb$c_'db'_'param' & nfb$m_inx> @ <cnvtab$v_int-nfb$v_inx>> -
	      + <<nfb$c_'db'_'param' & nfb$m_typ> @ <cnvtab$v_fmt-nfb$v_typ>> 
.ENDM

.MACRO	.inttab	nma,typ,param		; Describe internal NMA codes
					; returned by datalink drivers
	.LONG	<nma$c_'nma'_'param'		  @ cnvtab$v_nma> -
	      + <cnvtab$c_intrnl		  @ cnvtab$v_int> -
	      + <nfb$c_typ_'typ'		  @ cnvtab$v_fmt>
.ENDM

CRI_TRN_TAB:			; NICE-internal param i.d. translation
	.cnvtab	pcci,cri,POL	; Polling state
	.cnvtab	pcci,cri,PLS,1	; Polling sub-state  [READ ONLY]
	.cnvtab	pcci,cri,TYP,1	; Protocol type  [READ ONLY]
	.cnvtab	pcci,cri,TRI	; Tributary station address
	.cnvtab	pcci,cri,BBT	; Babbel timer
	.cnvtab	pcci,cri,TRT	; Transmit timer
	.cnvtab	pcci,cri,MRB	; Maximum receive buffers
	.cnvtab	pcci,cri,MTR	; Maximum transmits
	.cnvtab	pcci,cri,ACB	; Active base
	.cnvtab	pcci,cri,ACI	; Active increment
	.cnvtab	pcci,cri,IAB	; Inactive base
	.cnvtab	pcci,cri,IAI	; Inactive increment
	.cnvtab	pcci,cri,IAT	; Inactive threshold
	.cnvtab	pcci,cri,DYB	; Dying base
	.cnvtab	pcci,cri,DYI	; Dying increment
	.cnvtab	pcci,cri,DYT	; Dying threshold
	.cnvtab	pcci,cri,DTH	; Dead treshold
	.cnvtab	pcci,cri,MST	; Maintenance mode state

	.LONG	0		; Terminate the table


PLI_TRN_TAB:			; NICE-internal param i.d. translation
	.cnvtab	pcli,pli,BUS	; Receive buffer size
	.cnvtab	pcli,pli,DUP	; Duplex mode
	.cnvtab	pcli,pli,CON	; Controller (loopback) mode
	.cnvtab	pcli,pli,CLO	; Clock mode
	.cnvtab	pcli,pli,PRO	; Protocol
	.cnvtab	pcli,pli,SLT	; Scheduling timer
	.cnvtab	pcli,pli,DDT	; Dead timer
	.cnvtab	pcli,pli,DLT	; Delay timer
	.cnvtab	pcli,pli,SRT	; Stream timer
	.cnvtab	pcli,pli,BFN	; Number of buffers in pool
	.cnvtab	pcli,pli,RTT	; Retransmit timer
	.cnvtab	pcli,pli,HWA,1	; UNA hardware address  [READ ONLY]

	.LONG	0		; Terminate the table


	.PSECT	NET_IMPURE,WRT,NOEXE

PLI_B_STATE:	.BLKB	1		; Device state
PLI_Q_DEVNAM:	.QUAD	0		; Device name descriptor

DEVNAM_C_SIZ = 32			; Size of SEARCH key buffer
					; for line and circuit names

SRCH_BUF:	.BLKB	DEVNAM_C_SIZ	; Optional SEARCH KEY buffer

QIOW_Q_IOSB:	.QUAD	0		; General QIOW IOSB
QIOW_W_RETLEN:	.BLKW	1		; Return length word for PSI QIOW
TMP_Q_DESC:	.QUAD	0		; Scratch descrirptor

	.PSECT	NET_CODE,NOWRT,EXE

	.SBTTL	NET$SCAN_xxx - Scan database
;+
; NET$SCAN_CRI - Scan CRI database
; NET$SCAN_PLI - Scan PLI database
;
; This co-routine is used to scan the database, and return to the caller
; (co-routine) for each entry in the database.  These routines establish
; the order of the database entries, above that of the natural ordering of
; the collating field.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of starting CNF (or 0 if to start at the beginning)
;
; Outputs:
;
;	R10 = Address of CNF if dialogue aborted prematurely, else 0.
;
; The caller receives control on each database entry in list (via co-routine
; call).
;
; On input to co-routine:
;
;	R0 = True if entry was found.  False if at end of list (R10 invalid)
;	R10 = Address of CNF entry found
;
; On output from co-routine:
;
;	R0 = CNF$_ADVANCE	Advance to next CNF, continue dialogue
;	     CNF$_TAKE_PREV	Return previous CNF, abort dialogue
;	     CNF$_TAKE_CURR	Return current CNF, abort dialgoue
;	     CNF$_QUIT		Return no CNF (R10 = 0), abort dialogue
;
;  ***  These routines must be abortable via a RET  ***
;---

NET$SCAN_CRI::
NET$SCAN_PLI::
	BRW	DEFAULT_SCAN	; Use default scanner with collating field

	.SBTTL	NET$PRE_QIO_xxx - Pre-QIO processing
;+
; NET$PRE_QIO_CRI - Perform pre-QIO CRI database processing
; NET$PRE_QIO_PLI - Perform pre-QIO PLI database processing
;
; This routine is called just after validating the NFB for a database
; function to do any special pre-processing before the request is attempted.
;
; Here, for CRI and PLI databases, we reformat the search key into a standard
; format for line and circuit names, so that we don't get two database entries
; for DMC-0 and DMC-0.0, which should refer to the same entry.
;
; Inputs:
;
;	R11 = Address of CNR
;	NET$GQ_SRCH_KEY = Descriptor of search key value
;	NET$GL_SRCH_ID = Field ID of search field.
;	NET$GQ_SRCH2_KEY = Descriptor of secondary search key value
;	NET$GL_SRCH2_ID = Field ID of secondary search field.
;
; Outputs:
;
;	NET$GQ_SRCH_KEY = Reformatted search key value
;	NET$GQ_SRCH2_KEY = Reformatted secondary search key value
;---

NET$PRE_QIO_CRI::			;
	$CNFFLD	cri,s,nam,R9		; Get circuit name field i.d.
	BRB	PREQIO_PRI_CRI		; Continue in common

NET$PRE_QIO_PLI::			;
	$CNFFLD	pli,s,nam,R9		; Get line name field i.d.
					; Fall thru to common code
PREQIO_PRI_CRI:
	;
	;   Rebuild SEARCH key if needed
	;
	CMPL	R9,NET$GL_SRCH_ID	; Is the SEARCH key the name?
	BNEQ	10$			; If NEQ no
	MOVQ	NET$GQ_SRCH_KEY,R7	; Get the SEARCH KEY descriptor
	MOVAB	SRCH_BUF,R3		; Point to the SEARCH KEY buffer
	MNEGL	R3,NET$GQ_SRCH_KEY	; Prepare for size calculation
	MOVL	R3,NET$GQ_SRCH_KEY+4	; Point to new SEARCH KEY string
	BSBW	REBUILD_NAME		; Rebuild the circuit name
	BLBC	R0,210$			; If LBC then error in name
	ADDL	R3,NET$GQ_SRCH_KEY	; Calculate size of the string
	;
	;   Rebuild secondary SEARCH key if needed
	;
10$:	CMPL	R9,NET$GL_SRCH2_ID	; Is the secondary SEARCH key the name?
	BNEQ	100$			; If NEQ no
	MOVQ	NET$GQ_SRCH2_KEY,R7	; Get the secondary search key descriptor
	MOVAB	SRCH_BUF,R3		; Point to the SEARCH KEY buffer
	MNEGL	R3,NET$GQ_SRCH2_KEY	; Prepare for size calculation
	MOVL	R3,NET$GQ_SRCH2_KEY+4	; Point to new SEARCH KEY string
	BSBW	REBUILD_NAME		; Rebuild the circuit name
	BLBC	R0,210$			; If LBC then error in name
	ADDL	R3,NET$GQ_SRCH2_KEY	; Calculate size of the string
100$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
210$:	RSB				; Return status in R0


REBUILD_NAME:				; Rebuild the name to canonical form
	;
	;   Rebuild the device name so that it is of the form:
	;
	;    	'dev-c-u.t'  or  'dev-c-u'     for multiplexed device types
	;
	;	'dev-c.t'    or  'dev-c'       for non-multiplexed device types
	;
	;
	;
	CMPL	R7,#DEVNAM_C_SIZ	; Output name will be LEQ input name,
	BGTRU	40$			; If GTRU unsigned then may oveflow buf
	;
	;   Move the device mnemonic and locate the device table entry
	;
	BSBW	PRS_MNEMONIC		; Parse name, locate the table entry
	BLBC	R0,40$			; If LBC the error
	MOVC3	R5,(R4),(R3)		; Enter the Net. Man. device mnemonic
	;
	;   If the name is of the form "X25-xxx", then allow any remaining
	;   characters to be accepted as is.  The user must make sure that
	;   the name is spelled exactly the same for all requests.
	;
	CMPB	DEVTRN$B_DEV(R6),#DEVTRN$C_DEV_X25 ; X.25 circuit name?
	BNEQ	1$			; Branch if not
	MOVB	#^A"-",(R3)+		; Move delimiter
	MOVC	R7,(R8),(R3)		; Copy in rest of name
	BRW	90$			; Exit successfully
1$:	;
	;   Move the controller i.d. -- suppress leading zeroes.  If the device
	;   is not a "MULTI-plexed" device then the units field may not be
	;   present and the name may be end with the controller specifier field
	;   or it may end with either the units field or the tributary field or
	;   both.  If the device is "MULTI-plexed" then the name must contain
	;   at least the units field following the controller specifier field.
	;
	MOVZBL	#^A"-",R4		; Setup the field delimiter
	MOVB	R4,(R3)+		; Enter it into the output buffer
	BBS	#DEVTRN$V_MULTI,-	; If BS then multi-unit device
		 DEVTRN$B_CHAR(R6),10$	;
	MOVQ	R7,R0			; Copy string descriptor
5$:	DECL	R0			; Any characters left
	BLSS	10$			; If LSS then no
	CMPB	#^A"-",(R1)		; Delimited by a "-" ?
	BEQL	10$			; If EQL yes
	CMPB	#^A".",(R1)+		; Delimited by a "." ?
	BNEQ	5$			; If NEQ then keep trying
	MOVZBL	#^A".",R4		; Reset delimiter for parse
10$:	BSBW	PRS_DECIMAL		; Get binary value of controller
	BLBC	R0,40$			; If LBC then error
	TSTL	R2			; Any decimal characters parsed?
	BEQL	40$			; If EQL no, error in name
	MOVL	R1,R0			; Setup binary value to be converted
	BSBW	NET$BIN2ASC		; Convert to ascii and insert
	;
	;   Move the unit number  -- suppress leading zeros.
	;
	BBS	#DEVTRN$V_MULTI,-	; If BS then multi-unit device
		 DEVTRN$B_CHAR(R6),50$	;
	;
	;   Single unit device -- verify unit number is zero but don't move it
	;
	CMPB	#^A".",R4		; Did we already rule out a unit field?
	BEQL	70$			; If EQL then yes
	MOVZBL	#^A".",R4		; Setup the field delimiter
	BSBW	PRS_DECIMAL		; Get binary unit number
	BLBC	R0,100$			; If LBC then error
	TSTL	R1			; Single unit device, is it unit 0?
	BEQL	70$			; If EQL yes, process tributary field
40$:	BRB	100$			; Else error in name
50$:	;				
	;   Device is a multi-unit device, move unit number field
	;
	MOVB	#^A"-",(R3)+		; Enter prefix to unit number field
	MOVZBL	#^A".",R4		; Setup the field delimiter
	BSBW	PRS_DECIMAL		; Get binary unit number
	BLBC	R0,100$			; If EQL then error
	TSTL	R2			; Any decimal characters parsed?
	BEQL	100$			; If EQL then error
	MOVL	R1,R0			; Get binary value for ascii conversion
	BSBW	NET$BIN2ASC		; Move as ascii @R3
70$:	;
	;   Process the tributary field.  If this is the CRI database then move
	;   the remainder of the name (unfortunately we cannot determine if a
	;   tributary specifier is valid for this device yet since we cannot 
	;   determine for sure if the device is to be run in the multi-drop or
	;   point-to-point mode until later on in the QIO cycle).
	;
	CMPB	#NFB$C_DB_CRI,-		; Circuit database ?
		    CNR$B_TYPE(R11)	; 
	BEQL	80$			; If EQL yes
	TSTL	R7			; Else there must be no characters left
	BNEQ	100$			; If NEQ then illegal name
80$:	TSTL	R7			; Any characters left?
	BEQL	90$			; If EQL no, return success
	MOVB	#^A".",(R3)+		; Enter delimiter
	MOVC3	R7,(R8),(R3)		; Enter remaining characters, update R3
90$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	BRB	110$			; Take common exit

100$:	MOVZWL	#SS$_IVDEVNAM,R0	; Indicate invalid device name
110$:	RSB				; Return status in R0

	.SBTTL	NET$SHOW_xxx - Pre-SHOW processing
;+
; NET$SHOW_CRI - Show QIO pre-processing for CRI database
; NET$SHOW_PLI - Show QIO pre-processing for PLI database
;
; This routine is called for each CNF which is about to be returned
; to a "show" QIO.  For the CRI and PLI databases, we must "update"
; the fields reflecting datalink driver status, by issuing a SENSEMODE
; QIO to the driver, and taking it's current values for datalink parameters
; and storing them into the CNF.  This makes both the CNF and the driver
; consistent.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code
;
;	The CNF may be updated.
;-

NET$SHOW_CRI::				; "Show" QIO pre-processing for one CNF
	MOVAB	CRI_CLR_TAB,R5		; Get table of params to clear
	BSBW	CLEAR_VOLATILE		; Clear volatile parameters
	;
	;   If this is an X.25 circuit, then ask PSI for its parameter values
	;
	$GETFLD	cri,l,typ		; Get type of circuit
	BLBC	R0,5$			; Branch if not set
	CMPL	R8,#NMA$C_CIRTY_X25	; X.25 circuit?
	BNEQ	5$			; Branch if not
	BRW	GET_PSI_CRI		; Get current PSI parameter values
	;
	;   Issue SENSEMODE to driver, and store results in CRI
	;
5$:	BSBW	NET$LOCATE_LPD		; Get LPD associated with this CRI
	BLBC	R0,10$			; If EQL then none
	MOVZBL	LPD$B_PLVEC(R6),R8	; Get PLVEC index
	BEQL	10$			; Skip if none assigned
	MOVZWL	LPD$W_CHAN(R6),R3	; Get I/O channel
	MOVZWL	#IO$_SENSEMODE,R4	; Get I/O function code
	MOVAB	CRI_TRN_TAB,R6		; Get table for NICE param translation
	BRB	SHO_PLI_CRI		; Pre-process the CRI CNF block

10$:	MOVL	#1,R0			; Report success - return parameters
	RSB

NET$SHOW_PLI::				; "Show" QIO pre-processing for one CNF
	MOVAB	PLI_CLR_TAB,R5		; Get table of params to clear
	BSBW	CLEAR_VOLATILE		; Clear volatile parameters
	;
	; If this is a LAPB line, ask PSIACP for it's parameter values
	;
	$GETFLD	pli,l,pro		; Get protocol parameter value
	BLBC	R0,5$			; If not specified, skip it
	CMPL	R8,#NMA$C_LINPR_LAPB	; LAPB line?
	BNEQ	5$			; Branch if not
	BRW	GET_PSI_PLI		; Get current PSI PLI parameter values
	;
	;   Ask the datalink driver for it's parameter values
	;
5$:	MOVZWL	CNF$W_ID(R10),R0	; Get PLVEC index
	BEQL	10$			; If EQL then none assigned
	MOVW	PLVEC$AW_CHAN[R0],R3	; Get I/O channel
	MOVW	#IO$_SENSEMODE!IO$M_CTRL,R4 ; Get QIO function code
	MOVAB	PLI_TRN_TAB,R6		; Get table for NICE param translation
	BRB	SHO_PLI_CRI

10$:	MOVL	#1,R0			; Report success - return parameters
	RSB

SHO_PLI_CRI:
	;
	;   Get a list of parameters from the driver
	;
	CLRQ	QIOW_Q_IOSB		; Init IOSB image
	$QIOW_S	-			; Issue QIO to get device info
		EFN  = #NET$C_EFN_WAIT,-
		CHAN = R3,-
		FUNC = R4,-
		IOSB = QIOW_Q_IOSB,-
		P2   = #TMPBUF_DESC	
	BLBC	R0,100$			; If LBC assume unsupported by driver
	BLBC	QIOW_Q_IOSB,100$	; If LBC assume unsupported by driver
	BBC	#XM$V_STS_ACTIVE,QIOW_Q_IOSB+4,100$ ; Skip if datalink not active
	MOVL	TMPBUF_DESC+4,R4	; Point to parameter list
	BSBB	JAM_CNF			; Stuff the params into the CNF block
	BRB	110$			; Take common exit
100$:	MOVL	#1,R0			; Report success
110$:	RSB				; Return status in R0

	.SBTTL	JAM_CNF - Store driver values into CNF
;+
; JAM_CNF - Store datalink driver parameters into CNF
;
; This routine updates the CNF with the latest and greatest parameter
; values from the datalink driver.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R6 = Address of datalink-NICE translation table
;	R4 = Address of buffer returned by SENSEMODE
;	QIOW_Q_IOSB = IOSB from SENSEMODE operation
;
; Outputs:
;
;	R0 = Status code
;-
	.ENABL	LSB

JAM_CNF:
	PUSHL	NET$GL_FLAGS		; Save current flags
	CLRBIT	NET$V_CNFLCK,NET$GL_FLAGS ; Allow update of cond. write fields
	;
	;   Jam the values from the QIO buffer one at time into the CNF block.
	;
10$:	TSTW	QIOW_Q_IOSB+2		; Any params left?
	BEQL	110$			; If EQL we're done
	BSBB	TAKE_2_IOSB		; See if we have two bytes left
	MOVZWL	(R4)+,R9		; Get NICE protocol param i.d. + type
	MOVL	R6,R5			; Point to translation table
	BSBW	CVT_NMA_INT		; Convert NMA i.d. to internal i.d.
	BLBC	R0,70$			; If LBC then not found
	CMPZV	#NFB$V_TYP,#NFB$S_TYP,R9,#NFB$C_TYP_STR	; Is it a string ?
	BEQL	50$			; If EQL yes
	;
	;   It's a longword
	;
	MOVL	#4,R7			; We'll take 4 more bytes
	BSBB	TAKE_R7_IOSB		; Deplete IOSB count
	MOVL	(R4)+,R8		; Get the value
	BRB	60$			; Continue
	;
	;   It's a string
	;
50$:	BSBB	TAKE_2_IOSB		; Account for count field
	CVTWL	(R4)+,R7		; Get string size
	BLSS	120$			; If LSS then string is too long
	MOVL	R4,R8			; Point to string
	ADDL	R7,R4			; Skip over it
	BSBB	TAKE_R7_IOSB		; Deplete bytes for string
60$:	CMPW	R9,#CNVTAB$C_INTRNL	; Datalink only parameter?
	BEQL	10$			; If so, just ignore it
	BSBW	CNF$PUT_FIELD		; Store it in the CNF
					; Ignore errors - field might be R/O
	BRB	10$			; Loop through all parameters
	;
	;  Parameter is not found in tables, skip it if present in buffer
	;
70$:	TSTW	QIOW_Q_IOSB+2		; Deplete bytes
	BBS	#12,R9,80$		; Br if string value
	;
	;	It's a longword
	;
	MOVL	#4,R7			; We'll take 4 more bytes
	BSBB	TAKE_R7_IOSB		; Deplete IOSB count
	ADDL	#4,R4			; Skip valued parameter
	BRW	10$			; Get rest of buffer
	;
	;	It's a string
	;
80$:	BSBB	TAKE_2_IOSB		; Account for count field
	CVTWL	(R4)+,R7		; Get string size
	BLSS	120$			; If LSS then string is too long
	ADDL	R7,R4			; Skip over it
	BSBB	TAKE_R7_IOSB		; Deplete bytes for string
	BRW	10$			; Get rest of buffer

100$:	POPL	NET$GL_FLAGS		; Restore flags
	RSB				; Return status in R0

110$:	MOVL	#1,R0			; Return success
	BRB	100$

120$:	MOVZWL	#SS$_RESULTOVF,R0	; Indicate buffer error
	BRB	100$

TAKE_2_IOSB:
	MOVZWL	#2,R7			; Setup bytes to take
TAKE_R7_IOSB:
	SUBW	R7,QIOW_Q_IOSB+2	; Deplete bytes
	BGEQ	200$			; If GEQ then okay
	TSTL	(SP)+			; Pop caller's return address
	BRB	120$			; Exit with buffer error
200$:	RSB

	.DSABL	LSB

	.SBTTL	GET_PSI_xxx - Get current PSI parameter values
;+
; GET_PSI_CRI - Get current PSI circuit parameter values
; GET_PSI_PLI - Get current PSI line parameter values
;
; This routine is called to get the current PSI parameter values
; from it's database, and store them in ours, so the SHOW function returns
; the sum of both databases.
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;
; Outputs:
;
;	R0 = status
;-
GET_PSI_CRI:
	;
	;   If this is a PVC, then go ahead and ask PSI.  If it's a
	;   incoming or outgoing SVC, then don't bother, since PSI
	;   doesn't know anything about them.
	;
	$GETFLD	cri,l,use		; Get USAGE parameter
	BLBC	R0,5$			; Branch if not set - defaulting error
	CMPL	R8,#NMA$C_CIRUS_PER	; PVC?
	BEQL	10$			; If not, then exit successfully
5$:	MOVL	#1,R0			; Do nothing
	RSB
	;
	;   Issue a SHOW function to PSI for its circuit parameters
	;
10$:	$CNFFLD	cri,s,nam,R9		; Set field ID of circuit name
	BSBW	SEND_TO_PSI		; Call co-routine to setup NFB, etc.
	BLBC	R0,90$			; Branch if error detected
	MOVB	#NFB$C_FC_SHOW,NFB$B_FCT(R6) ; Set function code
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	ASSUME	NFB$C_ENDOFLIST EQ 0	; NFB terminator and PSI_TAB are same
	MOVC	#CRI_PSI_SIZ,CRI_PSI_TAB,(R2)  ; Copy in the field IDs
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	MOVAB	CRI_PSI_SIZ(R2),R2	; Increment field ID list pointer
	ADDL	#P4BUF_SIZE,R3		; Set size of P4 return buffer
	JSB	@(SP)+			; Call SEND_TO_PSI back to issue QIO
	BLBS	R0,STORE_PSI_PARAMS	; Branch if ok
90$:	RSB				; Return with error

GET_PSI_PLI:
	;
	;   Issue a SHOW function to PSI for its line parameters
	;
	$CNFFLD	pli,s,nam,R9		; Set field ID of circuit name
	BSBW	SEND_TO_PSI		; Call co-routine to setup NFB, etc.
	BLBC	R0,90$			; Branch if error detected
	MOVB	#NFB$C_FC_SHOW,NFB$B_FCT(R6) ; Set function code
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	ASSUME	NFB$C_ENDOFLIST EQ 0	; NFB terminator and PSI_TAB are same
	MOVC	#PLI_PSI_SIZ,PLI_PSI_TAB,(R2)  ; Copy in the field IDs
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	MOVAB	PLI_PSI_SIZ(R2),R2	; Increment field ID list pointer
	ADDL	#P4BUF_SIZE,R3		; Set size of P4 return buffer
	JSB	@(SP)+			; Call SEND_TO_PSI back to issue QIO
	BLBS	R0,STORE_PSI_PARAMS	; Branch if ok
90$:	RSB				; Return with error

STORE_PSI_PARAMS:
	;
	;   Copy the parameters returned by PSI into our database
	;
	MOVQ	R7,R4			; Make copy of result descriptor
	MOVAB	NFB$L_FLDID(R6),R6	; Point to field ID list
	PUSHR	#^M<R9>			; Save registers
	PUSHL	NET$GL_FLAGS		; Save ACP flags
	CLRBIT	NET$V_CNFLCK,NET$GL_FLAGS ; Allow update of cond. write fields
20$:	MOVL	(R6)+,R9		; Get next field ID
	BEQL	80$			; Branch if end of list
	CMPZV	#NFB$V_TYP,#NFB$S_TYP,R9,#NFB$C_TYP_STR ; Is it a string?
	BEQL	30$			; Branch if so
	SUBL	#4,R4			; Decrement buffer space left
	BLSS	70$			; Branch if not enough space returned
	MOVL	(R5)+,R8		; Get longword value
	BLSS	20$			; Branch if "cleared"
	BRB	50$			; Store paramter
30$:	SUBL	#2,R4			; Decrement space left
	BLSS	70$			; Branch if not enough space returned
	MOVZWL	(R5)+,R7		; Get length of string
	BEQL	20$			; Branch if "cleared"
	SUBL	R7,R4			; Decrement space left
	BLSS	70$			; Branch if not enough space returned
	MOVL	R5,R8			; Point to start of string
	ADDL	R7,R5			; Skip past string
50$:	BSBW	CNF$PUT_FIELD		; Store the parameter
	BRB	20$			; Loop thru all parameters

70$:	MOVZWL	#SS$_RESULTOVF,R0	; Set overflow status
	BRB	90$

80$:	MOVL	#1,R0
90$:	MOVL	R0,R1			; Save final status
	POPL	NET$GL_FLAGS		; Restore ACP flags
	POPL	R0			; Point to scratch storage
	JSB	NET$DEALLOCATE		; Deallocate SHOW buffer
	MOVL	R1,R0			; Restore final status
	RSB

	.SBTTL	CLEAR_VOLATILE - Clear list of volatile parameters
;+
; CLEAR_VOLATILE - Clear list of volatile parameters from a CNF
;
; This routine is called with a list of parameters to be cleared so
; that stale data is not kept in a CNF block.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R5 = Address of list of longword parameter IDs
;
; Outputs:
;
;	None
;-
CLEAR_VOLATILE:
10$:	MOVL	(R5)+,R9		; Get next parameter i.d.
	BEQL	20$			; If EQL then none left
	BSBW	CNF$CLR_FIELD		; Clear param in CNF, ignore errors
	BRB	10$			; Loop
20$:	RSB

	.SBTTL	NET$DEFAULT_CRI - Apply default values
;+
; NET$DEFAULT_CRI  -  Apply default values to selected CNF parameters.
;
; This routine is called by CNF$INSERT just prior to validating a CNF
; entry which is to be inserted into the database.  Its purpose is to
; supply default values to selected parameters.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R0	Status code.
;
;		All other registers contain garbage.
;-
NET$DEFAULT_CRI::
	BSBW	NET$APPLY_DFLT		; Apply standard table defaults
	$GETFLD	cri,s,nam		; Get descriptor of circuit name
	BSBW	PRS_MNEMONIC		; Locate the table entry
	BLBC	R0,10$			; If not found, assume DDCMP
	;
	;   If the circuit type is not specified yet, and the name is of
	;   the form X25-x, then apply the default X25 circuit parameters
	;   (including setting it's type to "X25").
	;
	CMPB	DEVTRN$B_DEV(R6),#DEVTRN$C_DEV_X25 ; Is circuit X25-x?
	BNEQ	10$			; If not, skip it
	MOVAB	NET$G_CRI_X25,R6	; Get address of X25 circuit defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
	;
	;   If the USAGE is INCOMING or OUTGOING, then assume that
	;   the circuit is to be used for X.25 datalink mapping, since
	;   native users of X.25 circuits don't ever set incoming or
	;   outgoing circuits.
	;
	$GETFLD	cri,l,use		; Get USAGE parameter
	BLBC	R0,5$			; If not set, skip it
	$DISPATCH R8,<-			; Based on Usage,
		<NMA$C_CIRUS_INC,4$>-	; If incoming
		<NMA$C_CIRUS_OUT,4$>>	; or outgoing, then set DLM on
	BRB	5$			; Else, skip it
4$:	MOVL	#1,R8			; Set "true"
	$PUTFLD	cri,v,dlm		; Enable X.25 datalink mapping
	;
	;   If X.25 datalink mapping is enabled, then apply the Transport
	;   defaults.
	;
5$:	$GETFLD	cri,v,dlm		; Is X.25 datalink mapping enabled?
	BLBC	R0,80$			; Branch if not
	BLBC	R8,80$
	MOVAB	NET$G_CRI_DLM,R6	; Get address of DLM defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
	$GETFLD	cri,l,use		; Get circuit usage
	CMPL	R8,#NMA$C_CIRUS_OUT	; Outgoing circuit?
	BNEQ	20$			; Skip if not
	MOVAB	NET$G_CRI_DLMOUT,R6	; Get address of outgoing DLM defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
	BRB	20$			; then apply Transport defaults
	;
	;   If it's a NI circuit, then apply the appropriate defaults
	;
10$:	CMPB	DEVTRN$B_DEV(R6),#DEVTRN$C_DEV_UNA ; Is it an NI circuit?
	BNEQ	15$			; If not, skip it
	MOVAB	NET$G_CRI_NI,R6		; Get address of NI circuit defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
	BRB	20$			; Apply Transport defaults as well
	;
	; For DDCMP circuits, apply another set of default values
	;
15$:	MOVAB	NET$G_CRI_DDCMP,R6	; Get address of DDCMP circuit defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
	;
	;   For circuits used by Transport, then apply the Transport defaults.
	;
20$:	MOVAB	NET$G_CRI_TRN,R6	; Get address of Transport defaults
	BSBW	NET$TABLE_DFLT		; Apply the default values
80$:	MOVL	#1,R0			; Return successful
	RSB

	.SBTTL	NET$DEFAULT_PLI - Apply default values
;+
; NET$DEFAULT_PLI  -  Apply default values to selected CNF parameters.
;
; This routine is called by CNF$INSERT just prior to validating a CNF
; entry which is to be inserted into the database.  Its purpose is to
; supply default values to selected parameters.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R0	Status code
;
;		All other registers contain garbage.
;-
NET$DEFAULT_PLI::
	BSBW	NET$APPLY_DFLT		; Apply standard table defaults
	$GETFLD	pli,s,nam		; Get descriptor of line name
	BSBW	PRS_MNEMONIC		; Locate the table entry
	BLBS	R0,10$			; If found, proceed
	RSB				; Else, not found
10$:	;
	;   If the protocol is not specified yet, stuff it's default value
	;   based on the line name nmemonic.
	;
	$GETFLD	pli,l,pro		; Was protocol explicitly specified?
	BLBS	R0,20$			; If so, don't change it
	MOVZBL	DEVTRN$B_PROT(R6),R8	; Get default protocol type
	CMPB	R8,#NMA$C_LINPR_	; Is there a default protocol?
	BEQL	20$			; Branch if not
	BSBW	CNF$PUT_FIELD		; Store the protocol into the CNF
	;
	;   Based on the type of line protocol, apply a different set of
	;   defaults for each type.
	;
20$:	CMPB	DEVTRN$B_DEV(R6),-	; Is this a "point-to-point" XE?
		#DEVTRN$C_DEV_PPUNA
	BEQL	50$			; If so, use NI defaults
	$GETFLD	pli,l,pro		; Get line protocol type
	BLBC	R0,80$			; If none, then no defaults
	$DISPATCH R8,<-			; Based on line protocol,
		<NMA$C_LINPR_POI,30$>-	; DDCMP Point-to-point
		<NMA$C_LINPR_CON,30$>-	; DDCMP Controller station
		<NMA$C_LINPR_TRI,30$>-	; DDCMP Tributary
		<NMA$C_LINPR_DMC,30$>-	; DDCMP DMC compatible mode
		<NMA$C_LINPR_LAPB,40$>-	; X.25 LAPB protocol
		<NMA$C_LINPR_NI,50$>>	; NI protocol
	BRB	80$			; If none of the above, then skip it
	;
	;   Apply DDCMP defaults
	;
30$:	MOVAB	NET$G_PLI_DDCMP,R6	; Get address of DDCMP defaults
	BSBW	NET$TABLE_DFLT		; Apply default values
	BRB	80$
	;
	;   Apply LAPB defaults
	;
40$:	MOVAB	NET$G_PLI_LAPB,R6	; Get address of LAPB defaults
	BSBW	NET$TABLE_DFLT		; Apply default values
	BRB	80$
	;
	;   Apply NI defaults
	;
50$:	MOVAB	NET$G_PLI_NI,R6		; Get address of NI defaults
	BSBW	NET$TABLE_DFLT		; Apply default tables
	;
	;   For NI lines, add the "hardware address" parameter at this time,
	;   so that there is enough space reserved in the CNF block for future
	;   replacements of the value by the datalink layer.  Initially, it
	;   will have the value of 6 bytes of binary zero.  This is done here
	;   because the defaulting tables don't handle string defaults.
	;
	CLRQ	-(SP)			; Zero 8 byte buffer
	MOVL	#6,R7			; Set length of string to 6 bytes
	MOVL	SP,R8			; Point to buffer of 8 null bytes
	$PUTFLD	pli,s,hwa		; Allocate space for NI hardware address
	ADDL	#8,SP			; Deallocate buffer
80$:	MOVL	#1,R0			; Return successful
90$:	RSB

	.SBTTL	NET$INSERT_CRI - Pre-insertion processing
;+
; NET$INSERT_CRI - Insert CRI entry into database
;
; This routine is called to validate a CRI CNF entry before inserting
; it into the database.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code.  If error, entry is not inserted.
;-
NET$INSERT_CRI::
	CLRL	-(SP)			; Scratch space on stack for STATE
	MOVZWL	#SS$_INSFARG,R0		; Set error if parameter not present
	$GETFLD cri,l,sta		; Get the operator state
	BLBS	R0,5$			; Error if not already defaulted
	BRW	200$			; Exit with status
5$:	MOVL	R8,(SP)			; Save new STATE value
	;
	;   If STATE=SERVICE, then make sure that SERVICE is ENABLED.
	;
	$GETFLD	cri,v,ser		; See if service functions are enabled
	BLBC	R0,10$			; Branch if parameter not set
	BLBC	R8,10$			; If LBC then "service" state is legal
	MOVL	#SS$_BADPARAM,R0	; Assume state is "service"
	CMPL	(SP),#NMA$C_STATE_SER	; Is it?
	BEQL	200$			; If so then conflicts with <cri,v,ser>
	;
	;   Make sure that the circuit name is valid
	;
10$:	CLRL	R0			; No default error status
	$GETFLD	cri,s,vmsnam		; Check if circuit name is valid
	BLBC	R0,200$			; If LBC then error
	;
	;   If the circuit type associated with this CNF is X25, then ship
	;   the X.25 specific circuit parameters to PSIACP via a control QIO.
	;   If the QIO succeeds, then allow the CNF to be inserted.  In
	;   either case, we do not perform any datalink processing.
	;
	$GETFLD	cri,l,typ		; Get circuit type
	BLBC	R0,25$			; If error, assume not X.25
	CMPL	R8,#NMA$C_CIRTY_X25	; X25 circuit?
	BEQL	28$			; Branch if so
25$:	PUSHL	R10			; Save pointer to current CNF
	MOVL	R6,R10			; Point to old version of CNF
	BEQL	26$			; Branch if none
	$GETFLD	cri,l,typ		; Get old circuit type
	BLBC	R0,26$			; If error, assume still not X.25
	CMPL	R8,#NMA$C_CIRTY_X25	; Did it used to be X25?
	BNEQ	26$			; Branch if not
	MOVZWL	#SS$_WRITLCK,R0		; Do not allow type change w/o CLEAR
	POPL	R10			; Restore current CNF
	RSB				; Return - do not allow insertion
26$:	POPL	R10			; Restore current CNF
	BRB	50$			; and allow Transport to use it

28$:	BSBB	CRI_TO_PSI		; Tell it to PSIACP
	BLBC	R0,200$			; Exit if error detected
	;
	;   For X.25 circuits, do not initialize the circuit if we haven't
	;   been granted ownership of it by the network manager.  This
	;   prevents the circuit from being used both by native mode X.25
	;   users and by Transport.
	;
29$:	$GETFLD	cri,v,DLM		; X.25 datalink mapping enabled?
	BLBC	R0,60$			; If not set, do not use this circuit
	BLBC	R8,60$			; If disabled, do not use this circuit
					; Call Transport to init circuit
	;
	;   Signal datalink control module that the CRI has been changed
	;
50$:	MOVL	(SP),R8			; Get STATE value
	BSBW	NET$DLL_OPR_SET		; Signal operator event
	BLBC	R0,200$			; If LBC then error
	;
	;   Start counter timer ticking
	;
60$:	BSBW	NET$SET_CTR_TIMER	; Reset automatic counter timer
	MOVL	#1,R0			; Indicate success
200$:	TSTL	(SP)+			; Cleanup the stack
	RSB				; Return status in R0

	.SBTTL	CRI_TO_PSI - Send CRI parameters to PSIACP
;+
; CRI_TO_PSI - Issue SET of CRI parameters to PSIACP
;
; Send the CRI parameters that PSIACP cares about via a ACP control QIO.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code
;-

CRI_TO_PSI:
	;
	;   Check if required parameters are present
	;
	MOVZWL	#SS$_INSFARG,R0		; Set error if parameter not present
	$GETFLD	cri,l,use		; Check if USAGE parameter specified
	BLBC	R0,90$			; If not, error - must be specified
	;
	;   If this is an incoming SVC, then make sure that NETACP is
	;   declared (to PSI) as being able to accept incoming calls
	;   since PSI might not have been up earlier to receive the
	;   declaration when the SUBADDRESS parameter was set.
	;
	CMPL	R8,#NMA$C_CIRUS_INC	; Incoming SVC?
	BNEQ	5$			; Branch if not
	PUSHR	#^M<R10,R11>		; Save registers
	MOVL	NET$GL_CNR_LNI,R11	; Get LNI root address
	MOVL	NET$GL_PTR_LNI,R10	; Get LNI CNF address
	BSBW	NET$DECLARE_PSI		; Declare ourselves to accept calls
	POPR	#^M<R10,R11>		; Restore registers
	BLBC	R0,90$			; Exit if error detected
5$:	;
	;   If this is a PVC, then go ahead and tell PSI.  If it's a
	;   incoming or outgoing SVC, then don't bother, since PSI
	;   doesn't need to know about them.
	;
	CMPL	R8,#NMA$C_CIRUS_PER	; PVC?
	BNEQ	90$			; If not, then exit successfully
	;
	;   Send the request to PSI
	;
	$CNFFLD	cri,s,nam,R9		; Set field ID of circuit name
	BSBW	SEND_TO_PSI		; Call co-routine to setup NFB, etc.
	BLBC	R0,90$			; Branch if error detected
	MOVB	#NFB$C_FC_SET,NFB$B_FCT(R6)	; Store function code
	MOVAB	CRI_PSI_TAB,R5		; Point to PSI circuit parameters
10$:	MOVL	(R5)+,R9		; Get next parameter ID
	BEQL	50$			; Branch if end of table
	BSBW	CNF$GET_FIELD		; Get the parameter value
	BLBC	R0,10$			; Skip it if it doesn't exist
	MOVL	R9,(R2)+		; Store into NFB
	CMPZV	#NFB$V_TYP,#NFB$S_TYP,-	; String or binary?
		R9,#NFB$C_TYP_STR
	BEQL	20$			; Branch if string
	MOVL	R8,(R3)+		; Store longword into P4 buffer
	BRB	10$
20$:	MOVW	R7,(R3)+		; Store string count word
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVC	R7,(R8),(R3)		; Store string text
	POPR	#^M<R2,R4,R5>		; Restore registers
	BRB	10$
50$:	JSB	@(SP)+			; Call SEND_TO_PSI back to issue QIO
90$:	RSB				; Return with status

	.SBTTL	NET$INSERT_PLI - Pre-insertion processing
;+
; NET$INSERT_PLI - Insert PLI entry into database
;
; This routine is called to validate a PLI CNF entry before inserting
; it into the database.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R6 = Address of previous version of CNF (zero if none)
;
; Outputs:
;
;	R0 = Status code
;-
NET$INSERT_PLI::
	;
	;   Get new value of STATE parameter.
	;
	$GETFLD pli,l,sta		; Get the operator state
	MOVB	R8,PLI_B_STATE		; Save state value
	;
	;   If the protocol associated with this CNF is LAPB, then ship
	;   the X.25 specific line parameters to PSIACP via a control QIO.
	;   If the QIO succeeds, then allow the CNF to be inserted.  In
	;   either case, we do not perform any PLVEC or datalink processing.
	;
	$GETFLD	pli,l,pro		; Get protocol type
	BLBC	R0,25$			; If error, assume not X.25
	CMPL	R8,#NMA$C_LINPR_LAPB	; LAPB protocol?
	BNEQ	25$			; Branch if not
	BSBW	PLI_TO_PSI		; If so, send it to PSIACP
	BLBC	R0,24$			; Branch if error detected
	BSBW	NET$SET_CTR_TIMER	; Start/reset automatic counter timer
	MOVL	#1,R0			; Set successful
24$:	RSB				; Exit with status
25$:	PUSHL	R10			; Save pointer to current CNF
	MOVL	R6,R10			; Point to old version of CNF
	BEQL	26$			; Branch if none
	$GETFLD	pli,l,pro		; Get old protocol type
	BLBC	R0,26$			; If error, assume still not X.25
	CMPL	R8,#NMA$C_LINPR_LAPB	; Did it used to be LAPB?
	BNEQ	26$			; Branch if not
	MOVZWL	#SS$_WRITLCK,R0		; Do not allow protocol change w/o CLEAR
	POPL	R10			; Restore current CNF
	RSB				; Return - do not allow insertion
26$:	POPL	R10			; Restore current CNF
	;
	;   Locate the PLVEC index for this PLI.  If there is none then
	;   assign and initialize a PLVEC entry for this PLI.
	;
	MOVZWL	CNF$W_ID(R10),R4	; Get i.d. (PLVEC index) of this entry
	BNEQ	30$			; If NEQ then its valid
	BSBW	ALLOC_PLVEC		; This is a new PLI, set it up
	BLBC	R0,29$			; If error then simply exit
	SETBIT	PLI_V_NEW,CNF$B_FLG(R10); Indicate PLVEC has been newly assigned
	MOVB	#NMA$C_STATE_OFF,-	; Init to "off" state
		    PLVEC$AB_STATE[R4]	; Setup an undefined state value
	;
	;   If this is an NI driver, then make sure that the executor
	;   type is Phase IV, since Phase III doesn't support
	;   broadcast circuits.
	;
	CMPB	PLVEC$AB_DEV[R4],#DEVTRN$C_DEV_UNA ; NI device?
	BNEQ	28$			; Branch if not
	MOVL	NET$GL_PTR_VCB,R0	; Get RCB address
	MOVZBL	RCB$B_ETY(R0),R0	; Get executor type
	$DISPATCH R0,<-			; Allow only if set to one of:
		<ADJ$C_PTY_PH4,28$>,-	; Phase IV routing
		<ADJ$C_PTY_PH4N,28$>,-	; Phase IV endnode
		<ADJ$C_PTY_AREA,28$>>	; Phase IV area routing
	MOVZWL	#SS$_BADPARAM,R0	; Else, illegal protocol
	$CNFFLD	pli,l,pro,R9		; Indicate parameter in error
29$:	BRB	100$			; Exit with error
28$:	;
	;   Issue the line control QIO to setup the driver with the control
	;   information.  The IO$_STARTUP and IO$_SHUTDOWN modifiers are
	;   illegal unless there is a state change.
	;
30$:	MOVZBL	PLVEC$AB_STATE[R4],-(SP); Save old state value
	CLRL	R1			; Clear illegal I/O modifier mask
	CMPB	PLI_B_STATE,-		; Are old and new state value the same?
		    PLVEC$AB_STATE[R4]	;
	BNEQ	40$			; If NEQ then state change
	MOVW	#IO$M_STARTUP!-		; Specify unwanted I/O modifiers
		 IO$M_SHUTDOWN,R1	;
40$:	MOVB	PLI_B_STATE,-		; Setup new state value
		    PLVEC$AB_STATE[R4]	;
	$CNFFLD	pli,s,chr,R9		; Set field i.d.
	MOVZWL	PLVEC$AW_CHAN[R4],R2	; Get channel
	BSBW	NET$SET_QIOW		; Issue set characteristics QIO
	MOVL	R1,R9			; Return 2nd IOSB longword as well
	CVTLB	(SP)+,PLVEC$AB_STATE[R4]; Restore original state
	BLBC	R0,100$			; If LBC then error
	MOVB	PLI_B_STATE,-		; Setup the new state value
		    PLVEC$AB_STATE[R4]	;
	;
	;   Start counter timer ticking
	;
	BSBW	NET$SET_CTR_TIMER	; Reset automatic counter timer
	MOVL	#1,R0			; Set successful
	;
	;   If the PLI is not new then simply return the status in R0.  If
	;   the PLI is new then the newly allocated PLVEC slot must be
	;   deallocated if R0 indicates an error.
	;
100$:	BBCC	#PLI_V_NEW,-		; Br unless PLVEC has been newly
		    CNF$B_FLG(R10),110$	; assigned
	BLBS	R0,110$			; If BS then no clean-up needed
	PUSHL	R0			; Save error code
	BSBW	DEAL_PLVEC		; Free the PLVEC cell
	POPL	R0			; Restore status
110$:	RSB				; Return status in R0

	.SBTTL	ALLOC_PLVEC - Setup PLVEC entry for new line
;+
; ALLOC_PLVEC - Setup a new PLVEC entry for a new PLI entry
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code
;-

ALLOC_PLVEC:				; Initialize a new PLVEC entry
	MOVZWL	#SS$_INSFMEM,R0		; Assume no resources for this entry
	MOVZBL	PLVEC$GB_MAX,R4		; Else no i.d. yet, get max PLX index
10$:	TSTB	PLVEC$AB_REFC[R4]	; Is this cell free?
	BEQL	20$			; If EQL then yes
	SOBGTR	R4,10$			; Loop -- index 0 is not used
19$:	BRW	100$			; Report "resource error"
20$:	MOVW	R4,CNF$W_ID(R10)	; Use PLVEC index as PLI i.d.
	INCB	PLVEC$AB_REFC[R4]	; Claim the PLVEC cell
	CLRW	PLVEC$AW_CHAN[R4]	; No channel assigned yet
	MOVZWL	#SS$_NOSUCHDEV,R0	; Assume error
	$GETFLD	pli,s,nam		; Else get the line name
	BLBC	R0,19$			; Branch to 100$ if cannot translate it
	;
	;   Get the VMS name of the device and the device code.  Assign an
	;   I/O channel to the device and squirrel away the device code
	;
	SUBL	#MAX_C_DEVNAM+8,SP	; Create scatch space on stack
	MOVAB	8(SP),R3		; Point to scratch space for name text
	MNEGL	R3,(SP)			; Bias count field of name descriptor
	MOVL	R3,4(SP)		; Enter ptr field of name descriptor
	BSBW	TRAN_DEVNAM		; Translate device name to VMS format
					; - advances R3, table entry -> R6
	BLBC	R0,40$			; If LBC then error
	MOVZWL	#SS$_IVDEVNAM,R0	; Assume error
	TSTL	R7			; Any unparsed characters?
	BNEQ	40$			; If NEQ yes, name format error
	MOVZWL	CNF$W_ID(R10),R4	; Recover R4
	MOVB	DEVTRN$B_DEV(R6),-	;
		    PLVEC$AB_DEV[R4]	; Enter device type code
	ADDL	R3,(SP)			; Complete device name descriptor
	MOVL	SP,R3			; Point to it
	$ASSIGN_S -			; Assign an I/O channel
		CHAN   = PLVEC$AW_CHAN[R4],-
		DEVNAM = (R3)
40$:	ADDL	#MAX_C_DEVNAM+8,SP	; Restore stack
	BLBC	R0,49$			; If LBC then error
	MOVZWL	PLVEC$AW_CHAN[R4],R0	; Get I/O channel
	JSB	G^IOC$VERIFYCHAN	; Return CCB in R1 regardless of error
	MOVL	CCB$L_UCB(R1),-		; Store device UCB
		    PLVEC$AL_UCB[R4]
					;
	SUBL	#4,SP			; Use stack for device characteristics
	MOVL	SP,R3			; Point R3 at return buffer
	PUSHL	#0			; Terminate GETDVI item list
	PUSHAB	QIOW_W_RETLEN		; Point to result length word
	PUSHL	R3			; Point to DEVCHAR return buffer
	MOVW	#DVI$_DEVCHAR,-(SP)	; Item code
	MOVW	#4,-(SP)		; Size of DEVCHAR result buffer
	MOVL	SP,R1			; Point to item list
	$GETDVI_S ITMLST=(R1),-		; Get device characteristics
		EFN=#NET$C_EFN_WAIT,-	; Use synchronous event flag
		CHAN = PLVEC$AW_CHAN[R4];
	ADDL	#5*4,SP			; Pop item list
					;
49$:	BLBC	R0,120$			; Branch if error detected
	MOVZWL	#SS$_IVDEVNAM,R0	; Assume error
	BBC	#DEV$V_NET,(R3),120$	; Br if not a network device
;
; Pre-allocate (and deallocate) the receive buffers for the datalink
; driver from the system nonpaged pool.  This is done here before
; invoking the driver so that the pool expansion mechanism can be used
; in case there isn't enough pool.  It is done here because pool
; expansion can't be done on the interrupt stack in the datalink driver.
;
	$GETFLD	pli,l,bus		; Get datalink receive buffer size
	BLBC	R0,70$			; If not set, skip it
	ADDL3	#CXB$C_OVERHEAD,R8,R5	; Add in datalink's overhead
	$GETFLD	pli,l,bfn		; Get number of line receive buffers
	BLBC	R0,70$			; Wasn't defaulted properly - skip it
	CLRL	-(SP)			; Terminate list of allocated blocks
50$:	MOVL	R5,R1			; Set size of block to allocate
	JSB	NET$ALONPAGED		; Allocate from nonpaged pool
	BLBC	R0,60$			; If error, give up
	PUSHL	R2			; Save block address
	SOBGTR	R8,50$			; Loop until all allocated
60$:	POPL	R0			; Get next buffer address
	BEQL	70$			; Branch if all blocks deallocated
	JSB	NET$DEALLOCATE		; Deallocate the block
	BRB	60$			; Loop until all blocks cleaned up
70$:	MOVL	#1,R0			; Success
100$:	RSB				; Return status in R0

120$:	;
	;  DEASSIGN the channel on error
	;
	PUSHL	R0			; Save error code
	$DASSGN_S -			; Deassign the I/O channed
		CHAN = PLVEC$AW_CHAN[R4];
	POPL	R0			; Restore error code
	BRB	100$			; And exit

	.SBTTL	NET$SET_QIOW - Issue datalink SETMODE function
;+
; NET$SET_QIOW - Issue datalink SETMODE function
;
; This routine is called when a line or circuit is to be initialized
; with a SETMODE function.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R9 = Parameter ID for CHR field, which returns DLLQIO buffer
;	R2 = Channel to datalink driver
;
; Outputs:
;
;	R0/R1 = I/O status quadword
;	R9 = Parameter ID qualifying error, if any.
;-

NET$SET_QIOW::
	MOVZWL	#SS$_NOSUCHDEV,R0	; Assume error
	BSBW	CNF$GET_FIELD		; Get datalink DLLQIO buffer
	BLBC	R0,100$			; If LBC then error
	BICL	R1,DLLQIO$L_FUNC(R8)	; Mask out illegal I/O modifier bits
	TSTL	DLLQIO$L_P1(R8)		; Any P1 buffer ?
	BEQL	5$			; If EQL no
	ADDL	R8,DLLQIO$L_P1(R8)	; Else turn offset into a pointer
5$:	TSTL	DLLQIO$L_P2(R8)		; Any P2 buffer ?
	BEQL	10$			; If EQL then none
	ADDL	R8,DLLQIO$L_P2(R8)	; Turn offset into a pointer
	MOVL	DLLQIO$L_P2(R8),R0	; Point to P2 buffer descriptor
	ADDL	R8,4(R0)		; Turn offset into a pointer
10$:	$QIOW_S	-			; Set the device charactersitics
		EFN  = #NET$C_EFN_WAIT,-
		IOSB = QIOW_Q_IOSB,-
		CHAN = R2,-
		FUNC = DLLQIO$L_FUNC(R8),-
		P1   = @DLLQIO$L_P1(R8),-	; This is a PUSHAL
		P2   = DLLQIO$L_P2(R8),-
		P3   = DLLQIO$L_P3(R8)
	BLBS	R0,20$			; Branch if queued ok
	MOVL	R0,QIOW_Q_IOSB		; If error, store status into IOSB
20$:	MOVL	QIOW_Q_IOSB+4,R9	; Get remainder of IOSB
	CMPL	R9,#NMA$C_PCLI_PHA	; "physical address"?
	BNEQ	22$			; If so,
	MOVL	#NMA$C_PCLI_HWA,R9	; then map it to "hardware address"
					; (so that we see it at the NICE level)
22$:	BSBW	NET$CVT_NMA_INT		; Convert NMA parameter i.d. to an
					; internal parameter i.d.
	CMPW	R9,#CNVTAB$C_INTRNL	; Datalink only parameter?
	BNEQ	25$			; Branch if not
	MOVL	QIOW_Q_IOSB+4,R9	; If so, I'd rather see the NMA code
25$:	MOVQ	QIOW_Q_IOSB,R0		; Get I/O status
	;
	;   Log the final status into the journal file, if any
	;
	MOVZWL	DLLQIO$L_FUNC(R8),R8	; Pass I/O function code into journal
100$:	MOVQ	R0,QIOW_Q_IOSB		; Save final status
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,120$			; Branch if not enabled
	MOVB	#^X44,(R1)+		; Journal record type = QIOW completion
	MOVW	R8,(R1)+		; I/O function code
	MOVQ	QIOW_Q_IOSB,(R1)+	; I/O status quadword
	JSB	@(SP)+			; Log the journalling record
120$:	MOVQ	QIOW_Q_IOSB,R0		; Restore final status
	RSB

	.SBTTL	PLI_TO_PSI - Send PLI parameters to PSIACP
;+
; PLI_TO_PSI - Issue SET of PLI parameters to PSIACP
;
; Send the PLI parameters that PSIACP cares about via a ACP control QIO.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;
; Outputs:
;
;	R0 = Status code
;-

PLI_TO_PSI:
	MOVAB	PSI_PLI_CLR_TAB,R5	; Get table of params to clear
	BSBW	CLEAR_VOLATILE		; Clear volatile parameters
	$CNFFLD	pli,s,nam,R9		; Set field ID of line name
	BSBB	SEND_TO_PSI		; Call co-routine to setup NFB, etc.
	BLBC	R0,90$			; Branch if error detected
	MOVB	#NFB$C_FC_SET,NFB$B_FCT(R6)	; Store function code
	MOVAB	PLI_PSI_TAB,R5		; Point to PSI line parameters
10$:	MOVL	(R5)+,R9		; Get next parameter ID
	BEQL	50$			; Branch if end of table
	BSBW	CNF$GET_FIELD		; Get the parameter value
	BLBC	R0,10$			; Skip it if it doesn't exist
	MOVL	R9,(R2)+		; Store into NFB
	CMPZV	#NFB$V_TYP,#NFB$S_TYP,-	; String or binary?
		R9,#NFB$C_TYP_STR
	BEQL	20$			; Branch if string
	MOVL	R8,(R3)+		; Store longword into P4 buffer
	BRB	10$
20$:	MOVW	R7,(R3)+		; Store string count word
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVC	R7,(R8),(R3)		; Store string text
	POPR	#^M<R2,R4,R5>		; Restore registers
	BRB	10$
50$:	JSB	@(SP)+			; Call SEND_TO_PSI back to issue QIO
90$:	RSB				; Return with status

	.SBTTL	SEND_TO_PSI - Send control QIO to PSIACP
;+
; SEND_TO_PSI - Send ACP control QIO to PSIACP
;
; This routine is called to transmit an ACP control function to PSIACP
; on behalf on a local CNF, such as a LAPB line.  CNFs like these are
; "known" about by both NETACP and PSIACP, NETACP in order to perform
; network management functions, and PSIACP in order to manage the line.
;
; Inputs:
;
;	R11 = Address of CNR
;	R10 = Address of CNF
;	R9 = Address of parameter ID describing entity name
;
; Outputs:
;
;	R0 = Status code
;
;	If the function code is NFB$C_FC_SHOW or NFB$C_FC_ZERCOU, then:
;
;	R7/R8 = Descriptor of result P4 buffer
;	R9 = Address of scratch storage, which should be deallocated
;		when processing of the P4 buffer is completed.
;
;	R1-R6 are destroyed.
;
; This routine makes a co-routine call back to the caller after setting
; up the NFB and associated control QIO buffers, so that the caller can
; fill in the essential fields.  When the caller returns via co-routine
; call to this routine, the control QIO is issued to PSIACP.
;
; On input to co-routine:
;
;	R6 = Address of NFB
;	R3 = Address of P4 buffer
;	R2 = Address of NFB$L_FLDID list
;
; On return from co-routine:
;
;	R3 = Updated pointer to end of P4 buffer
;	R2 = Updated pointer to end of FLDID list
;
;	R0-R1,R4-R5,R7-R9 may be destroyed by co-routine.
;-

NFB_SIZE = NFB$C_LENGTH + 30*4		; allow for all PSI field IDs
P2BUF_SIZE = 4+2+DEVNAM_C_SIZ+NFB$C_CTX_SIZE ; P2 holds CNF count and entity ID
					; plus context area
P4BUF_SIZE = 512			; P4 holds all parameter values

	ASSUME	PLI_PSI_SIZ LE 30*4	; Must be enough room for PLI params

SEND_TO_PSI:
	MOVZWL	#12+NFB_SIZE+P2BUF_SIZE+P4BUF_SIZE,R1 ; Set size of block overhead
					; plus NFB, P2 and P4 buffer sizes
	JSB	NET$ALLOCATE		; Allocate the storage
	BLBS	R0,5$			; Branch if successful
	RSB				; Else, exit with error status
5$:	PUSHL	R2			; Save address of block
	MOVAB	12(R2),R6		; Point to scratch NFB
	MOVC5	#0,(SP),#0,#NFB$C_LENGTH,(R6)	; Zero it
	MOVB	CNR$B_TYPE(R11),NFB$B_DATABASE(R6) ; Store database ID
	MOVB	#NFB$M_NOCTX,NFB$B_FLAGS(R6)	; Indicate one-shot request
	MOVB	#NFB$C_OP_EQL,NFB$B_OPER(R6)	; Search for key EQL
	MOVL	R9,NFB$L_SRCH_KEY(R6)	; Search for specific entry
					; by it's network management name
	BSBW	CNF$GET_FIELD		; Get descriptor of name
	BLBS	R0,10$			; Branch if ok
	BRW	110$			; Abort if unable to get entity name
10$:	MOVW	R7,NFB_SIZE+4(R6)	; Store size of string
	MOVC	R7,(R8),NFB_SIZE+6(R6)	; Copy into buffer
	CLRW	(R3)+			; Make context a null string
	MOVAB	NFB$L_FLDID(R6),R2	; Point to NFB field ID list
	MOVAB	NFB_SIZE+P2BUF_SIZE(R6),R3 ; Get address of P4 buffer
	MOVL	#1,R0			; Indicate co-routine init. successful
;
; Call the caller back so that he can fill in the NFB and P4 buffers.
;
	SWAP	(SP),4(SP)		; Swap block pointer & return address
					; so that caller's address is on top
	JSB	@(SP)+			; Fill in the NFB and P4 buffers
	SWAP	(SP),4(SP)		; Swap return address & block pointer
;
; Terminate the NFB field ID list
;
	ASSUME	NFB$C_ENDOFLIST EQ 0
	CLRL	(R2)+			; Terminate NFB parameter ID list
;
; Construct descriptors of NFB, P2 and P4 buffers for QIO
;
	ADDL3	#12,(SP),-(SP)		; Retreive starting address of NFB
	SUBL3	(SP),R2,-(SP)		; Compute length of NFB
	ADDL3	#NFB_SIZE+P2BUF_SIZE,4(SP),-(SP) ; Construct descriptor of P4
	SUBL3	(SP),R3,-(SP)		; Compute length of P4 buffer
	ADDL3	#NFB_SIZE,12(SP),R1	; Get address of P2 buffer
	MOVZWL	4(R1),R0		; Pick up length of entity name
	ADDL	#4+2+NFB$C_CTX_SIZE,R0	; Add 4 bytes for CNF count
					; plus 2 bytes for entity string size
					; and context area size
	MOVQ	R0,-(SP)		; Push P2 descrptor onto stack
	MOVL	SP,R2			; Point to P2/P4/NFB descriptors
	MOVAB	8(R2),R3		; Point to P4 descriptor directly
;
; Send database request to PSIACP
;
	TSTW	NET$GW_X25_CHAN		; Is there an active channel?
	BNEQ	60$			; If NEQL then yes
	BSBW	NET$GET_X25_CHAN	; Assign channel, get PSI mutex
	BLBC	R0,100$			; If LBC then error
60$:	$QIOW_S	FUNC = #IO$_ACPCONTROL,-; Re-issue QIO
		EFN  = #NET$C_EFN_WAIT,-; event flag for synchronous calls
		CHAN = NET$GW_X25_CHAN,-;
		IOSB = QIOW_Q_IOSB,-	; Scratch quadword buffer
		P1   = 8(R3),-		; Address of NFB descriptor
		P2   = R2,-		; Address of P2 buffer desciptor
		P3   = #QIOW_W_RETLEN,-	; Address of return length word
		P4   = R3		; Address of P4 buffer
	BLBC	R0,100$			; If LBC then error
	MOVQ	QIOW_Q_IOSB,R0		; Setup IOSB image
	BLBS	R0,100$			; Branch if successful
	MOVL	R1,R9			; Set error qualifier
100$:	ADDL	#3*8,SP			; Deallocate descriptors

	MOVQ	R0,QIOW_Q_IOSB		; Save final status
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,105$			; Branch if not enabled
	MOVB	#^X44,(R1)+		; Journal record type = QIOW completion
	MOVW	#IO$_ACPCONTROL,(R1)+	; I/O function code
	MOVQ	QIOW_Q_IOSB,(R1)+	; I/O status quadword
	JSB	@(SP)+			; Log the journalling record
105$:	MOVQ	QIOW_Q_IOSB,R0		; Restore final status

	BLBC	R0,110$			; Branch if error detected
	CMPB	NFB$B_FCT(R6),#NFB$C_FC_SHOW	; SHOW function?
	BEQL	150$			; Branch if so
	CMPB	NFB$B_FCT(R6),#NFB$C_FC_ZERCOU	; READ & ZERO function?
	BEQL	150$			; Branch if so
110$:	MOVL	R0,R1			; Save final status
	POPL	R0			; Retreive address of storage
	JSB	NET$DEALLOCATE		; Deallocate scratch storage
	MOVL	R1,R0			; Restore final status
	RSB				; Done

;
; The function is either SHOW or READ/ZERO.  Since the caller will most
; likely want to process the returned P4 buffer from the QIO, we return
; from the routine with a desciptor of the returned buffer, and the
; address of our scratch storage, which the caller will deallocate.
;

150$:	POPL	R9			; Return scratch pointer in R9
	MOVZWL	QIOW_W_RETLEN,R7	; Return descriptor of P4 buffer
	MOVAB	12+NFB_SIZE+P2BUF_SIZE(R9),R8
	RSB				; Exit successfully

	.SBTTL	NET$DELETE_CRI - Pre-delete processing
;+
; NET$DELETE_CRI - Special processing before a CRI entry is marked for delete
;
; This routine is called to perform any special action that may need to be
; taken before marking a CNF for delete.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11,R10	Preserved
;		R0	LBS if successful
;			LBC if CNF should not be marked for delete
;
;		All registers may be destroyed.
;-

NET$DELETE_CRI::
	;
	; If this is an X25 circuit, ask PSIACP if it's ok to delete CNF
	;
	$GETFLD	cri,l,typ		; Get circuit type parameter value
	BLBC	R0,10$			; If not specified, skip it
	CMPL	R8,#NMA$C_CIRTY_X25	; X25 circuit?
	BNEQ	10$			; Branch if not
	$GETFLD	cri,l,use		; Get X.25 usage
	BLBC	R0,10$			; If not specified, skip it
	CMPL	R8,#NMA$C_CIRUS_PER	; PVC?
	BNEQ	10$			; Only ask PSI about PVCs
	$CNFFLD	cri,s,nam,R9		; Set field ID of circuit name
	BSBW	SEND_TO_PSI		; Call co-routne to setup NFB, P4, etc.
	BLBC	R0,90$			; Branch if error detected
	MOVB	#NFB$C_FC_DELETE,NFB$B_FCT(R6) ; Set function code
	JSB	@(SP)+			; Call SEND_TO_PSI to issue QIO
	BLBC	R0,90$			; Branch if error detected
	BRB	50$			; Allow delete
	;
	;   For all circuits, if the LPD is no longer present (as a result
	;   of an ON -> OFF state transition), then allow the delete.
	;
10$:	BSBW	NET$LOCATE_LPD		; Locate the LPD 
	BLBS	R0,80$			; If found, then do not allow delete
50$:	MOVL	#1,R0			; Allow delete
90$:	RSB

80$:	CLRL	R0			; Do not allow delete
	RSB

	.SBTTL	NET$DELETE_PLI - Pre-delete processing
;+
; NET$DELETE_PLI - Special processing before a PLI entry is marked for delete
;
; This routine is called to perform any special action that may need to be
; taken before marking a CNF for delete.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11,R10	Preserved
;		R0	LBS if successful
;			LBC if CNF should not be marked for delete
;
;		All registers may be destroyed.
;-

NET$DELETE_PLI::
	$GETFLD	pli,l,sta		; Get the state value
	BLBC	R0,10$			; If LBC then no need to check state
	CMPL	#NMA$C_STATE_OFF,R8	; Is the line turned off?
	BEQL	10$			; If NEQ then cannot delete PLI
	CLRL	R0			; Say "cannot delete PLI"
	RSB				; Done
	;
	; If this is a LAPB line, ask PSIACP if it's ok to delete CNF
	;
10$:	$GETFLD	pli,l,pro		; Get protocol parameter value
	BLBC	R0,DEAL_PLVEC		; If not specified, skip it
	CMPL	R8,#NMA$C_LINPR_LAPB	; LAPB line?
	BNEQ	DEAL_PLVEC		; Branch if not
	$CNFFLD	pli,s,nam,R9		; Set field ID of line name
	BSBW	SEND_TO_PSI		; Call co-routne to setup NFB, P4, etc.
	BLBC	R0,90$			; Branch if error detected
	MOVB	#NFB$C_FC_DELETE,NFB$B_FCT(R6) ; Set function code
	JSB	@(SP)+			; Call SEND_TO_PSI to issue QIO
90$:	RSB				; Return with status.

DEAL_PLVEC:				; Deallocate PLVEC cell
	MOVZWL	CNF$W_ID(R10),R4	; Get the PLVEC index
	BEQL	10$			; If EQL then done
	CLRB	PLVEC$AB_REFC[R4]	; No longer any references to this slot
	CLRL	PLVEC$AL_UCB[R4]	; No UCB
	$DASSGN_S -			; Deassign the I/O channed
		CHAN = PLVEC$AW_CHAN[R4];
					; Ignore errors
10$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

	.SBTTL	NET$REMOVE_xxx - Pre-remove processing
;+
; NET$REMOVE_CRI - Processing after CRI block has been removed.
; NET$REMOVE_PLI - Processing after PLI block has been removed.
;
; This routine is called to perform special processing after a CNF block has 
; been removed from the database.  On return, the block is deallocated.
;
; INPUTS:	R11	CNR pointer
;		R0	CNF pointer
;
; OUTPUTS:	All registers are preserved.
;-
NET$REMOVE_CRI::			; Remove Circuit CNF action routine
NET$REMOVE_PLI::			; Remove Line CNF action routine
	JSB	NET$REMOVE_DEF		; Let default routine do the work
	RSB

	.SBTTL	CRI parameter action routines
;+
; NET$CRI_V_LCK	-  Get status of conditionally writeable fields
;
; NET$CRI_L_SUB -  Get circuit's substate
; NET$CRI_L_DRT -  Get broadcast circuit's designated router
;
; NET$CRI_L_PNA	-  Get partner's node address
; NET$CRI_L_BLO -  Get partner's receive block size
; NET$CRI_L_LIT -  Get partner's listen timer
;
; NET$CRI_S_COL -  Get circuit's collating value
; NET$CRI_S_PNN -  Get partner's node name
; NET$CRI_S_LOO -  Get line's loopback name
; NET$CRI_S_CNT -  Get (optionally clear) circuit counters
; NET$CRI_S_VMSNAM Get VMS name of associated device
; NET$CRI_S_CHR -  Get circuit's characteristics buffer
;
; INPUTS:	R11	CRI CNR address
;		R10	CRI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of string descriptor or address of field value
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-

NET$CRI_V_LCK::				; Get status of cond. writeable fields
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC no LPD, not locked
	TSTB	LPD$B_ASTCNT(R6)	; Any I/O outstanding?
	BNEQ	10$			; If NEQ yes, locked
	CLRL	R0			; Else not locked
10$:	MOVL	R0,R1			; Return as field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB


NET$CRI_L_SUB::				; Get circuit's substate	
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or substate
	CLRL	R0			; Assume in "run" state
	BBS	#LPD$V_RUN,-		; If BS then no sub-state
		    LPD$W_STS(R6),10$	;
	MOVZBL	LPD$B_SUB_STA(R6),R1	; Get sub-state
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_DRT::				; Get broadcast circuit's designated router
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,90$			; If not found, return "not set"
	CLRL	R0			; Assume not a valid address
	BBC	#LPD$V_BC,LPD$W_STS(R6),90$ ; No DRT if not broadcast circuit
	MOVZWL	LPD$W_DRT(R6),R1	; Get designated router ADJ index
	BEQL	90$			; If 0, then DRT "not set"
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVL	@RCB$L_PTR_ADJ(R4)[R1],R1 ; Get ADJ address
	MOVZWL	ADJ$W_PNA(R1),R1	; Get DRT node address
	BEQL	90$			; If 0, then DRT "not set"
	BSBW	SUPPRESS_AREA		; Suppress area, if necessary
	MOVL	S^#SS$_NORMAL,R0	; Set status
90$:	RSB				; Exit with status/value
	
NET$CRI_L_BLO::				; Get partner's receive block size
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BS then no block size
		    LPD$W_STS(R6),10$	;
	MOVZBL	LPD$B_PTH_INX(R6),R7	; Get LPD index
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R7 ; Get ADJ address
	MOVZWL	ADJ$W_BUFSIZ(R7),R1	; Get partner's node address
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_LIT::				; Get partner's listen timer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BS then no listen timer
		    LPD$W_STS(R6),10$	;
	BBS	#LPD$V_BC,-		; If a broadcast circuit,
		LPD$W_STS(R6),10$ 	; then no listen timer
	MOVZBL	LPD$B_PTH_INX(R6),R7	; Get LPD index
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R7 ; Get ADJ address
	MOVZWL	ADJ$W_INT_LSN(R7),R1	; Get partner's listen timer
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_PNA::				; Get partner's node address
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BC then no partner node
		    LPD$W_STS(R6),10$	;
	BBS	#LPD$V_BC,-		; If a broadcast circuit,
		LPD$W_STS(R6),10$ 	; then no block size
	MOVZBL	LPD$B_PTH_INX(R6),R7	; Get LPD index
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R7 ; Get ADJ address
	MOVZWL	ADJ$W_PNA(R7),R1	; Get partner's node address
	BSBW	SUPPRESS_AREA		; Suppress area, if necessary
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_MST::				; Get maintenance mode state
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,20$			; If LBC, no LPD or partner node
	MOVZWL	#NMA$C_STATE_ON,R1	; Assume state is "ON"
	BBS	#LPD$V_DLE,-		; If BS then maintenance state is "ON"
		    LPD$W_STS(R6),10$	;
	MOVZWL	#NMA$C_STATE_OFF,R1	; Else state is "OFF"
10$:	MOVL	S^#SS$_NORMAL,R0	; Set status
20$:	RSB				; Return to co-routine


NET$CRI_S_COL::				; Get circuit's collating value
	$GETFLD	cri,s,nam		; Get circuit's name
	BLBC	R0,10$			; Branch if not present
	MOVC3	R7,(R8),(R3)		; Move the name
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
10$:	RSB				; Return status in R0

NET$CRI_S_PNN::				; Get partner's node name
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,20$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BC then no partner node
		    LPD$W_STS(R6),20$	;
	BBS	#LPD$V_BC,-		; If a broadcast circuit,
		LPD$W_STS(R6),20$ 	; then no block size
	MOVZBL	LPD$B_PTH_INX(R6),R7	; Get LPD index
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R7 ; Get ADJ address
	MOVZWL	ADJ$W_PNA(R7),R8	; Get partner's node address
	MOVL	NET$GL_CNR_NDI,R11	; Get NDI root block
	BSBW	NET$NDI_BY_ADD		; Get the associated NDI CNF
	BLBC	R0,20$			; If LBC then none
	$GETFLD	ndi,s,nna		; Get node name 
	BLBC	R0,20$			; If LBC then not set
	MOVC3	R7,(R8),(R3)		; Move the name
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
20$:	RSB				; Return status in R0

NET$CRI_S_LOO::				; Get line's loopback nodename
	$GETFLD	cri,s,nam		; Get line name
	BLBC	R0,20$			; If LBC then error
	MOVL	NET$GL_CNR_NDI,R11	; Get NDI root block
	CLRL	R10			; Indicate no current NDI CNF
	$SEARCH	eql,ndi,s,nli		; Get find NDI with this loopback line
	BLBC	R0,20$			; If LBC then not found
	$GETFLD	ndi,s,nna		; Get the node name
	BLBC	R0,20$			; If LBC then not set
	MOVC3	R7,(R8),(R3)		; Move the name
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
20$:	RSB				; Return status in R0

NET$CRI_S_VMSNAM::			; Get VMS name of device
	$GETFLD	cri,s,nam		; Get network management circuit name
	BLBC	R0,100$			; If LBC then error
	BSBW	TRAN_DEVNAM		; Get VMS device name
					; Exit with status
	; Assume that any remaining characters are part of tributary identifier
100$:	RSB				; Return status in R0

NET$CRI_S_DEVNAM::			; Get VMS device name, including unit
	BSBW	NET$LOCATE_LPD		; Locate LPD
	BLBC	R0,80$			; Branch if none
	BBC	#LPD$V_RUN,-		; Exit if circuit not in run state
		LPD$W_STS(R6),80$
	SUBL	#4,SP			; Used for returning device characteristics
	MOVL	SP,R4			; Point R4 at return buffer
	PUSHL	#0			; Terminate GETDVI item list
	PUSHAB	QIOW_Q_IOSB		; Point to DEVCHAR length word (use IOSB)
	PUSHL	R4			; Point to DEVCHAR return buffer
	MOVW	#DVI$_DEVCHAR,-(SP)	; Item code
	MOVW	#4,-(SP)		; Size of DEVCHAR result buffer
	PUSHAB	QIOW_W_RETLEN		; Point to result length word
	PUSHL	R3			; Point to result buffer
	MOVW	#DVI$_DEVNAM,-(SP)	; Item code
	MOVW	#DEVNAM_C_SIZ,-(SP)	; Size of result buffer
	MOVL	SP,R1			; Point to item list
	$GETDVI_S ITMLST=(R1),-		; Construct actual device name
		EFN=#NET$C_EFN_WAIT,-	; Use synchronous event flag
		CHAN=LPD$W_CHAN(R6)
	ADDL	#8*4,SP			; Pop item list
	BLBC	R0,90$			; Branch if error detected
	BBC	#DEV$V_NET,(R4),80$	; Br if not a network device
	MOVZWL	QIOW_W_RETLEN,R1	; Get length of result buffer
	ADDL	R1,R3			; Point past result string
	BRB	90$			; Success
80$:	MOVZWL	#SS$_IVDEVNAM,R0	; Error in <cri,s,nam> field, or
					;   not a network device
90$:	RSB				; Return status in R0

NET$CRI_S_CNT::				; Get line counters (maybe clear them)
	PUSHL	R3			; Save starting address of counter block
	$GETFLD	cri,l,typ		; Get circuit type
	BLBC	R0,20$			; Branch if not set, assume not X25
	CMPL	R8,#NMA$C_CIRTY_X25	; X.25 circuit?
	BNEQ	20$			; Branch if not
	BSBW	NET$LOCATE_LPD		; Get associated LPD, if any
	BLBC	R0,10$			; Branch if no datalink mapping enabled
	;
	; X.25 datalink mapping circuit counters
	;
	BSBB	50$			; Get Transport counters & seconds
	PUSHL	R3			; Save current position in buffer
	BSBW	200$			; Get PSI circuit counters & seconds
	POPL	R8			; Get start of PSI counter block
	BLBC	R0,5$			; Branch if no PSI counters (possible
					; for switched circuits)
	CMPW	(R8),#NET$C_NMACNT_SLZ	; "seconds since last zeroed" ?
	BNEQ	30$			; Branch if not
	SUBL	#4,R7			; Account for loss of PSI "seconds"
	MOVC	R7,4(R8),(R8)		; Delete PSI seconds counter from block
5$:	MOVL	#1,R0			; Success
	BRB	30$
	;
	; Native X.25 circuit counters
	;
10$:	BSBW	200$			; Get PSI circuit counters & seconds
	BRB	30$			; and continue with status in R0
	;
	; Non-X25 circuit counters
	;
20$:	BSBW	NET$LOCATE_LPD		; Get associated LPD
	BLBC	R0,40$			; Error if LBC
	BSBB	50$			; Get the Transport counters
30$:	MOVL	(SP),R2			; Recover original counter block ptr
	BLBC	R0,40$			; If LBC then error
	MOVL	S^#EVC$C_SRC_CIR,R0	; Setup database event i.d.
	BSBW	LOG_COUNTERS		; Log the counters if they were zeroed
	MOVL	S^#SS$_NORMAL,R0	; Success
40$:	ADDL	#4,SP			; Pop buffer pointer
	RSB				; Done

;
;   Subroutine to move Transport and datalink counters
;
50$:	MOVAB	LPD_CNT_TAB,R5		; Point to Transport counter table
	MOVZWL	#4+LPD$C_CNT_SIZE,R2	; Number of bytes of Transport counters
					; +4 for ABS_TIME
	MOVAB	LPD$L_ABS_TIM(R6),R1	; Point to counters
	JSB	MOVE_FMT_CNT		; Move and format Transport counters
	;
	;   Get the counters from the driver and append to current counters
	;   minus the 'seconds since last zeroed' counter.
	;
	BBS	#LPD$V_X25,LPD$W_STS(R6),90$ ; Skip if X.25 datalink
	MOVZWL	LPD$W_CHAN(R6),R2	; Is there an I/O channel
	BEQL	90$			; If EQL no, skip this phase
	MOVZWL	#IO$_SENSEMODE!-	; Setup function code
		 IO$M_RD_COUNT,R0	;
	BSBW	DEV_CNT_QIO		; Issue circuit QIO for counters
90$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
100$:	RSB				; Done

;
; Subroutine to move PSI circuit counters
;

200$:	PUSHR	#^M<R3,R6>		; Save registers
	$CNFFLD	cri,s,nam,R9		; Set field ID of circuit name
	BSBW	SEND_TO_PSI		; Call co-routine to setup NFB, etc.
	BLBC	R0,59$			; Branch if error detected
	$CNFFLD	cri,s,cnt,(R2)+		; Store counter field ID into NFB
	MOVB	#NFB$C_FC_SHOW,NFB$B_FCT(R6) ; Set function code
	BBC	#NET$V_CLRCNT,NET$GL_FLAGS,55$ ; Branch if not clearing counters
	MOVB	#NFB$C_FC_ZERCOU,NFB$B_FCT(R6) ; Set READ & ZERO function code
55$:	ADDL	#P4BUF_SIZE,R3		; Set size of P4 return buffer
	JSB	@(SP)+			; Call SEND_TO_PSI back to issue QIO
	POPR	#^M<R3,R6>		; Restore registers
59$:	BLBC	R0,100$			; Branch if error detected
	MOVZWL	(R8)+,R7		; Make descriptor of CNT string
	MOVC	R7,(R8),(R3)		; Copy P4 buffer into counter block
	MOVL	R9,R0			; Point to scratch storage
	JSB	NET$DEALLOCATE		; Deallocate SHOW buffer
	MOVL	#1,R0			; Success
	RSB

NET$CRI_S_CHR::				; Get line's startup characteristics
	BSBW	NET$LOCATE_LPD		; Get associated LPD
	BLBC	R0,100$			; Error if LBC
	PUSHL	R3			; Save buffer pointer
	MOVC5	#0,(SP),#0,-		; Zero buffer header
		#DLLQIO$C_LENGTH,(R3)	; ...advance R3
	POPL	R5			; Point to DLLQIO block
	CLRL	R0			;& (better code) Assume no PLVEC index
	MOVZBL	LPD$B_PLVEC(R6),R4	; Get PLVEC index
	BEQL	100$			; Report error
	MOVL	LPD$L_UCB(R6),R0	; Get device UCB
	BEQL	100$			; If EQL then none
	MOVZWL	#IO$_SETMODE,-		; Setup I/O function code
		   DLLQIO$L_FUNC(R5)	;
	MOVAB	CRI_TRN_TAB,R2		; Setup parameter translation table
	PUSHAB	B^10$			; Setup return address
	$DISPATCH TYPE=B,PLVEC$AB_DEV[R4],- ; Dispatch on device type
	    <-
	    <DEVTRN$C_DEV_DMC,	   CRI_DMC>,-
	    <DEVTRN$C_DEV_PCL,     CRI_PCL>,-
	    <DEVTRN$C_DEV_DMP,	   CRI_DMP>,-
	    <DEVTRN$C_DEV_CI,	   CRI_CI>,-
	    <DEVTRN$C_DEV_UNA,	   CRI_UNA>,-
	>
	BRB	CRI_FOREIGN		; Br if device is unknowm
10$:
100$:	RSB

CRI_DMP:
CRI_PCL:
CRI_CI:
CRI_UNA:
CRI_FOREIGN:
	BSBW	BUILD_DEVBUF		; Build the device parameter buffer
	RSB				;

CRI_DMC:
	SUBL3	R5,R3,DLLQIO$L_P1(R5)	; Setup offset to characteristics buffer
	;
	;
	;   Get the characteristics buffer form the UCB.  This buffer was setup
	;   properly (with the exception of the MOP bit) from the PLI database
	;   when the corresponding DMC "line" was turned on.
	;
	;
	ASSUME	UCB$L_DEVDEPEND  EQ  2+UCB$W_DEVBUFSIZ
	ASSUME	UCB$W_DEVBUFSIZ  EQ  1+UCB$B_DEVTYPE
	ASSUME	UCB$B_DEVTYPE    EQ  1+UCB$B_DEVCLASS

	MOVQ	UCB$B_DEVCLASS(R0),(R3)+; Enter device characteristics
	CLRBIT	XM$V_CHR_MOP,-4(R3)	; Assume MOP mode not needed
	BBC	#LPD$V_DLE,-		; If BC not in use for direct-access
		    LPD$W_STS(R6),10$	; functions
	SETBIT	XM$V_CHR_MOP,-4(R3)	; Put line in MOP mode
10$:	;
	;
	;   Get number of receive buffers from the PLI database
	;
	;
	PUSHR	#^M<R1,R10,R11>		; Save regs
	MOVL	NET$GL_CNR_PLI,R11	; Get PLI root block
	CLRL	R10			; Search from begining of list
	MOVL	R4,R8			; Search key is the PLVEC index
	$SEARCH	eql,pli,l,plvec		; Find PLI's CNF block
	BLBC	R0,15$			; If LBC then not found
	$GETFLD	pli,l,bfn		; Get # of receive buffers
	BLBS	R0,20$			; If LBS then field was active
15$:	MOVL	#4,R8			; Setup default
20$:	MOVL	R8,DLLQIO$L_P3(R5)	; Setup # of receive buffers
	POPR	#^M<R1,R10,R11>		; Restore regs
					;
	MOVB	#1,R0			; Indicate success
100$:	RSB				; Return status in R0

	.SBTTL	PLI parameter action routines
;+
; NET$PLI_V_LCK	-  Get status of conditionally writeable fields
;
; NET$PLI_L_SUB -  Get line's substate
; NET$PLI_L_BUS	-  Get line's receive buffer size
; NET$PLI_L_PLVEC  Get line's PLVEC index
;
; NET$PLI_S_COL -  Get line's collating value
; NET$PLI_S_VMSNAM Get VMS name of associated device
; NET$PLI_S_DEVNAM Get VMS name of associated device, but with unit included
; NET$PLI_S_CNT -  Get (optionally clear) line counters
; NET$PLI_S_CHR -  Get line's characteristics buffer
;
; INPUTS:	R11	PLI CNR address
;		R10	PLI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of string descriptor or address of field value
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-

NET$PLI_V_LCK::				; Get status of cond. writeable fields
	$GETFLD	pli,l,sta		; Get the state value
	BLBC	R0,10$			; If LBC then not locked
	CMPL	#NMA$C_STATE_OFF,R8	; Is the line turned off?
	BNEQ	10$			; If NEQ then locked
	CLRL	R0			; Say "not locked"
10$:	MOVL	R0,R1			; Return as field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$PLI_L_SUB::				; Get line's substate	
	CLRL	R0			; No substate is defined for lines
					; at this time
	RSB				; Return status in R0

NET$PLI_L_PLVEC::			; Get line's PLVEC index
	MOVZBL	CNF$W_ID(R10),R1	; Get the PLVEC index
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return

NET$PLI_L_BUS::				; Get line's receive buffer size
					; (MUST preserve R2-R11)
	PUSHR	#^M<R7,R8,R9>		; Save registers
	MOVL	NET$GL_PTR_VCB,R1	; Get RCB address
	MOVZWL	RCB$W_TOTBUFSIZ(R1),R1	; Store the local block size
	SUBW	#CXB$C_OVERHEAD,R1	; Subtract out overhead
	;
	;   If this is an Ethernet controller, then add an additional
	;   15 bytes overhead to account for the extended Ethernet
	;   Route Header used by Transport.  This is done only for
	;   Ethernet datalinks to avoid burdening point-to-point datalinks
	;   with the additional memory for its buffers.
	;
	MOVZWL	CNF$W_ID(R10),R0	; Get PLVEC index
	BEQL	50$			; If none, skip it
	CMPB	PLVEC$AB_DEV[R0],-	; Is this an Ethernet controller?
		#DEVTRN$C_DEV_UNA
	BNEQ	50$			; Skip if not
	ADDL	#TR$C_MAXHDR-6,R1	; Add additional overhead for
					; Phase IV Ethernet Transport header
	;
	;   If the user wants a larger buffer size for this line,
	;   then return that value rather than the default executor
	;   buffer size.
	;
50$:	$GETFLD	pli,l,bfs		; Executor buffer size overridden?
	BLBC	R0,90$			; Skip if not set
	MOVL	R8,R1			; If set, use it (includes xpt header)
90$:	MOVZWL	#SS$_NORMAL,R0		; Success
	POPR	#^M<R7,R8,R9>		; Restore registers
	RSB				; Return status in R0

NET$PLI_S_COL::				; Get line's collating value
	$GETFLD	pli,s,nam		; Get line's name
	BLBC	R0,10$			; Branch if not present
	MOVC3	R7,(R8),(R3)		; Move the name
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
10$:	RSB				; Return status in R0

NET$PLI_S_VMSNAM::			; Get VMS name of device
	$GETFLD	pli,s,nam		; Get network management line name 
	BLBC	R0,10$			; If LBC then error
	BSBW	TRAN_DEVNAM		; Translate the device name
	BLBC	R0,10$			; If LBC then error
	TSTL	R7			; Any characters left?
	BEQL	10$			; If EQL then none, name is okay
	MOVZWL	#SS$_IVDEVNAM,R0	; Error in <pli,s,nam> field
10$:	RSB				; Return status in R0

NET$PLI_S_DEVNAM::			; Get VMS device name, including unit
	MOVZWL	CNF$W_ID(R10),R8	; Get PLVEC index
	BEQL	80$			; Branch if none
	MOVZWL	PLVEC$AW_CHAN[R8],R0	; Get channel used by line
	SUBL	#4,SP			; Used for returning device characteristics
	MOVL	SP,R4			; Point R4 at return buffer
	PUSHL	#0			; Terminate GETDVI item list
	PUSHAB	QIOW_Q_IOSB		; Point to DEVCHAR length word (use IOSB)
	PUSHL	R4			; Point to DEVCHAR return buffer
	MOVW	#DVI$_DEVCHAR,-(SP)	; Item code
	MOVW	#4,-(SP)		; Size of DEVCHAR result buffer
	PUSHAB	QIOW_W_RETLEN		; Point to result length word
	PUSHL	R3			; Point to result buffer
	MOVW	#DVI$_DEVNAM,-(SP)	; Item code
	MOVW	#DEVNAM_C_SIZ,-(SP)	; Size of result buffer
	MOVL	SP,R1			; Point to item list
	$GETDVI_S ITMLST=(R1),-		; Construct actual device name
		EFN=#NET$C_EFN_WAIT,-	; Use synchronous event flag
		CHAN=R0
	ADDL	#8*4,SP			; Pop item list
	BLBC	R0,90$			; Branch if error detected
	BBC	#DEV$V_NET,(R4),80$	; Br if not a network device
	MOVZWL	QIOW_W_RETLEN,R1	; Get length of result buffer
	ADDL	R1,R3			; Point past result string
	BRB	90$			; Success
80$:	MOVZWL	#SS$_IVDEVNAM,R0	; Error in <pli,s,nam> field or
					;   not a network device
90$:	RSB				; Return status in R0

NET$PLI_S_CNT::				; Get line counters (maybe clear them)
	PUSHL	R3			; Save starting address of counter block
	;
	;   If this is an X.25 circuit, then ask PSI for its counters.
	;
	$GETFLD	pli,l,pro		; Get line protocol code
	BLBC	R0,10$			; Branch if not specified
	CMPL	R8,#NMA$C_LINPR_LAPB	; LAPB line?
	BNEQ	10$			; If not, use normal SENSEMODE
	BSBB	200$			; Get PSI line counters & seconds
	BRB	20$
	;
	; Get non-X25 line counters
	;
10$:	MOVZWL	CNF$W_ID(R10),R6	; Get PLVEC index
	BEQL	30$			; Branch if none
	CMPB	PLVEC$AB_DEV[R6],-	; No counters for DMC "lines" (special
		#DEVTRN$C_DEV_DMC	; case this since XMDRIVER does not
	BEQL	30$			; support the standard datalink driver
					; interface).
	BSBB	50$			; Get the counters
20$:	MOVL	(SP),R2			; Recover original counter block ptr
	BLBC	R0,40$			; If LBC then error
	MOVL	S^#EVC$C_SRC_LIN,R0	; Setup database event i.d.
	BSBW	LOG_COUNTERS		; Log the counters if they were zeroed
30$:	MOVL	S^#SS$_NORMAL,R0	; Success
40$:	ADDL	#4,SP			; Pop counter address off stack
	RSB				; Done

50$:	;
	;   Subroutine to build the counter block
	;
	MOVAL	PLVEC$AL_ABS_TIM[R6],R1	; Point to seconds since last zeroed
					; counters
	MOVL	#4,R2			; Number of bytes in block
	MOVAB	PLI_CNT_TAB,R5		; Point to counter formatting table
	JSB	MOVE_FMT_CNT		; Move and format the counters
	;
	;   Get the counters from the driver and append to counter block
	;   being constructed.
	;
70$:	MOVZWL	PLVEC$AW_CHAN[R6],R2	; Is there an I/O channel
	BEQL	90$			; If EQL no, skip this phase
	MOVZWL	#IO$_SENSEMODE!-	; Setup function code
		 IO$M_CTRL!-		; 
		 IO$M_RD_COUNT,R0	;
	BSBW	DEV_CNT_QIO		; Issue circuit QIO for counters
90$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
100$:	RSB				; Done

;
; Subroutine to get PSI LAPB line counters
;
200$:	PUSHR	#^M<R3,R6>		; Save registers
	$CNFFLD	pli,s,nam,R9		; Set field ID of line name
	BSBW	SEND_TO_PSI		; Call co-routine to setup NFB, etc.
	BLBC	R0,59$			; Branch if error detected
	$CNFFLD	pli,s,cnt,(R2)+		; Store counter field ID into NFB
	MOVB	#NFB$C_FC_SHOW,NFB$B_FCT(R6) ; Set function code
	BBC	#NET$V_CLRCNT,NET$GL_FLAGS,55$ ; Branch if not clearing counters
	MOVB	#NFB$C_FC_ZERCOU,NFB$B_FCT(R6) ; Set READ & ZERO function code
55$:	ADDL	#P4BUF_SIZE,R3		; Set size of P4 return buffer
	JSB	@(SP)+			; Call SEND_TO_PSI back to issue QIO
	POPR	#^M<R3,R6>		; Restore registers
59$:	BLBC	R0,100$			; Branch if error detected
	MOVZWL	(R8)+,R7		; Make descriptor of CNT string
	MOVC	R7,(R8),(R3)		; Copy string into counter block
	MOVL	R9,R0			; Point to scratch storage
	JSB	NET$DEALLOCATE		; Deallocate SHOW buffer
	MOVL	#1,R0			; Success
	RSB

NET$PLI_S_CHR::				; Get line's startup characteristics
	PUSHL	R3			; Save pointer to buffer
	MOVC5	#0,(SP),#0,-		; Zero buffer header
		#DLLQIO$C_LENGTH,(R3)	; ...advance R3
	POPL	R5			; Point to top of buffer
	CLRL	R0			; Assume no PLVEC index assigned
	MOVZWL	CNF$W_ID(R10),R4	; Get PLVEC index
	BEQL	100$			; If EQL then return error
	;
	;   Setup default function value
	;
	$DISPATCH TYPE=B,PLVEC$AB_STATE[R4],-	; Dispatch by state value
	    <-
	    <NMA$C_STATE_OFF,	10$>,-
	    <NMA$C_STATE_ON,	20$>,-
	>
	MOVW	#IO$_SETMODE!IO$M_CTRL,R0 ; Use this for all other states
	BRB	30$			; Continue
10$:	MOVW	#IO$_SETMODE!IO$M_CTRL!-; State is "off"
		IO$M_SHUTDOWN,R0	;
	BRB	30$			; Continue
20$:	MOVW	#IO$_SETMODE!IO$M_CTRL!-; State is "on"
		IO$M_STARTUP,R0		;
30$:	MOVZWL	R0,DLLQIO$L_FUNC(R5)	; Setup I/O function code
	MOVAB	PLI_TRN_TAB,R2		; Point to param translation table
	PUSHAB	B^40$			; Setup return address

	$DISPATCH TYPE=B,PLVEC$AB_DEV[R4],- ; Dispatch on device type
	    <-
	    <DEVTRN$C_DEV_DMC,	   PLI_DMC>,-
	    <DEVTRN$C_DEV_PCL,     PLI_PCL>,-
	    <DEVTRN$C_DEV_DMP,	   PLI_DMP>,-
	    <DEVTRN$C_DEV_CI,	   PLI_CI>,-
	    <DEVTRN$C_DEV_UNA,	   PLI_UNA>,-
	    <DEVTRN$C_DEV_PPUNA,   PLI_PPUNA>,-
	>
	BRB	PLI_FOREIGN		; Br if device is unknown
40$:
100$:	RSB

PLI_DMP:
PLI_PCL:
PLI_CI:
PLI_FOREIGN:
	BSBW	BUILD_DEVBUF		; Build the parameter buffer
	RSB

PLI_UNA:
	BSBW	BUILD_DEVBUF		; Build standard parameter buffer
	PUSHL	R3			; Save position in P2 buffer
	MOVW	#NMA$C_PCLI_PRM,(R3)+	; Promiscuous mode = OFF
	MOVL	#NMA$C_STATE_OFF,(R3)+
	MOVW	#NMA$C_PCLI_MLT,(R3)+	; Multicast address state = OFF
	MOVL	#NMA$C_STATE_OFF,(R3)+
	MOVW	#NMA$C_PCLI_PAD,(R3)+	; Padding on transmits = ON
	MOVL	#NMA$C_STATE_ON,(R3)+
	MOVW	#NMA$C_PCLI_DCH,(R3)+	; Data chaining = OFF
	MOVL	#NMA$C_STATE_OFF,(R3)+	; (DLLTRN can't handle multiple CXBs)
	MOVW	#NMA$C_PCLI_CRC,(R3)+	; CRC generation = ON
	MOVL	#NMA$C_STATE_ON,(R3)+
	MOVW	#NMA$C_PCLI_ACC,(R3)+	; Protocol access mode = exclusive
	MOVL	#NMA$C_ACC_EXC,(R3)+
	MOVW	#NMA$C_PCLI_PTY,(R3)+	; Protocol type parameter code
	$GETFLD	pli,l,ept		; Get protocol type to be used
	BLBS	R0,10$			; Branch if ok
	MOVZWL	#TR$C_NI_PROT,R8	; Else, provide a default value
10$:	MOVL	R8,(R3)+		; Set protocol type
	MOVW	#NMA$C_PCLI_PHA,(R3)+	; Physical address = Phase IV address
	MOVW	#8,(R3)+		;    8 byte string:
	MOVW	#NMA$C_LINMC_SET,(R3)+	;    Set the address
	MOVL	#TR$C_NI_PREFIX,(R3)+	;    Phase IV NI prefix
	MOVL	NET$GL_PTR_VCB,R7	;
	MOVW	RCB$W_ADDR(R7),(R3)+	;    Phase IV node number
	MOVW	#NMA$C_PCLI_MCA,(R3)+	; Multicast addresses are:
	MOVW	#8,(R3)+		;    8 byte string:
	MOVW	#NMA$C_LINMC_SET,(R3)+	;    Set the address
	MOVL	#TR$C_NI_ALLROU1,(R3)+	;    Phase IV "all routers" multicast
	MOVW	#TR$C_NI_ALLROU2,(R3)+
	CMPB	RCB$B_ETY(R7),#ADJ$C_PTY_PH4N ; If Phase IV endnode,
	BNEQ	20$			;	use "all endnodes" instead
	SUBL	#6,R3			;	of "all routers"
	MOVL	#TR$C_NI_ALLEND1,(R3)+	;    Phase IV "all endnodes" multicast
	MOVW	#TR$C_NI_ALLEND2,(R3)+
20$:	SUBL3	(SP)+,R3,R2		; Compute size of additional params
	ADDL3	R5,DLLQIO$L_P2(R5),R1	; Point to P2 buffer descriptor
	ADDL	R2,(R1)			; Append these params to P2 buffer
	MOVL	#1,R0			; Success
	RSB

PLI_PPUNA_TAB:			; Parameter table for PPUNA pseudo-datalink
	.cnvtab	pcli,pli,BUS	; Receive buffer size
	.cnvtab	pcli,pli,CON	; Controller (loopback) mode
	.cnvtab	pcli,pli,BFN	; Number of buffers in pool
	.LONG	0		; Terminate the table

PLI_PPUNA:				; (used only for internal testing)
	MOVAB	PLI_PPUNA_TAB,R2	; Point to param translation table
	BSBW	BUILD_DEVBUF		; Build standard parameter buffer
	PUSHL	R3			; Save position in P2 buffer
	MOVW	#NMA$C_PCLI_PRO,(R3)+	; Protocol type = POINT
	MOVL	#NMA$C_LINPR_POI,(R3)+
	MOVW	#NMA$C_PCLI_PRM,(R3)+	; Promiscuous mode = OFF
	MOVL	#NMA$C_STATE_OFF,(R3)+
	MOVW	#NMA$C_PCLI_MLT,(R3)+	; Multicast address state = OFF
	MOVL	#NMA$C_STATE_OFF,(R3)+
	MOVW	#NMA$C_PCLI_PAD,(R3)+	; Padding on transmits = ON
	MOVL	#NMA$C_STATE_ON,(R3)+
	MOVW	#NMA$C_PCLI_DCH,(R3)+	; Data chaining = OFF
	MOVL	#NMA$C_STATE_OFF,(R3)+	; (DLLTRN can't handle multiple CXBs)
	MOVW	#NMA$C_PCLI_CRC,(R3)+	; CRC generation = ON
	MOVL	#NMA$C_STATE_ON,(R3)+
	MOVW	#NMA$C_PCLI_ACC,(R3)+	; Protocol access mode = limited
	MOVL	#NMA$C_ACC_LIM,(R3)+
	MOVW	#NMA$C_PCLI_DES,(R3)+	; Remote destination = (dead timer)
	MOVW	#8,(R3)+		;    8 byte string:
	MOVW	#NMA$C_LINMC_SET,(R3)+	;    Set the address
	MOVL	#TR$C_NI_PREFIX,(R3)+	;    Phase IV NI prefix
	$GETFLD	pli,l,ddt		; Get value of dead timer
	CMPZV	#TR4$V_ADDR_AREA,-	; Is area portion of address 0?
		#TR4$S_ADDR_AREA,R8,#0
	BNEQ	5$			; If not, set it as is
	MOVL	NET$GL_PTR_VCB,R7	;
	INSV	RCB$B_HOMEAREA(R7),-	; Else, insert our own area
		#TR4$V_ADDR_AREA,-
		#TR4$S_ADDR_AREA,R8	; (leave R8 set for code below)
5$:	MOVW	R8,(R3)+		;    Set remote destination address
	MOVW	#NMA$C_PCLI_PTY,(R3)+	; Protocol type parameter code
	$GETFLD	pli,l,ept		; Get protocol type to be used
	BLBS	R0,10$			; Branch if ok
	MOVZWL	#^XA002,R8		; Else, provide a default value
10$:	MOVL	R8,(R3)+		; Set protocol type
	MOVW	#NMA$C_PCLI_PHA,(R3)+	; Physical address = Phase IV address
	MOVW	#8,(R3)+		;    8 byte string:
	MOVW	#NMA$C_LINMC_SET,(R3)+	;    Set the address
	MOVL	#TR$C_NI_PREFIX,(R3)+	;    Phase IV NI prefix
	MOVL	NET$GL_PTR_VCB,R7	;
	MOVW	RCB$W_ADDR(R7),(R3)+	;    Phase IV node number
	SUBL3	(SP)+,R3,R2		; Compute size of additional params
	ADDL3	R5,DLLQIO$L_P2(R5),R1	; Point to P2 buffer descriptor
	ADDL	R2,(R1)			; Append these params to P2 buffer
	MOVL	#1,R0			; Success
	RSB

PLI_DMC:
	.IF NDF	DMC_MODEM		; Disallow controller functions if
					;  there is no modem support in DMC

	CLRL	R1			; Say "start with LPD index 0"
	BSBW	NET$GET_PLVECLPD	; Find next LPD actively using this line
	BLBS	R0,10$			; If LBS then found one
	BICW	#IO$M_SHUTDOWN,-	; Can't issue "SHUTDOWN" if device is
		DLLQIO$L_FUNC(R5)	; not active
10$:	BICW	#IO$M_STARTUP!-		; Special case -- DMC does not support
		 IO$M_CTRL,-		; these modifiers in for its "line"
		DLLQIO$L_FUNC(R5)	; aspect

	.ENDC	; DF DMC_MODEM

	SUBL3	R5,R3,DLLQIO$L_P1(R5)	; Setup offset to characteristics buffer
	MOVB	#DC$_SCOM,(R3)+		; Enter device class
	MOVB	#DT$_DMC11,(R3)+	; Enter device type
	;
	;   For now, all lines use the same buffer size.
	;
	BSBW	NET$PLI_L_BUS		; Get datalink buffer size
	MOVW	R1,(R3)+		; Store the block size
	CLRL	(R3)			; Zero the characteristis
	$GETFLD	pli,v,con		; Get loopback field value
	BLBC	R8,20$			; If LBC not in controller loopback
	SETBIT	XM$V_CHR_LOOPB,(R3)	; Else set loopback bit
	BRB	30$			; Don't bother with HDPLX
20$:	$GETFLD	pli,v,dup		; Get duplex selector
	BLBC	R8,30$			; LBS in R0 if half-duplex
	SETBIT	XM$V_CHR_HDPLX,(R3)	; Put line in half-duplex
30$:	TSTL	(R3)+			; Advance past characteristics
	MOVB	#1,R0			; Indicate success
	RSB				; Return status in R0

	.SBTTL	BUILD_DEVBUF - Build DLLQIO buffer
;+
; BUILD_DEVBUF - Build P2 buffer for SETMODE of line or circuit
;
; This routine is called to setup a standard P2 buffer for a line or
; circuit SETMODE function.  The P2 buffer contains all the datalink
; parameters for the line/circuit to be initialized.
;
; Inputs:
;
;	R11 = PLI CNR address
;	R10 = PLI CNF address
;	R5 = Address of DLLQIO buffer
;	R3 = Address of scratch buffer
;	R2 = Address of datalink parameter translation table (CNVTAB)
;
; Outputs:
;
;	R3 = Updated pointer to end of scratch buffer
;	R0 = Status code
;-

BUILD_DEVBUF:				; Build device param buffer
	MOVL	R3,DLLQIO$L_P2(R5)	; Setup pointer to device parameter
					; buffer descriptor
	ADDL	#8,R3			; Allow 8 bytes for the descriptor
	MNEGL	R3,@DLLQIO$L_P2(R5)	; Prepare for size calculation
	SUBL3	R5,R3,-4(R3)		; Setup offset to param buffer
	PUSHR	#^M<R4,R5,R6>		; Save regs
	MOVL	R2,R6			; Point to translation table

10$:	TSTL	(R6)			; At end of table?
	BEQL	40$			; If EQL then yes
	BBS	#CNVTAB$V_RO,(R6),30$	; Skip if should not send to driver
	MOVB	CNR$B_TYPE(R11),-(SP)	; Enter database i.d.
	EXTZV	#CNVTAB$V_FMT,-		; Get param format type
		#CNVTAB$S_FMT,(R6),R1	;
	MOVB	R1,-(SP)		; Append to param database i.d.
	EXTZV	#CNVTAB$V_INT,-		; Get internal param i.d. index
		#CNVTAB$S_INT,(R6),R1	;
	MOVW	R1,-(SP)		; Append param i.d.
	POPL	R9			; Get compelete param i.d., fix stack
	CMPW	R9,#CNVTAB$C_INTRNL	; Datalink only parameter?
	BEQL	30$			; If so, just ignore it
	BSBW	CNF$GET_FIELD		; Get the field value
	BLBC	R0,30$			; If LBC then param is not set
	EXTZV	#CNVTAB$V_NMA,-		; Get the NICE parameter code
		#CNVTAB$S_NMA,(R6),R0
	MOVW	R0,(R3)+		; Enter the NICE param i.d.
	CMPL	R1,#NFB$C_TYP_STR	; String ?
	BEQL	20$			; If EQL yes
	MOVL	R8,(R3)+		; Enter the parameter value
	BRB	30$			; Continue
20$:	MOVW	R7,(R3)+		; Enter the string length
	MOVC3	R7,(R8),(R3)		; Enter the string text, update R3
30$:	TSTL	(R6)+			; Advance to next table entry
	BRB	10$			; Loop
40$:	POPR	#^M<R4,R5,R6>		; Restore regs
	ADDL	R3,@DLLQIO$L_P2(R5)	; Complete size calculation
	SUBL	R5,DLLQIO$L_P2(R5)	; Convert pointer to offset
	MOVL	#SS$_NORMAL,R0		; Setup status
	RSB

	.SBTTL	NET$CVT_NMA_INT - Convert NMA to NFB code
;+
; NET$CVT_NMA_INT - Convert an NMA code returned by a datalink driver
; to a internal NFB parameter code.
;
; Inputs:	R11 = CNR address
;		R9 = NMA code
;
; Outputs:	R9 = NFB code corresponding to NMA code
;			(or original, if could not map the code)
;-
NET$CVT_NMA_INT::			; Convert NMA i.d. to internal i.d.
	PUSHR	#^M<R1,R2,R5>		; Save regs
	MOVAB	CRI_TRN_TAB,R5		; Assume CRI database
	CMPB	#NFB$C_DB_CRI,-		; Circuit database ?
		    CNR$B_TYPE(R11)	; 
	BEQL	10$			; If EQL then yes
	MOVAB	PLI_TRN_TAB,R5		; Else PLI database
10$:	BSBB	CVT_NMA_INT		; Convert the i.d.
	POPR	#^M<R1,R2,R5>		; Restore regs
	RSB

;
; Do the actual conversion of NMA to NFB parameter codes.
;
; Inputs:
;	R9 = NMA i.d. code, with format type
;	R5 = Conversion table address
;	
; Outputs:
;	R1 = Last table entry used (zero if end of table)
;	R0 = Status indicator
;
;	R2 is destroyed.
;

CVT_NMA_INT:				; Convert NMA i.d. to internal i.d.
	EXTZV	#0,#CNVTAB$S_NMA,R9,R2	; Get only NMA param i.d.
	CLRL	R0			; Assume conversion error
40$:	MOVL	(R5)+,R1		; Get next table entry
	BEQL	100$			; If EQL table is exhausted, report
					; that the driver is not supported
	ASSUME	NFB$V_INX	EQ   0
	ASSUME	NFB$V_TYP	EQ  16
	ASSUME	NFB$V_DB 	EQ  24

	CMPZV	#CNVTAB$V_NMA,-
		#CNVTAB$S_NMA,R1,R2	; Is this it?
	BNEQ	40$			; If NEQ then keep trying
	EXTZV	#CNVTAB$V_INT,-		;
		#CNVTAB$S_INT,R1,-(SP)	; Put internal code on stack longword
	EXTZV	#CNVTAB$V_FMT,-		; Get field format type
		#CNVTAB$S_FMT,R1,R2	; 
	MOVB	R2,2(SP)		; Insert format into TYP field
	MOVB	CNR$B_TYPE(R11),3(SP)	; Insert database id into DB field
	POPL	R9			; Get full field i.d., cleanup stack
	MOVL	#1,R0			; Indicate successful conversion
100$:	RSB

	.SBTTL	TRAN_DEVNAM - Translate device name
;+
; TRAN_DEVNAM	Translate Network Managment name to VMS device name
;
; This routine translates a network management line/circuit name to a VMS
; device name.  Network management line names have the format "dev-c-u" and
; circuit names have the format "dev-c-u.t"  where c,u,t are ascii-decimal 
; strings and "dev" is a network managment device numeric.
;
; INPUTS:	R8	Pointer to network management name
;		R7	Number of characters in name
;		R3	Output buffer pointer
;
; OUPUTS:	R8	Pointer to first unparsed character
;		R7	Number of unparsed characters
;		R6	Pointer to device table entry
;		R5,R4	Garbage
;		R3	Advanced by characters in translated name
;		R2,R1	Garbage
;		R0	Status
;
;		All other regs are perserved
;-
TRAN_DEVNAM:
	;
	;   Parse the device mnemonic, locate translation table entry
	;
	BSBB	PRS_MNEMONIC		; Parse name, locate entry in table
	BLBC	R0,110$			; If LBC then error
	MOVC3	R2,(R1),(R3)		; Move the VMS device mnemonic
	CMPB	DEVTRN$B_DEV(R6),#DEVTRN$C_DEV_X25 ; X25 circuit name?
	BEQL	40$			; If so, then use only device name
	;
	;			 dev-c-u.t
	;   We've parsed up to here  ^	   Translate the controller specifier.
	;
	MOVZBL	#^A".",R4		; Setup field delimiter for single-unit
					; device (i.e., no unit field)
	BBC	#DEVTRN$V_MULTI,-	; If BC then not multi-unit device
		 DEVTRN$B_CHAR(R6),20$	; and there's no unit field
	MOVZBL	#^A"-",R4		; Setup field delimiter
20$:	BSBB	PRS_DECIMAL		; Convert the controller to binary
	BLBC	R0,110$			; If LBC then error
	TSTL	R2			; Any decimal characters parsed ?
	BEQL	100$			; If EQL no, illegal name
	CMPB	R1,#25			; Within range (0=A, 25=Z)
	BGTRU	100$			; If GTRU then out of range
	ADDB3	#^A"A",R1,(R3)+		; Store as VMS controller designator
	;
	;				dev-c-u.t
	;   We have parsed up to here         ^      Parse the unit number.  
	;
	CLRL	R0			; Assume single-unit device
	BBC	#DEVTRN$V_MULTI,-	; If BC then single-unit device and
		 DEVTRN$B_CHAR(R6),30$	; there's no unit field
	MOVZBL	#^A".",R4		; Setup field delimiter
	BSBB	PRS_DECIMAL		; Convert the Ascii unit to binary
	BLBC	R0,110$			; If LBC then illegal name
	MOVL	R1,R0			; Get the binary value
30$:	BSBW	NET$BIN2ASC		; Move to @R3 as Ascii
40$:	MOVL	#SS$_NORMAL,R0		; Indicate success
	BRB	110$			; Take common exit

100$:	MOVZWL	#SS$_IVDEVNAM,R0	; Error in translated name
110$:	RSB				; Return status in R0

	.SBTTL	PRS_MNEMONIC - Parse device mnemonic
;+
; PRS_MNEMONIC	- Parse device mnemonic
;
; INPUTS:	R8	Pointer to device name
;		R7	Characters left in device name string
;
; OUTPUTS:	R8	Advanced by characters parsed
;		R7	Reduced by characters parsed
;		R6	Pointer to device table entry
;		R5	Size of network management device mnemonic
;		R4	Pointer to network management device mnemonic
;		R2	Size of VMS device mnemonic
;		R1	Pointer to VMS device mnemonic
;		R0	SS$_NORMAL    if successful
;			SS$_IVDEVNAM  otherwise
;	
;		All other regs are unchanged
;-
PRS_MNEMONIC:
	PUSHL	R3		        ; Save reg
	;
	;   Parse the device mnemonic
	;
	MOVZWL	#SS$_IVDEVNAM,R0	; Assume error in name format
	MOVL	R8,R4			; Make a copy of the name pointer
	MNEGL	#1,R5			; Init the character count
10$:	INCL	R5			; Update the character count
	SOBGTR	R7,20$			; If GTR then more characters are left
	BRW	100$			; Take common exit to report the error
20$:	CMPB	(R8)+,#^A"-"		; Mnemonic delimiter ?
	BNEQ	10$			; If NEQ then keep trying
	;
	;   Locate the table entry
	;
	MOVAB	DEVTRN_TABLE-DEVTRN$C_LENGTH,R6 ; Prepare to scan device table
30$:	ADDL	#DEVTRN$C_LENGTH,R6	; Advance to next entry
	MOVZBL	DEVTRN$B_NETMAN(R6),R1	; Get length of network management name
	BEQL	40$			; If EQL then at end of table
	CMPL	R1,R5			; Same size ?
	BNEQ	30$			; If NEQ no, advance to next entry
	CMPC	R5,(R4),-		; Is this it ?
		    DEVTRN$T_NETMAN(R6)	;
	BNEQ	30$			; If NEQ then loop
	MOVZBL	DEVTRN$B_VMS(R6),R2	; Setup length of VMS mnemonic
	MOVAB	DEVTRN$T_VMS(R6),R1	; Setup pointer to mnemonic 
	BRB	50$			; Take common exit
40$:	MOVQ	R4,R1			; Make a copy of the Net Man. mnemonic
50$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
100$:	POPL	R3			; Restore R3
	RSB				; Return status in R0

	.SBTTL	PRS_DECIMAL - Parse decimal number
;+
; PRS_DECIMAL	- Convert Ascii decimal number to a binary value
;
; INPUTS:	R7	Count of characters remaining in the string
;		R8	Address of string
;		R4	Field delimiter
;
; OUTPUTS:	R8	Advanced by characters parsed
;		R7	Reduced by characters parsed
;		R2	Number of numeric characters parsed
;		R1	Binary value
;		R0	SS$_NORMAL     if successful
;			SS$_INVDEVNAM  otherwise
;-
PRS_DECIMAL:				; Parse/convert ascii decimal to binary
	CLRQ	R1			; Init binary value, character count
10$:	DECL	R7			; Account for next character
	BLSS	15$			; If LSS then done
	MOVZBL	(R8)+,R0		; Get next character
	CMPB	R4,R0			; Is it the delimiter?
	BEQL	20$			; If EQL then done
	SUBB	#^A"0",R0		; Convert to binary
	BLSS	30$			; If LSS then not decimal
	CMPB	R0,#9			; Decimal ?
	BGTRU	30$			; If GTRU not decimal
	INCL	R2			; Bump number of digits
	MULL	#10,R1			; Shift total one digit
	BVS	30$			; If VS then R1 has overflowed
	ADDL	R0,R1			; Complete the sum
	BRB	10$			; Loop
15$:	CLRL	R7			; Repair R7
20$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
	BRB	40$			; Take common exit
30$:	MOVZWL	#SS$_IVDEVNAM,R0	; Indicate invalid device name
40$:	RSB				; Return status in R0

	.SBTTL	DEV_CNT_QIO - Get device counters
;+
; DEV_CNT_QIO   - Get counters from device driver
;
; INPUTS:	R3	Address of next byte in output buffer
;		R2	Channel to device driver
;		R0	$QIO function code
;
; OUTPUTS:	R3	Updated to next free byte in output buffer
;		R0	SS$_NORMAL
;
;		R1-R2,R4-R5 are destroyed.
;-
DEV_CNT_QIO:
	MOVL	R3,R4			; Save output buffer pointer
	BBC	#NET$V_CLRCNT,-		; If BC, don't clear the counters
		    NET$GL_FLAGS,20$	;
	BISW	#IO$M_CLR_COUNT,R0	; Else clear the counters
20$:	CLRQ	QIOW_Q_IOSB		; Init IOSB image
	MOVAB	TMPBUF_DESC,R1		; Get address of TMP_BUF descriptor
	MOVAB	TMP_Q_DESC,R5		; Get address of our buffer descriptor
	ADDL3	(R1),4(R1),(R5)		; Get ending buffer address
	SUBL	R3,(R5)			; Setup bytes left in buffer
	MOVL	R3,4(R5)		; Point to it
	$QIOW_S	FUNC = R0,-
		CHAN = R2,-
		EFN  = #NET$C_EFN_WAIT,-
		IOSB = QIOW_Q_IOSB,-
		P2   = R5
	MOVZWL	QIOW_Q_IOSB+2,R0	; Get number of bytes returned
	BEQL	90$			; If EQL then none
	ADDL	R0,R3			; Advance R3
	CMPL	#4,R0			; At least 4 bytes ?
	BGTR	90$			; If GTR no, return all bytes
	CMPW	(R4),#NET$C_NMACNT_SLZ 	; Seconds since last zeroed ?
	BNEQ	90$			; If NEQ no, return whats left
	SUBL	#4,R0			; Reduce by size of counter field
	MOVC3	R0,4(R4),(R4)		; Shift remaning counters, setup R3
90$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
	RSB				; Done

.END
