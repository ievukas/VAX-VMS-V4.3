	.TITLE	SYSENQDEQ - ENQUEUE/DEQUEUE SYSTEM SERVICES
	.IDENT	'V04-000'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT: 
;	This module implements the $ENQ, $ENQW, and $DEQ system services.
;
; ENVIRONMENT: VAX/VMS
;
; AUTHOR: Steve Beckhardt,	 CREATION DATE: 30-Oct-1980
;
; MODIFIED BY:
;
;	V03-029	SRB0151		Steve Beckhardt			21-Aug-1984
;		Fixed bug in "parent not granted" code to avoid spurious
;		errors.
;
;	V03-028	SRB0144		Steve Beckhardt			9-Aug-1984
;		Fix broken branch.
;
;	V03-027	SRB0141		Steve Beckhardt			6-Aug-1984
;		Changed the way system-owned locks are determined in
;		VERIFYLOCKID to remove race condition that gave incorrect
;		SS$_IVLOCKID errors.
;
;	V03-026	SRB0139		Steve Beckhardt			24-Jul-1984
;		Added new entry point, LCK$CHECK_STALL to allow $GETLKI
;		(and others) to stall during state transitions.
;
;	V03-025	SRB0137		Steve Beckhardt			11-Jul-1984
;		Remove race conditions from dequeue/all code.
;
;	V03-024	SRB0133		Steve Beckhardt			22-Jun-1984
;		Fixed two bugs:  1)  Don't lose lock mode in conversion code 
;		when an AST is already queued.  2)  Check CVTSYS bit of parent
;		lock when converting a lock to system owned instead of
;		looking for a zero PID.
;
;	V03-023	SRB0132		Steve Beckhardt			25-May-1984
;		Allowed parent locks to be in CONVERT state when $ENQing
;		sublocks.
;
;	V03-022	SRB0126		Steve Beckhardt			9-May-1984
;		Fixed bug whereby locks that were system owned that
;		were not successfully converted no longer had the
;		LCK$M_CVTSYS bit set.
;
;	V03-021	CWH3021 	CW Hobbs			14-Apr-1984
;		Fixed some broken branches.
;
;	V03-020	SRB0119		Steve Beckhardt			6-Apr-1984
;		Changed access mode checking on lock ids.  Reorganized
;		code involved in cancelling conversions and fixed bug.
;		Added support for LCK$M_NODLCKWT flag.
;
;	V03-019	SRB0116		Steve Beckhardt			8-Mar-1984
;		Return status code in LCK$DEQLOCK, change all SETIPL #0
;		to SETIPL #IPL$_ASTDEL, and fix two broken word displacements.
;
;	V03-018	LJK0264		Lawrence J. Kenah		29-Feb-1984
;		Fix broken word displacements.
;
;	V03-017	SRB0108		Steve Beckhardt			11-Jan-1983
;		Added support for hashed root directory.  
;
;	V03-016	SRB0106		Steve Beckhardt			6-Dec-1983
;		Changed LKB$L_REFCNT, RSB$L_REFCNT, RSB$L_BLKASTCNT
;		to word fields.
;
;	V03-015	SRB0101		Steve Beckhardt			7-Sep-1983
;		Fixed bug that prevented canceling locks with sublocks.
;
;	V03-014	SRB0100		Steve Beckhardt			18-Jul-1983
;		Enabled local deadlock detection.  Fixed PMS counters.
;		Fixed code for canceling locks and use of routine FREE_LKB.
;
;	V03-013	SRB0094		Steve Beckhardt			23-Jun-1983
;		Added support for PROTECT and RECOVER bits.  Added support
;		for converting new locks to be system owned.  Made several
;		changes to support multinode failover.
;
;	V03-012	SRB0090		Steve Beckhardt			20-May-1983
;		Added support for extending lock id. table.  Moved some
;		PMS counters and added new ones.  Cleared CVTSYS bit instead
;		of ignoring it to fix bug involving system owned locks.
;		Added support for stalling requests during a failover.
;
;	V03-011	SRB0083		Steve Beckhardt			29-Apr-1983
;		Added support for system owned locks.  Rewrote portions
;		of the conversion and dequeue code.
;
;	V03-010	SRB0073		Steve Beckhardt			25-Mar-1983
;		Added support for two new $DEQ flags:  CANCEL and INVVALBLK.
;
;	V03-009	SRB0069		Steve Beckhardt			7-Mar-1983
;		Changed HALT to BUG_CHECK.  Modified handling of value blocks
;		on conversions to return value block on conversions to same
;		lock mode.  Changed access mode handling to deliver ASTs in
;		mode of caller.  Added support for LCK$M_NOQUOTA flag.
;		Added conditionals around .PSECTS to allow loading for
;		debugging.
;
;	V03-008	RNG0008		Rod N. Gamache			2-Feb-1983
;		Changed paged PSECT to Y$EXEPAGED PSECT.
;
;	V03-007	SRB0061		Steve Beckhardt			7-Jan-1983
;		Added support for distributed lock conversions.
;
;	V03-006	SRB0057		Steve Beckhardt			15-Dec-1982
;		Added support for distributed $ENQ of new locks, 
;		distributed $DEQ, blocking ASTs, root directory
;		handling, etc.
;
;	V03-005	SRB0055		Steve Beckhardt			6-Oct-1982
;		Fixed a number of small things that prevented service from
;		being loadable.  Added coded to dequeue subtrees.
;
;	V03-004	SRB0053		Steve Beckhardt			6-Oct-1982
;		Fixed bug causing improper handling of common event flags
;		on conversions.
;
;	V03-003	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF and $SSDEF.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;
	$ACBDEF				; ACB offsets
	$CADEF				; Conditional assembly switches
	$DYNDEF				; Structure type code definitions
	$IPLDEF				; IPL definitions
	$IRPDEF				; IRP offsets
	$JIBDEF				; JIB offsets
	$LCKDEF				; LCK definitions
	$LKBDEF				; LKB offsets
	$PCBDEF				; PCB offsets
	$PRDEF				; Processor register definitions
	$PRIDEF				; Priority increment class definitions
	$PRVDEF				; Privilege bits
	$PSLDEF				; PSL definitions
	$RSBDEF				; RSB offsets
	$RSNDEF				; Resource numbers
	$SSDEF				; System status code definitions
;
; EQUATED SYMBOLS:
;

;
; Enqueue system service argument list offsets:
;

EFN = 4					; Event flag number
LKMODE = 8				; Lock mode
LKSB = 12				; Lock status block address
FLAGS = 16				; Flags
RESNAM = 20				; Resource name
PARID = 24				; Parent id
ASTADR = 28				; AST routine address
ASTPRM = 32				; AST routine parameter
BLKAST = 36				; Blocking AST address
ACMODE = 40				; Access mode
PROT = 44				; Protection mask

;
; Dequeue system service argument list offsets
;

LOCKID = 4				; Lock id
VALBLK = 8				; Value block address
DEQ_ACMODE = 12				; Access mode
DEQ_FLAGS = 16				; Flags

POOL_MASK = ^XF				; Pool allocation granularity mask

;
; OWN STORAGE:
;

	.IF NDF	LOADSW
	.PSECT	LOCKMGR,LONG
	.IFF
	.PSECT	$$$020
	.ENDC

;
;		LOCK MODE COMPATIBILITY TABLE
;
;
; The lock mode compatibility table represents the following
; compatibility matrix.
;
;
;	         |   NL  |   CR  |   CW  |   PR  |   PW  |   EX
;	         | NL/SW |  R/SW |  W/SW |  R/SR |  W/SR |  W/NL   
;	---------+-------+-------+-------+-------+-------+-------
;	NL NL/SW |  yes  |  yes  |  yes  |  yes  |  yes  |  yes
;	---------+-------+-------+-------+-------+-------+-------
;	CR  R/SW |  yes  |  yes  |  yes  |  yes  |  yes  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	CW  W/SW |  yes  |  yes  |  yes  |   no  |   no  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	PR  R/SR |  yes  |  yes  |   no  |  yes  |   no  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	PW  W/SR |  yes  |  yes  |   no  |   no  |   no  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	EX  W/NL |  yes  |   no  |   no  |   no  |   no  |   no   
;
; The compatibility table makes the following assumptions regarding
; the values of the lock modes.  These values cannot be changed without
; changing the table

	ASSUME	LCK$K_NLMODE  EQ  0
	ASSUME	LCK$K_CRMODE  EQ  1
	ASSUME	LCK$K_CWMODE  EQ  2
	ASSUME	LCK$K_PRMODE  EQ  3
	ASSUME	LCK$K_PWMODE  EQ  4
	ASSUME	LCK$K_EXMODE  EQ  5

LCK$COMPAT_TBL::
	.BYTE	^B 111111
	.BYTE	^B 011111
	.BYTE	^B 000111
	.BYTE	^B 001011
	.BYTE	^B 000011
	.BYTE	^B 000001

;
;		SYNCHRONOUS CONVERSION TABLE
;
; This table indicates which conversions are always synchronous as
; oppposed to those which may be asynchronous.
;
;				TO
;
;	         |   NL  |   CR  |   CW  |   PR  |   PW  |   EX
;	         | NL/SW |  R/SW |  W/SW |  R/SR |  W/SR |  W/NL   
;	---------+-------+-------+-------+-------+-------+-------
;	NL NL/SW |  yes  |   no  |   no  |   no  |   no  |   no
;	---------+-------+-------+-------+-------+-------+-------
;	CR  R/SW |  yes  |  yes  |   no  |   no  |   no  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	CW  W/SW |  yes  |  yes  |  yes  |   no  |   no  |   no   
; FROM	---------+-------+-------+-------+-------+-------+-------
;	PR  R/SR |  yes  |  yes  |   no  |  yes  |   no  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	PW  W/SR |  yes  |  yes  |  yes  |  yes  |  yes  |   no   
;	---------+-------+-------+-------+-------+-------+-------
;	EX  W/NL |  yes  |  yes  |  yes  |  yes  |  yes  |  yes   

LCK$SYNCCVT_TBL::
	.BYTE	^B 000001
	.BYTE	^B 000011
	.BYTE	^B 000111
	.BYTE	^B 001011
	.BYTE	^B 011111
	.BYTE	^B 111111

	.SBTTL	EXE$ENQ - Enqueue system service

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles the $ENQ system service.
;
; CALLING SEQUENCE:
;
;	CALLS/G	EXE$ENQ (actually called through the system service
;	dispatcher)
;
; INPUT PARAMETERS:
;
;	EFN(AP)		Event flag number
;	LKMODE(AP)	Lock mode
;	LKSB(AP)	Address of lock status block
;	FLAGS(AP)	Flags
;	RESNAM(AP)	Address of descriptor of resource name
;	PARID(AP)	Parent lock id
;	ASTADR(AP)	Address of completion AST routine
;	ASTPRM(AP)	AST parameter
;	BLKAST(AP)	Address of blocking AST routine
;	PROT(AP)	Protection mask
;	ACMODE(AP)	Access mode
;
;	R4		Address of PCB
;
; OUTPUT PARAMETERS:
;
;	R0		Completion code
;
; COMPLETION CODES:
;
;   In R0:
;
;	SS$_NORMAL		Successful completion
;	SS$_SYNCH		Synchronous successful completion
;	SS$_ACCVIO		Access violation (on LKSB or resource name)
;	SS$_BADPARAM		Bad lock mode
;	SS$_IVLOCKID		Invalid lock id
;	SS$_CVTUNGRANT		Attempted to convert an ungranted lock
;	SS$_PARNOTGRANT		Parent lock not granted
;	SS$_NOSYSLCK		No SYSLCK privilege (needed for a system lock)
;	SS$_IVBUFLEN		Resource name length = 0 or > 31
;	SS$_INSFMEM		Insufficient dynamic memory
;	SS$_EXASTLM		Exceeded AST quota
;	SS$_EXENQLM		Exceeded enqueue quota
;	SS$_NOTQUEUED		Request was not queued
;	SS$_EXDEPTH		Exceeded allowed depth of resource name tree
;	SS$_NOPRIV		No privilege (to not charge quota or convert to
;				system owned lock)
;	SS$_SUBLOCKS		Attempted to convert a system owned lock with 
;				sublocks
;	SS$_PARNOTSYS		Parent lock not system owned
;
;   In LKSB:
;
;	SS$_NORMAL		Successful completion
;	SS$_DEADLOCK		Deadlock detected
;	SS$_ABORT		Lock was dequeued before being granted
;	SS$_CANCEL		Lock request was canceled before being granted
;
;--

	.IF NDF	LOADSW
	.PSECT	Y$EXEPAGED
	.ENDC

	.ENABL	LSB

5$:	JSB	G^SCH$GETEFC		; Validate common event flag
	MOVL	EFN(AP),R3		; Refetch event flag number
	BLBS	R0,10$			; Rejoin common code
	RET				; Return - bad event flag

	.IF NDF	LOADSW
	.ENTRY	EXE$ENQ,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	.IFF
	.ENTRY	EXE$$ENQ,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	.ENDC

	; Verify event flag is ok

	MOVL	EFN(AP),R3		; Get event flag number
	CMPB	R3,#63			; Is it a local event flag?
	BGTRU	5$			; No - validate common event flag

10$:	; Probe lock status block.  For performance reasons, we assume the
	; presence of a value block and probe 24 bytes.  If this fails,
	; then we check to see if there isn't a value block and in
	; that case probe 8 bytes.

	ASSUME	FLAGS  EQ  LKSB+4
	ASSUME	LCK$V_VALBLK  EQ  0

	MOVQ	LKSB(AP),R8		; Get address of lock status block in 
					; R8 and get flags in R9
	IFWRT	#24,(R8),20$		; Branch if writable
	BLBS	R9,60$			; Error if there's a value block
	IFNOWRT	#8,(R8),60$		; No value block - br. if not writable

20$:	; Get lock mode and check for legality

	MOVZBL	LKMODE(AP),R7		; Get lock mode
	CMPB	R7,#LCK$K_EXMODE	; Is it legal?
	BGTRU	70$			; No - error

	; Determine if this is a new lock request or a conversion

	BITW	#LCK$M_CONVERT,R9	; Is convert bit set?

	.IF NDF	LOADSW
	BEQL	NEW_LOCK		; Branch if new lock
	JMP	G^CONVERSION		; Conversion
	.IFF
	BNEQ	CONVERSION		; Branch if conversion
	BRW	NEW_LOCK		; New lock
	.ENDC

;
; ERRORS:
;

60$:	BRW	ACCVIO			; Couldn't access LKSB

70$:	MOVZWL	S^#SS$_BADPARAM,R0	; Bad lock mode
	JMP	ERROR_EXIT_R0

	.DSABL	LSB

	.SBTTL	CONVERSIONS

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles lock mode conversions.
;
; CALLING SEQUENCE:
;
;	Branched to from $ENQ service
;	RET back to caller
;
; INPUTS:
;
;	R3	Event flag number
;	R4	Address of PCB
;	R7	Lock mode
;	R8	Address of LKSB
;	R9	Flags
;
;	Caller's argument list (offsets from AP)
;
; OUTPUTS:
;
;	R0	Completion code
;
; IMPLICIT OUTPUTS:
;
;	Caller's lock status block gets final request status (perhaps
;	aynchronously)
;
; COMPLETION CODES:
;
;   In R0:
;
;	SS$_NORMAL		Successful completion
;	SS$_SYNCH		Synchronous successful completion
;	SS$_IVLOCKID		Invalid lock id
;	SS$_CVTUNGRANT		Attempted to convert an ungranted lock
;	SS$_INSFMEM		Insufficient dynamic memory
;	SS$_EXASTLM		Exceeded AST quota
;	SS$_NOTQUEUED		Request was not queued
;	SS$_NOPRIV		No privilege (to convert to system owned lock)
;	SS$_SUBLOCKS		Attempted to convert a system owned lock with 
;				sublocks
;	SS$_PARNOTSYS		Parent lock not system owned
;
;   In LKSB:
;
;	SS$_NORMAL		Successful completion
;	SS$_DEADLOCK		Deadlock detected
;	SS$_ABORT		Lock was dequeued before being granted
;	SS$_CANCEL		Lock request was canceled before being granted
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABL	LSB

;
; Errors:
;

8$:	MOVZWL	#SS$_RETRY,R0		; Retry operation
	BRB	12$
10$:	MOVZWL	#SS$_CVTUNGRANT,R0	; Lock not currently granted
12$:	BRW	ERROR_EXIT_R0

14$:	BBS	#LKB$V_DCPLAST,R7,16$	; Branch if queued for completion AST
	PUSHL	R5			; Save lock mode
	MOVL	R6,R5			; Queued for blocking AST only
	JSB	G^SCH$REMOVACB		; Remove it
	POPL	R5			; Restore lock mode
	BRB	21$			; Continue with conversion
16$:	SETIPL	#IPL$_ASTDEL		; Lower IPL
	JSB	FREE_LKB		; Free up LKB
	BRB	15$			; Returns at IPL$_SYNCH

17$:	; Stalling some requests - see which ones

	BLSS	18$			; Stalling all requests
	BBC	#LKB$V_PROTECT,-	; Stalling only protected locks
		LKB$W_STATUS(R6),19$	; Branch if this is not a protected lock
	BBS	#PCB$V_RECOVER,-	; Don't stall recovery process,
		PCB$L_STS(R4),8$	; return error instead
18$:	BRW	STALL_REQ		; Stall this request

CONVERSION:
	; First get input arguments into registers (and on stack) because
	; when they're stored we'll be at IPL$_SYNCH.

	ASSUME	ASTPRM  EQ  ASTADR+4
	ASSUME	LCK$V_VALBLK  EQ  0

	MOVL	R7,R5			; Move lock mode to R5
	MOVQ	ASTADR(AP),R10		; Fetch completion AST address (R10)
					; and AST parameter (R11)
	MOVL	BLKAST(AP),R2		; Fetch blocking AST address (R2)
	BLBC	R9,15$			; Branch if no value block
	MOVQ	16(R8),-(SP)		; Copy caller's value block onto stack
	MOVQ	8(R8),-(SP)

15$:	; Get lock id, validate and convert to LKB address in R6.
	; Note that our raising IPL to IPL$_SYNCH is tied to the assumptions
	; stated in the routine FREE_LKB.

	MOVL	4(R8),R1		; Fetch lock id
	SETIPL	#IPL$_SYNCH		; Raise IPL
	BSBW	VERIFYLOCKID		; Verify lock id and return LKB in R6,
					; caller's access mode in R1
	BLBC	R0,12$			; Error

	; Verify that we aren't stalling lock requests.

	TSTB	G^LCK$GB_STALLREQS	; Are we stalling requests?
	BNEQ	17$			; Yes, see which ones

19$:	; Verify lock is granted and that the LKB is not queued to deliver 
	; an AST.  If ok, store input args in LKB.

	ASSUME	LKB$W_STATUS  EQ  LKB$W_FLAGS+2
	ASSUME	LKB$K_GRANTED  GT  0
	ASSUME	LKB$L_BLKASTADR  EQ  LKB$L_CPLASTADR+4

	TSTB	LKB$B_STATE(R6)		; Is the lock currently granted?
	BLEQ	10$			; No - error
	MOVZWL	LKB$W_STATUS(R6),R7	; Pick up current status
	BITW	#LKB$M_DCPLAST-		; Is the ACB portion of the LKB in use?
		!LKB$M_DBLKAST,R7	; (are we delivering a completion or
	BNEQ	14$			; blocking AST?).  Branch if yes.
21$:	BICW	#LKB$M_DCPLAST-		; Clear relevant status bits
		!LKB$M_DBLKAST-		; The following bits retain their
		!LKB$M_ASYNC-		; old state:
		!LKB$M_BLKASTQED-	;	MSTCPY (shouldn't be set)
		!LKB$M_TIMOUTQ-		;	NOQUOTA
		!LKB$M_WASSYSOWN-	;	PROTECT
		!LKB$M_CVTTOSYS,-
		LKB$W_STATUS(R6)
	MOVB	R3,LKB$B_EFN(R6)	; Store event flag number
	MOVL	R8,LKB$L_LKSB(R6)	; Store LKSB address
	MOVL	LKB$L_RSB(R6),R8	; Get RSB address in R8

	; Determine if we need to convert this lock to system owned or
	; process owned.  R1 contains caller's acccess mode.

	MOVZBL	LKB$B_GRMODE(R6),R3	; Save old granted mode
	TSTL	LKB$L_PID(R6)		; Is lock currently system owned?
	BEQL	22$			; Yes
	BBC	#LCK$V_CVTSYS,R9,25$	; No, handle normally if CVTSYS is clear
	BBC	R5,LCK$SYNCCVT_TBL[R3],24$ ; Clear CVTSYS flag if async. cvt.
	BSBW	CVT_TO_SYS		; Convert to system owned lock
26$:	BISW	#LCK$M_SYNCSTS,R9	; CVTSYS implies SYNCSTS so set it
	BRB	25$
22$:	BBC	R5,LCK$SYNCCVT_TBL[R3],23$ ; Cvt to process owned if async. cvt
	BBS	#LCK$V_CVTSYS,R9,26$	; Leave as is if CVTSYS flag is set
23$:	BSBW	CVT_TO_PRC		; Convert to process owned lock
24$:	BBSC	#LCK$V_CVTSYS,R9,25$	; Clear CVTSYS flag, ignore branch

25$:	; All error checking and conversion between system owned and process
	; owned has been performed.  Store new AST addresses and parameter.

	MOVL	LKB$L_BLKASTADR(R6),-	; Save old blocking AST address
		LKB$L_OLDBLKAST(R6)
					; Note:  This tests the old contents
					; of this field and must come before
					; the new contents are stored.
	BEQL	30$			; No
	MOVL	LKB$L_ASTPRM(R6),-	; Save old AST parameter
		LKB$L_OLDASTPRM(R6)
	DECW	RSB$W_BLKASTCNT(R8)	; Decr. blocking AST count
30$:	MOVL	R11,LKB$L_ASTPRM(R6)	; Store new AST parameter 
	MOVL	R2,R11			; Move blocking AST address
	MOVQ	R10,LKB$L_CPLASTADR(R6)	; Store new completion AST address (R10)
					; and new blocking AST address (R11)
	MOVW	R9,LKB$W_FLAGS(R6)	; Store flags 
	MOVL	R5,R1			; Move requested lock mode
	MOVL	R3,R11			; Move granted lock mode

	; If a value block is specified and we are converted down (or same)
	; from PW or EX, then store caller's value block in RSB.

	BLBC	R9,33$			; Branch if no value block specified
	CMPB	R11,#LCK$K_PWMODE	; Is granted mode PW or higher?
	BLSSU	33$			; No
	CMPB	R1,R11			; Is conversion to a higher lock mode?
	BGTRU	33$			; Yes
	MOVQ	(SP),RSB$Q_VALBLK(R8)	; No, copy caller's value block to RSB
	MOVQ	8(SP),RSB$Q_VALBLK+8(R8)
	INCL	RSB$L_VALSEQNUM(R8)	; Increment value block sequence number
	BICW	#RSB$M_VALINVLD,-	; Validate value block
		RSB$W_STATUS(R8)

33$:	; If this is a process copy LKB then jump to distributed lock
	; code.

	MOVL	RSB$L_CSID(R8),R3	; Get CSID of destination system
	BNEQ	35$			; Yes

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQCVT_LOC
	.ENDC

LCK$LOCAL_CVT::
	; Remove this lock from the granted queue.  If it was the only one and
	; if the conversion queue is also empty, then the conversion request 
	; can be granted immediately.  This path is special cased because it
	; is the normal case.

	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from granted queue
	BNEQ	40$			; Not the only one
	MOVAL	RSB$L_CVTQFL(R8),R10	; It's the only granted lock
	CMPL	(R10),R10		; Is conversion queue empty?
	BNEQ	40$			; It's not - must check the longer way
	BSBW	LCK$GRANT_LOCK_ALT	; It is - grant lock
	ADDL	#8,R10			; Point to wait queue
	CMPL	(R10),R10		; Is wait queue empty?
	BEQL	60$			; Yes, exit with completion status in R0
	MOVL	R0,R10			; No, save status in R10
	BSBW	LCK$GRANTWTRS		; Try granting waiting locks
	BRB	50$			; Exit with completion status in R10

35$:	JMP	G^LCK$SND_CVTREQ	; Send convert request

	; Possible return points are:
	;
	;	LCK$CVT_GRANTED		Conversion was granted
	;	LCK$QUEUE_EXIT		Conversion was queued
	;	LCK$CVTNOTQED		Conversion was not queued
	;	LCK$LOCAL_CVT		Remote system failed and conversion
	;				should now be done locally

40$:	; There was at least one other holder of the resource so we have
	; to check for compatibility the longer way.  The granted mode
	; of this lock is compared with the conversion grant mode.  If,
	; other than the head of the conversion queue, there are granted
	; locks with higher lock modes than this lock, then there
	; is no need to recompute the group grant mode or attempt to
	; grant waiting conversions.

	CMPB	R11,RSB$B_CGMODE(R8)	; Is granted mode = conv. grant mode?
	BEQL	45$			; Yes
	MOVZBL	RSB$B_GGMODE(R8),R5	; No, get group grant mode
	BBC	R1,LCK$COMPAT_TBL[R5],80$ ; Branch if not compatible
	BSBW	LCK$GRANT_LOCK		; Grant the lock
	BRB	60$			; Exit with completion status in R0

45$:	BSBW	LCK$COMP_GGMODE		; Compute new group grant mode in R5
	BBC	R1,LCK$COMPAT_TBL[R5],80$ ; Branch if not compatible 
	MOVB	R5,RSB$B_GGMODE(R8)	; Store group grant mode in RSB
	MOVB	R5,RSB$B_CGMODE(R8)	; Also store conversion grant mode
	BSBW	LCK$GRANT_LOCK		; Grant lock
	MOVL	R0,R10			; Save completion status in R10
	BSBW	LCK$GRANTCVTS		; Try granting conversions and waiters
50$:	MOVL	R10,R0			; Restore completion status to R0

60$:	; The conversion was performed synchronously.  Completion
	; status is in R0.  If a value block is specified then 
	; if we converted up or to the same level at NL - PR then
	; return value block to caller.

	ASSUME	LCK$V_VALBLK  EQ  0

LCK$CVT_GRANTED::
	BLBC	R9,75$			; Branch if no value block specified
	CMPB	LKB$B_GRMODE(R6),R11	; Was conversion to a lower lock mode?
	BLSSU	75$			; Yes, don't return value block
	BGTRU	65$			; Cvted to a higher mode; return valblk
	CMPB	R11,#LCK$K_PWMODE	; Was old mode PW or higher?
	BGEQU	75$			; Yes, don't return value block
65$:	BRW	LCK$RET_VALBLK		; No, return value block to caller
75$:	BRW	LCK$NORET_VALBLK

80$:	; The conversion cannot be granted.  Queue the request
	; unless the noqueue bit is set.  If the conversion queue is empty 
	; then R5 contains the new conversion grant mode.

	BBS	#LCK$V_NOQUEUE,R9,85$	; Branch if noqueue is set

	; Queue the conversion

	MOVB	R1,LKB$B_RQMODE(R6)	; Store requested mode
	BSBW	LCK$QUEUECVT		; Insert onto conversion queue, etc.
	BRW	LCK$QUEUED_EXIT

85$:	; The request is not to be queued.  Insert back onto the
	; granted queue.  R7 contains old LKB$W_STATUS.

	INSQUE	LKB$L_SQFL(R6),-	; Put lock back on granted queue
		RSB$L_GRQFL(R8)
LCK$CVTNOTQED::
	; Restore old blocking AST address and parameter and requeue
	; a blocking AST, if necessary.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNOTQD
	.ENDC

	MOVL	LKB$L_OLDBLKAST(R6),-	; Restore old blocking AST address 
		LKB$L_BLKASTADR(R6)
	BEQL	95$			; None specified
	MOVL	LKB$L_OLDASTPRM(R6),-	; Restore old AST parameter
		LKB$L_ASTPRM(R6)
	INCW	RSB$W_BLKASTCNT(R8)	; Incr. blocking AST count
	BBC	#LKB$V_DBLKAST,R7,95$	; Branch if blocking AST wasn't queued
	MOVL	R6,R5
	BSBW	QUEUE_BLKAST		; Requeue blocking AST
	BRB	98$			; Couldn't be system owned if a blocking
					; AST was queued.

95$:	; Now convert lock back to system owned, if necessary

	BBC	#LKB$V_WASSYSOWN,-	; Branch if it wasn't system owned
		LKB$W_STATUS(R6),98$
	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB address
	BSBB	CVT_TO_SYS_INT		; Convert to system lock

98$:	; Complete request with error status

	MOVZWL	#SS$_NOTQUEUED,R0	; Store status
	BRW	ERROR_EXIT_R0		; Exit

	.DSABL	LSB

	.SBTTL	CVT_TO_SYS - Convert to system owned lock

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts a lock from process owned to system owned
;
; CALLING SEQUENCE:
;
;	BSBW	CVT_TO_SYS
;	BSBW	CVT_TO_SYS_INT	(Internal entry point w/o error checking)
;	IPL must be at IPL$_SYNCH
;	NOTE:  Errors are passed to error exit, not returned to caller
;
; INPUTS:
;
;	R1	Access mode of caller (CVT_TO_SYS entry only)
;	R4	Address of PCB
;	R6	Address of LKB
;
; OUTPUTS:
;
;	R0	Completion code (returned to error handler, not caller)
;
; COMPLETION CODES:
;
;	SS$_NOPRIV	Caller wasn't in EXEC or KERNEL mode
;	SS$_PARNOTSYS	Parent lock is not a system lock
;
; SIDE EFFECTS:
;
;	R0 is destroyed
;--

	.ENABL	LSB

CVT_TO_SYS:
	; Verify that caller is in EXEC or KERNEL mode and that
	; this lock's parent lock is also system owned.

	CMPB	R1,#PSL$C_EXEC		; Is caller privileged?
	BGTRU	70$			; No, error
	MOVL	LKB$L_PARENT(R6),R0	; Get parent LKB address
	BEQL	CVT_TO_SYS_INT		; No parent
	BBC	#LCK$V_CVTSYS,-		; Branch if parent not system owned
		LKB$W_FLAGS(R0),80$

CVT_TO_SYS_INT:
	; Request passed all error checks, do the conversion to system owned.
	; Return quota to process, if charged, clear the lock's PID 
	; and remove from the process's lock queue.

	BITW	#LKB$M_NOQUOTA,-	; Was quota charged?
		LKB$W_STATUS(R6)
	BNEQ	20$			; No
	MOVL	PCB$L_JIB(R4),R0	; Yes, get address of JIB
	INCW	JIB$W_ENQCNT(R0)	; Return quota
	BISW	#LKB$M_NOQUOTA,-	; Set NOQUOTA bit
		LKB$W_STATUS(R6)

20$:	CLRL	LKB$L_PID(R6)		; Clear PID
	REMQUE	LKB$L_OWNQFL(R6),R0	; Remove from PCB queue
	BISW	#LCK$M_CVTSYS,-		; Set this flag in case we are 
		LKB$W_FLAGS(R6)		; cancelling or we have a NOQUEUE
					; situation (it got cleared)
	RSB

	;
	; Errors
	;
70$:	MOVZWL	#SS$_NOPRIV,R0
	BRB	90$
80$:	MOVZWL	#SS$_PARNOTSYS,R0
90$:	BRW	ERROR_EXIT_R0

	.DSABL	LSB

	.SBTTL	CVT_TO_PRC - Convert to process owned lock

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts a lock from system owned to process owned
;
; CALLING SEQUENCE:
;
;	BSBW	CVT_TO_PRC
;	IPL must be at IPL$_SYNCH
;	NOTE:  Errors are passed to error exit, not returned to caller
;
; INPUTS:
;
;	R4	Address of PCB
;	R6	Address of LKB
;	R9	Input flags
;
; OUTPUTS:
;
;	R0	Completion code (returned to error handler, not caller)
;
; COMPLETION CODES:
;
;	SS$_EXENQLM	Exceeded enqueue quota
;	SS$_SUBLOCKS	System owned locks with sublocks cannot be converted
;			to process owned locks
;
; SIDE EFFECTS:
;
;	R0 is destroyed
;--

CVT_TO_PRC:
	; Verify that this lock has no sublocks

	TSTW	LKB$W_REFCNT(R6)	; Are there any sublocks?
	BNEQ	80$			; Yes, error

	; Charge quota unless NOQUOTA bit is set

	BITW	#LCK$M_NOQUOTA,R9	; Charge quota?
	BNEQ	20$			; No
	MOVL	PCB$L_JIB(R4),R0	; Yes, get JIB address
	DECW	JIB$W_ENQCNT(R0)	; Charge one
	BLSS	70$			; No quota - error
	BICW	#LKB$M_NOQUOTA,-	; Indicate it was charged
		LKB$W_STATUS(R6)

20$:	; Store PID and insert onto PCB lock queue

	BISW	#LKB$M_WASSYSOWN,-	; Set status bit to indicate lock was
		LKB$W_STATUS(R6)	; system owned
	MOVL	PCB$L_PID(R4),-		; Store PID
		LKB$L_PID(R6)
	INSQUE	LKB$L_OWNQFL(R6),-	; Insert at head of PCB queue
		PCB$L_LOCKQFL(R4)
	RSB

;
;	Errors
;

70$:	INCW	JIB$W_ENQCNT(R0)	; Put back charged quota
	MOVZWL	#SS$_EXENQLM,R0
	BRB	90$
80$:	MOVZWL	#SS$_SUBLOCKS,R0
90$:	BRW	ERROR_EXIT_R0

	.SBTTL	NEW_LOCK - New lock request (not conversion)

; FUNCTIONAL DESCRIPTION:
;
;	This routine handles requests for new locks, as opposed to
;	conversions.  This routine eventually branches to NEW_RESOURCE
;	or OLD_RESOURCE depending on whether the resource already
;	exists or not.
;
; CALLING SEQUENCE:
;
;	Branched to from $ENQ service
;	RET back to caller
;
; INPUTS:
;
;	R3	Event flag number
;	R4	Address of PCB
;	R7	Lock mode
;	R8	Address of LKSB
;	R9	Flags
;
;	Caller's argument list (offsets from AP)
;
; OUTPUTS:
;
;	R0	Completion code
;
; IMPLICIT OUTPUTS:
;
;	Caller's lock status block gets final request status (perhaps
;	aynchronously)
;
; COMPLETION CODES:
;
;   In R0:
;
;	SS$_NORMAL		Successful completion
;	SS$_SYNCH		Synchronous successful completion
;	SS$_IVLOCKID		Invalid lock id
;	SS$_ACCVIO		Access violation (on resource name)
;	SS$_PARNOTGRANT		Parent lock not granted
;	SS$_NOSYSLCK		No SYSLCK privilege (needed for a system lock)
;	SS$_IVBUFLEN		Resource name length = 0 or > 31
;	SS$_INSFMEM		Insufficient dynamic memory
;	SS$_EXENQLM		Exceeded enqueue quota
;	SS$_NOTQUEUED		Request was not queued
;	SS$_NOPRIV		No privilege (to not charge quota)
;
;   In LKSB:
;
;	SS$_NORMAL		Successful completion
;	SS$_DEADLOCK		Deadlock detected
;	SS$_ABORT		Lock was dequeued before being granted
;--

	.IF NDF	LOADSW
	.PSECT	Y$EXEPAGED
	.ENDC

	.ENABL	LSB

;
; Errors:
;

ACCVIO:	MOVZWL	S^#SS$_ACCVIO,R0	; Access violation on res. name or LKSB
	BRB	8$
2$:	MOVZWL	#SS$_IVBUFLEN,R0	; Invalid length for resource name
8$:	JMP	ERROR_EXIT_R0

NEW_LOCK:

	; Get pointer to resource name, probe it, and check the length
	; for legality (0 < length <= RSB$K_MAXLEN).

	MOVL	RESNAM(AP),R0		; Get address of resource name descriptor
	IFNORD	#8,(R0),ACCVIO		; Branch if descriptor not readable
	MOVQ	(R0),R10		; Get length (R10) and address (R11)
	MOVZWL	R10,R10			; Clear top half of length
	BEQL	2$			; Error, length is zero
	ASSUME 	RSB$K_MAXLEN LE 512
	CMPL	R10,#RSB$K_MAXLEN	; Is length > maximum allowed?
	BGTRU	2$			; Yes, error, length is too big
	IFNORD	R10,(R11),ACCVIO	; Branch if string not readable
	
	; Allocate a lock block.
	; NOTE:  There is an implicit assumption here (unchecked!) that
	;	 the minimum size of an SRP is 96 bytes.

	ASSUME	LKB$K_LENGTH  LE  96
	ASSUME	LKB$B_TYPE  EQ  LKB$W_SIZE+2

	SETIPL	#IPL$_ASTDEL		; Raise IPL (to allocate pool)
	MOVAL	G^IOC$GL_SRPFL,R0	; *** Combine this and the following 
					; instruction when loading is resolved
	REMQUE	@(R0),R2		; Try lookaside list
	BVC	10$			; Have one
	MOVZWL	#LKB$K_LENGTH,R1	; List empty - do it the hard way
	CLRL	R0			; No cleanup routine needed
	JSB	G^EXE$ALONPAGWAIT	; Allocate; wait if necessary
	BLBC	R0,8$			; None there and resource wait off
10$:	MOVL	R2,R6			; R6 will point to LKB
	MOVL	#<DYN$C_LKB@16>!-	; Store size and type fields
		LKB$K_LENGTH,LKB$W_SIZE(R6)

	; Fill in various fields in LKB

	ASSUME	ASTPRM  EQ  ASTADR+4
	ASSUME	LKB$B_GRMODE  EQ  LKB$B_RQMODE+1

	MOVB	R3,LKB$B_EFN(R6)	; Store event flag number
	MOVZBW	R7,LKB$B_RQMODE(R6) 	; Store req. mode; clear granted mode
	MOVL	R8,LKB$L_LKSB(R6)	; Store LKSB address
	MOVL	ASTADR(AP),-		; Store completion AST address
		LKB$L_CPLASTADR(R6)
	MOVL	BLKAST(AP),-		; Store blocking AST address
		LKB$L_BLKASTADR(R6)
	MOVL	ASTPRM(AP),-		; Store AST parameter
		LKB$L_ASTPRM(R6)
	MOVL	PCB$L_PID(R4),-		; Store PID
		LKB$L_PID(R6)
	CLRW	LKB$W_REFCNT(R6)	; Clear sub LKB reference count

	; Allocate a resource block (RSB).  This is done now because the
	; resource name must be copied from the caller's buffer to a system
	; one before it is used.  It is copied right into the
	; resource block because the common case is that the resource does
	; not currently exist.  If we later find the resource, this RSB
	; will be deallocated.

	MOVAB	RSB$K_LENGTH(R10),R1	; Add length of name to fixed size 
	CMPL	R1,G^IOC$GL_SRPSIZE	; Will it fit in a SRP?
	BGTRU	15$			; No
	MOVAL	G^IOC$GL_SRPFL,R0	; *** Combine this and the following 
					; instruction when loading is resolved
	REMQUE	@(R0),R2		; Try lookaside list
	BVS	15$			; Didn't get one

13$:	; Continue building RSB and LKB

	ASSUME	RSB$B_TYPE  EQ  RSB$W_SIZE+2
	ASSUME	RSB$B_DEPTH  EQ  RSB$B_TYPE+1

	MOVZWL	R1,RSB$W_SIZE(R2)	; Store size of RSB and zero depth
	MOVL	R2,R8			; R8 will point to RSB

	; Copy resource name to RSB and branch to non-paged PSECT.

	MOVL	R4,R7			; Save PCB address
	MOVC3	R10,(R11),RSB$T_RESNAM(R8) ; R0 - R5 not valid anymore
	MOVL	R7,R4			; Restore PCB address
	JMP	40$			; Branch to non-paged PSECT

15$:	; Need to allocate a RSB from pool because it either won't fit
	; in a SRP or the SRP list is empty.

	MOVAB	L^CLEANUP4,R0		; Set address of cleanup routine
	JSB	G^EXE$ALONPAGWAIT	; Allocate.  Wait if necessary.
	BLBS	R0,13$			; Have one
	CLRL	R8			; Error, indicate no RSB to deallocate
	JMP	27$			; Deallocate LKB and return

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

;***************************************************************************
;
;	Errors
;
;***************************************************************************

	; CLEANUP3 errors

23$:	MOVZWL	#SS$_PARNOTGRANT,R0	; Parent lock not granted
25$:	MOVL	R3,R6			; Restore address of LKB
27$:	MOVL	R0,R11			; Save completion code
	BSBW	CLEANUP3		; Deallocate LKB and RSB; then exit
	BRW	ERROR_EXIT_R11


40$:	; Get parent id and convert to parent LKB if non-zero.  If a parent is
	; specified get parent RSB address (in R7) and get resource access mode
	; from parent RSB.  Otherwise, R7 = 0 so we get resource access mode 
	; from argument list (maximized with caller's access mode, of course).
	; Note that we raise to IPL$_SYNCH here.  After this is performed,
	; there can be no further references to the caller's address space.

	ASSUME	LKB$K_GRANTED  GT  0
	ASSUME	LKB$K_CONVERT  EQ  0
	ASSUME	RSB$B_RMOD  EQ  RSB$W_GROUP+2

	MOVL	R6,R3			; Save LKB address
	CLRL	R7			; Assume no parent RSB
	MOVL	PARID(AP),R6		; Get parent id
	BEQL	45$			; Branch if no parent specified
	SETIPL	#IPL$_SYNCH		; Raise IPL
	MOVL	R6,R1			; Move parent id
	BSBW	VERIFYPARLOCKID		; Get LKB in R6 and caller's access mode
	BLBC	R0,25$			; in R1.  Branch if error
	TSTB	LKB$B_STATE(R6)		; Is parent lock in grant or cvt state?
	BGEQ	43$			; Yes
	BBC	#LCK$V_CONVERT,-	; No, but if CONVERT bit is set, then
		LKB$W_FLAGS(R6),23$	; it's okay as lock is in a transient 
					; convert state.  Otherwise, error!
43$:	MOVL	LKB$L_RSB(R6),R7	; Yes, get parent RSB address
	MOVL	RSB$W_GROUP(R7),R0	; Get parent's group and res. acmode
	INCW	LKB$W_REFCNT(R6)	; Increment parent's sub LKB ref. count
	BRB	50$

45$:	; No parent LKB so get specified access mode and maximize with 
	; caller's access mode.

	MOVPSL	R0			; Read current PSL
	EXTZV	#PSL$V_PRVMOD,-		; Extract previous mode field
		#PSL$S_PRVMOD,R0,R1
	BICB3	#^C<3>,ACMODE(AP),R0	; Get specified access mode
	SETIPL	#IPL$_SYNCH		; Raise IPL
	CMPB	R1,R0 			; Compare with caller's access mode
	BLSSU	47$			; Use specified access mode (R0)
	MOVB	R1,R0			; Use caller's access mode (R1)
47$:	ASHL	#16,R0,R0		; Move to bits <16:23>

50$:	; Store parent LKB address or 0 (in R6).  Then store caller's
	; access mode with NODELETE bit set (caller's access mode is in R1,
	; resource access mode is in R0 <16:23>).

	ASSUME	LKB$B_RMOD  EQ  ACB$B_RMOD
	ASSUME	LKB$M_NODELETE  EQ  ACB$M_NODELETE

	MOVL	R6,LKB$L_PARENT(R3)	; Store parent LKB ptr in new LKB
	MOVL	R3,R6			; Restore LKB address
	BISB3	#LKB$M_NODELETE,R1,-	; Store access mode in LKB and set
		LKB$B_RMOD(R6)		; no delete bit
	MOVL	R1,R5			; Move access mode

	; R0 <16:23> contains resource access mode;  R0 <0:15> contains
	; parent's group if there is a parent.  R5 contains
	; caller's access mode;  R7 contains parent RSB address or 0.
	; Store composite group number and access mode in RSB.

	ASSUME	RSB$W_GROUP  EQ  RSB$L_PARENT+4
	ASSUME	RSB$B_RMOD  EQ  RSB$W_GROUP+2

	MOVL	R0,R1			; Move composite fields
	MOVL	R7,R0			; Move parent RSB address
	BNEQ	53$			; Store if this is a sub-lock
	BITW	#LCK$M_SYSTEM,R9	; Is this a system name?
	BNEQ	52$			; Yes
	MOVW	PCB$W_GRP(R4),R1	; Group name - store group number
	BRB	53$
52$:	CMPB	R5,#PSL$C_EXEC		; System name - allow without priv. if
	BLEQU	53$			; caller is from EXEC or KERNEL mode 
	IFNPRIV	SYSLCK,61$		; SUPER or USER mode needs privilege
53$:	MOVQ	R0,RSB$L_PARENT(R8)	; Store parent, group, acmode in RSB
	MOVB	R10,RSB$B_RSNLEN(R8)	; Store resource name lenght in RSB
	CLRW	LKB$W_STATUS(R6)	; Clear status bits

	; See if any special operations must be performed.
	; The caller's mode is in R5.  The PCB address is in R4.

	BITW	#LCK$M_RECOVER-		; Any special bits set?
		!LCK$M_PROTECT-
		!LCK$M_NOQUOTA-
		!LCK$M_CVTSYS,R9
	BEQL	59$			; No

	; If RECOVER bit is set, then verify process has privilege to set
	; it and if so, also set the PROTECT and NOQUEUE bits.

	BBC	#LCK$V_RECOVER,R9,54$	; Branch if RECOVER is not set
	BBC	#PCB$V_RECOVER,-	; Branch if no privilege
		PCB$L_STS(R4),62$
	BISW	#LCK$M_NOQUEUE!LCK$M_PROTECT,R9	; Set related bits

54$:	; If PROTECT is set, then set corresponding bit in status

	BBC	#LCK$V_PROTECT,R9,55$	; Branch if PROTECT is not set
	BISW	#LKB$M_PROTECT,-	; Set PROTECT bit is status
		LKB$W_STATUS(R6)

55$:	; If CVTSYS is set, then verify caller is from EXEC or KERNEL
	; mode and that parent lock is system owned.  Then also set
	; NOQUEUE and SYNCSTS bits and clear PID.

	BBC	#LCK$V_CVTSYS,R9,57$	; Branch if CVTSYS is not set
	MOVL	LKB$L_PARENT(R6),R0	; Get parent LKB address
	BEQL	56$			; No parent
	TSTL	LKB$L_PID(R0)		; Is parent system owned?
	BNEQ	60$			; No, error
56$:	BISW	#LCK$M_SYNCSTS!LCK$M_NOQUEUE,R9	; Set related bits
	CLRL	LKB$L_PID(R6)		; Clear PID
	BRB	58$			; Do access mode check

57$:	; If NOQUOTA is set, then verify caller is from EXEC or KERNEL
	; mode and set internal NOQUOTA bit.

	BBC	#LCK$V_NOQUOTA,R9,59$	; Branch if NOQUOTA is not set
58$:	CMPB	R5,#PSL$C_EXEC		; Is access mode EXEC or KERNEL?
	BGTRU	62$			; No - error
	BISW	#LKB$M_NOQUOTA,-	; Yes, set NOQUOTA status
		LKB$W_STATUS(R6)
	BRB	85$

59$:	MOVL	PCB$L_JIB(R4),R4	; Get pointer to JIB
	DECW	JIB$W_ENQCNT(R4)	; Decrement enqueue count remaining
	BGEQ	85$			; Quota ok
	BRB	67$			; No quota - error

;***************************************************************************
;
;	Error branches and out of line code
;
;***************************************************************************

	; CLEANUP2 errors

60$:	MOVZWL	#SS$_PARNOTSYS,R11	; Parent not system owned
	BRB	64$
61$:	MOVZWL	#SS$_NOSYSLCK,R11	; No privilege for system lock
	BRB	64$
62$:	MOVZWL	S^#SS$_NOPRIV,R11	; No privilege 
64$:	BSBW	CLEANUP2		; Cleanup
	BRB	69$

	; CLEANUP1 errors

66$:	MOVZWL	#SS$_RETRY,R11		; Retry operation
	BRB	68$
67$:	MOVZWL	#SS$_EXENQLM,R11	; Exceeded enqueue quota
68$:	BSBW	CLEANUP1		; Cleanup (deallocate LKB, RSB, etc.)

69$:	BRW	ERROR_EXIT_R11

	; OUT OF LINE CODE

70$:	; We are stalling some lock requests.  R0 (low byte) contains
	; stall flag.  See if this request should be stalled.  Stall values
	; are:
	;
	;	-1	Stall all requests
	;	+1	Stall only protected locks (not being recovered)
	;	+2	Stall protected locks and root locks

	BLSS	74$			; We are stalling all requests
	CMPB	R0,#2			; Are we stalling root locks?
	BLSS	72$			; No
	TSTL	LKB$L_PARENT(R6)	; Yes, is this a root lock?
	BEQL	74$			; Yes, stall this request
72$:	BBC	#LCK$V_PROTECT,R9,90$	; Don't stall unprotected locks
	BBS	#LCK$V_RECOVER,R9,90$	; Don't stall recovering a lock
	BBS	#PCB$V_RECOVER,-	; Don't stall recovery process,
		PCB$L_STS(R4),66$	; return error instead
74$:	BSBW	CLEANUP1		; Cleanup
	BRW	STALL_REQ		; Stall this request

75$:	; No lockids.   Try extending table

	MOVAB	W^CLEANUP1,R0		; Address of cleanup routine
	BSBW	LCK$EXTEND_IDTBLW	; Try extending table
	BLBS	R0,90$			; Success
	MOVL	R0,R11			; Failure, move status
	BRB	68$			; Cleanup

;***************************************************************************
;
;	End error branches and out of line code
;
;***************************************************************************

85$:	; Store flags and stall this lock request, if necessary.  

	MOVW	R9,LKB$W_FLAGS(R6)	; Store flags
	MOVB	G^LCK$GB_STALLREQS,R0	; Are we stalling requests?
	BNEQ	70$			; Yes

90$:	; Allocate a lock id and point the id slot to this LKB.

	MOVL	G^LCK$GL_NXTID,R0	; Get next lock id
	BEQL	75$			; No more - try expanding table
	MOVL	G^LCK$GL_IDTBL,R1	; Get address of lock id table.  *** May
					; combine with next instr. if no loading
	MOVW	R0,LKB$L_LKID(R6)	; Store lockid index
	MOVAL	(R1)[R0],R1		; Get address of lockid table entry
	MOVZWL	(R1),G^LCK$GL_NXTID	; Update ptr to next free id
	MOVW	2(R1),LKB$L_LKID+2(R6)	; Store lockid sequence number
	MOVL	R6,(R1)			; Store LKB address in table entry

	; Now hash resource name and search hash table for a matching
	; name and parent RSB address.

	MOVAB	RSB$L_PARENT(R8),R4	; Point to parent, group, resnam, etc.
	ADDL	#8,R10			; Account for parent RSB, group, etc.
	BSBW	LCK$HASH_SEARCH		; Hash and search the table for a match
	BLBS	R0,NEW_RESOURCE		; Didn't find one
					; Found one - fall through to ...


	.DSABL	LSB

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

OLD_RESOURCE:
	; Found a matching resource block (RSB).  Address of RSB is in R5.
	; Address of LKB is in R6.  First deallocate the temporary RSB 
	; pointed to by R8.  If anyone is waiting 
	; (in either the waiting queue or the conversion queue), then 
	; this request must also wait.  If no one is waiting, then this 
	; lock can be granted if it is compatible with the group grant mode.

	MOVL	R8,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate temporary RSB
	MOVL	R5,R8			; Use R8 from now on for RSB address
	MOVL	R8,LKB$L_RSB(R6)	; Store RSB pointer in LKB

	; If this resource is being handled remotely, then send a remote
	; lock request.  Otherwise do it here.

	MOVL	RSB$L_CSID(R8),R3	; Get CSID of system managing this 
	BNEQ	REM_LOCK		; resource and branch if it's not us

LCK$LOCAL_LOCK::
	; Return here to handle locks locally after a directory lookup.

	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNEW_LOC
	.ENDC

	MOVAL	RSB$L_CVTQFL(R8),R0	; Get address of conversion queue
	CMPL	R0,(R0)			; Queue empty?
	BNEQ	70$			; No
	ADDL	#8,R0			; Get address of wait queue
	MOVL	R0,R1			; Save in R1
60$:	CMPL	(R0),R1			; Is this the end of the queue?
	BNEQ	65$			; No

62$:	; No waiting requests (or RECOVER bit is set); is the lock compatible?

	MOVZBL	LKB$B_RQMODE(R6),R1	; Get lock mode
	MOVZBL	RSB$B_GGMODE(R8),R5	; Get group grant mode
	BBC	R1,LCK$COMPAT_TBL[R5],72$ ; Branch if incompatible

	; Lock can be granted

	BSBW	LCK$GRANT_LOCK		; Returns status in R0
	BRW	LCK$SYNC_EXIT

65$:	; Skip this lock if it's in a SCS wait state (anything but
	; LKB$K_WAITING).

	MOVL	(R0),R0			; Point to lock
	CMPB	#LKB$K_WAITING,-	; Is it waiting?
		LKB$B_STATE-LKB$L_SQFL(R0)
	BNEQ	60$			; No, skip over it

70$:	; Request cannot be granted due to other locks in the waiting
	; or conversion queue ahead of us.  If RECOVER bit is set,
	; then ignore these waiters and try granting anyway.

	BBS	#LCK$V_RECOVER,R9,62$	; Branch if recovering a lock

72$:	; Request cannot be granted due to other waiters or incompatibility.
	; The request gets queued unless the user requested that it not
	; be queued if it cannot be granted.

	BBS	#LCK$V_NOQUEUE,R9,80$	; Br. if request should not be queued
	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB address
	BSBW	LCK$QUEUEWAIT		; Insert lock on wait queue, etc.
	BRW	LCK$QUEUED_EXIT		; Exit system service

80$:	; Request is not to be queued.  Clean up and return status in R0.

	MOVZWL	#SS$_NOTQUEUED,R11	; Status
	BRW	LCK$NOT_QUEUED

REM_LOCK:
	; Send this lock request to another system

	JMP	G^LCK$SND_LOCKREQ	; Send remote lock request

	; Possible return entry points are:
	;
	;	LCK$LOCAL_LOCK	Handle request here after all
	;	LCK$SYNC_EXIT	Lock request was granted
	;	LCK$QUEUED_EXIT Lock request was queued
	;	LCK$NOT_QUEUED	Lock request was not queued

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

NEW_RESOURCE:
	; Resource does not exist, so create it.  Register usage is:
	;
	;	R6	Address of LKB
	;	R7	Address of parent RSB (or 0 if no parent)
	;	R8	Address of RSB being created
	;	R9	Flags
	;	R11	Address of last RSB in hash chain

85$:	MOVB	#DYN$C_RSB,-		; Store type field
		RSB$B_TYPE(R8)
	MOVL	R8,LKB$L_RSB(R6)	; Store RSB pointer in LKB

	; Insert RSB into hash chain.  R11 points to previous entry 
	; which was, until now, the last one in the chain.

	MOVL	R8,RSB$L_HSHCHN(R11)	; Make previous entry point to this one
	CLRL	RSB$L_HSHCHN(R8)	; This one now ends the chain
	MOVL	R11,RSB$L_HSHCHNBK(R8)	; Back pointer points to previous one

	; Fill in remaining fields in RSB

	ASSUME	RSB$W_REFCNT  EQ  RSB$L_VALSEQNUM+4
	ASSUME	RSB$W_BLKASTCNT  EQ  RSB$W_REFCNT+2
	ASSUME	RSB$L_CVTQFL  EQ  RSB$L_GRQFL+8
	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8
	ASSUME	RSB$B_CGMODE  EQ RSB$B_GGMODE+1
	ASSUME	RSB$W_STATUS  EQ RSB$B_CGMODE+1

	MOVAL	RSB$L_GRQFL(R8),R0	; Initialize all three queue headers
	MOVL	R0,R1
	MOVL	R0,(R1)+		; Granted queue
	MOVAQ	(R0)+,(R1)+
	MOVL	R0,(R1)+		; Conversion queue
	MOVAQ	(R0)+,(R1)+
	MOVL	R0,(R1)+		; Waiting queue
	MOVL	R0,(R1)
	CLRQ	RSB$Q_VALBLK(R8)	; Clear value block
	CLRQ	RSB$Q_VALBLK+8(R8)
	CLRQ	RSB$L_VALSEQNUM(R8)	; Clear value block sequence number,
					; sub-RSB reference count and
					; blocking AST count 
	CLRL	RSB$B_GGMODE(R8)	; Clear modes, status
	CLRW	RSB$W_RQSEQNM(R8)	; Clear req. seq. number

	; If there is a parent RSB then incr. sub-RSB reference count
	; and check for maximum depth of resource name tree.

	TSTL	R7			; Is there a parent?
	BEQL	90$			; No parent
	ADDB3	#1,RSB$B_DEPTH(R7),-	; Our depth is 1 more than our
		RSB$B_DEPTH(R8)		; parent's depth
	CMPB	RSB$B_DEPTH(R8),-	; Is our depth equal to 
		G^LCK$GB_MAXDEPTH	; maximum allowed?
	BGEQU	88$			; Yes - error
	INCW	RSB$W_REFCNT(R7)	; Increment parent's sub RSB ref. count
	MOVL	RSB$L_CSID(R7),-	; Our parent's CSID becomes
		RSB$L_CSID(R8)		; ours also
	BEQL	95$			; Resource is managed here
	MOVL	RSB$L_CSID(R8),R3	; Get CSID of destination system
87$:	BRB	REM_LOCK		; Resource is managed by another system
88$:	BRW	DEPTH_ERROR

90$:	; This resource has no parent.  Send lock request to appropriate 
	; directory system.  If this system is the directory system for this
	; resource, then turn RSB into a directory entry

	MOVL	G^LCK$GL_DIRVEC,R3	; Get address of directory vector
	BEQL	93$			; No vector, we are dir. sys.
	MOVZWL	RSB$W_HASHVAL(R8),R1	; Get hash value
	CLRL	R2			; Clear high order hash value
	EDIV	-12(R3),R1,R0,R1	; Remainder in R1
	MOVL	(R3)[R1],R3		; Get directory system CSID
93$:	MOVL	R3,RSB$L_CSID(R8)	; Store it in RSB
	BNEQ	87$			; Not us - do a directory lookup
	BISW	#RSB$M_DIRENTRY,-	; Set directory entry bit
		RSB$W_STATUS(R8)

95$:	MOVZBL	LKB$B_RQMODE(R6),R1	; Get requested lock mode
	BSBW	LCK$GRANT_LOCK_ALT	; Grant lock

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNEW_LOC
	.ENDC

LCK$SYNC_EXIT::
	; The request has been satisfied synchronously.  Status is already
	; in R0 and LKB$L_LKST1.  Insert the lock onto the head of the
	; lock list in the PCB (unless it's a system lock) and store 
	; value block, if specified.
	; Note: Conversions should not use this exit path as they are
	; already on the PCB's lock list.

	ASSUME	LCK$V_VALBLK  EQ  0

	TSTL	LKB$L_PID(R6)		; Is this a system owned lock?
	BEQL	10$			; Yes, don't insert onto PCB queue
	MOVL	G^SCH$GL_CURPCB,R4	; Get address of PCB
	INSQUE	LKB$L_OWNQFL(R6),-	; Insert lock at head of process
		PCB$L_LOCKQFL(R4)	; lock list
10$:	BLBC	R9,LCK$NORET_VALBLK	; Branch if no value block

LCK$RET_VALBLK::
	; Store RSB's value block in caller's value block, store LKSB,
	; and return.  Status is already in R0 and LKB$L_LKST1.
	; However, if the value block is marked invalid, then we will change
	; the status in LKB$L_LKST1 to SS$_VALNOTVALID.

	SETIPL	#IPL$_ASTDEL		; Lower IPL to write in caller's
					; address space but still block ASTs
	BITW	#RSB$M_VALINVLD,-	; Is value block valid?
		RSB$W_STATUS(R8)
	BEQL	10$			; Yes
	MOVW	#SS$_VALNOTVALID,-	; No, change completion status
		LKB$L_LKST1(R6)
10$:	MOVL	LKB$L_LKSB(R6),R1	; Get LKSB address
	MOVQ	LKB$L_LKST1(R6),(R1)+	; Store LKSB
	MOVQ	RSB$Q_VALBLK(R8),(R1)+	; Copy RSB value block to caller's
	MOVQ	RSB$Q_VALBLK+8(R8),(R1)+; value block
	RET				; Return



LCK$QUEUED_EXIT::
	; Come here if request was queued.

	MOVZWL	S^#SS$_NORMAL,R0	; Indicate it was queued successfully

LCK$NORET_VALBLK::
	; Exit service with status in R0.  Copy contents of internal
	; LKSB to the caller's LKSB.  Remember, once IPL is lowered to 0
	; the LKB can be instantly deleted out from under us.

	SETIPL	#IPL$_ASTDEL		; Lower IPL to write in caller's
					; address space but still block ASTs
	MOVQ	LKB$L_LKST1(R6),-	; Store contents of LKSB
		@LKB$L_LKSB(R6)
	RET				; Return


	.SBTTL	Error Handling for $ENQ

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the error handling for the $ENQ system
;	service.  This routine has a number of entry points, depending
;	on what the error is.  Each error entry point backs up the 
;	operations performed thus far.  Consequently, the order of operations
;	in this routine must be exactly the reverse of the order of 
;	operations in the $ENQ system service.
;
; CALLING SEQUENCE:
;
;	Branch to error entry point.  This routine returns from the system
;	service.  The entry points named CLEANUPx are called with a BSBW
;	and they return to the caller.  Then the appropriate ERROR_EXIT
;	may be branched to.
;
; INPUT PARAMETERS:
;
;	R0	Completion code (some entry points)
;	R6	Address of LKB (some entry points)
;	R8	Address of RSB (some entry points)
;	R11	Completion code (some entry points)
;		Address of previous RSB (DEPTH_ERROR entry point only)
;
; OUTPUT PARAMETERS:
;
;	R0	Status code
;
; COMPLETION CODES:
;
;	SS$_ACCVIO		Access violation (on LKSB or resource name)
;	SS$_BADPARAM		Bad lock mode
;	SS$_IVLOCKID		Invalid lock id
;	SS$_CVTUNGRANT		Attempted to convert an ungranted lock
;	SS$_PARNOTGRANT		Parent lock not granted
;	SS$_NOSYSLCK		No SYSLCK privilege (needed for a system lock)
;	SS$_IVBUFLEN		Resource name length = 0 or > 31
;	SS$_INSFMEM		Insufficient dynamic memory
;	SS$_EXASTLM		Exceeded AST quota
;	SS$_EXENQLM		Exceeded enqueue quota
;	SS$_NOTQUEUED		Request was not queued
;	SS$_EXDEPTH		Exceeded allowed depth of resource name tree
;
; SIDE EFFECTS:
;
;	None
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABL	LSB

DEPTH_ERROR:
	; Remove RSB from hash chain and deallocate both LKB (R6) 
	; and RSB (R8).  R11 points to previous RSB in hash chain.

	CLRL	RSB$L_HSHCHN(R11)	; End hash chain one RSB earlier
	MOVZWL	#SS$_EXDEPTH,R11	; Store status
	BRB	10$

LCK$NOT_QUEUED::
	; Deallocate lock id.  LKB address in R6, status in R11.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNOTQD
	.ENDC

	CLRL	R8			; Indicates no RSB to deallocate

10$:	MOVZWL	LKB$L_LKID(R6),R0	; Get lock id index
	MOVL	G^LCK$GL_IDTBL,R1	; *** Combine with next instr.
	MOVAL	(R1)[R0],R1		; Point to table entry
	MOVW	G^LCK$GL_NXTID,(R1)	; Store next id in this id's slot
	ADDW3	#1,LKB$L_LKID+2(R6),2(R1) ; Incr. and store sequence number
	BVC	20$			; Didn't overflow to a system address
	MOVW	#1,2(R1)		; Overflowed - restart seq. number at 1
20$:	MOVL	R0,G^LCK$GL_NXTID	; This id becomes the next one
	BSBB	CLEANUP1		; Cleanup (puts PCB address in R4)

ERROR_EXIT_R11:
	MOVL	R11,R0			; Move status to R0

ERROR_EXIT_R0:
	; Everything has been cleaned up; status is in R0.  Set event flag
	; and exit.

	SETIPL	#IPL$_ASTDEL		; Lower IPL
	PUSHL	R0			; Save status
	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB address
	MOVL	PCB$L_PID(R4),R1	; Get PID
	MOVZWL	#PRI$_RESAVL,R2		; Get priority increment class
	MOVZBL	EFN(AP),R3		; Get event flag
	JSB	G^SCH$POSTEF		; Set event flag
	POPL	R0			; Restore status
	RET	


; Cleanup subroutine.  This subroutine has various entry points which
; are called depending on how much cleanup is required.
;
; Inputs:
;
;	R6	Address of LKB
;	R8	Address of RSB or 0 to indicate no RSB
;
; Outputs:
;
;	R4	Address of PCB (CLEANUP1 entry point only)

CLEANUP1:
	; Increment enqueue count (if it was charged)

	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB address
	BBS	#LKB$V_NOQUOTA,-	; Branch if no quota was charged
		LKB$W_STATUS(R6),CLEANUP2
	MOVL	PCB$L_JIB(R4),R0	; Get address of JIB
	INCW	JIB$W_ENQCNT(R0)	; Increment enqueue count

CLEANUP2:
	; Decrement parent LKB's sub LKB reference count.

	MOVL	LKB$L_PARENT(R6),R0	; Get parent LKB address
	BEQL	CLEANUP3		; No parent
	DECW	LKB$W_REFCNT(R0)	; Decrement parent's sub LKB ref. count
	BLSS	90$			; Ref. count went negative

CLEANUP3:
	; Deallocate RSB.   R8 contains RSB address or
	; 0 indicating no RSB to deallocate, R11 contains status.

	MOVL	R8,R0			; Address of RSB
	BEQL	CLEANUP4		; No RSB
	JSB	G^EXE$DEANONPAGED	; Deallocate it

CLEANUP4:
	; Deallocate LKB.  R6 contains LKB address.

	MOVL	R6,R0			; Address of LKB
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	RSB

90$:	BUG_CHECK	LKBREFNEG,FATAL
	.DSABL	LSB

	.SBTTL	LCK$HASH_SEARCH - Hash resource and search hash table

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine hashes the resource name and parent RSB address
;	and then searches the hash table looking for a RSB with
;	matching:
;		o  resource names
;		o  parent RSB addresses
;		o  access modes
;		o  name spaces (system or group)
;		o  group numbers
;	Resource name length, access mode, name space and group number
;	are all collected into one longword to make the comparison easier.
;
;	The entry point LCK$SRCH_HSHTBL just searches the table using
;	a supplied hash value.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$HASH_SEARCH		(Hash resource and search table)
;	BSBW	LCK$SRCH_HSHTBL		(Just search hash table)
;	(Note: IPL must be at IPL$_SYNCH)
;
; INPUT PARAMETERS:
;
;	R1	Hash value in low-order 16 bits (LCK$SRCH_HSHTBL only)
;		High order 16 bits must be zero
;	R4	Address of parent RSB field (see following ASSUMEs)
;	R10	Length of resource name + 8
;
; IMPLICIT INPUTS:
;
;	This resource's parent's hash value is used to compute this hash
;	value.
;
; OUTPUT PARAMETERS:
;
;	R0	0 if match found
;		1 if no match found
;	R5	Address of matching RSB if a match was found
;	R11	Address of last entry in hash chain if no match found
;
; IMPLICIT OUTPUTS:
;
;	RSB$W_HASHVAL is stored with the hash value for this resource
;	(LCK$HASH_SEARCH entry only)
;
; SIDE EFFECTS:
;
;	R0 - R3 destroyed
;
; NOTES:
;
;	This routine depends on the following fields being adjacent
;	in the RSB.
;--

	ASSUME	RSB$W_GROUP  EQ  RSB$L_PARENT+4
	ASSUME	RSB$B_RMOD  EQ  RSB$W_GROUP+2
	ASSUME  RSB$B_RSNLEN  EQ  RSB$B_RMOD+1
	ASSUME	RSB$T_RESNAM  EQ  RSB$B_RSNLEN+1

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

LCK$HASH_SEARCH::

	; Zero pad resource name to a longword boundary and get # of
	; longwords in resource name plus parent RSB, group, etc.

	ASHL	#-2,R10,R3		; Divide size by 4
	DECL	R3			; Account for parent address
	BICL3	#^C<3>,R10,R0		; Get remainder from 4
	BEQL	40$			; Branch if multiple of 4
	MOVAB	(R4)[R10],R1 		; Get address of end of name
30$:	CLRB	(R1)+			; Clear to next lonqword boundary
	AOBLSS	#4,R0,30$
	INCL	R3			; R3 = # of longwords in name

	; Fold resource name and auxilary fields into a single
	; longword.  R3 = number of longwords to combine.

40$:	MOVAL	4(R4),R1		; Pointer to GROUP field
	CLRL	R2			; Initialize result reg.
45$:	XORL	(R1)+,R2		; XOR next longword
	ROTL	#9,R2,R2		; and rotate
	SOBGTR	R3,45$			; Repeat 
	MOVL	(R4),R0			; Get address of parent RSB
	BEQL	50$			; No parent
	XORW	RSB$W_HASHVAL(R0),R2	; XOR parent's hash value
50$:	MULL	#^XA53F19B7,R2		; Multiply by unusual number
	ROTL	#16,R2,R2		; Swap words

	; Have composite resource name and parent hash value in 
	; the low order word of R2.  Store it in the RSB and then
	; convert it to a hash table entry address (in R5).

	MOVW	R2,RSB$W_HASHVAL-RSB$L_PARENT(R4)  ; Store hash value
	MOVZWL	R2,R1			; Clear high word and move to R1

LCK$SRCH_HSHTBL::
	; Hash value is in low word of R1.  High word must be zero.

	ASHL	G^LCK$GB_HTBLSHFT,R1,R1	; Shift to get hash table index
	MOVL	G^LCK$GL_HASHTBL,R0	; *** Combine with next instr.
	MOVAL	(R0)[R1],R5		; Get address of hash table entry

	; R5 = hash table entry address.  Search hash table looking for
	; a resource block with a matching resource name, parent RSB,
	; access mode, name space (system or group), and group number.

	ASSUME	RSB$L_HSHCHN  EQ  0

60$:	MOVL	R5,R11			; R11 will point to previous entry and
	MOVL	(R5),R5			; R5 will point to next RSB in hash chain
	BEQL	90$			; End of chain - resource not found
	CMPC3	R10,RSB$L_PARENT(R5),(R4) ; Are the names the same?
	BNEQ	60$			; No, but keep looking
	RSB				; Yes, found a match; R0 = 0 from CMPC3

90$:	MOVL	#1,R0			; No match found
	RSB

	.SBTTL	LCK$GRANT_LOCK - Grant a lock request

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the actual granting of a lock.  This includes:
;		o  Computing the new group grant mode
;		o  Inserting the LKB on the granted queue
;		o  Setting the event flag (if required)
;		o  Delivering the completion AST (if required)
;		o  Delivering the blocking AST (if required)
;
;	This routine gets called for both synchronous grants (in the context
;	of the process requesting a lock) and asynchronous grants (in the
;	context of another process that has just performed a dequeue or
;	a conversion to a lower lock mode).
;
;	The alternate entry point LCK$GRANT_LOCK_ALT is used when the caller
;	knows that there are no granted locks (or waiting conversions) for
;	this resource.
;
;	The entry point LCK$REGRANTLOCK  is used to regrant an attempted
;	conversion that was put on the conversion queue and then taken
;	off due to deadlock.  Note that in this case the LKB$M_ASYNC
;	bit must be set (even though we might be completing the request
;	synchronously) in order to execute the code that moves the lock from
;	the tail to the head of the PCB lock queue.
;
;	The QUEUE_AST entry point is used to just queue an AST when 
;	dequeuing an ungranted lock (abort or deadlock).
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$GRANT_LOCK
;	Note:  IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	All entry points:
;
;		R1	Lock mode to grant
;		R6	Address of LKB
;		R8	Address of RSB
;
;	LCK$GRANT_LOCK:
;
;		R5	Existing group grant mode
;
; IMPLICIT INPUTS:
;
;	LCK$REGRANTLOCK and QUEUE_AST:
;
;		LKB$L_LKST1 contains final completion status
;		Also the LKB$M_ASYNC bit must be set
;
; OUTPUT PARAMETERS:
;
;	LCK$GRANT_LOCK and LCK$GRANT_LOCK_ALT:
;
;		R0	Request completion code
;		R5	New group grant mode
;
; IMPLICIT OUTPUTS:
;
;	LCK$GRANT_LOCK and LCK$GRANT_LOCK_ALT:
;
;		SS$_NORMAL is stored in the 1st longword of the LKSB
;
; COMPLETION CODES:
;
;	SS$_SYNCH		Synchronous completion
;	SS$_NORMAL		Normal completion
;
; SIDE EFFECTS:
;
;	R1 - R4 are destroyed
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABLE	LSB

LCK$GRANT_LOCK::
	CMPB	R1,R5			; Should there be a new group grant mode?
	BLEQU	10$			; No

LCK$GRANT_LOCK_ALT::
	MOVB	R1,RSB$B_GGMODE(R8)	; Yes, store group grant mode
	MOVL	R1,R5			; and in R5
	MOVB	R1,RSB$B_CGMODE(R8)	; Store conversion grant mode

10$:	MOVB	R1,LKB$B_GRMODE(R6)	; Store granted lock mode
	MOVZWL	S^#SS$_NORMAL,-		; Store success in LKSB
		LKB$L_LKST1(R6)
LCK$REGRANTLOCK::

	; Determine if this request wants a blocking AST.  If yes,
	; then increment blocking AST count in RSB and determine if we 
	; are blocking anyone.

	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8

	TSTL	LKB$L_BLKASTADR(R6)	; Blocking AST address specified?
	BEQL	30$			; No
	INCW	RSB$W_BLKASTCNT(R8)	; Incr. blocking AST count
	MOVAL	RSB$L_CVTQFL(R8),R2	; Get address of conversion queue
	MOVL	#2,R0			; Do this loop twice

15$:	MOVL	R2,R3			; Save address of queue header
20$:	MOVL	(R3),R3			; Get address of next element
	CMPL	R2,R3			; Is it the header?
	BEQL	25$			; Yes, done with this queue
	MOVZBL	LKB$B_RQMODE-LKB$L_SQFL(R3),R4	; No, get requested lock mode
	BBS	R1,LCK$COMPAT_TBL[R4],20$ ; Br. if compatible
	BISW	#LKB$M_BLKASTQED!-	; Set blocking AST queued and
		LKB$M_DBLKAST,LKB$W_STATUS(R6) ; deliver blocking AST status
	BISB	#LKB$M_PKAST,-		; Set piggyback kernel AST bit
		LKB$B_RMOD(R6)
	MOVL	LKB$L_BLKASTADR(R6),-	; Store address of blocking AST routine
		LKB$L_AST(R6)
	BRB	30$			; Search no more
25$:	ADDL	#8,R2			; Advance to wait queue
	SOBGTR	R0,15$			; Repeat

LCK$GRANT_REM::	
30$:	; Set state to granted and insert on granted queue.
	; Determine if a completion AST should be queued.

	INSQUE	LKB$L_SQFL(R6),-	; Insert lock on granted queue
		RSB$L_GRQFL(R8)
	MOVB	#LKB$K_GRANTED,-	; Indicate lock is on granted queue
		LKB$B_STATE(R6)

	MOVZWL	#SS$_SYNCH,R0		; Assume synchronous completion
	BITW	#LKB$M_MSTCPY,-		; Branch if this a 
		LKB$W_STATUS(R6)	; master copy
	BNEQ	35$
	BITW	#LKB$M_ASYNC,-		; Branch if this request is being 
		LKB$W_STATUS(R6)	; completed asynchronously
	BNEQ	40$
	BITW	#LCK$M_SYNCSTS,-	; Branch if SYNCSTS bit is set
		LKB$W_FLAGS(R6)	
	BNEQ	80$

	TSTL	LKB$L_CPLASTADR(R6)	; Did caller specify a completion AST?
	BEQL	70$			; No, just set event flag
	BRB	50$			; Yes, set appropriate bits

35$:	; Come here if the lock is a master copy

	BITW	#LKB$M_ASYNC,-		; Branch if this request is being 
		LKB$W_STATUS(R6)	; completed synchronously
	BEQL	37$
	PUSHL	R5			; Save group grant mode
	JSB	G^LCK$SND_GRANTED	; Send a granted message
	POPL	R5			; Restore it
37$:	RSB

40$:	; The request is being completed asynchronously so it is necessary
	; to remove the lock from its current position in the PCB queue
	; (around the tail) and reinsert it at the head of the PCB queue.

	MOVZWL	LKB$L_PID(R6),R4	; Get process index
	MOVL	G^SCH$GL_PCBVEC,R0	; *** Combine this and next inst. when 
					;  PIC code is no longer needed ***
	MOVL	(R0)[R4],R4		; Convert to PCB address
	REMQUE	LKB$L_OWNQFL(R6),R0	; Remove lock from PCB lock queue
	INSQUE	(R0),PCB$L_LOCKQFL(R4)	; Insert at head of lock queue

QUEUE_AST:
	; Request is being completed asynchronously so a kernel AST is
	; required to store status.  This is also used as an entry point
	; to queue an AST when dequeuing an ungranted lock.  (e.g. abort 
	; or deadlock).  Status should already be in LKB$L_LKST1.  Note:
	; The LKB$M_NODELETE bit may have been cleared before calling QUEUE_AST.

	BBCC	#LKB$V_TIMOUTQ,-	; Remove lock from timeout queue
		LKB$W_STATUS(R6),45$	; if it was on it
	REMQUE	LKB$L_ASTQFL(R6),R0
45$:	TSTL	LKB$L_CPLASTADR(R6)	; Did caller specify a completion AST?
	BNEQ	50$			; Yes
	BISB	#LKB$M_KAST,-		; No, set special kernel AST bit
		LKB$B_RMOD(R6)
	BRB	60$			; and deliver completion AST anyway

50$:	; A completion AST was requested by the caller.

	BISB	#LKB$M_PKAST,-		; Set piggyback kernel AST flag
		LKB$B_RMOD(R6)
	MOVL	LKB$L_CPLASTADR(R6),-	; Store completion AST address
		LKB$L_AST(R6)
60$:	BISW	#LKB$M_DCPLAST,-	; Set deliver completion AST flag
		LKB$W_STATUS(R6)

70$:	; Set the event flag

	MOVL	LKB$L_PID(R6),R1	; Get PID
	MOVZBL	#PRI$_RESAVL,R2		; Priority increment class
	MOVZBL	LKB$B_EFN(R6),R3	; Event flag number
	JSB	G^SCH$POSTEF		; Post event flag
	MOVZWL	S^#SS$_NORMAL,R0	; Return success

80$:	; Queue AST if either completion or blocking AST flags are set.

	BITW	#LKB$M_DCPLAST!-	; Is either flag set?
		LKB$M_DBLKAST,LKB$W_STATUS(R6)
	BEQL	90$			; No
	PUSHR	#^M<R0,R5>		; Save R0 and R5
	MOVL	R6,R5			; R5 points to ACB
	TSTL	LKB$L_PID(R6)		; Is this a system owned lock?
	BEQL	95$			; Yes
	MOVAB	B^LOCK_KAST,-		; Store address of kernel AST routine
		LKB$L_KAST(R6)
	MOVZBL	#PRI$_RESAVL,R2		; Priority increment class
	JSB	G^SCH$QAST		; Yes, queue AST
	POPR	#^M<R0,R5>		; Restore regs
90$:	RSB

95$:	; Handle system owned locks.  Since we can't be delivering a 
	; completion AST, we must have to deliver a blocking AST
	; (actually a blocking subroutine call).

	BSBW	CALL_BLK_SUBR		; Call blocking subroutine
	POPR	#^M<R0,R5>		; Restore regs
	RSB

	.DSABL	LSB

	.SBTTL	LOCK_KAST - Kernel AST routine

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is the special kernel AST routine.  It is called
;	whenever completion or blocking ASTs are delivered.
;	If a completion AST is being delivered and the request is being
;	completed asynchronously, then the lock status block and
;	optionally the value block are copied to the caller's LKSB.
;	Then (synch. or async.) we see if a blocking AST is required.
;	If it is then we requeue the LKB to deliver the blocking AST.
;	If a blocking AST is being delivered then we just have to clear
;	the bit that tells us to deliver a blocking AST.  Finally, if the
;	LKB is not requeued for an AST we check to see if it should be
;	deleted and if so, delete it.
;
; CALLING SEQUENCE:
;
;	JSB	LOCK_KAST (actually called by SCH$ASTDEL)
;	Note:  This routine may be called as either a special kernel
;	AST routine or piggyback kernel AST routine or both.
;
; INPUT PARAMETERS:
;
;	R4	Address of PCB
;	R5	Address of LKB
;	Note:  Only offsets up to LKB$K_ACBLEN may be used
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	???
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

LOCK_KAST:
	BBC	#LKB$V_DCPLAST,-	; Branch if no completion AST to deliver
		LKB$W_STATUS(R5),40$
	BBC	#LKB$V_ASYNC,-		; Branch if synchronous completion
		LKB$W_STATUS(R5),20$

	; Store status and value block, if requested.  If the value block
	; is invalid then the status in LKB$L_LKST1 is changed.  Note that
	; this only happens if the status code was a success code.

	MOVL	LKB$L_LKSB(R5),R1	; Get address of LKSB
	BBC	#LCK$V_VALBLK,-		; Branch if no value block
		LKB$W_FLAGS(R5),10$
	BLBC	LKB$L_LKST1(R5),10$	; Only store value block if request
					; was successful
	IFNOWRT	#24,(R1),20$		; Branch if LKSB is not writeable
	MOVL	LKB$L_RSB(R5),R0	; R0 = address of RSB
	BITW	#RSB$M_VALINVLD,-	; Is value block valid?
		RSB$W_STATUS(R0)
	BEQL	5$			; Yes
	MOVW	#SS$_VALNOTVALID,-	; No, change completion status
		LKB$L_LKST1(R5)
5$:	MOVQ	RSB$Q_VALBLK(R0),8(R1)	; Store value block - Note:  the fact
	MOVQ	RSB$Q_VALBLK+8(R0),16(R1) ; that we always store the value block
					; is based on the assumption that $ENQs
					; that fetch it are always synchronous.
	BRB	15$
10$:	IFNOWRT	#8,(R1),20$		; Branch if LKSB is not writeable
15$:	MOVL	LKB$L_LKST1(R5),(R1)	; Store status

20$:	; Requeue LKB if we have to deliver a blocking AST.  Also, convert
	; lock back to system owned, if necessary.

	SETIPL	#IPL$_SYNCH		; Raise IPL
	BICW	#LKB$M_DCPLAST,-	; Clear deliver completion AST bit
		LKB$W_STATUS(R5)
	BBS	#LKB$V_CVTTOSYS,-	; Branch if this lock should be con-
		LKB$W_STATUS(R5),30$	; verted back to system owned
	BBC	#LKB$V_DBLKAST,-	; Branch if no blocking AST to deliver
		LKB$W_STATUS(R5),60$
	MOVL	LKB$L_BLKASTADR(R5),-	; Store blocking AST address
		LKB$L_AST(R5)
	MOVZBL	#PRI$_RESAVL,R2		; Priority increment class
	JSB	G^SCH$QAST		; Queue AST
	BRB	80$

30$:	; Lock needs to be converted back to system owned.  Restore old AST
	; parameter and convert back to system owned.  Call blocking 
	; AST subroutine instead of queueing an AST, if necessary.
	; Note that this path should NEVER be taken if the NODELETE bit is
	; clear (i.e. places that clear the NODELETE bit should also clear
	; CVTTOSYS).  There are two reasons for this.  First, if NODELETE
	; is clear, then the LKB may already be removed from the PCB lock
	; queue and CVT_TO_SYS would do a double REMQUE.  Secondly, the field
	; LKB$L_OLDASTPRM is only part of the full LKB; it's not part of
	; the ACB portion of the LKB.  Therefore, this code path can only be
	; used if we are dealing with the full LKB (see routine FREE_LKB).
	; It is for these reasons that this code path branches to 80$
	; instead of 60$ when it's finished.

	MOVL	LKB$L_OLDASTPRM(R5),-	; Restore old AST parameter
		LKB$L_ASTPRM(R5)
	PUSHL	R6			; Save R6
	MOVL	R5,R6			; Move LKB address
	BSBW	CVT_TO_SYS_INT		; Convert to system owned
	POPL	R6			; Restore R6
	BBC	#LKB$V_DBLKAST,-	; Branch if no blocking AST to deliver
		LKB$W_STATUS(R5),80$
	BSBW	CALL_BLK_SUBR		; Call blocking subroutine
	BRB	80$

40$:	; We must be delivering a blocking AST

	SETIPL	#IPL$_SYNCH		; Raise IPL
	BICW	#LKB$M_DBLKAST,-	; Clear deliver blocking AST bit
		LKB$W_STATUS(R5)

60$:	; Delete LKB if no longer needed.  Increment enqueue quota unless
	; the NOQUOTA bit in the LKB is set.  In this case,
	; AST quota has already been accounted for in the AST delivery code.

	BBS	#LKB$V_NODELETE,-	; Branch if not deleting
		LKB$B_RMOD(R5),80$
	BBS	#LKB$V_NOQUOTA,-	; Branch if accounting taken care of
		LKB$W_STATUS(R5),70$
	MOVL	PCB$L_JIB(R4),R0	; Get JIB address
	INCW	JIB$W_ENQCNT(R0)	; Add 1 to enqueue count
70$:	MOVL	R5,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate it
80$:	SETIPL	#IPL$_ASTDEL		; Lower IPL
	RSB


;
; Synchronization notes:
;
;	1)  The clearing of the DCPLAST bit and the testing of the
;	    DBLKAST bit (after label 20$) must be done at IPL$_SYNCH
;	    in order to synchronize correctly with the queueing of a
;	    blocking AST by routine LCK$QUEUE_BLOCKAST.  Otherwise, the AST
;	    could be queued twice.
;
;	2)  Running the rest of the routine at IPL$_SYNCH (labels 40$ and
;	    80$) is just done for safety's sake.  At this writing, it
;	    is not believed to be necessary.
;

	.SBTTL	LCK$QUEUECVT - Insert a lock on conversion queue
	.SBTTL	LCK$QUEUEWAIT - Insert a lock on wait queue

;++
; FUNCTIONAL DESCRIPTION:
;
;	These routines handle lock requests when they cannot be granted
;	immediately.  LCK$QUEUECVT handles conversion requests and
;	LCK$QUEUEWAIT handles new lock requests.  These routines also
;	queue the lock onto a timeout queue if deadlock checking is enabled.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$QUEUECVT (or LCK$QUEUEWAIT)
;	(Note:  IPL must be at IPL$_SYNCH)
;
; INPUT PARAMETERS:
;
;	R4	Address of PCB 
;	R5	Group grant mode without this lock (LCK$QUEUECVT only)
;	R6	Address of LKB
;	R8	Address of RSB
;	R9	Flags
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	All registers except R6 may be clobbered.
;
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABL	LSB

	ASSUME	LKB$K_CONVERT  EQ  0

LCK$QUEUECVT::
	INSQUE	LKB$L_SQFL(R6),-	; Insert at end of conversion queue
		@RSB$L_CVTQBL(R8)
	BNEQ	10$			; Branch if not first in queue
	MOVB	R5,RSB$B_CGMODE(R8)	; Store conversion grant mode
10$:	CLRB	LKB$B_STATE(R6)		; Set state = conversion
	BITW	#LKB$M_MSTCPY,-		; Is this is a master copy?
		LKB$W_STATUS(R6)
	BNEQ	15$			; Yes
	REMQUE	LKB$L_OWNQFL(R6),R0	; Remove from PCB lock queue
	BRB	QUEUE_COMMON		; Join common code

LCK$QUEUEWAIT::
	INSQUE	LKB$L_SQFL(R6),-	; Insert request at end of wait queue
		@RSB$L_WTQBL(R8)
LCK$QUEUE_REM::
	MOVB	#LKB$K_WAITING,-	; Set state = waiting
		LKB$B_STATE(R6)
	BITW	#LKB$M_MSTCPY,-		; Is this is a master copy?
		LKB$W_STATUS(R6)
	BNEQ	15$			; Yes

QUEUE_COMMON:

	; Insert lock on process lock queue and clear event flag.

	INSQUE	LKB$L_OWNQFL(R6),-	; Insert at end of PCB lock queue
		@PCB$L_LOCKQBL(R4)
	MOVZBL	LKB$B_EFN(R6),R3	; Get event flag number
	JSB	G^SCH$CLREFR		; Clear the event flag

15$:	; Set ASYNC bit and queue blocking ASTs

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQWAIT
	.ENDC

	BISW	#LKB$M_ASYNC,-		; Set bit to indicate this request
		LKB$W_STATUS(R6)	; will be satisfied asynchronously
	CLRL	LKB$L_LKST1(R6)		; Clear 1st longword of LKSB
	TSTW	RSB$W_BLKASTCNT(R8)	; See if anyone wants a blocking AST
	BEQL	20$			; No
	BSBB	LCK$QUEUE_BLOCKAST	; Yes, queue blocking ASTs

20$:	; Insert this lock on timeout queue if deadlock checking is enabled
	; and this lock is mastered on this system and LCK$M_NODLCKWT is 
	; not set.

	ASSUME	LKB$L_DUETIME  EQ  LKB$L_KAST	; Note that these fields overlap

	TSTL	RSB$L_CSID(R8)		; Don't insert process copy locks
	BNEQ	30$
	BBS	#LCK$V_NODLCKWT,-	; Branch if no deadlock wait is set
		LKB$W_FLAGS(R6),30$
	MOVL	G^LCK$GL_WAITTIME,R0	; Get lock wait time
	BEQL	30$			; Deadlock checking is disabled
	ADDL3	R0,G^EXE$GL_ABSTIM,-	; Add wait time to current time to
		LKB$L_DUETIME(R6)	; get duetime
	CLRB	LKB$B_TSLT(R6)		; Init. timestamp lifetime
	BISW	#LKB$M_TIMOUTQ,-	; Set timeout queue bit
		LKB$W_STATUS(R6)
	MOVAL	G^LCK$GL_TIMOUTQ,R0
	INSQUE	LKB$L_ASTQFL(R6),-	; Insert lock on end of timeout queue
		@4(R0)
30$:	RSB

	.DSABL	LSB

	.SBTTL	LCK$QUEUE_BLOCKAST - Queue blocking ASTs

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine queues a blocking AST to all locks that meet the
;	following conditions:
;		o  Are on the granted queue
;		o  Have requested a blocking AST
;		o  Have not already received a blocking AST
;		o  Whose granted lock mode is incompatible with
;		   the requested lock mode of the lock being placed in
;		   the conversion or wait queue
;		o  Whose lock state is GRANTED (eliminates locks in a SCS
;		   conversion wait state)
;
;	This routine assumes that the caller has already determined
;	that RSB$W_BLKASTCNT is non-zero, indicating that there is at least
;	one lock requesting a blocking AST.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$QUEUE_BLOCKAST
;	(Note: IPL must be at IPL$_SYNCH)
;
; INPUTS:
;
;	R6	Address of LKB (being placed on conversion or wait queue)
;	R8	Address of RSB
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Possibly, a number of blocking ASTs are queued
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5, R7, R10, and R11 are destroyed
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

LCK$QUEUE_BLOCKAST::
	MOVZBL	LKB$B_RQMODE(R6),R10	; Get req. lock mode of blocked lock
	MOVAL	RSB$L_GRQFL(R8),R11	; Get address of granted queue
	MOVL	R11,R7			; Save address
10$:	MOVL	(R7),R7			; Get address of next element in queue
	CMPL	R7,R11			; Reached the end yet?
	BEQL	90$			; Yes
	SUBL3	#LKB$L_SQFL,R7,R5	; No, position to start of LKB
	TSTL	LKB$L_BLKASTADR(R5)	; Blocking AST address specified?
	BEQL	10$			; No
	MOVZBL	LKB$B_GRMODE(R5),R0	; Get granted lock mode
	BBS	R0,LCK$COMPAT_TBL[R10],10$ ; Branch if compatible
	BBS	#LKB$V_BLKASTQED,-	; Branch if blocking ast already
		LKB$W_STATUS(R5),10$	; queued
	CMPB	LKB$B_STATE(R5),-	; Is lock granted?
		#LKB$K_GRANTED
	BNEQ	10$			; No
	BITW	#LKB$M_MSTCPY,-		; Is this a master copy?
		LKB$W_STATUS(R5)
	BNEQ	80$			; Yes - send a message to other system

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_BLK_LOC
	.ENDC

	BSBB	LCK$QUEUE_BLKAST	; No, actually queue an AST
	BRB	10$			; Repeat for remaining locks

80$:	JSB	G^LCK$SND_BLKING	; Send a blocking message
	BRB	10$			; Repeat for remaining locks

90$:	RSB

;++
; Subroutine to actually queue the blocking AST.
;
; Input:
;	R5	Address of LKB
; Output:
;	R0 - R5 not preserved
;--

	.ENABL	LSB

LCK$QUEUE_BLKAST::
	TSTL	LKB$L_PID(R5)		; Is this lock system owned?
	BEQL	CALL_BLK_SUBR		; Yes, call blocking subroutine

QUEUE_BLKAST:
	; Deliver a blocking AST to the process owning this lock (LKB in R5)

	BISW	#LKB$M_BLKASTQED!-	; Set blocking AST queued and
		LKB$M_DBLKAST,LKB$W_STATUS(R5) ; deliver blocking AST status
	BISB	#LKB$M_PKAST,-		; Set piggyback kernel AST bit
		LKB$B_RMOD(R5)
	BBS	#LKB$V_DCPLAST,-	; Branch if the LKB is already queued
		LKB$W_STATUS(R5),70$	; NOTE: This test is based on the
					; assumption that the LKB$M_DBLKAST bit
					; cannot be set since the
					; LKB$M_BLKASTQED bit was not set.
	MOVL	LKB$L_BLKASTADR(R5),-	; Store blocking AST address
		LKB$L_AST(R5)
	MOVAB	LOCK_KAST,LKB$L_KAST(R5); Store address of kernel AST routine
	MOVZBL	#PRI$_RESAVL,R2		; Store priority increment class
	JSB	G^SCH$QAST		; Queue the AST
70$:	RSB

;++
; Subroutine to call blocking subroutine for system owned locks
;
; Input:
;	R5	Address of LKB
; Output:
;	R0 - R5 not preserved
;--

CALL_BLK_SUBR:
	BICW	#LKB$M_DBLKAST,-	; Clear deliver blocking AST bit
		LKB$W_STATUS(R5)
	BISW	#LKB$M_BLKASTQED,-	; Set blocking AST queued bit
		LKB$W_STATUS(R5)
	MOVL	LKB$L_ASTPRM(R5),R1	; Get AST parameter

	; Call blocking subroutine.  R5 points to LKB, R1 contains AST
	; parameter.  IPL is at IPL$_SYNCH.  R0 - R5 need not be
	; preserved by subroutine.

	JSB	@LKB$L_BLKASTADR(R5)	; Call blocking subroutine
	RSB

	.DSABL	LSB

	.SBTTL	LCK$COMP_GGMODE - Compute group grant mode

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine computes the group grant mode for a particular
;	resource.  It does this by maximizing the granted lock modes
;	for all locks in the granted and conversion queues.  Note that
;	this routine is often called with the lock of interest (to possibly
;	be granted) not on any queue.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$COMP_GGMODE
;	(Note IPL must be at IPL$_SYNCH)
;
; INPUTS:
;
;	R8	Address of RSB
;
; OUTPUTS:
;
;	R5	Group grant mode
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 and R2 are destroyed
;	Note:  R1 must be preserved
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

LCK$COMP_GGMODE::

	ASSUME	RSB$L_CVTQFL  EQ  RSB$L_GRQFL+8
	
	CLRL	R5			; Initialize group grant mode
	MOVAL	RSB$L_GRQFL(R8),R0	; Get address of granted queue
	BSBB	10$			; Compute g.g. mode for that queue
	ADDL	#8,R0			; Get address of conversion queue
					; fall through to ...

; Subroutine to compute group grant mode for a single queue

10$:	MOVL	R0,R2			; Address of queue header
20$:	MOVL	(R2),R2			; Get address of next element
	CMPL	R2,R0			; Reached queue header yet?
	BEQL	30$			; Yes
	CMPB	LKB$B_GRMODE-LKB$L_SQFL(R2),R5 ; Granted mode greater
					; than group grant  mode?
	BLEQU	20$			; No, continue down queue
	MOVZBL	LKB$B_GRMODE-LKB$L_SQFL(R2),R5 ; Yes, granted mode becomes 
					; group grant mode
	BRB	20$			; Continue down queue
30$:	RSB

	.SBTTL	LCK$GRANTCVTS - Grant conversions
	.SBTTL	LCK$GRANTWTRS - Grant waiters

;++
; FUNCTIONAL DESCRIPTION:
;
;	These two routines try to grant waiting conversions or
;	waiting new locks.  They are called when another lock
;	is dequeued or converted if there is a possibility that a waiting
;	lock request may be granted.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$GRANTCVTS (or LCK$GRANTWTRS)
;	(Note: IPL must be at IPL$_SYNCH)
;
; INPUT PARAMETERS:
;
;	R5	Contains group grant mode
;	R8	Address of RSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R4 are destroyed
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABL	LSB

LCK$GRANTCVTS::
	PUSHL	R6			; Save R6
10$:	REMQUE	@RSB$L_CVTQFL(R8),R6	; Remove head of conversion queue
	BVS	70$			; Nothing on conversion queue
	SUBL	#LKB$L_SQFL,R6		; Position R6 to start of LKB
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling requests?
	BNEQ	65$			; Yes
20$:	MOVZBL	LKB$B_RQMODE(R6),R1	; Get requested mode of conversion
	BBS	R1,LCK$COMPAT_TBL[R5],40$ ; Branch if compat. to grant conversion
	CMPB	LKB$B_GRMODE(R6),R5	; Is granted mode = g.g. mode?
	BNEQ	60$			; No
	BSBW	LCK$COMP_GGMODE		; Yes, try recomputing g.g. mode
	BBC	R1,LCK$COMPAT_TBL[R5],55$ ; Branch if not compatible
40$:	BSBW	LCK$GRANT_LOCK		; Grant this conversion
	BRB	10$			; Try the next conversion too
55$:	MOVB	R5,RSB$B_CGMODE(R8)	; Store conversion grant mode
60$:	INSQUE	LKB$L_SQFL(R6),-	; Insert lock at head of
		RSB$L_CVTQFL(R8)	; conversion queue
	POPL	R6			; Restore R6
	RSB

65$:	; We are stalling some requests - see which ones

	BLSS	60$			; We are stalling all requests
	BBC	#LKB$V_PROTECT,-	; We are only stalling protected locks
		LKB$W_STATUS(R6),20$	; Branch if this is not a protected lock
	BRB	60$			; Exit without trying to grant lock

LCK$GRANTWTRS::

	; Get here if the conversion queue is empty.
	; Try granting waiting locks.  Group grant mode is in R5.
	; This routine is different than the one above because we
	; must skip over locks in any SCS wait state.

	PUSHL	R6			; Save R6
70$:	PUSHL	R7			; Save R7
	MOVAB	RSB$L_WTQFL(R8),R6	; Get address of wait queue
	MOVL	R6,R7			; Save in R7

75$:	MOVL	(R6),R6			; Get next LKB
80$:	CMPL	R6,R7			; Reached the end?
	BEQL	90$			; Yes
	CMPB	#LKB$K_WAITING,-	; Is the state = WAITING
		LKB$B_STATE-LKB$L_SQFL(R6)
	BNEQ	75$			; No, skip over it
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling requests?
	BNEQ	95$			; Yes
85$:	MOVZBL	LKB$B_RQMODE-LKB$L_SQFL(R6),R1 ; Get requested mode
	BBC	R1,LCK$COMPAT_TBL[R5],90$ ; Branch if incompatible
	PUSHL	(R6)			; Save address of next LKB
	REMQUE	(R6),R0			; Remove from wait queue
	SUBL	#LKB$L_SQFL,R6		; Position R6 to start of LKB
	BSBW	LCK$GRANT_LOCK		; Grant this lock
	POPL	R6			; Resume queue where we left off
	BRB	80$			; Try next waiting lock

90$:	POPL	R7			; Restore R7
	POPL	R6			; Restore R6
	RSB

95$:	; We are stalling some requests - see which ones

	BLSS	90$			; We are stalling all requests
	BBC	#LKB$V_PROTECT,-	; Branch if this is not a protected lock
		LKB$W_STATUS-LKB$L_SQFL(R6),85$
	BRB	90$			; Exit without trying to grant lock

	.DSABL	LSB

	.SBTTL	VERIFYLOCKID - Verify lock id

;++
; FUNCTIONAL DESCRIPTION:
;
;	VERIFYLOCKID verifies a lock id for correct process ownership
;	and access mode and then converts it into a LKB address.
;
;	VERIFYPARLOCKID is similar except that the lockid is that
;	of a parent lock and the access mode checking is different.
;
; CALLING SEQUENCE:
;
;	BSBW	VERIFYLOCKID
;	Note:	IPL must be at IPL$_SYNCH to verify that an LKB is 
;		not deallocated while it is being verified.  After this
;		routine returns, it is permissable to lower IPL to
;		IPL$_ASTDEL because the process that owns this lock
;		cannot interrupt to dequeue it (as long as we're
;		not dealing with a system owned lock).
;
; INPUT PARAMETERS:
;
;	R1	Lock id
;	R4	Address of PCB
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;	R1	Access mode of caller (on success only)
;	R6	Address of LKB
;
; COMPLETION CODES:
;
;	SS$_NORMAL	Lock id was valid and converted to LKB address
;	SS$_IVLOCKID	Invalid lock id
;
; SIDE EFFECTS:
;
;	R0 is destroyed
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABL	LSB

	ASSUME	LKB$V_MODE  EQ  0
	ASSUME	LKB$S_MODE  EQ  2

VERIFYLOCKID:
	PUSHL	#1
	BRB	5$

VERIFYPARLOCKID:
	PUSHL	#0
5$:	MOVZWL	R1,R6			; Put lockid index in R6
	CMPL	R6,G^LCK$GL_MAXID	; Is the lock id too big?
	BGTRU	30$			; Yes
	MOVL	G^LCK$GL_IDTBL,R0	; *** May combine with next instr.
	MOVL	(R0)[R6],R6		; Get LKB address
	BGEQ	30$			; Unallocated id
	CMPL	R1,LKB$L_LKID(R6)	; Check sequence number
	BNEQ	30$			; Not valid
	MOVPSL	R0			; Get current PSL
	EXTZV	#PSL$V_PRVMOD,-		; Extract previous mode field
		#PSL$S_PRVMOD,R0,R1
	BICB3	#^XFC,LKB$B_RMOD(R6),R0	; Get access mode of lock
	TSTL	(SP)			; Determine which acmode checks to make
	BEQL	10$			; Parent checks
	CMPB	R1,R0			; Caller have privilege to access lock?
	BLEQU	15$			; Yes
	BRB	30$			; No
10$:	CMPB	R1,R0			; Only less priv. modes can be sub-locks
	BLSSU	30$			; to more priv. modes.
	MOVL	LKB$L_RSB(R6),R0	; Get RSB address
	CMPB	R1,RSB$B_RMOD(R0)	; Caller have privilege to access res.?
	BGTRU	30$			; No
15$:	CMPL	LKB$L_PID(R6),-		; Compare LKB PID with current 
		PCB$L_PID(R4)		; processes' PID
	BNEQ	50$			; Somebody else's id (or 0)

20$:	ADDL	#4,SP			; Remove flag
	MOVZWL	S^#SS$_NORMAL,R0	; Success
	RSB

30$:	ADDL	#4,SP			; Remove flag
	MOVZWL	#SS$_IVLOCKID,R0	; Invalid lock id
	RSB

50$:	; The caller's PID and the lock's PID don't match.  If this is not
	; a master copy lock, then it may be a system-owned lock.  If it
	; is system-owned and the caller's access mode is EXEC or KERNEL
	; the he can reference this lock.  Otherwise, it is an error.
	; We determine if it is system-owned via two different methods
	; depending on whether we are verifying a parent lock or not.
	; If it is a parent lock, we just need to determine if the CVTSYS
	; flag is set.  Otherwise, we need to verify that the PID is zero.
	; This is because even system owned locks go through transient
	; states when the PID is not zero (e.g. conversion in progress
	; and lock is mastered on another node).  If a system owned lock
	; is in this state (PID non-zero) then it cannot be manipulated
	; by another process.  But it can be used as a parent for other
	; system owned locks.

	BITW	#LKB$M_MSTCPY,-		; Is this another system's master copy?
		LKB$W_STATUS(R6)
	BNEQ	30$			; Yes, error
	TSTL	(SP)			; No, choose system ownership check
	BEQL	60$			; Parent lock check
	TSTL	LKB$L_PID(R6)		; Is this a system lock?
	BEQL	70$			; Yes
	BRB	30$			; No, error
60$:	BBC	#LCK$V_CVTSYS,-		; Branch if not system owned
		LKB$W_FLAGS(R6),30$
70$:	CMPB	R1,#PSL$C_EXEC		; Yes, is the caller privileged?
	BLEQU	20$			; Yes
	BRB	30$			; No

	.DSABL	LSB

	.SBTTL	EXE$DEQ - Dequeue system service

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles the $DEQ system service
;
; CALLING SEQUENCE:
;
;	CALLS/G	EXE$DEQ  (Actually called through the system service
;	dispatcher)
;
; INPUT PARAMETERS:
;
;	LOCKID(AP)	Lock id
;	VALBLK(AP)	Address of value block
;	DEQ_ACMODE(AP)	Access mode of locks to dequeue (only used if
;			DEQALL flag is set)
;	DEQ_FLAGS(AP)	Flags
;
;	R4		Address of PCB
;
; OUTPUT PARAMETERS:
;
;	R0		Completion code
;
; COMPLETION CODES:
;
;	SS$_NORMAL	Successful completion
;	SS$_IVLOCKID	Invalid lock id
;	SS$_ACCVIO	Access violation (on VALBLK)
;	SS$_SUBLOCKS	Lock has sublocks
;	SS$_CANCELGRANT	Cannot cancel a granted lock
;--

	.IF NDF	LOADSW
	.PSECT	Y$EXEPAGED
	.ENDC

	.ENABL	LSB


	.IF NDF	LOADSW
	.ENTRY	EXE$DEQ,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	.IFF
	.ENTRY	EXE$$DEQ,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	.ENDC

	; First see if this is a dequeue of a specific lock or a dequeue
	; of all locks at the specified access mode (maximized with caller's 
	; access mode) and outer modes.

	ASSUME	LCK$V_DEQALL  EQ  0

	MOVL	LOCKID(AP),R1		; Get lock id
	MOVZWL	DEQ_FLAGS(AP),R5	; Get dequeue flags
	BLBS	R5,DEQ_ALL		; Branch if dequeue all

	; It's a dequeue of a specific lock

	MOVL	VALBLK(AP),R9		; Get address of value block
	BEQL	20$			; No value block
	IFNORD	#16,(R9),25$		; Branch if value block not readable
	MOVQ	8(R9),-(SP)		; Push value block onto stack
	MOVQ	(R9),-(SP)
	MOVL	SP,R9			; R9 points to value block
20$:	SETIPL	95$			; Raise IPL to IPL$_SYNCH and 
					; lock pages in memory
	BSBW	VERIFYLOCKID		; Verify lock id and return LKB in R6
	BLBC	R0,DEQ_EXIT		; Error

	; Check to see if we are stalling all requests

	TSTB	G^LCK$GB_STALLREQS	; Are we stalling all requests?
	BLSS	22$			; Yes

	; LKB address is in R6.  Value block address (or 0) is in R9.
	; Dequeue the lock and grant any waiting locks.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DEQ_LOC
	.ENDC

	MOVL	R5,R4			; Move flags
	CLRL	R7			; Use default status
	BSBW	LCK$DEQLOCK		; Dequeue the lock
	CMPW	R0,#SS$_INSFMEM		; Handle insufficient memory
	BEQL	23$

DEQ_EXIT:
	; Exit $DEQ system service.  Status should already be in R0.

	SETIPL	#IPL$_ASTDEL		; Lower IPL
	RET

22$:	BRW	STALL_REQ		; Stall request
23$:	BRW	WAIT_FOR_POOL		; Wait for pool

25$:	MOVZWL	S^#SS$_ACCVIO,R0	; Access violation
	BRB	DEQ_EXIT

35$:	MOVZWL	#SS$_SUBLOCKS,R0	; System lock with sublocks
	BRB	DEQ_EXIT

DEQ_ALL:
	; Dequeue all locks at the specified access mode (maximized
	; with caller's mode) and less privileged modes.  Since this list
	; is normally kept in the order locks were taken out, one pass
	; through the list will normally be able to dequeue all the
	; specified locks.  However, two things may cause the list to
	; be out of order.  First of all, waiting locks are kept at the
	; end of list (for the convenience of deadlock detection) and
	; secondly, if a lock with sublocks is converted (and must wait)
	; it ends up out of order on the list.  If the list is out of order,
	; the result is that we get SS$_SUBLOCKS errors when we try to
	; dequeue out of order locks.  It is therefore necessary to count
	; these errors and if there are any to repeat the loop, again
	; trying to dequeue all the specified loops.  In order to guarantee
	; eventual completion we make sure that each time the loop is repeated,
	; the number of SS$_SUBLOCKS errors is less than the previous time.

	ASSUME	LKB$V_MODE  EQ  0
	ASSUME	LKB$S_MODE  EQ  2

	BICW	#LCK$M_CANCEL,R5	; Don't allow CANCEL if DEQALL is set
	PUSHL	R5			; Save dequeue flags
	MOVL	R1,R6			; Move parent lock id
	BEQL	40$			; No parent - dequeue all locks
	SETIPL	95$			; Raise IPL to verify lockid
	JSB	VERIFYLOCKID		; Convert to LKB address 
	BLBC	R0,DEQ_EXIT		; Error
	TSTL	LKB$L_PID(R6)		; Verify the lock is not system owned
	BEQL	35$			; It is - error
40$:	PUSHL	R6			; Save LKB address or zero
	SETIPL	#IPL$_ASTDEL		; Lower IPL to allow page faults
	BICL3	#^C<3>,DEQ_ACMODE(AP),R0; Get specified access mode
	JSB	G^EXE$MAXACMODE		; Maximize with previous mode
	MNEGL	#1,-(SP)		; Initialize last error count to -1
	PUSHL	#0			; Initialize current error count to 0
	PUSHL	R0			; Save access mode
	CLRL	R9			; Indicate no value block
	MOVAL	PCB$L_LOCKQFL(R4),R10	; Get address of PCB lock queue head
	MOVL	R10,R11			; Save in R11

50$:	; Process next LKB in list.  It's friendly to lower IPL to IPL$_ASTDEL
	; so that system events can occur.  Otherwise we could dequeue
	; thousands of locks staying at IPL$_SYNCH the entire time.
	; But lowering to IPL$_ASTDEL exposes us to at least two race
	; conditions.  The first is that we could have the address of
	; an LKB in R6 (at IPL$_ASTDEL) and deadlock detection could
	; dequeue the lock out from underneath us.  The solution to this
	; is to stay at IPL$_SYNCH between fetching the LKB address and
	; dequeuing it.  Thw other race condition is that by lowering
	; to IPL$_ASTDEL, a waiting lock could be granted, this moving
	; from the tail of the list to the head.  Since we traverse this
	; list from the head to the tail, we could miss this lock.  The
	; solution to this one is to verify that the head of the list
	; doesn't change while we lower and raise IPL.

	MOVL	(R11),R6		; Get first LKB on list
	SETIPL	#IPL$_ASTDEL		; Lower IPL to allow system events
	SETIPL	95$			; Raise IPL and lock pages in memory
	CMPL	R6,(R11)		; Did the head of the queue change?
	BNEQ	75$			; Yes, start over again
	MOVL	(R10),R6		; Get next LKB in list
	CMPL	R6,R11			; Reached end of list?
	BEQL	70$			; Yes
	MOVAL	-LKB$L_OWNQFL(R6),R6	; Back up R6 to point to start of LKB
	BICB3	#^XFC,LKB$B_RMOD(R6),R0	; Get lock access mode
	CMPB	R0,(SP)			; Is lock access mode < spec. mode?
	BLSSU	60$			; Yes, don't dequeue
	MOVL	12(SP),R1		; Get parent LKB address
	BEQL	55$			; No parent - dequeue all locks

	; Have a candidate lock to dequeue (in R6).  Exit the loop
	; if the specified parent lock (in R1) has a zero reference count.  
	; Otherwise, see if our candidate lock (in R6) is a sublock of our
	; parent lock (in R1).

	TSTW	LKB$W_REFCNT(R1)	; Are all its sublocks gone?
	BEQL	80$			; Yes
	MOVL	R6,R0			; R0 will point to each LKB up the tree
53$:	MOVL	LKB$L_PARENT(R0),R0	; Move up one level in tree
	BEQL	60$			; Reached the top without a match
	CMPL	R0,R1			; Does this match specified parent?
	BNEQ	53$			; No, keep going up tree

55$:	; Have an LKB (in R6) to be dequeued.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DEQ_LOC
	.ENDC

	MOVL	16(SP),R4		; Fetch dequeue flags
	CLRL	R7			; Use default status
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling all requests?
	BLSS	85$			; Yes
	BSBW	LCK$DEQLOCK		; Dequeue it
	BLBS	R0,50$			; Branch on success

	CMPW	R0,#SS$_INSFMEM		; Check for insufficient memory
	BEQL	83$

	INCL	4(SP)			; Increment error count
60$:	MOVL	(R10),R10		; Skip this LKB
	BRB	50$

70$:	; Completed a loop through all of the process's locks.  If the
	; current error count is zero, then we're done.  If it's non-zero
	; then we have to run through the list again as long as the error
	; count this time was less than the error count last time.

	TSTL	4(SP)			; Test current error count
	BEQL	80$			; Zero - all done.
	CMPL	4(SP),8(SP)		; Compare current count with last one
	BGEQU	90$			; Bugcheck if it didn't go down
	MOVL	4(SP),8(SP)		; Current count becomes previous count
75$:	CLRL	4(SP)			; Zero current count
	MOVL	R11,R10			; R10 now points to list head again
	BRW	50$			; Repeat the loop

80$:	MOVZWL	S^#SS$_NORMAL,R0	; Set completion status
	BRW	DEQ_EXIT

83$:	BRW	WAIT_FOR_POOL		; Wait for pool
85$:	BRW	STALL_REQ		; Stall request

90$:	BUG_CHECK	DEQSUBLCKS,FATAL

95$:	.LONG	IPL$_SYNCH		; End of locked down code
	ASSUME	.-20$  LE  512		; Must be on adjacent pages
	ASSUME	.-DEQ_ALL LE 512

	.DSABL	LSB

	.SBTTL	LCK$CANCEL_CVT - Cancel a waiting conversion

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine cancels waiting conversions instead of dequeueing them.
;	This means the lock is inserted back on the granted queue at it's 
;	old mode.  However, if it was at the head of the conversion queue, 
;	then we have to try granting other conversions.  Note that canceled 
;	locks get their old blocking AST address restored.  Also, if the lock
;	was formerly a system owned lock, then the CVTTOSYS bit is set so that
;	after the completion AST is delivered, the lock is converted back
;	to a system owned lock.
;
; CALLING SEQUENCE;
;
;	BSBW	LCK$CANCEL_CVT
;	IPL must be at IPL$_SYNCH
;
; INPUTS:
;
;	R6	Address of LKB
;	R7	Final completion status to to store in LKB$L_LKST1 or 0
;		in which case SS$_CANCEL is used (not needed if this is a
;		master copy lock)
;	R8	Address of RSB
;
; OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R4 and R9 are destroyed
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

LCK$CANCEL_CVT::
	SUBL3	#LKB$L_SQFL,-		; Save address of lock at the 
		RSB$L_CVTQFL(R8),R9	; head of conversion queue
	REMQUE	LKB$L_SQFL(R6),R1	; Remove this lock
	BBS	#LKB$V_MSTCPY,-		; Skip "process" code if this is a
		LKB$W_STATUS(R6),10$	; master copy
	MOVL	R7,LKB$L_LKST1(R6)	; Store specified status
	BNEQ	5$			; Had one
	MOVZWL	#SS$_CANCEL,-		; Use default status instead
		LKB$L_LKST1(R6)
5$:	BBC	#LKB$V_WASSYSOWN,-	; Branch if lock wasn't system owned
		LKB$W_STATUS(R6),10$
	BISW	#LKB$M_CVTTOSYS,-	; Lock should be cvted to system owned
		LKB$W_STATUS(R6)	; after completion  AST is delivered
10$:	MOVL	LKB$L_OLDBLKAST(R6),-	; Restore old blocking AST address
		LKB$L_BLKASTADR(R6)
	MOVZBL	LKB$B_GRMODE(R6),R1	; Get current granted mode
	TSTL	RSB$L_CSID(R8)		; Is this a process copy?
	BNEQ	30$			; Yes, skip granting other locks
	BSBW	LCK$REGRANTLOCK		; Regrant this lock
	CMPL	R6,R9			; Was it at the head of the queue?
	BNEQ	20$			; No

	; We have regranted a lock that was at the head of the conversion 
	; queue.  Therefore, it is necessary to try to grant additional 
	; locks.  Also, this will reset the conversion grant mode if we 
	; set it incorrectly below.

	MOVZBL	RSB$B_GGMODE(R8),R5	; Get group grant mode
	MOVB	R5,RSB$B_CGMODE(R8)	; and set conv. grant mode equal to it
	BSBW	LCK$GRANTCVTS		; Try granting more locks
20$:	RSB

30$:	BSBW	LCK$GRANT_REM		; Regrant this lock
	RSB

	.SBTTL	LCK$DEQLOCK - Dequeue a lock

;++
; FUNCTIONAL DESCRIPTION
;
;	This routine dequeues a specified (by LKB address) lock and
;	grants any waiting locks, if possible.  If there are no
;	waiters or holders of the lock, the RSB is deallocated.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$DEQLOCK
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R4	Dequeue flags
;	R6	Address of LKB
;	R7	Contains final status to store in LKB$L_LKST1 if lock
;		is not granted (i.e. SS$_DEADLOCK) or 0 which indicates
;		a default status should be used (see below).
;		(not needed if this is a master copy lock)
;	R9	Address of value block or 0 if no value block
;		(not needed if this is a CANCEL function)
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;
; COMPLETION CODES:
;
;	In R0:
;
;	SS$_NORMAL	Successful completion
;	SS$_SUBLOCKS	Lock has sublocks
;	SS$_CANCELGRANT	Cannot cancel a granted lock
;	SS$_INSFMEM	Insufficient memory to allocate a CDRP
;
;	In LKB$L_LKST1 (if R7 = 0)
;
;	SS$_ABORT - Lock request was aborted
;	SS$_CANCEL - Lock request was canceled
;
; SIDE EFFECTS
;
;	R0 - R5, and R8 and R9 are clobbered
;--

	.IF NDF	LOADSW
	.PSECT	LOCKMGR
	.ENDC

	.ENABL	LSB

INVALID_STATE:	
	BUG_CHECK	LOCKMGRERR,FATAL	; Invalid lock state

REFCNT_ERROR:
	MOVZWL	#SS$_SUBLOCKS,R0
	RSB

CANCELGRANT:
	MOVZWL	#SS$_CANCELGRANT,R0	; Granted - can't cancel a granted lock
	RSB

CANCEL:	TSTB	LKB$B_STATE(R6)		; Dispatch on lock state
	BLSS	6$			; Waiting - handle as ordinary dequeue
	BGTR	CANCELGRANT		; Granted - error
	MOVL	RSB$L_CSID(R8),R3	; Is resource managed by another system?
	BEQL	3$			; No
	JSB	G^CNX$ALLOC_CDRP	; Alloc. CDRP (and convert CSID to CSB)
	BLBC	R0,NOCDRP		; None available (or CSID convert error)
	JSB	G^LCK$SND_DEQCV		; Send a dequeue message
3$:	BSBB	LCK$CANCEL_CVT		; Cancel conversion and regrant lock
	MOVZWL	S^#SS$_NORMAL,R0	; Return success
	RSB

SNDDEQ_WAIT:
	; Need to send a message to master system.  Lock is in a
	; waiting state.

	JSB	G^CNX$ALLOC_CDRP	; Alloc. CDRP (and convert CSID to CSB)
	BLBC	R0,NOCDRP		; None available (or CSID convert error)
	TSTB	LKB$B_STATE(R6)		; Is lock in conversion wait?
	BEQL	4$			; Yes
	JSB	G^LCK$SND_DEQWT		; No, send a dequeue message
	BRW	60$			; Resume processing 
4$:	JSB	G^LCK$SND_DEQCV		; Send a dequeue message
	BRW	60$

LCK$DEQLOCK::
	MOVL	LKB$L_RSB(R6),R8	; Get RSB address
	BITW	#LCK$M_CANCEL,R4	; Is CANCEL flag set?
	BNEQ	CANCEL			; Yes
6$:	TSTW	LKB$W_REFCNT(R6)	; Are there any sub locks?
	BNEQ	REFCNT_ERROR		; Yes - error

	ASSUME	LKB$K_GRANTED  EQ  1
	ASSUME	LKB$K_CONVERT  EQ  0
	ASSUME	LKB$K_WAITING  EQ  -1

	; Dispatch depending on which queue the lock is on and 
	; whether it is managed remotely

	MOVB	LKB$B_STATE(R6),R0	; Get lock state
	BGTR	DEQ_GRANTED		; Lock is on granted queue
	MOVL	RSB$L_CSID(R8),R3	; Is resource managed by another system?
	BNEQ	SNDDEQ_WAIT		; Yes
	TSTB	R0			; What queue is lock on?
	BEQL	DEQ_CONVERT		; Lock is on conversion queue
	CMPB	R0,#LKB$K_WAITING	; Make sure state = WAITING
	BNEQ	INVALID_STATE		; It's not

DEQ_WAIT:
	; The lock is on the waiting queue.  Remove it from the queue and
	; see if it was at the head of the queue.  If yes, then we may be
	; able to grant some locks (but only if the conversion queue is empty).
	; If no, then there is no possibility of granting some locks.

	REMQUE	LKB$L_SQFL(R6),R1	; Remove this lock
	BEQL	18$			; Wait queue is now empty
	MOVAL	RSB$L_CVTQFL(R8),R0	; See if we can grant any more locks
	CMPL	(R0),R0			; is conversion queue empty?
	BNEQ	5$			; No - can't grant any other locks
	MOVZBL	RSB$B_GGMODE(R8),R5	; Yes, get group grant mode and
	BRW	40$			; Try granting some waiters
18$:	BRW	55$

NOCDRP:	; Either insufficient memory or CSID conversion error.

	CMPW	R0,#SS$_INSFMEM		; Is it insufficient memory?
	BNEQ	13$			; No
	RSB				; Yes, return error to caller
13$:	BUG_CHECK	LOCKMGRERR,FATAL; CSID conversion error

SNDDEQ_GRNT:
	; Need to send a message to master system.  Lock is in 
	; granted state.

	JSB	G^LCK$SND_DEQGR		; Send a dequeue message
5$:	BRW	60$

DEQ_CONVERT:
	; The lock is on the conversion queue.  Remove it from the queue and
	; see if it was at the head of the queue.  If no, we may be able to
	; grant some locks due to the granted mode of this lock going away.
	; If yes, we may be able to grant some locks for the same reason
	; and for the additional reason of the head of the queue going away.

	SUBL3	#LKB$L_SQFL,-		; Save address of lock at the 
		RSB$L_CVTQFL(R8),R9	; head of conversion queue
	REMQUE	LKB$L_SQFL(R6),R1	; Remove this lock
	CMPB	LKB$B_GRMODE(R6),-	; Is lock mode PW or higher?
		#LCK$K_PWMODE
	BLSSU	7$			; No, skip value block processing
	BITW	#LCK$M_INVVALBLK,R4	; Should value block be invalidated?
	BEQL	7$			; No
	BISW	#RSB$M_VALINVLD,-	; Yes, invalidate value block
		RSB$W_STATUS(R8)
	INCL	RSB$L_VALSEQNUM(R8)	; Increment value block sequence number
7$:	CMPL	R6,R9			; Was it the first one on the queue?
	BEQL	50$			; Yes
	BRB	45$			; No

DEQ_GRANTED:
	; The lock is on the granted queue.  Remove it from the queue
	; and see if it was the only one on the queue.  If it was, then see
	; if the conversion and wait queues are also empty, and if so then
	; the resource block can be deallocated.  This situation is special cased
	; because it is the normal case.  If this lock is not the only one on the
	; queue, then see if its granted mode is equal to the group grant mode.
	; If yes, we may be able to grant some locks if this lock (only) was
	; responsible for the group grant mode.  If no, then we can't
	; grant any more locks because the group grant mode won't change.

	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8

	MOVL	RSB$L_CSID(R8),R3	; Is resource managed by another system?
	BEQL	8$			; No
	JSB	G^CNX$ALLOC_CDRP	; No, get one (and convert CSID to CSB)
	BLBC	R0,NOCDRP		; None available or CSID convert error
8$:	CMPB	LKB$B_GRMODE(R6),-	; Is lock mode PW or higher?
		#LCK$K_PWMODE
	BLSSU	12$			; No, skip value block processing
	TSTL	R9			; Value block specified?
	BEQL	10$			; No
	MOVQ	(R9),RSB$Q_VALBLK(R8)	; Yes, copy caller's value block to RSB
	MOVQ	8(R9),RSB$Q_VALBLK+8(R8)
	INCL	RSB$L_VALSEQNUM(R8)	; Increment value block sequence number
	BICW	#RSB$M_VALINVLD,-	; Validate value block
		RSB$W_STATUS(R8)
10$:	BITW	#LCK$M_INVVALBLK,R4	; Should value block be invalidated?
	BEQL	12$			; No
	BISW	#RSB$M_VALINVLD,-	; Yes, invalidate value block
		RSB$W_STATUS(R8)
	INCL	RSB$L_VALSEQNUM(R8)	; Increment value block sequence number
12$:	TSTL	LKB$L_BLKASTADR(R6)	; Blocking AST address specified?
	BEQL	15$			; No
	DECW	RSB$W_BLKASTCNT(R8)	; Decr. blocking AST count

15$:	TSTL	R3			; Resource managed remotely?
	BNEQ	SNDDEQ_GRNT		; Yes
	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from granted queue
	BNEQ	45$			; Branch if queue not empty
	MOVAL	RSB$L_CVTQFL(R8),R0	; Get address of conversion queue
	CMPL	(R0),R0			; Is conversion queue empty?
	BNEQ	50$			; No
	ADDL	#8,R0			; Yes, get address of wait queue
	CMPL	(R0),R0			; Is wait queue empty?
	BNEQ	35$			; No, try granting waiters

	; All queues are empty.  Deallocate RSB (as long as it's not
	; a directory entry).

	BSBW	LCK$DEALLOC_RSB
	BRB	60$			; Finish up

35$:	; Try granting waiting locks

	ASSUME	RSB$B_CGMODE  EQ  RSB$B_GGMODE+1

	CLRW	RSB$B_GGMODE(R8)	; Clear group and conversion grant mode
	CLRL	R5			; Clear group grant mode in R5

40$:	BSBW	LCK$GRANTWTRS		; Try granting waiters
	BRB	60$

45$:	; Determine if the lock dequeued was equal to the conversion
	; grant mode.  If not, then no new locks can be granted.

	CMPB	LKB$B_GRMODE(R6),-	; Is the granted mode of this lock
		RSB$B_CGMODE(R8)	; equal to the conversion grant mode?
	BNEQ	60$			; No, don't bother going further

50$:	; Either we dequeued a lock equal to the conversion grant mode
	; or we dequeued the head of the converson queue.  Either way,
	; we must recompute the group grant mode.

	BSBW	LCK$COMP_GGMODE		; New group grant mode in R5
	MOVB	R5,RSB$B_GGMODE(R8)	; Store in RSB
	MOVB	R5,RSB$B_CGMODE(R8)	; Also store conversion grant mode
	BSBW	LCK$GRANTCVTS		; Try granting conversions and waiters
55$:	BSBW	LCK$CHECK_RSB		; Deallocate RSB, if necessary

60$:	; Now finish cleaning up the lock we originally dequeued.  
	; First,  decrement parent LKB's  sub LKB reference count.

	MOVL	LKB$L_PARENT(R6),R0	; Get parent LKB address
	BEQL	65$			; No parent
	DECW	LKB$W_REFCNT(R0)	; Decrement parent's sub LKB ref. count
	BLSS	75$			; Ref. count went negative

65$:	; Deallocate lock id

	MOVZWL	LKB$L_LKID(R6),R0	; Get lock id index
	MOVL	G^LCK$GL_IDTBL,R1	; *** Combine with next instr.
	MOVAL	(R1)[R0],R1		; Point to table entry
	MOVW	G^LCK$GL_NXTID,(R1)	; Store next id in this id's slot
	ADDW3	#1,LKB$L_LKID+2(R6),2(R1) ; Incr. and store sequence number
	BVC	70$			; Didn't overflow to a system address
	MOVW	#1,2(R1)		; Overflowed - restart seq. number at 1
70$:	MOVL	R0,G^LCK$GL_NXTID	; This id becomes the next one
	
	; If this lock is a master copy or system owned, then skip 
	; following "process" code and just deallocate LKB.  Both of these
	; conditions have a zero PID field in the LKB.

	TSTL	LKB$L_PID(R6)		; Is it either?
	BEQL	87$			; Yes

	; Remove LKB from owner's lock queue.  If the lock was not 
	; granted yet, then complete the request (queue an AST and 
	; set event flag) with the status in R7.

	ASSUME	LKB$K_GRANTED  EQ  1
	ASSUME	LKB$K_CONVERT  EQ  0
	ASSUME	LKB$K_WAITING  EQ  -1

	REMQUE	LKB$L_OWNQFL(R6),R0
	TSTB	LKB$B_STATE(R6)		; Is the lock granted?
	BGTR	80$			; Yes
	MOVL	R7,LKB$L_LKST1(R6)	; No, store specified status
	BNEQ	73$			; Had one
	MOVZWL	S^#SS$_ABORT,-		; Use default status instead
		LKB$L_LKST1(R6)
73$:	BICB	#LKB$M_NODELETE,-	; Clear nodelete bit
		LKB$B_RMOD(R6)
	BSBW	QUEUE_AST		; Queue AST and set event flag;
					; returns status on R0.  Kernel AST
					; routine will delete LKB.
	RSB

75$:	BUG_CHECK	LKBREFNEG,FATAL

80$:	; Increment the enqueue count and deallocate the LKB as long
	; as it's not queued to deliver an AST.  If it is queued, then
	; if it's queued to deliver a completion AST then let kernel AST
	; routine delete the LKB.  If it's only queued for a blocking
	; AST then remove it from the AST queue.

	BITW	#LKB$M_DCPLAST!-	; Is the LKB queued for AST delivery?
		LKB$M_DBLKAST,LKB$W_STATUS(R6)
	BEQL	85$			; No
	BICB	#LKB$M_NODELETE,-	; Yes, clear nodelete bit
		LKB$B_RMOD(R6)
	BICW	#LKB$M_DBLKAST-		; Clear deliver blocking AST bit
		!LKB$M_CVTTOSYS,-	; and convert to system owned bit
		LKB$W_STATUS(R6)
	BBS	#LKB$V_DCPLAST,-	; Branch if queued for a completion AST
		LKB$W_STATUS(R6),90$	; (will be deall. when AST is delivered)
	MOVL	R6,R5			; Blocking AST only - remove from
	JSB	G^SCH$REMOVACB		; AST queue

85$:	; Deallocate LKB and increment enqueue quota (if it was charged)

	BITW	#LKB$M_NOQUOTA,-	; Was enqueue quota charged?
		LKB$W_STATUS(R6)
	BNEQ	87$			; No
	MOVZWL	LKB$L_PID(R6),R4	; Get process index
	MOVL	G^SCH$GL_PCBVEC,R0	; *** Combine this and next inst. when 
					;  PIC code is no longer needed ***
	MOVL	(R0)[R4],R4		; Convert to PCB address
	MOVL	PCB$L_JIB(R4),R0	; Get address of JIB
	INCW	JIB$W_ENQCNT(R0)	; Increment enqueue count
87$:	MOVL	R6,R0			; Address of LKB
	JSB	G^EXE$DEANONPAGED	; Deallocate it

90$:	MOVZWL	S^#SS$_NORMAL,R0
	RSB


	.DSABL	LSB

	.SBTTL	LCK$CHECK_RSB - Deallocate RSB if necessary

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine checks to see if all queues on a resource
;	are empty.  If they are, the resource can be deleted
;	as long as it's not needed to act as a directory entry.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$CHECK_RSB
;	BSBW	LCK$DEALLOC_RSB is an entry point to use if all three queues
;		are known to be empty.
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R8	Address of RSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 are destroyed
;
; NOTES:
;
;	If all queues are empty and the RSB is not a root RSB then it
;	can be deleted.  If it is a root RSB then the situation is more
;	complicated as the RSB may still be needed to act as a directory
;	entry.  The following table summarizes what action must be taken.
;	
;				    This is a directory entry
;				       (RSB$M_DIRENTRY = 1)
;
;				|     Yes	|	No
;			  ------+---------------+-----------------
;				|		|  Delete RSB
;	This system	   Yes	|  Delete RSB	|  Send msg to
;	is managing		|		|  directory system
;	the resource	  ------+---------------+-----------------
;	(RSB$L_CSID =		|  Leave RSB	|
;	 0)		   No	|  as directory	|  Delete RSB
;				|  entry	|
;			  ------+---------------+-----------------
;--


	.ENABL	LSB

	ASSUME	RSB$L_CVTQFL  EQ  RSB$L_GRQFL+8
	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8

LCK$CHECK_RSB::
	MOVAL	RSB$L_GRQFL(R8),R0	; Get address of granted queue
	CMPL	(R0),R0			; Is granted queue empty?
	BNEQ	55$			; No
	ADDL	#8,R0			; Yes, get address of conversion queue
	CMPL	(R0),R0			; Is conversion queue empty?
	BNEQ	55$			; No
	ADDL	#8,R0			; Yes, get address of wait queue
	CMPL	(R0),R0			; Is wait queue empty?
	BNEQ	55$			; No

LCK$DEALLOC_RSB::
	; All queues are empty.  Delete RSB and/or send message to
	; directory system as appropriate (see above table).

	ASSUME	RSB$L_HSHCHN  EQ  0
	ASSUME	RSB$L_HSHCHNBK  EQ  RSB$L_HSHCHN+4
	ASSUME	RSB$M_DIRENTRY  EQ  1

	TSTW	RSB$W_REFCNT(R8)	; Verify there are no sub RSB's
	BNEQ	60$			; There are
	MOVL	RSB$L_PARENT(R8),R0	; Get parent RSB address
	BNEQ	25$			; There is a parent

	BLBC	RSB$W_STATUS(R8),15$	; Branch if this is not a dir. entry
	TSTL	RSB$L_CSID(R8)		; Is this system managing this resource?
	BEQL	35$			; Yes - resource can be deleted
	BRB	55$			; This is a directory entry; don't delete
15$:	TSTL	RSB$L_CSID(R8)		; Is this system managing the resource?
	BNEQ	35$			; No - Just delete resource

	; Have to send a remove directory entry message to directory system

	MOVQ	RSB$L_HSHCHN(R8),R0	; Get hash chain pointers in R0 and R1
	MOVL	R0,RSB$L_HSHCHN(R1)	; Store next pointer in previous RSB or
					; hash table
	BEQL	20$			; Branch if no next one
	MOVL	R1,RSB$L_HSHCHNBK(R0)	; Store previous pointer in next one
20$:	JSB	G^LCK$SND_RMVDIR	; Send remove directory entry message
	RSB

25$:	DECW	RSB$W_REFCNT(R0)	; Decrement parent's sub RSB ref. count
	BLSS	70$			; Ref. count went negative
35$:	MOVQ	RSB$L_HSHCHN(R8),R0	; Get hash chain pointers in R0 and R1
	MOVL	R0,RSB$L_HSHCHN(R1)	; Store next pointer in previous RSB or
					; hash table
	BEQL	45$			; Branch if no next one
	MOVL	R1,RSB$L_HSHCHNBK(R0)	; Store previous pointer in next one
45$:	MOVL	R8,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate RSB
55$:	RSB

60$:	BUG_CHECK	RSBREFNZRO,FATAL
70$:	BUG_CHECK	RSBREFNEG,FATAL

	.DSABL	LSB

	.SBTTL	STALL_REQ - Stall request during failover

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine stalls requests during failover by putting the
;	process into MWAIT state waiting for resource RSN$_CLUSTRAN.
;	It is assumed that the request has been backed up and all cleanup
;	has been performed as this routine backs up the service and
;	waits in the caller's mode.
;
;	The alternate entry point WAIT_FOR_POOL operates in the same
;	way but waits for non-paged pool as oppposed to a cluster transition.
;
;	The alternate entry point LCK$CHECK_STALL includes a test to
;	determine if we should stall.
;
; CALLING SEQUENCE:
;
;	BRW	STALL_REQ
;	BRW	WAIT_FOR_POOL
;
;	NOTE:	These routines do not return to the caller.  Rather they back
;		up the service and wait in the mode of the caller.  When
;		the resource becomes available, the service is re-executed.
;
;	JSB	LCK$CHECK_STALL (Either returns to caller or backs up
;				 system service call)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	It is assumed that these routines are being called from the context
;	of a system service and that FP has not been tinkered with.
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	The service is backed out
;--

WAIT_FOR_POOL:
	MOVL	#RSN$_NPDYNMEM,R0	; Set resource to wait for
	BRB	WAIT_COM
LCK$CHECK_STALL::
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling all requests?
	BLSS	STALL_REQ		; Yes
	RSB
STALL_REQ:
	MOVL	#RSN$_CLUSTRAN,R0	; Set resource to wait for
WAIT_COM:
	MOVL	G^SCH$GL_CURPCB,R4	; Set our PCB address
	MOVL	FP,SP			; Trim stack back to start of frame
	MOVQ	8(SP),AP		; Restore pre-call AP and FP
	ADDL	S^#EXE$C_CMSTKSZ,SP	; Clean call frame off stack
	SUBL	#4,(SP)			; Back up saved PC to point to CHMK
	JMP	G^SCH$RWAIT		; Wait

	.SBTTL	LCK$EXTEND_IDTBL - Extend lock id. table

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine extends the lock id. table if it hasn't already
;	reached it's maximum size.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$EXTEND_IDTBLW - To be called when in process context.
;				    If non-paged pool is not available
;				    the system service will be backed out
;				    and the caller will wait.
;	BSBW	LCK$EXTEND_IDTBL  - To be called when in fork context.
;				    This entry point will not wait for pool
;				    and will instead return an error to the
;				    caller.
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R0	Address of cleanup routine or 0 (LCK$EXTEND_IDTBLW only)
;
; IMPLICIT INPUTS:
;
;	Various lock manager memory cells and SYSGEN parameters
;	(LCK$GL_MAXID, LCK$GL_IDTBLSIZ, etc.)
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;
; COMPLETION CODES:
;
;	SS$_INSFMEM	Insufficient non-paged pool
;	SS$_NOLOCKID	Table has already been expanded to the maximum
;
; SIDE EFFECTS:
;
;	R1 - R4 are destroyed
;--

	.ENABL	LSB

5$:	MOVZWL	#SS$_NOLOCKID,R0	; Indicate error
10$:	RSB

LCK$EXTEND_IDTBL::
	MOVAB	G^EXE$ALONONPAGED,R2	; Address of allocate routine
	BRB	15$

LCK$EXTEND_IDTBLW::
	MOVAB	G^EXE$ALONPAGWAITS,R2	; Address of allocate routine

15$:	; Check that we haven't already exceeded the maximum table size

	MOVL	G^LCK$GL_MAXID,R1	; Get current largest lock id.
	CMPL	R1,G^LCK$GL_IDTBLMAX	; Have we reached the upper limit?
	BGEQU	5$			; Yes, return SS$_NOLOCKID
	ADDL3	#1,R1,R4		; Incr. and save for later

	; Compute new table size and allocate it from pool.

	ADDL	G^LCK$GL_IDTBLSIZ,R1	; Add another increment to table size
	MULL	#4,R1			; Convert to size in bytes
	ADDL	#12,R1			; Add header
	JSB	(R2)			; Allocate it
	BLBC	R0,10$			; Insuff. memory

	; Copy old table into new and deallocate old table.  Registers contain:
	;	R1	Allocated size of new table
	;	R2	Address of new table
	;	R4	Old maximum lock id. + 1

	PUSHR	#^M<R1,R2,R4,R5>	; Save regs.
	SUBL3	#12,G^LCK$GL_IDTBL,R5	; Get starting address of old table
	MOVL	R5,R0			; Save in R0
	ASHL	#-2,(R5),R3		; Get size of old table in longwords
20$:	MOVL	(R5)+,(R2)+		; Move old table entry to new table
	SOBGTR	R3,20$			; Repeat
	MOVL	(R0),R1			; Get size of old table
	JSB	G^EXE$DEANONPGDSIZ	; Deallocate old table
	POPR	#^M<R1,R2,R4,R5>	; Restore regs.

	; Set up header of new table and pointers to it.  Registers contain:
	;	R1	Size of table
	;	R2	Address of table
	;	R4	Old maximum lock id. + 1

	MOVL	R1,(R2)			; Store size in first longword
	CLRW	8(R2)			; Clear old size in word size field
	TSTW	2(R2)			; Will size fit in a word?
	BNEQ	30$			; No
	MOVW	R1,8(R2)		; Yes, store it in normal place
30$:	MOVAB	12(R2),G^LCK$GL_IDTBL	; Store pointer to table
	MOVL	R4,G^LCK$GL_NXTID	; Store next lock id. to allocate
	SUBL	#16,R1			; Compute new max. lock id. (# of 
	DIVL	#4,R1			; entries in table - 1)
	MOVZWL	#^XFFFF,R0		; Load useful constant (65535)
	CMPL	R1,R0			; Make sure we don't exceed 65535
	BLEQU	40$			; We're okay
	MOVL	R0,R1			; Set number of entries to exactly 65535
40$:	MOVL	R1,G^LCK$GL_MAXID	; Set maximum lock id.
	MOVAL	12(R2)[R4],R3		; Point to first new entry
	INCL	R4			; Increment next lock id.
	INCL	R0			; Change constant to ^X10000

	; Now initialize new section of table by storing linked list
	; of lock id. indicies and sequence numbers.  Registers contain:
	;	R0	Constant ^X10000
	;	R1	Maximum lock id.
	;	R3	Address of first new entry
	;	R4	Next lock id. to store in table

	BISL	R0,R4			; Logically OR seq. num. with next id.
50$:	MOVL	R4,(R3)+		; Store next table entry
	INCW	R4			; Incr. next id.
	CMPW	R4,R1			; Compare with max. id
	BLEQ	50$			; Repeat
	MOVL	R0,(R3)			; Store last entry
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

	.DSABL	LSB

	.SBTTL	FREE_LKB - Free LKB (from AST queue)

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to free an LKB that is currently
;	queued as an ACB.  This should happen rarely, but when it does
;	an ACB is allocated from pool, the ACB portion of the LKB is copied
;	into the new ACB and the two ACBs are swapped on the AST queue.
;	This frees up the LKB for another use (such as a lock conversion).
;
; CALLING SEQUENCE:
;
;	BSBW	FREE_LKB
;	(Note: IPL must be at IPL$_ASTDEL or lower)
;
; INPUT PARAMETERS:
;
;	R4	Address of PCB
;	R6	Address of LKB
;
; OUTPUT PARAMETERS:
;
;	R0	Completion Code (returned to ERROR_EXIT - not caller)
;
; COMPLETION CODES:
;
;	SS$_INSFMEM		Insufficient memory
;	SS$_EXASTLM		Exceeded AST quota
;
; SIDE EFFECTS:
;
;	The LKB is removed from the AST queue.  Note that all registers
;	(including R0 and R1) must be preserved.
;
; NOTES:
;
;	This code makes two assumptions:
;
;	1)  That the LKB must be queued for a regular AST
;	    (as opposed to just a special kernel AST).  This
;	    is why AST quota is always deducted, not conditionally
;	    on whether an AST address was specified.
;	    
;	2)  That the LKB$M_DCPLAST and LKB$M_DBLKAST bits cannot
;	    become clear while we are at IPL 0.  Otherwise, it
;	    is necessary to verify that the LKB is still in use
;	    after the ACB is allocated from pool.  This assumption
;	    is due to the fact that the AST must either be for
;	    an outer mode or if for kernel mode then kernel mode
;	    ASTs must be disabled.
;--

	.IF NDF	LOADSW
	.PSECT	Y$EXEPAGED
	.ENDC

FREE_LKB:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	TSTW	PCB$W_ASTCNT(R4)		; Test for enough AST quota
	BLEQ	80$				; Error - not enough
	MOVZWL	#LKB$K_ACBLEN,R1		; Size of ACB to allocate
	JSB	G^EXE$ALLOCBUF			; Allocate ACB
	BLBC	R0,90$				; Error - insuff. memory
	MOVB	#DYN$C_ACB,ACB$B_TYPE(R2)	; Store data structure type
	DECW	PCB$W_ASTCNT(R4)		; Decrement AST quota
10$:	SETIPL	95$				; Raise to IPL$_SYNCH and 
						; lock pages in memory

	; If CVTTOSYS bit is set, then this LKB should be converted
	; to system owned.  Do it now instead of in LOCK_KAST.

	BBC	#LKB$V_CVTTOSYS,-		; Branch if CVTTOSYS is clear
		LKB$W_STATUS(R6),20$
	JSB	G^CVT_TO_SYS_INT		; Convert to system owned
20$:	BICW	#LKB$M_DBLKAST-			; Clear deliver blocking AST bit
		!LKB$M_CVTTOSYS,-		; and convert to system owned bit
		LKB$W_STATUS(R6)
	PUSHL	R2				; Save ACB address
	MOVC3	#LKB$K_ACBLEN,(R6),(R2)		; Copy ACB portion of LKB
	POPL	R2				; Restore ACB address
	BISB	#ACB$M_QUOTA,ACB$B_RMOD(R2)	; Set quota accounting flag
	BICB	#ACB$M_NODELETE,ACB$B_RMOD(R2)	; Clear nodelete flag
	BISW	#LKB$M_NOQUOTA,-		; Set NOQUOTA bit so that 
		LKB$W_STATUS(R2)		; enqueue quota is not credited
	MOVL	R6,R5				; Address of LKB
	JSB	G^SCH$SWAPACBS			; Swap ACBs
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	SETIPL	#IPL$_ASTDEL			; Lower IPL
	RSB

80$:	MOVZWL	#SS$_EXASTLM,R0
90$:	JMP	ERROR_EXIT_R0

95$:	.LONG	IPL$_SYNCH			; End of locked down code
	ASSUME	.-10$  LE  512			; Must be on adjoining pages


	.END
