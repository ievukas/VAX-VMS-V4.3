	.TITLE	TIMESCHDL - TIME DEPENDENT SCHEDULING
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 15-JUN-76
;
; TIME RELATED ACTIVITY
;
;	UPDATE TIME OF DAY,
;	CHECK FOR ITEM READY IN TIMER QUEUE, AND
;	PERFORM DEVICE TIMEOUT.
;	UPDATE MEASUREMENT STATISTICS IF MEASUREMENT IS ENABLED.
;
; MODIFICATION HISTORY:
;
;	V03-013	CWH3012		CW Hobbs		29-Apr-1984
;		Change all W^SCH$Gxxx references to L^SCH$Gxxx to
;		fix current (and future) branch problems.
;
;	V03-012	WMC0012		Wayne Cardoza		23-Apr-1984
;		Declare pagedmeory and mailbox resources available once per 
;		second just in case...
;
;	V03-011	CWH3011		CW Hobbs		14-Apr-1984
;		Fixed broken branch.
;
;	V03-010	SRB0118		Steve Beckhardt		26-Mar-1984
;		Fixed broken branches.
;
;	V03-009	SRB0117		Steve Beckhardt		17-Mar-1984
;		Removed loop around checking for locks on the timeout queue
;		needing a deadlock search.  This loop is now in the module
;		DEADLOCK.
;
;	V03-008	MIR0200		MICHAEL I. ROSENBLUM	15-OCT-1983
;		Remove the setipl to DIPL when RDUTIM expires
;		To allow the driver using this service to do it's
;		own synchronization.
;	V03-007	DWT0123		David W. Thiel		22-Aug-1983
;		Declare non-paged dynamic memory available once per
;		second.
;
;	V03-006	SRB0099		Steve Beckhardt		15-July-1983
;		Added loop to deadlock detection timeout code to allow
;		finding more than one deadlock per second.
;
;	V03-005	ROW0190		Ralph O. Weber		 3-MAY-1983
;		Rewrite fork-and-wait processing using newly acquired 
;		knowledge of how to move a queue from one header to another.  
;		This better protects against infinite looping during the 
;		processing of the fork-and-wait queue.
;
;	V03-004	ROW0176		Ralph O. Weber		 4-APR-1983
;		Add code to process fork-and-wait queue to EXE$TIMEOUT.
;
;	V03-003	SRB0056		Steve Beckhardt		14-Dec-1982
;		Modified code to allow IPL$_SYNCH and IPL$_TIMER to be IPL 8
;		while IPL$_TIMERFORK is IPL 7.
;
;	V03-002	SPF0200		Steve Forgey		1-Jun-1982
;		Add alternate entry point to interval timer interrupt service
;		routine for Unibus clock interrupt.
;
;	V03-001	ROW0078		Ralph O. Weber		1-APR-1982
;		Enhance documentation regarding multiple use of timer queue
;		entry blocks.
;
;
	.PAGE
	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
 
	$ACBDEF				;DEFINE ACB OFFSETS
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$ERLDEF				;DEFINE ERL OFFSETS
	$FKBDEF				;DEFINE FORK BLOCK OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LKBDEF				;DEFINE LKB OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PHDDEF				;DEFINE PHD OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRIDEF				;DEFINE PRIORITY INCREMENTS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RSNDEF				;DEFINE RESOURCE WAIT NUMBERS
	$STATEDEF			;DEFINE SCHEDULER STATE VALUES
	$TQEDEF				;DEFINE TQE OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$TTYDEFS			; TTY UCB extension (must FOLLOW $UCBDEF)
	$TTYDEF				;DEFINE TTY SYMBOLS
	.PAGE
	.SBTTL	HARDWARE CLOCK INTERRUPTS
;+
; EXE$HWCLKINT - HARDWARE CLOCK INTERRUPT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN THE CLOCK COUNT REGISTER
; OVERFLOWS. THE CURRENT ABSOLUTE TIME IS UPDATED, THE ACCOUNTING INTEGRAL
; OF THE CURRENT PROCESS IS INCREMENTED, AND THE QUANTUM OF THE CURRENT
; PROCESS IS INCREMENTED. IF THE PROCESS QUANTUM TRANSISTS TO ZERO OR THE
; FIRST ENTRY IN THE TIMER QUEUE CAN BE REMOVED, THEN A SOFTWARE INTERRUPT
; IS REQUESTED ON THE TIMER LEVEL. THE CLOCK INTERRUPT IS THEN DISMISSED.
;
;	THE CLOCK IS CURRENTLY SET TO INTERRUPT AT 10MS INTERVALS.
;-
 
	.PSECT	A$EXENONPAGED,LONG
EXE$HWCLKINT::				;HARDWARE CLOCK INTERRUPT
	MTPR	#^X800000C1,#PR$_ICCS	;CLEAR INTERRUPT + ERROR AND RE-ENABLE
	NOP				;FORCE NEXT INST. TO LONGWORD ALIGN
EXE$UBCLKINT::
	PUSHL	R0			;SAVE REGISTER R0
	ADDL	#100000,W^EXE$GQ_SYSTIME ;UPDATE SYSTEM ABSOLUTE TIME
	ADWC	#0,W^EXE$GQ_SYSTIME+4	;

;
; IF MEASUREMENT IS ENABLED, UPDATE TIMER STATISTICS FIELDS.
;

	.IF NE	CA$_MEASURE

	CVTBL	11(SP),R0		;GET UPPER BYTE OF SAVED PSL
	BGEQ	20$			;BRANCH IF CM BIT NOT SET
	MOVZBL	#5,R0			;ELSE INSERT CM INDEX
20$:	BICB	#^XF8,R0		;CONVERT EXTENDED BYTE TO INDEX
	INCL	W^PMS$GL_KERNEL[R0]	;INCREMENT STATISTICS VECTOR

	.ENDC

	BBS	#PSL$V_IS,8(SP),25$	;IF SET, DON'T ADD INTERRUPT SERVICE TIME
	MOVL	L^SCH$GL_CURPCB,R0	;GET ADDRESS OF CURRENT PROCESS PCB
	MOVL	PCB$L_PHD(R0),R0	;GET ADDRESS OF PROCESS HEADER
	INCL	PHD$L_CPUTIM(R0)	;INCREMENT ACCOUNTING INTEGRAL
	INCW	PHD$W_QUANT(R0)		;INCREMENT TIME QUANTUM
	BGEQ	30$			;IF GEQ, QUANTUM RUNOUT
25$:
	MOVL	W^EXE$GL_TQFL,R0	;GET ADDRESS OF FIRST ENTRY IN TIME QUEUE
	CMPL	TQE$Q_TIME+4(R0),W^EXE$GQ_SYSTIME+4 ;COMPARE HIGH ORDER PARTS OF TIME
	BLSSU	30$			;IF LSSU ENTRY DUE
	BGTRU	40$			;IF GTRU ENTRY NOT DUE
	CMPL	TQE$Q_TIME(R0),W^EXE$GQ_SYSTIME ;COMPARE LOW ORDER PARTS OF TIME
	BGTRU	40$			;IF GTRU ENTRY NOT DUE
30$:	SOFTINT	#IPL$_TIMERFORK		;REQUEST SOFTWARE INTERRUPT ON TIMER LEVEL
40$:	POPL	R0			;RESTORE R0
	REI				;
	.PAGE
	.SBTTL	SOFTWARE TIMER INTERRUPTS
;+
; EXE$SWTIMINT - SOFTWARE TIMER INTERRUPTS
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A SOFTWARE INTERRUPT IS
; REQUESTED ON THE TIMER LEVEL. TIMER INTERRUPTS ARE REQUESTED WHEN THE
; CURRENT PROCESS HAS EXCEEDED ITS CPU TIME QUANTUM OR THE FIRST ENTRY IN
; THE TIMER QUEUE IS DUE.
;-
	ASSUME	IPL$_TIMER EQ IPL$_SYNCH
 
	.ALIGN	LONG
EXE$SWTIMINT::				;SOFTWARE TIMER INTERRUPTS
	SETIPL	#IPL$_TIMER		;RAISE IPL TO TIMER/SYNCH
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE REGISTERS R0 THRU R5
	MOVL	L^SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	;GET ADDRESS OF PROCESS HEADER
	TSTW	PHD$W_QUANT(R5)		;QUANTUM END?
	BLSS	CHKTMQ			;IF LSS NO
	BSBW	SCH$QEND		;CALL SCHEDULER TO RESET QUANTUM
CHKTMQ:	MOVL	W^EXE$GL_TQFL,R5	;GET ADDRESS OF FIRST ENTRY IN TIME QUEUE
	SETIPL	#IPL$_HWCLK		;RAISE IPL TO HARDWARE CLOCK LEVEL
	CMPL	TQE$Q_TIME+4(R5),W^EXE$GQ_SYSTIME+4 ;COMPARE HIGH ORDER PARTS OF TIME
	BLSSU	20$			;IF LSSU ENTRY IS DUE
	BGTRU	10$			;IF GTRU ENTRY IS NOT DUE
	CMPL	TQE$Q_TIME(R5),W^EXE$GQ_SYSTIME ;COMPARE LOW ORDER PARTS OF TIME
	BLEQU	20$			;IF LEQU ENTRY IS DUE
10$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS R0 THRU R5
	SETIPL	#IPL$_TIMERFORK		;LOWER IPL BACK TO TIMERFORK
	REI				;
 
;
; REMOVE DUE ENTRY FROM TIMER QUEUE
;
 
20$:	REMQUE	(R5),R5			;REMOVE FIRST ENTRY FROM TIME QUEUE
	SETIPL	#IPL$_TIMER		;LOWER IPL TO SOFTWARE TIMER LEVEL
	EXTZV	#0,#2,TQE$B_RQTYPE(R5),R0 ;GET REQUEST TYPE
	CASE	R0,<TIMER,SYSUB,WAKEUP>	;DISPATCH TO PROCESSING ROUTINE
	BUG_CHECK INVTQEFMT		;INVALID TIME QUEUE ENTRY FORMAT
	BRB	CHKTMQ			;
 
;
; PROCESS SYSTEM SUBROUTINE
;
; **** WARNING ****
;
; Upon return from the system subroutine call, this routine expects R5 to 
; contain the address of a valid timer queue entery.  The TQE$V_REPEAT bit 
; of that TQE will be tested, and if it is set, the TQE will be reentered in 
; the timer queue.  Therefore, the call system subroutine CANNOT use the TQE, 
; pointed to by R5 at entry, for some other purpose and return here without 
; placing the address of a valid TQE in R5.
;
; To this end, the executive system table contains a global symbol, 
; EXE$AL_TQENOREPT, which repersents the address of a always valid always 
; non-repeating timer queue entry.  Timer system subroutines wishing to use 
; the TQE which caused them to be called for purposes other than continued 
; use of the timer queue may load the address represented by EXE$AL_TQENOREPT 
; into R5 before returing to this routine.  This prevents duplicate use of 
; the TQE block which resulted in the system subroutine being called.
;
; For example, a system subroutine which decides to discontinue its timed 
; operations and deallocate the TQE would execute at least the following 
; instructions:
;	...
;	MOVL	R5, R0			;NB: this uses the TQE 
;	JSB	G^COM$DRVDEALMEM	;    as an IPL 6 fork block.
;	...
;	MOVAL	G^EXE$AL_TQENOREPT, R5	;Setup no repeat TQE.
;	RSB

SYSUB:	MOVQ	TQE$L_FR3(R5),R3	;LOAD SUBROUTINE CONTEXT
	JSB	@TQE$L_FPC(R5)		;CALL SYSTEM SUBROUTINE
	BBC	#TQE$V_REPEAT,TQE$B_RQTYPE(R5),CHKTMQ ;IF CLR, NOT REPEATABLE
	BRB	REPTIM			;INSERT REPEAT REQUEST IN TIME QUEUE
 
;
; PROCESS TIMER
;
 
	.ENABL	LSB
TIMER:	MOVL	TQE$L_PID(R5),R1	;GET TARGET PROCESS ID
	MOVZBL	#PRI$_TIMER,R2		;SET PRIORITY INCREMENT CLASS
	MOVZBL	TQE$B_EFN(R5),R3	;GET EVENT FLAG NUMBER
	BSBW	SCH$POSTEF		;POST EVENT FLAG
	BLBC	R0,30$			;IF LBC PROCESS NO LONGER IN SYSTEM
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	INCW	JIB$W_TQCNT(R0)		;UPDATE AVAILABLE TIME QUEUE ENTRIES
	BBC	#ACB$V_QUOTA,TQE$B_RMOD(R5),20$ ;IF CLR, NO AST SPECIFIED
	MOVB	TQE$B_RMOD(R5),TQE$B_RQTYPE(R5) ;SET AST ACCESS MODE
	MOVZBL	#PRI$_TIMER,R2		;SET PRIORITY INCREMENT CLASS
	BSBW	SCH$QAST		;QUEUE AST FOR PROCESS
	BRB	40$			;
10$:	MOVZWL	TQE$L_RQPID(R5),R4	;GET REQUESTING PROCESS INDEX
	MOVL	@L^SCH$GL_PCBVEC[R4],R4	;GET PROCESS PCB ADDRESS
	CMPL	PCB$L_PID(R4),TQE$L_RQPID(R5) ;PROCESS ID MATCH?
	BNEQ	30$			;IF NEQ NO
	INCW	PCB$W_ASTCNT(R4)	;UPDATE AVAILABLE AST QUEUE ENTRIES
	BRB	30$			;
20$:	MOVZBL	#RSN$_ASTWAIT,R0	;SET AST WAIT RESOURCE NUMBER
	BSBW	SCH$RAVAIL		;DECLARE RESOURCE AVAILABLE
30$:	MOVL	R5,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	BSBW	EXE$DEANONPAGED		;DEALLOCATE TIME QUEUE ENTRY
	BRB	40$			;
 
;
; PROCESS WAKE UP
;
 
WAKEUP:	MOVL	TQE$L_PID(R5),R1	;GET TARGET PROCESS ID
	BSBW	SCH$WAKE		;WAKE PROCESS
	BLBC	R0,10$			;IF LBC PROCESS NOT IN SYSTEM
	BBC	#TQE$V_REPEAT,TQE$B_RQTYPE(R5),10$ ;IF CLR, THEN NOT REPEATABLE
REPTIM:	MOVQ	TQE$Q_DELTA(R5),R0	;GET DELTA REPEAT TIME
	ADDL	TQE$Q_TIME(R5),R0	;ADD LOW ORDER PARTS OF TIME
	ADWC	TQE$Q_TIME+4(R5),R1	;ADD HIGH ORDER PARTS OF TIME
	BSBW	EXE$INSTIMQ		;INSERT ENTRY IN TIME QUEUE
40$:	BRW	CHKTMQ			;
	.DSABL	LSB
	.PAGE
	.SBTTL	SEARCH FOR TIME OUTS
;+
; EXE$TIMEOUT - SEARCH FOR TIME OUTS
;
; THIS ROUTINE IS ENTERED ONCE A SECOND TO PERFORM VARIOUS FUNCTIONS THAT
; NEED TO BE PERFORMED ONCE A SECOND.  THESE INCLUDE:
;
;	1)  SCAN THE DEVICE DATABASE FOR DEVICES THAT MAY HAVE TIMED OUT
;	2)  SCAN FOR CRB'S  THAT MAY HAVE TIMED OUT
;	3)  SCAN FOR WAITING LOCKS THAT MAY HAVE TIMED OUT (INITIATE
;	    DEADLOCK SEARCH)
;	4)  WAKE THE SWAPPER, IF NECESSARY
;	5)  WAKE THE ERROR LOG PROCESS, IF NECESSARY
;	6)  SCAN FOR MEMORY CRD ERRORS AND REENABLE MEMORY INTERRUPTS
;	7)  UPDATE THE SYSTEM ABSOLUTE TIME IN SECONDS
;	8)  DECLARE A NON-PAGED DYNAMIC MEMORY AVAILABLE EVENT
;-
 
EXE$TIMEOUT::				;SEARCH FOR TIME OUTS
	PUSHL	R6			;SAVE A REGISTER
	PUSHL	R5			;SAVE ANOTHER
	MOVL	DDB$L_LINK(R3),R6	;GET ADDRESS OF FIRST DDB
	BSBW	SCH$SWPWAKE		;WAKE SWAPPER IF NECESSARY
	INCL	W^EXE$GL_ABSTIM		;UPDATE ABSOLUTE TIME IN SECONDS
	BBC	#ERL$V_TIMER,W^ERL$GB_BUFFLAG,10$ ;IF CLR, TIMER NOT ACTIVE
	BSBW	ERL$WAKE		;WAKE ERROR LOG FORMAT PROCESS
10$:	BSBW	ECC$REENABLE		;WAKE CRD INTERRUPT REENABLE AND SCAN

;
; SCAN FOR DEVICE TIMEOUTS
;

20$:	MOVL	DDB$L_UCB(R6),R5	;GET ADDRESS OF FIRST UCB
	BEQL	60$			;EQL MEANS NO UCB'S AS YET ON THIS DDB
	BBS	#DEV$V_MBX,UCB$L_DEVCHAR(R5),60$ ;IF SET, DEVICE IS MAILBOX
30$:	BBS	#UCB$V_TIM,UCB$W_STS(R5),70$ ;IF SET, TIME OUT ENABLED
40$:	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),50$ ;IF CLR, DEVICE NOT TERMINAL
	BBS	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),90$ ;IF SET, READ TIMEOUT ENABLED
50$:	MOVL	UCB$L_LINK(R5),R5	;GET ADDRESS OF NEXT UCB
	BNEQ	30$			;IF NEQ MORE TO SCAN
60$:	MOVL	DDB$L_LINK(R6),R6	;GET ADDRESS OF NEXT DDB
	BNEQ	20$			;IF NEQ MORE TO SCAN

;
; FINISHED DEVICE SCAN, NOW CHECK THE LIST OF CRB'S
;

	MOVAL	W^IOC$GL_CRBTMOUT,R6	;PICK UP LIST HEAD
65$:	MOVL	(R6),R6			;ANY MORE TO SCAN?
	BEQL	CHECK_FORK_N_WAIT	;NO, DONE
	SETIPL	#IPL$_POWER		;SET TO POWERFAIL
	CMPL	CRB$L_DUETIME-CRB$L_TIMELINK(R6),-
		W^EXE$GL_ABSTIM		;YES, IS THIS ONE DUE?
	BGTRU	66$			;NO, SCAN AGAIN
	MOVAL	-CRB$L_TIMELINK(R6),R3	;YES, PICK UP POINTER TO CRB
	MNEGL	#1, CRB$L_DUETIME(R3)	;SET FOR NO MORE TIMEOUTS
	JSB	@CRB$L_TOUTROUT(R3)	;CALL THE TIMEOUT ROUTINE
66$:	SETIPL	#IPL$_TIMER		;RESET THE IPL
	BRB	65$			;CONTINUE SCAN


;
; DEVICE HAS ENABLED TIME OUT - SEE IF IT HAS TIMED OUT
;

70$:	CMPL	UCB$L_DUETIM(R5),W^EXE$GL_ABSTIM ;POSSIBLE TIME OUT?
	BGTRU	40$			;IF GTRU NO
	SETIPL	#IPL$_POWER		;RAISE TO POWERFAIL IPL
	BBC	#UCB$V_TIM,UCB$W_STS(R5),80$ ;IF CLR, THEN TIME OUT NOT ENABLED
	CMPL	UCB$L_DUETIM(R5),W^EXE$GL_ABSTIM ;DEVICE TIME OUT?
	BGTRU	80$			;IF GTRU NO
	BICW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;DISABLE INTERRUPT AND TIMEOUT
	BISW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;SET DEVICE TIMED OUT
	SETIPL	UCB$B_DIPL(R5)		;LOWER TO DEVICE IPL
	MOVQ	UCB$L_FR3(R5),R3	;RETRIEVE SAVED R3 AND R4
	MOVL	UCB$L_FPC(R5),R2	;GET SAVED PC
	CVTWL	-(R2),-(SP)		;GET OFFSET TO EXCEPTION ROUTINE
	ADDL	(SP)+,R2		;CALCULATE ADDRESS OF EXCEPTION ROUTINE
	JSB	(R2)			;CALL EXCEPTION ROUTINE
80$:	SETIPL	#IPL$_TIMER		;LOWER IPL TO THAT OF TIMER
	BRB	40$			;
 
;
; TERMINAL READ TIMED IN PROGRESS
;
 
90$:	CMPL	UCB$L_TT_RDUE(R5),W^EXE$GL_ABSTIM ;TIME OUT POSSIBLE?
	BGTRU	50$			;IF GTRU THEN NO
	SETIPL	#IPL$_POWER		;RAISE TO DEVICE IPL
	BBC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),100$ ;IF CLR, TIMEOUT NOT ENABLED
	CMPL	UCB$L_TT_RDUE(R5),W^EXE$GL_ABSTIM ;TIMED OUT?
	BGTRU	100$			;IF GTRU THEN NO
	JSB	@UCB$L_TT_RTIMOU(R5)	;GO OFF TO THE TERMINAL SERVICE
100$:	SETIPL	#IPL$_TIMER		;LOWER IPL TO THAT OF TIMER
	BRW	50$			;


;
; PROCESS THE FORK-AND-WAIT WORK QUEUE
;
; To avoid an infinite loop of executing new entries placed on the work queue 
; by fork threads resumed from the work queue, the entire work queue is 
; removed from the normal header and hung on a header allocated on the stack.  
; The normal queue header is then initialized thus providing a proper target 
; of new queue insertion operations.
;
	ASSUME	FKB$L_FR4 EQ <FKB$L_FR3 + 4>

CHECK_FORK_N_WAIT:
	MOVAL	W^EXE$GL_FKWAITFL, R6	; Get fork-&-wait queue header address.
	CMPL	(R6), R6		; Is the queue empty?
	BEQL	CHECK_LOCKS		; Branch if queue is empty.
	SUBL	#8, SP			; Make space on stack for header.
	REMQUE	(R6), R5		; Dequeue the work queue header.
	INSQUE	(SP), @4(R5)		; Queue stack header in its place.
	MOVL	R6, (R6)		; Make real fork=&-wait queue empty.
	MOVL	R6, 4(R6)		;
10$:	REMQUE	@(SP), R5		; Get an entry from stack work queue.
	BVS	90$			; Branch if stack work queue empty.
	MOVQ	FKB$L_FR3(R5), R3	; Restore fork context.
	DSBINT	FKB$B_FIPL(R5)		; Establish fork IPL.
	JSB	@FKB$L_FPC(R5)		; Restart fork thread.
	ENBINT				; Restore our IPL.
	BRB	10$			; Loop through entire stack work queue.
90$:	ADDL	#8, SP			; All done: pop queue header from stack.
;	JMP	CHECK_LOCKS		; Then, fall through to checking locks.


;
; SCAN FOR WAITING LOCKS THAT MAY HAVE TIMED OUT.  INITIATE A DEADLOCK
; SEARCH IF ONE IS FOUND.
;

CHECK_LOCKS:
	MOVAL	W^LCK$GL_TIMOUTQ,R5	;GET ADDRESS OF LIST HEAD
10$:	MOVL	(R5),R6			;GET FIRST ENTRY ON LIST
	CMPL	R5,R6			;IS LIST EMPTY?
	BEQL	20$			;YES
	CMPL	LKB$L_DUETIME(R6),-	;NO, HAS THIS ONE TIMED OUT?
		W^EXE$GL_ABSTIM
	BGTRU	20$			;NO, ALSO NO NEED TO LOOK FURTHER
					;AS LIST IS ORDERED
	BSBW	LCK$SEARCHDLCK		;SEARCH FOR DEADLOCK
					;DON'T REPEAT LOOP HERE; IT'S DONE
					;IN DEADLOCK
20$:
;
; SCAN PCB VECTOR FOR PROCESSES NEEDING PRIORITY BOOST
;
SCAN_PROC:
	MOVZWL	W^SGN$GW_PIXSCAN,R5	;GET NUMBER OF PROCESSES TO SCAN
	BEQL	100$			;NONE, DO NOTHING
	MOVZWL	W^EXE$GW_SCANPIX,R6	;GET PIX TO CHECK
10$:	MOVL	@L^SCH$GL_PCBVEC[R6],R4	;FETCH PCB ADDRESS FOR PIX
	CMPW	R6,PCB$L_PID(R4)	;IS THIS AN ACTIVE PCB?
	BNEQ	20$			;NO, SKIP IT.
	BISW3	#1,PCB$W_STATE(R4),R0	;GET STATE u 1
	CMPW	#<SCH$C_COM!1>,R0	;IS STATE COM OR COMO?
	BNEQ	20$			;BR IF NOT
	MOVL	L^SCH$GL_COMQS,R0	;GET SUMMARY LONGWORD
	EXTZV	#0,#5,L^SCH$GB_PRI,R1	;GET CURRENT PRIORITY
	BBSS	R1,R0,15$		;SET BIT FOR CURRENT PROCESS
15$:	FFS	#16,#15,R0,R0 		;GET HIGHEST BACKGROUND PRIORITY
	CMPB	R0,PCB$B_PRI(R4)	;IS PROCESS ALREADY HIGHER PRIORITY?
	BGEQ	20$			;BR IF SO
	BSBW	SCH$CHSEP		;SET TEMPORARY PRIORITY BOOST
20$:	AOBLEQ	L^SCH$GL_MAXPIX,R6,30$	;NEXT PROCESS INDEX
	MOVL	#2,R6			;SET TO START PAST SWAPPER AND NULL
30$:	SOBGTR	R5,10$			;SCAN FOR NUMBER OF PROCESSES REQUESTED
	MOVW	R6,W^EXE$GW_SCANPIX	;SAVE NEW VALUE
100$:					;
;
; DECLARE NON-PAGED AND PAGED DYNAMIC MEMORY AVAILABLE.  THIS IS NECESSARY 
; BECAUSE IN CERTAIN RARE CASES, THE MEMORY ALLOCATION ROUTINES MAY FAIL TO DO
; THIS AS OFTEN AS NECESSARY.
; THE MAILBOX RESOURCE IS ALSO DECLARED AVAILABLE FOR SIMILAR REASONS.
;

	MOVZWL	#RSN$_NPDYNMEM,R0	;NON-PAGED DYNAMIC MEMORY RESOURCE
	BSBW	SCH$RAVAIL		;DECLARE RESOURCE AVAILABLE
	MOVZWL	#RSN$_PGDYNMEM,R0	;PAGED DYNAMIC MEMORY RESOURCE
	BSBW	SCH$RAVAIL		;DECLARE RESOURCE AVAILABLE
	MOVZWL	#RSN$_MAILBOX,R0	;MAILBOX RESOURCE
	BSBW	SCH$RAVAIL		;DECLARE RESOURCE AVAILABLE

;
; ALL DONE - RETURN
;

TIMEOUT_DONE:
	MOVQ	(SP)+,R5		;RESTORE REGISTERS
	RSB				;RETURN
 
	.END
