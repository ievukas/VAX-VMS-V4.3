%TITLE 'NDXFMT -- Binary index formatter'
MODULE NDXFMT (IDENT = 'V04-000'
		    %BLISS32 [, ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE)]
		) =
BEGIN
!
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!   DSR (Digital Standard RUNOFF) /DSRPLUS DSRINDEX/INDEX Utility
!
! ABSTRACT:
!	This module contains the code to generate the output index lines
!	from the internal binary index. The output lines are formatted 
!	into pages by module NDXPAG. This module was adopted from the TCX
!	modules XPASSA and XPASSB.
!
! ENVIRONMENT:   Transportable
!
! AUTHOR: 	 JPK
!
! CREATION DATE: January 1982
!
! MODIFIED BY:
!
!	013	JPK00022	30-Mar-1983
!		Modified NDXVMS, NDXFMT, NDXPAG, NDXVMSMSG and NDXVMSREQ 
!		to generate TEX output. Added module NDXTEX.
!
!	012	JPK00021	28-Mar-1983
!		Modified NDXT20 to include E2.0 functionality.
!		Modified NDXCLIDMP, NDXFMT, NDXPAG, NDXVRS to require RNODEF
!		for BLISS36 and to remove any conditional require based on 
!		DSRPLUS_DEF.
!
!	011	JPK00020	17-Mar-1983
!		Modified NDXFMT to generate a ".NO PAGING" in the prologue
!		for /LAYOUT=GALLEY
!
!	010	JPK00018	09-Mar-1983
!		Modified INDEX to handle new BRN format.
!		Modified NDXOUT to handle specifyable levels on SORT= string.
!		Modified NDXFMT to output new RUNOFF prologue.
!		Modified NDXPAG to output new TMS prologue and RUNOFF epilogue.
!
!	009	JPK00017	23-Feb-1983
!		Modified NDXINI to initialize the zero'th entries of LLINES,
!		RLINES and TLINES which is where the telltale strings are 
!		stored by NDXFMT.
!		Modified NDXFMT to write appropriate prologue for /TELLTALE,
!		save the appropriate lines for left and right telltales, and
!		to mark the end of every entry with a NULL.
!		Modified NDXPAG to change the NULL following each entry to a
!		space if LAYOUT is SEPARATE or to a comma otherwise and to 
!		generate and output telltales.
!
!	008	JPK00015	04-Feb-1983
!		Cleaned up module names, modified revision history to
!		conform with established standards. Updated copyright dates.
!
!	007	JPK00012	24-Jan-1983
!		Modified NDXVMSMSG.MSG to define error messages for both
!		DSRINDEX and INDEX.
!		Added require of NDXVMSREQ.R32 to NDXOUT, NDXFMT, NDXDAT,
!		INDEX, NDXMSG, NDXXTN, NDXTMS, NDXVMS and NDXPAG for BLISS32. 
!		Since this file defines the error message literals, 
!		the EXTERNAL REFERENCEs for the error message literals 
!		have been removed.
!
!	006	JPK00011	24-Jan-1983
!		Changed CMDBLK [NDX$G_LEVEL] to CMDBLK [NDX$H_LEVEL]
!		Changed CMDBLK [NDX$H_FORMAT] to CMDBLK [NDX$H_LAYOUT]
!		Changed CMDBLK [NDX$V_TMS11] and CMDBLK [NDX$V_TEX] to CMDBLK [NDX$H_FORMAT]
!		Changed comparisons of (.CHRSIZ EQLA CHRSZA) to 
!		(.CMDBLK [NDX$H_FORMAT] EQL TMS11_A).
!		Definitions were changed in NDXCLI and references to the
!		effected fields were changed in NDXPAG, NDXFMT, INDEX, NDXVMS
!		and NDXCLIDMP.
!
!	005	JPK00010	24-Jan-1983
!		Removed routines GETDAT and UPDDAT from NDXDAT - they 
!		performed no useful function. Removed references to these
!		routines from NDXOUT, NDXFMT, and NDXMSG.
!		Removed reference to XPOOL in NDXOUT - not used.
!
!	004	JPK00009	24-Jan-1983
!		Modified to enhance performance. The sort buckets have each
!		been divided into 27 sub-buckets; 1 for each letter and 1
!		for non-alphas. Removed reference to BUCKET from INDEX.
!		Definition of the structure was added to NDXPOL. References
!		to BUCKET were changed in modules NDXOUT, NDXINI, NDXFMT 
!		and NDXDAT.
!
!	003	JPK00006	24-Sep-1982
!		Modified NDXFMT to ignore REQUIRE file if filename string 
!		is null. Added bold guide headings for RUNOFF output.
!
!	002	JPK00004	24-Sep-1982
!		Modified NDXOUT, NDXMSG, NDXFMT, and NDXDAT for TOPS-20. 
!		Strings stored in the index pool use the first fullword 
!		for their length. References to these strings were incorrect.
!
!--

%SBTTL 'Module level declarations'
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    NDXFMT	: NOVALUE,		! Generate output index
    EXAM_BUCKET	: NOVALUE,		! Examine bucket
    FORMAT_ENTRY: NOVALUE,		! Format an index entry
    INS_PAGE_NO	: NOVALUE,		! Insert page number(s) in print line
    BOOK_REF	: NOVALUE,		! Insert book name in master index
    PAGE_REF	: NOVALUE,		! Convert page reference to ASCII
    SAMEPG,				! Compare page references
    SAME_ATTR,				! Page references have same attributes
    INS_LINE	: NOVALUE,		! Insert line into page
    SAVE_TELLTALE_HEADING : NOVALUE,	! Save line as telltale heading
    LAST_LINE	: NOVALUE,		! Process last line in column
    DO_CONTINUE : NOVALUE,		! Generate continuation heading if necessary
    FILL_LINE	: NOVALUE,		! Pack the print line
    INDENT_LINE	: NOVALUE,		! Indent a new line
    PADLIN	: NOVALUE;		! Pad line to column width

!
! INCLUDE FILES:
!
LIBRARY 'NXPORT:XPORT';

SWITCHES LIST (REQUIRE);

REQUIRE 'REQ:NDXPOL';

REQUIRE 'REQ:NDXCLI';

REQUIRE 'REQ:NDXLIN';

REQUIRE 'REQ:PAGEN';

%IF %BLISS (BLISS32)
%THEN

REQUIRE 'REQ:NDXVMSREQ';

%FI

%IF %BLISS (BLISS36)
%THEN

REQUIRE 'REQ:RNODEF';

%FI

SWITCHES LIST (NOREQUIRE);

!
! MACROS:
!
MACRO
    !
    ! Don't quote the character, and it doesn't count visually.
    !
    NQCHAR_NC (X) =
	BEGIN
	CH$WCHAR_A(X, WORD_POINTER);
	INT_WORD_LENGTH = .INT_WORD_LENGTH + 1;
	END	%,

    !
    ! Don't quote the character, and it does count visually.
    !
    NQCHAR_C (X) =
	BEGIN
	NQCHAR_NC (X);
	EXT_WORD_LENGTH = .EXT_WORD_LENGTH + 1;
	TMS_WORD_LENGTH = .TMS_WORD_LENGTH + .CHRSIZ [X];
	END	%,

    !
    ! Quote the character; it doesn't count visually.
    !
    QCHAR_NC (X) =
	BEGIN
	NQCHAR_NC (%C'_');
	NQCHAR_NC (X);
	END	%,

    !
    ! Quote the character; it does count visually.
    !
    QCHAR_C (X) =
	BEGIN
	NQCHAR_NC (%C'_');
	NQCHAR_C (X);
	END	%,

    !
    ! Special macro to keep track of the backspace control character.
    !
    BACKSPACE (X) =
	BEGIN
	QCHAR_NC (X);
	EXT_WORD_LENGTH = .EXT_WORD_LENGTH - 1;
	END	%,

    !
    ! Clear the text lines being built up.
    !
    CLR_RNO_LINE (_) =
	BEGIN
	LINE_POINTER = CH$PTR (RNO_LINE);
	INT_LINE_LENGTH = 0;
	EXT_LINE_LENGTH = 0;
	TMS_LINE_LENGTH = 0;
	END	%,

    !
    ! Clear the word being built
    !
    CLR_RNO_WORD (_) =
	BEGIN
	WORD_POINTER = CH$PTR (RNO_WORD);
	INT_WORD_LENGTH = 0;
	EXT_WORD_LENGTH = 0;
	TMS_WORD_LENGTH = 0;
	HYPHENATE = FALSE;
	END	%,

    !
    ! Write a line to the output file
    !
    PUT_LINE (S) =
	$XPO_PUT (IOB = OUTIOB, STRING = S) %;

!
! EQUATED SYMBOLS:
!
LITERAL
    TRUE = 1,
    FALSE = 0;

LITERAL
    TMS_SAFETY_MARGIN = 4;			! Subtracted from # chars / line to avoid wrapping

!
! OWN STORAGE:
!
OWN
    BLANKS : INITIAL (CH$PTR (UPLIT ('    ')));	! Pointer to blanks

OWN
    LINE_POINTER,
    RNO_LINE : VECTOR [CH$ALLOCATION (1200)],
    INT_LINE_LENGTH,
    EXT_LINE_LENGTH,
    TMS_LINE_LENGTH,
    LINE_TYPE,
    PAGE_WIDTH;

OWN
    DOING_LAST;					! TRUE if processing last line

OWN
    SAVE_ENTRY : INITIAL (FALSE);		! TRUE if saw guide head at top of left page

!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
    TAB    : UNSIGNED (8),
    MAXLST,
    TMSSTD,					! Average TMS character size
    MSPACE,					! TMS 'em' space size
    RINTES : UNSIGNED (8);

EXTERNAL
    CMDBLK : $NDXCMD,				! Command line information block
    NDXVRL,					! Length of version string
    NDXVRP,					! CH$PTR to version string
    OUTIOB : $XPO_IOB (),			! Output file IOB
    LSTPTR : REF $XE_BLOCK,
    INDLVL,					! Index level
    LSTSTK : VECTOR,				! Temporary stack for storing back links
    BUCKET : $BUCKET_ARRAY [27, 27],		! Hashing buckets
    CHRSIZ : REF VECTOR,			! TMS11 character size vector
    ALLOWD,					! Usuable lines per page
    LCOUNT,					! Number of lines in left column
    RCOUNT,					! Number of lines in right column
    TCOUNT,					! Number of lines in temp column
!
! NOTE: The vectors and blockvectors below have two extra entries allocated
!	to avoid needing to subtract 1 all the time (for entry zero),
!	and so that there will always be an available line at the end of the column
!
    LTYPE  : VECTOR,				! Left column line types
    LLINES : BLOCKVECTOR [, STR$K_D_BLN],	! Left column string descriptors
    RTYPE  : VECTOR,				! Right column line types
    RLINES : BLOCKVECTOR [, STR$K_D_BLN],	! Right column string descriptors
    TTYPE  : VECTOR,				! Temp column line types
    TLINES : BLOCKVECTOR [, STR$K_D_BLN];	! Right column for last page

EXTERNAL ROUTINE

%IF %BLISS (BLISS32)
%THEN

    OPEN_ERROR,					! File open error processor

%FI

    ENTMSG   : NOVALUE,
    GENTRY,
    LASTPG   : NOVALUE,
    PACBAS,
    PACPAG,
    PAGEQL,
    PAGMRG,
    PUTPAG   : NOVALUE,
    TMSINI   : NOVALUE,
    TMSPUT   : NOVALUE,
    XTNPAG;

%SBTTL 'NDXFMT -- Build output index from internal index'
GLOBAL ROUTINE NDXFMT : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the top-level control routine of the formatting
!	procedure.
!
!	If output is being generated for RUNOFF, a "standard" RUNOFF
!	environment is set up. 
!
!	If a require file was specified, it is copied to the output file.
!
!	Each bucket of the binary index is then examined to form the
!	output index. The nonalpha bucket is examined first if either
!	/SORT=NONALPHA=BEFORE or /SORT=NONALPHA=IGNORE were specified
!	on the command line. Otherwise, the nonalpha bucket is examined last.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	CMDBLK	     - Command line information block
!
! IMPLICIT OUTPUTS:
!
!	INDLVL		- subindex level
!	PAGE_WIDTH	- width of output page
!	ALLOWD		- number of lines allowed on first page of index
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN
    LOCAL
	DSC_PTR : REF $STR_DESCRIPTOR (),
	CMD_LEN,
	CMD_PTR,
	PTR;

    !
    ! Initialization
    !
    LCOUNT = 0;
    RCOUNT = 0;
    DOING_LAST = FALSE;

    SELECTONE .CMDBLK [NDX$H_LAYOUT] OF
    SET

    [SEPARATE]:
	PAGE_WIDTH = .CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID] + .CMDBLK [NDX$G_SEPARATE_WIDTH];

    [TWO_COLUMN]:
	PAGE_WIDTH = (2 * .CMDBLK [NDX$G_COLUMN_WID]) + .CMDBLK [NDX$G_GUTTER_WID];

    [OTHERWISE]:
	PAGE_WIDTH = .CMDBLK [NDX$G_COLUMN_WID];

    TES;

    !
    ! Reformat command line before outputting.
    !	Change '<' to '['
    !	Change '>' to ']'
    !	Change ';' to '.'
    !
    DSC_PTR = CMDBLK [NDX$T_COMMAND_LINE];
    CMD_LEN = .DSC_PTR [STR$H_LENGTH];
    CMD_PTR = .DSC_PTR [STR$A_POINTER];

    WHILE NOT CH$FAIL (PTR = CH$FIND_CH (.CMD_LEN, .CMD_PTR, %C'<')) DO
	CH$WCHAR (%C'[', .PTR);

    WHILE NOT CH$FAIL (PTR = CH$FIND_CH (.CMD_LEN, .CMD_PTR, %C'>')) DO
	CH$WCHAR (%C']', .PTR);

    WHILE NOT CH$FAIL (PTR = CH$FIND_CH (.CMD_LEN, .CMD_PTR, %C';')) DO
	CH$WCHAR (%C'.', .PTR);

    !
    ! Compute number of lines allowed on first page
    !
    IF .CMDBLK [NDX$G_RESERVE_LINES] NEQ 0
    THEN
	!
	! Number of lines on first page is lines per page
	! minus number of reserved lines.
	!
	ALLOWD = .CMDBLK [NDX$G_LINES_PAGE] - .CMDBLK [NDX$G_RESERVE_LINES]
    ELSE
	BEGIN

	IF .CMDBLK [NDX$H_FORMAT] EQL DSR
	THEN
	    ALLOWD = .CMDBLK [NDX$G_LINES_PAGE] - 4	! Default for RUNOFF
	ELSE
	    ALLOWD = .CMDBLK [NDX$G_LINES_PAGE] - 22;	! Default for TMS and TEX

	END;

    !
    ! Write output dependant prologue
    !
    SELECTONE .CMDBLK [NDX$H_FORMAT] OF
	SET

	[DSR]:
	    BEGIN
	    !
	    ! RUNOFF output
	    !
	    ! Generate a "standard" RUNOFF environment. 
	    !
%IF DSRPLUS
%THEN

	    PUT_LINE ($STR_CONCAT ('.! INDEX version ', (.NDXVRL, .NDXVRP)));

%ELSE

	    PUT_LINE ($STR_CONCAT ('.! DSRINDEX version ', (.NDXVRL, .NDXVRP)));

%FI

	    PUT_LINE ($STR_CONCAT ('.! ', .DSC_PTR));
	    PUT_LINE ('.SAVE');
	    PUT_LINE ('.NO FLAGS ALL');
	    PUT_LINE ('.NO FLAGS BREAK		.NO FLAGS CAPITALIZE	.NO FLAGS ENDFOOTNOTE');
	    PUT_LINE ('.NO FLAGS HYPHENATE	.NO FLAGS INDEX		.NO FLAGS LOWERCASE');
	    PUT_LINE ('.NO FLAGS PERIOD	.NO FLAGS SPACE		.NO FLAGS SUBSTITUTE');
	    PUT_LINE ('.NO FLAGS UPPERCASE');
	    PUT_LINE ('.FLAGS ACCEPT _		.FLAGS BOLD *		.FLAGS COMMENT !');
	    PUT_LINE ('.FLAGS OVERSTRIKE %	.FLAGS UNDERLINE &');
	    PUT_LINE ('.FLAGS ALL');
	    PUT_LINE ('.NO FILL		.NO JUSTIFY');

	    PUT_LINE (
		$STR_CONCAT (
		    '.LEFT MARGIN 0		.RIGHT MARGIN ',
		    $STR_ASCII (.PAGE_WIDTH),
		    '	.PAGE SIZE , ',
		    $STR_ASCII (.PAGE_WIDTH)
		)
	    );

	    PUT_LINE ('.NUMBER INDEX		.NUMBER PAGE 1		.FIRST TITLE');

	    IF .CMDBLK [NDX$V_TELLTALE]
	    THEN
		BEGIN
		!
		! Generate prologue to set up for /TELLTALE
		!
		PUT_LINE ('.LAYOUT 2,2');
		PUT_LINE ('.TITLE');
		PUT_LINE ('.SUBTITLE');
		END;

	    IF .CMDBLK [NDX$H_LAYOUT] EQL GALLEY THEN PUT_LINE ('.NO PAGING');
	    END;

	[TMS11_A, TMS11_E]:
	    !
	    ! Generate TMS11 heading
	    !
	    TMSINI ();

	[TEX]:
	    BEGIN
	    !
	    ! Generate a heading for TEX
	    !
	    PUT_LINE ($STR_CONCAT ('% INDEX version ', (.NDXVRL, .NDXVRP)));
	    PUT_LINE ($STR_CONCAT ('% ', .DSC_PTR));
	    PUT_LINE ('\twocolindex');
	    END;

	TES;

    DSC_PTR = CMDBLK [NDX$T_REQUIRE_FILE];

    IF .CMDBLK [NDX$V_REQUIRE] AND (.DSC_PTR [STR$H_LENGTH] GTR 0)
    THEN
	BEGIN
	!
	! User specified a require file. Insert it here.
	!
	LOCAL
	    REQUIRE_IOB : $XPO_IOB ();

	$XPO_IOB_INIT (IOB = REQUIRE_IOB);
	$XPO_OPEN (IOB = REQUIRE_IOB, FILE_SPEC = .DSC_PTR
	    %IF %BLISS (BLISS32) %THEN , FAILURE = OPEN_ERROR %FI
	    );

	WHILE $XPO_GET (IOB = REQUIRE_IOB) EQL XPO$_NORMAL DO
	    BEGIN
	    
	    SELECTONE .CMDBLK [NDX$H_FORMAT] OF
		SET

		[TMS11_A, TMS11_E]:
		    TMSPUT (.REQUIRE_IOB [IOB$H_STRING], .REQUIRE_IOB [IOB$A_STRING], OUTIOB, FALSE);

		[DSR, TEX]:
		    PUT_LINE (REQUIRE_IOB [IOB$T_STRING]);

		TES;

	    END;

	$XPO_CLOSE (IOB = REQUIRE_IOB);
	END
    ELSE
	IF .CMDBLK [NDX$H_FORMAT] EQL DSR
	THEN
	    BEGIN
	    !
	    ! User didn't specify a require file and output is for RUNOFF.
	    ! Therefore, insert default commands.
	    !
	    PUT_LINE ('.CENTER;INDEX');
	    PUT_LINE ('.BLANK3');
	    END;

    IF .CMDBLK [NDX$H_NONALPHA] NEQ AFTER
    THEN
	!
	! Examine nonalpha bucket first if user specified
	!
	! /SORT=NONALPHA=BEFORE or /SORT=NONALPHA=IGNORE
	!
	EXAM_BUCKET (0);

    !
    ! Examine all alpha buckets
    !
    INCR I FROM 1 TO 26 DO
	EXAM_BUCKET (.I);

    IF .CMDBLK [NDX$H_NONALPHA] EQL AFTER
    THEN
	!
	! Examine nonalpha characters last
	!
	EXAM_BUCKET (0);

    !
    ! Write last page 
    !
    LASTPG ();

    END;			!End of NDXFMT

%SBTTL 'EXAM_BUCKET -- Print contents of a bucket'
ROUTINE EXAM_BUCKET (BKT) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to examine the contents of a bucket.
!
!	It generates a guide heading if one was requested via the
!	/GUIDE_HEADING qualifier.
!
! FORMAL PARAMETERS:
!
!	BKT - bucket number to examine
!
! IMPLICIT INPUTS:
!
!	CMDBLK - command line information block
!
! IMPLICIT OUTPUTS:
!
!	INDLVL  - subindex level is set to zero
!	LSTPTR - current entry pointer is zeroed
!	LINE_TYPE- is set if a guide heading is generated 
!		   and at the end of the bucket
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    LOCAL
	LAST_SUB_BUCKET,
	TEXT_GENERATED;

    TEXT_GENERATED = FALSE;

    IF .BKT EQL 0
    THEN
	!
	! Examining the nonalphabetic bucket (bucket 0).
	!
	! The only sub-bucket used is zero because nonalphabetics do
	! not sort correctly using the 'squared bucket' approach.
	!
	LAST_SUB_BUCKET = 0
    ELSE
	!
	! Not examining the nonalphabetic bucket. Use sub-buckets 0-26.
	!
	LAST_SUB_BUCKET = 26;

    INCR I FROM 0 TO .LAST_SUB_BUCKET DO
	BEGIN
	LSTPTR=0;				! Set starting point for listing at head
	INDLVL=0;				! Set starting indent level

	IF GENTRY (.BKT, .I, FALSE)
	THEN
	    BEGIN
	    !
	    ! Non empty bucket
	    !
	    IF .CMDBLK [NDX$V_GUIDE] AND (NOT .TEXT_GENERATED)
	    THEN
		BEGIN
		!
		! Build guide heading
		!
		LINE_TYPE = GUIDE;

		IF .CMDBLK [NDX$H_FORMAT] EQL DSR
		THEN
		    BEGIN
		    !
		    ! RUNOFF output
		    !
		    BIND
			BUCKET_NAMES = UPLIT (
			    CH$PTR (UPLIT ('   ')),
			    CH$PTR (UPLIT ('-A-')),
			    CH$PTR (UPLIT ('-B-')),
			    CH$PTR (UPLIT ('-C-')),
			    CH$PTR (UPLIT ('-D-')),
			    CH$PTR (UPLIT ('-E-')),
			    CH$PTR (UPLIT ('-F-')),
			    CH$PTR (UPLIT ('-G-')),
			    CH$PTR (UPLIT ('-H-')),
			    CH$PTR (UPLIT ('-I-')),
			    CH$PTR (UPLIT ('-J-')),
			    CH$PTR (UPLIT ('-K-')),
			    CH$PTR (UPLIT ('-L-')),
			    CH$PTR (UPLIT ('-M-')),
			    CH$PTR (UPLIT ('-N-')),
			    CH$PTR (UPLIT ('-O-')),
			    CH$PTR (UPLIT ('-P-')),
			    CH$PTR (UPLIT ('-Q-')),
			    CH$PTR (UPLIT ('-R-')),
			    CH$PTR (UPLIT ('-S-')),
			    CH$PTR (UPLIT ('-T-')),
			    CH$PTR (UPLIT ('-U-')),
			    CH$PTR (UPLIT ('-V-')),
			    CH$PTR (UPLIT ('-W-')),
			    CH$PTR (UPLIT ('-X-')),
			    CH$PTR (UPLIT ('-Y-')),
			    CH$PTR (UPLIT ('-Z-'))
			) : VECTOR;

		    LOCAL
			INDENT;

		    INDENT = .CMDBLK [NDX$G_COLUMN_WID] / 3;	! Number of leading blanks
		    INDENT = ((.INDENT + 1) / 2) * 2;		! Round to next even number

		    INDENT_LINE (.INDENT);
		    FILL_LINE (3, .BUCKET_NAMES [.BKT], .INDENT, .CMDBLK [NDX$G_COLUMN_WID], TRUE, FALSE, FALSE);
		    INS_LINE (.INT_LINE_LENGTH, CH$PTR (RNO_LINE), .EXT_LINE_LENGTH);
		    END
		ELSE
		    BEGIN
		    !
		    ! TMS11 or TEX output
		    !
		    BIND
			BUCKET_NAMES = UPLIT (
			    CH$PTR (UPLIT (' ')),
			    CH$PTR (UPLIT ('A')),
			    CH$PTR (UPLIT ('B')),
			    CH$PTR (UPLIT ('C')),
			    CH$PTR (UPLIT ('D')),
			    CH$PTR (UPLIT ('E')),
			    CH$PTR (UPLIT ('F')),
			    CH$PTR (UPLIT ('G')),
			    CH$PTR (UPLIT ('H')),
			    CH$PTR (UPLIT ('I')),
			    CH$PTR (UPLIT ('J')),
			    CH$PTR (UPLIT ('K')),
			    CH$PTR (UPLIT ('L')),
			    CH$PTR (UPLIT ('M')),
			    CH$PTR (UPLIT ('N')),
			    CH$PTR (UPLIT ('O')),
			    CH$PTR (UPLIT ('P')),
			    CH$PTR (UPLIT ('Q')),
			    CH$PTR (UPLIT ('R')),
			    CH$PTR (UPLIT ('S')),
			    CH$PTR (UPLIT ('T')),
			    CH$PTR (UPLIT ('U')),
			    CH$PTR (UPLIT ('V')),
			    CH$PTR (UPLIT ('W')),
			    CH$PTR (UPLIT ('X')),
			    CH$PTR (UPLIT ('Y')),
			    CH$PTR (UPLIT ('Z'))
			) : VECTOR;

		    INS_LINE (1, .BUCKET_NAMES [.BKT], 1);
		    END;

		LINE_TYPE = GUIDE_FILL;
		INS_LINE (4, .BLANKS, 4);
		END;
	
	    !
	    ! Now process rest of bucket
	    !
	    DO FORMAT_ENTRY () UNTIL NOT GENTRY (.BKT, .I, FALSE);

	    TEXT_GENERATED = TRUE;
	    END;

	END;

    IF .TEXT_GENERATED
    THEN
	BEGIN
	LINE_TYPE = BKT_E;
	INS_LINE (4, .BLANKS, 4);	! Skip a line
	END;

    END;


%SBTTL 'FORMAT_ENTRY -- collect & print index entry'
ROUTINE FORMAT_ENTRY : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Collect and print the entire index line, including
!	name and all line number references.
!
!	No line is generated if doing a master index and the
!	subindex level is greater than the deepest level
!	allowed in the master index.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	LSTPTR		- address of list item for index entry
!	INDLVL		- subindex level
!	LSTSTK		- subindex list stack
!	LINE_TYPE	- current line type
!	CMDBLK		- command line information block
!	CHRSIZ		- TMS character size vector
!
! IMPLICIT OUTPUTS:
!
!	LINE_TYPE	- current line type
!	LINE_POINTER	- pointer to next character position in output line
!	EXT_LINE_LENGTH - external line length
!	INT_LINE_LENGTH	- internal line length
!	TMS_LINE_LENGTH - length of line in TMS relative units
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	INDENT,
	STR_VEC : REF VECTOR,
	CHAR_COUNT,
	TEXT_PTR;

    IF .INDLVL GTR .CMDBLK [NDX$H_LEVEL] THEN RETURN;

    !
    ! Get pointer to text and length of text
    !
    STR_VEC = .LSTPTR [XE$A_TEXT];
    CHAR_COUNT = .STR_VEC [0];				! Length is 1st fullword of string
    TEXT_PTR = CH$PTR (STR_VEC [1]);

    IF .LINE_TYPE NEQ CONT_HEAD THEN LINE_TYPE = (IF .INDLVL EQL 0 THEN ENTRY_B ELSE SUB_B);

    !
    ! Indent the new line
    !
    INDENT = 2 * .INDLVL;
    INDENT_LINE (.INDENT);

    !
    ! Now format the entry
    !
    FILL_LINE (.CHAR_COUNT, .TEXT_PTR, .INDENT, .CMDBLK [NDX$G_COLUMN_WID], FALSE, FALSE, FALSE);
    
    IF .LINE_TYPE EQL CONT_HEAD
    THEN
	BEGIN
	!
	! Doing a continuation heading
	!
	IF (.LSTSTK [.INDLVL + 1] EQL 0)
	OR (.INDLVL EQL .CMDBLK [NDX$H_LEVEL])
	THEN
	    !
	    ! Append ' (Cont.)' to line
	    !
	    FILL_LINE (7, CH$PTR (UPLIT ('(Cont.)')), .INDENT, .CMDBLK [NDX$G_COLUMN_WID], FALSE, FALSE, TRUE)
	END
    ELSE
	BEGIN
	!
	! Doing a normal entry
	!
	IF .LSTPTR [XE$A_REF] NEQ 0
	THEN
	    BEGIN
	    !
	    ! Have page references.
	    !
	    IF .CMDBLK [NDX$V_PAGES]			! Generating page references
	    OR .CMDBLK [NDX$V_MASTER]			! or master index
	    THEN
		BEGIN
		!
		! Insert a null following the entry so that we can detect the
		! start of the page references for building telltale headings
		! or continuation headings on the last page.
		!
		CH$WCHAR_A (0, LINE_POINTER);
		EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
		INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;

		TMS_LINE_LENGTH = .TMS_LINE_LENGTH 
		    + (IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE THEN .CHRSIZ [%C' '] ELSE .CHRSIZ [%C',']);

		INS_PAGE_NO (.LSTPTR [XE$A_REF]); ! Insert page numbers
		END;
	    END
	ELSE
	    BEGIN
	    !
	    ! No page references
	    !
	    IF  .CMDBLK [NDX$V_MASTER]
	    AND (.INDLVL EQL .CMDBLK [NDX$H_LEVEL])
	    AND (.LSTPTR [XE$A_SUBX] NEQ 0)
	    THEN
		BEGIN
		!
		! Doing master indexing, at deepest level specified,
		! and not at the bottom of a .Y - generate book references
		!
		LOCAL
		    M_INDENT,
		    M_EXT,
		    NEW_LINE,
		    XMPTR : REF $XM_BLOCK;

		NEW_LINE = FALSE;
		XMPTR = .LSTPTR [XE$A_BOOK_LIST];

		IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE
		THEN
		    BEGIN
		    !
		    ! Set indent and maximum external length for separate format
		    !
		    M_INDENT = .CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID];
		    M_EXT = .PAGE_WIDTH;
		    END
		ELSE
		    BEGIN
		    !
		    ! Set indent and maximum external length for other formats.
		    !
		    M_INDENT = .INDENT;
		    M_EXT = .CMDBLK [NDX$G_COLUMN_WID];
		    END;

		!
		! Insert a null following the entry so that we can detect the
		! start of the page references for building telltale headings
		! or continuation headings on the last page.
		!
		CH$WCHAR_A (0, LINE_POINTER);
		EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
		INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;

		TMS_LINE_LENGTH = .TMS_LINE_LENGTH 
		    + (IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE THEN .CHRSIZ [%C' '] ELSE .CHRSIZ [%C',']);

		WHILE .XMPTR NEQ 0 DO
		    BEGIN
		    BOOK_REF (.XMPTR [XM$A_BOOK], .M_INDENT, .M_EXT, .NEW_LINE, FALSE);
		    IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE THEN NEW_LINE = TRUE;

		    IF .XMPTR [XM$A_LINK] NEQ 0
		    THEN
			XMPTR = .XMPTR [XM$A_LINK]
		    ELSE
			XMPTR = 0;
		    END;
		END;
	    END;
	END;

    IF .LINE_TYPE NEQ CONT_HEAD THEN LINE_TYPE = (IF .INDLVL EQL 0 THEN ENTRY_E ELSE SUB_E);

    INS_LINE (.INT_LINE_LENGTH, CH$PTR (RNO_LINE), .EXT_LINE_LENGTH);

    END;			!End of FORMAT_ENTRY

%SBTTL 'INS_PAGE_NO -- generate page # list'
ROUTINE INS_PAGE_NO (LIST_HEAD) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Generate the page number list for the index item
!
! FORMAL PARAMETERS:
!
!	LIST_HEAD - address of page number list
!
! IMPLICIT INPUTS:
!
!	CMDBLK		- command line information block
!	INDLVL		- subindex level
!	LSTSTK		- subindex list stack
!	PAGE_WIDTH	- size of output page
!	CHRSIZ		- TMS character size vector
!
! IMPLICIT OUTPUTS:
!
!	LINE_POINTER	- pointer to next position in output line
!	EXT_LINE_LENGTH	- external line length
!	INT_LINE_LENGTH	- internal line length
!	TMS_LINE_LENGTH	- TMS line length in relative units
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	INDENT,
	MAX_EXT_LENGTH,
	REF_GENERATED,
	MORE,
	NEW_LINE,
	CUR_BOOK,
	XXPTR : REF $XX_BLOCK;

    XXPTR = .LIST_HEAD;

    NEW_LINE = FALSE;
    CUR_BOOK = 0;

    IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE
    THEN
	BEGIN
	!
	! Doing an index with separate references
	!
	INDENT = .CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID];
	MAX_EXT_LENGTH = .PAGE_WIDTH;
	END
    ELSE
	BEGIN
	INDENT = 2 * .INDLVL;
	MAX_EXT_LENGTH = .CMDBLK [NDX$G_COLUMN_WID];
	END;

    DO
	BEGIN
	!
	! Process all page references
	!
	REF_GENERATED = FALSE;

	IF .CUR_BOOK NEQ .XXPTR [XX$A_BOOK]
	THEN
	    BEGIN
	    !
	    ! Have encountered a new book name
	    !
	    ! NOTE: If you want to insert a comma after the book reference,
	    ! use .CMDBLK [NDX$V_PAGES] as the last argument to BOOK_REF
	    !
	    CUR_BOOK = .XXPTR [XX$A_BOOK];
	    BOOK_REF (.CUR_BOOK, .INDENT, .MAX_EXT_LENGTH, .NEW_LINE, FALSE);

	    IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE THEN NEW_LINE = TRUE;
	    REF_GENERATED = TRUE;
	    END;

	IF .CMDBLK [NDX$V_PAGES]
	THEN
	    BEGIN
	    !
	    ! Doing page references. Generate one.
	    !
	    SELECTONE TRUE OF
	    SET

	    [.XXPTR [XX$V_END]]:
		!
		! END of page range.
		! These are picked up by BEGIN's so no processing is required
		!
		;

	    [.XXPTR [XX$V_BEGIN]]:
		BEGIN
		!
		! BEGIN page range.
		!
		LOCAL
		    SKIPPED_ENTRIES,
		    XXEND : REF $XX_BLOCK;

		SKIPPED_ENTRIES = 0;
		PAGE_REF (.XXPTR, .INDENT, .MAX_EXT_LENGTH);	! Write initial page
		REF_GENERATED = TRUE;

		!
		! Find end of range and output
		!
		XXEND = .XXPTR;
		WHILE TRUE DO
		    BEGIN

		    IF .XXEND [XX$A_LINK] EQL 0
		    THEN
			BEGIN
			!
			! No corresponding END.
			! Issue error message and exit loop.
			!
%IF %BLISS (BLISS32)
%THEN							! Signal errors in BLISS32

			SIGNAL (INDEX$_NOEND);

%ELSE							! Use $XPO_PUT_MSG otherwise

			$XPO_PUT_MSG (SEVERITY = WARNING,
			    STRING = '.XPLUS (BEGIN) has no corresponding .XPLUS (END)');

%FI

			ENTMSG ();

			EXITLOOP;
			END;

		    !
		    ! Point to next entry
		    !
		    XXEND = .XXEND [XX$A_LINK];

		    IF .XXEND [XX$V_END]
		    AND (.XXEND [XX$A_BOOK] EQL .XXPTR [XX$A_BOOK])
		    THEN
			BEGIN
			!
			! Entry is an end range entry and the book identifiers
			! are the same; found the corresponding END
			!
			! If BEGIN and END are on same page and have identical
			! display attributes, then don't generate a range.
			!
			XXPTR [XX$V_BEGIN] = FALSE;
			XXEND [XX$V_END] = FALSE;

			IF NOT SAMEPG (.XXPTR, .XXEND)
			THEN
			    BEGIN
			    !
			    ! Not same page or display attributes not identical.
			    ! Generate page reference.
			    !
			    ! Append ' to '
			    !
			    FILL_LINE (2, CH$PTR (UPLIT ('to')), .INDENT, 
				.MAX_EXT_LENGTH, FALSE, FALSE, TRUE);

			    !
			    ! Insert end of range number
			    !
			    PAGE_REF (.XXEND, .INDENT, .MAX_EXT_LENGTH);
			    END;

			!
			! Reset BEGIN and END attributes.
			!
			XXPTR [XX$V_BEGIN] = TRUE;
			XXEND [XX$V_END] = TRUE;

			EXITLOOP;			! Exit loop
			END
		    ELSE
			SKIPPED_ENTRIES = .SKIPPED_ENTRIES + 1;
		    END;

		IF .SKIPPED_ENTRIES NEQ 0
		THEN
		    BEGIN
		    !
		    ! There were entries inside a page range that were skipped.
		    ! Tell the user about it
		    !
%IF %BLISS (BLISS32)
%THEN						! Signal errors in BLISS32

		    SIGNAL (INDEX$_SKIPPED, 1, .SKIPPED_ENTRIES);

%ELSE						! Use $XPO_PUT_MSG otherwise

		    $XPO_PUT_MSG (SEVERITY = WARNING,
			STRING = $STR_CONCAT ($STR_ASCII (.SKIPPED_ENTRIES),
			    ' reference(s) inside page range - ignored'));

%FI

		    ENTMSG ();			! Dump the entry too.
		    END;

		!
		! NOTE: to avoid skipping entries inside a page range, remove
		! the following line.
		!
		XXPTR = .XXEND;
		END;

	    [OTHERWISE]:
		BEGIN
		!
		! Normal page ref
		!
		LOCAL
		    XXPEEK : REF $XX_BLOCK;

		PAGE_REF (.XXPTR, .INDENT, .MAX_EXT_LENGTH); ! Insert reference into line
		REF_GENERATED = TRUE;

		XXPEEK = .XXPTR [XX$A_LINK];	! Point to next entry
		WHILE .XXPEEK NEQ 0 DO
		    BEGIN
		    !
		    ! Check for duplicate references
		    !
		    IF SAMEPG (.XXPTR, .XXPEEK)
		    THEN
			!
			! Duplicate reference - skip it
			!
			XXPTR = .XXPEEK
		    ELSE
			!
			! Not same, terminate scan
			!
			EXITLOOP;

		    XXPEEK = .XXPEEK [XX$A_LINK];
		    END;

		IF .CMDBLK [NDX$V_PAGE_MERGE]
		THEN
		    BEGIN
		    !
		    ! User selected old style page merging
		    ! (adjacent pages form a page range)
		    !
		    LOCAL
			RANGE_SEEN;

		    RANGE_SEEN = FALSE;
		    XXPEEK = .XXPTR [XX$A_LINK];
		    WHILE .XXPEEK NEQ 0 DO
			BEGIN

			IF  PAGMRG (XTNPAG (.XXPTR [XX$H_PAGE]), XTNPAG (.XXPEEK [XX$H_PAGE]))
			AND SAME_ATTR (.XXPTR, .XXPEEK)
			THEN
			    BEGIN
			    !
			    ! Found some adjacent pages with same display attributes
			    !
			    RANGE_SEEN = TRUE;
			    XXPTR = .XXPEEK;
			    END
			ELSE
			    EXITLOOP;

			XXPEEK = .XXPEEK [XX$A_LINK];
			END;

		    IF .RANGE_SEEN
		    THEN
			BEGIN
			!
			! We found a page range - write it out
			!
			FILL_LINE (2, CH$PTR (UPLIT ('to')), .INDENT, .MAX_EXT_LENGTH, FALSE, FALSE, TRUE);
			PAGE_REF (.XXPTR, .INDENT, .MAX_EXT_LENGTH);
			END;
		    END;
		END;

	    TES;
	    END;

	!
	! Check for more to do
	!
	MORE = FALSE;

	XXPTR = .XXPTR [XX$A_LINK];
	WHILE .XXPTR NEQ 0 DO
	    BEGIN

	    IF NOT .XXPTR [XX$V_END]
	    THEN
		BEGIN
		!
		! Not a END range
		!
		MORE = TRUE;
		EXITLOOP;
		END;

	    XXPTR = .XXPTR [XX$A_LINK];
	    END;

	IF .MORE 					! More to do
	AND .CMDBLK [NDX$V_PAGES]			! Generating page references
	AND .REF_GENERATED				! Generated a reference
	AND (
	    (.CMDBLK [NDX$H_LAYOUT] NEQ SEPARATE)	! Not an index with separate references
	    OR (.CUR_BOOK EQL .XXPTR [XX$A_BOOK])	! or next book is the same as the current one
	    )
	THEN
	    BEGIN
	    !
	    ! Append a comma
	    !
	    CH$WCHAR_A (%C',', LINE_POINTER);
	    INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;
	    EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
	    TMS_LINE_LENGTH = .TMS_LINE_LENGTH + .CHRSIZ [%C','];
	    END;

	END

    WHILE .MORE;		! Loop if more to do

    END;			!End of INS_PAGE_NO

%SBTTL 'BOOK_REF -- Generate a book reference for master index'
ROUTINE BOOK_REF (BOOK, INDENT, MAX_EXT, NEW_LINE, COMMA) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine inserts a book reference into RNO_LINE
!
! FORMAL PARAMETERS:
!
!	BOOK	- Address of book name string
!	INDENT	- Number of blanks to indent a new line
!	MAX_EXT	- Maximum external line length
!	NEW_LINE- Put book reference on a new line
!	COMMA	- Append a comma to the book name
!
! IMPLICIT INPUTS:
!
!	LINE_POINTER	- Pointer to RNO_LINE
!	EXT_LINE_LENGTH - External line length
!	INT_LINE_LENGTH - Internal line length
!	INDLVL		- Current index level
!	CMDBLK		- Command line information block
!	PAGE_WIDTH	- Output page width
!	TMSSTD		- Standard character size for TMS
!
! IMPLICIT OUTPUTS:
!
!	LINE_POINTER	- pointer to next position in output line
!	EXT_LINE_LENGTH	- external line length
!	INT_LINE_LENGTH - internal line length
!	TMS_LINE_LENGTH	- length of line in TMS relative units
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    LOCAL
	LEADING_BLANK,
	STR_VEC : REF VECTOR,
	PTR,
	LEN;

    LEADING_BLANK = TRUE;

    IF .NEW_LINE
    THEN
	BEGIN
	!
	! Flush current line before inserting reference
	!
	INS_LINE (.INT_LINE_LENGTH, CH$PTR (RNO_LINE), .EXT_LINE_LENGTH);
	LINE_TYPE = (IF .INDLVL EQL 0 THEN ENTRY_W ELSE SUB_W);

	INDENT_LINE (.INDENT);

	LEADING_BLANK = FALSE;
	END
    ELSE
	IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE
	THEN
	    BEGIN
	    !
	    ! Separate layout. Pad line to appropriate length.
	    ! NOTE: Separate layout is not allowed for TEX format.
	    !
	    LEN = .CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID] - .EXT_LINE_LENGTH;

	    IF .LEN GTR 0
	    THEN
		BEGIN
		!
		! NOTE: if LEN LEQ 0 then line was already padded or overflowed.
		! In any case we don't pad it cause we'll blow up with the 
		! negative count.
		!
		EXT_LINE_LENGTH = .EXT_LINE_LENGTH + .LEN;

		IF (.CMDBLK [NDX$H_FORMAT] EQL TMS11_A)
		OR (.CMDBLK [NDX$H_FORMAT] EQL TMS11_E)
		THEN
		    BEGIN
		    !
		    ! TMS11 output (line is padded with a tabs)
		    !
		    CH$WCHAR_A (TAB, LINE_POINTER);
		    CH$WCHAR_A (TAB, LINE_POINTER);
		    INT_LINE_LENGTH = .INT_LINE_LENGTH + 2;
		    TMS_LINE_LENGTH = (.CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID]) * TMSSTD;
		    END
		ELSE
		    BEGIN
		    !
		    ! RUNOFF output (pad line with spaces)
		    !
		    INT_LINE_LENGTH = .INT_LINE_LENGTH + .LEN;
		    CH$FILL (%C' ', .LEN, .LINE_POINTER);
		    LINE_POINTER = CH$PLUS (.LINE_POINTER, .LEN);
		    END;
		END;

	    LEADING_BLANK = FALSE;
	    END;

    !
    ! Get pointer to book and length of book name
    !
    STR_VEC = .BOOK;
    LEN = .STR_VEC [0];
    PTR = CH$PTR (STR_VEC [1]);

    !
    ! Insert book name into line
    !
    FILL_LINE (.LEN, .PTR, .INDENT, .MAX_EXT, FALSE, TRUE, .LEADING_BLANK);

    !
    ! Append comma to end of reference if necessary
    !
    IF .COMMA 
    THEN 
	BEGIN
	CH$WCHAR_A (%C',', LINE_POINTER);
	INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;
	EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
	TMS_LINE_LENGTH = .TMS_LINE_LENGTH + .CHRSIZ [%C','];
	END;

    END;

%SBTTL 'PAGE_REF -- Format a page reference'
ROUTINE PAGE_REF (XX_ENTRY, INDENT, MAX_EXT) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine formats a page reference and inserts it into RNO_WORD
!
! FORMAL PARAMETERS:
!
!	XX_ENTRY - Pointer to reference to be formatted
!	INDENT	 - Number of blanks to indent new line if reference doesn't fit
!	MAX_EXT	 - Maximum external length of line before wrapping
!
! IMPLICIT INPUTS:
!
!	CMDBLK	- Command line information block
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    MAP
	XX_ENTRY : REF $XX_BLOCK;

    LOCAL
	REFBUF   : VECTOR [CH$ALLOCATION (100)],
	PTR,
	LEN,
	PAGE : REF PAGE_DEFINITION;

    PAGE = XTNPAG (.XX_ENTRY [XX$H_PAGE]);

    PTR = CH$PTR (REFBUF);

    IF .CMDBLK [NDX$V_STANDARD_PAGE]
    THEN
	!
	! User wants traditional page numbers
	!
	LEN = PACPAG (.PAGE, PTR)
    ELSE
	!
	! User wants running pages
	!
	LEN = PACBAS (.PAGE [SCT_RUN_PAGE], PTR, 10);

    IF .XX_ENTRY [XX$A_APPEND] NEQ 0
    THEN
	BEGIN
	!
	! Have appended text
	!
	LOCAL
	    A_VEC : REF VECTOR,
	    A_PTR,
	    A_LEN;

	A_VEC = .XX_ENTRY [XX$A_APPEND];
	A_LEN = .A_VEC [0];
	A_PTR = CH$PTR (A_VEC [1]);

	CH$MOVE (.A_LEN, .A_PTR, .PTR);
	LEN = .LEN + .A_LEN;
	END;

    !
    ! Insert reference into line
    !
    FILL_LINE (.LEN, CH$PTR (REFBUF), .INDENT, .MAX_EXT, .XX_ENTRY [XX$V_BOLD], .XX_ENTRY [XX$V_UNDERLINE], TRUE);

    END;

%SBTTL 'SAMEPG -- Compare page references'
ROUTINE SAMEPG (X1, X2) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine compares two page references to see if they are equal.
!
! FORMAL PARAMETERS:
!
!	X1 - Pointer to first page reference
!	X2 - Pointer to second page reference
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns TRUE if references are equal, FALSE otherwise
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    MAP
	X1 : REF $XX_BLOCK,
	X2 : REF $XX_BLOCK;

    IF PAGEQL (XTNPAG (.X1 [XX$H_PAGE]), XTNPAG (.X2 [XX$H_PAGE]), TRUE)
    THEN
	!
	! Pages are identical in the RUNOFF sense.
	! Compare reference attributes
	!
	RETURN SAME_ATTR (.X1, .X2)
    ELSE
	!
	! Pages not equal in RUNOFF sense
	!
	RETURN FALSE;

    END;

%SBTTL 'SAME_ATTR - Check page references for same attributes'
ROUTINE SAME_ATTR (X1, X2)  =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine compares the display attributes of two page references
!
! FORMAL PARAMETERS:
!
!	X1	- Pointer to first page reference
!	X2	- Pointer to second page reference
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE if references have the same display attributes, FALSE otherwise
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    MAP
	X1 : REF $XX_BLOCK,
	X2 : REF $XX_BLOCK;

    SELECTONE TRUE OF
    SET

    [(.X1 [XX$A_APPEND] NEQ 0) AND (.X2 [XX$A_APPEND] NEQ 0)]:
	BEGIN
	!
	! Both have appended text. Compare strings
	!
	LOCAL
	    STR_VEC : REF VECTOR,
	    L1,
	    P1,
	    L2,
	    P2;

	STR_VEC = .X1 [XX$A_APPEND];
	L1 = .STR_VEC [0];
	P1 = CH$PTR (STR_VEC [1]);

	STR_VEC = .X2 [XX$A_APPEND];
	L2 = .STR_VEC [0];
	P2 = CH$PTR (STR_VEC [1]);

	IF CH$NEQ (.L1, .P1, .L2, .P2) THEN RETURN FALSE;
	END;

    [(.X1 [XX$A_APPEND] EQL 0) AND (.X2 [XX$A_APPEND] EQL 0)]:
	!
	! Neither have appended strings. Do nothing.
	!
	;

    [OTHERWISE]:
	!
	! One has appended text and the other doesn't.
	! References are not identical
	!
	RETURN FALSE;

    TES;

    RETURN (
	    (.X1 [XX$V_BOLD]      EQL .X2 [XX$V_BOLD])
	AND (.X1 [XX$V_UNDERLINE] EQL .X2 [XX$V_UNDERLINE])
	AND (.X1 [XX$V_BEGIN]     EQL .X2 [XX$V_BEGIN])
	AND (.X1 [XX$V_END]       EQL .X2 [XX$V_END])
	AND (.X1 [XX$A_BOOK]      EQL .X2 [XX$A_BOOK])
	);

    END;

%SBTTL 'INS_LINE -- Insert line into page'
ROUTINE INS_LINE (INT_LEN, PTR, EXT_LEN) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine inserts a line into the print page
!
! FORMAL PARAMETERS:
!
!	INT_LEN		- Internal line length
!	PTR		- CH$PTR to text
!	EXT_LEN		- External line length
!
! IMPLICIT INPUTS:
!
!	ALLOWD		- Maximum number of lines allowed on page
!	LCOUNT		- Left column line count
!	RCOUNT		- Right column line count
!	CMDBLK		- Command line information block
!	DOING_LAST	- TRUE if LAST_LINE was called to process the last
!			  line in the column
!
! IMPLICIT OUTPUTS:
!
!	LCOUNT		- Incremented if line inserted into left column
!	LLINES		- If line inserted into left column
!	LTYPE		- Type of line if inserted into left column
!
!	RCOUNT		- Incremented if line inserted into right column
!	RLINES		- If line inserted into right column
!	RTYPE		- Type of line if inserted into right column
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    
    SELECTONE .CMDBLK [NDX$H_LAYOUT] OF
	SET

	[TWO_COLUMN]:
	    !
	    ! Two column output
	    !
	    IF .LCOUNT EQL .ALLOWD
	    THEN
		BEGIN
		!
		! Filling right column
		!
		IF (.RCOUNT EQL 0) 
		THEN
		    BEGIN
		    !
		    ! First line in column
		    !
		    IF CH$EQL (1, .BLANKS, .INT_LEN, .PTR, %C' ') THEN RETURN;

		    IF .CMDBLK [NDX$V_CONTINUATION]
		    THEN
			BEGIN
			!
			! Generate continuation heading
			!
			DO_CONTINUE (.INT_LEN, .PTR, .EXT_LEN);
			RETURN;
			END;
		    END;

		IF (.RCOUNT EQL .ALLOWD - 1) AND NOT .DOING_LAST
		THEN
		    !
		    ! Insert last line in column
		    !
		    LAST_LINE (.INT_LEN, .PTR, .EXT_LEN)
		ELSE
		    BEGIN
		    !
		    ! Insert normal line
		    !
		    RCOUNT = .RCOUNT + 1;
		    RTYPE [.RCOUNT] = .LINE_TYPE;
		    PADLIN (.INT_LEN, .PTR, .EXT_LEN, RLINES [.RCOUNT, 0,0,0,0]);
		    SAVE_TELLTALE_HEADING (RLINES [0, 0,0,0,0], RTYPE [0], .RCOUNT);

		    IF .RCOUNT EQL .ALLOWD THEN PUTPAG (FALSE);
		    END;
		END
	    ELSE
		BEGIN
		!
		! Left column
		!
		IF (.LCOUNT EQL 0) 
		THEN
		    BEGIN
		    !
		    ! First line in left column
		    !
		    IF CH$EQL (1, .BLANKS, .INT_LEN, .PTR, %C' ') THEN RETURN;

		    IF .CMDBLK [NDX$V_CONTINUATION]
		    THEN
			BEGIN
			!
			! Generate continuation heading
			!
			DO_CONTINUE (.INT_LEN, .PTR, .EXT_LEN);
			RETURN;
			END;
		    END;

		IF (.LCOUNT EQL .ALLOWD - 1) AND NOT .DOING_LAST
		THEN
		    !
		    ! Insert last line in left column
		    !
		    LAST_LINE (.INT_LEN, .PTR, .EXT_LEN)
		ELSE
		    BEGIN
		    !
		    ! Insert a normal line
		    !
		    LCOUNT = .LCOUNT + 1;
		    LTYPE [.LCOUNT] = .LINE_TYPE;
		    PADLIN (.INT_LEN, .PTR, .EXT_LEN, LLINES [.LCOUNT, 0,0,0,0]);
		    SAVE_TELLTALE_HEADING (LLINES [0, 0,0,0,0], LTYPE [0], .LCOUNT);
		    END;

		END;

	[OTHERWISE]:
	    BEGIN
	    !
	    ! One column output
	    !

	    IF (.LCOUNT EQL 0) 
	    THEN
		BEGIN
		!
		! First line in column
		!
		IF CH$EQL (1, .BLANKS, .INT_LEN, .PTR, %C' ') THEN RETURN;

		IF .CMDBLK [NDX$V_CONTINUATION]
		THEN
		    BEGIN
		    !
		    ! Generate continuation heading
		    !
		    DO_CONTINUE (.INT_LEN, .PTR, .EXT_LEN);
		    RETURN;
		    END;
		END;

	    IF (.LCOUNT EQL .ALLOWD - 1) AND NOT .DOING_LAST
	    THEN
		!
		! Insert last line in column
		!
		LAST_LINE (.INT_LEN, .PTR, .EXT_LEN)
	    ELSE
		BEGIN
		!
		! Insert a normal line
		!
		LCOUNT = .LCOUNT + 1;
		LTYPE [.LCOUNT] = .LINE_TYPE;
		PADLIN (.INT_LEN, .PTR, .EXT_LEN, LLINES [.LCOUNT, 0,0,0,0]);
		SAVE_TELLTALE_HEADING (LLINES [0, 0,0,0,0], LTYPE [0], .LCOUNT);

		IF .LCOUNT EQL .ALLOWD THEN PUTPAG (FALSE);
		END;
	    END;

	TES;
    END;

%SBTTL 'SAVE_TELLTALE_HEADING -- Save telltale heading string'
ROUTINE SAVE_TELLTALE_HEADING (
    LINES : REF BLOCKVECTOR [, STR$K_D_BLN],
    TYPES : REF VECTOR,
    L_NUM
    ) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by INS_LINE to save the current line as a 
!	possible telltale heading.
!
!	The line is saved only if it is the first line of a continuation
!	heading, the first line of a multi-line top level entry or a 
!	top-level entry which is only one line long.
!
!	If the line is saved, it is always saved as the right telltale string
!	which represents the last top level entry on the page.
!
!	The line is also saved as the left telltale if the right telltale 
!	string is null which occurs after a right side page has been generated
!	and if the line is the first on the page.
!
! FORMAL PARAMETERS:
!
!	LINES		- Pointer to the blockvector of string descriptors
!			  for the current column.
!	TYPES		- Pointer to the vector of line types for the 
!			  current column.
!	L_NUM		- Number of the line being generated.
!
! IMPLICIT INPUTS:
!
!	RLINES [0, ...]	- The right telltale string
!
! IMPLICIT OUTPUTS:
!
!	RLINES [0, ...]	- The right telltale string is replaced if the line
!			  is saved.
!	RTYPES [0]	- The right telltale line type is replaced if the
!			  line is saved.
!	LLINES [0, ...]	- The left telltale string is replaced if a right hand
!			  page was just generated.
!	LTYPES [0, ...]	- The left telltale line type is replaced if the
!			  line is saved as a left telltale.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--

    BEGIN

    LOCAL
	LINE_NUMBER,
	SAVE_LINE;

    LINE_NUMBER = .L_NUM;
    SAVE_LINE = FALSE;

    SELECTONE .TYPES [.LINE_NUMBER] OF
	SET

	[CONT_HEAD]:
	    BEGIN
	    !
	    ! A continuation heading.
	    !
	    IF .LINE_NUMBER EQL 1
	    THEN
		BEGIN
		!
		! Only save the first line in a continuation heading
		!
		SAVE_LINE = TRUE;
		END;

	    END;

	[GUIDE]:
	    BEGIN
	    !
	    ! A guide heading.
	    !
	    BIND
		RHEAD = RLINES [0, 0,0,0,0] : $STR_DESCRIPTOR ();

	    IF  (.LINE_NUMBER EQL 1)
	    AND (.RHEAD [STR$H_LENGTH] EQL 0)
	    THEN
		BEGIN
		!
		! This guide heading is the first line on a left hand page.
		! Set flag which indicates that the first top-level entry
		! on the page should be saved as the left telltale.
		!
		SAVE_ENTRY = TRUE;
		END;

	    END;

	[ENTRY_E]:
	    BEGIN
	    !
	    ! The last line in a top level entry.
	    !
	    DECR I FROM .LINE_NUMBER - 1 TO 1 DO
		BEGIN
		!
		! Find the first line in the entry.
		!
		SELECTONE .TYPES [.I] OF
		    SET

		    [ENTRY_B]:
			BEGIN
			!
			! Found the first line in a multi-line entry.
			! Save its line number and exit the loop.
			!
			LINE_NUMBER = .I;
			EXITLOOP;
			END;

		    [ENTRY_W]:
			!
			! Intermediate line of a multi-line entry.
			! Continue search by doing nothing.
			!
			;

		    [OTHERWISE]:
			!
			! Entry was not a multi-line entry. Exit the loop.
			!
			EXITLOOP;

		    TES;

		END;

	    SAVE_LINE = TRUE;
	    END;

	[OTHERWISE]:
	    !
	    ! Line should not be saved as a candidate for a telltale heading.
	    !
	    ;

	TES;

    IF .SAVE_LINE
    THEN
	BEGIN
	!
	! We found a line which could be used as a telltale head.
	!
	BIND
	    RHEAD = RLINES [0, 0,0,0,0] : $STR_DESCRIPTOR ();

	IF  (.RHEAD [STR$H_LENGTH] EQL 0)
	AND (
	    (.LINE_NUMBER EQL 1) OR .SAVE_ENTRY
	    )
	THEN
	    BEGIN
	    !
	    ! The right telltale is null only after a right hand page has been 
	    ! generated. In this case, the line should be saved as the left
	    ! telltale only if this is the first line on the page or if the
	    ! first line on the page was a guide heading.
	    !
	    SAVE_ENTRY = FALSE;

	    $STR_COPY (STRING = LINES [.LINE_NUMBER, 0,0,0,0], 
		TARGET = LLINES [0, 0,0,0,0]);

	    LTYPE [0] = .TYPES [.LINE_NUMBER];
	    END;

	!
	! Save the line as the right telltale.
	!
	$STR_COPY (STRING = LINES [.LINE_NUMBER, 0,0,0,0], 
	    TARGET = RLINES [0, 0,0,0,0]);

	RTYPE [0] = .TYPES [.LINE_NUMBER];
	END;

    END;

%SBTTL 'LAST_LINE -- Process last line in column'
ROUTINE LAST_LINE (I_LEN, PTR, E_LEN) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes the last line in the column.
!
!	If the current line is the beginning or middle of a subindex entry,
!	any preceeding lines which are also part of that subindex entry
!	will be moved to the next column. If the line preceeding the subindex
!	entry is the end of a top level entry, the top level entry will also
!	be moved. If the line preceeding the top level entry is part of a 
!	guide head, the guide head will also be moved.
!
!	If the line is part of a top level entry, the entry will be moved if
!	either it is not the last line in the entry or if the entry has 
!	subindex entries. If the entry is to be moved and the line preceeding
!	the heading is part of a guide heading, the guide heading is also moved.
!
!	If the line is part of a guide heading, the guide heading is moved
!	to the next column.
!
!	Lines are moved from the current column to the next by determining
!	the number of lines to be moved and by establishing a pointer to
!	the first line to be moved. The lines are then copied to the temporary
!	column TLINES and the rest of the current column are filled with
!	blank FILL lines. The copied lines are then inserted into the next
!	output column.
!
! FORMAL PARAMETERS:
!
!	I_LEN	- Internal line length
!	PTR	- CH$PTR to line
!	E_LEN	- External length
!
! IMPLICIT INPUTS:
!
!	ALLOWD		- number of lines allowed in column
!	RTYPE		- line types if doing right column
!	RLINES		- right column lines if doing right column
!	RCOUNT		- number of lines in column if doing right column
!	LTYPE		- line types if doing left column
!	LLINES		- left column lines if doing left column
!	LCOUNT		- number of lines in left column
!	LINE_TYPE	- type of current line
!	CMDBLK		- command line information block
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	During the execution of this routine, DOING_LAST is set to TRUE
!	to prevent INS_LINE from calling this routine again which would
!	cause an infinite loop of calls.
!
!	TLINES AND TTYPE are used during the execution of this routine.
!	Any other routine which may be called during the execution of
!	this routine must use some other area to store lines and line types.
!--
    BEGIN

    LOCAL
	TYPE,
	COUNT_PTR,
	TYPE_PTR	: REF VECTOR,
	LINES_PTR	: REF BLOCKVECTOR [, STR$K_D_BLN],
	COPY_LINES,
	FILL_LINES,
	S		: REF $STR_DESCRIPTOR ();

    DOING_LAST = TRUE;				! Tell INS_LINE we're processing last line

    COPY_LINES = 0;				! Number of lines to copy to next column
    FILL_LINES = 0;				! Number of fill lines to insert in this column
    TYPE = .LINE_TYPE;				! Save current line type

    IF .LCOUNT EQL .ALLOWD
    THEN
	BEGIN					! Filling right column
	COUNT_PTR = RCOUNT;			! Set up pointers to column variables
	TYPE_PTR = RTYPE [0];
	LINES_PTR = RLINES [0, 0,0,0,0];
	END
    ELSE
	BEGIN					! Filling left column
	COUNT_PTR = LCOUNT;			! Set up pointers...
	TYPE_PTR = LTYPE [0];
	LINES_PTR = LLINES [0, 0,0,0,0];
	END;

    CASE .TYPE FROM BKT_E TO CONT_HEAD OF
    SET

    [SUB_B, SUB_W]:
	BEGIN
	!
	! Beginning or middle of subindex entry
	!
	DECR I FROM ..COUNT_PTR TO 1 DO
	    IF (.TYPE_PTR [.I] NEQ SUB_W) AND (.TYPE_PTR [.I] NEQ SUB_B)
	    THEN
		EXITLOOP
	    ELSE
		BEGIN
		COPY_LINES = .COPY_LINES + 1;	! Copy this line to next column
		.COUNT_PTR = ..COUNT_PTR - 1;	! One less line in column
		END;

	IF (.TYPE_PTR [..COUNT_PTR] EQL ENTRY_E)
	AND .CMDBLK [NDX$V_CONTINUATION]
	THEN
	    BEGIN
	    !
	    ! Previous line is the end of an entry and we are
	    ! doing continuation headings. Move the entry too.
	    !
	    COPY_LINES = .COPY_LINES + 1;	! Copy this line to next column
	    .COUNT_PTR = ..COUNT_PTR - 1;	! One less line in column

	    DECR I FROM ..COUNT_PTR TO 1 DO
		IF (.TYPE_PTR [.I] NEQ ENTRY_W) AND (.TYPE_PTR [.I] NEQ ENTRY_B)
		THEN
		    EXITLOOP
		ELSE
		    BEGIN
		    COPY_LINES = .COPY_LINES + 1;
		    .COUNT_PTR = ..COUNT_PTR - 1;
		    END;

	    IF .TYPE_PTR [..COUNT_PTR] EQL GUIDE_FILL
	    THEN
		BEGIN				! Move the guide heading too
		COPY_LINES = .COPY_LINES + 2;
		.COUNT_PTR = ..COUNT_PTR - 2;
		END;
	    END;

	FILL_LINES = .COPY_LINES + 1;
	END;

    [ENTRY_B TO ENTRY_E]:
	BEGIN
	!
	! An index entry
	!
	IF (.TYPE NEQ ENTRY_E)
	OR (.CMDBLK [NDX$V_CONTINUATION] AND (.LSTPTR [XE$A_SUBX] NEQ 0))
	THEN
	    BEGIN
	    !
	    ! Line is not the end of an entry
	    !		OR
	    ! Doing continuation headings and have subindex entries.
	    !
	    ! Move it to next column.
	    !
	    DECR I FROM ..COUNT_PTR TO 1 DO
		IF (.TYPE_PTR [.I] NEQ ENTRY_W) AND (.TYPE_PTR [.I] NEQ ENTRY_B)
		THEN
		    EXITLOOP
		ELSE
		    BEGIN
		    COPY_LINES = .COPY_LINES + 1;
		    .COUNT_PTR = ..COUNT_PTR - 1;
		    END;

	    IF .TYPE_PTR [..COUNT_PTR] EQL GUIDE_FILL
	    THEN
		BEGIN				! Move the guide heading too
		COPY_LINES = .COPY_LINES + 2;
		.COUNT_PTR = ..COUNT_PTR - 2;
		END;

	    FILL_LINES = .COPY_LINES + 1;
	    END;
	END;

    [GUIDE_FILL]:
	BEGIN
	!
	! Line following guide heading. 
	!
	COPY_LINES = 1;
	.COUNT_PTR = ..COUNT_PTR - 1;
	FILL_LINES = 2;
	END;

    [GUIDE]:
	!
	! Guide heading.
	! Start guide heading in next column.
	!
	FILL_LINES = 1;

    [INRANGE]:
	!
	! Line is one of: BKT_E, FILL, SUB_E or CONT_HEAD. Just insert it.
	!
	;

    TES;

    IF .COPY_LINES NEQ 0
    THEN
	!
	! Copy lines to temp column
	!
	INCR I FROM 1 TO .COPY_LINES DO
	    BEGIN
	    $STR_COPY (STRING = LINES_PTR [..COUNT_PTR + .I, 0,0,0,0],
		TARGET = TLINES [.I, 0,0,0,0]);
	    TTYPE [.I] = .TYPE_PTR [..COUNT_PTR + .I];
	    END;
    
    !
    ! Copy line we started with
    !
    COPY_LINES = .COPY_LINES + 1;
    TTYPE [.COPY_LINES] = .TYPE;
    PADLIN (.I_LEN, .PTR, .E_LEN, TLINES [.COPY_LINES, 0,0,0,0]);

    IF .FILL_LINES NEQ 0
    THEN
	BEGIN
	!
	! Insert FILL lines to fill out rest of column
	!
	LINE_TYPE = FILL;

	INCR I FROM 1 TO .FILL_LINES DO INS_LINE (4, .BLANKS, 4);
	END;

    IF .COPY_LINES NEQ 0
    THEN
	!
	! Put copied lines in new column
	!
	INCR I FROM 1 TO .COPY_LINES DO
	    BEGIN
	    S = TLINES [.I, 0,0,0,0];
	    LINE_TYPE = .TTYPE [.I];
	    INS_LINE (.S [STR$H_LENGTH], .S [STR$A_POINTER], 0);
	    END;

    DOING_LAST = FALSE;				! Not doing last line any more

    END;

%SBTTL 'DO_CONTINUE -- Generate continuation heading if necessary'
ROUTINE DO_CONTINUE (I_LEN, PTR, E_LEN) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to generate a continuation heading if necessary
!
!	The input line is copied to local storage since it may reside in
!	RNO_LINE which is used to build the continuation heading. Note 
!	that the input line cannot be copied to TLINES since this routine
!	may be called during the execution of LAST_LINE which uses TLINES
!	to temporarily store one to many lines of text.
!
!	The continuation heading is generated by setting LINE_TYPE to
!	CONT_HEAD and by scanning the subindex list stack from bottom
!	to top, calling FORMAT_ENTRY for each level.
!
! FORMAL PARAMETERS:
!
!	I_LEN	- Internal length of line being processed
!	PTR	- CH$PTR to line
!	E_LEN	- External length of line being processed
!
! IMPLICIT INPUTS:
!
!	CMDBLK	- Command line information block
!	LSTSTK	- Subindex list stack
!	INDLVL	- Subindex level
!	LINE_TYPE - Type of current line
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	Sets CMDBLK [NDX$V_CONTINUATION] to false while processing
!	the input line. This prevents INS_LINE from calling the routine
!	again which would cause an infinite loop.
!
!	Sets LINE_TYPE to CONT_HEAD so that FORMAT_ENTRY will generate
!	a continuation heading instead of normal index entries.
!--
    BEGIN
    LOCAL
	LINE : VECTOR [CH$ALLOCATION(1200)],
	INT,
	EXT,
	TYP;

    CMDBLK [NDX$V_CONTINUATION] = FALSE;	! Prevent infinite loop of calls

    !
    ! Copy input parameters and input line
    !
    INT = .I_LEN;
    EXT = .E_LEN;
    TYP = .LINE_TYPE;
    CH$MOVE (.INT, .PTR, CH$PTR (LINE));
    CLR_RNO_LINE ();

    IF (.TYP EQL SUB_B)				! First line of subindex entry
    OR (.TYP EQL SUB_E)				! Last line of subindex entry
    THEN					! NOTE: can't get SUB_W as first
	BEGIN					! line in column.
	LOCAL
	    PTR,
	    SAV_INDLVL;

	PTR = .LSTPTR;				! Save current entry pointer
	SAV_INDLVL = .INDLVL;			! Save current index level
	LSTSTK [.INDLVL] = 0;			! Make sure top of stack is zero

	INCR I FROM 0 TO .SAV_INDLVL - 1 DO
	    BEGIN				! Generate continuation heading
	    INDLVL = .I;
	    LSTPTR = .LSTSTK [.I];
	    LINE_TYPE = CONT_HEAD;
	    FORMAT_ENTRY ();
	    END;

	INDLVL = .SAV_INDLVL;			! Restore current index level
	LSTPTR = .PTR;				! and entry pointer
	END;

    LINE_TYPE = .TYP;
    INS_LINE (.INT, CH$PTR (LINE), .EXT);	! Insert original line
    CMDBLK [NDX$V_CONTINUATION] = TRUE;		! Reset continuation switch
    END;

%SBTTL 'FILL_LINE -- Format an output line'
ROUTINE FILL_LINE (I_LEN, I_PTR, INDENT, MAX_EXT, BOLD, UND, L_BLANK) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine copies and formats the string specified by
!	I_LEN and I_PTR into RNO_LINE. If the external length
!	of the line exceeds MAX_EXT, the line is forced out.
!
! FORMAL PARAMETERS:
!
!	I_LEN	- Length of input string
!	I_PTR	- Pointer to input string
!	INDENT	- Number of spaces to indent line
!	MAX_EXT	- Maximum external line length allowed.
!	BOLD	- TRUE if string is to be bolded
!	UND	- TRUE if string is to be underlined
!	L_BLANK	- TRUE if a blank should be inserted before the string
!
! IMPLICIT INPUTS:
!
!	LINE_POINTER	- pointer to next character in output line
!	EXT_LINE_LENGTH - external line length
!	INT_LINE_LENGTH	- internal line length
!	CMDBLK		- command line information block
!	TMSSTD		- standard character size for TMS
!	TMS_LINE_LENGTH	- length of line in TMS relative units
!	CHRSIZ		- TMS character size vector
!
! IMPLICIT OUTPUTS:
!
!	LINE_POINTER	- pointer to next character in output line
!	EXT_LINE_LENGTH - external line length
!	INT_LINE_LENGTH	- internal line length
!	TMS_LINE_LENGTH	- length of line in TMS relative units
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    LOCAL
	WORD_POINTER,
	RNO_WORD : VECTOR [CH$ALLOCATION(1200)],
	INT_WORD_LENGTH,
	EXT_WORD_LENGTH,
	TMS_WORD_LENGTH,
	MAX_LEN,
	HYPHENATE,
	HYPH,
	INSERT_BLANK,
	CHAR_COUNT,
	TEXT_PTR;

    IF .CMDBLK [NDX$H_FORMAT] EQL DSR
    THEN
	!
	! RUNOFF output.
	!
	MAX_LEN = .MAX_EXT
    ELSE
	!
	! For TMS11 or TEX output, we don't count characters.
	!
	! The line length is expressed in units and each character is
	! assigned a length in units.
	!
	! The line length is computed as follows:
	!	(line length in characters - safety margin in characters)
	!	* average character size
	!
	! The safety margin is present to allow for slightly larger 
	! italicized or bolded characters.
	!
	MAX_LEN = (.MAX_EXT - TMS_SAFETY_MARGIN) * TMSSTD;

    CHAR_COUNT = .I_LEN;
    TEXT_PTR = .I_PTR;

    HYPH = FALSE;
    INSERT_BLANK = .L_BLANK;

    WHILE .CHAR_COUNT GTR 0 DO
	BEGIN
	LOCAL
	    L_PTR,
	    L_LEN;
    
	CLR_RNO_WORD ();			! Initialize word variables

	!
	! Get next word.
	!
	L_PTR = .TEXT_PTR;
	L_LEN = .CHAR_COUNT;
	INCR I FROM 1 TO .CHAR_COUNT DO
	    BEGIN
	    !
	    ! Skip leading whitespace if any
	    !
	    LOCAL
		CH;

	    CH = CH$RCHAR_A (L_PTR);
	    IF (.CH EQL %C' ') OR (.CH EQL TAB)
	    THEN
		L_LEN = .L_LEN - 1		! One less input character
	    ELSE
		BEGIN
		!
		! End of leading whitespace
		!
		L_PTR = CH$PLUS (.L_PTR, -1);	! Back up to account for overshoot
		EXITLOOP;
		END;
	    END;

	TEXT_PTR = .L_PTR;			! Point past leading whitespace
	CHAR_COUNT = .L_LEN;			! Update length of string

	INCR I FROM 1 TO .CHAR_COUNT DO
	    BEGIN
	    !
	    ! Now copy the word to the word buffer
	    !
	    LOCAL
		CH;

	    CH = CH$RCHAR_A (L_PTR);

	    IF .CH EQL RINTES
	    THEN
		BEGIN
		!
		! RUNOFF escape sequence
		!
		LOCAL
		    OPERAND;

		CH = CH$RCHAR_A (L_PTR);	! Get function
		OPERAND = CH$RCHAR_A (L_PTR);	! And the operand
		I = .I + 2;			! Update number of characters processed
		L_LEN = .L_LEN - 3;		! Update remaining character count

		SELECTONE .CH OF
		    SET

		    [%C'B']:			! Bold
			NQCHAR_NC (%C'*');

		    [%C'O']:			! Overstrike
			BEGIN
			NQCHAR_NC (.OPERAND);
			NQCHAR_NC (%C'%');
			END;

		    [%C'U']:			! Underline
			NQCHAR_NC (%C'&');

		    [%C'N']:
			IF .OPERAND EQL %C'-'
			THEN
			    BEGIN		! Hyphenate
			    HYPHENATE = TRUE;
			    EXITLOOP;
			    END;

		    TES;
		END
	    ELSE
		BEGIN
		!
		! Not a RUNOFF escape sequence, process character
		!
		L_LEN = .L_LEN - 1;		! One less character

		IF (.CH EQL %C' ') OR (.CH EQL TAB) 
		THEN 
		    EXITLOOP;			! Whitespace - end of word

		!
		! Bold and underline character if requested
		!
		IF .BOLD THEN NQCHAR_NC (%C'*');
		IF .UND  THEN NQCHAR_NC (%C'&');

		IF (.CH LSS %C' ') OR (.CH GTR %O'176')
		THEN
		    !
		    ! Control character
		    !
		    IF .CH NEQ %O'10'
		    THEN
			QCHAR_C (.CH)		! Normal control character
		    ELSE
			BACKSPACE (.CH)		! Process backspace
		ELSE
		    !
		    ! Not a control character
		    !
		    IF (.CH EQL %C'&')
		    OR (.CH EQL %C'*')
		    OR (.CH EQL %C'_')
		    OR (.CH EQL %C'.')
		    OR (.CH EQL %C'%')
		    THEN
			QCHAR_C (.CH)		! RUNOFF flag so quote it
		    ELSE
			NQCHAR_C (.CH);		! Ordinary character
		END;
	    END;

	TEXT_PTR = .L_PTR;			! Point to next character
	CHAR_COUNT = .L_LEN;			! Update length of input string

	!
	! Compute space needed if word is to be added to current line.
	!
	IF .CMDBLK [NDX$H_FORMAT] EQL DSR
	THEN
	    BEGIN
	    !
	    ! For RUNOFF, total = line length + word length
	    !   + 1 for comma in case this is the last word in the entry
	    !   + 1 if previous word was not terminated by a hyphenate sequence
	    !   + 1 if current word terminated with a hyphenate sequence
	    !
	    L_LEN = .EXT_LINE_LENGTH + .EXT_WORD_LENGTH + 1
		+ (IF NOT .HYPH THEN 1 ELSE 0) + (IF .HYPHENATE THEN 1 ELSE 0);
	    END
	ELSE
	    BEGIN
	    !
	    ! For TMS and TEX, total length = line length + word length
	    !	+ length of blank in case this is the last word in the entry
	    !	+ length of blank if previous word was not terminated by a hyphenate sequence
	    !	+ length of hyphen if current word terminated with a hyphenate sequence
	    !
	    L_LEN = .TMS_LINE_LENGTH + .TMS_WORD_LENGTH + .CHRSIZ [%C' ']
		+ (IF NOT .HYPH THEN .CHRSIZ [%C' '] ELSE 0)
		+ (IF .HYPHENATE THEN .CHRSIZ [%C'-'] ELSE 0);
	    END;

	IF .L_LEN GTR .MAX_LEN
	THEN
	    BEGIN
	    !
	    ! Word will not fit on line
	    !
	    IF .HYPH
	    THEN
		BEGIN
		!
		! Previous word terminated with a hyphenate sequence.
		! Add trailing hyphen.
		!
		CH$WCHAR_A (%C'-', LINE_POINTER);
		INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;
		EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
		TMS_LINE_LENGTH = .TMS_LINE_LENGTH + .CHRSIZ [%C'-'];
		END;

	    INS_LINE (.INT_LINE_LENGTH, CH$PTR (RNO_LINE), .EXT_LINE_LENGTH);

	    IF .LINE_TYPE NEQ CONT_HEAD THEN LINE_TYPE = (IF .INDLVL EQL 0 THEN ENTRY_W ELSE SUB_W);

	    !
	    ! Indent new line
	    !
	    INDENT_LINE (.INDENT + 4);

	    !
	    ! Verify word will fit on new line
	    !
	    IF .CMDBLK [NDX$H_FORMAT] EQL DSR
	    THEN
		BEGIN
		!
		! For RUNOFF...
		!
		L_LEN = .EXT_LINE_LENGTH + .EXT_WORD_LENGTH + 1
		    + (IF .HYPHENATE THEN 1 ELSE 0);
		END
	    ELSE
		BEGIN
		!
		! For TMS and TEX...
		!
		L_LEN = .TMS_LINE_LENGTH + .TMS_WORD_LENGTH + .CHRSIZ [%C' ']
		    + (IF .HYPHENATE THEN .CHRSIZ [%C'-'] ELSE 0);
		END;

	    IF .L_LEN GTR .MAX_LEN
	    THEN

%IF %BLISS (BLISS32)
%THEN						! Signal errors in BLISS32

		SIGNAL (INDEX$_DOESNTFIT, 2, .INT_WORD_LENGTH, CH$PTR (RNO_WORD));

%ELSE						! Use $XPO_PUT_MSG otherwise

		$XPO_PUT_MSG (SEVERITY = WARNING,
		    STRING = $STR_CONCAT ('the word ''', (.INT_WORD_LENGTH, CH$PTR (RNO_WORD)),
			''' will not fit at current indentation level'));

%FI

	    END
	ELSE
	    BEGIN
	    !
	    ! Word will fit on line.
	    !
	    IF CH$NEQ (1, .BLANKS, .INT_LINE_LENGTH, CH$PTR (RNO_LINE), %C' ')
	    AND (NOT .HYPH)
	    AND .INSERT_BLANK
	    THEN
		BEGIN
		!
		! Line is non-blank, previous word did not terminate
		! with a hyphenate sequence, and we are supposed to insert a blank.
		!
		! Add a blank to the line before adding the word.
		!
		CH$WCHAR_A (%C' ', LINE_POINTER);
		INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;
		EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
		TMS_LINE_LENGTH = .TMS_LINE_LENGTH + .CHRSIZ [%C' '];
		END;
	    END;

	!
	! Append word to line
	!
	CH$MOVE (.INT_WORD_LENGTH, CH$PTR (RNO_WORD), .LINE_POINTER);
	LINE_POINTER = CH$PLUS (.LINE_POINTER, .INT_WORD_LENGTH);
	INT_LINE_LENGTH = .INT_LINE_LENGTH + .INT_WORD_LENGTH;
	EXT_LINE_LENGTH = .EXT_LINE_LENGTH + .EXT_WORD_LENGTH;
	TMS_LINE_LENGTH = .TMS_LINE_LENGTH + .TMS_WORD_LENGTH;

	HYPH = .HYPHENATE;		! Save hyphenation status of current word
	INSERT_BLANK = TRUE;
	END;

    END;

%SBTTL 'INDENT_LINE -- Indent new line'
ROUTINE INDENT_LINE (INDENT) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine clears out RNO_LINE and fills it with the number
!	of blanks specified by INDENT.
!
! FORMAL PARAMETERS:
!
!	INDENT - Number of blanks to indent line
!
! IMPLICIT INPUTS:
!
!	CMDBLK		  - Command line information block
!	TMSSTD		  - Standard TMS character size
!	MSPACE		  - Size of /m sequence
!
! IMPLICIT OUTPUTS:
!
!	EXT_LINE_LENGTH = .INDENT
!	INT_LINE_LENGTH = .INDENT
!	LINE_POINTER	= Pointer to next character position in RNO_LINE
!	TMS_LINE_LENGTH = Length of line in TMS relative units
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    LOCAL
	IND;

    IND = .INDENT;
    CLR_RNO_LINE ();
    EXT_LINE_LENGTH = .IND;

    IF  (.IND GEQ .CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID])
    AND ((.CMDBLK [NDX$H_FORMAT] EQL TMS11_A) OR (.CMDBLK [NDX$H_FORMAT] EQL TMS11_E))
    THEN
	BEGIN
	!
	! TMS11 output and padding out to second column
	! for /MASTER/LAYOUT=SEPARATE
	!
	CH$WCHAR_A (TAB, LINE_POINTER);		! Use tabs to get to second column
	CH$WCHAR_A (TAB, LINE_POINTER);
	INT_LINE_LENGTH = .INT_LINE_LENGTH + 2;

	IND = .IND - .CMDBLK [NDX$G_COLUMN_WID] - .CMDBLK [NDX$G_GUTTER_WID];

	TMS_LINE_LENGTH = (.CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_GUTTER_WID]) * TMSSTD
	    + (.IND / 2) * MSPACE;
	END
    ELSE
	TMS_LINE_LENGTH = (.IND / 2) * MSPACE;

    CH$FILL (%C' ', .IND, .LINE_POINTER);
    INT_LINE_LENGTH = .INT_LINE_LENGTH + .IND;
    LINE_POINTER = CH$PLUS (CH$PTR (RNO_LINE), .INT_LINE_LENGTH);
    END;

%SBTTL 'PADLIN -- Pad line to column width'
GLOBAL ROUTINE PADLIN (INT_LEN, PTR, EXT_LEN, DSC) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine pads the input line to the column width
!
! FORMAL PARAMETERS:
!
!	INT_LEN	- Internal length of line
!	PTR	- CH$PTR to line
!	EXT_LEN	- Number of print positions used by line
!	DSC	- Address of string descriptor where padded line is returned
!
! IMPLICIT INPUTS:
!
!	CMDBLK [NDX$G_GUTTER_WID] - Gutter width
!	CMDBLK [NDX$G_COLUMN_WID] - Column width
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    IF .CMDBLK [NDX$H_FORMAT] NEQ DSR		! For TMS and TEX output
    OR (.CMDBLK [NDX$H_LAYOUT] NEQ TWO_COLUMN)	! For all output except TWO_COLUMN
    OR (.EXT_LEN EQL 0) 			! Or previously padded output
    OR (.EXT_LEN GTR .CMDBLK [NDX$G_COLUMN_WID])
    THEN
	!
	! Line does not need padding. Just copy it.
	!
	$STR_COPY (STRING = (.INT_LEN, .PTR), TARGET = .DSC)
    ELSE
	BEGIN
	!
	! Compute output length = 
	!	internal length + (column width - external length) + gutter width
	!
	LOCAL
	    LINE : VECTOR [CH$ALLOCATION (1200)],
	    LEN;

	LEN = .INT_LEN + (.CMDBLK [NDX$G_COLUMN_WID] - .EXT_LEN) + .CMDBLK [NDX$G_GUTTER_WID];

	CH$COPY (.INT_LEN, .PTR, %C' ', .LEN, CH$PTR (LINE));
	$STR_COPY (STRING = (.LEN, CH$PTR (LINE)), TARGET = .DSC);
	END;

    END;

END				!End of module
ELUDOM
