.TITLE	SCRINS	SCOPE "WATCH" INSERT PROCESSING FOR TECO
.NLIST	TTM
.LIST	TOC,MEB,BEX
.DSABL	REG,GBL,LC
.SBTTL	SCOPE "WATCH" INSERT PROCESSING FOR TECO

; LAST EDIT ON 02-JUN-83 BY MARK BRAMHALL

.IDENT	/V39.00/

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

.SBTTL	GENERAL PDP-11 DEFINITIONS

; GENERAL REGISTER DEFINITIONS

R0	=	%0
R1	=	%1
R2	=	%2
R3	=	%3
R4	=	%4
R5	=	%5
SP	=	%6
PC	=	%7

.SBTTL	ASCII CHARACTER DEFINITIONS

BS	=	010	;ASCII BACKSPACE
TAB	=	011	;ASCII HORIZONTAL TAB
LF	=	012	;ASCII LINE FEED
CR	=	015	;ASCII CARRIAGE RETURN
SPACE	=	040	;ASCII SPACE
DEL	=	177	;ASCII DELETE (ALSO CALLED RUBOUT)

.SBTTL	HANDLE -256+N:W (INSERT PROCESSING, ETC.)

;+
; SCRINS - HANDLE -256+N:W (INSERT PROCESSING, ETC.).
;
;	R0 = -256.+N WHERE:
;
;	N = +128. = 200 = <7> => DON'T STALL IF NO TERMINAL INPUT IS AVAILABLE
;	     +64. = 100 = <6> => EXIT ON ANY CHARACTER
;	     +32. =  40 = <5> => DON'T UPDATE SCREEN
;	     +16. =  20 = <4> => ** RESERVED **
;	      +8. =  10 = <3> => TREAT M(R5) AS EXCEPTION CHARACTER(S)
;	      +4. =   4 = <2> => UPPER CASE ANY INSERT(S)
;	      +2. =   2 = <1> => TREAT <TAB> AS AN EXCEPTION CHARACTER
;	      +1. =   1 = <0> => NO NEED TO INITIALLY UPDATE THE SCREEN
;
;	IF CFLG(R5)=-1 THEN
;		M(R5) = UPDATE INTERVAL IF <2> OF N IS 0
;		      = EXCEPTION CHARACTER(S) IF <2> OF N IS 1
;
;	JSR	PC,SCRINS
;
;	R0 = RETURNED EXIT VALUE WHERE:
;
;	R0  <15>  => ONE OR MORE INSERT(S) WERE DONE
;	R0 <14-8> =  ** RESERVED **
;	R0  <7-0> =  377 => DON'T STALL SPECIFIED AND NO INPUT AVAILABLE
;		  <> 377 => EXCEPTION CHARACTER'S VALUE
;-

.GLOBL	SI.OK			;SCREEN IMAGE IS O.K.
.GLOBL	SI.EXT			;TREAT <TAB> AS AN EXCEPTION CHARACTER
.GLOBL	SI.UC			;UPPER CASE ANY INSERT(S)
.GLOBL	SI.EXM			;TREAT M(R5) AS EXCEPTION CHARACTER(S)
;				;** RESERVED **
.GLOBL	SI.NUP			;DON'T UPDATE SCREEN
.GLOBL	SI.EXA			;EXIT ON ANY CHARACTER
.GLOBL	SI.NST			;DON'T STALL IF NO TERMINAL INPUT IS AVAILABLE

.GLOBL	SI.OKS			;ALL SET FOR A SIMPLE SCREEN UPDATE
.GLOBL	SI.INS			;ONE OR MORE INSERT(S) WERE DONE

.PSECT	SCRINS,RO,I,GBL,REL,OVR

SCRINS:	MOV	ETYPE(R5),-(SP)	;SAVE INITIAL "ETYPE"
	CLR	N(R5)		;GUESS AT NO SPECIAL EXCEPTION CHARACTER(S)
	BIT	R0,#SI.EXM	;GOOD GUESS?
	BEQ	10$		;YEP
	INC	CFLG(R5)	;M,N FORMAT?
	BNE	20$		;NO
	MOV	M(R5),N(R5)	;YES, SET EXCEPTION CHARACTER CODE(S)
10$:	INC	CFLG(R5)	;M,N FORMAT?
	BEQ	30$		;YES, M HAS THE UPDATE INTERVAL VALUE
20$:	CLR	M(R5)		;SET UPDATE INTERVAL VALUE TO "INFINITY"
30$:	TST	M(R5)		;A VALID UPDATE INTERVAL VALUE?
	BMI	20$		;NOPE, GO MAKE IT "INFINITY"
	CLR	CFLG(R5)	;ENSURE COMMA FLAG IS NOW OFF
	MOV	M(R5),OUTCHR+RWSIZE(R5) ;SET UPDATE INTERVAL INTO TEMP COUNTER
	CLR	-(SP)		;STACK A FLAG WORD
	MOVB	R0,(SP)		; AND INSERT THE CALLING ARGUMENT BITS

.GLOBL	ETYPE,	N,	CFLG,	M,	OUTCHR,	RWSIZE

READCS:	BIS	#ET$CC!ET$CKE!ET$NCH,ETYPE(R5) ;INDICATE NO STALL, ETC.
	TSTB	(SP)		;NO STALL?
	BMI	10$		;GO READ W/O A STALL IF NO STALL
;.IIF	NE	SI.NST-200, .ERROR ;THE ABOVE WON'T WORK
	BIT	(SP),#SI.NUP!SI.OK ;NOT UPDATING A/O SCREEN ALREADY O.K.?
	BEQ	10$		;NEITHER, GO READ W/O A STALL
	BIC	#ET$CKE,ETYPE(R5) ;GO BACK TO TERMINAL STALL MODE
10$:	JSR	PC,TLISTN	;READ FROM THE TERMINAL
SI$RET	==	.	;** RETURN ADDRESS FOR CONTROL/T INPUT CALLS **
	TST	ETYPE(R5)	;CHECK FOR CONTROL/C TYPED
	BPL	30$		;WHOOPS! CONTROL/C TYPED
;.IIF	NE	ET$CC-100000, .ERROR ;THE ABOVE WON'T WORK
	TST	R0		;DID WE GET ANYTHING?
	BPL	40$		;YES
	TSTB	(SP)		;NO STALL?
	BPL	80$		;NOPE, GO CHECK THE DISPLAY CORRECTNESS
;.IIF	NE	SI.NST-200, .ERROR ;THE ABOVE WON'T WORK
20$:	BIC	#^C<SI.INS>,(SP) ;CLEAR ALL BUT INSERT(S) DONE
	MOVB	R0,(SP)		;PUT EXCEPTION CHARACTER VALUE INTO FLAG
	MOV	(SP)+,R0	; AND SET R0 FOR RETURNED VALUE
	BIC	#^C<ET$CC!ET$CKE!ET$NCH>,(SP) ;TRIM SAVED "ETYPE"
	BIC	#ET$CC!ET$CKE!ET$NCH,ETYPE(R5) ;TURN OFF OUR BITS
	BIS	(SP)+,ETYPE(R5)	; THEN RESTORE ORIGINAL "ETYPE"
	RTS	PC		;  AND EXIT

.GLOBL	ET$CC,	ET$CKE,	ET$NCH,	ETYPE,	TLISTN

30$:	MOV	#'C-100,R0	;SET A CONTROL/C AS TYPED
	BIC	#ET$CC,2(SP)	; AND ENSURE THAT CONTROL/C TRAPS TURN OFF
40$:	BIT	(SP),#SI.EXA	;EXIT ON ANY CHARACTER?
	BNE	20$		;YES, EXIT
	CMPB	R0,#DEL		;CONTROL CHARACTER OR G1 GRAPHIC?
	BHIS	20$		;YES (177 TO 377), EXIT
	CMPB	R0,#SPACE	;MIGHT BE...
	BHIS	50$		;NORMAL GRAPHIC (040 TO 176)
	CMPB	R0,#TAB		;CONTROL CHARACTER, IS IT <TAB>?
	BNE	20$		;NO, OTHER, EXIT
	BIT	(SP),#SI.EXT	;ALLOWING <TAB>?
	BNE	20$		;NO, EXIT
50$:	BIT	(SP),#SI.EXM	;EXIT ON SPECIAL(S)?
	BEQ	60$		;NOPE
	CMPB	R0,N(R5)	;FIRST SPECIAL MATCH?
	BEQ	20$		;YES, EXIT
	CMPB	R0,N+1(R5)	;SECOND SPECIAL MATCH?
	BEQ	20$		;YES, EXIT ALSO
60$:	BIT	(SP),#SI.UC	;UPPER CASE INSERT(S)?
	BEQ	70$		;NOPE
	JSR	PC,UPPERC	;YEP, SO GO DO SO
70$:	BIS	#SI.INS!SI.OK,(SP) ; THEN INDICATE INSERT(S) DONE
	DEC	(SP)		;  BUT INDICATE DISPLAY NOT NOW CORRECT
;.IIF	NE	SI.OK-1, .ERROR	;THE ABOVE WON'T WORK
	JSR	PC,DOINST	;GO SAVE REGISTERS AND DO TEXT BUFFER INSERT
	DEC	OUTCHR+RWSIZE(R5) ;SHOULD WE UPDATE THE DISPLAY NOW?
	BNE	READCS		;NO, JUST LOOP FOR READ...
80$:	BIT	(SP),#SI.NUP!SI.OK ;NO UPDATE OR SCREEN O.K.?
	BNE	90$		;ONE OR THE OTHER, DON'T UPDATE
	JSR	PC,100$		;ELSE GO UPDATE THE SCREEN
	BIS	#SI.OKS!SI.OK,(SP) ;SAY SCREEN IS FULLY UPDATED NOW
90$:	MOV	M(R5),OUTCHR+RWSIZE(R5) ;RESET UPDATE INTERVAL TEMP COUNTER
	TST	ETYPE(R5)	;SET N-BIT=0 IF A CONTROL/C TYPED
	BMI	READCS		;N-BIT=1 => NO CONTROL/C, LOOP FOR READ...
;.IIF	NE	ET$CC-100000, .ERROR ;THE ABOVE WON'T WORK
	BR	30$		;CONTROL/C, SO GO EXIT WITH IT

100$:	BIT	2(SP),#SI.OKS	;ALL SET FOR A SIMPLE UPDATE?
	BEQ	110$		;NOPE, MUST DO A FULL SCREEN UPDATE
	JSR	R0,SCRSAV	;YEP, SAVE ALL REGISTERS, ETC.
	MOV	TOPDOT+RWSIZE(R5),R0 ;GET LAST USED UPPER LEFT HAND CORNER
	DEC	R0		; AND CORRECT IT
	MOV	R0,LINPTR+RWSIZE(R5) ;SET THAT AS THE STARTING POINT
	MOV	P(R5),-(SP)	;STACK "DOT" POSITION
	MOV	#SCROUT,-(SP)	;STACK THE SCREEN OUTPUT ROUTINE
	JMP	CHKSCN		;NOW GO OFF AND DO THE SIMPLE UPDATE

110$:	MOV	#-1,R0		;SET CALLING ARGUMENT TO -1
	JMP	SCRUPD		; AND GO UPDATE THE SCREEN

.GLOBL	ET$CC,	N,	UPPERC,	OUTCHR,	RWSIZE,	M,	ETYPE
.GLOBL	SCRSAV,	TOPDOT,	LINPTR,	P,	SCROUT,	CHKSCN,	SCRUPD

DOINST:	MOV	SP,OUTBLN+RWSIZE(R5) ;SAVE CALLING SP STACK VALUE
	JSR	R0,SCRSAV	;SAVE ALL REGISTERS
	JSR	PC,.III.I	;GO DO THE TEXT BUFFER INSERT
	MOV	OUTBLN+RWSIZE(R5),R4 ;GET POINTER TO ARGUMENT BITS -2
	TST	(R4)+		; THEN MAKE IT A POINTER TO ARGUMENT BITS
	BIT	(R4),#SI.OKS	;WAS DISPLAY SET FOR A SIMPLE UPDATE?
	BEQ	40$		;NOPE, FORGET THIS OPTIMIZATION...
	MOV	CURPOS+RWSIZE(R5),R1 ;GET CURRENT TEXT BUFFER POINTER
	MOVB	(R1)+,R0	; AND GET BACK THE INSERTED CHARACTER
	CMP	R0,#TAB		;WAS IT A <TAB>?
	BEQ	40$		;YEP, NO OPTIMIZATION CAN BE DONE...
	SUB	TXSTOR(R5),R1	;MAKE TEXT POINTER RELATIVE
	CMP	R1,P(R5)	;AT CURRENT "DOT"?
	BNE	40$		;NOPE, OTHER INSERT(S) DONE, FORGET IT...
	CMP	R1,ZZ(R5)	;AT END-OF-TEXT?
	BEQ	10$		;YEP
	ADD	TXSTOR(R5),R1	;NOPE, MAKE POINTER ABSOLUTE AGAIN
	CMPB	(R1)+,#CR	;FACING THE END OF THE LINE?
	BNE	40$		;NOPE, CAN'T DO ANYTHING...
	CMPB	(R1)+,#LF	;A TRUE, NORMAL END OF LINE?
	BNE	40$		;NO WAY, PUNT ON IT...
10$:	MOV	CURABS+RWSIZE(R5),R1 ;DID WE FIND THE CURSOR?
	BEQ	40$		;NO, FORGET IT...
	MOVB	(R1)+,R2	;YES, SNAG CURRENT SCREEN MAP CHARACTER
	CMPB	(R1),#SPACE	;A SPACE AFTER IT?
	BNE	40$		;NOPE, NO GO...
20$:	CMP	CURCOL+RWSIZE(R5),HTSIZ2+RWSIZE(R5) ;IS CURSOR TOO FAR RIGHT?
	BHIS	40$		;YEP, FORGET IT...
	BIT	(R4),#SI.NUP	;UPDATING THE SCREEN AT ALL?
	BNE	40$		;NOPE
	TST	OUTDNE(R5)	;HAS SOME OUTPUT BEEN DONE?
	BNE	40$		;YES, TOO MESSY FOR US...
	TST	MRKFLG+RWSIZE(R5) ;MARK'D REGION ACTIVE?
	BNE	40$		;YES, ALSO TOO MESSY...

.GLOBL	OUTBLN,	RWSIZE,	SCRSAV,	.III.I,	CURPOS,	TXSTOR,	P,	ZZ
.GLOBL	CURABS,	CURCOL,	HTSIZ2,	OUTDNE,	MRKFLG

	INC	(R4)		;DISPLAY IS NOW CORRECT AGAIN
;.IIF	NE	SI.OK-1, .ERROR	;THE ABOVE WON'T WORK
	MOVB	R2,(R1)		;REPLACE THE OLD SCREEN MAP CHARACTER
	MOVB	R0,-(R1)	; AND SET INSERTED CHARACTER INTO SCREEN MAP
	INC	CURABS+RWSIZE(R5) ;UPDATE THE SCREEN MAP POINTER
	INC	CURPOS+RWSIZE(R5) ; AND CURRENT TEXT BUFFER POINTER
	JSR	PC,TYPEBF	;OUTPUT THE CHARACTER
	INC	PRECOL+RWSIZE(R5) ; WHICH MOVES US ONE COLUMN RIGHT
	INC	CURCOL+RWSIZE(R5) ;  IN THE CURSOR SPOT ALSO
	CMP	R2,#SPACE	;NORMAL OLD SCREEN MAP CHARACTER?
	BHIS	30$		;YES
	MOV	CRTYPE(R5),R3	;NO, GET THE SCOPE TYPE
	ADD	GRPTBL(R3),R2	;FIND INDEX INTO CORRECT SYMBOL TABLE
	MOVB	-(R2),R0	;GET THE CORRECT GRAPHICS CHARACTER
	MOV	#GONSEQ,R3	;SET TO TURN GRAPHICS ON
	JSR	PC,DOTYPE	;GO OUTPUT THE GRAPHICS ON SEQUENCE
	JSR	PC,TYPEBF	;OUTPUT THE SPECIAL GRAPHICS CHARACTER
	MOV	#GOFSEQ,R3	;SET TO TURN GRAPHICS BACK OFF
	JSR	PC,DOTYPE	;GO OUTPUT THE GRAPHICS OFF SEQUENCE
	MOV	#BS,R0		;SET UP A <BACKSPACE>
	JSR	PC,TYPEBF	; AND GO OUTPUT IT TO CORRECT CURSOR
30$:	JSR	PC,SCRDNE	;GO FORCE BUFFER; CLEAR OUTPUT DONE
	MOV	M(R5),OUTCHR+RWSIZE(R5) ;RESET UPDATE INTERVAL TEMP COUNTER
40$:	RTS	PC		;EXIT

.GLOBL	CURABS,	RWSIZE,	CURPOS,	TYPEBF,	PRECOL,	CURCOL
.GLOBL	CRTYPE,	GRPTBL,	GONSEQ,	DOTYPE,	GOFSEQ,	SCRDNE,	M,	OUTCHR

.END

