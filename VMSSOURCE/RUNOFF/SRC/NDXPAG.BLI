%TITLE 'NDXPAG -- Output page formatting routines'
MODULE NDXPAG (IDENT = 'V04-000'
		    %BLISS32 [, ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE)]
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!   DSR (Digital Standard RUNOFF) /DSRPLUS DSRINDEX/INDEX Utility
!
! ABSTRACT:
!   This module contains routines that format the output index pages.
!
! ENVIRONMENT:   Transportable
!
! AUTHOR: 	 JPK
!
! CREATION DATE: January 1982
!
! MODIFIED BY:
!
!	009	JPK00022	30-Mar-1983
!		Modified NDXVMS, NDXFMT, NDXPAG, NDXVMSMSG and NDXVMSREQ 
!		to generate TEX output. Added module NDXTEX.
!
!	008	JPK00021	28-Mar-1983
!		Modified NDXT20 to include E2.0 functionality.
!		Modified NDXCLIDMP, NDXFMT, NDXPAG, NDXVRS to require RNODEF
!		for BLISS36 and to remove any conditional require based on 
!		DSRPLUS_DEF.
!
!	007	JPK00018	09-Mar-1983
!		Modified INDEX to handle new BRN format.
!		Modified NDXOUT to handle specifyable levels on SORT= string.
!		Modified NDXFMT to output new RUNOFF prologue.
!		Modified NDXPAG to output new TMS prologue and RUNOFF epilogue.
!
!	006	JPK00017	23-Feb-1983
!		Modified NDXINI to initialize the zero'th entries of LLINES,
!		RLINES and TLINES which is where the telltale strings are 
!		stored by NDXFMT.
!		Modified NDXFMT to write appropriate prologue for /TELLTALE,
!		save the appropriate lines for left and right telltales, and
!		to mark the end of every entry with a NULL.
!		Modified NDXPAG to change the NULL following each entry to a
!		space if LAYOUT is SEPARATE or to a comma otherwise and to 
!		generate and output telltales.
!
!	005	JPK00015	04-Feb-1983
!		Cleaned up module names, modified revision history to
!		conform with established standards. Updated copyright dates.
!
!	004	JPK00012	24-Jan-1983
!		Modified NDXVMSMSG.MSG to define error messages for both
!		DSRINDEX and INDEX.
!		Added require of NDXVMSREQ.R32 to NDXOUT, NDXFMT, NDXDAT,
!		INDEX, NDXMSG, NDXXTN, NDXTMS, NDXVMS and NDXPAG for BLISS32. 
!		Since this file defines the error message literals, 
!		the EXTERNAL REFERENCEs for the error message literals 
!		have been removed.
!
!	003	JPK00011	24-Jan-1983
!		Changed CMDBLK [NDX$G_LEVEL] to CMDBLK [NDX$H_LEVEL]
!		Changed CMDBLK [NDX$H_FORMAT] to CMDBLK [NDX$H_LAYOUT]
!		Changed CMDBLK [NDX$V_TMS11] and CMDBLK [NDX$V_TEX] to CMDBLK [NDX$H_FORMAT]
!		Changed comparisons of (.CHRSIZ EQLA CHRSZA) to 
!		(.CMDBLK [NDX$H_FORMAT] EQL TMS11_A).
!		Definitions were changed in NDXCLI and references to the
!		effected fields were changed in NDXPAG, NDXFMT, INDEX, NDXVMS
!		and NDXCLIDMP.
!
!	002	JPK00003	24-Sep-1982
!		Modified NDXPAG for TOPS-20. A 'SIGNAL' was not conditionalized
!		to produce an $XPO_PUT_MSG if not %BLISS (BLISS32).
!		Modified to add requested /TMS=E changes.
!
!--

!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
    PUTPAG	  : NOVALUE,			! Write a formatted page
    VJUST_COL	  : NOVALUE,			! Vertical justify a column
    LASTPG	  : NOVALUE,			! Format and balance last page
    LAST_CONT,					! Generate a continuation heading for last page
    GET_EXT_LEN,				! Get external length of line
    INDENT_LEVEL,				! Get indent level of string
    GUIDE_HEAD	  : NOVALUE,			! Build a guide head for TMS11
    TMSINI	  : NOVALUE,			! Initialization for TMS11 output
    TELLTALE_HEAD : NOVALUE;			! Generate a telltale heading

!
! INCLUDE FILES:
!

LIBRARY 'NXPORT:XPORT';

SWITCHES LIST (REQUIRE);

REQUIRE 'REQ:NDXCLI';

REQUIRE 'REQ:NDXLIN';

%IF %BLISS (BLISS32)
%THEN

REQUIRE 'REQ:NDXVMSREQ';

%FI

SWITCHES LIST (NOREQUIRE);

!
! MACROS:
!

MACRO
    PUT_LINE (S) =
	$XPO_PUT (IOB = OUTIOB, STRING = S) %;

!
! EQUATED SYMBOLS:
!
LITERAL
    TRUE = 1,
    FALSE = 0;

!
! OWN STORAGE:
!
OWN
    BLANKS : INITIAL (CH$PTR (UPLIT ('    ')));	!Pointer to blanks

OWN
    TMS_TMP	: $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    TMS_TITLE	: $STR_DESCRIPTOR (STRING = '[f7p18]INDEX/l[va96]'),
    TMS_GUIDE	: $STR_DESCRIPTOR (STRING = '[f7p12]'),
    TMS_LEFT	: $STR_DESCRIPTOR (STRING = '/l'),
    TMS_RIGHT	: $STR_DESCRIPTOR (STRING = '/r'),
    TMS_TXT_FMT : $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    TMS_TELLTALE: $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    TMS_FOOT	: $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    TMS_PAGE	: $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0));
!
! EXTERNAL REFERENCES:
!
EXTERNAL LITERAL
    MAXLST,					! Maximum subindex depth
    TMSSTD,					! Average TMS character size
    MSPACE,					! TMS 'em' space size
    TMSCOL;					! Default TMS column width

EXTERNAL
    CMDBLK : $NDXCMD,				! Command line information block
    NDXVRL,					! Length of version string
    NDXVRP,					! CH$PTR to version string
    OUTIOB : $XPO_IOB (),			! Output file IOB
    PAGENO,					! Page number
    TMSTOF : $STR_DESCRIPTOR (),		! Top of file string
    TMSSIZ,					! Ideal TMS file size in blocks
    CHRSIZ : REF VECTOR,			! Vector of character sizes for TMS
    LSTSTK : VECTOR,				! Subindex stack
    ALLOWD,					! Usuable lines per page
    LCOUNT,					! Number of lines in left column
    RCOUNT,					! Number of lines in right column
    TCOUNT,					! Number of lines in temp column
!
! NOTE: The vectors and blockvectors below have two extra entries allocated
!	to avoid needing to subtract 1 all the time (for entry zero),
!	and so that there will always be an available line at the end of the column
!
    LTYPE  : VECTOR,				! Left column line types
    LLINES : BLOCKVECTOR [, STR$K_D_BLN],	! Left column string descriptors
    RTYPE  : VECTOR,				! Right column line types
    RLINES : BLOCKVECTOR [, STR$K_D_BLN],	! Right column string descriptors
    TTYPE  : VECTOR,				! Temp column line types
    TLINES : BLOCKVECTOR [, STR$K_D_BLN];	! Right column for last page

EXTERNAL ROUTINE
    RNOTMS  : NOVALUE,			! Convert a line from RUNOFF to TMS format
    TMSPUT  : NOVALUE,			! Put a line to TMS output file
    RNOTEX  : NOVALUE,			! Convert a line from RUNOFF to TEX
    PADLIN  : NOVALUE;			! Pad a line with blanks

%SBTTL 'PUTPAG -- output formatted page'
GLOBAL ROUTINE PUTPAG (LAST) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes a formatted page to the output file.
!
! FORMAL PARAMETERS:
!
!	LAST		- TRUE if last page
!
! IMPLICIT INPUTS:
!
!	ALLOWD		- number of lines on this page
!	LLINES		- left column lines
!	RLINES		- right column lines
!	TLINES		- temp column lines (used for last page)
!	CMDBLK		- command line information block
!
! IMPLICIT OUTPUTS:
!
!	LCOUNT		- set to zero
!	RCOUNT		- set to zero
!	ALLOWD		- set to value of CMDBLK [NDX$G_LINES_PAGE]
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    LOCAL
	R_COL_LINES : REF BLOCKVECTOR [, STR$K_D_BLN],
	R_COL_TYPE  : REF VECTOR,
	IDEAL;

    IDEAL = TRUE;
    PAGENO = .PAGENO + 1;

    IF .CMDBLK [NDX$V_TELLTALE]
    THEN
	BEGIN						! Generate telltale heading
	TELLTALE_HEAD ();
	IDEAL = FALSE;
	END;

    IF .CMDBLK [NDX$H_LAYOUT] EQL TWO_COLUMN
    THEN
	BEGIN
	VJUST_COL (LCOUNT, LLINES, LTYPE);		! Vertical justify left column

	IF .LAST
	THEN
	    BEGIN
	    !
	    ! Doing last page.
	    ! Right column stuff is stored in temp column after page is balanced
	    !
	    VJUST_COL (TCOUNT, TLINES, TTYPE);		! Vertical justify column

	    R_COL_LINES = TLINES [0,0,0,0,0];		! Set up pointers to lines
	    R_COL_TYPE = TTYPE [0];			! and line types
	    END
	ELSE
	    BEGIN
	    !
	    ! Not last page
	    !
	    VJUST_COL (RCOUNT, RLINES, RTYPE);		! Vertical justify column

	    R_COL_LINES = RLINES [0,0,0,0,0];		! Set up pointers to lines
	    R_COL_TYPE = RTYPE [0];			! and line types
	    END;
	END;

    INCR I FROM 1 TO .ALLOWD DO
	BEGIN
	BIND
	    L = LLINES [.I, 0,0,0,0] : $STR_DESCRIPTOR ();

	LOCAL
	    LEN,
	    PTR;

	LEN = .L [STR$H_LENGTH];

	!
	! Change NULLs to COMMAs (or spaces if SEPARATE)
	!
	PTR = CH$FIND_CH (.L [STR$H_LENGTH], .L [STR$A_POINTER], 0);
	IF NOT CH$FAIL (.PTR) 
	THEN 
	    BEGIN

	    IF .CMDBLK [NDX$H_LAYOUT] EQL SEPARATE
	    THEN					! If SEPARATE format
		CH$WCHAR (%C' ', .PTR)			! - replace with a blank
	    ELSE					! Otherwise:
		CH$WCHAR (%C',', .PTR);			! Replace with a comma

	    END;

	IF .CMDBLK [NDX$H_LAYOUT] EQL TWO_COLUMN
	THEN
	    BEGIN
	    !
	    ! Two column output
	    !
	    BIND
		R = R_COL_LINES [.I, 0,0,0,0] : $STR_DESCRIPTOR ();

	    !
	    ! Change NULLs to COMMAs
	    !
	    PTR = CH$FIND_CH (.R [STR$H_LENGTH], .R [STR$A_POINTER], 0);
	    IF NOT CH$FAIL (.PTR) THEN CH$WCHAR (%C',', .PTR);

	    SELECTONE .CMDBLK [NDX$H_FORMAT] OF
		SET

		[TMS11_A, TMS11_E]:
		    BEGIN
		    !
		    ! TMS11 output
		    !
		    IF .R_COL_TYPE [.I] EQL GUIDE
		    THEN
			GUIDE_HEAD (R)
		    ELSE
			RNOTMS (.R [STR$H_LENGTH], .R [STR$A_POINTER], R);

		    END;

		[TEX]:
		    BEGIN
		    !
		    ! TEX output
		    !
		    IF .R_COL_TYPE [.I] EQL GUIDE
		    THEN
			GUIDE_HEAD (R)
		    ELSE
			RNOTEX (.R [STR$H_LENGTH], .R [STR$A_POINTER], R);

		    END;

		[DSR]:
		    BEGIN
		    !
		    ! RUNOFF output
		    !
		    $STR_APPEND (STRING = R, TARGET = L);	! Concatenate right column to left

		    !
		    ! Remove trailing spaces from line
		    !
		    LEN = .L [STR$H_LENGTH];
		    PTR = CH$PLUS (.L [STR$A_POINTER], .LEN - 1);

		    DECR I FROM .L [STR$H_LENGTH] TO 2 DO
			IF CH$RCHAR (.PTR) NEQ %C' '
			THEN
			    EXITLOOP
			ELSE
			    BEGIN
			    LEN = .LEN - 1;
			    PTR = CH$PLUS (.PTR, -1);
			    END;
		    END;

		TES;

	    END;

	IF NOT ((.CMDBLK [NDX$H_LAYOUT] EQL GALLEY) AND (.LTYPE [.I] EQL FILL))
	THEN
	    BEGIN
	    !
	    ! Not doing GALLEY output
	    ! or doing galley output and line type is not FILL
	    !
	    SELECTONE .CMDBLK [NDX$H_FORMAT] OF
		SET

		[TMS11_A, TMS11_E]:
		    BEGIN
		    !
		    ! TMS11 output
		    !
		    IF .LTYPE [.I] EQL GUIDE
		    THEN
			BEGIN
			IF .CMDBLK [NDX$H_LAYOUT] EQL GALLEY THEN IDEAL = TRUE;

			GUIDE_HEAD (L);
			END
		    ELSE
			BEGIN
			IF .CMDBLK [NDX$H_LAYOUT] EQL GALLEY THEN IDEAL = FALSE;

			RNOTMS (.L [STR$H_LENGTH], .L [STR$A_POINTER], L);
			END;

		    IF .CMDBLK [NDX$H_LAYOUT] EQL TWO_COLUMN
		    THEN
			BEGIN
			!
			! Two column output - append right column to left
			!
			BIND
			    R = R_COL_LINES [.I, 0,0,0,0] : $STR_DESCRIPTOR ();

			$STR_APPEND (STRING = $STR_CONCAT ('/u/u', R), TARGET = L);
			END;

		    $STR_APPEND (STRING = TMS_LEFT, TARGET = L);
		    TMSPUT (.L [STR$H_LENGTH], .L [STR$A_POINTER], OUTIOB, .IDEAL);
		    END;

		[TEX]:
		    BEGIN
		    !
		    ! TEX output
		    !
		    IF .LTYPE [.I] EQL GUIDE
		    THEN
			GUIDE_HEAD (L)
		    ELSE
			RNOTEX (.L [STR$H_LENGTH], .L [STR$A_POINTER], L);

		    PUT_LINE ($STR_CONCAT (L, '\hfill'));
		    END;

		[DSR]:
		    !
		    ! RUNOFF output
		    !
		    PUT_LINE ((.LEN, .L [STR$A_POINTER]));	! Write the line

		TES;

	    IDEAL = FALSE;
	    END;
	END;

    IF .CMDBLK [NDX$H_LAYOUT] NEQ GALLEY
    THEN
	BEGIN
	!
	! Not doing GALLEY output
	!
	SELECTONE .CMDBLK [NDX$H_FORMAT] OF
	    SET

	    [TMS11_A, TMS11_E]:
		BEGIN
		!
		! Write page break format for TMS11
		!
		LOCAL
		    JUSTIFY;

		JUSTIFY = (IF .PAGENO THEN TMS_RIGHT ELSE TMS_LEFT);
		$STR_COPY (TARGET = TMS_TMP,
		    STRING = $STR_CONCAT (TMS_FOOT, $STR_ASCII (.PAGENO), '[fr]', .JUSTIFY, TMS_PAGE));

		TMSPUT (.TMS_TMP [STR$H_LENGTH], .TMS_TMP [STR$A_POINTER], OUTIOB, FALSE);
		END;

	    [DSR]:
		!
		! RUNOFF output
		!
		IF (NOT .LAST) THEN PUT_LINE ('.PAGE');

	    [TEX]:
		BEGIN
		!
		! TEX output
		!
		PUT_LINE ('\endcolumn');

		INCR I FROM 1 TO .ALLOWD DO
		    !
		    ! Write out right column
		    !
		    PUT_LINE ($STR_CONCAT (R_COL_LINES [.I, 0,0,0,0], '\hfill'));

		PUT_LINE ($STR_CONCAT ('\botpage {Index-', $STR_ASCII (.PAGENO), '}'));
		END;

	    TES;

	END;

    LCOUNT = 0;
    RCOUNT = 0;
    ALLOWD = .CMDBLK [NDX$G_LINES_PAGE];
    END;

%SBTTL 'VJUST_COL -- Vertical justify column'
ROUTINE VJUST_COL (COUNT, COL_LINES, COL_TYPES) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by PUTPAG to vertical justify a column.
!
! FORMAL PARAMETERS:
!
!	COUNT		- Address of column line counter
!	COL_LINES	- Address of column lines blockvector
!	COL_TYPES	- Address of column types vector
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    MAP
	COL_LINES : REF BLOCKVECTOR [, STR$K_D_BLN],
	COL_TYPES : REF VECTOR;

    BIND
	COL_COUNT = .COUNT;

    LOCAL
	N_LINES,
	INSERT_POINTS,
	INSERT_TYPE,
	LINES_PER_INSERT,
	LINES_LEFT,
	TO_LINE,
	FROM_LINE;

    !
    ! Initialization
    !
    N_LINES = 0;
    INSERT_POINTS = 0;
    INSERT_TYPE = BKT_E;
    LINES_PER_INSERT = 0;
    LINES_LEFT = 0;

    !
    ! Get number of blank lines at bottom of column
    !
    DECR I FROM .COL_COUNT TO 2 DO
	IF (.COL_TYPES [.I] NEQ BKT_E) AND (.COL_TYPES [.I] NEQ FILL)
	THEN
	    EXITLOOP
	ELSE
	    N_LINES = .N_LINES + 1;

    IF .N_LINES EQL 0 THEN RETURN;		! No justification to do

    !
    ! Get number of primary insertion points
    !
    DECR I FROM .COL_COUNT - .N_LINES TO 2 DO
	IF .COL_TYPES [.I] EQL BKT_E THEN INSERT_POINTS = .INSERT_POINTS + 1;

    IF .INSERT_POINTS EQL 0
    THEN
	BEGIN
	!
	! Get number of secondary insertion points
	!
	INSERT_TYPE = GUIDE_FILL;
	DECR I FROM .COL_COUNT - .N_LINES TO 2 DO
	    IF .COL_TYPES [.I] EQL GUIDE_FILL THEN INSERT_POINTS = .INSERT_POINTS + 1;

	IF .INSERT_POINTS EQL 0 THEN RETURN;	! No place to insert 
	END;

    LINES_PER_INSERT = .N_LINES / .INSERT_POINTS;
    LINES_LEFT = .N_LINES - (.LINES_PER_INSERT * .INSERT_POINTS);

    TO_LINE = .COL_COUNT;
    FROM_LINE = .COL_COUNT - .N_LINES;

    WHILE (.INSERT_POINTS NEQ 0) DO
	BEGIN
	IF .COL_TYPES [.FROM_LINE] EQL .INSERT_TYPE
	THEN
	    BEGIN
	    !
	    ! Insert fill line(s)
	    !
	    INCR I FROM 1 TO .LINES_PER_INSERT DO
		BEGIN
		PADLIN (4, .BLANKS, 4, COL_LINES [.TO_LINE, 0,0,0,0]);
		COL_TYPES [.TO_LINE] = FILL;
		TO_LINE = .TO_LINE - 1;
		END;

	    INSERT_POINTS = .INSERT_POINTS - 1;

	    IF .LINES_LEFT NEQ 0
	    THEN
		BEGIN
		!
		! Insert an extra line
		!
		PADLIN (4, .BLANKS, 4, COL_LINES [.TO_LINE, 0,0,0,0]);
		COL_TYPES [.TO_LINE] = FILL;
		TO_LINE = .TO_LINE - 1;
		LINES_LEFT = .LINES_LEFT - 1;
		END;

	    END;

	!
	! Insert normal line
	!
	$STR_COPY (STRING = COL_LINES [.FROM_LINE, 0,0,0,0],
	    TARGET = COL_LINES [.TO_LINE, 0,0,0,0]);

	COL_TYPES [.TO_LINE] = .COL_TYPES [.FROM_LINE];

	TO_LINE = .TO_LINE - 1;
	FROM_LINE = .FROM_LINE - 1;
	END;

    END;

%SBTTL 'LASTPG -- Write last page for RUNOFF output'
GLOBAL ROUTINE LASTPG : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to write the last page for RUNOFF
!	output. For two column output, the last page is balanced.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	ALLOWD		- Maximum number of lines allowed for page
!	LCOUNT		- Number of lines in left column
!	RCOUNT		- Number of lines in right column
!	LLINES		- Lines in left column
!	RLINES		- Lines in right column
!	CMDBLK		- Command line information block
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    IF .CMDBLK [NDX$H_LAYOUT] EQL TWO_COLUMN
    THEN
	BEGIN
	!
	! Balance last page for two column output
	!
	LOCAL
	    MIDPT,				! Used to check where left col will break
	    R_FIRST,				! First non-continuation line in right col
	    R_LAST,				! Last non-blank line in right col
	    R_TOTAL,				! Total lines in right column
	    R_BEGIN,				! First line in left col which will be in new right col
	    L_END,				! Last line in new left col
	    L_LAST;				! Last non-blank line in left col

	R_FIRST = 1;
	R_LAST = .RCOUNT;
	R_TOTAL = .R_LAST - .R_FIRST + 1;
	R_BEGIN = .LCOUNT + 1;
	L_LAST = .LCOUNT;
	L_END = .LCOUNT;

	TCOUNT = 0;				! No lines in temp column yet

	IF ((.LCOUNT + .RCOUNT + 1) / 2) LSS .ALLOWD - 1
	THEN
	    BEGIN
	    !
	    ! Page is not full enough to write it out as is.
	    !

	    DECR I FROM .LCOUNT TO 2 DO
		BEGIN
		!
		! Remove blank lines at end of left col
		!
		L_LAST = .I;
		IF (.LTYPE [.I] NEQ FILL) AND (.LTYPE [.I] NEQ BKT_E) THEN EXITLOOP;
		END;

	    IF (.RCOUNT NEQ 0)
	    THEN
		BEGIN
		!
		! More than one column of output.
		!

		IF (.RTYPE [1] EQL GUIDE) AND (.LTYPE [.L_LAST] NEQ BKT_E)
		THEN
		    BEGIN
		    !
		    ! Insert a bucket end line before the guide head
		    ! that is, at end of current left column.
		    !
		    L_LAST = .L_LAST + 1;
		    PADLIN (4, .BLANKS, 4, LLINES [.L_LAST, 0,0,0,0]);
		    LTYPE [.L_LAST] = BKT_E;
		    END;

		INCR I FROM 1 TO .RCOUNT DO
		    BEGIN
		    !
		    ! Remove continuation head if any
		    !
		    R_FIRST = .I;
		    IF .RTYPE [.I] NEQ CONT_HEAD THEN EXITLOOP;
		    END;

		DECR I FROM .RCOUNT TO .R_FIRST DO
		    BEGIN
		    !
		    ! Remove trailing blank lines
		    !
		    R_LAST = .I;
		    IF (.RTYPE [.I] NEQ FILL) AND (.RTYPE [.I] NEQ BKT_E) THEN EXITLOOP;
		    END;

		R_TOTAL = .R_LAST - .R_FIRST + 1;
		END;

	    MIDPT = (.L_LAST + .R_TOTAL + 1) / 2;

	    !
	    ! Find a good place to break the left column
	    !
	    CASE .LTYPE [.MIDPT] FROM BKT_E TO CONT_HEAD OF
	    SET

	    [BKT_E]:				! Bucket end
		BEGIN
		L_END = .MIDPT - 1;		! Previous is last left col line
		R_BEGIN = .MIDPT + 1;		! Next line is first in right col
		END;

	    [GUIDE]:				! Guide head
		BEGIN
		L_END = .MIDPT - 2;		! Line before bucket end is last in left col
		R_BEGIN = .MIDPT;		! This line starts right col.
		END;

	    [GUIDE_FILL]:			! Line after guide head
		BEGIN
		L_END = .MIDPT - 3;		! Line before bucket end is last in left col
		R_BEGIN = .MIDPT - 1;		! Guide head starts right col.
		END;

	    [ENTRY_B TO ENTRY_E]:		! Somewhere in a top level entry
		IF (.LTYPE [.MIDPT] EQL ENTRY_E)
		AND (
		    ((.LTYPE [.MIDPT + 1] NEQ SUB_B) AND (.LTYPE [.MIDPT + 1] NEQ SUB_E))
		    OR NOT .CMDBLK [NDX$V_CONTINUATION]
		    )
		THEN 
		    BEGIN
		    !
		    ! Line is the last line in a top level entry.
		    ! and either the next line is not a subindex entry
		    ! or we aren't doing continuation headings.
		    !
		    ! Use this line as the last in the column.
		    !
		    L_END = .MIDPT;
		    R_BEGIN = .MIDPT + 1;
		    IF .R_BEGIN LEQ .L_LAST
		    THEN
			IF .LTYPE [.R_BEGIN] EQL BKT_E THEN R_BEGIN = .R_BEGIN + 1;
		    END
		ELSE
		    BEGIN
		    IF .LTYPE [.MIDPT] EQL ENTRY_E THEN MIDPT = .MIDPT - 1;

		    DECR I FROM .MIDPT TO 1 DO
			BEGIN
			!
			! Find beginning of entry
			!
			L_END = .I;
			R_BEGIN = .I + 1;
			IF (.LTYPE [.I] NEQ ENTRY_B) AND (.LTYPE [.I] NEQ ENTRY_W) THEN EXITLOOP;
			END;

		    SELECTONE .LTYPE [.L_END] OF
		    SET

		    [GUIDE_FILL]:
			BEGIN
			R_BEGIN = .L_END - 1;
			L_END = .L_END - 3;
			END;

		    [BKT_E]:
			L_END = .L_END - 1;

		    [OTHERWISE]:
			;

		    TES;

		    IF ((.L_LAST - .R_BEGIN + 1) + .R_TOTAL) GTR .ALLOWD
		    THEN
			BEGIN
			!
			! Write page as is
			!
%IF %BLISS (BLISS32)
%THEN							! Signal errors for BLISS32

			SIGNAL (INDEX$_CANTBAL);

%ELSE							! Use $XPO_PUT_MSG otherwise

			$XPO_PUT_MSG (SEVERITY = WARNING,
			    STRING = 'can''t balance last page.');

%FI

			R_FIRST = 1;
			R_LAST = .RCOUNT;
			R_TOTAL = .R_LAST - .R_FIRST + 1;
			R_BEGIN = .LCOUNT + 1;
			L_LAST = .LCOUNT;
			L_END = .LCOUNT;
			END;

		    END;

	    [SUB_B TO SUB_E]:			! Subindex entry
		BEGIN
		INCR I FROM .MIDPT TO .L_LAST DO
		    BEGIN
		    !
		    ! Find end of subindex entry
		    !
		    L_END = .I;
		    IF .LTYPE [.I] EQL SUB_E THEN EXITLOOP;
		    END;

		R_BEGIN = .L_END + 1;

		IF .R_BEGIN LEQ .L_LAST
		THEN
		    CASE .LTYPE [.R_BEGIN] FROM BKT_E TO CONT_HEAD OF
		    SET

		    [BKT_E]:
			R_BEGIN = .R_BEGIN + 1;

		    [SUB_B, SUB_E]:
			IF .CMDBLK [NDX$V_CONTINUATION]
			THEN
			    BEGIN
			    !
			    ! Must generate continuation head
			    !
			    IF NOT LAST_CONT (.R_BEGIN)
			    OR ((.TCOUNT + (.L_LAST - .R_BEGIN + 1) + .R_TOTAL) GTR .ALLOWD)
			    THEN
				BEGIN
				!
				! Can't generate a continuation heading or
				! continuation heading will make right column
				! too long. - Can't balance last page
				!
%IF %BLISS (BLISS32)
%THEN							! Signal errors for BLISS32

				SIGNAL (INDEX$_CANTBAL);

%ELSE							! Use $XPO_PUT_MSG otherwise

				$XPO_PUT_MSG (SEVERITY = WARNING, STRING = 'can''t balance last page');

%FI

				TCOUNT = 0;
				R_FIRST = 1;
				R_LAST = .RCOUNT;
				R_TOTAL = .R_LAST - .R_FIRST + 1;
				R_BEGIN = .LCOUNT + 1;
				L_LAST = .LCOUNT;
				L_END = .LCOUNT;
				END;
			    END;

		    [INRANGE]:
			;

		    TES;
		END;

	    [INRANGE]:				! FILL and CONT_HEAD
		;

	    TES;
	    END;

	IF .R_BEGIN EQL 1
	THEN
	    BEGIN
	    !
	    ! All of left column is to be copied to the new right column.
	    ! This means that the left column is very short so write out
	    ! everything in the left column.
	    !
	    R_BEGIN = .LCOUNT + 1;
	    L_END = .LCOUNT;
	    L_LAST = .LCOUNT;
	    END;

	LCOUNT = .L_END;

	IF .R_BEGIN LEQ .L_LAST
	THEN
	    INCR I FROM .R_BEGIN TO .L_LAST DO
		BEGIN
		!
		! Copy remainder of left column to temp column
		!
		TCOUNT = .TCOUNT + 1;
		TTYPE [.TCOUNT] = .LTYPE [.I];
		$STR_COPY (STRING = LLINES [.I, 0,0,0,0],
		    TARGET = TLINES [.TCOUNT, 0,0,0,0]);
		END;

	IF .R_TOTAL NEQ 0
	THEN
	    INCR I FROM .R_FIRST TO .R_LAST DO
		BEGIN
		!
		! Copy remainder of right column to temp column
		!
		TCOUNT = .TCOUNT + 1;
		TTYPE [.TCOUNT] = .RTYPE [.I];
		$STR_COPY (STRING = RLINES [.I, 0,0,0,0],
		    TARGET = TLINES [.TCOUNT, 0,0,0,0]);
		END;

	IF .LCOUNT LSS .TCOUNT 
	THEN
	    BEGIN
	    !
	    ! Insert enough blank lines in left column to make columns even
	    !
	    INCR I FROM .LCOUNT + 1 TO .TCOUNT DO
		BEGIN
		LTYPE [.I] = FILL;
		PADLIN (4, .BLANKS, 4, LLINES [.I, 0,0,0,0]);
		END;

	    LCOUNT = .TCOUNT;
	    END
	ELSE
	    IF .TCOUNT LSS .LCOUNT
	    THEN
		BEGIN
		!
		! Insert enough blank lines in right column to make columns even
		!
		INCR I FROM .TCOUNT + 1 TO .LCOUNT DO
		    BEGIN
		    TTYPE [.I] = FILL;
		    PADLIN (4, .BLANKS, 4, TLINES [.I, 0,0,0,0]);
		    END;

		TCOUNT = .LCOUNT;
		END;

	END;

    ALLOWD = .LCOUNT;
    PUTPAG (TRUE);

    IF .CMDBLK [NDX$H_FORMAT] EQL DSR THEN PUT_LINE ('.RESTORE');
    END;

%SBTTL 'LAST_CONT -- Generate continuation heading for last page'
ROUTINE LAST_CONT (L_NUM) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine generates a continuation heading for the last page
!	in the temp column.
!
!	It first builds a stack of line numbers which have the index
!	levels (current - 1), (current - 2), ..., 0 as these lines are
!	the predecessors of the current line.
!
!	It then generates the continuation heading.
!
!	For each index level, the line on the stack is copied.
!
!	If the line is not a continuation head, the line is copied
!	up to either the NULL inserted by INS_LINE to delimit the
!	start of page references or the whole string is copied.
!
!	If the line is a continuation head, it is copied up to the
!	string '(Cont.)' or the whole string is copied.
!
!	The following lines will also be copied if the delimiting
!	string was not found and they are wrap lines (i.e., they
!	have an indent level equal to the current level + 2)
!
! FORMAL PARAMETERS:
!
!	L_NUM	- Index into left column pointing to line which
!		  will be the first in the new right column (i.e.,
!		  the line for which the continuation heading is generated.
!
! IMPLICIT INPUTS:
!
!	LTYPE	- vector of line types for left column
!	LLINES	- left column lines
!
! IMPLICIT OUTPUTS:
!
!	TTYPE	- vector of line types for temp column
!	TCOUNT	- number of lines in temp column
!	TLINES - temp column lines
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns TRUE if it was possible to generate a continuation heading
!	Returns FALSE if it was impossible to generate a continuation heading
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    LOCAL
	CONT,
	CONT_INT_LEN,
	CONT_EXT_LEN,
	MAX_EXT,
	CUR_INDENT,
	CUR_LINE,
	INDENT;

    INDENT = INDENT_LEVEL (LLINES [.L_NUM, 0,0,0,0]) - 1;

    IF .INDENT LSS 0
    THEN
	BEGIN
	!
	! The input line was blank.
	! This can happen if the column width was too narrow to fit
	! the entry into. Usually this is caused by a combination of
	! a narrow column width and a deep subindex level.
	!
%IF %BLISS (BLISS32)
%THEN

	SIGNAL (INDEX$_LASTCONT);

%ELSE

	$XPO_PUT_MSG (SEVERITY = WARNING, 
	    STRING = 'can''t generate continuation heading on last page');

%FI
	RETURN FALSE;
	END;

    CONT = CH$PTR (UPLIT ('(Cont_.)'));
    CONT_INT_LEN = 8;				! Internal length of '(Cont_.)'

    IF .CMDBLK [NDX$H_FORMAT] NEQ DSR
    THEN
	BEGIN
	!
	! TMS11 output
	! Compute length of '(Cont.)' in TMS units
	! Set maximum line length in TMS units
	!
	LOCAL
	    PTR;

	CONT_EXT_LEN = 0;
	PTR = .CONT;

	INCR I FROM 1 TO .CONT_INT_LEN DO
	    BEGIN

	    LOCAL
		CH;

	    CH = CH$RCHAR_A (PTR);

	    IF .CH NEQ %C'_' THEN CONT_EXT_LEN = .CONT_EXT_LEN + .CHRSIZ [.CH];
	    END;

	MAX_EXT = .CMDBLK [NDX$G_COLUMN_WID] * TMSSTD;
	END
    ELSE
	BEGIN
	!
	! RUNOFF output
	! Length of '(Cont.)' and maximum line length are in characters
	!
	CONT_EXT_LEN = 7;
	MAX_EXT = .CMDBLK [NDX$G_COLUMN_WID];
	END;

    CUR_INDENT = .INDENT;
    CUR_LINE = .L_NUM - 1;

    WHILE (.CUR_INDENT GEQ 0) AND (.CUR_LINE GTR 0) DO
	BEGIN
	!
	! Build a stack of entry lines at the correct indent level
	!
	IF (.CUR_INDENT EQL INDENT_LEVEL (LLINES [.CUR_LINE, 0,0,0,0]))
	AND (.LTYPE [.CUR_LINE] GEQ ENTRY_B)
	THEN
	    BEGIN
	    !
	    ! Found preceeding subentry
	    !
	    LSTSTK [.CUR_INDENT] = .CUR_LINE;
	    CUR_INDENT = .CUR_INDENT - 1;
	    END;

	CUR_LINE = .CUR_LINE - 1;
	END;

    IF (.CUR_LINE EQL 0) AND (.CUR_INDENT GEQ 0)
    THEN
	BEGIN
	!
	! An internal inconsistancy prevented finding the predecessors
	! of the current line. This error is non-fatal: the last page
	! will be output as is.
	!

%IF %BLISS (BLISS32)
%THEN							! Signal errors for BLISS32

	SIGNAL (INDEX$_LASTCONT, 0, INDEX$_BADLOGIC);

%ELSE							! Use $XPO_PUT_MSG otherwise

	$XPO_PUT_MSG (SEVERITY = WARNING,
	    STRING = 'internal error - cannot generate continuation heading on last page');

%FI
	RETURN FALSE;
	END;

    INCR I FROM 0 TO .INDENT DO
	BEGIN
	LOCAL
	    S : REF $STR_DESCRIPTOR (),
	    LINE_NO;

	LINE_NO = .LSTSTK [.I];

	WHILE .LINE_NO NEQ 0 DO
	    BEGIN
	    LOCAL
		PTR,
		LEN;

	    S = LLINES [.LINE_NO, 0,0,0,0];

	    IF .LTYPE [.LINE_NO] EQL CONT_HEAD
	    THEN
		!
		! Picked up a continuation heading
		!
		PTR = CH$FIND_SUB (.S [STR$H_LENGTH], .S [STR$A_POINTER], 8, .CONT)
	    ELSE
		!
		! Line not a continuation head
		!
		PTR = CH$FIND_CH (.S [STR$H_LENGTH], .S [STR$A_POINTER], 0);

	    IF CH$FAIL (.PTR)
	    THEN
		BEGIN
		!
		! Delimiter not found
		!
		LEN = .S [STR$H_LENGTH]; 
		IF INDENT_LEVEL (LLINES [.LINE_NO + 1, 0,0,0,0]) EQL .I + 2
		THEN
		    !
		    ! Line is wrapped to next
		    !
		    LINE_NO = .LINE_NO + 1
		ELSE
		    !
		    ! Line not wrapped to next
		    !
		    LINE_NO = 0;
		END
	    ELSE
		BEGIN
		!
		! Delimiter found
		!
		LEN = CH$DIFF (.PTR, .S [STR$A_POINTER]);

		!
		! Signal no more lines at this level
		!
		LINE_NO = 0;
		END;

	    !
	    ! Point to beginning of string
	    !
	    PTR = .S [STR$A_POINTER];

	    IF CH$NEQ (1, .BLANKS, .LEN, .PTR, %C' ')
	    THEN
		BEGIN
		!
		! Line is non-blank.
		!
		DECR I FROM .LEN - 1 TO 0 DO
		    IF CH$RCHAR (CH$PLUS (.PTR, .I)) NEQ %C' '
		    THEN
			EXITLOOP
		    ELSE
			!
			! Remove a trailing blank
			!
			LEN = .LEN - 1;

		!
		! Bump line count, set line type and copy line
		!
		TCOUNT = .TCOUNT + 1;
		$STR_COPY (STRING = (.LEN, .PTR), TARGET = TLINES [.TCOUNT, 0,0,0,0]);
		TTYPE [.TCOUNT] = CONT_HEAD;
		END;
	    END;
	END;


    IF (GET_EXT_LEN (TLINES [.TCOUNT, 0,0,0,0]) + .CONT_EXT_LEN) GEQ .MAX_EXT
    THEN
	BEGIN
	!
	! '(Cont.)' doesn't fit on current line.
	! See if it will fit on next line.
	!
	IF  (
	    (.CMDBLK [NDX$H_FORMAT] NEQ DSR)
	    AND ((.INDENT + 2) * MSPACE + .CONT_EXT_LEN GEQ .MAX_EXT)
	    )
	OR  (
	    (.CMDBLK [NDX$H_FORMAT] EQL DSR) 
	    AND ((.INDENT + 2) * 2 + .CONT_EXT_LEN GEQ .MAX_EXT)
	    )
	THEN
	    BEGIN
	    !
	    ! Can't put '(Cont.)' on new line - hence can't generate a
	    ! continuation heading.
	    !
%IF %BLISS (BLISS32)
%THEN						! Signal errors in BLISS32

	    SIGNAL (INDEX$_LASTCONT, 0, INDEX$_DOESNTFIT, 2, .CONT_INT_LEN, .CONT);

%ELSE						! Use $XPO_PUT_MSG otherwise

	    $XPO_PUT_MSG (SEVERITY = WARNING,
		STRING = 'can''t generate continuation heading on last page');

%FI
	    RETURN FALSE;
	    END
	ELSE
	    BEGIN
	    !
	    ! Indent a new line and append '(Cont.)' to it.
	    !
	    LOCAL
		LINE : VECTOR [CH$ALLOCATION (200)],
		PTR,
		LEN;

	    PTR = CH$PTR (LINE);
	    LEN = (.INDENT + 2) * 2 - 1;
	    CH$FILL (%C' ', .LEN, .PTR);

	    TCOUNT = .TCOUNT + 1;
	    $STR_COPY (STRING = (.LEN, .PTR), TARGET = TLINES [.TCOUNT, 0,0,0,0]);
	    TTYPE [.TCOUNT] = CONT_HEAD;
	    END;
	END;

    $STR_APPEND (STRING = $STR_CONCAT ((1, .BLANKS), (.CONT_INT_LEN, .CONT)),
	TARGET = TLINES [.TCOUNT, 0,0,0,0]);

    RETURN TRUE;
    END;

%SBTTL 'GET_EXT_LEN - Get external length of line'
ROUTINE GET_EXT_LEN (DSC) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns the external length of a line in either
!	number of characters or in TMS relative units
!
! FORMAL PARAMETERS:
!
!	DSC	- Address of string descriptor of line
!
! IMPLICIT INPUTS:
!
!	CHRSIZ	- TMS character size vector
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns external length of line
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    MAP
	DSC : REF $STR_DESCRIPTOR ();

    LOCAL
	PTR,
	EXT_LEN;

    PTR = .DSC [STR$A_POINTER];
    EXT_LEN = 0;

    INCR I FROM 1 TO .DSC [STR$H_LENGTH] DO
	BEGIN
	LOCAL
	    CH;

	CH = CH$RCHAR_A (PTR);

	SELECTONE .CH OF
	SET

	[%C'*']:
	    !
	    ! Bold sequence. Doesn't add to external length.
	    !
	    ;


	[%C'&']:
	    !
	    ! Underline sequence. Doesn't add to external length
	    ;

	[%C'%']:
	    BEGIN
	    !
	    ! Overstrike sequence.
	    ! Next character doesn't count either.
	    !
	    CH$RCHAR_A (PTR);
	    I = .I + 1;
	    END;

	[OTHERWISE]:
	    BEGIN
	    !
	    ! An ordinary character.
	    !
	    IF .CH EQL %C'_'
	    THEN
		BEGIN
		!
		! Quote sequence doesn't count
		!
		CH$RCHAR_A (PTR);
		I = .I + 1;
		END;

	    IF .CMDBLK [NDX$H_FORMAT] NEQ DSR
	    THEN
		!
		! For TMS, use relative character size table
		!
		EXT_LEN = .EXT_LEN + .CHRSIZ [.CH]
	    ELSE
		!
		! For RUNOFF, just count a character
		!
		EXT_LEN = .EXT_LEN + 1;
	    END;

	TES;
	END;

    RETURN .EXT_LEN;
    END;


%SBTTL 'INDENT_LEVEL - Get indent level of string'
ROUTINE INDENT_LEVEL (DSC) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine computes the indent level of a line
!
!	The indent level is equal to 1/2 the number of 
!	leading spaces on the line.
!
!	If the line is blank or begins with a tab, the indent level is -1.
!
!	The number of leading spaces is found by taking the
!	difference of a pointer to the first non-blank character
!	and a pointer to the beginning of the line.
!
! FORMAL PARAMETERS:
!
!	DSC - Address of string descriptor describing the line
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns the indent level of the input line
!	Returns -1 if the line is blank or if the line begins with a tab.
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    MAP
	DSC : REF $STR_DESCRIPTOR ();

    LOCAL
	LEN,
	PTR;

    LEN = .DSC [STR$H_LENGTH];
    PTR = .DSC [STR$A_POINTER];

    IF CH$EQL (1, CH$PTR (UPLIT (' ')), .LEN, .PTR, %C' ')
    THEN
	!
	! Blank line.
	!
	RETURN -1
    ELSE
	!
	! Non-blank line
	!
	IF CH$EQL (1, CH$PTR (UPLIT ('	')), 1, .PTR)
	THEN
	    !
	    ! Line begins with a tab
	    !
	    RETURN -1
	ELSE
	    !
	    ! Compute indent level 
	    !
	    RETURN CH$DIFF (CH$FIND_NOT_CH (.LEN, .PTR, %C' '), .PTR) / 2;

    END;

%SBTTL 'GUIDE_HEAD -- Build a guide head for TMS11 or TEX'
ROUTINE GUIDE_HEAD (DSC) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine inserts the format strings into a guide heading
!
! FORMAL PARAMETERS:
!
!	DSC - Address of guide head string
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    IF .CMDBLK [NDX$H_FORMAT] NEQ TEX
    THEN
	!
	! TMS11 output
	!
	$STR_COPY (STRING = $STR_CONCAT (TMS_GUIDE, .DSC, TMS_TXT_FMT), TARGET = TMS_TMP)
    ELSE
	!
	! TEX output
	!
	$STR_COPY (STRING = $STR_CONCAT ('{\gh ', .DSC, '}'), TARGET = TMS_TMP);

    $STR_COPY (STRING = TMS_TMP, TARGET = .DSC);
    END;

%SBTTL 'TMSINI -- Generate TMS11 top of file string'
GLOBAL ROUTINE TMSINI : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine generates and outputs the top of file sequence for
!	TMS11 output files
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	CMDBLK		- Command line information block
!	TMSCOL		- Default TMS column width
!
! IMPLICIT OUTPUTS:
!
!	TMS_TMP		- Modified
!	TMSTOF 		- Contains top-of-file string
!	TMSSIZ 		- Ideal file size in blocks
!	TMS_TXT_FMT	- Text format markup (different for /TMS=A and /TMS=E)
!	TMS_FOOT	- Page footer markup (different for /TMS=A and /TMS=E)
!	TMS_PAGE	- New page markup (different for /TMS=A and /TMS=E)
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    LOCAL
	C,
	TS;

    IF .CMDBLK [NDX$H_FORMAT] EQL TMS11_A
    THEN
	BEGIN
	!
	! User specified /TMS11=A
	!
	$STR_COPY (TARGET = TMSTOF, STRING = '*start**text*');
	$STR_COPY (TARGET = TMS_TXT_FMT, STRING = '[f1p10]');
	$STR_COPY (TARGET = TMS_FOOT, STRING = '[va36][fb]Index+n');

	IF .CMDBLK [NDX$V_TELLTALE]
	THEN
	    $STR_COPY (TARGET = TMS_PAGE, STRING = '[va50]/_/l')
	ELSE
	    $STR_COPY (TARGET = TMS_PAGE, STRING = '[va50]/_/l[va50]');

	END
    ELSE
	BEGIN
	!
	! Initialize for /TMS11=E
	!
	$STR_COPY (TARGET = TMSTOF, STRING = '*start2**etext*');
	$STR_COPY (TARGET = TMS_TXT_FMT, STRING = '[f13p10]');
	$STR_COPY (TARGET = TMS_FOOT, STRING = '[va36][p11][fb]Index+n');

	IF .CMDBLK [NDX$V_TELLTALE]
	THEN
	    $STR_COPY (TARGET = TMS_PAGE, STRING = '[p10][va50]/_/l')
	ELSE
	    $STR_COPY (TARGET = TMS_PAGE, STRING = '[p10][va50]/_/l[va50]');

	END;

    !
    ! Write the version number
    !
    $STR_COPY (TARGET = TMS_TMP,
	STRING = $STR_CONCAT ('< INDEX version ', (.NDXVRL, .NDXVRP), ' >'));
    TMSPUT (.TMS_TMP [STR$H_LENGTH], .TMS_TMP [STR$A_POINTER], OUTIOB, FALSE);

    !
    ! Write the command line 
    !
    $STR_COPY (STRING = $STR_CONCAT ('< ', CMDBLK [NDX$T_COMMAND_LINE], ' >'), TARGET = TMS_TMP);
    TMSPUT (.TMS_TMP [STR$H_LENGTH], .TMS_TMP [STR$A_POINTER], OUTIOB, FALSE);

    !
    ! Compute tab stop
    !
    TS = .CMDBLK [NDX$G_COLUMN_WID] * 18;
    TS = (IF (.TS MOD TMSCOL) NEQ 0 THEN 1 ELSE 0) + (.TS / TMSCOL);

    !
    ! Compute column width and ideal file size
    !
    SELECTONE .CMDBLK [NDX$H_LAYOUT] OF
    SET

    [TWO_COLUMN]:
	BEGIN
	C = .CMDBLK [NDX$G_COLUMN_WID] * 2;

	TMSSIZ = 40;				! Ideal size is 40 blocks for TWO_COLUMN output
	END;

    [SEPARATE]:
	BEGIN
	C = .CMDBLK [NDX$G_COLUMN_WID] + .CMDBLK [NDX$G_SEPARATE_WIDTH];

	TMSSIZ = 25;				! Ideal size is 25 blocks for SEPARATE MASTER format
	END;

    [OTHERWISE]:
	BEGIN
	C = .CMDBLK [NDX$G_COLUMN_WID];

	TMSSIZ = 20;				! Ideal size is 20 blocks for ONE_COLUMN or GALLEY formats
	END;

    TES;

    C = (IF (.C MOD TMSCOL) NEQ 0 THEN 1 ELSE 0) 
	+ (.C * 18 / TMSCOL) + .CMDBLK [NDX$G_GUTTER_WID];

    !
    ! Build top of file string and write it out
    !
    $STR_APPEND (TARGET = TMSTOF,
	STRING = $STR_CONCAT ('[v12c', $STR_ASCII (.C), 'ts', 
	    $STR_ASCII (.TS), ',', $STR_ASCII (.TS + .CMDBLK [NDX$G_GUTTER_WID]),
	    ']', TMS_TXT_FMT));

    TMSPUT (.TMSTOF [STR$H_LENGTH], .TMSTOF [STR$A_POINTER], OUTIOB, FALSE);
    TMSPUT (1, .BLANKS, OUTIOB, FALSE);

    !
    ! Put out title 
    !
    $STR_COPY (STRING = $STR_CONCAT (TMS_TITLE, TMS_TXT_FMT), TARGET = TMS_TMP);
    TMSPUT (.TMS_TMP [STR$H_LENGTH], .TMS_TMP [STR$A_POINTER], OUTIOB, FALSE);

    END;

%SBTTL 'TELLTALE_HEAD -- Generate and output a telltale heading'
ROUTINE TELLTALE_HEAD : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine generates and outputs a telltale heading.
!
!	No heading is generated for the first page.
!	All emphasis except overstriking is removed from the heading string.
!	If generating a heading for RUNOFF, each character is bolded.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	PAGENO		- Page number
!	RLINES [0, ...]	- Right telltale
!	RTYPE [0]	- Right telltale line type
!	LLINES [0, ...]	- Left telltale
!	LTYPE [0]	- Left telltale line type
!	CMDBLK		- Command line information block
!
! IMPLICIT OUTPUTS:
!
!	The telltale heading is written to the output file if not page 1.
!
!	LLINES [0, ...]	- Set to right telltale string if generating a right
!			  telltale heading.
!	LTYPE [0]	- Set to right telltale line type if generating a
!			  right telltale heading.
!	RLINES [0, ...]	- Right telltale is set to the null string if a right
!			  telltale was generated.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    LOCAL
	T_PTR,
	I_PTR,
	I_LEN,
	O_PTR,
	O_LEN,
	O_BUF : VECTOR [CH$ALLOCATION (1024)];

    BIND
	STR = LLINES [0, 0,0,0,0] : $STR_DESCRIPTOR ();

    IF .PAGENO
    THEN
	BEGIN
	!
	! Odd numbered page. 
	! Save the right telltale as the left telltale and
	! set the right telltale to the null string.
	!
	$STR_COPY (STRING = RLINES [0, 0,0,0,0], TARGET = LLINES [0, 0,0,0,0]);
	LTYPE [0] = .RTYPE [0];
	$STR_COPY (STRING = '', TARGET = RLINES [0, 0,0,0,0]);
	END;

    !
    ! If this is page 1, do nothing; just return.
    !
    IF .PAGENO EQL 1 THEN RETURN;

    !
    ! Initialize pointers to input and output strings and string lengths.
    !
    I_PTR = .STR [STR$A_POINTER];
    I_LEN = .STR [STR$H_LENGTH];
    O_LEN = 0;
    O_PTR = CH$PTR (O_BUF);

    IF .LTYPE [0] EQL CONT_HEAD
    THEN
	BEGIN
	!
	! Line was a continuation heading. Search for '(Cont_.)'
	!
	T_PTR = CH$FIND_SUB (.I_LEN, .I_PTR, 8, CH$PTR (UPLIT ('(Cont_.)')));
	END
    ELSE
	BEGIN
	!
	! Line was an index entry. Search for the NULL which delimits the 
	! start of the page references (if any).
	!
	T_PTR = CH$FIND_CH (.I_LEN, .I_PTR, 0);
	END;

    IF NOT CH$FAIL (.T_PTR)
    THEN
	BEGIN
	!
	! There are either page references or '(Cont_.)' on the line which
	! should be ignored.
	!
	I_LEN = CH$DIFF (.T_PTR, .I_PTR);
	END;

    WHILE .I_LEN GTR 0 DO
	BEGIN
	!
	! Copy the line removing all emphasis except overstriking.
	! If generating RUNOFF output, bold each character.
	!
	LOCAL
	    CH;

	CH = CH$RCHAR_A (I_PTR);
	I_LEN = .I_LEN - 1;

	SELECTONE .CH OF
	    SET

	    [%C'*', %C'&']:
		!
		! Bold or underline. Ignore it.
		!
		;

	    [%C'_']:
		BEGIN
		!
		! Accept flag. Write it and the next character out.
		!
		IF .CMDBLK [NDX$H_FORMAT] EQL DSR
		THEN
		    BEGIN
		    !
		    ! Bold the character
		    !
		    CH$WCHAR_A (%C'*', O_PTR);
		    O_LEN = .O_LEN + 1;
		    END;

		CH$WCHAR_A (.CH, O_PTR);
		CH$WCHAR_A (CH$RCHAR_A (I_PTR), O_PTR);
		I_LEN = .I_LEN - 1;
		O_LEN = .O_LEN + 2;
		END;

	    [%C'%']:
		BEGIN
		!
		! Overstrike flag. Just write it out.
		!
		CH$WCHAR_A (.CH, O_PTR);		! Write overstrike flag
		O_LEN = .O_LEN + 1;
		END;

	    [OTHERWISE]:
		BEGIN
		!
		! A normal character. 
		!
		IF .CMDBLK [NDX$H_FORMAT] EQL DSR
		THEN
		    BEGIN
		    !
		    ! Bold the character
		    !
		    CH$WCHAR_A (%C'*', O_PTR);
		    O_LEN = .O_LEN + 1;
		    END;

		CH$WCHAR_A (.CH, O_PTR);
		O_LEN = .O_LEN + 1;
		END;

	    TES;

	END;

    O_PTR = CH$PTR (O_BUF);

    SELECTONE .CMDBLK [NDX$H_FORMAT] OF
	SET

	[DSR]:
	    PUT_LINE ($STR_CONCAT ('.SUBTITLE ', (.O_LEN, .O_PTR)));

	[TMS11_A, TMS11_E]:
	    BEGIN
	    !
	    ! Write telltale for /TMS
	    !
	    RNOTMS (.O_LEN, .O_PTR, TMS_TMP);	! Convert special characters

	    IF .PAGENO
	    THEN				! Odd page - right telltale
		$STR_APPEND (STRING = TMS_RIGHT, TARGET = TMS_TMP)
	    ELSE				! Even page - left telltale
		$STR_APPEND (STRING = TMS_LEFT, TARGET = TMS_TMP);

	    IF .CMDBLK [NDX$H_FORMAT] EQL TMS11_A
	    THEN
		$STR_COPY (STRING = '*telltale*', TARGET = TMS_TELLTALE)
	    ELSE
		$STR_COPY (STRING = '*etelltale*', TARGET = TMS_TELLTALE);

	    $STR_APPEND (STRING = $STR_CONCAT (TMS_TMP, '@'), TARGET = TMS_TELLTALE);
	    TMSPUT (.TMS_TELLTALE [STR$H_LENGTH], .TMS_TELLTALE [STR$A_POINTER], OUTIOB, TRUE);
	    END;

	[TEX]:
	    BEGIN
	    !
	    ! Write telltale for TEX
	    !
	    RNOTEX (.O_LEN, .O_PTR, TMS_TMP);

	    IF .PAGENO 
	    THEN 
		BEGIN
		!
		! Odd page, telltale is flush right
		!
		$STR_COPY (TARGET = TMS_TELLTALE,
		    STRING = $STR_CONCAT ('\telltale{\hfill ', TMS_TMP, '}'));

		END
	    ELSE
		BEGIN
		!
		! Even page, telltale is flush left
		!
		$STR_COPY (TARGET = TMS_TELLTALE,
		    STRING = $STR_CONCAT ('\telltale{', TMS_TMP, '\hfill }'));

		END;

	    PUT_LINE (TMS_TELLTALE);
	    END;

	TES;

    END;

END				! End of module
ELUDOM
