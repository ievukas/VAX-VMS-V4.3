.title	TECONAT	VAX-11 TECO
.ident	/V39.02/

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

.show	meb
.sbttl	VAX-11 TECO

; last edit on 25-Jan-1984 by Mark Bramhall

.sbttl	General macros

.macro	unorg
.endm	unorg

.macro	org	sect, offset
.macro	unorg
.noshow	meb
.psect	sect
.show	meb
.endm	unorg
	tmporg	sect, <offset>
.endm	org

.macro	deforg	sect
	org	sect
.if	ne	.-sect
.error	; DEFORG not a beginning of "sect"
.endc	; ne	.-sect
.endm	deforg

.macro	tmporg	sect, offset
.noshow	meb
.psect	sect
.	=	.
.if	ndf	sect
sect:
.endc	; ndf	sect
.if	nb	<offset>
.	=	offset+sect
.endc	; nb	<offset>
.show	meb
.endm	tmporg

.macro	.dsect	start=0
.noshow	meb
$$$$$$	=	start
.psect	..abs.., nopic,usr,ovr,abs,lcl,noshr,noexe,nord,nowrt
.if	ndf	..abs..
..abs..:
.endc	; ndf	..abs..
.	=	$$$$$$+..abs..
.show	meb
.endm	.dsect

.macro	.bsect	bit=0
.dsect	<1@<bit>>
.endm	.bsect

.macro	.mvsect	prefix, suffix, bit=0
.macro	.mvdef	sym
.if	nb	<sym>
prefix'$v_'suffix''sym:	.blkb
.bsect	prefix'$v_'suffix''sym
prefix'$m_'suffix''sym:	.blkb	.
.dsect	prefix'$v_'suffix''sym+1
.iff	; nb	<sym>
		.blkb
.endc	; nb	<sym>
.endm	.mvdef
.dsect	<bit>
.endm	.mvsect

.macro	.equate	symbol, value
.dsect	<value>
symbol:
	unorg
.endm	.equate

.macro	.assume	arg1, cond, arg2
.if	cond	<arg1>-<arg2>
.iff	; cond	<arg1>-<arg2>
.error	; "arg1 cond arg2" fails
.endc	; cond	<arg1>-<arg2>
.endm	.assume

.macro	.desc	tag, amt=63
.noshow	meb
$$$$$$	=	.+8
.align	quad
.if	ne	.+8-$$$$$$
.warn	; not quadword aligned
.	=	$$$$$$-8
.endc	; ne	.+8-$$$$$$
.show	meb
.if	nb	<tag>
tag'_buf =	$$$$$$
tag'_siz =	amt
	 .long	tag'_siz
	 .long	tag'_buf
.iff	; nb	<tag>
	 .long	amt
	 .long	$$$$$$
.endc	; nb	<tag>
.assume	.	eq	$$$$$$
	  .blkb	amt
.noshow	meb
.align	quad
.show	meb
.endm	.desc

.macro	bc	bit, dst, ?tag
.if	idn	<%extract(0,1,bit)>,<#>
.if	le	<1@%extract(1,3000,bit)>-63
	 bicb	s^#1@%extract(1,3000,bit), dst
.mexit
.endc	; le	<1@%extract(1,3000,bit)>-63
.endc	; idn	<%extract(0,1,bit)>,<#>
	 bbsc	bit, dst, tag
tag:
.endm	bc

.macro	bs	bit, dst, ?tag
.if	idn	<%extract(0,1,bit)>,<#>
.if	le	<1@%extract(1,3000,bit)>-63
	 bisb	s^#1@%extract(1,3000,bit), dst
.mexit
.endc	; le	<1@%extract(1,3000,bit)>-63
.endc	; idn	<%extract(0,1,bit)>,<#>
	 bbcs	bit, dst, tag
tag:
.endm	bs

.macro	getdesc	tag, reg, mode=w
	 movab	mode^tag'_buf, reg
	 movl	reg, -(reg)
.assume	tag+8	eq	tag'_buf
	 movzwl	#tag'_siz, -(reg)
.endm	getdesc

.sbttl	System definitions

.noshow	meb

	$clidef				; cli defs
	$dscdef				; string descriptor defs
	$dvidef				; get device information defs
	$jpidef				; get job/process information defs
	$libclidef			; cli defs
	$psldef				; processor status longword defs
	$stsdef				; status code definitions
	$ttdef				; terminal modes/characteristics defs
	$tt2def				; terminal modes/characteristics defs

.show	meb

;+
; Entry to compatibility mode exception handler with:
;
;	-32(r0) =  saved r0		(ctl$al_cmcntx)
;	-28(r0) =  saved r1
;	-24(r0) =  saved r2
;	-20(r0) =  saved r3
;	-16(r0) =  saved r4
;	-12(r0) =  saved r5
;	-08(r0) =  saved r6 (compatibility sp)
;	-04(r0) =  exception code
;	 00(r0) =  saved exception pc
;	 04(r0) =  saved exception psl (compatibility ps)
;
; Exception codes are:
;
;	0 = reserved instruction
;	1 = bpt
;	2 = iot
;	3 = emt
;	4 = trap
;	5 = illegal instruction
;	6 = odd address
;	7 = t-bit
;-

.dsect					; ctl$al_cmcntx data storage offsets

i_r0:		.blkl			; saved r0
i_r1:		.blkl			; saved r1
i_r2:		.blkl			; saved r2
i_r3:		.blkl			; saved r3
i_r4:		.blkl			; saved r4
i_r5:		.blkl			; saved r5
i_sp:		.blkl			; saved r6 (compatibility sp)
i_code:		.blkl			; saved exception code
i_pc:		.blkl			; saved pc
i_ps:		.blkl			; saved psl (compatibility ps)

.equate	i_bias, i_pc-i_r0		; bias from ctl$al_cmcntx to entry r0

.sbttl	Internal macros

.macro	rad50	code
$$$$$$	=	0
.irpc	char, <code>
$$$$$$	=	<$$$$$$*40>+<^a/char/-64>
.endr	; char, <code>
.endm	rad50

.macro	err	code, text
	 bsbw	err
	tmporg	tecodat
$$$$$$	=	.
	unorg
	  .long	$$$$$$
	tmporg	tecodat
rad50	<code>
	   .word  $$$$$$
	   .ascic text
	unorg
.endm	err

.sbttl	"ET" (edit typeout) bits

.mvsect	tec, et$

.mvdef	bin		;    +1., output in binary (image) mode
.mvdef	crt		;    +2., do scope type rubout and control/u
.mvdef	lc		;    +4., accept lower case input
.mvdef	nch		;    +8., no echo during input for ctrl/t
.mvdef	cco		;   +16., cancel control/o on output
.mvdef	cke		;   +32., return -1 if error/no input on ctrl/t
.mvdef	det		;   +64., detach and detached flag
.mvdef	xit		;  +128., "no prompt yet" flag
.mvdef	tru		;  +256., truncate long output lines
.mvdef	ias		;  +512., interactive scope available for "watch"
.mvdef	rfs		; +1024., refresh scope available for "watch"
.mvdef			; +2048., reserved by TECO-8
.mvdef	8bt		; +4096., terminal is an 8-bit terminal
.mvdef	grv		; +8192., accept "`" as escape during command input
.mvdef			;+16384., unused
.mvdef	cc		;-32768., allow program to trap control/c

.sbttl	"ED" (edit mode) bits

.mvsect	tec, ed$

.mvdef	ctl		;    +1., don't allow "^" as meaning control character
.mvdef	ynk		;    +2., allow yanks, etc. to clobber text buffer
.mvdef	exp		;    +4., don't allow arbitrary expansion(s)
.mvdef			;    +8., reserved by TECO-8
.mvdef	srh		;   +16., don't reset "dot" on search failure
.mvdef	imd		;   +32., allow immediate mode commands
.mvdef	inc		;   +64., only move "dot" by one on iterative search failures
.mvdef	wch		;  +128., don't do automatic "w" command before prompt
.mvdef			;  +256., unused
.mvdef			;  +512., unused
.mvdef			; +1024., unused
.mvdef			; +2048., unused
.mvdef			; +4096., unused
.mvdef			; +8192., unused
.mvdef			;+16384., unused
.mvdef			;+32768., unused

.sbttl	Internal definitions

.dsect	tt$_vt05			; define vt05's...
t$vt05::				; ... for compatibility mode

.dsect	tt2$m_edit@-16			; define 'edit' functions...
t$edit::				; ... for compatibility mode
.assume	t$edit	ne	0

.dsect	tt2$m_deccrt@-16		; define 'dec crt'...
t$dec::					; ... for compatibility mode
.assume	t$dec	ne	0

.dsect	tt2$m_ansicrt@-16		; define 'ansi crt'...
t$ansi::				; ... for compatibility mode
.assume	t$ansi	ne	0

.equate	initial_siz,	5000		; initial text & q-reg size

.equate	ter_i_siz,	 512		; terminal input buffer size

.equate	ter_o_siz,	 512		; terminal output buffer size

.equate	input_nor_siz,	2048		; normal input record buffer size

.equate	indir_cmd_siz,	2048		; "ei" record buffer size

.equate	input_alt_siz,	2048		; alternate input record buffer size

.equate	output_sys_siz,	 512		; sys$output output record buffer size

.equate	input_vfc_siz,	  12		; vfc input buffer size

.mvsect	fab, tec			; definitions for fab$l_tecsts

.mvdef	eof				; at end-of-file
.mvdef	no1st				; not first time through
.mvdef	buf				; use buffered data instead of file
.mvdef	icr				; <cr> ignored, need <cr><lf> on eof
.mvdef	ecr				; extra <cr> output, do <lf> next
.mvdef	nxt				; pre-fetched character exists (@ +3)
.mvdef	fmt				; /-cr, /cr, or /ft specified
.mvdef	rw				; /rw - rewind magtape before opens
.mvdef	sh				; /sh - shared open
.mvdef	b2				; /b2 - basic-plus-2 mode
.mvdef	nv				; /nv - always create a new version
.mvdef	stm				; /stm - stream format specified
.mvdef	var				; /var - variable format specified
.mvdef					; unused...
.mvdef					; unused...
.mvdef					; unused...

.assume	.	eq	16

.sbttl	.PSECT definitions

.psect	tecodat,	page,nopic,usr,con,rel,lcl,  shr,noexe,rd,nowrt
	deforg	tecodat
.psect	tecodatini,	page,nopic,usr,con,rel,lcl,  shr,noexe,rd,nowrt
	deforg	tecodatini

.psect	tecobuf,	page,nopic,usr,con,rel,lcl,noshr,noexe,rd,  wrt
	deforg	tecobuf
.psect	tecoctl,	page,nopic,usr,con,rel,lcl,noshr,noexe,rd,  wrt
	deforg	tecoctl
.psect	tecoctlini,	page,nopic,usr,con,rel,lcl,noshr,noexe,rd,  wrt
	deforg	tecoctlini

.psect	tecoexe,	page,nopic,usr,con,rel,lcl,  shr,  exe,rd,nowrt
	deforg	tecoexe
.psect	tecoexelbr,	page,nopic,usr,ovr,rel,gbl,  shr,  exe,rd,nowrt
	deforg	tecoexelbr
.psect	tecoexeini,	page,nopic,usr,con,rel,lcl,  shr,  exe,rd,nowrt
	deforg	tecoexeini

.sbttl	Pure data

	org	tecodat

.align	page

ter_o_table:				; terminal output translate 'til table
.rept	256
.if	eq	<<.-ter_o_table>&127>-27
	.byte	27
.iff	; eq	<<.-ter_o_table>&127>-27
	.byte	.-ter_o_table
.endc	; eq	<<.-ter_o_table>&127>-27
.endr

file_spec_table:			; file spec buffer translate 'til table
.rept	256
$$$$$$	=	.-file_spec_table
.iif	eq	$$$$$$-  0,	$$$$$$ = 0
.iif	eq	$$$$$$-128,	$$$$$$ = 0
.iif	eq	$$$$$$-255,	$$$$$$ = 0
.if	gt	$$$$$$-< 0+128>
.if	lt	$$$$$$-<32+128>
$$$$$$	=	$$$$$$&127
.endc	; lt	$$$$$$-<32+128>
.endc	; gt	$$$$$$-< 0+128>
	.byte	$$$$$$
.endr

.align	quad

ter_i_nor7_trm:				; normal 7-bit terminator mask
	.long	20$-10$
	.long	10$

10$:	.long	^c<	<1@8>! -	; all  of   0- 31 except bs,
			<1@9>! -	;			 tab,
			<1@10>! -	;			 lf,
			<1@11>! -	;			 vt,
			<1@12>>		;			 ff
	.long	0			; none of  32- 63
	.long	0			; none of  64- 95
	.long	<	<1@<96-96>>! -	; none of  96-127 except accent grave,
			<1@<127-96>>>	;			 del
	.long	^c<0>			; all  of 128-159
	.long	^c<0>			; all  of 160-191
	.long	^c<0>			; all  of 192-223
	.long	^c<0>			; all  of 224-255
20$:

ter_i_any_trm:				; any character terminator mask
	.long	20$-10$
	.long	10$

10$:	.long	^c<0>			; all of   0- 31
	.long	^c<0>			; all of  32- 63
	.long	^c<0>			; all of  64- 95
	.long	^c<0>			; all of  96-127
	.long	^c<0>			; all of 128-159
	.long	^c<0>			; all of 160-191
	.long	^c<0>			; all of 192-223
	.long	^c<0>			; all of 224-255
20$:

switch_list:				; file specification switches
	.long	^a/CR/,		fab$m_tecfmt!< fab$m_cr@16>
	.long	^a/-CR/,	fab$m_tecfmt!<        0@16>
	.long	^a/FT/,		fab$m_tecfmt!<fab$m_ftn@16>
	.long	^a/FTN/,	fab$m_tecfmt!<fab$m_ftn@16>
	.long	^a/B2/,		fab$m_tecb2
	.long	^a/RW/,		fab$m_tecrw
	.long	^a/SH/,		fab$m_tecsh
	.long	^a/SHR/,	fab$m_tecsh
	.long	^a/NV/,		fab$m_tecnv
	.long	^a/STM/,	fab$m_tecstm
	.long	^a/VAR/,	fab$m_tecvar
	.long	0,		0

colon_eg_list:				; :EG special functions
	.long	10$,	^a/MEM/		; :EGMEM$ is "memory" logical
	.long	20$,	^a/INI/		; :EGINI$ is "private init" logical
	.long	30$,	^a/VTE/		; :EGVTE$ is "keypad editor" logical
	.long	40$,	^a/LIB/		; :EGLIB$ is "macro library" logical
	.long	0,	^a/SYM/		; :EGSYM$ is DCL symbol manipulation

10$:	.ascid	"TEC$MEMORY"
20$:	.ascid	"TEC$INIT"
30$:	.ascid	"TEC$VTEDIT"
40$:	.ascid	"TEC$LIBRARY"

.align	byte

indir_cmd_dna:				; defaults for "ei" files
	.ascii	".TEC"
.equate	indir_cmd_dns,	.-indir_cmd_dna

quota_msg_desc:				; over quota message
	.ascid	<13><10>"%Exceeding disk quota"

sizing_msg_desc:			; memory sizing message
	.ascid	" pages]"

	org	tecodatini

.align	long

getdvi_itmlst:				; $GETDVI item list
	.word	 4, dvi$_devclass
	.long	devclass, 0
	.word	 4, dvi$_devtype
	.long	devtype, 0
	.word	 4, dvi$_devbufsiz
	.long	devbufsiz, 0
	.word	 4, dvi$_devdepend
	.long	devdepend, 0
	.word	 4, dvi$_devdepend2
	.long	devdepend2, 0
	.word	64, dvi$_devnam
	.long	devnam, 0
	.word	 4, dvi$_unit
	.long	unit, 0
	.word	 0, 0

.align	byte

ter_i_devnam_fna:			; terminal input device name string
	.ascii	"SYS$INPUT"
ter_i_devnam_fns = .-ter_i_devnam_fna	; terminal input device name length

ter_i_devnam:				; terminal input device name desc
	.long	ter_i_devnam_fns, ter_i_devnam_fna

ter_o_devnam_fna:			; terminal output device name string
	.ascii	"SYS$OUTPUT"
ter_o_devnam_fns = .-ter_o_devnam_fna	; terminal output device name length

ter_o_devnam:				; terminal output device name desc
	.long	ter_o_devnam_fns, ter_o_devnam_fna

ter_c_devnam:				; terminal command device name desc
	.ascid	"SYS$COMMAND"

ini_dcd_lognam:				; logical for private command decoder
	.ascid	"TECO"

cli_verb_teco:				; verb for EDIT/TECO
	.ascid	"TECO"

cli_no_ini:				; qualifier for /NOCOMMAND
	.ascid	"/NOINI"

cli_no_create:				; qualifier for /NOCREATE
	.ascid	"/NOCREATE"

cli_no_memory:				; qualifier for /NOMEMORY
	.ascid	"/NOMEMORY"

cli_inspect:				; qualifier for /READ_ONLY
	.ascid	"/INSPECT"

cli_null:				; a null string for string building
	.ascid	""

cli_space:				; a space for string building
	.ascid	" "

cli_equals:				; an equals sign for string building
	.ascid	"="

cli_dollar:				; a dollar sign for string building
	.ascid	"$"

cli_init:				; logical name for command file
	.ascid	"TEC$INIT"

cli_qual_command:			; to fetch /COMMAND qualifier
	.ascid	"COMMAND"

cli_qual_create:			; to fetch /CREATE qualifier
	.ascid	"CREATE"

cli_qual_memory:			; to fetch /MEMORY qualifier
	.ascid	"MEMORY"

cli_qual_execute:			; to fetch /EXECUTE qualifier
	.ascid	"EXECUTE"

cli_parm_p1:				; to fetch P1 parameter
	.ascid	"P1"

cli_qual_output:			; to fetch /OUTPUT qualifier
	.ascid	"OUTPUT"

cli_qual_read_only:			; to fetch /READ_ONLY qualifier
	.ascid	"READ_ONLY"

.sbttl	Impure data

	org	tecoctl

.align	quad

ter_o_status1:				; terminal output i/o status block #1
	.quad	1

ter_o_status2:				; terminal output i/o status block #2
	.quad	1

ter_o_pos:				; terminal output position IOSB
	.quad	0

ter_i_status:				; terminal input i/o status block
	.quad	0

ter_i:					; terminal input buffer descriptor
	.long	0			;  no initial size of input
	.long	ter_i_buf		;  but pointer to input buffer is set

ter_i_nor8_trm:				; normal 8-bit terminator mask
	.long	20$-10$
	.long	10$

10$:	.long	^c<	<1@8>! -	; all  of   0- 31 except bs,
			<1@9>! -	;			 tab,
			<1@10>! -	;			 lf,
			<1@11>! -	;			 vt,
			<1@12>>		;			 ff
	.long	0			; none of  32- 63
	.long	0			; none of  64- 95
	.long	<	<1@<96-96>>! -	; none of  96-127 except accent grave,
			<1@<127-96>>>	;			 del
	.long	^c<0>			; all  of 128-159
	.long	^c<0>			; all  of 160-191 (initially...)
	.long	^c<0>			; all  of 192-223 (initially...)
	.long	^c<0>			; all  of 224-255 (initially...)
20$:

tmp_string:				; a temporary string...
	.desc	tmp_string

tmp_string2:				; another temporary string...
	.desc	tmp_string2

.align	long

ter_i_nor_trm_ptr:			; normal input terminator mask pointer
	.long	ter_i_nor7_trm		;  (pre-set) normal 7-bit input

saved_sp:				; saved sp value for error exits
	.blkl

still_free:				; amount of memory still free
	.long	0

ctrlz_cnt:				; count of consecutive control/z's
	.long	0

ter_o_cc:				; terminal output carriage control
	.word	0
output_sys_vfc:				; sys$output print control
	.word	1

.align	word

ter_i_chan:				; channel # for terminal input
	.word	0

ter_o_chan:				; channel # for terminal output
	.word	0

ter_c_chan:				; channel # for terminal control/c ast
	.word	0

ter_o_unit:				; terminal output device unit
	.word	0

.align	byte

ctrlc_flag:				; exit on second control/c flip/flop
	.byte	0

ctrlo_flag:				; control/o in effect flag
	.byte	0

ter_o_force:				; terminal output being forced flag
	.byte	0

ter_o_pend:				; terminal output pending count
	.byte	-1

exiting_flag:				; exiting flag
	.byte	1			;  preset to force CTRL/T disable

.align	long

err_msgvec:				; error message vector
	.blkl	3

.noshow	meb

input_nor_fab:				; fab for normal input
	$fab -				; allocate a fab
		fac=get, -		;  allow gets
		fna=file_spec_buf, -	;  file name will come from here
		nam=input_nor_nam, -	;  catch the resultant filespec
		rat=cr, -		;  (pre-set) attributes of implied cc
		rfm=var, -		;  (pre-set) record format of variable
		xab=input_nor_xab	;  catch the protection code

.show	meb

.equate	fab$l_tecsts,	.-input_nor_fab	; our private fab status longword
	.blkl				;  private status longword
.equate	fab$l_tecrab,	.-input_nor_fab	; our private fab to rab pointer
	.long	input_nor_rab		;  private pointer to the correct rab
.equate	fab$q_tecque,	.-input_nor_fab	; our private fab data line queue
	.blkq				;  private data line queue
.equate	fab$l_tecdsp,	.-input_nor_fab	; our private fab dispatch longword
	.blkl				;  private dispatch longword
.equate	fab$l_tecctl,	.-input_nor_fab	; our private fab control bytes
	.blkl				;  private control bytes

.noshow	meb

input_nor_nam:				; nam for normal input
	$nam -				; allocate a nam
		rsa=input_nor_spec, -	;  resultant filespec goes here
		rss=nam$c_maxrss	;  allowing the maximum length

input_nor_xab:				; xab for normal input
	$xabpro				; allocate a protection code xab

input_nor_rab:				; rab for normal input
	$rab -				; allocate a rab
		fab=input_nor_fab, -	;  for normal input fab
		rhb=input_nor_vfc, -	;  use this vfc buffer
		rop=<loc,rah>, -	;  use locate mode & read ahead
		ubf=input_nor_buf, -	;  use this record buffer
		usz=input_nor_siz	;  with this size

output_nor_fab:				; fab for normal output
	$fab -				; allocate a fab
		fac=<put,trn>, -	;  allow puts & truncates
		fna=file_spec_buf, -	;  file name will come from here
		nam=output_nor_nam, -	;  catch the resultant filespec
		org=seq			;  organization is sequential
.assume	fab$l_tecsts eq .-output_nor_fab
	.blkl				;  private status longword
.assume	fab$l_tecrab eq .-output_nor_fab
	.long	output_nor_rab		;  private pointer to the correct rab
.assume	fab$q_tecque eq .-output_nor_fab
	.blkq				;  private data line queue

output_nor_nam:				; nam for normal output
	$nam -				; allocate a nam
		rsa=output_nor_spec, -	;  resultant filespec goes here
		rss=nam$c_maxrss	;  allowing the maximum length

output_nor_rab:				; rab for normal output
	$rab -				; allocate a rab
		fab=output_nor_fab, -	;  for normal output fab
		rop=<tpt,wbh>		;  use truncate on put & write behind

indir_cmd_fab:				; fab for "ei"
	$fab -				; allocate a fab
		dna=indir_cmd_dna, -	;  default string is '.tec'
		dns=indir_cmd_dns, -	;  which is this long
		fac=get, -		;  allow gets
		fna=file_spec_buf, -	;  file name will come from here
		fns=ini_dcd_fns, -	;  (pre-set) for "SYS$LOGIN:TECO"
		fop=sqo, -		;  (pre-set) sequential only option
		nam=indir_cmd_nam, -	;  catch the resultant filespec
		rat=cr, -		;  (pre-set) attributes of implied cc
		rfm=var, -		;  (pre-set) record format of variable
		shr=get			;  (pre-set) sharing is other gets
.assume	fab$l_tecsts eq .-indir_cmd_fab
	.long	0			;  (pre-set) private status longword
.assume	fab$l_tecrab eq .-indir_cmd_fab
	.long	indir_cmd_rab		;  private pointer to the correct rab
.assume	fab$q_tecque eq .-indir_cmd_fab
10$:	.long	10$, 10$		;  (pre-set) private data line queue
.assume	fab$l_tecdsp eq .-indir_cmd_fab
	.long	getbyt_first		;  (pre-set) private dispatch longword
.assume	fab$l_tecctl eq .-indir_cmd_fab
	.byte	10, 0, 0, 0		;  (pre-set) private control bytes

indir_cmd_nam:				; nam for "ei"
	$nam -				; allocate a nam
		rsa=indir_cmd_spec, -	;  resultant filespec goes here
		rss=nam$c_maxrss	;  allowing the maximum length

indir_cmd_rab:				; rab for "ei"
	$rab -				; allocate a rab
		fab=indir_cmd_fab, -	;  for "ei" fab
		rhb=indir_cmd_vfc, -	;  use this vfc buffer
		rop=<loc,rah>, -	;  use locate mode & read ahead
		ubf=indir_cmd_buf, -	;  use this record buffer
		usz=indir_cmd_siz	;  with this size

input_alt_fab:				; fab for alternate input
	$fab -				; allocate a fab
		fac=get, -		;  allow gets
		fna=file_spec_buf, -	;  file name will come from here
		nam=input_alt_nam, -	;  catch the resultant filespec
		rat=cr, -		;  (pre-set) attributes of implied cc
		rfm=var, -		;  (pre-set) record format of variable
		xab=input_alt_xab	;  catch the protection code
.assume	fab$l_tecsts eq .-input_alt_fab
	.blkl				;  private status longword
.assume	fab$l_tecrab eq .-input_alt_fab
	.long	input_alt_rab		;  private pointer to the correct rab
.assume	fab$q_tecque eq .-input_alt_fab
	.blkq				;  private data line queue
.assume	fab$l_tecdsp eq .-input_alt_fab
	.blkl				;  private dispatch longword
.assume	fab$l_tecctl eq .-input_alt_fab
	.blkl				;  private control bytes

input_alt_nam:				; nam for alternate input
	$nam -				; allocate a nam
		rsa=input_alt_spec, -	;  resultant filespec goes here
		rss=nam$c_maxrss	;  allowing the maximum length

input_alt_xab:				; xab for alternate input
	$xabpro				; allocate a protection code xab

input_alt_rab:				; rab for alternate input
	$rab -				; allocate a rab
		fab=input_alt_fab, -	;  for alternate input fab
		rhb=input_alt_vfc, -	;  use this vfc buffer
		rop=<loc,rah>, -	;  use locate mode & read ahead
		ubf=input_alt_buf, -	;  use this record buffer
		usz=input_alt_siz	;  with this size

output_alt_fab:				; fab for alternate output
	$fab -				; allocate a fab
		fac=<put,trn>, -	;  allow puts & truncates
		fna=file_spec_buf, -	;  file name will come from here
		nam=output_alt_nam, -	;  catch the resultant filespec
		org=seq			;  organization is sequential
.assume	fab$l_tecsts eq .-output_alt_fab
	.blkl				;  private status longword
.assume	fab$l_tecrab eq .-output_alt_fab
	.long	output_alt_rab		;  private pointer to the correct rab
.assume	fab$q_tecque eq .-output_alt_fab
	.blkq				;  private data line queue

output_alt_nam:				; nam for alternate output
	$nam -				; allocate a nam
		rsa=output_alt_spec, -	;  resultant filespec goes here
		rss=nam$c_maxrss	;  allowing the maximum length

output_alt_rab:				; rab for alternate output
	$rab -				; allocate a rab
		fab=output_alt_fab, -	;  for alternate output fab
		rop=<tpt,wbh>		;  use truncate on put & write behind

en_fab:					; for for "en"
	$fab -				; allocate a fab
		fna=file_spec_buf, -	;  file name will come from here
		nam=en_nam		;  "en" name block
.assume	fab$l_tecsts eq .-en_fab
	.long	fab$m_teceof		;  private status longword (fnf)

en_nam:					; nam for "en"
	$nam -				; allocate a nam
		esa=en_spec, -		;  "en" parse filespec
		ess=nam$c_maxrss, -	;  allowing the maximum length
		rsa=en_occur, -		;  "en" occurance filespec
		rss=nam$c_maxrss	;  allowing the maximum length

input_sys_fab:				; fab for sys$input input
	$fab -				; allocate a fab
		fac=get, -		;  allow gets
		fna=ter_i_devnam_fna, -	;  file name as for terminal input
		fns=ter_i_devnam_fns, -	;   with the correct length
		rat=cr, -		;  (pre-set) attributes of implied cc
		rfm=var			;  (pre-set) record format of variable
.assume	fab$l_tecsts eq .-input_sys_fab
	.long	0			;  (pre-set) private status longword
.assume	fab$l_tecrab eq .-input_sys_fab
	.long	input_sys_rab		;  private pointer to the correct rab
.assume	fab$q_tecque eq .-input_sys_fab
10$:	.long	10$, 10$		;  (pre-set) private data line queue
.assume	fab$l_tecdsp eq .-input_sys_fab
	.long	getbyt_first		;  (pre-set) private dispatch longword
.assume	fab$l_tecctl eq .-input_sys_fab
	.byte	10, 0, 0, 0		;  (pre-set) private control bytes

input_sys_rab:				; rab for sys$input input
	$rab -				; allocate a rab
		fab=input_sys_fab, -	;  for sys$input input fab
		rhb=input_sys_vfc, -	;  use this vfc buffer
		rop=<loc,rah>, -	;  use locate mode & read ahead
		ubf=ter_i_buf, -	;  use this record buffer
		usz=ter_i_siz		;  with this size

output_sys_fab:				; fab for sys$output output
	$fab -				; allocate a fab
		fac=put, -		;  allow puts
		fna=ter_o_devnam_fna, -	;  file name as for terminal output
		fns=ter_o_devnam_fns, -	;   with the correct length
		fsz=2, -		;  fixed control area is 2 bytes
		org=seq, -		;  organization is sequential
		rat=prn, -		;  use print file format
		rfm=vfc			;  format is variable w/ fixed control

output_sys_rab:				; rab for sys$output output
	$rab -				; allocate a rab
		fab=output_sys_fab, -	;  for sys$output output fab
		rbf=output_sys_buf, -	;  use this output buffer
		rhb=output_sys_vfc, -	;  use this print control buffer
		rsz=0, -		;  no partial record initially
		rop=wbh			;  use write behind

.show	meb

file_spec_opt:				; file specification options
	.blkl

file_spec_swt:				; file specification switch
	.blkl

ter_oob_msk:				; terminal out-of-band re-enable mask
	.long	0			;  preset to nothing to re-enable

.align	byte

file_spec_len:				; file specification length
	.blkb

file_spec_buf:				; file specification buffer
	.ascii	"SYS$LOGIN:TECO"	;  (pre-set for :EISYS$LOGIN:TECO$)
ini_dcd_fns = .-file_spec_buf
	.blkb	nam$c_maxrss+1-<.-file_spec_buf>

input_nor_spec:				; resultant filespec for normal input
	.blkb	nam$c_maxrss

output_nor_spec:			; resultant filespec for normal output
	.blkb	nam$c_maxrss

indir_cmd_spec:				; resultant filespec for "ei"
	.blkb	nam$c_maxrss

input_alt_spec:				; resultant spec for alternate input
	.blkb	nam$c_maxrss

output_alt_spec:			; resultant spec for alternate output
	.blkb	nam$c_maxrss

en_spec:				; "en" parse filespec
	.blkb	nam$c_maxrss

en_occur:				; "en" occurance filespec
	.blkb	nam$c_maxrss

input_nor_vfc:				; normal input vfc buffer
	.blkb	input_vfc_siz

indir_cmd_vfc:				; "ei" vfc buffer
	.blkb	input_vfc_siz

input_alt_vfc:				; alternate input vfc buffer
	.blkb	input_vfc_siz

input_sys_vfc:				; sys$input vfc buffer
	.blkb	input_vfc_siz

	org	tecoctlini

.align	long

getdvi_info:				; $GETDVI returned information
devclass:				;  device class
	.blkb
devtype:				;  device type
	.blkb
devbufsiz:				;  device buffer size (width)
	.blkw
devdepend:				;  device dependent bits
	.blkl
devdepend2:				;  device dependent bits #2
	.blkl
getdvi_info_len = .-getdvi_info

devnam:					;  device name string
	.blkb	64

unit:					;  device unit number
	.blkl

.noshow	meb

cli_req_getcmd:				; request block to get command line
	$clireqdesc -			; define cli request descriptor block
		rqtype=cli$k_getcmd	;  to get the whole command line

.show	meb

cli_result:				; cli parse result string
	.word	0
	.byte	dsc$k_dtype_t
	.byte	dsc$k_class_d
	.long	0

cli_command_line:			; built up cli parse command line
	.word	0
	.byte	dsc$k_dtype_t
	.byte	dsc$k_class_d
	.long	0

.sbttl	Permanent I/O buffers

	org	tecobuf

.align	page

ter_o_buf1:				; terminal output buffer #1
	.blkb	ter_o_siz

ter_o_buf2:				; terminal output buffer #2
	.blkb	ter_o_siz

ter_i_buf:				; terminal input buffer
	.ascii	"MY"<27>		; (pre-set) initial command string
.equate	ter_i_buf_pre,	.-ter_i_buf
	.blkb	ter_i_siz-<.-ter_i_buf>

input_nor_buf:				; normal input record buffer
	.blkb	input_nor_siz

indir_cmd_buf:				; "ei" record buffer
	.blkb	indir_cmd_siz

input_alt_buf:				; alternate input record buffer
	.blkb	input_alt_siz

output_sys_buf:				; sys$output output record buffer
	.blkb	output_sys_siz

.sbttl	Main startup entry point

	org	tecoexeini

.entry	tec$teco, ^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11> ; startup entry point

.sbttl	Initialization code

; set up permanent pointer registers

	mnegl	#1, r10			; junk up the ctl$al_cmcntx pointer
	movaw	r5set, r11		; point to teco's read/write area

; do default read/write area setup

	movw	#io$m_noformat, io$bin	; set "how to do binary output"
	movw	#io$m_canctrlo, io$cco	; set "how to cancel control/o"
	movw	#spset, w^tecosp(r11)	; set sp stack reset value
	movw	#pdlsrt, w^tecopd(r11)	; set teco's pdl start
	movw	#pdlsrt, b^pdl(r11)	;  and init the pdl
	movw	#schsrt, w^schbuf(r11)	; set teco's search buffer start
	movw	#filsrt, w^filbuf(r11)	; set teco's filename buffer start
	movw	#tagsrt, w^tagbuf(r11)	; set teco's tag buffer start
	movw	#inpnor, b^inpntr(r11)	; set input pointer to normal input
	movw	#oupnor, b^oupntr(r11)	; set output pointer to normal output
	movw	#tecoch, w^tecojp(r11)	; set default jump dispatch table
	movaw	w^rwsize(r11), r0	; get start of free memory
	movl	#initial_siz, r1	; set initial text buffer/q-reg sizes
	movw	r0, b^txstor(r11)	; set start of text storage
	movw	r1, b^zmax(r11)		;  and its size
	addl	r1, r0			;   then skip its size
	movw	r0, b^qrstor(r11)	; set start of q-register storage
	addl	r1, r0			;  then skip its (trial) size
	subl3	r0, #65535, r2		; find amount of memory still free
	bicl3	#512-1, r2, w^still_free ; store rounded down to page multiple
	subl	w^still_free, r2	;  then find the remainder
	addw3	r1, r2, b^qmax(r11)	; set true q-register storage size
	movw	#tec$m_et$xit, b^etype(r11) ; set default "et" flags
	movzbw	#^a/_/, b^symspc(r11)	; "_" is a symbol character too
	mnegw	#1, b^outdne(r11)	; say all sorts of output done
	addl3	#128/8, w^ter_i_nor8_trm+4, r1 ; address bits 128-255 of mask
	clrl	r2			; start at (relative) bit 0
10$:	bbss	r2, (r1), 20$		; ensure that this bit is set
20$:	tstw	cnv8bt[r2]		; a hex pair for conversion?
	blss	30$			; yes, leave the bit set
	bbcc	r2, (r1), 30$		; no, clear the bit
30$:	aoblss	#128, r2, 10$		; loop for all 128 bits...

; get terminal input device's characteristics

getdvi_ter_i:				; get terminal input characteristics
	$getdvi_s -			; get device characteristics
		devnam=w^ter_i_devnam, - ;  of terminal input device
		itmlst=w^getdvi_itmlst	;  using this item list
	blbc	r0, 20$			; non-terminal if any failure
	cmpb	w^devclass, #dc$_term	; a terminal?
	bneq	20$			; nope
	bbc	#tt$v_lower, w^devdepend, 10$ ; lowercase?
	bs	#tec$v_et$lc, b^etype(r11) ; yes, allow lower case input
10$:	$assign_s -			; assign channel for terminal input
		devnam=w^ter_i_devnam, - ;  terminal input device name
		chan=w^ter_i_chan	;  into terminal input channel
	bsbw	success_else_die	; abort unless success completion
	brb	60$			; go continue

20$:	bs	#tec$v_et$lc, b^etype(r11) ; lower case for non-terminals
	$open -				; open
		fab=w^input_sys_fab	;  sys$input
	movl	w^input_sys_fab+fab$l_stv, w^err_msgvec+8 ; save the STV value
	bsbw	success_else_die	; abort unless success completion
	cmpb	w^input_sys_fab+fab$b_rfm, #fab$c_vfc ; vfc record format?
	bneq	30$			; nope
	movl	#rms$_fsz, r0		; pre-set bad vfc size error
	cmpb	w^input_sys_fab+fab$b_fsz, #input_vfc_siz ; vfc size correct?
	bgtru	50$			; nope, go die with an error
30$:	cmpb	w^input_sys_fab+fab$b_rfm, #fab$c_stm ; stream record format?
	bneq	40$			; nope
	bisb	#fab$m_cr, w^input_sys_fab+fab$b_rat ; yep, set implied lf/cr
40$:	$connect -			; connect
		rab=w^input_sys_rab	;  to it
	movl	w^input_sys_rab+rab$l_stv, w^err_msgvec+8 ; save the STV value
50$:	bsbw	success_else_die	; abort unless success completion
60$:					; continue

; get terminal output device's characteristics

getdvi_ter_o:				; get terminal output characteristics
	$getdvi_s -			; get device characteristics
		devnam=w^ter_o_devnam, - ;  of terminal output device
		itmlst=w^getdvi_itmlst	;  using this item list
	pushl	#0			; guess at no terminal data to look at
	blbc	r0, 70$			; non-terminal if any failure
	cmpb	w^devclass, #dc$_term	; a terminal?
	bneq	70$			; nope
	movab	w^devnam, r0		; yep, address the device name string
10$:	cmpb	(r0)+, #^a/_/		; a leading underscore?
	beql	10$			; yes, go ignore it
	cmpw	-1(r0), #^a/TT/		; is it "TTc" format?
	bneq	20$			; no, so no decode
	subb3	#^a/A/, 1(r0), w^ter_o_unit+1 ; set controler # * 256.
	addw	w^unit, w^ter_o_unit	; plus unit number
20$:	moval	w^devdepend, r0		; address device dependent bits
	bbc	#tt$v_lower, (r0), 30$	; lowercase?
	decw	b^euflag(r11)		; yes, say no case flagging
30$:	bbs	#tt$v_wrap, (r0), 40$	; wrap?
	bs	#tec$v_et$tru, b^etype(r11) ; no, indicate truncated lines
40$:	bbc	#tt$v_eightbit, (r0), 50$ ; eight-bit?
	bs	#tec$v_et$8bt, b^etype(r11) ; yes, indicate 8-bit terminal
50$:	bbc	#tt$v_scope, (r0), 60$	; scope?
	movc	#getdvi_info_len, w^getdvi_info, errbuf ; save scope info
	movab	errbuf+2, (sp)		;  and form pointer to the data @ +2
60$:	$assign_s -			; assign channel for terminal output
		devnam=w^ter_o_devnam, - ;  terminal outut device name
		chan=w^ter_o_chan	;  into terminal output channel
	bsbw	success_else_die	; abort unless success completion
	brb	80$			; go continue

70$:	decw	b^euflag(r11)		; no case flagging for non-terminals
	bs	#tec$v_et$8bt, b^etype(r11) ; 8-bit mode for non-terminals
	$create -			; create
		fab=w^output_sys_fab	;  sys$output
	movl	w^output_sys_fab+fab$l_stv, w^err_msgvec+8 ; save STV value
	bsbw	success_else_die	; abort unless success completion
	$connect -			; connect
		rab=w^output_sys_rab	;  to it
	movl	w^output_sys_rab+rab$l_stv, w^err_msgvec+8 ; save STV value
	bsbw	success_else_die	; abort unless success completion
80$:					; continue

; get terminal command device's characteristics

getdvi_ter_c:				; get terminal command characteristics
	$getdvi_s -			; get device characteristics
		devnam=w^ter_c_devnam, - ;  of terminal command device
		itmlst=w^getdvi_itmlst	;  using this item list
	blbc	r0, 10$			; non-terminal if any failure
	cmpb	w^devclass, #dc$_term	; a terminal?
	bneq	10$			; nope
	$assign_s -			; assign channel for control/c ast's
		devnam=w^ter_c_devnam, - ;  terminal command device name
		chan=w^ter_c_chan	;  into terminal control/c ast channel
	bsbw	success_else_die	; abort unless success completion
	bsbw	enable_ctrlcast		; go enable the control/c ast
	bsbw	success_else_die	; abort unless success completion
10$:					; continue

; pre-load q-register y (command decoder) and z (command line) if needed

.enable	lsb

pre_load_q_regs:			; pre-load q-registers y and z
	moval	w^cli_req_getcmd, r6	; get address of request block
	pushal	(r6)			; set address of request block
	calls	#1, g^sys$cli		; go get the command line
	tstw	r0			; the special "no command" status?
	bneq	10$			; nope
	brw	210$			; yep, go continue

10$:	bsbw	success_else_die	; abort unless success completion
	cmpb	cli$b_rqstat(r6), #cli$k_verb_edit ; is this EDIT/TECO?
	beql	20$			; yes
	brw	110$			; no

20$:	movaq	w^cli_verb_teco, r5	; set TECO verb
	bsbw	200$			;  as command line verb
	pushaq	w^cli_qual_command	; /COMMAND
	calls	#1, g^cli$present	;  present?
	blbc	r0, 30$			; no, go use /NOINI
	pushaq	w^cli_result		; address result string
	pushaq	w^cli_qual_command	; /COMMAND=file
	calls	#2, g^cli$get_value	;  have a value?
	blbc	r0, 40$			; no
	pushaq	w^cli_result		; yes, form
	pushaq	w^cli_dollar		;  "$file"
	pushaq	w^cli_result		;   in the result
	calls	#3, g^str$concat	;    using concatenation
	bsbw	success_else_die	; abort unless success completion
	$crelog_s -			; create a logical
		tblflg = #2, -		;  use the process table
		lognam = w^cli_init, -	;  logical is TEC$INIT
		eqlnam = w^cli_result	;  with this equivalence string
	bsbw	success_else_die	; abort unless success completion
	brb	40$			; else continue

30$:	movaq	w^cli_no_ini, r5	; set /NOINI
	bsbw	200$			;  and go add it
40$:	pushaq	w^cli_qual_create	; /CREATE
	calls	#1, g^cli$present	;  present?
	blbs	r0, 50$			; yes
	movaq	w^cli_no_create, r5	; no, set /NOCREATE
	bsbw	200$			;  and go add it
50$:	pushaq	w^cli_qual_memory	; /MEMORY
	calls	#1, g^cli$present	;  present?
	blbs	r0, 60$			; yes
	movaq	w^cli_no_memory, r5	; no, set /NOMEMORY
	bsbw	200$			;  and go add it
60$:	movaq	w^cli_space, r5		; set " " as the next separator
	pushaq	w^cli_result		; address result string
	pushaq	w^cli_qual_execute	; /EXECUTE=file
	calls	#2, g^cli$get_value	;  present with a value?
	movl	r0, r4			; remember /EXECUTE's existence
	blbc	r0, 70$			; no
	movl	#^a/MUNG/, @cli_command_line+4 ; yes, change verb to MUNG
	bsbw	200$			; add the " " separator
	bsbw	190$			; add /EXECUTE's value
	movaq	w^cli_space, r5		; set " " as the next separator
	brb	80$			;  and go check out P1

70$:	pushaq	w^cli_result		; address result string
	pushaq	w^cli_qual_output	; /OUTPUT=file
	calls	#2, g^cli$get_value	;  present with a value?
	blbc	r0, 80$			; no
	bsbw	200$			; yes, add the " " separator
	bsbw	190$			; add /OUTPUT's value
	movaq	w^cli_equals, r5	; set "="
	bsbw	200$			;  and add it
	movaq	w^cli_null, r5		; set "" as the next separator
80$:	pushaq	w^cli_result		; address result string
	pushaq	w^cli_parm_p1		; parameter P1
	calls	#2, g^cli$get_value	;  present with a value?
	blbc	r0, 90$			; no
	bsbw	200$			; yes, add the " " or "" separator
	bsbw	190$			; add P1's value
90$:	blbs	r4, 100$		; all done if /EXECUTE exists
	pushaq	w^cli_qual_read_only	; /READ_ONLY
	calls	#1, g^cli$present	;  present?
	blbc	r0, 100$		; no
	movaq	w^cli_inspect, r5	; yes, set /INSPECT
	bsbw	200$			;  and go add it
100$:	movw	w^cli_command_line, cli$w_rqsize(r6) ; set command line length
	movl	w^cli_command_line+4, cli$a_rqaddr(r6) ;  and address
110$:	movzwl	b^qrstor(r11), r3	; get pointer to q-register storage
	movzbl	#^a/Y/-^a/A/, r0	; we're loading q-register y
	movzwl	#tecocmd_siz, r1	; get command decoder's size
	movab	w^tecocmd, r2		;  and a pointer to it
	bsbw	180$			; go load a q-register
	movzbl	#^a/Z/-^a/A/, r0	; we're loading q-register z
	movzwl	cli$w_rqsize(r6), r1	; get command line's size
	movl	cli$a_rqaddr(r6), r2	; get a pointer to command line
	bsbw	180$			; go load a q-register
	moval	w^indir_cmd_fab, r6	; get the indirect command fab
	getdesc	tmp_string, r0		; reset & get desc for temp string
	$trnlog_s -			; translate
		lognam=ini_dcd_lognam, - ;  logical name "TECO"
		rslbuf=(r0)		;  putting result into the temp
	cmpw	r0, #ss$_notran		; did anything happen?
	beql	130$			; nope, use pre-set "SYS$LOGIN:TECO"
	bsbw	success_else_die	; abort unless success completion
	movl	#^a/TECO/, @fab$l_fna(r6) ; set file name of simply "TECO"
	movb	#4, fab$b_fns(r6)	;  and its length
130$:	$open -				; open
		fab=(r6)		;  the command decoder file file
	blbc	r0, 170$		; branch if failure of any type
	cmpb	fab$b_rfm(r6), #fab$c_vfc ; vfc record format?
	bneq	140$			; nope
	cmpb	fab$b_fsz(r6), #input_vfc_siz ; vfc size correct?
	bgtru	160$			; nope, so don't use it...
140$:	cmpb	fab$b_rfm(r6), #fab$c_stm ; stream record format?
	bneq	150$			; nope
	bisb	#fab$m_cr, fab$b_rat(r6) ; always say implied lf/cr for stream
150$:	$connect -			; connect
		rab=@fab$l_tecrab(r6)	;  the correct rab
	blbc	r0, 160$		; branch if failure of any type
	moval	cmdprm, r7		; get where to store fab pointer
	movl	r6, (r7)		; set file as open
	bsbw	set_filename		; set the file's name, etc.
	movw	r7, b^indir(r11)	; set indirect as active
	brb	210$			; go continue

160$:	$close -			; close
		fab=(r6)		;  the (bad) command decoder file file
170$:	movzwl	#ter_i_buf_pre, w^ter_i	; set count for pre-buffered input
	movw	#2, b^indir(r11)	; preset for initial command string
	brb	210$			; go continue

180$:	movl	r1, b^qarray(r11)[r0]	; set q-reg's size (clobbers next!)
	addw	r1, b^qz(r11)		; count as q-reg space used
	cmpw	b^qz(r11), b^qmax(r11)	; did we run out of space?
	bgtru	abort_exit		; whoops, we did
	movc	r1, (r2), (r3)		; load the q-register
	rsb				; exit

abort_exit:				; set abort error code and exit
	movzwl	s^#ss$_abort, r0	; set a fatal error code
	brw	success_else_die	;  and go exit with it

190$:	movaq	w^cli_result, r5	; address the cli result string
200$:	pushaq	(r5)			; arg #2 is string to add
	pushaq	w^cli_command_line	; arg #1 is string to add to
	calls	#2, g^str$append	; go append to string
	brw	success_else_die	; error check and exit

210$:					; continue

.disable lsb

; clean up and enter compatibility mode

clean_up_and_start:			; clean up & enter compatibility mode
	tstw	w^ter_o_chan		; is there a terminal output channel?
	beql	10$			; nope, so no mode(s) to reset
	pushl	w^devdepend		; save the original characteristics
	bicl	#tt$m_halfdup!tt$m_escape, w^devdepend ; full dup & not escape
	bsbw	tec$setmode		; go reset the terminal mode(s)
	movl	(sp)+, w^devdepend	; restore original characteristics
	bsbw	success_else_die	; abort unless success completion
10$:	$dclcmh_s -			; declare compatibility mode handler
		addres=w^tec$cmtrap, -	;  traps will come here
		type=#1			;  and we want compatibility traps
	bsbw	success_else_die	; abort unless success completion
	clrq	r2			; clear r2, r3
	movl	(sp)+, r4		; set r4 if scope terminal, else clear
	movl	r11, r5			; set teco's r5 r/w area pointer
	movaw	spset, r6		; set to reset the sp stack
	pushl	#psl$m_cm!<psl$c_user@psl$v_curmod>!<psl$c_user@psl$v_prvmod>
	pushaw	tecost			; stack startup pc/psl pair
	brw	start_teco		; go purge working set, then start up!

.sbttl	Compatibility mode trap handler

	org	tecoexe

.align	page

tec$cmtrap:				; compatibility mode traps come here
	subl3	#i_bias, r0, r10	; form ctl$al_cmcntx pointer
	movzbl	@(r0)+, r1		; get low byte of instruction
	bicl	#1, (r0)		; pre-clear c-bit in saved ps
	addl	#2, -(r0)		; adjust saved pc
	bbcc	#7, r1, 10$		; check for automatic "rts pc"
	movzwl	@i_sp(r10), (r0)	; move return address to saved pc
	addl	#2, i_sp(r10)		;  then 'pop' the stack
10$:	bsbb	20$			; go dispatch on exception code
	movq	(r10)+, r0		; restore r0, r1
	movq	(r10)+, r2		; restore r2, r3
	movq	(r10)+, r4		; restore r4, r5
	movq	(r10)+, r6		; restore sp, junk r7
	movq	(r10), -(sp)		; stack pc/psl pair
	rei				; back to whatever...

20$:	movl	sp, w^saved_sp		; save calling sp for error exits
	casew	i_code(r10), #1, #<<40$-30$>/2>-1 ; enter proper routine...
30$:					; reference only
	 .word	tec$wait-30$		; 1 => bpt
	 .word	tec$output-30$		; 2 => iot
	 .word	50$-30$			; 3 => emt
	 .word	tec$input-30$		; 4 => trap
40$:					; reference only
	brw	abort_exit		; whoops, we must abort...

.macro	other	name
$'name	==	<<.-60$>/2>+1
	 .word	tec$'name-60$
.endm	other

50$:	casew	r1, #1, #<<70$-60$>/2>-1 ; 'emt' is other...
60$:					; reference only
	other	width			; new terminal width
	other	eight			; change 8-bit terminal mode
	other	truln			; change truncate lines mode
	other	ejflg			; get ej flag information
	other	gexit			; process special functions
	other	sizer			; get additional memory
	other	date			; get date
	other	time			; get time
	other	getfl			; get files opened
	other	inpsv			; switch input file
	other	outsv			; switch output file
	other	bakup			; page backwards
	other	getbf			; get input
	other	putbf			; put output
	other	clsfl			; close input & output files
	other	clsof			; close output files
	other	aller			; finish up on error processing
	other	kilfl			; delete output file
	other	delln			; echo line deletion
	other	delch			; echo character deletion
	other	xitnw			; stop teco terminal hacks
	other	texit			; exit from teco
70$:					; reference only
	brw	abort_exit		; whoops, we must abort...

.sbttl	Initial start up

start_teco:				; initial start of compatibility mode
	$purgws_s -			; purge our working set
		inadr=b^10$		;  do the whole thing...
	bsbw	success_or_announce	; announce any failure...
	clrq	r0			; clear r0, r1
	rei				; enter compatibility mode...

10$:	.long	0			; purge from 00000000
	.long	1@31-1			;  to 7FFFFFFF

.sbttl	Error processing, etc.

.enable	lsb

10$:	moval	w^err_msgvec+8, r1	; point to message vector spot
	movl	r0, -(r1)		; load the error status code
	movl	#<<8!4!2!1>@16>!1, -(r1) ; fac, sev, id, & text; arg count = 1
	cmpw	6(r1), s^#rms$_normal/65536 ; is this an RMS error?
	bneq	20$			; nope
	incw	(r1)			; yep, include the STV value in count
20$:	rsb				; exit

success_else_die:			; abort unless success completion
	blbs	r0, 20$			; exit if success
	pushl	r0			; failure, save the exit reason code
	bsbb	success_or_announce	; go announce the failure
	bicl	#sts$m_severity, (sp)	; trim out severity code in status
	bisl3	#sts$m_inhib_msg!sts$k_severe, - ; inhibit msg & severe error
			(sp)+, r0	;  get forced on in status code
	$exit_s -			; force an image exit
		code = r0		;  with the reason code

success_or_announce:			; check for success; announce if not
	blbs	r0, 60$			; exit if success
	bsbb	10$			; go format the message vector
	$putmsg_s -			; use $PUTMSG to format the message
		msgvec = (r1)		;  using the built up message vector
	;bsbw	success_or_announce	; announce any failure...
	rsb				; exit

success_or_abrt:			; check for success; abort if not
	blbs	r0, 60$			; exit if success
	movaw	ioerr, i_pc(r10)	; else exit to teco's error processor
	brb	30$			; continue

success_or_cls:				; check success; close & error if not
	blbs	r0, 60$			; exit if success
	movl	fab$l_tecrab(r6), r1	; get the rab pointer
	movl	rab$l_stv(r1), w^err_msgvec+8 ; save the STV value
	pushr	#^m<r0>			; save the failure status
	$close -			; close
		fab=(r6)		;  the (failing) fab
	popr	#^m<r0>			; restore the failure status
success_or_err:				; check for success; error if not
	blbs	r0, 60$			; exit if success
30$:	bsbb	10$			; go format the message vector
rad50	ERR
	movzwl	#$$$$$$, i_r0(r10)	; set rad50 code for ERR into saved r0
	cmpl	4(r1), #rms$_fnf	; was the error file not found?
	bneq	40$			; it was not
	movw	#1, 2(r1)		; it was, set only message text
rad50	FNF
	movzwl	#$$$$$$, i_r0(r10)	; set rad50 code for FNF into saved r0
40$:	clrb	errbuf			; "empty" the error message buffer
	$putmsg_s -			; use $PUTMSG to format the message
		msgvec = (r1), -	;  using the built up message vector
		actrtn = b^70$		;  catch the message w/ action routine
	bsbw	success_or_announce	; announce any failure...
50$:	movab	errbuf, i_r2(r10)	; set error message addr into saved r2
	incl	i_ps(r10)		; set c-bit in saved ps
	movl	w^saved_sp, sp		; restore calling sp for error exit
60$:	rsb				; exit

err:					; errors come here
	movl	@(sp)+, r6		; get pointer to: code, len, text
	movzwl	(r6)+, i_r0(r10)	; set rad50 code into saved r0
	movzbl	(r6)+, r0		; get length of text string
	movc5	r0, (r6), #0, #errbfl-1, errbuf ; move message text
	clrb	(r3)			;  and ensure result is asciz
	brb	50$			; go set the message text address

70$:	.word	^m<r2,r3,r4,r5>		; $PUTMSG action routine
	movq	@4(ap), r2		; get message text descriptor
	locc	#0, #errbfl-1, errbuf	; find asciz ending of message buffer
	cmpw	r0, #errbfl-1		; is the whole message buffer free?
	bgequ	80$			; yes, no need for prefixing
	addw3	#3, r2, r4		; add prefix size to message size
	cmpw	r0, r4			; would the whole thing fit?
	blssu	90$			; nope
	subw	#3, r0			; yep, remove prefix size from free
	movw	#<10@8>!13, (r1)+	; prefix message with <CR><LF>
	movb	#9, (r1)+		;  and <TAB>
80$:	movc5	r2, (r3), #0, r0, (r1)	; move message text into buffer
	clrb	(r3)			;  and ensure result is asciz
90$:	clrl	r0			; don't put the message to user
	ret				;  when I return to you

.disable lsb

.sbttl	Control/c ASTs

tec$ctrlcast:				; control/c ast's come here
	.word	^m<>			; no need to save any registers
	bbsc	#tec$v_et$cc, etype+r5set, 10$ ; user trapping control/c's?
	mnegb	#1, tflg+1+r5set	; no, set the stop soon indicator
	bbc	#tec$v_et$xit, etype+r5set, 10$ ; exit on control/c's?
	mcomb	#0, w^ctrlc_flag	; yes, ensure flipped flop
10$:	bsbb	enable_ctrlcast		; go re-enable the control/c ast
	bsbw	success_or_announce	; announce any failure...
	mcomb	#0, w^ctrlo_flag	; say control/o is now in effect
	$cancel_s -			; cancel all pending I/O
		chan=w^ter_o_chan	;  on the terminal output channel
	bsbw	success_or_announce	; announce any failure...
	ret				; return

enable_ctrlcast:			; enable the control/c ast
	$qiow_s -			; set up the control/c ast with a qio
		chan=w^ter_c_chan, -	;  using the control/c ast channel
		func=#io$_setmode!io$m_ctrlcast, - ;  function = control/c ast
		p1=b^tec$ctrlcast	;  go to here on control/c ast's
	rsb				; exit

.sbttl	Terminal output waits

.enable	lsb

tec$wait_done_lf:			; wait for all output (inc. <LF>'s)
	movb	#2!1, w^ter_o_force	; say we're forcing <LF>'s also
	cmpw	ttoptr, #ttobuf		; is the terminal output buffer empty?
	bneq	tec$wait_done		; nope
	tstl	w^ter_o_cc		; any pending, saved <LF>?
	beql	tec$wait_done		; nope
	movw	b^outdne(r11), -(sp)	; yep, save current output done flag
	clrl	w^ter_o_cc		; forget about saving the <LF>
	bsbw	echo_lf			;  because we want to (re-)buffer it
	movw	(sp)+, b^outdne(r11)	; restore original output done flag
tec$wait_done:				; wait for all output to complete
	bisb	#1, w^ter_o_force	; say we're forcing terminal output
	bsbb	tec$wait		;  and go do an initial wait
	clrb	w^ter_o_force		; now back to non-forced output
	tstb	w^ter_o_pend		; is there any in-progress output?
	blss	20$			; nope, go exit
	pushab	b^tec$wait_done		; yep, check again after waiting
10$:	$waitfr_s -			; wait for single event flag
		efn=#1			;  on this event flag
	bsbw	success_or_announce	; announce any failure...
	$clref_s -			; do an event flag clear
		efn=#1			;  on this event flag
	bsbw	success_or_announce	; announce any failure...
tec$wait:				; wait for output completion
	cmpw	ttoptr, #ttobuf		; is the buffer empty?
	beql	20$			; yes, go exit
	tstw	ttoint			; no, can we initiate output?
	bgeq	10$			; output's already pending, go wait
	bsbw	tec$output		; else initiate whatever output we can
20$:	rsb				; exit

.disable lsb

.sbttl	Terminal output

check_esc_csi:				; check ESCape/CSI sequences
	blbs	w^ter_o_force, 40$	; no processing if forcing output
	movq	r0, r2			; copy remaining count/pointer
	movzbl	#^a/0/, r4		;  and guess at an ESCape sequence
	cmpb	(r3), #27+128		; is it really (8-bit) CSI?
	beql	10$			; yep
	bsbb	60$			; get the next character
	cmpb	(r3), #^a/[/		; is it (7-bit) CSI?
	bneq	30$			; nope
10$:	movzbl	#^a/@/, r4		; set correct final for CSI
20$:	bsbb	60$			; get the next sequence character
30$:	cmpb	(r3), #32		; control character?
	blssu	40$			; yes, call it finished...
	cmpb	(r3), #127		; is it DEL or higher (also controls)?
	bgequ	40$			; yes, call it finished...
	cmpb	(r3), r4		; a final character to finish it?
	blssu	20$			; not finished, loop for the next...
40$:	movb	(r1)+, (r5)+		; copy over the ESCape/CSI character
	decl	r0			;  and remove it from the count
	beql	50$			; no more, just go exit
	movtuc	r0, (r1), #27, w^ter_o_table, r0, (r5) ; try move rest of data
	bvs	check_esc_csi		; another ESCape/CSI, go process it
50$:	rsb				; exit

60$:	incl	r3			; advance the remaining pointer
	decl	r2			;  and decrement the remaining count
	bneq	70$			; more to look at, go exit
	movab	40$, (sp)		; no more, change return to finish up
	cmpw	r0, #ttobfl		; about to re-buffer the whole buffer?
	bgequ	70$			; yep, don't, it's junk anyway...
	movl	r5, (sp)		; else save dst ptr (clobber return)
	movc	r0, (r1), ttobuf	; re-buffer unfinished ESCape/CSI seq
	movab	(r3), ttoptr		;  setting a new buffering pointer
	; How about CTRL/O and/or Binary Output?
	movl	(sp)+, r5		; restore destination pointer
70$:	rsb				; exit

tec$output_ast:				; terminal output done ast comes here
	.word	^m<>

	cmpw	@4(ap), #ss$_controlc	; completed under control/c?
	bneq	10$			; nope
	mcomb	#0, w^ctrlo_flag	; say control/o is now in effect
	$cancel_s -			; cancel all pending I/O
		chan=w^ter_o_chan	;  on the terminal output channel
	bsbw	success_or_announce	; announce any failure...
10$:	decb	w^ter_o_pend		; one less output request is pending
	bgeq	20$			; other(s) pending, really count it
	incw	ttoint			; else fake the count
20$:	decw	ttoint			; say terminal output completed
	bgeq	30$			; something else is going on, return
	bsbw	tec$output_more		; else try for more output
30$:	ret				; return

.enable	lsb

10$:	incl	r3			; correct the buffer pointer
	tstw	w^output_sys_rab+rab$w_rsz ; yep, anything in the record yet?
	beql	30$			; nothing there
20$:	bsbb	50$			; else clear out the buffer
30$:	incb	w^output_sys_vfc	; indicate 1 more <LF> of prefix
	bgtr	90$			; go continue if < 128 <LF>'s
	decb	w^output_sys_vfc	; else back to only 127 <LF>'s
	brb	20$			;  and go dump that record first

40$:	movb	#<1@7>!13, w^output_sys_vfc+1 ; indicate a <CR> as postfix
	pushab	b^90$			; set to loop after record output
50$:	movab	w^output_sys_buf, w^output_sys_rab+rab$l_rbf ; reset pointer
	$put -				; put a record
		rab=w^output_sys_rab	;  to sys$output
	movl	w^output_sys_rab+rab$l_stv, w^err_msgvec+8 ; save STV value
	clrw	w^output_sys_rab+rab$w_rsz ; always reset the record length
	clrw	w^output_sys_vfc	;  and the print control information
	brw	success_else_die	; check for success completion; exit

60$:	pushr	#^m<r2,r3>		; save r2 & r3
	movl	r1, r2			; move count over to here
	movab	ttobuf, r3		; get terminal output buffer pointer
70$:	cmpb	(r3)+, #13		; is this a <CR>?
	beql	40$			; yes, go set postfixing
	cmpb	-(r3), #10		; is this a <LF>?
	beql	10$			; yes, go set prefixing
	cmpw	w^output_sys_rab+rab$w_rsz, #output_sys_siz ; room left?
	blssu	80$			; yep
	bsbb	50$			; nope, must dump this buffer
80$:	movb	(r3)+, @w^output_sys_rab+rab$l_rbf ; store a byte in buffer
	incl	w^output_sys_rab+rab$l_rbf ; bump the record buffer pointer
	incw	w^output_sys_rab+rab$w_rsz ;  and count in record length
90$:	sobgtr	r2, 70$			; loop if more to go...
	popr	#^m<r2,r3>		; restore r2 & r3
100$:	decw	ttoint			; take away the buffer interlock
	rsb				; exit

tec$output:				; terminal output initiation
	bisw	#2, b^outdne(r11)	; say some output was done
tec$output_more:			; more terminal output initiation
	incw	ttoint			; interlock the terminal output buffer
	addw3	s^#io$_writevblk, ttomod, r0 ; form function code
	subl3	#ttobuf, ttoptr, r1	; get byte count in output buffer
	clrw	ttomod			; reset the terminal output mode
	movab	ttobuf, ttoptr		;  and empty terminal output buffer
	bbc	s^#io$v_canctrlo, r0, 110$ ; canceling control/o?
	clrb	w^ctrlo_flag		; yes, so cancel it
110$:	tstl	r1			; anything to output?
	bleq	100$			; nothing there...
	tstw	w^ter_o_chan		; do we have a real terminal?
	beql	60$			; nope
	tstb	w^ctrlo_flag		; yep, but is control/o in effect?
	bneq	100$			; that it is, junk this output...
	pushr	#^m<r2,r3,r4,r5>	; save r2 through r5
	movaq	w^ter_o_status1, r2	; guess at terminal output iosb #1
	movab	w^ter_o_buf1, r3	;  and terminal output buffer #1
	tstw	(r2)			; is that iosb currently in use?
	bneq	120$			; nope, so use it
	movaq	w^ter_o_status2, r2	; else use terminal output iosb #2
	movab	w^ter_o_buf2, r3	;  and terminal output buffer #2
120$:	pushr	#^m<r0,r2,r3>		; save function, iosb, and buffer
	movtuc	r1, ttobuf, #27, w^ter_o_table, r1, (r3) ; move data to buffer
	bvc	130$			; nothing special...
	bsbw	check_esc_csi		; else go check ESCape/CSI sequences
130$:	popr	#^m<r0,r2,r3>		; restore function, iosb, and buffer
	subl3	r3, r5, r1		;  and (re-)calculate the byte count
	bleq	160$			; nothing left, just go exit...
	incb	w^ter_o_pend		; one more output request is pending
	bleq	140$			; but only one, don't say busy
	incw	ttoint			; else say terminal output now busy
140$:	pushl	#0			; preset no carriage control next time
	bbs	#1, w^ter_o_force, 150$	; are <LF>'s being forced out?
	cmpb	-1(r3)[r1], #10		; does the buffer end with a <LF>?
	bneq	150$			; nope
	decl	r1			; yep, remove the <LF> from the count
	movl	#<<1@7>!10>@16, (sp)	;  and set <LF> prefix for next time
150$:	$qio_s -			; start the terminal output write
		efn=#1, -		;  using this event flag
		chan=w^ter_o_chan, -	;  using the terminal's channel
		func=r0, -		;  using the correct function
		iosb=(r2), -		;  using this iosb
		astadr=tec$output_ast, - ;  catch the output completion
		astprm=r2, -		;  passing the iosb pointer
		p1=(r3), -		;  from this output buffer
		p2=r1, -		;   with this byte count
		p4=w^ter_o_cc		;  using this carriage control
	movl	(sp)+, w^ter_o_cc	; set carriage control for next time
	bsbw	success_else_die	; check for success completion
160$:	popr	#^m<r2,r3,r4,r5>	; restore r2 through r5
	decw	ttoint			; take away the buffer interlock
	rsb				; exit

.disable lsb

.sbttl	Terminal input

.enable	lsb

10$:	tstw	w^ter_i_chan		; have a real terminal?
	bneq	110$			; yep
	clrl	-(r7)			; ensure the input buffer is empty
	moval	w^input_sys_fab, r6	; get the sys$input fab pointer
	bsbw	getbyt			; get the next byte
	cmpl	r0, #rms$_eof		; end-of-file?
	beql	50$			; yep
	bsbw	success_or_abrt		; else check for success completion
	bbc	s^#io$v_cvtlow, r8, 20$	; converting lower case?
	cmpb	r1, #^a/A/+32		; yep, is it lower case?
	blssu	20$			; not lower case
	cmpb	r1, #^a/Z/+32		; might be...
	bgtru	20$			; but it isn't
	bicb	#32, r1			; make lower case into upper case
20$:	movzbl	r1, i_r0(r10)		; copy character to here
	clrl	w^ctrlz_cnt		;  and clear control/z counter
30$:	bbs	s^#io$v_noecho, r8, 40$	; skip echo if not echoing
	cmpb	i_r0(r10), #127		; is the terminator a delete?
	beql	40$			; yep, delete's are echoed elsewhere
	movzbl	i_r0(r10), r6		; get the character to echo
	bsbw	echo_char		;  and go fully echo it
40$:	brw	190$			; go check out the input

50$:	movzbl	#^a/Z/-64, i_r0(r10)	; set a control/z
	aoblss	#3, w^ctrlz_cnt, 30$	; continue if not third control/z
60$:	movaw	texit, i_pc(r10)	; set for exiting from teco
	brb	90$			;  and go exit

70$:	bisw3	(r6), 4(r6), r0		; any character(s) or terminator(s)?
	bneq	130$			; yep, so go use them...
	mnegw	#1, i_r0(r10)		; return a -1 for no input
	clrl	-(r7)			; ensure the input buffer is empty
	brw	200$			;  and go exit

80$:	movaw	teco, i_pc(r10)		; set for restarting teco
90$:	clrl	w^ter_i			; ensure the input buffer is empty
	rsb				;  and exit

100$:	blbs	r0, 130$		; call a random success normal...
	tstw	-(r6)			; correct the iosb pointer
110$:	movl	w^ter_i_nor_trm_ptr, r1	; guess at the normal terminator mask
	bbc	s^#io$v_timed, r8, 120$	; checking for type ahead?
	movaq	w^ter_i_any_trm, r1	; use the anything terminator mask
120$:	$qiow_s -			; do a terminal input read
		chan=w^ter_i_chan, -	;  using the terminal input channel
		func=r8, -		;  using the correct function
		iosb=(r6), -		;  put i/o status here on completion
		p1=@(r7), -		;  using the terminal input buffer
		p2=r9, -		;   with the correct length
		p3=#0, -		;  using an immediate timeout value
		p4=r1			;  using correct terminator mask
	bsbw	success_or_abrt		; check for success completion
	movzwl	(r6)+, r0		; get the completion code
	cmpw	r0, #ss$_timeout	; a timed out operation?
	beql	70$			; yes, go return a -1 to user
	cmpw	r0, #ss$_controlc	; was control/c typed?
	bneq	100$			; none of the above...
	mcomb	w^ctrlc_flag, w^ctrlc_flag ; flip the control/c flop
	beql	60$			; it flopped, exit from teco
	bbc	#tec$v_et$cc, i_r0(r10), 80$ ; allowing return of control/c?
	movw	#1, (r6)		; set data count = 1
	clrl	2(r6)			;  and no terminator(s)
	movb	#^a/C/-64, @(r7)	;   then buffer a control/c
130$:	movzwl	(r6)+, -(r7)		; set count of characters obtained
	beql	140$			; none
	clrl	w^ctrlz_cnt		; some, reset control/z counter
	bbs	s^#io$v_noecho, r8, 140$ ; did they echo?
	bisw	#2, b^outdne(r11)	; echoed, so say so
140$:	movzwl	2(r6), r0		; get the terminator's length
	beql	180$			; no length, so no terminator(s)
	addl3	(r7)+, (r7), r1		; else point just beyond the data
	movzbl	(r1), r6		; get the terminator itself
	addl	r0, -(r7)		; now count the terminator(s)
	cmpb	r6, #^a/Z/-64		; control/z?
	bneq	150$			; no
	aoblss	#3, w^ctrlz_cnt, 160$	; continue if not third control/z
	brw	60$			; else go exit from teco

150$:	clrl	w^ctrlz_cnt		; no, reset control/z counter
160$:	cmpb	r6, #13			; carriage return?
	bneq	170$			; no
	incl	(r7)			; yes, count 1 more in buffer
	addl3	(r7)+, (r7), r7		; find position for line feed
	movb	#10, -(r7)		;  and store it also
	bbs	s^#io$v_noecho, r8, 180$ ; skip echo if not echoing
	bsbw	echo_buffer		; yes, echo the carriage return
	movzbl	#10, r6			;  and set to echo a line feed
170$:	bbs	s^#io$v_noecho, r8, 180$ ; skip echo if not echoing
	cmpb	r6, #127		; is the terminator a delete?
	beql	180$			; yep, delete's are echoed elsewhere
	bsbw	echo_char		; else fully echo the terminator
tec$input:				; terminal input
	bs	s^#io$v_canctrlo, ctlofg ; do a control/o cancel
	bbcc	#1, i_r0(r10), 180$	; main prompt call?
	clrl	w^ctrlz_cnt		; yes, reset control/z counter
180$:	movaq	w^ter_i, r7		; get terminal input buffer desc
	decl	(r7)+			; remove one character from buffer
	blss	230$			; nothing left, go get some more
	movzbl	@(r7)+, i_r0(r10)	; else get the character
	incl	-(r7)			;  and bump the buffer pointer
190$:	movzbl	i_r0(r10), r0		; get character about to be returned
	bsbw	tecoexelbr		;  and go check it
	beql	200$			; there was nothing there...
	blbc	r0, 220$		; there's some kind of error...
	movaw	tecocr, i_pc(r10)	; set to re-start TECO w/ <CR><LF>
200$:	clrb	w^ctrlc_flag		; turn off control/c exit flag if here
	rsb				;  and exit

210$:	movzbl	#27, i_r0(r10)		; set final initial command <ESC>
	brb	200$			;  and go exit with it...

220$:	movl	r1, w^err_msgvec+8	; save any STV value
	movaw	ioerrs, i_pc(r10)	; set exit to teco's error processor
	clrl	i_r4(r10)		;  with R4 = 0 for filename exists
	brw	success_or_err		; now go die with the error...

230$:	movzwl	b^indir(r11), r6	; is an indirect command file active?
	beql	240$			; nope
	cmpl	r6, #2			; really?
	bgtru	300$			; a real indirect command file...
	decw	b^indir(r11)		; "funny"(1) or initial command(2)?
	bneq	210$			; initial command, it's now "funny"(1)
240$:	bsbw	tec$wait_done_lf	; wait for terminal output to complete
	bsbw	not_exiting		; not exiting if doing terminal input
	movaq	w^ter_i_nor7_trm, w^ter_i_nor_trm_ptr ; mask to 7-bit normal
	bbc	#tec$v_et$8bt, b^etype(r11), 250$ ; is it an 8-bit terminal?
	movaq	w^ter_i_nor8_trm, w^ter_i_nor_trm_ptr ; mask to 8-bit normal
250$:	movab	w^ter_i_buf, (r7)	; reset terminal input buffer pointer
	movaq	w^ter_i_status, r6	; get pointer to terminal input iosb
	movzwl	#io$_readvblk! -	; set function as read virtual,
		io$m_nofiltr! -		;		no filtering,
		io$m_trmnoecho! -	;		no terminator echo,
		io$m_dsablmbx, r8	;		keep any mailbox off
	movzwl	#ter_i_siz-1, r9	; set terminal input buffer size
	bbs	#tec$v_et$lc, b^etype(r11), 260$ ; allowing lower case?
	bs	s^#io$v_cvtlow, r8	; no, so don't
260$:	bbc	#tec$v_et$nch, i_r0(r10), 270$ ; echoing?
	bs	s^#io$v_noecho, r8	; no, so don't
270$:	bbc	#tec$v_et$cke, i_r0(r10), 280$ ; checking type ahead?
	bs	s^#io$v_timed, r8	; yes, so do
280$:	blbc	i_r0(r10), 290$		; single character input mode?
	movl	#1, r9			; yes, so buffer size is 1 character
290$:	brw	10$			; long branch for real terminal input

300$:	clrl	-(r7)			; ensure the input buffer is empty
	moval	w^indir_cmd_fab, r7	; address the "ei" fab
	movl	fab$l_tecsts(r7), r8	; save original "pre-fetched" char/flag
	bs	#fab$v_tecnxt, fab$l_tecsts(r7) ; guess at "pre-fetch" working
	movl	(r6), r6		; get "ei" fab pointer
	beql	310$			; none?
	bsbw	getbyt			; get the next character
	cmpl	r0, #rms$_normal	; normal completion?
	beql	320$			; yep, character was "pre-fetched"
310$:	bc	#fab$v_tecnxt, fab$l_tecsts(r7) ; say nothing "pre-fetched"
	bsbw	reset_indir		; close the indirect file
	incw	b^indir(r11)		;  then mark as "funny"(1)
320$:	movb	r1, fab$l_tecsts+3(r7)	; save (possible) "pre-fetch" character
	bbs	#fab$v_tecnxt, r8, 330$	; originally have "pre-fetched" data?
	brw	180$			; nope, go loop to try again...

330$:	extzv	#24, #8, r8, i_r0(r10)	; set the "pre-fetched" character
	brw	190$			;  and go check it out...

.disable lsb

.sbttl	Echoing, etc.

.entry	tec$out_ascid, ^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11> ; output by desc

	movaw	r5set, r11		; (re-)point to teco's read/write area
	movq	@4(ap), r7		; get string's descriptor
	movzwl	r7, r7			;  and get real string length
	beql	20$			; null string, just do the <CR><LF>
10$:	movzbl	(r8)+, r6		; fetch next string character
	bsbb	echo_buffer		;  and output buffer it
	sobgtr	r7, 10$			;   then loop for more...
20$:	bsbb	echo_crlf		; now go do the <CR><LF>
	movl	#1, r0			; set the success return status
	tstb	w^ctrlo_flag		; is control/o in effect?
	beql	30$			; nope
	clrl	r0			; yep, change return status to failure
30$:	ret				; return

echo_crlf:				; buffer and dump a <CR><LF>
	movzbl	#13, r6			; set a <CR>
	bsbb	echo_buffer		;  and go output it
echo_lf:				; buffer and dump a <LF>
	movzbl	#10, r6			; set a <LF>
echo_char:				; buffer and dump a character
	pushab	w^echo_dump		; dump buffer after buffering
echo_buffer:				; buffer a echo character
	bbs	#7, r6, 20$		; a "negative" character?
	cmpb	r6, #32			; a control character?
	bgequ	echo_byte		; nope
	cmpb	r6, #13			; carriage return or higher
	bgtru	40$			; it's higher
	cmpb	r6, #7			; bell or lower?
	bgtru	echo_byte		; it's bs, tab, lf, vt, ff, or cr
	blssu	10$			; lower than bell
	bsbb	echo_byte		; it's bell, ring the bell first
10$:	pushl	r6			; save character
	movzbl	#^a/^/, r6		; prefix with an "^"
	bsbb	echo_byte		; go output the "^"
	bisl3	#64, (sp)+, r6		; restore character making it visible
	brb	echo_byte		;  and go output it

20$:	movzwl	#<^a/[/@8>+^a/]/, r1	; guess at hex digits trailing/leading
	cvtwl	cnv8bt-256[r6], r0	; get the conversion character pair
	blss	30$			; it's hex digits (<15> = 1)
	bbs	#tec$v_et$8bt, b^etype(r11), echo_byte ; 8-bit terminal?
	movzwl	#<^a/</@8>+^a/>/, r1	; set compose sequence trailing/leading
30$:	movq	r0, -(sp)		; save our special characters
	movzbl	5(sp), r6		; get the leading signal
	bsbb	echo_byte		;  and go output it
	movzbl	(sp), r6		; get the first of the character pair
	bsbb	echo_byte		;  and go output it
	extzv	#8, #7, (sp), r6	; get the second of pair (w/ <7> = 0)
	bsbb	echo_byte		;  and go output it
	movzbl	4(sp), r6		; get the trailing signal
	addl	#8, sp			; pop our special characters from stack
	brb	echo_byte		; go output trailing signal & exit

40$:	cmpb	r6, #27			; escape?
	bneq	10$			; nope, use an uparrow
	movzbl	#^a/$/, r6		; yep, use "$"
echo_byte:				; buffer a echo byte
	cmpw	ttoptr, #ttobuf		; is the terminal output buffer empty?
	beql	30$			; yes, always o.k. to buffer, etc.
	cmpw	ctlofg, ttomod		; mode correct?
	beql	10$			; it's totally correct
	cmpw	#io$m_canctrlo, ttomod	; mode correct (control/o cancel)?
	bneq	20$			; nope, must be really changing modes
10$:	cmpw	ttoptr, #ttobuf+ttobfl	; any room to buffer a character?
	blssu	30$			; room left, just go buffer character
20$:	tstw	ttoint			; is output currently in progress?
	bgeq	40$			; yes, we must wait for it to finish
	bsbw	tec$output		; no, start it going...
30$:	incw	ttoint			; interlock the terminal output buffer
	bisw	ctlofg, ttomod		; .OR. any control/o cancel into mode
	clrw	ctlofg			; clear out control/o cancel request
	bc	#tec$v_et$cco, b^etype(r11) ;  and say we did it
	movb	r6, @ttoptr		; store the character in the buffer
	incw	ttoptr			;  then bump the buffer pointer
	decw	ttoint			;   and take away the buffer interlock
	rsb				; exit

40$:	bsbw	tec$wait		; go wait for output to finish
	brb	echo_byte		;  then try, try again...

.sbttl	Process line/character deletion echoing

.enable	lsb

tec$delln:				; control/u handler
	bbs	#tec$v_et$crt, b^etype(r11), 40$ ; scope mode?
10$:	movzbl	#13, r6			; do tty compatible, set <cr>
	bsbw	echo_buffer		;  and output it
	movzbl	#10, r6			; set <lf>
20$:	brw	echo_char		; go fully echo the character

30$:	subl	#2, i_sp(r10)		; 'push' the sp stack
	movw	i_pc(r10), @i_sp(r10)	;  and move return onto it
	movaw	prtlin, i_pc(r10)	; set line re-print as the new exit
40$:	movzwl	crterl, r7		; get erase line sequence base
	bsbb	70$			;  and go do it
	movzwl	crtcup, r7		; get cursor up sequence base
	bsbb	70$			;  and go do that also
	brb	10$			; now go do a <cr><lf>

tec$delch:				; delete handler
	movzbl	i_r0(r10), r6		; get the deleted character
	bbc	#tec$v_et$crt, b^etype(r11), 20$ ; scope mode?
	movl	#1, r8			; set count for 1 erase sequence
	bbs	#7, r6, 100$		; a "negative" character?
	cmpb	r6, #32			; normal graphic?
	bgequ	120$			; yes, 1 sequence
	cmpb	r6, #27			; escape?
	beql	120$			; yes, 1 sequence
	incl	r8			; no, set count for 2 sequences
	cmpb	r6, #13			; is it carriage return or higher?
	bgtru	120$			; higher, do 2 sequences
	beql	30$			; it's carriage return, re-print line
	cmpb	r6, #7			; is it bell or lower?
	blequ	120$			; that it is, do 2 sequences
	cmpb	r6, #10			; check around line feed
	blssu	30$			; it's backspace or tab, re-print line
	beql	60$			; it's line feed, do 1 cursor up
	cmpb	r6, #12			; check around form feed
	blssu	50$			; it's vertical tab, do 2 cursor ups
	bsbb	50$			; do 2 cursor ups, fall to do 2 more
50$:	bsbb	60$			; do 1 cursor up, fall to do another
60$:	movzwl	crtcup, r7		; get cursor up sequence base
70$:	addw	b^crtype(r11), r7	; find correct sequence pointer
	movzwl	(r7), r7		;  and get pointer to count, string
	movzbl	(r7)+, r8		; pickup the count, correct pointer
80$:	movzbl	(r7)+, r6		; get a character
	bsbw	echo_byte		;  and output it
	sobgtr	r8, 80$			;   then loop for more...
echo_dump:				; dump the buffered echoing
	tstw	ttoint			; is terminal output buffer free?
	bgeq	90$			; nope, go exit
	cmpw	ttoptr, #ttobuf		; yep, anything buffered therein?
	beql	90$			; nothing there, go exit
	bsbw	tec$output		; else start that output going
90$:	rsb				; exit

100$:	tstw	cnv8bt-256[r6]		; check the conversion table entry
	blss	110$			; it's hex digits (<15> = 1)
	bbs	#tec$v_et$8bt, b^etype(r11), 120$ ; 8-bit terminal?
110$:	movl	#4, r8			; we must do 4 erase sequences
120$:	bsbw	tec$wait		; wait for all output to be queued
	$qiow_s -			; queue an i/o request with wait
		chan = w^ter_o_chan, -	;  on the terminal write channel
		func = s^#io$_writevblk, - ;  with a write function code
		iosb = w^ter_o_pos	;  so we can get horizontal position
	movzbl	w^ter_o_pos+6, r0	; extract the 1 based position
	beql	130$			; a zero, no position, skip it
	cmpl	r0, r8			; are we looking at a line wrap?
	bgtr	130$			; nope
	movzwl	crterl, r7		; get erase line sequence base
	bsbb	160$			;  and go to do it
	movzwl	crtcup, r7		; get cursor up sequence base
	bsbb	160$			;  and go to do that also
	brw	30$			; now go really do it...

130$:	cmpl	r8, #2			; how many sequences do we need?
	blss	150$			; 1
	beql	140$			; 2
	bsbb	140$			; we need 4 sequences
140$:	bsbb	150$			; we need 2 sequences
150$:	movzwl	crterc, r7		; get erase character sequence base
160$:	brw	70$			; go do the sequence, then exit

.disable lsb

.sbttl	Page backwards

.enable	lsb

10$:	err	NFI, <"No file for input">

20$:	err	NFO, <"No file for output">

tec$bakup:				; page backwards
	movzwl	b^inpntr(r11), r6	; get pointer to input file pointer
	movl	(r6), r6		;  then get input file fab pointer
	beql	10$			; no file...
	pushl	r6			; save input file fab pointer
	movzwl	b^oupntr(r11), r6	; get pointer to output file pointer
	movl	(r6), r6		;  then get output file fab pointer
	beql	20$			; no file...
	pushaq	@fab$q_tecque+4(r6)	; save current last buffer pointer
	pushl	r6			; save output file fab pointer
	bsbw	tec$putbf		; now go dump the text buffer
	movl	(sp)+, r6		; get back output file fab pointer
	bbs	#fab$v_tecbuf, fab$l_tecsts(r6), 30$ ; already into buffering?
	$rewind -			; rewind the output file
		rab=@fab$l_tecrab(r6)	;  so we can re-write it later
	bsbw	success_or_err		; check for success completion
	bs	#fab$v_tecbuf, fab$l_tecsts(r6) ; indicate data is buffered
30$:	mnegw	i_r4(r10), r0		; get number of pages to back up
	movq	(sp)+, r1		; get start pointer & input fab pointer
	movaq	fab$q_tecque(r6), r3	; address the output queue's root
40$:	cmpl	r1, r3			; have we backed up to the top?
	beql	50$			; yep, must exit the loop early
	movl	4(r1), r1		; else link backwards to the next
	decw	r0			; should we look at it?
	bgtr	40$			; yes, so loop...
50$:	mnegw	r0, i_r4(r10)		; return any remaining count
60$:	cmpl	r1, fab$q_tecque+4(r6)	; have we finished pruning?
	beql	70$			; yes
	remque	@fab$q_tecque+4(r6), r0	; no, remove a buffer from output tail
	insque	(r0), fab$q_tecque(r2)	;  and add it to input queue beginning
	bs	#fab$v_tecbuf, fab$l_tecsts(r2) ; say using buffered data now
	brb	60$			; loop for the next buffer...

70$:	rsb				; exit

.disable lsb

.sbttl	Get input

.enable	lsb

10$:	err	NFI, <"No file for input">

20$:	incl	fab$l_tecsts(r6)	; set internal end-of-file indicator
.assume	fab$m_teceof eq 1
	$close -			; close
		fab=(r6)		;  the file
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
	bsbw	success_or_err		; check for success completion
30$:	mcomw	#0, b^eoflag(r11)	; set end-of-file flag
	rsb				;  and exit

40$:	bbc	#fab$v_tecb2, fab$l_tecsts(r6), 50$ ; /b2 mode?
	bsbw	150$			; yes, go do trailing trims
50$:	mcomw	#0, b^ffflag(r11)	; set form feed flag
	rsb				;  and exit

tec$getbf:				; get input
	clrw	b^eoflag(r11)		; preset not at end-of-file
	clrw	b^ffflag(r11)		; preset no form feed at buffer's end
	movzwl	b^inpntr(r11), r6	; get pointer to input file pointer
	movl	(r6), r6		;  then get input file fab pointer
	beql	10$			; no file
	movl	i_r0(r10), r7		; get buffer pointer
	movl	i_r1(r10), r8		;  and room counter
	beql	120$			; no room at all, we'd better exit...
60$:	decl	r8			; count down the room counter
70$:	bbs	#fab$v_tecbuf, fab$l_tecsts(r6), 80$ ; never eof if buffering
	blbs	fab$l_tecsts(r6), 30$	; keep saying end-of-file if true
.assume	fab$m_teceof eq 1
80$:	bsbw	getbyt			; get the next character
	cmpl	r0, #rms$_eof		; end-of-file?
	beql	20$			; yep, so quit
	bsbw	success_or_err		; else check for success completion
	bbc	#fab$v_tecb2, fab$l_tecsts(r6), 90$ ; /b2 mode?
	cmpb	r1, #13			; a <cr>?
	beql	70$			; yep, ignore the <cr> (for now...)
90$:	cmpb	r1, #12			; it is <ff>?
	beql	40$			; yep, we're done
	movb	r1, (r7)+		; nope, store in the text buffer
	incw	b^zz(r11)		;  and count it as stored
	cmpb	r1, #10			; <lf>?
	bneq	110$			; nope
	bbc	#fab$v_tecb2, fab$l_tecsts(r6), 100$ ; /b2 mode?
	bsbb	130$			; yes, go do trailing trims
	movw	#13+<10@8>, (r7)+	; store closing <cr><lf>
	addw	#2, b^zz(r11)		;  and count the added <cr><lf>
	subl	#2, r8			;   then decrease the free space
100$:	cmpl	r8, i_r2(r10)		; how's room doing?
	blss	120$			; out of room, we must quit
110$:	cmpl	r8, #128		; down to very small??
	bgtr	60$			; nope, loop for more...
120$:	rsb				; exit

130$:	decl	r7			; backup the buffer pointer
140$:	decw	b^zz(r11)		; remove a character
	incl	r8			;  and increase the free space
150$:	cmpl	r7, i_r0(r10)		; backed up too far?
	blequ	160$			; yep, we must stop
	cmpb	-(r7), #^a/&/		; trailing "&"?
	beql	140$			; yes, remove it
	cmpb	(r7), #32		; trailing space?
	beql	140$			; yes, remove it also
	cmpb	(r7)+, #9		; trailing <tab>?
	beql	130$			; yes, that gets removed too
160$:	rsb				; exit

.disable lsb

.sbttl	Put output

dump_data:				; dump buffered data
	.word	^m<r2,r3,r4,r5,r6,r7,r8,r9>
	movq	fab$q_tecque(r6), -(sp)	; replicate the queue root
	movq	(sp), r0		; address head (R0) and tail (R1)
	movaq	(sp), 4(r0)		; re-link head's back ptr to our copy
	movaq	(sp), (r1)		; re-link tail's forw ptr to our copy
	movaq	fab$q_tecque(r6), fab$q_tecque(r6) ; reset the real
	movaq	fab$q_tecque(r6), fab$q_tecque+4(r6) ;  queue root
10$:	remque	@-8(fp), r0		; remove next item from the queue
	bvs	20$			; nothing more...
	pushl	r0			; else save pointer to removed hunk
	movl	8+4+4(r0), r3		; address the data
	movl	8+4(r0), r4		;  and get its count
	clrl	r9			; don't add any <ff>
	bsbw	put_buffer		; now go put it out
	movl	(sp)+, r0		; get back pointer to removed hunk
	calls	#0, w^free_data		;  and free it up
	brb	10$			;   then loop for the next...

20$:	ret				; return

save_data:				; save the put buffer data
	.word	^m<r2,r3,r4,r5>
	clrq	-(sp)			; make room for LIB$GET_VM args
10$:	locc	#12, r4, (r3)		; is there an embedded <ff>?
	beql	20$			; nope
	subl3	r0, r4, r2		; yep, find this hunk's size
	incl	r2			;  including the <ff>
	bsbb	60$			; go allocate and load a buffer
	addl	r2, r3			; bump pointer over this hunk
	subl	r2, r4			;  and skip it in the count
	bneq	10$			; loop if there's more to look at...
20$:	tstl	r9			; a trailing <ff> to add?
	beql	30$			; nope
	incl	r4			; yep, so count it in the count
30$:	movl	r4, r2			; now use the remaining count
	beql	40$			; nothing remaining...
	bsbb	60$			; go allocate and load the buffer
	tstl	r9			; are we adding a <ff>?
	beql	40$			; nope
	movb	#12, 8+4+8-1(r1)[r2]	; yep, load in the <ff>
40$:	movl	#1, r0			; set success
50$:	ret				; exit

60$:	addl3	#8+4+8, r2, -8(fp)	; set hunk size w/ overhead included
	pushal	-4(fp)			; stack address of (returned) address
	pushal	-8(fp)			; stack address of size
	calls	#2, g^lib$get_vm	; go allocate virtual memory
	blbc	r0, 50$			; exit if any error...
	movl	-4(fp), r1		; address the allocated new memory
	pushr	#^m<r0,r1,r2,r3,r4,r5>	; save the MOVC clobbered registers
	insque	(r1), @fab$q_tecque+4(r6) ; insert new hunk onto queue's tail
	movl	-8(fp), 8(r1)		; load total size of hunk into hunk
	movl	r2, 8+4(r1)		; load data size of hunk into hunk
	movab	8+4+8(r1), 8+4+4(r1)	; load data address of hunk into hunk
	movc	r2, (r3), 8+4+8(r1)	; load data itself into hunk
	popr	#^m<r0,r1,r2,r3,r4,r5>	; restore the MOVC clobbered registers
	rsb				; exit

.enable	lsb

10$:	err	NFO, <"No file for output">

tec$putbf:				; put output
	movl	i_r0(r10), r3		; get text buffer pointer
	movl	i_r1(r10), r4		;  and character count
	movl	i_r2(r10), r9		; put emit <ff> flag here
put_buffer:				; internal put output
	movzwl	b^oupntr(r11), r6	; get pointer to output file pointer
	movl	(r6), r6		;  then get output file fab pointer
	beql	10$			; no file
	movl	fab$l_tecrab(r6), r7	; file, get the rab pointer
	calls	#0, save_data		; go save the put buffer data
	bsbw	success_or_err		; check for success completion
	bbc	#fab$v_tecbuf, fab$l_tecsts(r6), 20$ ; proceed if not buffering
	rsb				; else exit...

20$:	movl	r3, r1			; save starting position
	clrl	r2			;  and reset count
30$:	decl	r4			; more to look at?
	blss	130$			; nope
	incl	r2			; yep, count another character
	cmpb	(r3)+, #12		; <ff> or higher?
	bgtru	30$			; higher, keep looking...
	cmpb	-1(r3), #10		; <lf> or lower?
	blssu	30$			; lower, keep looking...
	bneq	110$			; higher, it's <vt> or <ff>, do record
	bitb	#fab$m_cr!fab$m_ftn, fab$b_rat(r6) ; lf/cr and/or ftn cc?
	beql	110$			; no, so no additions, etc., do record
	cmpl	r2, #1			; anything before the <lf>?
	bleq	110$			; nope, go do a record
	cmpb	-2(r3), #13		; yep, it it a <cr>?
	bneq	110$			; no, do a record also
	cmpl	r2, #2			; anything before the <cr><lf>?
	bleq	40$			; nope
	cmpb	-3(r3), #27		; yep, is it <esc><cr><lf>?
	beql	110$			; it is, don't remove <cr><lf>, etc.
40$:	subl	#2, r2			; take away the <cr><lf>
	bbc	#fab$v_tecb2, fab$l_tecsts(r6), 110$ ; /b2 mode?
	tstl	r2			; anything in the record?
	beql	50$			; nope
	cmpb	-3(r3), #^a/&/		; yep, is it <&><cr><lf>?
	beql	110$			; that it is, go output as is
50$:	tstl	r4			; more to come?
	bleq	100$			; nope, but check for <ff> coming
	cmpb	(r3), #^a/0/		; is next a digit?
	blssu	60$			; non-digit, add "&" to record
	cmpb	(r3), #^a/9/		; really a digit?
	blequ	110$			; yes, a digit next, go do the record
60$:	movw	-(r3), -(sp)		; save the <cr><lf> from text buffer
	movw	#9+<^a/&/@8>, (r3)	; guess at adding <tab><&> to record
	cmpl	r2, #7			; already across the first tab stop?
	bgtr	80$			; yep, change that to <space>
	movl	r1, r5			; else copy pointer to record
70$:	cmpl	r5, r3			; are we up to record's end?
	bgequ	90$			; yes, no <tab> in record
	cmpb	(r5)+, #9		; is this a <tab>?
	bneq	70$			; not a <tab>, keep looking
80$:	movb	#32, (r3)		; change to adding <space><&>
90$:	addl	#2, r2			; we added 2 characters to record
	bsbb	150$			; go put the new record
	movw	(sp)+, (r3)+		; restore <cr><lf> into text buffer
	brb	120$			;  and go check for normal completion

100$:	tstl	r9			; a <ff> coming?
	bneq	60$			; yes, go add "&" to record
110$:	bsbb	150$			; go put that record
120$:	bsbw	success_or_err		; check for success completion
	brw	20$			;  then loop...

130$:	tstl	r9			; add a <ff>?
	beql	140$			; nope
	movb	(r3), -(sp)		; yep, save the next byte
	movb	#12, (r3)		;  then make it a <ff>
	incl	r2			;   and count that <ff>
	bsbb	150$			; go put the final record
	movb	(sp)+, (r3)		; restore the next byte
	brw	success_or_err		; check for success completion & exit

140$:	tstl	r2			; any size?
	beql	170$			; nope
	pushab	w^success_or_err	; check for success completion on exit
150$:	movl	r1, rab$l_rbf(r7)	; set starting address of record
	movw	r2, rab$w_rsz(r7)	;  and record's size
	clrl	r8			; clear our "over quota" flag
160$:	$put -				; put a record
		rab=(r7)		;  to the file
	movl	rab$l_stv(r7), w^err_msgvec+8 ; save the STV value
	blbs	r0, 170$		; all done if no error
	bbcs	#0, r8, 180$		; really an error if second time
170$:	rsb				; exit

180$:	cmpl	rab$l_stv(r7), #ss$_exdiskquota ; is it the quota error?
	bneq	170$			; nope, a real true error
	bs	s^#io$v_canctrlo, ctlofg ; do a control/o cancel
	pushaq	w^quota_msg_desc	; set the quota exceeded message
	calls	#1, w^tec$out_ascid	;  and go output it
	brb	160$			; now go try, try again...

.disable lsb

.sbttl	Get an input byte

.enable	lsb

getbyt_emit_ctl:			; emit a control character
	bicl	#^c<<1@6>!31>, r1	; trim to 8-bit flag & control char
	bbcc	#6, r1, 10$		; use 7-bit set control if <6>=0
	bs	#7, r1			; else use 8-bit set control
	brb	10$			;  and go emit it

getbyt_emit_cr:				; emit a <cr>
	movzbl	#13, r1			; set the <cr>
	brb	10$			;  then go emit it

getbyt_emit_lf:				; emit a <lf>
	movzbl	#10, r1			; set the <lf>
10$:	movl	(sp)+, fab$l_tecdsp(r6)	; set the next dispatch address
	rsb				; exit

20$:	bbc	#fab$v_prn, fab$b_rat(r6), 40$ ; br if not print file format
	cmpl	r0, #rms$_eof		; end-of-file?
	bneq	40$			; nope, other error
	bbs	#fab$v_tecicr, fab$l_tecsts(r6), 30$ ; just ignored a <cr>?
	cmpb	fab$l_tecctl(r6), #13	; was last character a <cr>?
	bneq	40$			; not a <cr>, nothing more needed...
30$:	bsbb	getbyt_emit_lf		; ignored or last <cr>, go emit a <lf>
	movl	#rms$_eof, r0		; now restore the end-of-file code
40$:	tstl	(sp)+			; pop the return exit
	rsb				;  and exit with error code

getbyt_first:				; initial dispatch entry point
	movab	b^getbyt_first, fab$l_tecdsp(r6) ; set new record dispatch
	movl	fab$l_tecrab(r6), r5	; get the rab pointer
	$get -				; get
		rab=(r5)		;  the next record
	movl	rab$l_stv(r5), w^err_msgvec+8 ; save the STV value
	cmpl	r0, #rms$_normal	; normal completion?
	bneq	20$			; nope, exit with error code
	bbc	#fab$v_prn, fab$b_rat(r6), 90$ ; print file format?
	movw	@rab$l_rhb(r5), fab$l_tecctl+2(r6) ; copy vfc bytes
	cvtbl	fab$l_tecctl+2(r6), r1	; get the 'prefix' byte
	beql	80$			; none
	blss	70$			; a control
	bbss	#fab$v_tecno1st, fab$l_tecsts(r6), 60$ ; first time?
50$:	decb	fab$l_tecctl+2(r6)	; another 'prefix' <cr><lf> to do?
	bleq	100$			; nope, go do the real data
60$:	bsbb	getbyt_emit_cr		; yep, emit a <cr>
	bsbb	getbyt_emit_lf		; emit a <lf>
	brb	50$			; now loop...

70$:	bsbw	getbyt_emit_ctl		; emit a control character
80$:	bs	#fab$v_tecno1st, fab$l_tecsts(r6) ; not first time anymore
	brb	100$			;  then continue

90$:	clrb	fab$l_tecctl+3(r6)	; guess at no carriage control
	bitb	#fab$m_cr!fab$m_ftn, fab$b_rat(r6) ; implied lf/cr or ftn ccl?
	beql	100$			; neither
	incb	fab$l_tecctl+3(r6)	; one or the other, do cr/lf at end
	tstw	rab$w_rsz(r5)		; a null record?
	beql	130$			; yep, no need to process it...
100$:	movab	b^110$, fab$l_tecdsp(r6) ; set dispatch for record data
110$:	movl	fab$l_tecrab(r6), r5	; get the rab pointer
	decw	rab$w_rsz(r5)		; more in the record?
	blss	120$			; nope
	movzbl	@rab$l_rbf(r5), r1	; yep, so get a byte
	incl	rab$l_rbf(r5)		;  and bump the record pointer
	rsb				;   then exit

120$:	cvtbl	fab$l_tecctl+3(r6), r1	; get the 'postfix' byte
	beql	140$			; none
	blss	150$			; a control
	bbs	#fab$v_prn, fab$b_rat(r6), 130$ ; print file format?
	movzbl	fab$l_tecctl(r6), r1	; get last record data byte
	cmpb	r1, #27			; was it escape?
	beql	140$			; it was, no additions
	cmpb	r1, #12			; was it <ff> or higher?
	bgtru	130$			; higher, go add a <cr><lf>
	cmpb	r1, #10			; was it <lf>, <vt>, or <ff>?
	bgequ	140$			; one of the above, no additions
130$:	bsbw	getbyt_emit_cr		; emit a <cr>
	bsbw	getbyt_emit_lf		; emit a <lf>
	decb	fab$l_tecctl+3(r6)	; another 'postfix' <lf> to do?
	bgtr	130$			; yep, so do another
140$:	brw	getbyt_first		; now is the time for a new record...

150$:	bsbw	getbyt_emit_ctl		; emit a control character
	brb	140$			;  then go to the next record

.disable lsb

.enable	lsb

10$:	movl	fab$q_tecque(r6), r0	; get queued data buffer pointer
	movzbl	@8+4+4(r0), r1		; get character from buffer
	incl	8+4+4(r0)		; bump the buffer pointer
	decl	8+4(r0)			; count down the count
	bneq	60$			; more remains, go exit
	remque	@fab$q_tecque(r6), r0	; no more, remove buffer from queue
	bneq	20$			; another buffer remains in the queue
	bc	#fab$v_tecbuf, fab$l_tecsts(r6) ; else turn off buffering
20$:	calls	#0, w^free_data		; go free up the buffer
	brb	60$			; now go exit

30$:	tstb	fab$l_tecctl+1(r6)	; have <cr>, already at left margin?
	bneq	90$			; nope, we need this <cr>
	bs	#fab$v_tecicr, fab$l_tecsts(r6) ; yep, say <cr> ignored...
getbyt:					; get an input byte
	bbs	#fab$v_tecbuf, fab$l_tecsts(r6), 10$ ; is there buffered data?
	bbsc	#fab$v_tececr, fab$l_tecsts(r6), 80$ ; do <lf> if extra <cr>
	jsb	@fab$l_tecdsp(r6)	; else dispatch to proper routine
	bbc	#fab$v_prn, fab$b_rat(r6), 50$ ; br if not print file format
	bc	#fab$v_tecicr, fab$l_tecsts(r6) ; undo <cr> ignored flag
	cmpb	r1, #13			; <cr> or greater?
	bgtru	40$			; greater, normal & no left margin
	beql	30$			; it's <cr>, so left margin
	cmpb	r1, #10			; is it <lf>, <vt>, or <ff>?
	bgtru	50$			; it's <vt> or <ff>
	beql	70$			; it's <lf>, check for needing <cr>
40$:	movb	#1, fab$l_tecctl+1(r6)	; set non-zero for not at left margin
50$:	movb	r1, fab$l_tecctl(r6)	; remember last character returned
60$:	movl	#rms$_normal, r0	; set normal completion
	rsb				;  and exit

70$:	cmpw	r1, fab$l_tecctl(r6)	; 2 <lf>'s at left margin?
	bneq	50$			; nope
	movzbl	#13, r1			; yep, set the missing <cr>
	bbcs	#fab$v_tececr, fab$l_tecsts(r6), 60$ ; emit the extra <cr>
80$:	movzbl	#10, r1			; now (re-)set the <lf>
90$:	clrb	fab$l_tecctl+1(r6)	; indicate left margin
	brb	50$			;  and go exit with <cr> or <lf>

.disable lsb

.sbttl	Switch to alternate output

.enable	lsb

tec$outsv:				; switch output file
	movw	#oupalt, b^oupntr(r11)	; do the pointer switch
set_outputname:				; set output file name, etc.
	movzwl	b^oupntr(r11), r7	; get pointer to output file pointer
	brb	10$			; go set file name, etc.

.sbttl	Switch to alternate input

tec$inpsv:				; switch input file
	movw	#inpalt, b^inpntr(r11)	; do the pointer switch
set_inputname:				; set input file name, etc.
	clrw	b^eoflag(r11)		; guess at not at end-of-file
	movzwl	b^inpntr(r11), r7	; get pointer to input file pointer
10$:	clrb	filsrt			; guess at file closed (no name)
	movl	(r7), r6		; get file's fab pointer
	beql	50$			; file is closed
	bbs	#fab$v_tecbuf, fab$l_tecsts(r6), 20$ ; never eof if buffering
	blbc	fab$l_tecsts(r6), 20$	; branch if not at end-of-file
.assume	fab$m_teceof eq 1
	mcomw	#0, b^eoflag(r11)	; eof, indicate such
set_filename:				; set a file name, etc.
20$:	movl	fab$l_nam(r6), r0	; get pointer to nam from fab
	movl	nam$l_rsa(r0), r1	;  and pointer to filename
	movzbl	nam$b_rsl(r0), r2	;   and get filename's length
	beql	30$			; no length?
	tstb	(r1)			; a starting null?
	bneq	30$			; nope
	incl	r1			; yep, skip it
	decl	r2			;  also skip in count
30$:	cmpb	r2, #filsiz-3-1-1	; will the whole specification fit?
	blequ	40$			; yep
	movzbl	#filsiz-3-1-1, r2	; nope, we must truncate it
40$:	movc	r2, (r1), filsrt	; move in the file specification
	clrb	(r3)			;  and make result asciz
	bbc	#fab$v_tecb2, fab$l_tecsts(r6), 50$ ; /b2?
	movl	#^a"/B2", (r3)		; yep, add the switch and asciz again
50$:	rsb				; exit

.disable lsb

.sbttl	Close input & output files

.enable	lsb

tec$clsfl:				; close input & output files
	bsbb	close_input		; close the input file first

.sbttl	Close output file

tec$clsof:				; close output file
	movzwl	b^oupntr(r11), r7	; get pointer to output file pointer
10$:	movl	(r7), r6		; get file's fab pointer
	beql	40$			; no file
	bbcc	#fab$v_dlt, fab$l_fop(r6), 20$ ; a file, don't delete it
	bbcc	#fab$v_tecbuf, fab$l_tecsts(r6), 20$ ; need data buffer dump?
	calls	#0, w^dump_data		; yes, so go do so
20$:	clrl	(r7)			; file is open no longer
	blbs	fab$l_tecsts(r6), 40$	; already closed if at end-of-file
.assume	fab$m_teceof eq 1
	bsbw	70$			; release any and all data lines...
	$close -			; close
		fab=(r6)		;  the file
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
	cmpl	r0, #rms$_eof		; did we get end-of-file (why?)?
	bneq	30$			; nope
	incl	r0			; yep, fudge for success (RMS bug?)
30$:	brw	success_or_err		; check for success completion & exit

close_input:				; close input file
	clrw	b^eoflag(r11)		; never eof if input file closed
	movzwl	b^inpntr(r11), r7	; get pointer to input file pointer
	brb	10$			;  then go close it & exit

.sbttl	Kill output file

tec$kilfl:				; delete output file
	movzwl	b^oupntr(r11), r7	; get pointer to output file pointer
	movl	(r7), r6		;  then get output file fab pointer
	bneq	20$			; a file, go close & delete it
40$:	rsb				; else just exit

.sbttl	Close indirect command file

close_indir:				; close indirect w/ error checking
	pushab	b^30$			; error check upon exit
reset_indir:				; close indirect command file
	clrw	b^indir(r11)		; ensure indirect file looks closed
	movl	#rms$_normal, r0	; pre-set o.k. if file's not open
	movl	cmdprm, r6		; get indirect file fab pointer
	beql	50$			; no file
	bsbb	70$			; release any and all data lines...
	$close -			; close
		fab=(r6)		;  the file
	clrl	cmdprm			;   and say we did it
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
50$:	rsb				; exit

60$:	calls	#0, b^free_data		; go free up the buffer
70$:	remque	@fab$q_tecque(r6), r0	; dequeue the next buffer
	bvc	60$			; there's one...
	rsb				; no more, exit

.disable lsb

free_data:				; free up a data buffer
	.word	^m<r1>
	pushl	r0			; stack the buffer's address
	pushl	8(r0)			; stack the buffer's size
	pushal	-4(fp)			; stack address of buffer's address
	pushal	-8(fp)			; stack address of buffer's size
	calls	#2, g^lib$free_vm	; go free up virtual memory
	ret				; exit

.sbttl	Error message finish up

tec$aller:				; error message finish up
	bsbw	not_exiting		; not exiting if error
	cmpzv	#0, #2, b^ehelp(r11), #3 ; want long form error message?
	bneq	reset_indir		; nope, so don't give it
	mcoml	#0, r0			; signal error message printing (-1)
	bsbw	tecoexelbr		;  and go do it
	brb	reset_indir		; go ensure no indirect and exit

	tmporg	tecoexelbr

	clrq	r0			; say nothing here...
	rsb				;  and exit

	unorg

.sbttl	Get files opened, etc.

tec$getfl:				; get files (EB, EI, EN, ER, EW)
	bsbw	fetch_filbuf		; go fetch the filename buffer
	bneq	non_null		; go off to process non-null...
	tstw	i_r2(r10)		; null, but what is it for?
	bgtr	20$			; it's EW
	beql	10$			; it's ER
	cmpw	i_r2(r10),#^a/I/-^a/R/	; come on now, what is it really?
	beql	close_indir		; it's EI, go close indirect
	blss	non_null		; it's EB, we'll die in parse...
	brw	en_next			; it's EN, go get next occurance

10$:	movw	#inpnor, b^inpntr(r11)	; do the pointer switch
	brw	set_inputname		;  and go set input file name, etc.

20$:	movw	#oupnor, b^oupntr(r11)	; do the pointer switch
	brw	set_outputname		;  and go set output file name, etc.

non_null:				; non-null file specification
	movab	w^file_spec_buf, r1	; get pointer to filespec buffer
	movl	r1, r2			;  in two registers
	clrb	w^file_spec_len		; reset the filespec's length
	clrl	w^file_spec_opt		;  and options
	clrl	r3			; say outside of quotes initially
10$:	bsbw	get_file_char		; get a character
	beql	70$			; null, the end
	blbs	r3, 20$			; branch if inside quotes
	cmpb	r0, #^a"/"		; else check for a switch
	beql	30$			; found one, switches start here...
20$:	movb	r0, (r1)+		; (re-)store into filespec's buffer
	incb	w^file_spec_len		;  and (re-)count it in the length
	brb	10$			;   then loop for more...

30$:	moval	w^file_spec_swt, r1	; point to the switch buffer
	clrl	(r1)			;  and clear it
40$:	bsbw	get_file_char		; get a switch character
	beql	50$			; null, end of this switch & spec too
	cmpb	r0, #^a"/"		; start of another switch?
	beql	50$			; yes, go end this one first
	movb	r0, (r1)+		; else store a switch character
	tstb	w^file_spec_swt+3	; did we store too many?
	beql	40$			; nope, continue
	brb	80$			; yep, go give an error...

50$:	movaq	w^switch_list-4, r1	; get the switch list
60$:	tstl	(r1)+			; skip the bit pattern
	tstb	(r1)			; more to check?
	beql	80$			; nope, go give an error
	cmpl	w^file_spec_swt, (r1)+	; a match?
	bneq	60$			; nope, keep checking...
	bisl	(r1), w^file_spec_opt	; yep, set the correct bit(s)
	tstb	r0			; is there more to come?
	bneq	30$			; yes, go get it...
70$:	tstb	w^file_spec_len		; did we get any length at all?
	bneq	do_non_null		; yep
80$:	movl	#rms$_syn, r0		; say that's illegal

.enable	lsb

10$:	brw	success_or_err		; go die with the error

20$:	brw	en_preset		; go do preset for "en"

do_non_null:				; do real opens, etc.
	tstw	i_r2(r10)		; what is it for?
	bgtr	30$			; it's EW
	beql	70$			; it's ER
	cmpw	i_r2(r10),#^a/I/-^a/R/	; come on now, what is it really?
	beql	40$			; it's EI
	bgtr	20$			; it's EN
30$:	movzwl	b^oupntr(r11), r7	; EB/EW, point to output file pointer
	movl	(r7), r6		;  then get output file fab pointer
	beql	60$			; closed is o.k.
	bsbw	set_outputname		; already open, set open file's name
	err	OFO, <"Output file already open">

40$:	bsbw	close_indir		; close the current indirect file
	moval	w^indir_cmd_fab, r6	; get the indirect command fab
	moval	cmdprm, r7		;  and where to store fab pointer
	brb	80$			;   then join common open code

50$:	tstw	b^nflg(r11)		; are we returning a value?
	bgeq	10$			; no, just die with the error
	err	FNF, <"File not found">

60$:	tstw	i_r2(r10)		; is it EB or EW?
	bleq	70$			; it's EB
	brw	170$			; it's EW

70$:	bsbw	close_input		; close the current input file
	moval	w^input_nor_fab, r6	; guess at normal input
	cmpw	r7, #inpnor		; good guess?
	beql	80$			; yep
	moval	w^input_alt_fab, r6	; nope, alternate input
80$:	movl	w^file_spec_opt, fab$l_tecsts(r6) ; set file spec options
	movab	w^getbyt_first, fab$l_tecdsp(r6) ; reset the get byte dispatch
	movzbl	#10, fab$l_tecctl(r6)	;  and the control bytes
	movl	#fab$m_sqo, fab$l_fop(r6) ; reset file options
	movw	#<fab$c_var@8>!fab$m_cr, fab$b_rat(r6) ; reset record fmt/attr
.assume	fab$b_rfm eq fab$b_rat+1
	movb	#fab$m_get, fab$b_shr(r6) ; set sharing to only other gets
	bbc	#fab$v_tecrw, fab$l_tecsts(r6), 90$ ; /rw?
	bs	#fab$v_rwo, fab$l_fop(r6) ; set rewind before open
90$:	bbc	#fab$v_tecsh, fab$l_tecsts(r6), 100$ ; /sh?
	movb	#fab$m_get!fab$m_put!fab$m_upi, fab$b_shr(r6) ; set sharing
100$:	movb	w^file_spec_len, fab$b_fns(r6) ; set file spec's length
	$open -				; open
		fab=(r6)		;  the input file
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
	blbc	r0, 50$			; branch if failure of any type
	cmpb	fab$b_rfm(r6), #fab$c_vfc ; vfc record format?
	bneq	110$			; nope
	movl	#rms$_fsz, r0		; pre-set bad vfc size error
	cmpb	fab$b_fsz(r6), #input_vfc_siz ; vfc size correct?
	bgtru	130$			; nope, go die with an error
110$:	cmpb	fab$b_rfm(r6), #fab$c_stm ; stream record format?
	bneq	120$			; nope
	bisb	#fab$m_cr, fab$b_rat(r6) ; always say implied lf/cr for stream
120$:	$connect -			; connect
		rab=@fab$l_tecrab(r6)	;  the correct rab
130$:	bsbw	success_or_cls		; check for success completion
	bbc	#fab$v_tecfmt, fab$l_tecsts(r6), 140$ ; any format options?
	bicb	#^c<fab$m_blk>, fab$b_rat(r6) ; yes, clear all but this
	bisb	fab$l_tecsts+2(r6), fab$b_rat(r6) ;  then apply options
140$:	movaq	fab$q_tecque(r6), fab$q_tecque(r6) ; initialize the
	movaq	fab$q_tecque(r6), fab$q_tecque+4(r6) ;  data buffer queue
	movl	r6, (r7)		; set file as open
	cmpw	i_r2(r10), #^a/I/-^a/R/	; what is it?
	blss	160$			; it's EB
	bgtr	150$			; it's ER
	movw	r7, b^indir(r11)	; it's EI, set indirect as active
150$:	bsbw	set_filename		; set the file's name, etc.
	rsb				;  and exit

160$:	movl	fab$l_nam(r6), r0	; get pointer to nam from fab
	movzbl	nam$b_rsl(r0), r1	;  and get resultant filename's length
	movb	r1, w^file_spec_len	; set a new file spec length
	movc5	r1, @nam$l_rsa(r0), #0, - ; move input's resultant filename
		#nam$c_maxrss, w^file_spec_buf ;  into file spec buffer
	bs	#fab$v_tecnv, w^file_spec_opt ; ensure maximized version
170$:	movzwl	b^oupntr(r11), r7	; get place to store fab pointer
	moval	w^output_nor_fab, r6	; guess at normal output
	cmpw	r7, #oupnor		; good guess?
	beql	180$			; yep
	moval	w^output_alt_fab, r6	; nope, alternate output
180$:	movl	w^file_spec_opt, fab$l_tecsts(r6) ; set file spec options
	movl	#fab$m_sqo!fab$m_sup!fab$m_tef, fab$l_fop(r6) ; reset options
	clrw	fab$w_mrs(r6)		; maximum record size = 0 for variable
	movb	#fab$c_var, fab$b_rfm(r6) ; guess at variable record format
	movb	#fab$m_cr, fab$b_rat(r6) ; guess at implied lf/cr records
	clrl	fab$l_xab(r6)		; guess at no specific protection code
	movb	#fab$m_get!fab$m_upi, fab$b_shr(r6) ; set sharing to gets
	bbc	#fab$v_tecrw, fab$l_tecsts(r6), 190$ ; /rw?
	bs	#fab$v_rwo, fab$l_fop(r6) ; set rewind before open
190$:	bbc	#fab$v_tecsh, fab$l_tecsts(r6), 200$ ; /sh?
	movb	#fab$m_get!fab$m_put!fab$m_upi, fab$b_shr(r6) ; set sharing
200$:	bbc	#fab$v_tecnv, fab$l_tecsts(r6), 210$ ; /nv?
	bs	#fab$v_mxv, fab$l_fop(r6) ; set maximized version numbers
210$:	movzwl	b^inpntr(r11), r0	; get input file's pointer
	movl	(r0), r0		;  to get its fab pointer
	beql	230$			; no input file
	bbc	#fab$v_ftn, fab$b_rat(r0), 220$ ; really want fortran ccl?
	movb	#fab$m_ftn, fab$b_rat(r6) ; yes, so set it
220$:	tstw	i_r2(r10)		; is it EB or EW?
	bgtr	230$			; it's EW
	movl	fab$l_xab(r0), r1	; it's EB, get input's protection xab
	bicw	#<xab$m_noread! -	;  clear no read
		xab$m_nowrite! -	;   and no write
		xab$m_noexe! -		;    and no execute
		xab$m_nodel>@xab$v_own, - ;   and no delete @ owner spot
			xab$w_pro(r1)	; to ensure owner stuff is o.k.
	movl	r1, fab$l_xab(r6)	; now use that protection code
	cmpb	fab$b_rfm(r0), #fab$c_stm ; input in stream record format?
	beql	240$			; yep, go default output to stream
230$:	bbc	#fab$v_tecstm, fab$l_tecsts(r6), 250$ ; stream format option?
240$:	movb	#fab$c_stm, fab$b_rfm(r6) ; set output for stream format
	movb	#fab$m_cr, fab$b_rat(r6) ;  with implied lf/cr records
250$:	bbc	#fab$v_tecvar, fab$l_tecsts(r6), 260$ ; variable format option?
	movb	#fab$c_var, fab$b_rfm(r6) ; set output for variable format
260$:	bbc	#fab$v_tecfmt, fab$l_tecsts(r6), 270$ ; any format options?
	movb	fab$l_tecsts+2(r6), fab$b_rat(r6) ; yes, apply options
270$:	movb	w^file_spec_len, fab$b_fns(r6) ; set file spec's length
	$create -			; create
		fab=(r6)		;  the output file
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
	movl	fab$l_xab(r6), r2	; save protection xab use indicator
	clrl	fab$l_xab(r6)		;  then remove the protection xab
	tstl	r2			; did we use a protection xab?
	beql	280$			; nope
	cmpl	r0, #rms$_prv		; yep, a privilege violation error?
	beql	270$			; that we did, go try, try again...
280$:	bs	#fab$v_dlt, fab$l_fop(r6) ; (pre-)mark file for deletion
	cmpl	r0, #rms$_supersede	; did we supersede something?
	beql	290$			; yes, that's o.k.
	bsbw	success_or_err		; else check for success completion
290$:	$connect -			; connect
		rab=@fab$l_tecrab(r6)	;  the correct rab
	bsbw	success_or_cls		; check for success completion
	movaq	fab$q_tecque(r6), fab$q_tecque(r6) ; initialize the
	movaq	fab$q_tecque(r6), fab$q_tecque+4(r6) ;  data buffer queue
	movl	r6, (r7)		; set file as open
	brw	set_outputname		; set the file's name, etc. & exit

.disable lsb

fetch_filbuf:				; fetch (converted) filename buffer
	movtuc	#filsiz, filsrt, -	; move translated from TECO's buffer
		#0, w^file_spec_table, - ;  'til 0(end), 128(spec), 255(end?)
		#nam$c_maxrss, w^file_spec_buf ;  into our file spec buffer
	bvc	30$			; terminator not seen??
10$:	cmpb	(r1)+, #128		; is it the special (128)?
	bneq	30$			; nope, other, call it the end
	decl	r0			; yep, remove the special from count
	beql	30$			; nothing left??
	addb3	#128, (r1)+, (r5)	; convert next to (almost) proper code
	bbcc	#5, (r5)+, 20$		; now do an (almost) final correction
	blbc	-1(r5), 20$		; have we (finally) done it?
	movb	#255, -1(r5)		; nope, this is the last fix!
20$:	decl	r0			; remove modified code from count
	decl	r4			; say we've store another character
	movtuc	r0, (r1), #0, (r3), r4, (r5) ; translated move rest of data
	bvs	10$			;  and loop if another hit...
30$:	clrb	(r5)			; ensure .asciz format
	subb3	r4, #nam$c_maxrss, w^file_spec_len ; form file spec length
	rsb				; exit w/ Z=1 if zero length

get_file_char:				; get file specification character
10$:	movzbl	(r2)+, r0		; get next byte from filename buffer
	beql	40$			; null, the end, exit 'beql'
	blbs	r3, 20$			; branch if inside of quotes
	cmpb	r0, #32			; is this a junky character?
	blequ	10$			; yes, ignore it
	cmpb	r0, #127		; other kind of junky character?
	beql	10$			; yes, ignore it
	cmpb	r0, #^a/A/+32		; is it lower case?
	blssu	20$			; not lower case
	cmpb	r0, #^a/Z/+32		; might be
	bgtru	20$			; but it isn't...
	bicb	#32, r0			; lower case, make into upper case
20$:	cmpb	r0, #^a/"/		; changing quote mode?
	bneq	30$			; nope
	xorl	#1, r3			; yep, so flip the flop
30$:	tstb	r0			; ensure 'bneq' exit
40$:	rsb				; exit

.sbttl	Do "en" processing

.enable	lsb

en_preset:				; preset the "en" specification
	moval	w^en_fab, r6		; get the "en" fab pointer
	movb	w^file_spec_len, fab$b_fns(r6) ; set file spec's length
	$parse -			; parse the specification
		fab=(r6)		;  from the "en" fab
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
10$:	movl	#fab$m_teceof, fab$l_tecsts(r6) ; reset private status (fnf)
	bsbw	success_or_err		; check for success completion
	clrl	fab$l_tecsts(r6)	; made it, mark as active
	rsb				;  then exit

en_next:				; get next "en" occurance
	moval	w^en_fab, r6		; get the "en" fab pointer
	blbs	fab$l_tecsts(r6), 50$	; keep saying 'fnf' if we need to
.assume	fab$m_teceof eq 1
20$:	$search -			; else search for next occurance
		fab=(r6)		;  using the "en" fab
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
	blbc	r0, 30$			; branch if any type of error
	brw	set_filename		; set the resultant stuff & exit

30$:	cmpl	r0, #rms$_fnf		; not found?
	beql	40$			; yes, so say so
	cmpl	r0, #rms$_nmf		; no more files?
	beql	40$			; yes, so say so
	tstl	fab$l_stv(r6)		; fatal type error?
	bneq	10$			; yep, so die with it
	bsbw	success_or_announce	; else just announce the error
	brb	20$			;  and go try, try again...

40$:	incl	fab$l_tecsts(r6)	; keep saying 'fnf' from now on
.assume	fab$m_teceof eq 1
50$:	err	FNF, <"File not found">

.disable lsb

.sbttl	Handle the EJ flag

tec$ejflg:				; get ej flag information
	movab	w^tmp_string_buf+8, r6	; point into temporary area
	clrq	(r6)			; no return len(+8) & end-of-list(+12)
	movab	w^tmp_string2_buf, r7	; point to result area
	movl	r7, -(r6)		; set pointer to result buffer(+4)
	movw	#jpi$_pid, -(r6)	; guess at wanting process id(+2)
	movl	#5, r8			; guess at -1ej (5 => vms)
	tstw	i_r0(r10)		; what does the user really want?
	blss	20$			; it is -1ej, return 5 for vms
	beql	10$			; it is 0ej, go fetch process id
	movzwl	w^ter_o_unit, r8	; guess at 1ej, terminal unit
	cmpw	i_r0(r10), #2		; what is it really?
	blss	20$			; it is 1ej, return terminal unit
	movw	#jpi$_uic, (r6)		; it is 2ej, fetch uic(+2)
10$:	movw	#tmp_string2_siz, -(r6)	; set size of result buffer(+0)
	$getjpi_s -			; get job information
		itmlst=(r6)		;  item list...
	bsbw	success_or_abrt		; check for success completion
	movl	(r7), r8		; fetch result
	tstw	i_r0(r10)		; what was it?
	beql	20$			; process id (0ej)
	insv	2(r7), #8, #8, r8	; uic, make into 2 bytes
20$:	movzwl	r8, i_r0(r10)		; set the desired result
	rsb				; exit

.sbttl	Handle line truncation mode changes

.enable	lsb

tec$truln:				; change truncate lines mode
	movl	#tec$v_et$tru, r2	; set the ET bit to check
	movl	#tt$v_wrap, r3		;  and corresponding characteristic
	mcoml	i_r0(r10), r0		; get the new bit(s) to check against
	brb	10$			; go join common code

.sbttl	Handle 8-bit terminal mode changes

tec$eight:				; change 8-bit terminal mode
	movl	#tec$v_et$8bt, r2	; set the ET bit to check
	movl	#tt$v_eightbit, r3	;  and corresponding characteristic
	movl	i_r0(r10), r0		; get the new bit(s) to check against
10$:	tstw	w^ter_o_chan		; is there a terminal output channel?
	beql	40$			; nope, just go exit
	pushl	w^devdepend		; save the original characteristics
	bbcc	r3, w^devdepend, 20$	; ensure bit off in characteristics
20$:	bbc	r2, r0, 30$		; shound we set the characteristic?
	bbss	r3, w^devdepend, 30$	; set bit on in characteristics
30$:	bsbb	tec$setmode		; go set the terminal mode
	movl	(sp)+, w^devdepend	; restore original characteristics
	brw	success_or_err		; check for success completion & exit

.sbttl	Handle new terminal width

tec$width:				; handle new terminal width
	tstw	w^ter_o_chan		; is there a terminal output channel?
	beql	40$			; nope, just go exit
	movw	htsize+rwsize(r11), w^devbufsiz ; set the new terminal width
tec$setmode:				; do a IO$_SETMODE on terminal output
	bsbw	tec$wait		; wait for all output to be queued
	$qiow_s -			; queue an I/O request
		chan = w^ter_o_chan, -	;  on the terminal output channel
		func = s^#io$_setmode, - ;  doing a setmode
		iosb = w^ter_o_pos, -	;  using this as the IOSB
		p1 = w^getdvi_info, -	;  set the information in this buffer
		p2 = #getdvi_info_len	;  which is this long
	blbc	r0, 40$			; just exit if any error
	movzwl	w^ter_o_pos, r0		; else return the completion status
40$:	rsb				; exit

.disable lsb

.sbttl	Stop terminal hacks

.enable	lsb

tec$xitnw:				; stop terminal hacks
	movb	#1, w^exiting_flag	; exiting flag <- on
enable_ctrlt:				; (re-)enable CTRL/T actions
	movab	g^lib$enable_ctrl, r0	; address enable oob cli service
	moval	w^ter_oob_msk, r1	; enable mask is saved old mask(s)
10$:	tstw	w^ter_i_chan		; do we have a terminal for input?
	beql	30$			; nope
	pushal	-(sp)			; arg #2 -> returned old mask
	pushal	(r1)			; arg #1 -> enable/disable mask
	calls	#2, (r0)		; call the enable/disable cli service
	blbc	r0, 20$			; skip .OR. if an error occured...
	bisl	(sp), w^ter_oob_msk	; .OR. together old mask(s)
20$:	addl	#4, sp			; clean up the stack
	bsbw	success_or_announce	; announce any failure...
30$:	rsb				; exit

not_exiting:				; say we're not really exiting
	bbcc	#0, w^exiting_flag, 30$	; exiting flag <- off, exit if was off
	movab	g^lib$disable_ctrl, r0	; address disable oob cli service
	moval	#lib$m_cli_ctrlt, r1	; disable mask is for CTRL/T
	brb	10$			; go do the CTRL/T disable

.disable lsb

.sbttl	Process special functions

.enable	lsb

10$:	movzbl	(r7)+, r0		; get a byte from the buffer
	beql	40$			; end of buffer, exit Z=1
	cmpb	r0, #^a/A/+32		; should we convert case?
	blssu	20$			; nope
	cmpb	r0, #^a/Z/+32		; really?
	bgtru	20$			; nope again
	bicb	#32, r0			; yep, force upper case
20$:	cmpb	r0, #32			; is it a space?
	bneq	40$			; nope, exit Z=0
30$:	cmpb	(r7)+, r0		; yep, is next also a space?
	beql	30$			; multiple spaces, collapse them
	decl	r7			; else back up the pre-fetch (& Z=0)
40$:	rsb				; exit, Z=1 => end-of-buffer

50$:	movzbl	#nam$c_maxrss, (r6)	; set maximum length of value
	movl	r7, 4(r6)		; set address part of value desc
	locc	#0, (r6), (r7)		; locate the terminating null
	subl	r0, (r6)		;  and find the true length
	pushaq	(r6)			; arg #2 -> symbol's value
	pushaq	(r8)			; arg #1 -> symbol's name
	calls	#2, g^lib$set_symbol	; call the set symbol cli service
53$:	bsbw	success_or_abrt		; check for success completion
	brw	130$			; go move value to filename buffer

57$:	tstw	(r8)			; zero length symbol name?
	beql	90$			; yep, error, go return a value of 0
	pushaw	(r6)			; arg #3 -> symbol's value length
	pushaq	(r6)			; arg #2 -> symbol's value
	pushaq	(r8)			; arg #1 -> symbol's name
	calls	#3, g^lib$get_symbol	; call the get symbol cli service
	cmpl	r0, #lib$_nosuchsym	; did the symbol exist?
	bneq	53$			; yes, or other error...
	brw	120$			; go move null to filename buffer

60$:	bsbb	10$			; get the next character
	cmpb	r0, #32			; is it a space?
	bneq	90$			; nope, error, go return a value of 0
	getdesc	tmp_string2, r8		; reset & get desc for temp string #2
	movl	(r8)+, r1		; get length of symbol's name buffer
	movl	(r8), r2		;  and get a pointer to it's storage
	clrl	-(r8)			; reset length of symbol's name desc
	decl	r1			; we store before check; fix length...
70$:	bsbb	10$			; get next character of symbol's name
	beql	57$			; end, must be reading the symbol
	cmpb	r0, #32			; is it a space?
	beql	50$			; yep, that's the name's end
	movb	r0, (r2)+		; store the symbol's name character
	acbl	r1, #1, (r8), 70$	; bump length and check for too far
	brb	90$			; it's too far, go return a value of 0

tec$gexit:				; process special functions
	bsbw	fetch_filbuf		; go fetch the filename buffer
	movab	w^file_spec_buf, r7	; address the fetched data
	bsbw	10$			; get the first command byte
	beql	90$			; the end, go exit n=0
	movab	w^colon_eg_list-3, r6	; get (biased) list of functions
80$:	addl	#3, r6			; skip uncompared characters
	movl	(r6)+, r8		; pick up pointer to logical name desc
	cmpb	r0, (r6)+		; could it be this function?
	beql	100$			; might be...
	tstl	r8			; more to check?
	bneq	80$			; yep, loop...
90$:	clrw	b^n(r11)		; set return value of 0
	rsb				; exit

100$:	bsbw	10$			; get next character of name
	beql	90$			; no more, go return value of 0
	cmpb	r0, (r6)+		; is the character correct?
	bneq	90$			; nope, go return value of 0
	tstb	(r6)			; yep, more to check?
	bneq	100$			; there's more, loop...
	getdesc	tmp_string, r6		; reset & get desc for temp string
	tstl	r8			; is it DCL symbol manipulation?
	beql	60$			; yes
	bsbw	10$			; get the next character
	beql	110$			; no more, go read the logical
	cmpb	r0, #32			; another, is it a space?
	bneq	90$			; nope, error, go return a value of 0
	movzwl	#63, (r6)+		; set maximum string size
	movl	r7, (r6)		;  and pointer to string
	locc	#0, #63, (r7)		; locate the terminating null
	subl	r0, -(r6)		;  then correct the size
	beql	150$			; size is zero, go delete the logical
	pushab	b^130$			; return new value string upon exit
	movq	(r8), -(sp)		; set logical name string desc
	movq	(r6), -(sp)		; set value string desc
	pushaq	(sp)			; arg #2 -> value string
	pushaq	4+8(sp)			; arg #1 -> logical name
	calls	#2, g^lib$set_logical	; call the set logical cli service
	movzwl	#ss$_supersede, r2	; we ignore supersede of an old string
	brb	160$			; now go check it

110$:	$trnlog_s -			; translate
		lognam=(r8), -		;  teco's logical
		rsllen=(r6), -		;  setting result length here
		rslbuf=(r6)		;  which is the result buffer
	bsbw	success_or_abrt		; check for success completion
	cmpw	r0, #ss$_notran		; did any translation happen?
	bneq	130$			; yep, return the result string
120$:	clrl	(r6)			; set result string to null
130$:	movc5	(r6), @4(r6), #0, #filsiz-1-1, filsrt ; move to filename buffer
	clrb	(r3)			; ensure answer is .asciz
140$:	rsb				; exit with n=-1 for success

150$:	pushab	120$			; return null value string upon exit
	clrq	-(sp)			; dummies to be removed below...
	movq	(r8), -(sp)		; set logical name string desc
	pushaq	(sp)			; arg #1 -> logical name
	calls	#1, g^lib$delete_logical ; call the delete logical cli service
	movzwl	#ss$_nolognam, r2	; we ignore no logical to delete
160$:	addl	#2*8, sp		; remove the stacked descriptors
	cmpl	r0, r2			; is this the error we ignore?
	beql	140$			; yep, just go exit
	brw	success_or_abrt		; check for success completion & exit

.disable lsb

.sbttl	Get additional memory

.enable	lsb

10$:	incl	i_ps(r10)		; indicate failure with c=1
	rsb				;  and exit with failure

tec$sizer:				; get additional memory
	addl3	#512-1, i_r1(r10), r1	; get the request amount
	bicl	#512-1, r1		;  rounded up to a page multiple
	cmpl	r1, w^still_free	; is there room left?
	bgtru	10$			; nope, we must fail
	subl	r1, w^still_free	; move the requested amount
	addw	r1, b^curfre(r11)	;  to teco's free space
	bbs	#tec$v_et$xit, b^etype(r11), 40$ ; doing announcements?
	cmpw	b^qcmnd(r11), #cmdqrg	; are we within a macro?
	bneq	40$			; skip announcements if so
	blbs	w^exiting_flag, 40$	; also skip announcements if exiting
	tstw	b^indir(r11)		; from within indirect command file?
	bneq	40$			; skip announcements if true
	bs	s^#io$v_canctrlo, ctlofg ; do a control/o cancel
	movzbl	#^a/[/, r6		; start with "["
	bsbw	echo_buffer		;  in the message
	addw3	b^qrstor(r11), b^qmax(r11), r6 ; find end of
	addw	b^curfre(r11), r6	;  total space in use
	subw	r11, r6			; now find total byte size in use
	movzwl	r6, r6			; now convert that to a longword
	addl	#511, r6		; round and
	divl	#512, r6		;  find that size in pages
	clrl	r7			; clear the high order
	ediv	#10, r6, r6, r7		;  and divide to tens/units
	beql	30$			; no tens
	subl3	#10, r6, r8		; are tens really up to hundreds?
	blss	20$			; nope
	movzbl	#^a/1/, r6		; yep, set a "1" for the hundreds
	bsbw	echo_buffer		;  and go output it
	movl	r8, r6			; restore corrected tens
20$:	bsbb	50$			; output result (tens)
30$:	movb	r7, r6			; copy the remainder (units)
	bsbb	50$			;  and go output it
	pushaq	w^sizing_msg_desc	; set the rest of the sizing message
	calls	#1, w^tec$out_ascid	;  and go output it
	bisw	#1, b^outdne(r11)	; say memory message output done
40$:	rsb				; exit

50$:	addb	#^a/0/, r6		; make character into a digit
	brw	echo_buffer		;  and, then, go buffer it

.disable lsb

.sbttl	Get date and time

.enable	lsb

tec$date:				; get date
	bsbb	20$			; go get the information
	subw3	#1900, (r6)+, r7	; get year-1900
	mulw	#16, r7			;  then multiply it by 16
	addw	(r6)+, r7		; add in the month
	mulw	#32, r7			;  then multiply by 32
10$:	addw	(r6)+, r7		; finally, add in the day or seconds/2
	movzwl	r7, i_r0(r10)		; return the result
	rsb				;  and exit

tec$time:				; get time
	bsbb	20$			; go get the information
	addl	#6, r6			; skip over year, month, day
	mulw3	#60, (r6)+, r7		; get hour*60
	addw	(r6)+, r7		; add in minutes
	mulw	#60/2, r7		;  then multiply by 30
	divw	#2, (r6)		; form seconds/2
	brb	10$			; go add in seconds/2 and exit

20$:	movab	w^tmp_string_buf, r6	; get pointer to temporary area
	$numtim_s -			; get numeric date/time
		timbuf=(r6)		;  into temporary area
	brw	success_or_abrt		; check for success completion

.disable lsb

.sbttl	Exit from TECO

.enable	lsb

10$:	beql	20$			; no file
	$close -			; else close
		fab=(r6)		;  the file
	movl	fab$l_stv(r6), w^err_msgvec+8 ; save the STV value
	cmpl	r0, #rms$_ifi		; was file already closed (bad IFI)?
	beql	20$			; yes, don't call it an error...
	bsbw	success_or_announce	; announce any failure...
20$:	rsb				; exit

tec$texit:				; exit from teco
	bsbw	echo_dump		; dump out any partial terminal output
	movl	cmdprm, r6		; get indirect file fab pointer
	bsbb	10$			;  and close it if necessary
	movl	inpnor, r6		; get normal input fab pointer
	bsbb	10$			;  and close it if necessary
	movl	inpalt, r6		; get alternate input fab pointer
	bsbb	10$			;  and close it if necessary
	movl	oupnor, r6		; get normal output fab pointer
	bsbb	10$			;  and close it if necessary
	movl	oupalt, r6		; get alternate output fab pointer
	bsbb	10$			;  and close it if necessary
	movzwl	w^ter_c_chan, r0	; get terminal control/c ast channel
	beql	30$			; none
	$dassgn_s -			; deassign channel
		chan=r0			;  from control/c ast channel
	bsbw	success_or_announce	; announce any failure...
30$:	movzwl	w^ter_i_chan, r0	; get terminal input channel
	beql	40$			; none
	$dassgn_s -			; deassign channel
		chan=r0			;  from terminal input
	bsbw	success_or_announce	; announce any failure...
	bsbw	enable_ctrlt		; go (re-)enable CTRL/T actions
	brb	50$			; continue

40$:	$close -			; close
		fab=w^input_sys_fab	;  sys$input
	bsbw	success_or_announce	; announce any failure...
50$:	tstw	w^ter_o_chan		; a terminal output channel?
	beql	60$			; none
	bsbw	tec$wait_done		; wait for terminal output to complete
	bsbw	tec$setmode		; go (re-)set correct terminal modes
	bsbw	success_or_announce	; announce any failure...
	$dassgn_s -			; deassign channel
		chan=w^ter_o_chan	;  from terminal output
	bsbw	success_or_announce	; announce any failure...
	brb	90$			; continue

60$:	tstw	w^output_sys_rab+rab$w_rsz ; any remaining record length?
	bneq	70$			; yes, so dump the record
	cmpw	w^output_sys_vfc, #1	; any remaining print control?
	blequ	80$			; none(0) or final NL(1), forget it
	decb	w^output_sys_vfc	; remove any final NL request
	bgeq	70$			; all is still o.k.
	clrb	w^output_sys_vfc	; else say no prefixing at all
70$:	movab	w^output_sys_buf, w^output_sys_rab+rab$l_rbf ; reset pointer
	$put -				; put a record
		rab=w^output_sys_rab	;  to sys$output
	bsbw	success_or_announce	; announce any failure...
80$:	$close -			; close
		fab=w^output_sys_fab	;  sys$output
	bsbw	success_or_announce	; announce any failure...
90$:	bsbw	fetch_filbuf		; go fetch the filename buffer
	beql	100$			; null string, just exit
	pushab	w^file_spec_buf		; stack descriptor
	movzbl	w^file_spec_len, -(sp)	;  of command string
	pushaq	(sp)			; arg #1 -> command string
	calls	#1, g^lib$do_command	; call the do command cli service
	addl	#8, sp			; remove stacked descriptor
	bsbw	success_or_announce	; announce any failure...
100$:	movzwl	xitsts, r0		; get the exit status
	cmpl	r0, #1			; what kind of an exit is this?
	beql	120$			; =1, a normal exit
	blssu	110$			; =0, an EG exit
	movl	#<ss$_abort!sts$m_inhib_msg>-9, r0 ; >1, an abort exit
110$:	addl	#9, r0			; make EG exits into a 9
120$:	$exit_s -			; finally done, really exit
		code = r0		;  with this reason code

.disable lsb

.end	tec$teco

