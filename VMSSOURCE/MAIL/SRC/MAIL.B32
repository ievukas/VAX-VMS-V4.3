MODULE MAIL$MAIL( %TITLE 'VAX/VMS PERSONAL MAIL UTILITY'
		MAIN = MAIL,
		IDENT = 'V04-001' ) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	Entry point to MAIL.  Dispatches according to type of
!		use: CLI command, interactive, or network slave job.
!
! 		This program was originally written as an exercise by the
!		author to learn VAX assembler coding.  The first versions
!		were based on the "PNOTES" program written by Kim Mast for
!		the University of Illinois PLATO system.
!
!		Two of the original goals of the design were simplicity of
!		use and simplicity of operation.  The latter goal suggested
!		the use of the operating system's own indexed filing system,
!		namely file directories.  
!
!		Note also that this program does not purport to be a general
!		purpose "electronic mail system" or "office automation
!		system".  It is simply a mail utility for normal users of
!		a VAX/VMS system.
!
! ENVIRONMENT:	NATIVE/USER MODE
!
! AUTHOR: Len Kawell, CREATION DATE: 20-FEB-1979
!
! MODIFIED BY:
!
!	V04-001	BLS0252		Benn Schreiber	12-SEP-1984
!		Do not drop NETMBX privilege.
!
!	V03-027	ROP0021		Robert Posniak	12-JUL-1984
!		If first character of MAIL$EDIT is @
!		then strip it.  Change references of XYZ
!		to TPU.  Change SCR$ERASE to SMG$ERASE_PASTEBOARD
!
!	V03-026	ROP0015		Robert Posniak	02-JUL-1984
!		Do not concatenate the sender's username and
!		nodename if the username string is null.
!
!	V03-025	ROP0006		Robert Posniak	12-JUN-1984
!		Clear proper bits in priv mask.
!
!	V30-024	BLS0292		Benn Schreiber	 8-APR-1984
!		Implement SEND/ATTACH for Message Router
!
!	V03-023	BLS0288		Benn Schreiber	21-MAR-1984
!		Make raised priv. vector global
!
!	V03-022	BLS0280		Benn Schreiber	 4-MAR-1984
!		Treat subject string of all blanks as no subject
!		in network input.
!
!	V03-021	BLS0272		Benn Schreiber	18-FEB-1984 13:34:05 
!		Implement server loop, enlarge SYS$NET buffer.
!
!	V03-020	BLS0263		Benn Schreiber	22-Jan-1984
!		Complete default keypad.  Disallow SPAWN if captive
!		bit set.  Send end-of-users flag immediately after
!		sending all the user names to check.
!
!	V03-019	BLS0255		Benn Schreiber	28-Dec-1983
!		Convert trnlogs to trnlnm.  Convert getdev to
!		getdviw.  Use new global flags. Upcase to-list watching
!		quotes.  In slave mode, purge working set while waiting
!		for first message record.
!
!	V03-018	BLS0249		Benn Schreiber	 8-Dec-1983
!		Put back the deleting of MAIL.TMP files.
!
!	V03-017	BLS0246		Benn Schreiber	 8-Nov-1983
!		Move new mail count to VMSMAIL.DAT.  Modify prompt.  Don't
!		delete MAIL.TMP.  Add support for cluster node enhancements.
!
!	V03-016	BLS0240		Benn Schreiber	15-Sep-1983
!		Complete alternate net protocol interfacing.
!
!	V03-015	BLS0229		Benn Schreiber	16-Jul-1983
!		Implement network block mode.  Make pagesize
!		very large if batch mode.  Get new message count from
!		mail file rather than SYSUAF.
!
!	V03-014	BLS0227		Benn Schreiber	29-Jun-1983
!		If file specified in  REPLY command, disable cli defaulted
!		/EXTRACT.
!
!	V03-013	BLS0224		Benn Schreiber	 1-Jun-1983
!		Correct argument to SMG$CREATE_VIRTUAL_KEYBOARD in cli_command
!
!	V03-012	BLS0222		Benn Schreiber	 7-May-1983
!		Correct SEND for case of COPY_SELF SEND and
!		distribution list.
!
!	V03-011	BLS0220		Benn Schreiber	30-Apr-1983
!		Add support for SET AUTO, SET MAIL_DIRECTORY, keypad
!		input, and ERASE commands.
!
!	V03-010	BLS0218		Benn Schreiber	18-Apr-1983
!		Make defualt spec '.txt' in lookup_file
!
!	V03-009	BLS0217		Benn Schreiber	12-Apr-1983
!		Support SEND/SELF, etc.
!
!	V03-008	BLS0214		Benn Schreiber	27-Mar-1983
!		Add REPLY/EXTRACT.  In cli_command, check addressees
!		first before getting message text if terminal input
!
!	V03-007	BLS0211		Benn Schreiber	13-Mar-1983
!		Extensive rework for isam mail files.  Correct privilege
!		handling.  Implement global CTRL/C handling.  Lookup file
!		on SEND, REPLY before prompting for "to".  Begin incorporation
!		of multi-threaded server
!
!	V03-006	BLS0197		Benn Schreiber	 9-Dec-1982
!		Implement SET PERSONAL_NAME command.  Break out SET, SHOW
!		commands and handling of VMSMAIL.DAT into separate files.
!
!	V03-005	BLS0193		Benn Schreiber	12-Nov-1982
!		Correct error handling in NETJOB reading message text. Collapse
!		GETJPI's so only one is done.  Add exit handler to clean
!		up network links.
!
!	V03-004	BLS0189		Benn Schreiber	14-Oct-1982
!		Convert command parsing from TPARSE to CLI$DCL_PARSE.  Add a
!		few new features, such as show for/user=wilduser, search/file
!		and DELETE and READ command interlock on message.
!
!	V03-003	BLS0184		Benn Schreiber	20-Aug-1982
!		Delete MAIL.TMP files on entering mail in interactive mode.
!		This prevents inadvertantly sending an old message left lying
!		around.  Add SET FORW/USER= and SHOW FORW/USER=.  Do not
!		put sender's node on his name if it's the same as our node.
!
!	V03-002	BLS0179		Benn Schreiber	26-Jul-1982
!		Complete automatic forwarding.  Add check for infinite forward
!		loops.
!
!	V03-001	BLS0177		Benn Schreiber	20-JUN-1982
!		Add info on output device for listing size handling and
!		fix a few bugs.  Add MAIL/EDIT DCL qualifier which implies
!		SEND/EDIT and REPLY/EDIT by default.  Add support for automatic
!		forwarding, implemented by reading SYS$SYSTEM:VMSMAIL.DAT, an
!		ISAM file.  Add SET [NO]FORWARD, and SHOW FORWARD commands.
!		Honor the DISMAIL flag in the UAF record.
!--

!
! TABLE OF CONTENTS:
!
!
! INCLUDE FILES:
!
	LIBRARY 'SYS$LIBRARY:LIB';
	LIBRARY 'SYS$LIBRARY:TPAMAC';
	REQUIRE 'SRC$:MAILREQ';
	LIBRARY 'LIB$:MAILDEF';

FORWARD ROUTINE
	EXIT_ROUTINE,				! clean up logical links
	MAIL$ENABLE_CTRLC,			! Enable for CTRL/C
	CHECK_SEND,				! Check if sending desired
	MAIL$GET_CLUNODES,			! Get cluster node names
	GET_SEND_MSG,				! Get and send message
	MAIL,					! Main entry point
	CLI_COMMAND,				! CLI command processing
	NETJOB,					! Network job processing
	INTJOB;					! Interactive job processing


!
! EQUATED SYMBOLS:
!
BUILTIN
	AP;					! Argument pointer

LITERAL
	EDIT_FLAG = 0,				! /EDIT flag
	LAST_FLAG = 1,				! /LAST flag
	FILE_FLAG = 2,				! /FILE flag
	EXIT_FLAG = 3,				! EXIT command flag
	QUIT_FLAG = 4,				! QUIT command flag
	F_SEND_EDIT = 0,			! Default SEND to SEND/EDIT
	F_REPLY_EDIT = 1,			!  REPLY
	F_FORW_EDIT = 2;			!  FORWARD
!
! EXTERNAL REFERENCES:
!
EXTERNAL LITERAL
	SMG$_EOF,				! end of file
	CLI$_NEGATED,				! Qualifier negated
	CLI$_LOCNEG;				! Qualifier locally negated

EXTERNAL ROUTINE
	CLI$GET_VALUE,				! Get value for qualifier
	CLI$DCL_PARSE,				! Parse command
	CLI$DISPATCH,				! Dispatch based on parse
	CLI$PRESENT,				! Test if qualifier present
	LIB$CVT_DTB,				! Convert decimal to binary
	LIB$DISABLE_CTRL,			! Disable CLI CTRL handling
	LIB$ENABLE_CTRL,			! Enable CLI CTRL handling
	LIB$GET_VM,				! Allocate virtual memory
	LIB$SET_FILE_PROT,			! Change file protection
	LIB$TPARSE,				! Table driven parser
	MAIL$CMD_READ,
	MAIL$CMD_CONTINUE,
	MAIL$DEL_TMPF,				! Delete old MAIL.TMP files
	MAIL$DELEMPLINK,			! Delete links with no addressees
	MAIL$EXTRACT_MESSAGE,			! Copy message text to file
	MAIL$FILTER_OUTPUT,			! Turn escapes into '$'
	MAIL$FAO_GETMSG,			! Get message text and fao it
	MAIL$GETMSG,				! Get message text
	MAIL$GET_DEVDIR,			! Get device and directory spec
	MAIL$HANDLE,				! Condition handler
	MAIL$ADD_ADDR,				! Add addressee to list
	MAIL$CLOSE_FILE,			! Close message file
	MAIL$CONFIRM,				! Confirm function
	MAIL$DELETELINK,			! Delette all logical links
	MAIL$EDIT,				! Edit a message
	MAIL$ENTER,				! Enter a message
	MAIL$GET_INPUT,				! Get from sys$input
	MAIL$GET_I_MSG,				! Get record of current ISAMsg
	MAIL$GET_MSG,				! Get record of current message
	MAIL$GET_NEWMAIL,			! Get new mail count
	MAIL$GET_USER,				! Get uaf record
	MAIL$INI_ADDR,				! Initalize addressee list
	MAIL$INFO_I_MSG,			! Get ISAM message info
	MAIL$INFO_MSG,				! Get message information
	MAIL$IOSUB_INIT,			! Allocate mem for iosubs rtns
	MAIL$NET_END_USERS,			! Send end-of-users and to-list
	MAIL$OPEN_IF,				! Open default mail file
	MAIL$OPEN_UAF,				! Open system uaf
	MAIL$OPEN_SYSMAI,			! Open MAIL info file
	MAIL$PUT_OUTPUT,			! Put to sys$output
	MAIL$READ_FOREIGN_FILE,			! Read input, foreign net
	MAIL$REWIND_I_MSG,			! Rewind current ISAM message
	MAIL$REWIND_MSG,			! Rewind current message
	MAIL$SEND_ADDR,				! Send message to addressee(s)
	MAIL$SET_NAME,				! Set full name string
	MAIL$TEST_SUBJ,				! Test if SUBJ: line present
	MAIL$UPDATE_I_MSG,			! Update message header record
	MAIL$UPCASE,				! Convert string to upper case
	MAIL$UPCASE_Q,				! Ditto, but not inside quotes
	SMG$CREATE_PASTEBOARD,
	SMG$ERASE_PASTEBOARD,
	SMG$CREATE_VIRTUAL_KEYBOARD,
	SMG$CREATE_KEY_TABLE,
	SMG$DELETE_VIRTUAL_KEYBOARD,
	SMG$DEFINE_KEY,
	STR$APPEND,				! String append
	STR$CONCAT,				! String copy and concatenate
	STR$COPY_DX,				! String copy
	STR$FREE1_DX,				! Deallocate dynamic string
	STR$TRIM,				! Trim trailing blanks
	SYS$FAO,				! Formatted ascii output
	UTIL$GETFILENAME,			! Get filename from FAB/RAB
	UTIL$REPORT_IO_ERROR;			! Report I/O error

EXTERNAL
	MAIL$T_RD_RAB : $BBLOCK,		! RAB for mail file i/o
	MAIL$Q_MAIL_MAI : $BBLOCK,		! Descriptor for 'MAIL.MAI'
	MAIL$B_MSGTRAN : BYTE,			! Next action for GET_I_MSG
	MAIL$COMMAND_TABLE,			! MAIL command tables
	MAIL$L_CURMSG : REF $BBLOCK,		! Pointer to MMB for msg
	MAIL$L_USRSYSBUF : REF $BBLOCK,		! User's vmsmail record
	MAIL$L_MSG_NUM:	WORD,			! Current message number
	MAIL$L_MSG_RADR:LONG,			! Current message record addr
	MAIL$W_MSG_RSIZ:WORD,			! Current message record size
	MAIL$L_MSG_STS:	LONG,			! Current message status
	MAIL$Q_MSGNAME:	BLOCK[,BYTE],		! Default message file name
	MAIL$Q_MSGTYPE: BLOCK[,BYTE],		! Default message file type
	MAIL$T_UAF_BUFF: REF $BBLOCK;		! Uaf record buffer

OWN
	EDITNAM_BUF:	BLOCK[64,BYTE];		! Edit logicalname buf

GLOBAL
	MAIL$GL_FLAGS : $BBLOCK[4],		! MAIL control flags
	MAIL$L_SMG_DISPLAY,			! Display id from SMG
	MAIL$L_SMG_KEYBOARD,			! Keyboard id from SMG
	MAIL$L_SMG_KEYTABLE,			! Keytable id from SMG
	MAIL$GL_BIGBUFSIZ : LONG INITIAL(127),	! Size of big buffer
	MAIL$GL_BIGBUFFER : REF $BBLOCK,	! Address of buffer
	MAIL$GL_SYSFLAGS : $BBLOCK[4],		! system-wide control flags
	MAIL$L_SIZLIM : LONG INITIAL(3),	! If > this, then write to file
	MAIL$L_MYUIC,				! UIC of user
	MAIL$L_MYPID,				! PID of user
	MAIL$Q_ATTDESC : DYN_DESC_DECL,		! Send/attach for mr
	MAIL$Q_CLUNODES : DYN_DESC_DECL,	! Descriptor of cluster nodes
	MAIL$Q_SYSPRVMSK: BLOCK[8,BYTE]		! Mask to enable/disable SYSPRV
			PRESET([PRV$V_SYSPRV] = 1),
	MAIL$Q_PROCPRIV : $BBLOCK[8],		! Process privileges
	MAIL$Q_INPTRAN:	BLOCK[8,BYTE],		! SYS$INPUT translation 
	MAIL$L_INPCLASS : VOLATILE,		! DVI$_DEVCLASS for input
	MAIL$L_INPDEVDP : VOLATILE,		! DVI$_DEVDEPEND2 for input
	MAIL$L_OUTCLASS : VOLATILE,		! DVI$_DEVCLASS for output
	MAIL$L_OUTDEVDP : VOLATILE,		! DVI$_DEVDEPEND2 for output
	MAIL$L_OUTLINES,			! Number of lines for output
	MAIL$Q_EDITNAM_DESC: VECTOR[2,LONG]	! Edit logical name desc
			INITIAL(LONG(64,EDITNAM_BUF)),
	MAIL$B_DFW : BYTE,			! True if should use FOP=DFW
	MAIL$W_TTCHAN : WORD,			! Channel for terminal
	MAIL$Q_USERNAME:BLOCK[8,BYTE],		! Username descriptor
	MAIL$G_CNCT : $BBLOCK[CNCT_C_LENGTH+RAB$C_BLN] !CNCT block
			PRESET([CNCT_B_FILRAT] = FAB$M_CR,
				[CNCT_B_FILRFM] = FAB$C_VAR),
	MAIL$Q_SYSNODE: $BBLOCK[DSC$C_S_BLN],	! Descriptor for SYS$NODE
						!  translation
	MAIL$Q_SYSNODE2: $BBLOCK[DSC$C_S_BLN]	! Same thing with '::' on end
			PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
				[DSC$B_CLASS] = DSC$K_CLASS_D),
	MAIL$Q_CALEDTNAM : DYN_DESC_DECL,	!editor from 'callable_editn'
	MAIL$Q_PROTOCOL : DYN_DESC_DECL,	!descriptor of network protocol
						! image file
	MAIL$Q_MAILDEF : DYN_DESC_DECL,		!dev/dir + 'MAIL.MAI'
	MAIL$Q_USERDEF: DYN_DESC_DECL;		!Descriptor of user's mail
						! directory
GLOBAL BIND
    MAIL$Q_TO = MAIL$G_CNCT[CNCT_Q_TODESC] : $BBLOCK, !"To" string
    MAIL$Q_SUBJ = MAIL$G_CNCT[CNCT_Q_SUBJDESC] : $BBLOCK, !"Subj" string
    MAIL$Q_FULLUSER = MAIL$G_CNCT[CNCT_Q_FROMDESC] : $BBLOCK, !and user
    MAIL$T_TMP_RAB = MAIL$G_CNCT[CNCT_T_RAB] : $BBLOCK;

BIND
    TMP_BUFF = MAIL$G_CNCT[CNCT_T_BUFFER] : $BBLOCK,
    TMP_RAB = MAIL$G_CNCT[CNCT_T_RAB] : $BBLOCK;

OWN
	CTRL_MASK,				! Mask returned from dis_ctrl
	TPA_NUMBER,				! Number parsed in tparse
	ENHANCED_PRIVS : VECTOR[2,LONG],	!Remember privs we added
	TMP_ESNAM_BUF:	VECTOR[NAM$C_MAXRSS,BYTE], ! Temporary filename buffer
	CLIFLAGS:	BITVECTOR[32],		! CLI flags vector
	PROCSTS:	LONG,			! Process status
	CLI_EDITQUAL:	BITVECTOR[32],		! Flags from DCL MAIL/EDIT
	CLI_EXTRACT :	BYTE,			! True if /EDIT=REPLY=EXTRACT
	CLI_SIGNALLED,				! True if CLI signalled parse error
	USERNAME:	VECTOR[UAF$S_USERNAME,BYTE], ! Username buffer
	SYSNODEBUF:	VECTOR[64,BYTE],	! SYS$NODE translation buffer
	TMP_NAM:	$NAM_DECL,		! TMP file NAM block
	TMP_FAB:	$FAB_DECL,		!  and FAB
	TMP_XAB:	$XABPRO_DECL,
	EXIT_STATUS,
	EXIT_BLOCK:	VECTOR[4,LONG]		! For $DCLEXH
			INITIAL (0,EXIT_ROUTINE,1,EXIT_STATUS),
	TMP_ESNAM_DESC: $BBLOCK[8]		! TMP filename descriptor
			PRESET([DSC$A_POINTER] = TMP_ESNAM_BUF),
	FILE_DESC:	BLOCK[8,BYTE],		! Message file descriptor
	TMPFILE_DESC:	DYN_DESC_DECL,
	TMPFILE1_DESC:	DYN_DESC_DECL,
	COMMAND_DESC:	DYN_DESC_DECL,
	DYN_DESC:	DYN_DESC_DECL,
	DYN_DESC_2:	DYN_DESC_DECL,
	INPUT_DESC:	DYN_DESC_DECL;


GLOBAL BIND
	MAIL$Q_ENHANCED_PRIVS = ENHANCED_PRIVS;

BIND
	NULL_CHAR  =    UPLIT('@'),
	COMMA_DESC =	$DESCRIPTOR(','),
	SLASH_DESC =	$DESCRIPTOR('/'),
	SYSIN_DESC =	$DESCRIPTOR('SYS$INPUT') : $BBLOCK,
	GETPROCSTS =	UPLIT(	WORD(4),	! Get process status $GETJPI
				WORD(JPI$_STS),	! list
				LONG(PROCSTS),
				LONG(0),
				WORD(UAF$S_USERNAME),! Get username list
				WORD(JPI$_USERNAME),
				LONG(USERNAME),
				LONG(MAIL$Q_USERNAME),
				WORD(8),	!Process privs
				WORD(JPI$_PROCPRIV),
				LONG(MAIL$Q_PROCPRIV),
				LONG(0),
				WORD(4),	!Process PID
				WORD(JPI$_PID),
				LONG(MAIL$L_MYPID),
				LONG(0),
				LONG(0)),
	TMPFILE_FAO_CDESC = $DESCRIPTOR('SYS$SCRATCH:MAIL_!XL.TMP')! Temporary file name
		     :	BLOCK[,BYTE],
	TMPFILE1_FAO_CDESC = DESCRIPTOR('SYS$SCRATCH:MAIL1_!XL.TMP')
			: $BBLOCK,			! Used for FOR/EDIT
	TMPFILE_FAO_DESC = $DESCRIPTOR('SYS$SCRATCH:MAIL_!XW.TMP')! Temporary file name
		     :	BLOCK[,BYTE],
	TMPFILE1_FAO_DESC = DESCRIPTOR('SYS$SCRATCH:MAIL1_!XW.TMP')
			: $BBLOCK,			! Used for FOR/EDIT
	CALLABLE_EDT = UPLIT (%ASCIC 'CALLABLE_') : VECTOR[,BYTE],
	TOPIC_DESC = FILE_DESC;			! Help topic descriptor

GLOBAL BIND
	MAIL$Q_TMPFILE_DESC = TMPFILE_DESC;	! Make descriptor available

LITERAL
	PRO_SYS		= $BITPOSITION(XAB$V_SYS),
	PRO_OWN		= $BITPOSITION(XAB$V_OWN),
	PRO_GRP		= $BITPOSITION(XAB$V_GRP),
	PRO_WLD		= $BITPOSITION(XAB$V_WLD),
	
	TMP_PRO =					!Temp file protection
(				  XAB$M_NOEXE		    ) ^ PRO_SYS OR
(				  XAB$M_NOEXE		    ) ^ PRO_OWN OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_GRP OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_WLD;

GLOBAL LITERAL
    MAIL$C_TMP_PRO = TMP_PRO;			!Make available globally
!
! Declare static strings for qualifier names
!
SD(
    'ATTACHMENT',
    'HEADER',
    'EXTRACT',
    'FILE',
    'FILEMF',
    'EDT',
    'EDIT',
    'LNM$SYSTEM',
    'LNM$FILE_DEV',
    'MAIL$INIT',
    'MAIL$SYSTEM_FLAGS',
    'PROTOCOL',
    'REPLF',
    'SELF',
    'SEND1',
    'SUBJECT',
    'LAST',
    'NEXT',
    'TOLIST',
    'USER',
    'TPU');

GLOBAL BIND
    MAIL$SD_LNM_FILE_DEV = SD_LNM$FILE_DEV,
    MAIL$SD_LNM_SYSTEM = SD_LNM$SYSTEM,
    MAIL$SD_USER = SD_USER;
!
! Define local names for shared messages
!
$SHR_MSGDEF(MAIL,126,LOCAL,
	(OPENIN,ERROR),
	(PARSEFAIL,WARNING),
	(OPENOUT,ERROR),
	(READERR,WARNING),
	(WRITEERR,WARNING),
	(CLOSEIN,WARNING),
	(CLOSEOUT,WARNING));

!
! TPARSE table to determine if a number is present as the command
!
$INIT_STATE (DECNUM_STATE,DECNUM_KEY);

$STATE	(,
	(TPA$_DECIMAL));
$STATE	(,
	('/',TPA$_EXIT),
	(TPA$_EOS,TPA$_EXIT));
!
! TPARSE table to parse /EDIT qualifier values
!
$INIT_STATE(EDITQUAL_STATE,EDITQUAL_KEY);

$STATE	(,
	('SEND',TPA$_EXIT,,1^F_SEND_EDIT,CLI_EDITQUAL),
	('REPLY',TPA$_EXIT,,1^F_REPLY_EDIT,CLI_EDITQUAL),
	('FORWARD',TPA$_EXIT,,1^F_FORW_EDIT,CLI_EDITQUAL));
!
! TPARSE table to parse a number, either octal, decimal, or hex
!
$INIT_STATE(GETNUM_STATE,GETNUM_KEY);
$STATE(,
	(TPA$_DECIMAL,TPA$_EXIT,,,TPA_NUMBER),
	('%',GET_OCTHEX));
$STATE(GET_OCTHEX,
	('O',GET_OCT),
	('X',GET_HEX));
$STATE(GET_OCT,
	(TPA$_OCTAL,TPA$_EXIT,,,TPA_NUMBER));
$STATE(GET_HEX,
	(TPA$_HEX,TPA$_EXIT,,,TPA_NUMBER));

GLOBAL ROUTINE MAIL$DISABLE_CTRLC : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Disable CTRL/C ast
!
!--
BEGIN
MAIL$GL_FLAGS[MAIF_V_CTRLCFL] = 0;
IF .MAIL$W_TTCHAN NEQ 0
    THEN $CANCEL(CHAN=.MAIL$W_TTCHAN);
RETURN;
END;

ROUTINE CTRLCAST : NOVALUE =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	Handles the CTRL/C ast, re-enables for next one
!
MAIL$ENABLE_CTRLC();
MAIL$GL_FLAGS[MAIF_V_CTRLCFL] = 1;
RETURN;
END;

GLOBAL ROUTINE MAIL$ENABLE_CTRLC =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Enables control-c's on MAIL$W_TTCHAN
!
!--
BEGIN
LOCAL
    IOSB :VECTOR[4,WORD];

MAIL$GL_FLAGS[MAIF_V_CTRLCFL] = 0;
IF .MAIL$GL_FLAGS[MAIF_V_ITERM]
THEN BEGIN
    IF_ERR($QIOW(CHAN=.MAIL$W_TTCHAN,
		FUNC=IO$_SETMODE OR IO$M_CTRLCAST,
		IOSB=IOSB,
		P1=CTRLCAST,
		P2=0);,
	    SIGNAL(.STATUS));
    IF NOT .IOSB[0]
	THEN SIGNAL(.IOSB[0]);
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$DISABLE_CTRLY : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Disable CLI control/y handling
!
!--
BEGIN

IF_ERR(LIB$DISABLE_CTRL(%REF(%X'02000000'),CTRL_MASK);,
	SIGNAL(.STATUS));
RETURN;
END;

GLOBAL ROUTINE MAIL$ENABLE_CTRLY : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Enable CLI control/y handling
!
!--
BEGIN

IF_ERR(LIB$ENABLE_CTRL(CTRL_MASK);,
	SIGNAL (.STATUS));
RETURN;
END;

ROUTINE call_tparse(string,states,keys) =
BEGIN

!
! This routine calls tparse given the string, states and keys
!
! Inputs:
!
!	string		address of string descriptor for string to parse
!	states		address of tparse states table
!	keys		address of tparse keys table
!

MAP
    string : REF $BBLOCK;

LOCAL
    tpablock : $bblock[tpa$k_length0],
    status;

!
! Initialize the tparse block
!
CH$FILL(0,tpa$k_length0,tpablock);
tpablock[tpa$l_count] = tpa$k_count0;
tpablock[tpa$l_options] = tpa$m_abbrev;
tpablock[tpa$l_stringcnt] = .string[dsc$w_length];
tpablock[tpa$l_stringptr] = .string[dsc$a_pointer];

RETURN lib$tparse(tpablock,.states,.keys)

END;

ROUTINE PARSE_EDIT_QUAL (CLIDEFAULT) =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the /EDIT qualifier on SEND and REPLY
!	commands, taking into account the DCL MAIL/EDIT qualifier.
!
! INPUTS:
!
!	CLIDEFAULT is the state of /EDIT from the DCL MAIL/EDIT command
!--
LOCAL
    EDIT_STATUS;
!
! Set the edit flag if either MAIL/EDIT, or /EDIT on this command.  Then,
! if user explicitly said /NOEDIT, clear the flag
!
EDIT_STATUS = CLI$PRESENT(SD_EDIT);
CLIFLAGS[EDIT_FLAG] = .CLIDEFAULT OR .EDIT_STATUS;
IF .EDIT_STATUS EQL CLI$_NEGATED
    OR .EDIT_STATUS EQL CLI$_LOCNEG
    THEN CLIFLAGS[EDIT_FLAG] = 0;

IF NOT .MAIL$GL_FLAGS[MAIF_V_ITERM]
    THEN (EDIT_STATUS = 0; CLIFLAGS[EDIT_FLAG] = 0);

RETURN .EDIT_STATUS
END;

GLOBAL ROUTINE MAIL$CMD_SET_EXIT = (CLIFLAGS[EXIT_FLAG] = 1;RETURN 1);
GLOBAL ROUTINE MAIL$CMD_SET_QUIT = (CLIFLAGS[QUIT_FLAG] = 1;RETURN 1);
GLOBAL ROUTINE MAIL$CMD_NULL = RETURN 1;

GLOBAL ROUTINE MAIL$CMD_ERASE = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	Erase the screen.  
!--
BEGIN
LOCAL
    DESC : VECTOR[2,LONG];

!DESC[0] = 0;
!DESC[1] = DESC[0];
!MAIL$PUT_OUTPUT(DESC);
RETURN SMG$ERASE_PASTEBOARD(MAIL$L_SMG_DISPLAY);
END;

ROUTINE IGNORE_SIGNALS =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	Ignore any signals by setting SS$_CONTINUE
!--

CLI_SIGNALLED = 1;
RETURN SS$_CONTINUE
END;

ROUTINE DEFINE_DEFAULT_KEYPAD : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Define the default keypad.
!
!--
BEGIN

BIND
    KEYDEFTAB = PLIT(
		$DESCRIPTOR('DEF/K PF1 "" /NOTERM/SET=GOLD/NOLOCK'),
		$DESCRIPTOR('DEF/K PF2 "HELP"/TERM'),
		$DESCRIPTOR('DEF/K PF3 "EXTRACT/MAIL"/TERM'),
		$DESCRIPTOR('DEF/K PF4 "ERASE" /TERM /NOECHO'),
		$DESCRIPTOR('DEF/K KP7 "SEND"/TERM'),
		$DESCRIPTOR('DEF/K KP8 "REPLY"/TERM'),
		$DESCRIPTOR('DEF/K KP9 "FORWARD"/TERM'),
		$DESCRIPTOR('DEF/K KP4 "CURRENT"/TERM'),
		$DESCRIPTOR('DEF/K KP5 "FIRST"/TERM'),
		$DESCRIPTOR('DEF/K KP6 "LAST"/TERM'),
		$DESCRIPTOR('DEF/K KP3 "DIR"/TERM'),
		$DESCRIPTOR('DEF/K KP2 "PRINT"/TERM'),
		$DESCRIPTOR('DEF/K KP1 "BACK"/TERM'),
		$DESCRIPTOR('DEF/K KP0 "NEXT"/TERM'),
		$DESCRIPTOR('DEF/K MINUS "READ/NEW"/TERM'),
		$DESCRIPTOR('DEF/K COMMA "DIR/NEW"/TERM'),
		$DESCRIPTOR('DEF/K PERIOD "FILE "/NOTERM'),
		$DESCRIPTOR('DEF/K PF2 "DIR/FOLDER"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K PF3 "EXTRACT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K PF4 "SELECT MAIL"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP7 "SEND/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP8 "REPLY/EDIT/EXTRACT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP9 "FORWARD/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP4 "CURRENT/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP5 "FIRST/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP6 "LAST/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP3 "DIR/START=999999"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP2 "PRINT/PRINT/NOTIFY"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP1 "BACK/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K KP0 "NEXT/EDIT"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K MINUS "SHOW NEW"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K COMMA "DIR MAIL"/TERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K PERIOD "DELETE "/NOTERM/IF=GOLD'),
		$DESCRIPTOR('DEF/K ENTER "SELECT "/NOTERM/IF=GOLD')
					) : VECTOR[,LONG],
    NUMBER_KEYDEFINES = KEYDEFTAB[-1] : LONG;

INCRU I FROM 0 TO .NUMBER_KEYDEFINES-1
    DO SMG$DEFINE_KEY(MAIL$L_SMG_KEYTABLE,.KEYDEFTAB[.I]);

RETURN;
END;

ROUTINE LOAD_KEY_DEFS =
!++
! FUNCTIONAL DESCRIPTION:
!
!	If MAIL$INIT is defined, load the specified file
!
!--
BEGIN
LOCAL
    DESC : VECTOR[2,LONG] VOLATILE,
    STATUS,
    TMPFAB : $FAB_DECL,
    TMPRAB : $RAB_DECL,
    TMPNAM : $NAM_DECL,
    NAMBUF : $BBLOCK[NAM$C_MAXRSS],
    TRNLNMLST : $ITMLST_DECL(ITEMS=1),
    IBUF : $BBLOCK[255];

BIND
    DPTR = DESC[1] : REF VECTOR[,BYTE];

DESC[0] = NAM$C_MAXRSS;
DESC[1] = IBUF;
$ITMLST_INIT(ITMLST=TRNLNMLST,
	(ITMCOD=LNM$_STRING,BUFADR=.DESC[1],BUFSIZ=.DESC[0],RETLEN=DESC[0]));

IF NOT $TRNLNM(ATTR=%REF(LNM$M_CASE_BLIND),
		TABNAM=MAIL$SD_LNM_FILE_DEV,
		LOGNAM=SD_MAIL$INIT,
		ITMLST=TRNLNMLST)
    THEN RETURN TRUE;

$FAB_INIT(FAB=TMPFAB,
	FNS=.DESC[0],
	FNA=.DESC[1],
	DNM='MAIL$INIT.INI',
	CTX=MAIL$_OPENIN,
	FAC=GET,
	FOP=SQO);

$NAM_INIT(NAM=TMPNAM,
	ESS=NAM$C_MAXRSS,
	ESA=NAMBUF,
	RSS=NAM$C_MAXRSS,
	RSA=NAMBUF);

IF_ERR($OPEN(FAB=TMPFAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

$RAB_INIT(RAB=TMPRAB,
	FAB=TMPFAB,
	CTX=MAIL$_OPENIN,
	UBF=IBUF,
	USZ=512);

IF_ERR($CONNECT(RAB=TMPRAB,ERR=UTIL$REPORT_IO_ERROR);,
	$CLOSE(FAB=TMPFAB);
	RETURN .STATUS);

TMPRAB[RAB$L_CTX] = MAIL$_READERR;
WHILE $GET(RAB=TMPRAB,ERR=UTIL$REPORT_IO_ERROR)
DO BEGIN
    DESC[0] = .TMPRAB[RAB$W_RSZ];
    DESC[1] = .TMPRAB[RAB$L_RBF];
    IF .DESC[0] NEQ 0
	AND .DPTR[0] NEQ %C'!'
	THEN IF_ERR(SMG$DEFINE_KEY(MAIL$L_SMG_KEYTABLE,DESC);,
			SIGNAL(MAIL$_PARSEFAIL,1,DESC,.STATUS));
    END;

$CLOSE(FAB=TMPFAB);
RETURN TRUE
END;

ROUTINE MAIL_DISPATCH =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine attempts to parse the input file spec from DCL
!	and then dispatches to process either a CLI, or interactive command
!
BEGIN
BUILTIN
	FP;

LOCAL
	DESC : $BBLOCK[DSC$C_S_BLN],
	STATUS;

.FP = IGNORE_SIGNALS;

STATUS = 0;
STATUS = CLI$GET_VALUE(SD_FILE,INPUT_DESC);

.FP = 0;

INIT_SDESC(DESC);
DESC[DSC$W_LENGTH] = .MAIL$L_USRSYSBUF[VMD_B_FNMLNG];
DESC[DSC$A_POINTER] = MAIL$L_USRSYSBUF[VMD_T_FWDNAM] +
				.MAIL$L_USRSYSBUF[VMD_B_FWDLNG];

MAIL$SET_NAME(DESC);

RETURN (IF .STATUS
		AND NOT .CLI_SIGNALLED
		    THEN CLI_COMMAND()
		    ELSE INTJOB()) OR STS$M_INHIB_MSG
END;

ROUTINE CHECK_SERVER : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	If /PROTOCOL specified on the command line, and the process
!	has SYSPRV and DETACH, then pretend it's a network server.
!	This allows foreign protocol input without network connections.
!--
BEGIN
BUILTIN FP;

.FP = IGNORE_SIGNALS;
IF CLI$PRESENT(SD_PROTOCOL)
    AND .MAIL$Q_PROCPRIV[PRV$V_SYSPRV]
    AND .MAIL$Q_PROCPRIV[PRV$V_DETACH]
THEN MAIL$GL_FLAGS[MAIF_V_NETJOB] = 1;
RETURN;
END;

GLOBAL ROUTINE MAIL =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Main entry point to MAIL utility.  Determines type of use: CLI command
!	processor, interactive mail command processor, or slave process for
!	network mail processing.
!
! INPUTS:
!
!	Command language interpreter parameters.
!
! OUTPUTS:
!
!	Mail utility executed.
!--
BEGIN
LOCAL
	DESC : VECTOR[2,LONG] VOLATILE,
	PTR : REF $BBLOCK,
	PRIVMASK : $BBLOCK[8],
	TRNLNMLST : $ITMLST_DECL(ITEMS=1),
	STATUS;

ENABLE MAIL$HANDLE;				! Enable condition handler
!
! Determine if process is an interactive or network job
!
IF_ERR($GETJPIW(ITMLST=GETPROCSTS);,
	RETURN .STATUS;);
MAIL$GL_FLAGS[MAIF_V_BATCH] = .PROCSTS<$BITPOSITION(PCB$V_BATCH),1>;
MAIL$GL_FLAGS[MAIF_V_NETJOB] = .PROCSTS<$BITPOSITION(PCB$V_NETWRK),1>;
CHECK_SERVER();
IF NOT .MAIL$GL_FLAGS[MAIF_V_NETJOB]
THEN BEGIN
    !
    ! Disable privs that user doesn't have
    !
    PRIVMASK<0,32,0> = 0;
    PRIVMASK[PRV$V_WORLD] = NOT .MAIL$Q_PROCPRIV[PRV$V_WORLD];
    PRIVMASK[PRV$V_OPER] = NOT .MAIL$Q_PROCPRIV[PRV$V_OPER];
    PRIVMASK[PRV$V_SYSNAM] = NOT .MAIL$Q_PROCPRIV[PRV$V_SYSNAM];
    PRIVMASK[PRV$V_SYSPRV] = NOT .MAIL$Q_PROCPRIV[PRV$V_SYSPRV];
    PRIVMASK<32,32,0> = 0;
    $SETPRV(ENBFLG=0,PRVADR=PRIVMASK);
    END;
!
! Allocate some buffers
!
IF_ERR(LIB$GET_VM(%REF(UAF$C_LENGTH),MAIL$T_UAF_BUFF);,
	RETURN SIGNAL(.STATUS));
IF_ERR(LIB$GET_VM(%REF(.MAIL$GL_BIGBUFSIZ*512),MAIL$GL_BIGBUFFER);,
	RETURN SIGNAL(.STATUS));
IF_ERR(MAIL$IOSUB_INIT();,
	RETURN .STATUS);
MAIL$Q_INPTRAN[DSC$W_LENGTH] = (IF .MAIL$GL_FLAGS[MAIF_V_NETJOB]
			THEN 2*NAM$C_MAXRSS
			ELSE NAM$C_MAXRSS);

IF_ERR(LIB$GET_VM(MAIL$Q_INPTRAN[DSC$W_LENGTH],
			MAIL$Q_INPTRAN[DSC$A_POINTER]);,
	RETURN SIGNAL(.STATUS));
!
! Initialize global CNCT block
!
MAIL$Q_USERNAME[DSC$A_POINTER] = USERNAME;
MAIL$G_CNCT[CNCT_L_FLINK] = MAIL$G_CNCT[CNCT_L_FLINK];
MAIL$G_CNCT[CNCT_L_BLINK] = MAIL$G_CNCT[CNCT_L_FLINK];
MAIL$G_CNCT[CNCT_Q_ADRLST]+4 =
	(MAIL$G_CNCT[CNCT_Q_ADRLST])<0,32,0> = MAIL$G_CNCT[CNCT_Q_ADRLST];
MAIL$G_CNCT[CNCT_Q_LNKLST]+4 =
	(MAIL$G_CNCT[CNCT_Q_LNKLST])<0,32,0> = MAIL$G_CNCT[CNCT_Q_LNKLST];
PTR = MAIL$G_CNCT[CNCT_Q_FROMDESC];
INIT_DDESC(PTR);
PTR = MAIL$G_CNCT[CNCT_Q_TODESC];
INIT_DDESC(PTR);
PTR = MAIL$G_CNCT[CNCT_Q_SUBJDESC];
INIT_DDESC(PTR);
!
! Translate MAIL$SYSTEM_FLAGS
!
DESC[0] = 0;
DESC[1] = .MAIL$GL_BIGBUFFER;
$ITMLST_INIT(ITMLST=TRNLNMLST,
	(ITMCOD=LNM$_STRING,BUFADR=.MAIL$GL_BIGBUFFER,
		BUFSIZ=64,RETLEN=DESC));

IF $TRNLNM(ATTR=%REF(LNM$M_CASE_BLIND),
	TABNAM=SD_LNM$SYSTEM,
	LOGNAM=SD_MAIL$SYSTEM_FLAGS,
	ACMODE=%REF(PSL$C_EXEC),
	ITMLST=TRNLNMLST)
    THEN IF CALL_TPARSE(DESC,GETNUM_STATE,GETNUM_KEY)
	THEN MAIL$GL_SYSFLAGS = .TPA_NUMBER;

!
! Translate SYS$INPUT or SYS$NET logical name and get device's characteristics
!
$ITMLST_INIT(ITMLST=TRNLNMLST,
	(ITMCOD=LNM$_STRING,BUFADR=.MAIL$Q_INPTRAN[DSC$A_POINTER],
		BUFSIZ=.MAIL$Q_INPTRAN[DSC$W_LENGTH],RETLEN=MAIL$Q_INPTRAN));

STATUS = $TRNLNM(ATTR=%REF(LNM$M_CASE_BLIND),
		TABNAM=MAIL$SD_LNM_FILE_DEV,
		LOGNAM=(IF .MAIL$GL_FLAGS[MAIF_V_NETJOB]
				THEN $DESCRIPTOR('SYS$NET')
				ELSE SYSIN_DESC),
		ITMLST=TRNLNMLST);
IF CH$RCHAR(.MAIL$Q_INPTRAN[DSC$A_POINTER]) EQL ESC	! Check for RMS escape
THEN	BEGIN				! If so, strip it off name
	MAIL$Q_INPTRAN[DSC$W_LENGTH] =  .MAIL$Q_INPTRAN[DSC$W_LENGTH] - 4;
	MAIL$Q_INPTRAN[DSC$A_POINTER] = .MAIL$Q_INPTRAN[DSC$A_POINTER] + 4;
	END;
!
! Translate SYS$NODE.  Strip off the leading "_" and trailing colons
! if they are present.
!
MAIL$Q_SYSNODE[DSC$W_LENGTH] = 64;
MAIL$Q_SYSNODE[DSC$A_POINTER] = SYSNODEBUF;
$ITMLST_INIT(ITMLST=TRNLNMLST,
	(ITMCOD=LNM$_STRING,BUFADR=SYSNODEBUF,BUFSIZ=64,RETLEN=MAIL$Q_SYSNODE));

IF NOT (STATUS = $TRNLNM(ATTR=%REF(LNM$M_CASE_BLIND),
			TABNAM=SD_LNM$SYSTEM,
			LOGNAM=$DESCRIPTOR('SYS$NODE'),
			ACMODE=%REF(PSL$C_EXEC),
			ITMLST=TRNLNMLST))
    THEN MAIL$Q_SYSNODE[DSC$W_LENGTH] = 0
    ELSE BEGIN
	IF .SYSNODEBUF[0] EQL '_'
	    THEN BEGIN
		MAIL$Q_SYSNODE[DSC$W_LENGTH] = .MAIL$Q_SYSNODE[DSC$W_LENGTH] -1;
		MAIL$Q_SYSNODE[DSC$A_POINTER] = .MAIL$Q_SYSNODE[DSC$A_POINTER] + 1;
		END;
	INCRU I FROM 0 TO 1
	    DO IF NOT CH$FAIL(CH$FIND_CH(.MAIL$Q_SYSNODE[DSC$W_LENGTH],
			.MAIL$Q_SYSNODE[DSC$A_POINTER],':'))
		THEN MAIL$Q_SYSNODE[DSC$W_LENGTH] = .MAIL$Q_SYSNODE[DSC$W_LENGTH] - 1;
	!
	! Make a copy with colons on the end for forwarding loop detection
	!
	STR$CONCAT(MAIL$Q_SYSNODE2,MAIL$Q_SYSNODE,$DESCRIPTOR('::'));
	END;
!
! Get SYS$INPUT and SYS$OUTPUT device characteristics
!
BEGIN
    LOCAL
	GETDVILST : $ITMLST_DECL(ITEMS=2);

    $ITMLST_INIT(ITMLST=GETDVILST,
	(ITMCOD=DVI$_DEVCLASS,BUFADR=MAIL$L_INPCLASS),
	(ITMCOD=DVI$_DEVDEPEND,BUFADR=MAIL$L_INPDEVDP));

    $GETDVIW(DEVNAM=MAIL$Q_INPTRAN,
	ITMLST=GETDVILST);

    $ITMLST_INIT(ITMLST=GETDVILST,
	(ITMCOD=DVI$_DEVCLASS,BUFADR=MAIL$L_OUTCLASS),
	(ITMCOD=DVI$_DEVDEPEND,BUFADR=MAIL$L_OUTDEVDP));

    $GETDVIW(DEVNAM=$DESCRIPTOR('SYS$OUTPUT'),
	ITMLST=GETDVILST);
    END;

IF .MAIL$L_INPCLASS EQL DC$_TERM
    THEN MAIL$GL_FLAGS[MAIF_V_ITERM] = 1;

IF .MAIL$L_OUTCLASS EQL DC$_TERM
THEN BEGIN
    MAIL$GL_FLAGS[MAIF_V_OTERM] = 1;
    MAIL$GL_FLAGS[MAIF_V_SCOPE] = .MAIL$L_OUTDEVDP<$BITPOSITION(TT$V_SCOPE),1>;
    END;

MAIL$L_OUTLINES = 
	.MAIL$L_OUTDEVDP<$BITPOSITION(TT$V_PAGE),$FIELDWIDTH(TT$V_PAGE)>;
IF .MAIL$GL_FLAGS[MAIF_V_BATCH]			!No need for pages in batch
    OR .MAIL$L_OUTLINES EQL 0
    THEN MAIL$L_OUTLINES = %X'7FFFFFFF';
!
! Open the system user authorization file and the mail system data file
!
IF_ERR(MAIL$OPEN_UAF();,RETURN .STATUS);
IF_ERR(MAIL$OPEN_SYSMAI();,RETURN .STATUS);
!
! Create the string descriptors for temporary files
!
DESC[0] = NAM$C_MAXRSS;
DESC[1] = .MAIL$GL_BIGBUFFER;
SYS$FAO((IF .MAIL$L_MYPID<16,16,0> NEQ 0
		THEN TMPFILE_FAO_CDESC
		ELSE TMPFILE_FAO_DESC),DESC,DESC,.MAIL$L_MYPID);
STR$COPY_DX(TMPFILE_DESC,DESC);
DESC[0] = NAM$C_MAXRSS;
DESC[1] = .MAIL$GL_BIGBUFFER;
SYS$FAO((IF .MAIL$L_MYPID<16,16,0> NEQ 0
		THEN TMPFILE1_FAO_CDESC
		ELSE TMPFILE1_FAO_DESC),DESC,DESC,.MAIL$L_MYPID);
STR$COPY_DX(TMPFILE1_DESC,DESC);
!
! If this is a network process, dispatch to the network server code
!
IF .MAIL$GL_FLAGS[MAIF_V_NETJOB]
    THEN RETURN NETJOB();
!
! Declare an exit handler to clean up any logical links on exit
!
$DCLEXH(DESBLK=EXIT_BLOCK);
!
! Dispatch according to whether this is a CLI command request, an interactive
! mail utility session.
!

RETURN MAIL_DISPATCH()

END;


ROUTINE CLI_COMMAND =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Callback the CLI for the rest of the command parameters and send
!	the specified file to the specified users.  Then return to the CLI.
!
! INPUTS:
!
!	INPUT_DESC = CLI request descriptor for input filespec.
!
! OUTPUTS:
!
!	Input file sent to specified users.
!--
BEGIN

OWN
    EXITVALUE : $BBLOCK[4] INITIAL(1);

ROUTINE HANDLER (SIGARGS,MECHARGS) =
BEGIN
MAP
    sigargs : REF $BBLOCK,
    mechargs : REF $BBLOCK;

BIND
    signame = sigargs [chf$l_sig_name] : $BBLOCK;	!Name of signal

IF NOT .signame				!If its an error signal
    AND ((.signame [sts$v_severity]	! and severity is worse than it was
	GEQU .exitvalue [sts$v_severity])
	OR .exitvalue [sts$v_severity])	! or we haven't had any errors
    THEN exitvalue = .signame;		! then remember it for exiting

RETURN SS$_RESIGNAL
END;

BUILTIN
    FP;

LOCAL
	SELF_FLAG,
	TT_INPUT,
	STATUS: LONG;

BIND
	NAMDVI = TMP_NAM[NAM$T_DVI] : VECTOR[,BYTE];

.FP = HANDLER;
!
! Open the input file and get the subject
!
$FAB_INIT(FAB=TMP_FAB,
	DEQ=4,
	NAM=TMP_NAM,
	DNM='.TXT',
	CTX=MAIL$_OPENIN,
	FNS = .INPUT_DESC[DSC$W_LENGTH],
	FNA = .INPUT_DESC[DSC$A_POINTER],
	RAT = CR,
	RFM = VAR,
	FOP = SQO,
	FAC = (GET,BRO));

$NAM_INIT(NAM=TMP_NAM,
	RSA=TMP_ESNAM_BUF,
	RSS=NAM$C_MAXRSS,
	ESA=TMP_ESNAM_BUF,
	ESS=NAM$C_MAXRSS);

IF_ERR( $OPEN(FAB=TMP_FAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

$RAB_INIT(RAB=TMP_RAB,
	FAB=TMP_FAB,
	CTX=MAIL$_OPENIN,
	UBF=TMP_BUFF,
	USZ=MAIL$K_INBUFFSZ);

TT_INPUT = 0;
IF .TMP_FAB[$FAB_DEV(TRM)]
    OR (.TMP_NAM[NAM$V_PPF]
	AND CH$EQL(.SYSIN_DESC[DSC$W_LENGTH],.SYSIN_DESC[DSC$A_POINTER],
			.NAMDVI[0],NAMDVI[1],0))
    THEN TT_INPUT = 1;
IF NOT .TT_INPUT
THEN BEGIN
    TMP_RAB[RAB$V_BIO] = TRUE;
    MAIL$G_CNCT[CNCT_B_FILRAT] = .TMP_FAB[FAB$B_RAT];
    MAIL$G_CNCT[CNCT_B_FILRFM] = .TMP_FAB[FAB$B_RFM];
    END;

IF_ERR($CONNECT(RAB=TMP_RAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);
TMP_RAB[RAB$L_CTX] = MAIL$_READERR;

IF_ERR(SMG$CREATE_VIRTUAL_KEYBOARD(MAIL$L_SMG_KEYBOARD,SYSIN_DESC);,
		RETURN SIGNAL(.STATUS));
IF_ERR(SMG$CREATE_KEY_TABLE(MAIL$L_SMG_KEYTABLE);,
		RETURN SIGNAL(.STATUS));
!
! Get qualifiers
!
CLI$GET_VALUE(SD_SUBJECT,MAIL$Q_SUBJ);
SELF_FLAG = CLI$PRESENT(SD_SELF);
!
! Get the user names to send to
!
WHILE CLI$GET_VALUE(SD_TOLIST,DYN_DESC)
DO BEGIN
    IF .MAIL$Q_TO[DSC$W_LENGTH] NEQ 0
	THEN STR$APPEND(MAIL$Q_TO,COMMA_DESC);
    STR$APPEND(MAIL$Q_TO,DYN_DESC);
    END;
IF .MAIL$Q_TO[DSC$W_LENGTH] EQL 0			! If no users, prompt
THEN BEGIN
    IF NOT (STATUS = MAIL$GET_INPUT(MAIL$Q_TO,MAIL$GETMSG(MAIL$_ISUB20)))
	THEN RETURN .STATUS;
    MAIL$UPCASE_Q(MAIL$Q_TO);
    END;
IF (.MAIL$L_USRSYSBUF[VMD_V_SELFSEND] OR .SELF_FLAG)
    AND ((.SELF_FLAG NEQ CLI$_NEGATED) AND (.SELF_FLAG NEQ CLI$_LOCNEG))
THEN BEGIN
    STR$APPEND(MAIL$Q_TO,COMMA_DESC);
    STR$APPEND(MAIL$Q_TO,MAIL$Q_USERNAME);
    END;
!
! Add the usernames to the addressee list and send the file to them.
!
MAIL$INI_ADDR(MAIL$G_CNCT);				! Init addressee list
MAIL$DELETELINK(MAIL$G_CNCT[CNCT_Q_LNKLST]);
MAIL$GET_CLUNODES();				!Create cluster node list
STATUS = CHECK_SEND(
	MAIL$ADD_ADDR(MAIL$Q_TO,MAIL$G_CNCT));		! Add the addresses
IF NOT .STATUS
    THEN RETURN .EXITVALUE;
!
! Send end of users and to-list
!
MAIL$NET_END_USERS(MAIL$G_CNCT);
!
! if the input file is SYS$INPUT or it's TRM (assume TT:), then copy it
! to a temporary file
!
IF .TT_INPUT
THEN BEGIN
    $CLOSE(FAB=TMP_FAB);
    !
    ! Open TMP_FAB to a temporary file
    !
    $FAB_INIT(FAB=TMP_FAB,
	DEQ=4,
	FNS=.TMPFILE_DESC[DSC$W_LENGTH],
	FNA=.TMPFILE_DESC[DSC$A_POINTER],
	CTX=MAIL$_OPENOUT,
	NAM=TMP_NAM,
	FOP=(SQO,TMD),
	RFM=VAR,
	RAT=CR,
	FAC=(GET,PUT,BRO));

    $NAM_INIT(NAM=TMP_NAM,
	RSA=TMP_ESNAM_BUF,
	RSS=NAM$C_MAXRSS,
	ESA=TMP_ESNAM_BUF,
	ESS=NAM$C_MAXRSS);

    $RAB_INIT(RAB=TMP_RAB,
	FAB=TMP_FAB,
	CTX=MAIL$_OPENOUT,
	UBF=TMP_BUFF,
	USZ=MAIL$K_INBUFFSZ);

    IF_ERR($CREATE(FAB=TMP_FAB,ERR=UTIL$REPORT_IO_ERROR);,
		RETURN .STATUS);

    IF_ERR($CONNECT(RAB=TMP_RAB,ERR=UTIL$REPORT_IO_ERROR);,
		$CLOSE(FAB=TMP_FAB);
		RETURN .STATUS);
    !
    ! If input is from terminal, assign a channel to it to enable CTRL/C AST's
    !
    IF .MAIL$GL_FLAGS[MAIF_V_ITERM]
	THEN $ASSIGN(CHAN=MAIL$W_TTCHAN,DEVNAM=MAIL$Q_INPTRAN);
    MAIL$ENABLE_CTRLC();
    SMG$DELETE_VIRTUAL_KEYBOARD(MAIL$L_SMG_KEYBOARD);	!Delete any previous
    IF_ERR(SMG$CREATE_VIRTUAL_KEYBOARD(MAIL$L_SMG_KEYBOARD,INPUT_DESC);,
		SIGNAL(.STATUS));
    IF NOT (STATUS = MAIL$ENTER(TMP_RAB))
	    THEN RETURN .STATUS;
    MAIL$DISABLE_CTRLC();
    END;
!
! Send the message
!
MAIL$SEND_ADDR(MAIL$G_CNCT);
RETURN .EXITVALUE					! Return the status
END;

ROUTINE NETJOB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If this is a network job, it doesn't process commands, rather it
!	is just a slave to send mail to some addressees that are at a different
!	network node than the sender.  This routine reads the sender's and
!	addressee's names from the master mail job and sends the mail to
!	the addressees.  It then just exits.
!
! INPUTS:
!
!	MAIL$Q_INPTRAN = SYS$NET logical name translation.
!
! OUTPUTS:
!
!	Mail message sent to specified addressee's.
!--
BEGIN
OWN
	DESC:	DYN_DESC_DECL;			!dynamic descriptor

BUILTIN
	FP;

LOCAL
	PTR : REF VECTOR[,BYTE],		! String pointer
	COUNT,
	PURGE_VEC : VECTOR[2,LONG],
	FORWARD_ERROR,				! Set if forwarding loop error
	STATUS;					! Status value
!
! Get value of /PROTOCOL qualifier in case inbound foreign net
!
.FP = IGNORE_SIGNALS;		!If not there, just ignore it
IF NOT CLI$GET_VALUE(SD_PROTOCOL,MAIL$Q_PROTOCOL)
    THEN STR$FREE1_DX(MAIL$Q_PROTOCOL);
.FP = 0;
!
! Get sender's name
!
INIT_DDESC(MAIL$Q_USERNAME);			! Create dynamic descriptor
MAIL$GL_FLAGS[MAIF_V_SERVERLOOP] = 1;		! Loop by default
!
! Begin looping.  Will exit loop when master disconnects the link.
!
WHILE TRUE
DO BEGIN
MAIL$G_CNCT[CNCT_B_FILRAT] = FAB$M_CR;
MAIL$G_CNCT[CNCT_B_FILRFM] = FAB$C_VAR;
MAIL$INI_ADDR(MAIL$G_CNCT);			! Initialize the list
MAIL$DELETELINK(MAIL$G_CNCT[CNCT_Q_LNKLST]);
!
! This first call will also create the logical link
!
IF_ERR(MAIL$GET_INPUT(MAIL$Q_USERNAME,LNK_C_IN_SENDER);,RETURN TRUE);
!
! Prevent an accvio, later will check for null username
!
IF .MAIL$Q_USERNAME[DSC$W_LENGTH] EQL 0
    THEN MAIL$Q_USERNAME[DSC$A_POINTER] = MAIL$Q_USERNAME;
!
! Check to see if we have been at this node before.  If so, signal
! the error and return.  Note the check is done before the sender
! node is put on to allow STAR::ME to send to STAR::YOU
!
FORWARD_ERROR = 0;
COUNT = .MAIL$Q_USERNAME[DSC$W_LENGTH];
PTR = .MAIL$Q_USERNAME[DSC$A_POINTER];
IF .MAIL$Q_SYSNODE2[DSC$W_LENGTH] NEQ 0		!Should not happen, but...
THEN INCRU I FROM 1 TO 10
DO BEGIN
    IF CH$FAIL(PTR = CH$FIND_SUB(.COUNT,.PTR,
		.MAIL$Q_SYSNODE2[DSC$W_LENGTH],
		.MAIL$Q_SYSNODE2[DSC$A_POINTER]))
	THEN EXITLOOP
	ELSE BEGIN
	    IF ((.PTR NEQ .MAIL$Q_USERNAME[DSC$A_POINTER])
		AND (.PTR[-1] NEQ %C':'))
		THEN EXITLOOP;
	    PTR = .PTR + .MAIL$Q_SYSNODE2[DSC$W_LENGTH];
	    COUNT = .COUNT - .MAIL$Q_SYSNODE2[DSC$W_LENGTH];
	    IF .I EQL 10
		THEN FORWARD_ERROR = 1;
	    END;
    END;
!
! Add sender's username to the node name, creating a full sender's name
!  unless the sender's node name and our node are the same node
!
IF .MAIL$Q_USERNAME[DSC$W_LENGTH] NEQ 0 THEN
BEGIN
IF NOT CH$FAIL(PTR = CH$FIND_CH(.MAIL$Q_INPTRAN[DSC$W_LENGTH],! Find end of node name
				 .MAIL$Q_INPTRAN[DSC$A_POINTER],
				 ':'))
THEN	BEGIN
	MAIL$Q_INPTRAN[DSC$W_LENGTH] = .PTR+2-.MAIL$Q_INPTRAN[DSC$A_POINTER];
	IF CH$FAIL(CH$FIND_SUB(.MAIL$Q_USERNAME[DSC$W_LENGTH],
				.MAIL$Q_USERNAME[DSC$A_POINTER],
				.MAIL$Q_SYSNODE2[DSC$W_LENGTH],
				.MAIL$Q_SYSNODE2[DSC$A_POINTER]))
	THEN STR$CONCAT(MAIL$Q_USERNAME,MAIL$Q_INPTRAN,MAIL$Q_USERNAME);
	END;
END;
!
! Also fill in MAIL$Q_FULLUSER for NOTIFY
!
STR$COPY_DX(MAIL$Q_FULLUSER,MAIL$Q_USERNAME);
!
! Get the addressee names and enter them in addressee list
!
WHILE 1 DO
	BEGIN
	IF_ERR(MAIL$GET_INPUT(DESC,LNK_C_IN_CKUSER);,	! Get addressee name
		RETURN TRUE);
	IF .DESC[DSC$W_LENGTH] EQL 0		! Check for 0-length name
	THEN BEGIN
	    SIGNAL(MAIL$_USERSPEC,1,DESC);	! Signal the error
	    EXITLOOP;
	    END;
	IF CH$RCHAR(.DESC[DSC$A_POINTER]) EQL 0 ! If null name,
	THEN					! Then all done
		EXITLOOP;
	!
	! If we detected a forwarding error, then send the
	! status back.  Otherwise add the addressee to the list
	!
	IF .FORWARD_ERROR
	    THEN BEGIN
		STATUS = MAIL$_FORWLOOP;
		SIGNAL(.STATUS,1,DESC);
		END
	    ELSE STATUS = MAIL$ADD_ADDR(DESC,MAIL$G_CNCT);! Add addressee to list
	IF .STATUS				! If success,
	THEN
		SIGNAL(.STATUS);		! Signal the success
	END;
!
! Send the end-of-users flag and the to-list to any remote nodes
!
!
! Get the To: and Subj: lists.  There is a bit of "behind the back" error
! handling going on here.  If the master mail job decides not to send,
! the logical link will be broken and one or the other of the following
! MAIL$GET_INPUT calls will fail, causing this job to exit.
!
IF_ERR(	MAIL$GET_INPUT(MAIL$Q_TO,LNK_C_IN_TO);,
	RETURN TRUE);
MAIL$NET_END_USERS(MAIL$G_CNCT);

IF_ERR(	MAIL$GET_INPUT(MAIL$Q_SUBJ,LNK_C_IN_SUBJ);,
	RETURN TRUE);
IF .MAIL$Q_SUBJ[DSC$W_LENGTH] NEQ 0
THEN IF CH$FAIL(CH$FIND_NOT_CH(.MAIL$Q_SUBJ[DSC$W_LENGTH],
			.MAIL$Q_SUBJ[DSC$A_POINTER],%C' '))
    THEN STR$FREE1_DX(MAIL$Q_SUBJ);
!
! Create a temporary file to store the message text
!
$FAB_INIT(FAB=TMP_FAB,
	NAM=TMP_NAM,
	DNM='MAIL.TXT',
	DEQ=3,
	CTX=MAIL$_OPENOUT,
	RAT = CR,
	RFM = VAR,
	FOP = (TMD),
	FAC = (GET,PUT,BRO));

IF .MAIL$G_CNCT[CNCT_V_BLKMODE]		!Did sender say block mode?
THEN BEGIN
    TMP_FAB[FAB$B_RAT] = .MAIL$G_CNCT[CNCT_B_FILRAT];	!Get record attributes
    TMP_FAB[FAB$B_RFM] = .MAIL$G_CNCT[CNCT_B_FILRFM];	! and format
    END;

$NAM_INIT(NAM=TMP_NAM,
	RSA=TMP_ESNAM_BUF,
	RSS=NAM$C_MAXRSS,
	ESA=TMP_ESNAM_BUF,
	ESS=NAM$C_MAXRSS);

MAIL$G_CNCT[CNCT_L_FILERR] = 1;
IF_ERR( $CREATE(FAB=TMP_FAB);,
	MAIL$G_CNCT[CNCT_L_FILERR] = .TMP_FAB[FAB$L_CTX];
	MAIL$G_CNCT[CNCT_L_FILESTS] = .TMP_FAB[FAB$L_STS];
	MAIL$G_CNCT[CNCT_L_FILESTV] = .TMP_FAB[FAB$L_STV]);

$RAB_INIT(RAB=TMP_RAB,
	FAB=TMP_FAB,
	CTX=MAIL$_OPENOUT,
	UBF=TMP_BUFF,
	USZ=MAIL$K_INBUFFSZ);

IF .MAIL$G_CNCT[CNCT_V_BLKMODE]		!If block mode, set bio in rab
    THEN TMP_RAB[RAB$V_BIO] = TRUE;

IF .MAIL$G_CNCT[CNCT_L_FILERR]
    THEN IF_ERR($CONNECT(RAB=TMP_RAB);,
	MAIL$G_CNCT[CNCT_L_FILERR] = .TMP_RAB[RAB$L_CTX];
	MAIL$G_CNCT[CNCT_L_FILESTS] = .TMP_RAB[RAB$L_STS];
	MAIL$G_CNCT[CNCT_L_FILESTV] = .TMP_RAB[RAB$L_STV]);

TMP_RAB[RAB$L_CTX] = MAIL$_WRITEERR;
!
! Get the message text and store in the temporary file
!
MAIL$G_CNCT[CNCT_L_NRECS] = 0;
IF NOT .MAIL$GL_FLAGS[MAIF_V_ALTP]
THEN BEGIN
    !
    ! Shrink working set while waiting for the first record.  Usually
    ! this takes a long time (while the person at the other end enters
    ! the message).
    !
    PURGE_VEC[0] = 0;
    PURGE_VEC[1] = %X'7FFFFFFF';
    $PURGWS(INADR=PURGE_VEC);
    STATUS = MAIL$GET_INPUT(DESC);			! Get first record
    UNTIL ((.DESC[DSC$W_LENGTH] EQL 1) AND		! Check for terminator
      (CH$RCHAR(.DESC[DSC$A_POINTER]) EQL 0))		! record
    OR NOT .STATUS
    DO BEGIN
	TMP_RAB[RAB$W_RSZ] = .DESC[DSC$W_LENGTH];
	TMP_RAB[RAB$L_RBF] = .DESC[DSC$A_POINTER];
	IF .MAIL$G_CNCT[CNCT_L_FILERR]
	    THEN IF NOT (IF .TMP_RAB[RAB$V_BIO]	!Use $write if block io
				THEN $WRITE(RAB=TMP_RAB)
				ELSE $PUT(RAB=TMP_RAB))! Put record in file
		THEN BEGIN
		    MAIL$G_CNCT[CNCT_L_FILERR] = .TMP_RAB[RAB$L_CTX];
		    MAIL$G_CNCT[CNCT_L_FILESTS] = .TMP_RAB[RAB$L_STS];
		    MAIL$G_CNCT[CNCT_L_FILESTV] = .TMP_RAB[RAB$L_STV];
		    END
		ELSE IF NOT .TMP_RAB[RAB$V_BIO]
		    THEN MAIL$G_CNCT[CNCT_L_NRECS] = .MAIL$G_CNCT[CNCT_L_NRECS] + 1;

	STATUS = MAIL$GET_INPUT(DESC);			! Get next record
	END;
    END
ELSE STATUS = MAIL$READ_FOREIGN_FILE(TMP_RAB);
TMP_RAB[RAB$L_CTX] = MAIL$_READERR;		!Now we read
!
! If success, send the message. Errors writing the temp file will be
! reported once per addressee
!
IF .STATUS
    THEN MAIL$SEND_ADDR(MAIL$G_CNCT)
    ELSE SIGNAL(.STATUS);

IF NOT .MAIL$GL_FLAGS[MAIF_V_SERVERLOOP]
    THEN EXITLOOP;

END;					!Looping until master disconnects
RETURN TRUE
END;

ROUTINE INTJOB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Get the sender's username and default directory spec, check for
!	new mail, get commands, parse them and dispatch to the command
!	action routines.
!
! INPUTS:
!
!	MAIL$Q_INPTRAN = SYS$INPUT logical name translation descriptor.
!	INPCHAR_DESC = SYS$INPUT device characteristics buffer descriptor
!
! OUTPUTS:
!
!	Commands parsed and executed.
!--
BEGIN

ROUTINE SWALLOW_SIGNALS(SIGARG,MECHARG) =
BEGIN

MAP
    SIGARG : REF $BBLOCK;

BIND
    SIGNAME = SIGARG[CHF$L_SIG_NAME] : $BBLOCK;

RETURN (IF .SIGNAME			!If success, then resignal to print
	THEN SS$_RESIGNAL		! otherwise, ignore error signals
	ELSE SS$_CONTINUE)

END;
ROUTINE NOTICE_SIGNAL (SIGARG,MECHARG,ENBL) =
BEGIN
MAP
    SIGARG : REF $BBLOCK,
    ENBL : REF VECTOR[,LONG];

BIND
    SIGNAME = SIGARG[CHF$L_SIG_NAME] : $BBLOCK,
    RETSTS = ENBL[1] : REF VECTOR[,LONG];

IF .SIGNAME[STS$V_FAC_NO] EQL 3
    THEN RETSTS[0] = 1;
RETURN SS$_RESIGNAL
END;
BUILTIN
    FP;

LOCAL
	NEWCOUNT,
	NOERASE_FLAG,
	ROWS,
	COLS,
	BLI_HANDLER_ADDR,
	TRNLNMLST : $ITMLST_DECL(ITEMS=1),
	PARSE_SIGNALLED : VOLATILE,
	NULLDESC : VECTOR[2,LONG],
	STATUS;

ENABLE NOTICE_SIGNAL(PARSE_SIGNALLED);
BLI_HANDLER_ADDR = ..FP;
.FP = 0;
NULLDESC[0] = 0;
NULLDESC[1] = NULLDESC[0];
!
! Parse any command qualifiers specified in the DCL command line
! (currently only one is /EDIT).  This is not done unless invoked
! with a "real" DCL command (ie. not RUN MAIL, MCR MAIL, or foreign command)
! IF /EDIT with no values, default to /EDIT=(SEND,REPLY)
!
IF NOT .CLI_SIGNALLED
    AND CLI$PRESENT(SD_EDIT)
THEN BEGIN
	WHILE CLI$GET_VALUE(SD_EDIT,DYN_DESC)
	    DO IF NOT (STATUS = CALL_TPARSE(DYN_DESC,
				EDITQUAL_STATE,EDITQUAL_KEY))
		THEN SIGNAL_STOP(.STATUS);
	IF .CLI_EDITQUAL EQL 0
	    THEN CLI_EDITQUAL = 1^F_SEND_EDIT OR 1^F_REPLY_EDIT;
	CLI_EXTRACT = CLI$PRESENT(SD_EXTRACT);
	END;

!
! Translate logical name MAIL$EDIT to see if there is a specific edit
! command file to be used.  If not, callable EDT will be used
!
$ITMLST_INIT(ITMLST=TRNLNMLST,
	(ITMCOD=LNM$_STRING,BUFADR=.MAIL$Q_EDITNAM_DESC[1],
		BUFSIZ=.MAIL$Q_EDITNAM_DESC[0],
		RETLEN=MAIL$Q_EDITNAM_DESC));

MAIL$GL_FLAGS[MAIF_V_USEREDIT] = (STATUS = $TRNLNM(ATTR=%REF(LNM$M_CASE_BLIND),
				TABNAM=SD_LNM$FILE_DEV,
				LOGNAM=$DESCRIPTOR('MAIL$EDIT'),
				ITMLST=TRNLNMLST)) EQL SS$_NORMAL;

!
!  If first character is a @ strip it off
!
IF  .MAIL$GL_FLAGS[MAIF_V_USEREDIT]
THEN 
    IF CH$EQL(1,CH$PTR(NULL_CHAR),1,CH$PTR(.MAIL$Q_EDITNAM_DESC[1])) THEN
    BEGIN
        MAIL$Q_EDITNAM_DESC[0] = .MAIL$Q_EDITNAM_DESC[0] - 1;
        MAIL$Q_EDITNAM_DESC[1] = .MAIL$Q_EDITNAM_DESC[1] + 1;
    END;

IF (NOT .MAIL$GL_FLAGS[MAIF_V_USEREDIT]) OR (.MAIL$Q_EDITNAM_DESC[0] EQLU 0)
THEN BEGIN
    CH$MOVE(.CALLABLE_EDT[0],CALLABLE_EDT[1],.MAIL$Q_EDITNAM_DESC[1]);
    MAIL$Q_EDITNAM_DESC[0] = .CALLABLE_EDT[0];
    END;

MAIL$UPCASE(MAIL$Q_EDITNAM_DESC);		! Make upper case for compare
MAIL$GL_FLAGS[MAIF_V_CALEDT] = CH$EQL(.CALLABLE_EDT[0],
			.MAIL$Q_EDITNAM_DESC[1],
			.CALLABLE_EDT[0],CALLABLE_EDT[1],0);
IF .MAIL$GL_FLAGS[MAIF_V_CALEDT]
THEN BEGIN
    LOCAL
	DESC : VECTOR[2,LONG];

    MAP
	SD_TPU : VECTOR[,LONG],
	SD_EDT : VECTOR[,LONG];

    DESC[0] = .MAIL$Q_EDITNAM_DESC[0] - .CALLABLE_EDT[0];
    DESC[1] = .MAIL$Q_EDITNAM_DESC[1] + .CALLABLE_EDT[0];
    IF .DESC[0] EQL 0
    THEN BEGIN
	DESC[0] = .SD_EDT[0];
	DESC[1] = .SD_EDT[1];
	END;
    !
    ! Check for 'EDT'
    !
    IF CH$EQL(.SD_EDT[0],.SD_EDT[1],.DESC[0],.DESC[1])
	THEN MAIL$GL_FLAGS[MAIF_V_EDTEDT] = 1;
    IF CH$EQL(.SD_TPU[0],.SD_TPU[1],.DESC[0],.DESC[1])
	THEN MAIL$GL_FLAGS[MAIF_V_EDTXYZ] = 1;
    STR$COPY_DX(MAIL$Q_CALEDTNAM,DESC);
    END;
!
! Create the virual display without erasing screen
!
NOERASE_FLAG=1;
COLS=0;
IF .MAIL$GL_FLAGS[MAIF_V_SCOPE] THEN
IF_ERR(SMG$CREATE_PASTEBOARD(MAIL$L_SMG_DISPLAY,$DESCRIPTOR('SYS$OUTPUT'),
                                                 ROWS,COLS,NOERASE_FLAG);,
						 RETURN .STATUS);
!
! Create the virtual keyboard and key table
!
IF_ERR(SMG$CREATE_VIRTUAL_KEYBOARD(MAIL$L_SMG_KEYBOARD,SYSIN_DESC);,
	RETURN SIGNAL(.STATUS));
IF_ERR(SMG$CREATE_KEY_TABLE(MAIL$L_SMG_KEYTABLE);,
	RETURN SIGNAL(.STATUS));
!
! Get user's default device and directory names and concatenate them together
!
IF_ERR(MAIL$GET_DEVDIR(MAIL$Q_USERNAME,MAIL$Q_USERDEF);,
		RETURN .STATUS);
!
! MAIL$GET_DEVDIR reads the uaf record
!
MAIL$L_MYUIC = .MAIL$T_UAF_BUFF[UAF$L_UIC];		! Get my UIC
STR$CONCAT(MAIL$Q_MAILDEF,MAIL$Q_USERDEF,MAIL$Q_MAIL_MAI);
MAIL$GL_FLAGS[MAIF_V_CAPTIVE] = .MAIL$T_UAF_BUFF[UAF$V_CAPTIVE];
!
! Check for new mail
!
IF NOT .MAIL$GL_FLAGS[MAIF_V_BATCH]			!Unless in BATCH mode
THEN BEGIN
    .FP = SWALLOW_SIGNALS;
    IF MAIL$GET_NEWMAIL(MAIL$Q_USERNAME,NEWCOUNT)
		AND .NEWCOUNT NEQ 0
		THEN (MAIL$PUT_OUTPUT(NULLDESC);
			MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_YOUHAVENEW),
					.NEWCOUNT));
    .FP = 0;
    !
    ! Delete any old MAIL.TMP files
    !
    MAIL$DEL_TMPF();
    END;
!
! If input is from terminal, assign a channel to it to enable CTRL/C AST's
!
IF .MAIL$GL_FLAGS[MAIF_V_ITERM]
THEN BEGIN
    $ASSIGN(CHAN=MAIL$W_TTCHAN,DEVNAM=MAIL$Q_INPTRAN);
    DEFINE_DEFAULT_KEYPAD();
    LOAD_KEY_DEFS();
    END;
!
! Get commands and parse them
!
DO	BEGIN
	IF .MAIL$GL_FLAGS[MAIF_V_ITERM]
	    THEN MAIL$PUT_OUTPUT(NULLDESC);
	IF_ERR( MAIL$GET_INPUT(COMMAND_DESC,	! Get the command
				DESCRIPTOR(%CHAR(LF),'MAIL> '));,
		IF .STATUS NEQ RMS$_EOF
		    AND .STATUS NEQ SMG$_EOF
		    THEN SIGNAL(.STATUS);
		EXITLOOP);
	STR$TRIM(COMMAND_DESC,COMMAND_DESC);
	MAIL$UPCASE_Q(COMMAND_DESC);			! Upcase the command
	!
	! Check string to see if it's a number.  If so, prefix with 'READ'
	!
	IF CALL_TPARSE(COMMAND_DESC,DECNUM_STATE,DECNUM_KEY)
	    THEN STR$CONCAT(COMMAND_DESC,
			$DESCRIPTOR('READ '),COMMAND_DESC);
	FILE_DESC[DSC$W_LENGTH] = 0;			! Init file name desc
	CLIFLAGS = 0;					! Init qualifier flags
	!
	! If length is 0, then assume CONTINUE.  Else parse command, and if
	! success, dispatch to process the command
	!
	MAIL$ENABLE_CTRLC();
	IF .COMMAND_DESC[DSC$W_LENGTH] EQL 0
	    THEN MAIL$CMD_CONTINUE()
	    ELSE BEGIN
!		.FP = .BLI_HANDLER_ADDR;
		PARSE_SIGNALLED = 0;
		IF (STATUS = CLI$DCL_PARSE(COMMAND_DESC,
			MAIL$COMMAND_TABLE,MAIL$GET_INPUT))
		    THEN STATUS = CLI$DISPATCH();
!		.FP = 0;
!		IF NOT .STATUS
!		    AND NOT .PARSE_SIGNALLED
!		    THEN SIGNAL(.STATUS);	!Signal all errors
		END;
	MAIL$G_CNCT[CNCT_B_FILRAT] = FAB$M_CR;
	MAIL$G_CNCT[CNCT_B_FILRFM] = FAB$C_VAR;
	MAIL$DELETELINK(MAIL$G_CNCT[CNCT_Q_LNKLST]);
	MAIL$DISABLE_CTRLC();
	MAIL$GL_FLAGS[MAIF_V_ATTACHMENT] = 0;
	END
UNTIL .CLIFLAGS[EXIT_FLAG] OR .CLIFLAGS[QUIT_FLAG];
IF NOT .CLIFLAGS[QUIT_FLAG]				! If not QUIT command,
THEN
	MAIL$CLOSE_FILE();				! Close any open file
$CLOSE(FAB = TMP_FAB);					! Close open input file
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$UP_PRIV (PRIVMASK1,PRIVMASK2) :NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Ensure privs specified by privmask are enabled
!
!--
BEGIN
ENHANCED_PRIVS[0] = (.PRIVMASK1 AND .MAIL$Q_PROCPRIV<0,32,0>)
				XOR .PRIVMASK1;
ENHANCED_PRIVS[1] = (.PRIVMASK2 AND .MAIL$Q_PROCPRIV<4,32,0>)
				XOR .PRIVMASK2;
IF ((.ENHANCED_PRIVS[0] NEQ 0)
    OR (.ENHANCED_PRIVS[1] NEQ 0))
    THEN $SETPRV(ENBFLG=1,PRVADR=ENHANCED_PRIVS);
RETURN;
END;

GLOBAL ROUTINE MAIL$DOWN_PRIV : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Disable privileges enabled by MAIL$UP_PRIV
!
!--
BEGIN

IF ((.ENHANCED_PRIVS[0] NEQ 0)
    OR (.ENHANCED_PRIVS[1] NEQ 0))
    THEN $SETPRV(ENBFLG=0,PRVADR=ENHANCED_PRIVS);
ENHANCED_PRIVS[0] = ENHANCED_PRIVS[0] = 0;
RETURN;
END;

GLOBAL ROUTINE MAIL$FORW_PRIV_CHECK =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks that the current process has SYSNAM
!	privilege, so that it can do a SET/SHOW FORWARD on another name.
!
!--
IF .MAIL$Q_PROCPRIV[PRV$V_SYSNAM]
    THEN RETURN TRUE
    ELSE BEGIN
	SIGNAL((SS$_NOSYSNAM-STS$K_SEVERE+STS$K_ERROR) OR MAIL$V_FACILITY);
	RETURN STS$K_ERROR
	END;
END;

GLOBAL ROUTINE MAIL$CMD_DEFINE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the DEFINE key command
!
BEGIN

IF_ERR(SMG$DEFINE_KEY(MAIL$L_SMG_KEYTABLE,COMMAND_DESC);,
	SIGNAL(MAIL$_PARSEFAIL,1,COMMAND_DESC,.STATUS));
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$GET_CLUNODES =
!
! Translate MAIL$SYSTEM_FLAGS.  If enabled, and in a cluster, then
! make a concatenated list of cluster nodes to avoid setting up decnet
! links.  nodes will be separated by "/".
!
BEGIN

LOCAL
    CSIDADR,
    SYITMLST : $ITMLST_DECL(ITEMS=2),
    MEMBER_FLAG : VOLATILE,
    NDESC : VECTOR[2,LONG];

IF .MAIL$GL_SYSFLAGS[SYSF_V_CLU_MAIL]
THEN BEGIN
    $ITMLST_INIT(ITMLST=SYITMLST,
	(ITMCOD=SYI$_CLUSTER_MEMBER,BUFADR=MEMBER_FLAG));

    CSIDADR = 0;
    $GETSYIW(EFN=1,CSIDADR=CSIDADR,ITMLST=SYITMLST);
    IF .MEMBER_FLAG
    THEN BEGIN
	$ITMLST_INIT(ITMLST=SYITMLST,
		(ITMCOD=SYI$_NODENAME,
		BUFADR=.MAIL$GL_BIGBUFFER,BUFSIZ=64,RETLEN=NDESC));

	STR$FREE1_DX(MAIL$Q_CLUNODES);
	NDESC[0] = 0;
	NDESC[1] = .MAIL$GL_BIGBUFFER;
	CSIDADR = -1;
	WHILE $GETSYIW(EFN=1,CSIDADR=CSIDADR,ITMLST=SYITMLST)
	    DO STR$CONCAT(MAIL$Q_CLUNODES,MAIL$Q_CLUNODES,
				SLASH_DESC,NDESC);
	END;
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CHK_CLUNODES(NODE_DESC) =
!
! Check if NODE_DESC is one of the nodes in this cluster,
! if we are in a cluster.
!
BEGIN
MAP
    NODE_DESC : REF $BBLOCK;

OWN
    TDESC : DYN_DESC_DECL;

LOCAL
    STATUS;

STATUS = FALSE;
IF .MAIL$Q_CLUNODES[DSC$W_LENGTH] NEQ 0
THEN BEGIN
    STR$CONCAT(TDESC,SLASH_DESC,.NODE_DESC);
    STATUS = NOT CH$FAIL(CH$FIND_SUB(.MAIL$Q_CLUNODES[DSC$W_LENGTH],
					.MAIL$Q_CLUNODES[DSC$A_POINTER],
					.TDESC[DSC$W_LENGTH],
					.TDESC[DSC$A_POINTER]));
    END;

RETURN .STATUS
END;

GLOBAL ROUTINE MAIL$CMD_FORWARD =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the FORWARD command action routine and is called to send
!	a copy of the current message to another user or users.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	A copy of the current message is sent to the specified user(s).
!--
BEGIN
LOCAL
	EDIFAB : $FAB_DECL,
	EDIRAB : $RAB_DECL,
	NAMBUF : $BBLOCK[NAM$C_MAXRSS],
	EDINAM : $NAM_DECL,
	OUTDESC : VECTOR[2,LONG],
	MOREFLAG,
	USERAB : REF $BBLOCK,
	USEFAB : REF $BBLOCK,
	USENAM : REF $BBLOCK,
	STATUS;					! Routine status
!
! Rewind current message
!
IF_ERR( (IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	    THEN MAIL$REWIND_I_MSG()
	    ELSE MAIL$REWIND_MSG());,		! Rewind current message
	SIGNAL (.STATUS);,			! If failure, signal it
	RETURN TRUE);			! and quit

$XABPRO_INIT(XAB=TMP_XAB);
TMP_XAB[XAB$W_PRO] = TMP_PRO;
PARSE_EDIT_QUAL(.CLI_EDITQUAL[F_FORW_EDIT]);
IF .CLIFLAGS[EDIT_FLAG]
THEN BEGIN
    $FAB_INIT(FAB=EDIFAB,
		FNS=.TMPFILE1_DESC[DSC$W_LENGTH],
		FNA=.TMPFILE1_DESC[DSC$A_POINTER],
		RAT=CR,
		RFM=VAR,
		DEQ=3,
		CTX=MAIL$_OPENOUT,
		XAB=TMP_XAB,
		FAC=PUT,
		FOP=SQO,
		NAM=EDINAM);

    $NAM_INIT(NAM=EDINAM,
		RSS=NAM$C_MAXRSS,
		RSA=NAMBUF,
		ESS=NAM$C_MAXRSS,
		ESA=NAMBUF);

    $RAB_INIT(RAB=EDIRAB,
	FAB=EDIFAB,
	CTX=MAIL$_OPENOUT,
	UBF=TMP_BUFF,
	USZ=MAIL$K_INBUFFSZ);

    USERAB = EDIRAB;
    USEFAB = EDIFAB;
    USENAM = EDINAM;
    END
ELSE BEGIN
    !
    ! Create a temporary file to store the message
    !
    $CLOSE(FAB=TMP_FAB);				! Close any other file
    $FAB_INIT(FAB=TMP_FAB,
	DEQ=3,
	NAM=TMP_NAM,
	FNS = .TMPFILE_DESC[DSC$W_LENGTH],
	FNA = .TMPFILE_DESC[DSC$A_POINTER],
	CTX = MAIL$_OPENOUT,
	XAB = TMP_XAB,
	RAT = CR,
	RFM = VAR,
	FOP = (TMD,SQO),
	FAC = (GET,PUT,BRO));

    $NAM_INIT(NAM=TMP_NAM,
	RSS=NAM$C_MAXRSS,
	RSA=TMP_ESNAM_BUF,
	ESA=TMP_ESNAM_BUF,
	ESS=NAM$C_MAXRSS);

    $RAB_INIT(RAB=TMP_RAB,
	FAB=TMP_FAB,
	CTX=MAIL$_OPENOUT,
	UBF=TMP_BUFF,
	USZ=MAIL$K_INBUFFSZ);

    USEFAB = TMP_FAB;
    USERAB = TMP_RAB;
    USENAM = TMP_NAM;
    END;

IF_ERR( $CREATE(FAB = .USEFAB,ERR=UTIL$REPORT_IO_ERROR);,! Create a temp file
	RETURN TRUE);
IF_ERR($CONNECT(RAB = .USERAB,ERR=UTIL$REPORT_IO_ERROR);,! Connect
	EDIFAB[FAB$V_DLT] = 1;		!Set delete if FOR/EDIT
	$CLOSE(FAB=.USEFAB);
	RETURN TRUE);
USERAB[RAB$L_CTX] = MAIL$_WRITEERR;
STATUS = MAIL$EXTRACT_MESSAGE(CLI$PRESENT(SD_HEADER),.USERAB);
IF NOT .STATUS
THEN	BEGIN
	USEFAB[FAB$V_DLT] = 1;
	$CLOSE(FAB = .USEFAB);
	RETURN TRUE;
	END;
!
! Get the name of the new addressee(s) and send the message.
!
MAIL$GET_CLUNODES();				! Get list of cluster nodes
MAIL$GET_INPUT(MAIL$Q_TO,MAIL$GETMSG(MAIL$_ISUB20));
IF .MAIL$Q_TO[DSC$W_LENGTH] EQL 0		! If nothing entered, quit
THEN (USEFAB[FAB$V_DLT] = 1; $CLOSE(FAB = .USEFAB); RETURN TRUE);
MAIL$UPCASE_Q(MAIL$Q_TO);			! Upcase the addressee names
MAIL$INI_ADDR(MAIL$G_CNCT);			! Init addressee list
IF CHECK_SEND(MAIL$ADD_ADDR(MAIL$Q_TO,MAIL$G_CNCT))! Add addressee(s) to list
THEN	BEGIN
	MAIL$NET_END_USERS(MAIL$G_CNCT);
	IF MAIL$GET_INPUT(MAIL$Q_SUBJ,
		MAIL$GETMSG(MAIL$_ISUB30)) EQL RMS$_EOF! Get the subject
	    THEN (USEFAB[FAB$V_DLT] = 1; $CLOSE(FAB=.USEFAB); RETURN TRUE);
	IF .CLIFLAGS[EDIT_FLAG]
	THEN BEGIN
	    $CLOSE(FAB=.USEFAB);
	    GET_SEND_MSG(TMPFILE1_DESC);
	    USEFAB[FAB$V_DLT] = 1;
	    $OPEN(FAB=.USEFAB);
	    END
	ELSE MAIL$SEND_ADDR(MAIL$G_CNCT);
	END;
USEFAB[FAB$V_DLT] = 1;
$CLOSE(FAB = .USEFAB);				! Close the temp file
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$LOOKUP_FILE(FILE_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Opens the specified file to ensure it is present and readable.  OPENIN
!	error signalled if not
!
! INPUTS:
!
!	FILE_DESC is the address of a dynamic string of the file to open.  It
!	is updated to have the resultant name if the open is successful
!
!--
BEGIN

MAP
    FILE_DESC : REF $BBLOCK;

LOCAL
    IFAB : $FAB_DECL,
    INAM : $NAM_DECL,
    NAMRSS : $BBLOCK[NAM$C_MAXRSS],
    STATUS;

IF .FILE_DESC[DSC$W_LENGTH] EQL 0
    THEN RETURN TRUE;

$FAB_INIT(FAB=IFAB,
	NAM=INAM,
	FNS=.FILE_DESC[DSC$W_LENGTH],
	FNA=.FILE_DESC[DSC$A_POINTER],
	DNM='.TXT',
	CTX=MAIL$_OPENIN);

$NAM_INIT(NAM=INAM,
	RSS=NAM$C_MAXRSS,
	RSA=NAMRSS,
	ESS=NAM$C_MAXRSS,
	ESA=NAMRSS);

STATUS = $OPEN(FAB=IFAB,ERR=UTIL$REPORT_IO_ERROR);
IF .STATUS
THEN BEGIN
    MAIL$G_CNCT[CNCT_B_FILRAT] = .IFAB[FAB$B_RAT];
    MAIL$G_CNCT[CNCT_B_FILRFM] = .IFAB[FAB$B_RFM];
    END;
$CLOSE(FAB=IFAB);
STR$COPY_DX(.FILE_DESC,UTIL$GETFILENAME(IFAB));
RETURN .STATUS
END;

ROUTINE SEND_SELF_IF (PERM_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the sender's name to the end of the "to" list
!	if (.perm_flag and not /noself) or /self.
!
!--
BEGIN
LOCAL
    STATUS;

STATUS = CLI$PRESENT(SD_SELF);
IF .STATUS EQL CLI$_NEGATED
    OR .STATUS EQL CLI$_LOCNEG
    THEN RETURN .STATUS;

IF .STATUS
    OR .PERM_FLAG
THEN BEGIN
    IF .MAIL$Q_TO[DSC$W_LENGTH] NEQ 0
	THEN STR$APPEND(MAIL$Q_TO,COMMA_DESC);
    STR$APPEND(MAIL$Q_TO,MAIL$Q_USERNAME);
    END;
RETURN (.STATUS OR .PERM_FLAG)
END;

GLOBAL ROUTINE MAIL$CMD_REPLY =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the REPLY command action routine and is called
!	to send a message to the sender of the current message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	Message sent to sender of current message.
!--
BEGIN

LOCAL
    EXTRACT_FLAG,
    EXTFAB : $FAB_DECL,
    EXTRAB : $RAB_DECL,
    EXTNAM : $NAM_DECL,
    NAMBUF : $BBLOCK[NAM$C_MAXRSS],
    OUTDESC : VECTOR[2,LONG],
    MORE_FLAG,
    PUT_STATUS,
    SEND_STATUS : VOLATILE;

ROUTINE REPLY_HANDLER (SIGARG,MECHARG,ENBL) =
BEGIN
MAP
    SIGARG : REF $BBLOCK,
    ENBL : REF VECTOR[,LONG];

BIND
    RETSTS = ENBL[1] : REF VECTOR[,LONG];

RETSTS[0] = .SIGARG[CHF$L_SIG_NAME];
RETURN SS$_RESIGNAL
END;

ENABLE REPLY_HANDLER (SEND_STATUS);
SEND_STATUS = 1;
PUT_STATUS = PARSE_EDIT_QUAL(.CLI_EDITQUAL[F_REPLY_EDIT]);
CLIFLAGS[LAST_FLAG] = CLI$PRESENT(SD_LAST);
EXTRACT_FLAG = CLI$PRESENT(SD_EXTRACT);
IF .CLI_EXTRACT
    AND ((.EXTRACT_FLAG NEQ CLI$_NEGATED) AND (.EXTRACT_FLAG NEQ CLI$_LOCNEG))
    THEN EXTRACT_FLAG = TRUE;
!
! Disable /extract if explicit /noedit
!
IF .PUT_STATUS EQL CLI$_LOCNEG
    OR .PUT_STATUS EQL CLI$_NEGATED
    THEN EXTRACT_FLAG = FALSE;
IF CLI$GET_VALUE(SD_REPLF,COMMAND_DESC)
THEN BEGIN
    EXTRACT_FLAG = FALSE;
    IF_ERR(MAIL$LOOKUP_FILE(COMMAND_DESC);,
		RETURN TRUE);
    END;
!
! /EXTRACT implies /edit
!
IF .EXTRACT_FLAG
    THEN CLIFLAGS[EDIT_FLAG] = 1;			!Force editting
!
! Get the sender and subject of the current message.  Use the sender's name
! as the addressee of the new message.
!
MAIL$GET_CLUNODES();				!Get list of cluster nodes
IF_ERR(	(IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	    THEN MAIL$INFO_I_MSG(0,MAIL$Q_SUBJ,0,0,0,MAIL$Q_TO)
	    ELSE MAIL$INFO_MSG(MAIL$Q_TO,
			MAIL$Q_SUBJ));,
	SIGNAL(.STATUS); RETURN TRUE);
SEND_SELF_IF(.MAIL$L_USRSYSBUF[VMD_V_SELFREPLY]);
MAIL$INI_ADDR(MAIL$G_CNCT);
IF_ERR(	MAIL$ADD_ADDR(MAIL$Q_TO,MAIL$G_CNCT);,
	IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
	    THEN MAIL$REWIND_MSG();
	RETURN TRUE);
MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_MAIL10),MAIL$Q_TO);
MAIL$NET_END_USERS(MAIL$G_CNCT);
IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
    THEN RETURN SIGNAL(MAIL$_SENDABORT);
!
! If a subject was specified in the original message, add a "RE:" and use it
! as the subject of the new message.  Otherwise, just prompt for a subject.
!
IF .MAIL$Q_SUBJ[DSC$W_LENGTH] NEQ 0
THEN	BEGIN
	IF .(.MAIL$Q_SUBJ[DSC$A_POINTER]) NEQ 'RE: '   ! If not already "RE:"
	THEN	STR$CONCAT(MAIL$Q_SUBJ,
			   DESCRIPTOR('RE: '),
			   MAIL$Q_SUBJ);
	MAIL$FILTER_OUTPUT(MAIL$FAO_GETMSG(MAIL$_MAIL20,MAIL$Q_SUBJ));
	END
ELSE BEGIN
	IF MAIL$GET_INPUT(MAIL$Q_SUBJ,MAIL$GETMSG(MAIL$_ISUB30)) EQL RMS$_EOF
	    THEN RETURN TRUE;
	END;
IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
    THEN RETURN SIGNAL(MAIL$_SENDABORT);
!
! If /EXTRACT, extract the message out to a temporary file
!
IF .EXTRACT_FLAG
THEN BEGIN
    $FAB_INIT(FAB=EXTFAB,
		FNS=.TMPFILE1_DESC[DSC$W_LENGTH],
		FNA=.TMPFILE1_DESC[DSC$A_POINTER],
		RAT=CR,
		RFM=VAR,
		DEQ=3,
		CTX=MAIL$_OPENOUT,
		XAB=TMP_XAB,
		FAC=PUT,
		FOP=SQO,
		NAM=EXTNAM);

    $XABPRO_INIT(XAB=TMP_XAB);
    TMP_XAB[XAB$W_PRO] = TMP_PRO;
    $NAM_INIT(NAM=EXTNAM,
		RSS=NAM$C_MAXRSS,
		RSA=NAMBUF,
		ESS=NAM$C_MAXRSS,
		ESA=NAMBUF);

    $RAB_INIT(RAB=EXTRAB,
		FAB=EXTFAB,
		CTX=MAIL$_OPENOUT,
		UBF=TMP_BUFF,
		USZ=MAIL$K_INBUFFSZ);

    IF_ERR($CREATE(FAB=EXTFAB,ERR=UTIL$REPORT_IO_ERROR);,
		RETURN TRUE);

    IF_ERR($CONNECT(RAB=EXTRAB,ERR=UTIL$REPORT_IO_ERROR);,
		EXTFAB[FAB$V_DLT] = 1;
		$CLOSE(FAB=EXTFAB);
		RETURN TRUE);
    !
    ! Copy the message text to the temporary file
    !
    EXTRAB[RAB$L_CTX] = MAIL$_WRITEERR;
    PUT_STATUS = MAIL$EXTRACT_MESSAGE(1,EXTRAB);
    IF NOT .PUT_STATUS
    THEN BEGIN
	EXTFAB[FAB$V_DLT] = 1;
	$CLOSE(FAB=EXTFAB);
	RETURN TRUE;
	END;
    $CLOSE(FAB=EXTFAB);
    STR$COPY_DX(COMMAND_DESC,TMPFILE1_DESC);
    END;
!
! Get the text of the new message and send it
!
GET_SEND_MSG(COMMAND_DESC);
!
! If /EXTRACT, delete the temp file
!
IF .EXTRACT_FLAG
THEN BEGIN
    EXTFAB[FAB$V_DLT] = 1;
    EXTFAB[FAB$V_NAM] = 1;
    EXTFAB[FAB$L_CTX] = MAIL$_OPENIN;
    $OPEN(FAB=EXTFAB,ERR=UTIL$REPORT_IO_ERROR);
    EXTFAB[FAB$L_CTX] = MAIL$_CLOSEIN;
    $CLOSE(FAB=EXTFAB,ERR=UTIL$REPORT_IO_ERROR);
    END;
!
! If successfully sent, flag message as replied
!
IF .SEND_STATUS
    AND .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    BIND
	MMH = MAIL$L_CURMSG[MMB_T_HDREC] + $BYTEOFFSET(MFR_T_DATA) : $BBLOCK;

    MMH[MMH_V_REPLIED] = TRUE;
    MAIL$UPDATE_I_MSG();
    END;
RETURN TRUE
END;


GLOBAL ROUTINE MAIL$CMD_SEND =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the SEND command action routine and is called to
!	send a message to a user or users.
!
! INPUTS:
!
!
! OUTPUTS:
!
!	Specified file, or SYS$INPUT if none specified, is sent the
!	the addressee(s).
!--
BEGIN

PARSE_EDIT_QUAL(.CLI_EDITQUAL[F_SEND_EDIT]);
CLIFLAGS[LAST_FLAG] = CLI$PRESENT(SD_LAST);
CLI$GET_VALUE(SD_SEND1,COMMAND_DESC);
IF_ERR(MAIL$LOOKUP_FILE(COMMAND_DESC);,
	RETURN TRUE);
MAIL$GL_FLAGS[MAIF_V_ATTACHMENT] = CLI$PRESENT(SD_ATTACHMENT);
IF .MAIL$GL_FLAGS[MAIF_V_ATTACHMENT]
THEN BEGIN
    STR$COPY_DX(MAIL$Q_ATTDESC,COMMAND_DESC);
    STR$FREE1_DX(COMMAND_DESC);
    END;
!
! Get the name of the addressee(s) and add them to the addressee list
!
MAIL$GET_CLUNODES();				!Get list of cluster nodes
MAIL$GET_INPUT(MAIL$Q_TO,MAIL$GETMSG(MAIL$_ISUB20));
IF .MAIL$Q_TO[DSC$W_LENGTH] EQL 0		! If nothing entered, quit
    THEN  RETURN TRUE;
MAIL$UPCASE_Q(MAIL$Q_TO);
MAIL$INI_ADDR(MAIL$G_CNCT);
IF NOT CHECK_SEND(MAIL$ADD_ADDR(MAIL$Q_TO,MAIL$G_CNCT))
    THEN RETURN TRUE;
IF SEND_SELF_IF(.MAIL$L_USRSYSBUF[VMD_V_SELFSEND])
    THEN IF NOT CHECK_SEND(MAIL$ADD_ADDR(MAIL$Q_USERNAME,MAIL$G_CNCT))
    THEN RETURN TRUE;
MAIL$NET_END_USERS(MAIL$G_CNCT);
!
! Get the subject and text of the message and send it
!
IF NOT CLI$GET_VALUE(SD_SUBJECT,MAIL$Q_SUBJ)
    THEN IF NOT MAIL$GET_INPUT(MAIL$Q_SUBJ,MAIL$GETMSG(MAIL$_ISUB30))
	THEN RETURN TRUE;

GET_SEND_MSG(COMMAND_DESC);

RETURN TRUE
END;


ROUTINE GET_SEND_MSG(FILE_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to complete the sending of a message file.
!
! INPUTS:
!
!	FILE_DESC = Message file name descriptor.
!
!	EDIT_FLAG = 1 if message file is to be edited before sending.
!		  = 0 if message file is not to be edited before sending.
!	LAST_FLAG = 1 if last message sent is to be sent again.
!		  = 0 if new message is to be sent.
!
! OUTPUTS:
!
!	Message file is sent to all addressee(s) in addressee list.
!--
BEGIN
MAP
	FILE_DESC: REF BLOCK[,BYTE];			! File name descriptor
LOCAL
	STATUS;						! Routine status

!
! If the /LAST qualifier was specified and the last file is still open,
! send it.
!
IF .CLIFLAGS[LAST_FLAG] AND .TMP_FAB[FAB$W_IFI] NEQ 0	! If last file specified
THEN	BEGIN
	MAIL$SEND_ADDR(MAIL$G_CNCT);			!Send the previous file
	IF (IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
		THEN MAIL$REWIND_I_MSG()
		ELSE MAIL$REWIND_MSG())
	THEN
		MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_PRESRET),0);
	RETURN TRUE
	END;
!
! Close any previously sent file and, depending on whether /EDIT was
! specified, either call an editor or just prompt for the input message text.
!
$CLOSE(FAB=TMP_FAB);					! Close any other file
$FAB_INIT(FAB=TMP_FAB,
	DEQ=3,
	FNS=.TMPFILE_DESC[DSC$W_LENGTH],
	FNA=.TMPFILE_DESC[DSC$A_POINTER],
	DNM='.TXT',
	CTX=MAIL$_OPENOUT,
	XAB=TMP_XAB,
	NAM=TMP_NAM,
	FOP=(SQO,TMD),
	RAT=CR,
	RFM=VAR,
	FAC=(GET,PUT,BRO));

$XABPRO_INIT(XAB=TMP_XAB);
TMP_XAB[XAB$W_PRO] = TMP_PRO;

$NAM_INIT(NAM=TMP_NAM,
	RSA=TMP_ESNAM_BUF,
	RSS=NAM$C_MAXRSS,
	ESA=TMP_ESNAM_BUF,
	ESS=NAM$C_MAXRSS);

$RAB_INIT(RAB=TMP_RAB,
	FAB=TMP_FAB,
	CTX=MAIL$_OPENOUT,
	UBF=TMP_BUFF,
	USZ=MAIL$K_INBUFFSZ);

IF .CLIFLAGS[EDIT_FLAG]
THEN	BEGIN
	STATUS = MAIL$EDIT(.FILE_DESC,TMPFILE_DESC);	! Call the editor
	IF .STATUS
	THEN BEGIN
	    !
	    ! Ensure we have delete access to the file.
	    !
	    IF $OPEN(FAB=TMP_FAB,ERR=UTIL$REPORT_IO_ERROR)
	    THEN BEGIN
		TMP_XAB[XAB$W_PRO] = TMP_PRO;
		TMP_XAB[XAB$L_UIC] = 0;
		$CLOSE(FAB=TMP_FAB,ERR=UTIL$REPORT_IO_ERROR);
		TMP_FAB[FAB$V_NAM] = 1;
		END;
	    END;
	TMP_FAB[FAB$V_DLT] = 1; 			! Set delete on close
	IF .STATUS
	    THEN STATUS = $OPEN(FAB = TMP_FAB,ERR=UTIL$REPORT_IO_ERROR);
	IF .STATUS
	    THEN STATUS = $CONNECT(RAB = TMP_RAB,ERR=UTIL$REPORT_IO_ERROR);
	END
ELSE 
	IF .FILE_DESC[DSC$W_LENGTH] EQL 0		! If no file specified
	THEN	BEGIN
		STATUS = $CREATE(FAB = TMP_FAB,ERR=UTIL$REPORT_IO_ERROR);
		IF .STATUS
		    THEN STATUS = $CONNECT(RAB = TMP_RAB,ERR=UTIL$REPORT_IO_ERROR);
		IF .STATUS THEN STATUS = MAIL$ENTER(TMP_RAB);
		END
	ELSE	BEGIN
		TMP_FAB[FAB$B_FNS] = .FILE_DESC[DSC$W_LENGTH];
		TMP_FAB[FAB$L_FNA] = .FILE_DESC[DSC$A_POINTER];
		TMP_FAB[FAB$V_TMD] = 0;			! Not a temp file
		TMP_FAB[FAB$V_PUT] = 0;			! and no PUT's
		TMP_FAB[FAB$L_CTX] = MAIL$_OPENIN;
		TMP_RAB[RAB$L_CTX] = MAIL$_OPENIN;
		STATUS = $OPEN(FAB = TMP_FAB,ERR=UTIL$REPORT_IO_ERROR);
		IF .STATUS
		    THEN STATUS = $CONNECT(RAB = TMP_RAB,ERR=UTIL$REPORT_IO_ERROR);
		END;
!
! If message text successfully obtained, then send it.  Otherwise signal
! the error.
!
IF .STATUS
THEN
	MAIL$SEND_ADDR(MAIL$G_CNCT)
ELSE	
	IF .STATUS EQL MAIL$_SENDABORT
	THEN
		SIGNAL(MAIL$_SENDABORT);
!
! If user was previously reading a message, rewind it and display help message.
!
IF (IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	THEN MAIL$REWIND_I_MSG()
	ELSE MAIL$REWIND_MSG())
THEN
	MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_PRESRET),0);

RETURN TRUE
END;


ROUTINE CHECK_SEND(STATUS) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to check if the ADD_ADDR was completely 
!	successful and if it wasn't, the user is asked if mail should be sent 
!	to the users that were found.
!
! INPUTS:
!
!	STATUS = Status from MAIL$ADD_ADDR.
!
! OUTPUTS:
!
!	Return status = success if mail should be sent.
!		      = failure if mail should not be sent.
!--
BEGIN
MAP
	STATUS:	BLOCK[,BYTE];			! Completion status

RETURN (
IF .STATUS[STS$V_SEVERITY]			! If complete success, ok
THEN
	TRUE
ELSE BEGIN
	MAIL$DELEMPLINK(MAIL$G_CNCT[CNCT_Q_LNKLST]);	! Delete empty links
	IF (.STATUS[STS$V_SEVERITY] NEQ STS$K_WARNING)
	    OR (.MAIL$G_CNCT[CNCT_L_NADDRS] EQL 0)
	THEN
		STS$K_ERROR			! If not partial success, error
	ELSE MAIL$CONFIRM(DYN_DESC_2,		! Else, ask user what to do
			MAIL$GETMSG(MAIL$_WANTOSEND))
	END
    )
END;

ROUTINE EXIT_ROUTINE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when a $EXIT service is executed to clean
!	up.
!--
BEGIN
RETURN MAIL$DELETELINK(MAIL$G_CNCT[CNCT_Q_LNKLST])
END;

END
ELUDOM
