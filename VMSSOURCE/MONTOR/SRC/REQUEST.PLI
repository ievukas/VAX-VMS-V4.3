EXECUTE_REQUEST: Procedure	Returns(Fixed Binary(31))
				Options(Ident('V04-000'));

/*
/****************************************************************************
/*									    *
/*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
/*  ALL RIGHTS RESERVED.						    *
/* 									    *
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
/*  TRANSFERRED.							    *
/* 									    *
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
/*  CORPORATION.							    *
/* 									    *
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
/* 									    *
/*									    *
/****************************************************************************
/*/

/*
/*++
/* FACILITY:  MONITOR Utility 
/*
/* ABSTRACT:  EXECUTE_REQUEST Routine.
/*		
/*		 Called from MONMAIN routine to execute a single
/*		   MONITOR request.
/*
/*
/* ENVIRONMENT:
/*
/*		Unprivileged user mode,
/*		except for certain collection routines which
/*		run in EXEC or KERNEL mode to access system
/*		data bases.
/*
/* AUTHOR:  Thomas L. Cafarella, April, 1981
/*

/*
/* MODIFIED BY:
/*
/*	V03-026	TLC1091		Thomas L. Cafarella	08-Aug-1984	15:00
/*		Save summary buffer data for only those classes requested;
/*		exclude extra classes collected in support of SYSTEM class.
/*
/*	V03-025	TLC1090		Thomas L. Cafarella	02-Aug-1984	15:00
/*		Correct ACCVIOs in SYSTEM and PROCESSES classes.
/*
/*	V03-024	TLC1086		Thomas L. Cafarella	24-Jul-1984	14:00
/*		Make top summary work for SYSTEM class.
/*
/*	V03-023	TLC1085		Thomas L. Cafarella	22-Jul-1984	14:00
/*		Calculate scale values for Free and Modified List bar graphs.
/*
/*	V03-022	TLC1082		Thomas L. Cafarella	23-Jul-1984	11:00
/*		Always save data in summary buffers, even when only
/*			one collection.
/*
/*	V03-021	TLC1072		Thomas L. Cafarella	17-Apr-1984	11:00
/*		Add volume name to DISK display.
/*
/*	V03-020	TLC1068		Thomas L. Cafarella	13-Apr-1984	14:00
/*		Fix bug causing a garbage heading display.
/*
/*	V03-019	PRS1019		Paul R. Senn		11-Apr-1984	16:00
/*		Fix SYSTEM class /SUMMARY and change SYSTEM default interval.
/*
/*	V03-018	TLC1060		Thomas L. Cafarella	12-Mar-1984	11:00
/*		Make multi-file summary work for homogeneous classes.
/*
/*	V03-018	TLC1059		Thomas L. Cafarella	20-Mar-1984	11:00
/*		When re-recording, include input revision level
/*		in output file.
/*
/*	V03-018	TLC1057		Thomas L. Cafarella	22-Mar-1984	15:00
/*		Eliminate node name from heading for multi-file summary.
/*
/*	V03-018	TLC1056		Thomas L. Cafarella	22-Mar-1984	11:00
/*		Disable journaling classes and exclude class which is disabled.
/*
/*	V03-017	PRS1011		Paul R. Senn		29-Feb-1984	14:00
/*		add /FLUSH_INTERVAL qualifier
/*
/*	V03-016	TLC1052		Thomas L. Cafarella	17-Feb-1984	11:00
/*		Add multi-file summary capability.
/*
/*	V03-015	TLC1051		Thomas L. Cafarella	11-Jan-1984	11:00
/*		Add consecutive number to class header record.
/*
/*	V03-015	PRS1003		Paul R. Senn		9-Jan-1984	10:00
/*		Fix 1 bit parameter passing problem on call to DISP_TEMPLATE.
/*
/*	V03-015	PRS1002		Paul R. Senn		29-Dec-1983	16:00
/*		GLOBALDEF VALUE symbols must now be longwords; 
/*		Use %REPLACE rather than GLOBALDEF VALUE for any equated
/*		symbols which are not 4 bytes in length; 
/*
/*
/*	V03-015	PRS1001		Paul R. Senn		27-Dec-1983	16:00
/*		Make default interval = 6 for ALL classes Pseudo-class		
/*		live requests.
/*
/*	V03-015	PRS1000		Paul R. Senn		15-Dec-1983	16:00
/*		For cases where one display event may involve multiple
/*		screens of data (such as PROCESSES and homogeneous 
/*		classes), make the wait between screens = VIEWING_TIME,
/*		instead of a constant of 2 seconds.
/*
/*	V03-014	TLC1050		Thomas L. Cafarella	06-Dec-1983	11:00
/*		Change directory information in DLOCK class.
/*
/*	V03-013	TLC1047		Thomas L. Cafarella	09-Sep-1983	10:00
/*		De-establish CTRL/W handler to get back AST quota.
/*
/*	V03-012	SPC0007		Stephen P. Carney	24-Jun-1983	16:00
/*		Add execute command file handling in CTRLZ routine.
/*
/*	V03-011	TLC1042		Thomas L. Cafarella	19-Jun-1983	15:00
/*		Add /ITEM qualifier for homogeneous classes.
/*
/*	V03-011	TLC1039		Thomas L. Cafarella	15-Jun-1983	15:00
/*		Add DECnet node name to heading.
/*
/*	V03-011	TLC1037		Thomas L. Cafarella	14-Jun-1983	19:00
/*		Perform FLUSH after writing record (instead of before).
/*
/*	V03-011	SPC0005		Stephen P. Carney	10-Jun-1983	15:00
/*		Make the playback/record file read-shareable
/*
/*	V03-010	TLC1035		Thomas L. Cafarella	06-Jun-1983	15:00
/*		Add homogeneous class type and DISK class.
/*
/*	V03-010	TLC1033		Thomas L. Cafarella	30-May-1983	16:00
/*		Don't clear screen for CTRL/Z.
/*
/*	V03-009	TLC1032		Thomas L. Cafarella	27-May-1983	15:00
/*		Modify file structure level ID for LOCK class change.
/*
/*	V03-008	SPC0002		Stephen P. Carney	22-Apr-1983	14:00
/*		Modify file structure level ID for new ACPCACHE class.
/*
/*	V03-007	TLC1028		Thomas L. Cafarella	14-Apr-1983	16:00
/*		Add interactive user interface.
/*
/*	V03-007	TLC1027		Thomas L. Cafarella	14-Apr-1983	16:00
/*		Enhance file compatibility features.
/*
/*	V03-006	TLC1022		Thomas L. Cafarella	12-Jul-1982	16:00
/*		Change recording file structure level since new classes
/*		(JOURNALING and RECOVERY) are now defined.
/*
/*	V03-005	TLC1016		Thomas L. Cafarella	02-Apr-1982	16:00
/*		Replace references to EXE$GQ_SYSTIME with $GETTIM calls.
/*
/*	V03-005	TLC1014		Thomas L. Cafarella	01-Apr-1982	13:00
/*		Correct attached processor time reporting for MODES class.
/*
/*	V03-005	TLC1013		Thomas L. Cafarella	31-Mar-1982	09:00
/*		Do not clear TOP box until it fills with data.
/*
/*	V03-005	TLC1012		Thomas L. Cafarella	30-Mar-1982	13:00
/*		Display user's comment string on screen line 5.
/*
/*	V03-005	TLC1011		Thomas L. Cafarella	29-Mar-1982	20:00
/*		Move system service names for SSERROR msg to static storage.
/*
/*	V03-004	TLC1009		Thomas L. Cafarella	29-Mar-1982	01:00
/*		Get current time when other times are converted.
/*
/*	V03-004	TLC1008		Thomas L. Cafarella	28-Mar-1982	21:00
/*		Fix to display first and last PROCESSES records on playback.
/*
/*	V03-004	TLC1006		Thomas L. Cafarella	28-Mar-1982	13:00
/*		Add checks to skip data display on CTRL-C during template.
/*
/*	V03-003	TLC1003		Thomas L. Cafarella	23-Mar-1982	13:00
/*		Fix up module headers.
/*
/*	V03-002	TLC1002		Thomas L. Cafarella	20-Mar-1982	13:00
/*		Change PROCESSES display from scroll-style to page-style to
/*			make it terminal-independent.
/*
/*		Move collection event flag to REQUEST.PLI for consolidation.
/*
/*	V03-001	TLC1001		Thomas L. Cafarella	16-Mar-1982	13:00
/*		Add CTRL-W screen refresh support.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;				/* Monitor utility structure definitions */
%INCLUDE	$CHFDEF;			/* Condition handler facility definitions */
%INCLUDE	$STSDEF;			/* Status value definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		   SYSTEM SERVICE MACRO DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$DCLAST;			/* $DCLAST system service */
%INCLUDE	SYS$SETAST;			/* $SETAST system service */
%INCLUDE	SYS$CLREF;			/* $CLREF system service */
%INCLUDE	SYS$SETEF;			/* $SETEF system service */
%INCLUDE	SYS$READEF;			/* $READEF system service */
%INCLUDE	SYS$SETIMR;			/* $SETIMR system service */
%INCLUDE	SYS$CANTIM;			/* $CANTIM system service */
%INCLUDE	SYS$ASCTIM;			/* $ASCTIM system service */
%INCLUDE	SYS$WAITFR;			/* $WAITFR system service */
%INCLUDE	SYS$WFLOR;			/* $WFLOR system service */
%INCLUDE	SYS$PUTMSG;			/* $PUTMSG system service */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
ST_LEVEL_CUR	CHAR(8)		 GLOBALREF;		/* Current MONITOR recording file structure level */

Declare
MAX_CLASS_NO	FIXED BINARY(31) GLOBALREF VALUE,	/* Maximum defined class number */
CLASSTABLE	FIXED BINARY(31) GLOBALREF VALUE,	/* Addr of table of class names & numbers*/
VTWIDTH		FIXED BINARY(31) GLOBALREF VALUE,	/* Width of video terminal */
VTHEIGHT	FIXED BINARY(31) GLOBALREF VALUE,	/* Height of video terminal */
MAX_REC_SIZE	FIXED BINARY(31) GLOBALREF VALUE,	/* Max record size for PLAYBACK & RECORD files */
PROCS_CLSNO	FIXED BINARY(31) GLOBALREF VALUE,	/* PROCESSES class number */
STATES_CLSNO	FIXED BINARY(31) GLOBALREF VALUE,	/* STATES class number */
MODES_CLSNO	FIXED BINARY(31) GLOBALREF VALUE,	/* MODES class number */
SYSTEM_CLSNO	FIXED BINARY(31) GLOBALREF VALUE;	/* SYSTEM class number */

Declare
CDBPTR			POINTER GLOBALREF,		/* Pointer to CDB (Class Descriptor Block) */
C			POINTER DEFINED(CDBPTR),	/* Synonym for CDBPTR */
MRBPTR			POINTER GLOBALREF,		/* Pointer to MRB (Monitor Request Block) */
M			POINTER DEFINED(MRBPTR),	/* Synonym for MRBPTR */
MCAPTR			POINTER GLOBALREF,		/* Pointer to MCA (Monitor Communication Area) */
MC			POINTER DEFINED(MCAPTR),	/* Synonym for MCAPTR */
SPTR			POINTER GLOBALREF;		/* Pointer to SYI (System Information Area) */

Declare
MFSPTR			POINTER GLOBALREF;		/* Pointer to Multi-File Summary Block (MFS) */

Declare
DISPLAYING		BIT(1) ALIGNED GLOBALREF;	/* YES=> display output is active */

Declare
CTRLCZ_CHAN		FIXED BINARY(31) GLOBALREF,	/* Channel number for CTRL-C and CTRL-Z */
CTRLW_CHAN		FIXED BINARY(31) GLOBALREF;	/* Channel number for CTRL-W */

Declare
EXE$GL_MP		POINTER GLOBALREF,		/* Pointer to multiprocessing data structures */
SGN$GW_MAXPRCCT		FIXED BINARY(15) GLOBALREF,	/* MAXPROCESSCNT SYSGEN parameter value */
PFN$GL_PHYPGCNT		FIXED BINARY(31) GLOBALREF,	/* Balance set memory size (in pages) */
MPW$GW_HILIM		FIXED BINARY(15) GLOBALREF;	/* MPW_HILIMIT SYSGEN parameter value */

Declare
SETIMR_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $SETIMR cstring */
DCLAST_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $DCLAST cstring */
SCHDWK_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $SCHDWK cstring */
READEF_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $READEF cstring */
CLREF_STR		FIXED BINARY(7)  GLOBALREF;	/* Count byte for $CLREF cstring */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL ROUTINE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),	/* MONITOR MACRO-32 routine to log synchronous errors */
SIGNAL_MON_ERR	ENTRY,						/* MONITOR MACRO-32 routine to signal MONITOR errors */
READ_INPUT	ENTRY (FIXED BINARY(31)),			/* MONITOR routine to read an input (playback) file record */
ESTAB_CTRLCZ	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to set up CTRL-C and CTRL-Z handlers */
ESTAB_CTRLW	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to set up CTRL-W handler */
DISPLAY_INIT	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to do display init */
SUMMARY_INIT	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to do summary init */
COLLECTION_EVENT ENTRY,						/* MONITOR routine to perform collection */
QUAD_LT_QUAD	ENTRY (BIT(64) ALIGNED, BIT(64) ALIGNED) 	/* MONITOR MACRO-32 unsigned quadword compare routine */
		RETURNS(BIT(1)),
QUAD_EQ_0	ENTRY (BIT(64) ALIGNED) RETURNS(BIT(1)), 	/* MONITOR MACRO-32 quadword compare to 0 routine */
CVT_TO_DELTA	ENTRY (FIXED BINARY(31), BIT(64) ALIGNED),	/* MONITOR MACRO-32 rtn to convert to delta time */ 
MPCHECK		ENTRY RETURNS(BIT(1)),				/* MONITOR MACRO-32 rtn to check for MP capability */
COMPUTE_BOOTTIME ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 rtn to compute system time at boot */
CLUS_NET_INFO	ENTRY RETURNS(FIXED BINARY(31));		/* MONITOR MACRO-32 rtn to get cluster & net info */

Declare
DISP_TEMPLATE	ENTRY (POINTER, BIT(1) ALIGNED)			/* Rtn to display the template */
		RETURNS (FIXED BINARY(31)),
DISPLAY_PUT	ENTRY(ANY, FIXED BINARY(31), ANY, ANY)		/* MACRO-32 rtn to put a display string */
		OPTIONS(VARIABLE)
		RETURNS(FIXED BINARY(31)),
FILL_DISP_BUFF	ENTRY (POINTER, BIT(64) ALIGNED)		/* MACRO-32 Fill display buffer routine */
		RETURNS (FIXED BINARY(31)),
DISPLAY_HOMOG	ENTRY (POINTER)					/* MACRO-32 rtn to display homog class data */
		RETURNS (FIXED BINARY(31)),
DISPLAY_PROCS	ENTRY (POINTER, BIT(64) ALIGNED)		/* MACRO-32 rtn to display processes */
		RETURNS (FIXED BINARY(31)),
DISPLAY_TOP	ENTRY (POINTER)					/* MACRO-32 rtn to display top processes */
		RETURNS (FIXED BINARY(31));

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			     MESSAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MNR$_SSERROR	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_DISPERR	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_BEGNLEND	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_HIB	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_CLASNP	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_CLASUNK	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOCLASS	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_CLASDISAB	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_BEGRAN	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_PREMEOF	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_INVINPFIL	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_UNSTLEV	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOOUTPUT	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_UNEXPERR	FIXED BINARY(31) GLOBALREF VALUE;


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		       GLOBAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
HEADER_TYPE	FIXED BINARY(15) GLOBALDEF INIT(128),		/* Type code for MONITOR recording file header */
SYI_TYPE	FIXED BINARY(15) GLOBALDEF INIT(129),		/* Type code for MONITOR recording file sys info record */
DISP_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(16),	/* Display event flag */
DISP_EV_FLAG_M	BIT(32) ALIGNED GLOBALDEF VALUE INIT('00000000000000001'B), /* Display event flag mask */
REFR_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(17),	/* Refresh event flag */
REFR_EV_FLAG_M	BIT(32) ALIGNED GLOBALDEF VALUE INIT('000000000000000001'B), /* Refresh event flag mask */
COLL_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(18),	/* Collection event flag */
BET_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(19),	/* "Between screens" event flag */
HIB_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(20),	/* Hibernation event flag */
INTERVAL_DEFAULT FIXED BINARY(31) GLOBALDEF VALUE INIT(3),	/* Default collection interval value */
ALLCL_INT_DEFAULT FIXED BINARY(31) GLOBALDEF VALUE INIT(6),	/* Default coll. interval for ALL classes Pseudo class */
SYSCL_INT_DEFAULT FIXED BINARY(31) GLOBALDEF VALUE INIT(6),	/* Default coll. interval for SYSTEM class Pseudo class */
VIEWING_DEFAULT	FIXED BINARY(31) GLOBALDEF VALUE INIT(3),	/* Default viewing time value */
FLUSH_INT_DEFAULT FIXED BINARY(31) GLOBALDEF VALUE INIT(300),	/* Default flush interval value */
BALSETMEM_DEF	FIXED BINARY(31) GLOBALDEF VALUE INIT(3000),	/* Default value for balance set memory */
MPWHILIM_DEF	FIXED BINARY(31) GLOBALDEF VALUE INIT(500),	/* Default value for MPW_HILIMIT */
COLLENDED	BIT(1) ALIGNED	 GLOBALDEF,			/* YES => collection has ended */
CTRLZ_HIT	BIT(1) ALIGNED	 GLOBALDEF,			/* YES => CTRL-Z has been hit */
CTRLCZ_HIT	BIT(1) ALIGNED	 GLOBALDEF,			/* YES => CTRL-C or CTRL-Z has been hit */
NEXT_REC	FIXED BINARY(31) GLOBALDEF VALUE INIT(0),	/* Read next record indicator for READ_INPUT rtn */
SKIP_TO_CLASS	FIXED BINARY(31) GLOBALDEF VALUE INIT(1),	/* Skip to class record indicator for READ_INPUT rtn */
CCDPTR		POINTER		 GLOBALDEF,			/* Pointer to CCD (Current Class Descriptor) Array */
COLL_STATUS	FIXED BINARY(31) GLOBALDEF,			/* COLLECTION_EVENT status code */
H		POINTER		 GLOBALDEF,			/* Pointer to input file header */
INP_COMM_STR	CHAR(MNR_HDR$K_MAXCOMLEN) GLOBALDEF,		/* User comment string from input file */
INP_COMM_LEN	FIXED BINARY(15) GLOBALDEF;			/* Actual length of comment string */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	NOT_SUCCESSFUL		BY '0'B;		/* Failing status bit */
%REPLACE 	YES			BY '1'B;		/* For general use */
%REPLACE 	NO			BY '0'B;		/* For general use */
%REPLACE	ENABLE_AST		BY 1;			/* Enable AST indicator */
%REPLACE	DISABLE_AST		BY 0;			/* Disable AST indicator */
%REPLACE	AND_OP			BY '0001'B;		/* AND Boolean operation */
%REPLACE	XOR_OP			BY '0110'B;		/* XOR Boolean operation */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CALL		FIXED BINARY(31),				/* Holds function value (return status) of called routines */ 
STATUS		BIT(1)	BASED(ADDR(CALL));			/* Low-order status bit for called routines */

Declare
NORMAL		FIXED BINARY(31) GLOBALREF, 			/* MONITOR normal return status */
TEMP		FIXED BINARY(31),				/* Scratch "register" */
CURR_ERRCODE	FIXED BINARY(31),				/* MONITOR error status code currently expected */
REQUEST_STATUS	FIXED BINARY(31),				/* EXECUTE_REQUEST status code */
ALREADY_FAILED	BIT(1) ALIGNED,					/* YES => a failure has already been signaled */
TEMP_PTR	POINTER,					/* Scratch pointer */
RECORD_STR	CHAR(128) VARYING;				/* Fully expanded file name string for the recording file */
								/* NOTE -- When the recording file is re-opened for update, */
								/* it uses this fully expanded file string.  This prevents */
								/* MONITOR from updating the wrong file if a new version is */
								/* created in the directory before the recording file is */
								/* opened for update. */

Declare
INTERVAL_DEL	BIT(64) ALIGNED GLOBALDEF,			/* Delta time value for Interval */
VIEWING_DEL	BIT(64) ALIGNED GLOBALDEF;			/* Delta time value for Viewing time */

Declare
CURR_DCLASS	FIXED BINARY(15),				/* Consec no (not class no) of current display class */
REPT_TOP	BIT(1) ALIGNED,					/* YES => Repeat a TOP display */
MULT_TEMP	FIXED BINARY(31) GLOBALDEF;			/* Temp area for MCA$L_INT_MULT, used in COLLECTION_EVENT */

/*
/*	File Declarations
/*
/*		The recording file is read shareable. This allows other
/*		MONITOR images to use the FLUSHED recording file as input.
/*
/*		When the recording file is opened for update (to write header
/*		information), it uses a fully expanded file string.  This prevents
/*		MONITOR from updating the wrong file if a new version is created
/*		in the directory before the recording file is opened for update. 
/*/

Declare
INPUT_FILE	FILE RECORD INPUT,				/* Monitor Input (Playback) File */
RECORD_FILE	FILE RECORD,	 				/* Monitor Record File */
RECCT		FIXED BINARY(31) GLOBALDEF;			/* Count of records written to record file */

Declare
TEMP_TYPE	BIT(8) ALIGNED;					/* Temporary area for record type byte */

Declare
INPUT_CPTR	POINTER GLOBALDEF,				/* Ptr to input buffer count word */
INPUT_DATA	CHAR(MAX_REC_SIZE) VARYING BASED(INPUT_CPTR),	/* Playback file input buffer */
1 DPUT_FLAGS,							/* DISPLAY_PUT routine flags */
  2 FAOL_REQUESTED BIT(8) ALIGNED,				/* YES => Xlate buffer with FAOL first */
  2 OUTP_REQUESTED BIT(8) ALIGNED, 				/* YES => Really output buffer */
PUT_LEN		FIXED BINARY(31);				/* Length of buffer for DISPLAY_PUT to put */


Declare
FLUSH_IND	BIT(1) ALIGNED		GLOBALDEF,		/* Flush indicator; YES=> perform FLUSH */
FLUSH_COLLS	FIXED BINARY(15)	GLOBALDEF,		/* Number of collection events between FLUSH's */
FLUSH_CTR	FIXED BINARY(15)	GLOBALDEF;		/* Down counter for FLUSH_COLLS */

Declare
01 CURR_CLASS_DESCR (MAX_CLASS_NO+1),				/* Current Class Descriptor Array */
								/* This array of structures includes a CCD (Current */
								/* Class Descriptor) for each class collected. */
    02 CURR_CDBPTR	POINTER,				/* CDBPTR for current class */
    02 CURR_CLASS_NO	FIXED BINARY(7);			/* Class number for current class */


Declare
01 D_CURR_CLASS_DESCR (MAX_CLASS_NO+1),				/* Current Class Descriptor Array for display classes */
								/* This array of structures includes a D_CCD (Current */
								/* Class Descriptor) for each class displayed. */
    02 D_CURR_CDBPTR	POINTER,				/* CDBPTR for current display class */
    02 D_CURR_CLASS_NO	FIXED BINARY(7);			/* Class number for current display class */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	EXECUTE_REQUEST
/*
/*	This routine is called by MONMAIN to execute a MONITOR request.
/*	The request is defined by the Monitor Request Block (MRB), which
/*	is created by MONMAIN after parsing a command string.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	Monitor Request Block (MRB), pointed to by MRBPTR.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	Monitor request has been performed.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

ON FINISH;						/* On finish, do nothing */
ALREADY_FAILED = NO;					/* Indicate no failure yet signaled */
CURR_ERRCODE = 0;					/* Set expected MONITOR code to default */

/*
/*	Set up condition handler to terminate the MONITOR request on:
/*		1) any asynchronous error condition, such as file and I/O errors;
/*		2) any synchronous MONITOR-detected condition.
/*/

ON ANYCONDITION						/* On any condition signaled, */
BEGIN;

Declare
  MNR$_ERRINPFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
  MNR$_ERRRECFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
  MNR$_UNEXPERR		FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
  MON_CODE		FIXED BINARY(31),			/* Monitor message code */
  TEMP			FIXED BINARY(31),			/* Temporary scratch area */
  MNR$_FACNO		FIXED BINARY(31) GLOBALREF VALUE,	/* MONITOR facility number */
  ON_FILE		CHAR(100) VARYING,			/* Holds possible file name string */
  SIGNALED_ERR ENTRY (ANY VALUE, ANY VALUE, ANY VALUE, ANY);	/* Rtn to set up PUTMSGVEC */

IF ^ ALREADY_FAILED						/* If a failure not already signaled, */
    THEN DO;
	 ALREADY_FAILED = YES;					/* Indicate a failure has been signaled */
	 CHF$ARGPTR = ONARGSLIST();				/* Get signal array pointer */
	 STS$VALUE = CHF$SIG_NAME;				/* Get code for signaled condition */
	 UNSPEC(TEMP) = STS$FAC_NO;				/* Convert facility no. to binary in TEMP */
	 IF TEMP = MNR$_FACNO					/* If a MONITOR code, */
	     THEN MON_CODE = STS$VALUE;				/*     then remember it */
	     ELSE DO;						/* Otherwise, need to set the MON_CODE */
		  ON_FILE = ONFILE();					/* Get PL/I file constant if I/O cond */
		  IF ON_FILE = 'INPUT_FILE'				/* If input file error, */
		      THEN MON_CODE = MNR$_ERRINPFIL;			/* Set Monitor status code accordingly */
		      ELSE IF ON_FILE = 'RECORD_FILE'			/* See if it's the recording file */
			       THEN MON_CODE = MNR$_ERRRECFIL;		/* Yes, save code */
			       ELSE IF CURR_ERRCODE = 0			/* No, see if an error is currently expected */
					THEN MON_CODE = MNR$_UNEXPERR;	/* No, set "unexpected" code */
					ELSE MON_CODE = CURR_ERRCODE;	/* Yes, set currently expected code */
		  CURR_ERRCODE = 0;					/* Reset to default MONITOR error code ("unexpected") */
		  CALL SIGNALED_ERR(MON_CODE,STS$VALUE,DIM(CHF$SIG_ARG,1),CHF$SIG_ARG); /* Log the error */
		  END;

	 REQUEST_STATUS = MON_CODE;				/* Set up code for MONITOR request termination */
	 CALL = COLLECTION_END();				/* Shut down collection activity */
	 CALL REQUEST_CLEANUP();				/* Perform cleanup for files, memory, etc. */
	 END;

GO TO REQUEST_EXIT;						/* Go return from EXECUTE_REQUEST (PL/I does an UNWIND) */

END;								/* End of ON-condition routine */

/*
/*	Set up EOF condition
/*/

IF M->MRB$A_INPUT ^= NULL()				/* If this is a PLAYBACK request, */
    THEN  ON ENDFILE(INPUT_FILE) MC->MCA$V_EOF = YES; 	/* then set up EOF condition */

/*
/*	General MONITOR request initialization
/*/

CALL = REQUEST_INIT();					/* Initialization for this request */	
IF STATUS = NOT_SUCCESSFUL
    THEN CALL SIGNAL_MON_ERR();				/* Short-circuit request if failure */

/*
/*	Establish CTRL-C and CTRL-Z handlers for terminating the MONITOR request.
/*	CTRL-C causes a MONITOR> prompt. CTRL-Z returns to DCL.
/*/

IF COLLENDED = NO  THEN CALL = ESTAB_CTRLCZ();		/* If still collecting, establish CTRL-C and CTRL-Z handlers */
							/* If error, do not terminate; simply ignore CTRL-C's and CTRL-Z's */

/*
/*	Establish CTRL-W handler for refreshing the terminal display.
/*/

IF COLLENDED = NO & M->MRB$V_DISPLAY			/* If still collecting, and display requested */
    THEN CALL = ESTAB_CTRLW();				/* ... establish CTRL-W handler */
							/* If error, do not terminate; simply ignore CTRL-W's */

/*
/*	If this is a live request, beginning in the future, "hibernate"
/*	the process until ready to execute. (Use event flags instead of $HIBER
/*	to avoid the problem of outstanding wakeups interfering with later
/*	MONITOR requests.)
/*/

IF ^ M->MRB$V_PLAYBACK & MC->MCA$V_FUTURE		/* If live future request, */
                       & COLLENDED = NO			/* ... and not terminated, */
    THEN DO;
	 CALL = SYS$SETIMR(HIB_EV_FLAG,M->MRB$Q_BEGINNING,,HIB_EV_FLAG);
							/* ... set flag when ready to execute request */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,SETIMR_STR); /* Yes -- log the error */
		  CALL SIGNAL_MON_ERR();		/* ... and signal it */
		  END;
	 BEGIN;
	 DECLARE 1 HIBMSG,				/* Declare hibernate msg vec dynamically */
	 	  2 HCOUNT FIXED BIN(31) INIT(1),
		  2 HMSG   FIXED BIN(31) INIT(MNR$_HIB);
	 CALL = SYS$PUTMSG(HIBMSG,,);			/* Let user know we're sleeping */
	 END;
	 IF COLLENDED = NO  THEN CALL = SYS$WAITFR(HIB_EV_FLAG); /* ... ZZZZZZZZZZ */
	 END;

/*
/*	Initialization associated with /DISPLAY output
/*/

IF M->MRB$V_DISPLAY 					/* If DISPLAY has been requested, */
   & COLLENDED = NO					/* ... and request not terminated, */
    THEN DO;
	 CALL = DISPLAY_INIT();				/* ... then perform init for it */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_DISPERR,CALL);	/* Yes -- log the error */
		  CALL SIGNAL_MON_ERR();		/* ... and signal it */
		  END;
	 ON FINISH CALL = DISPLAY_CLEANUP();		/* On finish, do display cleanup */
	 END;

/*
/*	Initialization associated with /RECORD output
/*/

IF M->MRB$V_RECORD					/* If RECORD has been requested, */
   & COLLENDED = NO					/* ... and request not terminated, */
    THEN DO;
	 CALL = RECORD_INIT();				/* ... then do init for it */
	 IF STATUS = NOT_SUCCESSFUL
	     THEN CALL SIGNAL_MON_ERR();		/* Signal error if failure */
	 END;

/*
/*	Execute main monitoring routine. When control returns from the CALL,
/*	the MONITOR request will have terminated.
/*/

IF COLLENDED = NO					/* If collection not ended, */
    THEN DO;
	 CALL = MONITOR_REQUEST();			/* Perform the MONITOR request */
	 IF STATUS = NOT_SUCCESSFUL			/* If failed, */
	     THEN CALL SIGNAL_MON_ERR();		/* ... signal the error */
	 END;

/*
/*	Perform SUMMARY processing if requested.
/*/

IF M->MRB$V_SUMMARY					/* If SUMMARY has been requested, */
    THEN DO;
	 CALL = REQUEST_SUMMARY();			/* Perform SUMMARY processing */
	 IF STATUS = NOT_SUCCESSFUL			/* If failed, */
	     THEN CALL SIGNAL_MON_ERR();		/* ... signal the error */
	 END;

/*
/*	Perform Multi-File Summary processing if requested.
/*/

IF M->MRB$V_MFSUM					/* If Multi-File Summary has been requested, */
    THEN DO;
	 CALL = SAVE_SUM_BUFFS();			/* Save SUM buffers */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_UNEXPERR,CALL);	/* Yes -- log the error */
		  CALL SIGNAL_MON_ERR();		/* ... and signal it */
		  END;
	 END;

/*
/*	Cleanup processing
/*/

CALL REQUEST_CLEANUP();					/* Execute various cleanup routines */

/*
/*	Exit from EXECUTE_REQUEST routine
/*	Note -- we get to this point either by falling through
/*	the above code (normal path), or by direct branch from
/*	the condition-handling routine (error path).
/*/

REQUEST_STATUS = NORMAL;				/* Normal status if we get to this point */

REQUEST_EXIT:

RETURN(REQUEST_STATUS);					/* Return to MONMAIN.PLI with status */

REQUEST_INIT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	REQUEST_INIT
/*
/*	Performs initialization for the Monitor request.
/*	Fills in defaults for the MRB (Monitor Request Block).
/*	Also inits the MCA (Monitor Communication Area), opens
/*	the input (playback) file if necessary, and fills in the
/*	SYI (System Information Area).
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/* SIDE EFFECTS:
/*
/*	/INPUT file (INPUT_FILE) is positioned to the first class record.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  F		POINTER;				/* Pointer to class record in input file */

REQUEST_STATUS = NORMAL;				/* Start off this MONITOR request with normal status */
COLL_STATUS = NORMAL;					/* Start off COLLECTION_EVENT with normal status */
COLLENDED = NO;						/* Indicate collection has not ended */
CTRLZ_HIT = NO;						/* Indicate CTRL-Z not hit */
CTRLCZ_HIT = NO;					/* Indicate CTRL-C and CTRL-Z not hit */
CTRLCZ_CHAN = 0;					/* ... and no channel assigned for them */
CTRLW_CHAN = 0;						/* No channel assigned for CTRL-W */
INP_COMM_LEN = 0;					/* Length of input comment string */
MC->MCA$L_COLLCNT = 0;					/* Initialize collection count */
MC->MCA$L_DISPCNT = 0;					/* ... and display count */
MC->MCA$L_CONSEC_REC = 0;				/* Consecutive collection number for recording */
MC->MCA$Q_LASTCOLL = '0'B;				/* Init latest collection time */
MC->MCA$V_FUTURE = NO;					/* Assume not a future request */
MC->MCA$V_EOF = NO;					/* Assume EOF not yet found on /INPUT file */
MC->MCA$V_ERA_SCRL = NO;				/* Assume no need to erase scrolling region */
MC->MCA$V_VIDEO = NO;					/* Assume display terminal is not video */
MC->MCA$V_GRAPHICS = NO;				/* ... and not VT-55 graphics */
MC->MCA$V_TOP_DISP = NO;				/* Indicate no TOP displays issued yet */
MC->MCA$V_S_TOP_DISP = NO;				/* Also no SYSTEM (TOP) displays issued yet */
MC->MCA$V_REFRESH = NO;					/* Indicate screen refresh request not received */
MC->MCA$V_FILLER = '0'B;				/* Clear all unused flags */
FLUSH_IND = NO;						/* Indicate recording file flush not required */
CURR_DCLASS = 0;					/* Init current display class */
REPT_TOP = NO;						/* Indicate do not repeat TOP display */
DISPLAYING = NO;					/* Indicate display output not yet begun */
CCDPTR = ADDR(CURR_CLASS_DESCR);			/* Set up ptr for COLLECTION_EVENT to use */
CALL = SYS$CLREF(REFR_EV_FLAG);				/* Clear refresh event flag */
CALL = SYS$SETAST(ENABLE_AST);				/* Make sure AST's are enabled */

/*
/*	Set MRB flags for options that were requested
/*/

IF M->MRB$A_INPUT   ^= NULL() THEN M->MRB$V_PLAYBACK = YES; /* If INPUT specified, indicate so */
IF M->MRB$A_DISPLAY ^= NULL() THEN M->MRB$V_DISPLAY = YES;  /* If DISPLAY specified, indicate so */
IF M->MRB$A_RECORD  ^= NULL() THEN M->MRB$V_RECORD = YES;   /* If RECORD specified, indicate so */
IF M->MRB$A_SUMMARY ^= NULL() THEN M->MRB$V_SUMMARY = YES;  /* If SUMMARY specified, indicate so */

IF ^ M->MRB$V_DISPLAY & ^ M->MRB$V_RECORD & ^ M->MRB$V_SUMMARY /* If none of the outputs requested, */
 & ^ M->MRB$V_MFSUM					       /* ... AND it's not a m.f. summary, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOOUTPUT);			/* Log the error */
	 RETURN(MNR$_NOOUTPUT);				/* ... and return with status */
	 END;

/*
/*	Set or clear display event flag
/*/

IF M->MRB$V_DISPLAY					/* If display requested, */
    THEN CALL = SYS$SETEF(DISP_EV_FLAG);		/* ... then set display event flag to force 1st display event */
    ELSE CALL = SYS$CLREF(DISP_EV_FLAG);		/* ... otherwise clear it */

/*
/*	If PLAYBACK, perform input file initialization, so MONITOR file header information can be accessed.
/*/

IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN DO;
         CALL = INPUT_INIT();			 	/* ... perform input file initializaton */
         IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);
         END;

IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN DO;
	 INP_COMM_STR = H->MNR_HDR$T_COMMENT;		/* Save user's comment string from header record */
	 INP_COMM_LEN = H->MNR_HDR$W_COMLEN;		/* ... and its length */
	 END;

/*
/*	The next several groups of code update the MRB with default and
/*	specified values, and, for PLAYBACK, values from the input file.
/*/

/*
/*	Verify requested classes and set up Current Class Descriptor array
/*/

BEGIN;
Declare
SELECT_REV_LEVS	ENTRY(BIT(128) ALIGNED, BIT(128) ALIGNED, CHAR(128), ANY) /* MACRO-32 rtn to select revision levels ... */
		OPTIONS(VARIABLE),				          /* ... for all classes */
CALC_LEN	ENTRY(BIT(128) ALIGNED)					  /* MACRO-32 rtn to calculate class block (record) length */
		RETURNS (FIXED BINARY(31));
Declare
REVLEVELS	(0:127) FIXED BINARY(7) GLOBALDEF,		/* Revision Levels Vector */
REV0CLSBITS	BIT(128) GLOBALDEF,				/* Monitored classes still at Rev Level 0 */
REV0CB_VEC	(0:127) BIT(1) DEFINED(REV0CLSBITS);		/* Bit-addressable alias */
Declare
  FILE_CLASSES	BIT(128),					/* Classes from input file */
  REQ_CLASSES	BIT(128),					/* Classes requested by user */
  NP_CLASSES	BIT(MAX_CLASS_NO+1),				/* Classes requested but not in input file */
  DO_CLASSES	BIT(128),					/* Classes to actually monitor */
  DO_CLASSES_VEC (0:127) BIT(1) DEFINED(DO_CLASSES),		/* Bit-addressable alias */
  DO_CLASSES_AL BIT(128) ALIGNED,				/* Aligned copy of DO_CLASSES */
  UNK_CLASSES	BIT(128) ALIGNED,				/* Classes with unknown revision levels */
  DISPLAY_CLASSES BIT(128) ALIGNED GLOBALDEF,			/* Classes to be displayed */
  CDBHEAD	FIXED BINARY(31) GLOBALREF VALUE,		/* Address of first CDB */
  I		FIXED BINARY(15),				/* Index for do-loop */
  CLASS_NO	FIXED BINARY(7),				/* Class number */
  TEMP_CDBPTR	POINTER,					/* Ptr to Class Descriptor Block (CDB) */
  CDBPTR_COMP	FIXED BINARY(31) BASED(ADDR(TEMP_CDBPTR));	/* Computable CDBPTR */

Declare
  SYS_REQ	BIT(1) ALIGNED,					/* YES => SYSTEM class requested */
  PROCS_REQ	BIT(1) ALIGNED,					/* YES => PROCESSES class requested */
  STATES_REQ	BIT(1) ALIGNED,					/* YES => STATES class requested */
  MODES_REQ	BIT(1) ALIGNED;					/* YES => MODES class requested */

DO I = 0 TO 127;						/* Set all revision levels ... */
REVLEVELS(I) = 0;						/* ... to 0 */
END;

DO_CLASSES = M->MRB$O_CLASSBITS;				/* Get set of classes to do */

IF M->MRB$V_PLAYBACK						/* Playback request */
    THEN DO;
	 IF MNR_HDR$K_CLASSBITS < MC->MCA$L_INPUT_LEN		/* If CLASSBITS field is defined for input file, */
	     THEN FILE_CLASSES = H->MNR_HDR$O_CLASSBITS;	/*   then get file classes from usual place */
	     ELSE FILE_CLASSES = H->MNR_HDR$O_REV0CLSBITS;	/*   else get them from another place */
								/* NOTE -- MNR_HDR$O_REV0CLSBITS is used for compatibility */
								/*         with MONSL001 and MONBA001 file struct levels */
	 REQ_CLASSES = DO_CLASSES;				/* Get requested classes */
	 DO_CLASSES = BOOL(FILE_CLASSES,REQ_CLASSES,AND_OP); 	/* Compute classes to actually do */
	 NP_CLASSES = BOOL(DO_CLASSES,REQ_CLASSES,XOR_OP); 	/* Compute classes not present */
	 IF DO_CLASSES = '0'B					/* If no classes to be done, */
	     THEN DO;
		  CALL MON_ERR(MNR$_NOCLASS);			/* Log error */
		  RETURN(MNR$_NOCLASS);				/* ... and return */
		  END;

	 IF M->MRB$V_DISPLAY = NO & NP_CLASSES ^= '0'B		/* If at least one class not present AND not displaying, */
	    & M->MRB$V_MFSUM = NO & M->MRB$V_ALL_CLASS = NO	/* ... AND not multi-file summary, AND not ALL_CLASSES, */
	     THEN BEGIN;					/* ... then print a warning */
		  DECLARE 1 NPMSG,				/* Declare not present msg vec dynamically */
		 	   2 NPCOUNT FIXED BIN(31) INIT(1),
			   2 NPMSG   FIXED BIN(31) INIT(MNR$_CLASNP);
		  CALL = SYS$PUTMSG(NPMSG,,);			/* Warn user that classes missing */
		  END;
	 END;

IF DO_CLASSES_VEC(SYSTEM_CLSNO)					/* If SYSTEM class requested, */
    THEN DO;
	 SYS_REQ = YES;						/* Remember that fact */
	 PROCS_REQ = DO_CLASSES_VEC(PROCS_CLSNO);		/* Remember whether PROCESSES requested */
	 DO_CLASSES_VEC(PROCS_CLSNO) = YES;			/* ... and include it */
	 STATES_REQ = DO_CLASSES_VEC(STATES_CLSNO);		/* Remember whether STATES requested */
	 DO_CLASSES_VEC(STATES_CLSNO) = YES;			/* ... and include it */
	 MODES_REQ = DO_CLASSES_VEC(MODES_CLSNO);		/* Remember whether MODES requested */
	 DO_CLASSES_VEC(MODES_CLSNO) = YES;			/* ... and include it */
	 END;
    ELSE SYS_REQ = NO;						/* Indicate SYSTEM class not requested */

DO_CLASSES_AL = DO_CLASSES;					/* Get aligned string for later routine calls */

IF M->MRB$V_PLAYBACK						/* Playback request */
    THEN DO;
	 /*
	 /* 	For each class in DO_CLASSES, update the CDB with information
	 /* 	from the CHD (CHange Descriptor) for the appropriate revision
	 /* 	level.
	 /*
	 /* 	Eliminate from DO_CLASSES those classes with incompatible structure
	 /* 	levels. Issue a warning message if any incompatibilities found.
	 /*/

	 IF MNR_HDR$K_REVLEVELS < MC->MCA$L_INPUT_LEN		/* If REVLEVELS field is defined for input file, */
	     THEN DO;
		  CALL SELECT_REV_LEVS(DO_CLASSES_AL, UNK_CLASSES,
				       H->MNR_HDR$T_REVLEVELS, REVLEVELS); /* Select revision levels ... */
									   /* ... for all classes */
		  IF  UNK_CLASSES ^= '0'B			/* If at least one class has unknown rev level, */
		      THEN DO;
			   DO_CLASSES = BOOL(DO_CLASSES,UNK_CLASSES,XOR_OP); /* Remove unknowns from DO_CLASSES */
			   IF M->MRB$V_DISPLAY = NO		/* If not displaying, */
			       THEN BEGIN;			/* ... then print a warning */
				    DECLARE 1 UNKMSG,		/* Declare unknown msg vec dynamically */
					     2 UNKCOUNT FIXED BIN(31) INIT(1),
					     2 UNKMSG   FIXED BIN(31) INIT(MNR$_CLASUNK);
				    CALL = SYS$PUTMSG(UNKMSG,,); /* Warn user that classes have unknown structs */
				    END;
			   END;
		  END;

	     ELSE						  /* Revision levels all 0 */
		  CALL SELECT_REV_LEVS(DO_CLASSES_AL,,,REVLEVELS); /* Move CHD info into CDB */
								  /* ... for all classes */
	 END;

    ELSE DO;							/* Live request */
	 CALL SELECT_REV_LEVS(DO_CLASSES_AL,,,REVLEVELS);	/* Select revision levels for all classes */
	 END;

IF DO_CLASSES_VEC(SYSTEM_CLSNO) = YES				/* If SYSTEM class being monitored, */
    THEN M->MRB$V_SYSCLS = YES;					/*   then indicate so */
    ELSE DO;
	 M->MRB$V_SYSCLS = NO;					/*   else indicate not */
	 IF SYS_REQ = YES					/* If SYSTEM originally requested, */
	     THEN DO;						/*   then make some further checks */
		  IF PROCS_REQ = NO				/* If PROCESSES not originally requested, */
		      THEN DO_CLASSES_VEC(PROCS_CLSNO) = NO;	/* ... make sure it's off now */
		  IF STATES_REQ = NO				/* If STATES not originally requested, */
		      THEN DO_CLASSES_VEC(STATES_CLSNO) = NO;	/* ... make sure it's off now */
		  IF MODES_REQ = NO				/* If MODES not originally requested, */
		      THEN DO_CLASSES_VEC(MODES_CLSNO) = NO;	/* ... make sure it's off now */
		  END;
	 END;

IF M->MRB$V_MFSUM						/* If multi-file summary, */
    THEN DO_CLASSES_VEC(PROCS_CLSNO) = NO;			/*   then make sure PROCESSES class is still off */

IF DO_CLASSES = '0'B						/* If no classes to be done, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOCLASS);				/* Log error */
	 RETURN(MNR$_NOCLASS);					/* ... and return */
	 END;

DISPLAY_CLASSES = M->MRB$O_CLASSBITS;				/* Get unaligned copy of orig requested classes */
DISPLAY_CLASSES = BOOL(DISPLAY_CLASSES,DO_CLASSES,AND_OP);	/* Compute classes to display */
M->MRB$O_CLASSBITS = DO_CLASSES;				/* Remember classes to collect */

/*
/*	Given DO_CLASSES, execute do loop using INDEX builtin
/*	to fill in the CCD (Current Class Descriptor) array.
/*	When do loop is finished, MRB$O_CLASSBITS, MRB$W_CLASSCT
/*				  MCA$B_FIRSTC and MCA$B_LASTC
/*				  will all be established.
/*/

REV0CLSBITS = '0'B;						/* Assume no classes at Rev Level 0 */
CALL = CALC_LEN(M->MRB$O_CLASSBITS);				/* Calc CDB$W_BLKLEN field for each class */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);			/* Return if error */

CLASS_NO = 0;							/* Initialize class number */
DO I = 1 TO MAX_CLASS_NO + 1  WHILE(CLASS_NO >= 0);		/* Loop once for each possible class */
  CLASS_NO = INDEX(DO_CLASSES,YES) - 1;				/* Find next requested class number */
  IF CLASS_NO >= 0						/* Only continue if a class was found */
    THEN DO;
         DO_CLASSES_VEC(CLASS_NO) = NO;				/* Eliminate it from future consideration */
	 IF REVLEVELS(CLASS_NO) = 0				/* If this class is at Rev Level 0, */
	     THEN REV0CB_VEC(CLASS_NO) = YES;			/*   then indicate so */
         CURR_CLASS_NO(I) = CLASS_NO;				/* Store class_no in CCD table */
         IF I = 1 THEN MC->MCA$B_FIRSTC = CLASS_NO;		/* Mark first class requested */
         MC->MCA$B_LASTC = CLASS_NO;				/* Mark last class requested */
         M->MRB$W_CLASSCT = I;					/* Keep track of class count */
         CDBPTR_COMP = CDBHEAD + (CDB$K_SIZE * CURR_CLASS_NO(I));
								/* Compute current cdbptr ... */
         CURR_CDBPTR(I) = TEMP_CDBPTR;				/* ... and store it in CCD table */
         END;
END;

/*
/*	Now, given DISPLAY_CLASSES, do a similar loop as above to set up D_CCD,
/*	the display version of the CCD. When loop is finished, the array will
/*	be established along with MCA$W_DCLASSCT, the number of display classes.
/*/

DO_CLASSES = DISPLAY_CLASSES;					/* Use DO_CLASSES vector */
IF DO_CLASSES_VEC(PROCS_CLSNO)					/* If PROCESSES to be displayed, */
  THEN M->MRB$V_PROC_REQ = YES;					/*   then indicate it was requested */
  ELSE M->MRB$V_PROC_REQ = NO;					/*   else indicate not */
CLASS_NO = 0;							/* Initialize class number */
DO I = 1 TO MAX_CLASS_NO + 1  WHILE(CLASS_NO >= 0);		/* Loop once for each possible class */
  CLASS_NO = INDEX(DO_CLASSES,YES) - 1;				/* Find next requested class number */
  IF CLASS_NO >= 0						/* Only continue if a class was found */
    THEN DO;
         DO_CLASSES_VEC(CLASS_NO) = NO;				/* Eliminate it from future consideration */
         D_CURR_CLASS_NO(I) = CLASS_NO;				/* Store class_no in D_CCD table */
         MC->MCA$W_DCLASSCT = I;				/* Keep track of class count */
         CDBPTR_COMP = CDBHEAD + (CDB$K_SIZE * D_CURR_CLASS_NO(I));
								/* Compute current cdbptr ... */
         D_CURR_CDBPTR(I) = TEMP_CDBPTR;			/* ... and store it in D_CCD table */
         END;
END;

END;								/* End of BEGIN-END group */

/*
/*	Establish defaults for FLUSH_INTERVAL, INTERVAL and VIEWING_TIME 
/*      options.
/*	If Playback, divide file value for INTERVAL into requested value, and round
/*	requested value up to the next whole multiple of the file value. Store the
/*	multiple value in MCA$L_INT_MULT. It will be used to trigger recording and
/*	display events.
/*/

IF M->MRB$L_FLUSH = 0						/* If FLUSH never specified... */
    THEN M->MRB$L_FLUSH = FLUSH_INT_DEFAULT;			/* normal default value */

IF M->MRB$V_PLAYBACK						/* Playback request */
    THEN DO;
	 IF M->MRB$L_VIEWING_TIME = 0				/* If VIEWING_TIME never specified, */
	     THEN M->MRB$L_VIEWING_TIME = VIEWING_DEFAULT;	/* ... then take default */
	 IF M->MRB$L_INTERVAL = 0				/* If INTERVAL never specified, */
	     THEN DO;
		  M->MRB$L_INTERVAL = H->MNR_HDR$L_INTERVAL;	/* ... then use file value */
		  MC->MCA$L_INT_MULT = 1;			/* ... and multiple of 1 */
		  END;
	     ELSE DO;						/* INTERVAL explicitly specified */
		  MC->MCA$L_INT_MULT = DIVIDE(M->MRB$L_INTERVAL,H->MNR_HDR$L_INTERVAL,31);
								/* Divide spec'd val by file val */
		  IF (M->MRB$L_INTERVAL - (H->MNR_HDR$L_INTERVAL * MC->MCA$L_INT_MULT)) ^= 0
		      THEN DO;
			   MC->MCA$L_INT_MULT = MC->MCA$L_INT_MULT + 1; /* Round up if necessary */
			   M->MRB$L_INTERVAL = MC->MCA$L_INT_MULT * H->MNR_HDR$L_INTERVAL; /* Round interval too */
			   END;
		  END;
	 END;

    ELSE DO;							/* Live request */
	 IF M->MRB$L_INTERVAL = 0				/* If INTERVAL never specified... */
	     THEN IF M->MRB$V_ALL_CLASS				/* ALL class request */
			THEN M->MRB$L_INTERVAL = ALLCL_INT_DEFAULT;	/* ALL class default value */
			ELSE IF M->MRB$V_SYSCLS			/* SYSTEM class request */
			        THEN M->MRB$L_INTERVAL = SYSCL_INT_DEFAULT;  /* SYSTEM class default value */ 
				ELSE M->MRB$L_INTERVAL = INTERVAL_DEFAULT;	/* normal default value */
	 IF M->MRB$L_VIEWING_TIME = 0				/* If VIEWING_TIME never specified... */
	     THEN M->MRB$L_VIEWING_TIME = M->MRB$L_INTERVAL;	/* Default to interval value */
	 IF M->MRB$L_INTERVAL <= M->MRB$L_FLUSH			/* Requested interval not larger than flush period? */
	     THEN FLUSH_COLLS = DIVIDE(M->MRB$L_FLUSH,M->MRB$L_INTERVAL,31); /* Yes -- compute collections until flush */
	     ELSE FLUSH_COLLS = 1;				/* No -- flush on every collection */
	 FLUSH_CTR = FLUSH_COLLS;				/* Set up down counter */

	 END;
 
CALL CVT_TO_DELTA(M->MRB$L_INTERVAL,INTERVAL_DEL);		/* Convert INTERVAL to delta time */
CALL CVT_TO_DELTA(M->MRB$L_VIEWING_TIME,VIEWING_DEL);		/* Convert VIEWING_TIME to delta time */

/*
/*	Establish defaults for BEGINNING and ENDING options
/*/

IF M->MRB$V_PLAYBACK
    THEN MC->MCA$Q_CURR_TIME = H->MNR_HDR$Q_BEGINNING;		/* If Playback, get current time from file */
								/* If Live, MCA$Q_CURR_TIME already contains */
								/* ... current time from system */

/*
/*	If user requested a past time for the BEGINNING option,
/*	or defaulted, then replace his value with MCA$Q_CURR_TIME.
/*	Otherwise, indicate a future request.
/*/

MC->MCA$V_FUTURE = QUAD_LT_QUAD(MC->MCA$Q_CURR_TIME,M->MRB$Q_BEGINNING); /* MCA$V_FUTURE gets YES or NO */
IF MC->MCA$V_FUTURE = NO
    THEN M->MRB$Q_BEGINNING = MC->MCA$Q_CURR_TIME;			/* If NO, give user current time */

/*
/*	For PLAYBACK, verify ENDING option. If file value is
/*	non-zero, replace requested value with file value if
/*	requested value is 0 (never specified), or requested
/*	value is larger (later) than file value.
/*/

IF M->MRB$V_PLAYBACK
    THEN IF ^ QUAD_EQ_0(H->MNR_HDR$Q_ENDING)
	     THEN IF QUAD_EQ_0(M->MRB$Q_ENDING)
		      THEN M->MRB$Q_ENDING = H->MNR_HDR$Q_ENDING;
		      ELSE IF QUAD_LT_QUAD(H->MNR_HDR$Q_ENDING,M->MRB$Q_ENDING)
			       THEN M->MRB$Q_ENDING = H->MNR_HDR$Q_ENDING;

/*
/*	Set indefinite end bit if ENDING option never specified.
/*
/*	Also, perform sanity check of BEGINNING and ENDING times.
/*	If BEGINNING not less than ENDING, exit with error.
/*/

IF QUAD_EQ_0(M->MRB$Q_ENDING)						/* If ENDING never specified, */	
    THEN M->MRB$V_INDEFEND = YES;					/* ... call it indefinite */
    ELSE IF QUAD_LT_QUAD(M->MRB$Q_BEGINNING,M->MRB$Q_ENDING) = NO	/* If BEGINNING not less than ENDING, */
	 THEN DO;
	      CALL MON_ERR(MNR$_BEGNLEND);				/* Log the error */
	      RETURN(MNR$_BEGNLEND);					/* ... and return with status */
	      END;

/*
/*	Get information about the monitored system.
/*/

IF M->MRB$V_PLAYBACK					/* PLAYBACK request */
    THEN DO;
	 CALL READ_INPUT(NEXT_REC);			/* Read system information record */
	 IF MC->MCA$V_EOF				/* If end-of-file, */
	     THEN DO;
		  CALL MON_ERR(MNR$_PREMEOF);		/* Can't find sys info record; log the error */
		  RETURN (MNR$_PREMEOF);		/* ... and return to caller */
		  END;

	 TEMP_PTR = MC->MCA$A_INPUT_PTR;		/* Establish ptr to sys info record */
	 TEMP_TYPE = UNSPEC(SYI_TYPE);			/* Get sys info type into a byte for compare */
	 IF TEMP_PTR->MNR_SYI$B_TYPE ^= TEMP_TYPE	/* If this record is not the sys info rec, */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVINPFIL);		/* Log an error */
		  RETURN(MNR$_INVINPFIL);		/* ... and return to caller */
		  END;

	 /*
	 /* Move entire sys info record to System Information Area 
	 /*/

	 SPTR->MNR_SYI$B_TYPE = TEMP_PTR->MNR_SYI$B_TYPE;	/* Get SYI type code */
	 SPTR->MNR_SYI$W_FLAGS = TEMP_PTR->MNR_SYI$W_FLAGS;	/* Get all flags */
	 SPTR->MNR_SYI$B_MPCPUS = TEMP_PTR->MNR_SYI$B_MPCPUS;	/* Get number of cpu's */
	 SPTR->MNR_SYI$W_MAXPRCCT = TEMP_PTR->MNR_SYI$W_MAXPRCCT; /* Get MAXPROCESSCNT SYSGEN parameter */
	 SPTR->MNR_SYI$Q_BOOTTIME = TEMP_PTR->MNR_SYI$Q_BOOTTIME; /* Get system boot time */

	 IF MNR_SYI$K_NODENAME < MC->MCA$L_INPUT_LEN		/* If NODENAME field is defined for input file, */
	     THEN SPTR->MNR_SYI$T_NODENAME = TEMP_PTR->MNR_SYI$T_NODENAME; /* ... then pick it up from there */
	     ELSE UNSPEC(SPTR->MNR_SYI$T_NODENAME) = '0'B;	/* Otherwise, simply clear it */

	 IF MNR_SYI$K_BALSETMEM < MC->MCA$L_INPUT_LEN		/* If BALSETMEM field is defined for input file, */
	     THEN SPTR->MNR_SYI$L_BALSETMEM = TEMP_PTR->MNR_SYI$L_BALSETMEM; /* ... then pick it up from there */
	     ELSE SPTR->MNR_SYI$L_BALSETMEM = BALSETMEM_DEF;	/* Otherwise, use a constant default value */

	 IF MNR_SYI$K_MPWHILIM < MC->MCA$L_INPUT_LEN		/* If MPWHILIM field is defined for input file, */
	     THEN SPTR->MNR_SYI$L_MPWHILIM = TEMP_PTR->MNR_SYI$L_MPWHILIM; /* ... then pick it up from there */
	     ELSE SPTR->MNR_SYI$L_MPWHILIM = MPWHILIM_DEF;	/* Otherwise, use a constant default value */

	 IF MNR_SYI$K_CPUTYPE < MC->MCA$L_INPUT_LEN		/* If CPUTYPE field is defined for input file, */
	     THEN SPTR->MNR_SYI$L_CPUTYPE = TEMP_PTR->MNR_SYI$L_CPUTYPE; /* ... then pick it up from there */
	     ELSE SPTR->MNR_SYI$L_CPUTYPE = 0;			/* Otherwise, simply clear */

	 END;

    ELSE DO;						/* LIVE request */
							/* Fill the System Information Area from the running system */
	 SPTR->MNR_SYI$B_TYPE = UNSPEC(SYI_TYPE);	/* Get SYI type code */
	 SPTR->MNR_SYI$V_RESERVED1 = '0'B;		/* Clear reserved flag ... */
	 SPTR->MNR_SYI$V_FILLER = '0'B;			/* ... and all unused flags */
	 IF MPCHECK()					/* Multiprocessing capability? */
	     THEN SPTR->MNR_SYI$B_MPCPUS = 2;		/* Yes -- 2 cpu's */
	     ELSE SPTR->MNR_SYI$B_MPCPUS = 1;		/* No -- just 1 cpu */
	 SPTR->MNR_SYI$W_MAXPRCCT = SGN$GW_MAXPRCCT;	/* Get MAXPROCESSCNT SYSGEN parameter */
	 CALL = COMPUTE_BOOTTIME();			/* Get system time at boot into MNR_SYI$Q_BOOTTIME */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_UNEXPERR,CALL);	/* Yes -- log the error */
		  RETURN(MNR$_UNEXPERR);		/* ... and return with status */
		  END;

	 CALL = CLUS_NET_INFO();			/* Get cluster and network info (incl CPU type) into SYI */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_UNEXPERR,CALL);	/* Yes -- log the error */
		  RETURN(MNR$_UNEXPERR);		/* ... and return with status */
		  END;

	 SPTR->MNR_SYI$L_BALSETMEM = PFN$GL_PHYPGCNT;	/* Get balance set memory size (in pages) */
	 SPTR->MNR_SYI$L_MPWHILIM = MPW$GW_HILIM;	/* Get MPW_HILIMIT SYSGEN parameter */

	 END;

/*
/*	If PLAYBACK, read first class record from input file
/*	to "prime the pump."
/*/

IF M->MRB$V_PLAYBACK
    THEN DO;
	 CALL READ_INPUT(SKIP_TO_CLASS);		/* Set up first class record for COLLECTION_EVENT rtn */
	 IF MC->MCA$V_EOF				/* If end-of-file, */
	     THEN DO;
		  CALL MON_ERR(MNR$_PREMEOF);		/* Log the error */
	          RETURN (MNR$_PREMEOF);		/* ... and return to caller */
	          END;

/*
/*	If a future playback request, read input file, skipping
/*	past class records until file is positioned to requested
/*	begin point. Examine file time value only for the first
/*	class record within an interval, to ensure that the request
/*	will begin at an interval boundary. If end-of-file is hit
/*	during this operation, terminate the request with an error. 
/*/

	IF MC->MCA$V_FUTURE
	    THEN DO;
		 F = MC->MCA$A_INPUT_PTR;
		 DO WHILE (^ MC->MCA$V_EOF & QUAD_LT_QUAD(F->MNR_CLS$Q_STAMP,M->MRB$Q_BEGINNING));

		 READ FILE(INPUT_FILE) INTO(INPUT_DATA); /* Read rec following first class record */

		 DO WHILE (^ MC->MCA$V_EOF & F->MNR_CLS$B_TYPE ^= MC->MCA$B_FIRSTC);

		 READ FILE(INPUT_FILE) INTO(INPUT_DATA); /* Read until first class found again */

		 END;
		 END;
		 IF MC->MCA$V_EOF			/* EOF => bad beginning time */
		     THEN DO;
			  CALL MON_ERR(MNR$_BEGRAN);	/* Log the error */
			  RETURN(MNR$_BEGRAN);		/* ... and return with status */
			  END;
		 END;

	 MC->MCA$L_INPUT_LEN = LENGTH(INPUT_DATA);	/* Establish length of input */
	 END;

RETURN(NORMAL);						/* Return to caller */
END REQUEST_INIT;

RECORD_INIT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	RECORD_INIT
/*
/*	Called by EXECUTE_REQUEST to open the output (recording) file.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE PLI_FILE_DISPLAY;

Declare
  RECORD_EXPTR	POINTER,
  TEMP_PTR	POINTER,
  01 TEMP BASED(TEMP_PTR),
    02 L	FIXED BINARY(15),
    02 DC	FIXED BINARY(15),
    02 A	POINTER,
  TEMP_STR	CHAR(TEMP.L) BASED(TEMP.A);

RECCT = 0;						/* Init count of records written */
M->MRB$V_REC_CL_REQ = YES;				/* Indicate record cleanup is required */
CLOSE FILE(RECORD_FILE);				/* Make sure file is closed before opening */
TEMP_PTR = M->MRB$A_RECORD;				/* Set up ptr to output file name string */
OPEN FILE(RECORD_FILE) OUTPUT TITLE(TEMP_STR)		/* Open the output recording file */
     ENVIRONMENT(MAXIMUM_RECORD_SIZE(MAX_REC_SIZE),	/*  such that others may read it */
                 SHARED_READ);				
ALLOCATE PLI_FILE_DISPLAY SET (RECORD_EXPTR);		/* Allocate space for the DISPLAY output */
CALL DISPLAY (RECORD_FILE,RECORD_EXPTR->PLI_FILE_DISPLAY); /* Get the expanded file name */
RECORD_STR = RECORD_EXPTR->EXPANDED_TITLE;		/* Move the expanded string into global area for the module */
FREE RECORD_EXPTR->PLI_FILE_DISPLAY;			/* Release the storage area since the expanded string has been moved */

RETURN(NORMAL);
END RECORD_INIT;

MONITOR_REQUEST: Procedure Returns(Fixed Binary(31));

/*
/*	Execute first collection event. If live, collection events will
/*	continue at AST level.
/*/

IF ^ (MC->MCA$B_FIRSTC = PROCS_CLSNO & M->MRB$V_PLAYBACK) /* If not playback of PROCESSES */
    THEN DO;
	 CALL = SYS$DCLAST(COLLECTION_EVENT,,);		/* ... then execute first collection event */
	 IF STATUS = NOT_SUCCESSFUL			/* $DCLAST failure? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,DCLAST_STR); /* Yes -- log the error */
		  RETURN(MNR$_SSERROR);			/* ... and return with status */
		  END;
	 END;

/*
/*	Main monitoring loop. For playback, alternate collection and display events.
/*	For live, simply issue display events in a loop while collection events loop
/*	at AST level.
/*/

DO WHILE (COLLENDED = NO);				/* Loop while collection has not ended */
IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN DO;
	 CALL = SYS$DCLAST(COLLECTION_EVENT,,);		/* ... then execute a collection event */
	 IF STATUS = NOT_SUCCESSFUL			/* $DCLAST failure? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,DCLAST_STR); /* Yes -- log the error */
		  RETURN(MNR$_SSERROR);			/* ... and return with status */
		  END;
	 IF MC->MCA$V_MULTFND & M->MRB$V_DISPLAY	/* If multiple found and display requested, */
			      & COLL_STATUS = NORMAL	/* ... and collection_event finished OK, */
	     THEN DO;
		  CALL = DISPLAY_EVENT();		/* Execute a display event */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Return if bad status */

		  IF COLLENDED = NO & M->MRB$V_DISP_TO_FILE = NO /* If still collecting, and displaying to SYS$OUTPUT, */
		      THEN CALL = SYS$WFLOR(0,DISP_EV_FLAG_M | REFR_EV_FLAG_M);
							/* ... then wait for viewing time or refresh request */

		  END;
	 END;

    ELSE DO;						/* This is a LIVE request */
	 IF M->MRB$V_DISPLAY				/* If display requested */
	     THEN DO;
		  CALL = DISPLAY_EVENT();		/* ... then execute a display request */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Return if bad status */
		  END;

	 IF COLLENDED = NO				/* Wait -- If no display, will wait whole request, */
	     THEN CALL = SYS$WFLOR(0,DISP_EV_FLAG_M | REFR_EV_FLAG_M);

	 END;						/* ... while collection continues at AST level */
END;


/*
/*	End of main monitoring loop
/*/

RETURN(COLL_STATUS);					/* Return with status from COLLECTION_EVENT */

END MONITOR_REQUEST;

REQUEST_SUMMARY: Procedure Returns(Fixed Binary(31));

/*
/*	Since the MONITOR request has terminated (except for SUMMARY),
/*	certain CLEANUP routines may be executed now. Since SUMMARY
/*	output uses the same SYS$OUTPUT stream through the SCRPKG as
/*	DISPLAY output, DISPLAY_CLEANUP MUST be done now.
/*/

IF M->MRB$V_RECORD & M->MRB$V_REC_CL_REQ		/* If this is a RECORD request AND cleanup required, */
    THEN CALL = RECORD_CLEANUP();			/* ... then do record cleanup */
IF M->MRB$V_PLAYBACK & M->MRB$V_INP_CL_REQ		/* If this is a PLAYBACK request AND cleanup required, */
    THEN CALL = INPUT_CLEANUP();			/* ... then do cleanup for it */
IF M->MRB$V_DISPLAY & M->MRB$V_DIS_CL_REQ		/* If this is a DISPLAY request AND cleanup required, */
    THEN CALL = DISPLAY_CLEANUP();			/* ... then do display cleanup */

CALL = SUMMARY_INIT();					/* Perform summary init */
IF STATUS = NOT_SUCCESSFUL				/* Failed? */
    THEN DO;
	 CALL MON_ERR(MNR$_DISPERR,CALL);			/* Yes -- log the error */
	 RETURN(MNR$_DISPERR);					/* ... and return with status */
	 END;
CALL = SUMMARY_EVENT();					/* Perform summarization */
IF STATUS = NOT_SUCCESSFUL				/* If failed, then return with status */
    THEN RETURN(CALL);

RETURN(NORMAL);						/* Return to caller */

END REQUEST_SUMMARY;

DISPLAY_EVENT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	DISPLAY_EVENT
/*
/*	Called by EXECUTE_REQUEST to perform a single display event.
/*	One display event consists of creating and writing a screen
/*	image, including template if necessary, for a single class.
/*	The current class to be displayed is indicated within the
/*	DISPLAY_EVENT routine by the CURR_DCLASS variable. CURR_DCLASS
/*	is updated on each entry to DISPLAY_EVENT to indicate the
/*	next class in the list of requested classes. This causes the
/*	displays to cycle. DISPLAY_EVENT is entered once per viewing
/*	interval, or whenever a CTRL-W (screen refresh) is received.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
ADV_HOM_ITEM	ENTRY (POINTER);				/* MACRO-32 rtn to advance homog class to next display item */

Declare
EV_FLAGS	BIT(32) ALIGNED,				/* Cluster 0 event flags */
SS$_WASCLR	FIXED BINARY(31) GLOBALREF VALUE;		/* "Event flag clear" return status */

Declare
DCDB		POINTER STATIC,					/* CDB for current display class */
COLL_TIME	BIT(64) ALIGNED STATIC,				/* Time stamp from most recent collection */
TEMP		FIXED BINARY(15);				/* Temporary scratch "register" */

Declare
1 TIME_PARMS	STATIC,						/* FAOL parms for date and time lines */
  2 DATE_LEN	FIXED BINARY(31) INIT(11),			/* Length of date string */
  2 DATE_PTR	POINTER,					/* Pointer to date string */
  2 TIME_LEN	FIXED BINARY(31) INIT(8),			/* Length of time string */
  2 TIME_PTR	POINTER,					/* Pointer to time string */

DATE_OUT	CHAR(11) STATIC,				/* Date output string from ASCTIM */	
TIME_OUT	CHAR(8) STATIC,					/* Time output string from ASCTIM */	

1 TIME_STR	GLOBALREF,					/* Date/time FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1),					/* First character of string */

1 SYS_TIME_STR	GLOBALREF,					/* SYSTEM class date/time FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
DATA_STR	CHAR(1)	BASED(DCDB->CDB$A_FAOCTR),		/* First char of FAO ctr str for display data */
FAOSTK		FIXED BINARY(31) GLOBALREF;			/* First longword of FAOL parm list */

Declare
VIDEO_IND	BIT(1) ALIGNED;					/* Video terminal indicator */

CALL = SYS$READEF(DISP_EV_FLAG,EV_FLAGS);			/* Examine state of display event flag */
IF STATUS = NOT_SUCCESSFUL					/* Failed? */
    THEN DO;
	 CALL MON_ERR(MNR$_SSERROR,CALL,READEF_STR);		/* Yes -- log the error */
	 RETURN(MNR$_SSERROR);					/* ... and return with status */
	 END;

IF CALL = SS$_WASCLR						/* If display event flag was clear, */
    THEN DO;							/* (Assume this is a refresh event) */
	 CALL = SYS$CLREF(REFR_EV_FLAG);			/* Clear refresh event flag */
	 MC->MCA$V_REFRESH = YES;				/* ... and indicate this is a refresh display event */
	 IF STATUS = NOT_SUCCESSFUL				/* SYS$CLREF service call failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,CLREF_STR);	/* Yes -- log the error */
		  RETURN(MNR$_SSERROR);				/* ... and return with status */
		  END;
	 END;

IF CURR_DCLASS = 0 & (DISPLAYING = NO | MC->MCA$V_REFRESH = YES) /* If class data not yet displayed, AND */
								/* ... first time thru or refresh requested */
    THEN DO;
	 VIDEO_IND = MC->MCA$V_VIDEO;				/*...Get Video indicator */ 
	 CALL = DISP_TEMPLATE(D_CURR_CDBPTR(1),VIDEO_IND);	/* ... display a template for the first class, */
							   	/* ... forcing output to screen if video terminal */
	 DISPLAYING = YES;					/* Indicate that display output has begun */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);		/* Check call */
	 END;

IF CURR_DCLASS = MC->MCA$W_DCLASSCT				/* If did final class on previous entry, */
    THEN TEMP = 1;						/* ... then start over at first one */
    ELSE TEMP = CURR_DCLASS + 1;				/* ... otherwise, advance to next class */
IF MC->MCA$L_COLLCNT >= 2 | D_CURR_CLASS_NO(TEMP) = PROCS_CLSNO	/* If at least 2 collections have passed OR ... */
								/* ... this is the PROCESSES class, */
    THEN DO;
	 IF ^ REPT_TOP						/* If not the special TOP repeat, */
	     THEN IF ADVANCE_DCLASS() = YES			/* Test if display class should be advanced */
		      THEN CURR_DCLASS = TEMP;			/* ... and advance it accordingly */

	 DCDB = D_CURR_CDBPTR(CURR_DCLASS);			/* Get CDB for current display class */

	 IF MC->MCA$L_DISPCNT ^= 0 & (MC->MCA$V_REFRESH = YES | MC->MCA$W_DCLASSCT ^= 1) & ^ REPT_TOP
								/* If template not printed above, AND ... */
								/* ... refresh requested OR more than 1 class, */
								/* ... AND not the special TOP repeat */
	     THEN DO;
		  CALL = DISP_TEMPLATE(DCDB,NO);		/* Display template */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* Check call */
		  END;

	 REPT_TOP = NO;						/* Eliminate future TOP repeat */
	 IF MC->MCA$L_DISPCNT = 0 & D_CURR_CLASS_NO(CURR_DCLASS) = PROCS_CLSNO & DCDB->CDB$B_ST ^= REG_PROC
	     THEN REPT_TOP = YES;				/* If 1st TOP display, allow a 2nd consec TOP */

	 IF CTRLCZ_HIT = NO | M->MRB$V_DISP_TO_FILE THEN	/* If CTRL-C and Z not hit OR displaying to a file, */
	 DO;							/* ... then prepare to display actual data */
	 IF DCDB->CDB$V_HOMOG THEN CALL ADV_HOM_ITEM(DCDB);	/* If homog class, advance to next display item */
	 CALL = SYS$SETAST(DISABLE_AST);			/* Disable collection events while filling display buffer */
	 CALL = FILL_DISP_BUFF(DCDB,COLL_TIME);			/* Fill display buffer for this class */
	 CALL = SYS$SETAST(ENABLE_AST);				/* Re-enable collection events */

/*
/*	Call DISPLAY_PUT to first display the date and time of the most recent collection,
/*	then to display the actual data itself.
/*/

	 CALL = SYS$ASCTIM(,DATE_OUT,COLL_TIME,0);		/* Get ASCII date */
	 CALL = SYS$ASCTIM(,TIME_OUT,COLL_TIME,1);		/* Get ASCII time */	 
	 DATE_PTR = ADDR(DATE_OUT);				/* Address of date string into FAOL list */
	 TIME_PTR = ADDR(TIME_OUT);				/* Address of time string into FAOL list */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 IF DCDB->CDB$V_SYSCLS & DCDB->CDB$B_ST ^= ALL_STAT	/* If special SYSTEM screen, issue it one way, */
	     THEN DO;
		  PUT_LEN = SYS_TIME_STR.L;			/* Length of time control string */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SYS_TIME_STR.S,TIME_PARMS);
								/* Send date and time to SCRPKG */
		  END;
	     ELSE DO;						/* Otherwise issue it another way */
		  PUT_LEN = TIME_STR.L;				/* Length of time control string */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,TIME_STR.S,TIME_PARMS);
								/* Send date and time to SCRPKG */
		  END;
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

/*
/*	Put actual display data
/*/

	 IF DCDB->CDB$V_STD					/* Is this a standard class? */
	     THEN						/* Standard Class */
		  IF DCDB->CDB$V_HOMOG				/* Check type of standard class */
		      THEN DO;					/* Homogeneous Standard Class */
			   CALL = DISPLAY_HOMOG(DCDB);		/* Send homog data display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
		      ELSE DO;					/* Heterogeneous Standard Class */
			   FAOL_REQUESTED = YES;		/* Run it through FAOL */
			   OUTP_REQUESTED = YES;		/* Output it now */
			   CALL = DISPLAY_PUT(DPUT_FLAGS,DCDB->CDB$L_FAOCTR,DATA_STR,FAOSTK);
								/* Send display data to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */
			   END;
	     ELSE						/* Non-standard Class (PROCESSES) */
		  IF DCDB->CDB$B_ST = REG_PROC
		      THEN DO;					/* Regular PROCESSES display */
			   CALL = DISPLAY_PROCS(DCDB,COLL_TIME);         /* Send process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
		      ELSE DO;					/* TOP PROCESSES display */
			   CALL = DISPLAY_TOP(DCDB);		/* Send top process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
	 MC->MCA$L_DISPCNT = MC->MCA$L_DISPCNT + 1;		/* Count this display event */
	 END;
	 END;

IF MC->MCA$V_REFRESH THEN CALL = SYS$CANTIM(DISP_EV_FLAG,);	/* If a refresh event, cancel "regular" display timer */

IF COLLENDED = NO & ^ (M->MRB$V_PLAYBACK & M->MRB$V_DISP_TO_FILE)
								/* If collection still going, ... */
								/* ... AND not playing back to a file, */
    THEN DO;
	 CALL = SYS$SETIMR(DISP_EV_FLAG,VIEWING_DEL,,DISP_EV_FLAG); /* Set flag when ready to display again */
	 IF STATUS = NOT_SUCCESSFUL				/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,SETIMR_STR);	/* Yes -- log the error */
		  RETURN(MNR$_SSERROR);				/* ... and return with status */
		  END;
	 END;

MC->MCA$V_REFRESH = NO;						/* Indicate not a refresh display event for next time */

RETURN(NORMAL);


ADVANCE_DCLASS: Procedure Returns(Bit(1) aligned);		/* Test if display class should be advanced */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	ADVANCE_DCLASS
/*
/*	This routine checks whether the current display class
/*	(as indicated in the variable CURR_DCLASS) should be
/*	advanced to the next requested class, or left where
/*	it is. Normally, the class is advanced, but in the case
/*	where the current class is homogeneous and not yet at
/*	the end of its item list, the class is not advanced.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	YES if the current display class should be advanced.
/*	NO  otherwise
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  ADVANCE_CLASS	BIT(1) ALIGNED,				/* YES => advance display class */
  RCDB		POINTER;				/* CDB pointer for most recent class */

ADVANCE_CLASS = YES;					/* Assume class will be advanced */
IF CURR_DCLASS ^= 0					/* If not the first display event, */
    THEN DO;
	 RCDB = D_CURR_CDBPTR(CURR_DCLASS);		/*   get CDB addr for most recent display event */
	 IF RCDB->CDB$V_HOMOG				/*   check if it is a homogeneous class */
	     THEN IF RCDB->CDB$A_CDX->CDX$B_IDISCONSEC < RCDB->CDB$A_CDX->CDX$B_IDISCT /* All items displayed? */
		      THEN ADVANCE_CLASS = NO;					       /* No -- don't advance */
	 END;

RETURN(ADVANCE_CLASS);					/* Return with indicator */

END ADVANCE_DCLASS;

END DISPLAY_EVENT;

SUMMARY_EVENT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	SUMMARY_EVENT
/*
/*	Called by EXECUTE_REQUEST once per request to create a
/*	summary file containing a screen image for each of the
/*	requested classes.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
SUMMARY_TOP	ENTRY (POINTER)					/* MACRO-32 rtn to set up for TOP summary */
		RETURNS (FIXED BINARY(31)),
ADV_HOM_ITEM	ENTRY (POINTER);				/* MACRO-32 rtn to advance homog class to next display item */

Declare
DCDB		POINTER STATIC,					/* CDB for current display class */
COLL_TIME	BIT(64) ALIGNED STATIC;				/* Time stamp from most recent collection */

Declare
1 SUMM_PARMS	STATIC,						/* FAOL parms for summary beg and end date/times */
  2 BEG_LEN	FIXED BINARY(31) INIT(20),			/* Length of beginning date/time string */
  2 BEG_PTR	POINTER,					/* Pointer to beginning date/time string */
  2 END_LEN	FIXED BINARY(31) INIT(20),			/* Length of ending date/time string */
  2 END_PTR	POINTER,					/* Pointer to ending date/time string */

BEG_OUT	CHAR(23) STATIC,					/* Beg date/time output string from ASCTIM */	
END_OUT	CHAR(23) STATIC,					/* End date/time output string from ASCTIM */	

1 SUMMLINE_STR	GLOBALREF,					/* Summary date/time FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1),					/* First character of string */

1 SYS_SUMMLINE_STR	GLOBALREF,				/* Summary date/time FAO control string for SYSTEM class */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
DATA_STR	CHAR(1)	BASED(DCDB->CDB$A_FAOCTR),		/* First char of FAO ctr str for display data */
FAOSTK		FIXED BINARY(31) GLOBALREF;			/* First longword of FAOL parm list */

DO CURR_DCLASS = 1 TO MC->MCA$W_DCLASSCT			/* Loop once for each requested class */
   WHILE (MC->MCA$L_COLLCNT >= 2);				/* ... but only if at least 2 collections */

	 DCDB = D_CURR_CDBPTR(CURR_DCLASS);			/* Get CDB for current display class */
	 CALL = DISP_TEMPLATE(DCDB,NO);				/* Send template to SCRPKG, but don't output yet */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);		/* Check call */
	 IF (D_CURR_CLASS_NO(CURR_DCLASS) = PROCS_CLSNO		/* If PROCESSES Class with TOP screen, */
	    & DCDB->CDB$B_ST ^= REG_PROC)
	    | (DCDB->CDB$V_SYSCLS & DCDB->CDB$B_ST ^= ALL_STAT)	/* ... OR SYSTEM class with single stat, */

	     THEN CALL = SUMMARY_TOP(DCDB);			/* ... then do TOP setup */

	 IF DCDB->CDB$V_HOMOG					/* If homogeneous class, */
	     THEN DO;
		  DCDB->CDB$A_CDX->CDX$B_IDISCONSEC = 0;	/* Init consec display item number */
		  DO WHILE(DCDB->CDB$A_CDX->CDX$B_IDISCONSEC < DCDB->CDB$A_CDX->CDX$B_IDISCT);

		  CALL ADV_HOM_ITEM(DCDB);			/* Advance to next display item */
		  CALL = SUMM_ONE_CLASS();			/* Summarize once for each item */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* Check call */
		  END;
		  END;

	     ELSE DO;						/* Heterogeneous class or PROCESSES */
		  CALL = SUMM_ONE_CLASS();			/* Only need to call once */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* Check call */
		  END;

END;

RETURN(NORMAL);							/* Return */

SUMM_ONE_CLASS: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	SUMM_ONE_CLASS
/*
/*	Called by SUMMARY_EVENT to put screen images to the
/*	summary file for a single class. For heterogeneous
/*	classes, a single screen image is required. For
/*	other classes, multiple screen images may be
/*	required.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/


	 CALL = FILL_DISP_BUFF(DCDB,COLL_TIME);			/* Fill display buffer for this class */

/*
/*	Call DISPLAY_PUT to first display the summary time range,
/*	then to display the actual data itself.
/*/

	 CALL = SYS$ASCTIM(,BEG_OUT,M->MRB$Q_BEGINNING,0);	/* Get ASCII beginning time */
	 CALL = SYS$ASCTIM(,END_OUT,COLL_TIME,0);		/* Get ASCII ending time */	 
	 BEG_PTR = ADDR(BEG_OUT);				/* Address of beg string into FAOL list */
	 END_PTR = ADDR(END_OUT);				/* Address of end string into FAOL list */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 IF DCDB->CDB$V_SYSCLS & DCDB->CDB$B_ST ^= ALL_STAT	/* If special SYSTEM screen, issue it a special way, */
	     THEN DO;
		 PUT_LEN = SYS_SUMMLINE_STR.L;			/* Length of SYSTEM summary control string */
	 	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SYS_SUMMLINE_STR.S,SUMM_PARMS);
								/* Send summary line to SCRPKG */
		 END;
	    ELSE DO;						/* else issue it the normal way */
		 PUT_LEN = SUMMLINE_STR.L;			/* Length of summary control string */
	 	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SUMMLINE_STR.S,SUMM_PARMS);
		 						/* Send summary line to SCRPKG */
		 END;
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

/*
/*	Put actual display data
/*/

	 IF DCDB->CDB$V_STD					/* Is this a standard class? */
	     THEN						/* Standard Class */
		  IF DCDB->CDB$V_HOMOG				/* Check type of standard class */
		      THEN DO;					/* Homogeneous Standard Class */
			   CALL = DISPLAY_HOMOG(DCDB);		/* Send homog data display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
		      ELSE DO;					/* Heterogeneous Standard Class */
			   FAOL_REQUESTED = YES;		/* Run it through FAOL */
			   OUTP_REQUESTED = YES;		/* Output it now */
			   CALL = DISPLAY_PUT(DPUT_FLAGS,DCDB->CDB$L_FAOCTR,DATA_STR,FAOSTK);
								/* Send display data to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */
			   END;
	     ELSE						/* Non-standard Class (PROCESSES) */
		  IF DCDB->CDB$B_ST = REG_PROC
		      THEN DO;					/* Regular PROCESSES display */
			   CALL = DISPLAY_PROCS(DCDB,COLL_TIME);         /* Send process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
		      ELSE DO;					/* TOP PROCESSES display */
			   CALL = DISPLAY_TOP(DCDB);		/* Send top process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;

	 RETURN(NORMAL);

	 END SUMM_ONE_CLASS;

END SUMMARY_EVENT;

SAVE_SUM_BUFFS:	Procedure Returns(Fixed Binary(31));		/* Save SUM buffers into M.F. Summary Buffer */
								/* ... for all classes for the current input file */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	SAVE_SUM_BUFFS
/*
/*	Called by EXECUTE_REQUEST once per request to save the
/*	SUM buffers of all classes into their respective Multi-File
/*	Summary Blocks.
/*
/* IMPLICIT INPUTS:
/*
/*	MFSPTR -- Pointer to MFS (Multi-File Summary Block)
/*
/*	MFS$B_CUR_COL -- column number for column (on m.f. summary report) into which the
/*		  	 data from the SUM buffers will be stored.
/*
/*	DISPLAY_CLASSES -- 128-bit string of classes to be summarized (excludes STATES, MODES
/*				and PROCESSES if they are present only in support of SYSTEM).
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
COL_NO		FIXED BINARY(7);				/* Column number to store sums into */

Declare
ALLOC_SUMBUFS	ENTRY(BIT(128) ALIGNED)				/* MONITOR MACRO-32 rtn to allocate m.f. summary buffers */
		RETURNS (FIXED BINARY(31)),
CAPTURE_SUMS	ENTRY (POINTER, FIXED BINARY(7))		/* MACRO-32 routine to move SUM buffer to M.F. Summary Buffer */
		RETURNS (FIXED BINARY(31)),
ADV_HOM_ITEM	ENTRY (POINTER);				/* MACRO-32 rtn to advance homog class to next display item */

Declare
DCDB		POINTER STATIC;					/* CDB for current class */

Declare
DISPLAY_CLASSES BIT(128) ALIGNED GLOBALREF;			/* Classes to be summarized */


CALL = ALLOC_SUMBUFS(DISPLAY_CLASSES);				/* Allocate m.f. summary buffers (if not done yet) */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);			/* Check call */

COL_NO = MFS$B_CUR_COL;						/* Get number of column currently being processed */

DO CURR_DCLASS = 1 TO MC->MCA$W_DCLASSCT;			/* Loop once for each summarized class */

	 DCDB = D_CURR_CDBPTR(CURR_DCLASS);			/* Get CDB for current class */

	 IF DCDB->CDB$L_ECOUNT ^= 0				/* If we have some elements, */
	     THEN DO;
		  CALL = CAPTURE_SUMS(DCDB,COL_NO);		/* Capture SUM buffer for this class and "column" */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* Check call */
		  END;

END;

RETURN(NORMAL);							/* Return */

END SAVE_SUM_BUFFS;

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CLEANUP Routines. RECORD_CLEANUP, SUMMARY_CLEANUP
/*			  INPUT_CLEANUP, and DISPLAY_CLEANUP
/*
/*	Called by EXECUTE_REQUEST to close files, reset terminal
/*	characteristics, and release associated resources.
/*	INPUT_CLEANUP can also be called by MFSUM_REQUEST to close
/*	an input file and free the allocated buffer memory.
/*	SUMMARY_CLEANUP can also be called by MFSUM_REQUEST to close
/*	the summary file.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

REQUEST_CLEANUP: Procedure;

Declare
FREE_MEM	ENTRY RETURNS(FIXED BINARY(31));	/* MONITOR MACRO-32 routine to issue LIB$FREE_VM's */


CALL = FREE_MEM();					/* Free virtual memory acquired for this request */

IF M->MRB$V_RECORD & M->MRB$V_REC_CL_REQ		/* If this is a RECORD request AND cleanup required, */
    THEN CALL = RECORD_CLEANUP();			/* ... then do record cleanup */
IF M->MRB$V_PLAYBACK & M->MRB$V_INP_CL_REQ		/* If this is a PLAYBACK request AND cleanup required, */
    THEN CALL = INPUT_CLEANUP();			/* ... then do cleanup for it */
IF M->MRB$V_DISPLAY & M->MRB$V_DIS_CL_REQ		/* If this is a DISPLAY request AND cleanup required, */
    THEN CALL = DISPLAY_CLEANUP();			/* ... then do display cleanup */
IF M->MRB$V_SUMMARY & M->MRB$V_SUM_CL_REQ		/* If this is a SUMMARY request AND cleanup required, */
    THEN CALL = SUMMARY_CLEANUP();			/* ... then do summary cleanup */

RETURN;
END REQUEST_CLEANUP;


RECORD_CLEANUP: Procedure Returns(fixed binary(31));

Declare
  H		POINTER;				/* Pointer to file header record */

M->MRB$V_REC_CL_REQ = NO;				/* Indicate record cleanup is no longer required */
CLOSE FILE(RECORD_FILE);				/* Close the record file */
IF RECCT > 0						/* If file is non-empty, */
    THEN DO;						/* ... then want to re-write the header */
	 OPEN FILE(RECORD_FILE) UPDATE TITLE(RECORD_STR) /* Re-open it to re-write header while */
	      ENVIRONMENT(SHARED_READ);			/*  allowing others to read the file */
	 READ FILE(RECORD_FILE) SET(H);			/* Read header record */
	 H->MNR_HDR$Q_ENDING = M->MRB$Q_ENDING;		/* Update the ending time */
	 H->MNR_HDR$L_RECCT = RECCT;			/* ... and the record count */
	 REWRITE FILE(RECORD_FILE);			/* Re-write the header record */
	 CLOSE FILE(RECORD_FILE);			/* ... and close it up again */
	 END;

RETURN(NORMAL);						/* Return */
END RECORD_CLEANUP;

END EXECUTE_REQUEST;

SUMMARY_CLEANUP: Procedure Returns(fixed binary(31));

%INCLUDE	MONDEF;					/* Monitor utility structure definitions */

Declare
LIB$SET_BUFFER	ENTRY (ANY VALUE),			/* Rtn to set and clear buffer mode for the SCRPKG */
SCR$SET_CURSOR	ENTRY (ANY VALUE, ANY VALUE),		/* SCRPKG rtn to set the cursor position */
SCR$UP_SCROLL	ENTRY,					/* SCRPKG rtn to scroll up one line */
SCR$STOP_OUTPUT	ENTRY;					/* Rtn to stop SCRPKG output stream */

Declare
  NORMAL	FIXED BINARY(31) GLOBALREF,		/* MONITOR normal status value */
  MRBPTR	POINTER GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
  M		POINTER DEFINED(MRBPTR),		/* Synonym for MRBPTR */

1 BOT_CURS	GLOBALREF,				/* Place cursor on bottom of screen */
  2 L		FIXED BINARY(7),			/* Length */
  2 S		CHAR(1),				/* First character of string */

SFSPEC		CHAR(8) BASED;				/* Dummy summary file spec descriptor */

M->MRB$V_SUM_CL_REQ = NO;				/* Indicate summary cleanup is no longer required */
CALL LIB$SET_BUFFER(0);					/* Indicate "clear buffer mode" to SCRPKG */
							/* ... and output what's left in the buffer */
CALL SCR$SET_CURSOR(24,1);				/* Place cursor on bottom line, */
CALL SCR$UP_SCROLL();					/* ... and scroll up one line */
CALL SCR$STOP_OUTPUT();					/* Stop output stream and close summary file */
RETURN(NORMAL);						/* Return */
END SUMMARY_CLEANUP;


INPUT_CLEANUP: Procedure Returns(fixed binary(31));

%INCLUDE	MONDEF;					/* Monitor utility structure definitions */

Declare
  MAX_REC_SIZE	FIXED BINARY(31) GLOBALREF VALUE,	/* Max record size for PLAYBACK & RECORD files */
  NORMAL	FIXED BINARY(31) GLOBALREF,		/* MONITOR normal status value */
  MRBPTR	POINTER GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
  M		POINTER DEFINED(MRBPTR),		/* Synonym for MRBPTR */
  INPUT_CPTR	POINTER GLOBALREF,			/* Ptr to input buffer count word */
  INPUT_DATA	CHAR(MAX_REC_SIZE) VARYING BASED(INPUT_CPTR);	/* Playback file input buffer */

Declare
  INPUT_FILE		FILE RECORD INPUT;		/* Monitor Input (Playback) File */

M->MRB$V_INP_CL_REQ = NO;				/* Indicate input cleanup is no longer required */
CLOSE FILE(INPUT_FILE);					/* Close the input file */
IF INPUT_CPTR ^= NULL()					/* If input buffer had been acquired */
    THEN FREE INPUT_CPTR->INPUT_DATA;			/* ... then free it */
RETURN(NORMAL);						/* Return */
END INPUT_CLEANUP;

DISPLAY_CLEANUP: Procedure Returns(fixed binary(31));

%INCLUDE	MONDEF;					/* Monitor utility structure definitions */

Declare
DISPLAYING	BIT(1) ALIGNED	GLOBALREF,		/* YES=> display output is active */
CTRLZ_HIT	BIT(1) ALIGNED	GLOBALREF,		/* YES=> CTRL/Z has been hit */
NORMAL		FIXED BINARY(31) GLOBALREF, 		/* MONITOR normal return status */
MRBPTR		POINTER		GLOBALREF,		/* Pointer to MRB (Monitor Request Block) */
M		POINTER	DEFINED(MRBPTR);		/* Synonym for MRBPTR */

Declare
LIB$SET_BUFFER	ENTRY (ANY VALUE),			/* Rtn to set and clear buffer mode for the SCRPKG */
PUT_TO_SCREEN	ENTRY (ANY VALUE, ANY),			/* Rtn to put an arbitrary buffer to the SCRPKG */
SCR$SET_CURSOR	ENTRY (ANY VALUE, ANY VALUE),		/* SCRPKG rtn to set the cursor position */
SCR$ERASE_PAGE	ENTRY (ANY VALUE, ANY VALUE),		/* SCRPKG rtn to home the cursor & clear the entire screen */
SCR$UP_SCROLL	ENTRY,					/* SCRPKG rtn to scroll up one line */
SCR$STOP_OUTPUT	ENTRY;					/* Rtn to stop SCRPKG output stream */

Declare
1 FIN_SEQ	GLOBALREF,				/* Finish escape sequence for display terminal */
  2 L		FIXED BINARY(7),			/* Length */
  2 S		CHAR(1),				/* First character of string */

1 BOT_CURS	GLOBALREF,				/* Place cursor on bottom of screen */
  2 L		FIXED BINARY(7),			/* Length */
  2 S		CHAR(1),				/* First character of string */

DFSPEC		CHAR(8) BASED;				/* Dummy display file spec descriptor */

M->MRB$V_DIS_CL_REQ = NO;				/* Indicate display cleanup is no longer required */
CALL LIB$SET_BUFFER(0);					/* Indicate "clear buffer mode" to SCRPKG */
							/* ... and output what's left in the buffer */
CALL PUT_TO_SCREEN(FIN_SEQ.L,FIN_SEQ.S);		/* Call SCRPKG for finish sequence, */
IF DISPLAYING = YES					/* If actual output has begun, */
    THEN DO;
	 DISPLAYING = NO;				/* Indicate display output has stopped, */
	 CALL SCR$SET_CURSOR(24,1);			/* ... place cursor on bottom line, */
	 CALL SCR$UP_SCROLL();				/* ... and scroll up one line */
	 END;
CALL SCR$STOP_OUTPUT();					/* Stop output stream if present */
RETURN(NORMAL);						/* Return */
END DISPLAY_CLEANUP;

INPUT_INIT: Procedure Returns(Fixed Binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	INPUT_INIT
/*
/*	Called by REQUEST_INIT or MFSUM_REQUEST to open the input
/*	(playback) file, performing various sanity checks on it.
/*
/* IMPLICIT INPUTS:
/*
/*	MRBPTR (or M) points to active MRB. In particular, MRB$A_INPUT
/*	points to string descriptor of file-spec to be opened.
/*
/* IMPLICIT OUTPUTS:
/*
/*	Input file has been opened.
/*	H and MCA$A_INPUT_PTR both point to first data byte of header record.
/*	MCA$L_INPUT_LEN contains length of header record.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/* SIDE EFFECTS:
/*
/*	/INPUT file (INPUT_FILE) is positioned to the file header record.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			     MESSAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MNR$_PREMEOF	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_INVINPFIL	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_UNSTLEV	FIXED BINARY(31) GLOBALREF VALUE;

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  MON_ERR	ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),	/* MONITOR MACRO-32 routine to log synchronous errors */
  MAX_REC_SIZE	FIXED BINARY(31) GLOBALREF VALUE,	/* Max record size for PLAYBACK & RECORD files */
  NORMAL	FIXED BINARY(31) GLOBALREF,		/* MONITOR normal status value */
  MRBPTR	POINTER GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
  M		POINTER DEFINED(MRBPTR),		/* Synonym for MRBPTR */
  MCAPTR	POINTER GLOBALREF,			/* Pointer to MCA (Monitor Communication Area) */
  MC		POINTER DEFINED(MCAPTR),		/* Synonym for MCAPTR */
  H		POINTER GLOBALREF,			/* Pointer to input file header */
  ST_LEVEL_CUR	CHAR(8)	GLOBALREF,			/* Current MONITOR recording file structure level */
  ST_LEVEL_PB	CHAR(8)	GLOBALDEF,			/* MONITOR recording file structure level from input file */
  NEXT_REC	FIXED BINARY(31) GLOBALREF VALUE,	/* Read next record indicator for READ_INPUT rtn */
  HEADER_TYPE	FIXED BINARY(15) GLOBALREF,		/* Type for MONITOR recording file header */
  INPUT_CPTR	POINTER GLOBALREF,			/* Ptr to input buffer count word */
  INPUT_DATA	CHAR(MAX_REC_SIZE) VARYING BASED(INPUT_CPTR);	/* Playback file input buffer */

Declare
  INPUT_FILE		FILE RECORD INPUT;		/* Monitor Input (Playback) File */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare

  TEMP_TYPE	BIT(8) ALIGNED,					/* Temporary area for record type byte */
  TEMP_PTR	POINTER,
  01 TEMP BASED(TEMP_PTR),
    02 L	FIXED BINARY(15),
    02 DC	FIXED BINARY(15),
    02 A	POINTER,
  TEMP_STR	CHAR(TEMP.L) BASED(TEMP.A);

Declare
  TEMP_INPUT_PTR FIXED BINARY(31) BASED(ADDR(MC->MCA$A_INPUT_PTR)); /* Alias for MCA$A_INPUT_PTR for computation */ 


M->MRB$V_INP_CL_REQ = YES;				/* Indicate input cleanup is required */
CLOSE FILE(INPUT_FILE);					/* Make sure file is closed before opening */
INPUT_CPTR = NULL();					/* Indicate no input buffer yet */
TEMP_PTR = M->MRB$A_INPUT;				/* Set up ptr to input file name string */
OPEN FILE(INPUT_FILE) TITLE(TEMP_STR)			/* Open the input recording file for playback */
    ENVIRONMENT(SHARED_WRITE);				/*  and shared read (but have to use SHARED_WRITE) */
ALLOCATE INPUT_DATA;					/* Allocate space for input buffer (for life of request) */
MC->MCA$A_INPUT_PTR = INPUT_CPTR;			/* Get ptr to first byte of input buffer */
TEMP_INPUT_PTR = TEMP_INPUT_PTR + 2;			/* Advance ptr beyond length word */
CALL READ_INPUT(NEXT_REC);				/* Read first (file header) record */
IF MC->MCA$V_EOF					/* If end-of-file, */
    THEN DO;
	 CALL MON_ERR(MNR$_PREMEOF);			/* Can't find file header; log the error */
         RETURN (MNR$_PREMEOF);				/* ... and return to caller */
         END;

H = MC->MCA$A_INPUT_PTR;				/* Establish ptr to file header */
TEMP_TYPE = UNSPEC(HEADER_TYPE);			/* Get header type into a byte for compare */
IF H->MNR_HDR$B_TYPE ^= TEMP_TYPE |			/* If first record is not a file header or ... */
   SUBSTR(H->MNR_HDR$T_LEVEL,1,3) ^= SUBSTR(ST_LEVEL_CUR,1,3) /* ... MONITOR ID is not OK, */
    THEN DO;
	 CALL MON_ERR(MNR$_INVINPFIL);			/* Log an error */
	 RETURN(MNR$_INVINPFIL);			/* ... and return to caller */
	 END;

IF SUBSTR(H->MNR_HDR$T_LEVEL,7,2) ^= SUBSTR(ST_LEVEL_CUR,7,2) /* If format level is not OK, */
    THEN DO;
	 CALL MON_ERR(MNR$_UNSTLEV);			/* Log an error */
	 RETURN(MNR$_UNSTLEV);				/* ... and return to caller */
	 END;

ST_LEVEL_PB = H->MNR_HDR$T_LEVEL;			/* Save playback structure level */

RETURN(NORMAL);
END INPUT_INIT;

DISP_TEMPLATE: Procedure (DCDB, OUTPUT_IND)
			 Returns(Fixed Binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	DISP_TEMPLATE
/*
/*	Called by DISPLAY_EVENT, SUMMARY_EVENT and PUT_SUMM_PAGE to
/*	form and write a template for the indicated class. The template
/*	consists of everything on the screen except actual data. This
/*	includes the first 7 lines of the screen, the footing line and
/*	the line item identifiers. If a bar graph has been requested,
/*	the graph box is also included.
/*
/* INPUTS:
/*
/*	DCDB	    -- Pointer to the CDB (Class Descriptor Block) 
/*			of the class to be displayed.
/*
/*	OUTPUT_IND  -- Output indicator bit. If set, DISP_TEMPLATE
/*			sends terminal display commands to the SCRPKG
/*			and requests it to output to the screen. If
/*			OUTPUT_IND is not set, DISP_TEMPLATE sends
/*			terminal display commands to the SCRPKG, but
/*			does not request immediate screen output.
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL ROUTINE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),	/* MONITOR MACRO-32 routine to log synchronous errors */
TEMPLATE	ENTRY(POINTER VALUE)				/* BLISS rtn to output template */
		RETURNS(FIXED BINARY(31)),
SCR$SET_CURSOR	ENTRY (ANY VALUE, ANY VALUE),			/* SCRPKG rtn to set the cursor position */
DISPLAY_PUT	ENTRY(ANY, FIXED BINARY(31), ANY, ANY)		/* MACRO-32 rtn to put a display string */
		OPTIONS(VARIABLE)
		RETURNS(FIXED BINARY(31));

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			     MESSAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MNR$_DISPERR	FIXED BINARY(31) GLOBALREF VALUE;


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	NOT_SUCCESSFUL		BY '0'B;		/* Failing status bit */
%REPLACE 	YES			BY '1'B;		/* For general use */
%REPLACE 	NO			BY '0'B;		/* For general use */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
VTWIDTH		FIXED BINARY(31) GLOBALREF VALUE,		/* Width of video terminal */
VTHEIGHT	FIXED BINARY(31) GLOBALREF VALUE;		/* Height of video terminal */

Declare
CDBPTR			POINTER GLOBALREF,			/* Pointer to CDB (Class Descriptor Block) */
C			POINTER DEFINED(CDBPTR),		/* Synonym for CDBPTR */
MRBPTR			POINTER GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
M			POINTER DEFINED(MRBPTR),		/* Synonym for MRBPTR */
MCAPTR			POINTER GLOBALREF,			/* Pointer to MCA (Monitor Communication Area) */
MC			POINTER DEFINED(MCAPTR),		/* Synonym for MCAPTR */
SPTR			POINTER GLOBALREF;			/* Pointer to SYI (System Information Area) */

Declare
NORMAL		FIXED BINARY(31) GLOBALREF;			/* MONITOR normal return status */

Declare
INP_COMM_STR	CHAR(MNR_HDR$K_MAXCOMLEN) GLOBALREF,		/* User comment string from input file */
INP_COMM_LEN	FIXED BINARY(15) GLOBALREF;			/* Actual length of comment string */

Declare
1 ANNCE_STR	GLOBALREF,					/* Announcement FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 STATUS_STR	GLOBALREF,					/* Status FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1),					/* First character of string */
STATUS_PARMS	CHAR(12) GLOBALREF;				/* 3 longword FAOL parms for status display */

Declare
1 TABHEAD_STR	GLOBALREF,					/* Tabular heading control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1),					/* First character of string */
TABHEAD_PARM	POINTER STATIC,					/* FAOL parm indicating % or blank */
PCENT_STR	CHAR(2) GLOBALREF,				/* Percent symbol cstring */
BLANK_STR	CHAR(2) GLOBALREF;				/* Blank character cstring */

Declare
1 PROCHEAD_STR	GLOBALREF,					/* PROCESSES heading control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 MF_STATHEAD_STR GLOBALREF,					/* M.F. summary statistic heading control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CALL		FIXED BINARY(31) STATIC,			/* Holds function value (return status) of called routines */ 
STATUS		BIT(1)	BASED(ADDR(CALL));			/* Low-order status bit for called routines */

Declare
1 DPUT_FLAGS,							/* DISPLAY_PUT routine flags */
  2 FAOL_REQUESTED BIT(8) ALIGNED,				/* YES => Xlate buffer with FAOL first */
  2 OUTP_REQUESTED BIT(8) ALIGNED, 				/* YES => Really output buffer */
PUT_LEN		FIXED BINARY(31);				/* Length of buffer for DISPLAY_PUT to put */

Declare
DCDB		POINTER,					/* Pointer to current display class CDB */
OUTPUT_IND	BIT(1) ALIGNED,					/* YES => output the template */
I		FIXED BINARY(15);				/* Index for DO loop */

Declare
SPEC_SYSTEM_SCREEN BIT(1) ALIGNED;				/* YES => special screen for SYSTEM class */

Declare
1 TITLE_PARMS	STATIC,						/* FAOL parms for title display line */
  2 BLANKS	FIXED BINARY(31),				/* Number of preceding blanks */
  2 TITLE_PTR	POINTER,					/* Pointer to title cstring */
  2 PCENT_WID	FIXED BINARY(31),				/* Width of percent string (0 or 4) */
  2 NODE_PTR	POINTER,					/* Pointer to DECnet node name cstring */
TITLE_LEN	FIXED BINARY(7) BASED(TITLE_PTR),		/* Length of title string */
NODE_LEN	FIXED BINARY(7) BASED(NODE_PTR),		/* Length byte of node name cstring */
1 TITLE_STR	GLOBALREF,					/* Title FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 COMM_PARMS	STATIC,						/* FAOL parms for comment display line */
  2 BLANKS	FIXED BINARY(31),				/* Number of preceding blanks */
  2 COMM_LEN	FIXED BINARY(31),				/* Length of comment */
  2 COMM_ADDR	POINTER,					/* Address of comment string */
1 COMM_STR	GLOBALREF,					/* Comment FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 SYS_HEAD_PARMS STATIC,					/* FAOL parms for SYSTEM heading line */
  2 SYS_NODE_PTR  POINTER,					/* Pointer to DECnet node name cstring */
  2 STATLONG_LEN  FIXED BINARY(31) INIT(7),			/* Length of requested stat */
  2 STATLONG_ADDR POINTER,					/* Addr of requested stat */

1 SYS_HEAD_STR	GLOBALREF,					/* SYSTEM class heading control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1),					/* First character of string */

STAT_LONG (4)		CHAR(7) GLOBALREF,			/* Table of 7-char statistic strings */
SYS_BOX_STR_ADDR	POINTER GLOBALREF,			/* Address of screen box string */
SYS_BOX_STR		CHAR(1)	BASED(SYS_BOX_STR_ADDR),	/* SYSTEM screen boxes (1st char) */
SYS_BOX_STR_LEN		FIXED BINARY(15) GLOBALREF,		/* Its length */
SYS_TEXT_STR		CHAR(1) GLOBALREF,			/* SYSTEM screen text */
SYS_TEXT_STR_LEN	FIXED BINARY(15) GLOBALREF,		/* Its length */
SYS_FAO_STR		CHAR(1) GLOBALREF,			/* SYSTEM FAO string */
SYS_FAO_STR_LEN		FIXED BINARY(15) GLOBALREF;		/* Its length */

Declare
1 SYS_BOX_PARMS,						/* FAOL parms for SYSTEM screen boxes */
  2 SBP1	FIXED BINARY(31),				/* Free List bar range value */
  2 SBP2	POINTER,					/* Pointer to "K" or null cstring */
  2 SBP3	FIXED BINARY(31),				/* Mod List bar range value */
  2 SBP4	POINTER;					/* Pointer to "K" or null cstring */

Declare
1 BU_SYS_SINGLE		GLOBALREF,				/* Bar graph range values for SYSTEM class (single stat) */
  2 BSS_RANGE (1:17)	FIXED BINARY(31),
K_STR			CHAR(2) GLOBALREF,			/* K symbol for box */
NULL_STR		FIXED BINARY(15) INIT(0);		/* Dummy null symbol for box */


MC->MCA$V_ERA_SCRL = NO;			/* Indicate no need to erase scrolling region ... */
						/* ... (display area) for PROCESSES and homogs */
IF DCDB->CDB$V_HOMOG
    THEN DCDB->CDB$A_CDX->CDX$L_PREV_DCT = 0; /* Init count of previous display elements ... */
						/* ... for homogeneous class */

IF DCDB->CDB$V_SYSCLS & DCDB->CDB$B_ST ^= ALL_STAT /* If special SYSTEM screen, */
    THEN SPEC_SYSTEM_SCREEN = YES;		/* Set a bit for quick reference */
    ELSE SPEC_SYSTEM_SCREEN = NO;		/* Otherwise, turn it off */


/*
/*	Send announcement string to SCRPKG via DISPLAY_PUT routine
/*	This string is independent of screen style.
/*/

PUT_LEN = ANNCE_STR.L;				/* Get length of this put */
FAOL_REQUESTED = NO;				/* No need to go thru $FAOL */
OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,ANNCE_STR.S,);
						/* Send announcement string to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	Send status (footing) string to SCRPKG via DISPLAY_PUT
/*	routine. This string is independent of screen style.
/*	Skip it, however, for multi-file summary.
/*/

IF M->MRB$V_MFSUM = NO				/* If not multi-file summary, */
    THEN DO;
	 PUT_LEN = STATUS_STR.L;		/* Get length of this put */
	 FAOL_REQUESTED = YES;			/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;			/* Not ready to actually output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,STATUS_STR.S,STATUS_PARMS);
						/* Send status string to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
	 END;


/*
/*	Send title string to SCRPKG via DISPLAY_PUT routine.
/*	Includes DECnet node name if one is present
/*	This string is independent of screen style.
/*/

TITLE_PTR = DCDB->CDB$A_TITLE;			/* Establish title pointer */
TITLE_PARMS.BLANKS = DIVIDE((VTWIDTH - TITLE_LEN),2,31) - 1; /* Compute preceding blanks */
IF DCDB->CDB$V_PERCENT = YES & M->MRB$V_MFSUM = NO /* If percent requested for other than m.f. summary, */
    THEN PCENT_WID = 4;				/* then put out % string */
    ELSE PCENT_WID = 0;				/* else don't put % string */
PUT_LEN = TITLE_STR.L;				/* Get length of this put */
NODE_PTR = ADDR(SPTR->MNR_SYI$T_NODENAME);	/* Set up ptr to node name cstring */
IF NODE_LEN = 0 | SPEC_SYSTEM_SCREEN		/* If node name non-existent, or special SYSTEM screen, */
    THEN PUT_LEN = PUT_LEN - 16;		/*   then chop off node name line */
FAOL_REQUESTED = YES;				/* Request a run thru $FAOL */
OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,TITLE_STR.S,TITLE_PARMS);
						/* Send title line to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	If special screen display for SYSTEM class,
/*	send a heading string including DECnet node
/*	name and requested statistic.
/*/

IF SPEC_SYSTEM_SCREEN
    THEN DO;
	 STATLONG_ADDR = ADDR(STAT_LONG(DCDB->CDB$B_ST));	/* Get addr of correct stat string */
	 SYS_NODE_PTR = NODE_PTR;				/* Get address of node name cstring */
	 PUT_LEN = SYS_HEAD_STR.L;				/* Get length of this put */
	 FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;					/* Not ready to actually output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SYS_HEAD_STR.S,SYS_HEAD_PARMS);
								/* Send SYSTEM heading to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

/*
/*	Send user's comment string to SCRPKG via DISPLAY_PUT routine.
/*	This string is independent of screen style.
/*/

IF M->MRB$V_MFSUM = NO & INP_COMM_LEN ^= 0		/* If not m.f. summary and an input comment exists, */
   & SPEC_SYSTEM_SCREEN = NO				/* and not the special SYSTEM screen, */
    THEN DO;
	 COMM_LEN = INP_COMM_LEN;			/* Move length to parm list */
	 COMM_ADDR = ADDR(INP_COMM_STR);		/* Move address to parm list */
	 COMM_PARMS.BLANKS = DIVIDE((VTWIDTH - COMM_LEN),2,31) - 1; /* Compute preceding blanks */
	 PUT_LEN = COMM_STR.L;				/* Get length of this put */
	 FAOL_REQUESTED = YES;				/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,COMM_STR.S,COMM_PARMS);
							/* Send comment line to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */
	 END;

/*
/*	For standard classes, call TEMPLATE to put item
/*	names and build FAO string for actual data for
/*	tabular or bar-style screen. Skip, however, for
/*	the special SYSTEM display
/*/

  IF DCDB->CDB$V_STD & SPEC_SYSTEM_SCREEN = NO		/* If standard class, and not SYSTEM screen, */
    THEN DO;
	 CALL = TEMPLATE(DCDB);				/* Put item names and build FAO string */
	 IF STATUS = NOT_SUCCESSFUL			/* Check status */
	     THEN DO;
		  CALL MON_ERR(MNR$_DISPERR,CALL);	/* Log the error */
		  RETURN(MNR$_DISPERR);			/* ... and return with status */
		  END;
	 END;

/*
/*	Send heading string (and box, if bar graph)
/*	to SCRPKG via DISPLAY_PUT routine.
/*/

IF M->MRB$V_MFSUM = NO & SPEC_SYSTEM_SCREEN = NO		/* Only do it if not multi-file summary and not spec SYSTEM */
THEN

/*
/*	Put PROCESSES Heading
/*/

IF ^ DCDB->CDB$V_STD & DCDB->CDB$B_ST = REG_PROC		/* Put out regular PROCESSES heading */
    THEN DO;
	 PUT_LEN = PROCHEAD_STR.L;				/* Length of put */
	 FAOL_REQUESTED = NO;					/* No $FAOL required */
	 OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,PROCHEAD_STR.S,); /* Hand heading over to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

/*
/*	Put Tabular Heading
/*/

    ELSE IF DCDB->CDB$V_STD & DCDB->CDB$B_ST = ALL_STAT			/* All statistics requested for STD class? */
	     THEN DO;							/* Tabular display */
		  IF DCDB->CDB$V_WIDE					/* If a wide display (for DISK), */
		      THEN CALL SCR$SET_CURSOR(6,44);			/* ... then set appropriate cursor */
		      ELSE CALL SCR$SET_CURSOR(6,40);			/* ... else set it to the usual place */
		  IF DCDB->CDB$V_PERCENT
		      THEN TABHEAD_PARM = ADDR(PCENT_STR);		/* Include % symbol in heading */
		      ELSE TABHEAD_PARM = ADDR(BLANK_STR);		/* Exclude % symbol from heading */
		  PUT_LEN = TABHEAD_STR.L;				/* Length of put */
		  FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
		  OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,TABHEAD_STR.S,TABHEAD_PARM);
									/* Hand heading over to SCRPKG */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
		  END;

/*
/*	Put Bar Graph Heading
/*/

   ELSE BEGIN;							/* Bar graph display */
	 Declare
	 CURGR_VAL	FIXED BINARY(31),			/* Current graph value (for heading) */
	 MAXGR_VAL	FIXED BINARY(31),			/* Max (right-edge) graph value for heading */
	 GR_INCR	FIXED BINARY(31),			/* Increment value for heading */
	 RANGE		FIXED BINARY(31),			/* Range for heading values */
	 CHAR_ADDR	POINTER;				/* Addr of symbol char for heading */

	 Declare
	 1 BARHEAD_STR	GLOBALREF,				/* Bar graph heading control string */
	   2 L		FIXED BINARY(7),			/* Length */
	   2 S		CHAR(1),				/* First character of string */
	 1 BARHEAD_PARMS,					/* FAOL parms for graph heading line */
	   2 BP1	FIXED BINARY(31),			/* Graph heading value */
	   2 BP2	POINTER,				/* Graph heading symbol string ptr */
	   2 BP3	FIXED BINARY(31),			/* Graph heading value */
	   2 BP4	POINTER,				/* Graph heading symbol string ptr */
	   2 BP5	FIXED BINARY(31),			/* Graph heading value */
	   2 BP6	POINTER,				/* Graph heading symbol string ptr */
	   2 BP7	FIXED BINARY(31),			/* Graph heading value */
	   2 BP8	POINTER,				/* Graph heading symbol string ptr */
	   2 BP9	FIXED BINARY(31),			/* 1=> advance heading one byte to right */
	   2 BP10	FIXED BINARY(31),			/* Graph heading value */
	   2 BP11	POINTER;				/* Graph heading symbol string ptr */

	 Declare
	 1 STATHEAD_STR	GLOBALREF,				/* Bar graph statistic heading control string */
	   2 L		FIXED BINARY(7),			/* Length */
	   2 S		CHAR(1),				/* First character of string */
	 1 STATHEAD_PARMS,					/* FAOL parms for statistic heading */
	   2 L		FIXED BINARY(31) INIT(3),		/* Statistic heading string length */
	   2 A		POINTER,				/* Pointer to heading string */
	 STAT_HEAD (4)	CHAR(3) GLOBALREF;			/* Table of 3-char heading strings */

	 CALL = PUT_BOX();					/* Put larger bar graph box to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

/*
/*	Put heading line on top of the box.
/*/

	 IF DCDB->CDB$V_PERCENT
	     THEN DO;						/* Heading values are percents */
		  CHAR_ADDR = ADDR(PCENT_STR);			/* Use % symbol for heading */
		  CURGR_VAL = 0;				/* First value is 0 */
		  RANGE = 100;					/* Range is 100 */
		  END;
	     ELSE IF DCDB->CDB$V_KUNITS
		      THEN DO;					/* Values in units of 1000 */
			   CHAR_ADDR = ADDR(K_STR);		/* Use K symbol for heading */
			   CURGR_VAL = DIVIDE(DCDB->CDB$L_MIN,1000,31); /* Compute first value */
			   RANGE = DIVIDE(DCDB->CDB$L_RANGE,1000,31);   /* ... and range */
			   END;
		      ELSE DO;					/* Heading values are as is */
			   CHAR_ADDR = ADDR(NULL_STR);		/* Use no (null) symbol for heading */
			   CURGR_VAL = DCDB->CDB$L_MIN;		/* Compute first value */
			   RANGE = DCDB->CDB$L_RANGE;		/* ... and range */
			   END;
	 GR_INCR = DIVIDE(RANGE,4,31);				/* Compute increment between values */
	 MAXGR_VAL = CURGR_VAL + RANGE;				/* ... and max (right-most) value */
	 BP1 = CURGR_VAL;					/* Fill in FAOL parms to put heading */
	 BP2 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 BP3 = CURGR_VAL;					/* ........ */
	 BP4 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 BP5 = CURGR_VAL;					/* ........ */
	 BP6 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 BP7 = CURGR_VAL;					/* ........ */
	 BP8 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 IF DCDB->CDB$V_PERCENT | DCDB->CDB$V_KUNITS		/* If units symbol is printable, */
	     THEN BP9 = 0;					/* ... then do not advance one space */
	     ELSE BP9 = 1;					/* ... else advance a space, so last value */
								/* ... is on right edge of box */
	 BP10 = MAXGR_VAL;					/* Next parm is the last value */
	 BP11 = CHAR_ADDR;					/* ... addr of units symbol */

/*
/*	Setup to call DISPLAY_PUT for the heading line
/*/
	 PUT_LEN = BARHEAD_STR.L;				/* Length of put */
	 FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;					/* Not ready to output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,BARHEAD_STR.S,BARHEAD_PARMS);
								/* Hand heading over to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
/*
/*	Now put the smaller box with the statistic heading for Standard classes
/*/
	 IF DCDB->CDB$V_STD					/* If standard class, */
	     THEN DO;
		  STATHEAD_PARMS.A = ADDR(STAT_HEAD(DCDB->CDB$B_ST));	/* Get addr of correct string */
		  PUT_LEN = STATHEAD_STR.L;				/* Length of put */
		  FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
		  OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,STATHEAD_STR.S,STATHEAD_PARMS);
									/* Hand statistic heading over to SCRPKG */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
		  END;

	 END;							/* End of begin-end group */

ELSE								/* At this point, either m.f.summ or spec. SYSTEM screen */
	 IF SPEC_SYSTEM_SCREEN					/* If special SYSTEM screen, */
	 THEN
	 DO;
	 DCDB->CDB$A_FAOCTR = ADDR(SYS_FAO_STR);		/* Get a pre-built FAO control string */
	 DCDB->CDB$L_FAOCTR = SYS_FAO_STR_LEN;			/* ... and its length */
	 IF BSS_RANGE(14) >= 10000				/* If range of Free List bar is large, */
	   THEN DO;
		SBP1 = DIVIDE(BSS_RANGE(14),1000,31);		/*   then get the number of thousands */
		SBP2 = ADDR(K_STR);				/*   and use a "K" */
		END;
	   ELSE DO;
		SBP1 = BSS_RANGE(14);				/*   else use the raw number */
		SBP2 = ADDR(NULL_STR);				/*   and no "K" */
		END;

	 IF BSS_RANGE(15) >= 10000				/* If range of Modified List bar is large, */
	   THEN DO;
		SBP3 = DIVIDE(BSS_RANGE(15),1000,31);		/*   then get the number of thousands */
		SBP4 = ADDR(K_STR);				/*   and use a "K" */
		END;
	   ELSE DO;
		SBP3 = BSS_RANGE(15);				/*   else use the raw number */
		SBP4 = ADDR(NULL_STR);				/*   and no "K" */
		END;

	 PUT_LEN = SYS_BOX_STR_LEN;				/* Length of put */
	 FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;					/* Don't output yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SYS_BOX_STR,SYS_BOX_PARMS); /* Hand boxes over to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 PUT_LEN = SYS_TEXT_STR_LEN;				/* Length of put */
	 FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
	 OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SYS_TEXT_STR,);	/* Output text and display entire screen */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

	 ELSE							/* Multi-file summary */
	 DO;
	 PUT_LEN = MF_STATHEAD_STR.L;				/* Length of put */
	 FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
	 OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MF_STATHEAD_STR.S,); /* Hand statistic heading over to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

RETURN(NORMAL);							/* Return to caller */

PUT_BOX: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	PUT_BOX
/*
/*	Called by DISP_TEMPLATE to put the bar graph box to the SCRPKG.
/*	Actual display output is not performed.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
FIRST_DATA_LINE		FIXED BINARY(31) GLOBALREF VALUE,	/* Line number of first data line on screen */
LAST_DATA_LINE		FIXED BINARY(31) GLOBALREF VALUE,	/* Line number of last data line on screen */
VTDATALINES		FIXED BINARY(31) GLOBALREF VALUE,	/* Total data lines on screen */
CURSOR_STR		CHAR(2) GLOBALREF,			/* Cursor control escape sequence */ 
HORIZ_STR		CHAR(42) GLOBALREF,			/* Horizontal portion of bar graph box */ 
CURROW			FIXED BINARY(15),			/* Current row counter */
CURCOL			FIXED BINARY(15);			/* Current column counter */

Declare
1 VERT_LINE (5*VTDATALINES),					/* Escape string to make vertical lines for box */
  2 CURSOR		CHAR(2),				/* Cursor control esc sequence */
  2 ROW			FIXED BINARY(7),			/* Row byte */
  2 COL			FIXED BINARY(7),			/* Column byte */
  2 VERT_CHAR		CHAR(1);				/* Vertical bar character */

Declare
1 HORIZ_LINE (2),						/* Escape string to make horiz'l lines for box */
  2 CURSOR		CHAR(2),				/* Cursor control esc sequence */
  2 ROW			FIXED BINARY(7),			/* Row byte */
  2 COL			FIXED BINARY(7),			/* Column byte */
  2 TOP_BOT		CHAR(42);				/* Horiz line appearing at top & bot of box */

/*
/*	Create and send to the SCRPKG the horizontal (top
/*	and bottom) lines of the bar graph box.
/*/

HORIZ_LINE.CURSOR(1) = CURSOR_STR;		/* Move in cursor control sequence */
HORIZ_LINE.ROW(1) = FIRST_DATA_LINE - 1;	/* Move in row number of top line of box */
HORIZ_LINE.COL(1) = 38;				/* Move in column number */
TOP_BOT(1) = HORIZ_STR;				/* Move in the top line */
HORIZ_LINE.CURSOR(2) = CURSOR_STR;		/* Move in cursor control sequence */
HORIZ_LINE.ROW(2) = LAST_DATA_LINE+1;		/* Move in row number of bot line of box */
HORIZ_LINE.COL(2) = 38;				/* Move in column number */
TOP_BOT(2) = HORIZ_STR;				/* Move in the bottom line */
FAOL_REQUESTED = NO;				/* FAOL not involved */
OUTP_REQUESTED = NO;				/* ... don't output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,46*2,HORIZ_LINE,); /* Put horizontal lines to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	Now create and send to the SCRPKG the vertical
/*	lines of the bar graph box.
/*/

I = 0;						/* Initialize loop control */
DO CURROW = FIRST_DATA_LINE TO LAST_DATA_LINE;	/* Loop once for each data line in graph */
DO CURCOL = 38 TO 78 BY 10;			/* Loop once for each vert char in a line */
IF CURCOL = 78 THEN CURCOL = CURCOL + 1;	/* Push right-most bar over 1 */
I = I + 1;					/* Update index into VERT_LINE vector */
VERT_LINE.CURSOR(I) = CURSOR_STR;		/* Move in cursor control sequence */
VERT_LINE.ROW(I) = CURROW;			/* Move in row number */
VERT_LINE.COL(I) = CURCOL;			/* Move in column number */
VERT_CHAR(I) = '|';				/* Move in the vertical bar char */
END;
END;
CALL = DISPLAY_PUT(DPUT_FLAGS,5*5*VTDATALINES,VERT_LINE,); /* Put vertical lines to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

RETURN(NORMAL);					/* Return to caller */
END PUT_BOX;

END DISP_TEMPLATE;

COLLECTION_END: Procedure Returns(fixed binary(31));	/* Indicate collection ended */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	COLLECTION_END
/*
/*	Called by CTRLC, CTRLZ, COLLECTION_EVENT or CLASS_COLLECT whenever it
/*	is determined that data collection has reached an end. This can occur
/*	when the user strikes CTRL-C or CTRL-Z, an input (playback) file has
/*	reached end-of-file, or a requested ending time has occurred.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	COLLENDED bit is set.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/* SIDE EFFECTS:
/*
/*	All timers are canceled, a $WAKE is issued, and the display and
/*	"between screens" event flags are set. Also, I/O is canceled on the
/*	channel for CTRL-C and CTRL-Z to disable reception of AST's, and
/*	on the channel for CTRL-W.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$CANTIM;				/* $CANTIM system service */
%INCLUDE	SYS$SETEF;				/* $SETEF system service */
%INCLUDE	SYS$CANCEL;				/* $CANCEL system service */
%INCLUDE	MONDEF;					/* Monitor utility structure definitions */

Declare
  DISP_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* Display event flag */
  BET_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* "Between screens" display event flag */
  HIB_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* Hibernation event flag */
  COLLENDED	BIT(1)		 GLOBALREF,		/* YES => collection has ended */
  MRBPTR	POINTER		 GLOBALREF,		/* Pointer to MRB (Monitor Request Block) */
  MCAPTR	POINTER		 GLOBALREF,		/* Pointer to MCA (Monitor Communication Area) */
  CTRLCZ_CHAN	FIXED BINARY(31) GLOBALREF,		/* Channel number for CTRL-C and CTRL-Z */
  CTRLW_CHAN	FIXED BINARY(31) GLOBALREF,		/* Channel number for CTRL-W */
  NORMAL	FIXED BINARY(31) GLOBALREF, 		/* MONITOR normal status value */
  CALL		FIXED BINARY(31);			/* Holds function value (return status) of called routines */ 

CALL = SYS$CANTIM(,);					/* Cancel outstanding timer requests */
CALL = SYS$SETEF(HIB_EV_FLAG);				/* Wake up if hibernating for future request */
CALL = SYS$SETEF(DISP_EV_FLAG);				/* Force final display */
CALL = SYS$SETEF(BET_EV_FLAG);				/* Force final screen of multi-screen display */
COLLENDED = YES;					/* Indicate collection ended */
MRBPTR->MRB$Q_ENDING = MCAPTR->MCA$Q_LASTCOLL;		/* Establish last collection time as ending */
IF CTRLCZ_CHAN ^= 0 THEN CALL = SYS$CANCEL(CTRLCZ_CHAN); /* Cancel CTRL-C and CTRL-Z handlers */
CTRLCZ_CHAN = 0;					/* ... and indicate so */
IF CTRLW_CHAN ^= 0 THEN CALL = SYS$CANCEL(CTRLW_CHAN);	/* Cancel CTRL-W handler */
CTRLW_CHAN = 0;						/* ... and indicate so */
RETURN(NORMAL);						/* Return to caller */

END COLLECTION_END;

CTRLC: Procedure Returns(fixed binary(31));		/* CTRL-C handler */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CTRLC
/*
/*	AST Routine entered whenever the user strikes CTRL-C.
/*	The COLLECTION_END routine is called to begin termination
/*	of the Monitor request. Also, the CTRLCZ_HIT bit is set,
/*	and the PROMPT bit is set to indicate a MONITOR> prompt
/*	is desired.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  COLLECTION_END ENTRY,					/* Routine to indicate end of collection */
  CTRLCZ_HIT	BIT(1) ALIGNED	GLOBALREF,		/* YES => CTRL-C or CTRL-Z has been hit */
  PROMPT	BIT(1) ALIGNED	GLOBALREF,		/* YES => prompt user for another subcommand */
  NORMAL	FIXED BINARY(31) GLOBALREF; 		/* MONITOR normal status value */

CTRLCZ_HIT = YES;					/* Indicate CTRL-C has been hit */
PROMPT = YES;						/* Indicate user wants MONITOR> prompt */
CALL COLLECTION_END();					/* Indicate end of collection */
RETURN(NORMAL);						/* Return to caller */

END CTRLC;

CTRLZ: Procedure Returns(fixed binary(31));		/* CTRL-Z handler */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CTRLZ
/*
/*	AST Routine entered whenever the user strikes CTRL-Z.
/*	The COLLECTION_END routine is called to begin termination
/*	of the Monitor request. Also, the CTRLCZ_HIT bit is set,
/*	and the PROMPT bit is set to 0 to indicate a MONITOR> prompt
/*	is NOT desired.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  COLLECTION_END ENTRY,					/* Routine to indicate end of collection */
  COMMAND_FILE	FILE		GLOBALREF,		/* File reference for the execute command file */
  CTRLZ_HIT	BIT(1) ALIGNED	GLOBALREF,		/* YES => CTRL-Z has been hit */
  CTRLCZ_HIT	BIT(1) ALIGNED	GLOBALREF,		/* YES => CTRL-C or CTRL-Z has been hit */
  PROMPT	BIT(1) ALIGNED	GLOBALREF,		/* YES => prompt user for another subcommand */
  EXECUTE	BIT(1) ALIGNED	GLOBALREF,		/* YES => read another execute command file subcommand */
  NORMAL	FIXED BINARY(31) GLOBALREF; 		/* MONITOR normal status value */

CTRLZ_HIT = YES;					/* Indicate CTRL-Z has been hit */
CTRLCZ_HIT = YES;					/* Indicate CTRL-Z has been hit */
PROMPT = NO;						/* Indicate user does NOT want a MONITOR> prompt */
IF (EXECUTE = YES) THEN DO;				/* If there is an execute command file open, */
    CLOSE FILE(COMMAND_FILE);				/*  close the execute command file and */
    EXECUTE = NO;					/*  indicate no more execute subcommands to be done. */
    END;
CALL COLLECTION_END();					/* Indicate end of collection */
RETURN(NORMAL);						/* Return to caller */

END CTRLZ;

CTRLW: Procedure Returns(fixed binary(31));		/* CTRL-W (display screen refresh) handler */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CTRLW
/*
/*	AST routine, entered whenever the user strikes CTRL-W.
/*	Sets the Refresh Event Flag to indicate a new display
/*	event (including template) is desired.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$SETEF;				/* $SETEF system service */

Declare
  REFR_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* Refresh event flag */
  NORMAL	FIXED BINARY(31) GLOBALREF, 		/* MONITOR normal status value */
  CALL		FIXED BINARY(31);			/* Holds function value (return status) of called routines */ 

CALL = SYS$SETEF(REFR_EV_FLAG);				/* Cause refresh display event to occur */
RETURN(NORMAL);						/* Return to caller */

END CTRLW;

WRITE_HEADER: Procedure Returns(fixed binary(31));		/* Write recording file header record */
								/* ... and system information record */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	WRITE_HEADER
/*
/*	Called by the CLASS_COLLECT routine to write the first 2
/*	records of the recording file (File Header Record and
/*	System Information Record). Called once per Monitor
/*	request before any class records are written.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
  WRITE_RECORD	ENTRY (ANY) RETURNS(FIXED BINARY(31));		/* Routine to write a rec to the recording file */

Declare
  CALL		FIXED BINARY(31),				/* Holds function value (return status) of called routines */ 
  STATUS	BIT(1)	BASED(ADDR(CALL)),			/* Low-order status bit for called routines */
  NORMAL	FIXED BINARY(31) GLOBALREF, 			/* MONITOR normal status value */
  SPTR		POINTER GLOBALREF,				/* Pointer to SYI (System Information Area) */
  MRBPTR	POINTER GLOBALREF,				/* Pointer to MRB (Monitor Request Block) */
  M		POINTER DEFINED(MRBPTR),			/* Synonym for MRBPTR */
  H		POINTER,					/* Pointer to record file header */
  HEADER_TYPE	FIXED BINARY(15) GLOBALREF,			/* Type for MONITOR recording file header */
  ST_LEVEL_CUR	CHAR(8) GLOBALREF,				/* Current MONITOR recording file structure level */
  ST_LEVEL_PB	CHAR(8)	GLOBALREF,				/* MONITOR recording file structure level from input file */
  REVLEVELS	CHAR(128) GLOBALREF,				/* Revision levels used by classes for this request */
  REV0CLSBITS	BIT(128) GLOBALREF,				/* Bits for classes recorded at rev level 0 */
  1 COMM_D BASED(M->MRB$A_COMMENT),				/* Descriptor for user's comment string */
    2 L		FIXED BINARY(15),				/* Length */
    2 TC	CHAR(2),					/* Type and class */
    2 A		POINTER,					/* Address */
  COMMENT	CHAR(COMM_D.L) BASED(COMM_D.A),			/* User-specified comment string */
  1 REC_DESCR,							/* Record descriptor */
    2 L		FIXED BINARY(31),				/* Length */
    2 A		POINTER;					/* Address */

ALLOCATE FILE_HDR SET (H);			/* Allocate file header space */

H->MNR_HDR$B_TYPE = UNSPEC(HEADER_TYPE);	/* Load header type code */
H->MNR_HDR$V_FILLER = '0'B;			/* Clear all unused flags */
H->MNR_HDR$Q_BEGINNING = M->MRB$Q_BEGINNING;	/* Load beginning time */
H->MNR_HDR$Q_ENDING = '0'B;			/* Indicate no ending time yet */
H->MNR_HDR$L_INTERVAL = M->MRB$L_INTERVAL;	/* Load interval value */
H->MNR_HDR$O_REV0CLSBITS = REV0CLSBITS;		/* Load bits for classes recorded at rev level 0 */
H->MNR_HDR$L_RECCT = 0;				/* Indicate no records yet */
IF M->MRB$V_PLAYBACK				/* If a playback request, */
    THEN H->MNR_HDR$T_LEVEL = ST_LEVEL_PB;	/*   then load playback recording file structure level */
    ELSE H->MNR_HDR$T_LEVEL = ST_LEVEL_CUR;	/*   else load current recording file structure level */

IF M->MRB$A_COMMENT = NULL()			/* If no comment string specified, */
    THEN DO;
	 H->MNR_HDR$T_COMMENT = ' ';		/* Load a string of blanks */
	 H->MNR_HDR$W_COMLEN = 0;		/* ... and a length of 0 */
	 END;

    ELSE DO;					/* Comment string is specified */
	 H->MNR_HDR$T_COMMENT = COMMENT;	/* Load user's comment string */
	 H->MNR_HDR$W_COMLEN = COMM_D.L;	/* ... and its actual length */
	 IF H->MNR_HDR$W_COMLEN > MNR_HDR$K_MAXCOMLEN	     /* Minimize actual length with ... */
	     THEN H->MNR_HDR$W_COMLEN = MNR_HDR$K_MAXCOMLEN; /* ... max comment length */
	 END;

H->MNR_HDR$O_CLASSBITS = M->MRB$O_CLASSBITS;	/* Load class bit string */
H->MNR_HDR$T_REVLEVELS = REVLEVELS;		/* Load revision levels used by this request */

/*
/*	Write file header record
/*/

REC_DESCR.L = MNR_HDR$K_SIZE;			/* Load up length */
REC_DESCR.A = H;				/* ... and address of record for write */
CALL = WRITE_RECORD(REC_DESCR);			/* Write the file header record */
FREE H->FILE_HDR;				/* Free file header space */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check WRITE_RECORD call */

/*
/*	Write system information record
/*/

REC_DESCR.L = MNR_SYI$K_SIZE;			/* Load up length */
REC_DESCR.A = SPTR;				/* ... and address of record for write */
CALL = WRITE_RECORD(REC_DESCR);			/* Write the system info record */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check WRITE_RECORD call */

RETURN(NORMAL);					/* Return to caller */
END WRITE_HEADER;

WRITE_RECORD: Procedure (RECORD_DESC)
			Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	WRITE_RECORD
/*
/*	Called by the WRITE_HEADER and CLASS_COLLECT routines to
/*	write a single record to the recording file. If a flush
/*	has been indicated, it is performed.
/*
/* INPUTS:
/*
/*	Address of a string descriptor describing the record to be written.
/*
/* IMPLICIT INPUTS:
/*
/*	FLUSH_IND -- Flush indicator. If set, perform an RMS flush operation
/*		     to "checkpoint" the recording file.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	RECCT incremented by 1.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  NORMAL		FIXED BINARY(31) GLOBALREF,		/* MONITOR normal status value */
  RECCT			FIXED BINARY(31) GLOBALREF,		/* Count of records written to record file */
  FLUSH_IND		BIT(1) ALIGNED   GLOBALREF;		/* Flush indicator; YES => perform FLUSH */

Declare
  1 RECORD_DESC,						/* Record descriptor */
    2 RECORD_LEN	FIXED BINARY(31),			/* Record length */
    2 RECORD_PTR	POINTER,				/* Record pointer */
  RECORD_DATA		CHAR(RECORD_LEN) BASED(RECORD_PTR); 	/* Record data */

Declare
  RECORD_FILE		FILE RECORD;				/* Monitor Record File */

WRITE FILE(RECORD_FILE) FROM(RECORD_DATA);			/* Write a record */
RECCT = RECCT + 1;						/* Count it */

IF FLUSH_IND							/* If flush indicated for this write, */
    THEN DO;
	 CALL FLUSH(RECORD_FILE);				/* Flush record file to checkpoint collected data */
	 FLUSH_IND = NO;					/* Indicate flush not required */
	 END;

RETURN(NORMAL);							/* Return */
END WRITE_RECORD;

READ_INPUT: Procedure (SKIP_IND);				/* Routine to read a record from the /INPUT file */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	READ_INPUT
/*
/*	This routine reads the /INPUT (playback) file until a
/*	record of the desired type is found, or until end-of-file
/*	is reached. The following categories of record types exist:
/*
/*		Types   0 - 127:	Class record
/*		Types 128 - 191:	DIGITAL control record
/*		Types 192 - 255:	Customer control record
/*
/*	A class record is always desired. A customer control record
/*	is never desired. A DIGITAL control record can be desired
/*	or not, depending on the input parameter SKIP_IND.
/*
/* INPUTS:
/*
/*	SKIP_IND -- a binary longword value indicating whether or not
/*			to skip past DIGITAL control records. If
/*			SKIP_IND is 0, DIGITAL control records
/*			are desired, and will not be skipped.
/*			Otherwise, they are skipped. 
/*
/* IMPLICIT INPUTS:
/*
/*	MCAPTR -- Pointer to Monitor Communication Area
/*	INPUT_CPTR -- Pointer to /INPUT file buffer
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	MCA$L_INPUT_LEN is updated to indicate the length of the record
/*	currently in the input buffer.
/*
/*	MCA$V_EOF is set if end-of-file is reached.
/*
/* ROUTINE VALUE:
/*
/*	None
/*
/* SIDE EFFECTS:
/*
/*	/INPUT file (INPUT_FILE) is advanced to the desired record.
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
  MAX_REC_SIZE	FIXED BINARY(31) GLOBALREF VALUE,		/* Max record size for PLAYBACK & RECORD files */
  MCAPTR	POINTER GLOBALREF,				/* Pointer to MCA (Monitor Communication Area) */
  MC		POINTER DEFINED(MCAPTR),			/* Synonym for MCAPTR */
  INPUT_CPTR	POINTER GLOBALREF,				/* Ptr to input buffer count word */
  INPUT_DATA	CHAR(MAX_REC_SIZE) VARYING BASED(INPUT_CPTR);	/* Playback file input buffer */

Declare
  SKIP_IND		FIXED BINARY(31),			/* Skip indicator; non-zero => skip DIGITAL control recs */
  DESIRED_TYPE		BIT(1) ALIGNED,				/* YES => desired record type found */
  1 RECORD_TYPE		BASED(MC->MCA$A_INPUT_PTR), 		/* Record type field of input record */
    2 FILLER		BIT(6),
    2 BIT6		BIT(1),
    2 BIT7		BIT(1);

Declare
  INPUT_FILE		FILE RECORD INPUT;			/* Monitor Input (Playback) File */

DESIRED_TYPE = NO;						/* Don't have desired type yet */
DO WHILE (^ MC->MCA$V_EOF & ^ DESIRED_TYPE);			/* Stop reading when hit EOF or desired rec found */
READ FILE(INPUT_FILE) INTO(INPUT_DATA);				/* Read a record from the input file */
IF BIT7 = NO							/* If high-order bit of record type off, */
    THEN DESIRED_TYPE = YES;					/*   then we found a desired type (class record) */
    ELSE IF SKIP_IND = 0 & BIT6 = NO				/* If caller wants a DIGITAL control rec, */
	 THEN DESIRED_TYPE = YES;				/*   and it is present, let him have it */
END;

MC->MCA$L_INPUT_LEN = LENGTH(INPUT_DATA);			/* Establish length of input */

RETURN;								/* Return */
END READ_INPUT;
