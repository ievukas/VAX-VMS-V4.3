MODULE INIPAR (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  INIT Utility Structure Level 2
!
! ABSTRACT:
!
!	This module contains the data base and utilities used to acquire the
!	INIT command line from the CLI parser.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  8-Nov-1977  22:29
!
! MODIFIED BY:
!
!	V03-005 MCN0140		Maria del C. Nasr	23-Nov-1983
!		Change to new CLI interface.
!
!	V03-004	LMP0140		L. Mark Pilant,		22-Aug-1983  12:51
!		Add support for alphanumeric UICs.
!
!	V03-003	STJ3089		Steven T. Jeffreys,	24-Apr-1983
!		Add support for /[NO]ERASE and /[NO]HIGHWATER.
!
!	V03-002	MMD0132		Meg Dumont,	12-Apr-1983  17:20
!		Add support for the underscore as a valid character for tape
!
!	V03-001	MMD0128		Meg Dumont,	8-Apr-1983  14:14
!		Added qualifiers to /OVERRIDE and to /LABEL to allow
!		users to ignore and set the OWNER_IDENTIFIER filed
!		of the VOL1 label on ANSI labeled tapes. Added support
!		for the /INTERCHANGE qualifier.
!
!	V02-007	DMW0017		David Michael Walp		19-Jan-1981
!		Uppercase value of volume_accessibility
!
!	V02-006	ACG43021	Andrew C. Goldstein,	4-Jan-1982  16:25
!		Store index file LBN as longword
!
!	V02-005	DMW0015		David Michael Walp		26-Aug-1981
!		/ANSI to /LABEL
!
!	V02-004	DMW0003		David Michael Walp		4-Mar-1981
!		Added /ANSI=VOLUME_ACCESSIBILTY:"x" switch
!
!	V02-003	RLRDENS		Robert L. Rappaport		6-Oct-1980
!		Added /DENSITY=1 and /DENSITY=2 support for RX02's
!
!
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:INIDEF.B32';
REQUIRE 'LIBD$:[VMSLIB.OBJ]INITMSG.B32';
LIBRARY 'SYS$LIBRARY:CLIMAC.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';

!+
!
! Impure data area. This area contains the INIT parameters extracted from
! the command line by the associated parsing routines.
!
!-

LITERAL
	BAD_TABLE_LEN	= 100;		! length of bad block table

GLOBAL
	INIT_OPTIONS	: BITVECTOR [64],	! option flags
	PROTECTION,				! value of /PROTECTION switch
	FILE_PROT,				! value of /FILE_PROTECTION switch
	MAXIMUM,				! value of /MAXIMUM switch
	INDEX,					! LBN of index file start
	CLUSTER,				! value of /CLUSTER switch
	HEADERS,				! value of /HEADERS switch
	DIRECTORIES,				! number of MFD entries to preallocate
	OWNER_UIC,				! value of /OWNER_UIC switch
	EXTENSION,				! value of /EXTENSION switch
	WINDOW,					! value of /WINDOW switch
	ACCESSED,				! value of /ACCESSED switch
	DEVICE_STRING	: BBLOCK [DSC$C_S_BLN],	! decriptor of device name string
	LABEL_STRING	: BBLOCK [DSC$C_S_BLN],	! descriptor of volume label string
	USER_NAME	: BBLOCK [DSC$C_S_BLN],	! descriptor of user name string
	BADBLOCK_COUNT,				! count of manually entered bad blocks
	BADBLOCK_TABLE	: BBLOCKVECTOR [BAD_TABLE_LEN, BAD_LENGTH],
						! manually entered bad blocks
	VOL_ACC		: BYTE,			! value of /LABEL:VOLUME_ACCESS switch
	VOL_OWNER	: VECTOR [14,BYTE],	! value of /LABEL=OWNER_ID
	DATA_PTR 	: VECTOR [32,BYTE],	! value of OWNER-ID from command line
	DATA_INDEX;				! index into data_ptr



!
! Assorted impure data.
!

OWN
	CLI_DESC	: BBLOCK [DSC$C_S_BLN],		!CLI work descriptor
	TPARSE_BLOCK	: BBLOCK [TPA$K_LENGTH0]
			  INITIAL (TPA$K_COUNT0, TPA$M_BLANKS OR TPA$M_ABBREV),
	PROT_VAL,
	UIC;

EXTERNAL LITERAL
	CLI$_DEFAULTED,
	CLI$_NEGATED,
	CLI$_PRESENT;



!+
!
! Request descriptors to the CLI parser. Labels are deemed sufficiently
! obvious to make cluttering the code with comments unnecessary.
!
!-

BIND
	ACCESSED_DESC	= $DESCRIPTOR('ACCESSED'),
	BADBLOCKS_DESC	= $DESCRIPTOR('BADBLOCKS'),
	CLUSTER_DESC	= $DESCRIPTOR('CLUSTER_SIZE'),
	DATA_DESC	= $DESCRIPTOR('DATA_CHECK'),
	DENSITY_DESC	= $DESCRIPTOR('DENSITY'),
	DIRECT_DESC	= $DESCRIPTOR('DIRECTORIES'),
	ERASE_DESC	= $DESCRIPTOR('ERASE'),
	EXTENSION_DESC	= $DESCRIPTOR('EXTENSION'),
	FILE_DESC	= $DESCRIPTOR('FILE_PROTECTION'),
	GROUP_DESC	= $DESCRIPTOR('GROUP'),
	HEADERS_DESC	= $DESCRIPTOR('HEADERS'),
	HIGH_DESC	= $DESCRIPTOR('HIGHWATER'),
	INDEX_DESC	= $DESCRIPTOR('INDEX'),
	INTERCHG_DESC	= $DESCRIPTOR('INTERCHANGE'),
	LABEL_DESC	= $DESCRIPTOR('LABEL'),
	MAXIMUM_DESC	= $DESCRIPTOR('MAXIMUM_FILES'),
	OVERRIDE_DESC	= $DESCRIPTOR('OVERRIDE'),
	OWNER_DESC	= $DESCRIPTOR('OWNER_UIC'),
	PROTECTION_DESC	= $DESCRIPTOR('PROTECTION'),
	SHARE_DESC	= $DESCRIPTOR('SHARE'),
	STRUCTURE_DESC	= $DESCRIPTOR('STRUCTURE'),
	SYSTEM_DESC	= $DESCRIPTOR('SYSTEM'),
	USER_DESC	= $DESCRIPTOR('USER_NAME'),
	VERIFIED_DESC	= $DESCRIPTOR('VERIFIED'),
	WINDOW_DESC	= $DESCRIPTOR('WINDOWS');

FORWARD ROUTINE
	PARSE_QUALIFIERS: NOVALUE,
	DENSITY_ACT	: NOVALUE,
	STRUCTURE_ACT	: NOVALUE,
	OVERRIDE_ACT	: NOVALUE,
	PROTECTION_ACT	: NOVALUE,
	FILE_PROT_ACT	: NOVALUE,
	OWNER_UIC_ACT	: NOVALUE,
	INDEX_ACT	: NOVALUE,
	DATACHECK_ACT	: NOVALUE,
	USER_NAME_ACT	: NOVALUE,
	BADBLOCKS_ACT	: NOVALUE,
	LABEL_QUAL_ACT	: NOVALUE;

EXTERNAL ROUTINE
	CLI$GET_VALUE,
	CLI$PRESENT,
	LIB$CVT_DTB;


GLOBAL ROUTINE INIT_PARSE : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the INIT command line by calling the CLI
!	result parse routines, and leaves the results in the global data
!	area.
!
!
! CALLING SEQUENCE:
!	INIT_PARSE
!
! INPUT PARAMETERS:
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	parser impure area on preceding pages
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! Initialize result parsing.
!

INIT_OPTIONS = INIT_OPTIONS+4 = 0;
INIT_OPTIONS[OPT_NOHIGHWATER] = 1;		! /NOHIGHWATER leaves it set

! Initialize descriptor
!
CH$FILL ( 0, DSC$C_S_BLN, CLI_DESC );
CLI_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;


! Parse command qualifiers. (Most of the action routines are called during
! this call.)
!
PARSE_QUALIFIERS ();

! Now acquire device name.
!

CH$FILL ( 0, DSC$C_S_BLN, DEVICE_STRING );
DEVICE_STRING [DSC$B_CLASS] = DSC$K_CLASS_D;
CLI$GET_VALUE ( $DESCRIPTOR('DEVICE'), DEVICE_STRING );

! Now acquire volume name.
!

CH$FILL ( 0, DSC$C_S_BLN, LABEL_STRING );
LABEL_STRING [DSC$B_CLASS] = DSC$K_CLASS_D;
CLI$GET_VALUE ( $DESCRIPTOR('VOLUME'), LABEL_STRING );

! The qualifier /STRUCTURE=1 cannot be used with /CLUSTER or
! /DATA_CHECK
!

IF .INIT_OPTIONS [OPT_STRUCTURE1]
  AND ( .INIT_OPTIONS [OPT_CLUSTER]
        OR .INIT_OPTIONS [OPT_READCHECK]
	OR .INIT_OPTIONS [OPT_WRITECHECK] )
THEN
    ERR_EXIT (INIT$_CONFQUAL);

END;			! end of routine INIT_PARSE

ROUTINE PARSE_QUALIFIERS : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the qualifiers of the INIT command line by
!	calling the CLI result parse routines.
!
! CALLING SEQUENCE:
!	PARSE_QUALIFIERS ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INIT_OPTIONS bits set
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! /ACCESSED qualifier
!
IF ( INIT_OPTIONS [OPT_ACCESSED] = CLI$PRESENT (ACCESSED_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( ACCESSED_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    ACCESSED ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;

! /BADBLOCKS qualifier
!
IF ( INIT_OPTIONS [OPT_BADBLOCKS] = CLI$PRESENT (BADBLOCKS_DESC) )
THEN
    BADBLOCKS_ACT ();

! /CLUSTER qualifier
!
IF ( INIT_OPTIONS [OPT_CLUSTER] = CLI$PRESENT (CLUSTER_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( CLUSTER_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    CLUSTER ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;

! /DATA_CHECK qualifier (value not required)
!
IF CLI$PRESENT (DATA_DESC)
THEN
    DATACHECK_ACT ();

! /DENSITY qualifier
!
IF ( INIT_OPTIONS [OPT_DENSITY] = CLI$PRESENT (DENSITY_DESC) )
THEN
    DENSITY_ACT ();

! /DIRECTORIES qualifier
!

IF ( INIT_OPTIONS [OPT_DIRECTORIES] = CLI$PRESENT (DIRECT_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( DIRECT_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    DIRECTORIES ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;

! /ERASE qualifier
!
SELECTONE CLI$PRESENT (ERASE_DESC) OF
SET
    [CLI$_PRESENT]	: INIT_OPTIONS [OPT_ERASE] = 1;

    [CLI$_DEFAULTED,
     CLI$_NEGATED]	: INIT_OPTIONS [OPT_ERASE] = 0;
TES;

! /EXTENSION qualifier
!
IF ( INIT_OPTIONS [OPT_EXTENSION] = CLI$PRESENT (EXTENSION_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( EXTENSION_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    EXTENSION ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;

! /FILE_PROTECTION qualifier
!
IF ( INIT_OPTIONS [OPT_FILE_PROT] = CLI$PRESENT (FILE_DESC) )
THEN
    FILE_PROT_ACT ();

! /GROUP qualifier
!
IF CLI$PRESENT ( GROUP_DESC )
THEN
    INIT_OPTIONS [OPT_GROUP] = 1
ELSE
    INIT_OPTIONS [OPT_GROUP] = 0;


! /HEADERS qualifier
!
IF ( INIT_OPTIONS [OPT_HEADERS] = CLI$PRESENT (HEADERS_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( HEADERS_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    HEADERS ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;

! /HIGHWATER qualifier
!
SELECTONE CLI$PRESENT (HIGH_DESC) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED]	: INIT_OPTIONS [OPT_NOHIGHWATER] = 0;

    [CLI$_NEGATED]	: INIT_OPTIONS [OPT_NOHIGHWATER] = 1;
TES;

! /INDEX qualifier
!
IF CLI$PRESENT (INDEX_DESC)
THEN
    INDEX_ACT ();

! /INTERCHANGE qualifier
!
SELECTONE CLI$PRESENT (INTERCHG_DESC) OF
SET
    [CLI$_PRESENT]	: INIT_OPTIONS [OPT_INTERCHG] = 1;

    [CLI$_DEFAULTED,
     CLI$_NEGATED] 	: INIT_OPTIONS [OPT_INTERCHG] = 0;
TES;

! /LABEL qualifier
!
IF CLI$PRESENT (LABEL_DESC)
THEN
    LABEL_QUAL_ACT ();

! /MAXIMUM qualifier
!
IF ( INIT_OPTIONS [OPT_MAXIMUM] = CLI$PRESENT (MAXIMUM_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( MAXIMUM_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    MAXIMUM ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;


! /OVERRIDE qualifier
!
IF CLI$PRESENT (OVERRIDE_DESC)
THEN
    OVERRIDE_ACT ();

! /OWNER_UIC qualifier
!
IF ( INIT_OPTIONS [OPT_OWNER_UIC] = CLI$PRESENT (OWNER_DESC) )
THEN
    OWNER_UIC_ACT ();


! /PROTECTION qualifier
!
IF ( INIT_OPTIONS [OPT_PROTECTION] = CLI$PRESENT (PROTECTION_DESC) )
THEN
    PROTECTION_ACT ();

! /SHARE qualifier
!
SELECTONE CLI$PRESENT ( SHARE_DESC ) OF
SET
    [CLI$_PRESENT]   :	BEGIN
			INIT_OPTIONS [OPT_SHARE] =1;
			INIT_OPTIONS [OPT_EXPNOTMT] = 1;	! not allowed for tapes
			END;
    [CLI$_DEFAULTED] :	INIT_OPTIONS [OPT_SHARE] = 1;
    [CLI$_NEGATED]   :	INIT_OPTIONS [OPT_SHARE] = 0;
TES;

! /STRUCTURE qualifier
!
IF CLI$PRESENT (STRUCTURE_DESC)
THEN
    STRUCTURE_ACT ();

! /SYSTEM qualifier
!
IF CLI$PRESENT ( SYSTEM_DESC )
THEN
    INIT_OPTIONS [OPT_SYSTEM] = 1
ELSE
    INIT_OPTIONS [OPT_SYSTEM] = 0;

! /USER qualifier
!
IF ( INIT_OPTIONS [OPT_USER_NAME] = CLI$PRESENT (USER_DESC) )
THEN
    USER_NAME_ACT ();

! /VERIFIED qualifier
!
SELECTONE CLI$PRESENT ( VERIFIED_DESC ) OF
SET
    [CLI$_PRESENT]   :	BEGIN
			INIT_OPTIONS [OPT_VERIFIED] = 1;
			INIT_OPTIONS [OPT_EXP_VER] = 1;
			INIT_OPTIONS [OPT_EXPNOTMT] = 1;	! not allowed for tapes
			END;
    [CLI$_DEFAULTED]  :	BEGIN
			INIT_OPTIONS [OPT_VERIFIED] =1;
			INIT_OPTIONS [OPT_EXP_VER] = 0;
			END;
    [CLI$_NEGATED]   :	BEGIN
			INIT_OPTIONS [OPT_VERIFIED] = 0;
			INIT_OPTIONS [OPT_EXP_VER] = 1;
			INIT_OPTIONS [OPT_EXPNOTMT] = 1;	! not allowed for tapes
			END;
TES;

! /WINDOWS qualifier
!
IF ( INIT_OPTIONS [OPT_WINDOW] = CLI$PRESENT (WINDOW_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( WINDOW_DESC, CLI_DESC );

    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    WINDOW ) )
    THEN
	ERR_EXIT (INIT$_VALCNVERR);
    END;

END;					! of PARSE_QUALIFIER routine

!+
!
! Parameter and qualifier action routines. Each routine is named corresponding
! to its associated parameter of qualifier. Each routine does whatever
! conversion is necessary and stores the parameter or qualifier value in
! the appropriate location in the output area.
!
!-


ROUTINE BADBLOCKS_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

EXTERNAL
	BADBLOCKS_STB	: VECTOR [0],	! state table address
	BADBLOCKS_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the BADBLOCKS options string.
!

WHILE CLI$GET_VALUE ( BADBLOCKS_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, BADBLOCKS_STB, BADBLOCKS_KTB)
    THEN
	ERR_EXIT (INIT$_BADBLOCKS);
END;

END;					! end of routine BADBLOCKS_ACT

ROUTINE DATACHECK_ACT : NOVALUE =
BEGIN

EXTERNAL
	DATACHECK_STB	: VECTOR [0],	! state table address
	DATACHECK_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

LOCAL
    VALUE_FOUND;			! set when value present

! Parse the DATACHECK options string.
!

VALUE_FOUND = 0;

WHILE CLI$GET_VALUE (DATA_DESC, CLI_DESC) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, DATACHECK_STB, DATACHECK_KTB)
    THEN
	ERR_EXIT (INIT$_BADDATCHK);
    VALUE_FOUND = 1;
END;

! If the qualifier /DATA_CHECK was specified with no value, then
! WRITE data check is the default.  Set the corresponding bit.
!
IF NOT .VALUE_FOUND
THEN
    INIT_OPTIONS [OPT_WRITECHECK] = 1;


END;					! end of routine DATACHECK_ACT

ROUTINE DENSITY_ACT : NOVALUE =

BEGIN

EXTERNAL
	DENSITY_STB	: VECTOR [0],	! state table address
	DENSITY_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the DENSITY value and set appropriate flags.
!

CLI$GET_VALUE ( DENSITY_DESC, CLI_DESC );
TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
IF NOT LIB$TPARSE (TPARSE_BLOCK, DENSITY_STB, DENSITY_KTB)
THEN
    ERR_EXIT (INIT$_BADDENS);
END;


ROUTINE FILE_PROT_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

EXTERNAL
	PROTECTION_STB	: VECTOR [0],	! state table address
	PROTECTION_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the switch value string (storing the binary protection).
! Complement thereafter, since the parser produces the complement.
!

PROT_VAL = 0;

WHILE CLI$GET_VALUE ( FILE_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, PROTECTION_STB, PROTECTION_KTB)
    THEN
	ERR_EXIT (INIT$_BADPRO);
END;

FILE_PROT = NOT .PROT_VAL;

END;					! end of routine FILE_PROT_ACT

ROUTINE INDEX_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

EXTERNAL
	INDEX_STB	: VECTOR [0],	! state table address
	INDEX_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the INDEX options string.
!

CLI$GET_VALUE ( INDEX_DESC, CLI_DESC );
TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
IF NOT LIB$TPARSE (TPARSE_BLOCK, INDEX_STB, INDEX_KTB)
THEN ERR_EXIT (INIT$_BADINDEX);

END;					! end of routine INDEX_ACT

ROUTINE LABEL_QUAL_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

EXTERNAL
	LABEL_QUAL_STB	: VECTOR [0],	! state table address
	LABEL_QUAL_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

DATA_INDEX = 0;			! set index to zero.

! Parse the LABEL options string.
!

WHILE CLI$GET_VALUE ( LABEL_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, LABEL_QUAL_STB, LABEL_QUAL_KTB)
    THEN
	ERR_EXIT (INIT$_BADLABELQ);
END;

END;					! end of routine LABEL_QUAL_ACT

ROUTINE OVERRIDE_ACT : NOVALUE =
BEGIN

EXTERNAL
	OVERRIDE_STB	: VECTOR [0],	! state table address
	OVERRIDE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the OVERRIDE string and set appropriate flags.
!

WHILE CLI$GET_VALUE ( OVERRIDE_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, OVERRIDE_STB, OVERRIDE_KTB)
    THEN
	ERR_EXIT (INIT$_BADOVR);
END;

END;					! end of routine OVERRIDE_ACT

ROUTINE OWNER_UIC_ACT : NOVALUE =
BEGIN

EXTERNAL
	UIC_STB		: VECTOR [0],	! state table address
	UIC_KTB		: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the UIC string and store it in the owner UIC longword.
!

WHILE CLI$GET_VALUE ( OWNER_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, UIC_STB, UIC_KTB)
    THEN
	ERR_EXIT (INIT$_BADUIC);
END;

END;					! end of routine OWNER_UIC_ACT

ROUTINE PROTECTION_ACT : NOVALUE =

BEGIN

EXTERNAL
	PROTECTION_STB	: VECTOR [0],	! state table address
	PROTECTION_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the PROTECTION qualifier string storing the binary protection.
! Complement thereafter, since the parser produces the complement.
!

PROT_VAL = 0;

WHILE CLI$GET_VALUE ( PROTECTION_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, PROTECTION_STB, PROTECTION_KTB)
    THEN
	ERR_EXIT (INIT$_BADPRO);
END;

PROTECTION = NOT .PROT_VAL;

END;

!
! Specify disk structure level
!
ROUTINE STRUCTURE_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

EXTERNAL
	STRUCTURE_STB	: VECTOR [0],	! state table address
	STRUCTURE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the STRUCTURE string (setting the level 1 bit if so).
!

CLI$GET_VALUE ( STRUCTURE_DESC, CLI_DESC );
TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC [DSC$W_LENGTH];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC [DSC$A_POINTER];
IF NOT LIB$TPARSE (TPARSE_BLOCK, STRUCTURE_STB, STRUCTURE_KTB)
THEN
    ERR_EXIT (INIT$_BADSTRUCT);

END;					! end of routine STRUCTURE_ACT

!
! Get volume user name
!
ROUTINE USER_NAME_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

! Store the descriptor for the volume USER_NAME.
!

CH$FILL ( 0, DSC$C_S_BLN, USER_NAME );
USER_NAME[DSC$B_CLASS] = DSC$K_CLASS_D;
CLI$GET_VALUE ( USER_DESC, USER_NAME );

END;					! end of routine USER_NAME_ACT

!
! Store index file LBN
!
ROUTINE GET_INDEX_LBN =
BEGIN

TPARSE_ARGS (CONTEXT);

INDEX = .CONTEXT[TPA$L_NUMBER];
RETURN 1;

END;					! end of routine GET_INDEX_LBN

!
! Store bad block LBN or sector number.
!
ROUTINE GET_BAD_LBN =
BEGIN

TPARSE_ARGS (CONTEXT);

IF .BADBLOCK_COUNT GEQ BAD_TABLE_LEN
THEN ERR_EXIT (INIT$_MAXBAD);
BADBLOCK_TABLE[.BADBLOCK_COUNT, BAD_LBN] = .CONTEXT[TPA$L_NUMBER];
BADBLOCK_TABLE[.BADBLOCK_COUNT, BAD_COUNT] = 1;
BADBLOCK_COUNT = .BADBLOCK_COUNT + 1;
RETURN 1;

END;					! end of routine GET_BAD_LBN

!
! Store bad block track number.
!
ROUTINE GET_BAD_TRACK =
BEGIN

TPARSE_ARGS (CONTEXT);

BADBLOCK_TABLE[.BADBLOCK_COUNT-1, BAD_TRACK] = .CONTEXT[TPA$L_NUMBER];
BADBLOCK_TABLE[.BADBLOCK_COUNT-1, BAD_STC_FORM] = 1;
RETURN 1;

END;					! end of routine GET_BAD_TRACK

!
! Store bad block cylinder number.
!
ROUTINE GET_BAD_CYL =
BEGIN

TPARSE_ARGS (CONTEXT);

BADBLOCK_TABLE[.BADBLOCK_COUNT-1, BAD_CYLINDER] = .CONTEXT[TPA$L_NUMBER];
RETURN 1;

END;					! end of routine GET_BAD_CYL

!
! Store bad block count.
!
ROUTINE GET_BAD_COUNT =
BEGIN

TPARSE_ARGS (CONTEXT);

BADBLOCK_TABLE[.BADBLOCK_COUNT-1, BAD_COUNT] = .CONTEXT[TPA$L_NUMBER];
IF .CONTEXT[TPA$L_NUMBER] EQL 0
THEN ERR_EXIT (INIT$_BADBLOCKS);
RETURN 1;

END;					! end of routine GET_BAD_COUNT

!
! Determine if ANSI VOL1 accessibility character is an ANSI 'a' character
!
ROUTINE GET_VOL_ACC =
BEGIN

TPARSE_ARGS (CONTEXT);

VOL_ACC = .(.CONTEXT[TPA$L_TOKENPTR]);
SELECTONE .VOL_ACC OF
    SET
    ['A' TO 'Z'] :;
    [' ' TO '"'] :;
    ['%' TO '?'] :;
    ['_']:;
    ['a' TO 'z'] : VOL_ACC = .VOL_ACC - ( 'a' - 'A' );	! uppercase
    [OTHERWISE]  : ERR_EXIT (INIT$_BADVOLACC);
    TES;
RETURN 1;
END;

!
! Determine if ANSI VOL1 OWNER IDENTIFIER is ANSI "a" characters
!
ROUTINE FORMAT_VOL_OWNER =
BEGIN

LOCAL 
	TEMP : BYTE,
	J,
	I;

TPARSE_ARGS (CONTEXT);

CH$FILL (' ',14,VOL_OWNER);
J = 0;
I = 0;
TEMP = .(.CONTEXT[TPA$L_TOKENPTR]);
IF NOT (.TEMP EQL ',')
   THEN 
   BEGIN
	CH$MOVE (.CONTEXT[TPA$L_TOKENCNT], .CONTEXT[TPA$L_TOKENPTR], 
	    DATA_PTR[.DATA_INDEX]);
	DATA_INDEX = .DATA_INDEX + .CONTEXT[TPA$L_TOKENCNT];
   END;
WHILE .I LEQ (.DATA_INDEX - 1) DO
   BEGIN
	LOCAL CHAR : BYTE;
	CHAR = .DATA_PTR[.I];
	SELECTONE .CHAR OF
	    SET
	    ['A' TO 'Z'] :;
	    [' ' TO '"'] :;
	    ['%' TO '?'] :;
	    ['_']:;
	    ['a' TO 'z'] : CHAR = .CHAR - ( 'a' - 'A' ); ! uppercase
	    [OTHERWISE]  : ERR_EXIT (INIT$_BADOWNID);
	    TES;
	IF (.CHAR EQL '"') AND (.I EQL (.DATA_INDEX - 1))
	   THEN RETURN 1;
	IF NOT ((.CHAR EQL '"') AND (.I EQL 0))
	   THEN
	   BEGIN
		VOL_OWNER[.J] = .CHAR;
		J = .J + 1;
		IF NOT (.CHAR EQL '"' AND .DATA_PTR[.I+1] EQL '"')
		   THEN	I = .I + 1 
		   ELSE	I = .I + 2;
	   END
	   ELSE I = .I + 1;

   END;
RETURN 1;
END;

ROUTINE MOVE_CHAR=
BEGIN

LOCAL 
	TEMP_DATA_INDEX;

TPARSE_ARGS (CONTEXT);
TEMP_DATA_INDEX = .DATA_INDEX + .CONTEXT[TPA$L_TOKENCNT];
IF .TEMP_DATA_INDEX GTR 32
THEN
    ERR_EXIT(INIT$_BADOWNID);
CH$MOVE (.CONTEXT[TPA$L_TOKENCNT], .CONTEXT[TPA$L_TOKENPTR], DATA_PTR[.DATA_INDEX]);
DATA_INDEX = .TEMP_DATA_INDEX;
RETURN 1;
END;

!+
!
! TPARSE state tables to parse the various qualifier value strings.
!
!-

!
! Parse magtape density (either "800", "1600", or "6250").
!  Also for floppy disks only (either "SINGLE" or "DOUBLE").
!
$INIT_STATE (DENSITY_STB, DENSITY_KTB);

$STATE	(,
	('6250',,, 1^(OPT_DENS_6250 - 32), INIT_OPTIONS + 4),
	('1600',,, 1^(OPT_DENS_1600 - 32), INIT_OPTIONS + 4),
	('800',,, 1^OPT_DENS_800, INIT_OPTIONS),
	('SINGLE',,, 1^(OPT_DENS_SING - 32), INIT_OPTIONS + 4),
	('DOUBLE',,, 1^(OPT_DENS_DOUB - 32), INIT_OPTIONS + 4)
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);
!
! Parse disk structure level (either "1" or "2").
!
$INIT_STATE (STRUCTURE_STB, STRUCTURE_KTB);

$STATE	(,
	('1',,, 1^OPT_STRUCTURE1, INIT_OPTIONS),
	('2')
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);
!
! PARSE OVERRIDE QUALIFIERS (EXPIRATION)
!
$INIT_STATE(OVERRIDE_STB, OVERRIDE_KTB);

$STATE	(NEXTOVR,
	('EXPIRATION',,,1^OPT_OVR_EXP,INIT_OPTIONS),
	('ACCESSIBILITY',,,1^OPT_OVR_ACC,INIT_OPTIONS),
	('OWNER_IDENTIFIER',,,1^(OPT_OVR_VOLO-32),INIT_OPTIONS+4)
	);


$STATE	(,
	(',',NEXTOVR),
	(TPA$_EOS,TPA$_EXIT)
	);
!
! Parse protection string "(SYSTEM:RWED,OWNER:RWED,GROUP:RWED,WORLD:RWED)"
!
$INIT_STATE (PROTECTION_STB, PROTECTION_KTB);

$STATE	(NEXTPRO,
	('SYSTEM', SYPR,, %X'000F0000', PROT_VAL),
	('OWNER',  OWPR,, %X'00F00000', PROT_VAL),
	('GROUP',  GRPR,, %X'0F000000', PROT_VAL),
	('WORLD',  WOPR,, %X'F0000000', PROT_VAL)
	);

$STATE	(SYPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(SYPR0,
	('R', SYPR0,, %X'0001', PROT_VAL),
	('W', SYPR0,, %X'0002', PROT_VAL),
	('E', SYPR0,, %X'0004', PROT_VAL),
	('D', SYPR0,, %X'0008', PROT_VAL),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(OWPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(OWPR0,
	('R', OWPR0,, %X'0010', PROT_VAL),
	('W', OWPR0,, %X'0020', PROT_VAL),
	('E', OWPR0,, %X'0040', PROT_VAL),
	('D', OWPR0,, %X'0080', PROT_VAL),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(GRPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(GRPR0,
	('R', GRPR0,, %X'0100', PROT_VAL),
	('W', GRPR0,, %X'0200', PROT_VAL),
	('E', GRPR0,, %X'0400', PROT_VAL),
	('D', GRPR0,, %X'0800', PROT_VAL),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(WOPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(WOPR0,
	('R', WOPR0,, %X'1000', PROT_VAL),
	('W', WOPR0,, %X'2000', PROT_VAL),
	('E', WOPR0,, %X'4000', PROT_VAL),
	('D', WOPR0,, %X'8000', PROT_VAL),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(ENDPRO,
	(',', NEXTPRO),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse UIC string and store binary value.
!
$INIT_STATE (UIC_STB, UIC_KTB);

$STATE	(,
	(TPA$_IDENT,,,,OWNER_UIC)
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse INDEX options (BEGINNING, MIDDLE, END, OR n)
!
$INIT_STATE (INDEX_STB, INDEX_KTB);

$STATE	(,
	('BEGINNING',,, 1^OPT_INDEX_BEG, INIT_OPTIONS),
	('MIDDLE',,, 1^OPT_INDEX_MID, INIT_OPTIONS),
	('END',,, 1^OPT_INDEX_END, INIT_OPTIONS),
	(TPA$_DECIMAL,, GET_INDEX_LBN, 1^OPT_INDEX_LBN, INIT_OPTIONS)
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);
!
! Parse data check options, of the form [READ][,WRITE]. Default is write.
!
$INIT_STATE (DATACHECK_STB, DATACHECK_KTB);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT,, 1^OPT_WRITECHECK, INIT_OPTIONS),
	(TPA$_LAMBDA)
	);

$STATE	(CHECKOPT,
	('READ',,, 1^OPT_READCHECK, INIT_OPTIONS),
	('WRITE',,, 1^OPT_WRITECHECK, INIT_OPTIONS)
	);

$STATE	(,
	(',', CHECKOPT),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse bad block data, consisting of entries of the form LBN:count or
! sector.track.cylinder:count, separated by commas.
!
$INIT_STATE (BADBLOCKS_STB, BADBLOCKS_KTB);

$STATE	(NEXTBLK,
	(TPA$_DECIMAL,, GET_BAD_LBN)
	);

$STATE	(,
	('.', TRACK),
	(TPA$_LAMBDA)
	);

$STATE	(COLON,
	(':', BLKCNT),
	(TPA$_LAMBDA)
	);

$STATE	(BLKEND,
	(',', NEXTBLK),
	(TPA$_EOS, TPA$_EXIT)
	);

$STATE	(BLKCNT,
	(TPA$_DECIMAL, BLKEND, GET_BAD_COUNT)
	);

$STATE	(TRACK,
	(TPA$_DECIMAL,, GET_BAD_TRACK)
	);

$STATE	(,
	('.')
	);

$STATE	(,
	(TPA$_DECIMAL, COLON, GET_BAD_CYL)
	);

!
! Parse LABEL option VOLUME_ACCESSIBILITY = "x" and OWNER_IDENTIFIER = "vol_owner"
!
$INIT_STATE (LABEL_QUAL_STB, LABEL_QUAL_KTB);

$STATE	(LABEL_QUAL,
	('VOLUME_ACCESSIBILITY',VOLUME,, 1^(OPT_LABEL_QUAL-32), INIT_OPTIONS+4),
	('OWNER_IDENTIFIER',OWNER,, 1^(OPT_VOL_OWNER-32), INIT_OPTIONS+4)
	);

$STATE	(VOLUME,
	(':',VALUEVOLACC),
	('=',VALUEVOLACC)
	);

$STATE	(VALUEVOLACC,
	(TPA$_ANY,DONE,GET_VOL_ACC)
	);

$STATE	(OWNER,
	(':',VALUEOWNER,),
	('=',VALUEOWNER,)
	);

$STATE	(VALUEOWNER,
	('"',ANSI_VOLO,MOVE_CHAR),
	(',',LABEL_QUAL,FORMAT_VOL_OWNER),
	(TPA$_SYMBOL,DONE,FORMAT_VOL_OWNER),
	(TPA$_LAMBDA,DONE,FORMAT_VOL_OWNER)
	);

$STATE	(ANSI_VOLO,
	('"',VALUEOWNER,MOVE_CHAR),
	(TPA$_ANY,ANSI_VOLO,MOVE_CHAR),
	(TPA$_EOS,TPA$_EXIT)
	);

$STATE	(DONE,
	(',',LABEL_QUAL),
	(TPA$_EOS, TPA$_EXIT)
	);

END
ELUDOM
