MODULE DBGSYMBLZ (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Victoria Holt	July, 1982
!
! MODIFIED BY:
!	R. Title                    \
!			Nov, 1982    >	Added DBG$SYMID_TO_PRIMARY routine
!	P. Sager                    /
!
!	P. Sager	Dec, 1982   Rework parts of this module to work better
!				    for symbolization.
!	R. Title	Feb 1983    Added DUMP_SAT and DUMP_GLOBAL routines
!				    to aid in performance studies.
!	R. Title	May 1983    Redesigned SAT as tree instead of linked
!				    list. Wrote SEARCH_BIN_SAT and SEARCH_PROG_SAT
!				    to utilize new data structure.
!	W. Carrell	Sep 1983    Update DBG$CURRENT_PRIMARY for self_referential 
!				    records
!
! MODULE FUNCTION
!	This module contains all the routines necessary for parsing and
!	executing the SYMBOLIZE command.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$NEXECUTE_SYMBOLIZE,		! Performs action of SYMBOLIZE xxx.
    DBG$NPARSE_SYMBOLIZE,		! Establishes parse network.
    DBG$SEARCH_BIN_SAT,			! Search module-level SAT
    DBG$SEARCH_PROG_SAT,		! Search program-level SAT
    DBG$SEARCH_BIN_SAT_REC,		! Recursive search-sat routine
    DBG$SEARCH_PROG_SAT_REC,		! Recursive search-sat routine
    DBG$SEARCH_GLOBAL,			! Searches Global Symbol Chain
    DBG$DUMP_GLOBAL: NOVALUE,		! Counts length of Global Symbol Chain
    DBG$SEARCH_SAT,			! Searches SAT to symbolize address.
    DBG$DUMP_SAT: NOVALUE,		! Dump information about SAT
    DBG$SEARCH_VAX_CALL_STACK,		! Searches VAX call stack.
    DBG$SYMBOLIZE_REG,			! Attempts to symbolize register addr.
    DBG$SYMID_TO_PRIMARY,		! Turns SYMID,OFFSET into Primary
    DBG$NEW_SYMBOLIZE,			! New symbolization routine
    DBG$PC_TO_SYMID,			! Given address, search Module SAT or
					!	Global symbol chain for RST
    FIND_ROUTINE,			! Finds routine corresponding to PC.
    GET_ADDRESS_DESC,			! Return Address Descriptor from given
					!	address representation
    GSTADDRESS,				! Get GST's address
    IS_SYMBOL_BOUND_TO_REG,		! Determines if symbol is bound to reg.
    IS_SYMBOL_PSECT,			! Determines if symbol is PSECT
    PRINT_REGNAME:  NOVALUE,		! Encodes register into output buffer.
    SEARCH_MODULE_SAT:  NOVALUE,	! Searches module level SAT for addr.
    BUILD_PRIMARY_SUBNODE,		! Build primary subnode
    GET_RECORD_COMPONENT,		! Get the record component from the list
    SYMBOLIZE_ARRAY_ELEMENT,		! Symbolize to array element
    SYMBOLIZE_RECORD_COMPONENT;		! Symbolize to record component

EXTERNAL ROUTINE
    DBG$BUILD_INVOC_RST,		! Build RST entry with invocation num
    DBG$BUILD_PRIMARY_SUBNODE: NOVALUE,	! Build a subnode for a Primary
    DBG$GET_TEMPMEM,			! Dynamic memory allocation.
    DBG$GET_DST_NAME,			! Get the name from DST record
    DBG$MAKE_SKELETON_DESC,
    DBG$NEWLINE:  NOVALUE,		! Flush current print line.
    DBG$NGET_ADDRESS,			! Obtains an address from an address
					! expression descriptor.
    DBG$NMAKE_ARG_VECT,			! Sets up message vector.
    DBG$NMATCH,				! Matches input to counted strings.
    DBG$NNEXT_WORD,			! Obtains next word of input.
    DBG$NPARSE_ADDRESS,			! Parses input and returns an AED.
    DBG$PC_TO_LINE_LOOKUP,		! Looks up line no. for PC addr.
    DBG$PRIM_TO_VAL: NOVALUE,		! Turn Primary into Value
    DBG$PRINT:  NOVALUE,		! Print/format ASCII text.
    DBG$PRINT_CONTROL:  NOVALUE,	! Sets up tabs for DBG$PRINT.
    DBG$PRINT_OFFSET:  NOVALUE,		! Prints value in correct radix.
    DBG$PRINT_SYMBOL_PATHNAME: NOVALUE, ! Print symbol name with pathname
    DBG$STA_ADDRESS_TO_REGDESCR,	! Return Register Descriptor for register
					!	address
    DBG$STA_GETSYMOFF,			! Convert addr. to symbol and offset.
    DBG$STA_LINE_NUM_RST,		! Build RST Entry for line number
    DBG$STA_REGISTER_NAME,		! Convert Register Descriptor into ASCIC
					!	name string for the register
    DBG$STA_SETCONTEXT: NOVALUE,	! Set the context for given SYMID
    DBG$STA_SYMKIND: NOVALUE,		! Obtains "kind" of a symbol
    DBG$STA_SYMNAME:  NOVALUE,		! Translates symid to unqualified name.
    DBG$STA_SYMSIZE:  NOVALUE,		! Returns size associated with symid.
    DBG$STA_SYMTYPE: NOVALUE,		! Determine TYPEID from SYMID
    DBG$STA_SYMVALUE: NOVALUE,		! Get the value kind and value
    DBG$STA_TYP_RECORD,			! Get info about record
    DBG$STA_TYPEFCODE,			! Obtain FCODE from SYMID
    DBG$STA_VARIANT_SELECT,		! Get a pointer to a variant set RST
    SYS$FAO;				! Formatter.

EXTERNAL
    DBG$GL_CURRENT_PRIMARY,		! Pointer to the primary being processed
    DBG$GB_RADIX: VECTOR[3, BYTE],	! Radix settings
    DBG$GL_ARRSUB_FLAG,			! Used for controling array subscripting
    DBG$GL_RECCMP_FLAG,			! Used for controling record component
    DBG$GB_LANGUAGE: BYTE,		! Current language setting
    DBG$FINAL_HANDL,			! Call frame exception handler.
    DBG$REG_VALUES:  VECTOR[, LONG],    ! Vector of user register values in the
					! current context.
    DBG$RUNFRAME:    BLOCK[, BYTE],	! The current user run frame.
    RST$START_ADDR:  REF RST$ENTRY,	! Ptr to 1st module RST entry.
    SAT$START_ADDR;			! Address of 1st SAT entry on program
					! SAT chain.

LITERAL
    TAB	= 4;				! Indentation level for DBG$PRINT_CONTROL.

OWN
    OWN_MODULE_BEGIN,			! Begin address of the module
    OWN_MODULE_END;			! End address of the module


MACRO
    PRINT_BIT_OFFSET(BIT_OFFSET) =
	IF .BIT_OFFSET NEQ 0
	THEN
	    BEGIN
	    DBG$PRINT (UPLIT BYTE (%ASCIC '<'));
	    DBG$PRINT (UPLIT BYTE (%ASCIC '!UL'), .BIT_OFFSET);
	    DBG$PRINT (UPLIT BYTE (%ASCIC ', 0, 0>'));
	    END;%;


GLOBAL ROUTINE DBG$NEXECUTE_SYMBOLIZE (VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine performs the action associated with the SYMBOLIZE xxx
!	command.
!
!	A virtual address is obtained from the command execution tree.  From
!	there, the routine determines what kind of address it is:  a register
!	address, static address, or stack address.  After making that
!	determination, the routine attempts to locate symbols bound to that
!	address by searching the set module chain (in the case of a register
!	address), by searching the SAT (in the case of a static address), or by
!	searching the call stack (in the case of a stack address).  (Symbols
!	whose addresses are too complicated to compute in this last search are
!	ignored.)  Finally the Global Symbol Chain is searched.
!
! INPUTS
!	VERB_NODE	   - A longword containing the address of the command
!			     execution tree verb node.
!
!	MESSAGE_VECT	   - The address of a longword to contain the address
!			     of a standard message argument vector on error.
!
! OUTPUTS
!	An unsigned integer longword completion code.
!
!	On success, all possible symbolizations for the virtual address are
!	    sent to the output device.
!
!	On failure (no symbolization found), a message to that effect is printed.
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;		! Ptr to verb node.


    LOCAL
	ADDRESS_DESC: REF DBG$ADDRESS_DESC,	! Address descriptor.
	BIT_OFFSET,				! Bit offset from SYMID
	NOUN_NODE: REF DBG$NOUN_NODE,		! Ptr to noun node.
	SYMID: REF RST$ENTRY;			! Unique symbol identifier.


    ! Recover the noun node.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];


    ! Loop through tree.
    !
    WHILE .NOUN_NODE NEQ 0 DO
	BEGIN


	! Set up tabs.
	!
	DBG$PRINT_CONTROL (DBG$K_PRT_RESET);


	! Recover address descriptor.
	!
	ADDRESS_DESC = .NOUN_NODE[DBG$L_NOUN_VALUE];


	! Call the routine that actually does all the work.
	! If no symbolization is possible for the address, print a message to
	! that effect.
	!
	IF NOT DBG$STA_GETSYMOFF (.ADDRESS_DESC, SYMID, BIT_OFFSET, TRUE)
	THEN
	    BEGIN
	    DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS_DESC[DBG$L_ADDRESS_BYTE_ADDR]);
	    PRINT_BIT_OFFSET(ADDRESS_DESC[DBG$L_ADDRESS_BIT_OFFSET]);
	    DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
	    DBG$NEWLINE();
	    DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
	    DBG$PRINT (UPLIT BYTE (%ASCIC 'no symbolization'), 0);
	    DBG$NEWLINE();
	    END;


	! Get next noun node.
	!
	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];
	END;


    ! Routine end.
    !
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NPARSE_SYMBOLIZE (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	Establishes the parse network for the SYMBOLIZE command, consisting of
!	a verb_node and a linked list of noun nodes.  Each noun node points to
!	an address that is to be symbolized, if possible.
!
! INPUTS
!	INPUT_DESC	- a longword containing the address of the command
!			  input descriptor.  This should point to the first
!			  character after the SYMBOLIZE keyword.
!
!	VERB_NODE	- A longword containing the address of the command
!			  execution tree verb node.
!
!	MESSAGE_VECT	- The address of a longword to contain the address
!			  of a standard message argument vector on error.
!
! OUTPUTS
!	An unsigned integer longword completion code.
!
!	The pointer to the input descriptor is advanced to the end of the
!	    complete symbolize command.  Normally this means pointing to the
!	    terminating carriage return.
!
!	On success, the command execution tree is constructed; ie, noun nodes
!	    containing the addresses descriptor to be symbolized are linked to
!	    the verb node.
!
!	On failure, the routine signals an error.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK [,BYTE],		! Ptr. to input desc.
	VERB_NODE: REF DBG$VERB_NODE;		! Ptr. to verb node.

    LOCAL
	ADDRPTR,				! Pointer to an address
						!       representation
	ADDRESS_DESC: REF DBG$ADDRESS_DESC,	! Pointer to an Addr. Desc.
	NOUN_NODE: REF DBG$NOUN_NODE,		! Object of verb
	NEXT_NOUN_NODE: REF DBG$NOUN_NODE,	! Temporary object.
	STATUS;


    BIND
	DBG$CS_CR	= UPLIT BYTE (1, DBG$K_CAR_RETURN),
	DBG$CS_COMMA	= UPLIT BYTE (1, DBG$K_COMMA);


    ! Need to be sure that the user has provided some sort of input after
    ! the verb.  If not, construct message_vect and return.
    !
    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	SIGNAL (DBG$_NEEDMORE);


    ! Construct the first noun node.
    !
    NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);


    ! Link in the noun node.
    !
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;


    ! Loop until input is exhausted.
    !
    WHILE (NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)) AND
	(.INPUT_DESC[DSC$W_LENGTH] NEQ 0) DO
	BEGIN


	! Attempt to parse the input_desc.  If successful, dbg$nparse_address
	! returns the address of an address expression descriptor.
	!
	STATUS = DBG$NPARSE_ADDRESS (.INPUT_DESC, ADDRPTR, 
    			.DBG$GB_RADIX[DBG$B_RADIX_INPUT],
			TOKEN$K_TERM_COMMA, .MESSAGE_VECT);
	SELECTONE .STATUS OF
	    SET


	    ! If successful, then get the address bound to the entity
	    ! described by the address expression descriptor.  Success
	    ! also implies the end of input.
	    !
	    [STS$K_SUCCESS]:
		BEGIN
		ADDRESS_DESC = DBG$GET_TEMPMEM (DBG$K_ADDRESS_DESC_SIZE);
		IF NOT GET_ADDRESS_DESC (.ADDRPTR, .ADDRESS_DESC, .MESSAGE_VECT)
		THEN
		    RETURN STS$K_SEVERE;
		NOUN_NODE[DBG$L_NOUN_VALUE] = .ADDRESS_DESC;
		END;


	    ! If a warning is returned, a comma may have been discovered in
	    ! the input stream.  Check for this.  If there is no comma, a
	    ! syntax error has occurred.  If a comma is present, there must
	    ! be more input or else error.  If all is OK, then get the address
	    ! bound to the entity described by the address expression
	    ! descriptor.  A warning implies further input, so must link in
	    ! another noun node.
	    !
	    [STS$K_WARNING]:
		BEGIN
		IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_COMMA, 1)
		THEN
		    SIGNAL (DBG$_CMDSYNERR, 1, DBG$NNEXT_WORD (.INPUT_DESC));

		IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
		THEN
		    SIGNAL (DBG$_NEEDMORE);

		ADDRESS_DESC = DBG$GET_TEMPMEM (DBG$K_ADDRESS_DESC_SIZE);
		IF NOT GET_ADDRESS_DESC (.ADDRPTR, .ADDRESS_DESC, .MESSAGE_VECT)
		THEN
		    RETURN STS$K_SEVERE;
		NOUN_NODE[DBG$L_NOUN_VALUE] = .ADDRESS_DESC;
		NEXT_NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);
		NOUN_NODE[DBG$L_NOUN_LINK] = .NEXT_NOUN_NODE;
		NOUN_NODE = .NEXT_NOUN_NODE;
		END;


	    ! Anything else, return severe error.
	    !
	    [OTHERWISE]:
		BEGIN
		RETURN STS$K_SEVERE;
		END;

	    TES;


	! End of WHILE loop.
	!
	END;


    ! End of routine.
    !
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$SEARCH_BIN_SAT (BASE_NODE, ADDRESS, 
    				   MACRO_OR_SHARE_FLAG, PSECT_FLAG)=
!
! FUNCTION
!	This routine searches a linked SAT list starting at BASE_NODE
!	and returns a pointer to a SAT entry containing ADDRESS (or zero
!	if no SAT entry was found).
!
!	This routine is called to search a module-level SAT. It is called
!	by DBG$SEARCH_PROG_SAT.
!
!	The SAT chain that this routine searches is a linked list which
!	is sorted by start address of the symbol. We just loop through
!	the list looking for the static symbol which contains the given
!	address and is the best match.
!
!	On a linear SAT, which we currently have,
!	this routine is functionally equivalent to DBG$SEARCH_BIN_SAT_REC.
!	The _REC routine is more general in that it also accepts a SAT
!	which is organized as a binary tree. However, until we start
!	building binary tree SATs, we will stick with this routine.
!	The _REC routine differs in implementation in that it is recursive,
!	which can be a problem in that it uses a lot of stack.
!
! INPUTS
!	BASE_NODE - 	The base of the SAT list
!	ADDRESS	  - 	The desired address.
!	MACRO_OR_SHARE_FLAG-	True for language MACRO and also true
!    			for static address chains that come from shareable
!			images.
!	PSECT_FLAG-	Says whether it is OK to symbolize to a PSECT.
!
! OUTPUTS
!	A pointer to the found SAT entry is returned.
!	Zero is returned if no SAT entry was found.
!
    BEGIN
    LOCAL
    	BEST_SATPTR: REF SAT$ENTRY,
    	SATPTR: REF SAT$ENTRY;	


    ! Loop through the SAT chain.
    !
    BEST_SATPTR = 0;
    SATPTR = .BASE_NODE;
    WHILE .SATPTR NEQ 0 DO
    	BEGIN


    	! If the address we are looking for is before the current SAT entry
    	! then stop searching.
    	!
    	IF .ADDRESS LSSA .SATPTR[SAT$L_START]
        THEN
    	    EXITLOOP;


    	! Choose this symbol if its range covers the address. Don't choose
    	! psects unless PSECT_FLAG is set. Don't check the end address
    	! for language MACRO or for symbols from shareable images.
    	!
    	IF .PSECT_FLAG OR (NOT IS_SYMBOL_PSECT(.SATPTR[SAT$L_RSTPTR]))
    	THEN
    	    IF .MACRO_OR_SHARE_FLAG OR (.ADDRESS LEQA .SATPTR[SAT$L_END])
    	    THEN
    	        BEST_SATPTR = .SATPTR;


    	! Link to next SAT entry.
    	!
    	SATPTR = .SATPTR[SAT$L_FLINK];
    	END;


    ! Return the SATPTR we have found. This will be zero if we
    ! fell out of the loop not finding a match.
    !
    RETURN .BEST_SATPTR;
    END;

GLOBAL ROUTINE DBG$SEARCH_PROG_SAT (BASE_NODE, ADDRESS, BYTE_OFFSET) =
!
! FUNCTION
!	This routine searches the program-level
!	SAT list starting at BASE_NODE
!	and returns a pointer to the SAT entry which contains ADDRESS 
!	and whose start address is closest to ADDRESS. (or zero
!	if no SAT entry was found).
!
!	This routine walks the linear list of program-level SATs, finding
!	one whose range covers the given address. Then, for each one of
!	those that it finds, it calls DBG$SEARCH_BIN_SAT to search the
!	module-level SAT for the closest symbol whose address range
!	covers the given address.
!
!	On a linear SAT, which we currently have,
!	this routine is functionally equivalent to DBG$SEARCH_PROG_SAT_REC.
!	The _REC routine is more general in that it also accepts a SAT
!	which is organized as a binary tree. However, until we start
!	building binary tree SATs, we will stick with this routine.
!	The _REC routine differs in implementation in that it is recursive,
!	which can be a problem in that it uses a lot of stack.
!
! INPUTS
!	BASE_NODE - 	The base of the SAT list
!	ADDRESS	  - 	The desired address.
!	BYTE_OFFSET - 	Return the byte offset associated with the symbolization
!			   in this address.
!
! OUTPUTS
!	A pointer to the found SAT entry is returned.
!	Zero is returned if no SAT entry was found.
!
    BEGIN
    LOCAL
    	BEST_SATPTR: REF SAT$ENTRY,
    	BEST_OFFSET,
    	OFFSET,
    	MODRSTPTR: REF RST$ENTRY,
    	SATPTR: REF SAT$ENTRY,
    	TEMP_SATPTR: REF SAT$ENTRY;


    ! Loop through the SAT chain.
    !
    BEST_SATPTR = 0;
    BEST_OFFSET = 999999999;
    SATPTR = .BASE_NODE;
    WHILE .SATPTR NEQ 0 DO
    	BEGIN


    	! If the address we are looking for is before the current SAT entry
    	! then terminate the search.
    	!
    	IF .ADDRESS LSSA .SATPTR[SAT$L_START]
    	THEN
    	    EXITLOOP;


    	! If the address we are looking for lies within the current 
    	! program-level SAT then search the module-level SAT.
    	!
    	IF .ADDRESS LEQA .SATPTR[SAT$L_END]
    	THEN
    	    BEGIN
    	    MODRSTPTR = .SATPTR[SAT$L_RSTPTR];
    	    IF .MODRSTPTR[RST$V_MODSET]
    	    THEN
    		BEGIN
    	        TEMP_SATPTR = DBG$SEARCH_BIN_SAT (
    			         .MODRSTPTR[RST$L_SAT_PTR], 
    			         .ADDRESS,
    			         (.MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO) OR
    			          .MODRSTPTR[RST$V_SHARE_IMAGE],
    			          FALSE);

    		! If the module-level search yielded a candidate, choose
    		! it if it is a closer match than the best so far.
    		!
    		IF .TEMP_SATPTR NEQ 0
    		THEN
    		    BEGIN
       	            OFFSET = .ADDRESS - .TEMP_SATPTR[SAT$L_START];
    		    IF .OFFSET LSS .BEST_OFFSET
    		    THEN
    		        BEGIN
    		        BEST_SATPTR = .TEMP_SATPTR;
    		        BEST_OFFSET = .OFFSET;
    		        END
    		    ELSE IF .OFFSET EQL .BEST_OFFSET
    		    THEN
    			BEGIN
    			IF .TEMP_SATPTR[SAT$L_END] LSS .BEST_SATPTR[SAT$L_END]
    			THEN	
    		            BEGIN
    		            BEST_SATPTR = .TEMP_SATPTR;
    		            BEST_OFFSET = .OFFSET;
    			    END;
    			END;
    		    END;
    		END;
    	    END;

    	! Link to the next SATPTR and loop.
    	!
    	SATPTR = .SATPTR[SAT$L_FLINK];
    	END;

    ! Return the best candidate.
    !
    IF .BEST_SATPTR NEQ 0
    THEN
    	.BYTE_OFFSET = .BEST_OFFSET;
    RETURN .BEST_SATPTR;
    END;

GLOBAL ROUTINE DBG$SEARCH_BIN_SAT_REC (BASE_NODE, ADDRESS, 
    				       MACRO_OR_SHARE_FLAG, PSECT_FLAG)=
!
! FUNCTION
!	This routine searches the binary SAT tree starting at BASE_NODE
!	and returns a pointer to a SAT entry containing ADDRESS (or zero
!	if no SAT entry was found).
!
!	This routine is called to search a module-level SAT. It is called
!	by DBG$SEARCH_PROG_SAT.
!
!	The tree is organized so that at any point in the search, if we
!	are at node NODE, then: If the desired address is less than the
!	range in NODE, then follow the RIGHT_SON link. If the desired
!	address is greater than the range in NODE, then follow the
!	LEFT_SON link. If we try to follow a link and the link is zero
!	then we failed to find a matching SAT entry.
!	If the address is in the range, then of course we are done.
!
!	This routine is designed so that it will work on the "old" linear
!	list data structure (this just being the extreme case of an
!	unbalanced tree). However, for now we are still calling the
!	old non-recursive search_sat routines. This one is not yet
!	being used.
!
! INPUTS
!	BASE_NODE - 	The base of the SAT tree
!	ADDRESS	  - 	The desired address.
!	MACRO_OR_SHARE_FLAG-	True for language MACRO and also true
!    			for static address chains that come from shareable
!			images.
!	PSECT_FLAG-	Says whether it is OK to symbolize to a PSECT.
!
! OUTPUTS
!	A pointer to the found SAT entry is returned.
!	Zero is returned if no SAT entry was found.
!
    BEGIN
    MAP
    	BASE_NODE: REF SAT$ENTRY;
    LOCAL
    	SATPTR: REF SAT$ENTRY;	

    ! Bottom level of the recursion.
    !
    IF .BASE_NODE EQL 0
    THEN
    	RETURN 0;

    ! If the address we are looking for is before the current SAT entry
    ! then follow the left son.
    !
    IF .ADDRESS LSSA .BASE_NODE[SAT$L_START]
    THEN
        RETURN DBG$SEARCH_BIN_SAT_REC(.BASE_NODE[SAT$L_LEFTSON], .ADDRESS,
    				      .MACRO_OR_SHARE_FLAG, .PSECT_FLAG);

    ! If the address we are looking for falls after the start of the
    ! current SAT entry then follow the right son. If this search
    ! yields a matching SAT then return it.
    !
    SATPTR = DBG$SEARCH_BIN_SAT_REC(.BASE_NODE[SAT$L_RIGHTSON], .ADDRESS,
    				    .MACRO_OR_SHARE_FLAG, .PSECT_FLAG);
    IF .SATPTR NEQ 0
    THEN
        RETURN .SATPTR;

    ! Don't symbolize to PSECTs unless PSECT_FLAG is set.
    !
    IF (.PSECT_FLAG) OR
       (NOT IS_SYMBOL_PSECT (.BASE_NODE[SAT$L_RSTPTR]))
    THEN
        BEGIN

    	! Check for the address being in the range of the SAT entry.
    	! But, in language MACRO, choose this symbolization - don't
    	! do the check for the address being in the correct range.
    	! Also, don't do this check for shareable image modules.
    	! The reason is that in these cases we do not get the right
    	! length information for the static item.
    	!
        IF .MACRO_OR_SHARE_FLAG OR
    	  (.ADDRESS LEQA .BASE_NODE[SAT$L_END])
        THEN
    	    RETURN .BASE_NODE;
    	END;

    ! Failed to find a match. Return 0.
    !
    RETURN 0;
    END;

GLOBAL ROUTINE DBG$SEARCH_PROG_SAT_REC (BASE_NODE, ADDRESS, BYTE_OFFSET) =
!
! FUNCTION
!	This routine searches the binary program-level
!	SAT tree starting at BASE_NODE
!	and returns a pointer to the SAT entry which contains ADDRESS 
!	and whose start address is closest to ADDRESS. (or zero
!	if no SAT entry was found).
!
!	The tree is organized so that at any point in the search, if we
!	are at node NODE, then: If the desired address is less than the
!	range in NODE, then follow the LEFT_SON link. If the desired
!	address is greater than the range in NODE, then follow the
!	RIGHT_SON link. If we try to follow a link and the link is zero
!	then we terminate the search.
!
!	Once a candidate program-level SAT is found, this routine calls
!	SEARCH_BIN_SAT to search the module-level SAT.
!
!	This routine is designed so that it will work on the "old" linear
!	list data structure (this just being the extreme case of an
!	unbalanced tree). However, for now we are still calling the
!	old non-recursive search_sat routines. This one is not yet
!	being used.
!
!	The routine is intended to be a replacement for the DBG$SEARCH_SAT
!	routine.
!
! INPUTS
!	BASE_NODE - 	The base of the SAT tree
!	ADDRESS	  - 	The desired address.
!	BYTE_OFFSET - 	Return the byte offset associated with the symbolization
!			   in this address.
!
! OUTPUTS
!	A pointer to the found SAT entry is returned.
!	Zero is returned if no SAT entry was found.
!
    BEGIN
    MAP
    	BASE_NODE: REF SAT$ENTRY;

    LOCAL
    	OFFSET,
    	OFFSET_1,
    	MODRSTPTR: REF RST$ENTRY,
    	SATPTR: REF SAT$ENTRY,	
    	SATPTR_1: REF SAT$ENTRY;	

    ! Bottom level of the recursion.
    !
    IF .BASE_NODE EQL 0
    THEN
    	RETURN 0;

    ! If the address we are looking for is before the current SAT entry
    ! then follow the left son.
    !
    IF .ADDRESS LSSA .BASE_NODE[SAT$L_START]
    THEN
        RETURN DBG$SEARCH_PROG_SAT_REC(.BASE_NODE[SAT$L_LEFTSON], .ADDRESS,
    				       .BYTE_OFFSET);

    ! If the address we are looking for falls after the start of the
    ! current SAT entry then follow the right son. 
    !
    SATPTR = DBG$SEARCH_PROG_SAT_REC(.BASE_NODE[SAT$L_RIGHTSON], .ADDRESS, OFFSET);

    ! If the address we are looking for also lies within the current 
    ! program-level SAT then search the module-level SAT.
    !
    IF .ADDRESS LEQA .BASE_NODE[SAT$L_END]
    THEN
    	BEGIN
    	MODRSTPTR = .BASE_NODE[SAT$L_RSTPTR];
    	IF .MODRSTPTR[RST$V_MODSET]
    	THEN
    	    SATPTR_1 = DBG$SEARCH_BIN_SAT_REC (
    			.MODRSTPTR[RST$L_SAT_PTR], 
    			.ADDRESS,
    			(.MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO) OR
    			 .MODRSTPTR[RST$V_SHARE_IMAGE],
    			FALSE)
    	ELSE
    	    SATPTR_1 = 0;
        IF .SATPTR_1 NEQ 0
    	THEN
       	    OFFSET_1 = .ADDRESS - .SATPTR_1[SAT$L_START];
    	END;

    ! If both of our candidate SATPTR's are zero then we have failed
    ! to find a match so return zero.
    !
    IF (.SATPTR EQL 0) AND (.SATPTR_1 EQL 0)
    THEN
    	RETURN 0;

    ! If only one candidate is zero then return the other one.
    !
    IF .SATPTR EQL 0
    THEN
    	BEGIN
    	.BYTE_OFFSET = .OFFSET_1;
    	RETURN .SATPTR_1;
    	END;
    IF .SATPTR_1 EQL 0
    THEN
        BEGIN
    	.BYTE_OFFSET = .OFFSET;
    	RETURN .SATPTR;
    	END;

    ! Both are non-zero. Return the one with the smaller offset.
    !
    IF .OFFSET LSS .OFFSET_1
    THEN
        BEGIN
    	.BYTE_OFFSET = .OFFSET;
    	RETURN .SATPTR;
    	END;
    IF .OFFSET GTR .OFFSET_1
    THEN
    	BEGIN
        .BYTE_OFFSET = .OFFSET_1;
        RETURN .SATPTR_1;
    	END;
    
    ! The offsets are equal. Return the one with the smaller end address.
    ! 
    IF .SATPTR[SAT$L_END] LSS .SATPTR_1[SAT$L_END]
    THEN
        BEGIN
    	.BYTE_OFFSET = .OFFSET;
    	RETURN .SATPTR;
    	END
    ELSE
    	BEGIN
        .BYTE_OFFSET = .OFFSET_1;
        RETURN .SATPTR_1;
    	END;
    END;

GLOBAL ROUTINE DBG$SEARCH_GLOBAL(ADDR, P_SYMID, P_BIT_OFFSET, PRINT_FLAG) =
!
! FUNCTION
!	This routine searches the GLOBAL symbol chain in an attempt to
!	symbolize the address.
!
!	NOTE: This routine is searching the whole Global symbol chain
!	if the proper global symbol is not found.  If we can be sure
!	the global symbol chain is ordered.  We can stop the searching
!	as soon as we have passed the address range.
!
! INPUTS
!	ADDR		- Address Descriptor.
!
!	P_SYMID		- The address of a longword location to receive the
!			  unique symbol RST pointer.
!
!	P_BIT_OFFSET	- The bit offset off of P_SYMID.
!
!	PRINT_FLAG	- If false, no output will be done.  If true, then
!			  the symbolization of the virtual address will be
!			  output to the terminal.
!
! OUTPUTS
!	If successful, the routine prints the symbolization of the address
!	(if the print flag was set).  P_SYMID contains the RST pointer of
!	the symbol that matched.  P_BIT_OFFSET contains the bit offset.
!	The routine returns TRUE.  If the address is not found in the
!	global symbol chain, then P_SYMID is zero and P_BIT_OFFSET is set
!	to the bit offset field from ADDR.
!

    BEGIN

    MAP
	ADDR: REF DBG$ADDRESS_DESC;

    BIND
	SYMID		= .P_SYMID: REF RST$ENTRY,
	BIT_OFFSET	= .P_BIT_OFFSET;

    LOCAL
	ADDRESS,			! Byte Address
	BEST_MATCH_VALUE,		! The best match value we found
	BYTE_OFFSET,			! Byte offset
	DSTPTR: REF DST$RECORD,		! Pointer to DST record in GST
	GSTPTR: REF RST$ENTRY,		! GST RST pointer
	GST_VALUE,			! GST value
	NAME: REF VECTOR[,BYTE];	! Pointer to counted ASCII string


    ADDRESS = .ADDR[DBG$L_ADDRESS_BYTE_ADDR];
    BIT_OFFSET = .ADDR[DBG$L_ADDRESS_BIT_OFFSET];
    BYTE_OFFSET = 0;
    SYMID = 0;
    GSTPTR = .RST$START_ADDR[RST$L_SYMCHNPTR];
    WHILE TRUE DO
	BEGIN


	! Check to see if we have no more Global Symbols.
	!
	IF .GSTPTR EQL 0 THEN EXITLOOP;
	$ABORT_ON_CONTROL_Y;
	GST_VALUE = GSTADDRESS(.GSTPTR);


	! First check for an exact match because then
	! we can abandon any further looking.
	!
	IF .ADDRESS EQLA .GST_VALUE
	THEN
	    BEGIN
	    SYMID = .GSTPTR;
	    EXITLOOP;
	    END;


	! Inexact matches are still better than nothing.
	!
	IF .ADDRESS GTRA .GST_VALUE
	THEN
	    BEGIN


	    ! A match.  See if we already have one.  If we do not have
	    ! one, Any one is better than none.
	    !
	    IF .SYMID EQL 0
	    THEN
		SYMID = .GSTPTR


	    ! Take the new one only if this symbol
	    ! is closer than the previous best one.
	    !
	    ELSE
		BEGIN
		BEST_MATCH_VALUE = GSTADDRESS(.SYMID);
		IF .BEST_MATCH_VALUE  LSSA .GST_VALUE
		THEN
		    SYMID = .GSTPTR;
		END;

	    END;


	! Go back and process the next record.
	!
	GSTPTR = .GSTPTR[RST$L_SYMCHNPTR];
	END;


    ! If we didn't find any possible match,
    ! return failure status.
    !
    IF .SYMID EQL 0
    THEN
	RETURN 0;

    BEST_MATCH_VALUE = GSTADDRESS(.SYMID);
    BYTE_OFFSET = .ADDRESS - .BEST_MATCH_VALUE;
    IF .BYTE_OFFSET EQL .ADDRESS THEN RETURN 0;


    ! If the BEST_MATCH_VALUE is not in the range cover by the MODULE and
    ! if the offset is too large, don't take it.
    !
    IF .BYTE_OFFSET NEQ 0
    THEN
	BEGIN
	IF NOT (.ADDRESS GEQ .OWN_MODULE_BEGIN AND
		.ADDRESS LEQ .OWN_MODULE_END)
	THEN
	    BEGIN
	    IF .BYTE_OFFSET GTR %X'1000'
	    THEN
		BEGIN
		SYMID = 0;
		BYTE_OFFSET = 0;
		RETURN 0;
		END;

	    END;

	END;

    IF .PRINT_FLAG
    THEN
	BEGIN
	DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
	PRINT_BIT_OFFSET(BIT_OFFSET);
	DBG$PRINT (UPLIT BYTE(%ASCIC ': (global)'));
	DBG$NEWLINE();
	DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
	DSTPTR = .SYMID[RST$L_DSTPTR];
	NAME = DBG$GET_DST_NAME(.DSTPTR);
	DBG$PRINT (UPLIT BYTE(%ASCIC '!AC'), .NAME);
	IF .BYTE_OFFSET NEQ 0
	THEN
	    DBG$PRINT_OFFSET(.BYTE_OFFSET);
	PRINT_BIT_OFFSET(BIT_OFFSET);
	DBG$NEWLINE();
	END;

    BIT_OFFSET = .BIT_OFFSET + .BYTE_OFFSET * 8;
    RETURN TRUE;
    END;

GLOBAL ROUTINE DBG$DUMP_GLOBAL: NOVALUE =
!
! FUNCTION
!	This routine just counts the number of entries in the GST and
!	displays the information on the terminal. It is called by the
!	DUMP GST command (which is enabled by SET DEVELOPER 0) and can
!	be used as an aid in measuring DEBUG performance.
!
! INPUTS
!	none.
!
! OUTPUTS
!	Displays size of GST.
!
    BEGIN
    LOCAL
	COUNT,
	GSTPTR: REF RST$ENTRY;

    ! Loop through the GST, counting the number of entries.
    !
    GSTPTR = .RST$START_ADDR[RST$L_SYMCHNPTR];
    COUNT = 0;
    WHILE .GSTPTR NEQ 0 DO
	BEGIN
	COUNT = .COUNT + 1;
	GSTPTR = .GSTPTR[RST$L_SYMCHNPTR];
	END;

    ! Display the information.
    !
    DBG$PRINT(UPLIT BYTE (%ASCIC 'There are !UL entries in the GST'), .COUNT);
    DBG$NEWLINE();
    END;

GLOBAL ROUTINE DBG$SEARCH_SAT(ADDR, P_SYMID, P_BIT_OFFSET, PRINT_FLAG) =
!
! FUNCTION
!	This routine searches both the program level and the module level SAT in an
!	attempt to symbolize the input address.  If the address is found to be
!	an instruction address, the routine will attempt to symbolize it as a line
!	number and byte offset from the start of the line.
!
!	If the address turns out to be a data address, this routine will see if it
!	corresponds to any static symbol.  If so, the symbol most immediately preceding
!	the address (or an exact match) and a positive offset (or 0) will be returned,
!	along with the value TRUE.
!	Symbolization will not be done to array elements or record components; only the
!	outer level static data item will be returned as the symbol.
!
!	If no suitable symbolization can be found, then the routine returns false, and
!	symid is 0.
!
! INPUTS:
!	ADDR	      - Address descriptor.
!
!	P_SYMID       - The address of a longword location to receive the "symbol
!			identifier".
!
!	P_BIT_OFFSET  - The bit offset off of P_SYMID.
!
!	PRINT_FLAG    - If false, no output will be done.  If true, then all symbols that
!			match the virtual address will be output to the terminal.  (There
!			may be more than one match, such as would occur in FORTRAN common.)
!
!	5th Parameter - If this routine is called from DBG$PC_TO_SYMID, this
!			parameter is set to TRUE.  If this is the case, the
!			line symid will not be created.
!
! OUTPUTS:
!	SYMID	      - A symbol identifier which uniquely identifies the symbol which best
!			symbolizes the input address.
!
!	If the PRINT_FLAG has a value of TRUE, then output of all matched symbols
!	to the terminal will occur.
!

    BEGIN

    MAP
	ADDR: REF DBG$ADDRESS_DESC;		! Pointer to Address Desc.

    BUILTIN
	ACTUALCOUNT;

    BIND
	SYMID	      = .P_SYMID:  REF RST$ENTRY,  ! Best symbol identifier.
	BIT_OFFSET    = .P_BIT_OFFSET;		   ! Bit offset.

    LOCAL
	ADDRESS,				! Byte address from Addr. Desc.
	BYTE_OFFSET,				! Byte offset from RSTPTR
	MODRSTPTR:     REF RST$ENTRY,		! The module RST ptr.
	MODULE_FOUND,				! Module found/not found flag.
	PROG_SATPTR:   REF SAT$ENTRY,		! Program level SAT ptr.
	RSTPTR:        REF RST$ENTRY,		! The symbol's RST ptr.
	SYMBOL_NAME:   REF BLOCK[, BYTE],	! Ptr to counted string.
	TMP_BYTE_OFFSET;			! Tmp offset for calc closest
						!   symbol.


    ! Initialize.
    !
    ADDRESS = .ADDR[DBG$L_ADDRESS_BYTE_ADDR];
    BIT_OFFSET = .ADDR[DBG$L_ADDRESS_BIT_OFFSET];
    BYTE_OFFSET = -1;
    SYMID = 0;
    MODULE_FOUND = FALSE;
    OWN_MODULE_BEGIN = 0;
    OWN_MODULE_END = 0;


    ! Search through the program level static address table, looking
    ! for a module that covers the address.
    !
    PROG_SATPTR = .SAT$START_ADDR;
    WHILE .PROG_SATPTR NEQ 0 DO
	BEGIN


	! If current SAT entry is past the address we are looking for,
	! then exitloop.  Can do this because SAT is sorted on start
	! address.
	!
	IF .PROG_SATPTR[SAT$L_START] GTRA .ADDRESS
	THEN
	    EXITLOOP;


    	! If the given address is in the correct range, then go ahead
    	! and search the module-level SAT.
    	!
    	IF (.PROG_SATPTR[SAT$L_START] LEQA .ADDRESS) AND
    	   (.PROG_SATPTR[SAT$L_END]   GEQA .ADDRESS)
    	THEN
    	    BEGIN

	    ! Search the module level SAT.
	    !
	    SEARCH_MODULE_SAT (.PROG_SATPTR, .ADDRESS, MODRSTPTR, RSTPTR,
				TMP_BYTE_OFFSET, .PRINT_FLAG);


	    ! If this is the first module found, then print the address.
	    !
	    IF (.PRINT_FLAG) AND (NOT .MODULE_FOUND)
	    THEN
		BEGIN
		DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
		PRINT_BIT_OFFSET(BIT_OFFSET);
		DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
		DBG$NEWLINE();
		DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
		END;
	    MODULE_FOUND = TRUE;


	    ! Calculate offset; determine what to print.
	    !
	    SELECTONE TRUE OF
		SET


		! If the module is not set, then print a message to that
		! effect.
		!
		[.MODRSTPTR[RST$V_MODSET] EQL 0]:
		    BEGIN
		    IF .PRINT_FLAG
		    THEN
			BEGIN
			DBG$STA_SYMNAME (.MODRSTPTR, SYMBOL_NAME);
			DBG$PRINT (UPLIT BYTE (%ASCIC 'in module !AC, module not set'), .SYMBOL_NAME);
			DBG$NEWLINE();
			END;
		    END;


		! If the module is set, but the RST pointer is 0, then the
		! address was found in the module, but could not be symbolized.
		! Print a message to this effect.
		!
		[.RSTPTR EQL 0]:
		    BEGIN
		    IF .PRINT_FLAG
		    THEN
			BEGIN
			DBG$STA_SYMNAME (.MODRSTPTR, SYMBOL_NAME);
			DBG$PRINT (UPLIT BYTE (%ASCIC 'in module !AC, no symbolization'), .SYMBOL_NAME);
			DBG$NEWLINE();
			END;
		    END;


		! There is a symbolization.
		!
		[OTHERWISE]:
		    BEGIN


		    ! If there is currently no symbolization for the address, then
		    ! assume this one to be the best.
		    ! If there is a prior symbolization, see if this one is better.
		    ! If the offset is 0, there can be no better match.
		    !
		    IF (.MODRSTPTR[RST$V_MODSET]) AND (.BYTE_OFFSET NEQ 0)
		    THEN
			IF (.BYTE_OFFSET LSS 0) OR
			   (.TMP_BYTE_OFFSET LSS .BYTE_OFFSET)
			THEN
			    BEGIN
			    SYMID = .RSTPTR;
			    BYTE_OFFSET = .TMP_BYTE_OFFSET;
			    END;


		    ! If the print_flag is set, output the symbolization.
		    !
		    IF .PRINT_FLAG
		    THEN
			BEGIN


			! Build the ASCII string for the symbol.
			!
			DBG$PRINT_SYMBOL_PATHNAME(.RSTPTR);
			IF .TMP_BYTE_OFFSET NEQ 0
			THEN
			    DBG$PRINT_OFFSET (.TMP_BYTE_OFFSET);
			PRINT_BIT_OFFSET(BIT_OFFSET);
			DBG$NEWLINE();
			END;

		    END;
		TES;
	    END;


	! Get the next program level SAT entry.
	!
	PROG_SATPTR = .PROG_SATPTR[SAT$L_FLINK];
	END;

    IF .SYMID EQL 0
    THEN
	BEGIN
	BYTE_OFFSET = 0;
	BIT_OFFSET = .BYTE_OFFSET * 8 + .BIT_OFFSET;
	RETURN .MODULE_FOUND;
	END;


    ! This is called from DBG$PC_TO_SYMID.  Line rst entry will not be
    ! created.  DBG$SEARCH_SAT serves as RST look up.
    !
    IF ACTUALCOUNT() EQL 5
    THEN
	BEGIN
	BIT_OFFSET = .BYTE_OFFSET * 8 + .BIT_OFFSET;
	RETURN .MODULE_FOUND;
	END;


    ! If the address is a code address, then print the symbol
    ! name and corresponding line number.  If there is no line
    ! number, then just print the routine name and offset.
    !
    IF (.SYMID[RST$B_KIND] EQL RST$K_ROUTINE) OR
       (.SYMID[RST$B_KIND] EQL RST$K_BLOCK) OR
       (.SYMID[RST$B_KIND] EQL RST$K_LABEL) OR
       (.SYMID[RST$B_KIND] EQL RST$K_ENTRY)
    THEN
	BEGIN
	LOCAL
	    LINE_NO,			! Line no. corresponding to code address.
	    STMT_NO,			! statement no.
	    START_PC,			! Beginning pc address for line.
	    END_PC,			! Dummy.
	    MOD_SYMID : REF RST$ENTRY,	! Dummy.
    	    TMP_OFFSET,			! Temporay offset 
    	    TMP_SYMID : REF RST$ENTRY;  ! Temporay symid for %line


	! Lookup the line number; if found, then print the symbol name
	! and line number.
	!
	MOD_SYMID = .MODRSTPTR;
	IF (DBG$PC_TO_LINE_LOOKUP (.ADDRESS, LINE_NO, STMT_NO,
				   START_PC, END_PC, MOD_SYMID))
	AND ((.LINE_NO NEQ 0) OR (.STMT_NO NEQ 0))
	THEN
	    BEGIN
	    IF (.BYTE_OFFSET NEQ 0) OR (.SYMID[RST$B_KIND] EQL RST$K_BLOCK)
	    THEN
		BEGIN
		SYMID = DBG$STA_LINE_NUM_RST(.SYMID, .LINE_NO, .STMT_NO,
						.START_PC, .END_PC);
		BYTE_OFFSET = .ADDRESS - .START_PC;


    		! Set the following for printing purpose.
    		!
    		TMP_SYMID = .SYMID;
    		TMP_OFFSET = .BYTE_OFFSET;
		END

    	    ELSE
    		BEGIN
    		IF .PRINT_FLAG
    		THEN
    		    BEGIN
		    TMP_SYMID = DBG$STA_LINE_NUM_RST(.SYMID, .LINE_NO, 
    			.STMT_NO, .START_PC, .END_PC);
		    TMP_OFFSET = .ADDRESS - .START_PC;
    		    TMP_SYMID[RST$L_UPSCOPEPTR] = .SYMID[RST$L_UPSCOPEPTR];
    		    END;
    		END;


	    IF .PRINT_FLAG
	    THEN
		BEGIN
		DBG$PRINT_SYMBOL_PATHNAME (.TMP_SYMID);


		! If the start pc is less than the code address, then
		! print the line offset.
		!
		IF .TMP_OFFSET GTR 0
		THEN
		    DBG$PRINT_OFFSET (.TMP_OFFSET);
		PRINT_BIT_OFFSET(BIT_OFFSET);
		DBG$NEWLINE();
		END;
	    END;
	END;


    ! End of routine.  If the symbol was located in some module, then
    ! MODULE_FOUND is true; otherwise the routine returns false.
    ! Set offset to original address if no symbolization.
    !
    BIT_OFFSET = .BYTE_OFFSET * 8 + .BIT_OFFSET;
    RETURN .MODULE_FOUND;

    END;

GLOBAL ROUTINE DBG$DUMP_SAT: NOVALUE =
!
! FUNCTION
!	This routine displays information about the Static Address Table.
!	It is called from the DUMP SAT command, which is enabled via
!	SET DEVELOPER 0. The information can be used as an aid to
!	studying the performance of the debugger.
!
! INPUTS
!	none.
!
! OUTPUTS
!	The length of each modules SAT chain is displayed at the terminal.
!
    BEGIN
    LOCAL
	COUNT,
	MODNAME,
	MODRSTPTR: REF RST$ENTRY,
    	PROGSAT_COUNT,
	PROG_SATPTR: REF SAT$ENTRY,
	SATPTR: REF SAT$ENTRY;

    ! Loop through the program-level SAT.
    !
    PROG_SATPTR = .SAT$START_ADDR;
    PROGSAT_COUNT = 0;
    WHILE .PROG_SATPTR NEQ 0 DO
	BEGIN
    	PROGSAT_COUNT = .PROGSAT_COUNT + 1;
	MODRSTPTR = .PROG_SATPTR[SAT$L_RSTPTR];

	! Loop through each module-level SAT, keeping a count of entries.
	!
	SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
	COUNT = 0;
	WHILE .SATPTR NEQ 0 DO
	    BEGIN
	    COUNT = .COUNT + 1;
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    END;

	! Display the information for this module SAT.
	!
	DBG$STA_SYMNAME (.MODRSTPTR, MODNAME);
	DBG$PRINT(UPLIT BYTE(%ASCIC 'module !AC: !UL'), .MODNAME, .COUNT);
	DBG$NEWLINE();

	PROG_SATPTR = .PROG_SATPTR[SAT$L_FLINK];
	END;
    DBG$PRINT(UPLIT BYTE(%ASCIC 'length of program SAT: !UL'), .PROGSAT_COUNT);
    DBG$NEWLINE();
    END;

GLOBAL ROUTINE DBG$SEARCH_VAX_CALL_STACK(ADDR, P_SYMID, P_BIT_OFFSET, PRINT_FLAG) =
!
! FUNCTION
!	This routine searches the VAX call stack in an attempt to symbolize the
!	address.
!
! INPUTS
!	ADDR		- Address Descriptor.
!
!	P_SYMID		- The address of a longword location to receive the
!			  unique symbol identifier.
!
!	P_BIT_OFFSET	- The bit offset off of P_SYMID.
!
!
!	PRINT_FLAG	- If false, no output will be done.  If true, then
!			  the symbolization of the virtual address will be
!			  output to the terminal.
!
! OUTPUTS
!	If successful, the routine prints the symbolization of the address
!	(if the print flag was set).  The location defined by P_SYMID contains
!	the RST pointer (unique symbol identifier) of the symbol that matched.
!	The location defined by P_BIT_OFFSET contains the bit offset.  The routine
!	returns true.  All of this occurs even if only a partial symbolization
!	is possible (eg. just routine name).
!
!	If the address is not found in the stack frame, then P_SYMID is 0, and
!	P_BIT_OFFSET is .ADDR's bit offset field.  The routine returns false.
!

    BEGIN

    MAP
	ADDR: REF DBG$ADDRESS_DESC;

    BIND
	SYMID		= .P_SYMID:  REF RST$ENTRY,  ! Unique symbol identifier.
	BIT_OFFSET	= .P_BIT_OFFSET;	     ! Offset off of FP.

    LITERAL
	FP = 13,
	SP = 14,
	LONGWORD = 4;

    LOCAL
	ADDRESS,				! Byte address
	BYTE_OFFSET,				! Byte offset
    	COUNT,					! Invocation count
    	ENDADDR,				! End address of routine
	FRAME_FOUND_FLAG,			!
    	FRAMEPTR        : REF BLOCK[, BYTE],	! Ptr to current VAX call frame.
	FRAMEPTR2       : REF BLOCK[, BYTE],	! Ptr to current VAX call frame.
	PCVAL,					! Current PC.
	PCVAL2,					! Current PC.
	TMP_BYTE_OFFSET,			! Tmp offset for calc closest symbol.
	VALSPEC		: REF DST$VAL_SPEC,	! Ptr to DST value spec.
	TMP_SYMID	: REF RST$ENTRY,	! Temp ptr to symbol RST entry.
	MODRSTPTR	: REF RST$ENTRY,	! Module RST pointer
	RSTPTR		: REF RST$ENTRY,	! Routine RST ptr.
	RSTPTR2		: REF RST$ENTRY,	! Routine RST ptr.
    	SATPTR		: REF SAT$ENTRY,	!
    	STARTADDR,				! Start address of routine
	SYMBOL_NAME     : REF BLOCK[, BYTE],	! Ptr to counted ASCII string.
	SPVAL           : REF VECTOR[, LONG],	! Current call frame SP value.
	REGMASK         : BITVECTOR[16];	! Reg save mask from the call frame.


    ! Initialize the SP, PC and frame pointer to their current (top of stack)
    ! values.
    !
    PCVAL = .DBG$RUNFRAME[DBG$L_USER_PC];
    SPVAL = .DBG$RUNFRAME[DBG$L_USER_SP];
    FRAMEPTR = .DBG$RUNFRAME[DBG$L_USER_FP];


    ! Assume symbolization not possible.
    !
    SYMID = 0;
    BYTE_OFFSET = -1;
    ADDRESS = .ADDR[DBG$L_ADDRESS_BYTE_ADDR];
    BIT_OFFSET = .ADDR[DBG$L_ADDRESS_BIT_OFFSET];


    ! Loop through the stack.
    !
    WHILE TRUE DO
	BEGIN


	! If we are at the bottom of the stack, then exit the loop.
	!
	IF (.PCVAL EQL 0) OR
	   (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL)
	THEN
	    EXITLOOP;


	! See if there is local data on top of the stack.
	!
	IF .FRAMEPTR GTRA .SPVAL
	THEN


	    ! There is, so see if address is within the data area.
	    !
	    IF (.ADDRESS GEQA .SPVAL) AND
	       (.ADDRESS LSSA .FRAMEPTR)
	    THEN
		BEGIN
		RSTPTR = FIND_ROUTINE (.PCVAL, .PRINT_FLAG);
		IF .RSTPTR EQL 0
		THEN
		    BEGIN
		    IF .PRINT_FLAG
		    THEN
			BEGIN
			DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
			PRINT_BIT_OFFSET(BIT_OFFSET);
			DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
			DBG$NEWLINE();
			DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
			DBG$PRINT (UPLIT BYTE (%ASCIC 'data item on stack in unknown module'));
			DBG$NEWLINE();
			END;

		    RETURN TRUE;
		    END;

		IF .RSTPTR[RST$B_KIND] EQL RST$K_MODULE
		THEN
		    BEGIN


		    ! We have located the PC in a module, but since the module
		    ! is not set, can't get any more information other than
		    ! module name.  Print that.
		    !
		    IF .PRINT_FLAG
		    THEN
			BEGIN
			DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
			PRINT_BIT_OFFSET(BIT_OFFSET);
			DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
			DBG$NEWLINE();
			DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
			DBG$STA_SYMNAME (.RSTPTR, SYMBOL_NAME);
			DBG$PRINT (UPLIT BYTE (%ASCIC 'data item on stack in module !AC'), .SYMBOL_NAME);
			IF .RSTPTR[RST$V_MODSET]
			THEN
			    DBG$PRINT( UPLIT BYTE (%ASCIC ', module set'))
			ELSE
			    DBG$PRINT( UPLIT BYTE (%ASCIC ', module not set'));

			DBG$NEWLINE();
			END;
		    RETURN TRUE;
		    END;


		! We have found the routine containing the PC.  Try for further
		! symbolization.
		!
		MODRSTPTR = .RSTPTR;
		WHILE .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		    MODRSTPTR = .MODRSTPTR[RST$L_UPSCOPEPTR];
		TMP_SYMID = .MODRSTPTR[RST$L_SYMCHNPTR];


		! Search through the routine to find the symbol most immediately
		! preceding the given address.
		!
		WHILE .TMP_SYMID NEQ 0 DO
		    BEGIN
		    LOCAL
			TMPPTR;


		    ! Get the DST value spec for the symbol.  If the symbol
		    ! is not bound to FP (or SP), then the valspec will be 0.
		    !
		    VALSPEC = IS_SYMBOL_BOUND_TO_REG (.TMP_SYMID, FP);
		    TMPPTR = .FRAMEPTR;
		    IF .VALSPEC EQL 0
		    THEN
			BEGIN
			VALSPEC = IS_SYMBOL_BOUND_TO_REG (.TMP_SYMID, SP);


			! In here we need to do a special check for JSB routine
			! local variables. (usually it is defined as SP - offset
			! in DST).  The address of those variables are usually
			! relative to SP pointer at the execution time.  We do
			! not have the correct information for SP.  So we do
			! our best guess at this case.  Ignore it if we think
			! we have found this case.
			!
			IF .VALSPEC NEQ 0
			THEN
			    BEGIN
			    IF .VALSPEC[DST$L_VS_VALUE] LSS 0
			    THEN
				VALSPEC = 0
			    ELSE
				TMPPTR = .SPVAL;
			    END;

			END;


		    IF .VALSPEC NEQ 0
		    THEN
			BEGIN


			! See if the symbol is a displacement off of the FP,
			! or SP.
			!
			IF NOT .VALSPEC[DST$V_VS_INDIRECT] AND
			   .VALSPEC[DST$V_VS_DISP]
			THEN
			    BEGIN
			    IF .TMP_SYMID[RST$L_UPSCOPEPTR] EQL .RSTPTR
			    THEN
				BEGIN


				! If this is the first match, or a better
				! match, set symid and offset.
				!
				TMP_BYTE_OFFSET = .ADDRESS -
					(.TMPPTR + .VALSPEC[DST$L_VS_VALUE]);
				IF ((.TMP_BYTE_OFFSET LSS .BYTE_OFFSET) AND
				    (.TMP_BYTE_OFFSET GEQ 0))
				OR (.BYTE_OFFSET LSS 0)
				THEN
				    BEGIN
				    SYMID = .TMP_SYMID;
				    BYTE_OFFSET = .TMP_BYTE_OFFSET;
				    END;
				END;
			    END;
			END;


		    ! If the offset is 0, have found a perfect match.
		    !
		    IF .BYTE_OFFSET EQL 0
		    THEN
			EXITLOOP;


		    ! Loop for next symbol.
		    !
		    TMP_SYMID = .TMP_SYMID[RST$L_SYMCHNPTR];
		    END;

    		! Before returning, we want to take care of the case
    		! where the found SYMID was declared in a routine
    		! with several invocations on the stack. We walk down
    		! the stack again, counting the times we pass the routine.
    		! This enables us to attach an invocation number to
    		! the SYMID.
    		!
    		COUNT = 0;
    		IF .SYMID NEQ 0
    		THEN
    		    BEGIN
		    STARTADDR = .RSTPTR[RST$L_STARTADDR];
		    ENDADDR = .RSTPTR[RST$L_ENDADDR];
    		    PCVAL2 = .DBG$RUNFRAME[DBG$L_USER_PC];
    		    FRAMEPTR2 = .DBG$RUNFRAME[DBG$L_USER_FP];
    		    WHILE .FRAMEPTR2 LSS .FRAMEPTR DO
    		        BEGIN
		        IF (.PCVAL2 GEQU .STARTADDR) AND (.PCVAL2 LEQU .ENDADDR)
		        THEN
	    		    BEGIN


	    		    ! The PC from this CALL frame is in the address range of the routine
	    		    ! we are looking for.  However, to make sure the PC is not really in
	    		    ! a nested routine within the desired routine, we search the Module
	    		    ! SAT starting at the desired routine's SAT entry looking for nested
	    		    ! routines which cover the CALL frame's PC value.  If we find such a
	    		    ! routine, the CALL frame is not for the desired routine.
	    		    !
	    		    FRAME_FOUND_FLAG = TRUE;
			    SATPTR = .RSTPTR[RST$L_RTNSATPTR];

                            ! WARNING -- We can get into trouble here.  Previously, we have
                            ! assumed that the SAT is always around.  This may not be the
		            ! case if this module has been canceled.  There are times when
		            ! the module could be canceled and then set again to make us
		            ! believe the the SAT is valid for this RST, but it is not!  To
		            ! correct the problem, when a module is canceled the field
		            ! RST$L_RTNSATPTR is set to ZERO for each routine.
		            ! So if the module for this RST has been canceled, SATPTR will
                            ! be zero from the above statement. The problem is that this
		            ! assumes there are no nested routines that truly require the
		            ! correct context information.  This is, of course, WRONG.  A
		            ! way of saving and getting to the SAT information must be
		            ! found in the future.  B.A. Becker  MAY-1984
                            !
		            IF .SATPTR NEQ 0
                            THEN
                                SATPTR = .SATPTR[SAT$L_FLINK];

	    		    WHILE TRUE DO
			        BEGIN
    			        LOCAL
    				    NEW_RSTPTR: REF RST$ENTRY;


			        ! If there are no more SAT entries in the chain or if they no
			        ! longer cover the PCVAL address, exit the SAT loop.
			        !
			        IF .SATPTR EQL 0 THEN EXITLOOP;
			        IF .SATPTR[SAT$L_START] GTRU .PCVAL2 THEN EXITLOOP;


			        ! If this SAT entry is for a routine which covers the PCVAL
			        ! address, we clear FRAME_FOUND_FLAG because the PC is in this
		   	        ! nested routine instead of the routine we are looking for.
		 	        !
			        NEW_RSTPTR = .SATPTR[SAT$L_RSTPTR];
			        IF (.PCVAL2 GEQU .SATPTR[SAT$L_START]) AND
		   	           (.PCVAL2 LEQU .SATPTR[SAT$L_END])   AND
		   	           (.NEW_RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE)
			        THEN
		    		    BEGIN
		    		    FRAME_FOUND_FLAG = FALSE;
		    		    EXITLOOP;
		    		    END;

			        ! Link on to the next SAT entry.
			        !
			        SATPTR = .SATPTR[SAT$L_FLINK];
			        END;

	    	            ! If the CALL frame we found really is for the desired routine,
	    	            ! then increment the invocation count.
	    	            !
	    	            IF .FRAME_FOUND_FLAG
	    	            THEN
			        COUNT = .COUNT + 1;
    			    END;

    		        ! Keep looping through the stack.
    		        !
    		        PCVAL2 = .FRAMEPTR2[SF$L_SAVE_PC];
    		        FRAMEPTR2 = .FRAMEPTR2[SF$L_SAVE_FP];
    		        END;
    		    END;

    		! Now build a new SYMID which includes the invocation number.
    		!
    		IF .COUNT GTR 0
    		THEN
    		    SYMID = DBG$BUILD_INVOC_RST(.SYMID, .COUNT);

		! If a symbol was not found, then just print the routine name.
		! Otherwise, print the symbol pathname (and offset, if
		! applicable).
		!
		IF .PRINT_FLAG
		THEN
		    BEGIN
		    DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
		    PRINT_BIT_OFFSET(BIT_OFFSET);
		    DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
		    DBG$NEWLINE();
		    DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
		    IF .SYMID EQL 0
		    THEN
			BEGIN
			DBG$PRINT (UPLIT BYTE (%ASCIC 'data item on stack in routine '));
			DBG$PRINT_SYMBOL_PATHNAME(.RSTPTR);
			END

		    ELSE
			BEGIN
			DBG$PRINT_SYMBOL_PATHNAME(.SYMID);
			IF .BYTE_OFFSET NEQ 0
			THEN
			    DBG$PRINT_OFFSET (.BYTE_OFFSET);
			PRINT_BIT_OFFSET(BIT_OFFSET);
			END;
		    DBG$NEWLINE();
		    END;

		IF .BYTE_OFFSET LSS 0 THEN SYMID = 0;
		IF .SYMID EQL 0 THEN BYTE_OFFSET = 0;
		BIT_OFFSET = .BYTE_OFFSET * 8 + .BIT_OFFSET;
		RETURN TRUE;
		END;


	! It was not a local data item, so see if it is a call frame address.
	! Determine what the value of SP will be when this call frame is torn
	! down by the RET instruction.  The new SP value will be the bottom
	! boundary of this call frame.
	!
	REGMASK = .FRAMEPTR[SF$W_SAVE_MASK];
	SPVAL = FRAMEPTR[SF$L_SAVE_REGS];
	INCR I FROM 0 TO 11 DO
	    IF .REGMASK[.I] THEN SPVAL = .SPVAL + LONGWORD;
	SPVAL = .SPVAL + .FRAMEPTR[SF$V_STACKOFFS];
	IF .FRAMEPTR[SF$V_CALLS]
	THEN
	    SPVAL = .SPVAL + 4*(.SPVAL[0] + 1);


	! See if the address falls into the current call frame (which is bounded
	! by the current frameptr and the sp value just calculated).
	!
	IF (.ADDRESS GEQA .FRAMEPTR) AND
	   (.ADDRESS LSSA .SPVAL)
	THEN
	    BEGIN


	    ! Find the routine that contains the PC.
	    !
	    RSTPTR = FIND_ROUTINE (.PCVAL, .PRINT_FLAG);
	    IF .RSTPTR EQL 0
	    THEN
		BEGIN
		IF .PRINT_FLAG
		THEN
		    BEGIN
		    DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
		    PRINT_BIT_OFFSET(BIT_OFFSET);
		    DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
		    DBG$NEWLINE();
		    DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
		    DBG$PRINT (UPLIT BYTE (%ASCIC 'stack frame address in unknown module'));
		    DBG$NEWLINE();
		    END;

		RETURN TRUE;
		END;

	    IF .RSTPTR[RST$B_KIND] EQL RST$K_MODULE
	    THEN
		BEGIN


		! We have located the PC in a module, but since the module
		! is not set, can't get any more information other than
		! module name.  Print that.
		!
		IF .PRINT_FLAG
		THEN
		    BEGIN
		    DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
		    PRINT_BIT_OFFSET(BIT_OFFSET);
		    DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
		    DBG$NEWLINE();
		    DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
		    DBG$STA_SYMNAME (.RSTPTR, SYMBOL_NAME);
		    DBG$PRINT (UPLIT BYTE (%ASCIC
			'stack frame address in module !AC'), .SYMBOL_NAME);
		    IF .RSTPTR[RST$V_MODSET]
		    THEN
			DBG$PRINT( UPLIT BYTE (%ASCIC ', module set'))
		    ELSE
			DBG$PRINT( UPLIT BYTE (%ASCIC ', module not set'));

		    DBG$NEWLINE();
		    END;

		RETURN TRUE;
		END

	    ELSE


		! Module is set.  Print the routine name.
		!
		BEGIN
		IF .PRINT_FLAG
		THEN
		    BEGIN
		    DBG$PRINT ( UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
		    PRINT_BIT_OFFSET(BIT_OFFSET);
		    DBG$PRINT ( UPLIT BYTE (%ASCIC ': '));
		    DBG$NEWLINE();
		    DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
		    DBG$PRINT ( UPLIT BYTE (%ASCIC 'stack call frame'), 0);
		    TMP_BYTE_OFFSET = .ADDRESS - .FRAMEPTR;
		    IF .TMP_BYTE_OFFSET NEQ 0
		    THEN
			DBG$PRINT_OFFSET(.TMP_BYTE_OFFSET);
		    PRINT_BIT_OFFSET(BIT_OFFSET);
		    DBG$PRINT (UPLIT BYTE (%ASCIC ' for routine '));
		    DBG$PRINT_SYMBOL_PATHNAME(.RSTPTR);
		    DBG$NEWLINE();
		    END;

		RETURN TRUE;
		END;

	    END;


	! Not found yet.  Get information for next stack frame.
	!
	PCVAL = .FRAMEPTR[SF$L_SAVE_PC];
	FRAMEPTR = .FRAMEPTR[SF$L_SAVE_FP];

	END;


    ! Address was not found in a call frame.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$SYMBOLIZE_REG(ADDR, P_SYMID, P_BIT_OFFSET, PRINT_FLAG): =
!
! FUNCTION
!	This routine searches through all set modules in the module chain,
!	looking for those symbols in the DST that are bound to the register
!	REGNUM.  Once found, they are printed.  If none are found, a message
!	to that effect is output.
!
! INPUTS
!	ADDR		- Address descriptor.
!
!	P_SYMID		- The address of a longword to receive the best
!			  possible symbolization of the register address.
!
!	P_BIT_OFFSET	- The bit offset off of SYMID.
!
!
! OUTPUTS
!	On success, prints those symbols (full pathname) that are bound to
!	    the register.  Also returns the best (first) symbolization.
!
!	On not finding any symbols bound to the register, a message to that
!	    effect is output.
!

    BEGIN

    MAP
	ADDR		: REF DBG$ADDRESS_DESC;

    BIND
	SYMID		= .P_SYMID:  REF RST$ENTRY,	! Best symbolization.
	BIT_OFFSET	= .P_BIT_OFFSET;		! Bit offset.

    LOCAL
	ADDRESS,					! Byte address
	BYTE_OFFSET,					! Byte offset
	REGNUM,						! Register number.
	SYMBOL_FOUND,					! One or more symbols found.
	REGNAME		: REF VECTOR[, BYTE],		! ASCII register name.
	MODRSTPTR	: REF RST$ENTRY,		! Ptr to current module
							! RST entry.
	RSTPTR		: REF RST$ENTRY,		! Unique symbol ID.
	VALSPEC		: REF DST$VAL_SPEC,		! Ptr to DST record's
							! value spec.
	BLITRLR		: REF DST$BLI_TRAILER1,		! Ptr to Bliss DST record
							! trailer.
	BLIVALSPEC	: BLOCK[8, BYTE]		! Value spec buffer for
			  FIELD (DST$VS_HDR_FIELDS);	! Bliss special cases DST.



    ADDRESS = .ADDR[DBG$L_ADDRESS_BYTE_ADDR];
    BIT_OFFSET = .ADDR[DBG$L_ADDRESS_BIT_OFFSET];


    ! See if the address is a register address.
    !
    IF (.ADDRESS LSSA DBG$REG_VALUES[0]) OR
       (.ADDRESS GEQA DBG$REG_VALUES[17])
    THEN
	RETURN FALSE;


    ! Set up to look through all set modules for symbols bound to REGNUM.
    !
    IF (MODRSTPTR = .RST$START_ADDR) EQL 0
    THEN
	SIGNAL (DBG$_NOLOCALS);


    ! Calculate register number and offset from register address.
    !
    REGNUM = (.ADDRESS - DBG$REG_VALUES[0]) / 4;
    BYTE_OFFSET = .ADDRESS - DBG$REG_VALUES[.REGNUM];


    ! Initialize.
    !
    SYMID = 0;
    SYMBOL_FOUND = FALSE;


    ! Print register name.
    !
    IF .PRINT_FLAG
    THEN
	BEGIN
	DBG$PRINT (UPLIT BYTE (%ASCIC 'address '), 0);
	PRINT_REGNAME (.ADDRESS);
	PRINT_BIT_OFFSET(BIT_OFFSET);
	DBG$PRINT (UPLIT BYTE (%ASCIC ':  '), 0);
	DBG$NEWLINE();
	DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
	END;


    ! Loop through all set modules.
    !
    WHILE .MODRSTPTR NEQ 0 DO
	BEGIN


	$ABORT_ON_CONTROL_Y;


	! Check to see if the module is set.
	!
	IF .MODRSTPTR[RST$V_MODSET]
	THEN
	    BEGIN


	    ! The module was set, so get the first RST entry in the chain.
	    !
	    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];


	    ! Loop until the module's symbol chain is exhausted.
	    !
	    WHILE .RSTPTR NEQ 0 DO
		BEGIN


		! See if symbol is bound to the register in question.
		!
		VALSPEC = IS_SYMBOL_BOUND_TO_REG (.RSTPTR, .REGNUM);


		! If it is, then use the value spec. to print the
		! symbolization.
		!
		IF .VALSPEC NEQ 0
		THEN
		    IF .VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_REG
		    THEN
			BEGIN
			IF .PRINT_FLAG
			THEN
			    BEGIN
			    DBG$PRINT_SYMBOL_PATHNAME (.RSTPTR);
			    IF .BYTE_OFFSET NEQ 0
			    THEN
				DBG$PRINT_OFFSET (.BYTE_OFFSET);
			    PRINT_BIT_OFFSET(BIT_OFFSET);
			    DBG$NEWLINE();
			    END;


			! The best symbolization is the first symbol found that
			! is bound to this register.  (An arbitrary decision.)
			! (More work needs to be done to associate the RST with
			!  the scope)
			!
			IF NOT .SYMBOL_FOUND
			THEN
			    SYMID = .RSTPTR;
			SYMBOL_FOUND = TRUE;
			END;


		! Get the next symid in the symbol chain.
		!
		RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
		END;

	    END;


	! Get a pointer to the next module in the chain.
	!
	MODRSTPTR = .MODRSTPTR[RST$L_NXTMODPTR];
	END;


    ! If NOT .SYMBOL_FOUND, then print out a message saying that there are no
    ! symbols bound to this register address.
    !
    IF .PRINT_FLAG
    THEN
	BEGIN
	IF NOT .SYMBOL_FOUND
	THEN
	    BEGIN
	    DBG$PRINT (UPLIT BYTE (%ASCIC 'no symbols are bound to '), 0);
	    PRINT_REGNAME(.ADDRESS);
	    PRINT_BIT_OFFSET(BIT_OFFSET);
	    DBG$NEWLINE();
	    END;
	END;


    ! End of routine.
    !
    IF .SYMID EQL 0 THEN BYTE_OFFSET = 0;
    BIT_OFFSET = .BYTE_OFFSET * 8 + .BIT_OFFSET;
    RETURN TRUE;

    END;

GLOBAL ROUTINE DBG$SYMID_TO_PRIMARY (SYMID, OFFSET) =
!
! FUNCTION
!	This routine takes a SYMID and an offset
!	and builds a Primary Descriptor for the object.
!	The routine must first do symbol table lookups to determine
!	the TYPEID, the KIND, and the FCODE.
!	It then can build a Primary root node and call DBG$BUILD_PRIMARY_SUBNODE
!	to create the Primary sub-node.
!
!	Then, if the offset is not zero, the Primary must be
!	modified to include the offset information. For example, if
!	the Primary is an array, the subscripts can be filled in with
!	the appropriate values.
!
! INPUTS
!	SYMID	- SYMID for the object
!	OFFSET	- offset from the object to the desired address
!
! OUTPUTS
!	A Primary Descriptor is built out of temporary memory and a
!	pointer to this descriptor and an offset to the primary
!	are returned.
!
    BEGIN

    MAP
	OFFSET: REF VECTOR[0];		! Offset value

    LOCAL
	PRIMPTR: REF DBG$PRIMARY;	! Pointer to a Primary Descriptor



    ! SYMID better not be zero.
    !
    IF .SYMID EQL 0
    THEN
	$DBG_ERROR ('DBGSYMBLZ\DBG$SYMID_TO_PRIMARY zero symid');


    ! Allocate space for the Primary Root node and fill in some of the header
    ! fields.
    !
    PRIMPTR = DBG$GET_TEMPMEM (DBG$K_PRIMARY_SIZE);
    PRIMPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    PRIMPTR[DBG$B_DHDR_TYPE] = DBG$K_PRIMARY_DESC;
    PRIMPTR[DBG$W_DHDR_LENGTH] = DBG$K_PRIMARY_SIZE*%UPVAL;
    PRIMPTR[DBG$L_DHDR_SYMID0] = .SYMID;
    PRIMPTR[DBG$L_PRIM_FLINK] = PRIMPTR[DBG$A_PRIM_FLINK];
    PRIMPTR[DBG$L_PRIM_BLINK] = PRIMPTR[DBG$A_PRIM_FLINK];


    ! Build the rest Primary subnode(s) for given SYMID.
    !
    RETURN BUILD_PRIMARY_SUBNODE(.PRIMPTR, .SYMID, .OFFSET);
    END;

GLOBAL ROUTINE DBG$NEW_SYMBOLIZE (ADDR, P_SYMID, P_BIT_OFFSET) =
!
! FUNCTION:
!	This routine accepts a address descriptor, and attempts to symbolize
!	it as a symbol name plus offset.
!	It always returns the best possible symbolization; if the address can
!	be symbolized by more than one symbol name with the same offset, then
!	the first is chosen to be the best.  
!
! INPUTS:
!	ADDR		- The address of an address descriptor (byte and bit offset).
!
!	P_SYMID	        - The address of a longword location where the "symbol identi-
!		  	  fier" should be returned.  The "symbol identifier" is a value
!		  	  which uniquely identifies the returned symbol.  This value is
!		  	  not directly understood outside the symbol table access rou-
!		  	  tines, but can be passed to various other symbol table access
!		  	  routines to extract information about the symbol.
!
!	P_BIT_OFFSET	- The address of a longword location where the bit offset from
!		  	  the SYMID symbol should be returned.
!
! OUTPUTS:
!	SYMID	- A symbol identifier which uniquely identifies the symbol
!		  which best symbolizes ADDR is returned to SYMID.  This symbol
!		  identifier can then be passed to any symbol table access rou-
!		  tine which accepts a SYMID parameter.  If no suitable symbol
!		  can be found, a zero is returned to SYMID.
!
!	OFFSET	- The bit offset of ADDR relative to the SYMID symbol is
!		  returned to OFFSET.  If (SYMID) is zero, this
!		  offset is simply the original address descriptor.
!
!	The routine returns true if symbolization was possible; otherwise it 
!	returns false.
!

    BEGIN

    BIND
	SYMID  = .P_SYMID:  REF RST$ENTRY,
	BIT_OFFSET = .P_BIT_OFFSET;

    MAP
    	ADDR: REF DBG$ADDRESS_DESC;	! Pointer to address descriptor

    LOCAL
    	BYTE_OFFSET,
    	SATPTR: REF SAT$ENTRY;


    ! See if the address is a register address.
    !
    IF DBG$SYMBOLIZE_REG (.ADDR, SYMID, BIT_OFFSET, FALSE)
    THEN
	RETURN TRUE;


    ! See if the address is a static address.
    !
    SATPTR = DBG$SEARCH_PROG_SAT (.SAT$START_ADDR,
    				  .ADDR[DBG$L_ADDRESS_BYTE_ADDR],
    				  BYTE_OFFSET);
    IF .SATPTR NEQ 0
    THEN
    	BEGIN
    	SYMID = .SATPTR[SAT$L_RSTPTR];

        ! If the address is a code address, then print the symbol
        ! name and corresponding line number.  If there is no line
        ! number, then just print the routine name and offset.
        !
        IF (.SYMID[RST$B_KIND] EQL RST$K_ROUTINE) OR
           (.SYMID[RST$B_KIND] EQL RST$K_BLOCK) OR
           (.SYMID[RST$B_KIND] EQL RST$K_LABEL) OR
           (.SYMID[RST$B_KIND] EQL RST$K_ENTRY)
        THEN
	    BEGIN
	    LOCAL
    		ADDRESS,
	        LINE_NO,			! Line no. corresponding to code address.
	        STMT_NO,			! statement no.
	        START_PC,			! Beginning pc address for line.
	        END_PC,				! Dummy.
	        MOD_SYMID : REF RST$ENTRY,	! Dummy.
    	        TMP_OFFSET,			! Temporay offset 
    	        TMP_SYMID : REF RST$ENTRY;  	! Temporay symid for %line


	    ! Lookup the line number; if found, then print the symbol name
	    ! and line number.
	    !
	    MOD_SYMID = .SYMID;
    	    WHILE .MOD_SYMID[RST$B_KIND] NEQ RST$K_MODULE DO
    		MOD_SYMID = .MOD_SYMID[RST$L_UPSCOPEPTR];
    	    ADDRESS = .ADDR[DBG$L_ADDRESS_BYTE_ADDR];
	    IF (DBG$PC_TO_LINE_LOOKUP (.ADDRESS, LINE_NO, STMT_NO,
				        START_PC, END_PC, MOD_SYMID))
	    AND ((.LINE_NO NEQ 0) OR (.STMT_NO NEQ 0))
	    THEN
	        IF (.BYTE_OFFSET NEQ 0) OR (.SYMID[RST$B_KIND] EQL RST$K_BLOCK)
	        THEN
		    BEGIN
		    SYMID = DBG$STA_LINE_NUM_RST(.SYMID, .LINE_NO, .STMT_NO,
						.START_PC, .END_PC);
		    BYTE_OFFSET = .ADDRESS - .START_PC;
		    END;
	    END;
    	BIT_OFFSET = .ADDR[DBG$L_ADDRESS_BIT_OFFSET] + (8 * .BYTE_OFFSET);
    	RETURN TRUE;
    	END;


    ! See if the address is a global symbol.
    !
    IF DBG$SEARCH_GLOBAL (.ADDR, SYMID, BIT_OFFSET, FALSE)
    THEN
        RETURN TRUE;


    ! See if the address is on the call stack.
    !
    IF DBG$SEARCH_VAX_CALL_STACK (.ADDR, SYMID, BIT_OFFSET, FALSE)
    THEN
	RETURN TRUE;


    ! The address was not found, and symbolization was thus impossible.
    !
    SYMID = 0;
    BIT_OFFSET = .ADDR;
    RETURN FALSE;
    END;

GLOBAL ROUTINE DBG$PC_TO_SYMID(PC, RSTPTR) =
!
! FUNCITON
!	This routine goes through the Module SAT table and/or Global symbol
!	chain to locate RST for the best match for a address.  If the 3rd
!	parameter is present, that means if the above
!	search failed, this routine goes on searching global symbol chain.
!	If the 3rd parameter is not present, that means to search Module SAT
!	only.
!
! INPUTS
!
!	ADDRESS	- The address for which a match is desired.
!
!	RSTPTR	- A pointer to RST entry.
!
!	3rd Parameter - optional.
!
! OUTPUTS
!
!	TRUE	- If a match is found.
!	FALSE	- otherwise.
!

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	ADDR: DBG$ADDRESS_DESC,		! Address Descriptor
	OFFSET,				! Bit offset
    	SATPTR: REF SAT$ENTRY;

    SATPTR = DBG$SEARCH_PROG_SAT (.SAT$START_ADDR, .PC, OFFSET);
    IF .SATPTR NEQ 0
    THEN
    	BEGIN
    	.RSTPTR = .SATPTR[SAT$L_RSTPTR];
    	RETURN TRUE;
    	END;
    IF ACTUALCOUNT() EQL 2 THEN RETURN FALSE;
    ADDR[DBG$L_ADDRESS_BYTE_ADDR] = .PC;
    ADDR[DBG$L_ADDRESS_BIT_OFFSET] = 0;
    RETURN DBG$SEARCH_GLOBAL(ADDR, .RSTPTR, OFFSET);
    END;

ROUTINE FIND_ROUTINE (PCVAL, PRINT_FLAG) =
!
! FUNCTION
!	This routine looks through the SAT to find the most nested routine
!	containing the PC value passed to the routine.
!
! INPUTS
!	PCVAL		   - The PC.
!
! OUTPUTS
!	If successful, and the module is set, the routine returns the routine
!	RST pointer.
!	If successful, and the module is not set, the routine returns the
!	module RST pointer.
!
!	If unsuccessful, the routine return 0.
!

    BEGIN

    LOCAL
	MODRSTPTR:	REF RST$ENTRY,  ! Ptr to module's RST entry.
	RSTPTR:		REF RST$ENTRY,  ! Ptr to symbol's RST entry.
	BYTE_OFFSET,			! Byte offset.
	PROG_SATPTR:	REF SAT$ENTRY;  ! Ptr to program level SAT entry.


    ! Initialize program level SAT pointer.
    !
    PROG_SATPTR = .SAT$START_ADDR;


    ! Search through the program level SAT.
    !
    WHILE .PROG_SATPTR NEQ 0 DO
	BEGIN


	! If current SAT entry is past the address we are looking for, then
	! exitloop.  (SAT is sorted on start address.)
	!
	IF .PROG_SATPTR[SAT$L_START] GTRA .PCVAL
	THEN
	    EXITLOOP;


    	IF (.PROG_SATPTR[SAT$L_START] LEQA .PCVAL) AND
    	   (.PROG_SATPTR[SAT$L_END]   GEQA .PCVAL)
    	THEN
    	    BEGIN


	    ! Search the module level SAT looking for a routine whose address
	    ! range includes .PCVAL.  (The most nested routine is returned.)
	    !
	    SEARCH_MODULE_SAT (.PROG_SATPTR, .PCVAL, MODRSTPTR, RSTPTR,
				BYTE_OFFSET, .PRINT_FLAG);


	    ! If the module is not set, can only return at most the module
	    ! RST pointer.
	    !
	    IF NOT .MODRSTPTR[RST$V_MODSET]
	    THEN
		RETURN .MODRSTPTR;


	    ! If the module was set, make sure RSTPTR is not zero.
	    !
	    IF .RSTPTR EQL 0 THEN RETURN .RSTPTR;


	    ! If the module was set, then find out if the RST entry is a
	    ! routine (the pcval could have more closely symbolized to a
	    ! label or block within the routine).
	    !
	    WHILE .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		BEGIN
		IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
		THEN
		    RETURN .RSTPTR;
		RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
		END;

	    RETURN .MODRSTPTR;
	    END;


	! Nothing found yet.  Get next SAT entry.
	!
	PROG_SATPTR = .PROG_SATPTR[SAT$L_FLINK];
	END;


    ! We did not find a routine containing the PC.
    !
    RETURN 0;
    END;

ROUTINE GET_ADDRESS_DESC (ADDRPTR, ADDRESS_DESC, MESSAGE_VECT) =
!
! FUNCTION
!	This routine interprets an address representation (AED for level 2
!	support, Primary or Value Descriptor for level 3 support), and an
!	address descriptor is returned.
!
! INPUTS
!	ADDRPTR		- The address representation.
!
!	ADDRESS_DESC	- The address descriptor.
!
!	MESSAGE_VECT	- The address of a longword to contain the address
!			  of a standard message argument vector.
!
! OUTPUTS
!	If the ADDRPTR type is a permanent descriptor of AED, then the register
!	address is returned in the byte address field of the address descriptor.
!	The bit offset is set to 0.  Otherwise, a regular address descriptor is
!	constructed and returned.
!
!	On success, STS$K_SUCCESS is returned.
!
!	On failure, either the routine signals its way out, or returns a
!	    message vector and STS$K_SEVERE.
!

    BEGIN

    MAP
	ADDRPTR		: REF DBG$AED,		! Ptr to Address Exp. Desc.
	ADDRESS_DESC	: REF DBG$ADDRESS_DESC;	! Ptr to Address Desc.

    LOCAL
	TYPE;


    ! See if we have a level 2 address expression descriptor.  If we do
    ! check for the permanent symbol AED type.
    !
    IF .ADDRPTR[DBG$B_AED_SIGNATURE] EQL DBG$K_AED
    THEN
	BEGIN
	IF .ADDRPTR[DBG$B_AED_TYPE] EQL DBG$K_PERM_DESC
	THEN
	    BEGIN
	    LOCAL
		REGNUM,				! Register Number
		PERM_DESC: REF DBG$PERMSD;	! Ptr to the permanent symbol desc.


	    ! We do, so initialize perm_desc to the AED value field,
	    ! which points to a permanent symbol descriptor.
	    !
	    PERM_DESC = .ADDRPTR[DBG$L_AED_VALUE];


	    ! Calculate the register number from the perm_desc ID field.
	    !
	    REGNUM = .PERM_DESC[DBG$B_PERMSD_ID] - DBG$K_R0;


	    ! Get the address of the register from DBG$REG_VALUES.
	    !
	    ADDRESS_DESC[DBG$L_ADDRESS_BYTE_ADDR] = DBG$REG_VALUES[.REGNUM];
	    ADDRESS_DESC[DBG$L_ADDRESS_BIT_OFFSET] = 0;
	    RETURN STS$K_SUCCESS;
	    END;

	END;


    ! Any other kinds call DBG$NGET_ADDRESS to get the addr. desc.
    !
    IF NOT DBG$NGET_ADDRESS (.ADDRPTR, .ADDRESS_DESC, TYPE, FALSE, .MESSAGE_VECT)
    THEN
	RETURN STS$K_SEVERE;

    RETURN STS$K_SUCCESS;
    END;

ROUTINE GSTADDRESS(RSTPTR) =
!
! FUNCTION:
!	This routine get the address of GST from GST's RST entry.
!
! INPUTS:
!	RSTPTR - Pointer to GST's RST entry.
!
! OUTPUT:
!	The address of GST.
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! Pointer to GST's RST entry

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to DST record
	GST_VALUE;			! Address of Global symbol


	CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO
				      RST$K_KIND_MAXIMUM OF
	    SET

	    [RST$K_ROUTINE]:
		BEGIN
		GST_VALUE = .RSTPTR[RST$L_STARTADDR];
		END;

	    [RST$K_DATA]:
		BEGIN
		DSTPTR = .RSTPTR[RST$L_DSTPTR];
		GST_VALUE = .DSTPTR[DST$L_VALUE];
		END;

	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGSYMBLZ\GSTADDRESS');

	    TES;

	RETURN .GST_VALUE;

    END;


ROUTINE IS_SYMBOL_BOUND_TO_REG (SYMID, REGNUM) =
!
! FUNCTION
!	This function accepts a symid as input, and determines if the symbol
!	associated with this symid is bound to the register regnum.
!
! INPUTS
!	SYMID	- Pointer to symbol's RST entry.
!
!	REGNUM	- The register number in question.
!
! OUTPUTS
!	The routine returns a DST value spec. if the symbol is bound to regnum
!	in some way; otherwise, it returns false.
!

    BEGIN

    MAP
	SYMID		: REF RST$ENTRY;		! Ptr. to symbol's RST entry.

    LOCAL
	VALSPEC		: REF DST$VAL_SPEC,		! Ptr to DST record's
							! value spec.
	BLITRLR		: REF DST$BLI_TRAILER1,		! Ptr to Bliss DST record
							! trailer.
	BLIVALSPEC	: BLOCK[8, BYTE]		! Value spec buffer for
			  FIELD (DST$VS_HDR_FIELDS),	! Bliss special cases DST.
	DSTPTR		: REF DST$RECORD;		! Ptr. to DST record value spec.


    $ABORT_ON_CONTROL_Y;


    ! See if the entry is a data type.
    !
    IF (.SYMID[RST$B_KIND] EQL RST$K_DATA) OR
       (.SYMID[RST$B_KIND] EQL RST$K_TYPCOMP)
    THEN
	BEGIN


	! It was, so get the corresponding DST entry.
	!
	DSTPTR = .SYMID[RST$L_DSTPTR];


	! Now get the value spec.
	!
	CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	    SET


	    ! Get the value spec for those DST records
	    ! that can be represented by the standard
	    ! format DST.
	    !
	    [DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	     DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
	     DST$K_ENTRY, DST$K_RECBEG, DST$K_ENUMELT]:
		BEGIN
		VALSPEC = DSTPTR[DST$B_VFLAGS];
		END;


	    ! Handle the Bliss Special Cases DST Record.
	    !
	    [DST$K_BLI]:
		BEGIN
		BLIVALSPEC[DST$B_VS_VFLAGS] = .DSTPTR[DST$B_BLI_VFLAGS];
		BLITRLR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
		BLIVALSPEC[DST$L_VS_VALUE] = .BLITRLR[DST$L_BLI_VALUE];
		VALSPEC = BLIVALSPEC[DST$B_VS_VFLAGS];
		END;


	    ! Other types of symbols cannot be bound to a
	    ! register, so ignore them.
	    !
	    [INRANGE]:
		RETURN FALSE;

	    ! Anything else is an illegal DST type.
	    !
	    [OUTRANGE]:
		SIGNAL (DBG$_INVDSTREC);

	    TES;


	! Loop through trailing value spec if present to get to actual
	! value spec.
	!
	WHILE .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
	    VALSPEC = VALSPEC[DST$A_VS_TVS_BASE] + .VALSPEC[DST$L_VS_TVS_OFFSET];

	SELECTONE TRUE OF
	    SET


	    ! Now, look at the VFLAGS field.
	    !
	    [.VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_NOVAL]:
		RETURN FALSE;


	    ! If valspec gives the offset to a descriptor, just return.
	    !
	    [.VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_DSC]:
		RETURN FALSE;


	    ! If valspec gives a bit offset, return.
	    !
	    [.VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_BITOFFS]:
		RETURN FALSE;


	    ! If valspec is a value-spec-follows, is a complex address.
	    !
	    [.VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS]:
		RETURN FALSE;


	    ! Now look at the VALKIND field for VFLAG non-above.
	    !
	    [.VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL]:
		RETURN FALSE;


	    [.VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_DESC]:
		RETURN FALSE;


	    ! If valkind is valkind_reg, then check and see if the value
	    ! field is equal to regnum.  If so, then return the valspec, as
	    ! the symbol is bound to this register.
	    !
	    [.VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_REG]:
		BEGIN
		IF .VALSPEC[DST$L_VS_VALUE] NEQ .REGNUM
		THEN
		    RETURN FALSE;

		RETURN .VALSPEC;
		END;


	    [.VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_ADDR]:


		! If there is a register displacement, check to see if the regnum
		! field is equal to regnum.  If so, return valspec.
		!
		BEGIN
		IF .VALSPEC[DST$V_VS_DISP]
		THEN
		    BEGIN
		    IF .VALSPEC[DST$V_VS_REGNUM] NEQ .REGNUM
		    THEN
			RETURN FALSE;

		    RETURN .VALSPEC;
		    END;
		END;

	    TES;
	END;


    ! Otherwise, just return false.
    !
    RETURN FALSE;
    END;

ROUTINE IS_SYMBOL_PSECT(RSTPTR) =
!
! FUNCTION
!	This routine determines whether a given symbol is a PSECT or not.
!	It accepts as input a SYMID (the given symbol's RST pointer), and it
!	returns TRUE if that SYMID is the SYMID of a PSECT; it returns FALSE
!	otherwise.  PSECTs are represented by Label RST Entries whose DST
!	pointer points to a PSECT DST Record.
!
!	PSECT names are less desirable symbolizations of addresses than any
!	other kind of label.
!
! INPUTS
!	RSTPTR	- A pointer to the RST entry of the symbol whose identity as
!		  a PSECT is to be established.
!
! OUTPUTS
!	The routine returns TRUE if the RSTPTR symbol is a PSECT.  It returns
!		  FALSE otherwise.
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! Pointer to symbol's RST entry

    LOCAL
	DSTPTR: REF DST$RECORD;		! Pointer to symbol's DST record



    ! If this is a Label RST Entry, see if its DST pointer points to a PSECT
    ! DST record.  If so, return TRUE.
    !
    IF .RSTPTR[RST$B_KIND] EQL RST$K_LABEL
    THEN
	BEGIN
	DSTPTR = .RSTPTR[RST$L_DSTPTR];
	IF .DSTPTR[DST$B_TYPE] EQL DST$K_PSECT THEN RETURN TRUE;
	END;


    ! It is not a PSECT--return FALSE.
    !
    RETURN FALSE;

    END;


ROUTINE PRINT_REGNAME (ADDRESS):  NOVALUE =
!
! FUNCTION
!	This routine accepts an address in register address area and gets a
!	register descriptor by calling DBG$STA_ADDRESS_TO_REGDESCR.  Then
!	converts register descriptor into a counted ASCII name.
!
!
! INPUTS
!	ADDRESS	- The input address which is a register address.
!
! OUTPUTS
!	None.
!

    BEGIN

    LOCAL
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to register name
	REGDESCR: DBG$REGDESCR;		! Register Descriptor


    REGDESCR = DBG$STA_ADDRESS_TO_REGDESCR(.ADDRESS);
    NAMEPTR = DBG$STA_REGISTER_NAME(.REGDESCR);
    DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .NAMEPTR);
    RETURN 0;
    END;

ROUTINE SEARCH_MODULE_SAT (PROG_SATPTR, ADDRESS, P_MODRSTPTR, P_RSTPTR,
				P_BYTE_OFFSET, PRINT_FLAG):  NOVALUE =
!
! FUNCTION
!	This routine searches a set module's SAT to determine what static
!	symbol most immediately precedes the given address.  The routine
!	returns the module RST pointer, the symbol RST pointer, and the byte
!	offset.
!
! INPUTS
!	ADDRESS		- The 32 bit address we want to symbolize.
!
!	PROG_SATPTR	- The pointer into the program level SAT.
!
!	PRINT_FLAG	- Flag to indicate the symbol to be outputed, in
!			here we print the symbols were not picked up
!			by this routine which all has the same address.
!
! OUTPUTS
!	P_MODRSTPTR	- The module RST entry for the symbol if one is found.
!
!	P_RSTPTR	- The RST entry for the symbol if a symbolization is
!			  possible.
!
!	P_BYTE_OFFSET	- The byte offset.
!

    BEGIN

    BIND
	BYTE_OFFSET = .P_BYTE_OFFSET,		    ! Byte offset.
	RSTPTR      = .P_RSTPTR    : REF RST$ENTRY, ! The symbol's RST pointer.
	MODRSTPTR   = .P_MODRSTPTR : REF RST$ENTRY; ! The module RST pointer.

    MAP
	PROG_SATPTR	: REF SAT$ENTRY;     ! The program's SAT pointer.

    LOCAL
	BEST_SAT	: REF SAT$ENTRY,
	NAME		: REF VECTOR[,BYTE], ! Pointer to ASCIC string
	NEXT_SATPTR	: REF SAT$ENTRY,     ! The next SAT ptr in the chain.
	SATPTR		: REF SAT$ENTRY,     ! The module's SAT pointer.
	SATRST		: REF RST$ENTRY,     ! Pointer RST entry in SAT
	TMPSAT		: REF SAT$ENTRY;     ! Temp. SAT.


    ! Initialize module RST pointer, as this is used to indicate the success
    ! of this routine.
    !
    $ABORT_ON_CONTROL_Y;
    MODRSTPTR = 0;
    RSTPTR = 0;


    MODRSTPTR = .PROG_SATPTR[SAT$L_RSTPTR];
    OWN_MODULE_BEGIN = .PROG_SATPTR[SAT$L_START];
    OWN_MODULE_END = .PROG_SATPTR[SAT$L_END];
    IF NOT .MODRSTPTR[RST$V_MODSET] THEN RETURN 0;


    ! If the module is set, search through the module's SAT looking for
    ! a symbol whose address matches the input.
    !
    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
    IF .SATPTR[SAT$L_START] GTRA .ADDRESS THEN RETURN 0;


    ! Determine the address range.
    !
    BEST_SAT = 0;
    TMPSAT = 0;
    NEXT_SATPTR = .SATPTR[SAT$L_FLINK];
    WHILE .NEXT_SATPTR NEQ 0 DO
	BEGIN
	$ABORT_ON_CONTROL_Y;
	IF .SATPTR[SAT$L_END] GEQA .ADDRESS
	THEN
	    BEGIN
	    IF NOT IS_SYMBOL_PSECT(.SATPTR[SAT$L_RSTPTR])
	    THEN
		BEGIN
		IF .TMPSAT NEQ 0 AND
		   .ADDRESS LEQ .TMPSAT[SAT$L_END]
		THEN
		    BEGIN
		    BEST_SAT = .TMPSAT;
		    TMPSAT = 0;


		    ! If the print_flag is set, output the symbol we did not
		    ! choose.
		    !
		    IF .PRINT_FLAG
		    THEN
			BEGIN


			! Build the ASCII string for the symbol.
			!
			DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
			DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
			DBG$NEWLINE();
			DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
			DBG$PRINT_SYMBOL_PATHNAME(.SATPTR[SAT$L_RSTPTR]);
			BYTE_OFFSET = .ADDRESS - .SATPTR[SAT$L_START];
			IF .BYTE_OFFSET NEQ 0
			THEN
			    DBG$PRINT_OFFSET (.BYTE_OFFSET);
			DBG$NEWLINE();
			DBG$PRINT_CONTROL (DBG$K_PRT_RESET);
			END;
		    END

		ELSE
		    BEST_SAT = .SATPTR;
		END;
	    END;

	IF .NEXT_SATPTR[SAT$L_START] GTRA .ADDRESS
	THEN
	    EXITLOOP;


	! In bliss, BIND user_meaningful_name = PLIT (....), in this case
	! user_meaningful_name == P.AAA.  So the choise should not be P.AAA.
	! Here is the code to check for this kind of cases.  Print both
	! name, the best symbolization one will be printed from the caller.
	!
	IF (.SATPTR[SAT$L_START] EQL .NEXT_SATPTR[SAT$L_START]) AND
	   (.SATPTR[SAT$L_END] EQL .NEXT_SATPTR[SAT$L_END])
	THEN
	    BEGIN
	    SATRST = .SATPTR[SAT$L_RSTPTR];
	    NAME = DBG$GET_DST_NAME(.SATRST[RST$L_DSTPTR]);
	    IF .NAME[0] NEQ 0
	    THEN
		BEGIN
		IF NOT (.NAME[1] EQL %C'P' AND .NAME[2] EQL %C'.')
		THEN
		    TMPSAT = .SATPTR


		! Print P.AAA, which we did not choose.
		!
		ELSE
		    BEGIN
		    IF .PRINT_FLAG
		    THEN
			BEGIN


			! Build the ASCII string for the symbol.
			!
			DBG$PRINT (UPLIT BYTE (%ASCIC 'address !XL'), .ADDRESS);
			DBG$PRINT (UPLIT BYTE (%ASCIC ': '));
			DBG$NEWLINE();
			DBG$PRINT_CONTROL (DBG$K_PRTSET_LMARGIN, TAB);
			DBG$PRINT_SYMBOL_PATHNAME(.SATPTR[SAT$L_RSTPTR]);
			BYTE_OFFSET = .SATPTR[SAT$L_START];
			IF .BYTE_OFFSET NEQ 0
			THEN
			    DBG$PRINT_OFFSET (.BYTE_OFFSET);
			DBG$NEWLINE();
			DBG$PRINT_CONTROL (DBG$K_PRT_RESET);
			END;

		    END;

		END;

	    END;

	SATPTR = .NEXT_SATPTR;
	NEXT_SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! Check for special cases.
    !
    IF .NEXT_SATPTR EQL 0
    THEN
	BEGIN
	IF (.ADDRESS GEQA .SATPTR[SAT$L_START]) AND
	   (.ADDRESS LEQA .SATPTR[SAT$L_END])
	THEN
	    BEGIN
	    IF .TMPSAT NEQ 0 AND
	       .ADDRESS LEQ .TMPSAT[SAT$L_END]
	    THEN
		BEST_SAT = .TMPSAT
	    ELSE
		BEST_SAT = .SATPTR;
	    END;
	END;

    IF .BEST_SAT EQL 0 THEN BEST_SAT = .SATPTR;


    ! We have found the best sat, get the symbol's RST pointer and determine
    ! the maximum byte offset.
    !
    RSTPTR = .BEST_SAT[SAT$L_RSTPTR];
    BYTE_OFFSET = .ADDRESS - .BEST_SAT[SAT$L_START];
    CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM
			     TO   RST$K_KIND_MAXIMUM OF
	SET
	[RST$K_ROUTINE, RST$K_BLOCK, RST$K_LABEL, RST$K_ENTRY]:
	    BEGIN


	    ! See if the address is a label address.  It much match the
	    ! the label address exactly, or else we find the containing
	    ! entity and print that plus line number as the better
	    ! symbolization.
	    !
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_LABEL OR
	       .RSTPTR[RST$B_KIND] EQL RST$K_ENTRY
	    THEN
		IF .BYTE_OFFSET NEQ 0
		THEN
		    BEGIN
		    LOCAL
			RSTPTR_TMP;

		    RSTPTR_TMP = .RSTPTR;
		    WHILE .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
			BEGIN
			RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
			IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
			THEN
			    EXITLOOP;
			END;

		    IF .RSTPTR[RST$B_KIND] EQL RST$K_MODULE
		    THEN
			IF .RSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO
			THEN
			    BEGIN
			    RSTPTR = .RSTPTR_TMP;
			    END
			ELSE
			    $DBG_ERROR ('DBGSYMBLZ\SEARCH_MODULE_SAT:  routine not found');
		    END;
		END;

	[RST$K_DATA]:
	    BEGIN
	    0;
	    END;

	[INRANGE, OUTRANGE]:
	    $DBG_ERROR ('DBGSYMBLZ\SEARCH_MODULE_SAT:  invalid RST kind');
	TES;


    ! If the address was found in the module, MODRSTPTR contains that module's
    ! RST pointer.  Otherwise, it contains 0.
    !
    RETURN 0;
    END;


ROUTINE BUILD_PRIMARY_SUBNODE(PRIMPTR, SYMID, BIT_OFFSET) =
!
! FUNCTION
!	This routine is a recursive routine to be called to build the
!	Primary subnode.  For Array or Record type, we need to do
!	more work to symbolize down to record component or array element
!	level.  For other type, return the primary from this routine.
!
! INPUTS
!	PRIMPTR	- Pointer to Primary.
!
!	SYMID	- Pointer to SYMID.
!
!	BIT_OFFSET - Bit offset to the given object.
!
! OUTPUTS
!	Return value is the pointer to Primary.  And Bit offsets to the
!	primary is passed back to the caller. (BIT_OFFSET updated accordingly).
!

    BEGIN

    MAP
	BIT_OFFSET: REF VECTOR[,LONG],	! Bit offset to Primary
	PRIMPTR: REF DBG$PRIMARY,	! Pointer to Primary
	SYMID: REF RST$ENTRY;		! Pointer to Symid

    LOCAL
	FCODE,				! Fcode of the symid to be build
	KIND,				! Kind of this symid to be build
	TYPEID: REF RST$ENTRY;		! Pointer to TYPEID for the SYMID

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;	! Update the current primary

    FCODE = 0;
    TYPEID = 0;
    DBG$STA_SYMKIND (.SYMID, KIND);


    ! Check to see if this is a data item, if it is get more inforamtion.
    !
    IF .KIND EQL RST$K_DATA OR
       .KIND EQL RST$K_TYPCOMP OR
       .KIND EQL RST$K_TYPE
    THEN
	DBG$STA_SYMTYPE(.SYMID, FCODE, TYPEID);


    ! Call DBG$BUILD_PRIMARY_SUBNODE to build a subnode and fill in all of
    ! the subnode information.
    !
    IF .KIND EQL RST$K_TYPE
    THEN
	BEGIN
	KIND = RST$K_DATA;
	SYMID = 0;
	END;

    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, .KIND, .SYMID, .FCODE, .TYPEID, 0);


    ! Do more work for array and record component --  Symbolize down to
    ! the components + offset.  For example, Array+15 --> Array(3)+3.
    !
    CASE .FCODE FROM RST$K_TYPE_MINIMUM TO RST$K_TYPE_MAXIMUM OF
	SET
	[RST$K_TYPE_ARRAY]:
	    IF .DBG$GL_ARRSUB_FLAG
	    THEN
		PRIMPTR = SYMBOLIZE_ARRAY_ELEMENT(.PRIMPTR, .BIT_OFFSET)
	    ELSE
		PRIMPTR[DBG$V_DHDR_AGGR] = FALSE;

	[RST$K_TYPE_RECORD]:
	    IF .DBG$GL_RECCMP_FLAG
	    THEN
		PRIMPTR = SYMBOLIZE_RECORD_COMPONENT(.PRIMPTR, .BIT_OFFSET)
	    ELSE
		PRIMPTR[DBG$V_DHDR_AGGR] = FALSE;

	[INRANGE, OUTRANGE]:
	    0;

	TES;

    RETURN .PRIMPTR;
    END;


ROUTINE GET_RECORD_COMPONENT(PRIMPTR, COMPTR, BIT_OFFSET, SYMID, OFFSET, IDX) =
!
! FUNCTION
!	This routine calculates the record component offsets to the record
!	address and then compares the value with the offset to the primary
!	we got so far.  If the value we just calculated is better than the
!	one we got so far, choice this one instead.  This routine is
!	recursive in a sense that if one of the record component is a
!	variant, we need to get a list of the variant components.  Then
!	figure out the offsets for each variant and choose the better
!	variant for the given record component.
!
! INPUTS
!	PRIMPTR	- Pointer to Primary descriptor.
!
!	COMPTR	- Pointer to the record component or variant component.
!
!	BIT_OFFSET - Offset value to the Primary.
!
!	SYMID	- The symid we choose for the record component, or variant.
!
!	OFFSET	- Offset value of the component.
!
!	IDX	- Ith component index.
!
! OUTPUTS
!	Return value is the pointer to the primary.
!	Note: The primary returned from this routine may not be in a stable
!	state. (The infomation in the root node may not be updated properly).
!	When next time around to build primary subnode, it will be updated
!	properly.
!

    BEGIN

    MAP
	BIT_OFFSET: REF VECTOR[,LONG],	! Desired offset value to Begin of
					!	the Record
	COMPTR: REF RST$ENTRY,		! Pointer to component RST
	OFFSET: REF VECTOR[,LONG],	! Offset Value to Begin of the Record
					!	for SYMID
	PRIMPTR: REF DBG$PRIMARY,	! Pointer to Primary Root Node
	SYMID: REF VECTOR[,LONG];	! Pointer to desired RST

    BUILTIN
	REMQUE;

    LOCAL
	COMPVECPTR: REF VECTOR[,LONG],	! Pointer to a list of variants
	DUMMY,				! Dummy as it is
	KIND,				! Data kind
	SUBNODE: REF DBG$PRIM_NODE,	! Last primary subnode
	TAGID,				! Variant Tag variable
	TAG_NAME: REF VECTOR[,BYTE],	! Variant Tag name
	TAG_VAL,			! Tag value
	TMP_OFFSET,			! Temporary offset
	TMP_SYMID,			! Temporary symid
	VAL_DESC: REF DBG$VALDESC,	! Tag Value descriptor
	VALKIND,			! Data value kind
	VALPTR: VECTOR[3, LONG],	! Data value
	VARIANT: REF RST$VAR_ENTRY;	! Variant



    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;	! Update the current primary

    ! Set the context for the given RST entry.
    !
    DBG$STA_SETCONTEXT(.COMPTR);
    DBG$STA_SYMKIND(.COMPTR, KIND);


    ! Check to see if this is a variant.
    !
    IF .KIND EQL RST$K_VARIANT
    THEN
	BEGIN
	VARIANT = 0;


	! Check to see if this variant has a tag variable.  Also check to
	! see if the tag variable has a name.
	!
	IF (TAGID = .COMPTR[RST$L_VARTAGPTR]) NEQ 0
	THEN
	    BEGIN
	    DBG$STA_SYMNAME(.TAGID, TAG_NAME);
	    IF .TAG_NAME[0] NEQ 0
	    THEN
		BEGIN


		! Build a subnode for the tag variable.
		!
		PRIMPTR = BUILD_PRIMARY_SUBNODE(.PRIMPTR, .TAGID, .BIT_OFFSET);


		! Get the value for the tag variable.
		!
		DBG$PRIM_TO_VAL(.PRIMPTR, DBG$K_VALUE_DESC, VAL_DESC);
		TAG_VAL = .VAL_DESC[DBG$L_VALUE_VALUE0];


		! Call variant select routine to select the variant components
		! given tag value and the pointer to the variant.
		!
		VARIANT = DBG$STA_VARIANT_SELECT(.TAG_VAL, .COMPTR);


		! We have no use for the tag variable, take it off from the
		! subnode.
		!
		REMQUE(.PRIMPTR[DBG$L_PRIM_BLINK], DUMMY);
		END;

	    END;


	! We have got variant components.
	!
	IF .VARIANT NEQ 0
	THEN
	    BEGIN


	    ! Build subnode for this variant, fill in information.
	    ! Note: Remember to take this node away, if this is not what we
	    ! want.
	    !
	    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, RST$K_VARIANT, 0,
		RST$K_TYPE_VARIANT, 0, 0);
	    SUBNODE = .PRIMPTR[DBG$L_PRIM_BLINK];
	    SUBNODE[DBG$L_PNVAR_TAGID] = .TAGID;
	    SUBNODE[DBG$W_PNVAR_INDEX] = 1;
	    SUBNODE[DBG$V_PNVAR_VALID] = TRUE;
	    SUBNODE[DBG$W_PNVAR_NCOMPS] = .VARIANT[RST$L_VAR_COMPCNT];
	    SUBNODE[DBG$L_PNVAR_COMPLST] = VARIANT[RST$A_VAR_COMPLST];
	    SUBNODE[DBG$L_PNVAR_DSTPTR] = .VARIANT[RST$L_VAR_DSTPTR];


	    ! Calculate the offsets of the variant components.  Call
	    ! GET_RECORD_COMPONENT to get the better variant component.
	    !
	    COMPVECPTR = VARIANT[RST$A_VAR_COMPLST];
	    TMP_SYMID = .SYMID[0];
	    TMP_OFFSET = .OFFSET[0];
	    INCR I FROM 0 TO .VARIANT[RST$L_VAR_COMPCNT] - 1 DO
		BEGIN
		PRIMPTR = GET_RECORD_COMPONENT(.PRIMPTR, .COMPVECPTR[.I],
				.BIT_OFFSET, TMP_SYMID, TMP_OFFSET, .I);
		END;


	    ! If we did not find one, take the subnode off.
	    !
	    IF .TMP_SYMID EQL .SYMID[0] AND
	       .TMP_OFFSET EQL .OFFSET[0]
	    THEN
		REMQUE(.PRIMPTR[DBG$L_PRIM_BLINK], DUMMY)


	    ! We got one variant component.
	    !
	    ELSE
		BEGIN
		SYMID[0] = .TMP_SYMID;
		OFFSET[0] = .TMP_OFFSET;
		SUBNODE[DBG$W_PNVAR_INDEX] = .IDX + 1;
		END;

	    END;

	END


    ! This is the normal case, get the component offset value.
    ! Select the smallest positive offset.
    !
    ELSE
	BEGIN
	DBG$STA_SYMVALUE(.COMPTR, VALPTR, VALKIND);
	IF .VALKIND EQL DBG$K_VAL_ADDR
	THEN
	    BEGIN
	    LOCAL
		VAL_OFFSET;

	    VAL_OFFSET = .VALPTR[0] * 8 + .VALPTR[1];
	    IF .VAL_OFFSET LEQ .BIT_OFFSET[0]
	    THEN
		BEGIN
		IF (.BIT_OFFSET[0] - .VAL_OFFSET) LEQ (.BIT_OFFSET[0] - .OFFSET[0])
		THEN
		    BEGIN
		    SYMID[0] = .COMPTR;
		    OFFSET[0] = .VAL_OFFSET;
		    SUBNODE = .PRIMPTR[DBG$L_PRIM_BLINK];
		    SUBNODE[DBG$W_PNREC_INDEX] = .IDX + 1;
		    END;

		END;

	    END;

	END;			! End of ELSE clause for non-variant type of
				!	record component.

    RETURN .PRIMPTR;
    END;


ROUTINE SYMBOLIZE_ARRAY_ELEMENT(PRIMPTR, BIT_OFFSET) =
!
! FUNCTION
!	This routine figures out the array element from offset value to
!	the start of the array.  And build primary subnode for the
!	array element.
!
! INPUTS
!	PRIMPTR	- Pointer to Primary descriptor.
!
!	BIT_OFFSET - Array element offset value in bits to the start of
!		the array.
!
! OUTPUTS
!	Return value is the pointer to the primary descriptor for the
!	array element.  BIT_OFFSET is the offset value in bits to
!	the primary.
!

    BEGIN

    MAP
	BIT_OFFSET: REF VECTOR[,LONG],	! Array cell Bit offset to array
	PRIMPTR: REF DBG$PRIMARY;	! Primary descriptor for the object

    LOCAL
	ARRAY_SUBNODE: REF DBG$PRIM_NODE,! Pointer to Array subnode
	ARRAY_SUBVEC: REF DBG$PRIM_NODE_SUBS,! Pointer to array subscript info
	BOUND_FLAG,			! Flag to indicate the bound is exceeded
	OFFSET,				! Offset value
	STRIDE;				! Stride along each dimension in bits


    ARRAY_SUBNODE = .PRIMPTR[DBG$L_PRIM_BLINK];
    IF .ARRAY_SUBNODE[DBG$B_PNODE_FCODE] NEQ RST$K_TYPE_ARRAY
    THEN
	$DBG_ERROR('DBGSYMBLZ\SYMBOLIZE_ARRAY_ELEMENT');


    ! We treat the start of the array is the first array element.
    !
    IF .BIT_OFFSET[0] EQL 0
    THEN
	BEGIN
	ARRAY_SUBNODE[DBG$V_PNODE_EVAL] = TRUE;
	RETURN BUILD_PRIMARY_SUBNODE(.PRIMPTR, .ARRAY_SUBNODE[DBG$L_PNARR_CELLTYPE],
	    .BIT_OFFSET);
	END;


    ! Divide the offset by largest stride and then adjusted by the lower bound,
    ! this is the subscript we want.
    !
    OFFSET = .BIT_OFFSET[0];
    ARRAY_SUBVEC = ARRAY_SUBNODE[DBG$A_PNARR_SVECTOR];
    BOUND_FLAG = FALSE;
    IF .ARRAY_SUBNODE[DBG$V_PNARR_COLUMN]
    THEN
	BEGIN
	DECR I FROM .ARRAY_SUBNODE[DBG$B_PNARR_DIMCNT] - 1 TO 0 DO
	    BEGIN
	    IF .ARRAY_SUBNODE[DBG$V_PNARR_BITREF]
	    THEN
		STRIDE = .ARRAY_SUBVEC[.I, DBG$L_PNSUB_STRIDE]

	    ELSE
		STRIDE = .ARRAY_SUBVEC[.I, DBG$L_PNSUB_STRIDE] * 8;

	    ARRAY_SUBVEC[.I, DBG$L_PNSUB_SVALUE] =
		.OFFSET / .STRIDE + .ARRAY_SUBVEC[.I, DBG$L_PNSUB_LBOUND];

	    IF .ARRAY_SUBVEC[.I, DBG$L_PNSUB_SVALUE] GTR
	       .ARRAY_SUBVEC[.I, DBG$L_PNSUB_UBOUND]
	    THEN
		BOUND_FLAG = TRUE;

	    OFFSET = .OFFSET MOD .STRIDE;
	    END;

	END

    ELSE
	BEGIN
	INCR I FROM 0 TO .ARRAY_SUBNODE[DBG$B_PNARR_DIMCNT] - 1 DO
	    BEGIN
	    IF .ARRAY_SUBNODE[DBG$V_PNARR_BITREF]
	    THEN
		STRIDE = .ARRAY_SUBVEC[.I, DBG$L_PNSUB_STRIDE]

	    ELSE
		STRIDE = .ARRAY_SUBVEC[.I, DBG$L_PNSUB_STRIDE] * 8;

	    ARRAY_SUBVEC[.I, DBG$L_PNSUB_SVALUE] =
		.OFFSET / .STRIDE + .ARRAY_SUBVEC[.I, DBG$L_PNSUB_LBOUND];

	    IF .ARRAY_SUBVEC[.I, DBG$L_PNSUB_SVALUE] GTR
	       .ARRAY_SUBVEC[.I, DBG$L_PNSUB_UBOUND]
	    THEN
		BOUND_FLAG = TRUE;

	    OFFSET = .OFFSET MOD .STRIDE;
	    END;

	END;


    ! Make sure the subscripts calculated from above are not exceed the bounds.
    !
    OFFSET = 0;
    INCR I FROM 0 TO .ARRAY_SUBNODE[DBG$B_PNARR_DIMCNT] - 1 DO
	BEGIN
	IF .BOUND_FLAG
	THEN
	    ARRAY_SUBVEC[.I, DBG$L_PNSUB_SVALUE] =
		.ARRAY_SUBVEC[.I, DBG$L_PNSUB_UBOUND];

	IF .ARRAY_SUBNODE[DBG$V_PNARR_BITREF]
	THEN
	    STRIDE = .ARRAY_SUBVEC[.I, DBG$L_PNSUB_STRIDE]

	ELSE
	    STRIDE = .ARRAY_SUBVEC[.I, DBG$L_PNSUB_STRIDE] * 8;

	OFFSET = .OFFSET + .ARRAY_SUBVEC[.I, DBG$L_PNSUB_SVALUE] * .STRIDE;
	END;


    ! Adjust the offset.  Based on A(0,0,...).
    !
    IF .ARRAY_SUBNODE[DBG$V_PNARR_BITREF]
    THEN
	BIT_OFFSET[0] = .BIT_OFFSET[0] + (-1 * .ARRAY_SUBNODE[DBG$L_PNARR_OFFSET])

    ELSE
	BIT_OFFSET[0] = .BIT_OFFSET[0] + (-8 * .ARRAY_SUBNODE[DBG$L_PNARR_OFFSET]);


    BIT_OFFSET[0] = .BIT_OFFSET[0] - .OFFSET;
    ARRAY_SUBNODE[DBG$V_PNODE_EVAL] = TRUE;
    ARRAY_SUBNODE[DBG$B_PNARR_SUBCNT] = .ARRAY_SUBNODE[DBG$B_PNARR_DIMCNT];
    RETURN BUILD_PRIMARY_SUBNODE(.PRIMPTR, .ARRAY_SUBNODE[DBG$L_PNARR_CELLTYPE],
	.BIT_OFFSET);

    END;


ROUTINE SYMBOLIZE_RECORD_COMPONENT(PRIMPTR, BIT_OFFSET) =
!
! FUNCTION
!	This routine gets a list of record components, call GET_RECORD_COMPONENT
!	to figure out THE component that is closest to the desired address.
!
! INPUTS
!	PRIMPTR	- Pointer to primary descriptor.
!
!	BIT_OFFSET - Offset value to the Primary.
!
! OUTPUTS
!	Returned value is the Pointer to primary and updated offset value
!	to the Primary.
!

    BEGIN

    MAP
	BIT_OFFSET: REF VECTOR[,LONG],	! Offset to Primary
	PRIMPTR: REF DBG$PRIMARY;	! Pointer to Primary

    LOCAL
	BITSIZE,			! Bit size of the record (not used)
	COMPVECPTR: REF VECTOR[,LONG],	! Pointer to vector of component
					!	SYMIDs for this record type
	NCOMPS,				! Number of components for this record
	OFFSET,				! Left over offsets to Primary
	REC_SUBNODE: REF DBG$PRIM_NODE, ! Pointer to Primary Subnode
	SYMID: REF RST$ENTRY;		! Symid pointer


    ! Get the last subnode we just built.  (This one must be a RST$K_TYPE_RECORD.
    ! type).
    !
    REC_SUBNODE = .PRIMPTR[DBG$L_PRIM_BLINK];
    IF .REC_SUBNODE[DBG$B_PNODE_FCODE] NEQ RST$K_TYPE_RECORD
    THEN
	$DBG_ERROR('DBGSYMBLZ\SYMBOLIZE_RECORD_COMPONENT');


    ! Get a list of record components for this record..
    !
    DBG$STA_TYP_RECORD(.REC_SUBNODE[DBG$L_PNODE_TYPEID], NCOMPS, COMPVECPTR,
	BITSIZE);


    ! Find a SYMID from this list of record components has the closest
    ! offset value to the given offset value.
    !
    SYMID = 0;
    OFFSET = 0;
    INCR I FROM 0 TO .NCOMPS - 1 DO
	BEGIN
	PRIMPTR = GET_RECORD_COMPONENT(.PRIMPTR, .COMPVECPTR[.I],
			.BIT_OFFSET, SYMID, OFFSET, .I);
	END;


    ! We did not find a record component just returned the primary we got
    ! so far.
    !
    IF .SYMID EQL 0 THEN RETURN .PRIMPTR;


    ! We have found a better symbol, re-figure the offset value to the
    ! record component.
    !
    BIT_OFFSET[0] = .BIT_OFFSET[0] - .OFFSET;


    ! Building the Primary subnode for record component.
    !
    REC_SUBNODE[DBG$V_PNODE_EVAL] = TRUE;
    RETURN BUILD_PRIMARY_SUBNODE(.PRIMPTR, .SYMID, .BIT_OFFSET);
    END;

END ELUDOM
