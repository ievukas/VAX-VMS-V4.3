; 
; ****************************************************************************
; *									    *
; *  Copyright (c) 1982, 1983		                                    *
; *  by DIGITAL Equipment Corporation, Maynard, Mass.			    *
; * 									    *
; *  This software is furnished under a license and may be used and  copied  *
; *  only  in  accordance  with  the  terms  of  such  license and with the  *
; *  inclusion of the above copyright notice.  This software or  any  other  *
; *  copies  thereof may not be provided or otherwise made available to any  *
; *  other person.  No title to and ownership of  the  software  is  hereby  *
; *  transferred.							    *
; * 									    *
; *  The information in this software is subject to change  without  notice  *
; *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
; *  Corporation.							    *
; * 									    *
; *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
; *  software on equipment which is not supplied by DIGITAL.		    *
; *									    *
; ****************************************************************************
; *********************************************************************************************************************************
;  Created 15-SEP-1984 22:54:37  by  VAX-11 SDL V2.0       Source: 15-SEP-1984 22:49:24 _$255$DUA28:[RMS.SRC]RMSINTSTR.SDL;1       
; *********************************************************************************************************************************
 
 
	.MACRO	$IFBDEF,$GBL
	$DEFINI	IFB,$GBL
; 
;   NOTE:  The fields thru JNLBDB inclusive are common between the ifb and irb
; 
$EQU	IFB$C_BID	11              ;  ifab id code 
$EQU	IFB$M_PUT	1
$EQU	IFB$M_GET	2
$EQU	IFB$M_DEL	4
$EQU	IFB$M_UPD	8
$EQU	IFB$M_TRN	16
$EQU	IFB$M_BIO	32
$EQU	IFB$M_BRO	64
$EQU	IFB$M_EXE	128
$EQU	IFB$C_SEQ	0               ;  sequential 
$EQU	IFB$C_REL	1               ;  relative 
$EQU	IFB$C_IDX	2               ;  indexed 
$EQU	IFB$C_DIR	3               ;  direct 
$EQU	IFB$C_MAXORG	2               ;  release 1.5 maximum 
$EQU	IFB$K_FHAEND	102             ;  end of file header attributes 
$EQU	IFB$C_FHAEND	102             ;  end of file header attributes 
$EQU	IFB$C_KBUFNUM	6               ;  constant - the number of key buffers allocated 
$EQU	IFB$M_ONLY_RU	1
$EQU	IFB$M_RU	2
$EQU	IFB$M_BI	4
$EQU	IFB$M_AI	8
$EQU	IFB$M_AT	16
$EQU	IFB$M_NEVER_RU	32
$EQU	IFB$M_RU_RECVR	1
$EQU	IFB$M_AI_RECVR	2
$EQU	IFB$M_BI_RECVR	4
$EQU	IFB$M_VALID_AT	1
$EQU	IFB$M_JNL	2
$EQU	IFB$M_RUP	4
$EQU	IFB$M_RU_RLK	8
$EQU	IFB$M_DONE_ASS_JNL	16
$EQU	IFB$K_BLN_SEQ	172
$EQU	IFB$C_BLN_SEQ	172
; --
; 
;   organization-dependent fields
; 
;   the following fields are used differently
;   depending upon the file's organization
; 
; ++
; 
;   relative org specific fields
; 
;  (but have definitions that allow them to
;   be referenced from the start of the ifab)
; ++
;   the following bits are defined in
;   common with the irab
; 
$EQU	IFB$V_BUSY	32              ;  stream busy 
$EQU	IFB$V_EOF	33              ;  file positioned at eof 
$EQU	IFB$V_PPF_IMAGE	34              ;  flag for indirect processing of process- 
;  permanent files (restricts allowable operations)
$EQU	IFB$V_ASYNC	35              ;  async i/o flag (must be zero for ifab) 
$EQU	IFB$V_ASYNCWAIT	36              ;  wait on async i/o (must be zero for ifab) 
; --
; 
;   ifab specific bits
; 
$EQU	IFB$V_ACCESSED	37              ;  file is accessed 
$EQU	IFB$V_ANSI_D	38              ;  ansi d variable records 
$EQU	IFB$V_RWC	39              ;  copy of fop bit from open 
$EQU	IFB$V_DMO	40              ;  copy of fop bit from open 
$EQU	IFB$V_SPL	41              ;  copy of fop bit from open 
$EQU	IFB$V_SCF	42              ;  copy of fop bit from open 
$EQU	IFB$V_DLT	43              ;  copy of fop bit from open 
$EQU	IFB$V_DFW	44              ;  deferred write (copy of fop bit from $open) 
$EQU	IFB$V_SQO	45              ;  sequential operations only 
$EQU	IFB$V_PPF_INPUT	46              ;  this is command 'input' stream 
$EQU	IFB$V_NFS	47              ;  non-file structured flag 
$EQU	IFB$V_WRTACC	48              ;  logical or of fac bits: 
;    put, upd, del, trn
$EQU	IFB$V_MSE	49              ;  multi-streams enabled 
$EQU	IFB$V_CREATE	50              ;  set if doing create (may be "create if") 
$EQU	IFB$V_NORECLK	51              ;  record locking not required 
;  (i.e., no shared access or multi-stream)
$EQU	IFB$V_RW_ATTR	52              ;  set if file attributes must be re-written 
$EQU	IFB$V_TMP	53              ;  temporary file (i.e., no directory entry) 
$EQU	IFB$V_TEF	54              ;  truncate at eof due to large auto extend 
$EQU	IFB$V_STALL_LOCK	55      ;  RMS is stalled for file lock 
$EQU	IFB$V_SEQFIL	56              ;  this is really a sequential file being shared 
$EQU	IFB$V_SEARCH	57              ;  search ifab - left during wildcard operations 
$EQU	IFB$V_RMS_STALL	58              ;  RMS is stalled on this file operation 
$EQU	IFB$V_RESTART	59              ;  Reopen or recreate operation in progress 
$EQU	IFB$V_FILEFOUND	60              ;  A file was found on a search operation 
$EQU	IFB$V_DAP_OPEN	61              ;  open/create function was performed via dap 
$EQU	IFB$V_DAP	62              ;  data access protocol transmission 
$EQU	IFB$V_NSP	63              ;  network services protocol transmission 
$EQU	IFB$L_PRIM_DEV	0               ;  device characteristics bits 
;  (for primary device - bit encoding same as for fab)
$EQU	IFB$L_BKPBITS	4               ;  bookkeeping bits 
; 
$EQU	IFB$B_BID	8               ;  block id 
$EQU	IFB$B_BLN	9               ;  block length in longwords 
$EQU	IFB$B_MODE	10              ;  caller's mode 
$EQU	IFB$B_EFN	11              ;  event flag used for synchronous qio 
$EQU	IFB$L_IOS	12              ;  internal i/o status block 
$EQU	IFB$L_BWB	12              ;  bucket wait block for inter stream waiting 
$EQU	IFB$W_IOS2	14              ;  high word of io status block 
$EQU	IFB$L_IOS4	16              ;  2nd longword of io status block 
$EQU	IFB$L_ASBADDR	20              ;  address of asynchronous context block 
$EQU	IFB$L_ARGLST	24              ;  user call parameters addr 
$EQU	IFB$L_IRAB_LNK	28              ;  pointer to irab(s) 
$EQU	IFB$W_CHNL	32              ;  i/o channel number 
$EQU	IFB$B_FAC	34              ;  file access 
$EQU	IFB$V_PUT	0               ;  (same as in fab's fac field) 
$EQU	IFB$V_GET	1
$EQU	IFB$V_DEL	2
$EQU	IFB$V_UPD	3
$EQU	IFB$V_TRN	4
$EQU	IFB$V_BIO	5
$EQU	IFB$V_BRO	6
$EQU	IFB$V_EXE	7
;  note: if both bio and bro set, implies block i/o
;         access only allowed for this connect, resets
;         to bro on disconnect (seq. file org. only).
; 
$EQU	IFB$B_ORGCASE	35              ;  copy of org for case dispatching 
$EQU	IFB$L_LAST_FAB	36              ;  address of fab for last operation 
$EQU	IFB$W_IFI	40              ;  Internal file Identifier, the one we gave to the user 
$EQU	IFB$W_ECHO_ISI	42              ;  ISI of stream to echo records from SYS$INPUT 
$EQU	IFB$L_ATJNLBUF	44              ;  address of IFAB audit trail buffer 
$EQU	IFB$L_JNLBDB	48              ;  address of Journaling BDB for FAB operations 
; -----*****
$EQU	IFB$L_EXTJNLBUF	52              ;  pointer to buffer to contain extend journal record 
$EQU	IFB$L_FWA_PTR	56              ;  pointer to file work area control block 
$EQU	IFB$L_NWA_PTR	60              ;  pointer to network work area control block 
$EQU	IFB$L_BDB_FLNK	64              ;  pointer to bdb(s) 
$EQU	IFB$L_BDB_BLNK	68              ;  bdb backward link 
$EQU	IFB$L_DEVBUFSIZ	72              ;  device default (or bls if mt) buff size 
$EQU	IFB$W_RTDEQ	76              ;  run-time default extend quantity 
$EQU	IFB$B_SHR	78              ;  File sharing bits from users FAB 
$EQU	IFB$B_AGENT_MODE	79      ;  User's FAB$V_FILE_MODE field, maximized with mode of caller
; 
; +++++*****
; 
;   the following fields must remain as is since
;   they correspond to the rms attributes stored
;   in the file header
; 
$EQU	IFB$B_RFMORG	80              ;  organization and record format 
$EQU	IFB$S_RFM	4
$EQU	IFB$V_RFM	0               ;  record format (n.b. constant values defined in rfm field of fab) 
$EQU	IFB$S_ORG	4
$EQU	IFB$V_ORG	4               ;  file organization 
$EQU	IFB$B_RAT	81              ;  record attributes (n.b. bit offsets defined in rat field of fab) 
$EQU	IFB$W_LRL	82              ;  longest record's length (or fixed record length) 
$EQU	IFB$L_HBK_DISK	84              ;  hi vbn allocated (note: disk format!) 
$EQU	IFB$L_EBK_DISK	88              ;  eof vbn (note: disk format!) 
$EQU	IFB$W_FFB	92              ;  first free byte in eof block 
$EQU	IFB$B_BKS	94              ;  bucket size (! vbns) 
$EQU	IFB$B_FSZ	95              ;  record header size for vfc 
$EQU	IFB$W_MRS	96              ;  max record size allowable 
$EQU	IFB$W_DEQ	98              ;  default extend quantity 
$EQU	IFB$W_GBC	100             ;  global buffer count 
; -----*****
$EQU	IFB$B_DRT_REHIT	104             ;  hit count for local dirty buffers. 
$EQU	IFB$B_GBL_REHIT	105             ;  rehit count for gbl buffers. 
$EQU	IFB$L_RNS_LEN	108             ;  resultant name string length (used as a temp field by $search) 
$EQU	IFB$L_LOCK_BDB	108             ;  lock bdb address (used by $extend for rel. file) 
$EQU	IFB$L_HBK	112             ;  hi vbn allocated. 
$EQU	IFB$L_EBK	116             ;  eof vbn. 
$EQU	IFB$L_SFSB_PTR	120             ;  pointer to shared file synchronization block 
$EQU	IFB$L_GBSB_PTR	124             ;  pointer to global buffer synchronization block. 
$EQU	IFB$L_PAR_LOCK_ID	128     ;  Parent lock ID for bucket locks (get from SFSB.) 
$EQU	IFB$W_AVLCL	132             ;  local buffers available. 
$EQU	IFB$W_AVGBPB	134             ;  gbl ptr blocks available. 
$EQU	IFB$L_GBH_PTR	136             ;  pointer to global header. 
$EQU	IFB$L_AS_DEV	140             ;  assigned device characteristics 
;                 AS_DEV and ASDEVBSIZ *)
$EQU	IFB$L_ASDEVBSIZ	148             ;  assigned device buffer size 
$EQU	IFB$L_BLBFLNK	152             ;  Forward link to BLB chain. 
$EQU	IFB$L_BLBBLNK	156             ;  Back link to BLB chain. 
$EQU	IFB$B_JNLFLG	160             ;  journaling attribute flags 
$EQU	IFB$V_ONLY_RU	0               ;  Recovery Unit journaling, no access outside RU 
$EQU	IFB$V_RU	1               ;  Recovery Unit journaling 
$EQU	IFB$V_BI	2               ;  Before Image journaling 
$EQU	IFB$V_AI	3               ;  After Image jouraling 
$EQU	IFB$V_AT	4               ;  Audit Trail journaling 
$EQU	IFB$V_NEVER_RU	5               ;  never do RU journaling 
$EQU	IFB$B_RECVRFLGS	161             ;  Recovery flags 
$EQU	IFB$V_RU_RECVR	0               ;  Recovery Unit Rollback in progress 
$EQU	IFB$V_AI_RECVR	1               ;  AI Roll Forward Recovery in progress 
$EQU	IFB$V_BI_RECVR	2               ;  BI Roll Backward Recovery in progress 
$EQU	IFB$B_JNLFLG2	162             ;  Secondary journaling flags (generally operation specific) 
$EQU	IFB$V_VALID_AT	0               ;  AT entry in IFB buffer is valid and should be written 
$EQU	IFB$V_JNL	1               ;  Journaling Initialized for this file 
$EQU	IFB$V_RUP	2               ;  Recovery Unit in progress 
$EQU	IFB$V_RU_RLK	3               ;  Fake record locking during recovery unit 
$EQU	IFB$V_DONE_ASS_JNL	4       ;  Journal channels already assigned 
$EQU	IFB$L_RJB	164             ;  RMS Journaling Block address 
$EQU	IFB$W_BUFFER_OFFSET	168     ;  ANSI buffer offset
$EQU	IFB$K_BLN_REL	180
$EQU	IFB$C_BLN_REL	180
; --
; ++
; 
;   indexed org specific fields
; 
$EQU	IFB$L_MRN	172             ;  (rel) max record number 
$EQU	IFB$L_DVBN	176             ;  (rel) first data bucket vbn 
$EQU	IFB$K_BLN_IDX	184
$EQU	IFB$C_BLN_IDX	184
$EQU	IFB$K_BLN	184             ;  ifab length 
$EQU	IFB$C_BLN	184             ;  ifab length 
; --
$EQU	IFB$L_IDX_PTR	172             ;  (idx) pointer to primary key index descriptor 
$EQU	IFB$B_AVBN	176             ;  (idx) vbn of 1st area descriptor 
$EQU	IFB$B_AMAX	177             ;  (idx) total number of area descriptors 
$EQU	IFB$B_NUM_KEYS	178             ;  (idx) ! of keys in file 
$EQU	IFB$B_UBUFSZ	179             ;  (idx) update buffer size for keys 
$EQU	IFB$W_KBUFSZ	180             ;  (idx) key buffer size 
$EQU	IFB$B_EXTRABUF	182             ;  (idx) number of extra buffers for 'cache'ing 
$EQU	IFB$B_PLG_VER	183             ;  (idx) prologue version number 
	$DEFEND	IFB,$GBL,DEF
	.ENDM
 
	.MACRO	$IRBDEF,$GBL
	$DEFINI	IRB,$GBL
; 
;         IRB field definitions
; 
;         Internal rab (irb)
; 
;         There is 1 irab per connected record access stream
; 
; 
;   NOTE: The fields thru JNLBDB inclusive are common between the irb and ifb
; 
$EQU	IRB$C_BID	10              ;  irab code 
$EQU	IRB$M_POSINSERT	1
$EQU	IRB$M_SRCHGT	2
$EQU	IRB$M_POSDELETE	4
$EQU	IRB$M_NEW_IDX	8
$EQU	IRB$M_SRCHGE	16
$EQU	IRB$M_NORLS_RNF	32
$EQU	IRB$M_FIRST_TIM	64
$EQU	IRB$M_PRM	128
$EQU	IRB$M_DUP_KEY	256
$EQU	IRB$M_DEL_SEEN	512
$EQU	IRB$M_LAST_GT	1024
$EQU	IRB$M_BKT_NO_LO	1
$EQU	IRB$M_NEW_BKTS	6
$EQU	IRB$M_REC_W_LO	8
$EQU	IRB$M_CONT_BKT	16
$EQU	IRB$M_CONT_R	32
$EQU	IRB$M_EMPTY_BKT	64
$EQU	IRB$M_DUPS_SEEN	128
$EQU	IRB$M_BKT_NO	3
$EQU	IRB$M_BIG_SPLIT	4
$EQU	IRB$M_SPL_IDX	1
$EQU	IRB$M_EMPT_SEEN	2
$EQU	IRB$M_VALID_AT	1
$EQU	IRB$K_BLN_REL	100
$EQU	IRB$C_BLN_REL	100
; ++
; 
;   sequential org specific fields
; 
$EQU	IRB$K_BLN_SEQ	108
$EQU	IRB$C_BLN_SEQ	108
;  to apply from start of irab
; ++
; 
;   the following bits are defined in common
;   with the ifab
; 
$EQU	IRB$V_BUSY	32              ;  file busy 
$EQU	IRB$V_EOF	33              ;  stream positioned at eof 
$EQU	IRB$V_PPF_IMAGE	34              ;  flag for indirect processing of process- 
;  permanent file
$EQU	IRB$V_ASYNC	35              ;  asynchronous i/o request 
$EQU	IRB$V_ASYNCWAIT	36              ;  $wait issued for asynchronous i/o request 
; --
; 
;    irab specific bits
; 
$EQU	IRB$V_FIND_LAST	37              ;  last operation was a find 
$EQU	IRB$V_PUTS_LAST	38              ;  last operation was a put sequential 
$EQU	IRB$V_BIO_LAST	39              ;  this/last operation is/was a block i/o operation 
;  note: this bit is set only if mixed block and record
;        operations (bro access).  after call to rm$rset
;         refers to the current operation and bro_sw gives
;         type of last operation.
$EQU	IRB$V_BRO_SW	40              ;  switched from record operation to block i/o operation 
$EQU	IRB$V_FIND	41              ;  operation is a find 
$EQU	IRB$V_RAHWBH	42              ;  read ahead or write behind processing 
$EQU	IRB$V_SKIP_NEXT	43              ;  skip to next record flag for index fo 
$EQU	IRB$V_DUP	44              ;  duplicate records seen 
$EQU	IRB$V_UNLOCK_RP	45              ;  release lock on current (rp) record 
$EQU	IRB$V_PPF_EOF	46              ;  give one-shot rms$_eof error on sys$input 
$EQU	IRB$V_PPF_SKIP	47              ;  skip sys$input record ($deck), redoing $get 
;  or $find on next record
$EQU	IRB$V_PPF_FNDSV	48              ;  save value for find bit when ppf_skip set 
$EQU	IRB$V_IDX_ERR	49              ;  index update error occurred 
$EQU	IRB$V_RRV_ERR	50              ;  rrv update error occurred 
$EQU	IRB$V_UPDATE	51              ;  operation is an update (indexed) 
$EQU	IRB$V_UPDATE_IF	52              ;  operation was a $PUT -> $UPDATE 
$EQU	IRB$V_ABOVELCKD	53              ;  level above was locked by search_tree 
$EQU	IRB$V_GBLBUFF	54              ;  global buffers are in use. 
$EQU	IRB$V_CON_EOF	55              ;  file positioned at EOF by $CONNECT (isam) 
$EQU	IRB$V_NO_Q_WAIT	56              ;  do not wait for enqueues on query_locks 
$EQU	IRB$V_PPF_ECHO	57              ;  echo SYS$INPUT records to SYS$OUTPUT 
$EQU	IRB$V_RMS_STALL	58              ;  RMS is stalled on this record operation 
$EQU	IRB$V_RESTART	59              ;  Reconnect operation in progress 
$EQU	IRB$V_DAP_CONN	60              ;  connect function was performed via dap 
$EQU	IRB$V_RU_DELETE	61              ;  recovery unit deletion in progress 
$EQU	IRB$V_RU_UNDEL	62              ;  recovery unit un-deletion in progress 
$EQU	IRB$V_RU_UPDATE	63              ;  place new record is special RU UPDATE format 
; 
;   the following are alternate definitions for alternate
;   (non-conflicting) use of the above bits
; 
$EQU	IRB$V_WRITE	41              ;  operation is a write 
$EQU	IRB$L_IFAB_LNK	0               ;  pointer to ifab 
$EQU	IRB$L_BKPBITS	4               ;  bookkeeping status bits 
; 
$EQU	IRB$B_BID	8               ;  block id 
$EQU	IRB$B_BLN	9               ;  block length in longwords 
$EQU	IRB$B_MODE	10              ;  caller's mode 
$EQU	IRB$B_EFN	11              ;  event flag for synchronous io 
$EQU	IRB$L_IOS	12              ;  internal i/o status block 
$EQU	IRB$L_BWB	12              ;  bucket wait block for inter stream locking 
$EQU	IRB$W_IOS2	14              ;  high word of io status block 
$EQU	IRB$L_IOS4	16              ;  io status block (2nd longword) 
$EQU	IRB$L_ASBADDR	20              ;  address of permanent asynchronous context block 
$EQU	IRB$L_ARGLST	24              ;  user arg list address 
;  if async, points to copy at head
;  of async context block
$EQU	IRB$L_IRAB_LNK	28              ;  pointer to next irab 
$EQU	IRB$L_CURBDB	32              ;  current bdb address 
$EQU	IRB$L_LAST_RAB	36              ;  address of rab for last operation 
$EQU	IRB$W_ISI	40              ;  Internal stream Identifier, the one we gave to the user 
$EQU	IRB$L_ATJNLBUF	44              ;  address of IRAB audit trail journaling buffer 
$EQU	IRB$L_JNLBDB	48              ;  address of journaling BDB for RAB operations 
; -----*****
$EQU	IRB$L_IDENT	52              ;  process unique identifier for the IRB 
$EQU	IRB$L_RLB_LNK	56              ;  pointer to RLBs 
$EQU	IRB$L_NXTBDB	60              ;  next bdb address 
$EQU	IRB$L_NRP	64              ;  next record pointer (relative record number) 
$EQU	IRB$L_NRP_VBN	64              ;  next record pointer (relative) 
$EQU	IRB$B_CACHEFLGS	64              ;  cacheflags for calls to getbkt,cache, etc. (indexed) 
$EQU	IRB$B_STOPLEVEL	65              ;  level to stop at on tree search (indexed) 
$EQU	IRB$W_SRCHFLAGS	66              ;  search flags (indexed) 
$EQU	IRB$V_POSINSERT	0               ;  position for insert 
$EQU	IRB$V_SRCHGT	1               ;  approximate search gt 
$EQU	IRB$V_POSDELETE	2               ;  position for delete 
$EQU	IRB$V_NEW_IDX	3               ;  need to read in new idx dsc from file 
$EQU	IRB$V_SRCHGE	4               ;  approximate search ge 
$EQU	IRB$V_NORLS_RNF	5               ;  don't release bkt on rnf error, if set 
$EQU	IRB$V_FIRST_TIM	6               ;  flag to indicate 1st time for seq. processing 
$EQU	IRB$V_PRM	7               ;  flag to indicate that the permanence bit in the bdb 
$EQU	IRB$V_DUP_KEY	8               ;  a duplicate key seen on scan of any data bucket 
$EQU	IRB$V_DEL_SEEN	9               ;  a deleted record has been encountered between current 
$EQU	IRB$V_LAST_GT	10              ;  result of last search of compressed key bucket was GT 
;  and a next record during a $GET/$FIND
;   should be set
$EQU	IRB$L_NRP_OFF	68              ;  next record pointer offset (relative) 
$EQU	IRB$L_CURVBN	68              ;  vbn of current record (relative) 
$EQU	IRB$W_NRP_OFF	68              ;  " 
$EQU	IRB$B_SPL_BITS	68              ;  bits for splitting (indexed) 
$EQU	IRB$V_BKT_NO_LO	0               ;  low bit of bucket number processing 
$EQU	IRB$S_NEW_BKTS	2
$EQU	IRB$V_NEW_BKTS	1               ;  number of new buckets (0-3) 
$EQU	IRB$V_REC_W_LO	3               ;  if splitting at pos_insert than rec goes w/ lo 
$EQU	IRB$V_CONT_BKT	4               ;  middle bucket is a continuation bkt 
$EQU	IRB$V_CONT_R	5               ;  right bucket is a continuation bkt 
$EQU	IRB$V_EMPTY_BKT	6               ;  bucket contains no data records 
$EQU	IRB$V_DUPS_SEEN	7               ;  dups seen on scan of bucket, any key 
$EQU	IRB$S_BKT_NO	2
$EQU	IRB$V_BKT_NO	0
$EQU	IRB$V_BIG_SPLIT	2
$EQU	IRB$V_SPL_IDX	0               ;  split up new index record and swing pointer 
$EQU	IRB$V_EMPT_SEEN	1               ;  empty bucket passed over on posinsert 
$EQU	IRB$L_RP	72              ;  record pointer (relative record !) 
$EQU	IRB$L_RP_VBN	72              ;  record pointer (relative) 
$EQU	IRB$W_POS_INS	72              ;  offset for position for insert for put (indexed) 
$EQU	IRB$W_SPLIT	74              ;  first split point (indexed) 
$EQU	IRB$L_RP_OFF	76              ;  record pointer offset 
$EQU	IRB$L_LST_REC	76              ;  last record address (indexed) 
$EQU	IRB$L_PTR_VBN	76              ;  pointer vbn used by find_by_rrv (indexed) 
$EQU	IRB$W_RP_OFF	76              ;  record pointer offset 
$EQU	IRB$W_SPLIT_1	76              ;  second split point -- 3-bkt split (indexed) 
$EQU	IRB$W_SPLIT_2	78              ;  third split point -- 4-bkt split (indexed) 
$EQU	IRB$L_OWNER_ID	80              ;  owner id used for record locks 
$EQU	IRB$W_OWN_ID	80              ;  index part of process id (pid) 
$EQU	IRB$W_OWN_ISI	82              ;  isi value for this irab 
$EQU	IRB$B_PPF_ISI	82              ;  isi value for this process-permanent irab 
$EQU	IRB$B_BCNT	84              ;  i/o buffer count 
$EQU	IRB$B_MBC	85              ;  multi-block count 
$EQU	IRB$W_RSZ	86              ;  record size from user 
$EQU	IRB$L_RBF	88              ;  user record buffer address 
$EQU	IRB$B_MBF	92              ;  Multi-buffer count from user's RAB 
$EQU	IRB$B_JNLFLG3	93              ;  IRB journaling flags 
$EQU	IRB$V_VALID_AT	0               ;  IRB MJB contains valid AT entry to write 
; ++
; 
;   start of organization dependent fields
; 
; ++
; 
;  used by sequential and relative files
; 
$EQU	IRB$W_CSIZ	98              ;  current record size (seq) 
; ++
; 
;   relative org specific fields
; 
$EQU	IRB$L_TEMP0	100
$EQU	IRB$W_ROVHDSZ	100             ;  overhead size for record 
$EQU	IRB$B_PRE_CCTL	100             ;  'pre' carriage control 
$EQU	IRB$B_POST_CCTL	101             ;  'post' carriage control 
$EQU	IRB$W_RTOTLSZ	102             ;  total size for record 
$EQU	IRB$L_TEMP1	104
$EQU	IRB$B_NVBNS	104             ;  number of vbns transferred (nxtblk1) 
; 
;  indexed org specific fields
; 
$EQU	IRB$K_BLN_IDX	196
$EQU	IRB$C_BLN_IDX	196
$EQU	IRB$L_KEYBUF	96              ;  address of internal key buffer & update buffer 
$EQU	IRB$L_UPDBUF	100             ;  address of internal update buffer 
$EQU	IRB$L_RECBUF	104             ;  address of internal record buffer 
$EQU	IRB$L_OLDBUF	108             ;  address of internal old record buffer (updates only) 
$EQU	IRB$L_RFA_VBN	112             ;  save record vbn for nrp data 
$EQU	IRB$L_UPD_BDB	112             ;  save current bdb during insert operation 
$EQU	IRB$L_LAST_VBN	112             ;  last vbn at data level for update 
$EQU	IRB$W_RFA_ID	116             ;  save record id for search data 
$EQU	IRB$W_LAST_ID	116             ;  id for udr during update (plg 3) 
$EQU	IRB$W_SAVE_POS	118             ;  save duplicate position for nrp data 
$EQU	IRB$L_NEXT_VBN	120             ;  save next user data record VBN for nrp data 
$EQU	IRB$L_PUTUP_VBN	120             ;  RFA VBN of $PUT/$UPDATE record 
$EQU	IRB$L_FIRST_VBN	124             ;  save SIDR first element VBN for search NRP data 
$EQU	IRB$W_NEXT_ID	128             ;  save next user data record ID for nrp data 
$EQU	IRB$W_PUTUP_ID	128             ;  ID of $PUT/$UPDATE record 
$EQU	IRB$W_FIRST_ID	130             ;  save SIDR first element ID for search NRP data 
$EQU	IRB$L_LOCK_BDB	132             ;  lock bdb addr of level below on splits 
$EQU	IRB$L_VBN_LEFT	136             ;  left vbn of split 
$EQU	IRB$L_MIDX_TMP1	136             ;  temporary one for make index 
$EQU	IRB$L_VBN_RIGHT	140             ;  right vbn of split 
$EQU	IRB$L_MIDX_TMP2	140             ;  temporary two for make index 
$EQU	IRB$L_VBN_MID	144             ;  middle vbn of split 
$EQU	IRB$L_MIDX_TMP3	144             ;  temporary three for make index 
$EQU	IRB$L_NEXT_DOWN	144             ;  used by search_tree 
$EQU	IRB$L_REC_COUNT	148             ;  number of current record in this bucket (plg 3) 
$EQU	IRB$L_LST_NCMP	152             ;  address of last key with zero front compression (plg 3) 
$EQU	IRB$L_SPL_COUNT	156             ;  number of the first record to be moved into new bucket 
;   when splitting indexes and SIDRs
$EQU	IRB$W_NID_RIGHT	160             ;  Next record ID of the right bucket 
$EQU	IRB$W_NID_MID	162             ;  Next record ID of the middle bucket 
$EQU	IRB$W_RFA_NID	164             ;  Next record ID of the RFA bucket 
$EQU	IRB$B_KEYSZ	166             ;  size of key in keybuffer !2 
$EQU	IRB$L_CUR_VBN	168             ;  VBN of current record (primary/SIDR) 
$EQU	IRB$L_POS_VBN	172             ;  VBN of primary data record for NRP positioning 
$EQU	IRB$L_UDR_VBN	176             ;  VBN of current primary data record 
$EQU	IRB$L_SIDR_VBN	180             ;  SIDR array first element VBN of current record (SIDR) 
$EQU	IRB$W_CUR_ID	184             ;  ID of current record (primary) 
$EQU	IRB$W_POS_ID	186             ;  ID of primary data record for NRP positioning 
$EQU	IRB$W_UDR_ID	188             ;  ID of current primary data record 
$EQU	IRB$W_SIDR_ID	190             ;  SIDR array first element ID of current record (SIDR) 
$EQU	IRB$W_CUR_COUNT	192             ;  SIDR array count of current record (SIDR) 
$EQU	IRB$B_RP_KREF	194             ;  Key of reference by which next record is retrieved 
$EQU	IRB$B_CUR_KREF	195             ;  Key of reference of current record (primary/SIDR) 
	$DEFEND	IRB,$GBL,DEF
	.ENDM
 
	.MACRO	$ASBDEF,$GBL
	$DEFINI	ASB,$GBL
; 
;         ASB field definitions
; 
;         Asynchronous context block (asb)
; 
;         There is one asb per irab pointed to by irb$l_asbaddr allocated at
;         connect and one per ifab which is dynamicaly allocated at stall
; 
;         The asb$l_arglst is pointed to by the arglst field of the
;         irab if the irb$v_async bookkeeping bit is set
; 
;         All of the asb$c_bln_xxx must be longword aligned
; 
$EQU	ASB$C_BID	13              ;  asb id = 13 
$EQU	ASB$K_BLN_FIX	48              ;  block length of fixed asb 
$EQU	ASB$C_BLN_FIX	48              ;  block length of fixed asb 
;   regs 4 and 5 are saved on stack
$EQU	ASB$K_BLN_SEQ	188             ;  block length for seq org irab operations 
$EQU	ASB$C_BLN_SEQ	188             ;  block length for seq org irab operations 
$EQU	ASB$K_BLN_REL	192             ;  block length for rel org irab operations 
$EQU	ASB$C_BLN_REL	192             ;  block length for rel org irab operations 
$EQU	ASB$K_BLN_FAB	352             ;  block length for fab-related operations 
$EQU	ASB$C_BLN_FAB	352             ;  block length for fab-related operations 
$EQU	ASB$K_BLN_IDX	512
$EQU	ASB$C_BLN_IDX	512
$EQU	ASB$W_STKLEN	0               ;  save stack length (must be first word in block) 
;   STKLEN = BLN_org - BLN_FIX
$EQU	ASB$W_STKSIZ	2               ;  size of saved stack in bytes 
$EQU	ASB$B_BID	8               ;  block id 
$EQU	ASB$B_BLN	9               ;  block length in longwords 
$EQU	ASB$S_ARGLST	16
$EQU	ASB$L_ARGLST	12              ;  saved argument list on async irab operations 
$EQU	ASB$B_ARGCNT	12              ;  argument count 
;  value will be 0, 1, 2, or 3
$EQU	ASB$L_FABRAB	16              ;  fab or rab address 
$EQU	ASB$L_ERR	20              ;  err routine addr 
$EQU	ASB$L_SUC	24              ;  suc routine addr 
$EQU	ASB$S_REGS	20
$EQU	ASB$L_REGS	28              ;  save register area for regs 6, 7, 8, 10 and 11 
$EQU	ASB$S_STK	140
$EQU	ASB$L_STK	48              ;  saved stack area 
	$DEFEND	ASB,$GBL,DEF
	.ENDM
 
	.MACRO	$BDBDEF,$GBL
	$DEFINI	BDB,$GBL
; 
;          BDB field definitions
; 
;         buffer descriptor block (bdb)
; 
;         there is one bdb per i/o buffer
;         ( the i/o buffers exist in separate pages, page aligned)
; 
$EQU	BDB$C_BID	12              ;  bdb id code 
$EQU	BDB$M_VAL	1
$EQU	BDB$M_DRT	2
$EQU	BDB$M_IOP	4
$EQU	BDB$M_PRM	8
$EQU	BDB$M_NOLOCATE	16
$EQU	BDB$M_WFO	32
$EQU	BDB$M_AST_DCL	64
$EQU	BDB$L_FLINK	0               ;  forward link 
$EQU	BDB$L_BLINK	4               ;  backward link 
$EQU	BDB$B_BID	8               ;  block id 
$EQU	BDB$B_BLN	9               ;  block length in longwords 
$EQU	BDB$B_FLGS	10              ;  bdb flags 
$EQU	BDB$V_VAL	0               ;  buffer contents valid 
$EQU	BDB$V_DRT	1               ;  buffer content dirty 
$EQU	BDB$V_IOP	2               ;  buffer has i/o in progress 
$EQU	BDB$V_PRM	3               ;  buffer has permanence factor 
$EQU	BDB$V_NOLOCATE	4               ;  buffer shared - no locate mode 
$EQU	BDB$V_WFO	5               ;  other streams awaiting 
$EQU	BDB$V_AST_DCL	6               ;  ast has been declared for 
;  waiting stream
;  the releasing of this bdb
;  (set/cleared by rm$cache)
$EQU	BDB$B_CACHE_VAL	11              ;  relative value of buffer in cache 
$EQU	BDB$B_VERTYP	11              ;  version type (1 = wild) 
$EQU	BDB$W_USERS	12              ;  number of streams referencing this buffer 
$EQU	BDB$W_BUFF_ID	14              ;  buffer identification number 
$EQU	BDB$L_BLB_PTR	16              ;  pointer to BLB chain for this BDB 
$EQU	BDB$W_NUMB	20              ;  ! of bytes of buffer in use 
$EQU	BDB$W_DIRSEQ	20              ;  UCB$W_DIRSEQ at directory read time 
$EQU	BDB$W_SIZE	22              ;  ! bytes in buffer 
$EQU	BDB$L_ADDR	24              ;  address of buffer 
$EQU	BDB$L_VBN	28              ;  1st vbn in buffer 
$EQU	BDB$L_VBNSEQNO	32              ;  vbn seq number of validity check vs. bcb copy 
$EQU	BDB$L_LAST	32              ;  address of last directory record 
$EQU	BDB$L_WAIT	36              ;  wait thread (irab addr) 
;  (for inter-stream intra-
;   process locking only)
$EQU	BDB$L_VERCOUNT	36              ;  negative count of version entries scanned 
$EQU	BDB$L_ALLOC_ADDR	40      ;  buffer allocation addr 
$EQU	BDB$W_ALLOC_SIZE	44      ;  buffer allocation size 
$EQU	BDB$L_BI_BDB	48              ;  address of isam/block i/o bi journaling BDB 
$EQU	BDB$L_AI_BDB	52              ;  address of isam/block i/o ai journaling BDB 
$EQU	BDB$S_JNLSEQ	16
$EQU	BDB$T_JNLSEQ	56              ;  Journaling Sequence Number Block 
$EQU	BDB$L_WK1	72              ;  work area 
$EQU	BDB$B_REL_VBN	72              ;  current vbn rel to start of buffer 
$EQU	BDB$B_VAL_VBNS	73              ;  ! of valid vbns in buffer 
$EQU	BDB$B_PRE_CCTL	74              ;  unit record carriage control byte ('pre') 
$EQU	BDB$B_POST_CCTL	75              ;  unit record carriage control byte ('post') 
$EQU	BDB$L_CURBUFADR	76              ;  current buffer addr 
$EQU	BDB$K_BLN	80              ;  length of bdb block 
$EQU	BDB$C_BLN	80              ;  length of bdb block 
$EQU	BDB$S_IOSB	8
$EQU	BDB$L_IOSB	72              ;  i/o status block for buffer 
$EQU	BDB$L_VERSION	72              ;  addr of current/next directory version entry 
$EQU	BDB$L_RECORD	76              ;  address of current/next directory record 
	$DEFEND	BDB,$GBL,DEF
	.ENDM
 
	.MACRO	$GBPBDEF,$GBL
	$DEFINI	GBPB,$GBL
; 
;         GBPB field definitions
; 
;         Global Buffer Pointer Block (GBPB)
; 
;         The GBPB is the process local structure used in conjunction with
;         shared global i/o buffers.  In order to minimize the impact of
;         global buffers on existing code, the GBPB is identical to a BDB
;         in those fields which are referenced outside of the RM$CACHE and
;         RM$RELEASE routines.
; 
$EQU	GBPB$C_BID	21              ;  gbpb id code 
$EQU	GBPB$K_BLN	40              ;  Length of GBPB block 
$EQU	GBPB$C_BLN	40              ;  Length of GBPB block 
$EQU	GBPB$L_FLINK	0               ;  forward link 
$EQU	GBPB$L_BLINK	4               ;  backward link 
$EQU	GBPB$B_BID	8               ;  block id 
$EQU	GBPB$B_BLN	9               ;  block length in longwords 
$EQU	GBPB$B_FLGS	10              ;  gbpb flags (use BDB flgs definitions) 
$EQU	GBPB$B_CACHE_VL	11              ;  relative cache value of this buffer 
$EQU	GBPB$W_USERS	12              ;  number of streams referencing this buffer 
$EQU	GBPB$W_BUFF_ID	14              ;  buffer identification number 
$EQU	GBPB$L_BLB_PTR	16              ;  pointer to BLB chain for this GBPB 
$EQU	GBPB$W_NUMB	20              ;  ! of bytes of buffer in use 
$EQU	GBPB$W_SIZE	22              ;  ! bytes in buffer 
$EQU	GBPB$L_ADDR	24              ;  address of buffer 
$EQU	GBPB$L_VBN	28              ;  1st vbn in buffer 
$EQU	GBPB$L_VBNSEQNO	32              ;  sequence number field. 
$EQU	GBPB$L_GBD_PTR	36              ;  Pointer to the GBD for this buffer. 
	$DEFEND	GBPB,$GBL,DEF
	.ENDM
 
	.MACRO	$RLBDEF,$GBL
	$DEFINI	RLB,$GBL
; 
;         RLB field definitions
; 
;         record lock block (rlb)
; 
;         The rlb describes one locked record for a particular
;         process-record stream (rab/irab). if the owner field
;         is 0 then the rlb is available for use. otherwise, it
;         describes a locked record. note: when owner is 0 the
;         record rfa fields are zeroed (0).
; 
; 
;                 +---------------------------------------+
;         rlb:     !                link                   |
;                 +------------------+--------------------+
;                 |                   |        rfa4  id         |
;                 +---------+--------+----------+---------+
;                 |  flags  |reserved|   bln    |   bid   |
;                 +---------+--------+----------+---------+
;                 |                rfa0                   |
;                 +---------------------------------------+
;                  |                  owner                         |
;                  +---------------------------------------+
;         lksb:    | Still to be def- |  VMS status code   |
;                 | ined status bits |                    |
;                 +---------------------------------------+
;                 |  Lock Id. (Returned for new locks,    |
;                 |            input for conversions)     |
;                 +---------------------------------------+
; 
$EQU	RLB$M_TIMER_INPROG	1
$EQU	RLB$C_BID	14              ;  rlb code 
$EQU	RLB$M_WAIT	1
$EQU	RLB$M_CR	2
$EQU	RLB$M_PW	4
$EQU	RLB$M_PR	8
$EQU	RLB$M_CONV	16
$EQU	RLB$M_LV2	32
$EQU	RLB$M_FAKE	64
$EQU	RLB$M_TMO	128
$EQU	RLB$K_BLN	28              ;  length of rlb 
$EQU	RLB$C_BLN	28              ;  length of rlb 
$EQU	RLB$L_LNK	0               ;  link to next rlb 
$EQU	RLB$L_MISC	4               ;  longword definition to optimize clearing field 
$EQU	RLB$W_FLAGS2	4               ;  more flag bits 
$EQU	RLB$V_TIMER_INPROG	0       ;  Timer queued. 
$EQU	RLB$W_RFA4	6               ;  3'rd word of records rfa 
;  offset for seq f.o. (bits 0:14)
;  always 0 for rel f.o. (bits 0:14)
$EQU	RLB$W_ID	6               ;  id for idx f.o. 
$EQU	RLB$B_BID	8               ;  block id 
$EQU	RLB$B_BLN	9               ;  block length in longwords 
$EQU	RLB$B_TMO	10              ;  propagation of ROP TMO field 
$EQU	RLB$B_FLAGS	11              ;  various locking flags 
$EQU	RLB$V_WAIT	0               ;  propagation of ROP WAT bit 
$EQU	RLB$V_CR	1               ;  defines lock manager mode "concurrent read" 
$EQU	RLB$V_PW	2               ;  allow reader access to locked record flag 
$EQU	RLB$V_PR	3               ;  used to query lock database 
$EQU	RLB$V_CONV	4               ;  defines lock manager option "convert" 
$EQU	RLB$V_LV2	5               ;  sets lock as "level 2" RU consistancy 
$EQU	RLB$V_FAKE	6               ;  this RLB contains no lock. 
$EQU	RLB$V_TMO	7               ;  propagation of ROP TMO bit 
;  indicate "lock for write, allow readers"
;  used to query lock database for records
$EQU	RLB$L_RFA0	12              ;  1'st and 2'nd words of record's rfa 
;  seq f.o. vbn
;  rel f.o. relative record number
;  idx f.o. start vbn
$EQU	RLB$L_OWNER	16              ;  identification of owning stream 
$EQU	RLB$L_LKSB	20              ;  first longword of lock status block 
$EQU	RLB$W_STATUS	20              ;  VMS status code 
$EQU	RLB$W_S_BITS	22              ;  various status bits 
$EQU	RLB$L_LOCK_ID	24              ;  second longword of lksb is lock_id 
	$DEFEND	RLB,$GBL,DEF
	.ENDM
 
	.MACRO	$FLBDEF,$GBL
	$DEFINI	FLB,$GBL
; 
;   file lock block definitions
; 
$EQU	FLB$C_BID	23
$EQU	FLB$K_BLN	20
$EQU	FLB$C_BLN	20
$EQU	FLB$L_FLB_LNK	0               ;  pointer to next FLB 
$EQU	FLB$L_RLB_LNK	4               ;  pointer to RLBs 
$EQU	FLB$B_BID	8               ;  block id 
$EQU	FLB$B_BLN	9               ;  block length 
$EQU	FLB$L_IFB_PTR	12              ;  IFAB address 
$EQU	FLB$L_LOCK_ID	16              ;  lock id 
	$DEFEND	FLB,$GBL,DEF
	.ENDM
 
	.MACRO	$DRCDEF,$GBL
	$DEFINI	DRC,$GBL
; 
;   directory cache node definitions
; 
$EQU	DRC$K_BLN	62              ;  length of directory cache node 
$EQU	DRC$C_BLN	62              ;  length of directory cache node 
$EQU	DRC$L_NXTFLNK	0               ;  link to next entry, this level 
$EQU	DRC$L_NXTBLNK	4               ;  link to previous entry, this level 
$EQU	DRC$L_LVLFLNK	8               ;  link to first entry, next lower level 
$EQU	DRC$L_LVLBLNK	12              ;  link to last entry, next lower level 
;  note: the links are maintained in lru order
$EQU	DRC$S_NAME	40
$EQU	DRC$T_NAME	16              ;  directory name or device and unit 
;  note: stored as counted string counting count itself
$EQU	DRC$S_DID	6
$EQU	DRC$W_DID	56              ;  file id for directory 
$EQU	DRC$W_DIRSEQ	58              ;  directory sequence ! for device node 
	$DEFEND	DRC,$GBL,DEF
	.ENDM
 
	.MACRO	$RLSDEF,$GBL
	$DEFINI	RLS,$GBL
; 
;                 release option flag definitions
; 
$EQU	RLS$M_RETURN	1
$EQU	RLS$M_WRT_THRU	2
$EQU	RLS$M_KEEP_LOCK	4
$EQU	RLS$M_DEQ	8
$EQU	RLS$V_RETURN	0               ;  return buffer and bdb to free space lists 
$EQU	RLS$V_WRT_THRU	1               ;  write buffer if dirty 
$EQU	RLS$V_KEEP_LOCK	2               ;  keep bdb locked 
$EQU	RLS$V_DEQ	3               ;  always release lock 
	$DEFEND	RLS,$GBL,DEF
	.ENDM
 
	.MACRO	$CSHDEF,$GBL
	$DEFINI	CSH,$GBL
; 
;                 cache option flag definitions
; 
$EQU	CSH$M_LOCK	1
$EQU	CSH$M_NOWAIT	2
$EQU	CSH$M_NOREAD	4
$EQU	CSH$M_NOBUFFER	8
$EQU	CSH$V_LOCK	0               ;  obtain exclusive access to block 
$EQU	CSH$V_NOWAIT	1               ;  do not wait for block on access interlock 
$EQU	CSH$V_NOREAD	2               ;  do not read in block 
$EQU	CSH$V_NOBUFFER	3               ;  obtain access to block but don't allocate 
;  a buffer for it and don't read it
;  collision
	$DEFEND	CSH,$GBL,DEF
	.ENDM
 
	.MACRO	$PIODEF,$GBL
	$DEFINI	PIO,$GBL
; 
; 
;   rms overall status bit definitions
; 
$EQU	PIO$V_INHAST	0               ;  set if asts implicitly inhibited 
;  if reset by disabled ast, ast must be re-
;  enabled
$EQU	PIO$V_EOD	1               ;  set if searching for 'eod' string on 'input' 
$EQU	PIO$V_SYNC1	2               ;  sync stalled operation using efn 27 
$EQU	PIO$V_SYNC2	3               ;  sync stalled operation using efn 28 
	$DEFEND	PIO,$GBL,DEF
	.ENDM
 
	.MACRO	$FTLDEF,$GBL
	$DEFINI	FTL,$GBL
; 
;         definitions for rms debug failure codes
; 
; 
;   the following codes are for temporary bug check tests, and are
;   internal to rms.  all of the codes are negative, implying that they
;   do not return to the caller, probably killing the process (if not
;   the entire system).
; 
$EQU	FTL$_SETPRTFAIL	-1              ;  set protection system service failed (rm0bufmgr) 
$EQU	FTL$_STKTOOBIG	-2              ;  stack too big for asb (rm0stall) 
$EQU	FTL$_BADIFAB	-3              ;  invalid ifab or irab (rm0fset,rm0conn,rm0rset,rm0prflnm) 
$EQU	FTL$_GTCHNFAIL	-4              ;  get channel system service failure (rm0prflnm) 
$EQU	FTL$_BADORGCASE	-5              ;  invalid orgcase value for dispatch (all rms$ 
;  level routines execept open and create)
$EQU	FTL$_BADBDB	-6              ;  block not a bdb (rm0bufmgr) 
$EQU	FTL$_ASBALLFAIL	-7              ;  couldn't allocate an asb (rm0stall) 
$EQU	FTL$_BADASTPRM	-8              ;  ast parameter not a valid ifab/irab addr (rm0stall) 
$EQU	FTL$_CANTDOAST	-9              ;  couldn't redeclare ast (insf. mem.) (rm0stall) 
$EQU	FTL$_NOSTRUCT	-10             ;  rab or fab not same on ast (rm0stall) 
$EQU	FTL$_NOASB	-11             ;  asb not allocated or stream not busy on ast (rm0stall) 
$EQU	FTL$_NONXTBDB	-12             ;  no next bdb available (rm1seqxfr) 
$EQU	FTL$_BADBUFSIZ	-13             ;  disk buffer size not = 512 (rm1conn) 
$EQU	FTL$_ENQDEQFAIL	-14             ;  enq or deq service failed (rm0reclck) 
$EQU	FTL$_NOCURBDB	-15             ;  no current bdb before calling rm$release (rm0reclck) 
$EQU	FTL$_NOPARENT	-16             ;  no parent lock available for global buffer section lock (rm0share) 
$EQU	FTL$_DEALLERR	-17             ;  ifab deallocation attempted with other block(s) 
;  still allocated (rms0close)
$EQU	FTL$_IORNDN	-18             ;  i/o rundown inconsistency (either ifab or irab 
;  table entries not zeroed) (rms0rndwn)
$EQU	FTL$_XFERSIZE	-19             ;  size of requested transfer not equal to 
;  or less than the current number of bytes
;  in use for the bdb (rm0cache)
$EQU	FTL$_NOTLOCKED	-20             ;  bdb not locked and a keep lock request 
;  was made on a release request.
$EQU	FTL$_NODIDORFID	-21             ;  neither a fid nor a did was set upon exit from 
;  rm$setdid (rms0erase)
$EQU	FTL$_RELEASFAIL	-22             ;  release of non-dirty bdb failed (rm0xtnd23,rms0extend) 
$EQU	FTL$_NOLOCKBDB	-23             ;  no lock bdb found (rm0xtnd23) 
$EQU	FTL$_NONETWORK	-24             ;  network routine entered but no network support in rms 
$EQU	FTL$_LOCKFAILED	-25             ;  failed to lock prolog (rm2create) 
$EQU	FTL$_BADLEVEL	-26             ;  to search by id, structure level must be 0 
$EQU	FTL$_ASTDECERR	-27             ;  ast declaration for file sharing failed 
$EQU	FTL$_BADGBLCNT	-28             ;  Zero global buffer count found when not expected (rm1conn) 
$EQU	FTL$_ACCNTOVFLO	-29             ;  access count overflow (rm0share) 
$EQU	FTL$_BDBAVAIL	-30             ;  BDB was available and shouldn't have been. 
$EQU	FTL$_GBLNOLK	-31             ;  Record locking was not set with global buffers. 
$EQU	FTL$_LCKFND	-32             ;  A lock was found and we don't know what to do. 
$EQU	FTL$_NOBLB	-33             ;  No BLB was found and there should have been one. 
$EQU	FTL$_NOGBPB	-34             ;  No GBPB was found and should have been. 
$EQU	FTL$_NOLCLBUF	-35             ;  Should have found a local buffer. 
$EQU	FTL$_NORDNOTSET	-36             ;  NOREAD not set when NOBUFFER was. 
$EQU	FTL$_NOTGBPB	-37             ;  Found an illegit BDB. 
$EQU	FTL$_NOSFSB	-38             ;  No SFSB when allocating BLB. 
$EQU	FTL$_LOCKHELD	-39             ;  Attempted to return a BLB with lock_id neq 0 
$EQU	FTL$_RLSDRT	-40             ;  Dirty buffer found in releasall. 
$EQU	FTL$_BADBLB	-41             ;  Bad BLB found in blocking AST routine. 
$EQU	FTL$_BADOWNER	-42             ;  Owner field in BLB is bad in blocking AST routine. 
$EQU	FTL$_GETLKIFAIL	-43             ;  $GETLKIW failed in last chance (rms0lstch).
$EQU	FTL$_BADEBKHBK	-44             ;  tried to store an invalid EBK/HBK (rm0share).
	$DEFEND	FTL,$GBL,DEF
	.ENDM
 
	.MACRO	$BUGDEF,$GBL
	$DEFINI	BUG,$GBL
; 
;   the following internal codes are for non-fatal bug check reporting.
;   these codes are positive byte values.  they trigger a reporting action
;   and return to the caller with r0 set to rms$_bug+<8*the bug code>,
;   which is an externally documented rms error code.
; 
$EQU	BUG$_BADDFLTDIR	1               ; DEFAULT DIRECTORY STRING INVALID (RM0XPFN) 
	$DEFEND	BUG,$GBL,DEF
	.ENDM
 
	.MACRO	$IDXDEF,$GBL
	$DEFINI	IDX,$GBL
; 
;         IDX field definitions
; 
;         index descriptor definition
; 
;         An index descriptor block exists for each key of reference in use.
;         they are not necessarily contiguous in memory.
; 
$EQU	IDX$C_BID	15              ;  id for index descriptor block 
$EQU	IDX$M_DUPKEYS	1
$EQU	IDX$M_CHGKEYS	2
$EQU	IDX$M_NULKEYS	4
$EQU	IDX$M_IDX_COMPR	8
$EQU	IDX$M_INITIDX	16
$EQU	IDX$M_KEY_COMPR	64
$EQU	IDX$M_REC_COMPR	128
$EQU	IDX$C_STRING	0               ;  string data type 
$EQU	IDX$C_SGNWORD	1               ;  signed binary word 
$EQU	IDX$C_UNSGNWORD	2               ;  unsigned binary word 
$EQU	IDX$C_SGNLONG	3               ;  signed binary long word 
$EQU	IDX$C_UNSGNLONG	4               ;  unsigned binary long word 
$EQU	IDX$C_PACKED	5               ;  packed decimal 
$EQU	IDX$C_SGNQUAD	6               ;  signed binary quadword 
$EQU	IDX$C_UNSGNQUAD	7               ;  unsigned binary quadword 
$EQU	IDX$C_V2_BKT	0               ;  Prologue two bucket 
$EQU	IDX$C_CMPIDX	1               ;  Prologue 3, index keys are compressed 
$EQU	IDX$C_NCMPIDX	2               ;  Prologue 3, index keys are not compressed 
$EQU	IDX$C_CMPCMP	3               ;  Prologue 3, primary key is compressed, data 
;   is compressed
;  Prologue 3, SIDR key is compressed
$EQU	IDX$C_CMPNCMP	4               ;  Prologue 3, primary key is compressed, 
;   data is not compressed
$EQU	IDX$C_NCMPCMP	5               ;  Prologue 3, primary key is not compressed 
;   data is compressed
$EQU	IDX$C_NCMPNCMP	6               ;  Prologue 3, primary key is not compressed 
;   data is not compressed
;  Prologue 3, SIDR key is compressed
$EQU	IDX$K_FIXED_BLN	44
$EQU	IDX$C_FIXED_BLN	44
; 
;  the following is the length of the fixed part of the index descriptor
; 
; 
;  the following is repeated for each key segment
; 
$EQU	IDX$L_IDXFL	0               ;  forward link to next index descriptor 
$EQU	IDX$B_BID	8               ;  block id 
$EQU	IDX$B_BLN	9               ;  length of block 
$EQU	IDX$L_VBN	10              ;  VBN where the descriptor came from 
$EQU	IDX$W_OFFSET	14              ;  Offset into the block (VBN) of the descriptor 
$EQU	IDX$B_DESC_NO	16              ;  Descriptor number (index into update buffer) 
$EQU	IDX$B_IANUM	18              ;  area number for index buckets 
$EQU	IDX$B_LANUM	19              ;  area number for lower index buckets 
$EQU	IDX$B_DANUM	20              ;  area number for data buckets 
$EQU	IDX$B_ROOTLEV	21              ;  level of root 
$EQU	IDX$B_IDXBKTSZ	22              ;  size of index bucket in vbn's 
$EQU	IDX$B_DATBKTSZ	23              ;  size of data bucket in vbn's 
$EQU	IDX$L_ROOTVBN	24              ;  start vbn of root bucket 
$EQU	IDX$B_FLAGS	28              ;  index/key flags 
$EQU	IDX$V_DUPKEYS	0               ;  duplicate keys allowed 
$EQU	IDX$V_CHGKEYS	1               ;  keys can change values 
$EQU	IDX$V_NULKEYS	2               ;  null key value allowed 
$EQU	IDX$V_IDX_COMPR	3               ;  index is compressed 
$EQU	IDX$V_INITIDX	4               ;  index is not initialized 
$EQU	IDX$V_KEY_COMPR	6               ;  key has been compressed 
$EQU	IDX$V_REC_COMPR	7               ;  data record is in compressed form 
$EQU	IDX$B_DATATYPE	29              ;  data type of key field 
$EQU	IDX$B_SEGMENTS	30              ;  number of key field segments 
$EQU	IDX$B_NULLCHAR	31              ;  null character 
$EQU	IDX$B_KEYSZ	32              ;  total key size 
$EQU	IDX$B_KEYREF	33              ;  key of reference(0-primary) 
$EQU	IDX$W_MINRECSZ	34              ;  minimum record size 
$EQU	IDX$W_IDXFILL	36              ;  index fill 
$EQU	IDX$W_DATFILL	38              ;  data fill 
$EQU	IDX$B_IDXBKTYP	40              ;  PLG3 - type of index bucket and SIDR bucket 
$EQU	IDX$B_DATBKTYP	41              ;  PLG3 - type of primary data bucket 
$EQU	IDX$W_POSITION	44              ;  key segment position 
$EQU	IDX$B_SIZE	46              ;  key segment size (plg 3) 
$EQU	IDX$B_TYPE	47              ;  key segment datatype (plg 3) 
	$DEFEND	IDX,$GBL,DEF
	.ENDM
 
	.MACRO	$UPDDEF,$GBL
	$DEFINI	UPD,$GBL
; 
;  update buffer flags
; 
$EQU	UPD$M_INS_NEW	1
$EQU	UPD$M_OLD_DEL	2
$EQU	UPD$B_FLAGS	0
$EQU	UPD$V_INS_NEW	0               ;  alternate key to be inserted from record buffer 
$EQU	UPD$V_OLD_DEL	1               ;  delete this key value using old record 
	$DEFEND	UPD,$GBL,DEF
	.ENDM
 
	.MACRO	$GBHDEF,$GBL
	$DEFINI	GBH,$GBL
; 
;         GBH field definitions
; 
;         Global Buffer Header (GBH)
; 
;         There is a Global Buffer Header for every file's global buffer section.
; 
;         ***  WARNING - THIS STRUCTURE MUST BE QUADWORD ALIGNED  ***
; 
$EQU	GBH$C_BID	17              ;  Block ID code for GBH 
$EQU	GBH$M_CACHE_IN	1
$EQU	GBH$M_CACHE_OUT	2
$EQU	GBH$M_RLS_IN	4
$EQU	GBH$M_RLS_OUT	8
$EQU	GBH$M_QIO_START	16
$EQU	GBH$M_QIO_DONE	32
$EQU	GBH$M_STALL	64
$EQU	GBH$M_THREADGO	128
$EQU	GBH$M_BLB_ENQ	256
$EQU	GBH$M_BLB_GRANT	512
$EQU	GBH$M_BLB_DEQ	1024
$EQU	GBH$M_BLB_BLOCK	2048
$EQU	GBH$M_F1	4096
$EQU	GBH$M_F2	8192
$EQU	GBH$M_F3	16384
$EQU	GBH$M_F4	32768
$EQU	GBH$K_BLN	88              ;  Length of global buffer header structure 
$EQU	GBH$C_BLN	88              ;  Length of global buffer header structure 
$EQU	GBH$L_GBD_FLNK	0               ;  Self relative queue header for GBD's 
$EQU	GBH$L_GBD_BLNK	4
$EQU	GBH$B_BID	8               ;  Block ID 
$EQU	GBH$B_BLN	9               ;  Length of GBH in longwords 
$EQU	GBH$W_TRC_FLGS	10              ;  Trace flags (set to trace given function) 
$EQU	GBH$V_CACHE_IN	0               ;  Cache inputs 
$EQU	GBH$V_CACHE_OUT	1               ;  Cache outputs 
$EQU	GBH$V_RLS_IN	2               ;  Release inputs 
$EQU	GBH$V_RLS_OUT	3               ;  Release outputs 
$EQU	GBH$V_QIO_START	4               ;  Qio inputs 
$EQU	GBH$V_QIO_DONE	5               ;  Qio outputs 
$EQU	GBH$V_STALL	6               ;  Stall inputs 
$EQU	GBH$V_THREADGO	7               ;  Stall outputs 
$EQU	GBH$V_BLB_ENQ	8               ;  Bucket lock ENQ inputs 
$EQU	GBH$V_BLB_GRANT	9               ;  Bucket lock grant status 
$EQU	GBH$V_BLB_DEQ	10              ;  Bucket lock DEQ request 
$EQU	GBH$V_BLB_BLOCK	11              ;  Blocking AST received 
$EQU	GBH$V_F1	12
$EQU	GBH$V_F2	13
$EQU	GBH$V_F3	14
$EQU	GBH$V_F4	15
$EQU	GBH$L_HI_VBN	12              ;  Highest possible VBN value (FFFFFFFF). 
$EQU	GBH$L_GS_SIZE	16              ;  Size of total section in bytes. 
$EQU	GBH$L_LOCK_ID	20              ;  Lock ID of system file lock. 
$EQU	GBH$L_GS_LOCK_ID	24      ;  Lock ID of system global section lock. 
$EQU	GBH$L_USECNT	28              ;  Accessor count for section.
$EQU	GBH$L_TRC_FLNK	32              ;  Trace blocks forward link 
$EQU	GBH$L_TRC_BLNK	36              ;  Trace blocks back link 
$EQU	GBH$L_GBD_START	40              ;  Offset to first GBD. 
$EQU	GBH$L_GBD_END	44              ;  Offset to last GBD. 
$EQU	GBH$L_GBD_NEXT	48              ;  Offset to next cache victim GBD. 
$EQU	GBH$L_SCAN_NUM	52              ;  Number of GBD's to scan for victim. 
; 
;  Global buffer statistics section
; 
$EQU	GBH$L_HIT	56              ;  Buffer found in global cache 
$EQU	GBH$L_MISS	60              ;  Buffer not found in global cache 
$EQU	GBH$L_READ	64              ;  Buffer read from disk into cache 
$EQU	GBH$L_WRITE	68              ;  Buffer written from cache to disk 
$EQU	GBH$L_DFW_WRITE	72              ;  Deferred writeback from cache to disk 
$EQU	GBH$L_CROSS_HIT	76              ;  Cross process hit count. 
$EQU	GBH$L_OUTBUFQUO	80              ;  Count of times GBLBUFQUO limit was hit.
$EQU	GBH$L_FILL_1	84              ;  Force quadword alignment
	$DEFEND	GBH,$GBL,DEF
	.ENDM
 
	.MACRO	$TRCDEF,$GBL
	$DEFINI	TRC,$GBL
; 
;         TRC field definitions
; 
;         Trace block structure (TRC)
; 
;         Tracing saves at specific points in the RMS code for debugging and
;         algorithm analysis purposes.
; 
;         ***  WARNING - THIS STRUCTURE MUST BE QUADWORD ALIGNED  ***
; 
$EQU	TRC$C_BID	18              ;  Trace block code 
$EQU	TRC$K_BLN	64              ;  NOTE: should be quadwords multiple to 
$EQU	TRC$C_BLN	64              ;  NOTE: should be quadwords multiple to 
$EQU	TRC$L_FLNK	0               ;  Trace block forward link 
$EQU	TRC$L_BLNK	4               ;  Trace block back link 
$EQU	TRC$B_BID	8               ;  Block ID 
$EQU	TRC$B_BLN	9               ;  Length of block in longwords 
$EQU	TRC$W_FUNCTION	10              ;  Function code (see GBH definitions) 
$EQU	TRC$L_STRUCTURE	12              ;  Ifab/irab address. 
$EQU	TRC$W_PID	16              ;  Process ID 
$EQU	TRC$W_SEQNUM	18              ;  Sequence number. 
$EQU	TRC$L_VBN	20              ;  VBN requested. 
$EQU	TRC$L_RETURN1	24              ;  Address of caller. 
$EQU	TRC$L_RETURN2	28              ;  Caller's caller. 
$EQU	TRC$S_ARGS	32
$EQU	TRC$L_ARGS	32              ;  Function specific arguments 
$EQU	TRC$L_ARG_FLG	32              ;  Argument flags (R3). 
$EQU	TRC$L_BDB_ADDR	36              ;  BDB address. 
$EQU	TRC$W_BDB_USERS	40              ;  Use count from BDB. 
$EQU	TRC$W_BDB_BUFF	42              ;  BDB buffer ID. 
$EQU	TRC$B_BDB_CACHE	44              ;  BDB cache value. 
$EQU	TRC$B_BDB_FLAGS	45              ;  Status flags from BDB. 
$EQU	TRC$L_BDB_SEQ	46              ;  Sequence number from BDB. 
$EQU	TRC$B_BLB_MODE	50              ;  Mode held in BLB. 
$EQU	TRC$B_BLB_FLAGS	51              ;  Flags from BLB. 
$EQU	TRC$L_BLB_ADDR	52              ;  Address of BLB. 
$EQU	TRC$L_BLB_LOCK	56              ;  Lock ID from BLB. 
$EQU	TRC$L_BLB_SEQ	60              ;  Sequence number from BLB. 
;  maintain quad alignment on header
	$DEFEND	TRC,$GBL,DEF
	.ENDM
 
	.MACRO	$GBDDEF,$GBL
	$DEFINI	GBD,$GBL
; 
;         GBD structure definitions
; 
;         Global Buffer Descriptor (GBD)
; 
;         There is a single GBD for every buffer in a global buffer
;         section (used only with shared files).  The GBD's themselves
;         are in the section also and linked from a queue header in
;         the Global Buffer Header (GBH).
; 
;         ***  WARNING - THIS STRUCTURE MUST BE QUADWORD ALIGNED  ***
; 
$EQU	GBD$C_BID	19              ;  Block ID code for GBD 
$EQU	GBD$M_VALID	1
$EQU	GBD$K_BLN	40              ;  Length of Global Buffer Descriptor structure. 
$EQU	GBD$C_BLN	40              ;  Length of Global Buffer Descriptor structure. 
$EQU	GBD$L_FLINK	0               ;  Forward link - Note: This is a self relative queue 
$EQU	GBD$L_BLINK	4               ;  Back link 
$EQU	GBD$B_BID	8               ;  Block ID 
$EQU	GBD$B_BLN	9               ;  Block length of GBD 
$EQU	GBD$B_FLAGS	10              ;  Buffer status flags 
$EQU	GBD$V_VALID	0               ;  Buffer is valid. 
$EQU	GBD$B_CACHE_VAL	11              ;  Cache value of this bucket 
$EQU	GBD$L_VBN	12              ;  VBN of bucket the buffer describes 
$EQU	GBD$L_VBNSEQNUM	16              ;  VBN sequence number validity check 
$EQU	GBD$L_LOCK_ID	20              ;  Lock ID of system lock. 
$EQU	GBD$W_NUMB	24              ;  Number of bytes in use 
$EQU	GBD$W_SIZE	26              ;  Size of buffer in bytes 
$EQU	GBD$L_REL_ADDR	28              ;  Address of buffer relative to GBH 
$EQU	GBD$W_USECNT	32              ;  Accessor count for bucket 
$EQU	GBD$B_REHIT_RD	34              ;  Rehit by same process count. 
$EQU	GBD$B_REHIT_LK	35              ;  Rehit by same locker process. 
	$DEFEND	GBD,$GBL,DEF
	.ENDM
 
	.MACRO	$BLBDEF,$GBL
	$DEFINI	BLB,$GBL
; 
;         BLB field definitions
; 
;         Bucket Lock Block (BLB)
; 
;         The BLB contains the argument list for the SYS$ENQ system service
;         as well a pointer to the BDB it relates to and other status.
; 
$EQU	BLB$C_BID	16              ;  BLB code 
$EQU	BLB$M_LOCK	1
$EQU	BLB$M_NOWAIT	2
$EQU	BLB$M_NOREAD	4
$EQU	BLB$M_NOBUFFER	8
$EQU	BLB$M_IOLOCK	16
$EQU	BLB$M_DFW	32
$EQU	BLB$M_WRITEBACK	64
$EQU	BLB$K_BLN	56              ;  Length of BLB 
$EQU	BLB$C_BLN	56              ;  Length of BLB 
$EQU	BLB$L_FLNK	0               ;  Link to next BLB 
$EQU	BLB$L_BLNK	4               ;  Back link 
$EQU	BLB$B_BID	8               ;  Block ID 
$EQU	BLB$B_BLN	9               ;  Block length 
$EQU	BLB$B_BLBFLGS	10              ;  Control flags for BLB 
$EQU	BLB$V_LOCK	0               ;  Corresponds to CSH$V_LOCK 
$EQU	BLB$V_NOWAIT	1               ;  Same as CSH$V_NOWAIT 
$EQU	BLB$V_NOREAD	2               ;  Same as CSH$V_NOREAD 
$EQU	BLB$V_NOBUFFER	3               ;  Same as CSH$V_NOBUFFER 
$EQU	BLB$V_IOLOCK	4               ;  Lock mode for read/write 
$EQU	BLB$V_DFW	5               ;  This is lock for deferred write buffer 
$EQU	BLB$V_WRITEBACK	6               ;  The associated buffer must be written back 
$EQU	BLB$B_MODEHELD	11              ;  Mode of current lock held. 
$EQU	BLB$L_BDB_ADDR	12              ;  BDB for which this lock is held 
$EQU	BLB$L_OWNER	16              ;  Address of stream owning this lock 
$EQU	BLB$L_VBN	20              ;  VBN of bucket lock (resource name) 
$EQU	BLB$S_RESDSC	8
$EQU	BLB$L_RESDSC	24              ;  Resource name descriptor 
$EQU	BLB$W_LKSTS	32              ;  Lock status word 
$EQU	BLB$L_LOCK_ID	36              ;  Lock ID 
$EQU	BLB$S_VALBLK	16
$EQU	BLB$L_VALBLK	40              ;  Lock value block 
$EQU	BLB$L_VALSEQNO	40              ;  Sequence number part of value block 
	$DEFEND	BLB,$GBL,DEF
	.ENDM
 
	.MACRO	$RJBDEF,$GBL
	$DEFINI	RJB,$GBL
; 
;         RJB Definitions
; 
;         RMS Journaling Block (RJB)
; 
;         This block contains the necessary control information to keep
;         track of the state of journaling on this file
; 
$EQU	RJB$C_BID	22
$EQU	RJB$K_BLN	12              ; Length of RJB 
$EQU	RJB$C_BLN	12              ; Length of RJB 
$EQU	RJB$M_RU	1
$EQU	RJB$M_BI	2
$EQU	RJB$M_AI	4
$EQU	RJB$M_AT	8
$EQU	RJB$M_OPEN	16
$EQU	RJB$S_CHAN	8
$EQU	RJB$Q_CHAN	0               ; Channel Block 
$EQU	RJB$W_RUCHAN	0               ;  channel for recovery unit journal 
$EQU	RJB$W_BICHAN	2               ;  channel for before image journal 
$EQU	RJB$W_AICHAN	4               ;  channel for after image journal 
$EQU	RJB$W_ATCHAN	6               ;  channel for audit trail journal 
$EQU	RJB$B_BID	8               ; Block Id 
$EQU	RJB$B_BLN	9               ; Block Length 
$EQU	RJB$W_FLAGS	10              ; Flags word 
$EQU	RJB$V_RU	0               ; Set to indicate RU channel open 
$EQU	RJB$V_BI	1               ; Set to indicate BI channel open 
$EQU	RJB$V_AI	2               ; Set to indicate AI channel open 
$EQU	RJB$V_AT	3               ; Set to indicate AT channel open 
$EQU	RJB$V_OPEN	4               ; Indicates $OPEN mapping entry written 
	$DEFEND	RJB,$GBL,DEF
	.ENDM
 
	.MACRO	$MJBDEF,$GBL
	$DEFINI	MJB,$GBL
; 
;         MJB field definitions
; 
;           Miscellaneous Journaling Buffer
; 
;         The MJB is used for writing miscellaneous journal entries,
;         for example, extend entries or audit-trail entries.
; 
$EQU	MJB$C_BID	24
$EQU	MJB$M_INIT	1
$EQU	MJB$M_FORCE	2
$EQU	MJB$M_FILE	4
$EQU	MJB$M_SYNCH_SHARE	8
$EQU	MJB$K_BLN	32
$EQU	MJB$C_BLN	32
$EQU	MJB$B_BID	8               ;  block id 
$EQU	MJB$B_BLN	9               ;  block length in longwords 
$EQU	MJB$W_FLAGS	10              ;  flags 
$EQU	MJB$V_INIT	0               ;  set if RJR overhead is initialized 
$EQU	MJB$V_FORCE	1               ;  set if RJR is to be written thru to journal 
$EQU	MJB$V_FILE	2               ;  set if file operation to journal 
$EQU	MJB$V_SYNCH_SHARE	3       ;  set if file lock can't be released during 
;  STALL
;  and not buffered by CJF (input to WRITE_MJB)
$EQU	MJB$B_JNL	12              ;  set to CJF$_"jnl type" as input to WRITE_MJB 
$EQU	MJB$S_DESC	8
$EQU	MJB$Q_DESC	16              ;  RJR descriptor used in $WRITEJNL service 
$EQU	MJB$W_SIZE	16              ;  size of RJR to write 
$EQU	MJB$L_POINTER	20              ;  pointer to RJR 
$EQU	MJB$S_IOSB	8
$EQU	MJB$Q_IOSB	24              ;  IOSB to use in $WRITEJNL 
$EQU	MJB$T_RJR	32              ;  the journal record begins here 
	$DEFEND	MJB,$GBL,DEF
	.ENDM
