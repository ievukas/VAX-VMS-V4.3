	.TITLE	VAX$DECIMAL - VAX-11 Packed Decimal Instruction Emulator
	.IDENT	/V04-000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: 
;
;	VAX-11 Instruction Emulator
;
; Abstract:
;
;	The routines in this module emulate the VAX-11 packed decimal 
;	instructions. These procedures can be a part of an emulator 
;	package or can be called directly after the input parameters 
;	have been loaded into the architectural registers.
;
;	The input parameters to these routines are the registers that
;	contain the intermediate instruction state. 
;
; Environment: 
;
;	These routines run at any access mode, at any IPL, and are AST 
;	reentrant.
;
; Author: 
;
;	Lawrence J. Kenah	
;
; Creation Date
;
;	24 September 1982
;
; Modified by:
;
;	V01-007	LJK0043		Lawrence J. Kenah	26-Jul-1984
;		Change STRIP_ZEROS routines so that they are more forgiving
;		when confronted with poorly formed packed decimal strings.
;		Specifically, do not allow string lengths smaller than zero.
;
;	V01-006	LJK0038		Lawrence J. Kenah	19-Jul-1984
;		Insure that initial setting of C-bit is preserved when
;		MOVP is restarted after an access violation.
;
;	V01-005	LJK0024		Lawrence J. Kenah	20-Feb-1984
;		Add code to handle access violations. 
;
;	V01-004	LJK0013		Lawrence J. Kenah	17-Nov-1983
;		Move CVTPL to a separate module.
;
;	V01-003	LJK0008		Lawrence J. Kenah	18-Oct-1983
;		Move decimal arithmetic and numeric string routines to
;		separate modules.
;
;	V01-002	LJK0006		Lawrence J. Kenah	14-Oct-1983
;		Fix code that handles arithmetic traps. Add reserved operand
;		processing. Add PROBEs and other code to handle access
;		violations.
;
;	V01-001	Original	Lawrence J. Kenah	24-Sep-82
;
;--

	.SUBTITLE	Miscellaneous Notes

;+
; There are several techniques that are used throughout the routines in this 
; module that are worth a comment somewhere. Rather than duplicate near 
; identical commentary in several places, we will describe these general 
; techniques in a single place.
;
; 1.	The VAX-11 architecture specifies that several kinds of input produce 
;	UNPREDICTABLE results. They are:
;
;	 o  Illegal decimal digit in packed decimal string
;
;	 o  Illegal sign specifier (other than 10 through 15) in low nibble of 
;	    highest addressed byte of packed decimal string
;
;	 o  Packed decimal string with even number of digits that contains 
;	    other than a zero in the high nibble of the lowest addressed byte
;
;	These routines take full advantage of the meaning of UNPREDICTABLE. 
;	In general, the code assumes that all input is correct. The operation 
;	of the code for illegal input is not even consistent but is simply 
;	whatever happens to be convenient in a particular place.
;
; 2.	All of these routines accumulate information about condition codes at
;	several key places in a routine. This information is kept in a
;	register (usually R11) that is used to set the final condition codes
;	in the PSW. In order to allow the register to obtain its correct
;	contents when the routine exits (without further affecting the
;	condition codes), the condition codes are set from the register
;	(BISPSW reg) and the register is then restored with a POPR
;	instruction, which does not affect condition codes. 
;
; 3.	There are several instances in these routines where it is necessary to
;	determine the difference in length between an input and an output
;	string and perform special processing on the excess digits. When the
;	longer string is a packed decimal string (it does not matter if the
;	packed decimal string is an input string or an output string), it is
;	sometimes useful to convert the difference in digits to a byte count. 
;
;	There are four different cases that exist. We will divide these cases
;	into two sets of two cases, depending on whether the shorter length is
;	even or odd. 
;
;	In the pictures that appear below, a blank box indicates a digit in 
;	the shorter string. A string of three dots in a box indicates a digit 
;	in the longer string. A string of three stars indicates an unused 
;	digit in a decimal string. The box that contains +/- obviously 
;	indicates the sign nibble in a packed decimal string.
;
; (cont.)

;                                               +-------+-------+
;                                               |       |       |
;                                               |  ***  |  ...  |
;                                               |       |       |
;          +-------+-------+                    +-------+ - - - +
;          |               |                    |               |
;          |  ...  |  ...  |                    |  ...  |  ...  |
;          |               |                    |               |
;          + - - - +-------+                    + - - - +-------+
;          |       |       |                    |       |       |
;          |  ...  |       |                    |  ...  |       |
;          |       |       |                    |       |       |
;          +-------+ - - - +                    +-------+ - - - +
;          |               |                    |               |
;          |       |       |                    |       |       |
;          |               |                    |               |
;          + - - - + - - - +                    + - - - + - - - +
;          |               |                    |               |
;          |       |  +/-  |                    |       |  +/-  |
;          |               |                    |               |
;          +-------+-------+                    +-------+-------+
;
;        A  Longer string odd                 B  Longer string even
;           Difference odd                       Difference even
;
;
;             CASE 1  Shorter string has even number of digits
;
;
;
;          +-------+-------+                    +-------+-------+
;          |               |                    |       |       |
;          |  ...  |  ...  |                    |  ***  |  ...  |
;          |               |                    |       |       |
;          + - - - + - - - +                    +-------+ - - - +
;          |               |                    |               |
;          |  ...  |  ...  |                    |  ...  |  ...  |
;          |               |                    |               |
;          +-------+-------+                    +-------+-------+
;          |               |                    |               |
;          |       |       |                    |       |       |
;          |               |                    |               |
;          + - - - + - - - +                    + - - - + - - - +
;          |               |                    |               |
;          |       |  +/-  |                    |       |  +/-  |
;          |               |                    |               |
;          +-------+-------+                    +-------+-------+
;
;        A  Longer string odd                 B  Longer string even
;           Difference even                      Difference odd
;
;
;              CASE 2  Shorter string has odd number of digits
;
; (cont.)

;
;	In general, the code must calculate the number of bytes that contain 
;	the excess digits. Most of the time, the interesting number includes 
;	complete excess bytes. The excess digit in the high nibble of the 
;	highest addressed byte (both parts of Case 1) is ignored. 
;
;	In three out of four cases, the difference (called R5 from this point 
;	on) can be simply divided by two to obtain a byte count. In one case 
;	(Case 2 B), this is not correct. (For example, 3/2 = 1 and we want to 
;	get a result of 2.) Note, however, that in both parts of Case 2, we 
;	can add 1 to R5 before we divide by two. In Case 2 B, this causes the 
;	result to be increased by 1, which is what we want. In Case 2 A, 
;	because the original difference is even, an increment of one before we 
;	divide by two has no effect on the final result. 
;
;	The correct code sequence to distinguish case 2 B from the other three
;	cases involves two BLBx instructions. A simpler sequence that
;	accomplishes correct results in all four cases when converting a digit
;	count to a byte count is something like 
;
;			BLBC	length-of-shorter,10$
;			INCL	R5
;		10$:	ASHL	#-1,R5,R5
;
;	where the length of the shorter string will typically be contained in 
;	either R0 or R2.
;
;	Note that we could also look at both B parts, performing the extra 
;	INCL instruction when the longer string is even. In case 1 B, this 
;	increment transforms an even difference to an odd number but does not 
;	affect the division by two. In case 2 B, the extra increment produces 
;	the correct result. This option is not used in these routines.
;
;	The two routines for CVTSP and CVTTP need a slightly different number. 
;	They want the number of bytes including the byte containing the excess 
;	high nibble. For Case 2, the above calculation is still valid. For 
;	Case 1, it is necessary to add one to R5 after the R5 is divided by 
;	two to obtain the correct byte count.
;
; 4.	There is a routine called STRIP_ZEROS that removes high order zeros
;	from decimal strings. This routine is not used by all of the routines
;	in this module but only by those routines that perform complicated
;	calculations on each byte of the input string. For these routines, the
;	overhead of testing for and discarding leading zeros is less than the
;	more costly per byte overhead of these routines. 
;-

	.SUBTITLE	Declarations

; Include files:

	.NOCROSS			; No cross reference for these
	.ENABLE		SUPPRESSION	; No symbol table entries either

	CMPP3_DEF			; Bit fields in CMPP3 registers
	CMPP4_DEF			; Bit fields in CMPP4 registers
	MOVP_DEF			; Bit fields in MOVP registers

	PACK_DEF			; Stack usage by exception handler
	STACK_DEF			; Stack usage of original exception

	$PSLDEF				; Define bit fields in PSL

	.DISABLE	SUPPRESSION	; Turn on symbol table again
	.CROSS				; Cross reference is OK now

; External declarations

	.DISABLE	GLOBAL

	.EXTERNAL -
			VAX$REFLECT_FAULT,-
			VAX$ROPRAND

; PSECT Declarations:

	.DEFAULT	DISPLACEMENT , WORD

	.PSECT _VAX$CODE PIC, USR, CON, REL, LCL, SHR, EXE, RD, NOWRT, LONG

	BEGIN_MARK_POINT

	.SUBTITLE	Conversion Tables

;+
; The following tables are designed to perform fast conversions between
; numbers in the range 0 to 99 and their decimal equivalents. The tables
; are used by placing the input parameter into a register and then using
; the contents of that register as an index into the table.
;-

;+
;	Decimal Digits to Binary Number
;
; The following table is used to convert a packed decimal byte to its binary
; equivalent. 
;
; Packed decimal numbers that contain illegal digits in the low nibble
; convert as if the low nibble contained a zero. That is, the binary number
; will be a multiple of ten. This is done so that this table can be used to
; convert the least significant (highest addressed) byte of a decimal string
; without first masking off the sign "digit". 
;
; Illegal digits in the high nibble produce UNPREDICTABLE results because the
; table does not contain entries to handle these illegal constructs. 
;-

;		Binary Equivalent		  Decimal Digits
;		-----------------		  --------------

DECIMAL$PACKED_TO_BINARY_TABLE::

	.BYTE	00 , 01 , 02 , 03 , 04 , -	; Index  ^X00
		05 , 06 , 07 , 08 , 09		;    to  ^X09

	.BYTE	00 , 00 , 00 , 00 , 00 , 00	; Illegal decimal digits

	.BYTE	10 , 11 , 12 , 13 , 14 , -	; Index  ^X10
		15 , 16 , 17 , 18 , 19		;    to  ^X19

	.BYTE	10 , 10 , 10 , 10 , 10 , 10	; Illegal decimal digits

	.BYTE	20 , 21 , 22 , 23 , 24 , -	; Index  ^X20
		25 , 26 , 27 , 28 , 29		;    to  ^X29

	.BYTE	20 , 20 , 20 , 20 , 20 , 20	; Illegal decimal digits

	.BYTE	30 , 31 , 32 , 33 , 34 , -	; Index  ^X30
		35 , 36 , 37 , 38 , 39		;    to  ^X39

	.BYTE	30 , 30 , 30 , 30 , 30 , 30	; Illegal decimal digits

	.BYTE	40 , 41 , 42 , 43 , 44 , -	; Index  ^X40
		45 , 46 , 47 , 48 , 49		;    to  ^X49

	.BYTE	40 , 40 , 40 , 40 , 40 , 40	; Illegal decimal digits

	.BYTE	50 , 51 , 52 , 53 , 54 , -	; Index  ^X50
		55 , 56 , 57 , 58 , 59		;    to  ^X59

	.BYTE	50 , 50 , 50 , 50 , 50 , 50	; Illegal decimal digits

	.BYTE	60 , 61 , 62 , 63 , 64 , -	; Index  ^X60
		65 , 66 , 67 , 68 , 69		;    to  ^X69

	.BYTE	60 , 60 , 60 , 60 , 60 , 60	; Illegal decimal digits

	.BYTE	70 , 71 , 72 , 73 , 74 , -	; Index  ^X70
		75 , 76 , 77 , 78 , 79		;    to  ^X79

	.BYTE	70 , 70 , 70 , 70 , 70 , 70	; Illegal decimal digits

	.BYTE	80 , 81 , 82 , 83 , 84 , -	; Index  ^X80
		85 , 86 , 87 , 88 , 89		;    to  ^X89

	.BYTE	80 , 80 , 80 , 80 , 80 , 80	; Illegal decimal digits

	.BYTE	90 , 91 , 92 , 93 , 94 , -	; Index  ^X90
		95 , 96 , 97 , 98 , 99		;    to  ^X99

	.BYTE	90 , 90 , 90 , 90 , 90 , 90	; Illegal decimal digits

;+
;		Binary Number to Decimal Equivalent
;
; The following table is used to do a fast conversion from a binary number
; stored in a byte to its decimal representation. The table structure assumes
; that the number lies in the range 0 to 99. Numbers that lie outside this
; range produce UNPREDICTABLE results.
;-

;		Decimal Equivalents			     Binary
;		-------------------			     ------

DECIMAL$BINARY_TO_PACKED_TABLE::

	.BYTE	^X00 , ^X01 , ^X02 , ^X03 , ^X04 , -	;  0 through  9
		^X05 , ^X06 , ^X07 , ^X08 , ^X09 	; 

	.BYTE	^X10 , ^X11 , ^X12 , ^X13 , ^X14 , -	; 10 through 19
		^X15 , ^X16 , ^X17 , ^X18 , ^X19 	; 

	.BYTE	^X20 , ^X21 , ^X22 , ^X23 , ^X24 , -	; 20 through 29
		^X25 , ^X26 , ^X27 , ^X28 , ^X29 	; 

	.BYTE	^X30 , ^X31 , ^X32 , ^X33 , ^X34 , -	; 30 through 39
		^X35 , ^X36 , ^X37 , ^X38 , ^X39 	; 

	.BYTE	^X40 , ^X41 , ^X42 , ^X43 , ^X44 , -	; 40 through 49
		^X45 , ^X46 , ^X47 , ^X48 , ^X49 	; 

	.BYTE	^X50 , ^X51 , ^X52 , ^X53 , ^X54 , -	; 50 through 59
		^X55 , ^X56 , ^X57 , ^X58 , ^X59 	; 

	.BYTE	^X60 , ^X61 , ^X62 , ^X63 , ^X64 , -	; 60 through 69
		^X65 , ^X66 , ^X67 , ^X68 , ^X69 	; 

	.BYTE	^X70 , ^X71 , ^X72 , ^X73 , ^X74 , -	; 70 through 79
		^X75 , ^X76 , ^X77 , ^X78 , ^X79 	; 

	.BYTE	^X80 , ^X81 , ^X82 , ^X83 , ^X84 , -	; 80 through 89
		^X85 , ^X86 , ^X87 , ^X88 , ^X89 	; 

	.BYTE	^X90 , ^X91 , ^X92 , ^X93 , ^X94 , -	; 90 through 99
		^X95 , ^X96 , ^X97 , ^X98 , ^X99 	; 


	.SUBTITLE	VAX$CMPPx - Compare Packed
;+
; Functional Description:
;
;	In 3 operand format, the source 1 string specified  by  the  length  and
;	source  1  address operands is compared to the source 2 string specified
;	by the length and source 2 address operands.   The  only  action  is  to
;	affect the condition codes.
;
;	In 4 operand format, the source 1  string  specified  by  the  source  1
;	length  and source 1 address operands is compared to the source 2 string
;	specified by the source 2 length and source  2  address  operands.   The
;	only action is to affect the condition codes.
;
; Input Parameters:
;
;	Entry at VAX$CMPP3
;
;		R0 - len.rw		Length of either decimal string
;		R1 - src1addr.ab	Address of first packed decimal string
;		R3 - src2addr.ab	Address of second packed decimal string
;
;	Entry at VAX$CMPP4
;
;		R0 - src1len.rw		Length of first packed decimal string
;		R1 - src1addr.ab	Address of first packed decimal string
;		R2 - src2len.rw		Length of second packed decimal string
;		R3 - src2addr.ab	Address of second packed decimal string
;
; Output Parameters:
;
;	R0 = 0
;	R1 = Address of the byte containing the most significant digit of
;	     the first source string
;	R2 = 0
;	R3 = Address of the byte containing the most significant digit of
;	     the second source string
;
; Condition Codes:
;
;	N <- first source string LSS second source string
;	Z <- first source string EQL second source string
;	V <- 0
;	C <- 0
;
; Register Usage:
;
;	This routine uses R0 through R5. The condition codes are recorded
;	in R2 as the routine executes.
;
; Algorithm:
;
;	TBS
;-

	.SUBTITLE	Data Declarations for CMPP3 and CMPP4

;+
; Define some bit fields that allow recording the presence of minus signs
; in either or both of the source strings.
;-

	$DEFINI	CMPPx_FLAGS

	_VIELD	CMPPx,0,<-
		<SRC1_MINUS,,M>,-
		<SRC2_MINUS,,M>,-
			>

	$DEFEND	CMPPx_FLAGS

	.ENABLE		LOCAL_BLOCK

VAX$CMPP3::
	MOVZWL	R0,R2			; Make two source lengths equal
	BRB	10$			; Only make one length check	

VAX$CMPP4::
	ROPRAND_CHECK	R2			; Insure that R2 LEQU 31
10$:	ROPRAND_CHECK	R0			; Insure that R0 LEQU 31
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R10>	; Save some registers
	ESTABLISH_HANDLER	-		; Store address of access 
		DECIMAL_ACCVIO			;  violation handler

; Get sign of first input string

	CLRL	R4			; Assume both strings contain "+"
	EXTZV	#1,#4,R0,R5		; Convert digit count to byte count
	MARK_POINT	CMPPx_ACCVIO
	BICB3	#^B11110000,(R1)[R5],R5	; R5 contains "sign" digit
	CASE	R5,TYPE=B,LIMIT=#10,<-	; Dispatch on sign digit
		30$,-			; 10 => sign is "+"
		20$,-			; 11 => sign is "-"
		30$,-			; 12 => sign is "+"
		20$,-			; 13 => sign is "-"
		30$,-			; 14 => sign is "+"
		30$,-			; 15 => sign is "+"
		>

20$:	BISL2	#CMPPx_M_SRC1_MINUS,R4	; Remember that src1 contains "-"

; Now get sign of second input string

30$:	EXTZV	#1,#4,R2,R5		; Convert digit count to byte count
	MARK_POINT	CMPPx_ACCVIO
	BICB3	#^B11110000,(R3)[R5],R5	; R5 contains "sign" digit
	CASE	R5,TYPE=B,LIMIT=#10,<-	; Dispatch on sign digit
		50$,-			; 10 => sign is "+"
		40$,-			; 11 => sign is "-"
		50$,-			; 12 => sign is "+"
		40$,-			; 13 => sign is "-"
		50$,-			; 14 => sign is "+"
		50$,-			; 15 => sign is "+"
		>

40$:	BISL2	#CMPPx_M_SRC2_MINUS,R4	; Remember that src2 contains "-"

; At this point, we have determined the signs of both input strings. If the
; strings have different signs, then the comparison is done except for the
; extraordinary case of comparing a minus zero to a plus zero. If both signs
; are the same, then a digit-by-digit comparison is required.

50$:	CASE	R4,LIMIT=#0,TYPE=B,<-	; Dispatch on combination of signs
		60$,-			; Both signs are "+"
		MINUS_ZERO_CHECK,-	; Signs are different
		MINUS_ZERO_CHECK,-	; Signs are different
		60$,-			; Both signs are "-"
		>

; Both strings have the same sign. If the strings have different lengths, then
; the excess digits in the longer string are checked for nonzero because that
; eliminates the need for further comparison.

60$:	SUBL3	R0,R2,R5		; Get difference in lengths
	BEQL	EQUAL_LENGTH		; Strings have the same size
	BLSS	SRC2_SHORTER		; src2 is shorter than src1

; This code executes when src1 is shorter than src2. That is, R0 LSSU R2.
; The large comment at the beginning of this module explains the need for the
; INCL R5 instruction when R0, the length of the shorter string, is odd.

SRC1_SHORTER:
	BLBC	R0,70$			; Skip adjustment if R0 is even
	INCL	R5			; Adjust digit difference if R0 is odd
70$:	EXTZV	#1,#4,R5,R5		; Convert digit count to byte count
	BEQL	EQUAL_LENGTH		; Skip loop if no entire bytes in excess

	MARK_POINT	CMPPx_ACCVIO
80$:	TSTB	(R3)+			; Test excess src2 digits for nonzero
	BNEQ	SRC1_SMALLER		; All done if nonzero. src1 LSS src2
	SOBGTR	R5,80$			; Test for end of loop

	BRB	EQUAL_LENGTH		; Enter loop that performs comparison

; This code executes when src2 is shorter than src1. That is, R2 LSSU R0.
; The large comment at the beginning of this module explains the need for the
; INCL R5 instruction when R2, the length of the shorter string, is odd.

SRC2_SHORTER:
	MOVL	R2,R0			; R0 contains number of remaining digits
	MNEGL	R5,R5			; Make difference positive
	BLBC	R2,90$			; Skip adjustment if R2 is even
	INCL	R5			; Adjust digit difference if R2 is odd
90$:	EXTZV	#1,#4,R5,R5		; Convert digit count to byte count
	BEQL	EQUAL_LENGTH		; Skip loop if no entire bytes in excess

	MARK_POINT	CMPPx_ACCVIO
100$:	TSTB	(R1)+			; Test excess src1 digits for nonzero
	BNEQ	SRC2_SMALLER		; All done if nonzero. src2 LSS src1
	SOBGTR	R5,100$			; Test for end of loop

; All excess digits are zero. We must now perform a digit-by-digit comparison
; of the remaining digits in the two strings. R0 contains the remaining number
; of digits in either string.

EQUAL_LENGTH:
	EXTZV	#1,#4,R0,R0		; Convert digit count to byte count
	BEQL	120$			; All done if no digits remain

	MARK_POINT	CMPPx_ACCVIO
110$:	CMPB	(R1)+,(R3)+		; Compare next two digits
	BNEQ	NOT_EQUAL		; Comparison complete if not equal
	SOBGTR	R0,110$			; Test for end of loop

; Compare least significant digit in source and destination strings

	MARK_POINT	CMPPx_ACCVIO
120$:	BICB3	#^B00001111,(R1),R1	; Strip sign from last src1 digit
	MARK_POINT	CMPPx_ACCVIO
	BICB3	#^B00001111,(R3),R3	; Strip sign from last src2 digit
	CMPB	R1,R3			; Compare least significant digits
	BNEQ	NOT_EQUAL

; At this point, all tests have been exhausted and the two strings have
; been shown to be equal. Set the Z-bit, clear the remaining condition
; codes, and restore saved registers.

SRC1_EQL_SRC2:
	MOVZBL	#PSL$M_Z,R2		; Set condition codes for src1 EQL src2

; This is the common exit path. R2 contains the appropriate settings for the
; N- and Z-bits. There is no other expected input at this point.

CMPPx_EXIT:
	CLRL	(SP)			; Set saved R0 to 0
	CLRL	8(SP)			; Set saved R2 to 0
	BICPSW	#<PSL$M_N!PSL$M_Z!PSL$M_V!PSL$M_C>	; Start with clean slate
	BISPSW	R2			; Set N- and Z-bits as appropriate
	POPR	#^M<R0,R1,R2,R3,R4,R5,R10>	; Restore saved registers
	RSB					; Return

; The following code executes if specific digits in the two strings have
; tested not equal. Separate pieces of code are selected for the two
; different cases of not equal. Note that unsigned comparisons are required
; here because the decimal digits "8" and "9", when appearing in the high
; nibble, can cause the sign bit to be set.

NOT_EQUAL:
	BLSSU	SRC1_SMALLER		; Branch if src1 is smaller than src2

; The src2 string has a smaller magnitude than the src1 string. The setting
; of the signs determines how this transforms to a signed comparison. That is,
; if both input signs are minus, then reverse the sense of the comparison.

SRC2_SMALLER:
	BBS	#CMPPx_V_SRC2_MINUS,R4,SRC1_SMALLER_REALLY

; The SRC2 string has been determined to be smaller that the SRC1 string

SRC2_SMALLER_REALLY:
	CLRL	R2			; Clear both N- and Z-bits
	BRB	CMPPx_EXIT		; Join common exit code

; The src1 string has a smaller magnitude than the src2 string. The setting
; of the signs determines how this transforms to a signed comparison. That is,
; if both input signs are minus, then reverse the sense of the comparison.

SRC1_SMALLER:
	BBS	#CMPPx_V_SRC1_MINUS,R4,SRC2_SMALLER_REALLY

; The src1 string has been determined to be smaller that the src2 string

SRC1_SMALLER_REALLY:
	MOVB	#PSL$M_N,R2		; Clear both N- and Z-bits
	BRB	CMPPx_EXIT		; Join common exit code

; The following code executes if the two input strings have different
; signs. We need to determine if a comparison between plus zero and minus
; zero is being made, because such a comparison should test equal. We scan
; first one string and then the other. If we find a nonzero digit anywhere
; along the way, we immediately exit this test and set the final condition
; codes such that the "-" string is smaller than the "+" string. If we
; exhaust both strings without finding a nonzero digit, then we report
; that the two strings are equal.

MINUS_ZERO_CHECK:
	EXTZV	#1,#4,R0,R0		; Convert src1 digit count to byte count
	BEQL	170$			; Skip loop if only single digit

	MARK_POINT	CMPPx_ACCVIO
160$:	TSTB	(R1)+			; Test next byte for nonzero
	BNEQ	CMPPx_NOT_ZERO		; Exit loop if nonzero
	SOBGTR	R0,160$			; Test for end of loop

	MARK_POINT	CMPPx_ACCVIO
170$:	BITB	#^B11110000,(R1)	; Test least significant digit
	BNEQ	CMPPx_NOT_ZERO		; Exit if this digit is not zero

; All digits in src1 are zero. Now we must look for nonzero digits in src2.

	EXTZV	#1,#4,R2,R2		; Convert src2 digit count to byte count
	BEQL	190$			; Skip loop if only single digit

	MARK_POINT	CMPPx_ACCVIO
180$:	TSTB	(R3)+			; Test next byte for nonzero
	BNEQ	CMPPx_NOT_ZERO		; Exit loop if nonzero
	SOBGTR	R2,180$			; Test for end of loop

	MARK_POINT	CMPPx_ACCVIO
190$:	BITB	#^B11110000,(R3)	; Test least significant digit
	BEQL	SRC1_EQL_SRC2		; Branch if two strings are equal 

; At least one of the two input strings contains at least one nonzero digit.
; That knowledge is sufficient to determine the result of the comparison
; based simply on the two (necessarily different) signs of the input strings.

CMPPx_NOT_ZERO:
	BBS	#CMPPx_V_SRC2_MINUS,R4,SRC2_SMALLER_REALLY
	BRB	SRC1_SMALLER_REALLY

	.DISABLE	LOCAL_BLOCK

	.SUBTITLE	VAX$MOVP - Move Packed
;+
; Functional Description:
;
;	The destination string specified by the length and  destination  address
;	operands  is  replaced  by the source string specified by the length and
;	source address operands.
;
; Input Parameters:
;
;	R0 - len.rw		Length of input and output decimal strings
;	R1 - srcaddr.ab		Address of input packed decimal string
;	R3 - dstaddr.ab		Address of output packed decimal string
;
;	PSL<C>			Contains setting of C-bit when MOVP executed
;
; Output Parameters:
;
;	R0 = 0
;	R1 = Address of byte containing most significant digit of
;	     the source string
;	R2 = 0
;	R3 = Address of byte containing most significant digit of
;	     the destination string
;
; Condition Codes:
;
;	N <- destination string LSS 0
;	Z <- destination string EQL 0
;	V <- 0
;	C <- C				; Note that C-bit is preserved!
;
; Register Usage:
;
;	This routine uses R0 through R3. The condition codes are recorded
;	in R2 as the routine executes.
;
; Notes:
;
;	The initial value of the C-bit must be captured (saved in R2) before
;	any instructions execute that alter the C-bit.
;-

VAX$MOVP::
	MOVPSL	R2			; Save initial PSL (to preserve C-bit)

	ASSUME MOVP_B_STATE EQ 2	; Make sure that FPD bit is in R0<23:16>

	BBC	#<MOVP_V_FPD + 16>,R0,5$	; Branch if first time
	EXTZV	#<MOVP_V_SAVED_PSW + 16>,-	; Otherwise, replace condition
		#MOVP_S_SAVED_PSW,R0,R2		;  codes with previous settings

5$:	ROPRAND_CHECK	R0		; Insure that R0 LEQU 31

; Save the starting addresses of the input and output strings in addition to
; the digit count operand (initial R0 contents.) Store a place holder for
; saved R2. 

	PUSHR	#^M<R0,R1,R2,R3,R10>	; Save initial register contents
	ESTABLISH_HANDLER	-	; Store address of access 
		DECIMAL_ACCVIO		;  violation handler

	INSV	#<PSL$M_Z@-1>,#1,#3,R2	; Set Z-bit. Clear N- and V-bits.
	EXTZV	#1,#4,R0,R0		; Convert digit count to byte count
	BEQL	30$			; Skip loop if zero or one digit

	MARK_POINT	MOVP_ACCVIO
10$:	MOVB	(R1)+,(R3)+		; Move next two digits
	BEQL	20$			; Leave Z-bit alone if both zero
	BICB	#PSL$M_Z,R2		; Otherwise, clear saved Z-bit
20$:	SOBGTR	R0,10$			; Check for end of loop

; The last byte must be processed in a special way. The digit must be checked
; for nonzero because that affects the condition codes. The sign must be
; transformed into the preferred form. The N-bit must be set if the input
; is negative, but cleared in the case of negative zero.

	MARK_POINT	MOVP_ACCVIO
30$:	MOVB	(R1),R0			; Get last input byte (R1 now scratch)
	BITB	#^B11110000,R0		; Is digit nonzero?
	BEQL	40$			; Branch if zero
	BICB	#PSL$M_Z,R2		; Otherwise, clear saved Z-bit	
40$:	BICB3	#^B11110000,R0,R1	; Sign "digit" to R1

; Assume that the sign is "+". If the input sign is minus, one of the several
; fixups that must be done is to change the output sign from "+" to "-".

	INSV	#12,#0,#4,R0		; 12 is preferred plus sign
	CASE	R1,LIMIT=#10,TYPE=B,<-	; Dispatch on sign type
		60$,-			; 10 => +
		50$,-			; 11 => -
		60$,-			; 12 => +
		50$,-			; 13 => -
		60$,-			; 14 => +
		60$,-			; 15 => +
		>

; Input sign is "-"

50$:	BBS	#PSL$V_Z,R2,60$		; Treat as "+" if negative zero
	INCL	R0			; 13 is preferred minus sign
	BISB	#PSL$M_N,R2		; Set N-bit

; Input sign is "+" or input is negative zero. Nothing special to do.

	MARK_POINT	MOVP_ACCVIO
60$:	MOVB	R0,(R3)			; Move modified final digit
	CLRL	(SP)			; R0 and R2 must be zero on output
	CLRL	8(SP)			;  so clear saved R0 and R2
	BICPSW	#<PSL$M_N!PSL$M_Z!PSL$M_V!PSL$M_C>	; Clear all codes
	BISPSW	R2			; Reset codes as appropriate
	POPR	#^M<R0,R1,R2,R3,R10>	; Restore saved registers
	RSB				; Return

	.SUBTITLE	Routine to Strip Leading Zeros from Decimal String
;+
; Functional Description:
;
;	This routine strips leading (high-order) zeros from a packed decimal 
;	string. The routine exists based on two assumptions.
;
;	1.  Many of the decimal strings that are used in packed decimal 
;	    operations have several leading zeros.
;
;	2.  The operations that are performed on a byte containing packed 
;	    decimal digits are more complicated that the combination of this 
;	    routine and any special end processing that occurs in the various 
;	    VAX$xxxxxx routines when a string is exhausted.
;
;	This routine exists as a performance enhancement. As such, it can only
;	succeed if it is extremely efficient. It does not attempt to be
;	rigorous in squeezing every last zero out of a string. It eliminates
;	only entire bytes that contain two zero digits. It does not look for a
;	leading zero in the high order nibble of a string of odd length. 
;
;	The routine also assumes that the input decimal strings are well 
;	formed. If an even-length decimal string does not have a zero in its 
;	unused high order nibble, then no stripping takes place, even though 
;	the underlying VAX$xxxxxx routine will work correctly. 
;
;	(The comment in the next four lines is preserved for its historical
;	content.)
;
;	Finally, there is no explicit test for the end of the string. The 
;	routine assumes that the low order byte, the one that contains the 
;	sign, is not equal to zero. This can cause rather strange behavior
;	(read UNPREDICTABLE) for poorly formed decimal strings.
;
;	(The following comment describes the revised treatment of certain forms
;	of illegal packed decimal strings.)
;
;	Although an end-of-string test is not required for well formed packed
;	decimal strings, it turns out that some layered products create packed
;	decimal data on the fly consisting of so many bytes containing zero. In
;	other words, the sign nibble contains zero. Previous implementations of
;	the VAX architecture have treated these strings as representations of
;	packed decimal zero. 
;
;	The BLEQ 30$ instructions that exist in the following two loops detect
;	these strings and treat them as strings with a digit count of one.
;	(The digit itself is zero.) Whether this string is treated as +0 or -0
;	is determined by the caller of this routine. That much UNPREDICTABLE
;	behavior remains in the treatment of these illegal strings. 
;
;	(End of revised comment)
;
; Input and Output Parameters:
;
;	There are really two identical but separate routines here. One is
;	used when the input decimal string descriptor is in R0 and R1. The
;	other is used when R2 and R3 describe the decimal string. Note that
;	we have already performed the reserved operand checks so that R0 (or
;	R2) is guaranteed LEQU 31.
;
;	If the high order digit of an initially even length string is zero,
;	then the digit count (R0 or R2) is reduced by one. For all other
;	cases, the digit count is reduced by two as an entire byte of zeros
;	is skipped.
;
; Input Parameters (for entry at DECIMAL$STRIP_ZEROS_R0_R1):
;
;	R0<4:0> - len.rw	Length of input decimal string
;	R1      - addr.ab	Address of input packed decimal string
;
; Output Parameters (for entry at DECIMAL$STRIP_ZEROS_R0_R1):
;
;	R1	Advanced to first nonzero byte in string
;	R0	Reduced accordingly (Note that if R0 is altered at all,
;		then R0 is always ODD on exit.)
;
; Input Parameters (for entry at DECIMAL$STRIP_ZEROS_R2_R3):
;
;	R2<4:0> - len.rw	Length of input decimal string
;	R3      - addr.ab	Address of input packed decimal string
;
; Output Parameters (for entry at DECIMAL$STRIP_ZEROS_R2_R3):
;
;	R3	Advanced to first nonzero byte in string
;	R2	Reduced accordingly (Note that if R2 is altered at all,
;		then R2 is always ODD on exit.)
;
; Note:
;
;	Although these routines can generate access violations, there is no
;	MARK_POINT here because these routines can be called from other
;	modules (and are not called by the routines in this module). The PC
;	check is made based on the return PC from this subroutine rather than
;	on the PC of the instruction that accessed the inaccessible address. 
;-

; This routine is used when the decimal string is described by R0 (digit
; count) and R1 (string address).

DECIMAL$STRIP_ZEROS_R0_R1::
	BLBS	R0,10$			; Skip first check if R0 starts out ODD
	TSTB	(R1)+			; Is first byte zero?
	BNEQ	20$			; All done if not
	DECL	R0			; Skip leading zero digit (R0 NEQU 0)

10$:	TSTB	(R1)+			; Is next byte zero?
	BNEQ	20$			; All done if not	
	SUBL	#2,R0			; Decrease digit count by 2
	BLEQ	30$			; We passed the end of the string
	BRB	10$			; ... and charge on

20$:	DECL	R1			; Back up R1 to last nonzero byte
	RSB

30$:	ADDL	#2,R0			; Undo last R0 modification
	BRB	20$			; ... and take common exit

; This routine is used when the decimal string is described by R2 (digit
; count) and R3 (string address).

DECIMAL$STRIP_ZEROS_R2_R3::
	BLBS	R2,10$			; Skip first check if R2 starts out ODD
	TSTB	(R3)+			; Is first byte zero?
	BNEQ	20$			; All done if not
	DECL	R2			; Skip leading zero digit (R2 NEQU 0)

10$:	TSTB	(R3)+			; Is next byte zero?
	BNEQ	20$			; All done if not	
	SUBL	#2,R2			; Decrease digit count by 2
	BLEQ	30$			; We passed the end of the string
	BRB	10$			; ... and charge on

20$:	DECL	R3			; Back up R3 to last nonzero byte
	RSB

30$:	ADDL	#2,R2			; Undo last R2 modification
	BRB	20$			; ... and take common exit


	.SUBTITLE	DECIMAL_ROPRAND
;-
; Functional Description:
;
;	This routine receives control when a digit count larger than 31
;	is detected. The exception is architecturally defined as an
;	abort so there is no need to store intermediate state. Because
;	all of the routines in this module check for legal digit counts
;	before saving any registers, this routine simply passes control
;	to VAX$ROPRAND.
;
; Input Parameters:
;
;	0(SP) - Return PC from VAX$xxxxxx routine
;
; Output Parameters:
;
;	0(SP) - Offset in packed register array to delta PC byte
;	4(SP) - Return PC from VAX$xxxxxx routine
;
; Implicit Output:
;
;	This routine passes control to VAX$ROPRAND where further
;	exception processing takes place.
;-

	ASSUME CMPP3_B_DELTA_PC EQ MOVP_B_DELTA_PC 
	ASSUME CMPP4_B_DELTA_PC EQ MOVP_B_DELTA_PC 

DECIMAL_ROPRAND:
	PUSHL	#MOVP_B_DELTA_PC	; Store offset to delta PC byte
	BRW	VAX$ROPRAND		; Pass control along

	.SUBTITLE	DECIMAL_ACCVIO - Reflect an Access Violation
;+
; Functional Description:
;
;	This routine receives control when an access violation occurs while
;	executing within the emulator routines for CMPP3, CMPP4 or MOVP.
;
;	The routine header for ASHP_ACCVIO in module VAX$ASHP contains a
;	detailed description of access violation handling for the decimal
;	string instructions. 
;
; Input Parameters:
;
;	See routine ASHP_ACCVIO in module VAX$ASHP
;
; Output Parameters:
;
;	See routine ASHP_ACCVIO in module VAX$ASHP
;-

DECIMAL_ACCVIO:
	CLRL	R2			; Initialize the counter
	PUSHAB	MODULE_BASE		; Store base address of this module
	SUBL2	(SP)+,R1		; Get PC relative to this base

10$:	CMPW	R1,PC_TABLE_BASE[R2]	; Is this the right PC?
	BEQL	30$			; Exit loop if true
	AOBLSS	#TABLE_SIZE,R2,10$	; Do the entire table

; If we drop through the dispatching based on PC, then the exception is not 
; one that we want to back up. We simply reflect the exception to the user.

20$:	POPR	#^M<R0,R1,R2,R3>	; Restore saved registers
	RSB				; Return to exception dispatcher

; The exception PC matched one of the entries in our PC table. R2 contains
; the index into both the PC table and the handler table. R1 has served
; its purpose and can be used as a scratch register.

30$:	MOVZWL	HANDLER_TABLE_BASE[R2],R1	; Get the offset to the handler
	JMP	MODULE_BASE[R1]		; Pass control to the handler
	
; In all of the instruction-specific routines, the state of the stack
; will be shown as it was when the exception occurred. All offsets will
; be pictured relative to R0. 

	.SUBTITLE	Context-Specific Access Violation Handling for VAX$CMPPx
;+
; Functional Description:
;
;	It is trivial to back out CMPP3 and CMPP4 because neither of these 
;	routines uses any stack space (other than saved register space). The 
;	only reason that this routine does not use the common 
;	VAX$DECIMAL_ACCVIO exit path is that fewer registers are saved by 
;	these two routines than are saved by the typical packed decimal 
;	emulation routine.
;
; Input Parameters:
;
;	R0 - Address of top of stack when access violation occurred
;
;	00(R0) - Saved R0 on entry to VAX$CMPPx
;	04(R0) - Saved R1
;	08(R0) - Saved R2
;	12(R0) - Saved R3
;	16(R0) - Saved R4
;	20(R0) - Saved R5
;	24(R0) - Saved R10
;	28(R0) - Return PC from VAX$CMPPx routine
;
;	00(SP) - Saved R0 (restored by VAX$HANDLER)
;	04(SP) - Saved R1
;	08(SP) - Saved R2
;	12(SP) - Saved R3
;
; Output Parameters:
;
;	R0 is advanced over saved register array as the registers are restored.
;	R0 ends up pointing at the return PC.
;
;	R1 contains the value of delta PC for all of the routines that
;	use this common code path. The FPD and ACCVIO bits are both set
;	in R1.
;
;	00(R0) - Return PC from VAX$CMPPx routine
;	
;	00(SP) - Value of R0 on entry to VAX$CMPPx
;	04(SP) - Value of R1 on entry to VAX$CMPPx
;	08(SP) - Value of R2 on entry to VAX$CMPPx
;	12(SP) - Value of R3 on entry to VAX$CMPPx
;
;	R4, R5, and R10 are restored to their values on entry to VAX$CMPPx.
;-

	.ENABLE		LOCAL_BLOCK

CMPPx_ACCVIO::
	MOVQ	(R0)+,PACK_L_SAVED_R0(SP)	; "Restore" R0 and R1
	MOVQ	(R0)+,PACK_L_SAVED_R2(SP)	; "Restore" R2 and R3
	MOVQ	(R0)+,R4			; Really restore R4 and R5

; The last two instructions can be shared with MOVP_ACCVIO, provided that
; the following assumptions hold.

	ASSUME CMPP3_B_DELTA_PC EQ MOVP_B_DELTA_PC
	ASSUME CMPP4_B_DELTA_PC EQ MOVP_B_DELTA_PC

	BRB	10$			; Share remainder with MOVP_ACCVIO

	.SUBTITLE	Context-Specific Access Violation Handling for VAX$MOVP
;+
; Functional Description:
;
;	It is almost too trivial to back out VAX$MOVP to its starting point. 
;	If time permits, we will add restart points to this routine. This will 
;	illustrate how one could go about adding restart capability to other 
;	decimal instructions, allowing the routines to pick up where they left 
;	off if an access violation occurs. This will also point out the 
;	magnitude of the task by showing the amount of intermediate state that 
;	must be saved for even so simple a routine as VAX$MOVP.
;
;	The VAX$MOVP routine, like VAX$CMPPx, uses no stack space. It also 
;	saves only a subset of the registers and so a special exit path must 
;	be taken to VAX$REFLECT_FAULT.
;
; Input Parameters:
;
;	R0 - Address of top of stack when access violation occurred
;
;	00(R0) - Saved R0 on entry to VAX$MOVP
;	04(R0) - Saved R1
;	08(R0) - Saved R2
;	12(R0) - Saved R3
;	16(R0) - Saved R10
;	20(R0) - Return PC from VAX$MOVP routine
;
;	00(SP) - Saved R0 (restored by VAX$HANDLER)
;	04(SP) - Saved R1
;	08(SP) - Saved R2
;	12(SP) - Saved R3
;
; Output Parameters:
;
;	R0 is advanced over saved register array as the registers are restored.
;	R0 ends up pointing at the return PC.
;
;	R1 contains the value of delta PC for all of the routines that
;	use this common code path. The FPD and ACCVIO bits are both set
;	in R1.
;
;	00(R0) - Return PC from VAX$MOVP routine
;	
;	00(SP) - Value of R0 on entry to VAX$MOVP
;	04(SP) - Value of R1 on entry to VAX$MOVP
;	08(SP) - Value of R2 on entry to VAX$MOVP
;	12(SP) - Value of R3 on entry to VAX$MOVP
;
;	R10 is restored to its value on entry to VAX$MOVP.
;-

MOVP_ACCVIO::
	MOVQ	(R0)+,PACK_L_SAVED_R0(SP)	; "Restore" R0 and R1
	MOVQ	(R0)+,PACK_L_SAVED_R2(SP)	; "Restore" R2 and R3
	BISB3	#MOVP_M_FPD,-8(R0),-
		MOVP_B_STATE(SP)		; Preserve saved C-bit

10$:	MOVL	(R0)+,R10			; Really restore R10 

	MOVL	#<MOVP_B_DELTA_PC!-	; Indicate offset for delta PC
		PACK_M_FPD!-		; FPD bit should be set
		PACK_M_ACCVIO>,R1	; This is an access violation
	BRW	VAX$REFLECT_FAULT	; Continue exception handling

	.DISABLE	LOCAL_BLOCK

	.END
