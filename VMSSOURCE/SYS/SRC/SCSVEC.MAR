	.IF	NDF,PRMSW
	.TITLE	SCSVEC - System Communications Service Vectors
	.IFF
	.TITLE	SCSLOA - System Communications Service Loadcode
	.ENDC
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	Executive data base
;
; ABSTRACT:
;	This module contains the global entry point vectors for System
;	Communications Services (SCS).  The targets of these vectors are
;	updated to point to the actual SCS image after it is loaded into
;	non-paged pool.
;
; ENVIRONMENT:  
;
; AUTHOR:  KERBEY T. ALTMANN, CREATION DATE:	22-APR-1981
;
; MODIFIED BY:
;
;	V03-033	DWT0237		David W. Thiel		10-Aug-1984
;		Correct reference to RDT$L_MAXRDIDX to match change
;		made in V03-032 below.
;
;	V03-032	NPK3058		N. Kronenberg		25-Jul-1984
;		Fix maximume RDTE index to be index rather than number
;		of RDTEs configured.
;
;	V03-031	NPK3056		N. Kronenberg		23-Jul-1984
;		Add capacity in Connection Descriptor List for addition
;		of CDT's beyond the sysgened number.  Add to SCS$ALLOC_CDT
;		the ability to allocate more CDTs from pool if the
;		are no free CDTs linked to the CDL.
;		Fix error in computation of CDL max index in CDL header
;		(it was # CDTs not index.)
;
;	V03-030	TCM0001		Trudy C. Matthews	20-Jul-1984
;		Remove routine IOC$THREADCRB; put it in IOSUBNPAG instead.
;
;	V03-029	KTA3113		Kerbey T. Altmann	20-Mar-1984
;		Add new entry - SCS$SHUTDOWN to shut down all SCS virtual
;		circuits.  Add new pointers for MSCP image and list of PDTs.
;
;	V03-028	KTA3102		Kerbey T. Altmann	09-Feb-1984
;		Prevent RDT/CDT sequence numbers from ever being zero.
;
;	V03-027	TMK0001		Todd M. Katz		05-Jan-1984
;		Change SCS$DIRECTORY so that it sends a counted sequential
;		message back to the remote SYSAP with the results of the
;		directory lookup. SCS$DIRECTORY was sending an un-counted
;		sequential message, and if the local SCSMAXMSG size was greater
;		than the remote SCSMAXMSG size, then this was resulting in
;		the remote port driver receiving a sequential message larger
;		in size then any of its receive buffers. 
;
;	V03-026	KDM0063		Kathleen D. Morse	03-Aug-1983
;		Replace random number generation usage of PR$_TODR with
;		usage of EXE$GQ_SYSTIME.
;
;	V03-025	NPK3029		N. Kronenberg		22-Jul-1983
;		Zero most fields in a freshly allocated CDT (needed
;		for per connection counters.)
;		Modify SCS$CONFIG_PTH to take advantage of rearranged
;		path block.
;
;	V03-024	MSH0010		Maryann Hinden		11-Jul-1983
;		Fix method of addressing SCS$GA_EXISTS.
;
;	V03-023	MSH0009		Maryann Hinden		27-Jun-1983
;		Modifications to error handling for SCS$DIRECTORY.
;		Keep process poller from polling a given system until
;		current poll is complete.
;
;	V03-022	MSH0008		Maryann Hinden		27-Jun-1983
;		Use remote process name in DIR_LOOKUP which won't get
;		deallocated.
;
;	V03-021	MSH0007		Maryann Hinden		23-Jun-1983
;		Use $PRCPOLDEF.  Check for nonpaged pool not available
;		in SCS$DIRECTORY.  Add SCS$GA_EXISTS to start CONFIGURE
;		process.
;
;	V03-020	MSH0006		Maryann Hinden		18-May-1983
;		Put nodename in process poller mailbox.
;
;	V03-019	ROW0184		Ralph O. Weber		19-APR-1983
;		Change order of wait queue searching in SCS$LKP_MSGWAIT so 
;		that message buffer wait queue is scanned first.  This is done 
;		because the way PADRIVER enters CDRPs into to the send credit 
;		and message buffer wait queues makes the message buffer wait 
;		queue is likely to contain older (longer waiting) CDRPs.  The 
;		connection manager needs this additional level of age ordering 
;		to help provide sequential delivery of messages.
;
;	V03-018 MSH0005		Maryann Hinden		19-Apr-1983
;		Use only one CDRP per connection.
;
;	V03-017	JWH0217		Jeffrey W. Horn		14-Apr-1983
;		Change second SLV table to be generated with SLVTAB macro.
;
;	V03-016	MSH0004		Maryann Hinden		08-Apr-1983
;		Changes to support HSC. Various bug fixes.
;
;	V03-015	JWH0211		Jeffrey W. Horn		13-Apr-1983
;		Use SLVTAB macro to produce loadable-code prologue.
;
;	V03-014	MSH0003		Maryann Hinden		01-Apr-1983
;		Move location of MY_PROC.
;	
;	V03-013	MSH0002		Maryann Hinden		24-Mar-1983
;
;--

	.page
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES
;
	.nocross
	.IF	DF,PRMSW		; For linkage with SCS
	$CCBDEF
	$CDLDEF
	$CDRPDEF
	$CDTDEF
	$CRBDEF
	$DDBDEF
	$DDTDEF
	$DYNDEF
	$IPLDEF
	$PBDEF
	$PBODEF
	$PDTDEF
	$PRCPOLDEF
	$RDDEF
	$RDTDEF
	.IFTF				; Always need the following definition
	$SBDEF
	.IFT
	$SBODEF
	$SDIRDEF
	$SPNBDEF
	$SPPBDEF
	$SSDEF
	$TQEDEF
	$UCBDEF
	.ENDC
	.cross

;
; Local macros
;
	.MACRO	LIST_HEAD,ENTRY
	.ALIGN	LONG
ENTRY::	.LONG	ENTRY
	.LONG	ENTRY
	.ENDM

	.MACRO	POINTER,ENTRY
	.ALIGN	LONG
ENTRY::	.LONG	0
	.ENDM

;
; Misc labels
;
	.IF	NDF,PRMSW		; For linkage with SYS.EXE
	.PSECT	$$$500,LONG

;
; Quadword linked list heads
;

SCS$GQ_CONFIG::
	.LONG	SCS$GA_LOCALSB
	.LONG	SCS$GA_LOCALSB
	LIST_HEAD SCS$GQ_DIRECT
	LIST_HEAD SCS$GQ_POLL		; List of SPPB's giving process names

;
; Longword pointers
;

	POINTER	SCS$GL_BDT
	POINTER	SCS$GL_CDL
	POINTER	SCS$GL_RDT
	POINTER	SCS$GL_MCLEN
	POINTER	SCS$GL_MCADR
	POINTER	SCS$GL_MSCP		; Start of MSCP server process
	POINTER	SCS$GL_PDT		; Singly link list of PDT's

;
; Process poller static data
;

SCS$GA_DFLTMSK::			; Mask of processes to enable
	.BLKB	SB$S_ENBMSK		;	in new systems that appear
SCS$GW_NEXTBIT::			; Next bit available for assignment
	.WORD	0

SCS$GA_EXISTS:: .LONG	0		; Flag to indicate presence of SCS

DO_RSB:
	CLRL	R0			; Failure status
	RSB				; Ignore call to unloaded routine

	.ALIGN	LONG
;
; Vector list
;

SCS$AL_LOAVEC::
	.IFF
	.PSECT	$$$000,LONG
SCS_START:
	SLVTAB	END	= SCS_END, -
		INITRTN = INIT_BEGIN, -
		SUBTYP	= DYN$C_LC_SCS, -
		FACILITY= <SCS_Loadable>

	.ENDC

	LOADVEC	SCS$ACCEPT
	LOADVEC	SCS$ALLOC_CDT
	LOADVEC	SCS$ALLOC_RSPID
	LOADVEC	SCS$CONFIG_PTH
	LOADVEC	SCS$CONFIG_SYS
	LOADVEC	SCS$CONNECT
	LOADVEC	SCS$DEALL_CDT
	LOADVEC	SCS$DEALL_RSPID
	LOADVEC	SCS$DISCONNECT
	LOADVEC	SCS$ENTER
	LOADVEC	SCS$LISTEN
	LOADVEC	SCS$LOCLOOKUP
	LOADVEC	SCS$REMOVE
	LOADVEC	SCS$RESUMEWAITR
	LOADVEC	SCS$UNSTALLUCB
	LOADVEC	SCS$LKP_RDTCDRP
	LOADVEC	SCS$LKP_RDTWAIT
	LOADVEC SCS$RECYL_RSPID
	LOADVEC	SCS$FIND_RDTE
	LOADVEC	SCS$LKP_MSGWAIT
	LOADVEC	SCS$DIR_LOOKUP		; Search for processes on remote node
	LOADVEC	SCS$NEW_SB,,DO_RSB	; Called when an SB is created/reused
	LOADVEC	SCS$POLL_PROC,,DO_RSB	; Declare a process name to the poller
	LOADVEC	SCS$POLL_MODE		; Enable/Disable polling for a process
	LOADVEC	SCS$POLL_MBX,,DO_RSB	; Declare a mailbox to receive poller notifications
	LOADVEC	SCS$CANCEL_MBX		; Cancel notifications to a mailbox
	LOADVEC	SCS$SHUTDOWN,,DO_RSB	; Shut down all SCS virtual circuits

;
; End of list
;
	.IF	NDF,PRMSW
	.NLIST				; Don't clutter vector listing
	.IFF				; For linking with SCS
	.LONG	-1			; End of vectors

;
; The SCA process name poller makes the following assumptions
;
	ASSUME	IPL$_TIMER  EQ  IPL$_SCS
	ASSUME	IPL$_SYNCH  EQ	IPL$_SCS

	.page
	.SBTTL	INITIALIZATION CODE
;+
; This code is called once upon the loading of SCS.  It initializes any
; piece of SCS that needs it.  It then deallocated itself to pool.
;-

INIT_BEGIN:
	SUBL	#12, SP			; Get some scratch area
	MOVL	SP, R6			; Set a pointer
	BSBW	SEQ_NO			; Get a sequence number
	BSBW	INIT_RDT		; Do the Request Desc
	BLBC	R0, 10$
;	BSBB	SEQ_NO			; Get a sequence number
	ADDW2	#^X10F3, 1(R6)		; Permute the low byte
	BSBW	INIT_CDL		; Do the Connect Desc
	ADDL	#12, SP			; Release the scratch area
	BLBC	R0, 10$			; Check for error
	LISTEN	MSGADR=W^SCS$DIRECTORY,-
		ERRADR=W^LISTENERR,-
		LPRNAM=B^DIRNAME,-
		PRINFO=B^DIRINFO 	; Put our name in directory-leave
					; (MUST BE AFTER INIT OF CDT)
	BLBC	R0, 10$			; Check for error
	BSBW	POLLER_INIT		; Initialize process name poller
	BLBC	R0,10$			; Branch on error
	MOVAL	SCS_START, R0		; Set R0--> start of code
	MOVL	R0,G^SCS$GA_EXISTS	; Indicate presence of SCS 
					; (flag to start CONFIGURE process)
	MOVZWL	#<CODE_HEADER-SCS_START>,R1 ; Set the size of just the init code
	SUBW3	R1,SCS_START+8,-	; Compute size of remaining code
		W^CODE_HEADER+8		;
	MOVAB	G^EXE$GL_NONPAGED+4,R3	; List head
	JSB	G^EXE$DEALLOCATE	; Just the smile on the Cheshire cat...
	MOVL	#1,R0			; Set success
10$:	RSB

;
DIRNAME:.ASCII	/SCS$DIRECTORY   /
DIRINFO:.ASCII	/What city, plez?/
;
; Calculate a random sequence number from the system time
;
SEQ_NO:	
	MOVL	G^EXE$GQ_TODCBASE+2,(R6); Get middle bits of system time
	MOVZWL	(R6), R0		; Get low 16 bits
	MOVZWL	2(R6), R1		; Get another 16 bits
	MULL2	R0, R1			; Multiply them
	MOVZWL	1(R6), R0		; Add in a fudge
	ADDL3	R0, R1, (R6)		; Store away for later
	TSTW	1(R6)			; Check for zero
	BNEQ	10$			; Not so, okay
	INCW	1(R6)			; Yes, fix it
10$:	RSB
;
; Allocate and initialize the Connection Descriptor List
;
INIT_CDL:
	MOVZWL	@#SCS$GW_CDTCNT, R4	; Pick up number of CDT's to alloc
	ADDW	R4,SCS$GW_CDTMAX	; Add sysgened # CDT's to # extension
					;  CDT's allowed
	MOVZWL	#<<CDT$C_LENGTH+15>&^C15>,R7  ; Get rounded CDT size
	MULL3	R7, R4, R1		; Get total amount of space
	ADDL	#SCS$K_CDTEXT,R4	; Get # CDL pointers to CDTs needed
	MOVL	#CDL$C_LENGTH, R5	; Fixed portion of CDL
	MOVAL	15(R5)[R4], R5		; Compute total CDL size with
	BICL	#15, R5			;  appropriate rounding
	ADDL	R5, R1			; Compute total pool needed
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0, 20$			; Error - no memory
;
; R1  =  Size of allocated block
; R2 --> Allocated block
; R4  =  #CDT's to allocate now + # extension CDTs allowed
; R5  =  Size of CDL (Rounded up)
; R7  =  Size of CDT(Rounded up)
;
	SUBL	#SCS$K_CDTEXT,R4	; Back off R4 to # CDT's to allocate now
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save reg
	MOVC5	#0, (SP), #0, R1, (R2)	; Clear it all out
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	MOVAL	CDL$C_LENGTH(R2), -
		@#SCS$GL_CDL		; Set pointer to CDL in system space
	MOVAB	(R2)[R5], R1		; Get pointer to first CDT
	MOVL	R4, (R2)		; Set # CDTs initially
	DECL	(R2)+			; Convert # CDTs to max initl index
	MOVL	R1, (R2)+		; Set first free CDT
	MOVW	R5, (R2)+		; Set size of CDL
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_CDL@8>,(R2)+	; Set type and subtype
	CLRL	(R2)+			; Clear reserved area
	CLRL	R5			; Initialize index
10$:	MOVL	R1, (R2)+		; Set address 	
	MOVAB	(R1)[R7], R3		; Get address of next CDT
	MOVL	R3, CDT$L_LINK(R1)	; Set it into link field
	MOVW	R7, CDT$W_SIZE(R1)	; Set size field
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_CDT@8>, -
		 CDT$B_TYPE(R1)		; Set type and subtype
	MOVW	R5, CDT$L_LCONID(R1)	; Set index piece of CONID
	MOVW	1(R6),CDT$L_LCONID+2(R1); Set sequence piece of CONID
	CLRL	CDT$W_STATE(R1)		; Set state to virgin
	MOVAB	CDT$L_WAITQFL(R1), -
		CDT$L_WAITQFL(R1)	; Set up initial cond
	MOVAB	CDT$L_WAITQFL(R1), -
		CDT$L_WAITQBL(R1)	; Set up initial cond
	MOVAB	CDT$L_CRWAITQFL(R1), -
		CDT$L_CRWAITQFL(R1)	; Set up initial cond
	MOVAB	CDT$L_CRWAITQFL(R1), -
		CDT$L_CRWAITQBL(R1)	; Set up initial cond
	MOVL	R3, R1			; Get next CDT
	AOBLSS	R4, R5,10$		; Loop until all done
	CLRL	-CDT$C_LENGTH(R1)	; Zero out final next pointer
	MOVL	#1, R0
20$:	RSB
;
; Allocate and initialize the Request Descriptor Table
;
INIT_RDT:
	ASSUME	RD$C_LENGTH EQ 8
	MOVZWL	@#SCS$GW_RDTCNT, R4	; Pick up number of RDTE's
	MOVL	#RDT$C_LENGTH, R1	; Fixed portion
	MOVAQ	(R1)[R4], R1		; Total space needed
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0, 20$			; No space, error
	MOVAB	RDT$C_LENGTH(R2), R3	; Set past RDT
	MOVL	R3, @#SCS$GL_RDT	; Set pointer to RDT in system space
	MOVL	R2, R5			; Save it
	MOVL	R5, (R2)+		; Set initial condition
	MOVL	R5, (R2)+		; Ditto
	MOVW	R1, (R2)+		; Set size field
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_RDT@8>,(R2)+	; Set type & subtype
	MOVQ	R3, (R2)+		; Set first free RDTE & # RDTEs
	DECL	-4(R2)			; Convert # RDTEs to maximum index
	CLRL	(R2)+			; Clear out reserved field
	MOVAB	RD$C_LENGTH(R3), R3	; Set R3 point to next RDTE
10$:	MOVAQ	(R3)+, (R2)+		; Set next free RDTE link
	CLRW	(R2)+			; Set state to FREE
	MOVW	1(R6), (R2)+		; Set in sequence number
	SOBGTR	R4, 10$			; Loop until done
	CLRL	-RD$C_LENGTH(R2)	; Zero out final next pointer
	MOVL	#1, R0
20$:	RSB
;
; Initialize the process name poller
;
POLLER_INIT:
	MOVAL	G^SCS$GQ_CONFIG,R3	; Address of system block listhead
	MOVL	(R3),R2			; Address of first SB
10$:	CMPL	R2,R3			; Back to listhead?
	BEQL	20$			; Branch if done
	BSBW	SCS$NEW_SB		; New system to poll	
	MOVL	SB$L_FLINK(R2),R2	; Chain to next SB
	BRB	10$			; Iterate over known systems
;
; Design note:
;
;	The following could be done in less code by having EXE$TIMEOUT make
;	the call.  The tradeoff is that if EXE$TIMEOUT calls the poller,
;	then there is a JSB/RSB overhead every second when not in an SCS
;	environment.  In an SCS environment, however, a TQE and the
;	associated queue management is avoided each second.
;
20$:	MOVZWL	#TQE$K_LENGTH,R1	; Size of a TQE
	BSBW	SCS_ALONONPAGED		; Allocate a TQE
	BLBC	R0,30$			; Exit on error
	MOVW	R1,TQE$W_SIZE(R2)	; Store size
	MOVB	#DYN$C_TQE,TQE$B_TYPE(R2)	; Store type
	MOVB	#TQE$C_SSREPT,TQE$B_RQTYPE(R2)	; Store type of timer queue entry
	MOVAB	W^START_POLL,TQE$L_FPC(R2)	; Address of timeout routine
	ASSUME	TQE$L_FR3+4,EQ,TQE$L_FR4
	CLRQ	TQE$L_FR3(R2)		; Zero R3 and R4
	EMUL	#10*1000*1000,#1,#0, -	; Delta time = 1 second
		TQE$Q_DELTA(R2)
	MOVL	R2,R5			; Address of TQE
	MOVQ	G^EXE$GQ_SYSTIME,R0	; Immediate timeout
	JSB	G^EXE$INSTIMQ		; Link into timer queue
	MOVL	S^#SS$_NORMAL,R0	; All is well
30$:	RSB

	LC=.
	.=<LC+15>&-16			; Align on 16 byte boundary
;
; Put a SLV prologue on this piece.
;
CODE_HEADER:
	SLVTAB	END	= SCS_END, -
		SUBTYP	= DYN$C_LC_SCS, -
		FACILITY= <SCS_Loadable>

;
; Some SCS loadable data:
;

SCS$K_CDTEXT == 100			; Allow # CDT's to be extended
					;  by 100 beyond sysgened value

SCS$GW_CDTMAX::

	.WORD	SCS$K_CDTEXT-1		; This will be the maximum CDT 
					;  index ever allowed in the CDL.
					;  It = 100-1 + sysgened # CDT's
					;  to be filled in during SCS init
	.page
	.SBTTL	SCS$ACCEPT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ACCEPT
;
; INPUTS:
;
;	R3 = Address of listening CDT
;	 0(SP) = Input address			MSGADR
;	 4(SP) = [Datagram input address]	DGADR
;	 8(SP) = Error address			ERRADR
;	12(SP) = Initial credit value		INITCR
;	14(SP) = Minimum send credit value	MINSCR
;	16(SP) = Initial DG credit value	INITDG
;	18(SP) = [Block transfer priority]	BLKPRI
;	20(SP) = Address of connect data	CONDAT
;	24(SP) = Address of auxilary structure	AUXSTR
;	28(SP) = [Bad response packet address]	BADRSP
;	32(SP) = Return address
;
; OUTPUTS:
;
;	R0 = Status
;	R2 = Address of listening CDT
;	R3 = Address of CDT allocated
;	R4 = Address of PDT for listening
;	R1,R2 Destroyed
;	R5   Preserved
;
;--

SCS$ACCEPT:
	MOVL	R3, R2			; Transfer listen CDT ptr
	BSBB	SCS$ALLOC_CDT		; Allocate a CDT
	BLBC	R0, 10$			; None, clean up and leave
	ASSUME	CDT$L_MSGINPUT+4 EQ CDT$L_DGINPUT
	MOVQ	(SP)+,CDT$L_MSGINPUT(R3); Get both MSGINPUT and DGINPUT
	POPL	CDT$L_ERRADDR(R3)	; Set address of error routine
	MOVL	CDT$L_PDT(R2), R4	; Pick up PDT addr from listen
	MOVZBL	#PDT$L_ACCEPT, R1	; Offset in PDT to use
	BRW	PDT_JMP			; Finish in port dependent code

10$:	ADDL	#8*4, SP		; Clean args off stack
	RSB
	.page
	.SBTTL	SCS$ALLOC_CDT
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Attempt to remove a CDT from the free list.  If no more
;	are available, and the CDL has room for an extension CDT,
;	then allocate one CDT from pool.  Put new CDT address in CDT,
;	step current maximum index in CDL header, init CDT to closed 
;	state, and give it a local connection ID.
;
;	In allocated CDT, init wait queues, zero most of the rest of
;	the CDT, and return to caller.
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ALLOC_CDT
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL if success
;	   = SS$_INSFCDT if no CDT's available
;	R1 = CONID
;	R3 = Pointer to CDT if successful
;	   = 0 otherwize
;	R2,R4,R5 preserved
;
;--

SCS$ALLOC_CDT:
	MOVL	@#SCS$GL_CDL, R1	; Pick up pointer to list
	MOVL	CDL$L_FREECDT(R1), R3	; Find first free one
	BNEQ	20$			; Branch if got one
	MOVZWL	#CDT$C_LENGTH,R1	; Get size of a CDT
	PUSHL	R2			; Save caller's register
	BSBW	SCS_ALONONPAGED		; Allocate one from pool
	MOVL	R2,R3			; Copy assumed new CDT addr
	POPL	R2			; Restore caller's R2
	BLBC	R0,NO_CDT		; Branch if didn't get CDT from pool
	MOVW	R1,CDT$W_SIZE(R3)	; Set CDT size,
	MOVW	#DYN$C_SCS!-		;  structure type,
		<DYN$C_SCS_CDT@8>,-	;  and subtype
		CDT$B_TYPE(R3)		;
	CLRL	CDT$W_STATE(R3)		; Set CDT state = closed
	MOVL	@#SCS$GL_CDL,R1		; Get start of CDT list
	MOVL	(R1),R0			; Get 1st CDT address
	MOVL	CDT$L_LCONID(R0),R0	; Get 1st CDT's local CONID
					;  in order to capture its sequence #
	INCW	CDL$W_MAXCONIDX(R1)	; Step max legal CONID index in CDL
	MOVW	CDL$W_MAXCONIDX(R1),R0	; Combine seq # and index
	MOVL	R0,CDT$L_LCONID(R3)	;  = new CDT's connection ID
	MOVZWL	R0,R0			; Isolate index
	MOVL	R3,(R1)[R0]		; Save new CDT addr in CDL
	BRB	30$			; Join common CDT init

20$:	MOVL	CDT$L_LINK(R3), -
		CDL$L_FREECDT(R1)	; Set pointer to next free CDT

30$:	PUSHR	#^M<R2,R3,R4,R5>	; Save registers for MOVC
	MOVC5	#0,#0,#0,-		; Zero CDT from longwd after
		#<CDT$C_LENGTH-CDT$L_LCONID-4>,-
		CDT$L_LCONID+4(R3)	;  local CONID to end
	POPR	#^M<R2,R3,R4,R5>	; Restore destroyed registers
	MOVL	CDT$L_LCONID(R3), R1	; Get conid for return to caller
	MOVAB	CDT$L_WAITQFL(R3), -
		CDT$L_WAITQFL(R3)	; Set up initial cond
	MOVAB	CDT$L_WAITQFL(R3), -
		CDT$L_WAITQBL(R3)	; Set up initial cond
	MOVAB	CDT$L_CRWAITQFL(R3), -
		CDT$L_CRWAITQFL(R3)	; Set up initial cond
	MOVAB	CDT$L_CRWAITQFL(R3), -
		CDT$L_CRWAITQBL(R3)	; Set up initial cond
	MOVL	#1,R0			; Set success
	RSB

NO_CDT:
	MOVZWL	#SS$_INSFCDT,R0		; Set error status
	RSB				;  and return to caller
	.page
	.SBTTL	SCS$ALLOC_RSPID
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ALLOC_RSPID
;
; INPUTS:
;
;	R5 = Pointer to context block (usually CDRP)
;
; OUTPUTS:
;
;	R1 = RSPID
;	R2 = Pointer to RDTE
;	R0,R3,R4 preserved
;
;	RSPID stored in CDRP	(* What if not a CDRP input??? *)
;
; SIDE EFFECTS:
;
;	If no RSPID available, process is put on wait queue, and control
;	returned to caller's caller.
;
;--

SCS$ALLOC_RSPID:
	MOVL	@#SCS$GL_RDT, R1	; Pick up list head
	MOVL	RDT$L_FREERD(R1), R2	; Find first free one
	BEQL	10$			; None available
	MOVL	RD$L_LINK(R2), -
		RDT$L_FREERD(R1)	; Update free list
	SUBL3	R1, R2, R1		; Form offset
	ASHL	#13, R1, R1		; Turn into slot number
	MOVW	RD$W_SEQNUM(R2), R1	; Insert sequence number
	ROTL	#16, R1, R1		; Reverse to correct order
	MOVL	R1, CDRP$L_RSPID(R5)	; Store in contex block
	MOVL	R5, RD$L_CDRP(R2)	; Fill in context block addr
	INCW	RD$W_STATE(R2)		; Set state to IN-USE
	RSB

10$:	MOVQ	R3, CDRP$L_FR3(R5)	; Save R3,R4 in context block
	POPL	CDRP$L_FPC(R5)		; ... and PC
	INSQUE	CDRP$L_FQFL(R5), -	; Insert this context block
		@RDT$L_WAITBL(R1)	;   on RDT wait queue
	MOVL	CDRP$L_RWCPTR(R5), R0	; Pick up any counter
	BEQL	20$			; None
	INCW	(R0)			; Bump the number of resources
20$:	RSB				; Return to caller's caller
	.page
	.SBTTL	SCS$CONFIG_PTH
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	CONFIG_PTH searches  the  path  blocks  on  all  system
;	blocks for one with a matching station address and local
;	port name.  If none is found, then error is returned in
;	R0.   Otherwise, most of the path block information
;	is returned in the caller's output array plus the system
;	ID of the remote system on this  path  and  the  station
;	address  of  the  next  path  to this remote system.  If
;	there are no more paths, the remote station ID  returned
;	is -1.
;
;	A fork process interested in discovering all paths to  a
;	particular  system  first  issues  a  CONFIG_SYS call to
;	learn the station addr/local port name  of  the 1st  path
;	to the system. The fork  process  then  calls  CONFIG_PTH
;	repeatedly  until  a  next  station  address  of  -1  is
;	returned.
;
; CALLING SEQUENCE:
;
;	BSBW	CONFIG_PTH
;
; INPUTS:
;
;	R1 = Address of station address followed by local port name:
;
;	     +--------+--------+--------+--------+
;	     |	    Remote station addr, l.o.    |
;	     +--------+--------+--------+--------+
;	     |    unused       | Rstation, h.o.  |
;	     +--------+--------+--------+--------+
;	     |     Local port name, e.g., PAA0   |
;	     +--------+--------+--------+--------+
;
;	R2 = Address of output buffer to return path information
;		0 if no output desired
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHNODE if failure to find specified path
;	   = 1 if success
;	R1 = Address of path block found (if R0 = success)
;	R2,R3,R4,R5 preserved
;
;--

;
; Path block and output array adjacency assumptions:
;

ASSUME	PB$B_RSTATION+6	  EQ  PB$W_STATE
ASSUME	PB$W_STATE+2	  EQ  PB$L_RPORT_TYP
ASSUME	PB$L_RPORT_TYP+4 EQ  PB$L_RPORT_REV
ASSUME	PB$L_RPORT_REV+4  EQ  PB$L_RPORT_FCN
ASSUME	PB$L_RPORT_FCN+4  EQ  PB$B_RST_PORT
ASSUME	PB$B_RST_PORT+1	  EQ  PB$B_RSTATE
ASSUME	PB$B_RSTATE+1	  EQ  PB$W_RETRY
ASSUME	PB$W_RETRY+2	  EQ  PB$T_LPORT_NAME
ASSUME	PB$T_LPORT_NAME+4 EQ  PB$B_CBL_STS
ASSUME	PB$B_CBL_STS+1	  EQ  PB$B_P0_STS
ASSUME	PB$B_P0_STS+1	  EQ  PB$B_P1_STS

ASSUME	PBO$B_RSTATION+6  EQ  PBO$W_STATE
ASSUME	PBO$W_STATE+2	  EQ  PBO$L_RPORT_TYP
ASSUME	PBO$L_RPORT_TYP+4 EQ  PBO$L_RPORT_REV
ASSUME	PBO$L_RPORT_REV+4 EQ  PBO$L_RPORT_FCN
ASSUME	PBO$L_RPORT_FCN+4 EQ  PBO$B_RST_PORT
ASSUME	PBO$B_RST_PORT+1  EQ  PBO$B_RSTATE
ASSUME	PBO$B_RSTATE+1	  EQ  PBO$W_RETRY
ASSUME	PBO$W_RETRY+2	  EQ  PBO$T_LPORT_NAME
ASSUME	PBO$T_LPORT_NAME+4 EQ PBO$B_CBL_STS
ASSUME	PBO$B_CBL_STS+1	  EQ  PBO$B_P0_STS
ASSUME	PBO$B_P0_STS+1	  EQ  PBO$B_P1_STS
ASSUME	PBO$B_P1_STS+2	  EQ  PBO$B_NXT_RSTAT
ASSUME	PBO$B_NXT_RSTAT+8 EQ  PBO$T_NXT_LPORT
ASSUME	PBO$T_NXT_LPORT+4 EQ  PBO$B_SYSTEMID

SCS$CONFIG_PTH:
	PUSHR	#^M<R2,R3,R4>		; Save registers and output buf. ptr.
	MOVAL	@#SCS$GQ_CONFIG, R0	; Pick up pointer to database
	MOVL	R0, R2			; Hold starting point
10$:	MOVL	(R0), R0		; Get next block in list
	CMPL	R0, R2			; Back where we started (empty) ?
	BEQL	50$			; Yes, leave now
;
; Got a system block, now search for a path block
;
	MOVAL	SB$L_PBFL(R0), R3	; No, have a sys block - find 1st path
	MOVL	R3, R4			; Hold starting point
20$:	MOVL	(R3), R3		; Get next block in list
	CMPL	R3, R4			; Back where we started (empty) ?
	BEQL	10$			; Yes, try another system
	CMPL	(R1), PB$B_RSTATION(R3)	; No, have a pth - check for ID match
	BNEQ	20$			; No match on first 32 bits, try again
	CMPW	4(R1), PB$B_RSTATION+4(R3) ; Check high order
	BNEQ	20$			; No match on next 16 bits, try again
	CMPL	8(R1), PB$T_LPORT_NAME(R3) ; Check local port name
	BNEQ	20$			; Branch if no match, try again
;
; Found a path block whose virtual circuit matches - return the info.
;
	MOVL	(SP),R2			; Recover addr to store info
	BEQL	40$			; None, done store anything
	MOVAL	PB$B_RSTATION(R3), R1	; R1 covers info in PB
	MOVQ	(R1)+, (R2)+		; Transfer 8 bytes (RSTATION)
	MOVQ	(R1)+, (R2)+		; Transfer 8 bytes (port type/rev)
	MOVQ	(R1)+, (R2)+		; Transfer 8 bytes (port fcn/state,retries)
	MOVQ	(R1), (R2)+		; Transfer 8 bytes (LPORT name/cable sts)
	MNEGL	#1, (R2)+		; Set reserved address to
	MNEGL	#1, (R2)+		; to indicate no next path.
	CLRL	(R2)+			; Zero out next local port name
	MOVL	(R3), R1		; Get next path block
	CMPL	R1, R4			; Is there a next?
	BEQL	30$			; No
	MOVQ	PB$B_RSTATION(R1), -12(R2) ; Yes, transfer its station address
	CLRW	-6(R2)			; Clear out reserved field
	MOVL	PB$T_LPORT_NAME(R1), -4(R2) ;  and transfer its local port name
30$:	MOVQ	SB$B_SYSTEMID(R0), (R2)	; Transfer associated system ID
	CLRW	6(R2)			; Clear out reserved field
40$:	MOVL	#1, R0			; Set for success
	BRB	60$			; Clean up

50$:	MOVZWL	#SS$_NOSUCHNODE, R0	; Set for failure
60$:	POPL	R2			; Restore R2
	MOVL	R3, R1			; Transfer path block pointer
	MOVQ	(SP)+, R3		; Restore R3,R4
	RSB				; Leave
	.page
	.SBTTL	SCS$CONFIG_SYS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	CONFIG_SYS searches the list of System Blocks  until  it
;	finds  one  with  a system ID matching the specified ID.
;	If no match is found,  error  is  returned.   Otherwise,
;	most  of  the SB is returned to the caller together with
;	the ID of the next system in the list.
;
;	A fork process interested in finding out about  all  the
;	systems  in  the  configuration simply issues successive
;	CONFIG_SYS  calls  on  the  next  system  ID  until  the
;	returned  next  system ID = 0.  To get information about
;	the first system, specify system ID of 0.   There  is  a
;	possibility  that  the configuration will change between
;	calls unless the entire configuration scan is conducted
;	at SCS IPL or higher.
;
; CALLING SEQUENCE:
;
;	BSBW	CONFIG_SYS
;
; INPUTS:
;
;	R1 = Address of system id to search for
;	R2 = Address of output buffer to return system information
;		0 if none desired
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHNODE if system id not found
;	R1 = Address of system block found (if R0 = success)
;	R2,R3,R4,R5  Preserved
;
;--

ASSUME	SB$B_SYSTEMID+8	  EQ  SB$W_MAXDG
ASSUME	SB$W_MAXDG+2	  EQ  SB$W_MAXMSG
ASSUME	SB$W_MAXMSG+2	  EQ  SB$T_SWTYPE
ASSUME	SB$T_SWTYPE+4	  EQ  SB$T_SWVERS
ASSUME	SB$T_SWVERS+4	  EQ  SB$Q_SWINCARN
ASSUME	SB$Q_SWINCARN+8	  EQ  SB$T_HWTYPE
ASSUME	SB$T_HWTYPE+4	  EQ  SB$B_HWVERS
ASSUME	SB$B_HWVERS+12	  EQ  SB$T_NODENAME
ASSUME	SB$T_NODENAME+16  EQ  SB$L_DDB

ASSUME	SBO$B_SYSTEMID+8  EQ  SBO$W_MAXDG
ASSUME	SBO$W_MAXDG+2	  EQ  SBO$W_MAXMSG
ASSUME	SBO$W_MAXMSG+2	  EQ  SBO$T_SWTYPE
ASSUME	SBO$T_SWTYPE+4	  EQ  SBO$T_SWVERS
ASSUME	SBO$T_SWVERS+4	  EQ  SBO$Q_SWINCARN
ASSUME	SBO$Q_SWINCARN+8  EQ  SBO$T_HWTYPE
ASSUME	SBO$T_HWTYPE+4	  EQ  SBO$B_HWVERS
ASSUME	SBO$B_HWVERS+12	  EQ  SBO$T_NODENAME
ASSUME	SBO$T_NODENAME+16 EQ  SBO$B_RSTATION1
ASSUME	SBO$B_RSTATION1+8  EQ  SBO$T_LPORT1
ASSUME	SBO$T_LPORT1+4	  EQ  SBO$B_NXT_SYSID

SB_COPY_LEN = SB$T_NODENAME+16 - SB$B_SYSTEMID

SCS$CONFIG_SYS:
	PUSHR	#^M<R2,R3>		; Save reg. and output buffer ptr.
	MOVAL	@#SCS$GQ_CONFIG, R0	; Pick up pointer to database
	MOVL	R0, R2			; Hold starting point
10$:	MOVL	(R0), R0		; Get next block in list
	CMPL	R0, R2			; Back where we started (empty) ?
	BEQL	60$			; Yes, leave now
	TSTL	(R1)			; Is this possibly the magic 0 value?
	BNEQ	20$			; No, continue
	TSTW	4(R1)			; Yes, try the high 16 bits
	BEQL	30$			; Yes, it is 0 - just get the first one
20$:	CMPL	(R1), SB$B_SYSTEMID(R0)	; Nonzero value - check for a match
	BNEQ	10$			; No match - try again
	CMPW	4(R1), SB$B_SYSTEMID+4(R0) ; Lo 32 bits match - try high 16 bit
	BNEQ	10$			; No match - try again
;
; Found a matching system block - transfer the information
;
30$:	MOVL	(SP),R3			; Recover pointer to output array
	BEQL	50$			; None, don't bother to transfer
	PUSHR	#^M<R0,R2,R4,R5>	; Save registers destroyed in MOVC
	MOVC3	#SB_COPY_LEN,-		; Copy data from SYSTEMID in SB
		SB$B_SYSTEMID(R0),(R3)	;  through nodename to output array
	POPR	#^M<R0,R2,R4,R5>	; Restore registers
	MNEGL	#1,(R3)+		; Set 1st station addr to -1
	MNEGL	#1,(R3)+		;  in case there is no path on SB
	CLRL	(R3)+			; Zero local port name of first path
	MOVL	SB$L_PBFL(R0), R1	; Get 1st path block
	BEQL	40$			; None there
	CMPL	R1, (R1)		; Is there really one?
	BEQL	40$			; No, skip on
	MOVQ	PB$B_RSTATION(R1), -12(R3) ; Yes, move in station id
	CLRW	-6(R3)			; Clear out reserved word
	MOVL	PB$T_LPORT_NAME(R1),-4(R3) ; Move in local port name
40$:	CLRQ	(R3)			; Clear out next system id
	MOVL	SB$L_FLINK(R0), R1	; Get next system block
	CMPL	R1, R2			; Is there really one?
	BEQL	50$			; No, skip on
	MOVQ	SB$B_SYSTEMID(R1), (R3)	; Yes, move in system id
	CLRW	6(R3)			; Clear out reserved word
50$:	MOVL	R0, R1			; Recover system block address
	MOVL	#1, R0			; Set success
	BRB	70$

60$:	MOVZWL	#SS$_NOSUCHNODE, R0	; Set failure
70$:	MOVQ	(SP)+, R2		; Clean stack
	RSB
	.page
	.SBTTL	SCS$CONNECT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$CONNECT
;
; INPUTS:
;
;	 0(SP) = Input address				MSGADR
;	 4(SP) = [Datagram input address]		DGADR
;	 8(SP) = Error address				ERRADR
;	12(SP) = Address of remote system ID		RSYSID
;	16(SP) = [Address of remote station addr]	RSTADR
;	20(SP) = Address of remote process name		RPRNAM
;	24(SP) = Address of local process name		LPRNAM
;	28(SP) = Initial credit value			INITCR
;	30(SP) = Minimum send credit value		MINSCR
;	32(SP) = [Initial datagram credit value]	INITDG
;	34(SP) = [Block transfer priority]		BLKPRI
;	36(SP) = [Address of connect data]		CONDAT
;	40(SP) = [Address of auxilary structure]	AUXSTR
;	44(SP) = [Bad response packet address]		BADRSP
;	48(SP) = Return address
;
; OUTPUTS:
;
;	R0 = Status
;	R3 = Address of CDT allocated if success
;	   = 0 if error status
;	R4 = Address of PDT for this station address
;	R1,R2 Destroyed
;	R5  Preserved
;
;	CDT fields filled in
;
;--

	.ENABLE lsb
SCS$CONNECT:
	BSBW	SCS$ALLOC_CDT		; Allocate a CDT
	BLBS	R0, 5$			; Okay
	BRW	140$			; None, clean up and leave
	ASSUME	CDT$L_MSGINPUT+4 EQ CDT$L_DGINPUT
5$:	MOVQ	(SP)+,CDT$L_MSGINPUT(R3); Get both MSGINPUT and DGINPUT
	POPL	CDT$L_ERRADDR(R3)	; Set address of error routine
;
; Check if remote station/local port specified.  If so, go connect over
;  that vc.
;
	TSTL	4(SP)			; RSTADR specified?
	BNEQ	70$			; Branch if so
;
; Now obtain the remote system id and use it to search the system
;  blocks for the correct one.  If found, return the PDT for the next 
;  path block and update that field.
;
	POPL	R1			; Pick up addr of rem system id
	CLRL	R2			; Don't want any info block
	BSBW	SCS$CONFIG_SYS		; Get the pointer to system block
	BLBS	R0, 10$			; Found it, continue
	TSTL	(SP)+			; Get rid of rem station addr
	BRB	90$			; Clean up stack and leave
;
; From the system block pick up the path block. 
;
10$:	TSTL	(SP)+			; Remove RSTADR parameter
	MOVL	SB$L_PBCONNX(R1), R4	; Get the next path block to use
	BEQL	35$			; Branch if no PB's available
	MOVAL	SB$L_PBFL(R1), R0	; Hold path block list head
	MOVL	R4, R2			; Save original pointer
20$:	CMPW	PB$W_STATE(R4),#PB$C_OPEN ; Is it good?
	BEQL	50$			; Yes
30$:	MOVL	PB$L_FLINK(R4), R4	; No, try next block
	CMPL	R4, R2			; Back to start?
	BNEQ	40$			; No, try another
35$:	MOVZWL	#SS$_UNREACHABLE, R0	; Yes, no good path
	BRB	90$			; Error out

40$:	CMPL	R4, R0			; Is it list head? (system block)
	BEQL	30$			; Yes, get another block
	BRB	20$			; No, try it

50$:	MOVL	PB$L_FLINK(R4), R2	; Try to find the next next block
	CMPL	R2, R0			; Is it list head?
	BNEQ	60$			; No, use it
	MOVL	PB$L_FLINK(R2), R2	; Yes, get the first in list
60$:	MOVL	R2, SB$L_PBCONNX(R1)	; Update next path block entry
	BRB	100$
;
; Remote station/local port specified, get the exact path.  Check to see 
; that it is open.
;
70$:	TSTL	(SP)+			; Clear remote system ID parameter
	POPL	R1			; Get addr of remote sta/local port
	CLRL	R2			; No info to move
	BSBW	SCS$CONFIG_PTH		; Find it
	MOVL	R1, R4			; Transfer to correct register	
	BLBC	R0, 90$			; Error, leave
80$:	CMPW	PB$W_STATE(R4),#PB$C_OPEN ; Is it good?
	BEQL	100$			; Yes
	MOVZWL	#SS$_UNREACHABLE, R0	; No, no good path
90$:	BSBW	SCS$DEALL_CDT1		; Bad id, get rid of the CDT
	ADDL	#<2*4>, SP		; Get rid of process names
	BRB	150$			; Leave

100$:	MOVL	PB$B_RSTATION(R4), -	; Move in 32 bits of Remote Sta Id
		CDT$B_RSTATION(R3)	;    into the CDT
	MOVW	PB$B_RSTATION+4(R4), -	; Another 16 bits
		CDT$B_RSTATION+4(R3)
	MOVL	R4, CDT$L_PB(R3)	; Store the pointer to Path Block
	MOVL	PB$L_PDT(R4), R4	; Recover PDT entry
	MOVL	R4, CDT$L_PDT(R3)	; Store the PDT
	MOVZBL	#PDT$L_CONNECT, R1	; Offset in PDT to jump to
	ASSUME	CDT$L_RPROCNAM+4 EQ CDT$L_LPROCNAM
	MOVQ	(SP)+,CDT$L_RPROCNAM(R3); Get both local & remote process names
;
; Now take care of the credit fields
;
	ASSUME	CDT$W_MINSEND EQ CDT$W_INITLREC+2
	ASSUME	CDT$W_DGREC EQ CDT$W_MINSEND+2
	ASSUME	CDT$B_PRIORITY EQ CDT$W_DGREC+2
PDT_JMP:MOVQ	(SP)+,CDT$W_INITLREC(R3); Pick up initial rec, min send, dgrec,pro
	POPL	CDT$L_CONDAT(R3)	; Transfer connection data
	BNEQ	110$			; Something there
	MOVAB	B^BLANK,CDT$L_CONDAT(R3); Else give 'em blanks
	ASSUME	CDT$L_AUXSTRUC+4 EQ CDT$L_BADRSP
110$:	MOVQ	(SP)+,CDT$L_AUXSTRUC(R3); Pick up aux struc addr & bad resp addr
	ADDL2	R4,R1			; Pick up address from PDT
	JMP	@(R1)+			; Finish in port dependent code

140$:	ADDL	#7*4, SP		; Clean args off stack
150$:	ADDL	#5*4, SP
	RSB

BLANK:	.ASCII/                /
	.DISABLE lsb
	.page
	.SBTTL	SCS$DEALL_CDT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$DEALL_CDT
;
; INPUTS:
;
;	R3 = Pointer to CDT
;
; OUTPUTS:
;
;	R1 trashed
;	R3 cleared
;	R0,R2,R4,R5  preserved
;
; COMPLETION CODES:
;
;	NONE (always succedes)
;
;--

SCS$DEALL_CDT:				; Unlink from PB first
	PUSHL	R2			; Save a register
	MOVL	CDT$L_PB(R3), R1	; Pick up Path block
	MOVAL	PB$L_CDTLST-CDT$L_CDTLST(R1), R1 ; Point to head of list
10$:	MOVL	CDT$L_CDTLST(R1), R2	; Get next block
	BEQL	30$			; There is none	
	CMPL	R2, R3			; Are we next block?
	BEQL	20$			; Yes
	MOVL	R2, R1			; No, shift pointer
	BRB	10$			; And try again

20$:	MOVL	CDT$L_CDTLST(R3), -
		CDT$L_CDTLST(R1)	; Put our next link in last block
	CLRL	CDT$L_CDTLST(R3)	; Clear out link
30$:	POPL	R2			; Restore a register

SCS$DEALL_CDT1:				; Deallocate w/o unlinking
	MOVL	@#SCS$GL_CDL, R1	; Pick up list head
	MOVL	CDL$L_FREECDT(R1), -
		CDT$L_LINK(R3)		; Insert in chain
	MOVL	R3, CDL$L_FREECDT(R1)	; Set this block as first free
10$:	INCW	CDT$L_LCONID+2(R3)	; Bump sequence number
	BEQL	10$			; Zero not allowed
	ASSUME	CDT$W_STATE+2 EQ CDT$W_BLKSTATE
	CLRL	CDT$W_STATE(R3)		; Set to CLOSED
	CLRL	R3			; Eliminate any chance of spurious CDT
	RSB
	.page
	.SBTTL	SCS$DEALL_RSPID - Dellocate a response id
	.SBTTL	SCS$RECYL_RSPID - Recycle a response id
;++
;
; SCS$DEALL_RSPID - Dellocate a response id
; SCS$RECYL_RSPID - Recycle a response id
;
; Functional description:
;
;	Check validity of the value in the CDRP$L_RSPID field. Increment
;	the RDTE sequence number.
;
;	For deallocate a response id (SCS$DEALL_RSPID):
;
;		Dequeue next waiter for an RDTE and start him up.  If no 
;		waiter to dequeue, set the RDTE state to unallocated, link 
;		RDTE as first entry in the free list, and return
;
;	For recycle a response id (SCS$RECYL_RSPID):
;
;		Update response id in CDRP and return.
;
; Calling sequence:
;
;	BSBW	SCS$DEALL_RSPID
;	BSBW	SCS$RECYL_RSPID
;
; Inputs:
;
;	R5 --> CDRP
;	SCS$GL_RDT
;
; Outputs:
;
;	R0,R1,R2  Destroyed; R3,R4,R5  Preserved -- SCS$DEALL_RSPID
;	R0,R1  Destroyed; R2,R3,R4,R5  Preserved -- SCS$RECYL_RSPID
;
;--

SCS$RECYL_RSPID:
	CLRL	-(SP)			; Put SCS$RECYL_RSPID flag on stack.

SCS$DEALL_RSPID:

	PUSHL	R5			; Save CDRP address.
	MOVL	CDRP$L_RSPID(R5), R5	; Get RSPID (if any).
	BEQL	90$			; No RSPID, then bugcheck.
	BSBW	SCS$FIND_RDTE		; Locate RDTE for the RSPID.
	BLBC	R0, 90$			; Branch if error in RSPID.
	MOVL	R5, R0			; Save RDTE address.
5$:	INCW	RD$W_SEQNUM(R0)		; Bump RDTE sequence number.
	BEQL	5$			; Zero sequence number not allowed.
	TSTL	4(SP)			; Was this a SCS$RECYL_RSPID call?
	BEQL	50$			; Branch if recycling a response id.
	REMQUE	@RDT$L_WAITFL(R1), R5	; Grab any process waiting on RSPIDs.
	BVS	10$			; Branch if no processes waiting.
;
; There is a stalled process waiting for a RSPID, resume it.
;
	MOVQ	R3, -(SP)		; Save context registers.
	SUBL3	R1, R0, R2		; Get RDTE offset from RDT base.
	ASSUME	RD$C_LENGTH EQ 8
	ASHL	#13, R2, R2		; Form index in high order R2.
	MOVW	RD$W_SEQNUM(R0), R2	; Insert sequence number.
	ROTL	#16, R2, CDRP$L_RSPID(R5) ; Form final RSPID and store in CDRP.
	MOVL	R5, RD$L_CDRP(R0)	; Store his CDRP in the RDTE.
	BSBW	SCS$RESUMEWAITR		; Resume the waiter
	MOVQ	(SP)+, R3		; Restore saved registers.
	BRB	20$			; Join common completion path.

10$:	CLRW	RD$W_STATE(R0)		; Set state as free.
	MOVL	RDT$L_FREERD(R1), -
		RD$L_LINK(R0)		; Insert RDTE in free RDTE chain.
	MOVL	R0, RDT$L_FREERD(R1)	; Make it the first free entry.
20$:	POPL	R5			; Restore CDRP address.
	CLRL	CDRP$L_RSPID(R5)	; Clear out RSPID.
	RSB				; Return from SCS$DEALL_RSPID.


90$:	BUG_CHECK  INVRSPID,FATAL	; "Invalid RSPID" bugcheck.


					; Complete SCS$RECYL_RSPID call.
50$:	POPL	R5			; Restore CDRP address.
	MOVW	RD$W_SEQNUM(R0), -	; Copy new sequence number to
		CDRP$L_RSPID+2(R5)	; CDRP.
	TSTL	(SP)+			; Pop SCS$RECYL_RSPID call flag.
	RSB				; Return from SCS$RECYL_RSPID.
	.page
	.SBTTL	SCS$DIRECTORY
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$DIRECTORY
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

SCS$DIRECTORY:
	ACCEPT	MSGADR=B^30$,-
		ERRADR=W^DIRERR,-	; If error, disconnect.
		INITCR=#1		; We'll accept anything
	BLBC	R0,10$			; If error, reject
	RSB

10$:	MOVL	R2,R3			; Copy of listening CDT address
	REJECT
	RSB
	
30$:	MOVAB	4(R2), R1		; Pick up procname
	MOVQ	R2,-(SP)		; Save address of message and CDT
	BSBW	SCS$LOCLOOKUP		; Look it up
	MOVW	R0, (R2)		; Set status
	BLBC	R0,35$			; If LBC, unsuccessful lookup
	MOVAB	<16+4>(R2), R2		; Set to info
	MOVQ	SDIR$B_PROCINF(R1),(R2)+    ; Transfer first 8 bytes
	MOVQ	<SDIR$B_PROCINF+8>(R1),(R2) ; ... and sec 8
35$:	MOVZWL	#CDRP$C_LENGTH, R1	; Size of block needed
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0,40$			; Branch if no pool available
	MOVL	R2, R5			; Transfer address
	MOVQ	(SP)+, R2		; Restore registers
	MOVW	R1, CDRP$W_CDRPSIZE(R5)	; Set up block
	MOVZBW	#DYN$C_CDRP, -
		CDRP$B_CD_TYPE(R5)	; Set type
	CLRL	CDRP$L_SAVD_RTN(R5)	; Just to be safe
	MOVL	R2, CDRP$L_MSG_BUF(R5)	; Set address of buffer
	CLRL	CDRP$L_RSPID(R5)	; Indicate we are turning around
	MOVL	R3, CDRP$L_CDT(R5)	; Set in pointer
	CLRL	CDRP$L_RWCPTR(R5)	; Just to be safe
	RECYCL_MSG_BUF			; We are going to recycle the buffer
	MOVZBL	#36,R1			; Maximum size of message 
	SEND_CNT_MSG_BUF		; Send message and term thread
	MOVL	R5, R0			; Set pointer to head of block
	BRW	SCS_DEALNONPAGD		; Get rid of the block

;
;  We come here if we could not allocate pool for the CDRP
;
40$:	MOVQ	(SP)+,R2		; Pop stack
	DEALLOC_MSG_BUF_REG		; Deallocate message buf
	DISCONNECT
	RSB

;
;  Clean up if there is an error while responding to a directory message
;
;  On entry:
;	R0 	- error status
;	R3	- address of CDT
;	R4	- address of PDT
;
DIRERR:
	SCAN_MSGBUF_WAIT -		; Find CDRP'S 
	  	ACTION = DIR_CLEANUP
	DISCONNECT			; Break connection
	RSB

;
;  For each CDRP which is found, remove it from queue, if needed, deallocate
;  associated message buffer, if any, and return CDRP to pool.
;
;  On entry:
;	R3	- address of CDT
;	R4	- address of PDT
;	R5	- address of CDRP
;
DIR_CLEANUP:

;
;  Remove CDRP from queue, if needed
;
	PUSHL	R2
	TSTL	CDRP$L_FQBL(R5)		; Is there a queue pointer?
	BEQL	5$			; If EQL, none
	CMPL	@CDRP$L_FQBL(R5),R5	; Is CDRP in a queue?
	BNEQ	5$			; If NEQ, no
	REMQUE	(R5),R5			; Dequeue CDRP
	MOVL	CDRP$L_RWCPTR(R5),R2	; Get wait count pointer
	BEQL	5$			; Branch if none
	DECW	(R2)			; Adjust

;
;  Deallocate associated message buffer, if any
;
5$:	POPL	R2			; Restore reg
	TSTL	CDRP$L_MSG_BUF(R5)	; Do we have any message buffers?
	BEQL	10$			; If EQL, no
	DEALLOC_MSG_BUF			; Get rid of it

;
;  Return CDRP to non-paged pool
;
10$:	MOVL	R5,R0			; Address of CDRP in R0
	JSB	G^COM$DRVDEALMEM	; Give back to pool
	RSB				; Cleanup done

;
;  Clean up for errors on the listen
;
LISTENERR:
	DISCONNECT			; Nothing to clean up -- disconnect
	RSB				; Return from error routine.

	.page
	.SBTTL	SCS$DISCONNECT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; INPUTS:
;
;	R3 -->	CDT
;	R4 -->	PDT
;
; IMPLICIT INPUTS:
;
;	CDT$W_STATE
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	If state was LISTEN, then directory entry removed and CDT deallocated.
;
;--

SCS$DISCONNECT:
	ASSUME	CDT$C_CLOSED EQ 0
	TSTW	CDT$W_STATE(R3)		; Is state CLOSED?
	BNEQ	10$			; No
	MOVZWL	#SS$_ALRDYCLOSED,R0	; Yes, issue qualified success
	RSB

10$:	CMPW	CDT$W_STATE(R3), - 	; Is state LISTEN?
		#CDT$C_LISTEN
	BNEQ	20$			; No
	BRW	SCS$REMOVE		; Yes, remove the entry and exit

20$:	MOVL	CDT$L_PDT(R3),R4	; Pick up the PDT address
	JMP	@PDT$L_DCONNECT(R4)	; Let port driver handle other states
	.page
	.SBTTL	SCS$ENTER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ENTER
;
; INPUTS:
;
;	R0 = Address of process name (16 byte string)
;	R1 = Address of process info (16 byte string)
;	R2 = CONID
;
;	SCS$GQ_DIRECT
;
; OUTPUTS:
;
;	R0 = SS$_INSFMEM if no pool for directory block
;	   = SS$_NORMAL if success
;	R1,R2  destroyed
;	R3,R4,R5  preserved
;
; SIDE EFFECTS:
;
;	NONE
;
;--

SCS$ENTER:
	PUSHR	#^M<R0,R1,R2,R3>	; Save registers and arguments.
	MOVL	#SDIR$C_LENGTH, R1	; Size of a directory entry
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0, 40$			; None, error out
	MOVAB	SDIR$W_SIZE(R2), R3	; Set pointer to size field
	MOVW	R1, (R3)+		; Set size field
	MOVW	#DYN$C_SCS!<DYN$C_SCS_DIR@8>, (R3)+ ; Size type and subtype
	POPL	R1			; Get pointer to process name
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVQ	(R1), (R3)+		; Move 8 bytes
	POPL	R1			; Get pointer to process info
	BEQL	10$			; None present
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVQ	(R1), (R3)+		; Move 8 bytes
	BRB	20$

10$:	CLRQ	(R3)+			; Clear it out
	CLRQ	(R3)+			; Ditto
20$:	POPL	(R3)			; Set in CONID
	MOVL	@#SCS$GQ_DIRECT+4, R3	; End of queue
	INSQUE	(R2), (R3)		; Insert at end
30$:	POPL	R3			; Restore register
	RSB

40$:	ADDL	#3*4, SP		; Clean up stack
	BRB	30$			; ... and out
	.PAGE
	.SBTTL	SCS$FIND_RDTE - Find RDTE for RSPID
;++
;
; SCS$FIND_RDTE - Find the RDTE for a given RSPID
;
; Functional description:
;
;	The RDT ID index is extracted from the given response id, RSPID, and 
;	validated.  The index is then used to locate the RDTE in the RDT.  A 
;	sequence number check is then performed and a check is made to insure 
;	that the RDTE is busy.
;
; Inputs:
;
;	R5	a response id, RSPID
;
;	IPL	IPL$_SCS
;
; Outputs:
;
;	R0	1 ==> Lookup successful
;		0 ==> invalid response ID
;	R1	RDT base address (This is not advertized to SYSAPs but is
;				 required by SCS$DEALL_RSPID.)
;	R2-R4	preserved
;	R5	RDTE address (if R0 = 1)
;-

SCS$FIND_RDTE:

	MOVL	@#SCS$GL_RDT, R1	; Get base address of RDT.
	MOVZWL	R5, R0			; Get RDT index from RSPID.
	CMPL	R0, RDT$L_MAXRDIDX(R1)	; Is index too big?
	BGTRU	90$			; Branch if too big.
	ASSUME	RD$C_LENGTH EQ 8
	PUSHAQ	(R1)[R0]		; Get pointer to RDTE.
	ROTL	#16, R5, R0		; Get response id sequence number.
	POPL	R5			; Prepair to return RDTE pointer.
	CMPW	RD$W_SEQNUM(R5), R0	; Do the sequence numbers match?
	BNEQ	90$			; Branch if no match.
	ASSUME	RD$V_BUSY EQ 0
	BLBC	RD$W_STATE(R5), 90$	; Branch if RDTE is not busy.
	MOVL	#1, R0			; Set success status.
	RSB				; Return to caller.

90$:	CLRL	R0			; Set error status.
	RSB				; Return to caller.
	.page
	.SBTTL	SCS$LISTEN
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$LISTEN
;
; INPUTS:
;
;	00(SP) = Address to call with CONNECT_REQ msg		MSGADR
;	04(SP) = Address to call with error in VC		ERRADR
;	08(SP) = Address of listening process name		LPRNAM
;	0C(SP) = Address of listening process information	PRINFO
;	10(SP) = Return address
;
; OUTPUTS:
;
;	R0 = SS$_INSFCDT if could not allocate CDT
;	   = SS$_INSFMEM if could not allocate pool for directory entry
;	   = SS$_NORMAL if success
;	R1,R2 destroyed
;	R3 = Pointer to CDT if success
;	   = 0 if failure
;	R4,R5 preserved
;
;	CDT$L_INPUT	Address to call process with CONNECT_REQ msgs
;	CDT$L_LCONID	Local connection id for CDT in R3
;	CDT$W_STATE	LISTENING
;
; SIDE EFFECTS:
;
;	Directory entry made if successful, CDT state set to LISTEN
;
;--

SCS$LISTEN:
	BSBW	SCS$ALLOC_CDT		; Grab a CDT
	BLBC	R0, 10$			; None, error out
	MOVL	R1, R2			; Shift CONID around
	POPL	CDT$L_MSGINPUT(R3)	; Fill in with address
	POPL	CDT$L_ERRADDR(R3)	; Ditto for errors
	MOVQ	(SP)+, R0		; Pick up arguments
	BSBW	SCS$ENTER		; Make a directory entry
	BLBC	R0, 20$			; None, error out
	MOVW	#CDT$C_LISTEN, -	; Set state to LISTENing
		CDT$W_STATE(R3)
	RSB

10$:	ADDL	#4*4, SP		; Clean up arguments
	RSB

20$:	BSBW	SCS$DEALL_CDT1		; Get rid of the CDT
	ADDL	#3*4, SP		; Clean up arguments
	RSB
	.page
	.SBTTL	SCS$LOCLOOKUP
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; INPUTS:
;
;	R1 = Addr of local process name to look up
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHOBJ if listener could not be found
;	   = SS$_NORMAL if listener found
;	R1 = Addr of entry if found
;	R2 = Preserved
;	R3 = Addr of listening CDT for local process, if success
;	   = 0 if failure
;	R4,R5 Preserved
;
;--

SCS$LOCLOOKUP:
	PUSHL	R5			; Save a register
	MOVL	R1, R5			; Copy addr of proc name
	PUSHL	R4			; Save another reg
	PUSHL	R2			; ... and another
	MOVAL	@#SCS$GQ_DIRECT, R4	; Get head of directory list
	PUSHL	R4			; Save a copy
10$:	MOVL	(R4), R4		; Next entry
	CMPL	R4, (SP)		; End of the line?
	BEQL	30$			; Yes, leave - not found
	CMPC3	#16, (R5), -
		SDIR$B_PROCNAM(R4)	; Names match?
	BNEQ	10$			; No, try again
	MOVL	SDIR$L_CONID(R4), R5	; Yes, pick up CONID
	BEQL	30$			; Zero is error
	MOVZWL	R5, R2			; Isolate index
	MOVL	@#SCS$GL_CDL, R3	; Pick up pointer to CDL
	MOVL	(R3)[R2], R3		; Obtain pointer to selected CDT
	CMPL	R5, CDT$L_LCONID(R3)	; CONID's match?
	BNEQ	30$			; No, failure
	MOVL	#1, R0			; Yes, success
	MOVL	R4, R1			; Return pointer to entry
20$:	TSTL	(SP)+			; Get rid of temp
	POPL	R2			; Recover R2
	MOVQ	(SP)+,R4		; Restore registers
	RSB

30$:	MOVZWL	#SS$_NOSUCHOBJ, R0	; Could not find listener *** TEMP ****
	CLRL	R3			; No chance of spurious CDT
	BRB	20$			;  and out
	.page
	.SBTTL	SCS$REMOVE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$REMOVE
;
; INPUTS:
;
;	R3 = CDT address
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHOBJ if could not find entry
;	   = SS$_NORMAL if successful
;	R1,R2 destroyed
;	R3 = 0 if successful
;	   = CDT if failure
;	R4,R5 preserved
;
; SIDE EFFECTS:
;
;	Directory entry removed from directory.
;
;--

SCS$REMOVE:
	MOVZWL	#SS$_NOSUCHOBJ, R0	; Assume failure
	MOVAL	@#SCS$GQ_DIRECT, R2	; Get pointer to directory head
	MOVL	R2, R1			; Copy
10$:	MOVL	(R2), R2		; Get next entry
	CMPL	R1, R2			; End of the line?
	BEQL	20$			; Yes, leave can't find entry
	CMPL	CDT$L_LCONID(R3), -
		SDIR$L_CONID(R2)	; Match CONID?
	BNEQ	10$			; No, try next one
	REMQUE	(R2), R0		; Yes, remove it
	PUSHL	R3			; Save CDT addr
	BSBW	SCS_DEALNONPAGD		; Release the pool space
	POPL	R3			; Restore CDT
	MOVL	#1, R0			; Set for success
	BRW	SCS$DEALL_CDT1		; Get rid of CDT and return

20$:	RSB				; Leave
.page
;
; Misc routines
;

SCS_ALONONPAGED:
	JSB	@#EXE$ALONONPAGED	; Allocate the pool
	BLBS	R0, 10$			; Skip out if success
	MOVZWL	#SS$_INSFMEM, R0	; Set a reconizible error code
10$:	RSB				; Leave

SCS_DEALNONPAGD:
	JMP	@#COM$DRVDEALMEM	; Deallocated
	.page
	.SBTTL	SCS$RESUMEWAITR
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Global SCS routine to resume a thread that had been
;	waiting on a resource wait queue.  This routine resumes the thread
;	and upon return from the thread, if the CDRP associated with the
;	resumed thread had a RWAITCNT, then we attempt to start any stalled
;	IRP's that may have been queued to the UCB while we were waiting.
;
; INPUTS:
;
;	R5 => CDRP of thread to resume
;
; OUTPUTS:
;
;	Thread resumed and IRP's started up when appropriate.
;
;	Note all registers R0 - R5 may be modified.
;
;--

SCS$RESUMEWAITR:			; Here we will start driver thread that
					;  was waiting for resource.

;
; We divide the CDRP thread to be restarted into two classes:  Those which
;	do NOT have a RWAITCNT and those which do.  The code path for those
;	without is very simple and appears directly below.  The more complex
;	case of CDRP's with a RWAITCNT begins at label THREAD_HAS_RWAITCNT.
;

	MOVL	CDRP$L_RWCPTR(R5),R3	; R3 => UCB$L_RWAITCNT or R3 = 0.
	BNEQ	THREAD_HAS_RWAITCNT	; NEQ implies R3 => UCB$L_RWAITCNT.
	MOVQ	CDRP$L_FR3(R5),R3	; Restore register context to thread.
	JSB	@CDRP$L_FPC(R5)		; Call back driver thread.
	RSB				; Return to caller.

THREAD_HAS_RWAITCNT:			; Here we have R3 =>  UCB$L_RWAITCNT.
	DECW	(R3)			; One less CDRP waiting for resources.
	PUSHL	CDRP$L_UCB(R5)		; Save this CDRP'S UCB address on stack.
	MOVQ	CDRP$L_FR3(R5),R3	; Restore context of waiting IRP.
	JSB	@CDRP$L_FPC(R5)		; Call back driver thread.
	POPL	R5			; R5 => UCB.

;
; Here we have experienced return from a resumed thread that maintains a
;	UCB$W_RWAITCNT.  Now we see if we can start up any IRP's that may have
;	backed on this UCB.  These would be new IRP's that had not yet gotten
;	into STARTIO.
;
; NOTE - This entrypoint SCS$UNSTALLUCB may be called independently to
;	unstall UCB's that may have had non-zero RWAITCNT's for other
;	reasons.
;

SCS$UNSTALLUCB:
10$:	TSTW	UCB$W_RWAITCNT(R5)	; Can we startup backed up IRP's?
	BNEQ	20$			; NEQ implies NO, so branch around.
	REMQUE	@UCB$L_IOQFL(R5),R3	; Remove 1st (if any) IRP from queue.
	BVS	20$			; VS implies no backed up IRP's.
	PUSHL	R5			; Remember UCB address on stack.
	BICW	#UCB$M_CANCEL!-
		 UCB$M_TIMOUT,-
		UCB$W_STS(R5)		; Clear cancel and time out

	ASSUME	DDT$L_START	EQ	0
	MOVL	@UCB$L_DDT(R5),R1	; R1 => Start_io routine.
	JSB	(R1)			;START I/O OPERATION
	POPL	R5			; Restore R5 => UCB of interest.
	BRB	10$			; Loop back to start more backed up IRP's.

20$:	RSB
	.PAGE
	.SBTTL	SCS$LKP_RDTCDRP

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Search RDT for CDRPs with CDT address matching the one in R3
;	upon entry.  For each CDRP found, call user-supplied action 
;	routine.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$LKP_RDTCDRP
;
; INPUTS:
;
;	R0 -->  Addr of action routine
;	R3 -->	Addr of CDT
;
; OUTPUTS:
;
;	R0 -->	status code
;		success ==> RDT contains no CDRPs with matching CDT
;		failure ==> RDT contains one or more CDRPs with matching CDT
;	R1	not altered or preserved by this routine; may be used as a 
;		communication mechanism between action routine and caller of 
;		this routine
;	R2 - R5	preserved
;
; ACTION ROUTINE INPUTS:
;
;	R1 -->	unchanged from value set by this routine's caller
;	R3 -->	Addr of CDT
;	R4 -->	unchanged from value set by this routine's caller
;	R5 -->	Addr of CDRP
;
; ACTION ROUTINE OUTPUTS:
;
;	R0	scratch
;	R1	value to be returned to this routine's caller
;	R2	scratch
;	R3	Addr of CDT; MUST be preserved
;	R4 - R5	scratch
;
;	N.B. More likely than not R4 is a PDT address which also must be
;	preserved.  However, this routine makes no such assumption.
;
; STACK USAGE:
;
;	This routine manipulates the stack in a rather odd mannor.  Therefore, 
;	the following map of the stack, as it is at the time of the JSB to the 
;	action routine, is provided to describe how the stack is used.
;
;	!---------------------------------------------------------------!
;	!			Saved index R0				! :(SP)
;	!---------------------------------------------------------------!
;	!		      Saved list base R2			!
;	!---------------------------------------------------------------!
;	! r0		    Action routine address			!
;	!---------------------------------------------------------------!
;	! r1		       "found-one" flag			     R0 !
;	!---------------------------------------------------------------!
;	! r2			Saved register 2		     R2 !
;	!---------------------------------------------------------------!
;	! r4			Saved register 4		     R4 !
;	!---------------------------------------------------------------!
;	! r5			Saved register 5		     R5 !
;	!---------------------------------------------------------------!
;	  ^							      ^
;	  |-as saved by PUSHR			  as restored by POPR-|
;
;--

SCS$LKP_RDTCDRP:
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save registers, make place for saved
	MOVL	#1, 4(SP)		; "found-one" flag, & init. none found.
	MOVZWL	@#SCS$GW_RDTCNT, R0	; Pick up number of entries.
	MOVL	@#SCS$GL_RDT, R2	; Pick up pointer to list.
	PUSHL	R2			; Save that on the stack.
	ASSUME	RD$C_LENGTH EQ 8
10$:	MOVAQ	B^-8(R2)[R0], R5	; Pick up next entry.
	TSTW	RD$W_STATE(R5)		; Is it in use?
	BEQL	20$			; No, try another.
	MOVL	RD$L_CDRP(R5), R5	; Pick up CDRP pointer.
	BEQL	20$			; None, try another.
	CMPL	CDRP$L_CDT(R5), R3	; CDT's match?
	BNEQ	20$			; No, try some other.
	CLRL	8(SP)			; Raise "found-one" flag.
	PUSHL	R0			; Save list index.
	JSB	@8(SP)			; Call action routine.
	POPL	R0			; Restore list index.
	MOVL	(SP), R2		; Restore list base address.
20$:	SOBGTR	R0, 10$			; Loop until done.
	MOVAB	8(SP), SP		; Cleanup the stack.
	POPR	#^M<R0,R2,R4,R5>	; Restore saved "found-one" flag and
	RSB				; other preserved registers.
	.page
	.SBTTL	SCS$LKP_RDTWAIT

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Search RSPID wait queue for next CDRP with CDRP$L_CDT that 
;	matches CDT specified in R3.  For each CDRP found, call user-
;	supplied action routine.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$LKP_RDTWAIT
;
; INPUTS:
;
;	R0 -->  Addr of action routine
;	R3 -->	Addr of CDT
;
; OUTPUTS:
;
;	R0 -->	status code
;		success ==> RDT contains no CDRPs with matching CDT
;		failure ==> RDT contains one or more CDRPs with matching CDT
;	R1	not altered or preserved by this routine; may be used as a 
;		communication mechanism between action routine and caller of 
;		this routine
;	R2 - R5	preserved
;
; ACTION ROUTINE INPUTS:
;
;	R1 -->	unchanged from value set by this routine's caller
;	R3 -->	Addr of CDT
;	R4 -->	unchanged from value set by this routine's caller
;	R5 -->	Addr of CDRP
;
; ACTION ROUTINE OUTPUTS:
;
;	R0	scratch
;	R1	value to be returned to this routine's caller
;	R2	scratch
;	R3	Addr of CDT; MUST be preserved
;	R4 - R5	scratch
;
;	N.B. More likely than not R4 is a PDT address which also must be
;	preserved.  However, this routine makes no such assumption.
;
;   STACK USAGE:
;	This routine manipulates the stack in a rather odd mannor.  Therefore, 
;	the following map of the stack, as it is at the time of the JSB to the 
;	action routine, is provided to describe how the stack is used.
;
;	!---------------------------------------------------------------!
;	!		  Saved next entry address R5			! :(SP)
;	!---------------------------------------------------------------!
;	!		   Saved end of list address			!
;	!---------------------------------------------------------------!
;	! r0		    Action routine address			!
;	!---------------------------------------------------------------!
;	! r1		       "found-one" flag			     R0 !
;	!---------------------------------------------------------------!
;	! r2			Saved register 2		     R2 !
;	!---------------------------------------------------------------!
;	! r4			Saved register 4		     R4 !
;	!---------------------------------------------------------------!
;	! r5			Saved register 5		     R5 !
;	!---------------------------------------------------------------!
;	  ^							      ^
;	  |-as saved by PUSHR			  as restored by POPR-|
;
;--

SCS$LKP_RDTWAIT:
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save registers, make place for saved
	MOVL	#1, 4(SP)		; "found-one" flag, & init. none found.
	MOVL	@#SCS$GL_RDT, R5	; Pick up pointer to list.
	MOVAL	RDT$L_WAITFL(R5), R5	; Point at wait queue head.
	PUSHL	R5			; Save end of queue information.
30$:	MOVL	(R5), R5		; Pick up next entry.
33$:	CMPL	R5, (SP)		; End of queue?
	BEQL	60$			; Yes, quit.
	CMPL	CDRP$L_CDT(R5), R3	; CDT's match?
	BNEQ	30$			; No, try again.
	CLRL	8(SP)			; Raise "found-one" flag.
	PUSHL	(R5)			; Save next entry address.
	JSB	@8(SP)			; Call action routine.
	POPL	R5			; Restore address of next entry.
	BRB	33$			; Since R5 already has the address
					; of the next entry, skip the queue
					; traversal step of this loop.
60$:	MOVAB	8(SP), SP		; Cleanup the stack.
	POPR	#^M<R0,R2,R4,R5>	; Restore saved "found-one" flag and
	RSB				; other preserved registers.
	.PAGE
	.SBTTL	SCS$LKP_MSGWAIT - Scan message wait queues

;++
;
; SCS$LKP_MSGWAIT - Scan message wait queues
;
; Functional description:
;
;	Search send credit wait and message buffer wait queues for CDRPs with 
;	CDRP$L_CDT that matches CDT specified in R3.  For each CDRP found, 
;	call user-supplied action routine.
;
;	This routine completely searches the message buffer wait queue before 
;	searching the send credit wait queue.  Both queues are searched front 
;	to back.  This is the reverse of the order in which the PADRIVER adds 
;	entries to these queues.  This searching stratagy has been choosen to 
;	maximize the possibility of locating CDRPs in the order in which the 
;	PADRIVER processed them.  This is very important to the connection 
;	manager which is trying to assure sequential delivery of specific 
;	message types to remote systems.  The lock manager, in turn, depends 
;	upon this sequential delivery promise.
;
;	DO NOT break this attempt at sequential location of CDRPs.  Do not 
;	change the ordering of queue insertion (in the PADRIVER or other port 
;	drivers used to maintain VAX-to-VAX connections) or the order of queue 
;	scanning here.
;
; Calling sequence:
;
;	JSB	SCS$LKP_MSGWAIT
;
; INPUTS:
;
;	R0 -->  Addr of action routine
;	R3 -->	Addr of CDT
;	R4 -->  Addr of PDT
;
; OUTPUTS:
;
;	R0 -->	status code
;		success ==> RDT contains no CDRPs with matching CDT
;		failure ==> RDT contains one or more CDRPs with matching CDT
;	R1	not altered or preserved by this routine; may be used as a 
;		communication mechanism between action routine and caller of 
;		this routine
;	R2 - R5	preserved
;
; ACTION ROUTINE INPUTS:
;
;	R1 -->	unchanged from value set by this routine's caller
;	R3 -->	Addr of CDT
;	R4 -->	unchanged from value set by this routine's caller
;	R5 -->	Addr of CDRP
;
; ACTION ROUTINE OUTPUTS:
;
;	R0	scratch
;	R1	value to be returned to this routine's caller
;	R2	scratch
;	R3	Addr of CDT; MUST be preserved
;	R4 - R5	scratch
;
;   STACK USAGE:
;	This routine manipulates the stack in a rather odd mannor.  Therefore, 
;	the following map of the stack, as it is at the time of the JSB to the 
;	action routine, is provided to describe how the stack is used.
;
;	!---------------------------------------------------------------!
;	!		  Saved next entry address R5			! :(SP)
;	!---------------------------------------------------------------!
;	!		   Saved end of list address			!
;	!---------------------------------------------------------------!
;	! r0		    Action routine address			!
;	!---------------------------------------------------------------!
;	! r1		       "found-one" flag			     R0 !
;	!---------------------------------------------------------------!
;	! r2			Saved register 2		     R2 !
;	!---------------------------------------------------------------!
;	! r4		     Saved register 4 (PDT)		     R4 !
;	!---------------------------------------------------------------!
;	! r5			Saved register 5		     R5 !
;	!---------------------------------------------------------------!
;	  ^							      ^
;	  |-as saved by PUSHR			  as restored by POPR-|
;
;--

SCS$LKP_MSGWAIT:
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save registers, make place for saved
	MOVL	#1, 4(SP)		; "found-one" flag, & init. none found.
	MOVAL	PDT$L_WAITQFL(R4), R5	; Point at msg. buf. wait queue header.
	PUSHL	R5			; Save end of queue information.
30$:	MOVL	(R5), R5		; Pick up next entry.
33$:	CMPL	R5, (SP)		; End of queue?
	BEQL	60$			; Yes, quit.
	CMPL	CDRP$L_CDT(R5), R3	; CDT's match?
	BNEQ	30$			; No, try again.
	CLRL	8(SP)			; Raise "found-one" flag.
	PUSHL	(R5)			; Save next entry address.
	JSB	@8(SP)			; Call action routine.
	POPL	R5			; Restore address of next entry.
	BRB	33$			; Since R5 already has the address
					; of the next entry, skip the queue
					; traversal step of this loop.
60$:	MOVAL	CDT$L_CRWAITQFL(R3), R5	; Point at send credit wait queue head.
	MOVL	R5, (SP)		; Save end of queue information.
80$:	MOVL	(R5), R5		; Pick up next entry.
83$:	CMPL	R5, (SP)		; End of queue?
	BEQL	100$			; Yes, quit.
	CMPL	CDRP$L_CDT(R5), R3	; CDT's match?
	BNEQ	80$			; No, try again.
	CLRL	8(SP)			; Raise "found-one" flag.
	PUSHL	(R5)			; Save next entry address.
	JSB	@8(SP)			; Call action routine.
	POPL	R5			; Restore address of next entry.
	BRB	83$			; Since R5 already has the address
					; of the next entry, skip the queue
					; traversal step of this loop.

100$:	MOVAB	8(SP), SP		; Cleanup the stack.
	POPR	#^M<R0,R2,R4,R5>	; Restore saved "found-one" flag and
	RSB				; other preserved registers.


	.SBTTL	SCS$NEW_SB - New/Reused System Block Available for Polling

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called whenever SCS builds a new system block
;	(SB) or reuses an existing SB with a new software incarnation
;	number.  This routine initializes the poller fields in the
;	system block.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$NEW_SB
;	IPL must be at IPL$_SCS, IPL$_TIMER
;
; INPUT PARAMETERS:
;
;	R2 contains the address of the system block of the new system.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

; Use of SB$W_TIMEOUT:
;
;	SB$W_TIMEOUT indicates that state of polling on a particular node
;
;		>0  : Seconds remaining until polling is triggered
;		=0  : Ready to be polled
;		-1  : Polling in progress, reset timer on completion
;		-2  : Polling in progress, set to 0 on completion to repoll
;
; Use of SB$B_ENBMSK:
;
;	Each process name to be polled is assigned a bit in the SB$B_ENBMSK
;	array.  If the bit is set, then polling for the process name is
;	enabled; if the bit is clear, polling for the name is disabled.
;	This allows system by system control over which processes are
;	polled.
;

SCS$NEW_SB:
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	CLRW	SB$W_TIMEOUT(R2)	; Trigger for immediate polling
	MOVC3	#SB$S_ENBMSK, -		; Initialize polling mask
		G^SCS$GA_DFLTMSK, -
		SB$B_ENBMSK(R2)
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB


	.SBTTL	SCS$POLL_PROC - Declare a process name to the poller

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to declare a process to be polled.
;	The routine builds a Poller Process block and links it.
;	An unused bit is allocated and assigned to this process.
;
;	Polling for the process is NOT enabled.
;
;	Note: Things could be simplified by omitting this routine
;	and wiring the necessary (and short) list of processes to
;	be polled into this module.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$POLL_PROC
;	IPL must be at IPL$_SCS, IPL$_TIMER
;
; INPUT PARAMETERS:
;
;	R0 contains the address of the notification routine
;	R1 contains the context to be passed to the notification routine
;	R2 contains the address of the process name
;
; OUTPUT PARAMETERS:
;
;	R1 contains address of the SPPB (to be used as context to other calls)
;
; COMPLETION CODES:
;
;	R0 contains status
;
; SIDE EFFECTS:
;
;	R0 is destroyed
;	New data structures are built
;
;--

SCS$POLL_PROC:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVAW	G^SCS$GW_NEXTBIT,R5	; Address of next bit to allocate
	CMPW	(R5),#SB$S_ENBMSK*8	; Any bits left?
	BGEQ	20$			; Branch if all bits used
	MOVZWL	#SPPB$K_LENGTH,R1	; Size of a SPPB
	BSBW	SCS_ALONONPAGED		; Allocate a SPPB
	BLBC	R0,30$			; Exit on error
	MOVW	R1,SPPB$W_SIZE(R2)	; Store size
	ASSUME	SPPB$B_SUBTYP,EQ,SPPB$B_TYPE+1
	MOVW	#DYN$C_SCS! -		; Store type and subtype
		<DYN$C_SCS_SPPB@8>, -
		SPPB$B_TYPE(R2)
	ASSUME	SPPB$L_RTN+4,EQ,SPPB$L_CTX
	MOVQ	(SP)+,SPPB$L_RTN(R2)	; Store routine address and context
	MOVW	(R5),SPPB$W_BIT(R2)	; Store allocated mask bit
	INCW	(R5)			; Mark bit used
	PUSHL	R2			; Save SPPB address
	MOVC3	#SPPB$S_PROCNAM, -	; Store process name
		@4(SP),SPPB$B_PROCNAM(R2)
	INSQUE	@(SP),G^SCS$GQ_POLL	; Link into head of list of SPPB's
	MOVL	S^#SS$_NORMAL,R0	; Success
10$:	POPR	#^M<R1,R2,R3,R4,R5>
	RSB
20$:	CLRL	R0			; Set failure return
30$:	ADDL2	#4,SP			; Balance stack with main path
	BRB	10$


	.SBTTL	SCS$POLL_MODE - Enable/Disable polling for a process

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine enable or disable polling for a process on
;	either a specified system or a global basis.  If polling
;	is enabled on any existing system, a poll is requested.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$POLL_MODE
;	IPL must be at IPL$_SCS, IPL$_TIMER
;
; INPUT PARAMETERS:
;
;	R0 contains 0 to disable or 1 to enable polling
;	R1 contains the address of the SPPB block
;	R2 contains the address of the System ID or 0 (for global)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 contains status
;
; SIDE EFFECTS:
;
;	All registers preserved
;
;--

SCS$POLL_MODE:
	PUSHR	#^M<R1,R2,R3,R4,R5>
	MOVL	R0,R3			; Set/clear flag
	MOVZWL	SPPB$W_BIT(R1),R4	; Process' bit number
	TSTL	R2			; Is system name specified?
	BNEQ	20$			; Branch if yes
	INSV	R3,R4,#1, -		; Set bit in default mask
		G^SCS$GA_DFLTMSK
	MOVAL	G^SCS$GQ_CONFIG,R0	; Address of SB listhead
	MOVL	(R0),R1			; Address of first SB
10$:	CMPL	R1,R0			; End of list?
	BEQL	30$			; Branch if done
	BSBB	100$			; Handle a system
	MOVL	SB$L_FLINK(R1),R1	; Link to next SB
	BRB	10$			; Iterate

20$:	MOVL	R2,R1			; Address of system ID
	CLRL	R2			; No output buffer
	BSBW	SCS$CONFIG_SYS		; Lookup system ID
	BLBC	R0,40$			; Branch if System ID not found
	BSBB	100$			; Enable/disable polling
30$:	MOVL	S^#SS$_NORMAL,R0	; Success
40$:	POPR	#^M<R1,R2,R3,R4,R5>
	RSB

;
; R3 is set/clear flag
; R4 is bit number
; R1 is address of the SB
;
100$:	BLBC	R3,120$			; Branch to disable polling
	BBSS	R4,SB$B_ENBMSK(R1),130$	; Branch if already enabled
	TSTW	SB$W_TIMEOUT(R1)	; Check timeout
	BLSS	110$			; Branch if in progress to retrigger
	CLRW	SB$W_TIMEOUT(R1)	; Set to 0 to trigger polling
	RSB				; Return
110$:	MNEGW	#2,SB$W_TIMEOUT(R1)	; Polling in progress, retrigger
	RSB
120$:	BBCC	R4,SB$B_ENBMSK(R1),130$	; Disable polling
130$:	RSB				; Return


	.SBTTL	START_POLL - Start poll of requested processes

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called as a result of a timeout.  It must
;	scan the list of system decrementing the timeouts.  If
;	a system has timed out, a poll of the processes listed
;	for that system must be begun.
;
; CALLING SEQUENCE:
;
;	JSB	START_POLL
;	IPL must be at IPL$_SCS, IPL$_TIMER
;
; INPUT PARAMETERS:
;
;	R5 is the address of a TQE block
;	R4 is the address of the SB which is the start of the
;	   circular sequence used to select the next system to
;	   poll.  If R4 does not point to an SB, the sequence
;	   begins with the first SB.
;
; OUTPUT PARAMETERS:
;
;	R4 is the new SB at which the search sequence is to
;	   start.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0,R1,R2,R3 are destroyed
;
;--

START_POLL:
	MOVAL	G^SCS$GQ_CONFIG,R2	; Address system listhead
	MOVL	R4,R0			; Position in scan
	CLRQ	R3			; No timed-out system found yet
	MOVL	(R2),R1			; First SB
10$:	CMPL	R2,R1			; All done?
	BEQL	80$			; Return
	CMPL	R0,R1			; At start of new scan?
	BNEQ	20$
	MOVL	R3,R4			; Save preceding match
	CLRL	R3			; Look for succeeding match
20$:	DECW	SB$W_TIMEOUT(R1)	; Decrement timer
	BLEQ	60$			; Timed out
30$:	MOVL	SB$L_FLINK(R1),R1	; Advance to next SB
	BRB	10$

40$:	POPR	#^M<R0,R1>		; Restore registers
50$:	MOVW	#^X7FFF, -		; Set max timeout -- this will be
		SB$W_TIMEOUT(R1)	;	reduced when a bit is set
	BRB	30$			; Continue scan

60$:	BEQL	70$			; Have just timed out
	INCW	SB$W_TIMEOUT(R1)	; Poll in progress, unmung timer
	BNEQ	30$			; Was -2, ignore for now
;
; here if polling is triggered but not yet begun
;
70$:	PUSHR	#^M<R0,R1>		; Save registers
	MOVAB	SB$L_PBFL(R1),R0	; Address of path block queue header
	CMPL	R0,(R0)			; Is there a path block?
	BEQL	40$			; Branch if no
	SKPC	#0,#SB$S_ENBMSK, -	; Any polling bits set?
		SB$B_ENBMSK(R1)
	BEQL	40$			; Branch if no bits are set
	POPR	#^M<R0,R1>		; Restore registers
	CMPL	R1,#SCS$GA_LOCALSB	; Local system?
	BEQL	50$			; Wait a long time
	TSTL	R3			; Found one yet this pass?
	BNEQ	30$			; Branch if yes
	MOVL	R1,R3			; Remember this one
	CLRL	R4			; Forget lower precedence type
	BRB	30$			; Rejoin main flow

;
; The scan over all SB's is completed.
; R3 NEQ 0:
;	R3 is the first SB ready for polling following the mark
;	point set during the last pass, or if there is not
;	such system, R3 is the first SB ready for polling following
;	the list header.  R4 is 0.
; R3 EQL 0:
;	R4 is 0 or the address of the first SB ready for polling
;	preceding mark point set during the last pass and no SB ready
;	for polling was found following the mark point.
; 
; If any systems are ready for polling, initiate polling one
; of these.
;
80$:	BISL2	R4,R3			; Address is in R3
	BEQL	90$			; Branch if no system
	MOVL	SB$L_FLINK(R3),R4	; Address of scan restart point
90$:	MOVL	R4,TQE$L_FR4(R5)	; Save restart point
	BEQL	140$			; Branch if no system ready for polling
	PUSHL	R5			; Save address of TQE
	MOVZWL	G^SCS$GW_NEXTBIT,R1	; Number of possible SPPBs
	MULL2	#4,R1			; One longword per SPPB
	ADDL2	#SPNB$C_HDRSIZ+4,R1	; Space for listhead and trailer
	PUSHL	R3			; Save SB address
	BSBW	SCS_ALONONPAGED		; Get pool
	POPL	R3			; Restore SB address
	BLBC	R0,130$			; Can't, so exit nicely
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	MOVC5	#0,(R2),#0,R1,(R2)	; Zero allocated block
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	MOVW	R1,SPNB$W_SIZE(R2)	; Store size
	CLRW	SPNB$W_REFC(R2)		; Init reference count
	ASSUME	SPNB$B_SUBTYP EQ SPNB$B_TYPE+1
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_SPNB@8>,SPNB$B_TYPE(R2) ; Set type
	MOVL	R3,SPNB$L_SB(R2)	; Address of SB
	MOVAB	B^300$,SPNB$L_ROUTINE(R2) ; Address of local notification routine
	MOVAB	SPNB$B_NAMLST(R2),R4	; Address data area
	MOVAL	G^SCS$GQ_POLL,R5	; Poller process list head
	MOVL	(R5),R0			; Address of first SPPB
100$:	CMPL	R5,R0			; All done?
	BEQL	120$			; Branch if yes
	MOVZWL	SPPB$W_BIT(R0),R1	; Get process bit number
	BBC	R1,SB$B_ENBMSK(R3),110$	; Branch if poll not enabled
	MOVAB	SPPB$B_PROCNAM(R0), -	; Save address of process name
		(R4)+
	INCW	SPNB$W_REFC(R2)		; Increment reference count
110$:	MOVL	SPPB$L_FLINK(R0),R0	; Advance to next process
	BRB	100$			; Iterate over all SPPBs

120$:	CLRL	(R4)+			; List end mark

;
; call SCS$DIRECTORY_LOOKUP to do lookups
;
;	R3 : address of SB
;	R2 : address of allocated argument list
;
	DECW	SB$W_TIMEOUT(R3)	; Set timeout to -1 to flag scan
	PUSHR	#^M<R3,R4>		; Save regs
	BSBW	SCS$DIR_LOOKUP		; Call lookup routine
	POPR	#^M<R3,R4>
130$:	POPL	R5			; Restore TQE address
140$:	RSB

;
; Get here when a polled process is found;
;
;	R1 is address of process name in SPPB
;	R2 is address of SB
;	R3 is address of process info in message buffer
;	Preserves R1-R5
;
300$:	
	MOVZWL	SPPB$W_BIT-SPPB$B_PROCNAM(R1),R0	; Polling bit number
	BBC	R0,SB$B_ENBMSK(R2),310$	; Branch if not interested
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save some registers
	MOVAB	SB$T_NODENAME(R2),R4	; Address of node name
	MOVAB	SB$B_SYSTEMID(R2),R2	; Address of system ID
	MOVL	SPPB$L_CTX-SPPB$B_PROCNAM(R1),R0	; Context longword
;
; Call notification routine with:
;
;	R0 is context longword
;	R1 is address of process name
;	R2 is address of system ID
;	R3 is address of process information
;	R4 is address of node name
;
;	If the notification routine returns success, disable polling
;	for the process on the system on which is was found
;
	JSB	@SPPB$L_RTN-SPPB$B_PROCNAM(R1)	; Call notification routine
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	BLBC	R0,310$			; Branch to leave polling enabled
	MOVZWL	SPPB$W_BIT-SPPB$B_PROCNAM(R1),R0	; Polling bit number
	BBCC	R0,SB$B_ENBMSK(R2),310$	; Clear polling bit		
310$:	RSB				; Have handled event


	.SBTTL SCS$DIR_LOOKUP - look up process names on remote node
;++
;  SCS$DIR_LOOKUP
;
;  INPUTS
;	R2	- address of SPNB (System Process Name Block)
;	R3 	- address of target SB
;	IPL	- IPL$SCS
;
;  FUNCTION
;	Connect to SCS$DIRECTORY service on remote system, look
;	up process names in specified list, and notify caller
;	of the ones which exist
;--

MY_PROC:	.ASCII /SCS$DIR_LOOKUP  /	; Name of process on local node
REM_PROC:	.ASCII /SCS$DIRECTORY   /	; Name of process on remote node
SCS$DIR_LOOKUP:

;
; Connect to remote node
;
	MOVL	R2,R5				; Save context in safe register
	CONNECT MSGADR=MSG_INPUT,-		; Try connect to directory
		ERRADR=ERR_ROUTINE,-		; service on remote node
		RPRNAM=REM_PROC,-
		LPRNAM=MY_PROC,-
		RSYSID=SB$B_SYSTEMID(R3),-
		INITCR=#1,-
		AUXSTR=(R2)
	BLBS	R0,10$				; If LBS, okay
	MOVL	R5,R0				; Get SPNB
	BSBW	RESET_TIMER			; Re-enable polling on this node
	JSB	G^COM$DRVDEALMEM		; And deallocate
	RSB					; Return
	
10$:	MOVL	CDT$L_AUXSTRUC(R3),R2		; Restore context
	MNEGB	#1,SPNB$B_INDEX(R2)		; Init index

;
; Allocate CDRP and set it up
;
	MOVZWL	#CDRP$C_LENGTH,R1		; Specify number of bytes needed
	PUSHL	R3
	BSBW	SCS_ALONONPAGED			; Allocate from npagedpool
	POPL	R3 
	BLBC	R0,25$				; No memory available
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save regs destroyed by MOVC
	MOVC5	#0,(R2),#0,#CDRP$C_LENGTH,(R2)	; Zero out block
	POPR	#^M<R0,R1,R2,R3,R4,R5>		; Restore regs	
	MOVL	R2,R5				; Move CDRP to arg register
	MOVW	R1, CDRP$W_CDRPSIZE(R5)		; Set up block size
	MOVZBW	#DYN$C_CDRP, -
		CDRP$B_CD_TYPE(R5)		; Set type
	MOVL	R3,CDRP$L_CDT(R5)		; Set CDT

;
; Allocate message buffer and store next process name to look for
;
15$:	ALLOC_MSG_BUF
	MOVL	CDRP$L_CDT(R5),R3		; Get CDT
	PUSHR	#^M<R6,R7>			; Save CDT
	MOVL	CDT$L_AUXSTRUC(R3),R6		; Get SPNB
	INCB	SPNB$B_INDEX(R6)		; Point to next name
	MOVZBL	SPNB$B_INDEX(R6),R7		; Get index
	MOVL	SPNB$B_NAMLST(R6)[R7],R7	; Get next process name
	BEQL	20$				; If zero, end of list
	CLRL	(R2)				; Zero out first longword of msg
	MOVQ	(R7),4(R2)			; Move to message buffer
	MOVQ	8(R7),12(R2)			; (16 bytes)
	POPR	#^M<R6,R7>			; Restore CDT
	MOVL	#36,R1				; Maximum size of msg (for HSC)
	CLRL	CDRP$L_RSPID(R5)		; No response ID
	SEND_CNT_MSG_BUF			; Send it
	BRB	15$				; More names to look for?

;
; No more processes to look for - clean up
;
20$:	
	POPR	#^M<R6,R7>			; Restore CDT and stack
	DEALLOC_MSG_BUF				; Deallocate message buffer
	RSB

;
; Deallocate SPNB (when CDRP allocate fails)
;	
25$:	MOVL	CDT$L_AUXSTRUC(R3),R0		; Get SPNB
	BSBB	RESET_TIMER			; Re-enable polling for node
	JSB	G^COM$DRVDEALMEM		; And deallocate
	DISCONNECT				; Break connection
	RSB

;++
;  MSG_INPUT
;	Process responses from SCS$DIRECTORY
;
;  INPUTS
;	R2	- Address of response message
;	R3	- CDT address
;	R4	- PDT address
;	IPL	- Port device fork IPL
;
;  FUNCTION
;	Notifies lookup initiator of found process
;
;--

MSG_INPUT:
	BLBC	(R2),35$			; If no success, return
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7>	; Save registers
	MOVL	CDT$L_AUXSTRUC(R3),R5		; Get address of SPNB
	MOVL	R2,R4				; Move to safe register

;
;  Search for name in list of names we've asked about
;
	CLRL	R6				; Init index
10$:	MOVL	SPNB$B_NAMLST(R5)[R6],R7	; Get next name
	BEQL	90$				; If eql, end of list
	CMPC3	#16,(R7),4(R4) 			; Look for match
	BEQL	20$				; Found one
	INCL	R6				; Next item in list
	BRB	10$				; Loop

;
;  Send on notice that remote node has process
;
20$:	MOVL	R7,R1				; Get address of process name
	MOVAB	<4+16>(R4),R3			; Get address of process info
	MOVL	SPNB$L_SB(R5),R2		; Get address of SB
	JSB	@SPNB$L_ROUTINE(R5)		; Pass to our notification rtn
;
;  Clean up
;
30$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7>	; Restore registers
35$:	
	DEALLOC_MSG_BUF_REG			; Return message buf to SCS
	MOVL	CDT$L_AUXSTRUC(R3),R0		; Get address of SPNB
	DECW	SPNB$W_REFC(R0)			; Decrement reference count
	BEQL	40$				; Branch if done on connection
	RSB					; And return

40$:	BSBB	ERR_ROUTINE			; Clean up on connection
						; & disconnect
	RSB

;
;  We get here if there is no match in the list of names we are polling
;  for.  The reference count is not decremented - the connection will
;  remain open without further polling as a way of flagging this error.
;
90$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7>	; Just exit here
	DEALLOC_MSG_BUF_REG			; Get rid of buffer
	RSB					;

;++
;  RESET_TIMER
;	Re-enable polling on a node
;
;  INPUT
;	R0	- address of SPNB
;
;  OUTPUT
;	Polling is re-enabled on node
;--

RESET_TIMER:
	PUSHL	R2			; Save R2
	MOVL	SPNB$L_SB(R0),R2	; Get address of system block
	INCW	SB$W_TIMEOUT(R2)	; Polling complete
	BEQL	10$			; Branch to reset timer
	CLRW	SB$W_TIMEOUT(R2)	; Request polling
	BRB	20$

10$:	MOVW	G^SCS$GW_PRCPOLINT, -	; Reset timer
		SB$W_TIMEOUT(R2)
20$:	POPL	R2			; Restore R2
	RSB				; Return


;++
;  ERR_ROUTINE
;	Handle broken connections
;
;  INPUTS
;	R0 	- error status
;	R3	- address of CDT
;	R4	- address of PDT
;
;  FUNCTION
;	Deallocate all message buffers and CDRP'S associated with
;	given CDT, and disconnect.
;--
ERR_ROUTINE:
	SCAN_MSGBUF_WAIT -		; Find CDRP'S 
	  	ACTION = CLEANUP_RTN	
	DISCONNECT			; Break connection
	RSB

;++
;  CLEANUP_RTN
;
;  INPUTS
;	R3	- address of CDT
;	R4	- address of PDT
;	R5	- address of CDRP
;--

CLEANUP_RTN:

;
;  Remove CDRP from queue, if needed
;
	PUSHL	R2
	TSTL	CDRP$L_FQBL(R5)		; Is there a queue pointer?
	BEQL	5$			; If EQL, none
	CMPL	@CDRP$L_FQBL(R5),R5	; Is CDRP in a queue?
	BNEQ	5$			; If NEQ, no
	REMQUE	(R5),R5			; Dequeue CDRP
	MOVL	CDRP$L_RWCPTR(R5),R2	; Get wait count pointer
	BEQL	5$			; Branch if none
	DECW	(R2)			; Adjust

;
;  Deallocate associated message buffer, if any
;
5$:	POPL	R2			; Restore reg
	TSTL	CDRP$L_MSG_BUF(R5)	; Do we have any message buffers?
	BEQL	10$			; If EQL, no
	DEALLOC_MSG_BUF			; Get rid of it

;
;  Return CDRP to non-paged pool
;
10$:	MOVL	R5,R0			; Address of CDRP in R0
	JSB	G^COM$DRVDEALMEM	; Give back to pool
	MOVL	CDT$L_AUXSTRUC(R3),R0	; Get address of SPNB
	BSBB	RESET_TIMER		; Re-enable polling
	JSB	G^COM$DRVDEALMEM	; Return to pool
	RSB				; Cleanup done

	.SBTTL	SCS$POLL_MBX - Declare Polling Notification Mailbox

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to declare a mailbox to receive notification
;	when a process name appears in an SCS directory.
;
;	This routine, and its companion SCS$CANCEL_MBX, are assumed to be
;	used as follows:
;
;		$CREMBX	...			;create mailbox
;		BLBC	R0,xxx
;		JSB	SCS$POLL_MBX		;declare polling notification
;		BLBC	R0,xxx
;
;		...
;
;		$QIO	#IO$_READVBLK,...	;read messages from mailbox
;
;		...
;
;		JSB	SCS$CANCEL_MBX		;cancel polling notification
;		$DASSGN	...			;deassign mailbox
;
;		Note that this sequence must be complete before the process
;		exists, for whatever reason!
;
; CALLING SEQUENCE:
;
;	JSB	SCS$POLL_MBX
;	IPL must be at IPL$_ASTDEL
;
; INPUT PARAMETERS:
;
;	R0 is the mailbox channel number
;	R2 is the address of process name address
;
; OUTPUT PARAMETERS:
;
;	R1 is the address of the SPPB created to service this request.
;
; COMPLETION CODES:
;
;	R0 contains status
;
; SIDE EFFECTS:
;
;	R0,R1 are destroyed
;
;--

SCS$POLL_MBX:
	PUSHR	#^M<R2,R3>
	JSB	G^IOC$VERIFYCHAN	; Verify channel number
	BLBC	R0,20$			; Branch on invalid channel
	MOVQ	(SP),R2			; Restore registers
	MOVL	CCB$L_UCB(R1),R1	; UCB address
	INCW	UCB$W_REFC(R1)		; Nail down UCB -- security blanket
	MOVAB	B^100$,R0		; Address of notication routine
	DSBINT	#IPL$_SCS		; Raise IPL
	BSBW	SCS$POLL_PROC		; Declare process to poll
	BLBC	R0,10$			; Branch on error
	CLRL	R2			; Set polling mode for all systems
					; R1 is address of SPPB
					; R0 is odd to enable polling
	BSBW	SCS$POLL_MODE		; Enable polling
10$:	ENBINT				; Restore IPL
20$:	POPR	#^M<R2,R3>		; Restore registers
	RSB

;
; Mailbox message format:
;
;	 31           24 23           16 15           08 07           00	
;	+---------------+---------------+---------------+---------------+
;    00	|       		System ID (l.o.)			|
;	+---------------+---------------+---------------+---------------+
;    04	|       Unused (zero)           |        System ID (h.o.)	|
;	+---------------+---------------+---------------+---------------+
;    08	|			Node Name				|
;	|			( 16 bytes )				|
;	|								|
;	|								|
;	+---------------+---------------+---------------+---------------+
;    24	|		Process						|
;	|		    Name					|
;	|			( 16					|
;	|			    Bytes )				|
;	+---------------+---------------+---------------+---------------+
;    40	|		Directory					|
;	|		    Information					|
;	|			( 16					|
;	|			    Bytes )				|
;	+---------------+---------------+---------------+---------------+
;    56
; 
;
; Notification routine called when process name is found
;
; Inputs:
;	R0 is UCB address
;	R1 is address of process name
;	R2 is address of system ID
;	R3 is address of process information
;	R4 is address of node name
;
; Outputs:
;	R1-R5 destroyed
;	R0 is status
;
100$:	MOVL	R0,R5			; Notification still wanted?
	BEQL	110$			; Branch if no
	ASSUME	PRCPOL$C_SIZ,EQ,56      ; Ensure size is longword aligned
	SUBL2	#PRCPOL$C_SIZ,SP	; Make room on stack
	MOVL	SP,R0			; Get address of allocated space
	ASSUME	SDIR$S_PROCINF,EQ,16    ; Use R0 to point to message on stack
	MOVQ	8(R3),PRCPOL$B_DIRINF+8(R0) ; Process information --
	MOVQ	(R3),PRCPOL$B_DIRINF(R0)    ;	16 bytes
	ASSUME	SDIR$S_PROCNAM,EQ,16
	MOVQ	8(R1),PRCPOL$B_PRCNAM+8(R0) ; Process name --
	MOVQ	(R1),PRCPOL$B_PRCNAM(R0)    ;	16 bytes
	ASSUME	SB$T_NODENAME+16  EQ  SB$L_DDB
	MOVQ	8(R4),PRCPOL$T_NODNAM+8(R0) ; Node name -- 
	MOVQ	(R4),PRCPOL$T_NODNAM(R0)    ;   16 bytes
	ASSUME	SB$S_SYSTEMID,EQ,6
	MOVZWL	4(R2),PRCPOL$W_SYSIDH(R0)   ; System ID --
	MOVL	(R2),PRCPOL$L_SYSIDL(R0)    ;	6 bytes
	MOVL	R0,R4			; Address of message
	MOVZBL	#PRCPOL$C_SIZ,R3	; Length of message
	JSB	G^EXE$WRTMAILBOX	; Put message into mailbox
	ADDL2	#PRCPOL$C_SIZ,SP	; Clean stack
	RSB				; On success, disable polling
110$:	MOVL	S^#SS$_NORMAL,R0	; Disable polling
	RSB	

	.SBTTL	SCS$CANCEL_MBX - Cancel Polling Notification Mailbox
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to cancel mailbox delivery of notification
;	when a process name appears in an SCS directory.
;
;	The user of a notification mailbox must call this routine before
;	exiting and before deassigning its channel to the mailbox.  If this
;	constraint is not satisfied, the mailbox may remain forever,
;	undeleted.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$CANCEL_MBX
;	IPL must be in range 0 to IPL$_SCS, IPL$_TIMER
;
; INPUT PARAMETERS:
;
;	R1 is the address of the SPPB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 contains status
;
; SIDE EFFECTS:
;
;	R0,R1,R2 are destroyed
;
;--

SCS$CANCEL_MBX:
	DSBINT	#IPL$_SCS		; Raise IPL
	MOVL	SPPB$L_CTX(R1),R0	; Mailbox UCB address
	CLRL	SPPB$L_CTX(R1)		; Forget mailbox UCB address
	DECW	UCB$W_REFC(R0)		; Release grip on UCB -- security blanket
	CLRL	R2			; For all systems
	CLRL	R0			;    disable polling
	BSBW	SCS$POLL_MODE		; Disable polling
	ENBINT				; Restore IPL
	RSB

	.SBTTL	SCS$SHUTDOWN - Shutdown all SCS virtual circuits
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine runs down the singly linked list of SCS speaking
;	PDT's, calling the associated port driver for each one it finds.
;	The port driver will close all virtual circuits it has outstanding.
;	Control will return upon the port being offline, encountering any
;	errors, or successful termination.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$SHUTDOWN
;	IPL = 31.
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R4 are destroyed
;
;--

SCS$SHUTDOWN:
	MOVAL	@#SCS$GL_PDT,R4		; Pick up list head of PDT's
10$:	MOVL	(R4),R4			; Get next entry
	BEQL	20$			; There is none
	JSB	@PDT$L_STOP_VCS(R4)	; Call the port driver to close VC's
	BRB	10$			; Loop for next one

20$:	RSB				; Finish, leave

	LC=.
	.=<LC+15>&-16			; Align on 16 byte boundary
SCS_END:
	.ENDC				; End of conditional code
	.END
