	.TITLE	SYSSNDMSG - SEND MESSAGE SYSTEM SERVICES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;
;	STARLET SYSTEM SERVICE
;
; ABSTRACT:
;
;	COMMON MODULE FOR SEND TO OPERATOR AND SYMBIONT MANAGER.
;
; AUTHOR: R.HEINEN, CREATION DATE: 11-JUL-77
;
; MODIFIED BY:
;
;	V03-010	LMP0185		L. Mark Pilant,		20-Jan-1984  10:57
;		Track interface changes to EXE$CHKxxxACCES.
;
;	V03-009	ACG0354		Andrew C. Goldstein,	19-Sep-1983  15:19
;		Use alternate access mask to validate delete access
;
;	V03-008	CWH3008		CW Hobbs		18-Sep-1983
;		KLUDGE - change ATR$x_ACCESS_MASK to DUMMY_0 to get the
;		build working.  Symbol was deleted.
;
;	V03-007	MLJ0118		Martin L. Jack,	22-Aug-1983  9:39
;		Guard against overlong resultant filename.
;
;	V03-006	MLJ0115		Martin L. Jack,	29-Jul-1983  14:30
;		Update for new file protection handling.
;
;	V03-005	CWH1002		Alan D. Eldridge	31-May-1983
;		Change BSBW to JSB in call to ERL$ALLOCMB and ERL$RELEASEMB.
;
;	V03-004	CWH1002		CW Hobbs		24-Feb-1983
;		Use extended pid and owner in the message.
;
;	V03-003	RNG0003		Rod N. Gamache		2-Feb-1983
;		Use longword displacements where needed.
;
;	V03-002	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF.
;
;
;--
	.PSECT	Y$EXEPAGED
;
; EXTERNAL SYMBOLS
;
	$ACMDEF				; DEFINE ACCOUNTING MESSAGE OFFSETS
	$ARMDEF				; Define access rights mask
	$ATRDEF				; Define ACP attribute codes
	$CCBDEF				; DEFINE CHANNEL CONTROL BLOCK
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$EMBDEF	SS			; DEFINE ERROR MESSAGE BUFFER OFFSETS
	$FATDEF				; Define RMS file attribute offsets
	$FIBDEF				; Define file information block offsets
	$IODEF				; Define I/O function codes
	$MSGDEF				; DEFINE MESSAGE TYPES
	$OPCDEF				; DEFINE OPERATOR MESSAGES
	$OPCMSG				; OPERATOR COMMUNICATIONS MESSAGES
	$PCBDEF				; DEFINE PCB
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTER NUMBERS
	$PRVDEF				; DEFINE PRIVILEGE MASK
	$SMRDEF				; Define $SNDSMB function codes
	$SSDEF				; DEFINE SYSTEM STATUS RETURN CODES
	$UCBDEF				; DEFINE UCB
	$IPLDEF				; DEFINE IPL CONSTANTS
	$RSNDEF				; DEFINE RESOURCE NUMBERS
;
; LOCAL SYMBOLS
;
MSG=4
MBX=8
;
; The messages sent by $SNDACC, $SNDERR, and $SNDOPR consist of
; a common header followed by the user specified message.  The 
; common header has the following format:
;
;	.WORD	<message type>
;	.WORD	<reply mailbox channel #>
;	.QUAD	<sender's privilege mask>
;	.LONG	<sender's UIC>
;	.BLKB	<sender's USERNAME.  12 bytes, blank filled>
;	.BLKB	<sender's ACCOUNT.  8 bytes, blank filled>
;	.BYTE	<sender's base priority>
;	.BYTE	<unused>
;
COMMON_HDR=38				; Common header size


;
; Option size table to allow scanning of options list
;
OPTION_SIZE:
	.BYTE	0,0,0,0,0,0,0,0,0,2,1,4,-1,0,0,0
	.BYTE	0[16]
	.BYTE	8,0,1,1,1,0,-2,-1,0,4,0,2,0,2,0,16
	.BYTE	-1,-1,0,0,0,0,0,0,2,0,0,0,0,0,0,0

	.SBTTL	EXE$SNDACC - SEND MESSAGE TO ACCOUNT MANAGER
;++
; EXE$SNDACC - SEND MESSAGE TO ACCOUNT MANAGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ACCOUNT MANAGER MAILBOX SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE JOB CONTROLLER MAILBOX.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED AND THE REQUEST REPLY MAILBOX
; IS CHECKED FOR BEING A MAILBOX AND ACCESSIBLE TO THE PROCESS.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE QUADWORD DESC FOR THE MESSAGE TEXT.
;	MBX(AP) = CHANNEL NUMBER OF THE MAILBOX FOR THE REPLY.
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - DEVICE OFFLINE
;--
EXE$SNDACC::				; SEND TO ACCOUNTING MANAGER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	#MSG$_SNDACC,R11	; SET MESSAGE TYPE CODE
	MOVAB	SYS$GL_JOBCTLMB,R5	; ADDRESS TARGET MAILBOX
	MOVZWL	#200,R7			; SET MAXIMUM MESSAGE SIZE
	BRB	BUILDMSG		; CONTINUE IN COMMON

	.SBTTL	EXE$SNDSMB - SEND MESSAGE TO SYMBIONT MANAGER
;++
; EXE$SNDSMB - SEND MESSAGE TO SYMBIONT MANAGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO SYMBIONT MANAGER MAILBOX SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE JOB CONTROLLER MAILBOX.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED AND THE REQUEST REPLY MAILBOX
; IS CHECKED FOR BEING A MAILBOX AND ACCESSIBLE TO THE PROCESS.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE QUADWORD DESC FOR THE MESSAGE TEXT.
;	MBX(AP) = CHANNEL NUMBER OF THE MAILBOX FOR THE REPLY.
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - DEVICE OFFLINE
;--
EXE$SNDSMB::				; SEND TO SYMBIONT MANAGER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	#MSG$_SNDSMB,R11	; SET MESSAGE TYPE CODE
	MOVAB	SYS$GL_JOBCTLMB,R5	; SET ADDRESS OF MAILBOX
	MOVZWL	#1000,R7		; SET MAXIMUM MESSAGE SIZE
	BRB	BUILDMSG		; CONTINUE IN COMMON

	.SBTTL	EXE$SNDOPR - SEND MESSAGE TO OPERATOR MAILBOX
;++
; EXE$SNDOPR - SEND MESSAGE TO OPERATOR MAILBOX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO OPERATOR MAILBOX SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE OPERATOR MAILBOX.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED AND THE REQUEST REPLY MAILBOX
; IS CHECKED FOR BEING A MAILBOX AND ACCESSIBLE TO THE PROCESS.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE QUADWORD DESC FOR THE MESSAGE TEXT.
;	MBX(AP) = CHANNEL NUMBER OF THE MAILBOX FOR THE REPLY.
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	OPC$_NOPERATOR - NO OPERATOR COVERAGE
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;--
EXE$SNDOPR::				; SEND TO OPERATOR
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	#MSG$_OPRQST,R11	; SET MESSAGE TYPE CODE
	MOVAB	SYS$GL_OPRMBX,R5	; SET ADDRESS OF MAILBOX
	MOVZWL	#<1024-COMMON_HDR>,R7	; SET MAXIMUM USER MESSAGE SIZE
	BRB	BUILDMSG		; CONTINUE IN COMMON

	.SBTTL	BUILD MESSAGE SUBROUTINE
;++
; BUILDMSG - BUILD MESSAGE ROUTINE FOR EXE$SNDOPR/EXE$SNDSMB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE BUILDS THE REQUESTED MESSAGE ON THE EXEC STACK
; AND ENTERS A KERNEL MODE ROUTINE TO PERFORM THE MAILBOX VALIDATION
; AND SEND THE MESSAGE.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;	MBX(AP) = CHANNEL NUMBER OF THE REPLY MAILBOX IF ANY
;	R5 = MAILBOX UCB ADDRESS
;	R7 = MAXIMUM MESSAGE SIZE
;	R11 = MESSAGE TYPE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - DEVICE OFFLINE
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;		     OR THE MESSAGE REQUEST TYPE REQUIRES THE OPERATOR PRIV.
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;--
BADPARAM:
	MOVZWL	#SS$_BADPARAM,R0	; SET BAD PARAM ERROR
ERROR:	RET				; ERROR RETURN
BUILDMSG:				; BUILD MESSAGE
	;
	; MINIMIZE THE ALLOWABLE MESSAGE SIZE WITH
	; THE SYSTEM MAXBUF PARAMETER.
	;
	CMPW	IOC$GW_MAXBUF,R7	; COMPARE MAX MSG SIZE AGAINST SYS MAX
	BGEQU	10$			; BRANCH IF SYSTEM MAX GREATER
	MOVZWL	IOC$GW_MAXBUF,R7	; SET MAXBUF AS MSG LIMIT
	;
	; CHECK THE INPUT PARAMETERS
	;
10$:	MOVL	MSG(AP),R1		; GET MESSAGE DESCRIPTER
	BEQL	BADPARAM		; IF EQL THEN NO MESSAGE AND ERROR
	JSB	G^EXE$PROBER_DSC	; PROBE DESCRIPTOR AND BUFFER
	BLBC	R0,ERROR		; BRANCH IF ERROR
	;
	; R1<0:15> = SIZE, R2 = ADDRESS OF BUFFER
	;
	MOVL	R2,R9			; SAVE ADDRESS OF BUFFER
	MOVZWL	R1,R8			; GET SIZE OF MESSAGE
	BEQL	BADPARAM		; IF EQL THEN ILLEGAL
	CMPW	R8,R7			; LEGAL SIZE?
	BGTRU	BADPARAM		; IF GTRU THEN NO
	CMPW	R11,#MSG$_SNDSMB	; $SNDSMB service?
	BNEQ	20$			; Br if not
	CMPW	R8,#2			; Message at least 2 bytes?
	BLSSU	BADPARAM		; Br if not, invalid
	MOVL	#30,R7			; Assume offset past file ID
	CMPW	(R9),#SMR$K_ADDFIL	; Add file request?
	BEQL	15$			; Br if yes
	MOVL	#46,R7			; Assume offset past file ID
	CMPW	(R9),#SMR$K_ENTER	; Enter file request?
	BNEQ	20$			; Br if no, no special handling
15$:	BRW	60$			; Go to file protection check code
20$:	ADDL3	#COMMON_HDR,R8,R1	; CALC SIZE OF TOTAL MESSAGE
	CMPW	#MSG$_OPRQST,R11	; SYMBIONT OR ACCOUNTING MGR MESSAGE?
	BEQL	30$			; IF EQL, NO
	ADDL2	#<ACM$Q_SYSTIME+8-ACM$B_PROCPRI-2>,R1
					; ALLOCATE SPACE FOR ID DATA
30$:	MOVZWL	#SS$_INSFMEM,R0		; ASSUME NO STACK
	SUBL3	R1,SP,R3		; ADDRESS MESSAGE STORAGE
	CMPL	R3,@#CTL$AL_STACK	; IN KERNEL STACK?
	BLEQU	ERROR			; IF LEQU THEN YES
	;
	; BUILD THE MESSAGE ON THE EXEC STACK.
	;
	MOVL	R3,SP			; ALLOCATE THE SPACE
	PUSHR	#^M<R3,R5>		; SAVE SIZE AND UCB ADDRESS
	MOVW	R11,(R3)+		; INSERT MESAGE TYPE
	MOVW	MBX(AP),(R3)+		; INSERT REPLY MAILBOX CHANNEL NUMBER
	MOVL	G^CTL$GL_PCB,R6		; GET ADDRESS OF PCB

	ASSUME	PHD$Q_PRIVMSK EQ 0

	MOVQ	@PCB$L_PHD(R6),(R3)+	; INSERT PRIVILEGE MASK
	MOVL	PCB$L_UIC(R6),(R3)+	; INSERT UIC
	MOVC3	#20,@#CTL$T_USERNAME,(R3); INSERT USER NAME AND ACCOUNT NAME
	SUBB3	PCB$B_PRIB(R6),#31,(R3)+; INSERT BASE PRIORITY
	CLRB	(R3)+			; CLEAR SPARE BYTE
	CMPW	#MSG$_OPRQST,R11	; ACCOUNTING OR SYMBIONT MESSAGE ?
	BEQL	50$			; IF EQL, NO
;***********************************************************************
;
	ASSUME	ACM$W_MAILBOX EQ ACM$W_TYPE+2
	ASSUME	ACM$Q_PRVMSK EQ ACM$W_MAILBOX+2
	ASSUME	ACM$L_UIC EQ ACM$Q_PRVMSK+8
	ASSUME	ACM$T_USERNAME EQ ACM$L_UIC+4
	ASSUME	ACM$T_ACCOUNT EQ ACM$T_USERNAME+12
	ASSUME	ACM$B_PROCPRI EQ ACM$T_ACCOUNT+8
	ASSUME	ACM$L_PID EQ ACM$B_PROCPRI+4
	ASSUME	ACM$L_STS EQ ACM$L_PID+4
	ASSUME	ACM$L_OWNER EQ ACM$L_STS+4
	ASSUME	ACM$T_TERMINAL EQ ACM$L_OWNER+4
	ASSUME	ACM$Q_SYSTIME EQ ACM$T_TERMINAL+8
;
;***********************************************************************
	CLRW	(R3)+			; CLEAR SPARE BYTES
	MOVL	PCB$L_EPID(R6),(R3)+	; INSERT EXTENDED PROCESS ID
	MOVL	PCB$L_STS(R6),(R3)+	; INSERT PROCESS STATUS
	MOVL	PCB$L_EOWNER(R6),(R3)+	; INSERT EXTENDED OWNER PID (0 => NONE)
	MOVQ	PCB$T_TERMINAL(R6),(R3)+; INSERT TERMINAL NAME
40$:	MOVQ	EXE$GQ_SYSTIME,(R3)	; CURRENT SYSTEM TIME
	CMPL	EXE$GQ_SYSTIME,(R3)	; VERIFY THAT VALUE ACQUIRED WAS
	BNEQ	40$			;  NOT BEING MODIFIED AT THE SAME
	CMPL	EXE$GQ_SYSTIME+4,4(R3)	;  AT THE SAME TIME.  ACQUIRE TIME
	BNEQ	40$			;  AGAIN IF IT CHANGED.
	ADDL	#8,R3			; POINT TO NEXT FIELD
50$:	MOVC3	R8,(R9),(R3)		; COPY MESSAGE
	SUBL3	(SP),FP,-(SP)		; CALC MESSAGE SIZE
	$CMKRNL_S	W^SENDMSG,(SP)	; SEND MESSAGE IN KERNEL MODE
	RET				; RETURN AND CLEAN STACK

	.SBTTL	File protection check
;
; Stack work area offsets for protection check routine.
;
FWA_ATRLIST=	0			; Attribute list
FWA_FIB=	20			; File information block
FWA_CHAN=	FIB$C_LENGTH+20		; Channel assigned to device
FWA_DVI_DESC=	FIB$C_LENGTH+22		; Descriptor for device name
FWA_FIB_DESC=	FIB$C_LENGTH+30		; Descriptor for FIB
FWA_IOSB=	FIB$C_LENGTH+38		; I/O status block
FWA_RECATTR=	FIB$C_LENGTH+46		; Record attributes

FWA_FILE_SPEC=	FIB$C_LENGTH+78		; File specification
FWA_FSPC_LEN=	FIB$C_LENGTH+334	; File specification length
FWA_DVI=	FIB$C_LENGTH+336	; DVI
FWA_FID=	FIB$C_LENGTH+352	; FID
FWA_DID=	FIB$C_LENGTH+358	; DID
FWA_FILE_SIZE=	FIB$C_LENGTH+364	; File size in blocks
FWA_SPARE=	FIB$C_LENGTH+368	; Spare longword

FWA_SIZE=	FIB$C_LENGTH+372	; Length of area
;
; The SMR$K_ENTER and SMR$K_ADDFIL functions check the protection of the
; submitted file, and append information to the user's message buffer:
;
;	fixed area
;	user's message buffer
;	zero byte to stop options scan
;	file specification
;	1 word length of file specification
;	28 byte DVI/FID/DID
;	longword file size
;	longword allowed file access
;
60$:					; Check file protection
	CMPW	R8,R7			; Message contains file ID?
	BLSSU	120$			; Br if not, invalid
;
; Check for sufficient space to allocate the work area, and do so.
;
	MOVZWL	#SS$_INSFMEM,R0		; Assume no space
	MOVAB	-FWA_SIZE(SP),R1	; Get lowest address that will be used
	CMPL	R1,@#CTL$AL_STACK	; Compare against that available
	BLSSU	130$			; Br if space exceeded
	MOVL	R1,SP			; Allocate the space
;
; Move the DVI/FID/DID to the result area.
;
	PUSHL	R5			; Save R5
	MOVC3	#28,-28(R9)[R7],FWA_DVI+4(SP) ; Move parameter to the work area
	MOVC5	#0,(SP),#0,#FIB$C_LENGTH,FWA_FIB(SP) ; Initialize FIB
	POPL	R5			; Restore R5
	CMPB	FWA_DVI(SP),#15		; Check device name length
	BGTRU	120$			; Br if invalid
;
; Scan the options string for a delete request. If found, we have to
; check for delete access to the file.
;
	CLRL	R6			; Assume no delete wanted
	MOVAB	20(R9)[R7],R1		; Point to start of options string
	ADDL3	R8,R9,R2		; Get end of options string
80$:	CMPL	R1,R2			; Check if at end
	BGEQU	150$			; Branch if done
	MOVZBL	(R1)+,R0		; Get next option byte
	CMPB	R0,#64			; Check option validity
	BGEQU	120$			; Branch if out of range
	CMPB	R0,#SMO$K_DELETE	; Check for delete option
	BNEQ	90$			; Branch if not
	MOVL	#1,R6			; Note delete wanted
90$:	CVTBL	OPTION_SIZE[R0],R3	; Get size of option text
	BGEQ	110$			; Branch if fixed
100$:	MOVZBL	(R1)+,R3		; Else counted string - get size
	BEQL	80$			; Branch if end of params
110$:	ADDL	R3,R1			; Skip option text
	CMPB	R0,#SMO$K_PARAMS	; Check for parameter option
	BNEQ	80$			; Branch if not
	BRB	100$			; And loop for next parameter
;
; Helper branches.
;
120$:	BRW	BADPARAM
130$:	BRW	ERROR
;
; Get a pointer to the DVI descriptor, and where the channel will be stored,
; and initialize the descriptor.
;
150$:	CLRL	FWA_SPARE(SP)		; Clear spare longword
	MOVAB	FWA_DVI_DESC(SP),R0	; Point to DVI descriptor
	MOVAB	FWA_CHAN(SP),R3		; Point to channel
	MOVZBL	FWA_DVI(SP),(R0)	; Store device name length
	MOVAB	FWA_DVI+1(SP),4(R0)	; Store device name address
;
; Assign a channel to the device.
;
	$ASSIGN_S -
		DEVNAM=(R0), -		; Device name
		CHAN=(R3)		; Output channel number
	BLBC	R0,130$			; Br if not assigned
;
; Build the FIB, the FIB descriptor, and the ACP attributes list.
;
	MOVAB	FWA_ATRLIST(SP),R0	; Point to attribute list
	MOVAB	FWA_FIB_DESC(SP),R1	; Point to FIB descriptor
	MOVAB	FWA_IOSB(SP),R2		; Point to IOSB
	MOVAB	FWA_FIB(SP),R4		; Point to FIB

	CLRL	FIB$L_ACCTL(R4)		; Clear access control
	MOVL	FWA_FID(SP),FIB$W_FID(R4) ; Store file ID
	MOVW	FWA_FID+4(SP),FIB$W_FID+4(R4)
	BLBC	R6,160$			; Check if delete access needed
	MOVL	FWA_DID(SP),FIB$W_DID(R4) ; Store directory ID
	MOVW	FWA_DID+4(SP),FIB$W_DID+4(R4)
	MOVL	#ARM$M_DELETE,FIB$L_ALT_ACCESS(R4) ; Store alternate access mask
	MOVL	#FIB$M_ALT_REQ,FIB$L_STATUS(R4) ; Note alternate access required
	MOVW	#FIB$M_FINDFID,FIB$W_NMCTL(R4) ; Search for file ID

160$:	MOVL	#FIB$C_LENGTH,(R1)	; Initialize FIB descriptor
	MOVAB	(R4),4(R1)		;

	MOVL	#<ATR$S_RECATTR+<ATR$C_RECATTR@16>>,(R0)
	MOVAB	FWA_RECATTR(SP),4(R0)
	MOVL	#<256+<ATR$C_FILE_SPEC@16>>,8(R0)
	MOVAB	FWA_FILE_SPEC(SP),12(R0)
	CLRL	16(R0)
;
; Access the file to get necessary information.
;
	$QIOW_S -
		EFN=#31, -		; Event flag
		CHAN=(R3), -		; Channel number
		FUNC=#IO$_ACCESS, - 	; Read attributes function
		IOSB=(R2), -		; I/O status block
		P1=(R1), -		; Address of FIB descriptor
		P5=R0			; Address of attribute list
	PUSHL	R0			; Save $QIOW status
	$DASSGN_S -
		CHAN=(R3)		; Deassign the channel
	POPL	R0			; Restore status from access
	BLBC	R0,190$			; Br if $QIOW failed
	MOVZWL	FWA_IOSB(SP),R0		; Pick up status from IOSB
	BLBC	R0,190$			; Br if operation failed
;
; Compute the file size from the record attributes.
;
	ROTL	#16, -			; Move EFBLK to file size area and
		FWA_RECATTR+FAT$L_EFBLK(SP), - ; convert to unswapped
		FWA_FILE_SIZE(SP)
	BEQL	170$			; Br if EFBLK is zero
	TSTW	FWA_RECATTR+FAT$W_FFBYTE(SP) ; Test first free byte
	BNEQ	170$			; Br if nonzero
	DECL	FWA_FILE_SIZE(SP)	; Adjust EFBLK
;
; Slide the file specification up adjacent to the count, and finish it by adding
; the zero byte.
;
170$:	MOVZWL	FWA_FILE_SPEC(SP),R7	; Get file specification length
	CMPW	R7,#254			; Check maximum supported length
	BLEQU	180$			; Br if in range
	MOVZWL	#254,R7			; Shorten
180$:	MOVW	R7,FWA_FSPC_LEN(SP)	; Set length in message
	SUBL3	R7,#254,R6		; Compute bias
	PUSHL	R5			; Save R5
	MOVC3	R7, -			; Slide item up
		FWA_FILE_SPEC+6(SP), -
		FWA_FILE_SPEC+6(SP)[R6]
	POPL	R5			; Restore R5
	MOVAB	FWA_FILE_SPEC+1(SP)[R6],SP ; Delete unused stack
	CLRB	(SP)			; Zero byte to stop options scan
	BRW	20$			; Return to mainline processing
;
; Helper branches.
;
190$:	BRW	ERROR

	.DSABL	LSB

	
	.SBTTL	SEND MESSAGE ROUTINE
;++
; SENDMSG - KERNEL MODE MESSAGE SEND ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RUNS IN KERNEL MODE AND SENDS THE MESSAGE TO THE
; TARGET MAILBOX.
;
; INPUTS:
;
;	0(AP) = SIZE OF MESSAGE
;	4(AP) = ADDRESS OF THE MESSAGE
;	8(AP) = MAILBOX UCB ADDRESS
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERTATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - NO LISTENER FOR SYMBIONT OR JOB CONTROLLER
;	OPC$_NOPERATOR - NO LISTENER FOR OPERATOR REQUEST
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;--
SENDMSG:				; 
	.WORD	0			; SAVE NO REGISTERS
	MOVL	4(AP),R5		; GET MESSAGE ADDRESS
	MOVZWL	2(R5),R0		; GET CHANNEL NUMBER
	BEQL	10$			; IF EQL THEN NO REPLY
	MOVL	SCH$GL_CURPCB,R4	; GET CURRENT PCB
	JSB	G^IOC$VERIFYCHAN	; CHECK OUT CHANNEL NUMBER
	BLBC	R0,20$			; BR IF ERROR
	MOVL	4(AP),R3		; GET MESSAGE ADDRESS
	MOVL	CCB$L_UCB(R1),R5	; GET UCB OF REPLY MAILBOX
	MOVW	UCB$W_UNIT(R5),2(R3)	; INSERT UNIT NUMBER OF MAILBOX
	MOVZWL	#SS$_DEVNOTMBX,R0	; ASSUME DEVICE NOT MAILBOX
	BBC	#DEV$V_MBX,UCB$L_DEVCHAR(R5),20$; BR IF NOT MAILBOX
	JSB	G^EXE$CHKRDACCES	; CHECK ACCESS
	BLBC	R0,20$			; BR IF ERROR IN ACCESS
	JSB	G^EXE$CHKWRTACCES	; CHECK OUT FOR WRITE
	BLBC	R0,20$			; AND RETURN IF NO ACCESS
10$:
	MOVL	8(AP),R5		; ADDRESS UCB OF MAILBOX
	MOVQ	(AP),R3			; GET SIZE AND ADDRESS OF MESSAGE
	BSBB	EXE$SENDMSG		; SEND MESSAGE
20$:
	RET
	.PAGE
;+
; EXE$SENDMSG -- Send mail box message
;
; INPUTS:	R3 = message size
;		R4 = message address
;		R5 = UCB address
;
;-

EXE$SENDMSG::
;
; Check the reference count in the UCB to see if the
; mailbox has a listener.  Note that both the JOB CONTROLER
; mailbox and the OPERATOR mailbox have an initial ref. count
; of 1.  Therefore, if there is a listener at the mailbox,
; the reference count must be greater than 1.
;
	CMPW	UCB$W_REFC(R5),#1	; DOES A LISTENER EXIST?
	BLEQU	10$			; BRANCH IF NOT
;
; The message must faulted in before calling EXE$WRTMAILBOX.
; The manner in which this is done verges on the magical.
; For a detailed explanation, see below.
;
; First round the address of the message (on the EXEC stack)
; DOWN to the nearest page boundary.  Then raise IPL to ASTDEL
; to block AST delivery.  This step is necessary to avoid
; pagefaults incurred during the execution of the AST routine.
; Since we now have a page-aligned base address of the message
; in R2, we can use one instruction to fault in the pages,
; two pages with each operand referenced.  This is done by
; choosing the operand address and instruction operand context
; so that the operand is split across a page boundary.
; Note that if the size (rounded up) in pages of the message
; is N, then the maximum number of pages that must be faulted
; in is N+1.  If the message size is small, and the message
; resides near the end of the EXEC stack, it is possible that
; we may overrun the EXEC stack.  This is ok, because the
; KERNEL stack follows the EXEC stack, and we're in KERNEL
; mode right now (remember?).  Note that after the KERNEL
; stack is a page that is inacessable.  As a result, the message
; size (in pages) must not exceed the number of pages in the
; KERNEL stack.
; 
	BICL3	#^X01FF,R4,R2		; ROUND ADDRESS DOWN
	SETIPL	#IPL$_ASTDEL		; BLOCK AST DELIVERY
	CMPW	511(R2),1023(R2)	; FAULT IN 4 CONTIGUOUS PAGES
	JSB	G^EXE$WRTMAILBOX	; WRITE MESSAGE
	SETIPL	#0			; ENABLE AST DELIVERY
	BLBC	R0,10$			; BRANCH IF ERROR
	RSB
;
; SOMETHING IS WRONG.  EITHER THERE IS NO LISTENER FOR
; THE SPECIFIED MAILBOX, OR THERE IS INSUFFICIENT NON-
; PAGED POOL TO MAIL THE MESSAGE.  CHECK THE STATUS CODE
; AND DO THE APPROPRIATE THING.
;
10$:	CMPW	R0,#SS$_INSFMEM		; INSUFFICIENT MEMORY?
	BEQL	30$			; BRANCH IF YES
;
; NO LISTENER IS PRESENT.
;
; IF THE SPECIFIED MAILBOX IS THE OPERATOR MAILBOX THEN
; THE SENDER IS INFORMED THAT NO OPERATOR IS PRESENT.
;
	MOVZWL	#SS$_DEVOFFLINE,R0	; ASSUME NO LISTENER
	CMPB	#MSG$_OPRQST,(R4)	; OPERATOR?
	BNEQ	20$			; IF NEQ THEN NO
	MOVL	#OPC$_NOPERATOR,R0	; SET NO OPERATOR SUCCESS STATUS
20$:	RSB				; RETURN
;
; THERE WAS INSUFFICIENT NONPAGED POOL TO SEND THE MESSAGE.
; IF THE PROCESS HAS RESOURCE WAIT MODE ENABLED, WAIT FOR
; THE POOL TO FREE UP.  IF NOT, THEN RETURN THE ERROR STATUS.
;
30$:
	PUSHR	#^M<R3,R4,R5>		; SAVE SIZE AND ADDRESS OF MESSAGE
					; AND UCB ADDRESS
	MOVL	SCH$GL_CURPCB,R4	; GET CURRENT PROCESS PCB ADDRESS
	BBS	#PCB$V_SSRWAIT,-	; IF SET, NO WAIT
		PCB$L_STS(R4),40$	;
	MOVZWL	#RSN$_NPDYNMEM,R0	; SET RESOURCE WAIT NUMBER
	MOVPSL	-(SP)			; PUSH PSL ON STACK
	SETIPL	#IPL$_SYNCH		; RAISE IPL TO SYNCH
	JSB	G^SCH$RWAIT		; WAIT FOR NONPAGED MEMORY
	POPR	#^M<R3,R4,R5>		; RESTORE SIZE AND ADDRESS OF MESSAGE
					; AND UCB ADDRESS
	BRB	EXE$SENDMSG		; TRY AGAIN
40$:
	POPR	#^M<R3,R4,R5>		; RESTORE SIZE AND ADDRESS OF MESSAGE
					; AND UCB ADDRESS
	RSB

	.SBTTL	EXE$OPRSNDERL - OPERATOR SEND MESSAGE TO ERROR LOGGER
;++
; EXE$OPRSNDERL - OPERATOR SEND MESSAGE TO ERROR LOGGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ERROR LOGGER SYSTEM SERVICE
; FOR THE OPERATOR COMMUNICATION PROCESS.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE ERROR LOG FORMAT PROGRAM.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;--
	.ENABL	LSB
 
EXE$OPRSNDERL::				; SEND TO ERROR LOGGER
	.WORD	^M<R2,R3,R4,R5>		;
	PUSHL	S^#EMB$K_OM		; SET MESSAGE TYPE TO OPERATOR MESSAGE
	BRB	10$			; JOIN COMMON CODE
	.PAGE
	.SBTTL	EXE$NETSNDERL - NETWORK SEND MESSAGE TO ERROR LOGGER
;++
; EXE$NETSNDERL - NETWORK SEND MESSAGE TO ERROR LOGGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ERROR LOGGER SYSTEM SERVICE
; FOR THE NETWORK COMMUNICATION PROCESS.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE ERROR LOG FORMAT PROGRAM.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;--
 
EXE$NETSNDERL::				; SEND TO ERROR LOGGER
	.WORD	^M<R2,R3,R4,R5>		;
	PUSHL	S^#EMB$K_NM		; SET MESSAGE TYPE TO NETWORK MESSAGE
	BRB	10$			; JOIN COMMON CODE
	.PAGE
	.SBTTL	EXE$SNDERL - SEND MESSAGE TO ERROR LOGGER
;++
; EXE$SNDERR - SEND MESSAGE TO ERROR LOGGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ERROR LOGGER SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE ERROR LOG FORMAT PROGRAM.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;	R4	= ADDRESS OF CURRENT PROCESS PCB - COURTESY OF CMKRNL
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE REQUIRED PRIVILEGE
;--
EXE$SNDERR::				; SEND TO ERROR LOGGER
	.WORD	^M<R2,R3,R4,R5>		; REGISTERS USED
	MOVW	#SS$_NOPRIV,R0		; ASSUME SUER HAS NO PRIVILEGE
	IFNPRIV	BUGCHK,30$		; BR IF NO PRIVILEGE
	PUSHL	S^#EMB$C_SS		; SET MESSAGE TYPE CODE
;
; 0(SP) = MESSAGE TYPE CODE
;
10$:	MOVL	MSG(AP),R1		; GET ADDRESS OF MESSAGE DESCRIPTOR
	JSB	G^EXE$PROBER_DSC	; CHECK ACCESS TO DESCRIPTOR AND BUFFER
	BLBC	R0,30$			; BR IF CAN'T READ DESCRIPTOR OR BUFFER
;
; R1<0:15> = SIZE, R2 = ADDRESS OF BUFFER
;
	MOVZWL	R1,R1			; GET SIZE OF MESSAGE AS A WORD
	MOVQ	R1,R4			; R4 = SIZE, R5 = ADDRESS OF BUFFER
	ADDL	#EMB$K_SS_LENGTH+3,R1	; SET SIZE OF MESSAGE BUFFER NEEDED
	BICL	#3,R1			; MODULO 4 BYTES
	JSB	G^ERL$ALLOCEMB		; ATTEMPT TO ALLOCATE A BUFFER
	BLBC	R0,20$			; BR IF CAN'T ALLOCATE BUFFER
	CVTLW	(SP)+,EMB$W_SS_ENTRY(R2) ; STORE MESSAGE TYPE
	MOVW	R4,EMB$W_SS_MSGSZ(R2)	; STORE LENGTH OF DATA MESSAGE
	PUSHL	R2			; SAVE STARTING ADDRESS OF BUFFER
	MOVC	R4,(R5),EMB$B_SS_MSGTXT(R2) ; INSERT USERS DATA INTO THE BUFFER
	POPR	#^M<R2>			; RESTORE START OF MESSAGE
	JSB	G^ERL$RELEASEMB		; RELEASE THE BUFFER TO THE ERROR LOGGER
	MOVL	S^#SS$_NORMAL,R0	; SET SUCCESSFUL STATUS
	RET				; SUCCESSFUL RETURN
20$:	MOVZWL	#SS$_INSFMEM,R0		; SET INSUFFICIENT MEMORY FLAG
30$:	RET				; ERROR RETURN
	.DSABL	LSB
 

	.SBTTL	SETOPR - set OPR bit in device UCB
;++
; EXE$SETOPR
;
; Functional Descripton:
;
;	This routine will set or clear the OPR bit in a
;	terminal, remote terminal, or mailbox UCB.
;
; Input:
;
;	DEVNAM(AP)	= Address of device name descriptor
;	BIT_STATE(AP)	= Value of the OPR bit.  Must be 0 or 1.
;
; Implicit Inputs:
;
;	The caller has OPER privilege.
;
; Output:
;
;	None.
;
; Implict Outputs:
;
;	R1 = address of device UCB
;
; Routine value:
;
;	R0 = The status of the operation.  Possible values listed below.
;
;	SS$_NORMAL	- The operation was completed.
;
;	SS$_ACCVIO	- The device name descriptor could not be accessed.
;	SS$_BADPARAM	- The bit state was not 0 or 1.
;	SS$_IVDEVNAM	- The device name specified was not valid.
;	SS$_NONLOCAL	- The specified device is not local.
;	SS$_NOPRIV	- The caller does not have OPER privilege.
;	SS$_NOSUCHDEV	- The specified device does not exist.
;--

;
; Local symbols
;

DEVNAM = 4				; Offset to device descriptor parameter
BIT_STATE = 8				; Offset to OPR bit state parameter

	.ENTRY	EXE$SETOPR,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; Check the input parameters.
;
;
; Make sure the caller has OPER privilege.
;
	MOVZWL	#SS$_NOPRIV,R0		; Assume insufficeint privilege
	MOVL	G^CTL$GL_PCB,R4		; Get current process PCB address
	IFNPRIV	OPER,13$		; Branch if no OPER privilege
;
; PROBE the device name descriptor for read access.
; The actual device name string is PROBEd by LOG$TRNSLOGNAME
; during processing by IOC$SEARCHDEV.
;
	MOVL	DEVNAM(AP),R3		; Get the device descriptor address
	MOVZWL	#SS$_ACCVIO,R0		; Assume not readable
	IFNORD	#8,(R3),13$		; Check descriptor for readability
;
; Check the bit_state parameter.
;
	MOVZWL	#SS$_BADPARAM,R0	; Assume value not 0 or 1
	BITL	#^C1,BIT_STATE(AP)	; Test for all but low bit set
	BEQL	20$			; Branch if yes
13$:	RET				; Exit with error
;
; Lock the I/O database for read access and search for the device.
; If the device exists, and it is a terminal, remote terminal or
; mailbox, then set the OPR bit as indicated.  A side effect of
; locking the I/O database is that the IPL is raised to IPL$_ASTDEL.
;
20$:	JSB	G^SCH$IOLOCKR		; Lock I/O database for read access
	MOVL	R3,R1			; Get device name descriptor address
	JSB	G^IOC$SEARCHDEV		; Search for the device
	BLBC	R0,UNLOCK		; Branch if error
;
; Check the device type.  R1 now contains the device UCB address.
;
	MOVZWL	#SS$_IVDEVNAM,R0	; Assume invalid device
	BITL	#DEV$M_TRM!DEV$M_MBX,-	; Check device type
		UCB$L_DEVCHAR(R1)	;
	BEQL	UNLOCK			; Branch if not an operator type device
;
; Set the OPR bit as indicated.
;
	MOVZWL	#SS$_NORMAL,R0		; Set normal return status
	TSTL	BIT_STATE(AP)		; Set or clear?
	BEQL	30$			; Branch if clear desired
	BBSS	#DEV$V_OPR,-		; Set the OPR bit
		UCB$L_DEVCHAR(R1),25$	;
25$:	BRB	UNLOCK			; Exit
30$:	BBCC	#DEV$V_OPR,-		; Clear the OPR bit
		UCB$L_DEVCHAR(R1),UNLOCK;
UNLOCK:	PUSHL	R0			; Save return status
	JSB	G^SCH$IOUNLOCK		; Unlock the I/O database
	SETIPL	#0			; Allow all interrupts
	MOVL	(SP)+,R0		; Restore return status
	RET				; Return

	.END	
