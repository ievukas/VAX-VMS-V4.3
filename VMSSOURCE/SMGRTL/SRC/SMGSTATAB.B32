MODULE SMG$STATEMENT_TABLES( %TITLE 'TPARSE tables for TERMTABLE statements'
		IDENT = '1-004'		! File: SMGSTATAB.B32 Edit: PLL1004
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management 
!
! ABSTRACT:
!
!	This module contains the LIB$TPARSE state tables used to parse
!	TERMTABLE statements.
!
! ENVIRONMENT:	User mode - AST reentrant
!
! AUTHOR: P. Levesque CREATION DATE: 29-Jan-1984
!
! MODIFIED BY:
!
! 1-001	- Original.  PLL 29-Jan-1983
! 1-002 - Allow logical name in REQUIRE file spec.  PLL 21-Mar-1984
! 1-003 - Tighten up some error checking in the state tables.  PLL 11-Jul-1984
! 1-004 - More error checking.  PLL 11-Jul-1984
!--


%SBTTL 'Declarations'
!
! SWITCHES:
!

!
! LINKAGES:
!
!	NONE
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	MISSING_FILE_SPEC,		! signal error
	MISSING_NAME_REQUIRE,		! signal error
	PARSE_BOOLEANS,			! compile boolean capabilities
	PARSE_NUMERICS,			! compile numeric capabilities
	PARSE_REQUIRE,			! compile caps in REQUIRE file
	PARSE_STRINGS,			! compile string capabilities
	SEARCH_KNOWN_TYPES,		! search table of known terminals
	START_NEW_TERM_DEF,		! new term, init def fields
	UNRECOGNIZED_STATEMENT,		! signal error
	ZERO_CUR_TERM_DEF,		! mark no current terminal definition

    ! The following are used by all the SMG TPARSE tables.

	SMG$$BLANKS_OFF,		! set bit to skip over blanks
	SMG$$BLANKS_ON,			! set bit to find blanks
	SMG$$COPY_CAP,			! copy string cap into TERMTABLE
	SMG$$FLUSH_ARITHMETIC,		! flush arithmetic data to TERMTABLE
	SMG$$FLUSH_NUMERIC,		! flush number to data area
	SMG$$FLUSH_SAVED_BUFFER,	! flush saved token to data area
	SMG$$NEXT_RECORD,		! get next record from ascii TERMTABLE
 	SMG$$SAVE_TOKEN_STRING,		! save pointer & count of chars
					! in current cap string
	SMG$$STORE_CAP_MASK,		! remember cap number
  	SMG$$SYNTAX_ERROR,		! signal syntax error
	SMG$$WRITE_DATA;		! block I/O write data to file

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:SMGPROLOG';		! Defines psects, macros, etc.


LIBRARY 'RTLML:SMGTPALIB';		! Bliss library of definitions &
					! macros used for TERMTABLE

LIBRARY 'RTLTPAMAC';			! TPARSE library of macros

!
! EQUATED SYMBOLS:
!
LITERAL
	SINGLE_QUOTE = %X'27',
	DOUBLE_QUOTE = %X'22',
	FORCED_END = %X'00';


!
! FIELDS:
!
!	NONE
!
! PSECTS:
!

!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
	LIB$TPARSE,			! parser
	STR$UPCASE,			! convert to uppercase chars
	STR$COPY_DX;			! copy src string to dest string

EXTERNAL
	SMG$_ERRLIN,			! error at line n
	SMG$_ERRAT_LIN,			! error in line n at or near 'x'
	SMG$_FAIOPEFIL,			! failed to open file x
	SMG$_MISTERNAM,			! missing terminal name
	SMG$_SYNERR,			! syntax error
	SMG$_UNRECSTA,			! unrecognized statement
	SMG$_MISFILSPE,			! missing file spec in REQUIRE stmt
	SMG$_MISENDSTA,			! missing END statement
	SMG$_MISNAMREQ;			! expected NAME or REQUIRE

!+
! The following is the table of DEC terminals used by SET/SHOW TERM.
!-
EXTERNAL
	TERM$_TABLE : BLOCKVECTOR [,28,BYTE], !table of known terminals
	TERM$_NAME : VECTOR,		! table of their names
	TERM$_NUM;			! number of known terminals

!+
! The following are the keyword and state tables needed by LIB$TPARSE.
!-
EXTERNAL
	SMG$$A_BOOLEAN_STATES,
	SMG$$A_BOOLEAN_KEYWDS,
	SMG$$A_NUMERIC_STATES,
	SMG$$A_NUMERIC_KEYWDS,
	SMG$$A_STRING_STATES,
	SMG$$A_STRING_KEYWDS;
!
! OWN STORAGE:
!

GLOBAL 
	SMG$$MASK_ADR : INITIAL (0),		! used by TPARSE action routines
	SMG$$NEXT_NEGATIVE_NUMBER : INITIAL (-2),
					! used to assign terminal numbers
					! (start with -2 cause SET TERM
					!  views -1 as failed to find name)
	SMG$$CURRENT_LINE : INITIAL (0),! current input line - maintained
					! for error messages
	SMG$$CURRENT_BLOCK : INITIAL (2 + SMG$K_CAP_PTRS_SIZE/512),
					! current virtual block in TERMTABLE.EXE
					! (data skips over ptrs)
	SMG$$CURRENT_DEF_BLOCK : INITIAL (2),
					! start of terminal definition
					! (0 is reserved for a header)
	SMG$$DATA_OFFSET : INITIAL (SMG$K_CAP_PTRS_SIZE);
					! starting offset for terminal data
!	
! MACROS:
!
!	NONE


%SBTTL 'SMG$$STATEMENT_TABLES - TPARSE tables for TERMTABLE statements'
!++
! FUNCTIONAL DESCRIPTION:
!
!	The following are the state tables used to parse an ascii
!	TERMTABLE.TXT (a file which defines terminal characteristics).
!	This set of state tables looks for valid statements and then
!	calls LIB$TPARSE with the state tables for those statements.
!--

$INIT_STATE (SMG$$A_STMT_STATES, SMG$$A_STMT_KEYWDS);
				! set up state tables, key words

!+
! Begin scanning loop.  Look for the start of a statement.
! Skip over blanks and comments.
!-

$STATE (BEGIN_SCAN,
    ((END_OF_LINE), BEGIN_SCAN, SMG$$NEXT_RECORD),
    ('!', BEGIN_SCAN, SMG$$NEXT_RECORD),
    ((STATEMENT), BEGIN_SCAN, SMG$$BLANKS_OFF),
    (TPA$_LAMBDA, TPA$_EXIT)
    );

!+
! This state indicates the end of a line.  A comment also signals the
! end of a line.
!-

$STATE (END_OF_LINE,
    (TPA$_EOS, TPA$_EXIT),
    ('!', TPA$_EXIT),
    (TPA$_LAMBDA, TPA$_FAIL)
    );

!+
! Look for the beginning of a known statement type.
!-
$STATE (STATEMENT,
    ('REQUIRE', REQUIRE_FILE),
    ('NAME', EQUALS, , SMG$K_NAME, SMG$$MASK_ADR),
    (FORCED_END, TPA$_FAIL),
    (TPA$_SYMBOL, , MISSING_NAME_REQUIRE),
    (TPA$_ANY, , MISSING_NAME_REQUIRE)
    );

!+
! NAME = 'string' is the format we expect.  Found NAME, now look for '='.
!-
$STATE (EQUALS,
    ((END_OF_LINE), EQUALS, SMG$$NEXT_RECORD),
    ('=', NAME_VALUE, SMG$$STORE_CAP_MASK),
    (TPA$_SYMBOL, , SMG$$SYNTAX_ERROR),
    (TPA$_ANY, , SMG$$SYNTAX_ERROR)
    );

!+
! The value of NAME should be a string.
!-
$STATE (NAME_VALUE,
    ((END_OF_LINE), NAME_VALUE, SMG$$NEXT_RECORD),
    ((STRING), SCAN_DEFINITION),
    (TPA$_SYMBOL, , SMG$$SYNTAX_ERROR),
    (TPA$_ANY, , SMG$$SYNTAX_ERROR)
    );

!+
! A string can be bounded by single or double quotes.
!-
$STATE (STRING,
    (SINGLE_QUOTE, SINGLE_QUOTE_STRING),
    (DOUBLE_QUOTE, DOUBLE_QUOTE_STRING),
    (TPA$_LAMBDA, TPA$_FAIL)
    );

!+
! The name should be plain text - no escape, control, or expressions allowed.
!-
$STATE (SINGLE_QUOTE_STRING,
    (SINGLE_QUOTE, TPA$_EXIT, SMG$$COPY_CAP),
    (TPA$_SYMBOL, SINGLE_QUOTE_STRING, SMG$$SAVE_TOKEN_STRING),
    (DOUBLE_QUOTE, , SMG$$SYNTAX_ERROR),
    (TPA$_LAMBDA, TPA$_FAIL)
    );

$STATE (DOUBLE_QUOTE_STRING,
    (DOUBLE_QUOTE, TPA$_EXIT, SMG$$COPY_CAP),
    (TPA$_SYMBOL, DOUBLE_QUOTE_STRING, SMG$$SAVE_TOKEN_STRING),
    (SINGLE_QUOTE, , SMG$$SYNTAX_ERROR),
    (TPA$_LAMBDA, TPA$_FAIL)
    );

!+
! Found a REQUIRE statement, now find the file name that should follow it.
!-
$STATE (REQUIRE_FILE,
    ((END_OF_LINE), REQUIRE_FILE, SMG$$NEXT_RECORD),
    ((FILE_SPEC), BEGIN_SCAN, PARSE_REQUIRE),
    (TPA$_LAMBDA, TPA$_FAIL, MISSING_FILE_SPEC)
    );

!+
! Assume the file name is between single quotes.  Pass the name to $OPEN
! and let it decide whether it's a valid filespec.
!-
$STATE (FILE_SPEC,
    (SINGLE_QUOTE),
    (TPA$_LAMBDA, TPA$_FAIL)
    );

$STATE (GET_FILE_SPEC,
    (SINGLE_QUOTE, TPA$_EXIT),
    (TPA$_ANY, GET_FILE_SPEC, SMG$$SAVE_TOKEN_STRING),
    (TPA$_LAMBDA, TPA$_FAIL)
    );

!+
! When we get here, we have found a terminal name.  At this point we are
! expecting some capabilities to be defined.
!-
$STATE (SCAN_DEFINITION,
    ((END_OF_LINE), SCAN_DEFINITION, SMG$$NEXT_RECORD),
    ('BOOLEAN', SCAN_DEFINITION, PARSE_BOOLEANS),
    ('NUMERIC', SCAN_DEFINITION, PARSE_NUMERICS),
    ('STRING', SCAN_DEFINITION, PARSE_STRINGS),
    ('END', BEGIN_SCAN, ZERO_CUR_TERM_DEF),
    (TPA$_SYMBOL, , UNRECOGNIZED_STATEMENT),
    (TPA$_ANY, , UNRECOGNIZED_STATEMENT)
    );


%SBTTL 'MISSING_FILE_SPEC - signal missing file specification'
ROUTINE MISSING_FILE_SPEC =

!++
! FUNCTIONAL DESCRIPTION:
!
!	We come here if there is no file spec in the REQUIRE statement.
!
! CALLING SEQUENCE:
!
! 	MISSING_FILE_SPEC ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    SIGNAL_STOP (SMG$_ERRLIN,
		 1, .SMG$$CURRENT_LINE,
		 SMG$_MISFILSPE)

    END;				! end of routine MISSING_FILE_SPEC

%SBTTL 'MISSING_NAME_REQUIRE - missing expected NAME or REQUIRE'
ROUTINE MISSING_NAME_REQUIRE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	We come here if there is some statement other than NAME or REQUIRE
!	starting a definition.
!
! CALLING SEQUENCE:
!
! 	MISSING_NAME_REQUIRE ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    SIGNAL_STOP (SMG$_ERRAT_LIN,
		 3, .SMG$$CURRENT_LINE,
		 .AP [TPA$L_TOKENCNT],
		 .AP [TPA$L_TOKENPTR],
		 SMG$_MISNAMREQ)

    END;				! end of routine MISSING_FILE_SPEC

%SBTTL 'PARSE_BOOLEANS - parse boolean capabilities'
ROUTINE PARSE_BOOLEANS =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse boolean capabilities by calling LIB$TPARSE with the
!	boolean state tables and keywords.  We use separate tables
!	in order to avoid bumping into the 220 keyword limit.
!
! CALLING SEQUENCE:
!
! 	status = PARSE_BOOLEANS ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	STATUS;

!+
! Should have seen a NAME statement by the time we reach here.
!-
    IF .AP [PARAM_L_CUR_TERM_DEF] EQL 0
    THEN
	SIGNAL_STOP (SMG$_ERRLIN,
		     1, .SMG$$CURRENT_LINE,
		     SMG$_MISTERNAM);

!+
! We reuse the same TPARSE parameter block.
!-
    IF NOT (STATUS = LIB$TPARSE (.AP, SMG$$A_BOOLEAN_STATES,
				 SMG$$A_BOOLEAN_KEYWDS))
    THEN
	SIGNAL_STOP (.STATUS);

    RETURN (SS$_NORMAL);
    END;				! end of routine PARSE_BOOLEANS

%SBTTL 'PARSE_NUMERICS - parse numeric capabilities'
ROUTINE PARSE_NUMERICS =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse numeric capabilities by calling LIB$TPARSE with the 
! 	numeric state and keyword tables.  We use separate tables
!	in order to avoid bumping into the 220 keyword limit.
!
! CALLING SEQUENCE:
!
! 	status = PARSE_NUMERICS ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	STATUS;

!+
! Should have seen a NAME statement by the time we reach here.
!-
    IF .AP [PARAM_L_CUR_TERM_DEF] EQL 0
    THEN
	SIGNAL_STOP (SMG$_ERRLIN,
		     1, .SMG$$CURRENT_LINE,
		     SMG$_MISTERNAM);

!+
! Reuse the same TPARSE parameter block.
!-
    IF NOT (STATUS = LIB$TPARSE (.AP, SMG$$A_NUMERIC_STATES,
				 SMG$$A_NUMERIC_KEYWDS))
    THEN
	SIGNAL_STOP (.STATUS);

    RETURN (SS$_NORMAL);
    END;				! end of routine PARSE_NUMERICS

%SBTTL 'PARSE_REQUIRE - parse definitions in REQUIRE file'
ROUTINE PARSE_REQUIRE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	In order to parse the definitions contained in a REQUIRE file,
!	we call ourselve recursively.  Notice that the REQUIRE file may
!	contain another REQUIRE statement, etc.
!
! CALLING SEQUENCE:
!
! 	status = PARSE_REQUIRE ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	REQUIRE_FAB : $FAB_DECL,	! FAB for required file
	REQUIRE_RAB : $RAB_DECL,	! RAB for required file
	SAVED_FAB,			! addr of original FAB
	SAVED_RAB,			! addr of original FAB
	SAVED_CUR_LINE,			! cur line in original file
	TEMP_BUFFER : VECTOR [255,BYTE],! buffer to hold records
	OPEN_STATUS,			! status retd by $OPEN
	CLOSE_STATUS,			! status retd by $CLOSE
	STATUS;				! status retd by called routines

!+
! In order to parse records from a different file, we need to reset the
! FAB and RAB fields stored in the TPARSE parameter block.  We save the
! addresses of the original FAB and RAB so that we can continue reading
! those records when we are done here.
!-

    SAVED_FAB = .AP [PARAM_A_TXT_FAB];
    SAVED_RAB = .AP [PARAM_A_TXT_RAB];
    SAVED_CUR_LINE = .SMG$$CURRENT_LINE;
				! remember where we are in first file
    $FAB_INIT (FAB = REQUIRE_FAB, FNS = .AP [PARAM_L_SAVED_TOKENCNT],
	       FNA = .AP [PARAM_L_SAVED_TOKENSTR], DNM = '.TXT',
	       FAC = GET, SHR = GET, ORG = SEQ);

    IF NOT (OPEN_STATUS = $OPEN (FAB = REQUIRE_FAB))
    THEN
	SIGNAL_STOP (SMG$_FAIOPEFIL,
		     2, .AP [TPA$L_TOKENCNT],
		     .AP [TPA$L_TOKENPTR],
		     .OPEN_STATUS);

    AP [PARAM_L_SAVED_TOKENCNT] = 0;
    AP [PARAM_L_SAVED_TOKENSTR] = 0;
				! re-init

!+
! Connect a RAB to the FAB so we can access the file.
!-

    $RAB_INIT (RAB = REQUIRE_RAB, FAB = REQUIRE_FAB);

    $CONNECT (RAB = REQUIRE_RAB);

    REQUIRE_RAB [RAB$W_USZ] = 255;
    REQUIRE_RAB [RAB$L_UBF] = TEMP_BUFFER [0];
				! set up buffer for RMS to use
!+
! Put the new FAB and RAB into the parameter block.
!-

    AP [PARAM_A_TXT_FAB] = REQUIRE_FAB;
    AP [PARAM_A_TXT_RAB] = REQUIRE_RAB;

!+
! Call ourself recursively, reusing the current TPARSE block.
!-

    IF NOT (STATUS = LIB$TPARSE (.AP, SMG$$A_STMT_STATES,
				 SMG$$A_STMT_KEYWDS))
    THEN
	SIGNAL_STOP (.STATUS);

!+
! Restore the original FAB and RAB addresses to the parameter block.
!-

    AP [PARAM_A_TXT_FAB] = .SAVED_FAB;
    AP [PARAM_A_TXT_RAB] = .SAVED_RAB;

    SMG$$CURRENT_LINE = .SAVED_CUR_LINE;

!+
! Done with the required file, close it.
!-

    IF NOT (CLOSE_STATUS = $CLOSE (FAB = REQUIRE_FAB))
    THEN
	SIGNAL_STOP (.CLOSE_STATUS);

!+
! Get the next record from the original definition file.
!-

    CALLG (.AP, SMG$$NEXT_RECORD);

    RETURN (SS$_NORMAL);
    END; 				! end of routine PARSE_REQUIRE

%SBTTL 'PARSE_STRINGS - parse string capabilities'
ROUTINE PARSE_STRINGS =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse string capabilities by calling LIB$TPARSE with the string
!	state and keyword tables.  We use separate tables to avoid bumping
!	into the 220 keyword limit.
!
! CALLING SEQUENCE:
!
! 	status = PARSE_STRINGS ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	STATUS;

!+
! Should have seen a NAME statement by the time we reach here.
!-
    IF .AP [PARAM_L_CUR_TERM_DEF] EQL 0
    THEN
	SIGNAL_STOP (SMG$_ERRLIN,
		     1, .SMG$$CURRENT_LINE,
		     SMG$_MISTERNAM);

!+
! Reuse the same TPARSE block.
!-
    IF NOT (STATUS = LIB$TPARSE (.AP, SMG$$A_STRING_STATES,
				 SMG$$A_STRING_KEYWDS))
    THEN
	SIGNAL_STOP (.STATUS);

    RETURN (SS$_NORMAL);
    END;				! end of routine PARSE_STRINGS

%SBTTL 'SEARCH_KNOWN_TYPES - search table of known terminal types'
ROUTINE SEARCH_KNOWN_TYPES =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Search a table of DEC terminals to see if the user is using a
!	known terminal name in his definition.  (SMG will define DEC
!	terminals - users shouldn't but just in case...)  We want to
!	assign the positive DT$_xx type instead of a negative number
!	for DEC terminals.
!
! CALLING SEQUENCE:
!
! 	status = SEARCH_KNOWN_TYPES ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	TYPE : INITIAL (-1),		! terminal type
	PTR_UPCASED_NAME,		! addr of upcased terminal name
	TXT_RAB : REF $RAB_DECL;	! ptr to RAB for TERMTABLE.TXT
    MACRO
	TERM$B_TYPE = 1, 0, 8, 0%;

!+
! The saved tokenptr points to the user's original text.  For comparison
! purposes, we need to look at the upcased version.  So index into upcased
! buffer.
!-
    TXT_RAB = .AP [PARAM_A_TXT_RAB];

    PTR_UPCASED_NAME = .TXT_RAB [RAB$L_UBF] +
		       (.AP [PARAM_L_SAVED_TOKENSTR] - .AP [PARAM_L_ORIG_TXT]);

!+
! Search table of names indexed by type.
!-
    INCR INDEX FROM 0 TO TERM$_NUM -1 DO
        BEGIN
	BIND 
	    NAME = .TERM$_NAME [.INDEX] : $BBLOCK;
 	IF CH$EQL (.AP [PARAM_L_SAVED_TOKENCNT], .PTR_UPCASED_NAME,
		   .AP [PARAM_L_SAVED_TOKENCNT], .NAME [DSC$A_POINTER])
	THEN
	    BEGIN
	    TYPE = .TERM$_TABLE [.INDEX, TERM$B_TYPE];    
	    EXITLOOP;
	    END;
	END;				! end of INCR loop

!+
! If we found the name, then use its type number.  If we exit this routine
! without a type, the caller (START_NEW_TERM_DEF) will assign a negative
! terminal number.
!-

    IF .TYPE NEQ -1
    THEN
	BEGIN
	AP [TPA$L_NUMBER] = .TYPE;
	CALLG (.AP, SMG$$FLUSH_NUMERIC);	! put type into data buffer

	RETURN (SS$_NORMAL);
	END
    ELSE
	RETURN (0);			! tell caller to assign negative number

    END;				! end of routine SEARCH_KNOWN_TYPES

%SBTTL 'START_NEW_TERM_DEF - Start of a term def, init fields'
ROUTINE START_NEW_TERM_DEF =

!++
! FUNCTIONAL DESCRIPTION:
!
!	We are at the beginning of a terminal definition (ie. we just
!	encountered a NAME field).  We need to begin a new block, make
!	an entry into the terminal definition index, and initialize
!	some fields preceeding the capability pointers.
!
! CALLING SEQUENCE:
!
! 	status = START_NEW_TERM_DEF ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	TERM_INDEX : REF VECTOR [,BYTE], ! addr of terminal def index
	CUR_INDEX_BYTE;			! first available byte

    TERM_INDEX = .AP [PARAM_A_TERM_INDEX];
    CUR_INDEX_BYTE = .AP [PARAM_L_TERM_INDEX_SIZE];

!+
! If there is a current terminal definition, then there must be two
! NAMEs with no intervening END.
!-
    IF .AP [PARAM_L_CUR_TERM_DEF] NEQ 0
    THEN
	SIGNAL_STOP (SMG$_ERRLIN,
		     1, .SMG$$CURRENT_LINE,
		     SMG$_MISENDSTA);

!+
! Make an entry in the terminal definition index.  Since each
! terminal definition begins on a block boundary, all we need to
! store is the terminal name (a counted string) and the block number.
!-

    TERM_INDEX [.CUR_INDEX_BYTE] = .AP [PARAM_L_SAVED_TOKENCNT];
    CUR_INDEX_BYTE = .CUR_INDEX_BYTE + 1;
					
    CH$MOVE (.AP [PARAM_L_SAVED_TOKENCNT],
	     .AP [PARAM_L_SAVED_TOKENSTR],
	     TERM_INDEX [.CUR_INDEX_BYTE]);
    CUR_INDEX_BYTE = .CUR_INDEX_BYTE + .AP [PARAM_L_SAVED_TOKENCNT];
				! copy counted name string into index
    TERM_INDEX [.CUR_INDEX_BYTE] = .SMG$$CURRENT_DEF_BLOCK;	
				! store block number
    
    AP [PARAM_L_TERM_INDEX_SIZE] = .CUR_INDEX_BYTE + 1;
				! incr size of terminal index

!+
! Update pointer into the current terminal definition.  
!-

    AP [PARAM_L_CUR_TERM_DEF] = .AP [PARAM_A_CAP_PTRS];
				! point to beginning of buffer

!+
! Ready to fill in control fields which preceed the capability offsets.
!-

    BEGIN
    LOCAL
	CUR_TERM_DEF : REF VECTOR [,WORD],
	SAVED_CAP_NUMBER,
	TYPE_FOUND;

    CUR_TERM_DEF = .AP [PARAM_L_CUR_TERM_DEF];

    CUR_TERM_DEF [SMG$K_TERM_DEF_ID_OFFSET] = SMG$K_TERM_DEF_ID;
				! identify as a terminal definition
    !+
    ! If this is a foreign terminal, then VMS will not assign any
    ! DT$_xx number to it.  All the negative numbers are unused by
    ! the terminal driver, so assigning a unique negative number to
    ! the terminal identifies it as one that is defined in TERMTABLE.
    ! The DCL commands SET and SHOW will make use of this number.
    !-
    SAVED_CAP_NUMBER = .AP [PARAM_L_CUR_CAP_NUMBER];
    AP [PARAM_L_CUR_CAP_NUMBER] = SMG$K_VMS_TERMINAL_NUMBER;
				! replace NAME with type for writing data
    IF NOT (TYPE_FOUND = CALLG (.AP, SEARCH_KNOWN_TYPES))
    THEN
	BEGIN
	AP [TPA$L_NUMBER] = .SMG$$NEXT_NEGATIVE_NUMBER;
	CALLG (.AP, SMG$$FLUSH_NUMERIC);
	SMG$$NEXT_NEGATIVE_NUMBER = .SMG$$NEXT_NEGATIVE_NUMBER - 1;
	END;

    AP [PARAM_L_CUR_CAP_NUMBER] = .SAVED_CAP_NUMBER;
					! restore NAME
    END;

    RETURN (SS$_NORMAL);

    END;				! end of routine START_NEW_TERM_DEF

%SBTTL 'UNRECOGNIZED_STATEMENT - signal UNRECSTA error'
ROUTINE UNRECOGNIZED_STATEMENT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	We just found something that isn't one of the statements we know -
!	complain.
!
! CALLING SEQUENCE:
!
! 	UNRECOGNIZED_STATEMENT ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    SIGNAL_STOP (SMG$_ERRLIN,
		 1,
		 .SMG$$CURRENT_LINE,
		SMG$_UNRECSTA)

    END;				! end of routine UNRECOGNIZED_STATEMENT

%SBTTL 'ZERO_CUR_TERM_DEF - zero the current terminal definition pointer'
ROUTINE ZERO_CUR_TERM_DEF =

!++
! FUNCTIONAL DESCRIPTION:
!
!	We just encountered an END statement - mark that there is no
!	current terminal definition so that capabilities will not be
!	accepted before a new NAME statement is encountered.
!
! CALLING SEQUENCE:
!
! 	status = ZERO_CUR_TERM_DEF ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	BINARY_RAB : REF $RAB_DECL;	! point to RAB

!+
! Move the previous definition to TERMTABLE.EXE.  First write
! out the capability pointers.
!-

    BINARY_RAB = .AP [PARAM_A_BINARY_RAB];

    BINARY_RAB [RAB$W_RSZ] = SMG$K_CAP_PTRS_SIZE;
    BINARY_RAB [RAB$L_RBF] = .AP [PARAM_A_CAP_PTRS];
					! set up size & buffer addr
    BINARY_RAB [RAB$L_BKT] = .SMG$$CURRENT_DEF_BLOCK;
					! set virtual block number

    $WRITE (RAB = .BINARY_RAB);

!+
! See if any data needs to be written out.
!-

    CALLG (.AP, SMG$$WRITE_DATA);

!+
! Update the next available block number.
!-
  
    SMG$$CURRENT_DEF_BLOCK = .SMG$$CURRENT_BLOCK;
    SMG$$CURRENT_BLOCK = .SMG$$CURRENT_DEF_BLOCK + (SMG$K_CAP_PTRS_SIZE/512);
					! next data skips over pointers

!+
! Mark that there is no current definition.  Init some things that will be
! reused by the next definition.
!-

    AP [PARAM_L_CUR_TERM_DEF] = 0;

    CH$FILL (0, SMG$K_CAP_PTRS_SIZE, .AP [PARAM_A_CAP_PTRS]);
					! zero data offsets
    SMG$$DATA_OFFSET = SMG$K_CAP_PTRS_SIZE;
					! start with 1st offset again
    CH$FILL (0, SMG$K_CAP_DATA_SIZE, .AP [PARAM_A_CAP_DATA]);
					! zero the data buffer
    AP [PARAM_L_CUR_DATA_BYTE] = .AP [PARAM_A_CAP_DATA];
					! current data byte is 1st byte

    RETURN (SS$_NORMAL);
    END;				! end of routine ZERO_CUR_TERM_DEF

%SBTTL 'SMG$$BLANKS_OFF - Turn OFF bit to skip over blanks'
GLOBAL ROUTINE SMG$$BLANKS_OFF =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Turns OFF a bit in the TPARSE parameter block which controls
!	whether blanks are significant.
!
! CALLING SEQUENCE:
!
! 	status = SMG$$BLANKS_OFF ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    AP [TPA$V_BLANKS] = 0;

    RETURN (SS$_NORMAL);

    END;				! end of routine SMG$$BLANKS_OFF

%SBTTL 'SMG$$BLANKS_ON - Set bit to look at blanks'
GLOBAL ROUTINE SMG$$BLANKS_ON =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Sets a bit in the TPARSE parameter block that causes blanks
!	and tabs to be processed.
!
! CALLING SEQUENCE:
!
! 	status = SMG$$BLANKS_ON ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP 
	AP : REF BLOCK [,BYTE];

    AP [TPA$V_BLANKS] = 1;

    RETURN (SS$_NORMAL);

    END;				! end of routine SMG$$BLANKS_ON

%SBTTL 'SMG$$COPY_CAP - Copy a string capability into TERMTABLE.EXE'
GLOBAL ROUTINE SMG$$COPY_CAP =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Copies a string capability into TERMTABLE.EXE.  It uses the
!	current capability number to determine where to copy the string.
!
! CALLING SEQUENCE:
!
! 	status = SMG$$COPY_CAP ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

!+
! If this is the name capability, then we are starting a new terminal
! definition.  Start a new block and set up some pointers.
!-

    IF .AP [PARAM_L_CUR_CAP_NUMBER] EQL SMG$K_NAME
    THEN
	CALLG (.AP, START_NEW_TERM_DEF);

!+
! If this is not the NAME capability and we have no pointers set up
! for the terminal definition, then NAME was not the first capability
! in the definition.  Complain.
!-

    BEGIN
    BIND
	CAP_PTRS = .AP [PARAM_L_CUR_TERM_DEF] : VECTOR [,WORD];

    IF CAP_PTRS EQL 0
    THEN
	SIGNAL_STOP (SMG$_MISTERNAM);

!+
! Move the capability data.  The byte count is in the first byte and
! the actual data follows.
!
! Part of the string may already be copied - append in this part so
! as not to overwrite it.  (This can happen if escape or control are
! part of the sequence.)
!-

    IF .AP [PARAM_L_SAVED_TOKENCNT] NEQ 0
    THEN
	CALLG (.AP, SMG$$FLUSH_SAVED_BUFFER);
					! copy string into data area

    END;				! end of BINDs scope

    AP [TPA$V_BLANKS] = 0;		! out of string cap, skip over blanks

    RETURN (SS$_NORMAL);
    END;				! end of routine SMG$$COPY_CAP

%SBTTL 'SMG$$FLUSH_ARITHMETIC - flush arithmetic data to TERMTABLE'
GLOBAL ROUTINE SMG$$FLUSH_ARITHMETIC =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Because expressions don't follow the rules for numeric or string
!	data, this is a special routine to copy expression 'tokens' into
!	the data area.  Usually we want to just write to the current data
!	byte without regard for a size or type.
!
! CALLING SEQUENCE:
!
! 	status = SMG$$FLUSH_ARITHMETIC ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	START_COPY : REF VECTOR [,BYTE,SIGNED];

    $CHECK_BUFFER_OVERFLOW (.AP [PARAM_L_SAVED_TOKENCNT]);
				! make sure this will fit in the buffer
    START_COPY = .AP [PARAM_L_CUR_DATA_BYTE];

    CH$MOVE (.AP [PARAM_L_SAVED_TOKENCNT],
	     .AP [PARAM_L_SAVED_TOKENSTR],
	     START_COPY [0]);
					! move the data
    AP [PARAM_L_CUR_DATA_BYTE] = .AP [PARAM_L_CUR_DATA_BYTE] + 
				 .AP [PARAM_L_SAVED_TOKENCNT];
					! update next available byte
    SMG$$DATA_OFFSET = .SMG$$DATA_OFFSET + .AP [PARAM_L_SAVED_TOKENCNT];
					! update next available data offset
    $UPDATE_ARITH_STRING_SIZE (.AP [PARAM_L_SAVED_TOKENCNT]);
					! update size of expression
    AP [PARAM_L_SAVED_TOKENCNT] = 0;
    AP [PARAM_L_SAVED_TOKENSTR] = 0;
					! re-init
    RETURN (SS$_NORMAL);

    END;				! end of routine SMG$$FLUSH_ARITHMETIC

%SBTTL 'SMG$$FLUSH_NUMERIC - flush number to data area'
GLOBAL ROUTINE SMG$$FLUSH_NUMERIC =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Copies a boolean or numeric value into TERMTABLE.EXE.  It uses the
!	current capability number to determine where to copy it.
!
! CALLING SEQUENCE:
!
! 	status = SMG$$FLUSH_NUMERIC ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	CUR_TERM_DEF : REF VECTOR [,WORD],
	START_CAP_STRING : REF VECTOR [,BYTE,SIGNED];

    CUR_TERM_DEF = .AP [PARAM_L_CUR_TERM_DEF];
    IF .CUR_TERM_DEF EQL 0
    THEN
	SIGNAL_STOP (SMG$_MISTERNAM);   ! complain if no current def

    $CHECK_BUFFER_OVERFLOW (6);		! make sure there's room in buffer

    CUR_TERM_DEF [.AP [PARAM_L_CUR_CAP_NUMBER]] = .SMG$$DATA_OFFSET;
					! set cap ptr to data offset
    SMG$$DATA_OFFSET = .SMG$$DATA_OFFSET + 6;
					! update to next offset
    START_CAP_STRING = .AP [PARAM_L_CUR_DATA_BYTE];
					! point to next available data byte
    START_CAP_STRING [0] = 4;		! length
    CH$MOVE (4, AP [TPA$L_NUMBER], START_CAP_STRING [2]);
					! data
    AP [PARAM_L_CUR_DATA_BYTE] = .AP [PARAM_L_CUR_DATA_BYTE] + 6;
					! update next available data byte
  
    RETURN (SS$_NORMAL);
    
    END;				! end of routine SMG$$FLUSH_NUMERIC

%SBTTL 'SMG$$FLUSH_SAVED_BUFFER - flush saved token to data buffer'
GLOBAL ROUTINE SMG$$FLUSH_SAVED_BUFFER =

!++
! FUNCTIONAL DESCRIPTION:
!
! Append the saved token into the data area for the current capability.
! We must append the data rather than just copying it because tokens are
! inserted as they are discovered, so this may not be the first.
!
! CALLING SEQUENCE:
!
!
! 	status = SMG$$FLUSH_SAVED_BUFFER ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	CALLG,
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    IF .AP [PARAM_L_SAVED_TOKENCNT] EQL 0
    THEN
	RETURN (SS$_NORMAL)		! no string to copy
    ELSE
	BEGIN				! copy saved string
    	BIND
	    CAP_PTRS = .AP [PARAM_L_CUR_TERM_DEF] : VECTOR [,WORD];
    	LOCAL
	    FIRST : INITIAL (0),
	    START_CAP_STRING : REF VECTOR [,BYTE,SIGNED],
	    SIZE_TYPE : INITIAL (0);

	$CHECK_BUFFER_OVERFLOW (.AP [PARAM_L_SAVED_TOKENCNT]);
					! make sure there's room in the buffer
    	IF .CAP_PTRS [.AP [PARAM_L_CUR_CAP_NUMBER]] NEQ 0
        THEN
	    BEGIN
	    !+
	    ! Not start of the capability string.
	    !-
	    START_CAP_STRING = .AP [PARAM_L_CUR_TERM_DEF] +
			       .CAP_PTRS [.AP [PARAM_L_CUR_CAP_NUMBER]];
	    END
        ELSE
	    !+
	    ! First byte of capability string.  Set offset pointer.
	    !-
	    BEGIN
	    FIRST = 1;
	    START_CAP_STRING = .AP [PARAM_L_CUR_DATA_BYTE];
    	    CAP_PTRS [.AP [PARAM_L_CUR_CAP_NUMBER]]  = .SMG$$DATA_OFFSET;
	    END;

    	IF .START_CAP_STRING [1] NEQ SMG$K_ARITH_STRING
    	THEN
	    BEGIN
    	    CH$MOVE (.AP [PARAM_L_SAVED_TOKENCNT],
	             .AP [PARAM_L_SAVED_TOKENSTR],
	             START_CAP_STRING [2] + ABS (.START_CAP_STRING [0]));
 	    END
    	ELSE
	    BEGIN
	    BIND
	    	EMBEDDED_STRING = (START_CAP_STRING [2] + 
			           ABS (.START_CAP_STRING [0]) - 2)
				: VECTOR [,BYTE];
				! subtract arith size & type
	    EMBEDDED_STRING [0] = .AP [PARAM_L_SAVED_TOKENCNT];
	    EMBEDDED_STRING [1] = 0;		! positive count indicates string
	    CH$MOVE (.AP [PARAM_L_SAVED_TOKENCNT],
	  	     .AP [PARAM_L_SAVED_TOKENSTR],
		     EMBEDDED_STRING [2]);
	    SIZE_TYPE = 2;
	    END;

    	$INCR_CAP_STRING_SIZE ((.AP [PARAM_L_SAVED_TOKENCNT] + .SIZE_TYPE), 
				START_CAP_STRING [0]);
					! update # bytes in string

    	$INCR_CUR_DATA_BYTE ((.AP [PARAM_L_SAVED_TOKENCNT] + .SIZE_TYPE), .FIRST);
					! macro to update next available
					! data byte, data offset

    	AP [PARAM_L_SAVED_TOKENCNT] = 0;
    	AP [PARAM_L_SAVED_TOKENSTR] = 0;
					! re-init to no saved string

	IF .SMG$$MASK_ADR EQL SMG$K_FAO_STRING
   	THEN
	    BEGIN
	    !+
	    ! If this is an FAO string, then we should set the type
	    ! byte and negate the size byte.
	    !-
	    IF .START_CAP_STRING [0] GTR 0
	    THEN
		START_CAP_STRING [0] = -.START_CAP_STRING [0];
					! don't negate twice
	    START_CAP_STRING [1] = .SMG$$MASK_ADR;
					! set type byte
	    SMG$$MASK_ADR = 0;		! reset mask
	    END;

	END;				! copy saved string


    RETURN (SS$_NORMAL);

    END;				! end of routine SMG$$FLUSH_SAVED_BUFFER

%SBTTL 'SMG$$MISSING_END - signal missing end statement'
GLOBAL ROUTINE SMG$$MISSING_END =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Signal that some other statement occurred where there should have
!	been an END statement.
!
! CALLING SEQUENCE:
!
!
! 	SMG$$MISSING_END ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    SIGNAL_STOP (SMG$_ERRLIN,
		 1, .SMG$$CURRENT_LINE,
		 SMG$_MISENDSTA)

    END;				! end of routine SMG$$MISSING_END

%SBTTL 'SMG$$NEXT_RECORD - Get next record from TERMTABLE.TXT'
GLOBAL ROUTINE SMG$$NEXT_RECORD =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Gets the next record to be parsed from TERMTABLE.TXT.
!
! CALLING SEQUENCE:
!
! 	status = SMG$$NEXT_RECORD ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
! 	the string pointer and string count in the TPARSE
!	parameter block are updated to point to the new record
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];
    LOCAL
	TXT_RAB : REF $RAB_DECL,
	RMS_STATUS;

!+
! Get a record from TERMTABLE.TXT.  Use the private parameters
! appended to the TPARSE parameter block to find the RAB.
!-

    TXT_RAB = .AP [PARAM_A_TXT_RAB];
   
    DO 
	BEGIN
 	RMS_STATUS = $GET (RAB = .TXT_RAB);
	END
    UNTIL .RMS_STATUS NEQ RMS$_RSA;

    IF NOT (.RMS_STATUS) AND 
       .RMS_STATUS NEQ RMS$_EOF
    THEN
	SIGNAL_STOP (.RMS_STATUS);

!+
! Set TPARSE pointer to the new record.
!-

    IF .RMS_STATUS NEQ RMS$_EOF
    THEN
	BEGIN
	LOCAL
	    UP_STATUS,
	    SRC_STR : BLOCK [8,BYTE],
	    ORIG_STRING : BLOCK [8,BYTE],
	    COPY_STATUS;

	SMG$$CURRENT_LINE = .SMG$$CURRENT_LINE + 1;
					! maintain line number for errors
	!+
	! We need to parse an upcased string, but copy from
	! the user's original string, preserving lower case
	! escape sequences.  So save away the original string.
	!-

	ORIG_STRING [DSC$B_CLASS] = DSC$K_CLASS_S;
	ORIG_STRING [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ORIG_STRING [DSC$W_LENGTH] = 255;
  	ORIG_STRING [DSC$A_POINTER] = .AP [PARAM_L_ORIG_TXT];

	SRC_STR [DSC$B_CLASS] = DSC$K_CLASS_S;
	SRC_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	SRC_STR [DSC$W_LENGTH] = .TXT_RAB [RAB$W_RSZ];
	SRC_STR [DSC$A_POINTER] = .TXT_RAB [RAB$L_RBF];

	IF NOT (COPY_STATUS = STR$COPY_DX (ORIG_STRING, SRC_STR))
	THEN
	    SIGNAL_STOP (.COPY_STATUS);

	IF NOT (UP_STATUS = STR$UPCASE (SRC_STR, SRC_STR))
	THEN
	    SIGNAL_STOP (.UP_STATUS);

	AP [TPA$L_STRINGPTR] = .SRC_STR [DSC$A_POINTER];
	AP [TPA$L_STRINGCNT] = .SRC_STR [DSC$W_LENGTH];
	END
    ELSE
	BEGIN
	!+
	! Tell LIB$TPARSE there's no more to parse.
	!-
	AP [TPA$L_STRINGPTR] = UPLIT (BYTE (NULL));
	AP [TPA$L_STRINGCNT] = 1;
	END;

    RETURN (SS$_NORMAL);

    END;					! end of routine SMG$$NEXT_RECORD

%SBTTL 'SMG$$SAVE_TOKEN_STRING - Save count & pointer to current token'
GLOBAL ROUTINE SMG$$SAVE_TOKEN_STRING =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Save a pointer to the start of the capability string, and
!	maintain a count of the characters.
!
! CALLING SEQUENCE:
!
! 	status = SAVE_TOKEN_STRING ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

!+
! TPARSE maintains a pointer to the current character but what we need
! is all the characters between quotes - they are the current capability
! string.  So we maintain our own pointer into the TPARSE input string.
! (COPY_CAP will use this information to copy the current capability.
! COPY_CAP also re-initializes the count & pointer to zero after it does
! its job.)
!
! Note that we store a pointer to the user's original string, not the
! string that we parsed.  This is because the parse string has been
! upcased but we need to preserve lower case letters in an escape sequence.
!
! For a numeric string, there are no quotes delimiting the string - we
! will be storing all digits.
!-

    IF .AP [PARAM_L_SAVED_TOKENSTR] EQL 0
    THEN
	!+
	! Only save the pointer the first time we're called.
	!-
	BEGIN
	LOCAL
	    TXT_RAB : REF $RAB_DECL,
	    OFFSET;

	TXT_RAB = .AP [PARAM_A_TXT_RAB];
	OFFSET = .AP [TPA$L_TOKENPTR] - .TXT_RAB [RAB$L_RBF];
					! compute offset into parsed buffer
	AP [PARAM_L_SAVED_TOKENSTR] = .AP [PARAM_L_ORIG_TXT] + .OFFSET;
	END;

    AP [PARAM_L_SAVED_TOKENCNT] = .AP [PARAM_L_SAVED_TOKENCNT] +
				  .AP [TPA$L_TOKENCNT];

    RETURN (SS$_NORMAL);

    END;				! end of routine SMG$$SAVE_TOKEN_STRING

%SBTTL 'SMG$$STORE_CAP_MASK - Store the capability mask'
GLOBAL ROUTINE SMG$$STORE_CAP_MASK =

!++
! FUNCTIONAL DESCRIPTION:
!
!	The capability mask is actually the capability number.  We
!	need to remember this so that we store the data in the correct
!	location.
!
! CALLING SEQUENCE:
!
!
! 	status = SMG$$STORE_CAP_MASK ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP 
	AP : REF BLOCK [,BYTE];

    !+
    ! Remember the capability number so that when we find the associated 
    ! value, we know where to store it.  The capability number is used as
    ! an index.
    !-

    AP [PARAM_L_CUR_CAP_NUMBER] = .SMG$$MASK_ADR;
    SMG$$MASK_ADR = 0;			! clear for next cap number

    RETURN (SS$_NORMAL);

    END;				! end of routine SMG$$STORE_CAP_MASK

%SBTTL 'SMG$$SYNTAX_ERROR - Signal a syntax error'
GLOBAL ROUTINE SMG$$SYNTAX_ERROR =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Signal that a syntax error occurred while parsing TERMTABLE.TXT.
!
! CALLING SEQUENCE:
!
!
! 	SMG$$SYNTAX_ERROR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP
	AP : REF BLOCK [,BYTE];

    SIGNAL_STOP (SMG$_ERRAT_LIN,
		 3, .SMG$$CURRENT_LINE,
		 .AP [TPA$L_TOKENCNT],
		 .AP [TPA$L_TOKENPTR],
		 SMG$_SYNERR)

    END;				! end of routine SMG$$SYNTAX_ERROR

%SBTTL 'SMG$$WRITE_DATA - perform block I/O write of data to file'
GLOBAL ROUTINE SMG$$WRITE_DATA =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes the terminal data to TERMTABLE.EXE using
!	block I/O.
!
! CALLING SEQUENCE:
!
!
!  	SMG$$WRITE_DATA ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to TPARSE parameter block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	 SS$_NORMAL
!
! SIDE EFFECTS:
!
!--

    BEGIN
    BUILTIN
	AP;
    MAP 
	AP : REF BLOCK [,BYTE];
    LOCAL
	BINARY_RAB : REF $RAB_DECL,	! point to RAB
	NUM_BYTES,			! number of bytes to write
	NUM_BLOCKS : INITIAL (0);	! number of blocks used

    BINARY_RAB = .AP [PARAM_A_BINARY_RAB];

    NUM_BYTES = .AP [PARAM_L_CUR_DATA_BYTE] - .AP [PARAM_A_CAP_DATA];
    BINARY_RAB [RAB$W_RSZ] = .NUM_BYTES;
    BINARY_RAB [RAB$L_RBF] = .AP [PARAM_A_CAP_DATA];
					! set up size & buffer addr
    BINARY_RAB [RAB$L_BKT] = .SMG$$CURRENT_BLOCK;
					! set virtual block number

    $WRITE (RAB = .BINARY_RAB);

!+
! Update the next available block number.
!-
  
    WHILE .NUM_BYTES GEQ 1 DO
    BEGIN
	NUM_BYTES = .NUM_BYTES - 512;
	NUM_BLOCKS = .NUM_BLOCKS + 1;
    END;

    SMG$$CURRENT_BLOCK = .SMG$$CURRENT_BLOCK + .NUM_BLOCKS;

    RETURN (SS$_NORMAL);
    END;				! end of routine SMG$$WRITE_BLOCK

!<BLF/PAGE>

END					! End of module SMG$STATEMENT_TABLES

ELUDOM
