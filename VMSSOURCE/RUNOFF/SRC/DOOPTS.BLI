%TITLE 'Digests and distributes command line information.'
MODULE DOOPTS (	IDENT = 'V04-000'
		%BLISS32[, ADDRESSING_MODE (EXTERNAL    = LONG_RELATIVE,
					    NONEXTERNAL = LONG_RELATIVE)]
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY:	 DSR (Digital Standard RUNOFF) / DSRPLUS
!
! ABSTRACT: Digests and distributes options specified to RUNOFF.
!
!
! ENVIRONMENT: Transportable
!
! AUTHOR: R.W.Friday	 CREATION DATE: September, 1978

%SBTTL 'Revision History'
!
! MODIFIED BY:
!
!	064	REM00064	Ray Marshall	17-May-1984
!		Added support to pickup DIAG2_15 and move it into GCA_CMD_OSQ.
!		  This diag flag was set by /DEC_INTERNAL=OUTPUT_LINE_NUMBER.
!
!	063	REM00063	Ray Marshall	10-April-1984
!		Changed the referenct to the string terminator module for the
!		  LN01 font load sequence from ST to ANSI$ST.
!
!	062	REM00062	Ray Marshall	3-4-April-1984
!		Changed the NOHEADER qualifier back to the way it worked before
!		  -- it now will only suppress the OSC escape sequences, but
!		  not the other escape sequences.
!		Added logic to force the output of a <FF> record after all of
!		  the normal LN01 escape sequences.  This is done by magic:
!		  we increment PHAN_LINES_TP, and later on the new page gets
!		  thrown.  This method also makes sure that the proper number
!		  of lines are output on the first page.  If we write the
!		  formfeed ourselves (herein), we end up with one more line
!		  on the first page then was requested (or expected).
!		We also reduced the automatic /DOWN=3 to /DOWN=2 for LN01
!		  output files.  As before, this automatic value will be
!		  overriden by any user specified value.
!
!	061	REM00061	Ray Marshall	6-December-1983
!		Made still more changes to the implementation of [NO]HEADER.
!		  It seems that we do want to redefine the fonts, but just
!		  not load them.  Also, the logic was modified to suppress
!		  the building of the font module name strings if NOHEADER
!		  was specified.
!		Reformatted some the code around the LN01 processing to make
!		  it read easier and take up fewer lines.
!
!	060	REM00060	Ray Marshall	5-December-1983
!		Made the NOHEADER parameter suppress everything between and
!		  including the two OSC escape sequences.  This is an LN01
!		  feature.
!		Also added RNO$V_LN01_LOAD to control the writing of the OSC
!		  escape sequence that actually causes the loading of fonts.
!
!	059	REM00059	Ray Marshall	22-November-1983
!		Made final (for now) changes to the LN01 output.  It now
!		  conforms to what both VMS and LN01 development groups
!		  say it should be.
!
!	058	REM00058	Ray Marshall	18-November-1983
!		Made more changes to the LN01 output.  Amoung other things,
!		  all DSR_ strings were changed to DSR$.
!		Also fixed a slight bug in the output for the EXTRACT.
!
!	057	KFA00057	Ken Alden	11-Oct-1983
!		Made LN01 margin fix.
!
!	056	KFA00056	Ken Alden	10-Oct-1983
!		Fixed 055.
!
!	055	KFA00055	Ken Alden	07-Oct-1983
!		Added gca_cmd_pages to flag the /PAGES qualifier.
!
!
!	054	REM00054	Ray Marshall	4-Oct-1983
!		Correct LN01 font loading sequence.  The OSC sequence has
!		  been redefined by VMSland.  Also, the names of the modules
!		  to be extracted from the symbiont's text library have been
!		  changed from COU72... to DSR_FONT_... and the font loading
!		  module name has been changed from FL to DSR_FONT_LOAD.
!
!	053	KFA00053	Ken Alden	12-Sep-1983
!		Added functionality to LN01 output since the user
!		  may now elect to suppress the ln01 header output(symbiont
!		  information).
!
!	052	KFA00052	Ken Alden	18-Aug-1983
!		Fixed a logical name translation bug with brn file names.
!		  Problem was in using an outdated XPORT macro.
!
!	051	KFA00051	Ken Alden	28-Jun-1983
!		/QUICK processing now just calls SETQUICK (false).
!		The routine SETQUICK is now located in this module.
!
!	050	KFA00050	Ken Alden	24-Jun-1983
!		Deleted some of Ray's logic in setting setquick to 
!		  prevent making a .mem file on the first run of a /auto
!		  file, regardless of whether it had an old brn file or not.
!
!	049	REM00049	Ray Marshall	22-June-1983
!		Modified logic around call to REABRN.  That routine now
!		  validates the BRN and if invalid, will set GCA_OLD_BRN_EXISTS
!		  to be false.  Therefore, we must test it again after returning
!		  from REABRN to determine /QUICK & /AUTOMATIC processing.
!
!	048	KFA00048	Ken Alden	14-Jun--1983
!		/AUTOMATIC now implies /CROSS.
!
!	047	KAD00047	Keith Dawson	2-Jun-1983
!		For LN01, make the user's /DOWN value override if specified.
!
!	046	KAD00046	Keith Dawson	25-May-1983
!		Minor changes to LN01 Font Assignment escape sequence 
!		  due to updated microcode.
!
!	045	KAD00045	Keith Dawson	16-May-1983
!		/DEVICE=FLIP again asserts gca_bix and gca_btc. Lost call 
!		  to PUTRTY (for .BFL-initialization information) reinserted.
!
!	044	KAD00044	Keith Dawson	11-May-1983
!		/DEVICE=FLIP does not assert gca_bix and gca_btc.
!
!	043	KAD00043	Keith Dawson	4-May-1983
!		For LN01 output, initially issue Default Font Invocation 
!		  escape sequence.
!
!	042	KAD00042	Keith Dawson	18-April-1983
!		Minor tweaks to LN01 output: issue escape sequence to 
!		  return to top of page. Do not quote font names. Set the 
!		  values of /RIGHT and /DOWN (unless the user gave values 
!		  for them) to move LN01 output off the upper-left of the 
!		  paper.
!		Remove all LN01 conditionals.
!
!	041	KAD00041	Keith Dawson	14-April-1983
!		/CROSS now ==> /INTERMEDIATE. Bit gca_expand_cref is not 
!		  turned off if no pre-existing .BRN. 
!
!	040	KAD00040	Keith Dawson	11-April-1983
!		Added support for new termination error messages for 
!		  information written to .BRN file. This involved adding 
!		  another formal to the RGH routine; this third formal is 
!		  TRUE or FALSE, as the caller determines whether or not to 
!		  increment the count of information written to the .BRN file.
!
!	039	KAD00039	Keith Dawson	8-Apr-1983
!		Make /NOCROSS the default.
!
!	038	KAD00038	Keith Dawson	7-Apr-1983
!		Consolidate support for SETQUICK routine (which is in 
!		  DOAUTO). Do not try to open old .BRN file if input 
!		  file is a terminal.
!
!	037	KAD00037	Keith Dawson	5-Apr-1983
!		Full support for /CROSS and /AUTO.
!
!	036	REM00036	Ray Marshall	4-April-1983
!		Added support for /DEBUG=(CROSS,SAVE).
!
!	035	KAD00035	Keith Dawson	21-Mar-1983
!		Added LN01 support. Got rid of /OVERPRINT.
!
!	034	KAD00034	Keith Dawson	20-Mar-1983
!		Removed all references to .BIX and .BTC files.
!
!	033	KFA00033	Ken Alden	07-Mar-1983
!		Global edit of all modules. Updated module names, idents,
!		copyright dates. Changed require files to BLISS library.
!
!--

%SBTTL 'Module Level Declarations'
!
! TABLE OF CONTENTS:
!
REQUIRE 'REQ:RNODEF';			! RUNOFF variant definitions

FORWARD ROUTINE
    DOOPTS,
    setquick : NOVALUE,
    write_ln01_info : NOVALUE;
!
! INCLUDE FILES:
!

LIBRARY 'NXPORT:XPORT';			! XPORT Library

%IF DSRPLUS %THEN
LIBRARY 'REQ:DPLLIB';			! DSRPLUS BLISS Library
%ELSE
LIBRARY 'REQ:DSRLIB';			! DSR BLISS Library
%FI

!
! MACROS:
!
MACRO
    erm_t (rnfcode, str_descr) =
	! This macro, ERM_T, is used to output as part of an error message a
	!   string described by an XPORT string descriptor.
	BEGIN
	BIND
	    temp = str_descr : $STR_DESCRIPTOR ();
	erme (rnfcode, .temp [STR$A_POINTER], .temp [STR$H_LENGTH], .semcod)
	END
    %;

!
! EQUATED SYMBOLS:
!

LITERAL
    escape = 27,			! Used for LN01 escape sequences.
    ppi = 300;				! Pixels-per-inch resolution of LN01.

EXTERNAL LITERAL
    RINTES : UNSIGNED (8);
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!
EXTERNAL LITERAL 				!Error messages
    RNFCEM,		! Comma expected, missing: "<%S>"
    RNFCOB,		! Can't open binary file
    RNFINM,		! Illegal number value: <qualifier>
    RNFIVS,		! Illegal /VARIANT qualifier
    RNFTMP,		! Too many page ranges on /PAGES qualifier
    RNFTMV;		! Too many /VARIANTs

EXTERNAL
    fs01 : fixed_string,
    fra : fixed_string,
    gca : gca_definition,
    hct : hct_definition,
    khar,
    spager : BLOCKVECTOR [1,page_sct_size],
    tpager : BLOCKVECTOR [1,page_sct_size],
    rnoiob : REF $XPO_IOB (),
    rniiob : REF $XPO_IOB (),
    brniob : $XPO_IOB (),
    brnoob : $XPO_IOB (),
    ffname : $STR_DESCRIPTOR (CLASS = DYNAMIC),	!Failure filename destination
    semcod,
    outopt : outopt_define,
    phan : phan_definition,
    sca : sca_definition,
    tsiiob : $XPO_IOB (),
    vrcnt;

EXTERNAL ROUTINE
    bars,	bwait,		clh,
    erm,	erme,		grab_resultant,
    gname,	parsep,		putrty,		rgh,
%IF DSRPLUS %THEN
    reabrn, 	
%FI
    vrentr,	vrfind;

%SBTTL 'DOOPTS -- ROUTINE header'
GLOBAL ROUTINE DOOPTS (RNO_CMD) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	DOOPTS interprets the qualifiers that the user specified on
!	the command line. Information is disseminated to various
!	RUNOFF control structures.
!
! FORMAL PARAMETERS:
!
!	RNO_CMD is the preprocessed set of qualifiers.
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:	None
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--

    BEGIN

    OWN
	u_ext : VECTOR [CH$ALLOCATION (4)],
	u_ext_ptr,
	type_length,
	type_ptr,
	prse_spec_block : $XPO_SPEC_BLOCK,
	range_error_flag;

    MAP
	rno_cmd : REF $rno_cmd;

    range_error_flag = 0;		! Turn it off to start with.

%SBTTL 'DOOPTS -- Process .RNH file type'
    !See if the user specified a .RNH input file, and if so apply special formatting rules.
    BEGIN

    !Get the input file type.
    $XPO_PARSE_SPEC (	 SPEC_BLOCK = prse_spec_block
			,FILE_SPEC = rniiob [IOB$T_RESULTANT] );

    !Get the length and location of the file type
    BEGIN
    BIND
	temp = prse_spec_block [XPO$T_FILE_TYPE] : $STR_DESCRIPTOR ();
    type_length = .temp [STR$H_LENGTH];
    type_ptr = .temp [STR$A_POINTER];
    END;

    IF 	.type_length EQL 4
    THEN 					!
    !Check further to see if the type is '.RNH'.
	BEGIN
	!First convert the file type to upper case.
	u_ext_ptr = CH$PTR (u_ext);

	INCR i FROM 1 TO 4 DO
	    BEGIN

	    LOCAL
		kahr;

	    kahr = CH$RCHAR_A (type_ptr);

	    IF lower_letter (.kahr)
	    THEN
		CH$WCHAR_A (upper_letter (.kahr), u_ext_ptr)
	    ELSE
		CH$WCHAR_A (.kahr, u_ext_ptr)
	    END;

	u_ext_ptr = CH$PTR (u_ext);

	IF CH$EQL (4, .u_ext_ptr, 4, CH$PTR (UPLIT ('.RNH')))
	THEN 					!
	!It is a .RNH input file.
	    BEGIN
	    hct_headers = false;		!No page headers wanted.
	    phan_paging = false;		!Don't divide document into pages.
	    phan_cmd_paging = false;		!...
	    sca_rm = 72;			!Set right margin to 72.
	    gca_lwidth = 72;			!...
	    END;
	END;
    END;

%SBTTL 'DOOPTS -- Process /PAGES switch'

    IF .rno_cmd [rno$h_pages] GTR 0
    THEN
    !User did specify some pages.
	BEGIN

	LOCAL
	    ira : VECTOR [4];

	!Set up dummy fixed string, so other routines can do parsing.

	MAP
	    ira : fixed_string;

	fs_start (ira) = .rno_cmd [rno$a_pages];
	fs_next (ira) = .fs_start (ira);
	gca_com_start = .fs_start (ira);	! Hack needed to tell the error
						! message handler where the
						! start of the string is.
	fs_maxsize (ira) = .rno_cmd [rno$h_pages];
	fs_length (ira) = .fs_maxsize (ira);

	!Initialize working string.

	fs_init (fs01);
	kcns ();
	
!Collect list of pages.
INCR i FROM 0 TO (max_page_ranges - 1) DO

    !Attempt to get a page number.
    IF  NOT parsep (ira, spager [.i, sct_typ])
    THEN
	RETURN FALSE				!Invalid page number.
    ELSE
    !Valid page number.  Attempt to pick up a terminating page.
	BEGIN

	BIND 					!Clear terminating page.
	    x = tpager [.i, sct_typ] : VECTOR;	!...

	INCR i FROM 0 TO (page_sct_size - 1) DO	!...
	    x [.i] = 0;				!...

	gca_orange_cnt = .i + 1;		!Remember page-range count.

	IF .khar NEQ rintes
	THEN
	!The parse of the initial page did not exhaust the entire
	!list of pages.  If a ':' follows, a terminating page must
	!have been given.  Otherwise, there must be a ',' to
	!introduce a new page.
	    BEGIN

	    !For PDP-11: recognize | or : as range-indicator.
	    IF .khar EQL %C':' OR .khar EQL %C'|'
	    THEN
	    !A terminating page number has to follow.
	    !Attempt to pick it up.
		BEGIN
		kcns ();			!Skip the ':'

		IF NOT parsep (ira, tpager [.i, sct_typ])
		THEN
		    RETURN false		!Bad or missing page number.
		END;

	    !Got the terminating page number successfully.
	    !See if another page range might follow.
	    IF  .KHAR EQL RINTES
	    THEN
		EXITLOOP;			!Nothing left.

	    !Something still there after the last page number.
	    IF  .khar EQL %C',' OR .khar EQL %C';'
	    THEN
	    !Yes, there should be another. For now just skip the ','. 
	    !The next pass through the loop will get the next one.
		kcns ()
	    ELSE
	    !Tell user a comma is (probably) missing
		BEGIN
		erm (rnfcem, .fs_start(ira), .fs_maxsize(ira));
		RETURN false;
		END

	    END

	ELSE
	!The list of pages has been completely scanned, and everything went ok.
	    EXITLOOP

	END;					!End of loop.

	!Be sure the user did not specify too many page ranges.
	IF .khar NEQ rintes
	THEN
	!User specified too many page ranges.  Give up.
	    BEGIN
	    erm (rnftmp, 0, 0);
	    RETURN false;
	    END;

        IF .rno_cmd [rno$h_pages] GTR 0
   	THEN
    	    gca_cmd_pages = true;		!Set a flag saying that user said /PAGES
	gca_skip_out = true;		!Start with output suppressed.
	END;

%SBTTL 'DOOPTS -- Process /AUTOMATIC switch'

%IF DSRPLUS %THEN

    ! /AUTOMATIC switch
    gca_black_box = false;			! Assume /NOAUTOMATIC
    
%IF %BLISS (BLISS32) %THEN
    IF .rno_cmd [rno$v_automatic] 
    THEN 
	BEGIN
	gca_bix = true;
	gca_btc = true;
	gca_cmd_btc = true;
	gca_black_box = true;
	rno_cmd [rno$v_intermediate] = true;	! Force generation of a BRN file
    	rno_cmd [rno$v_cross_reference] = true; ! Turn on cross referencing.
	END;
%FI

%SBTTL 'DOOPTS -- read crossreference information from old .BRN file'

    gca_old_brn_exists = false;			! Assume it doesn't.

    IF	( .gca_black_box OR .rno_cmd [rno$v_cross_reference] )
       AND NOT
	( .rniiob [IOB$V_TERMINAL] )
    THEN					! /AUTOMATIC or /CROSS_REFERENCE
	BEGIN
	LOCAL
	    status;
	$XPO_IOB_INIT (IOB = brniob);

	! Check to see if an old version of the BRN file exists.
	!
	status = $XPO_OPEN ( IOB     =	brniob
			, FILE_SPEC  =	'.BRN'
			, RELATED    =	rniiob [IOB$T_RESULTANT]
			, OPTIONS    =	INPUT
			, ATTRIBUTES =	BINARY
			, FAILURE    =	0);
	IF .status 
	THEN
	    gca_old_brn_exists = true;
	END;

%sbttl 'DOOPTS -- Process /CROSSREFERENCE switch'

    gca_expand_cref = false;		! Assume we won't expand.
!+
! /NOCROSS is overridden by /AUTO. So we don't allow users to say /NOCROSS
! and /AUTO to produce a complete document, but without cross-references
! expanded. 
!
! /CROSS turns on /INTERMEDIATE as well, unless the user said /NOINTER.
!-
    gca_cross_reference = ( .rno_cmd [rno$v_cross_reference] OR .rno_cmd [rno$v_automatic] );

    IF .gca_cross_reference
    THEN
	BEGIN					! User said /CROSS_REFERENCE or /AUTO.

	gca_expand_cref = true;			! So expand cross references.

!**new
	! The following logic will force generation of a BRN file unless
	! /NOINTERMEDIATE was explicitly specified.
	!
	rno_cmd [rno$v_intermediate] =
	    (.rno_cmd [rno$v_intermediate]
	   OR
	    NOT .rno_cmd [rno$v_s_intermediate]);

%IF %BLISS (BLISS32) %THEN			! Multi-pass logic only for BLISS32.
	IF .gca_pass_count EQL 1
	THEN
	    BEGIN				! First pass.
%FI

	    ! If there is an "old" BRN, validate it.  If valid, read it.

	    IF .gca_old_brn_exists THEN
		reabrn ();			! Read in existing BRN file.

%IF %BLISS (BLISS32) %THEN

	    ! If there wasn't an "old" BRN (or REABRN found it to be invalid),
	    ! and /AUTOMATIC has been asserted,  set /QUICK and initialize
	    ! automatic operation.

!!	    IF NOT .gca_old_brn_exists AND .gca_black_box
	    IF .gca_black_box
	    THEN			! User said /AUTOMATIC.
		BEGIN
		setquick (true);	! Pretend user said /QUICK.

		IF .gca_rerun_count EQL 0
		THEN
		    gca_rerun_count = 1	! Need a second pass at input file.
		END
	    END;
%FI
	END;

    IF .gca_old_brn_exists 
    THEN						! Old BRN file exists and is open.
	$XPO_CLOSE (IOB = brniob, OPTIONS = REMEMBER);	! Close it and remember its name.
%FI

%SBTTL 'DOOPTS -- Process /INTERMEDIATE switch'
    IF .rno_cmd [rno$v_intermediate]
		 AND NOT
	(.rno_cmd [rno$v_4_out_format] EQL op_dev_flip)

    THEN
    !User said /INTERMEDIATE (and is not generating FLIP output).
    !So we will open a .BRN file and write both indexing and contents 
    !information into it.
    !
	BEGIN
	LOCAL
	    status;

	! Open the output BRN file.
	status = $XPO_OPEN ( IOB = brnoob
			    ,FILE_SPEC = rno_cmd [rno$t_intermediate]
			    ,DEFAULT = ('.BRN')
			    ,RELATED = rniiob [IOB$T_RESULTANT]
			    ,FAILURE = grab_resultant
			    ,OPTIONS = OUTPUT
			    ,ATTRIBUTES = BINARY );

	IF NOT .status THEN
	    BEGIN
	    erm_t (rnfcob, ffname);
	    RETURN false;
	    END
	ELSE
	    BEGIN
	    !Now that the file has been opened successfully, initialize it 
	    !with a BRN header record.
	    LOCAL
		temp : VECTOR [2];
	!+
	!Write the .BRN File Identification Record Group. It identifies the 
	!format of the .BRN file, and of the indexing, contents, and cross-
	!reference information in it. This lets INDEX, CONTENTS, and DSRPLUS 
	!decide if they are prepared to read this format.
	!-
	    temp [0] = brn_file;
	    temp [1] = brn_ident;
	    !
	    !Write these records as the first information in the file.  
	    $XPO_PUT ( IOB = brnoob, BINARY_DATA = (2, temp) );

	    !Write a Record Group Header for Indexing information.
	    ! Do count this record in the .BRN count.
	    rgh (brn_index, 1, false);
	    !
	    !Add the New .BIX File Record Group.
	    temp [0] = new_sequence + (index_format^(%BPVAL/2));
	    !
	    $XPO_PUT ( IOB = brnoob, BINARY_DATA = (1, temp) );

	    !Write a Record Group Header for Contents information.
	    ! Do count this record in the .BRN count.
	    rgh (brn_contents, 2, false);
	    !
	    !Add the New .BTC File Record Group.
	    temp [0] = maj_new_toc;
	    temp [1] = toc_format;
	    !
	    $XPO_PUT ( IOB = brnoob, BINARY_DATA = (2, temp) );

	    !Write a Record Group Header for Cross-Reference information.
	    ! Do count this record in the .BRN count.
	    rgh (brn_crossref, 2, false);
	    !
	    !Add the New Cross-Reference Record Group.
	    temp [0] = new_crossref;
	    temp [1] = crossref_format;
	    !
	    $XPO_PUT ( IOB = brnoob, BINARY_DATA = (2, temp) );
	!+
	! End of .BRN File Identification Record Group.
	!-
	    gca_bix = true;			!Set binary-index flag.
	    gca_btc = true;			!Set binary-toc flag.
	    gca_cmd_btc = true;			!...
	    END;
	END
    ELSE
	BEGIN
	gca_bix = false;
	gca_btc = false;
	gca_cmd_btc = false;
	END;

%SBTTL 'DOOPTS -- Process /VARIANT switch'
%IF DSRPLUS %THEN
    !
    ! Hard-wire the variant "DSRPLUS", and also FLIP if the user said
    ! /DEC=FLIP.
    !
    BEGIN			!Local definition block
    LOCAL
	temp_ptr;
    temp_ptr = CH$PTR (UPLIT ('DSRPLUS'));
    vrentr (.temp_ptr, 7, %c' ', %c' ', 0, true);

%IF FLIP %THEN
    IF (.gca_op_dev EQL op_dev_flip) 
    THEN
	BEGIN
	temp_ptr = CH$PTR (UPLIT ('FLIP'));
	vrentr (.temp_ptr, 4, %c' ', %c' ', 0, true);
	END;
%FI
    END;			!End of local definition block
%FI

    IF .rno_cmd [rno$h_variant] GTR 0
    THEN		!User did specify at least one /VARIANT.
	BEGIN
	LOCAL
	    ira : VECTOR [4],
	    gncc;

	!Fix up IRA to look like a fixed string so other routines
	!can do some parsing.
	MAP
	    ira : fixed_string;

	fs_start (ira) = .rno_cmd [rno$a_variant];
	fs_next (ira) = .fs_start (ira);
	fs_maxsize (ira) = .rno_cmd [rno$h_variant];
	fs_length (ira) = .fs_maxsize (ira);
	kcns ();				!Start the scan.

	WHILE .khar NEQ rintes DO
	    BEGIN
	    fs_init (fs01);

	    IF gname (ira, fs01) NEQ gname_normal
	    THEN		!Bad variable name. Abort entire command line.
		BEGIN
		erm (rnfivs, 0, 0);
		RETURN false;
		END;

	    IF .vrcnt GEQ max_vr_names
	    THEN 		!Too many variants. Abort entire command line.
		BEGIN
		erm (rnftmv, 0, 0);
		RETURN false;
		END;

	    IF vrfind (.fs_start (fs01), .fs_length (fs01)) EQL -1
	    THEN 		!This is a brand new name, so save it marked as TRUE.
		vrentr (.fs_start (fs01), .fs_length (fs01), %C' ', %C' ', 0, true)
	    ELSE 		!Ignore duplicates
		(0);

	    !For PDP-11: recognize ; or , as variant-separator.
	    IF .khar EQL %C',' OR .khar EQL %C';'
	    THEN 		!Skip separator. This is a list of names.
		kcns ()
	    ELSE
		IF .khar NEQ rintes
		THEN 		!Garbage after the variable name.
				!Abort the entire command line.
		    BEGIN
		    erm (rnfivs, 0, 0);
		    RETURN false;
		    END;
	    END;
	END;

%SBTTL 'DOOPTS -- Check range of numeric parameters'

    IF (.rno_cmd[rno$h_bold] LSS 0  OR
	.rno_cmd[rno$h_bold] GTR 10 )
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/BOLD')), 5);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF (.rno_cmd[rno$h_down] LSS 0  OR
	.rno_cmd[rno$h_down] GTR 200 )
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/DOWN')), 5);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF (.rno_cmd[rno$h_form_size] LSS 0 OR
	.rno_cmd[rno$h_form_size] GTR 200 )
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/FORM_SIZE')), 10);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF (.rno_cmd[rno$h_right] LSS 0  OR
	.rno_cmd[rno$h_right] GTR 150  )
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/RIGHT')), 6);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF	(.rno_cmd[rno$v_s_underline] AND .rno_cmd[rno$c_underline] NEQ 0 AND
		(.rno_cmd[rno$c_underline] LSS 32 OR	! These values describe
		 .rno_cmd[rno$c_underline] GTR 125 ))	! "printable" characters
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/UNDERLINE')), 10);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF	(.rno_cmd[rno$v_s_und_separ] AND .rno_cmd[rno$c_underline] NEQ 0 AND
		(.rno_cmd[rno$c_underline] LSS 32 OR	! These values describe
		 .rno_cmd[rno$c_underline] GTR 125 ))	! "printable" characters
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/SEPARATE_UNDERLINE')), 19);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF	(.rno_cmd[rno$v_s_und_nonsp] AND .rno_cmd[rno$c_underline] NEQ 0 AND
		(.rno_cmd[rno$c_underline] LSS 0  OR	! These values describe
		 .rno_cmd[rno$c_underline] GTR 32 ))	! "NONprintable" characters
    THEN
	BEGIN
	ERM (RNFINM, CH$PTR(UPLIT ('/NONSPACING_UNDERLINE')), 21);
	range_error_flag = 1;		! Indicate error to force exit later.
	END;

    IF .range_error_flag 
    THEN				! If one of the above was out
	RETURN FALSE;			! of range, we can't go on.

%SBTTL 'DOOPTS -- Process /BACKSPACE, /BOLD, & /UNDERLINE'

    !Process /BACKSPACE switch'
    outopt_back = .rno_cmd [rno$v_backspace];
    outopt_over = true;				!Can always use line overprinting

    !Process /BOLD switch information
    gca_cmd_bld = .rno_cmd [rno$h_bold] GTR 0;	!Turn off bolding if user said /BOLD:0
    sca_do_bld = .gca_cmd_bld;
    outopt_bldn = .rno_cmd [rno$h_bold];	!Copy bolding depth indicator

    !Process /UNDERLINE switch information.
    gca_cmd_und = .rno_cmd [rno$v_underline];
    sca_do_und = .rno_cmd [rno$v_underline];

    IF 	(.rno_cmd [rno$c_underline] EQL 0)
	AND .rno_cmd [rno$v_und_char]
    THEN			!User said /UNDERLINE:0
	BEGIN
	gca_cmd_und = false;	!Turn off underlining for entire document.
	sca_do_und = false;	!...
	END;

    IF .rno_cmd [rno$v_underline]
    THEN
	BEGIN
	!Pick up information about how to do underlining.
	outopt_und_sep = .rno_cmd [rno$v_und_separ];	!Put dashes on next line.
	outopt_und_nosp = .rno_cmd [rno$v_und_nonsp];	!Underline character is non-spacing.

	outopt_und_char = 
	    (
	    IF .rno_cmd [rno$v_und_char]
	    THEN 
		!User said what character to use.
		(.rno_cmd [rno$c_underline])
	    ELSE
		!User did not specify the underline character, so figure it 
		!out, based on how underlining is to be done.

		(SELECTONE true OF
		SET
		[.outopt_und_sep]		: %C'-';	! Hyphen.
		[.outopt_und_nosp]		: 7;		! Bell.
		[.outopt_back, .outopt_over]	: %C'_';	! Underscore.
		TES)
	    );
	END;

    !Turn off the following command-line emphasis options ...
    !
    !   /BACKSPACE	  		/UNDERLINE="k"  
    !   /NONSPACING_UNDERLINE=["k"]	/SEPARATE_UNDERLINE=["k"]
    !
    ! ... if VT100 or LN01[e] output.
    !
    IF (.gca_op_dev EQL op_dev_ln01
	OR .gca_op_dev EQL op_dev_ln01e
	OR .gca_op_dev EQL op_dev_vt100)
    THEN
	BEGIN
	outopt_und_char = 0;		! No underline character.
	outopt_und_nosp = false;	! No nonspacing underlining.
	outopt_und_sep = false;		! No separate-line underlining.
	outopt_back = false;		! Don't use backspace characters.
	outopt_bldn = 0;		! Don't do bolding by overprinting.
	END;

%SBTTL 'DOOPTS -- Process /QUICK switch'

    IF .rno_cmd [rno$v_quick]
    THEN
    	setquick (false);

%SBTTL 'DOOPTS -- Process /DEBUG switch'

    !Process /DEBUG:INDEX switch
    gca_debug_index = .rno_cmd [rno$v_deb_index];

    !Process /DEBUG:CONTENTS switch
    gca_debug_toc = .rno_cmd [rno$v_deb_cont];

    !Process /DEBUG:FILES switch
    gca_debug_fil = .rno_cmd [rno$v_deb_files];

    !Process /DEBUG:CONDITIONALS switch
    gca_debug_cnd = .rno_cmd [rno$v_deb_cond];

    !Process /DEBUG:CROSS_REFERENCE switch
    gca_debug_cref = .rno_cmd [rno$v_deb_cros];

    !Process /DEBUG:SAVE switch
    gca_debug_save = .rno_cmd [rno$v_deb_save];

%SBTTL 'DOOPTS -- Process /MESSAGES switch'

    !NOTE:  This code relies on the bit representations of REPORT_ERR_?????.
    !
!!    IF .gca_cmd_quick
!!    THEN
!!	gca_cmd_msg = (1 ^ 1)		!If /QUICK, always report errors to user.
!!    ELSE
    BEGIN
    gca_cmd_msg = .rno_cmd [rno$v_msg_out] + (.rno_cmd [rno$v_msg_user] ^ 1);

    !If user didn't say /MESSAGES at all, direct them to everywhere
    IF .gca_cmd_msg EQL 0
    THEN				!User didn't say /MESSAGES, so
  	gca_cmd_msg = %B'11';	!direct messages everywhere.
    END;
				

%SBTTL 'DOOPTS -- Process change bar options.'

    IF .rno_cmd [rno$v_chng_char]
    THEN			!User specified character to be used as change bar.
	BEGIN
	sca_bar_char = .rno_cmd [rno$c_change];

	IF .rno_cmd [rno$c_change] EQL 0
	THEN 			!User is forbidding change bars for entire document.
	    gca_cmd_bar = false;
	END;

    IF .rno_cmd [rno$v_change]
    THEN 			!User wants change bars enabled.
	bars (h_enable_bar);

%SBTTL 'DOOPTS -- Process /RIGHT, /DOWN, /SIM, /PAUSE, & /SEQ'

    !Process /RIGHT switch information
    phan_right = .rno_cmd [rno$h_right];
    IF .phan_right NEQ 0
    THEN
	gca_cmd_rit = true;

    !Process /DOWN switch information
    phan_down = .rno_cmd [rno$h_down];
!zzz
    !Process /SIMULATE switch information
    IF .rno_cmd [RNO$V_SIMULATE]
    THEN			!User said /SIMULATE
	phan_simulate = true
    ELSE
	phan_simulate = false;

    !Process /PAUSE switch information
    phan_pause = .rno_cmd [rno$v_pause];

    !Process /SEQUENCE switch information
    gca_cmd_isq = .rno_cmd [rno$v_sequence];

%SBTTL 'DOOPTS -- Process /LOG, /DEVICE, /DEC_INTERNAL switches'

    ! /[NO]LOG switch

	termination_log = .rno_cmd [rno$v_log];

    ! /DEVICE switch
	!
	! NOTE: the output device type was already picked up in RUNOFF.BLI:
	!	gca_op_dev = .rno_cmd [rno$v_4_out_format];
	!
	!Pick up LN01 output options.
	IF (.gca_op_dev EQL op_dev_ln01
	  OR .gca_op_dev EQL op_dev_ln01e)
	THEN
	    BEGIN					! Options for LN01 output:
	    gca_ln01_ital_under = .rno_cmd [rno$v_ln01_ital_under]; ! set=italics, clear=underlining
	    gca_ln01_port_land = .rno_cmd [rno$v_ln01_port_land];   ! set=portrait, clear=landscape
	    !
	    ! Write initial escape sequences into the .LNI output file.
	    !
	    write_ln01_info (.rno_cmd);
	    END;

%IF FLIP %THEN
	IF (.gca_op_dev EQL op_dev_flip)
	THEN
	    BEGIN
	    !
	    ! Initialize the .BFL with a "new sequence" header.
	    !
	    putrty (maj_new_toc, toc_format);

	    ! Turn on flags to indicate that we want Index and Contents 
	    ! information for FLIP output.
	    !
	    gca_bix = true;
	    gca_btc = true;
	    gca_cmd_btc = true;
	    END;
%FI
    ! /DEC_INTERNAL switch

	!Pick up the debugging flags
	gca_diag1	=  .rno_cmd [rno$h_dbg1];
	gca_diag2	=  .rno_cmd [rno$h_dbg2];

	! If the user said /DEC=OUTPUT_LINE_NUMBER, the CLI set bit 15 of
	! the second diagnostic word.  Use that word to initialize the flag
	! that controls the outputting of the output line numbers at the
	! front of every line of text.
	gca_cmd_osq	=  .diag2_15;

%SBTTL 'DOOPTS -- Process /FORMSIZE switch information'

    IF .rno_cmd [rno$h_form_size] GTR 0
    THEN
	!User said /FORMSIZE:n.  Use it either for /SIMULATE or
	!/NOSIMULATE, as appropriate.
	IF .phan_simulate
	THEN
	    !User said /SIMULATE, so the specified form size is physical paper size
	    phan_plines = .rno_cmd [rno$h_form_size]
	ELSE
	    !User is not simulating, so specified form size is
	    !number of lines allowed on the page by the spooler.
	    phan_slines = .rno_cmd [rno$h_form_size];

    !If simulating formfeeds, or want to pause at top of each page, open 
    !the stream IOBs.
    IF .phan_simulate OR .phan_pause
    THEN
	$XPO_OPEN (IOB = tsiiob,
	    FILE_SPEC = $XPO_INPUT,
	    OPTIONS = (INPUT, OUTPUT),
	    ATTRIBUTES = STREAM);

    !Initial signals for /SIMULATE and /PAUSE

    IF .phan_simulate 
    THEN
	BEGIN				! Do not prompt in Batch (if 
	IF .tsiiob [iob$v_terminal]	! controller is not a terminal).
	THEN
	    BEGIN
	    $XPO_GET 
		( IOB = tsiiob
	          , PROMPT= ( 32
			    , CH$PTR(UPLIT (%STRING 
					     (BELL, DEL, BELL, DEL,
					     'Position paper, type a space'
					     )
					    )
				     )
			    )
	          , CHARACTERS = 1
		);

	    !After getting the user's character, issue a carriage return.
	    $XPO_PUT 
		( IOB = tsiiob
		, STRING = (1, CH$PTR(UPLIT (%STRING (%CHAR(%O'15'))))) 
		)
	    END;
	END
    ELSE
	IF .phan_pause
	THEN
	    bwait ();

    RETURN TRUE					!Command line was ok.
    END;					!End of DOOPTS


%SBTTL 'Disable output and enable "quick" processing'
GLOBAL ROUTINE SETQUICK (close_output) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to close the output file and set up the GCA
!	for "quick" output processing.
!
! FORMAL PARAMETERS:
!
!	close_output   	- If true, the output file is closed.
!
! IMPLICIT INPUTS:
!
!	gca_cmd_quick	- If true, no processing is done
!
! IMPLICIT OUTPUTS:
!
!	gca_cmd_quick	- Set to true
!	gca_cmd_bar	- Set to false
!	gca_skip_out	- Set to true
!	gca_cmd_msg	- Set to (1 ^ 1)	
!	output file is closed			!If close_output is true.
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--
    BEGIN

    IF NOT .gca_cmd_quick
    THEN
	BEGIN
	gca_cmd_quick	= true;
	gca_cmd_bar	= false;
	gca_skip_out	= true;
	gca_cmd_msg	= (1 ^ 1);
    	IF .close_output
    	THEN
    	    clh (clh_close_del_out);
	END;

    END;		! End of SETQUICK


ROUTINE write_ln01_info (rno_cmd : ref $rno_cmd) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes LN01-specific escape codes into the output file.
!
! FORMAL PARAMETERS:	None
!
!	RNO_CMD is the command-block structure address, passed from DOOPTS.
!
! IMPLICIT INPUTS:
!
!	The following GCA bits are checked to control which escape 
!	sequences are written:
!
!	  rno_cmd [rno$v_ln01_header]
!	  rno_cmd [rno$v_ln01_load]
!	  gca_op_dev
!	  gca_ln01_ital_under
!	  gca_ln01_port_land
!
! IMPLICIT OUTPUTS:
!
!	Initial escape sequences are written to the output file.
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--

    BEGIN

    MACRO
	write_escape_sequence (string) =
	    BEGIN
	    LOCAL
		len,
		ptr;
	    fs_init (fra);
	    len = .string[STR$H_LENGTH];
	    ptr = .string[STR$A_POINTER];
	    fs_wchar (fra, escape);		!Write initial escape character.
	    INCR i FROM 1 TO .len DO		!Append formal.
		fs_wchar (fra, CH$RCHAR_A(ptr) );
	    clh (clh_out_nocrlf);
	    END
	%;

    LOCAL
	decslpp,			! Lines (actually, pixels) per physical page. 
	pixels_per_line_spacing,	! Used to calculate decslpp.
	twice_paper_size,		! Accounts for portrait/landscape orientation.
	right_shift,			! Pretend the user said /RIGHT= this value.
	top_margin,
	bottom_margin,
	left_margin,
	right_margin,
	text_font : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	bold_font : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	italic_font : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	bold_italic_font : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	text_def : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	bold_def : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	italic_def : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	bold_italic_def : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) ),
	work_string : $STR_DESCRIPTOR (CLASS=DYNAMIC, STRING=(0,0) );

    !
    ! Assign parameters that depend on portrait/landscape orientation.
    !
    IF .gca_ln01_port_land EQL 1	!Portrait orientation.
    THEN
	BEGIN
	right_shift = 2;
	pixels_per_line_spacing = 50;
	END
    ELSE				!Landscape orientation.
	BEGIN
	IF .gca_op_dev EQL op_dev_ln01e
	THEN				!European-style LN01.
	    right_shift = 13
	ELSE				!American-style LN01.
	    right_shift = 9;

	pixels_per_line_spacing = 35;
	END;

    !
    ! Calculate value to use for decslpp (pixels per page).
    !
    decslpp = 
	(IF .phan_simulate 
	THEN 
	    (.phan_plines * .pixels_per_line_spacing)
	ELSE
	    (.phan_slines * .pixels_per_line_spacing)
	);

    !
    ! Calculate values for margins.
    !
    top_margin = 1;
    bottom_margin = .decslpp;
    left_margin = 1;		!DEC rom revision #14 left must be 1.
    right_margin = 65536;	!Largest unsigned number.

    !
    ! Set up right shift if user did not say /RIGHT himself.
    !
    IF NOT .rno_cmd [rno$v_s_right]
    THEN			!User did not specify /RIGHT.
	BEGIN
	phan_right = .right_shift;
	gca_cmd_rit = true;
	END;
    !
    ! Set up vertical shift if user did not say /DOWN himself.
    !
    IF NOT .rno_cmd [rno$v_s_down]
    THEN			!User did not specify /DOWN.
	phan_down = 2;



    IF .rno_cmd [rno$v_ln01_header]	! Only process & output header if it
    THEN				!  was not suppressed by the user.
	BEGIN
	!
	! Build up a suffix string to determine which fonts get used.
	!
	IF .gca_ln01_port_land EQL 1	! Determine orientation
	THEN
	    $STR_COPY (TARGET= work_string, STRING= 'P' )	! Portrait
	ELSE
	    $STR_COPY (TARGET= work_string, STRING= 'L' );	! Landscape

	IF .gca_op_dev EQL op_dev_ln01e
	THEN
	    $STR_APPEND (TARGET= work_string, STRING= 'E' );	! European-style

	! If font loading is specified (by the user not saying NOLOAD), we
	! will need the text strings for their module names built:
	!
	IF .rno_cmd [rno$v_ln01_load]	! Only load fonts if needed
	THEN
	    BEGIN
	    !
	    ! Build each font module name string by adding the suffix string
	    ! to the base name.
	    !
	    $STR_COPY  ( TARGET = text_font
			,STRING = $STR_CONCAT ( 'DSR$FONT_T', work_string ) );

	    $STR_COPY  ( TARGET = bold_font
			,STRING = $STR_CONCAT ( 'DSR$FONT_B', work_string ) );

	    $STR_COPY  ( TARGET = italic_font
			,STRING = $STR_CONCAT ( 'DSR$FONT_I', work_string ) );

	    $STR_COPY  ( TARGET = bold_italic_font
			,STRING = $STR_CONCAT ( 'DSR$FONT_BI', work_string ) )
	    END;

	! Build each font definition file name string by adding the suffix
	! string to the base name.
	!
	$STR_COPY  ( TARGET = text_def
		    ,STRING = $STR_CONCAT( 'DSR$FONT_DEFINE_T', work_string ));

	$STR_COPY  ( TARGET = bold_def
		    ,STRING = $STR_CONCAT( 'DSR$FONT_DEFINE_B', work_string ));

	$STR_COPY  ( TARGET = italic_def
		    ,STRING = $STR_CONCAT( 'DSR$FONT_DEFINE_I', work_string ));

	$STR_COPY  ( TARGET = bold_italic_def
		    ,STRING = $STR_CONCAT( 'DSR$FONT_DEFINE_BI', work_string ));


!+
! The preliminaries are taken care of. Now write the initializing escape 
! sequences to the output (.LNI) file. The sequences are written in the
! following order.  The first five are written only if the user didn't 
! issue a NOHEADER parameter:
!
!	Font Load
!	Font Assignment (Text)
!	Font Assignment	(Bold)
!	Font Assignment (Italic)	[if Italic specified or defaulted]
!	Font Assignment	(Bold Italic)	[if Italic specified or defaulted]
!
!	Set Lines Per Physical Page
!	Top and Bottom Margins
!	Left and Right Margins
!	Default Font Invocation 
!	Vertical Position Absolute
!
! The CLH routine is used to write output. The strings to write are built 
! up in the FRA fixed-string, and CLH called to write output with no ter-
! minating <CR> and <LF>.
!-
	!
	! Write Font Load escape sequence unless the user said not to. Format:
	!
	!   <ESC>]VMS;1;DSR$FONT_LOAD,fn1,fn2,...,ANSI$ST,def1,def2,...<ESC>\
	!
	!   fn1, fn2,...    = names of library modules containing fonts
	!   def1, def2,...  = names of lib. modules containing font definitions
	!
	! The above sequence is known as an OSC ESCAPE SEQUENCE.

	$STR_COPY (TARGET = work_string, STRING= ']VMS;1;' ); ! OSC control seq.

	IF .rno_cmd [rno$v_ln01_load]	! Only load fonts if needed
	THEN
	    BEGIN

		! load the Text and Bold fonts.

	    $STR_APPEND ( TARGET = work_string
			 ,STRING= $STR_CONCAT	( 'DSR$FONT_LOAD,'
						 ,text_font
						 ,','
						 ,bold_font
						 ,','		)	);

	    ! If italics were requested, also load the Italic and Bold Italic
	    ! fonts.
	    !    
	    IF .gca_ln01_ital_under EQL 1	!Italics requested.
	    THEN
		$STR_APPEND ( TARGET = work_string
			     ,STRING = $STR_CONCAT ( italic_font
						    ,','
						    ,bold_italic_font
						    ,','	)	);

	    ! Finish the font-load escape sequence.
	    !    
	    $STR_APPEND	( TARGET = work_string ,STRING = 'ANSI$ST,' )

	    END;  ! of font loading controls

	! This section specifies the font definition module names
	!
	! Add text and bold definition module names:
	!
	$STR_APPEND ( TARGET = work_string
		     ,STRING = $STR_CONCAT ( text_def
					    ,','
					    ,bold_def	)	);

	! If italics were requested, also load the definition modules for the
	! Italic and Bold Italic fonts.
	!    
	IF .gca_ln01_ital_under EQL 1	!Italics requested.
	THEN
	    $STR_APPEND ( TARGET = work_string
			 ,STRING = $STR_CONCAT ( ','
						,italic_def
						,','
						,bold_italic_def  )  );

	! Finish the font load and definition escape sequence.
	!    
	$STR_APPEND ( TARGET = work_string
		     ,STRING = $STR_CONCAT ( %CHAR(escape), '\' )  );

	! Write the string.
	!
	write_escape_sequence (work_string)
	END;


    !
    ! Write Set Lines Per Physical Page escape sequence. Format:
    !
    !   <ESC> [ Pn t			!Pn = form length (pixels)
    !
    $STR_COPY  ( TARGET = work_string
		,STRING = $STR_CONCAT ( '[', $STR_ASCII(.decslpp), 't' )  );

    write_escape_sequence (work_string);

    !
    ! Write Top and Bottom Margins escape sequence. Format:
    !
    !  <ESC> [ Pn ; Pm r
    !
    !  Pn = top margin (pixels)
    !  Pm  = bottom margin (pixels)
    !
    $STR_COPY  ( TARGET = work_string
		,STRING = $STR_CONCAT ( '['
				       ,$STR_ASCII(.top_margin)
				       ,';'
				       ,$STR_ASCII(.bottom_margin)
				       ,'r'		)  );

    write_escape_sequence (work_string);

    !
    ! Write Left and Right Margins escape sequence. Format:
    !
    !  <ESC> [ Pn ; Pm s
    !
    !  Pn = left margin (pixels)
    !  Pm  = right margin (pixels)
    !
    $STR_COPY  ( TARGET = work_string
		,STRING = $STR_CONCAT ( '['
				       ,$STR_ASCII(.left_margin)
				       ,';'
				       ,$STR_ASCII(.right_margin)
				       ,'s'  )  );

    write_escape_sequence (work_string);


    ! Write the sequence to load the DSR$PAGE_SIZE module to allow the user to
    ! redefine the parameters just set.  It is assumed that initially, for the
    ! normal user, this module will be a null module; i.e. it will not contain
    ! anything.  However, its reference here assumes that it will be present in
    ! the library.
    !
    ! This sequence is known as an OSC ESCAPE SEQUENCE.

    IF .rno_cmd [rno$v_ln01_header]	! Only process & output header if it
    THEN				!  was not suppressed by the user.
	BEGIN
	$STR_COPY  ( TARGET = work_string
		    ,STRING = $STR_CONCAT ( ']VMS;1;DSR$PAGE_SIZE'
					   ,%CHAR(escape)
					   ,'\'  )  );

	write_escape_sequence (work_string)
	END;

    !
    ! Write Default Font Invocation escape sequence. Format:
    !
    !  <ESC> [ 12 m
    !
    $STR_COPY (TARGET = work_string, STRING = '[12m' );
    write_escape_sequence (work_string);

    !
    ! Write Vertical Position Absolute escape sequence. Format:
    !
    !   <ESC> [ 0 d
    !
    $STR_COPY (TARGET=work_string, STRING = '[0d' );
    write_escape_sequence (work_string);

    ! Force a formfeed record to tell the print symbiont to reset its line
    ! counters.  This is a HACK made necessary because VMS-land won't provide
    ! a better method to accomplish the same end.

    phan_lines_tp = .phan_lines_tp + 1	! Count one line of output

    END;					!End of write_ln01_info
END						!End of module
ELUDOM
