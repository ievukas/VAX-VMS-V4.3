	.TITLE	PASCSCTL
	.IDENT	'V04-000'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:  SCS CONTROL INCLUDING CONNECTION MANAGEMENT, PROCESSING
;	     RECEIVED CREDIT MESSAGES, AND SHARING OF THE SINGLE
;	     SCS SEND BUFFER PER PATH.
;
; AUTHOR:  N. KRONENBERG,  MAY 1981
;
; MODIFIED BY:
;
;	V03-018	NPK3054		N. Kronenberg		24-Jun-1984
;		Change SCS$REQ_SCSSEND to check if a CDT is already
;		waiting for the SCS send buffer before putting it
;		on the queue.  If it is waiting, don't queue, but
;		just update the block state.
;
;	V03-017	NPK3052		N. Kronenberg		 4-May-1984
;		Make SCS$CLOSE_CDT a global entry like it was supposed
;		to be in the first place.
;
;	V03-016	NPK3048		N. Kronenberg		 4-Apr-1984
;		Modify SCS$VCCLOSED/SCS$SETCKT_CLSD to set aux
;		status to the value in PB$W_VCFAIL_RSN (host shutdown)
;		if there is a nonzero value there.
;
;	V03-015	NPK3046		N. Kronenberg		 8-Mar-1984
;		Fix SCS$NOTIFY_SYSAP to completed an outstanding
;		reject with success and return the cdt to the listening
;		state.  Previously the cdt was closed.
;
;	V03-014	NPK3045		N. Kronenberg		23-Feb-1984
;		Add to SCS$VCCLOSED the instruction to set 
;		PB$C_VC_FAIL after checking if a VC failure is already
;		in progress.
;
;	V03-013	NPK3042		N. Kronenberg		 6-Feb-1984
;		Modify SCS$VCCLOSED to simply return if a vc closure
;		is already in progress.  Add a new entry to this routine,
;		SCS$SETCKT_CLSD to be called when a SETCKT closed is
;		successfully completed.
;
;	V03-012	NPK3039		N. Kronenberg		11-Jan-1984
;		Repair automatic transition of formative PB to fully
;		open:  Continue to call CNF$SCSMSG_REC, but don't 
;		assume that a fully open PB actually resulted. (It
;		would fail, if the ENTER_PB previously failed
;		or now fails either due to lack of pool or because
;		the system has the same system name or system ID, but
;		different incarnation as some system to which we
;		already have circuit(s).)
;
;		If no fully open PB resulted, then the vc will have
;		been closed by CNF$SCSMSG_REC, and the remote system's
;		configuration poller will detect that the circuit is
;		gone and clean up the remote's dangling CONNECT_REQ.
;		The whole problem of a CONNECT_REQ arriving when we
;		have already told the port to open the vc, but when
;		we then failed to do the ENTER_PB could have been
;		avoided by delaying the vc open command to the port
;		till after the ENTER_PB.  This solution was rejected
;		because it would mean that a fast enough remote system
;		might always get its connect request through before
;		the local system could tell its port (after the ENTER_PB)
;		to open the vc.  Consequently, the open command to
;		the port remains as early as possible and is undone
;		later if that is necessary.  This optimizes the common
;		case at the expense of the error case.
;
;		It is possible in the future that sufficiently different
;		cpu speeds may lead to the situation where the fast cpu
;		can always get a connect request sent to a slow system
;		before the slow system can tell its port to open the 
;		vc.  If this happens, the current behavior should be
;		reevaluated -- a delay before sending connect requests
;		may be needed.
;
;	V03-011	NPK3037		N. Kronenberg		11-Nov-1983
;		Add optional $DEBUGCHECK on receipt of connect request
;		with no path block in hand or if VC closed or cache
;		clear processing is entered with no path block.
;		Fix SCS$NOTIFY_SYSAP and CHECK_NO_CDTS to suppress
;		send of cache clear if the port is dead.  Also, fix
;		CHECK_NO_CDTS to remove the PB and init the port in
;		the case where the last CDT to be removed did not
;		result in a call to the SYSAP error routine and
;		a SYSAP disconnect.  
;
;	V03-010	ROW0200		Ralph O. Weber		 2-AUG-1983
;		Change SCS$ALL_SCSREC error path after INI$ALLOC_MSG to simply 
;		RSB.  The previous version was POPing unsaved registers from 
;		the stack thus corrupting those registers.  This change relies 
;		on EXE$ALONONPAGED returning SS$_INSFMEM.  EXE$ALONONPAGED was 
;		recently changed to do this.
;
;	V03-009 NPK3029		N. Kronenberg		18-Jul-1983
;		Enhancements for V4.0:
;		Change to use symbols for SCS status/reason codes.
;		Allow receipt of a connect request to complete a
;		start handshake in case the last ack in the start
;		handshake was missed.
;		Fix disconnect of connection because of vc fail
;		to return both con_rec and rej_sent connections to
;		the listen state.  (Previously rej_sent connections
;		were deleted.)
;		
;	V03-008	KTA3046 	Kerbey T. Altmann	29-Mar-1983
;		Redo for SCS/PPD split.
;
;	V03-007 NPK3023		N. Kronenberg		 1-Mar-1983
;		Check destination connection sequence number on
;		credit requests and responses.
;
;	V03-006	ROW0147		Ralph O. Weber		15-DEC-1982
;		Correct offset on matching address in SCS$MAP_VMSSTS table 
;		lookup.
;
;	V03-005	NPK3008		N. Kronenberg		 6-Oct-1982
;		Change SCS status codes to conform to architecture.
;
;	V03-004	ROW0096		Ralph O. Weber		 7-JUN-1982
;		Add calls to error logging routines in REC_CON_REQ and 
;		BREAK_VC.  Also added necessary reference to $PAERDEF macro.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-003	NPK2019		N. Kronenberg		6-Apr-1982
;		Change BAD_DATABASE to crash port instead of bugcheck.
;
;	V03-002	NPK2018		N. Kronenberg		25-Mar-1982
;		Added routine SCS$ALLOC_DGPPD to allocate short dgs.
;		Removed test code from SCS$DEAL_DG.
;
;	V03-001	NPK2016		N. Kronenberg		18-Mar-1982
;		Fixed .TITLE
;
;--

	.SBTTL	DEFINITIONS

;
; Set PSECT to driver code:
;

	.PSECT	$$$115_DRIVER,LONG

;
; System definitions (LIB.MLB):
;

	.nocross
	$CDLDEF				; Connection Descriptor List format
	$CDTDEF				; Connection Descriptor Table format
	$CDRPDEF			; Class Driver Request Pkt format
	$PBDEF				; Path Block format
	$PDTDEF				; Port Descriptor Table
	$SCSDEF				; SCS message format
	$SSDEF				; System service messages

;
; PADRIVER definitions (PALIB.MLB):
;
	$PAPDTDEF			; PA specific PDT extension.
	$PAERDEF			; Port driver error code values
	.cross

	.SBTTL	DATA

;+
; Tables to convert SCS status codes to corresponding VMS status codes.
;-
;
; SCS status codes:
;

SCS_STATUS_TAB:


	.WORD	SCS$C_STNOMAT		; No matching listener
	.WORD	SCS$C_STNORS		; No resources in listener
	.WORD	SCS$C_STNORMAL		; General success status
	.WORD	SCS$C_STDISC		; CDT disconnected
	.WORD	SCS$C_STINSFCR		; Insufficient credits on connect
	.WORD	0			; Patch space
	.WORD	0			;
	.WORD	0			;
	.WORD	0			;

SCS_STATUS_LEN = .-SCS_STATUS_TAB	; # bytes in SCS status table

;
; VMS status codes corresponding to SCS codes.  This table must
; follow above table.
;

VMS_STATUS_TAB:

	.WORD	SS$_NOLISTENER		; No matching listener
	.WORD	SS$_REMRSRC		; No resources in listener
	.WORD	SS$_NORMAL		; Success
	.WORD	SS$_DISCONNECT		; CDT disconnected
	.WORD	SS$_NORMAL		; Default VMS status for patch space
	.WORD	SS$_NORMAL		;
	.WORD	SS$_NORMAL		;
	.WORD	SS$_NORMAL		;

;
; Length of the SCS overhead.
;

SCS$GL_SCSSIZE::

	.LONG	SCS$C_OVHD


	.SBTTL	SCS LAYER INITIALIZATION

;+
; This routine is called by the INIT module after the PDT has been set
; up and befor any port specific hardware initialization.  It gives the
; SCS layer a chance to do any initialization it needs.
;-

SCS$INITIAL::

	BRW	FPC$INITIAL		; Do it in FPC for now


	.SBTTL	PROCESS REC'D SCS CONTROL MESSAGES
;+
; This routine is called by module PAINTR when a message is received which is
; message type other than SCS$C_APPL_MSG.  This routine dispatches
; on the various message types that are possible to routines that
; process the received messages.
;
; Inputs:
;
;	R2			-Addr of received message
;	R4			-Addr of PDT
;
; Outputs:
;
;	R4			-Preserved
;	other registers		-Destroyed
;-

;
; Message format assumptions:
;

ASSUME	SCS$C_CON_REQ	EQ 0
ASSUME	SCS$C_CON_RSP	EQ 1
ASSUME	SCS$C_ACCP_REQ	EQ 2
ASSUME 	SCS$C_ACCP_RSP	EQ 3
ASSUME	SCS$C_REJ_REQ	EQ 4
ASSUME	SCS$C_REJ_RSP	EQ 5
ASSUME	SCS$C_DISC_REQ	EQ 6
ASSUME	SCS$C_DISC_RSP	EQ 7
ASSUME	SCS$C_CR_REQ	EQ 8
ASSUME	SCS$C_CR_RSP	EQ 9


	.ENABL	LSB

SCS$REC_SCSMSG::
	
	TSTW	SCS$W_MTYPE(R2)		; Connect request?
	BEQL	10$			; If so, skip CDT addr calculation
	BSBW	FPC$CHK_DCONID		; Check destination CONID
					;  and get CDT addr
	BLBS	R0,10$			; Branch if good  CONID
	RSB				; Else leave

10$:	CASE	SCS$W_MTYPE(R2),<-	; Dispatch to routine based on msg type:
		REC_CON_REQ,-		;  CONNECT_REQ
		REC_CON_RSP,-		;  CONNECT_RSP
		REC_ACCP_REQ,-		;  ACCEPT_REQ
		REC_ACCP_RSP,-		;  ACCEPT_RSP
		REC_REJ_REQ,-		;  REJECT_REQ
		REC_REJ_RSP,-		;  REJECT_RSP
		REC_DISC_REQ,-		;  DISCONNECT_REQ
		REC_DISC_RSP,-		;  DISCONNECT_RSP
		REC_CR_REQ,-		;  CREDIT_REQ
		REC_CR_RSP>		;  CREDIT_RSP
	BRW	BREAK_VC		; Other types are illegal


	.DSABL	LSB

	.SBTTL	-	REC_CR_REQ,	PROCESS REC'D CREDIT REQUEST

;+
; This routine processes a credit request (received separately from
; an appliction message).  The algorithm is:
;
; For positive credit field:
;
;	CDT$W_SEND(R3) = CDT$W_SEND(R3) + credit
;
; For negative credit field (credits being retracted):
;
;	Maximum returnable credit = Maximum of 0 or
;				    (CDT$W_SEND - CDT$W_MIN_SEND)
;
;	Number to return = Minimum of (Max returnable) or (-credit field)
;
; Inputs:
;
;	R2			-Addr of credit message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

REC_CR_REQ:

	CMPW	SCS$L_DST_CONID+2(R2),-	; Is the connection seq # in the
		CDT$L_LCONID+2(R3)	;  msg = seq # in cdt?
	BNEQ	FATAL_CR_ERR		; Branch if not
	MOVW	SCS$W_CREDIT(R2),R1	; Get # credits extended
	BGEQ	UPDATE_SEND		; Branch if positive
	SUBW3	CDT$W_MINSEND(R3),-	; Compute # we can return
		CDT$W_SEND(R3),R0	;
	BGEQ	10$			; Branch if not negative
	CLRW	R0			; Else # we can return = 0

10$:	MNEGW	R1,R1			; Compute -(credit field)
	CMPW	R1,R0			; Is it less than, or equal to 
					;  maximum returnable?
	BLEQU	20$			; Branch if so
	MOVW	R0,R1			; Else choose max returnable
20$:	MNEGW	R1,R1			; Calc -Min(max returnable,-credit)
	MOVW	R1,SCS$W_CREDIT(R2)	; Tell remote about partial

UPDATE_SEND:

	ADDW	R1,CDT$W_SEND(R3)	; Update our send credit
	BSBW	SEND_CR_RSP		; Turn messge around for RSP

30$:	TSTW	CDT$W_SEND(R3)		; Any send credits now?
	BEQL	40$			; Branch if not
	$RESUME_FP	-		; Else resume 
		@CDT$L_CRWAITQFL(R3),-	;  next waiter
		QEMPTY=40$		;  branching if none
	BRB	30$			; Check if more credit

40$:	RSB				; Return

 	.DSABL	LSB

	.SBTTL	-	REC_CR_RSP,	PROCESS REC'D CREDIT RESPONSE

;+
; This routine is called upon receipt of a response to a previously
; sent CREDIT_REQ.  REC_CR_RSP updates the record of the number
; of sent credits held by the remote SCS (CDT$W_REC) and then
; resumes the SCS message send process in case any connection
; is waiting for the SCS send buffer.
;
; Inputs:
;
;	R2			-Addr of credit response message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

REC_CR_RSP:
	
	CMPW	SCS$L_DST_CONID+2(R2),-	; Is connection seq # in msg
		CDT$L_LCONID+2(R3)	;  = seq # in cdt?
	BNEQ	FATAL_CR_ERR		; Branch if not
	MOVW	SCS$W_CREDIT(R2),R0	; Get credit confirmed
	BLSS	FATAL_CR_ERR		; Branch if negative
					; Negative credit--> remote SCS
					;  thinks we asked for credit
					;  back and we never do that.
	BRW	SCS$RESUM_SEND		; Resume SCS send waiter, if any

FATAL_CR_ERR:

	BRW	BREAK_VC		; Break virtual circuit

	.DSABL	LSB

	.SBTTL	-	REC_CON_REQ,	PROCESS REC'D CONNECT REQUEST

;+
; Receipt of a connect request causes the transition of the path block
; associated with this port-port vc from the formative to the open state
; if necessary.  (It is necessary only if the final datagram in the start
; handshake was lost.)
;
; Next, REC_CON_REQ looks up the target fork process in the directory of 
; listeners;  if the target is not listening, match failure status is
; returned to the remote.  If the target is listening, the listening CDT 
; receives assorted information about the connect requestor, and the 
; listening SYSAP is called at its listen message address.
;
; If the target process is busy handling a previous connect request 
; (it is in the con_rec or rej_sent state), then 'no resources' status
; is returned to the connect requestor.  The assumption is that, in this
; case, the requestor will reissue the connect request later.
;
; Inputs:
;
;	R2			-Addr of msg buffer containing CONNECT_REQ
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-


	.ENABL	LSB

REC_CON_REQ:

	BSBW	CNF$SCSMSG_REC		; Complete formative PB transition
					;  if necessary. (This routine may
					;  find a formative PB, but may fail
					;  for a number or reasons.  See 
					;  revision history on this module
					;  NPK3039)
	BSBW	CNF$LKP_PB_MSG2		; Look up PB given PDT and remote port
	BLBS	R0,VC_OPEN		; Branch if found open PB.
					;  Else, vc is closed and connect
					;  request arrived during window when
					;  we had vc open in anticipation of
					;  a successful handshake.
	BSBW	INT$INS_MFREEQ		; Discard CONNECT_REQ to free queue
					;  -- sender will discover closed vc
					;  via polling.
	RSB				; Return

VC_OPEN:

	MOVAL	SCS$T_DST_PROC(R2),R1	; Get addr of target process name
	JSB	G^SCS$LOCLOOKUP		; Look it up in the directory
	BLBC	R0,NO_MATCH		; Branch if failed
	$DISPATCH -
		CDT$W_STATE(R3),-		; Dispatch on state:
		<-				;
		<CDT$C_CON_REC,	NO_RESOURCE>,-	;  CONNECT in progress
		<CDT$C_REJ_SENT,NO_RESOURCE>,-	;  CONNECT in progress
		<CDT$C_LISTEN,	CON_LISTEN>,-	;  Just listening
		>

	BRW	BREAK_VC			; Illegal state

CON_LISTEN:

	PUSHL	R2			; Save addr of CONNECT_REQ
	BSBW	SCS$ALL_SCSREC		; Allocate SCS buffer to listening CDT
	POPL	R2			; Retreive addr of CONNECT_REQ
	BLBC	R0,NO_RESOURCE		; Branch if no pool
	BSBW	SCS$COPY_ACCP		; Copy info about remote to CDT
	BSBW	SCS$SAVE_REQ		; Copy connect request to listener
					;  SCS buffer.
	BSBW	CNF$LKP_PB_MSG2		; Look up path block given PDT and
	BLBC	R0,BAD_DATABASE		; Branch if couldn't find PB --
					;  shouldn't get seq msg unless
					;  there is a PB (VC open)
	MOVL	R1,CDT$L_PB(R3)		; Save PB addr in listen CDT
	MOVL	PB$B_RSTATION(R1),-	; Also save remote station addr,
		CDT$B_RSTATION(R3)
	MOVW	PB$B_RSTATION+4(R1),-
		CDT$B_RSTATION+4(R3)
	MOVL	R4,CDT$L_PDT(R3)	;  and PDT addr in listen CDT
	MOVW	#CDT$C_CON_REC,-	; Move connection state from
		CDT$W_STATE(R3)		;  listen to connect received
	MOVL	PB$L_CDTLST(R1),-	; Insert listening CDT on PB list
		CDT$L_CDTLST(R3)	;  of CDT's in case of VC or
	MOVL	R3,PB$L_CDTLST(R1)	;  power failure
	MOVW	#SCS$C_STNORMAL,R0	; Set status to match successful
	BSBW	SCS$SEND_RSP		; Generate response
	MOVL	CDT$L_SCSMSG(R3),R2	; Get addr of copy of msg
	MOVAB	SCS$T_DST_PROC(R2),R2	; Compute addr of part SYSAP wants
	JSB	@CDT$L_MSGINPUT(R3)	; Call listener input addr
	RSB				; Return to PAINIT to dequeue
					;  more responses

NO_MATCH:

	MOVW	#SCS$C_STNOMAT,R0	; Set status to no matching process
	BRB	10$			; Join common code

NO_RESOURCE:

	MOVW	#SCS$C_STNORS,R0	; Set status to no resources

10$:	BRW	SCS$SEND_RSP		; Send response

BAD_DATABASE:

	$DEBUGCHECK #ERR$V_DEB_NOPB	; Optionally, bugcheck on this error
	CVTWL	#<PAER$K_ES_CNPB ! ^X8000>, R0	; Log received connect request
	BSBW	ELOG$PACKET			; from port w/o PB error.
	BSBW	INT$INS_MFREEQ		; Put SCS receive buffer back
					;  on free queue
	BSBW	ERR$CRASH_PORT		; Init port crash
	RSB				; Return to interrupt service

	.DSABL	LSB

	.SBTTL	-	REC_CON_RSP,	PROCESS REC'D CONNECT RESPONSE

;+
; This routine is called upon receipt of a CONNECT_RSP.  Action is as
; follows:
;
;	CONNECT_RSP STATUS	CDT STATE	ACTION
;
;	Match			CON_SENT	Move state to CON_ACK.
;						Resume SCS send wait queue.
;
;	No match,		CON_SENT	Deallocate CDT and all its
;	No resources				buffers.  Resume SYSAP with
;						error status.  Resume SCS
;						send wait queue.
;
; Inputs:
;
;	R2			-Addr of CONNECT_RSP message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved (if connect acknowleged)
;	R3			-Destroyed if connect not acknowleged

;-

	.ENABL	LSB

REC_CON_RSP:

	$CHK_CDTSTATE -			; Verify CDT state is
		CON_SENT,-		;  connect sent;  if not,
		ERROR=BREAK_VC		;  fatal state error
	CMPW	SCS$W_STATUS(R2),-	; Was connect acknowleged?
		#SCS$C_STNORMAL		;
	BNEQ	CONNECT_FAIL		; Branch if not
	MOVW	#CDT$C_CON_ACK,-	; Move CDT state to connect ack'ed
		CDT$W_STATE(R3)		;
	BRW	SCS$RESUM_SEND		; Resume SCS send queue

CONNECT_FAIL:

	BSBW	SCS$DEAL_ALLBUF		; Deallocate all CDT's buffers
	BSBW	SCS$MAP_SCSSTS		; Map SCS status to VMS
	PUSHL	R0			;  and save on stack
	BSBW	SCS$RESUM_SEND		; Resume SCS send queue
	MOVL	CDT$L_FR5(R3),R5	; Restore SYSAP's context: R5
	PUSHL	CDT$L_FPC(R3)		;  and PC from CDT
	JSB	G^SCS$DEALL_CDT		; Deallocate CDT too
	MOVL	4(SP),R0		; Retreive VMS status
	MOVL	R4,4(SP)		; Save PDT addr over status
	JSB	@(SP)+			; Call SYSAP with error status
	POPL	R4			; Retreive PDT address
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	REC_ACCP_REQ,	PROCESS REC'D ACCEPT REQUEST

;+
; this routine is called upon receipt or an ACCEPT_REQ message.  Action
; is as follows:
;
;	CDT State		Action
;
;	CON_ACK			Copy accept message and parameters
;				to CDT;  Set CDT state open.
;				Send ACCEPT_RSP.  Resume SYSAP 
;				with success status.
;
;	Sequence # check	Send back a response that tells
;	fails			remote SCS this CDT went away.
;
; Inputs:
;
;	R2			-Addr of CONNECT_RSP message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

REC_ACCP_REQ:

	BSBW	SCS$CHK_SEQNUM		; Check that this is our CDT
	BLBC	R0,CDT_CLOSED		; Branch if not-- we must have
					;  done a unilateral disconnect
	$CHK_CDTSTATE	-		; Verify that the CDT state is
		CON_ACK,-		;  CONNECT ack'ed;  if not,
		ERROR=BREAK_VC		;  fatal state error
	BSBW	SCS$SAVE_REQ		; Save copy of ACCEPT_REQ message
	BSBW	SCS$COPY_ACCP		; Copy info from ACCEPT_REQ msg
					;  to local CDT
	MOVW	#CDT$C_OPEN,-		; Set CDT state open
		CDT$W_STATE(R3)		;
	MOVW	#SCS$C_STNORMAL,R0	; Set to send success response
	BSBW	SCS$SEND_RSP		; Send ACCEPT response to remote
	MOVZWL	#SS$_NORMAL,R0		; Set to return success
	MOVL	CDT$L_SCSMSG(R3),R2	; Get addr of success message
	MOVAL	SCS$T_DST_PROC(R2),R2	; Step R2 past SCS header
	BRW	RESUME_CONCALL		; Resume SYSAP 

CDT_CLOSED:

	MOVW	#SCS$C_STDISC,R0	; Set response status to error
	BRW	SCS$SEND_RSP		;  and send the response

	.DSABL	LSB

	.SBTTL	-	REC_ACCP_RSP,	PROCESS REC'D ACCEPT RESPONSE

;+
; This routine is called upon receipt of an ACCEPT_RSP message.  Action
; is as follows:
;
;	CDT State		Action
;
;	ACCP_SENT		If the ACCEPT_RSP has success status,
;				set CDT state open.  Resume SCS
;				send wait queue.  Resume SYSAP.
;				If the ACCEPT_RSP has fail status,
;				then clean up the CDT and return
;				the RSP error status to the SYSAP.
;
; Inputs:
;
;	R2			-Addr of ACCEPT_RSP message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

REC_ACCP_RSP:

	$CHK_CDTSTATE -			; Verify that CDT state is
		ACCP_SENT,-		;  accept sent;  if not,
		ERROR=BREAK_VC		;  fatal state error
	MOVW	#CDT$C_OPEN,-		; Move state to open
		CDT$W_STATE(R3)		;
	MOVL	CDT$L_SCSMSG(R3),R0	; Get CONNECT_REQ msg buffer
	PUSHL	R3			; Save addr of accepting CDT
	MOVL	SCS$L_DST_CONID(R0),R3	; Get addr of listening CDT
					;  saved by ACCEPT call
	BSBW	SCS$FREE_LISTEN		; Put listener back in listen state
	POPL	R3			; Retreive addr of accepting CDT
	BSBW	SCS$MAP_SCSSTS		; Map SCS status to VMS
	PUSHL	R0			; Save translated status
	BSBW	SCS$RESUM_SEND		; Resume SCS send wait queue
	POPL	R0			; Restore saved VMS status
	CMPW	R0,#SS$_NORMAL		; Was ACCEPT ok?
	BNEQ	ACCP_ABORT		; Branch if not
	BRW	RESUME_CONCALL		; Resume SYSAP

ACCP_ABORT:

	BRW	SCS$CLOSE_CDT		; Clean up the CDT that went
					;  with the ACCEPT request and
					;  notify caller that ACCEPT failed

	.DSABL	LSB

	.SBTTL	-	REC_REJ_REQ,	PROCESS REC'D REJECT REQUEST

;+
; This routine is called upon receipt of a REJECT_REQ message.  Action
; is as follows:
;
;	CDT State		Action
;
;	CON_ACK			Save reject reason and send REJECT_RSP.
;				Deallocate all buffers owned by CDT.
;				Deallocate CDT.  Resume SYSAP with
;				error status and reject reason.
;
;	Sequence # check	Send back a response that tells
;	fails			remote SCS that this CDT went away
;				via a unilateral DISCONNECT
;
; Inputs:
;
;	R2			-Addr of REJECT_REQ message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

REC_REJ_REQ:

	BSBW	SCS$CHK_SEQNUM		; Check if CDT is ours
	BLBC	R0,CDT_CLOSED		; Branch if not -- we must have
					;  done a unilateral DISCONNECT
	$CHK_CDTSTATE	-		; Verify that CDT state is
		CON_ACK,-		;  CONNECT ack'ed;  if not,
		ERROR=BREAK_VC		;  fatal state error
	BSBW	SCS$MAP_SCSSTS		; Translate SCS reason code to VMS
	PUSHL	R0			; Save reject reason
	MOVL	CDT$L_FR5(R3),R5	; Restore SYSAP's context: R5,
	PUSHL	CDT$L_FPC(R3)		;  and PC from CDT
	MOVZWL	#SCS$C_STNORMAL,R0	; Set for success status in RSP
	BSBW	SCS$SEND_RSP		; Send reject response
	BSBW	SCS$DEAL_ALLBUF		; Deallocate all buffers owned by CDT
	JSB	G^SCS$DEALL_CDT		; Deallocate the CDT
	MOVL	4(SP),R1		; Get reject reason again
	MOVZWL	#SS$_REJECT,R0		; Set main status = reject
	MOVL	R4,4(SP)		; Save PDT addr over reject reason
	JSB	@(SP)+			; Call SYSAP with error status
	POPL	R4			; Retreive PDT addr
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	REC_REJ_RSP,	PROCESS REC'D REJECT RESPONSE

;+
; This routine is called upon receipt of a REJECT_RSP message.  Action
; is as follows:
;
;	CDT State (listener)		Action
;
;	CON_REC				Return state to listen.  Resume
;					SCS send wait queue.  Resume
;					SYSAP with success regardless of the
;					status in the REJECT_RSP.
;
; Inputs:
;
;	R2			-Addr of REJECT_RSP message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;;-

	.ENABL	LSB

REC_REJ_RSP:

	$CHK_CDTSTATE -			; Verify that CDT state is
		REJ_SENT,-		;  is connect received;  if not,
		ERROR=BREAK_VC		;  fatal state error
	BSBW	SCS$DEAL_SCSREC		; Deallocate the SCS receive buffer
	BSBW	SCS$FREE_LISTEN		; Put listener back in listen state
	BSBW	SCS$RESUM_SEND		; Resume SCS send wait queue
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	BRW	RESUME_CONCALL		; Resume SYSAP

	.DSABL	LSB

	.SBTTL	-	REC_DISC_REQ,	PROCESS REC'D DISCONNECT REQUEST

;+
; This routine is called upon receipt or a DISCONNECT_REQ message.  It is 
; valid for several CDT states and action is as follows:
;
;	CDT State			Action
;
;	OPEN				Set state to disconnect received.
;					Save disconnect reason.  Send
;					DISCONNECT_RSP.  Call SYSAP error
;					address with error status and reason
;					code.
;
;	DISC_ACK			This is a matching DISCONNECT.
;					Send RSP.  Retreive saved SYSAP
;					context from CDT.  Deallocate 
;					CDT and receive buffers.  Complete
;					SYSAP's DISCONNECT call with 
;					success status.
;
;	DISC_SENT			This is a matching DISCONNECT
;					that crossed ours in the mail.
;					Send RSP and move CDT state to
;					DISC_MTCH.
;
;	Sequence # check		Send RSP with success status.
;	fails
;
; Inputs:
;
;	R2			-Addr of DISCONNECT_REQ message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

REC_DISC_REQ:

	BSBW	SCS$CHK_SEQNUM		; Verify that the CDT is still ours
	BLBC	R0,REC_DISC_CLOSED	; Branch if not-- must have done a
					;  unilateral DISCONNECT
	$DISPATCH -
		CDT$W_STATE(R3),-		; Dispatch on current state
		<-				;
		<CDT$C_OPEN,	REC_DISC_OPEN>,-;  OPEN,
		<CDT$C_DISC_ACK,REC_DISC_ACK>,-	;  DISCONNECT ack'ed,
		<CDT$C_DISC_SENT,REC_DISC_SENT>,- ;  DISCONNECT sent
		>

	BRW	BREAK_VC			; Fatal error if other state

REC_DISC_OPEN:

	MOVW	#CDT$C_DISC_REC,-	; Move state to disconnect received
		CDT$W_STATE(R3)		; 
	BSBW	SCS$MAP_SCSSTS		; Convert SCS status to VMS
	PUSHL	R0			;  and save it
	BSBW	SCS$SEND_RSP		; Send DISCONNECT response
	POPL	R1			; Restore disconnect reason
	MOVZWL	#SS$_DISCONNECT,R0	; Set status to disconnected
	PUSHL	R4			; Save R4
	JSB	@CDT$L_ERRADDR(R3)	; Call SYSAP error addr
	POPL	R4			; Restore R4
	RSB				; Return
	
REC_DISC_ACK:

	MOVW	#SCS$C_STDISC,R0	; Set response status
	BSBW	SCS$SEND_RSP		; Send response to DISCONNECT
	BRB	10$			; Complete SYSAP DISCONNECT call

REC_DISC_CLOSED:

	MOVW	#SCS$C_STDISC,R0	; Set response status
	BRW	SCS$SEND_RSP		; Send response to DISCONNECT

REC_DISC_SENT:

	MOVW	#SCS$C_STNORMAL,R0	; Set response status
	BSBW	SCS$SEND_RSP		; Send response
	MOVW	#CDT$C_DISC_MTCH,-	; Move CDT state to matching
		CDT$W_STATE(R3)		;  DISCONNECT received
	RSB				; Return

	.SBTTL	-	REC_DISC_RSP,	PROCESS REC'D DISCONNECT RESPONSE

;+
; This routine is called upon receipt of a DISCONNECT_RSP.  It is
; valid in more than one state and action is as follows:
;
;	CDT State			Action
;
;	DISC_SENT			This is a response to a
;					previously sent DISCONNECT.
;					Move CDT state to DISC_ACK
;					and exit.
;
;	DISC_MTCH			This is a response to a 
;					DISCONNECT sent that crossed
;					a received DISCONNECT in the
;					mail.  It is time to close the
;					CDT and notify the SYSAP that
;					its DISCONNECT is done.
;
; Inputs:
;
;	R2			-Addr of DISCONNECT_RSP message
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

REC_DISC_RSP:

	$DISPATCH -
		CDT$W_STATE(R3),-		; Check for legal state:
		<-				;
		<CDT$C_DISC_SENT,RSP_DISC_SENT>,- ;  DISCONNECT sent,
		<CDT$C_DISC_MTCH,RSP_DISC_MTCH>,- ;  Matching DISC rec'd
		>

	BRW	BREAK_VC		; Other state is fatal
	
RSP_DISC_SENT:

	MOVW	#CDT$C_DISC_ACK,-	; Move CDT state to
		CDT$W_STATE(R3)		;  DISCONNECT ack'ed
	BRW	SCS$RESUM_SEND		; Resume anyone waiting
					;  for SCS send buffer

RSP_DISC_MTCH:

	BSBW	SCS$RESUM_SEND		; Resume anyone waiting
					;  for SCS send buffer
10$:	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	BRW	SCS$CLOSE_CDT		;  and complete SYSAP DISCONNECT call

	.DSABL	LSB

	.SBTTL	CONNECTION AND SCS CONTROL SUBROUTINES
	.SBTTL	-	SCS$REQ_SCSSEND, REQUEST SEND OF SCS CONTROL 
	.SBTTL	-			MESSAGE

;+
; SCS$REQ_SCSSEND is called when an SCS control message is to be sent.  The
; block state defines the kind of control message to send:  CREDIT_REQ,
; CONNECT_REQ, REJECT_REQ, ACCEPT_REQ, DISC_REQ, or final
; CREDIT followed by DISCONNECT.  The CDT contains sufficient
; information to format the outgoing control message.
;
; Since a single SCS message buffer is available for each path to a
; remote system, SYSAP's may have to wait for the buffer to become available.
; The wait queue is a linked list of CDT's (linked via CDT$L_WAITQFL/BL) with
; listhead in the path block.  A CDT is removed from the wait queue as
; soon as it receives control of the SCS send message.  The SCS message
; address in the path block is used to determine if the send message
; buffer is currently available. (0/non-0 --> not avail/avail.)
;
; Only one block state may be in effect at a time for a CDT and therefore
; the CDT will never need to appear more than once on the wait queue.
; However, there are two cases where SCS$REQ_SCSSEND may be called for a 
; CDT that is already on the SCS send wait queue.  One case is where
; two msgs have been queued for receive, each triggers a CREDIT_REQ
; (likely if SCSFLOWCUSH and/or MIN_REC are greater than 0), and both
; must wait.  The second wait occurs when the CDT is already queued and
; waiting.  The second case is when a SYSAP issues a DISCONNECT on a 
; CDT which already waiting to send a credit.  In all cases, if the CDT
; is already waiting to send an SCS control message, it is okay to just
; change the block state to the new state as the CDT sits on the queue.
; The original request is then replaced by the new request.
;
; If the SCS send buffer is free, then the control message is sent immediately.
; Otherwise, the CDT block state is checked.  If zero, the CDT is inserted
; on the tail of the queue.  The CDT block state is then set.
;
; Inputs:
;
;	R0			-Block state code (l.o. 16 bits)
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$REQ_SCSSEND::

	MOVL	CDT$L_PB(R3),R1		; Get path block addr
	MOVL	PB$L_SCSMSG(R1),R2	; Get addr of SCS msg buffer
	BNEQ	SEND_NEXT_SEND		; Branch if buffer available
	TSTW	CDT$W_BLKSTATE(R3)	; CDT currently waiting to send?
	BNEQ	10$			; Branch if so
	INSQUE	CDT$L_WAITQFL(R3),-	; Link CDT to end of
		@PB$L_WAITQBL(R1)	;  SCS send wait queue

10$:	MOVW	R0,CDT$W_BLKSTATE(R3)	; Save block state
	RSB				; Return to caller (msg not
					;  yet sent)

;
; The SEND_NEXT_SEND entry is called when the SCS send message buffer
; is available to send a new control message.  The inputs to this entry:
;
;	R0			-Block state
;	R1			-Addr of PB
;	R2			-Addr of SCS message buffer
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;

;
; Block state value assumptions:
;

ASSUME	CDT$C_CON_PEND	EQ 1
ASSUME	CDT$C_ACCP_PEND	EQ 2
ASSUME	CDT$C_REJ_PEND	EQ 3
ASSUME	CDT$C_DISC_PEND	EQ 4
ASSUME	CDT$C_CR_PEND	EQ 5
ASSUME	CDT$C_DCR_PEND	EQ 6

SEND_NEXT_SEND:

	CLRL	PB$L_SCSMSG(R1)		; Show SCS send buffer unavail
	CASE	R0,<-			; Dispatch on block state:
		BLK_ST_ERR,-		;  undefined
		SEND_CONNECT,-		;  Send CONNECT_REQ
		SEND_ACCEPT,-		;  Send ACCEPT_REQ
		SEND_REJECT,-		;  Send REJECT_REQ
		SEND_DISCONNECT,-	;  Send DISCONNECT_REQ
		SEND_CREDIT,-		;  Send CREDIT_REQ
		SEND_CREDIT>		;  Send CREDIT_REQ+DISCONNECT_REQ

BLK_ST_ERR:

	BUGCHECK CIPORT			; Inconsistent CDT state field

	.DSABL	LSB

	.SBTTL	-	SEND_CREDIT,	SEND A CREDIT REQUEST

;+
; SEND_CREDIT -- Format and send a credit message.
;
; Inputs:
;
;	R0			-Block state
;	R1			-Addr of PB
;	R2			-Addr of message buffer
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

;
; Message format and CDT offset assumptions:
;

ASSUME	SCS$L_DST_CONID+4 EQ SCS$L_SRC_CONID
ASSUME	CDT$L_RCONID+4	  EQ CDT$L_LCONID

	.ENABL	LSB

SEND_CREDIT:

	CMPW	R0,#CDT$C_DCR_PEND	; Is this part of DISCONNECT?
	BNEQ	10$			; Branch if not
	INSQUE	CDT$L_WAITQFL(R3),-	; Else requeue CDT for 
		@PB$L_WAITQBL(R1)	;  DISCONNECT
	MOVW	#CDT$C_DISC_PEND,-	;  and move CDT state to
		CDT$W_BLKSTATE(R3)	;  DISCONNECT pending

10$:	MOVW	#SCS$C_CR_REQL,-	; Set length of CREDIT_REQ msg
		SCS$W_LENGTH(R2)	;
	MOVW	#SCS$C_CR_REQ,-		; Set SCS message type
		SCS$W_MTYPE(R2)		;

FMT_SCS_CREDIT:				; Entry for finishing SCS msg w/credit

	MOVW	CDT$W_PENDREC(R3),-	; Copy pending receive
		SCS$W_CREDIT(R2)	;  credit to message
	ADDW	CDT$W_PENDREC(R3),-	; Move pending recv credit to
		CDT$W_REC(R3)		;  receive credit
	CLRW	CDT$W_PENDREC(R3)	; Pending recv credit --> 0
	
FMT_SCS:				; Entry for finishing SCS w.o. credit

	MOVQ	CDT$L_RCONID(R3),-	; Set source connection ID
		SCS$L_DST_CONID(R2)	;  and remote connection ID
	BRB	SNDMSG			; Send message and return msg
					;  buffer to free queue for
					;  corresponding RSP

	.DSABL	LSB

	.SBTTL	-	SEND_CONNECT,	SEND A CONNECT_REQ

;+
; SEND_CONNECT -- Format and send a CONNECT_REQ message.
; COMMON_CONNECT -- Complete formatting and transmission of a CONNECT_REQ
;		    or ACCEPT_REQ message
;
; Inputs:
;
;	R1			-Addr of PB
;	R2			-Addr of start of message buffer
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
;	Connecting/Accepting CDT:
;
;	CDT$L_RPROCNAM		-Addr of remote proc name
;	      LPROCNAM		-Addr of local proc name
;	      CONDAT		-Addr of connect data from local
;	      INITREC		-Initial credit to extend
;	      RCONID		-Remote connection ID
;	      LCONID		-Local connection ID
;	      MINSEND		-Minimum send credit req'd by local SYSAP
;	      PDT		-PDT
;	      SCSMSG		-Addr of message buffer holding CONNECT_REQ
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

;
; Message and data structure adjacency assumptions.  These also apply
; to the following routine, SEND_ACCEPT.
;

ASSUME	SCS$W_MTYPE+2	EQ SCS$W_CREDIT
ASSUME	SCS$W_CREDIT+2	EQ SCS$L_DST_CONID
ASSUME	SCS$L_DST_CONID+4 EQ SCS$L_SRC_CONID
ASSUME	SCS$L_SRC_CONID+4 EQ SCS$W_MIN_CR
ASSUME	SCS$W_MIN_CR+2	EQ SCS$W_STATUS
ASSUME	SCS$W_STATUS+2	EQ SCS$T_DST_PROC
ASSUME	SCS$T_DST_PROC+16 EQ SCS$T_SRC_PROC
ASSUME	SCS$T_SRC_PROC+16 EQ SCS$B_CON_DAT

ASSUME	CDT$L_RCONID+4	EQ CDT$L_LCONID

ASSUME	CDT$L_RPROCNAM+4 EQ CDT$L_LPROCNAM
ASSUME	CDT$L_LPROCNAM+4 EQ CDT$L_CONDAT

	.ENABL	LSB

SEND_CONNECT:

	MOVW	#SCS$C_CON_REQL,-	; Set length of CONNECT_REQ msg
		SCS$W_LENGTH(R2)	;
	MOVAW	SCS$W_MTYPE(R2),R0	; Get addr of SCS msg type code
	MOVW	#SCS$C_CON_REQ,(R0)+	; Set type code

COMMON_CONNECT:

	MOVW	CDT$W_PENDREC(R3),(R0)+  ; Copy initial recv credit to msg
	MOVW	CDT$W_PENDREC(R3),-	; Copy initial to current recv credit
		CDT$W_REC(R3)		;  tally in CDT
	CLRW	CDT$W_PENDREC(R3)	; Zero pending receive
	MOVQ	CDT$L_RCONID(R3),(R0)+	; Copy remote (0) & local connx ID's
	MOVZWL	CDT$W_MINSEND(R3),(R0)+	; Copy min send credit req'd
	MOVAL	CDT$L_RPROCNAM(R3),R4	; Get addr of destination process name
	BSBB	MOV_PROCDATA		; Copy dest process name to msg
	BSBB	MOV_PROCDATA		;  Also, source process name,
	BSBB	MOV_PROCDATA		;  and connect data.
	MOVL	CDT$L_PDT(R3),R4	; Restore R4
SNDMSG:	CLRL	R0			; Send msg and return buffer to
	MOVL	CDT$L_PB(R3),R1		; Get PB addr in R1
	BRW	INT$SNDMSG		;  free queue for corresponding response


;
; Subroutine to move 16 bytes of data from source address pointed
; to by R4 to destination address in R0.
;

MOV_PROCDATA:

	MOVL	(R4)+,R1		; Get addr of source of data
	MOVQ	(R1)+,(R0)+		; Copy 16 bytes from source to
	MOVQ	(R1)+,(R0)+		;  message buffer
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SEND_ACCEPT,	SEND AN ACCEPT_REQ

;+
; SEND_ACCEPT -- Format and send an ACCEPT_REQ
;
; Inputs:
;
;	R1			-Addr of PB
;	R2			-Addr of start of message buffer
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
;	Accepting CDT:
;
;	CDT$L_RPROCNAM		-Addr of remote proc name
;	      LPROCNAM		-Addr of local proc name
;	      CONDAT		-Addr of connect data from local
;	      INITREC		-Initial credit to extend
;	      RCONID		-Remote connection ID
;	      LCONID		-Local connection ID
;	      MINSEND		-Minimum send credit req'd by local SYSAP
;	      PDT		-PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SEND_ACCEPT:

	MOVW	#SCS$C_ACCP_REQL,-	; Set length of ACCEPT_REQ msg
		SCS$W_LENGTH(R2)	;
	MOVAW	SCS$W_MTYPE(R2),R0	; Get addr of SCS msg type
	MOVW	#SCS$C_ACCP_REQ,(R0)+	; Set SCS msg type
	BRB	COMMON_CONNECT		; Join code common with CONNECT

	.DSABL	LSB

	.SBTTL	-	SEND_REJECT,	SEND A REJECT_REQ

;+
; SEND_REJECT -- Send a REJECT_REQ message
;
; Inputs:
;
;	R1			-Addr of PB
;	R2			-Addr of start of message buffer
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers 	-Preserved
;-

	.ENABL	LSB

SEND_REJECT:

	MOVW	#SCS$C_REJ_REQL,-	; Set REJECT_REQ msg length
		SCS$W_LENGTH(R2)	;
	MOVZWL	#SCS$C_REJ_REQ,-	; Set SCS msg type
		SCS$W_MTYPE(R2)		;  and zero credit field
	CLRW	SCS$W_MIN_CR(R2)	; Zero minimum credit field
	MOVW	CDT$W_REASON(R3),-	; Copy reject reason 
		SCS$W_STATUS(R2)	;  to status
	BRW	FMT_SCS			; Finish up and send msg

	.DSABL	LSB

	.SBTTL	-	SEND_DISCONNECT, SEND A DISCONNECT_REQ

;+
; SEND_DISCONNECT -- Format and send (at low priority) a DISCONNECT_REQ.
;
; Inputs:
;
;	R1			-Addr of PB
;	R2			-Addr of start of message buffer
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

;
; Message and CDT format assumptions:
;

ASSUME	SCS$W_MTYPE+2	EQ SCS$W_CREDIT
ASSUME 	SCS$L_DST_CONID+4 EQ SCS$L_SRC_CONID

ASSUME	CDT$L_RCONID+4	EQ CDT$L_LCONID

	.ENABL	LSB

SEND_DISCONNECT:

	MOVW	#SCS$C_DISC_REQL,-	; Set DISCONNECT_REQ length
		SCS$W_LENGTH(R2)	;
	MOVZWL	#SCS$C_DISC_REQ,-	;  and msg type;  and
		SCS$W_MTYPE(R2)		;  zero credit field
	CLRW	SCS$W_MIN_CR(R2)	; Zero minimum credit
	MOVW	CDT$W_REASON(R3),-	; Copy saved DISCONNECT
		SCS$W_STATUS(R2)	;  reason to status
	MOVQ	CDT$L_RCONID(R3),-	; Copy dest, src connx ID's
		SCS$L_DST_CONID(R2)	;
	CLRL	R0			; RETFLAG = 0
	BRW	INT$SNDMSGL		; Send off message at low
;		PRIORITY=LOW		;  priority behind all other
					;  currently queued msgs and
					;  block transfers

	.DSABL	LSB

	.SBTTL	-	SCS$RESUM_SEND, RESUME SCS CONTROL MESSAGE
	.SBTTL	-			 SEND QUEUE

;+
; This routine is called when an SCS control message response is received.
; Receipt of the response indicates that the SCS send buffer is now free
; and a new SCS control message may be sent to the remote system.  The 
; response message buffer is used for the next send.
;
; The wait queue (listhead PB$L_WAITQFL) is checked for waiting CDT's.
; If any CDT is waiting, then it is dequeued and its SCS control message
; sent.  If no CDT is waiting, then the buffer containing the response
; is linked to the path block for future use.
;
; Inputs:
;
;	R2			-Addr of SCS response message buffer
;	R3			-Addr of CDT receiving SCS RSP message
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$RESUM_SEND:

	MOVL	CDT$L_PB(R3),R1		; Get path block addr
	PUSHL	R3			; Save CDT receiving response
	REMQUE	@PB$L_WAITQFL(R1),R3	; Get CDT waiting to send
	BVS	20$			; Branch if nobody waiting
	SUBL	#CDT$L_WAITQFL,R3	; Back up to start of CDT
	MOVW	CDT$W_BLKSTATE(R3),R0	; Get block state
	CLRW	CDT$W_BLKSTATE(R3)	; Zero block state of resumed CDT
	BSBW	SEND_NEXT_SEND		; Go send the message
	BRB	30$			; Join common exit

20$:	MOVL	R2,PB$L_SCSMSG(R1)	; Save SCS msg addr for future
	
30$:	POPL	R3			; Restore CDT receiving response
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$SEND_RSP,	TURN SCS REQ AROUND INTO
	.SBTTL	-			SCS RESPONSE

;+
; One receive message buffer per port-port virtual circuit is reserved
; for receipt of SCS REQ control messages by all connections on the
; VC.  This routine is called with the reserved receive buffer 
; occupied by an SCS REQ.  SCS$SEND_RSP modified the REQ type message
; into its corresponding RSP and sends it to the remote system.  The
; RSP message is sent with RETFLAG false so that the message buffer is
; returned to the free queue to receive a new SCS REQ. 
;
; Note that certain SCS commands must be retained by the caller
; for further processing by the SYSAP.  These are CONNECT_REQ and
; ACCEPT_REQ.  the caller is expected om these cases to have copied
; the REQ message into the SCS buffer allocated for each CDT 
; (CDT$L_SCSMSG).
;
; Inputs:
;
;	R0			-Status to send out with RSP, 0 if none
;	R1			-Credit to confirm if applicable
;	R2			-Addr of SCS REQ message
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

;
; Message format assumptions:
;

ASSUME	SCS$C_CON_REQ	EQ 0
ASSUME	SCS$C_CON_RSP	EQ 1
ASSUME	SCS$C_ACCP_REQ	EQ 2
ASSUME	SCS$C_ACCP_RSP	EQ 3
ASSUME	SCS$C_REJ_REQ	EQ 4
ASSUME	SCS$C_REJ_RSP	EQ 5
ASSUME	SCS$C_DISC_REQ	EQ 6
ASSUME	SCS$C_DISC_RSP	EQ 7
ASSUME	SCS$C_CR_REQ	EQ 8
ASSUME	SCS$C_CR_RSP	EQ 9

ASSUME	SCS$C_REJ_RSPL	EQ SCS$C_DISC_RSPL

	.ENABL	LSB

SCS$SEND_RSP:

	CASE	SCS$W_MTYPE(R2),<-	; Dispatch on request type
		SEND_CON_RSP,-		;  CONNECT_REQ
		ILLMSGTYP,-		;  CONNECT_RSP illegal
		SEND_ACCP_RSP,-		;  ACCEPT_REQ
		ILLMSGTYP,-		;  ACCEPT_RSP illegal
		SEND_REJ_RSP,-		;  REJECT_REQ
		ILLMSGTYP,-		;  REJECT_RSP illegal
		SEND_DISC_RSP>		;  DISCONNECT_REQ

ILLMSGTYP:

	BUGCHECK  CIPORT		; Any other type is illegal

SEND_ACCP_RSP:

	MOVW	#SCS$C_ACCP_RSPL,-	; Set response message length
		SCS$W_LENGTH(R2)	;
	BRB	COMMON_RSP2		; Join common formatting

SEND_REJ_RSP:
SEND_DISC_RSP:

	MOVW	#SCS$C_REJ_RSPL,-	; Set response message length
		SCS$W_LENGTH(R2)	;
	BRB	COMMON_RSP2		; Join common formatting

SEND_CON_RSP:

	MOVW	#SCS$C_CON_RSPL,-	; Set CONNECT_RSP length
		SCS$W_LENGTH(R2)	;
	CLRW	SCS$W_MIN_CR(R2)	; Zero minimum credit
	BRB	COMMON_RSP2		; Join common code

SEND_CR_RSP:

	MOVW	#SCS$C_CR_RSPL,-	; Set credit RSP length
		SCS$W_LENGTH(R2)	;

COMMON_RSP1:

	INCW	SCS$W_MTYPE(R2)		; Convert type from REQ to RSP
	MOVL	SCS$L_DST_CONID(R2),R0	; Swap destination
	MOVL	SCS$L_SRC_CONID(R2),-	;  and
		SCS$L_DST_CONID(R2)	;  source
	MOVL	R0,SCS$L_SRC_CONID(R2)	;  connection ID's
	CLRL	R0			; RETFLAG = false
	BRW	INT$TRNMSG
;	$TURNMSG RETFLAG=FALSE		; Send off message

COMMON_RSP2:

	CLRW	SCS$W_CREDIT(R2)	; Credit = 0
	MOVW	R0,SCS$W_STATUS(R2)	; Status = caller-specified value
	BRB	COMMON_RSP1		; Join common completion

	.DSABL	LSB

	.SBTTL	-	SCS$COPY_ACCP, COPY CONNECTION PARAMETERS
	.SBTTL	-			 FROM ACCEPT MESSAGE TO CDT

;+
; SCS$COPY_ACCP copies the credit, sender's connect ID, and minimum
; credit from the CONNECT_REQ or ACCEPT_REQ message to the SEND credit,
; RCONID, and MINSEND fields of the CDT.
;
; Inputs:
;
;	R2			-Addr of message contianing CONNECT_REQ
;				 or ACCEPT_REQ 
;	R3			-Addr of CDT
;
; Outputs:
;
;	All registers		-Preserved
;
;-

	.ENABL	LSB

SCS$COPY_ACCP::

	MOVW	SCS$W_CREDIT(R2),-	; Copy extended credit to CDT
		CDT$W_SEND(R3)		;
	MOVL	SCS$L_SRC_CONID(R2),-	; Copy remote CONID to CDT
		CDT$L_RCONID(R3)	;
	MOVW	SCS$W_MIN_CR(R2),-	; Copy remote SYSAP's minimum
		CDT$W_MINREC(R3)	;  send credit to CDT
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$SAVE_REQ,	COPY SCS REQUEST TO SECOND
	.SBTTL	-			MESSAGE BUFFER

;+
; SCS$SAVE_REQ copies a received SCS request to an SCS message buffer
; attached to a CDT.  This routine is called when a copy of the request
; must be retained while the initial message is turned around into an
; SCS response.
;
; Inputs:
;
;	R2			-Addr of SCS buffer containing request
;	R3			-Addr of CDT
;	CDT$L_SCSMSG		-Addr of CDT's SCS msg buffer
;
; Outputs:
;
;	R0,R1			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$SAVE_REQ:

	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	CDT$L_SCSMSG(R3),R3	; Pick up receiving buffer
	MOVC3	#SCS$C_CON_REQL, -
		 SCS$W_MTYPE-2(R2),-
		 SCS$W_MTYPE-2(R3)	; Copy message
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return

	.DSABL	LSB

	.SBTTL	MESSAGE AND DATAGRAM BUFFER ALLOCATION
	.SBTTL	-	SCS$ALL_ALLBUF,	ALLOCATE ALL BUFFERS NEEDED
	.SBTTL	-			FOR A NEW CONNECTION

;+
; SCS$ALL_ALLBUF allocated from nonpaged pool:
;
;	1 SCS buffer for connect request storage, linked to CDT$L_SCSMSG
;	Initial receive credit worth of message buffers
;	Initial dg receive count of datagram buffers.
;
; The message buffers and datagram buffers are inserted on the
; port free queues for receiving messages and datagrams.
;
; Entry SCS$ALL_ALLBUF2 is called to allocate all except the SCS receive buffer.
;
; Inputs:
;
;	R3			-Addr of CDT getting buffers
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$INSFMEM
;				 (If insufficient pool, everything
;				  allocated so far is deallocated.)
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$ALL_ALLBUF::

	BSBB	SCS$ALL_SCSREC		; Allocate SCS recv buffer
	BLBC	R0,40$			; Branch if error

SCS$ALL_ALLBUF2::

	MOVW	CDT$W_INITLREC(R3),-	; Copy initial receive count to
		CDT$W_PENDREC(R3)	;  pending credit to remote
	CLRW	CDT$W_REC(R3)		; Clear current receive count
	BSBW	SCS$ALL_MSGREC		; Allocate message buffers
	BLBC	R0,30$			; Branch if error
	BSBW	SCS$ALL_DGREC		; Allocate datagram buffers
	BLBC	R0,20$			; Branch if error
	RSB				; Return success

20$:	BSBW	SCS$DEAL_MSGREC		; Deallocate message buffers
30$:	BSBW	SCS$DEAL_SCSREC		; Deallocate SCS recv buffer

40$:	MOVZWL	#SS$_INSFMEM,R0		; Set error status
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$ALL_SCSREC,	ALLOCATE A MESSAGE BUFFER FOR
	.SBTTL	-			HOLDING COPY OF SCS REQUESTS

;+
; This routine allocates one message buffer and links it to the
; CDT$L_SCSMSG.
;
; Inputs:
;
;	R3			-Addr of CDT getting buffer
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL,  SS$_INSFMEM
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$ALL_SCSREC:

	BSBW	INT$ALLOC_MSG		; Allocate 1 message buffer from pool
	BLBC	R0,10$			; Branch if didn't get it
	MOVL	R2,CDT$L_SCSMSG(R3)	; Save its address in CDT
10$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$ALL_MSGREC,	ALLOCATE BUFFERS FOR RECEIVING
	.SBTTL	-			APPLICATION MESSAGES
	.SBTTL	-	SCS$ALL_FRMSGS,	ALLOCATE MESSAGE BUFFERS AND
	.SBTTL	-			PUT ON PORT FREE QUEUE

;+
; This routine allocates the number of message buffers specified in 
; CDT$W_INITLREC or R0, linking them together as they are allocated.
; If all are allocated successfully, then they are inserted on the
; port free message queue and successful return is taken.
; If there is an allocate failure, then the buffers allocated already
; are returned to pool and error is returned to the caller.
;
; Inputs:
;
;	R0			-# buffers to allocate (SCS$ALL_FRMSGS)
;	R3			-Addr of CDT (SCS$ALL_MSGREC entry)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$ALL_FRMSGS::

	TSTL	R0			; Any buffers to allocate?
	BRB	5$			; Join common code

SCS$ALL_MSGREC:

	MOVZWL	CDT$W_INITLREC(R3),R0	; Get # buffers to allocate
5$:	BEQL	40$			; Branch if 0
	PUSHL	R5			; Save R5
	PUSHL	R3			;  and R3 
	MOVL	R0,R3			; R3 will be buffer counter
	CLRL	R5			; Set link to next buffer = 0

10$:	BSBW	INT$ALLOC_MSG		; Allocate next buffer
	BLBC	R0,50$			; Branch if failed
	MOVL	R5,(R2)			; Link this buffer to last allocated
	MOVL	R2,R5			; Set R5 to point to this buffer
	SOBGTR	R3,10$			; Branch if more to allocate
	POPL	R3			; Restore R3
	
20$:	MOVL	R5,R2			; Get addr of next buffer
	BEQL	30$			; Branch if no more
	MOVL	(R2),R5			; Update ptr to next buffer
	BSBW	INT$INS_MFREEQ		; Insert buffer on port free queue
	BRB	20$			; Branch for next buffer

30$:	POPL	R5			; Restore saved register

40$:	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return

50$:	MOVL	R5,R2			; Get addr of next buffer
	BEQL	NO_MSG_MEM		; Branch if done
	MOVL	(R2),R5			; Update ptr to next buffer
	BSBW	INT$DEAL_MSG		; Return buffer to pool
	BRB	50$			; Check for more buffers

NO_MSG_MEM:

	MOVZWL	#SS$_INSFMEM,R0		; Set status to fail
	POPL	R3			; Restore registers 
	POPL	R5			;
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$ALL_DGREC,	ALLOCATE BUFFERS FOR RECEIVING
	.SBTTL	-			APPLICATION DATAGRAMS
	.SBTTL	-	SCS$ALL_FRDGS,	ALLOCATE FREE DATAGRAMS AND 
	.SBTTL	-			PUT ON PORT QUEUE

;+
; This routine allocates the number of datagrams specified in
; CDT$W_DGREC or R0, linking them together as allocated.  If all are allocated
; successfully, then they are inserted on the port free datagram queue.
; Otherwise, the buffers allocated already are returned to pool and error
; is returned to the caller.
;
; Inputs:
;
;	R0			-# datagram buffers to allocate
;				 (SCS$ALL_FRDGS entry)
;	R3			-Addr of CDT (SCS$ALL_DGREC entry)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$INSFMEM
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$ALL_FRDGS::

	TSTL	R0			; Any datagrams to get?
	BRB	5$			; Join common code

SCS$ALL_DGREC:

	MOVZWL	CDT$W_DGREC(R3),R0	; Get # buffers to allocate
5$:	BEQL	40$			; Branch if 0
	PUSHL	R5			; Save R5
	PUSHL	R3			;  and R3
	MOVL	R0,R3			; R3 will be buffer counter
	CLRL	R5			; Set link to next buffer = 0

10$:	BSBW	INT$ALLOC_DG		; Allocate next buffer
	BLBC	R0,50$			; Branch if failed
	MOVL	R5,(R2)			; Link this buffer to last allocated
	MOVL	R2,R5			; Set R5 to point to this buffer
	SOBGTR	R3,10$			; Branch if more to allocate
	POPL	R3			; Retreive R3

20$:	MOVL	R5,R2			; Get addr of next buffer
	BEQL	30$			; Branch if no more
	MOVL	(R2),R5			; Update ptr to next buffer
	BSBW	INT$INS_DFREEQ 		; Insert buffer on port free queue
	BRB	20$			; Branch for next buffer

30$:	POPL	R5			; Restore saved register

40$:	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return

50$:	MOVL	R5,R2			; Get addr of next buffer
	BEQL	NO_MSG_MEM		; Branch if no more
	MOVL	(R2),R5			; Update ptr to next buffer
	BSBW	INT$DEAL_DG		; Return buffer to pool
	BRB	50$			; Check for more buffers

	.DSABL	LSB

	.SBTTL	-	SCS$DEAL_ALLBUF, DEALLOCATE ALL BUFFERS NEEDED
	.SBTTL	-			 FOR A CONNECTION

;+
; DEALL_BUF deallocates the following to nonpaged pool:
;
;	1 SCS message buffer (linked to CDT$L_SCSMSG)
;	Initial receive credit worth of message buffers
;	DG receive count of datagram buffers
;
; It is the caller's responsibility to guarantee that all the message 
; buffers and datagram buffers claimed to be on the port free queue
; are actually there.
;
; Inputs:
;
;	R3			-Addr of CDT returning buffers
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

SCS$DEAL_ALLBUF::

	BSBB	SCS$DEAL_SCSREC		; Deallocate the SCS buffer
					;  attached to the CDT
	BSBB	SCS$DEAL_DGREC		; Deallocate the dg buffers
					;  attached to the port free queue
;	BSBW	SCS$DEAL_MSGREC		; Deallocate the message buffers
;					;  attached to the port free queue
;	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$DEAL_MSGREC, DEALLOCATE BUFFERS QUEUED TO
	.SBTTL	-			PORT FOR RECEIVING APPLICATION
	.SBTTL	-			MESSAGES

;+
; SCS$DEAL_MSGREC extracts the current recv credit worth of message buffers
; from the port free queue and returns them to pool.
;
; Inputs:
;
;	R3			-Addr of CDT returning buffers
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	other registers		-Preserved
;	
;	CDT$W_REC(R3)		-0
;-

	.ENABL	LSB

SCS$DEAL_MSGREC:

	PUSHL	R2			; Save register
	ADDW	CDT$W_PENDREC(R3),-	; Compute total credit = pending
		CDT$W_REC(R3)		;  + receives given to remote

10$:	TSTW	CDT$W_REC(R3)		; Any buffers left to deallocate?
	BEQL	30$			; Branch if not
	BSBW	INT$MFQ2POOL		; Else remove another from port
	BVS	30$			; Branch if no more -- normally does't
					;  happen except during power fail recov
	DECW	CDT$W_REC(R3)		; Decr count of # buffers left
	BRB	10$			; Deallocate again

	.SBTTL	-	SCS$DEAL_DGBUF, DEALLOCATE BUFFERS QUEUED TO PORT
	.SBTTL	-			FOR RECEIVING DATAGRAMS

;+
; SCS$DEAL_DGREC extracts the current number of datagrams contributed by
; this connection to the free queue and returns them to nonpaged pool
;
; Inputs:
;
;	R3			-Addr of CDT returning datagrams
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;-

SCS$DEAL_DGREC:

	PUSHL	R2			; Save register

20$:	TSTW	CDT$W_DGREC(R3)		; Any buffers left to deallocate?
	BEQL	30$			; Branch if not
	BSBW	INT$DFQ2POOL		; Remove another buffer to pool
	BVS	30$			; Branch if no more-- normally doesn't
					;  happen except on power fail recovery
	DECW	CDT$W_DGREC(R3)		; Decr count of # dgs contributed
					;  by this connection
	BRB	20$			; Deallocate again

	.SBTTL	-	SCS$DEAL_SCSREC, DEALLOCATE SCS RECEIVE BUFFER

;+
; SCS$DEAL_SCSREC deallocates to nonpaged pool the message buffer,
; if any, pointed to by CDT$L_SCSMSG.
;
; Inputs:
;
;	R3			-Addr of the CDT returning the buffer
;
; Outputs:
;
;	R0			-Destroyed
;	other registers		-Preserved
;-

SCS$DEAL_SCSREC::

	PUSHL	R2			; Save a register
	MOVL	CDT$L_SCSMSG(R3),R2	; Get buffer address
	BEQL	30$			; Branch if none
	BSBW	INT$DEAL_MSG		; Return to pool
	CLRL	CDT$L_SCSMSG(R3)	; Show no SCS buffer in CDT

30$:	POPL	R2			; Restore a register
	RSB				; Return

	.DSABL	LSB

	.SBTTL	MISC ROUTINES
	.SBTTL	-	BREAK_VC,	CRASH A VIRTUAL CIRCUIT

;+
; BREAK_VC is branched to from various SCS message receive routines
; when an SCS control message is received which is inappropriate
; to the current CDT state, has an illegal SCS message type, or performs
; unexpected action.  The remote system is assumed to have a broken SCS.
; The error is logged.  Routine ERR$CRASHVC is called to look up the path 
; block associated with the message and close the virtual circuit to the
; remote.  The message in hand is occupying either: (1) the SCS send buffer
; in which virtual circuit failure expects to find it either in PB$L_SCSMSG
; or on the free queue, or (2) the SCS receive buffer in which case 
; virtual circuit failure expects to find it on the free queue.  Action
; here is to return it to the free queue regardless of whether it is the
; SCS send or receive buffer.  Return is to interrupt service to dequeue
; the next response.
;
; Inputs:
;
;	R2			-SCS message addr
;	R3			-CDT addr
;	R4			-PDT addr
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Perserved
;-

	.ENABL	LSB

BREAK_VC:

	MOVL	CDT$L_PB(R3),R1		; Pick up Path Block address
	MOVZBL	#PAER$K_ES_SCA, R0	; Log inappropriate SCS - SCA control
	BSBW	ELOG$PACKET		; message received error.
	BSBW	ERR$CRASHVC		; Call error handler to init
					;  close of VC
	BRW	INT$INS_MFREEQ		; Put msg back on free queue to
					;  be reclaimed when it is time
					;  to delete the path block
					; Return to interrupt service

	.DSABL	LSB

	.SBTTL	-	SCS$FREE_LISTEN,PUT BUSY LISTEN CDT
	.SBTTL	-			BACK IN LISTEN STATE

;+
; SCS$FREE_LISTEN deallocates the SCS receive buffer, if any, held
; by the specified CDT, searches for the CDT in the path block
; CDT list, removes the CDT from the list, and sets the CDT state
; to LISTEN.
;
; Inputs:
;
;	R3			-Addr of CDT 
;
; Outputs:
;
;	R0			-Destroyed
;
;	Other registers		-Preserved
;
;	CDT$W_STATE(R3)		-LISTEN state
;-

	.DSABL	LSB

SCS$FREE_LISTEN::

	PUSHL	R1			; Save caller's R1
	BSBW	SCS$DEAL_SCSREC		; Deallocate SCS recv buffer, if any
	MOVL	CDT$L_PB(R3),R1		; Get PB associdated with CDT
	MOVAL	PB$L_CDTLST(R1),R1	; Get addr of 1st fwd link

10$:	MOVL	(R1),R0			; Get next CDT
	BEQL	30$			; Branch if no more
	CMPL	R0,R3			; CDT we are looking for?
	BEQL	20$			; Branch if so
	MOVAL	CDT$L_CDTLST(R0),R1	; Save addr of this link
	BRB	10$			; Go for another CDT

20$:	MOVL	CDT$L_CDTLST(R0),(R1)	; Unlink this CDT from list
	
30$:	MOVW	#CDT$C_LISTEN,-		; Put CDT in listen state
		CDT$W_STATE(R3)		;
	POPL	R1			; Restore caller's R1
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	RESUME_CONCALL,	RESUME A CONNECTION
	.SBTTL	-			MANAGEMENT CALL

;+
; RESUME_CONCALL resumes the fork process context saved in the CDT
; during a CONNECT, ACCEPT, or REJECT call.
;
; Inputs:
;
;	R0			-Completion status of connection
;				 management call
;	R1			-Other status, if applicable
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;	(SP)			-Return to PAINIT, interrupt service
;
; Outputs:
;
;	R0-R3,R5		-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

RESUME_CONCALL:

	MOVL	CDT$L_FR5(R3),R5	; Restore SYSAP R5
	PUSHL	R4			; Save R4
	JSB	@CDT$L_FPC(R3)		; Call SYSAP back
	POPL	R4			; Restore R4
	RSB				; Return to interrupt service
					;  to dequeue more responses

	.DSABL	LSB

	.SBTTL	-	SCS$CHK_SEQNUM,	CHECK FOR VALID
	.SBTTL	-			SEQUENCE # IN 
	.SBTTL	-			CONNECTION ID

;+
; SCS$CHK_SEQNUM compares the sequence number fields in the
; destination connection ID in a specifed SCS message and specified
; CDT.  If they are equal, then the CDT is current for this message
; and success is returned.  If they are not equal, then this CDT was
; unilaterally closed sometime in the past and does not belong to
; a current CDT and fail status is returned.
;
; Inputs:
;
;	R2			-Addr of message/dg
;	R3			-Addr of CDT
;
; Outputs:
;
;	R0			-Status:  LBS/C for CDT OK/invalid
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$CHK_SEQNUM:

	CLRL	R0			; Assume failure
	CMPW	SCS$L_DST_CONID+2(R2),-	; Compare seq # in dest conid
		CDT$L_LCONID+2(R3)	;  and in conid in CDT
	BNEQ	10$			; Branch if not the same (fail)
	INCL	R0			; Else set status to success

10$:	RSB				; Return status

	.DSABL	LSB

	.SBTTL	-	SCS$CLOSE_CDT,	CLEANUP CDT AND COMPLETE
	.SBTTL	-			PENDING CONNX MGMT CALL

;+
; SCS$CLOSE_CDT retreives the saved SYSAP context from the specified CDT
; for a pending CONNECT/ACCEPT/REJECT/DISCONNECT call, deallocates the
; CDT and msgs/dgs queued for receive, and completes the SYSAP's pending
; call.
;
; Inputs:
;
;	R0			-VMS status to complete pending call
;	R1			-Aux status, if any
;	R3			-CDT to clean up
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$CLOSE_CDT::

	MOVQ	R4,-(SP)		; Save R4, R5
	MOVL	CDT$L_FR5(R3),R5	; Get SYSAP context, R5
	PUSHL	CDT$L_FPC(R3)		;  and PC
	MOVQ	R0,-(SP)		; Save status
	BSBW	SCS$DEAL_ALLBUF		; Deallocate receive buffers 
	JSB	G^SCS$DEALL_CDT		;  and CDT
	MOVQ	(SP)+,R0		; Retreive status
	JSB	@(SP)+			; Call SYSAP's return addr
	MOVQ	(SP)+,R4		; Restore R4, R5
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$MAP_SCSSTS	MAP SCS STATUS TO VMS STATUS

;+
; SCS$MAP_SCSSTS gets the SCS status contained in the SCS
; message pointed to by R2.  The corresponding VMS status is looked
; up and returned in R0.  (The status tables are contained in 
; SCS_STATUS_TAB and VMS_STATUS_TAB.)  If the SCS status is not
; in the translation table, it is returned as is.
;
; Inputs:
;
;	R2			-SCS message address
;
; Outputs:
;
;	R0			-L.o. word:  converted status
;				 or SYSAP-specific status.  H.o.
;				 word = 0.
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$MAP_SCSSTS:

	PUSHR	#^M<R1,R2,R3>		; Save registers
	MATCHC	#2,SCS$W_STATUS(R2),-	; Look up status in
		#SCS_STATUS_LEN,-	;  SCS status list
		SCS_STATUS_TAB		;
	BNEQ	20$			; Branch if did not find it
	MOVZWL	SCS_STATUS_LEN-2(R3),R0	; Get corresponding VMS status
	POPR	#^M<R1,R2,R3>		; Restore registers
	RSB				; Return

20$:	POPR	#^M<R1,R2,R3>		; Restore registers
	MOVZWL	SCS$W_STATUS(R2),R0	; Return original status
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$MAP_VMSSTS,	MAP VMS STATUS TO SCS

;+
; SCS$MAP_VMSSTS converts a VMS status code to the corresponding SCS
; code.  If the VMS code is not in the conversion table, then the VMS
; code is returned unchanged.
;
; Inputs:
;
;	R0			-VMS code (l.o. 16 bits only)
;	
; Outputs:
;
;	R0			-SCS code, if conversion is successful,
;				 otherwise, VMS code
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$MAP_VMSSTS::

	PUSHR	#^M<R0,R1,R2,R3>	; Save caller's registers
	MATCHC	#2,(SP),#SCS_STATUS_LEN,-  ; Look up R0 status in table
		VMS_STATUS_TAB		;
	BNEQ	20$			; Branch if didn't find it
	MOVZWL	-SCS_STATUS_LEN-2(R3),R0 ;Get corresponding SCS code
	TSTL	(SP)+			; Discard caller's R0
	POPR	#^M<R1,R2,R3>		; Restore other registers
	RSB				; Return

20$:	POPR	#^M<R0,R1,R2,R3>	; Restore all caller's registers
	RSB				; Return

	.DSABL	LSB

	.SBTTL	ERROR HANDLING ROUTINES
	.SBTTL	-	SCS$DISC_VCFAIL, PROCESS DISCONNECT CALL
	.SBTTL	-			 FOR CDT ON FAILING PB

;+
; SCS$DISC_VCFAIL is called by FPC$DCONNECT when the SYSAP issues a 
; DISCONNECT for a connection associated with a path block that has
; a virtual circuit failure in progress.  The CDT is placed in a
; virtual circuit fail state.  If this is the last CDT on the path
; block to be DISCONNECTed, then a marker message is sent to the
; port.  Receipt of the error response for the marker (handled in
; SCS$CACHECLR) tells us that the port cache is completely purged
; of all command queue entries for this virtual circuit.
;
; Inputs:
;
;	IPL			-Fork IPL
;
;	R1			-Addr of PB
;	R3			-Addr of CDT being DISCONNECTed
;	R4			-Addr of PDT
;
;	CDT$W_STATE(R3)		-Any except CLOSED
;
;	(SP)			-Addr of return to SYSAP
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$DISC_VCFAIL::

	$DISPATCH	-		; Dispathc on CDT state:
		CDT$W_STATE(R3),-	;
		<-			;
		<CDT$C_CON_REC,	20$>,-	;  Connect received on LISTEN,
		<CDT$C_REJ_SENT,20$>,-	;  Connect received on LISTEN,
		<CDT$C_VC_FAIL,	30$>,-	;  DISCONNECT already isssued,
		>			;  All other states:

	MOVW	#CDT$C_VC_FAIL,-	; Set state to VC failure
		CDT$W_STATE(R3)		;

10$:	BSBW	CHK_NO_CDTS		; Send cache clear if all
					;  CDTs have been disconnected
	MOVL	R5,CDT$L_FR5(R3)	; Suspend this DISCONNECT
	POPL	CDT$L_FPC(R3)		;  until cache is clear
	RSB				; Return to caller's caller

20$:	BSBW	SCS$FREE_LISTEN		; Put CDT back in LISTEN state
	BRB	10$			; Join common check for no CDT's

30$:	MOVZWL	#SS$_NORMAL,R0		; Return success to SYSAP
	RSB				; 

	.DSABL	LSB

	.SBTTL	-	SCS$VC_CLOSED,	HANDLE VC CLOSED ON
	.SBTTL	-			SPECIFIED PATH BLOCK

;+
; SCS$VC_CLOSED checks if a vc failure is already underway.  This could
; happen if a REQID immediately followed by a SNDMSG both discover
; that there is no path to the target.  The REQID initiates vc
; closure by sending a SETCKT closed command to the port.  The
; SNDMSG then tries to do a cache clear while the SETCKT is still
; in progress.  The SETCKT and the cache clear need to use the
; same packet.  Further, if this routine were called twice in this
; situation, then sysap's would be notified twice.  Therefore, if
; a vc failure is underway, simply return, letting the first vc
; circuit take care of all the bookkeeping.
;
; SCS$VCCLOSED checks if there are any CDT's linked on the PB.
; If not, it calls CNF$REMOVE_PB to clean up the configuration.
; If so, it calls SCS$NOTIFY_SYSAP to notify all SYSAPs involved. 
;
; SCS$SETCKT_CLSD is a separate entry to this routine which bypasses
; the check if a vc failure is in progress.  SCS$SETCKT_CLSD is called
; by PAINTR upon receipt of a SETCKT closed response.  A vc failure should
; always be marked in progress  in this case.
;
; Inputs:
;
;	IPL			-Fork IPL
;
;	R1			-Addr of failing PB, 0 if none
;				 (on SCS$SETCKT_CLSD there will always be
;				 a PB.)
;	R2			-Addr of RSP
;	R3			-Failure reason (VMS status code)
;	R4			-PDT addr
;
;	VC state		-Closed by port
;
; Outputs:
;
;	R0,R1,R3		-Destroyed
;	Other registers		-Preserved;  in particular, the msg/dg
;				 pointed to is not disposed of.  That is
;				 the caller's responsibility.
;-

	.ENABL	LSB

SCS$VCCLOSED::

	TSTL	R1			; Check PB addr for remote port
	BEQL	CONFIG_ERR		; There is none, log error
	CMPW	PB$W_STATE(R1),-	; Is a vc failure already in 
		#PB$C_VC_FAIL		;  progress?
	BEQL	40$			; Branch if so.

SCS$SETCKT_CLSD::

	PUSHL	R2			; Save caller's register
	MOVW	#PB$C_VC_FAIL,-		; Set VC failure in progess
		PB$W_STATE(R1)		;
	TSTL	PB$L_CDTLST(R1)		; Any CDT's on this PB?
	BNEQ	20$			; Branch if so
	MOVL	R1,R3			; Transfer PB address
	BSBW	CNF$REMOVE_PB		; Else remove PB/SB
	BRB	30$			; Return

20$:	MOVZWL	PB$W_VCFAIL_RSN(R1),R0	; Get possible remote host shutdown
					;  reason for vc failure
	BNEQ	25$			; Branch if there is a reason saved
	MOVL	R3,R0			; Else just copy the status handed
					;  as input to this routine

25$:	MOVL	R1,R3			; Transfer path block
	BSBB	SCS$NOTIFY_SYSAP	; Handle all CDT's in list
30$:	POPL	R2			; Restore caller's register

40$:	RSB				; Return to caller to drain
					;  response

CONFIG_ERR:

	$DEBUGCHECK #ERR$V_DEB_CNFER	; Optionally bugcheck on this error
	CVTWL	#<PAER$K_ES_NOPB ! ^X8000>, R0	; Log failure to find PB for
	BSBW	ELOG$PACKET			; given message while closing
						; VC error (crashes port).
	BRW	ERR$CRASH_PORT		; Init port crash

	.DSABL	LSB

	.SBTTL	-	SCS$NOTIFY_SYSAP, SEARCH CDT LIST AND
	.SBTTL	-			  HANDLE CDT'S IN
	.SBTTL	-			  VARIOUS STATES

;+
; NOTIFY_SYSAP is called by SCS$VCCLOSED and ERR$PWF_RECOV to search the
; CDT list associated with a path block and notify the SYSAP appropriately
; depending upon the CDT state.  It scans the CDT list for that path.  For
; each open CDT found, the SYSAP's error entry is called to notify the
; SYSAP of the virtual circuit failure.  The SYSAP may, in the course
; of reclaiming threads (CDRP's) in progress, cause new traffic to be
; sent to the port.  This happens with apparent success, e.g., new
; SEND_MSG_BUF's do not yield errors.  The SYSAP may issue a DISCONNECT
; as part of its error routine, or may defer the DISCONNECT till later.
;
; When all SYSAP's owning open CDT's have had their error entries called,
; then SCS$VCCLOSED calls CDF$REMOVE_PB to claen up the configuration 
; database if there were no CDT's on this path block.
;
; CDT's in non-open states are handled in various ways:
;
;	State			Action
;
;	CLOSED			Nonfatal bugcheck since a closed CDT
;				should never be linked to a PB.
;
;	CON_ACK			Terminate the connect call with
;				VCBROKEN status
;
;	DISC_ACK		Terminate disconnect with success status
;
;	CON_REC			Call the SYSAP's error routine.
;
;	DISC_REC		Ignore this CDT since the SYSAP will
;				eventually DISCONNECT anyway.
;
;	CON_SENT		Terminate connect call with VCBROKEN
;				status
;
;	DISC_SENT		Terminate disconnect with success status
;
;	REJ_SENT		Terminate reject with success status and
;				return CDT to listening state.
;
;	ACCP_SENT		Terminate accept call with VCBROKEN status
;
;	LISTEN			Nonfatal bugcheck since a listen CDT
;				should never be linked to the PB
;
;	DISC_MTCH		Terminate disconnect with success status
;
; Inputs:
;
;	R0			-Aux status to pass to SYSAP
;	R3			-PB addr
;	R4			-PDT addr
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$NOTIFY_SYSAP::

	PUSHL	R5			; Save caller's R5
	MOVL	R0,R1			; Transfer aux status
	MOVZWL	#SS$_VCBROKEN,R0	; Set status to report to SYSAP
	MOVL	R3,R5			; Save PB addr
	MOVL	PB$L_CDTLST(R3),R3	; Get 1st CDT
	BEQL	30$			; Branch if none

NEXT_CDT:

	PUSHL	CDT$L_CDTLST(R3)	; Save addr of next CDT in case
					;  this one is deleted
	$DISPATCH	-		; Dispatch on CDT state
		CDT$W_STATE(R3),-	;
		<-				;
		<CDT$C_OPEN,	CALL_ERRADDR>,-	;  
		<CDT$C_CON_ACK,	CONNECT_ABO>,-	;
		<CDT$C_DISC_ACK,DCONNECT_OK>,-	;
		<CDT$C_CON_REC,	CALL_ERRADDR>,-	;
		<CDT$C_DISC_REC,IGNORE_CDT>,-	;
		<CDT$C_CON_SENT,CONNECT_ABO>,-	;
		<CDT$C_DISC_SENT,DCONNECT_OK>,-	;
		<CDT$C_REJ_SENT,REJECT_OK>,-	;
		<CDT$C_ACCP_SENT,CONNECT_ABO>,-	;
		<CDT$C_DISC_MTCH,DCONNECT_OK>,-	;
		<CDT$C_VC_FAIL,	IGNORE_CDT>,-	;
		>

	BUGCHECK	CIPORT,NONFATAL	; Illegal CDT state
	
	MOVAL	PB$L_CDTLST-CDT$L_CDTLST(R5),R0
					; If nonfatal bugcheck, get PB
					;  CDT listhead addr - CDT$L_CDTLST
	
FIND_PRV_CDT:

	CMPL	CDT$L_CDTLST(R0),R3	; Got previous link?
	BEQL	UNLNK_CDT		; Branch if so
	MOVL	CDT$L_CDTLST(R0),R0	; Else get next CDT
	BRB	FIND_PRV_CDT		; Go check it

UNLNK_CDT:

	MOVL	(SP),CDT$L_CDTLST(R0)	; Remove this CDT from list and
					;  take no further action on it
	MOVZWL	#SS$_VCBROKEN,R0	; Retreive status
	BRB	GET_NEXT_CDT		; Go for next CDT

CALL_ERRADDR:				; Notify SYSAP via error routine:

	PUSHR	#^M<R0,R1,R4,R5>	; Save registers we need
	JSB	@CDT$L_ERRADDR(R3)	; Call SYSAP error routine
	POPR	#^M<R0,R1,R4,R5>	; Restore registers
	BRB	GET_NEXT_CDT		; Join common code

CONNECT_ABO:				; Terminate pending connect/accept
					;  with error status

	MOVQ	R0,-(SP)		; Save status values
	BRB	10$			; Join common code

REJECT_OK:				; Terminate pending connection mgmt
					;  call with success status, return
					;  CDT to listening state.
	MOVQ	R0,-(SP)		; Save R0, R1
	MOVZWL	#SS$_NORMAL,R0		; Set R0 to success status
	PUSHR	#^M<R2,R3,R4,R5>	; Save remaining registers
	MOVL	CDT$L_FR5(R3),R5	; Get sysap's R5
	JSB	@CDT$L_FPC(R3)		; Resume sysap after its reject call
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	BSBW	SCS$FREE_LISTEN		; Put CDT back in listening state
	BRB	20$			; Join common cleanup for next sysap
					;  to notify

DCONNECT_OK:				; Terminate pending connection mgmt
					;  call with success status:
	
	MOVQ	R0,-(SP)		; Save standard status values
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
10$:	BSBW	SCS$CLOSE_CDT		; Complete pending disconnect call

20$:	MOVL	R5,R1			; Retreive PB addr
	BSBB	CHK_NO_CDTS		; Check CDTs disconnected now
					;  and send cache clear if all disconnected
	MOVQ	(SP)+,R0		; Restore standard status values

IGNORE_CDT:
GET_NEXT_CDT:

	POPL	R3			; Retreive addr of next CDT
	BNEQ	NEXT_CDT		; Else go process

30$:	POPL	R5			; Restore caller's R5
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	CHK_NO_CDTS,	IF ALL CDTS ON PB DISCONNECTED,
	.SBTTL	-			SEND CACHE CLEAR MSG

;+
; This routine is called by SCS$NOTIFY_SYSAP as partially open CDTs 
; are closed out during a VC failure.  It checks whether any CDTs
; remain which have not been DISCONNECTed.  If so, CHK_NO_CDTS returns.
; If all have been disconnected, then check if the port is alive and
; able to process commands.  If the port is alive, then queue a cache
; clear message to it -- when the cache clear message has made it 
; through the port, then we know we have retreive everything from the
; port's caches.
;
; If the port is dead (it was crashed or power failed), then a cache
; clear will not be processed.  In this case proceed as if the cache
; is already cleared (may lose some buffers this way.)  If there are
; still connections on this PB, return since future loops through
; NOTIFY_SYSAP or DISCONNECT will complete cleanup.  If all the
; connections are gone on this PB, then clear port queues of any
; commands or responses again and remove the path block from the
; configuration.  When there are no more path blocks
; (virtual circuits) associated with this port, then attempt a reinit
; ofthe port.  The port reinit may not be possible at this time due
; to port power loss and no restoration -- in this case, the reinit
; will happen on power up interrupt from the port.
;
; Inputs:
;
;	R1			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;
;-

	.ENABL	LSB

CHK_NO_CDTS:

	MOVAL	PB$L_CDTLST-CDT$L_CDTLST(R1),R0
					; Get addr of CDT list - offset
					;  CDT$L_CDTLST
	
10$:	MOVL	CDT$L_CDTLST(R0),R0	; Get next CDT
	BEQL	20$			; Branch if none
	CMPW	CDT$W_STATE(R0),-	; Is CDT state other than
		#CDT$C_VC_FAIL		;  VC fail?
	BEQL	10$			; Branch if not
	RSB				; Else return without doing anything
					;  since not all CDTs disconnected yet

20$:	BBS	#PDT$V_PWF_CLNUP,-	; Is port processing commands or 
		PDT$W_LPORT_STS(R4),30$	;  crashed?  Branch if crashed.
	BRW	INT$CLRCACHE		; Else call PPD layer to clear out caches

30$:	PUSHL	R3			; Save caller's R3
	TSTL	PB$L_CDTLST(R1)		; Any CDT's left on this PB?
	BNEQ	40$			; Branch if so
	PUSHL	R1			; Save PB address
	BSBW	ERR$CLEANUP_PKT		; Clear port queues one more time
					;  just in case
	POPL	R3			; Get PB addr in right register
	BSBW	CNF$REMOVE_PB		; Remove path block from database
	TSTW	PDT$W_PBCOUNT(R4)	; Any PB's on this port left?
	BNEQ	40$			; Branch if so
	BSBW	ERR$INIPORT		; Else go call reinit of port if
					;  port has power now

40$:	POPL	R3			; Restore caller's R3
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SCS$CACHECLR,	PROCESS REC'D MARKER MSG THAT
	.SBTTL	-			SAYS THE PORT CACHE IS CLEAR
	.SBTTL	-			OF TRAFFIC ON SPECIFIED VC

;+
; SCS$CACHECLR is called by PAINTR upon completion of any cache clearing
; operations that were begun by CHK_NO_CDTS above.
;
; Inputs:
;
;	IPL			-Fork IPL
;
;	R1			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

SCS$CACHECLR::

	TSTL	R1			; Check PB  assoc with remote
					;  port in CACHECLR msg
	BNEQ	10$			; Branch if lookup successful
	BRW	CONFIG_ERR		; Else, config database is
					;  inconsistent

10$:	PUSHL	R1			; Save PB addr
	MOVL	R1,R3			; Retreive PB addr
	MOVL	PB$L_CDTLST(R3),R3	; Get addr of 1st CDT
	BEQL	50$			; Branch if none
	
20$:	PUSHL	CDT$L_CDTLST(R3)	; Save addr of next CDT 
	MOVZWL	#SS$_NORMAL,R0		; Return success to suspended
	BSBW	SCS$CLOSE_CDT		;  SYSAP and delete CDT
	POPL	R3			; Get next CDT addr
	BNEQ	20$			; Branch if got one

50$:	POPL	R3			; Retreive the PB addr
	BRW	CNF$REMOVE_PB		; Deallocate PB/SB and return

	.DSABL	LSB
 




	.END
