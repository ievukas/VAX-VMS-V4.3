MODULE SRTSPC (	IDENT = 'V04-000'	! File: SRTSPCBLI.B32 Edit: VLB3042
	%REQUIRE('SRC$:DEFS0') ) =
BEGIN
!--------------------------------------------------------------------------
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!--------------------------------------------------------------------------

!++
! Facility:
!
!	PDP-11 SORT/MERGE V3.0
!	VAX-11 SORT/MERGE V3.0
!
! Abstract:
!
!
! Environment:
!
!
! Author:
!
!	Victor L Bennison,	Creation Date:		8-Mar-82
!
! MODIFIED BY :
!	X30-001	Peter D Gilbert		Aug 1982
!		Pervasive modifications.
!		Pass text as a vector of 2 or 3 items.
!		Move expansion of keywords into this module.
!		General code cleanups.
!		Added ERR_ and WRN_ macros.
!		Corrected the EBC_TAB table.
!		Used TYP_K_xxx values to identify the sort process.
!		Deferred determining whether sort or merge until run-time.
!		Used DT_xxx values to identify datatypes.
!	T03-016	Improve allocation of the work area.  Change PARSE_TEST for
!		precedence of AND/OR, and nested parens.  PDG 13-Dec-1982
!	T03-017	Complete implementation of /WORK_FILES; store a counted list of
!		CFT table indices for the work file names.  PDG 26-Dec-1982
!	T03-018	Fix a reference in PARSE_KEY which caused ASCENDING and
!		DESCENDING to not be parsed.  Also, fixed a reference in
!		INIT_CS_TAB.  PDG 28-Dec-1982
!	T03-019	Fix off-by-one problems with ST indices.
!		Add ZONED.
!		Support conversions of decimal constants.
!		Fix off-by-one problem with MOD:("C"<"R").
!		PDG 29-Dec-1982
!	T03-020	Fix bug in ignoring a range of characters.  PDG 3-Jan-1983
!	T03-021	Store PT_ST_IDX for GC_S_EQ_D.  PDG 6-Jan-1983
!	T03-022	Fix initialization of DEC_MULTI.  PDG 10-Jan-1983
!	T03-023	Collating sequence stuff.  Fix GET_STRING.  PDG 26-Jan-1983
!	T03-024	Call COLL$FOLD to fold double characters.  Fix GET_CHAR_CLAUSE
!		so that returning GC_SINGLE also sets the second char the same
!		as the first.  PDG 1-Feb-1983
!	T03-025	Diagnose "/key=(if x then lit)".  PDG 2-Feb-1983
!	T03-026	Change DEC_UPP so different cases are equal.  PDG 11-Feb-1983
!	T03-027	Compute KFT_NDE_SIZ values.  PDG 12-Feb-1983
!	T03-028	Set the CA_TIE_BREAK flag in SOR$$DECM.  16-Feb-1983
!	T03-029	Change DEC_UPP so sharp s is just before s.  2-Mar-1983
!	T03-030	Remove need for COLL$COMPRESS.  PDG 5-Apr-1983
!	T03-031	Change for tie-breaking, so that [NO]TIE_BREAK turns on [off]
!		both the second pass and third pass comparisons.  Note that the
!		second pass table is specified only for DEC_MULTI; by default,
!		the second pass table is all zero (this is optimized away by
!		COLL$RESULT).  PDG 12-Apr-1983
!	T03-032	Add some error reporting in PARSE_COLL.  PDG 15-Apr-1983
!	T03-033	Always reverse the sense of the tie-break.  PDG 18-Apr-1983
!	T03-034	Changes necessary for SORT-11 overlay.  VLB 1-Jul-1983
!	T03-034	Set the "default length" for work file names.  PDG 15-Aug-1983
!	T03-035	Word align work area after allocating constants.  28-Jul-1983
!	T03-036	Make CFT_CON_ADR relative.  PDG 2-Aug-1983
!	T03-037	Changes to merge Sort-32 and Sort-11 sources.  PDG 31-Jan-1984
!	T03-038	Change CONV_CONSTANTS to fix /WORK_FILES.  PDG 16-Feb-1984
!	T03-039 Set CA[ COM_COL_SEQ_ ] for SORT-11 statistics, fix process
!		override.  VLB  22-FEB-1984
!	T03-040 Fix the error handling for SORT-11.  VLB  23-FEB-1984
!	T03-041 Use TRUE/FALSE instead of ON/OFF when setting modified, also
!		make some BLISS16 stuff unconditional instead.  VLB 7-MAR-1984
!	T03-042 Fix handling of WKAREA error.  VLB 9-MAR-1984
!
! SYNTAX:
!	/COND = (NAME:name, TEST:test)
!	/OMIT = (COND:cond)
!	/INCL = (COND:cond, DATA:data, KEY:key)
!--

REQUIRE 'SRC$:DKS';

EXTERNAL ROUTINE
	P1$PASS_ONE:	CA_LINKAGE,
	P2$PASS_TWO:	CA_LINKAGE,
	P3$PASS_THREE:	CA_LINKAGE,
	P4$PASS_FOUR:	CA_LINKAGE,
	P5$PASS_FIVE:	CA_LINKAGE;

FORWARD ROUTINE
	CVT_ATB,			! Convert ascii to binary
	ERR_CNTL:	CA_LINKAGE,	! Error control routine
	FIND_RPAR,			! Find the next unquoted right parenthesis
	GET_CHAR_CLAUSE,		! Get character clauses of various kinds
	GET_KYW_TYPE,			! Get keyword type
	GET_NEXT_SPEC,			! Get pointer and length of next specification
	GET_ONE_CHAR,			! Get character or double character
	GET_STRING,			! Find string and move around it
	GET_SUB_SPEC,			! Get pointer and length of sub-specification
	SEARCH_TABLE,			! Search a table for a string
	SKIP_COMMA,			! Skip commas and ignored stuff
	SKIP_IGNORED,			! Skip ignored text characters
	%IF %BLISS(BLISS32) %THEN
	SOR$$DEF_FIELD:	CA_LINKAGE,	! Define a field
	%FI
	SOR$$SFPRS:	CA_LINKAGE,	! Process specification file text
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SPC_HEAP:	CA_LINKAGE;	! Allocate temp storage from work area

! Define the text of the keywords
!
%IF %BLISS(BLISS16)
%THEN
    PSECT
	PLIT = $SFWRD (NOWRITE,NOEXECUTE,GLOBAL);
%FI

MACRO
    TXT_[A, B] = %ASCIC B %,
    OFF_[A, B] = OFF__ %ASSIGN( OFF__, OFF__ + %CHARCOUNT( B ) + 1) %;
COMPILETIME
    OFF__ = 0;
BIND
    SRTWRD = UPLIT BYTE( TXT_( KEYWORDS ) ):	VECTOR[, BYTE],
    WRDOFF = UPLIT WORD( OFF_( KEYWORDS ) ):	VECTOR[, WORD];

GLOBAL ROUTINE SOR$$SFPRS (
	SPEC_TEXT:	REF VECTOR[2]
	):	CA_LINKAGE =

!++
!
! Functional Description:
!
!	Parses the specification file buffer
!
! Formal Parameters:
!
!	SPEC_TEXT   Addr of length/address of buffer containing specifications.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	0 on error.
!	1 for sucess.
!
! Side Effects:
!
!	None.
!
! Notes:
!
!	When the input record LRL is known, it should be stored in:
!	FDT[0, FDT_FLD_SIZ] and KFT[*, KFT_NDE_SIZ] for every KFT entry
!	with KFT_CONSTANT = FALSE and KFT_FDT_IDX = 0.
!
!--
    BEGIN

    LOCAL
	TRDT:		REF TRDT_TAB[RDT_MAX],		! Hold info on record types
	CDX_SYM:	REF SYM_TAB[MAX_CONDX],		! Condition "symbol" table
	CDX_CNT,					! Entries in CDX_SYM ???safe???
	CON_SYM:	REF CON_SYM_TAB[MAX_CONST],	! Constant "symbol" table
	CON_CNT,					! Entries in CON_SYM ???safe???
	FLD_SYM:	REF SYM_TAB[MAX_FIELDS];	! Field "symbol" table

    LOCAL
	START:	VECTOR[3],	! Length/address/line of start of spec buffer
	WRK_END;		! End of work area

    LABEL
    	normal;

    ! Get the impure area
    !
    CA_AREA_( CA );

    output_('sor$$sfprs');

normal:
    BEGIN

    ! Save the address at the end of the work area
    !
    WRK_END = .CA[CA_WRK_END];

    ! Initialize start to length/address of buffer as passed
    !
    START[_LEN ] = .SPEC_TEXT[_LEN];
    START[_PTR ] = .SPEC_TEXT[_PTR];
    START[_LINE] = 1;

    ! Find the start of the first specification, ignore preceding
    ! Comments, nulls and blanks.  start will be constant for rest of parse.
    ! If there's no text, exit with success
    !
    IF SKIP_IGNORED( START[0] ) EQL FAIL THEN RETURN SUCCESS;

    !++
    ! Seven tables are created by this routine.
    ! These tables are created/expanded in the passes listed below:
    !	CA_ST_ADR/SIZ	1
    !	CA_FDT_ADR/SIZ	2
    !	CA_TDT_ADR/SIZ	3
    !	CA_KFT_ADR/SIZ	4,5
    !	CA_RDT_ADR/SIZ	5
    !	CA_CFT_ADR/SIZ	3,4,5 (via PARSE_TEST and PARSE_KEY)
    !
    ! The CFT table may be "expanded" in any of several places, but the work
    ! area storage is not allocated until after all the other processing.
    ! The information is stored in a temporary table, described below.
    !
    ! Four temporary tables are used:
    !	FLD_SYM	Symbol table for named fields
    !	CDX_SYM Symbol table for named conditions
    !	CON_SYM Symbol table for constants
    !	TRDT	Temporary record definition table
    ! these are allocated at the end of the work area, and the work area
    ! restored when processing is complete.
    !--

    ! Initialize constant table
    ! Allocate space for field symbol table
    ! Initialize condition symbol table
    ! Allocate space for the temporary record definition table.
    !
    CON_SYM = HEAP_( %SIZE( CON_SYM_TAB[MAX_CONST] ) );
    CON_CNT = 0;
    FLD_SYM = HEAP_( %SIZE( SYM_TAB[MAX_FIELDS] ) );
    CDX_SYM = HEAP_( %SIZE( SYM_TAB[MAX_CONDX] ) );
    CDX_CNT = 0;
    TRDT = HEAP_( %SIZE( TRDT_TAB[RDT_MAX]) );

    ! Make an entry for the default record type.
    !
    TRDT[0, TRDT_INCLUDE] = TRUE;
    TRDT[0, TRDT_CONDX  ] = FALSE;
    TRDT[0, TRDT_KFT_IDX] = .CA[CA_KFT_SIZ];

    !-----------------------------------------------------
    ! Pass 1:	parse /process, /stable, /strip,
    !		and /collating_sequence specifications.
    !		Build the PT and ST tables
    !-----------------------------------------------------

    IF P1$PASS_ONE( START[0], CON_SYM[0, BASE_], CON_CNT ) NEQ SUCCESS
    THEN
	LEAVE normal;

    !------------------------------------------------------
    ! Pass 2:	define all fields, fill the field definition
    !		table and the field symbol table
    !		Build the FDT table
    !------------------------------------------------------

    IF P2$PASS_TWO( START[0], FLD_SYM[0, BASE_] ) NEQ SUCCESS
    THEN
	LEAVE normal;

    !---------------------------------------------------
    ! Pass 3:	parse condition specifications.
    !		set up test definition table,
    !		condition symbol table and the
    !		constant symbol table.
    !		Build the TDT table
    !---------------------------------------------------

    IF P3$PASS_THREE( START[0], 
	CON_SYM[0, BASE_], CON_CNT,
	FLD_SYM[0, BASE_],
	CDX_SYM[0, BASE_], CDX_CNT ) NEQ SUCCESS
    THEN
	LEAVE normal;

    !-------------------------------------------------------
    ! Pass 4:	parse all /KEY and /DATA specifications.
    !		define the default record type in temporary
    !		record definition table.
    !		Build the KFT table
    !-------------------------------------------------------

    IF P4$PASS_FOUR( START[0], 
	CON_SYM[0, BASE_], CON_CNT,
	FLD_SYM[0, BASE_],
	CDX_SYM[0, BASE_], CDX_CNT ) NEQ SUCCESS
    THEN
	LEAVE normal;

    !-----------------------------------------------------------
    ! Pass 5:	parse all /include and /omit specifications.
    !		finish the temporary record definition table.
    !		create the record definition table from the
    !		temporary record definition table.
    !		create the constant table.
    !		Build the RDT table
    !-----------------------------------------------------------

    IF P5$PASS_FIVE( START[0], 
	CON_SYM[0, BASE_], CON_CNT,
	FLD_SYM[0, BASE_],
	CDX_SYM[0, BASE_], CDX_CNT,
	TRDT[0, BASE_] ) NEQ SUCCESS
    THEN
	LEAVE normal;

    !+++???
    !
    ! It may be worthwhile to determine the following information:
    !	Number of different record formats
    !	Longest (output) record length
    !	Whether any record reformatting is needed
    !	???
    !
    !+++???

    ! Restore the ending address of the work area
    !
    CA[CA_WRK_END] = .WRK_END;

    %IF %BLISS( BLISS16 ) 
    %THEN 

    ! Check error flag
    !
    IF .CA[ CA_1ST_SPC_ERR ] NEQ 0
    THEN			! Error encountered during parse
    	LEAVE normal;

    %FI

    ! No error encountered
    !
    RETURN SUCCESS;

!end normal processing
    END;

    ! Invalid specification.  Return the first error message
    !
    %IF %BLISS( BLISS16 ) 
    %THEN 
    	!fill the error buffer
    	BEGIN
    	LOCAL ERR_BUFF : REF VECTOR[,WORD];
    	ERR_BUFF = .CA[ CA_STAT_ADR ];
    	ERR_BUFF[ 0 ] = .CA[ CA_1ST_SPC_ERR ];
    	ERR_BUFF[ 1 ] = .CA[ CA_1ST_SPC_LIN ];
    	END;
    %FI

    RETURN FAIL;

    !end srtspc
    END;


%IF %BLISS(BLISS32) %THEN
GLOBAL ROUTINE SOR$$DEF_FIELD(
	FIELD_NAME:	REF VECTOR[2],
	DATATYPE:	BYTE,
	POSITION:	WORD,
	LENGTH:		WORD,
	SCALE:		BYTE,
	FLD_SYM:	REF SYM_TAB[],	! Field "symbol" table
	KYW_LINE
	): CA_LINKAGE =
    BEGIN
    LOCAL
	INDEX,
	NAME:	VECTOR[2],
	FDT:	REF FDT_TAB[];	! Pointer to Field Defn Table

    ! Get the impure area
    !
    CA_AREA_( CA );

    ! Save the name
    !
    NAME[0] = .(FIELD_NAME[0])<0,16,0>;		! Length is only a word
    NAME[1] = HEAP_(.NAME[0]);
    CH$MOVE(.NAME[0], .FIELD_NAME[1], .NAME[1]);

    FDT = ALLOC_(FDT_UNIT);
    CA[CA_FDT_SIZ] = .CA[CA_FDT_SIZ] + 1;

    ! Too many entries in FDT or field symbol table?
    !
    IF .CA[CA_FDT_SIZ] GEQ MIN(FDT_MAX, MAX_FIELDS)
    THEN
	BEGIN
	ERR_( .KYW_LINE, SOR$_SPCIVF );		! Invalid field
	RETURN FAIL;
	END;

    FDT[0, FDT_TYPE] = .DATATYPE;
    FDT[0, FDT_SCALE] = .SCALE;
    FDT[0, FDT_FLD_POS] = .POSITION;
    FDT[0, FDT_FLD_SIZ] = .LENGTH;

    ! Look for the name in the field symbol table
    !
    IF SEARCH_TABLE( NAME[0], INDEX,
	    FLD_SYM[0,BASE_], .CA[CA_FDT_SIZ]-1 ) EQL SUCCESS
    THEN
	BEGIN	! Name has already been used
	ERR_( .KYW_LINE, SOR$_SPCIVF );	! Invalid field
	RETURN FAIL;
	END;

    ! Put the length/address in the field symbol table entry
    ! Put the fdt index in the field symbol table
    !
    BEGIN
    LOCAL FLD_SYM_LOC: REF SYM_TAB [1];
    FLD_SYM_LOC = FLD_SYM[.CA[CA_FDT_SIZ]-1, BASE_];
    FLD_SYM_LOC[0, SYM_NAM_LEN] = .NAME[_LEN];
    FLD_SYM_LOC[0, SYM_NAM_ADR] = .NAME[_PTR];
    FLD_SYM_LOC[0, SYM_INDEX] = .CA[CA_FDT_SIZ]-1;
    END;

    RETURN SUCCESS;

    END;
%FI

GLOBAL ROUTINE SPC_ALLOC( AMT ): CA_LINKAGE =

!++
! Functional Description:
!
!	Allocate some storage from the work area, checking that we don't
!	exceed the end of the work area.
!
! Formal Parameters:
!
!	AMT	Amount of storage to allocate, in bytes.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	Address of the storage.
!
! Side Effects:
!
!	None.
!
!--
    BEGIN
    LOCAL
	T;

    CA_AREA_( CA );

    T = .CA[CA_WRK_ADR];
    CA[CA_WRK_ADR] = .CA[CA_WRK_ADR] + .AMT;
    IF .CA[CA_WRK_ADR] GTRA .CA[CA_WRK_END]
    THEN
	BEGIN
	ERR_CNTL(0, SOR$_WKAREA, (LOCAL X;X));	! Insufficient work area
	RETURN 0;
	END;
    RETURN .T;
    END;

GLOBAL ROUTINE SPC_HEAP( AMT ): CA_LINKAGE =

!++
! Functional Description:
!
!	Allocate some temporary storage from the work area, checking that we
!	don't exceed the end of the work area.
!
! Formal Parameters:
!
!	AMT	Amount of storage to allocate, in bytes.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	Address of the storage.
!
! Side Effects:
!
!	None.
!
!--
    BEGIN

    CA_AREA_( CA );

    CA[CA_WRK_END] = .CA[CA_WRK_END] - .AMT;
    CA[CA_WRK_END] = .CA[CA_WRK_END] AND NOT 1;	! Word align
    IF .CA[CA_WRK_ADR] GTRA .CA[CA_WRK_END]
    THEN
	BEGIN
	ERR_CNTL(0, SOR$_WKAREA, (LOCAL X;X));	! Insufficient work area
	RETURN 0;
	END;
    RETURN .CA[CA_WRK_END];

    END;

GLOBAL ROUTINE CVT_ATB(
	BASE,
	IN:		REF VECTOR[2],
	OUT_ADR:	REF VECTOR[1] ) =
!++
! Functional Description:
!
!	Converts ascii string to positive binary integer
!
! Formal Parameters:
!
!	BASE	- Number base (2 - 10 or 16).
!	IN	- Address of length/address of input string.
!	OUT_ADR	- Address of word to store resultant binary number.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!	None.
!
!--
    BEGIN

    output_('cvt_atb');

    ! Initialize the output value
    OUT_ADR[0] = 0;

    IF .IN[_LEN] LEQ 0 THEN RETURN FAIL;

    WHILE TRUE DO
	BEGIN
	LOCAL
	    NUM;

	! Get next digit
	NUM = LOWER_(CH$RCHAR(.IN[_PTR]));

	! Convert it to a number
	SELECTONE .NUM OF
	    SET
	    [%C'0' TO %C'9']:	NUM = .NUM - %C'0';
	    [%C'a' TO %C'f']:	NUM = .NUM - %C'a' + 10;
	    [OTHERWISE]:	RETURN FAIL;
	    TES;

	! Is it in range?
	IF .NUM GEQU .BASE THEN RETURN FAIL;

	! Multiply the result by the radix and add in the number
	OUT_ADR[0] = .OUT_ADR[0] * .BASE + .NUM;

	! Advance to next character
	!
	IN[_PTR] = .IN[_PTR] + 1;
	IN[_LEN] = .IN[_LEN] - 1;
	IF .IN[_LEN] LEQ 0 THEN EXITLOOP;
	END;

    RETURN SUCCESS

    END;

GLOBAL ROUTINE GET_NEXT_SPEC( DESC: REF VECTOR[3], SPC: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the next specification.  Specifications have one of the formats:
!
!	/keyword...=...sub_specification
!	/keyword...=...(sub_specification_list)
!
!	everything beyond the keyword is optional, and each "." represents a
!	space, a null, or part of a comment.
!	This routine returns the length/address of the sub_specification or
!	sub_specification_list.
!
! Formal Parameters:
!
!	DESC	   - Address of length/address/line of text to search.
!	SPC	   - Address to return length/pointer/line of sub_specification
!
! Implicit Inputs:
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	keyword type
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	KYW_TYPE,
	FIRST_CHAR;

    output_('get_next_spec');

    ! Initialize output length
    SPC[_LEN] = 0;

    ! Are we out of input?
    IF .DESC[_LEN] EQL 0 THEN RETURN KW_UNKN;

    ! Save the first character ("/"?)
    FIRST_CHAR = CH$RCHAR(.DESC[_PTR]);

    ! Move off of first character ("/"?)
    DESC[_PTR] = .DESC[_PTR] + 1;
    DESC[_LEN] = .DESC[_LEN] - 1;

    ! Get the sub_specification or sub_spec_list
    ! Note that is first character is not a slash we still want to
    ! call get_sub_spec to move pointers appropriately.
    !
    KYW_TYPE = GET_SUB_SPEC( DESC[0], SPC[0] );

    IF .FIRST_CHAR NEQ C_SLASH THEN RETURN KW_UNKN;

    RETURN .KYW_TYPE

    END;

GLOBAL ROUTINE GET_SUB_SPEC( SPC: REF VECTOR[3], SUB_SPC: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the next sub_specification.  Sub_specifications have the forms:
!
!	keyword...=...sub_specification
!	keyword...=...(sub_specification_list)
!
!	everything beyond the keyword is optional, and each "." represents a
!	space, a null, or part of a comment.
!	This routine returns the length/address of the sub_specification or
!	sub_specification_list.
!
! Formal Parameters:
!
!	SPC	- Address of length/pointer/line of first character of
!		  keyword, modified to point to end of sub_specification.
!	SUB_SPC	- Address to return length/pointer/line of sub_specification
!
! Implicit Inputs:
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	keyword type
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	KYW_TYPE;

    output_('get_sub_spec');

    ! Initialize output length
    SUB_SPC[_LEN] = 0;

    ! Are we out of input
    IF .SPC[_LEN] EQL 0
    THEN
	RETURN KW_UNKN;

    ! Get the keyword type
    KYW_TYPE = GET_KYW_TYPE( SPC[0] );

    ! Skip over ignored stuff.  If nothing else, just return the keyword.
    !
    IF SKIP_IGNORED( SPC[0] ) EQL FAIL THEN RETURN .KYW_TYPE;

    ! Check the character we're sitting on
    IF CH$RCHAR(.SPC[_PTR]) NEQ C_EQUAL
		AND
	CH$RCHAR(.SPC[_PTR]) NEQ C_COLON
    THEN
	RETURN .KYW_TYPE;

    ! Move pointer off of equal sign
    SPC[_PTR] = .SPC[_PTR] + 1;
    SPC[_LEN] = .SPC[_LEN] - 1;

    ! Skip more ignored stuff
    IF SKIP_IGNORED( SPC[0] ) EQL FAIL THEN RETURN KW_UNKN;

    ! Are we sitting on a left parenthesis?
    IF CH$RCHAR(.SPC[_PTR]) EQL C_L_PAREN
    THEN
	! Then its a sub_specification_list
	BEGIN

	! Move the pointer off of the left parenthesis
	SPC[_PTR] = .SPC[_PTR] + 1;
	SPC[_LEN] = .SPC[_LEN] - 1;

	! Skip more ignored stuff
	IF SKIP_IGNORED( SPC[0] ) EQL FAIL THEN RETURN KW_UNKN;

	! Start of sub_specification
	SUB_SPC[_PTR]  = .SPC[_PTR];
	SUB_SPC[_LINE] = .SPC[_LINE];

	! Get the corresponding right parenthesis
	IF FIND_RPAR( SPC[0] ) EQL FAIL
	THEN
	    RETURN KW_UNKN;

	! Calculate sub_specification_list length
	SUB_SPC[_LEN] = .SPC[_PTR] - .SUB_SPC[_PTR];

	! Move off of right parenthesis
	SPC[_PTR] = .SPC[_PTR] + 1;
	SPC[_LEN] = .SPC[_LEN] - 1;

	END

    ELSE

	BEGIN

	SUB_SPC[_LINE] = .SPC[_LINE];

	! Find the end of the sub_specification
	IF GET_STRING( SPC[0], SUB_SPC[0] ) EQL FAIL
	THEN
	    RETURN KW_UNKN;

	END;

    RETURN .KYW_TYPE

    END;

ROUTINE FIND_RPAR( SPEC: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Find the next right parenthesis that isn't in quotes or comments
!
! Formal Parameters:
!
!	SPEC	   - Address of length/address/line of the buffer.
!
! Implicit Inputs:
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!
!--
    BEGIN

    LOCAL
	PAREN_LEVEL,		! Parenthesis nesting level
	QUOTE_F,		! Quote flag
	COMMENT;		! Comment flag

    output_('find_rpar');

    PAREN_LEVEL = 0;	! Set the nesting level to zero
    QUOTE_F = FALSE;	! Set the quote flag to false
    COMMENT = FALSE;	! Set the comment flag to false

    ! Find the next right parenthesis
    WHILE TRUE DO
	BEGIN

	! Are there more characters in input buffer?
	IF .SPEC[_LEN] LEQ 0
	THEN
	    RETURN FAIL;

	! Check the character we're sitting on
	SELECTONE CH$RCHAR(.SPEC[_PTR]) OF
	    SET

	    [C_QUOTE]:		! A quote

		BEGIN

		! Are we in a comment
		IF NOT .COMMENT
		THEN
		    ! Toggle the quote flag
		    QUOTE_F = NOT .QUOTE_F;

		END;

	    [C_NULL, C_LF]:		! Null or line feed indicates end of line
		BEGIN
		IF NOT .QUOTE_F
		THEN
		    BEGIN
		    SPEC[_LINE] = .SPEC[_LINE] + 1;	! Bump line number
		    COMMENT = FALSE;			! Not in a comment
		    END;
		END;

	    [C_EXCLAM]:		! Exclamation point
		BEGIN
		IF NOT .QUOTE_F
		THEN
		    COMMENT = TRUE;	! Set the comment flag to true
		END;

	    [C_L_PAREN]:		! A left parenthesis
		! If the comment flag and quote flag are both off then
		! Increment the nesting level
		IF NOT .COMMENT AND NOT .QUOTE_F
		THEN
		    PAREN_LEVEL = .PAREN_LEVEL + 1;

	    [C_R_PAREN]:		! A right parenthesis
		BEGIN
		! If both the comment flag and quote flag are off and the
		! Nesting level is zero then we're done
		IF NOT .COMMENT AND NOT .QUOTE_F
		THEN
		    ! Reduce the nesting level, checking for the end
		    IF (PAREN_LEVEL = .PAREN_LEVEL - 1) LSS 0
		    THEN
			RETURN SUCCESS;
		END;

	    TES;

	! Increment pointer and decrement length
	SPEC[_PTR] = .SPEC[_PTR] + 1;
	SPEC[_LEN] = .SPEC[_LEN] - 1;

	END;

    RETURN FAIL

    END;

GLOBAL ROUTINE SKIP_IGNORED( DESC: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the next character, ignoring blanks, nulls, and comments
!
! Formal Parameters:
!
!	DESC	- Address of length/address/line to search.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL	- If run out of buffer before significant character is found.
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	COMMENT;		! Comment flag

    output_('skip_ignored');

    COMMENT = FALSE;

    ! Skip around all the ignored stuff
    WHILE TRUE DO
	BEGIN

	! Are there more characters in input buffer?
	IF .DESC[_LEN] LEQ 0
	THEN
	    RETURN FAIL;

	! Check the character we're sitting on
	SELECTONE CH$RCHAR(.DESC[_PTR]) OF
	    SET

	    [C_SPACE, C_TAB, C_CR]:	! Space, tab, or carriage return
		0;			! Do nothing

	    [C_NULL, C_LF]:		! Null, line feed indicates end of line
		BEGIN
		DESC[_LINE] = .DESC[_LINE] + 1;		! Bump the line number
		COMMENT = FALSE;			! Not in a comment
		END;

	    [C_EXCLAM]:		! Exclamation point
		COMMENT = TRUE;				! In a comment

	    [OTHERWISE]:		! Any other character
		IF NOT .COMMENT THEN RETURN SUCCESS;

	    TES;

	! Increment pointer and decrement N
	DESC[_PTR] = .DESC[_PTR] + 1;
	DESC[_LEN] = .DESC[_LEN] - 1;

	END;

    RETURN FAIL

    END;

GLOBAL ROUTINE SKIP_COMMA( DESC: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the next character, ignoring blanks, nulls, comments, and commas
!
! Formal Parameters:
!
!	DESC	- Address of length/address/line to search.
!
! Implicit Inputs:
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	FLAG;		! Found, not found flag

    output_('skip_comma');

    IF SKIP_IGNORED( DESC[0] ) EQL FAIL THEN RETURN FAIL;

    IF CH$RCHAR(.DESC[_PTR]) NEQ C_COMMA THEN RETURN FAIL;

    DESC[_PTR] = .DESC[_PTR] + 1;
    DESC[_LEN] = .DESC[_LEN] - 1;

    IF SKIP_IGNORED( DESC[0] ) EQL FAIL THEN RETURN FAIL;

    RETURN SUCCESS;

    END;

GLOBAL ROUTINE GET_KYW_TYPE( DESC: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the next keyword
!
! Formal Parameters:
!
!	DESC - Address of length/address
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	Code for specification file keyword or KW_UNKN
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	STRING: VECTOR[3],	! Local constant length/address to input string
	KYW_TYPE;	! Keyword type

    output_('get_kyw_type');

    ! Get the keyword string
    IF GET_STRING( DESC[0], STRING[0] ) EQL FAIL
    THEN
	RETURN KW_UNKN;

    KYW_TYPE = KW_UNKN;

    ! Run through all the spec file keywords
    !
    INCR IN FROM 0 TO KW_UNKN-1 DO
	BEGIN
	LOCAL
	    KYW: REF VECTOR[,BYTE],	! Address of a keyword
	    PTR: REF VECTOR[,BYTE];	! Local pointer to input string

	! Initialize the local pointer to input string
	PTR = .STRING[_PTR];

	! Get the address of the next keyword
	KYW = SRTWRD[.WRDOFF[.IN]];

	! Is the input string shorter than the keyword
	IF .STRING[_LEN] LEQU CH$RCHAR_A( KYW )
	THEN
	    BEGIN

	    ! Do the keyword and the input string,
	    ! (converted to upper case) match?
	    !
	    IF	BEGIN
		DECR COUNT FROM .STRING[_LEN]-1 TO 0 DO
		    IF LOWER_(.PTR[.COUNT]) NEQ LOWER_(.KYW[.COUNT])
		    THEN EXITLOOP 0
		END
	    THEN
		BEGIN

		! We are done if it was an exact match
		! Note that we must check for an exact match before checking
		! for ambiguous keywords, since some keywords (namely, ASCII
		! and LE) may by prefixes for other keywords.
		IF .STRING[_LEN] EQL .KYW[-1] THEN RETURN .IN;

		! Ambiguous keyword?
		IF .KYW_TYPE NEQ KW_UNKN THEN RETURN KW_UNKN;

		! Set the keyword type
		KYW_TYPE = .IN;

		END;

	    END;

	END;

    ! Return the keyword
    !
    RETURN .KYW_TYPE;

    END;

GLOBAL ROUTINE GET_STRING( DESC: REF VECTOR[3], STRING: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the string of contiguous significant characters in DESC.
!	(Anything inside quotes is significant.)
!
! Formal Parameters:
!
!	DESC	- Address of length/address to search
!	STRING	- Address of stored length/address of string.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN
    LOCAL
	QUOTED,		! Are we in a quote
	LENGTH;		! Length of the found string

    output_('get_string');

    QUOTED = FALSE;

    ! Initialize length
    LENGTH = 0;

    ! Set pointer to string
    STRING[_PTR] = .DESC[_PTR];
    STRING[_LINE] = .DESC[_LINE];

    ! Find the string
    WHILE TRUE DO
	BEGIN

	IF .DESC[_LEN] LEQ 0 THEN EXITLOOP;		! Out of input

	! Look at the next character
	SELECTONE CH$RCHAR(.DESC[_PTR]) OF
	    SET
	    [C_QUOTE]:
		QUOTED = NOT .QUOTED;
	    [%X'41' TO %X'5A', %X'61' TO %X'7A',
	     %X'30' TO %X'39', %C'_', %C'$', C_PERCENT]:
		0;
	    [OTHERWISE]:
		IF NOT .QUOTED THEN EXITLOOP;		! Inside of a quote?
	    TES;

	! Update the values
	DESC[_PTR] = .DESC[_PTR] + 1;
	DESC[_LEN] = .DESC[_LEN] - 1;

	LENGTH = .LENGTH + 1;

	END;

    IF .QUOTED THEN RETURN FAIL;

    IF (STRING[_LEN] = .LENGTH) EQL 0
    THEN
	RETURN FAIL
    ELSE
	RETURN SUCCESS;

    END;

GLOBAL ROUTINE GET_CHAR_CLAUSE(
	DESC:	REF VECTOR[3],
	CH4:	REF VECTOR[4,BYTE] ) =

!++
! Functional Description:
!
!	Get the character clause within DESC.
!
!	This is of the form:
!	{ s | d | s dash s | { s | d } eq { s | d } | { s | d } { lt | gt } s }
!
! Formal Parameters:
!
!	DESC	Address of length/address of the text.
!	CH4	Address to place up to four characters (0 thru 3).
!		0-1 = First character.
!			Single character or
!			first character of double character or
!			first character of range.
!		2-3 = Second character.
!			Same as first character if return value is SINGLE, or
!			second character of definition or
!			second character of range.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	FAIL		invalid clause
!	GC_SINGLE	<single>
!	GC_DOUBLE	<double>
!	GC_S_TO_S	<single> - <single>
!	GC_x_op_y
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	CHAR1, CHAR2, OP;

    %IF GC_SINGLE NEQ 1 %THEN %WARN('Error in GET_CHAR_CLAUSE') %FI
    %IF GC_DOUBLE NEQ 2 %THEN %WARN('Error in GET_CHAR_CLAUSE') %FI

    MACRO
	ADVANCE_(X) =
	    BEGIN
	    X[_PTR] = .X[_PTR] + 1;
	    X[_LEN] = .X[_LEN] - 1;
	    END %;

    output_('get_char_clause');

    ! Get the first character(s)
    CHAR1 = GET_ONE_CHAR( DESC[0], CH4[0] );
    CH4[2] = .CH4[0];
    CH4[3] = .CH4[1];

    IF .CHAR1 EQL FAIL THEN RETURN FAIL;

    IF SKIP_IGNORED( DESC[0] ) EQL FAIL THEN RETURN .CHAR1;

    SELECT CH$RCHAR(.DESC[_PTR]) OF
	SET
	[C_DASH, C_EQUAL, C_LESS, C_GREATER]:	! Need another character(s)
	    BEGIN
	    ADVANCE_(DESC);	! Move off of character
	    CHAR2 = GET_ONE_CHAR( DESC[0], CH4[2] );
	    IF .CHAR2 EQL FAIL THEN RETURN FAIL;
	    END;
	[OTHERWISE]:
	    RETURN .CHAR1;
	[C_DASH]:
	    BEGIN
	    IF NOT (.CHAR1 EQL 1 AND .CHAR2 EQL 1) THEN RETURN FAIL;
	    RETURN GC_S_TO_S;
	    END;
	[C_LESS]:
	    OP = %B'11';
	[C_EQUAL]:
	    OP = %B'00';
	[C_GREATER]:
	    OP = %B'01';
	[C_LESS, C_EQUAL, C_GREATER]:
	    RETURN GC_(.CHAR1,.OP,.CHAR2);
	TES;

    RETURN FAIL;

    END;

GLOBAL ROUTINE GET_ONE_CHAR(
	DESC: REF VECTOR[3],
	CH2:  REF VECTOR[2,BYTE] ) =

!++
! Functional Description:
!
!	Get the character or double character within DESC.
!
!	This is of the form:
!	{ char | char char }
!
!	Where char is of the form:
!	{ <quoted-string> | %<base><digits> | <character> }
!
! Formal Parameters:
!
!	DESC	Address of length/address for
!		remaining chars/address of first character of the keyword
!	CH2	Address of two characters.
!		0 = First character.
!			Single character or
!			first character of double character.
!		1 = Second character.
!			Same as first character if return value GC_SINGLE, or
!			second character of double character.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	Number of characters found, any more than two is considered an
!		error
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	BASE,
	STR:	VECTOR[3],
	VALUE,
	NUM_CHARS;	! Number of characters found
    MACRO
	ADVANCE_(X) =
	    BEGIN
	    X[_PTR] = .X[_PTR] + 1;
	    X[_LEN] = .X[_LEN] - 1;
	    END %;

    output_('get_one_char');

    NUM_CHARS = 0;
    IF SKIP_IGNORED( DESC[0] ) EQL FAIL THEN RETURN FAIL;

    ! While there are more characters
    WHILE .DESC[_LEN] GTR 0 DO
	BEGIN

	SELECTONE CH$RCHAR(.DESC[_PTR]) OF
	    SET

	    [C_SPACE, C_TAB]:		! Skip it
		BEGIN
		ADVANCE_(DESC);
		END;

	    [C_PERCENT]:		! We have octal, hex, or decimal
		BEGIN

		ADVANCE_(DESC);		! Look at the next character

		! Out of input?
		IF .DESC[_LEN] LEQ 0
		THEN
		    EXITLOOP;

		! Find out what base, lower case it
		BASE = LOWER_(CH$RCHAR(.DESC[_PTR]));

		! Convert base character to number
		SELECTONE .BASE OF
		    SET
		    [C_DEC]:	BASE = 10;	! Decimal
		    [C_OCT]:	BASE = 8;	! Octal
		    [C_HEX]:	BASE = 16;	! Hexidecimal
		    [OTHERWISE]: RETURN FAIL;	! Bad base
		    TES;

		! Move off of the base character
		ADVANCE_(DESC);

		! Get the number in character string form
		STR[_LEN] = 0;
		STR[_PTR] = .DESC[_PTR];
		WHILE .DESC[_LEN] GTR 0 DO
		    BEGIN
		    SELECTONE CH$RCHAR(.DESC[_PTR]) OF
			SET
			[%C'0' TO %C'9', %C'A' TO %C'F', %C'a' TO %C'f']: 0;
			[OTHERWISE]: EXITLOOP;
			TES;
		    STR[_LEN] = .STR[_LEN] + 1;
		    ADVANCE_(DESC);
		    END;
		IF .STR[_LEN] EQL 0 THEN RETURN FAIL;

		! Get the number
		IF CVT_ATB( .BASE, STR[0], VALUE ) EQL FAIL THEN RETURN FAIL;

		IF .VALUE GTRU 255 THEN RETURN FAIL;

		! Put value in appropriate place(s)
		IF .NUM_CHARS LSS 1 THEN CH2[0] = .VALUE;
		CH2[1] = .VALUE;
		NUM_CHARS = .NUM_CHARS + 1;

		END;

	    [C_QUOTE]:		! Quoted string
		BEGIN
		LOCAL
		    Q_CNT;

		Q_CNT = 1;		! We have seen one quote
		ADVANCE_(DESC);		! Advance past the first quote

		! Keep scanning characters until we are through with the string
		!
		WHILE TRUE DO
		    BEGIN

		    IF CH$RCHAR(.DESC[_PTR]) EQL C_QUOTE
		    THEN
			Q_CNT = .Q_CNT + 1
		    ELSE
			IF NOT .Q_CNT THEN EXITLOOP;

		    IF .Q_CNT
		    THEN
			BEGIN
			!
			! Emit the current character
			!
			CH2[1] = CH$RCHAR(.DESC[_PTR]);
			IF .NUM_CHARS EQL 0 THEN CH2[0] = .CH2[1];
			NUM_CHARS = .NUM_CHARS + 1;
			END;

		    ADVANCE_(DESC);
		    END;

		END;

	    [C_EQUAL,C_GREATER,C_LESS,C_DASH,C_L_PAREN,C_R_PAREN,
		    C_LF,C_CR,C_NULL,C_COMMA,C_EXCLAM]:
					    ! Reserved character so must be done
		EXITLOOP;

%(
	    [%C'A' TO %C'Z', %C'a' TO %C'z']:	! A valid unquoted character
		BEGIN
		CH2[1] = CH$RCHAR(.DESC[_PTR]);
		IF .NUM_CHARS EQL 0 THEN CH2[0] = .CH2[1];
		NUM_CHARS = .NUM_CHARS + 1;
		ADVANCE_(DESC);
		END;
)%
	    [OTHERWISE]:			! A valid unquoted character
		RETURN FAIL;

	    TES;

	END;

    ! Done
    IF .NUM_CHARS GTR 2
    THEN
	RETURN FAIL;

    RETURN .NUM_CHARS

    END;

GLOBAL ROUTINE SEARCH_TABLE
	(
	STRING:	REF VECTOR[2],
	INDEX:	REF VECTOR[1],
	TABLE:	REF SYM_TAB[],
	COUNT
	) =
!++
! Functional Description:
!
!	Search through a table to find a match with an input string.
!
! Formal Parameters:
!
!	STRING	- Address of length/address of the input string.
!	INDEX	- Address to store index of matching table entry.
!	TABLE	- Address of the table.
!	COUNT	- The number of entries in the table
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!	INDEX is set to the index of the matching table entry.
!
!--

    BEGIN

    LOCAL
	ITEM: VECTOR[2],	! Length/address of table item
	INP,		! Pointer to input string
	MATCH;		! Match flag

    output_('search_table');

    ! If input string length is zero return fail
    !
    IF .STRING[_LEN] LEQ 0 THEN RETURN FAIL;

    ! For each entry in table
    !
    DECR IN FROM .COUNT-1 TO 0 DO
	BEGIN

	! Initialize pointer to start of input string
	INP = .STRING[_PTR];

	! Get the address and length of table item
	ITEM[_PTR] = .TABLE[.IN, SYM_NAM_ADR];
	ITEM[_LEN] = .TABLE[.IN, SYM_NAM_LEN];

	! Initialize match flag
	MATCH = TRUE;

	! Lengths must be equal
	IF .ITEM[_LEN] EQL .STRING[_LEN]
	THEN
	    BEGIN

	    ! Compare the strings
	    !
	    WHILE .INP LSSA .STRING[_PTR] + .STRING[_LEN] DO
		BEGIN

		! Compare next characters converted to lower case
		IF LOWER_(CH$RCHAR(.INP)) NEQ LOWER_(CH$RCHAR(.ITEM[_PTR]))
		THEN
		    BEGIN
		    MATCH = FALSE;		! They don't match
		    EXITLOOP;
		    END;

		! Still have a match
		INP = .INP + 1;
		ITEM[_PTR] = .ITEM[_PTR] + 1;

		END;

	    ! Did they match?
	    IF .MATCH
	    THEN
		BEGIN
		INDEX[0] = .IN;		! Set index as output
		RETURN SUCCESS
		END;

	    END;

	END;

    ! Did not find match
    RETURN FAIL

    END;

GLOBAL ROUTINE ERR_CNTL(
	LINE_NO,
	ERROR_CODE     ) : CA_LINKAGE =

!++
! Functional Description:
!
!	Error control routine
!
! Formal Parameters:
!
!	LINE_NO		- Current line number.
!	ERROR_CODE	- Code number for the error being reported.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN

    output_('err_cntl');

    CA_AREA_( CA );

    %IF %BLISS( BLISS16 ) %THEN
    BEGIN

    LOCAL 
    	X,
    	STATUS,
	ERR_BUFF : REF VECTOR [,WORD];

    ! Get the address of the user error buffer
    ERR_BUFF = .CA[CA_STAT_ADR];

    ! Put the error code in the first word of the error buffer
    ! Put the line number in the second word of the error buffer
    ! Clear the rest
    ERR_BUFF[0] = .ERROR_CODE;
    ERR_BUFF[1] = .LINE_NO;
    ERR_BUFF[2] = 0;
    ERR_BUFF[3] = 0;

    X = ABS( .ERROR_CODE );    

    ! If too big for the warning message handler then must fatal out
    IF .X GEQ SOR$_LSTWRN 
    THEN 
    	BEGIN
    	ERR_BUFF[0] = -.X;
    	RETURN FAIL;
    	END;

    ! Call the user warning routine
    LIB_LINK( .CA[CA_USR_WRN], ERR_BUFF[0], STATUS );

    ! If we succeed then return
    !
    IF .STATUS NEQ SUCCESS
    THEN
    	!warning routine may have stuffed error buffer
    	RETURN FAIL;

    !if we haven't seen a fatal error yet then store the info away
    IF .CA[ CA_1ST_SPC_ERR ] EQL 0
    		AND
       .ERROR_CODE LSS 0
    THEN
    	BEGIN
    	CA[ CA_1ST_SPC_ERR ] = .ERROR_CODE;
    	CA[ CA_1ST_SPC_LIN ] = .LINE_NO;
    	END;

    !indicate no more error
    ERR_BUFF[0] = 0;
    ERR_BUFF[1] = 0;

    END;
    %FI

    %IF %BLISS(BLISS32)
    %THEN
	BEGIN
	EXTERNAL ROUTINE SOR$$ERROR;
	SOR$$ERROR( .ERROR_CODE, 1, .LINE_NO );
	END;
    %FI

    RETURN SUCCESS

    END;

%(
GLOBAL ROUTINE WRN_CNTL(
	LINE_NO,
	ERROR_CODE ): CA_LINKAGE =
!++
! Functional Description:
!
!	Warning control routine
!
! Formal Parameters:
!
!	LINE_NO		- Current line number.
!	ERROR_CODE	- Code number for the warning being reported.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	STATUS;

    ! Get the impure data area
    CA_AREA_( CA );

    output_('wrn_cntl');

    %IF %BLISS(BLISS16)
    %THEN
	BEGIN
	LOCAL
	    ERR_BUFF:	REF VECTOR [,WORD];

	! Get the address of the user error buffer
	ERR_BUFF = .CA[CA_STAT_ADR];

	! Put the error code in the first word of the error buffer
	! Put the line number in the second word of the error buffer
	! Clear the third word
	ERR_BUFF[0] = .ERROR_CODE;
	ERR_BUFF[1] = .LINE_NO;
	ERR_BUFF[2] = 0;

	! Call the user warning routine
	LIB_LINK( .CA[CA_USR_WRN], ERR_BUFF[0], STATUS );

	! If we fail then put negative code in buffer
	IF .STATUS NEQ SUCCESS
	THEN
	    BEGIN

	    ERR_BUFF[0] = - ABS( .ERROR_CODE );

	    RETURN FAIL;

	    END;
	END;
    %FI
    %IF %BLISS(BLISS32)
    %THEN
	BEGIN
	EXTERNAL ROUTINE SOR$$ERROR;
	SOR$$ERROR(.ERROR_CODE, 1, .LINE_NO);
	END;
    %FI

    RETURN SUCCESS

    END;
)%

! ELUDOM
!
END
ELUDOM
MODULE P1$PAS	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_KYW_TYPE,			! Get keyword type
	GET_CHAR_CLAUSE,		! Get character clauses of various kinds
	GET_ONE_CHAR,			! Get character or double character
	GET_NEXT_SPEC,			! Get pointer and length of next specification
	GET_SUB_SPEC,			! Get pointer and length of sub-specification
	GET_FILE_SPEC,			! Find file specification
	PARSE_COLL:	CA_LINKAGE;	! Parse collating sequence

GLOBAL ROUTINE P1$PASS_ONE(
	START:		REF VECTOR[3],
	CON_SYM:	REF CON_SYM_TAB,
	P_CON_CNT:	REF VECTOR[1]
	):	CA_LINKAGE =
    BEGIN
    !-----------------------------------------------------
    ! Pass 1:	parse /process, /stable, /strip,
    !		and /collating_sequence specifications.
    !		Build the PT and ST tables
    !-----------------------------------------------------
    BIND
	CON_CNT = P_CON_CNT[0];

    LOCAL
	KYW_LINE,			! Line number of keyword
	KYW_TYPE,			! Keyword type
	SUB_KYW_TYPE,
	BUFF:		VECTOR[3],
	SPC:		VECTOR[3],	! Next specification length/pointer/line
	SUB_SPC:	VECTOR[3];	! Sub specification length/pointer/line

    ! Get the impure area
    CA_AREA_( CA );

    !-----------------------------------------------------
    ! Pass 1:	parse /process, /stable, /strip,
    !		and /collating_sequence specifications.
    !		Build the PT and ST tables
    !-----------------------------------------------------
    BEGIN				! Pass 1
    LOCAL
	COLL:	VECTOR[3];		! Collating sequence specification

    output_('pass 1');

    ! Initialize for pass 1
    BUFF[_LEN] = .START[_LEN];
    BUFF[_PTR] = .START[_PTR];
    BUFF[_LINE] = .START[_LINE];

    COLL[_LEN] = 0;			! No collating sequence yet

    ! Exit loop when there are no remaining specifications
    !
    WHILE TRUE DO
	BEGIN

	KYW_LINE = .BUFF[_LINE];
	KYW_TYPE = GET_NEXT_SPEC( BUFF[0], SPC[0] );
	SUB_SPC[_LEN] = 0;		! Simplifies error checking below


	! Case on the keyword
	!
	SELECTONE .KYW_TYPE OF
	    SET

	    [KW_PROC]:				! /PROCESS=
		BEGIN
		IF .CA[CA_VAR_MERGE]		! Sort only
		THEN
		    WRN_( SOR$_SPCMIS )		! Merge invalid specification
		ELSE IF .CA[CA_PROCESS_OVR]
		THEN
		    WRN_( SOR$_SPCOVR )		! Warn of override
		ELSE
		    BEGIN

		    KYW_LINE = .SPC[_LINE];	! Save line for errors
		    SUB_KYW_TYPE = GET_SUB_SPEC( SPC[0], SUB_SPC[0] );

		    SELECTONE .SUB_KYW_TYPE OF
			SET
			[KW_RECD]:	CA[CA_PROCESS] = TYP_K_RECORD;
			[KW_TAG]:	CA[CA_PROCESS] = TYP_K_TAG;
			[KW_ADDR]:	CA[CA_PROCESS] = TYP_K_ADDRESS;
			[KW_INDX]:	CA[CA_PROCESS] = TYP_K_INDEX;
			[OTHERWISE]:	ERR_( .KYW_LINE, SOR$_SPCIVP );
			TES;

		    END;
		SPC[ _LEN ] = 0;
		END;

	    [KW_STAB, KW_NOST]:			! /[NO]STABLE
		BEGIN
		IF .CA[CA_STABLE_OVR]
		THEN
		    WRN_( SOR$_SPCOVR )		! Warn of override
		ELSE
		    BEGIN
		    IF .KYW_TYPE EQL KW_STAB
			THEN CA[CA_STABLE] = TRUE
			ELSE CA[CA_STABLE] = FALSE;
		    END;
		END;

	    [KW_CHSQ, KW_NOCH]:			! /[NO]CHECK_SEQUENCE
		BEGIN
		IF NOT .CA[CA_VAR_MERGE]	! Merge only
		THEN
		    WRN_( SOR$_SPCSIS )		! Sort invalid specification
		ELSE IF .CA[CA_CHKSEQ_OVR]
		THEN
		    WRN_( SOR$_SPCOVR )		! Warn of override
		ELSE
		    BEGIN
		    IF .KYW_TYPE EQL KW_CHSQ
			THEN CA[CA_CHKSEQ] = TRUE
			ELSE CA[CA_CHKSEQ] = FALSE
		    END;
		END;

	    [KW_COLL]:
		BEGIN
		IF .CA[CA_COLSEQ_OVR]
		THEN
		    WRN_( SOR$_SPCOVR )		! Warn of override
		ELSE
		    BEGIN
		    COLL[_LEN] = .SPC[_LEN];
		    COLL[_PTR] = .SPC[_PTR];
		    COLL[_LINE] = .SPC[_LINE];
		    END;
		SPC[_LEN] = 0;
		END;

	    [KW_PAD]:
		BEGIN
		LOCAL
		    CH2: VECTOR[2,BYTE];
		IF GET_ONE_CHAR(SPC[0], CH2) NEQ 1
		THEN
		    ERR_( .KYW_LINE, SOR$_SPCIVS )	! Invalid specification
		ELSE
		    CA[CA_PAD] = .CH2[0];
		END;

	    [KW_FIEL, KW_INCL, KW_OMIT, KW_KEY, KW_DATA,
	     KW_COND, KW_CDD]:
		BEGIN
		SPC[_LEN] = 0;			! Not parsed this pass
		END;

	    [KW_WORK]:
		BEGIN
		LOCAL
		    P: REF VECTOR[,BYTE];
		P = CA[CA_WF_NAMES];
		WHILE TRUE DO
		    BEGIN
		    IF GET_FILE_SPEC( SPC[0], SUB_SPC[0] ) EQL FAIL THEN EXITLOOP;
		    IF .P[0] GEQU MAX_WORK_FILES THEN EXITLOOP;
		    P[0] = .P[0] + 1;
		    P[.P[0]] = .CON_CNT;
		    CON_SYM[.CON_CNT, CON_NAM_ADR] = .SUB_SPC[_PTR];
		    CON_SYM[.CON_CNT, CON_NAM_LEN] = .SUB_SPC[_LEN];
		    CON_SYM[.CON_CNT, CON_LENGTH]  = .SUB_SPC[_LEN];
		    CON_CNT = .CON_CNT + 1;
		    IF SKIP_COMMA( SPC[0] ) EQL FAIL THEN EXITLOOP;
		    END;
		SUB_SPC[_LEN] = 0;
		END;

	    [OTHERWISE]:	! An invalid specification keyword
		BEGIN
		ERR_( .KYW_LINE, SOR$_SPCIVS );	! Invalid specification
		SPC[_LEN] = 0;			! Not parsed this pass
		END;

	    TES;

	! Check for extraneous text
	!
	IF .SUB_SPC[_LEN] NEQ 0			! Extraneous text?
	THEN
	    ERR_( .KYW_LINE, SOR$_SPCIVS );
	IF .SPC[_LEN] NEQ 0			! Extraneous text?
	THEN
	    ERR_( .SPC[_LINE], SOR$_SPCIVS );	! Invalid specification


	! Look for next significant character
	IF SKIP_IGNORED( BUFF[0] ) EQL FAIL THEN EXITLOOP;

	END;

    ! Process the collating sequence (now that we know the pad character)
    !
    IF .COLL[_LEN] NEQ 0
    THEN
	IF PARSE_COLL( COLL[0] ) EQL FAIL THEN RETURN FAIL;

    END;				! Pass 1

    RETURN SUCCESS;
    END;

! ELUDOM
!
END
ELUDOM
MODULE P2$PAS	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SEARCH_TABLE,			! Search a table for a string
	CVT_ATB,			! Convert ascii to binary
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_NEXT_SPEC,			! Get pointer and length of next specification
	GET_SUB_SPEC;			! Get pointer and length of sub-specification

GLOBAL ROUTINE P2$PASS_TWO(
	START:		REF VECTOR[3],
	FLD_SYM:	REF SYM_TAB
	):	CA_LINKAGE =
    BEGIN
    !------------------------------------------------------
    ! Pass 2:	define all fields, fill the field definition
    !		table and the field symbol table
    !		Build the FDT table
    !------------------------------------------------------

    LOCAL
	KYW_TYPE,			! Type of keyword
	SUB_KYW_TYPE,
	KYW_LINE,			! Line number of keyword
	BUFF:		VECTOR[3],
	SPC:		VECTOR[3],	! Next specification length/pointer/line
	SUB_SPC:	VECTOR[3];	! Sub specification length/pointer/line

    ! Get the impure area
    CA_AREA_( CA );


    !------------------------------------------------------
    ! Pass 2:	define all fields, fill the field definition
    !		table and the field symbol table
    !		Build the FDT table
    !------------------------------------------------------
    BEGIN				! Pass 2
    LOCAL
	FDT:	REF FDT_TAB[];	! Pointer to Field Defn Table

    output_('pass 2');

    ! Anchor field defn table at beginning of available work area
    ! Set address of field definition table in common area.
    !
    %IF %BLISS(BLISS16) %THEN IF NOT .CA[CA_KEY_OVR] %FI
    %IF %BLISS(BLISS32) %THEN IF .CA[CA_FDT_ADR] EQL 0 %FI
    THEN
	BEGIN
	CA[CA_FDT_ADR] = ALLOC_(0);
	CA[CA_FDT_SIZ] = 0;
	END
    ELSE
	BEGIN
	LOCAL
	    FROM_PTR;
	!move the key table entries generated by command line /ke:
	FROM_PTR = .CA[CA_FDT_ADR];
	CA[CA_FDT_ADR] = ALLOC_( .CA[CA_FDT_SIZ] * FDT_UNIT );
	CH$MOVE( .CA[CA_FDT_SIZ] * FDT_UNIT, .FROM_PTR, .CA[CA_FDT_ADR] );
	END;

    ! Initialize for pass 2
    BUFF[_LEN] = .START[_LEN];
    BUFF[_PTR] = .START[_PTR];
    BUFF[_LINE] = .START[_LINE];


    ! Always define a default field; character, offset 0, lrl long
    !
    FDT = ALLOC_(FDT_UNIT);
    CA[CA_FDT_SIZ] = .CA[CA_FDT_SIZ] + 1;
    FDT[0, FDT_TYPE] = DT_T;
    FDT[0, FDT_SCALE] = 0;
    FDT[0, FDT_FLD_POS] = 0;
    FDT[0, FDT_FLD_SIZ] = -1;	! (Just in case)

    ! Exit loop when there are no remaining specifications
    WHILE TRUE DO
	BEGIN

	LABEL
	    fld;

	KYW_LINE = .BUFF[_LINE];
	KYW_TYPE = GET_NEXT_SPEC( BUFF[0], SPC[0] );

	! Process the keyword (only field definitions)
	!
	SELECTONE .KYW_TYPE OF
	SET
	[KW_FIEL]:
fld:	    BEGIN	! Make an entry in the field table

	    LITERAL			! Bit masks for data_types
		BINARY_BIT = %X'0001',	! Binary
		DECIMA_BIT = %X'0002',	! Decimal
		SIGNED_BIT = %X'0004',	! Signed
		UNSIGN_BIT = %X'0008',	! Unsigned
		TRAILI_BIT = %X'0010',	! Trailing sign
		LEADIN_BIT = %X'0020',	! Leading sign
		SEPARA_BIT = %X'0040',	! Separate sign
		OVERPU_BIT = %X'0080',	! Overpunched sign
		OTHERS_BIT = %X'0100';	! Other explicit data types

	    LOCAL
		DATA_TYPE,		! Bit_vector defining data type
		TYP: BYTE SIGNED,	! Data type
		NUMBER,			! Returned number
		INDEX,			! Returned index
		NAM_SET,		! Name set flag
		POS_SET,		! Position set flag
		SIZ_SET,		! Size set flag
		DIG_SET;		! Digits set flag

	    FDT = ALLOC_(FDT_UNIT);
	    CA[CA_FDT_SIZ] = .CA[CA_FDT_SIZ] + 1;

	    ! Too many entries in FDT or field symbol table?
	    IF .CA[CA_FDT_SIZ] GEQ MIN(FDT_MAX, MAX_FIELDS)
	    THEN
		BEGIN
		ERR_( .KYW_LINE, SOR$_SPCIVF );		! Invalid field
		LEAVE fld;
		END;

	    ! Initialize flags
	    NAM_SET = FALSE;
	    POS_SET = FALSE;
	    SIZ_SET = FALSE;
	    DIG_SET = FALSE;
	    DATA_TYPE = 0;

	    ! While there are more field sub-specifications
	    WHILE TRUE DO
		BEGIN

		KYW_LINE = .SPC[_LINE];
		SUB_KYW_TYPE = GET_SUB_SPEC( SPC[0], SUB_SPC[0] );

		! Check the sub-specification
		!
		SELECTONE .SUB_KYW_TYPE OF
		    SET

		    [KW_NAME]:	! Field name
			BEGIN

			! Name should not already be defined and
			! Length must be greater than zero
			IF .SUB_SPC[_LEN] LEQ 0 OR
			   .NAM_SET
			THEN
			    BEGIN
			    ERR_( .KYW_LINE, SOR$_SPCIVF );		! Invalid field
			    LEAVE fld;
			    END;

			! Look for the name in the field symbol table
			IF SEARCH_TABLE( SUB_SPC[0], INDEX,
			    FLD_SYM[0,BASE_], .CA[CA_FDT_SIZ]-1 ) EQL SUCCESS
			THEN
			    ! Name has already been used
			    BEGIN
			    ERR_( .SUB_SPC[_LINE], SOR$_SPCIVF );	! Invalid field
			    LEAVE fld;
			    END;

			! Put the length/address in the field symbol table entry
			! Put the fdt index in the field symbol table
			BEGIN
			LOCAL FLD_SYM_LOC: REF SYM_TAB [1];
			FLD_SYM_LOC = FLD_SYM[.CA[CA_FDT_SIZ]-1, BASE_];
			FLD_SYM_LOC[0, SYM_NAM_LEN] = .SUB_SPC[_LEN];
			FLD_SYM_LOC[0, SYM_NAM_ADR] = .SUB_SPC[_PTR];
			FLD_SYM_LOC[0, SYM_INDEX] = .CA[CA_FDT_SIZ]-1;
			END;

			! Name has been set
			NAM_SET = TRUE;

			! Nothing is left
			SUB_SPC[_LEN] = 0;

			END;

		    [KW_SIZE, KW_DIGI]:
			BEGIN
			LOCAL
			    STATUS;			! Return status

			! Get the number
			STATUS = CVT_ATB( 10, SUB_SPC[0], NUMBER );

			! Size should not be set and
			! Positive numbers only
			IF .STATUS EQL FAIL OR .SIZ_SET
			THEN
			    BEGIN
			    ERR_( .KYW_LINE, SOR$_SPCIVF );		! Invalid field
			    LEAVE fld;
			    END;

			! Size has been set
			SIZ_SET = TRUE;

			! Place value in size field of FDT
			FDT[0, FDT_FLD_SIZ] = .NUMBER;
			%IF %BLISS(BLISS32) %THEN
			FDT[0, FDT_SCALE] = 0;
			%FI

			DIG_SET = (.SUB_KYW_TYPE EQL KW_DIGI);
			END;

		    [KW_POSI]:
			BEGIN
			LOCAL
			    STATUS;			! Return status

			! Get the number
			STATUS = CVT_ATB( 10, SUB_SPC[0], NUMBER );

			! Position should not already be set and
			! Number must be greater than zero
			IF .STATUS EQL FAIL OR
			   .POS_SET OR
			   .NUMBER LEQ 0
			THEN
			    BEGIN
			    ERR_( .KYW_LINE, SOR$_SPCIVF );	! Invalid field
			    LEAVE fld;
			    END;

			! Position has been set
			POS_SET = TRUE;

			! Place value in position field of FDT
			! Make it zero based
			FDT[0, FDT_FLD_POS] = .NUMBER - 1;

			END;

		    [KW_ASCF]:
			BEGIN
			TYP = DT_AF;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_ASCZ]:
			BEGIN
			TYP = DT_AZ;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_BINA]:
			DATA_TYPE = .DATA_TYPE OR BINARY_BIT;

		    [KW_CHAR]:
			BEGIN
			TYP = DT_T;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_DECI]:
			DATA_TYPE = .DATA_TYPE OR DECIMA_BIT;

		    [KW_DIBO]:
			BEGIN
			TYP = DT_DB;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_FFLT]:
			BEGIN
			TYP = DT_F;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_DFLT]:
			BEGIN
			TYP = DT_D;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_GFLT]:
			BEGIN
			TYP = DT_G;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_HFLT]:
			BEGIN
			TYP = DT_H;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_PACK]:
			BEGIN
			TYP = DT_P;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_ZONE]:
			BEGIN
			TYP = DT_NZ;
			DATA_TYPE = .DATA_TYPE OR OTHERS_BIT;
			END;

		    [KW_SIGN]:
			DATA_TYPE = .DATA_TYPE OR SIGNED_BIT;

		    [KW_UNSI]:
			DATA_TYPE = .DATA_TYPE OR UNSIGN_BIT;

		    [KW_LEAD]:
			DATA_TYPE = .DATA_TYPE OR LEADIN_BIT;

		    [KW_TRAI]:
			DATA_TYPE = .DATA_TYPE OR TRAILI_BIT;

		    [KW_OVER]:
			DATA_TYPE = .DATA_TYPE OR OVERPU_BIT;

		    [KW_SEPA]:
			DATA_TYPE = .DATA_TYPE OR SEPARA_BIT;

		    [OTHERWISE]:		! Bad sub-specification
    			BEGIN
			ERR_( .KYW_LINE, SOR$_SPCIVF );
    			LEAVE fld;
    			END;

		    TES;

		! Check for extraneous matter
		IF .SUB_SPC[_LEN] GTR 0
		THEN
		    ERR_( .SUB_SPC[_LINE], SOR$_SPCIVF );	! Invalid field

		IF SKIP_COMMA( SPC[0] ) EQL FAIL THEN EXITLOOP;
		END;

	    ! Determine final data type, which bits were set above?
	    !
	    IF .DATA_TYPE NEQ 0
	    THEN
		BEGIN
		MACRO
		    DEF_(X,Y) =		! Macro to apply defaults
			BEGIN
			IF (.DATA_TYPE AND (X)) EQL 0
			THEN
			    DATA_TYPE = .DATA_TYPE OR (Y);
			END %;
		IF (.DATA_TYPE AND OTHERS_BIT) EQL 0
		THEN
		    DEF_(SIGNED_BIT OR UNSIGN_BIT, SIGNED_BIT);
		IF (.DATA_TYPE AND DECIMA_BIT) NEQ 0
		THEN
		    BEGIN
		    DEF_(UNSIGN_BIT OR TRAILI_BIT OR LEADIN_BIT, TRAILI_BIT);
		    DEF_(UNSIGN_BIT OR SEPARA_BIT OR OVERPU_BIT, OVERPU_BIT);
		    END;
		END;

	    !	BINARY_BIT = %X'0001',	! Binary
	    !	DECIMA_BIT = %X'0002',	! Decimal
	    !	SIGNED_BIT = %X'0004',	! Signed
	    !	UNSIGN_BIT = %X'0008',	! Unsigned
	    !	TRAILI_BIT = %X'0010',	! Trailing sign
	    !	LEADIN_BIT = %X'0020',	! Leading sign
	    !	SEPARA_BIT = %X'0040',	! Separate sign
	    !	OVERPU_BIT = %X'0080',	! Overpunched sign
	    !	OTHERS_BIT = %X'0100';	! Other explicit data types

	    SELECTONE .DATA_TYPE OF
		SET
		[%X'0000']:	TYP = DT_T;	! Character
		[%X'0100']:	0;		! Do nothing, already set above
		[%X'0005']:	TYP = DT_B;	! Signed binary
		[%X'0009']:	TYP = DT_U;	! Unsigned binary
		[%X'000A']:	TYP = DT_NU;	! Unsigned decimal
		[%X'0096']:	TYP = DT_NRO;	! Decimal trailing overpunch
		[%X'0056']:	TYP = DT_NR;	! Decimal trailing separate
		[%X'00A6']:	TYP = DT_NLO;	! Decimal leading overpunch
		[%X'0066']:	TYP = DT_NL;	! Decimal leading separate
		[OTHERWISE]:			! Bad data type
		    ERR_( .KYW_LINE, SOR$_SPCIVD );
		TES;

	    FDT[0, FDT_TYPE] = .TYP;
	    IF .TYP LSS 0 THEN ERR_( .KYW_LINE, SOR$_SPCIVF );

	    ! Check for missing stuff
	    IF NOT (.NAM_SET AND .POS_SET AND .SIZ_SET)
	    THEN
		ERR_( .KYW_LINE, SOR$_SPCIVF );	! invalid field

	    ! If the key is decimal, zoned or packed, verify that the length
	    ! was specified in digits (on VAX).
	    ! Convert DIGITS to bytes, except for VAX packed.
	    ! If the key is not decimal or packed, digits can't be used.
	    !
	    BEGIN
	    MACRO
		SIZE = FDT[0, FDT_FLD_SIZ] %;
	    IF (.DATA_TYPE AND DECIMA_BIT) NEQ 0
		OR .TYP EQL DT_NZ
		OR .TYP EQL DT_DB
	    THEN
		BEGIN
		IF NOT .DIG_SET
		THEN
		    %IF %BLISS(BLISS32)
		    %THEN ERR_( .KYW_LINE, SOR$_SPCIVF )
		    %ELSE 0
		    %FI
		ELSE
		    IF (.DATA_TYPE AND SEPARA_BIT) NEQ 0 THEN SIZE = .SIZE + 1;
		END
	    ELSE IF .TYP EQL DT_P
	    THEN
		BEGIN
		%IF %BLISS(BLISS32)
		%THEN IF NOT .DIG_SET THEN ERR_( .KYW_LINE, SOR$_SPCIVF );
		%FI
		%IF %BLISS(BLISS16)
		%THEN SIZE = (.SIZE + 1) / 2;
		%FI
		END
	    ELSE
		IF .DIG_SET THEN ERR_( .KYW_LINE, SOR$_SPCIVF );
	    END;
	    END;

	%IF %BLISS(BLISS32) %THEN
	[KW_CDD]:
	    BEGIN
	    EXTERNAL ROUTINE
		CRE_EXTRACT_RECORD: CA_LINKAGE;
	    LOCAL
		STATUS;
	    IF .SPC[_LEN] GEQ 2 THEN
	    IF  CH$RCHAR(.SPC[_PTR]) EQL C_QUOTE AND
		CH$RCHAR(.SPC[_PTR]+.SPC[_LEN]-1) EQL C_QUOTE
	    THEN
		BEGIN
		SPC[_PTR] = .SPC[_PTR]+1;
		SPC[_LEN] = .SPC[_LEN]-2;
		END;
	    STATUS = CRE_EXTRACT_RECORD( SPC[0], FLD_SYM[0,BASE_], .KYW_LINE );
	    IF_ERROR_( .STATUS )
	    THEN
		ERR_( .KYW_LINE, .STATUS );
	    END;
	%FI

	[OTHERWISE]:
	    0;

	TES;

	! Move pointer to next specification
	IF SKIP_IGNORED( BUFF[0] ) EQL FAIL THEN EXITLOOP;

	END;

    END;				! Pass 2

    RETURN SUCCESS;
    END;

! ELUDOM
!
END
ELUDOM
MODULE P3$PAS	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_NEXT_SPEC,			! Get pointer and length of next specification
	GET_SUB_SPEC,			! Get pointer and length of sub-specification
	SEARCH_TABLE,
	PARSE_TEST:	CA_LINKAGE;	! Parse a test clause

GLOBAL ROUTINE P3$PASS_THREE(
	START:		REF VECTOR[3],
	CON_SYM:	REF CON_SYM_TAB,
	P_CON_CNT:	REF VECTOR[1],
	FLD_SYM:	REF SYM_TAB,
	CDX_SYM:	REF SYM_TAB,
	P_CDX_CNT:	REF VECTOR[1]
	):	CA_LINKAGE =
    BEGIN
    !---------------------------------------------------
    ! Pass 3:	parse condition specifications.
    !		set up test definition table,
    !		condition symbol table and the
    !		constant symbol table.
    !		Build the TDT table
    !---------------------------------------------------
    BIND
	CON_CNT = P_CON_CNT[0],
	CDX_CNT = P_CDX_CNT[0];

    LOCAL
	KYW_TYPE,			! Type of keyword
	SUB_KYW_TYPE,
	KYW_LINE,			! Line number of keyword
	BUFF:		VECTOR[3],
	SPC:		VECTOR[3],	! Next specification length/pointer/line
	SUB_SPC:	VECTOR[3],	! Sub specification length/pointer/line
	COLL:		VECTOR[3];	! Collating sequence specification

    ! Get the impure area
    CA_AREA_( CA );


    !---------------------------------------------------
    ! Pass 3:	parse condition specifications.
    !		set up test definition table,
    !		condition symbol table and the
    !		constant symbol table.
    !		Build the TDT table
    !---------------------------------------------------
    BEGIN				! Pass 3

    output_('pass 3');

    ! Anchor condition definition table at beginning of available work area
    ! Set address of condition definition table
    CA[CA_TDT_ADR] = ALLOC_(0);


    ! Initialize for pass 3
    BUFF[_LEN] = .START[_LEN];
    BUFF[_PTR] = .START[_PTR];
    BUFF[_LINE] = .START[_LINE];

    ! Exit loop when there are no remaining specifications
    WHILE TRUE DO
	BEGIN
	LABEL
	    condition;

	KYW_LINE = .BUFF[_LINE];
	KYW_TYPE = GET_NEXT_SPEC( BUFF[0], SPC[0] );

	! Process the keyword (only conditions)
	!
	IF .KYW_TYPE EQL KW_COND
	THEN
condition:  BEGIN	! Make a entry in the test definition table
	    LOCAL
		INDEX,			! Returned index in symbol table
		NAM_SET,		! Name qualifier defined
		TST_SET;		! Test qualifier defined

	    ! Too many entries in the named condition table?
	    IF .CDX_CNT GEQ MAX_CONDX
	    THEN
		BEGIN
		ERR_( .KYW_LINE, SOR$_SPCIVX );		! Invalid condition
		LEAVE condition;
		END;

	    NAM_SET = FALSE;
	    TST_SET = FALSE;

	    ! While there are more condition sub-specifications
	    WHILE TRUE DO
		BEGIN

		KYW_LINE = .SPC[_LINE];
		SUB_KYW_TYPE = GET_SUB_SPEC( SPC[0], SUB_SPC[0] );

		! Check the sub-specification
		!
		SELECTONE .SUB_KYW_TYPE OF
		    SET

		    [KW_NAME]:
			BEGIN

			! Name should not already be defined and
			! Length must be greater than zero
			IF .SUB_SPC[_LEN] LEQ 0
				OR
			   .NAM_SET
			THEN
			    BEGIN
			    ERR_( .KYW_LINE, SOR$_SPCIVX );	! Invalid condition
			    LEAVE condition;
			    END;

			! Look for the name in the condition symbol table
			IF SEARCH_TABLE( SUB_SPC[0], INDEX,
				CDX_SYM[0,BASE_], .CDX_CNT ) EQL SUCCESS
			THEN
			    ! Name has already been used
			    BEGIN
			    ERR_( .SUB_SPC[_LINE], SOR$_SPCIVX );	! Invalid condition
			    LEAVE condition;
			    END;

			! Put the length/address in the condition symbol table entry
			CDX_SYM[.CDX_CNT, SYM_NAM_LEN] = .SUB_SPC[_LEN];
			CDX_SYM[.CDX_CNT, SYM_NAM_ADR] = .SUB_SPC[_PTR];

			! Put the tdt index in the condition symbol table
			CDX_SYM[.CDX_CNT, SYM_INDEX] = .CA[CA_TDT_SIZ];

			! Increment the count of named condition
			CDX_CNT = .CDX_CNT + 1;

			! Name has been set
			NAM_SET = TRUE;

			END;

		    [KW_TEST]:

			BEGIN
			LOCAL
			    STATUS;			! Return status

			! Parse the test clause
			STATUS = PARSE_TEST( SUB_SPC[0],
			    CON_SYM[0,BASE_], CON_CNT,
			    FLD_SYM[0,BASE_] );

			! Test should not already be defined and test clause should
			! Be greater then zero in length
			IF .TST_SET OR .STATUS EQL FAIL
			THEN
			    BEGIN
			    ERR_( .SUB_SPC[_LINE], SOR$_SPCIVX );	! Invalid condition
			    LEAVE condition;
			    END;

			! Test has been set
			TST_SET = TRUE;

			END;

		    [OTHERWISE]:			! Neither "test" nor "name"
			BEGIN
			ERR_( .KYW_LINE, SOR$_SPCIVX );	! Invalid condition
			LEAVE condition;
			END;

		    TES;

		IF SKIP_COMMA( SPC[0] ) EQL FAIL THEN EXITLOOP;
		END;

	    ! Make sure mandatory stuff is set
	    IF NOT (.NAM_SET AND .TST_SET)
	    THEN
		BEGIN
		ERR_( .KYW_LINE, SOR$_SPCIVX );	! Invalid condition
		LEAVE condition;
		END;

	    END;


	! Find the next specification, ignore comments and blanks
	IF SKIP_IGNORED( BUFF[0] ) EQL FAIL THEN EXITLOOP;

	END;

    END;				! Pass 3

    RETURN SUCCESS;
    END;

! ELUDOM
!
END
ELUDOM
MODULE P4$PAS	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	GET_NEXT_SPEC,			! Get pointer and length of next specification
	PARSE_KEY:	CA_LINKAGE;	! Parse key definitions

GLOBAL ROUTINE P4$PASS_FOUR(
	START:		REF VECTOR[3],
	CON_SYM:	REF CON_SYM_TAB,
	P_CON_CNT:	REF VECTOR[1],
	FLD_SYM:	REF SYM_TAB,
	CDX_SYM:	REF SYM_TAB,
	P_CDX_CNT:	REF VECTOR[1]
	):	CA_LINKAGE =
    BEGIN
    !-------------------------------------------------------
    ! Pass 4:	parse all /KEY and /DATA specifications.
    !		define the default record type in temporary
    !		record definition table.
    !		Build the KFT table
    !-------------------------------------------------------
    BIND
	CON_CNT = P_CON_CNT[0],
	CDX_CNT = P_CDX_CNT[0];

    LOCAL
	KYW_TYPE,			! Type of keyword
	KYW_LINE,			! Line number of keyword
	BUFF:		VECTOR[3],
	SPC:		VECTOR[3],	! Next specification length/pointer/line
	SUB_SPC:	VECTOR[3];	! Sub specification length/pointer/line

    ! Get the impure area
    CA_AREA_( CA );


    !-------------------------------------------------------
    ! Pass 4:	parse all /KEY and /DATA specifications.
    !		define the default record type in temporary
    !		record definition table.
    !		Build the KFT table
    !-------------------------------------------------------
    BEGIN				! Pass 4
    LOCAL
	KEY_SET,		! Has key been explicitly set
	DATA_SET;		! Has data been explicitly set

    output_('pass 4');

    ! Anchor key/data field table (KFT) at beginning of available work area
    ! Set address of key/data field definition table
    ! Key field table so far has no entries
    !
    %IF %BLISS(BLISS16) %THEN IF NOT .CA[CA_KEY_OVR] %FI
    %IF %BLISS(BLISS32) %THEN IF .CA[CA_KFT_ADR] EQL 0 %FI
    THEN
	BEGIN
	CA[CA_KFT_ADR] = ALLOC_(0);
	CA[CA_KFT_SIZ] = 0;
	END
    ELSE
	BEGIN
	LOCAL
	    FROM_PTR;
	!move the key table entries generated by command line /ke:
	FROM_PTR = .CA[CA_KFT_ADR];
	CA[CA_KFT_ADR] = ALLOC_( .CA[CA_KFT_SIZ] * KFT_UNIT );
	CH$MOVE( .CA[CA_KFT_SIZ] * KFT_UNIT, .FROM_PTR, .CA[CA_KFT_ADR] );
	END;

    ! Initialize for pass 4
    BUFF[_LEN] = .START[_LEN];
    BUFF[_PTR] = .START[_PTR];
    BUFF[_LINE] = .START[_LINE];

    ! Neither key nor data has been explicitly given
    KEY_SET = FALSE;
    DATA_SET = FALSE;

    ! Exit loop when there are no remaining specifications
    WHILE TRUE DO
	BEGIN
	LABEL
	    key;

	KYW_LINE = .BUFF[_LINE];
	KYW_TYPE = GET_NEXT_SPEC( BUFF[0], SPC[0] );

	! Process the keyword
	!
key:	BEGIN
	SELECT .KYW_TYPE OF
	    SET

	    [KW_KEY, KW_DATA]:	! Make entry in the key/data field table (KFT)
		BEGIN
		LOCAL
		    IS_DATA;

		IF .KYW_TYPE EQL KW_DATA
		THEN
		    BEGIN
		    DATA_SET = TRUE;
		    IS_DATA = TRUE;
		    END
		ELSE
		    BEGIN
		    IF .CA[CA_KEY_OVR]
		    THEN
			BEGIN
			WRN_( SOR$_SPCOVR );	! Warn of override
			LEAVE key;
			END;
		    KEY_SET = TRUE;
		    IS_DATA = FALSE;
		    END;

		! Parse the key or data
		IF PARSE_KEY( SPC[0], .IS_DATA,
		    CON_SYM[0,BASE_], CON_CNT,
		    FLD_SYM[0,BASE_],
		    CDX_SYM[0,BASE_], CDX_CNT ) EQL FAIL
		THEN
		    ERR_( .SPC[_LINE], SOR$_SPCIVK );	! Invalid key or data field

		END;

	    ! Bad specification keywords handled in pass 1
	    TES;
	END;

	! Find the next specification, ignore comments and blanks
	IF SKIP_IGNORED( BUFF[0] ) EQL FAIL THEN EXITLOOP;

	END;

    ! See if default key field needs to be defined
    !
    IF NOT (.KEY_SET OR .CA[CA_KEY_OVR])
    THEN
	BEGIN		! Define default key entry
	LOCAL
	    KFT:	REF KFT_TAB[];	! Pointer to Key Field Table

	KFT = ALLOC_(KFT_UNIT);
	IF .CA[CA_KFT_SIZ] GEQ KFT_MAX THEN ERR_( 0, SOR$_WKAREA );
	CA[CA_KFT_SIZ] = .CA[CA_KFT_SIZ] + 1;

	KFT[0, KFT_BUILD] = TRUE;
	KFT[0, KFT_CONTINUE] = TRUE;
	KFT[0, KFT_CONSTANT] = FALSE;
	KFT[0, KFT_CONT_CDX] = FALSE;
	KFT[0, KFT_CONDX] = FALSE;
	KFT[0, KFT_DESCEND] = FALSE;
	KFT[0, KFT_DATA] = FALSE;
	KFT[0, KFT_NDE_POS] = 0;
	KFT[0, KFT_FDT_IDX] = 0;
	KFT[0, KFT_TDT_IDX] = 0;

	END;

    ! See if default data field needs to be defined
    !
    IF NOT .DATA_SET
    THEN
	BEGIN		! Define default data entry
	LOCAL
	    KFT:	REF KFT_TAB[];	! Pointer to Key Field Table

	KFT = ALLOC_(KFT_UNIT);
	IF .CA[CA_KFT_SIZ] GEQ KFT_MAX THEN ERR_( 0, SOR$_WKAREA );
	CA[CA_KFT_SIZ] = .CA[CA_KFT_SIZ] + 1;

	KFT[0, KFT_BUILD] = TRUE;
	KFT[0, KFT_CONTINUE] = TRUE;
	KFT[0, KFT_DATA] = TRUE;
	KFT[0, KFT_CONSTANT] = FALSE;
	KFT[0, KFT_CONT_CDX] = FALSE;
	KFT[0, KFT_CONDX] = FALSE;
	KFT[0, KFT_DESCEND] = FALSE;
	KFT[0, KFT_NDE_POS] = 0;
	KFT[0, KFT_FDT_IDX] = 0;
	KFT[0, KFT_TDT_IDX] = 0;

	END;

    ! Set continue bit off for last key field table entry
    BEGIN
    LOCAL KFT: REF KFT_TAB[];
    KFT = .CA[CA_KFT_ADR];
    KFT = KFT[.CA[CA_KFT_SIZ]-1, BASE_];
    KFT[0, KFT_CONTINUE] = FALSE;
    END;

    END;				! Pass 4

    RETURN SUCCESS;
    END;

! ELUDOM
!
END
ELUDOM
MODULE P5$PAS	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_NEXT_SPEC,			! Get pointer and length of next specification
	GET_SUB_SPEC,			! Get pointer and length of sub-specification
	SEARCH_TABLE,			! Search a table for a string
	PARSE_KEY:	CA_LINKAGE,	! Parse the key or data clause
	CONV_CONSTANTS:	CA_LINKAGE;	! Convert constant symbol table to

GLOBAL ROUTINE P5$PASS_FIVE(
	START:		REF VECTOR[3],
	CON_SYM:	REF CON_SYM_TAB,
	P_CON_CNT:	REF VECTOR[1],
	FLD_SYM:	REF SYM_TAB,
	CDX_SYM:	REF SYM_TAB,
	P_CDX_CNT:	REF VECTOR[1],
	TRDT:		REF TRDT_TAB
	):	CA_LINKAGE =
    BEGIN
    !-----------------------------------------------------------
    ! Pass 5:	parse all /include and /omit specifications.
    !		finish the temporary record definition table.
    !		create the record definition table from the
    !		temporary record definition table.
    !		create the constant table.
    !		Build the RDT table
    !-----------------------------------------------------------
    BIND
	CON_CNT = P_CON_CNT[0],
	CDX_CNT = P_CDX_CNT[0];


    LOCAL
	KYW_TYPE,			! Type of keyword
	SUB_KYW_TYPE,
	KYW_LINE,			! Line number of keyword
	BUFF:		VECTOR[3],
	SPC:		VECTOR[3],	! Next specification length/pointer/line
	SUB_SPC:	VECTOR[3],	! Sub specification length/pointer/line
	COLL:		VECTOR[3],	! Collating sequence specification
	TRDT_CNT;


    ! Get the impure area
    CA_AREA_( CA );


    !-----------------------------------------------------------
    ! Pass 5:	parse all /include and /omit specifications.
    !		finish the temporary record definition table.
    !		create the record definition table from the
    !		temporary record definition table.
    !		create the constant table.
    !		Build the RDT table
    !-----------------------------------------------------------
    BEGIN				! Pass 5

    output_('pass 5');

    ! Initialize for pass 5
    BUFF[_LEN] = .START[_LEN];
    BUFF[_PTR] = .START[_PTR];
    BUFF[_LINE] = .START[_LINE];

    ! Initialize temporary record defn table count for this pass
    TRDT_CNT = 0;

    ! Exit loop when there are no remaining specifications
    WHILE TRUE DO
	BEGIN
	LABEL
	   include;

	KYW_LINE = .BUFF[_LINE];
	KYW_TYPE = GET_NEXT_SPEC( BUFF[0], SPC[0] );

	! Process the keyword
	!
	SELECTONE .KYW_TYPE OF
	    SET
	    [KW_INCL, KW_OMIT]:	! Make entry in temporary record defn table
include:	BEGIN
		LITERAL
		    CDX_SET = 0,
		    KEY_SET = 1,
		    DAT_SET = 2;
		LOCAL
		    FLAGS: BITVECTOR[3];

		IF .TRDT_CNT GEQ RDT_MAX
		THEN
		    BEGIN
		    ERR_( .KYW_LINE, SOR$_WKAREA );
		    RETURN FAIL;
		    END;

		! No key or data or condition found in include yet
		FLAGS<0,%BPUNIT*%ALLOCATION(FLAGS),0> = 0;

		! Set the include bit and KFT index
		IF .KYW_TYPE EQL KW_INCL
		THEN
		    BEGIN
		    TRDT[.TRDT_CNT, TRDT_INCLUDE] = TRUE;
		    TRDT[.TRDT_CNT, TRDT_KFT_IDX] = .CA[CA_KFT_SIZ];
		    END
		ELSE
		    BEGIN
		    TRDT[.TRDT_CNT, TRDT_INCLUDE] = FALSE;
		    END;

		! Initialize the conditional bit to off
		TRDT[.TRDT_CNT, TRDT_CONDX] = FALSE;

		! While there are more include or omit sub-specifications
		WHILE .SPC[_LEN] NEQ 0 DO
		    BEGIN
		    LABEL
			key;

		    KYW_LINE = .SPC[_LINE];
		    SUB_KYW_TYPE = GET_SUB_SPEC( SPC[0], SUB_SPC[0] );

		    ! Check the sub-specification
		    !
key:		    BEGIN
		    LOCAL
			IS_DATA;

		    SELECT .SUB_KYW_TYPE OF
			SET

			[KW_COND]:		! Condition
			    BEGIN
			    LOCAL
				INDEX,
				STATUS;			! Return status

			    ! Search the condition symbol table for it
			    STATUS = SEARCH_TABLE( SUB_SPC[0],
				INDEX, CDX_SYM[0,BASE_], .CDX_CNT );

			    ! Condition should not have been set and should have
			    ! Non-zero length
			    IF .STATUS EQL FAIL OR .FLAGS[CDX_SET]
			    THEN
				BEGIN
				ERR_( .KYW_LINE, SOR$_SPCIVI );	! Invalid include or omit
				LEAVE include;
				END;

			    ! Condition has been set
			    FLAGS[CDX_SET] = TRUE;

			    ! Put the index in the temporary RDT
			    TRDT[.TRDT_CNT, TRDT_CONDX] = TRUE;
			    TRDT[.TRDT_CNT, TRDT_TDT_IDX] =
				.CDX_SYM[.INDEX, SYM_INDEX];

			    END;

			[KW_KEY]:
			    BEGIN

			    IS_DATA = FALSE;

			    IF .CA[CA_KEY_OVR]
			    THEN
				BEGIN
				WRN_( SOR$_SPCOVR );	! Warn of override
				LEAVE key;
				END
			    ELSE
				FLAGS[KEY_SET] = TRUE;	! Key has been given
			    END;

			[KW_DATA]:
			    BEGIN

			    IS_DATA = TRUE;

			    FLAGS[DAT_SET] = TRUE;	! Data has been given

			    END;

			[KW_KEY, KW_DATA]:	! Make entry in KFT table
			    BEGIN

			    ! If this is an omit then error
			    IF .KYW_TYPE EQL KW_OMIT
			    THEN
				BEGIN
				ERR_( .KYW_LINE, SOR$_SPCIVI );	! Invalid or omit
				LEAVE include;
				END;

			    ! Parse the key or data
			    IF PARSE_KEY( SUB_SPC[0], .IS_DATA,
				CON_SYM[0,BASE_], CON_CNT,
				FLD_SYM[0,BASE_],
				CDX_SYM[0,BASE_], CDX_CNT ) EQL FAIL
			    THEN
				BEGIN
				ERR_( .SUB_SPC[_LINE], SOR$_SPCIVI );	! Invalid include or omit
				LEAVE include;
				END;

			    END;

			[OTHERWISE]:		! Bad include sub-specification
			    BEGIN
			    ERR_( .KYW_LINE, SOR$_SPCIVI );	! Invalide include or omit
			    LEAVE include;
			    END;

			TES;
		    END;

		    IF SKIP_COMMA( SPC[0] ) EQL FAIL THEN EXITLOOP;
		    END;

		! If no key or data set then put default key index in TRDT
		IF NOT .FLAGS[KEY_SET] AND NOT .FLAGS[DAT_SET]
		THEN
		    TRDT[.TRDT_CNT, TRDT_KFT_IDX] = 0
		ELSE
		    IF .FLAGS[KEY_SET] AND .FLAGS[DAT_SET]
		THEN
		    0
		ELSE
		    IF NOT .FLAGS[KEY_SET]
		THEN
		    ERR_( .KYW_LINE, SOR$_INCNOKEY )
		ELSE
		    ERR_( .KYW_LINE, SOR$_INCNODATA );


		! Update the number of RDT table entries
		TRDT_CNT = .TRDT_CNT + 1;

		! Turn continue bit off for last key field table entry
		BEGIN
		LOCAL KFT: REF KFT_TAB[];
		KFT = .CA[CA_KFT_ADR];
		KFT[.CA[CA_KFT_SIZ]-1, KFT_CONTINUE] = FALSE;
		END;

		END;

	    TES;

	! Find the next specification, ignore comments and blanks
	IF SKIP_IGNORED( BUFF[0] ) EQL FAIL THEN EXITLOOP;

	END;

    ! Add one more RDT entry for the fall-through/default case
    IF .TRDT_CNT GEQ RDT_MAX
    THEN
	BEGIN
	ERR_( .KYW_LINE, SOR$_WKAREA );
	RETURN FAIL;
	END;
    TRDT[.TRDT_CNT, TRDT_CONDX] = FALSE;
!   TRDT[.TRDT_CNT, TRDT_TDT_IDX] = 0;
    TRDT[.TRDT_CNT, TRDT_KFT_IDX] = 0;	! ??? I think this is correct
    TRDT[.TRDT_CNT, TRDT_INCLUDE] = (IF .TRDT_CNT EQL 0 THEN TRUE
	ELSE NOT .TRDT[.TRDT_CNT-1, TRDT_INCLUDE]);
    TRDT_CNT = .TRDT_CNT + 1;

    ! Anchor address of record definition table to available work area
    ! Set the address/size of the record definition table in common area
    CA[CA_RDT_ADR] = ALLOC_(.TRDT_CNT * RDT_UNIT);
    CA[CA_RDT_SIZ] = .TRDT_CNT;

    ! Set up the record definition table
    BEGIN
    LOCAL
	RDT:	REF RDT_TAB[];	! Pointer to Record Defn Table
    RDT = .CA[CA_RDT_ADR];
    DECR IN FROM .TRDT_CNT-1 TO 0 DO
	BEGIN
	RDT[.IN, RDT_INCLUDE] =	.TRDT[.IN, TRDT_INCLUDE];
	RDT[.IN, RDT_CONDX] =	.TRDT[.IN, TRDT_CONDX];
	RDT[.IN, RDT_TDT_IDX] =	.TRDT[.IN, TRDT_TDT_IDX];
	RDT[.IN, RDT_KFT_IDX] =	.TRDT[.IN, TRDT_KFT_IDX];
	! What about key length and data length fields???++++
	END;
    END;

    ! Set the address/size of the constant field table in common area
    CA[CA_CFT_ADR] = ALLOC_(.CON_CNT * CFT_UNIT);
    CA[CA_CFT_SIZ] = .CON_CNT;
    IF .CON_CNT GEQ CFT_MAX THEN ERR_( 0, SOR$_WKAREA );

    ! Convert the constant symbol table into the constant field table
    IF CONV_CONSTANTS( .CA[CA_FDT_ADR], .CA[CA_CFT_ADR],
	CON_SYM[0,BASE_], .CON_CNT ) EQL FAIL
    THEN
	BEGIN
	ERR_( 0, SOR$_SPCIVS );		! Invalid specification
	RETURN FAIL;
	END;

    ! If we're at an odd boundary, allocate another byte
    !
    IF ALLOC_(0) THEN ALLOC_(1);

    ! Determine the lengths in bytes of the fields in the KFT table.
    !
    BEGIN
    BIND
	FDT = CA[CA_FDT_ADR]: REF FDT_TAB[],	! Field definition table
	CFT = CA[CA_CFT_ADR]: REF CFT_TAB[];	! Constant definition table
    LOCAL
	KFT1: REF KFT_TAB[],
	KFT2: REF KFT_TAB[],
	LEN;
    KFT1 = .CA[CA_KFT_ADR];
    KFT2 = .CA[CA_KFT_ADR];
    LEN = 0;
    DECR I FROM .CA[CA_KFT_SIZ]-1 TO 0 DO
	BEGIN
	LEN = MAXU(.LEN, KFT_UNITS_(KFT1));
	!
	! If this was the last key/data in the group, process the group
	!
	IF NOT .KFT1[0,KFT_CONDX]
	THEN
	    BEGIN
	    WHILE KFT2[0,BASE_] LEQA KFT1[0,BASE_] DO
		BEGIN
		KFT2[0,KFT_NDE_SIZ] = .LEN;
		!
		! ??? Check for compatibility
		!
		KFT2 = KFT2[1,BASE_];	! Advance KFT2
		END;
	    LEN = 0;			! Reinitialize for the next group
	    END;
	KFT1 = KFT1[1,BASE_];		! Advance KFT1
	END;
    END;

    END;				! Pass 5

    RETURN SUCCESS;
    END;

! ELUDOM
!
END
ELUDOM
MODULE ICT$IN	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SOR$$DECM:	CA_LINKAGE,	! Initialize for dec-multinational
	SOR$$EBCDIC:	CA_LINKAGE,	! Initialize for ebcdic
	COLL$BASE,			! Define the base collating sequence
	COLL$NEXT,			! Define the next character
	COLL$MODIFY,			! Make a modification
	COLL$FOLD,			! Fold lower case to upper case
	COLL$UPPER,			! Upper case comparison
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_CHAR_CLAUSE,		! Get character clauses of various kinds
	GET_SUB_SPEC;			! Get pointer and length of sub-specification

GLOBAL ROUTINE INIT_CS_TAB(
	SUB_SPEC: REF VECTOR[3],
	CD: REF VECTOR[2] ): CA_LINKAGE =
!++
! Functional Description:
!
!	Initialize the Primary Table and Secondary Table.
!
! Formal Parameters:
!
!	SUB_SPEC- The address of length/pointer/line defining the sequence
!	CD	- Length/address of the collating description work area
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	TEMP_SPC: VECTOR[3],	! Temporary to hold length/pointer
	DUMMY:	  VECTOR[3],
	CLAUSE_TYPE,
	CS_TYPE,	! Collating sequence type returned from get_kyw_type
	CH4:	VECTOR[4,BYTE];	! Characters returned from get_char_clause
    LOCAL
	KYW_LINE,
	CHAR1:	VECTOR[4,BYTE],
	S;

    ! Sets collating sequence type for sort-11 statistics 
    MACRO SET_STATS_( X ) =
    	%IF %BLISS(BLISS16)
    	%THEN
    	    CA[ COM_COL_SEQ_ ] = X - SOR$_STASCI
    	%FI %;

    CA_AREA_( CA );

    output_('init_cs_tab');

    CHAR1[0] = 1;
    CHAR1[1] = 0;

    ! Is there a sequence sub-clause?
    IF .SUB_SPEC[_LEN] EQL 0 THEN RETURN FAIL;

    ! Save pointer and length since get_sub_spec modifies its input
    !
    TEMP_SPC[_PTR] = .SUB_SPEC[_PTR];
    TEMP_SPC[_LEN] = .SUB_SPEC[_LEN];
    TEMP_SPC[_LINE] = .SUB_SPEC[_LINE];

    KYW_LINE = .SUB_SPEC[_LINE];

    ! Get the collating sequence type
    CS_TYPE = GET_SUB_SPEC( SUB_SPEC[0], DUMMY[0] );

    ! Ascii, ebcdic, dec-multinational, or user_defined
    SELECT .CS_TYPE OF
	SET

	[KW_ASC]:		! ASCII
	    BEGIN

	    ! Each character collates as its 8-bit character code
	    INCR I FROM %X'00' TO %X'FF' DO
		BEGIN
		CHAR1[2] = .I;
		S = COLL$NEXT(CD[0], CHAR1);
		IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);
		END;

    	    ! for sort-11 statistics, set collating sequence to ascii
    	    SET_STATS_( SOR$_STASCI );

	    END;

	[KW_EBC]:		! EBCDIC
	    BEGIN
	    S = SOR$$EBCDIC(CD[0]);
	    IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);

    	    ! for sort-11 statistics, set collating sequence to ebcdic
    	    SET_STATS_( SOR$_STEBCD );
	    END;

	[KW_DEC]:		! DEC_Multinational
	    BEGIN
	    S = SOR$$DECM(CD[0]);
	    IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);

    	    ! for sort-11 statistics, set collating sequence to multinational
    	    SET_STATS_( SOR$_STDECM );
	    END;

	[KW_UNKN]:		! User-defined base sequence
	    BEGIN

    	    ! for sort-11 statistics, set collating sequence to user-defined
    	    SET_STATS_( SOR$_STUSER );

	    ! Restore the length/address
	    SUB_SPEC[_PTR] = .TEMP_SPC[_PTR];
	    SUB_SPEC[_LEN] = .TEMP_SPC[_LEN];
	    SUB_SPEC[_LINE] = .TEMP_SPC[_LINE];

	    ! While there are more user-defined sequence sub-clauses
	    WHILE TRUE DO
		BEGIN

		! Get character clause
		CLAUSE_TYPE = GET_CHAR_CLAUSE( SUB_SPEC[0], CH4[0] );
		KYW_LINE = .SUB_SPEC[_LINE];

		SELECTONE .CLAUSE_TYPE OF
		    SET

		    [GC_SINGLE, GC_S_TO_S]:	! Single or range
			BEGIN

			! Define entries in primary table
			CHAR1[0] = 1;
			INCRU I FROM .CH4[0] TO .CH4[2] DO
			    BEGIN
			    CHAR1[2] = .I;
			    S = COLL$NEXT(CD[0], CHAR1);
			    IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);
			    END;

			END;

		    [GC_DOUBLE]:
			BEGIN
			CHAR1[0] = 2;
			CHAR1[2] = .CH4[0];
			CHAR1[3] = .CH4[1];
			S = COLL$NEXT(CD[0], CHAR1);
			IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);
			END;

		    [OTHERWISE]:		! Error condition
			RETURN FAIL;

		    TES;

		IF SKIP_COMMA( SUB_SPEC[0] ) EQL FAIL THEN EXITLOOP;
		END;

	    END;

	[OTHERWISE]:		! Misplaced keyword?
	    RETURN FAIL;

	TES;


    ! Was there extraneous matter?
    IF .SUB_SPEC[_LEN] NEQ 0 THEN RETURN FAIL;

    RETURN SUCCESS;
    END;

GLOBAL ROUTINE DO_FOLD(CD: REF VECTOR[2]): CA_LINKAGE NOVALUE =

!++
! Functional Description:
!
!	Fold the lower case characters onto the upper case.
!
! Formal Parameters:
!
!	CD	- Length/address of the collating description work area
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN
    LOCAL
	LOWER:	BITVECTOR[256],
	CHAR1:	VECTOR[4,BYTE],
	CHAR2:	VECTOR[4,BYTE],
	S;

    CA_AREA_( CA );

    output_('do_fold');

    CH$FILL(0, %ALLOCATION(LOWER), LOWER[0]);

    (LOWER[%X'60'])<0,16,0> = %X'FFFE';		! a - z
    (LOWER[%X'70'])<0,16,0> = %X'07FF';

    IF .CA[CA_BS_DECM]
    THEN
	BEGIN
	(LOWER[%X'E0'])<0,16,0> = %X'FFFF';	! a accent grave - y umlaut
	(LOWER[%X'F0'])<0,16,0> = %X'3FFE';
	END;

    S = COLL$FOLD(CD[0], LOWER[0], %X'20');
    IF_ERROR_( .S ) THEN (ERR_(0, .S); RETURN);

    RETURN;

    END;


! ELUDOM
!
END
ELUDOM
MODULE SDECM$	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
	COLL$NEXT,			! Collate char after all others
	COLL$BASE,			! Define the base collating sequence
	COLL$MODIFY,			! Make a modification
	COLL$UPPER;			! Upper case comparison

! Define the successful status returned by these routines
! It should aleady be defined for bliss16 and should equal 0
!
%IF NOT %DECLARED(SS$_NORMAL) %THEN LITERAL SS$_NORMAL = 1; %FI


    ! Collating sequence tables for EBCDIC and DEC_MULTINATIONAL
    !
    ! Note that EBC_TAB has 128 entries and that DEC_TAB has 256 entries.
    !
%IF %BLISS(BLISS32) %THEN

EXTERNAL
    LIB$AB_ASC_EBC: ADDRESSING_MODE(GENERAL);
BIND
    EBC_TAB = LIB$AB_ASC_EBC: VECTOR[,BYTE];

%ELSE

BIND
    EBC_TAB = UPLIT BYTE(
	%X'00',%X'01',%X'02',%X'03',%X'1D',%X'19',%X'1A',%X'1B',	! 00-07
	%X'0F',%X'04',%X'16',%X'06',%X'07',%X'08',%X'09',%X'0A',	! 08-0F
	%X'0B',%X'0C',%X'0D',%X'0E',%X'1E',%X'1F',%X'1C',%X'17',	! 10-17
	%X'10',%X'11',%X'20',%X'18',%X'12',%X'13',%X'14',%X'15',	! 18-1F
	%X'21',%X'27',%X'3D',%X'39',%X'2A',%X'33',%X'28',%X'3B',	! 20-27
	%X'25',%X'2C',%X'2B',%X'26',%X'32',%X'2F',%X'23',%X'30',	! 28-2F
	%X'76',%X'77',%X'78',%X'79',%X'7A',%X'7B',%X'7C',%X'7D',	! 30-37
	%X'7E',%X'7F',%X'38',%X'2D',%X'24',%X'3C',%X'35',%X'36',	! 38-3F
	%X'3A',%X'5A',%X'5B',%X'5C',%X'5D',%X'5E',%X'5F',%X'60',	! 40-47
	%X'61',%X'62',%X'64',%X'65',%X'66',%X'67',%X'68',%X'69',	! 48-4F
	%X'6A',%X'6B',%X'6C',%X'6E',%X'6F',%X'70',%X'71',%X'72',	! 50-57
	%X'73',%X'74',%X'75',%X'22',%X'6D',%X'29',%X'2E',%X'34',	! 58-5F
	%X'37',%X'3E',%X'3F',%X'40',%X'41',%X'42',%X'43',%X'44',	! 60-67
	%X'45',%X'46',%X'47',%X'48',%X'49',%X'4A',%X'4B',%X'4C',	! 68-6F
	%X'4D',%X'4E',%X'4F',%X'51',%X'52',%X'53',%X'54',%X'55',	! 70-77
	%X'56',%X'57',%X'58',%X'59',%X'31',%X'63',%X'50',%X'05'		! 78-7F
	): VECTOR[,BYTE];
%FI

BIND
    DEC_TAB = UPLIT BYTE(
	%X'01',%X'02',%X'03',%X'04',%X'05',%X'06',%X'07',%X'08',
	%X'09',%X'0A',%X'0B',%X'0C',%X'0D',%X'0E',%X'0F',%X'10',
	%X'11',%X'12',%X'13',%X'14',%X'15',%X'16',%X'17',%X'18',
	%X'19',%X'1A',%X'1B',%X'1C',%X'1D',%X'1E',%X'1F',%X'20',
	%X'21',%X'22',%X'23',%X'24',%X'25',%X'26',%X'27',%X'28',
	%X'29',%X'2A',%X'2B',%X'2C',%X'2D',%X'2E',%X'2F',%X'30',
	%X'31',%X'32',%X'33',%X'34',%X'35',%X'36',%X'37',%X'38',
	%X'39',%X'3A',%X'3B',%X'3C',%X'3D',%X'3E',%X'3F',%X'40',
	%X'41',%X'42',%X'43',%X'44',%X'45',%X'46',%X'47',%X'48',
	%X'49',%X'4A',%X'4B',%X'4C',%X'4D',%X'4E',%X'4F',%X'51',
	%X'52',%X'53',%X'54',%X'55',%X'56',%X'57',%X'58',%X'59',
	%X'5A',%X'5B',%X'5C',%X'60',%X'61',%X'62',%X'63',%X'64',
	%X'65',%X'42',%X'43',%X'44',%X'45',%X'46',%X'47',%X'48',
	%X'49',%X'4A',%X'4B',%X'4C',%X'4D',%X'4E',%X'4F',%X'51',
	%X'52',%X'53',%X'54',%X'55',%X'56',%X'57',%X'58',%X'59',
	%X'5A',%X'5B',%X'5C',%X'66',%X'67',%X'68',%X'69',%X'6A',
	%X'6B',%X'6C',%X'6D',%X'6E',%X'6F',%X'70',%X'71',%X'72',
	%X'73',%X'74',%X'75',%X'76',%X'77',%X'78',%X'79',%X'7A',
	%X'7B',%X'7C',%X'7D',%X'7E',%X'7F',%X'80',%X'81',%X'82',
	%X'83',%X'84',%X'85',%X'86',%X'87',%X'88',%X'89',%X'8A',
	%X'8B',%X'8C',%X'8D',%X'8E',%X'8F',%X'90',%X'91',%X'92',
	%X'93',%X'94',%X'95',%X'96',%X'97',%X'98',%X'99',%X'9A',
	%X'9B',%X'9C',%X'9D',%X'9E',%X'9F',%X'A0',%X'A1',%X'A2',
	%X'A3',%X'A4',%X'A5',%X'A6',%X'A7',%X'A8',%X'A9',%X'AA',
	%X'42',%X'42',%X'42',%X'42',%X'42',%X'5F',%X'5D',%X'44',
	%X'46',%X'46',%X'46',%X'46',%X'4A',%X'4A',%X'4A',%X'4A',
	%X'AB',%X'50',%X'51',%X'51',%X'51',%X'51',%X'51',%X'51',
	%X'5E',%X'57',%X'57',%X'57',%X'57',%X'5B',%X'AC',%X'55',
	%X'42',%X'42',%X'42',%X'42',%X'42',%X'5F',%X'5D',%X'44',
	%X'46',%X'46',%X'46',%X'46',%X'4A',%X'4A',%X'4A',%X'4A',
	%X'AD',%X'50',%X'51',%X'51',%X'51',%X'51',%X'51',%X'51',
	%X'5E',%X'57',%X'57',%X'57',%X'57',%X'5B',%X'AE',%X'AF')
	: VECTOR[,BYTE];
BIND
    DEC_UPP = PLIT BYTE(
	%X'00',%X'01',%X'02',%X'03',%X'04',%X'05',%X'06',%X'07',
	%X'08',%X'09',%X'0A',%X'0B',%X'0C',%X'0D',%X'0E',%X'0F',
	%X'10',%X'11',%X'12',%X'13',%X'14',%X'15',%X'16',%X'17',
	%X'18',%X'19',%X'1A',%X'1B',%X'1C',%X'1D',%X'1E',%X'1F',
	%X'20',%X'21',%X'22',%X'23',%X'24',%X'25',%X'26',%X'27',
	%X'28',%X'29',%X'2A',%X'2B',%X'2C',%X'2D',%X'2E',%X'2F',
	%X'30',%X'31',%X'32',%X'33',%X'34',%X'35',%X'36',%X'37',
	%X'38',%X'39',%X'3A',%X'3B',%X'3C',%X'3D',%X'3E',%X'3F',
	%X'40',%X'41',%X'47',%X'48',%X'4A',%X'4B',%X'50',%X'51',
	%X'52',%X'53',%X'58',%X'59',%X'5A',%X'5B',%X'5C',%X'5F',
	%X'65',%X'66',%X'67',%X'69',%X'6A',%X'6B',%X'70',%X'71',
	%X'72',%X'73',%X'75',%X'79',%X'7A',%X'7B',%X'7C',%X'7D',
	%X'7E',%X'41',%X'47',%X'48',%X'4A',%X'4B',%X'50',%X'51',
	%X'52',%X'53',%X'58',%X'59',%X'5A',%X'5B',%X'5C',%X'5F',
	%X'65',%X'66',%X'67',%X'69',%X'6A',%X'6B',%X'70',%X'71',
	%X'72',%X'73',%X'75',%X'7F',%X'80',%X'81',%X'82',%X'83',
	%X'84',%X'85',%X'86',%X'87',%X'88',%X'89',%X'8A',%X'8B',
	%X'8C',%X'8D',%X'8E',%X'8F',%X'90',%X'91',%X'92',%X'93',
	%X'94',%X'95',%X'96',%X'97',%X'98',%X'99',%X'9A',%X'9B',
	%X'9C',%X'9D',%X'9E',%X'9F',%X'A0',%X'A1',%X'A2',%X'A3',
	%X'A4',%X'A5',%X'A6',%X'A7',%X'A8',%X'A9',%X'AA',%X'AB',
	%X'AC',%X'AD',%X'AE',%X'AF',%X'B0',%X'B1',%X'B2',%X'B3',
	%X'B4',%X'B5',%X'B6',%X'B7',%X'B8',%X'B9',%X'BA',%X'BB',
	%X'BC',%X'BD',%X'BE',%X'BF',%X'C0',%X'C1',%X'C2',%X'C3',
	%X'42',%X'43',%X'44',%X'45',%X'46',%X'78',%X'76',%X'49',
	%X'4C',%X'4D',%X'4E',%X'4F',%X'54',%X'55',%X'56',%X'57',
	%X'C4',%X'5D',%X'60',%X'61',%X'62',%X'63',%X'64',%X'5E',
	%X'77',%X'6C',%X'6D',%X'6E',%X'6F',%X'74',%X'C5',%X'68',
	%X'42',%X'43',%X'44',%X'45',%X'46',%X'78',%X'76',%X'49',
	%X'4C',%X'4D',%X'4E',%X'4F',%X'54',%X'55',%X'56',%X'57',
	%X'C6',%X'5D',%X'60',%X'61',%X'62',%X'63',%X'64',%X'5E',
	%X'77',%X'6C',%X'6D',%X'6E',%X'6F',%X'74',%X'C7',%X'C8')
	: VECTOR[,BYTE];

GLOBAL ROUTINE SOR$$DECM(
	CD:	REF VECTOR[2]
	): CA_LINKAGE =

!++
!
! Functional Description:
!
!	Initializes a table for the dec multinational collating sequence.
!
! Formal Parameters:
!
!	CD	- Length/address of the collating description work area
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	0 on error.
!	1 for sucess.
!
! Side Effects:
!
!	None.
!
! Notes:
!
!	After the call to this routine, the following calls still should
!	be made: COLL$PAD, COLL$RESULT.
!
!--
    BEGIN
    LOCAL
	S;

    ! Get the impure area
    CA_AREA_( CA );

    output_('sor$$decm');

    S = COLL$BASE(CD[0], DEC_TAB[0]);
    IF_ERROR_( .S ) THEN RETURN .S;
    S = COLL$UPPER(CD[0], DEC_UPP[0]);
    IF_ERROR_( .S ) THEN RETURN .S;

    ! Small sharp s (DF), collates same as SS (53,53)
    ! OE dipthong (D7) collates same a OE (4F,45)
    !
    S = COLL$MODIFY(CD[0], UPLIT WORD(1,%X'DF'), UPLIT WORD(2,'SS'), 0);
    IF_ERROR_( .S ) THEN RETURN .S;
    S = COLL$MODIFY(CD[0], UPLIT WORD(1,%X'D7'), UPLIT WORD(2,'OE'), 0);
    IF_ERROR_( .S ) THEN RETURN .S;
    S = COLL$MODIFY(CD[0], UPLIT WORD(1,%X'F7'), UPLIT WORD(2,'OE'), 0);
    IF_ERROR_( .S ) THEN RETURN .S;

    CA[CA_TIE_BREAK] = TRUE;
    CA[CA_BS_DECM] = TRUE;

    RETURN SS$_NORMAL;

    END;

GLOBAL ROUTINE SOR$$EBCDIC( CD: REF VECTOR[2] ): CA_LINKAGE =

!++
!
! Functional Description:
!
!	Initializes a table for the ebcdic collating sequence.
!
! Formal Parameters:
!
!	CD	- Length/address of the collating description work area
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	0 on error.
!	1 for sucess.
!
! Side Effects:
!
!	None.
!
! Notes:
!
!	After the call to this routine, the following calls still should
!	be made: COLL$PAD, COLL$RESULT.
!
!--
    BEGIN

    LOCAL
	CHAR1:	VECTOR[ 4, BYTE ],
	CHAR2:	VECTOR[ 4, BYTE ],
	S;

    ! Get the impure area
    CA_AREA_( CA );

    output_('sor$$ebcdic');

    CHAR1[ 0 ] = 1;
    CHAR1[ 1 ] = 0;
    CHAR2[ 0 ] = 1;
    CHAR2[ 1 ] = 0;

    ! First half of the primary table
    S = COLL$BASE( CD[0], EBC_TAB[0] );
    IF_ERROR_( .S ) THEN RETURN .S;

    ! The second half collates the same as the SUB character (%X'1A')
    CHAR2[ 2 ] = %X'1A';

    INCR I FROM %X'80' TO %X'FF' DO
	BEGIN
	CHAR1[ 2 ] = .I;

	S = COLL$MODIFY( CD[0], CHAR1, CHAR2, 0);
	IF_ERROR_( .S ) THEN RETURN .S;

	END;

    CHAR1[2] = %X'FF';
    S = COLL$NEXT( CD[0], CHAR1 );
    IF_ERROR_( .S ) THEN RETURN .S;

    RETURN SS$_NORMAL;
    END;


! ELUDOM
!
END
ELUDOM
MODULE GFS$GE	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';

GLOBAL ROUTINE GET_FILE_SPEC( DESC: REF VECTOR[3], STRING: REF VECTOR[3] ) =

!++
! Functional Description:
!
!	Get the file specification in DESC.
!
! Formal Parameters:
!
!	DESC	- Address of length/address to search
!	STRING	- Address of stored length/address of string.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN
    LOCAL
	QUOTED,		! Are we in a quote
	BRAKET,		! Are we in brackets
	LENGTH;		! Length of the found string

    output_('get_file_spec');

    QUOTED = FALSE;
    BRAKET = FALSE;

    ! Initialize length
    LENGTH = 0;

    ! Set pointer to string
    STRING[_PTR] = .DESC[_PTR];
    STRING[_LINE] = .DESC[_LINE];

    ! Find the string
    WHILE TRUE DO
	BEGIN

	IF .DESC[_LEN] LEQ 0 THEN EXITLOOP;		! Out of input

	! Look at the next character
	SELECTONE CH$RCHAR(.DESC[_PTR]) OF
	    SET

	    [C_NULL,C_SPACE,C_TAB,C_EXCLAM,C_L_PAREN,C_R_PAREN,C_EQUAL]:
		IF NOT .QUOTED THEN EXITLOOP;	! Are we inside of a quote?

	    [C_COMMA]:
		IF NOT .QUOTED THEN
		IF NOT .BRAKET THEN EXITLOOP;	! Inside of [nnn,nnn]?

	    [C_LBRACK,C_LESS]:
		IF NOT .QUOTED
		THEN
		    BEGIN
		    IF .BRAKET THEN RETURN FAIL;
		    BRAKET = TRUE;
		    END;

	    [C_RBRACK,C_GREATER]:
		IF NOT .QUOTED
		THEN
		    BEGIN
		    IF NOT .BRAKET THEN RETURN FAIL;
		    BRAKET = FALSE;
		    END;

	    [C_QUOTE]:		! Character '"'
		QUOTED = NOT .QUOTED;

	    [OTHERWISE]:
		0;

	    TES;

	! Update the values
	DESC[_PTR] = .DESC[_PTR] + 1;
	DESC[_LEN] = .DESC[_LEN] - 1;

	LENGTH = .LENGTH + 1;

	END;

    IF .BRAKET OR .QUOTED THEN RETURN FAIL;

    IF (STRING[_LEN] = .LENGTH) EQL 0
    THEN
	RETURN FAIL
    ELSE
	RETURN SUCCESS;

    END;


! ELUDOM
!
END
ELUDOM
MODULE PC$PAR	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_SUB_SPEC,			! Get pointer and length of sub-specification
	INIT_CS_TAB:	CA_LINKAGE,	! Initialize primary table
	DO_FOLD:	CA_LINKAGE NOVALUE,	! Fold lower case characters to upper
	PARSE_MOD:	CA_LINKAGE,	! Parse a modification clause
	PARSE_IGN:	CA_LINKAGE;	! Parse an ignore clause
EXTERNAL ROUTINE
	COLL$INIT,			! Initialize collating sequence
	COLL$FOLD,			! Fold lower case to upper case
	COLL$TIE_BREAK,			! Indicate tie-breaking
	COLL$PAD,			! Indicate the pad character
	COLL$UPPER,			! Upper case comparison
	COLL$RESULT;			! Build the final tables

GLOBAL ROUTINE PARSE_COLL(
	DESC:	REF VECTOR[3] ): CA_LINKAGE =

!++
! Functional Description:
!
!	Parse the collating sequence specification.
!
! Formal Parameters:
!
!	DESC	Address of length/address of the text.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	SUCCESS/FAIL
!
! Side Effects:
!
!--
    BEGIN
    LOCAL
	COLL_DESC:	VECTOR[2],
	SUB_DESC:	VECTOR[3],
	PAD_CHAR:	VECTOR[4,BYTE],
	KYW_LINE,
	S;

    LOCAL
    	MODIFIED;

    ! Get the impure data area
    CA_AREA_( CA );

    output_('parse_coll');

    COLL_DESC[0] = .CA[CA_WRK_END]-.CA[CA_WRK_ADR];
    COLL_DESC[1] = ALLOC_(0);

    S = COLL$INIT(COLL_DESC[0]);
    IF_ERROR_( .S ) THEN (ERR_(.DESC[_LINE], .S); RETURN FAIL);

    KYW_LINE = .DESC[_LINE];

    ! The first clause must be SEQUENCE=...
    !
    IF	GET_SUB_SPEC( DESC[0], SUB_DESC[0] ) EQL KW_SEQU
    THEN
	BEGIN
	! Call routine to initialize collating tables
	IF INIT_CS_TAB( SUB_DESC[0], COLL_DESC[0] ) EQL FAIL
	THEN
	    BEGIN
	    ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
	    RETURN FAIL;
	    END;
	IF .SUB_DESC[_LEN] GTR 0
	THEN
	    BEGIN
	    ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
	    RETURN FAIL;
	    END;
	END
    ELSE
	BEGIN
	ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
	RETURN FAIL;
	END;


    ! While there are more collating sequence sub-qualifiers
    !
    WHILE SKIP_COMMA( DESC[0] ) NEQ FAIL DO
	BEGIN

	KYW_LINE = .DESC[_LINE];

	MODIFIED = FALSE;

	SELECTONE GET_SUB_SPEC( DESC[0], SUB_DESC[0] ) OF
	    SET

	    [KW_MODF]:
		BEGIN
		! Call routine to modify collating sequence tables
		IF PARSE_MOD( SUB_DESC[0], COLL_DESC[0] ) EQL FAIL
		THEN
		    BEGIN
		    ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
		    RETURN FAIL;
		    END;

		MODIFIED = TRUE;

		END;

	    [KW_IGNO]:		! Specify ignored characters
		BEGIN
		! Call routine to parse the ignore clause
		IF PARSE_IGN( SUB_DESC[0], COLL_DESC[0] ) EQL FAIL
		THEN
		    BEGIN
		    ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
		    RETURN FAIL;
		    END;

		MODIFIED = TRUE;

		END;

	    [KW_FOLD]:
    		BEGIN

		! Perform the folding when found
		! Note that if modifications are made to a dec_multi
		! Sequence, folding may have to be done after mods
		DO_FOLD(COLL_DESC[0]);

		MODIFIED = TRUE;

    		END;

	    [KW_TIEB]:		! Tie-breaking
    		BEGIN

		CA[CA_TIE_BREAK] = TRUE;

		MODIFIED = TRUE;

    		END;

	    [KW_NOTI]:		! No tie_breaking
    		BEGIN

		CA[CA_TIE_BREAK] = FALSE;

		MODIFIED = TRUE;

    		END;

	    [OTHERWISE]:		! Bad collate sub-specification
		BEGIN
		ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
		RETURN FAIL;
		END;

	    TES;

	IF .SUB_DESC[_LEN] GTR 0
	THEN
	    BEGIN
	    ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
	    RETURN FAIL;
	    END;

	END;

    %IF %BLISS(BLISS16) %THEN
    IF .MODIFIED EQL ON
    THEN
	CA[ COM_COL_SEQ_ ] = .CA[ COM_COL_SEQ_ ] + 4;
    %FI

    IF .DESC[_LEN] GTR 0
    THEN
	BEGIN
	ERR_( .KYW_LINE, SOR$_SPCIVC );	! Invalid collating sequence
	RETURN FAIL;
	END;

    IF .CA[CA_TIE_BREAK]
    THEN
	BEGIN
	!
	! Indicate tie-breaking.
	! ALWAYS reverse the sense of the CMPC comparison.
	!
!	S = COLL$TIE_BREAK(COLL_DESC[0], .CA[CA_BS_DECM]);
	S = COLL$TIE_BREAK(COLL_DESC[0], TRUE);
	END
    ELSE
	BEGIN
	!
	! Don't use the upper table if there is no tie-breaking.
	! Currently, this is only needed if CA_BS_DECM is set.
	!
	S = COLL$UPPER(COLL_DESC[0], 0);
	END;
    IF_ERROR_( .S ) THEN RETURN (ERR_(.DESC[_LINE], .S); RETURN FAIL);


    PAD_CHAR[0] = 1;
    PAD_CHAR[1] = 0;
    PAD_CHAR[2] = .CA[CA_PAD];
    S = COLL$PAD(COLL_DESC[0], PAD_CHAR);
    IF_ERROR_( .S ) THEN RETURN (ERR_(.DESC[_LINE], .S); RETURN FAIL);

    S = COLL$RESULT(COLL_DESC[0], COLL_DESC[0]);
    IF_ERROR_( .S ) THEN RETURN (ERR_(.DESC[_LINE], .S); RETURN FAIL);

    ! Store the address and length in the common area
    !
    CA[CA_ST_SIZ] = .COLL_DESC[0];
    CA[CA_ST_ADR] = ALLOC_(.COLL_DESC[0]);

    RETURN SUCCESS;
    END;


! ELUDOM
!
END
ELUDOM
MODULE PK$PAR	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_KYW_TYPE,			! Get keyword type
	GET_STRING,			! Find string and move around it
	SEARCH_TABLE;			! Search a table for a string

ROUTINE PRESUMED_LENGTH( X: REF VECTOR[3], LEN: REF VECTOR[1] ) =
    BEGIN
    SELECTONE CH$RCHAR(.X[_PTR]) OF
	SET
	[C_QUOTE]:		! String length - 1/2 imbedded quotes
	    BEGIN
	    LOCAL Q;
	    LEN[0] = .X[_LEN] - 2;
	    Q = 0;
	    DECR I FROM .LEN[0] TO 1 DO
		IF CH$RCHAR(.X[_PTR] + .I) EQL C_QUOTE THEN Q = .Q + 1;
	    LEN[0] = .LEN[0] - .Q ^ -1;
	    END;
	[C_PERCENT]:		LEN[0] = 1;
	[%C'0' TO %C'9']:	LEN[0] = 1;
	[OTHERWISE]:		RETURN FAIL;
	TES;

    RETURN SUCCESS
    END;

GLOBAL ROUTINE PARSE_KEY(
	KEY:	REF VECTOR[3],
	IS_DATA,
	CON_SYM:REF CON_SYM_TAB[],
	CON_CNT:REF VECTOR[1],
	FLD_SYM:REF SYM_TAB[],
	CDX_SYM:REF SYM_TAB[],
	CDX_CNT:REF VECTOR[1] ): CA_LINKAGE =

!++
! Functional Description:
!
!	Parse a key or data clause
!
! Formal Parameters:
!
!	KEY	- Address of the length/address/line of the key clause.
!	IS_DATA	- True iff a DATA clause is being parsed
!	CON_SYM	- Address of constant symbol table.
!	CON_CNT	- Address containing number of entries already in table.
!	FLD_SYM	- Address of field symbol table.
!	CDX_SYM	- Address of field symbol table.
!	CDX_CNT	- Address of number of entries in table.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
! Notes:
!	The syntax parsed by this routine is:
!
!	s=else
!	{
!	    [
!		IF cond THEN
!		s=if
!	    ]
!	    field
!	    if s=else then exitloop
!	    [
!		ELSE
!		s=else
!	    ]
!	}...
!
!--
    BEGIN

    LOCAL
	INDEX,
	LENGTH,			! Max length conditional key/data
	SAVE_COUNT,		! Save the number entries in constant table
	FIRST_IDX,		! KFT index of first entry for this key
	STATE,			! State variable
	DESCEND,		! Direction is descending
	LOC_KEY: VECTOR[3],	! Local length/address into key clause
	TEMP_KEY:VECTOR[3],	! Temporary length/address into key clause
	KYW_TYPE;		! Keyword type
    LOCAL
	KFT: REF KFT_TAB[];

    CA_AREA_( CA );

    output_('parse_key');

    ! Remember the starting count
    SAVE_COUNT = .CON_CNT[0];
    LENGTH = 0;

    ! Default to ascending (not descending)
    DESCEND = FALSE;

    ! Set the index of the first KFT entry we will allocate
    FIRST_IDX = .CA[CA_KFT_SIZ];

    ! Act (pretty much) like we've just seen an ELSE
    !
    STATE = KW_ELSE;

    ! Get what may be a field name
    IF SKIP_IGNORED( KEY[0] ) EQL FAIL THEN RETURN FAIL;
    IF GET_STRING( KEY[0], LOC_KEY[0] ) EQL FAIL THEN RETURN FAIL;

    ! While there are more key sub-clauses
    WHILE TRUE DO
	BEGIN

	! Allocate a KFT entry
	KFT = ALLOC_(KFT_UNIT);
	IF .CA[CA_KFT_SIZ] GEQ KFT_MAX THEN ERR_(0, SOR$_WKAREA);
	CA[CA_KFT_SIZ] = .CA[CA_KFT_SIZ] + 1;

	! Initialize the key/data field table entry
	!
	KFT[0, KFT_DATA] = .IS_DATA;
	KFT[0, KFT_BUILD] = TRUE;
	KFT[0, KFT_CONTINUE] = TRUE;
	KFT[0, KFT_CONT_CDX] = TRUE;
	KFT[0, KFT_NDE_POS] = 0;	! needed?
	KFT[0, KFT_FDT_IDX] = 0;	! needed?
	KFT[0, KFT_TDT_IDX] = 0;	! needed?
	KFT[0, KFT_CONSTANT] = FALSE;
	KFT[0, KFT_CONDX] = FALSE;
	KFT[0, KFT_DESCEND] = FALSE;

	! Try scanning "IF cond THEN"
	!
	TEMP_KEY[_PTR] = .LOC_KEY[_PTR];
	TEMP_KEY[_LEN] = .LOC_KEY[_LEN];
	TEMP_KEY[_LINE] = .LOC_KEY[_LINE];
	KYW_TYPE = GET_KYW_TYPE( TEMP_KEY[0] );
	IF .KYW_TYPE EQL KW_IF
	THEN
	    BEGIN

	    ! This is a conditional key
	    KFT[0, KFT_CONDX] = TRUE;

	    ! Get name of condition
	    IF SKIP_IGNORED( KEY[0] ) EQL FAIL THEN RETURN FAIL;
	    IF GET_STRING( KEY[0], LOC_KEY[0] ) EQL FAIL THEN RETURN FAIL;

	    ! Search condition symbol table for name
	    IF SEARCH_TABLE( LOC_KEY[0],
		   INDEX, CDX_SYM[0,BASE_], .CDX_CNT[0] ) EQL FAIL
	    THEN
		RETURN FAIL;

	    ! Put the TDT index in the key field table
	    KFT[0, KFT_TDT_IDX] = .CDX_SYM[.INDEX, SYM_INDEX];

	    ! Get the keyword type
	    IF SKIP_IGNORED( KEY[0] ) EQL FAIL THEN RETURN FAIL;
	    KYW_TYPE = GET_KYW_TYPE( KEY[0] );

	    ! If keyword is not "then"
	    IF .KYW_TYPE NEQ KW_THEN THEN RETURN FAIL;

	    ! Get the field name or constant
	    IF SKIP_IGNORED( KEY[0] ) EQL FAIL THEN RETURN FAIL;
	    IF GET_STRING( KEY[0], LOC_KEY[0] ) EQL FAIL THEN RETURN FAIL;

	    STATE = KW_IF;
	    END;

	! Search the field symbol table for field name
	!
	IF SEARCH_TABLE( LOC_KEY[0],
		INDEX, FLD_SYM[0,BASE_], .CA[CA_FDT_SIZ] ) EQL SUCCESS
	THEN
	    BEGIN
	    !
	    ! Put the index in the key field table
	    !
	    KFT[0, KFT_FDT_IDX] = .FLD_SYM[.INDEX, SYM_INDEX];
	    END
	ELSE
	    BEGIN
	    !
	    ! It had better be a constant
	    !
	    ! Put the constant symbol table index in the FDT index
	    ! Field of the key field table, this will be the
	    ! Same as index into constant field table
	    KFT[0, KFT_FDT_IDX] = .CON_CNT[0];
	    KFT[0, KFT_CONSTANT] = TRUE;

	    ! Make entry in constant table
	    CON_SYM[.CON_CNT[0], CON_NAM_ADR] = .LOC_KEY[_PTR];
	    CON_SYM[.CON_CNT[0], CON_NAM_LEN] = .LOC_KEY[_LEN];
	    CON_CNT[0] = .CON_CNT[0] + 1;

	    ! Determine the presumed length of the constant.
	    ! Note that the actual length depends on other key/data fields.
	    !	String constants:	Length of the string
	    !	Radix constants:	1
	    !	Decimal constants:	1
	    !
	    BEGIN
	    LOCAL L;
	    IF PRESUMED_LENGTH( LOC_KEY[0], L ) EQL FAIL THEN RETURN FAIL;
	    LENGTH = MAXU( .LENGTH, .L );
	    END;

	    END;

	! If we were working on the final "ELSE" clause, then exit the loop
	!
	IF .STATE EQL KW_ELSE THEN EXITLOOP;

	! Get the next word (ELSE or IF or nothing)
	!
	SKIP_IGNORED( KEY[0] );
	GET_STRING( KEY[0], LOC_KEY[0] );

	! Try scanning "ELSE"
	!
	TEMP_KEY[_PTR] = .LOC_KEY[_PTR];
	TEMP_KEY[_LEN] = .LOC_KEY[_LEN];
	TEMP_KEY[_LINE] = .LOC_KEY[_LINE];
	KYW_TYPE = GET_KYW_TYPE( TEMP_KEY[0] );
	IF .KYW_TYPE EQL KW_ELSE
	THEN
	    BEGIN
	    !
	    ! Get the next word
	    !
	    STATE = KW_ELSE;
	    IF SKIP_IGNORED( KEY[0] ) EQL FAIL THEN RETURN FAIL;
	    IF GET_STRING( KEY[0], LOC_KEY[0] ) EQL FAIL THEN RETURN FAIL;
	    END;

	END;

    ! Check for a comma, which must be followed by "ASCENDING" or "DESCENDING"
    !
    IF SKIP_COMMA( KEY[0] ) NEQ FAIL
    THEN
	BEGIN
	IF GET_STRING( KEY[0], LOC_KEY[0] ) EQL FAIL THEN RETURN FAIL;
	SELECTONE GET_KYW_TYPE( LOC_KEY[0] ) OF
	    SET
	    [KW_ASCE]:	DESCEND = FALSE;
	    [KW_DESC]:	DESCEND = TRUE;
	    [OTHERWISE]: RETURN FAIL;
	    TES;
	END;

    ! There had better not be anything else
    !
    IF SKIP_IGNORED( KEY[0] ) NEQ FAIL THEN RETURN FAIL;

    ! Set the last entry's continued condition bit off
    KFT[0, KFT_CONT_CDX] = FALSE;

    ! Set the result length for all entries made in constant table
    ! On this call.  This will be used for creating constant field table
    ! ??? This does not correctly account for mixing fields and constants.
    !
    INCR IN FROM .SAVE_COUNT TO .CON_CNT[0]-1 DO
	BEGIN
	CON_SYM[.IN, CON_LENGTH] = .LENGTH;
	CON_SYM[.IN, CON_INDEX] = 0;
	END;

    ! Propagate the descending bit
    KFT = .CA[CA_KFT_ADR];
    KFT = KFT[.FIRST_IDX, BASE_];
    DECR IN FROM .CA[CA_KFT_SIZ]-.FIRST_IDX-1 TO 0 DO
	BEGIN
	KFT[0, KFT_DESCEND] = .DESCEND;
	KFT = KFT[1, BASE_];
	END;

    RETURN SUCCESS

    END;


! ELUDOM
!
END
ELUDOM
MODULE PT$PAR	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE,	! Allocate storage from the work area
	SKIP_IGNORED,			! Skip ignored text characters
	GET_KYW_TYPE,			! Get keyword type
	GET_STRING,			! Find string and move around it
	SEARCH_TABLE;			! Search a table for a string

GLOBAL ROUTINE PARSE_TEST(
	TST:	REF VECTOR[3],
	CON_SYM:REF CON_SYM_TAB[],
	CON_CNT:REF VECTOR[1],
	FLD_SYM:REF SYM_TAB[] ): CA_LINKAGE =

!++
! Functional Description:
!
!	Parse a test clause
!
! Formal Parameters:
!
!	TST	- Address of length/address/line of the test clause.
!	CON_SYM - Address of constant symbol table.
!	CON_CNT - Address containing number of entries already in table.
!	FLD_SYM - Address of field symbol table.
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
! Notes:
!
!	A "global" area is initialized so that the recursive subroutines can
!	access the various parameters they need.
!	The GET_xxx routines parse the condition and produce TDT table entries,
!	and a postfix representation of the condition (in S2).
!	Finally, CEVAL is called to process the postfix expression (from right
!	to left), adjusting the TDT_GOTOs and (possibly) negating the tests.
!	See the comments in SRTSPC.REQ that describe how the TDT table is used.
!--
    BEGIN

    MACRO
	LB_DECL = EXTERNAL REGISTER LB: REF VECTOR %;

    FORWARD ROUTINE
	GET_EXPR:	CA_LINKAGE_LB,	! Parse an expression
	GET_SIMPLE:	CA_LINKAGE_LB;	! Parse a simple condition

    MACRO
	STACK2(X) =
	    BEGIN
	    S2[.S2I] = X;
	    S2I = .S2I + 1;
	    IF .S2I GEQ S2_MAX THEN RETURN FAIL;
	    END %,
	S1I = CA[CA_TDT_SIZ] %,
	S2(X) = (LB[K_S2]+X)<0,8,0> %,
	S2I = LB[K_S2I] %;

    LITERAL
	S2_MAX = 30,	! Bound on max complexity of a test
	OP_AND = 0,	! AND operator
	OP_OR  = 1,	! OR operator
	OP_NEG = 2,	! NOT operator
	OP_SYM = 3,	! Simple condition
	K_TST     = 0,
	K_S2I     = 1,
	K_CON_SYM = 2,
	K_CON_CNT = 3,
	K_FLD_SYM = 4,
	K_S2      = 5;

    ROUTINE GET_KYW_TYPE_NM( KW ): CA_LINKAGE_LB =
	BEGIN
	LOCAL
	    TST: REF VECTOR[3],
	    SKEY: VECTOR[3];
	LB_DECL;
	CA_AREA_( CA );
	TST = .LB[K_TST];
	SKEY[0] = .TST[0];
	SKEY[1] = .TST[1];
	SKEY[2] = .TST[2];
	IF SKIP_IGNORED( TST[0] ) EQL FAIL THEN RETURN FAIL;
	IF GET_KYW_TYPE( TST[0] ) NEQ .KW
	THEN
	    BEGIN
	    TST[0] = .SKEY[0];
	    TST[1] = .SKEY[1];
	    TST[2] = .SKEY[2];
	    RETURN FAIL;
	    END
	ELSE
	    RETURN SUCCESS;
	END;

    ROUTINE GET_FACT: CA_LINKAGE_LB =
	BEGIN
	LOCAL
	    TST: REF VECTOR[3];
	LB_DECL;
	CA_AREA_( CA );
	TST = .LB[K_TST];
	IF SKIP_IGNORED( TST[0] ) EQL FAIL THEN RETURN FAIL;
	IF CH$RCHAR(.TST[_PTR]) EQL C_L_PAREN
	THEN
	    BEGIN
	    TST[_LEN] = .TST[_LEN] - 1;
	    TST[_PTR] = .TST[_PTR] + 1;
	    IF NOT GET_EXPR() THEN RETURN FAIL;
	    IF SKIP_IGNORED(TST[0]) EQL FAIL THEN RETURN FAIL;
	    IF CH$RCHAR(.TST[_PTR]) NEQ C_R_PAREN THEN RETURN FAIL;
	    TST[_LEN] = .TST[_LEN] - 1;
	    TST[_PTR] = .TST[_PTR] + 1;
	    END
	%IF %DECLARED(KW_NOT) %THEN
	ELSE IF GET_KYW_TYPE_NM( KW_NOT );
	THEN
	    BEGIN
	    IF NOT GET_FACT() THEN RETURN FAIL;
	    STACK2(OP_NOT);
	    END
	%FI
	ELSE
	    BEGIN
	    IF NOT GET_SIMPLE() THEN RETURN FAIL;
	    STACK2(OP_SYM);
	    END;
	RETURN SUCCESS;
	END;

    ROUTINE GET_TERM: CA_LINKAGE_LB =
	BEGIN
	LB_DECL;
	CA_AREA_( CA );
	IF NOT GET_FACT() THEN RETURN FAIL;
	WHILE GET_KYW_TYPE_NM( KW_AND ) DO
	    BEGIN
	    IF NOT GET_FACT() THEN RETURN FAIL;
	    STACK2(OP_AND);
	    END;
	RETURN SUCCESS;
	END;

    ROUTINE GET_EXPR: CA_LINKAGE_LB =
	BEGIN
	LB_DECL;
	CA_AREA_( CA );
	IF NOT GET_TERM() THEN RETURN FAIL;
	WHILE GET_KYW_TYPE_NM( KW_OR ) DO
	    BEGIN
	    IF NOT GET_TERM() THEN RETURN FAIL;
	    STACK2(OP_OR);
	    END;
	RETURN SUCCESS;
	END;

    ROUTINE CEVAL(TLAB, FLAB): CA_LINKAGE_LB =
	BEGIN
	LOCAL
	    SOP;	! Saved operator
	MACRO
	    M0(X) = (IF X GTR 0 THEN X ELSE 0) %;
	LB_DECL;
	CA_AREA_( CA );
	S2I = .S2I - 1;
	SOP = .S2[.S2I];
	IF .SOP EQL OP_AND OR .SOP EQL OP_OR
	THEN
	    BEGIN
	    CEVAL(.TLAB, .FLAB);
	    IF .SOP EQL OP_OR
		THEN CEVAL(.TLAB, .S1I)
		ELSE CEVAL(.S1I, .FLAB);
	    END
	%IF %DECLARED(OP_NOT) %THEN
	ELSE IF .SOP EQL OP_NEG
	THEN
	    THEN CEVAL(.FLAB, .TLAB)
	%FI
	ELSE
	    BEGIN
	    LOCAL
		TDT: REF TDT_TAB[];
	    TDT = .CA[CA_TDT_ADR];

	    S1I = .S1I - 1;
	    IF .TLAB EQL .S1I+1
	    THEN
		BEGIN
		TDT[.S1I, TDT_CMP] = NOT .TDT[.S1I, TDT_CMP];
		TDT[.S1I, TDT_GOTO] = M0(.FLAB-.S1I);
		END
	    ELSE IF .FLAB EQL .S1I+1
	    THEN
		TDT[.S1I, TDT_GOTO] = M0(.TLAB-.S1I)
	    ELSE
		RETURN FAIL;
	    END;
	RETURN SUCCESS;
	END;

    ROUTINE GET_SIMPLE: CA_LINKAGE_LB =
	BEGIN
	LOCAL
	    TST: REF VECTOR[3],
	    TDT: REF TDT_TAB[1],
	    INDEX1,
	    INDEX2,
	    SUB_KYW_TYPE,
	    CON_SYM: REF CON_SYM_TAB[],
	    CON_CNT: REF VECTOR[1],
	    FLD_SYM: REF SYM_TAB[],
	    STRING: VECTOR[3];
	LB_DECL;
	CA_AREA_( CA );

	TST	= .LB[K_TST];
	CON_SYM = .LB[K_CON_SYM];
	CON_CNT = .LB[K_CON_CNT];
	FLD_SYM = .LB[K_FLD_SYM];

	TDT = ALLOC_(TDT_UNIT);
	CA[CA_TDT_SIZ] = .CA[CA_TDT_SIZ] + 1;
	IF .CA[CA_TDT_SIZ] GEQ TDT_MAX THEN RETURN FAIL;

	! Get field name
	IF SKIP_IGNORED( TST[0] ) EQL FAIL THEN RETURN FAIL;
	IF GET_STRING( TST[0], STRING[0] ) EQL FAIL THEN RETURN FAIL;

	! Search the field symbol table for a match
	IF SEARCH_TABLE( STRING[0], INDEX1,
		FLD_SYM[0,BASE_], .CA[CA_FDT_SIZ] ) EQL FAIL
	THEN
	    RETURN FAIL;		! Error if not found

	! Set field one index
	TDT[0, TDT_FLD_ONE] = .FLD_SYM[.INDEX1, SYM_INDEX];

	! Clear the comparison flags, and the TRUE flag
	TDT[0, TDT_EQL] = FALSE;
	TDT[0, TDT_LSS] = FALSE;
	TDT[0, TDT_GTR] = FALSE;
	TDT[0, TDT_TRUE] = FALSE;

	! Get and parse the operator keyword
	IF SKIP_IGNORED( TST[0] ) EQL FAIL THEN RETURN FAIL;
	SUB_KYW_TYPE = GET_KYW_TYPE( TST[0] );
	SELECT .SUB_KYW_TYPE OF
	    SET
	    [KW_EQ, KW_LE, KW_GE]:	TDT[0, TDT_EQL] = TRUE;
	    [KW_LT, KW_LE, KW_NE]:	TDT[0, TDT_LSS] = TRUE;
	    [KW_GT, KW_GE, KW_NE]:	TDT[0, TDT_GTR] = TRUE;
	    [OTHERWISE]:		RETURN FAIL;
	    TES;

	! Get the constant or second field
	IF SKIP_IGNORED( TST[0] ) EQL FAIL THEN RETURN FAIL;
	IF GET_STRING( TST[0], STRING[0] ) EQL FAIL THEN RETURN FAIL;

	! Search the field symbol table for a match
	!
	IF SEARCH_TABLE( STRING[0], INDEX2,
		FLD_SYM[0,BASE_], .CA[CA_FDT_SIZ] ) EQL SUCCESS
	THEN
	    BEGIN
	    !
	    ! We have a field (not a constant)
	    !
	    ! Indicate it is not a constant, and store the field two index
	    !
	    TDT[0, TDT_CONSTANT] = FALSE;
	    TDT[0, TDT_FLD_TWO] = .FLD_SYM[.INDEX2, SYM_INDEX];
	    END
	ELSE
	    BEGIN
	    !
	    ! We have a constant.  Make an entry in the constant symbol table
	    !
	    IF .CON_CNT[0] GEQ MAX_CONST THEN RETURN FAIL;	! too many?

	    ! Put index to constant table in TDT, and mark as a constant
	    !
	    TDT[0, TDT_FLD_TWO] = .CON_CNT[0];
	    TDT[0, TDT_CONSTANT] = TRUE;

	    ! Initialize the constant table entry
	    !
	    ! Store the length and address of the constant
	    ! Store the field one index.  This indicates a related field,
	    ! and lets us know how to convert this thing later.
	    ! Zero the length field.
	    !
	    CON_SYM[.CON_CNT[0], CON_NAM_LEN] = .STRING[_LEN];
	    CON_SYM[.CON_CNT[0], CON_NAM_ADR] = .STRING[_PTR];
	    CON_SYM[.CON_CNT[0], CON_INDEX] = .FLD_SYM[.INDEX1, SYM_INDEX];
	    CON_SYM[.CON_CNT[0], CON_LENGTH] = 0;
	    CON_CNT[0] = .CON_CNT[0] + 1;

	    END;
	RETURN SUCCESS;
	END;

    LOCAL
	S1S,			! Saved value of S1I
	LBLOCK:	VECTOR[K_S2+S2_MAX+1];

    GLOBAL REGISTER LB = LB_REG: REF VECTOR;

    CA_AREA_( CA );

    output_('parse_test');

    LB = LBLOCK[0];
    LB[K_S2I]     = 0;
    LB[K_TST]     = TST[0];
    LB[K_CON_SYM] = CON_SYM[0, BASE_];
    LB[K_CON_CNT] = CON_CNT[0];
    LB[K_FLD_SYM] = FLD_SYM[0, BASE_];

    IF NOT GET_EXPR() THEN RETURN FAIL;
    IF SKIP_IGNORED(TST[0]) NEQ FAIL THEN RETURN FAIL;

    S1S = .S1I;
    IF NOT CEVAL(.S1I, 0) THEN RETURN FAIL;
    S1I = .S1S;

    ! Create one more entry that has the TRUE bit set
    !
    BEGIN
    LOCAL
	TDT: REF TDT_TAB[1];
    TDT = ALLOC_(TDT_UNIT);
    CA[CA_TDT_SIZ] = .CA[CA_TDT_SIZ] + 1;
    IF .CA[CA_TDT_SIZ] GEQ TDT_MAX THEN RETURN FAIL;
    TDT[0, TDT_TRUE] = TRUE;
    END;

    RETURN SUCCESS
    END;


! ELUDOM
!
END
ELUDOM
MODULE PI$PAR	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	COLL$MODIFY,			! Make a modification
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_CHAR_CLAUSE;		! Get character clauses of various kinds

GLOBAL ROUTINE PARSE_IGN(
	IGN:	REF VECTOR[3],
	CD:	REF VECTOR[2] ): CA_LINKAGE =

!++
! Functional Description:
!
!	Parse an ignore clause
!
! Formal Parameters:
!
!	IGN	- Address of length/address/line of the ignore clause.
!	CD	- Length/address of the collating description work area
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	CH4:	VECTOR[4,BYTE],	! Characters returned from get_char_clause
	INDEX,
	CLAUSE_TYPE;
    LOCAL
	KYW_LINE,
	CHAR1:	VECTOR[4,BYTE],
	CHAR2:	VECTOR[4,BYTE],
	S;

    CA_AREA_( CA );

    output_('parse_ign');

    KYW_LINE = 0;

    CHAR1[0] = 0;
    CHAR1[1] = 0;
    CHAR2[0] = 0;
    CHAR2[1] = 0;

    ! While there are more ignore sub-clauses
    WHILE TRUE DO
	BEGIN

	! Get character clause
	CLAUSE_TYPE = GET_CHAR_CLAUSE( IGN[0], CH4[0] );

	SELECTONE .CLAUSE_TYPE OF
	    SET

	    [GC_SINGLE, GC_S_TO_S]:	! Single or range
		BEGIN
		CHAR1[0] = 1;
		INCRU I FROM .CH4[0] TO .CH4[2] DO
		    BEGIN
		    CHAR1[2] = .I;
		    S = COLL$MODIFY(CD[0], CHAR1, CHAR2, 0);
		    IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);
		    END;
		END;

	    [GC_DOUBLE]:
		BEGIN
		CHAR1[0] = 2;
		CHAR1[2] = .CH4[0];
		CHAR1[3] = .CH4[1];
		S = COLL$MODIFY(CD[0], CHAR1, CHAR2, 0);
		IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);
		END;

	    [OTHERWISE]:		! Error condition
		RETURN FAIL;

	    TES;

	IF SKIP_COMMA( IGN[0] ) EQL FAIL THEN EXITLOOP;
	END;

    RETURN SUCCESS

    END;


! ELUDOM
!
END
ELUDOM
MODULE PM$PAR	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	COLL$MODIFY,			! Make a modification
	SKIP_COMMA,			! Skip commas and ignored stuff
	GET_CHAR_CLAUSE;		! Get character clauses of various kinds

GLOBAL ROUTINE PARSE_MOD(
	MODI:	REF VECTOR[3],
	CD:	REF VECTOR[2] ): CA_LINKAGE =

!++
! Functional Description:
!
!	Parse a modification clause
!
! Formal Parameters:
!
!	MODI	- Address of length/address/line of the modification clause.
!	CD	- Length/address of the collating description work area
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
!--
    BEGIN

    LOCAL
	CH4:	VECTOR[4,BYTE],	! Characters returned from get_char_clause
	CLAUSE_TYPE;
    LOCAL
	KYW_LINE,
	CHAR1:	VECTOR[4,BYTE],
	CHAR2:	VECTOR[4,BYTE],
	S;

    CA_AREA_( CA );

    output_('parse_mod');

    KYW_LINE = 0;

    CHAR1[1] = 0;
    CHAR2[1] = 0;

    ! While there are more modification sub-clauses
    WHILE TRUE DO
	BEGIN

	! Find type of modification
	CLAUSE_TYPE = GET_CHAR_CLAUSE( MODI[0], CH4[0] );

	SELECTONE .CLAUSE_TYPE OF
	    SET
	    [FAIL, GC_SINGLE, GC_DOUBLE, GC_S_TO_S]: RETURN FAIL;
	    [OTHERWISE]: 0;
	    TES;

	CHAR1[0] = GC_L1_(.CLAUSE_TYPE);
	CHAR1[2] = .CH4[0];
	CHAR1[3] = .CH4[1];
	CHAR2[0] = GC_L2_(.CLAUSE_TYPE);
	CHAR2[2] = .CH4[2];
	CHAR2[3] = .CH4[3];

	S = COLL$MODIFY(CD[0], CHAR1, CHAR2, GC_OP_(.CLAUSE_TYPE));
	IF_ERROR_( .S ) THEN (ERR_(.KYW_LINE, .S); RETURN FAIL);

	IF SKIP_COMMA( MODI[0] ) EQL FAIL THEN EXITLOOP;
	END;

    RETURN SUCCESS;
    END;


! ELUDOM
!
END
ELUDOM
MODULE CC$CON	(IDENT = 'T03-038' %REQUIRE('SRC$:DEFS0') ) =
BEGIN
REQUIRE 'SRC$:DKS';
EXTERNAL ROUTINE
        ERR_CNTL:	CA_LINKAGE, 	! Error control routine
	SPC_ALLOC:	CA_LINKAGE;	! Allocate storage from the work area

GLOBAL ROUTINE CONV_CONSTANTS(
	FDT	: REF FDT_TAB[],
	CFT	: REF CFT_TAB[],
	CON_SYM	: REF CON_SYM_TAB[],
	CON_CNT
	): CA_LINKAGE =
!++
! Functional Description:
!
!	Convert the constant symbol table into the constant field table
!
! Formal Parameters:
!
!	FDT	- Address of the field definition table
!	CFT	- Address of constant field table
!	CON_SYM - Address of constant symbol table
!	CON_CNT - Number of entries in constant symbol table
!
! Implicit Inputs:
!
! Implicit Outputs:
!
! Routine Value:
!
!	SUCCESS
!	FAIL
!
! Side Effects:
!
! Note:
!	Mandatory length as used below is the minimum length required
!	by a conditional key specification.  If the CON_LENGTH field is
!	zero then the constant was not defined by a conditional key
!	specification, but rather by a condition specification.  In that
!	case, the length of the constant field should be determined by
!	the length of the field used in the condition specification.
!
!--
    BEGIN

    LOCAL
	OUT_PTR:	REF VECTOR[,BYTE],	! Output constant area
	IN_CON_PTR,		! Input constant pointer
	IN_CON_LEN,		! Input constant length
	OUT_CON_IDX,		! Total output constant length
	PRE_LENGTH;		! Presumed length

    ! Get the impure data area
    CA_AREA_( CA );

    output_('conv_constants');

    ! Set the address of constant storage area behind the CFT
    ! Set the address of constant area in common area
    !
    CA[CA_CONST_AREA] = ALLOC_(0);

    ! Set up the constant table.
    ! Run through the constant symbol table and convert
    !
    INCR IN FROM 0 TO .CON_CNT-1 DO
	BEGIN
	BIND
	    WF_NAMES = CA[CA_WF_NAMES]: VECTOR[,BYTE];
	MACRO
	    ITS_A_WORK_FILE = (.IN - .WF_NAMES[1] LSSU .WF_NAMES[0]) %;

	! Get the start address and length of the constant
	! Get the presumed length from the constant symbol table
	!
	IN_CON_PTR = .CON_SYM[.IN, CON_NAM_ADR];
	IN_CON_LEN = .CON_SYM[.IN, CON_NAM_LEN];
	PRE_LENGTH = .CON_SYM[.IN, CON_LENGTH];

	! If there, get length (in bytes) out of the FDT table
	!
	IF .CON_SYM[.IN, CON_INDEX] NEQ 0
	THEN
	    BEGIN
	    PRE_LENGTH = .FDT[.CON_SYM[.IN, CON_INDEX], FDT_FLD_SIZ];
	    %IF %BLISS(BLISS32)
	    %THEN
		IF .FDT[.CON_SYM[.IN, CON_INDEX], FDT_TYPE] EQL DT_P
		THEN
		    PRE_LENGTH = .PRE_LENGTH / 2 + 1;
	    %FI
	    END;

	! Allocate space for the constant
	!
	OUT_PTR = ALLOC_(.PRE_LENGTH);

	! Zero the output area
	!
	IF CH$RCHAR(.IN_CON_PTR) EQL C_QUOTE
	THEN
	    CH$FILL(.CA[CA_PAD], .PRE_LENGTH, OUT_PTR[0])
	ELSE
	    CH$FILL(0, .PRE_LENGTH, OUT_PTR[0]);

	! Set the address in CFT
	! Set the number of bytes in output string
	!
	CFT[.IN, CFT_CON_ADR] = OUT_PTR[0] - CFT[0, BASE_];
	CFT[.IN, CFT_CON_LEN] = .PRE_LENGTH;

	! Check for a work file name that does not begin with a quote.
	!
	IF ITS_A_WORK_FILE AND CH$RCHAR(.IN_CON_PTR) NEQ C_QUOTE
	THEN
	    BEGIN
	    CH$MOVE(.PRE_LENGTH, .IN_CON_PTR, OUT_PTR[0]);
	    END
	ELSE	! Should indent more, but ...

	! What kind of constant is it?
	!
	SELECTONE CH$RCHAR_A(IN_CON_PTR) OF
	    SET

	    [C_QUOTE]:	! It's a quoted string
		BEGIN
		!
		! Move string to storage area,
		! Converting doubled quotes to single
		!

		! Don't include the starting quote
		IN_CON_LEN = .IN_CON_LEN - 1;

		WHILE (IN_CON_LEN = .IN_CON_LEN - 1) GTR 0 DO
		    BEGIN
		    IF (PRE_LENGTH = .PRE_LENGTH - 1) LSS 0 THEN EXITLOOP;
		    CH$WCHAR( CH$RCHAR_A(IN_CON_PTR), OUT_PTR[0] );
		    IF CH$RCHAR_A(OUT_PTR) EQL C_QUOTE
		    THEN
			BEGIN
			IF CH$RCHAR_A(IN_CON_PTR) NEQ C_QUOTE THEN RETURN FAIL;
			IN_CON_LEN = .IN_CON_LEN - 1;
			END;
		    END;

		! For workfiles, we may have made the string shorter
		! (because of doubled quotes).  Set CFT_CON_LEN appropriately,
		! since RMS may not like the pad characters at the end.
		!
		IF ITS_A_WORK_FILE
		THEN
		    CFT[.IN,CFT_CON_LEN] =
			OUT_PTR[0] - (.CFT[.IN,CFT_CON_ADR] + CFT[0,BASE_]);

		END;

	    [C_PERCENT]:	! Decimal, octal, or hexadecimal constant
		BEGIN
		MACRO OCT_HEX(C_OH) =
		    BEGIN
		    ! From low order to high order, convert each byte
		    DECR I FROM .IN_CON_LEN-1 TO 0 DO
			BEGIN
			LOCAL V: BYTE;	! The input character
			LOCAL B;
			LITERAL K = %IF C_OH EQL C_HEX %THEN 4 %ELSE 3 %FI;
			SELECTONE (V = CH$RCHAR_A(IN_CON_PTR)) OF
			    SET
			    [%C'0' TO %C'9']:	V = .V - %C'0';
			    %IF C_OH EQL C_HEX %THEN
			    [%C'A' TO %C'F']:	V = .V - %C'A' + 10;
			    [%C'a' TO %C'f']:	V = .V - %C'a' + 10;
			    %FI
			    [OTHERWISE]:	RETURN FAIL;
			    TES;
			B = MINU(K, .PRE_LENGTH * %BPUNIT - K * .I);
			(.OUT_PTR)<K * .I, .B> = .V;
			END;
		    END %;

		! Adjust input length to reflect the percent and radix chars
		IN_CON_LEN = .IN_CON_LEN - 2;

		! Is it dec, oct or hex (lower_cased)?
		SELECTONE LOWER_(CH$RCHAR_A(IN_CON_PTR)) OF
		    SET
		    [C_DEC]:	RETURN FAIL;	! ???+++
		    [C_OCT]:	OCT_HEX(C_OCT);	! Octal
		    [C_HEX]:	OCT_HEX(C_HEX);	! Hexadecimal
		    TES;

		END;

	    [%C'0' TO %C'9']:
		BEGIN
		EXTERNAL ROUTINE
		    SOR$$CONVERT;
		LOCAL
		    TYP,
		    F1: VECTOR[2],
		    F2: VECTOR[2];
		TYP = DT_U;		! Unsigned binary
		F1[0] = .IN_CON_LEN;
		F1[1] = .IN_CON_PTR-1;	! Recover from previous CH$RCHAR_A
		F2[0] = .PRE_LENGTH;
		F2[1] = OUT_PTR[0];
		IF .CON_SYM[.IN, CON_INDEX] NEQ 0
		THEN
		    BEGIN
		    !
		    ! Grab the destination datatype, and (for BLISS32)
		    ! Grab the destination size again, since SOR$$CONVERT
		    !	wants DT_P in digits, while PRE_LENGTH is in bytes.
		    !
		    TYP =   .FDT[.CON_SYM[.IN, CON_INDEX], FDT_TYPE];
		    %IF %BLISS(BLISS32) %THEN
		    F2[0] = .FDT[.CON_SYM[.IN, CON_INDEX], FDT_FLD_SIZ];
		    %FI
		    IF .FDT[.CON_SYM[.IN, CON_INDEX], FDT_SCALE] NEQ 0
		    THEN
			RETURN FAIL;
		    END;
		IF SOR$$CONVERT(.TYP, F1[0], F2[0] ) NEQ SUCCESS
		THEN
		    RETURN FAIL;
		END;
	    [OTHERWISE]:		! It's something else ++++
		RETURN FAIL;

	    TES;

	END;

    RETURN SUCCESS

    END;


END
ELUDOM
