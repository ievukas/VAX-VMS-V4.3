MODULE MOUNTIMG (
		MAIN = PARSE_COMMAND,
		ADDRESSING_MODE (EXTERNAL = GENERAL),
		LANGUAGE (BLISS32),
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  MOUNT Utility Structure Level 1
!
! ABSTRACT:
!
!	This module contains the data base and utilities used to acquire the
!	MOUNT command line from the CLI parser.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  29-Sep-1977  16:58
!
! MODIFIED BY:
!
!	V03-018	HH0044		Hai Huang		09-Aug-1984
!		Correctly parse /CACHE options.
!
!	V03-017	HH0041		Hai Huang		24-Jul-1984
!		Remove REQUIRE 'LIBD$:[VMSLIB.OBJ]MOUNTMSG.B32'.
!
!	V03-016	DAS0003		David Solomon		09-Jul-1984
!		Add support for /NOREBUILD.
!
!	V03-015	HH0028		Hai Huang		27-Jun-1984
!		Make several qualifiers negatable (/CLUSTER, /GROUP,
!		/SYSTEM).
!
!	V03-014	HH0004		Hai Huang		09-Mar-1984
!		Add cluster-wide mount support.
!
!	V03-013	WMC0001		Wayne Cardoza		16-Jan-1984
!		Disable all journaling qualifiers.
!
!	V03-012	MCN0141		Maria del C. Nasr	27-Dec-1983
!		Add VALCNVERR message, and eliminate PARSE_ERROR routine
!		since it is not needed with new CLI interface.
!
!	V03-011	DAS0002		David Solomon		09-Dec-1983
!		Fix symbol name that was too long.
!
!	V03-010	DAS0001		David Solomon		29-Nov-1983
!		Add support for specifying maximum journal record size
!		with a new keyword, /JOURNAL=(RECORD_SIZE=n).
!
!	V03-009	MCN0138		Maria del C. Nasr	21-Nov-1983
!		Turn of NEWJOURNAL when /NOJOURNAL is specified.
!
!	V03-008	MCN0137		Maria del C. Nasr	12-Jul-1983
!		Change to new CLI interface.
!
!	V03-007 LMP0140		L. Mark Pilant		22-Aug-1983
!		Add support for alphanumeric UICs.
!
!	V03-006	MMD0188		Meg Dumont,	7-Jul-1983  10:00
!		Make the default for AVL/AVR the same from the DCL call
!		and from the system service call.
!		
!	V03-005	MMD0116		Meg Dumont,	29-Mar-1983  0:40
!		Add support for AVL, AVR and new VMS prot on tape
!
!	V03-004	STJ49203	Steven T. Jeffreys,	08-Feb-1982
!		Set MNT$V_OVR_SETID if /OVERRIDE=SETID was specified.
!
!	V03-003	STJ0318		Steven T. Jeffreys,	15-Aug-1982
!		Added support for the journalling qualifiers.
!
!	V03-002	STJ0303		Steven T. Jeffreys,	18-May-1982
!		Replace the obsolete /UNLOCK qualifier with the /UNLOAD
!		qualifier.
!
!	V03-001	STJ0239		Steven T. Jeffreys,	17-Mar-1982
!		Relax the parsing restrictions on the device name
!		as specified in the /PROCESSOR=SAME:<device name>
!		qualifier.  Specifically, if no ":" is specified in
!		the device name, put one there.
!
!	V02-016	STJ0226		Steven T. Jeffreys,	17-Feb-1982
!		Do not set the inhibit bit in the final status code.
!		This effectively undoes edit #14.
!
!	V02-015	STJ0213		Steven T. Jeffreys,	11-Feb-1982
!		Add support for the /COMMENT qualifier.
!
!	V02-014	STJ0201		Steven T. Jeffreys,	04-Feb-1982
!		Set the inhibit bit in the final status code.
!
!	V02-013	STJ0187		Steven T. Jeffreys,	25-Jan-1982
!		Changed MNT$V_MOUNTVER to MNT$V_NOMNTVER.
!
!	V02-012	STJ0172		Steven T. Jeffreys,	08-Jan-1982
!		Changed $MOUNT interface to use *new* item list format.
!
!	V02-011	STJ0162		Steven T. Jeffreys,	04-Jan-1982
!		Added support for the /OVERRIDE=LOCK, /NOCACHE, /MOUNTVER,
!		and /MESSAGE qualifiers.
!
!	V02-010	STJ0153		Steven T. Jeffreys,	02-Jan-1981
!		Extensive rewrite to support the $MOUNT system service.
!
!	V02-009	STJ0147		Steven T. jeffreys,	01-Dec-1981
!		Fixed TPARSE table for /PROCESSOR= option.
!
!	V02-008	STJ0137		Steven T. Jeffreys,	02-Nov-1981
!		Convert the command line parser to a separate image,
!		which will parse the command line and then call the
!		$MOUNT system service to complete the mount.
!
!	V02-007	STJ0036		Steven T. Jeffreys,	11-May-1981
!		Added support for /ASSIST qualifier.
!
!	V02-006	ACG0167		Andrew C. Goldstein,	18-Apr-1980  13:38
!		Previous revision history moved to MOUNT.REV
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:MOUDEF.B32';
REQUIRE	'LIBD$:[VMSLIB.OBJ]INITMSG.REQ';
LIBRARY 'SYS$LIBRARY:CLIMAC.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';


FORWARD ROUTINE
	CACHE_ACT	: NOVALUE,
	DATACHECK_ACT	: NOVALUE,
	DENSITY_ACT	: NOVALUE,
	GET_DEVICE	: NOVALUE,
	GET_LABEL	: NOVALUE,
	GET_LOG_NAME	: NOVALUE,
	INITIALIZE_ACT	: NOVALUE,
	JOURNAL_ACT	: NOVALUE,
	OVERRIDE_ACT	: NOVALUE,
	OWNER_UIC_ACT	: NOVALUE,
	PARSE_QUALIFIER : NOVALUE,
	PROCESSOR_ACT	: NOVALUE,
	PROTECTION_ACT	: NOVALUE,
	MAIN_HANDLER,
	BUILD_LIST	: NOVALUE;

!+
!
! Impure data area. This area contains the MOUNT parameters extracted from
! the command line by the associated parsing routines.
!
!-


OWN
    DEVICE_COUNT,				! number of devices specified
    LABEL_COUNT,				! number of volume labels specified
    DEVICE_STRING	: VECTOR [DEVMAX*2],	! descriptors of device name strings
    LABEL_STRING	: VECTOR [LABMAX*2],	! descriptors of volume label strings
    LOG_NAME		: BBLOCK [DSC$C_S_BLN],	! descriptor of logical name string
    MOUNT_OPTIONS	: BITVECTOR [64],	! option flags
    MOUNT_FLAGS		: BBLOCK [4],		! mount option flags for service

    ! Value of qualifiers
    !
    ACCESS,					! value of /ACCESSED qualifier
    ACP_STRING		: BBLOCK [DSC$C_S_BLN],	! descriptor of ACP device or name string
    BLOCKSZ,					! value of /BLOCKSIZE qualifier
    EXT_CACHE,					! space to allocate for extent cache
    FID_CACHE,					! space to allocate for file ID cache
    QUO_CACHE,					! space to allocate for quota cache
    COMMENT_STRING	: BBLOCK [DSC$C_S_BLN],	! descriptor of /COMMENT string
    DENSITY,					! value of /DENSITY qualifier
    EXTENSION,					! value of /EXTENSION qualifier
    JRNL_QUOTA,					! value of /JOURNAL=QUOTA keyword
    JRNL_EXTEND,				! value of /JOURNAL=EXTEND keyword
    JRNL_SIZE,					! value of /JOURNAL=SIZE keyword
    JRNL_RECORD_SIZE,				! value of /JOURNAL=RECORD_SIZE keyword
    OWNER_UIC,					! value of /OWNER_UIC qualifier
    PROTECTION,					! value of /PROTECTION qualifier
    RECORDSZ,					! value of /RECORDSZ qualifier
    STRUCT_NAME		: BBLOCK [DSC$C_S_BLN],	! descriptor of volume set name
						!  (value of /BIND qualifier)
    WINDOW,					! value of /WINDOWS qualifier

    CLI_DESC		: BBLOCK [DSC$C_S_BLN],	! CLI work descriptor
    EXT_LIMIT		: INITIAL (-1),		! limit of disk free space to cache
    TPARSE_BLOCK	: BBLOCK [TPA$K_LENGTH0]
			  INITIAL (TPA$K_COUNT0, TPA$M_BLANKS OR TPA$M_ABBREV),
    UIC,
    ZERO;					! variable whose value is 0

LITERAL
    ITEM_SIZE = 12,
    NUMBER_OF_ITEMS = 18,
    ITEM_LIST_SIZE = ((ITEM_SIZE * DEVMAX) * 2) + (NUMBER_OF_ITEMS * ITEM_SIZE) + 4;

! Descriptors for qualifiers names, used while parsing command line.
!
BIND
    ACCESSED_DESC	= $DESCRIPTOR('ACCESSED'),
    ASSIST_DESC		= $DESCRIPTOR('ASSIST'),
    AUTOMATIC_DESC	= $DESCRIPTOR('AUTOMATIC'),
    BIND_DESC		= $DESCRIPTOR('BIND'),
    BLOCK_DESC		= $DESCRIPTOR('BLOCKSIZE'),
    CACHE_DESC		= $DESCRIPTOR('CACHE'),
    CLUSTER_DESC	= $DESCRIPTOR('CLUSTER'),
    COMMENT_DESC	= $DESCRIPTOR('COMMENT'),
    DATA_DESC		= $DESCRIPTOR('DATA_CHECK'),
    DENSITY_DESC	= $DESCRIPTOR('DENSITY'),
    EXTENSION_DESC	= $DESCRIPTOR('EXTENSION'),
    FOREIGN_DESC	= $DESCRIPTOR('FOREIGN'),
    GROUP_DESC		= $DESCRIPTOR('GROUP'),
    HDR3_DESC		= $DESCRIPTOR('HDR3'),
    INITIALIZE_DESC	= $DESCRIPTOR('INITIALIZE'),
    JOURNAL_DESC	= $DESCRIPTOR('JOURNAL'),
    LABEL_DESC		= $DESCRIPTOR('LABEL'),
    MESSAGE_DESC	= $DESCRIPTOR('MESSAGE'),
    MOUNT_VER_DESC	= $DESCRIPTOR('MOUNT_VERIFICATION'),
    NOLABEL_DESC	= $DESCRIPTOR('NOLABEL'),
    OVERRIDE_DESC	= $DESCRIPTOR('OVERRIDE'),
    OWNER_DESC		= $DESCRIPTOR('OWNER_UIC'),
    PROCESSOR_DESC	= $DESCRIPTOR('PROCESSOR'),
    PROTECTION_DESC	= $DESCRIPTOR('PROTECTION'),
    QUOTA_DESC		= $DESCRIPTOR('QUOTA'),
    REBUILD_DESC	= $DESCRIPTOR('REBUILD'),
    RECORD_DESC		= $DESCRIPTOR('RECORDSIZE'),
    SHARE_DESC		= $DESCRIPTOR('SHARE'),
    SYSTEM_DESC		= $DESCRIPTOR('SYSTEM'),
    UNLOAD_DESC		= $DESCRIPTOR('UNLOAD'),
    WINDOW_DESC		= $DESCRIPTOR('WINDOWS'),
    WRITE_DESC		= $DESCRIPTOR('WRITE');

! CLI parsing routines
!
EXTERNAL ROUTINE
    LIB$CVT_DTB,
    STR$COPY_DX,
    CLI$GET_VALUE,			! retreives qualifiers value
    CLI$PRESENT;			! determines if qualifier appears in
					!  command
EXTERNAL LITERAL
    CLI$_ABSENT,
    CLI$_DEFAULTED,
    CLI$_NEGATED,
    CLI$_PRESENT;


GLOBAL ROUTINE PARSE_COMMAND =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the MOUNT command line by calling the CLI
!	result parse routines, and leaves the results in the global data
!	area.
!
!
! CALLING SEQUENCE:
!	MOUNT_PARSE
!
! INPUT PARAMETERS:
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	parser impure area on preceding pages
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
    ITEM_LIST		: BBLOCK [ITEM_LIST_SIZE],	! Storage for item list
    END_OF_LIST,					! Pointer to end of item list
    STATUS;

! Enable the main condition handler.  The handler will ensure that
! the return status will have the MOUNT facility code.
!

ENABLE	MAIN_HANDLER;

! Initialize list for system service.
!
END_OF_LIST = ITEM_LIST;

! Initialize result parsing.
!
ZERO = 0;
MOUNT_OPTIONS = MOUNT_OPTIONS+4 = 0;
MOUNT_OPTIONS[OPT_MESSAGE] = 1;
MOUNT_OPTIONS[OPT_NOSHARE] = 1;
MOUNT_OPTIONS[OPT_NOLABEL] = 1;
MOUNT_OPTIONS[OPT_NOQUOTA] = 1;
MOUNT_OPTIONS[OPT_NOHDR3] = 1;
MOUNT_OPTIONS[OPT_NOUNLOAD] = 1;

! Initialize CLI descriptor
!
CH$FILL ( 0, DSC$C_S_BLN, CLI_DESC );
CLI_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;

PARSE_QUALIFIER ();

! Get device names
!
GET_DEVICE ();

! Get volume labels
!
GET_LABEL ();

! Get logical name
!
GET_LOG_NAME ();

! If no label given, construct null label string
!

IF NOT .MOUNT_OPTIONS [OPT_LABEL]
THEN
    BEGIN
    LABEL_STRING [0] = 0;
    LABEL_STRING [1] = LABEL_STRING [1];
    END;

! Create a counted list of the addresses of all device names descriptors
!
INCR J FROM 0 TO (.DEVICE_COUNT - 1)
DO
    BUILD_LIST ( MNT$_DEVNAM,
		 .DEVICE_STRING [.J*2],
		 .DEVICE_STRING [(.J*2)+1],
		 END_OF_LIST );

! Create a counted list of the addresses of all volume name descriptors
!
INCR J FROM 0 TO (.LABEL_COUNT - 1)
DO
    BUILD_LIST ( MNT$_VOLNAM,
		 .LABEL_STRING [.J*2],
		 .LABEL_STRING [(.J*2)+1],
		 END_OF_LIST );

! Set up the parameter addresses for all specified parameters
!
! Process the LOGNAM parameter
!

IF .MOUNT_OPTIONS [OPT_LOG_NAME]
THEN
    BUILD_LIST ( MNT$_LOGNAM,
		 .LOG_NAME [DSC$W_LENGTH],
		 .LOG_NAME [DSC$A_POINTER],
		 END_OF_LIST );

! Process the /ACCESSED qualifier
!
IF .MOUNT_OPTIONS [OPT_ACCESSED]
THEN
    BUILD_LIST ( MNT$_ACCESSED, 4, ACCESS, END_OF_LIST );

! Process the /BIND qualifier
!
IF .MOUNT_OPTIONS [OPT_BIND]
THEN
    BUILD_LIST ( MNT$_VOLSET, .STRUCT_NAME[DSC$W_LENGTH],
		.STRUCT_NAME[DSC$A_POINTER], END_OF_LIST );

! Process the /BLOCKSIZE qualifier
!
IF .MOUNT_OPTIONS [OPT_BLOCKSIZE]
THEN
    BUILD_LIST ( MNT$_BLOCKSIZE, 4, BLOCKSZ, END_OF_LIST );

! Process the /CACHE=([NO]EXTENT) qualifier
!
IF .EXT_CACHE GTR 0
THEN
    BEGIN
    BUILD_LIST (MNT$_EXTENT, 4, EXT_CACHE, END_OF_LIST);
    END;
IF .MOUNT_OPTIONS [OPT_NOEXT_C]
THEN
    BUILD_LIST (MNT$_EXTENT, 4, ZERO, END_OF_LIST);

! Process the /CACHE=([NO]FILE_ID) qualifier
!
IF .MOUNT_OPTIONS [OPT_NOFID_C]
THEN
    FID_CACHE= 1;
IF .FID_CACHE GTR 0
THEN
    BUILD_LIST (MNT$_FILEID, 4, FID_CACHE, END_OF_LIST);

! Process the /CACHE=(LIMIT) qualifier
!
IF .EXT_LIMIT GTR -1
THEN
    BUILD_LIST (MNT$_LIMIT, 4, EXT_LIMIT, END_OF_LIST);

! Process the /CACHE=([NO]QUOTA) qualifier
!
IF .MOUNT_OPTIONS [OPT_NOQUO_C]
THEN
    BUILD_LIST (MNT$_QUOTA, 4, ZERO, END_OF_LIST);
IF .QUO_CACHE GTR 0
THEN
    BUILD_LIST (MNT$_QUOTA, 4, QUO_CACHE, END_OF_LIST);

! Process the /COMMENT qualifier
!
IF .MOUNT_OPTIONS [OPT_COMMENT]
THEN
    BUILD_LIST ( MNT$_COMMENT, .COMMENT_STRING[DSC$W_LENGTH],
		.COMMENT_STRING[DSC$A_POINTER], END_OF_LIST );

! Process the /DENSITY qualifier
!
IF .MOUNT_OPTIONS [OPT_DENSITY]
THEN
    BUILD_LIST (MNT$_DENSITY, 4, DENSITY, END_OF_LIST);

! Process the /EXTENSION qualifier
!
IF .MOUNT_OPTIONS [OPT_EXTENSION]
THEN
    BUILD_LIST ( MNT$_EXTENSION, 4, EXTENSION, END_OF_LIST );

! Process the /JOURNAL qualifier options
!
IF .JRNL_SIZE NEQ 0
THEN
    BUILD_LIST (MNT$_JRNLSIZE, 4, JRNL_SIZE, END_OF_LIST);

IF .JRNL_RECORD_SIZE NEQ 0
THEN
    BUILD_LIST (MNT$_JRNLRECORD_SIZE, 4, JRNL_RECORD_SIZE, END_OF_LIST);

IF .JRNL_EXTEND NEQ 0
THEN
    BUILD_LIST (MNT$_JRNLEXTEND, 4, JRNL_EXTEND, END_OF_LIST);

IF .JRNL_QUOTA NEQ 0
THEN
    BUILD_LIST (MNT$_JRNLQUOTA, 4, JRNL_QUOTA, END_OF_LIST);


! Process the /OWNER_UIC qualifier
!
IF .MOUNT_OPTIONS [OPT_OWNER_UIC]
THEN
    BUILD_LIST (MNT$_OWNER, 4, OWNER_UIC, END_OF_LIST);

! Process the /PROCESSOR qualifier
!
IF .MOUNT_OPTIONS [OPT_UNIQUEACP]
  OR .MOUNT_OPTIONS [OPT_SAMEACP]
    OR .MOUNT_OPTIONS [OPT_FILEACP]
THEN
    BUILD_LIST ( MNT$_PROCESSOR, .ACP_STRING [DSC$W_LENGTH],
		.ACP_STRING [DSC$A_POINTER], END_OF_LIST);

! Process the /PROTECTION qualifer
!
IF .MOUNT_OPTIONS [OPT_PROTECTION]
THEN
    BUILD_LIST (MNT$_VPROT, 4, PROTECTION, END_OF_LIST);

! Process the /RECORDIZE qualifier
!
IF .MOUNT_OPTIONS [OPT_RECORDSZ]
THEN
    BUILD_LIST ( MNT$_RECORDSIZ, 4, RECORDSZ, END_OF_LIST );

! Process the /WINDOW qualifier
!
IF .MOUNT_OPTIONS [OPT_WINDOW]
THEN
    BUILD_LIST ( MNT$_WINDOW, 4, WINDOW, END_OF_LIST );


! Set the MOUNT flags according to their counterparts in MOUNT_OPTIONS
!

MOUNT_FLAGS [MNT$V_CLUSTER] = .MOUNT_OPTIONS [OPT_CLUSTER];
MOUNT_FLAGS [MNT$V_FOREIGN] = .MOUNT_OPTIONS [OPT_FOREIGN] OR .MOUNT_OPTIONS [OPT_NOLABEL];
MOUNT_FLAGS [MNT$V_GROUP] = .MOUNT_OPTIONS [OPT_GROUP];
MOUNT_FLAGS [MNT$V_INIT_ALL] = .MOUNT_OPTIONS [OPT_INIT_ALL];
MOUNT_FLAGS [MNT$V_INIT_CONT] = .MOUNT_OPTIONS [OPT_INIT_CONT];
MOUNT_FLAGS [MNT$V_MESSAGE] = .MOUNT_OPTIONS [OPT_MESSAGE];
MOUNT_FLAGS [MNT$V_NEWJRNL] = .MOUNT_OPTIONS [OPT_NEWJRNL];
MOUNT_FLAGS [MNT$V_NOASSIST] = NOT .MOUNT_OPTIONS [OPT_ASSIST];
MOUNT_FLAGS [MNT$V_NOAUTO] = .MOUNT_OPTIONS [OPT_NOAUTO];
MOUNT_FLAGS [MNT$V_NOCACHE] = .MOUNT_OPTIONS [OPT_NOCACHE];
MOUNT_FLAGS [MNT$V_NODISKQ] = .MOUNT_OPTIONS [OPT_NOQUOTA];
MOUNT_FLAGS [MNT$V_NOHDR3] = .MOUNT_OPTIONS [OPT_NOHDR3];
MOUNT_FLAGS [MNT$V_NOJRNL] = .MOUNT_OPTIONS [OPT_NOJRNL];
MOUNT_FLAGS [MNT$V_NOMNTVER] = NOT .MOUNT_OPTIONS [OPT_MOUNTVER];
MOUNT_FLAGS [MNT$V_NOUNLOAD] = .MOUNT_OPTIONS [OPT_NOUNLOAD];
MOUNT_FLAGS [MNT$V_NOWRITE] = NOT .MOUNT_OPTIONS [OPT_WRITE];
MOUNT_FLAGS [MNT$V_OVR_ACCESS] = .MOUNT_OPTIONS [OPT_OVR_ACC];
MOUNT_FLAGS [MNT$V_OVR_EXP] = .MOUNT_OPTIONS [OPT_OVR_EXP];
MOUNT_FLAGS [MNT$V_OVR_IDENT] = .MOUNT_OPTIONS [OPT_OVR_ID];
MOUNT_FLAGS [MNT$V_OVR_LOCK] = .MOUNT_OPTIONS [OPT_OVR_LOCK];
MOUNT_FLAGS [MNT$V_OVR_SETID] = .MOUNT_OPTIONS [OPT_OVR_SETID];
MOUNT_FLAGS [MNT$V_OVR_VOLO] = .MOUNT_OPTIONS [OPT_OVR_VOLO];
MOUNT_FLAGS [MNT$V_READCHECK] = .MOUNT_OPTIONS [OPT_READCHECK];
MOUNT_FLAGS [MNT$V_SHARE] = .MOUNT_OPTIONS [OPT_SHARE];
MOUNT_FLAGS [MNT$V_SYSTEM] = .MOUNT_OPTIONS [OPT_SYSTEM];
MOUNT_FLAGS [MNT$V_WRITECHECK] = .MOUNT_OPTIONS [OPT_WRITECHECK];
MOUNT_FLAGS [MNT$V_WRITETHRU] = .MOUNT_OPTIONS [OPT_WTHRU];
MOUNT_FLAGS [MNT$V_NOREBUILD] = .MOUNT_OPTIONS [OPT_NOREBUILD];

! Build an item list entry for mount flags, then terminate the item list
! with a zero value.
!
BUILD_LIST ( MNT$_FLAGS, 4, MOUNT_FLAGS, END_OF_LIST );
.END_OF_LIST = 0;

! Now that all the parameters have been parsed, call the $MOUNT system service.
! Note the informational messages may be issued from mount via a $PUTMSG and
! a status value from the call will be returned as well.
!
STATUS = $MOUNT (ITMLST = ITEM_LIST);		! Mount the volume(s)

RETURN (.STATUS)				! Return status of $MOUNT call

END;						! end of routine PARSE_COMMAND

ROUTINE PARSE_QUALIFIER : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the qualifiers of the MOUNT command line by
!	calling the CLI	result parse routines.
!
! CALLING SEQUENCE:
!	PARSE_QUALIFIER ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	MOUNT_OPTIONS BITS SET
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! First, parse the qualifiers that do not have values, and cannot be negated.
!
! /FOREIGN qualifier
!

IF CLI$PRESENT ( FOREIGN_DESC )
THEN
    MOUNT_OPTIONS [OPT_FOREIGN] = 1
ELSE
    MOUNT_OPTIONS [OPT_FOREIGN] = 0;


! /LABEL qualifier
!
IF CLI$PRESENT ( LABEL_DESC )
THEN
    BEGIN
    MOUNT_OPTIONS [OPT_LABEL] = 1;
    MOUNT_OPTIONS [OPT_NOLABEL] = 0;
    END;

! /NOLABEL qualifier
!
IF CLI$PRESENT ( NOLABEL_DESC )
THEN
    BEGIN
    MOUNT_OPTIONS [OPT_NOLABEL] = 1;
    MOUNT_OPTIONS [OPT_LABEL] = 0;
    END;




! Now, parse those qualifiers that do not require a value, and can be
! negated
!
! /ASSIST qualifier
!
SELECTONE CLI$PRESENT ( ASSIST_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_ASSIST] = 1;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_ASSIST] = 0;
TES;

! /AUTOMATIC qualifier
!
SELECTONE CLI$PRESENT ( AUTOMATIC_DESC) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_NOAUTO] = 0;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_NOAUTO] = 1;
TES;


! /CLUSTER qualifier (default is /NOCLUSTER)
!
SELECTONE CLI$PRESENT ( CLUSTER_DESC ) OF
SET
    [CLI$_PRESENT]   :  MOUNT_OPTIONS [OPT_CLUSTER] = 1;
    [CLI$_DEFAULTED,
     CLI$_ABSENT,
     CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_CLUSTER] = 0;
TES;


! /GROUP qualifier   
!
SELECTONE CLI$PRESENT ( GROUP_DESC ) OF
SET
    [CLI$_PRESENT]   :  MOUNT_OPTIONS [OPT_GROUP] = 1;
    [CLI$_DEFAULTED,
     CLI$_ABSENT,
     CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_GROUP] = 0;
TES;


! /HDR3 qualifier
!
SELECTONE CLI$PRESENT ( HDR3_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_NOHDR3] = 0;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_NOHDR3] = 1;
TES;

! /MESSAGE qualifier
!
SELECTONE CLI$PRESENT ( MESSAGE_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_MESSAGE] = 1;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_MESSAGE] = 0;
TES;

! /MOUNT_VERIFICATION qualifier
!
SELECTONE CLI$PRESENT ( MOUNT_VER_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_MOUNTVER] = 1;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_MOUNTVER] = 0;
TES;

! /QUOTA qualifier
!
SELECTONE CLI$PRESENT ( QUOTA_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_NOQUOTA] = 0;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_NOQUOTA] = 1;
TES;

! /SHARE qualifier (default is NOSHARE)
!
SELECTONE CLI$PRESENT ( SHARE_DESC ) OF
SET
    [CLI$_PRESENT]   :  BEGIN
			MOUNT_OPTIONS [OPT_SHARE] = 1;
			MOUNT_OPTIONS [OPT_NOSHARE] = 0;
			END;
    [CLI$_DEFAULTED,
     CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_NOSHARE] = 1;
TES;


! /SYSTEM qualifier  
!
SELECTONE CLI$PRESENT ( SYSTEM_DESC ) OF
SET
    [CLI$_PRESENT]   :  MOUNT_OPTIONS [OPT_SYSTEM] = 1;
    [CLI$_DEFAULTED,
     CLI$_ABSENT,
     CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_SYSTEM] = 0;
TES;


! /UNLOAD qualifier
!
SELECTONE CLI$PRESENT ( UNLOAD_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_NOUNLOAD] = 0;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_NOUNLOAD] = 1;
TES;

! /WRITE qualifier
!
SELECTONE CLI$PRESENT ( WRITE_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :	MOUNT_OPTIONS [OPT_WRITE] = 1;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_WRITE] = 0;
TES;

! /[NO]REBUILD qualifier
!
SELECTONE CLI$PRESENT ( REBUILD_DESC ) OF
SET
    [CLI$_PRESENT,
     CLI$_DEFAULTED] :  MOUNT_OPTIONS [OPT_NOREBUILD] = 0;
    [CLI$_NEGATED]   :	MOUNT_OPTIONS [OPT_NOREBUILD] = 1;
TES;


! Finally, parse the qualifiers that might have values, or require values
!
! /ACCESSED qualifier
!
IF ( MOUNT_OPTIONS [OPT_ACCESSED] = CLI$PRESENT (ACCESSED_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( ACCESSED_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    ACCESS ) )
    THEN
	ERR_EXIT (MOUN$_VALCNVERR);
    END;

! /BIND qualifier
!
IF ( MOUNT_OPTIONS [OPT_BIND] = CLI$PRESENT (BIND_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( BIND_DESC, CLI_DESC );
    CH$FILL ( 0, DSC$C_S_BLN, STRUCT_NAME );
    STRUCT_NAME [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    STRUCT_NAME [DSC$B_CLASS] = DSC$K_CLASS_D;
    STR$COPY_DX ( STRUCT_NAME, CLI_DESC );
    END;

! /BLOCKSIZE qualifier
!
IF ( MOUNT_OPTIONS [OPT_BLOCK] = CLI$PRESENT (BLOCK_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( BLOCK_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    BLOCKSZ) )
    THEN
	ERR_EXIT (MOUN$_VALCNVERR);

    IF .BLOCKSZ GTRU 65534
    THEN
	ERR_EXIT (MOUN$_SZTOOBIG);
    MOUNT_OPTIONS [OPT_BLOCKSIZE] = 1;
    END;

! /CACHE qualifier.  If the /NOCACHE qualifier was explicit, then inhibit
! all options.
!
SELECTONE CLI$PRESENT (CACHE_DESC) OF
SET
    [CLI$_PRESENT] : BEGIN
		     MOUNT_OPTIONS [OPT_CACHE] = 1;
		     CACHE_ACT ();
		     END;
    [CLI$_NEGATED] : BEGIN
		     MOUNT_OPTIONS [OPT_NOCACHE] = 1;
		     MOUNT_OPTIONS [OPT_WTHRU] = 1;
		     MOUNT_OPTIONS [OPT_NOEXT_C] = 1;
		     MOUNT_OPTIONS [OPT_NOFID_C] = 1;
		     MOUNT_OPTIONS [OPT_NOQUO_C] = 1;
		     END;
TES;

! /COMMENT qualifier
!
IF ( MOUNT_OPTIONS [OPT_COMMENT] = CLI$PRESENT (COMMENT_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( COMMENT_DESC, CLI_DESC );
    CH$FILL ( 0, DSC$C_S_BLN, COMMENT_STRING );
    COMMENT_STRING [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    COMMENT_STRING [DSC$B_CLASS] = DSC$K_CLASS_D;
    STR$COPY_DX ( COMMENT_STRING, CLI_DESC );
    END;

! /DATA_CHECK qualifier (value not required)
!
IF CLI$PRESENT (DATA_DESC)
THEN
    DATACHECK_ACT ();

! /DENSITY qualifier
!
IF ( MOUNT_OPTIONS [OPT_DENSITY] = CLI$PRESENT (DENSITY_DESC) )
THEN
    DENSITY_ACT ();

! /EXTENSION qualifier
!
IF ( MOUNT_OPTIONS [OPT_EXTENSION] = CLI$PRESENT (EXTENSION_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( EXTENSION_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    EXTENSION ) )
    THEN
	ERR_EXIT (MOUN$_VALCNVERR);
    END;

! /INITIALIZE qualifier
!

IF CLI$PRESENT ( INITIALIZE_DESC )
THEN
    INITIALIZE_ACT ();

! /JOURNAL qualifier (value not required)
!
!**JNL** SELECTONE CLI$PRESENT (JOURNAL_DESC) OF
!**JNL** SET
!**JNL**     [CLI$_PRESENT] : JOURNAL_ACT ();
!**JNL**     [CLI$_NEGATED] : BEGIN
!**JNL** 		    MOUNT_OPTIONS [OPT_NOJRNL] = 1;
!**JNL** 		    MOUNT_OPTIONS [OPT_NEWJRNL] = 0;
!**JNL** 		    JRNL_SIZE = 0;
!**JNL** 		    JRNL_EXTEND = 0;
!**JNL** 		    JRNL_QUOTA = 0;
!**JNL** 		    JRNL_RECORD_SIZE = 0;
!**JNL** 		    END;
!**JNL** TES;

! /OVERRIDE qualifier
!
IF CLI$PRESENT (OVERRIDE_DESC)
THEN
    OVERRIDE_ACT ();

! /OWNER_UIC qualifier
!
IF ( MOUNT_OPTIONS [OPT_OWNER_UIC] = CLI$PRESENT (OWNER_DESC) )
THEN
    OWNER_UIC_ACT ();

! /PROCESSOR qualifier
!
IF CLI$PRESENT (PROCESSOR_DESC)
THEN
    PROCESSOR_ACT ();

! /PROTECTION qualifier
!
IF ( MOUNT_OPTIONS [OPT_PROTECTION] = CLI$PRESENT (PROTECTION_DESC) )
THEN
    PROTECTION_ACT ();

! /RECORDSIZE qualifier
!
IF ( MOUNT_OPTIONS [OPT_RECORDSZ] = CLI$PRESENT (RECORD_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( RECORD_DESC, CLI_DESC );
    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    RECORDSZ ) )
    THEN
	ERR_EXIT (MOUN$_VALCNVERR);

    IF .RECORDSZ GTRU 65534
    THEN
	ERR_EXIT (MOUN$_SZTOOBIG);
    END;

! /WINDOWS qualifier
!
IF ( MOUNT_OPTIONS [OPT_WINDOW] = CLI$PRESENT (WINDOW_DESC) )
THEN
    BEGIN
    CLI$GET_VALUE ( WINDOW_DESC, CLI_DESC );

    IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			    .CLI_DESC [DSC$A_POINTER],
			    WINDOW ) )
    THEN
	ERR_EXIT (MOUN$_VALCNVERR);
    END;

END;					! of PARSE_QUALIFIER routine

ROUTINE BUILD_LIST (ITEM_CODE, ITEM_LENGTH, ITEM_ADDRESS, LIST_PTR) : NOVALUE =

!++
! Functional description:
!
!	This routine will build an item list entry from the input parameters.
!
! Input:
!
!	ITEM_ADDRESS	: Address of item
!	ITEM_CODE	: Item code value
!	ITEM_LENGTH	: Length of item (in bytes)
!	LIST_PTR	: Address of a pointer to the end of the list
!	
!
! Implicit Input:
!
!	The list is assumed to be long enough.
!
! Output:
!
!	LIST		: points to new end of list
!
! Implict output:
!
!	None.
!
! Side effects:
!
!	None.
!
! Routine value:
!
!	None.
!--

BEGIN						! Start of BUILD_ENTRY

LOCAL
	LIST		: REF BBLOCK;

MACRO
	LENGTH		=  0, 0, 16, 0%,
	CODE		=  2, 0, 16, 0%,
	ADDRESS		=  4, 0, 32, 0%,
	UNUSED		=  8, 0, 32, 0%;

LIST = ..LIST_PTR;				! Get address of start of entry
LIST [LENGTH] = .ITEM_LENGTH;			! Set the item length
LIST [CODE] = .ITEM_CODE;			! Set the item code
LIST [ADDRESS] = .ITEM_ADDRESS;			! Set the item address
LIST [UNUSED] = 0;				! Clear the unused portion
.LIST_PTR = .LIST + ITEM_SIZE;			! Set new end of list

END;						! End of BUILD_ENTRY

ROUTINE MAIN_HANDLER (SIGNAL, MECHANISM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the main level condition handler for the MOUNT
!	utility. It undoes anything that MOUNT has done so far and returns
!	the condition code as status to MOUNT's	caller (i.e., the CLI).
!
!
! CALLING SEQUENCE:
!	MAIN_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal array
!	ARG2: address of mechanism array
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	stack unwound, control passed to CLI
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal array
	MECHANISM	: REF BBLOCK;	! mechanism array


! Force the facility code to be mount and resignal the
! error to be printed by the catch all handler.
!

IF .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] EQL 0
OR .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] EQL INIT$_FACILITY
THEN BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] = MOUN$_FACILITY;

RETURN SS$_RESIGNAL;

END;					! end of routine MAIN_HANDLER

!+
!
! Parameter and qualifier action routines. Each routine is named corresponding
! to its associated parameter of qualifier. Each routine does whatever
! conversion is necessary and stores the parameter or qualifier value in
! the appropriate location in the output area.
!
!-


ROUTINE CACHE_ACT : NOVALUE =
BEGIN

EXTERNAL
	CACHE_STB	: VECTOR [0],	! state table address
	CACHE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

!
! Initialize work area.
!

EXT_CACHE = -1;				! Set value for EXTENT not seen
FID_CACHE = -1;				! Set value for FILE_ID not seen
QUO_CACHE = -1;				! Set value for QUOTA not seen

! Parse the cache control options and set appropriate flags.
!

WHILE CLI$GET_VALUE ( CACHE_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, CACHE_STB, CACHE_KTB)
    THEN
	ERR_EXIT (MOUN$_BADCACHE);
END;

!
! Check to see if caching should be turned off:
!
!   /CACHE=EXTENT:0	disables extent caching
!   /CACHE=FILE_ID:1	disables FID caching
!   /CACHE=QUOTA:0	disables quota caching
!

IF .EXT_CACHE EQL 0			! /CACHE=EXTENT:0
THEN
    MOUNT_OPTIONS [OPT_NOEXT_C] = 1;

IF .FID_CACHE EQL 1			! /CACHE=FILE_ID:1
THEN
    MOUNT_OPTIONS [OPT_NOFID_C] = 1;

IF .QUO_CACHE EQL 0			! /CACHE=QUOTA:0
THEN
    MOUNT_OPTIONS [OPT_NOQUO_C] = 1;


END;					! end of routine CACHE_ACT

ROUTINE DATACHECK_ACT : NOVALUE =
BEGIN

EXTERNAL
	DATACHECK_STB	: VECTOR [0],	! state table address
	DATACHECK_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

LOCAL
    VALUE_FOUND;			! set when value present

! Parse the DATACHECK options string.
!

VALUE_FOUND = 0;

WHILE CLI$GET_VALUE (DATA_DESC, CLI_DESC) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, DATACHECK_STB, DATACHECK_KTB)
    THEN
	ERR_EXIT (MOUN$_BADDATCHK);
    VALUE_FOUND = 1;
END;

! If the qualifier /DATA_CHECK was specified with no value, then
! WRITE data check is the default.  Set the corresponding bit.
!
IF .VALUE_FOUND EQL 0
THEN
    MOUNT_OPTIONS [OPT_WRITECHECK] = 1;


END;					! end of routine DATACHECK_ACT

ROUTINE DENSITY_ACT : NOVALUE =

BEGIN

CLI$GET_VALUE ( DENSITY_DESC, CLI_DESC );

IF NOT ( LIB$CVT_DTB ( .CLI_DESC [DSC$W_LENGTH],
			.CLI_DESC [DSC$A_POINTER],
			DENSITY ) )
THEN
    ERR_EXIT (MOUN$_BADDENS);

SELECTONE .DENSITY OF
    SET

    [800]	: MOUNT_OPTIONS [OPT_DENS_800] = 1;
    [1600]	: MOUNT_OPTIONS [OPT_DENS_1600] = 1;
    [6250]	: 1;
    [OTHERWISE] : ERR_EXIT (MOUN$_BADDENS);

    TES;

END;


ROUTINE GET_DEVICE : NOVALUE =

BEGIN

DEVICE_COUNT = 0;

WHILE CLI$GET_VALUE ( $DESCRIPTOR('DEVICES'), CLI_DESC )
DO
    BEGIN

    BIND
	DEVICE_DESC = DEVICE_STRING [.DEVICE_COUNT * 2] : $BBLOCK;

    IF .DEVICE_COUNT GEQ DEVMAX
    THEN
	ERR_EXIT ( MOUN$_MAXDEV );

    CH$FILL ( 0, DSC$C_S_BLN, DEVICE_DESC );
    DEVICE_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DEVICE_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    STR$COPY_DX ( DEVICE_DESC, CLI_DESC );
    DEVICE_COUNT = .DEVICE_COUNT + 1;
    END;
END;					! of routine GET_DEVICE

ROUTINE GET_LABEL : NOVALUE =

BEGIN

LABEL_COUNT = 0;

WHILE CLI$GET_VALUE ( $DESCRIPTOR('VOLUMES'), CLI_DESC )
DO
    BEGIN

    BIND
	LABEL_DESC = LABEL_STRING [.LABEL_COUNT * 2] : $BBLOCK;

    IF .LABEL_COUNT GEQ LABMAX
    THEN
	ERR_EXIT ( MOUN$_MAXLAB );

    CH$FILL ( 0, DSC$C_S_BLN, LABEL_DESC );
    LABEL_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LABEL_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    STR$COPY_DX ( LABEL_DESC, CLI_DESC );
    LABEL_COUNT = .LABEL_COUNT + 1;
    END;
END;					! of routine GET_LABEL

ROUTINE GET_LOG_NAME: NOVALUE =

BEGIN

LOCAL
	P;			! string scan pointer

! Copy the logical name descriptor
!

IF CLI$GET_VALUE ( $DESCRIPTOR('LOGNAMES'), CLI_DESC )
THEN
    BEGIN
    MOUNT_OPTIONS [OPT_LOG_NAME] = 1;
    CH$FILL ( 0, DSC$C_S_BLN, LOG_NAME );
    LOG_NAME [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LOG_NAME [DSC$B_CLASS] = DSC$K_CLASS_D;
    STR$COPY_DX ( LOG_NAME, CLI_DESC );

    ! If logical name is greater than maximum size, return error.
    !

    IF .LOG_NAME [DSC$W_LENGTH] GTR (LOG$C_NAMLENGTH - 1)
    THEN
	ERR_EXIT ( MOUN$_LOGNAME );

    ! Scan for a trailing of embedded colon.  If found, use string preceding
    ! the colon.
    !
    P = CH$FIND_CH ( .LOG_NAME [DSC$W_LENGTH], .LOG_NAME [DSC$A_POINTER], ':' );

    IF NOT CH$FAIL (.P)
    THEN
	LOG_NAME [DSC$W_LENGTH] = .P - .LOG_NAME [DSC$A_POINTER];
    END;

END;					! end of routine LOG_NAME_ACT

ROUTINE INITIALIZE_ACT : NOVALUE =

BEGIN

EXTERNAL
	INITIALIZE_STB	: VECTOR [0],	! state table address
	INITIALIZE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the INITIALIZE string and set appropriate flags.
!

WHILE CLI$GET_VALUE ( INITIALIZE_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, INITIALIZE_STB, INITIALIZE_KTB)
    THEN
	ERR_EXIT (MOUN$_BADINIT);
END;

END;

ROUTINE JOURNAL_ACT : NOVALUE =
BEGIN

LITERAL
    MOUNT$K_DEF_JRNL_RECORD_SIZE = 600;	! Default value for max record size

EXTERNAL
	JOURNAL_STB	: VECTOR [0],	! state table address
	JOURNAL_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the journal control options and set appropriate flags.
!
MOUNT_OPTIONS [OPT_NOJRNL] = 0;

WHILE CLI$GET_VALUE ( JOURNAL_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT]	= .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR]	= .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, JOURNAL_STB, JOURNAL_KTB)
    THEN
	ERR_EXIT (MOUN$_BADJRNL);
END;

! If this is a MOUNT/JOURNAL=NEWFILE, then make sure RECORD_SIZE has a value.
! Otherwise, ensure that no values were specified for journal creation
! keywords.
!
IF .MOUNT_OPTIONS [OPT_NEWJRNL]
THEN
    BEGIN
    IF .JRNL_RECORD_SIZE EQL 0
    THEN
	JRNL_RECORD_SIZE = MOUNT$K_DEF_JRNL_RECORD_SIZE
    END
ELSE IF ((.JRNL_SIZE NEQ 0) OR (.JRNL_RECORD_SIZE NEQ 0) OR (.JRNL_EXTEND NEQ 0)
	OR (.JRNL_QUOTA NEQ 0))
THEN
    ERR_EXIT (MOUN$_BADJRNL);

END;					! end of routine JOURNAL_ACT

ROUTINE OVERRIDE_ACT : NOVALUE =
BEGIN

EXTERNAL
	OVERRIDE_STB	: VECTOR [0],	! state table address
	OVERRIDE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the OVERRIDE string and set appropriate flags.
!

WHILE CLI$GET_VALUE ( OVERRIDE_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, OVERRIDE_STB, OVERRIDE_KTB)
    THEN
	ERR_EXIT (MOUN$_BADOVR);
END;

END;					! end of routine OVERRIDE_ACT

ROUTINE OWNER_UIC_ACT : NOVALUE =
BEGIN

EXTERNAL
	UIC_STB		: VECTOR [0],	! state table address
	UIC_KTB		: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the UIC string and store it in the owner UIC longword.
!

WHILE CLI$GET_VALUE ( OWNER_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, UIC_STB, UIC_KTB)
    THEN
	ERR_EXIT (MOUN$_BADUIC);
END;

OWNER_UIC = .UIC;

END;					! end of routine OWNER_UIC_ACT


ROUTINE PROCESSOR_ACT : NOVALUE =
BEGIN

EXTERNAL
	PROCESSOR_STB	: VECTOR [0],	! state table address
	PROCESSOR_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the PROCESSOR switch options (leaving values and bits set).
!

CLI$GET_VALUE ( PROCESSOR_DESC, CLI_DESC );
TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];

IF NOT LIB$TPARSE (TPARSE_BLOCK, PROCESSOR_STB, PROCESSOR_KTB)
THEN
    ERR_EXIT (MOUN$_BADACP);

END;					! end of routine PROCESSOR_ACT

ROUTINE PROTECTION_ACT : NOVALUE =

BEGIN

EXTERNAL
	PROTECTION_STB	: VECTOR [0],	! state table address
	PROTECTION_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the PROTECTION qualifier string storing the binary protection.
! Complement thereafter, since the parser produces the complement.
!

WHILE CLI$GET_VALUE ( PROTECTION_DESC, CLI_DESC ) DO
BEGIN
    TPARSE_BLOCK[TPA$L_STRINGCNT] = .CLI_DESC[DSC$W_LENGTH];
    TPARSE_BLOCK[TPA$L_STRINGPTR] = .CLI_DESC[DSC$A_POINTER];
    IF NOT LIB$TPARSE (TPARSE_BLOCK, PROTECTION_STB, PROTECTION_KTB)
    THEN
	ERR_EXIT (MOUN$_BADPRO);
END;

PROTECTION <0, 16> = NOT .PROTECTION <0, 16>;

END;					! end of routine PROTECTION_ACT



!+
!
! TPARSE action routines for the following TPARSE tables.
!
!-

!
! Clear the "NEW JOURNAL FILE" option bit.  (We just saw NONEWFILE.)
!
ROUTINE CLEAR_NEWJRNL =
BEGIN

MOUNT_OPTIONS [OPT_NEWJRNL] = 0;
RETURN 1;

END;


!
! Store ACP string (either device name or file name).
!
ROUTINE GET_ACP_NAME =

BEGIN

LOCAL
    ACP_DESC :  BBLOCK [DSC$C_S_BLN];

TPARSE_ARGS (CONTEXT);

IF .CONTEXT[TPA$L_TOKENCNT] GTR 20
THEN ERR_EXIT (MOUN$_ACPNAME);

! Initialize local descriptor and load values
!
CH$FILL ( 0, DSC$C_S_BLN, ACP_DESC);
ACP_DESC [DSC$B_DTYPE] = DSC$K_CLASS_D;
ACP_DESC [DSC$W_LENGTH] = .CONTEXT [TPA$L_TOKENCNT];
ACP_DESC [DSC$A_POINTER] = .CONTEXT [TPA$L_TOKENPTR];

! Now, move values to the text descriptor.  We need to use a temporary
! ACP descriptor, because the CLI_DESC contains the keyword 'SAME:'
! when that option is used.
!
CH$FILL ( 0, DSC$C_S_BLN, ACP_STRING );
ACP_STRING [DSC$B_DTYPE] = DSC$K_DTYPE_T;
ACP_STRING [DSC$B_CLASS] = DSC$K_CLASS_D;
STR$COPY_DX ( ACP_STRING, ACP_DESC );
RETURN 1;

END;					! end of routine GET_ACP_NAME

!
! Store ACP string as specified by the :SAME option.
! Append a ":" to the device name.
!
ROUTINE GET_SAME_ACP =
BEGIN

LOCAL
    ACP_DESC :  BBLOCK [DSC$C_S_BLN],
    SAME_ACP : VECTOR [21,BYTE];

TPARSE_ARGS (CONTEXT);

IF .CONTEXT[TPA$L_TOKENCNT] GTR 20
THEN ERR_EXIT (MOUN$_ACPNAME);

! Add the colon (:) to the device name.
!
CH$MOVE (.CONTEXT[TPA$L_TOKENCNT], .CONTEXT[TPA$L_TOKENPTR], SAME_ACP);
SAME_ACP [.CONTEXT [TPA$L_TOKENCNT]] = %ASCII ':';

! Initialize local descriptor and load values.  The size of the device
! name has increased by 1, because of the colon that was added.
!
CH$FILL ( 0, DSC$C_S_BLN, ACP_DESC);
ACP_DESC [DSC$B_DTYPE] = DSC$K_CLASS_D;
ACP_DESC [DSC$W_LENGTH] = .CONTEXT [TPA$L_TOKENCNT] + 1;
ACP_DESC [DSC$A_POINTER] = SAME_ACP;

! Now, move values to the text descriptor.
!
CH$FILL ( 0, DSC$C_S_BLN, ACP_STRING );
ACP_STRING [DSC$B_DTYPE] = DSC$K_DTYPE_T;
ACP_STRING [DSC$B_CLASS] = DSC$K_CLASS_D;
STR$COPY_DX ( ACP_STRING, ACP_DESC );
RETURN 1;

END;					! end of routine GET_SAME_ACP

!+
!
! TPARSE state tables to parse the various qualifier value strings.
!
!-

!
! Parse /CACHE options (EXTENT=n, LIMIT=n, FILE_ID=n, QUOTA=n, NOEXTENT,
! NOFILE_ID, NOQUOTA, and WRITETHROUGH).
!
$INIT_STATE (CACHE_STB, CACHE_KTB);

$STATE	(NEXT_CACHE,
	('EXTENT',	CACHE_EXT,,	1^(OPT_CACHE-32), MOUNT_OPTIONS+4),
	('FILE_ID',	CACHE_FID,,	1^(OPT_CACHE-32), MOUNT_OPTIONS+4),
	('LIMIT',	LIMIT_EXT),
	('NOEXTENT',,,			1^(OPT_NOEXT_C-32), MOUNT_OPTIONS+4),
	('NOFILE_ID',,,			1^(OPT_NOFID_C-32), MOUNT_OPTIONS+4),
	('NOQUOTA',,,			1^(OPT_NOQUO_C-32), MOUNT_OPTIONS+4),
	('NOWRITETHROUGH'),
	('QUOTA',	CACHE_QUO,,	1^(OPT_CACHE-32), MOUNT_OPTIONS+4),
	('WRITETHROUGH',,,		1^(OPT_WTHRU-32), MOUNT_OPTIONS+4)
	);

$STATE	(END_CACHE,
	(',', NEXT_CACHE),
	(TPA$_EOS, TPA$_EXIT)
	);

$STATE	(CACHE_EXT,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	EXT_CACHE)
	);


$STATE	(CACHE_FID,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	FID_CACHE)
	);


$STATE	(CACHE_QUO,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	QUO_CACHE)
	);

$STATE	(LIMIT_EXT,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	EXT_LIMIT)
	);

!
! Parse /DATA_CHECK options, of the form [READ][,WRITE]. Default is write.
!
$INIT_STATE (DATACHECK_STB, DATACHECK_KTB);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT,, 1^(OPT_WRITECHECK-32), MOUNT_OPTIONS+4),
	(TPA$_LAMBDA)
	);

$STATE	(CHECKOPT,
	('READ',,, 1^(OPT_READCHECK-32), MOUNT_OPTIONS+4),
	('WRITE',,, 1^(OPT_WRITECHECK-32), MOUNT_OPTIONS+4)
	);

$STATE	(,
	(',', CHECKOPT),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse INITIALIZE options (ALL, CONTINUATION)
!

$INIT_STATE (INITIALIZE_STB, INITIALIZE_KTB);

$STATE	(NEXTINI,
	('ALL',,,1^(OPT_INIT_ALL-32), MOUNT_OPTIONS+4),
	('CONTINUATION',,,1^(OPT_INIT_CONT-32), MOUNT_OPTIONS+4)
	);

$STATE	(,
	(',',NEXTINI),
	(TPA$_EOS, TPA$_EXIT)
	);
!
! Parse JOURNAL options ([NO]NEWFILE, SIZE=n, EXTENSION=n, QUOTA=n, RECORD_SIZE=n)
!
$INIT_STATE (JOURNAL_STB, JOURNAL_KTB);

$STATE	(NEXT_JOURNAL,
	('NEWFILE',,,			1^(OPT_NEWJRNL-32), MOUNT_OPTIONS+4),
	('NONEWFILE',,		CLEAR_NEWJRNL),
	('SIZE',	JOURNAL_SIZE),
	('RECORD_SIZE',	JOURNAL_RECORD_SIZE),
	('EXTENSION',	JOURNAL_EXTEND),
	('QUOTA',	JOURNAL_QUOTA),
	(TPA$_EOS,	TPA$_EXIT)
	);

$STATE	(END_JOURNAL,
	(',',		NEXT_JOURNAL),
	(TPA$_EOS,	TPA$_EXIT)
	);

$STATE	(JOURNAL_SIZE,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_JOURNAL,,,	JRNL_SIZE)
	);

$STATE	(JOURNAL_RECORD_SIZE,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_JOURNAL,,,	JRNL_RECORD_SIZE)
	);

$STATE	(JOURNAL_EXTEND,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_JOURNAL,,,	JRNL_EXTEND)
	);
	
$STATE	(JOURNAL_QUOTA,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_JOURNAL,,,	JRNL_QUOTA)
	);

!
! Parse /OVERRIDE options (ACCESSIBILITY, EXPIRATION, SETIDENTIFICATION, 
!			  IDENTIFICATION, OWNER_IDENTIFIER).
!
$INIT_STATE (OVERRIDE_STB, OVERRIDE_KTB);

$STATE	(NEXTOVR,
	('ACCESSIBILITY',,,1^(OPT_OVR_ACC-32), MOUNT_OPTIONS+4),
	('EXPIRATION',,, 1^OPT_OVR_EXP, MOUNT_OPTIONS),
	('SETIDENTIFICATION',,, 1^OPT_OVR_SETID, MOUNT_OPTIONS),
	('LOCK',,,1^(OPT_OVR_LOCK-32), MOUNT_OPTIONS+4),
	('IDENTIFICATION',,, 1^OPT_OVR_ID, MOUNT_OPTIONS),
	('OWNER_IDENTIFIER',,,1^(OPT_OVR_VOLO-32), MOUNT_OPTIONS+4)
	);

$STATE	(,
	(',',NEXTOVR),
	(TPA$_EOS, TPA$_EXIT)
	);


!
! Parse /OWNER_UIC string and store binary value.
!
$INIT_STATE (UIC_STB, UIC_KTB);

$STATE	(,
	(TPA$_IDENT,,,,UIC)
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse PROCESSOR options, set bits and store name.
!
$INIT_STATE (PROCESSOR_STB, PROCESSOR_KTB);

$STATE	(,
	('UNIQUE',, GET_ACP_NAME, 1^OPT_UNIQUEACP, MOUNT_OPTIONS),
	('SAME', SAMEPROC,, 1^OPT_SAMEACP, MOUNT_OPTIONS),
	((FILENAME),, GET_ACP_NAME, 1^OPT_FILEACP, MOUNT_OPTIONS)
	);

$STATE	(ENDPROC,
	(TPA$_EOS, TPA$_EXIT)
	);

$STATE	(SAMEPROC,
	(':'),
	('=')
	);

$STATE	(,
	((DEVICENAME),, GET_ACP_NAME),
	(TPA$_SYMBOL,, GET_SAME_ACP)
	);

$STATE	(,
	(TPA$_LAMBDA, TPA$_EXIT)
	);

$STATE	(FILENAME,
	(TPA$_SYMBOL, FILENAME),
	('.', FILENAME),
	(';', FILENAME),
	(TPA$_LAMBDA, TPA$_EXIT)
	);

$STATE	(DEVICENAME,
	(TPA$_SYMBOL)
	);

$STATE	(,
	(':')
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse /PROTECTION string "(SYSTEM:RWED,OWNER:RWED,GROUP:RWED,WORLD:RWED)"
!
$INIT_STATE (PROTECTION_STB, PROTECTION_KTB);

$STATE	(NEXTPRO,
	('SYSTEM', SYPR,, %X'000F0000', PROTECTION),
	('OWNER',  OWPR,, %X'00F00000', PROTECTION),
	('GROUP',  GRPR,, %X'0F000000', PROTECTION),
	('WORLD',  WOPR,, %X'F0000000', PROTECTION)
	);

$STATE	(SYPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(SYPR0,
	('R', SYPR0,, %X'0001', PROTECTION),
	('W', SYPR0,, %X'0002', PROTECTION),
	('E', SYPR0,, %X'0004', PROTECTION),
	('P', SYPR0,, %X'0004', PROTECTION),
	('D', SYPR0,, %X'0008', PROTECTION),
	('L', SYPR0,, %X'0008', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(OWPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(OWPR0,
	('R', OWPR0,, %X'0010', PROTECTION),
	('W', OWPR0,, %X'0020', PROTECTION),
	('E', OWPR0,, %X'0040', PROTECTION),
	('P', OWPR0,, %X'0040', PROTECTION),
	('D', OWPR0,, %X'0080', PROTECTION),
	('L', OWPR0,, %X'0080', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(GRPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(GRPR0,
	('R', GRPR0,, %X'0100', PROTECTION),
	('W', GRPR0,, %X'0200', PROTECTION),
	('E', GRPR0,, %X'0400', PROTECTION),
	('P', GRPR0,, %X'0400', PROTECTION),
	('D', GRPR0,, %X'0800', PROTECTION),
	('L', GRPR0,, %X'0800', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(WOPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(WOPR0,
	('R', WOPR0,, %X'1000', PROTECTION),
	('W', WOPR0,, %X'2000', PROTECTION),
	('E', WOPR0,, %X'4000', PROTECTION),
	('P', WOPR0,, %X'4000', PROTECTION),
	('D', WOPR0,, %X'8000', PROTECTION),
	('L', WOPR0,, %X'8000', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(ENDPRO,
	(',', NEXTPRO),
	(TPA$_EOS, TPA$_EXIT)
	);

END
ELUDOM
