	.TITLE	TTYCHARI - terminal input character routines
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES NEEDED FOR CHARACTER INPUT.
;
; AUTHOR:
;
;	R.HEINEN  11-AUG-1976
;
; Revision history:
;	V03-019	MIR0450		Michael I. Rosenblum		27-Jun-1984
;		Never initiate logins on a terminal marked secure server
;		and noautobaud from unsolicited input.
;
;	V03-018 MIR0370		Michael I. Rosenblum		20-Mar-1984
;		Use TTY$GB_AUTOCHAR to get the character to indicate
;		ready for system password.
;
;	V03-017	MIR0310		Michael	I. Rosenblum		07-FEB-1985
;		Fix bug that caused the interrupt key to stop working when
;		in 8 bit mode.  Add code to output a different character
;		as a ready for system password character.
;		Fix bug in pasthru mode so it will honor control-s and 
;		control-q correctly.
;
;	V03-016	MIR0082		Michael I. Rosenblum		19-Aug-1983
;		Make long word reference to a byte field a byte reference.
;
;	V03-015	MIR0080		Michael I. Rosenblum		14-Jun-1983
;		Restructure module.
;
;	V03-014	MIR0051		Michael I. Rosenblum		23-Jun-1983
;		Optomize normal character input code path, make jobcontroler
;		notification logic a subroutine, output bell uppon notification
;		of job controler on login.  Make buffering characters in the
;		typeahead buffer a subroutine.
;
;	V03-013	MIR1050		Michael I. Rosenblum		23-May-1983
;		finish removing code for broadcast.
;
;	V03-012	JLV0255		Jake VanNoy		23-MAY-1983
;		Add code to allow out-of-band aborts. Set up multi-echo
;		strings to be table driven.
;
;	V03-011	MIR0041		Michael I. Rosenblum		29-Apr-1983
;		Cause autobaud to require a readable CR before initiating
;		loginout.  Clear the passall optomization bit when EOL is
;		set.  Check int before jumping into the getnextchar code path
;		when EOL is set by the passall code path.
;
;	V03-010	MIR0034		Michael I. Rosenblum		07-Apr-1983
;		allow LK201 function key F6 to translate to ^C
;
;	V03-009	MIR0032		Michael I. Rosenblum		05-Apr-1983
;		Allow control-C,Y and O to echo dec crt strings.
;
;	V03-008	RKS0008		RICK SPITZ			14-MAR-1983
;		ADD SUPPORT FOR LOGICAL UCB
;
;	V03-007	MIR0023		Michael I. Rosenblum		24-Jan-1983
;		Move the location of setting MULTI in the control-C and Y
;		logic to allow MULTI to be cleared during READONE.
;		Clearing MULTI will stop the Read buffer from
;		being modified after readone dealocates it.
;
;	V03-006	MIR0017		Michael I. Rosenblum		05-Jan-1983
;		Change return status of TTY$PUTNEXTCHAR to include a byte value
;		in the UCB, this will move the information from the condition
;		code bits.
;
;	V03-005	MIR0015		Michael I. Rosenblum		20-Dec-1982
;		Change TTY$V_ST_UNSOL and TTY$V_ST_GETAHD to TTY$V_FD_UNSOL
;		and TTY$V_FD_GETAHD, to reflect changes in the fork dispatcher
;		Change calls to port driver to call the class driver jacket
;		routines.
;
;	V03-004	MIR0014		Michael I. Rosenblum		17-Dec-1982
;		Change PORT_XON and PORT_XOFF to CLASS_XON and CLASS_XOFF
;
;	V03-003 MIR0013		Michael I. Rosenblum		16-Dec-1982
;		Fix up refferences to new ucb structure
;
;	V03-002	MIR0011		Michael I. Rosenblum		18-Nov-1982
;		Change multiecho to always take a length count and address
;		of a string.
;
;	V03-002	MIR0010		Michael I. Rosenblum		09-Nov-1982
;		Move the address of the terminator mask, and the length
;		of the prompt string from the IRP into the terminal read
;		packet.  Also move the count of the characters in the 
;		buffer from the UCB into the terminal typeahead buffer packet.
;		Restructured typeahead buffer alarm size calculation slightly
;		to use the count from the typeahead buffer packet.
;
;	V03-001	RKS0001		RICK SPITZ			23-SEP-1982
;		RESET ALTLEN VALUE WHEN STARTING MULTIECHO STRING, TO INSURE
;		THAT ^Y ECHO DURING READ VERIFY FUNCTIONS PROPERLY.
;
;	V02-026	RKS0026		RICK SPITZ			25-JAN-1982
;		CHANGE CONTROL O LOGIC TO WORK WITH BURST MODE OUTPUT
;		(PREVENT WRAP IN MID LINE)
;
;	V02-025	RKS0025		RICK SPITZ			15-DEC-1981
;		CHANGE INSPOST CALL TO WRITE POST IN CTRLC,Y LOGIC.
;
;	V02-024	RKS0024		RICK SPITZ			20-NOV-1981
;		ADD OUT OF BAND SUPPORT
;
;	V02-023	JLV0099		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-022	RKS022		RICK SPITZ			20-AUG-1981
;		ADD ALTERNATE TYPEAHEAD SIZE SUPPORT
;
;	V02-021	RKS021		RICK SPITZ			12-AUG-1981
;		CORRECT DEFINITION NAMES
;
;	V02-020	JLV0062		Jake VanNoy			10-Aug-1981
;		Added autobaud code.
;		
;	V02-019	RKS019		RICK SPITZ			27-JULY-1981
;		SEVERAL NEW FEATURES HAVE BEEN ADDED TO SUPPORT THE 
;		CLASS/PORT STRUCTURE OF THE TERMINAL SERVICES. THESE
;		INCLUDE ENHANCEMENTS TO SUPPORT QUADWORD STATE AND
;		MOVING MOST XON/XOFF LOGIC TO THE PORT DRIVER. THE
;		PORT FUNCTIONS RESUME AND STOP(2) ARE USED TO HANDLE
;		RECEIVED CONTROL S AND Q. LOGIC TO HANDLE CONTROL S
;		DURING A BROADCAST IS ALSO INCLUDED.
;
;	V02-018	RKS018		RICK SPITZ			26-FEB-1981
;		REMOVE V2.0 AUDIT TRAILS
;
;--

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS
;
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL'S
	$IRPDEF				; DEFINE IRP
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$SSDEF				; DEFINE SYSTEM SERVICE STATUS CODES
	$UCBDEF				; DEFINE UCB
	$TASTDEF			; DEFINE OUT OF BAND FLAGS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE TERMINAL CHARACTERISTICS
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
 
	.PSECT	$$$115_DRIVER,LONG	; DEFINE NON-PAGED PSECT

	.SBTTL	TTY$PUTNEXTCHAR - BUFFER CHARACTER 

;++
; TTY$PUTNEXTCHAR - BUFFER CHARACTER 
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED BY PORT DRIVERS TO PASS INPUT CHARACTERS.
;
; CHARACTERS RECEIVED ON NON PASSALL UNITS ARE FILTERED FOR IMMEDIATE
; CONTROL SEQUENCES. THESE SEQUENCES REPRESENT:
;
;	CONTROL Y -- 	CAUSES THE TYPEAHEAD BUFFER TO BE PURGED, THE
;		     	ENABLED PROCESS TO RECEIVE AN AST, A "^Y" TO
;			BE OUTPUT AND THE CURRENT OPERATION IF ANY TO
;			BE COMPLETED WITH A ZERO TRANSFER COUNT FOR READ 
;			AND AS IF CONTROL O FOR WRITE.
;
;	CONTROL C --	CAUSES THE RECEIVER OF CONTROL C AST'S OR THE RECEIVER
;			OF CONTROL Y AST'S TO BE SIGNALLED AS IN CONTROL Y.
;
;	CONTROL X -- 	CAUSES THE CONTENTS OF THE TYPEAHEAD BUFFER
;			TO BE PURGED AND A CONTROL U TO BE INSERTED
;			IN THE INPUT STREAM IF A READ IS IN PROGRESS.
;
;	CONTROL S --	CAUSES ALL OUTPUT ON UNIT TO STOP UNTIL
;			CONTROL Q,Y OR C.
;
;	CONTROL Q --	RESETS CONTROL S MODE AND STARTS OUTPUT UP.
;
; SLAVE MODE ( NO UNSOLICITED INPUT ) UNITS MUST HAVE OUTSTANDING
; READS OTHERWISE THE CHARACTER, AFTER CONTROL CHARACTER FILTERING
; IS IGNORED.
;
; INPUTS:
;	R3 = CHARACTER TO BUFFER
;	R5 = UCB
;	R1,R2,R4 ARE AVAILABLE FOR USE
;
; OUTPUTS:	
;
;	R3 =	0	AND CC = ZERO
;		CHAR	AND CC = PLUS
;		ADDRESS	AND CC = NEGATIVE	
;	
;	R5 = UCB ADDRESS
;--
;
; LONG REACH TABLE
;
TAB_CHECKPRE:		BRW	CHECKPRE
TAB_CONTINT:		BRW	CONTINT
TAB_EIGHTBIT:		BRW	EIGHTBIT
TAB_OUTBAND_CHAR:	BRW	OUTBAND_CHAR
;
; MAIN LINE
;
TTY$PUTNEXTCHAR::
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATUS OF UNIT
	BITW	#TT$M_EIGHTBIT,UCB$L_DEVDEPEND(R5); 8BIT TERMINAL?
	BNEQ	TAB_EIGHTBIT		; IF NEQ THEN YES
	BICB	#^X080,R3		; STRIP 8TH BIT
	IF_STATE PASALL,TAB_CHECKPRE	; IF PASSALL THEN OPTOMIZE

	MOVZBL	UCB$B_TT_INTCNT(R5),R1	; ARE WE IN THE MIDDLE OF THE
	BNEQ	TAB_CONTINT		; THE INTERUPT KEY - YES THEN HANDLE IT
;
; CHECK FOR OUT OF BAND CHARACTER
;
	CMPB	R3,#^A/ /		; CONTROL CHARACTER?
	BLSSU	TAB_OUTBAND_CHAR	; YES THEN PROCESS IT
;	BRB	BUFFER_CHAR		; FALL INTO BUFFER CHARACTER

	.SBTTL	BUFFER_CHAR - puts character into typeahead buffer

;++
; BUFFER_CHAR - INSERT CHARACTER INTO TYPEAHEAD BUFFER
;
; FUNCTIONAL DESCRIPTION:
;
; AT THIS POINT WE KNOW THAT THE CHARACTER DOES NOT REPRESENT SOME IMMEDIATE
; ACTION.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO BUFFER
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R3,R5 ARE PRESERVED
;--
	.ENABLE	LSB
BUFFER_CHAR:				; BUFFER CHARACTER
	IF_NOT_STATE READ,40$		; IF READ THEN BUFFER CHARACTER
	IF_STATE PRE,30$		; A NOFILTER READ THEN OPTOMIZE
	BBS	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),20$; BR IF TIMEOUT
10$:
	BSBW	BUFFER_INSERT		; INSERT THE CHARACTER IN THE BUFFER

; BEGIN ECHO ON READ
;
BEGIN_ECHO:
;
; START UP OUTPUT IF NOT ALREADY STARTED
;
	BITW	#UCB$M_INT,UCB$W_STS(R5); INTERRUPT EXPECTED?
	BNEQ	16$			; IF NEQ THEN YES
	BRW	TTY$GETNEXTCHAR		; FIND THE NEXT CHARACTER FOR THIS UNIT
16$:	BRW	DISMISS			; EXIT
;
; TIMEOUT ACTIVE - RESET THE TIMER THEN FALL INTO THE NORMAL PATH
;
20$:
	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
	MOVZWL	TTY$W_RB_TIMOS(R4),R4	; GET THE NUMBER OF SECONDS
	BEQL	10$			; BR IF READ WITH ZERO SECOND TIMEOUT.
	ADDL3	R4,G^EXE$GL_ABSTIM,UCB$L_TT_RDUE(R5); RESET THE TIME
	BRB	10$			; RETURN TO THE MAIN LINE
30$:	BRW	GOPASS

;
; NO READ IS CURRENTLY ACTIVE
;
40$:	BBS	#TT$V_NOTYPEAHD,UCB$L_DEVDEPEND(R5),5$; IF SLAVED TERMINAL, IGNORE CHARACTER
	MOVL	UCB$L_TT_LOGUCB(R5),R1	; GET LOGICAL UCB ADDRESS
	TSTW	UCB$W_REFC(R1)		; UNIT REF COUNT 0?
	BEQL	50$			; IF EQL THEN JOB CONTROLLER POSSIBILITY
	TSTL	UCB$L_AMB(R1)		; USER ASSOCIATED MAILBOX?
	BEQL	10$			; IF EQL THEN NO
	BBS	#TT$V_MBXDSABL,UCB$L_DEVDEPEND(R5),10$; BR IF NOT ENABLED
	BBS	#UCB$V_TT_NOTIF,UCB$W_DEVSTS(R5),10$; BR IF ALREADY NOTIFIED
	BSBW	TTY$NOTIFY
4$:	BRW	10$
5$:	BRW	DISMISS			; CONTINUE

; Before checking terminator, check for autobaud detect

50$:	BBC	#TT2$V_AUTOBAUD,UCB$L_DEVDEPND2(R5),60$ ; Branch if no autobaud
	CMPB	#TTY$C_CR,R3		; CR MEANS THAT WE ARE CORRECT
	BEQL	65$			; SO FALL THRU
	BSBW	TTY$AUTOBAUD		; Check for correct baud rate
60$:	BBS	#TT2$V_SECURE,UCB$L_DEVDEPND2(R5),4$; DON'T EVER INITIATE
					; HERE IF SECURE SERVER IS SET
65$:	BBC	R3,W^TTY$A_STANDARD,4$	; IF NOT TERMINATOR THEN NOT FOR JOBCTLRLR
	TSTW	G^SYS$GL_JOBCTLMB+UCB$W_DEVSTS; TERMINALS ENABLED FOR JOBCTLR?
	BLEQ	5$			; IF LEQ THEN DISMISS
70$:	BSBW	TTY$NOTIFY		; NOTIFY THE JOB CONTROLER
	BSBW	BUFFER_INSERT		; BUFFER THE CHARACTER
	BBS	#UCB$V_INT,UCB$L_STS(R5),DISMISS; DON'T RETURN DATA IF INT EXPECTED
	MOVZBL	G^TTY$GB_AUTOCHAR,R3	; AND RETURN THE AUTOBAUDED CHARACTER
	BEQL	DISMISS			; NO CHARACTER TO RETURN THEN EXIT
	TIMSET	#1,R1,LOCKOUTPUT	; LOCK THE OUTPUT STREAM AND TIME OUT THE CHARACTER
	MOVB	#1,UCB$B_TT_OUTYPE(R5)	;SETUP THAT WE RETURNED DATA
	RSB				; THEN RETURN
;
; NO TYPEAHEAD BUFFER - ALLOCATE ONE
;
NO_BUFFER:				;
	MOVL	#TTY$V_FD_GETAHD,R4	; ASK FOR TYPEAHEAD FORK
	BSBW	TTY$CRE_FORK		; CREATE THE FORK FOR ALLOCATION
;
; DISMISS INTERRUPT - NOTHING TO DO
;
DISMISS:
	CLRB	UCB$B_TT_OUTYPE(R5)	; SET NO RETURN CHARACTER
	RSB				; RETURN
	.DISABLE LSB

	.SBTTL	BUFFER_INSERT - INSERT CHARACTERS INTO THE TYPEAHEAD BUFFER
;++
;
; BUFFER_INSERT - BUFFER CHARACTER IN CIRCULAR TYPEAHEAD BUFFER
;
; TEST TO SEE IF THE NUMBER OF CHARACTERS IN THE TYPEAHEAD IS CRITICAL
; THIS TEST DOES NOT WORK FOR TYPEAHEAD BUFFERS BIGGER THAN 32K BYTES.
;
; INPUTS:
;	R3 - CHARACTER TO INSERT
;	R5 - PHYSICAL UCB ADDRESS
;
; OUTPUTS:
;	NONE
;
;	R4,R1 ARE DESTROYED
;
;--
BUFFER_INSERT:
	MOVL	UCB$L_TT_TYPAHD(R5),R4	; ADDRESS TYPEAHEAD BUFFER
	BEQL	NO_BUFFER		; IF EQL THEN NONE
	BBC	#TT2$V_ALTYPEAHD,-	; SKIP IF NORMAL TYPE AHEAD SIZE
		UCB$L_DEVDEPND2(R5),55$
	
	SUBW3	G^TTY$GW_ALTALARM,G^TTY$GW_ALTYPAHD,R1	; WITHIN N CHARS OF TYPAHD FULL?
	ACBW	R1,#1,TTY$W_TA_INAHD(R4),60$		; BRANCH IF NO
	ADDW2	G^TTY$GW_ALTALARM,R1			; MAX # TYPEAHEAD CHARS
	BRB	57$					; JOIN COMMON PATH

55$:	SUBW3	#8,G^TTY$GW_TYPAHDSZ,R1		; WITHIN 8 CHARS OF TYPAHD FULL?
	ACBW	R1,#1,TTY$W_TA_INAHD(R4),60$	; BRANCH IF NO
	ADDW2	#8,R1			; MAX # TYPEAHEAD CHARS
57$:	BSBW	TTY$XOFF		; SEND XOFF
	SET_STATE <TYPFUL>		; SET UP STOP SEQUENCE
	CMPW	R1,TTY$W_TA_INAHD(R4)	; TYPEAHEAD BUFFER OVERFLOW?
	BGEQ	60$			; IF GEQ THEN NO OVERFLOW - BUFFER CHARACTER
	DECW	TTY$W_TA_INAHD(R4)	; RESET COUNT ON OVERFLOW
	SET_STATE <OVRFLO>		; INDICATE OVERFLOW CONDITION
	RSB
;
; INSERT CHARACTER IN TYPEAHEAD BUFFER
;
60$:	MOVB	R3,@TTY$L_TA_PUT(R4)	; INSERT CHARACTER IN BUFFER
	AOBLSS	TTY$L_TA_END(R4),TTY$L_TA_PUT(R4),70$; INDEX AND BR IF NOT AROUND
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_PUT(R4); RESET POINTER
70$:	RSB

	.sbttl	Put next character service routines
;
; AVOID TYPEAHEAD BUFFER FOR PASSALL MODE
;
.ENABLE LSB
CHECKPRE:
	BBC	#TT2$V_PASTHRU,UCB$L_DEVDEPND2(R5),200$; IS THIS TRUE PASSALL MODE?
	BITB	#TTY$M_CH_CTRL,TTY$A_TYPE[R3]; IS THIS A CONTROL CHAR
	BNEQ	250$			; YES THEN CHECK FOR CONTORL-S OR Q
200$:	IF_NOT_STATE PRE,220$		; NO READ WAITING THEN BUFFER THE CHARACTER
;
; Pass all optomization verifyed continue
;
GOPASS:
	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
	BBS	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),270$; BR IF NO TIMEOUT
210$:	BSBW	PASSALL			; OPTOMIZE BY SKIPING THE TYPEAHEAD
	IF_STATE	EOL,230$	; If read complete then exit
	BRW	DISMISS			; NORMAL CHARACTER THEN DISMISS THE INTERUPT
;
; READ TERMINATED
;
230$:	CLR_STATE PRE			; EOL THEN CLEAR PRE
	BRW	BEGIN_ECHO		; AND BEGIN THE EOL SEQUENCE
;
; Flow control allowed and the character could be a control-s or q
;
250$:	CMPB	TTY$A_TYPE[R3],#3!TTY$M_CH_CTRL; IS IT A CONTROL-Q
	BGTRU	200$			; NO THEN HANDLE NORMALY
	BEQL	260$			; yes then restore flow
	CMPB	TTY$A_TYPE[R3],#2!TTY$M_CH_CTRL; IS IT A CONTROL-S
	BNEQ	200$			; NO THEN EXIT
	BRW	CONTROLQ		; else stop output
260$:	BRW	CONTROLS
;
; jump to buffer the character
;
220$:	BRW	BUFFER_CHAR
;
; RESET TIMERS AND CONTINUE
;
270$:	MOVZWL	TTY$W_RB_TIMOS(R4),R1	; GET THE NUMBER OF SECONDS
	BEQL	210$			; BR IF READ WITH ZERO SECOND TIMEOUT.
	ADDL3	R1,G^EXE$GL_ABSTIM,UCB$L_TT_RDUE(R5); RESET THE TIME
	BRB	210$
	.DISABLE LSB
	.ENABLE LSB

;
; 8 BIT CHARACTER IT MAY BE A CSI
;
EIGHTBIT:
	IF_STATE PASALL,CHECKPRE	; IF WE ARE IN PASSALL MODE THEN
					; DON'T PROCESS CSI
	CMPB	#TTY$C_CSI,R3		; NO  THEN IS IT A CSI
	BNEQ	305$			; NO THEN CONTIUE NORMALY
	BRW	CSI			; ELSE TAKE CSI ACTION.
305$:	MOVZBL	UCB$B_TT_INTCNT(R5),R1	; ARE WE IN THE MIDDLE OF THE
	BEQL	310$			; THE INTERUPT KEY - YES THEN HANDLE IT

;
; CHECK FOR INTERRUPT KEY
;
CONTINT:CLRB	UCB$B_TT_INTCNT(R5)	; ASUME IT IS THE WRONG KEY
	CMPB	R3,W^INTERRUPT_KEY[R1]	; IS THIS THE NEXT CHARACTER
	BNEQ	310$			; NO THEN THE STATE IS CORRECT SO EXIT
	ADDB3	#1,R1,UCB$B_TT_INTCNT(R5); INCREMENT THE COUNT
	CMPB	UCB$B_TT_INTCNT(R5),S^#INTERRUPT_KEY_LEN
	BNEQ	310$
	CLRB	UCB$B_TT_INTCNT(R5)	; COMPLETE ESCAPE SEQUENCE THEN RESET
	BRW	CONTROLC
310$:	CMPB	R3,#^A/ /		; IS THIS CHARACTER OUT OF BAND
	BLSSU	OUTBAND_CHAR		; YES THEN HANDLE CORRECTLY
	BRW	BUFFER_CHAR		; ELSE BUFFER THE CHARACTER
	.DISABLE LSB
;
; OUT OF BAND CHARACTER PROCESSING
;
DELOUTBAND:
	MOVAL	UCB$L_TL_BANDQUE(R1),R4		; ADDRESS OF QUEUE
	PUSHL	R6				; SAVE R6
	MOVL	UCB$L_TL_CTLPID(R1),R6		; GET THE CONTROLING PID
	JSB	G^COM$DELCTRLASTP		; DELIVER ANY OUTSTANDING ASTS
	POPL	R6				; RESTORE R6
;
; CHECK FOR INCLUDE OR ABORT
;
	BBCC	#TAST$V_ABO,R3,5$		; CHECK ABORT FIRST
	MOVZWL	#SS$_CONTROLC,UCB$W_BOFF(R5)	; SET STATUS
	CLRW	UCB$W_TT_MULTILEN(R5)		; CLEAR, NO EHCO TO PREFORM
	BSBW	TTY$ABORT_IO			; ABORT I/O
	BRB	8$				; CONTINUE
5$:	BBSC	#TAST$V_INC,R3,CHECASE		; DONT STRIP CHARACTER
8$:	BRW	DISMISS		
;
; CHECK FOR CONTROL SEQUENCE CHARACTER
;
OUTBAND_CHAR:

	MOVL	UCB$L_TT_LOGUCB(R5),R1		; GET LOGICAL UCB ADDRESS
	BBS	R3,UCB$L_TL_OUTBAND(R1),DELOUTBAND; NOT IN SUMMARY MASK

CHECASE:
	CASE	W^TTY$A_TYPE[R3],TYPE=B,LIMIT=#1@TTY$V_CH_CTRL,-
		<CONTROLC,CONTROLO,CONTROLQ,CONTROLS,CONTROLX,CONTROLY,ESCAPE,CSI>
	BRW	BUFFER_CHAR

	.SBTTL	PRE-TYPEAHEAD CONTROL CHARACTER ACTION ROUTINES.
;
; ENTRY FROM CONTROLY AND CONTROLC
;
CANCEL_CTRLS:
	BSBW	TTY$RESUME		; RESUME ANY PORT OUTPUT
	BRW	BEGIN_ECHO		; BEGIN OUTPUT


	.SBTTL	CONTROLC, CONTROLY handlers
 
	.ENABL	LSB

;++
; CONTROLC - SIGNAL CONTROL C INPUT
; CONTROLY - SIGNAL CONTROL Y INPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CONTROL C OR Y IS TYPED.
; THE ACTION IS TO SIGNAL, VIA AN AST, THE HOLDER OF THE AST ENABLE.
; IF NO ENABLE IS PRESENT, AN ATTEMPT IS MADE TO SIGNAL THE JOB CONTROLLER
; IF IT HAS NOT BEEN SIGNALED.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
; 	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
;--

M_CTRLC  = 1
M_REGIS  = 2
M_DECCRT = 4

CONTROLC:				; ENTRY FOR CONTROL C
	MOVL	UCB$L_TT_LOGUCB(R5),R1	; GET LOGICAL UCB ADDRESS
	MOVAL	UCB$L_TL_CTRLC(R1),R4	; GET ADDRESS OF CONTROL C AST LIST
	TSTL	(R4)			; EMPTY?
	BEQL	10$			; IF EQL THEN NO CTRLC
	MOVZWL	#SS$_CONTROLC,UCB$W_BOFF(R5)	; SET STATUS AND ZERO COUNT
	MOVZBL	#M_CTRLC,R3		; Set "Cancel"
	BRB	15$			; Branch
;
; CONTROL Y PROCESSING
;

CONTROLY:
	MOVL	UCB$L_TT_LOGUCB(R5),R1	; GET LOGICAL UCB ADDRESS
10$:	MOVAL	UCB$L_TL_CTRLY(R1),R4	; GET ADDRESS OF CONTROL Y AST LIST
	
	TSTL	(R4)			; EMPTY LIST?
	BNEQ	13$			; No, branch forward.
	BRW	TAB_BUFFER			; Yes. Don't process it.
13$:
	MOVZWL	#SS$_CONTROLY,UCB$W_BOFF(R5)	; SET STATUS AND ZERO COUNT
	CLRL	R3			; Set "Interrupt"
	;
	; Common ^C and ^Y code
	;
15$:
	BBC	#TT2$V_DECCRT,UCB$L_DEVDEPND2(R5),18$; IS THIS A DECCRT?
	BISB	#M_DECCRT,R3		; YES THEN DO A DECCRTECHO
18$:	BBC	#TT2$V_REGIS,UCB$L_DEVDEPND2(R5),20$; IS THIS REGIS
	BISB	#M_REGIS,R3		; YES THEN GET OUT OF REGIS MODE
20$:
	IF_STATE NINTMULTI,25$		; DON'T INTERUPT THE NON-INTERUPT MULTIECHOS
	MOVL	W^TTY$A_INTECHO,R1	; FETCH TABLE POINTER
	MOVL	(R1)[R3],R3		; AND OFFSET
	MOVZBW	(R3)+,UCB$W_TT_MULTILEN(R5); SETUP THE LENGTH OF THE MULTIECHO STRING
	MOVL	R3,UCB$L_TT_MULTI(R5)	; SET UP FOR MULTIECHO
	SET_STATE NINTMULTI		; MAKE THIS ONE OF THE NON-INTERUPTABLE
					; MULTIECHO STRING
25$:	PUSHL	R6
	MOVL	UCB$L_TT_LOGUCB(R5),R6	; GET THE LOGICAL UCB ADDRESS
	MOVL	UCB$L_TL_CTLPID(R6),R6	; THEN GET THE PID
	JSB	G^COM$DELATTNASTP	; DELIVER ATTENTION ASTS FOR THIS PID
	POPL	R6

	BSBW	TTY$ABORT_IO
	BRW	CANCEL_CTRLS		; CANCEL CONTROL S AND BEGIN ECHO

	.SBTTL	CONTROLO handler

;++
; CONTROLO - START OR STOP OUTPUT ON UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TOGGLES THE OUTPUT ENABLE OF A UNIT.
; OUTPUT IS STOPPED UNTIL THE NEXT READ OPERATION, IO$_WRTCANCTRLO
; OR CONTROL O.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

M_CTRLO_DEC = 1
M_CTRLO_ON  = 2

CONTROLO:

	IF_NOT_STATE READ,120$		; IF NOT READ THEN HONOR
	IF_NOT_STATE CTRLR,TAB_DISMISS		; IF CONTROL R THEN IGNORE
120$:	XORW	#<TTY$M_ST_CTRLO>,4(R2)	; FLOP CONTROL O BIT
	IF_NOT_STATE CTRLO,OUTPUTON	; IF NOW CLEAR THEN START OUTPUT
	BSBW	TTY$ABORT		; ABORT PORT OUTPUT
	CLRL	R3			; CLEAR ECHO FLAG
	BRB	CTRLO_ECHO		; STARTUP THE OUTPUT
;
; RESTART OUTPUT ON STOPPED UNIT
;
OUTPUTON:
	MOVL	#M_CTRLO_ON,R3		; SET FLAG

CTRLO_ECHO:
	IF_STATE NINTMULTI,TAB_CANCEL_CTRLS; don't bother non-interuptable multiechos
	SET_STATE <MULTI,NINTMULTI>
	BBC	#TT2$V_DECCRT,-
    		UCB$L_DEVDEPND2(R5),150$ ; BRANCH IF NOT DECCRT
	BISW	#M_CTRLO_DEC,R3
150$:
	MOVL	W^TTY$A_CTRLOECHO,R1	; INSERT ADDRESS OF STRING
	MOVL	(R1)[R3],R3		; AND OFFSET
	MOVZBW	(R3)+,UCB$W_TT_MULTILEN(R5); SETUP THE LENGTH OF THE MULTIECHO STRING
	MOVL	R3,UCB$L_TT_MULTI(R5)	; SET UP FOR MULTIECHO
TAB_CANCEL_CTRLS:
	BRW	CANCEL_CTRLS		; RESUME OUTPUT

	.SBTTL	CONTROLQ handler

;++
; CONTROLQ - START OUTPUT ON CONTROL S STOPPED UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE STARTS OUTPUT ON A UNIT WHICH IS STOPPED BECAUSE
; OF CONTROL S.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

CONTROLQ:
	BBS	#TT$V_TTSYNC,UCB$L_DEVDEPEND(R5),-
		TAB_CANCEL_CTRLS	; TERMINAL SYNCH?
TAB_BUFFER:
	IF_STATE PRE,TAB_GOPASS		; PASSALL OPTOMIZATION
	BRW	BUFFER_CHAR		; BUFFER THE CHARACTER NORMALLY
TAB_GOPASS:
	BRW	GOPASS			

	.SBTTL	CONTROLS handler

;++
; CONTROLS - STOP OUTPUT TO UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE USER TYPES A CONTROL S.
; ON UNITS THAT DO NOT HAVE THE TT$V_TTSYNC CHARACTERISTIC, THE OUTPUT
; IS STOPPED BY TURNING THE OUTPUT INTERRUPT ENABLE BIT IN THE UCB
; OFF.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

CONTROLS:
	BBC	#TT$V_TTSYNC,UCB$L_DEVDEPEND(R5),TAB_BUFFER; TERMINAL SYNCH?
	BSBW	TTY$STOP		; STOP PORT OUTPUT
TAB_DISMISS:
	BRW	DISMISS			; AND RETURN TO DRIVER CODE

	.SBTTL	CONTROLX handler

;++
; CONTROLX - PURGE TYPEAHEAD BECAUSE OF CONTROL X INPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PURGES THE TYPEAHEAD BUFFER AND IF THE REASON IS THAT
; A CONTROL X WAS TYPED DURING A READ THEN A CONTROL U IS INSERTED IN
; THE INPUT STREAM TO PURGE THE CURRENT INPUT LINE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CONTROL U - IF CONTROL X TYPED DURING READ
;	R5 = UCB ADDRESS
;--

CONTROLX:
	BSBW	TTY$PURGE_AHEAD		; PURGE TYPEAHEAD
	IF_NOT_STATE READ,TAB_DISMISS	; DONE IF NO READ IN PROGRESS
	MOVZBL	#TTY$C_CTRLU,R3		; FORCE A CONTROL U IN INPUT STREAM
	BRW	TAB_BUFFER		; CONTINUE AND BUFFER CHARACTER

	.SBTTL	ESCAPE, CSI handler
;++
; Escape - introducer for the cancel/interrupt key
;
;--
ESCAPE:
	MOVB	#1,UCB$B_TT_INTCNT(R5)	; SET INTERRUPT COUNT
	BRW	BUFFER_CHAR
;++
; CSI - CANCEL INTERUPT INTRODUCER
;
;--
CSI:
	MOVB	#2,UCB$B_TT_INTCNT(R5)	; MOVE BY THE ESC [ IN THE STRING
	BRW	BUFFER_CHAR

	.SBTTL	End of module

	.END
