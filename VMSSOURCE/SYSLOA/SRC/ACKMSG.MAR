	.TITLE	ACKMSG - Acknowledged Message Services
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: EXECUTIVE, CLUSTER MANAGEMENT
;
; ABSTRACT: 
;	This module provides an acknowledged message service based on
;	SCS for VAX/VMS Clusters.
;
; ENVIRONMENT: VAX/VMS
;
; AUTHOR: Steve Beckhardt,	 CREATION DATE: 17-Aug-1982
;
; MODIFIED BY:
;
;	V04-001	DWT0241		David W. Thiel		7-Sep-1984
;		Close window (which occurs when a connection breaks)
;		in block transfer partner logic where the actual
;		state is not properly anticipated.
;
;	V03-022	DWT0236		David W. Thiel		10-Aug-1984
;		Update use of RDT$L_MAXRDIDX to match reinterpretation
;		of this field as the maximum index rather than the
;		number of indices (maximum+1).
;
;	V03-021	DWT0234		David W. Thiel		7-Aug-1984
;		Bugcheck on lost message detection.
;
;	V03-020	DWT0227		David W. Thiel		24-Jul-1984
;		Change warm CDRP cache limit from 3 to 2.
;
;	V03-019	DWT0215		David W. Thiel		30-Apr-1984
;		Correct missing value in CDRP$L_CDT field.
;
;	V03-018	SRB0112 DWT0183	   Steve Beckhardt / Dave Thiel 20-Mar-1984
;		Implemented new SEND_MSG design whereby only one
;		CDRP (other than block transfers) may be in a resource
;		wait state at a time.  This more rigorously preserves
;		message sequentiality and as a by-product simplifies the
;		cleanup code.  This involves a major revision of all of
;		the logical involved in sending messages.
;
;	V03-017	DWT0167		David W. Thiel		28-Feb-1984
;		Use three-state dispatch on CDRP$B_CNXSTATE whereever
;		this field is used instead of two-state dispatch.
;		Return with SS$_NODELEAVE when a message is sent
;		to a node in long_break state, rather than bugcheck.
;		Bugcheck when a message buffer is returned for an
;		undefined CSID, rather than dropping the buffer.
;		Delete routines CNX$DEALL_WARMCDRP and CNX$DEALL_MSG_BUF.
;
;	V03-016	DWT0182		David W. Thiel		28-Feb-1984
;		Return error instead of bugchecking when a message
;		is sent to a permanently broken connection.
;
;	V03-015	ADE0002		Alan D. Eldridge	14-Feb-1984
;		Initialize more CDRP fields when recycling.
;
;	V03-014	ADE0001		Alan D. Eldridge	10-Jan-1984
;		Add CSP to list of ACKMSG clients.
;
;	V03-013	DWT0155		David W. Thiel		 1-DEC-1983
;		Send all SCS messages with an explicit size computed
;		as the size of the largest message.  Perform a few
;		minor code cleanups.
;
;	V03-012	DWT0134		David W. Thiel		 5-OCT-1983
;		Correct error patch in CNX$SEND_MSG so that when an
;		invalid CSID is given, the cleanup of the CDRP will
;		BUGCHECK if a message buffer is present, rather than
;		incorrectly attempting to deallocate the message buffer.
;
;	V03-011	ROW0206		Ralph O. Weber		 8-AUG-1983
;		Cleanup bugs found in a code review and testing of block 
;		transfers:
;		  - A missing @ sign on a REMQUE in CLEANUP_PARTNERS.
;		  - Fix CNX$PARTNER_INIT_CSB to return address of message
;		    buffer in R2 as advertized.
;		  - Have CNX$PARTNER_INIT_CSB correctly init CDRP$L_CDT before 
;		    calling DEALLOC_MSG_BUF.
;		  - Fix numerous incorrect register usages in 
;		    CNX$PARTNER_INIT_CSB.
;		  - Fix incorrect MOVC3 byte count in CNX$PARTNER_INIT_CSB.
;		  - Fix CNX$BLOCK_xxxxx to get CDT address into the CDRP.
;		  - Fix CNX$RCV_MSG to save R3 when deallocating a BTX.
;		  - Correct numerous typographical errors in the comments.
;		  - Fix CNX$PARTNER_RESPOND to use a unique BTX field to save 
;		    the caller's return PC.  The new field is added to the BTX 
;		    by ROW0214.  It is required to properly handle connection
;		    failure while the response message is being sent.
;
;	V03-010	BLS0233		Benn Schreiber		 7-Aug-1983
;		Fix truncation error in CNX$BLOCK_READ_IRP.
;
;	V03-009	ROW0195		Ralph O. Weber		27-JUL-1983
;		Add CNX$PARTNER_RESPOND which responds to a block transfer 
;		request, thus closing out a block transfer operation, but 
;		returns control to the caller after the response message has 
;		been sent.
;
;	V03-008	ROW0193		Ralph O. Weber		28-JUN-1983
;		Correct calling sequence for CNX$SEND_MSG_CSB in 
;		CNX$SEND_MNY_MSGS.  Cause CNX$INIT_CDRP, CNX$ALLOC_CDRP, and 
;		CNX$ALLOC_CDRP_ONLY to initialize CDRP$B_FIPL to IPL$_SCS.
;
;	V03-007	ROW0191		Ralph O. Weber		14-JUN-1983
;		Add dispatching for GETLKI.  Add paranoia checks to broken-
;		connection cleanup.  Fix CNX$ALLOC_CDRP to return SS$_INSFMEM 
;		like the comments say it does.
;
;	V03-006	ROW0185		Ralph O. Weber		24-APR-1983
;		Add block transfer support including the following routines:
;		- CNX$BLOCK_XFER to initiate a block transfer
;		- CNX$BLOCK_XFER_IRP to initiate a block transfer with a 
;		  CDRP/IRP pair
;		- CNX$PARTNER_INIT_CSB to initialize partner portion of a 
;		  block transfer
;		- CNX$PARTNER_FINISH to complete partner portion of a block 
;		  transfer
;		- CNX$BLOCK_READ, CNX$BLOCK_WRITE, CNX$BLOCK_READ_IRP, and 
;		  CNX$BLOCK_WRITE_IRP to actually do partner block transfers
;		- CLEANUP_PARTNERS and CALL_PARTNER_ERROR to handle broken 
;		  connection recovery on partner nodes
;		Correct CNX$SEND_MNY_MSGS to not send message to the local 
;		node.
;
;	V03-005	ROW0183		Ralph O. Weber		18-APR-1983
;		Change CNX$CLEANUP, CNX$FAIL_MSG, CNX$RESEND_MSGS, and other 
;		assorted routines to use SCS lookup threads routines.  This 
;		should reduce time spent on the send message path but increase 
;		time spent in failed virtual circuit cleanup.
;
;	V03-004	ROW0179		Ralph O. Weber		 5-APR-1983
;		- Add support for use of CSIDs as input to CNX$SEND_MSG.
;		- Change incoming new message dispatching to a two level 
;		  dispatch.
;		- Setup internal allocation of a CDRP for new incoming 
;		  messages.
;		- Change CNX$DEALL_WARMCDRP to use RECYCL_RSPID.
;		- Add CNX$SEND_MNY_MSGS.
;		- Cause the sent and received message counters to be 
;		  incremented.
;		- Change CNX$ALLOC_WARMCDRP and CNX$ALLOC_CDRP to use 
;		  CSID input.  Add CNX$ALLOC_WARMCDRP_CSB.
;		- Add CNX$ALLOC_CDRP_ONLY and CNX$INIT_CDRP.
;		- Add CNX$SEND_MSG_CSB, CNX$DEALL_WARMCDRP_CSB, 
;		  CNX$DEALL_MSG_BUF, and CNX$DEALL_MSG_BUF_CSB.
;
;	V03-003	SRB0074		Steve Beckhardt		27-Mar-1983
;		Fixed bug involving resuming a thread whose CDRP
;		was on a resource wait queue when the connection broke.
;
;	V03-002	DWT0083		David W. Thiel		7-Mar-1983
;		Replace HALTs with generic connection manager
;		BUG_CHECKs.
;
;	V03-001	DWT0070		David W. Thiel		17-Feb-1983
;		Split this module out of CNXMAN as part of a general
;		rewrite and reorganization of that module.
;	
;--


	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CDRPDEF			; CDRP Offsets
	$CDTDEF				; CDT Offsets
	$CLSMSGDEF			; Cluster message offsets
	$CLUBDEF			; Cluster block
	$CLUBTXDEF			; Cluster block-xfer CDRP extension
	$CSBDEF				; CSB Offsets
	$DYNDEF				; Data structure type codes
	$IPLDEF				; IPL definitions
	$IRPDEF				; I/O request packet offsets
	$PBDEF				; PB Offsets
	$PDTDEF				; PDT Offsets
	$RDDEF				; RD offsets
	$RDTDEF				; RDT offsets
	$SSDEF				; System return codes

;
; MACROS:
;

; MACRO:  FAC_POOL
;
;	This macro creates the list of allocated pool sizes -- one for each 
;	facility -- which is used when an unsolicited message arrives.

	.MACRO	FAC_POOL LIST

	.MACRO	ONE_FAC_POOL, FAC, SIZE
	.=$$FIRST+CLSMSG$K_FAC_'FAC'
	.BYTE	SIZE
	.IIF	GT .-$$BIGEST, $$BIGEST=.
	.ENDM	ONE_FAC_POOL

$$BIGEST=.
$$FIRST:

	.IRP	ITEM, <LIST>
	ONE_FAC_POOL	ITEM
	.ENDR

	.=$$BIGEST

	.ENDM	FAC_POOL


;
; EQUATED SYMBOLS:
;

MAXWARMCDRPS = 2			; Maximum number of CDRPs to cache
					; on CSB free list

;***********************************************************************
;
; NOTE:	The following assumptions are in effect for this entire module.
;
;************************************************************************

	ASSUME	IPL$_SYNCH  EQ  IPL$_SCS

	.DEFAULT	DISPLACEMENT,WORD

	.PSECT	$$$100,LONG

;************************************************************************
;
;	DESIGN NOTES:
;
;	The key to understanding this entire module is the strategy for keeping
;	track of CDRPs and for cleaning up CDRPs when connections break.  This
;	is the result of the design of SCS and of the mainline paths through
;	this module that opt for simplicity and efficiency of the mainline paths
;	at the expense of a complicted failure cleanup and recovery.
;
;	The cells CSB$L_RESENDQFL and CSB$L_RESENDQBL form the resend list (a
;	list of all CDRPs pending transmission).  This list is organized as
;	a single linked list with a pointer to the last element in the list
;	(essentially a FIFO).  CSB$L_RESENDQFL contains the address of the
;	first member of the list or zero, if the list is empty.  CSB$L_RESENDQBL
;	contains the address of the last member of the list or the address of
;	CSB$L_RESENDQFL, if the list is empty.  This structure is used instead
;	of VAX queues because improved performance can be achieved in critical
;	code paths.  The list is organized so that new messages are added to
;	the end and the message to be sent next is taken from the front.
;
;	Similarly, the cells CSB$L_SENTQFL and CSB$L_SENTQBL form the sent list,
;	a list of all CDRPs that have been transmitted but not yet acknowledged.
;
;************************************************************************


	.SBTTL	CNX$PRE_CLEANUP - Cleanup Outstanding Messages before Disconnecting

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by SCS when a connection breaks, before
;	a DISCONNECT is done.  The connection must be open when this
;	routine is called.
;
;	Simply stated, this routines finds all CDRPs that are in various stages
;	of being sent and puts them on the CSB resend list.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$PRE_CLEANUP
;	IPL is at SCS fork level (8)
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0-R4 destroyed
;
;--

CNX$PRE_CLEANUP::

	PUSHL	R6			; Save a register.
	MOVL	R5, R6			; Copy CSB address.

; At this time, the CDRPs to be cleaned up are in the following states:
;
;	1) In critical section, waiting for RSPID, MSGBUF, or MAP with
;	   CNXSTATE = NORMAL, REQUESTOR, or PARTNER.  Only in the
;	   REQUESTOR and PARTNER states can the resource be MAP.
;	   Resources that may be held are RSPID and MSGBUF, and in the
;	   case of REQUESTORs and PARTNERs, MAP.  These messages all
;	   have non-zero sequence numbers, except for PARTNERs which
;	   have zero sequence numbers.
;
;	2) On the resend list with CNXSTATE = NORMAL, REQUESTOR, or
;	   PARTNER.  The resources that may be held are RSPID, and in
;	   the latter two cases, MAP.  These are messages awaiting
;	   transmission or retransmission.  These messages all have
;	   non-zero sequence numbers, except for PARTNERs which have
;	   zero sequence numbers.
;
;	3) On sent list with CNXSTATE = NORMAL or REQUESTOR.  The only
;	   resource that may be held is RSPID.  These are messages
;	   awaiting acknowledgement.
;
;	4) Linked to the RDT and not in any of the above states.
;	   CNXSTATE = NORMAL, REQUESTOR, or PARTNER.  In the NORMAL state,
;	   the only resource that may be held is RSPID.  In the latter
;	   cases, the resources RSPID and MAP are held.  These messages
;	   have been acknowledged but have not yet been responded to.
;	   These messages all have zero sequence numbers.
;
;	5) Linked to the PARTNER queue with CNXSTATE = REQ_MAP or PART_MAP.
;	   These CDRPs are awaiting mapping resources outside of the
;	   critical section and are on this queue only to provide a way
;	   of finding these CDRPs.  Resources help may include RSPID and
;	   MSGBUF in the case of REQ_MAP.
;
;	6) Linked to the PARTNER queue with CNXSTATE = PART_IDLE.  This is
;	   an inactive partner thread that holds no resources.
;
; The purpose of this routine is to build a RESEND list containing a CDRPs that
; may need to be resent or cleaned up, except for PARTNERs, PART_IDLEs, and
; PART_MAPs which will always be failed and which are found via the PARTNER
; queue.  The resulting RESEND list will contain (in this order):
;	a) CDRPs with sequence number = 0.  These messages have been acknowledged
;	   and should never be resent.  CNXSTATE = NORMAL or REQUESTOR.  PARTNER
;	   block transfer requests are also in this category, are never
;	   acknowledged, and never resent.
;	b) CDRPs with sequence number non-zero.  These messages may have been
;	   sent and may have been received; their disposition will be sorted
;	   out when and if the connection is reestablished.
; 
	MOVL	CSB$L_CURRCDRP(R6),R5	; Get current CDRP, if any
	BGEQ	30$			; Don't have one
	REMQUE	CDRP$L_FQFL(R5),R5	; Remove it from resource wait queue
	MOVL	R6,R3			; Set up CSB address
	BSBW	CLEANUP_CDRP		; Clean out RSPID and message buffer
	CLRQ	CDRP$L_FQFL(R5)		; Clean out queue linkage
	MOVL	CDRP$L_SAVEPC(R5),-	; Move saved PC to be fork PC so that
		CDRP$L_FPC(R5)		; thread is resumed correctly on error
	DISPATCH	CDRP$B_CNXSTATE(R5),TYPE=B,PREFIX=CDRP$K_, -
		< -
		<NORMAL,10$>, -		; Normal message, link to resend list
		<REQUESTOR,10$>, -	; Block transfer requestor, link to resend list
		<PARTNER,10$>, -	; Block transfer partner, link to resend list
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CDRP state

10$:	MOVL	CSB$L_RESENDQFL(R6), -	; Insert at head of RESEND list
		CDRP$L_FQFL(R5)
	BNEQ	20$			; Branch if not only element in list
	MOVAL	CDRP$L_FQFL(R5), -	; Make tail of list
		CSB$L_RESENDQBL(R6)
20$:	MOVAL	CDRP$L_FQFL(R5), -	; Update head pointer
		CSB$L_RESENDQFL(R6)
30$:	MOVL	#1,CSB$L_CURRCDRP(R6)	; Indicate no current CDRP, block activity

; Cleanup warm CDRPs

	MOVL	R6,R3			; Move CSB address
	BSBW	FLUSH_WARMCDRPS	

; Remove elements one-by-one from the head of the RESEND list.
; If the sequence number is non-zero, add to tail of SENT list.
; If the sequence number is zero, add to the head of SENT list.
; Finally, move SENT list to RESEND list, initialize SENT list.

40$:	MOVL	CSB$L_RESENDQFL(R6),R5	; Get first element in RESEND list
	BEQL	80$			; Branch if RESEND list is empty
	MOVL	CDRP$L_FQFL(R5), -	; Set new first element in RESEND list
		CSB$L_RESENDQFL(R6)
	BNEQ	50$			; Branch if list not empty
	MOVAL	CSB$L_RESENDQFL(R6), -	; Reinitialize tail pointer
		CSB$L_RESENDQBL(R6)
50$:	TSTW	CDRP$W_SENDSEQNM(R5)	; Is sequence number non-zero?
	BNEQ	70$			; Branch if non-zero sequence number
	;
	; Add to head of SENTQ
	;
	MOVL	CSB$L_SENTQFL(R6), -	; Link to front of SENTQ
		CDRP$L_FQFL(R5)
	BNEQ	60$			; Branch if not first element in list
	MOVAL	CDRP$L_FQFL(R5), -	; Set up SENTQ tail pointer
		CSB$L_SENTQBL(R6)
60$:	MOVAL	CDRP$L_FQFL(R5), -	; Set new head pointer for SENTQ
		CSB$L_SENTQFL(R6)
	BRB	40$

	;
	; Add to tail of SENTQ
	;
70$:	CLRL	CDRP$L_FQFL(R5)		; Zero list pointer
	MOVAL	CDRP$L_FQFL(R5), -	; Link to tail of list
		@CSB$L_SENTQBL(R6)
	MOVAL	CDRP$L_FQFL(R5), -	; Update tail pointer
		CSB$L_SENTQBL(R6)
	BRB	40$

80$:	;
	; Move SENTQ to RESENDQ.
	; Note that RESEND list is empty.
	;
	MOVL	CSB$L_SENTQFL(R6), -	; Copy head pointer
		CSB$L_RESENDQFL(R6)
	BEQL	90$			; Branch if list is empty
	MOVL	CSB$L_SENTQBL(R6), -	; Copy tail pointer
		CSB$L_RESENDQBL(R6)
90$:	;
	; Make SENTQ empty
	;
	CLRL	CSB$L_SENTQFL(R6)	; Zero head pointer
	MOVAL	CSB$L_SENTQFL(R6), -	; Initialize tail pointer
		CSB$L_SENTQBL(R6)

; Scan the PARTNER queue to:
;	a) Remove MAP waiters from their queues and clean them up.
;	b) Put idle partners onto the RESEND list.

	MOVAQ	CSB$L_PARTNERQFL(R6),R3	; Address of BTX queue header
	MOVL	R3,R4
100$:	MOVL	(R4),R4			; Next element of BTX queue
	CMPL	R3,R4			; End of list?
	BEQL	140$			; Branch when scan is done
	MOVL	CLUBTX$L_CDRP(R4),R5	; CDRP address
	DISPATCH	CDRP$B_CNXSTATE(R5),TYPE=B,PREFIX=CDRP$K_, -
		< -
		<REQ_MAP,110$>, -	; Fail map waiters
		<PART_IDLE,120$>, -	; Link to head of RESEND list
		<PART_MAP,110$>, -	; Fail map waiters
		<PARTNER,100$>, -	; Ignore partners - on other lists
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CDRP state

; Clean up map waiters
;
110$:	REMQUE	CDRP$L_FQFL(R5),R5	; Remove it from map resource wait queue
	CLRQ	CDRP$L_FQFL(R5)		; Clean out linkage
	MOVL	R7,R3			; Set up CSB address
	BSBW	CLEANUP_CDRP		; Clean up RSPID and message buffer

	; Have a CDRP waiting for mapping resources that must be failed.
	; Inputs to fork process are:
	;
	;	R0	contains 0 (failure)
	;	R3	Address of CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	;
	; Fork routine may use R0 - R5.

	PUSHR	#^M<R3,R4>		; Save registers
	MOVL	CSB$L_PDT(R3),R4	; PDT address
	CLRL	R0			; Set failure status
	JSB	@CDRP$L_FPC(R5)		; Resume fork process
	POPR	#^M<R3,R4>		; Restore registers
	BRB	100$			; Continue processing

120$:	CLRW	CDRP$W_SENDSEQNM(R5)	; Clean out sequence number (just in case)
	MOVL	CSB$L_RESENDQFL(R6), -	; Put at front of RESEND list
		CDRP$L_FQFL(R5)
	BNEQ	130$			; Branch if not first in list
	MOVAL	CDRP$L_FQFL(R5), -	; Update back pointer
		CSB$L_RESENDQBL(R6)
130$:	MOVAL	CDRP$L_FQFL(R5), -	; Update list head pointer
		CSB$L_RESENDQFL(R6)
	BRB	100$

140$:
;
; Locate and prefix onto the resend list CDRPs left in the RDT with sequence numbers
; of zero (these are messages that have been acknowledged and may have CNXSTATE =
; NORMAL, REQUESTOR, or PARTNER).
;
	ASSUME	<CSB$L_CDT+4>,EQ,CSB$L_PDT
	MOVQ	CSB$L_CDT(R6),R3	; Restore CDT and PDT address
	SCAN_RDT action=MERGE_CDRP

	MOVL	R6, R5			; Restore CSB address in R5.
	POPL	R6			; Restore saved R6.
	RSB



	.SBTTL	CNX$POST_CLEANUP - Cleanup Outstanding Messages after Disconnecting

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by SCS when a connection breaks, after
;	a DISCONNECT has completed.
;	The major purpose of this routine is to deallocate map resources.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$POST_CLEANUP
;	IPL is at SCS fork level (8)
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0-R4 destroyed
;
;--

CNX$POST_CLEANUP::

	MOVQ	R6,-(SP)		; Save some registers.
	CLRL	R7			; Sequence number checker
	MOVL	R5, R6			; Copy CSB address.
;
; Scan resend list, unmapping REQUESTORs and PARTNERs
;
	MOVL	CSB$L_RESENDQFL(R6),R5	; First CDRP in list
	BEQL	70$			; Branch when done
10$:	MOVZWL	CDRP$W_SENDSEQNM(R5),R0	; Sequence number
	BEQL	30$			; Branch if zero
	TSTW	R7			; Send a real sequence number yet?
	BNEQ	20$			; Branch if yes
	MOVW	R0,R7			; Use the first
	BRB	30$

20$:	INCW	R7			; Bump expected sequence number
	BEQL	20$			; Avoid sequence number 0

30$:	CMPW	R7,CDRP$W_SENDSEQNM(R5)	; Check ordering
	BEQL	40$			; Branch if as expected
	BUG_CHECK	CNXMGRERR,FATAL	; Mis-ordered RESEND list

40$:	DISPATCH	CDRP$B_CNXSTATE(R5),TYPE=B,PREFIX=CDRP$K_, -
		< -
		<NORMAL,60$>, -
		<REQUESTOR,50$>, -
		<PARTNER,45$>, -
		<PART_IDLE,60$>, -
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CDRP state

45$:	MOVL	CDRP$L_SAVEPC(R5), -	; Fix resumption address for
		CDRP$L_FPC(R5)		; block transfers that were in progress
	TSTW	CDRP$L_RSPID+2(R5)	; Is there a RSPID allocated?
	BEQL	50$			; Branch if no
	DEALLOC_RSPID			; Deallocate RSPID
	MOVL	#1, CDRP$L_RSPID(R5)	; Indicate that a RSPID will be needed.
50$:	ASSUME	CSB$L_PDT,EQ,<CSB$L_CDT+4>
	MOVQ	CSB$L_CDT(R6),R3	; Fetch CDT, PDT addresses
	UNMAP				; Deallocate mapping resources
60$:	CLRL	CDRP$L_CDT(R5)		; Clean out obsolete CDT address
	MOVL	CDRP$L_FQFL(R5),R5	; Link to next CDRP
	BNEQ	10$			; Continue scan

70$:	TSTW	R7			; Were any sequence numbers found?
	BEQL	80$			; Branch if no
	CMPW	R7,CSB$W_SENDSEQNM(R6)	; Must match last used number
	BNEQ	90$			; Branch on mismatch
80$:
	CLRB	CSB$B_UNACKEDMSGS(R6)	; By definition, no messages need ACKs
	MOVL	R6,R5			; CSB Address
	MOVQ	(SP)+,R6		; Restore R6 and R7
	RSB

90$:	BUG_CHECK	CNXMGRERR,FATAL	; Sequence number error


	.SBTTL	FLUSH_WARMCDRPS - Flush warm CDRP cache
;++
; FUNCTIONAL DESCRIPTION
;
;	This routine is called to deallocate all resources from all
;	all CDRPs in the warm CDRP cache.  Note that deallocating
;	resources may resume other threads.
;
; CALLING SEQUENCE:
;
;	BSBW	FLUSH_WARMCDRPS
;	IPL must be at IPL$_SCS
;
; INPUTS:
;
;	R3	Address of CSB
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Note that other threads may be resumed as we deallocate resources.
;	R0 - R2 destroyed.
;--

FLUSH_WARMCDRPS:
	PUSHR	#^M<R3,R5>
10$:	REMQUE	@CSB$L_WARMCDRPQFL(R3), R5 ; Get the next warm CDRP.
	BVS	20$			; Branch if no warm CDRPs left.
	DECB	CSB$B_WARMCDRPS(R3)	; Adjust count
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Message buffer address
	BSBW	DEALLOC_WARMCDRP	; Deallocate warm CDRP
	BRB	10$			; Loop till no more warm CDRPs.

20$:	TSTB	CSB$B_WARMCDRPS(R3)	; Make sure count is correct
	BNEQ	80$			; Error!
	POPR	#^M<R3,R5>
	RSB

80$:	BUG_CHECK	CNXMGRERR,FATAL	; Warm CDRP count and queue disagree

	.SBTTL	CLEANUP_CDRP - Routine to cleanup a CDRP
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when SCS resources held by the CDRP must
;	be deallocated.
;
; INPUTS:
;
;	R3	CSB address
;	R5	CDRP address
;
; IMPLICIT INPUTS:
;
;	It is assumed that the input CDRP makes no use of the CDRP$L_RWCPTR.  
;	That field is ignored.
;
; OUTPUTS:
;
;	None.
;
; SIDE EFFECTS:
;
;	SCS resources held by input CDRP are deallocated.  This may cause 
;	other threads to begin executing.
;
;	R0,R1,R2 are destroyed.
;--

CLEANUP_CDRP:

	PUSHR	#^M<R3,R4>		; Save registers
	CMPB	#DYN$C_CDRP, -		; Is this a CDRP structure?
		CDRP$B_CD_TYPE(R5)
	BNEQ	900$			; Branch if not a CDRP (very bad).
	ASSUME	<CSB$L_CDT+4> EQ CSB$L_PDT
	MOVQ	CSB$L_CDT(R3),R3	; CDT address, PDT address
	TSTW	CDRP$L_RSPID+2(R5)	; Holding a RSPID?
	BEQL	40$			; Branch if not holding a RSPID.
	BSBB	CHECK_RSPID		; Check for valid RSPID.
	DEALLOC_RSPID			; Deallocate the RSPID.
	MOVL	#1, CDRP$L_RSPID(R5)	; Indicate that a RSPID will be needed.
40$:
	TSTL	CDRP$L_MSG_BUF(R5)	; Is a message buffer held by CDRP?
	BEQL	50$			; Branch if no message buffer held.
	TSTL	R4			; Is PDT defined?
	BEQL	800$			; Branch if no
	DEALLOC_MSG_BUF			; Deallocate the message buffer.
50$:
	DISPATCH	CDRP$B_CNXSTATE(R5),TYPE=B,PREFIX=CDRP$K_, -
		< -
		<NORMAL,70$>, -		; Normal messages
		<PARTNER,60$>, -	; Block transfer partners
		<REQUESTOR,60$>, -	; Block transfer requestors
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Unexpected CDRP state

60$:	TSTL	R4			; PDT still defined?
	BEQL	70$			; Branch if not
	UNMAP				; Release buffer handle
70$:	POPR	#^M<R3,R4>		; Restore registers
	RSB

800$:	BUG_CHECK	CNXMGRERR,FATAL	; Can't deallocate resource

900$:	BUG_CHECK	CNXMGRERR,FATAL	; Data structure not a CDRP.

	.SBTTL	CHECK_RSPID - Validate RSPID in given CDRP
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine validates the RSPID in the CDRP whose address is in R5.  
;	If the RSPID in the CDRP cannot be located in the RDT or if the RDT 
;	entry associated with the RSPID points to something other that in 
;	given CDRP, the system is bugchecked.
;
; INPUTS:
;
;	R5	Address of a CDRP
;
; IMPLICIT INPUTS:
;
;	CDRP$L_RSPID(R5) a RSPID
;	The RDT.
;
; OUTPUTS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	R0 and R1 destroyed.
;	All other registers preserved.
;
; SIDE EFFECTS:
;
;	System is bugchecked if error is located in RSPID.
;--

CHECK_RSPID:

	PUSHL	R5			; Save input CDRP address.
	MOVL	CDRP$L_RSPID(R5), R5	; Get RSPID.
	FIND_RSPID_RDTE			; Locate RDTE for this RSPID.
	BLBC	R0, 900$		; Branch if lookup failed.
	CMPL	RD$L_CDRP(R5), (SP)	; Is the CDRP address right.
	BNEQ	900$			; Branch if address is wrong.
	POPL	R5			; Restore CDRP address.
	RSB				; Return to caller.

900$:	BUG_CHECK	CNXMGRERR,FATAL	; RSPID is wrong.

	.SBTTL	MERGE_CDRP - Scan action routine to merge a CDRP
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This action routine is called when a CDRP thread is located in the RDT 
;	after all other processing has been completed.  This routine finds CDRPs
;	that have been acknowledged and are no longer on the SENT list as well
;	as CDRPs that have not yet been ackowledged and are still on the SENT
;	list.  Acknowledged CDRPs can be identified by fact that they have a
;	zero send sequence number.  Acknowledged CDRPs are inserted onto the
;	head of the RESEND list in no particular order.  Note that block
;	transfer requests always look as though they have been acknowledged
;	and are never on the SENT list.
;
; INPUTS:
;
;	R3	CDT address
;	R4	PDT address
;	R5	located CDRP address
;
; IMPLICIT INPUTS:
;
;	CDT$L_AUXSTRUC(R3) CSB address (we could use R6, but that would assume 
;	that the SCS lookup routines do not corrupt it).
;
;	The input CDRP is assumed to be on the SENT list if the sequence number
;	is non-zero and on no list or queue if the sequence number is zero.
;
;	It is assumed that the RSPID held by this located CDRP has been 
;	transmitted to a remote node and must be retained for future 
;	identification of the response from that node.
;
;	It is assumed that the input CDRP makes no use of the CDRP$L_RWCPTR.  
;	That field is ignored.
;
; OUTPUTS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	If the sequence number is zero, indicating a CDRP not on the SENT list,
;	the input CDRP is inserted at the head of the CSB resend list.
;
; SIDE EFFECTS:
;
;	None.
;--

MERGE_CDRP:

	CMPB	#DYN$C_CDRP, -		; Is this a CDRP structure?
		CDRP$B_CD_TYPE(R5)
	BNEQ	900$			; Branch if not a CDRP (very bad).
	BSBB	CHECK_RSPID		; Validate the RSPID.

	DISPATCH	CDRP$B_CNXSTATE(R5),TYPE=B,PREFIX=CDRP$K_, -
		< -
		<NORMAL,20$>, -		; Normal message
		<REQUESTOR,20$>, -	; Block transfer request
		<PARTNER,10$>, -	; Block transfer partner
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CDRP state

10$:	MOVAB	B^40$,CDRP$L_FPC(R5)	; Set up completion address
20$:	MOVL	CDT$L_AUXSTRUC(R3), R2	; Get CSB address.
	TSTW	CDRP$W_SENDSEQNM(R5)	; If nonzero, ignore this CDRP
	BNEQ	40$
	MOVL	CSB$L_RESENDQFL(R2), -	; Link to head of RESEND list
		CDRP$L_FQFL(R5)
	BNEQ	30$			; Branch if list already populated
	MOVAL	CDRP$L_FQFL(R5), -	; Set up tail pointer
		CSB$L_RESENDQBL(R2)
30$:	MOVAL	CDRP$L_FQFL(R5), -	; Set up new head pointer
		CSB$L_RESENDQFL(R2)
40$:	RSB

900$:	BUG_CHECK	CNXMGRERR,FATAL	; Data structure not a CDRP.

	.SBTTL	CNX$FAIL_MSG - Complete outstanding I/O with failure status
;++
; FUNCTIONAL DESCRIPTION:
;
;	All un-acked messages have their fork process resumed with
;	a failure status.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$FAIL_MSG
;	IPL must be at IPL$_SCS 
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed.
;--

CNX$FAIL_MSG::
	PUSHR	#^M<R2,R3,R4,R5,R6>	; Save registers
	MOVL	R5,R6			; Move address of CSB
10$:	MOVL	CSB$L_RESENDQFL(R6),R5	; Remove CDRP from head
	BEQL	60$			; Queue empty
	MOVL	CDRP$L_FQFL(R5), -	; Update queue head
		CSB$L_RESENDQFL(R6)
	BNEQ	20$			; Branch if queue not empty
	MOVAL	CSB$L_RESENDQFL(R6), -	; Update end pointer
		CSB$L_RESENDQBL(R6)
20$:	CLRQ	CDRP$L_FQFL(R5)		; Zap queue linkage
	CLRL	CDRP$L_CDT(R5)		; Invalidate CDT address
	TSTW	CDRP$L_RSPID+2(R5)	; Is there a RSPID?
	BEQL	30$			; Branch if no RSPID
	DEALLOC_RSPID
	MOVL	#1,CDRP$L_RSPID(R5)	; Set RSPID neeed flag
30$:	MOVZWL	#SS$_NODELEAVE,R0	; Indicate error to fork process
	MOVL	R6,R3			; Restore CSB address
	CLRL	R4			; Bug trap

	; Resume Fork process.  Inputs are:
	;
	;	R0	SS$_NODELEAVE (Indicates failover)
	;	R3	Address of CSB
	;	R5	Address of CDRP

	JSB	@CDRP$L_FPC(R5)		; Resume fork process
	BRB	10$			; Continue until queue is empty

60$:	POPR	#^M<R2,R3,R4,R5,R6>	; Restore registers
	RSB	

	.SBTTL	CNX$RESEND_MSGS - Resend messages

; ++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine uses the the last sequence number the remote
;	side received to resume the fork process for all messages
;	that have been acked and to resend all messages that weren't
;	acked.  In addition all messages that have been queued since the
;	previous connection broke are sent.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$RESEND_MSGS
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	CSB$W_ACKRSEQNM contains last sequence number (of ours) received by
;	remote side  (equivalent to CLSMSG$L_ACKSEQ).
;
;	It is assumed that the resend queue contains only normal and block 
;	transfer requestor CDRPs.
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0, and R1 are destroyed
;--

CNX$RESEND_MSGS::

	; Remove CDRPs from the CSB RESEND queue.  For each CDRP,
	;	a)  If its sequence number is zero, reset the CDT address,
	;	    remove the CDRP from the list, and forget it.
	;	b)  If its sequence number is less than or equal to the acked
	;	    sequence number, then if it doesn't have a RSPID
	;	    then resume its fork process.  If it does have a RSPID,
	;	    then reset the CDT address and skip over it.
	;	c)  if its sequence number is greater than the acked
	;	    sequence, then resend it.
	; This loop is terminated as soon as we find the first CDRP to resend

	PUSHR	#^M<R2,R3,R4,R5,R7>
	MOVL	R5,R7			; Address of CSB
10$:	MOVL	CSB$L_RESENDQFL(R7),R5	; Get the next CDRP
	BEQL	80$			; Branch if no more
	MOVZWL	CDRP$W_SENDSEQNM(R5),R0	; CDRP's sequence number
	BEQL	20$			; Branch if there is no sequence number
	SUBW	CSB$W_ACKRSEQNM(R7),R0	; Compare with acknowledged sequence number
	BGTR	80$			; Branch if it has not been ack'ed
20$:	MOVL	CDRP$L_FQFL(R5), -	; Update list head pointer
		CSB$L_RESENDQFL(R7)
	BNEQ	30$			; Branch if list not empty
	MOVAL	CSB$L_RESENDQFL(R7), -	; Point end at list head
		CSB$L_RESENDQBL(R7)
30$:	DISPATCH	CDRP$B_CNXSTATE(R5),TYPE=B,PREFIX=CDRP$K_, -
		< -
		<NORMAL,50$>, -		; If normal message
		<REQUESTOR,50$>, -	; If block transfer
		<PARTNER,40$>, -	; Fail partner
		<PART_IDLE,40$>, -	; Fail idle partner
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Inconsistent state -- should never get here

40$:
	; Have a PARTNER-type CDRP that must be failed.
	; Inputs to fork process are:
	;
	;	R0	contains 0 (failure)
	;	R3	Address of CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	;
	; Fork routine may use R0 - R5.

	MOVL	R7,R3			; CSB address
	MOVL	CSB$L_PDT(R3),R4	; PDT address
	CLRL	R0			; Set failure status
	JSB	@CDRP$L_FPC(R5)		; Resume fork process
	BRB	10$			; Continue processing

50$:
;
; Have a CDRP with a non-zero sequence number
;
	MOVL	CSB$L_CDT(R7), -	; Update CDT address in CDRP
		CDRP$L_CDT(R5)
	TSTW	CDRP$L_RSPID+2(R5)	; Is there a RSPID?
	BEQL	60$			; Branch if no RSPID
	CLRW	CDRP$W_SENDSEQNM(R5)	; Flag it acknowledged
	BRB	10$			; Note that the RDT still point this this one

60$:	TSTW	CDRP$W_SENDSEQNM(R5)	; Is there a sequence number?
	BEQL	70$			; Branch and bugcheck if no sequence number

	; Have a CDRP whose message has been ack'ed and who doesn't
	; have a response id.  Inputs to fork process are:
	;
	;	R0	contains 1 (successful acknowledge)
	;	R3	Address of CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	;
	; Fork routine may use R0 - R5.

	MOVL	R7,R3			; CSB address
	MOVL	CSB$L_PDT(R3),R4	; PDT address
	MOVL	#SS$_NORMAL,R0		; Get successful acknowledge
	JSB	@CDRP$L_FPC(R5)		; Resume fork process
	BRB	10$			; process and continue

70$:	BUG_CHECK	CNXMGRERR,FATAL	; Missing sequence number

80$:
	; Resend any messages that must be resent.
	; If there are no messages to resend, this will zero CURRCDRP
	; and allow future messages to go through.

	MOVL	R7,R3			; Set up CSB address
	BSBW	RESEND_MSG		; Resend it and start pipeline

	POPR	#^M<R2,R3,R4,R5,R7>
	RSB

	.SBTTL	CNX$SEND_MSG - Send an acknowledged message
	.SBTTL	CNX$SEND_MSG_CSB - Send a message using CSB
	.SBTTL	CNX$SEND_MSG_RSPID - Send a message with response id
	.SBTTL	CNX$SEND_MSG_RESP - Send a message & recycle message buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends an acknowledged message.  An acknowledged message
;	is one that is guaranteed to be received by VMS at the remote
;	system or a failover is initiated.  The message is automatically
;	resent if the connection breaks and another connection is 
;	subsequently established to the same system and software
;	incarnation.  Furthermore, the caller of this routine is returned
;	to when the message has been acknowledged.  The caller's caller
;	is returned to immediately.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$SEND_MSG		Send a message
;	BSBW	CNX$SEND_MSG_CSB	Send a message using CSB address
;	BSBW	CNX$SEND_MSG_RSPID	Send a message with response id
;	BSBW	CNX$SEND_MSG_RESP	Send a message and recycle message bfr
;	BSBW	RESEND_MSG		Internal entry point (used for resends)
;	BSBW	SEND_UNSEQ_MSG		Internal entry point (used for block transfer)
;
;	This routine returns to its caller when the message has been
;	acknowledged.  It returns to its caller's caller immediately.
;	The standard fork process convention that the caller must not
;	push anything onto the stack is in effect.
; 	An exception is when R0 contains SS$_NOSUCHNODE return status. 
;	In this case, the return address of the caller's orginal caller is
;	still on the top of the stack.  In some cases, this may require
; 	special action on the part of this routine's caller.
;	The other exception is one case of SS$_NODELEAVE.  When an attempt
;	is made to send a message to a node in the LONG_BREAK state, a
;	synchronous return is made with the stack in the condition just
;	described.
;
;	IPL must be at IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer (CNX$SEND_MSG_RESP entry only)
;	R3	CSID (for all routines except CNX$SEND_MSG_CSB)
;	R3	CSB (CNX$SEND_MSG_CSB only)
;	R5	Address of CDRP
;
; IMPLICIT INPUTS:
;
;	CDRP$L_MSGBLD must contain the address of a message build routine.
;
;	CDRP$L_RSPID must contain one of the following values:
;		0		No RSPID allocated and none needed
;		1		No RSPID allocated but one is needed
;		A valid RSPID	A RSPID is needed and is already allocated.
;
;	CDRP$L_MSG_BUF must contain a valid message buffer address or zero.
;
;	Any information that the message build routine requires should
;	be in the CDRP or pointed to by pointers in the CDRP.
;
;	This routine requires that several CDRP fields be initialized to zero. 
;	CNX$INIT_CDRP should be called to perform this initialization.
;
;
; OUTPUT PARAMETERS:
;
;	R0	Status
;		    SS$_NORMAL ==> Message successfully acknowledged 
;				(if response requested, response received)
;		    SS$_NOSUCHNODE ==> Invalid CSID (Not possible for 
;				CNX$SEND_MSG_CSB.  N.B. no fork occurs in 
;				this case)
;		    SS$_NODELEAVE ==> Requested node is leaving the cluster
;				or you are (a fork may or may not have occurred)
;	R2	Message buffer address
;				(if response requested and R0 = SS$_NORMAL)
;	R3
;		If status is anything but SS$_NOSUCHNODE :	CSB
;		If status is SS$_NOSUCHNODE :			CSID
;	R4
;		If status is SS$_NOSUCHNODE :			unchanged
;		If status is SS$_NODELEAVE (synchronous return) :	0
;		In all other caes :				PDT address
;	R5	CDRP address
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R2 and R4 are destroyed.
;
;--

	.ENABLE	LSB

;
; Error in input CSID.  
;	Cleanup allocated SCS resources and return SS$_NOSUCHNODE immediately.
;
; N.B. This is the synchronous return from CNX$SEND_MSG.  See notes in 
; module header above.
;

SEND_CSID_ERROR:
	MOVZWL	#SS$_NOSUCHNODE,-(SP)	; Set bad CSID error status.
	BRB	20$			; Cleanup and return synchronously


10$:	BSBW	FLUSH_WARMCDRPS		; Flush warm CDRP cache
	TSTL	CSB$L_CURRCDRP(R3)	; Increment count again
	BEQL	SEND_MSG_NOWAIT		; Don't wait after all
	BSBW	CLEANUP_CDRP		; Deallocate RSPID, MAP, and MSGBUF resources
	TSTL	CSB$L_CURRCDRP(R3)	; Increment count again
	BEQL	SEND_MSG_NOWAIT		; Don't wait after all
	CLRB	CSB$B_UNACKEDMSGS(R3)	; Prevent explicit ACK attempts
	POPL	CDRP$L_FPC(R5)		; Save our caller's PC in fork block
	CLRL	CDRP$L_FQFL(R5)		; Zero end of list
	MOVL	R5,@CSB$L_RESENDQBL(R3)	; Link this CDRP at end of list
	MOVL	R5,CSB$L_RESENDQBL(R3)	; Update end of list pinter
	RSB				; Return to caller's caller

CDRP_MUST_WAIT:
	; Another CDRP is in resource wait or the connection is currently 
	; down.  Place CDRP on resend queue and return to our caller's caller.
	;
	; NOTE:  The warm CDRP cache must be flushed AFTER we insert
	; this CDRP on the queue for the following reason.  Flushing the
	; cache (and the resources in this CDRP) may free up the waiting
	; thread which will in turn try to resume other waiters.  It may
	; seem that the correct solution to this is to insert this CDRP
	; on the RESEND queue BEFORE flushing the cache.  The reason this
	; doesn't work is that we can't deallocate both the RSPID and message
	; buffer atomically.  In other words, deallocation of the RSPID
	; might start up this very CDRP (if it were on the queue) before
	; the RSPID field had been set to 1 and before the message buffer
	; had been deallocated.  This problem could be circumvented (and
	; the cache flushed after the INSQUE) if we could deallocate the RSPID
	; with a register entry point (message buffers already can be 
	; deallocated with a register entry point).  Then we could pick up
	; the resources, initialize the CDRP, and then deallocate the
	; resources.  This, in turn, might start up the very CDRP we had
	; just INSQUEd.

	BBC	#CSB$V_LONG_BREAK, -	; Try to free resources if no long
		CSB$L_STATUS(R3),10$	;   connection break has yet occurred
	MOVZWL	#SS$_NODELEAVE,-(SP)	; Return status
20$:	TSTL	CDRP$L_MSG_BUF(R5)	; Is there a message buffer?
	BNEQ	40$			; Branch if buffer present.
	TSTW	CDRP$L_RSPID+2(R5)	; Is there a RSPID allocated?
	BEQL	30$			; Branch if no RSPID allocated.
	DEALLOC_RSPID			; Else, deallocate RSPID.
	MOVL	#1, CDRP$L_RSPID(R5)	; Indicate that a RSPID will be needed.
30$:	POPR	#^M<R0>			; Fetch return status
	RSB				; Return synchronously to caller.

40$:	BUG_CHECK	CNXMGRERR,FATAL	; CDRP contains message buffer which 
					; can not be deallocated without 
					; CSB / PDT context
	.DISABLE	LSB
	.ENABL	LSB

CNX$SEND_MSG_RSPID::
	MOVL	#1,CDRP$L_RSPID(R5)	; Indicate a RSPID is needed
	BRB	CNX$SEND_MSG

CNX$SEND_MSG_RESP::
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Save message buffer address
	MOVL	CLSMSG$L_RSPID(R2),-	; Store RSPID to return in CDRP
		CDRP$L_RETRSPID(R5)

CNX$SEND_MSG::

	; First determine if the connection is open.  If not, the CDRP
	; is simply placed on the resend queue.  If the connection comes back, 
	; we will build and send the message then.  Otherwise we will 
	; do a failover.  If the connection is open then save
	; our caller's return PC in the CDRP in case SCS calls (e.g.
	; ALLOC_MSG_BUF OR ALLOC_RSPID) wait and return to our caller's 
	; caller.  
	; Finally, prepare to call message build routine.  Put the PDT address 
	; in R4, the CDT address in the CDRP, conditionally allocate a 
	; response id., and allocate or recycle a message buffer.

	CSID_TO_CSB csb=R3, error=SEND_CSID_ERROR

CNX$SEND_MSG_CSB::
5$:	INCW	CSB$W_SENDSEQNM(R3)	; Increment sequence number
	BEQL	5$			; Don't use zero as a sequence number
	MOVW	CSB$W_SENDSEQNM(R3),-	; Put sequence number into the CDRP
		CDRP$W_SENDSEQNM(R5)

	; The block transfer code enters here to send an unsequenced message
	; requesting data movement using the common resource allocation /
	; cleanup apparatus.

SEND_UNSEQ_MSG:
	MOVL	CSB$L_CDT(R3),-		; Put CDT address into CDRP
		CDRP$L_CDT(R5)

	; The following code begins a critical section meaning only one
	; CDRP thread may be in this section at a time.

	TSTL	CSB$L_CURRCDRP(R3)	; Branch if critical section is locked (>0)
	BNEQ	CDRP_MUST_WAIT		; or busy (<0)
SEND_MSG_NOWAIT:			; Return here if we don't wait after all
	MOVL	R5,CSB$L_CURRCDRP(R3)	; This becomes the "current" CDRP
	POPL	CDRP$L_SAVEPC(R5)	; Save return PC 

	MOVL	CSB$L_PDT(R3),R4	; Get PDT address

SEND_ALLOC:

	; Allocate resources

	TSTL	CDRP$L_RSPID(R5)	; Is a response id needed?
	BEQL	10$			; Branch if no
	TSTW	CDRP$L_RSPID+2(R5)	; Yes, is a response id allocated?
	BNEQ	10$			; Branch if yes
	ALLOC_RSPID			; No, allocate a response id.
10$:	TSTL	CDRP$L_MSG_BUF(R5)	; Is there already a message buffer?
	BEQL	20$			; Branch if no
	RECYCL_MSG_BUF			; Yes, recycle it
	BLBS	R0,30$			; Branch if no error
15$:	BUG_CHECK	CNXMGRERR,FATAL	; Error allocating/recycling message buffer

20$:	ALLOC_MSG_BUF			; Allocate a message buffer
	BLBC	R0,15$			; Branch on error

30$:	; Now call the message build routine.  Inputs to this routine are:
	;
	;	R2	Address of message buffer
	;	R3	Address of CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	;
	;	R0 and R1 may be destroyed.  Everything else must be preserved.

	JSB	@CDRP$L_MSGBLD(R5)	; Call message build routine

	; Add message header.  This consists of this message's sequence
	; number and the last received sequence number from the remote side.

	MOVW	CSB$W_RCVDSEQNM(R3), -	; Get highest received (remote) sequence
		CLSMSG$W_ACKSEQ(R2)	; and return acknowledgement.
	MOVW	CDRP$W_SENDSEQNM(R5), -	; Get sequence number for this message
		CLSMSG$W_SEQNUM(R2)
	CLRB	CSB$B_UNACKEDMSGS(R3)	; Zero count of un-acked messages

	; Now send the message.  If there is a response id. then SCS will
	; set up the fork block so we have to make it appear
	; as if our caller called SEND_MSG_BUF.  Otherwise, we set up
	; the fork block.

	CLRL	CDRP$L_FQFL(R5)		; Clear linkage
	MOVL	R5,@CSB$L_SENTQBL(R3)	; Link to tail of sent list
	MOVL	R5,CSB$L_SENTQBL(R3)	; Update tail pointer
	MOVL	CDRP$L_RSPID(R5),R0	; Get response id. (if there is one)
	BEQL	50$			; No response id.

	MOVL	R0,CLSMSG$L_RSPID(R2)	; Store response id in message
	PUSHAL	B^60$			; Place to return to after send
	PUSHL	CDRP$L_SAVEPC(R5)	; Put our caller's PC back on the stack
	ASSUME	CLSMSG$K_MAXMSG,LT,256
	MOVZBL	#CLSMSG$K_MAXMSG,R1	; Message size
	JMP	@PDT$L_SNDCNTMSG(R4)	; This is a JMP to SEND_CNT_MSG_BUF rather
					; than a JSB

	; The following two named routines are special message build routines
	; to handle block transfer requests.  They replace the message build
	; routine and all following code.
	;
SEND_DATA:
	CLRW	CDRP$W_SENDSEQNM(R5)	; No sequence number
	MOVAB	B^60$,(SP)		; Replace message build routine return
	PUSHAB	B^100$			; Return point when transfer complete
	JMP	@PDT$L_SENDDATA(R4)	; This is a JMP to request data movement

REQUEST_DATA:
	CLRW	CDRP$W_SENDSEQNM(R5)	; No sequence number
	MOVAB	B^60$,(SP)		; Replace message build routine return
	PUSHAB	B^100$			; Return point when transfer complete
	JMP	@PDT$L_REQDATA(R4)	; This is a JMP to request data movement

50$:	MOVL	CDRP$L_RETRSPID(R5),-	; Store return RSPID (or 0)
		CLSMSG$L_RSPID(R2)
	ASSUME	CLSMSG$K_MAXMSG,LT,256
	MOVZBL	#CLSMSG$K_MAXMSG,R1	; Message size
	SEND_CNT_MSG_BUF
	MOVL	CDRP$L_SAVEPC(R5),-	; Put our caller's return PC into
		CDRP$L_FPC(R5)		; CDRP fork block

60$:	; Come here after message has been sent to see if we have to resume
	; any CDRPs that were placed on the RESEND queue.  This represents
	; the end of the critical section.  Also come here to initiate
	; resending messages when a connection is re-opened.

RESEND_MSG:
	MOVL	CSB$L_RESENDQFL(R3), -	; Update current CDRP
		CSB$L_CURRCDRP(R3)
	BNEQ	70$			; Have a waiter
	RSB

70$:	; Resume a waiting CDRP thread.

	MOVL	CSB$L_RESENDQFL(R3),R5	; Get next waiting CDRP
	MOVL	CDRP$L_FQFL(R5), -	; Update list head pointer
		CSB$L_RESENDQFL(R3)
	BNEQ	80$			; Branch if list not yet empty
	MOVAL	CSB$L_RESENDQFL(R3), -	; Update list tail pointer
		CSB$L_RESENDQBL(R3)
80$:
	MOVL	CDRP$L_FPC(R5),-	; Use original caller's return address
		CDRP$L_SAVEPC(R5)	; as the saved PC
	MOVL	CSB$L_PDT(R3),R4	; Get PDT address
	MOVL	CSB$L_CDT(R3),-		; Put CDT address into CDRP
		CDRP$L_CDT(R5)
	DISPATCH  CDRP$B_CNXSTATE(R5),type=B,prefix=CDRP$K_ -
		<-
		<NORMAL,SEND_ALLOC>, -	; Normal messages
		<REQUESTOR,90$>, -	; Block transfer requestor messages
		<PARTNER,90$>, -	; Block transfer partner messages
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CNX state

90$:	MOVAL	CDRP$L_CNXSVAPTE(R5),R1	; Get SVAPTE block address
	MOVZBL	CDRP$B_CNXRMOD(R5),R2	; Get requestor's access mode
	MAP				; Map transfer block
	BRW	SEND_ALLOC		; Join normal message resend code

; Get here when block transfer request completes
;
100$:	PUSHL	R0			; Save status
	UNMAP				; Unmap buffer
	POPR	#^M<R0>			; Restore status
	JMP	@CDRP$L_SAVEPC(R5)	; Return to caller

	.DSABL	LSB

	.SBTTL	CNX$SEND_MNY_MSGS - Send acknowledged messages to all nodes
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends acknowledged messages to all nodes having valid CSB 
;	addresses in the cluster system vector.  The messages are sent using 
;	multiple concurrent fork threads executing the CNX$SEND_MSG 
;	acknowledged message service.
;
;	NOTE:
;
;	  o No attempt is made to detect pending changes in the cluster system 
;	    vector.
;
;	  o Error status returns from the acknowledged message facility, i.e. 
;	    failing or failed systems, are ignored.
;
;	This routine will "broadcast" a message to all currently active 
;	systems.  However, systems just entering or leaving the cluster may be 
;	missed.  Callers of this routine are completely responsible for 
;	handling "missed" systems.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$SEND_MNY_MSGS	Send many messages
;
;	This routine returns to its caller when the all messages have been 
;	queued for processing  by the CNX$SEND_MSG.  This does not guarantee 
;	that all messages have been received at remote nodes.  Because of the 
;	nature of CNX$SEND_MSG operation when no response is required, waiting 
;	for all messages to be received and acknowledged at the remote nodes 
;	could result in wait intervals of days.
;
;	If a wait for resources is necessary, control may be returned to the 
;	caller's caller before control is returned to the caller.
;
;	IPL must be at IPL$_SCS
;
; INPUT PARAMETERS:
;
;	00(SP)	Return address for caller
;	04(SP)	Return address for caller's caller
;	R5	Address of CDRP
;
; IMPLICIT INPUTS:
;
;	CDRP$L_MSGBLD must contain the address of a message build routine.
;
;	CDRP$B_FIPL must contain IPL$_SCS
;
;	Because return from this routine does not guarantee that the message 
;	build routine will never be called again, any information required by 
;	the message build routine should be contained completely in the CDRP 
;	or in data structures which will never disappear.
;
;	This routine requires that several CDRP fields be initialized to zero. 
;	CNX$INIT_CDRP should be called to perform this initialization.
;
;	CLU$GL_CLUSVEC	starting address of the cluster system vector
;	CLU$GW_MAXINDEX	maximum CSID index
;
; OUTPUT PARAMETERS:
;
;	R5	CDRP address (unchanged)
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R4 are destroyed.
;
;--

CNX$SEND_MNY_MSGS::

	POPL	CDRP$L_SAVEPC(R5)		; Save caller's return address.
	MOVL	G^CLU$GL_CLUSVEC, R4		; Get cluster system vec. base.
	MOVZWL	G^CLU$GW_MAXINDEX, R3		; Get max CSID index.
10$:	SOBGTR	R3, 30$				; Loop through entire cluster 
						; system vector except idx. 0.
	JMP	@CDRP$L_SAVEPC(R5)		; Return to caller.

;
; Error allocating memory for CDRP.
;

20$:	FORK_WAIT				; Wait a little while.

;
; Send message to one node
;
30$:	MOVL	(R4)[R3], R0			; Get system vector entry.
	BGEQ	10$				; Branch if not valid CSB addr.
	BBS	#CSB$V_LOCAL, -			; Branch if this is the local node.
		CSB$L_STATUS(R0),10$

	MOVL	R0, CDRP$L_CDT(R5)		; Save CSB of entry.

	MOVZBL	#CDRP$K_CM_LENGTH, R1		; Get size of needed CDRP.
	JSB	G^EXE$ALONONPAGED		; Allocate memory for the CDRP.
	BLBC	R0, 20$				; Branch if allocation failed.

	ASSUME	CDRP$B_CD_TYPE EQ <CDRP$W_CDRPSIZE + 2>
	MOVW	R1, CDRP$W_CDRPSIZE(R2)		; Set allocation size.
	PUSHR	#^M<R2,R3,R4,R5>		; Save more registers.
	MOVC3	#<CDRP$K_CM_LENGTH-CDRP$B_CD_TYPE>,-	; Copy rest of user's 
		CDRP$B_CD_TYPE(R5), CDRP$B_CD_TYPE(R2)  ; CDRP to new CDRP.

	POPL	R5				; Restore new CDRP address.
	MOVL	CDRP$L_CDT(R5), R3		; Restore saved CSB address.
	PUSHAB	B^60$				; Set caller's caller address.
	BSBW	CNX$SEND_MSG_CSB		; Send this message.

						; Control returns here when 
						; the message is acknowledged.
	MOVL	R5, R0				; Copy CDRP address.
	JMP	G^EXE$DEANONPAGED		; Deallocate it and return.

						; Control returns here when 
						; message is queued.
60$:	POPR	#^M<R3,R4,R5>			; Restore saved registers.
	BRB	10$				; Go process next index.


	.SBTTL	CNX$RCV_MSG - Receive message routine

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is the message input routine.  I.e. SCS calls
;	this routine when a message has been received over our 
;	connection.  This routine firsts looks at the acknowledge
;	sequence number and calls any fork processes waiting for message
;	acknowledgement.  It then determines if this message is a
;	response for a message we sent.  If it is, that fork process
;	is resumed.  Otherwise, this message must be an unsolicited
;	message in which case the appropriate function routine is called.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCV_MSG	(called from fork dispatcher)
;	IPL is at IPL$_SCS
;	This routine operates as a fork process.
;
; INPUT PARAMETERS:
;
;	R1	Length of message
;	R2	Address of message
;	R3	Address of CDT
;	R4	Address of PDT
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.ENABL	LSB

; Connection is not open, drop message and return
;
10$:	CMPB	#CSB$K_DISCONNECT, -	; Is connection disconnecting?
		CSB$B_STATE(R3)
	BNEQ	20$			; Branch if not disconnecting
	BRW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer and return

20$:	BUG_CHECK	CNXMGRERR,FATAL	; Connection in unexptected state

; Sequence number error in received message
;
30$:	SUBW3	CSB$W_RCVDSEQNM(R3),-	; Verify that this is a missing
		CLSMSG$W_SEQNUM(R2),R0	;   message sequence number
	BLSS	40$			; Branch if not a missing message

;	BRW	CNX$RCV_REJECT		; Reject message and return
	BRW	40$			; *** temp to catch problems -- bugcheck on lost message

40$:	BUG_CHECK	CNXMGRERR,FATAL	; Repeated or garbage sequence number

; Acknowledged message sequence number precedes previous number
;
50$:	BUG_CHECK	CNXMGRERR,FATAL ; Out of order acknowledgement

CNX$RCV_MSG::
	MOVL	CDT$L_AUXSTRUC(R3),R3	; Get address of CSB
	CMPB	#CSB$K_OPEN, -		; Is connection open?
		CSB$B_STATE(R3)
	BNEQ	10$			; Branch if not open

	; Verify the sequence number on this message is 1 greater
	; than the last we received.  Update the received sequence number
	; field.  Determine if the ack'ed sequence number is greater
	; than the last sequence number ack'ed.

110$:	INCW	CSB$W_RCVDSEQNM(R3)	; Increment highest seq. no. received
	BEQL	110$			; Skip over zero
	CMPW	CSB$W_RCVDSEQNM(R3),-	; Verify message sequence number
		CLSMSG$W_SEQNUM(R2)
	BNEQ	30$			; Message seq. number error
	INCB	CSB$B_UNACKEDMSGS(R3)	; Incr. count of un-acked messages
	PUSHL	R3			; Save CSB address

	SUBW3	CSB$W_ACKRSEQNM(R3), -	; Is ack'ed sequence number
		CLSMSG$W_ACKSEQ(R2),R0	; bigger than the last one?
	BEQL	150$			; It's the same - nothing new ack'ed
	BLSS	50$			; It's smaller - seq. no. error
	MOVW	CLSMSG$W_ACKSEQ(R2), -	; It's bigger - update ack'ed number
		CSB$W_ACKRSEQNM(R3)

	; We've received a new ack'ed sequence number.  Resume fork process
	; threads for all CDRPs that have just been ack'ed.  This doesn't
	; include CDRPs that have RSPIDs as they are resumed when the 
	; response message arrives.  However, CDRPs with RSPIDs are not on
	; the sent queue

130$:	MOVL	CSB$L_SENTQFL(R3),R5	; Get first CDRP in sent list
	BEQL	150$			; No more CDRP's -- continue
	SUBW3	CSB$W_ACKRSEQNM(R3), -	; Does CDRP's sequence number match
		CDRP$W_SENDSEQNM(R5),R0	; next ack'ed sequence number?
	BGTR	150$			; This message not ack'ed
	MOVL	CDRP$L_FQFL(R5), -	; Update list head pointer
		CSB$L_SENTQFL(R3)
	BNEQ	140$			; Branch if list not empty
	MOVAL	CSB$L_SENTQFL(R3), -	; Reset list tail pointer
		CSB$L_SENTQBL(R3)
140$:	CLRW	CDRP$W_SENDSEQNM(R5)	; Clear sequence number marking message acknowledged
	TSTW	CDRP$L_RSPID+2(R5)	; Is there a RSPID?
	BNEQ	130$			; Branch if yes

	PUSHL	R2			; Save message buffer address

	; Have a CDRP whose message has been ack'ed and who doesn't
	; have a response id.  Resume fork process.  Inputs to fork process are:
	;
	;	R0	contains 1 (successful acknowledge)
	;	R3	Address of CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	;
	; Fork routine may destroy R0 - R5.

	MOVL	#SS$_NORMAL,R0		; Indicate success
	JSB	@CDRP$L_FPC(R5)		; Resume fork process
	POPL	R2			; Restore message buffer address
	MOVL	(SP),R3			; Restore CSB address into R3 
	MOVL	CSB$L_PDT(R3),R4	; Fetch PDT address
	BRB	130$			; Continue loop

150$:	; Now handle incoming message.  Determine if it is a response
	; to a message we sent or an unsolicited message by looking
	; at the message fucntion code.  Responses have negative function codes.

	PUSHAB	W^200$			; All roads eventually return to 200$

	CVTBL	CLSMSG$B_FACILITY(R2),R0 ; Get facility code
	BGEQ	170$			; Branch if not a response

	; Look up the RSPID to find the corresponding CDRP.
	; Recycle the RSPID with inline code instead of calling SCS (for speed).

	MOVL	G^SCS$GL_RDT,R0		; Get address of table of RSPIDs
	MOVZWL	CLSMSG$L_RSPID(R2),R1	; Get sequence number of RSPID
	CMPL	R1,RDT$L_MAXRDIDX(R0)	; Check it against maximum
	BGTRU	165$			; Too big - bugcheck
	ASSUME	RD$C_LENGTH  EQ  8
	MOVAQ	(R0)[R1],R1		; Compute address of entry
	CMPW	RD$W_SEQNUM(R1),-	; Compare sequence numbers
		CLSMSG$L_RSPID+2(R2)
	BNEQ	165$			; No match, bugcheck
	ASSUME	RD$V_BUSY  EQ  0
	BLBC	RD$W_STATE(R1),165$
	MOVL	RD$L_CDRP(R1),R5	; Get CDRP address
	CMPL	CLSMSG$L_RSPID(R2), -	; Check for RSPID match.
		CDRP$L_RSPID(R5)
	BNEQ	165$			; Branch if no match.
160$:	INCW	RD$W_SEQNUM(R1)		; Increment sequence number
	BEQL	160$			; Skip over zero
	MOVW	RD$W_SEQNUM(R1),-	; Copy new sequence number into CDRP
		CDRP$L_RSPID+2(R5)	
	
	; We have a response to a previous message.  Resume fork process.  
	; Inputs to fork process are:
	;
	;	R0	SS$_NORMAL (successful acknowledge)
	;	R2	Address of message
	;	R3	CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	;
	; Fork routine may destroy R0 - R5.

	MOVL	#SS$_NORMAL,R0		; Indicate success
	JMP	@CDRP$L_FPC(R5)		; Continue thread -- return to 200$

165$:	BUG_CHECK	CNXMGRERR,FATAL		; Response id invalid

170$:
	; Message is an input message rather than a response.  Dispatch
	; to appropriate second level message dispatcher.
	;
	;	Inputs to second level dispatcher are:
	;
	;	R2	Address of message
	;	R3	CSB
	;	R4	Address of PDT
	;	R5	If CLSMSG$L_RSPID(R2) is non-zero the address of a 
	;		non-initialized non-paged pool packet, usually a CDRP,
	;		(the size is determined on a per-facility basis from 
	;		the table, FAC_SIZES, below)
	;
	; 	Routine may destroy R0 - R5
	;
	;	N.B. the pool allocation does not check the legality of the 
	;	facility code.  It prevents errors during the pool allocation 
	;	request.  If the facility is bad, however, the first level 
	;	dispatcher will bugcheck the system very soon.

	TSTL	CLSMSG$L_RSPID(R2)	; Is a pool packet needed?
	BEQL	180$			; Branch if no pool needed
	MOVZBL	B^FAC_SIZES[R0],R1	; Get size of pool to allocate
	BEQL	180$			; Branch if allocation size is zero
	PUSHL	R2			; Save message buffer address
	JSB	G^EXE$ALONONPAGED	; Allocate needed pool
	MOVL	R2,R5			; Save packet address
	POPL	R2			; Restore message buffer address
	BLBC	R0,CNX$RCV_REJECT	; Branch on failure and reject message
					;   return to 200$
	MOVW	R1,CDRP$W_CDRPSIZE(R5)	; Setup packet size

180$:	; Return to 200$
	DISPATCH	CLSMSG$B_FACILITY(R2),TYPE=B,PREFIX=CLSMSG$K_FAC_,-
		<-
		<ACK,ACK_MSG>,-			; Explicit ACK message
		<CJF,CJF$DISPATCH>,-		; Common journaling facility
		<CNX,CNX$DISPATCH>,-		; Connection manager facility
		<CSP,CSP$DISPATCH>,-		; Cluster Server Process
		<LCK,LCK$DISPATCH>,-		; Lock manager facility
		<LKI,LKI$DISPATCH>,-		; GETLKI facility
		<BLK,BLKXFR_RETRY>,-		; Block transfer
		>
	BUG_CHECK	CNXMGRERR,FATAL		; Unrecognized function code

;
; Table of pool packet sizes
; for automatic allocations on incoming new messages
; with response requested
;

FAC_SIZES:
	FAC_POOL	<-
			<ACK,0>,-
			<CNX,CDRP$K_CM_LENGTH>,-
			<LCK,CDRP$K_CM_LENGTH>,-
			<CJF,IRP$K_LENGTH>,-
			<LKI,CDRP$K_CM_LENGTH>,-
			<CSP,CDRP$K_CM_LENGTH+8>,-
			<BLK,0>, -
			>
MAX_FACILITY = . - FAC_SIZES

200$:	; Come here after handling input message is complete.
	; Determine if an explicit ACK message should be sent back

	MOVL	(SP)+,R3		; Restore CSB address
	CMPB	CSB$B_UNACKEDMSGS(R3),-	; Is it necessary to send an ACK?
		CSB$B_REMACKLIM(R3) 
	BGEQ	SEND_ACK_MSG		; Send explicit acknowledgement
	RSB

	.DSABL	LSB

	.SBTTL	SEND_ACK_MSG - Send an explicit ACK message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends an explicit ACK message back to the 
;	remote side.
;
; CALLING SEQUENCE:
;
;	BSBW	SEND_ACK_MSG
;	IPL must be at IPL$_SCS
;
;	This routine may return to the caller before the message
;	has been sent (if we go into a SCS wait state).
;
; INPUT PARAMETERS:
;
;	R3	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;--

SEND_ACK_MSG:
	TSTL	CSB$L_CURRCDRP(R3)	; Test whether critical section blocked
	BNEQ	10$			; Branch if it is blocked and return
	BSBW	CNX$ALLOC_CDRP_ONLY	; Allocate a CDRP
	BLBC	R0,20$			; If unable to allocate, just return
					; without sending the message
	MOVAB	B^50$,CDRP$L_MSGBLD(R5)	; Address of message build routine
	BSBW	CNX$SEND_MSG_CSB	; Send the message
	MOVL	R5,R0			; Address of CDRP
	JMP	G^EXE$DEANONPAGED	; Deallocate CDRP

10$:	CLRB	CSB$B_UNACKEDMSGS(R3)	; Prevent further ACK attempts
20$:	RSB

50$:	MOVB	#CLSMSG$K_FAC_ACK, -	; Store message facility code
		CLSMSG$B_FACILITY(R2)	; (N.B. no sub-function code.)
	RSB

; Come here upon receiving one of these messages
;
ACK_MSG:
	BRW	CNX$DEALL_MSG_BUF_CSB	; Deallocate input message buffer.

	.SBTTL	CNX$RCV_REJECT - Reject received message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine rejects a received message, i.e., pretends that
;	this message was never seen.  This is done by dropping the
;	message on the floor, breaking the connection, and undoing
;	the sequence number modifcation that has taken place.
;
;	This routine may be called ONLY if the following conditions hold:
;		a) Unbroken thread of execution contiguous with receipt
;		   of message.
;		b) No messages have been sent since this message was
;		   received.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$RCV_REJECT
;	IPL must be at IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2	Address of received message
;	R3	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0-R2 are destroyed.
;
;--

CNX$RCV_REJECT::
	PUSHR	#^M<R3,R4,R5>			; Save registers
	BSBW	CNX$DEALL_MSG_BUF_CSB		; Deallocate message buffer
10$:	DECW	CSB$W_RCVDSEQNM(R3)		; Fix remembered received sequence
	BEQL	10$				;  number
	BSBB	SEND_ACK_MSG			; Acknowledge all ack'ed messages
	MOVL	R3,R5				; Address of CSB
	BSBW	CNX$DISC_PROTOCOL		; Request disconnect
	POPR	#^M<R3,R4,R5>			; Restore registers
	RSB

	.SBTTL	Principles of connection manager block transfers
;++
;
; The following paragraphs describe how block transfers are performed by the 
; connection manager.
;
;	Connection manager block transfers require a cooperative effort on the 
;	part of two cluster members.  This is very similar to (and based upon) 
;	the mechanisms by which SCS block transfers are accomplished.
;
;	A block transfer sequence is initiated by one node (which will be 
;	refered to as the requestor for the duration of this discussion) 
;	sending a message to a second node (which will be called the partner). 
;	This message signals that a block transfer operation is needed and 
;	describes the requestor's resources associated with the requested 
;	block transfer.  The message must require a response from the partner 
;	node.  When this response is received, it is assumed that the block 
;	transfer has been completed.
;
;	Before sending its message the requestor node must lock the virtual 
;	address space associated with the block transfer buffer into physical 
;	memory and request SCS mapping resources to map the buffer.  The 
;	connection manager will allocate SCS mapping resources to map the 
;	buffer.  However, the connection manager will not lock the virtual 
;	address space into physical memory nor will it fully protect its 
;	clients from knowing whether they are the requestor of or a partner 
;	to a block transfer operation.
;
;	Upon receipt of a message requesting that a block transfer take place, 
;	the partner node must:
;
;	    1.	Make whatever preparations are necessary to perform the block 
;		transfer (for example, reading information from a file).
;
;	    2.	Lock into physical memory those pages which contain (or will 
;		receive) its end of the block transfer information.
;
;	    3.	Using information in the message received from the requestor 
;		as well as information about its own mapping resources the 
;		block transfer must be performed.  This may either be done in 
;		a single operation or segmented.
;
;	    4.	If further processing is required once the transfer is 
;		complete (for example, writing information to a file), it 
;		must be done.
;
;	    5.	The response message must be sent to the requestor node.  This 
;		should be the last act of the thread initiated by the incoming 
;		request for a block transfer operation.
;
;	As with the requestor node, the connection manager will provide some, 
;	but by no means all, the support required for the tasks listed above.
;
;
;  The following paragraphs describe the connection manager routines 
;  assoicated with block transfers.  The order of presentation follows an 
;  block transfer operation as it progresses from requestor to partner 
;  and finally back to the requestor.
;
;  CNX$BLOCK_XFER, or CNX$BLOCK_XFER_IRP
;
;	One of these routines is called by a fork process on the requestor to 
;	begin the block transfer sequence.  Map resources are allocated for 
;	the requestor's buffer, a message buffer and RSPID are allocated, the 
;	client's message build routine is called, and a message is sent to the 
;	parter node.  When the response message is received, control is 
;	returned to the location following the subroutine call.
;
;  CNX$PARTNER_INIT_CSB
;
;	This routine is called by the partner's received message routine once 
;	the need for a block transfer is recognized.  It must be called before 
;	the thread initiated by the incoming message forks.  A data structure 
;	to describe the partner's block transfer (including a copy of the 
;	incoming message buffer and a buffer area whose size is specified as 
;	parameter to this routine) is allocated and initialized.  The incoming 
;	message buffer is deallocated.  Once control is returned from this 
;	routine, the thread initiated by the incoming message may fork.  
;	If data structures cannot be allocaed, no return to the caller will
;	be made.  The thread will be cleaned up and dropped, the connection
;	will be broken.
;
;	Many of the operations one might want to do in order to satisfy the 
;	block transfer request (e.g. reading data from a local disk) will 
;	require a fork at this point.  The purpose of CNX$PARTNER_INIT_CSB is 
;	to save all necessary context and release all necessary resources so 
;	that a fork can occur.
;
;  CNX$BLOCK_READ, CNX$BLOCK_WRITE, CNX$BLOCK_READ_IRP, and CNX$BLOCK_WRITE_IRP
;
;	One or more of these routines are called to actually cause a block 
;	transfer to occur.  N.B. read and write are viewed from the 
;	perspective of the partner node; read means transfer from requestor to 
;	partner and write means transfer from partner to requestor.
;
;	Mapping resources for the partner's buffer are allocated and the block 
;	transfer operation is performed.  This may transfer all or part of the 
;	requestor's buffer to/from the partner.  The partner need only provide 
;	sufficient buffer space for that portion of requestor's buffer which 
;	is to be transfered.  There is no prohibition against both reading 
;	from and writing to the requestor's buffer (i.e. a modify operation, as 
;	viewed from the requestor node).  However, at this time, there is no
;	protocol provided for preventing a set of operation from being restarted
;	from the beginning if a connection breaks and is reestablished.
;
;  CNX$PARTNER_FINISH
;
;	Control is transfered to this routine when the partner's portion of 
;	the block transfer operation has been completed.  A response message 
;	is sent to the requestor node and the structure allocated by 
;	CNX$PARTNER_INIT_CSB is deallocated.
;
;
;  Now, a few words about recovery from a connection breakage.
;
;	When the connection between a requestor and a partner is broken the 
;	partner thread is terminated with a call to the partner's error
;	routine after a message is sent to the requestor asking that the
;	request be retried.  If the requestor has survived, it will repeat
;	the request.
;
;	This form of broken connection recovery is required to accomodate the 
;	use of SCS mapping resources.  The message requesting a block transfer 
;	operation (sent from the requestor to the partner) contains a 
;	description of the requestor's SCS mapping resources allocated to the 
;	requestor's block transfer buffer.  In the event of a connection 
;	breakage, these SCS mapping resources must be deallocated.  This 
;	invalidates the description stored at the partner node and therefore 
;	the entire operation thread on the partner node.
;
;	The term "graceful" in the two paragraphs above is intended to imply 
;	that termination of the partner node thread includes a call to a 
;	client-specified error routine thus giving the client an opportunity 
;	to perform whatever client-specific cleanup operations are deemed 
;	necessary.
;
;--

	.SBTTL	CNX$BLOCK_XFER - Initiate a block transfer request
	.SBTTL	CNX$BLOCK_XFER_IRP - Initiate a block transfer request w/ IRP

;++
;
; FUNCTIONAL DESCRPITION:
;
;	This routines begin a block transfer operation sequence.  NOTE: a 
;	block transfer operation is actually a sequence of operations 
;	performed by cooperating processors/processes.  These routines 
;	represent the beginning of that sequence.  By no means, do they 
;	perform all operations involved in that sequence.  Nothing in these 
;	routines directly controls the direction of the block transfer.  It is 
;	determined solely by the cooperating acknowledged message services 
;	clients.
;
;	Calling one of these routines results in a message being sent to the 
;	cluster member identified by the input CSID.  In addition to the usual 
;	goodies (both acknowledged message goodies and client goodies), the 
;	message contains a buffer handle for the block transfer buffer on 
;	this, the local, system.  This node is the requestor of the block 
;	transfer operation.  The remote node is its partner.
;
;	The messages sent by these routines ALWAYS use a RSPID.  The block 
;	transfer operation sequence is not complete until the partner node 
;	responds to the intial message sent by these routines.  If the 
;	connection between the requestor and partner nodes breaks between the
;	time when the partner receives the request and when it sends its
;	response, the partner send a retry request message to the requestor
;	and forgets about the request.  The block 
;	transfer resource allocation mechanisms require this method of 
;	operation.
;
;	As with the other acknowledged message serivces, these routines 
;	control allocation of all SCS resources.  Because these routines must 
;	allocate the SCS mapping resources to be used for the local buffer 
;	handle, they require specific use of CDRP$L_VAL1, CDRP$L_VAL6, 
;	CDRP$L_VAL7, and CDRP$L_VAL8 which would otherwise be available to 
;	a client routine.
;
;	Except as noted above, these routines operate just like CNX$SEND_MSG.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$BLOCK_XFER		Initiate a block transfer
;	BSBW	CNX$BLOCK_XFER_IRP	Initiate a block transfer with an IRP
;
;	This routine returns to its caller when the block transfer has been 
;	completed and the partner has responded to the initial requestor 
;	message.  It returns to its caller's caller immediately.  The standard 
;	fork process convention that the caller must not push anything onto 
;	the stack is in effect.  The single exception is when R0 contains 
;	SS$_NOSUCHNODE return status.  This is the only synchronous return 
;	possible.  In this case, the return address of the caller's orginal 
;	caller is still on the top of the stack.  In some cases, this may 
;	require special action on the part of this routine's caller.
;
;	IPL must be at IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R3	CSID
;	R5	Address of CDRP
;
; IMPLICIT INPUTS:
;
;	CDRP$L_MSGBLD must contain the address of a message build routine.
;
;	CDRP$L_RSPID must contain valid RSPID or its high order word must be 
;	zero and its low order word nonzero to indicate that a RSPID must be
;	allocated.
;
;	CDRP$L_MSG_BUF must contain a valid message buffer address or zero.
;
;	--- FOR CNX$BLOCK_XFER:
;
;	CDRP$L_CNXSVAPTE(R5)	System virtual address of the first PTE 
;				describing the block transfer buffer
;	CDRP$W_CNXBOFF(R5)	Byte offset of first byte in block transfer 
;				buffer
;	CDRP$L_CNXBCNT(R5)	Number of bytes in block transfer
;	CDRP$B_CNXRMOD(R5)	Access mode of requestor
;
;	--- FOR CNX$BLOCK_XFER_IRP:
;
;	CDRP$L_SVAPTE(R5)	System virtual address of the first PTE 
;				describing the block transfer buffer
;	CDRP$W_BOFF(R5)		Byte offset of first byte in block transfer 
;				buffer
;	CDRP$L_BCNT(R5)		Number of bytes in block transfer
;	CDRP$B_RMOD(R5)		Access mode of requestor
;
;	Any information that the message build routine requires should
;	be in the CDRP or pointed to by pointers in the CDRP.
;
;	This routine requires that several CDRP fields be initialized to zero. 
;	CNX$INIT_CDRP should be called to perform this initialization.
;
; OUTPUT PARAMETERS:
;
;	R0	Status
;		    SS$_NORMAL ==> Message successfully acknowledged 
;				(if response requested, response received)
;		    SS$_NOSUCHNODE ==> Invalid CSID
;				(N.B. no fork occurs in this case)
;		    SS$_NODELEAVE ==> Requested node is leaving the cluster
;				or you are
;	R2	Partner's response message buffer address
;	R3	CSB address
;	R4	PDT address
;	R5	CDRP address
;
; IMPLICIT OUTPUTS:
;
;	CDRP$L_VAL1(R5) and CDRP$L_VAL6(R5) through CDRP$L_VAL8 are destroyed 
;	by this routine or overlayed by implicit inputs to this routine.
;
;	Assuming proper cooperation on the partner node, the block transfer 
;	buffer has either been copied to the partner node or over written with 
;	information from the partner node.
;
; SIDE EFFECTS:
;
;	R0 - R2 and R4 are destroyed.
;
; WARNING:
;
;	The connection manager header in messages sent by this routine is 
;	three longwords longer than normal.  This space contains the local 
;	buffer handle information.  This tactic has been chosen so that only 
;	block transfer messages pay the three longword penalty because three 
;	longwords is a significant amount of the space available in the 
;	message buffer to a connection manager client.
;
;--

	ASSUME	CDRP$B_RMOD-CDRP$L_IOQFL	EQ	IRP$B_RMOD
	ASSUME	CDRP$L_SVAPTE-CDRP$L_IOQFL	EQ	IRP$L_SVAPTE
	ASSUME	CDRP$W_BOFF-CDRP$L_IOQFL	EQ	IRP$W_BOFF
	ASSUME	CDRP$L_BCNT-CDRP$L_IOQFL	EQ	IRP$L_BCNT
	ASSUME	<CDRP$W_CNXBOFF - CDRP$L_CNXSVAPTE> EQ -
						<CDRP$W_BOFF - CDRP$L_SVAPTE>
	ASSUME	<CDRP$L_CNXBCNT - CDRP$L_CNXSVAPTE> EQ -
						<CDRP$L_BCNT - CDRP$L_SVAPTE>

	.ENABLE LSB

;
; Wait for pool, for connection to be re-established, or for the target to be
; removed from the cluster.
;
190$:	BSBW	CLEANUP_CDRP		; Deallocate RSPID and/or message buffer
	MOVL	CSB$L_CSID(R3),R3	; Get CSID
	FORK_WAIT			; On allocation failure; fork, wait,
	BRB	MEMORY_RETRY		; and try again.

900$:	PUSHL	CDRP$L_SAVEPC(R5)	; Setup return address
	BRW	SEND_CSID_ERROR

CNX$BLOCK_XFER_IRP::

	MOVQ	CDRP$L_SVAPTE(R5), -	; Copy SVAPTE and BOFF.
		CDRP$L_CNXSVAPTE(R5)
	MOVL	CDRP$L_BCNT(R5), -	; Copy BCNT.
		CDRP$L_CNXBCNT(R5)
	MOVB	CDRP$B_RMOD(R5), -	; Copy RMOD.
		CDRP$B_CNXRMOD(R5)

CNX$BLOCK_XFER::

	POPL	CDRP$L_SAVEPC(R5)	; Save return PC.

MEMORY_RETRY:

	CSID_TO_CSB csb=R3, error=900$	; Get CSB for input CSID.

	; allocate and init BTX

	MOVZBL	#CLUBTX$K_LENGTH, R1	; Get size of a BTX.
	JSB	G^EXE$ALONONPAGED	; Attempt to allocate a BTX.
	BLBC	R0, 190$		; Branch on allocation failure.
	MOVW	R1, CLUBTX$W_SIZE(R2)	; Set allocation size.
	MOVW	#<DYN$C_CLU_BTX*^x100+ -; Set structure type and subtype
		DYN$C_CLU>, -		; fields.
		CLUBTX$B_TYPE(R2)
	MOVL	R5,CLUBTX$L_CDRP(R2)	; Link CDRP to BTX
	ASSUME	CLUBTX$S_LBUFHNDL EQ 12
	CLRQ	CLUBTX$L_LBUFHNDL(R2)	; Zero local buffer handle area.
	CLRL	CLUBTX$L_LBUFHNDL+8(R2)
	MOVAL	CLUBTX$L_LBUFHNDL(R2), -; Set CDRP local buffer handle
		CDRP$L_LBUFH_AD(R5)	; pointer to point to BTX area.
	MOVL	CDRP$L_SAVEPC(R5), -	; Move caller's return PC to BTX
		CLUBTX$L_SAVED_PC(R2)
	MOVL	CDRP$L_MSGBLD(R5), -	; Copy user's message build routine address
		CLUBTX$L_MSGBLD(R2)
	MOVAB	B^BLD_BLKXFR_HDR, -	; Insert message prebuild routine address
		CDRP$L_MSGBLD(R5)

BLOCK_XFER:

	; Allocate a buffer handle.  If the allocation waits, there is a BTX on
	; the partner queue in the state REQMAP.  If the connection breaks, this
	; CDRP must be taken of the waiting queue.  When the connection is restored,
	; execution should be continued at BLOCK_XFR so that a new attempt to allocate
	; a buffer handle will occur.

	TEST_CSB_OPEN no=10$		; Is the CSB open?

	MOVB	#CDRP$K_REQ_MAP, -	; Mark CDRP as belonging to a 
		CDRP$B_CNXSTATE(R5)	; requestor in need of a buffer handle
	MOVL	CSB$L_CDT(R3), -	; Get CDT address in CDRP.
		CDRP$L_CDT(R5)
	MOVL	CDRP$L_LBUFH_AD(R5),R2	; Buffer handle address
	INSQUE	-CLUBTX$L_LBUFHNDL(R2), - ; Link to tail of partner queue
		@CSB$L_PARTNERQBL(R3)
	MOVL	CSB$L_PDT(R3), R4	; Get PDT address.
	MOVAL	CDRP$L_CNXSVAPTE(R5), R1; Get SVAPTE block address.
	MOVZBL	CDRP$B_CNXRMOD(R5), R2	; Get requestor's access mode.
	MAP				; Map transfer block.
	MOVL	CDRP$L_LBUFH_AD(R5),R2	; Buffer handle address in BTX
	REMQUE	-CLUBTX$L_LBUFHNDL(R2),R2 ; Dequeue BTX

10$:
	; If the connection broke, these is no map at this point.

	MOVB	#CDRP$K_REQUESTOR, -	; Mark CDRP as belonging to a 
		CDRP$B_CNXSTATE(R5)	; requestor that has a buffer handle
	MOVL	CSB$L_CDT(R3), -	; Get CDT address in CDRP -- must
		CDRP$L_CDT(R5)		;   be initialized for REQUESTOR
	BSBW	CNX$SEND_MSG_CSB	; Join common send message code.
	PUSHR	#^M<R0,R2,R3>		; Save registers.
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Buffer handle address
	MOVAB	-CLUBTX$L_LBUFHNDL(R1),R0 ; Address of BTX
	MOVL	CLUBTX$L_SAVED_PC(R0), - ; Copy return PC
		CDRP$L_SAVEPC(R5)
	MOVL	CLUBTX$L_MSGBLD(R0), -	; Restore user's message build routine address
		CDRP$L_MSGBLD(R5)
	BLBC	(SP),20$		; Branch on failure -- map already deallocated
	PUSHL	R0			; Save BTX address
	UNMAP				; Release buffer handle
	POPR	#^M<R0>			; Restore BTX address
20$:	JSB	G^EXE$DEANONPAGED	; Deallocate the BTX.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Forget deallocated storage
	POPR	#^M<R0,R2,R3>		; Restore saved registers.
	JMP	@CDRP$L_SAVEPC(R5)	; Return to mainline code.

	.DISABLE LSB

;
; Pre-Message build routine for block transfer requests.
; Do block transfer specific message setup and then transfer control to
; user's message build routine.
;
BLD_BLKXFR_HDR:
	MOVL	CDRP$L_LBUFH_AD(R5), R0	; Get local buffer handle address.
	MOVAB	-CLUBTX$L_LBUFHNDL(R0),R1 ; BTX address
	ASSUME	CLUBTX$S_LBUFHNDL EQ 12
	MOVQ	(R0)+, -		; Plant local buffer handle in
		CLSMSG$L_REQR_BUFH(R2)
	MOVL	(R0), -			; in message buffer.
		CLSMSG$L_REQR_BUFH+8(R2) 
	JMP	@CLUBTX$L_MSGBLD(R1)	; Jump to user's message build routine


; Enter here when a block transfer retry message is received from the partner.
; Deallocate the message buffer and the original RSPID.
; Branch to reissue the request.
;
;	R2:		Incoming message buffer address
;	R3:		CSB address
;	R4:		PDT address
;
BLKXFR_RETRY:
	MOVL	CLMBLK$L_RSPID(R2),R5	; Fetch RSPID from message
	FIND_RSPID_RDTE			; Look up RDPID
	BLBC	R0,10$			; Branch on error
	MOVL	RD$L_CDRP(R5),R5	; Fetch CDRP of requestor
	CMPB	#CDRP$K_REQUESTOR, -	; Test CDRP state
		CDRP$B_CNXSTATE(R5)
	BNEQ	20$			; Branch if state invalid
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Save message buffer
	BSBW	CLEANUP_CDRP		; Deallocate RSPID and/or message buffer
	BRW	BLOCK_XFER		; Branch to reissue the request

10$:	BUG_CHECK	CNXMGRERR,FATAL	; Invalid RSPID received

20$:	BUG_CHECK	CNXMGRERR,FATAL	; CDRP in unexpected state


	.SBTTL	CNX$PARTNER_INIT_CSB - Init block transfer partner
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by the partner's received message routine once 
;	the need for a block transfer is recognized.  It must be called before 
;	the thread initiated by the incoming message forks.  A BTX (or CLUBTX) 
;	is allocated.  It contains a fixed region in which the requestor's 
;	CSID and other useful information is stored, a copy of the incoming 
;	message buffer, and additional space as requested by the arguments to 
;	this routine.  The BTX is initialized.
;
;	The address of the client's broken connection error routine is among 
;	the arguments to this routine.  This address is stored in the BTX.  
;	Should the connection between the partner and the requestor break at 
;	anytime before the response message is successfully transmitted to the 
;	requestor, this error routine will be called.
;
;	ERROR ROUTINE INPUTS:
;
;		R1	Address of requested non-paged pool buffer (0 if none)
;		R2	Address of copy of original message
;		R3	CSB address (or zero if none exists)
;		R5	CDRP address
;
;	ERROR ROUTINE OUTPUTS:
;
;		R0-R5 may be destroyed
;
;		Client is responsible for deallocating CDRP.  All other 
;		structures are deallocated by the connection manager.
;
;	Once control is returned from this routine, the thread initiated by 
;	the incoming message may fork.  
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$PARTNER_INIT_CSB
;
; INPUTS:
;
;	R1	Desired size of non-paged pool buffer
;	R2	Incoming message buffer address
;	R3	CSB address
;	R4	Error cleanup routine address
;	R5	CDRP address
;	(SP)	Return address for the caller
;	4(SP)	Return address for the caller's caller
;
; IMPLICIT INPUTS:
;
;	CSB$L_CSID(R3)	CSID of the node requesting this block transfer
;	CDRP$L_SAVD_RTN(R5) & CDRP$L_MSG_BUF(R5) used as scratch areas
;
; OUTPUTS:
;
;	R0 - R1	Destroyed
;	R2	Address of copy of requestor's message buffer
;	R3	CSB address (unchanged)
;	R4	Address of allocated non-paged pool buffer
;	R5	CDRP address (unchanged)
;
; IMPLICIT OUTPUTS:
;
;--
CNX$PARTNER_INIT_CSB::

	BSBW	CNX$INIT_CDRP		; Initialize the CDRP.
	ASSUME	CDRP$L_MSG_BUF EQ <CDRP$L_SAVD_RTN + 4>
	MOVQ	R1, CDRP$L_SAVD_RTN(R5)	; Save requested buffer size and
					; message buffer address.

10$:	MOVAB	<CLSMSG$K_MAXMSG+ -	; Sum message buffer, requested buffer and BTX sizes.
		CLUBTX$K_LENGTH>(R1), R1
	JSB	G^EXE$ALONONPAGED	; Allocate extended BTX.
	BLBC	R0, 90$			; Branch if allocation failed.

	MOVW	R1, CLUBTX$W_SIZE(R2)	; Set allocation size.
	MOVW	#<DYN$C_CLU_BTX*^x100+ -; Set structure type and subtype
		DYN$C_CLU>, -		; fields.
		CLUBTX$B_TYPE(R2)
	MOVL	R5, CLUBTX$L_CDRP(R2)	; Setup CDRP pointer in BTX.
	MOVL	R4, CLUBTX$L_ERRADDR(R2); Save error action routine address.
	ASSUME	CLUBTX$S_LBUFHNDL EQ 12
	CLRQ	CLUBTX$L_LBUFHNDL(R2)	; Zero local buffer handle area.
	CLRL	CLUBTX$L_LBUFHNDL+8(R2)
	MOVAL	CLUBTX$L_LBUFHNDL(R2), -; Set CDRP local buffer handle
		CDRP$L_LBUFH_AD(R5)	; pointer to point to BTX area.
; *** I don't understand why we save the CSID since on every connection breakage
; *** all of this is flushed!
	MOVL	CSB$L_CSID(R3), -	; Save CSID of requestor in BTX.
		CLUBTX$L_CSID(R2)	; (Can't save CSB, since connection 
					; status may change during local setup.)
	MOVB	#CDRP$K_PART_IDLE, -	; Mark CDRP as belonging to an 
		CDRP$B_CNXSTATE(R5)	; idling partner
	MOVL	CSB$L_CDT(R3), -	; Get CDT address in CDRP.
		CDRP$L_CDT(R5)
	INSQUE	CLUBTX$L_XQFL(R2), -	; Queue BTX to partners queue.
		@CSB$L_PARTNERQBL(R3) 

	MOVL	CDRP$L_SAVD_RTN(R5),R4	; Was a buffer requested?
	BEQL	40$			; Branch in no buffer requested.
	MOVAB	-			; Get BTX plus max message buf. size	
		CLSMSG$K_MAXMSG+CLUBTX$K_LENGTH(R2), -
		R4  			; plus requested buffer address.
40$:	MOVL	R4, CLUBTX$L_USER_BUF(R2) ; Save requested buffer address.

	MOVQ	R3, -(SP)		; Save CSB & user buffer addresses.
	PUSHAB	CLUBTX$T_MSG_BUF(R2)	; Save address of copied msg. buf.
	PUSHL	R5			; Save CDRP address.
	MOVC3	#CLSMSG$K_MAXMSG, -	; Copy incoming message to
		@CDRP$L_MSG_BUF(R5), -	; the BTX.
		CLUBTX$T_MSG_BUF(R2)
	POPL	R5			; Restore CDRP address.
	MOVL	4(SP), R3		; Get CSB address.
	MOVL	CSB$L_PDT(R3), R4	; Setup PDT address.
	MOVL	CSB$L_CDT(R3), -	; Setup CDT address.
		CDRP$L_CDT(R5)
	DEALLOC_MSG_BUF			; Deallocate incoming message buffer.

	MOVAB	W^BLOCK_FAIL, -		; Set up resumption address for
		CDRP$L_FPC(R5)		; connection failure
	POPR	#^M<R2,R3,R4>		; Restore copied message buf. addr.,
					; CSB, and user buffer addresses.
	RSB				; Return to caller.

;
; BTX allocation failure
;	This is not an elegant solution to BTX allocation failure, but it is
;	easy.  If the BTX allocation fails, break the connection.
;
90$:	MOVL	CDRP$L_MSG_BUF(R5),R2	; Message buffer address
	CLRL	CDRP$L_MSG_BUF(R5)
	BSBW	CNX$RCV_REJECT		; Break connection, rejecting received message
	ADDL2	#4,SP			; Drop caller's address
	MOVL	R5,R0			; CDRP address
	JMP	G^EXE$DEANONPAGED	; Delete CDRP and return to caller's caller


	.SBTTL	CNX$BLOCK_READ - Partner block read
	.SBTTL	CNX$BLOCK_READ_IRP - Partner block read with IRP
	.SBTTL	CNX$BLOCK_WRITE - Partner block write
	.SBTTL	CNX$BLOCK_WRITE_IRP - Partner block write with IRP
;++
; FUNCTIONAL DESCRIPTION:
;
;	These routines are called on a block transfer partner node to initiate 
;	an actual block transfer.
;
;	These routines control allocation of all SCS resources.  Because these 
;	routines must allocate the SCS mapping resources to be used for the 
;	local buffer handle and use the supplied CDRP to perform a block 
;	transfer, they require specific use of CDRP$L_VAL1 through CDRP$L_VAL8 
;	which would otherwise be available to a client routine.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$BLOCK_READ (read from requestor to partner)
;	BSBW	CNX$BLOCK_READ_IRP (read with an IRP on the partner)
;	BSBW	CNX$BLOCK_WRITE (write from partner to requestor)
;	BSBW	CNX$BLOCK_WRITE_IRP (write with an IRP on the partner)
;
; INPUT PARAMETERS:
;
;	R5	CDRP address
;	(SP)	Return address for the caller
;	4(SP)	Return address for the caller's caller
;
; IMPLICIT INPUTS:
;
;	CDRP$L_LBUFH_AD (CDRP)		address of buffer handle in BTX
;	CLUBTX$L_CSID( BTX )		requestor's CSID
;	CLUBTX$T_MSG_BUF( BTX )		copy of incoming message buffer
;	CLSMSG$L_REQR_BUFH( MSG )	requestor's buffer handle descriptor
;
;	CDRP$L_RSPID(R5) and CDRP$L_MSG_BUF(R5) must contain zero.
;
;	CDRP$L_LBOFF must contain the offset (from the address described by 
;	SVAPTE - BOFF) in the local buffer at which the transfer is to begin.  
;	(This is provided to allow segmenting transfers.)
;
;	CDRP$L_RBOFF must contain the offset in the remote buffer at which the 
;	transfer is to begin.  (This is provided to allow segmenting 
;	transfers.)
;
;	CDRP$L_XCT_LEN must contain the number of bytes to transfer.
;
;	--- FOR CNX$BLOCK_READ and CNX$BLOCK_WRITE:
;
;	CDRP$L_CNXSVAPTE(R5)	System virtual address of the first PTE 
;				describing the block transfer buffer
;	CDRP$W_CNXBOFF(R5)	Byte offset of first byte in block transfer 
;				buffer
;	CDRP$L_CNXBCNT(R5)	Number of bytes in block transfer
;	CDRP$B_CNXRMOD(R5)		Access mode of requestor
;
;	--- FOR CNX$BLOCK_READ_IRP and CNX$BLOCK_WRITE_IRP:
;
;	CDRP$L_SVAPTE(R5)	System virtual address of the first PTE 
;				describing the block transfer buffer
;	CDRP$W_BOFF(R5)		Byte offset of first byte in block transfer 
;				buffer
;	CDRP$L_BCNT(R5)		Number of bytes in block transfer
;	CDRP$B_RMOD(R5)		Access mode of requestor
;
;	This routine requires that several CDRP fields be initialized to zero. 
;	CNX$PARTNER_INIT_CSB correctly performs this initialization.
;
; OUTPUT PARAMETERS:
;
;	R0 - R1	Destroyed
;	R2	Address of copy of requestor's message buffer
;	R3	Destroyed
;	R4	Address of allocated non-paged pool buffer
;	R5	CDRP address
;
; IMPLICIT OUTPUTS:
;
;	CDRP$L_VAL1(R5) through CDRP$L_VAL8 are destroyed by this routine or 
;	overlayed by implicit inputs to this routine.
;
;	Assuming proper cooperation on the partner node, the block transfer 
;	buffer has either been copied to the partner node or over written with 
;	information from the partner node.
;
; SIDE EFFECTS:
;
;	R0 - R4 are destroyed.
;
;--

	ASSUME	CDRP$L_CNXSVAPTE GT CDRP$L_LBUFH_AD
	ASSUME	CDRP$L_CNXSVAPTE GT CDRP$L_LBOFF
	ASSUME	CDRP$L_CNXSVAPTE GT CDRP$L_RBUFH_AD
	ASSUME	CDRP$L_CNXSVAPTE GT CDRP$L_RBOFF
	ASSUME	CDRP$L_CNXSVAPTE GT CDRP$L_XCT_LEN

	ASSUME	CDRP$B_RMOD-CDRP$L_IOQFL	EQ	IRP$B_RMOD
	ASSUME	CDRP$L_SVAPTE-CDRP$L_IOQFL	EQ	IRP$L_SVAPTE
	ASSUME	CDRP$W_BOFF-CDRP$L_IOQFL	EQ	IRP$W_BOFF
	ASSUME	CDRP$L_BCNT-CDRP$L_IOQFL	EQ	IRP$L_BCNT
	ASSUME	<CDRP$W_CNXBOFF - CDRP$L_CNXSVAPTE> EQ -
						<CDRP$W_BOFF - CDRP$L_SVAPTE>
	ASSUME	<CDRP$L_CNXBCNT - CDRP$L_CNXSVAPTE> EQ -
						<CDRP$L_BCNT - CDRP$L_SVAPTE>

	.ENABLE LSB

CNX$BLOCK_READ_IRP::

	MOVAB	W^REQUEST_DATA, -	; Setup for read function.
		CDRP$L_MSGBLD(R5)
	BRB	10$			; Branch to common IRP code.

CNX$BLOCK_WRITE_IRP::

	MOVAB	W^SEND_DATA, -		; Setup for write function.
		CDRP$L_MSGBLD(R5)
10$:	MOVQ	CDRP$L_SVAPTE(R5), -	; Copy SVAPTE and BOFF.
		CDRP$L_CNXSVAPTE(R5)
	MOVL	CDRP$L_BCNT(R5), -	; Copy BCNT.
		CDRP$L_CNXBCNT(R5)
	MOVB	CDRP$B_RMOD(R5), -	; Copy RMOD.
		CDRP$B_CNXRMOD(R5)
	BRB	20$			; Branch to common block xfer code.

CNX$BLOCK_READ::

	MOVAB	W^REQUEST_DATA, -	; Setup for read function.
		CDRP$L_MSGBLD(R5)
	BRB	20$			; Branch to common block xfer code.

14$:	ADDL2	#4,SP			; Eliminate callers address
15$:	RSB				; Connection is failing, exit

CNX$BLOCK_WRITE::

	MOVAB	W^SEND_DATA, -		; Setup for write function.
		CDRP$L_MSGBLD(R5)

20$:	DISPATCH  CDRP$B_CNXSTATE(R5),type=B,prefix=CDRP$K_ -
		<-
		<PART_IDLE,30$>, -	; Idle partner
		<NORMAL,14$>, -		; Return if turned into NORMAL
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CNX state

;
; If the CSID of the remote node involved in the transfer is invalid,
; bugcheck (unless the following case pertains):
;
; The following closes a window where a node has been removed from the
; cluster, pre-cleanup has been done, and an SCS DISCONNECT is in progress.
; A block transfer partner may initiate a request at this time because the
; error entry has not yet been called.  The appropriate behavior is to
; detect this case and drop the thread -- it will be returned via the
; error entry after the DISCONNECT completes.
;
25$:	MOVL	CDRP$L_CDT(R5),R3	; Fetch CDT address
	BEQL	29$			; Serious error if no CDT address
	MOVL	CDT$L_AUXSTRUC(R3),R3	; Fetch CSB address
	BEQL	29$			; Serious error if no CSB address
	CMPB	CSB$B_STATE(R3), -	; Is connection in DISCONNECT
		#CSB$K_DISCONNECT	;   state?
	BNEQ	29$			; No, serious error
	BBC	#CSB$V_REMOVED, -	; If node not removed from cluster,
		CSB$L_STATUS(R3),29$	;   bugcheck
	CMPL	CLUBTX$L_CSID(R2), -	; Double check CSID
		CSB$L_CSID(R3)
	BEQL	40$			; OK if match
29$:	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CNX state

30$:	SUBL3	#CLUBTX$L_LBUFHNDL, -	; Get BTX address
		CDRP$L_LBUFH_AD(R5),R2
	MOVL	CLUBTX$L_CSID(R2), R3	; Get CSID.
	CSID_TO_CSB error=25$, csb=R3	; Translate CSID to CSB.
40$:	POPL	CLUBTX$L_SAVED_PC(R2)	; Save caller's return PC.
	TEST_CSB_OPEN no=15$		; Branch if CSB not open.
	MOVL	CSB$L_PDT(R3), R4	; Setup PDT address.
	MOVL	CSB$L_CDT(R3), -	; Setup CDT address.
		CDRP$L_CDT(R5)

	MOVL	#1,CDRP$L_RSPID(R5)	; Request RSPID

	MOVB	#CDRP$K_PART_MAP, -	; Mark CDRP as belonging to a 
		CDRP$B_CNXSTATE(R5)	; partner waiting for a buffer handle.
	MOVAB	<CLUBTX$T_MSG_BUF + -	    ; Setup remote buffer handle
		CLSMSG$L_REQR_BUFH>(R2), -  ; address.
		CDRP$L_RBUFH_AD(R5)
	MOVAL	CDRP$L_CNXSVAPTE(R5), R1; Get SVAPTE block address.
	MOVZBL	CDRP$B_CNXRMOD(R5), R2	; Get requestor's access mode.
	MAP				; Map the local buffer.

	MOVB	#CDRP$K_PARTNER, -	; Mark CDRP as belonging to a 
		CDRP$B_CNXSTATE(R5)	; partner.
	BSBW	SEND_UNSEQ_MSG		; Send an unsequenced with a special
					; message build routine.
	BLBC	R0,BLOCK_FAIL		; Branch if connection has broken

	MOVB	#CDRP$K_PART_IDLE, -	; Return to idle partner CDRP CNX state.
		CDRP$B_CNXSTATE(R5) 
	MOVAB	B^BLOCK_FAIL, -		; Set up failure return
		CDRP$L_FPC(R5)
	SUBL3	#CLUBTX$L_LBUFHNDL, -	; Get BTX address into R0
		CDRP$L_LBUFH_AD(R5), R0
	MOVAB	CLUBTX$T_MSG_BUF(R0),R2	; Get requestor's message buffer address.
	MOVL	CLUBTX$L_USER_BUF(R0),R4 ; Get address of client requested buffer.
	JMP	@CLUBTX$L_SAVED_PC(R0)	; Return to caller.

;
; Get here when connection breaks
;
BLOCK_FAIL:
	BSBW	CNX$INIT_CDRP		; Initialize CDRP
	MOVAB	B^50$,CDRP$L_MSGBLD(R5)	; Message build routine
	MOVL	CDRP$L_LBUFH_AD(R5),R2	; BTX address
	REMQUE	-CLUBTX$L_LBUFHNDL(R2),R0 ; Remove from queue
	CLRQ	CLUBTX$L_XQFL(R0)	; Invalidate linkage
	MOVB	#CDRP$K_NORMAL, -	; Set CNXSTATE to NORMAL
		CDRP$B_CNXSTATE(R5)
	BSBW	CNX$SEND_MSG_CSB	; Send retry message
	SUBL3	#CLUBTX$L_LBUFHNDL, -	; Get BTX address
		CDRP$L_LBUFH_AD(R5),R2
;
; ERROR ACTION ROUTINE INPUTS:
;
;	R1	Address of requested non-paged pool buffer (0 if none)
;	R2	Address of copy of original message
;	R3	CSB address
;	R5	CDRP address
;
; ERROR ACTION ROUTINE OUTPUTS:
;
;	R0-R5 may be destroyed
;
;	Client is responsible for deallocating CDRP.  All other	structures 
;	will be deallocated here.
;--

	PUSHL	R2			; Save BTX address.

	MOVL	CLUBTX$L_CDRP(R2),R5	; Fetch CDRP address
	MOVL	CLUBTX$L_USER_BUF(R2), R1 ; Get requested pool address.
	ADDL	#CLUBTX$T_MSG_BUF, R2	; Get pointer to original message.
	JSB	@<CLUBTX$L_ERRADDR -	; Call user's error action routine.
		- CLUBTX$T_MSG_BUF>(R2)

	POPR	#^M<R0>			; Restore BTX address.
	JMP	G^EXE$DEANONPAGED	; Deallocate it and return to caller.


; Message build routine for retry messages
;
50$:	MOVB	#CLSMSG$K_FAC_BLK, -	; Set up facility code
		CLSMSG$B_FACILITY(R2)
	MOVL	CDRP$L_LBUFH_AD(R5),R0	; Address of offset in BTX
	MOVL	<CLUBTX$T_MSG_BUF+ -	; Set up response RSPID
		CLSMSG$L_RSPID- -
		CLUBTX$L_LBUFHNDL>(R0), -
		CLMBLK$L_RSPID(R2)
	RSB

	.DISABLE	LSB


	.SBTTL	CNX$PARTNER_FINISH - Complete partner's end of a block transfer
	.SBTTL	CNX$PARTNER_RESPOND - Send block transfer completed response
;++
; FUNCTIONAL DESCRIPTION:
;
;	One of these routines receives control when the partner's portion of 
;	the block transfer operation has been completed.  A response message 
;	is sent to the requestor node and the BTX, allocated by 
;	CNX$PARTNER_INIT_CSB, is deallocated.  CNX$PARTNER_FINISH also 
;	deallocates the input CDRP.
;
; CALLING SEQUENCE:
;
;	BRW	CNX$PARTNER_FINISH
;	BSBx	CNX$PARTNER_RESPOND
;
; INPUTS:
;
;	R5	CDRP address
;
; IMPLICIT INPUTS:
;
;	CDRP$L_LBUFH_AD(R5)	Fixed offset from BTX address
;	CLUBTX$L_CSID( BTX )	requestor's CSID
;	CLUBTX$T_MSG_BUF( BTX )	copy of incoming message buffer
;	CLSMSG$L_RSPID( MSG )	requestor's RSPID
;
;	CDRP$L_MSGBLD(R5) must contain the address of a message build routine.
;
;	CDRP$L_RSPID(R5) and CDRP$L_MSG_BUF(R5) must contain zero.
;
;	Any information that the message build routine requires should
;	be in the CDRP or pointed to by pointers in the CDRP.
;
; OUTPUTS:
;
;	R5	CDRP address (as input)
;
; IMPLICIT OUTPUTS:
;
;	CDRP$L_VAL8(R5) is overlayed by the client's status field CDRP$B_CLTSTS(R5).
;
;	The response message is sent to the requestor.  The BTX associated 
;	with this partner operation is dequeued and deallocated.  For 
;	CNX$PARTNER_FINISH, the input CDRP also is deallocated and this partner 
;	request thread is terminated.
;
; SIDE EFFECTS:
;
;	The response message is sent to the requestor.
;
;--

CNX$PARTNER_FINISH::
	BSBB	CNX$PARTNER_RESPOND	; Send response to requestor
	MOVL	R5, R0			; Copy the CDRP address.
	JMP	G^EXE$DEANONPAGED	; Deallocate CDRP and return 
					; (to whomever).

CNX$PARTNER_RESPOND::
	CMPB	#CDRP$K_PART_IDLE, -	; Test CDRP state
		CDRP$B_CNXSTATE(R5)
	BNEQ	10$			; Branch if no expected state
	MOVL	CDRP$L_LBUFH_AD(R5),R0	; Get offset in BTX
	REMQUE	-CLUBTX$L_LBUFHNDL(R0),R0 ; Remove BTX from partner queue
	MOVL	<CLUBTX$T_MSG_BUF + -	; Copy requestor's RSPID to
		CLSMSG$L_RSPID>(R0), -	; return RSPID (for response).
		CDRP$L_RETRSPID(R5)	; (This destroys the saved BTX address.)
	CLRL	CDRP$L_LBUFH_AD(R5)	; No more BTX
	MOVB	#CDRP$K_NORMAL, -	; Enter the normal state
		CDRP$B_CNXSTATE(R5)
	PUSHL	CLUBTX$L_CSID(R0)	; Get requestor's CSID.
	JSB	G^EXE$DEANONPAGED	; Deallocate the BTX
	POPR	#^M<R3>			; Restore CSID
	BRW	CNX$SEND_MSG		; Send the response message.

10$:	BUG_CHECK	CNXMGRERR,FATAL	; Invalid CDRP state

	.SBTTL	CNX$ALLOC_CDRP - Allocate a CDRP & Convert CSID
	.SBTTL	CNX$ALLOC_CDRP_ONLY - Allocate a CDRP
	.SBTTL	CNX$ALLOC_WARMCDRP - Allocate CDRP w/ RSPID and message buffer
	.SBTTL	CNX$ALLOC_WARMCDRP_CSB - Allocate warm CDRP using CSB
	.SBTTL	CNX$INIT_CDRP - Initialize a CDRP
;++
; FUNCTIONAL DESCRIPTION:
;
;	These routines are called to allocate CDRPs and initialize various
;	fields.
;
;	CNX$ALLOC_CDRP allocates a CDRP from non-paged pool and initializes 
;	various fields and converts a CSID to a CSB address.  
;	CNX$ALLOC_CDRP_ONLY performs the same allocation and initialization 
;	but does nothing with any CSIDs.
;
;	CNX$ALLOC_WARMCDRP and CNX$ALLOC_WARMCDRP_CSB attempt to allocate a 
;	CDRP from a free list on the CSB.  These CDRPs already have a response 
;	id. and message buffer allocated.  If the free list is empty then a 
;	CDRP is allocated from non-paged pool and initialized as before.  
;	However, the CDRP$L_RSPID field is set to 1 so that CNX$SEND_MSG will 
;	allocate a response id. (and also a message buffer).  The CSID 
;	supplied as an argument to CNX$ALLOC_WARMCDRP is converted to a 
;	CSB address.
;
;	CNX$INIT_CDRP simply initializes the CDRP whose address is supplied in 
;	R5.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$ALLOC_CDRP - Allocate a CDRP and convert CSID to CSB
;	BSBW	CNX$ALLOC_CDRP_ONLY - Allocate a CDRP only
;	BSBW	CNX$ALLOC_WARMCDRP - Allocate a CDRP w/ RSPID and msg buffer
;	BSBW	CNX$ALLOC_WARMCDRP - Allocate a warm CDRP using CSB address
;	BSBW	CNX$INIT_CDRP
;
;	IPL is at IPL$_SYNCH 
;
; INPUT PARAMETERS:
;
;	R3	CSID (CNX$ALLOC_CDRP and CNX$ALLOC_WARMCDRP)
;	R3	CSB (CNX$ALLOC_WARMCDRP_CSB)
;	R5	CDRP address (CNX$INIT_CDRP only)
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;	R3	CSB (CNX$ALLOC_CDRP and CNX$ALLOC_WARMCDRP)
;	R5	Address of CDRP
;
; IMPLICIT OUTPUTS:
;
;	Various fields in the CDRP are initialized to zero.
;
;	CNX$ALLOC_WARMCDRP, CNX$ALLOC_WARMCDRP_CSB, CNX$ALLOC_CDRP, and 
;	CNX$ALLOC_CDRP_ONLY set CDRP$W_CDRPSIZE to CDRP$K_CM_LENGTH on all 
;	newly allocated CDRPs.  CNX$INIT_CDRP does not alter CDRP$W_CDRPSIZE.  
;	This assumes the size has been correctly set by the caller and is 
;	consistant with the preallocation of CDRPs for messages requiring 
;	responses in CNX$RCV_MSG.
;
;	If CNX$ALLOC_WARMCDRP or CNX$ALLOC_WARMCDRP_CSB was called, then a 
;	CDRP with RSPID and message buffer will be returned if one was 
;	available.  If none were available, then a CDRP is returned with a 1 
;	in the CDRP$L_RSPID field.  No status is returned to indicate whether 
;	or not the CDRP has a RSPID and message buffer.  The caller does not 
;	have to be concerned about this as CNX$SEND_MSG_CSB will allocate 
;	either or both if they are needed.
;
;	CNX$ALLOC_CDRP and CNX$ALLOC_WARMCDRP convert a CSID address (input in 
;	R3) to a CSB address (output in R3).  For CNX$ALLOC_WARMCDRP, this is 
;	necessary because the CSB contains the listhead for the warm CDRP 
;	queue.  CNX$ALLOC_CDRP provides similar functionality for requests 
;	which do not need a RSPID.  It is also easier for acknowledged message 
;	services clients to detect and handle an error from the allocate CDRP 
;	routines than it is to detect and handle an error from CNX$SEND_MSG.  
;	Note: the use of either of these two routines implies the use of 
;	CNX$SEND_MSG_CSB instead of CNX$SEND_MSG.  When CSID conversion is not 
;	relivant, use CNX$ALLOC_CDRP_ONLY.
;
; COMPLETION CODES:
;
;	SS$_NORMAL	Normal successful completion
;	SS$_INSFMEM	Insufficient memory
;			(WARNING: If a CSID was input, it will have been 
;			converted to a CSB when this error is returned.)
;	SS$_NOSUCHNODE	Invalid CSID (CNX$ALLOC_CDRP and CNX$ALLOC_WARMCDRP)
;
; SIDE EFFECTS:
;
;	R1 - R2 are destroyed
;--

	.ENABL	LSB

CNX$ALLOC_WARMCDRP::
	CSID_TO_CSB csb=R3, error=INV_CSID_NO_CLEANUP

CNX$ALLOC_WARMCDRP_CSB::
	DECB	CSB$B_WARMCDRPS(R3)	; Decr. count of warm CDRPs
	BLSS	20$			; No more
	REMQUE	@CSB$L_WARMCDRPQFL(R3),R5 ; Allocate a free one
	BVS	10$			; List is empty
	MOVL	S^#SS$_NORMAL,R0
	RSB

10$:	BUG_CHECK	CNXMGRERR,FATAL	; *** TEMPORARY

20$:	INCB	CSB$B_WARMCDRPS(R3)	; Adjust count back
	PUSHL	#1			; Push contents of CDRP$L_RSPID
	BRB	30$

CNX$INIT_CDRP::
	ASSUME	CDRP$B_FIPL EQ CDRP$B_CD_TYPE+1
	MOVW	#<IPL$_SCS@8+DYN$C_CDRP>, -	; Set CDRP type and
		CDRP$B_CD_TYPE(R5)		; fork IPL of IPL$_SCS
	CLRL	CDRP$L_RSPID(R5)	; Clear RSPID field.
	BRB	40$			; Join common code.

CNX$ALLOC_CDRP::
	CSID_TO_CSB csb=R3, error=INV_CSID_NO_CLEANUP

CNX$ALLOC_CDRP_ONLY::
	PUSHL	#0			; Push contents of CDRP$L_RSPID
30$:	MOVZWL	#CDRP$K_CM_LENGTH,R1	; Size of CDRP
	JSB	G^EXE$ALONONPAGED	; Allocate it
	BLBC	R0,80$			; Unable to allocate it
	MOVL	R2,R5			; Use R5 from now on
	ASSUME	CDRP$B_CD_TYPE  EQ  CDRP$W_CDRPSIZE+2
	ASSUME	CDRP$B_FIPL EQ CDRP$B_CD_TYPE+1
	MOVL	#<<<IPL$_SCS@8>+DYN$C_CDRP@16>+CDRP$K_CM_LENGTH>, -
		CDRP$W_CDRPSIZE(R5)		; Set size, type, and fork IPL.
	POPL	CDRP$L_RSPID(R5)	; Initialize RSPID to 0 or 1
40$:	CLRL	CDRP$L_MSG_BUF(R5)	; Clear MSG_BUF
	CLRL	CDRP$L_RWCPTR(R5)	; and RWCPTR
	ASSUME	CDRP$K_NORMAL EQ 0
	ASSUME	CDRP$B_CNXSTATE EQ <CDRP$W_SENDSEQNM + 2>
	ASSUME	CDRP$L_RETRSPID EQ <CDRP$W_SENDSEQNM + 4>
	CLRQ	CDRP$W_SENDSEQNM(R5)
	MOVL	#SS$_NORMAL,R0
	RSB

80$:	TSTL	(SP)+			; Pop CDRP$L_RSPID info from stack.
	MOVZWL	#SS$_INSFMEM,R0		; Set error return status.
	RSB

INV_CSID_NO_CLEANUP:
	MOVZWL	#SS$_NOSUCHNODE,R0	; Signal invalid CSID in 
	RSB				; CNX$ALLOC_WARMCDRP and CNX$ALLOC_WARMCDRP

	.DSABL	LSB

	.SBTTL	CNX$DEALL_WARMCDRP_CSB - Deallocate a Warm CDRP using CSB
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to deallocate a CDRP that contains
;	a RSPID and a message buffer (actually in R2).  If the queue
;	of free CDRPs on the CSB contains less than a certain number
;	of CDRPs then the CDRP is inserted on the CSB free queue as
;	a package with the RSPID and message buffer.  Otherwise, all
;	three (CDRP, RSPID, and message buffer) are deallocated.
;
;	The RSPID must already have been recycled.  This is the case
;	when this entry point is called by a continuous thread of
;	execution that began as the result of receiving a message
;	with a RSPID and that calls this routine to deallocate that
;	message buffer and RSPID that were in the received message.
;
;	This requirement allows the lookup and recycling of the RSPID
;	to be combined into one in-line piece of code.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$DEALL_WARMCDRP_CSB
;
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	CSB
;	R5	Address of CDRP
;
; IMPLICIT INPUTS:
;
;	CDRP$L_RSPID contains the response id. 
;	The CDT and PDT addresses are in the CSB. 
;	NOTE:  The CDT address MUST be valid; i.e. the connection must NOT
;	       be broken.  One may NOT receive an input message on a
;	       connection, FORK or otherwise delay processing that message
;	       and then later call this routine with that message in hand
;	       (without at least verifying that the SAME connection is still
;	       valid).
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDRP$L_MSG_BUF contains the message buffer address if the
;	CDRP is not deallocated.
;
; SIDE EFFECTS:
;
;	R0 - R2 are destroyed
;--

CNX$DEALL_WARMCDRP_CSB::
	CMPB	CSB$B_WARMCDRPS(R3),-	; Is list of warm CDRPs full?
		#MAXWARMCDRPS
	BGEQ	30$			; Yes

	; The list of free CDRPs is not full.  Initialize some fields, 
	; store the message buffer address in the CDRP,
	; and insert this one on the list.

	ASSUME	CDRP$K_NORMAL EQ 0
	ASSUME	CDRP$B_CNXSTATE EQ <CDRP$W_SENDSEQNM + 2>
	ASSUME	CDRP$L_RETRSPID EQ <CDRP$W_SENDSEQNM + 4>
	CLRQ	CDRP$W_SENDSEQNM(R5)	; Clear sequence number, return RSPID,
					;   and set normal state
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Put message buffer address in CDRP
	CLRL	CDRP$L_FPC(R5)		; Ensure fork thread can't resume
	INSQUE	(R5),@CSB$L_WARMCDRPQBL(R3) ; Insert CDRP on free queue
	INCB	CSB$B_WARMCDRPS(R3)	; Incr. count of warm CDRPs
	RSB

30$:
	; List of warm CDRPs is full.  Deallocate message buffer, 
	; response id. and CDRP.

DEALLOC_WARMCDRP:	; Internal entry point

	; R2 is address of message buffer
	; R3 is CSB address
	;	CSB$L_CDT is CDT address
	;	CSB$L_PDT is PDT address
	; R5 is CDRP address
	;	CDRP$L_RSPID contains RSPID
	;
	; R0-R2 destroyed, R5 invalidated.

	ASSUME	CSB$L_PDT  EQ  CSB$L_CDT+4

	PUSHL	R4			; Save R4
	PUSHL	R3			; Save CSB address
	MOVQ	CSB$L_CDT(R3),R3	; Get address of CDT and PDT
	DEALLOC_MSG_BUF_REG		; Deallocate message buffer
	DEALLOC_RSPID			; Deallocate RSPID
	MOVL	R5,R0			; Move address of CDRP
	JSB	G^EXE$DEANONPAGED	; Deallocate CDRP
	MOVQ	(SP)+, R3		; Restore registers
	RSB

	.SBTTL	CNX$DEALL_MSG_BUF_CSB - Deallocate a message buffer using a CSB
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine deallocates the message buffer whose address is in R2.
;
; CALLING SEQUENCE:
;
;	BSBW	CNX$DEALL_MSG_BUF_CSB
;
;	IPL must be at IPL$_SCS (equals IPL$_SYNCH)
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	CSB
;
; IMPLICIT INPUTS:
;
;	The CDT and PDT addresses are in the CSB. 
;	NOTE:  The CDT address MUST be valid; i.e. the connection must NOT
;	       be broken.  One may NOT receive an input message on a
;	       connection, FORK or otherwise delay processing that message
;	       and then later call this routine with that message in hand
;	       (without at least verifying that the SAME connection is still
;	       valid).
;
; OUTPUT PARAMETERS:
;
;	R0	Status
;		SS$_NORMAL ==> deallocation successful
;
; IMPLICIT OUTPUTS:
;
;	R0 through R2 are destroyed; all other registers are preserved.
;
; SIDE EFFECTS:
;
;	The message buffer is deallocated.
;--

CNX$DEALL_MSG_BUF_CSB::
	MOVQ	R3, -(SP)		; Save sensitive registers.
	ASSUME	CSB$L_PDT EQ <CSB$L_CDT + 4>
	MOVQ	CSB$L_CDT(R3),R3	; Get CDT and PDT addresses.
	DEALLOC_MSG_BUF_REG		; Deallocate the message buffer.

	MOVQ	(SP)+, R3		; Restore registers.
	MOVL	#SS$_NORMAL,R0		; Set success status.
	RSB


	.END
