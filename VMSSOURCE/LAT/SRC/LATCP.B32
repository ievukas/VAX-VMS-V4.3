%TITLE	'LAT Control Program'
MODULE LATCP	(
		LANGUAGE (BLISS32),
		MAIN = LCP_MAIN,
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	LAT Control Program
!
! ABSTRACT:
!
!	This program controls and obtains counters and other information
!	from the LAT terminal port driver.
!
! ENVIRONMENT:	VAX/VMS Operating System
!
! AUTHOR:	Darrell Duffy	, CREATION DATE:  2-July-1983
!
! Previously modified by:
!		Darrel Duffy
!		Joe Marchesani
!
! MODIFIED BY:
!
!	V03-009	RNG0009		Rod Gamache		16-Jul-1984
!		Use system NODEname for /NODE=NAME qualifier if SYS$NODE
!		does not translate.
!		Allow for the Physical UCB pointer to be zero in the check
!		for LT devices for shut requests.
!
!	V03-008	RNG0008		Rod Gamache		7-Jun-1984
!		Change IDENTIFICATION to SERVICE_IDENTIFICATION.
!		With change in .CLD for /NAME and /IDENTIFICATION,
!		the LATCP program must default values on it's own.
!		Add HELP command.
!		Add START HISTORY command.
!		Add STOP HISTORY command.
!		Add /[NO]LOG qualifier to START, SET and STOP verbs.
!		Make proper determination of LAT terminals when shutting
!		down.
!
!	V03-007	RNG0007		Rod Gamache		8-May-1984
!		Change HOST qualifier to NODE qualifier, as per documentation
!		change.
!		Change MULTICAST_RATE to MULTICAST_TIMER.
!
!	V03-006	RNG0006		Rod Gamache		1-May-1984
!		Change LATCP to be a utility, instead of DCL command.
!
!	V03-005	LMP0221		L. Mark Pilant,		12-Apr-1984  14:42
!		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
!		ORB$W_PROT.
!
!	V03-004	RNG0004			Rod Gamache		27-Mar-1984
!		Add SHOW COUNTERS/DEVICE, SHOW COUNTERS/SERVERS and
!		SHOW SERVERS commands.
!		Add START/SET NODE_ID command.
!
!	V03-003	RNG0003			Rod Gamache		14-Mar-1984
!		Fix references to NMADEF.
!
!	V03-002	RNG0002			Rod Gamache		 2-Mar-1984
!		Add circuit counters.
!
!	V03-001	RNG0001			Rod Gamache		31-Jan-1984
!		Add new V5 message formats.
!--

%SBTTL	'Definitions'

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB';
LIBRARY 'SHRLIB$:NMALIBRY';
REQUIRE 'OBJ$:LATDEF';

!
! LINKAGES
!

    LINKAGE
	ALONONPAGED = JSB (REGISTER = 1; REGISTER = 2),
	DEANONPAGED = JSB (REGISTER = 0)
		: NOPRESERVE (1,2,3),
	VERIFYCHAN = JSB (REGISTER = 0; REGISTER = 1)
		: NOPRESERVE (2,3,4,5),
	STARTSTOP = JSB ( REGISTER = 5 )
		: NOPRESERVE (2,3,4,5,6,7,8,9,10,11)
	;

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    LCP_MAIN,				! Main entry
    LCP_QUAL,				! Convert all qualifiers
    LCP_GETSTR,				! Obtain a string qualifier
    LCP_FIXNAME,			! Fixup a name string qualifier
    LCPK_FINDDRIVER,			! Is the port driver loaded?
    LCP_START : NOVALUE,		! Start the driver
    LCP_STOP : NOVALUE,			! Stop the driver
    LCP_SET,				! Set the multicast message
    LCP_SHOW : NOVALUE,			! Process a SHOW command
    LCP_EXIT : NOVALUE,			! Exit LCP command
    LCP_ZERO : NOVALUE,			! Zero the counters
    LCPK_SET,				! Kernel mode set multicast routine
    LCPK_START,				! Kernel mode start routine
    LCPK_STOP,				! Kernel mode stop routine
    LCPK_ZERO : NOVALUE,		! Kernel mode zero routine
    LCPK_STARTHISTORY,			! Kernel mode start history routine
    LCPK_STOPHISTORY : NOVALUE,		! Kernel mode stop history routine
    LCPK_IS_LAT_TERMINAL,		! Kernel mode find LAT terminal routine
    LCP_SHOWCOUQUAL : NOVALUE,		! Show counters qualifiers
    LCP_SHOWCOU : NOVALUE,		! Show counters
    LCP_SHOWNODECOU : NOVALUE,		! Show node counters
    LCP_SHOWDEVCOU :NOVALUE,		! Show Ethernet device counters
    LCPK_SHOWDEVCOU,			! Show Ethernet device counters
    LCP_DISPDEVCOU,			! Display the Ethernet device ctrs
    LCP_FINDCOU,			! Find the counter value
    LCP_SHOWSERVCOU : NOVALUE,		! Show LAT Server counters
    LCP_SHOWHIST : NOVALUE,		! Show the history
    LCP_SHOWCHAR : NOVALUE,		! Show the characteristics
    LCP_SHOWSERVERS : NOVALUE,		! Show the LAT Servers
    LCP_HELP : NOVALUE,			! Give HELP
    LCP_CVTGROUPS : NOVALUE,		! Convert group codes to an ascii string
    LCP_FAOOUTPUT : NOVALUE,		! Convert and output a string
    LCPK_GETCOUNTERS,			! Obtain counters from driver
    LCPK_GETSERVCTRS,			! Obtain CSB counters from driver
    LCPK_GETSERVERS,			! Obtain CSB server information
    LCPK_GETHISTORY,			! Obtain history buffer from driver
    LCPK_GETCOMMON			! Obtain common buffer area from driver
    ;

!
! MACROS:
!

MACRO
!
! Set up a static descriptor
!
    DESCRIPTOR (STRING) =
	UPLIT (%CHARCOUNT (STRING), UPLIT BYTE (STRING))%,
!
! Set up a dynamic descriptor
!
    $SETDSC (DSC, SIZE, ADR) =
	(
	DSC [DSC$B_CLASS] = DSC [DSC$B_DTYPE] = 0;
	DSC [DSC$W_LENGTH] = SIZE;
	DSC [DSC$A_POINTER] = ADR
	)%,
!
! Compare a pair of descriptors
!
    $CMPDSC (DSC1, DSC2) =
	(
	CH$EQL
	    (
	    .DSC1 [DSC$W_LENGTH],
	    .DSC1 [DSC$A_POINTER],
	    MAX ( MIN ( .DSC1 [DSC$W_LENGTH], .DSC2 [DSC$W_LENGTH]), 3),
	    .DSC2 [DSC$A_POINTER],
	    ' '
	    )
	)%,
!
!  LOG information if requested
!
    LOG_SIGNAL [] =
	(
	IF (CLI$PRESENT (QUAL_LOG) )
        THEN
	    SIGNAL (%REMAINING)
	;
	)%,

    LOG_OUTPUT [] =
	(
	IF (CLI$PRESENT (QUAL_LOG) )
        THEN
	    LIB$PUT_OUTPUT (%REMAINING)
	;
	)%
    ;

    !
    !  Define FLAGS bits
    !
    MACRO
	FLAG_V_SERVERS	= 0,0,1,0%,
	FLAG_V_DEVICE	= 0,1,1,0%,
	FLAG_V_NODE	= 0,2,1,0%,

	FLAG_L_ALL	= 0,0,32,0%
    ;

!
! EQUATED SYMBOLS:
!

LITERAL
    TRUE = 1,
    FALSE = 0,
    SUCCESS = 1,
    FAILURE = 0,

    LF = 10,				! Line Feed character
    CR = 13,				! Carriage return character

    INPUT_LEN = 1024,			! Input command line length
    CMDLEN = 16,			! Subcommand string length
    NUMLEN = 16				! Numbers
    ;

BIND
    LCP_PROMPT		= %ASCID 'LCP> ',
    QUAL_SUBCOMMAND	= %ASCID 'SUBCOMMAND',
    QUAL_NAME		= %ASCID 'NODE_NAME' : BLOCK [,BYTE],
    QUAL_ID		= %ASCID 'SERVICE_IDENTIFICATION' : BLOCK [,BYTE],
    QUAL_GROUPS		= %ASCID 'GROUPS' : BLOCK [,BYTE],
    QUAL_RATING		= %ASCID 'RATING' : BLOCK [,BYTE],
    QUAL_SERV_RATING	= %ASCID 'RATING_SERVICE' : BLOCK [,BYTE],
    QUAL_SERV_NAME	= %ASCID 'SERVICE_NAME' : BLOCK [,BYTE],
    QUAL_START		= %ASCID 'START' : BLOCK [,BYTE],
    QUAL_STOP		= %ASCID 'STOP' : BLOCK [,BYTE],
    QUAL_SHOW		= %ASCID 'SHOW' : BLOCK [,BYTE],
    QUAL_SET 		= %ASCID 'SET ' : BLOCK [,BYTE],
    QUAL_ZERO		= %ASCID 'ZERO' : BLOCK [,BYTE],
    QUAL_COUNTERS	= %ASCID 'COUNTERS' : BLOCK [,BYTE],
    QUAL_HISTORY	= %ASCID 'HISTORY' : BLOCK [,BYTE],
    QUAL_CHAR		= %ASCID 'CHARACTERISTICS' : BLOCK [,BYTE],
    QUAL_MCAST		= %ASCID 'MULTICAST_TIMER'  : BLOCK [,BYTE],
    QUAL_SERVERS	= %ASCID 'SERVERS' : BLOCK [,BYTE],
    QUAL_DEVICE		= %ASCID 'DEVICE' : BLOCK [,BYTE],
    QUAL_NODE		= %ASCID 'NODE' : BLOCK [,BYTE],
    QUAL_LOG		= %ASCID 'LOG'	: BLOCK [,BYTE],
    QUAL_NODEID		= %ASCID 'NODE_IDENTIFICATION' : BLOCK [,BYTE],
    QUAL_NONE		= %ASCID 'none available' : BLOCK [,BYTE]
    ;

BIND
    ACTIVE = %ASCID 'active',
    INACTIVE = %ASCID 'inactive'
    ;


    BIND
	COUNTERSCTRSTR = %ASCID %STRING
	    (
	    '!/',
	    'LCP Node Counters!/!/',
	    '!10UL   Receive frames!/',
	    '!10UL   Receive errors!/',
	    '!10UL   Receive duplicates!/',
	    '!10UL   Transmit frames!/',
	    '!10UL   Transmit errors!/',
	    '!10XL   Last transmit failure code!/',
	    '!10UL   Retransmissions!/',
	    '!10UL   Circuit timeouts!/',
	    '!10UL   Protocol errors!/',
	    '!10XL   Protocol bit mask!/',
	    '!10UL   Resource errors!/',
	    '!10UL   No transmit buffer!/',
	    '!10UL   Unit timeouts!/',
	    );

    BIND
	PROTOCOLMASK = %ASCID %STRING
	    (
	    %CHAR (CR, LF),
	    ' Protocol errors include:',
	    %CHAR (CR, LF)
	    );


    BIND
	SERVCTRSTR = %ASCID %STRING
	    (
	    '!/',
	    'LCP Server Counters for !AS!/!/',
	    '!10UL   Receive frames!/',
	    '!10UL   Transmit frames!/',
	    '!10UL   Retransmissions!/',
	    '!10UL   Out of sequence frames!/',
	    '!10UL   Invalid messages!/',
	    '!10UL   Invalid slots!/',
	    '!/'
	    );


!
!  NOTE: The following 2 tables must be kept in order!
!	 If the counters are to be displayed correctly.
    BIND
	DEVCTRSTR = %ASCID %STRING
	    (
	    '!/',
	    'LCP Ethernet Device Counters!/!/',
	    '!10UL   Seconds since last zeroed!/',
	    '!10UL   Receive frames!/',
	    '!10UL   Receive errors!/',
	    '!10UL   Multicast frames received!/',
	    '!10UL   Receive bytes!/',
	    '!10UL   Multicast bytes received!/',
	    '!10UL   Transmit frames!/',
	    '!10UL   Transmit errors!/',
	    '!10UL   Multicast frames transmitted!/',
	    '!10UL   Transmit bytes!/',
	    '!10UL   Multicast bytes transmitted!/',
	    '!10UL   Frames sent, single collision!/',
	    '!10UL   Frames sent, multiple collisions!/',
	    '!10UL   Frames sent, initially deferred!/',
	    '!10UL   Transmit collision detect check failure!/',
	    '!10UL   Data overrun!/',
	    '!10UL   Local buffer errors!/',
	    '!10UL   System buffer unavailable!/',
	    '!10UL   User buffer unavailable!/',
	    );

BIND
    CTRNAMES = UPLIT
	(
	LONG	(NMA$C_CTLIN_ZER),
	LONG	(NMA$C_CTLIN_DBR),
	LONG	(NMA$C_CTLIN_RFL),
	LONG	(NMA$C_CTLIN_MBL),
	LONG	(NMA$C_CTLIN_BRC),
	LONG	(NMA$C_CTLIN_MBY),
	LONG	(NMA$C_CTLIN_DBS),
	LONG	(NMA$C_CTLIN_SFL),
	LONG	(NMA$C_CTLIN_MBS),
	LONG	(NMA$C_CTLIN_BSN),
	LONG	(NMA$C_CTLIN_MSN),
	LONG	(NMA$C_CTLIN_BS1),
	LONG	(NMA$C_CTLIN_BSM),
	LONG	(NMA$C_CTLIN_BID),
	LONG	(NMA$C_CTLIN_CDC),
	LONG	(NMA$C_CTLIN_OVR),
	LONG	(NMA$C_CTLIN_LBE),
	LONG	(NMA$C_CTLIN_SBU),
	LONG	(NMA$C_CTLIN_UBU),
	-1
	);

    BIND
	RCVERRMASK = %ASCID %STRING
	    (
	    %CHAR (CR, LF),
	    ' Receive errors include:',
	    %CHAR (CR, LF)
	    );

    BIND
	XMTERRMASK = %ASCID %STRING
	    (
	    %CHAR (CR, LF),
	    ' Transmit errors include:',
	    %CHAR (CR, LF)
	    );

BIND
    faostr1 = %ascid %string
	(
	'!/',
	'     Time       Type Slots Idx Seq   Idx Seq   Seq Ack    DATA...',
	'!/'
	),
    faostr2 = %ascid %string
	(
	' !14<!%T!>  !XB   !XB    !XB  !XB    !XB  !XB    !XB !XB     !XB !XB',
	'  !XB !XB  !XB !XB  !XB !XB  !XB !XB  !XB !XB  !XB !XB  !XB !XB !/'
	);

!
! List of device names to try in order.  A logical name allows us to
! define a new datalink device to use or to use a controller other than
! the first.
! We assume that the UNA is first, and we allow the QNA driver to be
! used also.
!
BIND
    DEVNAMES = UPLIT
	(
	%ASCID 'LAT$DEVICE',
	%ASCID 'XEA0:',
	%ASCID 'XQA0:',
	0
	);

!
! The list of parameters for the datalink driver to start up.  We include
! the protocol type here as well as the other parameters to allow the device
! to be started with or without DECnet.
!

BIND
    SETPARM = UPLIT
	(
	WORD	(NMA$C_PCLI_BUS),	! Buffer size
	LONG	(1500),
	WORD	(NMA$C_PCLI_BFN),	! Number of buffers
	LONG	(1),
	WORD	(NMA$C_PCLI_PAD),	! Pad short buffers (NO!)
	LONG	(NMA$C_STATE_OFF),
	WORD	(NMA$C_PCLI_PTY),	! Protocol type
	LONG	(%X'0460'),		! Digital assigned protcol type
	WORD	(NMA$C_PCLI_PHA),	! Physical address
	WORD	(2),			! Length of string
	WORD	(NMA$C_LINMC_SDF),	! Use default setting
	WORD	(NMA$C_PCLI_PRM),	! Promiscous mode
	LONG	(NMA$C_STATE_OFF),
	WORD	(NMA$C_PCLI_DCH),	! Data chaining
	LONG	(NMA$C_STATE_OFF),
	WORD	(NMA$C_PCLI_CRC),	! Generate crc on transmit
	LONG	(NMA$C_STATE_ON),
	WORD	(NMA$C_PCLI_CON),	! Controller mode
	LONG	(NMA$C_LINCN_NOR)	! Normal
	),
    SETPARMEND = UPLIT BYTE(0),
    SETPARMDSC = UPLIT (SETPARMEND - SETPARM, SETPARM)
    ;

!
! Build a list of Global Host Node protocol error bit values and their names
!

MACRO GHBERRBITS [BITNAME, MEANING] =
    $BITPOSITION ( %NAME ('GHB$V_',BITNAME) ),
    %ASCID MEANING
    %;

BIND
    PROTOCOLBITS =
    UPLIT
    (
    GHBERRBITS
	(
	START, '    Invalid start message received',
	CSBZERO, '    Zero node circuit index received',
	CSBRANGE, '    Node circuit index out of range',
	CSBINVALID, '    Node circuit sequence invalid',
	CSBSTALE, '    Node circuit index no longer valid',
    	INVALIDSEQ, '    Invalid sequence number received in start message',
	HALT, '    Circuit was forced to halt',
	INVALIDREMID, '    Invalid server slot index',
	INVALIDLOCID, '    Invalid node slot index',
	BADCREDITS, '    Invalid credit field or too many credits used',
	REPCREATE, '    Repeat create of slot by server',
	REPDISC, '    Repeat disconnect of slot by server'
	),
    0, 0
    );

!
!  Define general error bit generation macro
!

MACRO ERRBITS [BITVALUE, MEANING] =
    BITVALUE,
    %ASCID MEANING
    %;

!
! Build a list of Receive error bit values
!
BIND
    RCVERRBITS =
    UPLIT
    (
    ERRBITS
	(
	0, '    CRC errors',
	1, '    Framing errors',
	2, '    Frame length error'
	),
    0, 0
    );

!
! Build a list of Transmit error bit values
!
BIND
    XMTERRBITS =
    UPLIT
    (
    ERRBITS
	(
	0, '    More than 16 retry failures',
	1, '    Loss of carrier',
	2, '    Unknown',
	3, '    Unknown',
	4, '    Frame length error',
	5, '    Late collision',
	),
    0, 0
    );


!
! OWN STORAGE:
!

!
! These are the strings and descriptors used to parse commands and qualifiers.
!
OWN
    INPUT_LINE	: VECTOR [INPUT_LEN, BYTE],
    INPUT_DSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    CMDBUF_DSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    SUBCMD	: VECTOR [CMDLEN, BYTE],
    SUBCMDDSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    NAME	: VECTOR [GHB$K_NAMELEN, BYTE],
    NAMEDSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    SERV	: VECTOR [GHB$K_NAMELEN, BYTE],
    SERVDSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    ID		: VECTOR [GHB$K_IDLEN, BYTE],
    IDDSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    NODE_ID	: VECTOR [GHB$K_IDLEN, BYTE],
    NODE_IDDSC	: BLOCK [DSC$K_Z_BLN, BYTE],
    NUMLST	: VECTOR [NUMLEN, BYTE],
    NUMLSTDSC	: BLOCK [DSC$K_Z_BLN, BYTE],

    GROUPS	: BLOCK [32, BYTE],
    RATING	: LONG,
    SERVRATING	: LONG,
    VERSION	: LONG,
    ECO		: LONG,
    MCASTIMR	: LONG,

    FLAGS	: BLOCK [1, LONG]		! Flags word
    ;

LITERAL OUTBUFSIZE = 1024,
	GRPBUFSIZE = 1024;
!
! These data structures are those used in starting, stopping and showing
! the counters, characteristics and history buffer of the driver.
!

OWN
    LCP$L_AREA : REF BLOCK [,BYTE],
    AREA : BLOCK [MAX (GHB$S_COMM_AREA, GHB$K_HISTSIZE,
	      (GHB$K_NAMELEN+LCB_C_LENGTH+1)*(GHB$K_ACT_CSBS+GHB$K_INACT_CSBS)),
		 BYTE],
    AREA_RET_SIZE : LONG,
    OUTDSC : BLOCK [DSC$K_Z_BLN, BYTE],
    OUTBUF : VECTOR [OUTBUFSIZE, BYTE],
    GRPDSC : BLOCK [DSC$K_Z_BLN, BYTE],
    GRPBUF : VECTOR [GRPBUFSIZE, BYTE]
    ;


!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    CLI$GET_VALUE : ADDRESSING_MODE (GENERAL),
    CLI$PRESENT  : ADDRESSING_MODE (GENERAL),
    OTS$CVT_TI_L : ADDRESSING_MODE (GENERAL),
    OTS$CVT_L_TI : ADDRESSING_MODE (GENERAL),
    STR$TRIM : ADDRESSING_MODE (GENERAL),
    STR$UPCASE : ADDRESSING_MODE (GENERAL),
    LIB$PUT_OUTPUT : ADDRESSING_MODE (GENERAL),
    LIB$FFS : ADDRESSING_MODE (GENERAL),
    LIB$SKPC : ADDRESSING_MODE (GENERAL),
    LIB$GET_INPUT : ADDRESSING_MODE (GENERAL),
    LIB$GET_FOREIGN : ADDRESSING_MODE (GENERAL),
    CLI$DCL_PARSE : ADDRESSING_MODE (GENERAL),
    CLI$DISPATCH : ADDRESSING_MODE (GENERAL),
    IOC$VERIFYCHAN : VERIFYCHAN ADDRESSING_MODE (GENERAL),
    EXE$ALONONPAGED : ALONONPAGED ADDRESSING_MODE (GENERAL),
    EXE$DEANONPAGED : DEANONPAGED ADDRESSING_MODE (GENERAL)
    ;

 EXTERNAL
    LCP_COMMANDS,			! Command table
    IOC$GL_DPTLIST : LONG		! HEAD OF LIST OF DPTS
		ADDRESSING_MODE (GENERAL)
    ;

EXTERNAL LITERAL
    CLI$_ABSENT,
    LCP$_IVCMD,
    LCP$_IVQUAL,
    LCP$_NOTLOADED,
    LCP$_NOTINITED,
    LCP$_SET,
    LCP$_NOTSET,
    LCP$_STARTED,
    LCP$_NOTSTARTED,
    LCP$_STOPPED,
    LCP$_NOTSTOPPED,
    LCP$_NOHISTORY,
    LCP$_NOSTARTHIST,
    LCP$_NOTFROMLAT,
    LCP$_NOSERVERS,
    LCP$_INTERNAL
    ;


%SBTTL	'LCP_MAIN  Main entry point'
ROUTINE LCP_MAIN =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Main entry point for LAT control program.  Obtain the command
!   and do the main dispatch.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	Foreign command read
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	exit status or signalled errors
!
! SIDE EFFECTS:
!
!	ltdriver controlled or information obtained.
!
!--

    BEGIN

    LOCAL
	STATUS
	;

    !
    ! Go to see if the driver is loaded.  We will also fail early
    ! If we don't have CMKRNL priv.
    !
    IF NOT (STATUS = $CMKRNL (ROUTIN = LCPK_FINDDRIVER) )
    THEN
	RETURN .STATUS
    ;
    !
    !  Check for any foreign command
    !
    $SETDSC (CMDBUF_DSC, INPUT_LEN, INPUT_LINE);
    INPUT_DSC[DSC$A_POINTER] = INPUT_LINE;		! Set address of buffer
    IF LIB$GET_FOREIGN(CMDBUF_DSC,0,INPUT_DSC)
	AND .INPUT_DSC [DSC$W_LENGTH] NEQ 0
    THEN
	BEGIN
	FLAGS [FLAG_L_ALL] = 0;				! Zero all flags
	STATUS = CLI$DCL_PARSE(INPUT_DSC, LCP_COMMANDS, LIB$GET_INPUT,
			LIB$GET_INPUT, LCP_PROMPT);
	IF .STATUS
	THEN
	    CLI$DISPATCH ();				! Dispatch on the VERB

	RETURN SS$_NORMAL

	END
    ;

    UNTIL (STATUS = CLI$DCL_PARSE(0, LCP_COMMANDS, LIB$GET_INPUT,
			LIB$GET_INPUT, LCP_PROMPT)) EQL RMS$_EOF
    DO
	IF .STATUS
	THEN
	    CLI$DISPATCH ()
    ;

    RETURN SS$_NORMAL

    END;

%SBTTL	'LCPK_FINDDRIVER  Find the address of the communication area'
ROUTINE LCPK_FINDDRIVER =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Find the address of LTDRIVER and return the address as the value of
!   this routine, or return failure.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ioc$gl_dptlist
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	address of the communication driver
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    !
    ! obtain the address of the ltdriver dpt and return the address of
    ! the counter block.  If no ltdriver, then return zero.
    !

    !
    ! size and address of the driver name string
    !
    BIND
	DRVRNAM = DESCRIPTOR ('LTDRIVER') : BLOCK [,BYTE]
	;

    LOCAL
	DPT : REF BLOCK [,BYTE],
	DPTEND : LONG
	;
    !
    ! scan the dpt list looking for ltdriver by name.
    !
    DPT = .IOC$GL_DPTLIST;
    DPTEND = IOC$GL_DPTLIST;
    WHILE .DPT NEQ .DPTEND
    DO
	BEGIN
	IF
	    CH$EQL
		(
		.DRVRNAM [DSC$W_LENGTH], .DRVRNAM [DSC$A_POINTER],
		CH$RCHAR (DPT [DPT$T_NAME]),
		DPT [DPT$T_NAME] +1,
		0
		)
	THEN
	    BEGIN
	    !
	    ! address of the counters is found in the longword
	    ! preceeding the vector.
	    !
	    IF (LCP$L_AREA = .( (.DPT + .DPT [DPT$W_VECTOR]) - 4) )
		LSS 0
	    THEN
		RETURN SUCCESS
	    ELSE
		RETURN LCP$_NOTINITED
	    END
	;
	DPT = .DPT [DPT$L_FLINK]
	END
    ;
    RETURN LCP$_NOTLOADED

    END;

%SBTTL	'LCP_QUAL  Process multicast qualifiers'
ROUTINE LCP_QUAL =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Process qualifiers for the multicast message.  Convert the qualifiers
!   to descriptors to set in the driver.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	cli processed qualifiers
!
! IMPLICIT OUTPUTS:
!
!	qualifier descriptors
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	BITVALUE,
	PTR	: REF VECTOR [,BYTE],
	DSC	: BLOCK [DSC$K_Z_BLN, BYTE],
	STATUS
	;

    !
    ! Convert the name to a string and require that we get something
    !
    IF	NOT LCP_GETSTR (QUAL_NAME, NAMEDSC, GHB$K_NAMELEN, NAME,
		%ASCID 'SYS$NODE', SYI$_NODENAME)
	OR
	NOT LCP_FIXNAME (NAMEDSC)
    THEN
	BEGIN
	SIGNAL (LCP$_IVQUAL, 2, QUAL_NAME, NAMEDSC);
	RETURN FAILURE
	END
    ;

    !
    !  The node id is optional
    !
    LCP_GETSTR (QUAL_NODEID, NODE_IDDSC, GHB$K_IDLEN, NODE_ID,
	%ASCID 'SYS$ANNOUNCE', 0);

    !
    ! The service name is optional
    !
    IF	LCP_GETSTR (QUAL_SERV_NAME, SERVDSC, GHB$K_NAMELEN, SERV,
	%ASCID 'SYS$SERVICE_NAME', 0)
    THEN
	BEGIN
	IF NOT LCP_FIXNAME (SERVDSC)
	THEN
	    BEGIN
	    SIGNAL (LCP$_IVQUAL, 2, QUAL_SERV_NAME, SERVDSC);
	    RETURN FAILURE
	    END
	END
    ;

    !
    ! The service id string is optional too
    !
    LCP_GETSTR (QUAL_ID, IDDSC, GHB$K_IDLEN, ID, %ASCID 'SYS$ANNOUNCE', 0);
    
    !
    ! Convert the groups as a list of items
    !
    $SETDSC (DSC, NUMLEN, NUMLST);
    STATUS = CLI$GET_VALUE (QUAL_GROUPS, DSC);
    !
    ! If there is no QUALIFIER for GROUPS,
    ! Then we will default to enable group code 0
    !   
    IF NOT .STATUS
    THEN
	GROUPS = 1
    ELSE
	BEGIN
	GROUPS = 0;
	WHILE .STATUS
	DO
	    BEGIN
	    STR$TRIM (DSC, DSC, DSC [DSC$W_LENGTH] );
	    STATUS = OTS$CVT_TI_L (DSC, BITVALUE);
	    IF NOT .STATUS
	    THEN
		BEGIN
		SIGNAL (LCP$_IVQUAL, 2, QUAL_GROUPS, DSC, .STATUS);
		RETURN FAILURE
		END
	    ;
	    IF
		.BITVALUE LSS 0
		OR
		.BITVALUE GTR 255
	    THEN
		BEGIN
		SIGNAL (LCP$_IVQUAL, 2, QUAL_GROUPS, DSC);
		RETURN FAILURE
		END
	    ;
	    GROUPS [0, .BITVALUE, 1, 0] = TRUE;
	    $SETDSC (DSC, NUMLEN, NUMLST);
	    STATUS = CLI$GET_VALUE (QUAL_GROUPS, DSC);
	    END
	;
	END
    ;

    !
    ! The host node rating
    !
    $SETDSC (NUMLSTDSC, NUMLEN, NUMLST);
    IF CLI$GET_VALUE (QUAL_RATING, NUMLSTDSC)
    THEN
	BEGIN
	STR$TRIM (NUMLSTDSC, NUMLSTDSC, NUMLSTDSC [DSC$W_LENGTH] );
	STATUS = OTS$CVT_TI_L (NUMLSTDSC, RATING);
	IF NOT .STATUS
	    OR
	    (.RATING GEQU 255)
	THEN
	    BEGIN
	    SIGNAL (LCP$_IVQUAL, 2, QUAL_RATING, NUMLSTDSC, .STATUS);
	    RETURN FAILURE
	    END
	END
    ;

    !
    ! The service name rating
    !
    $SETDSC (NUMLSTDSC, NUMLEN, NUMLST);
    IF CLI$GET_VALUE (QUAL_SERV_RATING, NUMLSTDSC)
    THEN
	BEGIN
	STR$TRIM (NUMLSTDSC, NUMLSTDSC, NUMLSTDSC [DSC$W_LENGTH] );
	STATUS = OTS$CVT_TI_L (NUMLSTDSC, SERVRATING);
	IF NOT .STATUS
	    OR
	    (.SERVRATING GEQU 255)
	THEN
	    BEGIN
	    SIGNAL (LCP$_IVQUAL, 2, QUAL_SERV_RATING, NUMLSTDSC, .STATUS);
	    RETURN FAILURE
	    END
	END
    ;	

    !
    ! Multicast timer setting
    !
    $SETDSC (NUMLSTDSC, NUMLEN, NUMLST);
    IF CLI$GET_VALUE (QUAL_MCAST, NUMLSTDSC)
    THEN
	BEGIN
	STR$TRIM (NUMLSTDSC, NUMLSTDSC, NUMLSTDSC [DSC$W_LENGTH] );
	STATUS = OTS$CVT_TI_L (NUMLSTDSC, MCASTIMR);
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL (LCP$_IVQUAL, 2, QUAL_MCAST, NUMLSTDSC, .STATUS);
	    RETURN FAILURE
	    END
	ELSE
	    IF  (.MCASTIMR GTRU 255)
		OR
		(.MCASTIMR LSS 10)
	    THEN
		BEGIN
		SIGNAL (LCP$_IVQUAL, 2, QUAL_MCAST, NUMLSTDSC);
		RETURN FAILURE
		END
	END

    ;

    SUCCESS

    END;

%SBTTL	'LCP_GETSTR  Process a string value for a qualifier'
ROUTINE LCP_GETSTR (QUALDSC, DSC, SIZE, STR, LOGDSC, SYID) =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Accept a string value for a qualifier and translate it in the
!   case its a logical name. If there is not return value from the
!   call to CLI then use the LOGDSC to get our own interpretation.
!   (This should be done by the CLI, but it doesn't work that way.)
!
!   Also, if the LOGDSC doesn't translate, then attempt to use the
!   GETSYI parameter to retrieve a value.
!
! FORMAL PARAMETERS:
!
!   qualdsc		address of descriptor of the qualifier string
!   dsc			descriptor to leave string
!   size		size of string
!   str			string
!   logdsc		descriptor of logical name for defaulting
!   syid		system id parameter for $GETSYI call
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success if sring is present, failure if not, other errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	ITEM_SIZE = 16
	;

    MACRO
	ITM_LEN	= 0,0,16,0%,
	ITM_ID	= 2,0,16,0%,
	ITM_RETBUF = 4,0,32,0%,
	ITM_RETLEN = 8,0,32,0%,
	ITM_END	= 12,0,32,0%
	;

    MAP
	STR : REF VECTOR [,BYTE],
	DSC : REF BLOCK [,BYTE],
	LOGDSC : REF BLOCK [,BYTE],
	SYID
	;

    LOCAL
	RDSC	: BLOCK [DSC$K_Z_BLN, BYTE],
	PTR	: REF VECTOR [,BYTE],
	ITMLST	: BLOCK [ITEM_SIZE, BYTE],
	IOSB	: VECTOR [4, WORD],
	RET_LEN,
	LEN,
	STATUS
	;

    !
    ! Obtain the string
    !
    $SETDSC (DSC, .SIZE, .STR);
    STATUS = CLI$GET_VALUE (.QUALDSC, .DSC);
    IF NOT .STATUS
    THEN
	BEGIN
	$SETDSC (DSC, .SIZE, .STR);		! Re-set descriptor
	!
	!  If there is no logical name or translation OR no system parameter,
	!  then return failure.
	!
	IF NOT	(.LOGDSC NEQ 0
		AND
		(STATUS = $TRNLOG
		    (LOGNAM = .LOGDSC, RSLLEN = DSC[DSC$W_LENGTH],
		    RSLBUF = .DSC)))
	    OR
	    .STATUS EQL SS$_NOTRAN
	THEN
	    IF .SYID NEQ 0
	    THEN
		BEGIN
		ITMLST [ITM_LEN] = .SIZE;
		ITMLST [ITM_ID] = .SYID;
		ITMLST [ITM_RETBUF] = .STR;
		ITMLST [ITM_RETLEN] = DSC [DSC$W_LENGTH];
		ITMLST [ITM_END] = 0;	! End of LIST.
		IF NOT (STATUS = $GETSYIW ( ITMLST = ITMLST,
				IOSB = IOSB)
			OR
			.IOSB [0] )
		THEN
		    BEGIN
		    DSC [DSC$W_LENGTH] = 0;
		    RETURN FAILURE
		    END
		END
	    ELSE
		BEGIN
		DSC [DSC$W_LENGTH] = 0;
		RETURN FAILURE
		END
	    ;
	END
    ;

    !
    ! Translate the name in case its a logical name
    !
    $SETDSC (RDSC, .SIZE, .STR);
    DECR DCX FROM 10 TO 1
    DO
	BEGIN
	STR$TRIM (.DSC, .DSC, DSC [DSC$W_LENGTH] );
	STATUS = $TRNLOG
	    (LOGNAM = .DSC, RSLLEN = RDSC [DSC$W_LENGTH], RSLBUF = RDSC);
	IF .STATUS EQL SS$_NOTRAN
	THEN
	    EXITLOOP
	;
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL (LCP$_IVQUAL, 2, .QUALDSC, .DSC, .STATUS);
	    RETURN FAILURE
	    END
	END
    ;

    !
    ! Trim off the trailing spaces and look for an indirect or untranslated
    ! logical name.  If either, then just return none available.
    !
    STR$TRIM (.DSC, .DSC, DSC [DSC$W_LENGTH] );
    PTR = .DSC [DSC$A_POINTER];
    LEN = .DSC [DSC$W_LENGTH];

    !
    ! Scan the name and translate the non-printables to spaces
    !
    DECR DCX FROM .LEN - 1 TO 0
    DO
	BEGIN
	SELECTONE TRUE OF
	SET
	[.PTR [.DCX] LSS ' '] : PTR [.DCX] = ' ';
	[OTHERWISE] : 0;
	TES
	END
    ;

    DECR DCX FROM .LEN TO 0
    DO
	BEGIN
	IF .PTR [0] EQL ' '
	THEN
	    BEGIN
	    PTR = DSC [DSC$A_POINTER] = .PTR + 1;
	    LEN = DSC [DSC$W_LENGTH] = .LEN - 1
	    END
	END
    ;
    IF .PTR [0] EQL '@'
	OR
	CH$EQL (MIN (4, .LEN), .PTR, 4, UPLIT ('SYS$') )
    THEN
	BEGIN
	DSC [DSC$W_LENGTH] = MIN (.QUAL_NONE [DSC$W_LENGTH], .SIZE);
	DSC [DSC$A_POINTER] = .QUAL_NONE [DSC$A_POINTER];
	RETURN FAILURE
	END
    ;

    SUCCESS

    END;

%SBTTL	'LCP_FIXNAME  Process a name string'
ROUTINE LCP_FIXNAME (DSC) =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Process a name string.  Convert it to the correct form.
!
! FORMAL PARAMETERS:
!
!   DSC		Address of descriptor of string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	DSC : REF BLOCK [,BYTE]
	;

    LOCAL
	LEN,
	PTR : REF VECTOR [,BYTE],
	STATUS
	;

    !
    ! Strip beginning underscores and trailing colons
    !
    PTR = .DSC [DSC$A_POINTER];
    LEN = .DSC [DSC$W_LENGTH];
    DO
	BEGIN
	STATUS = FALSE;
	IF .PTR [0] EQL '_'
	THEN
	    BEGIN
	    LEN = DSC [DSC$W_LENGTH] = .LEN - 1;
	    PTR = DSC [DSC$A_POINTER] = .PTR + 1;
	    STATUS = TRUE
	    END
	;
	IF .PTR [.LEN - 1] EQL ':'
	THEN
	    BEGIN
	    LEN = DSC [DSC$W_LENGTH] = .LEN - 1;
	    STATUS = TRUE
	    END
	END
    WHILE .STATUS
    ;
    !
    ! Upcase the string and check for legal characters
    !
    STR$UPCASE (.DSC, .DSC);
    DECR DCX FROM .LEN - 1 TO 0
    DO
	BEGIN
	SELECTONE TRUE OF
	SET
	[.PTR [.DCX] GEQ 'A' AND .PTR [.DCX] LEQ 'Z'] : 0;
	[.PTR [.DCX] GEQ '0' AND .PTR [.DCX] LEQ '9'] : 0;
	[.PTR [.DCX] EQL '_'] : 0;
	[.PTR [.DCX] EQL '$'] : 0;
	[OTHERWISE] : RETURN FAILURE;
	TES
	END
    ;

    SUCCESS

    END;

%SBTTL	'LCP_START  Start the terminal port driver'
GLOBAL ROUTINE LCP_START : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Handle the general START request and the START HISTORY request.
!   If it is the general start request, then set the multicast message
!   data and then start the port driver. If it's the START HISTORY
!   request, allocate the history buffer.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	results from qualifier parse and address of driver comm area
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	driver started
!
!--

    BEGIN

    LOCAL
	STATUS
	;

    !
    !  Check if this is a START HISTORY command
    !
    $SETDSC (SUBCMDDSC, CMDLEN, SUBCMD);
    STATUS = CLI$GET_VALUE (QUAL_SUBCOMMAND, SUBCMDDSC);
    IF .STATUS EQL CLI$_ABSENT
    THEN
	BEGIN
	!
	!  Get the qualifiers and set them
	!
	IF NOT (STATUS = LCP_SET () )
	THEN
	    RETURN
	;

	!
	!  Now start the port driver
	!
	IF (STATUS = $CMKRNL (ROUTIN = LCPK_START) )
	THEN
	    LOG_SIGNAL (LCP$_STARTED)
	ELSE
	    SIGNAL (LCP$_NOTSTARTED, 0, .STATUS)
	;
	END
    ELSE
	BEGIN
	STR$TRIM (SUBCMDDSC, SUBCMDDSC, SUBCMDDSC [DSC$W_LENGTH] );
	!
	! Dispatch on the subcommand string
	!
	SELECTONE TRUE OF
	SET
	    [ $CMPDSC (SUBCMDDSC, QUAL_HISTORY) ] :
	    (
	    IF NOT (STATUS = $CMKRNL (ROUTIN = LCPK_STARTHISTORY) )
	    THEN
		SIGNAL (LCP$_NOSTARTHIST, 0, .STATUS)
	    ;
	    );

	[OTHERWISE] : SIGNAL (LCP$_IVCMD);

	TES;

	END
    ;
    END;

%SBTTL	'LCP_STOP  Stop the port driver'
GLOBAL ROUTINE LCP_STOP : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   The kernel routine is called to stop the driver.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	the driver is stopped
!
!--

    BEGIN

    LITERAL
	STRSIZE = 32
	;

    BIND
	TTNAME = DESCRIPTOR ('TT')
	;

    LOCAL
	DSC : BLOCK [DSC$K_Z_BLN, BYTE],
	STR : VECTOR [STRSIZE, BYTE],
	STATUS
	;

    !
    !  Check if this is a STOP HISTORY command
    !
    $SETDSC (SUBCMDDSC, CMDLEN, SUBCMD);
    STATUS = CLI$GET_VALUE (QUAL_SUBCOMMAND, SUBCMDDSC);
    IF .STATUS EQL CLI$_ABSENT
    THEN
	BEGIN
    !
    !  This is a general STOP command
    !
	!
	!  We cannot stop LAT from a LAT terminal
	!
	$SETDSC (DSC, STRSIZE, STR);
	$TRNLOG
	    (
	    LOGNAM = TTNAME,
	    RSLLEN = DSC [DSC$W_LENGTH],
	    RSLBUF = DSC
	    );
	IF CH$EQL (4, UPLIT (%ASCII '_LTA'), 4, STR)
	    OR
	   ($CMKRNL (ROUTIN = LCPK_IS_LAT_TERMINAL) )
	THEN
	    BEGIN
	    SIGNAL (LCP$_NOTFROMLAT);
	    RETURN
	    END
	;

	$CMKRNL (ROUTIN = LCPK_STOPHISTORY);	! Delete the history buffer

	!
	!  Stop the LTDRIVER
	!
	IF (STATUS = $CMKRNL (ROUTIN = LCPK_STOP) )
	THEN
	    LOG_SIGNAL (LCP$_STOPPED)
	ELSE
	    SIGNAL (LCP$_NOTSTOPPED, 0, .STATUS)
	;
	END
    ELSE
    !
    !  This is a STOP HISTORY command.
    !
	BEGIN
	STR$TRIM (SUBCMDDSC, SUBCMDDSC, SUBCMDDSC [DSC$W_LENGTH] );
	!
	! Dispatch on the subcommand string
	!
	SELECTONE TRUE OF
	SET
	    [ $CMPDSC (SUBCMDDSC, QUAL_HISTORY) ] :
	    (
	    $CMKRNL (ROUTIN = LCPK_STOPHISTORY)
	    );

	[OTHERWISE] : SIGNAL (LCP$_IVCMD);

	TES;

	END
    ;

    END;

%SBTTL	'LCP_SET  Set multicast information'
GLOBAL ROUTINE LCP_SET =

!++
! FUNCTIONAL DESCRIPTION:
!
!   The qualifier information is reported and then the kernel mode
!   routine is called to set the multicast information for transmission.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	results of qualifier parse
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	multicast information set
!
!--

    BEGIN

    LITERAL
	STRSIZE = 512,			! Size of input and output strings
	PRMSIZE = 24			! Size of parameter list in bytes
	;

    LOCAL
	STATUS,
        DSC : BLOCK [DSC$K_Z_BLN, BYTE],
        STR : VECTOR [STRSIZE,BYTE],
        P : VECTOR [PRMSIZE]
        ;

    !
    !  Get the command qualifiers
    !
    IF NOT (STATUS = LCP_QUAL () )
    THEN
	RETURN .STATUS
    ;

    !
    !  Convert the group codes to an ascii string
    !
    LCP_CVTGROUPS ();

    !
    ! Set up the parameter list and report the qualifier information
    ! that we are about to set.
    !
    P[0] = NAMEDSC;
    P[1] = SERVDSC;
    P[2] = NODE_IDDSC;
    P[3] = IDDSC;
    P[4] = GRPDSC;
    P[5] = .MCASTIMR;

    $SETDSC (DSC, STRSIZE, STR);

    $FAOL
        (
        CTRSTR = %ASCID
    	%STRING
    	    (
	    '!/LCP Qualifier Summary!/!/',
    	    'Node name = !18<\!AS\!>   Service name = !18<\!AS\!>!/',
	    'Node Identification = \!AS\!/',
    	    'Service Identification = \!AS\!/',
	    'Groups = !AS!/',
	    'Multicast timer = !UB seconds!/'
	    ),
        OUTBUF = DSC,
        OUTLEN = DSC,
        PRMLST = P[0]
        );

    LOG_OUTPUT (DSC);

    !
    ! Call the kernel mode routine to set the information in the
    ! driver.
    !
    IF NOT (STATUS = $CMKRNL (ROUTIN = LCPK_SET) )
    THEN
	SIGNAL (LCP$_NOTSET, 0, .STATUS)
    ;

    !
    !  LOG success if requested
    !
    LOG_SIGNAL (LCP$_SET);

    SUCCESS

    END;

%SBTTL	'LCP_SHOW  Process a SHOW command'
GLOBAL ROUTINE LCP_SHOW : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Routine to process an LCP SHOW ... command
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CLI parsed command
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS
	;
    !
    ! Obtain the subcommand
    !
    $SETDSC (SUBCMDDSC, CMDLEN, SUBCMD);
    STATUS = CLI$GET_VALUE (QUAL_SUBCOMMAND, SUBCMDDSC);
    IF .STATUS EQL CLI$_ABSENT
    THEN
	SUBCMDDSC [DSC$W_LENGTH] = 0
    ;
    STR$TRIM (SUBCMDDSC, SUBCMDDSC, SUBCMDDSC [DSC$W_LENGTH] );
    !
    ! Dispatch on the subcommand string
    !
    SELECTONE TRUE OF
    SET
    [ $CMPDSC (SUBCMDDSC, QUAL_COUNTERS) ] :
	(
	LCP_SHOWCOUQUAL ();
	LCP_SHOWCOU ()
	);

    [ $CMPDSC (SUBCMDDSC, QUAL_HISTORY) ] :
	(
	LCP_SHOWHIST ()
	);

    [ $CMPDSC (SUBCMDDSC, QUAL_CHAR) ] :
	(
	LCP_SHOWCHAR ()
	);

    [ $CMPDSC (SUBCMDDSC, QUAL_SERVERS) ] :
	(
	LCP_SHOWSERVERS ()
	);

    [OTHERWISE] : SIGNAL (LCP$_IVCMD);

    TES

    END;

%SBTTL	'LCP_EXIT  Process EXIT LCP request'
GLOBAL ROUTINE LCP_EXIT : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Routine to parse an LCP command line.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CLI parsed command
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS
	;

    STATUS = $EXIT (CODE = SS$_NORMAL)

    END;

%SBTTL	'LCPK_SET  Kernel mode routine to set multicast data'
ROUTINE LCPK_SET =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Kernel mode routine to set the information in the buffer of the driver.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	results of the qualifier parse
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	qualifier results set for multicast
!
!--

    BEGIN

    LOCAL
	ZERO,
	ONE,
	TWO,
	THIRTY_TWO,
	LT : REF BLOCK [,BYTE],
	PTR,
	STR : REF BLOCK [,BYTE]
	;

    ZERO = 0; ONE = 1; TWO = 2; THIRTY_TWO = 32;
    !
    ! Address of the buffer in the driver
    !
    LT = .LCP$L_AREA;
    PTR = STR = .LT [GHB$L_NODE];
    !
    ! Copy the multicast timer, host node status and group codes
    !
    PTR = CH$MOVE (2, MCASTIMR, .PTR);	! Set timer and no host node status
    PTR = CH$MOVE (1, THIRTY_TWO, .PTR);! Thirty-Two bytes of group code
    PTR = CH$MOVE (32, GROUPS, .PTR);	! Copy group codes
    !
    ! Copy the host node name and descriptor here
    !
    PTR = CH$MOVE (1, NAMEDSC [DSC$W_LENGTH], .PTR);
    PTR = CH$MOVE (.NAMEDSC [DSC$W_LENGTH],
    		.NAMEDSC [DSC$A_POINTER], .PTR);
    PTR = CH$MOVE (1, NODE_IDDSC [DSC$W_LENGTH], .PTR);
    PTR = CH$MOVE (.NODE_IDDSC [DSC$W_LENGTH],
		   .NODE_IDDSC [DSC$A_POINTER], .PTR);
    !
    ! If we have an service name, then report 2 service names here
    !
    IF .SERVDSC [DSC$W_LENGTH] NEQ 0
    THEN
	PTR = CH$MOVE (1, TWO, .PTR)
    ELSE
	PTR = CH$MOVE (1, ONE, .PTR)
    ;

    !
    ! Copy the first service rating, name and ID here
    !	We will use the host node name as the first service name
    !
    PTR = CH$MOVE (1, RATING, .PTR);
    PTR = CH$MOVE (1, NAMEDSC [DSC$W_LENGTH], .PTR);
    PTR = CH$MOVE (.NAMEDSC [DSC$W_LENGTH],
    		.NAMEDSC [DSC$A_POINTER], .PTR);
    PTR = CH$MOVE (1, IDDSC [DSC$W_LENGTH], .PTR);
    PTR = CH$MOVE (.IDDSC [DSC$W_LENGTH], .IDDSC [DSC$A_POINTER], .PTR);

    !
    ! If there is an service name, then build it and its rating as the
    !   second service name
    !
    IF .SERVDSC [DSC$W_LENGTH] NEQ 0
    THEN
	BEGIN
	PTR = CH$MOVE (1, SERVRATING, .PTR);
	PTR = CH$MOVE (1, SERVDSC [DSC$W_LENGTH], .PTR);
	PTR = CH$MOVE (.SERVDSC [DSC$W_LENGTH],
		.SERVDSC [DSC$A_POINTER], .PTR);
	PTR = CH$MOVE (1, ZERO, .PTR)	! No ID for the second service name!
	END
    ;

    !
    ! Now build the service classes
    !
    PTR = CH$MOVE (1, ONE, .PTR);	! One byte of service class
    PTR = CH$MOVE (1, ONE, .PTR);	! Enable service class 0

    !
    ! Store the total size of the data
    !
    STR [-2, 0, 16, 0] = .PTR - .STR;

    !
    ! Call the set entry of the driver
    !
    STARTSTOP (.LT [GHB$L_SETENTRY]);
    !
    ! Ignore the return from the driver for now.  It doesn't mean anything
    !
    SUCCESS

    END;

%SBTTL	'LCPK_START  Kernel mode start routine'
ROUTINE LCPK_START =

!++
! FUNCTIONAL DESCRIPTION:
!
!   This routine is called in kernel mode to start the driver.
!   First it checks to see if the terminal driver is already active
!   by looking at the Timer Active flag.  If
!   the device is not active, then a channel is assigned to the
!   data link device (a list of possible device names is tried) and
!   the ucb for the data link device is passed to the terminal port
!   driver.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LCP$L_AREA
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure code
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	LT : REF BLOCK [,BYTE],
	IOSB : VECTOR [4, WORD],
	CCB : REF BLOCK [,BYTE],
	UCB : REF BLOCK [,BYTE],
	ORB : REF BLOCK [,BYTE],
	DEV,
	STATUS,
	DEVCHAN : WORD
	;

    !
    ! If the timer active flag is present, then the port driver is active.
    !
    LT = .LCP$L_AREA;
    IF .LT [GHB$L_TIM_ACT] NEQ 0
    THEN
	RETURN SS$_DEVACTIVE
    ;
    !
    ! Try each of the device names in turn

    DEV = DEVNAMES;
    WHILE ..DEV NEQ 0
    DO
	BEGIN
	STATUS = $ASSIGN (DEVNAM = ..DEV, CHAN = DEVCHAN);
	IF .STATUS
	THEN
	    EXITLOOP
	;
	DEV = .DEV + 4
	END
    ;
    !
    ! If we never did find a device, then return the error
    !
    IF NOT .STATUS
    THEN
	RETURN .STATUS
    ;
    !
    ! Startup our protocol on the datalink device
    !
    STATUS = $QIOW
	(
	FUNC = IO$_SETMODE OR IO$M_CTRL OR IO$M_STARTUP,
	CHAN = .DEVCHAN,
	IOSB = IOSB,
	P2 = SETPARMDSC
	);
    !
    ! Something bad happened, so deassign our channel and then
    ! return the error
    !
    IF NOT .STATUS
	OR
	NOT ( STATUS = .IOSB [0])
    THEN
	BEGIN
	$DASSGN (CHAN = .DEVCHAN);
	RETURN .STATUS
	END
    ;
    !
    ! Call a handy system routine to find the datalink ucb address
    ! by obtaining the channel control block
    !
    IOC$VERIFYCHAN (.DEVCHAN; CCB);
    UCB = .CCB [CCB$L_UCB];
    !
    ! Call the start entry point of the port driver
    ! and if successful, then fix the ucb so it can stay around
    !
    STATUS = STARTSTOP (.LT [GHB$L_STRENTRY], .UCB);
    IF .STATUS
    THEN
	BEGIN
	UCB [UCB$L_PID] = 0;
	ORB = .UCB[UCB$L_ORB];
	ORB [ORB$L_OWNER] = %X'10004';
	ORB [ORB$W_PROT] = %X'FFF0'
	END
    ;
    !
    ! Deassign our channel to the datalink ucb
    !
    $DASSGN (CHAN = .DEVCHAN);
    RETURN .STATUS

    END;

%SBTTL	'LCPK_STOP  Kernel routine to stop the port driver'
ROUTINE LCPK_STOP =

!++
! FUNCTIONAL DESCRIPTION:
!
!   This routine is called in kernel mode and calls the shut entry point
!   in the ltdriver to stop all circuit and run things down.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LCP$L_AREA
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure code
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL DEVNAMSIZE = 16;

    BIND
	DEVNAMCTR = DESCRIPTOR ('!AC!UW')
	;

    LOCAL
	LT : REF BLOCK [,BYTE],
	DEVNAMSTR : VECTOR [DEVNAMSIZE, BYTE],
	DEVNAMDSC : BLOCK [DSC$K_Z_BLN, BYTE],
	UCB : REF BLOCK [,BYTE],
	ORB : REF BLOCK [,BYTE],
	DDB : REF BLOCK [,BYTE],
	IOSB : VECTOR [4, WORD],
	STATUS,
	DEVCHAN : WORD
	;
    
    !
    ! If the data link UCB is gone, then we are inactive
    !
    LT = .LCP$L_AREA;
    IF (UCB = .LT [GHB$L_UCB] ) EQL 0
    THEN
	RETURN SS$_DEVINACT
    ;
    !
    ! Get pointers to the ucb and ddb for datalink to make its name
    ! so we can assign a channel to the data link device ucb
    !
    DDB = .UCB [UCB$L_DDB];
    DEVNAMDSC [DSC$A_POINTER] = DEVNAMSTR;
    DEVNAMDSC [DSC$W_LENGTH] = DEVNAMSIZE;
    STATUS = $FAO
	(
	DEVNAMCTR,
	DEVNAMDSC [DSC$W_LENGTH],
	DEVNAMDSC,
	DDB [DDB$T_NAME],
	.UCB [UCB$W_UNIT]
	);
    IF NOT .STATUS
    THEN
	RETURN .STATUS
    ;
    !
    ! Fix the ucb so we can assign a channel to it.
    !
    UCB [UCB$L_PID] = 0;
    ORB = .UCB[UCB$L_ORB];
    ORB [ORB$L_OWNER] = 0;
    ORB [ORB$W_PROT] = 0;
    !
    ! Assign a channel to hold it here and allow us to shut it down
    ! later and deassign the ucb to cause it to go away.
    !
    STATUS = $ASSIGN (DEVNAM = DEVNAMDSC, CHAN = DEVCHAN);
    IF NOT .STATUS
    THEN
	RETURN .STATUS
    ;
    !
    ! Call the shutdown entry of the terminal port driver
    !
    STARTSTOP (.LT [GHB$L_SHUTENTRY]);
    !
    ! Shut down the datalink unit to free the protocol type
    !
    STATUS = $QIOW
	(
	FUNC = IO$_SETMODE OR IO$M_CTRL OR IO$M_SHUTDOWN,
	CHAN = .DEVCHAN,
	IOSB = IOSB
	);
    !
    ! Collect any failures in status
    !
    IF NOT .STATUS OR NOT (STATUS = .IOSB [0])
    THEN
	0
    ;

    !
    ! Temporary code to clean up io queue for mailbox delete
    !
    ! UCB [UCB$L_IOBL] = UCB [UCB$L_IOFL] = 0;

    !
    ! Deassign the channel that we have.  If shutentry succeeded, then
    ! the device will disappear
    !
    $DASSGN (CHAN = .DEVCHAN);

    RETURN .STATUS

    END;

%SBTTL	'LCPK_STARTHISTORY  Kernel mode start history routine'
ROUTINE LCPK_STARTHISTORY =

!++
! FUNCTIONAL DESCRIPTION:
!
!   This routine is called in kernel mode to start history journalling
!   in the driver. First it checks to see if the terminal driver is
!   already active by looking at the Timer Active flag.  If
!   the device is not active, then an error is returned, else the history
!   buffer is allocated and pointed to in the driver global area.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LCP$L_AREA
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure code
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	LT : REF BLOCK [,BYTE],
	HIST_BUF : REF BLOCK [,BYTE],
	STATUS
	;

    !
    !  Check to make sure the driver is active.
    !
    LT = .LCP$L_AREA;
    IF .LT [GHB$L_TIM_ACT] EQL 0
    THEN
	RETURN SS$_DEVINACT
    ;

    !
    !  Try to allocate a buffer, else insufficient memory
    !
    IF NOT (STATUS = EXE$ALONONPAGED (GHB$K_HISTSIZE+HBF_C_LENGTH; HIST_BUF) )
    THEN
	RETURN SS$_INSFMEM
    ;

    !
    !  Initialize the buffer and move pointer into global area
    !
    HIST_BUF[HBF_L_NEXT] = HIST_BUF[HBF_Z_DATA];
    HIST_BUF[HBF_L_BUFEND] = HIST_BUF[HBF_Z_DATA] + GHB$K_HISTSIZE;
    HIST_BUF[HBF_W_SIZE] = GHB$K_HISTSIZE;
    HIST_BUF[HBF_B_TYPE] = DYN$C_BUFIO;
    CH$FILL (0, GHB$K_HISTSIZE, HIST_BUF [HBF_Z_DATA]); ! Zero the buffer

    LT [GHB$L_HISTORY] = HIST_BUF [HBF_L_NEXT];

    SUCCESS

    END;

%SBTTL	'LCPK_STOPHISTORY  Kernel mode stop history routine'
ROUTINE LCPK_STOPHISTORY : NOVALUE  =

!++
! FUNCTIONAL DESCRIPTION:
!
!   This routine is called in kernel mode to start history journalling
!   in the driver. First it checks to see if the terminal driver is
!   already active by looking at the Timer Active flag.  If
!   the device is not active, then an error is returned, else the history
!   buffer is allocated and pointed to in the driver global area.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LCP$L_AREA
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	HIST_BUF : REF BLOCK [,BYTE]
	;

    !
    !  Check to make sure the driver is active.
    !
    IF .LCP$L_AREA [GHB$L_HISTORY] EQL 0
    THEN
	RETURN
    ;

    !
    !  Get history buffer and deallocate it.
    !
    HIST_BUF = .LCP$L_AREA [GHB$L_HISTORY];
    LCP$L_AREA [GHB$L_HISTORY] = 0;
    EXE$DEANONPAGED (HIST_BUF);

    END;

%SBTTL	'LCPK_IS_LAT_TERMINAL  Kernel routine to determine if TT is LAT terminal'
ROUTINE LCPK_IS_LAT_TERMINAL =

!++
! FUNCTIONAL DESCRIPTION:
!
!   This routine is called in kernel mode to determine if the current
!   TT: device is a LAT terminal.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure code
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BIND
	TTNAME	= DESCRIPTOR ('TT'),
	DRVRNAM = DESCRIPTOR ('LTDRIVER') : BLOCK [,BYTE]
	;

    LOCAL
	UCB : REF BLOCK [,BYTE],
	CCB : REF BLOCK [,BYTE],
	DDB : REF BLOCK [,BYTE],
	STATUS,
	DEVCHAN : WORD
	;

    !
    !  If we can't assign a channel, then return success, to prevent
    !  shutting down LAT.
    !
    IF NOT (STATUS = $ASSIGN (DEVNAM = TTNAME, CHAN = DEVCHAN) )
    THEN
	RETURN SUCCESS
    ;

    !
    !  Call a handy system routine to find the terminal ucb address
    !  from the channel control block.
    !
    IOC$VERIFYCHAN (.DEVCHAN; CCB);
    UCB = .CCB [CCB$L_UCB];			! Get (virtual?) UCB address
    !
    ! Deassign our channel to the terminal ucb
    !
    $DASSGN (CHAN = .DEVCHAN);

    IF .UCB [UCB$L_TL_PHYUCB] EQL 0		! LT devices should have this
    THEN					!    field set!
	RETURN FAILURE				! Assume we're not an LT term
    ;

    UCB = .UCB [UCB$L_TL_PHYUCB];		! Get Physical UCB address
    DDB = .UCB [UCB$L_DDB];			! Get DDB address

    !
    !  Return the result of the comparison
    !
    CH$EQL
	(
	.DRVRNAM [DSC$W_LENGTH], .DRVRNAM [DSC$A_POINTER],
	CH$RCHAR (DDB [DDB$B_DRVNAM_LEN]),
	DDB [DDB$T_DRVNAME] +1,
	0
	)

    END;

%SBTTL	'LCP_ZERO  Zero counters and history buffer'
GLOBAL ROUTINE LCP_ZERO : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Call the kernel mode routine to zero the counters and history buffer.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    $CMKRNL (ROUTIN = LCPK_ZERO)

    END;

%SBTTL	'LCPK_ZERO  Kernel mode zero routine'
ROUTINE LCPK_ZERO : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Zero the counter block and the history buffer
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	LT : REF BLOCK [,BYTE],
	HIST_BUF : REF BLOCK [,BYTE]
	;

    LT = .LCP$L_AREA;
    !
    ! Zero the counterblock
    !
    CH$FILL (0, GHB$K_CTRLENGTH, LT [GHB$T_COUNTERS] );

    !
    ! Zero the history buffer if there is one
    !
    IF .LT [GHB$L_HISTORY] NEQ 0
    THEN
	BEGIN
	HIST_BUF = .LT [GHB$L_HISTORY];
	CH$FILL (0, GHB$K_HISTSIZE, HIST_BUF [HBF_Z_DATA]);
	END
    ;

    END;

%SBTTL	'LCP_SHOWCOUQUAL  Process show qualifiers'
ROUTINE LCP_SHOWCOUQUAL : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Process qualifiers for the SHOW COUNTERS command.  Convert the qualifiers
!   to descriptors to set in the driver.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	cli processed qualifiers
!
! IMPLICIT OUTPUTS:
!
!	qualifier descriptors
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    !
    !  All qualifiers are optional!
    !
    FLAGS [FLAG_V_NODE] = CLI$PRESENT (QUAL_NODE);
    FLAGS [FLAG_V_DEVICE] = CLI$PRESENT (QUAL_DEVICE);
    FLAGS [FLAG_V_SERVERS] = CLI$PRESENT (QUAL_SERVERS);

    !
    !  If no qualifier is specified, then default to /NODE
    !
    IF NOT (
	   .FLAGS [FLAG_V_NODE] OR
	   .FLAGS [FLAG_V_DEVICE] OR
	   .FLAGS [FLAG_V_SERVERS]
	   )
    THEN
	FLAGS [FLAG_V_NODE] = TRUE
    ;

    END;

%SBTTL	'LCP_SHOWCOU  Process show counters request'
ROUTINE LCP_SHOWCOU : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the requested counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counters in LAT driver or Ethernet device driver
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    !
    !  If the /NODE qualifier is present, then display Host Node counters.
    !
    IF .FLAGS [FLAG_V_NODE]
    THEN
	LCP_SHOWNODECOU ()
    ;

    !
    !  If the /DEVICE qualifier is present, then display Ethernet device
    !  counters.
    !
    IF .FLAGS [FLAG_V_DEVICE]
    THEN
	LCP_SHOWDEVCOU ()
    ;

    !
    !  If the /SERVERS qualifier is present, then display SERVER counters.
    !
    IF .FLAGS [FLAG_V_SERVERS]
    THEN
	LCP_SHOWSERVCOU ()
    ;

    END;

%SBTTL	'LCP_SHOWNODECOU  Show Host Node counters'
ROUTINE LCP_SHOWNODECOU : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the NODE counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counters in LAT driver
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	LT : REF BLOCK [,BYTE],
	PTR : REF VECTOR [],
	STATUS
	;


    CH$FILL (255, GHB$S_COMM_AREA, AREA);

    !
    ! Get the counters if we can, and if not then signal the error
    !
    IF NOT
	(STATUS = $CMKRNL (ROUTIN = LCPK_GETCOUNTERS) )
    THEN
	BEGIN
	SIGNAL (.STATUS);
	RETURN
	END
    ;

    !
    ! convert the counters for output in a single bound
    !
    $SETDSC (OUTDSC, OUTBUFSIZE, OUTBUF);

    STATUS = $FAOL
	(
	CTRSTR = COUNTERSCTRSTR,
	OUTLEN = OUTDSC [DSC$W_LENGTH],
	OUTBUF = OUTDSC,
	PRMLST = AREA [GHB$T_COUNTERS]
	);

    IF NOT .STATUS THEN SIGNAL (.STATUS);

    STATUS = LIB$PUT_OUTPUT (OUTDSC);

    IF NOT .STATUS THEN SIGNAL (.STATUS);

    !
    ! Print the mask bit names that are present
    !
    LT = AREA;
    IF .LT [GHB$L_PROTOMASK] NEQ 0
    THEN
	BEGIN
	STATUS = LIB$PUT_OUTPUT (PROTOCOLMASK);
	PTR = PROTOCOLBITS;
	INCR IDX FROM 0 TO 64 BY 2
	DO
	    BEGIN
	    !
	    ! If the string desc is blank, then exit loop
	    !	
	    IF .PTR [.IDX + 1] EQL 0
	    THEN
		EXITLOOP
	    ;
	    !
	    ! If the bit is set, then write the string
	    !
	    IF .LT [$BYTEOFFSET (GHB$L_PROTOMASK), .PTR [.IDX], 1, 0]
	    THEN
		LIB$PUT_OUTPUT (.PTR [.IDX + 1] )
	    END
	;
	END
    ;

    END;


%SBTTL	'LCP_SHOWDEVCOU  Show Ethernet device counters'
ROUTINE LCP_SHOWDEVCOU : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the Ethernet device counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counters in LAT driver
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	CTRBUFSIZE = 512
	;

    LOCAL
	CTRDSC : BLOCK [DSC$K_Z_BLN, BYTE],
	STATUS
	;

    !
    !  Setup the counters return buffer descriptor
    !
    $SETDSC (CTRDSC, CTRBUFSIZE, AREA);

    !
    !  Read and display the counters
    !
    IF	NOT (STATUS = $CMKRNL (ROUTIN = LCPK_SHOWDEVCOU) )
	OR
	NOT (STATUS = LCP_DISPDEVCOU (CTRDSC) )
    THEN
	SIGNAL (.STATUS)
    ;

    END;

%SBTTL	'LCPK_SHOWDEVCOU  Show Ethernet device counters'
ROUTINE LCPK_SHOWDEVCOU (CTRDSC) =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the Ethernet device counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	CTRDSC		Address of counter block descriptor
!
! IMPLICIT INPUTS:
!
!	counters in Ethernet driver
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	error values returned
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	DEVNAMSIZE = 16,
	CTRBUFSIZE = 512
	;

    BIND
	DEVNAMCTRL = DESCRIPTOR ('!AC!UW')
	;

    LOCAL
	LT : REF BLOCK [,BYTE],
	DEVNAMSTR : VECTOR [DEVNAMSIZE, BYTE],
	DEVNAMDSC : BLOCK [DSC$K_Z_BLN, BYTE],
	RDCTRDSC : BLOCK [DSC$K_Z_BLN, BYTE],
	UCB : REF BLOCK [,BYTE],
	ORB : REF BLOCK [,BYTE],
	DDB : REF BLOCK [,BYTE],
	IOSB : VECTOR [4, WORD],
	STATUS,
	DEVCHAN : WORD,
	PID,
	OWNUIC,
	VPROT : WORD
	;
    
    !
    ! If the data link UCB is gone, then we are inactive
    !
    LT = .LCP$L_AREA;
    IF (UCB = .LT [GHB$L_UCB] ) EQL 0
    THEN
	RETURN SS$_DEVINACT
    ;
    !
    ! Get pointers to the ucb and ddb for datalink to make its name
    ! so we can assign a channel to the data link device ucb
    !
    DDB = .UCB [UCB$L_DDB];
    DEVNAMDSC [DSC$A_POINTER] = DEVNAMSTR;
    DEVNAMDSC [DSC$W_LENGTH] = DEVNAMSIZE;
    STATUS = $FAO
	(
	DEVNAMCTRL,
	DEVNAMDSC [DSC$W_LENGTH],
	DEVNAMDSC,
	DDB [DDB$T_NAME],
	.UCB [UCB$W_UNIT]
	);
    IF NOT .STATUS
    THEN
	RETURN .STATUS
    ;
    !
    !  Fix the ucb so we can assign a channel to it... save current
    !  settings first.
    !
    PID = .UCB [UCB$L_PID];
    ORB = .UCB[UCB$L_ORB];
    OWNUIC = .ORB [ORB$L_OWNER];
    VPROT = .ORB [ORB$W_PROT];
    UCB [UCB$L_PID] = 0;
    ORB [ORB$L_OWNER] = 0;
    ORB [ORB$W_PROT] = 0;
    !
    ! Assign a channel to hold it here and allow us to shut it down
    ! later and deassign the ucb to cause it to go away.
    !
    STATUS = $ASSIGN (DEVNAM = DEVNAMDSC, CHAN = DEVCHAN);
    IF NOT .STATUS
    THEN
	RETURN .STATUS
    ;

    !
    !  Setup the counters return buffer descriptor
    !
    $SETDSC (RDCTRDSC, CTRBUFSIZE, AREA);

    !
    !  Read the counters from the Ethernet device
    !
    STATUS = $QIOW
	(
	FUNC = IO$_SENSEMODE OR IO$M_CTRL OR IO$M_RD_COUNT,
	CHAN = .DEVCHAN,
	IOSB = IOSB,
	P2 = RDCTRDSC
	);

    !
    !  Restore device settings
    !
    UCB [UCB$L_PID] = .PID;
    ORB [ORB$L_OWNER] = .OWNUIC;
    ORB [ORB$W_PROT] = .VPROT;

    !
    ! Deassign the channel that we have.
    !
    $DASSGN (CHAN = .DEVCHAN);

    RETURN .STATUS		! Return the status from the READ QIO

    END;

%SBTTL	'LCP_DISPDEVCOU  Display the Ethernet device counters'
ROUTINE LCP_DISPDEVCOU (CTRDSC) =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the all the Ethernet device counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	CTRDSC		Address of descriptor of the counters string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	error values returned
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL PARMSIZE = 50;

    LOCAL
	PARAM : VECTOR [PARMSIZE, LONG],
	PINDX,
	CTRID,
	STATUS,
	VALUE,
	BITMAP,
	RCV_BITMAP : BLOCK [4, BYTE],
	XMT_BITMAP : BLOCK [4, BYTE],
	PTR : REF VECTOR []
	;

    RCV_BITMAP = 0;
    XMT_BITMAP = 0;
    !
    !  Loop through all the counters
    !
    PINDX = 0;
    CTRID = CTRNAMES;
    WHILE ..CTRID NEQ -1
    DO
	BEGIN
	!
	!  Get the counter values
	!
	LCP_FINDCOU (.CTRDSC, ..CTRID, VALUE, BITMAP);
	PARAM [.PINDX] = .VALUE;
	SELECTONEU ..CTRID OF
	SET

	[NMA$C_CTLIN_RFL] :			! If receive failures
	    (
	    RCV_BITMAP = .BITMAP		! Save the bitmap
	    );

	[NMA$C_CTLIN_SFL] :			! Is send failures
	    (
	    XMT_BITMAP = .BITMAP		! Save the bitmap
	    );

	TES
	;

	PINDX = .PINDX + 1;			! Skip to next parameter
	CTRID = .CTRID + 4			! Skip to next counter ID

	END
    ;
	
    !
    !  Convert the counters for output
    !
    $SETDSC (OUTDSC, OUTBUFSIZE, OUTBUF);

    STATUS = $FAOL
	(
	CTRSTR = DEVCTRSTR,
	OUTLEN = OUTDSC [DSC$W_LENGTH],
	OUTBUF = OUTDSC,
	PRMLST = PARAM[0]
	);

    IF NOT .STATUS THEN RETURN .STATUS;

    STATUS = LIB$PUT_OUTPUT (OUTDSC);

    IF NOT .STATUS THEN RETURN .STATUS;

    !
    ! Print the receive mask bit names that are present
    !
    IF .RCV_BITMAP [0, 0, 16, 0] NEQ 0
    THEN
	BEGIN
	!
	!  Print the header
	!
	STATUS = LIB$PUT_OUTPUT (RCVERRMASK);
	PTR = RCVERRBITS;			! Point to the translation tbl
	INCR INDX FROM 0 TO 32 BY 2
	DO
	    BEGIN
	    !
	    ! If the string desc is blank, then exit loop
	    !	
	    IF .PTR [.INDX + 1] EQL 0
	    THEN
		EXITLOOP
	    ;
	    !
	    ! If the bit is set, then write the string
	    !
	    IF .RCV_BITMAP [0, .PTR [.INDX], 1, 0]
	    THEN
		LIB$PUT_OUTPUT (.PTR [.INDX + 1] )
	    END
	;
	END
    ;

    !
    ! Print the transmit mask bit names that are present
    !
    IF .XMT_BITMAP [0, 0, 16, 0] NEQ 0
    THEN
	BEGIN
	!
	!  Print the header
	!
	STATUS = LIB$PUT_OUTPUT (XMTERRMASK);
	PTR = XMTERRBITS;			! Point to the translation tbl
	INCR INDX FROM 0 TO 32 BY 2
	DO
	    BEGIN
	    !
	    ! If the string desc is blank, then exit loop
	    !	
	    IF .PTR [.INDX + 1] EQL 0
	    THEN
		EXITLOOP
	    ;
	    !
	    ! If the bit is set, then write the string
	    !
	    IF .XMT_BITMAP [0, .PTR [.INDX], 1, 0]
	    THEN
		LIB$PUT_OUTPUT (.PTR [.INDX + 1] )
	    END
	;
	END
    ;

    SUCCESS

    END;

%SBTTL	'LCP_FINDCOU  Find the specific device counter'
ROUTINE LCP_FINDCOU (CTRDSC, CTRNAME, VALUE, BITMAP) =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the all the Ethernet device counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	CTRDSC		Address of descriptor of the counters string
!	CTRNAME		Name (ID) of the counter id code to search for
!	VALUE		Returned longword value for the counter if found
!	BITMAP		Returned longword value for the bitmap if found
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	error values returned
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	CTRDSC : REF BLOCK [,BYTE]
	;

    LOCAL
	CTRLEN,
	CTRPTR : REF BLOCK [,BYTE],
	STATUS,
	COUCOD,
	COUVAL,
	COUID : BLOCK [4, BYTE],
	ERRMAP
	;

    CTRPTR = .CTRDSC [DSC$A_POINTER];
    CTRLEN = .CTRDSC [DSC$W_LENGTH];
    COUCOD = -1;				! Set to illegal value
    WHILE .CTRLEN GTR 0 AND
	  .COUCOD NEQ .CTRNAME
    DO
	BEGIN
	COUID = .CTRPTR [0, 0 , 16, 0];		! Get the counter id + bits
	COUCOD = .COUID [NMA$V_CNT_TYP];	! Get just the counter code
	CTRPTR = .CTRPTR + 2;			! Skip counter id field
	CTRLEN = .CTRLEN - 2;			! Consume byte count

	!
	!  Get the bitmap if present
	!
	IF .COUID [NMA$V_CNT_MAP]
	THEN
	    BEGIN
	    ERRMAP = .CTRPTR [0, 0, 16, 0];	! Get the bitmap
	    CTRPTR = .CTRPTR + 2;		! Skip it
	    CTRLEN = .CTRLEN - 2		! Consume bytes
	    END
	ELSE
	    ERRMAP = 0
	;

	!
	!  Dispatch on counter width
	!
	SELECTONEU .COUID [NMA$V_CNT_WID] OF
	SET

	[0] :					! Unknown???
	    (
	    RETURN (LCP$_INTERNAL)
	    );

	[1] :					! 8 bit counter
	    (
	    COUVAL = .CTRPTR [0, 0, 8, 0];
	    CTRPTR = .CTRPTR + 1
	    );

	[2] :					! 16 bit counter
	    (
	    COUVAL = .CTRPTR [0, 0, 16, 0];
	    CTRPTR = .CTRPTR + 2
	    );

	[3] :					! 32 bit counter
	    (
	    COUVAL = .CTRPTR [0, 0, 32, 0];
	    CTRPTR = .CTRPTR + 4
	    );

	TES
	;

	END
    ;

    IF .COUCOD NEQ .CTRNAME
    THEN
	BEGIN
	.VALUE = 0;
	.BITMAP = 0;
	STATUS = FAILURE
	END
    ELSE
	BEGIN
	.VALUE = .COUVAL;
	.BITMAP = .ERRMAP;
	STATUS = SUCCESS
	END
    ;

    RETURN .STATUS

    END;

%SBTTL	'LCP_SHOWSERVCOU  Show SERVER counters'
ROUTINE LCP_SHOWSERVCOU : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert and write the all the SERVER counters to sys$output.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counters in LAT driver
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BIND
	UNKNOWN = DESCRIPTOR ('UNKNOWN')
	;

    LITERAL
	BUFSIZE = 24
	;

    LOCAL
	DSC : BLOCK [DSC$K_Z_BLN, BYTE],
	CTRBUF : VECTOR [BUFSIZE],
	PTR : REF BLOCK [,BYTE],
	STATUS
	;


    CH$FILL (255, GHB$S_COMM_AREA, AREA);

    !
    !  Get the counters if we can, and if not then signal the error
    !
    IF NOT
	(STATUS = $CMKRNL (ROUTIN = LCPK_GETSERVCTRS) )
    THEN
	SIGNAL (.STATUS)
    ;

    !
    !  Convert the counters for output one at a time
    !
    IF .AREA_RET_SIZE EQL 0
    THEN
	SIGNAL (LCP$_NOSERVERS)
    ELSE
	BEGIN
	INCR INDX FROM AREA
		TO AREA + .AREA_RET_SIZE - (LCB_K_LENGTH + GHB$K_NAMELEN + 1)
		BY LCB_K_LENGTH + GHB$K_NAMELEN + 1
	DO
	    BEGIN
	    PTR = .INDX;
	    CTRBUF [1] = .PTR [LCB_L_MSG_RCV];
	    CTRBUF [2] = .PTR [LCB_L_MSG_XMT];
	    CTRBUF [3] = .PTR [LCB_L_MSG_REXMT];
	    CTRBUF [4] = .PTR [LCB_W_SEQ_ERR];
	    CTRBUF [5] = .PTR [LCB_B_INV_MSG];
	    CTRBUF [6] = .PTR [LCB_B_INV_SLOT];

	    PTR = .PTR + LCB_K_LENGTH;		! Skip over counters

	    IF .PTR [0, 0, 8, 0] EQL 0
	    THEN
		CTRBUF [0] = UNKNOWN
	    ELSE
		BEGIN
		CTRBUF [0] = DSC;
		$SETDSC (DSC, .PTR [0, 0, 8, 0], PTR [1, 0, 8, 0])
		END
	    ;

	    $SETDSC (OUTDSC, OUTBUFSIZE, OUTBUF);

	    STATUS = $FAOL
		(
		CTRSTR = SERVCTRSTR,
		OUTLEN = OUTDSC [DSC$W_LENGTH],
		OUTBUF = OUTDSC,
		PRMLST = CTRBUF [0]
		);

	    IF NOT .STATUS THEN SIGNAL (.STATUS);

	    STATUS = LIB$PUT_OUTPUT (OUTDSC);

	    IF NOT .STATUS THEN SIGNAL (.STATUS)

	    END
	;

	END

    END;

%SBTTL	'LCP_SHOWHIST  Display the history buffer'
ROUTINE LCP_SHOWHIST : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Obtain the history buffer from the driver and then display it.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	history buffer in the driver.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS,
	CHAR
	;


    !
    ! Get the history buffer if there is one.
    !
    IF NOT
	(STATUS = $CMKRNL ( ROUTIN = LCPK_GETHISTORY ) )
    THEN
	BEGIN
	SIGNAL (.STATUS);
	RETURN;
	END
    ;

    !
    ! Now display the history buffer.  First the title line and then
    ! the buffer a line at a time.
    !
    LCP_FAOOUTPUT (FAOSTR1, 0);
    INCR IDX FROM AREA TO AREA + GHB$K_HISTSIZE - 32 BY 32
    DO
	LCP_FAOOUTPUT (FAOSTR2, .IDX)
    ;

    END;

%SBTTL	'LCP_SHOWCHAR  Display the LAT driver characteristics'
ROUTINE LCP_SHOWCHAR : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Obtain the common data area from the driver and then display
!   interesting tidbits.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	common data area in the driver.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS,
	PTR,
	NUM_SERVICES
	;

    LITERAL
	STRSIZE = 512,			! Size of input and output strings
	PRMSIZE = 24			! Size of parameter list in LONGs
	;

    LOCAL
        DSC : BLOCK [DSC$K_Z_BLN, BYTE],
        BUF : VECTOR [STRSIZE, BYTE],
        STR : REF VECTOR [,BYTE],
	VER_ECO : VECTOR [2, BYTE],
        P : VECTOR [PRMSIZE]
        ;

    !
    !  Get the COMMON AREA in the driver and setup the descriptors.
    !
    IF NOT
	(STATUS = $CMKRNL ( ROUTIN = LCPK_GETCOMMON ) )
    THEN
	SIGNAL (.STATUS)
    ;

    !
    !  Initialize descriptors
    !
    $SETDSC (IDDSC, GHB$K_IDLEN, ID);

    $SETDSC (NODE_IDDSC, GHB$K_IDLEN, NODE_ID);

    $SETDSC (SERVDSC, GHB$K_NAMELEN, SERV);

    $SETDSC (NAMEDSC, GHB$K_NAMELEN, NAME);

    STR = .OUTDSC [DSC$A_POINTER];

    !
    !  Pick up group codes, timer and skip host node status
    !
    MCASTIMR = .STR [0];
    PTR = CH$MOVE ( CH$RCHAR (STR [2]), STR [3], GROUPS);

    !
    !  Skip the group codes and host node name.
    !
    STR = .STR [2] + STR [3];		! Skip group codes
    STR = .STR [0] + STR [1];		! Skip host node name

    !
    !  Get host node id, then skip over it.
    !
    NODE_IDDSC [DSC$W_LENGTH] = .STR [0];
    PTR = CH$MOVE (.NODE_IDDSC [DSC$W_LENGTH],
		   STR [1], .NODE_IDDSC [DSC$A_POINTER]);

    STR = .STR [0] + STR [1];		! Skip host node id.

    !
    !  Get number of services
    !
    NUM_SERVICES = .STR [0];

    !
    !  Get the 1st service name and descriptor
    !
    NAMEDSC [DSC$W_LENGTH] = .STR [2];
    PTR = CH$MOVE (.NAMEDSC [DSC$W_LENGTH], STR [3], .NAMEDSC [DSC$A_POINTER]);

    STR = .STR [2] + STR [3];		! Skip 1st service name
    IDDSC [DSC$W_LENGTH] = .STR [0];
    PTR = CH$MOVE (.IDDSC [DSC$W_LENGTH], STR [1], .IDDSC [DSC$A_POINTER]);

    !
    ! If we have a second service name, then report the second service here
    !
    IF .NUM_SERVICES  LEQ  1
    THEN
	SERVDSC [DSC$W_LENGTH] = 0
    ELSE
	BEGIN
	STR = .STR [0] + STR [1];		! Skip 1st service id
	STR = .STR + 1;				! Skip 2nd rating
	SERVDSC [DSC$W_LENGTH] = .STR [0];
	PTR = CH$MOVE (.SERVDSC [DSC$W_LENGTH], STR [1],
		.SERVDSC [DSC$A_POINTER])
	END
     ;

    !
    !  Now display the relevant parts of the common area.
    !

    !
    !   Convert the group codes to a nice printable ascii string
    !
    LCP_CVTGROUPS ();

    !
    ! Set up the parameter list and report the current characteristics
    !
    P[0] = NAMEDSC;
    P[1] = SERVDSC;
    P[2] = NODE_IDDSC;
    P[3] = IDDSC;
    P[4] = GRPDSC;
    P[5] = .MCASTIMR;
    P[6] = .AREA [GHB$B_LATVERSION];
    P[7] = .AREA [GHB$B_LATECO];

    IF .AREA [GHB$L_TIM_ACT] NEQ 0
    THEN
	P[8] = ACTIVE
    ELSE
	P[8] = INACTIVE;

    $SETDSC (DSC, STRSIZE, BUF);

    $FAOL
        (
        CTRSTR = %ASCID
    	%STRING
    	    (
	    '!/LCP Characteristics!/!/',
    	    'Node name = !18<\!AS\!>   Service name = !18<\!AS\!>!/',
	    'Node Identification = \!AS\!/',
    	    'Service Identification = \!AS\!/',
	    'Groups = !AS!/',
	    'Multicast timer = !UB seconds!/',
	    'LAT Version = !16<!UB.!UB!>   LAT Protocol is !AS!/'
	    ),
        OUTBUF = DSC,
        OUTLEN = DSC,
        PRMLST = P[0]
        );

    LIB$PUT_OUTPUT (DSC)

    END;

%SBTTL	'LCP_CVTGROUPS  Convert the group codes to an ascii printable string'
ROUTINE LCP_CVTGROUPS : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Covert the group codes in thr GROUPS vector to an ascii output
!   string, suitable for printing.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	GROUP vector area set up with group codes
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS,
	BITPOS,				! Bit position within longword
	SIZE,				! Length of bit stream to scan
	BYTE_OFFSET,			! Offset in group code string
	PTR,				! Pointer into output string
	LEFT_PAREN,
	RIGHT_PAREN,
	COMMA,
	INDEX
	;

    LITERAL
	STRSIZE = 512,			! Size of input and output strings
	BITSIZE = 32,			! Maximum number of bits to scan
	CVTSTRSIZE = 3			! Size of output conversion string
	;

    LOCAL
	CVTDSC : BLOCK [DSC$K_Z_BLN, BYTE],
	CVTSTR : VECTOR [CVTSTRSIZE, BYTE],
	GROUP : REF BLOCK [,BYTE]
        ;

    LEFT_PAREN = %C'('; RIGHT_PAREN = %C')'; COMMA = %C',';

    !
    !  Initialize the group codes input string
    !
    $SETDSC (GRPDSC, STRSIZE, GRPBUF);

    PTR = .GRPDSC [DSC$A_POINTER];

    PTR = CH$MOVE(1, LEFT_PAREN, .PTR);

    !
    !  Initialize the conversion output string
    !
    $SETDSC (CVTDSC, CVTSTRSIZE, CVTSTR);

    !
    ! Set up the Group codes string
    !

    BYTE_OFFSET = 0;			! Start from beginning
    GROUP = GROUPS;			! Copy the group code pointer
    !
    !	Sear the group codes one longword at a time, note that there are
    !	32 longwords that we must search. We will use the FFS library routine
    !	to find all corresponding bits that are set.
    !
    WHILE .BYTE_OFFSET LSS 32
    DO
	BEGIN
	BITPOS = 0;
	SIZE = BITSIZE;
	STATUS = TRUE;
	WHILE .STATUS AND .BITPOS LSS BITSIZE
	DO
	    BEGIN
	    STATUS = LIB$FFS(BITPOS, SIZE, GROUP[.BYTE_OFFSET,0,0,0],
			BITPOS);
	    IF .STATUS
	    THEN
		BEGIN
		!
		!   Convert the bit number + offset to a binary value,
		!   and strip off leading spaces from converted string.
		!
		STATUS = OTS$CVT_L_TI (%REF((.BYTE_OFFSET*8)+.BITPOS), CVTDSC);
		INDEX = LIB$SKPC(%ASCID %STRING(' '), CVTDSC) - 1;
		!
		!   Move the converted string to the output buffer and
		!   add a "," to the end.
		!
		PTR = CH$MOVE (.CVTDSC [DSC$W_LENGTH] - .INDEX,
			 .CVTDSC [DSC$A_POINTER] + .INDEX, .PTR);
		PTR = CH$MOVE(1, COMMA, .PTR);
		BITPOS = .BITPOS + 1;
		SIZE = .SIZE - .BITPOS
		END
	    ;
	    END
	;
	BYTE_OFFSET = .BYTE_OFFSET + 4
	END
    ;

    !
    !  Overwrite last comma with the right parenthesis
    !
    PTR = .PTR - 1;
    PTR = CH$MOVE(1, RIGHT_PAREN, .PTR);

    !
    !  Calculate size of string moved
    !
    GRPDSC [DSC$W_LENGTH] = .PTR - .GRPDSC [DSC$A_POINTER];

    END;

%SBTTL	'LCP_SHOWSERVERS  Display the LAT Servers'
ROUTINE LCP_SHOWSERVERS : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Show the LAT servers (by name) and number of active sessions.
!   interesting tidbits.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	common data area in the driver.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	errors signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BIND
	UNKNOWN = DESCRIPTOR ('UNKNOWN')
	;

    LITERAL
	BUFSIZE = 24
	;

    LOCAL
	NAME_DSC : BLOCK [DSC$K_Z_BLN, BYTE],
	PARAM_BUF : VECTOR [BUFSIZE],
	PTR : REF BLOCK [,BYTE],
	STATUS
	;


    CH$FILL (255, GHB$S_COMM_AREA, AREA);

    !
    !  Get the counters if we can, and if not then signal the error
    !
    IF NOT
	(STATUS = $CMKRNL (ROUTIN = LCPK_GETSERVERS) )
    THEN
	SIGNAL (.STATUS)
    ;

    !
    !  Convert the server info for output one at a time
    !
    !		Display:
    !
    !			Server name
    !			Server state
    !			Number of users
    !			Ethernet address
    !
    IF .AREA_RET_SIZE EQL 0
    THEN
	SIGNAL (LCP$_NOSERVERS)
    ELSE
	BEGIN
	INCR INDX FROM AREA
		TO AREA + .AREA_RET_SIZE - (GHB$K_NAMELEN + 9)
		BY GHB$K_NAMELEN + 9
	DO
	    BEGIN
	    PTR = .INDX;

	    !
	    !  Get name descriptor
	    !
	    IF .PTR [0, 0, 8, 0] EQL 0
	    THEN
		PARAM_BUF [0] = UNKNOWN
	    ELSE
		BEGIN
		PARAM_BUF [0] = NAME_DSC;
		$SETDSC (NAME_DSC, .PTR [0, 0, 8, 0], PTR [1, 0, 8, 0])
		END
	    ;

	    !
	    !  Skip over server name
	    !
	    PTR = .PTR + GHB$K_NAMELEN + 1;

	    !
	    !  Get the Ethernet address, 6 bytes (1-6)
	    !
	    PARAM_BUF [1] = .PTR [1, 0, 8, 0];
	    PARAM_BUF [2] = .PTR [2, 0, 8, 0];
	    PARAM_BUF [3] = .PTR [3, 0, 8, 0];
	    PARAM_BUF [4] = .PTR [4, 0, 8, 0];
	    PARAM_BUF [5] = .PTR [5, 0, 8, 0];
	    PARAM_BUF [6] = .PTR [6, 0, 8, 0];

	    PARAM_BUF [8] = .PTR [0, 0, 8, 0];		! Get the # of users
	    !
	    !  Display current state
	    !
	    IF .PTR [7, 0, 8, 0]
	    THEN
		PARAM_BUF [7] = ACTIVE
	    ELSE
		PARAM_BUF [7] = INACTIVE
	    ;

	    $SETDSC (OUTDSC, OUTBUFSIZE, OUTBUF);

	    STATUS = $FAOL
		(
		CTRSTR = %ASCID
		%STRING
		    (
		    '!/LCP Server Characteristics for !AS!/!/',
		    'Ethernet address = !XB-!XB-!XB-!XB-!XB-!XB !/',
		    'Server is !18<!AS!>    Active users = !18<!UB!>!/'
		    ),
		OUTLEN = OUTDSC [DSC$W_LENGTH],
		OUTBUF = OUTDSC,
		PRMLST = PARAM_BUF [0]
		);

	    IF NOT .STATUS THEN SIGNAL (.STATUS);

	    STATUS = LIB$PUT_OUTPUT (OUTDSC);

	    IF NOT .STATUS THEN SIGNAL (.STATUS)

	    END
	;


	END

    END;

%SBTTL	'LCP_HELP Give HELP'
GLOBAL ROUTINE LCP_HELP : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   This routine is the LATCP help facility, and will display
!   useful and informative explanations of the LATCP facility.
!
! CALLING SEQUECE:
!    standard
!
! INPUT PARAMETERS:
!    none
!
! IMPLICIT INPUTS:
!    none
!
! OUTPUTS PARAMETERS:
!    none
!
! IMPLICIT OUTPUTS:
!
!    The help text will be printed on SYS$OUTPUT.
!
! ROUTINES CALLED:
!
!    LBR$OUTPUT_HELP
!
! ROUTINE VALUE:
!    none
!
! SIGNALS
!    none
!
! SIDE EFFECTS:
!    none
!
!--

    BEGIN

    EXTERNAL ROUTINE

	LBR$OUTPUT_HELP	: ADDRESSING_MODE(GENERAL);

    BIND

	LIBRARY_NAME	= DESCRIPTOR ('LATCP'),		! HELP text library
	KEYWORDS_DSC	= DESCRIPTOR ('KEYWORDS');	! Keywords desc

    LOCAL

	SUBCMD_DSC	: BLOCK [DSC$K_Z_BLN, BYTE],	! Rest of line
	STATUS;

    
!
!  Get help keywords and uppercase them
!
    CH$FILL (0, DSC$C_Z_BLN, SUBCMD_DSC);		! Zero fill desc
    SUBCMD_DSC [DSC$B_CLASS] = DSC$K_CLASS_D;	! Fill in desc class
    CLI$GET_VALUE (KEYWORDS_DSC, SUBCMD_DSC);	! Get the KEYWORDS
    IF .SUBCMD_DSC [DSC$W_LENGTH] NEQ 0
    THEN
	STR$UPCASE (SUBCMD_DSC, SUBCMD_DSC);

!
!  Call LBR$OUTPUT_HELP to do all the real work.
!
    LBR$OUTPUT_HELP (LIB$PUT_OUTPUT, 0, SUBCMD_DSC,
		LIBRARY_NAME, 0, LIB$GET_INPUT);
    END;


%SBTTL	'LCP_FAOOUTPUT  Convert and write a string'
ROUTINE LCP_FAOOUTPUT (FAOSTR, DATA) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Convert 32 bytes to a suitable parameter list for fao.  The fao
!   parameter string and the address of the data are passed.
!
! FORMAL PARAMETERS:
!
!	FAOSTR		Address of desc of fao control string
!	DATA		Address of 8 bytes of data
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	DATA : REF VECTOR [, BYTE]
	;

    LOCAL
	STATUS,
	EXPLODE : VECTOR [32, LONG]
	;

    !
    ! Set the output buffer descriptor
    !
    $SETDSC (OUTDSC, OUTBUFSIZE, OUTBUF);

    !
    ! Explode the data to longwords eight bytes of a time.
    !
    IF .DATA NEQ 0
    THEN
	BEGIN
	EXPLODE [ 0] = DATA [0];	! Get address of time
	INCR IDX FROM 8 TO 31
	DO
	    BEGIN
	    EXPLODE [.IDX-7] = .DATA [.IDX]
	    END
	END
    ;

    !
    ! Convert and print an output line
    !
    STATUS = $FAOL
	(
	CTRSTR = .FAOSTR,
	OUTLEN = OUTDSC [DSC$W_LENGTH],
	OUTBUF = OUTDSC,
	PRMLST = EXPLODE
	);

    IF NOT .STATUS THEN SIGNAL (.STATUS);

    STATUS = LIB$PUT_OUTPUT (OUTDSC);

    IF NOT .STATUS THEN SIGNAL (.STATUS)

    END;

%SBTTL	'LCPK_GETCOUNTERS  Obtain the counterblock'
ROUTINE LCPK_GETCOUNTERS =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Copy the counters from the driver, to an area here for conversion.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counter block in driver
!
! IMPLICIT OUTPUTS:
!
!	counter block here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure if no driver
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    CH$MOVE (GHB$K_LENGTH, .LCP$L_AREA, AREA);
    SUCCESS

    END;

%SBTTL	'LCPK_GETSERVCTRS  Obtain the SERVER counters'
ROUTINE LCPK_GETSERVCTRS =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Copy the counters from the driver, to an area here for conversion.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counter block in driver
!
! IMPLICIT OUTPUTS:
!
!	counter block here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure if no driver
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	CSB_LIST : REF VECTOR [, LONG],
	CSB_PTR : REF VECTOR [, BYTE],
	CSB_HEADER,
	PTR
	;

    !
    !  Point to output buffer
    !
    PTR = AREA;

    !
    !  Get pointer to CSB table
    !
    CSB_LIST = .LCP$L_AREA [GHB$L_CSBLST];

    !
    !  Get the counters from each active CSB
    !
    IF .CSB_LIST NEQ 0
    THEN
	INCR INDX FROM 0 TO GHB$K_ACT_CSBS - 1
	DO
	    BEGIN
	    CSB_PTR = .CSB_LIST [.INDX];
	    IF .CSB_PTR NEQ 0
	    THEN
		PTR = CH$MOVE (LCB_C_LENGTH + GHB$K_NAMELEN + 1,
			       CSB_PTR [GHB$T_CSBCTR], .PTR)
	    END
	;

    !
    !  Get pointer to inactive CSB queue, go through queue in reverse order.
    !
    CSB_HEADER = LCP$L_AREA [GHB$Q_OLD_CSBS];

    !
    !  Get the counters from each inactive CSB
    !
    IF ..CSB_HEADER NEQ 0
    THEN
	BEGIN
	CSB_PTR = .(.CSB_HEADER+4);
	WHILE .CSB_PTR NEQ .CSB_HEADER
	DO
	    BEGIN
	    PTR = CH$MOVE (LCB_C_LENGTH + GHB$K_NAMELEN + 1,
			   CSB_PTR [GHB$T_CSBCTR], .PTR);
	    CSB_PTR = .(.CSB_PTR+4)
	    END
	;
	END
    ;
    !
    !  Calculate size of area filled in
    !
    AREA_RET_SIZE = .PTR - AREA;

    SUCCESS

    END;

%SBTTL	'LCPK_GETSERVERS  Obtain the SERVER information'
ROUTINE LCPK_GETSERVERS =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Copy the CSB server info from the driver, to an area here for conversion.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CSB server block in driver
!
! IMPLICIT OUTPUTS:
!
!	CSB server block info here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success or failure if no driver
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	CSB_LIST : REF VECTOR [, LONG],
	CSB_PTR : REF VECTOR [, BYTE],
	CSB_HEADER,
	PTR,
	ACTIVE_V,
	INACTIVE_V
	;

    ACTIVE_V = 1; INACTIVE_V = 0;
    !
    !  Point to output buffer
    !
    PTR = AREA;

    !
    !  Get pointer to CSB table
    !
    CSB_LIST = .LCP$L_AREA [GHB$L_CSBLST];

    !
    !  Get the info from each active CSB
    !
    IF .CSB_LIST NEQ 0
    THEN
	INCR INDX FROM 0 TO GHB$K_ACT_CSBS - 1
	DO
	    BEGIN
	    CSB_PTR = .CSB_LIST [.INDX];
	    IF .CSB_PTR NEQ 0
	    THEN
		BEGIN
		PTR = CH$MOVE (GHB$K_NAMELEN + 8,
			       CSB_PTR [GHB$T_CSBCTR + LCB_C_LENGTH], .PTR);
		PTR = CH$MOVE (1, ACTIVE_V, .PTR)
		END
	    ;
	    END
	;

    !
    !  Get pointer to inactive CSB queue, go through queue in reverse order.
    !
    CSB_HEADER = LCP$L_AREA [GHB$Q_OLD_CSBS];

    !
    !  Get the info from each inactive CSB
    !
    IF ..CSB_HEADER NEQ 0
    THEN
	BEGIN
	CSB_PTR = .(.CSB_HEADER+4);
	WHILE .CSB_PTR NEQ .CSB_HEADER
	DO
	    BEGIN
	    PTR = CH$MOVE (GHB$K_NAMELEN + 8,
			   CSB_PTR [GHB$T_CSBCTR + LCB_C_LENGTH], .PTR);
	    PTR = CH$MOVE (1, INACTIVE_V, .PTR);
	    CSB_PTR = .(.CSB_PTR+4)
	    END
	;
	END
    ;

    !
    !  Calculate size of area filled in
    !
    AREA_RET_SIZE = .PTR - AREA;

    SUCCESS

    END;

%SBTTL	'LCPK_GETHISTORY  Obtain the history buffer'
ROUTINE LCPK_GETHISTORY =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Copy the history buffer from the driver, to an area here for conversion.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	counter block in driver
!
! IMPLICIT OUTPUTS:
!
!	counter block here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	HIST_BUF : REF BLOCK [,BYTE]
	;

    !
    !  If no history buffer, return error
    !
    IF .LCP$L_AREA [GHB$L_HISTORY] EQL 0
    THEN
	RETURN LCP$_NOHISTORY
    ;

    !
    !  Copy the history buffer
    !
    HIST_BUF = .LCP$L_AREA [GHB$L_HISTORY];
    CH$MOVE (GHB$K_HISTSIZE,
	HIST_BUF [HBF_Z_DATA], AREA);

    SUCCESS

    END;

%SBTTL	'LCPK_GETCOMMON  Kernel mode routine to get common buffer area'
ROUTINE LCPK_GETCOMMON =

!++
! FUNCTIONAL DESCRIPTION:
!
!   Kernel mode routine to get the information from the common area in
!   driver.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	results of the qualifier parse
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	qualifier results set for multicast
!
!--

    BEGIN

    LOCAL
	LT : REF BLOCK [,BYTE],
	PTR,
	STR : REF BLOCK [,BYTE]
	;

    !
    !  Setup the output descriptor
    !
    $SETDSC (OUTDSC, OUTBUFSIZE, OUTBUF);

    !
    ! Copy the common area
    !
    PTR = CH$MOVE (GHB$S_COMM_AREA, .LCP$L_AREA, AREA);

    !
    ! Copy the node information to the output buffer area
    !
    LT = .LCP$L_AREA;
    STR = .LT [GHB$L_NODE];
    PTR = .OUTDSC [DSC$A_POINTER];
    PTR = CH$MOVE (.STR [-2, 0, 16, 0], .LT [GHB$L_NODE], .PTR);

    SUCCESS

    END;

END				!End of module
ELUDOM
