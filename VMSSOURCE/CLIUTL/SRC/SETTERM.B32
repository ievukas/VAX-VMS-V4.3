MODULE setterm ( IDENT = 'V04-000',
		ADDRESSING_MODE (EXTERNAL = GENERAL)) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  SET Command
!
! ABSTRACT:
!
!	This module implements the DCL command SET TERMINAL.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, user mode
!
! AUTHOR:  Gerry Smith				21-Mar-1983
!
!
! Modified by:
!
!	V03-016	BLS0347		Benn Schreiber		29-AUG-1984
!		Only activate smg if we really need to.
!
!	V03-015 EMB0112		Ellen M. Batbouta	2-AUG-1984
!		Place the IO$M_NOECHO modifier on the readprompt
!		QIO in module, INQUIRE_TYPE.  This prevents the
!		escape sequence for the VT200 terminals being displayed
!		on the screen on a SET TERMINAL/INQUIRE command.
!
!	V03-014	JRL0003		John R. Lawson, Jr.	18-May-1984 15:18
!		For reasons of speed, do not let the linker resolve
!		external references to the SMG (shareable image).
!		SMG is only required when SET TERMINAL is issued, not
!		for any other SET command. Therefore, at the risk of
!		slowing down SET TERMINAL, other SET's are sped up by
!		linking to and activating SMG only when necessary.
!
!	V03-013 EMD0083		Ellen M. Dusseault	12-Apr-1984
!		If /protocol is specified in the command string,
!		don't issue the warning message, /perm qualifier
!		was not specified.
!
!	V03-012 STAN3012	Stanley Rabinowitz	25-Mar-1984
!		Allow "foreign" terminal capabilities LFFILL, CRFILL and FRAME
!		to set the corresponding terminal characteristics.
!
!	V03-011 EMD0068		Ellen M. Dusseault	13-Mar-1984
!		Add warning message to tell the user that the
!		permanent characteristics will be used since 
!		the command issued did not contain the /perm
!		qualifier and the user does not have a channel
!		assigned to the terminal which was specified in
!		the command string.
!		
!	V03-010 EMD0061		Ellen M. Dusseault	8-Mar-1984
!		Check to see if the terminal characteristic, regis,
!		is available if the terminal is a pro or rainbow when 
!		processing the command set term/inq.
!
!	V03-009 STAN009		Stanley Rabinowitz	4-Mar-1984
!		Add support for "foreign" terminals.
!		If the terminal device type is not known,
!		call the RTL TERMTABLE interface routines
!		to see if it is defined there.  If it is,
!		then set up the terminal characteristics from
!		the TERMTABLE information.
!		-----
!		Give symbolic name, data_bufsiz, to the size of the data_buffer.
!
!	V03-008 EMD0051		Ellen M. Dusseault	28-Feb-1984
!		Add support for SET TERMINAL/[NO]DEC_CRT=(1,2) to
!		implement new terminal characteristic, DEC_CRT2.
!		Also a new device name, PRO_SERIES is introduced.
!
!	V03-007	MMD0234		Meg Dumont,	4-Feb-1984  14:42
!		Add support for SET TERMINAL/PROTOCOL for switching terminal 
!		ports to and from asynch ddcmp decnet lines.
!
!	V03-006	MIR0300		MICHAEL I. ROSENBLUM	9-JAN-1984
!		Fix problems that were encountered during field test
!		1. SET TER/LOCAL should set NOECHO
!		2. SET TER/SPEED should clear autobaud
!		3. SET TER/INQUIRE should send out the normal ansi sequence
!			in seven bit mode as well as 8 bit mode.
!		4. SET TER/LOG SHOULD REPORT THE SPEED CORRECTLY
!
!	V03-005	MIR0083		Michael I. Rosenblum	23-Aug-1983
!		Reset terminal characteristics on the terminal line if
!		the set term/inq fails so not to leave the terminal in
!		8-bit mode.
!
!	V03-004	MIR0071		Michael I. Rosenblum	22-Jul-1983
!		Add code to inquire to parse 8-Bit inquire sequences.
!		add code to timeout all writes this will some timeing
!		problems when the terminal is control-s'ed
!
!	V03-003	GAS0143		Gerry Smith		22-Jun-1983
!		Lower all non-syntax ERRORs to WARNINGs.
!
!	V03-002	MIR0035		Michael I. Rosebnblum	27-Apr-1983
!		Add support for VT200 series terminals and VT200
!		Inquire sequences.  Add support for multiple frame
!		sizes, Dismissing parity errors.  Fix /Log qualifier.
!
!	V03-001	GAS0117			Gerry Smith	 7-Apr-1983
!		If a terminal is set /AUTOBAUD, also set the speed to 9600.
!
!--

!
! Include files
!
LIBRARY 'SYS$LIBRARY:LIB';			! VAX/VMS common definitions
REQUIRE 'SRC$:SHOWDEF';				! SHOW common definitions

!
! Define macros for the fields within each terminal block.  These 
! also correspond to the fields in the SENSEMODE/SENSECHAR block.
!
MACRO
    term$b_class  =  0, 0,  8, 0%,
    term$b_type   =  1, 0,  8, 0%,
    term$w_width  =  2, 0, 16, 0%,
    term$b_page   =  7, 0,  8, 0%,
    term$l_set1   =  4, 0, 32, 0%,
    term$l_set2   =  8, 0, 32, 0%,
    term$l_clr1   = 12, 0, 32, 0%,
    term$l_clr2   = 16, 0, 32, 0%,
    term$l_rspnum = 20, 0, 32, 0%,
    term$l_rspblk = 24, 0, 32, 0%;

!
! The data that gets used by all the subroutines is more easily handled
! in Bliss if it is actually a vector of data.  Then, thru a BIND, all
! the separate names can be used to identify the various elements of the
! vector. The length of the vector (in longwords) is given by the
! literal data_bufsiz.
!
MACRO bind_data =
    BIND
	tt1_set    = data_buffer[0] : BITVECTOR[32],
	tt1_clr    = data_buffer[1] : BITVECTOR[32],
	tt2_set    = data_buffer[2] : BITVECTOR[32],
	tt2_clr    = data_buffer[3] : BITVECTOR[32],
	speed      = data_buffer[4],
	parity     = data_buffer[5],
	fill       = data_buffer[6],
	flags      = data_buffer[7] : $BBLOCK[4],
	dev_desc   = data_buffer[8] : $BBLOCK[dsc$c_s_bln],
	info_block = data_buffer[10] : $BBLOCK[12],
	index	   = data_buffer[13],
	chan       = data_buffer[14] : WORD,
    	deccrt_set = data_buffer[15] : BITVECTOR[32],
    	deccrt_clr = data_buffer[16] : BITVECTOR[32],
	name_desc  = data_buffer[17] : $BBLOCK[dsc$c_s_bln]; %;

LITERAL

	data_bufsiz = 19;	! Number of longwords in data_buffer.

!
! Define FLAGS bits
!
MACRO
    set$v_log   = 0, 0, 1, 0%,			! Logging desired
    set$v_perm  = 0, 1, 1, 0%,			! Permanent chars requested
    set$v_odd   = 0, 2, 1, 0%,			! Odd parity requested
    set$v_even  = 0, 3, 1, 0%,			! Even parity requested
    set$v_nopar = 0, 4, 1, 0%,			! Parity turned off
    set$v_lf    = 0, 5, 1, 0%,			! LFfill given
    set$v_cr    = 0, 6, 1, 0%,			! CRfill given
    set$v_speed = 0, 7, 1, 0%,			! New speed given
    set$v_width = 0, 8, 1, 0%,			! Width changed
    set$v_page  = 0, 9, 1, 0%,			! Page length changed
    set$v_frame = 0,10, 1, 0%,			! frame size changed
    set$v_dismis= 0,11, 1, 0%,			! Dismiss parityerror
    set$v_nodism= 0,12, 1, 0%,			! Dismiss parity turned off
    set$v_vt200 = 0,13, 1, 0%,			! vt200 series terminals
    set$v_network=0,14, 1, 0%;			! Set to set port to a decnet port


!
! Table of contents
!

FORWARD ROUTINE
    set$terminal : NOVALUE,		! Main module of SET TERMINAL
    write_timeout : NOVALUE,		! Cancel active IO
    get_term_type,			! Set a particular term type
    get_term_def,			! Get definition from TERMTABLE
    inquire_type,			! Ask the terminal what it is
    get_values,				! Collect values
    log_results : NOVALUE;		! Log all results

!
! External routines
!
EXTERNAL ROUTINE
!   smg$init_term_table,		! Get address of data block from
					! TERMTABLE that describes this kind
					! of terminal
!   smg$get_term_data,			! Get data from TERMTABLE definition
!   smg$del_term_table,			! Delete virtual memory used by
					! TERMTABLE support
    switch_to_terminal,			! Switch to a terminal line
    switch_to_ddcmp,			! Switch to a Asynch DDCMP port
    str$append,				! Append ASCII strings
    lib$cvt_dtb,			! Convert ASCII to binary
    cli$get_value,			! Get value from CLI
    cli$present;			! See if qualifier is present


!
!	Mechanisms for Post-activation linking to SMG
!

macro	! So I don't need to change every occurrence in the program

   SMG$INIT_TERM_TABLE = ( .$SMG$INIT_TERM_TABLE ) %,
   SMG$DEL_TERM_TABLE = ( .$SMG$INIT_TERM_TABLE ) %,
   SMG$GET_TERM_DATA = ( .$SMG$GET_TERM_DATA ) %;

external routine	! To do the actual linking

   LIB$FIND_IMAGE_SYMBOL;

own	! To hold the addresses of the actual routines

   $SMG$INIT_TERM_TABLE,
   $SMG$DEL_TERM_TABLE,
   $SMG$GET_TERM_DATA: long;


!
! External references
!
EXTERNAL
    protocol$_none : vector,		! Protocol type "NONE" descriptor
    protocol$_ddcmp : vector,		! Protocol type "DDCMP" descriptor
    term$_table : BLOCKVECTOR[,28,BYTE],! Table of known terminals
    term$_name : VECTOR,		! Table of their names
    term$_ttset_key : VECTOR,		! Keywords
    term$_ttset_bit : VECTOR,		! and their bitmasks (devdepend)
    term$_ttclr_key : VECTOR,		! Keywords (inverse)
    term$_ttclr_bit : VECTOR,		! and their bitmasks 
    term$_tt2set_key : VECTOR,		! Keywords and
    term$_tt2set_bit : VECTOR,		! their bitmasks (devdepnd2)
    term$_tt2clr_key : VECTOR,		! Inverted keywords
    term$_tt2clr_bit : VECTOR,		! their bits
    term$_reqblk : VECTOR,		! Vector of request strings
    term$_odd : VECTOR,			! "Odd" descriptor
    term$_even : VECTOR,		! "Even" descriptor
    term$_none : VECTOR,		! "None" descriptor
    term$_spdblk : VECTOR;		! Vector of speed descriptors
    

!
! Macro to generate descriptors names SD_string
!
MACRO
    SD[A] =
	BIND %NAME('SD_',A) = $DESCRIPTOR(A)%;

SD(
	'SMGSHR',
	'PROTOCOL',
	'PARITY',
	'FRAME',
	'PAGE',
	'WIDTH',
	'CRFILL',
	'LFFILL',
	'SPEED',
	'DEC_CRT',
	'NO',
	'DEVICE_TYPE',
	'DEC_CRT2');

BIND
    SD_COMMA = $DESCRIPTOR(',');		!Descriptor of a comma
!
! Declare some shared messages
!
$SHR_MSGDEF	(SET,119,LOCAL,
    		(invquaval,	error));


!
! Declare literals defined elsewhere
!
EXTERNAL LITERAL
    term$_num,				! Number of known terminals
    term$_ttset_num,			! Number of DEVDEPEND bits/keywords
    term$_ttclr_num,			! Number of inverted bits/keywords
    term$_tt2set_num,			! Number of DEVDEPND2 bits/keywords
    term$_tt2clr_num,			! Number of inverted bits/keywords
    term$_spdnum,			! Number of terminal speeds
    term$_reqnum,			! Number of request strings
    term$_vk100,			! Identifiers for the VT1XX family
    term$_vt100,			! of non-compatible terminals
    term$_vt101,
    term$_vt102,
    term$_vt105,
    term$_vt125,
    term$_vt131,
    term$_vt132,
    term$_vt173,
    term$_vt52,				! old clunkers
    term$_vt200_series,			! Vt200 series terminals
    term$_pro_series,			! Pro series terminals
    term$_ft1,				! Beginnning of foreign terminals
    term$_ft8,				! End of foreign terminals
    term$_unknown,			! "Unknown terminal" type
    set$_termset,			! Terminal characteristics set
    set$_writeerr,			! Error modifying device
    set$_unkterm,			! Terminal type unknown
    set$_noperm,			! Permanent qualifier not specified
    cli$_ivdevtype,			! Invalid device type
    cli$_absent, 			! Qualifier absent
    cli$_negated,			! Qualifier explicitly negated
    cli$_present;			! Qualifier explicitly present


GLOBAL ROUTINE set$terminal : NOVALUE =
BEGIN

!++
! Functional description
!
!	This is the routine for the SET TERMINAL command.  It is called
!	from the SET command processor,	and sets the terminal characteristics.
!
! Inputs
!	None
!
! Outputs
!	None
!
!----

LOCAL
    status,				! Status return
    set_length,				! Address of change length string
    dev_char : $BBLOCK[4],		! Store the device char from GETDVI
    dev_buffer : VECTOR[20,BYTE],	! Device buffer
    data_buffer : VECTOR[data_bufsiz]		! Buffer to hold much data
    		INITIAL (REP data_bufsiz OF (0)),	! initially clear
    info_desc : VECTOR[2],		! $GETCHN descriptor
    iosb : VECTOR[4,WORD],		! I/O status block
    default_device : long initial (0) , ! flag set to 1 device not specified
    					! use default
    dvi_list2 : $ITMLST_DECL(ITEMS=1) , ! item list for ref count
    refcount  : long initial (0) ;	! reference count for terminal device
BIND
    timeout = UPLIT(-5*10*1000*1000,-1); ! 5 seconds

!
! Bind all DATA_BUFFER to nice normal names
!
bind_data;


!
! Collect the name of the device.
!
$init_dyndesc(dev_desc);		! Make the descriptor dynamic

IF NOT cli$get_value(%ASCID 'DEVICE',	! Get the device name
		     dev_desc)
THEN
    BEGIN
    default_device = 1 ;		! Use default device
    dev_desc[dsc$w_length] = %CHARCOUNT('SYS$COMMAND');
    dev_desc[dsc$a_pointer] = UPLIT BYTE('SYS$COMMAND');
    END;

!
! Use GETDVI to determine the real device name.
!
BEGIN
LOCAL
    class,
    dvi_list : $ITMLST_DECL(ITEMS = 3);
$ITMLST_INIT(ITMLST = dvi_list,
	     (ITMCOD = dvi$_devclass,
	      BUFADR = class),
    	     (ITMCOD = dvi$_devchar,
    	      BUFADR = dev_char),
    	     (ITMCOD = dvi$_devnam,
    	      BUFADR = dev_buffer,
    	      BUFSIZ = %ALLOCATION(dev_buffer),
    	      RETLEN = dev_desc));
status = $GETDVIW(ITMLST = dvi_list,
    		  DEVNAM = dev_desc,
    		  IOSB   = iosb);
IF .status
THEN status = .iosb[0];
IF NOT .status
THEN
    BEGIN
    SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	   1, dev_desc, .status);
    RETURN;
    END
ELSE
    BEGIN
    dev_desc[dsc$w_length] = .dev_desc[dsc$w_length] - 1;
    dev_desc[dsc$a_pointer] = dev_buffer + 1;
    IF .class NEQ dc$_term
    THEN
	BEGIN
	SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	       1, dev_desc,
    	       cli$_ivdevtype);
	RETURN;
	END;
    END;
END;

!
! Assign a channel to the device. 
!
IF NOT (status = $ASSIGN(DEVNAM = dev_desc,
			 CHAN   = chan))
THEN
    BEGIN
    SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	   1, dev_desc, .status);
    RETURN;
    END;


! If /PROTOCOL was specified then switch to the type of port requested.
! If a terminal port was requested =NONE then allow other terminal
! characteristics to be set. If Asynch DDCMP port was request then
! only allow the switch to made all other qualifiers are ignored. The
! user must have OPERATOR privilege in order to make the switch. The
! port being switched can not have a non-zero reference count and
! the Asynch DDCMP driver code must be loaded into the system.

IF cli$present(SD_PROTOCOL)
   THEN
	BEGIN
	LOCAL	
	   desc : $BBLOCK [dsc$c_s_bln],
	   process_privs : $BBLOCK[8],
	   getjpi_list : $ITMLST_DECL(ITEMS=1);
	$ITMLST_INIT(ITMLST=getjpi_list,
		     (ITMCOD = jpi$_procpriv,BUFADR=process_privs));
	$INIT_DYNDESC(desc);

	! Assume that the port isn't going to become a decnet port

	flags[set$v_network] = 0;

	status = $GETJPI(ITMLST=getjpi_list);
	IF NOT .status
	   THEN
		BEGIN
		SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
	 	   	   1, dev_desc, .status);
		RETURN;
		END;
	IF NOT .process_privs[prv$v_oper]
	   THEN
		BEGIN
		SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
		    	   1, dev_desc, ss$_nopriv);
		RETURN;
		END;
	IF cli$get_value(SD_PROTOCOL, desc)
	   THEN
		BEGIN
		LOCAL arglist : vector [2];
		IF CH$EQL (.desc[dsc$w_length], .desc[dsc$a_pointer],
			   .desc[dsc$w_length], .protocol$_none[1])
		   THEN
			BEGIN
			arglist[0] = 1;
			arglist[1] = .chan;
			IF NOT (STATUS = $CMKRNL(ROUTIN = switch_to_terminal,
						 ARGLST = arglist))
			   THEN
				BEGIN
				SIGNAL(set$_writeerr AND NOT sts$m_severity 
					OR sts$k_warning,1, dev_desc, .status);
				RETURN;
				END;

			! Clear the network bit in dev_char. Now that the device
			! is a terminal again we can allow the remainder
			! of the set to happen.

			dev_char[dev$v_net] = 0;
			END
		   ELSE
			BEGIN

			! Switch to a decnet device only after the terminal
			! characteristics have been updated to the ones
			! the user specified on the command line.

			IF CH$EQL (.desc[dsc$w_length], .desc[dsc$a_pointer],
				   .desc[dsc$w_length], .protocol$_ddcmp[1])
			   THEN
				BEGIN
				flags[set$v_network] = 1;
				END
			   ELSE
				BEGIN
				SIGNAL(set$_writeerr AND NOT sts$m_severity 
					OR sts$k_warning,1, dev_desc, 
					set$_invquaval,
					2, desc, SD_PROTOCOL);
				RETURN;
				END
			END
		END
	    ELSE
		BEGIN
 		SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
			1, dev_desc, .status);
		RETURN;
		END
	END;

! If the NET bit is set in DEV_CHAR then this is a DECNET terminal port
! and allowing the set continue can produce strange results.

IF .dev_char[dev$v_net]
   THEN
	BEGIN
	SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
		1, dev_desc, ss$_termnetdev);
	RETURN;
	END;
	
!
! Determine if this is /PERM or just normal.  See if logging is required.
!
flags[set$v_perm] = cli$present(%ASCID 'PERMANENT');
flags[set$v_log] = cli$present(%ASCID 'LOG');

! Generate a warning message under the following conditions:
!	1. a specific terminal device was specified,
!	2. the perm qualifier is absent from the command,
!	3. the refcount is 1 (this routine has the only channel),
!	4. the protocol qualifer is absent from the command
! The warning message will tell the user that the permanent characteristics
! will be used after this routine deassigns its channel to the terminal
! (ref count will drop to 0). Therefore it is possible that his efforts to
! modify characteristics will be fruitless .

$ITMLST_INIT( ITMLST = dvi_list2,( ITMCOD = dvi$_refcnt, BUFADR = refcount )) ;
status = $GETDVIW ( ITMLST = dvi_list2, DEVNAM=dev_desc, iosb = iosb) ;
IF .status
THEN status = .iosb[0];
IF NOT .status
THEN
    BEGIN
    SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	   1, dev_desc, .status);
    RETURN;
    END
ELSE
    BEGIN
    	IF  (.refcount EQL 1)
                AND 
            ( NOT .default_device ) 
    	        AND 
            ( NOT .flags[set$v_perm] ) 
    		AND
    	    ( NOT cli$present(SD_PROTOCOL) )
    	THEN
    	    SIGNAL( set$_noperm AND NOT sts$m_severity OR  sts$k_warning ) ;
    END;
!
! Get the characteristics
!
status = $QIOW(CHAN = .chan,
	       FUNC = (IF .flags[set$v_perm]
		       THEN io$_sensechar
		       ELSE io$_sensemode),
	       IOSB = iosb,
	       P1   = info_block,
	       P2   = 12);
IF .status
THEN status = .iosb[0];
IF NOT .status
THEN
    BEGIN
    SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	   1, dev_desc, .status);
    RETURN;
    END;
!
! zero the parity flags and fill characteristics.
!
parity = 0;
fill = 0;

!
! See if a specific terminal type was specified.  If an error, then it has
! already been signaled, and we should just go away.
!
IF NOT get_term_type(data_buffer)
THEN RETURN;

!
! Get individual qualifiers.  If an error occurred, then it has already been
! signaled and we should just return.
!
IF NOT get_values(data_buffer)
THEN RETURN;
IF .flags[set$v_width]					! If width changed and this
AND .$BBLOCK[info_block[term$l_set2], tt2$v_deccrt]	! and it's a DEC crt
THEN IF .info_block[term$w_width] GTR 80			! If wide screen
    THEN						! set length to 132
	BEGIN						! and fix page length
	set_length = UPLIT BYTE (27,'[?3h');
	IF NOT .$BBLOCK[info_block[term$l_set2], tt2$v_avo]
	THEN info_block[term$b_page] = 14;
	END
    ELSE						! If narrow, set
	BEGIN						! length to 80
	set_length = UPLIT BYTE (27, '[?3l');		! and adjust page
	IF NOT .$BBLOCK[info_block[term$l_set2], tt2$v_avo]
	THEN info_block[term$b_page] = 24;
	END;


!
! Now set the stuff explicitly requested by the user
!
status = $QIOW(CHAN = .chan,
	       FUNC = (IF .flags[set$v_perm]
		       THEN io$_setchar
		       ELSE io$_setmode),
	       IOSB = iosb,
	       P1   = info_block,
	       P2   = 12,
	       P3   = .speed,
	       P4   = .fill,
	       P5   = .parity);
IF .status
THEN status = .iosb[0];
IF .status EQL ss$_incompat
THEN SIGNAL(.status);
IF NOT .status
THEN
    Begin
	SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	    1, dev_desc, .status);
	RETURN;
    End;

! Now check the flag and switch to a decnet port if the user requested to
! do so.

IF .flags[set$v_network]
   THEN
	BEGIN
	LOCAL	arglist : vector[2];
	arglist[0] = 1;
	arglist[1] = .chan;
	IF NOT (STATUS = $CMKRNL(ROUTIN = switch_to_ddcmp,
				 ARGLST = arglist))
	   THEN
		BEGIN
		SIGNAL(set$_writeerr AND NOT sts$m_severity 
			OR sts$k_warning,1, dev_desc, .status);
		RETURN;
		END
	   ELSE
		RETURN;
	END;
!
! Now to set the characteristics.  First check to see if, because the
! width has changed, we need to fix the screen.  Then set the explicit stuff.
!
IF .flags[set$v_width]					! If width changed and this
AND .$BBLOCK[info_block[term$l_set2], tt2$v_deccrt]	! and it's a DEC crt
THEN
    BEGIN

    $SETIMR(DAYTIM = timeout,		! Set timeout timer going
	ASTADR = write_timeout,
	REQIDT = .chan);

    status = $QIOW(CHAN = .chan,
		   FUNC = io$_writevblk,
		   P1   = .set_length,
		   P2   = 5,
		   IOSB = iosb);

    $CANTIM(REQIDT = .chan);			! Cancel the timer
    IF .status 
    THEN IF .iosb[0] NEQ 0 THEN status = .iosb[0];
    IF NOT .status
    THEN
	BEGIN
	SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	       1, dev_desc, .status);
	RETURN;
	END;
    END;
IF .$BBLOCK[info_block[term$l_set2],tt2$v_deccrt]
   OR (.info_block[term$b_type] EQL .term$_table[term$_vt52, term$b_type])
THEN
    BEGIN
    LOCAL set_kpstate;

    $SETIMR(DAYTIM = timeout,		! Set timeout timer going
	ASTADR = write_timeout,
	REQIDT = .chan);

    status = $QIOW(CHAN = .chan,
		   FUNC = io$_writevblk,
		   P1   = (IF .$BBLOCK[info_block[term$l_set2],tt2$v_app_keypad]
			    THEN UPLIT BYTE (27, '=') ELSE UPLIT BYTE (27,'>')),
		   P2   = 2,
		   IOSB = iosb);

    $CANTIM(REQIDT = .chan);			! Cancel the timer
    IF .status 
    THEN IF .iosb[0] NEQ 0 THEN status = .iosb[0];
    IF NOT .status
    THEN
	BEGIN
	SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
    	       1, dev_desc, .status);
	RETURN;
	END
    END;
IF .flags[set$v_vt200]
THEN
    BEGIN
    $SETIMR(DAYTIM = timeout,		! Set timeout timer going
	ASTADR = write_timeout,
	REQIDT = .chan);

    status = $QIOW(CHAN = .chan,
    		   FUNC = io$_writevblk,
    		   P1   = uplit byte (27,'[62"p',27,' F'),
    		   P2   = 9,
    		   IOSB = iosb);

    $CANTIM(REQIDT = .chan);			! Cancel the timer
END;
IF .flags[set$v_log]
THEN log_results(data_buffer);
    
RETURN;
END;


ROUTINE write_timeout(chan): NOVALUE =

!---
!
!	The timeout has elapsed while trying to write to the primary
!	output stream.  We assume that the user pressed control/s to
!	inhibit completion of the write.  Cancel the I/O to force
!	completion of the $QIO.
!
! Inputs:
!
!	CHAN = The channel to cancel io on.  Since this is called
!		from a timer ast the channel must be the request id.
!
! Outputs:
!
!	None
!---
BEGIN
    $CANCEL(CHAN = .chan); ! Cancel the I/O to the terminal
END;

ROUTINE get_term_type (data_buffer) =
BEGIN

!++
! Functional description
!
!	This routine determines if a specific device type was specified,
!	and, if it was, sets the associated fields in the device 
!	characteristics buffer.
!	
!
! Inputs
!	DATA_BUFFER - contains all the meaningful data
!
! Outputs
!	INFO_BLOCK - will be changed according to what device type was 
!	INDEX      - will be set to a number corresponding to the term type
!	
!
!----

MAP
    data_buffer : REF VECTOR;

!
! Bind the data buffer to names we understand.
!
bind_data;

BUILTIN
    CALLG,
    AP;

LOCAL
    status;

index = -1;				! To show nothing specified

!
! See if /INQUIRE was specified.
!
IF cli$present(%ASCID 'INQUIRE')
THEN
    BEGIN
    IF NOT inquire_type(.data_buffer)
    THEN RETURN 0;
    END;

!
! See if a specific devtype was mentioned.  Before the /DEVICE_TYPE
! qualifier was implemented, it was possible to specify a devtype just
! by calling it out, e.g. /VT100.  So, to stay compatible with earlier
! versions, see if any of those were specified.
!
IF .index EQL -1
THEN INCR i FROM 0 TO 14 DO
    (IF cli$present(.term$_name[.i])
     THEN (index = .i; EXITLOOP));

!
! The newer method gets a value for DEVICE_TYPE.  So, if nothing found
! yet, try /DEVICE_TYPE.
!
IF .index EQL -1
THEN
    BEGIN
    $init_dyndesc(name_desc);
    IF cli$get_value(SD_DEVICE_TYPE, name_desc)
    THEN
	BEGIN
	DECR i FROM  term$_num - 1 TO 0 DO
	    BEGIN
	    BIND name = .term$_name[.i] : $BBLOCK;
	    IF CH$EQL(.name_desc[dsc$w_length], .name_desc[dsc$a_pointer],
		      .name_desc[dsc$w_length], .name[dsc$a_pointer])
	    THEN (index = .i; EXITLOOP);
	    END;
	IF .index EQL -1
	THEN
	    BEGIN
	    !
	    ! Didn't find a known type.  See if this terminal is
	    ! defined in TERMTABLE.EXE, the terminal definition file.
	    !
	    status = CALLG (.AP, get_term_def);
	    IF NOT .status
	    THEN
		RETURN 0		! errors already signalled
	    ELSE
		RETURN 1;		! get_term_def stored type, width, etc.
	    END;
    	END;
    END;

!
! If a device type was specified, set it.  But first, a word about the
! way that things get set or don't get set.
!
! If the device type was specified as FT1 thru FT8, simply set the type
! field.
!
! If /UNKNOWN, then set the type field and clear some bits in the second
! characteristics longword.
!
IF .index NEQ -1
THEN
    BEGIN
    LOCAL 
	mask;
    info_block[term$b_type] = .term$_table[.index, term$b_type];
    IF .index GEQ term$_ft1	
    AND .index LEQ term$_ft8
    THEN RETURN 1;

    mask = .term$_table[.index, term$l_set2] OR 
	   .term$_table[.index,term$l_clr2];
    info_block[term$l_set2] = .info_block[term$l_set2]
			    AND NOT .mask
			    OR .term$_table[.index, term$l_set2];
    IF .index EQL term$_unknown
    THEN RETURN 1;

    info_block[term$w_width] = .term$_table[.index, term$w_width];
    info_block[term$b_page] = .term$_table[.index, term$b_page];
    mask = .term$_table[.index, term$l_set1] OR 
	   .term$_table[.index, term$l_clr1];
    info_block[term$l_set1] = .info_block[term$l_set1]
				AND NOT .mask
				OR .term$_table[.index, term$l_set1];
    END;

RETURN 1;
END;

ROUTINE get_values (data_buffer) =
BEGIN

!++
! Functional description
!
!	This routine interrogates the CLI to obtain values for various 
!	terminal characteristics.  
!
! Inputs
!	CHAN - channel which is assigned to the terminal
!
! Outputs
!	INFO_BLOCK - changed to reflect qualifiers
!	TT1        - tells what was set/cleared in 1st characteristic longword
!	TT2    	   - tells what was set/cleared in 2nd characteristic longword
!	SPEED  	   - contains the new speed values
!	PARITY     - contains new parity code
!	FILL       - contains new fill characteristics
!	FLAGS      - bits set to show what was changed
!
!----

MAP
    data_buffer : REF VECTOR;

!
! Bind the data buffer to names we understand.
!
bind_data;

LOCAL
    crfill,
    deccrt,
    lffill,
    desc : $BBLOCK[dsc$c_s_bln],
    status,
    status2 ;

$init_dyndesc(desc);				! Make a dynamic descriptor

!
! Parity.
!
status = cli$present (SD_PARITY);
IF .status 					! If present,
THEN
    BEGIN					! say that we want to change
    parity = .parity OR tt$m_parity OR tt$m_altrpar;! parity, assume even.
    IF cli$get_value(SD_PARITY, desc)		! If a parity value given
    THEN
	BEGIN
	IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		  .desc[dsc$w_length], .term$_odd[1])
	THEN
	    BEGIN
	    parity = .parity OR tt$m_odd;
	    flags[set$v_odd] = 1;
	    END
	ELSE IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
	    	       .desc[dsc$w_length], .term$_even[1])
	THEN flags[set$v_even] = 1
    	ELSE IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		       .desc[dsc$w_length], .term$_none[1])
	THEN status = cli$_negated
	ELSE
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_PARITY);
	    RETURN 0;
	    END;
	END;
    END;
IF .status EQL cli$_negated
THEN
    BEGIN
    parity = (.parity OR tt$m_altrpar) AND NOT (tt$m_parity OR tt$m_odd);
    flags[set$v_nopar] = 1;
    END;
!
! frame size
!
IF cli$present (SD_FRAME)
THEN
    BEGIN
    LOCAL frame;
    IF cli$get_value(SD_FRAME, desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   frame)
	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_FRAME);
	    RETURN 0;
	    END;
	IF NOT (.frame EQL 0
	OR (.frame GEQ 5
	AND .frame LEQ 8))
	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_FRAME);
	    RETURN 0;
	    END;
	END;
    parity = tt$m_altframe or parity; ! say alter the frame size
    parity <0,4> = .frame;
    flags[set$v_frame] = 1;
    end;
!
! Page length
!
IF cli$present(SD_PAGE)
THEN
    BEGIN
    LOCAL page;
    flags[set$v_page] = 1;
    page = 0;
    IF cli$get_value(SD_PAGE, desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   page)
	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_PAGE);
	    RETURN 0;
	    END;
    	IF .page LSS 0
    	OR .page GTR 255
    	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_PAGE);
	    RETURN 0;
	    END;
	END;
    info_block[term$b_page] = .page;
    END;

!
! Page width
!
IF cli$present(SD_WIDTH)
THEN
    BEGIN
    LOCAL width;
    flags[set$v_width] = 1;
    width = 0;
    IF cli$get_value(SD_WIDTH, desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   width)
	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_WIDTH);
	    RETURN 0;
	    END;
    	IF .width LSS 0
    	OR .width GTR 511
    	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_WIDTH);
	    RETURN 0;
	    END;
	END;
    info_block[term$w_width] = .width;
    END;

!
! CRfill
!
crfill = 0;

IF cli$present(SD_CRFILL)
THEN 
    BEGIN
    flags[set$v_cr] = 1;
    IF cli$get_value(SD_CRFILL, desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   crfill)
	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_CRFILL);
	    RETURN 0;
	    END;
    	END;
    IF .crfill LSS 0
    OR .crfill GTR 9
    THEN
	BEGIN
	SIGNAL(set$_invquaval, 2, desc, SD_CRFILL);
	RETURN 0;
	END;
    IF .crfill EQL 0
    THEN tt1_clr = .tt1_clr OR tt$m_crfill
    ELSE tt1_set = .tt1_set OR tt$m_crfill;
    fill<0,8> = .crfill
    END;

!
! LFfill
!
lffill = 0;

IF cli$present(SD_LFFILL)
THEN
    BEGIN
    flags[set$v_lf] = 1;
    IF cli$get_value(SD_LFFILL, desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   lffill)
	THEN
	    BEGIN
	    SIGNAL(set$_invquaval, 2, desc, SD_LFFILL);
	    RETURN 0;
	    END;
    	END;
    IF .lffill LSS 0
    OR .lffill GTR 9
    THEN
	BEGIN
	SIGNAL(set$_invquaval, 2, desc, SD_LFFILL);
	RETURN 0;
	END;
    IF .lffill EQL 0
    THEN tt1_clr = .tt1_clr OR tt$m_lffill
    ELSE tt1_set = .tt1_set OR tt$m_lffill;
    fill<8,8> = .lffill
    END;

!
! When storing the fill characteristics above, it is important that
! changing one doesn't zero out the other, because either or both
! may have previously been set (by get_term_def).
!

!
! Speed.
!
IF cli$present(SD_SPEED)
THEN
    BEGIN
    IF .flags[set$v_perm]
    THEN tt2_clr = .tt2_clr OR tt2$m_autobaud;
    flags[set$v_speed] = 1;
    speed = 0;
    INCR j FROM 0 TO 1 DO
	BEGIN
	IF cli$get_value(SD_SPEED, desc)
	THEN INCR i FROM 0 to term$_spdnum-1 DO
	    BEGIN
	    BIND spd_desc = term$_spdblk[.i] : REF VECTOR;
	    IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		      .desc[dsc$w_length], .spd_desc[1])
	    THEN (speed = .speed^8 OR .i; EXITLOOP);
	    END;
	END;
    END;

!
! There are a number of different keywords which cause bits in the
! two characteristics longwords to be set.  This is relatively simple,
! since most keywords correspond to the setting of a corresponding bit,
! and the negation of a keyword causes the bit to be cleared.  Deal with
! those here.
! -Exception:  The qualifier /DEC_CRT does not uniquely correspond with
! 		a characteristic.  Instead it can have two values, 1 or 2
!		which can modify the characteristics, deccrt and deccrt2.
!		Therefore this qualifier is a special case which is proc-
!	        essed further on in this routine.
!
INCR i FROM 0 TO term$_ttset_num-1 DO			! 1st char longword
    BEGIN
    status = cli$present(.term$_ttset_key[.i]);
    IF .status
    THEN tt1_set = .tt1_set OR .term$_ttset_bit[.i]
    ELSE IF .status EQL cli$_negated
    THEN tt1_clr = .tt1_clr OR .term$_ttset_bit[.i];
    END;
INCR i FROM 0 TO term$_tt2set_num-1 DO			! 2nd char longword
    BEGIN
    status = cli$present(.term$_tt2set_key[.i]);
    IF .status
    THEN tt2_set = .tt2_set OR .term$_tt2set_bit[.i]
    ELSE IF .status EQL cli$_negated
    THEN tt2_clr = .tt2_clr OR .term$_tt2set_bit[.i];
    END;

!
! Now for the corkers.  Some (6 at present) keywords cause bits
! to be cleared; and the negation of those keywords causes the
! bit to be set.  So...
!
INCR i FROM 0 to term$_ttclr_num-1 DO
    BEGIN
    status = cli$present(.term$_ttclr_key[.i]);
    IF .status
    THEN tt1_clr = .tt1_clr OR .term$_ttclr_bit[.i]
    ELSE IF .status EQL cli$_negated
    THEN tt1_set = .tt1_set OR .term$_ttclr_bit[.i];
    END;
INCR i FROM 0 to term$_tt2clr_num-1 DO
    BEGIN
    status = cli$present(.term$_tt2clr_key[.i]);
    IF .status
    THEN tt2_clr = .tt2_clr OR .term$_tt2clr_bit[.i]
    ELSE IF .status EQL cli$_negated
    THEN tt2_set = .tt2_set OR .term$_tt2clr_bit[.i];
    END;
!
! LOCAL ECHO IMPLIES NOECHO
!
status = cli$present(%ASCID 'LOCAL_ECHO');
    IF .status
    THEN tt1_set = .tt1_set OR tt$m_noecho
    ELSE IF .status EQL cli$_negated
    THEN tt1_clr = .tt1_clr OR tt$m_noecho;

!
! Dismiss parity error modifier has a bit set in the parity longword
!
status = cli$present(%ASCID 'DISMISS_PARITY');
IF .status
THEN
    BEGIN
    flags[set$v_dismis] = 1;
    parity = .parity OR tt$m_altdispar OR tt$m_disparerr;
    END;
IF .status EQL cli$_negated
THEN
    BEGIN
    flags[set$v_nodism] = 1;
    parity = .parity OR tt$m_altdispar;
    END;

!
!  Qualifier - / [NO]DEC_CRT[=number]
!  This qualifier can set on or off the characteristics, Dec_CRT and DEC_CRT2
!  If the number specified is 1 (also the default value) the characteristic to
!  modify is dec_crt.  If the number is 2 then the characteristic is DEC_CRT2.
!
status = cli$present( SD_DEC_CRT) ;
IF (.status OR (.status EQL cli$_negated)) THEN
    BEGIN
    status2 = cli$get_value(SD_DEC_CRT, desc) ;
    INCR J FROM 0 TO 1 DO
    	BEGIN
        IF NOT .status2 THEN
            deccrt = 1
        ELSE
            BEGIN 
            IF NOT lib$cvt_dtb(.desc[dsc$w_length],
                               .desc[dsc$a_pointer],
                                deccrt)
            THEN
                BEGIN
                SIGNAL(set$_invquaval, 2, desc, SD_DEC_CRT);
                RETURN 0;
                END;
            END;
         IF ((.deccrt NEQ 1) AND (.deccrt NEQ 2)) THEN	
              BEGIN
              SIGNAL(set$_invquaval, 2, desc, SD_DEC_CRT);
              RETURN 0;
              END;
         IF .status THEN
            BEGIN
        	IF .deccrt EQL 1 THEN
        	    deccrt_set = .deccrt_set OR tt2$m_deccrt OR tt2$m_ansicrt
 	        ELSE
 	            deccrt_set = .deccrt_set OR tt2$m_deccrt2 OR tt2$m_deccrt OR tt2$m_ansicrt
            END;	
         IF .status EQL cli$_negated THEN
    	    BEGIN
      		IF .deccrt EQL 1 THEN
           	    deccrt_clr = .deccrt_clr OR tt2$m_deccrt OR tt2$m_deccrt2
    	    ELSE
        	    deccrt_clr = .deccrt_clr OR tt2$m_deccrt2;
    	    END;
         status2 = cli$get_value(SD_DEC_CRT, desc) ;
    	 IF NOT .status2 THEN exitloop ;
        END ;
    END ;

!
! One more special condition.  If ansicrt was turned off then
! deccrt levels 1 and 2 must also be turned off since they are
! a superset of ansicrt.
!
status = cli$present(%ASCID 'ANSI_CRT') ;
IF .status EQL cli$_negated THEN
   tt2_clr = .tt2_clr OR tt2$m_deccrt OR tt2$m_deccrt2 ;

!
! Now set/clear the bits, using STATUS as a mask longword.
!
status = .tt1_set OR .tt1_clr ;
info_block[term$l_set1] = .info_block[term$l_set1]
    			  AND NOT .status
    			  OR .tt1_set;
status = .tt2_set OR .tt2_clr OR .deccrt_set OR .deccrt_clr ;
info_block[term$l_set2] = .info_block[term$l_set2]
    			  AND NOT .status
    			  OR .tt2_set
    			  OR .deccrt_set;

!
! If /AUTOBAUD was specified, and no speed, then set the speed to 9600
!
IF (.tt2_set AND tt2$m_autobaud) NEQ 0		! If /AUTOBAUD specified
AND .speed EQL 0				! and no speed set
THEN speed = tt$c_baud_9600;

RETURN 1;
END;

ROUTINE inquire_type (data_buffer) =
BEGIN

!++
! Functional description
!
!	This routine implements the SET TERM/INQUIRE qualifier.  It sends
!	a message to the terminal, saying "who are you?"  If the terminal
!	responds, then we try to find a match between the pattern given and
!	the known patterns that supported DEC terminals give.
!
! Inputs
!	INFO_BLOCK - the characteristics buffer.
!	INDEX      - number which points to terminal's terminal block
!
! Outputs
!	INFO_BLOCK - will be changed according to what device type was 
!	INDEX      - will be a number, which will index to the terminal
!
!----

MAP
    data_buffer : REF VECTOR;
!
! Bind the data buffer to names we understand.
!
bind_data;

LOCAL
    ptr,					! Pointer to end of answer
    resp_len,					! Answer length
    sequence : REF VECTOR[,BYTE],		! Real answer
    resp_buffer : VECTOR[80,BYTE] 		! Place to put answer
    		INITIAL(REP 20 OF (0)),		! Zero it out first
    iosb : VECTOR[4,WORD],			! I/O status block
    tmpblock : $bblock[12],
    status;

!
! There are a number of different request strings, strings which will cause
! different terminals to respond with their identification string.  Loop
! thru these different strings, seeing if the terminal responds to any of 
! them.
!
INCR i FROM 0 to term$_reqnum - 1 DO
    BEGIN
    BIND request = .term$_reqblk[.i] : VECTOR;
    status = $QIOW(FUNC = io$_readprompt OR io$m_timed OR io$m_purge OR io$m_escape OR io$m_noecho,
		   CHAN = .chan,
		   IOSB = iosb,
		   P1   = resp_buffer,			! Place to store response
		   P2   = %ALLOCATION(resp_buffer),	! How big is the buffer
		   P3   = 4,				! Wait several seconds
		   P5   = .request[1],			! Address of request string,
		   P6   = .request[0]);			! Length of request string,
    IF .status						! Check both statuses
    THEN status = .iosb[0];
    IF 	(NOT .status) AND
	(.status NEQ ss$_timeout) AND 
	(.status NEQ ss$_badescape)			! If a real error,
    THEN 						! signal it and
	BEGIN						! return.
	SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning, 
    	       1, dev_desc,
	       .status);
	RETURN 0;
    	END;
    IF .i EQL 1 THEN
	BEGIN
	    tmpblock = .info_block;
	    tmpblock+4 = .(info_block+4) OR tt$m_eightbit;
	    $qiow (chan = .chan,
		   func = io$_setmode,
		   p1 = tmpblock);
	END;
    IF .status NEQ ss$_timeout
    THEN
	Begin

!
! At this point, we at least have something.  IOSB[3] will contain the actual
! number of characters returned as part of the escape sequence.  Now, in some
! instances (VT1XX and VT2XX families of terminals) the sequence of interest
! ends with a semicolon, followed by all manner of other stuff that should be
! meaningful, but isn't.  So the search stops at the semicolon.  But, VT52's 
! and other terminals end in a different way, with no semicolon, and/or no 
! other trailing garbage.  In those cases, the total length of good stuff 
! is the length found in IOSB[4].  Also, some sequences end with "c" and no
! semicolon.  Change that "c" to a ";".  Finally (for now), in some cases when
! a user is typing while the QIO is performed, garbage comes in before the
! valid escape sequence.  IOSB[1] is the offset into the response buffer that
! will get us to the beginning of the escape sequence, and IOSB[3] tells how
! long the escape sequence is.
!
!
! So, first get to where the "real" response sequence starts
!
	sequence = resp_buffer[.iosb[1]+1];
!
! Look for a semicolon.  If no semicolon, the IOSB[3] is the length of
! the string.  Make one further check, changing the 'c' at the end (if there
! is one) to a ';'
!
	ptr = CH$FIND_CH(.iosb[3] - 1, .sequence, ';');
	IF CH$FAIL(.ptr)
	THEN
	    BEGIN
	    resp_len = .iosb[3] - 1;
	    IF .sequence[.resp_len - 1] EQL 'c'
	    THEN sequence[.resp_len - 1] = ';';
	    END
!
! If the semicolon is found, calculate the response string length.
!
	ELSE resp_len = .ptr - .sequence + 1;

!
! Now loop thru all the terminal types, to see if any of them have the same
! response string as what we found.
!
	INCR i FROM 0 TO (term$_num -1) DO		! Go thru each term block
	    BEGIN
	    IF .term$_table[.i, term$l_rspnum] NEQ 0	! If a response block exists
	    THEN					! then go thru all the responses
		BEGIN
		BIND resp_block = .term$_table[.i, term$l_rspblk] : VECTOR;
		INCR j FROM 0 TO (.term$_table[.i, term$l_rspnum] - 1) DO
		    BEGIN
		    BIND response = .resp_block[.j] : VECTOR;
		    IF CH$EQL(.response[0], .response[1],
			      .resp_len,     .sequence)
		    THEN (index = .i; EXITLOOP);
		    END;
		IF .index NEQ -1
		THEN EXITLOOP;
		END;
	    END;

!
! If still no match, then return saying that the terminal type is unknown.
!
	IF .index NEQ -1
	THEN
	    BEGIN

!
! A VT100J looks almost like a VK100, except that the character after the
! ";" is a 2.  If that's what we have, then set it up that way.
!
	    IF .index EQL term$_vk100
	    AND .sequence[.resp_len] EQL '2'
	    THEN index = term$_vt100;

!
! In the VT1xx family of terminals, the presence of the advanced video
! is based on the character AFTER the ";".  If this character, translated
! to a "real" number, has bit 1 set (i.e. 2,3,6,7) then the terminal has
! the advanced video option.
!
	    IF .index EQL term$_vt100
	    OR .index EQL term$_vt101
	    OR .index EQL term$_vt102
	    OR .index EQL term$_vt105
	    OR .index EQL term$_vt125
	    OR .index EQL term$_vt131
	    OR .index EQL term$_vt132
	    OR .index EQL term$_vt173
	    AND
	    (   BEGIN
	        LOCAL char : BYTE;
	        char = .sequence[.resp_len] - '0';
	        .char<1,1>
	        END
	    OR
		BEGIN
		LOCAL CHAR : VECTOR[3,BYTE];
		CHAR = ';11';
		PTR = CH$FIND_SUB(.IOSB[3]-1, .SEQUENCE, 3, CHAR);
		CH$FAIL(.PTR)
		END
	    )
	    THEN tt2_set = .tt2_set OR tt2$m_avo
	    ELSE tt2_clr = .tt2_clr OR tt2$m_avo;
	    IF .index EQL term$_VT200_Series
	    THEN
	        BEGIN
	        LOCAL x,
	    	  opt200 : VECTOR[8,LONG]
	    		   PRESET ([0] = 0,
	    			   [1] = tt2$m_printer,
	    			   [2] = tt2$m_regis,
	    			   [3] = tt2$m_sixel,
	    			   [4] = 0,
	    			   [5] = 0,
	    			   [6] = tt2$m_drcs,
	    			   [7] = 0);
		tt2_set = .tt2_set OR tt2$m_avo;
	        INCR x from 1 TO 8 DO
		    BEGIN
	    	    local str: vector[2,byte];
	    	    str[0] = ';';
	    	    str[1] = '0' + .x;
	    	    ptr = CH$FIND_SUB(.iosb[3] - 1, .sequence, 2, str);
	    	    IF NOT CH$FAIL(.ptr)
	    	    THEN
	    	    	tt2_set = .tt2_set OR .OPT200[.x - 1];
	    	END;
	    flags[set$v_vt200] = 1;
	    END;
!
!  The pro terminal has the terminal characteristic, regis, set if 
!  the extended bit option in the response string is set ( first byte
!  after the actual response sequence).  Otherwise the characteristic
!  is turned off.
!    	
    	IF (.index EQL term$_pro_series )
    	THEN
    	    BEGIN
    	    tt2_set = .tt2_set or tt2$m_avo ;
    	    IF .sequence[.resp_len] EQL '1'
    	    THEN
    		tt2_set = .tt2_set or tt2$m_regis 
    	    ELSE
    		tt2_clr = .tt2_clr or tt2$m_regis ;
    	    END;
!
!  If the number 3 is present in the response then regis is
!  set for the vt102 ( the rainbow terminal can have regis)
!
    	IF .index EQL term$_vt102 
    	THEN
    	    BEGIN
    	    local str: vector[2,byte] ;
    	    str = ';3' ;
    	    ptr = ch$find_sub( .iosb[3]-1, .sequence, 2, str ) ;
    	    IF Not ch$fail(.ptr)
    	    THEN
    		tt2_set = .tt2_set or tt2$m_regis ;
    	    END;
	return 1;
	END;
    END;
END;
!
! If we went thru all the request sequences and nothing was found, then
! signal saying that the terminal type is unknown, and return.
!
tmpblock = .info_block;
tmpblock+4 = .(info_block+4);
$qiow (chan = .chan,
   func = io$_setmode,
   p1 = tmpblock);
SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning, 
       1, dev_desc, 
       set$_unkterm);
RETURN 0;
END;

ROUTINE get_term_def (data_buffer) =
BEGIN

!++
! Functional description
!
!	This routine searches TERMTABLE.EXE for a terminal definition.
!	We look in TERMTABLE only if we don't recognize the terminal
!	name.
!
!	This routine will extract various information about the terminal
!	from its definition.  This information is stored in INFO_BLOCK.
!
!	Inputs
!	      DATA_BUFFER - contains all meaningful data
!
!	Outputs
!	      fills in various fields in INFO_BLOCK
!--

MAP
    data_buffer : REF VECTOR;

MACRO

    $first_item(a,b,c,d) =

	a

    %,

    $cap_init[capability,action,characteristic,longword_number] =

	%NAME(smg$k_,capability)

    %,

    $set_init[capability,action,characteristic,longword_number] =

	$first_item( %NAME(term$l_set,longword_number) )

    %,

    $val_init[capability,action,characteristic,longword_number] =

	%IF %IDENTICAL(action,set)
	%THEN 1
	%ELSE 0
	%FI

    %,

    $msk_init[capability,action,characteristic,longword_number] =

	%NAME(	tt,

		%IF %IDENTICAL(longword_number,2) %THEN 2 %FI,

		$m_,characteristic)

    %,

    $bits[] = 

    LITERAL

	cap_size = %LENGTH/4;

    OWN

	cap_vector : VECTOR[cap_size] INITIAL( $cap_init(%REMAINING) ),
	set_vector : VECTOR[cap_size] INITIAL( $set_init(%REMAINING) ),
	val_vector : VECTOR[cap_size] INITIAL( $val_init(%REMAINING) ),
	msk_vector : VECTOR[cap_size] INITIAL( $msk_init(%REMAINING) );

    %,

    !
    ! We need to call SMG$GET_TERM_DATA several times.
    ! The code will look neater if we use a macro.
    !

    $get_term_data(request_code) =

	BEGIN
	status = smg$get_term_data( term_table_addr,
	   		            %ref(request_code),
				    %ref(4),
				    ret_length,
				    ret_buffer);
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
	           1, dev_desc, .status);
	    RETURN 0;
	    END;
	END

    %;

!
! Bind data to meaningful names
!

bind_data;

LOCAL
    crfill,
    lffill,
    frame,
    status,
    term_table_addr,
    ret_length,
    ret_buffer;

! This table describes the correspondence between TERMTABLE
! capability names and terminal characteristics.
! For example, the ADVANCED_VIDEO capability causes the AVO
! bit in the 2nd terminal characteristics longword to get set.

$BITS(

! Capability		! Action	! Characteristic	! Longword #

ADVANCED_VIDEO,		SET,		AVO,			2,
ANSI_CRT,		SET,		ANSICRT,		2,
BLOCK_MODE,		SET,		BLOCK,			2,
DEC_CRT,		SET,		DECCRT,			2,
EDIT,			SET,		EDIT,			2,
EIGHT_BIT,		SET,		EIGHTBIT,		1,
PHYSICAL_FF,		SET,		MECHFORM,		1,
FULLDUP,		CLR,		HALFDUP,		1,
LOWERCASE,		SET,		LOWER,			1,
REGIS,			SET,		REGIS,			2,
SCOPE,			SET,		SCOPE,			1,
SIXEL_GRAPHICS,		SET,		SIXEL,			2,
SOFT_CHARACTERS,	SET,		DRCS,			2,
PHYSICAL_TABS,		SET,		MECHTAB,		1);

!
!	On-the-fly activate the SMG package
!

LIB$FIND_IMAGE_SYMBOL(SD_SMGSHR,
      %ascid'SMG$INIT_TERM_TABLE', $SMG$INIT_TERM_TABLE);
LIB$FIND_IMAGE_SYMBOL(SD_SMGSHR,
      %ascid'SMG$DEL_TERM_TABLE', $SMG$DEL_TERM_TABLE);
LIB$FIND_IMAGE_SYMBOL(SD_SMGSHR,
      %ascid'SMG$GET_TERM_DATA', $SMG$GET_TERM_DATA);

!
! See if this terminal is defined in TERMTABLE.EXE.
!

IF NOT (smg$init_term_table(name_desc, term_table_addr))
THEN
    BEGIN			! error - not defined terminal
    SIGNAL(set$_writeerr AND NOT sts$m_severity OR sts$k_warning,
           1, dev_desc,
           set$_invquaval,
           2, name_desc, SD_DEVICE_TYPE);
    RETURN 0;
    END;

!
! Found this terminal name in the definition file.
! Now get the 'foreign' terminal number assigned to it.
!

$get_term_data(smg$k_vms_terminal_number);

!
! Store the terminal number
!

index = .ret_buffer;		! use this in log_results
info_block[term$b_type] = .ret_buffer<0,8>;
				! use this in QIOWs

!
! Next get the width and page size of the screen.
!

$get_term_data(smg$k_columns);

! 
! Save the width.  Note that this is optional information in
! a terminal definition so we may not have received anything
! in our buffer.
!

IF .ret_length NEQ 0
THEN
    BEGIN
    IF .ret_buffer GTRU 511
    THEN
	BEGIN
	LOCAL	desc	: VECTOR[2],
		buf	: VECTOR[64,BYTE];
	desc[0]=64;
	desc[1]=buf;
	$fao(%ASCID '!UL',desc,desc,.ret_buffer);
	SIGNAL(set$_invquaval, 2, desc, SD_WIDTH);
	RETURN 0
	END;
    info_block[term$w_width] = .ret_buffer<0,16>;
    END;

$get_term_data(smg$k_rows);

!
! Save the page size.
!

IF .ret_length NEQ 0
THEN
    BEGIN
    IF .ret_buffer GTRU 255
    THEN
	BEGIN
	LOCAL	desc	: VECTOR[2],
		buf	: VECTOR[64,BYTE];
	desc[0]=64;
	desc[1]=buf;
	$fao(%ASCID '!UL',desc,desc,.ret_buffer);
	SIGNAL(set$_invquaval, 2, desc, SD_PAGE);
	RETURN 0
	END;
    info_block[term$b_page] = .ret_buffer <0,8>;
    END;

!
! Get the fill characteristics.
!

$get_term_data(smg$k_cr_fill);

! 
! Save the carriage return fill count.
!

IF .ret_length EQL 0
THEN
    crfill=0
ELSE
    BEGIN
    BIND set1 = info_block[term$l_set1] : $bblock;
    IF .ret_buffer GTRU 9
    THEN
	BEGIN
	LOCAL	desc	: VECTOR[2],
		buf	: VECTOR[64,BYTE];
	desc[0]=64;
	desc[1]=buf;
	$fao(%ASCID '!UL',desc,desc,.ret_buffer);
	SIGNAL(set$_invquaval, 2, desc, SD_CRFILL);
	RETURN 0
	END;
    crfill = .ret_buffer;
    set1[tt$v_crfill]=1
    END;

$get_term_data(smg$k_lf_fill);

! 
! Save the line feed fill count.
!

IF .ret_length EQL 0
THEN
    lffill=0
ELSE
    BEGIN
    BIND set1 = info_block[term$l_set1] : $bblock;
    IF .ret_buffer GTRU 9
    THEN
	BEGIN
	LOCAL	desc	: VECTOR[2],
		buf	: VECTOR[64,BYTE];
	desc[0]=64;
	desc[1]=buf;
	$fao(%ASCID '!UL',desc,desc,.ret_buffer);
	SIGNAL(set$_invquaval, 2, desc, SD_LFFILL);
	RETURN 0
	END;
    lffill = .ret_buffer;
    set1[tt$v_lffill]=1
    END;

!
! Combine the resutant fill into one longword.
!

fill = .lffill^8 OR .crfill;

!
! Get the frame count.
!

$get_term_data(smg$k_frame);

! 
! Save the frame count.
!

IF .ret_length EQL 0
THEN
    frame=0
ELSE
    BEGIN
    frame = .ret_buffer;
    IF NOT (.frame EQL 0 OR (.frame GEQ 5 AND .frame LEQ 8))
    THEN
	BEGIN
	LOCAL	desc	: VECTOR[2],
		buf	: VECTOR[64,BYTE];
	desc[0]=64;
	desc[1]=buf;
	$fao(%ASCID '!UL',desc,desc,.frame);
	SIGNAL(set$_invquaval, 2, desc, SD_FRAME);
	RETURN 0
	END;
    parity = tt$m_altframe or parity;
    parity<0,4> = .frame
    END;

!
! Set the terminal characterics bits that correspond to the various
! boolean capabilities.
!

INCR index FROM 0 TO cap_size-1 DO
    BEGIN

    LOCAL

	set_position;

    $get_term_data(.cap_vector[.index]);

    set_position = .set_vector[.index];

    !
    ! If the capability is not defined, then do nothing.
    ! If the capability is defined to be a 1, then set the
    ! bit representing this capability in the appropriate
    ! "set" longword.  (This could be term$l_set1 or term$l_set2.
    ! If the capability is defined to be a 0, then clear the
    ! bit representing this capability in the appropriate "set" longword.
    ! The above action reverses if the val_vector is 0.
    !

    IF .ret_length NEQ 0
    THEN
	BEGIN

	BIND

	    set_longw = info_block[.set_position,0,32,0];

	IF	.ret_buffer EQV .val_vector[.index]
	THEN	set_longw = .set_longw OR .msk_vector[.index]
	ELSE	set_longw = .set_longw AND NOT .msk_vector[.index]

	END;

    END;

!
! Done with this terminal definition.  Get
! rid of the virtual memory used to hold TERMTABLE.EXE.
!

smg$del_term_table();		! don't care about return status

RETURN 1;			
END;				! end of routine get_term_def

ROUTINE log_results (data_buffer) : NOVALUE =
BEGIN

!++
! Functional description
!
!	This routine tells the user whatever was set.
!
! Inputs
!	DATA_BUFFER - full of all sorts of meaningful data
!
! Outputs
!	None.  
!
!----

MAP
    data_buffer : REF VECTOR;

LOCAL
    desc : $BBLOCK[dsc$c_s_bln],
    fao_buffer : VECTOR[8],
    fao_desc : VECTOR[2];

!
! Bind data_buffer to meaningful names.
!
bind_data;

!
! Initialize the descriptors
!
$init_dyndesc(desc);				! Make a dynamic descriptor
fao_desc[1] = fao_buffer;			! Set up the address

!
! See if a specific terminal type was set.
!
IF .index GTR -1
THEN
    BEGIN
    str$append(desc, .term$_name[.index]);
    str$append(desc, SD_COMMA);
    END;

!
! If this is an unknown terminal that is defined in
! TERMTABLE, use the name from the definition.
!
IF .index LSS -1 
THEN
    BEGIN
    str$append (desc, name_desc);
    str$append (desc, SD_COMMA);
    END;

!
! Go thru all 4 of the terminal flagwords, to produce a string showing
! everything that was changed.
!
INCR i FROM 0 TO term$_ttset_num - 1 DO
    BEGIN
    IF (.tt1_set AND .term$_ttset_bit[.i]) NEQ 0
    THEN
	BEGIN
	str$append(desc, .term$_ttset_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 4 TO term$_ttclr_num - 1 DO
    BEGIN
    IF (.tt1_clr AND .term$_ttclr_bit[.i]) NEQ 0
    THEN
	BEGIN
	str$append(desc, .term$_ttclr_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 0 TO term$_tt2set_num - 1 DO
    BEGIN
    IF (.tt2_set AND .term$_tt2set_bit[.i]) NEQ 0
    THEN
	BEGIN
	str$append(desc, .term$_tt2set_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 2 TO term$_tt2clr_num - 1 DO
    BEGIN
    IF (.tt2_clr AND .term$_tt2clr_bit[.i]) NEQ 0
    THEN
	BEGIN
	str$append(desc, .term$_tt2clr_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 0 TO term$_ttset_num - 1 DO
    BEGIN
    IF (.tt1_clr AND .term$_ttset_bit[.i]) NEQ 0
    THEN
	BEGIN
    	str$append(desc, SD_NO);
	str$append(desc, .term$_ttset_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 4 TO term$_ttclr_num - 1 DO
    BEGIN
    IF (.tt1_set AND .term$_ttclr_bit[.i]) NEQ 0
    THEN
	BEGIN
    	str$append(desc, SD_NO);
	str$append(desc, .term$_ttclr_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 0 TO term$_tt2set_num - 1 DO
    BEGIN
    IF (.tt2_clr AND .term$_tt2set_bit[.i]) NEQ 0
    THEN
	BEGIN
    	str$append(desc, SD_NO);
	str$append(desc, .term$_tt2set_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

INCR i FROM 2 TO term$_tt2clr_num - 1 DO
    BEGIN
    IF (.tt2_set AND .term$_tt2clr_bit[.i]) NEQ 0
    THEN
	BEGIN
    	str$append(desc, SD_NO);
	str$append(desc, .term$_tt2clr_key[.i]);
	str$append(desc, SD_COMMA);
	END;
    END;

!
! Check the special parameters, the ones that take a parameter.
!
! Dec_Crt
!
IF ( tt2$m_deccrt AND .deccrt_set) NEQ 0 THEN		!/DEC_CRT
    BEGIN
    str$append( desc, SD_DEC_CRT) ;
    str$append( desc, SD_COMMA ) ;
    END;

IF ( tt2$m_deccrt2 AND .deccrt_set) NEQ 0 THEN		!/DEC_CRT2
    BEGIN
    str$append( desc, SD_DEC_CRT2) ;
    str$append( desc, SD_COMMA ) ;
    END;

IF (tt2$m_deccrt AND .deccrt_clr) NEQ 0 THEN		!/NODEC_CRT
    BEGIN
    str$append( desc, SD_NO ) ;
    str$append( desc, SD_DEC_CRT ) ;
    str$append( desc, SD_COMMA ) ;
    END;

IF (tt2$m_deccrt2 AND .deccrt_clr) NEQ 0 THEN		!/NODEC_CRT2
    BEGIN
    str$append( desc, SD_NO ) ;
    str$append( desc, SD_DEC_CRT2 ) ;
    str$append( desc, SD_COMMA ) ;
    END;
!
! Parity
!
IF .flags[set$v_nopar]
THEN
    BEGIN
    str$append(desc, %ASCID 'NOPARITY');
    str$append(desc, SD_COMMA);
    END
ELSE IF .flags[set$v_odd] OR .flags[set$v_even]
THEN
    BEGIN
    str$append(desc, SD_PARITY);
    str$append(desc, %ASCID '=');
    IF .flags[set$v_odd]
    THEN str$append(desc, term$_odd)
    ELSE str$append(desc, term$_even);
    str$append(desc, SD_COMMA);
    END;

!
! CRfill
!
IF .flags[set$v_cr]
THEN
    BEGIN
    fao_desc[0] = %ALLOCATION(fao_buffer);
    $FAOL(CTRSTR = %ASCID 'CRFILL=!UL,',
    	  OUTBUF = fao_desc,
     	  OUTLEN = fao_desc,
    	  PRMLST = %REF(.fill<0,8>));
    str$append(desc, fao_desc);
    END;
!
! frame size
!
IF .flags[set$v_frame]
THEN
    BEGIN
    fao_desc[0] = %ALLOCATION(fao_buffer);
    $FAOL(CTRSTR = %ASCID 'FRAME=!UL,',
    	  OUTBUF = fao_desc,
     	  OUTLEN = fao_desc,
    	  PRMLST = %REF(.PARITY<0,4>));
    str$append(desc, fao_desc);
    END;
!
! dismiss parity errors
!
IF .flags[set$v_dismis]
THEN
    BEGIN
    str$append(desc, %ASCID 'DISMISS PARITY ERRORS');
    str$append(desc, SD_COMMA);
    END
ELSE IF .flags[set$v_nodism]
  THEN
    BEGIN
    str$append(desc, %ASCID 'NO DISMISS PARITY ERRORS');
    str$append(desc, SD_COMMA);
    END;
!
! LFfill
!
IF .flags[set$v_lf]
THEN
    BEGIN
    fao_desc[0] = %ALLOCATION(fao_buffer);
    $FAOL(CTRSTR = %ASCID 'LFFILL=!UL,',
    	  OUTBUF = fao_desc,
     	  OUTLEN = fao_desc,
    	  PRMLST = %REF(.fill<8,8>));
    str$append(desc, fao_desc);
    END;

!
! Page size
!
IF .flags[set$v_page]
THEN
    BEGIN
    fao_desc[0] = %ALLOCATION(fao_buffer);
    $FAOL(CTRSTR = %ASCID 'PAGE=!UL,',
    	  OUTBUF = fao_desc,
     	  OUTLEN = fao_desc,
    	  PRMLST = %REF(.info_block[term$b_page]));
    str$append(desc, fao_desc);
    END;

!
! Width
!
IF .flags[set$v_width]
THEN
    BEGIN
    fao_desc[0] = %ALLOCATION(fao_buffer);
    $FAOL(CTRSTR = %ASCID 'WIDTH=!UL,',
    	  OUTBUF = fao_desc,
     	  OUTLEN = fao_desc,
    	  PRMLST = %REF(.info_block[term$w_width]));
    str$append(desc, fao_desc);
    END;

!
! Speed
!
IF .flags[set$v_speed]
THEN
    BEGIN
    LOCAL
    	speeds : VECTOR[2];
    fao_desc[0] = %ALLOCATION(fao_buffer);
    speeds[0] = .term$_spdblk[.speed<0,8>];
    IF .speed<8,8> NEQ 0
    THEN speeds[1] = .term$_spdblk[.speed<8,8>]
    ELSE speeds[1] = .speeds[0];
    $FAOL(CTRSTR = %ASCID 'SPEED=(!AS,!AS),',
    	  OUTBUF = fao_desc,
     	  OUTLEN = fao_desc,
    	  PRMLST = speeds);
    str$append(desc, fao_desc);
    END;

!
! Finally, signal an informational message.
!
IF .desc[dsc$w_length] NEQ 0 
THEN
    BEGIN
	desc[dsc$w_length] = .desc[dsc$w_length] - 1;
	SIGNAL(set$_termset, 2, dev_desc, desc);
    END;
RETURN;
END;

END
ELUDOM
