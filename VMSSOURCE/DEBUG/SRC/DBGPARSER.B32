MODULE DBGPARSER (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	February, 1982
!
! MODIFIED BY
!	Rich Title			Added code and tables needed to
!					support BLISS, C, MACRO.
!	Ping Sager			Added code and tables needed to
!					support PASCAL.
!	Walter Carrell III		Update DBG$GL_CURRENT_PRIMARY for 
!					self_referential records
!	Brad Becker			Added tables and support for
!					Built-in functions.
!			
!
! MODULE FUNCTION
!	This module contains the language-independent lexical scanner and
!	parser used to scan and parse both address expressions and language
!	expressions for all languages.  It also contains all the parse tables
!	needed to scan and parse each of the languages supported by DEBUG.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    AAA_DUMMY: NOVALUE,			! Dummy routine--does nothing, not used
    DBG$ADDR_EXP_INT,			! Address Expression Interpreter driver
    DBG$BUILD_PRIMARY_SUBNODE: NOVALUE,	! Build a Primary Descriptor Sub-Node
    DBG$EXP_INT,			! Expression Interpreter driver routine
    DBG$EXPRESSION_PARSER,		! Parser to parse language expressions
    DBG$GET_BIF_ARGUMENTS,		! Parse and pick up built-in function argument list
    DBG$LEXICAL_SCANNER,		! Lexical scanner for all languages
    DBG$PARSER_SET_LANGUAGE: NOVALUE,	! Set language tables for parser
    DBG$PRIMARY_PARSER: NOVALUE,	! Parser to parse a primary symbol
    APPEND_TO_PATHNAME: NOVALUE,	! Append a name to Pathname Descriptor
    CHECK_UPSCOPE,			! Go upscope from record component
    CONSTANT_TO_VALDESCR,		! Build Value Descriptor for a constant
    CREATE_OPERAND_TOKEN,		! Create a Token Entry for an operand
    CREATE_OPERATOR_TOKEN,		! Create a Token Entry for an operator
    CREATE_PRID_CONSTANT,		! Create a Predefined Identifier Constatn
					!	value descriptor
    DUMP_OPERATOR: NOVALUE,		! Dump an operator being evaluated
    DUMP_TOKEN: NOVALUE,		! Dump a Token Entry symbolically
    DUMP_PRIMARY: NOVALUE,		! Dump a Primary or Value Descriptor
    FIX_UP_PRIMARY: NOVALUE,		! Fix up a Primary with subscripts
    GET_BLISS_SUBSCRIPTS: NOVALUE,	! Pick up BLISS subscripts
    GET_DEREFERENCE: NOVALUE,		! Do a derefence (PASCAL ^ operator)
    GET_FIELDREF: NOVALUE,		! Pick up field reference X<p,s,e>
    GET_RECORD_COMPONENT: NOVALUE,	! Do record component selection
    GET_RECORD_VARIANT,			! Search a set of record variants for
					!      a specified record component
    GET_SET_CONSTANT,			! Parse and pick of set constants
    GET_SUBSCRIPTS: NOVALUE,		! Parse and pick of array subscripts
    GET_SUBSTRING: NOVALUE,		! Parse and pick up substring reference
    OPERATOR_TO_RESTORE_RADIX,		! Returns operator to restore radix
    PATHNAME_TO_PRIMARY,		! Construct Primary Descr from pathname
    RESOLVE_COMPONENT,			! Attempt to resolve possibly 
    					!    ambiguous record references.
    SAVE_SUBSCRIPTS: NOVALUE,		! Save away subscripts
    SCAN_QUOTED_STRING: NOVALUE;	! Scan a quoted character string

EXTERNAL ROUTINE
    DBG$DATA_LENGTH,			! Length in bits of data in VMS descriptor
    DBG$DEF_SYM_FIND,			! Look up DEFINEd symbol
    DBG$DUMP_HEX: NOVALUE,		! Dump a memory block in hexadecimal
    DBG$ENUM_POS,			! Convert enum val-> enum position
    DBG$ENUM_VAL,			! Convert enum pos-> enum val
    DBG$EVALOP_SET_LANGUAGE: NOVALUE,	! Sets up Operator Information Tables
    DBG$EVAL_ADA_TICK,			! Evaluate an Ada Tick operator
    DBG$EVAL_ADDR_OPERATOR,		! Evaluate an Address Expr. operator
    DBG$EVAL_LANG_OPERATOR,		! Evaluate a language expr. operator
    DBG$GET_TEMPMEM,			! Get a temporary memory block
    DBG$HASH_FIND,			! Look up symbol in RST Hash Table
    DBG$HASH_FIND_SETUP: NOVALUE,	! Set up call on DBG$HASH_FIND
    DBG$PERFORM_TYPEID_CHECK,		! Check type consistency in set constant
    DBG$MAKE_SKELETON_DESC,		! Make skeleton Value or Primary Descr.
    DBG$MAP_DTYPE_CLASS,		! Given DTYPE, do a best guess at the CLASS
    DBG$NCOB_PATHDESC_TO_CS: NOVALUE,	! Pathname to COBOL string
    DBG$NCOPY_DESC,			! Copy a descriptor
    DBG$NEWLINE: NOVALUE,		! Close print line and start new line
    DBG$NPATHDESC_TO_CS: NOVALUE,	! Convert Pathname Descr to ASCII
    DBG$NUM_BYTES,			! Return the length of a given dtype
    DBG$PRIM_TO_ADDR,			! Convert Primary to address
    DBG$PRIM_TO_VAL,			! Convert Primary to Value Descriptor
    DBG$PRINT: NOVALUE,			! Print FAO-formatted text
    DBG$PRINT_SET_LANGUAGE: NOVALUE,	! Sets up Print Information Tables
    DBG$STA_GETSYMBOL: NOVALUE,		! Look up a symbol in the RST
    DBG$STA_SETCONTEXT: NOVALUE,	! Set up current context
    DBG$STA_SYMSIZE: NOVALUE,		! Look up a symbol's size
    DBG$STA_SYMTYPE: NOVALUE,		! Look up a symbol's data type in RST
    DBG$STA_SYMVALUE: NOVALUE,		! Look up a symbol's value
    DBG$STA_TYPEFCODE,			! Get FCODE of a given Type ID
    DBG$STA_TYP_ARRAY: NOVALUE,		! Look up array data type information
    DBG$STA_TYP_ATOMIC: NOVALUE,	! Look up atomic data type information
    DBG$STA_TYP_DESCR: NOVALUE,		! Look up descriptor type information
    DBG$STA_TYP_FILE: NOVALUE,		! Get type info for file variable
    DBG$STA_TYP_RECORD: NOVALUE,	! Look up record data type information
    DBG$STA_TYP_SUBRNG: NOVALUE,	! Look up subrange data type information
    DBG$STA_TYP_TYPEDPTR: NOVALUE,	! Look up typed pointer information
    DBG$STA_TYP_VARIANT: NOVALUE,	! Look up record variant set information
    DBG$STA_TYP_VARIANT_COMP: NOVALUE,	! Look up components of a record variant
    DBG$TYPEID_FOR_ARRAY,		! Construct a typeid for an array
    DBG$TYPEID_FOR_ATOMIC,		! Construct a typeid for an atomic object
    DBG$TYPEID_FOR_SET,			! Construct a Set Constant typeid
    OTS$CVT_TI_L;			! Convert ASCII string to integer

EXTERNAL
    DBG$GL_ARRSUB_FLAG,
    DBG$GL_DEVELOPER: BITVECTOR[],	! Developer mode control bits
    DBG$GL_CURRENT_PRIMARY,		! Pointer to the primary being processed
    DBG$GB_LANGUAGE: BYTE,		! Currently set language
    DBG$GB_MOD_PTR: REF VECTOR [,BYTE], ! Pointer to modes
    DBG$GL_ORIG_COMMAND_PTR,		! Pointer to original command string
    DBG$GL_RECCMP_FLAG,
    DBG$GB_SET_BREAK_FLAG: BYTE,	! Set to TRUE during parsing of 
    					!    SET BREAK command.
    DBG$GL_UPCASE_COMMAND_PTR: VECTOR[2];
    					! Pointers to start and end
    					!    of current command string

GLOBAL
    DBG$GL_CHARTBL: REF CHRTBL$TABLE;	! Pointer to character table for the
					!      currently set language

LITERAL
    CAR_RET = %CHAR(13),		! Carriage-return character
    VARSTK_SIZE = 20;			! Maximum nesting depth of record
					!      variants we allow

! These are passed into APPEND_TO_PATHNAME as the third parameter. This
! parameter tells the routine how to insert the name into the pathname
! being constructed.
!
LITERAL
    NOT_REC_COMP	= 0,
    REC_COMP		= 1,
    COB_REC_COMP	= 2;

OWN
    ADDRESS_LENGTH,			! Length of instruction pointed to by
					!      address expression (or zero)
    ADDRESS_TYPE,			! Address expression "type"--either
					!      "instruction" or "no type"
    BIF_TABLE: REF VECTOR[,LONG],	! Pointer to a Built-in Function table
					!      for the current language where
					!      the functions are identifiers.
					!      (SUCC, PRED)
    CASING_SIGNIFICANT,			! Set to TRUE if upper/lower casing
    					!      is significant in names.
    CHARPTR: REF VECTOR[,BYTE],		! Pointer to current character in input
					!      line being scanned and parsed
    CHARTBL: CHRTBL$TABLE,		! Character Table for current language
    COMPONENTS_IN_PATHNAME,		! Set to TRUE if the current language
    					!      picks up all record components
    					!      before calling GETSYMBOL.
    ENFORCE_RECORD,			! Set to TRUE if the current language
    					!      requires that COMP be a 
    					!      component of REC in the 
    					!      expression REC.COMP
    EXPRESSION_RADIX,			! Radix value to be used to interpret
					!      constants in expressions
    IDENT_OPERATOR_TABLE:		! Pointer to an Operator Table for the
		REF VECTOR[,LONG],	!      current language where the sym-
					!      bols are identifiers (NOT, AND)
    INCOMPLETE_QUAL,			! Set to TRUE if incomplete data 
    					!      qualification is allowed in
    					!      then current language.
    					!      (e.g., A.C in place of A.B.C)
    MULTIPLE_SUBSCR,			! Set to TRUE if multiple subscripts
					!      parens (X[1,2][3]) are allowed
    OPCHAR_OPERATOR_TABLE:		! Pointer to an Operator Table for the
		REF VECTOR[,LONG],	!      current language where the sym-
					!      bols are special characters (+,**)
    PRIMARY_TABLE: REF PRIMARY$TABLE,	! Pointer to the Primary Parser State
					!      Table for the current language
    SAVED_TOKEN: INITIAL(0),		! Token pointer saved by Primary Parser
					!      until next call by Expr. Parser
    STATE_TABLE: REF NUMST$TABLE,	! Pointer to the Number Scanner State
					!      Table for the current language
    SUBSCRIPT_TERM_TBL:			! Pointer to Terminator Table to use
		REF VECTOR[,LONG],	!      when picking up subscripts
    PRIDTBL: REF VECTOR[,LONG],		! Pointer to Predefined Identifier Table
    TERMINATOR_CODE:			! Terminator code for last terminator
	INITIAL(TOKEN$K_TERM_NONE),	!      token found by lexical scanner
    TERMINATOR_LENGTH: INITIAL(0),	! Length in characters of last termina-
					!      tor found by the lexical scanner
    VARSTACK1: VECTOR[VARSTK_SIZE],	! Stack of Variant Set RST Entry pointers
    VARSTACK2: VECTOR[VARSTK_SIZE],	! Stack of RST Variant Entry pointers
    VARSTACK3: VECTOR[VARSTK_SIZE],	! Stack of variant component indicies
    VARSTK_INDEX;			! Current index for VARSTACKn stacks

!	M A C R O S   T O   G E N E R A T E   P A R S E   T A B L E S
!
!
!
!	These macros are used to generate the parse tables used by the Lexical
!	Scanner and the Parser to parse both language-independent and language-
!	specific constructs accepted by DEBUG.
!
!
!
! CHARACTER TABLE
!
!
! Define the macros which generate the Character table.  This includes the
! macros which generate the base Character Table for language UNKNOWN and
! the macros which generate the Character Exception Tables for the individual
! languages.  The Character Exception Table for a language lists those char-
! acters which have different characteristics in that language that the de-
! fault characteristics specified for language UNKNOWN.  The Character Table
! for a language is thus formed by copying the default table for language
! UNKNOWN and then overlaying the entries for those characters listed in the
! language's Character Exception Table.
!
! These macros are used as follows.  To generate the default Character Table,
! the following sequence of macro invocations is used:
!
!	CHAR_TABLE(TBLNAME,
!		CHAR_ENT(CHAR, CLASS, BIT1, BIT2, ...)
!		...
!		CHAR_ENT(CHAR, CLASS, BIT1, BIT2, ...));
!
! Here TBLNAME is the name of the table to be built.  The CHAR_TABLE macro
! defines the whole Character Table as a BLOCKVECTOR and causes each element
! in the vector to be filled with zeroes unless this is overridden by an
! explicit CHAR_ENT invocation for that specific character.
!
! The CHAR_ENT macro sets the character characteristics for a specified
! character.  Here CHAR is the character itself (e.g., 'A'), CLASS is the
! Number Scanner Character Class, and BIT1, BIT2, ... are the names of the
! other characteristics bits to be set for this character.  The CLASS param-
! eter is automatically prefixed by "NUMST$K_CLASS_" by the macro.  Also,
! the BITn parameters are automatically prefixed by "CHRTBL$M_" to generate
! the proper mask value names.
!
! To generate a Character Exception Table for a language, the following
! macro invocations are used:
!
!	CHAR_EXCEPTION_TABLE(TBLNAME,
!		CHAR_ENTRY(CHAR, CLASS, BIT1, BIT2, ...)
!		...
!		CHAR_ENTRY(CHAR, CLASS, BIT1, BIT2, ...));
!
! Here CHAR, CLASS, and BIT1, BIT2, ... have the same meanings as for the
! CHAR_ENT macro above.  Similarly, TBLNAME is the name given to the new
! Character Exception Table.  The only difference between these macros and
! those described above is that a different data structure is generated.
!
MACRO
    CHAR_TABLE(TBLNAME) =
	OWN TBLNAME: VECTOR[256,LONG] PSECT(DBG$PLIT) PRESET(%REMAINING) %;

MACRO
    CHAR_ENT(CHAR, CLASS) =
	[CHAR]=((%NAME('NUMST$K_CLASS_',CLASS)^4) OR CHAR_FLAGS(%REMAINING)) %;

MACRO
    CHAR_FLAGS[FLAG] =
	%NAME('CHRTBL$M_',FLAG) %;

MACRO
    CHAR_EXCEPTION_TABLE(TBLNAME) =
	%IF %LENGTH EQL 1
	%THEN
	    BIND TBLNAME = PLIT(REP 0 OF (0)): VECTOR[,LONG]
	%ELSE
	    BIND TBLNAME = PLIT(%REMAINING): VECTOR[,LONG]
	%FI %;

MACRO
    CHAR_ENTRY(CHAR, CLASS) =
	CHAR^24 OR %NAME('NUMST$K_CLASS_',CLASS)^4 OR CHAR_FLAGS(%REMAINING) %;


! Define fields of Character Exception Table entry.  These definitions are only
! used in the DBG$PARSER_SET_LANGUAGE routine below.
!
FIELD CE_FLDS =
	SET
	CE_BITS = [ 0, V_(0,24) ],	! Character characteristics bits
	CE_CHAR = [ 0, B3_ ]		! The character itself
	TES;

MACRO
    CE_ENTRY = BLOCK[1,WORD] FIELD(CE_FLDS) %;



! OPERATOR TABLE
!
!
! Define the macros which generate an Operator Table for a language.  An Opera-
! tor Table is a counted vector (a PLIT) of longwords which point to Operator
! Lexical Token Entries for the operators of the language.  Each pointer is
! relative to the address TABLEBASE so that the code is completely Position-
! Independent (PIC); the true pointer value is thus the longword value plus
! TABLEBASE.
!
! An Operator Table is generated with the following macro invocations:
!
!    OPERATOR_TABLE(TBLNAME,
!	OPERATOR_ENTRY(OPNAME,CODE,KIND,LEFT_PREC,RIGHT_PREC,FLAG1,...),
!		...
!	OPERATOR_ENTRY(OPNAME,CODE,KIND,LEFT_PREC,RIGHT_PREC,FLAG1,...));
!
! Here TBLNAME is the name of the Operator Table generated.  OPNAME is the
! quoted character string which constitutes the operator (e.g., '+', ':=',
! 'AND', '.EQ.'), CODE is the name of the operation to be performed (e.g,
! SUBSCRIPT, ADD, OPENPAREN--this is automatically prefixed by "TOKEN$K_"
! by the macro), KIND is the operator kind (PREFIX, INFIX, or POSTFIX),
! LEFT_PREC is its left precedence, and RIGHT_PREC is its right precedence.
! FLAG1, ... is zero or more optional parameters which specify flag bits
! to be set in the Token Entry.  Each FLAGn name is automatically prefixed
! by "TOKEN$M_" by the macro to generate the appropriate mask value.  The
! only flag at present is PRIMARY which means that the operator is an
! operator within a Primary Symbol.
!
! The OPERATOR_ENTRY macro can also be used independently to generate an
! Operator Lexical Token Entry.  It returns the address of the Operator
! Lexical Token Entry it created.
!
MACRO
    OPERATOR_TABLE(TBLNAME) =
	%IF %LENGTH EQL 1
	%THEN
	    BIND TBLNAME = PLIT(REP 0 OF (0)): VECTOR[,LONG]
	%ELSE
	    BIND TBLNAME = PLIT(OP_ENT(%REMAINING)): VECTOR[,LONG]
	%FI %;

MACRO
    OP_ENT[ADDRESS] =
	(ADDRESS) - TABLEBASE %;

MACRO
    OPERATOR_ENTRY(OPNAME,CODE,KIND,LEFT_PREC,RIGHT_PREC) =
	UPLIT BYTE(%NAME('TOKEN$K_',KIND,'_OP'),
		%IF %LENGTH LEQ 5
		%THEN
		    0
		%ELSE
		    0 OR OP_FLAGS(%REMAINING)
		%FI,
		WORD (%NAME('TOKEN$K_',CODE)),
		RIGHT_PREC, LEFT_PREC, 0, 0, 0, 0, 0 , 0,
		%ASCIC OPNAME) %;

MACRO
    OP_FLAGS[FLAGNAME] =
	%NAME('TOKEN$M_',FLAGNAME) %;



! BUILT-IN-FUNCTION TABLE
!
!
! Define the macros which generate an Built-in Function Table for a language.
! A Built-in Function Table is a counted vector (a PLIT) of longwords which
! point to Operand Lexical Token Entries for the Built-in Functions of the
! language.  Each pointer is relative to the address TABLEBASE so that the
! code is completely Position-Independent (PIC); the true pointer value is
! thus the longword value plus TABLEBASE.
!
! An Built-in Function Table is generated with the following macro invocations:
!
!    BUILT_IN_FUNCTION_TABLE(TBLNAME,
!	BUILT_IN_FUNCTION_ENTRY(OPNAME,CODE),
!		...
!	BUILT_IN_FUNCTION_ENTRY(OPNAME,CODE);
!
! Here TBLNAME is the name of the Built-in Function Table generated.  OPNAME
! is the quoted character string which constitutes the Built-in Function call
! (e.g., 'succ', 'pred'), CODE is the name of the Built-in Function to be
! performed (e.g, SUCC, PRED--this is automatically prefixed by "TOKEN$K_"
! by the macro), and ARGUMENTS is the number of arguments for the Built-in
! function.
!
! The BUILT_IN_FUNCTION_ENTRY macro can also be used independently to
! generate an Built-in Function Lexical Token Entry.  It returns the
! address of the Built-in Function Lexical Token Entry it created.
!
MACRO
    BUILT_IN_FUNCTION_TABLE(TBLNAME) =
	%IF %LENGTH EQL 1
	%THEN
	    BIND TBLNAME = PLIT(REP 0 OF (0)): VECTOR[,LONG]
	%ELSE
	    BIND TBLNAME = PLIT(BIF_ENT(%REMAINING)): VECTOR[,LONG]
	%FI %;

MACRO
    BIF_ENT[ADDRESS] =
	(ADDRESS) - TABLEBASE %;

MACRO
    BUILT_IN_FUNCTION_ENTRY(OPNAME,CODE,ARGUMENTS) =
	UPLIT BYTE(TOKEN$K_OPERAND, ARGUMENTS,
		WORD(TOKEN$K_BUILTIN_FUNCTION),
		BYTE(%NAME('TOKEN$K_',CODE)), 0,
		0, 0,
		%ASCIC OPNAME) %;


! Define two tokens that are used in other modules.
!
GLOBAL BIND
    DBG$GL_CONVERT_TOKEN =
	OPERATOR_ENTRY ('CONVERT', CONVERT, INFIX, 0, 0),
    DBG$GL_DEPOSIT_TOKEN =
	OPERATOR_ENTRY ('DEPOSIT', DEPOSIT, INFIX, 0, 0),
    DBG$GL_IDENTITY_TOKEN =
	OPERATOR_ENTRY ('IDENTITY', IDENTITY, PREFIX, 0, 0),
    DBG$GL_NEG_CONST_TOKEN =
    	OPERATOR_ENTRY ('NEGCONST', NEGCONST, PREFIX, 0, 0),
    DBG$GL_POS_CONST_TOKEN =
    	OPERATOR_ENTRY ('POSCONST', POSCONST, PREFIX, 0, 0),
    DBG$GL_NEG_SIGN_TOKEN =
    	OPERATOR_ENTRY ('-', UNARY_MINUS, PREFIX, 0, 0),
    DBG$GL_POS_SIGN_TOKEN =
    	OPERATOR_ENTRY ('+', UNARY_PLUS, PREFIX, 0, 0);


! OPERAND LEXICAL TOKEN ENTRIES
!
!
! Define macro which builds an Operand Lexical Token Entry and returns the
! address of the entry.  The macro is used like this:
!
!		OPERAND_ENTRY(TOKENCODE, NAMESTRING)
!
! Here TOKENCODE is the code value for the type of operand this token
! constitutes.  TOKEN$K_IDENTIFIER or TOKEN$K_INTEGER are valid examples.
! NAMESTRING is the ASCII name to be associated with the operand token.
!
MACRO
    OPERAND_ENTRY(CODE, NAMESTRING) =
	UPLIT BYTE(TOKEN$K_OPERAND, 0, WORD (CODE),
			0, 0, 0, 0,
			%ASCIC NAMESTRING): TOKEN$ENTRY %;



! PREDEFINED IDENTIFIER TABLE
!
!
! Define the macros which generate a Predefined Identifier Table for a language.
! A Predefined Identifier Table is a counted vector (a PLIT) of longwords which 
! point to Predefined Identifier Entries for the reserved names of the language.
! Each pointer is relative to the address TABLEBASE so that the code is completely 
! Position Independent (PIC); the true pointer value is thus the longword value 
! plus TABLEBASE.
!
! A Predefined Identifier Table is generated with the following macro invocations:
!
!    PRID_TABLE(TBLNAME,
!	PRID_ENTRY(PRIDNAME, FCODE, DTYPE, VALUE),
!		...
!	PRID_ENTRY(PRIDNAME, FCODE, DTYPE, VALUE));
!
! Here TBLNAME is the name of the Predefined ID Table generated.  PRIDNAME is 
! the quoted character string which constitutes the reserved name (e.g., 
! 'TRUE', 'FALSE', '.TRUE.', '.FALSE.'), DTYPE is the Data type (e.g., Boolean, 
! Integer).  DTYPE is automatically prefixed by 'DSC$K_DTYPE_', and VALUE is a 
! longword constant value for the PRID constant, FCODE is the Format Code.
!
! The PRID_ENTRY macro can also be used independently to generate an entry.
! It returns the address of the PRID Entry it created.
!
MACRO
    PRID_TABLE(TBLNAME) =
	%IF %LENGTH EQL 1
	%THEN
	    BIND TBLNAME = PLIT(REP 0 OF (0)): VECTOR[,LONG]
	%ELSE
	    BIND TBLNAME = PLIT(PRID_ENT(%REMAINING)): VECTOR[,LONG]
	%FI %;

MACRO
    PRID_ENT[ADDRESS] =
	(ADDRESS) - TABLEBASE %;

MACRO
    PRID_ENTRY(NAMESTRING, FCODE, DTYPE, VALUE) =
	UPLIT BYTE(PRID$K_CONSTANT, 
		   %NAME('DSC$K_DTYPE_', DTYPE),
		   %NAME('RST$K_TYPE_', FCODE),
    		   0,
		   LONG (VALUE),
		   %ASCIC NAMESTRING)%;



! TERMINATOR LEXICAL TOKEN ENTRIES
!
!
! Define the macros which generate Terminator Lexical Token Entries.  These
! entries define lexical tokens which can terminate the current expression.
! For example, subscript expressions can normally be terminated by the tokens
! "," and ")".  These are thus the Terminator Tokens for subscript expressions.
! Similarly, "DO" is a terminator token for the address expression in the
! SET BREAK command and "=" is a terminator token for the address expression
! in the DEPOSIT command.  Terminator Lexical Token Entries thus define the
! tokens which can validly terminate the current expression in the current
! context.  Terminator Lexical Token Entries have exactly the same format as
! Operand Lexical Token Entries are are referenced with the same field names.
!
! A table of Terminator Lexical Token Entries is declared as follows:
!
!	TERMINATOR_TABLE(TBLNAME,
!		TERMINATOR_ENTRY(NAMESTRING, CODE, FLAG1, ...),
!			...
!		TERMINATOR_ENTRY(NAMESTRING, CODE, FLAG1, ...));
!
! Here TBLNAME is the name of the terminator table.  NAMESTRING is the ASCII
! string which constitutes the terminator token, CODE is the name of a termi-
! nator token code which identifies what kind of terminator this is (this name
! is automatically prefixed by "TOKEN$K_" by the macro), and FLAG1, ... is
! zero or more flag names indicating flag bits to be set in the Terminator
! Token Entry.  The flags names are automatically prefixed by "TOKEN$M_" to
! generate the appropriate mask value name.
!
MACRO
    TERMINATOR_TABLE(TBLNAME) =
	%IF %LENGTH EQL 1
	%THEN
	    BIND TBLNAME = PLIT(REP 0 OF (0)): VECTOR[,LONG]
	%ELSE
	    BIND TBLNAME = PLIT(OP_ENT(%REMAINING)): VECTOR[,LONG]
	%FI %;

MACRO
    TERMINATOR_ENTRY(NAMESTRING, CODE) =
	UPLIT BYTE(0,
		%IF %LENGTH LEQ 2
		%THEN
		    0
		%ELSE
		    0 OR OP_FLAGS(%REMAINING)
		%FI,
		WORD (%NAME('TOKEN$K_',CODE)),
		0, 0, 0, 0,
		%ASCIC NAMESTRING) %;



! NUMBER SCANNER STATE TABLE
!
!
! Define the macros which generate Number Scanner State Tables.  These tables
! are used in the lexical scanning of numeric constants and are in general
! specific to each language.
!
! A Number Scanner State Table for a language is generated with the following
! macro invocations:
!
!	NUMBER_STATE_TABLE(TBLNAME,
!
!		NUMBER_STATE(STATE_ID,
!			NUMBER_TRANSITION(CHAR_CLASS, ACTION, NEXTSTATE),
!			...
!			NUMBER_TRANSITION(CHAR_CLASS, ACTION, NEXTSTATE),
!			NUMBER_TRANSITION(OTHER, ACTION, NEXTSTATE)),
!
!		...
!
!		NUMBER_STATE(STATE_ID,
!			NUMBER_TRANSITION(CHAR_CLASS, ACTION, NEXTSTATE),
!			...
!			NUMBER_TRANSITION(CHAR_CLASS, ACTION, NEXTSTATE),
!			NUMBER_TRANSITION(OTHER, ACTION, NEXTSTATE)));
!
! The NUMBER_STATE_TABLE macro sets up the Number Scanner State Table as a
! whole and binds the table name TBLNAME to that structure.  Each state in the
! table is declared with the NUMBER_STATE macro whose STATE_ID argument names
! the state.  The actual state name is prefixed by "NUMST$XX_STATE_" by the
! macro and must be declared as such in the COMPILETIME declaration below.
!
! The NUMBER_TRANSITION macro defines one transition from the current state to
! some other state.  The transition is taken if the next input character is of
! the character class specified by CHAR_CLASS.  (CHAR_CLASS is automatically
! prefixed by "NUMST$K_CLASS_" to generate the class code constant.)  If the
! transition is taken, the action specified by ACTION is taken.  ACTION, which
! is automatically prefixed by "NUMST$K_ACT_" by the macro, is a CASE index
! used by the Number Scanner to select an action routine which performs what-
! ever semantic processing is appropriate.  After the action routine executes,
! the next state in the state table is given by NEXTSTATE.  NEXTSTATE is auto-
! matically prefixed by "NUMST$K_STATE_" by the macro and must be declared as
! the STATE_ID on some other NUMBER_STATE declaration in the state table.
!
! Every state in the state table must have at least two transitions and the
! last transition must always be for class NUMST$K_CLASS_OTHER, written as
! OTHER in the NUMBER_TRANSITION invocation.  (There is no point to having
! a state with only a single transition since that state could then be merged
! with the transition's next state.)
!
MACRO
    NUMBER_STATE_TABLE(TBLNAME) =
	BIND TBLNAME = UPLIT(%REMAINING): NUMST$TABLE
	%ASSIGN(NUMST$XX_CUR_LOC, 0) %;

MACRO
    NUMBER_STATE(STATE_ID) =
	%ASSIGN(%NAME('NUMST$XX_STATE_', STATE_ID), NUMST$XX_CUR_LOC)
	%ASSIGN(NUMST$XX_CUR_LOC, NUMST$XX_CUR_LOC + (%LENGTH - 1)/3)
	%REMAINING %;

MACRO
    NUMBER_TRANSITION(CHAR_CLASS, ACTION, NEXTSTATE) =
	BYTE (%NAME('NUMST$K_CLASS_', CHAR_CLASS)),
	BYTE (%NAME('NUMST$K_ACT_', ACTION)),
	WORD (%NAME('NUMST$XX_STATE_', NEXTSTATE)) %;

COMPILETIME
    NUMST$XX_CUR_LOC = 0,		! Current index into state table vector
					!      during macro expansion
    NUMST$XX_STATE_START_STATE = 0,	! Index values in state table vector
    NUMST$XX_STATE_LEADING_DOT = 0,	!      for state table entries
    NUMST$XX_STATE_ACCUM_INT = 0,
    NUMST$XX_STATE_T_ACCUM_INT = 0,
    NUMST$XX_STATE_ACCUM_HEX = 0,
    NUMST$XX_STATE_ACCUM_FRAC = 0,
    NUMST$XX_STATE_T_ACCUM_FRAC = 0,
    NUMST$XX_STATE_GET_EXPONENT = 0,
    NUMST$XX_STATE_GET_EXP_SIGN = 0,
    NUMST$XX_STATE_ACCUM_EXP = 0,
    NUMST$XX_STATE_T_ACCUM_EXP = 0,
    NUMST$XX_STATE_B_START_STATE = 0,
    NUMST$XX_STATE_B_ACCUM_INT = 0,
    NUMST$XX_STATE_T_B_ACCUM_INT = 0,
    NUMST$XX_STATE_B_ACCUM_FRAC = 0,
    NUMST$XX_STATE_T_B_ACCUM_FRAC = 0,
    NUMST$XX_STATE_END_STATE = 0;


! PRIMARY PARSER STATE TABLE
!
!
! Define the macros which generate Primary Parser State Tables.  These tables
! are used in the parsing of Primary Symbols (symbol names including pathname
! qualification, data qualification, subscripting, dereferencing, etc.) and
! are specific to each language.
!
! A Primary Parser State Table for a language is generated with the following
! macro invocations:
!
!	PRIMARY_STATE_TABLE(TBLNAME,
!
!	    PRIMARY_STATE(STATE_ID,
!		PRIMARY_TRANSITION(OPCODE, ACTION, NEXTSTATE),
!		...
!		PRIMARY_TRANSITION(OPCODE, ACTION, NEXTSTATE)),
!
!	    ...
!
!	    PRIMARY_STATE(STATE_ID,
!		PRIMARY_TRANSITION(OPCODE, ACTION, NEXTSTATE),
!		...
!		PRIMARY_TRANSITION(OPCODE, ACTION, NEXTSTATE)));
!
! The PRIMARY_STATE_TABLE macro sets up the Primary Parser State Table as a
! whole and binds the table name TBLNAME to that data structure.  Each state in
! the table is declared with the PRIMARY_STATE macro whose STATE_ID argument
! names the state.  The actual state name is prefixed by "PRIMARY$XX_STATE_"
! by the macro and must be declared in the COMPILETIME declaration below.
!
! The PRIMARY_TRANSITION macro defines one transition from the current state
! to some other state.  The transition is taken if the current Primary Operator
! returned by the Lexical Scanner has the Operator Code (TOKEN$W_CODE) speci-
! fied as OPCODE.  (OPCODE is automatically prefixed by "TOKEN$K_" to generate
! the constant name.)  If the transition is taken, the action routine specified
! by ACTION is taken.  ACTION, which the macro prefixes with "PRIMARY$K_ACT_",
! is a CASE index used by the Primary Parser to select an action routine to do
! whatever semantic processing is appropriate to build the Primary Descriptor
! for the Primary Symbol being parsed.  After the action routine executes, the
! next state in the state table is given by NEXTSTATE.  NEXTSTATE is automati-
! cally prefixed by "PRIMARY$XX_STATE_" by the macro and must be declared as
! the STATE_ID on some other PRIMARY_STATE declaration in the state table.
!
! If a Primary Operator is encountered during the scan for which there is no
! transition in the current Primary Parser State Table state, the Primary
! Parser signals an error.  This is how many ill-formed Primary Symbols are
! detected.  Every state thus has an implicit transition for every unspecified
! Operator Code (the "other" transition) for which the action is to signal a
! syntax error.
!
MACRO
    PRIMARY_STATE_TABLE(TBLNAME) =
	BIND TBLNAME = UPLIT(%REMAINING): PRIMARY$TABLE
	%ASSIGN(PRIMARY$XX_CUR_LOC, 0) %;

MACRO
    PRIMARY_STATE(STATE_ID) =
	%ASSIGN(%NAME('PRIMARY$XX_STATE_', STATE_ID), PRIMARY$XX_CUR_LOC)
	%ASSIGN(PRIMARY$XX_CUR_LOC, PRIMARY$XX_CUR_LOC + (%LENGTH - 1)/3 + 1)
	%IF %LENGTH GTR 1 %THEN %REMAINING, %FI LONG (0) %;

MACRO
    PRIMARY_TRANSITION(OPCODE, ACTION, NEXTSTATE) =
	BYTE (%NAME('TOKEN$K_', OPCODE)),
	BYTE (%NAME('PRIMARY$K_ACT_', ACTION)),
	WORD (%NAME('PRIMARY$XX_STATE_', NEXTSTATE)) %;

COMPILETIME
    PRIMARY$XX_CUR_LOC = 0,		! Current index into primary parser state
					!      table during macro expansion
    PRIMARY$XX_STATE_START_STATE = 0,	! Index values in primary parser state
    PRIMARY$XX_STATE_GET_GLOBAL = 0,	!      table vector for the states
    PRIMARY$XX_STATE_GOT_BACKSLASH = 0,
    PRIMARY$XX_STATE_GOT_DOT = 0,
    PRIMARY$XX_STATE_GOT_SUBSCRIPT = 0,
    PRIMARY$XX_STATE_GOT_SUBSCRIPT2 = 0,
    PRIMARY$XX_STATE_GOT_BRACKET = 0,
    PRIMARY$XX_STATE_GOT_DEREF = 0,
    PRIMARY$XX_STATE_GOT_DOT_SLASH = 0,
    PRIMARY$XX_STATE_END_STATE = 0;


! The following data structure is used in the SAVE_SUBSCRIPTS routine
! and the PATHNAME_TO_PRIMARY routine.
!
FIELD 
    SUBSCR_DESC_FIELDS =
        SET
    	SUBSCR$B_PATH_INDEX = [0,0,8,0],	! Says which pathname element
    						!    the subscripts were
    						!    associated with
    	SUBSCR$B_SUBCNT = [0,8,8,0],		! Count of subscripts so far
    	SUBSCR$V_RANGE = [0,16,1,0],		! True if range was specified
    	SUBSCR$V_ASTER = [0,17,1,0],		! True for "*" range
    	SUBSCR$V_MARKER = [0,18,1,0],		! Marker bit (see SAVE_SUBSCRIPTS)
    	SUBSCR$L_LBOUND = [1,0,32,0],		! Lower bound of range
    	SUBSCR$L_UBOUND = [2,0,32,0]		! Upper bound of range
    	TES;
MACRO
    SUBSCR$DESC = BLOCKVECTOR[DBG$K_PATHNAME_SIZE,3,LONG] 
    		          FIELD(SUBSCR_DESC_FIELDS)%;
LITERAL
    SUBSCR_DESC_SIZE = 3*DBG$K_PATHNAME_SIZE*%UPVAL;


! PARSER FLAGS
!
!
! Define parser flags which may have different settings for different languages.
! These flags are stored in the Table of Language-Specific Tables and are copied
! to individual OWN variables when the current language is set.  These flags
! control the behavior of the parser in those cases where different languages
! have different behaviors and the easiest way of encoding these differences
! is to have a flags to control the parser.  The following flags are available:
!
!	MULTIPLE_SUBSCR	- The language allows multiple subscript parentheses
!			  in array references.  For example, PASCAL allows
!			  X[1,2,3,4] to be written as X[1,2][3][4].  This
!			  flag should not be set if the second form is not
!			  equivalent to the first form of array reference.
!
! Each of these flags is set to TRUE or FALSE in an OWN variable with the same
! name as the flag name give here.



! TABLE OF LANGUAGE-SPECIFIC TABLES
!
!
! Define the macro which builds the table of pointers to the language-specific
! parse tables.  This table is simply a vector of pointers to the Character
! Exception Table, the Identifier Operator table, the Operator Character Opera-
! tor Table, and the Number Scanner State Table for the specified language.
! Each pointer is relative to TABLEBASE to keep the table position-independent
! (PIC).  The macro is used as follows:
!
!	LANGUAGE_TABLES(LANGUAGE = language-name,
!			CHARTBL = character-exception-table,
!			IDENT_OPTBL = identifier-operator-table,
!			OPCHAR_OPTBL = operator-character-operator-table,
!			NUMBER_TABLE = number-scanner-state-table,
!			PRIMARY_TABLE = primary-parser-state-table,
!			SUBSCR_TERMS = subscript-terminator-table,
!			PRIDTBL = Predefined-identifier-table,
!			BIF_TABLE = built-in-function-table,
!			MULTIPLE_SUBSCR = true-or-false,
!			ENFORCE_RECORD = true-or-false,
!			CASING_SIGNIFICANT = true-or-false,
!			COMPONENTS_IN_PATHNAME = true-or-false,
!			INCOMPLETE_QUAL = true-or-false);
!
! Notice that keyword parameters are used.  The meanings of the parameters
! should be self-explanatory.
!
KEYWORDMACRO
    LANGUAGE_TABLES(LANGUAGE=DBG$K_UNKNOWN, CHARTBL=0, IDENT_OPTBL=0,
			OPCHAR_OPTBL=0, NUMBER_TABLE=0, PRIMARY_TABLE=0,
			SUBSCR_TERMS=0, PRIDTBL=0, BIF_TABLE=0,
			MULTIPLE_SUBSCR=FALSE, ENFORCE_RECORD=TRUE, 
			CASING_SIGNIFICANT=FALSE, 
			COMPONENTS_IN_PATHNAME=FALSE, INCOMPLETE_QUAL=FALSE) =

	BIND %NAME(LANGUAGE, '_TABLES') =
		UPLIT  (CHARTBL - TABLEBASE,
			IDENT_OPTBL - TABLEBASE,
			OPCHAR_OPTBL - TABLEBASE,
			NUMBER_TABLE - TABLEBASE,
			PRIMARY_TABLE - TABLEBASE,
			SUBSCR_TERMS - TABLEBASE,
			PRIDTBL - TABLEBASE,
			BIF_TABLE - TABLEBASE,
			MULTIPLE_SUBSCR,
    			ENFORCE_RECORD,
    			CASING_SIGNIFICANT,
    			COMPONENTS_IN_PATHNAME,
    			INCOMPLETE_QUAL): VECTOR [,LONG] %;

!	L A N G U A G E - I N D E P E N D E N T   P A R S E   T A B L E S
!
!
!
!	The Parser and Lexical Scanner tables in this section are the language-
!	independent tables used during lexical scanning and parsing.
!
!
!
! Define a table "base address".  The TABLEBASE label defines a location in the
! PLIT PSECT which constitutes the base address for all pointers within the
! DEBUG parse tables defined in this module.  This base address is needed to
! make these tables position-independent (PIC) since DEBUG may be placed any-
! where in the virtual address space when run with a user program.
!
BIND
    TABLEBASE = UPLIT BYTE (%ASCII 'BASE');


! Generate the "Percent Table" to define all built-in "%"-symbols recognized
! by DEBUG.  This includes %LINE, %LABEL, %NAME, and all the register names.
!
!
! Define literals which identify the kind of "%"-symbol a given such symbol
! is.  This is used as a CASE index for further processing in the Lexical
! Scanner (DBG$LEXICAL_SCANNER).
!
LITERAL
    PERCENT_NOFIND	= 0,		! No such "%"-symbol exists
    PERCENT_LINE	= 1,		! %LINE symbol
    PERCENT_LABEL	= 2,		! %LABEL symbol
    PERCENT_NAME	= 3,		! %NAME symbol
    PERCENT_DEC		= 4,		! %DEC decimal operator
    PERCENT_HEX		= 5,		! %HEX hexadecimal operator
    PERCENT_OCT		= 6,		! %OCT octal operator
    PERCENT_BIN		= 7,		! %BIN binary operator
    PERCENT_IDENT	= 8;		! Identifier "%"-symbols such as %R5


! Generate the actual Percent Table itself.  Note that for compatibility with
! past usage, we allow abbreviations for %LINE and %LABEL, but only for those
! two reserved names.
!
BIND
    PERCENT_TABLE = PLIT(
	UPLIT BYTE(PERCENT_LINE,  %ASCIC '%LINE') - TABLEBASE,
	UPLIT BYTE(PERCENT_LINE,  %ASCIC '%LIN' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_LINE,  %ASCIC '%LI'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_LABEL, %ASCIC '%LABEL')- TABLEBASE,
	UPLIT BYTE(PERCENT_LABEL, %ASCIC '%LABE') - TABLEBASE,
	UPLIT BYTE(PERCENT_LABEL, %ASCIC '%LAB' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_LABEL, %ASCIC '%LA'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_NAME,  %ASCIC '%NAME') - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R0'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R1'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R2'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R3'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R4'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R5'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R6'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R7'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R8'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R9'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R10' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R11' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R12' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R13' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R14' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%R15' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%AP'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%FP'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%SP'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%PC'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%PSL' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r0'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r1'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r2'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r3'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r4'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r5'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r6'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r7'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r8'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r9'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r10' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r11' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r12' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r13' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r14' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%r15' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%ap'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%fp'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%sp'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%pc'  ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%psl' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_DEC,   %ASCIC '%DEC'	) - TABLEBASE,
	UPLIT BYTE(PERCENT_HEX,   %ASCIC '%HEX'	) - TABLEBASE,
	UPLIT BYTE(PERCENT_OCT,   %ASCIC '%OCT'	) - TABLEBASE,
	UPLIT BYTE(PERCENT_BIN,   %ASCIC '%BIN' ) - TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%CURLOC')-TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%CURVAL')-TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%PREVLOC')-TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%NEXTLOC')-TABLEBASE,
	UPLIT BYTE(PERCENT_IDENT, %ASCIC '%PARCNT')-TABLEBASE
						): VECTOR[,LONG];


! Define Operator Lexical Token Entries for two predefined operators, namely
! the Initiator and the Terminator operators.  These operators do not appear
! explicitly in the DEBUG command line, but are used internally by the Opera-
! tor Precedence Parsers as expression initiator and terminator tokens.  The
! Primary Terminator is a pseudo-operator used to terminate Primary Symbols.
!
BIND
    INITIATOR_TOKEN  =
	OPERATOR_ENTRY('start of expression', INITIATOR, PREFIX, 200, 1),
    TERMINATOR_TOKEN =
	OPERATOR_ENTRY('end of expression', TERMINATOR, POSTFIX, 2, 200, LEXICAL),
    PRIMARY_TERM_TOKEN =
	OPERATOR_ENTRY('end of symbol', PRIMARY_TERM, POSTFIX, 0, 0, PRIMARY);


! Generate Operator Lexical Token Entries for the radix operators.  These
! are the operators which change the current expression radix back and forth.
!
BIND
    RADIX_OP_DEC =
	OPERATOR_ENTRY('%DEC', RADIX_DEC, PREFIX, 200, 190, LEXICAL),
    RADIX_OP_HEX =
	OPERATOR_ENTRY('%HEX', RADIX_HEX, PREFIX, 200, 190, LEXICAL),
    RADIX_OP_OCT =
	OPERATOR_ENTRY('%OCT', RADIX_OCT, PREFIX, 200, 190, LEXICAL),
    RADIX_OP_BIN =
	OPERATOR_ENTRY('%BIN', RADIX_BIN, PREFIX, 200, 190, LEXICAL);


! Generate Operand Lexical Token Entries for the built-in DEBUG symbols
! ".", "\", and "^" meaning current location, current value, and previous
! location.
!
BIND
    CURLOC_TOKEN  = OPERAND_ENTRY(TOKEN$K_IDENTIFIER, '%CURLOC'),
    CURVAL_TOKEN  = OPERAND_ENTRY(TOKEN$K_IDENTIFIER, '%CURVAL'),
    PREVLOC_TOKEN = OPERAND_ENTRY(TOKEN$K_IDENTIFIER, '%PREVLOC');


! Generate the Operator Table for the built-in operators allowed in Address
! Expressions.
!
OPERATOR_TABLE(ADDR_EXPR_OPTBL,
	OPERATOR_ENTRY('.', INDIRECT,	PREFIX,	200,  40),
	OPERATOR_ENTRY('@', INDIRECT,	PREFIX,	200,  40),
	OPERATOR_ENTRY('+', ADD,	INFIX,	 10,  10),
	OPERATOR_ENTRY('-', SUBTRACT,	INFIX,	 10,  10),
	OPERATOR_ENTRY('+', UNARY_PLUS,	PREFIX,	200,  20),
	OPERATOR_ENTRY('-', UNARY_MINUS,PREFIX,	200,  20),
	OPERATOR_ENTRY('*', MULTIPLY,	INFIX,	 30,  30),
	OPERATOR_ENTRY('/', DIVIDE,	INFIX,	 30,  30),
	OPERATOR_ENTRY('<', BITSELECT,	POSTFIX, 50, 200, LEXICAL),
	OPERATOR_ENTRY('(', OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')', CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL));


! Generate the Terminator Lexical Token Entry tables used for the EXAMINE
! and other commands (EXAM A,B,C or EXAM A:B,C:D), the DEPOSIT command
! (DEP X = Y), the SET BREAK command (SET BREAK X DO(...)), the IF command
! (IF X THEN ...), and other situations (no terminator except end of command).
!
TERMINATOR_TABLE(EMPTY_TERM_TBL);

TERMINATOR_TABLE(COMMA_TERM_TBL,
	TERMINATOR_ENTRY(',', TERM_COMMA));

TERMINATOR_TABLE(EQUAL_TERM_TBL,
	TERMINATOR_ENTRY('=', TERM_EQUAL, BALANCED_PARENS));

TERMINATOR_TABLE(DO_TERM_TBL,
	TERMINATOR_ENTRY('DO', TERM_DO, BALANCED_PARENS));

TERMINATOR_TABLE(THEN_TERM_TBL,
	TERMINATOR_ENTRY('THEN', TERM_THEN, BALANCED_PARENS));

TERMINATOR_TABLE(COMCOL_TERM_TBL,
	TERMINATOR_ENTRY(',', TERM_COMMA),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE));

TERMINATOR_TABLE(CMWHDO_TERM_TBL,
	TERMINATOR_ENTRY(',', TERM_COMMA),
	TERMINATOR_ENTRY('WHEN', TERM_WHEN, BALANCED_PARENS),
	TERMINATOR_ENTRY('DO', TERM_DO, BALANCED_PARENS));

TERMINATOR_TABLE(OPEN_TERM_TBL,
	TERMINATOR_ENTRY('(', TERM_OPEN));

TERMINATOR_TABLE(COMPAREN_TERM_TBL,
	TERMINATOR_ENTRY(',', TERM_COMMA),
	TERMINATOR_ENTRY(')', TERM_CLOSE, BALANCED_PARENS));

TERMINATOR_TABLE(TO_TERM_TBL,
	TERMINATOR_ENTRY('TO', TERM_TO, BALANCED_PARENS));

TERMINATOR_TABLE(BY_TERM_TBL,
	TERMINATOR_ENTRY('BY', TERM_BY, BALANCED_PARENS),
	TERMINATOR_ENTRY('DO', TERM_DO, BALANCED_PARENS));

TERMINATOR_TABLE(BIT_SELECT_TERM_TBL,
	TERMINATOR_ENTRY(',', TERM_COMMA),
	TERMINATOR_ENTRY('>', TERM_GTRTHAN));

TERMINATOR_TABLE(SET_CONSTANT_TERM_TBL,
	TERMINATOR_ENTRY(',', TERM_COMMA),
	TERMINATOR_ENTRY(']', TERM_CLOSE, BALANCED_PARENS),
	TERMINATOR_ENTRY('..', TERM_DOT));


! Generate a table indexed by Terminator Code which has pointers to the above
! Terminator Lexical Token Entry tables.  This table is used in DBG$EXP_INT
! and DBG$ADDR_EXP_INT to look up the terminator table to be used for the
! current expression of address expression.
!
OWN
    TERM_POINTER_TBL: VECTOR[TOKEN$K_MAX_TERMINATOR + 1]
					PSECT(DBG$PLIT) PRESET(
	[TOKEN$K_TERM_NONE]    = EMPTY_TERM_TBL  	- TABLEBASE,
	[TOKEN$K_TERM_COMMA]   = COMMA_TERM_TBL  	- TABLEBASE,
	[TOKEN$K_TERM_EQUAL]   = EQUAL_TERM_TBL  	- TABLEBASE,
	[TOKEN$K_TERM_DO]      = DO_TERM_TBL     	- TABLEBASE,
	[TOKEN$K_TERM_THEN]    = THEN_TERM_TBL   	- TABLEBASE,
	[TOKEN$K_TERM_COMCOL]  = COMCOL_TERM_TBL 	- TABLEBASE,
	[TOKEN$K_TERM_CMWHDO]  = CMWHDO_TERM_TBL 	- TABLEBASE,
	[TOKEN$K_TERM_OPEN]    = OPEN_TERM_TBL  	- TABLEBASE,
	[TOKEN$K_TERM_COMPAREN]= COMPAREN_TERM_TBL  	- TABLEBASE,
	[TOKEN$K_TERM_TO]      = TO_TERM_TBL		- TABLEBASE,
	[TOKEN$K_TERM_BY]      = BY_TERM_TBL		- TABLEBASE);


! Generate the base Character Table.  The Character Table for each supported
! language is generated by using this Character Table as a base and then
! specifying a list of exceptions for specific characters.  The result is
! a language-specific Character Table, generated in the CHARTBL vector.
!
CHAR_TABLE(BASE_CHARACTER_TABLE,
	CHAR_ENT('A', HEXDIGIT,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('B', B,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('C', HEXDIGIT,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('D', D,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('E', E,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('F', HEXDIGIT,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('G', G,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('H', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('I', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('J', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('K', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('L', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('M', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('N', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('O', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('P', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('Q', Q,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('R', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('S', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('T', OTHER,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('U', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('V', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('W', OTHER,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('X', X,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('Y', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('Z', OTHER,	ALPHABETIC, IDENT_ANYWHERE),

	CHAR_ENT('a', HEXDIGIT,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('b', B,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('c', HEXDIGIT,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('d', D,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('e', E,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('f', HEXDIGIT,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('g', G,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('h', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('i', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('j', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('k', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('l', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('m', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('n', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('o', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('p', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('q', Q,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('r', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('s', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('t', OTHER,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('u', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('v', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('w', OTHER,	ALPHABETIC, IDENT_ANYWHERE, TERMINATOR),
	CHAR_ENT('x', X,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('y', OTHER,	ALPHABETIC, IDENT_ANYWHERE),
	CHAR_ENT('z', OTHER,	ALPHABETIC, IDENT_ANYWHERE),

	CHAR_ENT('0', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('1', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('2', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('3', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('4', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('5', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('6', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('7', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('8', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),
	CHAR_ENT('9', DIGIT,	DIGIT, IDENT_MIDDLE, IDENT_END, NUMBER_START),

	CHAR_ENT(' ', OTHER,	SPACE),
	CHAR_ENT(  9, OTHER,	SPACE),		! Tab character
	CHAR_ENT('!', OTHER,	NOTHING),
	CHAR_ENT('"', OTHER,	STRING_QUOTE),
	CHAR_ENT('#', OTHER,	NOTHING),
	CHAR_ENT('$', OTHER,	IDENT_MIDDLE, IDENT_END),
	CHAR_ENT('%', OTHER,	NOTHING),
	CHAR_ENT('&', OTHER,	NOTHING),
	CHAR_ENT('''',OTHER,	STRING_QUOTE),
	CHAR_ENT('(', OTHER,	OPCHAR, ADDRESS_OP, TERMINATOR),
	CHAR_ENT(')', OTHER,	OPCHAR, ADDRESS_OP, TERMINATOR),
	CHAR_ENT('*', OTHER,	OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENT('+', PLUS,	OPCHAR, ADDRESS_OP),
	CHAR_ENT(',', OTHER,	TERMINATOR),
	CHAR_ENT('-', MINUS,	OPCHAR, ADDRESS_OP),
	CHAR_ENT('.', DOT,	NUMBER_START, OPCHAR, ADDRESS_OP, SPECIAL_SYMBOL),
	CHAR_ENT('/', OTHER,	OPCHAR, ADDRESS_OP),
	CHAR_ENT(':', OTHER,	TERMINATOR),
	CHAR_ENT(';', OTHER,	NOTHING),
	CHAR_ENT('<', OTHER,	ADDRESS_OP),
	CHAR_ENT('=', OTHER,	TERMINATOR),
	CHAR_ENT('>', OTHER,	TERMINATOR),
	CHAR_ENT('?', OTHER,	NOTHING),
	CHAR_ENT('@', OTHER,	OPCHAR, ADDRESS_OP),
	CHAR_ENT('[', OTHER,	NOTHING),
	CHAR_ENT('\', OTHER,	OPCHAR, SPECIAL_SYMBOL),
	CHAR_ENT(']', OTHER,	NOTHING),
	CHAR_ENT('^', OTHER,	SPECIAL_SYMBOL),
	CHAR_ENT('_', OTHER,	IDENT_MIDDLE, IDENT_END),
	CHAR_ENT('`', OTHER,	NOTHING),
	CHAR_ENT('{', OTHER,	NOTHING),
	CHAR_ENT('|', OTHER,	NOTHING),
	CHAR_ENT('}', OTHER,	NOTHING),
	CHAR_ENT('~', OTHER,	NOTHING));

!		L A N G U A G E   U N K N O W N   P A R S E   T A B L E S
!
!
!	This section contains all Lexical Scanner and Parser tables for
!	language UNKNOWN.  Language "UNKNOWN" constitutes the language
!	facilities made available by DEBUG when the actual source language
!	is not known to DEBUG.  The main use for language UNKNOWN is to
!	provide a basic level of DEBUG support for new languages which are
!	not yet explicitly supported by DEBUG with its own syntax and
!	semantics.
!
!	(Language UNKNOWN comes first because some of the other languages
!	make references to the UNKNOWN number table.  The rest of the languages
!	are in alphabetical order.)
!
!
!
! Define the language UNKNOWN Character Table.
!
CHAR_EXCEPTION_TABLE(UNKNOWN_CHARTBL,
	CHAR_ENTRY('&', OTHER,	OPCHAR),
	CHAR_ENTRY('/', OTHER,	OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENTRY('<', OTHER,	OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENTRY('=', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('>', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('^', OTHER,  OPCHAR, SPECIAL_SYMBOL),
	CHAR_ENTRY('[', OTHER,	OPCHAR),
	CHAR_ENTRY(']', OTHER,	TERMINATOR));


! Define the language UNKNOWN Operator Table for operators whose names are
! identifiers.
!
OPERATOR_TABLE(UNKNOWN_IDENT_OPTBL,
	OPERATOR_ENTRY('EQL',	EQUAL,		INFIX,	 50, 50),
	OPERATOR_ENTRY('NEQ',	NOT_EQUAL,	INFIX,	 50, 50),
	OPERATOR_ENTRY('GTR',	GTR_THAN,	INFIX,	 50, 50),
	OPERATOR_ENTRY('GEQ',	GTR_EQUAL,	INFIX,	 50, 50),
	OPERATOR_ENTRY('LSS',	LSS_THAN,	INFIX,	 50, 50),
	OPERATOR_ENTRY('LEQ',	LSS_EQUAL,	INFIX,	 50, 50),
	OPERATOR_ENTRY('NOT',	NOT,		PREFIX,	200, 40),
	OPERATOR_ENTRY('AND',	AND,		INFIX,	 30, 30),
	OPERATOR_ENTRY('OR',	OR,		INFIX,	 20, 20),
	OPERATOR_ENTRY('XOR',	XOR,		INFIX,	 10, 10),
	OPERATOR_ENTRY('EQV',	EQV,		INFIX,	 10, 10));


! Define the language UNKNOWN Operator Table for operators whose names are
! composed of operator characters such as "+", "_", or "*".  This table in-
! cludes operators which are part of Primary Symbols (such as "\" and ".").
!
OPERATOR_TABLE(UNKNOWN_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('.',	DOT,		INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
    	OPERATOR_ENTRY('[',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
    	OPERATOR_ENTRY('^',	PASCAL_DEREF,	POSTFIX,0, 0, PRIMARY),

    	OPERATOR_ENTRY('//',	CONCATENATE,	INFIX,	 60,  60),
	OPERATOR_ENTRY('&',	CONCATENATE,	INFIX,	 60,  60),
	OPERATOR_ENTRY('+',	ADD,		INFIX,	 60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	 60,  60),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX,	200,  70),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX,	200,  70),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	 80,  80),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	 80,  80),
	OPERATOR_ENTRY('**',	POWER_OF,	INFIX,	 92,  90),
	OPERATOR_ENTRY('=',	EQUAL,		INFIX,	 50,  50),
	OPERATOR_ENTRY('<>',	NOT_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('/=',	NOT_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('>',	GTR_THAN,	INFIX,	 50,  50),
	OPERATOR_ENTRY('>=',	GTR_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('<',	LSS_THAN,	INFIX,	 50,  50),
	OPERATOR_ENTRY('<=',	LSS_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL));


! Define the UNKNOWN Terminator Lexical Token Table for subscript expressions.
! Here we allow subscript expressions to be terminated by ")" (end of sub-
! scripts) and by "," (more subscripts to follow).
!
TERMINATOR_TABLE(UNKNOWN_SUBSCR_TERM_TBL,
    	TERMINATOR_ENTRY(']', TERM_CLOSE, BALANCED_PARENS),
	TERMINATOR_ENTRY(')', TERM_CLOSE, BALANCED_PARENS),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the language UNKNOWN Number Scanner State Table. This is a finite-state
! machine in which each transition is of the form:
!
!	NUMBER_TRANSITION(character-class, action-index, next-state)
!
! where the character-class and action-index names are automatically prefixed
! by "NUMST$K_CLASS_" or "NUMST$K_ACT_" by the NUMBER_TRANSITION macro.
!
NUMBER_STATE_TABLE(UNKNOWN_NUMBER_TABLE,

    NUMBER_STATE(START_STATE,
	NUMBER_TRANSITION(DIGIT, GO_PAST_DIGIT, ACCUM_INT),
	NUMBER_TRANSITION(DOT, MARK_DEC_PT, LEADING_DOT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(LEADING_DOT,
	NUMBER_TRANSITION(DIGIT, GO_PAST_FRAC, ACCUM_FRAC),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, GO_PAST_DIGIT, ACCUM_INT),
	NUMBER_TRANSITION(DOT, MARK_DEC_PT, ACCUM_FRAC),
	NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(B, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(D, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(E, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_HEX,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(B, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(D, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(E, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, GO_PAST_FRAC, ACCUM_FRAC),
	NUMBER_TRANSITION(DOT, BACKUP_PTRS, END_STATE),
	NUMBER_TRANSITION(E, MARK_E_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(D, MARK_D_EXP, GET_EXPONENT),
    	NUMBER_TRANSITION(G, MARK_G_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(Q, MARK_Q_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(GET_EXPONENT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(PLUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(MINUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(OTHER, BACKUP_PTRS, END_STATE)),

    NUMBER_STATE(GET_EXP_SIGN,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_EXP,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(END_STATE,
	NUMBER_TRANSITION(OTHER, GIVE_ERROR, END_STATE)));


! Define the language UNKNOWN Predefined Identifier Table.
!
PRID_TABLE(UNKNOWN_PRID_TABLE);


! Define the language UNKNOWN Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(UNKNOWN_FUNCTION_TABLE);


! Define the Primary Parser State Table for language UNKNOWN.
!
PRIMARY_STATE_TABLE(UNKNOWN_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, START_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, SLASH_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, SLASH_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
	PRIMARY_TRANSITION(DOT, DOT_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, DOT_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(DOT, SUBSCR_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, SUBSCR_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DEREF,
	PRIMARY_TRANSITION(DOT, DEREF_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DEREF_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, DEREF_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, DEREF_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Finally define the table of pointers to the parse tables for language UNKNOWN.
!
LANGUAGE_TABLES(LANGUAGE = UNKNOWN,
		CHARTBL = UNKNOWN_CHARTBL,
		IDENT_OPTBL = UNKNOWN_IDENT_OPTBL,
		OPCHAR_OPTBL = UNKNOWN_OPCHAR_OPTBL,
		NUMBER_TABLE = UNKNOWN_NUMBER_TABLE,
		PRIMARY_TABLE = UNKNOWN_PRIMARY_TABLE,
		SUBSCR_TERMS = UNKNOWN_SUBSCR_TERM_TBL,
		PRIDTBL = UNKNOWN_PRID_TABLE,
		BIF_TABLE = UNKNOWN_FUNCTION_TABLE);

!			A D A   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the ADA language.
!
!
!
! Define the ADA Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(ADA_CHARTBL,
	CHAR_ENTRY('''',OTHER,	NOTHING),
	CHAR_ENTRY('_', UNDERSCORE, IDENT_MIDDLE),
    	CHAR_ENTRY('#', POUND,  NOTHING),
	CHAR_ENTRY('&', OTHER,	OPCHAR),
	CHAR_ENTRY('/', OTHER,	OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENTRY('<', OTHER,	OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENTRY('=', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('>', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR),
  	CHAR_ENTRY('.', DOT,	OPCHAR, ADDRESS_OP, SPECIAL_SYMBOL, TERMINATOR));


! Define the ADA Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(ADA_IDENT_OPTBL,
	OPERATOR_ENTRY('NOT',	NOT,		PREFIX,	200, 60),
	OPERATOR_ENTRY('ABS',	ABSOLUTE,	PREFIX,	200, 60),
	OPERATOR_ENTRY('MOD',	MODULUS,	INFIX,	 50, 50),
	OPERATOR_ENTRY('REM',	REMAINDER,	INFIX,	 50, 50),
	OPERATOR_ENTRY('AND',	AND,		INFIX,	 10, 10),
	OPERATOR_ENTRY('OR',	OR,		INFIX,	 10, 10),
	OPERATOR_ENTRY('XOR',	XOR,		INFIX,	 10, 10));


! Define the ADA Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(ADA_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('.',	DOT,		INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),

	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),
	OPERATOR_ENTRY('**',	POWER_OF,	INFIX,	 60,  60),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	 50,  50),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	 50,  50),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX,	200,  40),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX,	200,  40),
	OPERATOR_ENTRY('+',	ADD,		INFIX,	 30,  30),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	 30,  30),
	OPERATOR_ENTRY('&',	CONCATENATE,	INFIX,	 30,  30),
	OPERATOR_ENTRY('=',	EQUAL,		INFIX,	 20,  20),
	OPERATOR_ENTRY('/=',	NOT_EQUAL,	INFIX,	 20,  20),
	OPERATOR_ENTRY('<',	LSS_THAN,	INFIX,	 20,  20),
	OPERATOR_ENTRY('<=',	LSS_EQUAL,	INFIX,	 20,  20),
	OPERATOR_ENTRY('>',	GTR_THAN,	INFIX,	 20,  20),
	OPERATOR_ENTRY('>=',	GTR_EQUAL,	INFIX,	 20,  20));


! Define an Operator Lexical Token Entry for the ADA Tick operator "'".
! This token is actually used to represent a collection of postfix
! tick operators ("'FIRST", "'LAST", ...). The lexical scanner will
! fill in the subcode field which identifies which tick operator was
! given.
!
BIND
    ADA_TICK_TOKEN = OPERATOR_ENTRY('''', ADA_TICK, POSTFIX, 0, 0, PRIMARY);


OWN
    ADA_TICK_TABLE: VECTOR [TOKEN$K_TICK_MAX+1] PSECT(DBG$PLIT) PRESET (
    	[TOKEN$K_TICK_CONSTRAINED]	= UPLIT (%ASCIC 'CONSTRAINED')	- TABLEBASE,
    	[TOKEN$K_TICK_FIRST]		= UPLIT (%ASCIC 'FIRST')	- TABLEBASE,
    	[TOKEN$K_TICK_LAST]		= UPLIT (%ASCIC 'LAST')		- TABLEBASE,
    	[TOKEN$K_TICK_LENGTH]		= UPLIT (%ASCIC 'LENGTH')	- TABLEBASE,
    	[TOKEN$K_TICK_POS]		= UPLIT (%ASCIC 'POS')		- TABLEBASE,
    	[TOKEN$K_TICK_PRED]		= UPLIT (%ASCIC 'PRED')		- TABLEBASE,
    	[TOKEN$K_TICK_SIZE]		= UPLIT (%ASCIC 'SIZE')		- TABLEBASE,
    	[TOKEN$K_TICK_SUCC]		= UPLIT (%ASCIC 'SUCC')		- TABLEBASE,
    	[TOKEN$K_TICK_VAL]		= UPLIT (%ASCIC 'VAL')		- TABLEBASE);

! Define the ADA Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(ADA_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(')', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
    	TERMINATOR_ENTRY('..',TERM_COLON),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the ADA Predefined Identifier Table.
!
PRID_TABLE(ADA_PRID_TABLE);


! Define the ADA Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(ADA_FUNCTION_TABLE);


! Define the ADA Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! Each transition is of the form:
!	NUMBER_TRANSITION(character-class, action-index, next-state)
!
! The ADA standard defines a number to be of the form:
!
!	number_literal ::=  integer [.integer] [exponent]
!	integer ::= digit { [underline] digit }
!	exponent ::= E [+] integer | E - integer
!
! Examples:
!
!	12     1E6       123_456 	integer literals
!	12.0   3.141_592 1.34E+6  	real literals
!
! The ADA standard also defines a based number to be of the form:
!
!	base # based_integer [.based_integer] # [exponent]
!	base ::= integer
!	based_integer ::= extended_digit { [underline] extended_digit }
!	extended_digit ::= digit | letter
!
! Examples:
!
!	2#1111_1111#  16#FF#		integer literals
!	16#FF.FF#E+2			real literal
!
NUMBER_STATE_TABLE(ADA_NUMBER_TABLE,

    NUMBER_STATE(START_STATE,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_INT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_INT),
    	NUMBER_TRANSITION(UNDERSCORE, DO_NOTHING, T_ACCUM_INT),
        NUMBER_TRANSITION(POUND, SAVE_BASE, B_START_STATE),
	NUMBER_TRANSITION(DOT, MARK_DEC_PT, ACCUM_FRAC),
	NUMBER_TRANSITION(E, DO_NOTHING, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(T_ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_INT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_FRAC),
    	NUMBER_TRANSITION(UNDERSCORE, DO_NOTHING, T_ACCUM_FRAC),
	NUMBER_TRANSITION(DOT, NOT_NUMBER, END_STATE),
	NUMBER_TRANSITION(E, MARK_E_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(D, MARK_D_EXP, GET_EXPONENT),
    	NUMBER_TRANSITION(G, MARK_G_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(Q, MARK_Q_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(T_ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_FRAC),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(GET_EXPONENT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(PLUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(MINUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(GET_EXP_SIGN,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_EXP,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
    	NUMBER_TRANSITION(UNDERSCORE, DO_NOTHING, T_ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(T_ACCUM_EXP,
    	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
    	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(B_START_STATE,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, B_ACCUM_INT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(B_ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, B_ACCUM_INT),
        NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, B_ACCUM_INT),
    	NUMBER_TRANSITION(B, DO_NOTHING, B_ACCUM_INT),
    	NUMBER_TRANSITION(D, DO_NOTHING, B_ACCUM_INT),
	NUMBER_TRANSITION(E, DO_NOTHING, B_ACCUM_INT),
    	NUMBER_TRANSITION(UNDERSCORE, DO_NOTHING, T_B_ACCUM_INT),
	NUMBER_TRANSITION(DOT, MARK_DEC_PT, B_ACCUM_FRAC),
        NUMBER_TRANSITION(POUND, DO_NOTHING, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(T_B_ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, B_ACCUM_INT),
        NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, B_ACCUM_INT),
    	NUMBER_TRANSITION(B, DO_NOTHING, B_ACCUM_INT),
    	NUMBER_TRANSITION(D, DO_NOTHING, B_ACCUM_INT),
	NUMBER_TRANSITION(E, DO_NOTHING, B_ACCUM_INT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(B_ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, B_ACCUM_FRAC),
        NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, B_ACCUM_FRAC),
    	NUMBER_TRANSITION(B, DO_NOTHING, B_ACCUM_FRAC),
    	NUMBER_TRANSITION(D, DO_NOTHING, B_ACCUM_FRAC),
	NUMBER_TRANSITION(E, DO_NOTHING, B_ACCUM_FRAC),
    	NUMBER_TRANSITION(UNDERSCORE, DO_NOTHING, T_B_ACCUM_FRAC),
	NUMBER_TRANSITION(POUND, MARK_E_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(T_B_ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, B_ACCUM_FRAC),
        NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, B_ACCUM_FRAC),
    	NUMBER_TRANSITION(B, DO_NOTHING, B_ACCUM_FRAC),
    	NUMBER_TRANSITION(D, DO_NOTHING, B_ACCUM_FRAC),
	NUMBER_TRANSITION(E, DO_NOTHING, B_ACCUM_FRAC),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(END_STATE,
	NUMBER_TRANSITION(OTHER, GIVE_ERROR, END_STATE)));


! Save away the value of the B_START_STATE state for ADA. This will be
! used later in the number scanner.
!
COMPILETIME
    REMEMBER_ADA_B_START_STATE = 0;
%ASSIGN (REMEMBER_ADA_B_START_STATE, NUMST$XX_STATE_B_START_STATE);


! Define the Primary Parser State Table for language ADA.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(ADA_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(ADA_TICK, START_TICK, END_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, SLASH_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(ADA_TICK, SLASH_TICK, END_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
	PRIMARY_TRANSITION(DOT, DOT_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(ADA_TICK, DOT_TICK, END_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(DOT, SUBSCR_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for ADA.
!
LANGUAGE_TABLES(LANGUAGE = ADA,
		CHARTBL = ADA_CHARTBL,
		IDENT_OPTBL = ADA_IDENT_OPTBL,
		OPCHAR_OPTBL = ADA_OPCHAR_OPTBL,
		NUMBER_TABLE = ADA_NUMBER_TABLE,
		PRIMARY_TABLE = ADA_PRIMARY_TABLE,
		SUBSCR_TERMS = ADA_SUBSCR_TERM_TBL,
		PRIDTBL = ADA_PRID_TABLE,
		BIF_TABLE = ADA_FUNCTION_TABLE);

!			B A S I C   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse BASIC expressions.
!
!
!
! Define the BASIC Character Table.  What is listed here is actually a list
! of exceptions to the Character Table for language UNKNOWN.  (Language UNKNOWN
! lists the "average" use of each character in the character set.)
!
CHAR_EXCEPTION_TABLE(BASIC_CHARTBL,
	CHAR_ENTRY('.', DOT,	NUMBER_START, IDENT_MIDDLE, IDENT_END, ADDRESS_OP, SPECIAL_SYMBOL),
	CHAR_ENTRY('%', OTHER,  IDENT_END),
	CHAR_ENTRY(':', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('^', OTHER,  OPCHAR, SPECIAL_SYMBOL),
	CHAR_ENTRY('<', OTHER,  OPCHAR, OPCHAR_INFIX, ADDRESS_OP, TERMINATOR),
	CHAR_ENTRY('>', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('=', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR));


! Define the BASIC Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(BASIC_IDENT_OPTBL,
	OPERATOR_ENTRY('NOT',	BIT_NOT,	PREFIX,	200,  45),
	OPERATOR_ENTRY('AND',	BIT_AND,	INFIX,	 40,  40),
	OPERATOR_ENTRY('OR',	BIT_OR,		INFIX,	 30,  30),
	OPERATOR_ENTRY('XOR',	BIT_XOR,	INFIX,   30,  30),
	OPERATOR_ENTRY('IMP',	BIT_IMP,	INFIX,   20,  20),
	OPERATOR_ENTRY('EQV',	BIT_EQV,	INFIX,   10,  10));


! Define the BASIC Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes those
! operators which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(BASIC_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	  0,   0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	  0,   0, PRIMARY),
	OPERATOR_ENTRY('::',	DOT,		INFIX,	  0,   0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,  0,   0, PRIMARY),

	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX,	200,  70),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX,	200,  70),
	OPERATOR_ENTRY('**',	POWER_OF,	INFIX,	 92,  90),
	OPERATOR_ENTRY('^',	POWER_OF,	INFIX,	 92,  90),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	 80,  80),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	 80,  80),
	OPERATOR_ENTRY('+',	ADD,		INFIX,	 60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	 60,  60),
	OPERATOR_ENTRY('<',	LSS_THAN,	INFIX,	 50,  50),
	OPERATOR_ENTRY('<=',	LSS_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('=<',	LSS_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('>',	GTR_THAN,	INFIX,	 50,  50),
	OPERATOR_ENTRY('>=',	GTR_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('=>',	GTR_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('=',	EQUAL,		INFIX,	 50,  50),
	OPERATOR_ENTRY('<>',	NOT_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('><',	NOT_EQUAL,	INFIX,	 50,  50));


! Define the BASIC Terminator Lexical Token Table for subscript expressions.
! In BASIC a subscript expression can be terminated by ")" (end of sub-
! scripts), by "," (more subscripts to follow), or by ":" (string subscript
! upper bound to follow).
!
TERMINATOR_TABLE(BASIC_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(')', TERM_CLOSE, BALANCED_PARENS),
    	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the BASIC Predefined Identifier Table.
!
PRID_TABLE(BASIC_PRID_TABLE);


! Define the BASIC Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(BASIC_FUNCTION_TABLE);


! Define the BASIC Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! The BASIC number table is the same as the UNKNOWN number table at present.
!
BIND
    BASIC_NUMBER_TABLE = UNKNOWN_NUMBER_TABLE;


! Define the Primary Parser State Table for language BASIC Each Transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(BASIC_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, SLASH_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
 	PRIMARY_TRANSITION(DOT, DOT_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(DOT, SUBSCR_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for BASIC.
!
LANGUAGE_TABLES(LANGUAGE = BASIC,
		CHARTBL = BASIC_CHARTBL,
		IDENT_OPTBL = BASIC_IDENT_OPTBL,
		OPCHAR_OPTBL = BASIC_OPCHAR_OPTBL,
		NUMBER_TABLE = BASIC_NUMBER_TABLE,
		PRIMARY_TABLE = BASIC_PRIMARY_TABLE,
		SUBSCR_TERMS = BASIC_SUBSCR_TERM_TBL,
		PRIDTBL = BASIC_PRID_TABLE,
		BIF_TABLE = BASIC_FUNCTION_TABLE,
    		INCOMPLETE_QUAL = TRUE);

!			B L I S S   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the BLISS language.
!
!
!
! Define the BLISS Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(BLISS_CHARTBL,
	CHAR_ENTRY('$', OTHER,	IDENT_ANYWHERE),
	CHAR_ENTRY('<', OTHER,  OPCHAR, ADDRESS_OP),
	CHAR_ENTRY('>', OTHER,  TERMINATOR),
	CHAR_ENTRY('[', OTHER,	OPCHAR),
	CHAR_ENTRY(']', OTHER,  TERMINATOR),
	CHAR_ENTRY('^', OTHER,  OPCHAR, SPECIAL_SYMBOL),
	CHAR_ENTRY('_', OTHER,	IDENT_ANYWHERE));

! Define the BLISS Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(BLISS_IDENT_OPTBL,
	OPERATOR_ENTRY('MOD',	REMAINDER,	INFIX,   70,  70),
	OPERATOR_ENTRY('EQL',	EQUAL,		INFIX,   50,  50),
	OPERATOR_ENTRY('EQLU',	EQUAL,		INFIX,	 50,  50),
	OPERATOR_ENTRY('EQLA',	EQUAL,		INFIX,	 50,  50),
	OPERATOR_ENTRY('NEQ',	NOT_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('NEQU',	NOT_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('NEQA',	NOT_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('GTR',	GTR_THAN,	INFIX,   50,  50),
	OPERATOR_ENTRY('GTRU',	GTR_THAN_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('GTRA',	GTR_THAN_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('GEQ',	GTR_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('GEQU',	GTR_EQUAL_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('GEQA',  GTR_EQUAL_U,	INFIX,	 50,  50),
	OPERATOR_ENTRY('LSS',	LSS_THAN,	INFIX,   50,  50),
	OPERATOR_ENTRY('LSSU', 	LSS_THAN_U,	INFIX,	 50,  50),
	OPERATOR_ENTRY('LSSA', 	LSS_THAN_U,	INFIX,	 50,  50),
	OPERATOR_ENTRY('LEQ',	LSS_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('LEQU',	LSS_EQUAL_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('LEQA',	LSS_EQUAL_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('NOT',	BIT_NOT,	PREFIX, 200,  40),
	OPERATOR_ENTRY('AND',	BIT_AND,	INFIX,   30,  30),
	OPERATOR_ENTRY('OR',	BIT_OR,		INFIX,   20,  20),
	OPERATOR_ENTRY('EQV',	BIT_EQV,	INFIX,   10,  10),
	OPERATOR_ENTRY('XOR',	BIT_XOR,	INFIX,   10,  10));


! Define the BLISS Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(BLISS_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('[',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),

	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),

	OPERATOR_ENTRY('<',	BITSELECT,	POSTFIX,110, 200, LEXICAL),
	OPERATOR_ENTRY('.',	INDIRECT,	PREFIX, 200, 100),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX, 200,  90),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX, 200,  90),
	OPERATOR_ENTRY('^',	LEFT_SHIFT,	INFIX,   80,  80),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,   70,  70),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,   70,  70),
	OPERATOR_ENTRY('+',	ADD,		INFIX,   60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,   60,  60));


! Define the BLISS Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(BLISS_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(']', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the BLISS Predefined Identifier Table.
!
PRID_TABLE(BLISS_PRID_TABLE);


! Define the BLISS Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(BLISS_FUNCTION_TABLE);


! Define the BLISS Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! The BLISS number table is the same as the UNKNOWN number table at present.
!
BIND
    BLISS_NUMBER_TABLE = UNKNOWN_NUMBER_TABLE;


! Define the Primary Parser State Table for language BLISS.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(BLISS_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR_BLI, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR_BLI, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for BLISS.
!
LANGUAGE_TABLES(LANGUAGE = BLISS,
		CHARTBL = BLISS_CHARTBL,
		IDENT_OPTBL = BLISS_IDENT_OPTBL,
		OPCHAR_OPTBL = BLISS_OPCHAR_OPTBL,
		NUMBER_TABLE = BLISS_NUMBER_TABLE,
		PRIMARY_TABLE = BLISS_PRIMARY_TABLE,
		SUBSCR_TERMS = BLISS_SUBSCR_TERM_TBL,
		PRIDTBL = BLISS_PRID_TABLE,
		BIF_TABLE = BLISS_FUNCTION_TABLE);

!			C   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the C language.
!
!
!
! Define the C Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(C_CHARTBL,
	CHAR_ENTRY('$', OTHER,	IDENT_ANYWHERE),
    	CHAR_ENTRY('_', OTHER,  IDENT_ANYWHERE),
	CHAR_ENTRY('!', OTHER,	OPCHAR, OPCHAR_INFIX),
	CHAR_ENTRY('*', OTHER,	OPCHAR, ADDRESS_OP),
	CHAR_ENTRY('%', OTHER,	OPCHAR),
	CHAR_ENTRY('<', OTHER,	OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENTRY('=', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('>', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('[', OTHER,	OPCHAR),
	CHAR_ENTRY(']', OTHER,  TERMINATOR),
	CHAR_ENTRY('^', OTHER,	OPCHAR, SPECIAL_SYMBOL),
	CHAR_ENTRY('|', OTHER,	OPCHAR, OPCHAR_INFIX),
	CHAR_ENTRY('~', OTHER,	OPCHAR));


! Define the C Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(C_IDENT_OPTBL,
	OPERATOR_ENTRY('SIZEOF', SIZEOF,	PREFIX,	200, 140));


! Define the C Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(C_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('[',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
	OPERATOR_ENTRY('.',	DOT,		INFIX,	0, 0, PRIMARY),

	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),
	OPERATOR_ENTRY('!',	NOT,		PREFIX,	200, 140),
	OPERATOR_ENTRY('~',	BIT_NOT,	PREFIX,	200, 140),
	OPERATOR_ENTRY('*',	INDIRECT,	PREFIX,	200, 140),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	130, 130),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	130, 130),
	OPERATOR_ENTRY('%',	REMAINDER,	INFIX,	130, 130),
	OPERATOR_ENTRY('<<',	LEFT_SHIFT,	INFIX,	110, 110),
	OPERATOR_ENTRY('>>',	RIGHT_SHIFT,	INFIX,	110, 110),
	OPERATOR_ENTRY('<',	LSS_THAN,	INFIX,	100, 100),
	OPERATOR_ENTRY('<=',	LSS_EQUAL,	INFIX,	100, 100),
	OPERATOR_ENTRY('>',	GTR_THAN,	INFIX,	100, 100),
	OPERATOR_ENTRY('>=',	GTR_EQUAL,	INFIX,	100, 100),
	OPERATOR_ENTRY('==',	EQUAL,		INFIX,	 90,  90),
	OPERATOR_ENTRY('!=',	NOT_EQUAL,	INFIX,	 90,  90),
	OPERATOR_ENTRY('^',	BIT_XOR,	INFIX,	 70,  70),
	OPERATOR_ENTRY('|',	BIT_OR,		INFIX,	 60,  60),
	OPERATOR_ENTRY('||',	SHORT_OR,	INFIX,	 40,  40));


! Define Lexical Token Entries which require special-case scanning.
!
BIND
    C_ADDR_OF_TOKEN =
	OPERATOR_ENTRY('&',	ADDRESS_OF,	PREFIX,	200, 140),
    C_BIT_AND_TOKEN =
	OPERATOR_ENTRY('&',	BIT_AND,	INFIX,	 80,  80),
    C_AND_TOKEN =
	OPERATOR_ENTRY('&&',	SHORT_AND,	INFIX,	 50,  50),
    C_ADD_TOKEN =
	OPERATOR_ENTRY('+',	ADD,		INFIX,	120, 120),
    C_MINUS_TOKEN =
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX,	200, 140),
    C_SUB_TOKEN =
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	120, 120),
    C_ARROW_TOKEN =
    	OPERATOR_ENTRY('->',	PLI_DEREF,	INFIX,    0,   0, PRIMARY),

    ! The indirect operator will also be allowed as an address expression
    ! operator in C (synonymous with "." and "@"). That's why it appears
    ! here as a special case, in addition to its appearance in the normal
    ! operator tables. The precedence of "40" here is relative to other
    ! address expression operators.
    !
    C_INDIRECT_TOKEN =
	OPERATOR_ENTRY('*',	INDIRECT,	PREFIX,	200,  40);


! Increment and decrement were commented out so as not to allow operators with
! side effects. If we decide to allow them, the comments can be removed.
!
!BIND
!    C_PRE_INCR_TOKEN =
!    	OPERATOR_ENTRY('++',	PRE_INCR,	PREFIX,	200, 140),
!    C_POST_INCR_TOKEN =
!    	OPERATOR_ENTRY('++',	POST_INCR,	POSTFIX,140, 200),
!    C_PRE_DECR_TOKEN =
!    	OPERATOR_ENTRY('--',	PRE_DECR,	PREFIX, 200, 140),
!    C_POST_DECR_TOKEN =
!    	OPERATOR_ENTRY('--',	POST_DECR,	POSTFIX,140, 200);



! Define the C Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(C_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(']', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the C Predefined Identifier Table.
!
PRID_TABLE(C_PRID_TABLE);


! Define the C Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(C_FUNCTION_TABLE);


! Define the C Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! The C number table is the same as the UNKNOWN number table.
!
BIND
    C_NUMBER_TABLE = UNKNOWN_NUMBER_TABLE;


! Define the Primary Parser State Table for language C.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(C_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, START_DEREF, GOT_DOT),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, SLASH_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, SLASH_DEREF, GOT_DOT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
	PRIMARY_TRANSITION(DOT, DOT_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, DOT_DEREF, GOT_DOT),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(DOT, SUBSCR_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, SUBSCR_DEREF, GOT_DOT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Save away the value of the GOT_SUBSCRIPT state for C. This will be
! used later in the expression parser.
!
COMPILETIME
    REMEMBER_C_STATE_GOT_SUBSCRIPT = 0;
%ASSIGN (REMEMBER_C_STATE_GOT_SUBSCRIPT, PRIMARY$XX_STATE_GOT_SUBSCRIPT);


! Define the table of pointers to the parse tables for C.
!
LANGUAGE_TABLES(LANGUAGE = C,
		CHARTBL = C_CHARTBL,
		IDENT_OPTBL = C_IDENT_OPTBL,
		OPCHAR_OPTBL = C_OPCHAR_OPTBL,
		NUMBER_TABLE = C_NUMBER_TABLE,
		PRIMARY_TABLE = C_PRIMARY_TABLE,
		SUBSCR_TERMS = C_SUBSCR_TERM_TBL,
		PRIDTBL = C_PRID_TABLE,
		BIF_TABLE = C_FUNCTION_TABLE,
		MULTIPLE_SUBSCR = TRUE,
    		ENFORCE_RECORD = FALSE,
    		CASING_SIGNIFICANT = TRUE);

!			C O B O L   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the COBOL language.
!
!
! Define the COBOL Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(COBOL_CHARTBL,
    	CHAR_ENTRY('-', MINUS,  OPCHAR, ADDRESS_OP, IDENT_MIDDLE),
    	CHAR_ENTRY('0', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('1', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('2', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('3', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('4', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('5', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('6', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('7', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('8', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('9', DIGIT,	DIGIT, IDENT_ANYWHERE, NUMBER_START),
	CHAR_ENTRY('<', OTHER,  OPCHAR, OPCHAR_INFIX, ADDRESS_OP, TERMINATOR),
	CHAR_ENTRY('>', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('=', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('_', OTHER,	IDENT_ANYWHERE),
	CHAR_ENTRY('$', OTHER,  IDENT_ANYWHERE));


! Define the COBOL Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(COBOL_IDENT_OPTBL,
    	OPERATOR_ENTRY('OF',	DOT,		INFIX,	0, 0, PRIMARY),
    	OPERATOR_ENTRY('IN',	DOT,		INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('NOT',   NOT,            PREFIX, 200, 25),
	OPERATOR_ENTRY('AND',   AND,            INFIX,   20, 20),
    	OPERATOR_ENTRY('OR',    OR,             INFIX,   10, 10),
	OPERATOR_ENTRY('NOT',   INFIX_NOT,      INFIX,   30, 30, LEXICAL));

BIND
    	COBOL_NOT_EQL_TOKEN =
    	    OPERATOR_ENTRY('NOT =', NOT_EQUAL,      INFIX,   30, 30),
    	COBOL_NOT_GTR_TOKEN =
	    OPERATOR_ENTRY('NOT >', LSS_EQUAL,      INFIX,   30, 30),
    	COBOL_NOT_LSS_TOKEN =
	    OPERATOR_ENTRY('NOT <', GTR_EQUAL,      INFIX,   30, 30);


! Define the COBOL Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(COBOL_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
	OPERATOR_ENTRY('>',     PREFIX_GTR,     PREFIX, 200,  30, LEXICAL),
	OPERATOR_ENTRY('<',     PREFIX_LSS,     PREFIX, 200,  30, LEXICAL),
    	OPERATOR_ENTRY('=',	PREFIX_EQL,	PREFIX, 200,  30, LEXICAL),
	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX, 200,   5, LEXICAL),
	OPERATOR_ENTRY(')',     CLOSEPAREN,     POSTFIX,  6, 200, LEXICAL),
!	OPERATOR_ENTRY('**',    POWER_OF,       INFIX,   70,  70),
    	OPERATOR_ENTRY('*',     MULTIPLY,       INFIX,   60,  60),
    	OPERATOR_ENTRY('/',     DIVIDE,         INFIX,   60,  60),
	OPERATOR_ENTRY('+',     UNARY_PLUS,     PREFIX, 200,  50),
	OPERATOR_ENTRY('-',     UNARY_MINUS,    PREFIX, 200,  50),
	OPERATOR_ENTRY('+',     ADD,            INFIX,   40,  40),
	OPERATOR_ENTRY('-',     SUBTRACT,       INFIX,   40,  40),
	OPERATOR_ENTRY('>',     GTR_THAN,       INFIX,   30,  30),
	OPERATOR_ENTRY('<',     LSS_THAN,       INFIX,   30,  30),
	OPERATOR_ENTRY('=',     EQUAL,          INFIX,   30,  30));


! Define the COBOL Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(COBOL_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(')', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the COBOL Predefined Identifier Table.
!
PRID_TABLE(COBOL_PRID_TABLE);
    

! Define the COBOL Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(COBOL_FUNCTION_TABLE);


! Define the COBOL Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  Each Transition Entry is of the form:
!
!	NUMBER_TRANSITION(character-class, action-index, next-state)
!
! where the character-class and action-index names are automatically prefixed
! by "NUMST$K_CLASS_" or "NUMST$K_ACT_" by the NUMBER_TRANSITION macro.
!
NUMBER_STATE_TABLE(COBOL_NUMBER_TABLE,

    NUMBER_STATE(START_STATE,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK, ACCUM_INT),
	NUMBER_TRANSITION(DOT, DO_NOTHING, LEADING_DOT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(LEADING_DOT,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK_FRAC, ACCUM_FRAC),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK, ACCUM_INT),
	NUMBER_TRANSITION(DOT, DO_NOTHING, ACCUM_FRAC),
	NUMBER_TRANSITION(HEXDIGIT, COB_CKHEX, ACCUM_HEX),
	NUMBER_TRANSITION(B, COB_CKHEX, ACCUM_HEX),
	NUMBER_TRANSITION(D, COB_CKHEX, ACCUM_HEX),
	NUMBER_TRANSITION(E, COB_CKHEX, ACCUM_HEX),
	NUMBER_TRANSITION(OTHER, COB_CKNUM, END_STATE)),

    NUMBER_STATE(ACCUM_HEX,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(B, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(D, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(E, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(OTHER, COB_CKNUM, END_STATE)),

    NUMBER_STATE(ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK_FRAC, ACCUM_FRAC),
	NUMBER_TRANSITION(DOT, BACKUP_PTRS, END_STATE),
	NUMBER_TRANSITION(E, MARK_E_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(D, MARK_D_EXP, GET_EXPONENT),
    	NUMBER_TRANSITION(G, MARK_G_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(Q, MARK_Q_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, GOT_PACK_NUMBER, END_STATE)),

    NUMBER_STATE(GET_EXPONENT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(PLUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(MINUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(OTHER, BACKUP_PTRS, END_STATE)),

    NUMBER_STATE(GET_EXP_SIGN,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_EXP,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(END_STATE,
	NUMBER_TRANSITION(OTHER, GIVE_ERROR, END_STATE)));


! Define the Primary Parser State Table for language COBOL.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(COBOL_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT_COB, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR_PLI, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR_PLI, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
    	PRIMARY_TRANSITION(BACKSLASH, DOT_SLASH_COB, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, DOT_DOT_COB, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR_COB, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM_COB, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
    	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR_PLI, GOT_SUBSCRIPT2),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM_PLI, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT2,
    	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM_PLI, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for COBOL.
!
LANGUAGE_TABLES(LANGUAGE = COBOL,
		CHARTBL = COBOL_CHARTBL,
		IDENT_OPTBL = COBOL_IDENT_OPTBL,
		OPCHAR_OPTBL = COBOL_OPCHAR_OPTBL,
		NUMBER_TABLE = COBOL_NUMBER_TABLE,
		PRIMARY_TABLE = COBOL_PRIMARY_TABLE,
		SUBSCR_TERMS = COBOL_SUBSCR_TERM_TBL,
		PRIDTBL = COBOL_PRID_TABLE,
		BIF_TABLE = COBOL_FUNCTION_TABLE,
		MULTIPLE_SUBSCR = FALSE,
    		COMPONENTS_IN_PATHNAME = TRUE);

!			F O R T R A N   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse FORTRAN expressions.
!
!
!
! Define the FORTRAN Character Table.  What is listed here is actually a list
! of exceptions to the Character Table for language UNKNOWN.  (Language UNKNOWN
! lists the "average" use of each character in the character set.)
!
CHAR_EXCEPTION_TABLE(FORTRAN_CHARTBL,
	CHAR_ENTRY('.', DOT,	NUMBER_START, SPECIAL_SYMBOL),
	CHAR_ENTRY('/', OTHER,	OPCHAR, OPCHAR_INFIX));


! Define the FORTRAN Operator Table for operators whose names are identifiers.
! This table is empty since FORTRAN has no such operators, but the Lexical
! Scanner requires that such a table exist anyway.
!
OPERATOR_TABLE(FORTRAN_IDENT_OPTBL);


! Define the FORTRAN Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes those
! operators which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(FORTRAN_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	  0,   0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	  0,   0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,  0,   0, PRIMARY),
    	OPERATOR_ENTRY('.',     DOT,            INFIX,    0,   0, PRIMARY),
	OPERATOR_ENTRY('+',	ADD,		INFIX,	 60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	 60,  60),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX,	200,  70),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX,	200,  70),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	 80,  80),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	 80,  80),
	OPERATOR_ENTRY('**',	POWER_OF,	INFIX,	 92,  90),
	OPERATOR_ENTRY('//',	CONCATENATE,	INFIX,	 60,  60),
	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL));


BIND
    	FORTRAN_INDIRECT_TOKEN = OPERATOR_ENTRY('.',INDIRECT, PREFIX, 200, 40),
    	FORTRAN_DOT_TOKEN = OPERATOR_ENTRY('.', DOT, INFIX, 0, 0, PRIMARY);


! Define an Operator Table for FORTRAN operators of the form .XX. or .XXX.
! This includes all the FORTRAN comparison and boolean operators.
!
OPERATOR_TABLE(FORTRAN_SPECIAL_OPTBL,
	OPERATOR_ENTRY('.EQ.',	EQUAL,		INFIX,	 50, 50),
	OPERATOR_ENTRY('.NE.',	NOT_EQUAL,	INFIX,	 50, 50),
	OPERATOR_ENTRY('.GT.',	GTR_THAN,	INFIX,	 50, 50),
	OPERATOR_ENTRY('.GE.',	GTR_EQUAL,	INFIX,	 50, 50),
	OPERATOR_ENTRY('.LT.',	LSS_THAN,	INFIX,	 50, 50),
	OPERATOR_ENTRY('.LE.',	LSS_EQUAL,	INFIX,	 50, 50),
	OPERATOR_ENTRY('.NOT.',	NOT,		PREFIX,	200, 40),
	OPERATOR_ENTRY('.AND.',	AND,		INFIX,	 30, 30),
	OPERATOR_ENTRY('.OR.',	OR,		INFIX,	 20, 20),
	OPERATOR_ENTRY('.XOR.',	XOR,		INFIX,	 10, 10),
	OPERATOR_ENTRY('.EQV.',	EQV,		INFIX,	 10, 10),
	OPERATOR_ENTRY('.NEQV.',XOR,		INFIX,	 10, 10));


! Define the FORTRAN Terminator Lexical Token Table for subscript expressions.
! In FORTRAN, a subscript expression can be terminated by ")" (end of sub-
! scripts), by "," (more subscripts to follow), or by ":" (string subscript
! upper bound to follow).
!
TERMINATOR_TABLE(FORTRAN_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(')', TERM_CLOSE, BALANCED_PARENS),
	TERMINATOR_ENTRY(',', TERM_COMMA),
	TERMINATOR_ENTRY(':', TERM_COLON));


! Define the FORTRAN Predefined Identifier Table.
!
PRID_TABLE(FORTRAN_PRID_TABLE,
	PRID_ENTRY('.TRUE.', ATOMIC, L, 1),
	PRID_ENTRY('.FALSE.', ATOMIC, L, 0));


! Define the FORTRAN Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(FORTRAN_FUNCTION_TABLE);


! Define the FORTRAN Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! The FORTRAN number table is the same as the number table for language UNKNOWN.
!
BIND
    FORTRAN_NUMBER_TABLE = UNKNOWN_NUMBER_TABLE;


! Define the Primary Parser State Table for language FORTRAN.  Each Transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(FORTRAN_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
    	PRIMARY_TRANSITION(DOT, START_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
    	PRIMARY_TRANSITION(DOT, DOT_DOT, GOT_DOT),
    	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
    	PRIMARY_TRANSITION(DOT, SUBSCR_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for FORTRAN.
!
LANGUAGE_TABLES(LANGUAGE = FORTRAN,
		CHARTBL = FORTRAN_CHARTBL,
		IDENT_OPTBL = FORTRAN_IDENT_OPTBL,
		OPCHAR_OPTBL = FORTRAN_OPCHAR_OPTBL,
		NUMBER_TABLE = FORTRAN_NUMBER_TABLE,
		PRIMARY_TABLE = FORTRAN_PRIMARY_TABLE,
		SUBSCR_TERMS = FORTRAN_SUBSCR_TERM_TBL,
		PRIDTBL = FORTRAN_PRID_TABLE,
		BIF_TABLE = FORTRAN_FUNCTION_TABLE);

!			M A C R O   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the MACRO language.
!
!
!
! Define the MACRO Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(MACRO_CHARTBL,
    	CHAR_ENTRY('_', OTHER, IDENT_ANYWHERE),
    	CHAR_ENTRY('$', OTHER, IDENT_ANYWHERE),
    	CHAR_ENTRY('.', DOT,   NUMBER_START, OPCHAR, ADDRESS_OP, SPECIAL_SYMBOL,
    			       IDENT_MIDDLE, IDENT_END),
	CHAR_ENTRY('<', OTHER, OPCHAR, ADDRESS_OP),
	CHAR_ENTRY('>', OTHER, TERMINATOR));


! Define the MACRO Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(MACRO_IDENT_OPTBL,
	OPERATOR_ENTRY('EQL',	EQUAL,		INFIX,   50,  50),
	OPERATOR_ENTRY('EQLU',	EQUAL,		INFIX,	 50,  50),
	OPERATOR_ENTRY('NEQ',	NOT_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('NEQU',	NOT_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('GTR',	GTR_THAN,	INFIX,   50,  50),
	OPERATOR_ENTRY('GTRU',	GTR_THAN_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('GEQ',	GTR_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('GEQU',	GTR_EQUAL_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('LSS',	LSS_THAN,	INFIX,   50,  50),
	OPERATOR_ENTRY('LSSU', 	LSS_THAN_U,	INFIX,	 50,  50),
	OPERATOR_ENTRY('LEQ',	LSS_EQUAL,	INFIX,   50,  50),
	OPERATOR_ENTRY('LEQU',	LSS_EQUAL_U,	INFIX,   50,  50),
	OPERATOR_ENTRY('NOT',	BIT_NOT,	PREFIX, 200,  40),
	OPERATOR_ENTRY('AND',	BIT_AND,	INFIX,   30,  30),
	OPERATOR_ENTRY('OR',	BIT_OR,		INFIX,   20,  20),
	OPERATOR_ENTRY('EQV',	BIT_EQV,	INFIX,   10,  10),
	OPERATOR_ENTRY('XOR',	BIT_XOR,	INFIX,   10,  10),
	OPERATOR_ENTRY('MOD',	REMAINDER,	INFIX,   70,  70));


! Define the MACRO Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(MACRO_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),

	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),
	OPERATOR_ENTRY('<',	BITSELECT,	POSTFIX,110, 200, LEXICAL),
        OPERATOR_ENTRY('.',	INDIRECT,	PREFIX, 200, 100),
	OPERATOR_ENTRY('@',	INDIRECT,	PREFIX, 200, 100),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX, 200,  90),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX, 200,  90),
	OPERATOR_ENTRY('@',	LEFT_SHIFT,	INFIX,   80,  80),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,   70,  70),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,   70,  70),
	OPERATOR_ENTRY('+',	ADD,		INFIX,   60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,   60,  60)
	);


! Define the MACRO Terminator Lexical Token Table for subscript expressions.
! Since MACRO does not have subscripting, this table is empty.
!
TERMINATOR_TABLE(MACRO_SUBSCR_TERM_TBL);


! Define the MACRO Predefined Identifer Table.
!
PRID_TABLE(MACRO_PRID_TABLE);


! Define the MACRO Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(MACRO_FUNCTION_TABLE);


! Define the MACRO Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! The MACRO number table is the same as the number table for language UNKNOWN.
!
BIND
    MACRO_NUMBER_TABLE = UNKNOWN_NUMBER_TABLE;


! Define the Primary Parser State Table for language MACRO.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(MACRO_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for MACRO.
!
LANGUAGE_TABLES(LANGUAGE = MACRO,
		CHARTBL = MACRO_CHARTBL,
		IDENT_OPTBL = MACRO_IDENT_OPTBL,
		OPCHAR_OPTBL = MACRO_OPCHAR_OPTBL,
		NUMBER_TABLE = MACRO_NUMBER_TABLE,
		PRIMARY_TABLE = MACRO_PRIMARY_TABLE,
		SUBSCR_TERMS = MACRO_SUBSCR_TERM_TBL,
		PRIDTBL = MACRO_PRID_TABLE,
		BIF_TABLE = MACRO_FUNCTION_TABLE);

!			P A S C A L   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the PASCAL language.
!
!
!
! Define the PASCAL Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(PASCAL_CHARTBL,
	CHAR_ENTRY('<', OTHER,  OPCHAR, OPCHAR_INFIX, ADDRESS_OP),
	CHAR_ENTRY('=', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('>', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('^', OTHER,  OPCHAR, SPECIAL_SYMBOL),
	CHAR_ENTRY('.', DOT,    NUMBER_START, OPCHAR, ADDRESS_OP, SPECIAL_SYMBOL, TERMINATOR),
	CHAR_ENTRY('[', OTHER,	OPCHAR),
	CHAR_ENTRY(']', OTHER,  TERMINATOR));


! Define the PASCAL Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(PASCAL_IDENT_OPTBL,
	OPERATOR_ENTRY('DIV',  INT_DIVIDE,	INFIX,	 70,  70),
	OPERATOR_ENTRY('MOD',  MODULUS, 	INFIX,   70,  70),
	OPERATOR_ENTRY('REM',  REMAINDER,	INFIX,   70,  70),
	OPERATOR_ENTRY('AND',  AND,	 	INFIX,   70,  70),
	OPERATOR_ENTRY('OR',   OR,		INFIX,   60,  60),
	OPERATOR_ENTRY('NOT',  NOT,	 	PREFIX, 200,  90),
	OPERATOR_ENTRY('IN',   SET_MEMBER,	INFIX,   50,  50));


! Define the PASCAL Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(PASCAL_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('[',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
	OPERATOR_ENTRY('.',	DOT,		INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('^',	PASCAL_DEREF,	POSTFIX,0, 0, PRIMARY),
	OPERATOR_ENTRY('(',	BIF_OP,		POSTFIX, 0, 0, PRIMARY),

	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX,	200,   5, LEXICAL),
	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),
	OPERATOR_ENTRY('[',	OPENSET,	PREFIX, 200,   5, LEXICAL),
	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX, 200,  60),
	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX,	200,  60),
	OPERATOR_ENTRY('**',	POWER_OF,	INFIX,	 80,  80),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	 70,  70),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	 70,  70),
	OPERATOR_ENTRY('+',	ADD,		INFIX,	 60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	 60,  60),
	OPERATOR_ENTRY('<',	LSS_THAN,	INFIX,	 50,  50),
	OPERATOR_ENTRY('<=',	LSS_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('>',	GTR_THAN,	INFIX,	 50,  50),
	OPERATOR_ENTRY('>=',	GTR_EQUAL,	INFIX,	 50,  50),
	OPERATOR_ENTRY('=',	EQUAL,		INFIX,	 50,  50),
	OPERATOR_ENTRY('<>',	NOT_EQUAL,	INFIX,	 50,  50));


! Define the PASCAL Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(PASCAL_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(']', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the PASCAL Predefined Identifier Table.
!
PRID_TABLE(PASCAL_PRID_TABLE,
	PRID_ENTRY('TRUE', ATOMIC, TF, 1),
	PRID_ENTRY('FALSE', ATOMIC, TF, 0),
    	PRID_ENTRY('NIL', TPTR, Z, 0));


! Define the PASCAL Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(PASCAL_FUNCTION_TABLE);


! Define the PASCAL Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! The PASCAL number table is the same as the number table for language UNKNOWN.
!
BIND
    PASCAL_NUMBER_TABLE = UNKNOWN_NUMBER_TABLE;


! Define the Primary Parser State Table for language PASCAL.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(PASCAL_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, START_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(BIF_OP, START_BIF_CALL, END_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, SLASH_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, SLASH_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
	PRIMARY_TRANSITION(DOT, DOT_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, DOT_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(DOT, SUBSCR_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, SUBSCR_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DEREF,
	PRIMARY_TRANSITION(DOT, DEREF_DOT, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DEREF_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PASCAL_DEREF, DEREF_DEREF, GOT_DEREF),
	PRIMARY_TRANSITION(PRIMARY_TERM, DEREF_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for PASCAL.
!
LANGUAGE_TABLES(LANGUAGE = PASCAL,
		CHARTBL = PASCAL_CHARTBL,
		IDENT_OPTBL = PASCAL_IDENT_OPTBL,
		OPCHAR_OPTBL = PASCAL_OPCHAR_OPTBL,
		NUMBER_TABLE = PASCAL_NUMBER_TABLE,
		PRIMARY_TABLE = PASCAL_PRIMARY_TABLE,
		SUBSCR_TERMS = PASCAL_SUBSCR_TERM_TBL,
		PRIDTBL = PASCAL_PRID_TABLE,
		BIF_TABLE = PASCAL_FUNCTION_TABLE,
		MULTIPLE_SUBSCR = TRUE);

!			P L / I   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the PL/I language.
!
!
!
! Define the PL/I Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(PLI_CHARTBL,
	CHAR_ENTRY('$',	OTHER,	IDENT_ANYWHERE),
	CHAR_ENTRY('_',	OTHER,	IDENT_ANYWHERE),
	CHAR_ENTRY('%', OTHER,	IDENT_MIDDLE),
	CHAR_ENTRY('&',	OTHER,	OPCHAR),
	CHAR_ENTRY('|',	OTHER,	OPCHAR,	OPCHAR_INFIX),
	CHAR_ENTRY('!',	OTHER,	OPCHAR,	OPCHAR_INFIX),
	CHAR_ENTRY('=',	OTHER,	OPCHAR,	OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('^',	OTHER,	OPCHAR,	OPCHAR_INFIX, SPECIAL_SYMBOL),
    	CHAR_ENTRY('-', MINUS,	OPCHAR, ADDRESS_OP, SPECIAL_CASE),
	CHAR_ENTRY('<',	OTHER,	OPCHAR,	OPCHAR_INFIX, ADDRESS_OP),
    	CHAR_ENTRY('>', OTHER,	OPCHAR, OPCHAR_INFIX, TERMINATOR));


! Define the PL/I Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(PLI_IDENT_OPTBL);


! Define the PL/I Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(PLI_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
	OPERATOR_ENTRY('.',	DOT,		INFIX,	0, 0, PRIMARY),

    	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX, 200,   5, LEXICAL),
    	OPERATOR_ENTRY(')',	CLOSEPAREN,	POSTFIX,  6, 200, LEXICAL),
    	OPERATOR_ENTRY('+',	UNARY_PLUS,	PREFIX, 200, 70),
    	OPERATOR_ENTRY('-',	UNARY_MINUS,	PREFIX, 200, 70),
	OPERATOR_ENTRY('^',	BIT_NOT,	PREFIX,	200, 30),
	OPERATOR_ENTRY('**',	POWER_OF,	INFIX,	92,  90),
	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,	80,  80),
	OPERATOR_ENTRY('/',	DIVIDE,		INFIX,	80,  80),
	OPERATOR_ENTRY('+',	ADD,		INFIX,	60,  60),
	OPERATOR_ENTRY('-',	SUBTRACT,	INFIX,	60,  60),
	OPERATOR_ENTRY('||',	CONCATENATE,	INFIX,	55,  55),
	OPERATOR_ENTRY('>',	GTR_THAN,	INFIX,	50,  50),
	OPERATOR_ENTRY('<',	LSS_THAN,	INFIX,	50,  50),
	OPERATOR_ENTRY('^>',	LSS_EQUAL,	INFIX,	50,  50),
	OPERATOR_ENTRY('^<',	GTR_EQUAL,	INFIX,	50,  50),
	OPERATOR_ENTRY('=',	EQUAL,		INFIX,	50,  50),
	OPERATOR_ENTRY('^=',	NOT_EQUAL,	INFIX,	50,  50),
	OPERATOR_ENTRY('<=',	LSS_EQUAL,	INFIX,	50,  50),
	OPERATOR_ENTRY('>=',	GTR_EQUAL,	INFIX,	50,  50),
	OPERATOR_ENTRY('&',	BIT_AND,	INFIX,	45,  45),
	OPERATOR_ENTRY('|',	BIT_OR,		INFIX,	40,  40));


! Define the Lexical Token Entry for the PL/I dereference operator "->".
! This token is lexically scanned separately.
!
BIND
    PLI_ARROW_TOKEN =
	OPERATOR_ENTRY('->',	PLI_DEREF,	INFIX,  0, 0, PRIMARY);


! Define the PL/I Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(PLI_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(')', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the PL/I Predefined Identifier Table.
!
PRID_TABLE(PLI_PRID_TABLE);
    

! Define the PLI Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(PLI_FUNCTION_TABLE);


! Define the PLI Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  
!
! Define the language PLI Number Scanner State Table. This is a finite-state
! machine in which each transition is of the form:
!
!	NUMBER_TRANSITION(character-class, action-index, next-state)
!
! where the character-class and action-index names are automatically prefixed
! by "NUMST$K_CLASS_" or "NUMST$K_ACT_" by the NUMBER_TRANSITION macro.
!
NUMBER_STATE_TABLE(PLI_NUMBER_TABLE,

    NUMBER_STATE(START_STATE,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK, ACCUM_INT),
	NUMBER_TRANSITION(DOT, DO_NOTHING, LEADING_DOT),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(LEADING_DOT,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK_FRAC, ACCUM_FRAC),
	NUMBER_TRANSITION(OTHER, NOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_INT,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK, ACCUM_INT),
	NUMBER_TRANSITION(DOT, DO_NOTHING, ACCUM_FRAC),
	NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(B, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(D, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(E, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(OTHER, GOT_PACK_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_HEX,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(HEXDIGIT, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(B, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(D, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(E, DO_NOTHING, ACCUM_HEX),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_FRAC,
	NUMBER_TRANSITION(DIGIT, GO_PAST_PACK_FRAC, ACCUM_FRAC),
	NUMBER_TRANSITION(DOT, BACKUP_PTRS, END_STATE),
	NUMBER_TRANSITION(E, MARK_E_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(D, MARK_D_EXP, GET_EXPONENT),
    	NUMBER_TRANSITION(G, MARK_G_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(Q, MARK_Q_EXP, GET_EXPONENT),
	NUMBER_TRANSITION(OTHER, GOT_PACK_NUMBER, END_STATE)),

    NUMBER_STATE(GET_EXPONENT,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(PLUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(MINUS, DO_NOTHING, GET_EXP_SIGN),
	NUMBER_TRANSITION(OTHER, BACKUP_PTRS, END_STATE)),

    NUMBER_STATE(GET_EXP_SIGN,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(ACCUM_EXP,
	NUMBER_TRANSITION(DIGIT, DO_NOTHING, ACCUM_EXP),
	NUMBER_TRANSITION(OTHER, GOT_NUMBER, END_STATE)),

    NUMBER_STATE(END_STATE,
	NUMBER_TRANSITION(OTHER, GIVE_ERROR, END_STATE)));


! Define the Primary Parser State Table for language PL/I.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(PLI_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, START_DOT_PLI, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR_PLI, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, START_DEREF_PLI, START_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(DOT, SLASH_DOT_PLI, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR_PLI, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, SLASH_DEREF_PLI, START_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_DOT,
	PRIMARY_TRANSITION(DOT, DOT_DOT_PLI, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, DOT_SUBSCR_PLI, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, DOT_DEREF_PLI, START_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, DOT_TERM_PLI, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
	PRIMARY_TRANSITION(DOT, SUBSCR_DOT_PLI, GOT_DOT),
	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR_PLI, GOT_SUBSCRIPT),
    	PRIMARY_TRANSITION(PLI_DEREF, SUBSCR_DEREF_PLI, START_STATE),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM_PLI, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for PL/I.
!
LANGUAGE_TABLES(LANGUAGE = PLI,
		CHARTBL = PLI_CHARTBL,
		IDENT_OPTBL = PLI_IDENT_OPTBL,
		OPCHAR_OPTBL = PLI_OPCHAR_OPTBL,
		NUMBER_TABLE = PLI_NUMBER_TABLE,
		PRIMARY_TABLE = PLI_PRIMARY_TABLE,
		SUBSCR_TERMS = PLI_SUBSCR_TERM_TBL,
		PRIDTBL = PLI_PRID_TABLE,
		BIF_TABLE = PLI_FUNCTION_TABLE,
		MULTIPLE_SUBSCR = FALSE,
    		COMPONENTS_IN_PATHNAME = TRUE);

!			R P G   P A R S E   T A B L E S
!
!
!
!	This section includes all the Lexical Scanner and Parser tables needed
!	to scan and parse the RPG language.
!
!
! Define the RPG Character Table.  What is listed here is actually a list of
! exceptions to the Character Table for Language UNKNOWN.
!
CHAR_EXCEPTION_TABLE(RPG_CHARTBL,
	CHAR_ENTRY('*', OTHER,  NOTHING),
	CHAR_ENTRY('<', OTHER,  OPCHAR, OPCHAR_INFIX, ADDRESS_OP, TERMINATOR),
	CHAR_ENTRY('>', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('=', OTHER,  OPCHAR, OPCHAR_INFIX, TERMINATOR),
	CHAR_ENTRY('#', OTHER,	IDENT_ANYWHERE),
	CHAR_ENTRY('_', OTHER,	IDENT_ANYWHERE),
	CHAR_ENTRY('$', OTHER,  IDENT_ANYWHERE));


! Define the RPG Operator Table for operators whose names are identifiers.
!
OPERATOR_TABLE(RPG_IDENT_OPTBL,
	OPERATOR_ENTRY('NOT',   NOT,            PREFIX, 200, 11),
	OPERATOR_ENTRY('AND',   AND,            INFIX,   10, 10),
	OPERATOR_ENTRY('OR',    OR,             INFIX,   10, 10),
	OPERATOR_ENTRY('NOT',   INFIX_NOT,      INFIX,   15, 15, LEXICAL));

BIND
    	RPG_NOT_EQL_TOKEN =
    	    OPERATOR_ENTRY('NOT =', NOT_EQUAL,      INFIX,   15, 15),
    	RPG_NOT_GTR_TOKEN =
	    OPERATOR_ENTRY('NOT >', LSS_EQUAL,      INFIX,   15, 15),
    	RPG_NOT_LSS_TOKEN =
	    OPERATOR_ENTRY('NOT <', GTR_EQUAL,      INFIX,   15, 15);


! Define the RPG Operator Table for operators whose names are composed of
! operator characters such as "+", "-", or "*".  This table includes operators
! which are part of DEBUG Primary Symbols (such as "\").
!
OPERATOR_TABLE(RPG_OPCHAR_OPTBL,
	OPERATOR_ENTRY('\',	GLOBAL_SLASH,	PREFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('\',	BACKSLASH,	INFIX,	0, 0, PRIMARY),
	OPERATOR_ENTRY('(',	SUBSCRIPT,	POSTFIX,0, 0, PRIMARY),
	OPERATOR_ENTRY('>',     PREFIX_GTR,     PREFIX, 200,  15, LEXICAL),
	OPERATOR_ENTRY('<',     PREFIX_LSS,     PREFIX, 200,  15, LEXICAL),
    	OPERATOR_ENTRY('=',	PREFIX_EQL,	PREFIX, 200,  15, LEXICAL),
	OPERATOR_ENTRY('(',	OPENPAREN,	PREFIX, 200,   5, LEXICAL),
	OPERATOR_ENTRY(')',     CLOSEPAREN,     POSTFIX,  6, 200, LEXICAL),
    	OPERATOR_ENTRY('/',     DIVIDE,         INFIX,   30,  30),
	OPERATOR_ENTRY('+',     UNARY_PLUS,     PREFIX, 200,  25),
	OPERATOR_ENTRY('-',     UNARY_MINUS,    PREFIX, 200,  25),
	OPERATOR_ENTRY('+',     ADD,            INFIX,   20,  20),
	OPERATOR_ENTRY('-',     SUBTRACT,       INFIX,   20,  20),
	OPERATOR_ENTRY('>',     GTR_THAN,       INFIX,   15,  15),
	OPERATOR_ENTRY('<',     LSS_THAN,       INFIX,   15,  15),
	OPERATOR_ENTRY('=',     EQUAL,          INFIX,   15,  15));

BIND
    RPG_MULTIPLY_TOKEN =
    	OPERATOR_ENTRY('*',	MULTIPLY,	INFIX,   30,  30);


! Define the RPG Terminator Lexical Token Table for subscript expressions.
!
TERMINATOR_TABLE(RPG_SUBSCR_TERM_TBL,
	TERMINATOR_ENTRY(')', TERM_CLOSE),
	TERMINATOR_ENTRY(':', TERM_COLON, MUST_BE_SINGLE),
	TERMINATOR_ENTRY(',', TERM_COMMA));


! Define the RPG Predefined Identifier Table.
!
PRID_TABLE(RPG_PRID_TABLE);
    

! Define the RPG Built-in Function Table.
!
BUILT_IN_FUNCTION_TABLE(RPG_FUNCTION_TABLE);


! Define the RPG Number Scanner State Table.  This table defines the states
! of a Finite-State Machine which picks up all valid numeric constants in the
! language.  Each Transition Entry is of the form:
!
!	NUMBER_TRANSITION(character-class, action-index, next-state)
!
! where the character-class and action-index names are automatically prefixed
! by "NUMST$K_CLASS_" or "NUMST$K_ACT_" by the NUMBER_TRANSITION macro.
!
BIND
    RPG_NUMBER_TABLE = PLI_NUMBER_TABLE;


! Define the Primary Parser State Table for language RPG.  Each transition
! Entry in the state table has this format:
!
!	PRIMARY_TRANSITION(operator-code, action, next-state)
!
! where the first parameter is the operator code which causes the transition
! to be taken, the second parameter is the action routine CASE index for the
! transition, and the third parameter is the next state in the Finite-State
! Machine.
!
PRIMARY_STATE_TABLE(RPG_PRIMARY_TABLE,

    PRIMARY_STATE(START_STATE,
	PRIMARY_TRANSITION(GLOBAL_SLASH, START_GBL, GET_GLOBAL),
	PRIMARY_TRANSITION(BACKSLASH, START_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(SUBSCRIPT, START_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, START_TERM, END_STATE)),

    PRIMARY_STATE(GET_GLOBAL,
	PRIMARY_TRANSITION(PRIMARY_TERM, GBL_TERM, END_STATE)),

    PRIMARY_STATE(GOT_BACKSLASH,
	PRIMARY_TRANSITION(BACKSLASH, SLASH_SLASH, GOT_BACKSLASH),
	PRIMARY_TRANSITION(INVOCNUM, SLASH_INVOCNUM, GOT_BACKSLASH),
	PRIMARY_TRANSITION(SUBSCRIPT, SLASH_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SLASH_TERM, END_STATE)),

    PRIMARY_STATE(GOT_SUBSCRIPT,
    	PRIMARY_TRANSITION(SUBSCRIPT, SUBSCR_SUBSCR, GOT_SUBSCRIPT),
	PRIMARY_TRANSITION(PRIMARY_TERM, SUBSCR_TERM, END_STATE)),

    PRIMARY_STATE(END_STATE));


! Define the table of pointers to the parse tables for RPG.
!
LANGUAGE_TABLES(LANGUAGE = RPG,
		CHARTBL = RPG_CHARTBL,
		IDENT_OPTBL = RPG_IDENT_OPTBL,
		OPCHAR_OPTBL = RPG_OPCHAR_OPTBL,
		NUMBER_TABLE = RPG_NUMBER_TABLE,
		PRIMARY_TABLE = RPG_PRIMARY_TABLE,
		SUBSCR_TERMS = RPG_SUBSCR_TERM_TBL,
		PRIDTBL = RPG_PRID_TABLE,
		BIF_TABLE = PASCAL_FUNCTION_TABLE);

!	T A B L E   O F   P O I N T E R S   T O   L A N G U A G E   T A B L E S
!
!
!
!	This section contains the table of pointers to the language-specific
!	tables of parser table pointers.  In other words, this table in indexed
!	by language code to yield a pointer (relative to TABLEBASE) to the
!	table of table pointers built by the LANGUAGE_TABLES macro for the
!	individual language above.
!
!
! Define the table of pointers to language-specific tables.
!
OWN
    LANGUAGE_TABLE_PTRS:
		VECTOR[DBG$K_MAX_LANGUAGE + 1, LONG] PSECT(DBG$PLIT) PRESET(

	[DBG$K_MACRO]	= MACRO_TABLES   - TABLEBASE,	! MACRO
	[DBG$K_FORTRAN]	= FORTRAN_TABLES - TABLEBASE,	! FORTRAN
	[DBG$K_BLISS]	= BLISS_TABLES   - TABLEBASE,	! BLISS
	[DBG$K_COBOL]	= COBOL_TABLES   - TABLEBASE,	! COBOL
	[DBG$K_BASIC]	= BASIC_TABLES   - TABLEBASE,	! BASIC
	[DBG$K_PLI]	= PLI_TABLES     - TABLEBASE,	! PL/I
	[DBG$K_PASCAL]	= PASCAL_TABLES  - TABLEBASE,	! PASCAL
	[DBG$K_C]	= C_TABLES       - TABLEBASE,	! C
	[DBG$K_RPG]	= RPG_TABLES     - TABLEBASE,	! RPG
	[DBG$K_ADA]	= ADA_TABLES     - TABLEBASE,	! ADA
	[DBG$K_UNKNOWN]	= UNKNOWN_TABLES - TABLEBASE);	! UNKNOWN

ROUTINE AAA_DUMMY: NOVALUE =
!
! FUNCTION
!	This is a dummy routine which is never called.  Its sole purpose is
!	to force out the machine listing for all the above data tables before
!	the source listing for the first real routine in the module.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    RETURN;

    END;

GLOBAL ROUTINE DBG$ADDR_EXP_INT(INPUT_DESC, ADDR_EXP_PTR, TYPE, LENGTH,
						RADIX, TERM_INDEX) =
!
! FUNCTION
!	This is the Address Expression Interpreter for most languages
!	supported by DEBUG.  It parses and evaluates a DEBUG address
!	expression and returns an Address Expression Descriptor which
!	represents the value of the expression.  This routine itself is
!	only a set-up routine which sets up the character pointer and
!	the expression radix to use and then calls DBG$EXPRESSION_PARSER
!	to do the actual work.
!
! INPUTS
!	INPUT_DESC - A string descriptor which points to the input string to be
!		  parsed as an Address Expression.  Only the pointer field of
!		  this descriptor is actually used--the string is expected to
!		  terminated by a carriage-return character.
!
!	ADDR_EXP_PTR - The address of a longword location to receive a pointer
!		  to a Primary or Value Descriptor returned by this routine.
!
!	TYPE	- The address of a longword location to receive the address
!		  "type", namely instruction or not instruction.
!
!	LENGTH	- The address of a longword location to receive the length of
!		  the current instruction if the "type" is instruction.
!
!	RADIX	- The radix to be used to interpret integer numbers.  The al-
!		  lowed radix values are DBG$K_DECIMAL, DBG$K_HEX, DBG$K_OCTAL,
!		  and DBG$K_BINARY.
!
!	TERM_INDEX - A "terminator index" which indicates which lexical tokens
!		  are allowed as expression terminators in this context.  For
!		  example, in the EXAMINE command, "," and ":" are allowed
!		  terminators and in the DEPOSIT command, "=" is the allowed
!		  terminator.  These index values have names of the form
!		  TOKEN$K_TERM_xxx.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the address expression just parsed.
!		  If the parse was stopped by a terminator token, the input
!		  string descriptor will point to that token on return.
!
!	ADDR_EXP_PTR - A Primary or Value Descriptor is constructed and a
!		  pointer to that descriptor is returned to ADDR_EXP_PTR.
!
!	TYPE	- If the address expression yields an instruction address, the
!		  value DBG$K_INSTRUCTION is returned to TYPE.  Otherwise, the
!		  value DBG$K_NOTYPE is returned to TYPE.
!
!	LENGTH	- If the value DBG$K_INSTRUCTION is returned to TYPE, the
!		  length in bytes of the instruction pointed to by the address
!		  expression is returned to LENGTH.  Otherwise, 0 is returned.
!
!	The value STS$K_SUCCESS is return as the routine result if the expres-
!		  sion was terminated by a carriage-return character.  If it
!		  was terminated any other way (i.e., by a terminator token),
!		  the value STS$K_WARNING is returned.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	ADDR_EXP_PTR: REF VECTOR[1],	! Longword to receive address of a
					!      Primary or Value Descriptor
	TYPE: REF VECTOR[1],		! Longword to receive type code value
	LENGTH: REF VECTOR[1];		! Longword to receive length value



    ! Set up CHARPTR to point to the start of the expression string.  Also set
    ! up the radix we are to use in the scan and initialize some variables.
    !
    CHARPTR = .INPUT_DESC[DSC$A_POINTER];
    EXPRESSION_RADIX = .RADIX;
    SAVED_TOKEN = 0;


    ! Set the address "type" and "length" to indicate "no type".  These values
    ! may be changed to "instruction" if the Expression Parser finds that the
    ! address expression points to an instruction address.  (This allows DEBUG
    ! to automatically display instruction locations as instructions.)
    !
    ADDRESS_TYPE = DBG$K_NOTYPE;
    ADDRESS_LENGTH = 0;


    ! Call the Expression Parser to parse the address expression.  Then fix up
    ! the string descriptor to reflect the new location of the parse pointer,
    ! return the address type and length values, and return the appropriate
    ! status code.
    !
    ADDR_EXP_PTR[0] = DBG$EXPRESSION_PARSER(TRUE,
				.TERM_POINTER_TBL[.TERM_INDEX] + TABLEBASE);
    INPUT_DESC[DSC$W_LENGTH] = .INPUT_DESC[DSC$W_LENGTH] +
				.INPUT_DESC[DSC$A_POINTER] - .CHARPTR;
    INPUT_DESC[DSC$A_POINTER] = .CHARPTR;
    TYPE[0] = .ADDRESS_TYPE;
    LENGTH[0] = .ADDRESS_LENGTH;
    IF .CHARPTR[0] NEQ CAR_RET THEN RETURN STS$K_WARNING;
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$BUILD_PRIMARY_SUBNODE(PRIMPTR, KIND, SYMID, 
					 FCODE, TYPEID, DSTPTR): NOVALUE =
!
! FUNCTION
!	This routine constructs a Primary Descriptor Sub-Node for a specified
!	symbol and appends this sub-node to a specified Primary Descriptor.
!	If the symbol is an array or a record, an Array or Record Sub-Node is
!	constructed and the specific information needed for those data types
!	is filled in.  Otherwise, a Normal Sub-Node is constructed.
!
! INPUTS
!	PRIMPTR	- A pointer to the Root Node of the Primary Descriptor to
!		  which the Sub-Node should be appended.
!
!	KIND	- The KIND of the symbol for which the Primary Descriptor
!		  Sub-Node should be constructed.  This is the RST "kind"
!		  returned by DBG$STA_GETSYMBOL.
!
!	SYMID	- The SYMID of the symbol for which the Primary Descriptor
!		  Sub-Node should be constructed.  If there is no SYMID (as
!		  for an individual array element, for exmple), SYMID should
!		  be zero.
!
!	FCODE	- The FCODE ("format code") for the data type of the symbol for
!		  which the Primary Descriptor Sub-Node should be constructed.
!		  If the symbol is not a data items (i.e., if its KIND is not
!		  RST$K_DATA or RST$K_TYPCOMP), FCODE should be zero.
!
!	TYPEID	- The Type ID of the data item for which the Primary Descriptor
!		  Sub-Node should be constructed.  If the entity in question is
!		  not a data item, TYPEID should be zero.
!
!	DSTPTR	- A pointer to the DST record corresponding the the data item.
!		  This is used in the case of BLISS data to obtain the 
!		  information about what kind of BLISS structure this is.
!
! OUTPUTS
!	A Primary Descriptor Sub-Node is created and appended to the PRIMPTR
!		  Primary Descriptor.  PRIMPTR itself is not changed, however.
!		  There is no other output.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD,		! Pointer to DST record
	PRIMPTR: REF DBG$PRIMARY,	! Pointer to Primary Descriptor
	SYMID: REF RST$ENTRY;		! Pointer to symbol's RST entry

    BUILTIN
	INSQUE;				! Insert-Queue function

    LITERAL
	MAX_DIMS = 20;			! Maximum dimension count we allow

    LOCAL
	ATOMIC_TYPE,			! A dtype code
	BIT_LENGTH,			! Array element bit length
	BITSIZE,			! Array or record component bit-size
					!      (not actually used)
	BOUNDVEC: REF VECTOR[,LONG],	! Pointer to bounds vector in array
					!      descriptor
	CELLTYPE,			! TYPEID for array element cell type
	COMP_VEC,			! Record Component vector (not used)
	DIMVECPTR: REF VECTOR[,LONG],	! Pointer to vector of subscript TYPEIDs
	DSCADDR: REF BLOCK[,BYTE],	! Pointer to array descriptor
	HIGHPTR,			! Higher bound of the subrange value
    	LENGTH,				! Byte length of array element
	LOWPTR,				! Lower bound of the subrange value
	NCOMPS,				! Number of record components (not used)
	NDIMS,				! Number of array dimensions
	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to created Primary Sub-Node
	OFFSET,				! Computed offset for ARRAY[0,0,...,0]
	SIZE,				! Size in bits of the data type
	STRIDE: VECTOR[MAX_DIMS, LONG],	! Vector of strides computed from
					!      multipliers in array descriptor
	STRIDEPTR: REF VECTOR[,LONG],	! Pointer to stride or multiplier
					!      vector in array descriptor
	STRIDE_SIZE,			! Size of stride for BLISS vectors
	SUB_TYPEID: REF RST$ENTRY,	! Pointer to TYPEID RST entry
	SUBVECTOR:			! Pointer to subscript block-vector
		REF DBG$PRIM_NODE_SUBS,	!      in Primary Descr Array Sub-Node
    	TMP_SYMID: REF RST$ENTRY;	! Scratch SYMID

    LABEL
    	COMPUTE_STRIDES;


    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;

    ! Determine what kind of symbol this is and allocate the Sub-Node memory
    ! block accordingly.  If this symbol is an array or a record, we also must
    ! collect the special information needed for those data types and fill it
    ! into the Primary Descriptor Sub-Node.
    !
    CASE .FCODE FROM RST$K_TYPE_MINIMUM TO RST$K_TYPE_MAXIMUM OF
	SET


	! Handle arrays.  Determine the number of dimensions in the array and
	! allocate an Array Sub-Node large enough to hold that many dimensions.
	! Then fill in all the fields specific to the Array Sub-Node.
	!
	[RST$K_TYPE_ARRAY]:
	    BEGIN


	    ! Get all needed type information about the array type from
	    ! DBG$STA_TYP_ARRAY.  Allocate a memory block for the Array
	    ! Sub-Node and fill in the fields in the fixed part of that
	    ! Sub-Node.
	    !
	    DBG$STA_TYP_ARRAY(.TYPEID, DSCADDR, CELLTYPE,
						NDIMS, DIMVECPTR, BITSIZE);


    	    ! If we got a symid passed in to this routine, and the symid 
    	    ! represents an array, try calling SYMVALUE to get an array
    	    ! descriptor for this array. If we get one, then use this
    	    ! descriptor instead of the one we got back from STA_TYP_ARRAY.
    	    !
    	    ! Note - normally, these 2 descriptors will be the same.
    	    ! However, for dynamic arrays in PASCAL, the runtime descriptor
    	    ! (which we get back when we call SYMVALUE with the symid) is
    	    ! correct, but the compile-time descriptor (which is part of
    	    ! the typespec) is wrong. This code is a workaround for this
    	    ! problem in the PASCAL DST.
    	    !
    	    IF .SYMID NEQ 0
    	    THEN
    	        BEGIN
    	        LOCAL
    		    DESC: VECTOR[3],
    		    RSTPTR: REF RST$ENTRY,
    		    VALUE_KIND;
    	        RSTPTR = .SYMID;
    		WHILE .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
    		    RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
    		IF .RSTPTR[RST$B_LANGUAGE] EQL DBG$K_PASCAL
    		THEN
    		    BEGIN
    		    DBG$STA_SETCONTEXT(.SYMID);
    	            DBG$STA_SYMVALUE(.SYMID, DESC, VALUE_KIND);
    	            IF .VALUE_KIND EQL DBG$K_VAL_DESCR
    	            THEN
    		        DSCADDR = .DESC[0];
    		    END;
    	        END;

	    IF .NDIMS GTR MAX_DIMS THEN SIGNAL(DBG$_TOOMANDIM);
	    NODEPTR = DBG$GET_TEMPMEM(DBG$K_PRIM_SIZE_ARRAY +
						.NDIMS*DBG$K_PRIM_SIZE_SUBS);
	    NODEPTR[DBG$B_PNARR_DIMCNT] = .NDIMS;


    	    !*** The following is a temporary workaround to a problem in
    	    !*** the PASCAL DST: They are giving us array descriptors with
    	    !*** class UBA but dtype=0. Since dtype must be VU for this
    	    !*** class, we fill in the correct dtype here in this case.
    	    !
    	    IF .DSCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_UBA
    	    THEN
    		NODEPTR[DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_VU

    	    ELSE
    	    !*** End temporary workaround.

	        NODEPTR[DBG$B_PNARR_DTYPE] = .DSCADDR[DSC$B_DTYPE];

	    NODEPTR[DBG$W_PNARR_LENGTH] = .DSCADDR[DSC$W_LENGTH];
	    NODEPTR[DBG$B_PNARR_SCALE] = .DSCADDR[DSC$B_SCALE];
	    NODEPTR[DBG$B_PNARR_DIGITS] = .DSCADDR[DSC$B_DIGITS];
	    NODEPTR[DBG$V_PNARR_COLUMN] = .DSCADDR[DSC$V_FL_COLUMN];
	    NODEPTR[DBG$L_PNARR_CELLTYPE] = .CELLTYPE;


	    ! Set up pointers to the stride (or multiplier) vector and to the
	    ! bounds vector in the array descriptor.
	    !
	    STRIDEPTR = .DSCADDR + 20;
	    BOUNDVEC = .STRIDEPTR + 4*.NDIMS;


	    ! Determine what kind of array descriptor we have.  Determine
	    ! whether we have multipliers or strides and whether we are
	    ! doing byte or bit addressing.
	    !
	    CASE .DSCADDR[DSC$B_CLASS] FROM DSC$K_CLASS_S TO DSC$K_CLASS_UBA OF
		SET


		! Handle an ordinary Array Descriptor.  This descriptor has
		! byte multipliers.  Since we only allow strides in the Array
		! Sub-Node, we convert the array multipliers into strides here.
		! (Note that STRIDEPTR points to multipliers in this case.)
		!
		[DSC$K_CLASS_A]:
		    COMPUTE_STRIDES: BEGIN


    	    	    !*** Temporary workaround to a problem in the PL/I DST.
    	    	    !*** The multipliers that we are getting in the array
    	    	    !*** descriptors are not correct. They are giving us
    		    !*** strides instead of multipliers. So we skip the 
    		    !*** computation of strides if language is PL/I.
    	    	    !
    	    	    TMP_SYMID = .PRIMPTR[DBG$L_DHDR_SYMID0];
    	    	    IF .TMP_SYMID NEQ 0
    	    	    THEN
    			BEGIN
    	        	WHILE .TMP_SYMID[RST$B_KIND] NEQ RST$K_MODULE DO
        	    	    TMP_SYMID = .TMP_SYMID[RST$L_UPSCOPEPTR];
    	        	IF (.TMP_SYMID[RST$B_LANGUAGE] EQL DBG$K_PLI) AND
    			   (.TMP_SYMID[RST$V_OLDPLIFLAG])
    	        	THEN
    			    LEAVE COMPUTE_STRIDES;
    			END;


    		    ! Pick up the array element length in bytes.  We need this
    		    ! length to compute strides properly below.
    		    !
    		    LENGTH = DBG$DATA_LENGTH(.DSCADDR);
    		    LENGTH = (.LENGTH + 7)/8;


		    ! If this is a column-major order array, we compute the
		    ! array's stride values from its multiplier values.
		    !
		    IF .DSCADDR[DSC$V_FL_COLUMN]
		    THEN
			BEGIN
			STRIDE[0] = .LENGTH;
			INCR I FROM 1 TO .NDIMS - 1 DO
			    STRIDE[.I] = .STRIDE[.I - 1]*.STRIDEPTR[.I - 1];

			END


		    ! If this is a row-major order array, we compute the
		    ! strides in the opposite direction.
		    !
		    ELSE
			BEGIN
			STRIDE[.NDIMS - 1] = .LENGTH;
			DECR I FROM .NDIMS - 2 TO 0 DO
			    STRIDE[.I] = .STRIDE[.I + 1]*.STRIDEPTR[.I + 1];

			END;


		    ! Make STRIDEPTR point to the newly computed stride vector.
		    !
		    STRIDEPTR = STRIDE[0];
		    END;


		! Handle a Noncontiguous Array Descriptor or a Varying String
		! Descriptor.  Here we already have byte strides instead of
		! multipliers so there is nothing we need to do.
		!
		[DSC$K_CLASS_NCA,
		 DSC$K_CLASS_VSA]:
		    0;


		! Handle an Unaligned Bit Array Descriptor.  This descriptor
		! is like the Noncontiguous Array Descriptor except that it has
		! bit strides instead of byte strides.
		!
		[DSC$K_CLASS_UBA]:
		    NODEPTR[DBG$V_PNARR_BITREF] = TRUE;


		! Any other case constitutes an invalid array descriptor.
		! Signal an error message.
		!
		[INRANGE, OUTRANGE]:
		    SIGNAL(DBG$_INVARRDSC);

		TES;


	    ! Loop through the dimensions of the array to set up the subscript
	    ! block-vector in the Array Sub-Node.  In that vector, we set the
	    ! subscript value to be the same as the lower bound--this is changed
	    ! later when the actual subscript value is picked up.  The lower and
	    ! upper bounds, the stride, and the subscript type TYPEID are all
	    ! picked up and stored away as well.
	    !
	    SUBVECTOR = NODEPTR[DBG$A_PNARR_SVECTOR];
	    OFFSET = 0;
	    INCR I FROM 0 TO .NDIMS - 1 DO
		BEGIN
		SUBVECTOR[.I, DBG$L_PNSUB_SVALUE] = .BOUNDVEC[2*.I];
		SUBVECTOR[.I, DBG$L_PNSUB_STRIDE] = .STRIDEPTR[.I];
		SUBVECTOR[.I, DBG$L_PNSUB_LBOUND] = .BOUNDVEC[2*.I];
		SUBVECTOR[.I, DBG$L_PNSUB_UBOUND] = .BOUNDVEC[2*.I + 1];

    		SUB_TYPEID = 0;
		IF .DIMVECPTR[.I] NEQ 0
		THEN
		    BEGIN
		    SUB_TYPEID = .DIMVECPTR[.I];
		    WHILE .SUB_TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
			DBG$STA_TYP_SUBRNG(.SUB_TYPEID,SUB_TYPEID,LOWPTR,HIGHPTR,SIZE);

		    SUBVECTOR[.I, DBG$L_PNSUB_TYPEID] = .SUB_TYPEID;
		    END

		ELSE
		    SUBVECTOR[.I, DBG$L_PNSUB_TYPEID] = .DIMVECPTR[.I];

		OFFSET = .OFFSET - (.SUBVECTOR[.I, DBG$L_PNSUB_STRIDE]*
    				    .BOUNDVEC[2*.I]);


    		! One additional thing needs to be done for arrays indexed
    		! by enumeration types in ADA. The SVALUE field needs
    		! to be filled in to be the value of the enumeration,
    		! not its position.
    		!
    		IF .DBG$GB_LANGUAGE EQL DBG$K_ADA
    		THEN
    		    IF .SUB_TYPEID NEQ 0
    		    THEN
    			IF .SUB_TYPEID[RST$B_FCODE] EQL RST$K_TYPE_ENUM
    			THEN
			    SUBVECTOR[.I, DBG$L_PNSUB_SVALUE] = 
    				DBG$ENUM_VAL(.SUB_TYPEID,
    				    .SUBVECTOR[.I, DBG$L_PNSUB_SVALUE]);

		END;


	    ! Finally fill in the offset from the start of the array to
	    ! element ARRAY[0,0,...,0].  Also mark symbol as an aggregate.
	    !
	    NODEPTR[DBG$L_PNARR_OFFSET] = .OFFSET;
    	    IF .DBG$GL_ARRSUB_FLAG
    	    THEN
	        PRIMPTR[DBG$V_DHDR_AGGR] = TRUE;

	    END;			! End of case for Array Sub-Node


	! Handle records.  Allocate a Record Sub-Node.  Then simply initialize
	! the record component index to be 1.  If dot-qualification follows,
	! this field will be changed to the actual component index of the
	! selected record component.  Also mark symbol as an aggregate.
	!
	[RST$K_TYPE_RECORD]:
	    BEGIN
	    DBG$STA_TYP_RECORD(.TYPEID, NCOMPS, COMP_VEC, BITSIZE);
	    NODEPTR = DBG$GET_TEMPMEM(DBG$K_PRIM_SIZE_RECORD);
	    NODEPTR[DBG$W_PNREC_INDEX] = 1;
	    NODEPTR[DBG$W_PNREC_NCOMPS] = .NCOMPS;
    	    IF .DBG$GL_RECCMP_FLAG
    	    THEN
	        PRIMPTR[DBG$V_DHDR_AGGR] = TRUE;
	    END;


	! Handle Record Variants (as in PASCAL or ADA).  Here we allocate
	! a Variant Sub-Node, but the fields specific to this sub-node are
	! actually set by the caller (namely GET_RECORD_COMPONENT).
	!
	[RST$K_TYPE_VARIANT]:
	    NODEPTR = DBG$GET_TEMPMEM(DBG$K_PRIM_SIZE_VARIANT);


	! Handle BLISS data items. The four kinds of data that fall have this
	! fcode are vectors, bitvectors, blocks, and blockvectors. For these
	! four types, we have to go to the DST to obtain the information
	! which is placed in the Primary Descriptor.
	!
	[RST$K_TYPE_BLIDATA]:
	    BEGIN


	    ! Assume aggregate until proved otherwise.
	    !
	    PRIMPTR [DBG$V_DHDR_AGGR] = TRUE;


	    ! Get the DST record if necessary.
	    !
	    IF .DSTPTR EQL 0 AND .SYMID NEQ 0
	    THEN
	        DSTPTR = .SYMID [RST$L_DSTPTR];


	    ! Check for the REF bit being set.  If so, allocate a Primary
	    ! Descriptor Normal Sub-Node and set the FCODE to pointer to
	    ! indicate that dereferencing is taking place.  Also turn off
	    ! the aggregate flag for REF items.
	    !
	    IF .DSTPTR [DST$V_BLI_REF] AND .SYMID NEQ 0
	    THEN
		BEGIN
		NODEPTR = DBG$GET_TEMPMEM (DBG$K_PRIM_SIZE_NORMAL);
		PRIMPTR [DBG$V_DHDR_AGGR] = FALSE;
		FCODE = RST$K_TYPE_PTR;
		END


	    ! If it is not a REF item, CASE on the kind of BLISS structure:
	    ! Vector, Bitvector, Block, or Blockvector.
	    !
	    ELSE
		BEGIN
	        CASE .DSTPTR [DST$V_BLI_STRUC] FROM DST$K_BLI_NOSTRUC 
					   TO   DST$K_BLI_BLKVEC OF
		    SET


		    ! The "nostruc" code arises in the case where the structure of
		    ! the data is a user-defined structure, and not one of the
		    ! four built-ins. We treat such data as an ordinary variable.
		    !
		    [DST$K_BLI_NOSTRUC] :
		        BEGIN
		        PRIMPTR [DBG$V_DHDR_AGGR] = FALSE;
		        NODEPTR = DBG$GET_TEMPMEM (DBG$K_PRIM_SIZE_NORMAL);
		        END;


		    ! Handle vectors.  We allocate enough space for an Array
		    ! Sub-Node with one subscript.  The fields of the subnode
		    ! are then filled in.
	   	    !
		    [DST$K_BLI_VEC] :
		        BEGIN
		        FCODE = RST$K_TYPE_ARRAY;
		        NODEPTR = DBG$GET_TEMPMEM (DBG$K_PRIM_SIZE_ARRAY +
					       DBG$K_PRIM_SIZE_SUBS);
		        NODEPTR [DBG$B_PNARR_DIMCNT] = 1;
			NODEPTR [DBG$W_PNARR_LENGTH] =  .DSTPTR[DST$V_BLI_VEC_UNIT_SIZE];

    			!+
    			! Figure out the dtype based on the unit size and
    			! sign extension.
    			!-

    			! VECTOR[BYTE] or VECTOR[BYTE,SIGNED]
    			!
		        IF .DSTPTR[DST$V_BLI_VEC_UNIT_SIZE] EQL 1
		        THEN
			    IF .DSTPTR[DST$V_BLI_VEC_SIGN_EXT] NEQ 0 
			    THEN
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_B
			    ELSE
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_BU

    			! VECTOR[WORD] or VECTOR[WORD,SIGNED]
    			!
		        ELSE IF .DSTPTR[DST$V_BLI_VEC_UNIT_SIZE] EQL 2
		        THEN
			    IF .DSTPTR[DST$V_BLI_VEC_SIGN_EXT] NEQ 0
			    THEN
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_W
			    ELSE
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_WU

    			! VECTOR[LONG] or VECTOR[LONG,SIGNED]
    			!
		        ELSE IF .DSTPTR[DST$V_BLI_VEC_UNIT_SIZE] EQL 4
		        THEN
			    IF .DSTPTR[DST$V_BLI_VEC_SIGN_EXT] NEQ 0
			    THEN
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_L
			    ELSE
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_LU

    			! VECTOR[X] where X is not 1, 2, or 4
    			!
		        ELSE
    			    BEGIN
			    IF .DSTPTR[DST$V_BLI_VEC_SIGN_EXT] NEQ 0
			    THEN
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_V
			    ELSE
			        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_VU;

    			    ! In this case the since the type has been set
    			    ! to bitfield then multiply the length by 8 to
    			    ! express it in bits.
    			    !
    			    NODEPTR[DBG$W_PNARR_LENGTH] = 
    				.NODEPTR[DBG$W_PNARR_LENGTH] * 8;
    			    END;

		        SUBVECTOR = NODEPTR [DBG$A_PNARR_SVECTOR];


		        ! The stride can be either 1, 2, or 4, depending on whether
		        ! the vector was declared as a byte, word, or longword
		        ! vector. We obtain this information from the DST.
		        !
		        SUBVECTOR [0, DBG$L_PNSUB_STRIDE] =
			    .DSTPTR [DST$V_BLI_VEC_UNIT_SIZE];


		        ! The upper bound on subscripts is one less than the 
		        ! number of units that were allocated in the declaration
		        ! of the vector. (Origin-0 subscripting)
		        !
			IF .DSTPTR [DST$L_BLI_VEC_UNITS] EQL 0
			THEN
			    SUBVECTOR [0, DBG$L_PNSUB_UBOUND] = 0

			ELSE
		            SUBVECTOR [0, DBG$L_PNSUB_UBOUND] =
			        .DSTPTR [DST$L_BLI_VEC_UNITS]-1;

		        END;


		    ! Handle bit-vectors.  We allocate enough space for an
		    ! Array Sub-Node with one subscript.  The fields of the
		    ! subnode are then filled in.
		    !
   		    [DST$K_BLI_BITVEC] :
	 	        BEGIN
		        FCODE = RST$K_TYPE_ARRAY;
		        NODEPTR = DBG$GET_TEMPMEM (DBG$K_PRIM_SIZE_ARRAY +
					       DBG$K_PRIM_SIZE_SUBS);


		        ! Since this is a bitvector, set the BITREF flag.
		        !
		        NODEPTR [DBG$V_PNARR_BITREF] = TRUE;
		        NODEPTR [DBG$B_PNARR_DIMCNT] = 1;
		        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_VU;
		        NODEPTR [DBG$W_PNARR_LENGTH] = 1;
		        SUBVECTOR = NODEPTR [DBG$A_PNARR_SVECTOR];
		        SUBVECTOR [0, DBG$L_PNSUB_STRIDE] = 1;


		        ! The upper bound on subscripts is one less than the 
		        ! number of units that were allocated in the declaration
		        ! of the vector. (Origin-0 subscripting)
		        !
			IF .DSTPTR [DST$L_BLI_BITVEC_SIZE] EQL 0
			THEN
			    SUBVECTOR [0, DBG$L_PNSUB_UBOUND] = 0

			ELSE
		            SUBVECTOR [0, DBG$L_PNSUB_UBOUND] =
			        .DSTPTR [DST$L_BLI_BITVEC_SIZE]-1;

		        END;


		    ! Handle blocks.  We allocate enough space for an Array
		    ! Sub-Node with one subscript.  The fields of the subnode
		    ! are then filled in.
		    !
		    [DST$K_BLI_BLOCK] :
		        BEGIN
    			PRIMPTR[DBG$V_DHDR_BLIBLK] = TRUE;
		        FCODE = RST$K_TYPE_ARRAY;
		        NODEPTR = DBG$GET_TEMPMEM (DBG$K_PRIM_SIZE_ARRAY +
					       DBG$K_PRIM_SIZE_SUBS);
		        NODEPTR [DBG$B_PNARR_DIMCNT] = 1;
		        SUBVECTOR = NODEPTR [DBG$A_PNARR_SVECTOR];


    			! Fill in stride and length as four. For purposes
    			! of aggregate examine, we are representing
    			! each element as a longword. If it turns out
    			! we are not doing aggregate examine, then
    			! we fix up this information in the GET_BLISS_SUBSCRIPTS
    			! routine.
		        !
		        SUBVECTOR [0, DBG$L_PNSUB_STRIDE] = 4; 
			NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_L;
			NODEPTR [DBG$W_PNARR_LENGTH] = 4;


		        ! The upper bound on subscripts is one less than the 
		        ! number of units that were allocated in the declaration
		        ! of the vector. (Origin-0 subscripting)
    			! We temporarily dummy this up as if stride were 4, for
    			! purposes of aggregate output.
		        !
    	    		STRIDE_SIZE = .DSTPTR [DST$V_BLI_BLOCK_UNIT_SIZE];
			IF (.DSTPTR [DST$L_BLI_BLOCK_UNITS] EQL 0) OR
    			   (.STRIDE_SIZE EQL 0)
			THEN
			    SUBVECTOR [0, DBG$L_PNSUB_UBOUND] = 0

    			ELSE
		            SUBVECTOR [0, DBG$L_PNSUB_UBOUND] =
			      (.DSTPTR [DST$L_BLI_BLOCK_UNITS]*.STRIDE_SIZE-1)
    						      /4;

		        END;


		    ! Handle blockvectors.  We allocate enough space for an
		    ! Array Sub-Node with one subscript. The fields of the
		    ! subnode are then filled in.
		    !
		    [DST$K_BLI_BLKVEC] :
		        BEGIN
    			PRIMPTR[DBG$V_DHDR_BLIBLK] = TRUE;
		        FCODE = RST$K_TYPE_ARRAY;
		        NODEPTR = DBG$GET_TEMPMEM (DBG$K_PRIM_SIZE_ARRAY +
					   2 * DBG$K_PRIM_SIZE_SUBS);
		        NODEPTR [DBG$B_PNARR_DIMCNT] = 2;
		        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_V;
		        NODEPTR [DBG$W_PNARR_LENGTH] = 32;
		        SUBVECTOR = NODEPTR [DBG$A_PNARR_SVECTOR];
		    

		        ! The stride on the first subscript is the stride on
		        ! the second subscript times the number of units per
		        ! block. The upper bound on the first subscript 
		        ! depends on the number of blocks in the blockvector.
		        !
		        SUBVECTOR [0, DBG$L_PNSUB_STRIDE] =
					.DSTPTR [DST$B_BLI_BLKVEC_UNIT_SIZE] *
					.DSTPTR [DST$L_BLI_BLKVEC_UNITS];
			IF .DSTPTR [DST$L_BLI_BLKVEC_BLOCKS] EQL 0
			THEN
			    SUBVECTOR [0, DBG$L_PNSUB_UBOUND] = 0

			ELSE
		            SUBVECTOR [0, DBG$L_PNSUB_UBOUND] =
					.DSTPTR [DST$L_BLI_BLKVEC_BLOCKS]-1;


    			! Fill in stride and length as four (we are always
    			! representing blocks as blocks of longwords).
		        !
		        SUBVECTOR [1, DBG$L_PNSUB_STRIDE] = 4; 
		        NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_L;
			NODEPTR [DBG$W_PNARR_LENGTH] = 4;


    			! The upper bound on the subscript depends on the
    			! number of units per block.
    			! We temporarily dummy this up as if stride were 4, for
    			! purposes of aggregate output.
    			!
    	    		STRIDE_SIZE = .DSTPTR [DST$B_BLI_BLKVEC_UNIT_SIZE];
			IF (.DSTPTR [DST$L_BLI_BLKVEC_UNITS] EQL 0) OR
			   (.STRIDE_SIZE EQL 0)
			THEN
			    SUBVECTOR [1, DBG$L_PNSUB_UBOUND] = 0

			ELSE
		            SUBVECTOR [1, DBG$L_PNSUB_UBOUND] =
			      (.DSTPTR [DST$L_BLI_BLKVEC_UNITS]*.STRIDE_SIZE-1)
						      /4;

		        END;

		    TES;

		END;


	    ! For bitvectors, vectors, blocks, and blockvectors, and REF stuff,
	    ! make sure the celltype is filled in correctly.
	    !
	    IF .FCODE EQL RST$K_TYPE_ARRAY
	    THEN
	        BEGIN
	    	ATOMIC_TYPE = .NODEPTR [DBG$B_PNARR_DTYPE];
	    	BIT_LENGTH = .NODEPTR [DBG$W_PNARR_LENGTH];
	    	IF (.ATOMIC_TYPE NEQ DSC$K_DTYPE_V)  AND
		   (.ATOMIC_TYPE NEQ DSC$K_DTYPE_VU) AND
		   (.ATOMIC_TYPE NEQ DSC$K_DTYPE_SV) AND
		   (.ATOMIC_TYPE NEQ DSC$K_DTYPE_SVU)
	    	THEN
	            BIT_LENGTH = .BIT_LENGTH * 8;

	    	NODEPTR [DBG$L_PNARR_CELLTYPE] =
	                DBG$TYPEID_FOR_ATOMIC(.ATOMIC_TYPE, .BIT_LENGTH, FALSE);

	    	END;

	    IF .FCODE EQL RST$K_TYPE_PTR
	    THEN
	        BEGIN
	    	ATOMIC_TYPE = DSC$K_DTYPE_L;
	    	BIT_LENGTH = 32;
		TYPEID = DBG$TYPEID_FOR_ATOMIC(.ATOMIC_TYPE, .BIT_LENGTH, FALSE);
	    	END;

	    END; 


	! For all other cases, just allocate a Normal Sub-Node.  Also
	! clear the aggregate flag.
	!
	[INRANGE, OUTRANGE]:
	    BEGIN
	    NODEPTR = DBG$GET_TEMPMEM(DBG$K_PRIM_SIZE_NORMAL);
	    PRIMPTR[DBG$V_DHDR_AGGR] = FALSE;
	    END;

	TES;


    ! Fill in the standard fields common to all Primary Descriptor Sub-Nodes.
    !
    NODEPTR[DBG$B_PNODE_KIND] = .KIND;
    NODEPTR[DBG$B_PNODE_FCODE] = .FCODE;
    NODEPTR[DBG$L_PNODE_TYPEID] = .TYPEID;
    NODEPTR[DBG$L_PNODE_SYMID] = .SYMID;
    NODEPTR[DBG$L_PNODE_RELOC] = 0;


    ! Also set the final Sub-Node's KIND, FCODE, and TYPEID in the Primary
    ! Descriptor Root Node.  The Root Node thus describes the object described
    ! by the Primary Symbol as a whole.
    !
    PRIMPTR[DBG$B_DHDR_KIND] = .KIND;
    PRIMPTR[DBG$B_DHDR_FCODE] = .FCODE;
    PRIMPTR[DBG$L_DHDR_TYPEID] = .TYPEID;


    ! Append the Sub-Node to the Primary Descriptor by linking it in at the
    ! end of the doubly linked Sub-Node chain.  Then return.
    !
    INSQUE(.NODEPTR,.PRIMPTR[DBG$L_PRIM_BLINK]);
    RETURN;

    END;

GLOBAL ROUTINE DBG$EXP_INT(INPUT_DESC, RADIX, VALUE_PTR, TERM_INDEX) =
!
! FUNCTION
!	This is the common Expression Interpreter for most languages
!	supported by DEBUG.  It parses and evaluates a source language
!	expression and returns a Value Descriptor which represents the
!	value of the expression.  This routine itself is only a set-up
!	routine which sets up the character pointer and the expression
!	radix to use and then calls DBG$EXPRESSION_PARSER to do the
!	actual work.
!
! INPUTS
!	INPUT_DESC - The address of a VAX standard string descriptor which
!		  describes the input string to be parsed.  The length is
!		  actually not used, however--the string is instead assumed
!		  to be terminated by a carriage-return character.
!
!	RADIX	- The radix to be used to interpret integer constants in the
!		  input string.  The allowed radix values are DBG$K_DECIMAL,
!		  DBG$K_HEX, DBG$K_OCTAL, and DBG$K_BINARY.
!
!	VALUE_PTR - The address of a longword to receive a pointer to the
!		  value descriptor returned by this routine as its output.
!
!	TERM_INDEX - A "terminator index" which indicates which lexical tokens
!		  are allowed as expression terminators in this context.  These
!		  index values have names of the form TOKEN$K_TERM_xxx.
!
!	5th Optional Parameter - If this is present, and the value is
!			DBG$K_DEPOSIT_VERB then pass this into 
!			DBG$EXPRESSION_PARSER, so that in 
!			DBG$EXPRESSION_PARSER, when the expression is not
!			address expression and in deposit command, 
!			DBG$EVAL_LANG_OPERATOR will not be called with
!			DBG$GL_IDENTITY_TOKEN.
!			(This is passed in from DBG$NPARSE_DEPOSIT, from
!			 DBG$NPARSE_EXPRESSION).
!
! OUTPUTS
!	VALUE_PTR - The address of a Value Descriptor is returned to VALUE_PTR.
!		  This Value Descriptor represents the value of the expression
!		  interpreted by DBG$EXP_INT.
!
!	The value STS$K_SUCCESS is return as the routine result if the expres-
!		  sion was terminated by a carriage-return character.  If it
!		  was terminated any other way (i.e., by a terminator token),
!		  the value STS$K_WARNING is returned.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE],	! Pointer to input string descriptor
	VALUE_PTR: REF VECTOR[1];	! Longword to receive Value Descr ptr.

    LOCAL
	VALPTR: REF DBG$VALDESC;	! Pointer to returned Value Descriptor

    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;


    ! Set up CHARPTR to point to the start of the expression string.  Also set
    ! up the radix we are to use in the scan and initialize some variables.
    !
    CHARPTR = .INPUT_DESC[DSC$A_POINTER];
    EXPRESSION_RADIX = .RADIX;
    SAVED_TOKEN = 0;


    ! Call the Expression Parser to parse the language expression.  If the
    ! result is an unconverted constant Value Descriptor, we convert it to
    ! a real Value Descriptor here.  Then return the Value Descriptor pointer.
    !
    IF ACTUALCOUNT() GTR 4
    THEN
    	BEGIN
    	IF ACTUALPARAMETER(5) NEQ DBG$K_DEPOSIT_VERB
    	THEN
    	    $DBG_ERROR('DBGPARSER\DBG$EXP_INT');

        VALPTR = DBG$EXPRESSION_PARSER(FALSE,
				.TERM_POINTER_TBL[.TERM_INDEX] + TABLEBASE,
    				DBG$K_DEPOSIT_VERB);
    	END

    ELSE
        VALPTR = DBG$EXPRESSION_PARSER(FALSE,
				.TERM_POINTER_TBL[.TERM_INDEX] + TABLEBASE);
    VALUE_PTR[0] = .VALPTR;


    ! Fix up the string descriptor to reflect the new location of the parse
    ! pointer and return the appropriate status code.
    !
    INPUT_DESC[DSC$W_LENGTH] = .INPUT_DESC[DSC$W_LENGTH] +
				.INPUT_DESC[DSC$A_POINTER] - .CHARPTR;
    INPUT_DESC[DSC$A_POINTER] = .CHARPTR;
    IF .CHARPTR[0] NEQ CAR_RET THEN RETURN STS$K_WARNING;
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$EXPRESSION_PARSER(ADDRESS_EXPRESSION, TERM_LIST) =
!
! FUNCTION
!	This routine parses and interprets either a DEBUG Address Expression or
!	a language expression in the current language and returns the result of
!	the expression evaluation.
!
!	The routine uses an Operator Precedence parsing scheme.  Each operator
!	is represented by an Operator Lexical Token Entry which contains the
!	kind of the operator (prefix, infix, or postfix) and the left and right
!	precedences of that operator.  Operands are represented by Primary
!	Descriptors, Value Descriptors, or other Operand Lexical Token Entries.
!	The operators and operands are retrieved by calling the Primary Parser.
!
!	When an operand is encountered, it is simply stacked on the operand
!	stack.  When an operator is encountered, its left precedence is com-
!	pared to the right precedence of the previous operator on the operator
!	stack.  If the previous operator has the higher or equal precedence,
!	it is popped from the operator stack and evaluated.  The evaluation
!	requires one or two operands to be popped from the operand stack, after
!	which the result is pushed back on that stack.  When no previous opera-
!	tor has a higher or equal precedence, the new operator is pushed onto
!	the operator stack.
!
!	The operator stack is always initialized with the "initiator operator"
!	which ensures that there is always a previous operator on the stack.
!	The end of an expression is always signalled by the "terminator opera-
!	tor" whose left precedence is set such that it forces evaluation of all
!	operators still on the operator stack up to the initiator operator.
!	The single operand left on the operand stack thereafter constitutes
!	the result of the expression evaluation.
!
!	This routine accepts a list of allowed "terminator tokens" (keywords
!	such as "DO" or "THEN" or special characters such as ",", ")", or "=",
!	depending on context).  This list is passed to the Lexical Scanner
!	which returns the Terminator Operator when such a token or a carriage-
!	return is encountered.  As a side effect, OWN variable TERMINATOR_CODE
!	is set to a value which indicates which terminator token was found.
!	That terminator's character length is also set in TERMINATOR_LENGTH.
!	(This side effect is used when parsing subscript expressions.)
!
! INPUTS
!	ADDRESS_EXPRESSION - A flag set to TRUE if a DEBUG Address Expression
!		  is to be parsed and evaluated.  If this flag is FALSE, a
!		  language expression for the current language is parsed and
!		  evaluated instead.  This flag affects both the lexical
!		  scanning of operator symbols and the parsing and evaluation
!		  of the expression operators.
!
!	TERM_LIST - A vector of pointers to Terminator Lexical Token Entries
!		  for the Terminator Tokens which can terminate the expression
!		  to be parsed.  The vector must be in PLIT form (TERM_LIST[-1]
!		  gives the number of entries) and each pointer is expected to
!		  be relative to TABLEBASE.  If there are no terminator tokens
!		  other than carriage return, this list is empty (0 entries).
!
!	3rd Optional Parameter - If this is present, and the value is
!			DBG$K_DEPOSIT_VERB then this is passed in from
!			DBG$EXP_INT, from DBG$NPARSE_EXPRESSION, and from
!			DBG$NPARSE_DEPSOIT, , so that in 
!			DBG$EXPRESSION_PARSER, when the expression is not
!			address expression and in deposit command, 
!			DBG$EVAL_LANG_OPERATOR will not be called with
!			DBG$GL_IDENTITY_TOKEN.
!
! OUTPUTS
!	A pointer to a Primary Descriptor or a Value Descriptor specifying the
!		  result of the expression evaluation is returned as the
!		  routine value.
!

    BEGIN

    MAP
	TERM_LIST: REF VECTOR[,LONG];	! Pointer to Terminator Table

    LITERAL
	MAX_OPAND_INDEX = 25,		! Maximum size of operand stack
	MAX_OPTOR_INDEX = 25;		! Maximum size of operator stack

    LOCAL
    	DEPOSIT_FLAG,			! A flag to indicate the call is
    					!      from DBG$NPARSE_DEPOSIT
    	JUNK,				! Output parameter - not used
	LEFT_ARG,			! Pointer to the left (or only) argument
					!      of the current operator
	LEFT_OP: REF TOKEN$ENTRY,	! Pointer to top operator on operator
					!      stack--operator to the left
					!      of the current operator
    	NEW_PRIMPTR: REF DBG$PRIMARY,	! Pointer to a Primary Descriptor
	OP,				! The operator code for current operator
	OPAND_INDEX,			! Current index into OPERAND_STACK
	OPERAND_EXPECTED,		! Flag set when operand or prefix ope-
					!      rator is expected next
	OPERAND_STACK:			! Parser's operand stack
		VECTOR[MAX_OPAND_INDEX],!
	OPERATOR_STACK:			! Parser's operator stack
		VECTOR[MAX_OPTOR_INDEX],!
	OPTOR_INDEX,			! Current index into OPERATOR_STACK
	PAREN_NESTING,			! Parenthesis nesting depth in expr
    	PRIMPTR: REF DBG$PRIMARY,	! Pointer to a Primary Descriptor
	RIGHT_ARG,			! Pointer to the right argument to the
					!      current operator
	TEMP_TOKEN: REF TOKEN$ENTRY,	! Temporary copy of bit-select token
	TOKEN: REF TOKEN$ENTRY,		! Pointer to the current Token Entry
	TOKEN_OPERAND_FLAG,		! Flag returned by Primary Parser
					!      saying an operand was returned
	VALPTR: REF DBG$PRIMARY;	! Pointer to Primary or Value Descriptor


    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;


    DEPOSIT_FLAG = FALSE;
    IF ACTUALCOUNT() GTR 2
    THEN
    	BEGIN
    	IF ACTUALPARAMETER(3) NEQ DBG$K_DEPOSIT_VERB
    	THEN
    	    $DBG_ERROR('DBGNPARSE\DBG$NPARSE_EXPRESSION');

    	DEPOSIT_FLAG = TRUE;
    	END;


    ! Initialize the operator stack to contain one operator, the initiator
    ! operator.  Also initialize the operand stack to be empty.  Indicate
    ! that we expect an operand at the start of the parse.
    !
    OPTOR_INDEX = 0;
    OPERATOR_STACK[.OPTOR_INDEX] = INITIATOR_TOKEN;
    OPAND_INDEX = -1;
    OPERAND_EXPECTED = TRUE;
    PAREN_NESTING = 0;


    ! Loop through all operands and operators on the input line being parsed
    ! until we reach the terminator operator.  Stack operands and stack or
    ! evaluate operators as appropriate until the terminator operator forces
    ! evaluation of all stacked operators.
    !
    WHILE TRUE DO
	BEGIN


	! Pick up the next operand or operator.  An operand is returned as a
	! Primary Descriptor or a Value Descriptor by the Primary Parser.
	! An operator is just returned as an Operator Lexical Token Entry.
	!
	DBG$PRIMARY_PARSER(.OPERAND_EXPECTED, .ADDRESS_EXPRESSION,
			.TERM_LIST, .PAREN_NESTING, TOKEN, TOKEN_OPERAND_FLAG);


	! Handle operands.  If this is an operand, check that we are actually
	! expecting an operand at this point.  Then stack the operand on the
	! operand stack and loop to get the next operand or operator.
	!
	IF .TOKEN_OPERAND_FLAG
	THEN
	    BEGIN
	    IF NOT .OPERAND_EXPECTED
	    THEN
		!<<----------- FIX UP MESSAGE ----------------------------------
		SIGNAL(DBG$_MISINVOPER, 1, UPLIT BYTE(%ASCIC 'somewhere'));

	    OPERAND_EXPECTED = FALSE;
	    OPAND_INDEX = .OPAND_INDEX + 1;
	    IF .OPAND_INDEX GEQ MAX_OPAND_INDEX THEN SIGNAL(DBG$_PARSTKOVR);
	    OPERAND_STACK[.OPAND_INDEX] = .TOKEN;
	    IF .DBG$GL_DEVELOPER[3] THEN DUMP_PRIMARY(.TOKEN);
	    END


	! Handle operators.  First check that an operator of this operator's
	! kind is expected.  Then loop to pop all higher-precedence operators
	! from the operator stack so they can be evaluated.  When no higher-
	! precedence operators are left on the stack, we stack the current
	! operator on the operator stack.
	!
	ELSE
	    BEGIN


	    ! Check that an operator was expected unless this is a prefix
	    ! operator (which is okay when we expect an operand).  This check
	    ! catches any expression which is not well-formed, including empty
	    ! expressions.  Also say that we expect an operand next unless
	    ! this is a postfix operator.
	    !
	    IF (.OPERAND_EXPECTED AND
			(.TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_PREFIX_OP)) OR
	       ((NOT .OPERAND_EXPECTED) AND
			(.TOKEN[TOKEN$B_KIND] EQL TOKEN$K_PREFIX_OP))
	    THEN
		SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);

	    IF .TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_POSTFIX_OP
	    THEN
		OPERAND_EXPECTED = TRUE;


	    ! Pop and evaluate all operators on the operator stack whose prece-
	    ! dence is higher than or equal to the current operator's.  When we
	    ! finally reach a lower-precedence operator, we exit the pop loop.
	    !
	    WHILE TRUE DO
		BEGIN


		! If the current operator (TOKEN) has a precedence higher than
		! the precedence of the top operator on the stack (LEFT_OP),
		! then leave this loop.
		!
		LEFT_OP = .OPERATOR_STACK[.OPTOR_INDEX];
		IF .LEFT_OP[TOKEN$B_R_PREC] LSS .TOKEN[TOKEN$B_L_PREC]
		THEN
		    EXITLOOP;


		! The LEFT_OP operator has a higher or equal precedence.  Pop
		! it from the operator stack and evaluate it.  Start by picking
		! up its operands from the operand stack.
		!
		OPTOR_INDEX = .OPTOR_INDEX - 1;
		IF .OPTOR_INDEX LSS 0
		THEN
		    $DBG_ERROR('DBGPARSER\EXPRESSION_PARSER 1');

		LEFT_ARG = .OPERAND_STACK[.OPAND_INDEX];
		RIGHT_ARG = 0;
		IF .LEFT_OP[TOKEN$B_KIND] EQL TOKEN$K_INFIX_OP
		THEN
		    BEGIN
		    RIGHT_ARG = .LEFT_ARG;
		    OPAND_INDEX = .OPAND_INDEX - 1;
		    LEFT_ARG = .OPERAND_STACK[.OPAND_INDEX];
		    END;

		IF .DBG$GL_DEVELOPER[3] THEN DUMP_OPERATOR(.LEFT_OP, FALSE);


		! If the operator we are about to evaluate is a "lexical"
		! operator, meaning that it has some semantic effect on the
		! lexical processing or parsing of the current expression,
		! we perform that semantic action here.
		!
		IF  .LEFT_OP[TOKEN$V_LEXICAL]
		THEN
		    BEGIN
		    SELECTONE .LEFT_OP[TOKEN$W_CODE] OF
			SET


			! If evaluation of an open parenthesis operator is
			! forced by the terminator operator, we signal
			! unbalanced parentheses.
			!
			[TOKEN$K_OPENPAREN]:
			    SIGNAL(DBG$_UNBPAREN);


			! Restore the current radix to decimal.  This undoes
			! a previous radix operator (such as %HEX) in the input.
			!
			[TOKEN$K_RADIX_DEC]:
			    EXPRESSION_RADIX = DBG$K_DECIMAL;


			! Restore the current radix to hexadecimal.  This undoes
			! a previous radix operator (such as %DEC) in the input.
			!
			[TOKEN$K_RADIX_HEX]:
			    EXPRESSION_RADIX = DBG$K_HEX;


			! Restore the current radix to octal.  This undoes a
			! previous radix operator (such as %HEX) in the input.
			!
			[TOKEN$K_RADIX_OCT]:
			    EXPRESSION_RADIX = DBG$K_OCTAL;


			! Restore the current radix to binary.  This undoes a
			! previous radix operator (such as %HEX) in the input.
			!
			[TOKEN$K_RADIX_BIN]:
			    EXPRESSION_RADIX = DBG$K_BINARY;


    			! Infix NOT should not show up here.
    			!
    			[TOKEN$K_INFIX_NOT]:
    			    SIGNAL(DBG$_MISOPEMIS, 1, LEFT_OP[TOKEN$B_OPLEN]);

			! Any other case is an error--a lexical operator should
			! not be on the stack or should not be marked as lexical
			! if it has no semantic action here.
			!
			[OTHERWISE]:
			    $DBG_ERROR('DBGPARSER\EXPRESSION_PARSER 20');

			TES;

		    END


		! This is not a lexical operator--it is a "normal" operator.
		! If this is a DEBUG Address Expression, evaluate the Address
		! Expression operator.
		!
		ELSE IF .ADDRESS_EXPRESSION
		THEN
		    OPERAND_STACK[.OPAND_INDEX] =
			DBG$EVAL_ADDR_OPERATOR(.LEFT_OP, .LEFT_ARG, .RIGHT_ARG)


		! And if it is a language expression, evaluate this non-lexical
		! operator according to language rules.
		!
		ELSE
    		    BEGIN

                    ! EVAL_LANG_OPERATOR returns a pointer to a Primary Descriptor
                    ! or a pointer to a Value Descriptor.
    		    !
    		    PRIMPTR = DBG$EVAL_LANG_OPERATOR(.LEFT_OP, .LEFT_ARG, .RIGHT_ARG);


    		    ! If a Primary Descriptor was returned from the expression
    		    ! evaluator then there may be some further processing to do.
    		    ! An example of this is the C expression:
    		    ! EVALUATE  (*PTR).COMPONENT
    		    ! The (*PTR) will be evaluated by the expression evaluator
    		    ! and a Primary Descriptor will be returned (presumably,
    		    ! describing a record). Then we need to call the Primary
    		    ! Parser to pick up the rest of the expression.
    		    !
    		    IF .PRIMPTR[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
    		    THEN
    			BEGIN
    			DBG$PRIMARY_PARSER (
    			    FALSE,		! Operand not expected
    			    FALSE,		! Not address expression
    			    .TERM_LIST,		! Pass along terminator list
    			    0,			! Parenthesis nesting
    			    NEW_PRIMPTR,	! Address to fill in result
    			    JUNK,		! Not used
    			    .PRIMPTR,		! Input Primary
    			    REMEMBER_C_STATE_GOT_SUBSCRIPT);
    			PRIMPTR = .NEW_PRIMPTR;
    			END;
    			

    		    ! Now just put the result of the expression on top of
    		    ! the expression stack.
    		    !
		    OPERAND_STACK[.OPAND_INDEX] = .PRIMPTR;
    		    END;
		END;			! End of pop and evaluate loop


	    ! If the new operator is a "lexical operator", meaning that it has
	    ! some semantic effect on the lexical processing or parsing of the
	    ! current expression, we perform that semantic action here.  For
	    ! example, the terminator operator has the semantic effect of term-
	    ! inating the scan of the current expression.
	    !
	    IF .TOKEN[TOKEN$V_LEXICAL]
	    THEN
		BEGIN
		SELECTONE .TOKEN[TOKEN$W_CODE] OF
		    SET


		    ! If this is the terminator operator, exit the parse loop.
		    !
		    [TOKEN$K_TERMINATOR]:
			EXITLOOP;


		    ! If this is an open parenthesis "(", increment the
		    ! parenthesis count.
		    !
		    [TOKEN$K_OPENPAREN]:
			PAREN_NESTING = .PAREN_NESTING + 1;


		    ! If this is a close parenthesis ")", decrement the paren-
		    ! thesis count, check for balanced parentheses, and remove
		    ! both the close parenthesis and the matching open paren-
		    ! thesis from the operator stack.
		    !
		    [TOKEN$K_CLOSEPAREN]:
			BEGIN
			PAREN_NESTING = .PAREN_NESTING - 1;
			IF .PAREN_NESTING LSS 0 THEN SIGNAL(DBG$_UNBPAREN);
			IF .OPTOR_INDEX LSS 1
			THEN
			    $DBG_ERROR('DBGPARSER\EXPRESSION_PARSER 2');

			OPTOR_INDEX = .OPTOR_INDEX - 2;
			TOKEN = .OPERATOR_STACK[.OPTOR_INDEX + 1];
			END;


		    ! If this is a set constant [1, 3..4, 10], call routine
		    ! to build a value descriptor and push it on the operand
		    ! stack.  Ignore '[' by not pushing it on the operator
		    ! stack.
		    !
		    [TOKEN$K_OPENSET]:
			BEGIN
			OPERAND_EXPECTED = FALSE;
			OPAND_INDEX = .OPAND_INDEX + 1;
			IF .OPAND_INDEX GEQ MAX_OPAND_INDEX
			THEN
			    SIGNAL(DBG$_PARSTKOVR);

			OPERAND_STACK[.OPAND_INDEX] = GET_SET_CONSTANT();
			IF .DBG$GL_DEVELOPER[3] 
			THEN 
			    DUMP_PRIMARY(.OPERAND_STACK[.OPAND_INDEX]);

			TOKEN = .OPERATOR_STACK[.OPTOR_INDEX];
			OPTOR_INDEX = .OPTOR_INDEX - 1;
			END;


		    ! If this is the bit-selection operator <pos,size,ext>
		    ! allowed in Address Expressions and BLISS expressions,
		    ! parse the operator's parameter fields (i.e., pick up
		    ! pos, size, and ext) and incorporate those values in the
		    ! Operator Lexical Token Entry put on the operator stack.
		    !
		    [TOKEN$K_BITSELECT]:
			BEGIN
			TEMP_TOKEN = DBG$GET_TEMPMEM (
			    TOKEN$K_FIXED_SIZE_LONG +
			    .TOKEN[TOKEN$B_OPLEN]/4);
			CH$MOVE ( 
			    TOKEN$K_FIXED_SIZE_BYTE + .TOKEN[TOKEN$B_OPLEN],
			    .TOKEN, .TEMP_TOKEN);
			TOKEN = .TEMP_TOKEN;
			GET_FIELDREF(.TOKEN);
			TOKEN[TOKEN$V_LEXICAL] = FALSE;
			END;


		    ! Set the current radix to decimal.  Here we put a lexical
		    ! operator on the operator stack which will restore the
		    ! current radix.  We then set the radix to decimal.
		    !
		    [TOKEN$K_RADIX_DEC]:
			BEGIN
			TOKEN = OPERATOR_TO_RESTORE_RADIX();
			EXPRESSION_RADIX = DBG$K_DECIMAL;
			END;


		    ! Set the current radix to hexadecimal.  Here we put a lex-
		    ! ical operator on the operator stack which will restore
		    ! the current radix.  We then set the radix to hexadecimal.
		    !
		    [TOKEN$K_RADIX_HEX]:
			BEGIN
			TOKEN = OPERATOR_TO_RESTORE_RADIX();
			EXPRESSION_RADIX = DBG$K_HEX;
			END;


		    ! Set the current radix to octal.  Here we put a lexical
		    ! operator on the operator stack which will restore the
		    ! current radix.  We then set the radix to octal.
		    !
		    [TOKEN$K_RADIX_OCT]:
			BEGIN
			TOKEN = OPERATOR_TO_RESTORE_RADIX();
			EXPRESSION_RADIX = DBG$K_OCTAL;
			END;


		    ! Set the current radix to binary.  Here we put a lexical
		    ! operator on the operator stack which will restore the
		    ! current radix.  We then set the radix to binary.
		    !
		    [TOKEN$K_RADIX_BIN]:
			BEGIN
			TOKEN = OPERATOR_TO_RESTORE_RADIX();
			EXPRESSION_RADIX = DBG$K_BINARY;
			END;


		    ! Check for double-token (NOT =, NOT <, or NOT > in 
		    ! COBOL, where NOT is marked as infix and =, >, <
		    ! is marked as prefix and lexical bit is set.  Now
		    ! at this point, we should have infix NOT on the
		    ! operator stack, and have prefix token on hand.
		    ! We'll replace the infix NOT on the operator stack
		    ! to infix "NOT <".
    		    !
		    [TOKEN$K_PREFIX_EQL]:
			BEGIN
			TEMP_TOKEN = .OPERATOR_STACK[.OPTOR_INDEX];
			IF .TEMP_TOKEN[TOKEN$W_CODE] EQL TOKEN$K_INFIX_NOT
			THEN
			    BEGIN
			    OPTOR_INDEX = .OPTOR_INDEX - 1;
			    TOKEN = COBOL_NOT_EQL_TOKEN;
			    END

			ELSE
			    SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);
			END;


		    ! NOT > (Less equal)
		    !
		    [TOKEN$K_PREFIX_GTR]:
			BEGIN
			TEMP_TOKEN = .OPERATOR_STACK[.OPTOR_INDEX];
			IF .TEMP_TOKEN[TOKEN$W_CODE] EQL TOKEN$K_INFIX_NOT
			THEN
			    BEGIN
 			    OPTOR_INDEX = .OPTOR_INDEX - 1;
			    TOKEN = COBOL_NOT_GTR_TOKEN;
			    END

			ELSE
			    SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);
			END;


		    ! NOT < (Greater equal)
		    !
		    [TOKEN$K_PREFIX_LSS]:
			BEGIN
			TEMP_TOKEN = .OPERATOR_STACK[.OPTOR_INDEX];
			IF .TEMP_TOKEN[TOKEN$W_CODE] EQL TOKEN$K_INFIX_NOT
			THEN
			    BEGIN
			    OPTOR_INDEX = .OPTOR_INDEX - 1;
			    TOKEN = COBOL_NOT_LSS_TOKEN;
			    END

			ELSE
			    SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);

			END;


		    ! Do nothing, stack.
		    !
		    [TOKEN$K_INFIX_NOT]:
			BEGIN
			0;
			END;


		    ! Any other case is an error because the operator should
		    ! not be marked as a "lexical" operator if it has no
		    ! semantic action at this point.
		    !
		    [OTHERWISE]:
			$DBG_ERROR('DBGPARSER\EXPRESSION_PARSER 3');

		    TES;

		END;			! End of Lexical Operator processing


	    ! Stack the current operator on the operator stack.  Then loop to
	    ! get the next operator or operand.
	    !
	    OPTOR_INDEX = .OPTOR_INDEX + 1;
	    IF .OPTOR_INDEX GEQ MAX_OPTOR_INDEX THEN SIGNAL(DBG$_PARSTKOVR);
	    OPERATOR_STACK[.OPTOR_INDEX] = .TOKEN;

	    END;			! End of ELSE-clause for operators

	END;				! End of the get-symbol loop


    ! We are all done parsing the expression. Retrieve the descriptor from
    ! the top of the stack.
    ! 
    IF .OPAND_INDEX GTR 0 THEN $DBG_ERROR('DBGPARSER\EXPRESSION_PARSER 3');
    VALPTR = .OPERAND_STACK[0];


    ! If this is a language expression, then we always return a Value Descriptor.
    ! Primary Descriptors or Volatile Value Descriptors are converted to
    ! Value Descriptors here. DBG$EVAL_LANG_OPERATOR does this for us.
    !
    IF NOT .ADDRESS_EXPRESSION AND 
       NOT .DEPOSIT_FLAG
    THEN
	VALPTR = DBG$EVAL_LANG_OPERATOR (DBG$GL_IDENTITY_TOKEN, .VALPTR, 0);


    ! If this is an address expression then we always return either a 
    ! Primary Descriptor or a Volatile Value Descriptor.
    ! DBG$EVAL_ADDR_OPERATOR does this for us.
    !  
    IF .ADDRESS_EXPRESSION 
    THEN
	VALPTR = DBG$EVAL_ADDR_OPERATOR (DBG$GL_IDENTITY_TOKEN, .VALPTR, 0);


    RETURN .VALPTR;
    END;

GLOBAL ROUTINE DBG$GET_BIF_ARGUMENTS (LENGTH, NAME) =
!
! FUNCTION
!	This routine picks up built-in function arguments.  It calls
!	DBG$EXPRESSION_PARSER to parse and evaluate each argument
!	expression.
!
!	This routine assumes that the opening set parenthesis has
!	already been found and that the parse pointer points to the
!	start of the first built-in function argument expression.
!	When this routine returns, the parse pointer is left pointing
!	at the first character after the closing set parenthesis.
!
! INPUTS
!	LENGTH - The number of arguments expected.
!       NAME   - Name of Built-in function or Ada tick operator to output
!		when an error is to be signaled.
!
! OUTPUTS
!	Pointer to a counted vector of long words that point to the
!		argument values. The vector will have a minimum length
!		of 2 arguments.
!

    BEGIN

    MAP
	NAME	: REF VECTOR [,BYTE];		! Name of function or tick operator

    LOCAL
	ARG_PTR		: REF VECTOR [,LONG],	! Pointer to counted vect. of arguments
	BIF_INDEX;				! Index into the vector


    ! Get temporary memory for the argument list.
    !
    ARG_PTR = DBG$GET_TEMPMEM( MAX((.LENGTH + 1), 3) );

    ! Set the vector index to 1 and loop, picking up arguments, until
    ! a closing paren is found.  The arguments are picked up by a
    ! recursive call on DBG$EXPRESSION_PARSER.
    !
    BIF_INDEX = 1;
    TERMINATOR_CODE = TOKEN$K_TERM_NONE;
    WHILE .TERMINATOR_CODE NEQ TOKEN$K_TERM_CLOSE DO
        BEGIN

        ! If the number of arguments found so far is more than the number
        ! expected, signal a bad argument list.
        !
        IF .BIF_INDEX GTR .LENGTH
        THEN
            SIGNAL(DBG$_INVARGLIS, 1, .NAME);
        
        ! Recursive call to pick up the argument, and store the pointer
	! away in the vector.
        !
	ARG_PTR[.BIF_INDEX] = DBG$EXPRESSION_PARSER(FALSE, COMPAREN_TERM_TBL);

        ! If an invalid terminator was found signal the error.  If not,
	! increment the character pointer past the terminator.
        !
        IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE
        THEN
            SIGNAL(DBG$_MISCLOSUB);
        CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;
        BIF_INDEX = .BIF_INDEX + 1;

        END;

    BIF_INDEX = .BIF_INDEX - 1;

    ! If the number of arguments found is not the same as the number of
    ! expected, signal a bad argument list.
    !
    IF .BIF_INDEX NEQ .LENGTH
    THEN
        SIGNAL(DBG$_INVARGLIS, 1, .NAME);

    ! If only one argument is requested, a zero is left for the second argument.
    ! This is done for the subsequent call to DBG$EVAL_LANG_OPERATOR.
    ! Then store away the number of arguments and return a vector of these
    ! arguments.
    !
    ARG_PTR[0] = .BIF_INDEX;

    RETURN .ARG_PTR;
    END;

GLOBAL ROUTINE DBG$LEXICAL_SCANNER(OPERAND_EXPECTED,
			ADDRESS_EXPRESSION, TERM_LIST, PAREN_NESTING) =
!
! FUNCTION
!	This routine is the Lexical Scanner used during expression parsing.
!	It scans the character or characters pointed to by CHARPTR to pick
!	up the next lexical token according to the rules of the current
!	language.  It picks up or constructs a Lexical Token Entry for the
!	found lexical token and returns a pointer to that Token Entry as its
!	result.
!
!	The Lexical Scanner is called by the Primary Parser which then uses
!	the returned token to build up a Primary Descriptor if the token is
!	part of a Primary Symbol.  If the returned token is not part of a
!	Primary Symbol (i.e., if it is an operator in the current language or
!	the current Address Expression or if it is a constant), the Primary
!	Parser returns it directly to the Expression Parser.  The Expression
!	Parser is thus fed a stream of operands and operators which it then
!	uses to interpret and evaluate the current expression.
!
!	This routine assumes that the input line being scanned has already
!	been converted to upper case and it assumes that the input line is
!	terminated by a carriage-return character.  It also assumes that
!	the variable CHARPTR has been set up to point to the current posi-
!	tion in the buffer being scanned.  CHARPTR is updated by this rou-
!	tine to point to the first character position after the current
!	token.
!
!	This routine accepts a list of allowed "terminator tokens" (keywords
!	such as "DO" or "THEN" or special characters such as ",", ")", or "=",
!	depending on context).  This list is passed to the Lexical Scanner
!	which returns the Terminator Operator when such a token or a carriage-
!	return is encountered.  As a side effect, OWN variable TERMINATOR_CODE
!	is set to a value which indicates which terminator token was found.
!	That terminator's character length is also set in TERMINATOR_LENGTH.
!	(This side effect is used when parsing subscript expressions.)
!
! INPUTS
!	OPERAND_EXPECTED - A flag set to TRUE if an operand is expected next
!		  in the parse of the current expression.  This flag is used
!		  to disambiguate certain operators, such as "+" and "-",
!		  which are prefix operators when an operand is expected
!		  next and are infix operators when an operator is expected
!		  next.
!
!	ADDRESS_EXPRESSION - A flag set to TRUE if we are parsing a DEBUG
!		  Address Expression instead of a language expression.  This
!		  affects the parsing of Address Expression operators such
!		  as "+", "-", "*", "/", ".", and "@" which are recognized by
!		  DEBUG rules, not language rules, in Address Expressions.
!
!	TERM_LIST - A vector of pointers to Terminator Lexical Token Entries
!		  for the Terminator Tokens which can terminate the expression
!		  to be parsed.  The vector must be in PLIT form (TERM_LIST[-1]
!		  gives the number of entries) and each pointer is expected to
!		  be relative to TABLEBASE.  If there are no terminator tokens
!		  other than carriage return, this list is empty (0 entries).
!
!	PAREN_NESTING - The current parenthesis nesting depth.  This parameter
!		  is used to detect whether certain tokens are expression
!		  terminators or not.  (For example, a ")" token in a sub-
!		  script expression terminates it only if parentheses are
!		  already balanced.)
!
! OUTPUTS
!	A pointer to the Lexical Token Entry for the next lexical token found
!		  in the input line is returned as the routine value.  If there
!		  are no more lexical tokens on the line, a pointer to a Token
!		  Entry for the TOKEN$K_TERMINATOR operator is returned.
!

    BEGIN

    MAP
	TERM_LIST: REF VECTOR[,LONG];	! Pointer to Terminator Table to use

    LABEL
	CHECK_THIS_TERMINATOR;		! Label used to leave terminator
					!      checking code

    LOCAL
	ACTION,				! Action index during number scanning
	BACKUP_DIGIT_PTR,		! Pointer to last good digit in number
					!      --used to back up number scan
	BACKUP_NUMBER_KIND,		! Kind of numeric constant definite so
					!      far--used to back up number scan
	BEST_TOKEN_FOUND,		! Pointer to the Operator Token Entry
					!      for an operator with the right
					!      name but the wrong kind
	CLASS,				! Character class code of current char-
					!      acter during number scanning
	ENDPTR,				! Pointer to last char in an identifier
	ERRORMSG,			! Error message condition code
	INDEX,				! Index into look-up tables
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to name string in Percent Tbl
	NEW_STARTPTR,			! Start pointer to lower case identifier
	NUMBER_KIND,			! Kind of Numeric Constant Token found
	PRID: REF PRID$ENTRY,		! Pointer to Predefined Identifier Entry
	QUOTE,				! Quote character which started the
					!      current quoted string constant
	STARTPTR: REF VECTOR[,BYTE],	! Pointer to start of current token
	STATE_INDEX,			! Current Number Scanner State Table
					!      index during number scanning
	TERMPTR: REF TOKEN$ENTRY,	! Pointer to Terminator Toen Entry
	TOKEN: REF TOKEN$ENTRY,		! Pointer to Operator Token Entry
	TOKENBUFFER: VECTOR[256,BYTE],	! Vector in which current token is
					!      accumulated as Counted ASCII
	TOKEN_TYPE,			! Token's type; eg. TOKEN$K_STRING
	TOKENLEN;			! The character length of current token



    ! Start by scanning past any leading blanks.  Then mark the start location
    ! of the token to be picked up.
    !
    WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_SPACE] DO
	CHARPTR = .CHARPTR + 1;

    STARTPTR = .CHARPTR;


    ! If this took us to the carriage-return, return the terminator operator.
    !
    IF .CHARPTR[0] EQL CAR_RET
    THEN
	BEGIN
	TERMINATOR_CODE = TOKEN$K_TERM_NONE;
	TERMINATOR_LENGTH = 0;
	RETURN TERMINATOR_TOKEN;
	END;


    ! Check for a valid Terminator Token.  The TERM_LIST parameter lists all
    ! valid terminator tokens for the current expression.  If we have one of
    ! those here, we set TERMINATOR_CODE appropriately and return the termi-
    ! nator operator.
    !
    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_TERMINATOR]
    THEN
	BEGIN


	! Loop over all allowed terminators in this context.
	!
	INCR I FROM 0 TO .TERM_LIST[-1] - 1 DO
	    BEGIN
	    TERMPTR = .TERM_LIST[.I] + TABLEBASE;


	    ! Check whether this terminator matches what we have in the input
	    ! line being scanned.
	    !
	    CHECK_THIS_TERMINATOR:
		BEGIN
		IF CH$NEQ(.TERMPTR[TOKEN$B_LENGTH], TERMPTR[TOKEN$A_NAME],
			.TERMPTR[TOKEN$B_LENGTH], .CHARPTR, 0)
		THEN
		    LEAVE CHECK_THIS_TERMINATOR;

		IF .CHARTBL[.CHARPTR[0], CHRTBL$V_ALPHABETIC] AND
		   (.CHARTBL[.CHARPTR[.TERMPTR[TOKEN$B_LENGTH]],
						CHRTBL$V_IDENT_MIDDLE] OR
		    .CHARTBL[.CHARPTR[.TERMPTR[TOKEN$B_LENGTH]],
						CHRTBL$V_IDENT_END])
		THEN
		    LEAVE CHECK_THIS_TERMINATOR;

		IF .TERMPTR[TOKEN$V_BALANCED_PARENS] AND (.PAREN_NESTING NEQ 0)
		THEN
		    LEAVE CHECK_THIS_TERMINATOR;

		IF .TERMPTR[TOKEN$V_MUST_BE_SINGLE] AND
		   (.CHARPTR[0] EQL .CHARPTR[1])
		THEN
		    LEAVE CHECK_THIS_TERMINATOR;


		! This is a valid terminator in this context.  As a side-effect
		! save the terminator code in TERMINATOR_CODE and its length in
		! TERMINATOR_LENGTH.  Then return the terminator operator.
		!
		TERMINATOR_CODE = .TERMPTR[TOKEN$W_CODE];
		TERMINATOR_LENGTH = .TERMPTR[TOKEN$B_LENGTH];
		RETURN TERMINATOR_TOKEN;

		END;			! End of CHECK_THIS_TERMINATOR block

	    END;			! End of INCR loop over terminators

	END;				! End of terminator checking


    ! Handle any language-specific special cases that must be sorted out before
    ! we go through the normal lexical scanning code below.  Here we check for
    ! those tokens that would be scanned incorrectly if we went through the
    ! normal scanning mechanisms below.
    ! 
    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_SPECIAL_CASE]
    THEN
	BEGIN
	CASE .DBG$GB_LANGUAGE FROM DBG$K_MIN_LANGUAGE TO DBG$K_MAX_LANGUAGE OF
	    SET


	    ! Handle PL/I.  Here we special-case the -> operator.  We need to
	    ! mark "-" as being a single-character operator in the character
	    ! table so it does not get combined with itself or other operator
	    ! characters in expressions.  Hence we must special-case the one
	    ! situation where it can be combined, namely in "->".
	    !
	    [DBG$K_PLI]:
		BEGIN
		IF (.CHARPTR[0] EQL '-') AND (.CHARPTR[1] EQL '>')
		THEN
		    BEGIN
		    CHARPTR = .CHARPTR + 2;
		    RETURN PLI_ARROW_TOKEN;
		    END;

		END;


	    ! There are no special cases for any other language.  If we get
	    ! here, something is wrong (the code or character table is wrong.)
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGPARSER\LEXICAL_SCANNER 10');

	    TES;

	END;


    ! If the next token is one of the "special" symbols ".", "\", or "^", 
    ! and an operand is expected here, see if this token
    ! could mean "current location", "current value", or "previous
    ! location".  If so, return the appropriate Identifier Lexical Token Entry
    ! but change the name to %CURLOC, %CURVAL, or %PREVLOC.  
    !
    IF .OPERAND_EXPECTED AND .CHARTBL[.CHARPTR[0], CHRTBL$V_SPECIAL_SYMBOL]
    THEN
	BEGIN
	CHARPTR = .CHARPTR + 1;
	WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_SPACE] DO
	    CHARPTR = .CHARPTR + 1;


    	! Handle the special case where the user has said
    	! SET BREAK . DO ( command-list). In this case we assume that
    	! the "." means "current location".
    	!
    	IF .DBG$GB_SET_BREAK_FLAG
    	THEN
    	    BEGIN
    	    IF (.CHARPTR[0] EQL 'D') AND 
    	       (.CHARPTR[1] EQL 'O') AND
    	       ((.CHARPTR[2] EQL ' ') OR (.CHARPTR[2] EQL '('))
    	    THEN
    		RETURN CURLOC_TOKEN;
    	    IF (.CHARPTR[0] EQL 'W') AND
    	       (.CHARPTR[1] EQL 'H') AND
    	       (.CHARPTR[2] EQL 'E') AND
    	       (.CHARPTR[3] EQL 'N') AND
    	       ((.CHARPTR[4] EQL ' ') OR (.CHARPTR[4] EQL '('))
    	    THEN
    		RETURN CURLOC_TOKEN;
    	    END;
    

    	! We need to determine whether this special symbol is really one
    	! of the debugger permanent symbols for previous, current, or next
    	! location, or whether it is a language operator.
    	!
    	! For "\", the only other possible meaning is as the start of a pathname.
    	! (not the middle, since then "OPERAND_EXPECTED" would be false).
    	! In that case, the next character must be the start of an identifier
    	! or a "%" sign in %NAME. So in order to
    	! intepret "\" as current value, we check here that the next token
    	! is not the start of an identifier or a "%". (Note - in C, "%" is
    	! an operator, so for example "\%3" means "current location mod 3",
    	! so C is special-cased below). 
    	!
    	! "^" is an operator in some languages. The only one where it is
    	! a prefix operator (the case that causes ambiguities)
    	! is PLI, where it means "not". We resolve this by simply 
    	! assuming that "^" means prevloc if this is an address expression,
    	! and means "not" in a language expression. This essentially
    	! disallows "^" for prevloc in language expressions (%PREVLOC can
    	! be used instead).
    	!
    	! "." is highly overloaded. In many languages it can be the start
    	! of a floating point number, so we check for the next character
    	! being a digit here. It can also be the indirection operator
    	! in an address expression. We check for the next character being
    	! "(", ".", or "\", and if so, assume that the dot means 
    	! indirection and not current location.
    	!
	IF (NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_START]) AND
	   (NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_DIGIT]) AND
    	   (.CHARPTR[0] NEQ '%' OR 
    	   (.DBG$GB_LANGUAGE EQL DBG$K_C AND (NOT .ADDRESS_EXPRESSION)))
	THEN
	    BEGIN
	    IF .STARTPTR[0] EQL '\' THEN RETURN CURVAL_TOKEN;
	    IF (.STARTPTR[0] EQL '^') AND
    	      ((.DBG$GB_LANGUAGE NEQ DBG$K_PLI) OR .ADDRESS_EXPRESSION)
    	    THEN
    		RETURN PREVLOC_TOKEN;
	    IF .STARTPTR[0] EQL '.' AND
	       NOT ((.CHARPTR[0] EQL '(') OR
		    (.CHARPTR[0] EQL '.') OR
		    (.CHARPTR[0] EQL '\'))
	    THEN
		RETURN CURLOC_TOKEN;

	    END;

	CHARPTR = .STARTPTR;
	END;


    ! If we are expecting an operand next, check for the special DEBUG symbols
    ! that begin with a percent sign "%".  This includes %LINE, %LABEL, %NAME,
    ! and all the register names.
    !
    IF (.CHARPTR[0] EQL '%') AND
       .OPERAND_EXPECTED     AND
       .CHARTBL[.CHARPTR[1], CHRTBL$V_ALPHABETIC]
    THEN
	BEGIN


	! Accumulate the identifier after the "%"-sign.
	!
	CHARPTR = .CHARPTR + 1;
	TOKENLEN = 1;
	TOKENBUFFER[1] = '%';
	WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_ALPHABETIC] OR
	      .CHARTBL[.CHARPTR[0], CHRTBL$V_DIGIT]
	DO
	    BEGIN
	    TOKENLEN = .TOKENLEN + 1;
	    TOKENBUFFER[.TOKENLEN] = .CHARPTR[0];
	    CHARPTR = .CHARPTR + 1;
	    END;

	TOKENBUFFER[0] = .TOKENLEN;


	! Now look up the "%"-symbol in the DEBUG Percent Table.
	!
	INDEX = PERCENT_NOFIND;
	INCR I FROM 0 TO .PERCENT_TABLE[-1] - 1 DO
	    BEGIN
	    NAMEPTR = .PERCENT_TABLE[.I] + TABLEBASE;
	    IF CH$EQL(.NAMEPTR[1], NAMEPTR[2], .TOKENLEN, TOKENBUFFER[1], 0)
	    THEN
		BEGIN
		INDEX = .NAMEPTR[0];
		EXITLOOP;
		END;

	    END;


	! Now do whatever further processing is appropriate for this "%"-symbol.
	!
	CASE .INDEX FROM PERCENT_NOFIND TO PERCENT_IDENT OF
	    SET


	    ! Handle the No-Find case.  We do not recognize this "%"-symbol,
	    ! so we do nothing.
	    !
	    [PERCENT_NOFIND]:
		0;


	    ! Handle %LINE and %LABEL.  Here we pick up the line or label
	    ! number that follows the keyword and construct an Identifier
	    ! Token Entry for the line or label and return that to the caller.
	    !
	    [PERCENT_LINE,
	     PERCENT_LABEL]:
		BEGIN


		! Set up the fully spelled out keyword (%LINE or %LABEL) in
		! TOKENBUFFER and set up the appropriate error message code.
		!
		IF .INDEX EQL PERCENT_LINE
		THEN
		    BEGIN
		    CH$MOVE(6, UPLIT BYTE(%ASCII '%LINE '), TOKENBUFFER[1]);
		    TOKENLEN = 6;
		    ERRORMSG = DBG$_SYNERRLINE;
		    END

		ELSE
		    BEGIN
		    CH$MOVE(7, UPLIT BYTE(%ASCII '%LABEL '), TOKENBUFFER[1]);
		    TOKENLEN = 7;
		    ERRORMSG = DBG$_SYNERRLABEL;
		    END;


		! Check for and scan past the blanks after the %LINE or %LABEL
		! keyword and before the line or label number.
		!
		IF NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_SPACE] THEN SIGNAL(.ERRORMSG);
		WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_SPACE] DO
		    CHARPTR = .CHARPTR + 1;


		! Check that a digit follows.  Then strip off leading zeroes.
		!
		IF NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_DIGIT]
		THEN
		    SIGNAL(.ERRORMSG);

		WHILE (.CHARPTR[0] EQL '0') AND
		      .CHARTBL[.CHARPTR[1], CHRTBL$V_DIGIT]
		DO
		    CHARPTR = .CHARPTR + 1;


		! Now pick up the line or label number and copy all the digits
		! into TOKENBUFFER.
		!
		WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_DIGIT] DO
		    BEGIN
		    IF .TOKENLEN GEQ 255 THEN SIGNAL(.ERRORMSG);
		    TOKENLEN = .TOKENLEN + 1;
		    TOKENBUFFER[.TOKENLEN] = .CHARPTR[0];
		    CHARPTR = .CHARPTR + 1;
		    END;


		! If we are picking up a line number, we also allow a dot
		! followed by a statement number (e.g., %LINE 10.2).  Pick up
		! the statement number if present.
		!
		IF (.INDEX EQL PERCENT_LINE) AND (.CHARPTR[0] EQL '.')
		THEN
		    BEGIN


		    ! Check for valid syntax and pick up the dot.
		    !
		    IF (NOT .CHARTBL[.CHARPTR[1], CHRTBL$V_DIGIT]) OR
		       (.TOKENLEN GEQ 255)
		    THEN
			SIGNAL(.ERRORMSG);

		    TOKENLEN = .TOKENLEN + 1;
		    TOKENBUFFER[.TOKENLEN] = '.';
		    CHARPTR = .CHARPTR + 1;


		    ! Strip off leading zeroes.
		    !
		    WHILE (.CHARPTR[0] EQL '0') AND
			  .CHARTBL[.CHARPTR[1], CHRTBL$V_DIGIT]
		    DO
			CHARPTR = .CHARPTR + 1;


		    ! Pick up the statement number itself.
		    !
		    WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_DIGIT] DO
			BEGIN
			IF .TOKENLEN GEQ 255 THEN SIGNAL(.ERRORMSG);
			TOKENLEN = .TOKENLEN + 1;
			TOKENBUFFER[.TOKENLEN] = .CHARPTR[0];
			CHARPTR = .CHARPTR + 1;
			END;

		    END;


		! We now have a complete %LINE or %LABEL name string.  Create
		! and return an Identifier Token Entry for it.
		!
		TOKENBUFFER[0] = .TOKENLEN;
		RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);

		END;			! End of %LINE and %LABEL processing


	    ! Handle %NAME.  Here we pick up the identifier symbol that follows
	    ! (directly or in quotes) and return an Identifier Token for it.
	    !
	    [PERCENT_NAME]:
		BEGIN


		! Scan past any blanks after the %NAME keyword and before the
		! actual name string itself.  Then set STARTPTR to that place.
		!
		WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_SPACE] DO
		    CHARPTR = .CHARPTR + 1;

		STARTPTR = .CHARPTR;


		! If the name string starts with a quote character, pick up all
		! characters in the quoted string and move them to TOKENBUFFER.
		!
		IF .CHARTBL[.CHARPTR[0], CHRTBL$V_STRING_QUOTE]
		THEN
		    SCAN_QUOTED_STRING(TOKENBUFFER, TOKEN_TYPE)


		! Otherwise, pick up any consecutive string of characters which
		! are allowed anywhere in identifiers.  For most languages,
		! this is any string composed of A - Z, 0 - 9, $, and _.
		!
		ELSE
		    BEGIN
		    WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_START]  OR
			  .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE] OR
			  .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END]
		    DO
			CHARPTR = .CHARPTR + 1;

		    TOKENLEN = .CHARPTR - .STARTPTR;
		    IF .TOKENLEN EQL 0 THEN SIGNAL(DBG$_NAMSTRMIS);
		    CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
		    TOKENBUFFER[0] = .TOKENLEN;
		    END;


		! Create and return an Identifier Token Entry for the symbol.
		!
		RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);

		END;			! End of %NAME processing


	    ! Handle "%"-symbol names that we recognize as identifiers.  This
	    ! includes all the register names.  Return an Identifier Token.
	    !
	    [PERCENT_IDENT]:
		RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);


	    ! Handle the %DEC operator.  This sets the radix to decimal for
	    ! the expression which constitutes its operand.
	    !
	    [PERCENT_DEC]:
		RETURN RADIX_OP_DEC;


	    ! Handle the %HEX operator.  This sets the radix to hexadecimal for
	    ! the expression which constitutes its operand.
	    !
	    [PERCENT_HEX]:
		RETURN RADIX_OP_HEX;


	    ! Handle the %OCT operator.  This sets the radix to octal for
	    ! the expression which constitutes its operand.
	    !
	    [PERCENT_OCT]:
		RETURN RADIX_OP_OCT;


	    ! Handle the %BIN operator.  This sets the radix to binary for
	    ! the expression which constitutes its operand.
	    !
	    [PERCENT_BIN]:
		RETURN RADIX_OP_BIN;


	    ! Any other CASE index is an internal DEBUG error.
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGPARSER\LEXICAL_SCANNER 20');

	    TES;


	! This is the end of the "%"-symbol processing.  If we have not recog-
	! nized the symbol yet, it is not a DEBUG special symbol so we reset
	! CHARPTR to point to the "%" sign again.  The hope is that we will
	! recognize it as a valid token later in the Lexical Scanner.
	!
	CHARPTR = .STARTPTR;

	END;				! End of "%"-symbol scanning


    ! See if this token is a quoted character string.  Quoted character strings
    ! in this context are defined to start with a quote character (usually " or
    ! '), to continue as a string of zero or more non-quote characters, and to
    ! be terminated by a quote character.  The starting and ending quote char-
    ! acters must be the same character and that quote character is represented
    ! within the string by two consecutive quote characters.  If we find such
    ! a quoted string, we accumulate it and return a String Constant Token.
    !
    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_STRING_QUOTE]
    THEN
	BEGIN
	SCAN_QUOTED_STRING(TOKENBUFFER, TOKEN_TYPE);
	RETURN CREATE_OPERAND_TOKEN(.TOKEN_TYPE, TOKENBUFFER);
	END;


    ! See if this token is a numeric constant.  If so, we pick up the character
    ! representation of the number and return it as a Numeric Constant Lexical
    ! Token Entry.  This scan must be done before the Identifier scan below so
    ! that COBOL integers get interpreted as numbers, not identifiers.
    !
    ! This code simulates a Finite-State Machine (FSM) which accepts any valid
    ! numeric constant in the current language.  The machine is defined by a
    ! state table where each state has a set of allowed transitions to other
    ! states.  Each transition is selected by the next input character and has
    ! an associated action routine defined below.  When a numeric constant has
    ! been recognized, a transition is taken whose action routine builds and
    ! returns a Lexical Token Entry for the numeric constant.
    !
    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_NUMBER_START] AND
       ((NOT .ADDRESS_EXPRESSION) OR (.CHARPTR[0] NEQ '.'))
    THEN
	BEGIN


	! Start at the Start State for the Finite-State Machine that will scan
	! the number according to the rules of the current language.  This
    	! start state is ordinarily zero. If the language is ADA and the radix
    	! is not decimal, however, we start at the B_START_STATE, which is
    	! the entry to the part of the ADA number scanner that picks up
    	! based numbers.  Also, set up the initial number kind based on the 
    	! current radix setting assuming it will be an integer.
	!
	STATE_INDEX = 0;
    	IF (.DBG$GB_LANGUAGE EQL DBG$K_ADA) AND
	   (.EXPRESSION_RADIX NEQ DBG$K_DECIMAL)
	THEN
	    STATE_INDEX = REMEMBER_ADA_B_START_STATE;

	NUMBER_KIND = TOKEN$K_INTEGER;
	IF .EXPRESSION_RADIX EQL DBG$K_HEX
	THEN
	    NUMBER_KIND = TOKEN$K_HEX_INTEGER;

	IF .EXPRESSION_RADIX EQL DBG$K_OCTAL
	THEN
	    NUMBER_KIND = TOKEN$K_OCT_INTEGER;

	IF .EXPRESSION_RADIX EQL DBG$K_BINARY
	THEN
	    NUMBER_KIND = TOKEN$K_BIN_INTEGER;

	BACKUP_NUMBER_KIND = .NUMBER_KIND;


	! Then loop through the machine states, selecting each next state based
	! on the next input character and performing the appropriate action for
	! each transition, until the whole number is picked up.
	!
	WHILE TRUE DO
	    BEGIN


	    ! Get the character class code for the next input character.
    	    ! Small kludge for ADA: In X[1..5], we want to treat ".."
    	    ! as terminating the "1", not as part of the number.
    	    !
	    CLASS = .CHARTBL[.CHARPTR[0], CHRTBL$V_NUMBER_CLASS];
    	    IF .DBG$GB_LANGUAGE EQL DBG$K_ADA
    	    THEN
    		IF .CHARPTR[0] EQL '.' AND .CHARPTR[1] EQL '.'
    		THEN
    		    CLASS = NUMST$K_CLASS_OTHER;


	    ! Loop through the transitions from this state until we find a
	    ! transition for this character class or for NUMST$K_CLASS_OTHER
	    ! (the class of all other characters).  Pick up the action index
	    ! and next state associated with this transition of the Finite-
	    ! State Machine.
	    !
	    WHILE (.STATE_TABLE[.STATE_INDEX, NUMST$B_CHAR_CLASS] NEQ
						       NUMST$K_CLASS_OTHER) AND
		  (.STATE_TABLE[.STATE_INDEX, NUMST$B_CHAR_CLASS] NEQ .CLASS)
	    DO
		STATE_INDEX = .STATE_INDEX + 1;

	    ACTION = .STATE_TABLE[.STATE_INDEX, NUMST$B_ACTION];
	    STATE_INDEX = .STATE_TABLE[.STATE_INDEX, NUMST$W_NEXT_STATE];


	    ! Case on the action code to select the appropriate semantic
	    ! action routine for this state transition.
	    !
	    CASE .ACTION FROM NUMST$K_MIN_ACTION TO NUMST$K_MAX_ACTION OF
		SET


		! Some state transitions require no semantic action, so we
		! provide a do-nothing action routine.
		!
		[NUMST$K_ACT_DO_NOTHING]:
		    0;


		! Go past a digit in the integer part of the number.  Set the
		! digit backup pointer to the last good digit seen (this one).
		!
		[NUMST$K_ACT_GO_PAST_DIGIT]:
		    BACKUP_DIGIT_PTR = .CHARPTR;


		! At the decimal point, mark that we have a floating-point
		! number.
		!
		[NUMST$K_ACT_MARK_DEC_PT]:
	            NUMBER_KIND = TOKEN$K_FLOATING;


		! At a fraction digit, set the backup pointer to the last good
		! digit seen (i.e., this one) and note that we really have a
		! floating-point number even if we must back up the scan.
		!
		[NUMST$K_ACT_GO_PAST_FRAC]:
		    BEGIN
		    BACKUP_DIGIT_PTR = .CHARPTR;
		    BACKUP_NUMBER_KIND = TOKEN$K_FLOATING;
		    END;


		! Mark that we found an E exponent marker.
		!
		[NUMST$K_ACT_MARK_E_EXP]:
		    NUMBER_KIND = TOKEN$K_EXP_E_FLOAT;


		! Mark that we found a D exponent marker.
		!
		[NUMST$K_ACT_MARK_D_EXP]:
		    NUMBER_KIND = TOKEN$K_EXP_D_FLOAT;


		! Mark that we found a G exponent marker.
		!
		[NUMST$K_ACT_MARK_G_EXP]:
		    NUMBER_KIND = TOKEN$K_EXP_G_FLOAT;


		! Mark that we found a Q exponent marker.
		!
		[NUMST$K_ACT_MARK_Q_EXP]:
		    NUMBER_KIND = TOKEN$K_EXP_Q_FLOAT;


		! At a pack decimal digit, set the backup pointer to the last good
		! digit seen (i.e., this one) and note that we really have a
		! pack decimal number even if we must back up the scan.
		!
		[NUMST$K_ACT_GO_PAST_PACK]:
		    BEGIN
		    BACKUP_DIGIT_PTR = .CHARPTR;
    		    IF NOT (.NUMBER_KIND EQL TOKEN$K_HEX_INTEGER OR
    		            .NUMBER_KIND EQL TOKEN$K_OCT_INTEGER OR
    		            .NUMBER_KIND EQL TOKEN$K_BIN_INTEGER)
    		    THEN
    		        BACKUP_NUMBER_KIND = TOKEN$K_PACK_DECIMAL;
		    END;


		! At a pack decimal digit, set the backup pointer to the last good
		! digit seen (i.e., this one) and note that we really have a
		! pack decimal number even if we must back up the scan.
		!
		[NUMST$K_ACT_GO_PAST_PACK_FRAC]:
		    BEGIN
		    BACKUP_DIGIT_PTR = .CHARPTR;
    		    IF NOT (.NUMBER_KIND EQL TOKEN$K_HEX_INTEGER OR
    		            .NUMBER_KIND EQL TOKEN$K_OCT_INTEGER OR
    		            .NUMBER_KIND EQL TOKEN$K_BIN_INTEGER)
    		    THEN
		        BACKUP_NUMBER_KIND = TOKEN$K_PACK_DECIMAL
    		    ELSE
    			BACKUP_NUMBER_KIND = TOKEN$K_FLOATING;

		    END;


		! We have a number but we scanned too far.  This can happen in
		! FORTRAN with "25.EQ." where we pick up the "." and "E" since
		! that could be part of a number.  Back up the scan pointer to
		! the true end of the number and return the appropriate Numeric
		! Constant Lexical Token Entry.
		!
		[NUMST$K_ACT_BACKUP_PTRS]:
		    BEGIN
		    NUMBER_KIND = .BACKUP_NUMBER_KIND;
		    CHARPTR = .BACKUP_DIGIT_PTR + 1;
		    TOKENLEN = .CHARPTR - .STARTPTR;
		    IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_NUMCONLONG);
		    TOKENBUFFER[0] = .TOKENLEN;
		    CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
		    RETURN CREATE_OPERAND_TOKEN(.NUMBER_KIND, TOKENBUFFER);
		    END;


		! We have a complete and valid numeric constant.  Create a
		! Numeric Constant Lexical Token Entry for it and return a
		! pointer to that Token Entry to the caller.
		!
		[NUMST$K_ACT_GOT_NUMBER]:
		    BEGIN
		    TOKENLEN = .CHARPTR - .STARTPTR;
		    IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_NUMCONLONG);
		    TOKENBUFFER[0] = .TOKENLEN;
		    CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
		    RETURN CREATE_OPERAND_TOKEN(.NUMBER_KIND, TOKENBUFFER);
		    END;


		! We have a complete and valid pack decimal constant.  Create a
		! Numeric Constant Lexical Token Entry for it and return a
		! pointer to that Token Entry to the caller.  
		!
		[NUMST$K_ACT_GOT_PACK_NUMBER]:
		    BEGIN
    		    IF NOT (.NUMBER_KIND EQL TOKEN$K_HEX_INTEGER OR
    		            .NUMBER_KIND EQL TOKEN$K_OCT_INTEGER OR
    		            .NUMBER_KIND EQL TOKEN$K_BIN_INTEGER)
    		    THEN
    		        NUMBER_KIND = TOKEN$K_PACK_DECIMAL;

		    TOKENLEN = .CHARPTR - .STARTPTR;
		    IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_NUMCONLONG);
		    TOKENBUFFER[0] = .TOKENLEN;
		    CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
		    RETURN CREATE_OPERAND_TOKEN(.NUMBER_KIND, TOKENBUFFER);
		    END;


		! This is not a valid numeric constant.  Back up CHARPTR to the
		! start of the lexical token and exit the Number Scanner code.
		!
		[NUMST$K_ACT_NOT_NUMBER]:
		    BEGIN
		    CHARPTR = .STARTPTR;
		    EXITLOOP;
		    END;


		! In cobol, 12A will be a name if the mode setting is not hex.
		!
		[NUMST$K_ACT_COB_CKHEX]:
		    BEGIN
		    IF .EXPRESSION_RADIX NEQ DBG$K_HEX
		    THEN
			BEGIN
		        CHARPTR = .STARTPTR;
		        EXITLOOP;
			END;

		    END;


		! In COBOL, a number such as 123 can be a name.  Such a name
		! must be entered as %NAME 123.  However, if we find a number
		! followed by a valid identifier character, as in 123A or 12-3,
		! then we actually have an identifier, so we exit the number
		! scanning loop without returning a number token.  If the
		! number ended with any other character, we return a valid
		! number token.
		!
		[NUMST$K_ACT_COB_CKNUM]:
		    BEGIN
		    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_START]  OR
		       .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE] OR
		       .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END]
		    THEN
			BEGIN
		        CHARPTR = .STARTPTR;
		        EXITLOOP;
			END;

		    IF NOT ((.NUMBER_KIND EQL TOKEN$K_HEX_INTEGER) OR
			    (.NUMBER_KIND EQL TOKEN$K_OCT_INTEGER) OR
			    (.NUMBER_KIND EQL TOKEN$K_BIN_INTEGER))
		    THEN
			NUMBER_KIND = TOKEN$K_PACK_DECIMAL;

		    TOKENLEN = .CHARPTR - .STARTPTR;
		    IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_NUMCONLONG);
		    TOKENBUFFER[0] = .TOKENLEN;
		    CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
		    RETURN CREATE_OPERAND_TOKEN(.NUMBER_KIND, TOKENBUFFER);
    		    END;


    		! Save the base of a number in ADA, where a number can be
    		! of the form base#number.
    		!
    		[NUMST$K_ACT_SAVE_BASE]:
    		    0;	!<<<-----------------------------


		! Any other action index constitutes an internal error.
		!
		[NUMST$K_ACT_GIVE_ERROR,
		 INRANGE,
		 OUTRANGE]:
		    $DBG_ERROR('DBGPARSER\LEXICAL_SCANNER 30');

		TES;


	    ! Go on to the next character in the buffer and loop.
	    !
	    CHARPTR = .CHARPTR + 1;

	    END;			! End of WHILE loop over number states

	END;				! End of numeric constant scanning


    ! See if this token is an identifier according to the rules of the current
    ! language.  If so, pick up the whole identifier, see if this identifier is
    ! actually an operator (such as AND or MOD) in the current language, and
    ! return either an Identifier Token or an Operator Token.
    !
    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_START]
    THEN
	BEGIN


	! We have a valid start character for an identifier in the current
	! language.  Now scan through the identifier as long as we have valid
	! middle characters and set ENDPTR each time we find a valid end char-
	! acter for an identifier.  At the end of the scan we set CHARPTR to
	! point to the first character after the identifier end character.
	!
	ENDPTR = .CHARPTR - 1;
	WHILE TRUE DO
	    BEGIN
	    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END]
	    THEN
		BEGIN
		ENDPTR = .CHARPTR;
		IF NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE] THEN EXITLOOP;
		END;

	    CHARPTR = .CHARPTR + 1;
	    IF (NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE]) AND
	       (NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END])
	       THEN EXITLOOP;
	    END;

	CHARPTR = .ENDPTR + 1;


	! Copy the identifier name to TOKENBUFFER.
	!
	TOKENLEN = .CHARPTR - .STARTPTR;
	IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_IDENTLONG);
	CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
	TOKENBUFFER[0] = .TOKENLEN;


	! If the language is C, then we want to make sure that the identifier
	! preserves the original casing (upper/lower). This is because
	! in C, upper case XXX is a different variable from lower case xxx,
	! for example. So we copy characters from the original command 
	! buffer instead of the up-cased command buffer.
    	! We use a flag "CASING_SIGNIFICANT" which is set in the SET_LANGUAGE
    	! routine for this. At present, C is the only language that sets
    	! this flag to TRUE.
	!
	IF .CASING_SIGNIFICANT
	THEN
	    BEGIN
	    IF (.STARTPTR LSS .DBG$GL_UPCASE_COMMAND_PTR[0]) OR
	       (.STARTPTR GTR .DBG$GL_UPCASE_COMMAND_PTR[1])
    	    THEN
    		$DBG_ERROR('DBGPARSER\DBG$LEXICAL_SCANNER 40');

	    NEW_STARTPTR = (.STARTPTR - .DBG$GL_UPCASE_COMMAND_PTR[0]) + 
		 	    .DBG$GL_ORIG_COMMAND_PTR;
	    CH$MOVE(.TOKENLEN, .NEW_STARTPTR, TOKENBUFFER[1]);
	    END;


	! See if this identifier is actually the name of an operator.  We scan
	! a language-specific operator table to determine this.  If so, return
	! the corresponding Operator Token.
	!
	BEST_TOKEN_FOUND = 0;
	INCR I FROM 0 TO .IDENT_OPERATOR_TABLE[-1] - 1 DO
	    BEGIN
	    TOKEN = .IDENT_OPERATOR_TABLE[.I] + TABLEBASE;
	    IF CH$EQL(.TOKEN[TOKEN$B_OPLEN],
		TOKEN[TOKEN$A_OPNAME], .TOKENLEN, TOKENBUFFER[1], 0)
	    THEN
		BEGIN
		IF (.OPERAND_EXPECTED AND
			(.TOKEN[TOKEN$B_KIND] EQL TOKEN$K_PREFIX_OP)) OR
		   ((NOT .OPERAND_EXPECTED) AND
			(.TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_PREFIX_OP))
		THEN
		    RETURN .TOKEN

		ELSE
		    BEST_TOKEN_FOUND = .TOKEN;

		END;

	    END;

	IF .BEST_TOKEN_FOUND NEQ 0 THEN RETURN .BEST_TOKEN_FOUND;


	! See if this identifier is the name of a built-in function.  We scan
	! a language-specific built-in function table to determine this.  If
	! so, return the corresponding Operand Token.
	!
	BEST_TOKEN_FOUND = 0;
	INCR I FROM 0 TO .BIF_TABLE[-1] - 1 DO
	    BEGIN
	    TOKEN = .BIF_TABLE[.I] + TABLEBASE;
	    IF CH$EQL(.TOKEN[TOKEN$B_LENGTH], TOKEN[TOKEN$A_NAME],
                      .TOKENLEN, TOKENBUFFER[1], 0)
	    THEN
		IF .OPERAND_EXPECTED
		THEN
		    RETURN .TOKEN
		ELSE
		    BEST_TOKEN_FOUND = .TOKEN;
	    END;

	IF .BEST_TOKEN_FOUND NEQ 0 THEN RETURN .BEST_TOKEN_FOUND;


	! It is not an operator or a built-in function.  Hence we return an
	! Identifier Token for the symbol.  Note that we do not accept a
	! zero-length identifier (one that has no valid end character).
	!
	IF .TOKENLEN NEQ 0
	THEN
	    RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);

	END;				! End of identifier scanning


    ! See if this token is an operator symbol (such as +, *, /, or :=) in the
    ! current language.  If so, return an Operator Token to the caller.
    !
    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_OPCHAR]
    THEN
	BEGIN


	! Determine where the operator symbol ends.  By classifying the avail-
	! able operator characters as prefix, infix, or postfix characters, we
	! can ensure that we break operator character strings apart at postfix-
	! infix, infix-prefix, and postfix-prefix boundaries.  An operator char-
	! acter which does not fall in any of those classes cannot be combined
	! with other characters and is always a symbol by itself (such as "(").
	!
	WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_OPCHAR_PREFIX] DO
	    CHARPTR = .CHARPTR + 1;

	WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_OPCHAR_INFIX] DO
	    CHARPTR = .CHARPTR + 1;

	WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_OPCHAR_POSTFIX] DO
	    CHARPTR = .CHARPTR + 1;

	IF .CHARPTR EQLU .STARTPTR THEN CHARPTR = .CHARPTR + 1;


	! Copy the operator symbol to TOKENBUFFER.
	!
	TOKENLEN = .CHARPTR - .STARTPTR;
	IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_INVOPSYM);
	TOKENBUFFER[0] = .TOKENLEN;
	CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);


	! We now have an operator symbol in TOKENBUFFER.  Look it up in the
	! operator table for the current language, and if found, return the
	! corresponding Operator Token.  Note that we only accept an operator
	! if it is a Primary operator (which we accept in both language and
	! address expressions) or if we are in a language expression.
	!
	BEST_TOKEN_FOUND = 0;
	INCR I FROM 0 TO .OPCHAR_OPERATOR_TABLE[-1] - 1 DO
	    BEGIN
	    TOKEN = .OPCHAR_OPERATOR_TABLE[.I] + TABLEBASE;
	    IF (.TOKEN[TOKEN$V_PRIMARY] OR (NOT .ADDRESS_EXPRESSION)) AND
	       CH$EQL(.TOKEN[TOKEN$B_OPLEN],
			TOKEN[TOKEN$A_OPNAME], .TOKENLEN, TOKENBUFFER[1], 0)
	    THEN
		BEGIN
		IF (.OPERAND_EXPECTED AND
			(.TOKEN[TOKEN$B_KIND] EQL TOKEN$K_PREFIX_OP)) OR
		   ((NOT .OPERAND_EXPECTED) AND
			(.TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_PREFIX_OP))
		THEN
		    RETURN .TOKEN

		ELSE
		    BEST_TOKEN_FOUND = .TOKEN;

		END;

	    END;


	! If we found an operator but it is not in a valid context (e.g. infix
	! operator when we expect a prefix operator), we return it anyway but
	! only if it cannot be an address expression operator (which might be
	! valid in the current context).
	!
	IF (.BEST_TOKEN_FOUND NEQ 0) AND
	   NOT (.ADDRESS_EXPRESSION AND
		.CHARTBL[.STARTPTR[0], CHRTBL$V_ADDRESS_OP])
	THEN
	    RETURN .BEST_TOKEN_FOUND;


	! There is no such operator.  Reset CHARPTR to point to the start of
	! the token to give the code below a chance to make sense of it.
	!
	CHARPTR = .STARTPTR;

	END;				! End of operator scanning


    ! If we are parsing an Address Expression at present, we check for the
    ! specific operators allowed in Address Expressions.  We do not use the
    ! language-specific rules for combining operator characters in this case.
    ! If we find such an operator here, return the corresponding Token Entry.
    ! If not, reset CHARPTR and continue through the Lexical Scanner.
    !
    IF .ADDRESS_EXPRESSION AND .CHARTBL[.CHARPTR[0], CHRTBL$V_ADDRESS_OP]
    THEN
	BEGIN

    	! Special cases for C.
    	!
    	IF (.DBG$GB_LANGUAGE EQL DBG$K_C) AND
	   (.CHARPTR[0] EQL '-') AND (.CHARPTR[1] EQL '>')
	THEN
	    BEGIN
	    CHARPTR = .CHARPTR + 2;
	    RETURN C_ARROW_TOKEN;
	    END;    			
    	IF (.DBG$GB_LANGUAGE EQL DBG$K_C) AND
    	   (.CHARPTR[0] EQL '*') AND
    	   (.OPERAND_EXPECTED)
    	THEN
    	    BEGIN
    	    CHARPTR = .CHARPTR + 1;
    	    RETURN C_INDIRECT_TOKEN;
    	    END;

	! Check for all other address expression operators.
	!
	CHARPTR = .CHARPTR + 1;
	BEST_TOKEN_FOUND = 0;
	INCR I FROM 0 TO .ADDR_EXPR_OPTBL[-1] - 1 DO
	    BEGIN
	    TOKEN = .ADDR_EXPR_OPTBL[.I] + TABLEBASE;
	    IF CH$EQL(.TOKEN[TOKEN$B_OPLEN],
			TOKEN[TOKEN$A_OPNAME], 1, STARTPTR[0], 0)
	    THEN
		BEGIN
		IF (.OPERAND_EXPECTED AND
			(.TOKEN[TOKEN$B_KIND] EQL TOKEN$K_PREFIX_OP)) OR
		   ((NOT .OPERAND_EXPECTED) AND
			(.TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_PREFIX_OP))
		THEN
		    RETURN .TOKEN

		ELSE
		    BEST_TOKEN_FOUND = .TOKEN;

		END;

	    END;

	IF .BEST_TOKEN_FOUND NEQ 0 THEN RETURN .BEST_TOKEN_FOUND;
	CHARPTR = .STARTPTR;
	END;


    ! So far we have not determined what kind of token we have here.  We thus
    ! enter some language-specific code in a last-ditch effort to figure out
    ! what kind of token we have.  If the language-specific code can recognize
    ! a valid token, it returns a Lexical Token Entry for it.
    !
    CASE .DBG$GB_LANGUAGE FROM DBG$K_MIN_LANGUAGE TO DBG$K_MAX_LANGUAGE OF
	SET


	! Handle Fortran.  Here we pick up the operators of the form .XX. or
	! .XXX. (such as .EQ., .NOT., etc.) and return the corresponding
	! Operator Token.  These operators are looked up in the FORTRAN
	! Special Operator Table.
	!
	[DBG$K_FORTRAN]:
	    BEGIN


    	    ! Check for . as indirection operator in address expressions.
    	    !
    	    IF .ADDRESS_EXPRESSION AND .OPERAND_EXPECTED AND
    	       (.CHARPTR[0] EQL '.')
    	    THEN
    		BEGIN
    		CHARPTR = .CHARPTR + 1;
    		RETURN FORTRAN_INDIRECT_TOKEN;
    		END;


    	    ! See if we have one of the FORTRAN relational or boolean
    	    ! operators.
    	    !
	    WHILE .CHARTBL[.CHARPTR[1], CHRTBL$V_ALPHABETIC] DO
		CHARPTR = .CHARPTR + 1;

	    CHARPTR = .CHARPTR + 2;
	    INCR I FROM 0 TO .FORTRAN_SPECIAL_OPTBL[-1] - 1 DO
		BEGIN
		TOKEN = .FORTRAN_SPECIAL_OPTBL[.I] + TABLEBASE;
		IF CH$EQL(.TOKEN[TOKEN$B_OPLEN], TOKEN[TOKEN$A_OPNAME],
					.CHARPTR - .STARTPTR, .STARTPTR, 0)
		THEN
		    RETURN .TOKEN;

		END;


    	    ! Pick up FORTRAN Predefined Constant.
    	    !
	    INCR I FROM 0 TO .PRIDTBL[-1] - 1 DO
		BEGIN
		PRID = .PRIDTBL[.I] + TABLEBASE;
		IF CH$EQL(.PRID[PRID$B_LENGTH], PRID[PRID$A_NAME],
					.CHARPTR - .STARTPTR, .STARTPTR, 0)
		THEN
		    BEGIN
		    CH$MOVE(.PRID[PRID$B_LENGTH], PRID[PRID$A_NAME], TOKENBUFFER[1]);
		    TOKENBUFFER[0] = .PRID[PRID$B_LENGTH];
		    RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);
		    END;

		END;


    	    ! Return "." as the FORTRAN record component selection operator.
    	    !
    	    IF (NOT .OPERAND_EXPECTED) AND (.STARTPTR[0] EQL '.')
    	    THEN
    		BEGIN
    		CHARPTR = .STARTPTR + 1;
    		RETURN FORTRAN_DOT_TOKEN;
    		END;

	    END;


	! Handle C.  Here we pick up the C operators prefix &, infix &,
	! infix &&, prefix and postfix ++, prefix and postfix --, +, -, and ->.
    	! Possible ambiguities involving these operators must be
	! resolved using C rules, which is what we do here.
	!
	[DBG$K_C]:
	    BEGIN


    	    ! Check for the operators that begin with '&': address-of,
    	    ! bit-and, and short-and.
    	    !
	    IF .CHARPTR[0] EQL '&'
	    THEN
		BEGIN
		CHARPTR = .CHARPTR + 1;
		IF .CHARPTR[0] EQL '&'
		THEN
		    BEGIN
		    CHARPTR = .CHARPTR + 1;
		    RETURN C_AND_TOKEN;
		    END;

		IF .OPERAND_EXPECTED THEN RETURN C_ADDR_OF_TOKEN;
		RETURN C_BIT_AND_TOKEN;
		END;


    	    ! Check for the operators that start with '+': add, pre-increment,
    	    ! and post-increment. (X+Y  ++X  X++)
    	    !
	    IF .CHARPTR[0] EQL '+'
	    THEN
		BEGIN
		CHARPTR = .CHARPTR + 1;
		IF .CHARPTR[0] EQL '+'
		THEN
		    BEGIN
		    CHARPTR = .CHARPTR + 1;
    		    IF .OPERAND_EXPECTED
    		    THEN


    		    	! Since ++ is not supported, put out an 
    		    	! error message to that effect.
    		    	! If it does become supported then 
    		    	! un-comment the commented out code
    		    	! and take out the error signal.
    		    	!	 
    			SIGNAL(DBG$_SIDEFFECT)
    		    	! RETURN C_PRE_INCR_TOKEN

    		    ELSE
    			SIGNAL(DBG$_SIDEFFECT);
    			! RETURN C_POST_INCR_TOKEN;
		    END;

    		RETURN C_ADD_TOKEN;
	        END;


    	    ! Check for the operators that start with '-': subtract, pre-decrement,
    	    ! and post-decrement, unary minus, and ->.
    	    !
	    IF .CHARPTR[0] EQL '-'
	    THEN
		BEGIN
		CHARPTR = .CHARPTR + 1;
		IF .CHARPTR[0] EQL '-'
		THEN
		    BEGIN
		    CHARPTR = .CHARPTR + 1;
    		    IF .OPERAND_EXPECTED
    		    THEN


    		    	! Since -- is not supported, put out an 
    		    	! error message to that effect.
    		    	! If it does become supported then 
    		    	! un-comment the commented out code
    		    	! and take out the error signal.
    		    	!	 
    			SIGNAL(DBG$_SIDEFFECT)
		        ! RETURN C_PRE_DECR_TOKEN
    		    ELSE
    			SIGNAL(DBG$_SIDEFFECT);
    			! RETURN C_POST_INCR_TOKEN;
		    END;

    		IF .CHARPTR[0] EQL '>'
    		THEN
    		    BEGIN
    		    CHARPTR = .CHARPTR + 1;
    		    RETURN C_ARROW_TOKEN;
    		    END;    			

    		IF .OPERAND_EXPECTED
    		THEN
    		    RETURN C_MINUS_TOKEN
    		ELSE
    		    RETURN C_SUB_TOKEN;
	        END;

    	    END;


    	! Handle RPG.  The special indicator names start with "*".
    	!
    	[DBG$K_RPG]:
    	    BEGIN
    	    IF .CHARPTR[0] EQL '*'
    	    THEN
    		BEGIN

    		! Pick it up as a name.
    		!
    		IF .OPERAND_EXPECTED
    		THEN
    		    BEGIN
	 	    CHARPTR = .CHARPTR + 1;
           	    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_START]
    		    THEN
			BEGIN


			! We have a valid start character for an identifier in the current
			! language.  Now scan through the identifier as long as we have valid
			! middle characters and set ENDPTR each time we find a valid end char-
			! acter for an identifier.  At the end of the scan we set CHARPTR to
			! point to the first character after the identifier end character.
			!
			ENDPTR = .CHARPTR - 2;
			WHILE TRUE DO
	    		    BEGIN
	    		    IF .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END]
	    		    THEN
				BEGIN
				ENDPTR = .CHARPTR;
				IF NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE] THEN EXITLOOP;
				END;

	    		    CHARPTR = .CHARPTR + 1;
	    		    IF (NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE]) AND
	       		       (NOT .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END])
	       		    THEN EXITLOOP;
	    		    END;

			CHARPTR = .ENDPTR + 1;


			! Copy the identifier name to TOKENBUFFER.
			!
			TOKENLEN = .CHARPTR - .STARTPTR;
			IF .TOKENLEN GTR 255 THEN SIGNAL(DBG$_IDENTLONG);
			CH$MOVE(.TOKENLEN, .STARTPTR, TOKENBUFFER[1]);
			TOKENBUFFER[0] = .TOKENLEN;
    			RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);
    			END;
    		    END

    		! Pick it up as an operator.
    		!
    		ELSE
    		    BEGIN
    		    CHARPTR = .CHARPTR + 1;
    		    RETURN RPG_MULTIPLY_TOKEN;
    		    END;

    		END;

    	    END;


	! Handle Ada.  Here we distinguish the tick operator from the single
	! quote--both are represented by the character "'".  If it is a tick,
	! we return the Tick Operator Token and if it is a single quote, we
	! pick up the character it quotes and return a Character Constant Token.
	!
	[DBG$K_ADA]:
	    BEGIN

	    IF .CHARPTR[0] EQL ''''
	    THEN
		BEGIN


		! If we are expecting an infix or postfix operator, this must
		! be the "tick" character, which begins one of the postfix
    		! tick operators ("'FIRST", "'LAST", ...).
		!
		IF NOT .OPERAND_EXPECTED 
    		THEN
    		    BEGIN

    		    ! Make a copy of the tick token.
    		    !
		    TOKEN = DBG$GET_TEMPMEM (TOKEN$K_FIXED_SIZE_LONG + 4);
		    CH$MOVE (TOKEN$K_FIXED_SIZE_BYTE+1,ADA_TICK_TOKEN,.TOKEN);

    		    ! Look up which tick operator this is.
    		    !
    		    INCR INDEX FROM TOKEN$K_TICK_MIN TO TOKEN$K_TICK_MAX DO
    			BEGIN

    			NAMEPTR = .ADA_TICK_TABLE[.INDEX] + TABLEBASE;

    			IF CH$EQL (.NAMEPTR[0], NAMEPTR[1], .NAMEPTR[0], CHARPTR[1])
    			THEN
    			    BEGIN
    			    CHARPTR = .CHARPTR + 1 + .NAMEPTR[0];
    			    TOKEN[TOKEN$W_SUBCODE] = .INDEX;
                            TOKEN[TOKEN$B_OPLEN] = .NAMEPTR[0] + 1;
                            CH$COPY(1, CH$PTR(UPLIT('''')), .NAMEPTR[0], NAMEPTR[1],
                                    %C' ', .NAMEPTR[0]+1, TOKEN[TOKEN$A_OPNAME]);

                            ! Look for a left paren that would indicate a
                            ! list of arguments follow the tick operator.
                            ! If a paren is found, the subcode value is set
                            ! set to the corresponding tick operator type by
                            ! adding 1 to it.  Also, the CHARPTR will be
                            ! updated to pointer at the character just past
                            ! the paren.
                            !
                            WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_SPACE] DO
                                CHARPTR = .CHARPTR + 1;

                            IF .CHARPTR[0] EQL '('
                            THEN
                                BEGIN
                                TOKEN[TOKEN$V_ARGUMENT_LIST] = TRUE;
    			        CHARPTR = .CHARPTR + 1;
                                END
                            ELSE
                                TOKEN[TOKEN$V_ARGUMENT_LIST] = FALSE;

    			    RETURN .TOKEN;
    			    END;
    			END;

    		    ! If we fall through to here, we failed to find
    		    ! a matching tick operator in our table.
    	   	    !
        	    TOKENBUFFER[0] = 1;
    		    TOKENBUFFER[1] = '''';
    		    CHARPTR = .CHARPTR + 1;
    		    WHILE .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_START] OR
    		    	  .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_MIDDLE] OR
    		    	  .CHARTBL[.CHARPTR[0], CHRTBL$V_IDENT_END] DO
			BEGIN
			IF (.CHARPTR[0] EQL CAR_RET) OR (.TOKENBUFFER[0] GEQ 32)
                            THEN EXITLOOP;
			TOKENBUFFER[0] = .TOKENBUFFER[0] + 1;
			TOKENBUFFER[.TOKENBUFFER[0]] = .CHARPTR[0];
    			CHARPTR = .CHARPTR + 1;
			END;

    		    SIGNAL(DBG$_UNKATTRIB, 1, TOKENBUFFER);
    		    END;    

		! Otherwise we are expecting an operand, so it must be the
		! single quote character.  Pick up the single character quoted
		! and return a Character Constant Lexical Token Entry.
		!
		IF (.CHARPTR[1] EQL CAR_RET) OR (.CHARPTR[2] NEQ '''')
		THEN
		    SIGNAL(DBG$_INVCHRCON);

		TOKENBUFFER[0] = 3;
    		CH$MOVE(3, CHARPTR[0], TOKENBUFFER[1]);
		CHARPTR = .CHARPTR + 3;
		RETURN CREATE_OPERAND_TOKEN(TOKEN$K_IDENTIFIER, TOKENBUFFER);
		END;

	    END;


	! Do nothing for all other languages.
	!
	[INRANGE, OUTRANGE]:
	    0;

	TES;


    ! We have not found a valid token yet.  This must therefore be a genuine
    ! syntax error, so we signal an appropriate error message.
    !
    CHARPTR = .STARTPTR;
    TOKENBUFFER[0] = 0;
    INCR I FROM 0 TO 20 DO
	BEGIN
	IF .CHARPTR[.I] EQL CAR_RET THEN EXITLOOP;
	TOKENBUFFER[.I + 1] = .CHARPTR[.I];
	TOKENBUFFER[0] = .TOKENBUFFER[0] + 1;
	END;

    SIGNAL(DBG$_SYNERREXPR, 1, TOKENBUFFER);
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$PARSER_SET_LANGUAGE(LANGUAGE): NOVALUE =
!
! FUNCTION
!	This routine sets up the parse tables used by the Parser and Lexical
!	Scanner for a specified language.  It is called during the processing
!	of the SET LANGUAGE command.
!
!	Specificially, this routine sets up the Character Table CHARTBL to
!	have the values appropriate for the specified language.  It does so
!	by initializing CHRTBL to have the values appropriate for language
!	UNKNOWN and then changing selected character characteristics as speci-
!	fied in the Character Exception Table for the specified language.
!	It also sets up pointers to the Identifier Operator Table, the Opera-
!	tor Character Operator Table, the Number Scanner State Table, the
!	Primary Parser State Table, and the Subscript Terminator Table for
!	the specified language. It calls the routine DBG$EVALOP_SET_LANGUAGE
!	to set up the Operator Information Tables.
!
! INPUTS
!	LANGUAGE - The language code for the language being SET.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	CEPTR: REF CE_ENTRY,		! Pointer to Character Exception Table
					!      entry for one character
	CETBL: REF VECTOR[,LONG],	! Pointer to Character Exception Table
					!      for the language being SET
	PTR: REF VECTOR[,LONG];		! Pointer to table of language table
					!      pointers for language being SET



    ! Set PTR to point to the table of pointers for this language which point
    ! to the various language-specific tables.  Use language UNKNOWN if we do
    ! not recognize the language code.
    !
    IF (.LANGUAGE GEQ DBG$K_MIN_LANGUAGE) AND
       (.LANGUAGE LEQ DBG$K_MAX_LANGUAGE)
    THEN
	PTR = .LANGUAGE_TABLE_PTRS[.LANGUAGE] + TABLEBASE

    ELSE
	PTR = .LANGUAGE_TABLE_PTRS[DBG$K_UNKNOWN] + TABLEBASE;


    ! Set up the Character Table CHARTBL for this language.  Also make the
    ! global pointer DBG$GL_CHARTBL point to the character table--this pointer
    ! is used in DBGSOURCE by the SEARCH command.
    !
    DBG$GL_CHARTBL = CHARTBL;
    CETBL = .PTR[0] + TABLEBASE;
    CH$MOVE(256*%UPVAL, BASE_CHARACTER_TABLE, CHARTBL);
    INCR I FROM 0 TO .CETBL[-1] - 1 DO
	BEGIN
	CEPTR = CETBL[.I];
	CHARTBL[.CEPTR[CE_CHAR], CHRTBL$L_WHOLE_ENTRY] = .CEPTR[CE_BITS];
	END;


    ! Set up the various parse table pointers to the tables for this language.
    !
    IDENT_OPERATOR_TABLE = .PTR[1] + TABLEBASE;
    OPCHAR_OPERATOR_TABLE = .PTR[2] + TABLEBASE;
    STATE_TABLE = .PTR[3] + TABLEBASE;
    PRIMARY_TABLE = .PTR[4] + TABLEBASE;
    SUBSCRIPT_TERM_TBL = .PTR[5] + TABLEBASE;
    PRIDTBL = .PTR[6] + TABLEBASE;
    BIF_TABLE = .PTR[7] + TABLEBASE;
    MULTIPLE_SUBSCR = .PTR[8];
    ENFORCE_RECORD = .PTR[9];
    CASING_SIGNIFICANT = .PTR[10];
    COMPONENTS_IN_PATHNAME = .PTR[11];
    INCOMPLETE_QUAL = .PTR[12];

    ! Initialize the Operator Evaluation tables and the Print tables for
    ! the current language.
    !
    DBG$EVALOP_SET_LANGUAGE (.LANGUAGE);
    DBG$PRINT_SET_LANGUAGE (.LANGUAGE);
    RETURN;

    END;

GLOBAL ROUTINE DBG$PRIMARY_PARSER(OPERAND_EXPECTED_FLAG, ADDRESS_EXPRESSION,
	TERM_LIST, PAREN_NESTING, RET_TOKEN, RET_OPERAND_FLAG): NOVALUE =
!
! FUNCTION
!	This routine parses Primary Symbols and serves as a get-token routine
!	for the Expression Parser.  It calls the Lexical Scanner to get lexical
!	tokens from the command line being parsed.  It then intercepts tokens
!	which are part of a Primary Symbol and uses those to build a Primary
!	Descriptor for the symbol.  Lexical tokens which are not part of Prim-
!	ary Symbols are simply passed through to the Expression Parser.  The
!	result is that the Expression Parser sees a stream of operators and
!	operands where each Primary Symbol or constant has been preparsed and
!	packaged as a single operand by the Primary Parser.
!
!	A "Primary Symbol" is defined to be a variable name which may include
!	pathname qualification, subscripting, data component selection, and
!	dereferencing.  Exactly which of these are allowed depends on the cur-
!	rent language.  Thus "X" and "MOD\ROUT\Z" are Primary Symbols and so is
!	"M\R\X(2,3).Y^.Z(4)".  In effect, a Primary Symbol is anything that can
!	be described by a Primary Descriptor (see DBGLIB.REQ).
!
!	The Primary Parser emulates a Finite-State Machine (FSM) to parse the
!	Primary Symbols accepted in the current language.  The FMS for the
!	current language is defined by a Primary Parser State Table which
!	defines which operators (such as "\", ".", and subscripting) may appear
!	in which order in a Primary Symbol.  For each transition in the FMS,
!	a semantic routine is executed which builds up the Primary Descriptor
!	for the current Primary Symbol (or a Value Descriptor if the current
!	symbol is a constant).  The symbol is "accepted" by the parser if a
!	transition is reached which returns the completed Primary Descriptor
!	to the caller.  If the symbol is not accepted by the FSM, a syntax
!	error is signalled.
!
!	The Primary Parser is called by the Expression Parser.  However, the
!	Primary Parser will itself call the Expression Parser to pick up sub-
!	script expressions within Primary Symbols.  Hence these two routines
!	call each other recursively, and their data structures have been set
!	up so that this recursion will work properly.
!
! INPUTS
!	OPERAND_EXPECTED_FLAG - A flag which is set to TRUE if the caller
!		  expects to see an operand next.  This flag is used to
!		  determine whether certain operators (such as "+") are
!		  prefix (if an operand is expected) or infix (if an
!		  operand is not expected) operators at the current point
!		  in the parsing of an expression.
!
!	ADDRESS_EXPRESSION - A flag set to TRUE if we are parsing a DEBUG
!		  Address Expression instead of a language expression.  This
!		  affects the parsing of Address Expression operators such
!		  as "+", "-", "*", "/", ".", and "@" which are recognized by
!		  DEBUG rules, not language rules, in Address Expressions.
!
!	TERM_LIST - A vector of pointers to Terminator Lexical Token Entries
!		  for the Terminator Tokens which can terminate the expression
!		  being parsed.  The vector must be in PLIT form (TERM_LIST[-1]
!		  gives the number of entries) and each pointer is expected to
!		  be relative to TABLEBASE.  If there are no terminator tokens
!		  other than carriage return, this list is empty (0 entries).
!
!	PAREN_NESTING - The current parenthesis nesting depth.  This parameter
!		  is passed on to the Lexical Scanner which uses it in the
!		  detection of expression terminator tokens.
!
!	RET_TOKEN - The address of a longword to receive a pointer to an Opera-
!		  tor Lexical Token Entry or a Value or Primary Descriptor.
!
!	RET_OPERAND_FLAG - The address of a longword to receive a flag saying
!		  whether an operator or an operand was returned.
!
!	7th parameter - (optional) - if present, indicates partially
!		  constructed Primary and contains pointer to 
!		  descriptor so far. This is used for example, in the
!		  C expression (*PTR).COMPONENT, where a Primary is
!		  returned from the expression parser for (*PTR) and we
!		  call the Primary Parser to pick up the ".COMPONENT".
!
!	8th parameter - (optional) - if present, indicated partially
!		  constructed Primary and contains starting state.
!
! OUTPUTS
!	RET_TOKEN - A pointer to an Operator Lexical Token Entry or to a Value
!		  or Primary Descriptor is returned to RET_TOKEN.  What the
!		  returned pointer points to is specified by RET_OPERAND_FLAG.
!
!	RET_OPERAND_FLAG - A flag value is returned to RET_OPERAND_FLAG.  If
!		  a pointer to an Operator Lexical Token Entry was returned to
!		  RET_TOKEN, the value FALSE is returned to RET_OPERAND_FLAG.
!		  If a pointer to a Primary or Value Descriptor is returned to
!		  RET_TOKEN, the value TRUE is returned to RET_OPERAND_FLAG.
!

    BEGIN

    MAP
	RET_TOKEN: REF VECTOR[1],	! Token pointer return location
	RET_OPERAND_FLAG: REF VECTOR[1];! Operand returned flag location

    BUILTIN
    	ACTUALCOUNT,
    	ACTUALPARAMETER;

    OWN
	TOKEN_IS_INTEGER:		! Lookup table which states whether a
	    BITVECTOR[TOKEN$K_MAX_OPERAND + 1]	! given operand token is some
	    PSECT(DBG$PLIT)			! form of integer or not
	    PRESET(				!
		[TOKEN$K_INTEGER] = TRUE,	!
		[TOKEN$K_HEX_INTEGER] = TRUE,	!
		[TOKEN$K_OCT_INTEGER] = TRUE,	!
		[TOKEN$K_BIN_INTEGER] = TRUE,	!
    		[TOKEN$K_PACK_DECIMAL] =TRUE);	!

    LOCAL
	ACTION,				! Current state transition action index
	ARG_LIST: REF VECTOR [,LONG],	! List of built-in function arguments
	DUMMY,				! Output param for DEFINE lookup - not
					!      used here.
	KIND,				! RST symbol kind for current symbol
	LAST_OPERAND: REF TOKEN$ENTRY,	! Pointer to the last operand token
					!      entry encountered so far
	NUMERIC_PATHNAME,		! Flag set if numeric pathname is used
	OPCODE,				! Operator code for current operator
	OPERAND_EXPECTED,		! Flag set when operand or prefix ope-
					!      rator is expected next
	PATHDESC: PTH$PATHNAME,		! Pathname descriptor
	PATHSTRING,			! Pointer to pathname string for messages
	PATHVECTOR: REF VECTOR[,LONG],	! Pointer to pathname vector in PATHDESC
    	PLIPTR: REF DBG$PRIMARY,	! Pointer value
	PRID: REF PRID$ENTRY,		! Pointer to Predefined Identifier Entry
	PRIMPTR: REF DBG$PRIMARY,	! Pointer to Primary Descriptor built
    	SAVED_PATHDESC: PTH$PATHNAME,	! Copy of pathname descriptor
	STATE_INDEX,			! Current index into the Primary Parser
					!      State Table
	STATUS,				! Status code returned by RTL routines
	STRDESC: BLOCK[8,BYTE],		! String descriptor for RTL calls
    	SUBSCR_DESC: SUBSCR$DESC,	! Holds saved-away subscripts
	SYMID,				! SYMID (Symbol ID) for current symbol
	TEMPTOKEN: REF TOKEN$ENTRY,	! Pointer to token for invocation number
	TOKEN: REF TOKEN$ENTRY,		! Pointer to the current Token Entry
	TYPEID,				! TYPEID (Type ID) for current symbol
    	VALPTR: REF DBG$VALDESC;	! Pointer to a Value Descriptor



    ! There are two different initialization paths. The normal path is
    ! when we are picking up a Primary from scratch; that is the ELSE
    ! clause below.
    !
    IF ACTUALCOUNT() GTR 6
    THEN
    	BEGIN


        ! If we got an Operator Token last time which was not part of the Primary
        ! Symbol we were building, then we saved it in SAVED_TOKEN while we com-
        ! pleted and returned the Primary Descriptor.  In that case, return the
        ! input Primary and retain the SAVED_TOKEN value for the next time
    	! Primary Parser is called.
    	!
        IF .SAVED_TOKEN NEQ 0
        THEN
    	    BEGIN
	    RET_TOKEN[0] = ACTUALPARAMETER(7);
	    RETURN;
    	    END;
    		

        ! This is the case where we call the Primary Parser when we already
        ! have constructed part of the Primary, and we want to pick up the
        ! rest of the Primary. In this case, a pointer to the partially-
        ! constructed Primary is passed in as the 7th parameter, and the 
        ! current state in the primary parsing is passed in as the 8th parameter.
        ! We also initialize LAST_OPERAND to -1 here; it must be non-zero to
        ! avoid confusing the code below.
        !
        LAST_OPERAND = -1;
        OPERAND_EXPECTED = .OPERAND_EXPECTED_FLAG;
    	STATE_INDEX = ACTUALPARAMETER(8);
    	PRIMPTR = ACTUALPARAMETER(7);
    	END

    ELSE
    	BEGIN


        ! If we got an Operator Token last time which was not part of the Primary
        ! Symbol we were building, then we saved it in SAVED_TOKEN while we com-
        ! pleted and returned the Primary Descriptor.  In that case, return the
        ! saved token to the Expression Parser now and do no more.
        !
        IF .SAVED_TOKEN NEQ 0
        THEN
	    BEGIN
	    TOKEN = .SAVED_TOKEN;
	    SAVED_TOKEN = 0;
	    RET_TOKEN[0] = .TOKEN;
	    RET_OPERAND_FLAG[0] = FALSE;
	    RETURN;
	    END;


        ! Initialize LAST_OPERAND to be null (no operands have been encountered
        ! yet).  Also initialize the OPERAND_EXPECTED flag and various other local
        ! variables and data structures.
        !
        LAST_OPERAND = 0;
        OPERAND_EXPECTED = .OPERAND_EXPECTED_FLAG;
        STATE_INDEX = 0;
        PRIMPTR = 0;
        NUMERIC_PATHNAME = FALSE;
        CH$FILL(0, DBG$K_PATHNAME_SIZE*%UPVAL, PATHDESC);
        PATHVECTOR = PATHDESC[PTH$A_PATHVECTOR];
    	CH$FILL(0, SUBSCR_DESC_SIZE, SUBSCR_DESC);
    	PLIPTR = 0;
    	END;

    ! Loop through all lexical tokens on the input line being parsed until we
    ! reach a terminator operator.
    !
    WHILE TRUE DO
	BEGIN


	! Get the next lexical token.  DBG$LEXICAL_SCANNER picks up the next
	! token using the rules of the currently set language.
	!
	TOKEN = DBG$LEXICAL_SCANNER(.OPERAND_EXPECTED,
			.ADDRESS_EXPRESSION, .TERM_LIST, .PAREN_NESTING);
	IF .DBG$GL_DEVELOPER[2] THEN DUMP_TOKEN(.TOKEN);


	! Check for an invocation number.  An invocation number consists of an
	! integer constant in a pathname where an operator is expected.  If
	! this is an invocation number, we convert it to the invocation number
	! postfix operator which then passes through the rest of the code below
	! in the normal way.
	!
	IF (.PRIMPTR EQL 0)                           AND
	   (NOT .OPERAND_EXPECTED)                    AND
    	   (.LAST_OPERAND NEQ 0)		      AND
	   (.TOKEN[TOKEN$B_KIND] EQL TOKEN$K_OPERAND) AND
	   .TOKEN_IS_INTEGER[.TOKEN[TOKEN$W_CODE]]
	THEN
	    BEGIN
	    TEMPTOKEN = DBG$GET_TEMPMEM(TOKEN$K_ENTSIZE_OPERATOR +
				(.TOKEN[TOKEN$B_LENGTH] + %UPVAL)/%UPVAL);
	    TEMPTOKEN[TOKEN$B_KIND] = TOKEN$K_POSTFIX_OP;
	    TEMPTOKEN[TOKEN$V_PRIMARY] = TRUE;
	    TEMPTOKEN[TOKEN$W_CODE] = TOKEN$K_INVOCNUM;
	    CH$MOVE(.TOKEN[TOKEN$B_LENGTH] + 1,
			TOKEN[TOKEN$B_LENGTH], TEMPTOKEN[TOKEN$B_OPLEN]);
	    TOKEN = .TEMPTOKEN;
	    END;


	! Handle operands.  If this is an operand, check that we are actually
	! expecting an operand at this point.  Save a pointer to the operand
	! and loop to get the next token.
	!
	IF .TOKEN[TOKEN$B_KIND] EQL TOKEN$K_OPERAND
	THEN
	    BEGIN
	    IF NOT .OPERAND_EXPECTED
	    THEN
		SIGNAL(DBG$_MISINVOPER, 1, TOKEN[TOKEN$B_LENGTH]);

	    OPERAND_EXPECTED = FALSE;
	    LAST_OPERAND = .TOKEN;
	    END


	! Handle operators.  If this operator is not part of the current Prim-
	! ary Symbol, we save it while building and returning a descriptor for
	! the Primary Symbol.  If the operator is part of the current Primary
	! Symbol, we add to the Primary we are building and loop to pick up
	! more of the Primary.
	!
	ELSE
	    BEGIN


	    ! If this operator is not part of the Primary Symbol we are build-
	    ! ing (if any), then it is a language or address expression opera-
	    ! tor.  Save it for the next call on DBG$PRIMARY_PARSER and use the
	    ! Terminator Token to close out the Primary Symbol we are building
	    ! (if we are building one).
	    !
	    IF NOT .TOKEN[TOKEN$V_PRIMARY]
	    THEN
		BEGIN


		! If no operand was started, return the operator immediately.
		!
		IF .LAST_OPERAND EQL 0
		THEN
		    BEGIN
		    RET_TOKEN[0] = .TOKEN;
		    RET_OPERAND_FLAG[0] = FALSE;
		    RETURN;
		    END;


		! An operand is present--save the language operator and set
		! things up to close out and return the operand.
		!
		SAVED_TOKEN = .TOKEN;
		TOKEN = PRIMARY_TERM_TOKEN;
		RET_OPERAND_FLAG[0] = TRUE;
		END;


	    ! We now have a Primary operator.  Check that an operator was
	    ! expected unless this is a prefix operator (which is okay when
	    ! we expect an operand).  This check catches many kinds of ill-
	    ! formed Primary Symbols.  Also say that we expect an operand
	    ! next unless this is a postfix operator.
	    !
	    IF (.OPERAND_EXPECTED AND
			(.TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_PREFIX_OP)) OR
	       ((NOT .OPERAND_EXPECTED) AND
			(.TOKEN[TOKEN$B_KIND] EQL TOKEN$K_PREFIX_OP)) 
	    THEN
		SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);

    	    
    	    IF .TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_PREFIX_OP
    	    THEN
    		IF .LAST_OPERAND EQL 0 
    		THEN
		    SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN])
    		ELSE
    		    BEGIN
    		    IF .LAST_OPERAND NEQ -1
    		    THEN
    			BEGIN
    	    	        IF (.LAST_OPERAND[TOKEN$B_KIND] NEQ TOKEN$K_IDENTIFIER)
    	    	        THEN
			    SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);
    			END;
    		    END;


	    IF .TOKEN[TOKEN$B_KIND] NEQ TOKEN$K_POSTFIX_OP
	    THEN
		OPERAND_EXPECTED = TRUE;


	    ! Get the Operator Code for this Primary Operator and loop through
	    ! the transitions for the current state in the Primary Parser State
	    ! Table until we find a transition for this operator.  If we find
	    ! no such transition (PRIMARY$B_OPCODE field zero), the current
	    ! operator is not allowed in this context, so we signal a syntax
	    ! error.  If the transition is allowed, we pick up its action index
	    ! and the next state in the FSM.
	    !
	    OPCODE = .TOKEN[TOKEN$W_CODE];
	    WHILE .PRIMARY_TABLE[.STATE_INDEX, PRIMARY$B_OPCODE] NEQ .OPCODE DO
		BEGIN
		IF .PRIMARY_TABLE[.STATE_INDEX, PRIMARY$B_OPCODE] EQL 0
		THEN
		    SIGNAL(DBG$_SYNERREXPR, 1, TOKEN[TOKEN$B_OPLEN]);

		STATE_INDEX = .STATE_INDEX + 1;
		END;

	    ACTION = .PRIMARY_TABLE[.STATE_INDEX, PRIMARY$B_ACTION];
	    STATE_INDEX = .PRIMARY_TABLE[.STATE_INDEX, PRIMARY$W_NEXTSTATE];


	    ! Execute the action routine associated with this state transition.
	    !
	    CASE .ACTION FROM PRIMARY$K_MIN_ACTION TO PRIMARY$K_MAX_ACTION OF
		SET


		! Handle Global Symbol backslash operator (prefix "\").  Do
		! nothing at this point.
		!
		[PRIMARY$K_ACT_START_GBL]:
		    0;


		! Handle terminator after Global Symbol backslash.  Just pick
		! up the global symbol name and create a Primary Descriptor
		! for it.  Then exit from the parse loop.
		!
		[PRIMARY$K_ACT_GBL_TERM]:
		    BEGIN
		    PATHDESC[PTH$B_TOTCNT] = 1;
		    PATHDESC[PTH$B_PATHCNT] = 1;
		    PATHVECTOR[0] = UPLIT BYTE(0);
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC, SUBSCR_DESC, 
    						 .PLIPTR, SAVED_PATHDESC);
		    EXITLOOP;
		    END;


		! Handle backslash immediately after the start of the symbol.
		! If the last operand was a number, we have a numeric pathname
		! and we put that into the Pathname Descriptor and set the
		! numeric pathname flag.  If it is an identifier, we simply
		! append it to the Pathname Descriptor as is.
		!
		[PRIMARY$K_ACT_START_SLASH]:
		    BEGIN


		    ! If the last operand is an integer, then it constitutes
		    ! a numeric pathname.  We put that in the Pathname Descrip-
		    ! tor and set the NUMERIC_PATHNAME flag (which means that
		    ! no additional pathname qualification is allowed).
		    !
		    IF .TOKEN_IS_INTEGER[.LAST_OPERAND[TOKEN$W_CODE]]
		    THEN
			BEGIN
			STRDESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
			STRDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
			STRDESC[DSC$W_LENGTH] = .LAST_OPERAND[TOKEN$B_LENGTH];
			STRDESC[DSC$A_POINTER] = LAST_OPERAND[TOKEN$A_NAME];
			STATUS = OTS$CVT_TI_L(STRDESC, PATHDESC[PTH$L_INVOCNUM]);
			IF NOT .STATUS
			THEN
			    SIGNAL(DBG$_ILLPATHELEM, 1,
				LAST_OPERAND[TOKEN$B_LENGTH], .STATUS);

			PATHDESC[PTH$B_LOCINVOC] = 1;
			PATHDESC[PTH$B_TOTCNT] = 1;
			PATHDESC[PTH$B_PATHCNT] = 1;
			PATHVECTOR[0] = UPLIT BYTE(0);
			NUMERIC_PATHNAME = TRUE;
			END



		    ! Otherwise simply append the last operand to the current
		    ! Pathname Descriptor.  (The append routine checks that
		    ! the operand is an identifier.)
		    !
		    ELSE
			APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);

		    END;


		! Handle an invocation number immediately after the first or a
		! later pathname component of the symbol.  Check the invocation
		! number for validity and fill it into the Pathname Descriptor.
		!
		[PRIMARY$K_ACT_SLASH_INVOCNUM]:
		    BEGIN


		    ! Check that an invocation number has not already been
		    ! specified--if one has, signal an error.
		    !
		    IF .PATHDESC[PTH$B_LOCINVOC] NEQ 0
		    THEN
			SIGNAL(DBG$_TOOMANINV);


		    ! Convert the invocation number to internal form and fill
		    ! it into the Pathname Descriptor.
		    !
		    STRDESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
		    STRDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
		    STRDESC[DSC$W_LENGTH] = .TOKEN[TOKEN$B_OPLEN];
		    STRDESC[DSC$A_POINTER] = TOKEN[TOKEN$A_OPNAME];
		    STATUS = OTS$CVT_TI_L(STRDESC, PATHDESC[PTH$L_INVOCNUM]);
		    IF NOT .STATUS
		    THEN
			SIGNAL(DBG$_ILLPATHELEM, 1, TOKEN[TOKEN$B_OPLEN],
				DBG$_UNACVT, 3, UPLIT BYTE(%ASCIC 'decimal '),
				.STRDESC, UPLIT BYTE(%ASCIC 'longword integer'),
				.STATUS);

		    PATHDESC[PTH$B_LOCINVOC] = .PATHDESC[PTH$B_TOTCNT] + 1;
		    END;


		! Handle dot immediately after the start of the symbol.  Append
		! the last operand to the current Pathname Descriptor and build
		! the first part of a Primary Descriptor for it.
		!
		[PRIMARY$K_ACT_START_DOT]:
		    BEGIN
    		    LABEL TEMP_BLOCK;

		    ! If the last operand was an identifier, we append it to
		    ! the current Pathname Descriptor and convert that to a
		    ! Primary Descriptor.
		    !
    		    TEMP_BLOCK: BEGIN
		    IF .LAST_OPERAND[TOKEN$W_CODE] EQL TOKEN$K_IDENTIFIER
		    THEN
			BEGIN


			! First check for DEFINEd symbols.
			! Check that no invocation number is present.
			!
		        IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
			THEN


			    ! Look up the symbol in the DEFINE symbol table.
			    !
			    BEGIN
        		    IF DBG$DEF_SYM_FIND (LAST_OPERAND [TOKEN$B_LENGTH],
						 KIND, PRIMPTR, 
						 DUMMY, DUMMY)
			    THEN 
				BEGIN
	    			IF .KIND EQL DEFINE_ADDRESS
	    			OR .KIND EQL DEFINE_VALUE
	    			THEN
				    BEGIN


				    ! We have found a matching DEFINEd symbol.
				    ! Copy the descriptor into temporary memory.
				    ! (Fourth parameter FALSE <-> copy into tempmem).
				    !
				    DBG$NCOPY_DESC (.PRIMPTR, PRIMPTR,
						     DUMMY, FALSE);
    				    LEAVE TEMP_BLOCK;
				    END;
				END;
			    END;
    			END;
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
    		    END; ! TEMP_BLOCK

		    END;


    		! Handle a dot immediately after the start of the symbol.
    		! In PLI we collect all the record components before
    		! calling PATHNAME_TO_PRIMARY.
    		!
    		[PRIMARY$K_ACT_START_DOT_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    END;


    		! Handle a dot after the start of the symbol in COBOL.
    		!
    		[PRIMARY$K_ACT_START_DOT_COB]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, COB_REC_COMP);
    		    END;


		! Handle a subscript parenthesis immediately after the start of
		! the symbol.  Append the last operand to the Pathname Descrip-
		! tor, build a partial Primary Descriptor, and then pick up the
		! subscript expressions within the parentheses.
		!
		[PRIMARY$K_ACT_START_SUBSCR]:
		    BEGIN
    		    LABEL TEMP_BLOCK;

		    ! If the last operand was an identifier, we append it to
		    ! the current Pathname Descriptor and convert that to a
		    ! Primary Descriptor.
		    !
    		    TEMP_BLOCK: BEGIN
		    IF .LAST_OPERAND[TOKEN$W_CODE] EQL TOKEN$K_IDENTIFIER
		    THEN
			BEGIN


			! First check for DEFINEd symbols.
			! Check that no invocation number is present.
			!
		        IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
			THEN


			    ! Look up the symbol in the DEFINE symbol table.
			    !
			    BEGIN
        		    IF DBG$DEF_SYM_FIND (LAST_OPERAND [TOKEN$B_LENGTH],
						 KIND, PRIMPTR, 
						 DUMMY, DUMMY)
			    THEN 
				BEGIN
	    			IF .KIND EQL DEFINE_ADDRESS
	    			OR .KIND EQL DEFINE_VALUE
	    			THEN
				    BEGIN


				    ! We have found a matching DEFINEd symbol.
				    ! Copy the descriptor into temporary memory.
				    ! (Fourth parameter FALSE <-> copy into tempmem).
				    !
				    DBG$NCOPY_DESC (.PRIMPTR, PRIMPTR,
						     DUMMY, FALSE);
    				    LEAVE TEMP_BLOCK;
				    END;
				END;
			    END;
    			END;
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR, SAVED_PATHDESC, TRUE);
    		    END; ! TEMP_BLOCK

		    GET_SUBSCRIPTS(.PRIMPTR);
		    END;


    		! Handle a subscript immediately after the start of the
    		! symbol. In PLI we save away the subscripts and do not
    		! build them into the Primary until later.
    		!
    		[PRIMARY$K_ACT_START_SUBSCR_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    SAVE_SUBSCRIPTS(PATHDESC, SUBSCR_DESC);
    		    END;


		! Handle a subscript parenthesis immediately after the start of
		! the symbol.  Append the last operand to the Pathname Descrip-
		! tor, build a partial Primary Descriptor, and then pick up the
		! subscript expressions within the square brackets. BLISS needs to
		! be special cased because BLISS structures are represented
		! differently in the RST and DST.
		!
		[PRIMARY$K_ACT_START_SUBSCR_BLI]:
		    BEGIN
    		    LABEL TEMP_BLOCK;

		    ! If the last operand was an identifier, we 
    		    TEMP_BLOCK: BEGIN
		    IF .LAST_OPERAND[TOKEN$W_CODE] EQL TOKEN$K_IDENTIFIER
		    THEN
			BEGIN


			! First check for DEFINEd symbols.
			! Check that no invocation number is present.
			!
		        IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
			THEN


			    ! Look up the symbol in the DEFINE symbol table.
			    !
			    BEGIN
        		    IF DBG$DEF_SYM_FIND (LAST_OPERAND [TOKEN$B_LENGTH],
						 KIND, PRIMPTR, 
						 DUMMY, DUMMY)
			    THEN 
				BEGIN
	    			IF .KIND EQL DEFINE_ADDRESS
	    			OR .KIND EQL DEFINE_VALUE
	    			THEN
				    BEGIN


				    ! We have found a matching DEFINEd symbol.
				    ! Copy the descriptor into temporary memory.
				    ! (Fourth parameter FALSE <-> copy into tempmem).
				    !
				    DBG$NCOPY_DESC (.PRIMPTR, PRIMPTR,
						     DUMMY, FALSE);
    				    LEAVE TEMP_BLOCK;
				    END;
				END;
			    END;
    			END

    		    ELSE

    		        ! If the last operand was not an identifier then
    			! it is not legal to select a component.
    			!
			SIGNAL(DBG$_NOTASTRUCT, 1, LAST_OPERAND[TOKEN$B_LENGTH]);

    		    ! Append the last operand to
		    ! the current Pathname Descriptor and convert that to a
		    ! Primary Descriptor.
		    !
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
    		    END; ! TEMP_BLOCK

		    GET_BLISS_SUBSCRIPTS(.PRIMPTR, LAST_OPERAND[TOKEN$B_LENGTH]);
		    END;


		! Handler the PASCAL dereference operator (^).  Append the
		! last identifier onto the pathname.  Then build the pathname
		! into a Primary Descriptor.  Then call the routine that
		! handles derefencing --it just lights the EVAL bit on the
		! sub-node and then allocates a new subnode for the object
		! being pointed to.
		!
		[PRIMARY$K_ACT_START_DEREF]:
		    BEGIN
    		    LABEL TEMP_BLOCK;

		    ! If the last operand was an identifier, we append it to
		    ! the current Pathname Descriptor and convert that to a
		    ! Primary Descriptor.
		    !
    		    TEMP_BLOCK: BEGIN
		    IF .LAST_OPERAND[TOKEN$W_CODE] EQL TOKEN$K_IDENTIFIER
		    THEN
			BEGIN


			! First check for DEFINEd symbols.
			! Check that no invocation number is present.
			!
		        IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
			THEN


			    ! Look up the symbol in the DEFINE symbol table.
			    !
			    BEGIN
        		    IF DBG$DEF_SYM_FIND (LAST_OPERAND [TOKEN$B_LENGTH],
						 KIND, PRIMPTR, 
						 DUMMY, DUMMY)
			    THEN 
				BEGIN
	    			IF .KIND EQL DEFINE_ADDRESS
	    			OR .KIND EQL DEFINE_VALUE
	    			THEN
				    BEGIN


				    ! We have found a matching DEFINEd symbol.
				    ! Copy the descriptor into temporary memory.
				    ! (Fourth parameter FALSE <-> copy into tempmem).
				    !
				    DBG$NCOPY_DESC (.PRIMPTR, PRIMPTR,
						     DUMMY, FALSE);
    				    LEAVE TEMP_BLOCK;
				    END;
				END;
			    END;
    			END;
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
    		    END; ! TEMP_BLOCK

		    GET_DEREFERENCE(.PRIMPTR);
		    END;


    		! Handle a PLI dereference as in A->B. Here we convert the
    		! left-hand-side to a Primary, and then save away the Primary.
    		! The parse is then "backed up" to the start state to pick
    		! up the right hand side of the "->". Later, in the
    		! PATHNAME_TO_PRIMARY routine, the two primaries are glued
    		! together.
    		!
    		[PRIMARY$K_ACT_START_DEREF_PLI]:
    		    BEGIN

    		    ! Save away the Primary for the stuff to the left of "->".
    		    !
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PLIPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						.PLIPTR,SAVED_PATHDESC);
    		    IF (.PLIPTR[DBG$B_DHDR_KIND] NEQ RST$K_DATA) OR
    		       (.PLIPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_PTR)
    		    THEN
    			BEGIN
    			LOCAL
    			    NAME;
    			DBG$NPATHDESC_TO_CS(PATHDESC, NAME);
    			SIGNAL(DBG$_VALNOTADDR, 1, .NAME);
    			END;

    		    ! Re-initialize.
    		    !
        	    PRIMPTR = 0;
        	    NUMERIC_PATHNAME = FALSE;
        	    CH$FILL(0, DBG$K_PATHNAME_SIZE*%UPVAL, PATHDESC);
        	    PATHVECTOR = PATHDESC[PTH$A_PATHVECTOR];
    		    CH$FILL(0, SUBSCR_DESC_SIZE, SUBSCR_DESC);
    		    END;


		! Handle the built-in function operator that follows the
		! built-in function name.  This will return a primary that
		! represents the value of the built-in function.
		!
		[PRIMARY$K_ACT_START_BIF_CALL]:						
                    BEGIN


                    ! If the last operand was not a built-in function name,
                    ! signal the error.
                    !
                    IF .LAST_OPERAND[TOKEN$W_CODE] NEQ TOKEN$K_BUILTIN_FUNCTION
                    THEN
                        SIGNAL(DBG$_MISOPEMIS, 1, TOKEN[TOKEN$B_OPLEN]);

                    ! Call a routine that returns a counted longword vector of
                    ! pointers that point to primary tokens of the arguments
                    ! of the specified built-in function call.  The number of
                    ! arguments expected in the B_FLAGS field of a built-in
                    ! function operand.
                    !
                    ARG_LIST = DBG$GET_BIF_ARGUMENTS(.LAST_OPERAND[TOKEN$B_FLAGS],
                                                     LAST_OPERAND[TOKEN$B_LENGTH]);
                    
                    ! For now, we will not accept any built-in function that
                    ! contains more than 2 arguments.  If more than 2 are
                    ! present, an invalid argument list message in signaled.
                    !
                    IF .ARG_LIST[0] LEQ 2
                    THEN
                        BEGIN

                        ! Create a new operator token to represent the specific
                        ! built-in function call and then pass this token to
                        ! DBG$EVAL_LANG_OPERATOR to proccess the built-in
                        ! function and return its value as a primary.
                        !
                        IF .ARG_LIST[0] EQL 1
                        THEN
                            TOKEN = CREATE_OPERATOR_TOKEN(.LAST_OPERAND[TOKEN$B_BIF],
                                                          LAST_OPERAND[TOKEN$B_LENGTH],
                                                          .TOKEN[TOKEN$B_KIND])
                        ELSE
                            TOKEN = CREATE_OPERATOR_TOKEN(.LAST_OPERAND[TOKEN$B_BIF],
                                                          LAST_OPERAND[TOKEN$B_LENGTH],
                                                          TOKEN$K_INFIX_OP);

                        PRIMPTR = DBG$EVAL_LANG_OPERATOR(.TOKEN, .ARG_LIST[1], .ARG_LIST[2]);

                        ! Return the fact that we have built the result by now
                        ! and that it is a value descriptor.  Because of the
                        ! way the BIF tokens come through the above initialization
                        ! code, this value was never set.  And It Better Be!
                        !
         		RET_OPERAND_FLAG[0] = TRUE;

                        END
                    ELSE
                        SIGNAL(DBG$_INVARGLIS, 1, LAST_OPERAND[TOKEN$B_LENGTH]);
                    EXITLOOP;
                    END;


		! Handle the Ada tick operator immediately after the start of
		! the symbol.  The symbol thus consists of just a single type
		! name.
		!
		[PRIMARY$K_ACT_START_TICK]:
		    BEGIN


		    ! If the last operand was an identifier, we append it to
		    ! the current Pathname Descriptor and convert that to a
		    ! Primary Descriptor.
		    !
		    IF .LAST_OPERAND[TOKEN$W_CODE] EQL TOKEN$K_IDENTIFIER
		    THEN
			BEGIN


			! First check for DEFINEd symbols.
			! Check that no invocation number is present.
			!
		        IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
			THEN


			    ! Look up the symbol in the DEFINE symbol table.
			    !
			    BEGIN
        		    IF DBG$DEF_SYM_FIND (LAST_OPERAND [TOKEN$B_LENGTH],
						 KIND, PRIMPTR, 
						 DUMMY, DUMMY)
			    THEN 
				BEGIN
	    			IF .KIND EQL DEFINE_ADDRESS
	    			OR .KIND EQL DEFINE_VALUE
	    			THEN
				    BEGIN


				    ! We have found a matching DEFINEd symbol.
				    ! Copy the descriptor into temporary memory.
				    ! (Fourth parameter FALSE <-> copy into tempmem).
				    !
				    DBG$NCOPY_DESC (.PRIMPTR, PRIMPTR,
						     DUMMY, FALSE);
				    EXITLOOP;
				    END;

				END;

			    END;

			APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);

                        ! Call GETSYMBOL directly since all we need is the typeid.
                        ! TRUE is passed in to tell GETSYMBOL that we do want it
                        ! to look up symbol-types as well as the normal data-types.
                        !
                        DBG$STA_GETSYMBOL(PATHDESC, TYPEID, KIND, 0, 0, 0, TRUE);

                        ! Check the output from getsymbol to see if a unique symbol
                        ! was found.  If not, signal the appropriate error.
                        !
                        IF .TYPEID EQL 0
                        THEN
                            BEGIN
                            DBG$NPATHDESC_TO_CS(PATHDESC, PATHSTRING);
                            IF .KIND EQL RST$K_NOTUNIQUE
	                    THEN
		                SIGNAL(DBG$_NOUNIQUE, 1, .PATHSTRING)
	                    ELSE
                                IF .KIND EQL RST$K_OVERLOAD
                                THEN
                                    SIGNAL(DBG$_NOTUNQOVR, 1, .PATHSTRING)
                                ELSE
                                    SIGNAL(DBG$_NOSYMBOL, 1, .PATHSTRING);
                            END;

                        PRIMPTR = DBG$EVAL_ADA_TICK(.TYPEID, .TOKEN);

                        ! Return the fact that we have built the result by now
                        ! and that it is a value descriptor.  Because of the
                        ! way the Ada tick tokens come through the above 
                        ! initialization code, this value was never set.
                        ! And It Better Be!
                        !
         		RET_OPERAND_FLAG[0] = TRUE;

			END
                    ELSE
                        SIGNAL(DBG$_SYNERREXPR, 1, .LAST_OPERAND[TOKEN$B_LENGTH]);

                    EXITLOOP;
                    END;


		! Handle the terminator operator immediately after the start of
		! the symbol.  The symbol thus consists of just a single name
		! or a constant.
		!
		[PRIMARY$K_ACT_START_TERM]:
		    BEGIN


		    ! If the last operand was an identifier, we append it to
		    ! the current Pathname Descriptor and convert that to a
		    ! Primary Descriptor.
		    !
		    IF .LAST_OPERAND[TOKEN$W_CODE] EQL TOKEN$K_IDENTIFIER
		    THEN
			BEGIN


			! First check for DEFINEd symbols.
			! Check that no invocation number is present.
			!
		        IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
			THEN


			    ! Look up the symbol in the DEFINE symbol table.
			    !
			    BEGIN
        		    IF DBG$DEF_SYM_FIND (LAST_OPERAND [TOKEN$B_LENGTH],
						 KIND, PRIMPTR, 
						 DUMMY, DUMMY)
			    THEN 
				BEGIN
	    			IF .KIND EQL DEFINE_ADDRESS
	    			OR .KIND EQL DEFINE_VALUE
	    			THEN
				    BEGIN


				    ! We have found a matching DEFINEd symbol.
				    ! Copy the descriptor into temporary memory.
				    ! (Fourth parameter FALSE <-> copy into tempmem).
				    !
				    DBG$NCOPY_DESC (.PRIMPTR, PRIMPTR,
						     DUMMY, FALSE);
				    EXITLOOP;
				    END;

				END;

			    END;

			APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		        PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						     .PLIPTR,SAVED_PATHDESC);
			END


		    ! Otherwise, the last operand was a constant of some
		    ! sort so we create a Value Descriptor for it.
		    !
		    ELSE
			PRIMPTR = CONSTANT_TO_VALDESCR(.LAST_OPERAND);


		    ! Exit from the parse loop (the get-token loop).
		    !
		    EXITLOOP;
		    END;


		! Handle the backslash operator after a previous backslash ope-
		! rator (e.g., A\B\C).  Note that this is not allowed after a
		! numeric pathname.  Also handle a backslash operator after an
		! invocation number.  Append the last operand (which must be an
		! identifier) to the current Pathname Descriptor.
		!
		[PRIMARY$K_ACT_SLASH_SLASH]:
		    BEGIN
		    IF .NUMERIC_PATHNAME
		    THEN
			SIGNAL(DBG$_ILLPATHELEM, 1, LAST_OPERAND[TOKEN$B_LENGTH]);

		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
		    END;


		! Handle a dot (data qualification) after a backslash.  Here we
		! complete the current Pathname Descriptor and convert it to a
		! Primary Descriptor.
		!
		[PRIMARY$K_ACT_SLASH_DOT]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
		    END;


    		! Handle a dot after a backslash. In PLI we do not call
    		! PATHNAME_TO_PRIMARY until after collecting all the record
    		! components.
    		!
    		[PRIMARY$K_ACT_SLASH_DOT_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    END;


		! Handle a subscript parenthesis after a backslash.  Here we
		! complete the current Pathname Descriptor and convert it to a
		! Primary Descriptor.  We then pick up all the subscript expres-
		! sions.
		!
		[PRIMARY$K_ACT_SLASH_SUBSCR]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR, SAVED_PATHDESC, TRUE);
		    GET_SUBSCRIPTS(.PRIMPTR);
		    END;


    		! Handle a subscript after a backslash in language PLI. In PLI
    		! we do not incorporate the subscripts into the Primary
    		! Descriptor until later.
    		!
    		[PRIMARY$K_ACT_SLASH_SUBSCR_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    SAVE_SUBSCRIPTS(PATHDESC, SUBSCR_DESC);
    		    END;


		! Handle a subscript left bracket after a backslash for language
		! BLISS.  Here we complete the current Pathname Descriptor and
		! convert it to a Primary Descriptor.  We then pick up all the
		! subscript expressions.  BLISS has to be treated separately
		! because it represents data differently in the RST and DST.
		!
		[PRIMARY$K_ACT_SLASH_SUBSCR_BLI]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
		    GET_BLISS_SUBSCRIPTS(.PRIMPTR, LAST_OPERAND[TOKEN$B_LENGTH]);
		    END;


		! Handle the PASCAL dereference operator (^) occuring after
		! a pathname qualified name.  Append the last identifier onto
		! the pathname.  Then build the pathname into a Primary
		! Descriptor.  Then call the routine that handles derefencing
		! --it just lights the EVAL bit on the sub-node and then
		! allocates a new subnode for the object being pointed to.
		!
		[PRIMARY$K_ACT_SLASH_DEREF]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
		    GET_DEREFERENCE(.PRIMPTR);
		    END;


    		! Handle a PLI dereference as in A\B->C. Here we convert the
    		! left-hand-side to a Primary, and then save away the Primary.
    		! The parse is then "backed up" to the start state to pick
    		! up the right hand side of the "->". Later, in the
    		! PATHNAME_TO_PRIMARY routine, the two primaries are glued
    		! together.
    		!
    		[PRIMARY$K_ACT_SLASH_DEREF_PLI]:
    		    BEGIN

    		    ! Obtain value of expression to left of "->".
    		    !
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PLIPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    					   	.PLIPTR,SAVED_PATHDESC);
    		    IF (.PLIPTR[DBG$B_DHDR_KIND] NEQ RST$K_DATA) OR
    		       (.PLIPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_PTR)
    		    THEN
    			BEGIN
    			LOCAL
    			    NAME;
    			DBG$NPATHDESC_TO_CS(PATHDESC, NAME);
    			SIGNAL(DBG$_VALNOTADDR, 1, .NAME);
    			END;

    		    ! Re-initialize.
    		    !
        	    PRIMPTR = 0;
        	    NUMERIC_PATHNAME = FALSE;
        	    CH$FILL(0, DBG$K_PATHNAME_SIZE*%UPVAL, PATHDESC);
        	    PATHVECTOR = PATHDESC[PTH$A_PATHVECTOR];
    		    CH$FILL(0, SUBSCR_DESC_SIZE, SUBSCR_DESC);
    		    END;


		! Handle the Ada tick operator after a backslash.  Here we
		! just complete the Pathname Descriptor and convert it to a
		! Primary Descriptor.  We are then done with the symbol.
		!
		[PRIMARY$K_ACT_SLASH_TICK]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);

                    ! Call GETSYMBOL directly since all we need is the typeid.
                    ! TRUE is passed in to tell GETSYMBOL that we do want it
                    ! to look up symbol-types as well as the normal data-types.
                    !
                    DBG$STA_GETSYMBOL(PATHDESC, TYPEID, KIND, 0, 0, 0, TRUE);

                    ! Check the output from getsymbol to see if a unique symbol
                    ! was found.  If not, signal the appropriate error.
                    !
                    IF .TYPEID EQL 0
                    THEN
                        BEGIN
                        DBG$NPATHDESC_TO_CS(PATHDESC, PATHSTRING);
                        IF .KIND EQL RST$K_NOTUNIQUE
	                THEN
		            SIGNAL(DBG$_NOUNIQUE, 1, .PATHSTRING)
	                ELSE
                            IF .KIND EQL RST$K_OVERLOAD
                            THEN
                                SIGNAL(DBG$_NOTUNQOVR, 1, .PATHSTRING)
                            ELSE
                                SIGNAL(DBG$_NOSYMBOL, 1, .PATHSTRING);
                        END;

                    PRIMPTR = DBG$EVAL_ADA_TICK(.TYPEID, .TOKEN);

                    ! Return the fact that we have built the result by now
                    ! and that it is a value descriptor.  Because of the
                    ! way the Ada tick tokens come through the above 
                    ! initialization code, this value was never set.
                    ! And It Better Be!
                    !
         	    RET_OPERAND_FLAG[0] = TRUE;

		    EXITLOOP;
		    END;


		! Handle the terminator operator after a backslash.  Here we
		! just complete the Pathname Descriptor and convert it to a
		! Primary Descriptor.  We are then done with the symbol.
		!
		[PRIMARY$K_ACT_SLASH_TERM]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
		    EXITLOOP;
		    END;


    		! Handle a slash after an "OF" in COBOL.
    		!
    		[PRIMARY$K_ACT_DOT_SLASH_COB]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    END;

		! Handle a dot (data qualification) after another dot.  Check
		! that the last operand is an identifier and that it is a valid
		! component name of the current record type.  Get its SYMID,
		! etc., and add it to the Primary Descriptor being built.
		!
		[PRIMARY$K_ACT_DOT_DOT]:
		    GET_RECORD_COMPONENT(.PRIMPTR, LAST_OPERAND[TOKEN$B_LENGTH]);


    		! Handle a dot after another dot in PLI. In PLI we do not
    		! call PATHNAME_TO_PRIMARY until after collecting all
    		! the record components.
    		!
    		[PRIMARY$K_ACT_DOT_DOT_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, REC_COMP);
    		    END;
 

    		! Handle an "OF" operator after another "OF" operator in
    		! COBOL.
    		!
    		[PRIMARY$K_ACT_DOT_DOT_COB]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, COB_REC_COMP);
    		    END;

		! Handle subscripting after a dot (data qualification).  Check
		! that the last operand is an identifier and that it is a valid
		! component name of the current record type.  Get its SYMID,
		! etc., and add it to the Primary Descriptor being built.  Then
		! pick up all the subscript expressions and add their values to
		! the Primary Descriptor.
		!
		[PRIMARY$K_ACT_DOT_SUBSCR]:
		    BEGIN
		    GET_RECORD_COMPONENT(.PRIMPTR, LAST_OPERAND[TOKEN$B_LENGTH]);
		    GET_SUBSCRIPTS(.PRIMPTR);
		    END;


    		! Handle a subscript after a dot in PLI. In PLI we do not
    		! call PATHNAME_TO_PRIMARY until after picking up all
    		! the record components.
    		!
    		[PRIMARY$K_ACT_DOT_SUBSCR_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, REC_COMP);
    		    SAVE_SUBSCRIPTS(PATHDESC, SUBSCR_DESC);
    		    END;


    		! Handle the subscript operator after the "OF" operator
    		! in COBOL.
    		!
    		[PRIMARY$K_ACT_DOT_SUBSCR_COB]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    SAVE_SUBSCRIPTS(PATHDESC, SUBSCR_DESC);
    		    END;

		! Handle the PASCAL dereference operator (^) occurring after
		! a dot (data qualification).  Here we call a routine which
		! appends the last operand (representing a record component)
		! onto the Primary Descriptor being built.  We then call the
		! routine that handles derefencing--it just lights the EVAL
		! bit on the sub-node and then  allocates a new subnode for
		! the object being pointed to.
		!
		[PRIMARY$K_ACT_DOT_DEREF]:
		    BEGIN
		    GET_RECORD_COMPONENT(.PRIMPTR, LAST_OPERAND[TOKEN$B_LENGTH]);
		    GET_DEREFERENCE(.PRIMPTR);
		    END;


    		! Handle a PLI dereference as in A.B->C. Here we convert the
    		! left-hand-side to a Primary, and then save away the Primary.
    		! We loop back to the start state to pick up the rest
    		! of the expression.
    		!
    		[PRIMARY$K_ACT_DOT_DEREF_PLI]:
    		    BEGIN

    		    ! Save away the Primary constructed so far.
    		    !
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, REC_COMP);
    		    PLIPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						.PLIPTR,SAVED_PATHDESC);
    		    IF (.PLIPTR[DBG$B_DHDR_KIND] NEQ RST$K_DATA) OR
    		       (.PLIPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_PTR)
    		    THEN
    			BEGIN
    			LOCAL
    			    NAME;
    			DBG$NPATHDESC_TO_CS(PATHDESC, NAME);
    			SIGNAL(DBG$_VALNOTADDR, 1, .NAME);
    			END;

    		    ! Re-initialize.
    		    !
        	    PRIMPTR = 0;
        	    NUMERIC_PATHNAME = FALSE;
        	    CH$FILL(0, DBG$K_PATHNAME_SIZE*%UPVAL, PATHDESC);
        	    PATHVECTOR = PATHDESC[PTH$A_PATHVECTOR];
    		    CH$FILL(0, SUBSCR_DESC_SIZE, SUBSCR_DESC);
    		    END;


		! Handle the Ada tick operator after a dot (data qualifica-
		! tion).  Call the routine that looks up the SYMID for the
    		! record component and adds that to the Primary Descriptor.
		! Then exit the parse loop.
		!
		[PRIMARY$K_ACT_DOT_TICK]:
		    BEGIN
		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, REC_COMP);

                    ! Call GETSYMBOL directly since all we need is the typeid.
                    ! TRUE is passed in to tell GETSYMBOL that we do want it
                    ! to look up symbol-types as well as the normal data-types.
                    !
                    DBG$STA_GETSYMBOL(PATHDESC, TYPEID, KIND, 0, 0, 0, TRUE);

                    ! Check the output from getsymbol to see if a unique symbol
                    ! was found.  If not, signal the appropriate error.
                    !
                    IF .TYPEID EQL 0
                    THEN
                        BEGIN
                        DBG$NPATHDESC_TO_CS(PATHDESC, PATHSTRING);
                        IF .KIND EQL RST$K_NOTUNIQUE
	                THEN
		            SIGNAL(DBG$_NOUNIQUE, 1, .PATHSTRING)
	                ELSE
                            IF .KIND EQL RST$K_OVERLOAD
                            THEN
                                SIGNAL(DBG$_NOTUNQOVR, 1, .PATHSTRING)
                            ELSE
                                SIGNAL(DBG$_NOSYMBOL, 1, .PATHSTRING);
                        END;

                    PRIMPTR = DBG$EVAL_ADA_TICK(.TYPEID, .TOKEN);

                    ! Return the fact that we have built the result by now
                    ! and that it is a value descriptor.  Because of the
                    ! way the Ada tick tokens come through the above 
                    ! initialization code, this value was never set.
                    ! And It Better Be!
                    !
         	    RET_OPERAND_FLAG[0] = TRUE;

		    EXITLOOP;
		    END;


		! Handle the terminator operator after a dot (data qualifica-
		! tion).  Call the routine that looks up the SYMID for the
    		! record component and adds that to the Primary Descriptor.
		! Then exit the parse loop.
		!
		[PRIMARY$K_ACT_DOT_TERM]:
		    BEGIN
		    GET_RECORD_COMPONENT(.PRIMPTR, LAST_OPERAND[TOKEN$B_LENGTH]);
		    EXITLOOP;
		    END;


    		! Handle the end of the Primary after a dot in PLI. At this
    		! point we call PATHNAME_TO_PRIMARY, and then exit the loop.
    		!
    		[PRIMARY$K_ACT_DOT_TERM_PLI]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR, SAVED_PATHDESC);
    		    EXITLOOP;
    		    END;


    		! Handle the end of the Primary after an "OF" operator
    		! (record component selection) in COBOL.
    		!
    		[PRIMARY$K_ACT_DOT_TERM_COB]:
    		    BEGIN
    		    APPEND_TO_PATHNAME(PATHDESC, .LAST_OPERAND, NOT_REC_COMP);
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR,SAVED_PATHDESC);
    		    EXITLOOP;
    		    END;

		! Handle a dot (data qualification) after subscripting.  We do 
    		! nothing with the dot until after we pick up the component
    		! name. However, we do call a routine that fixes up the 
    		! bounds in the array subnode after subscripting has been
    		! completed.
		!
		[PRIMARY$K_ACT_SUBSCR_DOT]:
    		    FIX_UP_PRIMARY(.PRIMPTR);


    		! Handle a dot after a subscript in PLI. There is actually
    		! nothing to do here.
    		!
    		[PRIMARY$K_ACT_SUBSCR_DOT_PLI]:
    		    BEGIN
    		    0;
    		    END;
    		

		! Handle subscripting parentheses immediately after a previous
		! instance of subscripting.  Just do the subscripting normally.
		! Pick up the subscript expressions and add their values to the
		! Primary Descriptor being built.
		!
		[PRIMARY$K_ACT_SUBSCR_SUBSCR]:
		    GET_SUBSCRIPTS(.PRIMPTR);


    		! Handle a subscript immediately after another subscript 
    		! in PLI. In PLI we save up the subscripts until after we
    		! collect a full pathname including record components.
    	   	!
    		[PRIMARY$K_ACT_SUBSCR_SUBSCR_PLI]:
    		    BEGIN
    		    SAVE_SUBSCRIPTS(PATHDESC, SUBSCR_DESC);
    		    END;


		! Handle a PASCAL dereference operator (^) occuring after
		! a subscripting operation.  First call a routine that fixes
    		! up the bounds in the array subnode after subscripting has 
    		! been  completed.  Then  call  the  routine  that  handles
		! derefencing--it just lights the EVAL bit on the sub-node and
		! then allocates a new subnode for the object being pointed to.
		!	
		[PRIMARY$K_ACT_SUBSCR_DEREF]:
    		    BEGIN
    		    FIX_UP_PRIMARY(.PRIMPTR);
		    GET_DEREFERENCE(.PRIMPTR);
    		    END;


    		! Handle a PLI dereference as in A(2)->B. Here we convert the
    		! left-hand-side to a Primary, and save away that Primary.
    		! We loop back to the start state to pick up the rest
    		! of the expression.
    		!
    		[PRIMARY$K_ACT_SUBSCR_DEREF_PLI]:
    		    BEGIN

    		    ! Save away the Primary obtained so far.
    		    !
    		    PLIPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						.PLIPTR, SAVED_PATHDESC);
    		    IF (.PLIPTR[DBG$B_DHDR_KIND] NEQ RST$K_DATA) OR
    		       (.PLIPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_PTR)
    		    THEN
    			BEGIN
    			LOCAL
    			    NAME;
    			DBG$NPATHDESC_TO_CS(PATHDESC, NAME);
    			SIGNAL(DBG$_VALNOTADDR, 1, .NAME);
    			END;

    		    ! Re-initialize.
    		    !
        	    PRIMPTR = 0;
        	    NUMERIC_PATHNAME = FALSE;
        	    CH$FILL(0, DBG$K_PATHNAME_SIZE*%UPVAL, PATHDESC);
        	    PATHVECTOR = PATHDESC[PTH$A_PATHVECTOR];
    		    CH$FILL(0, SUBSCR_DESC_SIZE, SUBSCR_DESC);
    		    END;


		! Handle subscripting followed by the terminator operator.  
		! First call a routine that fixes up the bounds in the array 
    		! subnode  after  subscripting  has  been  completed.  The
		! Primary Descriptor is now complete, so we exit the parse 
    		! loop.
		!
		[PRIMARY$K_ACT_SUBSCR_TERM]:
    		    BEGIN
    		    FIX_UP_PRIMARY(.PRIMPTR);
		    EXITLOOP;
    		    END;


    		! Handle a subscript followed by the end of the expression
    		! in PLI.
    		!
    		[PRIMARY$K_ACT_SUBSCR_TERM_PLI]:
    		    BEGIN
    		    PRIMPTR = PATHNAME_TO_PRIMARY(PATHDESC,SUBSCR_DESC,
    						 .PLIPTR, SAVED_PATHDESC);
    		    EXITLOOP;
    		    END;



		! Handle a PASCAL dereference operator (^) followed by a dot.
		! (E.g. "A^.B").  We actually do nothing here since the deref-
		! erence operator was handled already, and the dot operator is
		! not handled until after we pick up the component.
		!
		[PRIMARY$K_ACT_DEREF_DOT]:
		    0;


		! Handle a PASCAL dereference operator (^) followed by a
		! subscript.  Here we just pick up the subscripts.
		!
		[PRIMARY$K_ACT_DEREF_SUBSCR]:
		    GET_SUBSCRIPTS(.PRIMPTR);


		! Handle a PASCAL dereference operator (^) followed by another
		! dereference.  We call the routine that handles derefencing--
		! it just lights the EVAL bit on the sub-node and then allo-
		! cates a new subnode for the object being pointed to.
		!
		[PRIMARY$K_ACT_DEREF_DEREF]:
		    GET_DEREFERENCE(.PRIMPTR);
		
		
		! Handle a PASCAL dereference operator (^) followed by a termi-
		! nator.  The Primary Descriptor is now complete, so we exit
		! the parse loop.
		!
		[PRIMARY$K_ACT_DEREF_TERM]:
		    EXITLOOP;


		! Any other CASE index constitutes an internal DEBUG error.
		!
		[INRANGE, OUTRANGE]:
		    $DBG_ERROR('DBGPARSER\PRIMARY_PARSER 10');

		TES;

	    END;			! End of ELSE-clause for operators

	END;				! End of the get-token loop


    ! We are all done parsing the primary. Return a pointer to the
    ! descriptor we have constructed.
    !
    RET_TOKEN[0] = .PRIMPTR;
    RETURN;

    END;

ROUTINE APPEND_TO_PATHNAME(PATHDESCR, TOKEN, COMPONENT_KIND): NOVALUE =
!
! FUNCTION
!	This routine appends a pathname component to an existing Pathname
!	Descriptor.  It is called by the Primary Parser during the parsing of
!	the pathname part of Primary Symbols (e.g., A\B\C) to build up the
!	Pathname Descriptor which must eventually be passed to GETSYMBOL to
!	get the symbol's SYMID.
!
! INPUTS
!	PATHDESCR - A pointer to a Pathname Descriptor to which a new pathname
!		  component should be appended.
!
!	TOKEN	- A pointer to the Lexical Token Entry for the identifier to
!		  be appended to the pathname descriptor.
!
!	COMPONENT_KIND - This tells us what kind of pathname component we
!		  are dealing with. It can have one of the following values:
!		  NOT_REC_COMP (0) - An ordinary pathname component to be
!				     appended onto the end of the pathname,
!				     e.g., "A" and "B" would be of this kind
!				     in the pathname "A\B.C"
!		  REC_COMP (1)	   - In the above example, "C" comes in as
!				     a record component. It is appended to
!				     the pathname and the TOTCNT is incremented
!				     but not the PTHCNT field.
!		  COB_REC_COMP (2) - In COBOL, record components come in 
!				     first, e.g., "C of B of A", so we have
!				     to treat them differently when we are
!				     building the pathname.
!		
! OUTPUTS
!	The identifier specified by TOKEN is added to the end of the Pathname
!		  Descriptor pointed to by PATHDESCR.
!

    BEGIN

    MAP
	PATHDESCR: REF PTH$PATHNAME,	! Pointer to Pathname Descriptor
	TOKEN: REF TOKEN$ENTRY;		! Pointer to Identifier Token Entry

    LOCAL
	PATHVECTOR: REF VECTOR[,LONG];	! Pointer to pathname vector in the
					!      PATHDESCR Pathname Descriptor



    ! Make sure we have a valid Identifier Lexical Token Entry.  Also make sure
    ! it will fit in the Pathname Descriptor.
    !
    IF .TOKEN[TOKEN$W_CODE] NEQ TOKEN$K_IDENTIFIER
    THEN
	SIGNAL(DBG$_ILLPATHELEM, 1, TOKEN[TOKEN$B_LENGTH]);

    IF .PATHDESCR[PTH$B_PATHCNT] GEQ DBG$K_MAX_PATHNAME
    THEN
	SIGNAL(DBG$_PATHTOOLONG, 1, TOKEN[TOKEN$B_LENGTH]);

    PATHVECTOR = PATHDESCR[PTH$A_PATHVECTOR];

    ! Handle a non-COBOL record component.
    !
    IF .COMPONENT_KIND EQL REC_COMP
    THEN
    	BEGIN

    	! Append the new pathname component to the Pathname Descriptor
    	! and then just return.
    	!
    	PATHVECTOR[.PATHDESCR[PTH$B_TOTCNT]] = TOKEN[TOKEN$B_LENGTH];
    	PATHDESCR[PTH$B_TOTCNT] = .PATHDESCR[PTH$B_TOTCNT] + 1;
    	RETURN;
    	END;

    ! Handle the case where we are adding a record component name in COBOL.
    ! Since these come in reverse order, previous ones must be pushed down.
    !
    IF .COMPONENT_KIND EQL COB_REC_COMP
    THEN
    	BEGIN

    	! Check that we have not seen any pathname components yet.
    	!
    	IF .PATHDESCR[PTH$B_PATHCNT] NEQ 0
    	THEN
    	    $DBG_ERROR('DBGPARSER\APPEND_TO_PATHNAME 10');

    	! Push the previous components.
    	!
    	DECR I FROM .PATHDESCR[PTH$B_TOTCNT] TO 1 DO
    	    PATHVECTOR[.I] = .PATHVECTOR[.I-1];

    	! Add the new component.
    	!
    	PATHVECTOR[0] = TOKEN[TOKEN$B_LENGTH];

    	! Bump the count and we are done.
    	!
    	PATHDESCR[PTH$B_TOTCNT] = .PATHDESCR[PTH$B_TOTCNT] + 1;
    	RETURN;
    	END;

    ! Finally handle the ordinary pathname components.
    ! We want to insert the given component after previous pathname components
    ! but before any record components we have already picked up.
    !
    IF .COMPONENT_KIND EQL NOT_REC_COMP
    THEN
    	BEGIN

    	! We want to insert the name at the PATHCNT position.
    	! Push down lower names (record component names).
    	!
    	DECR I FROM .PATHDESCR[PTH$B_TOTCNT] TO .PATHDESCR[PTH$B_PATHCNT]+1 DO
    	    PATHVECTOR[.I] = .PATHVECTOR[.I-1];

    	! Insert the given name, increment the counts, and return.
    	!
    	PATHVECTOR[.PATHDESCR[PTH$B_PATHCNT]] = TOKEN[TOKEN$B_LENGTH];
    	PATHDESCR[PTH$B_PATHCNT] = .PATHDESCR[PTH$B_PATHCNT] + 1;
    	PATHDESCR[PTH$B_TOTCNT] = .PATHDESCR[PTH$B_TOTCNT] + 1;
    	RETURN;
    	END;
    END;

ROUTINE CHECK_UPSCOPE(SYMID, TYPEID, PRIMPTR, DEPTH) =
!
! FUNCTION
!	This routine is used to implement "incomplete data qualification"
!	in language BASIC. For example, a user can abbreviate A::B::C with
!	A::C. We are passed in a SYMID for the record component ("C" in
!	the above example), and a TYPEID for the record ("A" in the above
!	example. This routine determines whether we can get to the record
!	by going upscope from the component. If so, it returns TRUE and
!	modifies the Primary to include the intervening component
!	selection.
!
! INPUTS
!	SYMID	- SYMID for the record component.
!	TYPEID	- TYPEID for the record.
!	PRIMPTR - Pointer to the Primary being constructed.
!	DEPTH   - recursion depth
!
! OUTPUTS
!	The value TRUE is returned if the component selection is valid.
!	In this case, the Primary is modified to include the intervening
!	component selection.
!	The value FALSE is returned if the component is not a valid
!	component for this record.
!
    BEGIN
    MAP
    	SYMID: REF RST$ENTRY,
    	TYPEID: REF RST$ENTRY,
    	PRIMPTR: REF DBG$PRIMARY;

    LOCAL
    	I,
    	COMPSYMID,
    	FCODE,
    	NEW_TYPEID,
    	NODEPTR: REF DBG$PRIM_NODE,
    	TYPCOMPLST: REF VECTOR[,LONG],
    	TYPREFTBL: REF VECTOR[,LONG],
    	U_SYMID: REF RST$ENTRY;

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;

    ! Check that the RST entry upscope from the given 
    ! record component SYMID is a Type RST Entry.
    ! Then check whether it matches the given TYPEID for the record.
    !
    U_SYMID = .SYMID[RST$L_UPSCOPEPTR];
    IF .U_SYMID[RST$B_KIND] NEQ RST$K_TYPE
    THEN
    	RETURN FALSE;
    IF .U_SYMID EQL .TYPEID
    THEN
    	BEGIN
    
    	! The TYPEID matches, so the record component SYMID is valid.
        ! In this case, we do want to perform the component selection.
    	! Modify the Primary to include the record component selection.
    	!
    	NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    	NODEPTR[DBG$V_PNODE_EVAL] = TRUE;
        TYPCOMPLST = TYPEID[RST$A_TYPCOMPLST];

    	! Determine the "component index". This "PNREC_INDEX" field gets
    	! used in determining the logical successor.
    	!
        INCR I FROM 0 TO .TYPEID[RST$L_TYPCOMPCNT] - 1 DO
	    BEGIN
	    COMPSYMID = .TYPCOMPLST[.I];


	    ! If this component is the one we seek, set its index into the Record
	    ! Sub-Node and leave the loop.
	    !
	    IF .SYMID EQL .COMPSYMID
	    THEN
	        BEGIN
	        NODEPTR[DBG$W_PNREC_INDEX] = .I + 1;
	        EXITLOOP;
	        END;
    	    END;

    	! Check for FCODE of record - otherwise, it is not valid to skip
    	! this component.
    	!
    	DBG$STA_SYMTYPE(.SYMID, FCODE, NEW_TYPEID);
    	IF .FCODE NEQ RST$K_TYPE_RECORD
    	THEN
    	    RETURN FALSE;

    	! Finally append another Primary Descriptor Sub-Node for the selected
    	! record component.  Then return.
    	!
    	DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, RST$K_TYPCOMP, .SYMID, 
    				  .FCODE, .NEW_TYPEID, 0);
    	RETURN TRUE;
    	END;

    ! The immediate upscope pointer did not match. In this case, go further
    ! upscope. We do this by getting the Type Reference table for this 
    ! Type RST entry. For each SYMID in the table, we recursively call
    ! the CHECK_UPSCOPE routine.
    !
    TYPREFTBL = .U_SYMID[RST$L_TYPREFTBL];
    I = 0;
    WHILE .TYPREFTBL[.I] NEQ 0 DO
    	BEGIN
    	U_SYMID = .TYPREFTBL[.I];
    	IF CHECK_UPSCOPE(.U_SYMID, .TYPEID, .PRIMPTR, .DEPTH+1)
    	THEN
    	    BEGIN

    	    ! If we are at the top level of recursion, then do not modify
    	    ! the Primary here. This is because it will get done in
    	    ! GET_RECORD_COMPONENT.
    	    !
    	    IF .DEPTH EQL 0
    	    THEN 
    		RETURN TRUE;

    	    ! The TYPEID matches, so the record component SYMID is valid.
            ! In this case, we do want to perform the component selection.
    	    ! Modify the Primary to include the record component selection.
    	    !
    	    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    	    NODEPTR[DBG$V_PNODE_EVAL] = TRUE;
            TYPCOMPLST = TYPEID[RST$A_TYPCOMPLST];

    	    ! Determine the "component index". This "PNREC_INDEX" field gets
    	    ! used in determining the logical successor.
    	    !
            INCR I FROM 0 TO .TYPEID[RST$L_TYPCOMPCNT] - 1 DO
	        BEGIN
	        COMPSYMID = .TYPCOMPLST[.I];


	        ! If this component is the one we seek, set its index into the Record
	        ! Sub-Node and leave the loop.
	        !
	        IF .SYMID EQL .COMPSYMID
	        THEN
	            BEGIN
	            NODEPTR[DBG$W_PNREC_INDEX] = .I + 1;
	            EXITLOOP;
	            END;
    	        END;

    	    ! Check for FCODE of record - otherwise, it is not valid to skip
    	    ! this component.
    	    !
    	    DBG$STA_SYMTYPE(.SYMID, FCODE, NEW_TYPEID);
    	    IF .FCODE NEQ RST$K_TYPE_RECORD
    	    THEN
    	        RETURN FALSE;


    	    ! Finally append another Primary Descriptor Sub-Node for the selected
    	    ! record component.  Then return.
    	    !
    	    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR,	RST$K_TYPCOMP, .SYMID, 
    				      .FCODE, .NEW_TYPEID, 0);
    	    RETURN TRUE;
    	    END;

    	I = .I + 1;
    	END;

    ! We failed to find a path to the desired TYPEID. Return FALSE.
    !
    RETURN FALSE;
    END;

ROUTINE CONSTANT_TO_VALDESCR(TOKEN) =
!
! FUNCTION
!	This routine converts a Constant Lexical Token Entry into the corre-
!	sponding Value Descriptor.  For string and character constants, this
!	results in an ordinary Value Descriptor, but for numeric constants
!	it results in an "unconverted" Value Descriptor, i.e., a descriptor
!	in which the numeric constant is represented as the original input
!	character string.  The actual conversion of a numeric constant to its
!	binary representation is thus delayed until the appropriate precision
!	of the binary representation can be determined from context.
!
! INPUTS
!	TOKEN	- A pointer to a Constant Lexical Token Entry.  This entry
!		  represents a numeric, string, or character constant of
!		  some sort.
!
! OUTPUTS
!	A Value Descriptor is constructed for the constant and a pointer to
!		  that descriptor is returned as the routine value.
!

    BEGIN

    MAP
	TOKEN: REF TOKEN$ENTRY;		! Pointer to Lexical Token Entry

    LOCAL
	VALPTR: REF DBG$VALDESC;	! Pointer to Value Descriptor we build



    ! Build a skeleton Value Descriptor for the constant and copy the constant
    ! character representation into that descriptor.
    !
    VALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, .TOKEN[TOKEN$B_LENGTH]);
    VALPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    VALPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
    VALPTR[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    VALPTR[DBG$V_DHDR_UNCVT] = TRUE;
    VALPTR[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    VALPTR[DBG$W_VALUE_LENGTH] = .TOKEN[TOKEN$B_LENGTH];
    VALPTR[DBG$L_VALUE_POINTER] = VALPTR[DBG$A_VALUE_ADDRESS];
    VALPTR[DBG$W_VALUE_TOKENCODE] = .TOKEN[TOKEN$W_CODE];
    CH$MOVE(.TOKEN[TOKEN$B_LENGTH], TOKEN[TOKEN$A_NAME],
						VALPTR[DBG$A_VALUE_ADDRESS]);


    ! Determine what kind of constant this is and set the data type and the
    ! "unconverted" bit accordingly.
    !
    CASE .TOKEN[TOKEN$W_CODE] FROM TOKEN$K_MIN_OPERAND TO TOKEN$K_MAX_OPERAND OF
	SET


	! Handle character string constants.  Mark the data as type T.
	!
	[TOKEN$K_STRING]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_T;


	! Handle bit string constants.  Mark the data as type TF.
	!
	[TOKEN$K_BIT_STRING]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_V;


	! Handle decimal integer constants.  Mark the data as type L.
	!
	[TOKEN$K_INTEGER]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;


	! Handle hexadecimal integer constants.  Mark the data as type L.
	!
	[TOKEN$K_HEX_INTEGER]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;


	! Handle octal integer constants.  Mark the data as type L.
	!
	[TOKEN$K_OCT_INTEGER]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;


	! Handle binary integer constants.  Mark the data as type L.
	!
	[TOKEN$K_BIN_INTEGER]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;


	! Handle floating-point constants without exponents.  Mark the data
	! type as F.
	!
	[TOKEN$K_FLOATING]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_F;


	! Handle floating-point constants with E exponents.  Mark the data
	! type as F.
	!
	[TOKEN$K_EXP_E_FLOAT]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_F;


	! Handle floating-point constants with D exponents.  Mark the data
	! type as D.
	!
	[TOKEN$K_EXP_D_FLOAT]:
    	    IF .DBG$GB_MOD_PTR[MODE_G_FLOATS]
    	    THEN
    		BEGIN
	        VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_G;
    		VALPTR[DBG$W_VALUE_TOKENCODE] = TOKEN$K_EXP_G_FLOAT;
    		END

    	    ELSE
	        VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_D;


	! Handle floating-point constants with G exponents.  Mark the data
	! type as G.
	!
	[TOKEN$K_EXP_G_FLOAT]:
    	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_G;


	! Handle floating-point constants with Q exponents.  Mark the data
	! type as H.
	!
	[TOKEN$K_EXP_Q_FLOAT]:
	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_H;


    	! Handle pack decimal constants.  Mark the data type as P.
    	!
    	[TOKEN$K_PACK_DECIMAL]:
    	    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_P;


	! Any other case is an internal error.
	!
	[INRANGE, OUTRANGE]:
	    $DBG_ERROR('DBGPARSER\CONSTANT_TO_VALDESC');

	TES;


    ! The Value Descriptor is constructed.  Return its address to the caller.
    !
    RETURN .VALPTR;

    END;

ROUTINE CONVERT_TO_INTEGER (VALPTR) =
!
! FUNCTION
!	This routine converts a value descriptor to an integer value
!	and returns the integer value.
!
! INPUTS
!	VALPTR -	A pointer to a value descriptor
!
! OUTPUTS
!	An integer value is returned.
!
    BEGIN

    LOCAL
	NEW_VALPTR: REF DBG$VALDESC;	! New value descriptor

    
    ! Build a new value descriptor of type longword integer.
    !
    NEW_VALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
    NEW_VALPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
    NEW_VALPTR[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    NEW_VALPTR[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    NEW_VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    NEW_VALPTR[DBG$W_VALUE_LENGTH] = 4;
    NEW_VALPTR[DBG$L_VALUE_POINTER] = NEW_VALPTR[DBG$A_VALUE_ADDRESS];


    ! Call the routine which does type conversion.
    !
    NEW_VALPTR = DBG$EVAL_LANG_OPERATOR ( 
		DBG$GL_CONVERT_TOKEN, .VALPTR, .NEW_VALPTR);

    ! Return the value in the new value descriptor.
    !
    RETURN .NEW_VALPTR [DBG$L_VALUE_VALUE0];
    END;

ROUTINE CREATE_OPERAND_TOKEN(TOKEN_CODE, TOKENBUFFER) =
!
! FUNCTION
!	This routine creates a Lexical Token Entry for an operand and returns
!	a pointer to the created Token Entry.  The Token Entry is created in
!	temporary memory.  When returned, the Lexical Token Entry will have
!	the TOKEN$B_KIND field set to TOKEN$K_OPERAND and the TOKEN$W_CODE
!	field set the specified operand token code.  The token name or charac-
!	ter representation will also be filled into the Token Entry in Counted
!	ASCII.
!
! INPUTS
!	TOKEN_CODE - This is the code value which indicates which kind of
!		  operand this is.  (TOKEN$K_IDENTIFIER or TOKEN$K_STRING
!		  would be valid examples.)  This value is filled into the
!		  TOKEN$W_CODE field.
!
!	TOKENBUFFER - A pointer to a buffer which contains the Counted ASCII
!		  representation of the operand for which a Token Entry is to
!		  be created.  This buffer will thus contain an identifier
!		  name, the character representation of a numeric constant,
!		  or the contents of a character string constant, depending
!		  on the kind of operand involved.
!
! OUTPUTS
!	A pointer to a Lexical Token Entry for the specified operand is
!		  returned as the routine value.
!

    BEGIN

    MAP
	TOKENBUFFER: REF VECTOR[,BYTE];	! Pointer to token Counted ASCII string

    LOCAL
	TOKEN: REF TOKEN$ENTRY;		! Pointer to new Token Entry created



    ! Get a temporary memory block for the Operand Lexical Token Entry.
    ! Fill in the fields of the Token Entry and return its address.
    !
    TOKEN = DBG$GET_TEMPMEM(TOKEN$K_ENTSIZE + .TOKENBUFFER[0]/%UPVAL + 1);
    TOKEN[TOKEN$B_KIND] = TOKEN$K_OPERAND;
    TOKEN[TOKEN$W_CODE] = .TOKEN_CODE;
    CH$MOVE(.TOKENBUFFER[0] + 1, TOKENBUFFER[0], TOKEN[TOKEN$B_LENGTH]);
    RETURN .TOKEN;

    END;

ROUTINE CREATE_OPERATOR_TOKEN(TOKEN_CODE, TOKENBUFFER, KIND) =
!
! FUNCTION
!	This routine creates a Token Entry for an operator and returns a
!	pointer to the created Token Entry.  The Token Entry is created in
!	temporary memory.  When returned, the Token Entry will have the
!	TOKEN$B_KIND field set to the specified kind and the TOKEN$W_CODE
!	field set the specified operator token code.  The token name or
!	character representation will also be filled into the Token Entry
!	in Counted ASCII.
!
! INPUTS
!	TOKEN_CODE - This is the code value which indicates which type of
!		  operator this is.  (TOKEN$K_DOT, TOKEN$K_ADD, TOKEN$K_BIF_OP
!		  would be valid examples.)  This value is filled into the
!		  TOKEN$W_CODE field.
!
!	TOKENBUFFER - A pointer to a buffer which contains the Counted ASCII
!		  representation of the operator for which a Token Entry is to
!		  be created.  This buffer will thus contain an identifier
!		  name, or the contents of a character string constant,
!		  depending on the kind of operator involved.
!
!	KIND - This is the code value which indicates which kind of operator
!                 this is.  (e.g. TOKEN$K_PREFIX_OP)  This value is filled
!		  into the TOKEN$B_KIND field.
!
! OUTPUTS
!	A pointer to a Token Entry for the specified operand is returned as
!	the routine value.
!

    BEGIN

    MAP
	TOKENBUFFER: REF VECTOR[,BYTE];	! Pointer to token Counted ASCII string

    LOCAL
	TOKEN: REF TOKEN$ENTRY;		! Pointer to new Token Entry created



    ! Get a temporary memory block for the Operator Token Entry.
    ! Fill in the fields of the Token Entry and return its address.
    !
    TOKEN = DBG$GET_TEMPMEM(TOKEN$K_ENTSIZE_OPERATOR + .TOKENBUFFER[0]/%UPVAL + 1);
    TOKEN[TOKEN$B_KIND] = .KIND;
    TOKEN[TOKEN$W_CODE] = .TOKEN_CODE;
    CH$MOVE(.TOKENBUFFER[0] + 1, TOKENBUFFER[0], TOKEN[TOKEN$B_OPLEN]);
    RETURN .TOKEN;

    END;

ROUTINE CREATE_PRID_CONSTANT(PRID) =
!
! FUNCTION
!	This routine creates a value descriptor for the predefined identifier
!	constant and returns the pointer to the value descriptor.
!
! INPUTS
!	PRID	- Pointer to a Predefined Identifier Constant entry in
!		Predefined Identifier Table for the given language.
!
! OUTPUTS
!	A pointer to the value descriptor of Predefined Identifier Constant
!	is returned.
!

    BEGIN

    MAP
	PRID: REF PRID$ENTRY;		! Pointer to Predefined Identifier

    LOCAL
	VALPTR: REF DBG$VALDESC;	! Pointer to Value Descriptor


    VALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
    VALPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    VALPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
    VALPTR[DBG$B_DHDR_FCODE] = .PRID[PRID$B_FCODE];
    VALPTR[DBG$B_VALUE_DTYPE] = .PRID[PRID$B_DTYPE];
    VALPTR[DBG$B_VALUE_CLASS] = DBG$MAP_DTYPE_CLASS(
    					.PRID[PRID$B_DTYPE], FALSE);
    VALPTR[DBG$W_VALUE_LENGTH] = DBG$NUM_BYTES(.PRID[PRID$B_DTYPE]);
    VALPTR[DBG$L_VALUE_POINTER] = VALPTR[DBG$A_VALUE_ADDRESS];
    VALPTR[DBG$L_VALUE_VALUE0] = .PRID[PRID$L_VALUE];
    RETURN .VALPTR;
    END;

ROUTINE DUMP_OPERATOR(OPERATOR, PRIMARY_FLAG): NOVALUE =
!
! FUNCTION
!	This routine dumps out an Operator Lexical Token Entry in a readable
!	format when that operator is about to be evaluated.  It prints one
!	line of output of approximately this format:
!
!			primary operator "\" evaluated (infix)
!
!	This routine is used only for internal DEBUG debugging purposes.  Its
!	output is not seen by normal DEBUG users.  It is only called when
!	Developer Switch 3 is set to trace operator evaluations as they occur.
!
! INPUTS
!	OPERATOR - A pointer to the Lexical Token Entry for the operator
!		  to be dumped.
!
!	PRIMARY_FLAG - A flag whose value is TRUE if this operator is
!		  evaluated as part of a Primary Symbol.  Its value is
!		  FALSE if it is an ordinary expression operator.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	OPERATOR: REF TOKEN$ENTRY;	! Pointer to operator's token entry



    ! Print the main text of the message including the operator name string.
    !
    DBG$PRINT(UPLIT BYTE(%ASCIC '    '), 0);
    IF .PRIMARY_FLAG THEN DBG$PRINT(UPLIT BYTE(%ASCIC 'primary '), 0);
    DBG$PRINT(UPLIT BYTE(%ASCIC 'operator "!AC" evaluated ('),
						OPERATOR[TOKEN$B_OPLEN]);


    ! Then print what kind of operator this is.
    !
    IF .OPERATOR[TOKEN$B_KIND] EQL TOKEN$K_PREFIX_OP
    THEN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'prefix'), 0)

    ELSE IF .OPERATOR[TOKEN$B_KIND] EQL TOKEN$K_INFIX_OP
    THEN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'infix'), 0)

    ELSE IF .OPERATOR[TOKEN$B_KIND] EQL TOKEN$K_POSTFIX_OP
    THEN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'postfix'), 0)

    ELSE
	DBG$PRINT(UPLIT BYTE(%ASCIC 'invalid kind'), 0);


    ! Close out the message, flush the buffer, and return.
    !
    DBG$PRINT(UPLIT BYTE(%ASCIC ')'), 0);
    DBG$NEWLINE();
    RETURN;

    END;

ROUTINE DUMP_TOKEN(TOKEN): NOVALUE =
!
! FUNCTION
!	This routine dumps out a specified Lexical Token Entry in a readable
!	format.  It prints one line of output of approximately this format:
!
!		token found: infix operator, code = 8, string = "**"
!
!	This routine is used only for internal DEBUG debugging purposes.
!	Its output is not seen by normal DEBUG users.  The routine is only
!	called by DBG$PRIMARY_PARSER if Developer Switch 2 is set.
!
! INPUTS
!	TOKEN	- The address of the Lexical Token Entry to dump.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	TOKEN: REF TOKEN$ENTRY;		! Address of Lexical Token Entry to dump

    LOCAL
	KIND,				! Pointer to text saying what kind of
					!      lexical token this is
	NAMEPTR,			! Pointer to the ASCIC name string for
					!      the lexical token
	PRIMARY;			! Pointer to string saying whether this
					!      is a Primary Symbol operator



    ! Determine what kind of Lexical Token Entry this is.
    !
    CASE .TOKEN[TOKEN$B_KIND] FROM TOKEN$K_OPERAND TO TOKEN$K_POSTFIX_OP OF
	SET


	[TOKEN$K_OPERAND]:
	    BEGIN
	    KIND = UPLIT BYTE(%ASCIC 'operand');
	    NAMEPTR = TOKEN[TOKEN$B_LENGTH];
	    END;


	[TOKEN$K_PREFIX_OP]:
	    BEGIN
	    KIND = UPLIT BYTE(%ASCIC 'prefix operator');
	    NAMEPTR = TOKEN[TOKEN$B_OPLEN];
	    END;


	[TOKEN$K_INFIX_OP]:
	    BEGIN
	    KIND = UPLIT BYTE(%ASCIC 'infix operator');
	    NAMEPTR = TOKEN[TOKEN$B_OPLEN];
	    END;


	[TOKEN$K_POSTFIX_OP]:
	    BEGIN
	    KIND = UPLIT BYTE(%ASCIC 'postfix operator');
	    NAMEPTR = TOKEN[TOKEN$B_OPLEN];
	    END;


	[INRANGE, OUTRANGE]:
	    BEGIN
	    KIND = UPLIT BYTE(%ASCIC 'invalid kind');
	    NAMEPTR = UPLIT BYTE(%ASCIC '');
	    END;

	TES;


    ! Print the line describing the Lexical Token Entry.
    !
    PRIMARY = UPLIT BYTE(%ASCIC '');
    IF .TOKEN[TOKEN$V_PRIMARY] THEN PRIMARY = UPLIT BYTE(%ASCIC ' (primary)');
    DBG$PRINT(UPLIT BYTE(%ASCIC 'token found: !AC!AC, code = !SL, string = "!AC"'),
		.KIND, .PRIMARY, .TOKEN[TOKEN$W_CODE], .NAMEPTR);
    DBG$NEWLINE();
    RETURN;

    END;

ROUTINE DUMP_PRIMARY(PRIMPTR): NOVALUE =
!
! FUNCTION
!	This routine dumps out a Primary Descriptor or a Value Descriptor
!	in hexadecimal on the terminal.  For a Primary Descriptor, it dumps
!	out not only the Root Node but also all Sub-Nodes.  This routine is
!	used only for internal DEBUG debugging purposes.  Its output is not
!	seen by normal DEBUG users.  It is only called if Developer Switch
!	3 is set.
!
! INPUTS
!	PRIMPTR	- A pointer to the Primary Descriptor or the Value Descriptor
!		  to be dumped out.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	PRIMPTR: REF DBG$PRIMARY;	! Pointer to Primary Descriptor

    LOCAL
	LENGTH,				! Byte length of Primary Descr Sub-Node
	NODEPTR: REF DBG$PRIM_NODE;	! Pointer to Primary Descr Sub-Node



    ! If this is a Primary Descriptor, dump out the Root Node and then loop to
    ! dump out all the individual Sub-Nodes.
    !
    IF .PRIMPTR[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
    THEN
	BEGIN


	! Dump out the Primary Descriptor Root Node.
	!
	DBG$DUMP_HEX(.PRIMPTR, DBG$K_PRIMARY_SIZE*%UPVAL, .PRIMPTR,
			UPLIT BYTE (%ASCIC '      Primary Descriptor:'));


	! Dump out each of the Primary Descriptor Sub-Nodes.  Note that the
	! length of the Sub-Node in bytes depends on the FCODE stored in the
	! Sub-Node.
	!
	NODEPTR = .PRIMPTR[DBG$L_PRIM_FLINK];
	WHILE .NODEPTR NEQ PRIMPTR[DBG$A_PRIM_FLINK] DO
	    BEGIN
	    IF .NODEPTR[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_ARRAY
	    THEN
		LENGTH = %UPVAL*(DBG$K_PRIM_SIZE_ARRAY +
			DBG$K_PRIM_SIZE_SUBS*.NODEPTR[DBG$B_PNARR_DIMCNT])

	    ELSE IF .NODEPTR[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_RECORD
	    THEN
		LENGTH = DBG$K_PRIM_SIZE_RECORD*%UPVAL

	    ELSE IF .NODEPTR[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_VARIANT
	    THEN
		LENGTH = DBG$K_PRIM_SIZE_VARIANT*%UPVAL

	    ELSE
		LENGTH = DBG$K_PRIM_SIZE_NORMAL*%UPVAL;

	    DBG$DUMP_HEX(.NODEPTR, .LENGTH, .NODEPTR,
			UPLIT BYTE (%ASCIC '      Primary Sub-Node:'));
	    NODEPTR = .NODEPTR[DBG$L_PNODE_FLINK];
	    END;

	END


    ! If this is a Value Descriptor, dump it as such.
    !
    ELSE IF .PRIMPTR[DBG$B_DHDR_TYPE] EQL DBG$K_VALUE_DESC
    THEN
	DBG$DUMP_HEX(.PRIMPTR, .PRIMPTR[DBG$W_DHDR_LENGTH], .PRIMPTR,
			UPLIT BYTE (%ASCIC '      Value Descriptor:'))


    ! If this is a Volatile Value Descriptor, dump it as such.
    !
    ELSE IF .PRIMPTR[DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC
    THEN
	DBG$DUMP_HEX(.PRIMPTR, .PRIMPTR[DBG$W_DHDR_LENGTH], .PRIMPTR,
			UPLIT BYTE (%ASCIC '      Volatile Value Descriptor:'))


    ! If it is none of the above, something is wrong but we try to dump the
    ! descriptor anyway.
    !
    ELSE
	DBG$DUMP_HEX(.PRIMPTR, .PRIMPTR[DBG$W_DHDR_LENGTH], .PRIMPTR,
			UPLIT BYTE (%ASCIC '      Invalid Descriptor Type:'));


    ! We are all done--now return.
    !
    RETURN;
    END;

ROUTINE FIX_UP_PRIMARY(PRIMPTR): NOVALUE =
!
! FUNCTION
!	This routine is needed to handle a special case that may arise
!	in conjunction with the array slice feature: If X is a two -
!	dimensional array, say 10x10, and the user specifies EX X[5],
!	then we want to treat this as if he had said X[5][1:10].
!	However, we do not know at the time we are picking up the "5"
!	subscript whether he is going to say X[5] or X[5][6], for example.
!	So we cannot fix up the lower/upper bounds properly until after
!	all the subscripts have been picked up. This is the routine
!	that gets called after all the subscripts have been picked
!	up, to fix up these bounds.
!
! INPUTS
!	PRIMPTR	- A pointer to the Primary Descriptor being constructed.
!
! OUTPUTS
!	The Primary Descriptor pointed to by PRIMPTR may be modified.
!
    BEGIN
    MAP
    	PRIMPTR: REF DBG$PRIMARY;

    LOCAL
    	NODEPTR: REF DBG$PRIM_NODE,
    	SUBVECTOR: REF DBG$PRIM_NODE_SUBS;


    ! Obtain a pointers to the Primary Descriptor Subnode and the
    ! subscript vector within that subnode. Do nothing if the
    ! subnode is not for an array.
    ! 
    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    IF .NODEPTR[DBG$B_PNODE_FCODE] NEQ RST$K_TYPE_ARRAY
    THEN
    	RETURN;
    SUBVECTOR = NODEPTR[DBG$A_PNARR_SVECTOR];


    ! Check for the subscript count being less than the dimension count,
    ! but the range bit not being set. The point here is that we want
    ! to treat this case as if it really were a range (e.g., treat
    ! X[1] as being the same as X[1][1:10]. Note that this same code
    ! appears in GET_SUBSCRIPTS when we discover that we do have a range.
    !
    IF  .NODEPTR[DBG$B_PNARR_SUBCNT] LSS .NODEPTR[DBG$B_PNARR_DIMCNT]
    AND NOT .NODEPTR[DBG$V_PNARR_RANGE]
    THEN
    	BEGIN
    	NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
    	INCR I FROM 0 TO .NODEPTR[DBG$B_PNARR_SUBCNT] - 1 DO
    	    BEGIN
    	    SUBVECTOR[.I, DBG$L_PNSUB_LBOUND] = 
    		.SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
    	    SUBVECTOR[.I, DBG$L_PNSUB_UBOUND] = 
    		.SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
    	    END;
    	END;
    RETURN;
    END;

ROUTINE GET_BLISS_SUBSCRIPTS(PRIMPTR, NAME): NOVALUE =
!
! FUNCTION
!	This routine picks up subscript values in a BLISS structure 
!	reference (i.e., any BLISS primary of the form X[...]).
!	It calls DBG$EXPRESSION_PARSER to pick up each subscript.
!
!	The kinds of BLISS structures we accept are:
!
!		X[i]		bitvector
!		X[i]		vector
!		X[n,p,s,e]	block
!		X[m,n,p,s,e]	blockvector
!
!	This routine assumes that the opening subscript bracket has
!	already been found and that the parse pointer points to the start
!	of the first subscript expression.  When this routine returns,
!	the parse pointer is left pointing at the first character after
!	the closing subscript bracket.
!
! INPUTS
!	PRIMPTR	- A pointer to the Primary Descriptor for a structure about
!		  to be subscripted.
!	NAME	- The name of the object being subscripted (for error
!		  message purposes)
!
! OUTPUTS
!	The PRIMPTR Primary Descriptor is changed to include the subscript
!		  information. This is represented as follows:
!
!	X[i] bitvector		- i is stored in a Primary Descriptor Array
!    				  sub-node.
!	X[i] vector		- i is stored in a Primary Descriptor Array
!    				  sub-node.
!	X[n,p,s,e] block	- n is stored in a Primary Descriptor Array
!    				  sub-node. p, s, and e are stored in the
!    				  Primary Descriptor Root node, in the
!    				  prim_offset, prim_length, and sgnext fields.
!	X[m,n,p,s,e] blockvector- m and n are stored in a Primary Descriptor
!				  Array sub-node. p, s, and e are stored in the
!    				  Primary Descriptor Root node, in the
!    				  prim_offset, prim_length, and sgnext fields.
!
    BEGIN

    MAP	
	PRIMPTR: REF DBG$PRIMARY;	! Pointer to BLISS structure Primary
					!    Descriptor.

    LOCAL
    	COUNT,				! Count of field values
	DECLTYPE: REF DBG$VALDESC,	! Pointer to value descriptor for the
					!    subscript value.
	DSTPTR: REF DST$RECORD,		! Pointer to BLISS structure DST entry
	FCODE,				! Data type FCODE for current symbol
    	LA_PTR: REF VECTOR[,BYTE],	! Lookahead pointer into input
	LOW_RANGE_VAL,			! The lower value of a subscript range
	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to Prim Desc Array sub-node
	NODESUBPTR: REF DBG$PRIM_NODE_SUBS, ! Pointer to subscript blockvector
					!	  in Prim Desc Array sub-node
	PTR: REF VECTOR[,LONG],		! Temporary pointer to field name values
	REF_FLAG,			! True for REF objects
	RSTPTR: REF RST$ENTRY,		! Pointer to BLISS structure RST entry
	SAVED_RADIX,			! Temporarily saved expression radix
    	STRIDE,				! Stride for blocks and blockvectors
	STRUC,				! Code for kind of BLISS structure
       	SUBSCR_COUNT,			! Count of the number of subscripts
	SUBVECTOR: VECTOR[5],		! Vector of subscripts
    	TOKEN,				! Pointer to a Lexical Token
	TYPEID,				! Pointer to a typeid
	VALPTR: REF DBG$VALDESC,	! Pointer to subscript Value Descriptor
	VALUE;				! Subscript value

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;

    ! Check that the Primary Descriptor has the correct Kind and FCODE.
    ! If so, obtain a pointer to the DST record for this BLISS structure.
    !
    RSTPTR = .PRIMPTR [DBG$L_DHDR_SYMID0];
    IF .RSTPTR EQL 0
    THEN
    	SIGNAL(DBG$_NOTASTRUCT, 1, .NAME);
    DSTPTR = .RSTPTR [RST$L_DSTPTR];
    IF .PRIMPTR [DBG$B_DHDR_KIND] NEQ RST$K_DATA
    THEN
	SIGNAL (DBG$_NOTASTRUCT, 1, DSTPTR[DST$B_NAME]);

    DBG$STA_SYMTYPE (.RSTPTR, FCODE, TYPEID);
    IF .FCODE NEQ RST$K_TYPE_BLIDATA
    THEN
	SIGNAL (DBG$_NOTASTRUCT, 1, DSTPTR[DST$B_NAME]);


    ! Check for no field structure in the RST - this arises when the
    ! user defines his own BLISS structure, instead of using one of
    ! the builtins BITVECTOR, VECTOR, BLOCK, or BLOCKVECTOR. We do
    ! not handle this case.
    !
    STRUC = .DSTPTR [DST$V_BLI_STRUC];
    IF .STRUC EQL DST$K_BLI_NOSTRUC
    THEN
	SIGNAL(DBG$_NOTASTRUCT, 1, DSTPTR[DST$B_NAME]);


    ! If the REF bit is set, then there is a sub-node for the dereferencing.
    ! Call DBG$BUILD_PRIMARY_SUBNODE to build a new subnode for the array
    ! information. Light the EVAL bit in the dereference subnode.
    !
    IF .DSTPTR [DST$V_BLI_REF]
    THEN
	BEGIN
	DBG$BUILD_PRIMARY_SUBNODE (.PRIMPTR, RST$K_DATA, 0, RST$K_TYPE_BLIDATA,
				   .PRIMPTR [DBG$L_DHDR_TYPEID], .DSTPTR);
	NODEPTR = .PRIMPTR [DBG$L_PRIM_FLINK];
	NODEPTR [DBG$V_PNODE_EVAL] = TRUE;
	REF_FLAG = TRUE;
	END
    ELSE
	REF_FLAG = FALSE;


    ! Obtain pointers to the Primary Descriptor Sub-Node and the subscript
    ! blockvector within that node.  Light the eval bit in the subnode.
    !
    NODEPTR = .PRIMPTR [DBG$L_PRIM_BLINK];
    NODESUBPTR = NODEPTR [DBG$A_PNARR_SVECTOR];
    NODEPTR [DBG$V_PNODE_EVAL] = TRUE;


    ! Loop through the list of subscripts.  Pick up each actual subscript and
    ! add it to the subscript vector.  When we get to the closing subscript
    ! parenthesis, we check all the subscript values for validity and complete
    ! the Primary Descriptor Sub-Node accordingly.
    !
    SUBSCR_COUNT = 0;
    TERMINATOR_CODE = TOKEN$K_TERM_COMMA;
    WHILE .TERMINATOR_CODE NEQ TOKEN$K_TERM_CLOSE DO
	BEGIN


    	! Look for the asterisk. X[*] is the same as X[lower:upper].
    	! If we find the asterisk then advance the character pointer beyond
    	! the asterisk and also increment the subscript count.
    	!
    	LA_PTR = .CHARPTR;
    	WHILE .LA_PTR[0] EQL ' ' DO LA_PTR = .LA_PTR + 1;
    	IF .LA_PTR[0] EQL '*'
    	THEN
    	    BEGIN
	    IF .NODEPTR[DBG$V_PNARR_RANGE] OR
	      (.SUBSCR_COUNT NEQ 0)       OR
	     ((.STRUC NEQ DST$K_BLI_BITVEC) AND
	      (.STRUC NEQ DST$K_BLI_VEC)    AND
	      (.STRUC NEQ DST$K_BLI_BLKVEC))
	    THEN
		SIGNAL(DBG$_INVRANSPEC);

    	    CHARPTR = .LA_PTR + 1;
    	    SUBSCR_COUNT = .SUBSCR_COUNT + 1;

    	    ! Call the Lexical Scanner to take us past the ',' or 
    	    ! or ']' or ')'. This will set TERMINATOR_CODE to the
    	    ! terminator that is seen. If we do not see a terminator
    	    ! then signal a syntax error. Also signal an error if
    	    ! ':' was the terminator.
    	    !
    	    TOKEN = DBG$LEXICAL_SCANNER (FALSE, FALSE,
    			.SUBSCRIPT_TERM_TBL, 0);
    	    IF .TOKEN NEQ TERMINATOR_TOKEN
    	    THEN
    		BEGIN
    		LOCAL
    		    ASCIC_STRING: VECTOR[2,BYTE];
    		ASCIC_STRING[0] = 1;
    		ASCIC_STRING[1] = .CHARPTR[0];
    		SIGNAL(DBG$_SYNERREXPR, 1, ASCIC_STRING);
    		END;	
    	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
    	    THEN    		
    		SIGNAL (DBG$_INVRANSPEC);
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE 
    	    THEN 
    		SIGNAL(DBG$_MISCLOSUB);
	    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


    	    ! Turn this reference into a range.
    	    !
	    NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
	    LOW_RANGE_VAL = .NODESUBPTR[0, DBG$L_PNSUB_LBOUND];
	    SUBVECTOR[0] = .NODESUBPTR[0, DBG$L_PNSUB_UBOUND];
    	    END

    	ELSE
    	    BEGIN


	    ! Call the Expression Parser to pick up the next subscript.  Note that
	    ! we set the radix to decimal over this call and then restore it.  Also
	    ! note that OWN variables TERMINATOR_CODE and TERMINATOR_LENGTH are set
	    ! by the Expression Parser as side-effects.
	    !
	    SAVED_RADIX = .EXPRESSION_RADIX;
	    EXPRESSION_RADIX = DBG$K_DECIMAL;
	    VALPTR = DBG$EXPRESSION_PARSER (FALSE, .SUBSCRIPT_TERM_TBL);
	    EXPRESSION_RADIX = .SAVED_RADIX;


	    ! Check the terminator code.  If there was no terminator (i.e., the
	    ! input line just ended), signal an error.  Otherwise we got a comma,
	    ! colon, or closing bracket and we increment CHARPTR to get past it.
 	    !
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE THEN SIGNAL(DBG$_MISCLOSUB);
	    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


	    ! Check whether this "subscript" is actually a BLISS field name.  If
	    ! so, set up a pointer to the BLISS field components and copy those
	    ! four components into the subscript vector.
	    !
	    IF .VALPTR [DBG$B_DHDR_FCODE] EQL RST$K_TYPE_BLIFLD
	    THEN
	        BEGIN
	        IF .NODEPTR[DBG$V_PNARR_RANGE] AND (.SUBSCR_COUNT EQL 0)
	        THEN 
		    SIGNAL(DBG$_INVRANSPEC);

	        PTR = VALPTR[DBG$A_VALUE_ADDRESS];
    	        COUNT = .PTR[0];
	        INCR I FROM 1 TO .COUNT DO
		    BEGIN
		    IF .SUBSCR_COUNT LSS 5 THEN SUBVECTOR[.SUBSCR_COUNT] = .PTR[.I];
		    SUBSCR_COUNT = .SUBSCR_COUNT + 1;
		    END;

	        END


	    ! The subscript is not a BLISS field name so we pick up the subscript
	    ! value and convert it to integer.  This subscript value is then put
	    ! away in the subscript vector and the subscript count is incremented.
	    !
	    ELSE
	        BEGIN


	        ! Convert the value descriptor to an integer value.
	        !
	        VALUE = CONVERT_TO_INTEGER (.VALPTR);


	        ! If the terminator is a colon, we have the first part of a sub-
	        ! script range specification (such as "ARR[2:5]").  See if a range
	        ! specification is allowed (it is only allowed on the first sub-
	        ! script of a bitvector, a normal vector, or a blockvector) and
	        ! save away this lower value of the range.
	        !
	        IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
	        THEN
		    BEGIN
		    IF .NODEPTR[DBG$V_PNARR_RANGE] OR
		      (.SUBSCR_COUNT NEQ 0)       OR
		     ((.STRUC NEQ DST$K_BLI_BITVEC) AND
		      (.STRUC NEQ DST$K_BLI_VEC)    AND
		      (.STRUC NEQ DST$K_BLI_BLKVEC))
		    THEN
		        SIGNAL(DBG$_INVRANSPEC);

		    NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
		    LOW_RANGE_VAL = .VALUE;
		    END


	        ! The terminator is not a colon, so we have the complete specifica-
	        ! tion for the current subscript.  Here we simply fill the subscript
	        ! value (or the upper bound of the range) into SUBVECTOR and incre-
	        ! ment the subscript count.  We can ignore subscripts after the
	        ! fifth one because they will be in error anyway.
	        !
	        ELSE
		    BEGIN
		    IF .SUBSCR_COUNT LSS 5
		    THEN
		        SUBVECTOR[.SUBSCR_COUNT] = .VALUE;

		    SUBSCR_COUNT = .SUBSCR_COUNT + 1;
	            END;
    		END;
	    END;

	END;				! End of WHILE loop over subscripts


    ! We found the end of the subscript list, i.e. the closing subscript
    ! parenthesis.  Now case on the kind of BLISS structure we are dealing
    ! with and check the subscript values and build the Primary Descriptor
    ! Sub-Node accordingly.
    !
    CASE .STRUC FROM DST$K_BLI_NOSTRUC TO DST$K_BLI_BLKVEC OF
	SET


	! Handle the Bitvector case.
	!
	[DST$K_BLI_BITVEC]:
	    BEGIN


	    ! Check that the bit-vector had exactly one subscript.
	    !
	    IF .SUBSCR_COUNT LSS 1 THEN SIGNAL(DBG$_TOOFEWSUB, 1, 1);
	    IF .SUBSCR_COUNT GTR 1 THEN SIGNAL(DBG$_TOOMANSUB, 1, 1);


	    ! Check that the subscript value is in range.
	    !
	    IF NOT .REF_FLAG
	    THEN
		BEGIN
	        IF (.SUBVECTOR[0] LSS 0) OR
	           (.SUBVECTOR[0] GEQ .DSTPTR[DST$L_BLI_BITVEC_SIZE])
	        THEN
		    SIGNAL (DBG$_STRUCSIZE, 2,
			   .DSTPTR[DST$L_BLI_BITVEC_SIZE], .SUBVECTOR[0]);


	        ! If a subscript range was specified, check that the lower range
	        ! value is also in range.
	        !
	        IF .NODEPTR[DBG$V_PNARR_RANGE] AND
	         ((.LOW_RANGE_VAL LSS 0) OR
		  (.LOW_RANGE_VAL GEQ .DSTPTR[DST$L_BLI_BITVEC_SIZE]))
	        THEN
		    SIGNAL (DBG$_STRUCSIZE, 2,
			   .DSTPTR[DST$L_BLI_BITVEC_SIZE], .LOW_RANGE_VAL);
		END;


	    ! Fill in the Primary Descriptor Array Sub-Node.
	    !
	    NODEPTR [DBG$B_PNARR_SUBCNT] = 1;
	    NODESUBPTR [0, DBG$L_PNSUB_SVALUE] = .SUBVECTOR[0];

	    END;			! End of bitvector case


	! Handle ordinary BLISS vectors.
	!
	[DST$K_BLI_VEC]:
	    BEGIN


	    ! Check that the vector had exactly one subscript.
	    !
	    IF .SUBSCR_COUNT LSS 1 THEN SIGNAL(DBG$_TOOFEWSUB, 1, 1);
	    IF .SUBSCR_COUNT GTR 1 THEN SIGNAL(DBG$_TOOMANSUB, 1, 1);


	    ! Check that the subscript value is in range.
	    !
	    IF NOT .REF_FLAG
	    THEN
		BEGIN
	        IF (.SUBVECTOR[0] LSS 0) OR
	           (.SUBVECTOR[0] GEQ .DSTPTR[DST$L_BLI_VEC_UNITS])
	        THEN
		    SIGNAL(DBG$_STRUCSIZE, 2,
			  .DSTPTR[DST$L_BLI_VEC_UNITS], .SUBVECTOR[0]);


	        ! If a subscript range was specified, check that the lower range
	        ! value is also in range.
	        !
	        IF .NODEPTR[DBG$V_PNARR_RANGE] AND
	         ((.LOW_RANGE_VAL LSS 0) OR
		  (.LOW_RANGE_VAL GEQ .DSTPTR[DST$L_BLI_VEC_UNITS]))
	        THEN
		    SIGNAL(DBG$_STRUCSIZE, 2,
			  .DSTPTR[DST$L_BLI_VEC_UNITS], .LOW_RANGE_VAL);
		END;


	    ! Fill in the Primary Descriptor Sub-Node.
	    !
	    NODEPTR [DBG$B_PNARR_SUBCNT] = 1;
	    NODESUBPTR [0, DBG$L_PNSUB_SVALUE] = .SUBVECTOR[0];

	    END;			! End of BLISS vector case


	! Handle BLISS blocks.
	!
	[DST$K_BLI_BLOCK]:
	    BEGIN

    	    ! Fill in the correct information for the array subnode
    	    ! (It was dummied up as an array of longwords for purposes
    	    !  of aggregate output earlier).
    	    !
    	    STRIDE = .DSTPTR [DST$V_BLI_BLOCK_UNIT_SIZE];
	    NODESUBPTR [0, DBG$L_PNSUB_STRIDE] = .STRIDE; 
	    NODESUBPTR [0, DBG$L_PNSUB_UBOUND] = 
    		.DSTPTR [DST$L_BLI_BLOCK_UNITS]-1;
    	    NODEPTR[DBG$W_PNARR_LENGTH] = .STRIDE;
    	    IF .STRIDE EQL 1
    	    THEN
    		IF .SUBVECTOR[3]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_B
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_BU
    	    ELSE IF .STRIDE EQL 2
    	    THEN
    		IF .SUBVECTOR[3]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_W
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_WU
    	    ELSE IF .STRIDE EQL 4
    	    THEN
    		IF .SUBVECTOR[3]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_L
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_LU
    	    ELSE
    		BEGIN
    		IF .SUBVECTOR[3]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_V
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_VU;
    		NODEPTR[DBG$W_PNARR_LENGTH] = 8 * .NODEPTR[DBG$W_PNARR_LENGTH];
    		END;

	    ! Check that the block had exactly four subscripts.
	    !
	    IF .SUBSCR_COUNT LSS 4 THEN SIGNAL(DBG$_TOOFEWSUB, 1, 4);
	    IF .SUBSCR_COUNT GTR 4 THEN SIGNAL(DBG$_TOOMANSUB, 1, 4);


	    ! Check that the subscript values are in range.
	    !
	    IF NOT .REF_FLAG
	    THEN
	        IF (.SUBVECTOR[0] LSS 0) OR
	           (.SUBVECTOR[0] GEQ .DSTPTR[DST$L_BLI_BLOCK_UNITS])
	        THEN
		    SIGNAL(DBG$_STRUCSIZE, 2,
			  .DSTPTR[DST$L_BLI_BLOCK_UNITS], .SUBVECTOR[0]);

    	    IF (.SUBVECTOR[1] LSS -%X'8000') OR 
    	       (.SUBVECTOR[1] GTR %X'7FFF')
    	    THEN
    		SIGNAL(DBG$_ILLOFFSET, 1, .SUBVECTOR[1]);

	    IF (.SUBVECTOR[2] LSS 0)
	    THEN
		SIGNAL(DBG$_ILLLENGTH, 1, .SUBVECTOR[2]);

	    IF (.SUBVECTOR[2] GTR 32)
	    THEN
		BEGIN
		SUBVECTOR[2] = 32;
		SIGNAL(DBG$_SIZETRUNC);
		END;

	    IF (.SUBVECTOR[3] NEQ 0) AND (.SUBVECTOR[3] NEQ 1)
	    THEN
		SIGNAL(DBG$_ILLSIGEXT, 1, .SUBVECTOR[3]);


	    ! Fill in the Primary Descriptor Sub-Node.
	    !
	    PRIMPTR [DBG$V_DHDR_BLIBLK] = TRUE;
	    PRIMPTR [DBG$V_DHDR_SUBREF] = TRUE;
	    PRIMPTR [DBG$V_DHDR_BITREF] = TRUE;  
	    PRIMPTR [DBG$W_PRIM_OFFSET] = .SUBVECTOR[1];
	    PRIMPTR [DBG$W_PRIM_LENGTH] = .SUBVECTOR[2];
	    PRIMPTR [DBG$V_DHDR_SGNEXT] = .SUBVECTOR[3];
	    NODEPTR [DBG$B_PNARR_SUBCNT] = 1;
	    NODESUBPTR [0, DBG$L_PNSUB_SVALUE] = .SUBVECTOR[0];

	    END;			! End of BLISS block case


	! Handle the Blockvector case.
	!
	[DST$K_BLI_BLKVEC]:
	    BEGIN

    	    ! We previously represented the block as a block of longwords,
    	    ! for purposes of aggregate output. If we get here, however,
    	    ! we are no longer doing aggregate output.
    	    ! So, fix up the information
    	    ! here, filling in the correct stride.
    	    !
    	    STRIDE = .DSTPTR [DST$B_BLI_BLKVEC_UNIT_SIZE];
	    NODESUBPTR [1, DBG$L_PNSUB_STRIDE] = .STRIDE; 
	    NODESUBPTR [1, DBG$L_PNSUB_UBOUND] =
		.DSTPTR [DST$L_BLI_BLKVEC_UNITS]-1;
    	    NODEPTR[DBG$W_PNARR_LENGTH] = .STRIDE;
    	    IF .STRIDE EQL 1
    	    THEN
    		IF .SUBVECTOR[4]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_B
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_BU
    	    ELSE IF .STRIDE EQL 2
    	    THEN
    		IF .SUBVECTOR[4]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_W
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_WU
    	    ELSE IF .STRIDE EQL 4
    	    THEN
    		IF .SUBVECTOR[4]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_L
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_LU
    	    ELSE
    		BEGIN
    		IF .SUBVECTOR[4]
    		THEN
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_V
    		ELSE
	            NODEPTR [DBG$B_PNARR_DTYPE] = DSC$K_DTYPE_VU;
    		NODEPTR[DBG$W_PNARR_LENGTH] = 8 * .NODEPTR[DBG$W_PNARR_LENGTH];
    		END;

	    ! Check that the block-vector had exactly five subscripts.
	    !
	    IF .SUBSCR_COUNT LSS 5 THEN SIGNAL(DBG$_TOOFEWSUB, 1, 5);
	    IF .SUBSCR_COUNT GTR 5 THEN SIGNAL(DBG$_TOOMANSUB, 1, 5);


	    ! Check that the subscript values are in range.
	    !
	    IF NOT .REF_FLAG
	    THEN
		BEGIN
	        IF (.SUBVECTOR[0] LSS 0) OR
	           (.SUBVECTOR[0] GEQ .DSTPTR[DST$L_BLI_BLKVEC_BLOCKS])
	        THEN
		    SIGNAL(DBG$_STRUCSIZE, 2,
			  .DSTPTR[DST$L_BLI_BLKVEC_BLOCKS], .SUBVECTOR[0]);

	        IF (.SUBVECTOR[1] LSS 0) OR
	           (.SUBVECTOR[1] GEQ .DSTPTR[DST$L_BLI_BLKVEC_UNITS])
	        THEN
		    SIGNAL(DBG$_STRUCSIZE, 2,
			  .DSTPTR[DST$L_BLI_BLKVEC_UNITS], .SUBVECTOR[1]);
		END;

    	    IF (.SUBVECTOR[2] LSS -%X'8000') OR
    	       (.SUBVECTOR[2] GTR %X'7FFF')
    	    THEN
    		SIGNAL(DBG$_ILLOFFSET, 1, .SUBVECTOR[2]);

	    IF (.SUBVECTOR[3] LSS 0)
	    THEN
		SIGNAL(DBG$_ILLLENGTH, 1, .SUBVECTOR[3]);

	    IF (.SUBVECTOR[3] GTR 32)
	    THEN
		BEGIN
		SUBVECTOR[3] = 32;
		SIGNAL(DBG$_SIZETRUNC);
		END;

	    IF (.SUBVECTOR[4] NEQ 0) AND (.SUBVECTOR[4] NEQ 1)
	    THEN
		SIGNAL(DBG$_ILLSIGEXT, 1, .SUBVECTOR[4]);


	    ! If a subscript range was specified, check that the lower range
	    ! value is also in range.
	    !
	    IF NOT .REF_FLAG
	    THEN
	        IF .NODEPTR[DBG$V_PNARR_RANGE] AND
	         ((.LOW_RANGE_VAL LSS 0) OR
		  (.LOW_RANGE_VAL GEQ .DSTPTR[DST$L_BLI_BLKVEC_BLOCKS]))
	        THEN
		    SIGNAL(DBG$_STRUCSIZE, 2,
			  .DSTPTR[DST$L_BLI_BLKVEC_BLOCKS], .LOW_RANGE_VAL);


	    ! Fill in the Primary Descriptor Sub-Node.
	    !
	    PRIMPTR [DBG$V_DHDR_BLIBLK] = TRUE;
	    PRIMPTR [DBG$V_DHDR_SUBREF] = TRUE;
	    PRIMPTR [DBG$V_DHDR_BITREF] = TRUE;  
	    PRIMPTR [DBG$W_PRIM_OFFSET] = .SUBVECTOR[2];
	    PRIMPTR [DBG$W_PRIM_LENGTH] = .SUBVECTOR[3];
	    PRIMPTR [DBG$V_DHDR_SGNEXT] = .SUBVECTOR[4];
	    NODEPTR [DBG$B_PNARR_SUBCNT] = 2;
	    NODESUBPTR [0, DBG$L_PNSUB_SVALUE] = .SUBVECTOR[0];
	    NODESUBPTR [1, DBG$L_PNSUB_SVALUE] = .SUBVECTOR[1];

    	    ! If there was a range on the first subscript then make 
    	    ! the second one into a range too.
    	    !
	    IF .NODEPTR[DBG$V_PNARR_RANGE]
    	    THEN
    		BEGIN
    		NODESUBPTR [1, DBG$L_PNSUB_LBOUND] = .SUBVECTOR[1];
    		NODESUBPTR [1, DBG$L_PNSUB_UBOUND] = .SUBVECTOR[1];
    		END;
	    END;			! End of BLISS block-vector case


	! Any other case should never occur and constitutes an internal
	! error in the BLISS Debug Symbol Table (DST).
	!
	[INRANGE, OUTRANGE]:
	    SIGNAL(DBG$_INVDSTREC);
	
	TES;				! End of CASE of BLISS structure type


    ! If a subscript range (as in ARR[2:5]) was specified for the first sub-
    ! script, modify the array's lower and upper bounds in the Primary Descrip-
    ! tor to represent the array "slice" specified by that subscript range.
    !
    IF .NODEPTR[DBG$V_PNARR_RANGE]
    THEN
	BEGIN
	IF .LOW_RANGE_VAL GTR .SUBVECTOR[0] THEN SIGNAL(DBG$_INVRANSPEC);
	NODESUBPTR[0, DBG$L_PNSUB_SVALUE] = .LOW_RANGE_VAL;
	NODESUBPTR[0, DBG$L_PNSUB_LBOUND] = .LOW_RANGE_VAL;
	NODESUBPTR[0, DBG$L_PNSUB_UBOUND] = .SUBVECTOR[0];
	RETURN;
	END;


    ! Build a new subnode. The typeid that we pass in to
    ! BUILD_PRIMARY_SUBNODE describes the element referenced by the 
    ! subscript expression. This typeid is pulled from the CELLTYPE field.
    !
    DBG$BUILD_PRIMARY_SUBNODE (.PRIMPTR, RST$K_DATA, 0, 
	RST$K_TYPE_ATOMIC, .NODEPTR[DBG$L_PNARR_CELLTYPE], 0);
    RETURN;
    END;

ROUTINE GET_DEREFERENCE (PRIMPTR): NOVALUE =
!
! FUNCTION
!	This routine is called upon seeing the dereference operator, e.g.,
!	the ^ in a PASCAL primary such as A^.
!
!	If the object being dereferenced is a pointer or a file variable, then
!	this routine lights a bit in the current primary subnode which
!	indicates that the dereference is taking place. It then calls
!	DBG$BUILD_PRIMARY_SUBNODE to append a new subnode. The type 
!	information in the new subnode reflects the type of the object
!	being pointed to; or in the case of file variables, the type
!	of the objects in the file.
!
! INPUTS
!	PRIMPTR		- A pointer to the Primary Descriptor currently
!			  being constructed by DBG$PRIMARY_PARSER.
!
! OUTPUTS
!	The Primary Descriptor pointed to by PRIMPTR is modified.
!
    BEGIN

    MAP
	PRIMPTR: REF DBG$PRIMARY;

    LOCAL
	FCODE,				! Local variable holding fcode info
    	JUNK,				! Dummy output parameter
	NODEPTR: REF DBG$PRIM_NODE,	! Points to a Primary Sub-node
	TYPEID;				! Pointer to a RST type entry

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;


    ! Check that the object being dereferenced is actually a pointer.
    !
    IF  .PRIMPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_TPTR
    AND .PRIMPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_FILE
    THEN
    	SIGNAL(DBG$_NOTPTR);


    ! Obtain a pointer to the bottom level sub-node by following the
    ! back-pointer. Light the EVAL bit in this subnode,
    ! which indicates that pointer dereferencing is
    ! taking place.
    ! Then, obtain the pointer to the RST type entry for the object being 
    ! dereferenced.
    !
    NODEPTR = .PRIMPTR [DBG$L_PRIM_BLINK];
    NODEPTR [DBG$V_PNODE_EVAL] = TRUE;
    TYPEID = .NODEPTR [DBG$L_PNODE_TYPEID];


    ! From this typeid, get the typeid for the object being pointed to.
    ! For pointer variables, use the routine that extracts the typeid
    ! of the pointed-to object.
    ! For file variables, use the routine that extracts the typeid of
    ! objects in the file.
    ! Then obtain the fcode from the typeid.
    !
    IF  .PRIMPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_TPTR
    THEN
        DBG$STA_TYP_TYPEDPTR (.TYPEID, TYPEID)
    ELSE
    	DBG$STA_TYP_FILE (.TYPEID, JUNK, TYPEID);
    FCODE = DBG$STA_TYPEFCODE (.TYPEID);


    ! Append a new sub-node to the Primary Descriptor.
    !
    DBG$BUILD_PRIMARY_SUBNODE (.PRIMPTR, RST$K_DATA, 0, .FCODE, .TYPEID, 0);
    RETURN;
    END;

ROUTINE GET_FIELDREF (TOKEN): NOVALUE =
!
! FUNCTION
!	This routine picks up the position, size, and (optionally) the
!	extension in a field reference (i.e., XX<pos,size,ext>.
!	DBG$EXPRESSION_PARSER is called to parse and evaluate each of
!	these values. The values are stored as integers in the
!	Operator Lexical Token entry.
!
!	This routine assumes that the opening angle bracket has already
!	been found and that the parse pointer points to the start of
!	the first expression in the field reference. When this routine
!	returns, the parse pointer is left at the first character after
!	the closing angle bracket.
!
! INPUTS
!	TOKEN	- a pointer to the Operator Lexical Token entry for
!		  the "<" operator.
!
! OUTPUTS
!	The Lexical Token pointed to by TOKEN is modified to include the
!	offset, size, and sign extension information.
! 

    BEGIN

    MAP
	TOKEN: REF TOKEN$ENTRY;		! Pointer to the Lexical Token Entry
					!      for the field reference operator

    LOCAL
	DECLTYPE: REF DBG$VALDESC,	! Pointer to Value Descriptor
					!      for one of the values
					!      inside the angle brackets
	SAVED_RADIX,			! Temporarily saved expression radix
	VALUE,				! Value of position, size, or sign ext
					!      field
	VALPTR: REF DBG$VALDESC;	! Pointer to position, size, or
					!      extension value descriptor.



    ! Loop through the expressions in this field reference. Each of these
    ! is parsed and evaluated via a call to DBG$EXPRESSION_PARSER. 
    ! This returns a descriptor, and the type converter is then called
    ! to convert the descriptor into an integer value.
    ! The integer value is checked for being in an appropriate range and
    ! then stored in the appropriate own variable.
    !
    INCR I FROM 1 TO 3 DO
	BEGIN


	! Call the expression parser to pick up the next expression in the
	! field reference.  Note that we set the radix to decimal over this
	! call and then restore it.  Also note that the Expression Parser sets
	! TERMINATOR_CODE and TERMINATOR_LENGTH as a side-effect.
	!
	SAVED_RADIX = .EXPRESSION_RADIX;
	EXPRESSION_RADIX = DBG$K_DECIMAL;
	VALPTR = DBG$EXPRESSION_PARSER(FALSE, BIT_SELECT_TERM_TBL);
	EXPRESSION_RADIX = .SAVED_RADIX;


	! Check the terminator code.  If there was no terminator (i.e., the
	! input line just ended), signal an error.  Otherwise we got a comma
	! or closing angle bracket and we increment CHARPTR to get past it.
	!
	IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE THEN SIGNAL(DBG$_MISCLOSUB);
	CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


	! Convert the value descriptor to an integer.
	!
	VALUE = CONVERT_TO_INTEGER (.VALPTR);


	! If we are looking at the "position" field, it can be any value that
	! fits in the PRIM_OFFSET field of the Primary Descriptor.  We do not
	! allow any terminator other than comma in this case.
	!
	IF .I EQL 1
	THEN
	    BEGIN
	    IF .VALUE LSS %X'0000' OR .VALUE GTR %X'7FFF'
	    THEN
		SIGNAL (DBG$_ILLPOSFLD, 1, .VALUE);

	    TOKEN [TOKEN$W_BIT_OFFSET] = .VALUE;
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_GTRTHAN
	    THEN
		SIGNAL(DBG$_INVFLDREF);

	    END;


	! If we are looking at the size field, the value must be in the
	! range 0 to 32 inclusive.  Here we exit the loop normally on a
	! closing angle bracket, defaulting the sign extension to zero.
	!
	IF .I EQL 2
	THEN
	    BEGIN
	    IF .VALUE LSS 0 OR .VALUE GTR 32
	    THEN
		SIGNAL (DBG$_ILLSIZFLD, 1, .VALUE);

	    TOKEN [TOKEN$W_BIT_LENGTH] = .VALUE;
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_GTRTHAN THEN EXITLOOP;
	    END;


	! If we are looking at the sign extension field then the value
	! must be either 0 or 1.  We also insist that the terminator must
	! be the closing angle bracket in this case.
	!
	IF .I EQL 3
	THEN
	    BEGIN
	    IF .VALUE NEQ 0 AND .VALUE NEQ 1 
	    THEN
		SIGNAL (DBG$_ILLSIGEXT, 1, .VALUE);

	    TOKEN [TOKEN$V_SGNEXT] = .VALUE;
	    IF .TERMINATOR_CODE NEQ TOKEN$K_TERM_GTRTHAN
	    THEN
		SIGNAL(DBG$_INVFLDREF);

	    EXITLOOP;
	    END;

	END;				! End of INCR loop


    ! All done. Return to the caller.
    !
    RETURN;
    END;

ROUTINE GET_RECORD_COMPONENT(PRIMPTR, COMPNAME): NOVALUE =
!
! FUNCTION
!	This routine is called during the parsing of Primary Symbols to do
!	record component selection.  It accepts as input a Primary Descriptor
!	for a record and the name of a record component to be selected from
!	that record.  It then checks that the Primary Descriptor is indeed
!	for a record (otherwise component selection is not allowed and an
!	error is signalled).  It then looks up the component name in the
!	RST and gets the SYMID for the specified component of the specified
!	record.  If no such component exists for this record, an error is
!	signalled.  Finally, this component SYMID is converted to a record
!	component index which is stored in the Record Sub-Node in the Primary
!	Descriptor and another Sub-Node is appended for the record component
!	itself.  The output of the routine is thus the side-effect of modi-
!	fying the input Primary Descriptor.
!
! INPUTS
!	PRIMPTR	- A pointer to the Primary Descriptor for the record on which
!		  component selection is to be done.
!
!	COMPNAME - A pointer to the name of the record component to be
!		  selected.  The name must be in Counted ASCII format.
!
! OUTPUTS
!	The PRIMPTR Primary Descriptor is modified by filling in the record
!		  component index for the selected component and by appending
!		  another Primary Descriptor Sub-Node for the component.  The
!		  PRIMPTR pointer itself is not modified, however.
!

    BEGIN

    MAP
	PRIMPTR: REF DBG$PRIMARY;	! Pointer to Primary Descriptor

    LOCAL
    	COMP_LIST: REF VECTOR[],	! List of potential
					!      component symids
    	COMP_LIST_SIZE,			! Length of COMP_LIST
	COMPSYMID: REF RST$ENTRY,	! SYMID for current record component
    	EXACT_MATCH,			! Flag saying we've found the record component
	FCODE,				! The FCODE of the record component
	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to Record Sub-Node in the
					!      Primary Descriptor
	STATUS,				! Status returned by GET_RECORD_VARIANT
	SYMID: REF RST$ENTRY,		! The SYMID of the record component
	TYPCOMPLST: REF VECTOR[,LONG],	! Pointer to list of record component
					!      SYMIDs in record Type RST Entry
	TYPEID: REF RST$ENTRY,		! The Type ID of the record record type
					!      or of the record component
	VARPTR: REF RST$VAR_ENTRY,	! Pointer to current RST Variant Entry
	VARSETPTR: REF RST$ENTRY;	! Pointer to Variant Set RST Entry

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;


    ! Check that the Primary Descriptor is for a record--otherwise record
    ! component selection is not allowed.
    !
    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    IF .ENFORCE_RECORD
    THEN
    	BEGIN


    	! For ADA, the pointer dereference is implicit. That is, if
        ! PTR is a pointer then PTR.C is equivalent to PASCAL's
    	! PTR^.C
    	!
    	IF .DBG$GB_LANGUAGE EQL DBG$K_ADA
    	THEN
    	    BEGIN

    	    ! First check for the special case ".ALL", which
    	    ! means pointer dereference.
    	    !
    	    IF CH$EQL(4, .COMPNAME, 
    		      4, UPLIT BYTE (3, 'A', 'L', 'L'))
    	    THEN
    		BEGIN
    		GET_DEREFERENCE(.PRIMPTR);
    		RETURN;
    		END;

    	    ! Now do implicit dereference of the pointer.
    	    !
    	    WHILE .PRIMPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_TPTR DO
    		GET_DEREFERENCE(.PRIMPTR);
            NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    	    END;

        IF .PRIMPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_RECORD
        THEN
	    SIGNAL(DBG$_NOTRECORD, 1, .COMPNAME);

        IF .NODEPTR[DBG$B_PNODE_FCODE] NEQ RST$K_TYPE_RECORD
        THEN
	    $DBG_ERROR('DBGPARSER\GET_RECORD_COMPONENT 10');
    	END


    ! For languages which allow non-records to be component-selected
    ! (i.e., language C), we do not do the above check. In fact,
    ! we explicitly change the FCODE to say "record" so that
    ! the Primary is processed as a record by routines in DBGVALUES
    ! and in DBGPRINT.
    !
    ELSE
    	NODEPTR[DBG$B_PNODE_FCODE] = RST$K_TYPE_RECORD;


    ! Search the RST Hash Table for all record components of this name.
    ! If we find one which belongs to the given record, then light the
    ! EXACT_MATCH flag and exit the loop. If we find one but it belongs
    ! to the wrong record, we save its SYMID anyway - some languages
    ! allow this. If we find more than one but they all belong to the 
    ! wrong record, then light DUPLICATE_FLAG - this will be an error.
    !
    TYPEID = .NODEPTR[DBG$L_PNODE_TYPEID];
    SYMID = 0;
    EXACT_MATCH = FALSE;
    COMP_LIST_SIZE = 10;
    COMP_LIST = DBG$GET_TEMPMEM(.COMP_LIST_SIZE);
    COMP_LIST[0] = 0;
    DBG$HASH_FIND_SETUP(.COMPNAME);
    WHILE TRUE DO
        BEGIN
    	SYMID = DBG$HASH_FIND(.COMPNAME);
	IF .SYMID EQL 0 THEN EXITLOOP;
	IF .SYMID[RST$B_KIND] EQL RST$K_TYPCOMP
	THEN
    	    BEGIN
    	    IF .SYMID[RST$L_UPSCOPEPTR] EQL .TYPEID
	    THEN
	        BEGIN


    		! This is the case where we find a component with the right
    		! name belonging to the right record.
    		!
	        EXACT_MATCH = TRUE;
	        EXITLOOP;
	        END

	    ELSE
    		BEGIN
    		COMP_LIST[0] = .COMP_LIST[0] + 1;

    		! If we overflow the component list then expand it.
    		!
    		IF .COMP_LIST[0] GEQ .COMP_LIST_SIZE
    		THEN
    		    BEGIN
    		    LOCAL
    			SAVE_COMP_LIST;
    		    SAVE_COMP_LIST = .COMP_LIST;
    		    COMP_LIST = DBG$GET_TEMPMEM(.COMP_LIST_SIZE+10);
    		    CH$MOVE(4*.COMP_LIST_SIZE, .SAVE_COMP_LIST, .COMP_LIST);
    		    COMP_LIST_SIZE = .COMP_LIST_SIZE + 10;
    		    END;
    		COMP_LIST[.COMP_LIST[0]] = .SYMID;
    		END;
    	    END;
	END;
    

    ! Signal errors for the cases where a record component was not found,
    ! or where the reference is ambiguous.
    !
    IF NOT .EXACT_MATCH
    THEN
    	IF .ENFORCE_RECORD AND NOT .INCOMPLETE_QUAL
    	THEN

    	    ! We did not find a component in the right record, and this 
    	    ! language is strict about membership checking. So signal
    	    ! an error.
    	    !
    	    SIGNAL(DBG$_NOFIELD, 1, .COMPNAME)

    	ELSE
    	    IF .COMP_LIST[0] EQL 0
    	    THEN


    		! We did not find any components at all. Signal an error.
    		!
    	        SIGNAL(DBG$_NOFIELD, 1, .COMPNAME)

    	    ELSE


    		! Call a routine which attempts to resolve amiguities.
    		! If it fails, it will return false and we signal an
    		! error saying that the record reference was ambiguous.
    		!
    		IF NOT RESOLVE_COMPONENT(.TYPEID, .COMP_LIST, SYMID, 
    					 .PRIMPTR, .COMPNAME)
    		THEN
    		    SIGNAL(DBG$_AMBFIELD, 1, .COMPNAME);


    ! Set the EVAL bit in the Record Sub-Node to indicate that a record com-
    ! ponent has actually been selected.
    !
    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    NODEPTR[DBG$V_PNODE_EVAL] = TRUE;


    ! We have found a Type Component SYMID for a component of the current
    ! record data type.  Now convert that SYMID to a record component index
    ! into the component vector for the record type.  We do this by searching
    ! the component list in the record type's Type RST Entry.
    !
    TYPCOMPLST = TYPEID[RST$A_TYPCOMPLST];
    INCR I FROM 0 TO .TYPEID[RST$L_TYPCOMPCNT] - 1 DO
	BEGIN
	COMPSYMID = .TYPCOMPLST[.I];


	! If this component is the one we seek, set its index into the Record
	! Sub-Node and leave the loop.
	!
	IF .SYMID EQL .COMPSYMID
	THEN
	    BEGIN
	    NODEPTR[DBG$W_PNREC_INDEX] = .I + 1;
	    EXITLOOP;
	    END;


	! If this record component is a Variant Set, see if the desired
	! component is part of one of the variants in this Variant Set.
	!
	IF .COMPSYMID[RST$B_KIND] EQL RST$K_VARIANT
	THEN
	    BEGIN
	    VARSTK_INDEX = 0;
	    STATUS = GET_RECORD_VARIANT(.COMPSYMID, .SYMID);
	    IF .STATUS
	    THEN
		BEGIN


		! We found the record component in the current Variant Set.
		! Set the index of the Variant Set in the Record Sub-Node.
		! Then build all necessary Primary Descriptor Variant Sub-
		! Nodes, one for each level of variant nesting.
		!
		NODEPTR[DBG$W_PNREC_INDEX] = .I + 1;
		INCR J FROM 0 TO .VARSTK_INDEX - 1 DO
		    BEGIN
		    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, RST$K_VARIANT,
						0, RST$K_TYPE_VARIANT, 0, 0);
		    VARSETPTR = .VARSTACK1[.J];
		    VARPTR = .VARSTACK2[.J];
		    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
		    NODEPTR[DBG$V_PNODE_EVAL]    = TRUE;
		    NODEPTR[DBG$L_PNVAR_TAGID]   = .VARSETPTR[RST$L_VARTAGPTR];
		    NODEPTR[DBG$W_PNVAR_INDEX]   = .VARSTACK3[.J];
		    NODEPTR[DBG$W_PNVAR_NCOMPS]  = .VARPTR[RST$L_VAR_COMPCNT];
		    NODEPTR[DBG$L_PNVAR_COMPLST] =  VARPTR[RST$A_VAR_COMPLST];
		    NODEPTR[DBG$L_PNVAR_DSTPTR]  = .VARPTR[RST$L_VAR_DSTPTR];
		    END;


		! The Variant Sub-Nodes have successfully been constructed.
		! Now exit the search of the record component list so that
		! we can build the Sub-Node for the component actually found.
		!
		EXITLOOP;
		END;

	    END;			! End of variant code

	END;				! End of loop over record components


    ! Finally append another Primary Descriptor Sub-Node for the selected
    ! record component.  Then return.
    !
    DBG$STA_SYMTYPE(.SYMID, FCODE, TYPEID);
    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR,
				RST$K_TYPCOMP, .SYMID, .FCODE, .TYPEID, 0);
    RETURN;

    END;

ROUTINE GET_RECORD_VARIANT(VARSETPTR, SYMID) =
!
! FUNCTION
!	This routine looks for a record component with a known SYMID among all
!	the variants in a specified Variant Set.  It returns TRUE if the compo-
!	nent is found in that Variant Set, and as a side-effect, it also builds
!	a "Variant Stack" which specifies which sequence of variants and Vari-
!	ant Sets contain the component.  This routine calls itself recursively
!	to search variants within variants; the "Variant Stack" records the
!	path taken through the tree of variants to reach the desired component.
!	This stack is then used by GET_RECORD_COMPONENT to build the Primary
!	Descriptor Variant Sub-Nodes needed to describe that path.
!
! INPUTS
!	VARSETPTR - Pointer to the Variant Set to be searched for the SYMID
!		  record component.
!
!	SYMID	- The SYMID (RST Entry address) of the record component to
!		  search for among the variants of the current Variant Set.
!		  (This SYMID has been found by looking up the record compo-
!		  nent by its name.)
!
! OUTPUTS
!	If the SYMID record component is found in any of the VARSETPTR variants,
!		  this routine returns TRUE as its value.  If the SYMID compo-
!		  nent is not found, it returns FALSE.  If TRUE is returned,
!		  the Variant Stack (in OWN storage) contains the list of Vari-
!		  ant Sets and variants which contain the SYMID component.
!

    BEGIN

    MAP
	VARSETPTR: REF RST$ENTRY;	! Pointer to Variant Set RST Entry

    LOCAL
	COMPLST: REF VECTOR[,LONG],	! Pointer to vector of component RST
					!      pointers in RST Variant Entry
	COMPPTR: REF RST$ENTRY,		! Pointer to current variant component's
					!      RST entry
	VARPTR: REF RST$VAR_ENTRY,	! Pointer to current RST Variant Entry
	VARSETTBL: REF VECTOR[,LONG],	! Pointer to vector of variant in the
					!      Variant Set RST Entry
	STATUS;				! Status returned by recursive call



    ! Push the address of the current Variant Set RST Entry on the Variant
    ! Stack maintained by this routine and GET_RECORD_COMPONENT.  This is
    ! how we keep track of nested Variant Sets in the record.
    !
    IF .VARSTK_INDEX GEQ VARSTK_SIZE THEN SIGNAL(DBG$_VARNESDEP);
    VARSTK_INDEX = .VARSTK_INDEX + 1;
    VARSTACK1[.VARSTK_INDEX - 1] = .VARSETPTR;


    ! Loop through all the variants in this Variant Set.  For each variant in
    ! the set, search its components until we find the SYMID component, i.e
    ! the record component we are looking for.
    !
    VARSETTBL = VARSETPTR[RST$A_VARSETTBL];
    INCR I FROM 0 TO .VARSETPTR[RST$L_VARSETCNT] - 1 DO
	BEGIN
	VARPTR = .VARSETTBL[.I];
	VARSTACK2[.VARSTK_INDEX - 1] = .VARPTR;


	! Loop over the record components in this particular variant.  If the
	! SYMID component is found, we return TRUE and leave the Variant Stack
	! with its current contents.  If we find another Variant Set component
	! within this variant (i.e., nested variants within the record), this
	! routine calls itself recursively to look for the SYMID component in
	! that nested variant.  If it is found there, TRUE is returned.
	!
	COMPLST = VARPTR[RST$A_VAR_COMPLST];
	INCR J FROM 0 TO .VARPTR[RST$L_VAR_COMPCNT] - 1 DO
	    BEGIN
	    COMPPTR = .COMPLST[.J];
	    VARSTACK3[.VARSTK_INDEX - 1] = .J + 1;
	    IF .COMPPTR EQL .SYMID THEN RETURN TRUE;
	    IF .COMPPTR[RST$B_KIND] EQL RST$K_VARIANT
	    THEN
		BEGIN
		STATUS = GET_RECORD_VARIANT(.COMPPTR, .SYMID);
		IF .STATUS THEN RETURN TRUE;
		END;

	    END;			! End of loop over variant components

	END;				! End of loop over Variant Set


    ! We did not find the SYMID component anywhere among the variants in this
    ! Variant Set.  We thus pop the Variant Stack and return FALSE.
    !
    VARSTK_INDEX = .VARSTK_INDEX - 1;
    RETURN FALSE;

    END;

ROUTINE GET_SET_CONSTANT =
!
! FUNCTION
!	This routine picks up set constants.  It calls DBG$EXPRESSION_PARSER 
!	to parse and evaluate each set constants expression.  It also checks 
!	the data type of each set constants and converts it to the appropriate 
!	data type of the first set constant as necessary.  
!
!	This routine assumes that the opening set parenthesis has
!	already been found and that the parse pointer points to the start
!	of the first set constant expression.  When this routine returns,
!	the parse pointer is left pointing at the first character after
!	the closing set parenthesis.
!
! INPUTS
!	None.
!
! OUTPUTS
!	Pointer to set constant value descriptor.
!

    BEGIN

    LOCAL
	CREATE,				! Flag set to true to create set
					!      constant value descriptor
	LOW_RANGE_VAL,			! Low value of a subscript range
	SAVED_RADIX,			! Temporarily saved expression radix
	SETVAL: REF BITVECTOR[],	! A vector of 256 bits
	SETVALPTR: REF DBG$VALDESC,	! Pointer to Value Descriptor for
					!      declared subscript data type
	THIS_SUBSCR_IS_RANGE,		! Flag set if the current subscript is
					!      given as a subscript range
	TYPEID: REF RST$ENTRY,		! Pointer to RST entry
	VALADDR: REF VECTOR[,LONG],	! Pointer to integer subscript value
	VALPTR: REF DBG$VALDESC;	! Pointer to subscript Value Descriptor



    ! Check for Empty Set [].  Create a value descriptor for it, mark 'FFFF'
    ! in class and dtype fields to indicate this is [], so DBG$EVAL_LANG_OPERATOR
    ! can play with it.
    !
    IF .CHARPTR[0] EQL ']'
    THEN
    	BEGIN
	SETVALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 8*4);
	SETVALPTR[DBG$B_DHDR_LANG] = %X'FF';
	SETVALPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
	SETVALPTR[DBG$B_DHDR_FCODE] = RST$K_TYPE_SET;
	SETVALPTR[DBG$L_VALUE_POINTER] = SETVALPTR[DBG$A_VALUE_ADDRESS];
    	SETVALPTR[DBG$B_VALUE_CLASS] = %X'FF';
    	SETVALPTR[DBG$B_VALUE_DTYPE] = %X'FF';
    	SETVALPTR[DBG$W_VALUE_LENGTH] = 32;
    	CHARPTR = .CHARPTR + 1;
    	RETURN .SETVALPTR;
    	END;


    ! Loop through the set constant expressions for this set constant.  Each
    ! set constant is parsed, evaluated, and converted to the appropriate type
    ! of the first set constant (with the type being checked in the process).  
    ! Note that TERMINATOR_CODE is set within the loop as a side-effect of the 
    ! call on DBG$EXPRESSION_PARSER.
    !
    CREATE = TRUE;
    THIS_SUBSCR_IS_RANGE = FALSE;
    TERMINATOR_CODE = TOKEN$K_TERM_COMMA;
    WHILE .TERMINATOR_CODE NEQ TOKEN$K_TERM_CLOSE DO
	BEGIN


	! Call the expression parser to pick up the next set constant expression
	! and its value.  Note that we set the radix to decimal over this call
	! and then restore it.  Also note that the Expression Parser sets
	! TERMINATOR_CODE and TERMINATOR_LENGTH as a side-effect.
	!
	SAVED_RADIX = .EXPRESSION_RADIX;
	EXPRESSION_RADIX = DBG$K_DECIMAL;
	VALPTR = DBG$EXPRESSION_PARSER (FALSE, SET_CONSTANT_TERM_TBL);
	EXPRESSION_RADIX = .SAVED_RADIX;


	! Check the terminator code.  If there was no terminator (the input
	! line just ended), signal an error.  Otherwise we got a comma or clos-
	! ing subscript parenthesis and we increment CHARPTR to get past it.
	!
	IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE THEN SIGNAL(DBG$_MISCLOSUB);
	CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


	! Create a set constant value descriptor.  Its type is the type of
	! the first set constant data type.
	!
	IF .CREATE
	THEN
	    BEGIN
	    SETVALPTR = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 8*4);
	    SETVALPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
	    SETVALPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
	    SETVALPTR[DBG$B_DHDR_FCODE] = RST$K_TYPE_SET;
	    SETVALPTR[DBG$W_VALUE_LENGTH] = 32;
	    SETVALPTR[DBG$L_VALUE_POINTER] = SETVALPTR[DBG$A_VALUE_ADDRESS];
	    SETVAL = .SETVALPTR[DBG$L_VALUE_POINTER];
	    SELECTONE .VALPTR[DBG$B_DHDR_FCODE] OF
		SET
		[RST$K_TYPE_ATOMIC, RST$K_TYPE_DESCR]:
		    BEGIN
		    SETVALPTR[DBG$L_DHDR_TYPEID] = DBG$TYPEID_FOR_SET(
			.VALPTR[DBG$B_VALUE_DTYPE], RST$K_TYPE_SET, 256, TRUE);
		    END;

		[RST$K_TYPE_ENUM]:
		    BEGIN
		    TYPEID = .VALPTR[DBG$L_DHDR_TYPEID];
		    SETVALPTR[DBG$L_DHDR_TYPEID] = DBG$TYPEID_FOR_SET(
			.TYPEID[RST$L_DSTPTR], RST$K_TYPE_SET, 256);
		    END;

		[OTHERWISE]:
		    SIGNAL(DBG$_ILLTYPE);

		TES;

	    CREATE = FALSE;
	    END;


	! Check that the type of the set item is consistent with the
	! type of the set as a whole.
	!
	IF NOT DBG$PERFORM_TYPEID_CHECK (ORT$K_TYPEID_SET_SET,
		.VALPTR, .SETVALPTR)
	THEN
	    SIGNAL (DBG$_ILLSETCON);

	VALADDR = .VALPTR[DBG$L_VALUE_POINTER];


	! If the terminator at the end of this set constant expression was a dot
	! we have a subrange (for example, "(1..5, 8)").  We thus set
	! the subrange-range flag and save the low value of the range, i.e.
	! the value we just picked up.  
	!
	IF .TERMINATOR_CODE EQL TOKEN$K_TERM_DOT
	THEN
	    BEGIN
	    IF .THIS_SUBSCR_IS_RANGE THEN SIGNAL(DBG$_INVRANSPEC);
	    THIS_SUBSCR_IS_RANGE = TRUE;
	    LOW_RANGE_VAL = .VALADDR[0];
	    END


	! The terminator was not a dot, so we now have the full set constant
	! specification.  
	!
	ELSE
	    BEGIN


	    ! If this set constant is specified as a subrange, check that
	    ! the first value in the range is not greater than the second.
	    ! Also clear the subscript-is-range flag for the next subscript.
	    !
	    IF .THIS_SUBSCR_IS_RANGE
	    THEN
		BEGIN
		IF .LOW_RANGE_VAL GTR .VALADDR[0] THEN SIGNAL(DBG$_INVRANSPEC);
		THIS_SUBSCR_IS_RANGE = FALSE;
		END


	    ! Otherwise, set the low range value to be the set constant value.
	    !
	    ELSE
		LOW_RANGE_VAL = .VALADDR[0];

	    END;


	! Set the set value.
	!
	IF .LOW_RANGE_VAL LSS 0 OR .LOW_RANGE_VAL GTR 256
	THEN
	    SIGNAL(DBG$_BITRANGE);

	IF .VALADDR[0] LSS 0 OR .VALADDR[0] GTR 256
	THEN
	    SIGNAL(DBG$_BITRANGE);

	INCR I FROM .LOW_RANGE_VAL TO .VALADDR[0] DO
	    SETVAL[.I] = TRUE;
	END;				! End of WHILE loop over set constants


    ! We have picked up all the set constants within this set parentheses.  
    ! Set Constant Value Descriptor is created.
    !
    RETURN .SETVALPTR;

    END;

ROUTINE GET_SUBSCRIPTS(PRIMPTR): NOVALUE =
!
! FUNCTION
!	This routine picks up subscript values in an array reference.  It
!	calls DBG$EXPRESSION_PARSER to parse and evaluate each subscript
!	expression.  It also checks the data type of each subscript value
!	and converts it to the appropriate data type as necessary.  The
!	ultimate subscript values are stored as integers in the Primary
!	Descriptor Array Sub-Node for the array being subscripted.  A new
!	Sub-Node for the array element type is then appended so that the
!	Primary Descriptor becomes a descriptor for the array element
!	selected by the subscripting.
!
!	This routine also handles subscript ranges, such as ARR(1:5,3:10).
!	It does so by modifying the subscript lower and upper bounds in
!	the Array Sub-Node subscript vector to in effect define a new
!	array, namely the array "slice" defined by the subscript ranges.
!	In this case no Sub-Node for the array element is appended since
!	the Primary Descriptor still defines an array.
!
!	This routine assumes that the opening subscript parenthesis has
!	already been found and that the parse pointer points to the start
!	of the first subscript expression.  When this routine returns,
!	the parse pointer is left pointing at the first character after
!	the closing subscript parenthesis.
!
! INPUTS
!	PRIMPTR	- A pointer to the Primary Descriptor for an array about
!		  to be subscripted.
!
! OUTPUTS
!	The PRIMPTR Primary Descriptor is changed to include the subscript
!		  information (the actual subscript values) and a new Sub-
!		  Node for the selected array element.  PRIMPTR itself is
!		  not changed, however.
!

    BEGIN

    MAP
	PRIMPTR: REF DBG$PRIMARY;	! Pointer to array Primary Descriptor

    LOCAL
	BITSIZE,			! Bit size of subscript value data type
    	CHECK_VAL,
	DECLTYPE: REF DBG$VALDESC,	! Pointer to Value Descriptor for
					!      declared subscript data type
    	DESCR: DBG$STG_DESC,		! String descriptor
	DSCADDR: REF DBG$STG_DESC,	! Pointer to a string descriptor
	FCODE,				! Data type FCODE for array element type
    	LA_PTR: REF VECTOR[,BYTE],	! Lookahead pointer into input
	LOW_RANGE_VAL,			! Low value of a subscript range
	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to Prim Descr Array Sub-Node
	SAVED_RADIX,			! Temporarily saved expression radix
	SUBSCR_COUNT,			! Actual subscript count in input line
	SUBVECTOR:			! Pointer to subscript block-vector
		REF DBG$PRIM_NODE_SUBS,	!      in Primary Descr Array Sub-Node
	THIS_SUBSCR_IS_RANGE,		! Flag set if the current subscript is
					!      given as a subscript range
    	TOKEN,				! Lexical Token
	TYPECODE,			! VAX standard type code for atomic type
    	TYPEID: REF RST$ENTRY,		! Holds a typeid
	VALADDR: REF VECTOR[,LONG],	! Pointer to integer subscript value
	VALPTR: REF DBG$VALDESC;	! Pointer to subscript Value Descriptor

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;


    ! Check that the Primary Descriptor is really a Primary Descriptor!
    !
    IF .PRIMPTR[DBG$B_DHDR_TYPE] NEQ DBG$K_PRIMARY_DESC
    THEN
	SIGNAL(DBG$_NOTARRAY);


    ! Check that the Primary Descriptor is for an array--otherwise subscripting
    ! is not allowed.
    !
    IF .PRIMPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_ARRAY
    THEN
	BEGIN
    
	! Check for the possibility of a substring reference.
	! E.g., in FORTRAN, if a variable is declared CHARACTER*n
	! we see it in the DST as an atomic item of type T.
	! We want to allow X(i:j) in this case.
	!
    	IF .PRIMPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC
    	THEN
    	    BEGIN
    	    DBG$STA_TYP_ATOMIC (.PRIMPTR[DBG$L_DHDR_TYPEID], TYPECODE, BITSIZE);


    	    ! Special case for BASIC.  In this case, each element of an
    	    ! array is a VMS descriptor.
    	    !
    	    IF .TYPECODE EQL DSC$K_DTYPE_DSC
    	    THEN
    		BEGIN
    		DBG$PRIM_TO_VAL (.PRIMPTR, DBG$K_VALUE_DESC, VALPTR);
    		DSCADDR = VALPTR[DBG$A_VALUE_VMSDESC];
	        IF .DSCADDR[DSC$B_DTYPE] EQL DSC$K_DTYPE_T
	        THEN
	            BEGIN
	            GET_SUBSTRING (.PRIMPTR, .DSCADDR);
	            RETURN;
	            END;
    		END;

    	    IF .TYPECODE EQL DSC$K_DTYPE_T
    	    THEN
    		BEGIN
    		DESCR[DSC$B_CLASS] = DSC$K_CLASS_S;
    		DESCR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    		DESCR[DSC$W_LENGTH] = .BITSIZE/8;
    		GET_SUBSTRING (.PRIMPTR, DESCR);
    		RETURN;
    		END;
    	    END;

	IF .PRIMPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR
	THEN
	    BEGIN
	    DBG$STA_TYP_DESCR (.PRIMPTR [DBG$L_DHDR_TYPEID], DSCADDR);
	    IF .DSCADDR[DSC$B_DTYPE] EQL DSC$K_DTYPE_T
	    THEN
	        BEGIN
	        GET_SUBSTRING (.PRIMPTR, .DSCADDR);
	        RETURN;
	        END;
    	    END;


    	! For typed pointers there are two special cases:
    	! For language C, subscripting of pointers is allowed; e.g.,
    	! PTR[n]  is equivalent to  *(PTR+n)
    	! For ADA, the pointer dereference is implicit; thus if PTR
    	! is a pointer then PTR(I) in ADA is equivalent to PTR^[I]
    	! in PASCAL.
    	!
    	IF .PRIMPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_TPTR
    	THEN
    	    BEGIN
    	    CASE .DBG$GB_LANGUAGE FROM DBG$K_MIN_LANGUAGE TO DBG$K_MAX_LANGUAGE OF
    	   	SET

    		! For language C, subscripting of pointers is allowed; e.g.,
    		! PTR[n]  is equivalent to  *(PTR+n)
    		!
    		[DBG$K_C]:
    		    BEGIN
    		    LOCAL
    		        ADDRESS,		! Address of array (value of pointer)
    		        DUMMY,			! Dummy output parameter
    		        VALPTR: REF DBG$VALDESC;! Pointer to a Value Descriptor


    		    BUILTIN
    		    	REMQUE;


    		    ! Compute the value of the pointer that is represented
    		    ! by the current primary.
    		    !
    		    DBG$PRIM_TO_VAL (.PRIMPTR, DBG$K_VALUE_DESC, VALPTR);
    		    ADDRESS = .VALPTR[DBG$L_VALUE_VALUE0];


    		    ! Unlink the existing subnode and build a new one to
    		    ! describe an array.
    		    !
    		    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    		    REMQUE(.NODEPTR, DUMMY);
    		    TYPEID = DBG$TYPEID_FOR_ARRAY(.PRIMPTR[DBG$L_DHDR_TYPEID],
    					          .ADDRESS);
    		    DBG$BUILD_PRIMARY_SUBNODE (.PRIMPTR, RST$K_DATA, 0, 
    					        RST$K_TYPE_ARRAY, .TYPEID, 0);
    		    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    		    NODEPTR[DBG$L_PNODE_RELOC] = .ADDRESS;
    		    END;


    		! For ADA, the pointer dereference is implicit; thus if PTR
    		! is a pointer then PTR(I) in ADA is equivalent to PTR^[I]
    		! in PASCAL.
    		!
    		[DBG$K_ADA]:
    		    BEGIN


    		    ! Dereference the pointer.
    		    !
    		    WHILE .PRIMPTR[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_TPTR DO
    			GET_DEREFERENCE(.PRIMPTR);


    		    ! If the Primary is still not an array then
    		    ! signal an error.
    		    !
    		    IF .PRIMPTR[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_ARRAY
    		    THEN
    			SIGNAL(DBG$_NOTARRAY);
    		    END;


    		! For other languages, we cannot subscript typed pointers.
    		!
    		[INRANGE]:
    		    SIGNAL(DBG$_NOTARRAY);


    		! We do not expect any other language codes.
    		!
    		[OUTRANGE]:
    		    $DBG_ERROR('DBGPARSER\GET_SUBSCRIPTS 5');

    	  	TES;
    	    END
    	    

	! Else the variable is neither a string nor a typed pointer
    	! nor an array so subscripting is not allowed.
	!
    	ELSE
    	    SIGNAL(DBG$_NOTARRAY);
	END;


    ! Set up pointers to the Primary Descriptor Array Sub-Node and to the
    ! subscript vector within that node.
    !
    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    SUBVECTOR = NODEPTR[DBG$A_PNARR_SVECTOR];
    IF .NODEPTR[DBG$B_PNODE_FCODE] NEQ RST$K_TYPE_ARRAY
    THEN
	$DBG_ERROR('DBGPARSER\GET_SUBSCRIPTS 10');


    ! Loop through the subscript expressions for this array reference.  Each
    ! subscript is parsed, evaluated, and converted to the appropriate type
    ! (with the type being checked in the process).  It is then checked for
    ! being in range and its integer value is stored in the Array Sub-Node's
    ! subscript block-vector.  Note that TERMINATOR_CODE is set within the
    ! loop as a side-effect of the call on DBG$EXPRESSION_PARSER.
    !
    THIS_SUBSCR_IS_RANGE = FALSE;
    SUBSCR_COUNT = .NODEPTR[DBG$B_PNARR_SUBCNT];
    TERMINATOR_CODE = TOKEN$K_TERM_COMMA;
    WHILE .TERMINATOR_CODE NEQ TOKEN$K_TERM_CLOSE DO
	BEGIN


	! Check that the actual subscript count does not exceed the dimension
	! count for the array.
	!
	IF .SUBSCR_COUNT GEQ .NODEPTR[DBG$B_PNARR_DIMCNT]
	THEN
	    SIGNAL(DBG$_TOOMANSUB, 1, .NODEPTR[DBG$B_PNARR_DIMCNT]);


    	! Look for the asterisk. X(*) is the same as X(lower:upper).
    	! If we find the asterisk then advance the character pointer beyond
    	! the asterisk and also increment the subscript count.
    	!
    	LA_PTR = .CHARPTR;
    	WHILE .LA_PTR[0] EQL ' ' DO LA_PTR = .LA_PTR + 1;
    	IF .LA_PTR[0] EQL '*'
    	THEN
    	    BEGIN
    	    CHARPTR = .LA_PTR + 1;


    	    ! Call the Lexical Scanner to take us past the ',' or 
    	    ! or ']' or ')'. This will set TERMINATOR_CODE to the
    	    ! terminator that is seen. If we do not see a terminator
    	    ! then signal a syntax error. Also signal an error if
    	    ! ':' was the terminator.
    	    !
    	    TOKEN = DBG$LEXICAL_SCANNER (FALSE, FALSE,
    			.SUBSCRIPT_TERM_TBL, 0);
    	    IF .TOKEN NEQ TERMINATOR_TOKEN
    	    THEN
    		BEGIN
    		LOCAL
    		    ASCIC_STRING: VECTOR[2,BYTE];
    		ASCIC_STRING[0] = 1;
    		ASCIC_STRING[1] = .CHARPTR[0];
    		SIGNAL(DBG$_SYNERREXPR, 1, ASCIC_STRING);
    		END;	
    	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
    	    THEN    		
    		SIGNAL (DBG$_INVRANSPEC);
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE 
    	    THEN 
    		SIGNAL(DBG$_MISCLOSUB);
	    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


    	    ! Turn this reference into a range.
    	    ! If it was not already a range, then turn all previous 
    	    ! subscripts into ranges.
    	    !
	    IF NOT .NODEPTR[DBG$V_PNARR_RANGE]
	    THEN
		BEGIN
		NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
		INCR I FROM 0 TO .SUBSCR_COUNT - 1 DO
		    BEGIN
		    SUBVECTOR[.I, DBG$L_PNSUB_LBOUND] =
					.SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
		    SUBVECTOR[.I, DBG$L_PNSUB_UBOUND] =
					.SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
		    END;

		END;
    	    SUBSCR_COUNT = .SUBSCR_COUNT + 1;
    	    NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
    	    END

    	ELSE
    	    BEGIN


	    ! Call the expression parser to pick up the next subscript expression
	    ! and its value.  Note that we set the radix to decimal over this call
	    ! and then restore it.  Also note that the Expression Parser sets
	    ! TERMINATOR_CODE and TERMINATOR_LENGTH as a side-effect.
	    !
	    SAVED_RADIX = .EXPRESSION_RADIX;
	    EXPRESSION_RADIX = DBG$K_DECIMAL;
	    VALPTR = DBG$EXPRESSION_PARSER (FALSE, .SUBSCRIPT_TERM_TBL);
	    EXPRESSION_RADIX = .SAVED_RADIX;


	    ! Check the terminator code.  If there was no terminator (the input
	    ! line just ended), signal an error.  Otherwise we got a comma or clos-
	    ! ing subscript parenthesis and we increment CHARPTR to get past it.
	    !
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE THEN SIGNAL(DBG$_MISCLOSUB);
	    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


    	    ! We now need to convert the subscript to one of the appropriate
    	    ! dtype. We need to set up a target descriptor for the conversion
    	    ! routine. We allocate a skeleton descriptor and fill in some of 
    	    ! the fields.
	    !
	    DECLTYPE = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
	    DECLTYPE[DBG$B_DHDR_KIND] = RST$K_DATA;
	    TYPEID = .SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_TYPEID];
	    DECLTYPE[DBG$L_DHDR_TYPEID] = .TYPEID;
	    DECLTYPE[DBG$L_VALUE_POINTER] = DECLTYPE[DBG$A_VALUE_ADDRESS];


    	    ! We now must fill in the FCODE, CLASS, DTYPE, and LENGTH fields
    	    ! of the target descriptor. To do this, we need to look at the
    	    ! typeid.
    	    !
	    IF .TYPEID EQL 0
	    THEN
    	        BEGIN


    	        ! No typeid available - assume longword integer.
    	        !
	        DECLTYPE[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
	        DECLTYPE[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
	        DECLTYPE[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
	        DECLTYPE[DBG$W_VALUE_LENGTH] = 4;
    	        END

	    ELSE
    	        BEGIN


    	        ! Typeid is available - determine FCODE from it.
    	        !
    		DBG$STA_SYMSIZE(.TYPEID, BITSIZE);
    		FCODE = .TYPEID[RST$B_FCODE];
    	        DECLTYPE[DBG$B_DHDR_FCODE] = .FCODE;
	        IF .FCODE EQL RST$K_TYPE_ATOMIC
	        THEN
	            BEGIN


    		    ! Atomic data - determine class, dtype, and length from DST.
    		    !
	            DBG$STA_TYP_ATOMIC(.TYPEID, TYPECODE, BITSIZE);
    		    IF .TYPECODE EQL DST$K_BOOL
    		    THEN
    		        TYPECODE = DSC$K_DTYPE_TF;
    		    DECLTYPE[DBG$B_VALUE_CLASS] = DBG$MAP_DTYPE_CLASS (
    			.TYPECODE, FALSE);
	            DECLTYPE[DBG$B_VALUE_DTYPE] = .TYPECODE;
    		    IF  .TYPECODE NEQ DSC$K_DTYPE_V
    		    AND .TYPECODE NEQ DSC$K_DTYPE_SV
    		    AND .TYPECODE NEQ DSC$K_DTYPE_VU
    		    AND .TYPECODE NEQ DSC$K_DTYPE_SVU
    		    AND .TYPECODE NEQ DSC$K_DTYPE_TF
    		    THEN
	                DECLTYPE[DBG$W_VALUE_LENGTH] = (.BITSIZE+7)/8
    		    ELSE
    		        DECLTYPE[DBG$W_VALUE_LENGTH] = .BITSIZE;
	            END

    	        ELSE IF .FCODE EQL RST$K_TYPE_DESCR
    	        THEN
    		    BEGIN

    		    ! Descriptor data - determine class, dtype, and length from DST.
    		    !
    		    DBG$STA_TYP_DESCR (.TYPEID, DECLTYPE[DBG$A_VALUE_VMSDESC]);
    		    IF .DECLTYPE[DBG$B_VALUE_DTYPE] EQL DST$K_BOOL
    		    THEN
    		        DECLTYPE[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_TF;
    		    END

    	        ELSE
    		    BEGIN

    		    ! Language-specific fcodes. Here we dummy in the dtype field
    		    ! with a special code. Determine class and length information
    		    ! using routines in DBGEVALOP.
    		    !
    		    DECLTYPE[DBG$B_VALUE_CLASS] = 0;
    		    DECLTYPE[DBG$B_VALUE_DTYPE] = 0;
    		    DECLTYPE[DBG$W_VALUE_LENGTH] = (.BITSIZE+7)/8;
    		    END;
    	        END;


    	    ! Finally call the conversion routine. This routine checks that
    	    ! the conversion is legal before doing it.
     	    !
	    VALPTR = DBG$EVAL_LANG_OPERATOR(DBG$GL_CONVERT_TOKEN, .VALPTR, .DECLTYPE);


	    ! Check that the subscript value is within the array bounds and give an
	    ! informational message if not (execution continues after the message).
    	    ! For ADA, we make sure to check enumeration subscripts by their
    	    ! position and not by their value.
	    !
	    VALADDR = .VALPTR[DBG$L_VALUE_POINTER];
    	    IF (.DBG$GB_LANGUAGE EQL DBG$K_ADA) AND
    	       (.TYPEID NEQ 0) AND
    	       (.FCODE EQL RST$K_TYPE_ENUM)
    	    THEN
    		CHECK_VAL = DBG$ENUM_POS(.TYPEID,.VALADDR[0])
    	    ELSE
    		CHECK_VAL = .VALADDR[0];

	    IF (.CHECK_VAL LSS .SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_LBOUND]) OR
	       (.CHECK_VAL GTR .SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_UBOUND])
	    THEN
	        SIGNAL(DBG$_SUBOUTBND, 4, .SUBSCR_COUNT + 1, .CHECK_VAL,
				.SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_LBOUND],
				.SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_UBOUND]);


	    ! If the terminator at the end of this subscript expression was a colon
	    ! we have a subscript range (for example, "ARR(1:5,2)").  We thus set
	    ! the subscript-range flag and save the low value of the range, i.e.
	    ! the value we just picked up.  If this is the first range in the
	    ! subscript list, we also turn all previous subscripts into ranges by
	    ! setting the lower and upper bound for each such subscript to the
	    ! corresponding subscript value.  This in effect defines a new array
	    ! which constitutes a "slice" of the original array.
	    !
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
	    THEN
	        BEGIN
	        IF .THIS_SUBSCR_IS_RANGE THEN SIGNAL(DBG$_INVRANSPEC);
	        THIS_SUBSCR_IS_RANGE = TRUE;
	        LOW_RANGE_VAL = .VALADDR[0];
	        IF NOT .NODEPTR[DBG$V_PNARR_RANGE]
	        THEN
	 	    BEGIN
		    NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
		    INCR I FROM 0 TO .SUBSCR_COUNT - 1 DO
		        BEGIN
		        SUBVECTOR[.I, DBG$L_PNSUB_LBOUND] =
					.SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
		        SUBVECTOR[.I, DBG$L_PNSUB_UBOUND] =
					.SUBVECTOR[.I, DBG$L_PNSUB_SVALUE];
		        END;

		    END;

	         END


	    ! The terminator was not a colon, so we now have the full subscript
	    ! specification.  Fill the subscript value into the Array Sub-Node's
	    ! subscript vector.  Set up the bounds for an array "slice" if this
	    ! or any previous subscript specification in this array reference
	    ! consisted of a subscript range.  Also bump the subscript count.
	    !
	    ELSE
	        BEGIN


	        ! If this subscript is specified as a subscript range, check that
	        ! the first value in the range is not greater than the second.
	        ! Also clear the subscript-is-range flag for the next subscript.
	        !
	        IF .THIS_SUBSCR_IS_RANGE
	        THEN
		    BEGIN
		    IF .LOW_RANGE_VAL GTR .VALADDR[0] THEN SIGNAL(DBG$_INVRANSPEC);
		    THIS_SUBSCR_IS_RANGE = FALSE;
		    END


	        ! Otherwise, set the low range value to be the subscript value.
	        !
	        ELSE
		    LOW_RANGE_VAL = .VALADDR[0];


	        ! If this or any previous subscript in this array reference con-
	        ! tained a range specification (as in ARR(5:10)), then we arrange
	        ! the array's lower and upper bounds to reflect the array "slice"
	        ! the user is requesting.
	        !
	        IF .NODEPTR[DBG$V_PNARR_RANGE]
	        THEN
		    BEGIN
		    SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_LBOUND] = .LOW_RANGE_VAL;
		    SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_UBOUND] = .VALADDR[0];
		    END;


	        ! Finally fill in the subscript value itself (the start of the
	        ! range), increment the subscript count, and loop.
	        !
	        SUBVECTOR[.SUBSCR_COUNT, DBG$L_PNSUB_SVALUE] = .LOW_RANGE_VAL;
	        SUBSCR_COUNT = .SUBSCR_COUNT + 1;
	        END;
    	    END;
	END;				! End of WHILE loop over subscripts


    ! We have picked up all the subscripts within this set of subscript paren-
    ! theses.  Now check that the subscript count is the same as the dimension
    ! count unless the language allows fewer subscripts (as in Pascal where
    ! the array reference X[2,3][4] is valid).  If fewer subscripts are allowed
    ! we return now, leaving the Array Sub-Node at the end of the Primary.
    !
    NODEPTR[DBG$B_PNARR_SUBCNT] = .SUBSCR_COUNT;
    IF .SUBSCR_COUNT NEQ .NODEPTR[DBG$B_PNARR_DIMCNT]
    THEN
	BEGIN
	IF .MULTIPLE_SUBSCR THEN RETURN;
	SIGNAL(DBG$_TOOFEWSUB, 1, .NODEPTR[DBG$B_PNARR_DIMCNT]);
	END;


    ! If any subscript range was specified, we leave the Array Sub-Node at the
    ! end of the Primary even if all subscripts were specified.  In other words,
    ! we still have an array, namely the specified "array slice".
    !
    IF .NODEPTR[DBG$V_PNARR_RANGE] THEN RETURN;


    ! All the subscripts are specified.  Now set the EVAL bit in the Array
    ! Sub-Node to indicate that subscripting actually is being done.  Also
    ! construct a new Sub-Node for the array element type and append it to
    ! the Primary Descriptor.  Then return.
    !
    NODEPTR[DBG$V_PNODE_EVAL] = TRUE;
    FCODE = DBG$STA_TYPEFCODE(.NODEPTR[DBG$L_PNARR_CELLTYPE]);
    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, RST$K_DATA, 0,
				.FCODE, .NODEPTR[DBG$L_PNARR_CELLTYPE], 0);
    RETURN;

    END;

ROUTINE GET_SUBSTRING (PRIMPTR, DSCADDR) : NOVALUE =
!
! FUNCTION
!	This routine picks up a substring reference.
!	For example, in FORTRAN, if a variable X is declared CHARACTER*n
!	then we want to allow X(i:j), where i and j represent the
!	beginning and ending character positions.
!	In PASCAL, if a variable X is declared PACKED ARRAY[1..N] OF CHAR
!	then we want to allow subscripting X[i] or ranged subscripting
!	X[i:j] to get at substrings of X.
!
!	This routine gets called from the GET_SUBSCRIPTS routine, at
!	the point where we discover that what we have is not an
!	array, but is a string.
!
!	The expression parser is called to pick up the first subscript.
!	If the terminator ":" is encountered then the expression parser
!	is called again to pick up the upper bound.
!
!	These substring bounds then get translated into the PRIM_OFFSET
!	and PRIM_LENGTH fields of the Primary Descriptor, and the
!	SUBREF flag is lit to indicate that a substring selection has
!	taken place.
!
! INPUTS
!	PRIMPTR - A pointer to the Primary Descriptor for a string
!	          about to be subscripted.
!	DSCADDR - A pointer to the string descriptor representing
!	          the string to be subscripted.
! 
! OUTPUTS
!	The PRIMPTR Primary Descriptor is changed to include the
!	substring information.
!
    BEGIN

    MAP
	PRIMPTR: REF DBG$PRIMARY,
	DSCADDR: REF DBG$STG_DESC;

    LOCAL
	HIGH_VALUE,			! Subscript value
	LOW_VALUE,			! Subscript value
    	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to Primary Subnode
	SAVED_RADIX,			! Temporary to save radix
	VALPTR: REF DBG$VALDESC;	! Pointer to a Value Descriptor



    ! Temporarily set the radix to decimal. Then call the Expression Parser
    ! to pick up the lower string bound. 
    !
    SAVED_RADIX = .EXPRESSION_RADIX;
    EXPRESSION_RADIX = DBG$K_DECIMAL;
    VALPTR = DBG$EXPRESSION_PARSER (FALSE, .SUBSCRIPT_TERM_TBL);
    EXPRESSION_RADIX = .SAVED_RADIX;


    ! Check the terminator code. If there was no terminator, (the
    ! input line just ended), signal an error. If the terminator was
    ! a comma, this is also an error - we only allow the colon or
    ! the closing subscript in this case.
    !
    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE
    THEN
	SIGNAL (DBG$_MISCLOSUB);
    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COMMA
    THEN
	SIGNAL (DBG$_SYNERREXPR, 1, UPLIT BYTE (%ASCIC ','));
    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;
    
    ! Convert the subscript value to longword integer.
    !
    LOW_VALUE = CONVERT_TO_INTEGER (.VALPTR);

    ! Check for ":" terminator. This indicates we also have to pick
    ! up the high value.
    !
    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
    THEN
	BEGIN

	! Pick up another expression for the high value.
	!
        SAVED_RADIX = .EXPRESSION_RADIX;
        EXPRESSION_RADIX = DBG$K_DECIMAL;
        VALPTR = DBG$EXPRESSION_PARSER (FALSE, .SUBSCRIPT_TERM_TBL);
        EXPRESSION_RADIX = .SAVED_RADIX;

	! Check for any of end-of-line, comma, or colon. These are all
	! errors here.
	!
        IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE
        THEN
	    SIGNAL (DBG$_MISCLOSUB);
        IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COMMA
        THEN
	    SIGNAL (DBG$_SYNERREXPR, 1, UPLIT BYTE (%ASCIC ','));
	IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COMMA
	THEN
	    SIGNAL (DBG$_SYNERREXPR, 1, UPLIT BYTE (%ASCIC ':'));
	CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;

	! Convert the value descriptor to an integer.
	!
	HIGH_VALUE = CONVERT_TO_INTEGER (.VALPTR);
	END

    ! No high value present - same as low value.
    !
    ELSE
	HIGH_VALUE = .LOW_VALUE;

    ! Signal an error if the range is reversed.
    !
    IF .LOW_VALUE LSS 1
    OR .HIGH_VALUE GTR .DSCADDR[DSC$W_LENGTH]
    OR .LOW_VALUE GTR .HIGH_VALUE
    THEN
	SIGNAL (DBG$_SUBSTRING, 3, .LOW_VALUE, .HIGH_VALUE, 
		.DSCADDR[DSC$W_LENGTH]);

    ! Signal an error if the values are too large to fit in a Primary.
    ! 
    IF .LOW_VALUE GTR %X'7FFF'
    THEN
    	SIGNAL(DBG$_ILLOFFSET, 1, .LOW_VALUE);
    IF (1+.HIGH_VALUE-.LOW_VALUE) GTR %X'7FFF'
    THEN
    	SIGNAL(DBG$_ILLSUBLEN);

    ! Modify the primary to indicate the substring information
    !
    NODEPTR = .PRIMPTR [DBG$L_PRIM_BLINK];
    PRIMPTR [DBG$V_DHDR_SUBREF] = TRUE;
    PRIMPTR [DBG$W_PRIM_OFFSET] = .LOW_VALUE;
    PRIMPTR [DBG$W_PRIM_LENGTH] = 1 + .HIGH_VALUE - .LOW_VALUE;
    NODEPTR [DBG$L_PNODE_RELOC] = -1;
    END;

ROUTINE OPERATOR_TO_RESTORE_RADIX =
!
! FUNCTION
!	This routine returns the Operator Lexical Token Entry for the
!	operator which will restore the currently set expression radix.
!	It is used in the processing of the lexical operators %DEC, %HEX,
!	%OCT, and %BIN.  If the current radix is decimal, for example,
!	when the %HEX operator is encountered, then the decimal radix must
!	be restored when the range of the %HEX operator ends.  Consider
!	this example:
!
!			10 + %HEX (20 + 30) - 40
!
!	Here 10 and 40 are interpreted as decimal numbers while 20 and 30
!	are treated as hexadecimal numbers.  When the %HEX operator is
!	encountered, this routine is called and returns the %DEC operator.
!	The %DEC operator is pushed onto the operator stack and the radix
!	is then set to hexadecimal.  When the minus sign is encountered,
!	it forces evaluation of the stacked %DEC operator which restores
!	the radix to decimal.
!
!	The current radix value is stored in and picked up from the OWN
!	variable EXPRESSION_RADIX.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	The return value of this routine is the address of the Operator
!		  Lexical Token Entry for the lexical operator which
!		  restores the current value of EXPRESSION_RADIX.
!

    BEGIN


    ! Based on the current radix value, return the lexical operator which
    ! will restore that radix value when popped from the operator stack
    ! and evaluated.
    !
    IF .EXPRESSION_RADIX EQL DBG$K_DECIMAL THEN RETURN RADIX_OP_DEC;
    IF .EXPRESSION_RADIX EQL DBG$K_HEX     THEN RETURN RADIX_OP_HEX;
    IF .EXPRESSION_RADIX EQL DBG$K_OCTAL   THEN RETURN RADIX_OP_OCT;
    IF .EXPRESSION_RADIX EQL DBG$K_BINARY  THEN RETURN RADIX_OP_BIN;


    ! Any other current radix value is an internal DEBUG error.
    !
    $DBG_ERROR('DBGPARSER\OPERATOR_TO_RESTORE_RADIX');
    RETURN 0;

    END;

ROUTINE PATHNAME_TO_PRIMARY(PATHDESC, SUBSCR_DESC, PLIPTR, 
    			    SAVED_PATHDESC, ARRAY_FLAG) =
!
! FUNCTION
!	This routine builds a Primary Descriptor Root Node in temporary
!	memory and returns a pointer to that descriptor.  The symbol for
!	which the descriptor is built is identified by a Pathname Descrip-
!	tor.  This routine passes the Pathname Descriptor to the GETSYMBOL
!	routine to get the symbol's SYMID, and then builds the Primary
!	Descriptor from that SYMID.  For data items, the symbol's FCODE
!	and TYPEID (which identify the data type) are also retrieved and
!	added to the Primary Descriptor.
!
!	After the Root Node has been build, DBG$BUILD_PRIMARY_SUBNODE is called
!	to build a Primary Descriptor Sub-Node for the symbol.  This means
!	that the Primary Descriptor is complete when PATHNAME_TO_PRIMARY
!	returns unless further subscripting or other qualification causes
!	additional Sub-Nodes to be appended later.
!
! INPUTS
!	PATHDESC - The address of a Pathname Descriptor which defines the
!		  symbol for which a Primary Descriptor is to be built.
!	SUBSCR_DESC - 	Some languages collect their subscripts as they
!		  pick up the Primary, and do not apply them until the
!		  end. In this case, SUBSCR_DESC is a data structure
!		  containing the saved subscripts.
!	PLIPTR -  In a PL/I exression of the form A->B, we first save away
!		  then Primary for "A". This Primary is in PLIPTR,
!		  and must be appended to the beginning of the Primary
!		  we now build.
!
!    	SAVED_PATHDESC: PTH$PATHNAME -
!		  This is an area of storage in which we can save
!		  away a copy of the pathname. This is used to make
!		  pathnames sticky in expressions such as
!		  P1\A->B	
!
!	ARRAY_FLAG - An optional fifth parameter, which, if present,
!		  indicates that this routine was called as part of an
!		  array subscripting operation. This is used in BASIC,
!		  where there may be two variables A, one an array and
!		  one not, and it is determined from context which is
!		  meant. This flag is just passed along to GETSYMBOL so
!		  that it can resolve the ambiguity properly.
!
! OUTPUTS
!	A Primary Descriptor for the symbol specified by PATHDESCR is built
!		  and its address is returned as the routine value.
!

    BEGIN

    MAP
	PATHDESC: REF PTH$PATHNAME,	! Pointer to input Pathname Descriptor
    	SAVED_PATHDESC: REF PTH$PATHNAME,! Saved copy of pathname.
    	SUBSCR_DESC: REF SUBSCR$DESC;	! Pointer to subscript information

    BUILTIN
    	ACTUALCOUNT;

    LOCAL
    	ARR_FLAG,			! TRUE if expecting an array.
    	BITSIZE,			! Bit length
    	DESCR: REF DBG$STG_DESC,	! String Descriptor
    	DUMMY,				! Unused output parameter
    	DTYPE,				! A type code
    	EXPECTED_SUBS,			! Count of expected number of subscripts
	FCODE,				! The data type format code for symbol
    	INDEX,				! Index into SYMID list
	KIND,				! RST symbol kind for current symbol
    	LEN,				! Byte length
    	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to Primary sub-node
	PATHSTRING,			! Pointer to pathname Counted ASCII
					!      string--used for messages
    	PATHVECTOR1: REF VECTOR[,LONG],	! Pathname vector
    	PATHVECTOR2: REF VECTOR[,LONG],	! Pathname vector
    	PICKED_UP_SUBSTRING,		! Flag for when we picked up a substring
	PRID: REF PRID$ENTRY,		! Pointer to Predefined Identifier Entry
    	PRIMPTR: REF DBG$PRIMARY,	! Pointer to Primary Descriptor
    	SCOPE,				! Scope where symbol was looked up
    	SCOPE_STATE,			! Kind of scope for SCOPE
    	SUBSCR_INDEX,			! Index into SUBSCR_DESC
    	SUBVECTOR:			! Pointer to subscript vector in
    	    REF DBG$PRIM_NODE_SUBS,	!      Primary Descriptor Sub-node
	SYMID: REF RST$ENTRY,		! SYMID (Symbol ID) for current symbol
	SYMID1: REF RST$ENTRY,		! scratch SYMID (Symbol ID)
	SYMID2: REF RST$ENTRY,		! scratch SYMID (Symbol ID)
    	SYMID_VECT: VECTOR[DBG$K_PATHNAME_SIZE], ! Vector of saved SYMIDs
    	TOOFEWSUB,			! Flag saying too few subscripts
    					!    were supplied.
    	TYPCOMPLST: REF VECTOR[,LONG],
	TYPEID: REF RST$ENTRY;		! The Type ID for the symbol's data type


    ! If the PLIPTR field is not zero then we already have part of the
    ! Primary.
    !
    IF .PLIPTR NEQ 0
    THEN
    	BEGIN
    	PRIMPTR = .PLIPTR;
    	NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    	NODEPTR[DBG$V_PNODE_EVAL] = TRUE;

    	IF .PATHDESC[PTH$B_PATHCNT] GTR 1
    	THEN

    	    ! Save away this pathname.
    	    !
    	    CH$MOVE(DBG$K_PATHNAME_SIZE, .PATHDESC, .SAVED_PATHDESC)

    	ELSE
    	    IF .SAVED_PATHDESC[PTH$B_PATHCNT] GTR 1
    	    THEN
    		BEGIN
    		LOCAL
    		    I;

    		! Merge the previous pathname into this one.
    		!
    		PATHVECTOR1 = PATHDESC[PTH$A_PATHVECTOR];
    		PATHVECTOR2 = SAVED_PATHDESC[PTH$A_PATHVECTOR];
    		I = .SAVED_PATHDESC[PTH$B_PATHCNT]-1;
    		DECR J FROM .PATHDESC[PTH$B_TOTCNT]-1 TO 0 DO
    		    PATHVECTOR1[.I+.J] = .PATHVECTOR1[.J];
    		DECR J FROM .I-1 TO 0 DO
    		    PATHVECTOR1[.J] = .PATHVECTOR2[.J];
    		PATHDESC[PTH$B_TOTCNT] = .PATHDESC[PTH$B_TOTCNT] + .I;
    		PATHDESC[PTH$B_PATHCNT] = .PATHDESC[PTH$B_PATHCNT] + .I;
    		! <<< INVOCNUM
    		END;    	    
    	END

    ELSE
    	BEGIN

        ! Allocate space for the Primary Descriptor and fill in the descriptor
        ! header fields and sub-node links.
        !
        PRIMPTR = DBG$GET_TEMPMEM(DBG$K_PRIMARY_SIZE);
        PRIMPTR[DBG$B_DHDR_TYPE] = DBG$K_PRIMARY_DESC;
    	PRIMPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
        PRIMPTR[DBG$W_DHDR_LENGTH] = DBG$K_PRIMARY_SIZE*%UPVAL;
        PRIMPTR[DBG$L_PRIM_FLINK] = PRIMPTR[DBG$A_PRIM_FLINK];
        PRIMPTR[DBG$L_PRIM_BLINK] = PRIMPTR[DBG$A_PRIM_FLINK];

    	! Save away copy of first pathname that we see.
    	!
    	IF .PATHDESC[PTH$B_PATHCNT] GTR 1
    	THEN
    	    CH$MOVE(DBG$K_PATHNAME_SIZE, .PATHDESC, .SAVED_PATHDESC)
    	ELSE
    	    SAVED_PATHDESC[PTH$B_PATHCNT] = 0;
    	END;

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;

    ! Call GETSYMBOL to get the KIND and SYMID for the symbol. 
    ! We pass along the flag saying whether this symbol was seen in
    ! a subscripted form - getsymbol can use that to resolve ambiguities
    ! in BASIC.
    ! This also gives the scope where the symbol
    ! was looked up and we save that in the Primary Root Node.
    ! Then case on the KIND to decide what to do next.
    !
    IF .COMPONENTS_IN_PATHNAME
    THEN
    	ARR_FLAG = .SUBSCR_DESC[0, SUBSCR$B_SUBCNT] GTR 0
    ELSE
    	ARR_FLAG = ACTUALCOUNT() GTR 4;
    DBG$STA_GETSYMBOL(.PATHDESC, SYMID, KIND, SCOPE_STATE, SCOPE, .ARR_FLAG, FALSE);
    PRIMPTR[DBG$B_PRIM_SCOPE_STATE] = .SCOPE_STATE;
    PRIMPTR[DBG$L_PRIM_SCOPE] = .SCOPE;

    SELECTONE .KIND OF
	SET


	! Handle the case where the symbol is not found in DEBUG's symbol
	! table (i.e., the RST).  Signal the appropriate error message.
	!
	[RST$K_INVALID]:
	    BEGIN

	    ! First check for Predefined Identifier reserved by the language.
            ! Note: We do this after we are sure that the symbol is not in
            !       the symbol table.  In PASCAL you may redefine the predefined
            !       symbols.  Currently, PASCAL is the only language where we
            !       have predefined identifiers.  FORTRAN has them but they are
            !       prefaced by a dot "." and are picked up by now.
	    ! Check that no invocation number is present.
	    !
	    IF .PATHDESC[PTH$B_LOCINVOC] EQL 0
		THEN
		    BEGIN
		    INCR I FROM 0 TO .PRIDTBL[-1] - 1 DO
			BEGIN
			PRID = .PRIDTBL[.I] + TABLEBASE;
			IF .PRID[PRID$B_KIND] EQL PRID$K_CONSTANT
			THEN
			    BEGIN

                            LOCAL
                                TEMP_NAME : REF VECTOR [,BYTE];

                            PATHVECTOR1 = PATHDESC[PTH$A_PATHVECTOR];
                            TEMP_NAME = .PATHVECTOR1[0];
			    IF CH$EQL(.PRID[PRID$B_LENGTH], 
				      PRID[PRID$A_NAME],
			              .TEMP_NAME[0], 
				      TEMP_NAME[1])
			    THEN
				BEGIN
				PRIMPTR = CREATE_PRID_CONSTANT(.PRID);
				RETURN .PRIMPTR;
				END;

			    END;
				    
			END;

	            END;

    	    IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL
    	    THEN
    		DBG$NCOB_PATHDESC_TO_CS(.PATHDESC, PATHSTRING)
    	    ELSE
	        DBG$NPATHDESC_TO_CS(.PATHDESC, PATHSTRING);
	    SIGNAL(DBG$_NOSYMBOL, 1, .PATHSTRING);
	    END;


	! Handle the case where the symbol is not unique.  Signal the appro-
	! priate error.
	!
	[RST$K_NOTUNIQUE,
	 RST$K_OVERLOAD]:
	    BEGIN

    	    IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL
    	    THEN
    		DBG$NCOB_PATHDESC_TO_CS(.PATHDESC, PATHSTRING)
    	    ELSE
	        DBG$NPATHDESC_TO_CS(.PATHDESC, PATHSTRING);

	    IF .KIND EQL RST$K_NOTUNIQUE
	    THEN
		SIGNAL(DBG$_NOUNIQUE, 1, .PATHSTRING)
	    ELSE
		SIGNAL(DBG$_NOTUNQOVR, 1, .PATHSTRING);

	    END;


	! Handle all lexical entities, instruction labels, and line numbers.
	! Zero the FCODE and TYPEID--they do not apply in these cases.
	!
	[RST$K_ROUTINE,
	 RST$K_BLOCK,
	 RST$K_ENTRY,
	 RST$K_LABEL,
	 RST$K_LINE]:
	    BEGIN

            PRIMPTR[DBG$B_DHDR_KIND] = .KIND;
            PRIMPTR[DBG$L_DHDR_SYMID0] = .SYMID;
	    FCODE = 0;
	    TYPEID = 0;


    	    ! Build a Primary Descriptor Sub-Node for the symbol we have so far.
    	    !
    	    DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, .KIND, .SYMID, .FCODE, .TYPEID, 0);
	    END;


	! Handle data items.  Here we get the FCODE and TYPEID of the data
	! item and store them in the Primary Descriptor.
	!
	[RST$K_DATA]:
	    BEGIN


    	    ! Walk the up-scope chain collecting all data symids above this one.
    	    ! This is in order to handle a case such as "X.Y.Z". In this example`,
    	    ! we build a vector of 3 symids: one for Z, one for Y, and one for X.
    	    !
    	    INDEX = -1;
    	    WHILE .KIND EQL RST$K_DATA DO
    		BEGIN
    		INDEX = .INDEX + 1;
    		IF .INDEX GEQ DBG$K_PATHNAME_SIZE
    		THEN
    	    	    $DBG_ERROR('DBGPARSER\PATHNAME_TO_PRIMARY symid stack overflow');
    		SYMID_VECT[.INDEX] = .SYMID;
    		SYMID = .SYMID[RST$L_UPSCOPEPTR];
    		KIND = .SYMID[RST$B_KIND];
    		END;
    

    	    ! Now walk back down the symid list, building up the Primary Descriptor.
    	    !
    	    SUBSCR_INDEX = 0;
    	    EXPECTED_SUBS = 0;
    	    TOOFEWSUB = FALSE;
    	    DECR I FROM .INDEX TO 0 DO
    		BEGIN
    		SYMID = .SYMID_VECT[.I];

    		! Fill in the root node SYMID if we are at the top of the list.
    		!
    		IF (.I EQL .INDEX) AND (.PLIPTR EQL 0)
    		THEN
        	    PRIMPTR[DBG$L_DHDR_SYMID0] = .SYMID;
    			
    		! Get the KIND, FCODE, and TYPEID, and build a new subnode.
    		!
    		KIND = .SYMID[RST$B_KIND];
		DBG$STA_SETCONTEXT(.SYMID);
		DBG$STA_SYMTYPE(.SYMID, FCODE, TYPEID);
        	DBG$BUILD_PRIMARY_SUBNODE(.PRIMPTR, .KIND, .SYMID, .FCODE, .TYPEID, 0);

    		! Obtain a pointer to the newly-built subnode.
    		!
    		NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];

    		! If there was an address override as in P->X then set a flag
    		! saying not to use the SYMID of X for address computations
    		! (we still retain it for printing, however)
    		!
    		IF (.I EQL .INDEX) AND (.PLIPTR NEQ 0)
    		THEN
    		    IF .FCODE EQL RST$K_TYPE_RECORD
    		    THEN
    			NODEPTR[DBG$L_PNODE_SYMID] = 0
    		    ELSE
    		        NODEPTR[DBG$V_PNODE_IGNORE] = TRUE;

    		! If we have just attached an array subnode then fill
    		! in the subscript information here.
    		!
    		IF .FCODE EQL RST$K_TYPE_ARRAY
    		AND .COMPONENTS_IN_PATHNAME
    		THEN
    		    BEGIN
    		    SUBVECTOR = NODEPTR[DBG$A_PNARR_SVECTOR];
    		    EXPECTED_SUBS = .EXPECTED_SUBS + .NODEPTR[DBG$B_PNARR_DIMCNT];

    		    ! Loop through the dimensions of the array.
    		    !
    		    INCR J FROM 0 TO .NODEPTR[DBG$B_PNARR_DIMCNT]-1 DO
    			BEGIN

    			! Signal an error if not enough subscripts were supplied.
    			!
    			IF  (.SUBSCR_INDEX GEQ .SUBSCR_DESC[0, SUBSCR$B_SUBCNT])
    			AND ((.SUBSCR_DESC[0, SUBSCR$B_SUBCNT] NEQ 0) OR
    			    (.I NEQ 0))
    			THEN
    			    BEGIN
    			
    			    ! We have a problem in that we know we don't have
    			    ! enough subscripts, but we don't know exactly
    			    ! how many we were expecting. So what we do here
    			    ! is just set a flag saying to signal the error
    			    ! later on (after we do know).
    			    !
    			    TOOFEWSUB = TRUE;
    			    SUBSCR_DESC[0, SUBSCR$B_SUBCNT] = 0;
    			    END;

    		        ! Special check for no subscripts specified - treat this
    		        ! the same as if (*,*,...) were specified (aggregate
    		        ! examine).
    		        !
    		        IF .SUBSCR_DESC[0, SUBSCR$B_SUBCNT] EQL 0
    		        THEN
    			    INCR J FROM 0 TO .NODEPTR[DBG$B_PNARR_DIMCNT] DO
    			        BEGIN
    			        SUBSCR_DESC[.SUBSCR_INDEX + .J, 
    				    SUBSCR$V_RANGE] = TRUE;
    			        SUBSCR_DESC[.SUBSCR_INDEX + .J, 
    				    SUBSCR$V_ASTER] = TRUE;
    			        END;


    			! If we were given a range then fix up the sub-node
    			! to reflect a ranged examine.
    			!
    			IF .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_RANGE]
    			THEN
    			    BEGIN
    		
    			    ! Do not allow asterisk unless we are at the
    			    ! bottom level. *** TEMPORARY
    			    !
    			    IF (.I NEQ 0) AND 
    			       (.SUBSCR_DESC[0, SUBSCR$B_SUBCNT] NEQ 0)
    			    THEN
    				IF .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_ASTER]
    				THEN
    				    SIGNAL(DBG$_ILLASTER)
    	    			ELSE
    				    SIGNAL(DBG$_ILLRANGE);
    					

    			    IF NOT .NODEPTR[DBG$V_PNARR_RANGE]
    			    THEN
    				BEGIN
    				NODEPTR[DBG$V_PNARR_RANGE] = TRUE;
    				INCR K FROM 0 TO .J-1 DO
    				    BEGIN
    				    SUBVECTOR[.K, DBG$L_PNSUB_LBOUND] =
    					.SUBVECTOR[.K, DBG$L_PNSUB_SVALUE];
    				    SUBVECTOR[.K, DBG$L_PNSUB_UBOUND] = 
    					.SUBVECTOR[.K, DBG$L_PNSUB_SVALUE];
    				    END;
    				END;

    			    IF NOT .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_ASTER]
    			    THEN
    				BEGIN

    			        ! Check for reversed range.
    			        !
	        		IF .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND] GTR
		           	   .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND]
    			        THEN 
    				    SIGNAL(DBG$_INVRANSPEC);

    				SUBVECTOR[.J, DBG$L_PNSUB_LBOUND] = 
    				    .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND];
    				SUBVECTOR[.J, DBG$L_PNSUB_UBOUND] =
    				    .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND];
    				END;

    			    SUBVECTOR[.J, DBG$L_PNSUB_SVALUE] = 
    				.SUBVECTOR[.J, DBG$L_PNSUB_LBOUND]
    			    END

    			! Fill in the subscript value.
    			!
    			ELSE
    			    BEGIN
    			    LOCAL
    				VAL;

    			    VAL = .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND];
    			    IF (.VAL LSS .SUBVECTOR[.J, DBG$L_PNSUB_LBOUND]) OR
    			       (.VAL GTR .SUBVECTOR[.J, DBG$L_PNSUB_UBOUND])
    			    THEN
    				SIGNAL(DBG$_SUBOUTBND, 4, .SUBSCR_INDEX, .VAL,
    				       .SUBVECTOR[.J, DBG$L_PNSUB_LBOUND],
    				       .SUBVECTOR[.J, DBG$L_PNSUB_UBOUND]);
    		 	    SUBVECTOR[.J, DBG$L_PNSUB_SVALUE] = 
    			        .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND];
    			    END;

    			! If we previously got a range, then make this dimension
    			! into a range also.
    			!
    			IF .NODEPTR[DBG$V_PNARR_RANGE] AND
    			NOT .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_RANGE]
    			THEN
    			    BEGIN
    			    SUBVECTOR[.J, DBG$L_PNSUB_LBOUND] =
    				.SUBVECTOR[.J, DBG$L_PNSUB_SVALUE];
    			    SUBVECTOR[.J, DBG$L_PNSUB_UBOUND] =
    				.SUBVECTOR[.J, DBG$L_PNSUB_SVALUE];
    			    END;

    			SUBSCR_INDEX = .SUBSCR_INDEX + 1;
    			END;

    		    ! Fill in the field that gives the count of subscripts.
    		    ! Also, unless this is an array slice, then light the
    		    ! EVAL bit which says that subscripting is being done,
    		    ! and tack on a new subnode.
    		    !
    		    NODEPTR[DBG$B_PNARR_SUBCNT] = .NODEPTR[DBG$B_PNARR_DIMCNT];
    		    IF NOT .NODEPTR[DBG$V_PNARR_RANGE]
    		    THEN
    		        BEGIN
    		        NODEPTR[DBG$V_PNODE_EVAL] = TRUE;

    		        ! Attach a new Primary sub-node for the array elements.
    		        !
    			TYPEID = .NODEPTR[DBG$L_PNARR_CELLTYPE];
    		        FCODE = DBG$STA_TYPEFCODE(.TYPEID);
    		        DBG$BUILD_PRIMARY_SUBNODE (.PRIMPTR, RST$K_DATA, 0,
    			    .FCODE, .TYPEID, 0);
    		        NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    			END;
    		    END;


    		! If we have just attached a record subnode then fill
    		! in the component information here. Note that this must
    		! be done after the array case above, to properly handle
    		! arrays of records.
    		!
    		IF (.FCODE EQL RST$K_TYPE_RECORD) AND
    		   (.COMPONENTS_IN_PATHNAME) AND
     		   (.I NEQ 0)
    		THEN
    		    BEGIN

    		    ! If we are not at the bottom symid, then there must be
    		    ! a symid for the record component below this one.
    		    ! We need to fill in the corresponding record sub-node
    		    ! with the component index. This component index is
    		    ! used by MODIFY_PRIMARY to compute logical sucessor/
    		    ! predecessor. We also light the "EVAL" bit in the
    		    ! sub-node.
    		    !
    		    NODEPTR[DBG$V_PNODE_EVAL] = TRUE;
    		    SYMID1 = .SYMID_VECT[.I-1];
    		    TYPCOMPLST = TYPEID[RST$A_TYPCOMPLST];
    		    INCR J FROM 0 TO .TYPEID[RST$L_TYPCOMPCNT] - 1 DO
    			BEGIN
    			SYMID2 = .TYPCOMPLST[.J];


    			! Use the DSTPTR to determine whether we are
    			! really looking at the right component.
    			!
    			IF .SYMID1[RST$L_DSTPTR] EQL .SYMID2[RST$L_DSTPTR]
    			THEN
    			    BEGIN
    			    NODEPTR[DBG$W_PNREC_INDEX] = .J + 1;
    			    EXITLOOP;
    			    END;

    			! We should not fall through to here.
    			END;
    		    END;
    		END;

    	    ! If we have not exhausted the given list of subscripts,
    	    ! then first check for a substring reference. 
    	    ! We must have seen something that
    	    ! looks like a ranged subscript "(i:j)". In order for a 
    	    ! substring to be legal then the data type must
    	    ! either be text or one of the decimal string types.
    	    !
    	    PICKED_UP_SUBSTRING = 0;
    	    IF  (.SUBSCR_INDEX EQL (.SUBSCR_DESC[0, SUBSCR$B_SUBCNT]-1))
    	    AND .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_RANGE]
    	    AND .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_MARKER]
    	    AND (NOT .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$V_ASTER])
    	    THEN
    		BEGIN
    		DTYPE = DSC$K_DTYPE_Z;
    		IF .KIND EQL RST$K_DATA
    		THEN
    		    BEGIN
    		    SELECTONE .FCODE OF
    			SET
    			[RST$K_TYPE_ATOMIC]:
    			    BEGIN
    			    DBG$STA_TYP_ATOMIC(.TYPEID, DTYPE, BITSIZE);
    			    LEN = .BITSIZE / 8;
    			    END;
    			[RST$K_TYPE_DESCR]:
    			    BEGIN
    			    DBG$STA_TYP_DESCR(.TYPEID, DESCR);
    			    DTYPE = .DESCR[DSC$B_DTYPE];
    			    LEN = .DESCR[DSC$W_LENGTH];
    			    END;
    			[RST$K_TYPE_PICT, RST$K_TYPE_RECORD]:
    			    BEGIN
    			    DTYPE = DSC$K_DTYPE_T;
    			    LEN = 10000;	! Pick large number to allow
    						! arbitrarily long substring.
    			    END;
    			TES;
    		    IF (.DTYPE EQL DSC$K_DTYPE_T) OR
    		       (.DTYPE EQL DSC$K_DTYPE_NU) OR
    		       (.DTYPE EQL DSC$K_DTYPE_NL) OR
    		       (.DTYPE EQL DSC$K_DTYPE_NLO) OR
    		       (.DTYPE EQL DSC$K_DTYPE_NR) OR
    		       (.DTYPE EQL DSC$K_DTYPE_NRO) OR
    		       (.DTYPE EQL DSC$K_DTYPE_NZ)
    		    THEN
    		        BEGIN

    		        ! Modify the primary to indicate the substring information
    		        !
    			PRIMPTR [DBG$V_DHDR_AGGR] = FALSE;
    		        PRIMPTR [DBG$V_DHDR_SUBREF] = TRUE;

    			IF .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND] GTR 
    			    %X'7FFFF'
    			THEN
    			    SIGNAL(DBG$_ILLOFFSET, 1, 
    				 .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND]);
    		        PRIMPTR [DBG$W_PRIM_OFFSET] = 
    			    .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND];
    		        IF ((.SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND] +
    		             .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND]-1)
    			      GTR .LEN) OR
    			    (.SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND]
    			      LSS 1)
    		        THEN
    			    SIGNAL(DBG$_SUBSTRING, 3, 
    			           .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_LBOUND],
    			           .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND],
    			           .LEN);

    			IF .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND] GTR
    				%X'7FFF'
    			THEN
    			    SIGNAL(DBG$_ILLSUBLEN, 1, 
    				.SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND]);
    		        PRIMPTR [DBG$W_PRIM_LENGTH] = 
    			    .SUBSCR_DESC[.SUBSCR_INDEX, SUBSCR$L_UBOUND];
    		        NODEPTR = .PRIMPTR [DBG$L_PRIM_BLINK];
    		        NODEPTR [DBG$L_PNODE_RELOC] = -1;
    		        PICKED_UP_SUBSTRING = 1;
    		        SUBSCR_INDEX = .SUBSCR_INDEX + 1;
    		        END
    		    ELSE
     
			! We have seen something that looks like a substring
    			! but the data type is wrong. Catch that case here and
    			! signal an error.
    			!
    			SIGNAL(DBG$_ILLSUBSTR);
    		    END

    		ELSE
    		    ! We have seen something that looks like a substring
    		    ! but the data type is wrong. Catch that case here and
    		    ! signal an error.
    		    !
    		    SIGNAL(DBG$_ILLSUBSTR);
    		END;


    	    ! Signal an error if we picked up too many or too few subscripts.
    	    !
    	    IF .TOOFEWSUB
    	    THEN
    		SIGNAL(DBG$_TOOFEWSUB, 1, .EXPECTED_SUBS);
    	    IF .SUBSCR_INDEX LSS .SUBSCR_DESC[0, SUBSCR$B_SUBCNT]
    	    THEN
    		SIGNAL(DBG$_TOOMANSUB, 1, .SUBSCR_INDEX-.PICKED_UP_SUBSTRING);

    	    END;

	! Anything else we treat as an internal DEBUG error.
	!
	[OTHERWISE]:
	    $DBG_ERROR('DBGPARSER\PATHNAME_TO_PRIMARY 10');

	TES;


    ! Return a pointer to the Primary Descriptor to the caller.
    !
    RETURN .PRIMPTR;
    END;

ROUTINE RESOLVE_COMPONENT (TYPEID, COMP_LIST, SYMID, PRIMPTR, COMPNAME) =
!
! FUNCTION
!	This routine is called from GET_RECORD_COMPONENT to resolve 
!	possible ambiguities where the user has specified X.Y and
!	there is more than one record component named Y.
!
!	This situation arises in C, where membership checking is not
!	enforced. Thus in C you can say X.Y even though Y is not a 
!	component in the record given by X. If we find more than one
!	symid for Y, there is a possible ambiguity (although if all
!	of the symids are record components with the same type and
!	offset, then it is OK).
!
!	A different situation arises in BASIC. Here, we allow A::C to
!	be an abbreviation for A::B::C (incomplete data qualification).
!	In this case, the INCOMPLETE_QUAL flag is lit. What we do here
!	is call a routine which chases upscope pointers to determine
!	whether we can get to the given TYPEID from the component SYMID.
!
! INPUTS
!	TYPEID		- typeid for the record
!	COMP_LIST	- list of symids which are record components having
!			      the same name. This list is in the form of
!			      a vector of longword, with the first longword
!			      being the count.
!	SYMID		- address in which to leave the resolved symid,
!			      if one is determined.
!	PRIMPTR		- pointer to the input Primary
!	COMPNAME	- name of the component
!
! OUTPUTS
!	The value TRUE is returned if a unique symid was determined; 
!	FALSE otherwise. If TRUE is returned then the output parameter
!	SYMID is filled in.
!
    BEGIN
    MAP
    	COMP_LIST: REF VECTOR[];
    LOCAL
    	FOUND;

    DBG$GL_CURRENT_PRIMARY = .PRIMPTR;

    ! If incomplete data qualification is allowed in this language
    ! (for example A::C in place of A::B::C) then we search the list
    ! of candidate components to see if there is a unique one in the
    ! given record. For example, if the user says A::C, and there are
    ! several components C, but only one belongs in record A, then
    ! that is the one we want.
    !
    ! This is the code path taken for language BASIC.
    !
    IF .INCOMPLETE_QUAL
    THEN
    	BEGIN
    	FOUND = FALSE;
       	INCR I FROM 1 TO .COMP_LIST[0] DO

    	    ! The CHECK_UPSCOPE routine determines whether the given
    	    ! record component belongs in the record given by TYPEID.
    	    ! If it does, but there are intervening record components,
    	    ! then the Primary must be modified to include the component
    	    ! selection for these intervening components.
    	    !
    	    IF CHECK_UPSCOPE(.COMP_LIST[.I], .TYPEID, .PRIMPTR, 0)
    	    THEN
    		IF .FOUND
    		THEN

    		    ! Not unique.
    		    !
    		    RETURN FALSE
    		ELSE
    		    BEGIN

    		    ! We found one.
    		    !
    		    .SYMID = .COMP_LIST[.I];
    		    FOUND = TRUE;
    		    END;

    	! If we failed to find one, signal that the given component
        ! is not a field of this record. Note that we do not return FALSE
    	! here - returning FALSE indicates an ambiguous field name.
    	!
    	IF NOT .FOUND
    	THEN
    	    SIGNAL(DBG$_NOFIELD, 1, .COMPNAME); 

    	! Found a unique component - return true.
    	!
    	RETURN TRUE;
    	END;


    ! This is where we end up for C: we are trying to resolve an ambiguity.
    ! Check for only one component in list: then there is no ambiguity.
    !
    IF .COMP_LIST[0] EQL 1
    THEN
    	BEGIN
    	.SYMID = .COMP_LIST[1];
        RETURN TRUE;
    	END;

    ! More than one component.
    !
    RETURN FALSE;  
    END;

ROUTINE SAVE_SUBSCRIPTS(PATHDESC, SUBSCR_DESC): NOVALUE =
!
! FUNCTION
!	When parsing PLI or BASIC Primaries we want to save away the subscripts
!	that we see along the way. This routine picks up subscripts and
!	saves them into the SUBSCR_DESC data structure.
!
! INPUTS
!	PATHDESC	-	A pointer to the pathname descriptor for
!				the pathname we have parsed so far.
!	SUBSCR_DESC	-	A data structure containing the subscript
!				values.
!
! OUTPUTS
!
    BEGIN
    MAP
       	PATHDESC: REF PTH$PATHNAME,
    	SUBSCR_DESC: REF SUBSCR$DESC;

    LOCAL
	DECLTYPE: REF DBG$VALDESC,	! Pointer to Value Descriptor for
					!      declared subscript data type
    	LA_PTR: REF VECTOR[,BYTE],	! Lookahead pointer into input
	LOW_RANGE_VAL,			! Low value of a subscript range
    	PATH_INDEX,			! Count of pathname components
	SAVED_RADIX,			! Temporarily saved expression radix
	SUBSCR_COUNT,			! Actual subscript count in input line
	THIS_SUBSCR_IS_RANGE,		! Flag set if the current subscript is
					!      given as a subscript range
    	TOKEN,				! Lexical Token
	VALADDR: REF VECTOR[,LONG],	! Pointer to integer subscript value
	VALPTR: REF DBG$VALDESC;	! Pointer to subscript Value Descriptor



    ! Note how many subscripts we have previously picked up (i.e., in earlier
    ! calls to this routine, while parsing this same expression). In PL/I,
    ! for example, the subscripts may arrive in separate pieces, and do not
    ! necessarily have to be associated with the "right" component, e.g.,
    ! X(1,2).Y(3).Z(4,5)
    ! This routine also picks up substring references in COBOL. Because of this,
    ! we set a marker to indicate where we were in SUBSCR_DESC when we entered
    ! this routine. E.g., in the COBOL expression X(1,2,3)(1:5) we set a 
    ! marker to indicate that the 1:5 came in a separate set of parenthesis.
    ! It would be illegal otherwise, so this marker can be used later to
    ! decide whether to signal an error.
    !
    SUBSCR_COUNT = .SUBSCR_DESC[0, SUBSCR$B_SUBCNT];
    SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$V_MARKER] = TRUE;


    ! Loop through the subscript expressions for this array reference.  Each
    ! subscript is parsed, evaluated, and converted to integer. Its value
    ! is then stored in the SUBSCR_DESC data structure.
    ! 
    PATH_INDEX = .PATHDESC[PTH$B_TOTCNT];
    THIS_SUBSCR_IS_RANGE = FALSE;
    TERMINATOR_CODE = TOKEN$K_TERM_COMMA;
    WHILE .TERMINATOR_CODE NEQ TOKEN$K_TERM_CLOSE DO
	BEGIN


    	! Look for the asterisk. X(*) is the same as X(lower:upper).
    	! If we find the asterisk then advance the character pointer beyond
    	! the asterisk and also increment the subscript count.
    	!
    	LA_PTR = .CHARPTR;
    	WHILE .LA_PTR[0] EQL ' ' DO LA_PTR = .LA_PTR + 1;
    	IF .LA_PTR[0] EQL '*'
    	THEN
    	    BEGIN
    	    CHARPTR = .LA_PTR + 1;


    	    ! Call the Lexical Scanner to take us past the ',' or 
    	    ! or ']' or ')'. This will set TERMINATOR_CODE to the
    	    ! terminator that is seen. If we do not see a terminator
    	    ! then signal a syntax error. Also signal an error if
    	    ! ':' was the terminator.
    	    !
    	    TOKEN = DBG$LEXICAL_SCANNER (FALSE, FALSE,
    			.SUBSCRIPT_TERM_TBL, 0);
    	    IF .TOKEN NEQ TERMINATOR_TOKEN
    	    THEN
    		BEGIN
    		LOCAL
    		    ASCIC_STRING: VECTOR[2,BYTE];
    		ASCIC_STRING[0] = 1;
    		ASCIC_STRING[1] = .CHARPTR[0];
    		SIGNAL(DBG$_SYNERREXPR, 1, ASCIC_STRING);
    		END;	
    	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
    	    THEN    		
    		SIGNAL (DBG$_INVRANSPEC);
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE 
    	    THEN 
    		SIGNAL(DBG$_MISCLOSUB);
	    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


    	    SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$B_PATH_INDEX] = .PATH_INDEX;
    	    SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$V_ASTER] = TRUE;
    	    SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$V_RANGE] = TRUE;
    	    SUBSCR_COUNT = .SUBSCR_COUNT + 1;
    	    END

    	ELSE
    	    BEGIN


	    ! Call the expression parser to pick up the next subscript expression
	    ! and its value.  Note that we set the radix to decimal over this call
	    ! and then restore it.  Also note that the Expression Parser sets
	    ! TERMINATOR_CODE and TERMINATOR_LENGTH as a side-effect.
	    !
	    SAVED_RADIX = .EXPRESSION_RADIX;
	    EXPRESSION_RADIX = DBG$K_DECIMAL;
	    VALPTR = DBG$EXPRESSION_PARSER (FALSE, .SUBSCRIPT_TERM_TBL);
	    EXPRESSION_RADIX = .SAVED_RADIX;


	    ! Check the terminator code.  If there was no terminator (the input
	    ! line just ended), signal an error.  Otherwise we got a comma or clos-
	    ! ing subscript parenthesis and we increment CHARPTR to get past it.
	    !
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_NONE THEN SIGNAL(DBG$_MISCLOSUB);
	    CHARPTR = .CHARPTR + .TERMINATOR_LENGTH;


    	    ! We now need to convert the subscript to one of the appropriate
    	    ! dtype. We need to set up a target descriptor for the conversion
    	    ! routine. We allocate a skeleton descriptor and fill in some of 
    	    ! the fields.
	    !
	    DECLTYPE = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
	    DECLTYPE[DBG$B_DHDR_KIND] = RST$K_DATA;
	    DECLTYPE[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
	    DECLTYPE[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
	    DECLTYPE[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
	    DECLTYPE[DBG$W_VALUE_LENGTH] = 4;
	    DECLTYPE[DBG$L_VALUE_POINTER] = DECLTYPE[DBG$A_VALUE_ADDRESS];


    	    ! Finally call the conversion routine. This routine checks that
    	    ! the conversion is legal before doing it.
     	    !
	    VALPTR = DBG$EVAL_LANG_OPERATOR(DBG$GL_CONVERT_TOKEN, .VALPTR, .DECLTYPE);
    	    VALADDR = .VALPTR[DBG$L_VALUE_POINTER];


	    ! If the terminator at the end of this subscript expression was a colon
	    ! we have a subscript range (for example, "ARR(1:5,2)").  We thus set
	    ! the subscript-range flag and save the low value of the range, i.e.
	    ! the value we just picked up.  If this is the first range in the
	    ! subscript list, we also turn all previous subscripts into ranges by
	    ! setting the lower and upper bound for each such subscript to the
	    ! corresponding subscript value.  This in effect defines a new array
	    ! which constitutes a "slice" of the original array.
	    !
	    IF .TERMINATOR_CODE EQL TOKEN$K_TERM_COLON
	    THEN
	        BEGIN
	        IF .THIS_SUBSCR_IS_RANGE THEN SIGNAL(DBG$_INVRANSPEC);
	        THIS_SUBSCR_IS_RANGE = TRUE;
	        LOW_RANGE_VAL = .VALADDR[0];
	        END


	    ! The terminator was not a colon, so we now have the full subscript
	    ! specification.  Fill the subscript value into the Array Sub-Node's
	    ! subscript vector.  Set up the bounds for an array "slice" if this
	    ! or any previous subscript specification in this array reference
	    ! consisted of a subscript range.  Also bump the subscript count.
	    !
	    ELSE
	        BEGIN


	        ! If this subscript is specified as a subscript range, check that
	        ! the first value in the range is not greater than the second.
	        ! Also clear the subscript-is-range flag for the next subscript.
	        !
	        IF .THIS_SUBSCR_IS_RANGE
	        THEN
		    BEGIN
    		    SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$V_RANGE] = TRUE;
		    THIS_SUBSCR_IS_RANGE = FALSE;
		    END


	        ! Otherwise, set the low range value to be the subscript value.
	        !
	        ELSE
		    LOW_RANGE_VAL = .VALADDR[0];


	        ! Finally fill in the subscript value itself (the start of the
	        ! range), increment the subscript count, and loop.
	        !
    		SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$B_PATH_INDEX] = .PATH_INDEX;
	        SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$L_LBOUND] = .LOW_RANGE_VAL;
	        IF .SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$V_RANGE]
	        THEN
		    SUBSCR_DESC[.SUBSCR_COUNT, SUBSCR$L_UBOUND] = .VALADDR[0];
	        SUBSCR_COUNT = .SUBSCR_COUNT + 1;
	        END;
    	    END;
	END;				! End of WHILE loop over subscripts


    ! We have picked up all the subscripts within this set of subscript paren-
    ! theses.  
    SUBSCR_DESC[0, SUBSCR$B_SUBCNT] = .SUBSCR_COUNT;
    RETURN;
    END;

ROUTINE SCAN_QUOTED_STRING(TOKENBUFFER, TOKEN_TYPE): NOVALUE =
!
! FUNCTION
!	This routine scans a quoted character string and returns the found
!	string in Counted ASCII format to a caller-provided buffer.  It
!	expects the OWN pointer CHARPTR to point to the quote character at
!	the start of the character constant and it assumes that this in
!	fact is a valid quote character.  It then scans for the closing
!	quote character (which must be the same character as the opening
!	quote), treating doubled up quote characters within the string as
!	a single quoted quote character.  If the language is set to PL/I, then
!	after finding the closing quote, it searches for a "B" or "b", to
!	determine if the string could be a bit-string rather than a 
!	character string.  If the quote characters are not "'", or if any
!	double quotes are encountered, then the trailing "B" is not
!	searched for.
!
!	If a carriage-return (end of input line) is found before the closing
!	quote or if the string exceeds 255 characters (the longest Counted
!	ASCII allows), an error is signalled.  Otherwise, CHARPTR is left
!	pointing to the first character after the closing quote and the
!	string itself is returned as Counted ASCII to the caller's buffer.
!
! INPUTS
!	TOKENBUFFER - A pointer to the buffer in which the character string is
!		  to be accumulated.  This buffer is expected to be 256 charac-
!		  ters long, enough for the longest Counted ASCII string.
!
! 	TOKEN_TYPE  - Address of where to return token's type.
!
! OUTPUTS
!	TOKENBUFFER - The quoted character string is accumulated and returned
!		  as a Counted ASCII string to the buffer pointed to by
!		  TOKENBUFFER.
!
!	TOKEN_TYPE  - Is filled in with either TOKEN$K_STRING or
!		  TOKEN$K_BIT_STRING.
!

    BEGIN

    MAP
	TOKENBUFFER: REF VECTOR[,BYTE],	! Pointer to buffer for char string
	TOKEN_TYPE : REF VECTOR[1];	! Longword to receive token's type.

    LOCAL
	QUOTE,				! Quote character which started the
					!      current quoted string constant
	DOUBLED_QUOTES,			! Flag denotes whether or not there
					!      exist doubled up quotes ('').
	TOKENLEN;			! Length of quoted string so far



    ! We pick up the closing quote character (which must be the same as the
    ! opening quote character) and then scan for the end of the string.
    ! Doubled up quotes are reduced to a single quote within the string
    ! and a carriage-return (end of line) is treated as an error (quotes
    ! not balanced).  Doubled up quotes set DOUBLED_QUOTES flag.
    !
    DOUBLED_QUOTES = FALSE;
    QUOTE = .CHARPTR[0];
    TOKENLEN = 0;
    TOKEN_TYPE[0] = TOKEN$K_STRING;

    WHILE TRUE DO
	BEGIN
	CHARPTR = .CHARPTR + 1;
	IF .CHARPTR[0] EQL CAR_RET THEN SIGNAL(DBG$_MATQUOMIS);
	IF .CHARPTR[0] EQL .QUOTE
	THEN
	    BEGIN
	    CHARPTR = .CHARPTR + 1;
	    IF .CHARPTR[0] NEQ .QUOTE THEN EXITLOOP;
	    DOUBLED_QUOTES = TRUE;
	    END;

	IF .TOKENLEN GEQ 255 THEN SIGNAL(DBG$_QUOSTRLONG);
	TOKENLEN = .TOKENLEN + 1;
	TOKENBUFFER[.TOKENLEN] = .CHARPTR[0];
	END;


    ! If langusge is PL/I, then check for a bit-string.
    ! If the quotes are "'" and there were no doubled up quotes, then
    ! see if the next character is the letter "B" or "b".  If so, then
    ! change TOKEN_TYPE to be a bit-string (TOKEN$K_BIT_STRING).  The
    ! "B" is not part of the length of the string.
    !
    IF .DBG$GB_LANGUAGE EQL DBG$K_PLI 
	AND .QUOTE EQL DBG$K_QUOTE 
	AND NOT .DOUBLED_QUOTES
    THEN
	IF .CHARPTR[0] EQL %C'B' OR .CHARPTR[0] EQL %C'b'
	THEN
	    BEGIN
	    CHARPTR = .CHARPTR + 1;
	    TOKEN_TYPE[0] = TOKEN$K_BIT_STRING;
	    END;


    ! We found the end of the string.  Complete the Counted ASCII string in
    ! the TOKENBUFFER buffer by filling in the length and return.
    !
    TOKENBUFFER[0] = .TOKENLEN;
    RETURN;

    END;

END ELUDOM
