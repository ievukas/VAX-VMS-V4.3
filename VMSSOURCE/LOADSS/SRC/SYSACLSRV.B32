MODULE SYSACLSRV (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000',
		ADDRESSING_MODE (EXTERNAL = GENERAL,
				 NONEXTERNAL = LONG_RELATIVE)
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	Miscellaneous system services
!
! ABSTRACT:
!
!	This module contains the routines necessary to convert an Access
!	Control Entry from a user (text) format to an internal (binary)
!	format and back again.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, non-privileged system services.
!
!--
!
!
! AUTHOR:	L. Mark Pilant		CREATION DATE:	30-Sep-1982  11:00
!
! MODIFIED BY:
!
!	V03-021	LMP0299		L. Mark Pilant,		8-Aug-1984  12:31
!		Require SYSPRV to add an ACL to a device if it is unowned
!		and there is no ACL already present on the device.
!
!	V03-020	LMP0275		L. Mark Pilant,		11-Jul-1984  10:11
!		If the ACL defined in the ORB is not a queue, initialize
!		it.  (This is to optimize the path through EXE$CHKPRO_INT.)
!
!	V03-019	LMP0271		L. Mark Pilant,		29-Jun-1984  13:18
!		Add support for ORB$V_NOACL.  (This is used by shared memory
!		mailboxes to disallow ACLs.)
!
!	V03-018	LMP0261		L. Mark Pilant,		26-Jun-1984 11:25
!		Fix a bug that caused the success status to be dropped from
!		the formatted AUDIT type ACE.
!
!	V03-017	LMP0248		L. Mark Pilant,		3-May-1984  14:30
!		Include the FID in the lock resource name for files, so that
!		unique lock names will be generated.  Also, do the unlock
!		regardless of the status if indicated by the item list.
!
!	V03-016	LMP0243		L. Mark Pilant,		1-May-1984  8:45
!		Fix the dispatching so that if an error occurs, processing
!		of the item list is not aborted.  However, only items that
!		do not alter the ACL are processed.
!
!	V03-015	ACG0417		Andrew C. Goldstein,	18-Apr-1984  11:50
!		Fix probing and lock access mode problems
!
!	V03-014	ACG0415		Andrew C. Goldstein,	30-Mar-1984  17:49
!		Add ACL mutex handling to CHANGE_ACL; add options parsing
!		to default protection ACE; break out ACL processing
!		subroutines into separate common module; mask success
!		and fail flags in audit display; remove IOSB parameter
!		in $CHANGE_ACL; defer unlocking of file ACL until end
!		of operation; find UCB ACL listhead in ORB instead of UCB.
!
!	V03-013	LMP0222		L. Mark Pilant,		27-Mar-1984  14:22
!		Change the tie off symbols, necessary because of linking
!		with XQP module ALLOCB, from locations to offsets.
!
!	V03-012	LMP0213		L. Mark Pilant,		13-Mar-1984  9:53
!		Add support for exclusively locking and unlocking the
!		object for ACL modifications.
!
!	V03-011	LMP0185		L. Mark Pilant,		2-Feb-1984  16:25
!		Add support for device ACLs.  Also, improve the error
!		handling considerably through judicious use of PROBing.
!
!	V03-010	LMP0179		L. Mark Pilant,		8-Dec-1983  15:46
!		Add a new routine SYS$CHANGE_ACL, for changing the ACL
!		associated with an object.
!
!	V03-009	LMP0174		L. Mark Pilant,		2-Dec-1983  9:58
!		Add support for RMS journal-ID ACEs.
!
!	V03-008	LMP0170		L. Mark Pilant,		1-Dec-1983  16:43
!		Add support for the NOPROPAGATE flag.
!
!	V03-007	LMP0152		L. Mark Pilant,		12-Sep-1983  15:13
!		Make SECURITY the journal name for AUDIT and ALARM ACEs.
!
!	V03-006	LMP0140		L. Mark Pilant,		23-Aug-1983  20:21
!		Add support for alphanumeric UICs.
!
!	V03-005	LMP0135		L. Mark Pilant,		8-Aug-1983  11:03
!		Change the parsing and formatting of directory default
!		ACEs slightly.
!
!	V03-004	LMP0123		L. Mark Pilant,		22-Jun-1983  10:36
!		Change the name of the FLAGS field to OPTIONS.
!
!	V03-003	LMP0122		L. Mark Pilant,		20-Jun-1983  9:14
!		Add support for a directory default protection ACE.
!
!	V03-002	LMP0114		L. Mark Pilant,		11-May-1983  10:42
!		Add support for an access bitmask name table.
!
!	V03-001	LMP0103		L. Mark Pilant,		24-Apr-1983  19:14
!		Add support for HIDDEN and PROTECTED ACEs.
!
!**

LIBRARY 'SYS$LIBRARY:LIB.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';

! Declare necessary builtin functions.

BUILTIN
	TESTBITSC,
	INSQUE,
	MOVPSL,
	MTPR,
	PROBER,
	PROBEW,
	REMQUE;

LINKAGE
	L_PROBE		= JSB (REGISTER = 3, REGISTER = 1, REGISTER = 0)
			: NOPRESERVE (2)
			  NOTUSED (4, 5, 6, 7, 8, 9, 10, 11),

	L_VERIFY	= JSB (REGISTER = 0; REGISTER = 1)
			: NOPRESERVE (2, 3)
			  NOTUSED (4, 5, 6, 7, 8, 9, 10, 11),

	L_MUTEX		= JSB (REGISTER = 0, REGISTER = 4)
			: NOTUSED (5, 6, 7, 8, 9, 10, 11);

FORWARD ROUTINE
	SYS$PARSE_ACL,				! Convert ACE to binary
	SYS$FORMAT_ACL,				! Convert ACE to text
	SYS$CHANGE_ACL,				! Change an object's ACL
	GET_PARENT_LOCK,			! Take out parent for ACL locks

! TPARSE action routine

	SET_ID,					! Save a converted identifier
	SET_ACCESS_BIT,				! Set desired access bit by name

! ACL queue head locating routines.

	GET_UCB_ACL,				! For UCBs
	GET_JBC_ACL,				! For Job controller queue
	GET_CEB_ACL,				! For CEBs
	GET_LNT_ACL,				! For logical name tables
	GET_PCB_ACL,				! For processes
	GET_GBL_ACL,				! For global sections

! ACL action routines.

	ACL_DISPATCH,				! Main ACL function dispatcher
	RUNDOWN_CHANGE_ACL;			! Clean up $CHANGE_ACL context

EXTERNAL ROUTINE
	ACL_ADDENTRY,				! Add an ACE
	ACL_DELENTRY,				! Delete an ACE
	ACL_MODENTRY,				! Modify an ACE
	ACL_FINDENTRY,				! Locate a specific ACE
	ACL_FINDTYPE,				! Locate a specific ACE type
	ACL_DELETEACL,				! Delete the entire ACL
	ACL_READACL,				! Read the ACL
	ACL_ACLLENGTH,				! Get the ACL's length
	ACL_READACE,				! Read a single ACE
	ACL_LOCATEACE,				! Locate ACE by context
	ACL_INIT_QUEUE,				! Initialize the ACL queue
	ALLOC_PAGED,				! Paged pool allocator
	DALLOC_PAGED,				! Paged pool deallocator
	LIB$TPARSE,				! General purpose parser
	LIB$FID_TO_NAME,			! FID to file-spec translator
	LIB$GET_VM,				! General memory allocater
	LIB$FREE_VM,				! General memory deallocater
	EXE$PROBER	: L_PROBE ADDRESSING_MODE (GENERAL),
						! Probe buffer for read
	EXE$PROBEW	: L_PROBE ADDRESSING_MODE (GENERAL),
						! Probe buffer for write
	IOC$VERIFYCHAN	: L_VERIFY ADDRESSING_MODE (GENERAL),
						! Verify channel number
	SCH$LOCKR	: L_MUTEX ADDRESSING_MODE (GENERAL),
						! Lock mutex for read
	SCH$LOCKW	: L_MUTEX ADDRESSING_MODE (GENERAL),
						! Lock mutex for write
	SCH$UNLOCK	: L_MUTEX ADDRESSING_MODE (GENERAL);
						! Unlock mutex

EXTERNAL
	CTL$GL_PCB	: REF $BBLOCK;		! Address of process PCB

MACRO
	ARG_COUNT =
		BEGIN
		BUILTIN AP;
		.(.AP)<0,8>
		END
		%,

	SET_IPL (LEVEL) =
		BEGIN
		BUILTIN	MTPR;
		MTPR (%REF (LEVEL), PR$_IPL)
		END
		%;

LITERAL
	ACL_TYPE	= 7,			! Must parallel [F11X.SRC]FCPDEF.B32
	MAX_ACL_SIZE	= 512;			! Max size of an ACL segment

LITERAL
	MIN_OBJECT_TYPE	= MINU (ACL$C_FILE,
				ACL$C_DEVICE,
				ACL$C_JOBCTL_QUEUE,
				ACL$C_COMMON_EF_CLUSTER,
				ACL$C_LOGICAL_NAME_TABLE,
				ACL$C_PROCESS,
				ACL$C_GLOBAL_SECTION),

	MAX_OBJECT_TYPE	= MAXU (ACL$C_FILE,
				ACL$C_DEVICE,
				ACL$C_JOBCTL_QUEUE,
				ACL$C_COMMON_EF_CLUSTER,
				ACL$C_LOGICAL_NAME_TABLE,
				ACL$C_PROCESS,
				ACL$C_GLOBAL_SECTION),

	MIN_ACL_ATR	= MINU (ACL$C_ADDACLENT,
				ACL$C_DELACLENT,
				ACL$C_MODACLENT,
				ACL$C_FNDACLENT,
				ACL$C_FNDACETYP,
				ACL$C_DELETEACL,
				ACL$C_READACL,
				ACL$C_ACLLENGTH,
				ACL$C_READACE,
				ACL$C_RLOCK_ACL,
				ACL$C_WLOCK_ACL,
				ACL$C_UNLOCK_ACL),

	MAX_ACL_ATR	= MAXU (ACL$C_ADDACLENT,
				ACL$C_DELACLENT,
				ACL$C_MODACLENT,
				ACL$C_FNDACLENT,
				ACL$C_FNDACETYP,
				ACL$C_DELETEACL,
				ACL$C_READACL,
				ACL$C_ACLLENGTH,
				ACL$C_READACE,
				ACL$C_RLOCK_ACL,
				ACL$C_WLOCK_ACL,
				ACL$C_UNLOCK_ACL);

OWN
	JOURNAL_ACES	: BYTE INITIAL (0),	! Journaling ACEs allowed
						! 0 = no support
						! 1 = support in
	ACE_BUFFER	: $BBLOCK [ATR$S_READACL],	! Storage for binary ACE
	ACE_INDEX,				! Index into ACE key area
	ACE_TYPE,				! ACE type code
	ACE_RIGHTS,				! ACE access rights
	UIC_FLAGS,				! UIC conversion flags
	UIC_COUNT,				! Number of UIC id's entered
	IDENTIFIER	: $BBLOCK [4],		! Converted identifier
	ID_NAME		: $BBLOCK [DSC$C_S_BLN],	! ID name descriptor
	ID_COUNT,				! Number of identifiers given
	JOURNAL_NAME	: $BBLOCK [DSC$C_S_BLN],	! Journal name descr
	ACCESS_FLAGS,				! Audit access flags
	SYSTEM_PROT	: $BBLOCK [4],		! System protection default
	OWNER_PROT	: $BBLOCK [4],		! Owner protection default
	GROUP_PROT	: $BBLOCK [4],		! Group protection default
	WORLD_PROT	: $BBLOCK [4],		! World protection default
	BIT_NAME_TABLE	: REF BLOCKVECTOR [,DSC$C_S_BLN,BYTE],	! Access bit name table addr
	CHANGE_ACMODE,				! Access mode for $CHANGE_ACL
	CALL_ACMODE,				! Access mode of caller
	PARENT_ID,				! Parent ID for ACL locks
	ACL_QUEUE_HEAD	: REF $BBLOCK,		! Address of the ACL queue head
	ACL_POINTER	: REF $BBLOCK,		! Address of current segment
	ACL_SPLIT,				! Offset to ACE in segment
	ACE_POINTER	: REF $BBLOCK,		! Address of current ACE
	ACE_NUMBER,				! Numeric position of ACE in ACL
	ACL_AREA	: $BBLOCK [MAX_ACL_SIZE],	! Temp storage for ACL segment
	ACL_CONTEXT,				! Context used in $CHANGE_ACL
	LOCK_RESNAM	: $BBLOCK [DSC$C_S_BLN],	! Lock resouce name desc
	RESNAM_TEXT	: $BBLOCK [31];		! Actual resource name

! Macro defining the subfields used within the resource name field.

MACRO
	RSN_T_PREFIX	=  0,  0,  0,  0 %,	! Lock name prefix
	RSN_T_DEVNAM	=  8,  0,  0,  0 %,	! Device name for device and
						!  file type objects
	RSN_L_FID	= 24,  0, 32,  0 %,	! File-id for lock
	RSN_W_FID_NUM	= 24,  0, 16,  0 %,	! File number
	RSN_W_FID_SEQ	= 26,  0, 16,  0 %;	! File sequence number

LITERAL
	RSN_S_PREFIX	= 8,			! Size of lock name prefix
	RSN_S_DEVNAM	= 16;			! Size of device name

! Assumptions made about various fields used.

! The following assumptions should track the definitions in
!	[RMS.SRC]RMSFILSTR.SDL module RJRDEF and
!	[VMSLIB.SRC]STARDEFAE.SDL module ACEDEF

$ASSUME (RJR$S_JNLID EQL 28);
$ASSUME ($BYTEOFFSET (RJR$T_VOLNAM) EQL 8);
$ASSUME ($BYTEOFFSET (RJR$T_FID) EQL 20);
$ASSUME ($BYTEOFFSET (RJR$Q_ID_DATE) EQL 28);

! Define the default bit names.

BIND
	DEFAULT_BITS	= UPLIT (
				$DESCRIPTOR ('READ'),
				$DESCRIPTOR ('WRITE'),
				$DESCRIPTOR ('EXECUTE'),
				$DESCRIPTOR ('DELETE'),
				$DESCRIPTOR ('CONTROL'),
				$DESCRIPTOR ('BIT_5'),
				$DESCRIPTOR ('BIT_6'),
				$DESCRIPTOR ('BIT_7'),
				$DESCRIPTOR ('BIT_8'),
				$DESCRIPTOR ('BIT_9'),
				$DESCRIPTOR ('BIT_10'),
				$DESCRIPTOR ('BIT_11'),
				$DESCRIPTOR ('BIT_12'),
				$DESCRIPTOR ('BIT_13'),
				$DESCRIPTOR ('BIT_14'),
				$DESCRIPTOR ('BIT_15'),
				$DESCRIPTOR ('BIT_16'),
				$DESCRIPTOR ('BIT_17'),
				$DESCRIPTOR ('BIT_18'),
				$DESCRIPTOR ('BIT_19'),
				$DESCRIPTOR ('BIT_20'),
				$DESCRIPTOR ('BIT_21'),
				$DESCRIPTOR ('BIT_22'),
				$DESCRIPTOR ('BIT_23'),
				$DESCRIPTOR ('BIT_24'),
				$DESCRIPTOR ('BIT_25'),
				$DESCRIPTOR ('BIT_26'),
				$DESCRIPTOR ('BIT_27'),
				$DESCRIPTOR ('BIT_28'),
				$DESCRIPTOR ('BIT_29'),
				$DESCRIPTOR ('BIT_30'),
				$DESCRIPTOR ('BIT_31')
				) : VECTOR,

	LOCK_PREFIX	= UPLIT (
				$DESCRIPTOR ('ACL$LOCK'),
				$DESCRIPTOR ('ACL$FIL_'),
				$DESCRIPTOR ('ACL$DEV_'),
				$DESCRIPTOR ('ACL$JBC_'),
				$DESCRIPTOR ('ACL$CEF_'),
				$DESCRIPTOR ('ACL$LNT_'),
				$DESCRIPTOR ('ACL$PRC_'),
				$DESCRIPTOR ('ACL$GBL_')
				) : VECTOR;

%SBTTL	'TPARSE tables for $PARSE_ACL'
! TPARSE tables to parse an Access Control List (ACL) entry.

$INIT_STATE	(ACE_STATE, ACE_KEY);

! Determine the type of ACE

$STATE	(,
	('(')
	);

$STATE	(GET_KEYWORD,
	('IDENTIFIER',GET_ID,,ACE$C_KEYID,ACE_TYPE),
	('BI_JOURNAL_NAME',GET_JNL,,ACE$C_BIJNL,ACE_TYPE),
	('AI_JOURNAL_NAME',GET_JNL,,ACE$C_AIJNL,ACE_TYPE),
	('AT_JOURNAL_NAME',GET_JNL,,ACE$C_ATJNL,ACE_TYPE),
	('AUDIT_JOURNAL',GET_AUDIT,,ACE$C_AUDIT,ACE_TYPE),
	('ALARM_JOURNAL',GET_ALARM,,ACE$C_ALARM,ACE_TYPE),
	('ACCESS',GET_ACCESS),
	('OPTIONS',GET_FLAGS),
	('DEFAULT_PROTECTION',GET_PROT,,ACE$C_DIRDEF,ACE_TYPE)
	);
$STATE	(,
	(',',GET_KEYWORD),
	(')',CHK_FOR_END)
	);

! Access Control Entry.

$STATE	(GET_ID,
	('='),
	(':')
	);
$STATE	(GET_IDTYPE,
	(TPA$_IDENT,,,,IDENTIFIER)
	);

! Check for the end of the identifier.

$STATE	(CHK_ENDID,
	(',',GET_KEYWORD,SET_ID),
	('+',GET_IDTYPE,SET_ID),
	(')',CHK_FOR_END,SET_ID)
	);

! RMS Journal name

$STATE	(GET_JNL,
	('='),
	(':')
	);
$STATE	(,
	((GET_STRING),,,,JOURNAL_NAME)
	);

! Check for the end of the journal name.

$STATE	(,
	(')',CHK_FOR_END)
	);

! File access audit.

$STATE	(GET_AUDIT,
	('='),
	(':')
	);
$STATE	(,
	((GET_STRING),,,,JOURNAL_NAME)
	);

! Check to see if there is an access type to follow

$STATE	(,
	(',',GET_KEYWORD),
	(')',CHK_FOR_END)
	);

! File access alarm

$STATE	(GET_ALARM,
	('='),
	(':')
	);
$STATE	(,
	((GET_STRING),,,,JOURNAL_NAME)
	);

! Check to see if there is an access type to follow

$STATE	(,
	(',',GET_KEYWORD),
	(')',CHK_FOR_END)
	);

! Get the access type code

$STATE	(GET_ACCESS,
	('='),
	(':')
	);
$STATE	(GET_ACCTYPE,
	('SUCCESS',,,ACE$M_SUCCESS,ACCESS_FLAGS),
	('FAILURE',,,ACE$M_FAILURE,ACCESS_FLAGS),
	('NONE'),
	((GET_STRING),,SET_ACCESS_BIT)
	);
$STATE	(,
	('+',GET_ACCTYPE),
	(')',CHK_FOR_END),
	(',',GET_KEYWORD)
	);

! Get any special flags applied to the ACE.

$STATE	(GET_FLAGS,
	('='),
	(':')
	);
$STATE	(GET_FLAGTYPE,
	('DEFAULT',,,ACE$M_DEFAULT,ACE_BUFFER[ACE$W_FLAGS]),
	('HIDDEN',,,ACE$M_HIDDEN,ACE_BUFFER[ACE$W_FLAGS]),
	('PROTECTED',,,ACE$M_PROTECTED,ACE_BUFFER[ACE$W_FLAGS]),
	('NOPROPAGATE',,,ACE$M_NOPROPAGATE,ACE_BUFFER[ACE$W_FLAGS]),
	('NONE')
	);
$STATE	(,
	('+',GET_FLAGTYPE),
	(')',CHK_FOR_END),
	(',',GET_KEYWORD)
	);

! Get the directory default protection.

$STATE	(GET_PROT,
	(',')
	);
$STATE	(GET_PROT_CLASS,
	('SYSTEM',GET_SYS_PRO),
	('OWNER',GET_OWN_PRO),
	('GROUP',GET_GRP_PRO),
	('WORLD',GET_WOR_PRO),
	(TPA$_LAMBDA,GET_KEYWORD)
	);
$STATE	(GET_SYS_PRO,
	(':'),
	('='),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_SYS_PRO1,
	('R',GET_SYS_PRO1,,ARM$M_READ,SYSTEM_PROT),
	('W',GET_SYS_PRO1,,ARM$M_WRITE,SYSTEM_PROT),
	('E',GET_SYS_PRO1,,ARM$M_EXECUTE,SYSTEM_PROT),
	('D',GET_SYS_PRO1,,ARM$M_DELETE,SYSTEM_PROT),
	('C',GET_SYS_PRO1,,ARM$M_CONTROL,SYSTEM_PROT),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_OWN_PRO,
	(':'),
	('='),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_OWN_PRO1,
	('R',GET_OWN_PRO1,,ARM$M_READ,OWNER_PROT),
	('W',GET_OWN_PRO1,,ARM$M_WRITE,OWNER_PROT),
	('E',GET_OWN_PRO1,,ARM$M_EXECUTE,OWNER_PROT),
	('D',GET_OWN_PRO1,,ARM$M_DELETE,OWNER_PROT),
	('C',GET_OWN_PRO1,,ARM$M_CONTROL,OWNER_PROT),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_GRP_PRO,
	(':'),
	('='),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_GRP_PRO1,
	('R',GET_GRP_PRO1,,ARM$M_READ,GROUP_PROT),
	('W',GET_GRP_PRO1,,ARM$M_WRITE,GROUP_PROT),
	('E',GET_GRP_PRO1,,ARM$M_EXECUTE,GROUP_PROT),
	('D',GET_GRP_PRO1,,ARM$M_DELETE,GROUP_PROT),
	('C',GET_GRP_PRO1,,ARM$M_CONTROL,GROUP_PROT),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_WOR_PRO,
	(':'),
	('='),
	(TPA$_LAMBDA,CHK_END_PRO)
	);
$STATE	(GET_WOR_PRO1,
	('R',GET_WOR_PRO1,,ARM$M_READ,WORLD_PROT),
	('W',GET_WOR_PRO1,,ARM$M_WRITE,WORLD_PROT),
	('E',GET_WOR_PRO1,,ARM$M_EXECUTE,WORLD_PROT),
	('D',GET_WOR_PRO1,,ARM$M_DELETE,WORLD_PROT),
	('C',GET_WOR_PRO1,,ARM$M_CONTROL,WORLD_PROT),
	(TPA$_LAMBDA,CHK_END_PRO)
	);

$STATE	(CHK_END_PRO,
	(',',GET_PROT_CLASS),
	(')',CHK_FOR_END)
	);

! Parse off a random string.

$STATE	(GET_STRING,
	(',',TPA$_FAIL),
	(')',TPA$_FAIL),
	(TPA$_EOS,TPA$_FAIL),
	((GET_STRING1))
	);
$STATE	(GET_STRING1,
	((CHK_DELIM),GET_STRING1),
	(TPA$_LAMBDA,TPA$_EXIT)
	);
$STATE	(CHK_DELIM,
	('+',TPA$_FAIL),
	(',',TPA$_FAIL),
	(')',TPA$_FAIL),
	(TPA$_EOS,TPA$_FAIL),
	(TPA$_ANY,TPA$_EXIT)
	);

! Check for the end of the ACE.  Trailing blanks are allowed.

$STATE	(CHK_FOR_END,
	(TPA$_EOS,TPA$_EXIT),
	);

%SBTTL	'$PARSE_ACL system service'
GLOBAL ROUTINE SYS$PARSE_ACL (ACL_STRING, ACL_ENTRY, ERROR_POSITION, BIT_TABLE) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts the Access Control Entry from a text form to
!	the binary form.
!
! CALLING SEQUENCE:
!	SYS$PARSE_ACL (ARG1, ARG2, ARG3, ARG4)
!
! INPUT PARAMETERS:
!	ARG1: address of the input text descriptor
!	ARG2: address of the output buffer descriptor
!	ARG4: address of an access bit name table
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	ARG3: number of characters processed
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	SS$_NORMAL:	The conversion was successful.
!	SS$_ACCVIO:	The input or output descrtptors cannot be read, the
!			output buffer cannot be written, or the output buffer
!			is not large enough to contain the converted ACE.
!	SS$_IVACL:	The syntax of the input ACE is invalid.
!	SS$_NOSUCHID:	The identifier specified in the ACE is not in the
!			rights database.
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	ACL_STRING	: REF $BBLOCK,		! Address of input descriptor
	ACL_ENTRY	: REF $BBLOCK,		! Address of output descriptor
	ERROR_POSITION	: REF VECTOR [,WORD],	! Syntax error position
	BIT_TABLE	: REF VECTOR;		! Address of access bit ame tale

LOCAL
	STATUS,					! Routine exit status
	ACL_STRING_LEN,				! Length of input ACL string
	ACL_ENTRY_LEN,				! Length of output ACE buffer
	TPARSE_BLOCK	: $BBLOCK [TPA$K_LENGTH0];	! Parser context block

EXTERNAL LITERAL
	LIB$_SYNTAXERR;

! Check to see if an access bit name table was supplied.  If so, use it
! rather than the default table.

BIT_NAME_TABLE = 0;
IF .BIT_TABLE NEQA 0
THEN IF PROBER (%REF (0), %REF (256), .BIT_TABLE)
     THEN BIT_NAME_TABLE = .BIT_TABLE
     ELSE RETURN SS$_ACCVIO;

! Set up initial parameters.

CH$FILL (0, ATR$S_READACL, ACE_BUFFER);
ACE_INDEX = ACE_TYPE = ACE_RIGHTS = 0;
UIC_FLAGS = UIC_COUNT = 0;
ID_COUNT = 0;
ACCESS_FLAGS = 0;
JOURNAL_NAME[DSC$W_LENGTH] = ID_NAME[DSC$W_LENGTH] = 0;
SYSTEM_PROT = OWNER_PROT = GROUP_PROT = WORLD_PROT = 0;

CH$FILL (0, TPA$K_LENGTH0, TPARSE_BLOCK);
TPARSE_BLOCK[TPA$L_COUNT] = TPA$K_COUNT0;
TPARSE_BLOCK[TPA$V_ABBREV] = 1;
IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .ACL_STRING)
THEN
    BEGIN
    ACL_STRING_LEN = TPARSE_BLOCK[TPA$L_STRINGCNT] = .ACL_STRING[DSC$W_LENGTH];
    IF EXE$PROBER (0, .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
    THEN TPARSE_BLOCK[TPA$L_STRINGPTR] = .ACL_STRING[DSC$A_POINTER]
    ELSE RETURN SS$_ACCVIO;
    END
ELSE RETURN SS$_ACCVIO;

STATUS = LIB$TPARSE (TPARSE_BLOCK, ACE_STATE, ACE_KEY);

! If necessary set the number of characters processed.

IF .ERROR_POSITION NEQA 0
THEN IF PROBEW (%REF (0), %REF (2), .ERROR_POSITION)
     THEN ERROR_POSITION[0] = .ACL_STRING_LEN -
			      .TPARSE_BLOCK[TPA$L_STRINGCNT]
     ELSE RETURN SS$_ACCVIO;

! If there 1) are any syntax errors, 2) is an invalid ACE type (zero),
! or 3) is remaining text to the ACE; return an error.

IF .STATUS EQL LIB$_SYNTAXERR
OR .ACE_TYPE EQL 0
OR (.STATUS AND .TPARSE_BLOCK[TPA$L_STRINGCNT] GTR 0)
THEN RETURN SS$_IVACL;

IF NOT .STATUS THEN RETURN .STATUS;

! Set up the standard ACE fields.

ACE_BUFFER[ACE$B_TYPE] = .ACE_TYPE;
ACE_BUFFER[ACE$W_FLAGS] = .ACE_BUFFER[ACE$W_FLAGS]
			  OR .UIC_FLAGS
			  OR .ACCESS_FLAGS;
ACE_BUFFER[ACE$L_ACCESS] = .ACE_RIGHTS;

! Based upon the type code, finish up the ACE.  Then do the final error
! checking to make sure that I didn't get more than I wanted.

CASE .ACE_TYPE FROM ACE$C_KEYID TO ACE$C_DIRDEF OF
SET
    [ACE$C_KEYID]:
	BEGIN
	IF .ACCESS_FLAGS NEQ 0
	OR .JOURNAL_NAME[DSC$W_LENGTH] NEQ 0
	OR .UIC_COUNT GTR 1
	OR .ACE_INDEX EQL 0
	THEN RETURN SS$_IVACL;
	ACE_BUFFER[ACE$B_SIZE] = ACE$C_LENGTH + .ACE_INDEX * 4;
	END;
    [ACE$C_BIJNL,
     ACE$C_AIJNL,
     ACE$C_ATJNL]:
	BEGIN
	IF NOT .JOURNAL_ACES THEN RETURN SS$_IVACL;
	IF .UIC_COUNT NEQ 0
	OR .ID_COUNT NEQ 0
	OR .ACCESS_FLAGS NEQ 0
	OR .ACE_RIGHTS NEQ 0
	THEN RETURN SS$_IVACL;
	CH$MOVE (.JOURNAL_NAME[DSC$W_LENGTH],
		 .JOURNAL_NAME[DSC$A_POINTER],
		 ACE_BUFFER[ACE$L_ACCESS]);
	ACE_BUFFER[ACE$B_SIZE] = .JOURNAL_NAME[DSC$W_LENGTH] +
				 $BYTEOFFSET (ACE$L_ACCESS);
	END;
    [ACE$C_AUDIT,
     ACE$C_ALARM]:
	BEGIN
	IF .UIC_COUNT NEQ 0
	OR .ID_COUNT NEQ 0
	OR .JOURNAL_NAME[DSC$W_LENGTH] NEQ %CHARCOUNT ('SECURITY')
	OR CH$NEQ (%CHARCOUNT ('SECURITY'), UPLIT ('SECURITY'),
		   .JOURNAL_NAME[DSC$W_LENGTH], .JOURNAL_NAME[DSC$A_POINTER], 0)
	THEN RETURN SS$_IVACL;
	CH$MOVE (.JOURNAL_NAME[DSC$W_LENGTH],
		 .JOURNAL_NAME[DSC$A_POINTER],
		 ACE_BUFFER[ACE$L_KEY]);
	ACE_BUFFER[ACE$B_SIZE] = ACE$C_LENGTH + .JOURNAL_NAME[DSC$W_LENGTH];
	END;
    [ACE$C_DIRDEF]:
	BEGIN
	IF .ACCESS_FLAGS NEQ 0
	OR .JOURNAL_NAME[DSC$W_LENGTH] NEQ 0
	OR .UIC_COUNT NEQ 0
	OR .ID_COUNT NEQ 0
	THEN RETURN SS$_IVACL;
	SYSTEM_PROT = NOT .SYSTEM_PROT;
	SYSTEM_PROT[ARM$V_FILL] = 0;
	ACE_BUFFER[ACE$L_SYS_PROT] = .SYSTEM_PROT;
	OWNER_PROT = NOT .OWNER_PROT;
	OWNER_PROT[ARM$V_FILL] = 0;
	ACE_BUFFER[ACE$L_OWN_PROT] = .OWNER_PROT;
	GROUP_PROT = NOT .GROUP_PROT;
	GROUP_PROT[ARM$V_FILL] = 0;
	ACE_BUFFER[ACE$L_GRP_PROT] = .GROUP_PROT;
	WORLD_PROT = NOT .WORLD_PROT;
	WORLD_PROT[ARM$V_FILL] = 0;
	ACE_BUFFER[ACE$L_WOR_PROT] = .WORLD_PROT;
	ACE_BUFFER[ACE$B_SIZE] = ACE$C_LENGTH + 16;
	END;
    [INRANGE,
     OUTRANGE]:	RETURN SS$_IVACL;
TES;

! Check to make sure there is room to receive the ACE.

IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .ACL_ENTRY)
THEN
    BEGIN
    ACL_ENTRY_LEN = .ACL_ENTRY[DSC$W_LENGTH];
    IF .ACE_BUFFER[ACE$B_SIZE] LEQU .ACL_ENTRY_LEN
    AND EXE$PROBEW (0, .ACL_ENTRY_LEN, .ACL_ENTRY[DSC$A_POINTER])
    THEN CH$COPY (.ACE_BUFFER[ACE$B_SIZE], ACE_BUFFER, 0,
		  .ACL_ENTRY[DSC$W_LENGTH], .ACL_ENTRY[DSC$A_POINTER])
    ELSE RETURN SS$_ACCVIO;
    END
ELSE RETURN SS$_ACCVIO;

RETURN SS$_NORMAL;

END;						! End of routine SYS$PARSE_ACL

%SBTTL	'$FORMAT_ACL system service'
GLOBAL ROUTINE SYS$FORMAT_ACL (ACL_ENTRY, ACL_LENGTH, ACL_STRING,
			       LINE_WIDTH, TERM_DESC, LINE_INDENT,
			       BIT_TABLE) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts the Access Control Entry from a binary form
!	to a text form.
!
! CALLING SEQUENCE:
!	SYS$FORMAT_ACL (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
!
! INPUT PARAMETERS:
!	ARG1: address of the input buffer descriptor
!	ARG4: address of the maximum line width for formatting
!	ARG5: address of the output line segment terminator descriptor
!	ARG6: address of the number of columns to indent each line segment
!	ARG7: address of an access bit name table
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	ARG2: address of a word to get the length of the formatted ACE
!	ARG3: address of the output text buffer descriptor
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	SS$_NORMAL:	The conversion was successful.
!	SS$_NOSUCHID:	The identifier specified in the ACE is not in the
!			rights database.
!	SS$_BUFFEROVF:	The conversion was successful.  The formatted ACE
!			has overflowed the output buffer and has been
!			truncated.
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MACRO	CHECK_WIDTH (TEST_WIDTH) =
		BEGIN
		IF .WIDTH GTRU 0
		AND .LINE_SIZE + TEST_WIDTH GTRU .WIDTH
		THEN
		    BEGIN
		    IF .TERM_LENGTH GTR 0
		    THEN
			BEGIN
			CH$MOVE (.TERM_LENGTH, .TERM_POINTER, BUFFER[.SIZE]);
			SIZE = .SIZE + .TERM_DESC[DSC$W_LENGTH];
			END;
		    CH$FILL (%C' ', .INDENT, BUFFER[.SIZE]);
		    SIZE = .SIZE + .INDENT;
		    LINE_SIZE = .INDENT;
		    END;
		LINE_SIZE = .LINE_SIZE + TEST_WIDTH;
		END
		%,

	STORE_TEXT (STRING) =
		BEGIN
		CHECK_WIDTH (%CHARCOUNT (STRING));
		CH$MOVE (%CHARCOUNT (STRING), UPLIT (STRING), BUFFER[.SIZE]);
		SIZE = .SIZE + %CHARCOUNT (STRING);
		END
		%,

	NEW_LINE =
		BEGIN
		IF .TERM_LENGTH GTR 0
		THEN
		    BEGIN
		    CH$MOVE (.TERM_LENGTH, .TERM_POINTER, BUFFER[.SIZE]);
		    SIZE = .SIZE + .TERM_LENGTH;
		    END;
		CH$FILL (%C' ', .INDENT, BUFFER[.SIZE]);
		SIZE = .SIZE + .INDENT;
		LINE_SIZE = .INDENT;
		END
		%;

MAP
	ACL_ENTRY	: REF $BBLOCK,		! Address of the input descriptor
	ACL_STRING	: REF $BBLOCK,		! Address of the output descriptor
	TERM_DESC	: REF $BBLOCK;		! Segment terminator descriptor

LITERAL
	MAX_FAO_LENGTH	= MAXU (2 * KGB$S_NAME + 3,	! Max size of
				ATR$S_FILE_SPEC),	!   FAO buffer
	MAX_FMT_ACE	= 3072,			! Largest possible formatted ACE
	VOLNAM_SIZE	= %CHARCOUNT ('DISK$') + ACE$S_VOLNAM + 1;
						! Size of full volume name

LOCAL
	ACL_ENTRY_LEN,				! Length of input ACE buffer
	LOCAL_ACE	: $BBLOCK [ATR$S_ADDACLENT],	! Local copy of ACE
	FAO_DESCR	: $BBLOCK [DSC$C_S_BLN],	! FAO output descriptor
	KEY_IDENTIFIER	: $BBLOCK [4],		! Key identifier
	PROT_VALUE,				! Protection value from ACE
	PROT_FIELD_DSC	: REF $BBLOCK,		! Addr of protection field name
	PROT_BUF	: VECTOR [32,BYTE],	! Storage for ASCII protection string
	PROT_IDX,				! Index into protection string
	BUFFER		: VECTOR [MAX_FMT_ACE, BYTE],
						! Temp storage for formatted ACE
	LINE_SIZE,				! Size of the current segment
	SIZE,					! Size of formatted ACE
	INDENT,					! Number of columns to indent
	WIDTH,					! Width of the line
	TERM_LENGTH,				! Size of terminator string
	TERM_POINTER,				! Address of terminator string
	FAO_DESC	: $BBLOCK [DSC$C_S_BLN],	! FAO output descriptor
	FAO_BUF		: VECTOR [MAX_FAO_LENGTH,BYTE],	! FAO output buffer
	BIT_NAME_DESC	: REF $BBLOCK,		! Descr for access bit name
	FLAGS		: BITVECTOR [16],	! Flags from ACE
	ACCESS_MASK	: BYTE,			! Access mask in ACE
	AUDIT_MASK	: BYTE,			! Audit access mask in ACE
	VOLNAM_DESC	: $BBLOCK [DSC$C_S_BLN],	! Volume name descriptor
	VOLNAM_TEXT	: VECTOR [VOLNAM_SIZE, BYTE],	! Volume name storage
	FILENAME_DESC	: $BBLOCK [DSC$C_S_BLN],	! File name descriptor
	FILENAME_TEXT	: VECTOR [ATR$S_FILE_SPEC],	! File name storage
	ACL_STRING_LEN,				! Length of ACL string buffer
	LOCAL_STATUS;				! Local routine return status

! Protection code names.

BIND
	PROT_CODE	= UPLIT BYTE ('R', 'W', 'E', 'D', 'C',
				      REP 27 OF (0)) : VECTOR [, BYTE];

! Probe the output string buffer.

IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .ACL_STRING)
THEN
    BEGIN
    ACL_STRING_LEN = .ACL_STRING[DSC$W_LENGTH];
    IF EXE$PROBEW (0, .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
    THEN CH$FILL (%C' ', .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
    ELSE RETURN SS$_ACCVIO;
    END
ELSE RETURN SS$_ACCVIO;

! Set up initial parameters.

INDENT = WIDTH = 0;
TERM_LENGTH = TERM_POINTER = 0;
ACCESS_MASK = AUDIT_MASK = 0;

! Check the optional arguments.

IF .LINE_WIDTH NEQA 0
THEN IF PROBER (%REF (0), %REF (4), .LINE_WIDTH)
     THEN WIDTH = ..LINE_WIDTH
     ELSE RETURN SS$_ACCVIO;

IF .TERM_DESC NEQA 0
THEN
    BEGIN
    IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .TERM_DESC)
    THEN
	BEGIN
	TERM_LENGTH = .TERM_DESC[DSC$W_LENGTH];
	TERM_POINTER = .TERM_DESC[DSC$A_POINTER];
	IF NOT EXE$PROBER (0, .TERM_LENGTH, .TERM_POINTER)
	THEN RETURN SS$_ACCVIO;
	END
    ELSE RETURN SS$_ACCVIO;
    END;

IF .LINE_INDENT NEQA 0
THEN IF PROBER (%REF (0), %REF (4), .LINE_INDENT)
     THEN INDENT = ..LINE_INDENT
     ELSE RETURN SS$_ACCVIO;

IF .INDENT GTRU 0
THEN
    BEGIN
    IF .WIDTH GTR 0
    THEN (IF .INDENT GTRU .WIDTH THEN RETURN SS$_BADPARAM)
    ELSE (IF .INDENT GTRU .ACL_STRING_LEN THEN RETURN SS$_BUFFEROVF);
    IF .INDENT GTRU MAX_FMT_ACE THEN RETURN SS$_BUFFEROVF;
    END;


! Check to see if an access bit name table was supplied.  If so, use it
! rather than the default table.

BIT_NAME_TABLE = 0;
IF .BIT_TABLE NEQA 0
THEN IF PROBER (%REF (0), %REF (256), .BIT_TABLE)
     THEN BIT_NAME_TABLE = .BIT_TABLE
     ELSE RETURN SS$_ACCVIO;

! Start building the text ACE.

CH$FILL (%C' ', .INDENT, BUFFER);
SIZE = LINE_SIZE = .INDENT;
STORE_TEXT ('(');
IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .ACL_ENTRY)
THEN
    BEGIN
    ACL_ENTRY_LEN = .ACL_ENTRY[DSC$W_LENGTH];
    IF .ACL_ENTRY_LEN GTRU ATR$S_ADDACLENT THEN RETURN SS$_IVACL;
    IF EXE$PROBER (0, .ACL_ENTRY_LEN, .ACL_ENTRY[DSC$A_POINTER])
    THEN CH$MOVE (.ACL_ENTRY_LEN, .ACL_ENTRY[DSC$A_POINTER], LOCAL_ACE)
    ELSE RETURN SS$_ACCVIO;
    END
ELSE RETURN SS$_ACCVIO;

! Convert the ACE type code.

CASE .LOCAL_ACE[ACE$B_TYPE] FROM ACE$C_KEYID TO ACE$C_DIRDEF OF
SET
    [ACE$C_KEYID]:
	BEGIN
	ACCESS_MASK = 1;
	STORE_TEXT ('IDENTIFIER=');
	INCR J FROM .LOCAL_ACE[ACE$V_RESERVED] + 1 TO (.LOCAL_ACE[ACE$B_SIZE] - ACE$C_LENGTH + 3) / 4
	DO
	    BEGIN
	    KEY_IDENTIFIER = .VECTOR [LOCAL_ACE[ACE$L_KEY], .J - 1];
	    FAO_DESC[DSC$W_LENGTH] = MAX_FAO_LENGTH;	! Max size of an identifier
	    FAO_DESC[DSC$A_POINTER] = FAO_BUF;
	    $FAOL (CTRSTR = $DESCRIPTOR ('!%I'),
		   OUTLEN = FAO_DESC,
		   OUTBUF = FAO_DESC,
		   PRMLST = KEY_IDENTIFIER);
	    CHECK_WIDTH (.FAO_DESC[DSC$W_LENGTH]);
	    CH$MOVE (.FAO_DESC[DSC$W_LENGTH],
		     .FAO_DESC[DSC$A_POINTER],
		     BUFFER[.SIZE]);
	    SIZE = .SIZE + .FAO_DESC[DSC$W_LENGTH];
	    STORE_TEXT ('+');
	    END;
	BUFFER[.SIZE - 1] = %C',';
	END;
    [ACE$C_BIJNL,
     ACE$C_AIJNL,
     ACE$C_ATJNL]:
	BEGIN
	IF .LOCAL_ACE[ACE$B_TYPE] EQL ACE$C_BIJNL
	THEN STORE_TEXT ('BI_JOURNAL=');
	IF .LOCAL_ACE[ACE$B_TYPE] EQL ACE$C_AIJNL
	THEN STORE_TEXT ('AI_JOURNAL=');
	IF .LOCAL_ACE[ACE$B_TYPE] EQL ACE$C_ATJNL
	THEN STORE_TEXT ('AT_JOURNAL=');
	CHECK_WIDTH (.LOCAL_ACE[ACE$B_SIZE] - $BYTEOFFSET (ACE$L_ACCESS));
	CH$MOVE (.LOCAL_ACE[ACE$B_SIZE] - $BYTEOFFSET (ACE$L_ACCESS),
		 LOCAL_ACE[ACE$L_ACCESS],
		 BUFFER[.SIZE]);
	SIZE = .SIZE + .LOCAL_ACE[ACE$B_SIZE] - $BYTEOFFSET (ACE$L_ACCESS);
	STORE_TEXT (',');
	END;
    [ACE$C_AUDIT,
     ACE$C_ALARM]:
	BEGIN
	ACCESS_MASK = 1;
	AUDIT_MASK = 1;
	IF .LOCAL_ACE[ACE$B_TYPE] EQL ACE$C_AUDIT
	THEN STORE_TEXT ('AUDIT_JOURNAL=');
	IF .LOCAL_ACE[ACE$B_TYPE] EQL ACE$C_ALARM
	THEN STORE_TEXT ('ALARM_JOURNAL=');
	CHECK_WIDTH (.LOCAL_ACE[ACE$B_SIZE] - ACE$C_LENGTH);
	CH$MOVE (.LOCAL_ACE[ACE$B_SIZE] - ACE$C_LENGTH,
		 LOCAL_ACE[ACE$L_KEY],
		 BUFFER[.SIZE]);
	SIZE = .SIZE + .LOCAL_ACE[ACE$B_SIZE] - ACE$C_LENGTH;
	STORE_TEXT (',');
	END;
    [ACE$C_DIRDEF]:
	BEGIN
	STORE_TEXT ('DEFAULT_PROTECTION,');
	INCR K FROM 0 TO 3
	DO
	    BEGIN
	    CASE .K FROM 0 TO 3 OF
	    SET
		[0]:	BEGIN
			PROT_VALUE = .LOCAL_ACE[ACE$L_SYS_PROT];
			PROT_FIELD_DSC = $DESCRIPTOR ('SYSTEM:');
			END;
		[1]:	BEGIN
			PROT_VALUE = .LOCAL_ACE[ACE$L_OWN_PROT];
			PROT_FIELD_DSC = $DESCRIPTOR ('OWNER:');
			END;
		[2]:	BEGIN
			PROT_VALUE = .LOCAL_ACE[ACE$L_GRP_PROT];
			PROT_FIELD_DSC = $DESCRIPTOR ('GROUP:');
			END;
		[3]:	BEGIN
			PROT_VALUE = .LOCAL_ACE[ACE$L_WOR_PROT];
			PROT_FIELD_DSC = $DESCRIPTOR ('WORLD:');
			END;
	    TES;
	    PROT_IDX = 0;
	    INCR J FROM 0 TO 31
	    DO
		BEGIN
		IF .PROT_CODE[.J] NEQ 0 AND NOT .PROT_VALUE<.J, 1>
		THEN
		    BEGIN
		    PROT_BUF[.PROT_IDX] = .PROT_CODE[.J];
		    PROT_IDX = .PROT_IDX + 1;
		    END;
		END;
	    CHECK_WIDTH (.PROT_FIELD_DSC[DSC$W_LENGTH] + .PROT_IDX);
	    CH$COPY (.PROT_FIELD_DSC[DSC$W_LENGTH], .PROT_FIELD_DSC[DSC$A_POINTER],
		     .PROT_IDX, PROT_BUF,
		     0,
		     512 - .SIZE,
		     BUFFER[.SIZE]);
	    SIZE = .SIZE + .PROT_FIELD_DSC[DSC$W_LENGTH] + .PROT_IDX;
	    STORE_TEXT (',');
	    END;
	END;
    [ACE$C_JNLID]:
	BEGIN
	STORE_TEXT ('RMS_JOURNAL_ID,');
	CH$FILL (0, DSC$C_S_BLN, VOLNAM_DESC);
	CH$FILL (0, VOLNAM_SIZE, VOLNAM_TEXT);
	CH$FILL (0, DSC$C_S_BLN, FILENAME_DESC);
	CH$FILL (0, ATR$S_FILE_SPEC, FILENAME_TEXT);
	CH$COPY (%CHARCOUNT ('DISK$'), UPLIT ('DISK$'),
		 ACE$S_VOLNAM, LOCAL_ACE[ACE$T_VOLNAM],
		 0, VOLNAM_SIZE, VOLNAM_TEXT);
	VOLNAM_DESC[DSC$W_LENGTH] = CH$FIND_CH (VOLNAM_SIZE, VOLNAM_TEXT, 0) -
				    VOLNAM_TEXT;
	VOLNAM_DESC[DSC$A_POINTER] = VOLNAM_TEXT;
	FILENAME_DESC[DSC$W_LENGTH] = ATR$S_FILE_SPEC;
	FILENAME_DESC[DSC$A_POINTER] = FILENAME_TEXT;
	LOCAL_STATUS = LIB$FID_TO_NAME (VOLNAM_DESC, LOCAL_ACE[ACE$T_FID],
					FILENAME_DESC, FILENAME_DESC);
	STORE_TEXT ('JOURNALED_FILE=');
	IF .LOCAL_STATUS
	THEN
	    BEGIN
	    LOCAL	SEGMENT_START	: REF VECTOR [,BYTE],
			SEGMENT_SIZE;		! Size of segment to get
	    SEGMENT_START = .FILENAME_DESC[DSC$A_POINTER];
	    SEGMENT_SIZE = MINU (.WIDTH - .LINE_SIZE, .FILENAME_DESC[DSC$W_LENGTH]);
	    DO
		BEGIN
		IF .SEGMENT_SIZE LSSU .FILENAME_DESC[DSC$W_LENGTH]
		THEN
		    DECR J FROM .SEGMENT_SIZE TO 1
		    DO
			BEGIN
			IF .SEGMENT_START[.J - 1] EQL ':'
			OR .SEGMENT_START[.J - 1] EQL ']'
			OR .SEGMENT_START[.J - 1] EQL '.'
			OR .SEGMENT_START[.J - 1] EQL ';'
			THEN
			    BEGIN
			    SEGMENT_SIZE = .J;
			    EXITLOOP;
			    END;
			END;
		CH$MOVE (.SEGMENT_SIZE, .SEGMENT_START, BUFFER[.SIZE]);
		LINE_SIZE = .LINE_SIZE + .SEGMENT_SIZE;
		SIZE = .SIZE + .SEGMENT_SIZE;
		FILENAME_DESC[DSC$W_LENGTH] = .FILENAME_DESC[DSC$W_LENGTH] - .SEGMENT_SIZE;
		SEGMENT_START = .SEGMENT_START + .SEGMENT_SIZE;
		IF .FILENAME_DESC[DSC$W_LENGTH] GTR 0 THEN NEW_LINE;
		SEGMENT_SIZE = MINU (.WIDTH - .LINE_SIZE, .FILENAME_DESC[DSC$W_LENGTH]);
		END
	    UNTIL .FILENAME_DESC[DSC$W_LENGTH] LEQ 0;
	    STORE_TEXT (',');
	    END
	ELSE
	    BEGIN
	    FAO_DESC[DSC$W_LENGTH] = MAX_FAO_LENGTH;
	    FAO_DESC[DSC$A_POINTER] = FAO_BUF;
	    $FAO ($DESCRIPTOR ('(!UW,!UW,!UW),'),
		  FAO_DESC,
		  FAO_DESC,
		  .(LOCAL_ACE[ACE$T_FID] + $BYTEOFFSET (FID$W_NUM)),
		  .(LOCAL_ACE[ACE$T_FID] + $BYTEOFFSET (FID$W_SEQ)),
		  .(LOCAL_ACE[ACE$T_FID] + $BYTEOFFSET (FID$W_RVN)));
	    CHECK_WIDTH (.FAO_DESC[DSC$W_LENGTH]);
	    CH$MOVE (.FAO_DESC[DSC$W_LENGTH], .FAO_DESC[DSC$A_POINTER], BUFFER[.SIZE]);
	    SIZE = .SIZE + .FAO_DESC[DSC$W_LENGTH];
	    END;
	STORE_TEXT ('MARKED_FOR_JOURNALING=');
	FAO_DESC[DSC$W_LENGTH] = MAX_FAO_LENGTH;
	FAO_DESC[DSC$A_POINTER] = FAO_BUF;
	$FAO ($DESCRIPTOR ('!%D,'),
	      FAO_DESC,
	      FAO_DESC,
	      LOCAL_ACE[ACE$Q_ID_DATE]);
	FAO_BUF[11] = ':';
	IF .FAO_BUF[0] EQL ' '
	THEN
	    BEGIN
	    FAO_DESC[DSC$W_LENGTH] = .FAO_DESC[DSC$W_LENGTH] - 1;
	    FAO_DESC[DSC$A_POINTER] = .FAO_DESC[DSC$A_POINTER] + 1;
	    END;
	CHECK_WIDTH (.FAO_DESC[DSC$W_LENGTH]);
	CH$MOVE (.FAO_DESC[DSC$W_LENGTH], .FAO_DESC[DSC$A_POINTER], BUFFER[.SIZE]);
	SIZE = .SIZE + .FAO_DESC[DSC$W_LENGTH];
	END;

    [INRANGE,
     OUTRANGE]:
	BEGIN
	STORE_TEXT ('Unknown=');
	CHECK_WIDTH (5);
	FAO_DESCR[DSC$W_LENGTH] = 5;
	FAO_DESCR[DSC$A_POINTER] = BUFFER[.SIZE];
	$FAOL (CTRSTR = $DESCRIPTOR ('%X!XB,'),
	       OUTBUF = FAO_DESCR,
	       PRMLST = %REF (.LOCAL_ACE[ACE$B_TYPE]));
	SIZE = .SIZE + 5;
	STORE_TEXT ('Size=');
	CHECK_WIDTH (5);
	FAO_DESCR[DSC$W_LENGTH] = 5;
	FAO_DESCR[DSC$A_POINTER] = BUFFER[.SIZE];
	$FAOL (CTRSTR = $DESCRIPTOR ('%D!UB,'),
	       OUTBUF = FAO_DESCR,
	       PRMLST = %REF (.LOCAL_ACE[ACE$B_SIZE]));
	SIZE = .SIZE + 5;
	STORE_TEXT ('Flags=');
	CHECK_WIDTH (7);
	FAO_DESCR[DSC$W_LENGTH] = 7;
	FAO_DESCR[DSC$A_POINTER] = BUFFER[.SIZE];
	$FAOL (CTRSTR = $DESCRIPTOR ('%X!XW,'),
	       OUTBUF = FAO_DESCR,
	       PRMLST = %REF (.LOCAL_ACE[ACE$W_FLAGS]));
	SIZE = .SIZE + 7;
	STORE_TEXT ('Access=');
	CHECK_WIDTH (11);
	FAO_DESCR[DSC$W_LENGTH] = 11;
	FAO_DESCR[DSC$A_POINTER] = BUFFER[.SIZE];
	$FAOL (CTRSTR = $DESCRIPTOR ('%X!XL,'),
	       OUTBUF = FAO_DESCR,
	       PRMLST = %REF (.LOCAL_ACE[ACE$L_ACCESS]));
	SIZE = .SIZE + 11;
	STORE_TEXT ('Data=');
	INCR J FROM 1 TO (.LOCAL_ACE[ACE$B_SIZE] - ACE$C_LENGTH + 3) / 4
	DO
	    BEGIN
	    CHECK_WIDTH (11);
	    FAO_DESCR[DSC$W_LENGTH] = 11;
	    FAO_DESCR[DSC$A_POINTER] = BUFFER[.SIZE];
	    $FAOL (CTRSTR = $DESCRIPTOR ('%X!XL,'),
		   OUTBUF = FAO_DESCR,
		   PRMLST = VECTOR [LOCAL_ACE[ACE$L_KEY], .J - 1]);
	    SIZE = .SIZE + 11;
	    END;
	BUFFER[.SIZE - 1] = %C')';
	IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .ACL_STRING)
	THEN
	    BEGIN
	    IF EXE$PROBEW (0, .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
	    THEN CH$COPY (.SIZE, BUFFER, 0, .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
	    ELSE RETURN SS$_ACCVIO
	    END
	ELSE RETURN SS$_ACCVIO;
	IF .ACL_LENGTH NEQ 0
	THEN IF PROBEW (%REF (0), %REF (4), .ACL_LENGTH)
	     THEN .ACL_LENGTH = .SIZE ELSE RETURN SS$_ACCVIO;
	IF .SIZE GTR .ACL_STRING_LEN
	THEN RETURN SS$_BUFFEROVF ELSE RETURN SS$_NORMAL;
	END;
TES;

! Note any special flags applied to the ACE.

FLAGS = .LOCAL_ACE[ACE$W_FLAGS];
IF .AUDIT_MASK
THEN FLAGS = .FLAGS AND NOT ($FIELDMASK (ACE$V_SUCCESS) OR $FIELDMASK (ACE$V_FAILURE));
IF .FLAGS NEQ 0
THEN
    BEGIN
    STORE_TEXT ('OPTIONS=');
    IF TESTBITSC (FLAGS[$BITPOSITION (ACE$V_DEFAULT)])
    THEN STORE_TEXT ('DEFAULT+');
    IF TESTBITSC (FLAGS[$BITPOSITION (ACE$V_HIDDEN)])
    THEN STORE_TEXT ('HIDDEN+');
    IF TESTBITSC (FLAGS[$BITPOSITION (ACE$V_PROTECTED)])
    THEN STORE_TEXT ('PROTECTED+');
    IF TESTBITSC (FLAGS[$BITPOSITION (ACE$V_NOPROPAGATE)])
    THEN STORE_TEXT ('NOPROPAGATE+');
    IF .FLAGS NEQ 0
    THEN
	BEGIN
	CHECK_WIDTH (7);
	FAO_DESCR[DSC$W_LENGTH] = 7;
	FAO_DESCR[DSC$A_POINTER] = BUFFER[.SIZE];
	$FAO ($DESCRIPTOR ('%X!XW,'),
	      FAO_DESCR,
	      FAO_DESCR,
	      .FLAGS);
	SIZE = .SIZE + 7;
	END
    ELSE BUFFER[.SIZE - 1] = %C',';
    END;

! Note the access rights.

IF .ACCESS_MASK
THEN
    BEGIN
    IF .LOCAL_ACE[ACE$L_ACCESS] NEQ 0
    OR (.AUDIT_MASK
	AND (.LOCAL_ACE[ACE$V_SUCCESS]
	     OR .LOCAL_ACE[ACE$V_FAILURE]))
    THEN
	BEGIN
	STORE_TEXT ('ACCESS=');
	INCR J FROM 0 TO 31
	DO
	    BEGIN
	    IF .(LOCAL_ACE[ACE$L_ACCESS])<.J,1>
	    THEN
		BEGIN
		IF .BIT_NAME_TABLE NEQA 0
		THEN
		    BEGIN
		    IF PROBER (%REF (0), %REF (DSC$C_S_BLN), BIT_NAME_TABLE[.J, 0, 0, 0, 0])
		    THEN BIT_NAME_DESC = BIT_NAME_TABLE[.J, 0, 0, 0, 0]
		    ELSE RETURN SS$_ACCVIO;
		    IF NOT EXE$PROBER (0, .BIT_NAME_DESC[DSC$W_LENGTH],
				       .BIT_NAME_DESC[DSC$A_POINTER])
		    THEN RETURN SS$_ACCVIO;
		    END
		ELSE BIT_NAME_DESC = .DEFAULT_BITS[.J];
		CHECK_WIDTH (.BIT_NAME_DESC[DSC$W_LENGTH] + 1);
		CH$MOVE (.BIT_NAME_DESC[DSC$W_LENGTH], .BIT_NAME_DESC[DSC$A_POINTER],
						       BUFFER[.SIZE]);
		BUFFER[.SIZE + .BIT_NAME_DESC[DSC$W_LENGTH]] = '+';
		SIZE = .SIZE + .BIT_NAME_DESC[DSC$W_LENGTH] + 1;
		END;
	    END;
	IF .AUDIT_MASK
	THEN
	    BEGIN
	    IF .LOCAL_ACE[ACE$V_SUCCESS] THEN STORE_TEXT ('SUCCESS+');
	    IF .LOCAL_ACE[ACE$V_FAILURE] THEN STORE_TEXT ('FAILURE+');
	    END;
	END
    ELSE STORE_TEXT ('ACCESS=NONE+');
    END;

! Close off the ACE.

BUFFER[.SIZE - 1] = %C')';

! Copy the formatted ACE to the user's buffer and return a size if required.

IF PROBER (%REF (0), %REF (DSC$C_S_BLN), .ACL_STRING)
THEN
    BEGIN
    IF EXE$PROBEW (0, .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
    THEN CH$COPY (.SIZE, BUFFER, 0, .ACL_STRING_LEN, .ACL_STRING[DSC$A_POINTER])
    ELSE RETURN SS$_ACCVIO
    END
ELSE RETURN SS$_ACCVIO;
IF .ACL_LENGTH NEQ 0
THEN IF PROBEW (%REF (0), %REF (4), .ACL_LENGTH)
     THEN .ACL_LENGTH = .SIZE ELSE RETURN SS$_ACCVIO;
IF .SIZE GTR .ACL_STRING_LEN
THEN RETURN SS$_BUFFEROVF ELSE RETURN SS$_NORMAL;

END;						! End of routine SYS$FORMAT_ACL

%SBTTL	'$CHANGE_ACL system service'
GLOBAL ROUTINE SYS$CHANGE_ACL (CHANNEL, OBJECT_TYPE, OBJECT_NAME,
			       ITEM_LIST, ACCESS_MODE, RESERVED, CONTEXT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes (or reads) the ACL associated with any of the
!	defined objects within the system.
!
!	Note:	Since the length of the ACE is part of the data returned to
!		the caller,  the return length parameter of the item list
!		is unused.
!
!	There are basically two types of objects that can have their ACL
!	twiddled. There are those objects that require an agent to do the work
!	(e.g, files by the XQP) and the others where it is simply necessary to
!	locate the ACL queue segment list head.  In the latter case, the work
!	is done here.
!
! CALLING SEQUENCE:
!	SYS$CHANGE_ACL (ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)
!
! INPUT PARAMETERS:
!	ARG1: number of the channel assigned to the object or 0 if
!	      the object is specified by ARG2 and ARG3
!	ARG2: address of an object type code
!	ARG3: address of an object name descriptor
!	ARG4: address of a list of item descriptors
!	ARG5: address of an access mode longword (used to validate the
!	      item list and I/O status block)
!	ARG6: reserved for future use
!	ARG7: address of a context longword
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	ARG7:	address of a context longword
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	SS$_NORMAL - if the requested action completed successfully
!	SS$_NOPRIV - if the requestor did not have privileges for the
!		     requested action
!
! SIDE EFFECTS:
!	The context longword is modified as necessary based upon the
!	action requested.
!
!--

BEGIN

MAP
	CHANNEL		: WORD,
	OBJECT_NAME	: REF $BBLOCK,
	ITEM_LIST	: REF BLOCKVECTOR [, ITM$S_ITEM, BYTE];

LOCAL
	STATUS,					! Local routine return status
	STATUS2,				! Temp status, may overwrite STATUS
	PSL		: $BBLOCK [4],		! Local copy of PSL
	LOCAL_OBJTYP,				! Local copy of object type code
	LOCAL_IOSB	: VECTOR [4, WORD],	! Local copy of the I/O status block
	LOCAL_LOCKID,				! Local copy of the lock-id
	OBJECT_DESC	: VECTOR [2],		! Descriptor of object name
	SHARE		: BYTE,			! Whether to allow sharing or not
	ITEM_COUNT,				! Number of items in the list
	ITEM_CODE,				! Code from item list entry
	ITEM_SIZE,				! Size from item list entry
	ITEM_ADDR,				! Buffer addr from item list entry
	LOCAL_CHANNEL	: WORD,			! Local copy of user's channel
	IO_CHANNEL	: WORD,			! Object's channel
	FILE_FAB	: $FAB_DECL,		! Object file's FAB
	FILE_NAM	: $NAM_DECL,		! Object file's NAMe block
	FILE_EXP_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Expanded name storage
	FILE_RES_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Resultant name storage
	FILE_FIB_DESC	: $BBLOCK [DSC$C_S_BLN],	! File FIB descriptor
	FILE_FIB	: $BBLOCK [FIB$C_LENGTH],	! File FIB storage
	DVI_ATR_LIST	: BLOCKVECTOR [2, ITM$S_ITEM, BYTE],	! $GETDVI item list
	ACP_ATR_PTR,				! Pointer into ACP attribute list
	ACP_ATR_LIST	: REF BLOCKVECTOR [, 8, BYTE],	! ACP attribute list
	ACL_TO_ATR_TAB	: VECTOR [MAX_ACL_ATR + 1]	! ATR$C to ACL$C xlate
			  INITIAL (0,
				   ATR$C_ADDACLENT,
				   ATR$C_DELACLENT,
				   ATR$C_MODACLENT,
				   ATR$C_FNDACLENT,
				   ATR$C_FNDACETYP,
				   ATR$C_DELETEACL,
				   ATR$C_READACL,
				   ATR$C_ACLLENGTH,
				   ATR$C_READACE),
	FUNCTION_CODE,				! QIOW function code
						! Also, ACL dispatch code
	CMK_ARG_LIST	: VECTOR [5];		! $CMKRNL arg list

! See if an access mode parameter was given.

CHANGE_ACMODE = 0;
IF .ACCESS_MODE NEQA 0
THEN IF PROBER (%REF (0), %REF (4), .ACCESS_MODE)
    THEN CHANGE_ACMODE = ..ACCESS_MODE
    ELSE RETURN SS$_ACCVIO;

MOVPSL (PSL);
CALL_ACMODE = .PSL[PSL$V_PRVMOD];
CHANGE_ACMODE = MAXU (.CHANGE_ACMODE, .CALL_ACMODE);

! Determine the validity of the access mode parameter.

IF .CHANGE_ACMODE GTRU PSL$C_USER THEN RETURN SS$_BADPARAM;

! Get the supplied channel, if any, and verify it.

IO_CHANNEL = LOCAL_CHANNEL = .CHANNEL;
IF .IO_CHANNEL NEQ 0
THEN
    BEGIN
    STATUS = IOC$VERIFYCHAN (.IO_CHANNEL);
    IF NOT .STATUS THEN RETURN .STATUS;
    END;

! Get the object type code.

IF .OBJECT_TYPE NEQA 0
THEN (IF PROBER (%REF (0), %REF (4), .OBJECT_TYPE)
      THEN LOCAL_OBJTYP = ..OBJECT_TYPE
      ELSE RETURN SS$_ACCVIO)
ELSE RETURN SS$_INSFARG;

! Check the validity of the object type code.

IF .LOCAL_OBJTYP LSSU MIN_OBJECT_TYPE
OR .LOCAL_OBJTYP GTRU MAX_OBJECT_TYPE
THEN RETURN SS$_BADPARAM;

! Probe the object name if supplied.

IF .OBJECT_NAME NEQA 0
THEN
    BEGIN
    IF NOT PROBER (%REF (0), %REF (DSC$C_S_BLN), .OBJECT_NAME)
    THEN RETURN SS$_ACCVIO;
    OBJECT_DESC[0] = .OBJECT_NAME[DSC$W_LENGTH];
    OBJECT_DESC[1] = .OBJECT_NAME[DSC$A_POINTER];
    IF NOT EXE$PROBER (0, .OBJECT_DESC[0], .OBJECT_DESC[1])
    THEN RETURN SS$_ACCVIO;
    END
ELSE
    BEGIN
    OBJECT_DESC[0] = 0;
    OBJECT_DESC[1] = 0;
    END;

! Get any value supplied for the context parameter.

ACL_CONTEXT = 0;
IF .CONTEXT NEQA 0
THEN IF PROBEW (%REF (0), %REF (4), .CONTEXT)
     THEN ACL_CONTEXT = ..CONTEXT
     ELSE RETURN SS$_ACCVIO;

! Count the number of items in the item list.

SHARE = 1;					! Assume shared access
INCR J FROM 0
DO IF PROBER (%REF (0), %REF (ITM$S_ITEM), ITEM_LIST[.J, 0,0,0,0])
   THEN (IF .ITEM_LIST[.J, ITM$W_BUFSIZ] EQL 0
	 THEN
	     BEGIN
	     ITEM_COUNT = .J;
	     EXITLOOP;
	     END
	 ELSE
	     BEGIN
	     IF .ITEM_LIST[.J, ITM$W_ITMCOD] EQL ACL$C_ADDACLENT
	     OR .ITEM_LIST[.J, ITM$W_ITMCOD] EQL ACL$C_DELACLENT
	     OR .ITEM_LIST[.J, ITM$W_ITMCOD] EQL ACL$C_MODACLENT
	     OR .ITEM_LIST[.J, ITM$W_ITMCOD] EQL ACL$C_DELETEACL
	     THEN SHARE = 0;
	     END)
   ELSE RETURN SS$_ACCVIO;

! Initialize all common (to both types of objects) storage.

CH$FILL (0, 2*ITM$S_ITEM, DVI_ATR_LIST);
CH$FILL (0, DSC$C_S_BLN, LOCK_RESNAM);
LOCAL_LOCKID = 0;

! Set up the lock resource name prefix.

LOCK_RESNAM[DSC$W_LENGTH] = RSN_S_PREFIX;
LOCK_RESNAM[DSC$A_POINTER] = RESNAM_TEXT;
CH$COPY (.$BBLOCK [.LOCK_PREFIX[.LOCAL_OBJTYP], DSC$W_LENGTH],
	 .$BBLOCK [.LOCK_PREFIX[.LOCAL_OBJTYP], DSC$A_POINTER],
	 0,
	 RSN_S_PREFIX, RESNAM_TEXT);

! If the call is from user mode, take out a lock to form the parent lock ID
! for all ACL locks. This facilitates releasing them at image rundown.

IF .CALL_ACMODE EQL PSL$C_USER
THEN
    IF .PARENT_ID EQL 0
    THEN
	BEGIN
	STATUS = $CMKRNL (ROUTIN = GET_PARENT_LOCK);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;

! Do any initial setup for the object.  For files, this means opening the
! specified file if it is not already open.  For devices, this means assigning
! a channel is one is not already assigned.  For most other objects, nothing
! special is needed.

CASE .LOCAL_OBJTYP FROM MIN_OBJECT_TYPE TO MAX_OBJECT_TYPE OF
SET
    [ACL$C_FILE]:
	BEGIN

! Initialize storage.

	CH$FILL (0, FIB$C_LENGTH, FILE_FIB);
	CH$FILL (0, DSC$C_S_BLN, FILE_FIB_DESC);
	FILE_FIB_DESC[DSC$W_LENGTH] = FIB$C_LENGTH;
	FILE_FIB_DESC[DSC$A_POINTER] = FILE_FIB;
	FILE_FIB[FIB$B_AGENT_MODE] = .CHANGE_ACMODE;

! If the file is not accessed, do it now.

	IF .IO_CHANNEL EQL 0
	THEN
	    BEGIN
	    $FAB_INIT (FAB = FILE_FAB,
		       FNS = .OBJECT_DESC[0],
		       FNA = .OBJECT_DESC[1],
		       FOP = UFO,
		       NAM = FILE_NAM);
	    $NAM_INIT (NAM = FILE_NAM,
		       ESA = FILE_EXP_NAME,
		       ESS = NAM$C_MAXRSS,
		       RSA = FILE_RES_NAME,
		       RSS = NAM$C_MAXRSS);
	    IF .SHARE
	    THEN
		BEGIN
		FILE_FAB[FAB$B_SHR] = FAB$M_GET OR FAB$M_PUT OR FAB$M_UPI;
		FILE_FAB[FAB$B_FAC] = FAB$M_GET;
		END
	    ELSE
		BEGIN
		FILE_FAB[FAB$B_SHR] = FAB$M_NIL;
		FILE_FAB[FAB$B_FAC] = FAB$M_GET OR FAB$M_PUT;
		END;
	    FILE_FAB[FAB$V_FILE_MODE] = .CHANGE_ACMODE;

	    STATUS = $OPEN (FAB = FILE_FAB);
	    IO_CHANNEL = .FILE_FAB[FAB$L_STV];
	    END
	ELSE STATUS = SS$_NORMAL;

! Now that a channel has been assigned to the file, do a simple access to
! fill the fib.  This is needed to get the file-id used to build the lock name.

	IF .STATUS
	THEN
	    BEGIN
	    STATUS = $QIOW (CHAN = .IO_CHANNEL,
			    FUNC = IO$_ACCESS,
			    IOSB = LOCAL_IOSB,
			    P1 = FILE_FIB_DESC);
	    IF .STATUS THEN STATUS = .LOCAL_IOSB[0];
	    END;
	END;

    [ACL$C_DEVICE]:
	BEGIN

! If necessary assign a channel to the specified device.

	IF .IO_CHANNEL EQL 0
	THEN
	    BEGIN
	    IF .OBJECT_DESC[0] EQL 0
	    THEN RETURN SS$_INSFARG;
	    STATUS = $ASSIGN (DEVNAM = OBJECT_DESC,
			      CHAN = IO_CHANNEL);
	    END;

! Now that there is a channel to the device, locate the ACL queue head.

	IF .STATUS
	THEN
	    BEGIN
	    CMK_ARG_LIST[0] = 1;		! Number of args
	    CMK_ARG_LIST[1] = .IO_CHANNEL;	! Channel number
	    STATUS = $CMKRNL (ROUTIN = GET_UCB_ACL,
			      ARGLST = CMK_ARG_LIST);
	    END;
	END;

    [ACL$C_JOBCTL_QUEUE]:
	BEGIN
	STATUS = SS$_BADPARAM;
	END;

    [ACL$C_COMMON_EF_CLUSTER]:
	BEGIN
	IF .OBJECT_DESC[0] EQL 0
	THEN RETURN SS$_INSFARG;
	CMK_ARG_LIST[0] = 1;			! Number of args
	CMK_ARG_LIST[1] = OBJECT_DESC;		! Cluster name descr
	STATUS = $CMKRNL (ROUTIN = GET_CEB_ACL,
			  ARGLST = CMK_ARG_LIST);
	END;

    [ACL$C_LOGICAL_NAME_TABLE]:
	BEGIN
	IF .OBJECT_DESC[0] EQL 0
	THEN RETURN SS$_INSFARG;
	CMK_ARG_LIST[0] = 1;			! Number of args
	CMK_ARG_LIST[1] = OBJECT_DESC;		! Logical name table descr
	STATUS = $CMKRNL (ROUTIN = GET_LNT_ACL,
			  ARGLST = CMK_ARG_LIST);
	END;

    [ACL$C_PROCESS]:
	BEGIN
	IF .OBJECT_DESC[0] EQL 0
	THEN RETURN SS$_INSFARG;
	CMK_ARG_LIST[0] = 1;			! Number of args
	CMK_ARG_LIST[1] = OBJECT_DESC;		! Process name descr
	STATUS = $CMKRNL (ROUTIN = GET_PCB_ACL,
			  ARGLST = CMK_ARG_LIST);
	END;

    [ACL$C_GLOBAL_SECTION]:
	BEGIN
	IF .OBJECT_DESC[0] EQL 0
	THEN RETURN SS$_INSFARG;
	CMK_ARG_LIST[0] = 1;			! Number of args
	CMK_ARG_LIST[1] = OBJECT_DESC;		! Section name descr
	STATUS = $CMKRNL (ROUTIN = GET_GBL_ACL,
			  ARGLST = CMK_ARG_LIST);
	END;

    [INRANGE, OUTRANGE]:	STATUS = SS$_BADPARAM;
TES;

! If any error have occurred, leave now.

IF NOT .STATUS
THEN
    BEGIN
    IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
    RETURN .STATUS;
    END;

! Now that the device has been identified, and a channel assigned if needed,
! form the remainder of the lock resource name.  Then do the appropriate lock
! or unlock.

IF .LOCAL_OBJTYP EQL ACL$C_FILE OR .LOCAL_OBJTYP EQL ACL$C_DEVICE
THEN
    BEGIN
    LOCAL	TMP_LEN;

! Build the remaining portion of the lock name.

    DVI_ATR_LIST[0, ITM$W_ITMCOD] = DVI$_DEVLOCKNAM;
    DVI_ATR_LIST[0, ITM$W_BUFSIZ] = 31 - RSN_S_PREFIX;
    DVI_ATR_LIST[0, ITM$L_BUFADR] = RESNAM_TEXT[RSN_T_DEVNAM];
    DVI_ATR_LIST[0, ITM$L_RETLEN] = TMP_LEN;
    STATUS = $GETDVI (CHAN = .IO_CHANNEL,
		      ITMLST = DVI_ATR_LIST,
		      IOSB = LOCAL_IOSB);
    IF .STATUS THEN STATUS = .LOCAL_IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
	RETURN .STATUS;
	END;

    LOCK_RESNAM[DSC$W_LENGTH] = .LOCK_RESNAM[DSC$W_LENGTH] + .TMP_LEN;
    IF .LOCAL_OBJTYP EQL ACL$C_FILE
    THEN
	BEGIN
	RESNAM_TEXT[RSN_W_FID_NUM] = .FILE_FIB[FIB$W_FID_NUM];
	RESNAM_TEXT[RSN_W_FID_SEQ] = .FILE_FIB[FIB$W_FID_SEQ];
	LOCK_RESNAM[DSC$W_LENGTH] = .LOCK_RESNAM[DSC$W_LENGTH] + 4;
	END;
    END;

! For files, process the attribute list, and pass it through to the ACP.
! for all other objects, the attribute processing is done here.

IF .LOCAL_OBJTYP EQL ACL$C_FILE
THEN
    BEGIN

! Build the ACP attribute list.

    STATUS = LIB$GET_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
    IF NOT .STATUS
    THEN
	BEGIN
	IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
	RETURN .STATUS;
	END;
    FUNCTION_CODE = IO$_ACCESS;
    ACP_ATR_PTR = 0;
    INCR J FROM 0 TO .ITEM_COUNT - 1
    DO
	BEGIN
	IF PROBER (%REF (0), %REF (ITM$S_ITEM), ITEM_LIST[.J, 0,0,0,0])
	THEN
	    BEGIN
	    ITEM_CODE = .ITEM_LIST[.J, ITM$W_ITMCOD];
	    ITEM_SIZE = .ITEM_LIST[.J, ITM$W_BUFSIZ];
	    ITEM_ADDR = .ITEM_LIST[.J, ITM$L_BUFADR];
	    END
	ELSE
	    BEGIN
	    STATUS = SS$_ACCVIO;
	    LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
	    IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
	    RETURN .STATUS;
	    END;
	IF .ITEM_CODE GTR MAX_ACL_ATR
	THEN
	    BEGIN
	    STATUS = SS$_BADPARAM;
	    LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
	    IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
	    RETURN .STATUS;
	    END;

	IF .ITEM_CODE EQL ACL$C_RLOCK_ACL
	OR .ITEM_CODE EQL ACL$C_WLOCK_ACL
	THEN
	    BEGIN
	    IF .ITEM_SIZE LSSU 4
	    THEN
		BEGIN
		STATUS = SS$_BADPARAM;
		LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
		IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
		RETURN .STATUS;
		END;
	    IF NOT EXE$PROBEW (0, .ITEM_SIZE, .ITEM_ADDR)
	    THEN
		BEGIN
		STATUS = SS$_ACCVIO;
		LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
		IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
		RETURN .STATUS;
		END;
	    STATUS = $ENQ (LKMODE = (IF .ITEM_CODE EQL ACL$C_RLOCK_ACL
				     THEN LCK$K_CRMODE ELSE LCK$K_PWMODE),
			   LKSB = LOCAL_IOSB,
			   RESNAM = LOCK_RESNAM,
			   PARID = (IF .CALL_ACMODE EQL PSL$C_USER
				    THEN .PARENT_ID
				    ELSE 0),
			   FLAGS = LCK$M_NOQUEUE OR
				   LCK$M_SYNCSTS OR
				   LCK$M_SYSTEM,
			   ACMODE = PSL$C_USER);
	    IF .STATUS THEN STATUS = .LOCAL_IOSB[0];
	    IF NOT .STATUS
	    THEN
		BEGIN
		LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
		IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
		RETURN .STATUS;
		END;
	    CH$COPY (4, LOCAL_IOSB[2],
		     0,
		     .ITEM_SIZE,  .ITEM_ADDR);	! Copy lock-id
	    END

	ELSE IF .ITEM_CODE EQL ACL$C_UNLOCK_ACL
	THEN
	    BEGIN
	    IF .ITEM_SIZE LSSU 4
	    THEN
		BEGIN
		STATUS = SS$_BADPARAM;
		LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
		IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
		RETURN .STATUS;
		END;
	    IF NOT EXE$PROBER (0, .ITEM_SIZE, .ITEM_ADDR)
	    THEN
		BEGIN
		STATUS = SS$_ACCVIO;
		LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
		IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);
		RETURN .STATUS;
		END;
	    CH$COPY (.ITEM_SIZE, .ITEM_ADDR, 0, 4, LOCAL_LOCKID);
	    END
	ELSE
	    BEGIN

! Save the converted attribute code and other information.

	    ACP_ATR_LIST[.ACP_ATR_PTR, ATR$W_TYPE] = .ACL_TO_ATR_TAB[.ITEM_CODE];
	    IF .ITEM_CODE EQL ACL$C_ADDACLENT OR .ITEM_CODE EQL ACL$C_DELACLENT
	    OR .ITEM_CODE EQL ACL$C_MODACLENT OR .ITEM_CODE EQL ACL$C_DELETEACL
	    THEN FUNCTION_CODE = IO$_MODIFY;
	    ACP_ATR_LIST[.ACP_ATR_PTR, ATR$W_SIZE] = .ITEM_SIZE;
	    ACP_ATR_LIST[.ACP_ATR_PTR, ATR$L_ADDR] = .ITEM_ADDR;
	    ACP_ATR_PTR = .ACP_ATR_PTR + 1;
	    END;
	END;

! Tie off the attribute descriptor list.

    ACP_ATR_LIST[.ACP_ATR_PTR, ATR$W_TYPE] = 0;
    ACP_ATR_LIST[.ACP_ATR_PTR, ATR$W_SIZE] = 0;

! Initialize the FIB, and call the ACP to process the attribute list.

    FILE_FIB[FIB$L_ACLCTX] = .ACL_CONTEXT;
    STATUS = $QIOW (CHAN = .IO_CHANNEL,
		    FUNC = .FUNCTION_CODE,
		    IOSB = LOCAL_IOSB,
		    P1 = FILE_FIB_DESC,
		    P5 = .ACP_ATR_LIST);
    IF .STATUS THEN STATUS = .LOCAL_IOSB[0];
    IF .STATUS THEN STATUS = .FILE_FIB[FIB$L_ACL_STATUS];
    IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);

    STATUS2 = LIB$FREE_VM (%REF ((.ITEM_COUNT + 1) * 8), ACP_ATR_LIST);
    IF .STATUS AND NOT .STATUS2 THEN STATUS = .STATUS2;

! If an unlock request was made on the file's ACL, do it now.

    IF .LOCAL_LOCKID NEQ 0 THEN STATUS = $DEQ (LKID = .LOCAL_LOCKID);
    END

! For non-file objects, the queue head has been located; loop through
! the item list performing the actions specified.

ELSE
    BEGIN
    CMK_ARG_LIST[0] = 3;
    CMK_ARG_LIST[1] = .ITEM_COUNT;
    CMK_ARG_LIST[2] = .ITEM_LIST;
    CMK_ARG_LIST[3] = .SHARE;
    STATUS = $CMKRNL (ROUTIN = ACL_DISPATCH,
		      ARGLST = CMK_ARG_LIST);
    END;

! If necessary, deassign the channel assigned.

IF .LOCAL_CHANNEL EQL 0 THEN $DASSGN (CHAN = .IO_CHANNEL);

! If necessary, return the context.

IF .CONTEXT NEQA 0
THEN IF PROBEW (%REF (0), %REF (4), .CONTEXT)
    THEN
	BEGIN
	IF .LOCAL_OBJTYP EQL ACL$C_FILE
	THEN .CONTEXT = .FILE_FIB[FIB$L_ACLCTX]
	ELSE .CONTEXT = .ACL_CONTEXT;
	END
    ELSE STATUS = SS$_ACCVIO;

RETURN .STATUS;

END;						! End of routine SYS$CHANGE_ACL

%SBTTL	'GET_PARENT_LOCK - get parent for ACL locks'
ROUTINE GET_PARENT_LOCK =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine takes out a null lock on the system-wide ACL lock
!	parent name. This lock is used as a parent for user mode ACL locks.
!	It must be taken out in kernel mode, since some ACL locks are
!	taken out in kernel mode.
!	numeric value.  If the name does not exist, an error is returned.
!
! CALLING SEQUENCE:
!	GET_PARENT_LOCK ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	PARENT_ID: set to lock ID of parent lock
!
! ROUTINE VALUE:
!	Status of $ENQ call
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	STATUS,				! system status return
	LOCAL_IOSB	: VECTOR [4, WORD]; ! lock status block


STATUS = $ENQ (LKMODE = LCK$K_NLMODE,
	       LKSB   = LOCAL_IOSB,
	       RESNAM = .LOCK_PREFIX[0],
	       FLAGS  = LCK$M_NOQUEUE OR
			LCK$M_SYNCSTS OR
			LCK$M_SYSTEM,
	       ACMODE = PSL$C_USER);
IF .STATUS THEN STATUS = .LOCAL_IOSB[0];
IF NOT .STATUS THEN RETURN .STATUS;
PARENT_ID = .(LOCAL_IOSB[2])<0,32>;

1
END;					! End of routine GET_PARENT_LOCK

%SBTTL	'SET_ID - TPARSE action routine'
ROUTINE SET_ID =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine tries to convert an identifier to its corresponding
!	numeric value.  If the name does not exist, an error is returned.
!
! CALLING SEQUENCE:
!	SET_ID ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	ACE_BUFFER: address of the binary ACE storage
!	ACE_INDEX: index into the ACE key area
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	ACE_INDEX: index into the ACE key area
!
! ROUTINE VALUE:
!	SS$_NORMAL if the ID name exists
!	SS$_NOSUCHID if it does not
!
! SIDE EFFECTS:
!	The identifier name is converted to its corresponding value.  That
!	value is then placed in the ACE key area.  The index is then updated
!	to point to the next available key storage area.
!
!--

BEGIN

LOCAL
	UIC_POINTER	: REF $BBLOCK;		! Pointer to UIC entry

! Save the identifier, and note the type.

VECTOR [ACE_BUFFER[ACE$L_KEY], .ACE_INDEX] = .IDENTIFIER;
ACE_INDEX = .ACE_INDEX + 1;
IF .IDENTIFIER[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
THEN UIC_COUNT = .UIC_COUNT + 1
ELSE ID_COUNT = .ID_COUNT + 1;

RETURN 1;

END;						! End of routine SET_ID

%SBTTL	'SET_ACCESS_BIT - TPARSE action routine'
ROUTINE SET_ACCESS_BIT (ARG1, ARG2, ARG3, SIZE, BUFFER) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks the current token to determine whether or not
!	it is an access bit name.  If it is, the appropriate bit is set
!	in ACE_RIGHTS.  If it is not, an error is returned.
!
! CALLING SEQUENCE:
!	SET_ACCESS_BIT (ARG1, ARG2, ARG3, ARG4, ARG5)
!
! INPUT PARAMETERS:
!	ARG1-ARG3: TPARSE block arguments not used
!	ARG4: size of the current token
!	ARG5: address of the current token text
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	ACE_RIGHTS
!
! ROUTINE VALUE:
!	1 if bit name was defined
!	0 otherwise
!
! SIDE EFFECTS:
!	The appropriate bit is set in ACE_RIGHTS.
!
!--

BEGIN

LOCAL
	BIT_POSITION,				! Bit index
	BIT_NAME_DESC	: REF $BBLOCK;		! Bit name descriptor

! Note that, initially, no match was found.

BIT_POSITION = -1;

! Now scan the bit name table to see if the specified definition exists.

INCR J FROM 0 TO 31
DO
    BEGIN
    IF .BIT_NAME_TABLE NEQA 0
    THEN
	BEGIN
	IF PROBER (%REF (0), %REF (DSC$C_S_BLN), BIT_NAME_TABLE[.J, 0, 0, 0, 0])
	THEN BIT_NAME_DESC = BIT_NAME_TABLE[.J, 0, 0, 0, 0]
	ELSE RETURN SS$_ACCVIO;
	IF NOT EXE$PROBER (0, .BIT_NAME_DESC[DSC$W_LENGTH],
			   .BIT_NAME_DESC[DSC$A_POINTER])
	THEN RETURN SS$_ACCVIO;
	END
    ELSE BIT_NAME_DESC = .DEFAULT_BITS[.J];
    IF CH$EQL (.SIZE, .BUFFER,
	       MINU (.SIZE, .BIT_NAME_DESC[DSC$W_LENGTH]), .BIT_NAME_DESC[DSC$A_POINTER], 0)
    THEN
	BEGIN
	IF .BIT_POSITION GEQ 0 THEN RETURN 0;	! Ambiguous, error.
	BIT_POSITION = .J;
	END;
    END;

IF .BIT_POSITION LSS 0 THEN RETURN 0;		! Specified name not found
ACE_RIGHTS<.BIT_POSITION,1> = 1;		! Note desired access.

RETURN 1;

END;						! End of routine SET_ACCESS_BIT

%SBTTL	'GET_UCB_ACL - get UCB ACL queue head address'
ROUTINE GET_UCB_ACL (CHANNEL) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the ACL queue head for a device, given a
!	channel number.
!
! CALLING SEQUENCE:
!	GET_UCB_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: channel assigned to the device
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	SS$_NORMAL if ACLs are allowed
!	SS$_NOACLSUPPORT if ACLs are not allowed
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	CHANNEL		: WORD;

LOCAL
	STATUS,					! Local routine return status
	DEVICE_UCB	: REF $BBLOCK,		! Device UCB address
	DEVICE_ORB	: REF $BBLOCK,		! Device ORB address
	CHANNEL_BLOCK	: REF $BBLOCK;		! Device CCB address

STATUS = IOC$VERIFYCHAN (.CHANNEL; CHANNEL_BLOCK);
IF NOT .STATUS THEN RETURN .STATUS;
DEVICE_UCB = .CHANNEL_BLOCK[CCB$L_UCB];
DEVICE_ORB = .DEVICE_UCB[UCB$L_ORB];

! If no ACLs are allowed, return an error.

IF .DEVICE_ORB[ORB$V_NOACL] THEN RETURN SS$_NOACLSUPPORT;

! If the device is unowned, and the protection is all access to everybody,
!  and there is no ACL present, require SYSPRV to change the ACL.

IF .DEVICE_ORB[ORB$L_OWNER] EQL 0
AND (IF .DEVICE_ORB[ORB$V_ACL_QUEUE]
     THEN .DEVICE_ORB[ORB$L_ACLFL] EQLA DEVICE_ORB[ORB$L_ACLFL]
     ELSE 1)
AND NOT .$BBLOCK [CTL$GL_PCB[PCB$Q_PRIV], PRV$V_SYSPRV]
THEN RETURN SS$_NOPRIV;

! If the ACL queue head is uninitialized, initialize it now.

IF NOT .DEVICE_ORB[ORB$V_ACL_QUEUE] THEN ACL_INIT_QUEUE (.DEVICE_ORB);

! Set up the address of the ACL queue head.

ACL_QUEUE_HEAD = $BBLOCK [.DEVICE_UCB[UCB$L_ORB], ORB$L_ACLFL];

RETURN SS$_NORMAL;

END;						! End of routine GET_UCB_ACL

%SBTTL	'GET_JBC_ACL - get Job Controller queue ACL queue head address'
ROUTINE GET_JBC_ACL (QUEUE_NAME) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the ACL queue head for a Job Controller
!	queue.
!
! CALLING SEQUENCE:
!	GET_JBC_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the queue name descriptor
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	address of the ACL queue head or 0 if an error has occurred
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	QUEUE_NAME	: REF $BBLOCK;

RETURN SS$_BADPARAM;

END;						! End of routine GET_JBC_ACL

%SBTTL	'GET_CEB_ACL - get common event block ACL queue head address'
ROUTINE GET_CEB_ACL (CLUSTER_NAME) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the ACL queue head for a common event block.
!
! CALLING SEQUENCE:
!	GET_CEB_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the cluster name descriptor
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	address of the ACL queue head or 0 if an error has occurred
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	CLUSTER_NAME	: REF $BBLOCK;

RETURN SS$_BADPARAM;

END;						! End of routine GET_CEB_ACL

%SBTTL	'GET_LNT_ACL - get logical name table ACL queue head address'
ROUTINE GET_LNT_ACL (TABLE_NAME) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the ACL queue head for aLogical name
!	table.
!
! CALLING SEQUENCE:
!	GET_LNT_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the table name descriptor
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	address of the ACL queue head or 0 if an error has occurred
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

RETURN SS$_BADPARAM;

END;						! End of routine GET_LNT_ACL

%SBTTL	'GET_PCB_ACL - get process ACL queue head address'
ROUTINE GET_PCB_ACL (PROCESS_NAME) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the ACL queue head for a process.
!
! CALLING SEQUENCE:
!	GET_PCB_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the process name descriptor
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	address of the ACL queue head or 0 if an error has occurred
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

RETURN SS$_BADPARAM;

END;						! End of routine GET_PCB_ACL

%SBTTL	'GET_GBL_ACL - get global section ACL queue head address'
ROUTINE GET_GBL_ACL (SECTION_NAME) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the ACL queue head for a global section, given
!	a section name.
!
! CALLING SEQUENCE:
!	GET_GBL_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the section name descriptor
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	address of the ACL queue head or 0 if an error has occurred
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

RETURN SS$_BADPARAM;

END;						! End of routine GET_GBL_ACL

%SBTTL	'ACL_DISPATCH - main ACL function dispatcher'
ROUTINE ACL_DISPATCH (ITEM_COUNT, ITEM_LIST, SHARE) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to perform the appropriate ACL operations.
!	The code is checked for validity and, when necessary, the buffer
!	is probed for the desired access.
!
! CALLING SEQUENCE:
!	ACL_DISPATCH (ARG1, ARG2, ARG3)
!
! INPUT PARAMETERS:
!	ARG1: count of items to process
!	ARG2: address of the item list
!	ARG3: 1 if the operation is only reading the ACL
!	      0 if the ACL is being modified
!
! IMPLICIT INPUTS:
!	ACL_CONTEXT: previous ACL context
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	ACL_CONTEXT: new ACL context
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	The appropriate action routine is called.  Possible ACL modification
!	may result.
!
!--

BEGIN

MAP
	ITEM_LIST	: REF BLOCKVECTOR [, ITM$S_ITEM, BYTE];

! Cells defined to tie off references made in the module ALLOCB obtained from
! the XQP.

GLOBAL	LITERAL
	CONTEXT_SAVE	= 0,
	CURRENT_WINDOW	= 0,
	IO_PACKET	= 0;

LOCAL
	ACL_STATUS,				! Status returned by ACL operation
	STATUS,					! Routine return status
	FUNCTION_CODE,				! Operation to perform
	SIZE,					! Size of user buffer
	BUFFER		: REF $BBLOCK,		! Address of user buffer
	LOCAL_IOSB	: VECTOR [4, WORD],	! Lock status block
	LOCAL_LOCKID;				! Local copy of the lock-id

! Initialize local storage.

CH$FILL (0, 4*2, LOCAL_IOSB);
LOCAL_IOSB[0] = SS$_NORMAL;			! Assume success
ACL_STATUS = STATUS = SS$_NORMAL;		! Here also

! Take out the mutex on the specified ACL.

IF .SHARE
THEN SCH$LOCKR (.ACL_QUEUE_HEAD - $BYTEOFFSET (ORB$L_ACLFL) + $BYTEOFFSET (ORB$L_ACL_MUTEX), .CTL$GL_PCB)
ELSE SCH$LOCKW (.ACL_QUEUE_HEAD - $BYTEOFFSET (ORB$L_ACLFL) + $BYTEOFFSET (ORB$L_ACL_MUTEX), .CTL$GL_PCB);

! Loop over the item list, processing each item.

INCR J FROM 0 TO .ITEM_COUNT-1
DO
    BEGIN

    FUNCTION_CODE = .ITEM_LIST[.J, ITM$W_ITMCOD];
    SIZE = .ITEM_LIST[.J, ITM$W_BUFSIZ];
    BUFFER = .ITEM_LIST[.J, ITM$L_BUFADR];

! Dispatch on the function code.

    CASE .FUNCTION_CODE FROM MIN_ACL_ATR TO MAX_ACL_ATR OF
    SET

	[ACL$C_ADDACLENT]:
	    BEGIN
	    IF .SHARE
	    THEN STATUS = SS$_BADPARAM
	    ELSE IF NOT EXE$PROBER (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE IF .ACL_STATUS
	    THEN ACL_STATUS = ACL_ADDENTRY (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER);
	    END;

	[ACL$C_DELACLENT]:
	    BEGIN
	    IF .SHARE
	    THEN STATUS = SS$_BADPARAM
	    ELSE IF NOT EXE$PROBER (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE IF .ACL_STATUS
	    THEN ACL_STATUS = ACL_DELENTRY (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER);
	    END;

	[ACL$C_MODACLENT]:
	    BEGIN
	    IF .SHARE
	    THEN STATUS = SS$_BADPARAM
	    ELSE IF NOT EXE$PROBER (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE IF .ACL_STATUS
	    THEN ACL_STATUS = ACL_MODENTRY (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER);
	    END;

	[ACL$C_FNDACLENT]:
	    BEGIN
	    IF NOT EXE$PROBEW (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE ACL_STATUS = ACL_FINDENTRY (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER, 0);
	    END;

	[ACL$C_FNDACETYP]:
	    BEGIN
	    IF NOT EXE$PROBEW (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE ACL_STATUS = ACL_FINDTYPE (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER, 0);
	    END;

	[ACL$C_DELETEACL]:
	    BEGIN
	    IF .SHARE
	    THEN STATUS = SS$_BADPARAM
	    ELSE IF .ACL_STATUS
	    THEN ACL_STATUS = ACL_DELETEACL (.ACL_QUEUE_HEAD, ACL_CONTEXT);
	    END;

	[ACL$C_READACL]:
	    BEGIN
	    IF NOT EXE$PROBEW (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE ACL_STATUS = ACL_READACL (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER);
	    END;

	[ACL$C_ACLLENGTH]:
	    BEGIN
	    IF NOT EXE$PROBEW (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE ACL_STATUS = ACL_ACLLENGTH (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER);
	    END;

	[ACL$C_READACE]:
	    BEGIN
	    IF NOT EXE$PROBEW (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE ACL_STATUS = ACL_READACE (.ACL_QUEUE_HEAD, ACL_CONTEXT, .SIZE, .BUFFER);
	    END;


	[ACL$C_RLOCK_ACL,
	 ACL$C_WLOCK_ACL]:
	    BEGIN
	    IF .SIZE LSSU 4
	    THEN STATUS = SS$_BADPARAM
	    ELSE IF NOT EXE$PROBEW (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE
		BEGIN
		STATUS = $ENQ (LKMODE = (IF .FUNCTION_CODE EQL ACL$C_RLOCK_ACL
					 THEN LCK$K_CRMODE ELSE LCK$K_PWMODE),
			       LKSB = LOCAL_IOSB,
			       RESNAM = LOCK_RESNAM,
			       PARID = (IF .CALL_ACMODE EQL PSL$C_USER
					THEN .PARENT_ID
					ELSE 0),
			       FLAGS = LCK$M_NOQUEUE OR
				       LCK$M_SYNCSTS OR
				       LCK$M_SYSTEM,
			       ACMODE = PSL$C_USER);
		IF .STATUS THEN STATUS = .LOCAL_IOSB[0];
		CH$COPY (4, LOCAL_IOSB[2],
			 0,
			 .SIZE, .BUFFER);		! Copy lock-id
		END;
	    END;


	[ACL$C_UNLOCK_ACL]:
	    BEGIN
	    IF .SIZE LSSU 4
	    THEN STATUS = SS$_BADPARAM
	    ELSE IF NOT EXE$PROBER (.CALL_ACMODE, .SIZE, .BUFFER)
	    THEN STATUS = SS$_ACCVIO
	    ELSE
		BEGIN
		CH$COPY (.SIZE, .BUFFER, 0, 4, LOCAL_LOCKID);
		STATUS = $DEQ (LKID = .LOCAL_LOCKID);
		END;
	    END;

	[INRANGE, OUTRANGE]:
	    BEGIN
	    STATUS = SS$_BADPARAM;
	    END;

    TES;

    IF NOT .STATUS THEN EXITLOOP;
    END;

! If an error occurred because of an access violation or an access conflict
! (trying to modify the ACL when only holding a read lock), return it.  Otherwise
! return any error that may have occurred during the ACL processing.

IF .STATUS THEN STATUS = .ACL_STATUS;

! Release the ACL mutex.

SCH$UNLOCK (.ACL_QUEUE_HEAD - $BYTEOFFSET (ORB$L_ACLFL) + $BYTEOFFSET (ORB$L_ACL_MUTEX), .CTL$GL_PCB);

RETURN .STATUS;

END;						! End of routine ACL_DISPATCH

%SBTTL	'RUNDOWN_CHANGE_ACL - run down $CHANGE_ACL context'
GLOBAL ROUTINE RUNDOWN_CHANGE_ACL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to perform the appropriate ACL operations.
!	The code is checked for validity and, when necessary, the buffer
!	is probed for the desired access.
!
! CALLING SEQUENCE:
!	RUNDOWN_CHANGE_ACL ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	PARENT_ID: lock ID of parent for ACL locks
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	All ACL locks taken out by user mode $CHANGE_ACL calls, plus the
!	parent lock, are dequeued.
!
!--

BEGIN

IF .PARENT_ID NEQ 0
THEN
    BEGIN
    $DEQ (LKID  = .PARENT_ID,
	  FLAGS = LCK$M_DEQALL);
    $DEQ (LKID  = .PARENT_ID);
    PARENT_ID = 0;
    END;

1
END;					! End of routine RUNDOWN_CHANGE_ACL

END
ELUDOM
