	.TITLE	DUDRIVER - DISK CLASS DRIVER
	.IDENT	'V04-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Robert Rappaport  11-May-1981
;
;  DISK CLASS DRIVER
;
; MODIFIED BY
;
;	V04-001	ROW0413		Ralph O. Weber		 6-SEP-1984
;		Add check in START_MOUNT_VER which causes SS$_VOLINV to be 
;		returned when a mount verification request is presented for a 
;		device which does not have UCB$V_VALID set.  Mount 
;		verification guarantees to have UCB$V_VALID set, even for the 
;		first IO$_PACKACK.  Therefore, when such an event occurs, 
;		mount verification needs to be informed.
;
;	V03-255	ROW0411		Ralph O. Weber		21-AUG-1984
;		Correct register usage in ROW0360 to reference UCB from R3 not 
;		R5.
;
;	V03-254	ROW0410		Ralph O. Weber		 6-AUG-1984
;		Setup use of UCB$V_CLUTRAN to guarantee that mount 
;		verification always runs for all disks after a VAXcluster 
;		state transition.
;
;	V03-253	ROW0400		Ralph O. Weber		21-JUL-1984
;		Eliminate waiting for write access to the I/O database mutex 
;		before calling DUTU$FAILOVER_UCB.  That routine will now wait 
;		for the mutex in its own fork thread.  This also prevents 
;		stalling requests due to lack of access to the mutex.  Since 
;		such requests can no longer stall, it is no longer possible to 
;		get a deadlock when, for example, a process holding the mutex 
;		must perform a page fault read in order to complete and 
;		release the mutex.
;
;	V03-252	ROW0399		Ralph O. Weber		21-JUL-1984
;		Add media-id to device type translation table entries for the 
;		RA82, RC26, RCF26, CDR50, RD53, RX31, RX32, and RX18.
;
;	V03-251	ROW0398		Ralph O. Weber		21-JUL-1984
;		Setup use of class driver write-lock bit in UCB$W_DEVSTS.  
;		Also eliminate alteration and use of DEV$V_SWL bit in 
;		UCB$L_DEVCHAR.  That bit is controlled by the file system.
;
;	V03-250	ROW0395		Ralph O. Weber		21-JUL-1984
;		Make changes which setup "normal" MSCP command timeout 
;		algorithm before calls to DUTU$POLL_FOR_UNITS.  Also setup 
;		use of DAP CDRP by DUTU$POLL_FOR_UNITS.
;
;	V03-249	ROW0394		Ralph O. Weber		21-JUL-1984
;		Remove DPT_STORE setting of ACL queue present bit in the ORB.
;		This should improve performance on devices which do not really 
;		have an ACL queue in their device protection ORB.
;
;	V03-248	ROW0389		Ralph O. Weber		 9-JUL-1984
;		Cause both mount verification requests and requests for 
;		devices which are not "volume valid" to fail during broken 
;		connection cleanup after their resources have been released.
;		This insures the requests from $MOUNT will fail if the 
;		connection to the remote MSCP server fails during processing 
;		of the $MOUNT command.
;
;	V03-247	ROW0388		Ralph O. Weber		 8-JUL-1984
;		Remove wait counter adjustment for possibly failed-over disk 
;		from DU_END_MNTVER.  Because of some race conditions, this 
;		adjustment must be done in DUTU$FAILOVER_UCB.
;
;	V03-246	ROW0387		Ralph O. Weber		 7-JUL-1984
;		Setup use of DUTU$RECONN_LOOKUP and DUTU$DRAIN_CDDB_CDRPQ.
;
;	V03-245	ROW0381		Ralph O. Weber		22-JUN-1984
;		Close a small window in volume not software enabled processing 
;		so that if there is any hope of getting an invalid volume back 
;		requests will wait until the volume returns.  Also add RD52 to 
;		media-id conversion table.
;
;	V03-244	ROW0377		Ralph O. Weber		 7-JUN-1984
;		Change order of bit test on DEV$V_2P and call to 
;		DUTU$DEALLOC_ALL in PACKACK_OFFLINE so that R0 (the return 
;		status) is not corrupted when the bit test branch is taken.
;
;		Correct branch destination in DU_REVALIDATE_DISKS to eliminate 
;		infinite loop when performing out-of-quorum processing for a 
;		non-multihost single pathed device.
;
;	V03-243	ROW0371		Ralph O. Weber		29-MAY-1984
;		Put a band-aid on problems related to the need to hold the I/O 
;		database mutex during a failover.  The band-aid is to 
;		eliminate waiting when there is not alternate path to which 
;		one can failover.
;
;	V03-242	ROW0369		Ralph O. Weber		22-MAY-1984
;		Change DU$RE_SYNCH to not do MRESET/MSTART to MSCP servers and 
;		then wait for something to happen.  Quite possibly, nothing 
;		ever will happen in such cases.  Proceeding directly to the 
;		DISCONNECT is the correct action.
;
;	V03-241	ROW0365		Ralph O. Weber		17-MAY-1984
;		Correct method for counting four passes through START_PACKACK 
;		when failover operations are attempted.
;
;	V03-240	ROW0361		Ralph O. Weber		 5-MAY-1984
;		Setup use of new class driver common DAP processing in 
;		DUTU$DODAP.  The new routine is designed to eliminate multiple 
;		concurrent DAP threads which are known to crash systems.
;
;	V03-239	ROW0360		Ralph O. Weber		 4-MAY-1984
;		Cause I/O requests to stall while a IO$_PACKACK is in progress 
;		by bumping RWAITCNT.  This corrects system crashes during 
;		booting where a paging I/O request gets SS$_VOLINV because the 
;		packack for SYSINITs mounting of the system disk is in 
;		progress.
;
;		Alter DU_REVALIDATE_DISKS for use in the stalling of all disk 
;		I/O activity whenever quorum is lost.  Change the routine 
;		itself to correctly handle being entered for quorum lost 
;		processing.  Cause the routine to be pointed to as the 
;		unsolicited interrupt routine.  Until a new DDT entry can be 
;		properly defined, this will allow the routine to be located by 
;		the connection manager quorum lost algorithm.
;
;	V03-238	ROW0359		Ralph O. Weber		 4-MAY-1984
;		Correct the $DISPATCH after PACKACK_OFFLINE to preserve R0 
;		which contains SS$_MEDOFL, a possible completion status.
;
;	V03-237	ROW0354		Ralph O. Weber		30-APR-1984
;		Add setting for DEV$M_NNM in DEVCHAR2 to indicate that tape 
;		class driver devices use NODENAME$DDCN device names.
;
;	V03-236	ROW0351		Ralph O. Weber		24-APR-1984
;		Correct MSCP offline processing in PACKACK so that spun-down 
;		drives return SS$_MEDOFL.
;
;	V03-235	ROW0350		Ralph O. Weber		23-APR-1984
;		Correct more problems causing multiple trips through 
;		END_SINGLE_STREAM, with the attendent bugchecks.  First, clear 
;		CDDB$V_SNGLSTRM upon entry to DU$CONNECT_ERR.  Second, protect 
;		the SCS$UNSTALLUCB loop in END_SINGLE_STREAM from possible 
;		connection failures during execution of the loop.
;
;	V03-234	LMP0237		L. Mark Pilant,		19-Apr-1984  11:23
;		Also initialize the size and type fields of the template ORB.
;
;	V03-233	LMP0235		L. Mark Pilant,		17-Apr-1984  13:54
;		Add a template ORB to be hooked up to the template UCB when
;		a new unit is initialized.
;
;	V03-232	ROW0345		Ralph O. Weber		11-APR-1984
;		Change replace logic so that a replace is not even attempted 
;		when the DEV$V_SWL bit is set in UCB$L_DEVCHAR.
;
;	V03-231	ROW0339		Ralph O. Weber		 8-APR-1984
;		Setup use of common invalid command processing routines 
;		(macros).  This replaces the old "form the original MSCP 
;		command packet by hand" algorithm with a "repeat the code 
;		which formed the original MSCP command" algorithm.  The cost 
;		is a single, hardly ever taken BLBS in the mainline read/write 
;		code path.  The savings are elimination of having to duplicate 
;		command packet setup changes in the invalid command case, 
;		hundreds of bytes of code, and a not inconsequential amount of 
;		static storage.
;
;	V03-230	ROW0338		Ralph O. Weber		 7-APR-1984
;		Setup use of DO_ACTION macro to replace INTERPRET_ACTION_TABLE.
;		Start using IF_MSCP where only success or failure of an MSCP 
;		command is being tested.  Setup use of ACTION_ENTRY END to end 
;		action tables.  Remove action table interpretation routines; 
;		they are now in DUTUSUBS.
;
;	V03-229	ROW0335		Ralph O. Weber		 4-APR-1984
;		Perform numerous class driver fixups and cleanups:
;		> Correct positioning of DPT_STORE REINIT and add note that 
;		  reinit is not significant because driver is not reloadable.
;		> Remove unitinit routine which was causing crashes after 
;		  power failures and replace it with a pointer to the new 
;		  routine in DUTUSUBS which does not have the power failure 
;		  problems.
;		> Remove usage of allocation class value in the SCS connect 
;		  accept message.  All MSCP servers now supply that 
;		  information in the Set Controller Characteristics command 
;		  end packet.
;		> Do not queue stalled I/O when UCB$V_VALID is clear and the 
;		  "stalled" request is not a physical function.
;		> Eliminate call to DU$ONLINE_COMPLETE whenever the ONLINE 
;		  command reports that the device was already online when the 
;		  command was issued.
;		> Remove unnecessary register saves and restores around calls 
;		  to DU$UNLOCK_HIRT.
;		> Add processing for IO$M_INHRETRY and IO$M_EXPRESS.  Also 
;		  rework read/write modifer testing so that only one test for 
;		  all possible modifers is in-line for the read/write path.  
;		  If any modifer is set, an out-of-line code segment 
;		  individually tests and processes the modifiers.
;		> Add the multi-host progress counter handling proposed by the 
;		  HSC implementors to DU$TMR.  This algorithm simplifies 
;		  handling of the case where the MSCP server is busy on an 
;		  older command from another host.
;
;	V03-228	ROW0331		Ralph O. Weber		30-MAR-1984
;		Setup use of common cancel support in DUTUSUBS.  Also make 
;		functions which use multiple MSCP commands check for cancel 
;		after each MSCP command and perform cancel if necessary.
;
;	V03-227	ROW0329		Ralph O. Weber		22-MAR-1984
;		Give up on preventing failover to a non-operational path as 
;		attempted in ROW0300, ROW0319, and ROW0328.  It does not work. 
;		Replace it with tests in DU_END_MOUNTVER which determine 
;		whether or not a pass through RESTART_NEXT_CDRP is in the 
;		cards for the current connection (at the time of mount 
;		verification completion).
;
;	V03-226	ROW0328		Ralph O. Weber		21-MAR-1984
;		Correct bugs in ROW0319 which caused it to incorrectly miss 
;		the end of the CDDB UCB chain.
;
;	V03-225	ROW0323		Ralph O. Weber		12-MAR-1984
;		Rework MSCP offline handling in PACKACK so that both "unknown" 
;		and "inoperative" subcodes cause failover attempts.
;
;	V03-224	ROW0319		Ralph O. Weber		28-FEB-1984
;		Attempt to eliminate failover to non-operational path by 
;		making clearing of CDDB$V_RECONNECT the last thing done in 
;		END_SINGLE_STREAM.  Also add sanity check that CDDB$V_RECONNECT 
;		is set before it is cleared.
;
;	V03-223	ROW0306		Ralph O. Weber		13-FEB-1984
;		Change end mount verification processing so that RWAITCNT 
;		reduction occurs whether or not mount verification succeeds.
;		This averts hangs produced by mount verification aborting 
;		after a failover occurs.
;
;	V03-222	ROW0302		Ralph O. Weber		10-FEB-1984
;		Add clearing of DEV$V_SWL to IO$_AVAILABLE and IO$_UNLOAD 
;		function processing.  This counteracts the effects of setting 
;		the bit in IO$_PACKACK processing.
;
;	V03-221	ROW0301		Ralph O. Weber		 9-FEB-1984
;		Remove clearing CDDB$V_NOCONN bit from MAKE_CONNECTION, this 
;		bit cannot be cleared until all UCBs chained to the CDDB have 
;		had their connection dependent fields updated to reflect the 
;		new connection.  In the re-connect code following the call to 
;		MAKE_CONNECTION, move the loop to test RWAITCNT in each 
;		chained UCB to before the call to DUTU$POLL_FOR_UNITS and add 
;		initialization of the connection dependent UCB fields to the 
;		operations performed by this loop.  After that loop, insert 
;		clearing the CDDB$V_NOCONN bit followed by the call to 
;		DUTU$POLL_FOR_UNITS.
;
;		These changes guarantee: 1. that mount verification thread 
;		will not attempt MSCP requests until AFTER the UCB connection 
;		dependent fields have be altered to reflect the current 
;		connection, 2. that the RWAITCNT test is made at a time when 
;		there is not active MSCP traffic on the connection (this is 
;		important because the test cannot account for RWAITCNT being 
;		bumped due to threads waiting on SCS resources), 3. that both 
;		mount verification and poll-for-units thread can proceed 
;		concurrently.
;
;		Some comments regarding the testing of for an empty queue of 
;		outstanding requests have been removed.  The test itself was 
;		removed in ROW0279 because mount verification threads can very 
;		well have outstanding requests at the time the test used to be 
;		made.
;
;	V03-220	ROW0300		Ralph O. Weber		 9-FEB-1984
;		Enhance DU_END_MNTVER to unbump RWAITCNT if the 
;		UCB$V_MSCP_WAITBMP flag is set.  This handles the case where 
;		mount verification has successfully failed a drive from a 
;		crashed controller to a working controller.
;
;	V03-219	ROW0298		Ralph O. Weber		 9-FEB-1984
;		Setup use of CDRP$W_ENDMSGSIZ to hold the size of an incomming 
;		sequenced message.  This replaces use of CDRP$L_IOST2+2 whose 
;		use causes valuable input information to be overwritten.
;
;	V03-218	ROW0296		Ralph O. Weber		 6-FEB-1984
;		Setup use of CDDB$V_RSTRTWAIT status bit in end-of-mount-
;		verification processing to tell whether or not to call 
;		RESTART_NEXT_CDRP.
;
;	V03-217	ROW0295		Ralph O. Weber		 6-FEB-1984
;		Set use of DUTU$CHECK_RWAITCNT, a routine which validates 
;		UCB$W_RWAITCNT and bug checks if it is wrong.
;
;	V03-216	ROW0294		Ralph O. Weber		 5-FEB-1984
;		Correct RECORD_STCON setup of allocation class information in 
;		the DDBs to use DDB$L_CONLINK so that only those DDBs on this 
;		connection are effected.
;
;	V03-215	ROW0293		Ralph O. Weber		 4-FEB-1984
;		Cleanup references to INIT_MSG_BUF and RECYCLE_ALL and remove 
;		them.  Restructure START_PACKACK so that the normal path is 
;		more linear.  In START_PACKACK, remove the notes about over-
;		riding a bad RCT as this can be done by write-locking the 
;		device and add a tests which rejects attempts to mount 576 
;		byte/sector disks.  Setup return of SS$_SHACHASTA for shadow 
;		set state change on all commands.
;
;	V03-214	ROW0287		Ralph O. Weber		22-JAN-1984
;		Make all remaining speed enhancements to mainline READ/WRITE 
;		path.  Setup support for IO$M_FORCERR modifier on WRITEs.
;
;	V03-213	ROW0286		Ralph O. Weber		22-JAN-1984
;		Cleanup all references to routines now moved to DUTUSUBS.  Fix 
;		usage of CDRP$V_ERLOGIP to be CDRP$V_ERLIP.
;
;	V03-212	ROW0285		Ralph O. Weber		21-JAN-1984
;		Move all host initiated replacement code, etc. to a seperate 
;		module, DUHIRT.
;
;	V03-211	ROW0283		Ralph O. Weber		16-JAN-1984
;		Take all reasonable steps to speed-up the mainline READ/WRITE 
;		path through the driver.  Eliminate taken branches and slow 
;		instructions.  Make I/O success case avoid call to 
;		INTERPRET_ACTION_TABLE.
;
;	V03-210	ROW0279		Ralph O. Weber		14-JAN-1984
;		Change mechanism for restoring units to online state after 
;		connection failure from use of BRING_UNIT_ONLINE to use of 
;		mount verification.  This includes a complete reworking of 
;		mount verification processing for the "normal" case too.  Also 
;		allow all unit failover to occur due to mount verification 
;		sending PACKACK requests to the driver.
;
;	V03-209	ROW0272		Ralph O. Weber		31-DEC-1983
;		Remove block which prevents issuing DAP requests from DU$TMR.  
;		Change START_DAP_THREAD to only send Determin Access Paths 
;		commands for those UCBs which are UCB$V_VALID.  MSCP servers 
;		will ignore DAP commands for units which are not MSCP online, 
;		so why should we send them.  Add block which prevents logging 
;		errors for DAP attention messages to ACCESS_PATH_ATTN.  This 
;		allows the code which logs DAP attention messages to remain 
;		and to be patched back into existance should it be needed.
;
;	V03-208	ROW0270		Ralph O. Weber		29-DEC-1983
;		Eliminate DRIVER_SEND_MSG_BUF by replacing all calls to it 
;		with SEND_MSCP_MSG DRIVER.  Change MAKE_CONNECTION to use the 
;		larger of HSTIMEOUT_ARRAY[controller_model] and the controller 
;		timeout value as the final host timeout value for the MSCP Set 
;		Controller Characteristics command.  Setup use of VMS SCS 
;		RECYCL_RSPID and FIND_RSPID_RDTE (except in DU$IDR where speed 
;		is desired).  Make all permanent/DAP CDRP to CDDB conversions 
;		use PERMCDRP_TO_CDDB.
;
;	V03-207	ROW0269		Ralph O. Weber		29-DEC-1983
;		Change DU_CONTROLLER_INIT to use DUTU$CREATE_CDDB.
;
;	V03-206	ROW0267		Ralph O. Weber		28-DEC-1983
;		Add IO$M_SHADOW modifier for IO$_PACKACK.  This is the PACKACK 
;		support for volume shadowing.
;
;	V03-205	ROW0262		Ralph O. Weber		24-NOV-1983
;		Move all UCB lookup and creation to DUTUSUBS.  Cleanup 
;		ATTN_MSG processing in DU$IDR.  Implement usage of $DUTUDEF, 
;		all device independent UCB fields, and the IOC$GL_DU_CDDB 
;		listhead.  Replace all DPT_STORE macros which init UCB fields 
;		with INIT_UCB macros.  INIT_UCB initializes both the DPT and 
;		the template UCB.  Its use eliminates possible mismatch of the 
;		two UCB sources as well as some setup code in the controller 
;		initialization routine.  Make driver not reloadable.  Change 
;		POLL_FOR_UNITS to DUTU$POLL_FOR_UNITS.
;
;	V03-204	ROW0261		Ralph O. Weber		22-NOV-1983
;		Move DUMP_COMMAND and DUMP_ENDMESSAGE to DUTUSUBS.  Change 
;		DU$END to DUTU$END so that linking with multiple modules does 
;		not involve a hack.  Do some common path cleanup to speed 
;		passage through the common code paths.  Change subroutine
;		CALL_SEND_MSG_BUF to SEND_MSCP_MSG macro.  Move INIT_TPLATE_UCB
;		to DUTULIB (macro library).
;
;	V03-203	RLRQBUS		Robert L. Rappaport	16-NOV-1983
;		Change building of transfer commands MSCP packet so that 
;		PQDRIVER can alter the mapping information during a map 
;		request and have the altered information appear in the MSCP 
;		packet.  Also fix a credit bug when invalid media addresses or 
;		buffer lengths are encountered.  In such cases, a NOP command 
;		must be sent to release the already allocated resources.
;
;	V03-202	ROW0253		Ralph O. Weber		12-NOV-1983
;		Change device dependent UCB definitions to work with globally 
;		defined MSCP extension to the UCB.  This change does not make 
;		use of all the UCB fields in the new extension.  It simply 
;		eliminates interactions which will prevent this module from 
;		building in the presence of the new UCB definitions.  The 
;		UCB$L_DU_MEDIATYP field, which was changed to UCB$L_MEDIA_ID 
;		ages ago, has also been eliminated.
;
;	V03-201	ROW0248		Ralph O. Weber		 8-NOV-1983
;		Remove setting of DEV$M_RCT from INIT_CONNDEP_UCB and change 
;		RECORD_UNIT_STATUS to set DEV$M_RCT if and only if the number 
;		of RCT copies is not zero.  This change causes the class 
;		driver to properly record the presence or absence of an RCT.  
;		It may break applications which were incorrectly using 
;		DEV$M_RCT as a signal that this was/is a MSCP disk.
;
;	V03-200	ROW0247		Ralph O. Weber		 2-NOV-1983
;		Correct inverted-sense branches in PACKACK_OFFLINE path added 
;		in ROW0231 to switch paths when a IO$_PACKACK fails and there 
;		is reason to believe the alternate path will work.
;
;	V03-199	ROW0245		Ralph O. Weber		17-OCT-1983
;		Correct couple of outstanding bugs:
;		 - Change DU$IDR to store incomming message size in 
;		   CDRP$L_IOST2+2.  This provides the message size to any code 
;		   requiring it.  In particular, the INVALID_STS and 
;		   RECORD_UNIT_STATUS fixes mentioned below use this feature.
;		 - Enhance RECORD_UNIT_STATUS to bugcheck if it produces zero 
;		   geometry information.
;		 - Fix INVALID_STS to properly place the size of the incomming 
;		   MSCP message in R1 before calling ERL$LOG_DMSCP.
;
;	V03-198	ROW0242		Ralph O. Weber		15-OCT-1983
;		Change unit attention processing in DU$IDR to skip altering 
;		UCB$M_DU_WAITBMP and UCB$W_RWAITCNT when the CDDB$M_INITING or 
;		CDDB$M_RECONNECT is set in CDDB$W_STATUS.  This prevents 
;		altering the wait count is such a way that the wait count 
;		tests in controller init and reconnection processing fail.  
;		Therefore, a spurous disk class driver bugcheck is eliminated.
;
;	V03-197	ROW0231		Ralph O. Weber		 1-OCT-1983
;		Fix several bugs:
;		o When a new DDB is created, either in CHAIN_UCB or 
;		  CHAIN_DUALPORT_UCB, force the initial UCB links both primary 
;		  and secondary to be zero (no chain exists yet).
;		o Change PACKACK function to try secondary path if primary 
;		  path ONLINE command fails with "unit unknown or online to 
;		  another controller."
;		o Fix PACKACK function to set DEV$M_SWL correctly whether or 
;		  not host initiated bad block replacement is in effect.
;		o Correct a couple of typographical errors in comments.
;
;	V03-196	ROW0229		Ralph O. Weber		24-SEP-1983
;		Make several changes which help SHOW DEVICE display 
;		information on dual pathed disks:
;		o Set the DEV$M_2P bit in UCB$L_DEVCHAR2 of all dual pathed 
;		  disks.  This allows dual pathed disks to be quickly 
;		  identified.
;		o When a local, non-MSCP disk also has a MSCP path, set the 
;		  DEV$M_CDP bit only in UCB$L_DEVCHAR2 of the UCB for the MSCP 
;		  path.  This allows differentiation between the local-path 
;		  and the MSCP-path UCBs.
;		o When a local, non-MSCP disk also has a MSCP path, fillin 
;		  UCB$L_DP_DDB in both UCBs.  This allows correct chaining 
;		  back to the system block in all cases.
;
;	V03-195	ROW0222		Ralph O. Weber		12-SEP-1983
;		o Change FDT to use EXE$LCLDSKVALID for IO$_PACKACK, 
;		  IO$_AVAILABLE, and IO$_UNLOAD processing.
;		o Move IO$_DSE entry higher in FDT to give it faster 
;		  processing.
;		o Change base of device dependent UCB to be UCB$K_LCL_DISK.  
;		o Move the testing for and setup of a local-dual-path UCB from 
;		  INIT_UCB to CHAIN_UCB, where we have a vaild DUDRIVER- 
;		  created DDB to test against.  
;		o Fix LOOKUP_LOCAL_UCB to use this DDB.
;		o If a local UCB exists for a MSCP served unit, mark the MSCP 
;		  served unit offline to make is unusable.  At this point, we 
;		  have no plans to allow it to be used, so make the UCB 
;		  reflect that fact.
;		o Correct bad stack offset in CHAIN_DUALPORT_UCB.  Also correct 
;		  starting DDB address so that a newly created DDB is linked 
;		  into the proper place.
;		o Rewrite INIT_CONNDEP_UCB to use only the UCB address input 
;		  and to fillin all fields based upon the primary path to the 
;		  device.
;		o Move call to INIT_CONNDEP_UCB for available attention 
;		  messages (in DU$IDR) to after call to CHAIN_UCB so that UCB 
;		  is properly initialized for INIT_CONNDEP_UCB.
;
;	V03-194	ROW0219		Ralph O. Weber		 7-SEP-1983
;		Make a couple of fixes for AZTEC.  Correct media-id 
;		information in MEDIA_ARRAY to represent RC25 and RCF25.  Fix 
;		no-unit-number error logging to "know" about AZTECs.  (This 
;		change is ENH and V3.5 BUG.)
;
;	V03-193	ROW0210		Ralph O. Weber		16-AUG-1983
;		Fix several bugs in LOOKUP_LOCAL_UCB.  Add call to 
;		IOC$CVTLOGPHY before transfering IRP to local driver at 
;		LOCAL_DEVICE.  Change allocation class setup to use VMSD2 as 
;		the allocation class for an HSC which has not specified an 
;		allocation class.  Prepare to set UCB$L_MAXBCNT, the maximum 
;		single transfer byte count, to 2**32-1.  We cannot actually 
;		set MAXBCNT now because it breaks MOUNT and INIT.  Add a 
;		branch which disables DAP commands but which can easily be 
;		patched out once they are working.
;
;	V03-192	ROW0208		Ralph O. Weber		13-AUG-1983
;		Fix IO$_DSE to have an FDT routine which copies P2 into 
;		UCB$L_BCNT and copies P3 into IRP$L_MEDIA.  (This change ENH 
;		only.)
;
;		Fix literal reference to EMB$C_INVSTS in INVALID_STS.  (This 
;		change ENH and V3.5 BUG.)
;
;	V03-191	ROW0205		Ralph O. Weber		 8-AUG-1983
;		Add device failover support.  Currently, this support is 
;		limited to FILES-11 devices.  This restriction will eventually 
;		have to be lifted.  However, work must be done to mount 
;		verification before the restriction can be lifted.
;
;		Primary modifications involved in adding failover support are
;		addition of a FAILOVER_DELTA driver parameter to specify the 
;		time we wait after a connection fails before attempting to do 
;		failover and addition of a call to DUTU$FAILOVER in 
;		MAKE_CONNECTION.  It was also necessary to prevent 
;		UCB$L_DU_CDDB from getting over written with the secondary 
;		CDDB address and to make CDDB$K_PERMCDRP_OFF a global symbol 
;		giving the offset from the CDDB base to the permanent CDRP 
;		base.
;
;	V03-190	RLRDSE2		Robert L. Rappaport	28-Jul-1982
;		Correct minor bugs in TRANSFER_INVALID_COMMAND that
;		incorrectly reproduced the opcode for IO$_DSE and
;		also incorrectly returned a Success status code.
;
;	V03-189	RLRDSE1		Robert L. Rappaport	26-Jul-1983
;		Add IO$_DSE to FDT tables.
;
;	V03-188	RLRODDBCNT	Robert L. Rappaport	22-Jul-1983
;		Test for odd bcnt in Host Memory Access Errors and
;		return SS$_IVBUFLEN in that case.
;
;	V03-187	RLRMEDIAID	Robert L. Rappaport	15-Jul-1983
;		Set UCB$L_MEDIA_ID in POLL_FOR_UNITS from data in
;		GET UNIT STATUS End Message.
;
;	V03-186	RLRCREDITBUG	Robert L. Rappaport	12-Jul-1983
;		Correct bug that allowed credits to go to zero.  Bug
;		was that we allocated a message buffer (and therefore
;		a credit) in STARTIO before testing the VOL_VALID bit.
;		We then simply deallocated the buffer without
;		disposing of the credit.
;
;	V03-185	RLRINVSTS	Robert L. Rappaport	1-Jul-1983
;		General set of changes to improve reliability.  These
;		include tolerating invalid MSCP status returns and
;		HOST Memory Buffer errors.  Also incorporate logging
;		of invalid ATTN messages, and RE-SYNCH after invalid
;		status returns.
;
;	V03-184	RLRDUALP1	Robert L. Rappaport	23-Jun-1983
;		First set of changes intended to support dual ported
;		devices.  Here we introduce the DU$_CDDB_CHAIN,
;		subroutines SCAN_UCB_CHAIN, and CHAIN_DUALPORT_UCB,
;		and introduce the DAPCDRP, (Determine Access Path).
;
;	V03-183	RLRCREDITa	Robert L. Rappaport	21-Jun-1983
;		Correct bug, discovered by Mike Masters in CX.  Fix
;		is in POST_CDRP, we must have R3=>UCB before calling
;		INIT_MSG_BUF.
;
;	V03-182	RLRDDB1		Robert L. Rappaport	21-Jun-1983
;		Additional change to previous update (RLRDDB) so
;		that the OrigUCB (Boot UCB) remains linked on its
;		DDB so as to enable it to be found by the ASSIGN
;		system service.
;
;	V03-181	RLRRWAITBUG	Robert L. Rappaport	17-Jun-1983
;		Correct bug in Cancel_IO Routine that decremented
;		RWAITCNT twice when we canceled CDRP that was
;		current HIRT owner.
;	V03-180	RLRALCLS2	Robert L. Rappaport	17-Jun-1983
;		Check for valid protocol type in Connect Data Message.
;
;	V03-179	RLRALCLS1	Robert L. Rappaport	3-Jun-1983
;		Correct typo in previous update.
;
;	V03-178	RLRALOCLS	Robert L. Rappaport	26-May-1983
;		Set CDDB$L_ALLOCLS and DBB$L_ALLOCLS from Connect
;		data.
;
;	V03-177	RLRUCBSZ	Robert L. Rappaport	25-May-1983
;		In ASSUME statement that tests size of UCB to that
;		of size of boot UCB (in DEVICEDAT.MAR), increase limit
;		to reflect growing of boot UCB in DEVICEDAT.MAR.
;
;	V03-176	RLRWRCHK	Robert L. Rappaport	19-May-1983
;		Correct error in handling IO$_WRITECHECK requests that
;		only allowed 512 BCNT and references within RCT.
;
;	V03-175	TCM0001		Trudy C. Matthews	4-May-1983
;		Set the DEV$V_CLU (device is available cluster-wide) bit
;		in INIT_UCB if the device is on a multi-host bus (i.e. CI).
;
;	V03-174	RLRNOLOG	Robert L. Rappaport	15-Apr-1983
;		Don't log Available Attention messages.
;
;	V03-173	RLRCANCELg	Robert L. Rappaport	1-Apr-1983
;		Correct bug in Cancel_IO Routine that affects CDRP's
;		on the HIRT Q and the CDRP that owns the HIRT.  Fix
;		is to DEALLOC_MSG_BUF the buffer owned by these CDRP's
;		prior to calling POST_CDRP.
;
;	V03-172	RLRRWCPTRa	Robert L. Rappaport	29-Mar-1983
;		Correct bug in RLRRWCPTR fix.
;
;	V03-171	RLRCANCELf	Robert L. Rappaport	29-Mar-1983
;		Initialize CDRP fields before deciding whether to
;		start this I/O request or whether to Q to mount
;		verification or UCB I/O Q.  This prevents misusing
;		uninitialized fields from being misinterpreted.  Bug
;		arose when an IRP traveled from I/O Queue to Mount
;		Verification Queue.  This fix supercedes RLRCANCELc.
;
;	V03-170	RLRDDB		Robert L. Rappaport	18-Mar-1983
;		Add support for multiple DDB's per connection.
;
;	V03-169	RLRRWCPTR	Robert L. Rappaport	4-Mar-1983
;		Test for zero UCB$L_RWCPTR in RDTWAIT_DIS_ACT and
;		in RDT_DIS_ACTION.  Such a situation could occur if
;		no RSPID's were available during a re-Connection and
;		if the re-Connection failed and we had to do a
;		re-re-Connection.  Also use Controller timeout for
;		host timeout value for those controllers for which
;		we care to set a host timeout.
;
;	V03-168	RLRIHIRT	Robert L. Rappaport	3-Mar-1983
;		Eliminate window in Controller initialization wherein
;		a timeout on the Set Controller Characteristics command
;		will cause us to neglect to call INIT_HIRT.
;
;	V03-167	RLRDSE		Robert L. Rappaport	28-Feb-1983
;		Add support for IO$_DSE.
;
;	V03-166	RLRTMUCB	Robert L. Rappaport	25-Feb-1983
;		Revamp Template UCB so as to be automatically compliant
;		with new UCB additions.
;
;	V03-165	RLRRDRX		Robert L. Rappaport	9-Feb-1983
;		Add RD/RX definitions in tables.  Also add patchable
;		extensions to tables.
;
;	V03-164	RLRCREDIT	Robert L. Rappaport	18-Jan-1983
;		Correct esoteric bug that could lose credits when do
;		Cancel I/O.  Basically, CDRP's that are CANCELED
;		(rather than ABORTED), that have already allocated
;		Message Buffers have no way of deallocating the
;		associated CREDIT.  The only solution is to have them
;		send a NOP message.
;		Also use CDDB$W_CNTRLTMO rather than INIT_IMMED_DELTA in
;		BRING_UNIT_ONLINE.
;		Also in REPLACE_LBN, after writting the TEST_PATTERN,
;		explicitly UNMAP and then reMAP before reading it back in.
;		Otherwise on 780's we will have buffered datapath problems.
;
;	V03-163	RLRONLIN	Robert L. Rappaport	28-Oct-1982
;		Add possible status returns from ONLIN command so that
;		unformatted disk does not cause crash.
;
;	V03-162	RLRCLINIT	Robert L. Rappaport	21-Oct-1982
;		Clear CDDB$M_INITING in Reconnection.
;
;	V03-161	RLRWAITBMP	Robert L. Rappaport	13-Oct-1982
;		Add UCB$M_DU_WAITBMP bit in UCB$W_DU_DEVSTS, which is
;		set iff the UCB$W_RWAITCNT has been bumped due to either
;		initialization or re-connection.  This allows to bump
;		(or not bump) the RWAITCNT in re-connection on a unit
;		by unit basis instead of on a connection basis.  This
;		prevents situations where during init or re-connect,
;		certain timeouts result in some but not all of the units
;		having their RWAITCNTs decremented.  Also increment
;		CDDB$W_RSTRTCNT each time we enter re-connection code.
;
;	V03-160	RLRBUNOL	Robert L. Rappaport	11-Oct-1982
;		Correct problem in Bring UNit OnLine, wherein we
;		might use the connection permanent CDRP to do
;		ONLINE_COMPLETE, and therefore bump the RWAITCNT
;		of this UCB.
;
;	V03-159	RLRPOLL		Robert L. Rappaport	8-Oct-1982
;		Make the polling of controller for units a callable
;		function rather than in line code executed at initialization
;		time only.  Also call it after re-connection.
;
;	V03-158	RLRMRESETb	Robert L. Rappaport	8-Oct-1982
;		Correct bug introduced in V03-055 which cleared R3=>CDDB
;		and then tested CDDB$W_STATUS bit.
;
;	V03-157	RLRIATTN	Robert L. Rappaport	5-Oct-1982
;		In ATTN_MSG ignore attentions during initialization.
;
;	V03-156	RLRMERSETa	Robert L. Rappaport	5-Oct-1982
;		Change calls to MRESET and MSTART to pass PB$B_RSTATION
;		instead of remote System ID.
;
;	V03-155	RLRRESYN	Robert L. Rappaport	4-Oct-1982
;		Let DU$RESYNCH setup R4 => PDT.
;
;	V03-154	RLRATTN		Robert L. Rappaport	29-Sep-1982
;		Correct error in Input Dispatcher Routine, wherein after
;		receipt and handling of an Attention message, R3 was no
;		longer pointing to the CDT.
;
;	V03-153	RLRUNLCK	Robert L. Rappaport	24-Sep-1982
;		Correct bug in UNLOCK_HIRT that attempts to return
;		to caller's caller when original CDRP has been
;		canceled.  Problem is that caller may have left data
;		on stack.  Solution is to have caller to UNLOCK_HIRT
;		check for zero in R5 and cleanup its own stack before
;		returning to its caller.
;		Note- version numbers incremented by 100 to distinguish
;		from .BUG version.
;
;	V03-052	ROW0128		Ralph O. Weber		22-SEP-1982
;		Modify template UCB to conform with new UCB structure.
;		WARNING:  this makes the enhancement version of this driver 
;		completely incompatible with V3.0.
;
;	V03-051	RLRPURGE	Robert L. Rappaport	17-Sep-1982
;		In WRITE_RCT_BLOCK and READ_RCT_BLOCK, do an explicit
;		MAP and UNMAP before each read or write so as to
;		force a needed datapath purge on UDA's on 780's.
;
;	V03-050	RLRTIMOUT	Robert L. Rappaport	10-Sep-1982
;		Allow for timing out of MAKE_CONNECTION.  That is,
;		if the number of seconds specified in SGN$GL_VMSD3
;		has past since we began to try to CONNECT, then
;		terminate all pending I/O with SS$_CTRLERR.  If this
;		SYSGEN parameter is zero, then such timeouts are
;		disabled and we do not terminate any I/O but rather
;		keep them pending until the CONNECTION is established.
;
;	V03-049	RLRMRESET	Robert L. Rappaport	8-Sep-1982
;		Changed order of MRESET and DISCONNECT so that an
;		explicit DISCONNECT is NOT done if we decide to MRESET.
;		We instead rely on the port drivers to call our error
;		entrypoint in order for the DISCONNECT to be done.
;		Therefore after MRESET we now RSB.
;
;	V03-048	RLRCANCELe	Robert L. Rappaport	27-Aug-1982
;		Modify TST_CANCEL_CDRP so as to NOT test for virtual
;		I/O requests.
;
;	V03-047	RLRCANCELd	Robert L. Rappaport	24-Aug-1982
;		Correct bug in CANCEL I/O wherein two cancels, in quick
;		succession, for a channel that had a CDRP that was doing
;		a replacement caused a crash.  Fix is to check for zero
;		in HIRT$L_SAVDCDRP of a busy HIRT.  This could occur if
;		we had already posted the owner but allowed the replacement
;		to run to completion.
;
;	V03-046	RLR0046		Robert L. Rappaport	22-July-1982
;		Changed references to UCB$L_DU_MEDIAID to UCB$L_MEDIA_ID.
;		Also changed references to DU_FORK_IPL to IPL$_SCS.
;
;	V03-045	RLRCANCELc	Robert L. Rappaport	7-July-1982
;		Correct bug in CANCEL I/O wherein we take an IRP off
;		the Mount Verification Q and call POST_IRP and the
;		IRP had never had its CDRP portion initialized.
;		Fix entails clearing CDRP$W_CDRPSIZE when INSQUEing
;		an uninitialized IRP onto Mount verification Q and
;		testing for this condition in POST_CDRP and then NOT
;		calling DEALLOC_RESOURCES for such a CDRP.
;
;	V03-044	RLRCANCELb	Robert L. Rappaport	7-July-1982
;		Correct re-CONNECT bug that left UCB$W_RWAITCNT zero.
;		Added new bit, CDRP$M_CANCELED, in CDRP$W_STS that
;		distinguishes all CDRP's that are in the process of
;		being canceled.  These CDRP's are necessarily queued
;		on either the CDRP$L_IOQFL or CDRP$L_ABCNT of some
;		Cancel CDRP.  In RDT_DIS_ACTION we check for this bit.
;
;	V03-043	RLRDEFS		Robert L. Rappaport	29-June-1982
;		Add $DCDEF, $IPLDEF, $PCBDEF, $PRDEF, $SSDEF, and $VADEF.
;
;	V03-042	RLRCANCELa	Robert L. Rappaport	24-June-1982
;		Correct minor bugs in CANCEL_IO.
;
;	V03-041	RLRECO13	Robert L. Rappaport	16-June-1982
;		Allow for long (not infinite) host timeouts on UDA.
;
;	V03-040	RLRCANCEL	Robert L. Rappaport	10-June-1982
;		Add CANCEL_IO functionality.
;
;	V03-039	RLRECO12	Robert L. Rappaport	7-June-1982
;		Eliminate extra UCB created by SYSGEN.  This entails
;		adding a bogus UNITINIT routine to be called that
;		only looks out for bogus UCB's and eliminates them.
;
;	V03-038	RLRECO11	Robert L. Rappaport	4-June-1982
;		Two corrections:
;		1. BRW to DU$RE_SYNCH as a result of an INIT_TIMEOUT.
;		2. Return proper success status if disk write-locked
;			on a PACKACK operation.  We were returning
;			SS$_WRITLCK.  ALso if ONLINE succeeds but
;			ONLINE_COMPLETE fails due to something other
;			than write-lock, make disk AVAILABLE.
;
;	V03-037	RLRECO10	Robert L. Rappaport	3-June-1982
;		Correct error introduced in RLRECO07 wherein MOVZWL
;		to HIRT$W_IOST also cleared next word (HIRT$W_STS).
;
;	V03-036	RLRECO09	Robert L. Rappaport	2-June-1982
;		Correct two problems:
;		1. In INSERT_RSTRTQ, do NOT (recursively) insert the
;		HIRT$L_SAVDCDRP if this CDRP is the connection permanent
;		CDRP.
;		2. Lengthen the connection permanent CDRP (appended to CDDB)
;		to the length of a normal CDRP (including an IRP prefix).
;		Also insure that this CDRP has a valid value in CDRP$L_UCB.
;		This is necessary to allow proper deallocation of map resources
;		that may have been put here due to re-CONNECT from HIRTCDRP
;		when we are running on the UDA port.  This port driver needs
;		to have access to a UCB in order to find the CRB.
;
;	V03-035	RLRECO08	Robert L. Rappaport	26-May-1982
;		Correct shift of FORCEDERROR subcode in
;		TRANSFER_DATA_ERROR.
;
;	V03-034	RLRECO07	Robert L. Rappaport	26-May-1982
;		Allow write locked disks to be MOUNTed.
;
;	V03-033	RLRECO06	Robert L. Rappaport	25-May-1982
;		Correct bug introduced in ECO01, wherein resetting
;		of Timeout Routine was done prematurely.
;
;	V03-032	RLRECO05	Robert L. Rappaport	20-May-1982
;		To protect against a sick controller, do UNMAPs for
;		collected CDRP's only after controller reset and
;		DISCONNECT done in re-CONNECT logic.  This is
;		done by having INSERT_RSTRTQ now call DEALO_MSG_RSPID,
;		which only deallocates these resources, and then
;		calling DEALLOC_RESOURCES for all collected CDRP's.
;		Also any mapping resources allocated by the HIRTCDRP
;		for this connection are copied to the connection
;		permanent CDRP which also has DEALLOC_RESOURCES called
;		for it at this same time.
;
;	V03-031	RLRECO04	Robert L. Rappaport	19-May-1982
;		In UNLOCK_HIRT, after call to GRANT_HIRT, resume thread
;		from HIRT$L_SAVDCDRP rather than from R5 => ReplaceCDRP
;		returned by GRANT_HIRT.
;
;	V03-030	RLRECO03	Robert L. Rappaport	19-May-1982
;		Return SS$_DRVERR to users of PACKACK and transfer
;		functions if MSCP$K_ST_MEDOFL is returned with
;		MSCP$V_SC_INOPR subcode also set.
;
;	V03-029	RLRECO02	Robert L. Rappaport	13-May-1982
;		1. Refresh R2 => End Message after ONLINE_COMPLETE in
;			BRING_UNIT_ONLINE.
;		2. Call SCS$UNSTALLUCB in UNLOCK_HIRT.
;		3. Refresh R2 => End Message after UNMAP in STEP7 of
;			REPLACE_LBN.
;		This change tracks patch to DUDRIVER in V3.1
;
;	V03-028	RLRECO01	Robert L. Rappaport	26-Apr-1982
;		In UNLOCK_HIRT,  do not reassign RSPID to user CDRP if
;		RSPID has been deallocated due to re-CONNECT. Also
;		re-establish DU$TMR as timeout routine after calling
;		MAKE_CONNECTION in re-CONNECTION.
;		This change tracks patch to DUDRIVER in V3.0
;
;
; MACRO LIBRARY CALLS
;

	$CDDBDEF			;Define CDDB offsets
	$CDRPDEF			;Define CDRP offsets
	$CDTDEF				;Define CDT offsets
	$CRBDEF				;Define CRB offsets
	$DCDEF				;Define Device Classes and Types
	$DDBDEF				;Define DDB offsets
	$DEVDEF				;Define DEVICE CHARACTERISTICS bits
	$DPTDEF				;Define DPT offsets
	$DYNDEF				;Define DYN symbols
	$EMBLTDEF			;Define EMB Log Message Types
	$FKBDEF				;Define FKB offsets
	$IDBDEF				;Define IDB offsets
	$IODEF				;Define I/O FUNCTION codes
	$IPLDEF				;Define IPL levels
	$IRPDEF				;Define IRP offsets
	$MSCPDEF			;Define MSCP packet offsets
	$MSLGDEF			;Define MSCP Error Log offsets
	$MTXDEF				;Define MUTEX offsets
	$ORBDEF				;Define ORB offsets
	$PBDEF				;Define Path Block offsets
	$PCBDEF				;Define PCB offsets
	$PDTDEF				;Define PDT offsets
	$PRDEF				;Define Processor Registers
	$RCTDEF				;Define RCT offsets
	$RDDEF				;Define RDTE offsets
	$RDTDEF				;Define RDT offsets
	$SBDEF				;Define System Block Offsets
	$SCSCMGDEF			;Define SCS Connect Message offsets
	$SSDEF				;Define System Status values
	$UCBDEF				;Define UCB offsets
	$VADEF				;Define Virtual Address offsets
	$VECDEF				;Define INTERRUPT DISPATCH VECTOR offsets
	$WCBDEF				;Define WCB offsets


	$DUTUDEF			;Define common class driver CDDB
					; extensions and other common symbols


; Constants

ALLOC_DELTA=1			; Number of seconds to wait to retry pool
				;  allocation that failed.
INIT_IMMED_DELTA=30		; During Controller Initialization, the
				;  timeout DELTA for immediate MSCP commands.
CONNECT_DELTA=10		; During Controller Initialization, the
				;  time interval for retrying failed
				;  CONNECT attempts.
HOST_TIMEOUT=30			; Host timeout value.

DISCONNECT_REASON=1
INITIAL_CREDIT=10
INITIAL_DG_COUNT=2
MAX_RETRY=2
MIN_SEND_CREDIT=2

;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
P1=0					;FIRST FUNCTION DEPENDENT PARAMETER
P2=4					;SECOND FUNCTION DEPENDENT PARAMETER
P3=8					;THIRD FUNCTION DEPENDENT PARAMETER
P4=12					;FOURTH FUNCTION DEPENDENT PARAMETER
P5=16					;FIFTH FUNCTION DEPENDENT PARAMETER
P6=20					;SIXTH FUNCTION DEPENDENT PARAMETER
	.PAGE
	.SBTTL	MACRO DEFINITIONS

;
; Expanded opcode macros - Branch word conditional psuedo opcodes.
;

;
; BWNEQ - Branch (word offset) not equal
;

	.MACRO	BWNEQ	DEST,?L1
	.SHOW
	BEQL	L1		; Branch around if NOT NEQ.
	BRW	DEST		; Branch to destination if NEQ.
L1:				; Around.
	.NOSHOW
	.ENDM	BWNEQ

;
; BWEQL - Branch (word offset) equal
;

	.MACRO	BWEQL	DEST,?L1
	.SHOW
	BNEQ	L1		; Branch around if NOT EQL.
	BRW	DEST		; Branch to destination if EQL.
L1:				; Around.
	.NOSHOW
	.ENDM	BWEQL

;
; BWBS - Branch (word offset) bit set.
;

	.MACRO	BWBS	BIT,FIELD,DEST,?L1
	.SHOW
	BBC	BIT,FIELD,L1		; Branch around if bit NOT set.
	BRW	DEST			; Branch to destination if bit set.
L1:					; Around.
	.NOSHOW
	.ENDM	BWBS

;
; BWBC - Branch (word offset) bit clear.
;

	.MACRO	BWBC	BIT,FIELD,DEST,?L1
	.SHOW
	BBS	BIT,FIELD,L1		; Branch around if bit NOT clear.
	BRW	DEST			; Branch to destination if bit clear.
L1:					; Around.
	.NOSHOW
	.ENDM	BWBC
	.PAGE
	.SBTTL	ASSUMES

; The following set of ASSUME statements will all be true as long as
;	the IRP and CDRP definitions remain consistent.

	ASSUME	CDRP$L_IOQFL-CDRP$L_IOQFL	EQ	IRP$L_IOQFL
	ASSUME	CDRP$L_IOQBL-CDRP$L_IOQFL	EQ	IRP$L_IOQBL
	ASSUME	CDRP$W_IRP_SIZE-CDRP$L_IOQFL	EQ	IRP$W_SIZE
	ASSUME	CDRP$B_IRP_TYPE-CDRP$L_IOQFL	EQ	IRP$B_TYPE
	ASSUME	CDRP$B_RMOD-CDRP$L_IOQFL	EQ	IRP$B_RMOD
	ASSUME	CDRP$L_PID-CDRP$L_IOQFL		EQ	IRP$L_PID
	ASSUME	CDRP$L_AST-CDRP$L_IOQFL		EQ	IRP$L_AST
	ASSUME	CDRP$L_ASTPRM-CDRP$L_IOQFL	EQ	IRP$L_ASTPRM
	ASSUME	CDRP$L_WIND-CDRP$L_IOQFL	EQ	IRP$L_WIND
	ASSUME	CDRP$L_UCB-CDRP$L_IOQFL		EQ	IRP$L_UCB
	ASSUME	CDRP$W_FUNC-CDRP$L_IOQFL	EQ	IRP$W_FUNC
	ASSUME	CDRP$B_EFN-CDRP$L_IOQFL		EQ	IRP$B_EFN
	ASSUME	CDRP$B_PRI-CDRP$L_IOQFL		EQ	IRP$B_PRI
	ASSUME	CDRP$L_IOSB-CDRP$L_IOQFL	EQ	IRP$L_IOSB
	ASSUME	CDRP$W_CHAN-CDRP$L_IOQFL	EQ	IRP$W_CHAN
	ASSUME	CDRP$W_STS-CDRP$L_IOQFL		EQ	IRP$W_STS
	ASSUME	CDRP$L_SVAPTE-CDRP$L_IOQFL	EQ	IRP$L_SVAPTE
	ASSUME	CDRP$W_BOFF-CDRP$L_IOQFL	EQ	IRP$W_BOFF
	ASSUME	CDRP$L_BCNT-CDRP$L_IOQFL	EQ	IRP$L_BCNT
	ASSUME	CDRP$W_BCNT-CDRP$L_IOQFL	EQ	IRP$W_BCNT
	ASSUME	CDRP$L_IOST1-CDRP$L_IOQFL	EQ	IRP$L_IOST1
	ASSUME	CDRP$L_MEDIA-CDRP$L_IOQFL	EQ	IRP$L_MEDIA
	ASSUME	CDRP$L_IOST2-CDRP$L_IOQFL	EQ	IRP$L_IOST2
	ASSUME	CDRP$L_TT_TERM-CDRP$L_IOQFL	EQ	IRP$L_TT_TERM
	ASSUME	CDRP$B_CARCON-CDRP$L_IOQFL	EQ	IRP$B_CARCON
	ASSUME	CDRP$Q_NT_PRVMSK-CDRP$L_IOQFL	EQ	IRP$Q_NT_PRVMSK
	ASSUME	CDRP$L_ABCNT-CDRP$L_IOQFL	EQ	IRP$L_ABCNT
	ASSUME	CDRP$W_ABCNT-CDRP$L_IOQFL	EQ	IRP$W_ABCNT
	ASSUME	CDRP$L_OBCNT-CDRP$L_IOQFL	EQ	IRP$L_OBCNT
	ASSUME	CDRP$W_OBCNT-CDRP$L_IOQFL	EQ	IRP$W_OBCNT
	ASSUME	CDRP$L_SEGVBN-CDRP$L_IOQFL	EQ	IRP$L_SEGVBN
	ASSUME	CDRP$L_JNL_SEQNO-CDRP$L_IOQFL	EQ	IRP$L_JNL_SEQNO
	ASSUME	CDRP$L_DIAGBUF-CDRP$L_IOQFL	EQ	IRP$L_DIAGBUF
	ASSUME	CDRP$L_SEQNUM-CDRP$L_IOQFL	EQ	IRP$L_SEQNUM
	ASSUME	CDRP$L_EXTEND-CDRP$L_IOQFL	EQ	IRP$L_EXTEND
	ASSUME	CDRP$L_ARB-CDRP$L_IOQFL		EQ	IRP$L_ARB
	.PAGE
	.SBTTL	DISK CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS

	$DEFINI	UCB,GLOBAL		; The GLOBAL is for DUHIRT.


. = UCB$K_MSCP_DISK_LENGTH
$DEF	UCB$L_DU_VOLSER	.BLKL	1	; Volume Serial number as returned
					;  in ONLINE end packet.

$DEF	UCB$L_DU_USIZE	.BLKL	1	; Size of user visible area of unit
					;  in logical blocks.
$DEF	UCB$L_DU_TOTSZ	.BLKL	1	; Size of unit including RCT area in
					;  logical blocks.
$DEF	UCB$W_DU_RCTSIZE
			.BLKW	1	; Size of the RCT in blocks.
$DEF	UCB$B_DU_RCTCPYS
			.BLKB	1	; Number of RCT copies on the unit.
$DEF	UCB$B_DU_RBNPTRK
			.BLKB	1	; RBN's per track.
$DEF	UCB$W_DU_LBNPTRK
			.BLKW	1	; LBN's per track.
$DEF	UCB$W_DU_TRKPGRP
			.BLKW	1	; Tracks per group.
$DEF	UCB$W_DU_GRPPCYL
			.BLKW	1	; Groups per cylinder.

UCB$K_DU_LENGTH=.

	$DEFEND	UCB

	ASSUME	UCB$K_DU_LENGTH		LE	UCB$K_LENGTH+160

;
; If the preceeding ASSUME macro breaks it is a signal that the Disk Class
;	Driver UCB has grown larger than the space allocated to the Boot
;	Device UCB in [SYS.SRC]DEVICEDAT.MAR.  The Boot Device UCB allocated
;	in DEVICEDAT is 40 longwords longer than the nominal UCB (whose length
;	is known symbolically as UCB$K_LENGTH).  This additional length is
;	meant to accomodate all possible idiosyncracies that individual disk
;	drivers might have.  To correct such an overgrowth in UCB size entails
;	enlarging the expansion area in the Boot Device UCB (beyond the 40
;	longwords) and the relevant correction to the above ASSUME macro.
;


	.SBTTL	Allocate Space for Template UCB

; Allocate zeroed space for template UCB and ORB.

	INIT_UCB size=UCB$K_DU_LENGTH
	INIT_ORB size=ORB$C_LENGTH
	.PAGE
	.SBTTL	DRIVER PROLOGUE AND DISPATCH TABLES (and UCB Initialization)
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;
 
	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=DUTU$END,-		; End of driver
		ADAPTER=NULL,-		; No Adapter
		FLAGS=<DPT$M_SCS -	; Driver requires that SCS be loaded
		      !DPT$M_NOUNLOAD>,-; Driver cannot be reloaded
		UCBSIZE=UCB$K_DU_LENGTH,-;Sysgen insists on making a UCB
		MAXUNITS=1,-		 ;Sysgen insists on making a UCB
		NAME=DUDRIVER			; Driver name
	DPT_STORE INIT				; Control block init values
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\>	; Default ACP name
	DPT_STORE DDB,DDB$L_ACPD+3,B,1		; ACP class


	; The following UCB initialization requests alter the template UCB
	; as well as producing equivalent DPT_STORE entries.  Thus both 
	; structures reflect the required initial UCB state and the UCBs 
	; initially processed by this driver are identical whether they are
	; produced by SYSGEN or by IOC$COPY_UCB.

	INIT_UCB	W_SIZE,WORD,UCB$K_DU_LENGTH
	INIT_UCB	B_TYPE,BYTE,DYN$C_UCB
	INIT_UCB	B_FIPL,BYTE,IPL$_SCS
	INIT_UCB	L_DEVCHAR,LONG,<<DEV$M_FOD!-
					 DEV$M_DIR!-
					 DEV$M_AVL!-
					 DEV$M_ELG!-
					 DEV$M_SHR!-
					 DEV$M_IDV!-
					 DEV$M_ODV!-
					 DEV$M_RND>>
	INIT_UCB	L_DEVCHAR2,LONG,<<DEV$M_CLU!-
					  DEV$M_MSCP!-
					  DEV$M_NNM>>
	INIT_UCB	B_DEVCLASS,BYTE,DC$_DISK
	INIT_UCB	W_DEVBUFSIZ,WORD,512
	INIT_UCB	W_RWAITCNT,WORD,1
	INIT_UCB	B_DIPL,BYTE,IPL$_SCS
	INIT_UCB	W_DEVSTS,WORD, <<UCB$M_NOCNVRT -
				      	!UCB$M_MSCP_INITING -
					!UCB$M_MSCP_WAITBMP>>

	; Initially the disk is made to look huge.  This prevents comparison 
	; errors and the MSCP server will catch any real problems.  Once the 
	; correct size is known or it has been determined that the size need 
	; not be known immediately, this value will be reduced.
	INIT_UCB	L_MAXBLOCK,LONG,<<^x7F000000>>

	; The following ORB initialization requests alter the template ORB
	; as well as producing equivalent DPT_STORE entries.  Thus both 
	; structures reflect the required initial ORB state and the ORBs 
	; initially processed by this driver are identical whether they are
	; produced by SYSGEN or by IOC$COPY_UCB.

	INIT_ORB	W_SIZE,WORD,ORB$C_LENGTH
	INIT_ORB	B_TYPE,BYTE,DYN$C_ORB
	INIT_ORB	B_FLAGS,BYTE,<< -
			    ORB$M_PROT_16>>	; SOGW protection word
	INIT_ORB	W_PROT,WORD,0		; default protection
	INIT_ORB	L_OWNER,LONG,0		; no owner as yet

	DPT_STORE REINIT		; Control block re-initialization values

	; N.B. Causing the following values to be setup during re-initializa-
	; tion is not significant because this driver cannot be reloaded.  
	; However, were the driver to be reloadable the following values would 
	; need to be re-initialized upon each driver reload.

	DPT_STORE CRB, -			; Controller init routine.
		CRB$L_INTD+VEC$L_INITIAL,D,DU_CONTROLLER_INIT
	DPT_STORE DDB,DDB$L_DDT,D,DU$DDT	; DDT address.

	DPT_STORE END
 
;
; DRIVER DISPATCH TABLE
;
 
	DDTAB	DEVNAM=DU,-		;DRIVER DISPATCH TABLE
		START=DU_STARTIO,-	;START I/O OPERATION
		FUNCTB=DU_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=DUTU$CANCEL,-	;CANCEL I/O ENTRY POINT
		DIAGBF=MSCP$K_MXCMDLEN+MSCP$K_LEN+20,-	; DIAG BUFF SIZE
		UNITINIT=DUTU$UNITINIT,-; Unit initialization routine.
		MNTVER=DU$MOUNTVER, -	; Mount Verification routine.
		UNSOLIC=DU_REVALIDATE_DISKS ; Quorum lost processing.
					; Use of the unsolicited interrupt
					; entry as defined above is a temporary
					; measure.  It will be changed when
					; a correct DDT entry can be defined.
	.PAGE
	.SBTTL	DISK CLASS DRIVER FUNCTION DECISION TABLE
;+
; DISK CLASS DRIVER FUNCTION DECISION TABLE
;-
 
DU_FUNCTABLE:				;Function Decision Table
	FUNCTAB	,-			; LEGAL FUNCTIONS
		<NOP,-			;  No operation
		UNLOAD,-		;  Unload (make available + spindown)
		AVAILABLE,-		;  Available (no spindown)
		PACKACK,-		;  Pack Acknowledge
		SENSECHAR,-		;  Sense Characteristics
		SETCHAR,-		;  Set Characteristics
		SENSEMODE,-		;  Sense Mode
		SETMODE,-		;  Set Mode
		WRITECHECK,-		;  Write Check
		READPBLK,-		;  Read  PHYSICAL Block
		READLBLK,-		;  Read  LOGICAL  Block
		WRITELBLK,-		;  Write LOGICAL  Block
		READVBLK,-		;  Read  VIRTUAL  Block
		WRITEVBLK,-		;  Write VIRTUAL  Block
		DSE,-			;  Data Security Erase
		ACCESS,-		;  Access file and/or find directory entry
		ACPCONTROL,-		;  ACP Control Function
		CREATE,-		;  Create file and/or create directory entry
		DEACCESS,-		;  Deaccess file
		DELETE,-		;  Delete file and/or directory entry
		MODIFY,-		;  Modify file attributes
		MOUNT>			;  Mount volume
	FUNCTAB	,-			; BUFFERED I/O FUNCTIONS
		<NOP,-			;  No Operation
		 UNLOAD,-		;  Unload (make available + spindown)
		 AVAILABLE,-		;  Available (no spindown)
		 PACKACK,-		;  Pack Acknowledge
		 DSE,-			;  Data Security Erase
		 SENSECHAR,-		;  Sense Characteristics
		 SETCHAR,-		;  Set   Characteristics
		 SENSEMODE,-		;  Sense Mode
		 SETMODE,-		;  Set   Mode
		 ACCESS,-		;  Access file and/or find directory entry
		 ACPCONTROL,-		;  ACP Control Function
		 CREATE,-		;  Create file and/or create directory entry
		 DEACCESS,-		;  Deaccess file
		 DELETE,-		;  Delete file and/or directory entry
		 MODIFY,-		;  Modify file attributes
		 MOUNT>			;  Mount volume
	FUNCTAB	+ACP$READBLK,-		; READ FUNCTIONS
		<READLBLK,-		;  Read LOGICAL Block
		 READPBLK,-		;  Read PHYSICAL Block
		 READVBLK>		;  Read VIRTUAL Block
	FUNCTAB	+ACP$WRITEBLK,-		; WRITE FUNCTIONS
		<WRITECHECK,-		;  Write Check
		 WRITELBLK,-		;  Write LOGICAL Block
		 WRITEVBLK>		;  Write VIRTUAL Block
	FUNCTAB	+ACP$ACCESS,-		;
		<ACCESS,CREATE>		; ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS>; DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;  ACP Control Function
		 DELETE,-		;  Delete file or directory entry
		 MODIFY>		;  Modify File Attributes
	FUNCTAB	DU$DSE_FDT,<DSE>	; Data Security Erase
	FUNCTAB	+ACP$MOUNT,<MOUNT>	; Mount Volume
	FUNCTAB	DU$SHADOW_PACKACK_FDT, -; Pack Acknowledge processing for 
		<PACKACK>		;  shadowed volume sets.  This must
					;  proceed EXE$LCLDSKVALID processing.
	FUNCTAB	+EXE$LCLDSKVALID, -	; Functions effecting UCB$V_VALID
		<PACKACK, -		;  Pack Acknowledge
		 AVAILABLE, -		;  Available (no spin-down)
		 UNLOAD>		;  Unload
	FUNCTAB	+EXE$ZEROPARM, -	; Zero parameter functions
		<NOP>			;  No Operation
	FUNCTAB	+EXE$SENSEMODE,-	;
		<SENSECHAR,-		;  Sense Characteristics
		 SENSEMODE>		;  Sense Mode
	FUNCTAB	+EXE$SETCHAR,-		;
		<SETCHAR,-		;  Set Characteristics
		 SETMODE>		;  Set Mode
	.PAGE
	.SBTTL	Static Storage
	.SBTTL	- Data Area Shared With Common Subroutines Module
;++
;
; Data Area Shared With Common Subroutines Module
;
; Functional Description:
;
;	This PSECT contains those constant (link-time) values which would 
;	otherwise be passed as arguments to the disk and tape class driver 
;	common routines in module DUTUSUBS.
;
;--

	.SAVE

	.PSECT	$$$220_DUTU_DATA_01 RD,WRT,EXE,LONG

	ASSUME	DUTU$L_CDDB_LISTHEAD EQ 0

;base + DUTU$L_CDDB_LISTHEAD			; Location containing the
						; address of the CDDB listhead
	.ADDRESS IOC$GL_DU_CDDB			; for CDDBs belonging to the 
						; disk device type

	.RESTORE
	.PAGE
	.SBTTL	- Media-id to Device Type Conversion Table
;++
;
; Media-id to Device Type Conversion Table
;
; Functional Description:
;
;	This table is used by DUTU$GET_DEVTYPE to convert a MSCP media 
;	identifier to a VMS device type.
;
;	Entries are made here in order of expected frequency of use.  This
;	speeds lookup for the more common cases.
;
;--

	MEDIA	<DU>, <RA80>
	MEDIA	<DU>, <RA81>
	MEDIA	<DJ>, <RA60>
	MEDIA	<DU>, <RA82>
	MEDIA	<DU>, <RD52>
	MEDIA	<DU>, <RD53>
	MEDIA	<DU>, <RD51>
	MEDIA	<DU>, <RX50>
	MEDIA	<DA>, <RC25>
	MEDIA	<DA>, <RCF25>
	MEDIA	<DA>, <RC26>
	MEDIA	<DA>, <RCF26>
	MEDIA	<DU>, <CDR50>
	MEDIA	<DB>, <RP06>
	MEDIA	<DR>, <RM05>
	MEDIA	<DR>, <RP07>
	MEDIA	<DR>, <RM80>
	MEDIA	<DR>, <RM03>
	MEDIA	<DR>, <RP08>, DT$_RP07HT
	MEDIA	<DB>, <RP05>
	MEDIA	<DB>, <RP04>
	MEDIA	<DM>, <RK07>
	MEDIA	<DM>, <RK06>
	MEDIA	<DU>, <RX31>
	MEDIA	<DU>, <RX32>
	MEDIA	<DU>, <RX18>
	MEDIA	<DL>, <RL02>
	MEDIA	<DL>, <RL01>
	MEDIA	<DY>, <RX04>
	MEDIA	<DY>, <RX02>
	MEDIA	<DX>, <RX01>
	MEDIA	<DD>, <TU58>
	MEDIA	<DQ>, <RB02>
	MEDIA	<DQ>, <RB80>
	MEDIA	<ML>, <ML11>
	.PAGE
	.SBTTL	Controller Initialization Routine

;+
; MSCP speaking intelligent controller initialization routine.
;
; INPUTS:
;	R4 => System ID of intelligent controller.
;	R5 => IDB
;	R6 => DDB
;	R8 => CRB for intelligent controller.
;

DU_CONTROLLER_INIT:
	BRB	0$			; Branch around breakpoint.
	JSB	G^INI$BRK		; Breakpoint for debugging.
0$:

; Check for CDDB already present.  If a CDDB is present, this call results
; from a power failure.  This driver performs power failure recovery as a
; result of virtual circuit closure notification.  No action need be taken
; here.

	TSTL	CRB$L_AUXSTRUC(R8)	; Is there a CDDB present?
	BEQL	5$			; Branch if CDDB is not present.
	RSB				; Else, just exit.

; Check that only one UCB is chained onto the input DDB.  This UCB could be
; the boot device UCB.  Therefore, make the UCB online so that I/O may be 
; performed on it.  All other initialization of the UCB is performed as the 
; result of DPT_STORE entries place in the INIT section of the DPT by the 
; INIT_UCB macro.

5$:
	MOVL	DDB$L_UCB(R6),R5	; R5 => first UCB if any.
	BISL	#UCB$M_ONLINE, -	; Set the possibly boot UCB online.
		UCB$L_STS(R5)
	TSTL	UCB$L_LINK(R5)		; Is there another UCB?
	BEQL	10$			; EQL implies no more UCB's.
	BUG_CHECK	DISKCLASS,FATAL	; For now.
10$:

; Setup those values which must be correct before IPL is lowered from 31.  
; Then FORK to create an IPL$_SCS fork thread which will complete controller 
; initialization.  Initialization of an MSCP server requires several message 
; exchanges and consumes several seconds.  Therefore, this work is conducted 
; in a fork thread with other system initialization proceeding concurrently.

	MOVL	R5, CRB$L_AUXSTRUC(R8)	; The UCB will act as a CDDB until the 
					; real one is built.
	MOVQ	(R4), -			; Setup remote system ID for call to
		UCB$Q_UNIT_ID(R5)	; DUTU$CREATE_CDDB.

	FORK				; Create initialization fork thread.

; Create and initialize the CDDB.

	BSBW	DUTU$CREATE_CDDB
;
; Here we call an internal subroutine which:
;
;	1. Makes a connection to the MSCP server in the intelligent
;		controller.
;
;	2. Sends an MSCP command to SET CONTROLLER CHARACTERISTICS.
;
;	3. Allocates an MSCP buffer and RSPID for our future use in
;		connection management.
;
; Upon return R4 => PDT and R5 => CDRP.
;

	MOVAL	CDDB$A_PRMCDRP(R5), R5	; Get permanent CDRP address.
	BSBW	MAKE_CONNECTION		; Call internal subroutine to make
					;  a connection to the MSCP server in
					;  the intelligent controller. Input
					;  and output are R5 => CDRP.

;
; Here we determine if the Controller is capable of performing Controller
;	initiated bad block replacement.  If so we branch around.  If not,
;	we call INIT_HIRT to initialize the HIRT (Host Intitiated Replacement
;	Table.
;

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3

	BBS	#MSCP$V_CF_REPLC,-	; See if Controller initiated replacement.
		CDDB$W_CNTRLFLGS(R3),90$;  If so, branch around.
	BSBW	DU$INIT_HIRT		; Initialize HIRT.

90$:	MOVL	CDDB$L_CRB(R3),R0	; Get CRB address.
	MOVAB	W^DU$TMR, -		; Establish permanent timeout routine.
		CRB$L_TOUTROUT(R0)
	MOVZWL	CDDB$W_CNTRLTMO(R3), R1	; Get controller timeout interval.
	ADDL3	R1, G^EXE$GL_ABSTIM, -	; Use that to set next timeout 
		CRB$L_DUETIME(R0)	; wakeup time.

	; The normal MSCP timeout mechanism is now in effect.  Henceforth,
	; no fork thread may use the CDDB permanent CDRP as a fork block.

	ASSUME	CDDB$V_DAPBSY GE 8
	BISB	#<CDDB$M_DAPBSY @ -8>, -; Set DAP CDRP in use flag.
		CDDB$W_STATUS+1(R3)
	MOVL	CDDB$L_DAPCDRP(R3), R5	; Get DAP CDRP address.
	BSBW	DUTU$POLL_FOR_UNITS	; Poll controller for units.

	BICW	#<CDDB$M_NOCONN -	; Clear no-connection and 
		 !CDDB$M_DAPBSY>, -	; DAP-CDRP-busy flags.
		CDDB$W_STATUS(R3)

	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB in R5.
		 -CDDB$L_UCBCHAIN>, -
		R3, R5

100$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Get next UCB if any in R5.
	BEQL	130$			; EQL implies no more UCB's.
	BICW	#UCB$M_MSCP_WAITBMP, -	; Indicate RWAITCNT no longer bumped.
		UCB$W_DEVSTS(R5)
	DECW	UCB$W_RWAITCNT(R5)	; Decrement wait reason count.
	BEQL	120$			; If count is zero, startup I/O.
	BSBW	DUTU$CHECK_RWAITCNT	; Else, check for vaild wait count.
120$:	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers before call.
	JSB	G^SCS$UNSTALLUCB	; Startup any queued up I/O requests.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers after call.
	BRB	100$			; Loop back to test more UCB's (if any).

130$:	BICW	#CDDB$M_INITING, -	; Clear the "initing" bit.
		CDDB$W_STATUS(R3)
	RSB				; Terminate this thread of execution.

INIT_TIMEOUT:				; Controller Init Timeout handler.
	BRW	DU$RE_SYNCH		; If we timeout, try to restart.
	.PAGE
	.SBTTL	MAKE_CONNECTION

; MAKE_CONNECTION - Internal subroutine, called from DU_CONTROLLER_INIT and
;	DU$CONNECT_ERR, that establishes a connection to the MSCP server
;	in the intelligent controller.
;
; INPUTS:
;	R5 => permanent CDRP
;
; OUTPUTS:
;	Connection established and initial SET CONTROLLER CHARACTERISTICS
;	command is sent to controller.  Also an MSCP buffer and an RSPID
;	are allocated for the connection.
;
;	Side effects include the fact that all registers, except R5, are
;	modified.
;

CLASS_DRVR_NAME:	.ASCII	/VMS$DISK_CL_DRVR/
MSCP_SRVR_NAME:		.ASCII	/MSCP$DISK       /

HSTIMEOUT_ARRAY:			; Host timeouts for various controllers.
	ASSUME	MSCP$K_CM_HSC50	EQ	1
	ASSUME	MSCP$K_CM_UDA50	EQ	2
	ASSUME	MSCP$K_CM_RC25	EQ	3
	ASSUME	MSCP$K_CM_EMULA	EQ	4
	ASSUME	MSCP$K_CM_TU81	EQ	5
	ASSUME	MSCP$K_CM_UDA52	EQ	6
	ASSUME	MSCP$K_CM_RDRX	EQ	7
	.BYTE	HOST_TIMEOUT		; Use default constant for HSC50.
	.BYTE	255			; Long timeout for dedicated controller
					;  (UDA50) with dual portable drives.
	.BYTE	0			; Use zero for dedicated controller.(AZTEC)
	.BYTE	HOST_TIMEOUT		; Use default constant for Emulator.
	.BYTE	0			; Use zero for dedicated controller.(TU81)
	.BYTE	255			; Long timeout for dedicated controller
					;  (UDA52) with dual portable drives.
	.BYTE	0			; Use zero for dedicated controller.(RD/RX)
	.BYTE	0			; Patch space for expansion
	.BYTE	0
	.BYTE	0

MAKE_CONNECTION:

	PERMCDRP_TO_CDDB -		; Get CDDB address form CDRP.
		cdrp=R5, cddb=R2
	POPL	CDDB$L_SAVED_PC(R2)	; Save caller's return in CDDB field.

10$:
	CONNECT	DU$IDR,-		; Entry point of Input Dispatcher Routine.
		DU$DGDR,-		; Entry point of Datagram Dispatcher.
		DU$CONNECT_ERR,-	; Error entry point.
		CDDB$B_SYSTEMID(R2),-	; Destination SYSTEM ID.
		,-			; Remote station address.
		MSCP_SRVR_NAME,-	; MSCP server name.
		CLASS_DRVR_NAME,-	; Ascii of class driver name.
		#INITIAL_CREDIT,-	;  Needs definition
		#MIN_SEND_CREDIT,-	; Minimum send credit
		#INITIAL_DG_COUNT,-	; Initial DataGram count
		,-			; Block transfer priority
		,-			; Connect data
		(R2),-			; Also pass CDDB address to CDT$L_AUXSTRUC
		,			; Bad Response packet address

	BLBS	R0,30$			; LBS implies success, so branch around.

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3
	MOVL	CDDB$L_CRB(R3), R3	; Get CRB address.
	MOVAB	B^20$,CRB$L_TOUTROUT(R3); Establish LABEL as place to call, for
					;  now, for periodic wakeups.
	ADDL3	#CONNECT_DELTA,-	; Establish Due time as a little in
		G^EXE$GL_ABSTIM,-	;  the future.
		CRB$L_DUETIME(R3)
	RSB				; Return to caller's caller and kill
					;  this thread.
20$:
	MOVL	CRB$L_AUXSTRUC(R3),R2	; R2 => CDDB.
	MOVAB	CDDB$A_PRMCDRP(R2),R5	; Get permanent CDRP address.
	SETIPL	#IPL$_SCS		; Lower IPL after wakeup.
	BRW	10$			; Loop back and try CONNECT again.
30$:	; A connection has been established
	PERMCDRP_TO_CDDB -		; Get CDDB address from CDRP.
		cdrp=R5, cddb=R1
	MOVL	R3, CDDB$L_CDT(R1)	; Save CDT address (in perm CDRP).
	MOVL	R4, CDDB$L_PDT(R1)	; Save PDT address.
	MOVL	R3, CDDB$L_DAPCDT(R1)	; Save CDT address in DAP CDRP too.
	MOVL	R1, R3			; Now that CDT is saved, move CDDB addr.

	MOVL	CDDB$L_CRB(R3), R1	; Get CRB address.
	MNEGL	#1, CRB$L_DUETIME(R1)	; Infinite time till next timeout, now.
	MOVAB	INIT_TIMEOUT, -		; Establish timeout routine that will
		CRB$L_TOUTROUT(R1)	; serve for rest of controller init.

;
; Here we prepare to send a SET CONTROLLER CHARACTERISTICS MSCP Packet to
;	the intelligent controller over the connection that we have just
;	established.
;

	ALLOC_RSPID			; ALLOCate a ReSPonse ID.
	ALLOC_MSG_BUF			; Allocate an MSCP buffer (and also
					;  allocate a unit of flow control).
	BLBS	R0,50$			; If success, branch around.
	MOVL	CDDB$L_CRB(R3),R3	; DU$RE-SYNCH expects R3 => CRB.
	BRW	DU$RE_SYNCH		; If we fail, try to restart.
50$:					; Here R2 => MSCP buffer allocated.
	CLRL	R1			; First set Controller Characteristics
					;  with zero (i.e. infinite) host timeout.
	BSBB	PRP_STCON_MSG		; Call to prepare MSCP command.
	SEND_MSCP_MSG DRIVER		; Returns with end-message addr. in R2.
	BSBW	RECORD_STCON		; Record Controller Characteristics.

	RECYCH_MSG_BUF			; We recycle the END PACKET and
					;  thereby allocate a new send credit.
	RECYCL_RSPID			; We also recycle the RSPID.

; Determine the correct host timeout interval.  This is the larger of 
; HSTIMEOUT_ARRAY[controller_model] and the controller timeout interval 
; returned by the just completed Set Controller Characteristics.  There is, 
; however, one wrinkle.  Zero represents an infinite timeout and therefore is 
; larger than any other number.  Also, the controller already believes the 
; host timeout interval to be infinite, as the result of the previous Set 
; Controller Characteristics command.  Therefore, no further action need be 
; taken when the timeout interval is infinite.

	MOVZBL	CDDB$B_CNTRLMDL(R3),R1	; Get controller model type.
	MOVZBL	HSTIMEOUT_ARRAY-1[R1],R1; Get corresponding host timeout value.
	BEQL	60$			; If zero, branch around.
	MOVZWL	CDDB$W_CNTRLTMO(R3), R0	; Get controller timeout interval.
	BEQL	60$			; If controller timeout is infinite,
					; use already set infinite host timeout.
	CMPL	R0, R1			; Compare with HSTIMEOUT_ARRAY value.
	BLSSU	55$			; Branch if HSTIMEOUT_ARRAY is larger.
	MOVL	R0, R1			; Else, use controller timeout as
					; host timeout interval.
55$:
	BSBB	PRP_STCON_MSG		; Else reset controller characteristics.
	SEND_MSCP_MSG DRIVER		; Returns with end-message addr. in R2.
	BSBB	RECORD_STCON		; Record Controller Characteristics.
	RECYCH_MSG_BUF			; Again we recycle the END PACKET and
					;  thereby allocate a new send credit.
	RECYCL_RSPID			; We also recycle the RSPID.
60$:

	JMP	@CDDB$L_SAVED_PC(R3)	; Return to caller.
	.PAGE
; PRP_STCON_MSG - Prepare a Set Controller Characteristics Command Message.
;
; Inputs:
;	R1 =  Host Timeout Value
;	R2 => MSCP buffer to fill
;	R3 => CDDB
;	R5 => CDRP
;

PRP_STCON_MSG:

	PUSHL	R1			; Save important register.
	INIT_MSCP_MSG			; Initialize buffer for MSCP message.
	POPL	R1			; Restore important register.

	MOVB	#MSCP$K_OP_STCON,-	; Insert SET CONTROLLER CHARACTERISTICS
		MSCP$B_OPCODE(R2)	;  opcode with NO modifiers.

	MOVW	CDDB$W_CNTRLFLGS(R3),-	; Set host settable characteristics
		MSCP$W_CNT_FLGS(R2)	;  bits into MSCP command message.

	MOVW	R1,MSCP$W_HST_TMO(R2)	; Set host timeout into MSCP packet.

	MOVQ	G^EXE$GQ_SYSTIME,-	; Transmit time of century in clunks.
		MSCP$Q_TIME(R2)

	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	MOVZWL	CDDB$W_CNTRLTMO(R3),-(SP); Pickup controller delta.
	BNEQ	70$			 ; NEQ implies this controller has been
					 ;  init'ed at least once before.
	MOVL	#INIT_IMMED_DELTA,(SP)	 ; Else use compiled in timeout.
70$:
	ADDL3	(SP)+,-			 ; Establish delta time for time out
		G^EXE$GL_ABSTIM,-	;  to prevent against controller never
		CRB$L_DUETIME(R0)	;  responding.

	RSB				; Return to caller.
	.PAGE
; RECORD_STCON - Record data from a Set Controller Characteristics end message
;		in the CDDB.
;
; Inputs:
;	R2 => MSCP End Message
;	R3 => CDDB


RECORD_STCON:
	MOVW	MSCP$W_CNT_FLGS(R2),-	; Pickup NON-host settable characteristics
		CDDB$W_CNTRLFLGS(R3)	;  from END PACKET and save in CDDB.

	MOVW	MSCP$W_CNT_TMO(R2),-	; Likewise with controller timeout.
		CDDB$W_CNTRLTMO(R3)

	MOVQ	MSCP$Q_CNT_ID(R2),-	; Also save controller unique ID.
		CDDB$Q_CNTRLID(R3)

	BBSS	#CDDB$V_ALCLS_SET, -	; Branch if allocation class already
		CDDB$W_STATUS(R3), 90$	; set, and indicate it is now set.

	; The allocation class is about to be set for this device.  The object
	; is to give every reasonable chance for the value to be non-zero.
	MOVL	G^CLU$GL_ALLOCLS, -	; Assume a local, single host 
		CDDB$L_ALLOCLS(R3)	; controller.
	BBC	#MSCP$V_CF_MLTHS, -	; Branch if a single host controller.
		CDDB$W_CNTRLFLGS(R3), -
		80$
	MOVZBL	MSCP$B_CNT_ALCS(R2), -	; Get set controller characteristics
		CDDB$L_ALLOCLS(R3)	; allocation class.
80$:	MOVAB	<CDDB$L_DDB -		; Init loop through all DDBs.
		-DDB$L_CONLINK>(R3), R0
82$:	MOVL	DDB$L_CONLINK(R0), R0	; Link to next DDB.
	BEQL	90$			; Branch if no more DDBs.
	MOVL	CDDB$L_ALLOCLS(R3), -	; Copy allocation class to this
		DDB$L_ALLOCLS(R0)	; DDB.
	BRB	82$			; Loop till no more DDBs.

90$:	RSB
	.PAGE
	.SBTTL	DU_REVALIDATE_DISKS - Revalidate previously online disks
;++
;
; DU_REVALIDATE_DISKS - Revalidate previously online disks
;
; Functional Description:
;
;	This routine supervises the revalidation of all disks which once were 
;	valid (online) but which have gone offline due to a connection 
;	failure.  This routine is also called whenever the connection manager 
;	wishes to stall all disk I/O activity by forcing all disks into mount 
;	verification.  The first case is distinguished from the second by the 
;	CDDB$V_QUORLOST bit in CDDB$W_STATUS being clear.
;
;	For each device not already in mount verification whose UCB has the 
;	UCB$V_VALID bit set in UCB$L_STS, mount verification is invoked.  
;	Mount verification is started by feeding it one of the permanent 
;	CDRP's associated with the CDDB and an appropriate error status.
;
;	If mount verification cannot be performed on the device (for example 
;	the device is mounted foreign),  then all pending I/O requests for the 
;	device are located and terminated with SS$_MEDOFL, medium offline.
;
;	This routine is only interested in getting mount verification started 
;	wherever possible.  If mount verification can be started it will 
;	complete in one of the following ways:
;
;	    -	A suitable alternate path will be found.  This can happen even 
;		before a new connection is established for this CDDB.
;
;	    -	The connection associated with this CDDB will be reestablished 
;		and access to the device via that connection restored.
;
;	    -	Mount verification will timeout or otherwise abort.
;
;	All of these cases are handled in DU_END_MOUNTVER.
;
;	    - 	Successful completion of mount verification (with RWAITCNT 
;		equal to zero) causes the UCB to be unstalled and I/O activity 
;		to be resumed.
;
;	    -	When mount verfication completes successfully but the RWAITCNT 
;		is not zero, the UCB is not unstalled.  That duty befalls 
;		whomever has bumped RWAITCNT.  
;
;	    -	If mount verification aborted, all pending I/O requests must 
;		be located and terminated with SS$_VOLINV.
;
; Synchronizing Device Revalidation After a Connection Failure
;
;	For each UCB placed into mount verification, this routine increments a 
;	counter in the CDDB which represents the failed connection.  The UCB 
;	is also made to point to this CDDB.  After reestablishing a connection 
;	and polling for units, the reconnection routine determines whether or 
;	not any UCBs are still waiting for mount verification via the new 
;	connection.
;
;	If no UCBs are waiting, the single step processing CDRPs active at the 
;	time the connection failed begins immediately.  Otherwise, the 
;	reconnection thread exits, to wait for the pending mount verification 
;	operations to complete.
;
;	As a UCB completes mount verification, the end mount verification 
;	routine uses the CDDB pointer setup by this routine to locate the CDDB 
;	which is waiting for mount verification completion.  The counter of 
;	waiting UCBs in that CDDB is reduced by one (representing the UCB 
;	which just finished mount verification).  When that count reaches zero, 
;	the reconnection logic thread is resumed at RESTART_NEXT_CDRP.  
;
;	In this way, all the CDRPs active at the time of the connection 
;	failure (which may have been due to a insane server) can be retried 
;	one at a time after the connection has been restored and the disks 
;	(or UCBs) validated by mount verification.  This is an important 
;	element of error recovery for MSCP devices.
;
;	N.B. CDRPs for disks failed over to an alternate controller do not 
;	participate in this single step retry mechanism, but by treating all 
;	types of mount verification completetion equally, waiting 
;	unnecessarily for a failed over disk is avoided.
;
;	Since this routine is called from both reconnection processing on 
;	controller initialization and since having RESTART_NEXT_CDRP entered 
;	due to controller initialization is very undesirable, this routine 
;	does not set UCB$L_WAIT_CDDB when the CDDB$V_INITING flag is set in 
;	the input CDDB.  This effectively eliminates the chain of events which 
;	would cause RESTART_NEXT_CDRP to be called.
;
;	Consider a few cases:
;
;	The connection fails for a device which has been chugging along and 
;	has some requests outstanding.  The outstanding requests are placed on 
;	the CDDB restart queue.  Mount verification begins throwing requests 
;	at the driver.  These requests complete quickly because no connection 
;	is active and no alternate path is available.  The UCB points to the 
;	CDDB which it turn is waiting for mount verification to complete for 
;	the UCB.  When the connection is restored, the reconnect thread notices
;	the waiting UCB as exits before restarting the pending CDRPs.  This 
;	leaves the wait count bumpped by 2, one for the mount verification and 
;	one for the incomplete reconnection thread.  When mount verification 
;	completes, the waint count is reduced by one to one, but this is not 
;	sufficient to unstall any pending requests (those received while the 
;	connection was broken).  Eventually, the end mount verification 
;	routine finds no more waiting UCBs on the CDDB and the single step 
;	delivery of requests begins.  Once all outstanding requests (from the 
;	time of the connection failure) have been singly passed to the server, 
;	the wait count is reduced by one to zero, this allows the pending 
;	requests to be starting (in parrallel mode).  If the device can 
;	failover to another server or if mount verification aborts, 
;	outstanding requests are removed from the CDDB restart queue and the 
;	end of mount verification processing is performed as described above.
;
;	If mount verification were already in progress when the connection 
;	failed, there is no need to begin it again for recovery after the 
;	connection reforms.  Also, the CDDB need not wait for mount 
;	verification to complete on the new connection before starting single 
;	step delivery of outstanding requests.  The only possible outstanding 
;	request is from mount verification.  All other requests are on the 
;	pending I/O queue.  When the connection fails, the mount verification 
;	I/O request is either active or inactive.  If it is active, it will be 
;	queued for post processing with a status of SS$_MEDOFL.  If it is 
;	inactive, the next attempt to make a mount verification request will 
;	be caught by the start I/O routine.
;
; Inputs:
;
;	R3	CDDB address
;
; Implicit inputs:
;
;	CDDB$L_UCBCHAIN(R3)	chain of UCBs on this connection
;	CDDB$W_STATUS(R3)	CDDB$V_INITING set if called from controller 
;				initialization.
;				CDDB$V_QUORLOST set if called to force mount 
;				verification after a quorum loss.
;
; Outputs:
;
;	R3	CDDB address (unchanged)
;
;	R0 - R2, and R4 - R5 are destroyed.
;	All other registers are preserved.
;
; Implicit outputs:
;
;	CDDB$L_WTUCBCTR(R3)	incremented once for each UCB waiting for 
;				mount verification to complete.
;	UCB$L_WAIT_CDDB		of each waiting UCB is made to point to the 
;				input CDDB.
;--

DU_REVALIDATE_DISKS:

	ADDL3	#<CDDB$L_UCBCHAIN - 		; Get "previous" UCB address.
		 -UCB$L_CDDB_LINK>, R3, R5

NEXT_REVAL_UCB:

	MOVL	UCB$L_CDDB_LINK(R5), R5		; Link to next UCB on conn.
	BEQL	REVAL_STARTED			; Branch if no more UCBs.
10$:	BBC	#UCB$V_VALID, UCB$L_STS(R5), -	; Does UCB need revalidation?
		NEXT_REVAL_UCB			; Branch if no revalidation.
	BBS	#UCB$V_MSCP_MNTVERIP, -		; Is mount verification already
		UCB$W_DEVSTS(R5), -		; in progress?
		NEXT_REVAL_UCB			; Branch if mv in progress.
	BBC	#CDDB$V_QUORLOST, -		; Branch if not quorum lost
		CDDB$W_STATUS(R3), 30$		; processing.

	; For quorum lost processing, this routine is called for all disk
	; CDDBs known to the system.  It must then decide whether or not the 
	; UCBs hanging off those CDDBs must have their I/O requests stalled.
	; The rule is that any disk accessible from more than one host must 
	; have its I/O stalled.  The following tests implement that rule.

	BBS	#MSCP$V_CF_MLTHS, -		; Branch if this is a multi-
		CDDB$W_CNTRLFLGS(R3), 25$	; host controller.
	BBC	#DEV$V_2P, -			; Branch if disk is not
		UCB$L_DEVCHAR2(R5), -		; dual-pathed.
		NEXT_REVAL_UCB

25$:	ASSUME	UCB$V_CLUTRAN GE 16		; Since this disk needs MV after
	BISB	#<UCB$M_CLUTRAN @ -16>, -	; a VAXcluster state transition,
		UCB$L_STS+2(R5)			; set UCB$V_CLUTRAN.

30$:	; Mount verification needs to be called for this device (or UCB).  
	; Understanding what follows requires several pieces of information:
	;
	;   1.	Mount verification returns to its caller only if it cannot 
	;	perform verification for the UCB submitted to it.  For 
	;	example, control is returned to the caller if the device is 
	;	not mounted.
	;   2.	In all other cases, mount verification returns to its caller's 
	;	caller.
	;   3.	If mount verification is possible, EXE$MOUNTVER will call the 
	;	driver's mount verification routine, DU$MOUNTVER, which is 
	;	supposed to process the IRP.  Since this IRP is a dummy, one 
	;	of the permanent IRP/CDRP pairs associated with the CDDB, 
	;	DU$MOUNTVER will do mount verification book keeping and then 
	;	RSB; since no special action is required.
	;   4.	Mount verification could result in a failover, which would 
	;	alter UCB$L_CDDB_LINK.  Since the UCBs on the current 
	;	connection are the only ones of interest, the next UCB address 
	;	is preserved on the stack across the call to mount verification.
	;   5.	Setting the UCB$M_SUPMVMSG bit causes those mount verficiation 
	;	messages associated with a successful mount verification 
	;	operation to be suppressed.  If something goes wrong or the 
	;	mount verfication operation nears the timeout stage, these 
	;	messages will be output (as usual).

	PUSHL	UCB$L_CDDB_LINK(R5)		; Push next UCB address.
	BISL	#UCB$M_SUPMVMSG, UCB$L_STS(R5)	; Suppress mount ver. messages.
	PUSHR	#^M<R3,R5>			; Save CDDB and UCB addresses.
	ADDL3	#CDDB$A_PRMIRP, -		; Get a permanent IRP address.
		UCB$L_CDDB(R5), R3
	MOVZWL	#SS$_MEDOFL, R0			; Setup a suitable status.
	CLRL	R1
	PUSHAB	B^50$				; Setup caller's caller.
	JSB	G^EXE$MOUNTVER			; Start mount verification.

	; Cannot do mount verification

	TSTL	(SP)+				; Pop caller's caller addr.
	POPR	#^M<R3,R5>			; Restore CDDB and UCB addrs.
	BSBW	DUTU$TERMINATE_PENDING		; Terminate all pending I/O.
	BRB	90$				; Loop through all UCBs.

50$:	; Mount verification is in progress

	POPR	#^M<R3,R5>			; Restore CDDB and UCB addrs.
	BITW	#<CDDB$M_INITING -		; If called from controller
		 !CDDB$M_QUORLOST>, -		; initialization or quorum
		CDDB$W_STATUS(R3)		; lost processing, skip this
	BNEQ	90$				; setup.
	TSTL	UCB$L_WAIT_CDDB(R5)		; Check of double waiting UCB.
	BNEQ	DBL_WAIT_UCB			; This is a serious error.
	INCW	CDDB$W_WTUCBCTR(R3)		; Count waiting UCB.
	MOVL	R3, UCB$L_WAIT_CDDB(R5)		; Store waiting CDDB address.
90$:	POPL	R5				; Get next UCB.
	BNEQ	10$				; If there is a UCB there, go
						; processs it.

	; All UCBs on the connection have been processed, one way or the 
	; other.  Control is now return this routine's caller.  As devices 
	; (or UCBs) complete mount verification DU$MOUNTVER will receive 
	; control and perform end of mount verification processing.

REVAL_STARTED:

	RSB

DBL_WAIT_UCB:
	BUG_CHECK DISKCLASS, FATAL		; Doublely waiting UCB; fatal 
						; error.
	.PAGE
	.SBTTL	Mount Verification Entry Point
;++
;
; DU$MOUNTVER
;
; Functional Description:
;
;	The disk class driver and mount verification are in bed together.  
;	They are so intimately related that one of them is most certainly 
;	"with child" and nuptual annoucements will soon be made.
;
;	In addition to the usual services performed by mount verification, the 
;	disk class driver calls for its assistance in restoring access to 
;	disks lost due to the various failure conditions which can occur with 
;	a MSCP server.
;
;	The following is a list of reasons why this routine might be called:
;
;	   -	starting mount verification due to appropriate status is a 
;		normal I/O request.  This probably is the result of the a 
;		change of state in the drive.  Hopefully, mount verification 
;		will restore the drive to the online state and work can 
;		continue.
;	   -	completing mount verification for the above.
;
;	   -	starting mount verification to "remount" a disk which was 
;		automatically dismounted due to a connection breakage.  This 
;		is done by force feeding mount verification one of the 
;		connection permanent CDRP's.
;	   -	completing mount verification for the above.
;
;	The first two cases represent pretty much normal mount verification.  
;	At least, they are the kind of mount verification one would expect to 
;	encounter for other disk devices.  The second two cases are a special 
;	usage of mount verification by the disk class driver.
;
;	Since the connection lost processing done when mount verification 
;	calls the driver is nearly identical to normal mount verification 
;	processing, all that work is performed within this routine or its 
;	servers.  To fully understand some aspects of this routine, it may be 
;	necessary to review the DU_REVALIDATE_DISKS routine.
;
; RWAITCNT Handling:
;
;	This routine increments RWAITCNT(ucb) when beginning mount 
;	verification for the first time and decrements it when mount 
;	verification is ended.  While RWAITCNT is non-zero, all I/O requests 
;	are added to the I/O queue hanging off the UCB.  Thus all I/O is 
;	stalled until the mount verification completes.  The mount 
;	verification IRP is not stalled because the start I/O routine handles 
;	it specially.
;
;	The code on this page acts as a simple dispatcher for the beginning 
;	and ending mount verification cases.
;
; Inputs:
;
;	For beginning mount verification:
;
;	R3	IRP address 
;	R5	UCB address
;
;	For ending mount verification:
;
;	R3	zero
;	R5	UCB address
;
; Outputs:
;
;	All registers are preserved.
;--

DU$MOUNTVER:

	TSTL	R3				; Is this ending mount ver.?
	BEQL	DU_END_MNTVER			; Branch if ending.
;	BRB	DU_BEGIN_MNTVER			; Fall through if beginning.
	.PAGE
	.SBTTL	 - DU_BEGIN_MNTVER - Begin mount verification
;++
;
; DU_BEGIN_MNTVER - Begin mount verification
;
; Functional Description:
;
;	This routine is called whenever mount verification needs to present a 
;	new IRP to the driver to be "remembered" and restarted after mount 
;	verification completes.  If this is a "normal" mount verification 
;	operation, the is inserted into the pending I/O request queue, ordered 
;	by sequence number.  However, if the IRP is one of those permanantly 
;	attached to a CDDB, it is simply discarded.  In any event, RWAITCNT is 
;	bumped, unless its already bumped because of mount verification, 
;	UCB$V_MSCP_MNTVERIP is set.
;
; Inputs:
;
;	R3	IRP address
;	R5	UCB address
;
; Implicit inputs:
;
;	IRP$L_DUTUFLAGS(R3) 	CDRP$V_PERM bit set to indicate presence of 
;				one of the permanent IRP/CDRP pairs belonging 
;				to the connection.
;	IRP$L_SEQNUM(R3)	monotonically increasing I/O request sequence 
;				number
;	UCB$L_IOQ[F/B]L(R5)	header for queue of pending I/O requests for 
;				this unit
;
; Outputs:
;
;	R0 and R1 are destroyed.
;	All other registers are preserved.
;
; Implicit outputs:
;
;	UCB$W_RWAITCNT(R5)	incremented if mount verification not already 
;				in progress.
;	UCB$W_DEVSTS(R5)	UCB$V_MSCP_MNTVERIP bit set
;
; Side effects:
;
;	The IRP pointed to by R3 is linked into the pending I/O request queue.
;--

DU_BEGIN_MNTVER:

	EXTZV	#UCB$V_MSCP_MNTVERIP, #1, -	; Get previous mount ver. bit
		UCB$W_DEVSTS(R5), R0		; for an upcomming sanity check.
	BBSS	#UCB$V_MSCP_MNTVERIP, -		; Set MSCP mount ver. in
		UCB$W_DEVSTS(R5), 15$		; progress and branch if already
	INCW	UCB$W_RWAITCNT(R5)		; set.  Else, bump wait count.
15$:	BBS	#CDRP$V_PERM, -			; Branch if permanent CDRP 
		IRP$L_DUTUFLAGS(R3), 50$	; used to start special 
						; purpose mount verification?
	; "Normal" mount verification

	MOVAB	<UCB$L_IOQFL-IRP$L_IOQFL>(R5), -; Get pending I/O queue 
		R1				; listhead address.
	MOVL	R1, R0				; Copy listhead address.

20$:	MOVL	IRP$L_IOQFL(R0), R0		; Link to next pending IRP.
	CMPL	R0, R1				; Reached end of list yet?
	BEQL	40$				; Branch if end of list.
	CMPL	IRP$L_SEQNUM(R0), -		; Does new IRP belong here?
		IRP$L_SEQNUM(R3)
	BLSSU	20$				; Branch if IRP doesn't belong.

40$:	INSQUE	(R3), @IRP$L_IOQBL(R0)		; Insert new IRP between 
						; previous and current IRPs in 
						; pending I/O queue.
	RSB					; Return.

	; Special purpose mount verification

50$:	BLBS	R0, 999$			; Branch if nested mount ver.
	RSB					; Otherwise, exit.

999$:	BUG_CHECK DISKCLASS, FATAL		; Initating special mount ver.
						; when mount ver. is already
						; in progress is a no no.
	.PAGE
	.SBTTL	 - DU_END_MNTVER - End mount verification
;++
;
; DU_END_MNTVER - End mount verification
;
; Functional Description:
;
;	This routine completes mount verification processing.  
;
;	The mount verification in progress flag is cleared and the wait count 
;	is reduce one to offset its being raised one when mount verification 
;	was initiated.  If mount verification failed to bring the disk back 
;	online, all requests are aborted with SS$_VOLINV to indicate that the 
;	volume is no longer valid.
;
;	Next, the status of the wait count and the wait count bumped bit must 
;	be made appropriate for the status of the current connection to the 
;	MSCP server.  Mount verification, failover, and reconnection processing 
;	all occur independently of each other.  However, at this point they 
;	must be coordinated.  If reconnection processing is in progress the 
;	wait count must be bumped by at least one and the wait count bumped 
;	bit must be set.  If reconnection processing is not in progress, the 
;	wait count must not be bumped and the wait count bumped bit must be 
;	clear.  During a reconnection attempt, the wait count must be bumped 
;	from the beginning of the attempt to the end of the attempt, and this 
;	routine, since it represents the last driver routine in a mount 
;	verification attempt and since mount verification is the primary 
;	failover tool, must coordinate handling of the wait count.  
;	Reconnection modification of the wait count is handled in 
;	DU$CONNECT_ERR and END_SINGLE_STREAM.  
;
;	If mount verification succeded in bringing the disk back online, 
;	this routine performs the end of mount verification processing 
;	necessary to stall attempting to single step CDRPs active when a 
;	connection failed until all disks (or UCBs) on a given CDDB are made 
;	valid by mount verification.  This scheme is detailed in the 
;	description of DU_REVALIDATE_DISKS.
;
; Inputs:
;
;	R5	UCB address
;
; Implicit inputs:
;
;	UCB$W_RWAITCNT(R5)	count of the reasons for stalling I/O requests
;				(zero implies requests can be restarted)
;	UCB$L_IOQ[F/B]L(R5)	header for queue of pending I/O requests for 
;				this unit
;	UCB$L_STS(R5)		bit UCB$V_VALID clear if mount verification 
;				failed
;	UCB$L_WAIT_CDDB(R5)	address of a CDDB waiting for mount 
;				verification to complete, or zero if none
;
; Outputs:
;
;	R0 through R4 are destroyed.
;	All other registers are preserved.
;
; Implicit outputs:
;
;	UCB$W_RWAITCNT(R5)	decremented
;	UCB$W_DEVSTS(R5)	UCB$V_MSCP_MNTVERIP bit cleared.
;	UCB$L_STS(R5)		UCB$V_SUPMVMSG bit cleared.
;	UCB$L_WAIT_CDDB(R5)	zeroed
;--

DU_END_MNTVER:

	BICL	#UCB$M_SUPMVMSG, UCB$L_STS(R5)	; Make next mount ver. noisy.
	BICW	#UCB$M_MSCP_MNTVERIP, -		; Clear mount verification
		UCB$W_DEVSTS(R5)		; in progress bit.
	DECW	UCB$W_RWAITCNT(R5)		; Reduce wait count.

	BBC	#UCB$V_VALID, UCB$L_STS(R5), 90$; Branch if mount ver. failed.

	; Mount verification was successful.

	JSB	G^SCS$UNSTALLUCB		; If possible, start pending

70$:	MOVL	UCB$L_WAIT_CDDB(R5), R3		; Get wait CDDB address.
	BEQL	80$				; Branch if none.
	CLRL	UCB$L_WAIT_CDDB(R5)		; Else, clear waiting CDDB.
	DECW	CDDB$W_WTUCBCTR(R3)		; Decrement waiting UCB count.
	BNEQ	80$				; Branch if UCBs still waiting.
	BBCC	#CDDB$V_RSTRTWAIT, -		; Branch if connection is not
		CDDB$W_STATUS(R3), 80$		; waiting to restart CDRPs.
	PUSHL	R5				; Else, save UCB.
	BSBW	RESTART_NEXT_CDRP		; Begin single steping CDRPs.
	POPL	R5				; Restore UCB.

80$:	RSB					; Exit.

	; Mount verification was not successful.

90$:	BSBW	DUTU$TERMINATE_PENDING		; Terminate all pending I/O.
	BRB	70$				; Rejoin end mount ver. code.
	.PAGE
	.SBTTL	DU$DSE_FDT - Data Security Erase FDT Routine
;++
;
; DU$DSE_FDT - Data Security Erase FDT Routine
;
; Functional Description:
;
;	This is the FDT routine for the Data Security Erase operation 
;	supported by MSCP speaking devices.  The byte count (P2) is stored in 
;	IRP$L_BCNT.  The starting logical block (P3) is stored in IRP$L_MEDIA.
;	Control is transfered to EXE$QIODRVPKT, thus queueing the I/O request
;	to the driver's start I/O routine.
;
; Inputs:
;
;	R3	IRP address
;	P2(AP)	byte count
;	P3(AP)	starting logical block
;
; Implicit inputs: None.
;
; Outputs:
;
;	IRP$L_BCNT(R3)  <== P2(AP) <byte count>
;	IRP$L_MEDIA(R3) <== P3(AP) <starting logical block>
;
; Implicit outputs: None.
;
; Condition codes: None.
;
; Side effects:
;
;	Control is transfered to EXE$QIODRVPKT, thus queueing the I/O request
;	to the driver's start I/O routine.
;--

DU$DSE_FDT:

	MOVL	P2(AP), IRP$L_BCNT(R3)		; Setup erase byte count.
	MOVL	P3(AP), IRP$L_MEDIA(R3)		; Setup erase starting LBN
	JMP	G^EXE$QIODRVPKT			; Send request to STARTIO.
	.PAGE
	.SBTTL	DU$SHADOW_PACKACK_FDT - Packack FDT for Volume Shadowing
;++
;
; DU$SHADOW_PACKACK_FDT - Packack FDT for Volume Shadowing
;
; Functional Description:
;
;	This is one of the FDT routines used by the disk class driver for the 
;	pack acknowledge (IO$_PACKACK) function.  It processes all requests 
;	relating in some way to shadowing.  There are two possible types of 
;	requests; requests which constitute a shadow set, and requests which 
;	bring a shadow set master unit online.
;
;	Requests to constitute a shadow set MUST ALWAYS be identified by the 
;	presence of the IO$M_SHADOW modifier.  For such requests, the legality 
;	of the request is tested.  For example, a shadow set master unit may 
;	not be a member of another shadow set, and only controllers which 
;	support shadowing may form shadow sets.  If the shadow set formation 
;	request is illegal, SS$_ILLIOFUNC status is returned.  Otherwise,
;	shadow volume set specific information is copied to the IRP where it 
;	will be available to be copied into the MSCP command packet by the 
;	start I/O routine.
;
;	The following information is copied to the IRP:
;	    -	the unit number to be assigned (used) for the pseudo-unit 
;		represnting the shadow volume set, P4.  This unit number may 
;		or may not have the MSCP$M_SHADOW bit set, to indicate that 
;		the unit is a shadow unit.  This routine will set it 
;		automatically.
;	    -	the starting LBN and block count of the area to be excluded 
;		from any catchup copy, P3 and P2 respectively.
;	    -	the catchup copy speed, P5.  This is one of the values 
;		specified for the MSCP ONLINE command COPY SPEED parameter.
;
;	Requests to bring a shadow set master online have two variants which 
;	are identified by whether or not the IO$M_SHADOW function modifier is 
;	set.  If IO$M_SHADOW is set and the shadow unit number, P4, matches 
;	the device's MSCP unit number, then this is a legal request to bring a 
;	shadow set master online.  Otherwise, it is an attempt to include a 
;	shadow set master as a member of another shadow set, which is illegal.
;	If IO$M_SHADOW is clear by the MSCP unit number indicates that this is 
;	a shadow set master, the IO$M_SHADOW bit must be set for proper 
;	processing to occur within the MSCP server.  Therefore, this routine 
;	sets IO$M_SHADOW and prepares the IRP for a proper MSCP shadow online 
;	request.
;
;	This routine does not terminate FDT processing.  The FDT must contain 
;	a second entry for PACKACK which follows the entry for this routine 
;	and which posts the IRP for delivery to the start I/O routine.
;
; Inputs:
;
;	R3	IRP address
;	R5	UCB address
;	P2(AP)	exclusion area block count
;	P3(AP)	starting logical block number for the exclusion area
;	P4(AP)	shadow unit number
;	P5(AP)	copy speed
;
;	IRP$W_FUNC(R3) I/O function code and modifiers
;
; Implicit inputs:
;
;	UCB$L_CDDB(R5)		CDDB address
;	CDDB$W_CNTRLFLGS(CDDB)	MSCP$V_CF_SHADW set to indicate controller 
;				supports shadowing
;	UCB$W_MSCPUNIT(R5)	MSCP unit number; MSCP$V_SHADOW being set 
;				implies that this is a shadow set master and 
;				not a candidate for shadowing
;
; Outputs:
;
;	R0 and R1 are destroyed.
;	All other registers are preserved.
;
;	IRP$L_BCNT(R3)    <== P2(AP) <exclusion area block count>
;	IRP$L_MEDIA(R3)	  <== P3(AP) <exclusion area starting LBN>
;	IRP$L_MEDIA+4(R3) <== P4(AP) .or. MSCP$M_SHADOW <shadow unit number>
;	IRP$W_BOFF(R3)	  <== P5(AP) <copy speed>
;
;	N.B. the IRP field usage conventions used above are effective solely 
;	within this driver.
;
; Implicit outputs: None.
;
; Condition codes:
;
;	SS$_ILLIOFUNC	returned if specified unit cannot be a shadow set 
;			member
;
; Side effects:
;
;	This routine exits with an RSB.  This means that another FDT entry for 
;	PACKACK must exist following the entry for this routine in the FDT.
;--

DU$SHADOW_PACKACK_FDT:

	BBC	#IO$V_SHADOW, -			; Is this a shadow packack?
		IRP$W_FUNC(R3), 50$		; Branch if not shadow packack.
	BISW3	#MSCP$M_SHADOW, P4(AP), R1	; Get QIO shadow unit number.
	ASSUME	MSCP$V_SHADOW EQ 15
	MOVW	UCB$W_MSCPUNIT(R5), R0		; Get MSCP unit number.
	BLSS	40$				; Branch if shadow set master.

	MOVZWL	P2(AP), IRP$L_BCNT(R3)		; Plant exc. area block count.
	MOVL	P3(AP), IRP$L_MEDIA(R3)		; Plant exc. area starting LBN.
	MOVW	P5(AP), IRP$W_BOFF(R3)		; Plant catchup copy speed.
	MOVW	R1, IRP$L_MEDIA+4(R3)		; Plant shadow master unit no.
	BRB	70$				; Exit routine.

40$:	CMPW	R0, R1				; Is QIO shadow master right?
	BEQL	55$				; If right, process request.
	BRB	99$				; Else, error.

50$:	ASSUME	MSCP$V_SHADOW EQ 15
	MOVW	UCB$W_MSCPUNIT(R5), R0		; Get MSCP unit number.
	BGEQ	80$				; Exit routine if not a 
55$:	ASSUME	IRP$L_BCNT EQ IRP$W_BOFF+2	; shadow set master.
	CLRQ	IRP$W_BCNT(R3)			; Else, initialize IRP for a
	CLRL	IRP$L_MEDIA(R3)			; shadow set master online.
	MOVW	R0, IRP$L_MEDIA+4(R3)		; Plant shadow master unit no.

70$:	MOVL	UCB$L_CDDB(R5), R0		; Get CDDB address.
	BBC	#MSCP$V_CF_SHADW, -		; Does controller shadow?
		CDDB$W_CNTRLFLGS(R0), 99$	; Branch if no shadowing.

80$:	RSB					; Continue FDT processing.

; ERROR - this unit cannot be a member of a shadow set.

99$:	MOVZWL	#SS$_ILLIOFUNC, R0		; Set error status.
	JMP	G^EXE$FINISHIOC			; Complete I/O request.
	.PAGE
	.SBTTL	START I/O
	.SBTTL	- Out of main line code

; Handle device which is in mount verification.
;
;   R3 UCB address
;   R5 CDRP address

START_MOUNT_VER:

	; This is a request from mount verification.  Since mount verification 
	; guarantees that the volume is valid before presenting requests to 
	; the drivers, UCB$V_VALID being clear is cause for immediately 
	; terminating the request with SS$_VOLINV.  Presumably, mount 
	; verification will pickup the pieces and retry the mount verification 
	; operation from the top.  To avoid unnecessary hangs, the conditions 
	; which would prevent the IRP from being processed are tested.  If any 
	; such condition exists, an attempt to failover to the alternate path 
	; will be made.  If that succeeds, the request will be processed on 
	; the alternate path.  If the failover fails, the IRP will be 
	; immediately completed with a SS$_MEDOFL status.

	BBC	#UCB$V_VALID, -		; In mount verification, valid bit
		UCB$L_STS(R3), 199$	; should always be set.
	CLRL	CDRP$L_RWCPTR(R5)	; Clear wait count pointer.
	EXTZV	#UCB$V_MSCP_MNTVERIP, -	; Get mount verification in progress
		#1, UCB$W_DEVSTS(R3), R0; bit.
	BEQL	999$			; It had better be one.
	BBC	#UCB$V_MSCP_WAITBMP, -	; Is wait count bumped?
		UCB$W_DEVSTS(R3), 10$	; Branch if wait count not bumped.
	INCW	R0			; Increment expected wait count.
10$:	CMPW	R0, UCB$W_RWAITCNT(R3)	; Is wait count as expected?
	BNEQ	90$			; Branch if not as expected.
	MOVL	UCB$L_CDDB(R3), R0	; Get CDDB address.
	BBC	#CDDB$V_NOCONN, -	; Is there a connection?
		CDDB$W_STATUS(R0), 105$	; Branch if connection present.
90$:	BSBW	DUTU$FAILOVER_UCB	; Try failover to alternate path.
	BLBS	R0, 105$		; Branch if failover succeeded.
	CLRL	R1			; Init second IOSB longword.
	ALT_REQCOM			; Complete mount ver. request now.

105$:	BRB	DU_RESTARTIO		; Branch assists.
199$:	BRW	VOLNOTVAL


999$:	BUG_CHECK DISKCLASS, FATAL	; Received mount verification IRP
					; when mount verification was not
					; in progress.  Somebody blew it.

; Handle device with I/O requests stalled.
;
;   R3 UCB address
;   R5 CDRP address

	; For any one of several reasons requests on this UCB are stalled.  
	; If this is a mount verification, presumably mount verification is in 
	; progress which would stall this UCB.  So go process the mount 
	; verfication IRP.
	;
	; Otherwise, determine whether or not there is any hope that this IRP 
	; will work when the UCB becomes unstalled.  If mount verification is 
	; in progress, the volume is still valid, or the request if a physical 
	; function, then assume there is hope.  Otherwise, terminate the 
	; request now with SS$_VOLINV.
	;
	;   R3 UCB address
	;   R5 CDRP address

IO_STALLED:

	BBS	#IRP$V_MVIRP, -		; Is this a mount verification IRP?
		CDRP$W_STS(R5), -	; Branch if mount verification IRP.
		START_MOUNT_VER
	BBS	#UCB$V_MSCP_MNTVERIP, -	; Is mount verification in progress?
		UCB$W_DEVSTS(R3), -	; Branch if mount verification is in
		QUEUE_IRP		; progress.
	BBS	#UCB$V_VALID, -		; Is the volume still valid?
		UCB$L_STS(R3), -	; Branch if volume is valid.
		QUEUE_IRP
	BBS	#UCB$V_MSCP_PKACK, -	; Branch if a PACKACK is in progress.
		UCB$W_DEVSTS(R3), -
		QUEUE_IRP
	BBC	#IRP$V_PHYSIO, -	; Volume not valid:  branch if this 
		CDRP$W_STS(R5), 90$	; request is not a physical function.
	MOVL	UCB$L_CDDB(R3), R0	; Get CDDB address.
	BBC	#CDDB$V_NOCONN, -	; Is there a connection?
		CDDB$W_STATUS(R0), -	; Branch if connection present.
		QUEUE_IRP
90$:	BRW	VOLNOTVAL		; Else, kill the request now.

QUEUE_IRP:
	INSQUE	CDRP$L_IOQFL(R5), -	; Queue IRP (based upon CDRP address).
		@UCB$L_IOQBL(R3)
	RSB				; Then discontinue processing on this
					; request.

; Handle class driver reference to a locally connected device
;
;   R3	IRP address
;   R5	UCB address

START_LOCAL_DEVICE:
	MOVL	UCB$L_2P_ALTUCB(R5), R5	; Get local UCB address.
	MOVL	IRP$L_MEDIA(R3), R0	; Get logical block address.
	JSB	G^IOC$CVTLOGPHY		; Convert it to a physical address.
	JMP	G^EXE$INSIOQ		; Go hand this IRP to local driver.
	.PAGE
	.SBTTL	- Start I/O entry point
DU_STARTIO:
	ASSUME	UCB$V_BSY GE 8
	BICB	#<UCB$M_BSY @ -8>, -	; Undo bit setting so that multiple
		UCB$W_STS+1(R5)		; IRP's can be started.

	; If this UCB indicates that the device is a local (non-MSCP) device 
	; that has also been made available to us via 1) dual porting and 
	; 2) an MSCP server on the node to which it is dual ported, then 
	; shunt this IRP to the local driver.

	BITL	#DEV$M_CDP, -		; Is this a class driver path to a
		UCB$L_DEVCHAR2(R5)	; local device?
	BNEQ	START_LOCAL_DEVICE	; Branch if such a path.

	; Initialize CDRP fields.

	MOVAB	IRP$L_FQFL(R3), R0	; Get address of CDRP portion of IRP.
	MOVL	R5, R3			; Move UCB address.
	MOVL	R0, R5			; Move CDRP address.
	ASSUME	CDRP$B_CD_TYPE EQ CDRP$W_CDRPSIZE+2
	ASSUME	CDRP$B_FIPL    EQ CDRP$W_CDRPSIZE+3
	MOVL	#< <IPL$_SCS@24> -	; Initialize CDRP size, type and fork
		 ! <DYN$C_CDRP@16> -	; IPL fields.
		 ! <CDRP$L_IOQFL&^xFFFF> >, -
		CDRP$W_CDRPSIZE(R5)
	ASSUME	CDRP$L_RSPID	EQ	CDRP$L_MSG_BUF+4
	CLRQ	CDRP$L_MSG_BUF(R5)	; Prevent spurious DEALLOC_MSG_BUF and
					; spurious DEALLOC_RSPID calls.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Prevent spurious UNMAP calls.
	ASSUME	CDRP$W_DUTUCNTR  EQ <CDRP$L_DUTUFLAGS+4>
	ASSUME	CDRP$W_ENDMSGSIZ EQ <CDRP$L_DUTUFLAGS+6>
	CLRQ	CDRP$L_DUTUFLAGS(R5)	; Clear flags, counter, & msg. size.
	MOVAB	UCB$W_RWAITCNT(R3), -	; Point CDRP field to wait counter
		CDRP$L_RWCPTR(R5)	; in the UCB.

	TSTW	UCB$W_RWAITCNT(R3)	; Are "normal" I/O requests stalled?
	BNEQ	IO_STALLED		; Branch if requests are stalled.

DU_RESTARTIO:				; Label where we RESTART CDRP's after
					;  virtual circuit re-CONNECTION.

	MOVL	UCB$L_CDT(R3),-		; Place CDT pointer into CDRP for handy
		CDRP$L_CDT(R5)		;  reference by SCS routines. Note we
					;  do this after label DU_RESTARTIO so
					;  that it is refreshed upon restart.
	MOVL	UCB$L_PDT(R3),R4	; R4 => port's PDT.

	BITL	#CDRP$M_ERLIP,	-	; When set, this bit means an operation
		CDRP$L_DUTUFLAGS(R5)	; which replaced a block is being 
	BNEQ	10$			; restarted and that the previously
					; allocated RSPID should continue to
					; be used.
	CLRL	CDRP$L_RSPID(R5)	; Prevent spurious DEALLOC_RSPID.
	ALLOC_RSPID			; ALLOCate a ReSPonse ID.
10$:	BITW	#UCB$M_VALID, -		; Is volume software valid?
		UCB$W_STS(R3)
	BEQL	VOL_INVALID		; Branch if not volume software valid.

PHYIO_VOLINV:
	ALLOC_MSG_BUF			; Allocate an MSCP buffer (and also
					;  allocate a unit of flow control).
	BLBC	R0,MSG_BUF_FAILURE	; If failure, branch out of line.

; Here a little common MSCP packet initialization.

	MOVL	R2, R0			; Copy message buffer address.
	.REPEAT	MSCP$K_MXCMDLEN / 8
	CLRQ	(R0)+			; Zero entire message buffer.
	.ENDR
	.IIF	NE MSCP$K_MXCMDLEN & 4, CLRL (R0)+
	.IIF	NE MSCP$K_MXCMDLEN & 2, CLRW (R0)+
	.IIF	NE MSCP$K_MXCMDLEN & 1, CLRB (R0)+

	MOVL	CDRP$L_RSPID(R5),-	; Use RSPID as command reference
		MSCP$L_CMD_REF(R2)	;  number for all commands.

	MOVW	UCB$W_MSCPUNIT(R3),-	; Indicate UNIT number in MSCP
		MSCP$W_UNIT(R2)		;  packet.

DU_BEGIN_IVCMD:
	MOVW	CDRP$W_FUNC(R5), R1	; Get function code & modifiers.
	ASSUME	IO$V_FCODE EQ 0
	BICW3	#^cIO$M_FCODE, R1, R0	; Extract just the I/O function code.

	DISPATCH R0, type=B, prefix=IO$_, < -		; Dispatch to correct 
		<NOP,		START_NOP>, -		; function processing.
		<UNLOAD,	START_UNLOAD>, -
		<PACKACK,	START_PACKACK>, -
		<WRITECHECK,	START_WRITECHECK>, -
		<WRITEPBLK,	START_WRITEPBLK>, -
		<READPBLK,	START_READPBLK>, -
		<AVAILABLE,	START_AVAILABLE>, -
		<DSE,		START_DSE> -
		>
; -----	BRB	START_NOSUCH			; Illegal function code
	.PAGE
	.SBTTL	- More out of main line code
;++
;
; Handle an illegal I/O function.
;
; Since a message buffer has been allocated, DUTU$RESTORE_CREDIT must be 
; called to restore the allocated send credit.  Then the request can be 
; finished off with SS$_ILLIOFUNC.
;--

START_NOSUCH:
	BSBW	DUTU$RESTORE_CREDIT	; Restore allocated send credit.
	MOVZWL	#SS$_ILLIOFUNC,R0
	CLRL	R1
	BRW	FUNCTION_EXIT		; Branch to exit I/O function.


;++
;
; Handle a message buffer allocation failure.
;
; Control get here whenever there is a message buffer allocation failure.  
; This implies that the connection to the MSCP server is broken.  The action
; to be taken is to kill this thread of execution by placing the CDRP at the 
; tail of the outstanding CDRP queue.  Because of the connection failure, a
; thread exists that is currently executing that is gathering all CDRP's 
; associated with this connection for a future restart attempt.  Therefore, 
; control is pased to DUTU$KILL_THIS_THREAD which will handle this error.
;--

MSG_BUF_FAILURE:

	BRW	DUTU$KILL_THIS_THREAD	; Branch to where we collect all active
					;  CDRP's prior to re-CONNECTION.

;++
;
; Handle volume which is not software valid.
;
; When a volume is not software valid, only physical opeations are legal.  All 
; other operations must produce a SS$_VOLINV status.  The only exception is a 
; small race window where the volume can become invalid while a thread is 
; waiting for a RSPID.  In this case, a check for a packack which might make 
; things better is required.
;--

VOL_INVALID:
	BBS	#IRP$V_PHYSIO,-		; See if PHYSICAL I/O requested.
		CDRP$W_STS(R5),-	;  If physical, then branch back to
		PHYIO_VOLINV		;  continue even tho VOLINV.
	TSTW	UCB$W_RWAITCNT(R3)	; Is the wait count raised?
	BEQL	VOLNOTVAL		; Branch if wait count not raised.
	DEALLOC_RSPID			; Else, release RSPID.
	BRW	IO_STALLED		; Join the I/O is stalled code path.
VOLNOTVAL:
	MOVZWL	#SS$_VOLINV,R0		; Indicate error status.
	CLRL	R1			; Clear second word of I/O status.
	BRW	FUNCTION_EXIT		; GOTO common exit.

;  End of out of line code
;-
	.PAGE
	.SBTTL	START_NOP
; START_NOP - Prepare an MSCP packet to do a GET UNIT STATUS command.
;
; INPUTS:
;	R1 => I/O function code & modifiers
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	The MSCP packet contains zeros except for:
;
;	MSCP$L_CMD_REF(R2)	<== CDRP$L_RSPID(R5)
;	MSCP$W_UNIT(R2)		<== UCB$W_MSCPUNIT(R3)
;

START_NOP:
	MOVB	#MSCP$K_OP_GTUNT,-	; Transfer GET UNIT STATUS opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	SEND_MSCP_MSG			; Send message to the MSCP server.

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	NOP_SUCC
	ACTION_ENTRY	OFFLN, SS$_DEVOFFLINE,	NOP_OFFLINE
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	NOP_AVAIL
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	NOP_DRVERR
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	NOP_CTRLERR
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	NOP_IVCMD
	ACTION_ENTRY	SHST,  SS$_SHACHASTA,	NOP_SSSC
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

NOP_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	MOVB	#MSCP$K_OP_GTUNT, -	; Setup Get Unit Status opcode
		MSCP$B_OPCODE(R2)	; in duplicate MSCP command.
	IVCMD_END			; Complete invalid command processing.
; -----	BRB	NOP_SUCC		; Fall through to complete command.


NOP_SUCC:
NOP_OFFLINE:
NOP_AVAIL:
NOP_CTRLERR:
NOP_DRVERR:
NOP_SSSC:
	CLRL	R1			; Clear for I/O status block.
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.PAGE
	.SBTTL	START_PACKACK

; START_PACKACK - Prepare an MSCP packet to do an ONLINE command.
;
; INPUTS:
;	R1 => I/O function code & modifiers
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	The MSCP packet contains zeros except for:
;
;	MSCP$L_CMD_REF(R2)	<== CDRP$L_RSPID(R5)
;	MSCP$W_UNIT(R2)		<== UCB$W_MSCPUNIT(R3)
;

START_PACKACK:

	BBSS	#UCB$V_MSCP_PKACK, -	; Branch if PACKACK in progress is
		UCB$W_DEVSTS(R3), 5$	; set and set it.
	INCW	UCB$W_RWAITCNT(R3)	; Bump wait count to stall I/O.

5$:	MOVB	#MSCP$K_OP_ONLIN, -	; Transfer ONLINE opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	MOVW	UCB$W_UNIT_FLAGS(R3),-	; Copy unit flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)

	MOVL	UCB$L_MSCPDEVPARAM(R3), - ; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	;  MSCP packet.

	BBC	#IO$V_SHADOW, R1, 10$	; Branch if not shadow packack.
	MOVW	CDRP$L_MEDIA+4(R5), -	; Copy shadow device pseudo-unit unit
		MSCP$W_SHDW_UNT(R2)	; number.
	MOVW	CDRP$L_BCNT(R5), -	; Plant exc. area block count.
		MSCP$W_EXCL_LBC(R2)
	MOVL	CDRP$L_MEDIA(R5), -	; Plant exc. area starting LBN.
		MSCP$L_EXCL_LBA(R2)
	MOVW	CDRP$W_BOFF(R5), -	; Plant catchup copy speed.
		MSCP$W_COPY_SPD(R2)
	BISW	#MSCP$M_MD_SHDSP, -	; Set the shadow unit specified
		MSCP$W_MODIFIER(R2)	; modifier.

10$:	IF_IVCMD then=PKAK_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to the MSCP server.

	ASSUME	UCB$V_VALID GE 8
	BICB	#<UCB$M_VALID @ -8>, -	; Initialize software volume valid.
		UCB$W_STS+1(R3)

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	PACKACK_SUCC
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	PACKACK_OFFLINE
	ACTION_ENTRY	ABRTD, SS$_ABORT,	END_PACKACK
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	END_PACKACK
	ACTION_ENTRY	MFMTE, SS$_FORMAT,	END_PACKACK
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	PACKACK_IVCMD
	ACTION_ENTRY	DATA,  SS$_FORMAT,	END_PACKACK
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	END_PACKACK
	ACTION_ENTRY	SHST,  SS$_SHACHASTA,	END_PACKACK
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

PKAK_IVCMD_END:
	BRW	PACKACK_IVCMD_END	; Branch assist

PACKACK_SUCC:

	; At this point, R0 is assumed to contain SS$_NORMAL and 
	; the online is assumed to have completed successfully.

	; Test for otherwise undetected errors during ONLINE command.

	BBS	#MSCP$V_UF_576, -	; Is disk 576 bytes/sector?
		UCB$W_UNIT_FLAGS(R3), -	; Branch if disk is 576 bytes/sector.
		PACKACK_576
	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Was I/O request canceled?
		PACKACK_CANCEL		; Branch if request was canceled.

	; Having done a successful ONLINE command; the MSCP end packet status 
	; for the online command is saved in CDRP$W_DUTUCNTR.  Since the 
	; online was successful, this field is not longer needed to failover 
	; retries.  The saved end status will be used later to determine 
	; whether or not to call DU$ONLINE_COMPLETE for hirt processing.  This 
	; needs to be done only after the device is first brought online.  All 
	; succeeding onlines can ignore it.  Status information in the ONLINE 
	; command end message is saved in the UCB, and other valuable 
	; information is collected using a GET UNIT STATUS command.

	MOVW	MSCP$W_STATUS(R2), -	; Copy MSCP end status for later
		CDRP$W_DUTUCNTR(R5)	; testing.
	BSBW	RECORD_ONLINE		; Record ONLINE date in UCB.

	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
	MOVB	#MSCP$K_OP_GTUNT,-	; Opcode is for GET UNIT STATUS.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG			; Send message to the MSCP server.

	IF_MSCP	SUCCESS then=PACKACK_GTUNT_SUCC  ; Branch if GTUNT successful.
	ASSUME	CDRP$V_CAND EQ 0	; Else, ...
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Was I/O request canceled?
		PACKACK_CANCEL		; Branch if request was canceled.
	RESET_MSCP_MSG			; If here, the drive went offline.
	BRW	START_PACKACK		; Go try again.

PACKACK_GTUNT_SUCC:

	BSBW	RECORD_UNIT_STATUS	; Record UNIT STATUS data in UCB.

	MOVL	#SS$_NORMAL, R0		; The PACKACK has been successful.
	BBS	#MSCP$V_UF_REPLC,-	; Branch around, if controller initiated
		UCB$W_UNIT_FLAGS(R3),-	; bad block replacement since we already
		VALID_PACKACK		; have our status in R0.
	BBS	#UCB$V_MSCP_WRTP, -	; Also branch around if drive is
		UCB$W_DEVSTS(R3), -	; write protected.
		VALID_PACKACK
	BBS	#MSCP$V_SC_ALONL, -	; Also branch around if drive was
		CDRP$W_DUTUCNTR(R5), -	; already online when MSCP online
		VALID_PACKACK		; command was issued.
	BSBW	DU$LOCK_HIRT		; Else grab hold of the HIRT.
	BSBW	DU$ONLINE_COMPLETE	; Make sure no replacement in progress.
	BSBW	DU$UNLOCK_HIRT		; Release HIRT.
	TSTL	R5			; Was CDRP canceled?
	BNEQ	2$			; Branch if CDRP not canceled.
	RSB				; Else, kill this fork thread.

2$:	BISL	R1, CDRP$L_DUTUFLAGS(R5); Set ERLIP bit if its on in R1.

	BLBC	R0, PACKACK_BADRCT	; Branch if something wrong with RCT.

VALID_PACKACK:
	ASSUME	UCB$V_VALID GE 8
	BISB	#<UCB$M_VALID @ -8>, -	; Set software volume valid.
		UCB$W_STS+1(R3)

END_PACKACK:
	ASSUME	UCB$V_MSCP_PKACK GE 8
	BICB	#<UCB$M_MSCP_PKACK@-8>,-; Clear PACKACK in progress flag.
		UCB$W_DEVSTS+1(R3)
	DECW	UCB$W_RWAITCNT(R3)	; Unbump wait count.
	PUSHR	#^M<R0,R3,R4,R5>	; Save important registers.
	MOVL	R3, R5			; Setup UCB address.
	JSB	G^SCS$UNSTALLUCB	; Unstall I/O requests.
	POPR	#^M<R0,R3,R4,R5>	; Restore important registers.
	CLRL	R1			; Clear R1, for I/O status block.
	BRW	FUNCTION_EXIT		; Packack function is done.
	.PAGE
	.SBTTL	PACKACK Errors
PACKACK_576:				; Encountered 576 bytes/sector disk.
	MOVZWL	#SS$_FORMAT, R0		; Get bad disk format error.
	BRB	UNDO_ONLINE		; Negate the successful ONLINE command.

PACKACK_CANCEL:				; PACKACK operation canceled.
	MOVZWL	#SS$_ABORT, R0		; Set canceled status.
	BRB	UNDO_ONLINE		; Negate possibly successful ONLINE.

PACKACK_BADRCT:				; Encountered a bad RCT.
	MOVZWL	#SS$_BADRCT, R0		; Set BADRCT error status.

UNDO_ONLINE:				; Must undo the effect of a successful 
					; MSCP online command.
	MOVL	R0, CDRP$L_MEDIA(R5)	; Save function error status.
	RESET_MSCP_MSG			; Ready message for a new MSCP command.
	MOVB	#MSCP$K_OP_AVAIL, -	; Undo online with available command.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG			; Sent AVAILABLE to the server.
	MOVL	CDRP$L_MEDIA(R5), R0	; Restore function error status.
	BRB	END_PACKACK		; Exit PACKACK processing.

PACKACK_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	START_PACKACK		; Duplicate PACKACK setup.
PACKACK_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
	BRB	END_PACKACK		; Complete PACKACK operation.

PACKACK_OFFLINE:
	EXTZV	#MSCP$V_ST_SBCOD, -	; Extract the end message substatus.
		#MSCP$S_ST_SBCOD, -
		MSCP$W_STATUS(R2), R1	; Then, dispatch on that substatus:
	DISPATCH R1, type=W, prefix=MSCP$K_SC_, < -
		<UNKNO, 100$>, -	; Unit unknown to this server
		<INOPR, 100$>, -	; Unit inoperative on this server
		<DUPUN,  20$>, -	; Duplicate unit number
		<NOVOL, END_PACKACK> -	; Run/Stop switch not depressed
		>
	MOVZWL	#SS$_DRVERR, R0		; Everything else is a drive error.
	BRB	END_PACKACK		; Branch to exit PACKACK.

20$:	; Duplicate unit
	BSBW	DUTU$SEND_DUPLICATE_UNIT; Send a message to the operator.
	MOVZWL	#SS$_DUPUNIT,R0		; Return final status.
9$:	BRB	END_PACKACK		; Exit PACKACK processing.

100$:	; Unknown or inoperative unit
	INCW	CDRP$W_DUTUCNTR(R5)	; Count this retry attempt.
	CMPW	#4, CDRP$W_DUTUCNTR(R5)	; Are the retries exhausted?
	BLEQU	END_PACKACK		; Branch if no more retries.
	BICL	#CDRP$M_ERLIP, -	; Since RSPID is going away, clear the
		CDRP$L_DUTUFLAGS(R5)	; errorlog in progress (to get another).
	BSBW	DUTU$DEALLOC_ALL	; Release all SCS resources.
	BSBW	DUTU$FAILOVER_UCB	; Failover to secondary path, if any.
	BLBC	R0, 9$			; Branch if switch attempt failed.
	BRW	DU_RESTARTIO		; Otherwise, retry the PACKACK.
	.PAGE
	.SBTTL	PACKACK Support Routines

;+
; RECORD_ONLINE - copy data form ONLINE END MESSAGE to UCB.
;
; Inputs:
;	R2 => End Message
;	R3 => UCB
;
; Outputs:
;	R0 is destroyed
;	UCB fields set
;-

RECORD_ONLINE:

	MOVQ	MSCP$Q_UNIT_ID(R2),-	; In the event of success, copy unit
		UCB$Q_UNIT_ID(R3)	;  characteristics data to UCB.
	MOVL	MSCP$L_MEDIA_ID(R2),-	; Starting with the UNIT ID, followed
		UCB$L_MEDIA_ID(R3)	;  by the media identifier and
	BSBW	DUTU$GET_DEVTYPE	;  device type and 
	MOVL	MSCP$L_UNT_SIZE(R2),-	; Then followed by the unit size and
		UCB$L_MAXBLOCK(R3)
	MOVL	MSCP$L_VOL_SER(R2),-	; Then by the volume serial number.
		UCB$L_DU_VOLSER(R3)
	MOVW	MSCP$W_UNT_FLGS(R2),-	; Copy new unit flags from end packet.
		UCB$W_UNIT_FLAGS(R3)

	RSB				; Return to caller.
	.PAGE
;++
; RECORD_UNIT_STATUS - copy data from GET UNIT STATUS end message to UCB
;
; Functional Description:
;
;	The supplied MSCP end message is analyzed and appropriate fields in 
;	the UCB are filled in with information contained in the end message.
;
;	If the end message is shorter than MSCP$K_LEN, it is zero filled 
;	to that length.  This compensates for controllers possibly passing 
;	some fields back as zeros by returning short messages.  Then various 
;	geometry parameters are copied or calculated from the geometry 
;	information in the end message.  If the basic cylinders/tracks/sectors 
;	information produced by these calulations contains any zeros, a class 
;	driver bugcheck is declared.  Finally, the two write-locked bits are 
;	tested.  If either is set, the DEV$M_SWL bit is set.  Otherwise, the 
;	bit is not set.
;
; Inputs:
;
;	R2	address of MSCP get unit status end message
;	R3	UCB address
;	R5	CDRP address
;
;	CDRP$W_ENDMSGSIZ(R5) size of MSCP end message
;
; Outputs:
;
;	R0 & R1	destroyed
;
;	The following UCB fields are altered:
;
;	UCB$W_DU_LBNPTRK	LBNs per track
;	UCB$W_DU_TRKPGRP	tracks per group
;	UCB$W_DU_GRPPCYL	groups per cylinder
;	UCB$W_DU_RCTSIZE	LBNs in the RCT
;	UCB$B_DU_RBNPTRK	RBNs per track
;	UCB$B_DU_RCTCPYS	number of RCT copies
;	UCB$L_DU_TOTSIZ		LBNs plus RCT blocks
;	UCB$B_SECTORS		sectors per track (must not be zero)
;	UCB$B_TRACKS		tracks per cylinder (must not be zero)
;	UCB$W_CYLINDERS		cylinders per volume (must not be zero)
;--

RECORD_UNIT_STATUS:

	MOVZWL	CDRP$W_ENDMSGSIZ(R5), R1; Get size of end message received.
	SUBW3	R1, #MSCP$K_LEN, R0	; Compute size unsent message.
	BLEQ	10$			; Branch if whole message sent.
	PUSHR	#^M<R2,R3,R4,R5>	; Else, save favorite registers.
	MOVC5	#0, (SP), #0, R0, (R2)[R1] ; Zero-fill unsent message.
	POPR	#^M<R2,R3,R4,R5>	; Restore saved registers.

10$:	MOVW	MSCP$W_TRACK(R2),-	; Copy date from end message to UCB.
		UCB$W_DU_LBNPTRK(R3)	; LBN's per track.
	MOVW	MSCP$W_GROUP(R2),-	; Then tracks per group.
		UCB$W_DU_TRKPGRP(R3)
	MOVW	MSCP$W_CYLINDER(R2),-	; Groups per cylinder.
		UCB$W_DU_GRPPCYL(R3)
	MOVL	UCB$L_MAXBLOCK(R3),-	; Unit size in LBNs.
		UCB$L_DU_USIZE(R3)
	MOVW	MSCP$W_RCT_SIZE(R2),-	; Size of the RCT in blocks.
		UCB$W_DU_RCTSIZE(R3)
	MOVB	MSCP$B_RBNS(R2),-	; RBN's per track.
		UCB$B_DU_RBNPTRK(R3)

	ASSUME	DEV$V_RCT GE 8
	BISB	#<DEV$M_RCT @ -8>, -	; Assume this unit has an RCT.
		UCB$L_DEVCHAR+1(R3)
	MOVZBL	MSCP$B_RCT_CPYS(R2), R0	; R0 = # of RCT copies on the unit.
	BNEQ	15$			; Branch if unit has an RCT.
	BICL	#<DEV$M_RCT @ -8>, -	; Else, signal that unit has no RCT.
		UCB$L_DEVCHAR+1(R3)
15$:	MOVB	R0, UCB$B_DU_RCTCPYS(R3); Save number of RCT copies on unit.

	MULW2	MSCP$W_RCT_SIZE(R2),R0	; R0 = size of RCT area.
	ADDL3	UCB$L_MAXBLOCK(R3),R0,-	; Size of user visible area plus size
		UCB$L_DU_TOTSZ(R3)	;  of RCT area is total size.

	MOVB	MSCP$W_TRACK(R2),-	; Init UCB devdepend fields.
		UCB$B_SECTORS(R3)	; Tracksize is number of sectors.
	BEQL	999$			; Branch to bugcheck if zero.
	CLRL	R0			; Clear Product.
	MULW3	MSCP$W_GROUP(R2),-	; Group size * cylinder size =
		MSCP$W_CYLINDER(R2),R0	;  # of tracks in a cylinder.
	MOVB	R0,UCB$B_TRACKS(R3)
	BEQL	999$			; Branch to bugcheck if zero.
	MULW2	MSCP$W_TRACK(R2),R0	; * #sectors/track = #sectors/cyl
	CLRL	-(SP)			; Put UCB$L_MAXBLOCK into low order
	PUSHL	UCB$L_MAXBLOCK(R3)	;  longword of workarea on stack.
	EDIV	R0,(SP)+,R0,R1		; UCB$L_MAXBLOCK/R0 ... quotient -> R0,
					;  remainder -> R1, workarea popped off
					;  stack.
	TSTL	R1			; Test for any remainder.
	BEQL	25$			; EQL means no remainder.
	INCL	R0			; If remainder, round quotient up.
25$:	MOVW	R0,UCB$W_CYLINDERS(R3)	; Store number of cylinders on disk.
	BEQL	999$			; Branch to bugcheck if zero.

	ASSUME	MSCP$V_UF_WRTPH GE 8
	ASSUME	MSCP$V_UF_WRTPS GE 8
	ASSUME	MSCP$V_UF_WRTPD GE 8
	ASSUME	UCB$V_MSCP_WRTP GE 8
	BICB	#<UCB$M_MSCP_WRTP@-8>, -; Clear class driver write protected
		UCB$W_DEVSTS+1(R3)	; flag.
	BITB	#<<MSCP$M_UF_WRTPD -	; Is the unit data loss,
		 !MSCP$M_UF_WRTPH -	; hardware, or
		 !MSCP$M_UF_WRTPS>@-8>,-; software write protected?
		MSCP$W_UNT_FLGS+1(R2)
	BEQL	50$			; Branch if not write protected.
	BISB	#<UCB$M_MSCP_WRTP@-8>, -; Else, set the class driver write 
		UCB$W_DEVSTS+1(R3)	; protected flag.

50$:	BBC	#MSCP$V_UF_SSMEM, -	; Branch if unit is not a shadow set
		MSCP$W_UNT_FLGS(R2), 60$; member.
	BBSS	#DEV$V_SSM, -		; Else, set shadow set member device
		UCB$L_DEVCHAR2(R3), 60$	; characteristic.

60$:	RSB				; Return to caller w/ status in R0.

999$:	BUG_CHECK DISKCLASS, FATAL	; This bugcheck is here to catch MSCP
					; servers which return invalid
					; geometry information from a 
					; Get Unit Status to an ONLINE drive
					; red-handed.
	.PAGE
	.SBTTL	START_UNLOAD and START_AVAILABLE

; START_AVAILABLE - Prepare an MSCP packet to do an AVAILABLE command without
;	the spindown modifier.
;
; START_UNLOAD - Prepare an MSCP packet to do an AVAILABLE command with
;	spindown specified.
;
; INPUTS:
;	R1 => I/O function code & modifiers
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	The MSCP packet contains zeros except for:
;
;	MSCP$L_CMD_REF(R2)	<== CDRP$L_RSPID(R5)
;	MSCP$W_UNIT(R2)		<== UCB$W_MSCPUNIT(R3)
;

START_UNLOAD:

	MOVW	#MSCP$M_MD_SPNDW,-	; Specify the SPINDOWN bit in the
		MSCP$W_MODIFIER(R2)	;  modifier word.

START_AVAILABLE:

	MOVB	#MSCP$K_OP_AVAIL,-	; Transfer AVAILABLE opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	IF_IVCMD then=AVAIL_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to the MSCP server.

	ASSUME	UCB$V_VALID GE 8
	BICB	#<UCB$M_VALID @ -8>, -	; Clear software volume valid.
		UCB$W_STS+1(R3)

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	AVAILABLE_SUCC
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	AVAILABLE_MEDOFL
	ACTION_ENTRY	ABRTD, SS$_ABORT,	AVAILABLE_ABORT
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	AVAILABLE_DRVERR
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	AVAILABLE_CTRLERR
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	AVAIL_IVCMD
	ACTION_ENTRY	SHST,  SS$_SHACHASTA,	AVAILABLE_SSSC
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

AVAIL_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	DU_BEGIN_IVCMD		; Rebuild failing MSCP packet.
AVAIL_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
; -----	BRB	AVAILABLE_SUCC		; Fall through to complete available
					; operation.


AVAILABLE_SUCC:				; Action routine for MSCP$K_ST_SUCC.
AVAILABLE_MEDOFL:			; Action routine for MSCP$K_ST_MEDOFL.
AVAILABLE_ABORT:			; Action routine for MSCP$K_ST_ABORT.
AVAILABLE_DRVERR:			; Action routine for MSCP$K_ST_DRVERR.
AVAILABLE_CTRLERR:			; Action routine for MSCP$K_ST_CNTRL.
AVAILABLE_SSSC:
	BBCC	#DEV$V_SSM, -		; Since its not longer one, clear the 
		UCB$L_DEVCHAR2(R3), 10$	; shadow set member device char.
10$:	ASSUME	UCB$V_MSCP_WRTP GE 8
	BICB	#<UCB$M_MSCP_WRTP@-8>, -; Also clear class driver write 
		UCB$W_DEVSTS+1(R3)	; protected flag.
	CLRL	R1			; Clear R1, for I/O status block.
	BRW	FUNCTION_EXIT
	.PAGE
	.SBTTL	START_DSE - Start data security erase
	.SBTTL	START_WRITEPBLK & START_WRITECHECK - Start write opertions
	.SBTTL	START_READPBLK - Start read operation

; START_READPBLK - Prepare an MSCP packet to do a READ command.
;
; START_WRITEPBLK - Prepare an MSCP packet to do a WRITE command.
;
; START_WRITECHECK - Prepare an MSCP packet to do a COMPARE HOST DATA command.
;
; START_DSE - Prepare an MSCP packet to do a ERASE command.
;
; INPUTS:
;	R1 => I/O function code & modifiers
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	The MSCP packet contains zeros except for:
;
;	MSCP$L_CMD_REF(R2)	<== CDRP$L_RSPID(R5)
;	MSCP$W_UNIT(R2)		<== UCB$W_MSCPUNIT(R3)
;

	.ENABLE	LSB

START_DSE:

	MOVB	#MSCP$K_OP_ERASE,-	; Transfer ERASE opcode to packet.
		MSCP$B_OPCODE(R2)
	IF_IVCMD then=90$		; Branch if invalid command processing.
	BRW	AFTER_MAP		; Else, branch around to common code.
90$:	BRW	DSE_IVCMD_END		; Branch assist.

PHYS_IO:				; Out of line code to handle "physical"
					;  READ operations.  I.e. reads of RCT.
	CMPL	CDRP$L_MEDIA(R5),-	; Make sure block to be read within
		UCB$L_DU_TOTSZ(R3)	;  limits of disk.
	BGEQ	3$			; GEQ implies NOT on the disk.
	CMPL	CDRP$L_MEDIA(R5),-	; Make sure block to be read within
		UCB$L_MAXBLOCK(R3)	;  RCT area.
	BLSS	3$			; LSS implies NOT in RCT.
1$:	CMPL	#512,CDRP$L_BCNT(R5)	; Reads of RCT should be 1 block only.
	BGEQ	DO_MAP			; GEQ implies only reading one block.
					;  so we return to inline code.
	MOVZWL	#SS$_IVBUFLEN,R0	; Else indicate error and branch around.
	BRB	6$
3$:
	MOVZWL	#SS$_IVADDR,R0		; Bad address on disk.
6$:
	CLRL	R1			; Clear for I/O status block.
	BSBW	DUTU$RESTORE_CREDIT	; Restore allocated send credit.
	BRW	FUNCTION_EXIT		; And goto common function exit.

START_WRITECHECK:

	MOVB	#MSCP$K_OP_COMP,-	; Compare host data opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	CMPL	CDRP$L_BCNT(R5), -	; Make sure block to WRITECHECK within
		UCB$L_DU_TOTSZ(R3)	;  limits of disk.
	BGEQ	3$			; GEQ implies NOT on the disk.
	CMPL	CDRP$L_BCNT(R5), -	; See if block to WRITECHECK within
		UCB$L_MAXBLOCK(R3)	;  RCT area.
	BLSS	DO_MAP			; LSS implies NOT in RCT so continue.
	BRB	1$			; If in RCT, go check BCNT.

	.DISABLE LSB
;+
; Out of line processing for all read and write modifiers.
;
;	This code section receives control whenever any of the possible
;	modifiers for read or write functions are detected to be set in a 
;	single test in the common read/write code below.  Here the individual 
;	modifiers are checked and processed.  This scheme reduces the number 
;	of instructions in the main-line no-modifiers-set code path.
;-

START_WITH_MODIFIERS:

	BBC	#IO$V_DATACHECK, R1, 10$; Branch if data check not specified.
	ASSUME	MSCP$V_MD_COMP GE 8	; Else, set the read/write with
	BISB	#<MSCP$M_MD_COMP@-8>, -	; data compare modifier.
		MSCP$W_MODIFIER+1(R2)

10$:	BBC	#IO$V_INHRETRY, R1, 20$	; Branch if retries not inhibited.
	ASSUME	MSCP$V_MD_SEREC GE 8	; Else, set the suppress error
	BISB	#<MSCP$M_MD_SEREC@-8>, -; modifier.
		MSCP$W_MODIFIER+1(R2)

20$:	BBC	#IO$V_FORCERR, R1, 30$	; Branch if forced error not specified.
	CMPZV	#IO$V_FCODE, #IO$S_FCODE, -	; Is this a write function?
		R1, #IO$_WRITEPBLK
	BNEQ	30$			; If not, ignore forced error requests.
	ASSUME	MSCP$V_MD_ERROR GE 8	; Else, set the WRITE with forced
	BISB	#<MSCP$M_MD_ERROR@-8>, -; modifier.
		MSCP$W_MODIFIER+1(R2)

30$:	BBC	#IO$V_EXPRESS, R1, -	; Branch if express request not 
		TEST_PHYSIO		; specified.
	ASSUME	MSCP$V_MD_EXPRS GE 8	; Else, set the express request
	BISB	#<MSCP$M_MD_EXPRS@-8>, -; modifier.
		MSCP$W_MODIFIER+1(R2)
	BRB	TEST_PHYSIO		; Rejoin common code.

PHYSICAL:				; Branch assist.
	BRB	PHYS_IO
XFER_IVCMD_END:				; Branch assist.
	BRW	TRANSFER_IVCMD_END

START_WRITEPBLK:

	MOVB	#MSCP$K_OP_WRITE, -	; Setup write MSCP opcode.
		MSCP$B_OPCODE(R2)
	BRB	START_READWRITE		; Join common code.

START_READPBLK:

	MOVB	#MSCP$K_OP_READ, -	; Setup read MSCP opcode.
		MSCP$B_OPCODE(R2)

START_READWRITE:

					; Test for any special modifiers set:
	BITW	#<IO$M_DATACHECK -	;	data check
		 !IO$M_INHRETRY -	;	inhibit retries
		 !IO$M_FORCERR -	;	write forced error
		 !IO$M_EXPRESS>, R1	;	express request
	BNEQ	START_WITH_MODIFIERS	; Branch if any modifier set.

TEST_PHYSIO:

	ASSUME	IRP$V_PHYSIO GE 8
	BITW	#<IRP$M_PHYSIO @ -8>, -	; Is this a physical request?
		CDRP$W_STS+1(R5)
	BNEQ	PHYSICAL		; If physical request, get physical.

DO_MAP:
	IF_IVCMD then=XFER_IVCMD_END	; Branch if invalid command processing.

	MOVAB	CDRP$T_LBUFHNDL(R5),-	; Put address of Local BUFfer HaNDLe
		CDRP$L_LBUFH_AD(R5)	;  field into field that points to it.
	MAP_IRP				; Allocate mapping resources and load
					;  them with data from SVAPTE, BOFF,
					;  and BCNT derived from IRP within
					;  CDRP.

	MOVL	CDRP$L_MSG_BUF(R5),R2	; Refresh R2 => MSCP packet.
	MOVQ	CDRP$T_LBUFHNDL(R5),-	; Copy contents of buffer handle to
		MSCP$B_BUFFER(R2)	;  MSCP buffer descriptor field.
	MOVL	CDRP$T_LBUFHNDL+8(R5),-	; Buffer handle is 96 bits (12 bytes)
		MSCP$B_BUFFER+8(R2)	;  in length.
AFTER_MAP:
	MOVL	CDRP$L_BCNT(R5),-
		MSCP$L_BYTE_CNT(R2)	; Copy byte count of transfer.
	MOVL	CDRP$L_MEDIA(R5),-
		MSCP$L_LBN(R2)		; And also the Logical Block Number.

	SEND_MSCP_MSG	INLINE		; Send message to the MSCP server.

	; To make the normal (successful) case go faster, an explicit test for 
	; a successful MSCP status is made here.  If that test fails, 
	; an action table will be used to determine the appropriate action.
	; If it succeeds, however, we're goin' a git out o' here like a shot.

	IF_MSCP	FAILURE then=TRANSFER_MSCP_ERROR  ; Branch if not successful.

	; Transfer was successful.
	MOVL	#SS$_NORMAL@16, R0	; Set success status.

TRANSFER_RTN_BCNT:			; Common TRANSFER action routine.
					; Here R0 has SS$_ code in hi order.
	MOVL	MSCP$L_BYTE_CNT(R2), R1	; Get # bytes actually transferred.

TRANSFER_SHIFT:

	ASHQ	#-16, R0, R0		; Shift into proper position for IOSB.

	BITB	#MSCP$M_EF_BBLKR, -	; Has a bad block been reported?
		MSCP$B_FLAGS(R2)	; If so,
	BNEQ	XFER_REPLACE		; it must be replaced.

NORMAL_TRANSFEREND:
; -----	BRW	FUNCTION_EXIT		; Fall though to function exit.
	.PAGE
	.SBTTL	FUNCTION_EXIT - Common request completion processing
;++
;
; FUNCTION_EXIT - Common request completion processing
;
; Functional Description:
;
;	If need to log final I/O status call ERL$LOGSTATUS.  Deallocate all 
;	SCS resources held by the request.  If necessary perform special 
;	single stream processing.  Else, complete the request normally.
;
; Inputs:
;
;	R3	UCB address
;	R4	PDT address
;	R5	CDRP address
;
; Outputs: None.
;--

	.ENABLE LSB

FUNCTION_EXIT:

	MOVL	CDRP$L_MSG_BUF(R5), R2	; Get end message address.
	BEQL	20$			; Branch if no end message present.

	BITB	#MSCP$M_EF_ERLOG, -	; Was an error log message generated?
		MSCP$B_FLAGS(R2)
	BNEQ	LOG_FINAL_STATUS	; Branch if error log generated.
	BITL	#CDRP$M_ERLIP, -	; How about a very old error log msg.,
		CDRP$L_DUTUFLAGS(R5)	; which the server has forgotten?
	BNEQ	LOG_FINAL_STATUS	; Branch if error log generated.

20$:	BICL	#CDRP$M_ERLIP, -	; Just in case clear bit.
		CDRP$L_DUTUFLAGS(R5)

	MOVQ	R0,-(SP)		; Save final I/O status on stack.
	BSBW	DUTU$DEALLOC_ALL	; Free resources owned by this CDRP.
	MOVQ	(SP)+,R0		; Restore final I/O status.

	MOVL	UCB$L_CDDB(R3), R2	; Get CDDB address in R2.
	BITW	#CDDB$M_SNGLSTRM, -	; Is CDDB in single stream mode?
		CDDB$W_STATUS(R2)
	BNEQ	SINGLE_STREAM		; Branch if single stream.
	ALT_REQCOM			; Else, complete the request.

LOG_FINAL_STATUS:
	JSB	G^ERL$LOGSTATUS		; Go log software status for errorlog.
	BRB	20$			; Rejoin mainline code.

SINGLE_STREAM:
	PUSHR	#^M<R2,R4>		; Save CDDB and PDT addresses.
	JSB	G^IOC$ALTREQCOM		; Complete request, but keep control.
	POPR	#^M<R3,R4>		; Restore CDDB and PDT addresses.
	BRW	RESTART_NEXT_CDRP	; Branch to code to restart next CDRP.
	.DISABLE LSB
	.PAGE
	.SBTTL	READ/WRITE Error processing

	.ENABLE LSB

XFER_REPLACE:				; A branch assist.
	BRW	TRANSFER_REPLACE

; All data transfer error cases begin their processing here.
;
; CDRP$L_MSG_BUF and R2 point to the END PACKET which was returned by the 
; server.

TRANSFER_MSCP_ERROR:

	DO_ACTION	TRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	TRANSFER_MEDOFL
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	DATA,  SS$_FORCEDERROR,	TRANSFER_DATA_ERROR
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	WRTPR, SS$_WRITLCK,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	COMP,  SS$_DATACHECK,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	MFMTE, SS$_FORMAT,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	ABRTD, SS$_ABORT,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	TRANSFER_INVALID_COMMAND
	ACTION_ENTRY	HSTBF, SS$_IVBUFLEN,	TRANSFER_HOST_BUFFER_ERROR
	ACTION_ENTRY	SHST,  SS$_SHACHASTA,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

TRANSFER_INVALID_COMMAND:

	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	DU_BEGIN_IVCMD		; Repeat MSCP command packet setup
					; upto but not including the MAP_IRP.
					; Then do everything after the 
TRANSFER_IVCMD_END:			; MAP_IRP here, by hand.
	ASSUME	CDRP$S_LBUFHNDL EQ 12
	MOVQ	CDRP$T_LBUFHNDL(R5), -	; Copy contents of buffer handle to
		MSCP$B_BUFFER(R2)	; MSCP buffer descriptor field.
	MOVL	CDRP$T_LBUFHNDL+8(R5), -
		MSCP$B_BUFFER+8(R2)
DSE_IVCMD_END:
	MOVL	CDRP$L_BCNT(R5), -	; Copy transfer byte count.
		MSCP$L_BYTE_CNT(R2)	
	MOVL	CDRP$L_MEDIA(R5), -	; Copy starting logical block number.
		MSCP$L_LBN(R2)

	IVCMD_END			; Complete invalid command processing.
	BLBC	R1, 35$			; If this is the first time through
					; here, try the MSCP command one more
					; time.
	CLRL	R1			; Else, clear "byte count."
	BRW	TRANSFER_SHIFT		; And blow this operation away.

TRANSFER_MEDOFL:

	BBC	#MSCP$V_SC_INOPR,-	; Branch around if NOT unit inoperative
		MSCP$W_STATUS(R2),-	;  substatus.
		XFER_RTN_BCNT
	MOVL	#SS$_DRVERR@16,R0	; Else set up R0 with proper SS$_ code
					;  in high order word and
	BRW	TRANSFER_RTN_BCNT	; Branch around.

TRANSFER_HOST_BUFFER_ERROR:

	EXTZV	#MSCP$S_ST_MASK,-	; Extract the sub-code only.
		#16-MSCP$S_ST_MASK,-
		MSCP$W_STATUS(R2),R1
	CMPW	#MSCP$K_SC_ODDBC,R1	; Compare to Odd Byte Count error.
	BEQL	XFER_RTN_BCNT		; Branch around if Odd BCNT.
	BRW	INVALID_STS		; Here we got an invalid MSCP status.

TRANSFER_DATA_ERROR:			; TRANSFER action routine for MSCP$K_ST_DATA.
					; Here R0 contains SS$_FORCEDERROR in
					;  high order word.
	MOVZWL	MSCP$W_STATUS(R2),R1	; Zero extend MSCP status.

;	ASSUME THAT FORCED ERROR SUBCODE IS ZERO.

	ASHL	#-MSCP$S_ST_MASK,R1,R1	; Shift out major status code.
	BEQL	XFER_RTN_BCNT		; EQL implies that it was forced error
					;  so we simply branch since we already
					;  have R0 set up.
	MOVL	#SS$_PARITY@16,R0	; Else set up R0 with proper SS$_ code
					;  in high order word.
XFER_RTN_BCNT:
	BRW	TRANSFER_RTN_BCNT	; Now, go complete the request.

TRANSFER_REPLACE:			; Here perform Bad Block Replacement.

	BBC	#MSCP$V_EF_ERLOG,-	; Branch around if End Message does NOT
		MSCP$B_FLAGS(R2),30$	;  have ERLOG flag set.
	BISL	#CDRP$M_ERLIP, -	; Else set corresponding bit in CDRP to
		CDRP$L_DUTUFLAGS(R5)	;  remember this fact.

30$:	BBS	#UCB$V_MSCP_WRTP, -	; If device is write protected, don't
		UCB$W_DEVSTS(R3), -	; even attempt to perform the replace;
		XFER_NORMALEND		; it won't work.
	MOVQ	R0,CDRP$L_IOQFL(R5)	; Store valid I/O status in unused
					;  FLINK and BLINK of IRP portion.
	BSBW	DU$LOCK_HIRT		; Grab hold of HIRT.
	BSBW	DU$REPLACE_LBN		; Perform the replacement.
	BSBW	DU$UNLOCK_HIRT		; Release HIRT.
	MOVL	R0, R2			; Copy replacement status to R2.
	TSTL	R5			; Was CDRP canceled?
	BNEQ	32$			; Branch if CDRP not canceled.
	RSB				; Else, kill this thread.

32$:	BISW	R1, CDRP$L_DUTUFLAGS(R5); Set ERLOGIP bit if on in R1.
	MOVQ	CDRP$L_IOQFL(R5),R0	; Restore I/O status of original QIO.
	BLBC	R2,60$			; LBC means unsuccessful replacement.

					; If here replacement successful
	BLBS	R0, XFER_NORMALEND	; LBS means original I/O was success.
	
35$:
	PUSHL	CDRP$L_RSPID(R5)	; Save current RSPID so as to possibly
					;  reuse.
	BBS	#CDRP$V_ERLIP, -	; If set, we reuse RSPID so that error
		CDRP$L_DUTUFLAGS(R5), -	;  log messages co-relate. So we branch.
		40$
	CLRL	(SP)			; If no errorlog, erase RSPID to prevent
	BRB	50$			;  spurious deallocates and branch.
40$:
	CLRL	CDRP$L_RSPID(R5)	; Prevent current RSPID from being deallocated.
50$:
	BSBW	DUTU$DEALLOC_ALL	; Free resources owned by this CDRP before
					;  retrying operation.
	POPL	CDRP$L_RSPID(R5)	; Restore RSPID or zero to CDRP.
	BRW	DU_RESTARTIO		; Else go to retry the original request.
60$:
	MOVW	R2,R0			; Replace failed replacement status.
XFER_NORMALEND:
	BRW	FUNCTION_EXIT		; And branch to FUNCTION_EXIT.
	.DISABLE	LSB

;; This code previously resided prior to label 24$ above.  It is left here
;;	as reference material.
;;
;	BBC	#IRP$V_PHYSIO,-		; Branch around if NOT physical I/O.
;		CDRP$W_STS(R5),24$
;	BBC	#IRP$V_FUNC,-		; Branch around if NOT read function.
;		CDRP$W_STS(R5),24$
;
;; Here if this is a read physical function.  We must back translate the
;;	physical media address to an LBN.
;;
;; User specified physical media address has following format: (in CDRP$L_MEDIA)
;;
;;	._______________________________._______________._______________.
;;	!				!		!		!
;;	!         Cylinder		!     Track	!     Sector	!
;;	!_______________________________!_______________!_______________!
;
;
;	MOVZBL	UCB$B_TRACKS(R3),R0	; R0 = tracks/cylinder.
;	MOVZBL	UCB$B_SECTORS(R3),R1	; R1 = sectors/track.
;	MULL	R1,R0			; R0 = sectors/cylinder.
;	MOVZWL	CDRP$L_MEDIA+2(R5),-(SP); Push user specified cylinder #.
;	MULL	R0,(SP)			; (SP) = LBN of 1st sector in cylinder.
;	MOVZBL	CDRP$L_MEDIA+1(R5),R0	; R0 = user specified track #.
;	MULL	R0,R1			; R1 = relative LBN of 1st sector on track.
;	MOVZBL	CDRP$L_MEDIA(R5),R0	; R0 = user specified sector #.
;	ADDL	R0,R1			; R1 = relative LBN of user sector.
;	ADDL3	R1,(SP)+,MSCP$L_LBN(R2)	; Deposit calculated LBN into packet.
	.PAGE
	.SBTTL	re-CONNECTION after VC error or failure

; DU$CONNECT_ERR - Block of code invoked during the time that we
;	re-CONNECT to the intelligent controller following some disturbance
;	that caused dismanteling of the logical CONNECTION between the
;	class driver and the controller.  The ultimate purpose of the code
;	here is to locate all CDRP's relevant to this controller and place
;	them in the proper order into CDDB$L_RSTRTQFL.  Once
;	all the CDRP's are on this list we "execute" each of these CDRP's, one
;	by one, until they are all done.  When the last such CDRP is completed
;	we resume normal QIO processing.  This code works in cooperation with
;	code in FUNCTION_EXIT.
;
;	We are invoked here either by the Port Driver calling us at our error
;	entry point or by the Disk Class Driver branching here as a result of
;	deciding that the intelligent controller has gone "insane".
;
;	The actions herein taken are the following:
;
;	1.  We disable the Timeout Mechanism Routine wakeups by placing a
;		longword of all 1's in CRB$L_DUETIME.
;
;	2.  In order to prevent new CDRP's from starting up, we increment
;		UCB$W_RWAITCNT for each UCB associated with this controller.
;		This count is used to count the number of CDRP's associated
;		with a UCB that have run into resource wait situations.
;		Whenever this count is non-zero, new CDRP's are automatically
;		backed up onto the UCB$L_IRPQFL queue.  Incrementing this
;		count here, insures that it will not be run to zero and will
;		cause all new CDRP's to backup.
;
;	3.  We deallocate resources owned by the permanent CDRP used by the
;		Timeout Mechanism Routine.
;
;	4.  At the time that we are called here, our active CDRP's can be
;		found in one of the following places:
;
;		a) On the HIRT wait Q.  If here note that the associated UCB
;		   RWAITCNT has been bumped due to being on this list in
;		   addition to the bump given in step 2 above.
;
;		b) On the RDT resource wait Q.  Here also RWAITCNT has been
;		   bumped once to many times.
;
;		c) On the CDDB$L_CDRPQFL.  Here RWAITCNT is normal except for
;		   the bump given in step 2.
;
;		d) On some other resource wait Q (Flow control, message buffer,
;		   mapping resources, etc.). Here again RWAITCNT has been bumped
;		   once to much.
;
;		e) On the CDDB$L_RSTRTQ.  If here, the CONNECTION has failed
;		   while we were in the middle of cleaning up a previous
;		   CONNECTION failure.  The CDRP's here need no further
;		   gathering.
;
;		Our aim here is to gather all the active CDRP's onto the
;		CDDB$L_RSTRTQ.  To do this we search for them in the above
;		mentioned places in the order in which they were mentioned.
;		This order is important as will be explained below.
;
;	5.  Note here that at the time of the call to DU$CONNECT_ERR, we
;		may have been on the middle of MOUNT VERIFICATION.  In such
;		a case the particular volume would have been marked as
;		invalid and during re-CONNECTION we would not try to bring
;		the unit online.  Also we would have a set of inactive
;		(i.e. no resources allocated for them) CDRP'a (IRP's) on
;		the MOUNT VERIFICATION QUEUE of the UCB and possibly one
;		MOUNT VERIFICATION specific CDRP active.  This all meshes
;		perfectly with our re-CONNECTION design.  The contents of
;		the MOUNT VERIFICATION QUEUE can be ignored.  The active
;		MOUNT VERIFICATION CDRP will be treated normally.  Its
;		I/O will be retried and will probably fail and MOUNT
;		VERIFICATION will re-submit it and it will wind up on the
;		normal UCB I/O QUEUE awaiting the RWAITCNT's going to zero.
;		After re-CONNECTION, it will start up normally and everything
;		should resume transparently.
;
;	6.  First we scan the HIRT wait Q and remove any CDRP's associated
;		with the current CDDB.  We do this first so that if perchance,
;		some of our CDRP's are here, they will not be selected
;		inadvertantly when the current HIRT owner is possibly killed.
;
;		This scan is done by going down the entire HIRT wait Q and
;		removing the 1st entry of ours that we find.  If in a pass
;		we DO remove an entry , then we go back and scan from the
;		start of the Q.  When we make an entire pass without any hits,
;		we finish.  Note that when we remove an entry, we decrement
;		the RWAITCNT prior to calling INSERT_RSTRTQ to undo the bump
;		we gave in calling LOCK_HIRT.
;
;	7.  We scan the RDT resource wait Q.  Again we scan until we find our
;		first entry and after a removal we begin to scan from the
;		beginning.  Only a clean scan ends the process.  Also we
;		must decrement RWAITCNT for each removal.
;
;	8.  We REMQUE each entry on CDDB$L_CDRPQFL and call INSERT_RSTRTQ
;		for each one.
;
;	9.  Here we should note that INSERT_RSTRTQ deallocates all resources
;		owned by a CDRP prior to inserting it in CDDB$L_RSTRTQ.
;		Because of this, the only CDRP's belonging to us that still
;		own RSPID's are the CDRP's which are on other resource wait
;		queues.  So here we scan the RDT looking for entries that
;		belong to us.  When we find one we REMQUE it, decrement its
;		RWAITCNT and call INSERT_RSTRTQ for it.  Note that this
;		deallocates its resources and as a result of this could cause
;		another of our CDRP's to receive these resources and proceed
;		up to the CDDB$L_CDRPQFL.  Therefore after a removal here,
;		we branch back to step 7 to safeguard against this possibility.
;		A complete scan of the RDT with no hits implies that we now
;		have gathered all our CDRP's and that we can continue.
;
;*********************************************************************
;	9.  If the two counts above are equal, then we have all CDRP's on
;		CDDB$L_RSTRTQFL.  No more CDRP's will trickle in so we clear
;		CDDB$M_CDRPTRCKL in CDDB$W_STATUS.
;
;	10. We DISCONNECT the now dead connection and then re-CONNECT to
;		establish a new channel to the MSCP server in the controller.
;
;	11. We are now ready to begin single stream execution of CDRPs, until
;		exhaust the contents of the CDRP$L_RSTRTQFL.  However we
;		want to guard against the possibility that a particular
;		request (i.e. CDRP) may repeatedly hang a controller (i.e.
;		cause a re-CONNECTION) and thereby prevent anything from
;		getting through.  To deal with this we only retry a given
;		request a fixed maximum number of times (MAX_RETRY).  The
;		algorithm which resolves this retry logic dilemma relies
;		on several data items in the CDDB:
;
;			a) CDDB$L_RSTRTCDRP - the address of the CDRP that is
;			    currently being processed in single stream mode if
;			    we are in single stream mode.
;
;			b) CDDB$B_RETRYCNT - the number of remaining retries
;			    for the current CDRP being processes in single
;			    stream mode if we are in single stream mode.
;
;			c) CDDB$V_SNGLSTRM - bit in CDDB$W_STATUS which tells
;			    us if we are in single stream mode.
;
;		The algorithm is as follows: If upon selecting the first CDRP
;		on CDDB$L_RSTRTQFL, we find CDDB$V_SNGLSTRM clear, we merely
;		set it and we can be assurred that this is the first time
;		that we are attempting to retry this request in single stream
;		mode.  This is so because the bit being clear implies either
;		that this is the first re-CONNECTION since the system came up
;		or that the last re-CONNECTION ran to completion thereby leaving
;		the bit clear.  In this case we select this first CDRP, set
;		CDDB$B_RETRYCNT to the maximum and establish this CDRP as the
;		current one by storing its address in CDDB$L_RSTRTCDRP.
;
;		If however CDDB$V_SNGLSTRM is set upon selecting a CDRP, we
;		must compare the CDRP address to the current value of
;		CDDB$L_RSTRTCDRP.  If they are NOT equal, then again this is
;		the first retry attempt for this CDRP and we merely set the
;		CDDB$B_RETRYCNT to the maximum and store the CDRP in
;		CDDB$L_RSTRTCDRP.  If the CDRP has the same address however,
;		we must decrement one from the retry count and if it is not
;		exhausted attempt to process the CDRP again.
;
;		Note this all works even though the address of a CDRP is not
;		necessarily unique. That is, many I/O requests in the life of
;		the system may occupy the same CDRP in virtual space.  However,
;		once re-CONNECTION logic begins, it deals only with the CDRPs
;		on the CDDB$L_RSTRTQFL.  This list never grows until re-
;		CONNECTION is run to completion since all new IRPs are
;		being backed up.  Therefore even though we may run repeated
;		re-CONNECTIONs that do not run to completion but rather each
;		causes the connection to go down, through all this the
;		CDDB$L_RSTRTQFL is always monotonically decreasing and no
;		new CDRPs are entered onto it that were not there at the time
;		that we began to process the first re-CONNECTION.  In a fixed
;		list of CDRPs which all exist at the same time, the address
;		is a unique descriptor.
;
;	12. Note that CDDB$M_SNGLSTRM in CDDB$W_STATUS acts as a flag to
;		FUNCTION_EXIT so that it can aid in the one at a time re-
;		execution of the CDRP's.
;
;	13. For debugging sake, we loop thru all UCB's and check that their
;		UCB$W_RWAITCNT values are all equal to 1.
;		Also for debugging sake we check that CDDB$L_CDRPQFL is
;		empty.
;
;	14. We REMQUE the 1st CDRP on CDDB$L_RSTRTQFL and branch to
;		DU_RESTARTIO to begin its execution.
;
; Inputs: (for DU$RE_SYNCH)
;	R3 => CRB


DU$RE_SYNCH:

	MOVL	CRB$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	MOVL	CDDB$L_PDT(R3),R4	; R4 => PDT.
	CMPB	#MSCP$K_CM_EMULA, -	; If this is the MSCP server, the right
		CDDB$B_CNTRLMDL(R3)	; resynch technique is DISCONNECT.
	BEQL	RECONN_COMMON		; So, skip the MRESET setup.
	BISW	#CDDB$M_RESYNCH,-	; Signal that we should reset
		CDDB$W_STATUS(R3)	;  intelligent controller.
	BRB	RECONN_COMMON		; Branch around to common code.

; Inputs: (for DU$CONNECT_ERR)
;	R3 => CDT
;	R4 => PDT
;

DU$CONNECT_ERR:

	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
RECONN_COMMON:
	INCW	CDDB$W_RSTRTCNT(R3)	; Count number times thru here.
	BICW	#<CDDB$M_IMPEND -	; Signal: no immediate command pending
		 !CDDB$M_INITING -	; 	  out of initialization
		 !CDDB$M_SNGLSTRM -	; 	  no single stream in progress
		 !CDDB$M_RSTRTWAIT>,-	;	  not waiting to restart CDRPs
		CDDB$W_STATUS(R3)
	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Prevent Timeout Mechanism wakeups.

	BISW	#CDDB$M_RECONNECT,-	; Indicate that we are re-connecting
		CDDB$W_STATUS(R3)	;  state.

	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB address in R1.
		 -CDDB$L_UCBCHAIN>, -
		R3, R1

10$:	MOVL	UCB$L_CDDB_LINK(R1), R1	; Chain to next UCB.
	BEQL	20$			; EQL implies no more UCB's here.
	BBSS	#UCB$V_MSCP_WAITBMP, -	; If already bumped, branch around;
		UCB$W_DEVSTS(R1), 10$	; else indicate RWAITCNT bumped.
	INCW	UCB$W_RWAITCNT(R1)	; Prevent new CDRP's from starting up.
	BRB	10$			; Go look for more UCB's.
20$:

;
; Now we are sure that no new CDRP's will start.
;

	BSBW	DUTU$DISCONNECT_CANCEL	; Perform disconnect cancel cleanup.

; Deallocate RSPID & message buffer on each of the CDDB perm. IRP/CDRP pairs.

	MOVAB	CDDB$A_PRMCDRP(R3), R5	; Get permanent CDRP address.
	BSBW	DUTU$DEALLOC_RSPID_MSG	; Deallocate its RSPID & msg. buf.
	MOVAB	CDDB$A_DAPCDRP(R3), R5	; Get DAP permanent CDRP address.
	BSBW	DUTU$DEALLOC_RSPID_MSG	; Deallocate its RSPID & msg. buf.

;
;	Registers here are:
;		R3 => CDDB
;		R4 => PDT.
;		R5 => Permanent CDRP.
;

	BSBW	DU$DISCONNECT_HIRT	; Cleanup HIRT wait queue.

; All CDRPs belonging to this CDDB have been removed from the HIRT wait queue.

; Locate and prepare for restarting all CDRPs currently waiting for a RSPID.
; Since the class driver allocates a RSPID as the first step in any function,  
; CDRPs found now will not be holding any resources and will not be active.  
; Since these CDRPs hold no resources, their cleanup will not cause any other 
; waiting requests to become active.  (This fact is not currently used, but it 
; might be useful.)

	MOVL	CDDB$L_CDT(R3), R3		; Get CDT address.

	CLRL	R1				; Set SCAN_RSPID_WAIT flag.
	SCAN_RSPID_WAIT -			; Use SCS service to scan RSPID
		action = DUTU$RECONN_LOOKUP	; wait queue.
						; DUTU$RECONN_LOOKUP is in
						; DUTUSUBS.

; Remove all CDRPs on the active requests queue.  These CDRPs:
;   a. have outstanding requests in the intelligent controller, 
;   b. suffered allocation failures due to a broken connection,
;   c. represent the request during which an "insane" controller was detected.
; In any case, these CDRPs are not on any resource wait queue and do not have 
; their associated resource wait count bumped due to need for a resource.

	BSBW	DUTU$DRAIN_CDDB_CDRPQ		; Cleanup active requests.

; Now scan the entire Response-id Descriptor Table for any remaining CDRPs 
; belonging to this connection.  Presumably these CDRPs are on a resource wait 
; queue somewhere.  In addtion, releasing whatever resources such CDRPs hold 
; may cause other waiting CDRPs to become active.  Therefore, after every CDRP 
; is located and processed, the active CDRP queue must be scanned again.

	INCL	R1				; Set SCAN_RDT flag.
	SCAN_RDT -				; Use SCS service to scan RDT.
		action = DUTU$RECONN_LOOKUP	; DUTU$RECONN_LOOKUP is in
						; DUTUSUBS.

	MOVL	CDT$L_AUXSTRUC(R3), R3		; Restore the CDDB address.

RESTART_FIRST_CDRP:

;
; We come here either by falling thru from above code or by branching here
;	from CALL_SEND_MSG_BUF when the last CDRP has trickled in.
;
;
; If here all CDRP's are in CDDB$L_RSTRTQFL.  So no more will trickle.
;	Clear bit that prevents CALL_SEND_MSG_BUF from doing its job.
;
; INPUTS:
;	R3 => CDDB
;	R4 => PDT
;


;
; Here we DISCONNECT the old connection.
;

	MOVAB	CDDB$A_PRMCDRP(R3), R5	; CDRP into R5 for coming BSBWs.
	MOVL	R3,R0			; R0 => CDDB.
	MOVL	CDRP$L_CDT(R5),R3	; Set R3 => CDT.
	BISW	#CDDB$M_NOCONN, -	; Set no connection active flag.
		CDDB$W_STATUS(R0)
	BBCC	#CDDB$V_RESYNCH,-	; Do NOT branch around if we were called
		CDDB$W_STATUS(R0),2$	;  in order to re-synchronize.
	MOVL	CDT$L_PB(R3),R3		; R3 => Path Block for MRESET, etc.
	MRESET	PB$B_RSTATION(R3),#1	; Force controller to reset itself.
	MSTART	PB$B_RSTATION(R3)	; And force controller to restart itself.
	RSB				; Kill this thread. Rely on Port
					;  Driver calling error routine as
					;  a result of MRESET to accomplish
					;  DISCONNECT and subsequent logic.
2$:
	DISCONNECT	#DISCONNECT_REASON

					; Restore R3 => CDDB after disconnect.
	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3

;
; Deallocate mapping resources 
;

	; Any mapping resources still owned by CDRPs on the restart queue are 
	; deallocated here.  This deallocation is delayed until after the 
	; DISCONNECT (and possible MRESET) to prevent an "insane" controller 
	; from continuing to transfer via possibly re-allocated mapping 
	; resources.  Once the mapping resources are released, I/O requests 
	; related to "mounting" a disk are released so that $MOUNT or mount 
	; verification can take appropriate action.  This is done by 
	; releaseing any request with IRP$V_MVIRP or directed to a device with 
	; UCB$V_VAILD clear is released.  The mount verification case is 
	; obvious and experience shows that $MOUNT does not set UCB$V_VALID 
	; before issuing the IO$_PACKACK.

	PUSHAB	CDDB$L_RSTRTQFL(R3)	; Setup listhead address.
	PUSHL	CDDB$L_RSTRTQFL(R3)	; Setup first CDRP address.

4$:	POPL	R5			; Get next CDRP address.
	CMPL	R5, (SP)		; Is it the listhead?
	BEQL	6$			; If yes, all deallocations are done.
	BSBW	DUTU$DEALLOC_ALL	; Free MAP resources owned by this CDRP.
	PUSHL	(R5)			; Push next CDRP address.
	MOVL	CDRP$L_UCB(R5), R0	; Get UCB address.
	BBC	#UCB$V_VALID, -		; Branch to post the IRP if this
		UCB$L_STS(R0), 5$	; device is not "volume valid."
	BBC	#IRP$V_MVIRP, -		; Is this a mount verification IRP?
		CDRP$W_STS(R5), 4$	; Branch if not an MV IRP.
5$:	REMQUE	(R5), R0		; Else, remove IRP/CDRP from restart
	POST_CDRP status=SS$_MEDOFL	; queue and send it to post processing.
	BRB	4$			; Loop till all restart CDRPs are done.

6$:	TSTL	(SP)+			; Clear listhead pointer from stack.

	; Deallocate mapping resources whose description is stored in the 
	; CDDB permanent CDRP.  This information was placed there by 
	; DUTU$INSERT_RESTARTQ when it discovered that the HIRT permanent CDRP 
	; owned mapping resources.  In this way, another thread is allowed to 
	; use the HIRT permanent CDRP while this connection is broken.

	MOVAB	CDDB$A_PRMCDRP(R3), R5	; Get CDRP in R5.
	BSBW	DUTU$DEALLOC_ALL	; Free old HIRT MAP resources.
					;  the HIRT CDRP and whose ownership
					;  has been transferred here.

	BSBW	DU_REVALIDATE_DISKS	; Start mount verification for online
					; devices.  Starting MV here allows
					; MV to perform failover, if that's 
					; possible.

;
; re-CONNECT - Here we call an internal subroutine which:
;
;	1. Makes a connection to the MSCP server in the intelligent
;		controller.
;
;	2. Sends an MSCP command to SET CONTROLLER CHARACTERISTICS.
;
;	3. Allocates an MSCP buffer and RSPID for our future use in
;		connection management.
;
; Upon return R4 => PDT and R5 => CDRP.
;

	MOVAB	CDDB$A_PRMCDRP(R3), R5	; Get permanent CDRP address.
	BSBW	MAKE_CONNECTION		; Call subroutine to connect.

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3
	BBS	#MSCP$V_CF_REPLC, -	; Branch if controller will perform
		CDDB$W_CNTRLFLGS(R3),10$; bad block replacement operations.
	BSBW	DU$INIT_HIRT		; Else, initialize HIRT.

10$:	; Now it is necessary to propogate all the connection dependent 
	; information regarding the newly formed connection to the MSCP server 
	; to all the UCB's in the primary chain for this CDDB.  At the same 
	; time, every RWAITCNT value is tested to insure that it is consistant 
	; with what would be expected based upon the various possible reasons 
	; which cause it to be bumped.  This is merely a debugging exercise.  
	; In END_SINGLE_STREAM, RWAITCNT will be reduced by one and the wait 
	; count bumped flag will be cleared.

	MOVAB	<CDDB$L_UCBCHAIN -	; Setup "previous" UCB address.
		-UCB$L_CDDB_LINK>(R3), -
		R5
15$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Link to next UCB.
	BEQL	30$			; Branch if no more UCBs to test.
	BSBW	DUTU$INIT_CONN_UCB	; Setup connection dep. UCB fields.
	BSBW	DUTU$CHECK_RWAITCNT	; Validate the wait count value.
	BRB	15$			; Loop through all UCBs.

30$:	; It is now possible to execute requests on behalf of any pending 
	; mount verification threads.  Therefore, the CDDB$V_NOCONN bit is 
	; cleared.

	BICW	#CDDB$M_NOCONN, CDDB$W_STATUS(R3)
	MOVL	CDDB$L_CRB(R3),R0	; Get CRB address.
	MOVAB	W^DU$TMR, -		; Establish permanent timeout routine.
		CRB$L_TOUTROUT(R0)
	MOVZWL	CDDB$W_CNTRLTMO(R3), R1	; Get controller timeout interval.
	ADDL3	R1, G^EXE$GL_ABSTIM, -	; Use that to set next timeout 
		CRB$L_DUETIME(R0)	; wakeup time.

	; The normal MSCP timeout mechanism is now in effect.  Henceforth,
	; no fork thread may use the CDDB permanent CDRP as a fork block.
	;
	; While the mount verification threads are being handled, also poll 
	; for any previously unknown devices handled by this server.

	ASSUME	CDDB$V_DAPBSY GE 8
	BISB	#<CDDB$M_DAPBSY @ -8>, -; Set DAP CDRP in use flag.
		CDDB$W_STATUS+1(R3)
	MOVL	CDDB$L_DAPCDRP(R3), R5	; Get DAP CDRP address.
	BSBW	DUTU$POLL_FOR_UNITS	; Poll for units.
	BICB	#<CDDB$M_DAPBSY @ -8>, -; Clear DAP CDRP in use flag.
		CDDB$W_STATUS+1(R3)

	; At this point, there once was a test for an empty CDDB$L_CDRPQFL.
	; Such a test is no longer valid because mount verification processing 
	; may very well have CDRPs active on the connection represented by 
	; this CDDB.

;
; Restore normal CRB timeout routine and interval.
;
	MOVL	CDDB$L_CRB(R3), R0	; Get CRB address.
	MOVAB	W^DU$TMR, -		; Re-establish normal timeout 
		CRB$L_TOUTROUT(R0)	; routine.
	MOVZWL	CDDB$W_CNTRLTMO(R3), R1	; Establish controller specified
	ADDL3	R1, G^EXE$GL_ABSTIM, -	; delta time as normal timeout 
		CRB$L_DUETIME(R0)	; interval for timeout mechanism.

; At this point, the reconnection thread may need to be suspended (you may 
; wish to think of it as ended) until mount verification completes for all the 
; disks (or UCBs) which had mount verification started by DU_REVALIDATE_DISKS.  
; This is necessary if and only if CDDB$W_WTUCBCTR is non-zero, indicating 
; that one or more UCBs are waiting for mount verification to complete.  When 
; this thread is "suspended," the end mount verification routine will call 
; RESTART_NEXT_CDRP when the count of UCBs waiting for mount verification to 
; complete reaches zero.  This scheme is described in excruciating detail in
; the DU_REVALIDATE_DISKS preamble.

	TSTW	CDDB$W_WTUCBCTR(R3)	; Are any UCBs waiting for mnt. ver.?
	BEQL	RESTART_NEXT_CDRP	; Branch if no UCBs are waiting.
	BISW	#CDDB$M_RSTRTWAIT, -	; Else, signal that connection is 
		CDDB$W_STATUS(R3)	; waiting to restart CDRPs and
	RSB				; "suspend" the reconnect thread.
	.PAGE
RESTART_NEXT_CDRP:

;
; Here we attempt to initiate the first (i.e. next) CDRP on the restart queue.
;	In order to prevent getting caught in an infinite loop trying to
;	initiate an operation that the controller cannot complete for
;	one reason or another, we maintain a retry count and the address
;	of the CDRP that we are currently single streaming.
;
;	In the normal case this is an isolated re-CONNECTION and the
;	first CDRP on the restart queue is a random CDRP.  We notice this
;	by seeing that the address of our first CDRP is not equal to the
;	current contents of CDDB$L_RSTRTCDRP.
;
;	In the other case the connection failed while we were in single
;	stream mode and the CDRP which we happened to be processing is the
;	same CDRP that now heads our restart queue.  In this case, before
;	initiating the processing of this CDRP, we decrement 1 from the
;	retry count and if it remains non-zero, we restart the CDRP
;	processing.  If the decrementing results in a zero retry count,
;	then we log the event and effectively abort the CDRP by branching to
;	FUNCTION_EXIT with an appropriate error status.  FUNCTION_EXIT, due
;	to the setting of the CDDB$M_SNGLSTRM bit will then start the
;	processing of the next CDRP on the restart queue.
;
; We can arrive here either by falling through from the above code or via
;	a branch from FUNCTION_EXIT.  In either case we have:
;
; INPUT:
;	R3 => CDDB
;

	REMQUE	@CDDB$L_RSTRTQFL(R3),R5	; R5 => 1st CDRP on restart queue.
	BVS	END_SINGLE_STREAM	; VS implies restart was empty.
	BBCS	#CDDB$V_SNGLSTRM,-	; Set bit and if clear, this is 1st
		CDDB$W_STATUS(R3),20$	;  time here for this CDRP, so branch.
	CMPL	R5,CDDB$L_RSTRTCDRP(R3)	; See if same CDRP as last time.
	BNEQ	20$			; NEQ implies not the same.
	DECB	CDDB$B_RETRYCNT(R3)	; If same, decrement 1 from retries.
	BNEQ	30$			; NEQ implies retries remaining.

;
; *******************************Log this error.******************************
;

	MOVL	#SS$_CTRLERR,R0		; Indicate appropriate error status.
	CLRL	R1			;  And set second part of I/O status.
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BRW	FUNCTION_EXIT
20$:
	MOVL	R5,CDDB$L_RSTRTCDRP(R3)	; Establish new single stream CDRP.
	MOVB	#MAX_RETRY,-		; Establish fresh retry count.
		CDDB$B_RETRYCNT(R3)
30$:
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BRW	DU_RESTARTIO		; Restart the CDRP.


END_SINGLE_STREAM:

;
; Here we want to resume normal operation and get each unit going.
;	To do this we pickup each UCB in turn and call SCS$UNSTALLUCB
;	for it.  This has the effect of starting up as many (perhaps all)
;	of the IRP's (that's right IRP's) as possible that may have
;	backed up on the UCB input queue while we were in single stream mode.
;	We then go on to the next UCB until we exhaust all UCB's connected
;	to this CDDB.
;

	BICW	#CDDB$M_SNGLSTRM, -	; Clear single streaming CDRPs flag.
		CDDB$W_STATUS(R3)
	MOVZWL	CDDB$W_RSTRTCNT(R3), R0	; Get current restart count.
	MOVAB	<CDDB$L_UCBCHAIN -	; Setup "previous" UCB address.
		-UCB$L_CDDB_LINK>(R3), -
		R5

10$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Point to next UCB.
	BEQL	30$			; Branch if no more UCBs to process.
	BICW	#UCB$M_MSCP_WAITBMP, -	; Indicate RWAITCNT no longer bumped.
		UCB$W_DEVSTS(R5)
	DECW	UCB$W_RWAITCNT(R5)	; Unbump wait count.
	BSBW	DUTU$CHECK_RWAITCNT	; Else, check wait count and
	PUSHR	#^M<R0,R3>		; Save restart cnt. and CDDB address.
	JSB	G^SCS$UNSTALLUCB	; Start up IRPs on UCB.
	POPR	#^M<R0,R3>		; Restore restart cnt. and CDDB address.
	CMPW	R0, CDDB$W_RSTRTCNT(R3)	; Did the unstall cause a restart?
	BEQL	10$			; Branch if no restart was caused.
	RSB				; Else, discontinue this thread.

30$:	BICW	#CDDB$M_RECONNECT, -	; Clear reconnect in progress bit.
		CDDB$W_STATUS(R3)
	RSB				; Ta De, Ta De, that's all folks.
	.PAGE
	.SBTTL	DU$TMR - Class Driver Timeout Mechanism Routine

;+
; DU$TMR - Time out Mechanism Routine.  This routine is called
;  periodically whenever CRB$L_DUETIME becomes due.  At the time of a
;  periodic call to DU$TMR the Class Driver is in one of three states
;  with respect to the intelligent mass storage controller associated
;  with the CRB pointed at by R3.
;
;	1. State #1, the "normal" state for which this routine is optimized,
;	    is characterized by the following two conditions:
;
;		a) One or more MSCP commands are outstanding to the controller.
;		    This is determined by having a NON-empty queue of CDRP's
;		    hanging off the CDDB.
;
;		b) The oldest outstanding command was initiated since the
;		    previous invocation of DU$TMR and is therefore not very
;		    old.  This is determined by comparing the RSPID of the
;		    currently oldest command to the RSPID of the oldest request
;		    at the time of the previous invocation.  If they are not
;		    equal then we are in State #1.
;
;	2. State #2 is characterized by having NO outstanding MSCP commands in
;	    the controller.  This is determined by finding an empty CDRP queue
;	    in the CDDB.
;
;	3. State #3 is the state where MSCP commands are outstanding and the
;	    oldest one has been outstanding for at least one previous DU$TMR
;	    invocation.
;
;  If we determine that we are in state #1, we simply record the RSPID of the
;   currently oldest outstanding MSCP command in CDDB$L_OLDRSPID and we initial-
;   ize CDDB$L_OLDCMDSTS to all 1's.  We then calculate a new due time,
;   place it in CRB$L_DUETIME and return to our caller, which results
;   in scheduling ourselves for the next invocation of DU$TMR.
;
;  States #2 and #3 share some common code.  In both cases we will issue an
;   IMMEDIATE command to the controller but for diverse reasons.  In the case
;   of state #2 it will be an effective NOP command that is only issued to
;   insure against the controller timing out the host (i.e. us) due to lack of
;   activity on our part.  In the case of state #3, the IMMEDIATE command will
;   be a "GET COMMAND STATUS" for the oldest outstanding MSCP command.
;
;  The common code they share consists of code to appropriate the pre-allocated
;   MSCP buffer pointed at by CDRP$L_MSG_BUF and to pick up the pre-allocated
;   RSPID identified by CDRP$L_RSPID.  BOth these items are located in
;   the permanent CDRP which is appended to the CDDB of this intelligent
;   controller.  Also at this time a new due time is calculated prior to
;   doing the DRIVER_SEND_MSG so that we will be able to time out the
;   Immediate command.  Then the code for these two states diverges for
;   a while to prepare distinct MSCP packets, do the SEND_MSG_BUF,
;   and in the case of state #3, to do some specific processing upon
;   receipt of the END PACKET for the IMMEDIATE command.  This processing
;   consists of insuring that the command status returned in the END PACKET
;   indicates progress being made on the oldest outstanding command; and also
;   of saving this received command status in the CDDB$L_OLDCMDSTS so as to
;   have it available at the next invocation, if this oldest command is still
;   outstanding.  Following this the two code paths converge to recycle the
;   received END PACKET for use as the next IMMEDIATE MSCP buffer and to also
;   recycle the RSPID by bumping its sequence number.
;
; INPUTS:
;	R3 => CRB of the intelligent disk controller
;
; OUTPUTS:
;	Registers R0 through R5 are all possibly modified.
;

DU$TMR:
	SETIPL	#IPL$_SCS		; After wakeup lower IPL.
	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.

	ASSUME	CDDB$L_CDRPQFL   EQ   0
	CMPL	(R1),R1			; If =, then list of CDRP's is empty
	BEQL	20$			; EQL means empty list of CDRP's,
					;  which implies we are in State #2.
	MOVL	(R1),R0			; R0 => CDRP associated with "oldest"
					;  outstanding MSCP command.

	CMPL	CDRP$L_RSPID(R0),-	; Compare RSPID of oldest request to
		CDDB$L_OLDRSPID(R1)	;  that of request current at time of
					;  previous invocation of DU$TMR.
	BEQL	30$			; EQL implies State #3, i.e. current
					;  oldest has been around for awhile.

	MOVL	CDRP$L_RSPID(R0),-	; State #1, we have a NEW oldest request
		CDDB$L_OLDRSPID(R1)	;  so record its RSPID in CDDB field.
	MNEGL	#1,CDDB$L_OLDCMDSTS(R1)	; And initialize its associated status.
10$:
	MOVZWL	CDDB$W_CNTRLTMO(R1),-(SP); Pickup controller delta.
	ADDL3	(SP)+,-			 ; Calculate delta time for next
		G^EXE$GL_ABSTIM,-	;  periodic invocation of DU$TMR.
		CRB$L_DUETIME(R3)
	RSB				; And return to caller.

20$:					; If we are here, there are NO outstand-
					;  ing requests in the controller since
					;  CDRP list is empty.
	CLRL	R0			; R0 flagged to indicate State #2.
	CLRL	CDDB$L_OLDRSPID(R1)	; Set to impossible value to prevent
					;  inadvertent comparison error.

30$:					; Common State #2, State #3 code path.
					; If here, for sure we will be issuing
					;  an immediate command to the controller.
					;  If we are in State #2, it will be a
					;  "GET UNIT STATUS" (NOP) command but
					;  if we are in State #3, it will be
					;  a "GET COMMAND STATUS" command.  For
					;  either case we begin the common setup.


	MOVL	CDDB$L_PDT(R1),R4	; Setup for SEND_MSG_BUF, R4=>PDT.
	MOVAB	CDDB$A_PRMCDRP(R1), R5	; Get CDRP appended to CDDB.
	BBCS	#CDDB$V_IMPEND,-	; Branch if an immediate command is NOT
		CDDB$W_STATUS(R1),40$	;  pending. Also set bit to show that
					;  one WILL be pending momentarily.
	BRW	DU$RE_SYNCH		; Bit set implies that an immediate
					;  "GET STATUS" type command has not
					;  completed in the timeout interval.
					;  So we goto resynchronization logic.

40$:
	MOVQ	R0, -(SP)		; Save valuable registers.
	INIT_MSCP_MSG			; Initalize buffer for MSCP message.
	MOVQ	(SP)+, R0		; Restore valuable registers.

	BSBB	10$			; Establish due time so as to be able
					;  to timeout Immediate command.
	TSTL	R0			; Test for State #2 or State #3.
	BNEQ	50$			; NEQ implies State #3. Branch to handle it.

; State #2 specific code.
; Here we prepare the MSCP packet for the "GET UNIT STATUS" command for
;	unit #0, which is an effective NOP command.  This is done to
;	maintain minimum activity so that the controller will not time
;	out the host (i.e. us). NOTE that since the MSCP buffer has been
;	cleared above, there is no need to specify unit #0 in the command
;	buffer.
;

	MOVB	#MSCP$K_OP_GTUNT,-	; Move in "GET UNIT STATUS" opcode.
		MSCP$B_OPCODE(R2)

	SEND_MSCP_MSG DRIVER		; Here we call to send the MSCP packet
					;  to the intelligent disk controller.

					; Return is experienced here after
					;  receipt of the END PACKET correspond-
					;  ing to the MSCP NOP sent above.  We
					;  regain control due to a callback
					;  from our own INPUT DISPATCHER
					;  ROUTINE.  Passed to us at this call-
					;  back are R2 => END PACKET, R3 => CRB,
					;  R4 => PDT and R5 => CDRP.
					; All we want to do is recycle the
					;  END PACKET for use as our next MSCP
					;  packet and recycle the RSPID.
					;  To do this we branch to common code.
	BRB	70$

50$:

; State #3 specific code.
; Here we prepare the MSCP packet for a "GET COMMAND STATUS" command.

	MOVL	CDRP$L_UCB(R0),R0	; R0 => UCB for oldest outstanding request.

	MOVW	UCB$W_MSCPUNIT(R0),-	; Setup UNIT field.
		MSCP$W_UNIT(R2)
	MOVB	#MSCP$K_OP_GTCMD,-	; Setup OPCODE field.
		MSCP$B_OPCODE(R2)

	MOVL	CDDB$L_OLDRSPID(R1),-	; Setup OUTSTANDING COMMAND REFERENCE
		MSCP$L_OUT_REF(R2)	;  field.

	SEND_MSCP_MSG DRIVER		; Here we call to send the MSCP packet
					;  to the intelligent disk controller.

					; We experience return here upon receipt
					;  of the END PACKET for the above "GET
					;  COMMAND STATUS" command. We must make
					;  sure that progress has indeed been
					;  made on the outstanding command.  We
					;  therefore compare the outstanding
					;  command status returned in the END
					;  PACKET to the previous value in CDDB
					;  field CDDB$L_OLDCMDSTS.
					; Here R2=>END PACKET, R3=>CRB, R4=>PDT
					;  and R5=>CDRP.

	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.
	CMPL	MSCP$L_CMD_STS(R2),-	; Compare received outstanding command
		CDDB$L_OLDCMDSTS(R1)	;  status to previous value.
	BLSSU	60$			; LSSU implies progress made so branch.
	BNEQ	55$			; If not equal, progress went the 
					;  wrong direction; a sure sign of 
					;  an insane controller.
	CMPL	#-1, MSCP$L_CMD_STS(R2)	; If equal to last time, is this the
					;  multi-host busy somewhere else value?
	BEQL	60$			; Branch if it is busy somewhere else.
55$:	BRW	DU$RE_SYNCH		; Anything else, implies no progress
					;  has been made.  So we goto
					;  re-synchronize with the intelligent
					;  disk controller and re-issue all
					;  outstanding commands.

60$:
	MOVL	MSCP$L_CMD_STS(R2),-	; Remember this received outstanding
		CDDB$L_OLDCMDSTS(R1)	;  command status for next time.

70$:					; States #2 and #3 code paths merge here.
	RECYCH_MSG_BUF		; Recycle END PACKET.
	RECYCL_RSPID			; Likewise the RSPID.

	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.
	BICW	#CDDB$M_IMPEND,-	; Indicate that immediate command is
		CDDB$W_STATUS(R1)	;  no longer pending.
	BRW	DUTU$DODAP		; Continue by doing DAP processing.
	.PAGE
	.SBTTL	DU$IDR - Class Driver Input Dispatch Routine

;+
; DU$IDR - Class Driver Input Dispatching Routine.  This routine is to
;	the class driver what the Interrupt Service Routine is to a
;	conventional driver.  We are called here by the Port Driver
;	and we are passed the address of an END PACKET or an ATTENTION
;	MESSAGE buffer.  By testing a bit in the ENDCODE field of the
;	received buffer we determine which of the two has been received.
;	For ATTENTION MESSAGES we immediately branch to ATTN_MSG.
;
;	For END PACKETs we first determine if the END PACKET is still of
;	interest.  This is done by testing whether the COMMAND REFERENCE
;	NUMBER returned in the END PACKET, interpreted as a RSPID, is
;	still valid.  If not, we merely deallocate the END PACKET and
;	return to our caller in the Port Driver.
;
;	If the END PACKET is still of interest then before dispatching
;	to the code that originally issued the MSCP command for which we
;	have just received the END PACKET, we first remove the
;	CDRP associated with the command from the list of active CDRP's
;	defined by the listhead located at CDDB$L_CDRPQFL.
;
; INPUTS:
;	R1 =  Message Length
;	R2 => END PACKET or ATTENTION MESSAGE BUFFER
;	R3 => Connection Data Block
;-

DU$IDR::
	BITB	#MSCP$M_OP_END, -	; Is this an ATTENTION MESSAGE?
		MSCP$B_OPCODE(R2)
	BEQL	ATTN_MSG		; Branch if its an ATTENTION MESSAGE.


;
; Process command END MESSAGES
;

	; NOTE: The following is a duplication of the code in FIND_RSPID_RDTE.
	; The code is reproduced inline here to avoid two branches and make
	; this code path as fast as possible.

	MOVL	G^SCS$GL_RDT,R0		; R0 => base of the RDT.
	MOVZWL	MSCP$L_CMD_REF(R2),R5	; Pickup RDTE index from END PACKET.
	CMPL	R5,RDT$L_MAXRDIDX(R0)	; Bounds check on index.
	BGEQ	FINISHED_WITH_MESSAGE	; GEQ implies out of bounds.
	MOVAQ	(R0)[R5],R5		; R5 => RDTE of interest.

	CMPW	RD$W_SEQNUM(R5),-	; See if RSPID is still valid by com-
		MSCP$L_CMD_REF+2(R2)	;  paring the sequence number.
	BNEQ	FINISHED_WITH_MESSAGE	; NEQ implies invalid RSPID.
	MOVL	RD$L_CDRP(R5),R5	; R5 => CDRP.
	MOVL	CDRP$L_CDT(R5),R0	; R0 => CDT.
	MOVL	CDT$L_AUXSTRUC(R0),R0	; R0 => CDDB.
	CMPL	CDDB$L_OLDRSPID(R0),-	; See if oldest outstanding command has
		MSCP$L_CMD_REF(R2)	;  this Command Reference Number.
	BNEQ	20$			; If not, branch around.
	CLRL	CDDB$L_OLDRSPID(R0)	; Prevent inadvertent timeouts due to
					;  reuse of RSPID in error situations.
20$:	ASSUME	MSCP$K_LEN LT 32767
	MOVW	R1, CDRP$W_ENDMSGSIZ(R5); Save length of incomming packet.
	MOVL	R2, CDRP$L_MSG_BUF(R5)	; Save address of incomming packet.

	REMQUE	(R5),R5			; Remove R5=>CDRP from list.

	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Has request been canceled?
		30$			; If so, do cancel completion work.

23$:	BITW	#IRP$M_DIAGBUF,	-	; Was a diagnostic buffer supplied?
		CDRP$W_STS(R5)
	BNEQ	50$			; Branch if diagnostic buffer present.

25$:	MOVQ	CDRP$L_FR3(R5), R3	; Restore fork registers, R3 & R4.
	JMP	@CDRP$L_FPC(R5)		; Dispatch to issuer of MSCP command
					; who will return to our caller.

30$:	BSBW	DUTU$TEST_CANCEL_DONE	; If this request completes a cancel
					; operation, cleanup that operation.
	BRB	23$			; Branch back to normal flow.

50$:	BSBW	DUTU$DUMP_ENDMESSAGE	; If diagnostic buffer, record MSCP
					; end message sent in the buffer.
	BRB	25$			; Branch back to normal flow.



;
; Process ATTENTION MESSAGES
;

ATTN_MSG:
	PUSHR	#^M<R1,R2,R3,R4>	; Save vital registers.
	MOVL	CDT$L_AUXSTRUC(R3), R3	; Get CDDB address.
	PUSHAB	B^EXIT_ATTN_MSG		; Make DISPATCH look like a BSBx.
	DISPATCH -			; Dispatch to attention message 
		MSCP$B_OPCODE(R2), -	;  specific processing:
		type=B, prefix=MSCP$K_OP_, < -
		<AVATN, UNIT_AVAILABLE_ATTN>, -
		<DUPUN, DUPLICATE_UNIT_ATTN>, -
		<ACPTH, ACCESS_PATH_ATTN>, -
		>
INV_ATTN_MSG:				; Process invalid ATTENTION MESSAGE.
	TSTL	(SP)+			; Pop "return" address.
	MOVZWL	#EMB$C_INVATT, R0	; Invalid attention message type.
	JSB	G^ERL$LOG_DMSCP		; Log incorrect DISK MSCP message.
	POPR	#^M<R1,R2,R3,R4>	; Restore vital registers.
	DEALLOC_MSG_BUF_REG		; Deallocate ATTN MSG buffer.
	MOVL	CDT$L_AUXSTRUC(R3), R3	; Get CDDB again.
	MOVL	CDDB$L_CRB(R3), R3	; From that get the CRB address.
	BRW	DU$RE_SYNCH		; Re-synchronize with controller.

EXIT_ATTN_MSG:
	POPR	#^M<R1,R2,R3,R4>	; Restore vital registers.
FINISHED_WITH_MESSAGE:
	DEALLOC_MSG_BUF_REG		; Deallocate ATTN MSG buffer.
	RSB				; Return to SCS caller.
	.PAGE
	.SBTTL Attention Message Processing
	.SBTTL   - Process Unit Available Attention Message

;++
;
; Functional Description:
;
;	This routine processes unit available attention messages.  If the
;	available unit is already known in the I/O database, no action is 
;	taken.  If the available unit represents a second path to an already 
;	known unit, the I/O database is altered to show the alternate path 
;	availability.  If the available unit represents a totally new device, 
;	it is added to the I/O database.
;
; Inputs:
;
;	R1	attention message size
;	R2	attention message address
;	R3	CDDB address
;
; Outputs:
;
;	R0 - R5 destroyed
;	All other registers preserved
;--

UNIT_AVAILABLE_ATTN:

	BBS	#CDDB$V_POLLING, -	; Is a poll for units in progress?
		CDDB$W_STATUS(R3), 90$	; Branch if poll for units active.
	BSBW	DUTU$NEW_UNIT		; Process possible new unit.
90$:	RSB
	.PAGE
	.SBTTL   - Process Duplicate Unit Attention Message

;++
;
; Functional Description:
;
;	This routine processes duplicate unit attention messages.
;	Notification of the condition is sent to the operator's console and 
;	an entry is made in the error log.  If the unit described in the 
;	message cannot be found, an invalid MSCP message error log entry is 
;	generated.
;
; Inputs:
;
;	R1	attention message size
;	R2	attention message address
;	R3	CDDB address
;
; Outputs:
;
;	R0 - R5 destroyed
;	All other registers preserved
;--

	.ENABLE LSB

DUPLICATE_UNIT_ATTN:

	BSBW	DUTU$LOOKUP_UCB		; Locate UCB for this message.
	MOVL	R0, R3			; Setup UCB address.
	BEQL	90$			; If no UCB found, ignore message.
	BSBW	DUTU$SEND_DUPLICATE_UNIT; Send message to operator.
	MOVZWL	#EMB$C_DUPUN, R0	; Setup duplicate unit error log code.

LOG_ATTENTION_MESSAGE:
	JSB	G^ERL$LOGMESSAGE	; Error log attention message 
90$:	RSB				; and return to caller.

	.DISABLE LSB
	.PAGE
	.SBTTL   - Process Access Path Attention Message

;++
;
; Functional Description:
;
;	This routine processes access path attention messages.  If the access 
;	path represents a second path to an already known unit, the I/O 
;	database is altered to show the alternate path availability, and an 
;	entry is made in the error log indicating receipt of the message.
;	If the unit described in the message cannot be found, an invalid MSCP 
;	message error log entry is generated.
;
; Inputs:
;
;	R1	attention message size
;	R2	attention message address
;	R3	CDDB address
;
; Outputs:
;
;	R0 - R5 destroyed
;	All other registers preserved
;--

ACCESS_PATH_ATTN:

	BSBW	DUTU$SETUP_DUAL_PATH	; Process possible dual path unit.
	MOVL	R0, R3			; Get UCB address.
	BEQL	90$			; If no UCB found, ignore the message.
	RSB				; Return w/o logging message, but
					; leave message logging code in place
					; just in case its needed.
	MOVZBL	#EMB$C_ACPTH, R0	; Setup ERL$LOGMESSAGE code.
	BRB	LOG_ATTENTION_MESSAGE	; Join common log message path.
90$:	RSB				; If no UCB, exit.
	.PAGE
	.SBTTL	DU$DGDR	- Data Gram Dispatch Routine
;
; Inputs:
;
;	R1 =  length of datagram
;	R2 => datagram
;	R3 => CDT
;	R4 => PDT

DU$DGDR:

	MOVL	CDT$L_AUXSTRUC(R3),R0	; R0 => CDDB
	MOVL	R3,R5			; Save pointer to CDT.
	CMPB	#MSLG$K_DISK_TRN,-	; Look into error log message.
		MSLG$B_FORMAT(R2)	;  See if disk transfer error.
	BEQL	5$			; EQL means yes.
	CMPB	#MSLG$K_SDI,-		; See if SDI error.
		MSLG$B_FORMAT(R2)
	BEQL	5$			; EQL means yes.
	CMPB	#MSLG$K_SML_DSK, -	; See if disk transfer error.
		MSLG$B_FORMAT(R2)
	BNEQ	30$			; NEQ means unit # field maybe invalid.

5$:					; If here, then UNIT # field valid.
	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB address in R3.
		 -CDDB$L_UCBCHAIN>, -
		R0, R3

10$:	MOVL	UCB$L_CDDB_LINK(R3), R3	; Chain to next UCB.
	BEQL	30$			; No more UCBs.
	CMPW	UCB$W_MSCPUNIT(R3),-	; See if datagram (error log packet)
		MSCP$W_UNIT(R2)		;  for this unit.
	BNEQ	10$			; If not, branch abck to try next unit.
15$:
	MOVZWL	#EMB$C_DM,R0		; Put type of message into R0.
	JSB	G^ERL$LOGMESSAGE	; And call to log message.
20$:
	MOVL	R5,R3			; Restore R3 => CDT.
	SUBL	PDT$L_DGOVRHD(R4),R2	; R2 => SCS header of datagram.
	QUEUE_DG_BUF			; Requeue datagram buffer.
	RSB				; Return to port.

30$:	MOVL	MSCP$L_CMD_REF(R2),R3	; Pickup RSPID from END PACKET.
	BEQL	40$			; EQL means no RSPID.
	PUSHR	#^M<R1,R5>		; Save registers.
	MOVL	R3, R5			; Copy RSPID.
	FIND_RSPID_RDTE			; Lookup RDTE for RSPID.
	MOVL	R5, R3			; Copy RDTE address.
	POPR	#^M<R1,R5>		; Restore saved registers.
	BLBC	R0,40$			; Branch if lookup error.
	MOVL	RD$L_CDRP(R3),R3	; Get CDRP address in R3.
	MOVL	CDRP$L_UCB(R3),R3	; Get UCB address in R3 (if any).
	BNEQ	15$			; If we get a UCB, use it.

40$:	MOVL	CDT$L_AUXSTRUC(R5),R3	; R3 => CDDB.
	MOVZWL	#EMB$C_NOUNIT_DG,R0	; Indicate type of message.
	JSB	G^ERL$LOG_DMSCP		; Call to log message.
	BRB	20$			; Rejoin code.
	.PAGE
	.SBTTL	INVALID_STS

;+
; We come here if we get an invalid MSCP status.  We log the MSCP message
; and then RE-SYNCH the controller.
;
; Inputs:
;	R2 => MSCP packet
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;	CDRP$L_ENDMSGSIZ(R5) => length of MSCP packet with invalid status
;

INVALID_STS:

	MOVZWL	#EMB$C_INVSTS, R0	; Indicate type of record to log.
	MOVZWL	CDRP$W_ENDMSGSIZ(R5), R1; Pickup length of faulty packet.
	MOVL	UCB$L_CDDB(R3), R3	; Get CDDB address for logging error.
	JSB	G^ERL$LOG_DMSCP		; Log disk MSCP error.
	BSBW	DUTU$INSERT_RESTARTQ	; Queue CDRP for retry.
	MOVL	CDDB$L_CRB(R3),R3	; R3 => CRB for re-SYNCH.
	BRW	DU$RE_SYNCH		; Zap controller.



	.END
