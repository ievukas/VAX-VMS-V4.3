	.TITLE	MCRCOMD - PROCESS NEXT COMMAND
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 7-DEC-1977
;
; PROCESS NEXT COMMAND
;
; MODIFIED BY:
;	
;	V3.009	MAJ0016		Melanie Johnson	03-Mar-1983
;		Update to use structure level 6 of the command tables.
;
;	V3.008	MAJ0015		Melanie Johnson	24-Feb-1983
;		Remove reference to MCR$STOPIND, part of imbedded indirect.
;
;	V3.007	MAJ0014		Melanie Johnson	12-Jan-1983
;		Recogize indirect invocation (@) and treat it as a foreign
;		command, invoking ICM, the compatibility mode indirect.
;		Add command level support for the COMMAND callback.
;
;	V3.006	MAJ0013		Melanie Johnson	05-Jan-1983
;		When an invalid delimiter is found, check for the case of
;		no parameters to prevent ACCVIO. (In MCR$PARSE_DCL)
;
;	V3.005	MAJ0012		Melanie Johnson	10-Nov-1982
;		Add support for keyword parsing and for passbacks.
;
;	V3.004	MAJ0011		Melanie Johnson	03-Sep-1982
;		Use WRK_L_EXPANDPTR(FP) instead of R9 as the command expansion
;		buffer pointer.  Save address of tables vector from
;		PRC_L_TAB_VEC(R11) in WRK_L_TAB_VEC(FP) for later use in
;		MCRRPCLNT.
;
;	V3.003	MAJ0010		Melanie Johnson	08-Apr-1982
;		Allocate the WRK block before using it in MCR$RESTART.
;		Initialize WRK_L_RSLNXT(FP) - end of token pointer - to
;		the beginning of the token array to prevent ACCVIO.
;
;	V3.002	MAJ0009		Melanie Johnson	24-Mar-1982
;		Allow ':' to be a parameter delimiter to allow the label to
;		appear immediately after the device spec. for the MOUNT and
;		INITIALIZE commands.  This will provide RSX and V2.x compatibility.
;
;	V3.001	MAJ0008		Melanie Johnson	18-Mar-1982
;		Check for commands explicitly defined as foreign (to fix HELP).
;		Remove enforced use of a blank before the slash in option
;		commands being specified as if the options were qualifiers.
;		(This will fix SET /UIC which was broken by the removal of
;		insignificant blanks by MCR$GETOKEN/MCR$GTBTOKEN.)
;
;	V007	MAJ0007		Melanie Johnson	10-Feb-1982
;		Allow MCR-ized commands to contain mulitple command verb
;		qualifiers.
;
;	V006	MAJ0006		Melanie Johnson	17-Nov-81
;		Convert to using the new command tables (new MDL structures).
;
;	V005	MAJ0005		Melanie Johnson	20-Aug-81
;		In MCR$FLUSH, check to see if we're in a .GOTO section
;		and set a flag if we're also in a comment so that
;		full-line comments won't be continued and hence, won't
;		wipe out the label which follows.
;
;	V004	MAJ0004		Melanie Johnson 07-Aug-81
;		Move initialization of <FILSPC> and <FILERR> out of
;		here so they won't be re-initialized on the next
;		command after a .TESTFILE.
;
;	V003	TMH0003		Tim Halvorsen	01-Jun-1981
;		Rewrite terminal hangup to take advantage of normal
;		external image execution path, so that it sets up
;		the scratch stack and buffer descriptor.
;
;	V002	TMH0002		Tim Halvorsen	16-Dec-1980
;		Move initialiation of <FILSPC> and <FILERR> from CLI
;		initialization here, where WRK is allocated.
;
;	V001	TMH0001		Tim Halvorsen	24-Nov-1980
;		Reset NOSTAT bit on and clear all other command parsing
;		flags before parsing each line; so that indirect directives
;		do not reset <EXSTAT> unless an error occurs. SPR #33721
;		Clear NOSTAT bit on foreign commands.
;---
;
; MACRO LIBRARY CALLS
;
 
	$CLIMSGDEF			;DEFINE CLI MESSAGE CODES
	$$CLITABDEF			;DEFINE COMMAND TABLE STRUCTURES
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFPROBLK			;DEFINE PROMPT DESCRIPTOR BLOCK OFFSETS
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	DEFSYMTBL			;DEFINE SYMBOL ENTRY OFFSETS
	DEFOPIMCR			; Result parse work definitions
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$PBKDEF				;DEFINE PASSBACK STRUCTURE
	$IODEF				;I/O FUNCTION CODES


	.PSECT	MCR$ZDATA,BYTE,RD,NOWRT

;
; LOCAL DEFINITIONS
;
	LOC_V_FULCOM	=	8	;FLAG TO INDICATE COMMENT FOUND IN A .GOTO SECTION
; ********************************************************************
; NOTE:
;	THE FOLLOWING DEFINITION SHOULD BE INCORPORATED INTO AN SDL!
;
; ********************************************************************
	RSX$C_PASSBACK	=	1	;TYPE OF MESSAGE BEING MAILED TO AME


ROUTINES_LEN = 0

	.MACRO	INTIMAGE NAME
$NAM1$ = ^A/%EXTRACT(0,4,NAME)/!^X80
$NAM2$ = ^A/%EXTRACT(4,4,NAME)/
	.LONG	$NAM1$
	.LONG	$NAM2$
ROUTINES_LEN = ROUTINES_LEN + 8
	.ENDM

ROUTINES:
	MCRINTIMG			; GENERATE TABLE OF INTERNAL ROUTINE NAMES

;
; GLOBAL DATA
;
 
MCR$T_PROMPT::				;PRIMARY PROMPT
	.ASCIC	\> \			;

MCR$T_INDNAME::
	.ASCII	/ICM/


	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT

	.SBTTL	PROCESS NEXT COMMAND
;+
; MCR$RESTART - PROCESS NEXT COMMAND
;
; THIS ROUTINE IS THE CENTRAL COMMAND PARSE AND DISPATCH ROUTINE FOR THE
; STARLET MCRS COMMAND LANGUAGE INTERPRETER. IT INITIALIZES FOR THE NEXT
; COMMAND, READS AND PARSES THE COMMAND FOR SYNTACTIC CORRECTNESS, AND THEN
; EXECUTES THE APPROPRIATE IMAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	COMMAND IS READ, PARSED, AND AN IMAGE IS ACTIVATED.
;-
 
	.ENABL	LSB			;

MCR$RESTART::				;RESTART ENTRY POINT
	MOVAB	WRK_K_LENGTH-16(FP),SP	;ALLOCATE COMMAND IMPURE AREA
					; (2ND ALLOCATION BELOW IS SAFE)
	MOVAB	W^MCR$HYPHEN-1,WRK_L_CHARPTR(FP) ;SET TO FORCE INPUT ON NEXT GET
 
;
; PARSE COMMAND AND BUILD RESULT TABLE
;
 
MCR$CMDSTART::				;COMMAND PROCESSING ENTRY POINT
	MOVAB	W^MCR$CONDHAND,(FP)	;ESTABLISH CONDITION HANDLER
	MOVAB	WRK_K_LENGTH-16(FP),SP	;ALLOCATE COMMAND IMPURE AREA
	CLRB	WRK_B_VERBTYP(FP)	;INIT VERB CLASS TO NONE!
	CLRBIT	MCR_V_FORCMD,PRC_W_CLIFLAG(R11) ;REOMVE FOREIGN COMMAND FLAG
	MOVAB	MCR$T_PROMPT,WRK_L_PROMPT(FP) ;SET ADDRESS OF DEFAULT PROMPT
	MOVAB	WRK_G_RESULT(FP),WRK_L_RSLNXT(FP) ;INIT. ADDRESS OF LAST TOKEN
	CLRB	WRK_B_VALLEV(FP)	;RESET VALUE LEVEL
	CLRL	WRK_L_PARMCNT(FP)	;ZERO PARAMETER COUNT
	CLRL	WRK_L_MAXPARM(FP)	;RESET MAXIMUM PARAMETER LIMIT
	CLRL	WRK_L_MINPARM(FP)	;RESET MINIMUM PARAMETER LIMIT
	CLRL	WRK_L_QUABLK(FP)	;ZERO ADDRESS OF QUALIFIER DESCRIPTORS
	CLRL	WRK_L_IMAGE(FP)		;ZERO ADDRESS OF IMAGE NAME
	CLRL	WRK_L_PAROUT(FP)	;ZERO ADDRESS OF OUTPUTS LIST
	CLRL	WRK_L_PROPTR(FP)	;ZERO ADDDRESS OF PARAMETER DESCRIPTORS
	CLRW	WRK_W_FLAGS(FP)		;RESET COMMAND FLAGS
	CLRW	WRK_W_FLAGS2(FP)	; (2ND COMMAND FLAGS WORD)
	CLRW	WRK_W_LOCFLG(FP)	;RESET LOCAL USAGE FLAGS
;*****Disabling imbedded indirect*************************************
;	MOVB	#CMD_M_NOSTAT,WRK_B_CMDFLG(FP) ;DEFAULT FOR ".XXX" IS NOSTAT
;*********************************************************************
	CLRBIT	PRC_V_RUNDEF,PRC_B_FLAGS2(R11) ;CLEAR IMAGE RUN DEFAULT FLAG
	BICW	#PRC_M_DISABL!-		;CLEAR COMMAND INTERPRETER CONTROL Y/C
		PRC_M_IND,PRC_W_FLAGS(R11) ;CLEAR INDIRECT FILE IN PROGRESS
;
; CHECK FOR SPECIAL COMMAND PROCESSING CASES
;	PENDING CONTROL/Y
;	CHAINED COMMAND FROM CALLBACK
;	CHAINED IMAGE FROM CALLBACK
;	PENDING HANGUP
;
; IF CONTROL/Y PENDING, EXECUTE "ON CONTROL_Y" STATEMENT
;
;********ON CONTROL_Y statement not fully implemented*************
;
	BBCC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),6$ ;BR IF NO CONTROL Y/C REQUESTED
	MOVL	PRC_L_ONCTLY(R11),R1	;GET ADDRESS OF ACTION COMMAND
	BEQL	5$			;BR IF NO ACTION OUTSTANDING
	MOVZBL	(R1)+,R0		;GET THE ADDRESS AND COUNT
	MOVC	R0,(R1),WRK_G_INPBUF(FP) ;MOVE COMMAND INTO BUFFER
	BRB	8$			;
5$:	BISW	#PRC_M_YLEVEL,PRC_W_FLAGS(R11) ;SET CONTROL Y/C LEVEL
	BRB	10$			;

;
; IF CHAINED COMMAND OR CHAINED IMAGE, COPY COMMAND INTO COMMAND BUFFER
; AND DEALLOCATE STORAGE USED BY THE CALLBACK TO HOLD THE COMMAND.
;
6$:	MOVAQ	PRC_Q_COMMAND(R11),R6	;GET DESCRIPTOR OF THE COMMAND LINE
	BBSC	#PRC_V_CMD,PRC_B_FLAGS2(R11),7$ ;BRANCH IF USER COMMAND SETUP
	BBCC	#PRC_V_CHAIN,PRC_B_FLAGS2(R11),10$ ;BRANCH IF NOT USER CHAIN
	MOVAQ	PRC_Q_IMAGENAME(R11),R6	;GET DESCRIPTOR OF IMAGE TO INVOKE
	SETBIT	PRC_V_RUNDEF,PRC_B_FLAGS2(R11)	;SET RUN DEFAULT
7$:	MOVC	(R6),@4(R6),WRK_G_INPBUF(FP) ;SET STRING IN BUFFER
	BSBW	MCR$ALLDEACMD		;GO DEALLOCATE THE SPACE
;
; IF CONTROL IS TO BE TRANSFERRED TO AN ON-CONTROL_Y CONDITION OR A CHAINED
; COMMAND, THEN TERMINATE ANY FORWARD GOTO IN PROGRESS.
;
8$:	MOVAB	WRK_G_INPBUF-1(FP),WRK_L_CHARPTR(FP) ;SET POINTER BEFORE RECORD
;*****Disabling imbedded indirect*************************************
;	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),10$ ;BR IF NOT IN A GOTO
;	BSBW	MCR$DEALGOTO		;DEALLOCATE THE CONTROL BLOCK
;*********************************************************************
;
; IF A HANGUP IS PENDING, THEN ABORT THE PROCESS
;
10$:	BBC	#PRC_V_HANGUP,PRC_W_FLAGS(R11),12$ ;IF SET, HANGUP PENDING
	BRW	MCR$ABORT		;LOG PROCESS OUT

12$:	MOVAB	WRK_AB_BUFFER+2(FP),WRK_L_EXPANDPTR(FP) ;SET ADDRESS OF COMMAND BUFFER
	MOVAB	WRK_AG_RESULT(FP),R10	;SET ADDRESS OF RESULT PARSE TABLE
	BSBW	MCR$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	BEQL	49$			;IF EQL NULL LINE
20$:	CMPB	#^A/$/,R0		;DOLLAR SIGN?
	BNEQ	30$			;BR IF NO-PROCESS THE COMMAND
	INCL	WRK_L_CHARPTR(FP)	;SKIP THE DOLLAR SIGN
;*****Disabling imbedded indirect*************************************
;	PUSHL	PRC_L_INDEPTH(R11)	;SAVE CURRENT INDIRECT LEVEL
;*********************************************************************
	BSBW	MCR$SETNBLK		;POINT AT NEXT NON-BLANK CHARACTER
	BEQL	49$			;IF NULL LINE, THEN RESTART
;*****Disabling imbedded indirect*************************************
;	CMPL	PRC_L_INDEPTH(R11),(SP)+ ;INDIRECT LEVEL CHANGE?
;	BNEQ	20$			;IF YES-LOOK FOR LEADING DOLLAR SIGN
;*********************************************************************
30$:	BSBW	MCR$MARK		;SET ERROR PRINT POINTER
	CMPB	R0,#^A/@/		;IS THIS AN INDIRECT COMMAND FILE
	BEQL	50$			;BR IF YES
	CMPB	R0,#^A/./		;IS THIS A NOW-ILLEGAL INDIRECT COMMAND?
	BEQL	44$			;BR IF YES
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),40$ ;BR IF AT CONTROL Y LEVEL
;*****Disabling imbedded indirect*************************************
;	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),60$ ;BR IF IN A GOTO
;*********************************************************************
	CMPB	R0,#^A\/\		;LOGICAL EOF?
	BEQL	45$			;BR IF YES
40$:	BRW	COMMAND			;PROCESS COMMAND

44$:	STATUS	IVVERB			;INDIRECT COMMANDS ARE NO LONGER IMBEDDED IN MCR
	BRB	EXIT1			;ERROR EXIT

45$:	FLUSH				;REST OF COMMAND IS IGNORED
	BSBW	MCR$EXIT		;If BATCH, THEN EXIT; ELSE, NOP
49$:	BRW	MCR$RESTART		;READ IN NEXT COMMAND

;*****Disabling imbedded indirect*************************************
;	SETBIT	WRK_V_TABS,WRK_W_FLAGS(FP) ; Suppress forward conversion of tabs
;	BSBW	MCR$MOVTOKN		; Get the token for the indirect command
;	CLRBIT	WRK_V_TABS,WRK_W_FLAGS(FP) ; Allow forward conversion of tabs
;	TSTL	R1			; Test token length
;	BEQL	65$			;BR IF NULL INDIRECT COMMAND
;	CMPB	#^A/:/,R0		;LABEL TERMINATOR?
;	BEQL	70$			;BR IF FOUND A LABEL
;	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),67$ ;BR IF NOT IN A GOTO
;	BSBW	MCR$INDCMDSCAN		; Process indirect command
;	BRB	EXIT1
;*********************************************************************

;
; Hook up ICM as the indirect command processing facility instead
;
50$:	BSBW	MCR$MOVCHAR		;COPY THE WHOLE LINE INTO THE COMMAND BUFFER
	BNEQ	50$			;IF NEQ NOT END OF LINE
	MOVZBL	#3,R1			;LENGTH OF STRING "ICM"
	MOVAB	MCR$T_INDNAME,R2	;ADDRESS OF "ICM"
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3	;MARK AS EXTERNAL IMAGE
	SETBIT	MCR_V_FORCMD,PRC_W_CLIFLAG(R11) ;FLAG THAT "ICM" IS A FOREIGN COMMAND
	BRW	EXECUTE			;GO DIRECTLY TO ACTIVATION


60$:	BSBW	MCR$FLUSH		;FLUSH THE COMMAND
	BRW	MCR$RESTART		;START WITH A NEW COMMAND
;*****Disabling imbedded indirect*************************************
;65$:	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),60$ ;BR IF IN A FORWARD GOTO
;	CMPB	R0,#^A/;/		;"DOTTED" COMMENT
;	BEQL	60$			;IF YES - JUST FLUSH IT
;	BRW	NOCOMD			;
;67$:	BSBW	MCR$INDCMD		;PROCESS MCR INDIRECT COMMAND
;*********************************************************************
EXIT1:	BRW	ERROR_EXIT		;
 
;*****Disabling imbedded indirect*************************************
;
; LABEL ENCOUNTERED
;
; 
;70$:	BSBW	MCR$MOVNCHR		;MOVE COLON TO THE COMMAND BUFFER
;	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),START1 ;IF SET, CONTROL Y/C LEVEL
;	MOVL	PRC_L_INDINPRAB(R11),R7	;GET CURRENT INDIRECT INPUT RAB
;	BBC	#DEV$V_RND,RAB$L_CTX(R7),START1 ;IF CLR, NOT RANDOM DEVICE
;	MOVQ	R1,R7			;PUT LABEL DESCRIPTOR IN SAFE REGISTERS
;	TSTB	R0			;CHECK IF NEXT CHARACTER IS EOL
;	BNEQ	80$			;BR IF NO - MAKE NO LABEL TABLE ENTRY
;	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),80$ ;BR IF IN GOTO
;	MOVAB	PRC_Q_LABEL(R11),R5	;GET ADDRESS OF LABEL TABLE LISTHEAD
;	MOVQ	R7,R3			;SET LABEL NAME PARAMETERS
;	MOVL	PRC_L_INDINPRAB(R11),R2	;GET ADDRESS OF INDIRECT RAB
;	MOVAB	RAB$W_RFA(R2),R2	;SET ADDRESS OF RECORD FILE ADDRESS
;	MOVZBL	#6,R1			;SET LENGTH OF RECORD FILE ADDRESS
;	DISABLE				;DISABLE CONTROL Y/C AST'S
;	BSBW	MCR$ALLOCSYM		;ALLOCATE AND INSERT LABEL IN TABLE
;	BLBC	R0,EXIT1		;IF LBC ALLOCATION FAILURE
;80$:	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),START1 ;IF CLR, NO GOTO
;	MOVL	PRC_L_SYMBOL(R11),R3	;GET ADDRESS OF GOTO LABEL NAME
;	MOVB	(R3)+,R0		; Get label level
;	CMPB	PRC_B_FWDSCAN(R11), -	; Is forward scan for a .GOTO
;		#PRC_K_GOTO
;	BNEQ	90$			; No if NEQ, level is not significant
;	CMPB	R0,PRC_B_NESTLEVEL(R11)	; Was label defined at current level?
;	BNEQ	START1			; No if NEQ
;90$:
;	CMPB	(R3)+,R7		;LABEL LENGTHS MATCH?
;	BNEQ	START1			;IF NEQ NO
;	CMPC	R7,(R8),(R3)		;LABELS HAVE SAME NAME?
;	BNEQ	START1			;IF NEQ NO
;	BICW	#PRC_M_GOTO!PRC_M_GOEOF,- ;CLEAR GOTO IN PROGRESS AND EOF
;		PRC_W_FLAGS(R11)	;ENCOUNTERED DURING SEARCH FLAGS
;	MOVL	PRC_L_INDINPRAB(R11),R2	;GET THE INDIRECT INPUT RAB
;	MOVB	#RAB$C_RFA,RAB$B_RAC(R2);SET ACCESS TO "RECORD FILE ADDRESS"
;	$FIND	RAB=(R2)		;POSITION TO CURRENT RECORD
;	MOVB	#RAB$C_SEQ,RAB$B_RAC(R2);RESET ACCESS TO SEQUENTIAL
;	BSBW	MCR$DEALGOTO		;DEALLOCATE THE GOTO LABEL
;	BRW	MCR$RESTART		;READ THE NEXT COMMAND LINE
;*********************************************************************
START1:	BRW	MCR$CMDSTART		;START THE COMMAND OVER
	.DSABL	LSB
 
;
; FOREIGN COMMAND VERB
;
 
FORCMD:	PUSHR	#^M<R1,R2,R8>		;SAVE FILENAME DESCRIPTOR
	BSBW	PROCFORN		;PROCESS FOREIGN COMMAND
	POPR	#^M<R1,R2,R8>		;RESTORE FILENAME DESCRIPTOR PARAMETERS
	MOVB	#CLI$K_VERB_FORE,WRK_B_VERBTYP(FP) ;SET COMMADN GENERIC TYPE
	CLRB	WRK_B_CMDFLG(FP)	;CLEAR COMMAND FLAGS (CLEAR NOSTAT)
	SETBIT	MCR_V_FORCMD,PRC_W_CLIFLAG(R11) ;FLAG DOING FOREIGN COMMAND
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3	;EXTERNAL IMAGE
	TSTL	R8			;IS THERE A COMMAND BLOCK (VERB FOUND)?
	BEQL	5$			;IF EQL, NO
	BBS	#CMD_V_FOREIGN,CMD_W_FLAGS(R8),BUILD_IMAGE ;IF EXPLICIT FOREIGN CMD, BUILD IMAGE
5$:	BRW	EXECUTE			;IMPLICIT FOREIGN COMMAND

;
; NO COMMAND VERB
;
 
NOCOMD:	CMPB	R0,#^A/;/		;COMMENT COMMAND
	BNEQ	10$			;IF NO ITS AN ERROR
	BRW	COMNT			;LIST THE COMMENT
10$:	STATUS	NOCOMD			;SET NO COMMAND STATUS
COMDERR:BRW	ERROR_EXIT
 
 
;
; STANDARD COMMAND VERB
;
 
COMMAND:BSBW	MCR$MARK		;MARK CURRENT POSITION FOR ERROR REPORTING
	BSBW	MCR$GETOKEN		;GET COMMAND VERB TOKEN
	BEQL	NOCOMD			;IF EQL NONE
	MOVL	PRC_L_TAB_VEC(R11),R8	;GET ADDRESS OF COMMAND TABLE VECTOR
	BSBW	MCR$SEARCH_VERB		;SEARCH VERB TABLE
	STATUS	IVVERB,R3		;CONSTRUCT "FOREIGN COMMAND" STATUS
	CMPL	R0,R3			;FOREIGN COMMAND?
	BEQL	FORCMD			;BRANCH IF FOREIGN COMMAND
	BLBC	R0,COMDERR		;REPORT ANY OTHER ERRORS FROM SEARCH
	BBS	#CMD_V_FOREIGN,CMD_W_FLAGS(R8),FORCMD ;SPECIFIED AS A FOREIGN COMMAND?
	BBC	#CMD_V_IMMED,CMD_W_FLAGS(R8),10$ ;BR IF NORMAL
	MOVL	WRK_L_IMAGE(FP),R2	;GET ADDR OF ASCIC ROUTINE NAME
	MOVZBL	(R2)+,R1		;GET COUNT IN R1, ADDRESS IN R2
	BSBW	MCR$LOCATE_INTERNAL	;FIND INTERNAL ROUTINE INDEX
	BLBC	R0,ERREXT		;BRANCH IF ERROR
	BRW	IMMED
 
;
; Check for MCR-style parsing vs. DCL-style parsing
;
 
10$:	BBS	#CMD_V_MCRPARSE,CMD_W_FLAGS(R8),15$ ;BR IF MCR-TYPE COMMAND
	BSBW	MCR$PARSE_DCL		;PARSE A DCL-TYPE COMMAND
	BRB	20$
15$:	BSBW	MCR$PARSE_MCR		;PARSE A MCR-TYPE COMMAND
20$:	BLBS	R0,BUILD_IMAGE		;BR IF NO ERROR
 
ERREXT:	BRW	ERROR_EXIT		;

;
; COMMENT COMMAND - PRINT THE LINE IF IT HAS NOT BEEN PRINTED
;
 
COMNT:	BBS	#PRC_V_VERIFY,PRC_W_FLAGS(R11),175$ ;BR IF ALREADY VERIFIED
	MOVL	WRK_L_CHARPTR(FP),R2	;GET START OF INPUT LINE
	LOCC	#0,#INPBUFSIZ,(R2)+	;FIND THE END OF LINE
	SUBL	R2,R1			;GET COUNT OF BYTES TO THE END
	BSBW	MCR$MSGOUT		;PRINT THE COMMENT
175$:	BRW	RSTRT			;
 
;
; BUILD IMAGE NAME DESCRIPTOR
;
 

BUILD_IMAGE:
	MOVL	WRK_L_IMAGE(FP),R2	;GET IMAGE NAME INDEX NUMBER
	MOVZBL	(R2)+,R1		;GET COUNT TO R1, ADDRESS TO R2
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3	;ASSUME EXTERNAL IMAGE
	BBC	#WRK_V_CLIRTN,WRK_W_FLAGS2(FP),EXECUTE ;BRANCH IF EXTERNAL ROUTINE
	BSBW	MCR$LOCATE_INTERNAL	;LOCATE IMAGE NAME STRING
	BLBC	R0,ERREXT		;BRANCH IF ERROR
 
 
;
; EXECUTE COMMAND
;
 
EXECUTE:				;EXECUTE INTERNAL COMMAND
	PUSHR	#^M<R1,R2,R3>		;SAVE IMAGE NAME PARAMETERS
	MOVZBL	#PTR_K_ENDLINE,R5	;SET ITEM TYPE TO END OF LINE
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#1,R7			;SET LENGTH OF ITEM
	MOVL	WRK_L_EXPANDPTR(FP),R8	;SET STARTING ADDRESS OF ITEM
	BSBW	MCR$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	BITW	#<PRC_M_VERIFY!PRC_M_YLEVEL>,-	;IF COMMAND WAS VERIFIED,
		PRC_W_FLAGS(R11)		;OR IF AT CONTROL Y LEVEL
	BNEQ	5$				;THEN DON'T PRINT AGAIN
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;IF INPUT IS THE SAME AS
	BEQL	5$			;INDIRECT INPUT, THEN DON'T RE-PRINT
	MOVAB	WRK_AB_BUFFER+2(FP),R2	;GET START OF COMMAND BUFFER
	MOVW	#^A/> /,-(R2)		;SET PROPER PREFIX
	SUBL3	R2,WRK_L_EXPANDPTR(FP),R1 ;FIND LENGTH OF COMMAND
	BSBW	MCR$MSGOUT		;PRINT THE COMMAND
5$:	POPR	#^M<R1,R2,R3>		;RESTORE IMAGE NAME PARAMETERS
	MOVL	R10,WRK_L_RSLNXT(FP)	;SAVE ADDRESS OF NEXT PARSE TABLE ENTRY
	BBS	#WRK_V_CLIRTN,WRK_W_FLAGS2(FP),7$ ;BRANCH IF INTERNAL COMMAND
	BRW	EXECEXT			;FOR EXTERNAL COMMANDS, NO NEED TO SORT TOKENS

;
; SORT TOKEN DESCRIPTORS SO THAT THEY APPEAR IN THE ORDER: COMDQUAL, PARAMETER,
; PARMQUAL FOR INTERNAL CLI ROUTINES TO SIMPLIFY THE PROCESSING WITH THE
; MCR$GETDVAL ROUTINE.
;

 7$:	PUSHL	R3			;SAVE INTERNAL COMMAND INDEX
	MOVAB	WRK_AG_RESULT(FP),R7	;GET ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVL	R7,R8			;COPY ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVAB	-RSLBUFSIZ(SP),SP	;ALLOCATE TEMPORARY DESCRIPTOR ARRAY
	MOVL	SP,R9			;SAVE ADDRESS OF TEMPORARY DESCRIPTOR ARRAY
10$:	CMPL	R7,WRK_L_RSLNXT(FP)	;END OF RESULT DESCRIPTOR ARRAY?
	BEQL	30$			;IF EQL YES
	MOVC3	#PTR_C_LENGTH,(R7),(R9)	;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	ADDL	#PTR_C_LENGTH,R7	;POINT PAST IT IN ORIGINAL ARRAY
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;COMMAND QUALIFIER?
		(R9),#PTR_K_COMDQUAL	;
	BNEQ	10$			;IF NEQ NO
	MOVC5	#0,(SP),#0,#PTR_C_LENGTH,- ;CLEAR COMMAND QUALIFIER DESCRIPTOR
		-PTR_C_LENGTH(R7)	  ;  IN ORIGINAL ARRAY
	ADDL	#PTR_C_LENGTH,R9	;POINT TO NEXT ITEM IN TEMPORARY ARRAY
20$:	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;QUALIFIER VALUE?
		(R7),#PTR_K_QUALVALU	;
	BNEQ	10$			;IF NEQ NO
	MOVC3	#PTR_C_LENGTH,(R7),(R9)	;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	ADDL	#PTR_C_LENGTH,R9	;POINT PAST IT IN TEMPORARY ARRAY
	MOVC5	#0,(SP),#0,#PTR_C_LENGTH,(R7) ;CLEAR QUALIFIER VALUE DESCRIPTOR
	ADDL	#PTR_C_LENGTH,R7	;POINT TO NEXT ITEM IN ORIGINAL ARRAY
	BRB	20$			;

30$:	MOVL	R7,R10			;COPY ADDRESS OF LAST DESCRIPTOR + 8
40$:	CMPL	R7,R8			;ANY MORE DESCRIPTORS TO EXAMINE?
	BEQL	50$			;IF EQL NO
	SUBL	#PTR_C_LENGTH,R7	;REMOVE DESCRIPTOR
	MOVL	R7,R6			;GET DESCRIPTOR ADDRESS
	TSTL	(R6)			;WAS THERE A DESCRIPTOR THERE?
	BEQL	40$			;IF EQL NONE
	SUBL	#PTR_C_LENGTH,R10	;POINT BEFORE IT IN ORIGINAL ARRAY
	MOVC3	#PTR_C_LENGTH,(R6),(R10) ;MOVE DESCRIPTOR TO NEW POSITION
	BRB	40$			;

50$:	CMPL	R9,SP			;ANY MORE TEMPORARY DESCRIPTORS?
	BEQL	60$			;IF EQL NO
	SUBL	#PTR_C_LENGTH,R10	;POINT BEFORE IT IN ORIGINAL ARRAY
	SUBL	#PTR_C_LENGTH,R9	;POINT BEFORE IT IN TEMPORARY ARRAY
	MOVC3	#PTR_C_LENGTH,(R9),(R10) ;MOVE DESCRIPTOR TO NEW POSITION
	BRB	50$			;

60$:	MOVAB	RSLBUFSIZ(SP),SP	;DEALLOCATE TEMPORARY DESCRIPTOR ARRAY
	POPL	R3			;RESTORE INTERNAL COMMAND INDEX

;
; SET UP SCRATCH STACK AND SCRATCH BUFFER FOR INTERNAL COMMANDS
;
	MOVL	SP,R9			;SET ADDRESS OF SCRATCH STACK
	MOVAB	-MSGBUFSIZ*2(SP),SP	;ALLOCATE SCRATCH BUFFER
	PUSHAB	(SP)			;BUILD SCRATCH BUFFER DESCRIPTOR
	MOVZWL	#MSGBUFSIZ*2,-(SP)	;SET SIZE OF BUFFER
	MOVL	SP,R8			;SET ADDRESS OF SCRATCH BUFFER DESCRIPTOR
;
; EXECUTE EXTERNAL COMMAND
;
 
EXECEXT:				;EXECUTE EXTERNAL COMMAND
	MOVAB	WRK_AG_RESULT(FP),R10	;SET ADDRESS OF RESULT PARSE DESCRIPTOR TABLE
	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(FP) ;SET COMMAND EXECUTION IN PROGRESS

;
; INTERNAL COMMAND PARAMETERS:
;
;	R1 = LENGTH OF IMAGE FILENAME (IF ANY).
;	R2 = ADDRESS OF IMAGE FILENAME (IF ANY).
;	R3 = INTERNAL ROUTINE INDEX 
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
;	WRK_L_EXPANDPTR(FP) = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;
; IMMEDIATE COMMAND PARAMETERS:
;
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
;	WRK_L_EXPANDPTR(FP) = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;

IMMED:					;IMMEDIATE COMMAND EXECUTION
	BSBW	MCR$INTIMAGE		;EXECUTE INTERNAL IMAGE
ERROR_EXIT:				;ERROR EXIT
	BLBS	R0,10$			;IF LBS SUCCESSFUL COMPLETION
	ERRMSG				;OUTPUT SYSTEM ERROR MESSAGE
10$:	TSTL	PRC_L_OWNRPID(R11)	;IS THIS A SUBPROCESS?
	BEQL	20$			;IF EQL, NO
	PUSHL	R0			;SAVE EXIT STATUS
	BSBW	MCR$MAILPBK		;MAIL EXIT STATUS AND PASSBACK INFO. TO AME
	POPL	R0			;RESTORE EXIT STATUS
20$:	SET_STATUS			;SET COMPLETION STATUS
RSTRT:	BSBW	MCR$FLUSH		;FLUSH COMMAND BUFFER
	BRW	MCR$RESTART		;

;
; DEFINE INTERNAL ROUTINES
;

	.MACRO	INTIMAGE IMAGE
	.WORD	MCR$'IMAGE'-INTIMAGEBASE
IMG_K_'IMAGE = $INTIMAGE$		;DEFINE INTERNAL IMAGE SYMBOL
$INTIMAGE$=$INTIMAGE$+1
	.ENDM	INTIMAGE

MCR$INTIMAGE::				;ADDRESS OF INTERNAL IMAGE CASE TABLE
	CASEB	R3,#0,#<INTIMAGETOP-INTIMAGEBASE>/2-1
INTIMAGEBASE:				;BASE ADDRESS OF CASE TABLE
	.LIST	MEB
	MCRINTIMG			;GENERATE INTERNAL IMAGE CASE TABLE
	.NLIST	MEB
INTIMAGETOP:				;TOP ADDRESS OF CASE TABLE
	MOVZWL	#SS$_ILLSER,R0		;SET SERVICE ERROR
	RSB				;


	.SBTTL	CALL LOGINOUT TO ABORT THE PROCESS
;----
;	MCR$ABORT
;
;	Control is transferred here to abort the process by calling
;	the LOGINOUT image.  Care is taken to setup the result
;	parse descriptors so that LOGINOUT can use result parsing
;	as if LOGOUT was given as a command line.
;
;   Inputs:
;
;	None
;----

MCR$ABORT::
	MOVAB	WRK_AG_RESULT(FP),R10	; SETUP POINTER TO RESULT ARRAY
	MOVAB	WRK_AB_BUFFER(FP),R2	; GET ADDRESS OF EXPANSION BUFFER
	MOVL	R2,WRK_L_EXPANDPTR(FP)	; RESET EXPANSION BUFFER POINTER
	MOVL	#^A'LOGO',(R2)		; STORE VERB INTO BUFFER
	MOVL	#4,R1			; SET LENGTH OF VERB
	MOVZBL	#IMG_K_LOGOUT,WRK_L_IMAGE(FP) ; SET ROUTINE IN CASE NOT FOUND
	MOVL	PRC_L_TAB_VEC(R11),R8	; GET ADDRESS OF COMMAND TABLE VECTOR
	BSBW	MCR$SEARCH_VERB		; LOCATE COMMAND DEFINITION FOR
					; LOGOUT CLI INTERFACE (IGNORE ERRORS)
	BRW	BUILD_IMAGE		; PROCESS LOGOUT COMMAND

	.SBTTL	CHECK FOR CONTROL Y/C AST PENDING
;+
; MCR$CHECK_AST - CHECK FOR CONTROL Y/C AST PENDING
;
; THIS ROUTINE IS CALLED TO CHECK FOR A PENDING CONTROL Y/C AST.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF A CONTROL Y/C AST IS PENDING, THEN CONTROL IS TRANSFERED TO THE COMMAND
;	RESTART ENTRY POINT. OTHERWISE CONTROL IS RETURNED TO THE CALLER.
;-
 
	.ENABL	LSB
MCR$CHECK_AST::				;CHECK FOR PENDING CONTROL Y/C AST
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),50$ ;IF CLR, NO PENDING AST
10$:	BRW	MCR$RESTART		;

	.SBTTL	ENABLE/DISABLE CONTROL Y/C AST'S
;+
; MCR$DISABLE - DISABLE CONTROL Y/C AST'S
;
; THIS ROUTINE IS CALLED TO DISABLE/ENABLE CONTROL Y/C AST'S.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CONTROL Y/C AST'S ARE DISABLED, THE PREVIOUS ENABLE STATE IS SAVED, AND
;	A CO-ROUTINE CALL IS MADE BACK TO THE CALLER. WHEN CONTROL RETURNS, THE
;	AST STATE IS RESTORED TO ITS VALUE BEFORE THE DISABLE.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL
;-
 
MCR$DISABLE::				;DISABLE CONTROL Y/C AST'S
	PUSHL	(SP)			;COPY RETURN ADDRESS
	MOVZWL	PRC_W_FLAGS(R11),4(SP)	;SAVE PREVIOUS DISABLE STATE
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	JSB	@(SP)+			;CALL THE CALLER BACK
	BBS	#PRC_V_DISABL,4(SP),40$	;IF SET, AST'S PREVIOUSLY DISABLED
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF SET, AT CONTROL Y/C LEVEL
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BNEQ	30$			;IF NEQ NO
20$:	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),10$ ;IF SET, CONTROL Y/C REQUEST
30$:	BICW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;ENABLE CONTROL Y/C AST'S
40$:	POPL	(SP)			;REMOVE PREVIOUS STATE FROM STACK
50$:	RSB				;
	.DSABL	LSB

	.SBTTL	FLUSH COMMAND BUFFER
;+
; MCR$FLUSH - FLUSH COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO READ CHARACTERS FROM THE COMMAND BUFFER UNTIL AN
; END OF LINE IS ENCOUNTERED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	INDIRECT FILE RECOGNITION IS DISABLED AND CHARACTERS ARE READ FROM THE
;	INPUT BUFFER UNTIL AN END OF LINE IS ENCOUNTERED.
;-
 
MCR$FLUSH::				;FLUSH COMMAND BUFFER
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF AT ^Y LEVEL DON'T FLUSH
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),5$	;IF NOT IN A .GOTO SECTION, BRANCH
	CMPB	R0,#^A/;/		;In a .GOTO section - also in a comment?
	BNEQ	5$			;If NEQ, no
	SETBIT	LOC_V_FULCOM,WRK_W_LOCFLG(FP) ;Set comment-in-a-.GOTO-section flag
5$:	MOVL	PRC_L_INDINPRAB(R11),R0	;GET CURRENT INPUT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R0),20$ ;LIKEWISE FOR TERMINALS
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
10$:	BSBW	MCR$GETCHAR		;GET CHARACTER FROM INPUT BUFFER
	BNEQ	10$			;IF NEQ NOT END OF LINE
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE RECOGNITION
20$:	RSB				;


	.SBTTL	SEARCH VERB TABLE
;---
; MCR$SEARCH_VERB - SEARCH VERB TABLE AND OBTAIN VERB INFORMATION
;
; THIS ROUTINE SEARCHES THE VERB TABLE FOR A SPECIFIED STRING.
; IF FOUND, THE VERB ATTRIBUTES ARE STORED IN THE COMMAND WORK AREA.
;
; INPUTS:
;
;	R1 = LENGTH OF VERB TOKEN
;	R2 = ADDRESS OF VERB TOKEN
;	R8 = ADDRESS OF COMMAND TABLES
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R8 = ADDRESS OF CMD BLOCK OR ZERO IF VERB NOT FOUND
;	THE COMMAND WORK AREA IS INITIALIZED IF VERB FOUND
;---

MCR$SEARCH_VERB::
	PUSHR	#^M<R1,R2,R6,R7,R9>		;SAVE REGISTERS

;
; TRIM VERB TO FOUR CHARACTERS.
;
	MOVQ	R1,R4				;SAVE COMMAND VERB DESCRIPTOR
	CMPL	#4,R4				;COMMAND VERB LESS THAN 5 CHARACTERS?
	BGEQ	20$				;IF GEQ, USE ORIGINAL LENGTH
	MOVL	#4,R4				;SET TO SCAN ONLY 4 CHARACTERS

;
; FIND BASE AND SIZE OF VERB AND POINTER TABLES.
;
20$:	ADDL3	VEC_L_COMDPTR(R8),R8,R7		;GET BASE OF POINTER TABLE
	ADDL	#VEC_K_HEADER_LENGTH,R7		;SKIP PAST POINTER TABLE HEADER

	ADDL3	VEC_L_VERBTBL(R8),R8,R3		;GET BASE OF VERB TABLE
	CVTWL	VEC_W_SIZE(R3),R2		;GET SIZE OF TABLE + HEADER
	SUBL	#VEC_K_HEADER_LENGTH,R2		;REMOVE HEADER
	DIVL3	#4,R2,R6			;GET SIZE IN VERBS (4 BYTES PER VERB)
	ADDL	#VEC_K_HEADER_LENGTH,R3		;SKIP PAST VERB TABLE HEADER

;
; SEARCH VERB TABLE FOR SPECIFIED VERB.
;
22$:	MATCHC	R4,(R5),R2,(R3)			;SCAN FOR VERB MATCH
	BEQL	25$				;BR IF VERB MATCH
	CLRL	R8				;NO COMMAND BLOCK - VERB NOT FOUND
	STATUS	IVVERB				;INVALID VERB
	BRW	90$				;

;
; IF MATCH WAS NOT ON LONGWORD BOUNDARY, THEN KEEP LOOKING.
;
25$:	SUBL3	R4,R3,R0			;GET ADDRESS OF MATCHED VERB
	BICL3	#3,R0,R1			;ROUND ADDR TO LONGWORD ADDR
	CMPL	R0,R1				;IS IT SAME AS ORIGINAL?
	BNEQ	22$				;NO, THEN KEEP LOOKING

;
; VERB MATCH FOUND - GET ADDRESS OF CMD BLOCK.
;
	MOVL	R8,WRK_L_TAB_VEC(FP)		;SAVE ADDRESS OF TABLES VECTOR
	DIVL3	#4,R2,R9			;CALCULATE INVERSE COMMAND INDEX
	SUBW3	R9,R6,R9			;CALCULATE VERB INDEX
	SUBW	#1,R9				;ZERO BASE THE RESULT
	ADDL3	WRK_L_TAB_VEC(FP),(R7)[R9],R9	;GET ADDRESS OF COMMAND BLOCK

;
; CHECK FOR AMBIGUOUS VERBS.
;
	BBS	#CMD_V_ABBREV,-			;IF SET, NON UNIQUE ACCEPTABLE
		CMD_W_FLAGS(R9),30$ 		;
	SUBL	R4,R3				;BACKUP TO START OF VERB ENTRY FOUND
	CMPC5	#4,(R5),#0,#4,(R3)		;EXACT MATCH?
	BEQL	30$				;IF EXACT MATCH, IGNORE AMBIGUITY
	MATCHC	R4,(R5),#4,(R3)			;SCAN FOR DUPLICATE MATCH
	BNEQ	30$				;IF NEQ UNIQUE MATCH
	STATUS	ABVERB				;AMBIGUOUS COMMAND VERB
	BRW	90$				;

;
; VERB MATCH FOUND - EXTRACT ATTRIBUTES FROM COMMAND BLOCK
;
30$:	MOVB	CMD_B_VERBTYP(R9),-		;SET VERB TYPE FOR OLD INTERFACE
		WRK_B_VERBTYP(FP)		;

	CVTWL	CMD_W_NAME(R9),R0		;SAVE VERB NAME
	ADDL	R9,R0				;
	MOVAB	1(R0),WRK_L_VERB(FP)		;SKIP PAST FIRST ASCIC COUNT

	EXTZV	#CMD_V_MINPARM,#CMD_S_MINPARM,-	;EXTRACT MINIMUM NUMBER OF PARAMETERS
		CMD_B_PARMCNT(R9),WRK_L_MINPARM(FP)

	EXTZV	#CMD_V_MAXPARM,#CMD_S_MAXPARM,-	;EXTRACT MAXIMUM NUMBER OF PARAMETERS
		CMD_B_PARMCNT(R9),WRK_L_MAXPARM(FP)

	MOVL	CMD_L_QUALS(R9),R0		;GET OFFSET TO FIRST QUALIFIER DESC
	BEQL	40$				;IF EQL NONE
	ADDL	R8,R0				;CALCULATE ACTUAL ADDRESS
40$:	MOVL	R0,WRK_L_QUABLK(FP)		;SET ADDRESS OF QUALIFIER DESCRIPTORS

	MOVL	CMD_L_PARMS(R9),R0		;GET OFFSET TO FIRST POSITIONAL ENTITY
	BEQL	50$				;IF EQL NONE
	ADDL	R8,R0				;CALCULATE ACTUAL ADDRESS
50$:	MOVL	R0,WRK_L_PROPTR(FP)		;SAVE ADDRESS OF PARAMETER DESCRIPTORS

	MOVL	CMD_L_DISALLOW(R9),R0		;GET OFFSET TO DISALLOW EXPRESSION TREE
	BEQL	55$				;IF EQL NONE
	ADDL	R8,R0				;CALCULATE ACTUAL ADDRESS
55$:	MOVL	R0,WRK_L_DISALLOW(FP)		;SAVE ADDRESS OF DISALLOW EXPRESSION TREE

	CVTWL	CMD_W_OUTPUTS(R9),R0		;GET OFFSET TO OUTPUT LIST
	BEQL	60$				;IF EQL NONE
	ADDL	R9,R0				;CALCULATE ACTUAL ADDRESS
60$:	MOVL	R0,WRK_L_PAROUT(FP)		;SAVE ADDRESS OF OUTPUT LIST

	CLRL	WRK_L_PARMCNT(FP)		;CLEAR COUNT OF PARAMETERS
	CLRB	WRK_B_CMDOPT(FP)		;CLEAR ENTITY # CAUSING SYNTAX CHANGE
	CLRBIT	CMD_V_NOSTAT,WRK_B_CMDFLG(FP)	;CLEAR STATUS FLAG
	BBC	#CMD_V_NOSTAT,CMD_W_FLAGS(R9),62$ ;BRANCH IF STATUS SHOULD BE SET
	SETBIT	CMD_V_NOSTAT,WRK_B_CMDFLG(FP)	;SET STATUS FLAG

;
; IF CLI ROUTINE OR IMAGE - GET ADDRESS OF ASCIC ROUTINE NAME OR FILE SPEC.
;
62$:	BICW	#WRK_M_CLIRTN,WRK_W_FLAGS2(FP)	;CLEAR PREVIOUS IMAGE STATE
	CVTWL	CMD_W_IMAGE(R9),R0		;GET BRO TO IMAGE/ROUTINE INFO
	ADDL	R9,R0				;COMPUTE REAL ADDRESS
	CMPB	#CMD_K_CLI,CMD_B_HANDLER(R9)	;ARE WE DEALING WITH A CLI ROUTINE?
	BNEQ	70$				;NO, THEN SKIP
	SETBIT	WRK_V_CLIRTN,WRK_W_FLAGS2(FP)	;SET CLI ROUTINE FLAG
70$:	MOVL	R0,WRK_L_IMAGE(FP)		;SAVE IMAGE/ROUTINE INFO

;
; RESTORE STATE AND RETURN SUCCESS.
;
	STATUS	NORMAL				;SET SUCCESSFUL STATUS
	MOVL	R9,R8				;RETURN CMD BLOCK ADDRESS
90$:	POPR	#^M<R1,R2,R6,R7,R9>		;RESTORE REGISTERS
	RSB

	.SBTTL	PROCESS FOREIGN COMMAND
;
; SUBROUTINE TO PROCESS FOREIGN COMMAND AND BUILD RESULT PARSE DESCRIPTOR
;
 
PROCFORN:				;PROCESS FOREIGN COMMAND
	MOVL	R8,R9			;SAVE ENTITY BLOCK ADDR IF ONE EXISTS
	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;MAKE SURE THERE IS A SPACE
	DECL	WRK_L_CHARPTR(FP)	;BACKUP POINTER TO GET SPACE
	MOVL	WRK_L_EXPANDPTR(FP),R0	;GET EXPANSION BUFFER POINTER
	MOVAB	1(R0),R8		;SET START OF LINE AFTER SPACE
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE INTERPRETATION
10$:	BSBW	MCR$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BNEQ	10$			;IF NEQ NOT END OF FILE
	DECL	WRK_L_EXPANDPTR(FP)	;BACK UP TO TERMINATOR
	SUBL3	R8,WRK_L_EXPANDPTR(FP),R7 ;CALCULATE LENGTH OF COMMAND LINE
	CLRL	R4			;CLEAR ENTITY NUMBER
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#PTR_K_PARAMETR,R5	;SET ITEM TYPE TO PARAMETER
	BSBW	MCR$GENDESCR		;GENERATE RESULT PARSE TABLE DESCRIPTOR
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE INTERPRETATION
	RSB				;
 

	.SBTTL	MAIL PASSBACK STRUCTURE TO THE AME
;+
; MCR$MAILPBK - MAIL PASSBACK STRUCTURE TO THE AME FROM MCR IN A SUBPROCESS
;
; THIS ROUTINE IS CALLED WHEN THIS PROCESS IS A SUBPROCESS CREATED BY THE
; AME AS PART OF EXECUTION OF THE SPWN$ DIRECTIVE.  THIS ROUTINE MAILS
; THE PASSBACK STRUCTURE, WHICH INCLUDES CRITICAL PROCESS INFORMATION AND
; EXIT STATUS FOR THIS COMMAND, TO THE MAIN PROCESS.  THE INFORMATION IN
; THE PASSBACK STRUCTURE WILL ALLOW THE AME TO FIXUP CRITICAL PROCESS CONTEXT,
; SUCH AS UIC, FOR THE MAIN PROCESS.
;
; INPUTS:
;
;	R0 = EXIT STATUS OF COMMAND
;
;	IF THIS COMMAND CHANGED A CRITICAL PART OF THE PROCESS CONTEXT,
;	THAT CRITICAL INFORMATION SHOULD BE CONTAINED IN THE PASSBACK
;	STRUCTURE.
;
; OUTPUTS:
;
;	THE PASSBACK STRUCTURE IS MAILED TO THE MAIN-PROCESS AME'S RECEIVING
;	MAILBOX.
;-
MCR$MAILPBK::
	MOVL	PRC_L_PBKPTR(R11),R6		;GET POINTER TO PASSBACK STRUCTURE
	MOVL	R0,PBK$L_STATUS(R6)		;SET THE EXIT STATUS OF THIS COMMAND
	MOVZBW	#RSX$C_PASSBACK,PBK$W_TYPE(R6)	;TYPE OF MAIL IS PASSBACK
	BLBS	R0,10$				;IF SUCCESSFUL, DON'T CLEAR PASSBACK FLAG
	CLRBIT	PBK$V_PASSBACK,PBK$W_FLAGS(R6)	;ONLY SEND EXIT STATUS IF ERROR
10$:	$QIOW_S	CHAN=PRC_W_MBXCHAN(R11),-	;CHANNEL OF MAIN-PROCESS AME'S MAILBOX
		FUNC=#IO$_WRITEVBLK!IO$M_NOW,-	;WRITE THE MESSAGE AND DON'T WAIT
		P1=(R6),P2=#PBK$C_PBKSTRSIZ	;ADDR AND LENGTH OF PASSBACK STRUCTURE
	CLRBIT	PBK$V_PASSBACK,PBK$W_FLAGS(R6)	;RE-INITIALIZE PASSBACK FLAG FOR NEXT TIME
	RSB

	.SBTTL	GET INTERNAL ROUTINE INDEX
;---
; MCR$LOCATE_INTERNAL - GET INDEX FROM INTERNAL ROUTINE TABLE
;
; THIS ROUTINE SEARCHES THE TABLE OF INTERNAL ROUTINES FOR A SPECIFIED STRING.
; IF FOUND, THE INDEX OF THAT STRING IS RETURNED.
;
; INPUTS:
;
;	R1/R2 = ROUTINE NAME DESCRIPTOR
;
; OUTPUTS:
;
;	R0 = STATUS
;	R3 = INDEX NUMBER
;	R4 IS DESTROYED
;---

MCR$LOCATE_INTERNAL:
	MOVQ	R1,-(SP)		; SAVE R1/R2
	MOVQ	(R2),-(SP)		; GET ROUTINE NAME
	BISB	#^X80,(SP)		; SET HIGH ORDER BIT TO FORCE ROUTINE MATCH
	CMPL	R1,#8			; ROUTINE LENGTH GREATER THAN 8?
	BLEQ	5$			; BRANCH IF NOT
        MOVL	#8,R1			; SET LENGTH EQUAL 8
5$:	MOVL	#ROUTINES_LEN,R4	; SET TABLE LENGTH
	MATCHC	R1,(SP),R4,ROUTINES	; FIND SPECIFIED ROUTINE
	BNEQ	20$			; BRANCH IF NO MATCH
	BICL	#7,R2			; ROUND REMAINING LENGTH UP
	ADDL	#8,R2			;
	SUBL	R2,R4			; CALCULATE RELATIVE POSITION OF MATCH
	ASHL	#-3,R4,R3		; DIVIDE BY 8 TO GET INDEX INTO R3
	MOVL	#1,R0			; SET SUCCESS
10$:	CLRQ	(SP)+			; RESTORE STACK
	MOVQ	(SP)+,R1		; RESTORE R1/R2
	RSB

20$:	STATUS	INVROUT			; SET INVALID ROUTINE STATUS
	BRB	10$			; RETURN

	.END
