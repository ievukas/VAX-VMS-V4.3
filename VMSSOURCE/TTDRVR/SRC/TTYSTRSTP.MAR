	.TITLE	TTYSTRSTP - Terminal driver start/stop I/O routines
	.IDENT 	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES PERTAINING TO STARTING AND COMPLETING
;	I/O REQUESTS.
;
; AUTHOR:
;
;	R.HEINEN 10-OCT-1977
;
; Revision history:
;
;	V03-030	MIR0450		MICHAEL I. ROSENBLUM		27-JUN-1984
;		Add code to the free linefeed logic to account for PC_NOCRLF.
;		Fix problem that causes the first linefeed typed on a 
;		read with no prompt to not be echoed.
;
;	V03-029	RKS0029		RICK SPITZ			10-APR-1984
;		Enhance virtual terminal connect action routine to
;		perform an implicit set mode operation.
;
;	V03-028	MIR0370		Michael I. Rosenblum		20-Mar-1984
;		Put code in to fix problems with lines and prompts causing
;		wrap.  Fix bug that would cause FMS programs to crash the
;		system.
;
;	V03-027	RKS0027		RICK SPITZ			05-MAR-1984
;		Enhance write post completion to handle the case
;		of a write completion with no current PUCB.
;
;	V03-026	MIR0310		Michael I. Rosenblum		09-Feb-1984
;		Fix bugs.
;		make sure setting nomodem on a modem terminal shuts down
;		   the line.
;
;	V03-025	MIR0300		Michael I. Rosenblum		30-Jan-1984
;		Add input fallback
;
;	V03-024	MIR0085		Michael I. Rosenblum		26-Aug-1983
;		Remove references to DCL_OUTBND and DCL_CTRLC.
;
;	V03-023	MIR0082		Michael I. Rosenblum		19-Aug-1983
;		Make autoxoff mode work with passall and ttsync.
;		Fix pasthru to remain enabled after a read completes.
;
;	V03-022	MIR0080		Michael I. Rosenblum		28-Jul-1983
;		Move newline code into write done rather than TTYFDT
;		Reposition routines in the module.
;
;	V03-021	MIR0070		Michael I. Rosenblum		13-jul-1983
;		Fix bug that would cause TTY$DISCONNECT to be called twice.
;		if a SETMODE with the HANGUP modifier was issued.
;
;	V03-020	MIR0051		Michael I. Rosenblum		23-Jun-1983
;		Fix missing litterals in connect and disconnect code.
;		Check write active bit in getnextwrite to insure that
;		The write queue is not reordered.
;
;	V03-019	RKS0019		RICK SPITZ			7-JUN-1983
;		ADD CONNECT/DISCONNECT ACTION ROUTINES.
;		ENHANCE WRITE DONE FORK PROCESS TO ALWAYS USE REQCOM
;		IF THE WRITE IRP IS POINTED TO BY UCB$L_IRP
;		MAKE SURE LUCB IS NOT DETACHED AT THE ALTERNATE WRITE ENTRY.
;		REMOVE CTRLY HANGUP CHECK, AS IT IS STILL DONE IN FDT.
;
;	V03-018	RKS0018		RICK SPITZ			16-MAY-1983
;		MOVE SEGMENTS OF CHARACTERISTICS FDT CODE TO TTYSTRSTP
;		TO ALLOW CLEAN DISCONNECT OF DISCONNECTED TERMINALS.
;		RESTORE LUCB FROM LUCB IN READ/WRITE DONE.
;
;	V03-017	MIR0050		Michael I. Rosenblum		11-May-1983
;		Remove code that special cased broadcasts.  Allow the
;		data returned by timeout errors to be stored in the recall
;		buffer.  Make write post complete broadcasts.
;
;	V03-016	MIR0030		Michael I. Rosenblum		30-Mar-1983
;		Integrate Read verification with the standard driver
;		Add support for alternate frame sizes.
;
;	V03-015	MIR0029		Michael I. Rosenblum		22-Mar-1983
;		Add field to the iosb when itemlist reads are used.
;
;	V03-014	RKS0014		RICK SPITZ			14-MAR-1983
;		ADD SUPPORT FOR LOGICAL UCB. NOTE THAT THE DRIVER
;		SWITCHES TO PHYSICAL UCB CONTEXT AT STARTIO ENTRY. IT
;		RESTORES LOGICAL UCB CONTEXT PRIOR TO RETURNING TO THE
;		SYSTEM.
;
;	V03-013	MIR8026		Michael I. Rosenblum		14-Mar-1983
;		Fix bug in partail escape sequence processing.
;
;	V03-012	MIR5026		Michael I. Rosenblum		10-Mar-1983
;		Fix security whole with command recall and the password
;		by not allowing noecho strings to be stored in the recall
;		buffer.
;
;	V03-011	MIR1024		Michael I. Rosenblum		09-Mar-1983
;		Fix code in getnxtwrite to look at the read packet
;		rather than UCB$W_BCNT to find the number of characters
;		that have been read so far.
;
;	V03-010	MIR0026		Michael I. Rosenblum		01-Mar-1983
;		Add code to save the results of the last read.
;
;	V03-009	MIR0024		Michael I. Rosenblum		28-Jan-1983
;		Update code to use the new read packet format
;
;	V03-008	MIR0023		Michael I. Rosenblum		24-Jan-1983
;		Read buffer was used after it was deallocated if a
;		Cancel was issued while EDITREAD state was in affect.
;		Changed READONE code to clear the edit read states
;		when a read is completed.
;
;	V03-007	MIR0016		Michael I. Rosenblum		4-Jan-1983
;		Change TTY$STARTOUTPUT to use the UCB OUTYPE field to determine
;		the necessary action when TTY$GETNEXTCHAR is called.  This change
;		should illiminate the checking the volitale condition code bits
;		that previously had the function of OUTYPE.  For compatibility
;		purposes only we are setting the correct condition codes.
;
;	V03-006	MIR0015		Michael I. Rosenblum		20-Dec-1982
;		Change TTY$V_ST_UNSOL and TTY$V_ST_GETAHD to TTY$V_FD_UNSOL
;		and TTY$V_FD_GETAHD, to reflect changes in the fork dispatcher
;		also change PORT_DISCONNECT call to refer to 
;		CLASS_MODEM_DIS.  Change all port calls to call the Class
;		driver jacket routines.
;
;	V03-005 MIR0013		Michael I. Rosenblum		16-Dec-1982
;		Fix up refferences to new ucb structure
;
;	V03-004	MIR0011		Michael I. Rosenblum		18-Nov-1982
;		Remove code that implimented HOLDSCREEN.
;
;	V03-003	MIR0010		Michael I Rosenblum	09-Nov-1982
;		Move the address of the terminator mask, and the length
;		of the prompt string from the IRP into the terminal read
;		buffer.
;
;	V03-002	ROW0077		Ralph O. Weber		27-MAR-1982
;		Change TTY$WRITEDONE to insure that eventhough UCB$W_TT_CURSOR 
;		can now be bigger than UCB$W_DEVBUFSIZ, i.e. eventhough our 
;		internal cursor position marker can virtually be beyond the 
;		right-hand edge of the screen, the cursor-position value 
;		returned in IOSB will never exceed the width of the screen.
;
;	V03-001	JLV0202		Jake VanNoy		23-MAR-1982
;		Change MODHANGUP from NOMOD to PRIV_TO_MOD in Set
;		Mode/Char logic.
;		Correct alternate class name lookup.
;
;	V02-045	RKS0045		RICK SPITZ		22-FEB-1982
;		Repair diagnostic function code logic.
;
;	V02-044	RKS0044		RICK SPITZ		16-FEB-1982
;		Enhance broadcast logic to allow delay prior to
;		forcing output. Move setting of controls pending
;		to STOP2 timeout. This way user ^s can be distinquished
;		from terminal xoff.
;		Save R3 prior to forking to create typeahead on read.
;
;	V02-043	RKS0043		RICK SPITZ		11-FEB-1982
;		Zero fork byte in TWP to allow DMA of broadcast.
;		Prevent XON characteristic from being permantly set.
;
;	V02-042	RKS0042		Rick Spitz		8-FEB-1982
;		Repair Alternate typeahead logic to allow setting
;		Permanent from users terminal.
;		Allocate typeahead buffer when starting read, if not already
;		done. This is needed for lines which are used for communications
;		on DMF-32 async lines.
;
;	V02-041	ROW0066		Ralph O. Weber		31-JAN-1982
;		Enhance alternate class driver setup to relocate address in 
;		alternate class driver vector table.  Correct use of 
;		unrelocateable .ASCID directive.
;
;	V02-040	RKS0040		RICK SPITZ		24-JAN-1982
;		USE INPUT VALUE FOR READ FIELD OFFSET.
;		ADD LOGIC TO BIND TO ALTERNATE DRIVER.
;
;	V02-039	RKS0039		RICK SPITZ		15-DEC-1981
;		FIX MAINTENANCE DISPATCH LOGIC.
;		DISALLOW SETTING ALT TYPEAHEAD IF ONE ALREAY EXISTS.
;		REMOVE LOGIO REQUIREMENT FOR PARITY ENABLE.
;		FIX WRTSTARTIO RETURN ADDRESSING.
;		ALLOW NOECHO READ TO NOT BLOCK WRITES.
;		ADD WRITE POST ROUTINE TO REPLACE INSPOST LOGIC, THIS
;		CORRECTS RACE CONDITION IN HALF DUPLEX WRITE COMPLETIONS.
;		ADD SUPPORT FOR ALTERNATE CLASS DRIVER.
;
;	V02-038	JLV0126		Jake VanNoy		1-Dec-1981
;		Add local echo logic and set speed privilege checking.
;
;	V02-037	JLV0102		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-036	JLV0070		Jake VanNoy			28-Aug-1981
;		Added UCB$L_TT_DEVDP1 checking and no refresh on broadcast.
;
;	V02-035	RKS035		RICK SPITZ			26-AUG-1981
;		ADD MAINT ENABLE BIT
;
;	V02-034	RKS034		RICK SPITZ			20-AUG-1981
;		ADD SUPPORT FOR ESCAPE MODIFIER ON READ.
;
;	V02-033	RKS033		RICK SPITZ			12-AUG-1981
;		RESET DMA ABORT STATE IN WRITE DONE LOGIC.
;		RESET CONTROLS STATE FOR MAINTENANCE FUNCTIONS.
;
;	V02-032	RKS032		RICK SPITZ			27-JULY-1981
;		SEVERAL ENHANCEMENTS HAVE BEEN ADDED TO SUPPORT REVISIONS
;		TO THE UCB STRUCTURE INCLUDING SPLIT SPEED, AND QUADWORD STATE
;		AND DEVDEPEND FIELDS.
;		SUPPORT FOR DIAGNOSTIC FUNCTIONS AND ENHANCED MODEM PROCESSING
;		HAS BEEN ADDED. SEVERAL CHANGES TO SUPPORT THE CLASS/PORT
;		STRUCTURE AS WELL AS ENHANCEMENTS TO ALLOW TERMINAL 
;		INITIATED CONTROL S AND Q DURING BROADCAST HAVE ALSO BEEN
;		ADDED.
;
;	V02-031	RKS031		RICK SPITZ			26-FEB-1981
;		REMOVE V2.0 AUDIT TRAILS
;

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS
;
	$ARBDEF				; DEFINE ACCESS RIGHTS BLOCK
;	$CADEF				; DEFINE CONDITIONAL ASSEMBLY PARAMETERS.
	$CRBDEF				; DEFINE CRB
	$DPTDEF				; DEFINE DPT OFFSETS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL'S
	$IRPDEF				; DEFINE IRP
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRVDEF				; DEFINE PRIVILEGE MASK BITS
	$SSDEF				; Define system status codes
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE TERMINAL CHARACTERISTICS
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$UCBDEF				; DEFINE UCB
	$VECDEF				; DEFINE CRB VECTOR OFFSETS
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
	$TTYMODEM			; DEFINE TERMINAL MODEM DEFINITIONS

	.PSECT	$$$115_DRIVER,LONG	; DEFINE NON-PAGED PSECT

	.SBTTL	TTY$STARTIO - START I/O OPERATION ON TERMINAL
;++
; TTY$STARTIO - START I/O OPERATION ON TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE UNIT IS IDLE AND THERE IS A PACKET TO PROCESS.
;
; INPUTS:
;
;	I/O PACKET FORMATTED AS DESCRIBED IN TTYFDT.
;
;	R3 = I/O PACKET ADDRESS
;	R5 = LOGICAL UCB ADDRESS
;
; OUTPUTS:
;
;	NONE
;--
TTY$STARTIO::				; START TERMINAL I/O

;	MOVE TO PHYSICAL UCB CONTEXT. THIS INVOLVES DUPLICATING
;	MANIPULATIONS TO THE LOGICAL UCB DONE BY IOC$INITIATE

	MOVL	UCB$L_TL_PHYUCB(R5),R0	; GET PHYSICAL UCB ADDRESS 
	MOVL	R3,UCB$L_IRP(R0)	; COPY IRP ADDRESS TO PHYS UCB
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R0)
	BICW	#UCB$M_CANCEL!UCB$M_TIMOUT,UCB$W_STS(R0)
	MOVL	R0,R5			; SWITCH TO PHYSICAL UCB
	
	BSBW	TTY$LOCK		; SETUP IPL AND REGISTERS
	BICW3	#^C<IO$M_FCODE>,IRP$W_FUNC(R3),R4; GET INTERNAL FUNCTION CODE
	CASE	R4,TYPE=B,<DO_READ,DO_WRITE,DO_SETM,DO_SETC,DO_HANGUP,-
			DO_MAINT,DO_HANGUP,DO_CONNECT,DO_DISCONNECT>


	.sbttl	START_IO ACTION ROUTINES

;	CONNECT THIS PUCB TO A DETACHED LUCB

DO_CONNECT:
	BBC	#IO$V_TT_DISCON,-
		IRP$W_FUNC(R3),10$		;SKIP UNLESS DISCONNECT SPECIFIED
	BICL	#TT2$M_DISCONNECT,UCB$L_DEVDEPND2(R5); FORCE HANGUP TO COMMAND PROCESS
10$:
	MOVL	UCB$L_PDT(R5),R1		; GET TARGET LUCB ADDRESS
	BEQL	25$				; NONE, MUST BE JUST DELETED

	SET_STATE	RECONNECT		; SET RECONNECT STATE TO TARGET LUCB 

	PUSHR	#^M<R1,R3>			; SAVE IRP ADDRESS AND LUCB
	MOVL	#TTY$V_FD_DISCONNECT,R4		; SCHEDULE DISCONNECT COMMAND PUCB
	BSBW	TTY$CRE_FORK		
	POPR	#^M<R1,R3>			; SAVE IRP ADDRESS AND LUCB

;	NOW CONVERT IRP INTO SET MODE AND FILL IN VALUES FROM
;	THE TARGET LUCB

	MOVQ	UCB$L_DEVDEPEND(R1),IRP$Q_TT_STATE(R3)
	MOVB	UCB$B_DEVTYPE(R1),IRP$L_MEDIA+1(R3)	; TERMINAL TYPE
	MOVW	UCB$W_DEVBUFSIZ(R1),IRP$L_MEDIA+2(R3)	; WIDTH
	CLRL	IRP$W_TT_PRMPT(R3)
	CLRL	IRP$L_VAL5(R3)

	BICL	#TT$M_MODEM,IRP$Q_TT_STATE(R3)		; TRACK MODEM TO BE SAME AS PUCB
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),20$	; 
	BISL	#TT$M_MODEM,IRP$Q_TT_STATE(R3)		; 
20$:
	BICL	#TT2$M_DISCONNECT,IRP$Q_TT_STATE+4(R3)	; TRACK DISCONNECT TO BE SAME AS PUCB
	BBC	#TT2$V_DISCONNECT,UCB$L_DEVDEPND2(R5),22$; 
	BISL	#TT2$M_DISCONNECT,IRP$Q_TT_STATE+4(R3)	; 
22$:
	

	BRW	DO_SET				; NOW INVOKE SET MODE ACTION ROUTINE

25$:	MOVZWL	#SS$_NOSUCHDEV,R0		; INDICATE DEVICE NOT AVAILABLE
	BRW	TTY$DONE	



;	DISCONNECT COMMAND LUCB FROM PUCB.
;	IF NOT DETACHED, HANGUP SIGNALED TO COMMAND PROCESS

DO_DISCONNECT:
	PUSHL	R3				; SAVE IRP
	MOVL	#TTY$V_FD_DISCONNECT,R4		; SCHEDULE DISCONNECT ON THAT PUCB
	BSBW	TTY$CRE_FORK		
	POPL	R3				; RESTORE IRP
	MOVZWL	#SS$_NORMAL,R0
	BRW	TTY$DONE



;	PROCESS HANGUP FUNCTION. THIS ROUTINE FORCES A MODEM HANGUP

DO_HANGUP:
	PUSHR	#^M<R3,R4,R5>		; SAVE REGISTERS
	BSBW	CLASS_MODEM_DIS		; DISCONNECT UNIT
	POPR	#^M<R3,R4,R5>		; RESTORE REGITERS
	BRW	DO_EXIT



; 	PROCESS MAINTENANCE FUNCTIONS

DO_MAINT:
	BBS	#TT$V_MODEM,-			; DISALLOW IF MODEM LINE
		UCB$L_DEVDEPEND(R5),30$
	MOVL	UCB$L_TT_PORT(R5),R4		; ACCESS PORT VECTOR
	BBS	#IO$V_SET_MODEM,-		; BRANCH IF SET MODEM FUNCTION
		IRP$W_FUNC(R3),20$
	EXTZV	#IO$V_LOOP,#<IO$V_LOOP_EXT-IO$V_LOOP+1>,-
		IRP$W_FUNC(R3),R0		; GET MAINT SUBMODIFIERS
	BISB	R0,UCB$B_TT_MAINT(R5)		; PASS TO PORT
	CLRL	R0				; ASSUME ERROR, FOR NULL POST ROUTINE
	BSBW	TTY$MAINT			; INVOKE PORT DRIVER TO DO FUNCTION
	BICB	#^C<UCB$M_TT_DSBL>,-		; RESET ALL BUT DISABLE
		UCB$B_TT_MAINT(R5)
	BLBC	R0,30$				; FAILURE
	MOVL	UCB$L_TT_PORT(R5),R0		; GET PORT VECTOR ADDRESS
	BSBW	TTY$RESUME			; RESET ANY CONTROLS STATE
	BRW	DO_EXIT				; SUCCESS
20$:						; PROCESS SET MODEM SIGNALS
	MOVZWL	IRP$L_MEDIA+2(R3),R2		; GET SET/RESET MODEM MASK
	BICB	#^C<TT$M_DS_DTR!-		; CLEAR ALL BUT MODEM OUTPUT
		TT$M_DS_SECTX!-			; BITS
		TT$M_DS_RTS>,R2
	PUSHL	R3				; SAVE VOLITAL REGISTER
	BSBW	TTY$DS_SET			; SET /RESET SPECIFIED SIGNALS
	POPL	R3				; RESTORE REGISTER
	BRW	DO_EXIT				; SUCCESS EXIT
30$:
	MOVZWL	#SS$_ABORT,R0			; ERROR EXIT 
	CLRL	R1
	BRW	TTY$DONE

;
; READ OPERATION
;
DO_READ:				; 
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE ADDRESS OF THE READ PACKET

	BISL	IRP$Q_TT_STATE(R3),(R2)	; Set the read state bits.
	BISL	IRP$Q_TT_STATE+4(R3),4(R2)

	CLRL	IRP$L_MEDIA(R3)		; Set up storage for the read
					; terminator.
	BICW	#UCB$M_TT_NOTIF,-	; Set the "user has not been
		UCB$W_DEVSTS(R5)	; notified" bit.
	BBC	#IO$V_PURGE,-		; Branch forward if purge type-
		IRP$W_FUNC(R3),10$	; ahead not requested.
	BSBW	TTY$PURGE_AHEAD		; Otherwise, purge buffer.
					; the write completes.
10$:
	TSTL	UCB$L_TT_TYPAHD(R5)	; Type ahead buffer allocated?
	BEQL	30$			; Not yet

12$:	BSBW	TTY$SETUP_READ		; Set up the UCB for a read
					; operation.

;
; CHECK FOR LINE FEED NEEDED
;
;
	IF_STATE -			; Skip if passall, or
	<PASALL>,25$
	IF_NOT_STATE NOECHO,14$		; NO ECHO THEN
	CLR_STATE EDITING		; NO EDITING
14$:	IF_STATE -
	<NL,WRAP>,20$			; if already did line feed.

	IF_NOT_STATE NOECHO,15$		; Branch if echo
	BBC	#TT2$V_LOCALECHO,-	; Branch if not local echo
		UCB$L_DEVDEPND2(R5),20$

15$:	TSTW	UCB$W_TT_CURSOR(R5)	; CURSOR AT 0?
	BNEQ	20$			; If no, send no line feed.
	CMPB	UCB$B_TT_LASTC(R5),-	; Was the last character also a
		#TTY$C_CR		; carriage return?
	BNEQ	20$			; No. Don't send free linefeed.
	IF_NOT_STATE SKIPLF,17$		; NO SKIP LINEFEED THEN BYPASS NOCRLF CHECK
	BBS	#TTY$V_PC_NOCRLF,UCB$W_TT_PRTCTL(R5),20$;SO JUST ECHO THE CHARACTER NOW(WITH LINEFEED)
17$:	SET_STATE <SENDLF>		; SEND A LINE FEED FIRST
	CLR_STATE <SKIPLF>
	IF_NOT_STATE PROMPT,20$		; DO WE HAVE A 
	SET_STATE <SKIPLF>		; SEND A LINE FEED FIRST
20$:	IF_STATE RDVERIFY,25$		; THIS ISN'T NECESSARY IF READ VERIFY

	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE READ PACKET ADDRESS
	MOVZWL	UCB$W_TT_CURSOR(R5),-(SP); SAVE THE CURSOR POSITION FOR ECHOING
	CMPW	TTY$W_RB_MODE(R4),#TTY$K_ER_ECHLINE; IS THIS A READ WITH INITIAL
					; OFFSET.
	BNEQ	21$			; NO THEN USE NORMAL
	MOVZBW	UCB$B_TT_OLDCPZORG(R5),UCB$W_TT_CURSOR(R5); YES THEN USE THE
					; STORED INITIAL CURSOR POSITION
	MOVZBW	UCB$B_TT_OLDCPZORG(R5),TTY$W_RB_CPZORG(R4);
21$:	CLRW	TTY$W_RB_LINREST(R4)	; NO EXTRA CHARACTERS
	BSBW	FIND_BOL_NOCLEAR	; find the wrapping and
	CVTLW	(SP)+,UCB$W_TT_CURSOR(R5); RESTORE THE CURSOR POSITION FOR ECHOING
25$:	BRW	TTY$STARTOUTPUT		; Go start the read.
30$:
	; Allocate typeahead buffer

	PUSHL	R3			; SAVE IRP ADDRESS
	CLRL	R3			; INDICATE NO DATA
	MOVL	#TTY$V_FD_GETAHD,R4	; ASK FOR TYPEAHD FORK
	BSBW	TTY$CRE_FORK		; GO ALLOCATE BUFFER
	POPL	R3			; RESTORE IRP ADDRESS
	BRW	12$			; CONTINUE PROCESSING



; SET MODE OPERATION - 

DO_SETM:
	BRW	DO_SET

; DO SET CHARACTERISTICS

DO_SETC:				; DO PRIVILEGED SET
	CMPW	#12,IRP$W_BCNT(R3)	; CHECK PARAMETERS
	BLEQ	DO_SET			; ALL SPECIFIED
	MOVL	UCB$L_TT_DECHA1(R5),-	; INIT DEFAULT IF NOT SPECIFIED
		IRP$Q_TT_STATE+4(R3)

; PROCESS CHANGE OF CHARACTERISTICS AND MODE
; CHANGE BASIC MODE BITS IN UCB$L_DEVDEPEND

DO_SET:
	XORL3	IRP$Q_TT_STATE(R3),UCB$L_DEVDEPEND(R5),R4; GET MODIFIED BITS
	BBCC	#TT$V_REMOTE,R4,8$	; DISALLOW CLEARING REMOTE BIT
	BICL	#TT$M_REMOTE,IRP$Q_TT_STATE(R3)
					; DISALLOW SETTING REMOTE BIT
8$:
	BICL	R4,UCB$L_DEVDEPEND(R5)	; CLEAR THE CHANGED BITS
	BISL	IRP$Q_TT_STATE(R3),UCB$L_DEVDEPEND(R5);
	MOVB	IRP$L_MEDIA+1(R3),UCB$B_DEVTYPE(R5); INSERT NEW TERMINAL TYPE
;
;	DEVDP1 BIT CHECKING
;
	MOVL	IRP$Q_TT_STATE+4(R3),R0	; GET SECOND DEVDEPEND WORD
	XORL3	R0,UCB$L_DEVDEPND2(R5),R1 ; GET MODIFIED BITS
	BICL	#<TT2$M_DCL_MAILBX>,R0	; REMOVE DCL SPECIFIC BITS

	BBC	#TT2$V_DMA,R1,12$	; SKIP IF DMA NOT CHANGED
	BBC	#TT2$V_DMA,R0,10$	; BRANCH IF TURNING DMA OFF
	BBC	#TTY$V_PC_DMAAVL,UCB$W_TT_PRTCTL(R5),10$ ; DONT IF FEATURE NOT AVAILABLE
	BISL	#TT2$M_DMA,R0		; SET DMA CHARACTERISTIC ON
	BISW	#TTY$M_PC_DMAENA,UCB$W_TT_PRTCTL(R5) ; ENABLE IN PORT
	BRB	12$
10$:	BICW	#TTY$M_PC_DMAENA,UCB$W_TT_PRTCTL(R5) ; DISABLE DMA IN PORT
	BICL	#TT2$M_DMA,R0		; RESET DMA CHARACTERISTIC

12$:	NOMOD	ALTYPEAHD		; DISALLOW CHANGING TYPE AHEAD
	
	BBS	#TT2$V_MODHANGUP,-
		UCB$L_DEVDEPND2(R5),15$	; BRANCH IF MODIFY HANGUP ALLOWED

	PRIV_TO_MOD HANGUP		; REQUIRE PRIV TO MODIFY HANGUP
15$:	PRIV_TO_MOD SETSPEED		; REQUIRE PRIV TO MODIFY SET SPEED
	PRIV_TO_MOD SECURE		; REQUIRE PRIVS TO MODIFY SECURE SERVER
	PRIV_TO_MOD MODHANGUP		; REQUIRE PRIV TO MODIFY MODHANGUP

	BBC	#TT2$V_XON,R0,20$	; BRANCH IF NO XON REQUESTED
	BICL	#TT2$M_XON,R0		; RESET XON BIT.
	BSBW	TTY$RESUME		; CALL RESUME

20$:
	MOVL	R0,UCB$L_DEVDEPND2(R5) ; SET SECOND DEVDEPENDENT WORD
;
; SET UP WIDTH
;
	MOVW	IRP$L_MEDIA+2(R3),UCB$W_DEVBUFSIZ(R5); INSERT NEW CARRIAGE WIDTH
;
; SET UP SPEED
;
	MOVZWL	IRP$W_TT_PRMPT(R3),R1	; GET NEW SPEED
	BEQL	30$			; IF EQL THEN NO CHANGE
;
; SET SPEED PRIVILEGE CHECK
;
	CMPB	R1,UCB$W_TT_SPEED(R5)	; IS LOW ORDER BYTE OF SPEED CHANGING?
	BEQL	28$			; BRANCH IF NOT

	BBC	#TT2$V_SETSPEED,-
		UCB$L_DEVDEPND2(R5),28$	; BRANCH IF SET SPEED ALLOWED
	BITL	#<<1@PRV$V_LOG_IO>! -	; DOES PROCESS HAVE LOG_IO
		<1@PRV$V_PHY_IO>>, -	; OR PHY_IO PRIVILEGE?
		@IRP$L_ARB(R3)		; CHECK ACCESS RIGHTS BLOCK
	BNEQ	28$			; BRANCH IF PRIVILEGED
	BRW	NOPRIV_EXIT		; PRIV FAILURE

;
; PROCESS PARITY SETTINGS
;
28$:	MOVW	R1,UCB$W_TT_SPEED(R5)	; INSERT LINE SPEED
30$:	BBC	#TT$V_ALTRPAR,IRP$L_VAL5(R3),35$; BR IF PARITY SHOULD NOT BE ALTERED
	BICB3	#^C<TT$M_PARITY!TT$M_ODD>,IRP$L_VAL5(R3),R0; RESET BITS
	BICB	#TT$M_PARITY!TT$M_ODD,UCB$B_TT_PARITY(R5); CLEAR CURRENT PARITY
	BISB	R0,UCB$B_TT_PARITY(R5)	; INSERT NEW VALUE
;
; SET UP CHARACTER SIZE AND STOP BITS
;
35$:
	BBS	#TT$V_ALTFRAME,IRP$L_VAL5(R3),36$; DOES THE USER WANT A NEW FRPAM SIZE
	BBC	#UCB$V_TT_USERFRAME,UCB$B_TT_PARITY(R5),37$; DID THE USER SPECIFY
					; THE FRAME SIZE?
	BRB	42$			; YES THEN DON'T BOTHER IT
36$:	BBCC	#UCB$V_TT_USERFRAME,UCB$B_TT_PARITY(R5),38$
38$:	BICL3	#^C<^X0F>,IRP$L_VAL5(R3),R0; GET THE NEW FRAME SIZE
	BEQL	37$			; 0 SPECIFYED THEN CLEAR USER FRAME
	INSV	R0,#UCB$V_TT_LEN,#2,UCB$B_TT_PARITY(R5); SET THE
					; PARITY CORRECTLY
	BBCS	#UCB$V_TT_USERFRAME,UCB$B_TT_PARITY(R5),42$; AND SETUSER FRAME
					; SPECIFYED THEN CONTINUE ON
37$:	BBC	#TT$V_PARITY,-
		UCB$B_TT_PARITY(R5),40$	; IF NO PARITY, USE 8 BIT
	BBS	#TT$V_EIGHTBIT,-
		UCB$L_DEVDEPEND(R5),40$	; USE 8 BIT SIZE	
	BICB	#UCB$M_TT_LEN,UCB$B_TT_PARITY(R5)	; RESET CHARACTER FRAME
	BISB	#^X10,UCB$B_TT_PARITY(R5) 	; SET 7 BIT CHARACTER FRAME
	BRB	42$
40$:
	BISB	#UCB$M_TT_LEN,UCB$B_TT_PARITY(R5)	; SET 8 BIT CHARACTER FRAME
42$:
	BBC	#TT$V_ALTDISPAR,IRP$L_VAL5(R3),41$	; CHECK FOR DISABLE PARITY ERRORS BIT
	BICL	#UCB$M_TT_DISPARERR,UCB$B_TT_PARITY(R5)	; CLEAR DISMISS
	BBC	#TT$V_DISPARERR,IRP$L_VAL5(R3),41$	; DOES HE WANT IT SET
	BBSS	#UCB$V_TT_DISPARERR,UCB$B_TT_PARITY(R5),41$; YES THEN SET IT
41$:	BBS	#TT$V_TWOSTOP,IRP$L_VAL5(R3),43$	; DOES HE WANT TWO STOP BITS
	CMPB	UCB$W_TT_SPEED(R5),#4			; SPEED <= 150 BAUD?
	BGTR	44$					; NO
43$:	BISB	#UCB$M_TT_STOP,UCB$B_TT_PARITY(R5)	; FLAG 2 STOP BITS
	BRB	46$
44$:
	BICB	#UCB$M_TT_STOP,UCB$B_TT_PARITY(R5)	; FLAG 1 STOP BIT
;
; PROCESS FILL DATA
;
46$:
	CLRL	R0			; ASSUME NEW VALUE IS 0
	BBC	#TT$V_CRFILL,UCB$L_DEVDEPEND(R5),50$; CR FILL ON?
	MOVZBL	IRP$W_TT_PRMPT+2(R3),R0	; GET NEW VALUE
	BBS	#TT$V_CRFILL,R4,50$	; CHANGE?
	BEQL	60$			; IF NEQ EQL 0 THEN NO CHANGE
50$:	MOVB	R0,UCB$B_TT_CRFILL(R5)	; RESET VALUE
	BNEQ	60$			; IF NEQ THEN OK
	BBCC	#TT$V_CRFILL,UCB$L_DEVDEPEND(R5),60$; SET OFF
60$:	CLRL	R0			; ASSUME NEW VALUE IS 0
	BBC	#TT$V_LFFILL,UCB$L_DEVDEPEND(R5),65$; LF FILL ON?
	MOVZBL	IRP$W_TT_PRMPT+3(R3),R0	; GET NEW VALUE
	BBS	#TT$V_LFFILL,R4,65$	; CHANGE?
	BEQL	75$			; IF NEQ EQL 0 THEN NO CHANGE
65$:	MOVB	R0,UCB$B_TT_LFFILL(R5)	; RESET VALUE
	BNEQ	75$			; IF NEQ THEN OK
	BBCC	#TT$V_LFFILL,UCB$L_DEVDEPEND(R5),75$; SET OFF
;
; CHECK FOR CHANGE IN STATUS OF MODEM
;
75$:
	BBC	#TT$V_MODEM,R4,80$	; NO CHANGE IN MODEM STATUS
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE VOLITAL REGISTERS
	MOVZBL	#MODEM$C_INIT,R1	; ASSUME MODEM INIT
	BBS	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),-
		77$			; IT IS INIT
	MOVZBL	#MODEM$C_SHUTDWN,R1	; NO, SHUT DOWN
77$:
	BSBW	TRANSITION_NOCHECK	; DECLARE MODEM TRANSITION
	POPR	#^M<R0,R1,R2,R3,R4>

80$:
;
; enable or disable AUTO XON AND XOFF
;
	BISW	#TTY$M_PC_XOFENA,UCB$W_TT_PRTCTL(R5); TURN ON AUTO XOFF
	BBS	#TT$V_PASSALL,UCB$L_DEVDEPEND(R5),84$; IS THIS PASSALL? YES THEN
	BBS	#TT$V_TTSYNC,UCB$L_DEVDEPEND(R5),85$; IF TT SYNC IS SET THEN LEAVE IT ON
84$:	BICW	#TTY$M_PC_XOFENA,UCB$W_TT_PRTCTL(R5); TURN OFF AUTO XOFF
85$:
;
; COPY OVER PASSALL AND NOECHO TO CURRENT STATE
;
	BICB3	#^C<TT$M_PASSALL!TT$M_NOECHO>,UCB$L_DEVDEPEND(R5),R4
	INSV	R4,#TTY$V_ST_PASALL,#2,4(R2); INSERT IN STATE VECTOR
	EXTV	#TT$V_ESCAPE,#1,UCB$L_DEVDEPEND(R5),R4	; GET CURRENT SETTING
	INSV	R4,#TTY$V_ST_ESCAPE,#1,4(R2)		; UPDATE IN STATE
	BBC	#TT2$V_PASTHRU,UCB$L_DEVDEPND2(R5),98$	; IN PASS THRU MODE
	SET_STATE PASALL
98$:
;
; INIT THE UNIT TO CHANGE THE SPEED AND PARITY
;
	BSBW	TTY$SET_LINE		; INIT LINE SPEED AND PARITY
;
; IF MULTI IS SET THEN THE I/O MUST BE STARTED
;
100$:	IF_NOT_STATE MULTI,110$		; BR IF MULTI NO SET
	BSBW	TTY$STARTOUTPUT		; START THE MULTIPLE OUTPUT
;
; CHECK FOR SET CHARACTERISTICS AND RETURN IOSB DATA
;
110$:	MOVL	UCB$L_IRP(R5),R3	; GET CURRENT PACKET ADDRESS
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#TTY$C_FC_SETC; SET CHAR?
	BNEQ	120$			; IF NEQ THEN NO
	MOVL	UCB$W_TT_SPEED(R5),UCB$W_TT_DESPEE(R5); RESET PERM SPEED
	BBC	#TT2$V_AUTOBAUD,-
		UCB$L_DEVDEPND2(R5),115$ ; BRANCH IF NOAUTOBAUD
	MOVZBW	#TT$C_BAUD_9600,-
		UCB$W_TT_DESPEE(R5)	; SET PERMANENT 9600 BAUD FOR AUTOBAUD
115$:	MOVB	UCB$B_TT_PARITY(R5),UCB$B_TT_DEPARI(R5); RESET PERM PARITY
	MOVL	UCB$B_DEVTYPE(R5),UCB$B_TT_DETYPE(R5); RESET TYPE AND WIDTH
	BICL3	#TT$M_REMOTE,UCB$L_DEVDEPEND(R5),UCB$L_TT_DECHAR(R5); RESET PERM CHARACTERISTICS
	MOVL	UCB$L_DEVDEPND2(R5),UCB$L_TT_DECHA1(R5)	;UPDATE SECOND CHAR WORD

	BBC	#TT2$V_ALTYPEAHD,IRP$Q_TT_STATE+4(R3),120$; SKIP IF ALTERNATE
							 ; TYPEAHEAD NOT SPECIFIED
	BBSS	#TT2$V_ALTYPEAHD,UCB$L_TT_DECHA1(R5),120$ ; ONLY ALLOW SETTING
							 ; AS PERM CHARACTERISTIC
120$:

;	UPDATE NEWLY WRITTEN FIELDS WHICH ARE MAINTAINED 
;	IN BOTH THE LOGICAL ANY PHYSICAL UCB

	MOVL	UCB$L_TT_LOGUCB(R5),R0			; GET LOGICAL UCB ADDRESS
	MOVL	UCB$L_DEVDEPEND(R5),UCB$L_DEVDEPEND(R0)	; UPDATE CHARACTERISTICS
	MOVL	UCB$L_DEVDEPND2(R5),UCB$L_DEVDEPND2(R0)	; "UCB$L_TT_DEVDP1"
	MOVL	UCB$B_DEVCLASS(R5),UCB$B_DEVCLASS(R0)	; CLASS,TYPE,BUFSIZE

;	THIS ROUTINE COMPLETES SET AND SENSE CHARACTERISTICS OPERATIONS
;	AND RETURNS STATUS VALUES IN THE IOSB

DO_EXIT:
	MOVL	UCB$W_TT_SPEED-2(R5),R0; RETURN SPEED
	BICL3	#^C<<UCB$M_TT_PARTY!UCB$M_TT_ODD>@16>,UCB$B_TT_PARITY-2(R5),R1;
	MOVW	UCB$B_TT_CRFILL(R5),R1	; INSERT FILL DATA
	MOVW	#SS$_NORMAL,R0		; SET STATUS
	BRW	TTY$DONE

NOPRIV_EXIT:
	MOVL	#SS$_NOPRIV,R0		; SET NO PRIV
	CLRL	R1			; CLEAR R1
	BRW	TTY$DONE


;
; WRITE OPERATION
;
DO_WRITE:				;
;
; Control only comes here in the case of half duplex writes.  Full
; duplex writes use the TTY$WRTSTARTIO entry point.
;
	MOVL	IRP$L_SVAPTE(R3), R3	; Get addr of write block
	PUSHAB	TTY$STARTOUTPUT		; if write is started, control
					; will return to STARTOUTPUT
	BSBW	WRTSTARTIO		; if queued, control will return
	RSB				; here.  Return to caller.

	.SBTTL	TTY$WRTSTARTIO - Starts or queues a write operation

;++
;
; Functional description:
;
;	If called from an FDT routine (or from EXE$BRDCST),
;	TTY$WRTSTARTIO first raises to device IPL, and then calls the
;	internal routine. All other code enters through the WRTSTARTIO
;	entry point.
;
;	If a write is occurring, the routine queues the write buffer.
;	If a read is occurring, but the buffer header specifies
;		write-breakthrough, the routine starts the write.
;	If a read is occurring, but no characters have been received
;		yet, the routine starts the write.
;	Otherwise, the routine queues the write buffer.
;
;	To start the write operation, the routine writes the address
;	of the buffer in UCB$L_TT_WRTBUF, sets and clears various
;	state bits, and returns.
;
;	To queue the buffer, the routine inserts the buffer address at
;	the end of the queue unless the header specfies write-
;	breakthrough. In the latter case, the buffer address is inserted
;	after the last write-breakthrough request in the queue.
;
;	Returning from WRTSTARTIO is odd. The routine assumes that 0(SP)
;	is the address to return to if the write is to start now.
;	If the routine instead queues the write, the routine pops this
;	start-write address of the stack, and returns to the real
;	caller.
;
; Inputs:
;
;	R3	- address of the write buffer
;	R5	- address of the UCB
;
; Implicit inputs:
;
;	The write buffer consists of a header, and an optional message
;	buffer. For broadcast messages, the message buffer is absent.
;	TTY$L_WB_FR3 is 0 for a normal broadcast and 1 for and ANSI
;	broadcast or one that specified norefresh.
;
; Outputs:
;
;	If the broadcast message is rejected, the TTY$L_WB_END field
;	of the write packet is zeroed.
;
;	R0	- preserved
;	R1	- scratch
;	R2	- address of UCB state bits
;	R3	- address of buffer
;	R4	- if packet is started, address of IRP or 0
;		- if packet is queued, scratch
;	R5	- address of UCB
;
; Implicit outputs:
;
;	Buffer may be entered in queue.
;
;	If write operation is started,
;	UCB$L_TT_WRTBUF	- address of buffer
;	UCB$Q_TT_STATE	- write bit, and other bits from IRP are set
;			  control-O may be canceled
;	UCB$L_DEVDEPEND	- mailbox may be enabled
;
;--

TTY$WRTSTARTIO::			; Start or queue write.
	MOVL	UCB$L_TL_PHYUCB(R5),R1	; GET PUCB ADDRESS
	BEQL	30$			; NONE CURRENTLY EXISTS
	MOVL	R1,R5			; SWITCH TO PUCB CONTEXT
	TSTL	TTY$L_WB_IRP(R3)	; Is this a broadcast?
	BEQL	20$			; YES, SPECIAL CASE
10$:					; Acceptable packet.
	BSBW	TTY$LOCK		; Raise to DIPL, get states.
	PUSHAB	TTY$STARTOUTPUT		; Set up return address to
					; start the output.
	BSBB	WRTSTARTIO		; Start or queue the packet.
	RSB				; If packet queued, control
					; returns here, so return to
					; caller.
;	INTERNAL BROADCAST PACKET.
;	CHECK FOR DISABLE
20$:
	BITL	#TT$M_PASSALL!-		; Test for passall and/or
		TT$M_NOBRDCST,-		; nobroadcast modes set in the
		UCB$L_DEVDEPEND(R5)	; term's UCB (ignore NOECHO).
	BEQL	10$			; Continue if not set.
25$:	CLRL	TTY$L_WB_END(R3)	; Zero end address to indicate
					; failure to EXE$BRDCST.
	RSB				; And return to EXE$BRDCST.

;	LUCB CURRENTLY DETACHED
;	COMPLETE THE WRITE
	ASSUME IRP$L_IOST1+4 EQ IRP$L_IOST2
30$:
	MOVL	TTY$L_WB_IRP(R3),R1	; GET IRP ADDRESS
	BEQL	25$			; INTERNAL BROADCAST, REJECT IT.
	MOVL	R1,R3			; GET IRP ADDRESS 
	CLRQ	IRP$L_IOST1(R3)		; INIT IOSB RETURN
	MOVW	#SS$_NORMAL,IRP$L_IOST1(R3)
	JMP	G^COM$POST



WRTSTARTIO:				; Checks for start or queue.

;
; Inputs:
;
;	R2	- address of state bits longword
;	R3	- address of write packet
;	R5	- address of the device's UCB
;
;	0(SP)	- address to return if write is queued
;	4(SP)	- address to return to if write is started
;

	PUSHR	#^M<R0>			; Save a register.
	MOVAB	UCB$L_TT_WFLINK(R5),R0	; Get address of write queue.
	MOVL	TTY$L_WB_IRP(R3),R4	; Get address of IRP.
	IF_STATE -			; If writing is in progress,
		WRITE,QUEUE_PKT		; just queue the packet.
	TSTL	R4			; See if the packet has an IRP.
	BEQL	START_PKT		; If not, just start the packet.
	IF_NOT_STATE -			; If not in a read state,
		READ,START_PKT		; go ahead and start the packet.
	IF_STATE -			; If noecho read, no blocking
		NOECHO,START_PKT	; so start the write
	BBS	#IO$V_BREAKTHRU,-
		IRP$W_FUNC(R4),START_PKT; Start if break thru write.
	MOVL	UCB$L_SVAPTE(R5),R1	; get the read packet address
	TSTW	TTY$W_RB_TXTOFF(R1)	; and check if we have started typing
	BEQL	START_PKT		; go start the packet.
	BRB	QUEUE_LAST		; Otherwise, queue packet at end
					; of queue.

QUEUE_PKT:
	TSTL	R4			; If an IRP is associated,
	BNEQ	QUEUE_LAST		; queue packet at end of queue.
	MOVL	R0,R4			; Make a copy of queue head.

10$:
	MOVL	TTY$L_WB_FLINK(R4),R1	; Get first queue entry.
	CMPL	R1,R0			; See if at end of queue.
	BEQL	QUEUE_LAST		; If yes, put at end of queue.
	TSTL	TTY$L_WB_IRP(R1)	; Else, see if this entry has an
					; associated IRP.
	BNEQ	INSERT_PKT		; If yes, branch to insert
					; packet before it.
	MOVL	R1,R4			; Otherwise, go on to next
	BRB	10$			; entry in queue.

QUEUE_LAST:				; Queue at end of queue.
	MOVL	TTY$L_WB_BLINK(R0),R4	; Get back pointer.

INSERT_PKT:
	INSQUE	TTY$L_WB_FLINK(R3),-	; Insert new packet in the
		TTY$L_WB_FLINK(R4)	; queue.
	POPR	#^M<R0>			; Remove saved register and
	MOVL	(SP),R1			; get queued address
	ADDL	#8,SP			; clean stack
	JMP	(R1)			; return to queued address

START_PKT:				; Start the packet.
	MOVL	R3,UCB$L_TT_WRTBUF(R5)	; Point to packet from UCB.
	SET_STATE -			; Set the write state.
		WRITE
	TSTL	R4			; If this write does not have an
	BEQL	20$			; IRP, don't check IRP fields.
	BISL	IRP$Q_TT_STATE(R4),(R2)	; Set write state bits.
	BISL	IRP$Q_TT_STATE+4(R4),4(R2)	; Set write state bits.
	CLRL	IRP$L_MEDIA(R4)		; Set up IRP for completion.
	BBC	#IO$V_ENABLMBX,-	; Branch if enable-mailbox
		IRP$W_FUNC(R4),10$	; is not requested.

	MOVL	UCB$L_TT_LOGUCB(R5),R1	; GET LOGICAL UCB ADDRESS
	BICL	#TT$M_MBXDSABL,UCB$L_DEVDEPEND(R5) ; CLEAR MAILBOX DISABLED PHYSICAL
	BICL	#TT$M_MBXDSABL,UCB$L_DEVDEPEND(R1) ; CLEAR MAILBOX DISABLED LOGICAL

10$:
	BBC	#IO$V_CANCTRLO,-	; Branch if cancel control-O
		IRP$W_FUNC(R4),30$	; is not requested.
	CLR_STATE -			; Clear control-O state.
		CTRLO
	BRB	30$			; And start the output.

;
; Start a broadcast packet.
;

20$:
	CLRB	TTY$B_WB_FIPL(R3)	; Indicate block free to fork (for DMA)
	BLBC	TTY$L_WB_FR3(R3),30$	; Branch if ANSI broadcast or norefresh
	SET_STATE -
		<REFRSH>		; Set refresh read
30$:					; Go output buffer.
	POPR	#^M<R0,R1>		; Restore saved register 
					; and queued address.
	RSB				; And return to caller.

	.SBTTL	TTY$STARTOUTPUT - START OUTPUT OPERATION ON UNIT

;++
; TTY$STARTOUTPUT - START OUTPUT ON UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO INITIATE OUTPUT ON A UNIT. THIS OPERATION STARTS
; THE FLOW OF DATA EVEN IN THE CASE OF READS. THE ACTION IS TO TEST THE
; STATE OF INTERRUPT EXPECTED. IF AN INTERRUPT IS EXPECTED, THEN NOTHING NEED BE DONE
; BECAUSE A SUBSEQUENT INTERRUPT WILL CONTINUE APPROP. WITH THE CURRENT STATE.
; IF NO INTERRUPT IS EXPECTED, THEN THE TTY$GETNEXTCHAR ROUTINE IS ENTERED TO RETURN
; THE NEXT CHARACTER(S) FOR THE UNIT. THEN IF AVAILABLE THE PORT DRIVER
; STARTIO ROUTINE IS ENTERED. 
; THIS OPERATION IS IDENTICAL TO THE OPERATION OF AN OUTPUT READY INTERRUPT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	NONE
;--
TTY$STARTOUTPUT::			; START OUTPUT
	BBS	#UCB$V_INT,UCB$W_STS(R5),100$; LEAVE HERE IF INTERRUPT EXPECTED
	MOVL	UCB$L_TT_PORT(R5),R0	; GET THE PORT'S VECTOR TABLE ADDRESS
	BSBW	TTY$GETNEXTCHAR		; GET NEXT CHARACTER FOR UNIT
	BLBC	UCB$B_TT_OUTYPE(R5),100$; LEAVE IF NOTHING TO OUTPUT
	JMP	@PORT_STARTIO(R0)	; START OUTPUT ON LINE
100$:	RSB				; RETURN

	.SBTTL	TTY$GETNXTWRITE - Start next write or restart read

;++
;
; Functional description:
;
;	This routine gains control at device IPL on return from the
;	VMS fork queuing routine. The routine tries to restart a
;	suspended but now active read, or to dequeue and start the
;	next write request vis WRTSTARTIO.
;
;	The routine always returns to the caller of TTY$WRITEDONE,
;	TTY$READONE, or BRDCST in TTYCHARO. This caller is usually
;	GETNEXTCHAR, so setting states causes the driver to go on
;	echoing and outputting.
;
; Inputs:
;
;	0(SP)	- address of the UCB state vector
;	4(SP)	- address of the UCB
;
; Outputs:
;
;	R2	- address of the UCB state vector
;	R3	- address of a write buffer if writing is to begin
;	R5	- address of the UCB
;
;	The 2 named inputs are removed from the stack.
;
;--

TTY$GETNXTWRITE::			; Check for a new write.
	POPR	#^M<R2,R5>		; Restore UCB state address and
					; UCB address.
	IF_NOT_STATE -			; If not in a read state, just
		READ,10$		; branch forward.
	IF_STATE -			; If noecho, don't block writes
		NOECHO,10$
	CMPL	UCB$L_TT_WFLINK(R5),-
		UCB$L_TT_WBLINK(R5)	; queue empty?
	BEQL	5$			; Branch if yes
	MOVL	UCB$L_TT_WFLINK(R5),R3	; Fetch address of next irp
	BBS	#IO$V_BREAKTHRU,-
		IRP$W_FUNC(R3),10$	; Start if break thru write.
5$:	MOVL	UCB$L_SVAPTE(R5),R3	; get the read packet address
	TSTW	TTY$W_RB_TXTOFF(R3)	; see if any input
					; has been received.
	BNEQ	20$			; If yes, go restart read.

10$:	IF_STATE WRITE,30$		; if we are writing then don't get the
					; next write
					; Otherwise, look for a write.
	REMQUE	@UCB$L_TT_WFLINK(R5),R3	; Get a new write buffer.
	BVS	20$			; Branch if no buffers exist.
	PUSHAB	30$			; Save a write start return
					; address.
	BSBW	WRTSTARTIO		; Start the write.
	RSB				; Return to GETNEXTCHAR.

20$:
	BSBW	TTY$RESTARTIO		; Restart the read, if any.

30$:					; Joint read/write return.
	RSB				; Return.

	.SBTTL	TTY$WRITEDONE - Complete a write operation

;++
; TTY$WRITEDONE - WRITE OPERATION DONE
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine creates a fork process to complete the write, and
;	checks for another write packet to start up.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
;	TTY$W_WB_STATUS	- status of operation
;	TTY$W_WB_BCNT	- number of bytes transferred
;
; OUTPUTS:
;
;	R2,R5 ARE PRESERVED.

;--

TTY$WRITEDONE::				; Complete write operation.

;
; This routine used to start by clearing a whole raft of state bits.
; I only turn off write-related bits, and I do that in TTY$GETNXTWRITE.
; The bits I no longer modify are:
;
;	READ, DEL, XON, EOL, PROMPT, CTRLR, NOFLTR, ESC, ESC_O, and
;	BADESC
;


	PUSHR	#^M<R2,R5>		; Save state and UCB address.
14$:

	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write buffer.

;
; NEW LINE MODIFIER
;
	MOVL	TTY$L_WB_IRP(R3),R4	; Get address of associated IRP.
	BEQL	10$
	BBC	#IO$V_NEWLINE,IRP$W_FUNC(R4),10$; NO NEWLINE THEN DON'T ADD A THING
	SET_STATE <SENDLF,SKIPLF,NL>
10$:
	CLR_STATE -			; Clear the write bits.
		<WRITE,WRTALL>
	PUSHAB	TTY$GETNXTWRITE		; Return address after queuing fork

WRITEPOST:

	MOVB	UCB$B_FIPL(R5),-	; Set up fork IPL in the buffer
		TTY$B_WB_FIPL(R3)	; block.
	MOVL	TTY$L_WB_IRP(R3),R4	; Get address of associated IRP.
	BNEQ	5$			; one there then continue
	MOVB	#IPL$_QUEUEAST,-	; for broadcast fork to ipl6
		TTY$B_WB_FIPL(R3)	
	clrl	-(sp)			; no irp then no process to fork to
	brb	7$
5$:
	PUSHL	IRP$L_PID(R4)		; FORK ON THE PID OF THE IO OWNER
7$:	MOVL	R3,R5			; Setup fork block address.
	JSB	TTY$SYNCH		; Create a fork process.

;
; This is the write completion fork process. Registers are as follows:
;
;	R4	- address of IRP
;	R5	- address of write buffer (TWP)
;

	MOVL	R4,R3			; Need IRP in R3 for I/O post.
	BEQL	100$

	.IF DF	CA$_MEASURE_IOT
;
;ACCUMULATE STATISTICS ON NUMBER OF CHARACTERS AND I/OS TO TERMINALS.
;
	BSBB	TTSTATS			; CALL STATISTICS ROUTINE.

	.ENDC

;
; NOTE: IRP$L_MEDIA = IRP$L_IOST1
; NOTE: terminal position is 0-based; interface position is 1-based
;

	MOVL	R5,R4			; Put buffer address in R4.
	MOVZWL	IRP$L_MEDIA(R3),-	; number of lines output for the
		IRP$L_IOST2(R3)		; write QIO, and zero other values
	MOVL	TTY$W_WB_STATUS(R4),-	; move status and count of bytes
		IRP$L_IOST1(R3)		; transferred into IOSB

	MOVL	IRP$L_UCB(R3),R5	; Regain LUCB address.
	MOVL	UCB$L_TL_PHYUCB(R5),R5	; Switch to Physical context
	BEQL	15$			; Disconnect has occured!
	CMPW	UCB$W_TT_CURSOR(R5),-	; Is cursor marker beyond the right-
		UCB$W_DEVBUFSIZ(R5)	; hand edge of screen?
	BGEQU	12$			; Branch if cursor has gone too far.
	ADDW3	UCB$W_TT_CURSOR(R5),-	; Else return cursor column position, 
		#1,IRP$L_IOST2+2(R3)	; adjusted for zero offset, in IOSB.
	BRB	14$			; Continue building IOSB.
12$:	MOVW	UCB$W_DEVBUFSIZ(R5),-	; If necessary, return cursor column
		IRP$L_IOST2+2(R3)	; position in IOSB as right-hand edge.
14$:	ADDB3	UCB$B_TT_LINE(R5),-	; move line position into IOSB
		#1,IRP$L_IOST2+3(R3)	;

15$:	MOVW	TTY$W_WB_SIZE(R4),-	; Move size of buffer into IRP
		IRP$W_BOFF(R3)		; to record quota used.
	MOVL	IRP$L_UCB(R3),R5	; Restore logical UCB address
	CMPL	R3,UCB$L_IRP(R5)	; Is this the current write 
	BEQL	30$			; blocking the i/o queue?

20$:	JMP	G^COM$POST		; Full duplex: complete write

30$:					; Half duplex:
	MOVQ	IRP$L_MEDIA(R3),R0	; Load IOST1 and IOST2 in R0,R1
	REQCOM				; Complete request and get next
					; entry in system queue.
100$:
	MOVL	TTY$L_WB_END(R5),R3	; GET THE ADDRESS OF THE LAST CHARACTER
	JMP	@TTY$L_WB_RETADDR(R5)	; Want fork process to gain control
					; string for fork process use.



	.SBTTL	TTY$WRITEPOST - QUEUE A WRITE COMPLETION

;++
; TTY$WRITEPOST - QUEUE A WRITE COMPLETION
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE FORKS ON A TWP TO COMPLETE A QUEUED WRITE OPERATION
;	BOTH HALF AND FULL DUPLEX.
;
; INPUTS:
;
;	R4 = TWP ADDRESS
;	R5 = UCB ADDRESS
;
;	UCB$W_BOFF - STATUS OF OPERATION
;
; OUTPUTS:
;
;	R0,R1,R2,R3,R5 ARE PRESERVED
;--

TTY$WRITEPOST::

	PUSHR	#^M<R3,R5>		; SAVE REGISTERS
	MOVL	R4,R3			; TWP ADDRESS
	CLRW	TTY$W_WB_BCNT(R3)	; NONE TRANSFERED
	MOVW	UCB$W_BOFF(R5),-	; SAVE COMPLETION STATUS
		TTY$W_WB_STATUS(R3)
	BSBW	WRITEPOST		; QUE THE FORK
	POPR	#^M<R3,R5>
	RSB




	.IF DF	CA$_MEASURE_IOT
;
;	Subroutine to accumulate statistics on the number of
;	the number of characters read and written to terminals
;
TTSTATS:BLBC	G^PMS$GL_DOSTATS,40$	; IF FLAG SET, BYPASS STATISTICS CODE
	MOVZWL	IRP$W_BCNT(R3),R1	; GET # CHARACTERS TRANSFERRED.
	DIVL3	#5,R1,R0		; STATISTICS ARE KEPT IN INCREMENTS
					;      OF 5 CHARACTERS.
	CMPL	#9,R0			; LAST ENTRY IN TABLE IS FOR I/OS
					;     OF >= 45 CHARACTERS.
	BGEQ	10$
	MOVL	#9,R0
10$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#TTY$C_FC_READ
					; CHECK IF JUST FINISHED A READ OR WRITE.
	BNEQ	20$			; BRANCH FOR WRITE
;
; COMPILE STATISTICS FOR READ
;
	INCL	G^PMS$AL_READTBL[R0]	; INCREMENT APPROPRIATE RANGE.
	INCL	G^PMS$GL_TREADS		; INCREMENT READ COUNT
	ADDL2	R1,G^PMS$GL_READCNT	; INCREMENT TOTAL COUNT FOR CHARACTERS
	BRB	40$
;
; COMPILE STATISTICS FOR WRITE
;
20$:	INCL	G^PMS$AL_WRITETBL[R0]	; INCREMENT APPROPRIATE RANGE.
	INCL	G^PMS$GL_TWRITES	; INCREMENT WRITE COUNT
	ADDL2	R1,G^PMS$GL_WRTCNT	; INCREMENT TOTAL COUNT FOR CHARACTERS
					;      WRITTEN.
40$:	RSB				; RETURN TO CALLER.

	.ENDC

	.SBTTL	TTY$READONE - READ OPERATION DONE
;++
; TTY$READONE - READ I/O OPERATION DONE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO COMPLETE THE CURRENT READ OPERATION.
; THE ACTION IS TO RESET THE STATE OF THE UNIT TO REFLECT THE CHANGE AND TO
; FORK ON THE IRP TO COMPLETE THE PROCESSING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
;		UCB$W_BOFF = STATUS WORD
;		UCB$W_BCNT = COUNT OF TRANSFER
;
;	IRP$L_MEDIA(CURRENT PACKET) = TERMINATOR AND TERMINATOR SIZE
;
; OUTPUTS:
;
;
;	NONE
;--
.enable lsb
TTY$READONE::				; READ I/O DONE
	BBC	#TT$V_READSYNC,UCB$L_DEVDEPEND(R5),10$; BR IF NOT READSYNC
	BSBW	TTY$XOFF		; SEND XOFF
10$:	BICW	#UCB$M_TT_TIMO,UCB$W_DEVSTS(R5); CLEAR TIMEOUT ENABLED
;
; SET UP ERRORS ON ESCAPE SEQUENCES
;
	IF_NOT_STATE ESC,15$		; IF NOT ESCAPE THEN BR
	MOVW	#SS$_PARTESCAPE,UCB$W_BOFF(R5); ASSUME PARTIAL ESCAPE SEQUENCE
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE ADDRESS OF THE READ PACKET
	MOVL	UCB$L_IRP(R5),R3	; ADDRESS CURRENT PACKET
	MOVZBW	IRP$L_MEDIA+2(R3),R3	; MAKE THE ESCAPE SEQUENCE COUNT A WORD
	SUBW	R3,TTY$W_RB_TXTOFF(R4)	; SUBTRACT OUT TERMINATOR LENGTH
15$:	IF_NOT_STATE BADESC,20$		; ESCAPE SYNTAX CORRECT?
	MOVW	#SS$_BADESCAPE,UCB$W_BOFF(R5); SET STATUS FOR IMPROPER ESCAPE SEQ
;
; RESET PASSALL AND NOECHO IF MODES
;
20$:

	.IF DF	CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,25$	; IF FLAG SET, BYPASS STATISTICS CODE
	BBC	#TT$V_PASSALL,UCB$L_DEVDEPEND(R5),25$; BR IF NOT PASSALL
	INCL	G^PMS$GL_PASSALL	; INCREMENT PASSALL COUNT

	.ENDC

25$:	BICB3	#^C<TT$M_PASSALL!TT$M_NOECHO>,UCB$L_DEVDEPEND(R5),R4;
	INSV	R4,#TTY$V_ST_PASALL,#2,4(R2)		; RESET PASSALL AND NOECHO
	EXTV	#TT$V_ESCAPE,#1,UCB$L_DEVDEPEND(R5),R4	; GET CURRENT SETTING
	INSV	R4,#TTY$V_ST_ESCAPE,#1,4(R2)		; UPDATE IN STATE
	BBC	#TT2$V_PASTHRU,UCB$L_DEVDEPND2(R5),98$	; IN PASS THRU MODE
	SET_STATE PASALL
98$:

	CLR_STATE -			; Clear state bits relevant to
		<READ,DEL,EOL,-		; a read (this does not include
		PROMPT,CTRLR,NOFLTR,-	; the write bits).
		ESC,ESC_O,BADESC,PRE,TERMNORM,-
		REFRSH,EDITREAD,SKIPCRLF,RDVERIFY,ECHAES,-
		MULTI,RECALL,OVERSTRIKE,EDITING,QUOTING,BACKSPACE>
	MOVL	UCB$L_IRP(R5),R3	; ADDRESS CURRENT PACKET
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE ADDRESS OF THE READ PACKET
	MOVB	TTY$W_RB_CPZORG(R4),UCB$B_TT_OLDCPZORG(R5); SAVE BECAUSE
					; WE MAY CONTINUE THIS READ
	MOVL	IRP$L_PID(R3),IRP$L_TT_TERM(R3); SAVE DATA FOR FORK BLOCK
	MOVB	IRP$B_RMOD(R3),IRP$W_TT_PRMPT(R3);
	MOVB	UCB$B_FIPL(R5),IRP$B_RMOD(R3); SET FORK IPL
	MOVW	UCB$W_BOFF(R5),IRP$W_BOFF(R3); SAVE STATUS
	MOVW	TTY$W_RB_TXTOFF(R4),IRP$W_BCNT(R3); SAVE TRANSFER SIZE 
	PUSHR	#^M<R2,R5>		;
	MOVL	R3,R5			; SET UP FORK BLOCK ADDRESS
	MOVQ	IRP$L_AST(R3),R3	; GET PARAMS FOR FORK
	PUSHAB	W^TTY$GETNXTWRITE	; FORCE RETURN TO RESTORE UCB ADDRESS
	PUSHL	IRP$L_TT_TERM(R5)	; USE THE PID OF THE ISSUING PROCESS
	JSB	TTY$SYNCH		; CREATE FORK PROCESS
;
; I/O DONE FORK PROCESS
;
	MOVL	R5,R3			; RESTORE PACKET AND UCB ADDRESSES

	.IF DF	CA$_MEASURE_IOT
;
;ACCUMULATE STATISTICS ON NUMBER OF CHARACTERS AND I/OS TO TERMINALS.
;
	BSBW	TTSTATS			; CALL STATISTICS ROUTINE.

	.ENDC

	MOVL	IRP$L_UCB(R3),R5	; GET LUCB ADDRESS FROM IRP
	MOVL	UCB$L_TL_PHYUCB(R5),R5	; SWITCH TO PHYSICAL USB CONTEXT
	MOVL	IRP$W_BOFF(R3),R0	; GET STATUS AND TRANSFER SIZE
	MOVZBW	IRP$L_MEDIA+2(R3),R4	; GET THE BYTE COUNT OF THE TERMINATOR
	ADDW	R4,IRP$W_BCNT(R3)	; CALC TOTAL TRANSFER SIZE
	MOVL	IRP$L_SVAPTE(R3),R4	; GET ADDRESS OF THE BUFFER BLOCK
	BBC	#IO$V_EXTEND,IRP$W_FUNC(R3),27$
	MOVB	#^X0FF,IRP$L_MEDIA+1(R3); INFORCE RESERVED FIELD
	BBS	#TTY$V_ST_RDVERIFY,IRP$Q_TT_STATE(R3),27$; DON'T DO IT FOR READ VERIFY
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; get the offset to this character
	ADDL	R1,TTY$L_RB_LIN(R4)	; ADD IN THE OFFSET TO GET AN ADDRESS
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE LENGTH OF THE READ
	ADDL	TTY$L_RB_TXT(R4),R1	; AND GET THE ADDRESS OF THE LAST CHARACTER
	SUBL	TTY$L_RB_LIN(R4),R1	; SUBTRACT OUT THE ADDRESS OF THE
	MOVB	R1,IRP$L_MEDIA+3(R3)	; LAST CHARACTER AND THIS IS THE
					; OFFSET FROM THE END OF THE READ
					; TO THE LAST POSITION.
27$:	MOVL	IRP$L_MEDIA(R3),R1	; SET TERMINATOR DATA
	MOVL	IRP$L_TT_TERM(R3),IRP$L_PID(R3); RETURN IRP DATA
	MOVB	IRP$W_TT_PRMPT(R3),IRP$B_RMOD(R3);
	MOVW	TTY$W_RB_SIZE(R4),IRP$W_BOFF(R3); MAKE IT QUOTA
	BBS	#TT2$V_EDITING,UCB$L_DEVDEPND2(R5),40$; IF EDITING THEN
					; SAVE THE BUFFER.
READ$DONE:
	BBS	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),200$; DO WE HAVE TO CHECK
END_FALL: 				; FOR INPUT FALLBACK 

TTY$DONE:
	MOVL	IRP$L_UCB(R3),R5	; RESTORE LOGICAL UCB ADDRESS
	REQCOM				; COMPLETE REQUEST
;
; SAVE THE COMMAND IF WE ARE IN EDITING, THE READ WAS SUCESSFUL AND
; IT WAS NOT A NOECHO READ.
;
40$:	CMPW	R0,#SS$_TIMEOUT		; ALLOW TIMEOUT ERRORS TO BE SAVED
	BEQL	42$			; ...
	BLBC	R0,READ$DONE		; READ NOT SUCCESSFUL THEN DON'T SAVE
42$:	BITL	#TT$M_NOECHO!TT$M_PASSALL,UCB$L_DEVDEPEND(R5);DON'T COPY ON
	BNEQ	READ$DONE		; PASSALL OR NOECHO
	BITL	#TTY$M_ST_NOECHO!TTY$M_ST_PASALL!TTY$M_ST_NOFLTR,-
		IRP$Q_TT_STATE+4(R3)	; WERE WE PASS ALL, NOECHO
	BNEQ	READ$DONE		; OR NO FILTER THEN DON'T SAVE THIS BUFFER
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE THE REGISTERS OVER THE MOVE
	MOVZWL	TTY$W_RB_TXTOFF(R4),R0	; GET THE LENGTH
	BEQL	35$			; IF THE LENGTH IS ZERO THEN DON'T SAVE
					; THE DATA
	CMPL	#TTY$K_TA_RCLLEN,R0	; DOES ALL THE DATA FIT?
	BGEQ	30$			; YES THEN CONTINUE ON
	MOVL	#TTY$K_TA_RCLLEN,R0	; ELSE USE THE WHOLE BFFER
30$:	MOVL	UCB$L_TT_TYPAHD(R5),R1	; GET THE ADDRESS OF THE TYPEAHEAD BUFFER
	MOVW	R0,TTY$W_TA_RCLSIZ(R1)	; KEEP THE SIZE CORRECTLY
	MOVC3	R0,@TTY$L_RB_TXT(R4),TTY$A_TA_RCL(R1); MOVE THE DATA IN
35$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE THE REGISTERS AND
91$:	BRB	READ$DONE

;
; INPUT FALLBACK TABLE IMPLIMENTATION
;
200$:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE THE REGISTERS OVER THE MOVE
	MOVL	@TTY$A_INPFALL,R1	; ANY INPUT FALLBACK
	BEQL	210$
	MOVZWL	TTY$W_RB_TXTOFF(R4),R0	; GET THE LENGTH
	BEQL	210$			; IF THE LENGTH IS ZERO THEN DON'T SAVE
	MOVTC	R0,@TTY$L_RB_TXT(R4),#0,(R1),-
		R0,@TTY$L_RB_TXT(R4)	; MOVE THE DATA THRU THE FALLBACK TABLE
210$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE THE REGISTERS AND
220$:	BRW	END_FALL
.Disable lsb


	.SBTTL	End of module

	.END
