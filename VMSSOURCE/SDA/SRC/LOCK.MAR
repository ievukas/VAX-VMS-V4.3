	.TITLE	LOCK LOCK AND RESOURCE FORMATTING ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	ROUTINES TO FORMAT LOCK AND RESOURCE INFORMATION
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	MARYANN HINDEN, JUNE 1982
;
;   MODIFIED BY
;
;	V03-007	SRB0109		Steve Beckhardt		2-Feb-1984
;		Fixed formatting of Directory entry text in SHO RES line.
;
;	V03-006	SRB0107		Steve Beckhardt		7-Dec-1983
;		Enhanced SHOW LOCK and SHOW RESOURCE to display
;		distributed lock information.
;
;	V03-005	SRB0089		Steve Beckhardt		27-May-1983
;		Fixed bug displaying resource name.  Added new status bit
;		definitions.
;
;	V03-004	SRB0071		Steve Beckhardt		16-Mar-1983
;		Changed the way system resources are decoded in RSB
;		to use zero group number instead of SYSNAM flag.
;
;	V03-003 MSH0003		Maryann Hinden		17-Dec-1982
;		Fix broken assume's.
;
;	V03-002	MSH0002		Maryann Hinden		22-Oct-1982
;		Determine empty lock queue correctly in SHOW_PROC_LOCK.
;		Change lock display - output lock and parent id in hex;
;		rearrange format.
;
;	V03-001	MSH0001		Maryann Hinden		16-Jul-1982
;		Correct references to LCK$xxxx data structures; change
;		condition handling.
;--

	.SBTTL	DECLARATIONS
;
;	SYSTEM SYMBOL DEFINTIONS
;

	$CHFDEF
	$LCKDEF
	$LKBDEF
	$OPTDEF
	$PCBDEF
	$RSBDEF
	$STSDEF

;
;	LOCAL SYMBOL DEFINITIONS
;

GRANT    = -1		; SYMBOLIC DESIGNATIONS FOR QUEUE TYPES
CONVERT  = 0
WAIT     = 1

LKID_OFF = LKB$L_LKID-LKB$L_LKID	; OFFSETS INTO SAVED QUEUE DATA
GRMD_OFF = LKB$B_GRMODE-LKB$L_LKID
RQMD_OFF = LKB$B_RQMODE-LKB$L_LKID


	.SBTTL	STORAGE DEFINITIONS
	.PSECT	SDADATA,NOEXE,WRT,LONG
;
;	Data area for SHOW LOCKS commands
;

LOCK_COUNT:				; count of locks processed
	.LONG	0
PARID_BFR:				; parent lock id
	.LONG	0
LKB_BFR:				; lock block data
	.BLKB	LKB$K_LENGTH

RSBCSID_BFR:				; CSID in RSB
	.BLKL	1
LKB_RSB_BFR:				; resource block data for given lock
GROUP_BFR:				;	group number
	.BLKW	1
RMOD_BFR:				;	access mode
	.BLKB	1
RSNLEN_BFR:				;	resource name length
	.BLKB	1
RESNAM_BFR:				;	resource name
	.BLKB	RSB$K_MAXLEN+1

LOCKID::				; lock ID currently being processed
	.BLKL	1

	.ALIGN	LONG

FAO_RMINFO_DSC:
	.ASCID	"of lock !XL on system !XL"

	.ALIGN	LONG
RMINFO_LEN:
	.LONG	0
RMINFO_DSC:
	.LONG	80
	.ADDRESS	RMINFO_BFR

RMINFO_CNT:
	.BLKB	1
RMINFO_BFR:
	.BLKB	80

;
;	Data area for SHOW RESOURCES commands
;

RES_COUNT:				; count of resources processed
	.LONG	0
QUEUE_COUNT:				; count of queue elements processed
	.LONG	0
RSB_BFR:				; resource block data
	.BLKB	RSB$K_MAXLEN+RSB$K_LENGTH
HTBL_INDX:				; current index into hash table
	.BLKL	1
HTBL_CNT:				; size of hash table
	.BLKL	1
COUNT:					; # queue items to display
	.BLKL	1
QUEUE_TYPE:				; type of queue being processed
	.BLKL	1
GRMD_BFR:				; grant mode
	.BLKB	3
RQMD_BFR:				; requested mode
	.BLKB	3
LKID_BFR:				; lock id
	.BLKL	3
FAO_GROUP_DSC:
	.ASCID	"!3OW"

GROUP_BUF:
	.BLKB	3

	.ALIGN	LONG
GROUP_BUF_DSC:
	.LONG	3
	.ADDRESS	GROUP_BUF

SYS_DSC:
	.ASCID	"System"

	.ALIGN	LONG
GROUP_DSC:
	.LONG	11
	.ADDRESS	GROUP_TXT

GROUP_TXT:
	.ASCII	"Group   "
GROUP_NUM:
	.BLKB	3

;
;	FAO data storage for RESOURCE display
;	

;  line 1

RSB:	.LONG	0		; Address of RSB
GGMOD:	.LONG	0		; Group grant mode (addr of ASCIC string)

;  line 2

PRSB:	.LONG	0		; Address of parent RSB
CGMOD:	.LONG	0		; Conversion grant mode (addr of ASCIC string)

;  line 3

SRSBCT: .LONG	0		; Sub-RSB reference count	
BAST:	.LONG	0		; Blocking AST count

;  line 4

VAL4:	.LONG	0		; Value block longword #4
VAL3:	.LONG	0		; Value block longword #3
VAL2:	.LONG	0		; Value block longword #2
VAL1:	.LONG	0		; Value block longword #1
SEQNUM:	.LONG	0		; Sequence number
VALID:	.LONG	0		; Value block valid (addr. of .ASCIC string)

;  line 5
	
RESN2:	.LONG	0		; Second longword of resource name
RESN1:	.LONG	0		; First	    "	  "     "      "
	.LONG	8		; Count of ASCII string
BUF1:	.LONG	0		; Text of resource name (addr of ASCII string)

;  line 6

RESNLEN:.LONG	0		; Resource name length
RESN4:	.LONG	0		; Fourth longword of resource name
RESN3:	.LONG	0		; Third	     "    "      "     "
	.LONG	8		; Count of ASCII string
BUF2:	.LONG	0		; Text of resource name (addr of ASCII string)
CSID:	.LONG	0		; RSB CSID

;  line 7

RACMOD:	.LONG	0		; Resource access mode (addr of ASCIC string)
RESN6:	.LONG	0		; Sixth longword of resource name
RESN5:	.LONG	0		; Fifth     "    "      "     "
	.LONG	8		; Count of ASCII string
BUF3:	.LONG	0		; Text of resource name (addr of ASCII string)
DIRENTRY:
	.LONG	0		; Directory entry (addr. of .ASCIC string)

;  line 8

RNSPACE: .LONG	0		; Address of descriptor
RESN8:	.LONG	0		; Eighth longword of resource name
RESN7:	.LONG	0		; Seventh    "    "      "     "
	.LONG	8		; Count of ASCII string
BUF4:	.LONG	0		; Text of resource name (addr of ASCII string)


;
;	FAO data storage for LOCKS display
;

;  LINE 1

LKID:	.LONG	0		; Lock id (value)
PID:	.LONG	0		; PID (value)
FLAGS1:	.LONG	0		; First line of flags (addr. of .ASCIC string)
	.LONG	0		;   "     "   "   " 
	.LONG	0		;   "     "   "   "

;  LINE 2

PARID:	.LONG	0		; Parent id (value)
STATE1:	.LONG	0		; Lock state info (address of .ASCIC string)
	.LONG	2		; Lock mode (length of string)
MODE1:	.LONG	0		; Lock mode (address of .ASCII string)
FLAGS2:	.LONG	0		; Second line of flags (addr. of .ASCIC string)
	.LONG	0		;    "     "   "   "
	.LONG	0		;    "     "   "   "

;  LINE 3

SUBLKS:	.LONG	0		; Sublocks (value)
STATE2:	.LONG	0		; More lock state info (addr. of .ASCIC string)
	.LONG	2		; More lock mode (length of string)
MODE2:	.LONG	0		; More lock mode ( addr. of .ASCII string)
FLAGS3:	.LONG	0		; Third line of flags (addr. of .ASCIC string)
	.LONG	0		;   "     "   "   "
	.LONG	0		;   "     "   "   "

;  LINE 3A

BLKAST:	.LONG	0		; Blocking AST (address of .ASCIC string)
LKB:	.LONG	0		; Address of LKB

;  LINE 4

RES2:	.LONG	0		; Second longword of resource name (value)
RES1:	.LONG	0		; First longword of resource name (value)
	.LONG	8
DMP1:	.LONG	0		; First line of text name (.ASCII string)
STS1:	.LONG	0		; 1st line of status (addr. of .ASCIC strings)
	.LONG	0
	.LONG	0

;  LINE 5

RLEN:	.LONG	0		; Resource name length (value)
RES4:	.LONG	0		; Fourth longword of resource name (value)
RES3:	.LONG	0		; Third longword of resource name (value)
	.LONG	8
DMP3:	.LONG	0		; Second line of text name (.ASCII string)
STS2:	.LONG	0		; 2nd line of status (addr. of .ASCIC strings)
	.LONG	0
	.LONG	0

;  LINE 6

ACMODE:	.LONG	0		; Access mode (Address of .ASCIC string)
RES6:	.LONG	0		; Sixth longword of resource name (value)
RES5:	.LONG	0		; Fifth longword of resource name (value)
	.LONG	8
DMP5:	.LONG	0		; Third line of text name (.ASCII string)
STS3:	.LONG	0		; 3rd line of status (addr. of .ASCIC strings)
	.LONG	0
	.LONG	0

;  LINE 7

NSPACE:	.LONG	0		; Name space (group/system) (addr. of desc.)
RES8:	.LONG	0		; Eighth longword of resource name (value)
RES7:	.LONG	0		; Seventh longword of resource name (value)
	.LONG	8
DMP7:	.LONG	0		; Fourth line of text name (.ASCII string)

; LINE 8

TYPE:	.LONG	0		; Lock type (addr. of .ASCIC string)
RMINFO:	.LONG	0		; Remote info (addr. of .ASCIC string)


	.SBTTL	READ-ONLY DATA DEFINITIONS
	.PSECT	LOCK,EXE,NOWRT,LONG

;  HEADERS

LOCK_HEAD:  STRING <Lock database>
RES_HEAD:   STRING <Resource database>

LOCK_STR_TBL:			; table of FAO strings for wait/grant queue display
	.LONG	0
	.LONG	LOCKSTR1
	.LONG	LOCKSTR2
	.LONG	LOCKSTR3

CONV_STR_TBL:			; table of FAO strings for convert queue display
	.LONG	0
	.LONG	CONVSTR1
	.LONG	CONVSTR2
	.LONG	CONVSTR3

QUE_STR_TBL:			; table of headers for queue display
	.LONG	GRANTSTR
	.LONG	CONVSTR
	.LONG	WAITSTR

LOCKSTR1:  .ASCID	#     !XL  !AC#
LOCKSTR2:  .ASCID	#     !XL  !AC       !XL  !AC#
LOCKSTR3:  .ASCID	#     !XL  !AC       !XL  !AC       !XL  !AC#

CONVSTR1:  .ASCID	#     !XL  !AC/!AC#
CONVSTR2:  .ASCID	#     !XL  !AC/!AC    !XL  !AC/!AC#
CONVSTR3:  .ASCID	#     !XL  !AC/!AC    !XL  !AC/!AC    !XL  !AC/!AC#

GRANTSTR:  .ASCID	#Granted queue (Lock ID / Gr mode):#
CONVSTR:   .ASCID	#Conversion queue (Lock ID / Gr/Rq mode):#
WAITSTR:   .ASCID	#Waiting queue (Lock ID / Rq mode):#

;
;	Generic Data
;
LOCKMODE_TBL:
	.ASCII	"NL"
	.ASCII	"CR"
	.ASCII	"CW"
	.ASCII	"PR"
	.ASCII	"PW"
	.ASCII	"EX"

LKMODE_TBL:	.ADDRESS NULL			; POINTERS TO MODE TEXT
		.ADDRESS CREAD			
		.ADDRESS CWRITE
		.ADDRESS PREAD
		.ADDRESS PWRITE
		.ADDRESS EX
NULL:	.ASCIC	/NL/
CREAD:	.ASCIC	/CR/
CWRITE:	.ASCIC	/CW/
PREAD:	.ASCIC	/PR/
PWRITE:	.ASCIC	/PW/
EX:	.ASCIC	/EX/

GR_STRING:
	.ASCIC	"Granted at"
CV_STRING:
	.ASCIC	"Converting to"
WT_STRING:
	.ASCIC	"Waiting for"

BLANKS:	.ASCII	"  "

NULL_CSTRING:
	.ASCIC	""

BL_STRING:
	.ASCIC	"BLKAST"

FLAGS_TBL:
	.ASCIC	"VALBLK "
	.ASCIC	"CONVERT"
	.ASCIC	"NOQUEUE"
	.ASCIC	"SYNCSTS"
	.ASCIC	"SYSTEM "
	.ASCIC	"NOQUOTA"
	.ASCIC	"CVTSYS "
	.ASCIC	"RECOVER"
	.ASCIC	"PROTECT"

STATUS_TBL:
	.ASCIC	"DCPLAST"
	.ASCIC	"DBLKAST"
	.ASCIC	"ASYNC  "
	.ASCIC	"BLASTQD"
	.ASCIC	"MSTCPY "
	.ASCIC	"NOQUOTA"
	.ASCIC	"TIMOUTQ"
	.ASCIC	"WASSYS "
	.ASCIC	"CVTOSYS"

LOCAL:	.ASCIC	"Local"
PROCESS:
	.ASCIC	"Process"
MASTER:	.ASCIC	"Master"

SPACE:	.ASCIC	" "

NOT_VALID:
	.ASCIC	"Not valid"
DIR_ENTRY:
	.ASCIC	"Directory entry"

KMODE:	.ASCIC	"Kernel mode"
EMODE:	.ASCIC	"Exec. mode"
SMODE:	.ASCIC	"Super. mode"
UMODE:	.ASCIC	"User mode"

	.ALIGN	LONG
ACMODE_TBL:
	.ADDRESS	KMODE
	.ADDRESS	EMODE
	.ADDRESS	SMODE
	.ADDRESS	UMODE


	.SBTTL	SHOW_ALL_LOCKS - ACTION ROUTINE TO DISPLAY ALL LOCKS
;+++
;
;	SHOW_ALL_LOCKS
;
;  PURPOSE
;	ACTION ROUTINE FOR THE "SHOW LOCKS/ALL" COMMAND
;
;  INPUT
;	NONE
;
;  OUTPUT
;	DISPLAYED DATA
;
;---
	.ENTRY	SHOW_ALL_LOCKS,^M<>

	MOVAB	LOCK_COND_HAND,(FP)	; ESTABLISH CONDITION HANDLER
	CLRL	LOCKID			; INITIALIZE VARIABLE
	PUSHAB 	LOCK_HEAD		; GET HEADER 
	CALLS	#1,SET_HEADING		; SET IT UP
	CLRL	LOCK_COUNT		; INIT COUNT OF LOCKS PROCESSED

;
;  STEP THROUGH LOCK ID TABLE, DISPLAYING ENTRIES WITH DATA
;
10$:	INCL	LOCKID			; INCREMENT INDEX
	CALLS	#0,GET_LKB		; GET ADDRESS OF ASSOCIATED LKB
	BLBC	R0,10$			; IF LBC, NON-EXISTENT, TRY NEXT
	INCL	LOCK_COUNT		; GOT ONE
	CALLS	#0,SAVE_LOCK_DATA	; GET ASSOCIATED DATA
	CALLS	#0,DISPLAY_LOCK		; DISPLAY DATA FOR THIS LOCKID
	BRB	10$			; LOOP (SIGNAL WILL EXIT FOR US)

	.SBTTL	SHOW_ONE_LOCK - ACTION ROUTINE TO DISPLAY ONE LOCK
;+++
;
;	SHOW_ONE_LOCK
;
;  PURPOSE
;	ACTION ROUTINE TO PROCESS "SHOW LOCK lockid" COMMAND
;
;  INPUT
;	LOCKID - INDEX INTO LOCK ID TABLE
;
;  OUTPUT
;	DISPLAYED DATA
;
;---
	.ENTRY	SHOW_ONE_LOCK,^M<>

	CALLS	#0,GET_LKB			; GET LOCK BLOCK ADDRESS
	BLBC	R0,10$				; IF LBC, NO LOCK BLOCK FOR ID

	CALLS	#0,SAVE_LOCK_DATA		; SAVE LOCK DATA
	PUSHAB	LOCK_HEAD			; SET UP LOCK HEADING
	CALLS	#1,SET_HEADING
	CALLS	#0,DISPLAY_LOCK			; DISPLAY LOCK INFO
	STATUS	SUCCESS				; SUCCESSFUL COMPLETION
	RET

10$:	SIGNAL	0,NOLKB				; NO LOCK BLOCK FOR THIS ID
	RET

	.SBTTL	SHOW_PROC_LOCK - SHOW LOCKS ASSOCIATED WITH A PROCESS
;+++
;
;	SHOW_PROC_LOCK
;
;  PURPOSE
;	SHOW LOCKS ASSOCIATED WITH A GIVEN LOCK.  CALLED FROM
;	GENERIC CODE WHICH DISPLAYS PROCESS DATA.
;
;  INPUT
;	4(AP) - ADDRESS OF PCB COPY IN SDA IMAGE
;	8(AP) - ADDRESS OF "REAL" PCB IN SYSTEM
;
;  OUTPUT
;	DISPLAYED DATA
;---
	.ENTRY	SHOW_PROC_LOCK,^M<R2,R3>

	MOVL	4(AP),R3		; GET ADDRESS OF PCB SAVE AREA
	MOVL	PCB$L_LOCKQFL(R3),R3	; GET FORWARD LINK
	MOVL	@8(AP),R2		; GET "REAL" ADDRESS OF PCB
	MOVAL	PCB$L_LOCKQFL(R2),R2	; GET "REAL" ADDRESS OF HEAD OF QUEUE
	CMPL	R3,R2			; ARE THERE ELEMENTS IN THIS QUEUE?
	BEQL	NOLCK			; IF EQL, NO

GETLCK:	SUBL3	#LKB$L_OWNQFL,R3,LKB	; ADJUST FOR START OF LKB
	CALLS	#0,SAVE_LOCK_DATA	; SAVE LOCK DATA
	SKIP	PAGE			
	PRINT	0,<Lock data:>
	CALLS	#0,FORMAT_LOCK		; FORMAT LOCK DATA
	ENSURE 	9
	SKIP	1
	CALLS	#0,PRINT_LOCK		; DISPLAY LOCK INFO
	REQMEM	(R3),R3			; GET NEXT QUEUE LINK
	CMPL	R3,R2			; AT END OF QUEUE?
	BEQL	DONE			; IF EQL, DONE
	BRB	GETLCK			; LOOP

NOLCK:					; THIS PROCESS HAS NO LOCKS
	SIGNAL	0,NOPRLOCK

DONE:	RET				; SUCCESSFUL

	.SBTTL	GET_LKB - GET LOCK BLOCK
;+++
;
;	GET_LKB
;
;  PURPOSE
;	GIVEN LOCK ID, GET ADDRESS OF LOCK BLOCK.
;
;  INPUT
;	LOCKID - INDEX INTO LOCK ID TABLE
;
;  OUTPUT
;	R0 - IF LBS, LKB CONTAINS ADDRESS OF LOCK BLOCK
;	     IF LBC, NO LOCK BLOCK FOR THIS ID	
;
;---
	.ENTRY	GET_LKB,^M<R2,R3>

;
;  VALIDATE INPUT
;
	MOVZWL	LOCKID,R2		; MOVE TO REGISTER AND TEST
	BEQL	20$			; IF EQL, NOT VALID
	REQMEM	@LCK$GL_MAXID,R3	; GET MAX ID VALUE
	CMPL	R2,R3			; CHECK IT
	BGTRU	30$			; IF GTRU, TOO BIG

;
;  GET ADDRESS OF LOCK BLOCK
;
	REQMEM	@LCK$GL_IDTBL,R3	; GET START OF TABLE
	MOVAL	(R3)[R2],R3		; CALC SLOT ADDRESS
	REQMEM	(R3),R3			; GET LKB ADDRESS
	CLRL	R0			; ASSUME EMPTY SLOT
	MOVL	R3,LKB			; MOVE DATA AND TEST
	BGEQ	10$			; IF GEQ, NO LKB FOR THIS ID
	INCL	R0			; INDICATE SUCCESS

10$:	RET				; DONE

20$: 	SIGNAL	0,LOCKIDZER		; LOCK ID 0
	RET

30$: 	SIGNAL	0,OUTOFRANG		; LOCK ID GREATER THAN MAXID
	RET

	.SBTTL	SAVE_LOCK_DATA - RETRIEVE LOCK DATA FROM SYSTEM
;+++
;
;	SAVE_LOCK_DATA
;
;  PURPOSE
;	GIVEN ADDRESS OF LOCK BLOCK, RETRIEVE ALL DATA NEEDED TO
;	DISPLAY LOCK INFORMATION
;
;  INPUT
;	LKB - ADDRESS OF LOCK BLOCK
;
;  OUTPUT
;	LKB_BFR     - CONTENTS OF LOCK BLOCK
;	PARID_BFR   - ID OF PARENT LOCK
;	LKB_RSB_BFR - DATA FROM ASSOCIATED RESOURCE
;
;---
	.ENTRY	SAVE_LOCK_DATA,^M<R2,R3>

	MOVL	LKB,R2
	REQMEM	(R2),LKB_BFR,#LKB$K_LENGTH	; STORE LKB DATA
	MOVL	LKB_BFR+LKB$L_PARENT,R3		; PARENT LKB ADDR
	BEQL	10$				; IF EQL, NO PARENT
	REQMEM	LKB$L_LKID(R3),R3		; FETCH PARENT LOCK ID

10$:	MOVL	R3,PARID_BFR			; STORE IN BUFFER
	MOVL	LKB_BFR+LKB$L_RSB,R3		; GET ASSOCIATED RSB

	ASSUME	RSB$B_RMOD-RSB$W_GROUP    EQ 2	; MAKE SURE NOTHING CHANGES
	ASSUME	RSB$B_RSNLEN-RSB$W_GROUP  EQ 3
	ASSUME	RSB$T_RESNAM-RSB$W_GROUP  EQ 4
	ASSUME  RSB$K_MAXLEN EQ <^X1F>

	REQMEM	RSB$W_GROUP(R3),LKB_RSB_BFR,-	; STORE RSB DATA
		 #RSB$K_MAXLEN+4 
	REQMEM	RSB$L_CSID(R3),RSBCSID_BFR	; GET CSID IN RSB
	
	RET

	.SBTTL	DISPLAY_LOCK - CONTROL DISPLAY OF LOCK DATA
;+++
;
;	DISPLAY_LOCK
;
;  PURPOSE
;	CONTROLS FORMAT AND DISPLAY OF LOCK DATA
;
;  INPUT
;	LOCK DATA AREAS (IMPLIED)
;
;  OUTPUT
;	DISPLAYED LOCK INFORMATION
;
;---
	.ENTRY  DISPLAY_LOCK,^M<>

	CALLS	#0,FORMAT_LOCK		; FORMAT LOCK DATA
	SKIP	PAGE
	ENSURE	10
	SKIP	1
	CALLS	#0,PRINT_LOCK		; DISPLAY LOCK DATA

	RET

	.SBTTL	FORMAT_LOCK - FORMAT LOCK DATA
;+++
;
;	FORMAT_LOCK
;
;  PURPOSE
;	FORMAT RAW SYSTEM LOCK AND RESOURCE DATA. STORE
;	FOR EASY ACCESS.
;
;  INPUT
;	LKB_BFR - ADDRESS OF LOCK BLOCK DATA
;	PARID_BFR - PARENT LOCK ID
;	LKB_RSB_BFR - ASSOCIATED RESOURCE DATA
;
;  OUTPUT
;	STORED DATA
;
;---

	.ENTRY	FORMAT_LOCK,^M<R2,R3,R4,R5,R6>

	; Lock id., parent id., sublocks and PID

	MOVAB	LKB_BFR,R6	
	MOVL	LKB$L_LKID(R6),LKID
	MOVL	PARID_BFR,PARID
	MOVZWL	LKB$W_REFCNT(R6),SUBLKS
	MOVL	LKB$L_PID(R6),PID

	; Lock state and mode(s)

	TSTB	LKB$B_STATE(R6)
	BLSS	20$			; Waiting
	BGTR	10$			; Granted
	MOVAB	CV_STRING,STATE1
	MOVAB	GR_STRING,STATE2
	MOVZBL	LKB$B_GRMODE(R6),R0	; Get granted mode
	MOVAW	LOCKMODE_TBL[R0],MODE2	; Store granted mode sting
	MOVZBL	LKB$B_RQMODE(R6),R0	; Get requested mode
	BRB	30$
10$:	MOVAB	GR_STRING,STATE1
	MOVZBL	LKB$B_GRMODE(R6),R0
	BRB	25$
20$:	MOVAB	WT_STRING,STATE1
	MOVZBL	LKB$B_RQMODE(R6),R0
25$:	MOVAB	NULL_CSTRING,STATE2	; No state 2
	MOVAB	BLANKS,MODE2		; No mode 2
30$:	MOVAW	LOCKMODE_TBL[R0],MODE1	; Store mode 1

	; Blocking AST

	MOVAB	NULL_CSTRING,BLKAST	; Assume no blocking AST
	TSTL	LKB$L_BLKASTADR(R6)	; Is there a blocking AST?
	BEQL	32$
	MOVAB	BL_STRING,BLKAST	; Yes, store address of string

	; Flags

32$:	MOVAB	NULL_CSTRING,R3		; Initialize fields
	MOVL	R3,FLAGS1
	MOVL	R3,FLAGS1+4
	MOVL	R3,FLAGS1+8
	MOVL	R3,FLAGS2
	MOVL	R3,FLAGS2+4
	MOVL	R3,FLAGS2+8
	MOVL	R3,FLAGS3
	MOVL	R3,FLAGS3+4
	MOVL	R3,FLAGS3+8

	MOVZWL	LKB$W_FLAGS(R6),R5	; Pick up flags
	MOVAL	FLAGS1,R4		; Address of 1st arg. list
	CLRL	R2
	CLRL	R3
35$:	BBC	R3,R5,60$		; Br. if flag not set
	MOVAQ	FLAGS_TBL[R3],(R4)	; Store appropriate string address
	ADDL	#4,R4
	INCL	R2			; Incr. position counter
	CMPL	R2,#3			; Move to 2nd line?
	BNEQ	40$			; No
	MOVAL	FLAGS2,R4		; Yes
	BRB	60$
40$:	CMPL	R2,#6			; Move to third line
	BNEQ	60$			; No
	MOVAL	FLAGS3,R4		; Yes
60$:	AOBLSS	#9,R3,35$		; Repeat 9 times


PART2:

	; Status

	MOVAB	NULL_CSTRING,R3		; Initialize fields
	MOVL	R3,STS1
	MOVL	R3,STS1+4
	MOVL	R3,STS1+8
	MOVL	R3,STS2
	MOVL	R3,STS2+4
	MOVL	R3,STS2+8
	MOVL	R3,STS3
	MOVL	R3,STS3+4
	MOVL	R3,STS3+8

	MOVZWL	LKB$W_STATUS(R6),R5	; Pick up status
	MOVAL	STS1,R4			; Address of 1st arg. list
	CLRL	R2
	CLRL	R3
35$:	BBC	R3,R5,60$		; Br. if flag not set
	MOVAQ	STATUS_TBL[R3],(R4)	; Store appropriate string address
	ADDL	#4,R4
	INCL	R2			; Incr. position counter
	CMPL	R2,#3			; Move to 2nd line?
	BNEQ	40$			; No
	MOVAL	STS2,R4			; Yes
	BRB	60$
40$:	CMPL	R2,#6			; Move to third line
	BNEQ	60$			; No
	MOVAL	STS3,R4			; Yes
60$:	AOBLSS	#9,R3,35$		; Repeat 9 times

	;
	; Resource name, length, access mode, and name space
	;

	MOVZBL	RSNLEN_BFR,RLEN
	MOVZBL	RSNLEN_BFR,R1
	MOVAB	RESNAM_BFR,R0
	PUSHL	R0			; Save R0
	MOVC5	R1,(R0),#0,#32,(R0) 	; Zero out rest of buffer
	POPL	R0			; Restore R0
	MOVAL	(R0),DMP1
	MOVL	(R0)+,RES1
	MOVL	(R0)+,RES2
	MOVAL	(R0),DMP3
	MOVL	(R0)+,RES3
	MOVL	(R0)+,RES4
	MOVAL	(R0),DMP5
	MOVL	(R0)+,RES5
	MOVL	(R0)+,RES6
	MOVAL	(R0),DMP7
	MOVL	(R0)+,RES7
	MOVL	(R0)+,RES8
	MOVZBL	RMOD_BFR,R0		; Get access mode
	MOVL	ACMODE_TBL[R0],ACMODE
	TSTW	GROUP_BUF		; System names have group = 0
	BEQL	70$			; Branch if system name
	$FAO_S	CTRSTR = FAO_GROUP_DSC,-
		OUTBUF = GROUP_BUF_DSC,-
		P1 =  GROUP_BFR
	BLBS	R0,65$
	BRW	90$
65$:	MOVW	GROUP_BUF,GROUP_NUM
	MOVB	GROUP_BUF+2,GROUP_NUM+2
	MOVAQ	GROUP_DSC,NSPACE
	BRB	80$
70$:	MOVAQ	SYS_DSC,NSPACE

80$:	; Format type of lock and remote lock info.

	MOVL	RSBCSID_BFR,R0		; Get CSID
	BNEQ	82$			; Must be process copy
	BBS	#LKB$V_MSTCPY,LKB$W_STATUS(R6),84$ ; Branch if master copy
	MOVAB	LOCAL,TYPE		; Set type of lock
	MOVAB	SPACE,RMINFO		; Display no remote info
	BRB	88$

82$:	MOVAB	PROCESS,TYPE		; Set type of lock
	BRB	86$

84$:	MOVAB	MASTER,TYPE		; Set type of lock
	MOVL	LKB$L_CSID(R6),R0	; Get CSID

86$:	MOVL	LKB$L_REMLKID(R6),R1	; Get remote lock id.
	$FAO_S	CTRSTR = FAO_RMINFO_DSC,-
		OUTBUF = RMINFO_DSC,-
		OUTLEN = RMINFO_LEN,-
		P1 = R1,-
		P2 = R0
	BLBC	R0,90$
	MOVB	RMINFO_LEN,RMINFO_CNT
	MOVAB	RMINFO_CNT,RMINFO	; Store ptr to .ASCIC string

88$:	MOVL	#1,R0
90$:	RET

	.SBTTL	PRINT_LOCK - OUTPUT LOCK DATA
;+++
;
;	PRINT_LOCK
;
;  PURPOSE
;	OUTPUT FORMATTED LOCK DATA, LINE-BY-LINE.
;
;  INPUT
;	FORMATTED LOCK DATA
;
;  OUTPUT
;	DISPLAYED DATA
;
;---
	.ENTRY	PRINT_LOCK,^M<>

;
;  LINE 1
;
	PUSHL	FLAGS1+8
	PUSHL	FLAGS1+4
	PUSHL	FLAGS1
	PUSHL	PID
	PUSHL	LKID
	PRINT	5,<Lock id:  !XL   PID:    !XL   Flags:   !3(8AC)>
;		             LKID          PID            FLAGS1
	
;
;  LINE 2
;
	PUSHL	FLAGS2+8
	PUSHL	FLAGS2+4
	PUSHL	FLAGS2
	PUSHL	MODE1
	PUSHL	#2
	PUSHL	STATE1
	PUSHL	PARID
	PRINT	7,<Par. id:  !XL   !13AC !AD!12* !3(8AC)>
;			    PARID STATE1 MODE1    FLAGS2

;
;  LINE 3
;
	PUSHL	FLAGS3+8
	PUSHL	FLAGS3+4
	PUSHL	FLAGS3
	PUSHL	MODE2
	PUSHL	#2
	PUSHL	STATE2
	PUSHL	SUBLKS
	PRINT	7,<Sublocks:  !7UL   !13AC !AD!12* !3(8AC)>
;		             SUBLKS STATE2 MODE2    FLAGS3

;
;  LINE 3A
;
	PUSHL	BLKAST
	PUSHL	LKB
	PRINT	2,<LKB:      !XL   !9AC>
;			     LKB   BLKAST

;
;  LINE 4
;
	PUSHL	STS1+8
	PUSHL	STS1+4
	PUSHL	STS1
	PUSHL	DMP1
	PUSHL	#8
	PUSHL	RES1
	PUSHL	RES2
	PRINT	7,<Resource:      !XL !XL    !AF  Status:  !3(8AC)>
;			         RES2 RES1   DMP1            STS1

;
;  LINE 5
;
	PUSHL	STS2+8
	PUSHL	STS2+4
	PUSHL	STS2
	PUSHL	DMP3
	PUSHL	#8
	PUSHL	RES3
	PUSHL	RES4
	PUSHL	RLEN
	PRINT	8,< Length   !2ZB   !XL !XL    !AF           !3(8AC)>
;			     RLEN   RES4 RES3   DMP3            STS2

;
;  LINE 6
;
	PUSHL	STS3+8
	PUSHL	STS3+4
	PUSHL	STS3
	PUSHL	DMP5
	PUSHL	#8
	PUSHL	RES5
	PUSHL	RES6
	PUSHL	ACMODE
	PRINT	8,< !11AC   !XL !XL    !AF           !3(8AC)>
;	           ACMODE  RES6 RES5   DMP5            STS3  

;
;  LINE 7
;
	PUSHL	DMP7
	PUSHL	#8
	PUSHL	RES7
	PUSHL	RES8
	PUSHL	NSPACE
	PRINT	5,< !11AS   !XL !XL    !AF>
;	            NSPACE  RES8 RES7  DMP7 
	
;
; LINE 8
;
	PUSHL	RMINFO
	PUSHL	TYPE
	PRINT	2,<!AC copy !AC!/>
;		   TYPE     RMINFO
	RET

	.SBTTL 	LOCK_COND_HAND - CONDITION HANDLER FOR SHOW_ALL_LOCKS
;+++
;
;  	LOCK_COND_HAND
;
;  PURPOSE
;	PROVIDE EXIT PATH FOR SHOW_ALL_LOCKS WHEN THERE ARE NO MORE LOCKS
;	TO BE PROCESSED
;
;  INPUT
;	4(AP) = POINTER TO SIGNAL ARGUMENTS
;	8(AP) = POINTER TO MECHANISM ARGUMENTS
;
;  OUTPUT
;	POSSIBLE MODIFICATION OF STATUS; POSSIBLE CHANGE IN FLOW 
;	OF CONTROL.
;
;---
	.ENTRY	LOCK_COND_HAND,^M<R2,R3,R4>

	MOVQ	4(AP),R2		; GET ADDRESSES OF ARRAYS
	MOVL	CHF$L_SIG_NAME(R2),R4	; GET CONDITION NAME
	CMPL	#SS$_UNWIND,R4		; ARE WE UNWINDING?
	BEQL	20$			; IF EQL, YES
	CMPL	#MSG$_OUTOFRANG,R4	; DID WE GET THE SIGNAL WE'RE LOOKING FOR?
	BNEQ	20$			; IF NEQ, NO - PASS IT ON

	TSTL	LOCK_COUNT		; DID WE PROCESS LOCKS?
	BNEQ	10$			; IF NEQ, YES
	SIGNAL	0,NOLOCKS		; DISPLAY INFO MESSAGE

10$:	MOVL	R0,CHF$L_MCH_SAVR0(R3)	; INDICATE SUCCESS AFTER UNWIND
	CLRQ	-(SP)			; GO BACK TO ESTABLISHER
	CALLS	#2,G^SYS$UNWIND		; UNWIND CALL FRAMES
	RET				; RETURN TO ESTABLISHER

20$:	MOVZWL	#SS$_RESIGNAL,R0	; RESIGNAL CONDITION
	RET

	.SBTTL	SHOW_ALL_RES - ACTION ROUTINE TO DISPLAY ALL RESOURCES
;+++
;
;	SHOW_ALL_RES
;
;  PURPOSE
;	MAIN ROUTINE TO PROCESS THE "SHOW RES/ALL" COMMAND
;
;  INPUT
;	NONE
;
;  OUTPUT
;	DISPLAYED DATA
;
;---
	.ENTRY	SHOW_ALL_RES,^M<R2,R3,R4>

	PUSHAB	RES_HEAD		; SET UP HEADING
	CALLS	#1,SET_HEADING
	CLRL	RES_COUNT		; INIT COUNT
	CLRL	R4			; INIT HASH TABLE INDEX
	REQMEM	@LCK$GL_HTBLCNT,R2	; GET COUNT OF ELEMENTS IN HASH TABLE
	ASHL	R2,#1,HTBL_CNT
	MOVL	LCK$GL_HASHTBL,R3	; GET ADDRESS OF START OF HASH TABLE
	REQMEM	(R3),R3			; GET FIRST ELEMENT

;
;  INDEX THROUGH HASH TABLE, LOOKING FOR HASH CHAINS
; 
10$:
	MOVAL	(R3)[R4],R2		; GET HEAD OF CHAIN 
	REQMEM	(R2),RSB		; GET FIRST RSB ADDRESS
	TSTL	RSB			; IF ZERO, EMPTY CHAIN
	BEQL	20$

;
;  SEQUENCE THROUGH HASH CHAIN
;
15$:
	INCL	RES_COUNT		; INCREMENT COUNT
	REQMEM	@RSB,RSB_BFR,#RSB$K_MAXLEN+RSB$K_LENGTH  ;SAVE RSB DATA
	CALLS	#0,SHOW_RSB		; DISPLAY RSB
	CALLS	#0,SHOW_QUEUES		; DISPLAY QUEUES
	MOVL	RSB_BFR,RSB		; GET NEXT RSB
	BLSS	15$

;
;  OUTER LOOP CONTROL
;
20$:
	AOBLSS	HTBL_CNT,R4,10$		; INCREMENT INDEX, LOOP IF LSS

	TSTL	RES_COUNT		; DID WE PROCESS ANY RESOURCES?
	BEQL	30$			; IF EQL, NO

	STATUS	SUCCESS			; SUCCESS RETURN
	RET
30$:
	SIGNAL	0,NORESOURC		; NO RESOURCES DISPLAYED
	RET 

	
	.SBTTL	SHOW_ONE_RES - ACTION ROUTINE TO DISPLAY ONE RESOURCE
;+++
;
;	SHOW_ONE_RES
;
;  PURPOSE
;	MAIN ROUTINE TO PROCESS THE "SHOW RES/LOCK=lockid" COMMAND.
;
;  INPUT
;	LOCKID - ID OF LOCK WHOSE ASSOCIATED RESOURCE IS TO BE DISPLAYED.
;
;  OUTPUT
;	DISPLAYED DATA.
;
;---
	.ENTRY	SHOW_ONE_RES,^M<R2>

	CALLS	#0,GET_LKB		; GET LKB ADDRESS
	BLBC	R0,10$			; IF LBC, NONE EXISTS
	MOVL	LKB,R2
	REQMEM	LKB$L_RSB(R2),RSB	; GET ADDRESS OF RSB
	REQMEM	@RSB,RSB_BFR,#RSB$K_MAXLEN+RSB$K_LENGTH  ; GET RSB DATA
	PUSHAB	RES_HEAD		; SET RSB HEADING
	CALLS	#1,SET_HEADING
	CALLS	#0,SHOW_RSB		; DISPLAY RSB
	CALLS	#0,SHOW_QUEUES		; DISPLAY QUEUES

	STATUS	SUCCESS			
	RET

10$:	SIGNAL	0,NOLKB			; LOCKID NON-EXISTANT
	RET

	.SBTTL	SHOW_RSB - CONTROL FOR RSB DISPLAY
;+++
;
;	SHOW_RSB
;
;  PURPOSE
;	CONTROL THE FORMAT AND DISPLAY OF RSB DATA
;
;  INPUT
;	RSB DATA STRUCTURES (IMPLIED)
;
;  OUTPUT
;	DISPLAYED DATA
;---
	.ENTRY	SHOW_RSB,^M<>

	CALLS	#0,FORMAT_RSB
	SKIP	PAGE
	ENSURE	9
	CALLS	#0,PRINT_RSB

	RET

	.SBTTL	SHOW_QUEUES - DISPLAY QUEUES FOR GIVEN RESOURCE
;+++
;
;	SHOW_QUEUES
;
;  PURPOSE
;	DISPLAY, SEQUENTIALLY, THE GRANTED, CONVERSION AND WAIT
;	QUEUES ASSOCIATED WITH A RESOURCE.
;
;  INPUT
;	RSB - BUFFER CONTAINING RSB DATA
;
;  OUTPUT
;	DISPLAYED QUEUES.
;
;---
	.ENTRY	SHOW_QUEUES,^M<>

	
	ADDL3	RSB,#RSB$L_GRQFL,-(SP)		; GET ADDRESS OF GRANT QUE FLINK
	PUSHL	#GRANT				; IND GRANT QUE
	CALLS	#2,PROCESS_QUEUE		

	ADDL3	RSB,#RSB$L_CVTQFL,-(SP)		; GET ADDRESS OF CONVERT QUE FLINK
	PUSHL	#CONVERT			; IND CONVERT QUE
	CALLS	#2,PROCESS_QUEUE

	ADDL3	RSB,#RSB$L_WTQFL,-(SP)		; GET ADDRESS OF WAIT QUE FLINK
	PUSHL	#WAIT				; IND WAIT QUE
	CALLS	#2,PROCESS_QUEUE

	RET

	.SBTTL	FORMAT_RSB - FORMAT RSB DATA
;+++
;
;	FORMAT_RSB
;
;  PURPOSE
;	FORMAT RAW RSB DATA, STORE FOR EASY ACCESS LATER ON.
;
;  INPUT
;	RSB_BFR - BUFFER CONTAINING RSB DATA
;
;  OUTPUT
;	STORED DATA.
;
;---
	.ENTRY	FORMAT_RSB,^M<R2,R3,R4,R5,R6,R7>

	MOVAB	RSB_BFR,R6			; GET ADDRESS OF DATA BUFFER

;
;  FORMAT RESOURCE NAME
;
	MOVAB	RSB$T_RESNAM(R6),R7		; LET R7 POINT TO RESOURCE NAME
	MOVZBL	RSB$B_RSNLEN(R6),R0		; ZERO OUT UNUSED PORTION OF BUFFER
	MOVC5	R0,(R7),#0,#32,(R7)
	MOVAL	(R7),BUF1
	MOVL	(R7)+,RESN1
	MOVL	(R7)+,RESN2
	MOVAL	(R7),BUF2
	MOVL	(R7)+,RESN3
	MOVL	(R7)+,RESN4
	MOVAL	(R7),BUF3
	MOVL	(R7)+,RESN5
	MOVL	(R7)+,RESN6
	MOVAL	(R7),BUF4
	MOVL	(R7)+,RESN7
	MOVL	(R7)+,RESN8

;
;  FORMAT RSB
;
	MOVL	RSB$L_PARENT(R6),PRSB
	MOVZWL	RSB$W_REFCNT(R6),SRSBCT
	MOVZWL	RSB$W_BLKASTCNT(R6),BAST
	MOVL	RSB$Q_VALBLK(R6),VAL1
	MOVL	RSB$Q_VALBLK+4(R6),VAL2
	MOVL	RSB$Q_VALBLK+8(R6),VAL3
	MOVL	RSB$Q_VALBLK+12(R6),VAL4
	MOVL	RSB$L_VALSEQNUM(R6),SEQNUM
	MOVL	RSB$L_CSID(R6),CSID
	MOVAB	SPACE,VALID
	BBC	#RSB$V_VALINVLD,RSB$W_STATUS(R6),15$
	MOVAB	NOT_VALID,VALID
15$:	MOVAB	SPACE,DIRENTRY
	BBC	#RSB$V_DIRENTRY,RSB$W_STATUS(R6),17$
	MOVAB	DIR_ENTRY,DIRENTRY
17$:	MOVZBL	RSB$B_GGMODE(R6),R1
	MOVL	LKMODE_TBL[R1],GGMOD
	MOVZBL	RSB$B_CGMODE(R6),R1
	MOVL	LKMODE_TBL[R1],CGMOD
	MOVB	RSB$B_RMOD(R6),R1
	MOVL	ACMODE_TBL[R1],RACMOD
	MOVZBL	RSB$B_RSNLEN(R6),RESNLEN
	MOVAQ	SYS_DSC,RNSPACE
	MOVW	RSB$W_GROUP(R6),GROUP_BFR
	BEQL	90$				; Branch if system name
	$FAO_S	CTRSTR = FAO_GROUP_DSC,-
		OUTBUF = GROUP_BUF_DSC,-
		P1 =  GROUP_BFR
	BLBC	R0,90$
	MOVW	GROUP_BUF,GROUP_NUM
	MOVB	GROUP_BUF+2,GROUP_NUM+2
	MOVAQ	GROUP_DSC,RNSPACE

90$:
	RET

	.SBTTL	PRINT_RSB - OUTPUT RSB DATA
;+++
;
;	PRINT_RSB
;
;  PURPOSE
;	OUTPUT RSB DATA, LINE-BY-LINE.
;
;  INPUT
;	FORMATTED DATA.
;
;  OUTPUT
;	DIPLAYED DATA.
;	
;---

	.ENTRY	PRINT_RSB,^M<>

;
;  LINE 1
;
	PUSHL	GGMOD
	PUSHL	RSB
	PRINT	2,<Address of RSB:  !XL  Group grant mode:       !AC     >
;			                    RSB			        GGMOD

;
;  LINE 2
;
	PUSHL	CGMOD
	PUSHL	PRSB
	PRINT	2,<Parent RSB:      !XL  Conversion grant mode:  !AC      >
;				            PRSB			 CGMOD

;
;  LINE 3
;
	PUSHL	BAST
	PUSHL	SRSBCT
	PRINT	2,<Sub-RSB count:   !8UL  BLKAST count:     !8UL>
;	  	                           SRSBCT		    BAST

;
;  LINE 4
;
	PUSHL	VALID
	PUSHL	SEQNUM
	PUSHL	VAL1
	PUSHL	VAL2
	PUSHL	VAL3
	PUSHL	VAL4
	PRINT	6,<Value block:   !XL !XL !XL !XL   Seq. #:  !XL !AC>
;			        VAL4 VAL3 VAL2 VAL1       SEQNUM VALID

;
;  LINE 5
;
	PUSHL	BUF1
	PUSHL	#8
	PUSHL	RESN1
	PUSHL	RESN2
	PRINT	4,<Resource:      !XL !XL    !AF  >
;				         RESN2 RESN1  BUF1 

;
;  LINE 6
;
	PUSHL	CSID
	PUSHL	BUF2
	PUSHL	#8
	PUSHL	RESN3
	PUSHL	RESN4
	PUSHL	RESNLEN
	PRINT	6,< Length   !2UL   !XL !XL    !AF         CSID:  !XL>
;			    RESNLEN RESN4 RESN3  BUF2             CSID

;
;  LINE 7
;
	PUSHL	DIRENTRY
	PUSHL	BUF3
	PUSHL	#8
	PUSHL	RESN5
	PUSHL	RESN6
	PUSHL	RACMOD
	PRINT	6,< !11AC   !XL !XL    !AF         !AC>
;	           RACMOD RESN6 RESN5  BUF3      DIRENTRY  

;
;  LINE 8
;
	PUSHL	BUF4
	PUSHL	#8
	PUSHL	RESN7
	PUSHL	RESN8
	PUSHL	RNSPACE
	PRINT	5,< !11AS   !XL !XL    !AF>
;		           RNSPACE RESN8 RESN7 BUF4

	RET

	.SBTTL	PROCESS_QUEUE - TRAVERSE RESOURCE QUEUES
;+++
;
;	PROCESS_QUEUE
;
;  PURPOSE
;	TRAVERSE AN INDIVIDUAL RESOURCE QUEUE, FORMATTING AND
;	DISPLAYING ITS CONTENTS.
;
;  INPUT
;	4(AP) - QUEUE TYPE, WHERE:  -1: GRANT
;				     0: CONVERSION
;				     1: WAIT
;	8(AP) - ADDRESS OF HEAD OF QUEUE
;
;  OUTPUT
;	DISPLAYED CONTENTS OF QUEUE
;
;---
	.ENTRY	PROCESS_QUEUE,^M<R2,R3,R4,R5,R6,R7,R8,R9>

	MOVAB	LKID_BFR,R4		; GET ADDRESS OF LOCKID STORAGE BUFFER
	MOVAB	GRMD_BFR,R5		; GET ADDRESS OF GRANT MODE BUFFER
	MOVAB	RQMD_BFR,R6		; GET ADDRESS OF REQUEST MODE BUFFER
	MOVL	8(AP),R2		; GET ADDRESS OF HEAD OF QUEUE
	MOVL	R2,R9			
	CLRL	QUEUE_COUNT		; INIT COUNT OF QUEUE ITEMS PROCESSED
	MOVL	4(AP),QUEUE_TYPE	; GET TYPE OF QUEUE
	MNEGL	#1,R8			
	ADDL3	#1,QUEUE_TYPE,R7	
	MOVL	QUE_STR_TBL[R7],R7	; GET HEADER FOR THIS TYPE OF QUEUE
	ENSURE	3
	SKIP	1
	PRINTD	R8,(R7)			; DISPLAY IT

;
;  INIT FOR SCAN OF QUEUE
;
10$:	CLRL	R3

;
;  GET QUEUE ELEMENT
;
20$:	REQMEM	(R2),R2			; GET QUEUE ELEMENT
	CMPL	R9,R2			; AT END OF QUEUE?
	BEQL	30$			; IF EQL, YES

	ASSUME	LKB$L_SQFL-LKB$L_LKID	GT  0
	ASSUME	LKB$B_RQMODE-LKB$L_LKID	EQ  4
	ASSUME	LKB$B_GRMODE-LKB$L_LKID	EQ  5

	INCL	QUEUE_COUNT		; INCREMENT COUNT
	SUBL3	#<LKB$L_SQFL-LKB$L_LKID>,R2,R8  ; GET START OF RELEVANT DATA
	REQMEM	(R8),LKB_BFR,#6		; SAVE ID, GRANT & REQUEST MODE
	MOVAB	LKB_BFR,R7
	MOVL	LKID_OFF(R7),(R4)[R3]   ; MOVE INTO STORAGE BUFFERS
	MOVB	GRMD_OFF(R7),(R5)[R3]
	MOVB	RQMD_OFF(R7),(R6)[R3]

	AOBLSS	#3,R3,20$		; IF WE'VE SAVED 3 ITEMS, PRINT THEM
	CALLS	#0,PRINT_LINE
	BRB	10$			; GET MORE ITEMS

30$:	CALLS	#0,PRINT_LINE		; PRINT ANY REMAINING ITEMS
	TSTL	QUEUE_COUNT		; WERE ANY ITEMS PROCESSED?
	BNEQ	EXIT			; IF NEQ, YES
	PRINT	0,<     *** EMPTY QUEUE ***> 

EXIT:	RET

	.SBTTL	PRINT_LINE - OUTPUT QUEUE DATA
;+++
;
;	PRINT_LINE
;
;  PURPOSE
;	GIVEN LOCK DATA FOR ONE LINE (0 - 3 ITEMS), FORMAT AND
;	DISPLAY THIS DATA
;
;  INPUT
;	R3 - COUNT OF ITEMS TO DISPLAY
;	R4 - ADDRESS OF BUFFER CONTAINING LOCK IDS
;	R5 - ADDRESS OF BUFFER CONTAINING GRANT-MODES
;	R6 - ADDRESS OF BUFFER CONTAINING REQUESTED-MODES
;	QUEUE_TYPE - TYPE OF QUEUE WE ARE WORKING ON
;
;  OUTPUT
;	ONE DISPLAYED LINE OF QUEUE LOCK DATA.
;
;---

	.ENTRY	PRINT_LINE,^M<R7,R8>

;
;  INITIALIZE
;	
	MOVL	QUEUE_TYPE,R7		; SAVE QUEUE TYPE
	MOVL	R3,COUNT		; SAVE COUNT
	SOBGEQ	R3,10$			; CONVERT TO ARRAY INDEX
	RET				; IF COUNT 0, NO ITEMS TO DISPLAY

;
;  FORMAT DATA
;
10$:	TSTL	R7			; ONLY FORMAT RQ MODE IF WAIT OR CONVERT
	BLSS	15$			;    QUEUE
	MOVZBL	(R6)[R3],R8
	PUSHL	LKMODE_TBL[R8]

15$:	TSTL	R7			; ONLY FORMAT GR MODE IF GRANT OR CONVERT
	BGTR	20$			;    QUEUE
	MOVZBL	(R5)[R3],R8
	PUSHL	LKMODE_TBL[R8]

20$:	PUSHL	(R4)[R3]		; PROCESS LOCK ID
	SOBGEQ	R3,10$			; IF NOT YET DONE, LOOP

	MOVAB	CONV_STR_TBL,R8		; GET ADDRESS OF CORRECT FAO STRING TABLE
	TSTL	R7
	BEQL	25$			; IF EQL, CONVERT
	MOVAB	LOCK_STR_TBL,R8		; ELSE WAIT/GRANT

25$:	MOVL	COUNT,R3		; PICK UP CORRECT STRING FOR NUMBER OF 
	MOVL	(R8)[R3],R8		;     ITEMS
	ADDL	R3,R3			; CALCULATE CORRECT FAO ARG COUNT
	TSTL	R7
	BNEQ	30$
	ADDL	COUNT,R3

30$:	PRINTD  r3,(r8)			; DISPLAY LINE

	RET 

	.END

