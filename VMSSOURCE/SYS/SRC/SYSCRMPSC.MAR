	.TITLE	SYSCRMPSC - Create and Map Section System Service
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
; ABSTRACT:
;
; ENVIRONMENT:
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 24-APR-78
;
; MODIFIED BY:
;
;	V03-034	WMC0012		Wayne Cardoza		03-Jul-1984
;		Fix register problem with WMC0011.
;
;	V03-033	WMC0011		Wayne Cardoza		25-May-1984
;		Fix protection checks for CRF global sections.
;
;	V03-032	LMP0221		L. Mark Pilant,		12-Apr-1984  16:22
;		Modify the protection check to call EXE$CHECKPROT_16
;		instead of the various EXE$CHKxxxACCES routines.
;
;	V03-031	WMC0012		Wayne Cardoza		9-Apr-1984
;		Fix check for resident section read complete.
;
;	V03-030	CDS0001		Christian D. Saether	 9-Apr-1984
;		Credit BYTLM as well as BYTCNT when returning quota
;		as a result of creating shared WCB.  It is now being
;		charged by the file system.
;
;	V03-029	WMC0011		Wayne Cardoza		28-Mar-1984
;		Check that page isn't in memory seen by MP before
;		bumping the inhibit count.
;		Add hash byte to GSD.
;
;	V03-028	WMC0010		Wayne Cardoza		14-Mar-1984
;		Set valid bit in GPTE for resident global.
;
;	V03-027	WMC0009		Wayne Cardoza		22-Feb-1984
;		Add resident global section support.
;
;	V03-026	MSH0005		Michael S. Harvey	3-Feb-1984
;		R5 is now a valid input for access checking routines. Make
;		sure R5 is correct before calling them.
;
;	V03-025	MSH0004		Michael S. Harvey	26-Jan-1984
;		Add support for lengthened global section names in GSDs.
;
;	V03-024	WMC0008		Wayne Cardoza		12-Jan-1983
;		Process sections should not use fast path for PFN sections.
;
;	V03-023	TMK0001		Todd M. Katz		11-Dec-1983
;		Fix a broken branch.
;
;	V03-022	WMC0007		Wayne Cardoza		23-Sep-1983
;		Changes to routines to fill in PTEs to improve performance.
;
;	V03-021	CWH3021		CW Hobbs		18-Sep-1983
;		Fix broken branch.
;
;	V03-020	WMC0006		Wayne Cardoza		30-Aug-1983
;		Disable IPL 0 wait on process section creation.
;
;	V03-019	ADE9005		Alan D. Eldridge 	31-May-1983
;		Change BSBW to JSB's to MMG$RETADRINI and MMG$INADRINI.
;
;	V03-018	RSH0031		R. Scott Hanna		26-May-1983
;		Fix linker truncation errors.
;
;	V03-017	WMC0005		Wayne Cardoza		24-May-1983
;		Allow mapping of execute-access global sections.
;
;	V03-016	LJK0199		LAWRENCE J. KENAH	12-Apr-1983
;		Restore FILCNT along with BYTCNT for files with shared windows.
;
;	V03-015	WMC0004		Wayne Cardoza		23-Mar-1983
;		Fix a linker truncation error.
;
;	V03-014	WMC0003		Wayne Cardoza		18-Mar-1983
;		Fix a return status in mapsecpag.
;
;	V03-013	WMC0002		Wayne Cardoza		02-Mar-1983
;		MMG$CRECOM2 is gone
;		MMG$RETADRINI, MMG$INADRINI return status
;
;	V03-012	WMC53991	Wayne Cardoza		21-Feb-1983
;		Make protection checks on global sections not mapped to file.
;
;	V03-011	SRB0066		Steve Beckhardt		18-Feb-1983
;		Fixed two broken branch displacments.
;
;	V03-010	WMC0001		Wayne Cardoza		02-Feb-1983
;		Ensure that section table entry is complete before service
;		touches the return address.
;
;	V03-009	KDM0037		Kathleen D. Morse	16-Dec-1982
;		Prevent shared memory and PFNMAP sections from being
;		backed to page file via SEC$V_PAGFIL.  Optimize some code
;		and add some comments.
;
;	V03-008	KDM0036		Kathleen D. Morse	15-Dec-1982
;		Re-compute the section table entry address after every
;		page creation as the process header may have been expanded
;		causing the section table to slide up one page.
;
;	V03-007	KDM0038		Kathleen D. Morse	21-Dec-1982
;		Change BSBW to JSB.
;
;	V03-006	KDM0029		Kathleen D. Morse	10-Nov-1982
;		Correct check for backwards mapping of shared memory
;		global section.  Only return SS$_IVSSRQ if the section
;		is mapped in pieces, not if it is mapped in one contiguous
;		piece of memory.
;
;	V03-005	LJK0189		Lawrence J. Kenah	10-Nov-1982
;		Make RELPAG parameter work correctly for shared memory
;		global sections.
;	V03-004	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $IODEF.
;
;	V03-003	PHL0101		Peter H. Lipman		21-Jun-1982
;		$QIOW now synchronizes the EFN and IOSB parameters
;		correctly.  Eliminate the synchronization code here.
;
;
;	V03-002	DWT0041		David Thiel		10-Jun-1982
;		Correct sequence of clearing shared memory bitmap lock
;		bit and releasing the shared memory GSD mutex so that the
;		bitmap lock bit is cleared first.
;
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ARMDEF				;ACCESS BITMASK DEFINITIONS
	$ARBDEF				;AGENT'S RIGHTS BLOCK OFFSETS
	$CCBDEF				;CHANNEL CONTROL BLOCK DEFINITIONS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DYNDEF				;DYNAMIC DATA STRUCTURE DEFINTIONS
	$FCBDEF				;FILE CONTROL BLOCK DEFINITIONS
	$FIBDEF				;FILE INFORMATION BLOCK DEFINITIONS
	$GSDDEF				;GLOBAL SECTION DESCRIPTOR DEFINTIONS
	$IODEF				;I/O FUNCTION CODE DEFINITIONS
	$IPLDEF				;PROCESSOR PRIORITY LEVELS
	$IRPDEF				;I/O REQUEST PACKET
	$JIBDEF				;JOB INFORMATION BLOCK OFFSETS
	$MMGDEF				;OFFSETS FROM FP INTO SCRATCH AREA
	$ORBDEF				;OBJECT'S RIGHTS BLOCK OFFSETS
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PFNDEF				;PFN DATA BASE
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINTIONS
	$PRTDEF				;PROTECTION CODE DEFINITIONS
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
	$PSLDEF				;DEFINE PROCESS MODES
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$RSNDEF				;RESOURCE NAMES
	$SECDEF				;SECTION TABLE DEFINITIONS
	$SHBDEF				;SHARED MEMORY CONTROL BLOCK DEFINITIONS
	$SHDDEF				;SHARED MEMORY COMMON DATA PAGE DEF.
	$SSDEF				;SYSTEM STATUS CODE DEFINTIONS
	$UCBDEF				;DEFINE UNIT CONTROL BLOCKS
	$VADEF				;VIRTUAL ADDRESS VIELDS
	$WCBDEF				;WINDOW CONTROL BLOCK DEFINITIONS
;
; EXTERNAL SYMBOLS:
;
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
; OFFSET FROM AP
;
	INADR		= 4		;OFFSET TO INPUT RANGE
	RETADR		= 8		;OFFSET TO RETURN RANGE
	ACMODE		= 12		;ACCESS MODE
	FLAGS		= 16		;MAP SECTION FLAGS
	GSDNAM		= 20		;GLOBAL SECTION NAME DESCRIPTOR ADDRESS
	IDENT		= 24		;SECTION IDENTIFIER
	RELPAG		= 28		;RELATIVE PAGE TO START MAPPING AT
	CHAN		= 32		;CHANNEL THAT FILE TO MAP IS OPEN ON
	SECPAGCNT	= 36		;NUMBER OF PAGES IN SECTION
	VBN		= 40		;FILE VBN AT WHICH SECTION BEGINS
	PFN		= 40		;STARTING PFN TO BE MAPPED
	PROT		= 44		;SECTION PROTECTION CODE
	PFC		= 48		;SECTION PAGE FAULT CLUSTER
;
; OWN STORAGE:
;

	.SBTTL	CRMPSC - CREATE AND MAP SECTION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THE CREATE AND MAP SECTION SERVICE CREATES A NEW SECTION
; OF THE SPECIFIED NAME UNLESS THAT NAME ALREADY EXISTS.  IN EITHER CASE
; IT THEN MAPS THE SPECIFIED SECTION.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$CRMPSC
;
; INPUT PARAMETERS:
;
;	INADR(AP) = ADDRESS OF 2 LONG WORDS THE 1ST OF WHICH SPECIFIES
;		THE STARTING VIRTUAL ADDRESS TO CREATE, THE 2ND SPECIFIES
;		THE ENDING VIRTUAL ADDRESS TO CREATE (INCLUSIVE).
;	RETADR(AP) = ADDRESS OF A 2 LONGWORD ARRAY INTO WHICH IS RETURNED
;		THE STARTING AND ENDING VIRTUAL ADDRESSES (INCLUSIVE)
;		OF THE PAGES JUST CREATED
;	ACMODE(AP) = THE ACCESS MODE (MAXIMIZED WITH CALLING MODE)
;		USED AS THE OWNER OF THE NEW PAGE(S)
;	FLAGS(AP)  = BIT  0  - GBL - GLOBAL IF SET, PROCESS IF CLEAR
;		     BIT  1  - CRF - COPY ON REFERENCE
;		     BIT  2  - DZRO - DEMAND ZERO
;		     BIT  3  - WRT - WRITABLE IF SET, READ ONLY IF CLEAR
;		     BITS 4 - 5 RESERVED, MUST BE ZERO
;		     BITS 6 & 7 - WRTMOD - WRITE ACCESS FOR SECTION
;		     BITS 8 - 12 RESERVED, MUST BE ZERO
;		     BIT  13 - RESIDENT - RESIDENT GLOBAL SECTION
;			       BIT 13 IS NOT TO BE DOCUMENTED (WMC)
;		     BIT  14 - PERM - PERMANENT IF SET, TEMPORARY IF CLEAR
;		     BIT  15 - SYSGBL - SYSTEM GLOBAL IF SET, GROUP GLOBAL IF CLEAR
;		     BIT  16 - PFNMAP - MAP TO SPECIFIC PFN'S, IF SET
;		     BIT  17 - EXPREG - MAP TO FIRST FREE SPACE AVAILABLE
;		     BIT  18 - PROTECT - SET IF WRITE ACCESS MODE SPECIFIED
;		     BIT  19 - PAGFIL - USE PAGE FILE BACKING STORE FOR GLOBAL SECTION
;		     BIT  20 - EXECUTE - MAP IF EXECUTE ACCESS - EXEC MODE ONLY
;		     BITS 21 - 31 RESERVED, MUST BE ZERO
;	GSDNAM(AP) = THE DESCRIPTOR OF THE GLOBAL SECTION NAME
;	IDENT(AP)  = ADDRESS OF QUAD WORD CONTAINING SECTION IDENTIFICATION
;		     FIRST LONG WORD CONTAINS THE MATCH CONTROL INFORMATION
;			0 = ISD$K_MATALL, MATCH ALWAYS
;			1 = ISD$K_MATEQU, MATCH IF IDENTS ARE EQUAL
;			2 = ISD$K_MATLEQ, MATCH IF HIGH 8 BITS ARE EQUAL
;			    AND LOW 24 BITS ARE LESS THAN OR EQUAL TO
;			    THE ID STORED IN THE GLOBAL SECTION.
;		     SECOND LONG WORD CONTAINS THE IDENT TO BE COMPARED
;	RELPAG(AP) = RELATIVE PAGE IN SECTION TO START MAPPING
;	CHAN(AP)   = CHANNEL ON WHICH FILE IS ACCESSED
;	SECPAGCNT(AP) = NUMBER OF PAGES (STARTING AT THE ABOVE VBN) IN THE SECTION
;	VBN(AP)    = STARTING VIRTUAL BLOCK IN FILE THAT BECOMES THE
;			FIRST BLOCK OF THE GLOBAL SECTION
;	PFN(AP)	= STARTING PFN TO BE MAPPED, IF PFNMAP FLAG SET
;	PROT(AP) = PROTECTION APPLIED TO SECTION
;	PFC(AP)    = PAGE FAULT CLUSTER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_IVSECFLG - INVALID SECTION FLAGS
;	SS$_ACCVIO - ACCESS VIOLATION
;	SS$_CREATED - SECTION SUCCESSFULLY CREATED
;	SS$_NORMAL - EXISTING SECTION SUCESSFULLY MAPPED
;	SS$_ILLPAGCNT - PAGE COUNT LESS THAN ZERO
;	SS$_GSDFULL - NO FREE GSD TO ALLOCATE
;	SS$_IVSECIDCTL - INVALID SECTION IDENT MATCH CONTROL
;	SS$_GPTFULL - NO GLOBAL PAGE TABLE SPACE TO ALLOCATE
;	SS$_NOTFILEDEV - NOT A FILE ORIENTED DEVICE
;	SS$_IVCHNLSEC - INVALID CHANNEL FOR SECTION
;	SS$_ENDOFFILE - END OF FILE ENCOUNTERED MAPPING SECTION
;	SS$_VASFULL - VIRTUAL ADDRESS SPACE FULL
;	SS$_INSFMEM - INSUFFICIENT SHARED MEMORY GLOBAL PAGES AVAILABLE
;	SS$_INTERLOCK - UNABLE TO ACQUIRE SHARED MEMORY BIT MAP LOCK
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAMES (DEPTH > 10)
;	SS$_IVLOGNAM - INVALID LOGICAL NAME
;	SS$_SHMNOTCNCT - SHARED MEMORY DATA STRUCTURES NOT CONNECTED
;	SS$_NOPRIV - NO PRIVILEGE FOR ATTEMPTED OPERATION
;	SS$_SECTBLFUL - SECTION TABLE FULL
;	SS$_PAGOWNVIO - PAGE OWNER VIOLATION (RE-MAPPING A PAGE IN USE)
;	SS$_IVCHAN - INVALID CHANNEL
;	SS$_EXQUOTA - EXCEEDED PAGING FILE QUOTA (FOR CRF SECTIONS)
;	SS$_NOWRT - UNABLE TO CREATE WRITABLE SECTION TO READ-ONLY FILE
;	SS$_IDMISMATCH - IDENT MISMATCH WITH EXISTING GLOBAL SECTION
;	SS$_EXPORTQUOTA - EXCEEDED PORT'S QUOTA FOR GSD'S
;	SS$_IVSSRQ - REQUEST TRIED TO MAP A MULTIPLE-PIECE SHARED
;		MEMORY GLOBAL SECTION BACKWARDS (THIS IS UN-IMPLEMENTED.)
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC
;
; **********************************************************************
;
	.ENABL	LSB

;
; NO INPUT RANGE ADDRESS SPECIFIED
;
CRMPSC_NOINADR:
	ASSUME	SEC$V_GBL EQ 0
	BLBC	R9,CRMPSC_ACCVIO	;ONLY LEGAL FOR GLOBAL SECTIONS
	BBC	#SEC$V_PERM,R9,CRMPSC_ACCVIO ;WHICH ARE PERMANENT
	DECL	R4			;-1 INDICATES NO RANGE TO MAP
	BRB	15$			;REJOIN CRMPSC CODE

FLAG_ERROR1:
	MOVZWL	#SS$_IVSECFLG,R0	;SET INVALID SECTION FLAG ERROR CODE
	BRB	CRMPSC_RET		;BRANCH TO ERROR RETURN
CRMPSC_ACCVIO:
	MOVZWL	#SS$_ACCVIO,R0		;CANNOT ACCESS THE RANGE TO MAP
CRMPSC_RET:
	RET

	.PSECT	Y$EXEPAGED		;PUT ENTRY POINT INTO SEPARATE PSECT

;**********  EXE$CRMPSC  ENTRY POINT

	.ENTRY	EXE$CRMPSC,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	JMP	EXE_CRMPSC		;TRANSFER TO REAL PROCEDURE

	.PSECT	YF$$SYSCRMPSC		;BACK TO $CRMPSC PSECT

EXE_CRMPSC:
	SUBL	S^#-MMG$C_LENGTH,SP	;RESERVE A SCRATCH AREA
	MOVL	FLAGS(AP),R9		;GLOBAL SECTION FLAGS
	MOVL	INADR(AP),R4		;ADDRESS OF RANGE TO MAP
	BEQL	CRMPSC_NOINADR		;BRANCH IF NULL RANGE
	IFNORD	#8,(R4),CRMPSC_ACCVIO	;BRANCH IF RANGE NOT ACCESSIBLE
	MOVQ	(R4),R4			;PICK UP THE RANGE
15$:	PUSHL	#0			;REMEMBER NO START RETADR YET
	MOVZWL	#SS$_CREATED,-(SP)	;ASSUME SECTION WILL BE CREATED
	PUSHR	#^M<R4,R5>		;SAVE RANGE FOR MAPPING LATER
	JSB	G^MMG$RETADRINI		;INIT RETURN RANGE, AND SCRATCH AREA
	BLBC	R0,CRMPSC_RET		;RETURN THE ERROR
	MOVL	R9,R0			;GLOBAL SECTION FLAGS
	BSBW	MMG$VFYSECFLG		;VERIFY SECTION FLAGS
	MOVL	R0,R9			;USE VERIFIED FLAGS
	CLRL	R8			;ASSUME NO SECTION TABLE ADDRESS
	MOVZWL	CHAN(AP),R6		;CHANNEL PARAMETER
	BNEQ	17$			;BR ON MAPPED TO A FILE
	BBS	#SEC$V_PAGFIL,R9,20$	;SKIP CHANNEL CHECKS IF PAGE FILE
	BBC	#SEC$V_PFNMAP,R9,FLAG_ERROR1 ;ERR IF NOT PFNMAP AND NO CHANNEL
	BRB	20$			;SKIP CHANNEL VERIFICATION AS NO CHANNEL

CRMPSC_FOUND:				;GLOBAL SECTION EXISTS, JUST MAP TO IT
	ADDL	#<11*4>+8,SP		;CLEAN OFF THE STACK
	MOVZWL	#SS$_NORMAL,8(SP)	;INDICATE SECTION ALREADY EXISTS
	BRW	MAPGBLSEC1		;GO MAP THE SECTION

17$:	BBS	#SEC$V_PFNMAP,R9,FLAG_ERROR1	;BR IF PFNMAP, ERROR
	BBS	#SEC$V_PAGFIL,R9,FLAG_ERROR1	;BR IF PAGFIL BACKING STORE, ERR

; CALL TO IOC$VERIFYCHAN THAT WAS MADE HERE IS NOW BEING MADE IN CHECK_WINDOW

19$:	BSBW	CHECK_WINDOW		;INSURE THAT FILE IS COMPLETELY MAPPED
	BLBC	R0,CRMPSC_RET		;BRANCH IF FILE NOT FULLY MAPPED
20$:	MOVL	G^SCH$GL_CURPCB,R4	;GET PCB ADDRESS
	BBC	#SEC$V_CRF,R9,25$	;BRANCH IF NOT CRF SECTION
	BBSS	S^#MMG$V_CHGPAGFIL,B^MMG$L_MAXACMODE(FP),25$ ;MUST CHARGE PAGE FILE

	ASSUME	SEC$V_GBL EQ 0
25$:	BLBC	R9,CRMPSC_PROCESS	;BRANCH IF CREATING PROCESS SECTION
	MOVAL	G^EXE$GL_GSDMTX,R0	;ADR OF GLOBAL SECTION MUTEX
	JSB	G^SCH$LOCKW		;LOCK GSD MUTEX FOR WRITING
;
; RETURNS WITH IPL = ASTDEL
; R8 = CHANNEL CONTROL BLOCK ADDRESS, IF PFNMAP CLEAR
; R9 = SECTION FLAGS
; 0(SP)  = STARTVA
; 4(SP) = ENDVA
; 8(SP) = SUCCESS CODE FOR MAP GLOBAL SECTION
;
; ***** NOTE:  ALL EXITS FROM THIS POINT ON MUST UNLOCK THE GSD MUTEX.
;
; FIRST, BEFORE DOING A GSD SCAN, DO A DEALLOCATE SECTION SCAN.  THIS
; SCAN MUST BE DONE IN ORDER TO COMPLETE THE DELETION OF A TEMPORARY
; GLOBAL SECTION WHOSE REFERENCE COUNT HAS DROPPED TO ZERO.
;
	JSB	MMG$DALCSTXSCN1		;SCAN FOR SECTIONS TO DEALLOCATE --
;
	SUBL	#<11*4>+8,SP		;MAKE ROOM FOR GSD NAME AND IDENT
	MOVL	SP,R7			;R7 = ADDRESS OF GSD NAME STORAGE

	ASSUME	IDENT EQ GSDNAM+4
	MOVQ	GSDNAM(AP),R0		;DESCRIPTOR ADDRESS FOR GLOBAL SECTION NAME
					;ADDRESS OF IDENTIFICATION QUAD WORD
	MOVL	R9,R6			;SECTION FLAGS
	BSBW	MMG$GSDSCN		;SCAN FOR THE NAME
;
; R4 = SHARED MEMORY CONTROL BLOCK ADR IF GLOBAL SECTION IS IN SHARED MEMORY
; R5 RETURNED WITH SYSTEM PROCESS HEADER ADDRESS WHETHER SUCCESSFUL OR NOT
; R10 =   0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	  -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	  >0 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED
;
	BLBS	R0,CRMPSC_FOUND		;BRANCH IF SECTION ALREADY EXISTS
	CMPW	#SS$_NOSUCHSEC,R0	;CONTINUE WITH CREATION IF NOT FOUND
	BNEQ	ULKGSDMTXRET1		;BRANCH IF SOME OTHER ERROR
;
; GLOBAL SECTION NAME DOESN'T EXIST, CREATE A NEW ONE
; ALLOCATE A GLOBAL SECTION DESCRIPTOR BLOCK
;  0(SP) - 43(SP) = GSD NAME COUNTED STRING
; 44(SP) - 51(SP) = IDENTIFICATION QUAD WORD
;

	ASSUME	PRV$V_SYSGBL EQ PRV$V_PRMGBL+1
	ASSUME	SEC$V_SYSGBL EQ SEC$V_PERM+1
	MOVL	@#CTL$GL_PHD,R11	;YES, THEN CHECK FOR PRIVILEGE TO DO SO
	EXTZV	#PRV$V_PRMGBL,#2,(R11),R0 ;GET PRIVILEGES FOR PERM AND SYS
	EXTZV	#SEC$V_PERM,#2,R9,R1	;GET DESIRED PERMANENT AND SYSTEM WIDE FLAGS
	BICL	R0,R1			;IF ANY DESIRED BITS STILL LEFT ON
	BNEQ	CRMPSC_NOPRIV		;THEN NO PRIV FOR REQUESTED OPERATION
	BBC	#SEC$V_PFNMAP,R9,26$	;IS PFNMAPPING REQUESTED?
	BBC	#PRV$V_PFNMAP,PHD$Q_PRIVMSK(R11),CRMPSC_NOPRIV ;NEEDS PRIV
26$:	BBC	#SEC$V_RESIDENT,R9,30$	;IS RESIDENT SECTION REQUESTED?
	BBS	#PRV$V_CMKRNL,PHD$Q_PRIVMSK(R11),30$ ;NEEDS PRIV
	BRB	CRMPSC_NOPRIV		;REPORT NO PRIV TO DO PFNMAP
CRMPSC_PROCESS:				;BRANCH ASSIST TO PROCESS SECTION MAP
	BRW	MAP_PROCESS_SEC		;GO MAP PROCESS SECTION
;
; ERROR IN SECTION FLAGS AND TYPE OF SECTION REQUESTED
;
FLAG_ERROR:
	MOVZWL	#SS$_IVSECFLG,R0	;REPORT INVALID SECTION FLAGS
28$:	BRB	ULKGSDMTXRET1		;RETURN ERROR STATUS TO CALLER
;
; NO PRIVILEGE TO CREATE OR MAP THE GLOBAL SECTION
;
CRMPSC_NOPRIV:
	MOVZWL	#SS$_NOPRIV,R0		;NO PRIVILEGE FOR REQUESTED OPERATION
ULKGSDMTXRET1:
	BRW	ULKGSDMTXRET
ILL_PAG_CNT:
	MOVZBL	#SS$_ILLPAGCNT,R0	;REPORT SECTION HAS NO PAGES IN IT
	BRB	ULKGSDMTXRET1		;RETURN TO CALLER
SHM_NOT_MAP:
	MOVZWL	#SS$_SHMGSNOTMAP,R0	;REPORT SECTION IS NOT BEING MAPPED
	BRB	ULKGSDMTXRET1		;RETURN TO CALLER
					;R5=SYSTEM PROCESS HEADER ADR
30$:	MOVL	SECPAGCNT(AP),R7	;SET COUNT OF PAGES IN SECTION
	BLSS	ILL_PAG_CNT		;ERROR, ILLEGAL PAGE COUNT
	TSTL	R10			;IS SECTION IN SHARED MEMORY?
	BLEQ	LOCAL_MEM_GSD		;BR ON NO
	TSTL	R7			;IS A NON-ZERO PAGECOUNT SPECIFIED?
	BEQL	ILL_PAG_CNT		;BR ON NO, THIS IS NOT IMPLEMENTED
	BBC	#PRV$V_SHMEM,PHD$Q_PRIVMSK(R11),CRMPSC_NOPRIV ;SHMEM PRIV NEEDED
	BBS	#SEC$V_CRF,R9,FLAG_ERROR  ;SHARED MEMORY CAN'T BE CRF
	BBS	#SEC$V_PFNMAP,R9,FLAG_ERROR	;SHMEM CANNOT BE PFNMAP
	BBS	#SEC$V_PAGFIL,R9,FLAG_ERROR	;SHMEM CANNOT ALSO BE PAGFIL
	BBC	#SEC$V_PERM,R9,FLAG_ERROR ;SHARED MEMORY MUST BE PERMANENT
	BBSS	#SEC$V_SHMGS,R9,31$	;INDICATE SECTION IS IN SHARED MEMORY
31$:	BBC	#SEC$V_DZRO,R9,32$	;IF NOT DZRO, THEN NEED NOT BE MAPPED
	TSTL	RELPAG(AP)		;FOR SH MEM GS, ALL SECTION MUST BE
	BNEQ	SHM_NOT_MAP		;MAPPED OTHERWISE IT CAN'T BE INITED
	MOVL	<<11*4>+8+4>(SP),R0	;THIS MEANS RELPAG MUST BE ZERO AND
	BEQL	SHM_NOT_MAP		;THE INPUT ADDRESS RANGE MUST SPECIFY
	MCOML	R0,R0			;A VALID RANGE OF ADDRESSES (MINUS
	BEQL	SHM_NOT_MAP		;ONE AND ZERO ARE NOT VALID)
					;R4=SHARED MEMORY CONTROL BLOCK ADR
32$:	BSBW	MMG$ALOSHMGSD		;ALLOCATE A SHARED MEMORY GSD
	BLBC	R0,28$			;BR IF UNABLE TO GET A GSD
					;R4=SHARED MEMORY CONTROL BLOCK ADR
	BSBW	MMG$ALOSHMPAG		;ALLOCATE PAGES OF SHARED MEMORY
	BLBC	R0,RELEAS_GSD_RET	;BR IF COULDN'T GET ENOUGH PAGES
	MOVAB	GSD$T_GSDNAM(R6),R0	;GET ADDRESS OF GSD ASCIC NAME FIELD
	MOVL	SP,R1			;POINT TO ASCIC NAME STRING TO STORE
	BSBB	MOVGSDNAM		;MOVE GLOBAL SECTION NAME INTO GSD
	TSTL	R8			;IS GS MAPPED TO A FILE?
	BNEQ	COMMON_INIT1		;BR IF MAPPED TO A FILE
	BRW	NO_FILE_INIT		;BR IF NOT MAPPED TO A FILE
;
COMMON_INIT1:
	BRW	COMMON_INIT		;SKIP EXTGSD SPECIFIC INITIALIZATION
PFNMAP_GSD_1:
	BRW	PFNMAP_GSD
;
LOCAL_MEM_GSD:
	BBS	#SEC$V_PFNMAP,R9,PFNMAP_GSD_1 ;BR IF PFNMAP AS GSD IS LARGER
	MOVZBL	(SP),R1			;GET SIZE OF GLOBAL SECTION NAME
	ADDL2	#GSD$C_LENGTH,R1	;CALCULATE TOTAL GSD STRUCTURE SIZE
	PUSHL	R1			;SAVE GSD SIZE FOR LATER
	JSB	G^EXE$ALOPAGED		;ALLOCATE FROM PAGED POOL
	MOVL	(SP)+,R1		;RESTORE GSD SIZE FOR LATER
	BLBS	R0,NORMAL_GSD		;BRANCH IF ONE AVAILABLE
	MOVZWL	#SS$_GSDFULL,R0		;GLOBAL SECTION DESCRIPTOR TABLE FULL
37$:	BRW	ULKGSDMTXRET		;UNLOCK THE MUTEX AND RETURN ERROR
;
MOVGSDNAM:
	PUSHR	#^M<R2,R3,R4,R5>	;SAVE SOME REGS TO BE SAFE
	MOVL	R1,R2			;NAME POINTER FOR HASH
	MOVZBL	(R2)+,R3		;NAME LENGTH
	CLRL	R4			;HASH ACCUMULATOR
10$:	ADDB	(R2)+,R4		;CALCULATE A SIMPLE HASH
	SOBGTR	R3,10$
	MOVB	R4,GSD$B_HASH(R6)	;SAVE IT
	MOVZBW	(R1)+,R2		;GET GLOBAL SECTION NAME LENGTH
	MOVB	R2,(R0)+		;STORE NAME LENGTH IN GSD
	MOVC3	R2,(R1),(R0)		;MOVE NAME STRING INTO GSD
	POPR	#^M<R2,R3,R4,R5>	;RESTORE THE REGISTERS
	RSB
;
RELEAS_PAG_RET:
	MOVZBL	#SHD$V_BITMAPLCK,R0	;NUMBER OF BIT LOCK REQUESTED
	BSBW	MMG$SHMTXLK		;REQUEST MUTEX AND BIT LOCK
; **********
; AT SOME TIME THIS SHOULD SEND A MESSAGE TO THE ERROR LOGGER.
; **********
	BLBC	R0,34$			;UNABLE TO GET BIT LOCK
	BSBW	MMG$SET_BITMAP		;RELEASE ALL PAGES ALLOCATED FOR GS
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),33$ ;RELEASE BIT LCK
33$:	BSBW	MMG$SHMTXULK		;RELEASE SHM MUTEX
	BRB	34$			;JOIN COMMON CODE
RELEAS_GSD_RET:				;R0 CONTAINS ERROR CODE
	PUSHL	R0			;REMEMBER RETURN STATUS CODE
34$:	MOVZBL	#1,R0			;ONE REFERENCE COUNT THAT LOCKS GSD
	JSB	G^MMG$DECSHMREF		;IS GIVEN BACK
	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),35$ ;UNLOCK THE GSD
35$:	MOVZBL	SHB$B_PORT(R4),R1	;GET PORT # FOR THIS PROCESSOR
	DECL	SHB$L_REFCNT(R4)	;ONE LESS GSD OWNED BY THIS PORT
	ADAWI	#1,SHD$W_GSDQUOTA(R5)[R1] ;GIVE SHM GSD QUOTA BACK TO PORT
	MOVL	(SP)+,R0		;RESTORE RETURN STATUS CODE
	BRB	37$			;ERROR RETURN
NORMAL_GSD:
	MOVL	R2,R6			;ADDRESS OF NEW GSD
	MOVW	R1,GSD$W_SIZE(R6)	;FILL IN SIZE OF GSD
	MOVB	#DYN$C_GSD,GSD$B_TYPE(R6) ;AND TYPE CODE
	MOVAB	GSD$T_GSDNAM(R6),R0	;LOAD POINTER TO ASCIC NAME FIELD IN GSD
	MOVL	SP,R1			;COPY POINTER TO ASCIC NAME STRING
	BSBB	MOVGSDNAM		;MOVE GLOBAL SECTION NAME INTO GSD
	BRB	COMMON_INIT		;SKIP EXTGSD SPECIFIC INITIALIZATION
;
36$:	MOVZWL	#SS$_GSDFULL,R0		;GLOBAL SECTION DESCRIPTOR TABLE FULL
	BRW	ULKGSDMTXRET		;UNLOCK THE MUTEX AND RETURN ERROR
;
PFNMAP_GSD:
	MOVZBL	(SP),R1			;GET SIZE OF GLOBAL SECTION NAME STRING
	ADDL2	#GSD$C_EXTGSDLNG,R1	;CALCULATE TOTAL SIZE OF EXTENDED GSD
	PUSHL	R1			;SAVE GSD SIZE FOR LATER
	JSB	G^EXE$ALOPAGED		;ALLOCATE FROM PAGED POOL
	MOVL	(SP)+,R1		;RESTORE GSD SIZE
	BLBC	R0,36$			;BRANCH IF NONE AVAILABLE
	MOVL	R2,R6			;REMEMBER ADDRESS OF NEW EXTGSD
	MOVW	R1,GSD$W_SIZE(R6)	;FILL IN SIZE OF EXTGSD
	MOVB	#DYN$C_EXTGSD,GSD$B_TYPE(R6) ;AND TYPE CODE
	MOVAB	GSD$T_PFNGSDNAM(R6),R0	;POINT TO DESTINATION OF NAME STRING
	MOVL	SP,R1			;POINT TO ASCIC NAME STRING ITSELF
	BSBW	MOVGSDNAM		;MOVE GLOBAL SECTION NAME INTO GSD
	CLRL	GSD$L_REFCNT(R6)	;INITIALIZE REFERENCE TO SECTION
	MOVL	PFN(AP),GSD$L_BASEPFN(R6) ;FILL IN STARTING PFN FOR SECTION
	MOVL	R7,GSD$L_PAGES(R6)	;AND NUMBER OF PAGES IN SECTION
	BNEQ	NO_FILE_INIT		;BR IF PAGE COUNT VALID
	BRW	ILL_PAG_CNT		;BR IF BAD PAGE COUNT
NO_FILE_INIT:
	MOVW	PROT(AP),GSD$W_PROT(R6)	;AND PROTECTION FOR SECTION
	CLRW	GSD$W_GSTX(R6)		;SET NO SECTION TABLE INDEX
	CLRL	R10			;REMEMBER NO SECTION TABLE ENTRY
	CLRL	GSD$L_FILUIC(R6)	;0 INDICATES BYPASS FILE PROT CHECK
COMMON_INIT:
	MOVL	G^SCH$GL_CURPCB,R0	;GET PCB ADDRESS
	MOVL	PCB$L_UIC(R0),GSD$L_PCBUIC(R6) ;SET UIC OF CREATOR FROM PCB
	ADDL2	#<11*4>,SP		;CLEAN GS NAME OFF STACK
	MOVQ	(SP)+,R0		;R0=MATCH CONTROL, R1=IDENTIFICATION DATA
	INSV	B^MMG$L_MAXACMODE(FP),#SEC$V_AMOD,- ;SET THE ACCESS
		#SEC$S_AMOD,R9		;MODE OF THE SECTION
	MOVW	R9,GSD$W_FLAGS(R6)	;FILL IN SECTION FLAGS
	CMPL	R0,#SEC$K_MATLEQ	;VALID MATCH CONTROL
	BGTR	BADMATCHCTL		;BRANCH IF NOT
	MOVL	R1,GSD$L_IDENT(R6)	;SET GLOBAL SECTION IDENT
	BBS	#SEC$V_PFNMAP,R9,BRW_70$  ;BR IF NO SECTION TABLE ENTRY
;
; ALLOCATE A GLOBAL SECTION TABLE ENTRY FOR THE NEW SECTION
; R4 = SHARED MEMORY CONTROL BLOCK ADDRESS IF GLOBAL SECTION IS IN SHARED MEM
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R6 = GLOBAL SECTION DESCRIPTOR ADDRESS
; R7 = COUNT OF PAGES IN SECTION
; R8 = CHANNEL CONTROL BLOCK ADDRESS, OR
;    = 0 IF PFNMAP OR PAGFIL SECTION
; R9 = SECTION FLAGS
; R10 = SECTION TABLE ENTRY ADDRESS, OR
;     = 0 IF PFNMAP SECTION
; 0(SP) = STARVA
; 4(SP) = ENDVA
; 8(SP) = SUCCESS CODE FOR MAP GLOBAL SECTION
;
MAP_TO_FILE:
	BSBW	INITSECTBL		;ALLOCATE AND INIT SECTION TABLE
					;R2 AND R3 DESTROYED
	BLBC	R0,GSTFULL1		;BRANCH IF NONE AVAILABLE
	MOVW	SEC$W_FLAGS(R10),GSD$W_FLAGS(R6) ;RECORD FLAGS IN GSD
;
; R1  = SECTION TABLE INDEX
; R7  = SECTION PAGE COUNT
; R10 = SECTION TABLE BASE ADDRESS
;
	MOVW	R1,GSD$W_GSTX(R6)	;SAVE SECTION INDEX
	CLRL	GSD$L_FILUIC(R6)	;ASSUME NO FILE PROTECTION CHECK
	MOVL	SEC$L_WINDOW(R10),R0	;GET WINDOW ADDRESS
	BEQL	392$			;NO WINDOW - PAGE FILE BACKING STORE
	MOVL	WCB$L_FCB(R0),R0	;CHAIN TO FCB ADDRESS
	BEQL	38$			;BRANCH IF NOT AN FCP WINDOW
	BISW3	PROT(AP),FCB$W_FILEPROT(R0),- ;SET POSSIBLY RESTRICTED
		GSD$W_PROT(R6)		;FILE PROTECTION
	MOVL	FCB$L_FILEOWNER(R0),R0	;AND FETCH THE FILE'S OWNER
38$:	MOVL	R0,GSD$L_FILUIC(R6)	;SET FILE OWNER INTO GSD
					;0 INDICATES BYPASS FILE PROT CHECK
	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS GS IN SHARED MEMORY?
39$:	BEQL	SHM_GS_MAP		;BR ON YES, GO READ SECTION INTO MEMORY
;
; GET GLOBAL PAGE TABLE ENTRIES
;
391$:	ADDL3	#3,R7,R1		;PAGCNT + 2 FOR STOPPER ENTRIES
	BICL	#1,R1			;ROUND UP TO EVEN NO. OF LONG WORDS
	MULL	#4,R1			;DESIRED NO. OF BYTES OF GPTE
	MOVAL	G^EXE$GL_GPT,R3		;GPT ALLOCATION LIST HEAD
	JSB	G^EXE$ALLOCATE		;GET SOME GPT
	BLBS	R0,40$			;BRANCH IF GOT SOME
	BRW	GPTFULL			;GLOBAL PAGE TABLE FULL

BRW_70$:
	BRW	70$			;BRANCH ASSIST
SHM_GS_MAP:
	CLRL	SEC$L_REFCNT(R10)	;DON'T USE SEC TBL REFCNT FOR SH MEM GS
	BRW	MAPGBLSEC2		;GO MAP THE SECTION
;
;
; BAD MATCH CONTROL FIELD FOR SECTION
;
BADMATCHCTL:				;BAD MATCH CONTROL FIELD
	MOVZWL	#SS$_IVSECIDCTL,R0	;INVALID SECTION IDENT CONTROL
GSTFULL1:
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BLEQU	BRGSTFULL		;BR IF LOCAL MEMORY OR EXTENDED GSD
	PUSHL	R0			;SAVE ERROR STATUS CODE
	BRW	RELEAS_PAG_RET		;BR IF SHARED MEMORY GSD
;
; CHECK FOR PAGE FILE LIMIT EXCEEDED AND FILL IN PROTECTION
;
392$:	MOVW	PROT(AP),GSD$W_PROT(R6)	;PROTECTION REQUESTED FOR THE GLOBAL SECTION
	SUBL	SEC$L_PAGCNT(R10),MMG$GL_GBLPAGFIL
	BGEQ	391$			;NO PROBLEMS
	ADDL3	SEC$L_PAGCNT(R10),MMG$GL_GBLPAGFIL,R0
	PUSHL	#SS$_EXGBLPAGFIL
	BRW	FRESTXERR		;THIS WILL ALSO FIX UP THE LIMIT
;
BRGSTFULL: BRW	GSTFULL
;
;
; INITIALIZE GLOBAL PAGE TABLE ENTRIES
;
; R2 = ADDRESS OF FIRST GPTE ALLOCATED, FRONT STOPPER GPTE
; R7 = DESIRED SECTION PAGE COUNT
; R10 = SECTION TABLE ENTRY ADDRESS
;
40$:	CLRL	(R2)+			;SET FRONT STOPPER FOR GLOBAL SECTION
	MOVL	R2,R3			;FIRST GPTE ADDRESS
	SUBL	MMG$GL_GPTBASE,R2	;BYTE OFFSET FROM BEGINNING OF GPT
	DIVL	#4,R2			;LONG WORD OFFSET = GPTX
	BISL	R2,SEC$L_VPXPFC(R10)	;PUT GPTX IN (PFC ALREADY PRESENT)
;
; R3 = ADDRESS OF FIRST GLOBAL PTE TO FILL IN
; R5 = PROCESS HEADER ADDRESS FOR SYSTEM
; R7 = SECTION PAGE COUNT
;
	MOVL	#2@PTE$V_OWN,R2		;GLOBAL DZRO FORMAT FOR PAGE FILE BACKING STORE
	BBS	#SEC$V_PAGFIL,R9,45$	;PAGE FILE BACKING STORE
	ASSUME	SEC$V_DZRO EQ SEC$V_CRF+1 ;REQUIRE BITS TO BE ADJACENT
	ASSUME	SEC$V_WRT EQ SEC$V_DZRO+1
	EXTZV	#SEC$V_CRF,#3,SEC$W_FLAGS(R10),R2 ;CRF, DZRO, AND WRT BITS
	BISW	#<PTE$M_TYP1 ! PTE$M_TYP0 !- ;SECTION TYPE PTE
		<2@PTE$V_OWN>>@-16,R2	;OWNER FIELD USED FOR GLOBAL BITS
	ASSUME	GSD$W_GSTX GE 2
	MOVL	GSD$W_GSTX-2(R6),R1	;HIGH 16 BITS OF R1 = SEC TBL INDEX
	ASHQ	#16,R1,R1		;R2 = PAGE TABLE ENTRY
	BBC	#SEC$V_WRT,SEC$W_FLAGS(R10),50$ ;BRANCH IF NOT WRITABLE
45$:	BBSS	#PTE$V_OWN,R2,50$	;SET GBLWRT BIT IN OWNER FIELD
50$:
;
; R7 = COUNT OF GLOBAL PAGE TABLE ENTRIES TO LOCK AND FILL IN
; R2 = PAGE TABLE ENTRY TO STORE IN NEW GPTE'S
; R3 = ADDRESS OF FIRST GLOBAL PAGE TABLE ENTRY
;
	PUSHR	#^M<R3,R7>
60$:	MOVB	#IPL$_SYNCH,(R3)	;SET UP TO REFERENCE PAGE AND
	MTPR	(R3),W^PRIPL		;FAULT IN CODE AND RAISE TO SYNCH
					;ALL IN ONE INSTRUCTION
	JSB	G^MMG$INCPTREF		;LOCK THE GLOBAL PAGE TABLE
	BBC	#SEC$V_RESIDENT,R9,65$	;NOT RESIDENT
	BSBB	100$			;CALCULATE A NEW R2 AMONG OTHER THINGS
65$:	SETIPL	#IPL$_ASTDEL		;BACK TO PAGE FAULTABLE STATE
	MOVL	R2,(R3)+		;STORE NEW GPT ENTRY
	SOBGTR	R7,60$			;LOOP THROUGH SPECIFIED NO. OF PTE'S
	CLRL	(R3)			;ZERO STOPPER AT END OF GLOBAL SECTION
	POPR	#^M<R3,R7>		;RESTORE THE INITIAL SVAGPT AND COUNT
	BBC	#SEC$V_RESIDENT,R9,70$	;NOT RESIDENT
	BSBW	READ_RESIDENT		;INITIALIZE THE CONTENTS
70$:	EXTZV	#SEC$V_SYSGBL,#1,R9,R0	;SYSTEM OR GROUP GLOBAL BIT
	MOVAQ	G^EXE$GL_GSDGRPFL[R0],R0 ;ADDRESS OF APPROPRIATE LIST

;
; QUEUE THE NEW GSD ON THE FRONT OF THE APPROPRIATE LIST.  PLACING IT ON THE
; FRONT ALLOWS FOR THE INSTALLATION OF A NEW COPY OF SAY A FORTRAN OTS WITH
; AN IDENT THAT IS GREATER THAN THE OLD BUT UPWARD COMPATIBLE.  THE NEW ONE
; IS FOUND FIRST IF THE MATCH IS MATLEQ.  THE OLD ONE IS STILL AVAILABLE FOR
; MATCH EQUAL.
;
	INSQUE	(R6),(R0)		;PLACE GSD ON THE SYSTEM OR GROUP GLOBAL LIST
	BRW	MAPGBLSEC2		;GO MAP THE SECTION

;
; SET UP ONE PAGE OF A RESIDENT GLOBAL SECTION
; ALLOCATE A PFN AND SET UP PFN DATA BASE
; CALCULATE THE NEW PTE CONTENTS
;
100$:	MOVQ	R2,-(SP)
	JSB	MMG$ALLOCPFN		;GET A PHYSICAL PAGE
	MOVQ	(SP)+,R2
	TSTL	R0			;DID WE GET A PAGE
	BLSS	120$			;NO - GO WAIT
	INSV	R0,#PTE$V_PFN,#PTE$S_PFN,R2 ;ADD PFN TO PTE
	BICL	#PTE$M_TYP0!PTE$M_TYP1,R2 ;CLEAR THE SECTION INDICATOR
	BBSS	#PTE$V_VALID,R2,110$	;SET THE VALID BIT TO INDICATE RESIDENT 
110$:	MOVB	#PFN$C_ACTIVE,@PFN$AB_STATE[R0]
	MOVB	#PFN$C_GLOBAL,@PFN$AB_TYPE[R0]
	MOVL	R3,@PFN$AL_PTE[R0]
	MOVW	#1,@PFN$AW_REFCNT[R0]
	MOVZWL	GSD$W_GSTX(R6),@PFN$AL_BAK[R0]
	BISL	#PTE$M_TYP0,@PFN$AL_BAK[R0] ;INDICATE SECTION BACKING STORE
	RSB

120$:	MOVL	SCH$GL_CURPCB,R4
	MOVAQ	SCH$GQ_FPGWQ,R0		;WE WILL BE ON FREE PAGE WAIT QUEUE
	JSB	MMG$PGFLTWAIT		;PUT PROCESS ON THE QUEUE
	MOVPSL	-(SP)			;CONSTRUCT PC-PSL TO RETURN HERE
	JSB	MMG$SVPCTX		;WE GET BACK BY REI
	BRB	100$			;GO TRY AGAIN

PRIPL:					;THE PROCESSOR REGISTER NUMBER IS
	.LONG	PR$_IPL			;PLACED IN THIS LOCATION, INSTEAD OF
					;BEING REFERENCED SYMBOLICALLY ABOVE,
					;TO FAULT IN THE CODE THAT IS TO BE
					;EXECUTED AT RAISED IPL.
	ASSUME	<.-60$> LE 512		;PREVENT INTERVENING PAGE

;
; GLOBAL PAGE TABLE FULL
; R0 = SYSTEM STATUS CODE
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R10 = SECTION TABLE ENTRY ADDRESS
;
GPTFULL:
	PUSHL	#SS$_GPTFULL		;GLOBAL PAGE TABLE FULL
FRESTXERR:
	TSTL	SEC$L_WINDOW(R10)
	BNEQ	79$
	ADDL	SEC$L_PAGCNT(R10),MMG$GL_GBLPAGFIL ;PAGE FILE BACKING STORE - ADJUST LIMIT
79$:	CLRL	SEC$L_GSD(R10)		;GSD WILL BE DELETED BELOW
	ASSUME SEC$L_PAGCNT EQ SEC$L_REFCNT+4 ;FIELDS MUST BE ADJACENT
	CLRQ	SEC$L_REFCNT(R10)	;SET INDICATORS FOR DELGBLSEC
	BBCC	#SEC$V_PERM,SEC$W_FLAGS(R10),80$ ;LET SECTION BE DELETED
80$:	BBSSI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),90$ ;SET DELETION FLAG
90$:	JSB	MMG$DALCSTXSCN		;SCAN FOR SECTIONS TO DEALLOCATE
	MOVL	(SP)+,R0		;GET ERROR CODE
;
; GLOBAL SECTION TABLE FULL
; R0 = SYSTEM STATUS CODE
;
GSTFULL:
	PUSHL	R0			;REMEMBER ERROR CODE TO RETURN
	MOVL	R6,R0			;SET ADR OF BLOCK TO BE DEALLOCATED
	JSB	G^EXE$DEAPAGED		;RELEASE GLOBAL SECTION DESCRIPTOR
	BRB	ULKGSDMTXRET2		;GO UNLOCK GSD MUTEX
;
; UNLOCK THE GLOBAL SECTION MUTEX AND RETURN WITH STATUS CODE IN R0
;
ULKGSDMTXRET:
	PUSHL	R0			;SAVE STATUS CODE
ULKGSDMTXRET2:
	BSBW	MMG$GSDMTXULK		;UNLOCK THE GSD MUTEX
					;RETURNS R4=PCB ADR FOR MMG$DELGBLWCB
	BSBW	MMG$DELGBLWCB		;DELETE ANY GLOBAL WINDOW CONTROL BLOCKS
	POPL	R0			;RESTORE ERROR STAUS CODE TO RETURN
	SETIPL	B^MMG$L_CALLEDIPL(FP)	;RESTORE CALLER'S IPL
MAPSEC_RET:
	RET

	.DSABL	LSB

	.SBTTL	MGBLSC - MAP GLOBAL SECTION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THE MAP GLOBAL SECTION SYSTEM SERVICE MAPS A SPECIFIED GLOBAL
; SECTION INTO A SPECIFIED RANGE OF VIRTUAL ADDRESS SPACE.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$MGBLSC
;
; INPUT PARAMETERS:
;
;	INADR(AP) = ADDRESS OF 2 LONG WORDS THE 1ST OF WHICH SPECIFIES
;		THE STARTING VIRTUAL ADDRESS TO CREATE, THE 2ND SPECIFIES
;		THE ENDING VIRTUAL ADDRESS TO CREATE (INCLUSIVE).
;	RETADR(AP) = ADDRESS OF A 2 LONGWORD ARRAY INTO WHICH IS RETURNED
;		THE STARTING AND ENDING VIRTUAL ADDRESSES (INCLUSIVE)
;		OF THE PAGES JUST CREATED
;	ACMODE(AP) = THE ACCESS MODE (MAXIMIZED WITH CALLING MODE)
;		USED AS THE OWNER OF THE NEW PAGE(S)
;	FLAGS(AP)  = BIT  0  - GBL - GLOBAL IF SET, PROCESS IF CLEAR
;		     BIT  1  - CRF - COPY ON REFERENCE
;		     BIT  2  - DZRO - DEMAND ZERO
;		     BIT  3  - WRT - WRITABLE IF SET, READ ONLY IF CLEAR
;		     BITS 4 - 5, RESERVED, MUST BE ZERO
;		     BITS 6 & 7 - WRTMOD - WRITE ACCESS FOR SECTION
;		     BITS 8 - 13 RESERVED, MUST BE ZERO
;		     BIT  14 - PERM - PERMANENT IF SET, TEMPORARY IF CLEAR
;		     BIT  15 - SYSGBL - SYSTEM GLOBAL IF SET, GROUP GLOBAL IF CLEAR
;		     BIT  16  - PFNMAP - MAP TO SPECIFIC PFN'S, IF SET
;		     BIT  17  - EXPREG - MAP TO FIRST FREE SPACE AVAILABLE
;		     BIT  18 - PROTECT - SET IF WRITE ACCESS MODE SPECIFIED
;		     BITS 19  - 31 RESERVED, MUST BE ZERO
;	GSDNAM(AP) = THE DESCRIPTOR OF THE GLOBAL SECTION NAME
;	IDENT(AP)  = ADDRESS OF QUAD WORD CONTAINING SECTION IDENTIFICATION
;		     FIRST LONG WORD CONTAINS THE MATCH CONTROL INFORMATION
;			0 = ISD$K_MATALL, MATCH ALWAYS
;			1 = ISD$K_MATEQU, MATCH IF IDENTS ARE EQUAL
;			2 = ISD$K_MATLEQ, MATCH IF HIGH 8 BITS ARE EQUAL
;			    AND LOW 24 BITS ARE LESS THAN OR EQUAL TO
;			    THE ID STORED IN THE GLOBAL SECTION.
;		     SECOND LONG WORD CONTAINS THE IDENT TO BE COMPARED
;	RELPAG(AP) = RELATIVE PAGE IN SECTION TO START MAPPING
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESS
;	SS$_IVSECFLG - INVALID SECTION FLAGS
;	SS$_ENDOFFILE - END OF FILE ENCOUNTERED
;	SS$_NOPRIV - NO PRIVILEGE FOR ATTEMPTED OPERATION
;	SS$_VASFULL - VIRTUAL ADDRESS SPACE FULL
;	SS$_IVLOGNAM - INVALID LOGICAL NAME
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAMES (DEPTH > 10)
;	SS$_SHMNOTCNCT - SHARED MEMORY DATA STRUCTURES NOT CONNECTED
;	SS$_NOSUCHSEC - NO SUCH GLOBAL SECTION
;	SS$_PAGOWNVIO - PAGE OWNER VIOLATION (RE-MAPPING PAGES ALREADY IN USE)
;	SS$_EXQUOTA - EXCEEDED PAGING FILE QUOTA (FOR CRF SECTIONS)
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC

INADRERR:
	RET
;
; **********************************************************************
;

	.PSECT	Y$EXEPAGED		;PUT ENTRY POINT INTO SEPARATE PSECT

;*************  EXE$MGBLSC  ENTRY POINT

	.ENTRY	EXE$MGBLSC,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	JMP	EXE_MGBLSC		;TRANSFER TO REAL PROCEDURE

	.PSECT	YF$$SYSCRMPSC		;BACK TO $CRMPSC PSECT

EXE_MGBLSC:
	SUBL	S^#-MMG$C_LENGTH,SP	;RESERVE A SCRATCH STORAGE AREA
	JSB	G^MMG$INADRINI		;GET INPUT RANGE TO R4, R5
					;INIT RETURN RANGE AND SCRATCH AREA
	BLBC	R0,INADRERR
	PUSHL	#0			;REMEMBER NO START RETADR YET
	PUSHL	#SS$_NORMAL		;SAVE SUCCESS RETURN CODE
	PUSHR	#^M<R4,R5>		;PUSH ENDVA, STARTVA
	MOVL	FLAGS(AP),R0		;SECTION FLAGS
	BSBW	MMG$VFYSECFLG		;VERIFY SECTION FLAGS
	MOVL	R0,R9			;USE VERIFIED SECTION FLAGS
	MOVL	G^SCH$GL_CURPCB,R4	;PROCESS CONTROL BLOCK ADDRESS
	MOVAL	G^EXE$GL_GSDMTX,R0	;GLOBAL SECTION MUTEX
	JSB	G^SCH$LOCKW		;LOCK GSD FOR WRITING
	JSB	MMG$DALCSTXSCN1		;SCAN FOR SECTIONS TO DELETE
;
; RETURNS AT ASTDEL
;
	SUBL	#<11*4>+8,SP		;RESERVE SPACE FOR GSD NAME AND IDENT
	MOVL	SP,R7			;ADDRESS OF SCRATCH SPACE

	ASSUME	IDENT EQ GSDNAM+4
	MOVQ	GSDNAM(AP),R0		;DESCRIPTOR ADDRESS FOR GLOBAL SECTION NAME
					;ADDRESS OF IDENTIFICATION QUAD WORD
	MOVL	R9,R6			;SECTION FLAGS
	BSBW	MMG$GSDSCN		;SCAN GSD'S FOR THIS NAME
	BLBS	R0,5$			;BRANCH IF SECTION FOUND
	CMPL	#SS$_NOSUCHSEC,R0	;WAS THE ERROR DUE TO SECTION NOT FOUND?
	BNEQ	ULKGSDMTXRET		;IF NO, RETURN ERROR CODE TO CALLER
;
;  0(SP) = ASCIC GLOBAL SECTION NAME STRING
; 44(SP) = IDENT INFORMATION
; 52(SP) = STARTVA
; 56(SP) = ENDVA
; 60(SP) = SUCCESS CODE (SS$_NORMAL OR SS$_EXISTED) TO BE RETURNED IF
;	   MAPPING IS SUCCESSFUL.
; R4 = SHARED MEMORY CONTROL BLOCK ADDRESS IF GLOBAL SECTION IS IN SH MEM
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R6 = GLOBAL SECTION DESCRIPTOR BLOCK ADDRESS
; R9 = SECTION FLAGS
; R10 IS   0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	  -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	  >0 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED

;
; IF THE GLOBAL SECTION WAS NOT FOUND, PERHAPS IT IS BECAUSE THE SECTION IS
; COPY AND REFERENCE AND THERE WAS A LOGICAL NAME WHICH STATED IT WAS IN
; SHARED MEMORY.  SINCE CRF SECTIONS ARE PLACED IN LOCAL MEMORY INSTEAD OF
; SHARED MEMORY, USE THE RESULTANT GLOBAL SECTION NAME AND SEARCH FOR THAT
; IN LOCAL MEMORY.  THIS IS DONE BY FORCING NO LOGICAL TRANSLATION OF THE
; GLOBAL SECTION NAME (PREFIXING IT WITH AN UNDERSCORE).
;
	BSBW	MMG$FINDGSNOTRN		;FIND GSD WITH NO LOGICAL TRANSLATION
5$:	ADDL2	#<11*4>+8,SP		;RECLAIM THE SCRATCH AREA
	BLBC	R0,ULKGSDMTXRET		;BRANCH IF SECTION NOT FOUND
;
MAPGBLSEC1:
	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS GS IN SHARED MEMORY?
	BEQL	7$			;BR ON YES, CAN'T ALWAYS ACCESS SEC TBL
	CVTWL	GSD$W_GSTX(R6),R10	;IS GS MAPPED TO A FILE?
	BEQL	7$			;BR ON NOT MAPPED TO A FILE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R0 ;BASE ADDRESS OF SECTION TABLE
	MOVAL	(R0)[R10],R10		;ADDRESS OF SECTION TABLE ENTRY
7$:	ROTL	#31-SEC$V_CRF,GSD$W_FLAGS(R6),R0 ;GET FLAGS FROM GSD
	BGEQ	10$			;BRANCH IF NOT COPY ON REFERENCE
	BBSS	S^#MMG$V_CHGPAGFIL,B^MMG$L_MAXACMODE(FP),10$
					;MUST CHARGE PAGES AGAINST PAGE FILE QUOTA
10$:	EXTZV	#<SEC$V_AMOD-<SEC$V_CRF+1>>,- ;GET ACCESS MODE OF SECTION
		#SEC$S_AMOD,R0,R0
	CMPB	B^MMG$L_MAXACMODE(FP),R0 ;SEE IF THIS CALLER CAN MAP THE SECTION
	BGTR	MGBLSC_NOPRIV		;BRANCH IF CANNOT MAP THE SECTION
	CMPB	GSD$B_TYPE(R6),#DYN$C_GSD ;WHAT TYPE OF GSD IS THIS?
	BNEQU	MAPGBLSEC2		;BR IF NOT LOCAL MEMORY TYPE
	INCL	SEC$L_REFCNT(R10)	;BIAS THE SECTION REFERENCE COUNT
					;SO THAT IT CAN'T BE DELETED
;
; R5  = SYSTEM PROCESS HEADER ADDRESS
; R9  = SECTION FLAGS
; R10 = SECTION TABLE ENTRY ADDRESS
;
	ASSUME DYN$C_EXTGSD GT DYN$C_GSD
	ASSUME DYN$C_EXTGSD LT DYN$C_SHMGSD
MAPGBLSEC2:
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS EXTENDED GSD?
	BNEQU	MAPGBLSEC3		;BR IF LOCAL MEMORY OR SHARED MEMORY
	INCL	GSD$L_REFCNT(R6)	;YES, BIAS GSD REFCNT SO IT CAN'T
					;BE DELETED BUT MUTEX CAN BE UNLOCKED
MAPGBLSEC3:
	.ENABL	LSB
	PUSHL	R4			;SAVE SHB ADDRESS
	BSBW	MMG$GSDMTXULK		;UNLOCK THE GLOBAL SECTION MUTEX
	POPL	R4			;RESTORE SHB ADDRESS
	MOVL	R6,R11			;SAVE GSD ADR FOR ERROR PATH RECOVERY
	BBC	#SEC$V_EXPREG,R9,MAPGBLSEC4 ;BR IF RANGE IS EXPLICITLY STATED
;
; FIND THE FIRST AVAILABLE VIRTUAL ADDRESS AND COMPUTE THE RANGE TO BE MAPPED.
;
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;WHAT TYPE OF GSD IS THIS?
	BLSSU	30$			;BR IF LOCAL MEMORY GSD
	BEQL	40$			;BR IF EXTENDED GSD
	CLRL	R1			;INITIALIZE COUNT OF PAGES IN SHMGSD
	MOVZBL	#GSD$C_PFNBASMAX,R7	;MAX NUMBER OF BASES ALLOWED
	MOVAB	GSD$L_BASPFN1(R6),R8	;ADR OF FIRST GSD BASE PFN
10$:	TSTL	(R8)+			;IS THIS BASE USED?
	ADDL2	(R8)+,R1		;ADD THESE PAGES INTO SIZE OF SECTION
20$:	SOBGTR	R7,10$			;REPEAT FOR NEXT BASE
	BRB	50$			;JOIN COMMON CODE
30$:	MOVL	SEC$L_PAGCNT(R10),R1	;SIZE OF LOCAL MEMORY GLOBAL SECTION
	BRB	50$			;JOIN COMMON CODE

MGBLSC_NOPRIV:
	BRW	CRMPSC_NOPRIV		;NO PRIV TO MAP GLOBAL SECTION

40$:	MOVL	GSD$L_PAGES(R6),R1	;SIZE OF EXTENDED GSD SECTION
50$:	MOVL	RELPAG(AP),R0		;GET # OF PAGES NOT TO BE MAPPED
	BLSS	55$			;BR IF ILLEGAL NUMBER OF PAGES
	CMPL	R0,R1			;ARE MORE PAGES SKIPPED THAN IN SECTION?
	BGEQ	55$			;BR IF ILLEGAL NUMBER OF PAGES
	SUBL	R0,R1			;GET # OF PAGES IN SECTION TO MAP
	ASHL	#9,R1,R1		;CONVERT PAGE COUNT TO # OF
	DECL	R1			;BYTES BETWEEN START VA AND END VA
	MOVL	@#CTL$GL_PHD,R0		;GET PROCESS HEADER FOR PROCESS
	POPR	#^M<R2,R3>		;FIND REGION TO MAP SECTION INTO
	BBC	#VA$V_P1,R2,60$		;BR IF MAPPING INTO P0 SPACE
	ADDL3	#^X1FF,PHD$L_FREP1VA(R0),R3 ;ENDING VA IN P1 SPACE
	SUBL3	R1,R3,R2		;STARTING VA IN P1 SPACE
	BRB	70$			;JOIN COMMON CODE
55$:	BRW	ILL_RELPAG		;BR TO RETURN ERROR CODE
60$:	MOVL	PHD$L_FREP0VA(R0),R2	;STARTING VA IN P0 SPACE
	ADDL3	R1,R2,R3		;ENDING VA IN P0 SPACE
70$:	PUSHR	#^M<R2,R3>		;REMEMBER VA RANGE TO BE MAPPED
	.DSABL	LSB
;
; BUILD A PAGE TABLE ENTRY TO PUT IN THE PROCESS PAGE TABLE
;
MAPGBLSEC4:
	.ENABLE	LSB
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS A MAP BY PFN?
	BLSSU	6$			;NO, BR TO CREATE LOCAL MEM GPTX PTE
	BEQL	5$			;YES, BR TO CREATE VALID WINDOW PTE
	MOVZBL	#GSD$C_PFNBASMAX,R7	;GET # OF BASES ALLOWED
	MOVAB	GSD$L_BASPFN1(R6),R10	;GET ADR OF FIRST PFN BASE
MAP_NXT_BASE:
	MOVL	(R10)+,R8		;GET PFN BASE FOR FIRST PIECE OF SECTION
	MOVL	(R10)+,R9		;GET SIZE OF FIRST PIECE OF SECTION
	BNEQ	3$			;BR IF MORE SECTION TO MAP
	BRW	NO_MORE_PAGES		;BR IF ALL SECTION MAPPED
3$:	ADDL2	SHB$L_BASGSPFN(R4),R8	;ADD IN BASE PFN FOR GS PAGES
	BBCS	#PTE$V_VALID,R8,4$	;SET VALID BIT IN PTE
4$:	PUSHR	#^M<R9,R10>		;SAVE ADR OF PFN BASES AND PIECE SIZE
	CLRL	R10			;FORCE USE OF GSD FLAGS
	MOVL	MMG$L_VFYFLAGS(FP),R9	;RESTORE FLAGS FOR SETSECPROTOWN CALL
	BSBW	SETSECPROTOWN		;SET SECTION PROTECTION AND OWNER
	POPR	#^M<R9,R10>		;RESTORE ADR OF PFN BASES AND PIECE SIZE
	BRB	8$			;BR PAST NO SECTION TABLE CODE
5$:	CLRL	R10			;REMEMBER NO SECTION TABLE ENTRY EXISTS
	MOVL	GSD$L_BASEPFN(R6),R8	;CREATING VALID PTE
	BISL2	#<PTE$M_VALID ! PTE$M_WINDOW>,R8 ;SET VALID & WINDOW
	BRB	7$			;SKIP PAGE TABLE INDEX
6$:	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,- ;GET THE FIRST GLOBAL
		SEC$L_VPXPFC(R10),R8	;PAGE TABLE INDEX
7$:	BSBW	SETSECPROTOWN		;SET SECTION PROTECTION AND OWNER
8$:	MOVL	R6,R11			;SAVE GSD ADDRESS FOR MMG$MAPSECPAG
	BLBC	R0,13$			;BRANCH IF PROTECTION VIOLATION
	CMPL	#SS$_NORMAL,R0		;WAS THERE AN ALTERNATE SUCCESS CODE?
	BEQL	9$			;BR IF CODE WAS NORMAL SUCCESS
	MOVL	R0,8(SP)		;SET ALTERNATE RETURN CODE

; BECAUSE OF THE REGISTERS NEEDED BY EXE$CHECKPROT_16 FOR INPUT, SAVE
; R2 THROUGH R6 NOW.

9$:	PUSHR	#^M<R2,R3,R4,R5,R6>	;SAVE SOME WORK REGISTERS
;
; R4= SHB ADDRESS, IF GLOBAL SECTION IS IN SHARED MEMORY
; VALIDATE THIS PROCESS' ACCESS TO THIS FILE
; NOTE: SINCE REFCNT IS INCREMENTED ABOVE, GSD CAN'T GO AWAY EVEN THOUGH
; GSD MUTEX IS RELEASED.
;
	MOVAB	GSD$W_PROT(R6),R5	;SET PROTECTION WORD ADDRESS
	MOVL	GSD$L_FILUIC(R6),-(SP)	;GET FILE OWNER
	BNEQ	10$			;USE THE FILE UIC
	MOVL	GSD$L_PCBUIC(R6),(SP)	;NO FILE - USE SECTION CREATOR UIC
;
; CHECK THAT THE CALLER HAS READ OR WRITE ACCESS TO THE SECTION
; ACCORDING TO HOW IT IS TO BE MAPPED.
;
10$:	MOVL	G^SCH$GL_CURPCB,R0	;SET CURRENT PROCESS CONTROL BLOCK ADR
	MOVL	PCB$L_ARB(R0),R0	;GET ACCESS RIGHTS BLOCK
	MOVAB	ARB$L_RIGHTSLIST(R0),R4	;SET RIGHTSLIST ADDRESS
	MOVL	#ARM$M_READ,R3		;SET UP FOR READ ACCESS CHECK
	BBC	#SEC$V_EXECUTE,MMG$L_VFYFLAGS(FP),11$
	MOVPSL	R9
	BBS	#PSL$V_PRVMOD+1,R9,11$	;MAKE SURE PREVIOUS MODE WAS EXEC, KERNEL
	MOVL	#ARM$M_EXECUTE,R3	;SET UP FOR EXECUTE ACCESS CHECK
11$:	BBC	#SEC$V_WRT,MMG$L_VFYFLAGS(FP),12$ ;BR IF NOT WRITING THE SECTION
	CMPB	GSD$B_TYPE(R6),#DYN$C_GSD ;IS IT LOCAL MEMORY GSD
	BNEQ	111$			;NO - NEED WRITE ACCESS
	BBS	#SEC$V_CRF,SEC$W_FLAGS(R10),12$ ;CRF DOESNT NEED WRITE ACCESS
	BBS	#SEC$V_CRF,MMG$L_VFYFLAGS(FP),14$ ;CALLER CAN'T GET CRF
111$:	MOVL	#ARM$M_WRITE,R3		;SET UP FOR WRITE ACCESS CHECK
12$:	MOVL	(SP)+,R6		;GET OBJECT'S OWNER UIC
	MOVAB	ARB$Q_PRIV(R0),R2	;SET PRIV QUADWORD ADDRESS
	JSB	EXE$CHECKPROT_16	;DO SOGW PROTECTION CHECK
	POPR	#^M<R2,R3,R4,R5,R6>	;RESTORE REGISTERS
	BLBS	R0,15$			;BRANCH IF CALLER HAS DESIRED ACCESS
13$:	BRW	PRE_MAP_ERR		;BRANCH IF ACCESS DENIED
;
14$:	MOVZWL	#SS$_IVSECFLG,R0	;INVALID FLAGS SPECIFIED
	BRB	13$
;
; R7 - COUNT OF PFN BASES ALLOWED IN GSD
; R10 - ADR OF NEXT PFN BASE IN GSD
;
15$:	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BLSSU	MAP_LOCAL_MEM		;NO, GO USE SECTION TABLE ENTRY
	BGTRU	SHM_GSD			;NO, GO USE SHARED MEMORY GSD
	MOVL	GSD$L_PAGES(R6),R9	;YES, GET # OF PAGES IN SECTION FROM GSD
	BRB	30$			;SKIP FINDING # PAGES FROM SECTION TBL
SHM_GSD:
	CMPB	#GSD$C_PFNBASMAX,R7	;IS THIS THE FIRST BASE?
	BNEQ	COMMON_MAP		;NO, BR THEN TO SKIP RELPAG OFFSETING
	MOVL	RELPAG(AP),R0		;GET STARTING RELATIVE PAGE TO MAP
	CMPL	R0,R9			;SEE IF RELPAG IS PAST THIS PIECE
	BLSSU	32$			;BR IF MUST MAP PART OF THIS PIECE
20$:	DECL	R7			;DEC COUNT OF PIECES OF SECTION TO MAP
	BNEQ	TRY_NXT_BASE		;BR IF ANOTHER PIECE TO MAP (MAYBE)
ILL_RELPAG:
	MOVZWL	#SS$_ENDOFFILE,R0	;REMEMBER THERE WERE NO PAGES TO MAP
	BRW	PRE_MAP_ERR		;BR IF NO SECTION TO MAP AT ALL
TRY_NXT_BASE:
	MOVL	(R10)+,R8		;GET PFN BASE OF NEXT PIECE
	ADDL2	(R10)+,R9		;ADD NEXT BASE COUNT TO RELPAG OFFSET
	CMPL	R0,R9			;IS RELPAG PAST THIS PIECE?
	BGEQU	20$			;BR IF NOTHING IN THIS PIECE TO MAP
	SUBL2	R0,R9			;GET OFFSET TO FIRST PFN TO MAP
	SUBL3	R9,-4(R10),R0		;GET # OF PAGES IN PIECE NOT MAPPED
	ADDL2	R0,R8			;GET FIRST PFN TO BE MAPPED
	BRW	3$			;BR TO CREATE PTE
MAP_LOCAL_MEM:
	MOVL	SEC$L_PAGCNT(R10),R9	;NUMBER OF PAGES IN THE SECTION
30$:	MOVL	RELPAG(AP),R0		;STARTING RELATIVE PAGE TO MAP
	BLSS	ILL_RELPAG		;BR IF ILLEGAL RELPAG, NEGATIVE
	CMPL	R0,R9			;IS RELPAG WITHIN THE SECTION?
	BGEQ	ILL_RELPAG		;BR IF ILLEGAL RELPAG, PAST SECTION
32$:	SUBL	R0,R9			;FEWER PAGES TO MAP
	ADDL	R0,R8			;BIAS STARTING GPTX
35$:	CMPB	GSD$B_TYPE(R6),#DYN$C_GSD ;IS THIS NORMAL GSD?
	BNEQ	COMMON_MAP		;BR ON NO, DON'T SET TYP0 BIT
	BBSS	#PTE$V_TYP0,R8,COMMON_MAP ;GLOBAL PAGE TYPE
;
; 0(SP) = STARVA, 4(SP) = ENDVA
; R6 = GLOBAL SECTION DESCRIPTOR BLOCK ADDRESS
; R8 = STARTING PTE CONTENTS, R9 = MAXIMUM PAGE COUNT TO MAP
; R10 = GLOBAL SECTION TABLE ADDRESS
;
COMMON_MAP:
	POPR	#^M<R2,R3>		;R2 = STARTVA, R3 = ENDVA
	MCOML	R2,R0			;STARTVA = -1?
	BNEQ	40$
	BRW	84$			;BRANCH IF YES, NO RANGE TO MAP
40$:	CMPB	GSD$B_TYPE(R6),#DYN$C_GSD ;IS THIS NORMAL GSD?
	BNEQ	48$			;NO - DON'T TRY ANY OPTIMIZATIONS
	MOVQ	R2,R4			;GET THE START AND END VA
	JSB	MMG$IN_REGION		;IS IT NEW ADDRESS SPACE
	BLBC	R0,48$			;NO - CREATE IT THE HARD WAY
	CMPL	R6,R9			;CHECK FIT OF SECTION IN THE SPACE
	BNEQ	48$			;NOT EXACT - DO IT THE HARD WAY
	MOVL	SCH$GL_CURPCB,R4
	JSB	MMG$TRY_ALL		;SEE IF REGION CAN BE EXPANDED
	BLBC	R0,48$			;NO - CREATE IT THE HARD WAY
	BSBW	FAST_MAP		;DO IT THE FAST WAY
	PUSHR	#^M<R3,R4,R7,R10>	;NO EFFECT - MATCHES A LATER POPR
	BRB	66$
48$:	DECL	R9			;PAGE COUNT BASE 0
	CMPL	R2,R3			;CHECK DIRECTION OF MAPPING
	BLSSU	60$			;BRANCH IF FORWARDS
	BGTRU	50$			;BRANCH IF BACKWARDS
	BBC	#VA$V_P1,R2,60$		;WHEN EQUAL, FORWARD IF P0, BACKWARDS IF P1
50$:	ADDL	R9,R8			;START AT LAST GPTX WHEN MAPPING BACKWARDS
60$:	MOVAL	W^MMG$MAPSECPAG,R6	;MAP SECTION PAGE ROUTINE
	PUSHR	#^M<R3,R4,R7,R10>	;SAV VA RANGE,SHB,PFNBASCNT,PFNBAS ADR
	CMPB	GSD$B_TYPE(R11),#DYN$C_SHMGSD ;IS THIS A SHARED MEMORY GSD?
	BNEQ	65$			;BR IF IT IS NOT
	CLRL	R10			;INIDICATE NO GST CNT TO INCREMENT
65$:	JSB	G^MMG$CREDEL		;USE THE COMMON CREATE PAGE CODE
	BLBS	R0,66$
	MOVL	R0,16(SP)		;SAVE THE BAD STATUS
66$:	JSB	G^MMG$RETRANGE
	SUBL3	R1,R2,R9		;GET # BYTES ACTUALLY MAPPED
	BGEQ	67$			;BR IF RANGE IS IN INCREASING ORDER
	MNEGL	R9,R9			;NEGATE THE BYTE COUNT, RANGE DECR ORDER
67$:	ASHL	#-9,R9,R9		;CONVERT BYTE COUNT TO PAGE COUNT
	POPR	#^M<R3,R4,R7,R10>	;GET VA RANGE,SHB,PFNBASCNT,PFNBAS ADR
	INCL	R9			;ACTUAL COUNT OF PAGES MAPPED
	BLBS	R0,80$			;IF SUCCESSFUL USE SUCCESS STATUS
					;ALREADY ON TOP OF STACK
70$:	MOVL	R0,(SP)			;OTHERWISE SAVE ERROR STATUS
;
; 0(SP) = SYSTEM STATUS CODE
; R11 = GLOBAL SECTION DESCRIPTOR ADDRESS
;
80$:	CMPB	GSD$B_TYPE(R11),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BLSSU	85$			;NO, BR TO CLEAN UP SECTION TBL ENTRY
	BGTRU	PIECE_MAPPED		;NO, BR IF SHARED MEMORY GSD
82$:	MOVAL	G^EXE$GL_GSDMTX,R0	;GET MUTEX TO LOCK
	MOVL	G^SCH$GL_CURPCB,R4	;GET ADR OF PROCESS PCB
	JSB	G^SCH$LOCKW		;LOCK GSD MUTEX FOR WRITING
	DECL	GSD$L_REFCNT(R11)	;RELEASE THE GSD TO ALLOW DELETION
	BSBW	MMG$GSDMTXULK		;UNLOCK GSD MUTEX
	BRB	90$			;ALL DONE
84$:	CLRL	R9			;INDICATE NO PAGES MAPPED
	BRB	80$			;JOIN COMMON CODE
85$:	CVTWL	GSD$W_GSTX(R11),R1	;SECTION INDEX
	MOVAL	@L^MMG$GL_SYSPHD,R5	;SYSTEM PROCESS HEADER
	JSB	G^MMG$DECSECREF		;REMOVE SECTION REFERENCE BIAS
88$:	MOVL	G^SCH$GL_CURPCB,R4	;GET ADR OF PROCESS PCB
	BSBW	MMG$DELGBLWCB		;DELETE ANY GLOBAL WINDOWS
90$:	POPR	#^M<R0>			;SYSTEM STATUS CODE
	RET				;RETURN STATUS TO CALLER
;
; THE USER REQUESTED THAT NO PAGES BE MAPPED OR THERE WAS AN ERROR BEFORE
; THE PAGES WERE MAPPED.  SHARED MEMORY GSD'S MUST BE MAPPED FOR CREATION; THIS
; IS CHECKED IN $CRMPSC (FOR A VALID RELPAG, ONLY).
;
PRE_MAP_ERR:
	MOVL	R0,(SP)			;SAVE RETURN ERROR CODE
110$:	CMPB	GSD$B_TYPE(R11),#DYN$C_EXTGSD ;WHAT TYPE OF GSD IS THIS?
	BLSSU	85$			;BR IF LOCAL MEMORY
	BEQL	82$			;BR IF EXTENDED GSD
	MOVZBL	#1,R0			;ONE REF COUNT FOR A LOCK
	JSB	G^MMG$DECSHMREF		;RELEASE THE GSD LOCK
	BBS	#GSD$V_VALID,GSD$L_GSDFL(R6),88$ ;BR IF NOT CREATING GS
	BRW	SHM_UNMAPPED		;BR TO DELETE GS AS CANNOT ALWAYS
					;INITIALIZE A SHARED MEMORY GS.
;
; A PIECE OF A SHARED MEMORY GLOBAL SECTION HAS BEEN MAPPED.  UPDATE THE
; RETURN RANGE OF VIRTUAL ADDRESSES MAPPED AND SET UP TO MAP THE NEXT PIECE.
;
PIECE_MAPPED:
	MOVL	R9,R0			;GET COUNT OF PTE'S JUST CREATED
	BEQL	140$			;BR IF NOTHING MAPPED
	MOVL	R11,R6			;RESTORE GSD ADR
	BBS	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),120$ ;BR IF UN-MAPPING GS
					;R4=SHB ADDRESS
	JSB	G^MMG$INCSHMREF		;INCREMENT THE PROCESSOR REF COUNT
	TSTL	4(SP)			;IS START RETADR A VALID ADR?
	BNEQ	120$			;BR ON YES, FIRST ADR MAPPED SET
	MOVL	R1,4(SP)		;ASSUME RETADR NOT SPEC, USE INADR VALUE
120$:	PUSHR	#^M<R2,R3>		;REMEM NEW START VA AND END VA
	INCL	(SP)			;ROUND NEW START VA TO PAGE BOUNDRY
	DECL	R7			;ONE LESS PIECE OF SECTION TO MAP
	BLEQ	NO_MORE_PAGES		;BR IF NO MORE PIECES IN SECTION
	TSTL	4(R10)			;WAS SECTION CREATED IN PIECES?
	BEQL	121$			;BR ON NO, ONE CONTIGUOUS BLOCK OF PAGES
	BISL3	#^X1FF,R3,-(SP)		;GET ENDING ADR, ROUNDED TO LAST BYTE
	CMPL	R2,(SP)+		;IS SECTION MAPPED BACKWARDS?
	BGTRU	125$			;BR IF YES, RETURN ERROR CODE
121$:	BBS	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),122$ ;BR IF UN-MAPPING GS
	BLBC	8(SP),NO_MORE_PAGES	;DON'T TRY TO MAP MORE IF GOT ERROR
122$:	BRW	MAP_NXT_BASE		;BR ON ANOTHER PIECE TO MAP/UNMAP


124$:	BRB	88$			;HOP, SKIP FOR BROKEN BRANCH DISPLACEMENT


125$:	MOVZWL	#SS$_IVSSRQ,8(SP)	;*** BACKWARDS MAPPING IS BROKEN
					;*** FOR MULTIPLE PIECE SECTIONS
;
; NO MORE PIECES OF SHARED MEMORY SECTION LEFT TO MAP.  THIS MAY OR MAY NOT
; BE AN ERROR, DEPENDING UPON WHETHER OR NOT AT LEAST ONE PAGE WAS MAPPED.
;
NO_MORE_PAGES:
	POPR	#^M<R2,R3>		;CLEAN OFF START VA AND END VA
	MOVL	MMG$L_SAVRETADR(FP),R0	;GET ADDRESS OF RETURN ADR BUFFER
	BEQL	140$			;BR ON RETURN ADDRESS NOT REQUESTED
	IFNOWRT	#8,(R0),140$		;CHECK IF BUFFER IS ACCESSIBLE
	MOVL	4(SP),(R0)		;RESET TO VERY 1ST STARTVA IN RET RANGE
140$:	MOVZBL	#1,R0			;ONE REF COUNT FOR THE GSD LOCK
					;R4=SHB ADDRESS
	JSB	G^MMG$DECSHMREF		;REMOVE THE GSD LOCK
	BBSC	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),SHM_UNMAPPED ;BR IF INIT FAILED
	BBSSI	#GSD$V_VALID,GSD$L_GSDFL(R6),124$ ;BR ON $MGBLSC REQUEST
;
; THE GLOBAL SECTION DESCRIPTOR WAS NOT VALID.  THEREFORE, THE GSD IS BEING
; MAPPED DUE TO A $CRMPSC REQUEST.  THE PAGES MUST NOW BE INITIALIZED.
; 
					;R6=GSD,INADR(AP),(SP)=MAP STATUS CODE
	MOVL	4(SP),R2		;STARTVA FOR VERY FIRST PAGE MAPPED
	BSBW	MMG$READ_GSD		;BR TO READ SECTION INTO MEMORY
	BLBC	R0,RELEAS_SHMGS		;BR IF FAILED TO INIT SECTION PAGES
;
; NOW THE SHARED MEMORY GSD TABLE MUST BE SEARCHED, CHECKING FOR SUCCESSFUL
; CREATION OF A GLOBAL SECTION WITH THE SAME NAME AS THE ONE BEING CREATED.
; THIS ALLOWS THE GSD TABLE TO BE OPEN FOR ACCESS DURING THE LENGTHY PROCESS
; OF INITIALIZING THE SECTION PAGES.  HOWEVER, IT ALSO ALLOWS TWO USERS TO
; TRY TO CREATE THE SAME SECTION AT THE SAME TIME.
;
					;R11=GSD,R4=SHB
	BSBW	MMG$UNIQUEGSD		;VALIDATE THAT THE NEW GSD IS UNIQUE
					;R5=SHD,R6=DUPLICATE GSD ADR
	TSTL	R6			;IS THERE A DUPLICATE GSD?
	BEQL	135$			;BR IF THERE IS NOT A DUPLICATE
;
; NOW CHECK THAT THE DUPLICATE GLOBAL SECTION PASSES THE IDENT MATCH CONTROL
; TEST.  IF IT DOES NOT, THEN RETURN AN ERROR CODE TO THE USER.  IF IT DOES
; MATCH, THEN GO MAP THE DUPLICATE.
;
	TSTL	GSD$L_IDENT(R6)		;IS THIS ALWAYS MATCH?
	BEQL	141$			;BR TO USE SECTION IF ALWAYS MATCH
	CMPB	GSD$L_IDENT+3(R6),GSD$L_IDENT+3(R11) ;DOES MAJOR ID MATCH?
	BNEQ	133$			;BR ON NO, CAN'T USE DUP SECTION
	CMPL	GSD$L_IDENT(R6),GSD$L_IDENT(R11) ;COMPARE ENTIRE LONGWORD
	BGTRU	133$			;BR IF LARGER, NO MATCH, CAN'T USE DUP
	BLBC	GSD$L_IDENT(R6),141$	;BR IF EXACT MATCH NOT REQUIRED
	BEQL	141$			;BR IF AN EXACT MATCH, CAN USE DUP
133$:	MOVZWL	#SS$_IDMISMATCH,(SP)	;REPORT DUPLICATE GS NAME
	MOVZBL	#1,R0			;ONE REFCNT FOR LOCK
	JSB	G^MMG$DECSHMREF		;RELEASE LOCK ON DUP AS WON'T MAP TO IT
	BRB	143$			;RETURN TO USER WITHOUT MAPPING DUP
135$:	BRW	150$			;BR ASSIST FOR NO DUP GSD PATH
141$:	BBSSI	#GSD$V_DUPGSD,GSD$L_GSDFL(R11),142$ ;RECORD DUP GSD CREATED
142$:	MOVL	R0,(SP)			;REMEMBER ERROR CODE
143$:	MOVL	R6,GSD$L_GSDBL(R11)	;REMEMBER ADR OF DUP GSD TO MAP TO
	MOVL	R11,R6			;RESTORE ADR OF GSD BEING CREATED
;
; AT THIS POINT, THE GLOBAL SECTION MUST BE RELEASED.  EITHER THE GLOBAL
; SECTION COULD NOT BE INITIALIZED OR A DUPLICATE SECTION WAS FOUND.  IF A
; DUPLICATE SECTION WAS FOUND, THE NEW SECTION MUST BE DELETED AND THE OLD
; SECTION MAPPED, INSTEAD.  THEREFORE, BEFORE RETURNING A STATUS CODE TO THE
; USER, THE PAGES MUST BE UNMAPPED FROM HIS VIRTUAL  ADDRESS SPACE.  THIS IS
; DONE BY SETTING A TEMP DELETE FLAG, AND THEN RE-EXECUTING THE $MGBLSC LOGIC
; CALLING $DELPAG INSTEAD OF $CREPAG.  WHEN THE LAST REFERENCE (PTE) TO THE
; SECTION IS DELETED, THEN THE SHARED MEMORY PAGES ASSOCIATED WITH THE SECTION
; AND THE GSD MAY BE RELEASED.  IF THERE IS A DUPLICATE SECTION, THEN A $MGBLSC
; IS PERFORMED TO IT.
;
RELEAS_SHMGS:
	TSTL	4(SP)			;WAS ANYTHING MAPPED?
	BEQL	SHM_UNMAPPED		;BR ON NO, NOTHING TO UNMAP
	BBCS	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),144$ ;SET TMP DEL INDIC
144$:	MOVZBL	#1,R0			;REF COUNT INCREMENT
					;R4=SHB ADDRESS
	JSB	G^MMG$INCSHMREF		;LOCK GSD SO IT CAN'T BE DELETED
145$:	PUSHL	R3			;LAST ENDING VA MAPPED
	PUSHL	8(SP)			;FIRST STARTING VA MAPPED
	BRW	MAPGBLSEC4		;REPEAT CODE, UNMAPPING THE VA SPACE
SHM_UNMAPPED:
	MOVL	MMG$GL_SYSPHD,R5	;GET ADR OF SYSTEM PROCESS HEADER
	CVTWL	GSD$W_GSTX(R6),R1	;GET SECTION TABLE ENTRY INDEX
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R0 ;COMPUTE ADR OF SECTION TBL ENTRY
	MOVAL	(R0)[R1],R10		;SO THAT IT CAN BE RELEASED
	CLRL	SEC$L_GSD(R10)		;INDICATE NO GSD CONNECTED TO IT
	ASSUME	SEC$L_PAGCNT EQ SEC$L_REFCNT+4
	CLRQ	SEC$L_REFCNT(R10)	;CLEAR REFCNT, SO IT WILL BE DELETED
	BBCC	#SEC$V_PERM,SEC$W_FLAGS(R10),151$ ;CLEAR THE PERMANENT FLAG
151$:	BBSSI	#PHD$V_DALCSTX,-	;LET SOMEONE IN PROPER
		PHD$W_FLAGS(R5),152$	;STATE DELETE IT (HOLDING GSD MUTEX)
152$:	MOVZBL	#SHD$V_BITMAPLCK,R0	;NUMBER OF BIT LOCK REQUESTED
	BSBW	MMG$SHMTXLK		;REQUEST MUTEX AND BIT LOCK
; **********
; AT SOME TIME THIS SHOULD SEND A MESSAGE TO THE ERROR LOGGER.
; **********
	BLBC	R0,146$			;UNABLE TO ACQUIRE BIT MAP LOCK
	MOVL	SHB$L_DATAPAGE(R4),R5	;GET ADR OF COMMON DATA PAGE
	BSBW	MMG$SET_BITMAP		;RELEASE ALL PAGES ALLOCATED FOR GS
	BSBW	MMG$SHMTXULK		;RELEASE SHM MUTEX
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),146$ ;RELEASE BIT LCK
146$:	BBCCI	#GSD$V_VALID,GSD$L_GSDFL(R6),147$ ;SET THE GSD NOT VALID
147$:	CLRL	R11			;ASSUME NO DUPLICATE GSD TO MAP TO
	BBCCI	#GSD$V_DUPGSD,GSD$L_GSDFL(R6),148$ ;BR IF NO DUP GSD TO MAP TO
	MOVL	GSD$L_GSDBL(R6),R11	;GET ADR OF DUPLICATE GSD
148$:	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),149$ ;UNLOCK THE GSD FOR REUSE
149$:	MOVZBL	SHB$B_PORT(R4),R1	;GET PORT # FOR THIS PROCESSOR
	ADAWI	#1,SHD$W_GSDQUOTA(R5)[R1] ;GIVE BACK SHM GSD QUOTA FOR PORT
	DECL	SHB$L_REFCNT(R4)	;ONE LESS SHM GSD OWNED BY THIS PORT
	MOVL	R11,R6			;SET ADR OF DUPLICATE GSD TO MAP TO
	BEQL	160$			;BR TO RETURN ERROR CODE
	BRB	145$			;BR TO MAP TO DUPLICATE GSD
150$:	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R11),160$ ;UNLOCK THE GSD FOR USE
160$:	BRW	88$			;ALL DONE, GO CLEAN UP
	.DSABL	LSB

	.SBTTL FAST_MAP - DO COMMON CASES EFFICIENTLY
;
; MAP A GLOBAL SECTION THE EASY WAY
;
;	This fast path is used for new adress space beyond the end of a
;	region with all quota checks made in advance.
;	The main loop does four pages at a time to further decrease the
;	loop overhead.
;
FAST_MAP:
	MOVQ	R2,-(SP)		;SAVE THE VA'S
	CMPL	R2,R3			;IS R2 THE LOWEST VA
	BLSSU	10$			;YES
	MOVL	R3,R2			;NOW R2 IS LOWEST

10$:	BBC	#VA$V_P1,R2,20$		;BRANCH IF P0 SPACE
;
; P1 SPACE
;
	MOVAL	PHD$L_P1BR(R5),R3	;ADR OF POINTER TO P1PT
	BRB	30$
;
; P0 SPACE
;
20$:	MOVAL	PHD$L_P0BR(R5),R3	;ADR OF POINTER TO P0PT

30$:	ADDL	R6,SEC$L_REFCNT(R10)	;ADJUST REFERENCE COUNT

	BBC	#SEC$V_RESIDENT,SEC$W_FLAGS(R10),35$ ;IS IT RESIDENT
	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,R8,R9 ;EXTRACT GPTX FROM PROPOSED PTE
	MOVAL	@MMG$GL_GPTBASE[R9],R9	;GET FIRST GPTE ADDRESS
	INCL	R9			;INDICATOR FOR FIRST TIME THROUGH LOOP
	BICL	#^C<PTE$M_OWN!PTE$M_PROT>,R8 ;LEAVE OWNER-PROT IN PTE
	BBSS	#PTE$V_VALID,R8,35$	;VALID

35$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R1 ;VIRTUAL PAGE NUMBER
	EXTZV	#0,#2,R6,R0		;PAGES TO LEAVE A MULTIPLE OF 4
	BEQL	50$

	BBS	#SEC$V_RESIDENT,SEC$W_FLAGS(R10),45$ ;IS IT RESIDENT
40$:	MOVAB	(R8)+,@(R3)[R1]		;STORE NEW PTE
	INCL	R1			;NEXT PAGE
	SOBGTR	R0,40$
	BRB	50$			;REJOIN COMMON CODE

45$:	JSB	LCKPAGTBL1
	INSV	(R9),#PTE$V_PFN,#PTE$S_PFN,R8 ;PUT PFN IN PTE
	MOVL	R8,@(R3)[R1]		;STORE NEW PTE
	ADDL	#4,R9			;NEXT GPTE
	INCL	R1			;NEXT PAGE
	SOBGTR	R0,45$

50$:	ASHL	#-2,R6,R6
	BNEQ	55$
	BRW	70$			;DONE

55$:	BBS	#SEC$V_RESIDENT,SEC$W_FLAGS(R10),65$ ;IS IT RESIDENT
60$:	MOVAB	(R8)+,@(R3)[R1]		;STORE NEW PTE
	INCL	R1			;NEXT PAGE
	MOVAB	(R8)+,@(R3)[R1]		;STORE NEW PTE
	INCL	R1			;NEXT PAGE
	MOVAB	(R8)+,@(R3)[R1]		;STORE NEW PTE
	INCL	R1			;NEXT PAGE
	MOVAB	(R8)+,@(R3)[R1]		;STORE NEW PTE
	INCL	R1			;NEXT PAGE
	SOBGTR	R6,60$
	BRB	70$			;REJOIN COMMON CODE

65$:	JSB	LCKPAGTBL1
	INSV	(R9),#PTE$V_PFN,#PTE$S_PFN,R8 ;PUT PFN IN PTE
	MOVL	R8,@(R3)[R1]		;STORE NEW PTE
	ADDL	#4,R9			;NEXT GPTE
	INCL	R1			;NEXT PAGE
;
	JSB	LCKPAGTBL1		;LOCK THE PAGE TABLE
	INSV	(R9),#PTE$V_PFN,#PTE$S_PFN,R8 ;PUT PFN IN PTE
	MOVL	R8,@(R3)[R1]		;STORE NEW PTE
	ADDL	#4,R9			;NEXT GPTE
	INCL	R1			;NEXT PAGE
;
	JSB	LCKPAGTBL1		;LOCK THE PAGE TABLE
	INSV	(R9),#PTE$V_PFN,#PTE$S_PFN,R8 ;PUT PFN IN PTE
	MOVL	R8,@(R3)[R1]		;STORE NEW PTE
	ADDL	#4,R9			;NEXT GPTE
	INCL	R1			;NEXT PAGE
;
	JSB	LCKPAGTBL1		;LOCK THE PAGE TABLE
	INSV	(R9),#PTE$V_PFN,#PTE$S_PFN,R8 ;PUT PFN IN PTE
	MOVL	R8,@(R3)[R1]		;STORE NEW PTE
	ADDL	#4,R9			;NEXT GPTE
	INCL	R1			;NEXT PAGE
;
	SOBGTR	R6,65$

70$:	MOVQ	(SP)+,R1		;GET BACK THE VA'S
	CMPL	R1,R2
	BGTRU	90$			;GOING BACKWARDS
	BLSSU	80$			;GOING FORWARDS
	BBS	#VA$V_P1,R2,90$		;EQUAL - P1 IS BACKWARDS
80$:	BICW	#^X1FF,R1		;STARTVA IS START OF PAGE
	BISW	#^X1FF,R2		;ENDVA IS END OF PAGE
	BRB	100$
90$:	BICW	#^X1FF,R2		;STARTVA IS START OF PAGE
	BISW	#^X1FF,R1		;ENDVA IS END OF PAGE
100$:	MOVZWL	#SS$_NORMAL,R0		;INDICATE SUCCESSFUL COMPLETION
	RSB

	.SBTTL	SETSECPROTOWN - SET SECTION PROTECTION AND OWNER
;
; INPUTS:
;
;	R6  = GLOBAL SECTION DESCRIPTOR ADDRESS
;	R8  = PAGE TABLE ENTRY WITH SECTION INDEX, FLAGS, PAGE TYPE BITS
;	      OR PAGE TABLE ENTRY WITH PFN FOR PFNMAP-ING
;	R9  = SECTION FLAGS
;	R10 = SECTION TABLE ENTRY ADDRESS OR 0 IF GSD TYPE IS EXTENDED GSD
;	MMG$L_MAXACMODE(FP) = MAXIMIZED ACCESS MODE
;
; OUTPUTS:
;
;	R0 = SYSTEM STATUS CODE
;	R8 OWNER AND PROTECTION FIELDS FILLED IN
;
SETSECPROTOWN:
	.ENABL	LSB
	PUSHL	#SS$_NORMAL		;ASSUME NORMAL SUCCESS RETURN CODE
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,R9,R1 ;GET WRTMOD MAPPER SPECIFIED
	TSTL	R10			;IS THERE A SECTION TABLE ENTRY?
	BEQL	2$			;BR IF NO SECTION TABLE
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,- ;GET ACCESS MODE FROM SECTION
		SEC$W_FLAGS(R10),R0	;TABLE ENTRY, I.E., WHAT CREATOR SPEC
	BRB	4$			;JOIN COMMON CODE
2$:	TSTL	R6			;IS THERE A GLOBAL SECTION DESCRIPTOR?
	BEQL	10$			;BR ON LOCAL PFNMAP, CREATOR=MAPPER
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,- ;GET ACCESS MODE FROM GSD
		GSD$W_FLAGS(R6),R0	;I.E., WHAT CREATOR OF GS SPECIFIED
4$:	CMPL	R0,R1			;NOW MINIMIZE THE WRITE ACCESS
	BLEQ	5$			;BR IF MAPPER SPECIFIED MORE ACCESS
	MOVZWL	#SS$_IVLVEC,(SP)	;SET ALTERNATE RETURN SUCCESS CODE
	MOVL	R1,R0			;USE CREATOR'S ACCESS
5$:	EXTZV	#0,#2,B^MMG$L_MAXACMODE(FP),R1 ;GET READ ACCESS MODE
	CMPL	R0,R1			;IF WRTMOD > ACMOD, THEN USE ACMOD
	BLSS	15$			;TO PREVENT ILLEGAL ACCESS, E.G., ERUW
10$:	MOVL	R1,R0			;AND TO SET CORRECT OWNER FIELD
15$:	INSV	R0,#PTE$V_OWN,#PTE$S_OWN,R8 ;SET PAGE OWNER IN PTE
;
; CALCULATE PROTECTION FIELD
;
	BBC	#SEC$V_WRT,R9,NO_WRT_ACCESS ;BR IF NOT TRYING TO WRITE SECTION
	TSTL	R10			;IS THERE A SECTION TABLE ENTRY?
	BNEQ	20$			;YES, GO CHECK ITS FLAGS
	TSTL	R6			;IS THIS A GLOBAL SECTION?
	BEQL	30$			;NO, THEN MUST BE LOCAL PFNMAP
					;WITH NO GSD OR SECTION TBL ENTRY (ONLY
					;FLAGS ARE IN R9 AND ALREADY TESTED)
	BBC	#SEC$V_WRT,GSD$W_FLAGS(R6),100$ ;BRANCH IF ILLEGAL TO WRITE
	BRB	30$			;GO GET ACCESS MODE
20$:	BBC	#SEC$V_WRT,SEC$W_FLAGS(R10),100$ ;BRANCH IF ILLEGAL TO WRITE
30$:	MULL2	#3,R0			;SCALE WRITE ACCESS MODE BY THREE BITS
	EXTV	R0,#3,B^WRTMOD_TBL,R0	;GET PTE CODE FOR THIS WRITE MODE
	BGEQ	GET_READ_ACCESS		;BR IF NOT USER MODE WRITE
	MOVZBL	#PRT$C_UW,R0		;SET USER MODE WRITE, SPECIAL CASE
	BRB	SET_PTE_PROT		;GO SET PROTECTION FIELD OF PTE
WRTMOD_TBL:
	.WORD	^B100000001010		;3 BIT PTE CODES, INDEXED BY 3 * WRTMOD
NO_WRT_ACCESS:
	MOVZBL	#3,R0			;SET PTE CODE FOR READ ONLY ACCESS
GET_READ_ACCESS:
	INSV	R1,#2,#2,R0		;INSERT READ ACCESS BESIDE WRITE ACCESS
SET_PTE_PROT:
	INSV	R0,#PTE$V_PROT,#PTE$S_PROT,R8 ;PUT PROTECTION IN PTE
90$:	MOVL	(SP)+,R0		;SET RETURN STATUS CODE
	RSB
;
; TRIED TO MAP READ ONLY SECTION WRITABLE
;
100$:	MOVZWL	#SS$_NOPRIV,(SP)	;SET RETURN ERROR CODE, NO PRIVILEGE
	BRB	90$			;RETURN ERROR CODE
	.DSABL	LSB

	.SBTTL	INITSECTBL - ALLOC & INIT SECTION TABLE ENTRY
;
; INPUTS:
;
;	R5 = PROCESS HEADER ADDRESS
;	R6 = GLOBAL SECTION DESCRIPTOR ADDRESS IF GLOBAL SECTION
;	   = CHANNEL CONTROL BLOCK ADDRESS IF PROCESS SECTION
;	R7 = NUMBER OF PAGES TO BE MAPPED
;	R8 = CHANNEL CONTROL BLOCK ADDRESS
;	R9 = SECTION FLAGS
;
; OUTPUTS:
;
;	R0  = SYSTEM STATUS CODE
;	R1  = SECTION TABLE INDEX
;	R2,R3 ALTERED
;	R7  = SECTION PAGE COUNT
;	R10 = SECTION TABLE ADDRESS
;
;
; ***** NOTE THAT SECTION SIZE MUST BE SUCH THAT SECTION INDICES HAVE THE
; ***** LOW BIT ZERO.
;
	ASSUME	SEC$C_LENGTH@-2&1 EQ 0

	.ENABL	LSB
;
; GLOBAL SECTION BEING CREATED ON CHANNEL WITH PROCESS SECTION INDEX
; GET WINDOW ADDRESS
;
10$:	MOVL	@#CTL$GL_PHD,R0		;PROCESS HEADER ADDRESS
	ADDL	PHD$L_PSTBASOFF(R0),R0	;FORM BASE OF PROCESS SECTION TABLE
	MOVL	SEC$L_WINDOW(R0)[R2],R2	;GET WINDOW ADDRESS FROM PROCESS SECTION
	BRB	100$			;AND REJOIN THE NORMAL FLOW
;
; SPECIAL CASE CODE FOR NON-FCP WINDOW - I.E. ONE CREATED WITHOUT BENEFIT OF
; THE ACP - USUALLY DONE AT SYSTEM INITIALIZATION TIME. THE LOOP IS TO
; TAKE CARE OF POSSIBLY NON-CONTIGUOUS FILES.
;
40$:	PUSHL	R1			;NEED A SCRATCH REGISTER
	CLRL	-(SP)			;INITILIZE TOTAL VBN'S
	MOVZWL	WCB$W_NMAP(R2),R1	;PICK UP NUMBER OF MAPPING POINTERS
	MOVAB	WCB$W_P1_COUNT(R2),R2	;POINT AT FIRST ONE
45$:	MOVZWL	(R2),R0			;PICK UP THE NUMBER OF BLOCKS/POINTER
	ADDL2	R0,(SP)			;ADD TO TOTAL MAPPED
	ADDL2	#6,R2			;ADVANCE TO NEXT POINTER
	SOBGTR	R1,45$			;TAKE CARE OF THEM ALL
	MOVQ	(SP)+,R0		;RESTORE R1.  R0 = TOTAL VBNS IN FILE
	BRW	120$			;AND REJOIN THE MAIN PATH CODE
;
; CHANNEL IS ACTIVE OR OTHERWISE INAPPROPRIATE FOR CREATING A SECTION
;
50$:	MOVZWL	#SS$_NOTFILEDEV,-(SP)	;FILE NOT RND, FOD, OR DIR
	BRB	70$			;GO RELEASE SECTION TABLE ENTRY
60$:	MOVZWL	#SS$_IVCHNLSEC,-(SP)	;INVALID CHANNEL FOR SECTION
70$:	JSB	G^MMG$DALCSTX		;DEALLOCATE SECTION TABLE ENTRY
	POPR	#^M<R0>			;GET ERROR STATUS
80$:	RSB

81$:	BRW	230$
82$:	BRB	10$

INITSECTBL:
	JSB	G^MMG$ALCSTX		;ALLOCATE SECTION TABLE INDEX
	BLBC	R0,80$			;BRANCH IF NONE AVAILABLE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R3 ;BASE ADDRESS OF SECTION TABLE
	MOVAL	(R3)[R1],R10		;ADDRESS OF SECTION TABLE ENTRY
	MOVL	R6,(R10)		;CCB ADDRESS OR GSD ADDRESS
	MOVW	R9,SEC$W_FLAGS(R10)	;SET FLAGS
	TSTL	R8
	BEQL	81$			;NO CHANNEL - SKIP ALL THIS STUFF
	TSTW	CCB$W_IOC(R8)		;IF ANY OUTSTANDING I/O ON CHANNEL
	BNEQ	60$			;THEN IT CANNOT BE USED
	MOVL	CCB$L_UCB(R8),R0	;GET UCB FOR DEVICE CHARACTERISTICS
	BICL3	UCB$L_DEVCHAR(R0), -	;CHECK THAT DEVICE HAS DIRECTORIES,
		#<DEV$M_DIR!DEV$M_FOD!DEV$M_RND>,R0 ;FILES, AND IS RANDOM-ACCESS
	BNEQ	50$			;BRANCH IF ANY CHARACTERISTIC IS MISSING
	MOVL	CCB$L_WIND(R8),R2	;WINDOW ADDRESS FROM CHANNEL
	BEQL	60$			;BRANCH IF NO FILE IS OPEN
	BLBS	R2,60$			;CAN'T USE CHAN IF ACCESS/DEACCESS PENDING
	BLSS	100$			;BRANCH IF WINDOW ADDRESS
	CVTWL	R2,R2			;FORM PROCESS SECTION INDEX
	BLBS	R9,82$			;BRANCH IF CREATING A GLOBAL SECTION
	MOVL	SEC$L_WINDOW(R3)[R2],R2	;FETCH WINDOW FROM PROCESS SECTION
100$:	MOVL	R2,SEC$L_WINDOW(R10)	;SET WINDOW ADDRESS IN SECTION TABLE
	BBS	#WCB$V_WRITE,WCB$B_ACCESS(R2),105$ ;BR IF FILE WRITE ACCESSED
	BBC	#SEC$V_WRT,R9,110$	;BRANCH IF NOT MAPPING FOR WRITE
	BBS	#SEC$V_CRF,R9,110$	;WRITE AND CRF IS OK FOR READ ONLY FILE
	MOVZWL	#SS$_NOWRT,-(SP)	;ERROR, CANNOT CREATE WRITABLE SECTION
	BRB	70$			;TO A READ ONLY FILE, RETURN TO USER

	ASSUME	SEC$V_WRT LE 7
105$:	BISB	#SEC$M_WRT,SEC$W_FLAGS(R10) ;NOTE SECTION WRITABLE
110$:	MOVL	WCB$L_FCB(R2),R0	;FCB ADDRESS FROM WINDOW
	BNEQ	112$			;GOT A REAL ONE
	BRW	40$			;BRANCH IF NONE THERE
112$:	BBSS	#WCB$V_NOTRUNC,WCB$W_ACON(R2),115$ ;DISALLOW TRUNCATE ON THE FILE
	INCW	FCB$W_TCNT(R0)		;COUNT TRUNCATE LOCKS
115$:	MOVL	B^MMG$L_EFBLK(FP),R0	;LAST VIRTUAL BLOCK THAT MAY BE MAPPED
120$:	SUBL3	#1,VBN(AP),R2		;DESIRED STARTING VBN - 1
	BGEQ	130$			;IF WAS SPECIFIED AS 0
	CLRL	R2			;THEN MAKE IT VBN 1
130$:	ADDL3	#1,R2,SEC$L_VBN(R10)	;SET STARTING VBN IN SECTION TABLE
	TSTL	R7			;NUMBER OF PAGES IN SECTION
					;STARTING AT SPECIFIED VBN
	BGTR	140$			;BRANCH IF NOT DEFAULTED TO "ENTIRE FILE"
	MOVL	R0,R7			;USE ENTIRE FILE
140$:	ADDL3	R7,R2,-(SP)		;FORM HIGHEST VBN TO BE MAPPED
	CMPL	R0,(SP)+		;TRYING TO MAP BEYOND EOF?
	BGTR	150$			;BRANCH IF NOT
	SUBL3	R2,R0,R7		;FORM NEW PAGCNT = MAXVBN - (STARTVBN - 1)
	BLEQ	290$			;BRANCH IF NOTHING TO MAP, EOF
150$:	MOVL	R7,SEC$L_PAGCNT(R10)	;SET SECTION SIZE
	BLBC	R9,170$			;BRANCH IF PROCESS SECTION
;
; GLOBAL SECTION - ONCE THE WINDOW IS MADE SHARED, DALCSTX CANNOT BE
; USED TO DELETE THE SECTION TABLE ENTRY.  DALCSTXSCN MUST BE USED
; BECAUSE IT RELEASES THE WINDOW.
;
	MOVL	SEC$L_WINDOW(R10),R0	;WINDOW ADDRESS
	BBSS	#WCB$V_SHRWCB,WCB$B_ACCESS(R0),160$ ;MAKE INTO SHARED WINDOW
					;BRANCH IF ALREADY A SHARED WINDOW
	BSBW	MMG$RET_BYT_QUOTA	;RESTORE BYTCNT QUOTA TO FILE OWNER
160$:	INCW	WCB$W_REFCNT(R0)	;ANOTHER REFERENCE FOR SECTION ENTRY
	BRB	180$
;
; PROCESS SECTION
;
170$:	MOVL	CCB$L_WIND(R8),R0	;GET WINDOW OR SECTION FROM CHANNEL
	BGTR	190$			;BRANCH IF SECTION INDEX
	MOVZWL	R1,CCB$L_WIND(R8)	;1ST PROCESS SECTION ON CHANNEL
					;STORE SECTION INDEX IN CCB
180$:	MOVL	R10,R0			;SECTION TABLE ENTRY ADDRESS
	BRB	200$			;INIT FORWARD AND BACKWARD SECTION INDICES
;
; SUBSEQUENT SECTION (NOT THE FIRST) ON THIS CHANNEL
;
190$:	CVTWL	R0,R0			;INSERT AFTER THIS SECTION
	MOVW	R0,SEC$W_SECXBL(R10)	;CURSEC(BL) = BAKSECX
	MOVAL	(R3)[R0],R0		;ADR OF BACKWARD SECTION TABLE ENTRY
	MOVW	SEC$W_SECXFL(R0),SEC$W_SECXFL(R10) ;CURSEC(FL) = BAKSEC(FL)
200$:	MOVW	R1,SEC$W_SECXFL(R0)	;BAKSEC(FL) = CURSECX
	CVTWL	SEC$W_SECXFL(R10),R0	;FORWARD SECTION INDEX (FORSECX)
	MOVAL	(R3)[R0],R0		;FORWARD SECTION TABLE ENTRY ADDRESS
	MOVW	R1,SEC$W_SECXBL(R0)	;FORSEC(BL) = CURSECX
	MOVL	#1,SEC$L_REFCNT(R10)	;NO REFERENCES YET
	CVTBL	PFC(AP),R0		;GET PAGE FAULT CLUSTER
	BGEQ	210$			;BRANCH IF NOT TOO BIG
	MOVZBL	#127,R0			;IT WAS TOO BIG, SET TO MAX

	ASSUME	SEC$B_PFC EQ SEC$L_VPXPFC+3
210$:	ASHL	#24,R0,SEC$L_VPXPFC(R10) ;SET PFC, ZERO VIRTUAL PAGE INDEX
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION
	RSB
;
; PAGE FILE BACKING STORE
;
230$:	BISB	#SEC$M_WRT,SEC$W_FLAGS(R10) ;NOTE SECTION WRITABLE
	MOVL	R7,SEC$L_PAGCNT(R10)	;SET SECTION SIZE
	CLRL	SEC$L_WINDOW(R10)	;NO WINDOW - PAGE FILE BACKING STORE
	BRB	180$
;
; ATTEMPT TO CREATE A SECTION BEYOND END OF FILE
;
290$:	MOVZWL	#SS$_ENDOFFILE,-(SP)	;SET RETURN STATUS
	BRW	70$			;CLEAN UP AND EXIT

	.DSABL	LSB

	.SBTTL	MAP PROCESS SECTION
;
; CALLING SEQUENCE:
;
;	BRW	MAP_PROCESS_SECTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS
;	R8 = CHANNEL CONTROL BLOCK ADDRESS, IF PFNMAP FLAG IS CLEAR
;	R9 = SECTION FLAGS
;	0(SP) = STARTVA
;	4(SP) = ENDVA
;	8(SP) = SUCCESS CODE FOR MAP SECTION
;	PFN(AP) = FIRST PFN TO MAP TO, IF PFNMAP FLAG IS SET
;
MAP_PROCESS_SEC:
	SETIPL	#IPL$_ASTDEL		;NO AST'S WHILE MANIPULATING HEADER
	CLRL	R11			;INDICATE NO GSD ADR
	MOVL	@#CTL$GL_PHD,R5		;PROCESS HEADER ADDRESS
	BBC	#SEC$V_PFNMAP,R9,1$	;IS PFNMAPPING REQUESTED?
	BBS	#PRV$V_PFNMAP,PHD$Q_PRIVMSK(R5),1$ ;BR ON HAVE PRIV
	MOVZWL	#SS$_NOPRIV,R0		;NO PRIVILEGE FOR REQUESTED OPERATION
	BRW	90$			;RETURN ERROR CODE TO CALLER
1$:	JSB	G^MMG$DALCSTXSCN	;SCAN FOR SECTIONS TO DEALLOCATE
	MOVL	R8,R6			;CCB ADDRESS

	MOVL	SECPAGCNT(AP),R7	;GET # OF PAGES IN SECTION
	PUSHL	R9			;REMEMBER FLAGS
	ASSUME	<SEC$M_CRF!SEC$M_DZRO> EQ 6
	CMPZV	#1,#2,R9,#<<SEC$M_CRF!SEC$M_DZRO>@-1> ;IF CRF+DZRO, THEN DONT
	BEQL	8$			;CREATE SECTION TABLE ENTRY JUST PTES
	BBS	#SEC$V_PFNMAP,R9,10$	;DON'T CREATE SECTION PTE FOR PFNMAP-ING
	ASSUME	<<SEC$M_DZRO!SEC$M_CRF!SEC$M_WRT>&^XFFFFFF00> EQ 0
	MOVZBL	R9,R9			;ELIM GBL FLAGS, PFNMAP, & EXPREG
	BSBW	INITSECTBL		;ALLOCATE AND INIT A SECTION TABLE ENTRY
	BLBS	R0,5$			;BR IF SECTION TABLE ENTRY CREATED
	BRW	90$			;BR IF NONE AVAILABLE OR ERROR
;
; R1  = SECTION TABLE INDEX
; R7  = SECTION PAGE COUNT
; R10 = SECTION TABLE ENTRY ADDRESS
;

	ASSUME	SEC$V_WRT EQ SEC$V_DZRO+1
	ASSUME	SEC$V_DZRO EQ SEC$V_CRF+1
5$:	EXTZV	#SEC$V_CRF,#3,SEC$W_FLAGS(R10),R8 ;GET CRF, DZRO, WRT BITS
	BISW	#<PTE$M_TYP1 ! PTE$M_TYP0>@-16,R8 ;OR IN TYPE BITS
	ROTL	#16,R8,R8		;PUT IN HIGH 16 BITS
	MOVW	R1,R8			;SET SECTION INDEX
	BRB	15$			;SKIP PFNMAP-ING PTE CREATION
8$:	CLRL	R8			;USE DEMAND-ZERO PTE FORMAT
	BRB	12$			;CONTINUE MAPPING SECTION
10$:	MOVL	PFN(AP),R8		;GET STARTING PFN FOR SECTION
	BISL	#^X<PTE$M_VALID ! PTE$M_WINDOW>,R8 ;SET VALID AND WINDOW BITS
12$:	CLRL	R10			;INDICATE NO SECTION TABLE ENTRY
	CLRL	R6			;NO GSD ADDRESS
15$:	BSBW	SETSECPROTOWN		;SET SECTION PROTECTION AND OWNER
	BLBS	R0,151$			;BRANCH IF GOOD PROTECTION CODE
	CLRL	MMG$L_SAVRETADR(FP)	;DON'T RETURN AN ADDRESS RANGE
	BRW	20$			; THE MOVQ (SP)+ WILL TAKE GARBAGE FROM STACK
151$:	CMPL	#SS$_NORMAL,R0		;WAS ALTERNATE SUCCESS CODE RETURNED?
	BEQL	16$			;BR IF NORMAL CODE RETURNED
	MOVL	R0,12(SP)		;SAVE ALTERNATE CODE TO RETURN TO CALLER
16$:	POPL	R0			;GET FLAGS BACK
	POPR	#^M<R2,R3>		;R2=STARTVA, R3=ENDVA
	BBC	#SEC$V_EXPREG,R0,175$	;BR IF RANGE IS EXPLICITLY STATED
;
; FIND THE FIRST AVAILABLE VIRTUAL ADDRESS AND COMPUTE THE RANGE TO BE MAPPED.
;
	ASHL	#9,R7,R1		;CONVERT PAGE COUNT TO # OF
	DECL	R1			;BYTES BETWEEN START VA AND END VA
	MOVL	@#CTL$GL_PHD,R0		;GET PROCESS HEADER FOR PROCESS
	BBC	#VA$V_P1,R2,17$		;BR IF MAPPING INTO P0 SPACE
	ADDL3	#^X1FF,PHD$L_FREP1VA(R0),R3 ;ENDING VA IN P1 SPACE
	SUBL3	R1,R3,R2		;STARTING VA IN P1 SPACE
	BRB	175$			;JOIN COMMON CODE
17$:	MOVL	PHD$L_FREP0VA(R0),R2	;STARTING VA IN P0 SPACE
	ADDL3	R1,R2,R3		;ENDING VA IN P0 SPACE
175$:	TSTL	R10			;IS IT PFN MAPPING
	BEQL	19$			;YES - DO IT THE HARD WAY
	MOVQ	R2,R4			;GET THE START AND END VA
	JSB	MMG$IN_REGION		;IS IT NEW ADDRESS SPACE
	BLBC	R0,19$			;NO - CREATE IT THE HARD WAY
	CMPL	R6,R7			;CHECK FIT OF SECTION IN THE SPACE
	BNEQ	19$			;NOT EXACT - DO IT THE HARD WAY
	MOVL	SCH$GL_CURPCB,R4
	SUBL	PHD$L_PSTBASOFF(R5),R10	;NORMALIZE SECTION ADDRESS IN CASE IT MOVES
	JSB	MMG$TRY_ALL		;SEE IF REGION CAN BE EXPANDED
	BLBC	R0,18$			;NO - CREATE IT THE HARD WAY
	JSB	MMG$FAST_CREATE		;DO IT THE FAST WAY
	ADDL	PHD$L_PSTBASOFF(R5),R10	;UN-NORMALIZE SECTION ADDRESS
	ADDL	R7,SEC$L_REFCNT(R10)	;ACCOUNT FOR THE PAGES MAPPED
	BRB	194$
18$:	ADDL	PHD$L_PSTBASOFF(R5),R10	;UN-NORMALIZE SECTION ADDRESS
19$:	SUBL3	#1,R7,R9		;SECTION PAGE COUNT BASE 0
191$:	PUSHR	#^M<R2,R3,R8,R9>	;NEEDED TO REDO OPERATION
	MOVAL	W^MMG$MAPSECPAG,R6	;MAP SECTION PAGE ROUTINE
	BBSS	#MMG$V_NOWAIT_IPL0,-	;RETURN INSTEAD OF WAITING AT IPL 0
		MMG$L_MAXACMODE(FP),193$
193$:	JSB	G^MMG$CREDEL		;CREATE THE PAGES
	CMPW	R0,#SS$_ABORT		;DID WE ABORT RATHER THAN WAIT AT IPL 0
	BEQL	100$			;YES - GO CLEAN UP
	ADDL	#<4*4>,SP		;REMOVE SAVED REGISTERS
194$:	MOVQ	R1,-(SP)		;SAVE RETURN ADDRESS RANGE
	BLBS	R0,30$			;IF SUCCESSFUL, USE SUCCESS CODE AT 8(SP)
20$:	MOVL	R0,8(SP)		;OTHERWISE SAVE ERROR CODE
30$:	TSTL	R10			;IS THERE A SECTION TABLE ENTRY?
	BEQL	85$			;BR ON NO SECTION TABLE ENTRY
	SUBL3	#1,SEC$L_REFCNT(R10),SEC$L_PAGCNT(R10) ;SET ACTUAL PAGE COUNT
	BEQL	80$			;BRANCH IF NO PAGES MAPPED
;
; AT LEAST ONE PAGE WAS MAPPED.
; R1, R2 CONTAIN THE RETURN RANGE VALUES
;
	BLBC	R1,40$			;BRANCH IF R1 IS THE LOWEST ADDRESS
	MOVL	R2,R1			;R2 WAS THE LOWEST
40$:	EXTV	#VA$V_VPN,#VA$S_VPN+1,R1,R0 ;GET VIRTUAL PAGE INDEX
	BGEQ	50$			;BRANCH IF NOT P1 SPACE
	ROTL	#7,SGN$GL_PTPAGCNT,R1	;OFFSET IN LONG WORD FROM BEGIN OF PAGE TABLE
	ADDL	R1,R0			;CORRECT P1 SPACE INDEX
50$:	BISL	R0,SEC$L_VPXPFC(R10)	;SET VIRTUAL PAGE INDEX, PRESERVE PFC
80$:	CVTWL	R8,R1			;SECTION TABLE INDEX
	JSB	G^MMG$DECSECREF		;COUNT ONE LESS SECTION REFERENCE
85$:	MOVQ	(SP)+,R1		;GET BACK RETURN RANGE
	JSB	G^MMG$RETRANGE		;RETURN ADDRESS RANGE TO CALLER
	BLBC	R0,90$			;ERROR - USE THIS STATUS
	POPR	#^M<R0>			;RETURN STATUS CODE 
90$:	RET				;AND RETURN TO CALLER
;
; THERE WAS A PAGE WITH I/O IN PROGRESS WHICH WE MUST WAIT FOR.
; DELETE THE PARTIALLY MAPPED SECTION FIRST
;
100$:	BBCC	#MMG$V_NOWAIT_IPL0,-	;WAIT THIS TIME
		MMG$L_MAXACMODE(FP),110$
110$:	MOVQ	R1,R2			;COMPLETED ADDRESS RANGE
	ADDL	R7,R3			;ADD IN THE PROBLEM PAGE
	MOVAL	MMG$DELPAG,R6		;DELETE ONLY THIS PASS
	JSB	MMG$CREDEL
	BLBC	R0,194$			;ERROR
	POPR	#^M<R2,R3,R8,R9>
	BRW	191$			;GO TRY AGAIN

	.SBTTL	MAPSECPAG - MAP A SINGLE PROCESS/GLOBAL SECTION PAGE

;++
; FUNCTIONAL DESCRIPTION:
;
;	MAPSECPAG MAPS A SINGLE PAGE OF A GLOBAL OR PROCESS SECTION AT THE
; SPECIFIED VITUAL ADDRESS.  AS IN CREPAG, THE PAGE TABLE IS EXTENDED
; IF NECESSARY (WHICH COULD FAIL IF THE VIRTUAL ADDRESS SPACE IS FULL),
; AND THE PAGE TABLE ENTRY IS DELETED IF NECESSARY AND THEN SET TO
; SPECIFIED VALUE.
;
;	THE CREATE PAGE LOGIC WILL CAUSE THE SECTION TABLE TO BE RELOCATED
; IF IT IS NECESSARY TO EXPAND THE PROCESS HEADER.  THIS HAPPENS WHEN THE
; WORKING SET IS FULL AND IT IS BACK-TO-BACK WITH THE SECTION TABLE.  THAT
; IS WHY THE SECTION TABLE ENTRY ADDRESS MUST BE RECOMPUTED AFTER EACH
; CALL TO MMG$CREPAG.  THE SECTION TABLE INDEX NEVER CHANGES, BUT THE OFFSET
; TO THE SECTION TABLE FROM THE TOP OF THE PROCESS HEADER DOES.
;
;	THIS ROUTINE IS ALSO USED TO UNMAP THE PAGES OF SHARED MEMORY GLOBAL
; SECTION WHICH FOR SOME REASON COULD NOT BE INITIALIZED.  THE BIT,
; GSD$V_INITFAIL, INDICATES THAT THE RANGE OF VIRTUAL ADDRESS SPACE IS TO
; BE DELETED INSTEAD OF CREATED.  THIS SERVICE WILL ONLY BE NEEDED FOR SHARED
; MEMORY GLOBAL SECTIONS SINCE ONLY THIS TYPE OF SECTION IS INITIALIZED BEFORE
; THE $CRMPSC STATUS CODE CAN BE RETURNED TO THE USER.  THE NEW CONTENTS OF
; THE PAGE TABLE ENTRY (R8) IS NOT USED WHEN DELETING VIRTUAL ADDRESS SPACE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$MAPSECPAG
;
; INPUT PARAMETERS:
;
;	R0 = MODE FOR CREATING NEW PAGE
;	R2 = VIRTUAL ADDRESS OF PAGE TO CREATE
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS - P1 OR SYSTEM SPACE
;	R6 = COUNT-1 OF PAGES TO BE MAPPED ACCORDING TO THE INPUT RANGE
;	R7 = +^X200 IF MAPPING FORWARDS IN THE VIRTUAL ADDRESS SPACE
;	   = -^X200 IF MAPPING BACKWARDS IN THE VIRTUAL ADDRESS SPACE
;	R8 = NEW CONTENTS OF PAGE TABLE ENTRY
;	R9 = COUNT-1 OF PAGES LEFT IN THE SECTION THAT COULD BE MAPPED
;	R10 = SECTION TABLE ENTRY ADDRESS OR 0 IF NONE APPLIES
;	R11 = GLOBAL SECTION DESCRIPTOR ADDRESS OR 0 IF NONE APPLIES
;
;	THE CURRENT IPL MUST BE AT ASTDEL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = ERROR STATUS CODE
;	R2 PRESERVED
;	R1,R3-R7,R9 DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	PTE CORRESPONDING TO SPECIFIED VIRTUAL ADDRESS IS DELETED AND
;	THE DESIRED PTE IS STORED
;
;	IF PAGE TABLE EXPANSION IS NECESSARY THEN THE FOLLOWING 
;	ARE AFFECTED:
;
;	PHD$L_FREP0VA OR PHD$L_FREP1VA	;1ST FREE PAGE AT END OF P0/P1 PAGE TABLE
;	PHD$L_P0LRASTL OR PHD$L_P1LR	;LENGTH OF PT IN HARDWARE PCB
;	PR$_P0LR OR PR$_P1LR		;LENGTH OF PT IN PROCESSOR REG
;	PHD$L_FREPTECNT			;FREE PTE COUNTER
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_NOPRIV			;NO PRIVILEGE TO CREATE/DELETE PAGE
;	SS$_VASFULL			;VIRTUAL ADDRESS SPACE FULL
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC
;
; **********************************************************************
;
MMG$MAPSECPAG:
	CMPL	R6,R9			;MORE PAGES THAN IN THE SECTION?
	BLEQ	10$			;BRANCH IF NOT
	MOVL	R9,R6			;YES, USE SECTION SIZE
10$:	ASHL	#-9,R7,R9		;+1 OR -1 DEPENDING ON DIRECTION
	TSTL	R11			;IS THIS A GLOBAL SECTION MAPPING?
	BNEQ	50$			;YES, BRANCH IF IS A GLOBAL SECTION

;
; LOGIC FOR PROCESS SECTIONS ONLY:
;
;	PTE'S THAT MAP A PROCESS SECTION ARE FILLED IN WITH
;	THE SECTION TABLE INDEX, AND THEREFORE, NO INCREMENT OR
;	DECREMENT IS NEEDED FOR SEQUENTIAL PTE'S.
;
	TSTL	R10			;CHECK IF NO SECTION TABLE ENTRY
	BEQL	30$			;BR ON NONE, PFNMAP SECTION OR DZERO
	CLRL	R9			;NO INC FOR NORMAL PROCESS SEC PTE'S

;
; LOGIC FOR ALL SECTIONS, EXCEPT PFNMAP AND SHARED MEMORY:
;
;	THIS IS THE CREATE-PAGE LOOP FOR ALL SECTION MAPPING,
;	EXCEPT FOR PFNMAP SECTIONS.
;	RESIDENT GLOBAL SECTIONS ARE A SPECIAL CASE OF THIS
;
20$:	BBS	#SEC$V_RESIDENT,SEC$W_FLAGS(R10),60$ ;RESIDENT GLOBAL SECTION
	MOVAL	B^25$,B^MMG$L_PAGESUBR(FP) ;SKIP INIT CODE FOR SUBSEQUENT PAGES
25$:	SUBL	PHD$L_PSTBASOFF(R5),R10	;SUBTRACT OFF POINTER THAT MIGHT CHANGE
	JSB	G^MMG$CREPAG		;CREATE AND STORE THE PAGE TABLE ENTRY
26$:	ADDL	PHD$L_PSTBASOFF(R5),R10	;ADD IN OFFSET THAT MAY HAVE CHANGED
	BLBC	R0,29$			;BRANCH IF ERROR
	INCL	SEC$L_REFCNT(R10)	;COUNT USES OF THIS SECTION
	ADDL	R9,R8			;COMPUTE NEXT PTE'S CONTENTS
29$:	RSB
;
; LOGIC FOR PFNMAP, SHARED MEMORY SECTIONS, AND DZERO CRF 
;
;	THIS CODE ASSUMES THAT THERE IS NO SECTION TABLE ENTRY.
;
;	FOR SHARED MEMORY, THERE IS A SECTION TABLE ENTRY BUT THE REFERENCE
;	COUNT IS NOT INCREMENTED FOR EACH PAGE MAPPING TO IT.  INSTEAD, THE
;	REFERENCE COUNT IS KEPT IN THE SHARED MEMORY GSD.  THEREFORE, R10 IS
;	0 FOR SHARED MEMORY MAPPING REQUESTS.
;
30$:	BBS	#PTE$V_WINDOW,R8,40$	;PFN SECTION OR DZERO CRF?
	CLRL	R9			;DZERO
40$:	MOVAL	B^45$,B^MMG$L_PAGESUBR(FP) ;SKIP INIT CODE FOR SUBSEQUENT PAGES
45$:	JSB	G^MMG$CREPAG		;CREATE AND STORE THE PAGE TABLE ENTRY
	BLBC	R0,49$			;BRANCH IF ERROR
	ADDL	R9,R8			;COMPUTE NEXT PTE'S CONTENTS
	BBC	#PTE$V_WINDOW,R8,49$	;BR IF NOT PFNMAP
	CMPZV	#PTE$V_PFN,#PTE$S_PFN,R8,MMG$GL_MAXMEM ;CHECK PFN
	BLEQU	49$			;MEMORY IS SEEN BY MP SECONDARY
	INCL	PHD$L_MPINHIBIT(R5)	;LOCK PROCESS ONTO PRIMARY PROCESSOR
49$:	RSB				;

;
; LOGIC FOR SHMGSD UNMAP ONLY:
;
;	THIS CODE IS USED TO UNMAP A SHARED MEMORY GLOBAL SECTION,
;	WHEN THE RACE CONDITION OCCURS CAUSING TWO SECTIONS OF THE
;	SAME NAME ARE CREATED IN ONE SHARED MEMORY.  THE SECOND
;	SECTION CREATED, IS UNMAPPED AND RELEASED.
;
50$:	CMPB	GSD$B_TYPE(R11),#DYN$C_EXTGSD ;IS THIS A PFNMAPPED SECTION?
	BEQL	40$			;BR IF PFNMAP
	BLSSU	20$			;BR IF NORMAL LOCAL MEMORY GSD
	BBC	#GSD$V_INITFAIL,GSD$L_GSDFL(R11),40$ ;BR IF NOT UNMAPPING VA

	MOVAL	B^55$,B^MMG$L_PAGESUBR(FP) ;SKIP INIT CODE FOR SUBSEQUENT PAGES
55$:	JSB	G^MMG$DELPAG		;UNMAP A PAGE OF VA SPACE
	RSB				;(DELPAG DOESN'T USE R8, SO ALL DONE)
;
; SPECIAL CODE FOR RESIDENT GLOBAL SECTIONS
;	THE PTE IS SIMPLY MADE VALID WITH NO WORKING SET LIST ENTRY
;	THE WINDOW BIT IS NOT SET TO AVOID CONFUSION WITH PFN-SECTIONS
;
60$:	MOVAL	B^65$,B^MMG$L_PAGESUBR(FP) ;SKIP INIT CODE FOR SUBSEQUENT PAGES
65$:	SUBL	PHD$L_PSTBASOFF(R5),R10	;SUBTRACT OFF POINTER THAT MIGHT CHANGE
	MOVQ	R8,-(SP)		;SAVE PTE AND COUNT
	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,R8,R9 ;GET GPTX
	MOVL	@MMG$GL_GPTBASE[R9],R9		;GET THE GPTE
	INSV	R9,#PTE$V_PFN,#PTE$S_PFN,R8 ;PUT PFN INTO PTE
	BBSS	#PTE$V_VALID,R8,70$	;SET THE VALID BIT
70$:	BICL	#PTE$M_TYP0!PTE$M_TYP1,R8
	JSB	MMG$CREPAG
	JSB	LCKPAGTBL		;LOCK THE PAGE TABLE
	MOVQ	(SP)+,R8
	BRW	26$			;GO BACK TO COMMON CODE

	.SBTTL	CHECK_WINDOW	INSURE FULLY MAPPED FILE

;+
; Functional Description:
;
;	This routine checks that a file is completely mapped (that the
;	mapping pointers for the file are permanently resident) and that
;	the file will remain completely mapped while the section exists.
;
;	There is an assumption at work here that the ACP can tolerate the
;	CATHEDRAL bit being turned on while it is working on extending
;	the file.
;
; Calling Sequence:
;
;	BSBW	CHECK_WINDOW
;
; Input Parameters:
;
;	R6		Channel on which file is open
;	FP		Address of $CRMPSC impure area
;
; Implicit Input:
;
;	None
;
; Output Parameters:
;
;	R2		Channel index
;	R8		Address of Channel Control Block
;	MMG$L_EFBLK(FP)	Largest block in file that can be mapped
;
; Implicit Output:
;
;	WCB$V_COMPLETE and WCB$V_CATHEDRAL bits are set in WCB$B_ACCESS.
;
; Completion Codes:
;
;	SS$_NORMAL			; Successful completion
;	SS$_EXBYTLM			; ACP remap operation failed
;	Error codes returned from IOC$VERIFYCHAN
;-

;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC

BEGIN_LOCKED_CODE:

CHECK_WINDOW:
	MOVL	R6,R0			; Input parameter to VERIFYCHAN
	JSB	IOC$VERIFYCHAN		; Verify it and return CCB address

; R1	Address of channel control block
; R2	Index into channel table

	PUSHR	#^M<R2,R3,R4,R5>	; Save some registers
	BLBC	R0,25$			; Branch if bad channel parameter
	MOVL	R1,R8			; Channel control block address
10$:	MOVL	CCB$L_UCB(R8),R0	; Get UCB for device characteristics
	BICL3	UCB$L_DEVCHAR(R0), -	; Check that device ...
		#<DEV$M_DIR!-		;  has directories,
		  DEV$M_FOD!-		;  is file oriented,
		  DEV$M_RND>,R0		;  and is random access
	BNEQ	30$			; Error if any characteristic is missing
	BICL3	#1,CCB$L_WIND(R8),R2	; Get window address, clearing low bit
	BEQL	35$			; Error if no file open on channel
	BLSS	15$			; Branch if R2 contains window address
	CVTWL	R2,R2			; Sign extend PSTX
	MOVL	@#CTL$GL_PHD,R0		; Get process header address
	ADDL2	PHD$L_PSTBASOFF(R0),R0	; Point R0 to base of section table
	MOVL	SEC$L_WINDOW(R0)[R2],R2	; Get window address from PSTE
	BGEQ	35$			; Error unless system address
15$:	SETIPL	W^LOCK_IPL		; Lock code and synchronize
	BBC	#WCB$V_COMPLETE,WCB$B_ACCESS(R2),40$	; Step out of line 
					;  if file is not completely mapped
	MOVL	WCB$L_FCB(R2),R3	; Get FCB address
	BEQL	20$			; All done if not FCP window

; Note that the previous branch relies on the fact that all non-FCP windows
; have already had the CATHEDRAL bit set. In addition, there is special
; code in routine INITSECTBL that takes care of file size for non-FCP
; files so that MMG$L_EFBLK does not have to be loaded. (In fact, the
; common exit code loads MMG$L_EFBLK with 0.)

	MOVL	FCB$L_EFBLK(R3),R3	; Save end-of-file block
	BBSS	#WCB$V_CATHEDRAL,WCB$B_ACCESS(R2),20$	; Set CATHEDRAL bit
20$:	SETIPL	#0			; Allow page faults to occur
	MOVL	R3,MMG$L_EFBLK(FP)	; Store end-of-file block
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
25$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				;  and return

30$:	MOVZWL	#SS$_NOTFILEDEV,R0	; Device is not file structured
	BRB	25$			; Restore registers and return

35$:	MOVZWL	#SS$_IVCHNLSEC,R0	; Return "invalid channel" error
	BRB	25$			; Restore registers and return

; Call ACP with REMAP control function to insure that all mapping pointers for
; this file are permanently resident.

40$:	SETIPL	#0			; Lower IPL to call system services
	SUBL2	#FIB$K_LENGTH,SP	; Allocate space for FIB on stack
	MOVC5	#0,(SP),#0,#FIB$K_LENGTH,(SP)	; Fill FIB with zeros
	MOVW	#FIB$C_REMAP,FIB$W_CNTRLFUNC(SP); Set ACP control function
	PUSHAL	(SP)			; Make FIB descriptor (address
	PUSHL	#FIB$K_LENGTH		;   and length)
	MOVL	SP,R5			; Save FIB address for $QIO call
	MOVAQ	-(SP),R4		; Allocate space for IOSB
	$QIOW_S	EFN=S^#EXE$C_SYSEFN,-
		CHAN=R6,-
		FUNC=#IO$_ACPCONTROL,-
		IOSB=(R4),-
		P1=(R5)
	MOVZWL	(R4),R1			;SAVE STATUS FROM IOSB
	MOVAB	<FIB$K_LENGTH+8+8>(SP),SP ; AND REMOVE IOSB AND FIB FROM STACK
	BLBC	R0,25$			;BRANCH IF FAILED TO QUEUE I/O REQUEST
	MOVL	R1,R0			;OTHERWISE, GET IO STATUS IN R0
	BLBC	R0,25$			; AND BRANCH IF REMAP FAILED
	BRW	10$			;REMAP WAS SUCCESSFUL, REPEAT CHECKS

LOCK_IPL:
	.LONG	IPL$_SYNCH		; Synchronization IPL

END_LOCKED_CODE:

; The following test insures that the code that is dynamically locked
; does not span more than two consecutive pages.

	ASSUME	<END_LOCKED_CODE-BEGIN_LOCKED_CODE> LE 512
	.PAGE
	.SUBTITLE	MMG$RET_BYT_QUOTA		RETURN BYTCNT QUOTA 
;+
;	Return BYTCNT Quota to Owner of File
;
; Functional Description:
;
;	When a window is converted to a shared WCB as part of global
;	section creation, the BYTCNT quota that was charged against
;	the process that opened the file must be returned.
;
; Input Parameter:
;
;	R0	Address of primary WCB
;
; Implicit Input:
;
;	JIB of process that opened file
;
; Output Parameters:
;
;	None
;
; Implicit Output:
;
;	JIB$L_BYTCNT is updated to account for the entire chain of WCBs.
;
;	Each WCB in a chain of WCBs has the following fields changed
;
;		WCB$L_PID is cleared
;		WCB$W_REFCNT is set to 1
;		WCB$V_SHRWCB in WCB$B_ACCESS is set
;-

MMG$RET_BYT_QUOTA::
	PUSHR	#^M<R0,R1,R2,R3>	; Get some registers to work with
5$:	DSBINT	30$			; Synchronize access to data
	MOVZWL	WCB$L_PID(R0),R1	; Get process index
	MOVL	@SCH$GL_PCBVEC[R1],R1	; Convert to PCB address
	CMPL	PCB$L_PID(R1),WCB$L_PID(R0)	; Make a consistency check
	BNEQ	20$			; Return if PIDs do not match
	MOVL	PCB$L_JIB(R1),R1	; Finally, store JIB address
	CLRL	R3			; Initialize sum

10$:	MOVZWL	WCB$W_SIZE(R0),R2	; Extract size of next WCB
	ADDL2	R2,R3			; Include in sum
	CLRL	WCB$L_PID(R0)		; Zap PID to eliminate link to process
	MOVW	#1,WCB$W_REFCNT(R0)	; Initialize REFCNT for one access
	BISB	#WCB$M_SHRWCB,WCB$B_ACCESS(R0)	; Set SHRWCB bit
	MOVL	WCB$L_LINK(R0),R0	; Get next WCB in chain
	BNEQ	10$			; Loop back if next WCB exists

	ADDL2	R3,JIB$L_BYTCNT(R1)	; Restore BYTCNT quota
	ADDL2	R3,JIB$L_BYTLM(R1)	; Restore byte limit also.
	INCW	JIB$W_FILCNT(R1)	; One less file to worry about
20$:	ENBINT				; Allow rescheduling to occur
	POPR	#^M<R0,R1,R2,R3>	; Restore registers
	RSB				;  and return

30$:	.LONG	IPL$_SYNCH		; Synchronization IPL

	ASSUME	<.-5$> LE 512		; Can only lock 512 bytes this way

	.PAGE
	.SUBTITLE	READ_RESIDENT  -  INITIALIZE A RESIDENT GLOBAL SECTION
;+
;
; Functional Description:
;
;	The contents of a resident global section is read into memory.
;	Internal interfaces are used to queue the IRP.
;	On error, the physical pages are released.
;
; Input Parameters
;
;	R3 - First global PTE
;	R7 - page count
;
; Registers destroyed
;
;	R0,R1,R2,R3,R4,R7
;
;*********************************************************************
;*********LESS THAN IDEAL FOR GENERAL USE***************************
; THIS ROUTINE DOES A WAIT FOR IO COMPLETION HOLDING GSD MUTEX
; THIS ROUTINE DOES NOT CHECK DIOCNT
; THIS IS NOT ACCEPTABLE FOR A DOCUMENTED, GENERAL USE INTERFACE
; THIS IS INTENDED ONLY FOR USE DURING SYSTEM INITIALIZATION
;*********************************************************************
;-

READ_RESIDENT:
	PUSHL 	R7			; Save count
	MOVZWL	#IRP$C_LENGTH,R1	; Get an IRP
	JSB	EXE$ALONONPAGED		; Return IRP in R2
	BLBC	R0,50$			; None available
	MOVL	SCH$GL_CURPCB,R4
	PUSHR	#^M<R3,R5>
	MOVL	R2,R5			; IRP address
	MOVAL	200$,IRP$L_ASTPRM(R5)	; AST to free the IRP
	MOVB	PCB$B_PRIB(R4),IRP$B_PRI(R5) ; Transfer priority
	CLRL	IRP$L_IOST1(R5)
	MOVL	SEC$L_VBN(R10),R0	; Starting VBN
	ASHL	#9,R7,R1		; Byte count
	MOVL	SEC$L_WINDOW(R10),R2	; WCB address
	MOVL	R5,R7			; Save IRP address
	JSB	EXE$BLDPKTSWPR	; Build and queue IRP
	POPR	#^M<R3,R5>		; Get back PHD, SVAPTE
10$:	MOVL	#RSN$_ASTWAIT,R1	; Wait for an AST
	JSB	MMG$RESRCWAIT		; Set up to wait for the resource
	MTPR	100$,#PR$_IPL
	MOVPSL	-(SP)			; Wait requires PC-PSL
	JSB	MMG$SVPCTX		; Go wait
;
;	We need some way to tell when the I/O is done, but we can't get an
;	AST since we are at ASTDEL.  Instead, look for the IRP to be put
;	on the AST queue.
;
	MOVAB	PCB$L_ASTQFL(R4),R0	; Get AST queue
	MOVL	R0,R1			; Save it for comparison
20$:	MOVL	(R0),R0			; Next AST on queue
	CMPL	R0,R1			; Are we back at beginning
	BEQL	10$			; Yes - go wait some more
	CMPL	R0,R7			; Is this the one we want
	BNEQ	20$			; No - look for another one
	MTPR	#IPL$_ASTDEL,#PR$_IPL	; Go back to reasonable IPL
;
	MOVZWL	IRP$L_IOST1(R7),R0	; Get IO status
	BLBC	R0,50$			; Error
	ADDL	#4,SP			; Clean up stack
	RSB

;
; Error - clean up and release physical memory
;
50$:	POPL	R7			; Get back the page count
	PUSHL	R0			; Save the error status
60$:	MTPR	100$,#PR$_IPL
	MOVL	(R3),R0			; Get the GPTE
	BICL	#^C<PTE$M_PFN>,R0	; Leave only PFN
	DECW	@PFN$AW_REFCNT[R0]
	JSB	MMG$RELPFN		; Release the page
	JSB	MMG$DECPTREF		; Global page table ref count
	ADDL	#4,R3			; Next GPTE
	MTPR	#IPL$_ASTDEL,#PR$_IPL	; Go back to reasonable IPL
	SOBGTR	R7,60$
	BRW	FRESTXERR		; Error clean-up - expects R0 on stack

100$:	.LONG	IPL$_SYNCH		; Synchronization IPL
	ASSUME	<. - 50$> LE 512 	; Can only lock 512 bytes this way

;
; I/O completion AST - delivered after IPL drops
; Free the IRP
;
200$:	MOVL	R5,R0
	JSB	EXE$DEANONPAGED
	RSB

;+
;
; Functional description:
;
;	Lock the page table in memory.
;
; Input Parameters
;
;    For LCKPAGTBL only
;	R2 - VA of page represented by page table to be locked
;
;    For LCKPAGTBL1 only
;	R1 - virtual page number
;	R3 - pointer to base of appropriate page table
;
; Registers destroyed
;	LCKPAGTBL1 only
;	 R2
;
;
;-
; *************************************************************************
;************** THIS CODE MUST NOT PAGE *********************************
;
	.SAVE_PSECT
	.PSECT $MMGCOD,LONG
;
;****************************************************************************
;
LCKPAGTBL:
	PUSHR	#^M<R0,R1,R3>
	BSBW	MMG$PTEREF		;GET THE SVAPTE 
	MOVL	#1,R0			;LOCK INDICATOR
	BSBW	MMG$MOVPTLOCK		;DO ALL THE WORK
	MTPR	#IPL$_ASTDEL,#PR$_IPL	;WE DON'T WANT TO STAY AT SYNCH
	POPR	#^M<R0,R1,R3>
	RSB

LCKPAGTBL1:
	PUSHR	#^M<R0,R3>
	BLBS	R9,20$			;Indicator for first time through loop
	BITB	#^X7F,R1		;Is it first one in new page
	BEQL	20$			;Yes - do it the hard way
	MTPR	#IPL$_SYNCH,#PR$_IPL	;Don't let anything change
	MOVAL	@(R3)[R1],R3		;Get the SVAPTE
	SUBL3	PHD$L_P0BR(R5),R3,R2	;Byte offset of PTE
	ASHL	#-9,R2,R0		;Byte index of containing page table
	ADDL3	PHD$L_PTWSLELCK(R5),R5,R2 ;Locked working set list entries
	ADDL2	R0,R2			;Address of count byte for # of locked
					; WSLE's in the page table
	INCB	(R2)			;Add one for WINDOW/MA780 global page
10$:	MTPR	#IPL$_ASTDEL,#PR$_IPL	;We don't want to stay at synch
	POPR	#^M<R0,R3>
	RSB
;
20$:	BICB	#1,R9			;Just in case this is the first time
	TSTL	@(R3)[R1]		;Make sure page table is resident
	MTPR	#IPL$_SYNCH,#PR$_IPL	;Don't let anything change
	MOVAL	@(R3)[R1],R3		;Get the SVAPTE
	MOVL	#1,R0			;Lock indicator
	BSBW	MMG$MOVPTLOCK		;Do all the work
	BRB 	10$
	.RESTORE_PSECT

	.END
