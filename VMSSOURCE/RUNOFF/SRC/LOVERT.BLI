%TITLE 'Line output (vertical motion)'
MODULE LOVERT (	IDENT = 'V04-000'
    		%BLISS32[,ADDRESSING_MODE(EXTERNAL =	LONG_RELATIVE,
    					  NONEXTERNAL =	LONG_RELATIVE)]
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY:	 DSR (Digital Standard RUNOFF) / DSRPLUS
!
! ABSTRACT: Translation from intermediate format to final output.
!
!
! ENVIRONMENT: Transportable
!
! AUTHOR: K. A. Dawson	 CREATION DATE: December 1983
!

%SBTTL 'Revision History'
!
! MODIFIED BY:
!
!	013	REM00013	Ray Marshall	30-Nov-1983
!		Initialize the local BRANCH within routine LOUT to eliminate
!		  informational message generated by the compiler.
!
!	012	KFA00012	Ken Alden	05-Oct-1983
!		Removed left margin fix from #11 and added checking for
!		  sca_margin_pad.
!
!	011	KFA00011	Ken Alden	27-Jul-1983
!		For DSRPLUS: Added a few comments and included the left margin
!		  in the figuring of the special cased CREF (only) line.  This
!		  is found in the first line of LOUT.
!
!	010	KFA00010	Ken Alden	8-Jul-1983
!		Just changed the conditional for dsrplus so the cref stuff
!		  would not be seen be DSR.
!
!	009	KFA00009	Ken Alden	30-Jun-1983
!		Logic that was put into this routine in #8 was not totally
!		  correct so a cref was getting held up for quite some time.
!		Output of crefs is handled in this module and LOUT1.  Crefs,
!		  however, will increment the tsf_int_hl and there may not
!		  be anything on the line.  Therefore we test tsf_ext_hl so
!		  see if there is any text.
!
!	008	KFA00008	Ken Alden	29-Jun-1983
!		Lout now checks tsf_cref_data before returning.
!
!	007	KFA00007	Ken Alden	29-Jun-1983
!		In the very weird cases where the mra only contains vertical
!		  rintes sequences and any number of crefs, LOUT1 is NOT
!		  called to dump the crefs since going over to LOUT1 meant never
!		  returning without a crlf getting output.  
!
!	006	KFA00006	Ken Alden	28-Jun-1983
!		Calling lout1 now if tsf_cref_data GTR 0.
!
!	005	REM00005	Ray Marshall	17-Jun-1983
!		Remove call to OUTCREF because it's been moved to LOUT1 (in
!		  module LOHORI) based on a new escape sequence in the MRA.
!
!	004	KAD00004	Keith Dawson	3-Jun-1983
!		Call OUTCREF from here (not from LOHORI), in order to 
!		  assure that cref records are written to the .BRN even 
!		  when Quick is set.
!
!	003	KAD00003	Keith Dawson	9-May-1983
!		Remove support for .DX, .PX (remove references to ASGXTN).
!
!	002	KFA000021	Ken Alden 	29-Apr-1983
!		Added code for START_ODD chapters.
!
!--

%SBTTL 'Module Level Declarations'

!
! TABLE OF CONTENTS:
!

REQUIRE 'REQ:RNODEF';			! RUNOFF variant definitions

FORWARD ROUTINE
    JUSTF : NOVALUE,
    LOUT : NOVALUE,
    find_next_dot : NOVALUE,
    ascftn : NOVALUE;

!
! INCLUDE FILES:
!
LIBRARY 'NXPORT:XPORT';			! XPORT Library

%IF DSRPLUS %THEN
LIBRARY 'REQ:DPLLIB';			! DSRPLUS BLISS Library
%ELSE
LIBRARY 'REQ:DSRLIB';			! DSR BLISS Library
%FI
!
! MACROS:
!

MACRO
    exchange (a, b) =
	BEGIN
	LOCAL h;
	h = .(a); a = .(b); b = .h;
	END
    %;

MACRO
    save_xtn (page_ref, xtn) =
	BEGIN
!!	IF NOT .gca_bix
!!	THEN
!!	    asgxtn (page_ref, xtn);
	IF .gca_bix
	THEN
	    putxtn (page_ref, xtn);
	END
    %;

!
! EQUATED SYMBOLS:
!

EXTERNAL LITERAL
    rintes : UNSIGNED (8);

!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!

EXTERNAL
    fnct : fnct_definition,
    gca : gca_definition,
%IF DSRPLUS %THEN
    sca : sca_definition,
%FI
    hct : hct_definition,
    mra : ref fixed_string,
    tsf : tsf_definition,
    npagen : page_definition,
    pagen : page_definition,
    phan : phan_definition;

EXTERNAL LITERAL 				! Error messages
    rnfile;

EXTERNAL ROUTINE
    cskipl,	erms,	
%IF DSRPLUS %THEN
    outcref,
%FI
    lout1,	newpag,
    putxtn,	tpr,	uskipl;

%SBTTL 'LOUT -- generate output line'
GLOBAL ROUTINE lout : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOUT accepts as input a line of text as encoded by SCANT and described
!	by the TSF data structure.  If GCA_SKIP_OUT is true, the line is
!	ignored; otherwise LOUT generates the necessary device control
!	sequences that cause the line to be printed correctly and leaves its
!	output in the FRA to be output by OUTLIN.
!
! FORMAL PARAMETERS:	None
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:
!
!	PHAN_FIGURE	-
!	PHAN_TOP_PAGE	-
!	PHAN_FORM_PEND	- Controls whether a formfeed is written to output
!			  (if nonzero).
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--

    BEGIN

    LOCAL
	branch : INITIAL (false),
	ptr_copy,
	tsf_phregs : REF VECTOR [tsf_nregs];

    !			Nothing to output??
    ! TSF_INT_?L NEQ 0	means either paper control codes and/or some text to
    !			be output.
    ! TSF_FIRST_XTN NEQ 0  means that there is an index entry referring to
    ! 			something on the current page;  it is possible for just
    ! 			this item to be set.  That can happen if, for example,
    ! 			the very first command in the file is a .INDEX command,
    ! 			and a .SKIP command follows that.

%IF DSRPLUS %THEN
    !
    ! Text to do (processing needed in LOUT1)?
    ! If the following branch is taken, then the only 'text' in the MRA is
    ! cref information.  In some instances, there also may be a few spaces
    ! at the beginning of the line.  This is from the left margin padding in 
    ! FCIMRA.  If this is the case, then we just ignore the line since lout
    ! would normally exit at this point since FCIMRA never would have 
    ! been called from CREF and the padding never would have occured.
    !
    IF 	.tsf_int_hl - (3 * .tsf_cref_count) EQL 0 
			OR
	(.tsf_int_hl - (3 * .tsf_cref_count) EQL .sca_margin_pad 	
			AND
	.tsf_ext_hl EQL .sca_margin_pad)
    THEN
    	BEGIN    	
	WHILE .tsf_cref_data NEQ 0 DO outcref (); !Dump all pending crefs.
    	tsf_int_hl = .tsf_int_hl - (3 * .tsf_cref_count);
    	tsf_cref_count = 0;		! Clear this flag since all crefs are done
    	IF (.tsf_int_vl EQL 0)		!  Vertical positioning?
	    AND (.tsf_first_xtn EQL 0)	!  Indexing to do?
	    AND (.tsf_footw EQL 0)	!  Footnotes attached to this line?
        THEN
	    RETURN;			! THEN do absolutely nothing.
    	END;
%ELSE

    IF 	.tsf_int_hl EQL 0 !  Text to do (processing needed in LOUT1)?
    	AND (.tsf_int_vl EQL 0)		!  Vertical positioning?
	AND (.tsf_first_xtn EQL 0)	!  Indexing to do?
	AND (.tsf_footw EQL 0)		!  Footnotes attached to this line?
    THEN
    	RETURN;				! THEN do absolutely nothing.
%FI

    tsf_phregs = tsf__phregs;
    ptr_copy = .fs_start (mra);

    INCR k FROM 1 TO .tsf_int_vl DO	! Process vertical movement
	BEGIN

	LOCAL
	    hold_khar;

	hold_khar = CH$RCHAR_A (ptr_copy);

	! All vertical motion code starts with RINTES.  Otherwise it shouldn't
	! be there and is an error (see the ELSE branch, below).
	IF .hold_khar EQL RINTES
	THEN
	    BEGIN

	    LOCAL
		op_code,
		operand;

	    ! The character after RINTES indicates what type of vertical motion
	    ! is to be done, and gets saved as OP_CODE.  The character after
	    ! that is either a dummy or is a parameter; it gets saved as
	    ! OPERAND.
	    op_code = CH$RCHAR_A (ptr_copy);
	    operand = CH$RCHAR_A (ptr_copy);
	    k = .k + 2;

	    ! Process the particular type of vertical motion
	    SELECTONE .op_code OF
		SET

		[%C'p'] :
		    phan_top_page = true;	! Start a new page

		[%C's'] :
		    cskipl (.tsf_phregs [.operand]);	! skip lines if not top
							! of page
		[%C'u'] :
		    BEGIN    ! skip lines regardless of page position

		    IF (.phan_top_page
			AND NOT .fnct_expanding)
		    THEN
			newpag ();

		    uskipl (.tsf_phregs [.operand]);
		    END;

		[%C'd'] :
		    ! Defer blank lines until top of page
		    phan_figure = .phan_figure + .tsf_phregs [.operand];

		[%C'g'] :
		    ! Go to a specific line immediately.
		    ! Start a new page if necessary.
		    ! NOTE: You can only go to a line within the text area of
		    !	    the page.  So a negative line number is interpreted
		    !	    as that many lines above the footer area (but not
		    !	    above footnotes).
		    BEGIN

		    LOCAL
			x,	! TRUE, if not already past that position.
			y;	! Skip this many lines to position.

		    IF (.tsf_phregs [.operand] LSS 0)
		    THEN	! Count from bottom.
			x = tpr (ABS (.tsf_phregs [.operand]) )
		    ELSE	! Absolute line number.
			x = (.tsf_phregs [.operand]) GEQ .phan_lines_tp;

		    IF NOT .x
		    THEN
			newpag ();	! Already too far.  Start a new page.

		    IF (.tsf_phregs [.operand] LSS 0)
		    THEN
			y = .phan_llines - .hct_layoutn - .phan_lines_tp + .tsf_phregs [.operand]
		    ELSE
			y = .tsf_phregs [.operand] - .phan_lines_tp;
			
		    ! If already at that position do nothing.  However, if not
		    ! at that position, get there.  Note the following special
		    ! case:  if we're at the top of a page then we have to get
		    ! past the top of the page for the counting to work
		    ! correctly.
		    IF .y NEQ 0
		    THEN
			BEGIN
			uskipl (1);	! Force a blank line to get past the
					! top of the page, if that's the case.

			! Now recompute position all over again, since
			! we may have just gotten past the top of a page.
			IF  (.tsf_phregs [.operand] LSS 0)
			THEN
			    y = .phan_llines - .phan_lines_tp - .hct_layoutn + .tsf_phregs [.operand]
			ELSE
			    y = .tsf_phregs [.operand] - .phan_lines_tp;

			! Now do the remainder of the positioning to the
			! proper spot.
			uskipl (.y)
			END
		    END;

		[%C'.'] :
		    BEGIN

		    IF .branch
		    THEN
		    ! Skip until next '.' is found.
			find_next_dot (k, ptr_copy, hold_khar);

		    branch = not .branch
		    END;

		[%C't'] :
		    ! Test page
		    BEGIN

		    IF tpr (.tsf_phregs [.operand])
		    THEN
		    ! Take the 'THEN' branch
			branch = true
		    ELSE
		    ! Skip the 'THEN' branch.
			BEGIN
			find_next_dot (k, ptr_copy, hold_khar);
			branch = false;
			END

		    END;
    
		[%C'w'] :
    		    IF (.pagen[sct_run_page] MOD 2) EQL 0
    		    THEN 
    			phan_top_page = true		!Simply start a new page
    		    ELSE
    			BEGIN
    			IF .phan_top_first EQL 0
    			THEN
    			    BEGIN
    			    LOCAL 
    			    	hold_headers;

    			    hold_headers = .hct_headers;	!Save the status of headers
    			    hct_headers = false;
    			    newpag ();				!Throw a 'blank' page
			    uskipl (1);				! Force a blank line to get past the
			 					! top of the page, if that's the case.
    			    npagen [sct_page] = 1;		!number the next page "1"
    			    hct_headers = .hold_headers;
    			    phan_top_page = true;		!And start another new page
    			    END
    			ELSE
    			    phan_top_page = true;		!And start another new page
    			END;
    			
		[OTHERWISE] :
		    ! Unrecognized sequence!!
		    ! Issue error message and carry on.
		    BEGIN
		    erms (rnfile, CH$PTR (UPLIT ('lout')), 4);
		    END;
		TES;

	    END
	ELSE
	! Not an escape sequence.
	! Issue an error message and ignore the character.
	    BEGIN
	    erms (rnfile, CH$PTR (UPLIT ('lout')), 4);
	    END;

	END;

    ! Paper-motion codes have been taken care of.

    ! The index entry is associated with the current page number.  However,
    ! what the current page number is depends on whether or not there is some
    ! text on the page.  According to "strict" usage of indexing, indexing
    ! commands should go immediately after the line to which they apply.
    ! However, it can be expected that users will do the natural thing,
    ! i.e., put the indexing commands before the text to which they apply.
    ! This leads to the situation where the (other) indexing routines have no
    ! text with which to associate the index entry; for example, this is
    ! obviously true at the top of the very first page, or the top of any page
    ! for that matter.
    IF 	.tsf_int_hl NEQ 0 
    THEN
	! There is some text to be output.
	BEGIN
%IF DSRPLUS %THEN
	IF (.tsf_int_hl EQL .sca_margin_pad 	
			AND
	   .tsf_ext_hl EQL .sca_margin_pad)
	THEN
	    RETURN;
%FI

	lout1 (.ptr_copy);		! Output text.

	IF .tsf_last_xtn NEQ  0
	THEN
	    save_xtn (pagen, .tsf_last_xtn);	! Associate current page number
	END					! with transaction number.
    ELSE
    	!
	! Promote index entries attached to this line, if any.
	IF .tsf_last_xtn NEQ 0
	THEN
	    BEGIN
	    IF (.phan_top_page
		AND NOT .phan_top_first)
	    THEN
		save_xtn (npagen, .tsf_last_xtn)
	    ELSE
		save_xtn (pagen, .tsf_last_xtn);
	    END;

    ! Clear transaction numbers in the TSF.  This is done so that for things
    ! such as titles, that reoccur, no attempt is made to "redefine" the page
    ! number associated with the transaction number.
    tsf_first_xtn = 0;
    tsf_last_xtn = 0;

    ! If there were any footnotes associated with this line, associate them
    ! with this page.
    ascftn ();
    END;					! End of LOUT

%SBTTL 'JUSTF -- Compute spaces needed for justification'
GLOBAL ROUTINE JUSTF (PADDING, INSERT_COUNT, SPACE_COUNT, ALGORITHM) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Computes the number of spaces to be dropped between words
!	and their locations.
!
! FORMAL PARAMETERS:
!
!	INSERT_COUNT is the number of places where spaces can
!	be inserted.  SPACE_COUNT is the number of spaces to
!	be distributed.
!	ALGORITHM specifies how spaces are to be distributed.
!	The space distribution is returned in PADDING as a set
!	of insert counts.
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:	None
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--

    BEGIN

    MAP
	PADDING : REF VECTOR;

    LOCAL
	SPACES_PER_I,		! This many spaces inserted per word.
	REMAINING,		! This many "odd" spaces remain.
	RIGHT_INSERT,		! Put this many spaces at the right.
	LEFT_INSERT,		! Put this many spaces between words on left.
	RIGHT_COUNT,		! There are this many words on the right.
	LEFT_COUNT,		! There are this many words on the left.
	PI;			! Index into padding.

    SPACES_PER_I = .SPACE_COUNT/.INSERT_COUNT;
    REMAINING = .SPACE_COUNT MOD .INSERT_COUNT;
    LEFT_INSERT = .SPACES_PER_I;
    RIGHT_INSERT = .SPACES_PER_I + (.REMAINING NEQ 0);
    RIGHT_COUNT = .REMAINING;
    LEFT_COUNT = .INSERT_COUNT - .RIGHT_COUNT;

    IF .ALGORITHM
    THEN
	BEGIN					! Use alternate space distribution algorithm.
	EXCHANGE (LEFT_INSERT, RIGHT_INSERT);
	EXCHANGE (LEFT_COUNT, RIGHT_COUNT);
	END;

    PI = 0;

    INCR I FROM 1 TO .RIGHT_COUNT DO
	BEGIN
	PADDING [.PI] = .RIGHT_INSERT;
	PI = .PI + 1;
	END;

    INCR I FROM 1 TO .LEFT_COUNT DO
	BEGIN
	PADDING [.PI] = .LEFT_INSERT;
	PI = .PI + 1;
	END;

    END;					! End of JUSTF

%SBTTL 'FIND_NEXT_DOT -- Skip to next "." in text.'
ROUTINE FIND_NEXT_DOT (N, PTR, KHAR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Skip text until a "." is seen
!
! FORMAL PARAMETERS:
!
!	N	-  Address of current offset into the string.
!	PTR	-  Address of a String descriptor pointing to a text string.
!	KHAR	-  Character just beyond the period (returned value).
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:
!
!	N and PTR are advanced to reflect updated position.
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--

    BEGIN

    MACRO
	K = .N %,
	PTR_COPY = .PTR %,
	HOLD_KHAR = .KHAR %;

    WHILE 1 DO
    BEGIN
    HOLD_KHAR = CH$RCHAR_A (PTR_COPY);
    K = .K + 1;

    IF .HOLD_KHAR EQL RINTES
    THEN
	BEGIN
	LOCAL
	    TEMP;
	TEMP = CH$RCHAR_A (PTR_COPY);
	K = .K + 1;
	HOLD_KHAR = CH$RCHAR_A (PTR_COPY);
	K = .K + 1;

	IF .TEMP EQL %C'.'
	THEN
	    RETURN;
	END
    END
    END;					! End of find_next_dot

%SBTTL 'ASCFTN -- Associate this line''s fn''s to this page'
GLOBAL ROUTINE ASCFTN : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Associates footnotes associated with the current line with
!	the current page.  Such footnotes may be output at any point after
!	this.
!
! FORMAL PARAMETERS:	None
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:	None
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--

    BEGIN

    FNCT_READY = .FNCT_READY + .TSF_FOOTW;	! Number of footnotes that can be output.
    ! The following code is not really necessary.  All it does is establish a
    ! consistancy check to make sure footnotes are being counted correctly.
    FNCT_WAITING = .FNCT_WAITING - .TSF_FOOTW;	! Reduce number of footnotes "in limbo."
    TSF_FOOTW = 0;				! Forget these footnotes now, so they don't get counted twice accidentally.

    ! Now perform the consistancy check.
    IF
	.FNCT_WAITING LSS 0
    THEN
	! Something's wrong. Complain (INTERNAL LOGIC) and try to recover.
	BEGIN
	ERMS (RNFILE, CH$PTR (UPLIT ('ASCFTN')), 6);
	! Attempt to reset this consistancy check so this message
	! doesn't continue to happen.
	FNCT_WAITING = .FNCT_COUNT - .FNCT_READY
	END;

    ! Clear out the counter, so these footnotes don't get counted twice.
    TSF_FOOTW = 0;

    END;					! End of ascftn

END						! End of module
ELUDOM
