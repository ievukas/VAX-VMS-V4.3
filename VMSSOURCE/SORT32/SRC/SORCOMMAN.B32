MODULE SOR$COMMAND (
		IDENT = 'V04-000'	! File: SORCOMMAN.B32 Edit: PDG3024
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:	VAX-11 SORT/MERGE
!
! ABSTRACT:
!
!	This module processes the SORT/MERGE command line.
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: Peter D Gilbert, CREATION DATE: 07-Jan-1982
!
! MODIFIED BY:
!
!	T03-015		Original
!	T03-016	Added a check that the CLI$K_SORT_xxx and CLI$K_MERG_xxx
!		externals have the same value.  PDG 9-Dec-1982
!	T03-017	Remove reference to CLI$END_PARSE.  PDG 22-Dec-1982
!	T03-018	Stable option is allowed for merges.  PDG 27-Jan-1983
!	T03-019	Change DEC_MULTINATIONAL to MULTINATIONAL.  PDG 13-Apr-1983
!	T03-020	Various changes for KANJI.  PDG 2-May-1983
!	T03-021	Make SOR$$DTYPE_T_W a weak external.  PDG 19-May-1983
!	T03-022	Convert to use new CLI interface.  PDG 10-Aug-1983
!	T03-023	New CLI interface for checkpointing.  PDG 15-Dec-1983
!	T03-024	Conditionalize checkpointing code.  PDG 07-Jan-1984
!--

LIBRARY	'SYS$LIBRARY:LIB';
REQUIRE 'SRC$:SORMSG';
!+
!
! Note that we do not use SORLIB.REQ.  This ensures that the code in this
! module does not depend on internal data structures.
!
!-

! These literals control support for user-defined key data types,
! and checkpointing.
!
LITERAL
    FUN_K_KANJI = %VARIANT,
    FUN_K_CHECKPOINT = %VARIANT;


FORWARD ROUTINE
    CMD_ERROR,					! Issue an error diagnostic
    SOR$$COMMAND,				! Parse the command line
    NUMERIC_PARSE,				! Parse a number
    SET_SPEC:		NOVALUE,		! Parse specification file name
    SET_COLL:		NOVALUE,		! Get argument of /COLLATING_SEQUE=
    SET_BUCK:		NOVALUE,		! Get the number of buckets
    SET_ALLO:		NOVALUE,		! Get output file allocation
    SET_OUT_FMT:	NOVALUE,		! Set output file record format
    SET_INP_FMT:	NOVALUE,		! Set input record format
    SET_KEY:		NOVALUE,		! Parse and store key definitions
    LOOKUP_KEY,					! Compare keyword strings
    !
    ! Define the SORT-specific routines
    !
    SET_PROC:		NOVALUE,		! Set type of process requested
    NOT_WORK:		NOVALUE,		! Set no work files
%IF FUN_K_KANJI %THEN
    DEL_BOTH,
    SET_DUPL:		NOVALUE,
%FI
    SET_WORK:		NOVALUE;		! Get the number of work files


%IF FUN_K_CHECKPOINT %THEN
EXTERNAL ROUTINE
    !
    ! Routines that interface to the CLI
    !
    CLI_BEGIN:		NOVALUE,		! Setup CLI processing
    CLI_GET_VALUE,				! Get value of item
    CLI_PRESENT,				! Determine if item is present
    CLI_NEXT_QUAL,				! Get next qualifier
    CLI_END:		NOVALUE;		! End CLI processing
%ELSE
EXTERNAL ROUTINE
    !
    ! Routines that interface to the CLI
    !
    CLI$GET_VALUE,				! Get value of item
    CLI$PRESENT,				! Determine if item is present
    CLI$NEXT_QUAL;				! Get next qualifier
BIND ROUTINE
    CLI_GET_VALUE	= CLI$GET_VALUE,
    CLI_PRESENT		= CLI$PRESENT,
    CLI_NEXT_QUAL	= CLI$NEXT_QUAL;
%FI

MACRO
    ! Macro to test an assertion about compile-time constants.
    !
    ASSERT_(A)=
	%IF NOT (A)
	%THEN
	    %ERROR('Assertion failed')
	%FI %;

! These macroes define the external and internal representations of options for
! command line qualifiers.  The second parameter in each pair may be translated;
! the first, however, is used to define the internal name for this option, and
! may not be translated.
!
MACRO
    STR_OPT_OUTFMT =			! outfile/FORMAT=(...)
	'FIXE',	'FIXED',
	'VARI',	'VARIABLE',
	'CONT',	'CONTROLLED',
	'SIZE',	'SIZE',
	'BLOC',	'BLOCK_SIZE' %,

    STR_OPT_INPFMT =			! inpfile/FORMAT=(...)
	'FILE',	'FILE_SIZE',
	'RECO',	'RECORD_SIZE' %,

    STR_OPT_PROCESS =			! /PROCESS=...
	'RECO',	'RECORD',
	'TAG',	'TAG',
	'ADDR',	'ADDRESS',
	'INDE',	'INDEX' %,

    STR_OPT_KEY =			! /KEY=...
	'ASCE',	'ASCENDING',
	'BINA',	'BINARY',
	'CHAR',	'CHARACTER',
	'DECI',	'DECIMAL',
	'DESC',	'DESCENDING',
%IF FUN_K_KANJI %THEN
	'DTYP',	'DTYPE',
%FI
	'F_FL',	'F_FLOATING',
	'D_FL',	'D_FLOATING',
	'G_FL',	'G_FLOATING',
	'H_FL',	'H_FLOATING',
	'LEAD',	'LEADING_SIGN',
	'NUMB',	'NUMBER',		! NUMBER:nn
	'OVER',	'OVERPUNCHED_SIGN',
	'POSI',	'POSITION',		! POSITION:nn
	'PACK',	'PACKED_DECIMAL',
	'SI',	'SI',			! SI:nn or SIGNED
	'SIGN',	'SIGNED',
	'SIZE',	'SIZE',			! SIZE:nn
	'SEPA',	'SEPARATE_SIGN',
	'TRAI',	'TRAILING_SIGN',
	'UNSI',	'UNSIGNED',
	'ZONE',	'ZONED' %,

    STR_OPT_COLL =
	'ASCI',	'ASCII',
	'EBCD',	'EBCDIC',
	'MULT',	'MULTINATIONAL' %;


! Default specification file
!
MACRO
    STR_DEF_SPECFILE =	'SYS$INPUT' %;

EXTERNAL LITERAL
    SOR$M_STABLE,
    SOR$M_SEQ_CHECK,
    SOR$M_NODUPS,
    SOR$M_EBCDIC,
    SOR$M_MULTI,
    SOR$M_LOAD_FILL;

EXTERNAL LITERAL
    SOR$GK_RECORD,
    SOR$GK_TAG,
    SOR$GK_ADDRESS,
    SOR$GK_INDEX;

! Define the maximum number of keys we will allow.  This need not agree with
! the value used by the callable interface routines, but it should be as large.
!
LITERAL
    MAX_KEYS = 255;

MACRO
    ELIF =	ELSE IF %,
    BASE_ =	0, 0, 0, 0 %,
    W0_=	0, 16,0 %,
    W1_=	16,16,0 %,
    SW1_=	16,16,1 %;

MACRO
    ! Fields for key buffer.
    !
    KEY_NUMBER=		0, W0_ %,	! Number of key descriptions
    KEY_KBF(N)=		2*(N),16,0,0 %,	! Address of KBF (0..number-1)
    KBF_TYPE=		0, W0_ %,	! Data type of key
    KBF_ORDER=		0, W1_ %,	! True iff descending order
    KBF_ORDER_S=	0, SW1_ %,	! Signed version of KBF_ORDER
    KBF_POSITION=	1, W0_ %,	! Offset to key within record (1..LRL)
    KBF_LENGTH=		1, W1_ %;	! Length of key
LITERAL
    KBF_S_ENTRY=	2;		! Size in longwords of key description


%IF NOT %DECLARED(SORT$_FACILITY)
%THEN
    LITERAL
	SORT$_FACILITY = SOR$_FACILITY;
    UNDECLARE
	SOR$_FACILITY;
    %FI
MACRO
    DEFSHR_[MSG,SEV] =
	%NAME('SOR$_SHR_',MSG) =
	    %NAME('SHR$_',MSG) +
	    %NAME('STS$K_',SEV) + SORT$_FACILITY ^ 16 %;
LITERAL
    DEFSHR_(
	BADBYTE,  SEVERE,	! Invalid data (!XB) at !XL
	BADKEY,   SEVERE,	! !AS is an invalid keyword
	BADLOGIC, SEVERE,	! Internal logic error detected
	BADWORD,  SEVERE,	! Invalid data (!XW) at !XL
	NOVALUE,  SEVERE,	! '!AS' keyword requires a value
	SYNTAX,   SEVERE,	! Error parsing !AS
	SYSERROR, SEVERE);	! System service error
LITERAL
    SOR$_SHR_BADKEY_W =
	SHR$_BADKEY + STS$K_WARNING + SORT$_FACILITY ^ 16;

! This macro builds a keyword description table, passed to LOOKUP_KEY
!
MACRO
    KEY_TABLE_[] =
	LITERAL	TABLE_SIZE = %LENGTH/2,
		KEY_TABLE1_(%REMAINING);
	BIND	KEYWORD_TABLE = PLIT(KEY_TABLE2_(%REMAINING)): VECTOR %,
    KEY_TABLE1_[X,Y] = %NAME('K_',X) = %COUNT %,
    KEY_TABLE2_[X,Y] = UPLIT BYTE(%ASCIC Y) %;


! This macro stores a value in a variable.  It checks for overflow.
!
MACRO
    STORE_(X,Y) =
	%IF %ALLOCATION(X) LSS %UPVAL
	%THEN
	    BEGIN
	    LOCAL
		Z;	! So Y is evaluated only once; a BIND may be better
	    Z = (Y);
	    X = .Z;
	    IF .Z<0,%ALLOCATION(X)*%BPUNIT,0> NEQ .Z
	    THEN
		RETURN CMD_ERROR(
		    %IF %ALLOCATION(X) EQL 1
		    %THEN SOR$_SHR_BADBYTE
		    %ELSE SOR$_SHR_BADWORD
		    %FI, 2, .Z, 0);
	    END
	%ELSE
	    X = (Y)
	%FI %;


! Define these mnemonic literals
!
LITERAL
    TRUE =		1,
    FALSE =		0;


! Define the ONEOF macro, and its related macroes.
!
MACRO
    XBMSK_[A]= (1 ^ (31 - (A))) %,
    BMSK_[]= (0 OR XBMSK_(%REMAINING)) %,
    ONEOF_(A,B)= (((B) ^ (A)) LSS 0) %;

! Define bit positions within FLAGS
!
LITERAL
    IOS_SORT=		1,	! True if we were invoked for SORT
    IOS_SEQU=		2,	! /SEQUENTIAL
    IOS_RELA=		3,	! /RELATIVE
    IOS_INDE=		4,	! /INDEXED
    IOS_OVER=		5,	! /OVERLAY
    IOS_BUCK=		6,	! /BUCKET
    IOS_ALLO=		7,	! /ALLOCATION
    IOS_WORK=		8,	! /WORK_FILES
    IOS_CONT=		9,	! /CONTIGUOUS
    IOS_STAB=		10,	! /STABLE
    IOS_STAT=		11,	! /STATISTICS
    IOS_LOAD=		12,	! /LOAD
    IOS_CHEC=		13,	! /CHECK
    IOS_DUPL=		14,	! /DUPLICATES
    IOS_KEY=		15,	! /KEY
    IOS_PROC=		16,	! /PROCESS
    IOS_BOTH=		17,	! /DUPLICATES=DELBOTH
    IOS_CHKP=		18;	! /CHKPNT

! Define the codes for the sort or merge qualifiers
! Note that they both use the the names CLI$K_SORT_xxx.
! If any SORT-specific qualifiers are used with MERGE, or any MERGE-specific
! qualifiers are used with SORT, the code will signal CLI$_INVQUAL.
!
MACRO
    QUALCODES =
	!
	! The SORT-specific qualifiers
	!
	'PROCESS',		! /PROCESS=sort-type
	'WORK_FILES',		! /WORK_FILES=n
	!
	! The MERGE-specific qualifiers
	!
	'CHECK_SEQUENCE',	! /CHECK_SEQUENCE
	!
	! The qualifiers common to both SORT and MERGE
	!
	'KEY',			! /KEY=sort-key
	'SPECIFICATION',	! /SPECIFICATION=spec-file
	'STABLE',		! /STABLE
	'COLLATING_SEQUENCE',	! /COLLATING_SEQUENCE=collating-type
	'STATISTICS',		! /STATISTICS
	'DUPLICATES',		! /DUPLICATES
%IF FUN_K_CHECKPOINT %THEN
	'CHKPNT',		! /CHKPNT
%FI
	!
	! Output file qualifiers
	!
	'SEQUENTIAL',		! /SEQUENTIAL
	'RELATIVE',		! /RELATIVE
	'INDEXED_SEQUENTIAL',	! /INDEXED
!!!!!!!	'FORMAT',		! /FORMAT=record-format	(handled specially)
	'BUCKET_SIZE',		! /BUCKET_SIZE=n
	'ALLOCATION',		! /ALLOCATION=n
	'CONTIGUOUS',		! /CONTIGUOUS
	'OVERLAY',		! /OVERLAY
	'LOAD_FILL' %;		! /LOAD_FILL
MACRO
    QC_4[X] =
	%IF %CHARCOUNT(X) LEQ 4 %THEN X %ELSE %EXACTSTRING(4,' ',X) %FI,
	%STRING(X) %,
    QC_1[X,Y] = %NAME('SD_',X) = $DESCRIPTOR(Y): $BBLOCK[DSC$C_S_BLN] %,
    QC_2[X,Y] =
	%NAME('SD_',X),
	%IF %DECLARED(%NAME('IOS_',X)) %THEN %NAME('IOS_',X) %ELSE 0 %FI,
	%IF %DECLARED(%NAME('SET_',X)) %THEN %NAME('SET_',X) %ELSE 0 %FI,
	%IF %DECLARED(%NAME('NOT_',X)) %THEN %NAME('NOT_',X) %ELSE 0 %FI %,
    QC_3[] = %LENGTH %;
LITERAL
    STR_K_QUALCODES = QC_3( QUALCODES );
MACRO
    STR_OPT_QUALCODES = %UNQUOTE QC_4( QUALCODES ) %;
BIND
    QC_1( STR_OPT_QUALCODES ),
    QC_1( QC_4(
	'P1',		! Input file(s)
	'P2',		! Output file
	'$VERB',	! Verb from the command line
	'FORMAT' ) ),	! /FORMAT=record-format
    CLIQUALDESC = UPLIT( QC_2( STR_OPT_QUALCODES ) ): VECTOR;

OWN
    ! Qualifier string value descriptor block
    !
    STRING_DESC:	$BBLOCK[DSC$C_D_BLN],
    SUBVAL_DESC:	$BBLOCK[DSC$C_S_BLN];


EXTERNAL ROUTINE
    CLI$PRESENT:	ADDRESSING_MODE(GENERAL),	! Determine if /CHKPNT
    STR$COPY_R:		ADDRESSING_MODE(GENERAL),	! String copy
    SOR$SPEC_FILE:	ADDRESSING_MODE(GENERAL),	! Process spec file
    SOR$PASS_FILES:	ADDRESSING_MODE(GENERAL),	! Pass file names
    SOR$BEGIN_SORT:	ADDRESSING_MODE(GENERAL),	! Initialize the sort
    SOR$BEGIN_MERGE:	ADDRESSING_MODE(GENERAL),	! Initialize the merge
%IF FUN_K_KANJI %THEN
    SOR$$DTYPE_T_W:	ADDRESSING_MODE(GENERAL) WEAK,	! Key name to code
%FI
    LIB$SIGNAL:		ADDRESSING_MODE(GENERAL);	! Signal an error

EXTERNAL LITERAL
    CLI$_VALCNVERR,	! Error converting value
    CLI$_IVCHAR,	! Invalid character
    CLI$_IVVALU,	! Invalid value
    CLI$_NEGATED,	! Qualifier was explicitly negated
    CLI$_INVQUAL;	! SORT-specific quals used with MERGE, or vica-versa.

OWN
    CMD_CLEAR0:	VECTOR[0],
    !
    ! Parameters passed to PASS_FILES
    !
    ORG:	BYTE,		! File organization
    RFM:	BYTE,		! Record format
    BKS:	BYTE,		! Bucket size
    BLS:	WORD,		! Block size
    MRS:	WORD,		! Maximum record size
    OUT_ALQ:	LONG,		! Allocation quantity
    FOP:	LONG,		! File-processing options
    !
    ! Parameters returned from SOR$$COMMAND
    !
    KBF:	REF BLOCK,	! Key buffer address
    LRL:	WORD,		! Longest record length
    INP_ALQ:	LONG,		! Input file allocation
    WRK:	BYTE,		! Number of work files
    TYP:	BYTE,		! Sort type
    OPT:	LONG,		! Options
    CTX:	LONG,		! Address of context longword
    FSZ:	BYTE,		! Size of the VFC field (word suffices)
    !
    ! Sort parser flags
    !
    FLAGS:	BITVECTOR[32],
    !
    CMD_CLEAR1:	VECTOR[0];

ROUTINE CMD_ERROR(ERR) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine signals an error diagnostic.
!
! FORMAL PARAMETERS:
!
!	Parameters passed to LIB$SIGNAL.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	System status (first parameter of signalled status), with the
!	INHIB_MSG bit set.
!
! SIDE EFFECTS:
!
!	The image may be exitted due to the error.
!
!--
    BEGIN
    BUILTIN
	AP,
	CALLG;
    CALLG(.AP, LIB$SIGNAL);
    RETURN .ERR OR STS$M_INHIB_MSG;
    END;

GLOBAL ROUTINE SOR$$COMMAND
	(
	CONTEXT:	REF VECTOR[1,LONG],
	SORT_FLAG:	REF VECTOR[1,BYTE],
	STATISTICS:	REF VECTOR[1,BYTE],
	IMAGE_AP:	REF $BBLOCK
	) =
!++
! Functional Description:
!
!	This routine gets the sort command line from DCL and calls DCL to
!	parse it.
!
! Formal Parameters:
!
!	CONTEXT		Address of pointer to the context area
!	SORT_FLAG	Flag indicating we were invoked by SORT (not MERGE)
!	STATISTICS	Address in which to return whether statistics requested
!	IMAGE_AP	Address of main program's argument list
!
! Implicit Inputs:
!
!	NONE
!
! Implicit Outputs:
!
!	NONE
!
! Routine Value:
!
!	Status value
!
! Side Effects:
!
!	Calls PASS_FILES.
!
!--

    BEGIN
    LOCAL
	KEY_BUFFER:	VECTOR[1+4*MAX_KEYS,WORD],
	OUT_FILE_DESC:	$BBLOCK[DSC$C_D_BLN],
	INP_FILE_DESC:	$BBLOCK[DSC$C_D_BLN],
	STATUS;
    MACRO
	LENADR_(X) = %IF %ISSTRING(X)
	    %THEN %CHARCOUNT(X), UPLIT BYTE(X)
	    %ELSE .X[DSC$W_LENGTH], .X[DSC$A_POINTER] %FI %,
	DSC_INIT_(X,CLASS) =
	    BEGIN
	    X[DSC$W_LENGTH] = 0;
	    X[DSC$B_CLASS] = %NAME('DSC$K_CLASS_',CLASS);
	    X[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    X[DSC$A_POINTER] = 0;
	    END %;

    ! Initialize out dynamic string descriptors
    !
    DSC_INIT_(OUT_FILE_DESC, 'D');
    DSC_INIT_(INP_FILE_DESC, 'D');
    DSC_INIT_(STRING_DESC, 'D');

    ! Clear our variables
    !
    CH$FILL(0, CMD_CLEAR1-CMD_CLEAR0, CMD_CLEAR0);

%IF FUN_K_CHECKPOINT
%THEN
    ! If we're a checkpoint subprocess, call the CLI through a mailbox
    !
    CLI_BEGIN(IMAGE_AP[BASE_], CLI$PRESENT(SD_CHKP));
%FI

    ! Determine whether the user invoked SORT or MERGE
    ! Base this judgement on the verb from the command line.
    !
    CLI_GET_VALUE( SD_$VER, STRING_DESC[BASE_] );
    FLAGS[IOS_SORT] = SORT_FLAG[0] = TRUE;	! Assume we were invoked by SORT
    IF CH$EQL(LENADR_(STRING_DESC), LENADR_('MERG'))	! JUST FOUR CHARACTERS!
    THEN
	FLAGS[IOS_SORT] = SORT_FLAG[0] = FALSE;

    ! Get the context longword
    !
    CTX = CONTEXT[0];


    ! Zero the number of keys, and indicate that each key is "not yet used",
    ! by putting -1 in the KEY_ORDER field.
    !
    KBF = KEY_BUFFER[0];
    KBF[KEY_NUMBER] = 0;			! No keys yet
    DECR I FROM MAX_KEYS-1 TO 0 DO
	BEGIN
	BLOCK[ KBF[KEY_KBF(.I)], KBF_ORDER_S] = -1;
	END;


    ! Get output file spec and its qualifiers
    !
    CLI_GET_VALUE(SD_P2, OUT_FILE_DESC[BASE_]);
    SET_OUT_FMT();

    ! Process all the command qualifiers and output fille qualifiers
    !
    INCR I FROM 0 TO STR_K_QUALCODES-1 DO
	BEGIN
	LOCAL
	    Q:	REF VECTOR;
	Q = CLIQUALDESC[4*.I];
	IF (STATUS = CLI_PRESENT(.Q[0]))
	THEN
	    BEGIN
	    FLAGS[.Q[1]] = TRUE;
	    IF .Q[2] NEQ 0 THEN (.Q[2])();
	    END
	ELSE
	    BEGIN
	    IF .Q[3] NEQ 0 THEN (.Q[3])();
	    END;
	END;


    ! Get input file spec and its qualifiers
    !
    CLI_GET_VALUE(SD_P1, INP_FILE_DESC[BASE_]);
    SET_INP_FMT();


    ! Copy all output options specified to output file parameter
    ! area.
    !
    IF .FLAGS[IOS_OVER] THEN FOP = .FOP OR FAB$M_CIF;
    IF .FLAGS[IOS_CONT] THEN FOP = .FOP OR FAB$M_CTG;
    IF .FLAGS[IOS_SEQU] THEN ORG = FAB$C_SEQ ELSE
    IF .FLAGS[IOS_RELA] THEN ORG = FAB$C_REL ELSE
    IF .FLAGS[IOS_INDE] THEN ORG = FAB$C_IDX;

    ! As the utility, always set the "output file parse" option.
    !
    FOP = .FOP OR FAB$M_OFP;


    ! Copy the filenames.
    !
    STATUS = SOR$PASS_FILES(
	INP_FILE_DESC[BASE_],		! Descriptor for input file
	OUT_FILE_DESC[BASE_],		! Descriptor for output file
	(IF (.FLAGS AND 1^IOS_SEQU+1^IOS_RELA+1^IOS_INDE) EQL 0
	    THEN 0 ELSE ORG),				! ORG
	(IF .RFM EQL 0 THEN 0 ELSE RFM),		! RFM
	(IF .FLAGS[IOS_BUCK] THEN BKS ELSE 0),		! BKS
	(IF .BLS EQL 0 THEN 0 ELSE BLS),		! BLS
	(IF .MRS EQL 0 THEN 0 ELSE MRS),		! MRS
	(IF .FLAGS[IOS_ALLO] THEN OUT_ALQ ELSE 0),	! ALQ
	(IF .FOP EQL 0 THEN 0 ELSE FOP),		! FOP
	(IF .FSZ EQL 0 THEN 0 ELSE FSZ),		! FSZ
	CONTEXT[0]);					! Context
    IF NOT .STATUS THEN RETURN .STATUS;


    ! Copy Options
    !
    IF .FLAGS[IOS_STAB] THEN OPT = .OPT OR SOR$M_STABLE;
    IF .FLAGS[IOS_CHEC] THEN OPT = .OPT OR SOR$M_SEQ_CHECK;
    IF .FLAGS[IOS_LOAD] THEN OPT = .OPT OR SOR$M_LOAD_FILL;
    IF NOT .FLAGS[IOS_DUPL] THEN OPT = .OPT OR SOR$M_NODUPS;
    STATISTICS[0] = .FLAGS[IOS_STAT];


    ! Now get the rest of the input files.
    !
    WHILE CLI_GET_VALUE(SD_P1, INP_FILE_DESC[BASE_]) DO
	BEGIN
	SET_INP_FMT();

	STATUS = SOR$PASS_FILES(
	    INP_FILE_DESC[BASE_],	! Descriptor for input file
	    0,				! Descriptor for output file
	    0,0,0,0,			! ORG,RFM,BKS,BLS,
	    0,0,0,0,			! MRS,ALQ,FOP,FSZ
	    CONTEXT[0]);		! Context
	IF NOT .STATUS THEN RETURN .STATUS;
	END;

%IF FUN_K_CHECKPOINT
%THEN
    ! Indicate that no other CLI_xxx calls are needed
    !
    CLI_END();
%FI

    ! Set default options
    !
    !OPT = .OPT OR 0;			! No other defaults


    ! Push all the key descriptions together (this happens if the user
    ! uses NUMBER:n for non-successive n).
    !
    BEGIN
    LOCAL
	P: REF BLOCK,
	Q: REF BLOCK;
    P = KBF[KEY_KBF(0)];
    Q = KBF[KEY_KBF(0)];
    INCR I FROM 0 TO .KBF[KEY_NUMBER]-1 DO
	BEGIN
	IF .P[KBF_ORDER_S] GEQ 0		! Do a signed fetch
	THEN
	    BEGIN
	    CH$MOVE(%UPVAL*KBF_S_ENTRY, P[BASE_], Q[BASE_]);
	    Q = Q[BASE_] + %UPVAL*KBF_S_ENTRY;
	    END
	ELSE
	    KBF[KEY_NUMBER] = .KBF[KEY_NUMBER] - 1;
	P = P[BASE_] + %UPVAL*KBF_S_ENTRY;
	END;
    END;


    IF .FLAGS[IOS_SORT]
    THEN
	BEGIN
	!
	! Check for specifying non-SORT options
	!
	IF .FLAGS[IOS_CHEC]
	THEN
	    RETURN CMD_ERROR(CLI$_INVQUAL);
	!
	! Call BEGIN_SORT
	!
	STATUS = SOR$BEGIN_SORT(
	    (IF .FLAGS[IOS_KEY]
	    THEN KBF[BASE_] ELSE 0),	! Addr of key buffer
	    LRL,			! Longest record length
	    OPT,			! Options longword
	    INP_ALQ,			! File allocation amount
	    0,				! Comparison routine
%IF FUN_K_KANJI %THEN
	    IF .FLAGS[IOS_BOTH] THEN DEL_BOTH ELSE
%FI
	    0,				! No equal key routine
	    (IF .FLAGS[IOS_PROC]
	    THEN TYP ELSE 0),		! Sort type
	    (IF .FLAGS[IOS_WORK]
	    THEN WRK ELSE 0),		! Number of work files
	    CONTEXT[0]);		! Context parameter
	END
    ELSE
	BEGIN
	!
	! Check for specifying non-MERGE options
	!
	IF .FLAGS[IOS_WORK] OR .FLAGS[IOS_PROC]
	THEN
	    RETURN CMD_ERROR(CLI$_INVQUAL);
	!
	! Call BEGIN_MERGE
	!
	STATUS = SOR$BEGIN_MERGE(
	    (IF .FLAGS[IOS_KEY]
	    THEN KBF[BASE_] ELSE 0),	! Addr of key buffer
	    LRL,			! Longest record length
	    OPT,			! Options longword
	    0,				! Merge order
	    0,				! Comparison routine
%IF FUN_K_KANJI %THEN
	    IF .FLAGS[IOS_BOTH] THEN DEL_BOTH ELSE
%FI
	    0,				! No equal key routine
	    0,				! No input routine
	    CONTEXT[0]);		! Context parameter
	END;
    IF NOT .STATUS THEN RETURN .STATUS;

    RETURN SS$_NORMAL;
    END;

ROUTINE UTIL$NUMERVAL
	(
	DESC:		REF $BBLOCK[DSC$C_S_BLN]
	) =
!++
! Functional Description:
!
!	This routine converts a string to a number.
!	It allows for unary minus, and decimal, hexadecimal and octal radices.
!
! Formal Parameters:
!
!	DESC		String descriptor
!
! Implicit Inputs:
!
!	NONE
!
! Implicit Outputs:
!
!	NONE
!
! Routine Value:
!
!	Integer value of the converted string
!
! Side Effects:
!
!	Signals CLI$_IVCHAR for invalid characters
!
!--
    BEGIN
    LOCAL
	C,	! Current character
	V,	! The computed value
	L,	! Length of string
	A,	! Address of string
	B,	! Base
	N;	! Negation flag
    MACRO
	ERR_(X) = (CMD_ERROR(X); RETURN 0) %;
	
    L = .DESC[DSC$W_LENGTH];
    A = .DESC[DSC$A_POINTER];
    V = 0;
    B = 10;
    N = 1;
    WHILE (L = .L-1) GEQ 0 DO
	BEGIN
	SELECTONE (C = CH$RCHAR_A(A)) OF
	    SET
	    ['0' TO '9']:
		BEGIN
		V = .C - '0';
		EXITLOOP;
		END;
	    ['%']:
		BEGIN
		IF (L=.L-1) GEQ 0
		THEN
		    BEGIN
		    SELECTONE (C = CH$RCHAR_A(A)) OF
			SET
			['D']: B =    10 ;
			['O']: B = %O'10';
			['X']: B = %X'10';
			[OTHERWISE]: ERR_(CLI$_IVCHAR);
			TES
		    END
		ELSE
		    ERR_(CLI$_IVCHAR);
		EXITLOOP;
		END;
	    ['-']:
		BEGIN
		N = -.N;
		IF .N GEQ 0 THEN ERR_(CLI$_IVCHAR);
		END;
	    [OTHERWISE]:
		ERR_(CLI$_IVCHAR);
	    TES;
	END;
	    
    WHILE (L = .L-1) GEQ 0 DO
	BEGIN
	SELECTONE (C = CH$RCHAR_A(A)) OF
	    SET
	    ['0' TO '9']: C = .C - '0';
	    ['A' TO 'F']: C = .C - 'A' + 10;
	    [OTHERWISE]: ERR_(CLI$_IVCHAR);
	    TES;
	IF .C GEQU .B THEN ERR_(CLI$_IVCHAR);
	V = .V * .B + .C;
	END;

    RETURN .V * .N;

    END;

ROUTINE KEYVALU =

!++
! Functional Description:
!
!	This routine breaks a string into a keyword and a keyword value.
!
! Formal Parameters:
!
!	NONE
!
! Implicit Inputs:
!
!	STRING_DESC	String descriptor of source
!
! Implicit Outputs:
!
!	SUBVAL_DESC	String descriptor for storing value
!
! Routine Value:
!
!	True iff the source string contained a value.
!
! Side Effects:
!
!	Signals CLI$_IVVALU for zero-length values
!
!--
    BEGIN
    BUILTIN
	LOCC,
	NULLPARAMETER;
    LOCAL
	L: WORD;

    L = .STRING_DESC[DSC$W_LENGTH];

    BEGIN REGISTER R0 = 0, R1 = 1;
    LOCC( %REF(':'), L, .STRING_DESC[DSC$A_POINTER]; R0, R1 );
    L = .L - .R0;
    LOCC( %REF('='), L, .STRING_DESC[DSC$A_POINTER]; R0, R1 );
    L = .L - .R0;
    END;

    SUBVAL_DESC[DSC$W_LENGTH] = 0;	! Indicate no value seen yet

    IF .L GEQU .STRING_DESC[DSC$W_LENGTH] THEN RETURN FALSE;
    L = .L + 1;				! Remove the colon or equals

    SUBVAL_DESC[DSC$A_POINTER] = .STRING_DESC[DSC$A_POINTER] + .L;
    SUBVAL_DESC[DSC$W_LENGTH]  = .STRING_DESC[DSC$W_LENGTH]  - .L;

    IF .SUBVAL_DESC[DSC$W_LENGTH] EQL 0 THEN CMD_ERROR(CLI$_IVVALU);

    RETURN TRUE;
    
    END;

ROUTINE NUMERIC_PARSE
	(
	DESC:	REF $BBLOCK[DSC$C_D_BLN]
	) =

!++
! Functional Description:
!
!	This routine converts an ASCII number into a binary value.
!
! Formal Parameters:
!
!	DESC		The address of the ASCII string descriptor.
!
! Implicit Inputs:
!
!	STRING_DESC	Used for issuing the "'XXX' keyword requires a value"
!			diagnostic.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	Converted value
!
! Side Effects:
!
!	None.
!
!--

    BEGIN
    BUILTIN
	NULLPARAMETER;

    IF .DESC[DSC$W_LENGTH] EQL 0
    THEN				! No value where one was expected
	BEGIN
	CMD_ERROR(SOR$_SHR_NOVALUE, 1, STRING_DESC[BASE_]);
	RETURN 0;
	END;

    ! Parse the value
    !
    RETURN UTIL$NUMERVAL(DESC[BASE_]);

    END;

ROUTINE SET_SPEC: NOVALUE =

!++
! Functional Description:
!
!	This routine calls the CLI to parse a file name and stores it in the
!	sort parameter area.
!
! Formal Parameters:
!
!	None.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN
    LOCAL
	P:	REF $BBLOCK,
	STATUS;

    P = STRING_DESC[BASE_];
    IF NOT CLI_GET_VALUE( SD_SPEC, P[BASE_] )
    THEN
	P = $DESCRIPTOR(STR_DEF_SPECFILE);

    STATUS = SOR$SPEC_FILE(P[BASE_], 0, .CTX);

    IF NOT .STATUS THEN RETURN CMD_ERROR(.STATUS);
    END;

%IF %VARIANT %THEN
ROUTINE DEL_BOTH = (EXTERNAL LITERAL SOR$_DELBOTH; SOR$_DELBOTH);
ROUTINE SET_DUPL: NOVALUE =

!++
! Functional Description:
!
!	This routine calls the CLI to parse a file name and stores it in the
!	sort parameter area.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN
    KEY_TABLE_('DELB', 'DELBOTH');
    LOCAL
	LOOKUP;

    ! Name given?
    !
    IF NOT CLI_GET_VALUE( SD_DUPL, STRING_DESC[BASE_] ) THEN RETURN;

    FLAGS[IOS_DUPL] = TRUE;

    LOOKUP = LOOKUP_KEY(KEYWORD_TABLE);
    IF .LOOKUP LSSU TABLE_SIZE THEN FLAGS[IOS_BOTH] = TRUE;

    END;
%FI

ROUTINE SET_OUT_FMT: NOVALUE =

!++
! Functional Description:
!
!	This routine sets the output file record format in the output file
!	parameter area.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN

    KEY_TABLE_(STR_OPT_OUTFMT);

    LOCAL
	NUMBER_ADR:	REF VECTOR[,WORD];

    MACRO
	GET_RFM_(KIND,VALU) =
	    BEGIN
	    %IF NOT %NULL(KIND)
	    %THEN
		RFM = %NAME('FAB$C_',KIND);
	    %FI
	    IF .SUBVAL_DESC[DSC$W_LENGTH] NEQ 0		! If there is a value
	    THEN					! Get optional number
		STORE_(VALU, .RSLT);			! Get Max Record Size
	    END %;


    ! Determine which format was specified and set the appropriate
    ! attributes in the output file area.
    !
    WHILE CLI_GET_VALUE(SD_FORM, STRING_DESC[BASE_]) DO
	BEGIN
	LOCAL
	    LOOKUP,
	    RSLT;

	! Look up the keyword
	!
	LOOKUP = LOOKUP_KEY(KEYWORD_TABLE);

	! If there is a value, get it.
	!
	IF .SUBVAL_DESC[DSC$W_LENGTH] NEQ 0
	THEN
	    RSLT = NUMERIC_PARSE(SUBVAL_DESC[BASE_]);

	CASE .LOOKUP FROM 0 TO TABLE_SIZE-1 OF
	    SET
	    [K_FIXE]:	GET_RFM_(FIX,MRS);
	    [K_VARI]:	GET_RFM_(VAR,MRS);
	    [K_CONT]:	GET_RFM_(VFC,MRS);
	    [K_SIZE]:	GET_RFM_(   ,FSZ);
	    [K_BLOC]:	GET_RFM_(   ,BLS);
	    [OUTRANGE]:	0;
	    TES
	END;

    ! Check for specifying SIZE and something other than CONTROLLED
    !
    IF .FSZ NEQ 0 AND .RFM NEQ 0 AND .RFM NEQ FAB$C_VFC
    THEN
	CMD_ERROR(SOR$_KEYAMBINC);

    END;

ROUTINE SET_PROC: NOVALUE =

!++
! Functional Description:
!
!	This routine sets the sort type to perform in the sort parameter area.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN

    KEY_TABLE_(STR_OPT_PROCESS);

    OWN
	TAB: VECTOR[TABLE_SIZE,BYTE]
	    PSECT($CODE$) PRESET(
		[K_RECO]= SOR$GK_RECORD,
		[K_TAG]=  SOR$GK_TAG,
		[K_ADDR]= SOR$GK_ADDRESS,
		[K_INDE]= SOR$GK_INDEX);

    LOCAL
	LOOKUP;

    ! Indicate that this qualifier was seen
    !
    FLAGS[IOS_PROC] = TRUE;

    ! Determine which type was specified and set the appropriate attribute
    ! in the sort parameter area.
    !
    CLI_GET_VALUE(SD_PROC, STRING_DESC[BASE_]);

    LOOKUP = LOOKUP_KEY(KEYWORD_TABLE);
    IF .LOOKUP LSSU TABLE_SIZE THEN TYP = .TAB[.LOOKUP];

    IF .SUBVAL_DESC[DSC$W_LENGTH] NEQ 0
    THEN				! Value where none was expected
	RETURN CMD_ERROR(SOR$_SHR_SYNTAX, 1, STRING_DESC[BASE_]);

    END;

ROUTINE SET_INP_FMT: NOVALUE =

!++
! Functional Description:
!
!	This routine sets the input file record format in the input file
!	parameter area.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN

    KEY_TABLE_(STR_OPT_INPFMT);


    ! Get values and store them away.
    !
    WHILE CLI_GET_VALUE(SD_FORM, STRING_DESC[BASE_]) DO
	BEGIN

	CASE LOOKUP_KEY(KEYWORD_TABLE) FROM 0 TO TABLE_SIZE-1 OF
	    SET
	    [K_RECO]:
		STORE_(LRL, NUMERIC_PARSE(SUBVAL_DESC[BASE_]));
	    [K_FILE]:
		STORE_(INP_ALQ, .INP_ALQ + NUMERIC_PARSE(SUBVAL_DESC[BASE_]));
	    [OUTRANGE]:
		0;
	    TES;

	END;

    END;

ROUTINE NOT_WORK: NOVALUE =

!++
! Functional Description:
!
!	This routine is called if the user specifies /NOWORK_FILES
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN

    ! Make sure that the user explicitly requested no work files.
    !
    IF CLI_PRESENT( SD_WORK ) EQL CLI$_NEGATED
    THEN
	BEGIN
	!
	! Act as though the user specified 0 work files.
	!
	FLAGS[IOS_WORK] = TRUE;
	WRK = 0;
	END;
    END;

ROUTINE SET_WORK: NOVALUE =

!++
! Functional Description:
!
!	This routine gets the number of work files to use.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN

    ! If there is a value, store it into WRK.
    ! Otherwise, let the sort routines default this value.
    !
    IF CLI_GET_VALUE( SD_WORK, STRING_DESC[BASE_] )
    THEN
	STORE_(WRK, NUMERIC_PARSE(STRING_DESC[BASE_]))
    ELSE
	FLAGS[IOS_WORK] = FALSE;

    END;

ROUTINE SET_BUCK: NOVALUE =

!++
! Functional Description:
!
!	This routine gets the bucket size to use.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN
    CLI_GET_VALUE( SD_BUCK, STRING_DESC[BASE_] );
    STORE_(BKS, NUMERIC_PARSE(STRING_DESC[BASE_]));
    END;

ROUTINE SET_ALLO: NOVALUE =

!++
! Functional Description:
!
!	This routine gets the output file allocation to use.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN
    CLI_GET_VALUE( SD_ALLO, STRING_DESC[BASE_] );
    STORE_(OUT_ALQ, NUMERIC_PARSE(STRING_DESC[BASE_]));
    END;

ROUTINE PARSE_KEY: NOVALUE =

!++
! Functional Description:
!
!	This routine parses the key definition and stores it in the key
!	buffer.
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
! Implicit Inputs:
!
!	The key buffer.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    BEGIN

    OWN
	KEY_NUM:	BYTE INITIAL (0);

    BUILTIN
	TESTBITSC, TESTBITCC,
	TESTBITSS, TESTBITCS;

    LOCAL
	CURRENT_KEY:	REF BLOCK;

    LITERAL		! Bits for OPTS
	B_SEP   = 0,	! Separate
	B_OVE	= 1,	! Overpunched
	B_LEA	= 2,	! Leading
	B_TRA	= 3,	! Trailing
	B_UNS	= 4,	! Unsigned
	B_SIG	= 5,	! Signed
	B_ASC	= 6,	! Ascending
	B_DES	= 7,	! Descending
	B_POS	= 8,	! Position
	B_SIZ	= 9,	! Size
	B_NUM	= 10	! Number
%IF FUN_K_KANJI %THEN ,
	B_DTY	= 11	! Dtype
%FI	;

    KEY_TABLE_(STR_OPT_KEY);

    OWN
	TAB: VECTOR[TABLE_SIZE,BYTE]
	    PSECT($CODE$) PRESET(
		[K_ASCE]=	B_ASC,
		[K_DESC]=	B_DES,
		[K_BINA]=	DSC$K_DTYPE_B,		! We fix this later
		[K_CHAR]=	DSC$K_DTYPE_T,
		[K_DECI]=	DSC$K_DTYPE_NRO,	! We fix this later
		[K_PACK]=	DSC$K_DTYPE_P,
		[K_ZONE]=	DSC$K_DTYPE_NZ,
		[K_F_FL]=	DSC$K_DTYPE_F,
		[K_D_FL]=	DSC$K_DTYPE_D,
		[K_G_FL]=	DSC$K_DTYPE_G,
		[K_H_FL]=	DSC$K_DTYPE_H,
		[K_SIGN]=	B_SIG,
		[K_UNSI]=	B_UNS,
		[K_LEAD]=	B_LEA,
		[K_TRAI]=	B_TRA,
		[K_OVER]=	B_OVE,
		[K_SEPA]=	B_SEP);
    LOCAL					! Temporary storage for key
	TYPE:	%IF FUN_K_KANJI %THEN WORD %ELSE BYTE %FI,
	POSIT:	WORD,
	SIZ:	WORD,
	ASCDES:	BYTE,
	OPTS:	BITVECTOR[32];		! Key parser flags

    KEY_NUM	= .KEY_NUM + 1;		! Set up defaults
    TYPE	= 0;
    POSIT	= 1;			! Default position
    SIZ		= -1;			! Default size (entire record)
    OPTS	= 0;

    WHILE CLI_GET_VALUE(SD_KEY, STRING_DESC[BASE_]) DO
	BEGIN
	LOCAL
	    LOOKUP;

	LOOKUP = LOOKUP_KEY(KEYWORD_TABLE);
	IF .LOOKUP EQL K_SI
	THEN
	    BEGIN
	    CMD_ERROR(SOR$_SHR_BADKEY_W, 1, STRING_DESC[BASE_]);
	    IF .SUBVAL_DESC[DSC$W_LENGTH] NEQ 0
	    THEN LOOKUP = K_SIZE
	    ELSE LOOKUP = K_SIGN;
	    END;

	IF NOT ONEOF_(.LOOKUP, BMSK_(K_POSI, K_SIZE, K_NUMB
	    %IF FUN_K_KANJI %THEN , K_DTYP %FI))
	THEN
	    BEGIN
	    IF .SUBVAL_DESC[DSC$W_LENGTH] NEQ 0
	    THEN				! Value where none was expected
		RETURN CMD_ERROR(SOR$_SHR_SYNTAX, 1, STRING_DESC[BASE_]);
	    END;


	! Process the keyword.
	!
	IF
	    ONEOF_(.LOOKUP, BMSK_(K_BINA,K_CHAR,K_DECI,K_PACK,K_ZONE,
		K_F_FL,K_D_FL,K_G_FL,K_H_FL))
	THEN
	    BEGIN
	    !
	    ! Check whether the user has already specified the key data type.
	    !
	    IF .TYPE NEQ 0 THEN CMD_ERROR(SOR$_KEYAMBINC);
	    !
	    ! Set the key data type.  BINARY and DECIMAL are fixed up later.
	    !
	    TYPE = .TAB[.LOOKUP];
	    END
	ELIF
	    ONEOF_(.LOOKUP, BMSK_(K_ASCE,K_DESC,K_SIGN,K_UNSI,K_LEAD,K_TRAI,
		K_OVER,K_SEPA))
	THEN
	    BEGIN
	    !
	    ! Set the option, and verify that it's opposite isn't set.
	    !
	    ASSERT_((B_ASC XOR B_DES) EQL 1)
	    ASSERT_((B_SIG XOR B_UNS) EQL 1)
	    ASSERT_((B_LEA XOR B_TRA) EQL 1)
	    ASSERT_((B_OVE XOR B_SEP) EQL 1)
	    OPTS[.TAB[.LOOKUP]] = TRUE;
	    IF TESTBITSC(OPTS[.TAB[.LOOKUP] XOR 1])
	    THEN
		CMD_ERROR(SOR$_KEYAMBINC);
	    END
	ELIF
	    .LOOKUP EQL K_POSI
	THEN
	    BEGIN				! Set starting position of key
	    IF TESTBITSS(OPTS[B_POS]) THEN CMD_ERROR(SOR$_KEYAMBINC);
	    STORE_(POSIT, NUMERIC_PARSE(SUBVAL_DESC[BASE_]));
	    END
	ELIF
	    .LOOKUP EQL K_SIZE
	THEN
	    BEGIN				! Set size of key field
	    LOCAL
		TMP;
	    IF TESTBITSS(OPTS[B_SIZ]) THEN CMD_ERROR(SOR$_KEYAMBINC);
	    TMP = NUMERIC_PARSE(SUBVAL_DESC[BASE_]);
	    IF .TMP EQL -1 THEN SIZ = -1 ELSE STORE_(SIZ, .TMP);
	    END
	ELIF
	    .LOOKUP EQL K_NUMB
	THEN
	    BEGIN				! Set key number
	    IF TESTBITSS(OPTS[B_NUM]) THEN CMD_ERROR(SOR$_KEYAMBINC);
	    STORE_(KEY_NUM, NUMERIC_PARSE(SUBVAL_DESC[BASE_]));
	    END
%IF FUN_K_KANJI %THEN
	ELIF
	    .LOOKUP EQL K_DTYP
	THEN
	    BEGIN
	    !
	    ! Convert the string to a number
	    !
	    LOCAL
		STATUS;
	    IF SOR$$DTYPE_T_W EQL 0
	    THEN
		CMD_ERROR(SOR$_SHR_BADKEY, 1, STRING_DESC[BASE_]);
	    IF .TYPE NEQ 0 THEN CMD_ERROR(SOR$_KEYAMBINC);
	    IF .SUBVAL_DESC[DSC$W_LENGTH] EQL 0
	    THEN			! No value where one was expected
		CMD_ERROR(SOR$_SHR_NOVALUE, 1, STRING_DESC[BASE_]);

	    STATUS = SOR$$DTYPE_T_W(SUBVAL_DESC[BASE_], TYPE);
	    IF NOT .STATUS THEN CMD_ERROR(SOR$_KEYAMBINC, 0, .STATUS);
	    OPTS[B_DTY] = TRUE;
	    END
%FI
	ELSE
	    BEGIN
	    !
	    ! We've already complained about other keywords.
	    ! K_SI has already been converted to K_SIZE or K_SIGN.
	    !
	    0;
	    END;
	END;


%IF FUN_K_KANJI %THEN
    IF NOT .OPTS[B_DTY] THEN
%FI
    IF .TYPE EQL 0 THEN TYPE = DSC$K_DTYPE_T;	! Default to text


    ! Compute the size for the floating datatypes
    !
    IF ONEOF_(.TYPE, BMSK_(
	DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H))
    THEN
	BEGIN
	LOCAL
	    TMP;	! Save the user-specified size for a moment
	ASSERT_(1^(DSC$K_DTYPE_F MOD 8) EQL 4)
	ASSERT_(1^(DSC$K_DTYPE_D MOD 8) EQL 8)
	ASSERT_(1^(DSC$K_DTYPE_G MOD 8) EQL 8)
	ASSERT_(1^(DSC$K_DTYPE_H MOD 8) EQL 16)
	TMP = .SIZ;
	SIZ = 1 ^ .TYPE<0,3,0>;

	! If the user specified a size, make sure he was correct
	!
	IF TESTBITSS(OPTS[B_SIZ])
	THEN
	    IF .TMP NEQ .SIZ THEN CMD_ERROR(SOR$_BAD_KEY);
	END;

%IF FUN_K_KANJI %THEN
    IF .OPTS[B_DTY]
    THEN
	BEGIN
	OPTS[B_POS] = TRUE;	! Assume position seen
	OPTS[B_SIZ] = TRUE;	! Assume size seen
	END;
%FI

    ! Make sure that position and size were specified
    !
    IF TESTBITSC(OPTS[B_POS]) AND TESTBITSC(OPTS[B_SIZ])
    THEN
	0
    ELSE
	CMD_ERROR(SOR$_BAD_KEY);


    ! Check the number of keys
    !
    IF .KEY_NUM EQL 0 OR .KEY_NUM GTRU MAX_KEYS
    THEN
	BEGIN
	CMD_ERROR(SOR$_NUM_KEY);
	KEY_NUM = MAX_KEYS;
	END;
    OPTS[B_NUM] = FALSE;


    ! Some checks on the data type
    !
    IF	ONEOF_(.TYPE, BMSK_(DSC$K_DTYPE_T, DSC$K_DTYPE_NZ, DSC$K_DTYPE_P,
		DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H))
    THEN
	0
    ELIF
	.TYPE EQL DSC$K_DTYPE_B
    THEN
	BEGIN
	IF   .SIZ EQL  1 THEN 0
	ELIF .SIZ EQL  2 THEN TYPE = DSC$K_DTYPE_W
	ELIF .SIZ EQL  4 THEN TYPE = DSC$K_DTYPE_L
	ELIF .SIZ EQL  8 THEN TYPE = DSC$K_DTYPE_Q
	ELIF .SIZ EQL 16 THEN TYPE = DSC$K_DTYPE_O
	ELSE CMD_ERROR(SOR$_BAD_KEY);
	IF .OPTS[B_UNS]
	THEN
	    BEGIN
	    ASSERT_(DSC$K_DTYPE_B-4 EQL DSC$K_DTYPE_BU)
	    ASSERT_(DSC$K_DTYPE_W-4 EQL DSC$K_DTYPE_WU)
	    ASSERT_(DSC$K_DTYPE_L-4 EQL DSC$K_DTYPE_LU)
	    ASSERT_(DSC$K_DTYPE_Q-4 EQL DSC$K_DTYPE_QU)
	    IF .TYPE EQL DSC$K_DTYPE_O
		THEN TYPE = DSC$K_DTYPE_OU
		ELSE TYPE = .TYPE - 4;	! Convert from DTYPE_x to DTYPE_xU
	    END;
	OPTS[B_SIG] = FALSE;
	OPTS[B_UNS] = FALSE;
	END
    ELIF
	.TYPE EQL DSC$K_DTYPE_NRO
    THEN
	BEGIN
	IF TESTBITSC(OPTS[B_UNS])
	THEN
	    TYPE = DSC$K_DTYPE_NU
	ELSE
	    BEGIN
	    OPTS[B_SIG] = FALSE;
	    IF .OPTS[B_LEA] THEN TYPE = DSC$K_DTYPE_NLO;
	    OPTS[B_LEA] = FALSE;
	    OPTS[B_TRA] = FALSE;
	    IF .OPTS[B_SEP]
	    THEN
		BEGIN
		ASSERT_(DSC$K_DTYPE_NLO - 1 EQL DSC$K_DTYPE_NL)
		ASSERT_(DSC$K_DTYPE_NRO - 1 EQL DSC$K_DTYPE_NR)
		TYPE = .TYPE - 1;	! Convert from DTYPE_NxO to DTYPE_Nx
		SIZ = .SIZ + 1;		! Increase the size to include the sign
		END;
	    OPTS[B_SEP] = FALSE;
	    OPTS[B_OVE] = FALSE;
	    END
	END
    %IF FUN_K_KANJI %THEN ELSE IF TESTBITSC(OPTS[B_DTY]) THEN 0 %FI
    ELSE
	CMD_ERROR(SOR$_SHR_BADLOGIC);


    ! Copy key definition with defaults to block in key buffer.
    !
    CURRENT_KEY = KBF[KEY_KBF(.KEY_NUM-1)];
    IF .CURRENT_KEY[KBF_ORDER_S] GEQ 0
    THEN
	CMD_ERROR(SOR$_KEYAMBINC);
    CURRENT_KEY[KBF_ORDER] = .OPTS[B_DES];	! Ascending/Descending
    CURRENT_KEY[KBF_TYPE] = .TYPE;		! DSC datatype
    OPTS[B_DES] = FALSE;
    OPTS[B_ASC] = FALSE;
    CURRENT_KEY[KBF_POSITION] = .POSIT - 1;	! Adjust to start at pos 0
    CURRENT_KEY[KBF_LENGTH] = .SIZ;		! Size
    KBF[KEY_NUMBER] = MAXU(.KBF[KEY_NUMBER], .KEY_NUM);		! Another key


    ! We should have used up all the options
    !
    IF .OPTS NEQ 0 THEN CMD_ERROR(SOR$_KEYAMBINC);

    END;

ROUTINE SET_KEY: NOVALUE =
    BEGIN
    WHILE CLI_NEXT_QUAL(SD_KEY) DO PARSE_KEY();	! Do it again and again
    END;

ROUTINE SET_COLL: NOVALUE =

!++
!
! Functional Description:
!
!	Routine to call CLI to get the argument of the /COLLATING_SEQUE
!	qualifier.  The valid arguments are ASCII, EBCDIC and MULTINATIONAL.
!	If no argument is given, ASCII is assumed.
!
! Formal Parameters:
!
!	QUAL_DESC	address of the qualifier descriptor block.
!
! Implicit Outputs:
!
!	OPT is modified to have the appropriate option bit set.
!
!--
    BEGIN

    KEY_TABLE_(STR_OPT_COLL);

    OWN
	TAB: VECTOR[TABLE_SIZE,BYTE]
	    PSECT($CODE$) PRESET(
		[K_ASCI]=	0,
		[K_EBCD]=	SOR$M_EBCDIC,
		[K_MULT]=	SOR$M_MULTI);
    LOCAL
	LOOKUP;

    CLI_GET_VALUE( SD_COLL, STRING_DESC[BASE_] );
    LOOKUP = LOOKUP_KEY(KEYWORD_TABLE);
    IF .LOOKUP LSSU TABLE_SIZE THEN OPT = .OPT OR .TAB[.LOOKUP];

    END;

ROUTINE LOOKUP_KEY
	(
	TABLE:	REF VECTOR
	) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to process the qualifier value for qualifiers
!	that take keyword values.
!
! FORMAL PARAMETERS:
!
!	TABLE	- Pointer to keyword table
!
! IMPLICIT INPUTS:
!
!	STRING_DESC contains the keyword to match against, and possibly a value.
!	IOS_CMDFLAGS has already been initialized to default values.
!
! IMPLICIT OUTPUTS:
!
!	SUBVAL_DESC is set to describe the value (if any) on this keyword.
!
! ROUTINE VALUE:
!
!	If the keyword was found, the index of the keyword, otherwise -1.
!
! SIDE EFFECTS:
!
!	If the keyword was not found, a diagnostic is issued.
!
!--

    BEGIN
    MAP
	TABLE:	REF VECTOR;

    LOCAL
	L,				! Keyword string length
	A:	REF VECTOR[,BYTE],	! Keyword string address
	INDEX;				! Routine return value


    ! Search through table looking for a single match. If more than one
    ! match is found return an error.
    !
    INDEX = -1;					! Initialize return to error

    ! Remove the value (if any) from this keyword
    !
    A = .STRING_DESC[DSC$A_POINTER];
    L = .STRING_DESC[DSC$W_LENGTH];
    L = .L - KEYVALU();
    L = .L - .SUBVAL_DESC[DSC$W_LENGTH];

    INCR N FROM 0 TO .TABLE[-1]-1 DO
	BEGIN
	LOCAL
	    P:	REF VECTOR[,BYTE];
	P = .TABLE[.N];				! Point to ASCIC keyword string
	IF .P[0] GEQ .L<0,8> THEN
	IF CH$EQL(.L, A[0], .L, P[1])
	THEN
	    BEGIN
	    !
	    ! We found a matching name.
	    !
	    IF .INDEX LSS 0
	    THEN
		INDEX = .N
	    ELSE
		BEGIN
		CMD_ERROR(SOR$_SHR_BADKEY, 1, STRING_DESC[BASE_]);
		RETURN -1;
		END;
	    IF .P[0] EQL .L<0,8> THEN EXITLOOP;	! An optimization
	    END;
	END;

    IF .INDEX LSS 0
    THEN
	BEGIN
	CMD_ERROR(SOR$_SHR_BADKEY, 1, STRING_DESC[BASE_]);
	RETURN -1;
	END;

    RETURN .INDEX;				! Return value
    END;

END
ELUDOM
