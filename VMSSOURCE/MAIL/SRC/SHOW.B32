MODULE MAIL$SHOW( %TITLE 'VAX/VMS MAIL UTILITY SHOW COMMAND'
		IDENT = 'V04-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	SHOW command handling.
!
! AUTHOR:	Benn Schreiber,	5-Dec-1982
!
! MODIFIED BY:
!
!	V03-008	BLS0255		Benn Schreiber		28-Dec-1983
!		New global flags.  Add SHOW KEY command.  SHOW NEW
!		does not need to open mail file.
!
!	V03-007	BLS0246		Benn Schreiber		 8-Nov-1983
!		Move new mail count to VMSMAIL.
!
!	V03-006	BLS0229		Benn Schreiber		16-Jul-1983
!		Add SHOW NEW_MAIL_COUNT command, and SHOW ALL command.
!
!	V03-005	BLS0225		Benn Schreiber		17-Jun-1983
!		Remove reference to MAIL$Q_VMSMAILDAT_DESC, as it
!		no longer is needed.
!
!	V03-004	BLS0220		Benn Schreiber		30-Apr-1983
!		Add SHOW MAIL_DIRECTORY, SHOW AUTO_PURGE
!
!	V03-003	BLS0217		Benn Schreiber		12-Apr-1983
!		Add SHOW COPY_SELF command.
!
!	V03-002	BLS0214		Benn Schreiber		27-Mar-1983
!		SHOW FOLDER and SHOW DELETED commands.  Correct
!		error in SHOW PERSONAL if record exists but has
!		no personal name set.
!
!	V03-001	BLS0211		Benn Schreiber		13-Mar-1983
!		New commands for ISAM mail files
!--

!
! Declarations
!
LIBRARY	'SYS$LIBRARY:STARLET';
REQUIRE	'SRC$:MAILREQ';
LIBRARY 'LIB$:MAILDEF';

OWN
	COMMAND_DESC: $BBLOCK[DSC$C_S_BLN]
			PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
				[DSC$B_CLASS] = DSC$K_CLASS_D),
	DYN_DESC: $BBLOCK[DSC$C_S_BLN]
			PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
				[DSC$B_CLASS] = DSC$K_CLASS_D);

EXTERNAL
	MAIL$L_SMG_KEYTABLE,			!Pointer to key defs table
	MAIL$T_RD_RAB : $BBLOCK,		!Mail file rab
	MAIL$GL_FLAGS : $BBLOCK,		!control flags
	MAIL$SD_USER: $BBLOCK,			!Descriptor of 'USER'
	MAIL$Q_USERDEF : $BBLOCK,		!Default dev/dir spec
	MAIL$Q_CURFOLDER : $BBLOCK,		!Current folder name
	MAIL$Q_WASTEDESC : $BBLOCK,		!Wastebasket name
	MAIL$Q_RD_DESC : $BBLOCK,		!Current file descriptor
	MAIL$Q_USERNAME: $BBLOCK,		!username descriptor
	MAIL$T_SYSMAIRAB: $BBLOCK,		!RAB for VMSMAIL.DAT
	MAIL$L_USRSYSBUF : REF $BBLOCK,		!User's vmsmail record
	MAIL$L_SYSMAIBUF: REF $BBLOCK;		!Pointer to buffer

EXTERNAL ROUTINE
	CLI$GET_VALUE: ADDRESSING_MODE(GENERAL),!Get value from CLI
	CLI$PRESENT: ADDRESSING_MODE(GENERAL),	!Test qualifier present
	MAIL$OPEN_IF,				!Ensure file open
	SMG$LIST_KEY_DEFS,			!Get key defs from smg
	STR$APPEND,				!String append
	STR$CONCAT,				!String concatenate
	STR$COPY_DX,				!String copy
	STR$FREE1_DX: ADDRESSING_MODE(GENERAL),	!Free dynamic string
	STR$TRIM: ADDRESSING_MODE(GENERAL),	!Trim trailing blanks
	MAIL$CHECK_FORW,			!See if forwarding enabled
	MAIL$MATCH_NAME,			!Wildcard match routine
	MAIL$FAO_GETMSG,			!Get message and then fao it
	MAIL$GETMSG,				!Get message text for code
	MAIL$GET_NEWMAIL,			!Get count of new messages
	MAIL$GET_SYSMAI_REC,			!Read record from VMSMAIL.DAT
	MAIL$FORW_PRIV_CHECK,			!See if SYSNAM privilege
	MAIL$PUT_OUTPUT,			!Format and write to output
	MAIL$READ_INFO_REC;			!Read isam file info rec
!
! Define facility specific names for shared messages
!
$SHR_MSGDEF(MAIL,126,LOCAL,
	(TEXT,SUCCESS));

BIND
    COMMA_DESC = $DESCRIPTOR(',');

SD (
    'KEYNAME',
    'ALL',
    'STATE',
    'BRIEF',
    'DIRECTORY');

GLOBAL ROUTINE MAIL$CMD_SHOW_FORWARD =
!++
! FUNCTIONAL DESCRIPTION:
!
!--
BEGIN

LOCAL
    TMPBUF : $BBLOCK[VMD_C_LENGTH+2*NAM$C_MAXRSS];

IF NOT CLI$PRESENT(MAIL$SD_USER)
THEN BEGIN
    IF NOT MAIL$CHECK_FORW(MAIL$Q_USERNAME)		!Check for self
	THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW20))
	ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW30),
		MAIL$L_USRSYSBUF[VMD_B_FWDLNG]);
    END
ELSE BEGIN
    !
    ! To look at someone else's you must have privilege
    !
    IF NOT MAIL$FORW_PRIV_CHECK()
	THEN RETURN TRUE;
    CLI$GET_VALUE(MAIL$SD_USER,COMMAND_DESC);	!Get name to show
    IF CH$FAIL(CH$FIND_CH(
	.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],'*'))
	AND CH$FAIL(CH$FIND_CH(
		.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],'%'))
    THEN BEGIN
	IF NOT MAIL$CHECK_FORW(COMMAND_DESC,TMPBUF)	!Show a single user
	    THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW40),
			COMMAND_DESC)
	    ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW10),
			COMMAND_DESC,TMPBUF[VMD_B_FWDLNG]);
	END
    ELSE BEGIN
	LOCAL
	    FIRST_USER,
	    DESC_1 : $BBLOCK[DSC$C_S_BLN];
	!
	! Show for a wildcard user.  Read all records of the file sequentially
	! and check for a match.
	!
	CH$FILL(0,DSC$C_S_BLN,DESC_1);
	MAIL$T_SYSMAIRAB[RAB$B_RAC] = RAB$C_SEQ;
	MAIL$T_SYSMAIRAB[RAB$L_UBF] = TMPBUF;
	$REWIND(RAB=MAIL$T_SYSMAIRAB);
	FIRST_USER = 1;
	WHILE ($GET(RAB=MAIL$T_SYSMAIRAB) NEQ RMS$_EOF)
	DO BEGIN
	    DESC_1[DSC$W_LENGTH] = VMD_C_USERNAME;
	    DESC_1[DSC$A_POINTER] = TMPBUF[VMD_T_USERNAME];
	    STR$TRIM(DYN_DESC,DESC_1);
	    IF MAIL$MATCH_NAME(DYN_DESC,COMMAND_DESC)
		AND .TMPBUF[VMD_B_FWDLNG] NEQ 0
	    	THEN BEGIN
		    IF .FIRST_USER
			THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW50),0);
		    FIRST_USER = 0;
		    MAIL$PUT_OUTPUT(
			$DESCRIPTOR('!31AS !AC'),
			DYN_DESC,TMPBUF[VMD_B_FWDLNG]);
		    IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
			THEN RETURN TRUE;
		    END;
	    END;
	MAIL$T_SYSMAIRAB[RAB$B_RAC] = RAB$C_KEY;
	END;
    END;
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_FOLDER =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show the current folder name
!
!--
BEGIN

IF_ERR(MAIL$OPEN_IF();,
	RETURN TRUE);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN RETURN SIGNAL(MAIL$_NOTISAM);

IF .MAIL$Q_CURFOLDER[DSC$W_LENGTH] EQL 0
    THEN RETURN SIGNAL(MAIL$_NOFOLDER,%X'10000')
    ELSE RETURN SIGNAL(MAIL$_MAILFOLDER,%X'10001',MAIL$Q_CURFOLDER)

END;

GLOBAL ROUTINE MAIL$CMD_SHOW_DELMSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show amount of deleted space in current isam file
!
!--
BEGIN

LOCAL
    RECPTR : REF $BBLOCK,
    DELCOUNT,
    RECDESC : VECTOR[2,LONG];

IF_ERR(MAIL$OPEN_IF();,
	RETURN TRUE);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN RETURN SIGNAL(MAIL$_NOTISAM);

DELCOUNT = 0;
IF MAIL$READ_INFO_REC(MAIL$T_RD_RAB,MFR_C_FILEINFO,1,RECDESC)
THEN BEGIN
    RECPTR = .RECDESC[1];
    DELCOUNT = .(RECPTR[MFR_T_DATA])<0,32,0>;
    END;

RETURN SIGNAL(MAIL$_DELSPACE,%X'10002',MAIL$Q_RD_DESC,.DELCOUNT)

END;

GLOBAL ROUTINE MAIL$CMD_SHOW_NAME =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine displays the full username set by the
!	SET PERSONAL_NAME command
!
!--
BEGIN

LOCAL
    TMPBUF : $BBLOCK[VMD_C_LENGTH+2*NAM$C_MAXRSS];

BIND
    UREC = .MAIL$L_USRSYSBUF : $BBLOCK;

IF NOT CLI$PRESENT(MAIL$SD_USER)
THEN BEGIN
    IF .UREC[VMD_B_FNMLNG] EQL 0
	THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW60))
	ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW70),
				.UREC[VMD_B_FNMLNG],
				UREC[VMD_T_FWDNAM]+.UREC[VMD_B_FWDLNG]);
    END
ELSE BEGIN
    !
    ! Check for privileges
    !
    IF NOT MAIL$FORW_PRIV_CHECK()
	THEN RETURN TRUE;
    CLI$GET_VALUE(MAIL$SD_USER,COMMAND_DESC);
    IF CH$FAIL(CH$FIND_CH(
		.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],'*'))
	AND CH$FAIL(CH$FIND_CH(
		.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],'%'))
    THEN BEGIN
	TMPBUF[VMD_B_FNMLNG] = 0;
	IF NOT MAIL$GET_SYSMAI_REC(COMMAND_DESC,TMPBUF)
	    OR .TMPBUF[VMD_B_FNMLNG] EQL 0
	    THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW80),
			COMMAND_DESC)
	    ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW90),
			COMMAND_DESC,.TMPBUF[VMD_B_FNMLNG],
			TMPBUF[VMD_T_FWDNAM]+.TMPBUF[VMD_B_FWDLNG]);
	END
    ELSE BEGIN
	!
	! Show for wildcard user.  Read all records sequentially
	! and check for a match
	!
	LOCAL
	    FIRST_USER,
	    DESC_1 : $BBLOCK[DSC$C_S_BLN];

	CH$FILL(0,DSC$C_S_BLN,DESC_1);
	MAIL$T_SYSMAIRAB[RAB$B_RAC] = RAB$C_SEQ;
	MAIL$T_SYSMAIRAB[RAB$L_UBF] = TMPBUF;
	$REWIND(RAB=MAIL$T_SYSMAIRAB);
	FIRST_USER = 1;
	WHILE ($GET(RAB=MAIL$T_SYSMAIRAB) NEQ RMS$_EOF)
	DO BEGIN
	    DESC_1[DSC$W_LENGTH] = VMD_C_USERNAME;
	    DESC_1[DSC$A_POINTER] = TMPBUF[VMD_T_USERNAME];
	    STR$TRIM(DYN_DESC,DESC_1);
	    IF MAIL$MATCH_NAME(DYN_DESC,COMMAND_DESC)
		AND .TMPBUF[VMD_B_FNMLNG] NEQ 0
	    	THEN BEGIN
		    IF .FIRST_USER
			THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW100),0);
		    FIRST_USER = 0;
		    MAIL$PUT_OUTPUT(
			$DESCRIPTOR('!31AS !AD'),
			DYN_DESC,.TMPBUF[VMD_B_FNMLNG],
			TMPBUF[VMD_T_FWDNAM]+.TMPBUF[VMD_B_FWDLNG]);
		    IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
			THEN RETURN TRUE;
		    END;
	    END;
	MAIL$T_SYSMAIRAB[RAB$B_RAC] = RAB$C_KEY;
	END;
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_AUTO =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show whether or not AUTO_PURGE is enabled
!
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG];

DESC[0] = DESC[1] = 0;

STR$COPY_DX(DYN_DESC,MAIL$GETMSG(MAIL$_SHOW140));
STR$APPEND(DYN_DESC,MAIL$GETMSG((IF .MAIL$L_USRSYSBUF[VMD_V_NOAUTOPURGE]
					THEN MAIL$_SHOW160
					ELSE MAIL$_SHOW150)));
MAIL$PUT_OUTPUT(DYN_DESC);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_SELF =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show what copy self features are enabled.
!
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG];

DESC[0] = DESC[1] = 0;
IF .MAIL$L_USRSYSBUF[VMD_V_SELFSEND]
    THEN STR$COPY_DX(DYN_DESC,MAIL$GETMSG(MAIL$_SEND))
    ELSE STR$COPY_DX(DYN_DESC,DESC);

IF .MAIL$L_USRSYSBUF[VMD_V_SELFREPLY]
THEN BEGIN
    IF .DYN_DESC[DSC$W_LENGTH] NEQ 0
	THEN STR$APPEND(DYN_DESC,$DESCRIPTOR(','));
    STR$APPEND(DYN_DESC,MAIL$GETMSG(MAIL$_REPLY));
    END;

IF .DYN_DESC[DSC$W_LENGTH] NEQ 0
    THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW120),DYN_DESC)
    ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW130));
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_WASTE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show the wastebasket folder name
!
!--
BEGIN

IF_ERR(MAIL$OPEN_IF();,
	RETURN TRUE);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN (SIGNAL(MAIL$_NOTISAM); RETURN TRUE);

IF .MAIL$Q_WASTEDESC[DSC$W_LENGTH] EQL 0
    THEN SIGNAL(MAIL$_NOTREADIN)
    ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW110),MAIL$Q_WASTEDESC);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_DIR =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show the name of the current mail directory
!--
BEGIN

SIGNAL(MAIL$_MAILDIR,%X'10001',MAIL$Q_USERDEF);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_FILE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show the name of the current mail file
!--
BEGIN

IF_ERR(MAIL$OPEN_IF();,
	RETURN TRUE);

SIGNAL(MAIL$_MAILFILE,%X'10001',MAIL$Q_RD_DESC);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_NEW =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show the new message count
!
!--
BEGIN

LOCAL
    NEWCOUNT;

NEWCOUNT = 0;
MAIL$GET_NEWMAIL(MAIL$Q_USERNAME,NEWCOUNT);

MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_YOUHAVENEW),.NEWCOUNT);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_ALL =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show the world
!
!--
BEGIN
BIND
    UREC = .MAIL$L_USRSYSBUF : $BBLOCK;

LOCAL
    DESC : VECTOR[2,LONG];

!
! File related things (SET MAIL_DIR, SET FILE, SELECT folder, SET
! WASTEBASKET, SHOW DELETED, SHOW NEW_MAIL_COUNT)
!
DESC[0] = 0;
DESC[1] = DESC[0];
MAIL$CMD_SHOW_DIR();
MAIL$CMD_SHOW_FILE();
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    MAIL$CMD_SHOW_FOLDER();
    MAIL$CMD_SHOW_WASTE();
    MAIL$CMD_SHOW_DELMSG();
    MAIL$PUT_OUTPUT(DESC);		!Blank line
    MAIL$CMD_SHOW_NEW();
    END;

MAIL$PUT_OUTPUT(DESC);			!Blank line
!
! More personal things (SET FORWARD, SET PERSONAL_NAME, SET COPY_SELF,
! and SET AUTOPURGE).
!
IF NOT MAIL$CHECK_FORW(MAIL$Q_USERNAME)
    THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW20))
    ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW30),UREC[VMD_B_FWDLNG]);

IF .UREC[VMD_B_FNMLNG] EQL 0
    THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW60))
    ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOW70),.UREC[VMD_B_FNMLNG],
			UREC[VMD_T_FWDNAM]+.UREC[VMD_B_FWDLNG]);

MAIL$CMD_SHOW_SELF();
MAIL$CMD_SHOW_AUTO();

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SHOW_KEY =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the SHOW KEY command
!
!--
BEGIN

LOCAL
    ALL_FLAG,
    DIR_FLAG,
    BRIEF_FLAG,
    ZDESC : VECTOR[2,LONG],
    SMG_CONTEXT,
    KEY_ATTRIBUTES : $BBLOCK[4];

OWN
    SEEN_STATES : DYN_DESC_DECL,
    PREV_STATE : DYN_DESC_DECL,
    STATE_DESC : DYN_DESC_DECL,
    KEYDESC : DYN_DESC_DECL,
    KEY_NAME_DESC : DYN_DESC_DECL,
    IF_STATE_DESC : DYN_DESC_DECL,
    EQUIV_DESC : DYN_DESC_DECL,
    STATE_STRING_DESC : DYN_DESC_DECL;

ZDESC[0] = 0;
ZDESC[1] = ZDESC[0];
DIR_FLAG = CLI$PRESENT(SD_DIRECTORY);
IF NOT .DIR_FLAG
THEN BEGIN
    IF NOT (ALL_FLAG = CLI$PRESENT(SD_ALL))
	THEN CLI$GET_VALUE(SD_KEYNAME,KEYDESC)
	ELSE STR$FREE1_DX(KEYDESC);
    BRIEF_FLAG = CLI$PRESENT(SD_BRIEF);
    IF CLI$PRESENT(SD_STATE)
	THEN CLI$GET_VALUE(SD_STATE,STATE_DESC)
	ELSE STR$FREE1_DX(STATE_DESC);
    DO BEGIN
	SMG_CONTEXT = 0;
	STR$FREE1_DX(PREV_STATE);
	IF .STATE_DESC[DSC$W_LENGTH] EQL 0
	    THEN STR$COPY_DX(STATE_DESC,$DESCRIPTOR('DEFAULT'));
	WHILE SMG$LIST_KEY_DEFS(MAIL$L_SMG_KEYTABLE,
				SMG_CONTEXT,
				KEY_NAME_DESC,IF_STATE_DESC,
				KEY_ATTRIBUTES,EQUIV_DESC,
				STATE_STRING_DESC)
	DO BEGIN
	    IF CH$EQL(.IF_STATE_DESC[DSC$W_LENGTH],.IF_STATE_DESC[DSC$A_POINTER],
			.STATE_DESC[DSC$W_LENGTH],.STATE_DESC[DSC$A_POINTER])
		AND ((.KEYDESC[DSC$W_LENGTH] EQL 0)
		    OR CH$EQL(.KEYDESC[DSC$W_LENGTH],.KEYDESC[DSC$A_POINTER],
				.KEY_NAME_DESC[DSC$W_LENGTH],
				.KEY_NAME_DESC[DSC$A_POINTER]))
	    THEN BEGIN
		IF NOT CH$EQL(.IF_STATE_DESC[DSC$W_LENGTH],
				.IF_STATE_DESC[DSC$A_POINTER],
				.PREV_STATE[DSC$W_LENGTH],
				.PREV_STATE[DSC$A_POINTER])
		THEN BEGIN
		    MAIL$PUT_OUTPUT(ZDESC);
		    MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOWKEY30),
					IF_STATE_DESC);
		    STR$COPY_DX(PREV_STATE,IF_STATE_DESC);
		    END;
		IF .BRIEF_FLAG
		THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOWKEY10),
				KEY_NAME_DESC,EQUIV_DESC)
		ELSE BEGIN
		    IF .KEY_ATTRIBUTES[SMG$V_KEY_NOECHO]
		        THEN STR$FREE1_DX(SEEN_STATES)
			ELSE STR$COPY_DX(SEEN_STATES,MAIL$GETMSG(MAIL$_SHOWKEY40));
		    IF .KEY_ATTRIBUTES[SMG$V_KEY_TERMINATE]
		    THEN BEGIN
			IF .SEEN_STATES[DSC$W_LENGTH] NEQ 0
			    THEN STR$CONCAT(SEEN_STATES,SEEN_STATES,COMMA_DESC,
					MAIL$GETMSG(MAIL$_SHOWKEY50))
			    ELSE STR$COPY_DX(SEEN_STATES,
					MAIL$GETMSG(MAIL$_SHOWKEY50));
			END;
		    IF .KEY_ATTRIBUTES[SMG$V_KEY_LOCK]
		    THEN BEGIN
			IF .SEEN_STATES[DSC$W_LENGTH] NEQ 0
			    THEN STR$CONCAT(SEEN_STATES,SEEN_STATES,COMMA_DESC,
					MAIL$GETMSG(MAIL$_SHOWKEY70))
			    ELSE STR$COPY_DX(SEEN_STATES,
					MAIL$GETMSG(MAIL$_SHOWKEY70));
			END;
		    IF .KEY_ATTRIBUTES[SMG$V_KEY_SETSTATE]
		    THEN BEGIN
			IF .SEEN_STATES[DSC$W_LENGTH] NEQ 0
			    THEN STR$CONCAT(SEEN_STATES,SEEN_STATES,COMMA_DESC,
					MAIL$FAO_GETMSG(MAIL$_SHOWKEY60,
						STATE_STRING_DESC))
			    ELSE STR$COPY_DX(SEEN_STATES,
					MAIL$FAO_GETMSG(MAIL$_SHOWKEY60,
						STATE_STRING_DESC));
			END;
		    IF .SEEN_STATES[DSC$W_LENGTH] NEQ 0
			THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOWKEY20),
				KEY_NAME_DESC,EQUIV_DESC,SEEN_STATES)
			ELSE MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_SHOWKEY10),
				KEY_NAME_DESC,EQUIV_DESC);
		    END;
		END;
	    END
	END UNTIL NOT CLI$GET_VALUE(SD_STATE,STATE_DESC);
    END
ELSE BEGIN
    ! List directory of key states
    SMG_CONTEXT = 0;
    STR$FREE1_DX(PREV_STATE);
    STR$FREE1_DX(SEEN_STATES);
    WHILE SMG$LIST_KEY_DEFS(MAIL$L_SMG_KEYTABLE,
				SMG_CONTEXT,
				KEY_NAME_DESC,IF_STATE_DESC,
				KEY_ATTRIBUTES,EQUIV_DESC,
				STATE_STRING_DESC)
    DO BEGIN
	STR$CONCAT(KEYDESC,IF_STATE_DESC,$DESCRIPTOR('/'));
	IF NOT CH$EQL(.PREV_STATE[DSC$W_LENGTH],.PREV_STATE[DSC$A_POINTER],
			.IF_STATE_DESC[DSC$W_LENGTH],
			.IF_STATE_DESC[DSC$A_POINTER])
	    AND CH$FAIL(CH$FIND_SUB(.SEEN_STATES[DSC$W_LENGTH],
				.SEEN_STATES[DSC$A_POINTER],
				.KEYDESC[DSC$W_LENGTH],
				.KEYDESC[DSC$A_POINTER]))
	THEN BEGIN
	    STR$COPY_DX(PREV_STATE,IF_STATE_DESC);
	    STR$CONCAT(SEEN_STATES,SEEN_STATES,IF_STATE_DESC,$DESCRIPTOR('/'));
	    MAIL$PUT_OUTPUT(PREV_STATE);
	    END;
	END;
    END;

RETURN TRUE
END;

END
ELUDOM
