
module lnk_objpass2 
		(ident = 'V04-000'
		,addressing_mode 
			(nonexternal = long_relative
			,external    = general
			)
		) =

begin
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_OBJPASS2
!
! FACILITY: LINKER
!
! ABSTRACT: PASS 2 OF OBJECT MODULES
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 11-APR-77
!
! MODIFIED BY:
!
!	V03-016	ADE0002		Alan D. Eldridge	13-Aug-1984
!		Fix call to LNK$WRTIMGBYTS so that the repeat count
!		is "1" instead of "0".
!
!	V03-015	ADE0001		Alan D. Eldridge	 4-May-1984
!		Fix access violation in STORECOMMAND.
!
!	V03-014	JWT0154		Jim Teague		10-Feb-1984
!		Modules that contributed to the DST but had no psects
!		that were other than 0-length were left out of the 
!		DMT.  Revise the philosophy here: make a DMT entry
!		for any module that contributes to the DST, regardless
!		of the presence or absence of non-0-length psects.
!		I rewrote the whole mess while I was at it, placing
!		the DMT code into a separate, heavily-commented routine,
!		construct_dmt.
!
!	V03-013	JWT0136		Jim Teague		07-Sep-1983
!		When checking for a pic shareable image after finding
!		a non-relocatable reference, be sure to check if the
!		image is pic AND shr.  Also, even if STDISPIC message 
!		is to be issued, it IS just a warning -- go ahead with 
!		computing the symbol reference.  
!
!	V03-012	JWT0118		Jim Teague		04-May-1983
!		Implement flagstack for processing symbols and
!		expressions.
!
!	V03-011	JWT0116		Jim Teague		29-Apr-1983
!		New error message LIN$_STDISPIC for STO_xD commands
!		that store non-relocatable values into pic shr images.
!		That displacement is computed relative to the linker's
!		location counter (lnk$gl_locn), and once the image is 
!		relocated, that displacement will likely be wrong.
!
!	V03-010	JWT0094		Jim Teague		03-Feb-1983
!		Don't write length of last DMT entry when image 
!		production is disabled.
!
!	V03-009	JWT0092		Jim Teague		01-Feb-1983
!		Fix to DMT pointer adjustment when a module consists
!		of nothing BUT 0-length psects.
!
!	V03-008	JWT0088		Jim Teague		12-Jan-1982
!		Filter 0-length psects out of DMT info.
!
!	V03-007	JWT0084		Jim Teague		07-Jan-1982
!		Fix some more of shareable image symbol expression
!		problem.
!
!	V03-006	JWT0080		Jim Teague		15-Dec-1982
!		Fix part of shareable image symbol relocation problem.
!
!	V03-005	JWT0078		Jim Teague		15-Dec-1982
!		Change implementation of DMT.  Don't make it an image
!		section -- let Debugger map it if needed.
!
!	V03-004	JWT0074		Jim Teague		09-Dec-1982
!		Finalize Debugger DMT.
!
!	V03-003	JWT0061		Jim Teague		22-Oct-1982
!		Add debugger image section to images linked /debug.
!
!	V03-002	JWT0041		Jim Teague		30-Jun-1982
!		Fix for shr img symbols in based clusters
!
!	V03-001	JWT0038		Jim Teague		23-Jun-1982
!		Clean up INFO#212 errors.
!
!
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!
!	THIS MODULE CONTAINS THE ROUTINES WHICH IMPLEMENT THE SECOND OBJECT
!	MODULE PASS OF THE LINK. SINCE THE DATA STRUCTURES RELATING
!	OBJECT MODULES AND FILES WERE BUILT DURING PASS 1, IT IS NOW ONLY
!	NECESSARY TO FOLLOW THE LINKED LISTS TO ACQUIRE EACH OBJECT
!	MODULE.
!	PASS 2 IS CONCERNED WITH WRITING THE BINARY TO THE
!	OUTPUT IMAGE AND PRODUCTION OF THE MODULE SYNOPSIS OF THE
!	OUTPUT MAP LISTING. THEREFORE, THIS PASS IGNORES GSD
!	RECORDS COMPLETELY.
!--
!
library
	'LIBL32';			! SYSTEM DATA STRUCTURES
require
	'PREFIX';			! MACROS ETC.
library
	'DATBAS';			! INTERNAL DATA BASE
require
	'ISGENC';			! ISECT GENERATION CONTROL TABLES
require
	'TIRAUX';			! AUXILIARY MACROS FOR TIR DATA
!
structure
	doublevector [i,j;n,unit=4,ext=1] =
			[2*unit*n]
			(doublevector + 2*unit*i + unit*j) ;
!
linkage
	tir_proc  = jsb	 : global (commandtype = 11
				  ,commandata  = 10
				  ,datalng     =  9
				  ) preserve (2,3,4) nopreserve (5,6,7,8),

	tir_proc2 = call : global (commandtype = 11
				  ,commandata  = 10
				  ,datalng     =  9
				  ) ;
forward routine
	report_illnamlng,				! ILLEGAL SYMBOL NAME LENGTH
	report_tirlng 		: tir_proc2,		! REPORT RECORD TOO SHORT FOR DATA REQUIRED
	report_udefpsc,					! REPORT REFERENCE TO UNDEFINED PSECT
	report_useundef,				! REPORT USING UNDEFINED SYMBOL
	report_useudfenv,				! REPORT USING UNDEFINED ENVIRONMENT
	report_useudflsy,				! REPORT USING UNDEFINED MODULE LOCAL SYMBOL
	prohdrs,					! PASS 2 PROCESSING OF HEADER RECORDS
	alloc_spcr,					! ALLOCATE SPCR BLOCK
	compare_spcr,					! COMPARE VALUE AND SPCR BLOCK
	compare_lit,					! COMPARE VALUE AND LIT BLOCK
	alloc_lit,					! ALLOCATE LIT BLOCK
	protirdbg,					! PASS 2 ON TIR AND DBG RECORDS
	stackcommand 		: tir_proc,		! PROCESS TIR STACK COMMANDS
	storecommand 		: tir_proc,		! PROCESS TIR STORE COMMANDS
	operatecommand 		: tir_proc,		! PROCESS TIR OPERATE COMMANDS
	controlcommand 		: tir_proc,		! PROCESS TIR CONTROL COMMANDS
	report_illtir 		: tir_proc,		! PROCESS ILLEGAL TIR COMMANDS
	report_illtir2 		: tir_proc2,		! PROCESS ILLEGAL TIR COMMANDS
	fndpscmapent,					! RETURNS MAPPING TABLE ADDRESS
	baseallimages,					! BASE ALL PIC,NON-BASED SHAREABLE IMAGES
	checkshrsym,					! VERIFY CORRECTNESS OF SHR IMG SYMBOL REF
	setaddressref,					! STORE INFO FOR .ADDR
	push,						! PUSHES VALUES ONTO INTERNAL STACKS
	pop ;						! REMOVES THEM
!
external routine
	crf$insrtkey,					! INSERT A KEY DESCRIPTION IN CREF TABLES
	crf$insrtref,					! INSERT A REFERENCE IN CREF TABLES
	lib$insert_tree,				! INSERT INTO BINARY TREE
	lib$lookup_tree,				! LOOKUP IN BINARY TREE
	lnk$nxtobjmod,					! ACQUIRE NEXT OBJECT MODULE
	lnk$nxtrec,					! GET NEXT RECORD OF OBJECT MODULE
	lnk$mapmhd,					! MAP MODULE HEADER INFORMATION
	lnk$maplng,					! MAP THE COMPILER NAME
	lnk$search,					! SYMBOL TABLE SEARCH
	lnk$searchlocal,				! LOCAL SYMBOL TABLE SEARCH
	lnk$fndpscnam,					! FIND/ENTER P-SECTION
	lnk$alloblk, 					! MEMORY ALLOCATION ROUTINE
	lnk$getfixsize,					! COMPUTE SIZE OF FIXUP VECTOR
	lnk$crefixisd,					! CREATE FIXUP SECTION
	lnk$allovirmem,					! ALLOCATE MEMORY AT A SPECIFIC ADDRESS
	lnk$cluvirmem,					! ALLOCATE MEMORY FOR A CLUSTER
	lnk$wrtimgbyts;					! WRITE BYTE STREAM TO IMAGE
!
external literal
	lib$_normal,					! NORMAL RTL RETURN
	lin$_adrwrtdat,					! .ADDRESS IN SHR, WRT SECTION
	lin$_alredef,					! MULTIPLE .TRANSFER FOR A SYMBOL
	lin$_basduerrs,					! BASING IMAGE DUE TO REFERENCE ERRORS
	lin$_eomstk,					! STACK NOT COLLAPSED AT EOM
	lin$_format,					! ILLEGAL FORMAT
	lin$_illnamelen,				! ILLEGAL NAME LENGTH (SYMBOL OR PSECT)
	lin$_illrectyp,					! ILLEGAL RECORD TYPE
	lin$_illshropr,					! ILLEGAL OPERATOR ON SHR IMG SYM
	lin$_illshrxpr,					! TWO SHR SYMS IN EXPRESSION
	lin$_illtir,					! ILLEGAL TIR COMMAND
	lin$_intstkov,					! INTERNAL STACK OVERFLOW
	lin$_intstkun,					! INTERNAL STACK UNDERFLOW
	lin$_insvirmem,					! INSUFFICIENT VIRTUAL MEMORY
	lin$_noepm,					! ATTEMPT TO STACK ENTRYPOINT MASK
	lin$_nogsdref,					! NO GSD REF TO SHAREABLE IMAGE SYMBOL FOUND
	lin$_noimgfil,					! NO IMAGE FILE CREATED
	lin$_nonpicref,					! USE OF .LONG, ETC TO RELOCATABLE IN SHAREABLE IMAGE
	lin$_notpsect,					! SET RELOC. BASE TO OTHER THAN PSECT CONTEXT
	lin$_rectyp,					! ILLEGAL RECORD
	lin$_shrpscref,					! INCORRECT REFERENCE TO SHAREABLE IMAGE PSECT
	lin$_shrsymref,					! INCORRECT REFERENCE TO SHAREABLE IMAGE SYMBOL
	lin$_shrsymtra,					! ATTEMPTED .TRANSFER FOR SHR IMG SYM
	lin$_stalitudf,					! STACK OF UNDEFINED LITERAL
	lin$_tirlng,					! TIR COMMAND DATA O'FLOWS RECORD
	lin$_tirnyi,					! UNIMPLEMEMTED TIR COMMAND
	lin$_trunc,					! TRUNCATION ERRORS
	lin$_truncdat,					! WITH DATA OUTPUT
	lin$_udefpsc,					! REFERENCE TO UNDEFINED P-SECTION
	lin$_useudfenv,					! REFERENCE TO UNDEFINED ENVIRONMENT
	lin$_useudfen2,					!  ...
	lin$_useudflsy,					! REFERENCE TO UNDEFINED MODULE-LOCAL SYMBOL
	lin$_useundef,					! USING AN UNDEFINED SYMBOL
	lin$_useundef2,					!  ... IN A DEBUG / TRACEBACK RECORD
	lin$_illvps,					! ILLEGAL ARGUMENTS TO STORE VARIABLE POSITION/SIZE
	lin$_excpsc,					! TOO MANY PSECTS DEFINED (IN A SHAREABLE IMAGE BEING CREATED)
	lin$_stdispic;					! tir$c_sto_ld or sto_bd of scalar in a pic shr image
!
external
	lnk$gl_dmtbytes,				! SIZE OF DMT 
	lnk$gl_dmtbuffer	: vector [2],		! BUFFER FOR ALLOCATED FOR DMT
	lnk$gw_shriscts 	: word,			! NUMBER OF ISECTS FROM PIC SHAREABLE IMAGES
	lnk$gb_matchctl 	: byte,			! GLOBAL SECTION MATCH CONTROL FOR SHAREABLE IMAGE BEING CREATED
	lnk$al_valctltb,				! CREF BY VALUE CONTROL TABLE
	lnk$al_sytblfmt,				! SYMBOL TABLE FORMAT DESCRIPTION BLOCK
	lnk$gl_ctlmsk 		: block [,byte],	! LINK CONTROL MASK
	lnk$gl_curisd 		: ref block [,byte], 	! ADDRESS OF ISD OWNING CURRENT P-SECT
	lnk$gl_defclu 		: block [,byte],	! DEFAULT CLUSTER DESCRIPTOR
	lnk$gl_locn,					! CURRENT LOCATION COUNTER
	lnk$gl_dstlocn,					! CURRENT LOCATION IN DEBUG SYMBOL TABLE
	lnk$gl_curclu 		: ref block [,byte],	! POINTER TO CURRENT CLUSTER DESCRIPTOR
	lnk$gl_clulst,					! LIST HEAD OF CLUSTER LIST
	lnk$gl_fixisd 		: ref block [,byte],	! POINTER TO FIXUP ISECT DESCRIPTOR
	lnk$gl_lastgadr,				! LAST SPECIAL G^ ADDR ASSIGNED
	lnk$gl_record,					! RECORD NUMBER
	lnk$gl_rprotisd,				! NUMBER OF ISECTS TO REPROTECT
	lnk$gl_imgfil 		: ref block [,byte],	! IMAGE FILE FDB
	lnk$gt_imgnam 		: vector [,byte], 	! IMAGE FILE NAME
	lnk$gt_symstring,				! ASCIC STRING OF 'SYMBOL'
	lnk$gt_pscstring,				! ASCIC STRING OF 'PSECT'
	lnk$gl_curomd 		: ref block [,byte],	! POINTER TO CURRENT OBJ MOD. DESCRIPTOR
	lnk$gl_curfil 		: ref block [,byte] ;	! POINTER TO CURRENT FILE DESCRIPTOR
!
global
	lnk$gl_omdadrlst,				! LISTHEAD OF LIST OF OMD'S CONTAINING .ADDRESS
	lnk$gl_omdadrend,				! POINTER TO END OF OMDADRLST
	lnk$gl_nadromd,					! NUMBER OF MODULES CONTAINING .ADDRESS DATA
	lnk$gl_pshrnum 		: initial (0),		! COUNT THE NUMBER OF PSECTS
							! BOUND FOR A (POSSIBLE)
							! SHAREABLE IMAGE
	lnk$gl_spcgfix,					! NUMBER OF SPECIAL G^ FIXUPS
	lnk$gl_spcgimgs,				! NUMBER OF SHR IMGS REFERENCED WITH SPECIAL G^ FIXUPS
	lnk$gl_adrefs,					! NUMBER OF .ADDRESS FIXUPS IN LINK
	lnk$gl_shradr,					! NUMBER OF SHAREABLE IMAGES REF'D BY .ADDRESS
	lnk$gl_litbl,					! POINTER TO LITERAL TABLE
	lnk$gl_litflgs 		: bitvector [lnk$c_nlits], ! DEF FLAGS FOR LITERALS
	lnk$gl_curpsc 		: ref block [,byte] ;	! POINTER TO CURRENT PSECT DESCRIPTOR
!
global literal
	stk$c_size = 25 ;				! INTERNAL STACK SIZE
!
own
	absexpr		: initial (0),			! USED TO ACCUMULATE THE ABS PART OF SHR IMG EXPRESSIONS
	shrimgsym 	: ref block [,byte],		! POINTER TO STACKED SYMBOL DESCRIPTOR IF FROM SHAREABLE IMAGE
	shrsymexpr 	: ref block [,byte],		! POINTER TO STACKED SYMBOL DESCRIPTOR IF SHR IMG SYMBOL EXPRESSION
	obmodesc 	: ref block [,byte],		! CURRENT OBJ DESCRIPTOR
	objrecdesc 	: block [dsc$c_s_bln, byte],	! STRING DESCRIPTOR FOR OBJ RECORD
	curpsectbase,					! BASE ADDRESS OF CURRENT CONTRIBUTION
	stapx 		: byte,				! TRUE IF LAST COMMAND WAS STAPX
	stackpointer 	: byte,				! INTERNAL STACK POINTER
	basedmsgout 	: byte,				! TRUE IF MSG ABOUT BASING HAS BEEN ISSUED
	endrecaddr,					! END OF CURRENT RECORD
	tiroffset,					! OFFSET OF CURRENT COMMAND
	pdl,						! POSITION DEPENDENCE LEVEL
	flags 		: block [2, byte],		! word for flags
	compustack 	: vector [stk$c_size],		! COMPUTATION STACK
	pdlstack 	: vector [stk$c_size, byte],	! PDL STACK
	psectstack 	: doublevector [stk$c_size],	! STACK TO RECORD P-SECTION CONTEXT
	shrsymstack 	: vector [stk$c_size],		! STACK SHRIMGSYM
	stapxstack 	: vector [stk$c_size, byte],	! STACK STAPX
	flagstack 	: vector [stk$c_size, word],	! word stack for symbol information
	prev_dstlen_addr,				! address of dstlen field of previous module
	dmtptr 		: ref block [,byte];		! current ptr into DMT

bind
	reclng = objrecdesc [dsc$w_length]  : word,
	objrec = objrecdesc [dsc$a_pointer] : ref block [,byte];

	psect own = $code$;
own
	stkdatlngtbl : vector [tir$c_maxstacod+1, byte] ! STACK COMMAND DATA LENGTH TABLE
		       initial (byte   (1,		! 0 - STACK GLOBAL - AT LEAST ONE BYTE FOLLOWS
					1,		! 1 - STACK SIGNED BYTE - ONE BYTE MUST FOLLOW
					2,		! 2 - STACK SIGNED WORD - TWO BYTES MUST FOLLOW
					4,		! 3 - STACK LONGWORD - FOUR BYTES MUST FOLLOW
					2,		! 4 - STACK P-SECTION BASE PLUS BYTE - TWO DATA BYTES
					3,		! 5 -   "       "       "   "   WORD - THREE DATA BYTES
					5,		! 6 -   "       "       "   "  LONGWORD - FIVE DATA BYTES
					1,		! 7 - STACK UNSIGNED BYTES - ONE BYTE MUST FOLLOW
					2,		! 8 - STACK UNSIGNED WORD - TWO BYTES MUST FOLLOW
					0,		! 9 - STACK BYTE FROM IMAGE - NO DATA BYTES
					0,		! 10 - STACK WORD FROM IMAGE - NO DATA BYTES
					0,		! 11 - STACK LONGWORD FROM IMAGE - NO DATA BYTES
					1,		! 12 - STACK ENTRY POINT MASK - AT LEAST ONE BYTE REQUIRED
					2+arg$c_size,	! 13 - STACK RESULT OF ARGUMENT CHECK.
					3,		! 14 - STACK PSECT BASE PLUS BYTE (WORD PSECT NUMBER) - THREE DATA BYTES
					4,		! 15 - STACK PSECT BASE PLUS WORD (WORD PSECT NUMBER) - FOUR DATA BYTES
					6,		! 16 - STACK PSECT BASE PLUS LONGWORD (WORD PSECT NUMBER) - 6 DATA BYTES
					3,		! 17 - STACK LOCAL SYMBOL
					1)),		! 18 - STACK LITERAL
!					3)),		! 19 - STACK LOCAL ENTRY POINT

	storectltbl : blockvector [tir$c_maxstocod-tir$c_minstocod+1,	! THIS IS THE
				   stoctl$c_size, byte]		! STORE COMMAND CONTROL TABLE
								! EACH ENTRY OF WHICH HAS TWO BYTES, BEING
								! THE FLAGS AND OUTPUT BYTE COUNT (RESPECTIVELY)
								! FOR THE CORRESPONDING STORE COMMAND.
								! SEE 'TIRAUX' FOR FURTHER DETAILS.
								! COMMAND TIR$C_MINSTOCOD + ...
		initial ( byte (0,1,				! 0 - STORE SIGNED BYTE
				0,2,				! 1 - STORE SIGNED WORD
				0,4,				! 2 - STORE LONGWORD
				stoctl$m_displ,1,		! 3 - STORE BYTE DISPLACED
				stoctl$m_displ,2,		! 4 - STORE WORD DISPLACED
				stoctl$m_displ,4,		! 5 - STORE LONGWORD DISPLACED
				6^stoctl$c_mbzbit,1,		! 6 - STORE SHORT LITERAL
				0,4,				! 7 - STORE POSITION INDEPENDENT LONGWORD DATA REF
				0,5,				! 8 - STORE POSITION INDEPENDENT CODE REFERENCE
								! WHICH IS ADDRESSING MODE FOLLOWED BY LONGWORD
				stoctl$m_rep,1,			! 9 - REPEATED SIGNED BYTE
				stoctl$m_rep,2,			! 10 - REPEATED SIGNED WORD
				stoctl$m_rep,4,			! 11 - REPEATED LONGWORD
				0,4,				! 12 - ARBITRARY BIT FIELD (UP TO 1 BYTE, BUT DON'T CHECK TRUNC.)
				8^stoctl$c_mbzbit,1,		! 13 - UNSIGNED BYTE
				16^stoctl$c_mbzbit,2,		! 14 - UNSIGNED WORD
				stoctl$m_rep or (8^stoctl$c_mbzbit) ,1,	! 15 - REPEATED UNSIGNED BYTE
				stoctl$m_rep or (16^stoctl$c_mbzbit),2,	! 16 - REPEATED UNSIGNED WORD
				stoctl$m_conmbz or (8^stoctl$c_mbzbit) ,1,	! 17 - BYTE (-128 TO +255)
				stoctl$m_conmbz or (16^stoctl$c_mbzbit),2,	! 18 - WORD (-32K TO + 65K)
				stoctl$m_rep or stoctl$m_conmbz or	! 19 - REPEATED BYTE (-128 TO +255)
					(8^stoctl$c_mbzbit),1,
				stoctl$m_rep or stoctl$m_conmbz or	! 20 - REPEATED WORD (-32K TO +65K)
				(16^stoctl$c_mbzbit),2,		! 20 - REPEATED WORD (-32K TO +65K)
				stoctl$m_rep,0,			! 21 - STORE REPEATED IMMEDIATE VARIABLE NO. BYTES
				0,4));				! 22 - STORE POSITION INDPENDENT RELATIVE REFERENCE

	psect own = $own$;
bind
	fixup_section = cstring ('Fixup section'),	! NAME OF THE FIXUP SECTION
	objvec = objrec : ref vector [,byte],		! NAME RECORD AS BYTE VECTOR ALSO
	tirrec = objrec : ref vector [,byte];		! RENAME THE RECORD


routine report_illnamlng (symbolstring) =
begin
!
! REPORT SYMBOL NAME LENGTH ILLEGAL
!
map
    symbolstring : ref vector[,byte];

signal(lin$_illnamelen,6,lnk$gt_symstring,
	symbolstring[0],.symbolstring[0],
	sym$c_maxlng,obmodesc[omd$b_namlng],
	lnk$gl_curfil[fdb$q_filename]);

return false
end;

routine report_tirlng : tir_proc2 =
begin
!
! REPORT RECORD TOO SHORT TO HOLD REQUIRED DATA
!
external register
    datalng = 9;

signal(lin$_tirlng,4,.datalng,obmodesc[omd$b_namlng],	!SIGNAL RECORD TOO SHORT
	.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);

return false
end;

routine report_udefpsc (psectnum) =
begin
!
! REPORT REFERENCE TO AN UNDEFINED PSECT
!
signal(lin$_udefpsc,3,.psectnum,obmodesc[omd$b_namlng],
	lnk$gl_curfil[fdb$q_filename]);

return false
end;

routine report_useundef (symbolname) =
begin
!
! REPORT ATTEMPT TO USE AN UNDEFINED SYMBOL
!
if .lnk$gl_ctlmsk [lnk$v_dbgrec]
then signal (lin$_useundef2, 3, .symbolname
	    ,obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]
	    )
else signal (lin$_useundef, 5, .symbolname
	    ,lnk$gl_curpsc [psc$b_namlng], (.lnk$gl_locn-.curpsectbase)
	    ,obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]
	    );

return false
end;

routine report_useudfenv (envdesc,envindex) =
begin
!
! REPORT REFERENCE TO UNDEFINED ENVIRONMENT
!
map
    envdesc : ref block[,byte];

local
    errorcode,
    arg1;

if .envdesc eql 0
then begin
    errorcode = lin$_useudfen2;
    arg1 = .envindex;
    end
else begin
    errorcode = lin$_useudfenv;
    arg1 = envdesc[nvd$b_namlng];
    end;
signal(.errorcode,5,.arg1,
	lnk$gl_curpsc[psc$b_namlng],
	(.lnk$gl_locn-.curpsectbase),
	obmodesc[omd$b_namlng],
	lnk$gl_curfil[fdb$q_filename]);

return false
end;

routine report_useudflsy (symbolname) =
begin
!
! REPORT REFERENCE TO UNDEFINED LOCAL SYMBOL
!
signal(lin$_useudflsy,5,.symbolname,
	lnk$gl_curpsc[psc$b_namlng],(.lnk$gl_locn-.curpsectbase),
		obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename]);
return false;
end;

routine report_illtir : tir_proc =
begin

external register
    commandtype = 11 : byte;

signal(lin$_illtir,4,
	.commandtype,obmodesc[omd$b_namlng],
	.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);

return false
end;

routine report_illtir2 : tir_proc2 =
begin

external register
    commandtype = 11 : byte;

signal(lin$_illtir,4,
	.commandtype,obmodesc[omd$b_namlng],
	.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);

return false
end;

routine fndpscmapent(psctnum) =
begin
!	THIS ROUTINE RETURNS THE ADDRESS OF THE MAPPING TABLE ENTRY
!	FOR THE GIVEN PSECT NUMBER.
!

if .psctnum gtru .obmodesc[omd$w_hipsct]
    then return 0;

if not .obmodesc[omd$v_p256]
then return obmodesc[omd$t_pscmap]+.psctnum*pmt$c_size
!
! MODULE HAS MORE THAN 256 PSECTS
!
else begin
     local  mapent : ref block[,byte];

      mapent = .(obmodesc[omd$t_pscmap] + (.psctnum/256)*pmt$c_size);	! GET EXTENDED TABLE ADDRESS
      if .mapent neq 0							! IF EXTENDED TABLE PRESENT
      then return .mapent + (.psctnum mod 256)*pmt$c_size		!  THEN RETURN ENTRY ADDRESS
      else return 0;
      end;
end;									! OF FNDPSCMAP

routine push (value, psectnum, posdeplvl) =
begin
!
!	THIS ROUTINE IMPLEMENTS THE PUSHING OF VALUES ON THE LINKERS
!	INTERNAL STACKS. INPUT PARAMETERS ARE:
!		VALUE	   =	VALUE TO BE PLACED ON STACK
!		PSECTNUM   =	THE MODULE RELATIVE P-SECTION INDEX TO
!				WHICH THE STACKED VALUE IS RELATIVE
!		POSDEPLVL  =	THE POSITION DEPENDENCE LEVEL OF THE VALUE
!				BEING STACKED.
!				NORMALLY = 1 FOR AN ADDRESS (E.G. A
!					     RELOCATED SYMBOL)
!					   0 FOR A SCALER.
!	IF PSECTNUM = -1 THEN THE VALUE IS NOT TO BE RELATIVE TO A 
!	P-SECTION BASE ADDRESS. IF, HOWEVER, PSECTNUM IS NOT -1, THEN
!	THE OBJECT MODULE DESCRIPTOR IS ACCESSED TO DETERMINE IF THIS
!	MODULE HAS SUCH A P-SECTION (FOUND ON PASS 1) AND TO COMPUTE
!	THE BASE ADDRESS OF THIS MODULE'S CONTRIBUTION TO THAT P-SECTION.
!	IF THIS SUCCEEDS, THE VALUE STACKED IS THE SUM OF THE MODULE
!	CONTRIBUTION BASE AND "VALUE"
!
!	IN ADDITION TO THE ABOVE CHECKS, THIS ROUTINE ALSO DETECTS STACK
!	OVERFLOW. ON ANY FAILURE CONDITION, AN ERROR MESSAGE IS ISSUED
!	AND THE VALUE "FALSE" IS RETURNED.
!
!	THERE ARE TWO PARALLEL STACKS - ONE FOR COMPUTATION AS DRIVEN
!	BY THE COMPILER GENERATED OBJECT LANGUAGE AND THE OTHER
!	CALLED THE PDL STACK, FOR LINKER COMPUTATION OF POSITION
!	DEPENDENCE AND COERCION OF PIC IMAGES. THE COMPUTATION 
!	STACK IS LONGWORD ALIGNED WHILE THE PDL STACK IS A BYTE STACK.
!
local
	psctmap : ref block[,byte],		! POINTER TO PSECT MAPPING TABLE ENTRY
	modcontribase,				! BASE OF THIS MODULES CONTRIBUTION TO P-SECTION
	psectdesc : ref block[,byte],		! P-SECTION DESCRIPTOR POINTER
	modpscontriblk : ref block[,byte];	! POINTER TO DESCRIPTOR OF CONTRIBUTION
!
if .psectnum eql -1						! MODULE BASE OF P-SECTION
then (modcontribase = 0; psectdesc = 0)				! IS ZERO IF NOT P-SECT RELATIVE
else begin							! VALUE. IF IT IS PSECT
	if .psectnum gtru .obmodesc[omd$w_hipsct]		! RELATIVE, CHECK P-SECTION
	    then return report_udefpsc(.psectnum);
	psctmap = fndpscmapent(.psectnum);			! GET MAPPING TABLE ENTRY
	if .psctmap eql 0
	    or (psectdesc = .psctmap[pmt$l_pscdes]) eql 0	! GET P-SECTION DESCRIPTOR
	    or (modpscontriblk = .psctmap[pmt$l_modcon]) eql 0	! AND MODULE CONTRIBUTION BLOCK
	    then return report_udefpsc(.psectnum);
	modcontribase = .psectdesc[psc$l_base] +		! THE MODULE'S BASE IS
				 .modpscontriblk[mpc$l_offset]; ! P-SECT BASE PLUS OFFSET.
     end;
if .stackpointer eql 0							! NOW CHECK IF ALREADY
then begin								! AT BOTTOM OF STACK AND
	signal(lin$_intstkov,3,stk$c_size,				! IF SO ISSUE ERROR MESSAGE
			obmodesc[omd$b_namlng],
			lnk$gl_curfil[fdb$q_filename]);
	return false;
	end;

stackpointer = .stackpointer -1;					! DECREMENT POINTER
compustack[.stackpointer] = .value + .modcontribase;			! PUSH VALUE ONTO COMPUTE STACK
pdlstack[.stackpointer] = .posdeplvl;					! AND ON PDL STACK.
psectstack[.stackpointer,0] = .psectdesc;				! SAVE PSECT DESCRIPTOR ADDRESS AND THE
psectstack[.stackpointer,1] = .modcontribase;				! MODULE'S BASE ON THE PSECT STACK
shrsymstack[.stackpointer] = (if .shrimgsym neq 0 			! SAVE AWAY SHR IMG SYMBOL INFO
			      then .shrimgsym
			      else .shrsymexpr);
stapxstack[.stackpointer] = .stapx;
flagstack[.stackpointer] = .flags;
return true;								! AND RETURN SUCCESS.
end;

routine pop (valueaddr, pdladdr) =
begin
!
!	THIS ROUTINE REMOVES VALUES FROM THE INTERNAL STACKS
!	OF THE LINKER AS DESCRIBED WITH "PUSH" ABOVE.
!	STACK OVERFLOW CAUSES THE ISSUANCE OF AN ERROR
!	MESSAGE AND RETURN VALUE OF FALSE.
!
if .stackpointer gequ stk$c_size
then begin
     signal(lin$_intstkun,3,stk$c_size,				! IF STACK IS ALREADY
			obmodesc[omd$b_namlng],			! EMPTY, ISSUE ERROR AND QUIT
			lnk$gl_curfil[fdb$q_filename]);
      return false;
      end;
.valueaddr   = .compustack [.stackpointer];			! POP VALUE
.pdladdr     = .pdlstack [.stackpointer];			! AND PDL TO WHERE CALLER WANTS THEM
shrimgsym    = .shrsymstack [.stackpointer];			! RESTORE SHR IMG SYMBOL INFO
stapx        = .stapxstack [.stackpointer];
flags        = .flagstack [.stackpointer];
stackpointer = .stackpointer + 1;
return true;							! UPDATE POINTER AND
end;								! SUCCESS

routine compare_lit (value, node) =
begin
!
! COMPARE A VALUE WITH CURRENT NODE
!
map
    node : ref block[,byte];

return (.value - .node[lit$b_index])
end;

routine alloc_lit (value, retadr) =
begin
!
! ALLOCATE A NEW LIT BLOCK
!
map
    retadr : ref vector[,long];

lnk$alloblk(lit$c_size, retadr[0]);

return true
end;

routine stackcommand : tir_proc =
begin
!
! PROCESS TIR STACK COMMANDS
!
external register
    commandtype = 11 : byte,
    commandata = 10 : ref block[,byte],
    datalng = 9;

local
    argnum,					! INDEX TO ARGUMENT TO BE CHECKED
    argdesc : ref block[,byte],			! POINTER TO ARGUMENT DESCRIPTOR
    psectnum,					! P-SECTION NUMBER
    symdscnam : ref block[,byte],		! PTR TO NAME BLOCK PART
    symdesc : ref block[,byte],			! SYMBOL DESCRIPTOR POINTER
    envdesc : ref block[,byte],			! POINTER TO ENVIRONMENT DESCRIPTOR
    value;					! TEMP VALUE HOLDER

datalng = .stkdatlngtbl[.commandtype];			! GET EXPECTED DATA LENGTH
if (commandata[signed_byte] + .datalng) gtru .endrecaddr! AND CHECK THAT IT EXISTS
    then return report_tirlng();
psectnum = -1;						! NOT P-SECTION RELATIVE
shrimgsym = flags = pdl = value = stapx = 0;		! AND NOT SHAREABLE IMAGE SYMBOL/PSECT
!
! DISPATCH ON THE COMMAND TYPE
!
case .commandtype from 0 to tir$c_maxstacod
of set
    [tir$c_sta_gbl,					! STACK GLOBAL SYMBOL
    tir$c_sta_epm,					! ENTRY POINT MASK
    tir$c_sta_ckarg] :					! CHECK ARGUMENT
	begin					
	    datalng = .datalng+.commandata[symboleng];		! UPDATE THE ACTUAL LENGTH OF THE DATA
	    if .commandtype eql tir$c_sta_ckarg			! IF ARGUMENT CHECK COMMAND
	    then begin
		argnum = .(commandata[symboleng] + 1 + 		! FETCH THE ARGUMENT
				.commandata[symboleng])<0,8,0>;	! NUMBER AS AN UNSIGNED BYTE
		argdesc = 2 + commandata[symboleng] +		! AND COMPUTE ADDRESS
					.commandata[symboleng];	! WITHIN RECORD
		datalng = .datalng + .argdesc[arg$b_bytecnt];	! THEN UPDATE DATA COUNT
		end;
	    if (commandata[symboleng] +.datalng) gtru .endrecaddr ! CHECK IF DATA ALL PRESENT
		then return report_tirlng();
	    if .commandata[symboleng] gtru sym$c_maxlng		! CHECK SYMBOL NAME LENGTH
		or .commandata[symboleng] eql 0
		then return report_illnamlng(commandata[symboleng]);
	    if not lnk$search(commandata[symboleng],symdesc,symdscnam) ! GO LOOK UP SYMBOL
	    then begin
		if .commandtype eql tir$c_sta_ckarg		! IF NOT FOUND
		    then value = true;				! DEFAULT IS 0 EXCEPT FOR CHECK ARG
		report_useundef(commandata[symboleng]);		! REPORT REFERENCE TO UNDEFINDE SYMBOL
		flags[flg$v_undef] = true;
		end
	    else begin						! SYMBOL FOUND
		 bind imgclu = .symdesc[sym$l_cludsc] : block[,byte];
		if .symdesc[sym$v_shrimg]			! IF SYMBOL IS FROM A SHAREABLE IMAGE
		    and .symdesc[sym$v_rel]			!  AND IS RELOCATABLE
		    and not .symdesc[sym$v_gref]		!  BUT HAS NOT BEEN PUT IN SHR LST
		    and not .imgclu[clu$v_based]
		    and not .lnk$gl_defclu[clu$v_based]
		    then begin
			signal(lin$_nogsdref,3,commandata[symboleng], ! THEN TELL USER OF PROBLEM
				obmodesc[omd$b_namlng],
				lnk$gl_curfil[fdb$q_filename],lin$_noimgfil);
			lnk$gl_ctlmsk[lnk$v_image] = false;
			end;
		if .commandtype eql tir$c_sta_epm		! IF THIS IS STACK ENTRY POINT MASK
		    then if not .symdesc[sym$v_entmsk]		!  THEN MAKE SURE SYMBOL HAS ONE
			then signal(lin$_noepm,3,		!  ISSUE MESSAGE IF NOT.
				commandata[symboleng],obmodesc[omd$b_namlng],
				lnk$gl_curfil[fdb$q_filename]);	!  MASK FIELD IN SYMBOL BLOCK WILL BE 0
		if not .symdesc[sym$v_def]			! NOW CHECK WHAT WE FOUND WAS A DEF.
		    then 
			begin
			flags[flg$v_undef] = true;
			report_useundef(commandata[symboleng]);! AND REPORT ERROR IF NOT
			end;
		if .commandtype eql tir$c_sta_gbl
		then begin
		    value = .symdesc[sym$l_value];		! GET SYMBOL VALUE IF COMMAND IS STACK GLOBAL
		    if .symdesc[sym$v_rel]			! AND IF RELOCATABLE SET PDL = 1
			then pdl = 1;
		    if .symdesc[sym$v_rel]			! IF SYMBOL IS RELOCATABLE
			or .symdesc[sym$v_gref]			! OR FROM A SHARABLE IMAGE
			then shrimgsym = .symdesc;		! REMEMBER ADDRESS OF SYMBOL BLOCK
		    end
		else if .commandtype eql tir$c_sta_epm		! FOR STACK ENTRY POINT MASK, MASK IS THE VALUE
		    then value = .symdesc[sym$w_entmsk];
		if .commandtype eql tir$c_sta_ckarg
		then begin					! CHECK ARGUMENT ...
		    bind
			argvaldata = symdesc[sym$l_valdata]	! POINT TO THE VALIDATION
						: ref vector[,byte];	! DATA ARRAY
		    if .argvaldata eql 0			! BUT IF NONE
			then value = true			! SET INDICATOR
			else if (.argvaldata[0] - 3) lssu .argnum ! IF NOT ENOUGH ARGS
			    then value = true			! ALSO ASSUME MATCH
			    else if .argvaldata[2+.argnum]	! OTHERWISE COMPARE THE ARGUMENTS
						eql .argdesc[arg$v_passmech]
				then value = true;		! AND SET VALUE
		     end;
	         end;
	    end;
    [tir$c_sta_lsy,
     tir$c_sta_lepm] :
	begin
	    datalng = .datalng + .commandata[lsymboleng];		! COMPUTE SIZE OF DATA NEEDED
	    if (commandata[lenvindex] + .datalng) gtru .endrecaddr	! ENSURE ALL THERE
		then return report_tirlng();				!  AND RETURN WITH ERROR IF NOT
	    if .commandata[lsymboleng] gtru sym$c_maxlng		! CHECK LENGTH OF SYMBOL NAME
		or .commandata[lsymboleng] eql 0
		then return report_illnamlng(commandata[lsymboleng]);
	    if not lnk$searchlocal(commandata[lsymboleng],		! LOOK UP THE SYMBOL
				.commandata[lenvindex],
				symdesc,symdscnam,envdesc)
	    then begin
		if .envdesc eql 0					! SIGNAL UNDEFINED ENVIRONMENT IF THAT IS TRUE
			or not .envdesc[nvd$v_def]
		    then report_useudfenv(.envdesc,.commandata[lenvindex]);
		report_useudflsy(commandata[lsymboleng]);
		end
	    else begin
		if .envdesc eql 0
		    or not .envdesc[nvd$v_def]
		    then report_useudfenv(.envdesc,.commandata[lenvindex]);
		if not .symdesc[sym$v_def]
		    then report_useudflsy(commandata[lsymboleng]);
		if .commandtype eql tir$c_sta_lepm			! CHECK ENTRY MASK PRESENT IF STA_LEPM
		then begin
		    if not .symdesc[sym$v_entmsk]
			then signal(lin$_noepm,3,commandata[lsymboleng],
				obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename])
			else value = .symdesc[sym$w_entmsk];
		    end
		else if .commandtype eql tir$c_sta_lsy			! IF STACKING LOCAL SYMBOL, GET SYMBOL VALUE
		then begin
		    value = .symdesc[sym$l_value];
		    if .symdesc[sym$v_rel]
			then pdl = 1;
		    end;
		end;
	    end;
    [tir$c_sta_sb] :
	    value = .commandata[signed_byte];			! GET A SIGN EXTENDED BYTE
    [tir$c_sta_sw] :
	    value = .commandata[signed_word];			! GET SIGN EXTENDED WORD
    [tir$c_sta_lw] :
	    value = .commandata[longword];			! GET LONGWORD DATA
    [tir$c_sta_pb,
    tir$c_sta_pw,
    tir$c_sta_pl] :
    	    begin
    		local
    		    cludesc : ref block[,byte],
		    psctmap : ref block[,byte],
		    psctdesc : ref block[,byte];

		pdl = 1;					! VALUE IS POSITION DEPENDENT
		psectnum = .commandata[psect_index];		! EXTRACT PSECT NUMBER
		psctmap = fndpscmapent(.psectnum);		! GET DESCRIPTOR ADDRESS
		if .psctmap neq 0
		then begin
		    psctdesc = .psctmap[pmt$l_pscdes];		! GET PSECT DESCRIPTOR ADDRESS
		    shrimgsym = .psctdesc;			! SAVE PSECT DESCRIPTOR ADDRESS
		    cludesc = .psctdesc[psc$l_cludsc];		! POINT TO CLUSTER PSECT IS IN
		    if .cludesc[clu$v_shrimg]			! IF IT'S A SHAREABLE IMAGE CLUSTER
			or .lnk$gl_ctlmsk[lnk$v_shr]		!  OR CREATING SHR IMAGE
			then stapx = true			! REMEBER LAST COMMAND WAS STAPX
			else shrimgsym = 0;			! BUT IF NOT, JUST FORGET IT
		    if .cludesc[clu$v_shrimg]			! IF TARGET IS SHAREABLE IMAGE CLUSTER
			and .cludesc[clu$v_based]		!  WHICH IS BASED
			then pdl = 0;				! THEN IT'S NOT POSITION DEPENDENT
		    end
		else return report_udefpsc(.psectnum);		! REPORT ERROR REFERENCING UNDEFINED PSECT
		case .commandtype from tir$c_sta_pb to tir$c_sta_pl
		of set
		    [tir$c_sta_pb] :
				value = .commandata[psect_b_offset];	! GET A BYTE OFFSET
		    [tir$c_sta_pw] :
				value = .commandata[psect_w_offset];	! WORD OFFSET
		    [tir$c_sta_pl] :
				value = .commandata[psect_l_offset];	! LONGWORD OFFSET
		    tes
		end;
    [tir$c_sta_wpb,							! STACK PSECT BASE PLUS OFFSET COMMANDS
    tir$c_sta_wpw,							! WHICH ALLOW A WORD OF PSECT NUMBER
    tir$c_sta_wpl] :
		begin
			local
			    cludesc : ref block[,byte],
			    psctmap : ref block[,byte],
			    psctdesc : ref block[,byte];

			pdl = 1;					! VALUE IS POSITION DEPENDENT
			psectnum = .commandata[wpsect_index];		! EXTRACT PSECT NUMBER
			psctmap = fndpscmapent(.psectnum);		! GET DESCRIPTOR ADDRESS
			if .psctmap neq 0
			then begin
			    psctdesc = .psctmap[pmt$l_pscdes];		! GET PSECT DESCRIPTOR ADDRESS
			    shrimgsym = .psctdesc;			! SAVE PSECT DESCRIPTOR ADDRESS
			    cludesc = .psctdesc[psc$l_cludsc];		! SAVE CLUSTER ADDRESS
			    if .cludesc[clu$v_shrimg]			! IF IT'S A SHAREABLE IMAGE CLUSTER
				or .lnk$gl_ctlmsk[lnk$v_shr]		!  OR CREATING SHR IMAGE
				then stapx = true			! REMEBER LAST COMMAND WAS STAPX
				else shrimgsym = 0;			! BUT IF NOT, JUST FORGET IT
			    if .cludesc[clu$v_shrimg]			! IF TARGET IS SHAREABLE IMAGE CLUSTER
				and .cludesc[clu$v_based]		!  WHICH IS BASED
				then pdl = 0;				! THEN IT'S NOT POSITION DEPENDENT
			    end
			else return report_udefpsc(.psectnum);		! NOT DEFINED, REPORT ERROR AND RETURN
			case .commandtype from tir$c_sta_wpb to	tir$c_sta_wpl
			of set
			    [tir$c_sta_wpb] :
					value = .commandata[wpsect_b_offset];	! GET A BYTE OFFSET
			    [tir$c_sta_wpw] :
					value = .commandata[wpsect_w_offset];	! WORD OFFSET
			    [tir$c_sta_wpl] :
					value = .commandata[wpsect_l_offset];	! LONGWORD OFFSET
			    tes
			end;
    [tir$c_sta_ub] :
		    value = .commandata[unsigned_byte];				! UNSIGNED BYTE
    [tir$c_sta_uw] :
		    value = .commandata[unsigned_word];				! UNSIGNED WORD
    [tir$c_sta_lit] :
		    begin
			local
			    litindex;

			!
			! GET THE INDEX.  ENSURE THAT THE LITERAL
			! HAS BEEN DEFINED. USE 0 IF NOT, AND ISSUE
			! A WARNING MESSAGE
			!
			litindex = .commandata[unsigned_byte];
			if not .lnk$gl_litflgs[.litindex]
			    then signal(lin$_stalitudf,4,.litindex,
				.lnk$gl_record,obmodesc[omd$b_namlng],
				lnk$gl_curfil[fdb$q_filename])
			else begin
			    local
				entry : ref block[,byte];

			    if lib$lookup_tree(lnk$gl_litbl,.litindex,		! LOOKUP LITERAL IN TREE
						compare_lit,entry)
			    then begin
				pdl = .entry[lit$v_pdl];			! RETRIEVE VALUES NEEDED
				stapx = .entry[lit$v_stapx];
				shrimgsym = .entry[lit$l_shrsym];
				shrsymexpr = .entry[lit$l_shrexpr];
				value = .entry[lit$l_value];
				end
			    else signal(lin$_stalitudf,4,.litindex,
					.lnk$gl_record,obmodesc[omd$b_namlng],
					lnk$gl_curfil[fdb$q_filename]);
			    end;
			end;
    [inrange] :
		return report_illtir2();		! OTHERWISE IT'S ILLEGAL
    tes;

return push (.value,.psectnum,.pdl)			! NOW PUSH THE VALUES AND RETURN
end;

routine baseallimages =
begin
!
! THIS ROUTINE ALLOCATES VIRTUAL ADDRESS SPACE FOR FIXUP SECTION AND
! BASES ALL PIC, NON-BASED SHAREABLE IMAGES
!
local
    fixhdr : ref block[,byte],
    fixsize,
    cluster : ref block[,byte],
    symsnb : ref block[,byte],
    symbol : ref block[,byte];

if not .lnk$gl_ctlmsk[lnk$v_lbased]		! IF WE HAVEN'T DONE THIS YET
then begin
    if .lnk$gl_fixisd eql 0			! IF NO FIXUP SECTION YET CREATED
	then lnk$crefixisd();
    fixhdr = lnk$gl_fixisd[isl$t_hdrisd];	! POINT TO PART BOUND FOR HEADER
    fixhdr[isd$w_pagcnt] = lnk$getfixsize();	! COMPUTE SIZE OF SECTION
    if not lnk$allovirmem(.fixhdr[isd$v_vpn]^9,
				.fixhdr[isd$w_pagcnt])
    then begin
	signal(lin$_insvirmem,2,.fixhdr[isd$w_pagcnt],
			fixup_section,lin$_noimgfil);
	lnk$gl_ctlmsk[lnk$v_image] = false;
	end;
    lnk$gl_fixisd[isl$v_memalo] = true;		! FLAG FIXUP SECTION ALLOCATED
!
! NOW FIND AND BASE ALL PIC NON-BASED SHAREABLE IMAGES
!
    cluster = lnk$gl_clulst;
    while (cluster = .cluster[clu$l_nxtclu]) neq 0
    do if .cluster[clu$v_shrimg]
	and not .cluster[clu$v_based]
    then begin
	lnk$cluvirmem(.cluster);		! ALLOCATE VIRT MEMORY FOR THIS CLUSTER
	lnk$gw_shriscts = .lnk$gw_shriscts -	! DECREMENT NUMBER OF PIC SHAREABLE IMAGE ISECTS
				.cluster[clu$l_nisects];
	end;
    if not .basedmsgout
    then begin
	basedmsgout = true;
	signal(lin$_basduerrs);				! TELL USER HIS IMAGE JUST GOT NAILED DOWN
	end;
    lnk$gl_ctlmsk[lnk$v_lbased] = true;			! FLAG WE HAVE BASED THE WORLD
    lnk$gl_ctlmsk[lnk$v_picimg] = false;		! IMAGE IS NOT PIC ANY MORE
    end;
return false
end;							! OF BASEALLIMAGES

routine checkshrsym (symbolblock) =
begin
!
! 	THIS ROUTINE CHECKS THAT THE SYMBOL POINTED TO BY SYMBOLBLOCK
!	IS NOT FROM A SHAREABLE IMAGE.  IF IT IS, AN ERROR MESSAGE IS
!	ISSUED, SINCE THE SYMBOL WAS NOT REFERENCED POSITION INDEPENDENTLY.
!	THEN, AN ATTEMPT IS MADE TO ALLOCATE MEMORY FOR THE CLUSTER, SO THAT
!	THIS REFERENCE CAN BE RESOLVED.
!
map
    symbolblock : ref block[,byte];

local
    symsnb : ref block[,byte];

if .symbolblock neq 0
then begin
    if not .stapx
	and .symbolblock[sym$v_gref]
    then begin
	symsnb = .symbolblock - .symbolblock[sym$b_namlng] - snb$c_fxdlen;
	baseallimages();
	signal(lin$_shrsymref,5,symsnb[snb$b_namlng],
		lnk$gl_curpsc[psc$b_namlng],(.lnk$gl_locn-.curpsectbase),
		obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename]);
	return false
	end
    else if .stapx
	and .symbolblock[psc$v_shrimg]
    then begin
	baseallimages();
	signal(lin$_shrpscref,5,symbolblock[psc$b_namlng],
		lnk$gl_curpsc[psc$b_namlng],(.lnk$gl_locn-.curpsectbase),
		obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename]);
	return false
	end
    end;

return true
end;

routine setaddressref (cludesc, isdesc, locn) =
begin
!
! THIS ROUTINE STORES INFO NECESSARY FOR .ADDRESS FIXUPS.  IT STORES THE
! LOCATION (GIVEN BY ARGUMENT LOCN) TO BE FIXED UP IN THE .ADDRESS FIXUP
! INFO FOR THE GIVEN CLUSTER.
!
! INPUTS:
!
!	CLUDESC		ADDRESS OF CLUSTER DESCRIPTOR FOR TARGET OF REFERENCE
!	ISDESC		ADDRESS OF ISECT DESCRIPTOR WHERE REF IS STORED
!	LOCN		LOCATION OF REF
!
map
    cludesc : ref block[,byte],
    isdesc : ref block[,byte];

local
    adrblock : ref vector[,long];

bind
    lastblock = cludesc[clu$l_lstadrl] : ref vector[,long];

adrblock = .lastblock;				! POINT AT CURRENT BLOCK
if .cludesc[clu$l_adrleft] eql 0		! IF BLOCK IS EMPTY
then begin
    lnk$alloblk(clu$c_adrblock*4,adrblock);	! ALLOCATE ANOTHER BLOCK
    lastblock[0] = .adrblock;			! LINK INTO THE LIST
    cludesc[clu$l_lstadrl] = .adrblock;		! MAKE IT THE NEW LAST BLOCK
    adrblock[0] = 0;				! MAKE IT THE END OF THE LIST
    cludesc[clu$l_adrleft] = clu$c_adrblock-1;	! SET COUNT OF SLOTS LEFT IN BLOCK
    end;
adrblock[clu$c_adrblock - .cludesc[clu$l_adrleft]] ! SET LOCATION IN BLOCK
				= .locn;
cludesc[clu$l_adrleft] = .cludesc[clu$l_adrleft] -1; ! COUNT ONE LESS IN BLOCK
if .cludesc[clu$l_adrcnt] eql 0			! IF THIS IS FIRST REF TO THIS CLUSTER
    then lnk$gl_shradr = .lnk$gl_shradr + 1;	!  THEN COUNT ANOTHER CLUSTER
cludesc[clu$l_adrcnt] = .cludesc[clu$l_adrcnt] + 1; ! COUNT REF IN THIS CLUSTER
lnk$gl_adrefs = .lnk$gl_adrefs + 1;		! COUNT THE REFERENCE
if .isdesc neq 0				! ENSURE THERE IS AN ISECT
then begin
    bind
	curhdrisd = isdesc[isl$t_hdrisd]	! PART FOR HEADER
				 : block[,byte];

    if not .curhdrisd[isd$v_crf]		! SECTION MUST BE CRF
    then begin
	curhdrisd[isd$v_crf] = true;		! MAKE IT CRF
	if not .curhdrisd[isd$v_wrt]
	then begin
	    curhdrisd[isd$v_wrt] = true;	! MAKE SECTION WRITEABLE
	    lnk$gl_curisd[isl$b_newprt] = prt$c_ur; ! TELL IACT TO MAKE IT RO LATER
	    lnk$gl_curisd[isl$v_reprot] = true;	! FLAG SECTION NEEDS REPROTECTING
	    lnk$gl_rprotisd = .lnk$gl_rprotisd + 1; ! COUNT THE REPROTECTION
	    end;
	end;
    end;

return true
end;

routine compare_spcr (value,node) =
begin
!
! COMPARE A VALUE WITH CURRENT NODE
!
map
    node : ref block[,byte];

return (.value - .node[spcr$l_offset])
end;

routine alloc_spcr (value,retadr) =
begin
!
! ALLOCATE A NEW SPCR BLOCK
!
map
    retadr : ref vector[,long];

local
    entry : ref block[,byte];

lnk$alloblk(spcr$c_size,entry);			! ALLOCATE NEW BLOCK
entry[spcr$l_offset] = .value;			! SET OFFSET IN IMAGE
entry[spcr$l_fixadr] = .lnk$gl_lastgadr;	! SET FIXUP VECTOR VA
lnk$gl_lastgadr = .lnk$gl_lastgadr + 4;		! UPDATE VA FOR NEXT
lnk$gl_spcgfix = .lnk$gl_spcgfix + 1;		! COUNT ANOTHER SPECIAL FIXUP
retadr[0] = .entry;				! RETURN VALUE TO CALLER

return true
end;

routine storecommand : tir_proc =
begin
external register
    commandtype = 11 : byte,
    commandata  = 10 : ref block [,byte],
    datalng 	= 9 ;

local
    stocmdindex,					! INDEX INTO THE GROUP
    correctvalue,					! CORRECTED STORE VALUE
    outputaddr,						! ADDRESS OF OUTPUT STREAM
    mbzmask,						! MASK COMPUTED TO CORRECT THE VALUE
    outbytecount,					! NUMBER OF BYTES TO WRITE OUT
    lowestmbzbit,					! FOR COMPUTING MBZ FIELDS
    repeatcount,					! STORE REPEATED COUNTS
    outputarray : vector [5, byte] ;			! OUTPUT DATA

bind
    value = outputarray [1] ;				! LEAVE ONE BYTE FOR ADDRESSING MODE

stocmdindex  = .commandtype - tir$c_minstocod ;			! CREATE USEFUL INDEX
outbytecount = .storectltbl [.stocmdindex,stoctl$b_bytes] ;	! GET OUTPUT BYTE COUNT

if (.storectltbl [.stocmdindex,stoctl$b_flags]			! IF THIS IS A
    and 
    stoctl$m_rep
   ) neq 0				! REPEATED STORE,
then begin
     if not pop (repeatcount,pdl)				! GET TOP OF STACK
     then return false ;					! GIVING UP ON ERROR
     end
else repeatcount = 1 ;						! NO REPEAT, SO SET TO 1.

if  .commandtype eql tir$c_sto_rivb				! IF THIS IS STOREPEATED IMMEDIATE VAR. NO. BYTES
then begin							! PROCESS IT NOW
     bind  databytes = tirrec [.tiroffset+1] : vector [,byte] ; ! NAME THE DATA PART

     outbytecount = .databytes [0] ;				! GET THE OUTPUT BYTE COUNT
     datalng      = .outbytecount + 1 ;				! FIGURE LENGTH OF RECORD NEEDED TO BE THERE
     shrimgsym    = stapx = shrsymexpr = 0 ;			! 

     return (if (.outbytecount+databytes [1]) gtru .endrecaddr 	! IF RECORD IS TOO SHORT
	     then report_tirlng  ()
	     else lnk$wrtimgbyts (.outbytecount,databytes [1]	! OTHERWISE, RETURN, WRITING THE BYTES TO THE IMAGE
				 ,.repeatcount			! THE NUMBER OF TIMES SPECIFIED
				 )
	     ) ;
     end ;

if not pop (value,pdl)						! ATTEMPT TO GET
then return false ;						! VALUE TO BE STORED

if (.pdl neq 0							! IF POSITION-DEPENDENT
     or 
    (not .stapx and (.shrimgsym neq 0) and .shrimgsym [sym$v_gref])
   )
   and .commandtype neq tir$c_sto_picr				!  AND COMMAND IS NOT STORE PIC CODE
   and .commandtype neq tir$c_sto_pidr				!  OR STORE PIC DATA REFERERNCE
   and not .lnk$gl_ctlmsk [lnk$v_ubased]			!  AND IMAGE NOT BASED BY USER
then begin
     if not checkshrsym (.shrimgsym)				! THEN CHECK CORRECTNESS OF REFERENCE
     then value = (if not .stapx
		   then (.shrimgsym [sym$l_value] + .absexpr)	! IF RELOCATED, USE NEW VALUE
				   				!  BUT DON'T FORGET THE REST OF THE EXPRN
		   else 0					!**??**
		  )
     else if  .pdl eql 1					! IF POS DEP LEVEL IS 1
	  and     .lnk$gl_ctlmsk [lnk$v_shr]			! AND CREATING SHR IMAGE
	  and not .lnk$gl_ctlmsk [lnk$v_ubased]
	  and  .commandtype neq tir$c_sto_pirr
	  and (.commandtype lssu tir$c_sto_bd			! AND COMMAND IS NOT STORE DISPLACED
		or 
	       .commandtype gtru tir$c_sto_ld			!  OF BYTE, WORD, OR LONGWORD
	       )
	  then	begin
		baseallimages () ;					! THEN BASE EVERYTHING
		signal	(lin$_nonpicref,4,lnk$gl_curpsc [psc$b_namlng]	! THEN THAT IS AN ERROR
			,(.lnk$gl_locn-.curpsectbase)
			,obmodesc [omd$b_namlng]
			,lnk$gl_curfil [fdb$q_filename]
			) ;
		end ;
     stapx = shrimgsym = shrsymexpr = absexpr = 0 ;		! CLEAR OUT SHR IMG VARIABLES
     end ;

if (.storectltbl [.stocmdindex,stoctl$b_flags] and stoctl$m_displ) neq 0	! IF A DISPLACEMENT COMMAND
then begin
     if  .pdl eql 0 
     and .lnk$gl_ctlmsk [lnk$v_shr] 				! then can't have non-relocatable
     and .lnk$gl_ctlmsk [lnk$v_picimg]				!  references stored in pic images
     and not .flags [flg$v_undef]				! (special case undefined syms - act like non-rel refs)
     then signal (lin$_stdispic, 4, lnk$gl_curpsc [psc$b_namlng]
		 ,(.lnk$gl_locn - .curpsectbase)
		 ,obmodesc [omd$b_namlng]
		 ,lnk$gl_curfil [fdb$q_filename]
		 ) ;
								! subtract current location counter and
     value = .value - .lnk$gl_locn - .outbytecount ;		!   output byte count
     end ;

lowestmbzbit = .storectltbl [.stocmdindex,stoctl$v_mbzbit] ;	! GET NUMBER OF LOWEST

if (.storectltbl [.stocmdindex,stoctl$b_flags] 
     and 
    stoctl$m_conmbz
   ) neq 0							! BIT WHICH MUST BE ZERO
then if .value <.lowestmbzbit,1,0> neq 0			! IF A CONDITIONALLY MBZ
     then lowestmbzbit = 0 ;					! FIELD, SUPPRESS MBZ IF VALUE IS NEGATIVE

if  .lowestmbzbit eql 0						! IF THERE IS NOT AN MBZ FIELD
then correctvalue = .value < 0,min (32,8*.outbytecount),1>	! CORRECT VALUE IS SIGN EXTENSION
else begin							! OF THE FIELD TO BE WRITTEN
     mbzmask = (1^.lowestmbzbit) -1 ;				! OTHERWISE, MASK VALUE TO GET CORRECT
     correctvalue = .value and .mbzmask ;			! ONE
     end ;

if  .value neq .correctvalue					! IF VALUE DOES NOT MATCH
then begin
     signal (lin$_trunc, 4					! NOT MATCH THE CORRECT VERSION
	    ,lnk$gl_curpsc [psc$b_namlng]
	    ,(.lnk$gl_locn - .curpsectbase)			 ! ISSUE TRUNCATION ERROR
	    ,obmodesc [omd$b_namlng]
	    ,lnk$gl_curfil [fdb$q_filename]
	    ,lin$_truncdat, 3					! GIVING MODULE, PSECTION,
	    ,.value, .correctvalue				! OFFSET, THEN COMPUTED VALUE,
	    ,.lnk$gl_locn					! WRITTEN VALUE AND VIRTUAL ADDRESS
	    ) ;
     value = .correctvalue ;					! GET THE CORRECT VALUE
     end ;

if .commandtype eql tir$c_sto_vps				! STORE VARIABLE POSITION AND SIZE
then begin
     local	vpspos,
		vpssiz ;

     datalng = 2 ;
     if tirrec [.tiroffset+2] gtru .endrecaddr			! MUST HAVE TWO MORE BYTES FOR COMMAND
								!% missing dot?
     then return report_tirlng () ;

     vpspos = .tirrec [.tiroffset+1] ;				! GET POSITION
     vpssiz = .tirrec [.tiroffset+2] ;				! AND SIZE

     if .vpspos+.vpssiz gequ 32					! CHECK LEGAL
     or .vpspos+.vpssiz gtru ((.vpspos+8)/8*8)
     then begin
	  signal (lin$_illvps, 4, .vpspos, .vpssiz
		 ,obmodesc [omd$b_namlng]
		 ,lnk$gl_curfil [fdb$q_filename]
		 ) ;
	   return false
	   end
     else return lnk$wrtimgbyts (1,.value,1,.vpspos,.vpssiz) ;
     end ;

if  .commandtype eql tir$c_sto_pirr				! STORE POSITION INDEPENDENT RELATIVE REFERENCE
then begin
     local	value2,
		pdl2 ;

     if not pop (value2, pdl2)					! POP THE RELATIVE LOCATION
     then return false ;					! BUT IF AN ERROR, GIVE UP

     if (.pdl2 neq 0						! IF POS DEP VALUE
	 or 
	 (not .stapx and (.shrimgsym neq 0) and .shrimgsym [sym$v_gref])
	 )
	 and not .lnk$gl_ctlmsk [lnk$v_ubased]
     then begin
	  if not checkshrsym (.shrimgsym)
	  then value2 = (if not .stapx
			 then .shrimgsym [sym$l_value]
			 else 0
			)
	  else	if  .pdl2 eql 1
		and     .lnk$gl_ctlmsk [lnk$v_shr]
		and not .lnk$gl_ctlmsk [lnk$v_ubased]
		then begin
		     baseallimages () ;				! BASE THE WORLD
		     signal (lin$_nonpicref, 4
			    ,lnk$gl_curpsc [psc$b_namlng]
			    ,(.lnk$gl_locn-.curpsectbase)
			    ,obmodesc [omd$b_namlng]
			    ,lnk$gl_curfil [fdb$q_filename]
			    ) ;
		     end ;
	   end ;

     if .value2 eql -1 then value2 = .lnk$gl_locn ; 		! SUBSTITUTUE CURRENT LOC. FOR -1
     if .pdl neq 0     then value  = .value - .value2 ;		! RELOCATE VALUE IF CALLED FOR.
     end ;

if  .commandtype neq tir$c_sto_picr				! IF THIS IS NOT A STORE POS. IND. CODE OR DATA REF
and .commandtype neq tir$c_sto_pidr
then outputaddr = outputarray [1]				! THEN SET THE OUTPUT POINTER
else if .commandtype eql tir$c_sto_pidr				! IF A STORE PIC DATA REF
     then begin
	  bind  symclu = (if .stapx 				! NAME THE CLUSTER THAT REF. IS IN
			  then shrimgsym [psc$l_cludsc]	
			  else shrimgsym [sym$l_cludsc]
			  ) : ref block [,byte] ;

	  outputaddr = outputarray [1] ;			! FOUR BYTES GO
	  if .pdl neq 0						! IF NON-PIC DATA REFERENCE
	  and not .lnk$gl_ctlmsk [lnk$v_dbgrec]			!  AND NOT IN A DEBUG RECORD
	  then  begin
		if begin
		   if  .lnk$gl_ctlmsk [lnk$v_shr]		! OTHERWISE IF CREATING A SHAREABLE IMAGE
		   then begin
			if  .lnk$gl_ctlmsk [lnk$v_picimg]	!  AND IT'S A PIC IMAGE
			then begin
			     if .lnk$gl_curisd eql 0		! IF NO ISECT
			     then true
			     else begin
				  bind   curhdrisd = lnk$gl_curisd [isl$t_hdrisd] : block [,byte] ;

			    	  if         .curhdrisd [isd$v_wrt]		! IF SECTION IS WRITEABLE
				     and not .curhdrisd [isd$v_crf]	!  BUT NOT COPY ON REF (IE SHAREABLE SECTION)
				  then	begin
				  	baseallimages () ;			! BASE THE WORLD
					signal	(lin$_adrwrtdat, 4		! TELL USER IMAGE ABOUT .ADDRESS DATA IN COMMON
				   		,lnk$gl_curpsc [psc$b_namlng]
						,(.lnk$gl_locn-.curpsectbase)
						,obmodesc [omd$b_namlng]
						,lnk$gl_curfil [fdb$q_filename]
						) ;
					false
					end
			    	  else true
				  end
			     end
			else (    not .lnk$gl_ctlmsk [lnk$v_lbased]	! IF NON-PIC, DON'T DO FIXUP IF WORLD GOT BASED
			      and not .lnk$gl_ctlmsk [lnk$v_ubased]	! OR IF BASED FOR ANY OTHER REASON (BY USER, PERHAPS)
			      and ( (.shrimgsym neq 0)			!  IF THAT ISN'T TRUE, ONLY DO FIXUP IF
					and not .symclu [clu$v_based]		! TARGET CLUSTER IS NOT BASED
			      )   )
			end
		   else (    .shrimgsym neq 0				! EXECUTABLE IMAGE...DO ONLY IF REFERENCE
			 and .symclu neq .lnk$gl_curclu			! IS TO SYMBOL IN ANOTHER CLUSTER
			 and .symclu [clu$v_shrimg]			!  THAT IS A SHAREABLE IMAGE
			 and not .symclu [clu$v_based]			!    AND IS NOT BASED
			)						!% check that (,) removal maintained logic
		   end 
		then begin
		     if not .stapx					! IF IT WAS NOT STA_PX
		     and (.shrimgsym neq 0)				!  IE IT WAS STA_GBL
		     and (.shrsymexpr eql 0)				!  AND NOT AN EXPRESSION
		     and .shrimgsym [sym$v_rel]				! OF A RELOCATABLE SYMBOL
		     and .shrimgsym [sym$v_gref]			! FROM A SHAREABLE IMAGE
		     then value = .shrimgsym [sym$l_offset] ;		!   THEN GET VALUE OF SHR IMG SYMBOL OFFSET

		     setaddressref (.symclu,.lnk$gl_curisd,.lnk$gl_locn) ;	! STORE FIXUP INFORMATION

		     if  .lnk$gl_ctlmsk [lnk$v_long]			! IF GETTING A FULL MAP
		     then begin						!  THEN COUNT THE .ADDRESSES
			  if .obmodesc [omd$l_adrcnt] eql 0		! IF THIS IS FIRST .ADDRESS IN THIS MODULE
			  then	begin
				local  lastomd : ref block [,byte] ;

				lnk$gl_nadromd = .lnk$gl_nadromd + 1 ;	! COUNT ANOTHER MODULE WITH .ADDRESS
				lastomd        = .lnk$gl_omdadrend ;	! GET POINTER TO LAST MODULE IN LIST

				if  .lastomd eql 0			! IF NONE, THEN INSERT AT FRONT OF LIST
				then lnk$gl_omdadrlst       = .obmodesc
				else lastomd [omd$l_nxtadr] = .obmodesc;! OTHERWISE, INSERT AT END OF LIST

				lnk$gl_omdadrend = .obmodesc ;		! SET NEW END OF LIST
				end ;
			  obmodesc [omd$l_adrcnt] = .obmodesc [omd$l_adrcnt] + 1 ; ! COUNT THE .ADDRESS IN THIS MODULE
			  end ;
		     end ;
	        end
	  end
     else 
	!
	!  PROCESS TIR$C_STO_PICR (STORE POS. IND. CODE REF)
	!
	begin
	bind symclu  =	(if .stapx 				! NAME THE CLUSTER DESCRIPTOR
			 then shrimgsym [psc$l_cludsc]
			 else shrimgsym [sym$l_cludsc]
			) : ref block [,byte] ;

	outputaddr = outputarray [0] ;				! WE WILL BE SENDING A MODE BYTE ALSO
	if .pdl eql 0						! IF ABS. ADDRESSING 
	then outputarray [0] = absaddrmode			!  THEN SET THAT
	else
	    !
	    ! TARGET IS RELOCATABLE
	    !
	    begin	
	    if	.shrimgsym neq 0				! IF TARGET IS IN A SHR IMAGE
		  and 
		.symclu [clu$v_shrimg]
	    then begin
		 outputarray [0] = indpcreladdr ;		! USE "@L^" MODE
		 if .shrsymexpr neq 0				! IF TARGET IS AN EXPRESSION
		 or .stapx					!  OR A PSECT BASE + OFFSET
		 then begin
		      local  entry : ref block [,byte] ;

		      if .symclu [clu$l_spcrlst] eql 0		    ! IF THIS IS FIRST ONE FOR THIS CLUSTER
		      then lnk$gl_spcgimgs = .lnk$gl_spcgimgs + 1 ; ! THEN COUNT ANOTHER SHR IMG

		      if lib$insert_tree (symclu [clu$l_spcrlst]    ! INSERT INTO SPCR LIST FOR
					 ,.value, %ref (0)	    ! TARGET CLUSTER
					 ,compare_spcr
					 ,alloc_spcr, entry
					 ) 
			  eql lib$_normal 			! AND IF IT WAS INSERTED (NOT ALREADY THERE)
		      then setaddressref (.symclu, 0		! THEN SET A .ADDR FIXUP FOR THE LOC. IN FIXUP VEC
					 ,.entry [spcr$l_fixadr]
					 ) ;
		      value = .entry [spcr$l_fixadr] ;		! VALUE TO STORE IS VALUE IN FIXUP
		      end					! (TARGET IS EXPR OR STA_PX)
		 end						! (TARGET IS IN SHR IMG)
	    else outputarray [0] = pcreladdrmode ;		! NOT SHR IMAGE USE PC RELATIVE
	
	    value = .value-.lnk$gl_locn - .outbytecount ;	! PC RELATIVE (SO COMPUTE DISPLACEMENT
	    end							! (TARGET IS RELOCATABLE)
	end ;

shrimgsym = stapx = flags = shrsymexpr = absexpr = 0 ;		! CLEAR FLAGS
return lnk$wrtimgbyts (.outbytecount,.outputaddr,.repeatcount) ;! FINALLY OUTPUT BYTES
end ;


routine operatecommand : tir_proc =
begin
!
! PROCESS OPERATE GROUP COMMANDS
!
external register
    commandtype = 11 : byte,
    commandata = 10 : ref block[,byte],
    datalng = 9;

builtin
    rot;

local
    first_abs,
    second_abs,
    either_shr,
    cludesc : ref block[,byte],
    symdesc : ref block[,byte],
    symdscnam : ref block[,byte],	! NAME PART OF BLOCK
    value,
    value2,
    pdl2;

if .commandtype eql tir$c_opr_nop
    then return true;
if .commandtype eql tir$c_opr_redef			! IF THIS IS A RE-DEFINITION COMMAND
then begin						! FIRST VALIDATE THE TIR STREAM
    datalng = 1 + .commandata[symboleng];		! SET LENGTH OF DATA
    if (commandata[symboleng] +.datalng) gtru .endrecaddr ! CHECK ALL THERE
	then return report_tirlng();
    if .commandata[symboleng] gtru sym$c_maxlng		! CHECK LENGTH OF SYMBOL NAME
	or .commandata[symboleng] eql 0
	then return report_illnamlng(commandata[symboleng]);
    if not .lnk$gl_ctlmsk[lnk$v_shr]			! IF NOT PRODUCING A SHAREABLE IMAGE
	then return true;				! FORGET IT
    if not lnk$search(commandata[symboleng],symdesc,symdscnam) ! LOOK IT UP
	or not .symdesc[sym$v_def]			! CHECK IT FOR A DEFINITION
    then begin						! AND ISSUE ERROR MESSAGE IF NOT
	report_useundef(commandata[symboleng]);
	flags[flg$v_undef] = true ;
	return true					! AND FORGET IT
	end;
    if .symdesc[sym$v_redef]				! IF THE SYMBOL HAS A REDEF PENDING
    then begin
	signal(lin$_alredef,5,commandata[symboleng],
		lnk$gl_curpsc[psc$b_namlng],(.lnk$gl_locn-.curpsectbase),
		obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename]);
	return true
	end;
    symdesc[sym$l_newval] = .lnk$gl_locn;		! OTHERWISE SET ITS NEW VALUE
    symdesc[sym$v_redef] = true;			! SET REDEF PENDING
    symdesc[sym$v_uni] = true;				! AND MAKE IT UNIVERSAL
    cludesc = .lnk$gl_curpsc[psc$l_cludsc];		! GET POINTER TO CLUSTER DESCRIPTOR
    if .lnk$gl_curpsc[psc$v_rel]			! IF CURRENT PSECT IS RELOCATABLE
	and not .cludesc[clu$v_based]			!  IN A CLUSTER THAT IS NOT BASED
	then symdesc[sym$v_rerel] = true;		!  THEN MAKE SURE THAT SYMBOL IS RELOCATABLE (DONE IN LNK$SYMTBLOUT)
    if .lnk$gl_ctlmsk[lnk$v_mapopn]			! IF THERE WAS A MAP OPENED
	and not .lnk$gl_ctlmsk[lnk$v_brief]		! AND IT WAS NOT A BRIEF
	then crf$insrtkey(lnk$al_sytblfmt,symdscnam[snb$b_namlng], ! TELL CREF ABOUT NEW FLAGS
			symdesc[sym$l_value],.symdesc[sym$w_flags]);
    return true
    end;						! THAT'S ALL FOR REDEF
first_abs = true;
if not pop(value,pdl)					! FOR ALL OTHERS, GET TOP VALUE FROM STACK
    then return false;
if .shrimgsym neq 0
then 
    begin
    first_abs = false;
    if not .stapx
        and .shrimgsym[sym$v_gref]
        and .shrimgsym[sym$v_rel]
    then 
	begin
	value = .shrimgsym[sym$l_offset];
	shrsymexpr = .shrimgsym;
	end;
    end;
if .commandtype neq tir$c_opr_neg			! POP SECOND VALUE IF NOT NEGATE
    and .commandtype neq tir$c_opr_com			!  COMPLEMENT
    and .commandtype neq tir$c_opr_dflit		!  OR DEFINE LITERAL
then begin
    second_abs = true;
    if not pop(value2,pdl2)				! GET SECOND VALUE IF A BINARY
	then return false;				!  OPERATOR - ERROR IF NONE
    if .shrimgsym neq 0					! IF FROM SHR IMG
    then 
	begin
	if .shrsymexpr neq 0				! AND OTHER OPERAND WAS TOO
	    then signal(lin$_illshrxpr,3,		!  THEN THAT IS AN ERROR
			obmodesc[omd$b_namlng],.lnk$gl_record,
			lnk$gl_curfil[fdb$q_filename]);
	if not .stapx					! IF STA_GBL
	    and .shrimgsym[sym$v_gref]			! OF SHR IMG SYMBOL
	    and .shrimgsym[sym$v_rel]
	then 
	    begin
	    value2 = .shrimgsym[sym$l_offset];		! THEN USE THE OFFSET
	    shrsymexpr = .shrimgsym;			! AND REMEMBER THAT IT WAS
	    end;
	second_abs = false;
	end;
    end;

if .shrsymexpr neq 0					! IF ONE OPERAND IS FROM SHR IMG
    and .commandtype neq tir$c_opr_add			! ONLY ADD AND SUB ARE LEGAL
    and .commandtype neq tir$c_opr_sub
    then signal(lin$_illshropr,3,obmodesc[omd$b_namlng], ! ANYTHING ELSE IS ERROR
		.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);
either_shr = not (.first_abs and .second_abs);
!
! DISPATCH ON COMMAND
!
case .commandtype from tir$c_opr_add to tir$c_maxoprcod
of set
    [tir$c_opr_add] :
		begin
		    if .either_shr 			! IF THIS EXPRN IS PART OF A SHR IMG EXPRN
		    then
			begin
			if .first_abs			! IF FIRST VALUE WAS A CONSTANT
			then				!   ACCUMULATE IT
			    absexpr = .absexpr + .value;
			if .second_abs			! IF SECOND VALUE WAS A CONSTANT 
			then				!   ACCUMULATE IT
		 	    absexpr = .absexpr + .value2;
			end;
		    value = .value + .value2;	! ADD THE TWO VALUES
		    pdl = .pdl + .pdl2;		! AND THE TWO POS. DEP. LEVELS
		    true
		    end;
    [tir$c_opr_sub] :
		begin
		    if .either_shr 			! IF THIS EXPRN IS PART OF A SHR IMG EXPRN
		    then
			begin
			if .first_abs			! IF FIRST VALUE WAS A CONSTANT
			then				!   ACCUMULATE IT
			    absexpr = .absexpr - .value;
			if .second_abs			! IF SECOND VALUE WAS A CONSTANT 
			then				!   ACCUMULATE IT
		 	    absexpr = .absexpr - .value2;
			end;
		    value = .value2 - .value;	! SUBTRACT THE VALUES AND
		    pdl = .pdl2 - .pdl;		! AND POSITION DEPENDENCE LEVELS
		    true
		    end;
    [tir$c_opr_neg] :
		begin
		    value = -.value;
		    true
		    end;
    [tir$c_opr_com] :
		begin
		    value = -1 - .value;
		    true
		    end;
    [tir$c_opr_mul] :
		begin
		    value = .value*.value2;
		    true
		    end;
    [tir$c_opr_div] :
		begin
		    if .value neq 0			! CHECK FOR DIVIDE BY ZERO
			then value = .value2/.value;
		    true
		    end;
    [tir$c_opr_ior] :
		begin
		    value = .value or .value2;
		    true
		    end;
    [tir$c_opr_eor] :
		begin
		    value = (.value or .value2) and 
					not(.value and .value2);
		    true
		    end;
    [tir$c_opr_and] :
		begin
		    value = .value and .value2;
		    true
		    end;
    [tir$c_opr_rot] :
		begin
		    value = rot(.value2, .value);
		    true
		    end;
    [tir$c_opr_ash] :
		begin
		    value = .value2 ^ .value;
		    true
		    end;
    [tir$c_opr_sel] :
		begin
		    if .value eql true			! IF TOP LONGWORD IS
			then return true;		! IS TRUE, ALL DONE
		    value = .value2;			! OTHERWISE MOVE VALUE2
		    pdl = .pdl2;			! TO VALUE 3, DISCARDING
		    if not pop(value2,pdl2)		! WHAT EVER WAS THERE
			then return false;		! BUT CHECK SOMETHING WAS
		    end;
    [tir$c_opr_dflit] :
		begin
		    local
			entry : ref block[,byte],
			litindex;

		    datalng = 1;
		    if (.commandata + .datalng) gtru .endrecaddr
			then return report_tirlng();
		    litindex = .commandata[0,0,8,0];
		    lib$insert_tree(lnk$gl_litbl,.litindex,		!INSERT INTO TREE
				%ref(0),compare_lit,alloc_lit,entry);
		    entry[lit$v_pdl] = .pdl;
		    entry[lit$v_stapx] = .stapx;
		    entry[lit$b_index] = .litindex;
		    entry[lit$l_shrsym] = .shrimgsym;
		    entry[lit$l_shrexpr] = .shrsymexpr;
		    entry[lit$l_value] = .value;
		    lnk$gl_litflgs[.litindex] = true;
		    return true
		    end;
    [inrange] :
		return report_illtir2();
    tes;

return push(.value,-1,.pdl)

end;

routine compare_dli (value,node) =
begin
!
! COMPARE A VALUE WITH CURRENT NODE
!
map
    node : ref block[,byte];

return (.value - .node[dli$l_index])
end;

routine alloc_dli (value,retadr) =
begin
!
! ALLOCATE A NEW DLI BLOCK
!
map
    retadr : ref vector[,long];

lnk$alloblk(dli$c_size,retadr[0]);
return true
end;

routine controlcommand : tir_proc =
begin
!
! PROCESS CONTROL COMMANDS
!
external register
    commandtype = 11 : byte,
    commandata = 10 : ref block[,byte],
    datalng = 9;

local
    value;

case .commandtype from tir$c_ctl_setrb to tir$c_maxctlcod
of set
    [tir$c_ctl_setrb] :						! PROCESS SETTING OF RELOCATION BASE
	begin
	    if (lnk$gl_curpsc = .psectstack[.stackpointer,0]) eql 0	! SET POINTER TO CURRENT P-SECTION
	    then begin						! DESCRIPTOR AND IF ZERO
		signal(lin$_notpsect,2,				! REPORT AS FATAL ERROR
			obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename]);
		return false;
		end
	    else lnk$gl_curisd = .lnk$gl_curpsc[psc$l_isect];		! SET CURRENT ISD ADDRESS
	    curpsectbase = .psectstack[.stackpointer,1];		! SET BASE OF THIS MODULES CONTRIBUTION
	    if not pop (value,pdl)					! GIVE UP IF THAT FAILS
		then return false;
	    stapx = shrimgsym = shrsymexpr = 0;
	    lnk$gl_locn = .value;					! OTHERWISE SET IT
	    end;

    [tir$c_ctl_augrb] :						! PROCESS AUGMENTS TO RELOCATION BASE
	begin
	    datalng = 4;						! FOUR BYTES OF DATA
	    if (commandata[longword] + .datalng) gtru .endrecaddr	! CHECK THE INCREMENT EXISTS
		then return report_tirlng();
	    lnk$gl_locn = .lnk$gl_locn + .commandata[longword];	! IF AUGMENT, DO THAT
	    end;

    [tir$c_ctl_dfloc,
    tir$c_ctl_stkdl,
    tir$c_ctl_stloc] :							! TBK/DBG LOCATION COUNTER CONTROL
	begin
	    local
		entry : ref block[,byte];

	    if not .lnk$gl_ctlmsk[lnk$v_dbgrec]				! MUST BE IN DEBUG TYPE RECORD
	    then begin
		signal_stop(lin$_illtir,4,				! REPORT ILLEGAL TIR TYPE
			.commandtype,obmodesc[omd$b_namlng],
			.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);
		return false;
		end
	    else if not pop(value,pdl)						! OTHERWISE POP THE INDEX
		or .pdl neq 0							! AND IF THAT FAILS OR INDEX NOT ABSOLUTE
		then return false
		else begin							!
		    if .commandtype eql tir$c_ctl_dfloc				! IF THIS IS DEFINE LOCATION
		    then begin
			lib$insert_tree(obmodesc[omd$l_dlilst],.value,		! INSERT INTO TREE
					%ref(0),compare_dli,alloc_dli,entry);
			entry[dli$l_index] = .value;
			entry[dli$l_loc] = .lnk$gl_locn;
			end
		    else begin							! STKDL OR STLOC
			if not lib$lookup_tree(obmodesc[omd$l_dlilst],
					.value,compare_dli,entry)
			then begin
			    signal(lin$_illtir,4,.commandtype,obmodesc[omd$b_namlng],
				.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);
			    return false
			    end;
			if .commandtype eql tir$c_ctl_stloc
			    then lnk$gl_locn = .entry[dli$l_loc]
			    else return push(.entry[dli$l_loc],-1,0);
			end;
		    end;
		end;
	  [inrange] : return report_illtir2();
	tes;

return true
end;

routine protirdbg =
begin
!
!	PROCESS TIR, DBG AND TRACEBACK RECORDS
!
!
psect plit = $code$;

bind
    tirdisptable = uplit(					! TIR DISPATCH TABLE
			rep tir$c_maxstacod+1			! STACK   COMMANDS
				of word(stackcommand-protirdbg),

			%if tir$c_minstocod-tir$c_maxstacod-1 neq 0
			%then
			    rep tir$c_minstocod-tir$c_maxstacod-1	! ILLEGAL COMMANDS
				of word(report_illtir-protirdbg),
			%fi

			rep tir$c_maxstocod-tir$c_minstocod+1		! STORE COMMANDS
				of word(storecommand-protirdbg),

			%if tir$c_minoprcod-tir$c_maxstocod-1 neq 0
			%then
			    rep tir$c_minoprcod-tir$c_maxstocod-1	! ILLEGAL COMMANDS
				of word(report_illtir-protirdbg),
			%fi

			rep tir$c_maxoprcod-tir$c_minoprcod+1		! OPERATE COMMANDS
				of word(operatecommand-protirdbg),

			%if tir$c_minctlcod-tir$c_maxoprcod-1 neq 0
			%then
			    rep tir$c_minctlcod-tir$c_maxoprcod-1	! ILLEGAL COMMANDS
				of word(report_illtir-protirdbg),
			%fi

			rep tir$c_maxctlcod-tir$c_minctlcod+1		! CONTROL COMMANDS
					of word(controlcommand-protirdbg)
			) 
				: vector[,word,signed];

psect plit = $plit$;

global register
    commandtype = 11 : byte,
    commandata  = 10 : ref block[,byte],
    datalng     =  9;

tiroffset  = 1;						! START AT FIRST BYTE PAST RECORD TYPE CODE
endrecaddr = tirrec[0] + .reclng;			! COMPUTE END ADDRESS + 1
while .tiroffset lssu .reclng
do begin
   !
   !	STEP THROUGH THE CONCATENATED SEQUENCE OF THE COMMANDS
   !	IN THIS RECORD.
   !
   if (commandtype = .tirrec[.tiroffset]) gtru 127
   then	begin
	!
	! COMMAND IS A STORE IMMEDIATE
	!
	tiroffset = .tiroffset+1;					! POINT PAST THE BYTECOUNT
	datalng   = 256 -.commandtype;

	if tirrec[.tiroffset + .datalng] gtru .endrecaddr		! CHECK THERE ARE ARE ENOUGH BYTES IN THE RECORD
	then return report_tirlng();

	if not lnk$wrtimgbyts(.datalng,tirrec[.tiroffset],1)		! OTHERWISE WRITE THE STREAM
	then return false;

	tiroffset = .tiroffset + .datalng;				! AND UPDATE THE OFFSET INTO THE RECORD
	end
   else	begin
	!
	! COMMAND IS OTHER THAN STORE IMMEDIATE COMMAND
	!
	commandata = tirrec[.tiroffset+1];				! POINT TO DATA PART OF COMMAND
	datalng    = 0;
	if not (if .commandtype gtru tir$c_maxctlcod
		then report_illtir2()
		else begin
		     bind routine
				recordprocessor = .tirdisptable[.commandtype] + protirdbg : tir_proc;

		     recordprocessor()
		     end
		)
	then return false
	else tiroffset = .tiroffset + 1 + .datalng;
	end;
   end;

return true
end;

routine prohdrs =
begin
!
!	PROCESS HEADER RECORDS AS FOLLOWS:
!
!		IF HEADER TYPE 0 (MAIN MODULE HEADER) CALL THE MAP
!			ROUTINE THAT DESCRIBES A MODULE.
!
!		IF A LANGUAGE PROCESSOR HEADER TYPE, CALL THE MAP
!			ROUTINE THAT OUTPUTS THAT DATA.
!
!		IGNORE ALL OTHER SUB-TYPES.
!
if not  .obmodesc [omd$v_mapmod]				! IF MODULE NOT FLAGGED FOR MAP
and not .lnk$gl_ctlmsk [lnk$v_long]				! AND THIS IS NOT A FULL MAP
then return true;						! FORGET IT

if not .lnk$gl_ctlmsk [lnk$v_mapopn]				! ALSO FORGET IT IF
then return true;						! MAP IS NOT OPEN

if  .objrec [obj$b_subtyp] eql obj$c_hdr_mhd			! IF THIS IS MAIN HEADER
then lnk$mapmhd (.objrec,.obmodesc)				! GO MAP SOME INFO
else if  .objrec [obj$b_subtyp] eql obj$c_hdr_lnm		! OR IF THE COMPILER IDENTIFICATION
     then lnk$maplng (objrec [obj$b_subtyp]+1,.reclng-2);	! HEADER GO MAP THAT DATA

return true							! RETURN SUCCESS
end;

routine construct_dmt = 
begin
!
!
!    This routine manufactures Debugger Module/Psect Table (DMT)
!    entries.  There is an entry for each object module that
!    contributes to the DST.  The format of the DMT is illustrated
!    below.
!
!    For each object module with a non-0 DST contribution,
!
!    ---------------------------------------------------
!    | Offset into DST of this module's contribution   |	(longword)
!    ---------------------------------------------------
!    | Length of this module's DST contribution        |	(longword)
!    ---------------------------------------------------
!    | Number of non-0-length psects in this module    |	(longword)
!    ---------------------------------------------------
!
!	Then, for each of the above psects in this object module, 
!
!	---------------------------------------------------
!	| Base of this module's contribution to the psect |	(longword)
!	---------------------------------------------------
!	| Length of this module's cont. to the psect      |	(longword)
!	---------------------------------------------------
!
!    
!    The maximum size of the DMT is calculated by multiplying the number 
!    of modules by the length of the module part of the DMT (12 bytes), 
!    and adding that quantity to the value obtained by multiplying the 
!    total number of psects with the length of the psect part (8 bytes).  
!    However, the size of the DMT may be adjusted downward in numerous ways.  
!    Among those situations requiring a change in size are 1) no psect 
!    entries are made for 0-length psect contributions, and 2) no module 
!    entries are made for modules with no DST contribution.
!
!    The offset into the DST of a modules DST contribution is obtained 
!    from the value of lnk$gl_dstlocn (DST location counter) at the
!    time the first DBG or TBT record is encountered for a module.
!    The length is obtained by subtracting the DST offset of the previous
!    module from the DST offset of the current module's contribution.
!
!    The psect information is available from the MPC blocks, which used to
!    be mostly for psect output in the linker map.
!
local
    zero_length_psect,			! Logical flag
    curomdptr: ref block[,byte];	! Ptr to start of data for current module

dmtptr[dcm$l_dstoff] = .lnk$gl_dstlocn;			! Start of this module's cont. to DST
dmtptr[dcm$w_numpsc] = .obmodesc[omd$w_hipsct] + 1;	! Initial number of psects for the module
curomdptr = .dmtptr;					! Save ptr to start of data for this objmod

if .prev_dstlen_addr neq 0				! If prev_dstlen_addr has been initialized...
then
    begin									 	!  then compute dstlen, based
    if (.prev_dstlen_addr = .dmtptr[dcm$l_dstoff] - .(.prev_dstlen_addr - 4)) eql 0	!  on difference of dstoffs
    then								! If the last module didn't contribute any to
	begin								!  the DMT, then adjust lnk$gl_dmtbytes;
	lnk$gl_dmtbytes = .lnk$gl_dmtbytes -				!  reset dmtptr and curomdptr back to the  
				(.dmtptr - (.prev_dstlen_addr - 4));	!  position of the previous module entry
	dmtptr = .prev_dstlen_addr - 4;
	curomdptr = .dmtptr;
	end;
    end;

prev_dstlen_addr = dmtptr[dcm$l_dstlen];			! Save address of dstlen for current module

if (.dmtptr+dcm$c_size) gtr .lnk$gl_dmtbuffer[1]		! If we'll end up past the end of the allocated
then								!  memory, something's amiss -- quit writing
    begin
    dmtptr = 0;						   	!  the DMT...
    return true;						!  and return
    end
else
    begin							! Otherwise, everything's cool...
    dmtptr = .dmtptr + dcm$c_size;				! Adjust pointer to psect data part
    incr i from 0 to .obmodesc[omd$w_hipsct] do			! Take a peek at each psect in this module...
	begin
	local pscdsc : ref block[,byte];
	pscdsc = fndpscmapent( .i );				! Set up psect info...
	pscdsc = .pscdsc[pmt$l_pscdes];
	if .dmtptr neq 0
	then
	    begin
	    local mpcblk : ref block[,byte];
	    mpcblk = .pscdsc[psc$l_mpclst];			! Set up MPC info for the psect...
	    while .mpcblk neq 0 do
		begin
		if .mpcblk[mpc$l_ownomd] eql .obmodesc			! Is this psect owned by this objmod?
		then
		    if .mpcblk[mpc$l_length] neq 0			! If it's a non-0-length psect
		    then
			begin
			dmtptr[dcp$l_base] = .pscdsc[psc$l_base] +	!  then write it's base...
						.mpcblk[mpc$l_offset];
			dmtptr[dcp$l_length] = .mpcblk[mpc$l_length];	!  and length to the DMT
			zero_length_psect = false;			! Yes, it was a valid psect
			exitloop;					!  (i.e., non-0 length)
			end
		    else
			begin
			curomdptr[dcm$w_numpsc] = .curomdptr[dcm$w_numpsc] - 1;	! 0-length, so lower the
			zero_length_psect = true;				!  count of psects by 1
			lnk$gl_dmtbytes = .lnk$gl_dmtbytes - dcp$c_size;	!  and adjust lnk$gl_dmtbytes
			exitloop;						!  accordingly.
			end;
		mpcblk = .mpcblk[mpc$l_nxtmpc];
		end;  						! of WHILE loop
	    if (.dmtptr+dcp$c_size) gtr .lnk$gl_dmtbuffer[1]	! If we're going to end up past the end
	    then						!  of our allocated space for the DMT,
		begin						!  then something's wrong -- stop
		dmtptr = 0;					!  manufacturing it
		return true;					!  and return
		end
	    else 
		if not .zero_length_psect			! If we got a good psect, then 
		then						!  move the pointer to the position
		    dmtptr = .dmtptr + dcp$c_size;		!  for the next psect
	    end;
	end;							! of INCR loop
    end;
return true
end;

global routine lnk$objpass2=
begin
!
!	MAIN ROUTINE TO READ RECORDS SEQUENTIALLY FROM OBJECT
!	MODULE FILES AND DISPATCH ON RECORD TYPE
!
own
    tirlocn;								! SAVED LOCATION IN IMAGE BINARY
local
    first_dbg_record,
    prevomd : ref block[,byte],						! PREVIOUS OBJ MOD DESCR
    auxfnb : ref block[,byte];

stackpointer = stk$c_size;						! SET STACK POINTER

if .lnk$gl_dmtbuffer[0] neq 0
then
    begin
    dmtptr = .lnk$gl_dmtbuffer[0];				! POINT TO BEGINNING OF TABLE
    prev_dstlen_addr = 0;
    end
else
    dmtptr = 0;

while lnk$nxtobjmod()							! WHILE THERE IS ANOTHER OBJECT MODULE
do begin
    first_dbg_record = true;
    obmodesc = .lnk$gl_curomd;
    lnk$gl_curomd[omd$l_dlilst] = 0;					! CLEAR DEBUG LIST (USED DURING PASS 1)
    ch$fill(0,lnk$c_nlits/8,lnk$gl_litflgs);				! UNDEFINE ALL LITERALS
    stapx = shrimgsym = shrsymexpr = 0;					! INITIALIZE DATA FOR SHR IMAGE CHECKING
    while lnk$nxtrec(objrecdesc)					! READ THE NEXT RECORD
    do begin
	case .objrec[obj$b_rectyp] from 0 to obj$c_maxrectyp		! AND DISPATCH ON THE RECORD TYPE
	of set
!
! HEADER RECORDS
!
	    [obj$c_hdr] :
			begin
			    prohdrs();					!  PROCESS THE HEADERS
			    if .objrec[obj$b_subtyp] eql obj$c_hdr_lnm 	! IF THIS IS THE CREATOR IDENT RECORD
				and .obmodesc[omd$v_nobin] 		!  OF A MODULE WITHOUT ANY BINARY
				then exitloop;				!  THEN ALL DONE WITH MODULE
			    end;
!
! TIR RECORDS
!
	    [obj$c_tir] :
			if .lnk$gl_ctlmsk[lnk$v_image]			! IF THE IMAGE FILE IS STILL OPEN
			then begin
			    lnk$gl_ctlmsk[lnk$v_dbgrec] = false; 	! RESET POSSIBLE DBG
			    lnk$gl_locn = .tirlocn;			! RECORD FLAG AND LOCATION
			    protirdbg();				! COUNTER AND PROCESS IT
			    tirlocn = .lnk$gl_locn;			! SAVE THE LOCATION COUNTER
			    end
			else exitloop;					! NO IMAGE FILE SO SKIP REST OF THIS MODULE
!
! DEBUG AND TRACEBACK RECORDS
!
	    [obj$c_dbg,obj$c_tbt] :
			begin
			    if not .lnk$gl_ctlmsk[lnk$v_image]		! IF NO IMAGE THEN QUIT NOW
			    then 
				exitloop;
			    if (.lnk$gl_ctlmsk[lnk$v_dbg]		! IF /DEBUG REQUESTED
				or (.lnk$gl_ctlmsk[lnk$v_trace]		!  OR /TRACE REQUESTED
				and (.objrec[obj$b_rectyp] eql obj$c_tbt))) ! AND THIS IS A TRACEBACK RECORD
				and not .lnk$gl_ctlmsk[lnk$v_sys]	! AND THIS IS NOT A SYSTEM IMAGE BEING MADE
!				AND NOT .LNK$GL_CTLMSK[LNK$V_SHR]	! AND THIS IS NOT A SHAREABLE IMAGE BEING MADE
				and not .obmodesc[omd$v_debuger]	! AND THIS IS NOT THE DEBUGGER MODULE
			    then begin
				lnk$gl_ctlmsk[lnk$v_dbgrec] = true;	! SET THE DEBUG CONTEXT FLAG

				if .first_dbg_record	! if this is the first dbg record for the module
				    and 
				   .dmtptr neq 0      	!   and there is dmt information to output...
				then			
				    begin
				    first_dbg_record = false;
				    construct_dmt();		! then do it
			   	    end;

				lnk$gl_locn = .lnk$gl_dstlocn;		! SWAP LOCATION COUNTERS
				protirdbg();				! AND GO PROCESS IT
				lnk$gl_dstlocn = .lnk$gl_locn;		! SAVE UPDATED POINTER
				end;
			    end;
!
! END OF MODULE RECORDS
!
	    [obj$c_eom,obj$c_eomw] :
			    begin
				if .stackpointer eql stk$c_size			! IF STACKS HAVE BEEN
				    then exitloop;				! COLLAPSED ALL DONE
				signal(lin$_eomstk,3,				! ELSE REPORT THAT STACK
					(stk$c_size - .stackpointer),		! STILL HAS ITEMS ON IT
					obmodesc[omd$b_namlng],lnk$gl_curfil[fdb$q_filename]);
				stackpointer = stk$c_size;			! AND RESET IT
			      	end;
	    [inrange]   :
			true;							! IGNORE OTHERS
	    [outrange]  :
			signal(lin$_illrectyp,4,				! ILLEGAL TYPES
				.objrec[obj$b_rectyp],obmodesc[omd$b_namlng],
				.lnk$gl_record,lnk$gl_curfil[fdb$q_filename]);
	    tes
	end;								! END OF RECORD LOOP
    lnk$gl_curisd = 0;
    end;									! END OF MODULES LOOP

lnk$gl_curfil = 0;

if .dmtptr neq 0 and .lnk$gl_ctlmsk[lnk$v_image]	! IF WE'RE PRODUCING A DEBUG MODULE/PSECT INFO TABLE, FILL IN 
then							!  THE LENGTH OF THE LAST OBJECT MODULE'S DST CONTRIBUTION
    begin
    if (.prev_dstlen_addr = .lnk$gl_dstlocn - .(.prev_dstlen_addr - 4)) eql 0	! If the last module didn't contribute
    then									!  any to the DST, then eliminate it
        lnk$gl_dmtbytes = .lnk$gl_dmtbytes -					!  by adjusting lnk$gl_dmtbytes 
				(.dmtptr - (.prev_dstlen_addr - 4));	
    end;    
!
! LOOP THROUGH THE CLUSTERS AND CROSS REFERENCE ANY SYMBOLS THAT
! ARE ON THE SHR LST AND ARE RELOCATABLE (I.E. DID NOT GET BASED
! DURING PASS 2)
!
if .lnk$gl_ctlmsk[lnk$v_mapopn]						! IF MAP FILE IS OPEN
    and .lnk$gl_ctlmsk[lnk$v_long]
then begin
    local
	cluster : ref block[,byte],
	symbol : ref block[,byte],
	symsnb : ref block[,byte];

    cluster = lnk$gl_clulst;						! POINT AT START OF LIST
    while (cluster = .cluster[clu$l_nxtclu]) neq 0
    do if .cluster[clu$v_shrimg]					! IF CLUSTER IS NON-BASED SHR IMAGE
	and not .cluster[clu$v_based]
    then begin
	symbol = .cluster[clu$l_shrlst];
	while .symbol neq 0
	do begin
	    symsnb = .symbol - .symbol[sym$b_namlng] - snb$c_fxdlen;
	    if .symbol[sym$v_crosref]					! IF SYMBOL WAS CROSS REFERENCED
		then crf$insrtref(lnk$al_valctltb,symbol[sym$l_value],	! THEN ENTER IN CREF BY VALUE TABLE
				symsnb[snb$b_namlng],.symbol[sym$w_flags]);
	    symbol = .symbol[sym$l_shrlnk];				! LINK TO NEXT SYMBOL
	    end;
	end;
    end;
return true								! END OF PASS 2
end;
end eludom
