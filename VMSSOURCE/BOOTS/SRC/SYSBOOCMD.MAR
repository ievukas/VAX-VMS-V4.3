	.IF	NDF,CMDSW
	.TITLE	SYSBOOCMD - Command parsing for SYSBOOT
	.IFF
	.TITLE	SYSGENCMD - Command parsing for SYSGEN
	.ENDC
	.IDENT	'V04-000'
	.DEFAULT DISPLACEMENT,LONG
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; Facility:  System generation and initialization
;
; Abstract: SYSBOOCMD is the interpreter for parameter modification
;	    commands both at bootstrap time and as part of the sysgen utility
;	    SYSGEN.
;
; Environment:
;
;	Both SYSGEN and SYSBOOT environments.
;
;	*********************************
;
;	WARNING: SYSBOOT code must be PIC
;
;	*********************************
;
; Author:  RICHARD I. HUSTVEDT, Creation date:  4-MAY-1978
;
; Modified by:
;
;	V03-027	WHM0012		Bill Matthews		02-aug-1984
;		Fix bad movc instruction in BOO$SETSTART from V03-026.
;
;	V03-026	WHM0011		Bill Matthews		01-aug-1984
;		Fix SET/STARTUP bug from V03-024.
;
;	V03-025	WHM0010		Bill Matthews		23-Jul-1984
;		Change MSCP qualifier /SMALL to /MINIMUM and /FRACTION to
;		/MAXIMUM.
;
;	V03-024	WHM0009		Bill Matthews		19-Jun-1984
;		Fixed LOAD<CR> accvio. Fixed SET ascii-parameter 0 bug.
;		Now allow an optional : and = in SET/STARTUP filespec.
;		Now allow optional : in device name of the CONNECT command.
;
;	V03-023	WHM0008		Bill Matthews		20-Apr-1984
;		Fixed SET of an ascii parameter to DEFAULT bug.
;		Removed USE CURRENT that read SYSGEN parameters from SYS.EXE.
;
;	V03-022	WHM0007		Bill Matthews		11-Apr-1984
;		Removed the QUORUM command.
;
;	V03-021	WHM0006		Bill Matthews		04-Apr-1984
;		Added support for sysgen ascii parameters longer than 4
;		characters.
;		Added support for a seperate default system parameter file.
;
;	V03-020	JLV0342		Jake VanNoy		 3-APR-1984
;		Add TERMINAL/ECHO command.
;
;	V03-019	WHM0005		Bill Matthews		14-Mar-1984
;		Conditionally assembled TPARSE tables for SYSBOOT.
;		Change ascii input specifier from %A to "".
;		Output header for display of a single parameter value.
;
;	V03-018	WHM0004		Bill Matthews		13-Mar-1984
;		Move definition of BOO$GL_LOAD_ARGS from this module
;		to SYSGEN.MAR.
;
;	V03-017	WHM0003		Bill Matthews		23-Feb-1984
;		Add support for loading and starting the MSCP server.
;
;	V03-016	WHM0002		Bill Matthews		01-Feb-1984
;		Add support for SHOW/LGI.
;
;	V03-015	ACG0392		Andrew C. Goldstein,	19-Jan-1984  22:40
;		Tie off SYS$FILESCAN for TPARSE use
;
;	V03-014	WHM0001		Bill Matthews		14-Dec-1983
;		Add /REMOTE and /LOGICAL switches to the CONNECT CONSOLE command
;		Add /VECTOR_OFFSET and /CSR_OFFSET to the CONNECT command
;
;	V03-013	WMC0013		Wayne Cardoza		01-Dec-1983
;		Allow arbitrary ordering of install qualifiers
;
;	V03-012	JLV0311		Jake VanNoy		10-OCT-1983
;		Fix SHOW/ALL to really SHOW/ALL.
;
;	V03-011	SRB0103		Steve Beckhardt		19-Sep-1983
;		Added temporary QUORUM command.
;
;	V03-010	BLS0239		Benn Schreiber		13-Sep-1983
;		Use TPA$_SYMBOL for %A so that '$' and '_' are allowed.
;
;	V03-009	ACG0345		Andrew C. Goldstein,	1-Aug-1983  16:53
;		Add dummy SYS$ASCTOID routine for TPARSE
;
;	V03-008	MSH0005		Maryann Hinden		13-Jul-1983
;		Don't need to echo input anymore.
;		Set ascii parameters correctly if smaller than a longword.
;
;	V03-007	MSH0004		Maryann Hinde 		24-Jun-1983
;		Change $BOODEF to $BOOCMDDEF.
;
;	V03-006	MSH0003		Maryann Hinden		10-Jun-1983
;		Use $BOODEF.
;
;	V03-005	MSH0002		Maryann Hinden		14-Apr-1983
;		Teach SYSGEN to speak ASCII.
;
;	V03-004	MSH0001		Maryann Hinden		24-Mar-1983
;		Preserve values for system time and base registers
;		across USE DEFAULT and USE CURRENT commands.
;
;	V03-003	DWT0086		David W. Thiel		22-Mar-1983
;		Add PRM$M_CLUSTER to SHOW/ALL mask.  Add
;		SHOW/CLUSTER.
;
;	V03-002	WMC0001		Wayne Cardoza		12-Aug-1982
;		Add support for the /checkpoint qualifier on install /page
;
;	V03-001	JLV0196		Jake VanNoy		17-MAR-1982
;		Add new parsing for CREATE. Add PRM$M_SCS, PRM$M_TTY
;		and PRM$M_SYSGEN to SHOW/ALL mask. Change BOO$SEARCH
;		to return no such parameter if a search for a zero
;		length parameter is passed in.
;
;--

;
; Include files:
;
	$BOOCMDDEF			; Flag bits in command options longword
	$CLUBDEF			; Cluster block offsets
	$IPLDEF				; IPL defs
	$PRVDEF				; Privilege definitions
	$PCBDEF				; PCB offsets
	$PRMDEF				; Parameter descriptor definitions
	$SSDEF				; System messages
	$SYSGMSGDEF			; Sysgen messages	
	$TPADEF				; Define TPARSE symbols

;
; MACROS:
;
;
; Macro to print message
;
;	MSG	message_text
;
	.MACRO	MSG,STR			;
	BSBW	BOO$FACMSG		;
	.ASCIZ	\'STR'\			;
	.ENDM	MSG			;

;
; Equated Symbols:
;
	CR=13				; Character value for carriage return
	FF=12				; Character value for form feed
	LF=10				; Character value for line feed
	BUFFER_SIZE=256
 
	.PAGE
	.SBTTL	PARSE TABLES
;
;	DEFINE COMMAND SYNTAX
;

	$INIT_STATE	STATE1,KEYTBL	;
	$STATE				;
	$TRAN	!DISABLCMD,TPA$_EXIT	; Disable option command
	$TRAN	!ENABLCMD,TPA$_EXIT	; Enable option command
	$TRAN	'HELP',TPA$_EXIT,BOO$GIVEHELP	; Help command
	$TRAN	!SETCMD,TPA$_EXIT	; Set specific value
	$TRAN	!SHOCMD,TPA$_EXIT	; Show values
	$TRAN	!USECMD,TPA$_EXIT	; Set background values
	$TRAN	'EXIT',TPA$_EXIT,,BOOCMD$M_CONT,BOO$GL_CMDOPT	; Same as continue

	.IF	NDF,CMDSW		;SYSBOOT specific commands
	$TRAN	'CONTINUE',TPA$_EXIT,,BOOCMD$M_CONT,BOO$GL_CMDOPT ; Continue command

	.IFF				;SYSGEN specific commands
	$TRAN	!ADPCMD,TPA$_EXIT,BOO$CONADP	; Set adapter TR number
	$TRAN	!CONECTCMD,TPA$_EXIT,BOO$CONNECT ; Connect command
	$TRAN	!CREATECMD,TPA$_EXIT,BOO$CREATE	; Create dump/page/swap file
	$TRAN	!INSTALCMD,TPA$_EXIT,BOO$INSTALL; Install swap/page file
	$TRAN	!LOADCMD,TPA$_EXIT,BOO$LOAD	; Load driver
	$TRAN	!RELOADCMD,TPA$_EXIT,BOO$RELOAD	; Reload driver
	$TRAN	!MSCPCMD,TPA$_EXIT,BOO$LOAD	; Load and start the MSCP server
	$TRAN	!SHARECMD,TPA$_EXIT,GEN$SHARE ; Share command
	$TRAN	!WRTCMD,TPA$_EXIT		; Write parameter file
	$TRAN	!AUTOCONFIG,TPA$_EXIT		; Auto-configure command
	$TRAN	!CONFIGCMD,TPA$_EXIT,BOO$CONFIGURE
	$TRAN	!TERMINALCMD,TPA$_EXIT		; terminal command
	.ENDC

	$TRAN	TPA$_EOS,TPA$_EXIT	; END OF LINE

;
; Disable command
;
	$STATE	DISABLCMD		; Disable command
	$TRAN	'DISABLE'		; Command verb
	$STATE				;
	$TRAN	'CHECKS',TPA$_EXIT,BOO$NOCHECK	; Disable value checking
;
;	Recognize ENABLE command
;
	$STATE	ENABLCMD		; ENABLE command
	$TRAN	'ENABLE'		; Command verb
	$STATE				;
	$TRAN	'CHECKS',TPA$_EXIT,BOO$CHECK	;

;
;	Recognize SET Command
;
	$STATE	SETCMD			; SET command
	$TRAN	'SET'			; Command verb
	$STATE				;
	$TRAN	'/',SETSPEC		; 
	$TRAN	'.',,BOO$DOT		; Use last name
	$TRAN	TPA$_SYMBOL,,BOO$SEARCH	; Lookup and verify symbol name
	$STATE				;
	$TRAN	!ASCII,TPA$_EXIT	; Verify and set ASCII string
	$TRAN	!NUMBER,TPA$_EXIT,BOO$SETVALUE	; Verify and set value
	$TRAN	'DEFAULT',TPA$_EXIT,BOO$SETDEF	; Set to default value
	$STATE	SETSPEC			;
	$TRAN	!SETSTARTUP,TPA$_EXIT	; Set startup file name
	$TRAN	!SETOUTPUT,TPA$_EXIT	; Set output filespec

	$STATE	ASCII
	$TRAN	'"',,,TPA$M_BLANKS,PARMBLK+TPA$L_OPTIONS; Make blanks significant
	$STATE	SYMBOL
	$TRAN	TPA$_SYMBOL,,BOO$SETASCII
	$TRAN	TPA$_BLANK,SYMBOL	; ignore blanks
	$TRAN	'"',TPA$_EXIT,BOO$SETBLANK; null string => all blanks
	$STATE
	$TRAN	'"',TPA$_EXIT

	$STATE	SETOUTPUT
	$TRAN	'OUTPUT'
	$STATE
	$TRAN	!SEPARATOR		; = or :
	$TRAN	TPA$_LAMBDA		; Or null
	$STATE
	$TRAN	!FILESPEC
	$STATE	
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SET_OUTPUT

	$STATE	SETSTARTUP
	$TRAN	'STARTUP'
	$STATE
	$TRAN	!SEPARATOR		; = or :
	$TRAN	TPA$_LAMBDA		; Or null
	$STATE
	$TRAN	!FILESPEC
	$STATE	
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SETSTART

;
;	Recognize SHOW Command
;
	$STATE	SHOCMD			; SHOW command
	$TRAN	'SHOW'			; Command verb
	$STATE	SHOSWITCH		;
	$TRAN	'/'			;
	$TRAN	'.',SHOWONE,BOO$DOT	; SHOW .
	$TRAN	TPA$_SYMBOL,SHOWONE,BOO$SEARCH	; Lookup and verify symbol name
	$STATE				;
	$TRAN	'HEX',SHOSWITCH,,BOOCMD$M_DISHEX,BOO$GL_CMDOPT
	$TRAN	'ACP',HEXQUAL2,,,,PRM$M_ACP; SHOW/ACP
;
; Note that PRM$M_ALL doesn't exist in $PRMDEF. It is used here simply as
; a flag to BOO$SHOALL.
;
PRM$V_ALL = 31
PRM$M_ALL = 1@PRM$V_ALL

	$TRAN	'ALL',HEXQUAL2,,,,PRM$M_ALL; SHOW/ALL
	$TRAN	'RMS',HEXQUAL2,,,,<PRM$M_RMS>; SHOW/RMS
	$TRAN	'SCS',HEXQUAL2,,,,<PRM$M_SCS>; SHOW/SCS
	$TRAN	'SPECIAL',HEXQUAL2,,,,<PRM$M_SPECIAL>; SHOW/SPECIAL
	$TRAN	'SYS',HEXQUAL2,,,,<PRM$M_SYS>; SHOW/SYS
	$TRAN	'GEN',HEXQUAL2,,,,<PRM$M_SYSGEN>; SHOW/GEN (Sysgen Parameters)
	$TRAN	'JOB',HEXQUAL2,,,,<PRM$M_JBC>; SHOW/JOB (Job controller)
	$TRAN	'PQL',HEXQUAL2,,,,<PRM$M_PQL>; SHOW/PQL (Process quota list)
	$TRAN	'TTY',HEXQUAL2,,,,<PRM$M_TTY>; SHOW/TTY
	$TRAN	'LGI',HEXQUAL2,,,,<PRM$M_LGI>; SHOW/LGI
    	$TRAN	'CLUSTER',HEXQUAL2,,,,<PRM$M_CLUSTER>	; SHOW/CLUSTER show cluster parameters
	$TRAN	'NAMES',TPA$_EXIT,BOO$SHONAMES	; SHOW/NAMES show parameter names
	$TRAN	'MAJOR',HEXQUAL2,,,,<PRM$M_MAJOR>	; SHOW/MAJOR show major parameters
	$TRAN	'DYNAMIC',HEXQUAL2,,,,<PRM$M_DYNAMIC>; SHOW/DYNAMIC show dyn. params.
	$TRAN	'STARTUP',TPA$_EXIT,BOO$SHOSTART     ; SHO/STARTUP Show startup file name
	.IF	DF,CMDSW			;SYSGEN specific qualifiers
	$TRAN	'ADAPTER',TPA$_EXIT,BOO$SHOW_ADAPTER ; SHOW/ADAPTER
	$TRAN	'CONFIGURATION',SHOWCON,BOO$RESET_IO ; SHOW/CONFIGURATION
	$TRAN	!SHOW_UNIBUS,TPA$_EXIT		; /UNIBUS
	$TRAN	!DEV_OR_DRIV,TPA$_EXIT		; /DEVICES and /DRIVER
	.ENDC
	
	$STATE	SHOWONE			; SHOW value_name
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,BOO$SHOVALUE	;

	$STATE	HEXQUAL2
	$TRAN	!HEXQUAL,TPA$_EXIT,BOO$SHOALL

	$STATE	HEXQUAL
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE
	$TRAN	'HEX',TPA$_EXIT,,BOOCMD$M_DISHEX,BOO$GL_CMDOPT
;	
; Recognize USE command
;
	$STATE	USECMD			;
	$TRAN	'USE',,,BOOCMD$M_USEFILE,BOO$GL_CMDOPT ;
	$STATE				;
	$TRAN	!USECUR			; 
	$TRAN	!USEACT			;
	$TRAN	!USEDEF			;
	$TRAN	!FILESPEC,,BOO$USEFILE	;
	$STATE				;
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	;

	$STATE	USECUR			; USE CURRENT
	$TRAN	'CURRENT'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$USECUR

	$STATE	USEACT			; USE ACTIVE
	$TRAN	'ACTIVE'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$USEACT

	$STATE	USEDEF			; USE DEFAULT
	$TRAN	'DEFAULT'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,,BOOCMD$M_DEFAULT,BOO$GL_CMDOPT	;

;
; File Specification
;
	$STATE	FILESPEC		; GENERAL FILE SPEC CHECK
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,BOO$FILESPEC

;
; RECOGNIZE NUMBER
;
	$STATE NUMBER			;
	$TRAN	TPA$_DECIMAL,TPA$_EXIT	; DECIMAL NUMBER
	$TRAN	'%'			; BASE PREFIX
	$STATE				;
	$TRAN	'X',HEXNUM		; HEX BASE DESIGNATOR
	$TRAN	'O'			; OCTAL NUMBER
	$STATE				; 
	$TRAN	TPA$_OCTAL,TPA$_EXIT	; INTRODUCED OCTAL NUMBER
	$STATE	HEXNUM			; INTRODUCED HEX NUMBER
	$TRAN	TPA$_HEX,TPA$_EXIT	; HEX NUMBER

;
; RECOGNIZE SWITCH/VALUE SEPARATOR
;
	$STATE	SEPARATOR		;
	$TRAN	'=',TPA$_EXIT		;
	$TRAN	':',TPA$_EXIT		;

;
; Get a numeric qualifier value
;
	$STATE	VALUE			; Get value for option
	$TRAN	!SEPARATOR		;
	$STATE				;
	$TRAN	!NUMBER,TPA$_EXIT	;

	.IF	DF,CMDSW		;SYSGEN specific commands
;
; Adapter command
;
	$STATE	ADPCMD			; Command to set adapter TR number
	$TRAN	'ADAPTER',,BOO$RESET_ADAP ; Command verb
	$STATE				;
	$TRAN	!NUMBER,TPA$_EXIT	; Numeric value
	$TRAN	!ADAP_STR,TPA$_EXIT	; Generic Name

;
; Autoconfigure command
;
	$STATE	AUTOCONFIG		; Auto configure command
	$TRAN	'AUTOCONFIGURE',,BOO$RESETLIST	; Command verb
	$STATE				;
	$TRAN	'ALL',CONFIGALL		; Configure all
	$TRAN	!NUMBER			; Configure one TR number
	$TRAN	!ADAP_STR2		; Generic Name
	$STATE				;
	$TRAN	!AUTOOPT,TPA$_EXIT,BOO$CONFIGONE	;

	$STATE	CONFIGALL		;
	$TRAN	!AUTOOPT,TPA$_EXIT,BOO$CONFIGALL	;

	$STATE	AUTOOPT			; Select option
	$TRAN	'/'			; Switch introducer
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	; Else not specified
	$STATE				;
	$TRAN	'LOG',AUTOOPT,,BOOCMD$M_AUTOLOG,BOO$GL_CMDOPT ; LOG DEVICES
	$TRAN	'SELECT' ,,,BOOCMD$M_SELECT,BOO$GL_CMDOPT ; Option name
	$TRAN	'EXCLUDE',,,BOOCMD$M_EXCLUDE,BOO$GL_CMDOPT
					; Reverse sense of select
	$STATE				;
	$TRAN	!SEPARATOR		; : or =
	$STATE				;
	$TRAN	'('			; Allow parentheses
	$TRAN	TPA$_LAMBDA		; But make it optional

	$STATE	SELECTLIST		; Device selectlist
	$TRAN	TPA$_SYMBOL,,BOO$MAKLIST	; Select string
	$TRAN	')',AUTOOPT		; End ')'
	$TRAN	TPA$_LAMBDA,AUTOOPT	; Else end of list
	$STATE				;
	$TRAN	<','>,SELECTLIST	; Another option in list
	$TRAN	TPA$_LAMBDA,SELECTLIST	; Else end

;
; CONFIGURE command
;

	$STATE	CONFIGCMD
	$TRAN	'CONFIGURE',,BOO$RESET_IO ; Reset IO and AUTORESET of devices names
	$STATE	
	$TRAN	!CONFIG_LIST
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	
	$STATE	CONFIG_LIST
	$TRAN	!CONFIG_OPT,CONFIG_LIST
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	
	$STATE	CONFIG_OPT
	$TRAN	'/'
	$STATE
	$TRAN	!INPUT,TPA$_EXIT
	$TRAN	!OUTPUT,TPA$_EXIT
	$TRAN	!RESET,TPA$_EXIT

	$STATE	INPUT
	$TRAN	'INPUT'
	$STATE
	$TRAN	!SEPARATOR
	$STATE
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$INPUT_FILE

	$STATE	OUTPUT
	$TRAN	'OUTPUT'
	$STATE
	$TRAN	!SEPARATOR
	$STATE
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$OUTPUT_FILE

	$STATE	RESET
	$TRAN	'RESET',TPA$_EXIT		; No action,this is the default
	$TRAN	'NORESET',TPA$_EXIT,BOO$NO_RESET ; Turn reset off this call


;
; Create command - Create contiguous file for paging, swapping or system dump
;
	$STATE	CREATECMD		;
	$TRAN	'CREATE'		; Command verb
	$STATE	CREOPT			; Create options
	$TRAN	'/',CREATE_QUAL		;
	$TRAN	!FILESPEC,CREOPT,BOO$SETFILNAM; Set name of file
	$TRAN	TPA$_EOS,TPA$_EXIT	;

	$STATE	CREATE_QUAL		;
	$TRAN	'CONTIGUOUS',CREOPT,BOO$CRECONTIG    ; Contiguous 
	$TRAN	'NOCONTIGUOUS',CREOPT,BOO$CRENCONTIG ; Set non-contiguous
	$TRAN	'SIZE'			; Get the allocation size
	$STATE				;
	$TRAN	!VALUE,CREOPT,BOO$FILESIZE ; Set file size
;
; Connect command - Connect specified device and load driver if required
;
	$STATE	CONECTCMD		; 
	$TRAN	'CONNECT',,BOO$CONRESET	; Command verb
	$STATE				;
	$TRAN	'CONSOLE',CONSOLCMD	; Connect console command
	$TRAN	TPA$_SYMBOL,,BOO$DEVNAME; Device name
	$STATE				;
	$TRAN	':'			;allow an optional ":"
	$TRAN	TPA$_LAMBDA		;
	$STATE	CONOPT			;
	$TRAN	!CONECTOPT,CONOPT	; Connect option
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	;
;
; Connect console command
;
	$STATE	CONSOLCMD
	$TRAN	!CONSOLOPT,TPA$_EXIT,BOO$CONSOLE;

	$STATE	CONSOLOPT
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE
	$TRAN	'REMOTE',TPA$_EXIT,,BOOCMD$M_REMOTE,BOO$GL_CMDOPT; Connect remote console
	$TRAN	'LOGICAL',TPA$_EXIT,,BOOCMD$M_LOGICAL,BOO$GL_CMDOPT; Connect logical console
	$TRAN	TPA$_LAMBDA,TPA$_EXIT

;
;	Recognize INSTALL command
;
	$STATE	INSTALCMD		;
	$TRAN	'INSTALL'		;
	$STATE				;
	$TRAN	!FILESPEC,,BOO$SETFILNAM;
	$STATE	INS1			;
	$TRAN	'/'			; Switch introducer
	$STATE
	$TRAN	'PAGEFILE',,BOO$SETPGFL
	$TRAN	'SWAPFILE',INS_EXIT
	$TRAN	'CHECKPOINT',INS_PAGE
	$TRAN	'NOCHECKPOINT',INS_PAGE,BOO$NOCHKPNT
	$STATE	
	$TRAN	'/'			; look for the checkpoint switch
	$TRAN	TPA$_EOS,TPA$_EXIT
	$STATE
	$TRAN	'CHECKPOINT',TPA$_EXIT
	$TRAN	'NOCHECKPOINT',TPA$_EXIT,BOO$NOCHKPNT
	$STATE	INS_PAGE
	$TRAN	'/'
	$STATE
	$TRAN	'PAGEFILE',,BOO$SETPGFL
	$STATE	INS_EXIT
	$TRAN	TPA$_EOS,TPA$_EXIT
;
;	Recognize LOAD command
;
	$STATE	LOADCMD			;
	$TRAN	'LOAD',,BOO$CONRESET; Command verb
	$STATE
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$CONDRVNAM
	$STATE
	$TRAN	TPA$_LAMBDA,MSCP
;
;	Recognize MSCP command
;
	$STATE	MSCPCMD
	$TRAN	'MSCP_LOAD',,BOO$MSCP_RESET ; Loading and starting the MSCP server
	$STATE	MSCP
	$TRAN	!MSCPOPT,MSCP
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE	MSCPOPT
	$TRAN	'/'
	$STATE
	$TRAN	!MSCP_BUFFER,TPA$_EXIT,BOO$MSCP_ARG,,,2	;BUFFERS IS PARAMETER 2
	$TRAN	!MSCP_PACKET,TPA$_EXIT,BOO$MSCP_ARG,,,3	;PACKET IS PARAMETER 3
	$TRAN	!MSCP_HOSTS,TPA$_EXIT,BOO$MSCP_ARG,,,4	;HOSTS IS PARAMETER 4
	$TRAN	!MSCP_TIME_OUT,TPA$_EXIT,BOO$MSCP_ARG,,,5;TIME_OUT IS PARAMETER 5
	$TRAN	!MSCP_PRIORITY,TPA$_EXIT,BOO$MSCP_ARG,,,6;PRIORITY IS PARAMETER 6
	$TRAN	!MSCP_SMALL,TPA$_EXIT,BOO$MSCP_ARG,,,7	;SMALL IS PARAMETER 7
	$TRAN	!MSCP_FRACTION,TPA$_EXIT,BOO$MSCP_ARG,,,8;FRACTION IS PARAMETER 8
	$TRAN	!LOADARGCNT,TPA$_EXIT,BOO$MSCP_ARG,,,0	;ARGUMENT COUNT
	$TRAN	!LOADP1,TPA$_EXIT,BOO$MSCP_ARG,,,1	;LOAD PARAMETER 1

	$STATE	MSCP_BUFFER
	$TRAN	'BUFFER',VALUE
	$TRAN	'P2',VALUE

	$STATE	MSCP_PACKET
	$TRAN	'PACKET',VALUE
	$TRAN	'P3',VALUE

	$STATE	MSCP_HOSTS
	$TRAN	'HOSTS',VALUE
	$TRAN	'P4',VALUE

	$STATE	MSCP_TIME_OUT
	$TRAN	'TIME_OUT',VALUE
	$TRAN	'P5',VALUE

	$STATE	MSCP_PRIORITY
	$TRAN	'PRIORITY',VALUE
	$TRAN	'P6',VALUE

	$STATE	MSCP_SMALL
	$TRAN	'MINIMUM',VALUE
	$TRAN	'P7',VALUE

	$STATE	MSCP_FRACTION
	$TRAN	'MAXIMUM',VALUE
	$TRAN	'P8',VALUE

	$STATE	LOADARGCNT
	$TRAN	'ARGCOUNT',VALUE

	$STATE	LOADP1
	$TRAN	'P1',VALUE

;	
;
;	Recognize RELOAD command
;
	$STATE	RELOADCMD		;
	$TRAN	'RELOAD',LOAD1,BOO$CONRESET; Command verb

;
; Share command - Initialize and/or connect to a shared memory
;
	$STATE	SHARECMD
	$TRAN	'SHARE',,GEN$SHR_RESET	; Command verb
	$STATE	SHARECMDOPT
	$TRAN	!SHAREOPT,SHARECMDOPT	; Command options
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	'M'			; Multiport memory "MPMx"
	$STATE				;
	$TRAN	'P'			;
	$STATE				;
	$TRAN	'M'			;
	$STATE				;
	$TRAN	TPA$_DECIMAL,,GEN$SHR_UNIT ; Memory unit #
	$STATE				;
	$TRAN	TPA$_SYMBOL,,GEN$SHR_MEMNAME ; Memory name
	$STATE	SHROPT			;
	$TRAN	!SHAREOPT,SHROPT	; Share options
	$TRAN	TPA$_EOS,TPA$_EXIT	;

;
; SYSGEN specific show qualifiers
;
	$STATE	DEV_OR_DRIV
	$TRAN	'DEVICES',,,,,0		; SHO/DEVICES[=devname]
	$TRAN	'DRIVER',,,,,1		; SHO/DRIVER [=devname]
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SHODEV_ALL	; SHOW ALL
	$TRAN	!SEPARATOR		;
	$TRAN	TPA$_LAMBDA
	$STATE				;
	$TRAN	TPA$_STRING,TPA$_EXIT,BOO$SHODEV	; SHOW SPECIFIC DEVICE

	$STATE	SHOWCON
	$TRAN	!SHOWCON_LOOP,TPA$_EXIT,BOO$SHOCONFIG
	
	$STATE	SHOWCON_LOOP
	$TRAN	!SHOWCONOPT,SHOWCON_LOOP
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,TPA$_FAIL
	
	$STATE	SHOWCONOPT
	$TRAN	'/'
	$STATE
	$TRAN	'COMMAND_FILE',TPA$_EXIT,BOO$RESET_COMMAND ; Set command file spec
	$TRAN	!OUTPUT,TPA$_EXIT
	$TRAN	!ADAPTER,TPA$_EXIT,BOO$SET_TR
;
; SHOW /UNIBUS [/ADAPTER=n]
;
	$STATE	SHOW_UNIBUS
	$TRAN	'UNIBUS',,,,,0
	$STATE
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	!ADAPTER,,BOO$SET_TR,,,1
	$TRAN	TPA$_LAMBDA
	$STATE	
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SHOW_UNIBUS

	$STATE	ADAPTER			; Set adapter number
	$TRAN	'ADAPTER',,BOO$RESET_ADAP
	$STATE	
	$TRAN	!SEPARATOR
	$STATE
	$TRAN	!NUMBER,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,ADAP_STR

	$STATE	ADAP_STR2
	$TRAN	TPA$_LAMBDA,ADAP_STR,BOO$RESET_ADAP

	$STATE	ADAP_STR
	$TRAN	TPA$_ALPHA,ADAP_STR,BOO$ADAP_LETTER 	; One letter at a time
	$TRAN	TPA$_DECIMAL,TPA$_EXIT,BOO$ADAPTER_NAME	; Take number as end

;
;	Recognize the TERMINAL command
;
	$STATE	TERMINALCMD
	$TRAN	'TERMINAL'
	$STATE	
	$TRAN	'/'
	$STATE
	$TRAN	'ECHO',TPA$_EXIT,SYSG$LOAD_TT_STR ; /ECHO only qualifier
;
; 	Recognize WRITE Command
;
	$STATE	WRTCMD			;
	$TRAN	'WRITE'			; Command verb
	$STATE				;
	$TRAN	!WRTCUR,TPA$_EXIT	; 
	$TRAN	!WRTACT,TPA$_EXIT	;
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$WRTFILE	;

	$STATE	WRTCUR			; WRITE CURRENT
	$TRAN	'CURRENT'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$WRTCUR

	$STATE	WRTACT			; WRITE ACTIVE
	$TRAN	'ACTIVE'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$WRTACT
;
; RECOGNIZE CONNECT OPTIONS
;
	$STATE	CONECTOPT		;
	$TRAN	'/'			; Switch introducer
	$STATE				;
	$TRAN	!ADAPTER,TPA$_EXIT,BOO$CONADP		; Adapter number
	$TRAN	'NOADAPTER',TPA$_EXIT,BOO$CONNLADP 	; Use null adapter
	$TRAN	!CONCREG,TPA$_EXIT,BOO$CONCREG		; Control register (UBA)
	$TRAN	!CONCVECTOR,TPA$_EXIT,BOO$CONCVEC	; Vector (UBA)
	$TRAN	!CONCNUMVEC,TPA$_EXIT,BOO$CONCNUM	; Number of vectors
	$TRAN	!CONAUNIT,TPA$_EXIT,BOO$CONAUNIT	; Adapter unit
	$TRAN	!CONUNITS,TPA$_EXIT,BOO$CONUNITS	; Maximum units
	$TRAN	!CONSYSID_LO,TPA$_EXIT,BOO$CONSYSID_LOW	 ; System ID (low)
	$TRAN	!CONSYSID_HI,TPA$_EXIT,BOO$CONSYSID_HIGH ; System ID (high)
	$TRAN	!CONVECOFF,TPA$_EXIT,BOO$CONVECOFFSET	; Offset to vector(combo devices only)
	$TRAN	!CONCSROFF,TPA$_EXIT,BOO$CONCSROFFSET	; Offset to CSR(combo devices only)
	$TRAN	'DRIVERNAME'		;
	$STATE				;
	$TRAN	!SEPARATOR		;
	$STATE	LOAD1			;
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$CONDRVNAM	; Driver name

	$STATE	CONCREG			; Control register address
	$TRAN	'CONTROLREGISTER',VALUE	;
	$TRAN	'CSR',VALUE		; Synonym

	$STATE	CONCVECTOR		; Control vector address
	$TRAN	'VECTOR',VALUE		; 

	$STATE	CONCNUMVEC		; Number of vectors
	$TRAN	'NUMVEC',VALUE		;

	$STATE	CONUNITS		; Maximum units
	$TRAN	'MAXUNITS',VALUE	;

	$STATE	CONSYSID_LO		; System id
	$TRAN	'SYSIDLOW',VALUE	;

	$STATE	CONSYSID_HI		; System id
	$TRAN	'SYSIDHIGH',VALUE	;

	$STATE	CONVECOFF		; Offset to vector from start of combo vectors
	$TRAN	'VECTOR_OFFSET',VALUE	;

	$STATE	CONCSROFF		; Offset to CSR from start of combo CSR
	$TRAN	'CSR_OFFSET',VALUE	;

	$STATE	CONAUNIT		; Adapter unit number
	$TRAN	'ADPUNIT',VALUE		;
	$TRAN	':',TPA$_EXIT		;
;
; Recognize Share command options
;
	$STATE	SHAREOPT		;
	$TRAN	'/'			; Switch introducer
	$STATE				;
	$TRAN	!SHRGBLCNT,TPA$_EXIT,GEN$SHR_GBLCNT ; Global Section count
	$TRAN	!SHRMBXCNT,TPA$_EXIT,GEN$SHR_MBXCNT ; Mailbox count
	$TRAN	!SHRCEFCNT,TPA$_EXIT,GEN$SHR_CEFCNT ; Com Event Flags Clustr Cnt
	$TRAN	!SHRGBLMAX,TPA$_EXIT,GEN$SHR_GBLMAX ; Port max Global Sections
	$TRAN	!SHRMBXMAX,TPA$_EXIT,GEN$SHR_MBXMAX ; Port max mailboxes
	$TRAN	!SHRCEFMAX,TPA$_EXIT,GEN$SHR_CEFMAX ; Port max Com Event Flags
	$TRAN	!POOLCNT,TPA$_EXIT,GEN$SHR_POOLC ; Count of pool blocks
	$TRAN	!POOLSIZE,TPA$_EXIT,GEN$SHR_POOLS ; Size of pool blocks
	$TRAN	!PRQCNT,TPA$_EXIT,GEN$SHR_PRQCNT ; Count of PRQ blocks

	$TRAN	!SHRSTART,TPA$_EXIT,GEN$SHR_START ; Start of useable mem.
	$TRAN	'INITIALIZE',TPA$_EXIT,GEN$SHR_INIT ; Initialize

	$STATE	SHRGBLCNT		; Global section count
	$TRAN	'GBLSECTIONS',VALUE	; 

	$STATE	SHRMBXCNT		; Mailbox count
	$TRAN	'MAILBOXES',VALUE	;

	$STATE	SHRCEFCNT		; Common event flag cluster count
	$TRAN	'CEFCLUSTERS',VALUE	; 

	$STATE	SHRGBLMAX		; Port maximum Global Sections
	$TRAN	'MAXGBLSECTIONS',VALUE	;

	$STATE	SHRMBXMAX		; Port maximum Mailboxes
	$TRAN	'MAXMAILBOXES',VALUE	;

	$STATE	SHRCEFMAX		; Port maximum Common Ev Flag Clusters
	$TRAN	'MAXCEFCLUSTERS',VALUE	;

	$STATE	POOLCNT			; Total pool blocks count
	$TRAN	'POOLBCOUNT',VALUE	;
	$TRAN	'POOLBCNT',VALUE	;

	$STATE	POOLSIZE		; Pool block size
	$TRAN	'POOLBSIZE',VALUE	;

	$STATE	PRQCNT			; Total PRQ blocks count
	$TRAN	'PRQCOUNT',VALUE	;
	$TRAN	'PRQCNT',VALUE	;

	$STATE	SHRSTART		; Starting relative PFN
	$TRAN	'START',VALUE		;

	.ENDC				; End SYSGEN specific command
	$END_STATE
;

; Own Storage:
;

.Psect NONPAGED_DATA,	noexe,rd,wrt,quad

BOO$GL_CMDOPT::				; Command options
	.LONG	BOOCMD$M_TERMINAL	; Default is all off, except for terminal

SAVE_TODCBASE:				; Save area for system time and base
	.BLKQ	1			; registers
SAVE_TODR:
	.BLKL	1

	.PSECT	SYSBOOCMD,LONG

PARMBLK:				; TPARSE parameter block
	.BLKB	TPA$K_LENGTH0		;
BOO$GL_DOT::				; Last parameter address
	.LONG	0			;
BOO$GQ_FILDESC::			; File name descriptor
	.LONG	0,0			; 
BOO$GT_FILNAME::			; File name buffer
	.BLKB	64			;
BOO$GT_COMBUF::				; Command Line Buffer
	.BLKB	200			;
BOO$C_COMBUFSZ==.-BOO$GT_COMBUF		; Size of command buffer
BOO$GT_COMSTR::				; Command string 
	.BLKB	1024			; 
BOO$C_COMSTRLEN==.-BOO$GT_COMSTR	; Length of command string buffer
BOO$GT_SYSNAME::			; System name string
	.ASCIC	\SYS$SYSTEM:SYS.EXE\	; Name of sytem image
BOO$GT_SYSPARNAME::
	.ASCIC	\SYS$SYSTEM:VAXVMSSYS.PAR\; Name of the system .PAR file

BOO$T_DYNAMIC:		.ascic	/D/
BOO$T_NODYNAMIC:	.ascic	//

CUR_BLANKS:	.ASCIC	/                 /
BLANKS:		.ASCIC  /    /

CTRLSTR:	.ASCID	@!15AC         !4(10SL) !11AC !AC@

HEXSTR:		.ASCID	@!15AC         !4(10XL) !11AC !AC@

ASCSTR:		.ASCID	@!15AC!AC"!AF"   !AC"!AF"   !AC"!AF"   !AC"!AF" !11AC !AC@

NCTRLSTR:	.ASCID	@  !#(17AC) @

SCTRLSTR:	.ASCID	@  Startup command file = !AC@

CTR_PARINUSE:	.ASCID	@!/Parameters in use: !AC@

SDVHDR:
	.ASCII	\Parameter Name             Current   Default   Minimum   Maximum\
	.ASCII	\ Unit  Dynamic\
	.ASCII	<CR><LF>		; 
	.ASCII	\--------------             -------   -------   -------   -------\
	.ASCII	\ ----  -------\
SDVHDRLEN=.-SDVHDR

.IF	NDF,CMDSW			; SYSBOOCMD definitions for RIO$OUTPUT_LINE

RIO$AB_OUTBUF::		.long	BUFFER_SIZE
			.long	RIO$AB_BUFFER
RIO$AB_BUFFER::		.blkb	BUFFER_SIZE
RIO$GW_OUTLEN::		.word	0

BOO$GB_FILELEN:		.byte	0
BOO$GL_FILEADDR:	.long	0
BOO$GT_CURRENT:	
BOO$GT_DEFAULT:
BOO$GL_PARINUSE:	.long	0
		
.ENDC
	.PAGE
	.SBTTL	
;++
;
; Functional Description:
;
;
; Calling Sequence:
;	NONE
;
; Input Parameters:
;	NONE
;
; Implicit Inputs:
;	NONE
;
; Output Parameters:
;	NONE
;
; Implicit Outputs:
;	NONE
;
; Side Effects:
;	NONE
;
;--
	.LIST	MEB			; Show macro expansions


BOO$GETPARAM::	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Save all registers

	.IF	NDF,CMDSW	; SYSBOOCMD only
;
; Make descriptors PIC (only needed in SYSBOOCMD)
;

	MOVAB	CTRLSTR+8,CTRLSTR+4	; Set address in descriptor
	MOVAB	HEXSTR+8,HEXSTR+4	; Set address in descriptor
	MOVAB	ASCSTR+8,ASCSTR+4	; Set address in descriptor
	MOVAB	NCTRLSTR+8,NCTRLSTR+4	; Set address in descriptor
	MOVAB	SCTRLSTR+8,SCTRLSTR+4	; Set address in descriptor
	MOVAB	RIO$AB_BUFFER,-
		RIO$AB_OUTBUF+4		; Set address in descriptor

	.ENDC

READCMD:				;
	MOVAL	PARMBLK,R7		; Get address of parameter block
	CLRL	TPA$L_STRINGCNT(R7)	; Initialize string length
	MOVAB	BOO$GT_COMSTR,TPA$L_STRINGPTR(R7)	; And address
READLINE:				;
	MOVAB	BOO$GT_COMBUF,R2	; Set address of buffer
	PUSHL	R2			; Set buffer address into argument list
	MOVZBL	#BOO$C_COMBUFSZ,-(SP)	;  and maximum size for read
	PUSHAB	BOO$GT_PROMPT		; Address of prompt string
	CALLS	#3,L^BOO$READPROMPT	; Prompt for and accept command
	BLBS	R0,5$			; Exit if end of file.
	RET				;

; Upcase input

5$:	MOVL	R2,R0			; Set address of string
	MOVZBL	(R0)+,R1		; Get address and count
7$:	CMPB	(R0),#^A/a/		; Lower case possible ?
	BLSSU	8$			; No, Branch
	CMPB	(R0),#^A/z/		; Lower case possible ?
	BGTRU	8$			; No, Branch
	BICB2	#^X20,(R0)		; Clear bit, make character upper case
8$:	INCL	R0			; Increment pointer
	SOBGTR	R1,7$			; Loop

	ADDL3	TPA$L_STRINGPTR(R7),TPA$L_STRINGCNT(R7),R3 ; Get current pointer
	MOVZBL	(R2)+,R0		; Get length of input line
	BEQL	READLINE		; Ignore null input
	MOVL	R2,R1			; Move to LOCC address register
30$:	MOVZBL	(R1)+,R2		; Get a character
	CMPB	#^A/-/,R2		; Is this a possible continuation?
	BEQL	50$			; Branch if yes
	CMPB	#^A/!/,R2		; Is this the start of a comment?
	BEQL	40$			; Branch if yes
	INCL	TPA$L_STRINGCNT(R7)	; Bump characters in command string
	MOVB	R2,(R3)+		; Copy character to command string
35$:	SOBGTR	R0,30$			; Continue for all characters in put
	BRB	PARSE			; Done, parse command
40$:	DECL	R0			; One less character
	LOCC	#^A/!/,R0,1(R1)		; Scan remaining string for !
	BEQL	PARSE			; None end of line first
	INCL	R1			; Advance to next character
	BRB	35$			; Continue with line scan
50$:	MOVL	R3,R4			; Save string insertion pointer
	MOVL	TPA$L_STRINGCNT(R7),R5	; and current length
	MOVB	R2,(R3)+		; Copy to buffer anyway
	INCL	TPA$L_STRINGCNT(R7)	; Advance counter
	BRB	65$			; And check for end of string
60$:	MOVZBL	(R1)+,R2		; Get another character
	MOVB	R2,(R3)+		; Copy to buffer
	INCL	TPA$L_STRINGCNT(R7)	; Bump string count
	CMPB	#^A/ /,R2		; Blank?
	BEQL	65$			; Yes, still might be a continuation
	CMPB	#^A/!/,R2		; Is this a comment?
	BEQL	80$			; Branch if yes
	BRB	35$			; Not a continuation
65$:	SOBGTR	R0,60$			; Continue to end of line
70$:	MOVL	R4,R3			; Drop everything after continuation
	MOVL	R5,TPA$L_STRINGCNT(R7)	; By restoring count
	BRW	READLINE		; Read another line
80$:	DECL	R0			; One less character
	LOCC	#^A/!/,R0,1(R1)		; Scan for end of comment
	BEQL	70$			; None
	INCL	R1			; Skip trailing !
	BRB	65$			; and continue scan for end of line
PARSE:	MOVL	#TPA$K_COUNT0,TPA$L_COUNT(R7)	; Init count field
	BISL	#TPA$M_ABBREV,TPA$L_OPTIONS(R7)	; Permit abbreviations
	BICL2	#^C<BOOCMD$M_NOCHECK!-
		BOOCMD$M_SETOUTPUT!-
		BOOCMD$M_TERMINAL>,-
		BOO$GL_CMDOPT 		; Clear all options but specified
	CLRB	TPA$B_CHAR(R7)		; Last character parsed
	PUSHAB	KEYTBL			; Pass address of key table
	PUSHAB	STATE1			;  and state table
	PUSHL	R7			; Set address of parameter block
	CALLS	#3,G^LIB$TPARSE		; Parse input
	BLBS	R0,20$			; Branch if no syntax error
	BBS	#31,R0,15$		; Branch if error already given

.IF	NDF,CMDSW		; SYSBOOCMD 

	MSG	<-E-Syntax error>	; SYSBOOT error message

.IFF				; SYSGENCMD

	CMPL	#LIB$_SYNTAXERR,R0	; Tparse Syntax error ?
	BEQLU	10$			; Branch if yes
	TSTL	R0			; Zero ?
	BEQL	10$			; Branch if yes
	PUSHL	R0			; Push REAL error code
	CALLS	#1,G^LIB$SIGNAL		; Signal Error
	BRW	30$			; Continue

; Heuristically determine where syntax error occured

10$:	MOVZBL	TPA$B_CHAR(R7),R4	; Was there a character parsed ?
	BNEQ	12$			; Branch if yes
	MOVQ	TPA$L_STRINGCNT(R7),-(SP) ; Push entire read-in string
	BRB	14$			; Branch

12$:	SUBL3	TPA$L_TOKENCNT(R7),TPA$L_STRINGCNT(R7),R2 ; Length
	ADDL3	TPA$L_TOKENCNT(R7),TPA$L_STRINGPTR(R7),R3 ; Address
	CMPB	#^A'/',R4		; Was it a qualifier error ?
	BEQL	13$			; No
	MOVQ	R2,-(SP)		
	BRB	14$

13$:	LOCC	TPA$B_CHAR(R7),R2,(R3)  ; Find it then
	MOVQ	R0,-(SP)		; Push length and address
14$:	PUSHL	#2			; Number of FAO params
	PUSHL	#SYSG$_SYNTAX		; Error message
	CALLS	#4,G^LIB$SIGNAL		; Signal the error

.ENDC	

15$:	BRB	30$			; and get another command
20$:	MOVL	BOO$GL_CMDOPT,R6	; Get command option flags
	BBS	#BOOCMD$V_CONT,R6,EXIT	; Exit if continue flag
	BBC	#BOOCMD$V_DEFAULT,R6,30$ ; Read another command if Help
;
; The Default values for system parameters are selected and must be copied to 
; the current system parameter area.
;
	MOVQ	EXE$GQ_TODCBASE,SAVE_TODCBASE ; Save time base register
	MOVL	EXE$GL_TODR,SAVE_TODR	      ; Save time register

	MOVC3	#EXE$C_SYSPARSZ,-
		BOO$A_SYSPARAM,-
		EXE$A_SYSPARAM		; Copy defaults

	MOVQ	SAVE_TODCBASE,EXE$GQ_TODCBASE ; Restore
	MOVL	SAVE_TODR,EXE$GL_TODR	

	BBSS	#EXE$V_WRITESYSPARAMS,-	; Use default => write current needed
		G^EXE$GL_DYNAMIC_FLAGS,1$;
1$:
	MOVAL	BOO$GT_DEFAULT,-
		BOO$GL_PARINUSE		; Set default in use
30$:	BRW	READCMD			; Read more commands

EXIT:	MOVL	#1,R0			; Return success
	RET				;

	.PAGE
	.SBTTL	BOO$FILESPEC - Parse file spec
;+
;
; CALLING SEQUENCE:
; 
;	called as a TPARSE action routine
;
; INPUT:
;
;	The tparse parameter block (AP)
;
; OUTPUT:
;
;	A possible file spec is found.
;
; SIDE EFFECTS:
;
;	The tparse parameter block is updated.
;
;-

.Entry	BOO$FILESPEC, ^M<R2,R3,R4,R5,R6,R7>

	MOVL	TPA$L_STRINGPTR(AP),R2	; Get address of current parse
	MOVL	R2,TPA$L_TOKENPTR(AP)	; Set token pointer
	MOVL	R2,BOO$GL_FILEADDR	; Set file spec pointer
	MOVL	TPA$L_STRINGCNT(AP),R3	; Remainder of parse string length
	BEQL	100$			; Error if zero

	LOCC	#^A/ /,R3,(R2)		; is there a blank?
	BNEQ	50$			; Branch if yes
	LOCC	#^A@/@,R3,(R2)		; is there a slash?

50$:	MOVL	R0,TPA$L_STRINGCNT(AP)	; Remaining length
	MOVL	R1,TPA$L_STRINGPTR(AP)	; Address of blank or slash
	SUBL2	R2,R1			; Calculate length
	MOVL	R1,TPA$L_TOKENCNT(AP)	; Set length of file spec
	MOVB	R1,BOO$GB_FILELEN	; Set length of file spec	
60$:	MOVL	#SS$_NORMAL,R0		; Set success
	BRB	110$			; Exit

100$:	MOVL	#LIB$_SYNTAXERR,R0
110$:	RET

	.PAGE
	.SBTTL	BOO$USECUR - Use parameters from current image
BOO$USECUR::				; Set to current system values
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>;
	MOVAB	G^BOO$GT_SYSPARNAME,R0	; Get address of system .PAR file name
	MOVAL	PARMBLK,AP		; Get address of the TPARSE parameter block
	MOVZBL	(R0)+,TPA$L_TOKENCNT(AP); Set up for call to BOO$USEFILE
	MOVL	R0,TPA$L_TOKENPTR(AP)	;
	CALLG	(AP),G^BOO$USEFILE	; Call routine to process the .PAR file
	BLBC	R0,10$			; Branch to failure code
	BBCC	#EXE$V_WRITESYSPARAMS,-	; Use current => no write current needed
		G^EXE$GL_DYNAMIC_FLAGS,5$;
5$:	MOVAL	BOO$GT_CURRENT,-
		BOO$GL_PARINUSE		; Set parameters in use
10$:	MOVL	#1,R0			; Return success
	RET				;

	.PAGE			;
	.SBTTL	BOO$SHOWV - Routine to show one parameter value
;
; Input Parameters:
;	R4 - Pointer to PRM block to be displayed.
;
; Output Parameters:
;	Content of parameter block is displayed by calling RIO$OUTPUT_LINE
;
BOO$SHOWV:				;
	MOVL	(R4),R0			; Get address of value
	MOVAB	BOO$A_SYSPARAM[R0],R0	; Add current base address
	SUBL	#BOO$A_SYSPARAM,R0	;  and subtract link-time value
	MOVAQ	HEXSTR,R3		; Assume hex display
	BBS	#BOOCMD$V_DISHEX,-
		BOO$GL_CMDOPT,1$	; If set, then display hex
	MOVAQ	CTRLSTR,R3		; Assume not ascii data
	BBS	#PRM$V_ASCII,PRM$L_FLAGS(R4),2$ ; Branch if ascii
1$:	BRW	15$			;

;
; ASCII data
;
2$:	PUSHL	R5			; Save a register
	SUBL2	#16,SP			; Allocate a buffer on the stack
	MOVZBL	PRM$B_SIZE(R4),R2	; Get size (in bits)
	ASHL	#-3,R2,R2		; Convert size from bit to byte count
	MOVL	R2,R1			; Make a copy of the size
	CMPL	R2,#4			; Size > 4?
	BLEQ	3$			; If geq yes
	MOVL	#4,R1			; Max of 4 for default, max and min
3$:	SUBB3	R1,#5,BLANKS		; Calculate number of blank spaces needed
	PUSHR	#^M<R1,R2,R4>		; Save some registers
	MOVC5	R2,(R0),#^A/ /,#16,<3*4>(SP) ; Move the parameter value into the buffer
	POPR	#^M<R1,R2,R4>		; Restore the registers
	MOVL	SP,R3			; Save a pointer to the buffer
	SUBB3	R2,#17,CUR_BLANKS	; Calculate number of pad blanks
	PUSHAL	BOO$T_NODYNAMIC		; Assume not dynamic
	BBC	#PRM$V_DYNAMIC,PRM$L_FLAGS(R4),10$ ; Branch if not
	MOVAL	BOO$T_DYNAMIC,(SP)	; Change to dynamic string
10$:	PUSHAB	PRM$T_UNIT(R4)		; Stack address of unit name string
	PUSHAB	PRM$L_MAX(R4)		; Stack maximum value
	PUSHL	R1			;  and size
	PUSHAB	BLANKS			; Blanks for padding
	PUSHAB	PRM$L_MIN(R4)		; Minimum value
	PUSHL	R1			;  and size
	PUSHAB	BLANKS			; Blanks for padding
	PUSHAB	PRM$L_DEFAULT(R4)	; Default value
	PUSHL	R1			;  and size
	PUSHAB	BLANKS			; Blanks for padding
	PUSHL	R3			; Address of current value
	PUSHL	R2			;  and size
	PUSHAB	CUR_BLANKS		; Blanks for padding
	PUSHAB	PRM$T_NAME(R4)		; Stack address of parameter name
	PUSHAQ	RIO$AB_OUTBUF		; Stack address of buffer descriptor
	PUSHAL	RIO$GW_OUTLEN		; Set address of loc to receive size
	PUSHAQ	ASCSTR			; Control string for ascii

	CALLS	#18,SYS$FAO		; Format value for output
	ADDL2	#16,SP			; Remove the buffer from the stack
	POPL	R5			; Restore a register
	BRB	55$			; and join common code

;
; Decimal or hex display - R3 contains address of control string
;
15$:	BSBB	GETDATA			; Get data item according to size
	PUSHAL	BOO$T_NODYNAMIC		; Assume not dynamic
	BBC	#PRM$V_DYNAMIC,PRM$L_FLAGS(R4),20$ ; Branch if not
	MOVAL	BOO$T_DYNAMIC,(SP)	; Change to dynamic string
	
20$:	PUSHAB	PRM$T_UNIT(R4)		; Stack address of unit name string
	PUSHL	PRM$L_MAX(R4)		; Stack maximum value
	PUSHL	PRM$L_MIN(R4)		;  and minimum value
	PUSHL	PRM$L_DEFAULT(R4)	; Default value
	BITW	#PRM$M_NEG,PRM$L_FLAGS(R4)	; check for negated value
	BEQL	30$			; Branch if not
	MNEGL	(SP),(SP)		; Make absolute value
30$:	PUSHL	R1			; Current value
	PUSHAB	PRM$T_NAME(R4)		; Stack address of parameter name
	PUSHAQ	RIO$AB_OUTBUF		; Stack address of buffer descriptor
	PUSHAL	RIO$GW_OUTLEN		; Set address of loc to receive size
	PUSHL	R3			; Push address of control string

	CALLS	#10,SYS$FAO		; Format value for output
55$:	BLBC	R0,60$

	BSBW	RIO$OUTPUT_LINE		; Output the line
60$:	RSB				; and return

GETDATA:				;
	MOVZBL	PRM$B_POS(R4),R1	; GET SIZE OF DATUM
	EXTZV	R1,PRM$B_SIZE(R4),(R0),R1	; GET DATUM
	BITW	#PRM$M_NEG,PRM$L_FLAGS(R4)	; CHECK FOR NEGATED VALUE
	BEQL	10$			; NO
	MOVZBL	PRM$B_POS(R4),R1	; GET POSITION AGAIN
	EXTV	R1,PRM$B_SIZE(R4),(R0),R1	; CONVERT TO SIGNED NUMBER
	MNEGL	R1,R1			; ABSOLUTE VALUE
10$:	RSB				;

;
;	Show names of parameters
;
BOO$SHONAMES:			;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;
	MOVAB	BOO$A_PRMBLK,R6		; Set base of parameter blocks

10$:	MOVL	#5,R7			; Init argument count
	TSTL	(R6)			; At end of list?
	BEQL	90$			; Yes, finished
	MOVAL	PRM$T_NAME(R6),R1	; Set parameter name address
	MOVAB	PRM$C_LENGTH(R6),R6	; Next parameter block
	TSTL	(R6)			; At end of list?
	BEQL	70$			; yes
	MOVAL	PRM$T_NAME(R6),R2	; Set second address
	INCL	R7			; Advance argument count
	MOVAB	PRM$C_LENGTH(R6),R6	; Next argument
	TSTL	(R6)			; At end of list ?
	BEQL	70$			; yes
	MOVAL	PRM$T_NAME(R6),R3	; Set third address
	INCL	R7			; Another argument
	MOVAB	PRM$C_LENGTH(R6),R6	; Next parameter block
	TSTL	(R6)			; At end of list?
	BEQL	70$			; Yes
	INCL	R7			; another argument
	MOVAB	PRM$T_NAME(R6),R4	; Set fourth address
	MOVAL	PRM$C_LENGTH(R6),R6	; Next parameter block
70$:	PUSHR	#^M<R1,R2,R3,R4>	; Stack args
	SUBL3	#4,R7,-(SP)		; Set number of strings on line
	PUSHAQ	RIO$AB_OUTBUF		; Stack address of buffer descriptor
	PUSHAL	RIO$GW_OUTLEN		; Set address of loc to receive size
	PUSHAQ	NCTRLSTR		; Stack address of control string descr
	CALLS	R7,SYS$FAO		; Format value for output
	BLBC	R0,100$

	BSBW	RIO$OUTPUT_LINE		; Output line
	BRB	10$			; Loop

90$:	MOVL	#1,R0			; Success status
100$:	RET				; Return

;
; Show name of Startup command file
;
BOO$SHOSTART:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;
	
	MOVAB	L^EXE$GT_STARTUP,R0	; Set address of string
	$FAO_S	-
		CTRSTR	= SCTRLSTR,-	    ; Stack address of control string descr
		OUTLEN	= RIO$GW_OUTLEN,-   ; Set address of loc to receive size
		OUTBUF  = RIO$AB_OUTBUF,-   ; Stack address of buffer descriptor
		P1 	= R0 		    ; Set address of startup string
	BLBC	R0,10$

	BSBW	RIO$OUTPUT_LINE
10$:	RET				;

	.PAGE
	.SBTTL	BOO$NOCHECK - Disable value checking
;
; Disable Value Checking and Limiting
;
BOO$NOCHECK:	.WORD	0		;
	BBCS	#BOOCMD$V_NOCHECK,BOO$GL_CMDOPT,10$ ; Set value check inhibit
10$:	MOVL	#1,R0			; Return success
	RET				;
	.PAGE
	.SBTTL	BOO$NOCHECK - Disable value checking

;
; ENABLE VALUE CHECKING AND LIMITING
;
BOO$CHECK:				;
	.WORD	0			; Null entry mask
	BBCC	#BOOCMD$V_NOCHECK,BOO$GL_CMDOPT,10$ ; Clear check flag
10$:	MOVL	#1,R0			; Return with success
	RET				;

	.PAGE
	.SBTTL	BOO$SEARCH - Lookup parameter name
;
; Input Parameters:
;	TPA$L_TOKENCNT(AP) - Count of characters in token
;	TPA$L_TOKENPTR(AP) - Address of token
;
; Output Parameters:
;	TPA$L_PARAM(AP) - Address of PRM block for specified parameter
;			  name if found.
;	R0	- 0 => Name not found
;		  1 => Name found
;
BOO$SEARCH::	.WORD	^M<R2,R3,R4,R5>	;

	BBC	#BOOCMD$V_USEFILE, -
		BOO$GL_CMDOPT,5$	; Skip count check if not USE <file>

	CMPB	#3,TPA$L_TOKENCNT(AP)	; Check for count of characters
	BGEQ	50$			; Exit if if not > 3

5$:	MOVAB	BOO$A_PRMBLK,R4		; Set base of parameter blocks
10$:	TSTL	(R4)			; Check for end of list
	BNEQ	30$			; Not yet
	BRB	50$			; Symbol not found error
30$:	MOVAB	PRM$T_NAME(R4),R5	; Get pointer to name string
	CMPB	TPA$L_TOKENCNT(AP),(R5)+; Check for too many characters
	BGTR	35$			; Yes, cant be a match
	CMPC3	TPA$L_TOKENCNT(AP),-	;
		@TPA$L_TOKENPTR(AP),(R5); Is this a match?
	BEQL	40$			; Yes, return PRM pointer
35$:	MOVAB	PRM$C_LENGTH(R4),R4	; Advance to nex parameter descriptor
	BRB	10$			; and try another
40$:	MOVL	R4,TPA$L_PARAM(AP)	; Return address of parameter block
	MOVL	R4,BOO$GL_DOT		; And save as dot
	MOVL	#1,R0			; Indicate success
	RET				;  and return
50$:	BBS	#BOOCMD$V_USEFILE,BOO$GL_CMDOPT,60$; No message on 'USE filename'

.IF	NDF,CMDSW			; SYSBOOCMD 
	MSG	<-E-No such parameter>
.IFF					; SYSGENCMD
	PUSHL	#SYSG$_NOPARAM		; Set message
	CALLS	#1,G^LIB$SIGNAL		; Signal
.ENDC

60$:	MNEGL	#2,R0			; Give unique error code
	RET

;
; BOO$DOT - Use last parameter name if any
;
BOO$DOT:.WORD	0			; Null entry mask
	MOVL	BOO$GL_DOT,TPA$L_PARAM(AP)	; Get dot address
	BNEQ	10$			; Have pointer
	CLRL	R0			; Give error status
10$:	RET				;
	.PAGE
	.SBTTL	BOO$SETVALUE - Store parameter value
;
; Input Parameters:
;	TPA$L_PARAM - Address of parameter descriptor
;	TPA$L_NUMBER- Value to be checked and stored
;
; Output Parameters:
;	If value is within bounds set by parameter descriptor, the
;	value is moved to the address specified by the parameter descriptor
;	R0 - Completion status 0 => value out of allowable range
;			       1 => legal value successfully stored
;
BOO$SETVALUE::				;
	.WORD	^M<R4>			; Entry mask

	BBSS	#EXE$V_WRITESYSPARAMS,-	; Set a value => write current needed
		G^EXE$GL_DYNAMIC_FLAGS,1$;
1$:
	MOVL	TPA$L_PARAM(AP),R4	; Get pointer to parameter descriptor
	BBC	#PRM$V_ASCII,-		; Ascii parameter?
		PRM$L_FLAGS(R4),10$	; If BC no continue
	BRW	65$			; Branch to error
10$:	PUSHL	#1			; Assume good value
	BBS	#BOOCMD$V_NOCHECK,BOO$GL_CMDOPT,30$ ; Should values be checked
	MOVL	PRM$L_MIN(R4),R0	; Get minimum allowable value
	BLSS	20$			; No minimum
	CMPL	TPA$L_NUMBER(AP),R0	; Check input value
	BGEQU	20$			; Branch if above minimum
	MOVL	R0,TPA$L_NUMBER(AP)	; Use minimum value
	MNEGL	#2,(SP)			; Note bad value
20$:	MOVL	PRM$L_MAX(R4),R0	; Get maximum allowable value
	BLSS	30$			; Branch if no maximum
	CMPL	R0,TPA$L_NUMBER(AP)	; Check for maximum
	BGEQU	30$			; Continue if value legal
	MOVL	R0,TPA$L_NUMBER(AP)	; Limit to max value
	CLRL	(SP)			; Indicate error
30$:	MOVL	TPA$L_PARAM(AP),R0	; Get address at which to store
	MOVL	PRM$L_ADDR(R0),R0	; 
	MOVAB	BOO$A_SYSPARAM[R0],R0	; Add present base of parameters
	SUBL	#BOO$A_SYSPARAM,R0	; And subtract link-time base
	BITW	#PRM$M_NEG,PRM$L_FLAGS(R4)	; Check for negative
	BEQL	35$			; No
	MNEGL	TPA$L_NUMBER(AP),TPA$L_NUMBER(AP)	; Complement
35$:	MOVZBL	PRM$B_POS(R4),R1	; Get position
	INSV	TPA$L_NUMBER(AP),R1,PRM$B_SIZE(R4),(R0); Set value in field
40$:	MOVL	(SP)+,R0		; Get completion status
	BLSS	60$			; Low value limit
	BLBS	R0,50$			; Success, return

.IF	NDF,CMDSW		; SYSBOOCMD 

	MSG	<-W-Value set to maximum>
50$:	RET				; and return
60$:	MSG	<-W-Value set to minimum>
	RET				;
65$:	MSG	<-E-Parameter is not numeric type>
	RET

.IFF				; SYSGENCMD

	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_SETMAX		; Error status
	BRB	70$
50$:	RET

60$:	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_SETMIN		; Error status
	BRB	65$			;
65$:	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_NOTASCII		; Error status
70$:	CALLS	#3,G^LIB$SIGNAL		; Signal
	MOVL	#SS$_NORMAL,R0		; Set success
	RET				; and return

.ENDC

;
; Set to default value
;
BOO$SETDEF:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;
	MOVL	TPA$L_PARAM(AP),R4	; Get address of parameter block
	BBS	#PRM$V_ASCII,-		; Ascii parameter?
		PRM$L_FLAGS(R4),10$	; If BS yes
	MOVL	PRM$L_DEFAULT(R4),TPA$L_NUMBER(AP); Set default as value
	BRW	BOO$SETVALUE+2		; Call routine to set the value
10$:	MOVAB	PRM$L_DEFAULT(R4),TPA$L_TOKENPTR(AP); Set ptr to default string
	MOVZBL	PRM$B_SIZE(R4),R4	; Get size in bits
	ASHL	#-3,R4,TPA$L_TOKENCNT(AP); Set size in bytes
	BRB	BOO$SETASCII+2		; Call routine to set the default string

;
; Set acsii parameter to all blanks
;
BOO$SETBLANK:
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	CLRL	TPA$L_TOKENCNT(AP)	; Set string count zero (null string)
	BRB	BOO$SETASCII+2		; join common code

	.PAGE
	.SBTTL	BOO$SETASCII - Action routine to set ASCII parameter type
;
; Input Parameters:
;	TPA$L_PARAM(AP) - Address of parameter descriptor
;	TPA$L_TOKENCNT(AP) - Length of parsed string
;	TPA$L_TOKENPTR(AP) - Address of parsed string
;
; Output Parameters:
;	The parameter is checked to ensure it is ASCII type, then length
;	of the parsed string is compared to size of parameter.  If no
;	error, then parameter is set to new string.
;
BOO$SETASCII::
	.WORD	^M<R2,R3,R4,R5,R6,R7>

	BBSS	#EXE$V_WRITESYSPARAMS,-	; Set an value => write current needed
		G^EXE$GL_DYNAMIC_FLAGS,1$;
1$:
	BBCC	#TPA$V_BLANKS,TPA$L_OPTIONS(AP),2$; Make blanks no longer significant
2$:	MOVL	TPA$L_PARAM(AP),R6	; Get address of parameter block
	BBS	#PRM$V_ASCII,PRM$L_FLAGS(R6),-
		5$			; If set, then ASCII type
	BRW	90$			
5$:	MOVZBL	PRM$B_SIZE(R6),R7	; Get size (in bits)
	ASHL	#-3,R7,R7		; Convert size from bit to byte count
	CMPL	TPA$L_TOKENCNT(AP),R7	; Compare with parsed string size
	BLEQU	10$			; If LEQU, then fits
	BRW	80$			; Else string too big
10$:	PUSHL	#1			; Assume success
	SUBL	#16,SP			; Make room for octaword buffer on stack
	MOVL	TPA$L_TOKENPTR(AP),R3	; Get address of token
	MOVL	TPA$L_TOKENCNT(AP),R4	; Get count of token
	MOVC5	R4,(R3),#^A/ /,R7,(SP)	; New value on stack temporarily
	BBS	#BOOCMD$V_NOCHECK,BOO$GL_CMDOPT,30$ ; If checks disabled, branch
	CMPC5	R7,(SP),PRM$L_MIN(R6),-; Compare min value with parsed value
		#4,PRM$L_MIN(R6)	;
	BGEQU	20$			; Branch if input is greater
	MOVC5	#4,PRM$L_MIN(R6),-	; Set min value
		PRM$L_MIN(R6),R7,(SP)	;
	MNEGL	#2,16(SP)		; Ind error
	BRB	30$
20$:	CMPC5	#4,PRM$L_MAX(R6),-	; Compare max value with parsed value
		PRM$L_MAX(R6),R7,(SP)	;
	BGEQU	30$			; Branch if input is greater
	MOVC5	#4,PRM$L_MAX(R6),-	; Set max value
		PRM$L_MAX(R6),R7,(SP)	;
	CLRL	16(SP)			; Ind error
30$:	MOVL	PRM$L_ADDR(R6),R0	; Get address parameter
	MOVAB	BOO$A_SYSPARAM[R0],R0	; Add present base of parameters
	SUBL	#BOO$A_SYSPARAM,R0	; And subtract link-time base
	MOVC3	R7,(SP),(R0)		; Set value in system
	ADDL	#16,SP			; Remove value from stack
	MOVL	(SP)+,R0		; Get status
	BLSS	60$			; If neg, value set to min
	BLBS	R0,50$			; If LBS, success

.IF	NDF,CMDSW		; SYSBOOCMD 

	MSG	<-W-Value set to maximum>
50$:	RET			; and return
60$:	MSG	<-W-Value set to minimum>
	RET			;

.IFF				; SYSGENCMD

	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_SETMAX		; Error status
	BRB	70$
50$:	RET

60$:	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_SETMIN		; Error status
70$:	CALLS	#3,G^LIB$SIGNAL		; Signal
75$:	MOVL	#SS$_NORMAL,R0		; Set success
	RET			; and return

.ENDC

	.IF NDF,CMDSW			; SYSBOOCMD

80$:	
	MSG	<-E-Specified string is too long>
	RET

90$:	
	MSG	<-E-Parameter is not ASCII type>
	RET
	
	.IFF				; SYSGENCMD

80$:
	PUSHL	#SYSG$_STRTOOLNG	; Error status
	CALLS	#1,G^LIB$SIGNAL		; Output it
	BRB	75$

90$:
	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; FAO arg count
	PUSHL	#SYSG$_NOTASCII		; Error status
	CALLS	#3,G^LIB$SIGNAL		; Output it
	BRB	75$			

	.ENDC
	.PAGE
	.SBTTL	BOO$SHOVALUE - Action routine to show single value
;
; Input Parameters:
;	TPA$L_PARAMETER(AP) - Address of parameter block
;
BOO$SHOVALUE:				;
	.WORD	^M<R2,R3,R4,R5>		;
;
; Output header
;
.IF	DF,CMDSW			; SYSGEN Only
	BBC	#BOOCMD$V_TERMINAL,-	; Output header to terminals only
		BOO$GL_CMDOPT,10$	;
	.ENDC

	MOVC3	#SDVHDRLEN,-
		SDVHDR,RIO$AB_BUFFER	 ; Move in string
	MOVW	#SDVHDRLEN,RIO$GW_OUTLEN ; Set length
	BSBW	RIO$OUTPUT_LINE		 ; Output line

10$:	MOVL	TPA$L_PARAM(AP),R4	; Get address of parameter block
	BSBW	BOO$SHOWV		; Show value
	RET				; Return with BOO$SHOWV status

	.PAGE				
	.SBTTL	BOO$SHOALL - Action routine to show all parameter values
;
; Input Parameters:
; 	(AP)		Pointer to the TPARSE table
;	TPA$L_PARAM(AP)	The mask of acceptable types
; Output Parameters:
;	All parameters except special parameters are displayed.
;
BOO$SHOALL:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;

.IF	DF,CMDSW			; SYSGEN ONLY
	
	BBC	#BOOCMD$V_TERMINAL,-
		BOO$GL_CMDOPT,5$	; If terminal,
	CLRQ	-(SP)			;  clear the whole screen
	CALLS	#2,G^SCR$ERASE_PAGE	
5$:
;
; Format "Parameters in use message" 
;
	$FAO_S	CTRSTR = CTR_PARINUSE,-
		OUTLEN = RIO$GW_OUTLEN,-
		OUTBUF = RIO$AB_OUTBUF,-
		P1 = BOO$GL_PARINUSE
	BSBW	RIO$OUTPUT_LINE

.ENDC

	MOVC3	#SDVHDRLEN,-
		SDVHDR,RIO$AB_BUFFER	 ; Move in string
	MOVW	#SDVHDRLEN,RIO$GW_OUTLEN ; Set length
	BSBW	RIO$OUTPUT_LINE		 ; Output line

.IF	DF,CMDSW			; SYSGEN ONLY
	BBC	#BOOCMD$V_TERMINAL,-
		BOO$GL_CMDOPT,7$	; If terminal,
	PUSHL	#24			;  use only 24 lines
	PUSHL	#5			;  and scroll only the bottom portion
	CALLS	#2,G^SCR$SET_SCROLL	;  and setup a scrolling region
7$:
.ENDC

	MOVAB	BOO$A_PRMBLK,R4		; Set starting parameter block address
	MOVL	TPA$L_PARAM(AP),R5	; Set mask of acceptable types
;
; Loop through all parameters
;
10$:	TSTL	(R4)			; Check for end of list
	BEQL	50$			;  yes, done
	BBS	#PRM$V_ALL,R5,20$	; Branch if SHOW/ALL
	BITL	R5,PRM$L_FLAGS(R4)	; Is this one to output?
	BEQL	40$			; No, try another
20$:	BBC	#PRM$V_SPECIAL,-	; Yes, is it a special parameter?
		PRM$L_FLAGS(R4),30$	; Branch if not
	BBC	#PRM$V_SPECIAL,R5,40$	; It's special - branch if unasked for
30$:
	BSBW	BOO$SHOWV		; Display values
40$:	MOVAB	PRM$C_LENGTH(R4),R4	; Next parameter block
	BRB	10$			;
50$:

.IF	DF,CMDSW
	BBC	#BOOCMD$V_TERMINAL,-
		BOO$GL_CMDOPT,60$	; If terminal,
	PUSHL	#24			;  Use only 24 lines
	PUSHL	#1			;  and scroll only the bottom portion
	CALLS	#2,G^SCR$SET_SCROLL	;  and setup a scrolling region
60$:
.ENDC
	RET				;
	.PAGE				;
;
; Set name of startup command file
;
BOO$SETSTART:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;

	BBSS	#EXE$V_WRITESYSPARAMS,-	; Set startup name => write current needed
		G^EXE$GL_DYNAMIC_FLAGS,1$;
1$:
	MOVAB	L^EXE$GT_STARTUP,R6	; Point to slot for startup file name
	CLRL	R0			; Assume error
	CMPB	#31,BOO$GB_FILELEN	; Check for fit
	BGEQ	10$			; Continue if legal size
	RET				;
10$:	MOVZBL	BOO$GB_FILELEN,R0	; Get count
	MOVB	R0,(R6)+		; Set count for string
	MOVC3	R0,@BOO$GL_FILEADDR,(R6); Set file name
	MOVZWL	#1,R0			; Return success indication
	RET				;

	.PAGE
	.IF	NDF,CMDSW		; SYSBOOCMD ONLY

	.SBTTL	BOO$MSGOUT - Output message
;
; Calling Sequence:
;	BSBW	BOO$MSGOUT
;	.ASCIZ	message_string
;
BOO$MSGOUT::				;
	CLRQ	-(SP)			; Null read buffer
	PUSHL	8(SP)			; Address of string
	CALLS	#3,L^BOO$READPROMPT	; Output string
	LOCC	#0,#64000,@(SP)+	; Find end of string
	MOVL	#1,R0			; Set success code
	JMP	1(R1)			; Return to caller

;+
; This routine is in RMSCONIO for SYSGEN, is used here to map SYSBOOT
; calls to this routine into calls to BOO$READPROMPT.
;
; Inputs:
;	RIO$GW_OUTLEN - length of string to output
;	RIO$AB_BUFFER - buffer to output
;-

RIO$OUTPUT_LINE::

	MOVQ	R1,-(SP)		; Save R1,R2
	MOVZWL	RIO$GW_OUTLEN,R1	; Set length
	MOVAB	RIO$AB_BUFFER,R2	; Set address
	MOVAB	(R2)[R1],R1		; Set address of end of string
	MOVL	#^X00000A0D,(R1)	; Set CR, LF, zero byte at end
	
	CLRQ	-(SP)			; Null read buffer
	PUSHL	R2			; Address of string
	CALLS	#3,L^BOO$READPROMPT	; Output string

	MOVQ	(SP)+,R1		; Restore R1,R2
	RSB				; Return

	.PAGE
	.SBTTL	DUMMY COMMAND ROUTINES FOR COMMANDS NOT IN SYSBOOT
BOO$SET_OUTPUT::
BOO$USEACT::
SYS$ASCTOID::
SYS$FILESCAN::

	.WORD	0			; Null entry mask
	MSG	<-E-Syntax error>	; SYSBOOT error message
	MOVL	#1,R0			;
	RET				;

	.ENDC	; End of SYSBOOT conditional code

	.END				;
