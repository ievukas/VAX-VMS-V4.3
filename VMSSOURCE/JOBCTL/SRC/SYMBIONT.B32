MODULE SYMBIONT	(%TITLE	'Symbiont communication'
		IDENT = 'V04-000'
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:
!	Job controller.
!
! ABSTRACT:
!	This module contains the routines that communicate with symbionts.
!
! ENVIRONMENT:
!	VAX/VMS user and kernel mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 16-Feb-1982
!
! MODIFIED BY:
!
!	V03-016	JAK0232		J A Krycka	31-Aug-1984
!		Ensure that the display of the error message associated with
!		a symbiont deletion error message is not inhibited.
!
!	V03-015	JAK0228		J A Krycka	30-Aug-1984
!		Temporarily disable the pausing of a output queue upon
!		processing an operator request message.
!
!	V03-014	JAK0220		J A Krycka	18-Jul-1984
!		Support SJC$_PAGINATE at the queue level in addition to the
!		job and file levels.
!
!	V03-013	JAK0219		J A Krycka	17-Jul-1984
!		Track changes in JOBCTLDEF.REQ.
!
!	V03-012	JAK0206		J A Krycka	06-May-1984
!		Conditonally request image dump for symbiont process.
!
!	V03-011	GRR0011		Gregory R. Robert	19-Apr-1984
!		Enable image dump for symbiont process.
!
!	V03-010	JAK0200		J A Krycka	15-Mar-1984
!		Add IO$M_NORSWAIT function modifier to mailbox write.
!
!	V03-009	GRR0008		Gregory R. Robert	26-Sep-1983
!		Remove GRR0005 (LIB is already refereced in JOBCTLDEF).
!
!	V03-008	GRR0005		Gregory R. Robert	26-Sep-1983
!		Fetch symbiont definitions directly from LIB.
!
!	V03-007	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Change field names, track symbiont changes.
!
!	V03-006	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!	V03-005	MLJ0114		Martin L. Jack,	23-Jun-1983
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0113		Martin L. Jack,	26-May-1983
!		Changes for job controller baselevel.
!
!	V03-003	MLJ0112		Martin L. Jack,	29-Apr-1983
!		Changes for job controller and print symbiont baselevel.
!
!	V03-002	MLJ0110		Martin L. Jack,	18-Apr-1983
!		Correct failure to set stopped state in STOP_SYMBIONT_STREAM.
!
!	V03-001	MLJ0109		Martin L. Jack,	14-Apr-1983
!		Changes for job controller baselevel.
!
!**

REQUIRE 'SRC$:JOBCTLDEF';		! Job controller definitions


FORWARD ROUTINE
	OPERATOR_REQUEST_ACTION,
	OPERATOR_REQUEST:		NOVALUE,
	SEND_SYMBIONT_MESSAGE:		NOVALUE,
	START_SYMBIONT_TASK:		NOVALUE,
	STOP_SYMBIONT_TASK:		NOVALUE,
	PAUSE_SYMBIONT_TASK:		NOVALUE,
	RESUME_SYMBIONT_TASK:		NOVALUE,
	START_SYMBIONT_STREAM,
	STOP_SYMBIONT_STREAM:		NOVALUE,
	RESET_SYMBIONT_STREAM:		NOVALUE,
	PROCESS_SYMBIONT_MESSAGE:	NOVALUE,
	SYMBIONT_SERVICE:		NOVALUE,
	SYMBIONT_DELETION:		NOVALUE,
	DELETE_SYMBIONTS:		NOVALUE,
	SYMBIONT_COMPLETED_BLOCKS;


EXTERNAL ROUTINE
	ALLOCATE_MEMORY,
	COMPLETE_JOB:			NOVALUE,
	DEALLOCATE_MEMORY:		NOVALUE,
	DEALLOCATE_VARIABLE_DATA:	NOVALUE,
	ENQUEUE_JOB:			L_OUTPUT_2 NOVALUE,
	ENTER_PROCESS_DATA:		NOVALUE,
	FETCH_VARIABLE_DATA:		NOVALUE,
	FETCH_VARIABLE_ITEM,
	FETCH_VARIABLE_ITEM_LIST,
	FIND_PENDING_JOBS:		NOVALUE,
	LOCK_QUEUE_FILE:		NOVALUE,
	READ_RECORD,
	RELEASE_RECORD:			NOVALUE,
	REWRITE_RECORD:			NOVALUE,
	SCAN_INCOMPLETE_SERVICES:	NOVALUE,
	STORE_VARIABLE_DATA,
	UNLOCK_QUEUE_FILE:		NOVALUE,
	UPDATE_GETQUI_DATA:		NOVALUE;


EXTERNAL
	JOBCTLMBX_DESC,
	NLA0_DESC,
	OPA0_DESC;


! Symbiont control table.
!
MACRO
	SCT_L_FLINK=		0,0,32,0 %,	! Link to next SCT
	SCT_V_DELETING=		4,0,1,0 %,	! Symbiont is deleting itself
	SCT_B_MAXSTREAMS=	5,0,8,0 %,	! Maximum active streams
	SCT_W_MAILBOX=		6,0,16,0 %,	! Unit number of mailbox
	SCT_L_PID=		8,0,32,0 %,	! PID of symbiont process
	SCT_L_BITMAP=		12,0,32,0 %,	! Stream index allocation bitmap
	SCT_L_RESETTING=	16,0,32,0 %,	! Stream resetting bitmap
	SCT_T_PROCESSOR=	20,0,0,0 %,	! Image filename (ASCIC)
	SCT_L_QUEUES=		60,0,0,0 %;	! Base of 32 SMQ pointers


LITERAL
	SCT_K_MAXSTREAMS=	32;		! Maximum active streams


BUILTIN
	FFC,
	MOVC3,
	TESTBITSC;

ROUTINE OPERATOR_REQUEST_ACTION(MSG_DESC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This is an action routine for the $PUTMSG that issues an operator
!	request to the printer operator.  It writes the record to the operator
!	via OPCOM or via broadcast.
!
! INPUT PARAMETERS:
!	MSG_DESC	- Descriptor for message.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	FALSE, to signal $PUTMSG not to write the message.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	MSG_DESC:	REF BBLOCK;	! Descriptor for message text
LOCAL
	LENGTH:		WORD,		! Length of message, minimized
	OPC_BUFFER:	BBLOCK[$BYTEOFFSET(OPC$L_MS_TEXT) + 512],
					! Buffer for OPCOM message
	OPC_DESC:	VECTOR[2],	! Descriptor for message buffer
	STATUS;				! Status return


! Set up the OPCOM message buffer.
!
OPC_BUFFER[OPC$B_MS_TYPE] = OPC$_RQ_RQST;
OPC_BUFFER[OPC$B_MS_TARGET] = OPC$M_NM_PRINT;
OPC_BUFFER[OPC$W_MS_STATUS] = 0;
OPC_BUFFER[OPC$L_MS_RQSTID] = 0;
LENGTH = .MSG_DESC[DSC$W_LENGTH];
IF .LENGTH GTRU 512 THEN LENGTH = 512;
CH$MOVE(.LENGTH, .MSG_DESC[DSC$A_POINTER], OPC_BUFFER[OPC$L_MS_TEXT]);
OPC_DESC[0] = $BYTEOFFSET(OPC$L_MS_TEXT) + .LENGTH;
OPC_DESC[1] = OPC_BUFFER;


! Try to send the message by OPCOM.  If this fails, send a broadcast to the
! system console.
!
STATUS = $SNDOPR(MSGBUF=OPC_DESC);
IF NOT .STATUS OR .STATUS EQL OPC$_NOPERATOR
THEN
    $BRKTHRU(
	MSGBUF=.MSG_DESC,
	SENDTO=OPA0_DESC,
	SNDTYP=BRK$C_DEVICE,
	TIMOUT=10);


! Return FALSE, to signal $PUTMSG not to write the message.
!
FALSE
END;

ROUTINE OPERATOR_REQUEST(SMQ,SJH): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats and writes an operator request message to the
!	printer operator.
!
! INPUT PARAMETERS:
!	SMQ		- Pointer to SMQ.
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Message written to operator.
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	SJH:		REF BBLOCK;	! Pointer to SJH
LOCAL
	MSGVEC:		VECTOR[9],	! $PUTMSG message vector
	BUFFER:		VECTOR[132,BYTE]; ! User's operator request text


! Fetch the user's operator request message.
!
FETCH_VARIABLE_DATA(
    SJH$S_OPERATOR_REQUEST, SJH[SJH$T_OPERATOR_REQUEST],
    %ALLOCATION(BUFFER), BUFFER);


! Format the $PUTMSG buffer.
!
MSGVEC[0] = 8;
MSGVEC[1] = JBC$_REQUEST;
MSGVEC[2] = 6;
MSGVEC[3] = SMQ[SMQ$T_NAME];
MSGVEC[4] = SJH[SJH$T_NAME];
MSGVEC[5] = SJH$S_USERNAME;
MSGVEC[6] = SJH[SJH$T_USERNAME];
MSGVEC[7] = .BBLOCK[SJH[SJH$T_OPERATOR_REQUEST], FVDF_LENGTH];
MSGVEC[8] = BUFFER;
$PUTMSG(MSGVEC=MSGVEC, ACTRTN=OPERATOR_REQUEST_ACTION);
END;

ROUTINE SEND_SYMBIONT_MESSAGE(SMQ,MSG_DESC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends a message to a specified symbiont.
!
! INPUT PARAMETERS:
!	SMQ		- Pointer to SMQ.
!	MSG_DESC	- Descriptor for message.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Message written to mailbox.
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,	! Pointer to SMQ.
	MSG_DESC:	REF BBLOCK;	! Descriptor for message
LOCAL
	STATUS;				! Status return


! Write the message without waiting.
!
STATUS = $QIO(
    FUNC=IO$_WRITEVBLK OR IO$M_NOW OR IO$M_NORSWAIT,
    CHAN=.BBLOCK[.SMQ[SMQ$L_STREAM_SCT], SCT_W_MAILBOX],
    P1=.MSG_DESC[DSC$A_POINTER],
    P2=.MSG_DESC[DSC$W_LENGTH]);
IF NOT .STATUS THEN SIGNAL(JBC$_WRISMBMBX OR STS$K_ERROR, 0, .STATUS);
END;

GLOBAL ROUTINE START_SYMBIONT_TASK(SMQ_N,SMQ,SJH_N,SJH,SQR_N,SQR): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends the "start task" message to a symbiont.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!	SQR_N		- Record number of SQR.
!	SQR		- Pointer to SQR.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,		! Pointer to SMQ
	SJH:		REF BBLOCK,		! Pointer to SJH
	SQR:		REF BBLOCK;		! Pointer to SQR
LOCAL
	FIRST_FILE,				! True if first file in job
	LAST_FILE,				! True if last file in job
	SFM:		REF BBLOCK,		! Pointer to SFM
	QSMQ:		REF BBLOCK,		! Pointer to job's SMQ
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


! Read the form definition.
!
SFM = READ_RECORD(.SJH[SJH$L_FORM_LINK]);


! Message header.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_START_TASK;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_REQUEST_HEADER;


! Account name.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = SJH$S_ACCOUNT;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_ACCOUNT_NAME;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(SJH$S_ACCOUNT),
    SJH[SJH$T_ACCOUNT],
    .SMBITM; ,,, SMBITM);


! After time.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = SJH$S_AFTER_TIME;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_AFTER_TIME;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
COPY_TIME(SJH[SJH$Q_AFTER_TIME], .SMBITM);
SMBITM = .SMBITM + SJH$S_AFTER_TIME;


! Form bottom margin.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_BOTTOM_MARGIN;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SFM[SFM$B_MARGIN_BOTTOM];
SMBITM = .SMBITM + 4;


! Characteristics.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = SJH$S_CHARACTERISTICS;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_CHARACTERISTICS;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(SJH$S_CHARACTERISTICS),
    SJH[SJH$T_CHARACTERISTICS],
    .SMBITM; ,,, SMBITM);


! Checkpoint data.
!
IF .SJH[SJH$L_CURRENT_FILE_CHKPT] EQL .SQR_N
AND .SJH[SJH$B_JOB_COPIES_CHKPT] EQL .SJH[SJH$B_JOB_COPIES_DONE]
AND .SJH[SJH$B_FILE_COPIES_CHKPT] EQL .SJH[SJH$B_FILE_COPIES_DONE]
THEN
    SMBITM = FETCH_VARIABLE_ITEM(
	SJH$S_CHECKPOINT, SJH[SJH$T_CHECKPOINT],
	SMBMSG$K_CHECKPOINT_DATA,
	.SMBITM);
    

! Entry number.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_ENTRY_NUMBER;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SJH[SYM$L_ENTRY_NUMBER];
SMBITM = .SMBITM + 4;


! File copies.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FILE_COPIES;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SQR[SQR$B_FILE_COPIES];
SMBITM = .SMBITM + 4;


! File copy number.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FILE_COUNT;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SJH[SJH$B_FILE_COPIES_DONE] + 1;
SMBITM = .SMBITM + 4;


! File setup modules.
!
SMBITM = FETCH_VARIABLE_ITEM(
    SQR$S_FILE_SETUP_MODULES, SQR[SQR$T_FILE_SETUP_MODULES],
    SMBMSG$K_FILE_SETUP_MODULES,
    .SMBITM);


! First page number.
!
IF .SQR[SQR$L_FIRST_PAGE] NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FIRST_PAGE;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    .SMBITM = .SQR[SQR$L_FIRST_PAGE];
    SMBITM = .SMBITM + 4;
    END;


! Form length.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FORM_LENGTH;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SFM[SFM$B_LENGTH];
SMBITM = .SMBITM + 4;


! Form name.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(SFM[SFM$T_NAME]);
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FORM_NAME;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(CH$RCHAR(SFM[SFM$T_NAME])),
    SFM[SFM$T_NAME] + 1,
    .SMBITM; ,,, SMBITM);


! Form setup modules.
!
SMBITM = FETCH_VARIABLE_ITEM(
    SFM$S_FORM_SETUP_MODULES, SFM[SFM$T_FORM_SETUP_MODULES],
    SMBMSG$K_FORM_SETUP_MODULES,
    .SMBITM);


! Form width.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FORM_WIDTH;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SFM[SFM$W_WIDTH];
SMBITM = .SMBITM + 4;


! File identification or condition vector.
!
IF CH$RCHAR(SQR[SQR$T_FILE_ID_DVI]) NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = SQR$S_FILE_IDENTIFICATION;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FILE_IDENTIFICATION;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    MOVC3(
	%REF(SQR$S_FILE_IDENTIFICATION),
	SQR[SQR$T_FILE_IDENTIFICATION],
	.SMBITM; ,,, SMBITM);
    END
ELSE
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = SQR$S_CONDITION_VECTOR;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_MESSAGE_VECTOR;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    MOVC3(
	%REF(SQR$S_CONDITION_VECTOR),
	SQR[SQR$L_CONDITION_1],
	.SMBITM; ,,, SMBITM);
    END;


! File specification.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(SQR[SQR$T_FILE_SPECIFICATION]);
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_FILE_SPECIFICATION;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(CH$RCHAR(SQR[SQR$T_FILE_SPECIFICATION])),
    SQR[SQR$T_FILE_SPECIFICATION]+1,
    .SMBITM; ,,, SMBITM);


! Job copies.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_JOB_COPIES;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SJH[SJH$B_JOB_COPIES];
SMBITM = .SMBITM + 4;


! Job copy number.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_JOB_COUNT;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SJH[SJH$B_JOB_COPIES_DONE] + 1;
SMBITM = .SMBITM + 4;


! Job name.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(SJH[SJH$T_NAME]);
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_JOB_NAME;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(CH$RCHAR(SJH[SJH$T_NAME])),
    SJH[SJH$T_NAME]+1,
    .SMBITM; ,,, SMBITM);


! Job reset modules.
!
SMBITM = FETCH_VARIABLE_ITEM(
    SMQ$S_JOB_RESET_MODULES, SMQ[SMQ$T_JOB_RESET_MODULES],
    SMBMSG$K_JOB_RESET_MODULES,
    .SMBITM);


! Last page number.
!
IF .SQR[SQR$L_LAST_PAGE] NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_LAST_PAGE;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    .SMBITM = .SQR[SQR$L_LAST_PAGE];
    SMBITM = .SMBITM + 4;
    END;


! Form left margin.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_LEFT_MARGIN;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SFM[SFM$W_MARGIN_LEFT];
SMBITM = .SMBITM + 4;


! Note.
!
SMBITM = FETCH_VARIABLE_ITEM(
    SJH$S_NOTE, SJH[SJH$T_NOTE],
    SMBMSG$K_NOTE,
    .SMBITM);


! Page setup modules.
!
SMBITM = FETCH_VARIABLE_ITEM(
    SFM$S_PAGE_SETUP_MODULES, SFM[SFM$T_PAGE_SETUP_MODULES],
    SMBMSG$K_PAGE_SETUP_MODULES,
    .SMBITM);


! Parameters.
!
SMBITM = FETCH_VARIABLE_ITEM_LIST(
    SJH$S_PARAMETERS, SJH[SJH$T_PARAMETERS],
    SMBMSG$K_PARAMETER_1,
    .SMBITM);


! Print control flags.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_PRINT_CONTROL;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = 0;
IF .SQR[SQR$V_DOUBLE_SPACE] THEN SMBITM[SMBMSG$V_DOUBLE_SPACE] = TRUE;
IF .SQR[SQR$V_PAGE_HEADER] THEN SMBITM[SMBMSG$V_PAGE_HEADER] = TRUE;
IF .SQR[SQR$V_PASSALL] THEN SMBITM[SMBMSG$V_PASSALL] = TRUE;
IF .SFM[SFM$V_SHEET_FEED] THEN SMBITM[SMBMSG$V_SHEET_FEED] = TRUE;
IF .SFM[SFM$V_TRUNCATE] THEN SMBITM[SMBMSG$V_TRUNCATE] = TRUE;
IF .SFM[SFM$V_WRAP] THEN SMBITM[SMBMSG$V_WRAP] = TRUE;


! Compute paginate bit.
!
IF .SQR[SQR$V_PAGINATE_EXPLICIT]
THEN
    BEGIN
    IF .SQR[SQR$V_PAGINATE]
    THEN
	SMBITM[SMBMSG$V_PAGINATE] = TRUE;
    END

ELSE IF .SJH[SJH$V_PAGINATE_EXPLICIT]
THEN
    BEGIN
    IF .SJH[SJH$V_PAGINATE]
    THEN
	SMBITM[SMBMSG$V_PAGINATE] = TRUE;
    END

ELSE
    BEGIN
    IF .SMQ[SMQ$V_PAGINATE]
    THEN
	SMBITM[SMBMSG$V_PAGINATE] = TRUE;
    END;

SMBITM = .SMBITM + 4;


! Separation control flags.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_SEPARATION_CONTROL;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = 0;
IF .BBLOCK[SMQ[SMQ$T_JOB_RESET_MODULES], FVDF_LENGTH] NEQ 0
    THEN SMBITM[SMBMSG$V_JOB_RESET_ABORT] = TRUE;


! Special actions for the first file in the job.
!
FIRST_FILE = FALSE;
IF
    (.SJH[SJH$B_JOB_COPIES_DONE] EQL 0
    AND .SJH[SJH$B_FILE_COPIES_DONE] EQL 0
    AND .SJH[SJH$L_FILE_LIST] EQL .SQR_N)
OR
    .SJH[SJH$V_RESTARTING]
THEN
    BEGIN
    SJH[SJH$V_RESTARTING] = FALSE;
    IF .SMQ[SMQ$V_JOB_FLAG] THEN SMBITM[SMBMSG$V_JOB_FLAG] = TRUE;
    IF .SMQ[SMQ$V_JOB_BURST] THEN SMBITM[SMBMSG$V_JOB_BURST] = TRUE;
    FIRST_FILE = TRUE;
    END;


! Compute file burst bit.
!
IF .SQR[SQR$V_FILE_BURST_EXPLICIT]
THEN
    BEGIN
    IF .SQR[SQR$V_FILE_BURST]
    THEN
	SMBITM[SMBMSG$V_FILE_BURST] = TRUE;
    END

ELSE IF .SJH[SJH$V_FILE_BURST_EXPLICIT]
THEN
    BEGIN
    IF .SJH[SJH$V_FILE_BURST]
    OR (.SJH[SJH$V_FILE_BURST_ONE] AND .FIRST_FILE)
    THEN
	SMBITM[SMBMSG$V_FILE_BURST] = TRUE;
    END

ELSE
    BEGIN
    IF .SMQ[SMQ$V_FILE_BURST]
    OR (.SMQ[SMQ$V_FILE_BURST_ONE] AND .FIRST_FILE)
    THEN
	SMBITM[SMBMSG$V_FILE_BURST] = TRUE;
    END;


! Compute file flag bit.
!
IF .SQR[SQR$V_FILE_FLAG_EXPLICIT]
THEN
    BEGIN
    IF .SQR[SQR$V_FILE_FLAG]
    THEN
	SMBITM[SMBMSG$V_FILE_FLAG] = TRUE;
    END

ELSE IF .SJH[SJH$V_FILE_FLAG_EXPLICIT]
THEN
    BEGIN
    IF .SJH[SJH$V_FILE_FLAG]
    OR (.SJH[SJH$V_FILE_FLAG_ONE] AND .FIRST_FILE)
    THEN
	SMBITM[SMBMSG$V_FILE_FLAG] = TRUE;
    END

ELSE
    BEGIN
    IF .SMQ[SMQ$V_FILE_FLAG]
    OR (.SMQ[SMQ$V_FILE_FLAG_ONE] AND .FIRST_FILE)
    THEN
	SMBITM[SMBMSG$V_FILE_FLAG] = TRUE;
    END;


! Special actions for last file in job.
!
LAST_FILE = FALSE;
IF .SJH[SJH$B_JOB_COPIES_DONE] + 1 GEQU .SJH[SJH$B_JOB_COPIES]
AND .SJH[SJH$B_FILE_COPIES_DONE] + 1 GEQU .SQR[SQR$B_FILE_COPIES]
AND .SQR[SYM$L_LINK] EQL 0
THEN
    BEGIN
    IF .SMQ[SMQ$V_JOB_TRAILER] THEN SMBITM[SMBMSG$V_JOB_TRAILER] = TRUE;
    IF .BBLOCK[SMQ[SMQ$T_JOB_RESET_MODULES], FVDF_LENGTH] NEQ 0
	THEN SMBITM[SMBMSG$V_JOB_RESET] = TRUE;
    LAST_FILE = TRUE;
    END;


! Compute file trailer bits.
!
IF .SQR[SQR$V_FILE_TRAILER_EXPLICIT]
THEN
    BEGIN
    IF .SQR[SQR$V_FILE_TRAILER]
    THEN
	BEGIN
	SMBITM[SMBMSG$V_FILE_TRAILER] = TRUE;
	SMBITM[SMBMSG$V_FILE_TRAILER_ABORT] = TRUE;
	END;
    END

ELSE IF .SJH[SJH$V_FILE_TRAILER_EXPLICIT]
THEN
    BEGIN
    IF .SJH[SJH$V_FILE_TRAILER]
    THEN
	BEGIN
	SMBITM[SMBMSG$V_FILE_TRAILER] = TRUE;
	SMBITM[SMBMSG$V_FILE_TRAILER_ABORT] = TRUE;
	END

    ELSE IF .SJH[SJH$V_FILE_TRAILER_ONE]
    THEN
	BEGIN
	IF .LAST_FILE THEN SMBITM[SMBMSG$V_FILE_TRAILER] = TRUE;
	SMBITM[SMBMSG$V_FILE_TRAILER_ABORT] = TRUE;
	END;
    END

ELSE
    BEGIN
    IF .SMQ[SMQ$V_FILE_TRAILER]
    THEN
	BEGIN
	SMBITM[SMBMSG$V_FILE_TRAILER] = TRUE;
	SMBITM[SMBMSG$V_FILE_TRAILER_ABORT] = TRUE;
	END

    ELSE IF .SMQ[SMQ$V_FILE_TRAILER_ONE]
    THEN
	BEGIN
	IF .LAST_FILE THEN SMBITM[SMBMSG$V_FILE_TRAILER] = TRUE;
	SMBITM[SMBMSG$V_FILE_TRAILER_ABORT] = TRUE;
	END;
    END;
SMBITM = .SMBITM + 4;


! Request control flags.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_REQUEST_CONTROL;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = 0;
IF .SJH[SJH$V_RESTARTING] THEN SMBITM[SMBMSG$V_RESTARTING] = TRUE;
IF .BBLOCK[SJH[SJH$T_OPERATOR_REQUEST], FVDF_LENGTH] NEQ 0
AND .FIRST_FILE
THEN
    BEGIN
    SMQ[SMQ$V_OPERATOR_REQUEST] = TRUE;
    SMBITM[SMBMSG$V_PAUSE_COMPLETE] = FALSE;	! Temporarily cleared (V03-015)
    END;
SMBITM = .SMBITM + 4;


! Job priority.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_PRIORITY;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SJH[SJH$B_PRIORITY];
SMBITM = .SMBITM + 4;


! Queue name.
!
QSMQ = READ_RECORD(.SJH[SJH$L_QUEUE_LINK]);
SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(QSMQ[SMQ$T_NAME]);
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_QUEUE;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(CH$RCHAR(QSMQ[SMQ$T_NAME])),
    QSMQ[SMQ$T_NAME]+1,
    .SMBITM; ,,, SMBITM);
RELEASE_RECORD(.SJH[SJH$L_QUEUE_LINK]);


! Form right margin.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_RIGHT_MARGIN;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SFM[SFM$W_MARGIN_RIGHT];
SMBITM = .SMBITM + 4;


! Time queued.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = SJH$S_TIME;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_TIME_QUEUED;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
COPY_TIME(SJH[SJH$Q_TIME], .SMBITM);
SMBITM = .SMBITM + SJH$S_TIME;


! Form top margin.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_TOP_MARGIN;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SFM[SFM$B_MARGIN_TOP];
SMBITM = .SMBITM + 4;


! UIC.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_UIC;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = .SJH[SJH$L_UIC];
SMBITM = .SMBITM + 4;


! User name.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = SJH$S_USERNAME;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_USER_NAME;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(SJH$S_USERNAME),
    SJH[SJH$T_USERNAME],
    .SMBITM; ,,, SMBITM);


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);


! Update SMQ.
!
SMQ[SMQ$L_FORM_LINK] = .SJH[SJH$L_FORM_LINK];


! Update SJH.
!
SJH[SJH$L_CURRENT_FILE_CHKPT] = .SQR_N;
SJH[SJH$B_JOB_COPIES_CHKPT] = .SJH[SJH$B_JOB_COPIES_DONE];
SJH[SJH$B_FILE_COPIES_CHKPT] = .SJH[SJH$B_FILE_COPIES_DONE];
SJH[SJH$L_CURRENT_FILE_LINK] = .SQR_N;
DEALLOCATE_VARIABLE_DATA(
    SJH$S_CHECKPOINT,
    SJH[SJH$T_CHECKPOINT]);
SJH[SJH$V_EXECUTING] = TRUE;
SJH[SJH$V_FILE_STARTING] = TRUE;
RELEASE_RECORD(.SJH[SJH$L_FORM_LINK]);
END;

GLOBAL ROUTINE STOP_SYMBIONT_TASK(SMQ_N,SMQ,SJH_N,SJH): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends the "stop task" message to a symbiont.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,		! Pointer to SMQ
	SJH:		REF BBLOCK;		! Pointer to SJH
LOCAL
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


! Message header.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_STOP_TASK;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_REQUEST_HEADER;


! Reason for stop.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_STOP_CONDITION;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
.SMBITM = JBC$_JOBABORT OR STS$K_ERROR;
IF .SJH[SJH$V_REQUEUE] THEN .SMBITM = JBC$_JOBREQUEUE OR STS$K_ERROR;
SMBITM = .SMBITM + 4;


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);
END;

GLOBAL ROUTINE PAUSE_SYMBIONT_TASK(SMQ_N,SMQ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends the "pause task" message to a symbiont.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


! Message header.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_PAUSE_TASK;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_REQUEST_HEADER;


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);


! Update SMQ.
!
SMQ[SMQ$V_PAUSING] = TRUE;
END;

GLOBAL ROUTINE RESUME_SYMBIONT_TASK(SMQ_N,SMQ,FLAGS,ALIGNMENT_PAGES,RELATIVE_PAGE,SEARCH_LENGTH,SEARCH_ADDRESS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends the "resume task" message to a symbiont.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!	FLAGS		- Resume control flags.
!	ALIGNMENT_PAGES	- Number of alignment pages (or 0).
!	RELATIVE_PAGE	- Relative page position (or 0).
!	SEARCH_LENGTH	- Descriptor for search string (or 0).
!	SEARCH_ADDRESS	-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	FLAGS:		BBLOCK;		! Resume control flags
LOCAL
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


! Message header.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_RESUME_TASK;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_REQUEST_HEADER;


! Alignment pages.
!
IF .ALIGNMENT_PAGES NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_ALIGNMENT_PAGES;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    .SMBITM = .ALIGNMENT_PAGES;
    SMBITM = .SMBITM + 4;
    END;


! File repositioning.
!
IF .RELATIVE_PAGE NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_RELATIVE_PAGE;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    .SMBITM = .RELATIVE_PAGE;
    SMBITM = .SMBITM + 4;
    END;


! Request control flags.
!
IF .FLAGS NEQ 0 OR .ALIGNMENT_PAGES NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = 4;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_REQUEST_CONTROL;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    .SMBITM = 0;
    IF .FLAGS[ISRV_V_ALIGNMENT_MASK]
	THEN SMBITM[SMBMSG$V_ALIGNMENT_MASK] = TRUE;
    IF .ALIGNMENT_PAGES NEQ 0
	THEN SMBITM[SMBMSG$V_PAUSE_COMPLETE] = TRUE;
    IF .FLAGS[ISRV_V_TOP_OF_FILE]
	THEN SMBITM[SMBMSG$V_TOP_OF_FILE] = TRUE;
    SMBITM = .SMBITM + 4;
    END;


! Search string.
!
IF .SEARCH_LENGTH NEQ 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = .SEARCH_LENGTH;
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_SEARCH_STRING;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    MOVC3(
	SEARCH_LENGTH,
	.SEARCH_ADDRESS,
	.SMBITM; ,,, SMBITM);
    END;


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);


! Update SMQ.
!
SMQ[SMQ$V_RESUMING] = TRUE;
IF .ALIGNMENT_PAGES NEQ 0 THEN SMQ[SMQ$V_ALIGNING] = TRUE;
END;

GLOBAL ROUTINE START_SYMBIONT_STREAM(SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine starts a symbiont stream.  If necessary, it creates a
!	symbiont process and then sends the "start stream" message.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SCT:		REF BBLOCK,	! Pointer to SCT
	STM,				! Stream index
	PRCNAM_BUFFER:	VECTOR[15,BYTE],! Buffer for process name
	PRCNAM_DESC:	VECTOR[2],	! Descriptor for process name
	PRCNAM,				! Process name parameter
	IMAGE_BUFFER:	VECTOR[63,BYTE],! Buffer for image name
	IMAGE_DESC:	VECTOR[2],	! Descriptor for image name
	MAILBOX_BUFFER:	VECTOR[30,BYTE],! Buffer for mailbox name
	MAILBOX_DESC:	VECTOR[2],	! Descriptor for mailbox name
	GETDVI_LIST:	BBLOCK[16],	! $GETDVI item list
	IOSB:		VECTOR[4,WORD],	! I/O status block
	STATUS_1,			! Status return
	STATUS_2,			! Status return
	STATUS_3,			! Status return
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


OWN
	PRIVILEGE_MASK:	BBLOCK[8]	! Symbiont privileges
	    PSECT(CODE) PRESET(
		[PRV$V_SETPRV] = TRUE);


! Find a suitable symbiont.
!
SCT = .SYMBIONT_CONTROL;
WHILE .SCT NEQ 0 DO
    BEGIN

    ! Locate a symbiont that is executing the desired image, that is not
    ! deleting itself, and has an available stream.
    !
    IF CH$EQL(
	CH$RCHAR(SMQ[SMQ$T_PROCESSOR]),
	SMQ[SMQ$T_PROCESSOR] + 1,
	CH$RCHAR(SCT[SCT_T_PROCESSOR]),
	SCT[SCT_T_PROCESSOR] + 1)
    AND NOT .SCT[SCT_V_DELETING]
    AND NOT FFC(
	%REF(0), %REF(.SCT[SCT_B_MAXSTREAMS]), SCT[SCT_L_BITMAP], STM)
    THEN
	EXITLOOP;


    ! Advance to next.
    !
    SCT = .SCT[SCT_L_FLINK];
    END;


! No suitable symbiont found; create a new one.
!
IF .SCT EQL 0
THEN
    BEGIN
    SCT = ALLOCATE_MEMORY();
    SCT[SCT_L_FLINK] = .SYMBIONT_CONTROL;
    SCT[SCT_B_MAXSTREAMS] = SCT_K_MAXSTREAMS;
    CH$MOVE(
	SMQ$S_PROCESSOR,
	SMQ[SMQ$T_PROCESSOR],
	SCT[SCT_T_PROCESSOR]);
    SYMBIONT_CONTROL = .SCT;
    STM = 0;
    END;


! Create a symbiont process if needed.
!
IF .SCT[SCT_L_BITMAP] EQL 0
THEN
    BEGIN

    ! Set up the process name as "SYMBIONT_nnnn".
    !
    PRCNAM_DESC[0] = %ALLOCATION(PRCNAM_BUFFER);
    PRCNAM_DESC[1] = PRCNAM_BUFFER;
    SYMBIONT_COUNT = .SYMBIONT_COUNT + 1;
    $FAO(
	$DESCRIPTOR('SYMBIONT_!4ZL'),
	PRCNAM_DESC,
	PRCNAM_DESC,
	.SYMBIONT_COUNT);


    ! Set up the image name as "SYS$SYSTEM:name.EXE".
    !
    IMAGE_DESC[0] = %ALLOCATION(IMAGE_BUFFER);
    IMAGE_DESC[1] = IMAGE_BUFFER;
    $FAO(
	$DESCRIPTOR('SYS$SYSTEM:!AC.EXE'),
	IMAGE_DESC,
	IMAGE_DESC,
	(IF CH$RCHAR(SMQ[SMQ$T_PROCESSOR]) EQL 0
	    THEN UPLIT BYTE (%ASCIC 'PRTSMB')
	    ELSE SMQ[SMQ$T_PROCESSOR]));


    ! Create the symbiont input mailbox.
    !
    STATUS_1 = $CREMBX(
	CHAN=SCT[SCT_W_MAILBOX],
	MAXMSG=JBC$K_SMBMBXSIZ,
	BUFQUO=JBC$K_SMBMBXSIZ,
	PROMSK=%B'1111111100000000');	! S:RWED, O:RWED, G, W
    IF NOT .STATUS_1
    THEN
	BEGIN
	SYMBIONT_CONTROL = .SCT[SCT_L_FLINK];
	DEALLOCATE_MEMORY(.SCT);
	RETURN .STATUS_1;
	END;


    ! Get a descriptor for the mailbox device name.
    !
    MAILBOX_DESC[0] = 0;
    MAILBOX_DESC[1] = MAILBOX_BUFFER;
    GETDVI_LIST[0,0,16,0] = %ALLOCATION(MAILBOX_BUFFER);
    GETDVI_LIST[2,0,16,0] = DVI$_DEVNAM;
    GETDVI_LIST[4,0,32,0] = MAILBOX_BUFFER;
    GETDVI_LIST[8,0,32,0] = MAILBOX_DESC;
    GETDVI_LIST[12,0,32,0] = 0;
    STATUS_2 = $GETDVIW(
	EFN=JBC$K_SYNC_EFN,
	CHAN=.SCT[SCT_W_MAILBOX],
	ITMLST=GETDVI_LIST,
	IOSB=IOSB);
    IF NOT .STATUS_2
    THEN
	BEGIN
	$DASSGN(CHAN=.SCT[SCT_W_MAILBOX]);
	SYMBIONT_CONTROL = .SCT[SCT_L_FLINK];
	DEALLOCATE_MEMORY(.SCT);
	RETURN .STATUS_2;
	END;


    ! The following loop is executed at most twice.
    !
    PRCNAM = PRCNAM_DESC;
    WHILE TRUE DO
	BEGIN

	! Create the symbiont process.
	!
	STATUS_3 = $CREPRC(
	    PIDADR=SCT[SCT_L_PID],
	    IMAGE=IMAGE_DESC,
	    INPUT=MAILBOX_DESC,
	    OUTPUT=JOBCTLMBX_DESC,
	    ERROR=NLA0_DESC,
	    PRVADR=PRIVILEGE_MASK,
	    QUOTA=JBC_QUOTAS,
	    PRCNAM=.PRCNAM,
	    BASPRI=.SMQ[SMQ$B_BASE_PRIORITY],
	    STSFLG=.IMAGE_DUMP_STSFLG,
	    UIC=.JBC_UIC);

	IF NOT .STATUS_3
	THEN
	    BEGIN

	    ! Create failed.  If the status is not "duplicate process name", or
	    ! if a create has already been tried with no name, give up.
	    ! Otherwise, loop to try creation with no name.
	    !
	    IF .STATUS_3<0,16> NEQ SS$_DUPLNAM OR .PRCNAM EQL 0
	    THEN
		BEGIN
		$DASSGN(CHAN=.SCT[SCT_W_MAILBOX]);
		SYMBIONT_CONTROL = .SCT[SCT_L_FLINK];
		DEALLOCATE_MEMORY(.SCT);
		SCAN_INCOMPLETE_SERVICES(ISRV_K_PURGE_SMQ, .SMQ_N);
		RETURN .STATUS_3;
		END;
	    PRCNAM = 0;
	    END
	ELSE
	    BEGIN
	    ENTER_PROCESS_DATA(PDE_K_SYMBIONT, .SCT[SCT_L_PID]);
	    QUEUE_REFERENCE_COUNT = .QUEUE_REFERENCE_COUNT + 1;
	    EXITLOOP;
	    END;
	END;
    END;


! Update SMQ.
!
SMQ[SMQ$L_STREAM_SCT] = .SCT;
SMQ[SMQ$B_STREAM_INDEX] = .STM;
SMQ[SMQ$V_STARTING] = TRUE;
SMQ[SMQ$V_STOPPED] = FALSE;


! Update SCT.
!
BITVECTOR[SCT[SCT_L_BITMAP], .STM] = TRUE;
VECTOR[SCT[SCT_L_QUEUES], .STM] = .SMQ_N;


! Message header for the "start stream" command.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_START_STREAM;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_REQUEST_HEADER;


! Device name.
!
IF CH$RCHAR(SMQ[SMQ$T_DEVICE_NAME]) EQL 0
THEN
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(SMQ[SMQ$T_NAME]);
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_DEVICE_NAME;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    MOVC3(
	%REF(CH$RCHAR(SMQ[SMQ$T_NAME])),
	SMQ[SMQ$T_NAME] + 1,
	.SMBITM; ,,, SMBITM);
    END
ELSE
    BEGIN
    SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(SMQ[SMQ$T_DEVICE_NAME]);
    SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_DEVICE_NAME;
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
    MOVC3(
	%REF(CH$RCHAR(SMQ[SMQ$T_DEVICE_NAME])),
	SMQ[SMQ$T_DEVICE_NAME] + 1,
	.SMBITM; ,,, SMBITM);
    END;


! Queue name.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = CH$RCHAR(SMQ[SMQ$T_NAME]);
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_EXECUTOR_QUEUE;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(CH$RCHAR(SMQ[SMQ$T_NAME])),
    SMQ[SMQ$T_NAME] + 1,
    .SMBITM; ,,, SMBITM);


! Job reset modules.
!
SMBITM = FETCH_VARIABLE_ITEM(
    SMQ$S_JOB_RESET_MODULES, SMQ[SMQ$T_JOB_RESET_MODULES],
    SMBMSG$K_JOB_RESET_MODULES,
    .SMBITM);


! Device control library name.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = %CHARCOUNT('SYS$LIBRARY:.TLB') + CH$RCHAR(SMQ[SMQ$T_LIBRARY]);
IF CH$RCHAR(SMQ[SMQ$T_LIBRARY]) EQL 0 THEN SMBITM[SMBMSG$W_ITEM_SIZE] = %CHARCOUNT('SYS$LIBRARY:SYSDEVCTL.TLB');
SMBITM[SMBMSG$W_ITEM_CODE] = SMBMSG$K_LIBRARY_SPECIFICATION;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;
MOVC3(
    %REF(%CHARCOUNT('SYS$LIBRARY:')),
    UPLIT BYTE('SYS$LIBRARY:'),
    .SMBITM; ,,, SMBITM);
IF CH$RCHAR(SMQ[SMQ$T_LIBRARY]) EQL 0
THEN
    MOVC3(
	%REF(%CHARCOUNT('SYSDEVCTL')),
	UPLIT BYTE ('SYSDEVCTL'),
	.SMBITM; ,,, SMBITM)
ELSE
    MOVC3(
	%REF(CH$RCHAR(SMQ[SMQ$T_LIBRARY])),
	SMQ[SMQ$T_LIBRARY] + 1,
	.SMBITM; ,,, SMBITM);
.SMBITM = '.TLB';
SMBITM = .SMBITM + 4;


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);


SS$_NORMAL
END;

GLOBAL ROUTINE STOP_SYMBIONT_STREAM(SMQ_N,SMQ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends the "stop stream" message to a symbiont.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SCT:		REF BBLOCK,	! Pointer to SCT
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


! Message header.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_STOP_STREAM;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_ITEM_HEADER;


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);


! Update SMQ.
!
SMQ[SMQ$V_STOPPING] = TRUE;
SMQ[SMQ$V_STOPPED] = TRUE;
END;

GLOBAL ROUTINE RESET_SYMBIONT_STREAM(SMQ_N,SMQ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sends the "reset stream" message to a symbiont.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SCT:		REF BBLOCK,	! Pointer to SCT
	SMBMSG:		BBLOCK[JBC$K_SMBMBXSIZ],! Message buffer
	SMBITM:		REF BBLOCK,		! Cursor for message items
	SMBMSG_DESC:	VECTOR[2];		! Descriptor for message buffer


! Message header.
!
SMBMSG[SMBMSG$W_REQUEST_CODE] = SMBMSG$K_RESET_STREAM;
SMBMSG[SMBMSG$B_STRUCTURE_LEVEL] = SMBMSG$K_STRUCTURE_LEVEL;
SMBMSG[SMBMSG$B_STREAM_INDEX] = .SMQ[SMQ$B_STREAM_INDEX];
SMBITM = SMBMSG + SMBMSG$S_REQUEST_HEADER;


! Trailing zero item.
!
SMBITM[SMBMSG$W_ITEM_SIZE] = 0;
SMBITM[SMBMSG$W_ITEM_CODE] = 0;
SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


! Send the message to the symbiont.
!
SMBMSG_DESC[1] = SMBMSG;
SMBMSG_DESC[0] = .SMBITM - .SMBMSG_DESC[1];
SEND_SYMBIONT_MESSAGE(.SMQ, SMBMSG_DESC);


! Update SCT.
!
SCT = .SMQ[SMQ$L_STREAM_SCT];
BITVECTOR[SCT[SCT_L_RESETTING], .SMQ[SMQ$B_STREAM_INDEX]] = TRUE;
VECTOR[SCT[SCT_L_QUEUES], .SMQ[SMQ$B_STREAM_INDEX]] = 0;
END;

ROUTINE PROCESS_SYMBIONT_MESSAGE(SMQ_N,SMQ,SCT): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes a symbiont response message.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!	SCT		- Pointer to SCT.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:			REF BBLOCK,	! Pointer to SMQ
	SCT:			REF BBLOCK;	! Pointer to SCT
LOCAL
	SMBITM:			REF BBLOCK,	! Cursor for symbiont message
	REQUEST_RESPONSE,			! Symbiont request response
	CONDITION_VECTOR:	VECTOR[3],	! Status of current request
	SRQ_TYPE,				! SRQ type to be completed
	SJH_N,					! Record number of SJH
	SJH:			REF BBLOCK;	! Pointer to SJH


SMBITM = .MBX + SMBMSG$S_REQUEST_HEADER;
REQUEST_RESPONSE = SMBMSG$K_TASK_STATUS;
CONDITION_VECTOR[0] = JBC$_NORMAL;
CONDITION_VECTOR[1] = 0;
CONDITION_VECTOR[2] = 0;


! Read the current job record, if any.
!
SJH_N = .SMQ[SMQ$L_CURRENT_LIST];
IF .SJH_N NEQ 0 THEN SJH = READ_RECORD(.SJH_N);


! Process the message's item list.
!
WHILE .SMBITM LSSA .MBX_END DO
    BEGIN
    LOCAL
	ITEM_CODE,			! Code of current item
	ITEM_SIZE;			! Size of current item


    ! Get the size and item code of the current item.
    !
    ITEM_SIZE = .SMBITM[SMBMSG$W_ITEM_SIZE];
    ITEM_CODE = .SMBITM[SMBMSG$W_ITEM_CODE];
    SMBITM = .SMBITM + SMBMSG$S_ITEM_HEADER;


    ! Process the item.
    !
    CASE .ITEM_CODE FROM 0 TO SMBMSG$K_USER_NAME OF
	SET


	[INRANGE, OUTRANGE]:
	    CONDITION_VECTOR[0] = JBC$_INVMSG OR STS$K_ERROR;


	[0]:
	    EXITLOOP;


	[SMBMSG$K_ACCOUNTING_DATA]:
	    BEGIN
	    IF .ITEM_SIZE EQL SMBMSG$S_ACCOUNTING_DATA
	    THEN
		BEGIN
		SMQ[SMQ$L_ACM_GETCNT] =
		    .SMQ[SMQ$L_ACM_GETCNT] + .SMBITM[SMBMSG$L_RMS_GETS];
		SMQ[SMQ$L_ACM_QIOCNT] =
		    .SMQ[SMQ$L_ACM_QIOCNT] + .SMBITM[SMBMSG$L_QIO_PUTS];
		SMQ[SMQ$L_ACM_PAGECNT] =
		    .SMQ[SMQ$L_ACM_PAGECNT] + .SMBITM[SMBMSG$L_PAGES_PRINTED];
		SMQ[SMQ$L_ACM_SYMCPUTIM] =
		    .SMQ[SMQ$L_ACM_SYMCPUTIM] + .SMBITM[SMBMSG$L_CPU_TIME];
		END;
	    END;


	[SMBMSG$K_CHECKPOINT_DATA]:
	    BEGIN
	    LOCAL
		SAVED_CHECKPOINT:	BBLOCK[SJH$S_CHECKPOINT];

	    IF .SJH_N NEQ 0
	    THEN
		BEGIN
		CH$MOVE(
		    SJH$S_CHECKPOINT,
		    SJH[SJH$T_CHECKPOINT],
		    SAVED_CHECKPOINT);
		CH$FILL(0, SJH$S_CHECKPOINT, SJH[SJH$T_CHECKPOINT]);

		IF STORE_VARIABLE_DATA(
		    .SJH,
		    SJH$S_CHECKPOINT,
		    SJH[SJH$T_CHECKPOINT],
		    SYM$K_CHECKPOINT,
		    .ITEM_SIZE,
		    .SMBITM)
		THEN
		    DEALLOCATE_VARIABLE_DATA(
			SJH$S_CHECKPOINT,
			SAVED_CHECKPOINT)
		ELSE
		    CH$MOVE(
			SJH$S_CHECKPOINT,
			SAVED_CHECKPOINT,
			SJH[SJH$T_CHECKPOINT]);
		END;
	    END;


	[SMBMSG$K_CONDITION_VECTOR]:
	    BEGIN
	    CH$COPY(
		.ITEM_SIZE, .SMBITM,
		0,
		%ALLOCATION(CONDITION_VECTOR), CONDITION_VECTOR);
	    END;


	[SMBMSG$K_DEVICE_STATUS]:
	    BEGIN
	    IF .ITEM_SIZE EQL SMBMSG$S_DEVICE_STATUS
	    THEN
		BEGIN
		SMQ[SMQ$V_LOWERCASE] = FALSE;
		SMQ[SMQ$V_REMOTE] = FALSE;
		SMQ[SMQ$V_SERVER] = FALSE;
		SMQ[SMQ$V_STALLED] = FALSE;
		SMQ[SMQ$V_TERMINAL] = FALSE;
		SMQ[SMQ$V_UNAVAILABLE] = FALSE;
		IF .SMBITM[SMBMSG$V_LOWERCASE]
		    THEN SMQ[SMQ$V_LOWERCASE] = TRUE;
		IF .SMBITM[SMBMSG$V_PAUSE_TASK]
		    THEN SMQ[SMQ$V_PAUSED] = TRUE;
		IF .SMBITM[SMBMSG$V_REMOTE]
		    THEN SMQ[SMQ$V_REMOTE] = TRUE;
		IF .SMBITM[SMBMSG$V_SERVER]
		    THEN SMQ[SMQ$V_SERVER] = TRUE;
		IF .SMBITM[SMBMSG$V_STALLED]
		    THEN SMQ[SMQ$V_STALLED] = TRUE;
		IF .SMBITM[SMBMSG$V_STOP_STREAM]
		    THEN SMQ[SMQ$V_STOPPED] = TRUE;
		IF .SMBITM[SMBMSG$V_TERMINAL]
		    THEN SMQ[SMQ$V_TERMINAL] = TRUE;
		IF .SMBITM[SMBMSG$V_UNAVAILABLE]
		    THEN SMQ[SMQ$V_UNAVAILABLE] = TRUE;
		END;
	    END;


	[SMBMSG$K_MAXIMUM_STREAMS]:
	    BEGIN
	    IF .ITEM_SIZE EQL 4
	    THEN
		SCT[SCT_B_MAXSTREAMS] = ..SMBITM;
	    END;


	[SMBMSG$K_REFUSE_REASON]:
	    BEGIN
	    LOCAL
		SAVED_REFUSAL_REASON:	BBLOCK[SJH$S_REFUSAL_REASON];

	    IF .SJH_N NEQ 0
	    THEN
		BEGIN
		CH$MOVE(
		    SJH$S_REFUSAL_REASON,
		    SJH[SJH$T_REFUSAL_REASON],
		    SAVED_REFUSAL_REASON);
		CH$FILL(0, SJH$S_REFUSAL_REASON, SJH[SJH$T_REFUSAL_REASON]);

		IF STORE_VARIABLE_DATA(
		    .SJH,
		    SJH$S_REFUSAL_REASON,
		    SJH[SJH$T_REFUSAL_REASON],
		    SYM$K_REFUSAL_REASON,
		    .ITEM_SIZE,
		    .SMBITM)
		THEN
		    DEALLOCATE_VARIABLE_DATA(
			SJH$S_REFUSAL_REASON,
			SAVED_REFUSAL_REASON)
		ELSE
		    CH$MOVE(
			SJH$S_REFUSAL_REASON,
			SAVED_REFUSAL_REASON,
			SJH[SJH$T_REFUSAL_REASON]);

		SJH[SJH$V_REFUSED] = TRUE;
		END;
	    END;


	[SMBMSG$K_REQUEST_RESPONSE]:
	    BEGIN
	    IF .ITEM_SIZE EQL 4
	    THEN
		IF ..SMBITM GEQU SMBMSG$K_PAUSE_TASK
		AND ..SMBITM LEQU SMBMSG$K_TASK_STATUS
		THEN
		    REQUEST_RESPONSE = ..SMBITM;
	    END;


	TES;


    SMBITM = .SMBITM + .ITEM_SIZE;
    END;


! Update state based on the request status.
!
SRQ_TYPE = 0;
CASE .REQUEST_RESPONSE FROM SMBMSG$K_PAUSE_TASK TO SMBMSG$K_TASK_STATUS OF
    SET


    [SMBMSG$K_PAUSE_TASK]:
	BEGIN
	IF .CONDITION_VECTOR[0]
	THEN
	    SMQ[SMQ$V_PAUSED] = TRUE;
	SMQ[SMQ$V_PAUSING] = FALSE;
	END;


    [SMBMSG$K_RESET_STREAM]:
	0;


    [SMBMSG$K_RESUME_TASK]:
	BEGIN
	IF .CONDITION_VECTOR[0]
	THEN
	    BEGIN
	    SMQ[SMQ$V_OPERATOR_REQUEST] = FALSE;
	    SMQ[SMQ$V_PAUSED] = FALSE;
	    IF .SMQ[SMQ$V_ALIGNING] THEN SMQ[SMQ$V_PAUSED] = TRUE;
	    END;
	SMQ[SMQ$V_ALIGNING] = FALSE;
	SMQ[SMQ$V_RESUMING] = FALSE;
	END;


    [SMBMSG$K_START_STREAM]:
	BEGIN
	SRQ_TYPE = SRQ$K_START_SYMBIONT;
	SMQ[SMQ$V_STARTING] = FALSE;
	IF NOT .CONDITION_VECTOR[0]
	THEN
	    BEGIN
	    IF .SMQ[SMQ$B_STREAM_INDEX] GTRU .SCT[SCT_B_MAXSTREAMS]
	    THEN
		BEGIN
		BITVECTOR[SCT[SCT_L_BITMAP], .SMQ[SMQ$B_STREAM_INDEX]] = FALSE;
		VECTOR[SCT[SCT_L_QUEUES], .SMQ[SMQ$B_STREAM_INDEX]] = 0;
		CONDITION_VECTOR[0] = START_SYMBIONT_STREAM(.SMQ_N, .SMQ);
		IF .CONDITION_VECTOR[0] THEN RETURN;
		END
	    ELSE
		SMQ[SMQ$V_STOPPED] = TRUE;
	    END;
	END;


    [SMBMSG$K_START_TASK]:
	BEGIN
	IF .SJH_N NEQ 0
	THEN
	    SJH[SJH$V_FILE_STARTING] = FALSE;

	IF NOT .CONDITION_VECTOR[0]
	OR .SJH[SJH$V_REFUSED]
	THEN
	    REQUEST_RESPONSE = SMBMSG$K_TASK_COMPLETE
	ELSE
	    BEGIN
	    IF .SMQ[SMQ$V_OPERATOR_REQUEST]
	    THEN
		BEGIN
		SMQ[SMQ$V_PAUSED] = FALSE;	! Temporarily cleared (V03-015)
		SMQ[SMQ$V_OPERATOR_REQUEST] = FALSE;	! Temp. added (V03-015)
		IF .SJH_N NEQ 0 THEN OPERATOR_REQUEST(.SMQ, .SJH);
		END;
	    END;
	END;


    [SMBMSG$K_STOP_STREAM]:
	BEGIN
	BITVECTOR[SCT[SCT_L_BITMAP], .SMQ[SMQ$B_STREAM_INDEX]] = FALSE;
	VECTOR[SCT[SCT_L_QUEUES], .SMQ[SMQ$B_STREAM_INDEX]] = 0;
	IF .SCT[SCT_L_BITMAP] EQL 0 THEN SCT[SCT_V_DELETING] = TRUE;
	SMQ[SMQ$L_STREAM_SCT] = 0;
	SMQ[SMQ$B_STREAM_INDEX] = 0;
	SMQ[SMQ$V_PAUSED] = FALSE;
	SMQ[SMQ$V_STALLED] = FALSE;
	SMQ[SMQ$V_STOPPING] = FALSE;
	END;


    [SMBMSG$K_STOP_TASK, SMBMSG$K_TASK_COMPLETE]:
	BEGIN
	IF .SMQ[SMQ$V_PAUSING] THEN SMQ[SMQ$V_PAUSED] = TRUE;
	SMQ[SMQ$V_ALIGNING] = FALSE;
	SMQ[SMQ$V_OPERATOR_REQUEST] = FALSE;
	SMQ[SMQ$V_PAUSING] = FALSE;
	SMQ[SMQ$V_RESUMING] = FALSE;
	END;


    [SMBMSG$K_TASK_STATUS]:
	0;


    TES;


! If an incomplete service has completed, notify the requestor.
!
IF .SRQ_TYPE NEQ 0
THEN
    SCAN_INCOMPLETE_SERVICES(
	ISRV_K_SYMBIONT,
	.SMQ_N, .SMQ,
	.SRQ_TYPE,
	.CONDITION_VECTOR[0]);


! If the stream is not available for new work, we are done.
!
IF NOT ONEOF_(.REQUEST_RESPONSE,
    BMSK_(
	SMBMSG$K_START_STREAM,
	SMBMSG$K_STOP_TASK,
	SMBMSG$K_TASK_COMPLETE))
THEN
    BEGIN
    IF .SJH_N NEQ 0 THEN REWRITE_RECORD(.SJH_N);
    RETURN;
    END;


! Handle multi-copy and multi-file situations.
!
IF .SJH_N NEQ 0
THEN
    BEGIN

    ! Update the job status with the received status.
    !
    IF .SJH[SJH$L_CONDITION_1] EQL 0
    OR (.SJH[SJH$L_CONDITION_1] AND NOT .CONDITION_VECTOR[0])
    THEN
	CH$MOVE(
	    SJH$S_CONDITION_VECTOR,
	    CONDITION_VECTOR,
	    SJH[SJH$L_CONDITION_1]);


    IF .SJH[SJH$V_REFUSED]
    THEN
	BEGIN
	UPDATE_GETQUI_DATA(.SJH_N, .SJH);
	ENQUEUE_JOB(.SJH_N, .SJH);
	SMQ[SMQ$L_CURRENT_LIST] = 0;
	SMQ[SMQ$L_CURRENT_LIST_END] = 0;
	SMQ[SMQ$B_CURRENT_JOB_COUNT] = 0;
	END


    ELSE IF .SJH[SJH$V_ABORTED]
    THEN
	BEGIN
	UPDATE_GETQUI_DATA(.SJH_N, .SJH);
	COMPLETE_JOB(.SJH_N, .SJH, .SMQ, 0);
	SJH_N = 0;
	SMQ[SMQ$L_CURRENT_LIST] = 0;
	SMQ[SMQ$L_CURRENT_LIST_END] = 0;
	SMQ[SMQ$B_CURRENT_JOB_COUNT] = 0;
	END


    ELSE
	BEGIN
	LOCAL
	    SQR_N,			! Record number of SQR
	    SQR:	REF BBLOCK;	! Pointer to SQR


	SQR = READ_RECORD(SQR_N = .SJH[SJH$L_CURRENT_FILE_LINK]);


	SJH[SJH$L_COMPLETED_BLOCKS] =
	    .SJH[SJH$L_COMPLETED_BLOCKS] + .SQR[SQR$L_FILE_SIZE];
	SJH[SJH$L_CURRENT_FILE_CHKPT] = 0;
	SJH[SJH$B_JOB_COPIES_CHKPT] = 0;
	SJH[SJH$B_FILE_COPIES_CHKPT] = 0;
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_CHECKPOINT,
	    SJH[SJH$T_CHECKPOINT]);


	SJH[SJH$B_FILE_COPIES_DONE] = .SJH[SJH$B_FILE_COPIES_DONE] + 1;
	IF .SJH[SJH$B_FILE_COPIES_DONE] GEQU .SQR[SQR$B_FILE_COPIES]
	THEN
	    BEGIN
	    IF .SQR[SYM$L_LINK] EQL 0
	    THEN
		BEGIN
		SJH[SJH$B_JOB_COPIES_DONE] = .SJH[SJH$B_JOB_COPIES_DONE] + 1;
		IF .SJH[SJH$B_JOB_COPIES_DONE] GEQU .SJH[SJH$B_JOB_COPIES]
		THEN
		    BEGIN
		    RELEASE_RECORD(.SQR_N);
		    UPDATE_GETQUI_DATA(.SJH_N, .SJH);
		    COMPLETE_JOB(.SJH_N, .SJH, .SMQ, 0);
		    SJH_N = 0;
		    SMQ[SMQ$L_CURRENT_LIST] = 0;
		    SMQ[SMQ$L_CURRENT_LIST_END] = 0;
		    SMQ[SMQ$B_CURRENT_JOB_COUNT] = 0;
		    END
		ELSE
		    BEGIN
		    LOCAL
			SQR_N2,			! Record number of SQR
			SQR_2:	REF BBLOCK;	! Pointer to SQR

		    SQR_2 = READ_RECORD(SQR_N2 = .SJH[SJH$L_FILE_LIST]);
		    SJH[SJH$B_FILE_COPIES_DONE] = 0;
		    START_SYMBIONT_TASK(
			.SMQ_N, .SMQ,
			.SJH_N, .SJH,
			.SQR_N2, .SQR_2);
		    END
		END
	    ELSE
		BEGIN
		LOCAL
		    SQR_N2,				! Record number of SQR
		    SQR_2:		REF BBLOCK;	! Pointer to SQR

		SQR_2 = READ_RECORD(SQR_N2 = .SQR[SYM$L_LINK]);
		SJH[SJH$B_FILE_COPIES_DONE] = 0;
		START_SYMBIONT_TASK(
		    .SMQ_N, .SMQ,
		    .SJH_N, .SJH,
		    .SQR_N2, .SQR_2);
		END
	    END
	ELSE
	    BEGIN
	    START_SYMBIONT_TASK(
		.SMQ_N, .SMQ,
		.SJH_N, .SJH,
		.SQR_N, .SQR);
	    END
	END;
    END;


! Rewrite the job header, if any.
!
IF .SJH_N NEQ 0 THEN REWRITE_RECORD(.SJH_N);


! Find the next work item for the symbiont.
!
IF .SMQ[SMQ$B_CURRENT_JOB_COUNT] EQL 0
THEN
    IF .SMQ[SMQ$V_STOPPED]
    THEN
	STOP_SYMBIONT_STREAM(.SMQ_N, .SMQ)
    ELSE
	FIND_PENDING_JOBS(.SMQ_N, .SMQ);
END;

GLOBAL ROUTINE SYMBIONT_SERVICE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the message type:
!		MSG$_SMBINI		symbiont has completed assignment
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SCT:		REF BBLOCK;	! Pointer to SCT


! Validate the message structure level.
!
IF .MBX[SMBMSG$B_STRUCTURE_LEVEL] NEQ SMBMSG$K_STRUCTURE_LEVEL
OR .MBX[SMBMSG$B_STREAM_INDEX] GEQU SCT_K_MAXSTREAMS
THEN
    BEGIN
    SIGNAL(JBC$_INVMSG OR STS$K_ERROR);
    RETURN;
    END;


! Search the symbiont control table for the PID of the process that sent the
! message, which is in the second longword of the IOSB.  If found, locate the
! queue corresponding to the stream identifier.
!
SCT = .SYMBIONT_CONTROL;
WHILE .SCT NEQ 0 DO
    BEGIN
    IF .SCT[SCT_L_PID] EQL .MBX[ACM$L_PROCID]
    THEN
	BEGIN
	LOCAL
	    SMQ_N,				! Record number of SMQ
	    SMQ:		REF BBLOCK;	! Pointer to SMQ


	! Update SCT for a resetting stream.
	!
	IF .BITVECTOR[SCT[SCT_L_RESETTING], .MBX[SMBMSG$B_STREAM_INDEX]]
	THEN
	    BEGIN
	    BITVECTOR[SCT[SCT_L_RESETTING], .MBX[SMBMSG$B_STREAM_INDEX]] = FALSE;
	    BITVECTOR[SCT[SCT_L_BITMAP], .MBX[SMBMSG$B_STREAM_INDEX]] = FALSE;
	    IF .SCT[SCT_L_BITMAP] EQL 0 THEN SCT[SCT_V_DELETING] = TRUE;
	    RETURN;
	    END;


	! Get the queue header corresponding to the stream index, and ensure
	! that it is an active stream.
	!
	SMQ_N = .VECTOR[SCT[SCT_L_QUEUES], .MBX[SMBMSG$B_STREAM_INDEX]];
	IF .SMQ_N NEQ 0
	THEN
	    BEGIN

	    ! Read the queue header.
	    !
	    LOCK_QUEUE_FILE();
	    SMQ = READ_RECORD(.SMQ_N);


	    ! Ensure that the record is a queue header that is connected to this
	    ! stream.  If it is, process the message.
	    !
	    IF .SMQ[SYM$B_TYPE] EQL SYM$K_SMQ
	    AND .SMQ[SMQ$L_STREAM_SCT] EQL .SCT
	    AND .SMQ[SMQ$B_STREAM_INDEX] EQL .MBX[SMBMSG$B_STREAM_INDEX]
	    THEN
		BEGIN
		PROCESS_SYMBIONT_MESSAGE(.SMQ_N, .SMQ, .SCT);
		REWRITE_RECORD(.SMQ_N);
		END;


	    UNLOCK_QUEUE_FILE();
	    END;
	RETURN;
	END;


    SCT = .SCT[SCT_L_FLINK];
    END;


! The PID was not found in the symbiont control table.
!
SIGNAL(JBC$_INVMSG OR STS$K_ERROR);
END;

GLOBAL ROUTINE SYMBIONT_DELETION: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine checks for and processes the deletion of a symbiont.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PREV,				! Pointer to predecessor of SCT
	SCT:		REF BBLOCK,	! Pointer to symbiont control table
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK;	! Pointer to SMQ


PREV = SYMBIONT_CONTROL;
SCT = ..PREV;
WHILE .SCT NEQ 0 DO
    BEGIN
    IF .SCT[SCT_L_PID] EQL .MBX[ACM$L_PID]
    THEN
	BEGIN

	! If this process deletion is unexpected, do extra processing.
	!
	IF (.SCT[SCT_L_BITMAP] AND NOT .SCT[SCT_L_RESETTING]) NEQ 0
	THEN
	    BEGIN

	    ! Signal a message.
	    !
	    SIGNAL(JBC$_SYMDEL + STS$K_WARNING, 0,
		(.MBX[ACM$L_FINALSTS] AND NOT STS$M_INHIB_MSG) );


	    ! Stop all queues being served by this symbiont.
	    !
	    INCR I FROM 0 TO 31 DO
		BEGIN
		SMQ_N = .VECTOR[SCT[SCT_L_QUEUES], .I];
		IF .SMQ_N NEQ 0
		THEN
		    BEGIN
		    SMQ = READ_RECORD(.SMQ_N);


		    ! If a request is pending, send a response.
		    !
		    IF .SMQ[SMQ$V_PAUSING]
		    OR .SMQ[SMQ$V_RESETTING]
		    OR .SMQ[SMQ$V_RESUMING]
		    OR .SMQ[SMQ$V_STARTING]
		    OR .SMQ[SMQ$V_STOPPING]
		    THEN
			SCAN_INCOMPLETE_SERVICES(
			    ISRV_K_SYMBIONT,
			    .SMQ_N, .SMQ,
			    0,
			    JBC$_SYMDEL + STS$K_ERROR);


		    ! Stop the queue.
		    !
		    SMQ[SMQ$L_STREAM_SCT] = 0;
		    SMQ[SMQ$L_STATUS] = 0;
		    SMQ[SMQ$V_STOPPED] = TRUE;


		    ! Rewrite the SMQ record.
		    !
		    REWRITE_RECORD(.SMQ_N);
		    END;
		END;


	    ! Requeue current jobs on all queues being served by this symbiont.
	    !
	    INCR I FROM 0 TO 31 DO
		BEGIN
		SMQ_N = .VECTOR[SCT[SCT_L_QUEUES], .I];
		IF .SMQ_N NEQ 0
		THEN
		    BEGIN
		    SMQ = READ_RECORD(.SMQ_N);


		    ! Requeue the current job if there is one.
		    !
		    SJH_N = .SMQ[SMQ$L_CURRENT_LIST];
		    IF .SJH_N NEQ 0
		    THEN
			BEGIN
			SJH = READ_RECORD(.SJH_N);
			SJH[SJH$V_SYSTEM_FAILURE] = TRUE;
			UPDATE_GETQUI_DATA(.SJH_N, .SJH);
			COMPLETE_JOB(
			    .SJH_N, .SJH, .SMQ,
			    0,
			    JBC$_SYMDEL OR STS$K_ERROR);
			SMQ[SMQ$L_CURRENT_LIST] = 0;
			SMQ[SMQ$L_CURRENT_LIST_END] = 0;
			SMQ[SMQ$B_CURRENT_JOB_COUNT] = 0;
			END;


		    ! Rewrite the SMQ record.
		    !
		    REWRITE_RECORD(.SMQ_N);
		    END;
		END;
	    END;


	! Deassign the channel to the symbiont mailbox if one has been
	! assigned.
	!
	IF .SCT[SCT_W_MAILBOX] NEQ 0
	THEN
	    $DASSGN(CHAN=.SCT[SCT_W_MAILBOX]);


	! Finally, release the SCT entry.
	!
	.PREV = .SCT[SCT_L_FLINK];
	DEALLOCATE_MEMORY(.SCT);
	QUEUE_REFERENCE_COUNT = .QUEUE_REFERENCE_COUNT - 1;
	EXITLOOP;
	END;


    ! Advance to next.
    !
    PREV = .SCT;
    SCT = ..PREV;
    END;
END;

GLOBAL ROUTINE DELETE_SYMBIONTS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes all symbiont processes just before the job
!	controller restarts itself after a fatal error.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SCT:		REF BBLOCK;	! Pointer to symbiont control table


SCT = .SYMBIONT_CONTROL;
WHILE .SCT NEQ 0 DO
    BEGIN
    $DELPRC(PIDADR=SCT[SCT_L_PID]);
    SCT = .SCT[SCT_L_FLINK];
    END;
END;

GLOBAL ROUTINE SYMBIONT_COMPLETED_BLOCKS(SJH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine analyzes the checkpoint entry for a job and returns the
!	number of completed blocks in the current file.
!
! INPUT PARAMETERS:
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Number of completed blocks, or 0 if indeterminate.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK;	! Pointer to SJH


! If the checkpoint is short enough to fit into the main area, and the
! structure level is correct, then return the first longword of the user
! key, which is known to be the current VBN.
!
IF .BBLOCK[SJH[SJH$T_CHECKPOINT], FVDF_LENGTH] LEQU SJH$S_CHECKPOINT-2
THEN
    BEGIN
    BIND
	CKP = BBLOCK[SJH[SJH$T_CHECKPOINT], FVDF_DATA] : BBLOCK;


    IF .CKP[SMBMSG$B_CHECKPOINT_LEVEL] EQL SMBMSG$K_STRUCTURE_LEVEL
    THEN
	RETURN .(CKP[SMBMSG$Q_USER_KEY]);
    END;


! Unknown checkpoint, or none stored -- return 0.
!
0
END;

END
ELUDOM
