	.TITLE	TTYSYNCH - THIS MODULE CONTAINS SYNCHRONIZATION ROUTINES FOR TTDRVR
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
; Author:
;
;	Michael I. Rosenblum 10/7/83
;
; Description:
;
;	THIS MODULE PROVIDES THE SET OF ROUTINES NECESSARY TO IMPLIMENT
; A SYNCHRONIZATION TECHNEQUE BASED ON IPL FOR THE VMS TERMINAL DRIVER
;
;--
;
; Edit History
;
;	V04-001	MIR1100		Michael I. Rosenblum		7-Sep-1984
;		Fix bug where R0 would be set to 1 if the ipl was already
;		below IPL$_SYNCH.
;		Fix bug that would let the ACB allocation routine run off
;		The end of the pool. Allocate more pool.
;
; 	V03-001	MIR0320		Michael I. Rosenblum		17-Feb-1984
;		Fix bug in the loading of R2 by ttylock we must make sure
;		That we are in physical context.
;
	.page
	$FKBDEF
	$ACBDEF
	$UCBDEF
	$TTYDEFS
	$TTYDEF
	$TTDEF
	$TT2DEF
	$IPLDEF

	.PSECT	$$$115_DRIVER,LONG

	.sbttl	TTY$SYNCH - common routine that provides necessary synchronization
;++
; EXE$FORK - replaces the functionality of EXE$FORK
;
; Description:
;
;	This routine is the basis of synchronization for the terminal class
; driver.  For normal controlers  this is implimented by a normal fork call
; for controlers that whish to run in process context specail kernal AST's
; may be used, in user mode the lock manager may be used.
;
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = PROCESS PID TO USE FOR THIS FORK
;	08(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = ADDRESS OF FORK BLOCK.
;
; OUTPUTS:
;
;	***TBS***
;-
TTY$SYNCH::				;CREATE FORK PROCESS

	CMPB	FKB$B_FIPL(R5),#2	; ARE WE FORKING TO IPL2?
	BEQL	DEL_SPKNL		; YES THEN DELIVER THINGS DIFFERENTLY
	MOVL	(SP)+,(SP)		; NORMAL FORK THEN REMOVE PID FROM STACK
	JMP	g^EXE$FORK		; THEN FORK
DEL_SPKNL:
	MOVQ	R3,FKB$L_FR3(R5)	; SAVE FORK R3 AND R4
	POPL	FKB$L_FPC(R5)		; GET A FORK PC
	POPL	R3			; GET PID
	BNEQ	5$			; IS THERE A PID
	MOVL	#^X10001,R3		; NO THEN USE THE SWAPPER
5$:
	MOVAL	TTY$FORK_POOL_END-TTY$K_FXT_LENGTH,TTY$FORK_POOL_END
	MOVAB	TTY$FORK_POOL,R4	; GET THE ADDRESS OF THE FORK POOL
10$:	BBCS	#0,(R4),20$		; SET THE BUSY BIT  AND EXIT WITH THIS ADDRESS
	ACBL	TTY$FORK_POOL_END,#TTY$K_FXT_LENGTH,R4,10$; MOVE TO THE NEXT BLOCK
	TSTL	@-1
20$:
	ADDL	#4,R4			; MOVE PAST THE LOCAL STATUS WORD
	MOVL	R5,ACB$L_ASTPRM(R4)	; KEEP THE REAL FORK BLOCK FOR LATER USE
	PUSHL	R5			; SAVE THIS FOR LATER
	MOVL	R4,R5			; MAKE R5 THE ACB
	MOVL	R3,ACB$L_PID(R5)	; PUT IN THE PID
	MOVB	#ACB$M_PKAST!ACB$M_NODELETE,ACB$B_RMOD(R5); MAKE THIS A SPECAIL KERNAL
	MOVAB	L1,ACB$L_AST(R5)	; GET THE AST ADDRESS
	MOVAB	FREE_ACB,ACB$L_KAST(R5); A PIGGY BACK AST TO DEASSIGN THE AASTBLK
	PUSHL	R2			; SAVE R2 AS WELL AS R5
	PUSHAB	RESTR5			; RESTORE R5 AFTER QUEUEING THE FORK
	MFPR	#PR$_IPL,R4		; GET THE CURRENT IPL
	MOVL	R5,R3			; SAVE THE ACB ADDRESS
	CMPL	R4,#IPL$_SYNCH		; ARE WE AT SYNC OR BELOW?
	BLEQ	60$
;
; we need a fork block to get to IPL queueast before we can queue an ast
;
	MOVAB	TTY$FORK_POOL,R4	; GET THE ADDRESS OF THE FORK POOL
40$:	BBCS	#0,(R4),50$		; SET THE BUSY BIT  AND EXIT WITH THIS ADDRESS
	ACBL	TTY$FORK_POOL_END,#TTY$K_FXT_LENGTH,R4,40$; MOVE TO THE NEXT BLOCK
	TSTL	@-1
50$:	ADDL	#4,R4			; MOVE BEAOND THE STATUS LONGWORD
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R4);
	MOVL	R4,R5			; SETUP THIS ADDRESS TO FORK ON

	JSB	g^EXE$FORK		; CALL OURSELFS WITH A NON-IPL 2 IPL
;
; When the fork returns then queue the ast
;
	BBCC	#0,-4(R5),60$		; FREE THE FORK BLOCK
60$:	MOVL	R3,R5
	CLRL	R2			; NO PRIORITY BOOST NECESSARY
	PUSHL	R0
	JSB	G^SCH$QAST		; QUEUE ST
	POPL	R0
	rsb
;
; RETURN HERE AFTER THE AST IS FIRED
;
L1:	.WORD	^M<R2,R3,R4,R5>		; SAVE SOME REGISTERS
	MOVL	4(AP),R5		; RESTORE THE REAL FORK BLOCK ADDRESS

30$:	MOVQ	FKB$L_FR3(R5),R3	; THE FORK BLOCK AND REGISTERS THEN
					; RETURN
	JSB	@FKB$L_FPC(R5)		; GOTO THE ROUTINE
	RET				; RETURN TO THE SYSTEM
;
; CALLED AS A PIGGYBACK AST TO THE NORMAL AST
;
FREE_ACB:
	BBCC	#0,-4(R5),30$		; NOW CLEAR THE BUSY BIT
30$:	MOVAL	TTY$NODELACB,R5		; MAKE SURE WE DO NOT DELETE THIS ACB
	RSB				; NOW RETURN
;
; RESTORE USED REGISTERS BEFORE RETURNING TO THE HIGHER LEVEL
;
RESTR5:					; RESTORE R5 AFTER CALLING FORK
	POPL	R2			; RESTORE R2
	POPL	R5
	RSB

	.SBTTL	TTY$LOCK - SETUP IPL AND REGISTERS

; ++
; TTY$LOCK - SETUP IPL AND REGISTER CO-ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A CO-ROUTINE THAT DISABLES INTERRUPTS TO THE IPL IN UCB$B_DIPL
; AND SETS UP A POINTER TO THE UNIT STATE VECTOR.
;
; SUBSEQUENT RETURN CAUSES IPL TO BE RETURNED.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R1 IS DESTROYED.
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

TTY$LOCK::				; SETUP IPL AND REGISTERS
	MOVL	(SP),R1			; GET RETURN ADDRESS
	MFPR	#PR$_IPL,(SP)		; GET THE CURRENT IPL
	CMPB	UCB$B_DIPL(R5),(SP)	; If already at device IPL or
	BLEQU	10$			; higher, branch forward.
	SETIPL	UCB$B_DIPL(R5)		; Else, raise to device IPL.
10$:	CMPB	UCB$B_DIPL(R5),#IPL$_ASTDEL; ARE WE AT ASTDEL OR GOING THERE?
	BEQL	20$			; YES THEN HANDLE SPECAILLY
30$:	MOVL	UCB$L_TL_PHYUCB(R5),R2	; MAKE SURE WE ARE IN PHYSICAL CONTEXT
	MOVAB	UCB$Q_TT_STATE(R2),R2	; SETUP STATE VECTOR POINTER
	JSB	(R1)			; CALL CALLER BACK
	CMPB	UCB$B_DIPL(R5),#IPL$_ASTDEL; ARE WE AT ASTDEL OR GOING THERE?
	BEQL	40$			; YES THEN HANDLE SPECAILLY
	ENBINT				; ENABLE INTERRUPTS
40$:	RSB				;

20$:
	MOVAL	TTY$FORK_POOL_END-TTY$K_FXT_LENGTH,TTY$FORK_POOL_END
	CMPL	#IPL$_ASTDEL,(SP)+	; ARE WE ALREADY AT ASTDEL?
	BNEQ	60$			; NO THEN WE MUST FORK
	PUSHL	R1			; KEEP THE RETURN LOCATION
	MOVZWL	UCB$L_PID(R5),R1	; GET THE PID INDEX
	BNEQ	50$
	MOVL	#1,R1			; NO PID USE SWAPPER
50$:	MOVL	g^sch$gl_pcbvec,-(sp)	; get the location of the pcb
	CMPL	(sp)+[R1],G^SCH$GL_CURPCB	; ARE WE CURRENTLY ACTIVE
	BNEQ	70$			; YES THEN NO FORK NECESSARY
	POPL	R1			; RESTORE R1
	BRB	30$
60$:	PUSHL	R1			; SAVE THE RETURN ADDRESS
70$:	MOVAB	TTY$FORK_POOL,R1	; GET THE ADDRESS OF THE FORK POOL
200$:	BBCS	#0,(R1),250$		; SET THE BUSY BIT  AND EXIT WITH THIS ADDRESS
	ACBL	TTY$FORK_POOL_END,#TTY$K_FXT_LENGTH,R1,200$; MOVE TO THE NEXT BLOCK
	TSTL	@-1
250$:	ADDL	#4,R1			; MOVE BEAOND THE STATUS LONGWORD
	MOVQ	R3,FKB$L_FR3(R1)	; SAVE R3 AND R4
	MOVL	R1,R3			; KEEP THE FORK BLOCK 
	POPL	R4			; AND THE RETURN ADDRESS
	PUSHAB	REST_REGS		; RESTOR THE NECESSARY REGISTERS
	MOVL	UCB$L_PID(R5),-(SP)	; PUT THE PID ON THE STACK
	BNEQ	80$			; NO PID
	MOVL	#^X10001,(SP)		; THEN USE SWAPPER
80$:
	MOVAB	TTY$FORK_POOL,R1	; GET THE ADDRESS OF THE FORK POOL
90$:	BBCS	#0,(R1),100$		; SET THE BUSY BIT  AND EXIT WITH THIS ADDRESS
	ACBL	TTY$FORK_POOL_END,#TTY$K_FXT_LENGTH,R1,90$; MOVE TO THE NEXT BLOCK
	TSTL	@-1
100$:	ADDL	#4,R1			; MOVE BEAOND THE STATUS LONGWORD
	MOVL	R5,ACB$L_KAST(R1)	; PLACE R5 IN AN UNUSED LOCATION
	MOVB	UCB$B_FIPL(R5),FKB$B_FIPL(R1); SETUP THE FORK IPL
	MOVL	R1,R5			; MAKE THIS THE FORK BLOCK
	BSBW	TTY$SYNCH		; AND SYNCHRONIZE
	MOVL	R5,R1			; GET THE FORK BLOCK ADDRESS
	MOVL	ACB$L_KAST(R1),R5	; GET THE UCB ADDRESS
	BBSC	#0,-4(R1),130$		; NOW CLEAR THE BUSY BIT
130$:	MOVL	R3,R2			; GET THE AUXILLARY BLOCK
	MOVL	R4,R1			; AND THE RETURN ADDRESS
	MOVQ	FKB$L_FR3(R2),R3	; RESTORE R3 AND R4
	BBSC	#0,-4(R2),140$		; FREE THE AUXILLIARY BLOCK
140$:	BRW	30$
REST_REGS:
	MOVQ	FKB$L_FR3(R5),R3	; RESTORE THE REGISTERS
	MOVL	ACB$L_KAST(R5),R5	; GET R5 BACK
	MOVQ	FKB$L_FR3(R3),R3	; RESTORE THE REGISTERS
	RSB				; AND RETURN

TTY$K_FXT_LENGTH=ACB$K_LENGTH+4
TTY$FORK_POOL:
.REPEAT	75
	.BLKB	TTY$K_FXT_LENGTH
.ENDR

TTY$FORK_POOL_END:
	.BLKB	TTY$K_FXT_LENGTH
TTY$NODELACB:
	.BLKB	ACB$B_RMOD
	.BYTE	ACB$M_NODELETE
	.BLKB	ACB$K_LENGTH-ACB$B_RMOD
	.END
