MODULE ERFPARSER
(%TITLE 'Command Parser'
IDENT = 'V04-000') =
	
BEGIN
	
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  ERF, Error Log Report Generator
!
! ABSTRACT:
!
! 	This module contains the routines that perform the command parsing
!	for ERF.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, user mode.
!
! AUTHOR:  Sharon Reynolds,	CREATION DATE:	October 1982
!
! Modified by:
!
!	V03-013	SAR0273		Sharon A. Reynolds	18-Jun-1984
!		- Fixed a bug with the parsing of device names.
!
!	V03-012	SAR0266		Sharon A. Reynolds	15-May-1984
!		- Re-inserted code for handling /inc=star$, lost due to
!		incorrect version checked in.
!
!	V03-011	SAR0255		Sharon A. Reynolds	23-Apr-1984
!		- Fixed a problem in parsing nodes names of max length.
!		- Added a check for /output and /binary.
!
!	V03-010	SAR0242		Sharon A. Reynolds	4-Apr-1984
!		- Removed unnecessary code from search_queue.
!		- Made unit number max = 5.
!
!	V03-009	EAD0120		Elliott A. Drayton		23-Feb-1984
!		Changed code to handel UNKNOWN as a keyword, not as a qualifier.
!
!	V03-008 SAR0190		Sharon A. Reynolds,	13-Feb-1984
!		- Added additional test for summary updates.
!		- Added 'CS' device name support to the device table
!		search routine.
!		- Changed the error return for lib$cvt_xxx.
!
!		JMG0008		Joel M. Gringorten,	 6-Feb-1984
!		Added Statistics qualifier support.
!
!	V03-007	JMG0001		Joel M. Gringorten,	 9-Jan-1984
!		Added support for SUMMARY=HISTOGRAM.
!
!	V03-006 SAR0180		Sharon A. Reynolds,	13-Dec-1983
!		- Removed unnecessary descriptors.
!		- Added unsolicited_mscp keyword.
!		- Removed the logmessage keyword.
!		- Added the attentions keyword.
!		- Fixed the parsing of 'sloth$dba3'.
!		- Changed the name wild indicator to node name wild indicator.
!		- Made the 'parse_devname' and 'search_queue' routines
!		  support node name wild indicator.
!
!	V03-005	SAR0166		Sharon A. Reynolds,	14-Oct-1983
!		- Made the following command valid. (/inclu=disk/excl=db).
!		- Changed the way the report type is referenced. 
!		- Removed reference to erf_norep.
!
!	V03-004	SAR0151		Sharon A. Reynolds,	7-Oct-1983
!		Fixed a bug in GET_DEVICE_SELECT.
!
!	V03-003	SAR0121		Sharon A. Reynolds,	23-Aug-1983
!		Fixed a problem with report type selection (/NOFULL)
!		and added /REJECTED qualifier support. Re-wrote the
!		search routine for use with the permanent device tables.
!
!	V03-002	SAR0028		Sharon A. Reynolds,	11-May-1983
!		Removed support for logstatus keyword. Fixed a 
!		problem in parsing an '*' in a device name spec.
!
!	V03-001	SAR0014		Sharon A. Reynolds,	18-Apr-1983
!		Fixed a problem with error message returns for the parsing
!		of /include and /exclude device name and keyword selection.
!
!--
!

!
! This global data psect is quadword aligned. It currently
! contains data for use by the LIB$INSQTI routine.
!
PSECT GLOBAL = QUEUE_DATA (PIC,ALIGN (3)) ;
Global
    Root_flink:		Initial (0),
    Root_blink:		Initial (0),
    Que_addrs:		Initial (0),
    Que_entry_addrs:	Initial (0) ;

PSECT
    Code = $CODE (pic,addressing_mode(general)),
    Plit = $PLIT (pic,addressing_mode(general)), 
    Own = $own$ (pic,addressing_mode(general)),
    Global = $global$ (pic,addressing_mode(general)) ;



!
! Required files
!
REQUIRE 'SRC$:ERFDEF.REQ' ;		! For message definitions
REQUIRE	'LIB$:PARSERDAT.R32' ;		! ERF parser data definitions

!
! Table of contents
!
FORWARD ROUTINE
    Class_option_check: NOVALUE,
    Device_option_check,
    Get_device_select,
    Get_vm,
    Parse_command,
    Parse_devname,
    Search_queue,
    Translate_device ;

!
! Declare external routines
!
EXTERNAL ROUTINE
    CLI$GET_VALUE: addressing_mode(general),	! Get parameter or qualifier 
						! value.
    CLI$PRESENT: addressing_mode (general),	! Determine if entity is present
    LIB$LOOKUP_KEY : addressing_mode (general), ! Match selected keyword against
						! the specified keyword table.
    LIB$CVT_TIME: addressing_mode (general),	! Convert time string to binary
						! value.
    LIB$CVT_DTB: addressing_mode (general),	! Convert decimal to binary
    LIB$CVT_HTB: addressing_mode (general),	! Convert hexadecimal to binary
    LIB$GET_VM: addressing_mode (general),	! Get virtual memory
    LIB$INSQTI: addressing_mode (general),	! Insert entry at head of queue
    LIB$REMQTI: addressing_mode (general) ;	! Remove an entry from the 
						! head for the queue.

!
! Declare external literals
!
EXTERNAL LITERAL
    Cli$_absent,
    Cli$_negated,
    Cli$_present,
    Erf_cnfquaval,
    Erf_cvterr,
    Erf_devselreq ;

!
! Declare literals
!
GLOBAL LITERAL 
!   Async = 0,			! Index for include_class/mask and 
    Bus = 1,			! exclude_class/mask structures
    Disk = 2,
    Realtime = 3,
    Sync = 4,
    Tape = 5,

    Error = 2,			!
    Max_class = (5),		! Maximum number of device class selections for /include,/exclude
    Q_entry_size = (((dev$s_dev_queue+7)/8)*8) ;! Device queue entry size

!
! Declare global storage 
!
GLOBAL 
!    Bugchk_type,			! Storage for bugcheck values
    Dev_class_key,			! Device class selection indicator
    Dev_entry_key,			! Device entry selection indicator
    Dev_name,				! Device name (first two chars)
    Dev_select:		REF $BBLOCK,	! Device selection que entry storage
    Entry_value,			! Converted entry value storage
    Exclude_class:	VECTOR [6,BYTE],! Selected device classes for /exclude
    Exclude_flag:	BYTE,		! /include, /exclude processing indicator
    Exclude_key:	VECTOR [6,BYTE],! 
    Exclude_mask,			! Exclude selection indicators
    Exclude_q_entry_cnt: BYTE,
    Include_q_entry_cnt: BYTE,
    Include_class:	VECTOR [6,BYTE],! Selected device classes for /include
    Include_key:	VECTOR [6,BYTE],!
    Include_mask,			! Include selection indicators
    Option_flag,			! Option selection indicators
    Parser_data,			! Address of actual data storage area
    Parser_table,			! Address of descriptor storage area
    Que_entry_cnt:	WORD,		! Number of entries in the queue
    Summary_flag,			! Summary option selections
    Class_dir, 
    Wild_carded_device ;		! Device wild carded

OWN
    Keywrd_mask:	Initial (%X'FFFFF') ;

MAP
    Exclude_mask:	REF $BBLOCK,
    Include_mask:	REF $BBLOCK,
    Option_flag:	REF $BBLOCK,
    Parser_data:	REF $BBLOCK,
    Parser_table: 	REF $BBLOCK,
    Summary_flag:	REF $BBLOCK,
    Que_entry_addrs:	REF $BBLOCK,
    Class_dir:		REF $BBLOCK ;


!
! Macro definitions
!
MACRO
    !
    ! Define a macro for converting the entry values from ascii to a value.
    !
    CVT_ENTRY_VALUE = 
	Begin

	If NOT (status = LIB$CVT_DTB (.wrk_desc[dsc$w_length],
					.wrk_desc[dsc$a_pointer],entry_value))
	Then
	    !
	    ! Error converting the ascii decimal value to a value, notify
	    ! the user and exit.
	    !
	    Signal (erf_cvterr, 2,.wrk_desc[dsc$w_length],
				.wrk_desc[dsc$a_pointer]) ; 
	End % ;


GLOBAL ROUTINE PARSE_COMMAND =			! Command line parsing 

!++
!
! Functional Description:
!
!    This routine is called from the main loop to parse the 
!    command line 
!
! Calling Sequence:
!
!    PARSE_COMMAND ()
!
! Input Parameters:
!
!    None
!
! Output Parameters:
!
!    *
!
!--
Begin

!
! Generate static string descriptors for the qualifiers.
!
SD( '$LINE',
    'FILE_SPECS',
    'BEFORE',
    'BINARY',
    'BRIEF',
    'ENTRY',
    'EXCLUDE',
    'FULL',
    'INCLUDE',
    'LOG',
    'OUTPUT',
    'PAGE',
    'REGISTER_DUMP',
    'REJECTED',
    'SID_REGISTER',
    'SINCE',
    'STATISTICS',
    'SUMMARY') ;

    Bind %NAME('ENTRY_END_DESC') = $DESCRIPTOR('ENTRY.END') ;
    Bind %NAME('ENTRY_START_DESC') = $DESCRIPTOR('ENTRY.START') ;
    Bind ptr_0 = CH$PTR (UPLIT ('0')) ;
    Bind ptr_z = CH$PTR (UPLIT ('z')) ;

LOCAL 
    Cmd_line_desc,			! Command line desc address storage
    Full_negate:	BYTE,		! /nofull indicator
    I:			Initial (0),	! Multiple uses
    Key_value,				! Key word value storage
    Status,				! Return status storage
    System_id:		Initial (0) ;	! Temporary storage for system id

OWN
    Wrk_desc:	$BBLOCK [dsc$k_d_bln]	! Dynamic work descriptor
		Preset ([dsc$b_class] = dsc$k_class_d),

!
! Create the keyword tables for the LIB$LOOKUP_KEY routine. It (LIB$LOOKUP_KEY)
! will locate a matching key and return the value associated with it.
!
Summary_keywords:			! /SUMMARY keywords
    $LIB_KEY_TABLE (
	(Device, 01),
	(Entry, 02),
	(Memory, 03),
	(Volume, 04),
	(Histogram, 05)) ;

!
! Allocate memory for the parser table (descriptors) and the parser
! data (actual data).
!
Parser_table = GET_VM (erl$s_prs_table) ;
Parser_data = GET_VM (erl$s_prs_data) ;

!
! Set up some default values.
!
Parser_data[erl$b_rpt_type] = full_rep ;	! Default to full
Parser_data[erl$q_end_date]+0 = (%x'FFFFFFFF') ; ! Default to most future date
Parser_data[erl$q_end_date]+4 = (%x'7FFFFFFF') ; ! 
Parser_data[erl$q_start_date]+0 = 0 ;		! Default to earliest possible 
						! date/time.
Parser_data[erl$q_start_date]+4 = 0 ;		! 
Parser_data[erl$l_start_entry] = 0 ;		! Default to the beginning entry
Parser_data[erl$l_end_entry] = (%x'FFFFFFFF') ;	! Default to the last entry

!
! Get virtual memory for the bugcheck value storage.
! 
!Bugchk_type = GET_VM (bug$s_bugchk_flags) ;

!
! Get virtual memory for the exclude mask flags.
Exclude_mask = GET_VM (exc$s_exclude_flags) ;

!
! Get virtual memory for the include mask flags.
Include_mask = GET_VM (inc$s_include_flags) ;

!
! Get virtual memory for the option flags and set up
! some defaults.
Option_flag = GET_VM (opt$s_opt_flags) ;
Option_flag[opt$v_output_qual] = true ;
Option_flag[opt$v_full_qual] = true ;

!
! Get virtual memory for the summary qualifier flags.
Summary_flag = GET_VM (sum$s_summary_flags) ;

! Set up the descriptor that points to the entire command line.
!
Parser_table[cmd$b_class] = dsc$k_class_d ;
Cmd_line_desc = parser_table[erl$r_cmd_line] ;


!
! Save the entire command line for output at the end 
! of any report.
!
CLI$GET_VALUE ($LINE_DESC,.cmd_line_desc) ;

!
! Parse the command line.
!
! Determine if the /BEFORE qualifier was specified.
!
If CLI$PRESENT (before_desc)
Then
    !
    ! Get any value associated with the qualifier.
    !
    Begin
    Option_flag[opt$v_before_qual] = true ;    
    If CLI$GET_VALUE (before_desc,wrk_desc)
    Then
	! 
	! Convert the ascii time/date string to binary time/date.
	! LIB$CVT_TIME handles the Today, Yesterday, and Tomorrow keywords and 
	! will convert an absolute or delta time string or a combination of 
	! the two.
	!
	Begin
	If NOT (status = LIB$CVT_TIME (wrk_desc,parser_data[erl$q_end_date]))
	Then
	    !
	    ! Date/time conversion error, notify the user.
	    !
	    Signal (.status) ;
        End ;
    End ;

!
! Determine if the  /BINARY qualifier was specified. The file spec
! for the /binary qualifier is retrieved and parsed by the 
! Parse_output_files routine in ERF.
!
If CLI$PRESENT (binary_desc) 
Then
    !
    ! Indicate that the qualifier was specified and reset the
    ! default report type information.
    !
    Begin
    Status = CLI$PRESENT (output_desc) ;
    If .status EQL CLI$_PRESENT
    Then
	Signal_stop (msg$_confqual) ;

    Option_flag[opt$v_binary_qual] = true ;    
    Option_flag[opt$v_full_qual] = false ;
    Parser_data[erl$b_rpt_type] = 0 ;
    End ;

!
! Determine if the /ENTRY qualifier was specified. The CLD will 
! ensure a value was specified.
!
If CLI$PRESENT (entry_desc)
Then
    !
    ! Indicate that the /Entry qualifier was specified and get
    ! any associated values.
    !
    Begin
    Option_flag[opt$v_entry_qual] = true ;

    !
    ! Get the value associated with /ENTRY=start:value. The CLD will
    ! return a default if the user did not specify anything.
    !
    If CLI$GET_VALUE(ENTRY_START_DESC,wrk_desc) 
    Then
	!
	! Convert the ascii input to a decimal value and save it. If there was
	! a conversion error the CVT_ENTRY_VALUE will notify the user and will 
	! not return.
	!
	Begin
	CVT_ENTRY_VALUE ;
	Parser_data[erl$l_start_entry] = .entry_value ;
	End ;
    !
    ! Get the value associated with /ENTRY=end:value. The CLD will
    ! return a default if the user did not specify anything.
    !
    If CLI$GET_VALUE(ENTRY_END_DESC,wrk_desc)
    Then
	!
	! Convert the ascii input to a decimal value and save it. If there was
	! a conversion error the CVT_ENTRY_VALUE will notify the user and will 
	! not return.
	!
	Begin
	CVT_ENTRY_VALUE ;
	Parser_data[erl$l_end_entry] = .entry_value ;
	End ;
    End ;

!
! Determine whether the /EXCLUDE qualifier was specified.
!
If CLI$PRESENT (exclude_desc)
Then
    !
    ! Indicate that the /exclude qualifier was specified.
    !
    Begin
    Option_flag[opt$v_exclude_qual] = true ;
    Exclude_flag = true ;    

    !
    ! Get any value(s) associated with the qualifier. 
    ! 
    While CLI$GET_VALUE (exclude_desc,wrk_desc) do
	Begin
	!
	! Determine if the retrieved 'value', is a keyword.
	!
	If NOT (GET_DEVICE_SELECT (wrk_desc))
	Then
	    !
	    ! Not valid input for device selection, notify the user
	    ! and exit.
	    !
	    Signal_stop (msg$_invquaval, 2,
			wrk_desc,
			exclude_desc) ;
	End ;
    End ;


!
! Determine whether the /INCLUDE qualifier was specified, get any 
! qualifier 'values', parse the 'values', and save them. 
!
If CLI$PRESENT (include_desc)
Then
    !
    ! Indicate that the /include qualifier was specified, get
    ! any value(s) associated with it.
    !
    Begin
    Option_flag[opt$v_include_qual] = true ;
    Exclude_flag = false ;

    While CLI$GET_VALUE (include_desc,wrk_desc) do
	Begin
	!
	! Determine if the retrieved 'value' is a keyword
	! or a device specification.
	!
	If NOT (GET_DEVICE_SELECT (wrk_desc))
	Then
	    !
	    ! Illegal input, notify the user and exit.
	    !
	    Signal_stop (msg$_invquaval, 2,
			wrk_desc,include_desc) ;
	End ;
   End ;

!
! Determine whether the /LOG qualifier was specified.
!
If CLI$PRESENT (log_desc)
Then
    !
    ! Indicate that it was speicified.
    !
    Option_flag[opt$v_log_qual] = true ;

!
! Determine whether the /PAGE qualifier was specified.
!
If CLI$PRESENT (page_desc) 
Then
    !
    ! Indicate that the qualifier was specified.
    !
    Option_flag[opt$v_page_qual] = true ;

!
! Determine whether the /REJECTED qualifier was specified. The 
! file spec will be retrieved and parsed by the Parse_output_files
! routine in ERF.
!
If CLI$PRESENT (rejected_desc)
Then
    !
    ! Indicate that the qualifier was specified.
    !    
    Option_flag[opt$v_rejected_qual] = true ;

!
! Determine whether the /SID_REGISTER was specified.
!
If CLI$PRESENT (sid_register_desc)
Then
    !
    ! Indicate that the qualifier was specified and get the 
    ! value associated with it. The CLD will ensure that
    ! a value was specified.
    !
    Begin
    Option_flag[opt$v_sid_reg_qual] = true ;
    CLI$GET_VALUE (sid_register_desc,wrk_desc) ;

    !
    ! Determine if the specified sid has characters outside the range
    ! of hexadecimal chars.
    !
    If (CH$GEQ (1,CH$PTR(.wrk_desc[dsc$a_pointer]),1,ptr_0) AND
	CH$LEQ (1,CH$PTR(.wrk_desc[dsc$a_pointer]),1,ptr_z))
    Then
	!
	! Save the system id value.
	!
	Parser_data[erl$l_sid_selection] = .system_id ;
    End ;

!
! Indicate that the /SINCE qualifier was specified and get any value(s)
! associated with it.
!
If CLI$GET_VALUE (since_desc,wrk_desc)
Then
    ! 
    ! Convert the ascii time/date string to binary time/date.
    ! The CLI will return a default value if the user did not specify one. 
    ! LIB$CVT_TIME handles the Today, Yesterday, and Tomorrow keywords and 
    ! will convert an absolute or delta time string or a combination of 
    ! the two.
    !
    Begin
    Option_flag[opt$v_since_qual] = true ;    
    If NOT (status = LIB$CVT_TIME (wrk_desc,parser_data[erl$q_start_date]))
    Then
	!
	! Date/time conversion error, notify the user.
	!
	Signal (.status) ;
    End ;

!
! Determine whether the /STATISTICS qualifier was specified.
!
If CLI$PRESENT (statistics_desc)
Then
    !
    ! Indicate that it was speicified.
    !
    Option_flag[opt$v_statistics_qual] = true ;

!
! Determine whether /SUMMARY was specified.
!
If CLI$PRESENT (summary_desc)
Then
    !
    ! Indicate that a summary report was selected.
    !
    Begin
    Option_flag[opt$v_summary_qual] = true ;

    !
    ! Get any value(s) associated with the qualifier.
    !
    While CLI$GET_VALUE (summary_desc,wrk_desc) do
	Begin
	!
	! Get the value associated with the summary type keyword.
	!
	If (status = LIB$LOOKUP_KEY (wrk_desc,summary_keywords,key_value))
	Then
	    !
	    ! Indicate which summary options were selected.
	    !
	    Begin

	    Case .key_value from 1 to 5 of
		Set
		[1]:			! Device summary info
		    Begin
		    Summary_flag[sum$v_device] = true ;
		    End ;

		[2]:			! Entry summary info
		    Begin
		    Summary_flag[sum$v_entry] = true ;
		    End ;

		[3]:			! Memory summary info
		    Begin
		    Summary_flag[sum$v_memory] = true ;
		    End ;

		[4]:			! Volume summary info
		    Begin
		    Summary_flag[sum$v_volume] = true ;
		    End ;

		[5]:			! Histogram summary info
		    Begin
		    Summary_flag[sum$v_histogram] = true ;
		    End ;
		
		Tes ;
	    End
	Else
	    !
	    ! Illegal input, notify the user.
	    !
	    Signal_stop (msg$_invquaval, 2,wrk_desc,summary_desc) ; 
	End ;

    If ..summary_flag EQL 0
    Then summary_flag[sum$v_all_summ] = true ;

    End ;

!
! Determine if the /INCLUDE or /EXCLUDE qualifiers were specified and 
! set up the defaults for what to output.
!
If (NOT .option_flag[opt$v_include_qual]) AND
    (NOT .option_flag[opt$v_exclude_qual])
Then
    !
    ! Default to outputting of all entry types,
    ! device classes, and device names.
    !
    Begin
    Option_flag[opt$v_output_all] = true ;
    Include_mask[inc$v_device_select] = false ;
    Exclude_mask[exc$v_device_select] = false ;
    Include_mask[inc$v_dev_class_select] = false ;
    Exclude_mask[exc$v_dev_class_select] = false ;
    Include_mask[inc$v_entry_select] = false ;
    Exclude_mask[exc$v_entry_select] = false ;
    Include_mask[inc$v_unknown_entry] = false ;
    Exclude_mask[exc$v_unknown_entry] = false ;
    End ;

!
! Determine if the /FULL report type qualifier was
! specified. 
!
Status = CLI$PRESENT (full_desc) ;
If .status EQL cli$_present
Then 
    !
    ! Indicate the report type.
    !
    Begin
    I  = .I + 1 ;
    Parser_data[erl$b_rpt_type] = full_rep ;
    End 
Else
    Begin
    If .status EQL cli$_negated
    Then
	!
	! Indicate that /NOFULL was specified.
	!
	Begin
	Parser_data[erl$b_rpt_type] = 0 ;
	Full_negate = true ;
	End ;
    End ;

!
! Determine if the /BRIEF report type qualifier was
! specified. 
!
If CLI$PRESENT (brief_desc)
Then 
    !
    ! Indicate the report type.
    !
    Begin
    I  = .I + 1 ;
    Parser_data[erl$b_rpt_type] = brief_rep ;
    End ;

!
! Determine if the /REGISTER_DUMP report type qualifier was 
! specified.
!
If CLI$PRESENT (register_dump_desc)
Then
    !
    ! Indicate that the report type and ensure that device 
    ! selection was made.
    !
    Begin
    I  = .I + 1 ;
    Parser_data[erl$b_rpt_type] = reg_dump_rep ;

    If (NOT .option_flag[opt$v_include_qual]) OR
	(dev_entry_key)
    Then
	!
	! Either a device was not selected or an invalid
	! device selection was made, notify the user and exit.
	!
	Signal_stop (erf_devselreq) ;
    End ;


!
! Determine if a report type was specified and ensure that the
! /BINARY qualifier was not specified also.
!
If (.parser_data[erl$b_rpt_type] NEQ 0)
Then
    !
    ! Ensure that the /binary qualifier was not specified.
    !
    Begin
    If .option_flag[opt$v_binary_qual]
    Then 
	!
	! Illegal combination of qualifiers, notify the user and
	! exit.
	!
	Signal_stop (msg$_confqual) ;
    End ;

!
! Ensure that there was only one report type specified.
!
If .I GTR 1
Then
    !
    ! Illegal combination of qualifiers, notify the user and exit.
    !
    Signal_stop (msg$_confqual) ;

!
! Determine if there are any conflicts between /exclude
! and /include device class option selections.
! Do not look at the device, device class, or entry selection
! indicators.
!
Status = (..include_mask AND .keywrd_mask) AND 
	(..exclude_mask AND .keywrd_mask);

If .status NEQU 0
Then
    !
    ! Illegal combination of /exclude and /include
    ! options, notify the user and exit.
    !
    Signal_stop (erf_cnfquaval, 2,exclude_desc,include_desc) ;

!
! Determine if there are any conflicts between any of the 
! selected devices and any selected device class options
! for /include and /exclude.
!
CLASS_OPTION_CHECK () ;

!
! Indicate that the command line is parsed, by returning
! to the calling routine with a true value.
!
Return true ;
End ; 		! Routine 


ROUTINE GET_DEVICE_SELECT (temp_desc) = 	! Device selection parsing

!++
!
! Functional Description:
!
! This routine determines if the 'value' specified with the /device or /exclude 
! qualifier was a valid keyword and translates it to the device class 
! designation.
!
! Calling Sequence:
!
!    GET_DEVICE_SELECT (temp_desc) 
!
! Input Parameters:
!
!    Temp_desc = the 'value' associated with the qualifier
!
! Output Parameters:
!
!    This routine will ****
!
!--
Begin

LITERAL
    Max_keywords = 16 ;			! Maximum number of keywords

LOCAL
    Device_class,			! Device class storage
    Key_value,				! Key value storage
    Status ;				! Return status storage
	
!
! Create the device keyword table.
!
OWN
    !
    ! Define the device class and device entry keywords associated
    ! with the /exclude and /include qualifiers.
    !
    Dev_class_keywords:			
	$LIB_KEY_TABLE (
!	    (Async_communications, 00),
	    (Buses, 01),
	    (Disks, 02),
	    (Realtime, 03),
	    (Sync_communications, 04),
	    (Tapes, 05)),

    Dev_entry_keywords:
	$LIB_KEY_TABLE (
	    (Bugchecks, 06),
	    (Control_entries, 07),
	    (Cpu_entries, 08),
	    (Device_errors, 9),
	    (Machine_checks, 10),
	    (Memory, 11),
	    (Timeouts, 12),
	    (Volume_changes, 13),
	    (Attentions, 14),
	    (Unsolicited_mscp, 15),
	    (Unknown, 16)) ;

MAP
    Temp_desc:	REF $BBLOCK ;


!
! Allocate the necessary storage (zero filled) and initialize
! the device select queue entry.
!
Dev_select = GET_VM (q_entry_size) ;

Dev_select[dev$w_unit] = (-1) ;
Dev_select[dev$v_node_name_wild] = false ;
Dev_select[dev$v_exclude_flg] = false ;


!
! Determine if it is a device class keyword.
!
Dev_class_key = true ;
If NOT (status = LIB$LOOKUP_KEY(.temp_desc,dev_class_keywords,key_value))
Then
    !
    ! Not a device class keyword, determine if it is 
    ! a device entry keyword.
    !
    Begin
    Dev_class_key = false ;
    Dev_entry_key = true ;
    If NOT (status = LIB$LOOKUP_KEY(.temp_desc,dev_entry_keywords,key_value))
    Then
	!
	! Not a device entry keyword determine if it is a 
	! device specification.
	!
	Begin
	Dev_entry_key = false ;
	If NOT (PARSE_DEVNAME (.temp_desc))
	Then
	    !
	    ! Not a device specification either, return to calling routine.
	    !
	    Return false
	Else
	    ! 
	    ! Valid device specification, the name and
	    ! unit number are already stored in the queue entry.
	    !
	    ! Translate the device name to a device class.
 	    !
	    Begin
	    If NOT .wild_carded_device
	    Then
		Begin
		If NOT TRANSLATE_DEVICE (dev_name,device_class)
	        Then
		    !
		    ! Device not found, notify the user and exit.
		    !
		    Return false
	        Else
	 	    !
		    ! Device found, save the device class in the device
		    ! select queue entry.
		    !
		    Dev_select[dev$b_class] = .device_class ;

	        !
	        ! Search any entries already in the queue to ensure
	        ! there are no conflicts between the selected 
	        ! device and any device class(es) already selected.
	        !
	        If NOT DEVICE_OPTION_CHECK ()
	        Then
		    !
		    ! Like entry already in the queue.
		    ! (/include=MF,MF or /exclude=MF,MF)
		    !
		    Return true ;
		End ;

	    !
	    ! Insert entry in the queue. The LIB$INSQTI creates 
	    ! a self relative queue that is interlocked. 
	    !
	    If NOT (status = LIB$INSQTI (.dev_select,root_flink))
	    Then
		!
		! The entry could not be placed in the queue, notify
		! the user and exit.
		!
		Signal_stop (.status)
	    Else
		!
		! Entry was successfully entered in queue.
		!
		Begin
		If .exclude_flag
		Then
		    Exclude_q_entry_cnt = .exclude_q_entry_cnt + 1 
		Else
		    Include_q_entry_cnt = .include_q_entry_cnt + 1 ;

		Que_entry_cnt = .exclude_q_entry_cnt + .include_q_entry_cnt ;
	        End ;
	    End ;
	End ;
    End ;

!
! Valid keyword, set up the exclude and include option 
! selection indicators.
!
If (.dev_entry_key) OR (.dev_class_key)
Then
    Begin
    If .option_flag[opt$v_include_qual] 
    Then
	Begin
	Case .key_value from 1 to max_keywords of
	Set
!        [0]:				! Asynchronous communications device class
!	    Begin
!	    Include_mask[inc$v_async_comm] = true ;
!	    Include_class[async] = DC$_ACOM ;
!	    Include_key[async] = .key_value ;
!	    Include_mask[inc$v_dev_class_select] = true ;
!	    End ;				

	[1]:				! Bus device class 
	    Begin
	    Include_mask[inc$v_buses] = true ;
	    Include_class[bus] = DC$_BUS ;
	    Include_key[bus] = .key_value ;
	    Include_mask[inc$v_dev_class_select] = true ;
	    End ;

	[2]:				! Disk device class
	    Begin
	    Include_mask[inc$v_disks] = true ;
	    Include_class[disk] = DC$_DISK ;
	    Include_key[disk] = .key_value ;
	    Include_mask[inc$v_dev_class_select] = true ;
	    End ;

	[3]:				! Realtime class
	    Begin
	    Include_mask[inc$v_realtime] = true ;
    	    Include_class[realtime] = DC$_REALTIME ;
	    Include_key[realtime] = .key_value ;
	    Include_mask[inc$v_dev_class_select] = true ;
	    End ;

	[4]:				! Synchronous communication device class
	    Begin  
	    Include_mask[inc$v_sync_comm] = true ;
	    Include_class[sync] = DC$_SCOM ;
	    Include_key[sync] = .key_value ;
	    Include_mask[inc$v_dev_class_select] = true ;
	    End ;

	[5]:				! Tapes device class
	    Begin
	    Include_mask[inc$v_tapes] = true ;
	    Include_class[tape] = DC$_TAPE ;
	    Include_key[tape] = .key_value ;
	    Include_mask[inc$v_dev_class_select] = true ;
	    End ;

	[6]:				! Bugcheck entries
	    Begin
	    Include_mask[inc$v_bugchks] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    !
	    ! Determine if a specific type of bugcheck entry
	    ! was selected.
	    !
	    !*****get value associated with bugchecks
	    End ;

	[7]:				! Control entries
	    Begin
	    Include_mask[inc$v_control_entry] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    End ;

	[8]:				! Cpu entries 
	    Begin
	    Include_mask[inc$v_cpu_entry] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    End ;

	[9]:				! Device error entries
	    Begin
	    Include_mask[inc$v_dev_errors] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    End ;

	[10]:				! Machine check entries
	    Begin
	    Include_mask[inc$v_machine_chks] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    End ;

	[11]:				! Memory entries
	    Begin
	    Include_mask[inc$v_memory] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    End ;

	[12]:				! Device timeout entries
	    Begin
	    Include_mask[inc$v_dev_timeouts] = true ;
	    Include_mask[inc$v_entry_select] = true ;
	    End ;

	[13]:				! Volume change entries
	    Begin
	    Include_mask[inc$v_volume] = true ;
	    Include_mask[inc$v_entry_select] = true ;	    
	    End ;

	[14]:				! Device attention entries
	    Begin
	    Include_mask[inc$v_dev_attentions] = true ;
	    Include_mask[inc$v_entry_select] = true ;
	    End ;

	[15]:				! Unsolicted mscp entries (logmscp)
	    Begin
	    Include_mask[inc$v_unsol_mscp] = true ;
	    Include_mask[inc$v_entry_select] = true ;
	    End ;

	[16]:				! Unknown entry
	    Begin
	    Include_mask[inc$v_unknown_entry] = true ;
	    Include_mask[inc$v_entry_select] = true ;
	    End ;

	[Outrange]:
	    Begin
	    Return false ;
	    End ;

	TES ;
	End ;

	If (.option_flag[opt$v_exclude_qual] AND .exclude_flag)
	Then
	    !
	    ! Set up the /exclude option selection indicators.
	    !
	    Begin
	    Case .key_value from 1 to max_keywords of
	    Set
!    	    [0]:				! Asynchronous communications device class
!		Begin
!	    	Exclude_mask[exc$v_async_comm] = true ;
!		Exclude_class[async] = DC$_ACOM ;
!		Exclude_key[async] = exc$v_async_comm ;
!		Exclude_mask[exc$v_dev_class_select] = true ;
!		End ;				

	    [1]:				! Bus device class
		Begin
		Exclude_mask[exc$v_buses] = true ;
		Exclude_class[bus] = DC$_BUS ;
		Exclude_key[bus] = .key_value ;
		Exclude_mask[exc$v_dev_class_select] = true ;
		End ;

	    [2]:				! Disk device class
		Begin
		Exclude_mask[exc$v_disks] = true ;
		Exclude_class[disk] = DC$_DISK ;
		Exclude_key[disk] = .key_value ;
		Exclude_mask[exc$v_dev_class_select] = true ;
		End ;

	    [3]:				! Realtime device class
		Begin
		Exclude_mask[exc$v_realtime] = true ;   
		Exclude_class[realtime] = DC$_REALTIME ;
		Exclude_key[realtime] = .key_value ;
		Exclude_mask[exc$v_dev_class_select] = true ;
		End ;

	    [4]:				! Synchronous communication device class
		Begin  
		Exclude_mask[exc$v_sync_comm] = true ;
		Exclude_class[sync] = DC$_SCOM ;
		Exclude_key[sync] = .key_value ;
		Exclude_mask[exc$v_dev_class_select] = true ;
		End ;

	    [5]:				! Tape device class
		Begin
		Exclude_mask[exc$v_tapes] = true ;
		Exclude_class[tape] = DC$_TAPE ;
		Exclude_key[tape] = .key_value ;
		Exclude_mask[exc$v_dev_class_select] = true ;
		End ;

	    [6]:				! Bugcheck entries 
		Begin	
		Exclude_mask[exc$v_bugchks] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		!
		! Determine if a specific type of bugcheck entry
		! was selected.
		!
		!***** Get value associated with it
		End ;

	    [7]:				! Control entries 
		Begin	
		Exclude_mask[exc$v_control_entry] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [8]:				! Cpu entries 
		Begin
		Exclude_mask[exc$v_cpu_entry] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [9]:				! Device error entries
		Begin
		Exclude_mask[exc$v_dev_errors] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [10]:				! Machine check entries
		Begin
		Exclude_mask[exc$v_machine_chks] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [11]:				! Memory entries
		Begin
		Exclude_mask[exc$v_memory] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [12]:				! Device timeout entries
		Begin
		Exclude_mask[exc$v_dev_timeouts] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [13]:				! Volume entries (mount/dismount)
		Begin
		Exclude_mask[exc$v_volume] = true ;
		Exclude_mask[exc$v_entry_select] = true ;	    
		End ;

	    [14]:				! Device attention entries
		Begin
		Exclude_mask[exc$v_dev_attentions] = true ;
		Exclude_mask[exc$v_entry_select] = true ;
		End ;

	    [15]:				! Unsolicited mscp entries (logmscp)
		Begin
		Exclude_mask[exc$v_unsol_mscp] = true ;
		Exclude_mask[exc$v_entry_select] = true ;
		End ;

	    [16]:				! Unnknown entry
		Begin
		Exclude_mask[exc$v_unknown_entry] = true ;
		Exclude_mask[exc$v_entry_select] = true ;
		End ;

            [Outrange]:
		Begin
		Return false ;
		End ;
	    TES ;
	    End ;
	End ;

!
! Output data is set up.
!
Return true ;

End ;		! Routine 


GLOBAL ROUTINE PARSE_DEVNAME (name) =

!++
!
! Functional Description:
!
!    This routine parses a device name specification. It will validate the
!    length and range of the unit number and that the characters specified
!    as the name/controller are within a valid range. It will also check
!    for wildcard name and unit selection.
!
! Calling Sequence:
!
!    PARSE_DEVNAME (device name descriptor)
!
! Input Parameters:
!
!    Device name descriptor = device name passed by descriptor
!
! Output Parameters:
!
!    *
!
!--
Begin

EXTERNAL
    Include_desc ;

LITERAL
    Min_len = 2,
    Max_len = 14,
    Unit_number_len = 5 ;

MAP
    Dev_select: REF $BBLOCK,
    Name:	REF $BBLOCK ;

LOCAL
    I,					! Temporary counter
    Name_size,				! Storage for node name size
    Name_len:	Initial (0),		! Storage for device name size
    Ptr, 				! Character string pointer
    Ptr_unit,				! Character string pointer to unit number
    Sp_chr_len:	Initial (0),
    Status,				! Completion status indicator
    Str_len,				! String length
    Tmp_ptr,				! Temporary character string pointer
    Unit_number,			! Storage for unit number
    Unit_len ;

!
! Set up the necessary pointers
!
Bind 
    Ptr_a = CH$PTR (UPLIT ('A')),
    Ptr_z = CH$PTR (UPLIT ('Z')),
    Ptr_0 = CH$PTR (UPLIT ('0')),
    Ptr_9 = CH$PTR (UPLIT ('9')),
    Ptr_star = CH$PTR (UPLIT ('*')),
    Ptr_colon = CH$PTR (UPLIT (':')) ;


!
! Determine if the string specified falls in the range of 
! the minimum/maximum possible length.
!
If (.name[dsc$w_length] LSS min_len) OR
    (.name[dsc$w_length] GTR max_len)
Then
    !
    ! The string is either too small or too large, indicate that
    ! this is invalid input by returning to the calling routine
    ! with a false value.
    !
    Return false ;

!
! Parse the device name specification.
!
! Set up pointer to the end of string and break out the
! unit number designation. 
!
Ptr = CH$PTR (.name[dsc$a_pointer],.name[dsc$w_length]-1) ;
Str_len = 0 ;
Unit_len = 0 ;
Sp_chr_len = 0 ;

Until (CH$GEQ (1,.ptr,1,ptr_a)) Do
    Begin
    If (CH$GEQ (1,.ptr,1,ptr_0)) AND
	(CH$LEQ (1,.ptr,1,ptr_9))
    Then
	!
	! Valid unit number, update string length and point to the
	! next character back.
	!
	Begin
	Unit_len = .unit_len + 1 ;
	Ptr = CH$PLUS (.ptr,-1) ;
	End
    Else
	!
	! Not a valid unit number, determine if it was a wildcard character.
	!
	Begin
	If (CH$EQL (1,.ptr,1,ptr_star))
	Then
	    !
	    ! Indicate  wildcard specified.
	    !
	    Begin
	    Sp_chr_len = .sp_chr_len + 1 ;
	    Ptr = CH$PLUS (.ptr,-1) ;
	    End 
	Else
	    Begin
	    If (CH$EQL (1,.ptr,1,CH$PTR (uplit('$'))))
	    Then
		Begin
		Exitloop ;
		End
	    Else
	        !
	        ! Not a valid unit number or wildcard designator, only other
	        ! valid input would be a colon. Determine if it was a colon.
	        !
	        Begin
	        If NOT (CH$EQL (1,.ptr,1,ptr_colon))
	        Then
		    !
		    ! Indicate that this is invalid input, by returning to the
		    ! calling routine with a false value.
		    !
		    Return false
	        Else
	 	    !
		    ! Character was a colon, point to the next character back.
		    !
		    Begin
		    Sp_chr_len = .sp_chr_len + 1 ;
		    Ptr = CH$PLUS (.ptr,-1) ;
	 	    End ;
		End ;
	    End ;
	End ;
    End ;

!
! Ensure that the unit number designation is not larger then 5 digits,
! convert and save it.
!
If .unit_len NEQ 0
Then
    Begin
    If (.unit_len GTRU unit_number_len)
    Then
	!
	! Unit number designation too large. Return to calling routine.
	!
	Return false
    Else
	!
	! Point to the begining of the unit number(s) and convert the 
	! ascii unit number to a binary value and save it.
	!
	Begin
	Ptr_unit = CH$PLUS (.ptr,1) ;
	If (status = LIB$CVT_DTB (.unit_len,.ptr_unit,unit_number))
	Then
	    !
	    ! Save the unit number in the queue entry.
	    !
	    Begin
	    Dev_select[dev$w_unit] = .unit_number
	    End
	Else
	    !
	    ! Error converting the unit number, notify user.
	    !
	    Signal (erf_cvterr, 2,.unit_len,ptr_unit) ;
	End ;
    End ;

!
! Set the pointer to the begining of the string. Calculate remaining
! string length. 
!
Ptr = CH$PTR (.name[dsc$a_pointer]) ;
Str_len = ((.name[dsc$w_length] - .unit_len) - .sp_chr_len);

!
! Determine if a node name was specified.
!
Tmp_ptr = CH$FIND_CH (.str_len,.ptr,%C'$') ;
If .tmp_ptr NEQ 0
Then
    !
    ! Not a null pointer, there is a node name. Update the string 
    ! pointer so it points to the device name and adjust the 
    ! string length.
    !
    Begin
    Name_size = CH$DIFF (.tmp_ptr, .ptr) ;
    If .name_size GTR 6
    Then
	!
	Signal_stop (msg$_invquaval, 2,.name,include_desc) ;

    Ptr = CH$PLUS (.tmp_ptr,1) ;
    Str_len = .str_len - (.name_size + 1) ;
    End 
Else
    !
    ! Did not locate a '$' in the string, ensure the string
    ! meets length restrictions for device name only.
    !
    Begin
    !
    ! Indicate that a node name was not specified.
    !
    Dev_select[dev$v_node_name_wild] = true ;

    If .str_len GEQ 7
    Then
	!
	! Illegal string length, for specifying device name 
	! without a node name.
	!
	Signal_stop (msg$_invquaval, 2,.name,include_desc) ;
 
    End ;

!
! Ensure that the device and controller designation are 
! valid. Save the starting pointer.
! 
Tmp_ptr = .ptr ;

Incr I from 1 to .str_len do
    Begin
    If (CH$GEQ (1,.ptr,1,ptr_a)) AND
	(CH$LEQ (1,.ptr,1,ptr_z))
    Then
	!
	! Valid character for this string, point to the next character.
	!
	Begin
	Name_len = .name_len + 1 ;
	Ptr = CH$PLUS (.ptr,1) ;
	End 
     Else
	Return false ;

    End ;

!
! Save the device and controller designation as 
! a counted ascii string.
!

Dev_select[dev$b_dev_name_length] = 
		((.name[dsc$w_length] - .unit_len) - .sp_chr_len) ;

CH$MOVE (.dev_select[dev$b_dev_name_length],
		.name[dsc$a_pointer],dev_select[dev$t_dev_name]) ;

!
! Save the two-character device name designation seperately, for use
! in correlating the device name with a device class.
!
If .str_len EQL 0
Then 
    ! Indicate that the device name has been wild carded.
    ! 
    Wild_carded_device = true 
Else
    ! There is a device name get the first two characters
    ! so that a device class can be translated.
    ! 
    CH$MOVE (2,.tmp_ptr,dev_name) ;
    
If .exclude_flag
Then
    !
    ! Indicate that this device is to be excluded.
    !
    Begin
    Dev_select[dev$v_exclude_flg] = true ;
    Exclude_mask[exc$v_device_select] = true ;
    End
Else
    Include_mask[inc$v_device_select] = true ;

Return true ;

End ;		! Routine


ROUTINE CLASS_OPTION_CHECK: NOVALUE =  

!++
!
! Functional Description:
!
!    This routine verifies that there are no conflicts between /exclude and 
!    /include device name and class option selections. Following is a set of
!    example inputs and a brief description of how they are handled:
!
!    /include=MF,TAPE (the queue entry for MF will be removed because that 
!			entire class of devices is selected (tape)).
!    /exclude=MF,TAPE (the queue entry for MF will be removed because that 
!			entire class of devices is selected (tape)).
!
!    /include=TAPE
!     and /exclude=MF (valid command - will output all tape entries except
!			MF entries)
!
!    /include=MF
!     and /exclude=TAPE (The /include option will take precedence over the 
!			/exclude option and the tape class indicator will 
!			be cleared.)
!
! Calling Sequence:
!
!    CLASS_OPTION_CHECK () ;
!
! Input Parameters:
!
!    None
!
! Output Parameters:
!
!    None
!
!--
Begin

MAP
    Dev_select:		REF $BBLOCK,
    Exclude_class:	REF VECTOR[,byte],
    Exclude_key:	REF VECTOR,
    Exclude_mask:	REF $BBLOCK,
    Include_class:	REF VECTOR[,byte],
    Include_key:	REF VECTOR,
    Include_mask:	REF $BBLOCK ;

LOCAL
    Status ;

!
! Both the /include and /exclude qualifiers have been parsed. Determine
! if there are any conflicts between the devices and device classes 
! that have been included / excluded.
!
! Ensure queue is not empty
!
If .que_entry_cnt LEQ 0
Then
    !
    ! Exit, empty queue
    !
    Return ;

!
! Determine if there were both device and device class entries selected.
!
If ((NOT .include_mask[inc$v_dev_class_select]) AND
    (NOT .include_mask[inc$v_device_select])) OR
   ((NOT .exclude_mask[exc$v_dev_class_select]) AND
    (NOT .exclude_mask[exc$v_device_select]))
Then
    !
    ! Either one of the other is not selected, return to calling 
    ! routine.
    !
    Return ;

!
! Get the address of the first entry in the queue.
! 
Que_entry_addrs = root_flink + .root_flink ;

!
! Read an entry from the queue.
!
Incr I from 1 to .que_entry_cnt do
    Begin
    !
    ! Determine if either the exclude or include device class
    ! selections conflict with any of the devices selected.
    ! (/include,/exclude=tapes and/or /include,/exclude=MF)
    !
    Incr J from 0 to max_class do
	Begin
	If .exclude_mask[exc$v_dev_class_select]
	Then   
	    ! Determine if exclude bit recorded in the entry was set.
	    Begin
	    If ( (.exclude_class[.J] EQL .que_entry_addrs[dev$b_class]) AND
		(.que_entry_addrs[dev$v_exclude_flg]) )
	    Then
		!
		! Remove entry from queue because the entire class
		! of devices is excluded.
		!
	  	Begin
		If NOT (status = LIB$REMQTI (root_flink,.que_entry_addrs))
		Then
		    Signal (.status) ;

		!
		! Update the que entry count, determine if there are
		! any device selections left, and return to calling routine.
		!    
		Exclude_q_entry_cnt = .exclude_q_entry_cnt - 1 ;

		If .que_entry_cnt EQL 0
		Then
		    !
		    ! Indicate that there are no device selections.
		    !
		    Begin
		    Exclude_mask[exc$v_device_select] = false ;
		    End ;

		Return ;
	 	End 
	    Else
		!
		! Conflicting /include and /exclude option
		! selections. Reset the exclude class selection.
		! Determine if there are any device class selections left,
		! notify the user and return.
		!
		Begin
		Exclude_mask[0,.(exclude_key+.J),1,0] = false ;

		!
		! Indicate that there are no device class 
		! selections made for /exclude.
		!
		Exclude_mask[exc$v_dev_class_select] = false ;
		Return ;
	   	End ;
	    End ;			

	If .include_mask[inc$v_dev_class_select]
	Then
	    !
	    ! Remove the entry from the queue because either (1)entire class
	    ! of devices is includes OR (2)conflicting /include and 
	    ! /exclude options were selected (The /include selection has
	    ! precedence over the /exclude selection). 
	    !
	    Begin
	    If ( (.include_class[.J] EQL .que_entry_addrs[dev$b_class]) AND
		(NOT .que_entry_addrs[dev$v_exclude_flg]) )
	    Then
		!
		!
		!
		Begin
		If NOT (status = LIB$REMQTI (root_flink,.que_entry_addrs))
		Then
		    Signal (.status) ;

		!
		! Update the que entry count, and determine if there are 
		! any device selections left.
		!
		Include_q_entry_cnt = .include_q_entry_cnt - 1 ;
		If .que_entry_cnt EQL 0
		Then
		    !
		    ! Indicate that there are no device selections.
		    !
		    Begin
		    Include_mask[inc$v_device_select] = false ;
		    End ;

		Return ;
	 	End ;
	    End ;			
 	End ;

    !
    ! Update the que entry address, to get the next entry.
    !
    Que_entry_addrs = .que_entry_addrs + .que_entry_addrs[dev$a_flink] ;
    End ;
End ;		! Routine


GLOBAL ROUTINE DEVICE_OPTION_CHECK =  

!++
!
! Functional Description:
!
!    This routine verifies that there are no conflicts between;
!    (1) /exclude and /include device name selections, (2) any of the 
!    'values' specified for either /include or /exclude. Following is a
!    set of example inputs and a brief description of how they are handled:
!
!    /include=MF,MF (only one entry for MF will be in the device selection queue
!    /exclude=MF,MF (")
!
!    /include=MF
!     and /exclude=MF (user will get an error message, invalid option selection)
!
!  Return false if like entry already exists in queue.
!  Return true if ok to put entry in queue.
!  Exits with and error message if conflicting entry already in queue.
!
! Calling Sequence:
!
!    DEVICE_OPTION_CHECK () ;
!
! Input Parameters:
!
!    None
!
! Output Parameters:
!
!    None
!
! Implicit Inputs:
!
!
! Implicit Outputs:
!
!
!--
Begin

EXTERNAL
    Exclude_desc,
    Include_desc ;

MAP
    Dev_select:		REF $BBLOCK ;

If NOT SEARCH_QUEUE (dev_select[dev$t_dev_name],
    dev_select[dev$b_dev_name_length],dev_select[dev$w_unit])
Then
    !
    ! The selected entry does not match any entries already 
    ! in the queue.
    ! 
    Return true ;

!
! Indicate that conflicting /exclude and /include option 
! selections.
!
Signal (erf_cnfquaval, 2,exclude_desc,include_desc) ;

!
! Due to the error message severity (fatal) this should never 
! be executed but satisfies the return value business for the 
! compiler.
!
Return false ;

End ;		! Routine


GLOBAL ROUTINE SEARCH_QUEUE (name,name_length,unit_number) = 

!++
!
! Functional Description:
!
!    This routine will search the device name queue and determine whether
!    the device name/unit passed to it matches any of the entries in the 
!    queue. It will return true if match on either device name/unit or
!    return false if no match.
!
! Calling Sequence:
!
!    SEARCH_QUEUE (device name,device name length,unit number)
!
! Input Parameters:
!
!    Address of device name 
!    Address of device name length
!    Unit number
!
! Output Parameters:
!
!    None
! 
!--
Begin

LOCAL 
    Device_selected:	BYTE
			Initial (false),
    Entry_name,
    Entry_name_size,
    I:			WORD
			Initial (.que_entry_cnt),
    Name_ptr,
    Ptr,
    Size ,
    Size_adj ;

Bind select_name_size = .name_length : byte ;
Bind unit = .unit_number : word ;

!
! Ensure queue is not empty
!
If .que_entry_cnt LEQ 0
Then
    !
    ! Exit, empty queue
    !
    Return false ;

!
! Get the address of the first entry in the queue.
!
Que_entry_addrs = root_flink + .root_flink ;

!
! Read an entry from the queue.
!
Until (.I EQL 0) OR (.device_selected) do
    Begin
    !
    ! Determine if the selected device name/controller match the 
    ! device name/controller recorded by this queue entry.
    !
    !
    ! Determine if the node name in the queue entry was wild carded.
    !
    If .que_entry_addrs[dev$v_node_name_wild] 
    Then
	!
	! The node name is wild carded, locate the '$' in the string
	! and adjust the length and starting address of the string so
	! that the compare will be against the device name only.
	!
	Begin
	Ptr = CH$FIND_CH (..name_length,.name,%C'$') ;
	If .ptr NEQ 0
	Then
	    !
	    ! Found a $ in the string, compensate for node name being
	    ! logged and being wild carded when device(s) selected for 
	    ! output.
	    !
	    Begin
	    Size_adj = (.ptr - .name) ;
	    .Name_length = (..name_length - .size_adj) ;
	    Name = CH$PLUS (.ptr,1) ;
	    End ;
	End ;

    Size = MINU (.que_entry_addrs[dev$b_dev_name_length],.select_name_size) ;

    !
    ! Determine if the device name/controller match.
    !
    If CH$EQL (.size,.name,.size,que_entry_addrs[dev$t_dev_name])
    Then
	!
	! Determine if a unit number was specified.
	!
	Begin
	Device_selected = true ;

	If .que_entry_addrs[dev$w_unit] NEQ (-1)
	Then
	    ! 
	    ! Unit number was specified, determine if it matches.
	    !
	    Begin
	    If .unit NEQU .que_entry_addrs[dev$w_unit] 
	    Then
		!
		! Indicate that the unit number did not
		! match.
		!
		Device_selected = false ;
	    End ;

	If .device_selected
	Then
	    Exitloop ;

	End ;

    !
    ! Update the que entry address and decrement the number of 
    ! queue entries that have been searched.
    !
    Que_entry_addrs = .que_entry_addrs + .que_entry_addrs[dev$a_flink] ;
    I = .I - 1 ;
    End ;

!
! Ensure that the device name/controller designation and unit 
! numbers match, determine whether the entry is for a /include 
! and /exclude option.
!
If .device_selected
Then
    Begin
    If .exclude_flag AND .que_entry_addrs[dev$v_exclude_flg]
    Then
	!
	! Indicate that a '/excluded' entry was found by
	! returning with a true value.
	!
	Return true 
    Else
	Begin
	If (NOT .exclude_flag) AND (NOT .que_entry_addrs[dev$v_exclude_flg])
	Then
	    !
 	    ! Indicate that a '/included' entry was found by
	    ! returning with a true value.
	    ! 
	    Return true ;
	End ;
    End ;
!
! No matching entries, return to calling routine.
!
Return false ;

End ;		! Routine


GLOBAL ROUTINE TRANSLATE_DEVICE (search_name,dev_class) =
Begin

!++
!
! Functional Description:
!
!    This routine searches the device tables to translate the 
!    known device name to a device class. 
!
! Calling Sequence:
!
!    TRANSLATE_DEVICE (search_name,dev_class)
!
! Input Parameters:
!
!    Search name = First two characters of device name
!
! Output Parameters:
!
!    Dev_class = Device class if device name found ELSE
!		 -1 if device name not located in table.
!
!    Returns true if a match occurred.
!    Returns false if unsupported device. (This should eventually be
!	caught and handled by the parse_devname routine.)
!
!--

EXTERNAL
    Dev_addrs_ptr:	REF VECTOR [,long],
    Dev_class_ptr:	REF VECTOR [,word],
    Max_classes:	REF VECTOR [,byte];

OWN
    I:		BYTE Initial (1),		! Device address pointer index
    Max_classes_value: BYTE;

LOCAL 
    Dev_specific_tbl:	REF VECTOR [,word], ! Device specific table address
    K:  	Initial (0) ;		! Device specific table index

BIND
    Cs_name = CH$PTR (uplit('CS')) ;

!
! Class dir is the address of a table that contains supported device 
! classes and pointers to the device class specific information tables. 
!
! The device class specific table contains the supported device names, 
! image name pointers (image that needs to get activated), and transfer 
! address pointers.
!
! This routine searches all of the device class specific tables until a 
! matching device name is located, and returns the appropriate device class.
!
! Loop through all of the device class specific pointers in the class dir 
! table.
!

Max_classes_value = max_classes[0];

Incr I from 1 to .max_classes_value do
    Begin
    !
    ! Get the address of a device class specific table.
    !
    Dev_specific_tbl = .dev_addrs_ptr[.I] ;

    !
    ! Initialize another index for the device class specific table so don't
    ! lose the current position. Determine if the contents of the device 
    ! name field is valid OR whether the end of the device name entries 
    ! in the table has been reached. 
    !
    K = 1 ;
    Until (.K EQL .dev_specific_tbl[0]) do
	Begin
	!
	! Determine if the selected device name matches any of the
	! device names recorded in this table.
	!
	If CH$EQL (2, CH$PTR(.search_name), 2, CH$PTR(dev_specific_tbl[.K]))
	Then
	    !
	    ! The device names match. Using the class dir table index, 
	    ! get the corresponding device class. (The index is divided 
	    ! by 2 because device classes are words and the index is for 
	    ! longwords).
	    !
	    Begin
	    .Dev_class = .dev_class_ptr[.I] ;
	    Return true ;
	    End ;

	!
	! Update the device name pointer indices.
	!
	K = .K + 1 ;
	End ;
    End ;


! 
! The name for the console device 'CSA' is not included in the device name
! tables contained in ERFLIB.TLB. It really is a second device name for
! the RX device which is included in the device tables. There should be
! a table that includes devices like these, however because there is only 
! one at this time, it is checked for explicitly.
!
If CH$EQL (2, CH$PTR(.search_name), 2, cs_name)
Then
    !
    ! Return the device class.
    !
    Begin
    .Dev_class = DC$_DISK ;
    Return true ;
    End ;

!
! Could not locate a class for this device name.
!
.Dev_class = -1 ;
Return false ;

End ;		! Routine


GLOBAL ROUTINE GET_VM (size) = 

!++
!
! Functional Description:
!
!    This routine calls the LIB$GET_VM library routine to allocate the
!    requested amount of virtual memory. If the request completed 
!    successfully the allocated area is cleared, else an error is notified.
!
! Calling Sequence:
!
!    Base_adr = GET_VM (size)
!
! Input Parameters:
!
!   Size in bytes) of the area to be allocated.
!
! Output Parameters:
!
!    Base address of the allocated area (address of the first byte).
!
!--
Begin

LOCAL
    Base_addrs,				! Storage for returned base address
    Status ;				! Storage for the return status

!
! Call the LIB$GET_VM routine to allocate the requested amount of 
! virtual memory and if it was not successful, notify the user and exit.
!
Status = LIB$GET_VM (size,base_addrs) ;

If NOT .status
Then
    Signal (.status) ;

!
! Clear the allocated area and return the base address of the area
! to the calling routine.
!
CH$FILL (0, .size, .base_addrs) ;
.Base_addrs
End ;

End 
ELUDOM
