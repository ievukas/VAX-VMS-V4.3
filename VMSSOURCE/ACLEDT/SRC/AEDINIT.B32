MODULE AED$INIT (
		 LANGUAGE (BLISS32),
		 IDENT = 'V04-000',
		 MAIN = AED_INIT
		 ) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	Miscellaneous utilities
!
! ABSTRACT:
!
!	This module contains the initialization routines for the ACL editor.
!	It also contains some miscellaneous support routine.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, user mode utilities.
!
!--
!
!
! AUTHOR:	L. Mark Pilant		CREATION DATE:	12-Nov-1982  9:50
!
! MODIFIED BY:
!
!	V03-019	LMP0300		L. Mark Pilant,		9-Aug-1984  9:14
!		Use the correct journal file spec when editing the ACL of a
!		device.
!
!	V03-018	LMP0283		L. Mark Pilant,		25-Jul-1984  12:38
!		Make sure the default object type is a file.
!
!	V03-017	LMP0270		L. Mark Pilant,		29-Jun-1984  8:44
!		Correctly handle a control-C.
!
!	V03-016	LMP0268		L. Mark Pilant,		28-Jun-1984  15:02
!		Dont' delete the journal file if aborting via control-C.
!
!	V03-015	LMP0230		L. Mark Pilant,		16-Apr-1984  9:14
!		Track changes made to the $CHANGE_ACL system service.
!
!	V03-014	LMP0223		L. Mark Pilant,		6-Apr-1984  13:05
!		Use the correct amount of storage for the lock block.
!
!	V03-013	LMP0213		L. Mark Pilant,		24-Mar-1984  12:23
!		Add support for locking and unlocking the object's ACL.
!
!	V03-012	LMP0193		L. Mark Pilant,		14-Feb-1984  11:46
!		Modify the way the journal and recovery files are used.
!		Instead of the ACL, it now logs key-strokes.
!
!	V03-011	LMP0185		L. Mark Pilant,		4-Feb-1984  12:20
!		Add support for device ACLs.
!
!	V03-010	LMP0181		L. Mark Pilant,		15-Dec-1983  9:51
!		Change code to use $CHANGE_ACL instead of the ACP to do
!		ACL twiddling.
!
!	V03-009	LMP0172		L. Mark Pilant,		28-Nov-1983  12:11
!		Numerous bug fixes, support for VT2xx terminals, and a
!		session keystroke logger.
!
!	V03-008	LMP0147		L. Mark Pilant,		29-Aug-1983  9:48
!		Add support for handling multi-line ACEs during initialization.
!
!	V03-007	LMP0144		L. Mark Pilant,		25-Aug-1983  10:12
!		Remember initial state of the keypad.
!
!	V03-006	LMP0142		L. Mark Pilant,		24-Aug-1983  3:18
!		Change references to ACLEDIT$INI to be ACLEDIT$INIT.
!
!	V03-005	LMP0103		L. Mark Pilant,		27-Apr-1983  15:20
!		Add support for HIDDEN and PROTETCED ACEs.
!
!	V03-004	LMP0102		L. Mark Pilant,		19-Apr-1983  14:59
!		Use correct funtion codes when building a file's ACL from a
!		recovery journal file.
!
!	V03-003	LMP0100		L. Mark Pilant,		14-Apr-1983  12:12
!		Add the $FORMAT_ACL and $PARSE_ACL system services.
!
!	V03-002	LMP0076		L. Mark Pilant,		24-Jan-1983  9:06
!		Add support for an action definition file.
!
!	V03-001	LMP0074		L. Mark Pilant,		20-Jan-1983  12:07
!		Add support for handling RMS journal ACE's.
!
!**

LIBRARY 'SYS$LIBRARY:LIB.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';
REQUIRE 'SRC$:ACLEDTDEF';

FORWARD ROUTINE
	AED_INIT,				! Main intialization/startup routine
	AED_FILERROR	: NOVALUE,		! Common error reporting
	AED_CTRLCAST	: NOVALUE,		! Control-C handler
	AED_HANDLER,				! ACL editor main handler
	AED_PUTOUTPUT;				! General purpose output routine

EXTERNAL ROUTINE
	AED_PROCESSACL	: NOVALUE,		! Main ACL processing routine
	AED_CLEANUP	: NOVALUE,		! Termination cleanup routine
	AED_GETKEYINI,				! Open action definition file
	AED_FLUSHKEY,				! Flush session keystroke buffer
	AED_SET_CURSOR;				! Set cursor position

OWN
	AED_L_LOCKINFO	: $BBLOCK [ACL$S_RLOCK_ACL],
	OBJECT_FAB	: $FAB_DECL,		! Input object FAB
	OBJECT_NAM	: $NAM_DECL;		! Input object NAM block

ROUTINE AED_INIT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the main routine.  It initializes all variables,
!	parses the input qualifiers and objects, opens journal and recovery
!	files (if necessary), and sets up the scope for editing.
!
!--

BEGIN

LOCAL
	VERB_DESC	: $BBLOCK [DSC$C_S_BLN],	! Invoking DCL verb
	CMD_DESC	: $BBLOCK [DSC$C_S_BLN],	! Invoking DCL verb option
	JOURNAL_DESC	: $BBLOCK [DSC$C_S_BLN],	! Journal file descr
	RECOVER_DESC	: $BBLOCK [DSC$C_S_BLN],	! Revocery file descr
	KEEP_DESC	: $BBLOCK [DSC$C_S_BLN],	! /KEEP value
	MODE_DESC	: $BBLOCK [DSC$C_S_BLN],	! /MODE value
	TERM_CHAR	: VECTOR [3],		! Terminal characteristics
	OBJ_EXP_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Expanded file name
	OBJ_RES_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Resultant file name
	JOU_EXP_NAME	: $BBLOCK [NAM$C_MAXRSS],
	JOU_RES_NAME	: $BBLOCK [NAM$C_MAXRSS],
	REC_EXP_NAME	: $BBLOCK [NAM$C_MAXRSS],
	REC_RES_NAME	: $BBLOCK [NAM$C_MAXRSS],
	DEVICE_TYPE,				! Device type code
	DEVICE_CLASS,				! Device class code
	DEVICE_DEPEND	: $BBLOCK [4],		! Device information
	DEVICE_DEPEND2	: $BBLOCK [4],		! Additional device info
	GETDVI_ARGLIST	: BLOCKVECTOR [6, ITM$S_ITEM, BYTE],	! GETDVI arg list
	ACL_FIB		: $BBLOCK [FIB$C_LENGTH],	! For ACL context
	ACL_FIB_DESC	: $BBLOCK [DSC$C_S_BLN],	! FIB descriptor
	ATR_ARGLIST	: BLOCKVECTOR [2, ITM$S_ITEM, BYTE],	! ACL attribute descriptor
	ACE_POINTER	: REF $BBLOCK,		! Address of current ACE
	ACE_NEWADDR	: REF $BBLOCK,		! Copy of the header ACE
	ACE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Binary ACE descr
	ACE_TEXT_DESC	: $BBLOCK [DSC$C_S_BLN],	! Text ACE descriptor
	ACE_TEXT_SIZE,				! Text ACE size
	ACE_TEXT	: $BBLOCK [3072],	! Text ACE storage
	NEW_TEXT_LINE	: REF $BBLOCK,		! Converted line storage addr
	FILE_HEADER	: $BBLOCK [512],	! Storage for the file header
	FIRST_CHAR,				! Address of first char of segment
	LAST_CHAR,				! Address of last char of segment
	SEGMENT_SIZE,				! Size of segment
	ACL_CONTEXT;				! ACL context for $CHANGE_ACL

! Initialize common variables and flags

ENABLE AED_HANDLER;

AED_L_FLAGS = 0;
AED_B_OPTIONS = 0;
AED_L_WORSTERR = SS$_NORMAL;
AED_B_LINE = AED_B_COLUMN = 1;
DEVICE_TYPE = DEVICE_CLASS = 0;
DEVICE_DEPEND = DEVICE_DEPEND2 = 0;

CH$FILL (0, DSC$C_S_BLN, AED_Q_OBJNAM);		! Initialize the descriptor
AED_Q_OBJNAM[DSC$B_CLASS] = DSC$K_CLASS_D;	! Dynamic descriptor
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, VERB_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, CMD_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, JOURNAL_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, RECOVER_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, KEEP_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, MODE_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, ACE_DESC);
CH$MOVE (DSC$C_S_BLN, AED_Q_OBJNAM, ACE_TEXT_DESC);
CH$FILL (0, 6*ITM$S_ITEM, GETDVI_ARGLIST);
CH$FILL (0, 2*ITM$S_ITEM, ATR_ARGLIST);

! Initialize all of the necessary RMS file data structures.

$FAB_INIT (FAB = OBJECT_FAB,
	   FAC = <GET, PUT>,
	   FOP = UFO,
	   NAM = OBJECT_NAM,
	   SHR = <GET, UPI>);
$NAM_INIT (NAM = OBJECT_NAM,
	   ESA = OBJ_EXP_NAME,
	   ESS = NAM$C_MAXRSS,
	   RSA = OBJ_RES_NAME,
	   RSS = NAM$C_MAXRSS);

$FAB_INIT (FAB = JOURNAL_FAB,
	   ALQ = 5,
	   DNA = UPLIT ('.JOU'),
	   DNS = %CHARCOUNT ('.JOU'),
	   FAC = <GET, PUT, TRN, DEL>,
	   FOP = <SQO, OFP>,
	   NAM = JOURNAL_NAM,
	   ORG = SEQ,
	   RFM = VAR,
	   XAB = JOURNAL_XABPRO);
$NAM_INIT (NAM = JOURNAL_NAM,
	   ESA = JOU_EXP_NAME,
	   ESS = NAM$C_MAXRSS,
	   RLF = OBJECT_NAM,
	   RSA = JOU_RES_NAME,
	   RSS = NAM$C_MAXRSS);
$XABPRO_INIT (XAB = JOURNAL_XABPRO,
	      PRO = <,RWED,,>);
$RAB_INIT (RAB = JOURNAL_RAB,
	   FAB = JOURNAL_FAB,
	   RAC = SEQ,
	   ROP = TPT);

$FAB_INIT (FAB = RECOVER_FAB,
	   DNA = UPLIT ('.JOU'),
	   DNS = %CHARCOUNT ('.JOU'),
	   FAC = <GET, DEL>,
	   FOP = <SQO, OFP>,
	   NAM = RECOVER_NAM,
	   ORG = SEQ,
	   RFM = VAR);
$NAM_INIT (NAM = RECOVER_NAM,
	   ESA = REC_EXP_NAME,
	   ESS = NAM$C_MAXRSS,
	   RLF = OBJECT_NAM,
	   RSA = REC_RES_NAME,
	   RSS = NAM$C_MAXRSS);
$RAB_INIT (RAB = RECOVER_RAB,
	   FAB = RECOVER_FAB,
	   RAC = SEQ);

! Assign channels for terminal input and output.

AED_L_STATUS = $ASSIGN (DEVNAM = $DESCRIPTOR ('SYS$INPUT'),
			CHAN = AED_W_TERMIN);
IF NOT .AED_L_STATUS
THEN
    BEGIN
    SIGNAL (.AED_L_STATUS);
    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
    END;

AED_L_STATUS = $ASSIGN (DEVNAM = $DESCRIPTOR ('SYS$OUTPUT'),
			CHAN = AED_W_TERMOUT);
IF NOT .AED_L_STATUS
THEN
    BEGIN
    SIGNAL (.AED_L_STATUS);
    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
    END;

! Get the necessary information about the terminal

GETDVI_ARGLIST[0, ITM$W_ITMCOD] = DVI$_DEVTYPE;
GETDVI_ARGLIST[0, ITM$W_BUFSIZ] = 4;
GETDVI_ARGLIST[0, ITM$L_BUFADR] = DEVICE_TYPE;
GETDVI_ARGLIST[1, ITM$W_ITMCOD] = DVI$_DEVCLASS;
GETDVI_ARGLIST[1, ITM$W_BUFSIZ] = 4;
GETDVI_ARGLIST[1, ITM$L_BUFADR] = DEVICE_CLASS;
GETDVI_ARGLIST[2, ITM$W_ITMCOD] = DVI$_DEVDEPEND;
GETDVI_ARGLIST[2, ITM$W_BUFSIZ] = 4;
GETDVI_ARGLIST[2, ITM$L_BUFADR] = DEVICE_DEPEND;
GETDVI_ARGLIST[3, ITM$W_ITMCOD] = DVI$_DEVDEPEND2;
GETDVI_ARGLIST[3, ITM$W_BUFSIZ] = 4;
GETDVI_ARGLIST[3, ITM$L_BUFADR] = DEVICE_DEPEND2;
GETDVI_ARGLIST[4, ITM$W_ITMCOD] = DVI$_DEVBUFSIZ;
GETDVI_ARGLIST[4, ITM$W_BUFSIZ] = 4;
GETDVI_ARGLIST[4, ITM$L_BUFADR] = AED_L_PAGEWIDTH;

AED_L_STATUS = $GETDVI (CHAN = .AED_W_TERMIN,
			ITMLST = GETDVI_ARGLIST,
			IOSB = AED_W_IOSB);
IF .AED_L_STATUS THEN AED_L_STATUS = .AED_W_IOSB[0];
IF NOT .AED_L_STATUS
THEN
    BEGIN
    SIGNAL (.AED_L_STATUS);
    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
    END;

AED_L_PAGESIZE = .DEVICE_DEPEND<24,8>;
IF .DEVICE_CLASS NEQ DC$_TERM THEN AED_L_PAGEWIDTH = 132;
IF .DEVICE_TYPE EQL TT$_VT52
OR .DEVICE_TYPE EQL TT$_VT55
THEN AED_L_FLAGS[AED_V_VT5X] = 1;
IF .DEVICE_DEPEND2[TT2$V_DECCRT] THEN AED_L_FLAGS[AED_V_VT1XX] = 1;
IF .DEVICE_DEPEND2[TT2$V_DECCRT2] THEN AED_L_FLAGS[AED_V_VT2XX] = 1;
AED_L_FLAGS[AED_V_WRAP] = .DEVICE_DEPEND[TT$V_WRAP];
AED_L_FLAGS[AED_V_SCOPE] = .DEVICE_DEPEND[TT$V_SCOPE];
AED_L_FLAGS[AED_V_APPLICAT] = .DEVICE_DEPEND2[TT2$V_APP_KEYPAD];
!AED_L_FLAGS[AED_V_OVERSTRIKE] = NOT .DEVICE_DEPEND2[TT2$V_INSERT];

! If the terminal is a scope, set it to nowrap, set it to the home position,
! clear the entire screen, and set the alternate keypad if possible.

IF .AED_L_FLAGS[AED_V_SCOPE]
THEN
    BEGIN
    AED_L_STATUS = $QIOW (CHAN = .AED_W_TERMOUT,
			  FUNC = IO$_SENSEMODE,
			  IOSB = AED_W_IOSB,
			  P1 = TERM_CHAR);
    IF .AED_L_STATUS THEN AED_L_STATUS = .AED_W_IOSB[0];
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;
    IF .AED_L_FLAGS[AED_V_WRAP]
    THEN
	BEGIN
	$BBLOCK [TERM_CHAR[1], TT$V_WRAP] = 0;
	AED_L_STATUS = $QIOW (CHAN = .AED_W_TERMOUT,
			      FUNC = IO$_SETMODE,
			      IOSB = AED_W_IOSB,
			      P1 = TERM_CHAR);
	IF .AED_L_STATUS THEN AED_L_STATUS = .AED_W_IOSB[0];
	IF NOT .AED_L_STATUS
	THEN
	    BEGIN
	    SIGNAL (.AED_L_STATUS);
	    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	    END;
	END;
    AED_L_STATUS = $QIOW (CHAN = .AED_W_TERMIN,
			  FUNC = IO$_SETMODE OR IO$M_CTRLCAST,
			  IOSB = AED_W_IOSB,
			  P1 = AED_CTRLCAST);
    IF .AED_L_STATUS THEN AED_L_STATUS = .AED_W_IOSB[0];
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (.AED_L_STATUS);
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;
    SCR$ERASE_PAGE (1, 1);
    SCR$SET_SCROLL (1, 20);			! Set up the scrolling region
    IF (.AED_L_FLAGS[AED_V_VT5X] OR .AED_L_FLAGS[AED_V_VT1XX])
    AND NOT .AED_L_FLAGS[AED_V_APPLICAT]
    THEN AED_PUTOUTPUT ($DESCRIPTOR (%CHAR(AED_C_CHAR_ESC),'='));
    END;

! Get the name of the object whose ACL is to be modified.

CLI$GET_VALUE ($DESCRIPTOR ('INPUT'), AED_Q_OBJNAM);

! Determine what DCL verb and option used to invoke this image.  Also, set the
! appropriate default object type code.

CLI$GET_VALUE ($DESCRIPTOR ('$VERB'), VERB_DESC);
IF CH$EQL (.VERB_DESC[DSC$W_LENGTH], .VERB_DESC[DSC$A_POINTER],
	   MINU (.VERB_DESC[DSC$W_LENGTH], %CHARCOUNT ('EDIT')), UPLIT ('EDIT'),
	   0)
THEN AED_L_OBJTYP = ACL$C_FILE;				! Set default type

IF CH$EQL (.VERB_DESC[DSC$W_LENGTH], .VERB_DESC[DSC$A_POINTER],
	   MINU (.VERB_DESC[DSC$W_LENGTH], %CHARCOUNT ('SET')), UPLIT ('SET'),
	   0)
THEN
    BEGIN
    CLI$GET_VALUE ($DESCRIPTOR ('OPTION'), CMD_DESC);
    IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	       MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('FILE')), UPLIT ('FILE'),
	       0)
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_SET_FILE_CMD] = 1;
	AED_L_OBJTYP = ACL$C_FILE;
	END;

    IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	       MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('DIRECTORY')), UPLIT ('DIRECTORY'),
	       0)
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_SET_DIR_CMD] = 1;
	AED_L_OBJTYP = ACL$C_FILE;
	END;

    IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	       MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('DEVICE')), UPLIT ('DEVICE'),
	       0)
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_SET_DEV_CMD] = 1;
	AED_L_OBJTYP = ACL$C_DEVICE;
	END;

    IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	       MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('ACL')), UPLIT ('ACL'),
	       0)
    THEN
	BEGIN
	AED_L_FLAGS[AED_V_SET_ACL_CMD] = 1;
	AED_L_OBJTYP = ACL$C_FILE;
	END;
    END;

! Get the object's type code.

IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.FILE')) THEN AED_L_OBJTYP = ACL$C_FILE;
IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.DEVICE')) THEN AED_L_OBJTYP = ACL$C_DEVICE;
IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.QUEUE')) THEN AED_L_OBJTYP = ACL$C_JOBCTL_QUEUE;
IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.EVENT_CLUSTER')) THEN AED_L_OBJTYP = ACL$C_COMMON_EF_CLUSTER;
IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.LOGICAL_NAME_TABLE')) THEN AED_L_OBJTYP = ACL$C_LOGICAL_NAME_TABLE;
IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.PROCESS')) THEN AED_L_OBJTYP = ACL$C_PROCESS;
IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.GLOBAL_SECTION')) THEN AED_L_OBJTYP = ACL$C_GLOBAL_SECTION;

! Parse the verious options that the user may have specified.

IF (AED_B_OPTIONS[AED_V_JOURNAL] = CLI$PRESENT ($DESCRIPTOR ('JOURNAL')))
THEN
    BEGIN
    CLI$GET_VALUE ($DESCRIPTOR ('JOURNAL'), JOURNAL_DESC);
    JOURNAL_RAB[RAB$L_RBF] = JOURNAL_BUFFER;
    JOURNAL_RAB[RAB$W_RSZ] = 10;
    JOURNAL_INDEX = 0;
    END;

IF (AED_B_OPTIONS[AED_V_RECOVER] = CLI$PRESENT ($DESCRIPTOR ('RECOVER')))
THEN
    BEGIN
    CLI$GET_VALUE ($DESCRIPTOR ('RECOVER'), RECOVER_DESC);
    RECOVER_RAB[RAB$L_UBF] = RECOVER_BUFFER;
    RECOVER_RAB[RAB$W_USZ] = 10;;
    RECOVER_RAB[RAB$W_RSZ] = 0;
    RECOVER_INDEX = 0;
    END;

AED_B_OPTIONS[AED_V_KEEPREC] = CLI$PRESENT ($DESCRIPTOR ('KEEP.RECOVERY'));
AED_B_OPTIONS[AED_V_KEEPJNL] = CLI$PRESENT ($DESCRIPTOR ('KEEP.JOURNAL'));

AED_L_FLAGS[AED_V_PROMPT] = CLI$PRESENT ($DESCRIPTOR ('MODE.PROMPT'));

! Now that all of the necessary command line parsing has been done, attempt
! to lock the object for future ACL modifications.

ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_WLOCK_ACL;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_WLOCK_ACL;
ATR_ARGLIST[0, ITM$L_BUFADR] = AED_L_LOCKINFO;
AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
			    OBJTYP = AED_L_OBJTYP,
			    OBJNAM = AED_Q_OBJNAM,
			    ITMLST = ATR_ARGLIST);
IF NOT .AED_L_STATUS
THEN
    BEGIN
    IF .AED_L_STATUS EQL SS$_NOTQUEUED
    THEN SIGNAL (AED$_OBJLOCKED)
    ELSE SIGNAL (.AED_L_STATUS);
    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
    END;
CH$FILL (0, 2*ITM$S_ITEM, ATR_ARGLIST);

! If the target object is a file, it is necessary to open the file and get
! the channel assigned to it.  Otherwise, do a parse to fill in the NAMe
! block necessary for the journal and recovery file names.

IF .AED_L_OBJTYP EQL ACL$C_FILE
THEN
    BEGIN
    OBJECT_FAB[FAB$L_FNA] = .AED_Q_OBJNAM[DSC$A_POINTER];
    OBJECT_FAB[FAB$B_FNS] = .AED_Q_OBJNAM[DSC$W_LENGTH];
    IF NOT $OPEN (FAB = OBJECT_FAB)
    THEN
	BEGIN
	AED_FILERROR (AED$_OPENIN, OBJECT_FAB, .OBJECT_FAB[FAB$L_STS],
					       .OBJECT_FAB[FAB$L_STV]);
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;

    AED_Q_OBJNAM[DSC$W_LENGTH] = .OBJECT_NAM[NAM$B_RSL];
    AED_Q_OBJNAM[DSC$A_POINTER] = .OBJECT_NAM[NAM$L_RSA];
    AED_W_OBJCHAN = .OBJECT_FAB[FAB$L_STV];

! Determine whether or not the file is a directory file.

    ATR_ARGLIST[0, ATR$W_TYPE] = ATR$C_HEADER;
    ATR_ARGLIST[0, ATR$W_SIZE] = ATR$S_HEADER;
    ATR_ARGLIST[0, ATR$L_ADDR] = FILE_HEADER;
    AED_L_STATUS = $QIOW (CHAN = .AED_W_OBJCHAN,
			  FUNC = IO$_ACCESS,
			  IOSB = AED_W_IOSB,
			  P5 = ATR_ARGLIST);
    IF .AED_L_STATUS THEN AED_L_STATUS = .AED_W_IOSB[0];
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	SIGNAL (AED$_READERR, 1, AED_Q_OBJNAM, .AED_L_STATUS, 0);
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;
    AED_L_FLAGS[AED_V_DIRECTORY] = .FILE_HEADER[FH2$V_DIRECTORY];
    CH$FILL (0, 2*ITM$S_ITEM, ATR_ARGLIST);
    END
ELSE
    BEGIN
    OBJECT_FAB[FAB$L_FNA] = .AED_Q_OBJNAM[DSC$A_POINTER];
    OBJECT_FAB[FAB$B_FNS] = .AED_Q_OBJNAM[DSC$W_LENGTH];
    IF .AED_L_OBJTYP EQL ACL$C_DEVICE
    AND .VECTOR [.AED_Q_OBJNAM[DSC$A_POINTER], .AED_Q_OBJNAM[DSC$W_LENGTH] - 1; , BYTE] EQL ':'
    THEN OBJECT_FAB[FAB$B_FNS] = .OBJECT_FAB[FAB$B_FNS] - 1;

    IF NOT $PARSE (FAB = OBJECT_FAB)
    THEN
	BEGIN
	AED_FILERROR (AED$_SYNTAX, OBJECT_FAB, .OBJECT_FAB[FAB$L_STS],
					       .OBJECT_FAB[FAB$L_STV]);
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;
    OBJECT_NAM[NAM$B_RSL] = .OBJECT_NAM[NAM$B_ESL];
    OBJECT_NAM[NAM$L_RSA] = .OBJECT_NAM[NAM$L_ESA];
    AED_W_OBJCHAN = 0;
    END;

! Open the journal file and the recovery file if specified.

IF .AED_B_OPTIONS[AED_V_RECOVER]
THEN
    BEGIN
    RECOVER_FAB[FAB$L_FNA] = .RECOVER_DESC[DSC$A_POINTER];
    RECOVER_FAB[FAB$B_FNS] = .RECOVER_DESC[DSC$W_LENGTH];
    IF NOT $OPEN (FAB = RECOVER_FAB)
    THEN
	BEGIN
	AED_FILERROR (AED$_RECOPENIN, RECOVER_FAB, .RECOVER_FAB[FAB$L_STS],
						   .RECOVER_FAB[FAB$L_STV]);
	AED_B_OPTIONS[AED_V_RECOVER] = 0;
	END
    ELSE IF NOT $CONNECT (RAB = RECOVER_RAB)
    THEN
	BEGIN
	AED_FILERROR (AED$_RECOPENIN, RECOVER_FAB, .RECOVER_RAB[RAB$L_STS],
						   .RECOVER_RAB[RAB$L_STV]);
	AED_B_OPTIONS[AED_V_RECOVER] = 0;
	END;
    END;

IF .AED_B_OPTIONS[AED_V_JOURNAL]
THEN
    BEGIN
    JOURNAL_FAB[FAB$L_FNA] = .JOURNAL_DESC[DSC$A_POINTER];
    JOURNAL_FAB[FAB$B_FNS] = .JOURNAL_DESC[DSC$W_LENGTH];
    IF NOT $CREATE (FAB = JOURNAL_FAB)
    THEN
	BEGIN
	AED_FILERROR (AED$_JOUOPENOUT, JOURNAL_FAB, .JOURNAL_FAB[FAB$L_STS],
						    .JOURNAL_FAB[FAB$L_STV]);
	AED_B_OPTIONS[AED_V_JOURNAL] = 0;
	END
    ELSE IF NOT $CONNECT (RAB = JOURNAL_RAB)
    THEN
	BEGIN
	AED_FILERROR (AED$_JOUOPENOUT, JOURNAL_FAB, .JOURNAL_RAB[RAB$L_STS],
						    .JOURNAL_RAB[RAB$L_STV]);
	AED_B_OPTIONS[AED_V_JOURNAL] = 0;
	END;
    END;

! Check for the editor action definition file.  This is pointed to by the
! logical name ACLEDIT$INIT.  If it does not exist, a set of defaults is used.
! If it exists, and any errors are encountered opening or reading it, an
! error message is given, and the ACL editor will exit.

AED_L_STATUS = AED_GETKEYINI ();
IF NOT .AED_L_STATUS THEN RETURN .AED_L_STATUS OR STS$M_INHIB_MSG;

! Now that the necessary files have been opened, the in core copy of the ACL
! must be built.

AED_Q_LINETABLE[LINE_L_FLINK] = AED_Q_LINETABLE[LINE_L_FLINK];
AED_Q_LINETABLE[LINE_L_BLINK] = AED_Q_LINETABLE[LINE_L_FLINK];

CH$FILL (0, FIB$C_LENGTH, ACL_FIB);
CH$FILL (0, DSC$C_S_BLN, ACL_FIB_DESC);
ACL_FIB_DESC[DSC$W_LENGTH] = FIB$C_LENGTH;
ACL_FIB_DESC[DSC$A_POINTER] = ACL_FIB;

! Read any ACL current associated with the object.

AED_L_STATUS = ALLOCATE (512, AED_A_ACLBUFFER);
IF NOT .AED_L_STATUS
THEN
    BEGIN
    SIGNAL (.AED_L_STATUS);
    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
    END;

! Read in the ACL.

ACL_CONTEXT = 0;
ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_READACL;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = 512;
ATR_ARGLIST[0, ITM$L_BUFADR] = .AED_A_ACLBUFFER;
WHILE 1
DO
    BEGIN
    CH$FILL (0, 512, .AED_A_ACLBUFFER);
    AED_L_STATUS = $CHANGE_ACL (CHAN = .AED_W_OBJCHAN,
				OBJTYP = AED_L_OBJTYP,
				OBJNAM = AED_Q_OBJNAM,
				ITMLST = ATR_ARGLIST,
				CONTXT = ACL_CONTEXT);
    IF NOT .AED_L_STATUS
    THEN
	BEGIN
	IF .AED_L_STATUS EQL SS$_ACLEMPTY OR .AED_L_STATUS EQL SS$_NOMOREACE THEN EXITLOOP;
	SIGNAL (AED$_READERR, 1, AED_Q_OBJNAM, .AED_L_STATUS, 0);
	RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	END;
    ACE_POINTER = .AED_A_ACLBUFFER;
    UNTIL .ACE_POINTER GEQA .AED_A_ACLBUFFER + 512
    DO
	BEGIN
	IF .ACE_POINTER[ACE$B_SIZE] EQL 0 THEN EXITLOOP;
	AED_L_STATUS = ALLOCATE (.ACE_POINTER[ACE$B_SIZE], ACE_NEWADDR);
	IF NOT .AED_L_STATUS
	THEN
	    BEGIN
	    SIGNAL (.AED_L_STATUS);
	    RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
	    END;
	CH$MOVE (.ACE_POINTER[ACE$B_SIZE], .ACE_POINTER, .ACE_NEWADDR);
	ACE_DESC[DSC$A_POINTER] = .ACE_POINTER;
	ACE_DESC[DSC$W_LENGTH] = .ACE_POINTER[ACE$B_SIZE];
	ACE_TEXT_DESC[DSC$A_POINTER] = ACE_TEXT;
	ACE_TEXT_DESC[DSC$W_LENGTH] = 3072;
	AED_L_STATUS = $FORMAT_ACL (ACLENT = ACE_DESC,
				    ACLLEN = ACE_TEXT_DESC,
				    ACLSTR = ACE_TEXT_DESC,
				    WIDTH = AED_L_PAGEWIDTH,
				    TRMDSC = $DESCRIPTOR (0),
				    INDENT = 0);
	ACE_TEXT_SIZE = .ACE_TEXT_DESC[DSC$W_LENGTH];
	FIRST_CHAR = ACE_TEXT;
	AED_L_FIRSTLINE = AED_L_LASTLINE = 0;
	WHILE (LAST_CHAR = CH$FIND_CH (.ACE_TEXT_SIZE, .FIRST_CHAR, 0)) GTR 0
	DO
	    BEGIN
	    SEGMENT_SIZE = .LAST_CHAR - .FIRST_CHAR;
	    AED_L_STATUS = ALLOCATE (.SEGMENT_SIZE + $BYTEOFFSET (LINE_T_TEXT),
				     NEW_TEXT_LINE);
	    IF NOT .AED_L_STATUS
	    THEN
		BEGIN
		SIGNAL (.AED_L_STATUS);
		RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
		END;
	    NEW_TEXT_LINE[LINE_W_SIZE] = .SEGMENT_SIZE;
	    NEW_TEXT_LINE[LINE_L_BINACE] = .ACE_NEWADDR;
	    CH$MOVE (.ACE_TEXT_SIZE, .FIRST_CHAR, NEW_TEXT_LINE[LINE_T_TEXT]);
	    INSQUE (.NEW_TEXT_LINE, .AED_Q_LINETABLE[LINE_L_BLINK]);
	    IF .AED_L_FIRSTLINE EQL 0 THEN AED_L_FIRSTLINE = .NEW_TEXT_LINE;
	    AED_L_LASTLINE = .NEW_TEXT_LINE;
	    FIRST_CHAR = .LAST_CHAR + 1;
	    ACE_TEXT_SIZE = .ACE_TEXT_SIZE - .SEGMENT_SIZE - 1;
	    END;
	IF .ACE_TEXT_SIZE GTR 0
	THEN
	    BEGIN
	    AED_L_STATUS = ALLOCATE (.ACE_TEXT_SIZE + $BYTEOFFSET (LINE_T_TEXT),
				     NEW_TEXT_LINE);
	    IF NOT .AED_L_STATUS
	    THEN
		BEGIN
		SIGNAL (.AED_L_STATUS);
		RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;
		END;
	    NEW_TEXT_LINE[LINE_W_SIZE] = .ACE_TEXT_SIZE;
	    NEW_TEXT_LINE[LINE_L_BINACE] = .ACE_NEWADDR;
	    CH$MOVE (.ACE_TEXT_SIZE, .FIRST_CHAR, NEW_TEXT_LINE[LINE_T_TEXT]);
	    INSQUE (.NEW_TEXT_LINE, .AED_Q_LINETABLE[LINE_L_BLINK]);
	    IF .AED_L_FIRSTLINE EQL 0 THEN AED_L_FIRSTLINE = .NEW_TEXT_LINE;
	    AED_L_LASTLINE = .NEW_TEXT_LINE;
	    END;
	AED_L_FIRSTLINE[LINE_V_BEGINACE] = 1;
	IF .ACE_POINTER[ACE$V_HIDDEN]
	OR (.ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_KEYID
	    AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_BIJNL
	    AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_AIJNL
	    AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_ATJNL
	    AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_AUDIT
	    AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_ALARM
	    AND .ACE_POINTER[ACE$B_TYPE] NEQ ACE$C_DIRDEF)
	THEN AED_L_FIRSTLINE[LINE_V_NOTOUCH] = 1;
	AED_L_LASTLINE[LINE_V_ENDACE] = 1;
	ACE_POINTER = .ACE_POINTER + .ACE_POINTER[ACE$B_SIZE];
	END;
    END;
DEALLOCATE (512, AED_A_ACLBUFFER);

! Now set up the initial display.

IF .AED_Q_LINETABLE[LINE_L_FLINK] NEQA AED_Q_LINETABLE[LINE_L_FLINK]
AND .AED_L_FLAGS[AED_V_SCOPE]
THEN
    BEGIN
    ACE_NEWADDR = AED_Q_LINETABLE[LINE_L_FLINK];
    DO
	BEGIN
	ACE_NEWADDR = .ACE_NEWADDR[LINE_L_FLINK];
	AED_Q_OUTLINE[DSC$W_LENGTH] = .ACE_NEWADDR[LINE_W_SIZE];
	AED_Q_OUTLINE[DSC$A_POINTER] = ACE_NEWADDR[LINE_T_TEXT];
	AED_SET_CURSOR (.AED_B_LINE, 1);
	AED_PUTOUTPUT (AED_Q_OUTLINE);
	AED_B_LINE = .AED_B_LINE + 1;
	END
    UNTIL (.AED_B_LINE GTR 20)
       OR (.ACE_NEWADDR[LINE_L_FLINK] EQL AED_Q_LINETABLE[LINE_L_FLINK]);
    AED_B_LINE = 1;
    AED_SET_CURSOR (1, 1);
    END;

! At this point all of the necessary initialization has been completed.  Now,
! prompt the user for any modifications to the ACL.

AED_PROCESSACL();

! All of the ACL processing has been completed.  Do some final cleanup before
! returning control to the user.

AED_FLUSHKEY ();
AED_CLEANUP ();					! Reset any screen setup done

RETURN .AED_L_WORSTERR OR STS$M_INHIB_MSG;

END;						! End of routine AED_INIT

GLOBAL ROUTINE AED_FILERROR (ERROR_CODE, FAB, PRI_STATUS, SEC_STATUS) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the common error reporting routine for the ACL
!	editor.
!
! CALLING SEQUENCE:
!	AED_ERROR (ARG1, ARG2, ARG3, ARG4)
!
! INPUT PARAMETERS:
!	ARG1: the facility error code
!	ARG2: the address of the related FAB for RMS errors
!	ARG3: the primary RMS error code
!	ARG4: the secondary RMS error code
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	FAB		: REF $BBLOCK;		! Address of the FAB

BIND
	NAM		= .FAB[FAB$L_NAM]	: $BBLOCK;	! Address of the NAM block

LOCAL
	FILE_NAME	: $BBLOCK [DSC$C_S_BLN];	! File name storage

CH$FILL (0, DSC$C_S_BLN, FILE_NAME);
IF .NAM[NAM$B_RSL] NEQ 0			! Use resultant name if present
THEN
    BEGIN
    FILE_NAME[DSC$A_POINTER] = .NAM[NAM$L_RSA];
    FILE_NAME[DSC$W_LENGTH] = .NAM[NAM$B_RSL];
    END
ELSE IF .NAM[NAM$B_ESL] NEQ 0			! Use expanded name if no resultant
THEN
    BEGIN
    FILE_NAME[DSC$A_POINTER] = .NAM[NAM$L_ESA];
    FILE_NAME[DSC$W_LENGTH] = .NAM[NAM$B_ESL];
    END
ELSE
    BEGIN
    FILE_NAME[DSC$A_POINTER] = .FAB[FAB$L_FNA];	! Use Original if no expanded
    FILE_NAME[DSC$W_LENGTH] = .FAB[FAB$B_FNS];
    END;

SIGNAL (.ERROR_CODE, 1, FILE_NAME, .PRI_STATUS, .SEC_STATUS);

RETURN;

END;						! End of routine AED_FILERROR

ROUTINE AED_CTRLCAST : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when the user types a control-C.  It resets
!	the necessary terminal characteristics, unwinds all the way, and then
!	returns.  This is necessary to support a callable ACL editor.
!
! CALLING SEQUENCE:
!	AED_CNTRLCAST ()
!
! INPUT PARAMETERS:
!	none
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	The stack is unwound, and control is returned to the caller of the
!	ACL editor.
!
!--

BEGIN

AED_B_OPTIONS[AED_V_KEEPJNL] = 1;		! Don't delete journal file
SIGNAL (AED$_CONTROL_C);			! Will never return

RETURN;

END;						! End of routine AED_CTRLCAST

ROUTINE AED_HANDLER (SIGNAL_VEC, MECHANISM_VEC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is the main exception handler for the ACL editor.  The
!	purpose it serves is to flush the session log (if any) and reset
!	the terminal characteristics before resignaling the error.
!
! CALLING SEQUENCE:
!	AED_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of the signal array
!	ARG2: address of the mechanism array
!
! IMPLICIT INPUTS:
!	OWN storage
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	SIGNAL_VEC	: REF $BBLOCK,		! The signal vector
	MECHANISM_VEC	: REF $BBLOCK;		! The mechanism vector

! If the severity is FATAL or this is a control-C abort, do the needed
! cleanup and reset the terminal characteristics.

IF .$BBLOCK[SIGNAL_VEC[CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_SEVERE
OR .SIGNAL_VEC[CHF$L_SIG_NAME] EQL AED$_CONTROL_C
THEN
    BEGIN
    AED_FLUSHKEY ();
    AED_CLEANUP ();
    IF .SIGNAL_VEC[CHF$L_SIG_NAME] EQL AED$_CONTROL_C
    THEN
	BEGIN
	$UNWIND ();
	RETURN 1;
	END;
    END;

RETURN SS$_RESIGNAL;

END;						! End of routine AED_HANDLER

GLOBAL ROUTINE AED_PUTOUTPUT (BUFFER_DESC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine outputs the buffer pointed to by the specified descriptor
!	to the terminal.  No assumption is made as to the content of the buffer.
!
! CALLING SEQUENCE:
!	AED_PUTOUTPUT (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the buffer descriptor
!
! IMPLICIT INPUTS:
!	AED_W_TERMOUT: channel to use for terminal I/O
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if no errors
!	otherwise an error code
!
! SIDE EFFECTS:
!	The output display is updated.
!
!--

BEGIN

MAP
	BUFFER_DESC	: REF $BBLOCK;		! Address of the buffer descr

LOCAL
	LOCAL_IOSB	: VECTOR [4,WORD],	! I/O status block
	LOCAL_STATUS;				! Routine exit status

! Write the specified buffer to the output device.

LOCAL_STATUS = $QIOW (CHAN = .AED_W_TERMOUT,
		      FUNC = IO$_WRITEVBLK OR IO$M_CANCTRLO,
		      IOSB = LOCAL_IOSB,
		      P1 = .BUFFER_DESC[DSC$A_POINTER],
		      P2 = .BUFFER_DESC[DSC$W_LENGTH]);

IF .LOCAL_STATUS THEN LOCAL_STATUS = .LOCAL_IOSB[0];
IF NOT .LOCAL_STATUS THEN SIGNAL (.LOCAL_STATUS);
RETURN .LOCAL_STATUS;

END;						! End of routine AED_PUTOUTPUT

END
ELUDOM
