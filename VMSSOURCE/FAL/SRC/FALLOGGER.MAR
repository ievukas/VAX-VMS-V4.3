	.TITLE	FALLOGGER - FAL LOGGING ROUTINES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: FAL (DECnet File Access Listener)
;
; Abstract:
;
;	This module contains FAL logging routines and associated text.
;
; Environment: VAX/VMS, user mode
;
; Author: James A. Krycka,	Creation Date:	16-JUN-1977
;
; Modified By:
;
;	V03-009	JAK0144		J A Krycka	11-APR-1984
;		Use local symbols instead of global symbols wherever possible.
;		Log CPU time with FAL$LOG statistics display and optionally
;		display internal counters.
;
;	V03-008	JAK0137		J A Krycka	12-MAR-1984
;		Add FAL$PARSE_FAL$LOG routine to parse FAL logging options.
;		Make minor changes to FAL logging display.
;		Add description of FAL$LOG options and use of FAL$OUTPUT.
;		Modifications to reflect macro name changes in FALMACROS.MAR.
;
;	V03-007	JAK0136		J A Krycka	07-MAR-1984
;		Do not terminate FAL on error writing to print file with FAL
;		logging information.
;
;	V03-006	JAK0107		J A Krycka	30-APR-1983
;		This fix supersedes V03-002.
;
;	V03-005	JAK0105		J A Krycka	29-APR-1983
;		Make general enhancements to FAL logging display and log more
;		performance diagnostic information.
;
;	V03-004 KRM0097		K Malik		06-Apr-1983
;		Add support for DAP V7.0 rename operation.
;
;	V03-003	KRM0071		K Malik		23-Nov-1982
;		Modify FAL$LOG_RESNAM to support rename operation.
;
;	V03-002	KRM0062		K Malik		08-Oct-1982
;		Modified FAL$PRINT_FAO to loop on encountering a
;		Record Stream Active error, instead of quitting.
;
;--

	.SBTTL	FAL LOGGING OPTIONS DESCRIPTION

;++
;
; INTRODUCTION TO FAL LOGGING
;
; The following describes the format and use of the FAL logging options which
; are specified via the logical names FAL$LOG and FAL$OUTPUT. These are normally
; defined in the user's LOGIN.COM file, but they can be placed in a group or
; system logical name table to affect a larger class of remote file accesses.
; FAL$LOG conveys logging and control directives to FAL and FAL$OUTPUT is used
; to specify the name of the log file to create (in place of SYS$OUTPUT).
;
; NOTE:	Use of the logical names FAL$LOG and FAL$OUTPUT by FAL is an UNSUPPORTED
;	feature intended as a diagnostic, debugging, and performance monitoring
;	tool for use by Digital. The format and function of these logical names
;	may change at any time, or perhaps not be used in the future.
;
; NOTE:	Logging of information other than file name and statistics (parameter
;	bits 0, 1, and 5) can severly reduce data throughput!!!
;
;
; SYNTAX RULES
;
; The primary function of the logical name FAL$LOG is to request the logging of
; various types of information about the file operations performed by FAL. This
; includes identifying each file accessed, displaying the Data Access Protocol
; (DAP) messages exchanged, computing data throughput statistics, and logging
; the logical link and mailbox QIO calls and the subsequent delivery of ASTs.
; Logging operations are requested via the parameter bitmask value. A secondary
; use of the logical name is to specify qualifiers that control various aspects
; of FAL's operation such as determining buffer sizes or disabling features.
; Currently, the format of the FAL$LOG options string is:
;
;	[parameter][/qualifier-1,...,qualifier-n]
;
; where each qualifier is of the form keyword=value (e.g., /BPM=20).
;
; The parameter and qualifiers are optional. However, the parameter if present
; must precede any qualifiers. In addition, only the first three characters of
; a qualifier keyword are examined to determine a match. Thus, /DISABLE=xx can
; be addreviated to /DIS=xx. Spaces and tabs are ignored and keywords can be
; be entered using either uppercase or lowercase characters.
;
;
; PARAMETER VALUES
;
; The parameter is a hexadecimal bitmask used to specify FAL logging options.
; If this parameter is non-zero (indicating that FAL logging output will be
; generated), then an attempt is made to translate the logical name SYS$OUTPUT
; prior to opening the log file. If FAL$OUTPUT is defined, then its equivalence
; string is used as the file specification of the log file; otherwise logging
; output is directed to SYS$OUTPUT which normally points to the default network
; log file named SYS$LOGIN:NETSERVER.LOG. The bitmask definitions for the
; parameter are as follows:
;
;	bit0 -- enable logging of file name and type of file access requested.
;	bit1 -- enable logging of data throughput and other performance
;		statistics.
;	bit2 -- enable logging of individual DAP messages as they are processed
;		from the input buffer or assembled in the output buffer
;	bit3 -- enable logging of DAP message packet and mailbox AST routine
;		completions.
;	bit4 -- enable logging of DAP message packet and mailbox QIO requests.
;	bit5 -- enable logging of internal counters.
;
;
; QUALIFIER VALUES
;
; The following qualifiers are recognized where 'd' denotes a decimal digit and
; 'x' denotes a hexadecimal digit:
;
; /DISABLE=xx (Disable FAL Options) where the bitmask value denotes:
;
;	bit0 -- disable DAP level CRC checksum generation and comparison.
;		(Note that CRC checking will be automatically disabled if the
;		initiating node does not support DAP level CRC computation.)
;	bit1 -- disable DAP message blocking in both directions (i.e., transmit
;		each DAP message in a separate QIO system service call).
;	bit2 -- disable RMS multi-block caching to/from disk when block I/O
;		file transfer mode is in effect. This restores the pre-VMS V3.4
;		block I/O processing behavior of FAL where each DAP DATA message
;		resulted in one RMS $READ or $WRITE call to be executed. Note
;		also that selection of this option elimimates one MOVC3 copy
;		of the data in memory at the expense of greatly increasing the
;		number of RMS I/O operations performed during a file transfer.
;	bit3 -- disable poor-man's (or manual) routing (i.e., have FAL reject
;		any file specification it receives that contains a node name).
;	bits4-7 are undefined.
;
; /ENABLE=xx (Enable FAL Options) where the bitmask value denotes:
;
;	bits0-7 are undefined.
;
; /BPM=ddddd (Bytes per Message) this is the maximum number of bytes per DAP
;	message to display (used only if parameter bit2 is set). The default
;	value is 20 bytes per message.
;
; /BPL=dd (Bytes per Line) this is the maximum number of bytes per line to
;	display when dumping a DAP message (used only if parameter bit2 is set).
;	The default value is 20 bytes per line.
;
; /RBK_CACHE=ddd (RMS Multi-block Cache Size) this controls the number of disk
;	blocks per RMS $READ or $WRITE call to transfer when block I/O file
;	transfer mode is selected (if bit2 of the /DISABLE option is set, this
;	option is ignored). The number can be from 1 to 127. The default is 64.
;
; /DBS=ddddd (DAP Buffer Size) requests FAL to send this value in the DAP
;	Configuration message for the <BUFSIZ> field.
;
; /SYSTEM_ID=xxxx (System Identification) requests FAL to send this value in
;	the DAP Configuration message for the <FILESYS><OSTYPE> fields (the
;	OSTYPE field is the low order byte of the value).
;
; /VERSION=xxxxxxxx (DAP Version Number) requests FAL to send this value in
;	the DAP Configuration message for the <DECVER><USRNUM><ECONUM><VERNUM>
;	fields (the VERNUM field is the low order byte of the value).
;
; /SC1=xxxxxxxx (System Capabilities Part 1) requests FAL to send this value in
;	the DAP Configuration message for bits <31-00> of the <SYSCAP> field.
;
; /SC2=xxxxxxxx (System Capabilities Part 2) requests FAL to send this value in
;	the DAP Configuration message for bits <63-32> of the <SYSCAP> field.
;
; Note that any qualifier that cannot be interpreted or that contains an invalid
; value is ignored and a parse error message is written to the log file.
;
;
; EXAMPLES
;
; The following DCL commands illustrate how FAL logging options may be setup
; in one's LOGIN.COM file.
;
;	$ DEFINE FAL$LOG 1
;
; The above command enables the logging of file name and type of access in
; the default network log file NETSERVER.LOG.
;
;	$ DEFINE FAL$LOG 3
;	$ DEFINE FAL$OUTPUT FAL.LOG
;
; This requests the logging of file name, type of acesss, and data throughput
; statistics in SYS$LOGIN:FAL.LOG.
;
;	$ DEFINE FAL$LOG "3/RBK_CACHE=16/DBS=1056"
;	$ DEFINE FAL$OUTPUT work_disk:[testing]statistics.star_to_galaxy
;
; The above definitions are used to gather data throughput statistics in the
; specified log file while altering buffer sizes.
;
;	$ DEFINE FAL$LOG "7/bpm=80
;
; This definition causes the first 80 bytes of each DAP message to dumped and
; file identification and statistics to be displayed in the log file.
;
;	$ DEFINE FAL$LOG 7_50
;
; Same as the previous example, except the VMS V3.n parameter format of xx_yyyy
; is used where yyyy is the number of bytes per DAP message to display expressed
; as a hexadecimal value.
;
;	$ DEFINE FAL$LOG "/DISABLE=8"
;
; This disables poor-man's routing which prevents users from using FAL as a
; pass-through object on this node.
;
;	$DEFINE FAL$LOG 2F
;
; This enables all FAL logging options excluding qualifier control options.
;
;--

	.SBTTL	DECLARATIONS
	.PSECT	FAL$DATA_LOGGER	SHR,NOEXE,RD,WRT,QUAD

;
; Include Files:
;

	$DAPHDRDEF			; Define DAP message header
	$DAPACCDEF			; Define DAP Access message
	$DAPCTLDEF			; Define DAP Control message
	$FABDEF				; Define File Access Block symbols
	$FALSTBDEF			; Define Statistics Block symbols
	$FALWRKDEF			; Define FAL Work Area symbols
	$JPIDEF				; Define Job/Process Information symbols
	$NAMDEF				; Define Name Block symbols
	$RMSDEF				; Define RMS completion codes

;
; Macros:
;
;	None
;
; Equated Symbols:
;

EQUALSIGN	= ^X3D			; ASCII code for equal sign
SLASH		= ^X2F			; ASCII code for slash
SPACE		= ^X20			; ASCII code for space
TAB		= ^X09			; ASCII code for horizontal tab
UNDERSCORE	= ^X5F			; ASCII code for underscore

	ASSUME	FAL$Q_FLG EQ 0

;
; Own Storage:
;

;
; Data structures for the print file:
;

	.ALIGN	LONG			; Required for FABs and RABs
FAL$PRTFAB::				; File Access Block
	$FAB	FAC=PUT-		;  Put access
		FOP=SQO-		;  Sequential-only access
		RAT=CR-			;  Carriage control
		FNA=FALL$T_PRTNAM-	;  File name string address
		FNS=FALL$S_PRTNAM	;  File name string size
FAL$PRTRAB::				; Record Access Block
	$RAB	FAB=FAL$PRTFAB-		;  Address of associated FAB
		RBF=0-			;  Record buffer address--t.b.s. later
		RSZ=0			;  Record buffer size--t.b.s. later
FAL$GQ_PRTBUF1::			; Output string descriptor for FAO
	.BLKQ	1			;  when called from non-AST-level code
FAL$GQ_PRTBUF2::			; Output string descriptor for FAO
	.BLKQ	1			;  when called from AST-level code
FAL$GW_PRTLEN1::			; Formatted message length from FAO
	.BLKW	1			;
FAL$GW_PRTLEN2::			; Formatted message length from FAO
	.BLKW	1			;
FALL$T_PRTNAM:				; Print device name
	.ASCII	\SYS$OUTPUT\		;
FALL$S_PRTNAM=.-FALL$T_PRTNAM		; Print device name length

;
; Time related storage:
;

	.ALIGN	LONG			; Required for FABs and RABs
FAL$GQ_TIME0::				; Time of link connect
	.BLKQ	1			;
FAL$GQ_TIME1::				; Time of link disconnect
	.BLKQ	1			;

;
; Item list parameter block for the $GETJPI System Service calls:
;

	.ALIGN	LONG
FAL$GETJPI_LST0::			; Start of parameter block
	.WORD	4			; Length of buffer
	.WORD	JPI$_CPUTIM		; Type of info to return
	.LONG	FALL$L_CPUTIM0		; Address of buffer
	.LONG	0			; Don't return length of value
	.WORD	4			; Length of buffer
	.WORD	JPI$_BUFIO		; Type of info to return
	.LONG	FALL$L_BUFIO0		; Address of buffer
	.LONG	0			; Don't return length of value
	.WORD	4			; Length of buffer
	.WORD	JPI$_DIRIO		; Type of info to return
	.LONG	FALL$L_DIRIO0		; Address of buffer
	.LONG	0			; Don't return length of value
	.LONG	0			; End of parameter block

FAL$GETJPI_LST1::			; Start of parameter block
	.WORD	4			; Length of buffer
	.WORD	JPI$_CPUTIM		; Type of info to return
	.LONG	FALL$L_CPUTIM1		; Address of buffer
	.LONG	0			; Don't return length of value
	.WORD	4			; Length of buffer
	.WORD	JPI$_BUFIO		; Type of info to return
	.LONG	FALL$L_BUFIO1		; Address of buffer
	.LONG	0			; Don't return length of value
	.WORD	4			; Length of buffer
	.WORD	JPI$_DIRIO		; Type of info to return
	.LONG	FALL$L_DIRIO1		; Address of buffer
	.LONG	0			; Don't return length of value
	.WORD	4			; Length of buffer
	.WORD	JPI$_WSPEAK		; Type of info to return
	.LONG	FALL$L_WSPEAK		; Address of buffer
	.LONG	0			; Don't return length of value
	.LONG	0			; End of parameter block

FALL$Q_CPUTIME:				; Total CPU time in delta format
					;  (overlays next two longwords)
FALL$L_CPUTIM0:				; Accumulated CPU time in 10 millisecond
	.BLKL	1			;  units is returned here
FALL$L_CPUTIM1:				; Accumulated CPU time in 10 millisecond
	.BLKL	1			;  units is returned here
FALL$L_BUFIO0:				; Accumulated buffered I/O operations
	.BLKL	1			;  count is returned here
FALL$L_BUFIO1:				; Accumulated buffered I/O operations
	.BLKL	1			;  count is returned here
FALL$L_DIRIO0:				; Accumulated direct I/O operations
	.BLKL	1			;  count is returned here
FALL$L_DIRIO1:				; Accumulated direct I/O operations
	.BLKL	1			;  count is returned here
FALL$L_WSPEAK:				; Peak working set size
	.BLKL	1			;

;
; Flags to control logging printout:
;

FALL$W_PERMSG:				; Maximum # bytes per message to log
	.LONG	FAL$K_DFLT_BPM		; Default value
FALL$W_PERLINE:				; Maximum # bytes per line to log
	.LONG	FAL$K_DFLT_BPL		; Default value

;
; Miscellaneous counter storage:
;

FAL$GL_RECVWAIT::			; Receive QIO wait count
	.LONG	0			; Initialize to zero
FAL$GL_XMITWAIT::			; Transmit QIO wait count
	.LONG	0			; Initialize to zero
FAL$GL_READWAIT::			; RMS FTM READ wait count
	.LONG	0			; Initialize to zero
FAL$GL_WRITWAIT::			; RMS FTM WRITE wait count
	.LONG	0			; Initialize to zero
FAL$GL_COUNTER1::			; Miscellaneous counter 1
	.LONG	0			; Initialize to zero
FAL$GL_COUNTER2::			; Miscellaneous counter 2
	.LONG	0			; Initialize to zero
FAL$GL_COUNTER3::			; Miscellaneous counter 3
	.LONG	0			; Initialize to zero
FAL$GL_COUNTER4::			; Miscellaneous counter 4
	.LONG	0			; Initialize to zero

;
; FAO related descriptor blocks with text:
;

FALL$Q_MBXNAM:				; Name of associated mailbox
	$QBLOCK	TEXT=<<_!AC!UW:>>
FAL$GQ_UIC::				; File owner UIC string
	$QBLOCK	TEXT=<<[!3OW,!3OW]>>
FAL$GQ_CALLER::				; Requestor ID message
	$QBLOCK	TEXT=<!/!56*=!/-
		<FAL !AC started execution on !23%D!/>-
		<  with SYS$NET = !AS and!/>-
		<  with FAL$LOG = !AS!/>-
	>
FAL$GQ_PARSERR::			; Parse error message
	$QBLOCK	TEXT=<<******* ERROR PARSING FAL$LOG COMMAND *******!/>>
FAL$GQ_HEADER::				; Header line for DAP message logging
	$QBLOCK	TEXT=<-
		<For DAP message dump read byte stream from right to left!/>-
	>
FAL$GQ_LINKUP::				; Link established message
	$QBLOCK	TEXT=<<Logical link was established on  !23%D!/>>
FALL$Q_REQNAM:				; Requested file name message
	$QBLOCK	TEXT=<-
		<Requested file access operation: !AC!/>-
		<Specified file: !AS>-
	>
FALL$Q_REQNAM2:				; Requested new file name message
	$QBLOCK	TEXT=<<Change name to: !AS>>
FALL$Q_RESNAM:				; Resultant file name message
	$QBLOCK	TEXT=<<Resultant file: !AD>>
FAL$GQ_STATUS::				; Status code message
	$QBLOCK	TEXT=<<DAP status code of !XW generated>>
FALL$Q_CLOSE:				; File closed message
	$QBLOCK	TEXT=<<File access was terminated with !AC set on close>>
FAL$GQ_MBXMSG::				; Mailbox message type
	$QBLOCK	TEXT=<<Mailbox message type !XW received>>
FAL$GQ_LINKDOWN::			; Link terminated message
	$QBLOCK	TEXT=<<!/Logical link was terminated on   !23%D>>
FALL$Q_CONNTIME:			; Link connect time message
	$QBLOCK	TEXT=<!/-
		<Total connect time for logical link was !%D!/>-
		<Total CPU time used for connection was  !%D>-
	>
FALL$Q_STAT1:				; Statistics message part 1
	$QBLOCK	TEXT=<!/-
		<File Access Statistics for RECV-Side XMIT-Side Composite!/>-
		<!26*- !9*- !9*- !9*-!/>-
		<# DAP Message QIO Calls   !3(10UL)!/>-
		<# DAP Messages Exchanged  !3(10UL)>-
	>
FALL$Q_STAT2:				; Statistics message part 2
	$QBLOCK	TEXT=<-
		<# User Records/Blocks     !3(10UL)!/>-
		<# Bytes of User Data      !3(10UL)!/>-
		<# Bytes in DAP Layer      !3(10UL)>-
	>
FALL$Q_STAT3:				; Statistics message part 3
	$QBLOCK	TEXT=<-
		<User Data Throughput (bps)!3(10UL)!/>-
		<DAP Layer Throughput (bps)!3(10UL)>-
	>
FALL$Q_STAT4:				; Statistics message part 4
	$QBLOCK	TEXT=<-
		<Average Record/Block Size !3(10UL)>-
	>
FALL$Q_STAT5:				; Statistics message part 5
	$QBLOCK	TEXT=<-
		<% User Data in DAP Layer  !7UB.!1UB%!7UB.!1UB%!7UB.!1UB%!/>-
		<!26*- !9*- !9*- !9*->-
	>
FALL$Q_STAT6:				; Statistics message part 6
	$QBLOCK	TEXT=<!/-
		<Negotiated DAP buffer size = !UW bytes!/>-
		<Buffered I/O count during connection = !UL!/>-
		<Direct I/O count during connection   = !UL!/>-
		<Peak working set size for process = !UL pages>-
	>
FAL$GQ_INTCNTR::			; Internal counter information
	$QBLOCK	TEXT=<!/-
		<Total RECV_WAIT = !UL and XMIT_WAIT not kept!/>-
		<Total READ_WAIT not kept and WRIT_WAIT = !UL!/>-
		<COUNTER1 = !UL and COUNTER2 = !UL!/>-
		<COUNTER3 = !UL and COUNTER4 = !UL>-
	>
FAL$GQ_EXIT::				; Exit message
	$QBLOCK	TEXT=<<!/FAL terminated execution on      !%D!/!56*=!/>>
FALL$Q_LOGMSG:				; Print DAP message (first line)
	$QBLOCK	TEXT=<<!AC !AC !AC!1(6UW) -!#(3XB)>>
FALL$Q_LOGMSG2:				; Print DAP message (continuation lines)
	$QBLOCK	TEXT=<<!19* -!#(3XB)>>
FALL$Q_LOGQIO:				; Print QIO message
	$QBLOCK	TEXT=<<!11%T !AC QIO issued>>
FALL$Q_LOGAST:				; Print AST message
	$QBLOCK	TEXT=<<!11%T !AC AST delivered!1(6UW) bytes>>

;
; Additional text stored in counted ASCII strings:
;

FAL$GT_RCVQIO::				; Text for LOGAST and LOGQIO
	.ASCIC	\Receive \		;
FAL$GT_XMTQIO::				; Text for LOGAST and LOGQIO
	.ASCIC	\Transmit\		;
FAL$GT_MBXQIO::				; Text for LOGAST and LOGQIO
	.ASCIC	\Mailbox \		;
FAL$GT_ENCODE::				; Text for LOGMSG
	.ASCIC	\<---\			;
FAL$GT_DECODE::				; Text for LOGMSG
	.ASCIC	\--->\			;
FALL$T_MSG:				; Text for LOGMSG
	.ASCIC	\msg\			;

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one quadword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$Q_FOP_OPT:				; Text for FOP options on close
	.ASCIC	\no bits\		; No options selected
	.ASCIC	\SPL bit\		; SPL bit set
	.ASCIC	\SCF bit\		; SCF bit set
	.ASCIC	\SCF!SPL\		; SCF and SPL bits set ==> SCF
	.ASCIC	\DLT bit\		; DLT bit set
	.ASCIC	\SPL!DLT\		; SPL and DLT bits set
	.ASCIC	\SCF!DLT\		; SCF and DLT bits set
	.ASCIC	\all opt\		; All three bits set ==> SCF and DLT

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one octaword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$T_ACCFUNC:				; Access function code text
	.ASCIC	\Invalid request\	; Invalid function code
	.ASCIC	\Open file      \	; OPEN
	.ASCIC	\Create file    \	; CREATE
	.ASCIC	\Rename file    \	; RENAME
	.ASCIC	\Erase file     \	; ERASE
	.ASCIC	\Invalid request\	; Reserved
	.ASCIC	\Directory List \	; DIRECTORY-LIST
	.ASCIC	\Create (submit)\	; SUBMIT
	.ASCIC	\Open (execute) \	; EXECUTE

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one longword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$L_MSGTYPE:				; DAP message type text
	.ASCIC	\???\			; Unknown message type
	.ASCIC	\CNF\			; Configuration message
	.ASCIC	\ATT\			; Attributes message
	.ASCIC	\ACC\			; Access message
	.ASCIC	\CTL\			; Control message
	.ASCIC	\CON\			; Continue Transfer message
	.ASCIC	\ACK\			; Acknowledge messasge
	.ASCIC	\CMP\			; Access Complete message
	.ASCIC	\DAT\			; Data message
	.ASCIC	\STS\			; Status message
	.ASCIC	\KEY\			; Key Definition message
	.ASCIC	\ALL\			; Allocation message
	.ASCIC	\SUM\			; Summary message
	.ASCIC	\TIM\			; Date and Time message
	.ASCIC	\PRO\			; Protection messsage
	.ASCIC	\NAM\			; Name message

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one longword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$L_ACCFUNC:				; Access function code text
	.ASCIC	\???\			; Unknown function code
	.ASCIC	\OPN\			; OPEN
	.ASCIC	\CRE\			; CREATE
	.ASCIC	\REN\			; RENAME
	.ASCIC	\ERA\			; ERASE
	.ASCIC	\rsv\			; Reserved
	.ASCIC	\DIR\			; DIRECTORY-LIST
	.ASCIC	\SUB\			; SUBMIT
	.ASCIC	\EXE\			; EXECUTE

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one longword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$L_CTLFUNC:				; Control function code text
	.ASCIC	\???\			; Unknown function code
	.ASCIC	\GET\			; GET or READ
	.ASCIC	\CON\			; CONNECT
	.ASCIC	\UPD\			; UPDATE
	.ASCIC	\PUT\			; PUT or WRITE
	.ASCIC	\DEL\			; DELETE
	.ASCIC	\REW\			; REWIND
	.ASCIC	\TRU\			; TRUNCATE
	.ASCIC	\MOD\			; MODIFY (reserved)
	.ASCIC	\REL\			; RELEASE
	.ASCIC	\FRE\			; FREE
	.ASCIC	\XTB\			; EXTEND-BEGIN
	.ASCIC	\FLU\			; FLUSH
	.ASCIC	\NXV\			; NEXT VOLUME (reserved)
	.ASCIC	\FND\			; FIND
	.ASCIC	\XTE\			; EXTEND-END
	.ASCIC	\DSP\			; DISPLAY
	.ASCIC	\SPF\			; SPACE FORWARD
	.ASCIC	\SFB\			; SPACE BACKWARD
					; Add strings for new codes here and
					;  update the following constant
CTLFUNC_ALT_DEF=18			; Constant to add to function code value
					;  to index into alternate definitions
					;  (for GET/READ = 1 and PUT/WRITE = 4)
	.ASCIC	\REA\			; READ (redefiniton of GET code)
	.ASCIC	\CON\			; CONNECT
	.ASCIC	\UPD\			; UPDATE
	.ASCIC	\WRT\			; WRITE (redefiniton of PUT code)

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one longword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$L_CONFUNC:				; Continue Transfer function code text
	.ASCIC	\???\			; Unknown function code
	.ASCIC	\TRY\			; TRY AGAIN
	.ASCIC	\SKR\			; SKIP to next record
	.ASCIC	\ABO\			; ABORT
	.ASCIC	\RES\			; RESUME

;
; The following counted ASCII strings are arranged in an array where each string
; must begin one longword apart to accomodate indexed addressing into the array.
;

	.ALIGN	LONG
FALL$L_CMPFUNC:				; Access Complete function code text
	.ASCIC	\???\			; Unknown function code
	.ASCIC	\CLS\			; CLOSE
RESPONSE_CODE=2				; Value of response function code
	.ASCIC	\RSP\			; RESPONSE
	.ASCIC	\RST\			; RESET
	.ASCIC	\DSC\			; DISCONNECT
	.ASCIC	\SKF\			; SKIP to next file
	.ASCIC	\CHB\			; CHANGE-BEGIN
	.ASCIC	\CHE\			; CHANGE-END
	.ASCIC	\TER\			; TERMINATE operation

	.SBTTL	FAL$PARSE_FAL$LOG - PARSE FAL$LOG STRING
	.PSECT	FAL$CODE_LOGGER	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	FAL$PARSE_FAL$LOG parses the equivalence string from the translation
;	of FAL$LOG and stores the results in the FAL work area and/or global
;	storage depending on the options specified in the string.
;
; Calling Sequence:
;
;	BSBW	FAL$PARSE_FAL$LOG
;
; Input Parameters:
;
;	None
;
; Implicit Inputs:
;
;	FAL$Q_FALLOG
;
; Output Parameters:
;
;	R0-R6	Destroyed
;
; Implicit Outputs:
;
;	FAL$V_PARSE_ERR, FAL$V_DBS, FAL$V_SYS, FAL$V_VER, FAL$V_SC1, FAL$V_SC2
;
; Completion Codes:
;
;	None
;
; Side Effects:
;
;	None
;
;--

FAL$PARSE_FAL$LOG::			; Entry point
	MOVQ	FAL$Q_FALLOG(R8),R4	; <R4,R5> = FAL$LOG equivalence string
	TSTL	R4			; Branch if this is a null string
	BEQL	PARSE_NEXT		;
	MOVL	R5,R3			; Make copy of string address
10$:	MOVB	(R5)+,R1		; Get next character
	CMPB	#SPACE,R1		; Skip over if this is a space
	BEQL	20$			;
	CMPB	#TAB,R1			; Skip over if this is a tab
	BEQL	20$			;
	MOVB	R1,(R3)+		; Move character to buffer
20$:	SOBGTR	R4,10$			; Branch if not end-of-string
	SUBL3	FAL$Q_FALLOG+4(R8),R3,-	; Update FAL options string to reflect
		FAL$Q_FALLOG(R8)	;  size of compressed string
	MOVQ	FAL$Q_FALLOG(R8),R4	; <R4,R5> = compressed FAL$LOG string

;
; Obtain the parameter string or next qualifier string (divided into keyword
; and value substrings).
;

PARSE_NEXT:				; Parse parameter or next qualifier
	TSTL	R4			; Check for end-of-string and branch
	BNEQ	10$			;  if there is more string to parse
	RSB				; Exit from routine --------------------
10$:	CMPB	#SLASH,(R5)		; Is this start of a qualifier string?
	BNEQ	20$			; No, it is the parameter string
	DECL	R4			; Yes, skip over slash by adjusting
	INCL	R5			;  string descriptor
20$:	LOCC	#SLASH,R4,(R5)		; Find end of parameter or qualifier str
	SUBL3	R0,R4,R2		; <R2,R3> = parameter or qualifier desc
	MOVL	R5,R3			;  string less leading slash character
	MOVQ	R0,R4			; <R4,R5> = rest of string to parse desc
	CMPL	FAL$Q_FALLOG+4(R8),R3	; Determine if parameter or qualifier
	BEQL	PROCESS_PARAMETER	; Branch if this is the parameter
	LOCC	#EQUALSIGN,R2,(R3)	; Determine whether or not keyword has
	BEQL	PROCESS_QUALIFIER	;  associated value string
	SUBL2	R0,R2			; <R2,R3> = qualifier keyword descriptor
	DECL	R0			; Skip over equal sign character
	INCL	R1			; <R0,R1> = qualifier value descriptor
	BRB	PROCESS_QUALIFIER	; Process qaulifier

;
; Process the parameter bitmask which specifies FAL logging options.
;
; Note that the FAL V3.0 format of xx_yyyy is supported for compatibility where
; yyyy is a hexadecimal value for bytes per message to display (now /BPM=ddddd).
;

PROCESS_PARAMETER:			; Process FAL logging bitmask parameter
	LOCC	#UNDERSCORE,R2,(R3)	; Check for possible underline delimiter
	BEQL	10$			; Branch if no underline character found
	SUBL2	R0,R2			; <R2,R3> = parameter string descriptor
	DECL	R0			; Skip over underline character
	INCL	R1			; <R0,R1> = bytes per message descriptor
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVW	R1,W^FALL$W_PERMSG	; Save number of bytes per message value
10$:	MOVQ	R2,R0			; <R0,R1> = parameter bitmask descriptor
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVB	R1,FAL$B_LOGGING(R8)	; Store logging flags in FAL work area
	BRW	PARSE_NEXT		; Parse next qualifier

;
; Process the qualifier keyword and its associated value string. The value may
; be either a decimal or a hexadecimal integer depending on the keyword.
;

PROCESS_QUALIFIER:			; Process qualifier (keyword/value str)
	BICL3	#^X20202000,-1(R3),R6	; Move slash and first three characters
					;  of qualifier to register upcased
10$:	CMPL	#^A\/BPM\,R6		; Check for BPM=ddddd (zero is valid)
	BNEQ	20$			;
	BSBW	CONVERT_DEC_STRING	; Convert string to binary value
	MOVW	R1,W^FALL$W_PERMSG	; Store bytes per message value
	BRW	PARSE_NEXT		; Parse next qualifier

20$:	CMPL	#^A\/BPL\,R6		; Check for /BPL=dd
	BNEQ	30$			;
	BSBW	CONVERT_DEC_STRING	; Convert string to binary value
	TSTW	R1			; This must be a non-zero value
	BEQL	35$			; Branch if zero
	MOVW	R1,W^FALL$W_PERLINE	; Store bytes per line value
	BRW	PARSE_NEXT		; Parse next qualifier

30$:	CMPL	#^A\/RBK\,R6		; Check for /RBK_CACHE=ddd
	BNEQ	40$			;
	BSBW	CONVERT_DEC_STRING	; Convert string to binary value
	CMPW	R1,#FAL$K_MIN_RBK	; Branch if specified value is less
	BLSSU	35$			;  than minimum allowed
	CMPW	R1,#FAL$K_MAX_RBK	; Branch if specified value is greater
	BGTRU	35$			;  than maximum allowed
	MOVB	R1,FAL$B_RBK_CACHE(R8)	; Store RMS cache block value
	BRW	PARSE_NEXT		; Parse next qualifier
35$:	$SETBIT	#FAL$V_PARSE_ERR,(R8)	; Denote invalid value
	BRW	PARSE_NEXT		; Parse next qualifier

40$:	CMPL	#^A\/DIS\,R6		; Check for /DISABLE=xx
	BNEQ	50$			;
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVB	R1,FAL$B_DISABLE(R8)	; Store bitmask in FAL work area
	BRW	PARSE_NEXT		; Parse next qualifier

50$:	CMPL	#^A\/ENA\,R6		; Check for /ENABLE=xx
	BNEQ	60$			;
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVB	R1,FAL$B_ENABLE(R8)	; Store bitmask in FAL work area
	BRW	PARSE_NEXT		; Parse next qualifier

60$:	CMPL	#^A\/DBS\,R6		; Check for /DBS=ddddd
	BNEQ	70$			;
	BSBW	CONVERT_DEC_STRING	; Convert string to binary value
	MOVW	R1,FAL$W_USE_DBS(R8)	; Store buffer size in FAL work area
	$SETBIT	#FAL$V_USE_DBS,(R8)	; Denote DBS present
	BRW	PARSE_NEXT		; Parse next qualifier

70$:	CMPL	#^A\/SYS\,R6		; Check for /SYSTEM=xxxx
	BNEQ	80$			;
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVW	R1,FAL$W_USE_SYS(R8)	; Store bitmask in FAL work area
	$SETBIT	#FAL$V_USE_SYS,(R8)	; Denote SYS present
	BRW	PARSE_NEXT		; Parse next qualifier

80$:	CMPL	#^A\/VER\,R6		; Check for /VERSION=xxxxxxxx
	BNEQ	90$			;
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVL	R1,FAL$L_USE_VER(R8)	; Store bitmask in FAL work area
	$SETBIT	#FAL$V_USE_VER,(R8)	; Denote VER present
	BRW	PARSE_NEXT		; Parse next qualifier

90$:	CMPL	#^A\/SC1\,R6		; Check for /SC1=xxxxxxxx
	BNEQ	100$			;
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVL	R1,FAL$L_USE_SC1(R8)	; Store bitmask in FAL work area
	$SETBIT	#FAL$V_USE_SC1,(R8)	; Denote SC1 present
	BRW	PARSE_NEXT		; Parse next qualifier

100$:	CMPL	#^A\/SC2\,R6		; Check for /SC2=xxxxxxxx
	BNEQ	999$			;
	BSBW	CONVERT_HEX_STRING	; Convert string to binary value
	MOVL	R1,FAL$L_USE_SC2(R8)	; Store bitmask in FAL work area
	$SETBIT	#FAL$V_USE_SC2,(R8)	; Denote SC2 present
	BRW	PARSE_NEXT		; Parse next qualifier
999$:	$SETBIT	#FAL$V_PARSE_ERR,(R8)	; Denote invalid qualifier
	BRW	PARSE_NEXT		; Parse next qualifier

;+
; These routines convert either a decimal or a hexadecimal number to an unsigned
; binary value which is returned in R1.
;-

CONVERT_DEC_STRING:			; Convert decimal string to binary
	PUSHAL	FAL$L_TEMP(R8)		; Address to place converted result
	PUSHL	R1			; Address of input string
	PUSHL	R0			; Size of input string
	CALLS	#3,G^LIB$CVT_DTB	; Perform the conversion
	BRB	CONVERT_COMMON		; Join common code
CONVERT_HEX_STRING:			; Convert hexadecimal string to binary
	PUSHAL	FAL$L_TEMP(R8)		; Address to place converted result
	PUSHL	R1			; Address of input string
	PUSHL	R0			; Size of input string
	CALLS	#3,G^LIB$CVT_HTB	; Perform the conversion
CONVERT_COMMON:				; Common conversion code
	BLBC	R0,10$			; Branch on failure
	MOVL	FAL$L_TEMP(R8),R1	; Return resultant binary value in R1	
	RSB				; Exit
10$:	POPR	#^M<R0>			; Discard return address
	$SETBIT	#FAL$V_PARSE_ERR,(R8)	; Denote conversion failure
	BRW	PARSE_NEXT		; Parse next qualifier

	.SBTTL	FAL$STATISTICS - COMPUTE AND PRINT STATISTICS
	.PSECT	FAL$CODE_LOGGER	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	FAL$STATISTICS computes and prints statistics to the print file.
;
; Calling Sequence:
;
;	BSBW	FAL$STATISTICS
;
; Input Parameters:
;
;	None
;
; Implicit Inputs:
;
;	None
;
; Output Parameters:
;
;	R0-R7	Destroyed
;	R9-R11	Destroyed
;
; Implicit Outputs:
;
;	None
;
; Completion Codes:
;
;	None
;
; Side Effects:
;
;	None
;
;--

FAL$STATISTICS::			; Entry point
	MOVAL	FAL$L_STB(R8),R7	; Get address of statistics block

;
; Compute total link connect time and store it in 64-bit delta time format.
; The staring and ending times are initially in 64-bit absolute time format, so
; delta_time = -(end_time - start_time) = (start_time - end_time).
;

	SUBL2	W^FAL$GQ_TIME1,-	; Double precision subtraction of
		W^FAL$GQ_TIME0		;  ending time from starting time
	SBWC	W^FAL$GQ_TIME1+4,-	;  to obtain negative difference and
		W^FAL$GQ_TIME0+4	;  store in 64-bit delta format

;
; Compute total CPU time used while the logical link connection was in effect
; and store the result in 64-bit delta time format in 100 nanosecond units.
; The starting and ending CPU times are initially in 32-bit binary format in
; 10 millisecond units (or hundredths of a second). Therefore, the algorithm is
; delta_time = (start_units - end_units) * 100000.
;

	SUBL3	W^FALL$L_CPUTIM1,-	; Subtract ending time ticks from
		W^FALL$L_CPUTIM0,R0	;  starting time ticks to obtain
	MULL3	#100000,R0,-		;  negative difference, then multiply
		W^FALL$Q_CPUTIME	;  by 100000 and store result as a
	MNEGL	#1,W^FALL$Q_CPUTIME+4	;  64-bit delta time

;
; Write total link connect time and total CPU time used to the print file.
;

	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_CONNTIME-; Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=#FAL$GQ_TIME0-	;  Address of delta connect time
		P2=#FALL$Q_CPUTIME	;  Address of delta CPU time used
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message

;
; Total the event counters.
;

	ADDL3	FAL$L_RCV_PKT(R7),-	; Total DAP message packets
		FAL$L_XMT_PKT(R7),R2	; 
	ADDL3	FAL$L_RCV_MSG(R7),-	; Total DAP messages
		FAL$L_XMT_MSG(R7),R3	; 
	ADDL3	FAL$L_RCV_DAT(R7),-	; Total user records/blocks
		FAL$L_XMT_DAT(R7),R4	; 
	ADDL3	FAL$L_RCV_USR(R7),-	; Total bytes of user data
		FAL$L_XMT_USR(R7),R5	; 
	ADDL3	FAL$L_RCV_LNK(R7),-	; Total bytes of link data
		FAL$L_XMT_LNK(R7),R6	; 

;
; Write statistics header and counters to the print file.
;

	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_STAT1-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=FAL$L_RCV_PKT(R7)-	;  # DAP message packets received
		P2=FAL$L_XMT_PKT(R7)-	;  # DAP message packets transmitted
		P3=R2-			;  # DAP messages packets exchanged
		P4=FAL$L_RCV_MSG(R7)-	;  # DAP messages received
		P5=FAL$L_XMT_MSG(R7)-	;  # DAP messages transmitted
		P6=R3			;  # DAP messages exchanged
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_STAT2-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=FAL$L_RCV_DAT(R7)-	;  # data records/blocks received
		P2=FAL$L_XMT_DAT(R7)-	;  # data records/blocks transmitted
		P3=R4-			;  # data records/blocks exchanged
		P4=FAL$L_RCV_USR(R7)-	;  # bytes of user data received
		P5=FAL$L_XMT_USR(R7)-	;  # bytes of user data transmitted
		P6=R5-			;  # bytes of user data exchanged
		P7=FAL$L_RCV_LNK(R7)-	;  # bytes of link data received
		P8=FAL$L_XMT_LNK(R7)-	;  # bytes of link data transmitted
		P9=R6			;  # bytes of link data exchanged
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message

;
; Convert logical link connect time from internal 64-bit delta time format in
; 100 nanosecond units to 32-bit binary format in 10 millisecond units (or
; hundredths of a second).
;

	MOVL	W^FAL$GQ_PRTBUF1+4,R9	; Get 14 byte scratch buffer address
	$NUMTIM_S TIMBUF=(R9)-		; Convert delta link connect time
		TIMADR=W^FAL$GQ_TIME0	;  to numeric values
	$CHECK_STATUS			; Check status code
	TSTL	(R9)+			; Skip to day field address
	MOVZWL	(R9)+,R11		; Get day value
	MULL2	#24,R11			; Convert to hours
	MOVZWL	(R9)+,R10		; Get hour value
	ADDL2	R10,R11			; Obtain total hours
	MULL2	#60,R11			; Convert to minutes
	MOVZWL	(R9)+,R10		; Get minute value
	ADDL2	R10,R11			; Obtain total minutes
	MULL2	#60,R11			; Convert to seconds
	MOVZWL	(R9)+,R10		; Get seconds value
	ADDL2	R10,R11			; Obtain total seconds
	MULL2	#100,R11		; Convert to hundredths
	MOVZWL	(R9)+,R10		; Get hundredths value
	ADDL2	R10,R11			; Obtain total hundredths
	BEQL	AVERAGE			; Branch if zero (something is wrong!>

;
; Compute line throughput statistics where:
;
; Throughput = <#bits> / <#seconds>
;	     = <#bits * 100> / <#seconds / 100>
;	     = <#bytes * 8 * 100> / <#hundredths>
;	     = <#bytes> / <#hundredths / 800>
;

	CVTLF	R11,R9			; Put hundredths of second value
					;  in floating point format
	DIVF2	#800,R9			; Build divisor in desired form
	CVTLF	FAL$L_RCV_USR(R7),R0	; Put # bytes of user data received
					;  in floating point format
	DIVF2	R9,R0			; Compute receive baud rate
	CVTRFL	R0,R0			; Round result and store as integer
	CVTLF	FAL$L_XMT_USR(R7),R1	; Put # bytes of user data transmitted
					;  in floating point format
	DIVF2	R9,R1			; Compute transmit baud rate
	CVTRFL	R1,R1			; Round result and store as integer
	CVTLF	R5,R2			; Put # bytes of user data exchanged
					;  in floating point format
	DIVF2	R9,R2			; Compute full-duplex baud rate
	CVTRFL	R2,R2			; Round result and store as integer
	CVTLF	FAL$L_RCV_LNK(R7),R3	; Put # bytes of link data received
					;  in floating point format
	DIVF2	R9,R3			; Compute receive baud rate
	CVTRFL	R3,R3			; Round result and store as integer
	CVTLF	FAL$L_XMT_LNK(R7),R10	; Put # bytes of link data transmitted
					;  in floating point format
	DIVF2	R9,R10			; Compute transmit baud rate
	CVTRFL	R10,R10			; Round result and store as integer
	CVTLF	R6,R11			; Put # bytes of link data exchanged
					;  in floating point format
	DIVF2	R9,R11			; Compute full-duplex baud rate
	CVTRFL	R11,R11			; Round result and store as integer
;
; Write logical link throughput statistics to the print file.
;

	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_STAT3-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R0-			;  User receive throughput
		P2=R1-			;  User transmit throughput
		P3=R2-			;  User full-duplex throughput
		P4=R3-			;  Link receive throughput
		P5=R10-			;  Link transmit throughput
		P6=R11			;  Link full-duplex throughput
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message

;
; Compute average record/block size.
;

AVERAGE:				;
	CLRL	R9			; Prepare for zero divisor
	CLRQ	R10			; "
	CVTLF	FAL$L_RCV_DAT(R7),R0	; Get divisor
	BEQL	10$			; Avoid division by zero
	CVTLF	FAL$L_RCV_USR(R7),R1	; Get dividend
	DIVF2	R0,R1			; Find average receive size
	CVTRFL	R1,R9			; Round an store as integer
10$:	CVTLF	FAL$L_XMT_DAT(R7),R0	; Get divisor
	BEQL	20$			; Avoid division by zero
	CVTLF	FAL$L_XMT_USR(R7),R1	; Get dividend
	DIVF2	R0,R1			; Find average transmit size
	CVTRFL	R1,R10			; Round an store as integer
20$:	CVTLF	R4,R0			; Get divisor
	BEQL	30$			; Avoid division by zero
	CVTLF	R5,R1			; Get dividend
	DIVF2	R0,R1			; Find overall average size
	CVTRFL	R1,R11			; Round an store as integer

;
; Write average record/block size statistics to the print file.
;

30$:	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_STAT4-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R9-			;  Average receive record/block size
		P2=R10-			;  Average transmit record/block size
		P3=R11			;  Average overall record/block size
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message

;
; Compute (DAP) protocol efficiency statistics where:
;
; efficiency = <user_data_bytes> / <totaL_link_data_bytes>
;

	MOVL	FAL$L_RCV_LNK(R7),R0	; Get divisor
	MOVL	FAL$L_RCV_USR(R7),R1	; Get dividend
	BSBW	PERCENTAGE		; Compute receive percentage
	MOVQ	R0,R2			; Copy results to <R2,R3>
	MOVL	FAL$L_XMT_LNK(R7),R0	; Get divisor
	MOVL	FAL$L_XMT_USR(R7),R1	; Get dividend
	BSBW	PERCENTAGE		; Compute transmit percentage
	MOVQ	R0,R10			; Copy results to <R10,R11>
	MOVL	R6,R0			; Get divisor
	MOVL	R5,R1			; Get dividend
	BSBW	PERCENTAGE		; Compute full-duplex percentage
					;  results are in <R0,R1>

;
; Write (DAP) protocol efficeincy statistics to the print file.
;

	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_STAT5-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R2-			;  Receive protocol efficiency
		P2=R3-			;  "
		P3=R10-			;  Transmit protocol efficiency
		P4=R11-			;  "
		P5=R0-			;  Overall protocol efficiency
		P6=R1			;  "
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message

;
; Write other performance indicators to the print file.
;

	MOVZWL	FAL$W_DAPBUFSIZ(R8),R1	; Get negotiated DAP buffer size
	SUBL3	W^FALL$L_BUFIO0,-	; Find total buffered I/O count
		W^FALL$L_BUFIO1,R2	;
	SUBL3	W^FALL$L_DIRIO0,-	; Find total direct I/O count
		W^FALL$L_DIRIO1,R3	;
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_STAT6-	; Address of control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address of receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer to put string
		P1=R1-			;  Negotiated DAP buffer size
		P2=R2-			;  Total buffered I/O count
		P3=R3-			;  Total direct I/O count
		P4=W^FALL$L_WSPEAK	;  Peak working set size
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
	RSB				; Exit

;++
; This routine computes a percentage in xx.y format, given an integer divisor
; and an integer dividend.
;
; On input:
;
;	R0 = Divisor
;	R1 = Dividend
;
; On output:
;
;	R0 = xx part
;	R1 =  y part
;--

PERCENTAGE:				; Entry point
	CVTLF	R0,R0			; Put divisor in floating point format
	BEQL	10$			; Branch if division by zero
	CVTLF	R1,R1			; Put dividend in floating point format
	MULF2	#1000,R1		; Compute percentage x 10
	DIVF2	R0,R1			; "
	CVTRFL	R1,R0			; Round result and store as integer
10$:	CLRL	R1			; Prepare for double precision division
	EDIV	#10,R0,R0,R1		; Split result into xx.y format
	RSB				; Exit

	.SBTTL	FAL$PRINT_FAO, FAL$PRINT_FAO_ASTLEVEL
	.PSECT	FAL$CODE_LOGGER	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	FAL$PRINT_FAO outputs the buffer formatted by FAO to the print file
;	and is called from non-AST-level code.
;
;	FAL$PRINT_FAO_ASTLEVEL performs the same function, except it is called
;	from AST-level code.
;
; Calling Sequence:
;
;	BSBW	FAL$PRINT_FAO
;	BSBW	FAL$PRINT_FAO_ASTLEVEL
;
; Input Parameters:
;
;	None
;
; Implicit Inputs:
;
;	FAL$GQ_PRTBUF1
;	FAL$GQ_PRTBUF2
;	FAL$GW_PRTLEN1
;	FAL$GW_PRTLEN2
;
; Output Parameters:
;
;	R0-R1	Destroyed
;
; Implicit Outputs:
;
;	FAL$PRTRAB is updated
;
; Completion Codes:
;
;	None
;
; Side Effects:
;
;	None
;
;--

FAL$PRINT_FAO::				; Entry point
	MOVAL	W^FAL$PRTRAB,R1		; Get address of print RAB
	MOVL	W^FAL$GQ_PRTBUF1+4,-	; Update buffer address in RAB
		RAB$L_RBF(R1)		;
	MOVW	W^FAL$GW_PRTLEN1,-	; Update buffer size in RAB
		RAB$W_RSZ(R1)		;
	$PUT	RAB=R1			; Write the record
	$CHECK_STATUS			; Check completion code
	TSTW	W^FAL$GW_PRTLEN2	; Check for AST level PUT failure
	BEQL	10$			;  because of PUT above in progress
	INCL	W^FAL$GL_COUNTER1	; Count occurrence of race condition
	BSBB	FAL$PRINT_FAO_ASTLEVEL	; Write AST level message now
10$:	RSB				; Exit

FAL$PRINT_FAO_ASTLEVEL::		; Entry point
	MOVAL	W^FAL$PRTRAB,R1		; Get address of print RAB
	MOVL	W^FAL$GQ_PRTBUF2+4,-	; Update buffer address in RAB
		RAB$L_RBF(R1)		;
	MOVW	W^FAL$GW_PRTLEN2,-	; Update buffer size in RAB
		RAB$W_RSZ(R1)		;
	$PUT	RAB=R1			; Write the record
	CMPW	R0,#<RMS$_BUSY&^XFFFF>	; Record stream busy? (new status code
	BEQL	10$			; If so, exit to let other PUT finish
	CMPW	R0,#<RMS$_RSA&^XFFFF>	; Record stream active error?
	BEQL	10$			; If so, exit to let other PUT finish
	$CHECK_STATUS			; Check completion code
	CLRW	W^FAL$GW_PRTLEN2	; Declare AST level PUT complete
10$:	RSB				; Exit

	.SBTTL	FAL$DISPLAY_MSG - DISPLAY MESSAGE BUFFER
	.PSECT	FAL$CODE_LOGGER	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	FAL$DISPLAY formats the specified DAP message and outputs it to the
;	print file. Note that for incoming messages, this routine requires
;	that FAL$DECODE_MSG has already parsed the message and updated the
;	DAP control block.
;
; Calling Sequence:
;
;	Call	#3,FAL$DISPLAY_MSG
;
; Input Parameters:
;
;	4(AP)	Address of header text (counted ASCII string) for message
;	8(AP)	Size of the DAP message in bytes
;	12(AP)	Address of the DAP message
;	R9	Address of DAP control block (for incoming messages)
;
; Implicit Inputs:
;
;	FALL$W_PERMSG
;	FALL$W_PERLINE
;
; Output Parameters:
;
;	R0-R1	Destroyed
;
; Implicit Outputs:
;
;	None
;
; Completion Codes:
;
;	None
;
; Side Effects:
;
;	None
;
;--

	.ENTRY	FAL$DISPLAY_MSG,^M<R2,R3,R4,R5> ; Entry point

;
; Determine total number of bytes to display of the DAP message and the number
; of bytes to display on the first line of the printout.
;

	MOVZWL	W^FALL$W_PERMSG,R0	; Get max # bytes to display per message
	MOVZWL	W^FALL$W_PERLINE,R5	; Get max # bytes to display per line
	CMPL	8(AP),R0		; Is message size GEQ max count?
	BGEQU	10$			; Yes
	MOVL	8(AP),R0		; No, use actual message size
10$:	MOVL	R0,R3			; Save count
	CMPL	R0,R5			; Branch if message will fit on one
	BLEQU	20$			;  line
	MOVL	R5,R0			; Specify count for this line
20$:	SUBL2	R0,R3			; Determine count remaining after this
					;  line
	MOVL	R0,R1			; Save count for this line
	BEQL	40$			; Branch on zero length message

;
; Construct parameter list on the stack for use by $FAOL routine.
;
;	R0=R1	# bytes to print on first line
;	R3	Total # bytes to display for message
;

	MOVL	12(AP),R2		; Get address of message buffer
30$:	MOVZBL	(R2)+,-(SP)		; Put each character in list
	SOBGTR	R0,30$			; Continue until done
40$:	PUSHL	R1			; Put # bytes to convert in list
	PUSHL	8(AP)			; Put actual message size in list
	MOVZBL	@12(AP),R0		; Get first byte of message (type field)
	BSBW	GET_FUNCTION		; Get function code
	PUSHL	R4			; Put address of string in list
	TSTL	8(AP)			; Branch on zero length message
	BEQL	50$			;
	CMPB	R0,#DAP$K_NAM_MSG	; Bounds check message type value
	BLEQU	60$			; Branch if within range
50$:	CLRL	R0			; Treat as reserved
60$:	PUSHAL	W^FALL$L_MSGTYPE[R0]	; Put address of message type text
					;  in list
	PUSHL	4(AP)			; Put address of header text for message
					;  in list
	MOVL	SP,R1			; Get address of FAOL parameter list

;
; Format and print first line of message.
;

	$FAOL_S-			; Format the message
		CTRSTR=W^FALL$Q_LOGMSG-	;  Address of FAOL control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		PRMLST=(R1)		;  Address of parameter list
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message

;
; Print additional lines as required to display the entire DAP message.
;

DISPLAY_LOOP:				;
	MOVL	R3,R0			; Get # bytes remaining to display
	BEQL	DISPLAY_EXIT		; Branch if none
	CMPL	R0,R5			; Branch if message will fit on one
	BLEQU	10$			;  line
	MOVL	R5,R0			; Specify count for this line
10$:	SUBL2	R0,R3			; Determine count remaining after this
					;  line
	MOVL	R0,R1			; Save count for this line
20$:	MOVZBL	(R2)+,-(SP)		; Put each character in list
	SOBGTR	R0,20$			; Continue until done
	PUSHL	R1			; Put # bytes to convert in list
	MOVL	SP,R1			; Get address of FAOL parameter list

;
; Format and print next line of message.
;

	$FAOL_S-			; Format the message
		CTRSTR=W^FALL$Q_LOGMSG2-;  Address of FAOL control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		PRMLST=(R1)		;  Address of parameter list
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
	BRB	DISPLAY_LOOP		;

;
; The "RET" instruction will adjust SP so that the parameter list for $FAOL
; that was constructed on the stack is eliminated.
;

DISPLAY_EXIT:				;
	RET				; Exit

;+
; This routine returns the address of a counted text string that describes the
; function code (if any) of the parsed DAP message.
;
; Inputs:
;	R0	Message type value
;	R9	Address of DAP control block
; Outputs:
;	R1	Destroyed
;	R4	Address of counted ASCII text string
;-

FUNCTION_CODE=DAP$B_CTLFUNC		; Offset of function code fields in DAP
					;  control block (same for all messages)
GET_FUNCTION:				; Entry point
	CMPL	4(AP),#FAL$GT_DECODE	; Branch if this is an incoming message
	BEQL	10$			;  that has just been parsed
	CMPB	R0,#DAP$K_CMP_MSG	; Check for outgoing Access Complete
	BNEQ	99$			;  message
	MOVL	#RESPONSE_CODE,R1	; It must be a response fuction code
	BRB	55$			; Join common code
10$:	$CASEB	SELECTOR=R0-		; Get DAP message type code
		BASE=#DAP$K_ACC_MSG-	;
		DISPL=<-		; Message type:
		    20$-		;  Access Complete
		    30$-		;  Control
		    40$-		;  Continue Transfer
		    99$-		;  Acknowledge
		    50$-		;  Access Complete
		>			;
99$:	MOVAB	W^FALL$T_MSG,R4		; Get address of counted string
	RSB				; Exit

;
; Get address of text string based on message type and function code.
;

20$:	MOVZBL	FUNCTION_CODE(R9),R1	; Get Access function code
	MOVAL	W^FALL$L_ACCFUNC[R1],R4	; Get address of counted string
	RSB				; Exit
30$:	MOVZBL	FUNCTION_CODE(R9),R1	; Get Control function code
	BEQL	35$			; Screen out illegal code
	CMPB	DAP$B_RAC(R9),-		; Branch if not block I/O mode; else
		#DAP$K_BLK_VBN		;  convert 'GET' into 'READ' string
	BLSSU	35$			;  and 'PUT' into 'WRITE' string
	CMPB	R1,#DAP$K_PUT_WRITE	;  if function code is within bounds
	BGTRU	35$			; Branch if not GET, CON, UPD, or PUT
	ADDL2	#CTLFUNC_ALT_DEF,R1	; Index into alternate definition table
35$:	MOVAL	W^FALL$L_CTLFUNC[R1],R4	; Get address of counted string
	RSB				; Exit
40$:	MOVZBL	FUNCTION_CODE(R9),R1	; Get Continue Transfer function code
	MOVAL	W^FALL$L_CONFUNC[R1],R4	; Get address of counted string
	RSB				; Exit
50$:	MOVZBL	FUNCTION_CODE(R9),R1	; Get Access Complete function code
55$:	MOVAL	W^FALL$L_CMPFUNC[R1],R4	; Get address of counted string
	RSB				; Exit

	.SBTTL	FAL$LOG_QIO, FAL$LOG_AST
	.PSECT	FAL$CODE_LOGGER	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Write QIO posted message to the print file.
;--

FAL$LOG_QIO::				; Entry point
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_LOGQIO-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=#0-			;  Use current time of day
		P2=R1			;  Address of counted string
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
	RSB				; Exit

;++
; Write AST delivered message to the print file.
;--

FAL$LOG_AST::				; Entry point
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_LOGAST-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN2-;  Address of receive string length
		OUTBUF=W^FAL$GQ_PRTBUF2-;  Address of buffer descriptor
		P1=#0-			;  Use current time of day
		P2=R1-			;  Address of counted string
		P3=R0			;  # bytes in DAP message packet
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO_ASTLEVEL	; Print message
	RSB				; Exit

	.SBTTL	FAL$LOG_REQNAM, FAL$LOG_REQNAM2
	.PSECT	FAL$CODE_LOGGER	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Write requested new file Name message to the print file.
;
; Inputs:
;	R1	Access function code
;	R2	Address of filespec string descriptor
;--

FAL$LOG_REQNAM::			; Entry point
	BBC	#FAL$V_LOG_NAM,(R8),10$	; Branch if logging disabled
	ASHL	#1,R1,R1		; Multiply by 2 for octaword index
	MOVAQ	W^FALL$T_ACCFUNC[R1],R1	; Get address of counted string
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_REQNAM-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R1-			;  Address of counted string
		P2=R2			;  Address of filespec string descriptor
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
10$:	RSB				; Exit

;++
; Write requested new file Name message to the print file.
;
; Inputs:
;	R2	Address of filespec string descriptor
;--

FAL$LOG_REQNAM2::			; Entry point
	BBC	#FAL$V_LOG_NAM,(R8),10$	; Branch if logging disabled
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_REQNAM2-;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R2			;  Address of filespec string descriptor
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
10$:	RSB				; Exit

	.SBTTL	FAL$LOG_RESNAM, FAL$LOG_CLSMSG
;++
; Write resultant file Name message to the print file.
;--

FAL$LOG_RESNAM::			; Entry point
	BBC	#FAL$V_LOG_NAM,(R8),10$	; Branch if logging disabled
	MOVZBL	FAL$L_NAM+NAM$B_RSL(R8),R0 ; Get resultant string length
	MOVL	FAL$L_NAM+NAM$L_RSA(R8),R1 ; Get resultant string address
	BBC	#FAL$V_NEWNAM,(R8),5$	; Branch if not the 2nd (new) Name
					;  message of rename operation
	MOVZBL	FAL$L_NAM2+NAM$B_RSL(R8),R0 ; Get new resultant string length
	MOVL	FAL$L_NAM2+NAM$L_RSA(R8),R1 ; Get new resultant string address
5$:	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_RESNAM-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R0-			;  Resultant string length
		P2=R1			;  Resultant string address
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
10$:	RSB				; Exit

;++
; Write file close message with selected FOP options to the print file.
;
; Inputs:
;	R0	FOP field of the FAB
;--

FAL$LOG_CLSMSG::			; Entry point

	ASSUME	FAB$V_SPL+1 EQ FAB$V_SCF
	ASSUME	FAB$V_SCF+1 EQ FAB$V_DLT

	BBC	#FAL$V_LOG_NAM,(R8),10$	; Branch if logging disabled
	EXTZV	#FAB$V_SPL,#3,R1,R1	; Extract DLT!SCF!SPL bits
	MOVAQ	W^FALL$Q_FOP_OPT[R1],R1	; Get appropriate counted string
	$FAO_S-				; Format the message
		CTRSTR=W^FALL$Q_CLOSE-	;  Address of FAO control string
		OUTLEN=W^FAL$GW_PRTLEN1-;  Address to receive string length
		OUTBUF=W^FAL$GQ_PRTBUF1-;  Address of buffer descriptor
		P1=R1			;  Address of counted string
	$CHECK_STATUS			; Check status code
	BSBW	FAL$PRINT_FAO		; Print message
10$:	RSB				; Exit

	.END				; End of module
