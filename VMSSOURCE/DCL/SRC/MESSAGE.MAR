	.TITLE	MESSAGE - MESSAGE OUTPUT ROUTINES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; MESSAGE OUTPUT ROUTINES
;
; D. N. CUTLER 28-MAR-77
;
; MODIFIED BY:
;
;	V03-010	HWS0065		Harold Schultz		09-May-1984
;		Use a temporary RAB built on stack when flushing output
;		to a batch log file instead of current output RAB.
;
;	V03-009 HWS0058		Harold Schultz		12-Apr-1984
;		Add DCL$SPAWNOUT message routine for SPAWN since it
;		doesn't have valid pointer to work area.(Must be same
;		as DCL$MSGOUT.
;
;	V03-008	PCG0008		Peter George		02-Mar-1984
;		Move inhibit message bit test.
;
;	V03-007	HWS0014		Harold Schultz		21-Feb-1984
;		If current error number equal to RMS STS value in
;		PRC_L_STS, signal both the STS and STV messages.
;
;	V03-006	PCG0007		Peter George		21-Nov-1983
;		Fix bug in specifying record for $FLUSH.
;
;	V03-005	PCG0006		Peter George		29-Jun-1983
;		Handle event flags more intelligently.
;
;	V03-004	PCG0005		Peter George		24-Jun-1983
;		Fix broken branch.
;
;	V03-004	PCG0004		Peter George		15-Jun-1983
;		Do not special case negative statuses.
;		Return non-zero status when calling SET OUTPUT_RATE
;		interactively.  Change order of $FLUSH and $SETTIMER
;		in flush ast routine.
;
;	V03-003	PCG0003		Peter George		30-Apr-1983
;		Add DCL$FLUSH_OUTPUT.
;		Fix order of args but in $PUTMSG call.
;
;	V03-002	PCG0002		Peter George		21-Mar-1983
;		Add DCL$FORMMSG.
;
;	V03-001	PCG0001		Peter George		07-Jan-1983
;		Use $PUTMSG to output command segment.
;		Delete DCL$ERROUT.
;
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE COMMAND TOKENS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$IODEF				;DEFINE I/O FUNCTION CODES
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS LONGWORD VALUES
	$SFDEF				;DEFINE CALL FRAME

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

	.SBTTL	OUTPUT ERROR MESSAGE
;+
; DCL$ERRORMSG - OUTPUT ERROR MESSAGE
;
; THIS ROUTINE IS CALLED TO OUTPUT AN ERROR MESSAGE AND DISPLAY THE SEGMENT
; OF THE COMMAND LINE THAT IS IN ERROR.
;
; INPUTS:
;
;	R0 = ERROR NUMBER.
;	WRK_L_MARKPTR = ADDRESS OF START OF TOKEN IN EXPANSION BUFFER.
;	WRK_L_EXPANDPTR = ADDRESS OF NEXT BYTE IN EXPANSION BUFFER.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE APPROPRIATE ERROR MESSAGE IS DISPLAYED ALONG WITH THE SEGMENT OF
;	THE COMMAND LINE IN ERROR.
;
;	R0 IS PRESERVED ACROSS CALL.
;-
 
DCL$ERRORMSG::				;OUTPUT ERROR MESSAGE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE REGISTERS
	BBS	#STS$V_INHIB_MSG,R0,60$ ;BR IF NO MESSAGE DESIRED

;
; Check if offending text should be output as part of this error message.
;
	MOVL	#2,R5			;ASSUME NO COMMAND SET WILL BE OUTPUT
	MOVL	#3*4,R4			;  SET ARG COUNT AND STACK USAGE
	BBS	#WRK_V_COMMAND,-	;DO NOT OUTPUT IF COMMAND IN EXECUTION
		WRK_W_FLAGS(R10),40$ 	;
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF CURRENT PARSE STRING
	TSTB	(R2)			;DOES TOKEN START WITH EOL CHAR?
	BEQL	40$			;IF SO, ASSUME AT EOL AND SKIP TEXT
	TSTL	R1			;WILL ANY TOKEN BE SHOWN?
	BEQL	40$			;IF NO ERROR TOKEN, SKIP IT

;
; Build the command line part of the message argument vector.
;
30$:	MOVQ	R1,-(SP)		;PUSH SEGMENT DESCRIPTOR ON STACK
	PUSHL	SP			;PUSH ADDRESS OF SEGMENT DESCRIPTOR
	MOVW	#^X0011,-(SP)		;ONLY OUTPUT THE TEXT PART
	MOVW	#1,-(SP)		;ONE FAO ARGUMENT
	PUSHL	#CLI$_CMDSEG		;PUSH MESSAGE CODE
	MOVL	#5,R5			;SET ARGUMENT COUNT
	MOVL	#8*4,R4			;SET STACK USAGE

;
; Build the status part of the message argument vector.
;
40$:	TSTL	PRC_L_STS(R11)		;VALID STS VALUE?
	BEQL	45$			;NO, PROCESS NORMALLY

	CMPL	PRC_L_STS(R11),R0	;STS VALUE = TO CURRENT ERROR NUM?
	BNEQ	45$			;NO, PROCESS NORMALLY

	CMPB	R5,#2			;OUTPUT COMMAND SET?
	BGTR	45$			;YES, PROCESS NORMALLY
	PUSHL	PRC_L_STV(R11)		;PUT STV VALUE INTO MESSAGE VECTOR
	BRB	50$

45$:	PUSHL	#0			;CREATE PUTMSG VECTOR (FAO COUNT)
50$:	PUSHL	R0			;SET STATUS CODE
	PUSHL	R5			;# ARGS ON PUTMSG VECTOR
	MOVL	SP,R0			;ADDRESS OF THE BUFFER DESCRIPTOR

	BSBB	DCL$PUTMSG		;SIGNAL PUTMSG VECTOR AT (R0)
	ADDL	R4,SP			;POP EVERYTHING UP TO BUFFER AND DESC.

60$:	ASSUME	PRC_L_STV EQ PRC_L_STS+4
	CLRQ	PRC_L_STS(R11)		;INIT. STS AND STV ERROR NUMBERS
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	RSB				;

	.SBTTL	FORMAT MESSAGE
;+
; DCL$FORMMSG - FORMAT MESSAGE
;
; THIS ROUTINE IS CALLED TO CREATE A MESSAGE VECTOR FOR A MESSAGE AND THEN
; CALL DCL$PUTMSG TO OUTPUT THAT MESSAGE.
;
; INPUTS:
;
;	R0 = ERROR NUMBER.
;	R1 = NUMBER OF ARGUMENTS.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
;	THE FAO ARGUMENTS ARE ON THE STACK, JUST ABOVE THE STORED PC.
;
; OUTPUTS:
;
;	THE ERROR MESSAGE IS DISPLAYED.
;	THE FAO ARGUMENTS ARE POPPED FROM THE STACK.
;	R1,R2 ARE DESTROYED
;-
DCL$FORMMSG::				;OUTPUT MESSAGE
	MOVL	(SP)+,R2		;GET SAVED PC
	PUSHL	R1			;PUSH FAO COUNT
	PUSHL	R0			;SET STATUS CODE
	ADDL3	#2,R1,-(SP)		;SET # ARGS IN PUTMSG VECTOR
	MOVL	SP,R0			;SET ADDRESS OF THE ARGUMENT VECTOR
	BSBB	DCL$PUTMSG		;SIGNAL PUTMSG VECTOR AT (R0)
	ADDL	#8,SP			;RESTORE THE STACK
	POPL	R1			;
	MOVAL	(SP)[R1],SP		;
	MOVL	R2,-(SP)		;RESTORE THE PC
	RSB				;

	.SBTTL	PUTMSG OUTPUT ROUTINE
;---
;
;	THIS ROUTINE OUTPUTS A GIVEN PUTMSG MESSAGE VECTOR
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R0 = ADDRESS OF PUTMSG VECTOR
;
; OUTPUTS:
;
;	NONE
;---
DCL$PUTMSG::
	DISABLE				; DISABLE CONTROL Y/C AST'S
	PUSHL	#^A'DCL '		; FACILITY NAME
	PUSHL	SP			; MAKE DESCRIPTOR OF NAME
	PUSHL	#3
	PUSHL	SP			; SET ADDRESS OF FACNAM
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,4(R0),-
		#<CLI$_ABKEYW&STS$M_FAC_NO>@-STS$V_FAC_NO
	BEQL	10$			; BRANCH IF OUR FACILITY
	CLRL	(SP)			; IF NOT OUR FACILITY, ZERO FACNAM PARAMETER
10$:	PUSHL	#0			; NO ACTION ROUTINE
	PUSHL	R0			; R0 = ADDRESS OF MESSAGE VECTOR
	CALLS	#6,G^SYS$PUTMSG		; WRITE THE MESSAGE TO SYS$ERROR,OUTPUT
	ENABLE				; RE-ENABLE CONTROL/Y AST'S
	BBC	#WRK_V_COMMAND,WRK_W_FLAGS(R10),90$ ; BRANCH IF NO IMAGE ACTIVE
	BSBW	DCL$CHECK_AST		; CHECK FOR PENDING AST
90$:	RSB

	.SBTTL	OUTPUT FILE MESSAGE OUTPUT (FOR SPAWN)
;+
; DCL$SPAWNOUT - OUTPUT FILE MESSAGE OUTPUT
;
; THSI ROUTINE IS CALLED TO OUTPUT A MESSAGE TO THE OUTPUT FILE.
;
; INPUTS:
;
;	R1 = LENGTH OF MESSAGE.
;	R2 = ADDRESS OF MESSAGE.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE MESSAGE IS WRITTEN TO THE OUTPUT FILE AND CONTROL IS RETURNED
;	TO THE CALLER.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
DCL$SPAWNOUT::				;MESSAGE OUTPUT
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET ADDRESS OF INDIRECT OUTPUT RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;BR IF NOT IN CONTROL Y
	MOVL	PRC_L_OUTRAB(R11),R0	;SET ADDRESS OF OUTPUT FILE RAB
20$:	DISABLE				;DISABLE CONTROL Y/C AST'S
	MOVW	R1,RAB$W_RSZ(R0)	;SET SIZE OF OUTPUT RECORD
	MOVL	R2,RAB$L_RBF(R0)	;SET ADDRESS OF OUTPUT RECORD
	$PUT	RAB=(R0)		;OUTPUT RECORD
	ENABLE				;ENABLE CONTROL Y/C AST'S
	RSB				;

	.SBTTL	OUTPUT FILE MESSAGE OUTPUT
;+
; DCL$MSGOUT - OUTPUT FILE MESSAGE OUTPUT
;
; THSI ROUTINE IS CALLED TO OUTPUT A MESSAGE TO THE OUTPUT FILE.
;
; INPUTS:
;
;	R1 = LENGTH OF MESSAGE.
;	R2 = ADDRESS OF MESSAGE.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE MESSAGE IS WRITTEN TO THE OUTPUT FILE AND CONTROL IS RETURNED
;	TO THE CALLER.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
DCL$MSGOUT::				;MESSAGE OUTPUT
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET ADDRESS OF INDIRECT OUTPUT RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;BR IF NOT IN CONTROL Y
	MOVL	PRC_L_OUTRAB(R11),R0	;SET ADDRESS OF OUTPUT FILE RAB
20$:	DISABLE				;DISABLE CONTROL Y/C AST'S
	MOVW	R1,RAB$W_RSZ(R0)	;SET SIZE OF OUTPUT RECORD
	MOVL	R2,RAB$L_RBF(R0)	;SET ADDRESS OF OUTPUT RECORD
	$PUT	RAB=(R0)		;OUTPUT RECORD
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BBC	#WRK_V_COMMAND,WRK_W_FLAGS(R10),30$ ;IF CLR, NO COMMAND EXECUTION
	BSBW	DCL$CHECK_AST		;CHECK FOR PENDING AST
30$:	RSB				;

 
	.SBTTL	SET FLUSH RATE COMMAND
;+
; DCL$SETFLUSH - FLUSH OUTPUT FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO SET THE OUTPUT BUFFER
; FLUSH RATE.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE FLUSH RATE IS SET.
;-
DCL$SETFLUSH::					;
	STATUS	NORMAL				; ASSUME SUCCESS
	BBC	#PRC_V_MODE,-			; IGNORE IF INTERACTIVE PROCESS
		PRC_W_FLAGS(R11),30$		;
	BSBW	DCL$GETDVAL			; SKIP PAST OPTION KEYWORD
	BSBW	DCL$GETDVAL			; WAS A VALUE SPECIFIED?
	CMPL	R5,#PTR_K_ENDLINE		; NO, THEN SIMPLY FORCE A FLUSH NOW	
	BEQL	20$				;
	MOVQ	R1,-(SP)			; BUILD DESCRIPTOR FOR DELTA TIME STRING
	MOVL	SP,R3				; SAVE ADDRESS OF QUAD WORD DECRIPTOR
	$BINTIM_S TIMBUF=(R3),-			; CONVERT TIME TO BINARY DELTA FORMAT
		TIMADR=(R3)			;
	BLBC	R0,30$				; BR IF ERROR IN TIME
	MOVQ	(SP)+,PRC_Q_FLUSHTIME(R11)	; SAVE THE FLUSH TIME INTERVAL
	BSBB	DCL$SET_TIMER			; SET THE TIMER
	BLBC	R0,30$				; BRANCH IF ERROR
20$:	CALLS	#0,FLUSH			; FLUSH THE OUTPUT BUFFER
30$:	RSB

	.SBTTL	SET THE FLUSH TIMER
;+
; DCL$SET_TIMER - SET THE FLUSH TIMER
;
; THIS ROUTINE SETS THE OUTPUT BUFFER FLUSH TIMER.
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = $SETIMR STATUS
;	THE TIMER IS SET.
;-

DCL$SET_TIMER::
	$CANTIM_S REQIDT=R11			;CANCEL PREVIOUS FLUSH TIMERS
	$SETIMR_S EFN=#EXE$C_SYSEFN,-		;SET TIMER FOR SPECIFIED TIME
		DAYTIM=PRC_Q_FLUSHTIME(R11),-	;
		ASTADR=FLUSH_AST,-		;
		REQIDT=R11			;
	RSB					;

	.SBTTL	FLUSH OUTPUT FILE
;+
; FLUSH_AST - FLUSH OUTPUT FILE
; FLUSH - FLUSH OUTPUT FILE
;
; THIS ROUTINE IS CALLED TO FLUSH THE OUTPUT FILE.
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;-
	.ENABLE	LSB
 
FLUSH_AST:					;FLUSH OUTPUT
	.WORD	^M<R2,R3,R4,R5,R6,R11>			;
	MOVL	4(AP),R11			;GET ADDRESS OF PRC DATA STRUCTURE
	MOVL	#1,R6				;RESET THE TIMER
	BRB	10$				;

FLUSH:	.WORD	^M<R2,R3,R4,R5,R6,R11>			;FLUSH OUTPUT
	CLRL	R6				;DO NOT RESET THE TIMER
;
; INITIALIZE TEMPORARY RAB
;
10$:	MOVAB	-RAB$C_BLN(SP),SP		;ALLOCATE A RAB ON STACK
	MOVC5	#0,(SP),#0,#RAB$C_BLN,(SP)	;ZERO THE RAB(R1 NOW CONTAINS 
						;      ADDRESS OF RAB
	ASSUME	RAB$B_BID EQ 0
	ASSUME	RAB$B_BLN EQ RAB$B_BID+1

	MOVW	#<RAB$C_BID+<RAB$C_BLN@8>>,(R1)  ;FILL IN BID AND BLN

	MOVL	PRC_L_INDOUTRAB(R11),R0		;GET ADDRESS OF INDIRECT OUTPUT RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;BR IF NOT IN CONTROL Y
	MOVL	PRC_L_OUTRAB(R11),R0		;SET ADDRESS OF OUTPUT FILE RAB
20$:	MOVW	RAB$W_ISI(R0),-			;COPY PPF ISI TO TEMP. RAB
		RAB$W_ISI(R1)
	$FLUSH	RAB=(R1)			;OUTPUT RECORD
	BLBC	R6,30$				;BRANCH IF NOT RESETING TIMER
	BSBW	DCL$SET_TIMER			;RESET THE TIMER
30$:	MOVL	#1,R0				;SET SUCCESSFUL STATUS
	RET					;

	.DISABLE LSB
 
	.END
