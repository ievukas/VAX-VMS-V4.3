	.NLIST	CND
	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	.TITLE	INIADP780 - ADAPTER INITIALIZATION FOR VAX 11/780
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	.TITLE	INIADP750 - ADAPTER INITIALIZATION FOR VAX 11/750
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	.TITLE	INIADP730 - ADAPTER INITIALIZATION FOR VAX 11/730
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	.TITLE	INIADP790 - ADAPTER INITIALIZATION FOR VAX 11/790
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	.TITLE	INIADPUV1 - ADAPTER INITIALIZATION FOR MICRO-VAX I
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS
	.TITLE	INIADP8SS - ADAPTER INITIALIZATION FOR VAX 11/8SS (SCORPIO)
	.ENDC

	.IDENT	'V04-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Facility: System bootstrapping and initialization
;
; Abstract: This module contains initialization routines that are loaded
;	     during system initialization (rather than linked into the system).
;
; Environment: Mode = KERNEL, Executing on INTERRUPT stack, IPL=31
;
; Author:  Trudy C. Matthews		Creation date: 22-Jan-1981
;
; Modification history:
;
;	V04-002	TCM0013		Trudy C. Matthews	10-Sep-1984
;		Add $BQODEF missing from TCM0012.
;
;	V04-001	TCM0012		Trudy C. Matthews	07-Sep-1984
;		For venus processor:  turn on cache before calibrating
;		TIMEDWAIT cells (routine EXE$INI_TIMWAIT).  Store the TIMEDWAIT
;		values calculated after cache is enabled in the boot driver's
;		TIMEDWAIT cells.  This is because the boot driver initially
;		has to run with cache off, but after booting will run with
;		cache on.
;
;	V03-024	TCM0011		Trudy C. Matthews	31-Jul-1984
;		Change venus's CRD interrupt vector back to ^X54 in the SCB,
;		and its SBIA Fail vector to ^X64.
;
;	V03-023	WMC0001		Wayne Cardoza		30-Jul-1984
;		Add H memory to 780 list.
;
;	V03-022	TCM0010		Trudy C. Matthews	25-Jul-1984
;		Fix a bug in INI$UBSPACE for the 11/790 that caused second
;		and subsequent unibus adapter spaces to be mapped incorrectly.
;		Fix bugs in INI$SCB for the 11/790.  Fix conditional
;		assembly flags in INI$CONSOLE for the 11/790.
;
;	V03-021	KDM0100		Kathleen D. Morse	01-May-1984
;		Correct address of memory CSRs to be past the 8 missing
;		Qbus adapter pages that do not exist.
;
;	V03-020	KDM0099		Kathleen D. Morse	27-Apr-1984
;		On a MicroVAX I, if the sysgen parameter TIMEDWAIT is set
;		to request no time-prompting, then use the last recorded
;		system time instead.  This is found in EXE$GQ_TODCBASE
;		which can be updated with a SET TIME command.
;
;	V03-019	RLRSCORPIO	Robert L. Rappaport	16-Mar-1984
;		Begin additions (to INI$IOMAP) for Scorpio support.  
;		Also move ADAPDESC to SYSMAR.MAR, changing it to remove
;		the ADAP_GENERAL array.
;
;	V03-018	RLRINIADP	Robert Rappaport	28-Feb-1984
;		Add refinements to previous update that introduces
;		lonqword array CONFREG.  Mainly add logic to allow for
;		independently assembled invocations of ADAPDESC macro
;		to be linked into this code.  This provides possible
;		support of BI as a public bus, with user defined nodes.
;
;	V03-017	KPL0100		Peter Lieberwirth	30-Jan-1984
;		Implement first step towards a longword-array CONFREG to
;		replace current byte array CONFREG.  INIADP will construct
;		two confregs, CONFREG and CONFREGL.  CONFREGL will be
;		a longword array.  The high byte will be a VMS-bus
;		designation, and the low word will contain the 16-bit
;		device type.  The BI introduces 16 bit device types.
;
;		When all references to CONFREG have been modified to touch
;		CONFREGL, INIADP will be modified again to stop creating
;		the byte array.
;
;		While here, map 9 pages of CI register space, up from 8.
;
;	V03-016	KPL0001		Peter Lieberwirth	17-Jan-1984
;		Fix bug in V03-015 that caused a failure to boot on 750s.
;		Specifically, add NDT$_MEM1664NI to ADAPDESC macro.
;
;	V03-015	TCM0009		Trudy C. Matthews	12-Dec-1983
;		Add support for booting from VENUS console device to
;		INI$CONSOLE.  When mapping I/O space on VENUS, use the
;		PAMM to determine if any adaptors are present on the
;		ABUS.
;
;	V03-014	KDM0081		Kathleen D. Morse	13-Sep-1983
;		Create version for Micro-VAX I.
;
;	V03-013	DWT0126		David W. Thiel		30-Aug-1983
;		Modify EXE$INIT_TODR to set internal time without
;		modifying the contents of the system disk.
;
;	V03-012	KDM0062		Kathleen D. Morse	18-Jul-1983
;		Add loadable, cpu-dependent routine for initializing
;		the time-wait loop data cells, EXE$INI_TIMWAIT.
;
;	V03-011	KDM0057		Kathleen D. Morse	15-Jul-1983
;		Added loadable, cpu-dependent routine for initializing
;		the system time, EXE$INIT_TODR.
;
;	V03-010	KTA3071		Kerbey T. Altmann	12-Jul-1983
;		Include CPU-specific console init code.
;
;	V03-009	TCM0008		Trudy C. Matthews	10-Jan-1983
;		Change PSECT of 11/790 data that must stick around after
;		INIADP is deleted.  Build arrays ABUS_VA, ABUS_TYPE, and
;		ABUS_INDEX that describe the 11/790 ABUS configuration.
;
;	V03-008 MSH0002		Maryann Hinden		08-Dec-1982
;		Add powerfail support for DW750.
;
;	V03-007	ROW0142		Ralph O. Weber		24-NOV-1982
;		Change UBA interrupt services routines prototype so that 
;		UBAERRADR is correctly computed as an offset from UBAINTBASE.
;
;	V03-006	TCM0007		Trudy C. Matthews	10-Nov-1982
;		Add 11/790-specific initialization of SCB.
;
;	V03-005	TCM0006		Trudy C. Matthews	8-Nov-1982
;		Initialize field ADP$L_AVECTOR with the address of
;		each adapter's first SCB vector.
;
;	V03-004	KTA3018		Kerbey T. Altmann	30-Oct-1982
;		Move from INILOA facility, rename from INITADP,
;		put in conditional assembly, rewrite some routines.
;
;	V03-003 MSH0001		Maryann Hinden		24-Sep-1982
;		Change EXE$DW780_INT to EXE$UBAERR_INT.
;
;	V03-002	TCM0005		Trudy C. Matthews	10-Aug-1982
;		Added support for 11/790 processor.
;
;	V03-001	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DCDEF.
;
;--

;
; MACRO LIBRARY CALLS
;
	$ADPDEF				; Define ADP offsets.
	$BIICDEF			; Define BIIC offsets.
	$BQODEF				; Define boot vector offsets.
	$BTDDEF				; Define boot devices
	$BUADEF				; Define BUA Register offsets.
	$CRBDEF				; Define CRB offsets.
	$DCDEF				; Define adapter types
	$DDBDEF				; Define DDB offsets
	$DYNDEF				; Define data structure type codes.
	$IDBDEF				; Define interrupt dispatcher offsets.
	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	$IO750DEF			; Define 11/750 I/O space.
	$UASDEF				; Define DW750 IPEC registers.
	.ENDC
	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	$IO780DEF			; Define 11/780 I/O space.
	.ENDC
	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	$IO730DEF			; Define 11/730 I/O space.
	.ENDC
	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	$IO790DEF			; Define 11/790 I/O space.
	$PAMMDEF			; Define PAMM register fields.
	$SBIADEF			; Define SBI adapter register space.
	.ENDC
	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	$IOUV1DEF			; Define Micro-VAX I I/O space.
	.ENDC
	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS
	$IO8SSDEF			; Define 11/8SS I/O space.
	$KDZDEF				; Define KDZ module node private space
	.ENDC
	$MCHKDEF			; Define machine check masks.
	$NDTDEF				; Define nexus device types.
	$PRDEF				; Define IPR numbers.

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	$PR780DEF			; Define 11/780 specific IPR numbers.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	$PR750DEF			; Define 11/750 specific IPR numbers.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	$PR730DEF			; Define 11/730 specific IPR numbers.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	$PR790DEF			; Define 11/790 specific IPR numbers.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	$PRUV1DEF			; Define Micro-VAX I specific IPRs.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS
	$PR8SSDEF			; Define 11/8SS specific IPRs.
	.ENDC

	$PTEDEF				; Define Page Table Entry bits.
	$RPBDEF				; Define Restart Parameter Block fields.
	$UBADEF				; Define UBA register offsets.
	$UCBDEF				; Define UCB offsets.
	$VADEF				; Define virtual address fields.
	$VECDEF				; Define vec offsets.

	.SBTTL	Macros to describe nexus configurations
;
;	The macros FLOAT_NEXUS and FIXED_NEXUS add one or more entries to a
;	nexus descriptor table.  Each entry is of the form:
;		+-------------------------------+
;		|   PFN of nexus I/O space	|
;		+-------+-------+---------------+
;		|  bus  |   0   |     type	|
;		+-------+-------+---------------+
;	type = 0 -> floating nexus
;	type = non-zero -> fixed nexus; type = fixed adapter type
;	bus  = 0, if SBI; %x80 if BI  (this is a VMS-only designation)
;
;
;	device_type:	SBI adapters have 8-bit device type codes.  These
;			device types are simple integers.
;
;			BI adapters have 16-bit device type codes, that are
;			subject to the following interpretation:
;
;			- the MSB of the device-type field will be 0 for DEC
;			devices and 1 for non-DEC devices,
;
;			- DEC memory devices will have 0s in the high-order
;			byte of the device type,
;
;			- non-DEC supplied memory devices will have a 1 in the
;			MSB of the high-order byte, and the rest of the high
;			order byte will contain 0s.
;
;			- The "all 0s" and "all 1s" device-type codes are
;			reserved for DEC.
;
; If SBI type codes were simply expanded to a word for purposes of the routines
; in this module, there would be possible conflicts between SBI devices and
; BI memory adapters supplied by DEC.  Voila:  the bus type.
;
; Macro FLOAT_NEXUS.
; INPUTS:
;	PHYSADR -- physical address of 1 or more contiguous floating nexus
;		   slots
;	NUMNEX -- number of contiguous floating nexuses, default = 1
;	PERNEX -- amount of address space per nexus (does not have to be
;		  specified if NUMNEX = 1)
;
	.MACRO	FLOAT_NEXUS	PHYSADR,NUMNEX=1,PERNEX=0
	PA = PHYSADR
	.REPEAT	NUMNEX		; For each nexus...
	.LONG	<PA/^X200>	; Store PFN.
	.LONG	0		; Store floating nexus type.
	PA = PA + PERNEX	; Increment to physical address of next nexus.
	.ENDR
	.ENDM	FLOAT_NEXUS

;
; Macro FIXED_NEXUS.
;
; INPUTS:
;	PHYSADR - physical address of 1 or more contiguous fixed nexus slots
;	PERNEX - amount of address space per nexus
;	NEXUSTYPES - a list of fixed nexus types, enclosed in <>
;
	.MACRO	FIXED_NEXUS	PHYSADR,PERNEX=0,NEXUSTYPES
	PA = PHYSADR
	.IRP	TYPECODE,NEXUSTYPES	; For each fixed nexus type...
	.LONG	<PA/^X200>		; Store PFN.
	.LONG	TYPECODE		; Store fixed nexus type.
	PA = PA + PERNEX		; Increment to address of next nexus.
	.ENDR
	.ENDM	FIXED_NEXUS

;
; Macro NEXUSDESC_TABLE - declare the beginning of a NEXUS descriptor table
;
;	1st byte in table (at offset -5 from label) contains length of
;	adapter type code field in CSR's on this bus. [Note for SBI like
;	busses, this is 1.]  The next longword (at offset -4) in the
;	table contains the Software defined bus type byte defined in the
;	high order byte of the longword.  [Note for SBI like busses, this
;	value is 0, for the BI it is ^x80.]
;

; Define parameters that may be specified or used in macro invocation.

BI_LIKE  = 0			; BI like bus.
SBI_LIKE = 1			; SBI like bus.

SBI_CSR_LEN = 1			; Length of type code field in adapter CSR's
				;  on SBI, CMI, etc.
BI_CSR_LEN  = 2			; Length of type code field in adapter CSR's
				;  on BI.

SBI_BUS_CODE = 0		; Software defined bus code for SBI like busses.
BI_BUS_CODE  = ^x80000000	; Software defined bus code for the BI.

	.MACRO	NEXUSDESC_TABLE LABEL,BUS_TYPE=SBI_LIKE
	.IF	EQ,BUS_TYPE-SBI_LIKE
				.BYTE	SBI_CSR_LEN
				.LONG	SBI_BUS_CODE
	.IFF
		.IF	EQ,BUS_TYPE-BI_LIKE
				.BYTE	BI_CSR_LEN
				.LONG	BI_BUS_CODE
		.IFF
				.ERROR	; UNRECOGNIZED BUS TYPE, NEXUSDESC_TABLE;
		.ENDC
	.ENDC

LABEL:
	.ENDM	NEXUSDESC_TABLE

CSR_LEN_OFFSET  = -5			; Offset before nexus descriptor of
					;  byte containing length of adapter
					;  type field in adapter CSR.
BUS_CODE_OFFSET = -4			; Offset before nexus descriptor table
					;  of longword containing software
					;  defined bus type to be or'ed with
					;  adapter type to produce NDT$_ value.
;
; Macro END_NEXUSDESC.
;
	.MACRO	END_NEXUSDESC
	.LONG	0			; PFN=0 -> end of nexus descriptors.
	.ENDM	END_NEXUSDESC

	.SBTTL	Adapter-specific data structures
;
; Put a symbol for arrays built by macros in the correct psects.
;
;***************** ADAPTERS array *************
	.PSECT	$$$INIT$DATA0
ADAPTERS:				; Build adapter type code arrays here.

	.PSECT	$$$INIT$DATA1		; User contributions in this .PSECT.
					; End of ADAPTERS array.
;***************** End of ADAPTERS array *************

;***************** NUM_PAGES array *************
	.PSECT	$$$INIT$DATA2
NUM_PAGES:				; Build "number of pages to map" array.
	.PSECT	$$$INIT$DATA3		; User contributions in this .PSECT.
;***************** End of NUM_PAGESarray *************

;***************** INIT_ROUTINES array *************
	.PSECT	$$$INIT$DATA4
INIT_ROUTINES:				; Build "address of init routine" array.
	.PSECT	$$$INIT$DATA5		; User contributions in this .PSECT.
;***************** End of INIT_ROUTINES array *************

;
; To add a new adapter type:
;	1) Add a new ADAPDESC macro invocation to the end of this list.
;
	.PSECT	$$$INIT$DATA,LONG

;
; Default interupt vectors for UNIBUS system devices
; (This array is indexed by the RPB field RPB$B_DEVTYP, if the RPB field
; RPB$W_R0UBVEC is zero.  If RPB$W_R0UBVEC is not zero, then RPB$W_R0UBVEC
; is used and this array is not referenced at all.  RPB$W_R0UBVEC is set up
; by PQDRIVER.  RPB$L_BOOTR0 is set by VMB to contain the device name in 
; ASCII, not the vector number and device type, as it does on full 
; architecture VAX machines.
;
BOOTVECTOR:
	.WORD	^X88		; RK06/7 Interrupt vector
	.WORD	^X70		; RL01/2 Interrupt vector

BUS_CSR_LEN:			; Static byte containing the length (in bytes)
	.BYTE	0		;  of the adapter type field in the CSR's of
				;  the bus currently being configured.  The
				;  proper value for the bus of interest is
				;  copied here, from the current nexus
				;  descriptor table, when we enter subroutine
				;  CONFIG_IOSPACE.

SW_BUS_CODE:			; Static longword containing the software
	.LONG	0		;  defined bus type, of the bus currently being
				;  configured, in the high order byte.  The
				;  proper value for the bus of current interest
				;  is copied here, from the nexus descriptor
				;  table, when we enter subroutine
				;  CONFIG_IOSPACE.

DIRECT_VEC_NODE_CNT:		; Static longword that counts the number of
				;  direct vectoring adpater nodes that we have
	.LONG	0		;  run across so far.

$$$VMSDEFINED = 1		; Define symbol that means VMS system software.
NUMUBAVEC = 128			; ALLOW FOR 128 UNIBUS VECTORS

	ADAPDESC -		; Memory. ** MUST BE 1ST IN DESCRIPTOR LIST **
	ADPTYPES=<NDT$_MEM1664NI,NDT$_MEM4NI,NDT$_MEM4I,NDT$_MEM16NI, -
		NDT$_MEM16I, -
		NDT$_MEM64NIL,NDT$_MEM64EIL,NDT$_MEM64NIU,NDT$_MEM64EIU,  -
		NDT$_MEM64I, -
		NDT$_MEM256NIL,NDT$_MEM256EIL,NDT$_MEM256NIU,NDT$_MEM256EIU,  -
		NDT$_MEM256I, -
		NDT$_SCORMEM> -
		NUMPAGES=1

	ADAPDESC -		; MASSbus.
		ADPTYPES=NDT$_MB, -
		NUMPAGES=8, -
		INITRTN=INI$MBADP

	ADAPDESC -		; UNIbus.
		ADPTYPES=<NDT$_UB0,NDT$_UB1,NDT$_UB2,NDT$_UB3,NDT$_BUA>, -
		NUMPAGES=8, -
		INITRTN=INI$UBSPACE

	ADAPDESC -		; Multi-port memory.
		ADPTYPES=<NDT$_MPM0,NDT$_MPM1,NDT$_MPM2,NDT$_MPM3>, -
		NUMPAGES=1, -
		INITRTN=INI$MPMADP

	ADAPDESC -		; DR32.
		ADPTYPES=NDT$_DR32, -
		NUMPAGES=4, -
		INITRTN=INI$DRADP

	ADAPDESC -		; CI780
		ADPTYPES=NDT$_CI, -
		NUMPAGES=9, -
		INITRTN=INI$CIADP

	ADAPDESC -		; KDZ11 Processor
		ADPTYPES=NDT$_KDZ11, -
		NUMPAGES=1, -
		INITRTN=INI$KDZ11

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	.PAGE
;
; TABLES OF ADAPTER-DEPENDENT INFORMATION
;
; THE TABLE OFFSETS ARE:
;
	$DEFINI	ADPTAB

ADPTAB_IDBUNITS:.BLKB	1		; # UNITS TO SET IN IDB
ADPTAB_ADPLEN:	.BLKW	1		; LENGTH OF ADP
ADPTAB_ATYPE:	.BLKB	1		; ADP TYPE

	$DEFEND	ADPTAB

;
; TABLES THEMSELVES:
;

MBATAB:					; TABLE OF MBA CONSTANTS
	.BYTE	8			; # UNITS IN MBA IDB
	.WORD	ADP$C_MBAADPLEN		; # BYTES IN MBA ADP
	.BYTE	AT$_MBA			; MBA ADAPTER TYPE

DRTAB:					; TABLE OF DR32 CONSTANTS
	.BYTE	1			; # UNITS IN DR IDB
	.WORD	ADP$C_DRADPLEN		; # BYTES IN DR ADP
	.BYTE	AT$_DR			; DR ADAPTER TYPE

CITAB:					; TABLE OF CI CONSTANTS
	.BYTE	1			; # UNITS IN CI IDB
	.WORD	ADP$C_CIADPLEN		; # BYTES IN CI ADP
	.BYTE	AT$_CI			; CI ADAPTER TYPE

	.ENDC				;END UV1 CONDITIONAL
	.ENDC				;END 730 CONDITIONAL

	.SBTTL	CPU-specific data structures
;
; To add a new CPU type:
;	1) Create a new nexus descriptor table, using FLOAT_NEXUS and
;	   FIXED_NEXUS macros.  Put an END_NEXUSDESC macro at the end.
;

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780

CPU_ADPSIZE:
	.WORD	ADP$C_UBAADPLEN+UBINTSZ+<NUMUBAVEC*4>


;
; Declare the beginning of a nexus-descriptor table.
;
	NEXUSDESC_TABLE LABEL=NEXUSDESC

;
; Describe all possible nexuses on an 11/780.
;
	SBI_CPU = 1
	BI_CPU  = 0
	FLOAT_NEXUS -
		PHYSADR=IO780$AL_IOBASE, -
		NUMNEX=IO780$AL_NNEX, -
		PERNEX=IO780$AL_PERNEX
	END_NEXUSDESC
	.ENDC					;END 780 CONDITIONAL

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750

CPU_ADPSIZE:
	.WORD	ADP$C_UBAADPLEN


;
; Declare the beginning of a nexus-descriptor table.
;
	NEXUSDESC_TABLE LABEL=NEXUSDESC


;
; Describe all possible nexuses on an 11/750 (the first 10 have fixed adapter
; assignments).
;
	SBI_CPU = 0
	BI_CPU  = 0
	FIXED_NEXUS -
		PHYSADR=IO750$AL_IOBASE, -
		PERNEX=IO750$AL_PERNEX, -
		NEXUSTYPES=<NDT$_MEM1664NI, -
			    NDT$_MPM0, -
			    NDT$_MPM1, -
			    NDT$_MPM2, -
			    NDT$_MB, -
			    NDT$_MB, -
			    NDT$_MB, -
			    NDT$_MB, -
			    NDT$_UB0, -
			    NDT$_UB1>
	FLOAT_NEXUS -
		PHYSADR=IO750$AL_IOBASE+<10*IO750$AL_PERNEX>, -
		NUMNEX=6, -
		PERNEX=IO750$AL_PERNEX
	END_NEXUSDESC
	.ENDC					;END 750 CONDITIONAL

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730

CPU_ADPSIZE:
	.WORD	ADP$C_UBAADPLEN


;
; Declare the beginning of a nexus-descriptor table.
;
	NEXUSDESC_TABLE LABEL=NEXUSDESC


;
; Describe all nexuses on an 11/730 processor.
;
	SBI_CPU = 0
	BI_CPU  = 0
	FIXED_NEXUS -
		PHYSADR=IO730$AL_IOBASE, -
		NEXUSTYPES=NDT$_MEM64NIL
	FLOAT_NEXUS -
		PHYSADR=IO730$AL_IOBASE+<1*IO730$AL_PERNEX>, -
		NUMNEX=15, -
		PERNEX=IO730$AL_PERNEX
	END_NEXUSDESC
	.ENDC					;END 730 CONDITIONAL

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790

CPU_ADPSIZE:
	.WORD	ADP$C_UBAADPLEN+UBINTSZ+<NUMUBAVEC*4>


;
; Declare the beginning of a nexus-descriptor table.
;
	NEXUSDESC_TABLE LABEL=NEXUSDESC


;
; Describe all nexuses on an 11/790 processor.
;
	SBI_CPU = 1
	BI_CPU  = 0
	FLOAT_NEXUS -
		PHYSADR=IO790$AL_IOA0, -
		NUMNEX=IO790$AL_NNEX, -
		PERNEX=IO790$AL_PERNEX
	END_NEXUSDESC

;
; The following 11/790 data must remain in pool after INIADP is deallocated.
;
	.SAVE
	.PSECT	SYSLOA,LONG
;
; These arrays describe the adapters on the 11/790's ABUS.
;
ABUS_VA::				; Virtual address of ABUS adapter space.
	.LONG	0[4]
ABUS_TYPE::
	.BYTE	0[4]			; Type code of ABUS adapter.
ABUS_INDEX::
	.BYTE	0[4]			; If this ABUS adapter is an SBIA, index
					; into EXE$GL_CONFREGL and MMG$GL_SBICONF
					; where this SBI's nexus slots start.
	.RESTORE
	.ENDC				;END 790 CONDITIONAL


	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
CPU_ADPSIZE:
	.WORD	ADP$C_UBAADPLEN


;
; Declare the beginning of a nexus-descriptor table.
;
	NEXUSDESC_TABLE LABEL=NEXUSDESC


;
; Describe all nexuses on a Micro-VAX I processor.
;
	SBI_CPU = 0
	BI_CPU  = 0
	FIXED_NEXUS -
		PHYSADR=IOUV1$AL_QB0SP, -
		NEXUSTYPES=NDT$_UB0
	END_NEXUSDESC
	.ENDC				;END UV1 CONDITIONAL

	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS

CPU_ADPSIZE:
	.WORD	ADP$C_UBAADPLEN


;
; Declare the beginning of a nexus-descriptor table.
;
	NEXUSDESC_TABLE LABEL=NEXUSDESC


;
; Describe all nexuses on an 11/8SS processor.
;
	SBI_CPU = 0
	BI_CPU  = 1
	FLOAT_NEXUS -
		PHYSADR=IO8SS$AL_IOBASE, -
		NUMNEX=IO8SS$AL_NNEX, -
		PERNEX=IO8SS$AL_PERNEX
	END_NEXUSDESC
	.ENDC					;END 8SS CONDITIONAL

;
; Nexus "descriptor" arrays -- these arrays hold the nexus-device type and
; virtual address of every adapter on the system.  The arrays, CONFREGL and
; SBICONF, are allocated enough space to hold the maximum number of adapters
; that can be attached to any CPU.  When the code discovers how many adapters
; actually exist on the system, it will allocate space from non-paged pool
; and move a permanent copy of these arrays into that space.
;
MAXNEXUS = 64
CONFREG:				; Byte array of nexus-device type codes..
	.BLKB	MAXNEXUS
SBICONF:
	.BLKL	MAXNEXUS		; Longword array of VAs of adapter space.
CONFREGL:
	.BLKL	MAXNEXUS		; Longword array of nexus-device type codes

	.SBTTL	Message strings

CR = 13
LF = 10
NOSPT:
	.ASCIZ	<CR><LF>/%EXECINIT-F-Insufficient SPT entries/<CR><LF>
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
BADUMR:
	.ASCIZ	<CR><LF>/%EXECINIT-F-UNIBUS memory does not start at 0/<CR><LF>
	.ENDC				;END UV1 CONDITIONAL

	.SBTTL	INI$IOMAP, Initialize and map nexuses
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed only once, during system initialization.
;	It loops through all nexuses on the system, testing for
;	adapters.  When it finds an adapter, it maps its I/O space and
;	initializes it.
;
; INPUTS:
;	BOO$GL_SPTFREL	- next free VPN
;	MMG$GL_SPTVASE	- base of system page table
;	EXE$GL_RPB	- address of reboot parameter block
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
;	RPB$L_ADPPHY(RPB) - PFN of boot adapter space
	.ENDC
;
; OUTPUTS:
;	R0 - SS$_NORMAL
;
;	For each adapter found, its accessible I/O space is mapped to virtual
;	addresses.  An ADP (Adapter Control Block) is built, and the hardware
;	adapter is initialized.
;
;	The arrays CONFREG (a byte array of nexus-device type codes, defined
;	by NDT$_ symbols) and SBICONF (a longword array of
;	virtual addresses that map adapter space) are initialized.  Pointers
;	to these arrays are stored in EXE$GL_CONFREG  and
;	MMG$GL_SBICONF.  The number of entries in these two parallel arrays is
;	stored in EXE$GL_NUMNEXUS.
;
;	Since BI devices have a 16-bit device type code, a new CONFREG array is
;	constructed.  This is a longword array called CONFREGL.
;
;	Several locations in the RPB that describe the boot device are init'ed:
;	RPB$L_BOOTR1	- holds index into CONFREG and SBICONF for the boot
;			  adapter
;	RPB$L_ADPVIR	- holds VA of boot device adapter's register space
;	RPB$L_CSRVIR	- holds VA of boot device's register space
;--

	.PSECT	$$$INIT$CODE,QUAD
INI$IOMAP::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; Set up common inputs to CONFIG_IOSPACE subroutine for the CPU-specific code.
;
	MOVL	G^BOO$GL_SPTFREL,R2	; Get next available VPN.
	MOVL	G^MMG$GL_SPTBASE,R3	; Get base of System Page Table.
	MOVAL	(R3)[R2],R3		; Compute SVASPT.
	ASHL	#9,R2,R2		; Convert VPN to VA.
	BISL	#VA$M_SYSTEM,R2		; Set system bit.
	CLRL	R4			; Clear index into CONFREG and SBICONF.
	MOVL	G^EXE$GL_RPB,R9		; Get address of RPB.
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	ASHL	#-9,RPB$L_ADPPHY(R9),R10; Get PFN of boot adapter space.
	.ENDC
	MOVAL	W^SBICONF,G^MMG$GL_SBICONF  ; Set pointers to local copies
	MOVAL	W^CONFREG,G^EXE$GL_CONFREG  ; of these arrays for init routines.
	MOVAL	W^CONFREGL,G^EXE$GL_CONFREGL ; ...

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	.SBTTL	INITADP_790
;++
; Configure VENUS I/O Address Space.
;
; ABUS Physical Address Space:
;
;	VENUS's internal I/O bus, or ABUS, has 4 slots on it.	ABUS adapters
; occupy the following ranges of I/O address space:
;
;	ABUS slot	    Physical address range
;	---------	    ----------------------
;	    0		2000 0000  through  21FF FFFF
;	    1		2200 0000  through  23FF FFFF
;	    2		2400 0000  through  25FF FFFF
;	    3		2600 0000  through  27FF FFFF
;
;	
;	For each adapter attached to the ABUS, some adapter register space
; is defined (addresses 2x08 0000 through 2x08 007F).  The first 12 (decimal)
; longwords of the ABUS adapter register space are generically defined for all
; types of ABUS adapters; the remaining register address space is ABUS
; adapter-specific.  The first generic register is the configuration register.
; The low byte of the configuration register identifies the type of ABUS
; adapter, and its revision level.
;
;	Currently, only one adapter is supported on the ABUS: the SBIA, or
; SBI/ABUS adapter.  This adapter allows a standard 780 SBI to be attached to
; VENUS's ABUS, and allows VENUS to support all standard 780 adapters and
; peripherals.
;
;	Search the ABUS slots for SBIA adapters, and configure SBI I/O space
; and SBIA register space for any that are found.
;
;--
	ASSUME	SBIA$L_CR EQ 0		; Assume configuration register is first
					; register in SBIA register space.
	MOVL	#<<IO790$AL_IOA0+ -
		 IO790$AL_IOACR>/^X200>,R8	; Calculate PFN
					; of first ABUS configuration register.
	CLRL	R11			; Index into ABUS slots.

ABUS_LOOP:
	ASHL	#9,R8,R1		; Get physical address back from PFN.
	BICL	#^C<PAMM$M_PAMADD>,R1	; Only want bits 29:20 of physical addr.
	MTPR	R1,#PR790$_PAMLOC	; Request PAMM code for this address.
	MFPR	#PR790$_PAMACC,R1	; Read PAMM location.
	EXTZV	#PAMM$V_CODE,#PAMM$S_CODE, -	; Extract PAMM code.
		R1,R1
	CMPB	R1,#PAMM$C_NEXM		; Is an ABUS adapter present?
	BEQL	END_ABUS_LOOP		; Nothing at this ABUS slot.
	BISL3	#PTE$M_VALID!PTE$C_KW,-	; Temporarily associate VA in R2 with
		R8,(R3)			; PFN in R8 via SPTE in R3.
	$PRTCTINI	B^10$ -		; Protect against non-existent memory
		#<MCHK$M_NEXM!MCHK$M_LOG>	; machine checks.
	MOVL	(R2),R1			; Read ABUS configuration register.
	$PRTCTEND	10$		; End of protected code.
	INVALID	R2			; Clear TB of temporary mapping.
	BLBC	R0,END_ABUS_LOOP	; Nothing at this ABUS slot.
;
; Found an adapter.  See if its an SBIA.
;
	EXTZV	#SBIA$V_TYPE,#SBIA$S_TYPE,R1,R1	; Get type field in config reg.
	MOVB	R1,W^ABUS_TYPE[R11]	; Save in ABUS type array.
	CMPB	#IO790$C_SBIA,R1	; Is this an SBIA?
	BNEQ	END_ABUS_LOOP		; Nope, go to next slot.
;
; Found an SBIA.
; Fill in the 790 nexus descriptor table with the physical addresses
; corresponding to this ABUS slot.
;
	TSTL	R11			; If this is the first ABUS slot,
	BEQL	CONFIG_790		; table is already set up properly.
	MOVL	#IO790$AL_NNEX,R1	; Get number of nexues on this SBI.
	SUBL3	#IO790$AL_IOACR/^X200,-	; Get PFN of SBI nexus space for
		R8,R0			; this ABUS slot.
	MOVAL	W^NEXUSDESC,R6		; Get address of 790 nexus table.
20$:
	MOVL	R0,(R6)+		; Put PFN in table.
	ADDL2	#4,R6			; Step past fixed/floating type code.
	ADDL	#IO790$AL_PERNEX/^X200,R0   ; PFN of next nexus on this SBI.
	SOBGTR	R1,20$			; Fill in entire table.
;
; Fill in 11/790-specific SCB slots and map SBIA register space, then
; call CONFIG_IOSPACE as a subroutine, to configure this SBI.
;
CONFIG_790:
	MOVL	R2,W^ABUS_VA[R11]	; Save VA of SBIA register space.
	PUSHL	R8			; Save PFN of SBIA register space.
	MOVL	#1,R1			; Number of pages to map.
	BSBW	MAP_PAGES		; Map SBIA register space.
	BSBW	INI$SCB			; Fill in 790-specific SCB vectors.
	MOVAL	W^NEXUSDESC,R6		; Address of 790 nexus descriptor table.
	MOVB	R4,W^ABUS_INDEX[R11]	; Save index into CONFREG and SBICONF.
	BSBB	CONFIG_IOSPACE		; Configure this SBI.
	POPR	#^M<R8>			; Restore PFN of SBIA register space.


END_ABUS_LOOP:
	ADDL	#IO790$AL_PERABS/^X200,R8 ; R8 <- PFN of next ABUS adapter's
					; register space.
	ACBL	#3,#1,R11,ABUS_LOOP	; Branch if more ABUS slots.
	.IFF				;END OF 790 SPECIFIC CODE
	.PAGE
	.SBTTL	INITADP_780, _750, _730, and _UV1
;
; I/O address space for the 11/780, 11/750, 11/730, and Micro-VAX I cpus
; is statically defined in their respective nexus descriptor tables.
;
	MOVAL	W^NEXUSDESC,R6		; Get address of nexus table.
	CLRL	R11			; Signal use 1st page of SCB.
	BSBB	CONFIG_IOSPACE		; Configure processor I/O space.

	.IFTF				;CODE FOR ALL PROCESSORS

	BSBW	CREATE_ARRAYS		; Create CONFREG and SBICONF arrays.
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	#1,R0			; Set success status
	RSB				; Return.
	.ENDC				;END OF 790 CONDITIONAL

	.SBTTL	CONFIG_IOSPACE
;
; CONFIG_IOSPACE
;	Given a nexus descriptor table, which describes what "nexuses" or
;	"slots" are available on a system to hold I/O adapters, find and
;	initialize all adapters on the system.
;
; Inputs:
;	R2 - next available virtual address, to be used for mapping I/O space
;	R3 - address of PTE associated with VA in R2
;	R4 - Current index into CONFREG and SBICONF arrays (should be 0 the
;	     first time CONFIG_IOSPACE is called)
;	R6 - address of nexus descriptor table
;	R9 - address of Restart Parameter Block (RPB)
;	R10 - PFN of boot adapter space
;	R11- page offset from beginning of SCB; tells which page of the SCB
;	     to use for this set of nexuses (passed to routines that init ADP)
;
; Outputs:
;	R2,R3,R4 - updated
;	R9,R10,R11 - preserved; all other registers potentially modified
;	CONFREG - initialized with adapter NDT$ code for each nexus
;	SBICONF - initialized with adapter space VA for each nexus
;
CONFIG_IOSPACE:
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
;
; Main loop.  Map and initialize all adapters on system.
;
	.IFF				;IF CPU IS UV1
;
; There is only one adapter, the Qbus.
;
	.ENDC				;END "NOT" UV1 CONDITIONAL

	MOVB	CSR_LEN_OFFSET(R6),-	; Move length of adapter type field
		W^BUS_CSR_LEN		;  in CSR's to static location.
	MOVL	BUS_CODE_OFFSET(R6),-	; Move software defined bus type code
		W^SW_BUS_CODE		;  to static longword.

NXT_NEXUS:				; For each nexus...
	MOVL	(R6)+,R8		; Get PFN of nexus.
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	BNEQ	TEST_NEXUS		; If PFN non-zero, go test the slot.
	RSB				; If 0, we've found all nexuses.
;
; Read configuration register to determine if anything is present at this
; nexus.
;
TEST_NEXUS:
	BISL3	#PTE$M_VALID!PTE$C_KW,-	; Temporarily associate VA in R2 with
		R8,(R3)			; PFN in R8 via SPTE in R3.
	$PRTCTINI B^10$, -		; Protect following code from non-
		#<MCHK$M_NEXM!MCHK$M_LOG>; existent memory machine checks.
	MOVL	(R2),R1			; Read adapter configuration register.
	$PRTCTEND 10$			; End of protected code.
	INVALID	R2			; Clear TB of temporary mapping.
	BLBS	R0,GET_TYPE		; Branch if no machine check occurred.
;
; No adapter present at this nexus.
;
	CLRB	W^CONFREG[R4]		; Store "unknown" type in CONFREG
	CLRL	W^CONFREGL[R4]		; and in CONFREGL also.
	CLRL	R5			; Use general memory type to map
					; one page of I/O space.
	ADDL2	#4,R6			; Step past type code in nexus table.
	BRB	MAP_NEXUS		; Go map I/O space for this nexus.
	.ENDC				;END NOT "UV1" CONDITIONAL
;
; Execution continues here if adapter was present.
;
GET_TYPE:
	MOVL	(R6)+,R7		; Get nexus-device type from nexus table.
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	BNEQ	GET_GEN_TYPE		; Branch if fixed slot.
;
; Floating-type slot.  Use type from configuration register.
; Determine if type in configuration register is 8-bits or 16-bits.
;

	CMPB	#1,W^BUS_CSR_LEN	; Determine length of adapter type
					;  field in CSR contained in R7.
	BEQL	10$			; EQL implies 1 byte (8-bit) field.
	MOVZWL	R1,R7			; BI_LIKE, so use word instruction.
	BRB	20$			; Skip byte instruction.
10$:	MOVZBL	R1,R7			; Use byte instruction to get type.
20$:					;
	BISL	W^SW_BUS_CODE,R7	; Or in software bus code.
	.ENDC				;END NOT "UV1" CONDITIONAL
;
; Here R7 has hardware adapter code or'ed with software bus code.
; Translate specific nexus device type code into general adapter type code.
;
GET_GEN_TYPE:
	MOVB	R7,W^CONFREG[R4]	; Save nexus-device type in CONFREG.
	MOVL	R7,W^CONFREGL[R4]	; CONFREGL also filled in.
	CLRL	R5			; Clear loop index.
30$:					;
	MOVAL	W^ADAPTERS[R5],R0	; Get address of adapter type code.
	PUSHAB	W^NUM_PAGES		; Push addr of end of ADAPTERS array.
	CMPL	R0,(SP)+		; See if we went beyond array.
	BGEQU	END_NEXUS		; unrecognized adapter, do not map.
	CMPL	R7,(R0)			; Adapter type match?
	BEQL	40$			; If EQL yes, adapter type match.
	INCL	R5			; Increment loop index.
	BRB	30$			; Look at next adapter.
40$:

;
; Store boot parameters.
;
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	CMPL	R8,R10			; Does PFN match boot adapter's PFN?
	BNEQ	MAP_NEXUS		; No; continue.
	.ENDC				;END NOT "UV1" CONDITIONAL
	MOVL	R2,RPB$L_ADPVIR(R9)	; Store VA of boot adapter space.
	MOVL	R4,RPB$L_BOOTR1(R9)	; Store boot adapter nexus number.
	EXTZV	#0,#13, -		; Get offset into UNIBUS/QBUS I/O page.
		RPB$L_CSRPHY(R9),R1	; 
	MOVAB	<8*512>(R2)[R1], -	; Set VA of UNIBUS/QBUS registers.
		RPB$L_CSRVIR(R9)	;


;
; R5/ general adapter type; index into "general" adapter arrays.
; For each adapter -
;	Map the # of pages specified in ADAPDESC macro
;	JSB to initialization routine specified in ADAPDESC macro
;
MAP_NEXUS:
	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	MOVAB	<16*512>(R8),R8		; Since no Qbus adapter space, point to
					;  non-exist memory past Qbus I/O space.
	.ENDC
	MOVL	R2,W^SBICONF[R4]	; Save VA of adapter space in SBICONF.
	MOVZWL	W^NUM_PAGES[R5],R1	; Get number of pages to map.
	BSBB	MAP_PAGES		; Map the I/O pages.
	MOVAL	W^INIT_ROUTINES[R5],R1	; Get address of initialization routine.
	TSTL	(R1)			; Initialization routine specified?
	BEQL	END_NEXUS		; Branch if none.
	JSB	@(R1)[R1]		; Call initialization routine.
END_NEXUS:
	INCL	R4			; Increment CONFREG and SBICONF index.
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	BRW	NXT_NEXUS		; Go do next nexus.
	.IFF				;IF IS "UV1"
	RSB				; Return, as only one nexus.
	.ENDC				;END NOT "UV1" CONDITIONAL


	.SBTTL	CREATE_ARRAYS
;
; CREATE_ARRAYS
;
;	Move the local CONFREG and SBICONF arrays into non-paged pool.
;
; Inputs:
;	R4 - Number of nexuses on the system.
;	CONFREG and SBICONF have been initialized.
;
; Outputs:
;	R0 - R5 destroyed
;	EXE$GL_CONFREG points to a copy of the CONFREG array in non-paged pool
;	MMG$GL_SBICONF points to a copy of the SBICONF array in non-paged pool
;	EXE$GL_NUMNEXUS contains the number of nexuses on the system
;
;
CREATE_ARRAYS:
	MOVL	R4,G^EXE$GL_NUMNEXUS	; Store number of nexuses on system.
	MOVAL	12(R4)[R4],R1		; Allocate n bytes for CONFREG plus
					; 4n bytes for SBICONF + header
	MOVAL	(R1)[R4],R1		; Another 4n bytes for CONFREGL.
	BSBW	ALONPAGD		; Get pool for CONFREG and SBICONF.
	CLRQ	(R2)+			; Clear out unused
	MOVW	R1,(R2)+		; Set in size
	MOVW	#<DYN$C_CONF@8>!DYN$C_INIT,(R2)+ ; Set type and subtype
	MOVAB	(R2),G^EXE$GL_CONFREG	; Store address of system CONFREG.
	MOVAB	(R2)[R4],R1		; Two steps to CONFREGL, 1st, SBICONF,
	MOVL	R1,G^MMG$GL_SBICONF 	; Store address of system SBICONF.
	MOVAL	(R1)[R4],G^EXE$GL_CONFREGL ; And address of system CONFREGL.
	PUSHR	#^M<R2,R4>		; Save pool address and nexus count.
	MOVC3	R4,W^CONFREG,(R2)	; Copy CONFREG to pool.
	POPR	#^M<R2,R4>		; Retrieve pool address and nexus count.
	MULL3	#4,R4,R1		; Number of bytes in SBICONF.
	MOVL	R1,-(SP)		; Save, SBICONF size = CONFREGL size
	MOVC3	R1,W^SBICONF,(R2)[R4]	; Copy SBICONF to pool.
	MOVL	(SP)+,R1		; Restore size of SBICONF and CONFREGL.
	MOVC3	R1,W^CONFREGL,(R3)	; Copy CONFREGL to pool.  R3 is output
					; from SBICONF MOVC3, so SBICONF and
					; CONFREGL must be adjacent.

	RSB

	.SBTTL	MAP_PAGES
;++
; INPUTS:
;	R1/ Number of pages to map.
;	R2/ VA of page to map.
;	R3/ VA of system page table entry to be used.
;	R8/ PFN of page(s) to map.
;
; OUTPUTS:
;	R2,R3 updated; R1,R8 destroyed; all other registers preserved
;
;--

MAP_PAGES:

	BISL3	#<PTE$M_VALID!PTE$C_KW>,R8,(R3)+
					; Map a page.
	INCL	R8			; Next PFN.
	MOVAB	512(R2),R2		; Next VA.
	INCL	G^BOO$GL_SPTFREL	; Next free entry.
	CMPL	G^BOO$GL_SPTFREH, -	; Check for no more system page
		G^BOO$GL_SPTFREL	; table entries.
	BLEQ	ERROR_HALT		; Branch if out of SPTEs.
	SOBGTR	R1,MAP_PAGES		; Map another page.
	RSB				; All done.

ERROR_HALT:
	MOVAB	W^NOSPT,R1		; Set error message.
ERROR_HALT_1:
	CLRL	R11			; Indicate console terminal.
	JSB	G^EXE$OUTZSTRING 	; Output error message.
	HALT				; ***** FATAL ERROR *******

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	.SBTTL	INI$SCB
;++
;	Fill in 11/790-specific SCB vectors.
;
; INPUTS:
;	R11		- Which SCB page is used by this SBIA
;	ABUS_VA[R11]	- Address of this SBIA's register space
;
; OUTPUTS:
;	790-specific SCB vectors are filled in; they will point into a
;	JSB table, which transfers control to the appropriate interrupt
;	handling routine with the address of the SBIA's register space
;	on top of the stack (so the interrupt routine will know which SBIA
;	interrupted).  After this routine executes, each 790-specific SCB
;	vector is set up as shown below:
;
;	  SCB		   SYSLOA790
;	+-------+	+---------------+
;	|   .	|	|	.	|
;	|-------|	|---------------|
;	|   +---|------>| JSB int_rtn --|---+
;	|-------|	| <SBIA reg adr>|   |
;	|   .	|	|---------------|   |
;	+-------+	|		|   |
;			|---------------|<--+
;			|   int_rtn	|
;			|---------------|
;
;	All registers are preserved.
;++
	
;
; Macro SCBVEC.
;
;	This macro defines a table of <SCB vector, interrupt service routine>
;	pairs.  This table is used to initialize the 11/790-specific vectors
;	in the SCB.
;
	.MACRO	SCBVEC	VECNUM,SERVICE_RTN,SYS

	.WORD	<VECNUM/4>		; Longword offset from start of SCB page.
	.LONG	<SERVICE_RTN-.>		; Store self-relative offset to service
					; routines defined in SYSLOA790.
	NUMVECS = NUMVECS + 1		; Count number of vectors to load.
	.ENDM	SCBVEC


;
; List the 11/790 SCB vectors to be directed to the JSB table.
;
	NUMVECS = 0			; Number of SCB vectors to load.
INI$L_SCBVALS:				; Define SCB vectors and their
					; interrupt handling routines.
	SCBVEC	VECNUM=<^X58>,SERVICE_RTN=EXE$INT58
	SCBVEC	VECNUM=<^X5C>,SERVICE_RTN=EXE$INT5C
	SCBVEC	VECNUM=<^X60>,SERVICE_RTN=EXE$INT60

	.PSECT	SYSLOA,LONG		; This data stays after INIADP is gone.

	.ALIGN	LONG
INI$L_IOAVECS:
	.REPT	4*NUMVECS		; 4 pages of SCB * number of vectors/page.
	.ALIGN	LONG			; SCB routines must be longword aligned.
	JSB	@#EXE$LOAD_ERROR	; Init to error halt.
	.LONG	0			; Reserve space for address of IOA regs.
	.ENDR

	.PSECT	$$$INIT$CODE

INI$SCB:
	PUSHR	#^M<R0,R1,R2,R3,R4>	; Save some registers.
	MOVAL	INI$L_SCBVALS,R0	; Get address of SCB value table.
	MOVAL	INI$L_IOAVECS,R1	; Get address of JSB table.
	MULL3	#<NUMVECS*12>,R11,R2	; Get byte offset into JSB table for
					; this SCB page.
	ADDL	R2,R1			; R1 points to 1st JSB table entry
					; for this SCB page.
	MOVL	G^EXE$GL_SCB,R2		; Address of SCB.
	ASHL	#9,R11,R3		; Turn SCB page offset into byte offset.
	ADDL	R3,R2			; R2 points to beginning of correct
					; SCB page.
	MOVL	#NUMVECS,R3		; Get number of vectors to load.

;
; R0 walks through a table of the form:
;	.WORD	<longword offset into SCB>
;	.LONG	<self-relative offset to SCB interrupt handling routine>
; where each JSB instruction is longword aligned.
;
; R1 walks through a table of the form:
;	JSB	<@#interrupt handling routine>
;	.LONG	<address of SBIA register space>
;
; R2 points to the beginning of the SCB page for this SBIA.
;
; This loop performs the following functions:
;	(1) Fills in the SCB vector to point to one of the JSB instructions
;	    in the IOAVEC table.
;	(2) Fills in the destination of the JSB instruction to point to the
;	    correct interrupt handling routine in SYSLOA790.EXE.
;	(3) Fills in the longword after the JSB instruction with the address
;	    of register space for this SBIA adapter.
;

FILL_IN_SCB:
	MOVW	(R0)+,R4		; R4 <- longword offset into SCB page.
	MOVAB	1(R1),(R2)[R4]		; Point SCB vector to JSB instruction
					; (+1 to execute on interrupt stack).
	MOVAB	@(R0)[R0],2(R1)		; Fill in destination of JSB instruction.
	MOVL	W^ABUS_VA[R11],6(R1)	; Put address of IOA regs after the JSB.
	MOVAL	4(R0),R0		; Step to next entry in SCB table.
	MOVAL	12(R1),R1		; Step to next entry in JSB table.
	SOBGTR	R3,FILL_IN_SCB		; Repeat for all vectors.
;
; Take care of a special case: the vector at offset ^x54 into venus' SCB is
; the SBI FAIL vector.  This condition is handled as a powerfail.  This is a
; special case because we don't want the address of the SBIA registers on the
; stack when we vector to the powerfail code.
;
	MOVAB	G^EXE$POWERFAIL+1,-	; Load address of powerfail routine.
		^X64(R2)
	POPR	#^M<R0,R1,R2,R3,R4>
	RSB

	.ENDC				;END 790 CONDITIONAL

	.SBTTL	INI$UBSPACE
;++
;	Map UNIBUS space; initialize UNIBUS ADP.
;
; INPUTS:
;	R2 - VA of next free system page
;	R3 - VA of system page table entry to be used to map VA in R2
;	R4 - nexus identification number of this adapter
;   -8(R6) - PFN of this UNIBUS adapter's register space
;
; OUTPUTS:
;	UNIBUS space is mapped.
;	INI$UBADP is called to build an ADP block and initialize UNIBUS
;	adapter hardware.
;
;--

INI$UBSPACE:

	.IF	NE,CPU_TYPE-PR$_SID_TYP8SS	; If NOT 11/8SS
	.IF	NE,CPU_TYPE-PR$_SID_TYP8NN	; If NOT 11/8NN
	MOVAL	W^CONFREGL[R4],R8		; R8 => CONFREGL slot.
	EXTZV	#0,#2,(R8),R8			; Get UBA number.
	ASHL	#9,R8,R8			; Position UB number.
	.ENDC					; End NOT 11/8NN
	.ENDC					; End NOT 11/8SS

	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS	; If 11/8SS
	MOVL	W^SBICONF[R4],R8		; R8 => node space for this BUA.
	ADDL3	#^O760000,-			; Add offset to I/O page to physical
		BIIC$L_SAR(R8),R8		;  address of window space (from
						;  BIIC starting address register)
						;  to get phy. addr of I/O page.
	ASHL	#-9,R8,R8			; Shift to get PFN.
	.ENDC					; End 11/8SS conditional.

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	ADDL	#<IO780$AL_UB0SP+^O760000/^X200>,R8
					; Get PFN of Ub I/O page.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	SUBL3	R8,#<IO750$AL_UB0SP+^O760000/^X200>,R8
					; Get PFN of UB I/O page.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	SUBL3	R8,#<IO730$AL_UB0SP+^O760000/^X200>,R8
					; Get PFN of UB I/O page.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	BICL3	#^XFF,-8(R6),R1		; Get PFN of start of SBI addr space.
	MOVAB	W^<<IO790$AL_UB0SP+^O760000>/^X200>(R1)[R8],R8
					; Calculate PFN of Unibus I/O page.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	SUBL3	R8,#<IOUV1$AL_QB0SP/^X200>,R8
					; Get PFN of Qbus I/O page.
	.ENDC

	MOVL	#16,R1			; Number of pages to map (UB/Qbus space).
	BSBW	MAP_PAGES		; Map I/O pages.
;
; Call adapter initialization routine.
;
;	BSBW	INI$UBADP		; Init ADP block.
;	RSB

	.SBTTL	INI$UBADP - BUILD ADP AND INITIALIZE UBA
;+
; INI$UBADP ALLOCATES AND FILLS IN AN ADAPTER CONTROL BLOCK, INTERRUPT
; DISPATCHER AND CONNECTS THEM TO THE PROPER SCB VECTORS.  A CALL IS
; THEN MADE TO UBA$INITIAL TO INITIALIZE THE ADAPTER HARDWARE.
;
; INPUT:
;	R4 - nexus identification number of this adapter
;	R11- offset from beginning of SCB to correct SCB page for this adapter
;-

INI$UBADP:

	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>	; SAVE R0-R8
;
; Allocate and initialize Adapter Control Block (ADP).
;
	MOVZWL	W^CPU_ADPSIZE,R1	; PICK UP LENGTH OF ADP
	BSBW	ALONPAGD		; ALLOCATE SPACE FOR ADP
	MOVW	R1,ADP$W_SIZE(R2)	; SET SIZE INTO ADP BLOCK
	MOVB	#DYN$C_ADP, -		; AND SET TYPE OF BLOCK
		ADP$B_TYPE(R2)
	MOVW	#AT$_UBA, -		; SET TYPE OF ADAPTER
		ADP$W_ADPTYPE(R2)
	MOVL	W^SBICONF[R4], -	; SET VA OF CONFIGURATION REG
		ADP$L_CSR(R2)
	MOVW	R4,ADP$W_TR(R2)		; SET TR NUMBER FOR ADAPTER

	MOVAL	ADP$L_DPQFL(R2),R0	; ADDRESS OF DATA PATH WAIT QUEUE
	MOVL	R0,(R0)			; INIT QUEUE HEADER
	MOVL	R0,4(R0)		;

	MOVAL	ADP$L_MRQFL(R2),R0	; ADDRESS OF MAP WAIT QUEUE
	MOVL	R0,(R0)			; INIT QUEUE HEADER
	MOVL	R0,4(R0)		;
	CLRL	ADP$L_LINK(R2)		; ZAP ADAPTER CHAIN LINK
	BSBW	ADPLINK			; LINK ADP TO END OF LIST
;
; Initialize adapter interrupt vectors in System Control Block.
;
	MOVL	G^EXE$GL_SCB,R8		; GET SCB ADDRESS

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790

	ASHL	#9,R11,R3		; Turn SCB page offset into byte offset.
	ADDL	R3,R8			; Set to beginning of correct SCB page.
					; Fall into 11/780 code.
	.ENDC

	.IF	NE,SBI_CPU		; For 11/780's and 11/790's

;
; Following ASSUME breaks if the ADP length is not a multiple of 4, thereby
;	causing the vectors to NOT be long word aligned.

	ASSUME	ADP$C_UBAADPLEN/4*4	EQ	ADP$C_UBAADPLEN

	MOVAB	ADP$C_UBAADPLEN+UBINTSZ(R2),R3	; LOCATE VECTORS
	MOVL	R3,ADP$L_VECTOR(R2)	; AND RECORD IN ADP
	MOVW	#^XFFFE,ADP$W_DPBITMAP(R2) ; MARK DATAPATHS 1-15 AVAILABLE
	MOVAB	-UBINTSZ(R3),R3		; BASE OF INTERRUPT CODE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	#UBINTSZ,W^UBAINTBASE,(R3)	; COPY INTERRUPT CODE
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	EXTZV	#0,#4,R4,R4		; Use low 4 bits of nexus number.
	MOVAL	^X100(R8)[R4],R0	; COMPUTE 1ST VECTOR ADDRESS
	MOVL	R0,ADP$L_AVECTOR(R2)	; SAVE ADDR OF ADAPTER SCB VECTORS
	MOVAB	B^UBAINT4+1(R3),(R0)	; STORE VECTOR FOR BR4
	MOVAB	B^UBAINT5+1(R3),64(R0)	; STORE VECTOR FOR BR5
	MOVAB	B^UBAINT6+1(R3),128(R0)	; STORE VECTOR FOR BR6
	MOVAB	B^UBAINT7+1(R3),192(R0)	; STORE VECTOR FOR BR7
	MOVL	ADP$L_CSR(R2),R0	; GET UBACSR ADDRESS
	ADDL	R0,B^UBAINT4REL(R3)	; ADD CSR VA
	ADDL	R0,B^UBAINT5REL(R3)	; TO EACH OF THE
	ADDL	R0,B^UBAINT6REL(R3)	; BICL INSTRUCTIONS
	ADDL	R0,B^UBAINT7REL(R3)	; IN THE INTERRUPT DISPATCHERS
	MOVL	R2,UBAINTADP(R3)	;SET ADDRESS OF ADAPTOR CONTROL BLOCK
	MOVAB	W^EXE$UBAERR_INT,-
		 UBAERRADR(R3)		; SET ADDRESS OF ERROR HANDLER
	MOVAB	B^UBAINT4+1(R3),-
		 ADP$L_UBASCB(R2)	; SAVE 4 SCB VECTOR CONTENTS
	MOVAB	B^UBAINT5+1(R3),-
		 ADP$L_UBASCB+4(R2)	; DITTO
	MOVAB	B^UBAINT6+1(R3),-
		 ADP$L_UBASCB+8(R2) 	; DITTO
	MOVAB	B^UBAINT7+1(R3),-
		 ADP$L_UBASCB+12(R2) 	; DITTO
	MOVL	R2,R4			; COPY ADP ADDRESS
	MOVL	ADP$L_CSR(R2),R2	; VIRTUAL ADDRESS OF ADAPTER
	MOVL	#^X7C000000,UBA$L_CR(R2); DISABLE ALL UMR'S
	JSB	G^MMG$SVAPTECHK		; ADDRESS OF SPTE THAT MAPS ADAPTER
	MOVL	(R3),ADP$L_UBASPTE(R4)	; SAVE CONTENTS OF SPTE MAPPING ADAPTER
	MOVL	<8*4>(R3), -		; CONTENTS OF SPTE MAPPING I/O SPACE
		ADP$L_UBASPTE+4(R4)
	MOVL	R4,R2			; COPY ADP ADDRESS BACK TO R2
	MOVAL	G^UBA$UNEXINT,R3	; GET ADDR OF UNEXP INT SERVICE(IN EXEC)
	MOVAL	W^UBA$INT0,R4		; GET ADDR OF SPECIAL VECTOR 0 ROUTINE

;
; INIT UB VECTORS TO UNEXPECTED INTERRUPT SERVICE
;
	MOVL	ADP$L_VECTOR(R2),R0	; GET ADDRESS OF VECTORS
	MOVL	R4,(R0)+		; SPECIAL CASE FOR VECTOR 0
	MOVZBL	#<NUMUBAVEC-1>,R1	; REST OF VECTORS
10$:	MOVL	R3,(R0)+		; FILL VECTOR WITH UNEXP INT
	SOBGTR	R1,10$			; FILL ALL VECTORS

	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750

	PUSHL	#NDT$_UB0		; ASSUME UB0
	MOVAL	^X200(R8),-		; GET VECTOR SPACE FOR UB0
		ADP$L_VECTOR(R2)	;  
	CMPL	W^CONFREGL[R4],#NDT$_UB0; IS DEVICE TYPE = UB0?
	BEQL	10$			; BRANCH IF SO
	MOVL	#NDT$_UB1,(SP)		; INDICATE UB1
	ADDL	#^X200,ADP$L_VECTOR(R2)	; STEP TO ITS VECTOR SPACE
10$:	MOVW	#^XE,ADP$W_DPBITMAP(R2)	; MARK DATAPATHS 1-3 AVAILABLE
	MOVL	ADP$L_CSR(R2),R3	; VIRTUAL ADDRESS OF ADAPTER
	MOVAB	UBA$L_MAP(R3),R3	; POINT TO MAPPING REGISTERS
	MOVZWL	#496,R4			; NUMBER OF UMR TO DISABLE
20$:	CLRL	(R3)+			; DISABLE A UNIBUS MAP REGISTER
	SOBGTR	R4,20$			; LOOP THRU THEM ALL
	MOVAL	G^UBA$UNEXINT+1,R3	; GET ADDR OF UNEXP INT SERVICE
					;  (+1 MEANS HANDLE ON INT STACK)
	MOVAL	W^UBA$INT0+1,R4		; SPECIAL CASE TO COUNT PASSIVE RELEASE

;
; INIT UB VECTORS TO UNEXPECTED INTERRUPT SERVICE
;
	MOVL	ADP$L_VECTOR(R2),R0	; GET ADDRESS OF VECTORS
	MOVL	R4,(R0)+		; SPECIAL CASE FOR VECTOR 0
	MOVZBL	#<NUMUBAVEC-1>,R1	; REST OF VECTORS
30$:	MOVL	R3,(R0)+		; FILL VECTOR WITH UNEXP INT
	SOBGTR	R1,30$			; FILL ALL VECTORS
	CMPB	#NDT$_UB1,(SP)		; IS THIS UB1?
	BNEQ	40$			; IF NOT, SKIP CODE
;
; SAVE CONTENTS OF SPTE'S MAPPING UB SPACE
;
	MOVL	R2,R4			; SAVE ADP ADDRESS
	MOVL	ADP$L_CSR(R2),R2	; GET VA OF ADAPTER
	JSB	G^MMG$SVAPTECHK		; GET ADDRESS OF SPTE MAPPING ADAPTER
	MOVL	(R3),ADP$L_UBASPTE(R4)	; STORE CONTENTS OF SPTE IN ADP
	MOVL	<8*4>(R3),ADP$L_UBASPTE+4(R4) ; SAME FOR I/O SPACE
;
; CALCULATE AND STORE VA OF IPEC REGISTER, WHICH CONTAINS BITS NEEDED
; TO PROCESS POWERFAIL
;
	ADDL3	#<8*^X200> + UAS$W_IP_CR1,- ; VA OF ADAPTER + OFFSET TO	
		R2,ADP$L_UBASCB+12(R4)	; I/O SPACE + OFFSET TO IPEC REGISTER
;
; STORE INTERRUPT CODE IN ADP, STORE ITS ADDRESS IN POWERFAIL INTERRUPT
; VECTOR IN SCB, AND SAVE ITS ADDRESS IN ADP
;
	MOVQ	W^UBA1INT,ADP$L_UBASCB+4(R4)
	MOVAB	W^EXE$UBAERR_INT,ADP$L_UBASCB+6(R4)
	MOVAL	ADP$L_UBASCB+4(R4),^X1E4(R8) 
	INCL	^X1E4(R8)		; USE INTERRUPT STACK
	MOVAL	ADP$L_UBASCB+4(R4),ADP$L_UBASCB(R4)
;
; DONE WITH ADAPTER-SPECIFIC CODE
;
	MOVL	R4,R2			; RESTORE R2
40$:	ADDL	#4,SP			; CLEAN STACK
	
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
					; REMAINING ADP INIT FOR 11/730:
	MOVAL	^X200(R8),-		; ASSUME UB0
		ADP$L_VECTOR(R2)	;  VECTOR SPACE
	CMPL	W^CONFREGL[R4],#NDT$_UB0; IS DEVICE TYPE = UB0?
	BEQL	10$			; BRANCH IF SO
	ADDL	#^X200,ADP$L_VECTOR(R2)	; ELSE STEP TO UB1 VECTOR SPACE
10$:	MOVW	#^XE,ADP$W_DPBITMAP(R2)	; MARK DATAPATHS 1-3 AVAILABLE
	MOVL	ADP$L_CSR(R2),R3	; VIRTUAL ADDRESS OF ADAPTER
	MOVAB	UBA$L_MAP(R3),R3	; POINT TO MAPPING REGISTERS
	MOVZWL	#496,R4			; NUMBER OF UMR TO DISABLE
20$:	CLRL	(R3)+			; DISABLE A UNIBUS MAP REGISTER
	SOBGTR	R4,20$			; LOOP THRU THEM ALL
	MOVAL	G^UBA$UNEXINT+1,R3	; GET ADDR OF UNEXP INT SERVICE
					;  (+1 MEANS HANDLE ON INT STACK)
	MOVAL	W^UBA$INT0+1,R4		; SPECIAL CASE TO COUNT PASSIVE RELEASE

;
; INIT UB VECTORS TO UNEXPECTED INTERRUPT SERVICE
;
	MOVL	ADP$L_VECTOR(R2),R0	; GET ADDRESS OF VECTORS
	MOVL	R4,(R0)+		; SPECIAL CASE FOR VECTOR 0
	MOVZBL	#<NUMUBAVEC-1>,R1	; REST OF VECTORS
30$:	MOVL	R3,(R0)+		; FILL VECTOR WITH UNEXP INT
	SOBGTR	R1,30$			; FILL ALL VECTORS

	.ENDC				;END 730 CONDITIONAL


	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
					; REMAINING ADP INIT FOR MICRO-VAX I:
	MOVAL	^X200(R8),-		; ASSUME UB0
		ADP$L_VECTOR(R2)	;  VECTOR SPACE

	MOVW	#^XE,ADP$W_DPBITMAP(R2)	; MARK DATAPATHS 1-3 AVAILABLE
	MOVAL	G^UBA$UNEXINT+1,R3	; GET ADDR OF UNEXP INT SERVICE
					;  (+1 MEANS HANDLE ON INT STACK)
	MOVAL	W^UBA$INT0+1,R4		; SPECIAL CASE TO COUNT PASSIVE RELEASE

;
; INIT QBUS VECTORS TO UNEXPECTED INTERRUPT SERVICE
;
	MOVL	ADP$L_VECTOR(R2),R0	; GET ADDRESS OF VECTORS
	MOVL	R4,(R0)+		; SPECIAL CASE FOR VECTOR 0
	MOVZBL	#<NUMUBAVEC-1>,R1	; REST OF VECTORS
30$:	MOVL	R3,(R0)+		; FILL VECTOR WITH UNEXP INT
	SOBGTR	R1,30$			; FILL ALL VECTORS

	.ENDC				;END UV1 CONDITIONAL


	.IF	NE,BI_CPU			; For BI CPU's only.

; Remaining BUA ADP init for BI CPU's. Here R2 => ADP, R8 => SCB.

; First we will (someday) set up the 4 Adapter Interrupt Vectors in the SCB.
; End of setup for Adapter Interrupt Vectors.

	INCL	W^DIRECT_VEC_NODE_CNT	; Incr the number fo direct vectoring
					;  BI nodes found so far.
	ASHL	#9,-			; Shift left number of nodes to get
		W^DIRECT_VEC_NODE_CNT,-	;  offset into SCB for page of direct
		R0			;  vectors for this node.
	MOVAB	(R0)[R8],ADP$L_VECTOR(R2);Save address of vector page in ADP.

	MOVW	#^X3E,ADP$W_DPBITMAP(R2); Mark datapaths 1-5 available.

	MOVL	ADP$L_CSR(R2),R3	; Virtual address of Adapter registers.
	INSV	W^DIRECT_VEC_NODE_CNT,-	; Record in BUA Vector Offset Register,
		#BUA$V_VECOFF,-		;  the offset to the SCB page to use
		#BUA$S_VECOFF,-		;  for UNIBUS device interrupts.
		BUA$L_VOR(R3)

;	ASSUME	UBA$L_MAP	EQ	BUA$L_MAP
	MOVAB	UBA$L_MAP(R3),R3	; Point to mapping registers.
	MOVZWL	#496,R4			; Number of UMR to disable.
10$:	CLRL	(R3)+			; Disable a UNIBUS map register.
	SOBGTR	R4,10$			; Loop thru them all.
	MOVAL	G^UBA$UNEXINT+1,R3	; Get addr of UNEXP INT Service
					;  (+1 means handle on INT stack).
	MOVAL	W^UBA$INT0+1,R4		; Special case to count Passive Release.

;
; INIT UB Vectors to UNEXPECTED INTERRUPT SERVICE
;
	MOVL	ADP$L_VECTOR(R2),R0	; Get address of vectors.
	MOVL	R4,(R0)+		; Special case for Vector 0.
	MOVZBL	#<NUMUBAVEC-1>,R1	; Rest of vectors.
20$:	MOVL	R3,(R0)+		; Fill vector with UNEXP INT.
	SOBGTR	R1,20$			; Fill all vectors.

	.ENDC					; End NI CPU conditional.


	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
;
; All memory on the QBUS is main memory.  There is no memory analogous
; to UNIBUS memory.
;
; Now locate the memory controllers and build a list of the addresses
; at which they are located.  This list is used by the memory error logic
; in machine-check.  This information must be determined outside of machine-
; check, since the machine-check code cannot cause another machine-check
; without causing a cpu double-error halt.
;
; The list is a count of controllers, followed by the virtual addresses
; that are the memory controller CSRs.  Each MSV-11P has a single word CSR.
;
	.ENABLE	LSB
	MOVL	G^EXE$GL_SCB,R3		; Get SCB address.
	PUSHL	4(R3)			; Save current mcheck handler address.
	MOVL	SP,R0			; Mark current stack position.
	MOVAL	B^MCHK_HANDLER,4(R3)	; Connect temp mcheck handler.

	MOVL	G^MMG$GL_SBICONF,R1	; Get address of SBICONF array.
	MOVL	(R1),R1			; Get VA of Qbus I/O space.
	ADDL	#<^O12100+^X1000>,R1	; Offset to memory controller CSR(772100).
	MOVAL	G^EXE$AL_MEMCSRS,R4	; Get address of memory CSR count.
	MOVAL	4(R4),R6		; Get address of buffer for CSRs.
	CLRL	R5			; Initialize index.
 
50$:	TSTW	(R1)[R5]		; Touch possible memory CSR.
	INCL	(R4)			; Count number of error bits set.
	MOVAW	(R1)[R5],(R6)+		; Save address of this CSR
60$:	AOBLSS	#16,R5,50$		; Loop through all possible CSRs.
	BRB	70$			; Continue with common code. 
;
; TEMPORARY MACHINE CHECK HANDLER
;

	.ALIGN	LONG			; Align machine-check vector.
MCHK_HANDLER:				;

	MTPR	#^XF,#PRUV1$_MCESR	; Clear machine-check state.
	MOVL	R0,SP			; Clean mcheck frame from stack.
	BRB	60$			; Continue looking for memory CSRs.

70$:	POPL	4(R3)			; Restore mcheck handler address.

	.DISABLE LSB
	.ENDC
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
;
; Now check for any UNIBUS memory that may be on the adapter. First we must
; disable all the UNIBUS Map Registers so that there is no conflict in
; which memory will respond.  Then we check all 248Kb of potential memory in
; 8Kb chunks, since each disable bit on the 780 UBA represents 16 UMR's or
; 8Kb of memory.  The number of registers is stored in the ADP and the 
; corresponding number withdrawn from the UMR map in the ADP.
;

	.ENDC
	MOVL	ADP$L_CSR(R2),R6	; Pick up adapter pointer
	CLRL	R1			; Zero out number of UMR to disable
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	SUBL3	#512,8(SP),R7		; R7 = VA of last page of UNIBUS
	SUBL3	#4,12(SP),R8		; R8 = VA of SPTE mapping (R7)
	SUBL3	#512,32(SP),R4		; R4 = PFN of first page of UNIBUS
	PUSHL	(R8)			; Save contents of SPTE
	MOVL	R4,R3			; Copy starting PFN
	MOVL	#31,R5			; 31 8Kb chunks to test
50$:	INVALID	R7			; Invalidate TB
	BISL3	#<PTE$M_VALID!PTE$C_KW>,-
		 R4,(R8)		; Map each page of UNIBUS
	MOVL	R7,R0			; Address to check
	BSBW	EXE$TEST_CSR		; Validate it
	BLBC	R0,70$			; Not there
	CMPL	R3,R4			; First time in?
	BEQL	60$			; Yes, skip next test
	TSTL	R1			; Any registers already?
	BEQL	80$			; No, memory not start at 0
60$:	MOVAB	16(R1),R1		; Yes, up the count
70$:	MOVAB	16(R4),R4		; Map Next 8Kb (16*512)
	SOBGTR	R5,50$			; Loop until done
	POPL	(R8)			; Restore old contents of SPTE
	INVALID	R7			; Invalidate TB
	.ENDC				;END "NOT" UV1 CONDITIONAL
	MOVW	R1,ADP$W_UMR_DIS(R2)	; Record number disabled
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
;
; Initialize fields for new UBA map register allocation.  Make it appear
;	that we have one contiguous array of 496 available map registers.
;	To do this we set ADP$L_MRACTMDRS to one (the number of active
;	map register descriptors for distinct contiguous areas),
;	ADP$W_MRNREGARY(0) to 496 (i.e the number of registers in this
;	contiguous range) and ADP$FREGARY(0) to 0 (i.e. the first register
;	in the range is register 0).
;
	MOVL	#1,ADP$L_MRACTMDRS(R2)	; 1 active map descriptor
	SUBW3	R1,#496,ADP$W_MRNREGARY(R2);  for a range of 496 registers
	.IFF				;IF IS "UV1"
;
; Initialize fields for the Qbus map register allocation.  Since there
; are no map registers for the Micro-VAX I Qbus, initialize the data structures
; so that the standard allocate routine will just return an error.
;
	MOVL	#1,ADP$L_MRACTMDRS(R2)	; 1 active map descriptor
	SUBW3	R1,#496,ADP$W_MRNREGARY(R2);  for a range of 496 registers
;	CLRL	ADP$L_MRACTMDRS(R2)	; No active descripters.
;	CLRL	ADP$W_MRNREGARY(R2)	; No registers to allocate,
	.ENDC				;END NOT "UV1" CONDITIONAL
	MOVW	R1,ADP$W_MRFREGARY(R2)	;  starting at register zero.
	MNEGW	#1,ADP$W_MRNFENCE(R2)	; Also init "fences" which preceed
	MNEGW	#1,ADP$W_MRFFENCE(R2)	;  the two descriptor arrays.
;
; Initialize adapter hardware.
;
	MOVL	ADP$L_CSR(R2),R4	; Get CSR address to init
	BSBW	UBA$INITIAL 		; And initialize adapter
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8> ; Restore registers
	RSB				; Return

	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
;
; Error if UNIBUS memory not start at location 0
;
80$:	MOVAB	W^BADUMR,R1		; Set error message
	BRW	ERROR_HALT_1		; Put it out
	.ENDC				;END "NOT" UV1 CONDITIONAL

	.IF	NE,SBI_CPU		; For 11/780's and 11/790's.
	.PAGE
;
; UBA INTERRUPT SERVICE ROUTINES.  ONE COPY OF THESE ROUTINES IS
; MOVED INTO NONPAGED POOL AND RELOCATED FOR EACH UBA.
;
; **** NOTE ****  THE CODING SEQUENCE FOR DISPATCHING ON UBA INTTERUPTS
; IS ASSUMED IN THE MODULE MCHECK780.MAR.  THE ASSUMPTIONS ARE MADE SO
; THE MACHINE CHECK HANDLER CAN IDENTIFY A CPU TIMEOUT WHEN THE
; BICL3 INSTRUCTION IS READING THE  UBA'S BRRVR REGISTER.
; THE ASSUMPTIONS MADE ARE THAT THE VALUE OF THE VIRTUAL ADDRESS OF THE BRRVR
; REGISTER IS AT AN OFFSET OF 10. BYTES PAST THE INTERRUPT VECTOR ENTRY POINT,
; THAT THE PC OF THE INSTRUCTION ACCESSING BRRVR IS 3 BYTES PAST THE INTERRUPT
; VECTOR ENTRY, AND THAT R4 AND R5 ARE SAVED ON THE STACK AT THAT POINT.
;

	.ENABL	LSB
	.ALIGN	QUAD
UBAINTBASE:				; BASE OF UBA INTERRUPT DISPATCHERS
UBAINT4=.-UBAINTBASE			; UBA 0 INTERRUPT DISPATCH LEVEL 4
	MOVQ	R4,-(SP)		; SAVE REGISTERS
	BICL3	#^X7FFFFE03,@#UBA$L_BRRVR,R4 ; READ VECTOR  REGISTER AND CLEAR BITS
UBAINT4REL=.-UBAINTBASE-5		; OFFSET TO ADD UBACSR VALUE
	MOVQ	R2,-(SP)		; SAVE REGISTERS
	MOVAB	B^VECTAB[R4],R5		; GET ADDRESS OF INTERRUPT VECTOR
	BGEQ	10$			; IF GEQ UBA INTERRUPTS
	MOVQ	R0,-(SP)		; SAVE REGISTERS
	JMP	@(R5)+			; DISPATCH INTERRUPT
	.ALIGN	QUAD
UBAINT5=.-UBAINTBASE			; UBA 0 INTERRUPT DISPATCH LEVEL 5
	MOVQ	R4,-(SP)		; SAVE REGISTERS
	BICL3	#^X7FFFFE03,@#UBA$L_BRRVR+4,R4 ; READ VECTOR REGISTER AND CLEAR BITS
UBAINT5REL=.-UBAINTBASE-5		; OFFSET TO ADD UBACSR VALUE
	MOVQ	R2,-(SP)		; SAVE REGISTERS
	MOVAB	B^VECTAB[R4],R5		; GET ADDRESS OF INTERRUPT VECTOR
	BGEQ	10$			; IF GEQ UBA INTERRUPTS
	MOVQ	R0,-(SP)		; SAVE REGISTERS
	JMP	@(R5)+			; DISPATCH INTERRUPT
	.ALIGN	QUAD
UBAINT6=.-UBAINTBASE			; UBA 0 INTERRUPT DISPATCH LEVEL 6
	MOVQ	R4,-(SP)		; SAVE REGISTERS
	BICL3	#^X7FFFFE03,@#UBA$L_BRRVR+8,R4 ; READ VECTOR REGISTER AND CLEAR BITS
UBAINT6REL=.-UBAINTBASE-5		; OFFSET TO ADD UBACSR VALUE
	MOVQ	R2,-(SP)		; SAVE REGISTERS
	MOVAB	B^VECTAB[R4],R5		; GET ADDRESS OF INTERRUPT VECTOR
	BGEQ	10$			; IF GEQ UBA INTERRUPTS
	MOVQ	R0,-(SP)		; SAVE REGISTERS
	JMP	@(R5)+			; DISPATCH INTERRUPT
	.ALIGN	QUAD
UBAINT7=.-UBAINTBASE			; UBA 0 INTERRUPT DISPATCH LEVEL 7
	MOVQ	R4,-(SP)		; SAVE REGISTERS
	BICL3	#^X7FFFFE03,@#UBA$L_BRRVR+12,R4 ; READ VECTOR AND CLEAR BITS
UBAINT7REL=.-UBAINTBASE-5		; OFFSET TO ADD UBACSR VALUE
	MOVQ	R2,-(SP)		; SAVE REGISTERS
	MOVAB	B^VECTAB[R4],R5		; GET ADDRESS OF INTERRUPT VECTOR
	BGEQ	10$			; IF GEQ UBA INTERRUPTS
	MOVQ	R0,-(SP)		; SAVE REGISTERS
	JMP	@(R5)+			; DISPATCH INTERRUPT
10$:	BBCC	#31,R4,20$		;CLEAR ADAPTER ERROR INTERRUPT FLAG (MSB)
20$:	MOVAB	B^VECTAB[R4],R5		;GET ADDRESS OF INTERRUPT VECTOR
	MOVL	I^#0,R4			;GET ADDRESS OF ADAPTOR CONTROL BLOCK
UBAINTADP=.-UBAINTBASE-5		;OFFSET TO START OF LOADED CODE
	JMP	@#0			;ERROR ROUTINE IN ADPERR780
UBAERRADR=.-UBAINTBASE-4
	.DSABL	LSB

	.ALIGN	LONG			; LONGWORD ALIGN VECTORS
VECTAB:					; END OF INTERRUPT CODE, START OF VECTORS
UBINTSZ=.-UBAINTBASE			; SIZE OF UBA INTERRUPT CODE
	
	.ENDC
	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	.PAGE
;
; UBA INTERRUPT SERVICE HANDLER FOR 11/750.  THIS CODE IS PLACED
; IN THE ADP, AND IT IS POINTED TO BY THE SCB VECTOR WHICH
; HANDLES UBA POWERFAIL INTERRUPTS.  USING A JSB TO DISPATCH
; TO THE ADAPTER POWERFAIL INTERRUPT CODE ALLOWS A POINTER WITH A
; KNOWN OFFSET INTO THE ADP TO BE PUSHED ON THE STACK AND USED
; BY THE CODE TO FIND THE ADP.
;
UBA1INT:
	JSB	@#0			; ERROR ROUTINE IN ADPERR750
	.WORD	0			; ZERO OUT REST OF QUADWORD
	.ENDC
	.PAGE
	.SBTTL	INI$MBADP - BUILD ADP AND INITIALIZE MBA
	.SBTTL	INI$DRADP - BUILD ADP AND INITIALIZE DR32
	.SBTTL	INI$CIADP - BUILD ADP AND INITIALIZE CI
;+
; INI$MBADP IS CALLED AFTER MAPPING THE REGISTERS FOR A MASSBUS ADAPTER.
; AN ADAPTER CONTROL BLOCK IS ALLOCATED AND FILLED.  A CRB AND IDB ARE
; ALSO ALLOCATED AND INITIALIZED. THE ADAPTER HARDWARE IS THEN INITIALIZED
; BY CALLING MBA$INITIAL.
;
; INI$DRADP IS CALLED AFTER MAPPING THE REGISTERS FOR THE DR32
; ADAPTER.  THE ADAPTER CONTROL BLOCK, CRB, AND IDB ARE ALLOCATED
; AND INITIALIZED.  THE ADAPTER HARDWARE IS THEN INITIALIZED BY
; CALLING DR$INITIAL.
;
; INI$MBADP AND INI$DRADP SHARE COMMON CODE AFTER THE TABLE OF ADAPTER
; SPECIFIC CONSTANTS IS SELECTED AND STORED IN R8.
;
; INPUT:
;	R4 - nexus identification number of this adapter
;	R11- offset from beginning of SCB to correct SCB page for this adapter
;
; OUTPUTS:
;	ALL REGISTERS PRESERVED
;-

ALONPAGD:JMP	G^INI$ALONONPAGED

	.ENABL	LSB

INI$DRADP:				; INITIALIZE DR32 DATA STRUCTURES

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; SAVE REGISTERS
	MOVAL	W^DRTAB,R8		; GET DR32 TABLE OF CONSTANTS
	MOVAB	W^DR$INT,R9		; ADDRESS OF INITERRUPT SERVICE ROUTINE
	MOVAB	W^DR$INITIAL,R10	; ADDRESS OF DEVICE INITIALIZATION
	BRB	10$			; JOIN COMMON CODE
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.ENDC				;END "NOT" 730 CONDITIONAL

INI$CIADP:				; INITIALIZE CI DATA STRUCTURES

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; SAVE REGISTERS
	MOVAL	W^CITAB,R8		; GET CI TABLE OF CONSTANTS
	MOVAB	W^CI$INT,R9		; ADDRESS OF INITERRUPT SERVICE ROUTINE
	MOVAB	W^CI$INITIAL,R10	; ADDRESS OF DEVICE INITIALIZATION
	BRB	10$			; JOIN COMMON CODE
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.ENDC				;END "NOT" 730 CONDITIONAL

INI$MBADP:				; INIT MBA DATA STRUCTURES

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ;
	MOVAL	W^MBATAB,R8		; GET MBA TABLE OF CONSTANTS
	MOVAB	W^MBA$INT,R9		; ADDRESS OF INITERRUPT SERVICE ROUTINE
	MOVAB	W^MBA$INITIAL,R10	; ADDRESS OF DEVICE INITIALIZATION
10$:					;
;
; Allocate and initialize Channel Request Block.
;
	MOVZWL	#CRB$C_LENGTH,R1	; SET SIZE OF CRB
	BSBB	ALONPAGD		; ALLOCATE SPACE FOR CRB
	MOVW	R1,CRB$W_SIZE(R2)	; SET CORRECT SIZE
	MOVB	#DYN$C_CRB,CRB$B_TYPE(R2) ; SET CORRECT TYPE
	MOVAL	CRB$L_WQFL(R2),CRB$L_WQFL(R2)	; INITIALIZE WAIT QUEUE HEADER
	MOVAL	CRB$L_WQFL(R2),CRB$L_WQBL(R2)	; FLINK AND BLINK
	MOVAB	CRB$L_INTD(R2),R0	; SET ADDRESS OF INTD AREAD
	MOVL	#^X9F163CBB,(R0)+	; "PUSHR ^M<R2,R3,R4,R5>,JSB @#"
	MOVL	R9,(R0)+		; ADDR OF XXX$INT ROUTINE
	CLRL	(R0)+			; CLEAR OUT UNNEEDED AREA
	MOVL	R10,(R0)		; ADDR OF XXX$INITIAL ROUTINE
	MOVL	R2,R10			; SAVE CRB ADDRESS
;
; Allocate and initialize Interrupt Dispatch Block.
;
	MOVZBL	ADPTAB_IDBUNITS(R8),R1	; GET # OF IDB UNITS
	MOVAL	@#IDB$C_LENGTH[R1],R1	; GET TOTAL SIZE OF IDB
	BSBB	ALONPAGD		; ALLOCATE SPACE FOR CRB
	MOVW	R1,IDB$W_SIZE(R2)	; SET STRUCTURE SIZE
	MOVB	#DYN$C_IDB, -		; AND TYPE CODE
		IDB$B_TYPE(R2)
	MOVZBW	ADPTAB_IDBUNITS(R8),-	; SET COUNT OF UNITS
		IDB$W_UNITS(R2)
	MOVL	W^SBICONF[R4], -	; SET CSR ADDRESS TO
		IDB$L_CSR(R2)		;  START OF ADAPTER REG SPACE
	MOVL	R2, -			; SET ADDRESS OF IDB INTO CRB
		CRB$L_INTD+VEC$L_IDB(R10)
	MOVL 	R2,R9			; SAVE ADDRESS OF IDB
;
; Allocate and initialize Adapter Control Block (ADP).
;
	MOVZWL	ADPTAB_ADPLEN(R8),R1	; GET SIZE OF ADAPTER
	BSBW	ALONPAGD		; ALLOCATE SPACE FOR CRB
	MOVW	R1,ADP$W_SIZE(R2)	; SET SIZE OF STRUCTURE
	MOVB	#DYN$C_ADP,ADP$B_TYPE(R2); AND TYPE CODE
	MOVL	IDB$L_CSR(R9),ADP$L_CSR(R2); SET ADDRESS OF CONFIGURATION REGISTER
	MOVW	R4,ADP$W_TR(R2)		; SET TR/SLOT-16 NUMBER OF ADAPTER
	MOVZBW	ADPTAB_ATYPE(R8),-	; SET THE ADAPTER TYPE
		ADP$W_ADPTYPE(R2)
	MOVL	R10,ADP$L_CRB(R2)	; POINT ADP TO CRB
;	CMPW	ADP$W_ADPTYPE(R2),#AT$_CI ; CI?
;	BEQL	20$			; YES, DO NOT CONNECT UP VECTORS
;
; Initialize adapter interrupt vectors in System Control Block.
;
	MOVL	G^EXE$GL_SCB,R0		; GET ADDRESS OF SCB
	ASHL	#9,R11,R5		; Turn SCB page offset into byte offset.
	ADDL	R5,R0			; set to beginning of correct SCB page.
	EXTZV	#0,#4,R4,R4		; Use low 4 bits of nexus number.
	MOVAL	^X100(R0)[R4],R0	; COMPUTE ADDR OF 1ST VECTOR
	MOVL	R0,ADP$L_AVECTOR(R2)	; SAVE ADDR OF ADAPTER'S SCB VECTORS
	MOVAL	CRB$L_INTD+1(R10),(R0)	; CONNECT VECTOR TO CRB CODE
	MOVAL	CRB$L_INTD+1(R10),64(R0); SAME FOR
	MOVAL	CRB$L_INTD+1(R10),128(R0); ALL FOUR
	MOVAL	CRB$L_INTD+1(R10),192(R0); VECTORS
;
; Continue with ADP initialization.
;
20$:	MOVAL	CRB$L_INTD+1(R10), -	; SAVE SCB VECTOR CONTENTS IN ADP
		ADP$L_MBASCB(R2)
	PUSHR	#^M<R2,R3>		; SAVE SOME REGISTERS
	MOVL	R2,R5			; COPY ADP ADDRESS
	MOVL	ADP$L_CSR(R2),R2	; VIRTUAL ADDRESS OF ADAPTER
	JSB	G^MMG$SVAPTECHK		; ADDRESS OF SPTE THAT MAPS ADAPTER
	MOVL	(R3),ADP$L_MBASPTE(R5)	; SAVE CONTENTS OF SPTE
	POPR	#^M<R2,R3>		; RESTORE REGISTERS
	MOVL	R2,CRB$L_INTD+VEC$L_ADP(R10)	; SET CRB POINTER TO ADP
	MOVL	R2,IDB$L_ADP(R9)	; AND INTO IDB
	BSBW	ADPLINK			; LINK ADP TO END OF CHAIN
;
; Initialize adapter hardware.
;
	MOVL	R9,R5			; ADDRESS OF IDB
	MOVL	IDB$L_CSR(R5),R4	; ADDRESS OF CONFIGURATION REGISTER 0
	JSB	@CRB$L_INTD+VEC$L_INITIAL(R10) ; INIT ADAPTER
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10>; RESTORE ALL REGISTERS
	RSB				; RETURN

	.DSABL	LSB
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.ENDC				;END "NOT" 730 CONDITIONAL
	.PAGE
	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS
	.SBTTL	KDZ11 Structures

	.MACRO	KDZ_REGION , PHYSICAL_ADDR , SIZE

; Macro to generate table entries that relate the PFN's of items in KDZ11
; node private space and the number of contiguous physical pages to map at
; that PFN.


	.LONG	PHYSICAL_ADDR/512	; PFN = Physical Address/512
	.BYTE	SIZE/512		; No. pages = size(in bytes)/512

$$KDZ_PRIV_SIZE=$$KDZ_PRIV_SIZE+SIZE	; Running count of amount of KDZ
					;  space mapped.
	.ENDM

$$KDZ_PRIV_SIZE=0

KDZ_PRIVATE_SPACE:

	KDZ_REGION	IO8SS$AL_NDPRIV , <KDZ$L_PCNTL-KDZ$B_BIICBASE>
	KDZ_REGION	IO8SS$AL_PCNTL  , <KDZ$B_NIBUF-KDZ$L_PCNTL>
	KDZ_REGION	IO8SS$AL_NIBUF  , <KDZ$B_EEPROM-KDZ$B_NIBUF>
	KDZ_REGION	IO8SS$AL_EEPROM , <KDZ$L_NIDATA-KDZ$B_EEPROM>
	KDZ_REGION	IO8SS$AL_NIDATA , <KDZ$L_NIADDR-KDZ$L_NIDATA>
	KDZ_REGION	IO8SS$AL_NIADDR , <KDZ$B_RCX50-KDZ$L_NIADDR>
	KDZ_REGION	IO8SS$AL_RCX50  , <KDZ$B_WATCH-KDZ$B_RCX50>
	KDZ_REGION	IO8SS$AL_WATCH  , <KDZ$S_KDZDEF-KDZ$B_WATCH>

	.LONG	0				; End of table.

	ASSUME	KDZ$S_KDZDEF		EQ	$$KDZ_PRIV_SIZE
	.ENDC
	.PAGE
	.SBTTL	INI$KDZ11
;++
;
; INPUTS:
;	R2 - VA of next free system page
;	R3 - VA of system page table entry to be used to map VA in R2
;	R4 - nexus identification number of this adapter
;
; OUTPUTS:
;
;--

INI$KDZ11:

	.IF	EQ,CPU_TYPE-PR$_SID_TYP8SS

	TSTL	G^EXE$GL_CPUNODSP	; See if we have already mapped
					;  node private space.
	BNEQ	20$			; NEQ implies yes we have.
	MOVL	R2,G^EXE$GL_CPUNODSP	; Point to VA where we will map
					;  node private space.
	MOVAB	KDZ_PRIVATE_SPACE,R0	; R0 => table that relates PFN's
					;  and the number of pages to
					;  map in node private space.
10$:
	MOVL	(R0)+,R8		; Pickup PFN to map.
	BEQL	20$			; EQL implies end of table.
	MOVZBL	(R0)+,R1		; Pickup number of pages to map.
	BSBW	MAP_PAGES		; Map these pages into system space.
	BRB	10$			; Loop thru node private space.
20$:
	.ENDC
	RSB				; Return to caller.
	.PAGE
	.SBTTL	INI$CONSOLE, init data structures for console
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is executed only once, during system initialization.
;	It initializes the CRB and IDB for boot/console device.
;
;	This routine is called from INIT.
;
; INPUTS:
;
;	R3 -->	DISK [CLASS] DRIVER DDB
;	R4 -->	DISK [CLASS] DRIVER DPT
;	R5 -->	DISK [CLASS] DRIVER UCB
;	R6 -->	RPB
;	R7 -->	ADP FOR EITHER A REAL DISK OR A PORT
;	R9 -->	PORT DRIVER DPT (IF PRESENT)
;	R10-->	PORT DIRVER UCB (IF PRESENT)
;
;--

INI$CONSOLE::
	.ENABL	LSB

	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	CMPB	RPB$B_DEVTYP(R6),-	; BOOTING FROM CONSOLE BLOCK
		#BTD$K_CONSOLE		; STORAGE DEVICE?
	BNEQ	BLD_CRB			; NO
	MOVL	#^A/CSA/@8+3,-		; YES, SET DEVICE NAME
		DDB$T_NAME(R3)		; COUNTED STRING
	.ENDC				;END "NOT" UV1 CONDITIONAL

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MOVAL	@#OPA$CRB,R8		; SET ADDRESS OF CRB
	BRW	100$
	.ENDC				;END 11/780 CONDITIONAL

	.IF	NE,CPU_TYPE-PR$_SID_TYP780 ; IF NOT A 780
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1 ; OR A UV1
	CLRL	R7			; CLEAR ADP POINTER
	MOVW	#1,UCB$W_UNIT(R5)	; SET UNIT NUMBER TO 1
	BRB	FILL_CRB
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.ENDC				;END "NOT" 780 CONDITIONAL

;
; NOW BUILD THE AUXILIARY DATA BLOCKS (CRB,IDB)
;
BLD_CRB:
	MOVL	ADP$L_CRB(R7),R8	; GET ADDRESS OF CRB IF IT EXISTS
	CMPW	#AT$_UBA,ADP$W_ADPTYPE(R7); IS THIS A UNIBUS ADAPTER?
	BEQL	FILL_CRB		; YES, ALLOCATE CRB
	BRW	100$			; NO, CRB/IDB ALREADY ALLOCATED

FILL_CRB:
	JSB	@#INI$ALLOC_CRB		; GO ALLOCATE AND SETUP CRB
	MOVL	#^X9F163FBB,CRB$L_INTD(R2) ; SET PUSHR #^M<R0,...R5>
					;  JSB @#0 INTO INTERRUPT DISPATCH
	MOVL	R7,CRB$L_INTD+VEC$L_ADP(R2)	; SET POINTER TO ADP
	MOVL	R2,R8			; SAVE CRB POINTER
	MOVZWL	#<IDB$C_LENGTH+<8*4>>,R1; SIZE TO ALLOCATE FOR IDB
	JSB	@#INI$ALONONPAGED	; ALLOCATE IDB
	MOVW	R1,IDB$W_SIZE(R2)	; SET SIZE OF IDB
	MOVB	#DYN$C_IDB,IDB$B_TYPE(R2); AND STRUCTURE TYPE CODE
	MOVL	R2,CRB$L_INTD+VEC$L_IDB(R8) ; SET IDB INTO CRB

	.IF	NE,CPU_TYPE-PR$_SID_TYP780
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1 ; IF NOT A 780 OR A UV1
	CMPB	RPB$B_DEVTYP(R6),-	; BOOTING FROM CONSOLE BLOCK
		#BTD$K_CONSOLE		; STORAGE DEVICE?
	BNEQ	10$			; NO
	ADDL3	@#EXE$GL_SCB,#^XF0,R0	; YES, GET ADDRESS OF VECTOR IN SCB
	MOVAL	CRB$L_INTD+1(R8),(R0)+	; SET ADDR IN 1ST VECTOR
	MOVAL	CRB$L_INTD2+1(R8),(R0)  ; SET ADDR IN 2ND VECTOR
	MOVL	#^X9F163FBB,CRB$L_INTD2(R8) ; STORE PUSHR #^M<R0...R5>
					    ; JMP @# IN 2ND INT. DISPATCH
	MOVL	R2,CRB$L_INTD2+VEC$L_IDB(R8); STORE ADDRESS OF IDB IN CRB
	MOVL	#PR$_CSTD, -		; STORE IPR NUMBER OF CONSOLE INTERFACE
		@CRB$L_INTD+8(R8)	; REGISTER AS DEVICE CSR ADDRESS
	BRB	100$
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.ENDC				;END "NOT" 780 CONDITIONAL

10$:	MOVL	RPB$L_CSRVIR(R6), -	; SAVE BOOT DEVICE CSR ADDRESS
		IDB$L_CSR(R2)		; IN INTERRUPT DISPATCH BLOCK
	CMPB	#BTD$K_UDA,-		; LOW ORDER BYTE OF ORIGINAL R0 TELLS
		RPB$B_DEVTYP(R6)	;  BOOT DEVICE TYPE.
	BNEQ	20$			; IF NOT BOOTING FROM A UDA BRANCH
					;  AROUND.
	MOVL	RPB$L_CSRVIR(R6), -	; COPY VIRTUAL ADDRESS OF UDA PORT CSR
		@#BOO$GB_SYSTEMID	;  TO LOW ORDER LONGWORD OF SYSTEMID
20$:
	MOVL	R7,IDB$L_ADP(R2)	; POINT IDB TO ADP
	MOVZWL	RPB$W_R0UBVEC(R6),R0	; GET USER SPECIFIED VECTOR
	BNEQ	30$			; BRANCH IF VECTOR SPECIFIED
	MOVZBL	RPB$B_DEVTYP(R6),R0	; ELSE GET DEVICE TYPE CODE
	MOVZWL	W^BOOTVECTOR-2[R0],R0	; GET DEFAULT INTERRUPT VECTOR
30$:	MOVAB	@ADP$L_VECTOR(R7)[R0],R0; COMPUTE ADDRESS OF VECTOR
	MOVAB	CRB$L_INTD+2(R8),(R0)	; SET ADDR OF INTERRUPT VECTOR

	.IF	NE,CPU_TYPE-PR$_SID_TYP780 ; IF "NOT" A 780
	.IF	NE,CPU_TYPE-PR$_SID_TYP790 ; OR A 790
	DECL	(R0)			;  BACK TWO BYTES TO PUSHR, +1 TO
	.ENDC				;  SPECIFY INTERRUPT STACK
	.ENDC
					;
100$:
	RSB				; RETURN
	.DISABLE LSB

	.SBTTL	EXE$INI_TIMWAIT - COMPUTE CORRECT TIMEWAIT LOOP VALUES
;++
; FUNCTIONAL DESCRIPTION:
;
; EXE$INI_TIMWAIT initializes EXE$GL_TENUSEC and EXE$GL_UBDELAY, cells used
; in the time-wait macros.  The first data cell, EXE$GL_TENUSEC, is the number
; of times the following loop will be executed in ten u-seconds.  This is
; done once here to calibrate the loop instead of reading the processor clock.
; The resulting number is used in the system macros TIMEWAIT and TIMEDWAIT.
;
; The first step is to initialize EXE$GL_UBDELAY.  If the bit test instruction
; in the TIMEWAIT macro is executed too rapidly in a loop, it can saturate the
; Unibus.  EXE$GL_UBDELAY is used to introduce a 3 microsecond delay loop into
; the TIMEWAIT bit test loop.
;
; This routine is called only once, from INIT.
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Time-of-day processor clock.
;	Interval timers.
;
; OUTPUT PARAMETERS:
;
;	R0 - Destroyed.
;
; IMPLICIT OUTPUTS:
;
;	EXE$GL_TENUSEC - set to appropriate value to make TIMEWAIT and TIMEDWAIT
;			 macros loop for 10 micro-seconds.
;
;	EXE$GL_UBDELAY - set to appropriate value to make TIMEWAIT and TIMEDWAIT
;			 macros loop for 3 micro-seconds in the unibus delay
;			 loop.
;
;--

EXE$INI_TIMWAIT::			; Initialize time-wait data cells
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	.ENABLE LSB

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MTPR	#0,#PR780$_NICR		; Initialize next interval count register.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MTPR	#0,#PR750$_NICR		; Initialize next interval count register.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MTPR	#0,#PR730$_NICR		; Initialize next interval count register.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	BSBW	INI$CACHE		; Initialize and enable cache.
	MTPR	#0,#PR790$_NICR		; Initialize next interval count register.
	.ENDC

	MOVL	#20000,-(SP)		; # of times to execute timed loop.
	MTPR	#^X11,#PR$_ICCS		; Start clock, no interrupts.

; * * * start of loop to time * * *
10$:	SOBGTR	(SP),10$		; Delay loop.
; * * * end of loop to time * * *

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MFPR	#PR780$_ICR,R0		; Read total time to execute loop.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MFPR	#PR750$_ICR,R0		; Read total time to execute loop.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MFPR	#PR730$_ICR,R0		; Read total time to execute loop.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	MFPR	#PR790$_ICR,R0		; Read total time to execute loop.
	.ENDC

	MTPR	#0,#PR$_ICCS		; Shut off clock.
	DIVL3	R0,#60000,G^EXE$GL_UBDELAY; Calculate number of times through
	INCL	G^EXE$GL_UBDELAY	; loop to delay 3 microseconds.

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MTPR	#0,#PR780$_NICR		; Initialize next interval count register.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MTPR	#0,#PR750$_NICR		; Initialize next interval count register.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MTPR	#0,#PR730$_NICR		; Initialize next interval count register.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	MTPR	#0,#PR790$_NICR		; Initialize next interval count register.
	.ENDC

	MOVL	#20000,R0		; Number of times to execute test loop
	MOVL	G^EXE$GL_UBDELAY,(SP)	; Get delay loop iteration count.
	MTPR	#^X11,#PR$_ICCS		; Start clock, no interrupts

; **** Start of loop to time
20$:	BITW	#^X8000,40$		; Random BITx instruction to time
	BNEQ	40$			; Random conditional branch instruction
30$:	SOBGTR	(SP),30$		; Delay 3 microseconds.
40$:	SOBGTR	R0,20$			; Loop
; **** End of loop to time

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MFPR	#PR780$_ICR,R0		; Read total time to execute loop.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MFPR	#PR750$_ICR,R0		; Read total time to execute loop.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MFPR	#PR730$_ICR,R0		; Read total time to execute loop.
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	MFPR	#PR790$_ICR,R0		; Read total time to execute loop.
	.ENDC
	MTPR	#0,#PR$_ICCS		; Shut clock off
	TSTL	(SP)+			; Pop delay loop index off stack.
	DIVL3	R0,#200000,G^EXE$GL_TENUSEC ; Calculate number of times to
	INCL	G^EXE$GL_TENUSEC	; execute the loop to kill 10 u-secs.
	
	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
;
; Store the TIMEDWAIT values calculated with cache enabled in the BOOTDRIVR
; TIMEDWAIT cells.
;
	MOVL	G^EXE$GL_RPB,R0		; Get address of RPB.
	MOVL	RPB$L_IOVEC(R0),R0	; Get address of BOOTDRIVR I/O cells.
	MOVL	G^EXE$GL_TENUSEC,-	; Store TENUSEC value in BOOTDRIVR.
		BQO$L_TENUSEC(R0)
	MOVL	G^EXE$GL_UBDELAY,-	; Store UBDELAY value in BOOTDRIVR.
		BQO$L_UBDELAY(R0)
	.ENDC

	RSB				; Return
	.DISABLE LSB
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	MOVZBL	#1,G^EXE$GL_UBDELAY	; Set UV1 value same as 11/730
	MOVZBL	#1,G^EXE$GL_TENUSEC	; Set UV1 value same as 11/730
	RSB				; Return
	.ENDC				;END UV1 CONDITIONAL

	.SBTTL	EXE$INIT_TODR  -  SET SYSTEM TIME TO CORRECT VALUE AT STARTUP
;++
; FUNCTIONAL DESCRIPTION:
;
;	EXE$INIT_TODR SOLICITS THE CORRECT TIME FROM THE OPERATOR IF NECESSARY,
;	CONVERTS THE ASCII RESPONSE TO BINARY FORMAT AND CALLS AN INTERNAL
;	ENTRY POINT OF THE $SETIME SYSTEM SERVICE TO SET THE NEW SYSTEM TIME
;	IN MEMORY WITHOUT MODIFYING THE CONTENTS OF THE SYSTEM DISK.
;
;	IF THE TIME WOULD NORMALLY BE SOLICITED FROM AN OPERATOR, BECAUSE
;	THE HARDWARE TIME OF YEAR CLOCK IS ZERO, THEN THE SYSGEN PARAMETER
;	"TPWAIT" IS CHECKED.  IF IT IS ZERO, THEN IT IS ASSUMED THAT NO
;	OPERATOR IS PRESENT AND THE SYSTEM IS BOOTED USING THE LAST TIME
;	RECORDED IN THE SYSTEM IMAGE.  IF THE PARAMETER IS NON ZERO THEN
;	THAT TIME IS USED AS THE MAXIMUM TIME TO WAIT BEFOR ASSUMING THAT
;	THERE IS NO OPERATOR AND BOOTING ANY WAY.  IF THE PARAMETER IS
;	NEGATIVE, THE SYSTEM WILL WAIT FOREVER.
;
;	THIS ROUTINE IS CALLED ONLY ONCE, FROM SYSINIT OR STASYSGEN.
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	TIME-OF-DAY PROCESSOR CLOCK.
;
; OUTPUT PARAMETERS:
;
;	R0,R1 - DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	EXE$GQ_SYSTIME - SET TO CURRENT TIME IN 100 NANOSECOND UNITS SINCE
;			 17-NOV-1858  00:00:00.
;
;--

;
; Stack storage offsets:
;
TTCHAN  = ^X00				; CHANNEL FOR TERMINAL (LONGWORD)
TTNAME  = ^X04				; STRING DESCRIPTOR FOR OPERATOR'S TERM
TMPDESC = ^X0C				; TEMPORY STRING DESCRIPTOR (QUADWORD)
INTIME  = ^X14				; INPUT TIME VALUE (QUADWORD)
LINBUF  = ^X1C				; INPUT LINE BUFFER (5 LONGWORDS)
LINBUFSIZ = ^X14			;  (LENGTH OF LINE BUFFER IN BYTES)

;
; PURE DATA
;
TERM_NAMADR:
	.ASCII	\OPA0\			; DEVICE NAME FOR OPERATOR'S TERMINAL
TERM_NAMSIZ = . - TERM_NAMADR
TIMERR:	.ASCIC	\invalid date/time\	;
TIMEPROMPT:
	.BYTE	NPROMPT
	.ASCII	<13><10>/PLEASE ENTER DATE AND TIME (DD-MMM-YYYY  HH:MM)  /
NPROMPT=.-TIMEPROMPT-1
 

EXE$INIT_TODR::				; SET CORRECT TIME
	.ENABLE LSB
	PUSHR	#^M<R2,R3,R4,R5,R6,R8,R9,R10> ; SAVE REGISTERS
	SUBL	#4*12,SP		; SCRATCH STORAGE
	MOVL	SP,R6			; SAVE ADDRESS OF SCRATCH STORAGE
	MOVZBL	#TERM_NAMSIZ,TTNAME(R6)	; SET SIZE OF OPERATOR'S TERM NAME AND
	MOVAB	W^TERM_NAMADR,TTNAME+4(R6) ;  PIC ADDRESS INTO TERM NAME DESC
	BBS	S^#EXE$V_SETTIME,G^EXE$GL_FLAGS,READTIME ; BR TO SOLICIT TIME


	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MFPR	#PR780$_TODR,R0		; GET TIME OF DAY CLOCK VALUE
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MFPR	#PR750$_TODR,R0		; GET TIME OF DAY CLOCK VALUE
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MFPR	#PR730$_TODR,R0		; GET TIME OF DAY CLOCK VALUE
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	MFPR	#PR790$_TODR,R0		; GET TIME OF DAY CLOCK VALUE
	.ENDC

	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	SUBL3	R0,G^EXE$GL_TODR,R9	; GET TOD DELTA TIME (10 MS UNITS)
	BLEQU	5$			; BRANCH IF TIME IS LATER
	CMPL	R9,#24*60*60*100	; CHECK FOR SETBACK OF ONE DAY
	BGEQU	READTIME		; MORE, MUST SOLICIT TIME
	.ENDC				;END "NOT" UV1 CONDITIONAL
	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	BRB	READTIME		; ON MICROVAX I, ALWAYS SOLICIT TIME
	.ENDC				;END UV1 CONDITIONAL
5$:	CLRQ	INTIME(R6)		; NULL ARGUMENT FOR EXE$SETIME_INT
	BRW	200$			; RETURN TO CALLER

READTIME:				; SOLICIT TIME 
	CLRL	R9			; CLEAR A FLAG
	CVTWL	G^SGN$GW_TPWAIT,R8	; PICK UP TIMEOUT WAIT INTERVAL
	BGTR	8$			; POSITIVE, WAIT THAT PERIOD ONCE
	BLSS	7$			; NEGATIVE IS WAIT FOREVER
6$:
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	ADDL3	#1,G^EXE$GL_TODR,R0	; ZERO, SET TIME-OF-DAY CLOCK TO
	.ENDC				;END "NOT" UV1 CONDITIONAL

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MTPR	R0,#PR780$_TODR		;   KNOWN VALUE + 10 MSEC AND FINISH UP
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MTPR	R0,#PR750$_TODR		;   KNOWN VALUE + 10 MSEC AND FINISH UP
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MTPR	R0,#PR730$_TODR		;   KNOWN VALUE + 10 MSEC AND FINISH UP
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	MTPR	R0,#PR790$_TODR		;   KNOWN VALUE + 10 MSEC AND FINISH UP
	.ENDC

	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	BRB	5$			;
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	MOVQ	G^EXE$GQ_TODCBASE,INTIME(R6) ; USE LAST KNOWN SYSTEM TIME
	BRW	200$			; IF THE USER REQUESTS NO PROMPTING
	.ENDC

7$:	MOVL	#20,R8			; STARTING WAIT
	INCL	R9			; NEGATIVE - WAIT FOREVER
8$:	$ASSIGN_S	TTNAME(R6),TTCHAN(R6) ; AND ASSIGN TO INPUT DEVICE
	BLBC	R0,6$			; ERROR - FALL BACK TO STORED TIME
10$:	MOVAB	W^TIMEPROMPT,R2		; GET ADDRESS OF PROMPT STRING
	MOVZBL	(R2)+,R3		; AND LENGTH
	$QIOW_S	#0,W^TTCHAN(R6),-	; PROMPT AND READ TIME
		#<IO$_READPROMPT!IO$M_PURGE!IO$M_TIMED!IO$M_CVTLOW>,-
		TMPDESC(R6),,,-		;  I/O STATUS BLOCK , NO AST OR PARAM
		LINBUF(R6),#LINBUFSIZ,-	;  BUFFER ADDRESS AND SIZE
		R8,#0,-			;  TIME OUT
		R2,R3			;  PROMPT ADDRESS AND SIZE
	BLBC	R0,6$			; ERROR - FALL BACK TO STORED TIME
	MOVQ	TMPDESC(R6),R4		; GET COMPLETION STATUS
	BLBS	R4,20$			; CONTINUE IF SUCCESSFUL READ
	BLBC	R9,6$			; FAILED ON ONE-TIME READ, RETURN
	MOVAB	1(R8)[R8],R8		; (2 * TIMEOUT) + 1
	MOVZWL	R8,R8			; BOUND TIMEOUT
	BRB	10$			; TRY AGAIN FOR TIME
20$:					; SOMETHING WAS INPUT
	MOVZWL	TMPDESC+2(R6),TMPDESC(R6) ; FORM DESCRIPTOR FOR BUFFER
	MOVAB	LINBUF(R6),TMPDESC+4(R6) ; SET DESCRIPTOR ADDRESS
	$BINTIM_S TMPDESC(R6),INTIME(R6) ; CONVERT TO BINARY TIME
	BLBC	R0,89$			; INVALID TIME
	TSTL	INTIME+4(R6)		; CHECK FOR DELTA TIME
	BGTR	100$			; BRANCH IF NOT - OK
89$:					; INVALID TIME VALUE INPUT
	MOVAB	W^TIMERR,R2		; ADDRESS OF ERROR MESSAGE 
	MOVZBL	(R2)+,R3		; GET STRING LENGTH
	$QIOW_S	#0,TTCHAN(R6),-		; GIVE ERROR MESSAGE
		#IO$_WRITEVBLK,-	;
		,,,-			;  NO I/O STATUS,AST OR AST PARAM
		(R2),R3	,-		;  BUFFER ADDRESS, LENGTH
		#0,#32			;  SET CARRIAGE CONTROL TO CR/LF
	BRW	10$			; AND TRY AGAIN
100$:					; EXIT
	$DASSGN_S TTCHAN(R6)		; DE-ASSIGN TERMINAL CHANNEL
200$:   PUSHAQ	INTIME(R6)		; SET NEW SYSTEM TIME
	CALLS	#1,G^EXE$SETIME_INT	; USE TODR CLOCK TO SET SYSTEM TIME
	MOVQ	G^EXE$GQ_TODCBASE,G^EXE$GQ_BOOTTIME ; SAVE BOOT TIME
	ADDL	#12*4,SP		; CLEAN OFF SCRATCH STORAGE
	POPR	#^M<R2,R3,R4,R5,R6,R8,R9,R10> ; RESTORE REGISTERS

;
; Fall through into the deallocate logic.
;
;	RSB				; *** This goes in if another piece of
					; *** initialization code is added that
					; *** is executed after EXE$INI_TIMWAIT.
	.DISABLE LSB


DEAL_INIT_CODE:				; DEALLOCATE THE INITIALIZATION CODE
;
; It is the duty of the last-executed, loadable initialization
; routine to make itself and all other such routines disappear, i.e.,
; release the space they occupy to non-paged pool.  Each routine's vector
; must be disconnected, e.g., be made to point to the symbol, EXE$LOAD_ERROR.  
;
; NOTE:  This means that new initialization routines should be added
; 	 to this module in a particular order, not necessarily at the
;	 end of the module!
;
	.ENABLE LSB
	MOVQ	R2,-(SP)		; Save some registers

;
; First find the vectors that point to these initialization routines
; and reset them to point to EXE$LOAD_ERROR.
;
	MOVAB	W^SYSL$BEGIN,R0		; Compute bounds of releasable piece:
	ADDL3	#<STAY_HEADER-SYSL$BEGIN>,R0,R1 ; starting and ending addresses.
	MOVAB	G^EXE$AL_LOAVEC,R2	; Get starting address of vectors.
	MOVAB	G^EXE$LOAD_ERROR,R3	; Get end of vectors.
10$:	CMPW	(R2),#^X9F17		; Is this JMP @# ?
	BEQL	30$			; Br if yes, skip past it.
	CMPB	3(R2),#^X80		; Is this a system space address
	BNEQ	40$			; Br if no, assume it's a HALT instr.
	CMPL	(R2),R0			; Is address before the releasable
	BLSSU	20$			;  piece of memory?  Br on yes.
	CMPL	(R2),R1			; Is address after the releasable
	BGTRU	20$			;  piece of memory?  Br on yes.
	MOVAB	G^EXE$LOAD_ERROR,(R2)	; Reset this vector.
20$:	ADDL	#2,R2			; Point past this vector.
30$:	INCL	R2			; Come here to point past JMP @#.
40$:	INCL	R2			; Come here to point past HALT.
	CMPL	R2,R3			; Past the end of the vectors?
	BLSSU	10$			; Keep searching vectors.
;
; Now release the memory to non-paged pool.
;
	MOVAB	W^SYSL$BEGIN,R0		; Point to start of module
	MOVZWL	#<STAY_HEADER-SYSL$BEGIN>,R1 ; Length to vaporize
	BRW	50$			; Br to code that is not released.

	.PSECT	$$$INIT__END,PAGE	; 'PAGE' SINCE 16-BYTE ALIGN IS NOT

STAY_HEADER:
	.LONG	0,0
	.WORD	<SYSL$END-STAY_HEADER>
	.BYTE	DYN$C_LOADCODE
	.BYTE	0

50$:	JSB	@#EXE$DEANONPGDSIZ	; Just the smile on the Chesire cat
	MOVQ	(SP)+,R2		; Restore
	RSB				; Return.

	.DISABLE LSB
	.END
