	.TITLE	PROCESS	PROCESS FORMATTING ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	ROUTINES TO FORMAT PROCESS INFORMATION
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V03-013	MSH0072		Michael S. Harvey	3-Aug-1984
;		Correct some bugs causing errors getting data for
;		processes other than your own.
;
;	V03-012 EMB0101		Ellen M. Batbouta	14-Jun-1984
;		Decode MWAIT so as to correctly display the resource
;		a process is waiting for when a SHOW PROCESS or SHOW
;		SUMMARY command is issued.  Show the full device name
;		on a SHOW PROCESS/CHANNELS display.
;
;	V03-011	PRB0314		Paul Beck	28-Feb-1984  16:48
;		Use longword formatting for BUFIO byte count/limit.
;
;	V03-010	WMC0002		Wayne Cardoza		02-Dec-1983
;		Some PHD fields have changed to longwords
;
;	V03-009	WMC0001		Wayne Cardoza		11-Jul-1983
;		Support separate display of process P0 and P1 page tables.
;
;	V03-008	TCM0001		Trudy C. Matthews	 12-Apr-1983
;		Make sure references to working set list offsets in the
;		process header are treated as unsigned words.
;
;	V03-007	CWH1004		CW Hobbs		 26-Mar-1983
;		Run process names through !AF directive to keep escape
;		sequences from the displays.
;
;	V03-006	CWH1003		CW Hobbs		 23-Mar-1983
;		Shuffle items in SHOW SUMMARY a little.
;
;	V03-005	CWH1002		CW Hobbs		 1-Mar-1983
;		Display extended PIDs in heading and SHOW PROCESS /PCB
;		display.  Change SHOW SUMMARY to add /IMAGE qualifier
;		and alter items in summary line.
;
;	V03-004 MSH0002		Maryann Hinden		22-Oct-1982
;		Pass extra argument to SHOW_PROC_LOCK.
;
;	V03-003	LMP0033		L. Mark Pilant,		25-Jun-1982  15:36
;		Fix a problem introduced by KTA0103.  Also, fix a bug that
;		caused a BADPROC error message to appear if a display for all
;		processes terminated abnormally.
;
;	V03-002	LMP0031		L. Mark Pilant,		17-Jun-1982  13:25
;		Add support for SHOW PROCESS/CHANNELS.
;
;	V03-001 MSH0001		Maryann Hinden		10-Jun-1982
;		Add SHOW PROC/LOCK.
;
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINITIONS
;
	$PCBDEF			; PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF			; PROCESS HEADER DEFINITIONS
	$WSLDEF			; WORKING SET LIST DEFINITIONS
	$SECDEF			; SECTION TABLE DEFINITIONS
	$IFDDEF			; IMAGE FILE DESCRIPTOR DEFINITIONS
	$JIBDEF			; JOB INFORMATION BLOCK DEFINITIONS
	$OPTDEF			; OPTION DEFINITIONS
	$CCBDEF			; CHANNEL CONTROL BLOCK OFFSETS
	$DDBDEF			; DEVICE DATA BLOCK OFFSETS
	$DYNDEF			; DYNAMIC BLOCK TYPE CODES
	$FCBDEF			; FCB OFFSETS
    	$RSNDEF			; RESOURCE NAME DEFINITIONS
    	$SBDEF			; SYSTEM BLOCK DEFINITIONS
	$STSDEF			; STATUS FIELD DEFINITIONS
	$UCBDEF			; UCB OFFSETS
	$WCBDEF			; WCB OFFSETS

;
;	LOCAL MACRO DEFINITIONS
;

	.MACRO	CSTABLE,LEN
	CSL =	LEN
	.ENDM


	.MACRO	CS,TEXT
	SAV = .
	.ASCIC	\TEXT\
	. = SAV + CSL
	.ENDM

	.SBTTL	STORAGE DEFINITIONS
;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

	.default displacement,long

PCBADR::
	.BLKL	1			; ADDRESS OF PCB

PCB::
	.BLKB	PCB$C_LENGTH		; BUFFER TO HOLD PCB

PHDADR::
	.BLKL	1			; ADDRESS OF PHD

PHD::
	.BLKB	PHD$C_LENGTH		; BUFFER TO HOLD PHD

JIBADR::	
	.BLKL	1			; ADDRESS OF JIB
JIB::
	.BLKB	JIB$C_LENGTH		; BUFFER TO HOLD JIB

CHANTBL_SIZE:
	.BLKL	1			; SIZE OF THE CHANNEL TABLE
CHANTBL_ADDR:
	.BLKL	1			; ADDRESS OF THE CHANNEL TABLE COPY
CHANNEL_DEVICE:
CHANDEV_SIZE:
	.BLKL	1			; SIZE OF DEVICE NAME FOR CHANNEL
	.ADDRESS	CHANDEV_NAME+1	; ADDRESS OF NAME STORAGE
CHANDEV_NAME:
	.BLKB	16			; STORAGE FOR THE DEVICE NAME
FILE_NAME:
	.LONG	132			; FILE NAME DESCRIPTOR
	.ADDRESS	FILE_NAMETXT
FILE_NAMETXT:
	.BLKB	132
NODE:
    	.BLKB	SB$S_NODENAME		; NODE NAME
FCB:
	.BLKB	FCB$C_LENGTH		; STORAGE FOR THE FCB
WCB:
	.BLKB	WCB$C_LENGTH		; STORAGE FOR THE WCB (NO MAP POINTERS)

	.PSECT	PROCESS,EXE,NOWRT

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

NOTAVAIL:
	.ASCIC	'-- image name not available --'

	.MACRO	$DEFINI NAME,P1,P2
	.ENDM
	.MACRO	$DEFEND NAME,P1,P2
	.ENDM
	.MACRO	$EQU SYMBOL,VALUE
S = %LOCATE(<_>,SYMBOL)+1
L = %LENGTH(SYMBOL)-S
	.ASCIC	/%EXTRACT(S,L,SYMBOL)/
	.BLKB	8-<L+1>
	.ENDM	$EQU

STATE_TABLE:
	.ASCIC	'ILLEGAL'		; FOR ZERO CASE
	$STATEDEF			; TABLE OF PROCESS STATE NAMES

	.MDELETE	$DEFINI,$DEFEND,$EQU

    	$STATEDEF

PROCESS_STATUS:
	TABLE	PCB$V_,<RES,DELPEN,FORCPEN,INQUAN,PSWAPM,RESPEN,SSFEXC,-
		SSFEXCE,SSFEXCS,SSFEXCU,SSRWAIT,SUSPEN,WAKEPEN,WALL,-
		BATCH,NOACNT,SWPVBN,ASTPEN,PHDRES,HIBER,LOGIN,NETWRK,-
		PWRAST,NODELET>

;
; Below is a complete list of the resources a process could be waiting for
; if it is in mwait state.  The mutex resource is a special case.  It is 
; detected by examining the field, PCB$L_EFWM, in the pcb.  This field will
; contain the address of the mutex if the process is waiting for one. 
; Otherwise this field will contain the number of the resource when in mwait.
;

ASSUME	RSN$_MAX  EQ   15

RESOURCE_WAIT:
    	ADDR_TABLE	RSN$_ , <-
    			<ASTWAIT,AST>,-
    			<MAILBOX,MBX>,-
    			<NPDYNMEM,NONPAGED>,-
    			<PGFILE,PAGING>,-
    			<PGDYNMEM,PAGED>,-
    			<BRKTHRU,BREAK>,-
    			<IACLOCK,IMGACT>,-
    			<JQUOTA,JOB_QUOTA>,-
    			<LOCKID,LOCKS>,-
    			<SWPFILE,SWAP>,-
    			<MPLEMPTY,MPAGE_EMPTY>,-
    			<MPWBUSY,MPAGE_BUSY>,-
    			<SCS,SCSWAIT>,-
    			<CLUSTRAN,CLUSTER>-
    			>

AST:
    .ASCIC	/RWAST/			; RESOURCE WAIT FOR AST COMPLETION

MBX:
    .ASCIC	/RWMBX/			; MAILBOX FULL

NONPAGED:
    .ASCIC	/RWNPG/			; NONPAGED DYNAMIC MEMORY

PAGING:
    .ASCIC	/RWPFF/			; PAGE FILL FULL

PAGED:
    .ASCIC	/RWPAG/			; PAGED DYNAMIC MEMORY

BREAK:
    .ASCIC	/RWBRK/			; BREAKTHROUGH

IMGACT:
    .ASCIC	/RWIMG/			; IMAGE ACTIVATION LOCK

JOB_QUOTA:	
    .ASCIC	/RWQUO/			; JOB POOLED QUOTA

LOCKS:
    .ASCIC	/RWLCK/			; LOCK IDENTIFICATION DATABASE

SWAP:
    .ASCIC	/RWSWP/			; SWAP FILE SPACE

MPAGE_EMPTY:
    .ASCIC	/RWMPE/			; MODIFIED PAGE LIST EMPTY

MPAGE_BUSY:
    .ASCIC	/RWMPB/			; MODIFIED PAGE LIST BUSY

SCSWAIT:
    .ASCIC	/RWSCS/			; SYSTEM COMMUNICATIONS

CLUSTER:
    .ASCIC	/RWCLU/			; CLUSTER STATE TRANSITION

MWAIT:					; Process is waiting for the resource,
    .ASCIC	/MUTEX/			; mutex.

GBL_TABLE:
	.ASCIC	''
	.ASCIC	'GBL '
CRF_TABLE:
	.ASCIC	''
	.ASCIC	'CRF '
DZRO_TABLE:
	.ASCIC	''
	.ASCIC	'DZERO '
WRT_TABLE:
	.ASCIC	''
	.ASCIC	'WRT '

VALID_TABLE:
	.ASCIC	''
	.ASCIC	' VALID'
PAGTYP_TABLE:
	.ASCIC	'PROCESS'
	.ASCIC	'SYSTEM '
	.ASCIC	'GLOBAL '
	.ASCIC	'GBLWRT '
	.ASCIC	'PPGTBL '
	.ASCIC	'GPGTBL '
	.ASCIC	'       '
	.ASCIC	'       '
MODIFY_TABLE:
	.ASCIC	''
	.ASCIC	' MODIFIED'
WSLOCK_TABLE:
	.ASCIC	''
	.ASCIC	' WSLOCK'
PFNLOCK_TABLE:
	.ASCIC	''
	.ASCIC	' PFNLOCK'
GOODPAGE_TABLE:
	.ASCIC	''
	.ASCIC	' GOODPAGE'

CHANBUSY_TABLE:
	.ASCIC	''
	.ASCIC	'Busy '
CHANDPND_TABLE:
	.ASCIC	''
	.ASCIC	'Dpnd '
CHANSEC_TABLE:
	.ASCIC	''
	.ASCIC	' (section file)'

AST_TABLE:
	CSTABLE	8
	CS	NONE
	CS	K
	CS	E
	CS	KE
	CS	S
	CS	KS
	CS	ES
	CS	KES
	CS	U
	CS	KU
	CS	EU
	CS	KEU
	CS	SU
	CS	KSU
	CS	ESU
	CS	KESU

HDRSTR1:
	STRING	<Process index: !XW   Name: !AF   Extended PID: !XL>

	.SBTTL	DISPLAY_PROCS -- DISPLAY PROCESS DATA
;---
;
;	DISPLAY_PROCS
;
;	SHOWS INFORMATION ABOUT EACH PROCESS IN THE SYSTEM.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

DISPLAY_PROCS::
	.WORD	^M<R2,R3,R4>

	REQMEM	@SCH$GL_PCBVEC,R2	; VECTOR OF PCB ADDRESSES
	REQMEM	@SCH$GL_MAXPIX,R3	; GET MAXIMUM PROCESS INDEX

	CLRL	R4			; INITIALIZE CURRENT INDEX
	CLRL	PROC_NAME		;SET TO PREVIOUS PROCESS IN CASE OF ERROR
10$:
	MOVAL	(R2)[R4],R1		; ADDRESS OF POINTER TO PCB
	REQMEM	(R1),PCBADR		; GET ADDRESS OF PCB
	REQMEM	@PCBADR,PCB,#PCB$C_LENGTH	; GET PCB
	TSTW	PCB+PCB$L_PID		; CHECK IF PROCESS INDEX = 0
	BNEQ	20$			; BRANCH IF NOT
	TSTL	R4			; CHECK IF NULL PROCESS SLOT
	BNEQ	90$			; SKIP IF NOT
20$:
	TSTL	PCB+PCB$L_PHD		; SWAPPED OUT?
	BEQL	30$			; BRANCH IF SO
	REQMEM	@PCB+PCB$L_PHD,PHD,#PHD$C_LENGTH ; READ PHD
	MOVAL	P0BR,R0			; 4 LONGWORDS
	MOVAB	PHD,R1
	MOVQ	PHD$L_P0BR(R1),(R0)	; SETUP RELOCATION REGISTERS
	MOVQ	PHD$L_P1BR(R1),8(R0)
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,4(R0),4(R0)
30$:	MOVL	PCB+PCB$L_PID,PROC_PID	; SET PID OF PROCESS TO READ
	CALLS	#0,B^DISPLAY_PROCESS	; DISPLAY PROCESS INFORMATION
90$:
	AOBLEQ	R3,R4,100$		; CONTINUE UNTIL DONE
	BRB	110$
100$:	BRW	10$
110$:	STATUS	SUCCESS
	RET

	.SBTTL	DISPLAY_PROCESS -- DISPLAY PROCESS INFORMATION
;---
;
;	DISPLAY_PROCESS
;
;	THIS ROUTINE FORMATS ALL INFORMATION ABOUT A SINGLE
;	PROCESS GIVEN THE PROCESS CONTROL BLOCK.
;
;   INPUTS:
;
;	PCB = PROCESS CONTROL BLOCK FOR PROCESS
;
;   OUTPUTS:
;
;	NONE
;
;---

DISPLAY_PROCESS::
	.WORD	^M<R2,R3,R4,R5>
	MOVC5	#0,(SP),#0,#JIB$C_LENGTH,JIB	; PRE-ZERO JIB IN CASE NOT THERE
	MOVL	PCB+PCB$L_JIB,JIBADR	; CHECK FOR JIB
	BEQL	5$			; BR IF NONE
	REQMEM	@JIBADR,JIB,#JIB$C_LENGTH	; GET JIB
5$:
	MOVAL	PCB,R2
	MOVAL	PHD,R3
	ALLOC	80,R4			; 80 BYTE BUFFER FOR HEADER
	PUSHL	PCB$L_EPID(R2)		; EXTENDED PROCESS ID
	PUSHAB	PCB$T_LNAME+1(R2)	; PROCESS NAME
	MOVZBL	PCB$T_LNAME(R2),-(SP)	; PROCESS NAME
	PUSHL	PCB$L_PID(R2)		; PROCESS INDEX
	PUSHL	R4
	PUSHL	R4
	PUSHAB	HDRSTR1			; FAO CONTROL STRING
	CALLS	#7,G^SYS$FAO		; FORMAT TITLE STRING
	PUSHL	R4
	CALLS	#1,SET_HEADING		; SET NEW HEADING
	SKIP	PAGE

	MOVL	OPTIONS,R4
	BITL	#^C<OPT$M_SYSPROC>,R4	; CHECK IF ANY OPTION SPECIFIED
	BEQL	10$			; DEFAULT IS PCB
	BBC	#OPT$V_PCB,R4,20$	; CHECK IF /PCB SPECIFIED
10$:
	CALLS	#0,SHOW_PCB		; SHOW SOME PCB FIELDS
20$:
	BITL	#<OPT$M_PHD! -		; IF ANY OF THESE OPTIONS CHOSEN
		OPT$M_REGS! -
		OPT$M_WSL! -
		OPT$M_PST! -
		OPT$M_PPT! -
		OPT$M_CHAN>,R4
	BEQL	70$			; SKIP READING PHD IF NONE
	TSTL	PCB$L_PHD(R2)		; PROCESS RESIDENT?
	BNEQ	25$			; XFER IF SO
	BRW	100$			; ELSE GIVE A WARNING
25$:	REQMEM	@PCB$L_PHD(R2),(R3),#PHD$C_LENGTH  ; READ PROCESS HEADER

	BBC	#OPT$V_PHD,R4,30$	; CHECK IF /PHD SPECIFIED
	CALLS	#0,SHOW_PHD		; SHOW PROCESS HEADER
30$:	BBC	#OPT$V_REGS,R4,40$	; CHECK IF /REGS SPECIFIED
	CALLS	#0,SHOW_REGS		; SHOW SAVED REGISTERS
40$:	BBC	#OPT$V_WSL,R4,50$	; CHECK IF /WSL SPECIFIED
	CALLS	#0,SHOW_WSL		; SHOW WORKING SET LIST
50$:	BBC	#OPT$V_PST,R4,60$	; CHECK IF /PST SPECIFIED
	CALLS	#0,SHOW_PST		; SHOW PROCESS SECTION TABLE
60$:	BBC	#OPT$V_PPT,R4,70$	; CHECK IF /PPT SPECIFIED
	CALLS	#0,SHOW_PPT		; SHOW PROCESS PAGE TABLES
70$:	BBC	#OPT$V_RMS,R4,80$	; CHECK IF /RMS SPECIFIED
	BBS	#OPT$V_RMSD,R4,71$	; CHECK IF /RMS=... SPECIFIED
	CALLS	#0,SHOW_RMS		; SHOW CURRENTLY SELECTED RMS STRUCTS
	BRB	80$			; GO ON TO NEXT OPTION
71$:	CALLS	#0,SHOW_RMS_DIS		; SHOW RMS STURCTS SPECIFIED ON 
					;  THIS COMMAND
80$:	BBC	#OPT$V_LCK,R4,85$	; CHECK IF /LOCK SPECIFIED
	PUSHAB	PCBADR			; PASS ON ADDRESS OF PCB IN SYSTEM
	PUSHAB	PCB			; PASS ON ADDRESS OF PCB COPY IN SDA
	CALLS	#2,SHOW_PROC_LOCK	; SHOW LOCKS OWNED BY PROCESS

85$:	BBC	#OPT$V_CHAN,R4,90$	; CHECK IF /CHANNELS SPECIFIED
	CALLS	#0,SHOW_CHANNELS	; DISPLAY PROCESS CHANNEL INFORMATION

90$:	STATUS	SUCCESS			; EXIT
	RET

100$:	SKIP	1			; IN CASE ALL PROCESSES ARE DISPLAYED
	MOVL	#<<MSG$_NOTRES&^XFFFFFFF8>!STS$K_WARNING>,R0	; SET STATUS
	SIGNAL	1			; SIGNAL WARNING
	BRB	70$			; MUST RETURN SUCCESS TO TPARSE

	.SBTTL	SHOW_PCB -- SHOW PROCESS CONTROL BLOCK
;---
;
;	SHOW_PCB
;
;	THIS ROUTINE FORMATS SOME INTERESTING FIELDS IN THE
;	PROCESS CONTROL BLOCK FOR EASY READING.
;
;   INPUTS:
;
;	PCB = CURRENT PROCESS CONTROL BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_PCB:
	.WORD	^M<R2>

	MOVAL	PCB,R2
	ENSURE	12
	ALLOC	80			; 80 BYTE OUTPUT BUFFER
	PUSHL	PCB$L_STS(R2)		; PROCESS STATUS
	PUSHAB	PROCESS_STATUS		; BIT DEFINITION TABLE	
	CALLS	#2,TRANSLATE_BITS	; TRANSLATE BITS INTO NAMES
	PUSHL	SP			; ADDRESS OF RESULT DESCRIPTOR
	PUSHL	PCB$L_STS(R2)
	PRINT	2,<Process status:  !XL   !AS>
	SKIP	1

	PUSHL	JIBADR			; ADDRESS OF JIB
	PUSHL	PCBADR			; ADDRESS OF PCB
	PRINT	2,<-
PCB address              !XL    -
JIB address              !XL>

	PUSHL	PCB$L_WSSWP(R2)
	PUSHL	PCB$L_PHD(R2)
	PRINT	2,<-
PHD address              !XL    -
Swapfile disk address    !XL>

	PUSHL	JIB+JIB$W_PRCCNT
	PUSHL	JIB+JIB$L_MPID		; MASTER PID
	PRINT	2,<-
Master internal PID      !XL    -
Subprocess count         !8UW>

	PUSHL	PCB$L_OWNER(R2)		; CREATOR PID
	PUSHL	PCB$L_PID(R2)
	PRINT	2,<-
Internal PID             !XL    -
Creator internal PID     !XL>

	PUSHL	PCB$L_EOWNER(R2)	; CREATOR EXTENDED PID
	PUSHL	PCB$L_EPID(R2)		; EXTENDED PID
	PRINT	2,<-
Extended PID             !XL    -
Creator extended PID     !XL>

	PUSHL	PCB$W_TMBU(R2)
    	CMPW	PCB$W_STATE(R2),#SCH$C_MWAIT	; CHECK FOR MWAIT
    	BNEQ	15$			; NOT EQUAL, TRANSLATE TO STATE NAME
10$:	PUSHL	R2			; SAVE R2, DETERMINE RESOURCE WAIT STATE
    	MOVL	PCB$L_EFWM(R2),R2	; RESOURCE WAIT
	MOVAB	RESOURCE_WAIT,R3	; ADDRESS OF TABLE OF STATES
	JSB	G^TRANSLATE_ADDRESS	; DETERMINE STATE
    	MOVL	(SP)+,R2		; RESTORE R2
    	BNEQ	12$			; MATCH FOUND, IF NOT EQUAL
    	TSTL	PCB$L_EFWM(R2)		; CHECK FOR MUTEX ADDRESS
    	BGEQ	15$			; BRANCH IF NOT ADDRESS
    	PUSHAB	MWAIT			; ADDRESS OF MUTEX COUNTED STRING	
    	BRB	20$			; DISPLAY
12$:	PUSHL	R0			; ADDRESS OF RESOURCE WAITING FOR
    	BRB	20$			; DISPLAY
15$:
	MOVZWL	PCB$W_STATE(R2),R1
	PUSHAQ	STATE_TABLE[R1]
20$:
	PRINT	2,<-
State                       !5AC    -
Termination mailbox          !XW>

	MOVZBL	PCB$B_ASTEN(R2),R1
	PUSHAQ	AST_TABLE[R1]
	MOVZBL	PCB$B_PRI(R2),-(SP)
	SUBL3	(SP),#31,(SP)
	PRINT	2,<-
Current priority         !8UB    -
AST's enabled                !4AC>

	MOVZBL	PCB$B_ASTACT(R2),R1
	PUSHAQ	AST_TABLE[R1]
	MOVZBL	PCB$B_PRIB(R2),-(SP)
	SUBL3	(SP),#31,(SP)
	PRINT	2,<-
Base priority            !8UB    -
AST's active                 !4AC>

	PUSHL	PCB$W_ASTCNT(R2)
	PUSHL	PCB$W_MEM(R2)
	PUSHL	PCB$W_GRP(R2)
	PRINT	3,<-
UIC                     [!3OW,!3OW]    -
AST's remaining          !8UW>

	PUSHL	PCB$W_BIOLM(R2)		; BUFFERED I/O LIMIT
	PUSHL	PCB$W_BIOCNT(R2)	; BUFFERED I/O COUNT
	PUSHL	PCB$W_MTXCNT(R2)	; MUTEX COUNT
	PRINT	3,<-
Mutex count              !8UW    -
Buffered I/O count/limit   !6UW/!UW>

	PUSHL	PCB$W_DIOLM(R2)
	PUSHL	PCB$W_DIOCNT(R2)
	PUSHL	PCB$B_WEFC(R2)
	PRINT	3,<-
Waiting EF cluster       !8UB    -
Direct I/O count/limit     !6UW/!UW>

	PUSHL	JIB+JIB$L_BYTLM
	PUSHL	JIB+JIB$L_BYTCNT
	PUSHL	PCB$L_WTIME(R2)
	PRINT	3,<-
Starting wait time       !XL    -
BUFIO byte count/limit     !6UL/!UL>

	PUSHL	JIB+JIB$W_FILCNT
	PUSHL	PCB$L_EFWM(R2)
	PRINT	2,<-
Event flag wait mask     !XL    -
# open files allowed left  !6UW>

	PUSHL	JIB+JIB$W_TQCNT
	PUSHL	PCB$L_EFCS(R2)
	PRINT	2,<-
Local EF cluster 0       !XL    -
Timer entries allowed left !6UW>

	PUSHL	PCB$W_APTCNT(R2)
	PUSHL	PCB$L_EFCU(R2)
	PRINT	2,<-
Local EF cluster 1       !XL    -
Active page table count    !6UW>

	PUSHL	PCB$W_PPGCNT(R2)
	PUSHL	PCB$L_EFC2P(R2)
	PRINT	2,<-
Global cluster 2 pointer !XL    -
Process WS page count      !6UW>

	PUSHL	PCB$W_GPGCNT(R2)
	PUSHL	PCB$L_EFC3P(R2)
	PRINT	2,<-
Global cluster 3 pointer !XL    -
Global WS page count       !6UW>

	RET

	.SBTTL	SHOW_PHD -- SHOW PROCESS HEADER
;---
;
;	SHOW_PHD
;
;	FORMAT THE FIELDS FROM THE PROCESS HEADER.
;
;   INPUTS:
;
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_PHD:
	.WORD	^M<R2>

	MOVAL	PHD,R2			; ADDRESS OF PROCESS HEADER
	SKIP	2
	ENSURE	12
	PRINT	0,<Process header>
	PRINT	0,<-------------->
	SKIP	1
	PUSHL	PHD$L_CPUTIM(R2)
	PUSHL	PHD$L_FREP0VA(R2)
	PRINT	2,<-
First free P0 address      !8XL!4* -
Accumulated CPU time       !8XL>
	PUSHL	PHD$W_QUANT(R2)
	PUSHL	PHD$L_FREPTECNT(R2)
	PRINT	2,<-
Free PTEs between P0/P1    !8UL!4* -
CPU since last quantum     !8XW>
	PUSHL	JIB+JIB$W_PRCLIM
	PUSHL	PHD$L_FREP1VA(R2)
	PRINT	2,<-
First free P1 address      !8XL!4* -
Subprocess quota           !8UW>
	PUSHL	PHD$W_ASTLM(R2)
	PUSHL	JIB+JIB$L_PGFLCNT
	PRINT	2,<-
Free page file pages       !8UL!4* -
AST limit                  !8UW>
	PUSHL	PHD$W_PHVINDEX(R2)
	PUSHL	PHD$B_DFPFC(R2)
	PRINT	2,<-
Page fault cluster size    !8UB!4* -
Process header index       !8XW>
	PUSHL	PHD$L_BAK(R2)
	PUSHL	PHD$B_PGTBPFC(R2)
	PRINT	2,<-
Page table cluster size    !8UB!4* -
Backup address vector      !8XL>
	PUSHL	PHD$L_WSLX(R2)
	PUSHL	PHD$W_FLAGS(R2)
	PRINT	2,<-
Flags                      !8XW!4* -
WSL index save area        !8XL>
	PUSHL	PHD$W_PTCNTLCK(R2)
	PUSHL	PHD$L_DIOCNT(R2)
	PRINT	2,<-
Direct I/O count           !8UL!4* -
PTs having locked WSLs     !8UW>
	PUSHL	PHD$W_PTCNTVAL(R2)
	PUSHL	PHD$L_BIOCNT(R2)
	PRINT	2,<-
Buffered I/O count         !8UL!4* -
PTs having valid WSLs      !8UW>
	PUSHL	PHD$W_PTCNTACT(R2)
	PUSHL	PHD$L_CPULIM(R2)
	PRINT	2,<-
Limit on CPU time          !8XL!4* -
Active page tables         !8UW>
	PUSHL	PHD$W_PTCNTMAX(R2)
	PUSHL	JIB+JIB$L_PGFLQUOTA
	PRINT	2,<-
Maximum page file count    !8UL!4* -
Maximum active PTs         !8UW>
	PUSHL	PHD$W_WSFLUID(R2)
	PUSHL	PHD$L_PAGEFLTS(R2)
	PRINT	2,<-
Total page faults          !8UL!4* -
Guaranteed fluid WS pages  !8UW>
	PUSHL	PHD$W_EXTDYNWS(R2)
	PUSHL	JIB+JIB$W_FILLM
	PRINT	2,<-
File limit                 !8UW!4* -
Extra dynamic WS entries   !8UW>
	PUSHL	PHD$L_PTWSLELCK(R2)
	PUSHL	JIB+JIB$W_TQLM
	PRINT	2,<-
Timer queue limit          !8UW!4* -
Locked WSLE counts array   !8XW>
	PUSHL	PHD$L_PTWSLEVAL(R2)
	PUSHL	PHD$L_PAGFIL(R2)
	PRINT	2,<-
Paging file index          !8XL!4* -
Valid WSLE counts array    !8XW>

	RET

	.SBTTL	SHOW_REGS -- SHOW SAVED PROCESS REGISTERS
;---
;
;	SHOW_REGS
;
;	DISPLAY THE SAVED PROCESS REGISTERS
;
;   INPUTS:
;
;	PHD = CURRENT PROCESS HEADER
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_REGS:
	.WORD	^M<R2>

	SKIP	2
	ENSURE	7
	PRINT	0,<Saved process registers>
	PRINT	0,<----------------------->
	SKIP	1
	MOVAL	PHD,R2			; ADDRESS OF PROCESS HEADER
	PUSHL	PHD$L_R3(R2)
	PUSHL	PHD$L_R2(R2)
	PUSHL	PHD$L_R1(R2)
	PUSHL	PHD$L_R0(R2)
	PRINT	4,<R0   = !XL    R1   = !XL    R2   = !XL    R3   = !XL>
	PUSHL	PHD$L_R7(R2)
	PUSHL	PHD$L_R6(R2)
	PUSHL	PHD$L_R5(R2)
	PUSHL	PHD$L_R4(R2)
	PRINT	4,<R4   = !XL    R5   = !XL    R6   = !XL    R7   = !XL>
	PUSHL	PHD$L_R11(R2)
	PUSHL	PHD$L_R10(R2)
	PUSHL	PHD$L_R9(R2)
	PUSHL	PHD$L_R8(R2)
	PRINT	4,<R8   = !XL    R9   = !XL    R10  = !XL    R11  = !XL>
	PUSHL	PHD$L_PSL(R2)
	PUSHL	PHD$L_PC(R2)
	PUSHL	PHD$L_R13(R2)
	PUSHL	PHD$L_R12(R2)
	PRINT	4,<AP   = !XL    FP   = !XL    PC   = !XL    PSL  = !XL>
	PUSHL	PHD$L_USP(R2)
	PUSHL	PHD$L_SSP(R2)
	PUSHL	PHD$L_ESP(R2)
	PUSHL	PHD$L_KSP(R2)
	PRINT	4,<KSP  = !XL    ESP  = !XL    SSP  = !XL    USP  = !XL>
	PUSHL	PHD$L_P1LR(R2)
	PUSHL	PHD$L_P1BR(R2)
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,PHD$L_P0LRASTL(R2),-(SP)
	PUSHL	PHD$L_P0BR(R2)
	PRINT	4,<P0BR = !XL    P0LR = !XL    P1BR = !XL    P1LR = !XL>

	RET

	.SBTTL	SHOW_WSL -- SHOW WORKING SET LIST
;---
;
;	SHOW_WSL
;
;	THIS ROUTINE FORMATS INFORMATION ABOUT THE PROCESSES
;	WORKING SET LIST FROM THE PROCESS HEADER.
;
;   INPUTS:
;
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_WSL:
	.WORD	^M<R2,R3,R4,R5,R6>

	SKIP	2
	ENSURE	8
	PRINT	0,<Working set information>
	PRINT	0,<----------------------->
	SKIP	1
	MOVAL	PHD,R2
	MOVZWL	PHD$W_WSLIST(R2),R3	; BIAS TO WORKING SET LIST
	DECL	R3			; ADJUST BIAS
	SUBL3	R3,PHD$W_WSAUTH(R2),-(SP) ; CURRENT AUTHORIZED SIZE
	PUSHL	PHD$W_WSLIST(R2)	; 1ST WSL ENTRY
	PRINT	1,<First WSL entry          !XW        Current authorized working set size   !UW>
	SUBL3	R3,PHD$W_DFWSCNT(R2),-(SP) ; DEFAULT WORKING SET SIZE
	PUSHL	PHD$W_WSLOCK(R2)	; 1ST LOCKED WSL ENTRY
	PRINT	1,<First locked entry       !XW        Default (initial) working set size    !UW>
	SUBL3	R3,PHD$W_WSQUOTA(R2),-(SP) ; MAXIMUM WORKING SET ALLOWED
	PUSHL	PHD$W_WSDYN(R2)		; 1ST DYNAMIC ENTRY
	PRINT	1,<First dynamic entry      !XW        Maximum working set allowed (quota)   !UW>
	PUSHL	PHD$W_WSNEXT(R2)	; LAST ENTRY REPLACED
	PRINT	1,<Last entry replaced      !XW>
	PUSHL	PHD$W_WSLAST(R2)	; LAST ENTRY IN LIST
	PRINT	1,<Last entry in list       !XW>
	TSTW	PHD$W_WSLIST(R2)	; CHECK IF REASONABLE
	BGTR	5$			; BRANCH IF OK
	RET
5$:
	SKIP	2
	ENSURE	8
	PRINT	0,<Working set list>
	PRINT	0,<---------------->
	MOVZWL	PHD$W_WSLAST(R2),R6	; LONGWORD OFFSET TO LAST ENTRY
	INCL	R6			; LONGWORDS IN PHD+WSL
	ASHL	#2,R6,R6		; R6 = LENGTH IN BYTES
	PUSHL	R6			; LENGTH TO ALLOCATE
	CALLS	#1,ALLOCATE		; ALLOCATE SPACE FOR PHD+WSL
	MOVL	R1,R2			; ADDRESS OF PHD/WSL BUFFER
	GETMEM	@PCB+PCB$L_PHD,(R2),R6	; GET ENTIRE WORKING SET LIST
	BLBC	R0,90$			; SKIP IF CANNOT BE READ

	CALLS	#0,WSL_TITLE		; PRINT THE HEADING LINES
	MOVAB	WSL_TITLE,HEADING_ROUTINE ; SET HEADING ROUTINE
	MOVZWL	PHD$W_WSLIST(R2),R3	; STARTING INDEX OF LIST
	MOVZWL	PHD$W_WSLAST(R2),R4	; LAST ENTRY TO DUMP
	DECL	R3			; ADJUST FOR FIRST ITERATION
	CLRL	R5			; EMPTY WSLE COUNT
10$:
	INCL	R3			; INCREMENT INDEX
	CMPL	R3,R4			; CHECK IF DONE
	BLEQ	20$			; BRANCH IF OK
90$:
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	PUSHL	R6			; LENGTH OF BUFFER
	PUSHL	R2			; ADDRESS OF PHD+WSL BUFFER
	CALLS	#2,DEALLOCATE		; DEALLOCATE BUFFER
	RET
20$:
	MOVL	(R2)[R3],R0		; GET ENTRY
	BBS	#WSL$V_VALID,R0,30$	; BRANCH IF VALID
	INCL	R5			; INCREMENT EMPTY ENTRIES
	BRB	10$
30$:
	TSTL	R5			; CHECK IF EMPTY ENTRIES
	BEQL	40$			; BRANCH IF NOT
	PUSHL	R0			; SAVE PENDING WSLE
	PUSHL	R5
	SKIP	1
	PRINT	1,<!_ ----  !UL empty entries>
	SKIP	1
	CLRL	R5			; RESET EMPTY WSLE COUNT
	POPL	R0			; RESTORE PENDING WSLE TO SHOW
40$:
	EXTZV	#WSL$V_GOODPAGE,#1,R0,R1
	PUSHAB	GOODPAGE_TABLE[R1]
	EXTZV	#WSL$V_PFNLOCK,#1,R0,R1
	PUSHAB	PFNLOCK_TABLE[R1]
	EXTZV	#WSL$V_WSLOCK,#1,R0,R1
	PUSHAB	WSLOCK_TABLE[R1]
	EXTZV	#WSL$V_MODIFY,#1,R0,R1
	PUSHAB	MODIFY_TABLE[R1]
	EXTZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R0,R1
	PUSHAQ	PAGTYP_TABLE[R1]
	EXTZV	#WSL$V_VALID,#1,R0,R1
	PUSHAB	VALID_TABLE[R1]
	BICL3	#^X1FF,R0,-(SP)		; VIRTUAL ADDRESS
	PUSHL	R3			; INDEX
	PRINT	8,<!_ !XW  !XL    !AC !5(AC)>
	BRW	10$

	.DSABL	LSB

;
;	THIS ROUTINE PRINTS THE HEADING LINES FOR EACH PAGE
;	OF THE WORKING SET LIST DISPLAY.
;
WSL_TITLE:
	.WORD	0

	SKIP	1
	PRINT	0,<!_INDEX   ADDRESS    STATUS>
	SKIP	1
	RET

	.SBTTL	SHOW_PST -- SHOW PROCESS SECTION TABLE
;---
;
;	SHOW_PST
;
;	DISPLAY THE PROCESS SECTION TABLE
;
;   INPUTS:
;
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_PST:
	.WORD	^M<R2,R3,R4,R5,R6,R7>

	SKIP	2
	ENSURE	5
	PRINT	0,<Process section table information>
	PRINT	0,<--------------------------------->
	SKIP	1
	MOVAL	PHD,R2
	PUSHL	PHD$W_PSTLAST(R2)	; LAST PST ENTRY ALLOCATED
	PRINT	1,<!_Last entry allocated     !XW>
	PUSHL	PHD$W_PSTFREE(R2)
	PRINT	1,<!_First free PST entry     !XW>
	TSTW	PHD$W_PSTLAST(R2)	; CHECK IF REASONABLE
	BLSS	5$			; BRANCH IF OK
	RET
5$:
	SKIP	2
	ENSURE	8
	PRINT	0,<Process section table>
	PRINT	0,<--------------------->
	CALLS	#0,PST_TITLE		; PRINT TITLE LINE
	MOVAB	PST_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE
	CVTWL	PHD$W_PSTLAST(R2),R0	; LAST ENTRY ALLOCATED
	ADDL3	PCB+PCB$L_PHD,PHD$L_PSTBASOFF(R2),R7  ; BASE ADDRESS
	MOVAL	(R7)[R0],R4		; ADDRESS OF LOWEST ENTRY
	SUBL2	R4,R7			; LENGTH OF PST IN USE
	PUSHL	R7			; LENGTH TO ALLOCATE
	CALLS	#1,ALLOCATE		; ALLOCATE PST BUFFER
	MOVL	R1,R6			; SAVE ADDRESS OF PST BUFFER
	GETMEM	(R4),(R6),R7		; GET USED PART OF PST
	RETIFERR			; SKIP IF ERROR READING

	MOVL	R7,R3			; SET LENGTH OF PST TO SCAN
	MOVAB	(R6)[R7],R4		; FIRST ENTRY + 1
	CLRL	R5			; INITIALIZE PST INDEX
10$:
	SUBL2	#SEC$C_LENGTH,R4	; DECREMENT ADDRESS
	SUBL2	#SEC$C_LENGTH/4,R5	; DECREMENT INDEX
	SUBL2	#SEC$C_LENGTH,R3	; DECREMENT BUFFER LENGTH
	BGEQ	20$			; BRANCH IF OK
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	PUSHL	R7			; LENGTH TO DEALLOCATE
	PUSHL	R6			; ADDRESS OF PST BUFFER
	CALLS	#2,DEALLOCATE		; DEALLOCATE PST BUFFER
	STATUS	SUCCESS
	RET
20$:
	EXTZV	#SEC$V_GBL,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	GBL_TABLE[R1]
	EXTZV	#SEC$V_CRF,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	CRF_TABLE[R1]
	EXTZV	#SEC$V_DZRO,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	DZRO_TABLE[R1]
	EXTZV	#SEC$V_WRT,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	WRT_TABLE[R1]
	PUSHL	SEC$W_SECXBL(R4)	; BACKWARD LINK
	PUSHL	SEC$W_SECXFL(R4)	; FORWARD LINK
	PUSHL	SEC$L_REFCNT(R4)	; REFERENCE COUNT
	PUSHL	SEC$L_CCB(R4)		; CCB ADDRESS
	EXTZV	#SEC$V_PFC,#SEC$S_PFC,SEC$L_VPXPFC(R4),-(SP)
	PUSHL	SEC$L_VBN(R4)		; STARTING BLOCK NUMBER
	PUSHL	SEC$L_WINDOW(R4)	; WINDOW CONTROL BLOCK
	PUSHL	SEC$L_PAGCNT(R4)	; PAGE COUNT
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,SEC$L_VPXPFC(R4),R1
	ASHL	#9,R1,-(SP)		; VIRTUAL ADDRESS OF SECTION
	PUSHL	R5			; SECTION TABLE INDEX
	PRINT	14,<!_ !XW     !XL !XL   !XL  !XL   !4UL  !XL  !4UL     !XW  !XW   !4(AC)>
	BRW	10$

	.DSABL	LSB

;
;	SUBROUTINE TO PRINT THE SUB-HEADING LINE
;
PST_TITLE:
	.WORD	0
	
	SKIP	1
	PRINT	0,<!_INDEX      ADDRESS   PAGES     WINDOW     VBN    CLUSTER  CHANNEL  REFCNT  FLINK BLINK   FLAGS>
	SKIP	1
	RET

	.SBTTL	SHOW_PPT -- SHOW PROCESS PAGE TABLES
;---
;
;	SHOW_PPT
;
;	THIS ROUTINE DISPLAYS THE CONTENTS OF THE P0 AND
;	P1 PAGE TABLES FOR THE CURRENT PROCESS.
;
;   INPUTS:
;
;	PCB = PROCESS CONTROL BLOCK
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_PPT:
	.WORD	^M<R2,R3,R4,R5>

	.ENABL	LSB
	CALLS	#0,INIT_PFN		; SETUP ACCESS TO PFN DATA BASE
	MOVAL	PCB,R2
	MOVAL	PHD,R3
	BITL	#OPT$M_PPT_LEN!OPT$M_PPT_RNG,OPTIONS ; SPECIFIC ADDRESSES?
	BEQL	5$			; NO
	BRW	100$
5$:	BITL	#OPT$M_P0_PPT!OPT$M_P1_PPT,OPTIONS ; SPECIFIC PAGE TABLES?
	BEQL	10$			; NO
	BBC	#OPT$V_P0_PPT,OPTIONS,20$ ; P0 NOT REQUESTED
10$:	SKIP	2
	ENSURE	8
	PRINT	0,<P0 page table>
	PRINT	0,<------------->
	SKIP	1
	PUSHL	PCB$L_PHD(R2)		; ADDRESS OF PROCESS HEADER
	PUSHL	PHD$L_P0BR(R3)		; ADDRESS OF P0 PAGE TABLE
	PUSHL	#0			; STARTING ADDRESS BEING MAPPED
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,PHD$L_P0LRASTL(R3),-(SP) ; NUM ENTRIES
	CALLS	#4,DUMP_PTE		; FORMAT PAGE TABLE

	BITL	#OPT$M_P0_PPT!OPT$M_P1_PPT,OPTIONS ; SPECIFIC PAGE TABLES?
	BEQL	20$			; NO
	BBC	#OPT$V_P1_PPT,OPTIONS,90$ ; P1 NOT REQUESTED
20$:	SKIP	2
	ENSURE	8
	PRINT	0,<P1 page table>
	PRINT	0,<------------->
	SKIP	1
	MOVL	PHD$L_P1LR(R3),R1	; GET P1LR
	BEQL	90$			; SKIP IF ZERO
	SUBL3	R1,#^X200000,R1		; TOTAL PAGES ALLOCATED
	ASHL	#9,R1,R0		; SIZE OF P1 SPACE IN BYTES
	PUSHL	PCB$L_PHD(R2)		; ADDRESS OF PROCESS HEADER
	MOVL	PHD$L_P1LR(R3),R2	; GET NUMBER OF PAGES
	PUSHAL	@PHD$L_P1BR(R3)[R2]	; STARTING ADDRESS OF TABLE
	SUBL3	R0,#^X80000000,-(SP)	; STARTING ADDRESS BEING MAPPED
	PUSHL	R1			; TOTAL PAGES IN TABLE
	CALLS	#4,DUMP_PTE		; FORMAT PAGE TABLE

90$:	RET

100$:	SKIP	2
	ENSURE	8
	PRINT	0,<Process page table>
	PRINT	0,<------------------>
	SKIP	1
	PUSHL	PCB$L_PHD(R2)		; ADDRESS OF PROCESS HEADER
	MOVL	ESP,R1			; EXPRESSION STACK
	MOVQ	(R1),R4			; R5 = LOW LIMIT
	BBS	#OPT$V_PPT_LEN,OPTIONS,110$ ; R4 IS ALREADY LENGTH
	SUBL	R5,R4			; GET LENGTH
110$:	BICW	#^X1FF,R5		; ROUND DOWN
	ADDL	#^X3FF,R4
	ASHL	#-9,R4,R4		; NUMBER OF PTE'S
	PUSHL	PHD$L_P0BR(R3)		; ASSUME P0
	ASHL	#-7,R5,R1		; OFFSET IN PAGE TABLE
	BBC	#30,R5,120$		; IT WAS P0
	MOVL	PHD$L_P1BR(R3),(SP)	; USE P1
	SUBL3	#^X40000000,R5,R1
	ASHL	#-7,R1,R1		; OFFSET IN PAGE TABLE
120$:	ADDL	R1,(SP)
	PUSHL	R5			; BASE
	PUSHL	R4			; NUMBER OF ENTRIES
	CALLS	#4,DUMP_PTE		; FORMAT PAGE TABLE
	RET

	.DSABL	LSB

	.SBTTL	SHOW_CHANNELS -- DISPLAY ACTIVE CHANNELS
;---
;
;	SHOW_CHANNELS
;
;	THIS ROUTINE DISPLAYS THE INFORMATION IN THE PROCESS CHANNEL TABLE
;	PERTAINING TO THE ACTIVE CHANNELS.  FOR A CRASH FILE, YOU GET YOUR
;	CHOICE OF JUST THE DEVICE NAME OR A DEVICE NAME WITH THE FILE-ID.
;	FOR A RUNNING SYSTEM, THE FILE NAME (IF AVAILABLE) IS ALSO DISPLAYED.
;
;   INPUTS:
;
;	PCB = PROCESS CONTROL BLOCK
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_CHANNELS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

	TRYMEM	@CTL$GL_CCBBASE		;SEE IF CCB TABLE EXISTS
	BLBS	R0,10$			;XFER IF AVAILABLE
	SKIP	1			;ELSE FORCE ONE BLANK LINE
	RET				;AND RETURN NOW
10$:	CLRL	CHANTBL_SIZE		;RESET SIZE
	REQMEM	@CTL$GW_CHINDX,CHANTBL_SIZE,#2	;GET CHANNEL HIGH WATER MARK
	MOVL	CHANTBL_SIZE,R7		;GET THE TABLE SIZE
	PUSHAB	CHANTBL_ADDR		;GET MEMORY FOR CCB TABLE COPY
	PUSHAB	CHANTBL_SIZE
	CALLS	#2,G^LIB$GET_VM
	BLBS	R0,20$			;XFER IF SUCCESSFUL
	RET				;ELSE RETURN NOW
20$:	SKIP	2
	PRINT	0,<!28* Process active channels>
	PRINT	0,<!28* ----------------------->
	CALLS	#0,CHAN_TITLE		;PRINT COLUMN HEADINGS
	MOVAB	CHAN_TITLE,HEADING_ROUTINE	;SET HEADING ROUTINE ADDRESS
	MOVC5	#0,@CHANTBL_ADDR,#0,R7,@CHANTBL_ADDR	;CLEAR TABLE
	REQMEM	@CTL$GL_CCBBASE,R6	;GET CCB TABLE END ADDRESS
	SUBL2	R7,R6			;CALC START OF THE TABLE
	REQMEM	(R6),@CHANTBL_ADDR,R7	;COPY CCB TABLE
	ADDL3	R7,CHANTBL_ADDR,R6	;PROCESS FROM THE TOP DOWN
	MOVL	R6,R8			;SAVE FOR CALCULATING CHANNEL NUMBER
	BRW	160$			;JUMP INTO THE LOOP
30$:	TSTB	CCB$B_AMOD(R6)		;IS THE CHANNEL ACTIVE?
	BNEQ	40$			;XFER IF SO
35$:	BRW	160$			;ELSE GO TRY THE NEXT ONE
40$:	MOVL	CCB$L_UCB(R6),R5	;GET THE UCB ADDRESS
	BEQL	35$			;IF EQL THEN TRY NEXT ONE
	REQMEM	UCB$L_DDB(R5),R4	;GET THE DDB ADDRESS
;
;  Read node name into local memory.  The node name will be displayed along
;  with the device name.
;    
    	CLRL	NODE			; ZERO THE LENGTH FIELD
    	MOVL	SCS$GA_LOCALSB,R3	; LOCAL SYSTEM BLOCK
    	REQMEM	DDB$L_SB(R4),R0		; GET ADDRESS OF SYSTEM BLOCK
    	CMPL	R0,R3			; IS THIS THE LOCAL NODE?
    	BEQL	43$			; BRANCH, LOCAL NODE
    	ADDL3	#SB$T_NODENAME,R0,R0 	; POINT TO NODE NAME
    	GETMEM	(R0),NODE,#SB$S_NODENAME  ; READ INTO LOCAL STORAGE
    	MOVZBL	NODE,R0			; GET LENGTH OF NAME
    	MOVB	#^A/$/,NODE+1[R0]	; APPEND "$" TO NODE NAME
    	INCB	NODE			; INCREMENT LENGTH
43$:
	REQMEM	DDB$T_NAME(R4),CHANDEV_NAME,#16	;COPY THE DEVICE NAME
	MOVZBL	CHANDEV_NAME,CHANDEV_SIZE	;SET THE SIZE OF THE DEVICE NAME
    	
	REQMEM	UCB$W_UNIT(R5),R0	;GET THE DEVICE UNIT NUMBER
	CLRQ	-(SP)			;DESCRIPTOR FOR THE OUTPUT STRING
	MOVL	SP,R4			;SAVE ADDRESS FOR LATER
	SUBW3	CHANDEV_SIZE,#15,(R4)	;SET THE SIZE
	ADDL3	CHANDEV_SIZE,#CHANDEV_NAME+1,4(R4)	;SET THE ADDRESS
	PUSHL	R0			;STASH THE UNIT NUMBER
	PUSHL	R4			;FORMAT THE DEVICE NAME
	PUSHL	R4
	PUSHAB	CHANDEV_FMT
	CALLS	#4,G^SYS$FAO
	MOVQ	(SP)+,R0		;GET THE DESCRIPTOR & CLEAN THE STACK
	ADDW2	R0,CHANDEV_SIZE		;SET FULL DEVICE NAME SIZE
	MOVC5	#0,FCB,#0,#FCB$C_LENGTH,FCB	;CLEAR THE FCB
	MOVC5	#0,WCB,#0,#WCB$C_LENGTH,WCB	; AND THE WCB
	MOVAB	CHANSEC_TABLE,-(SP)	;NO SECTION SO FAR
	MOVL	SP,R5			;SAVE ADDRESS FOR LATER
	PUSHAB	FILE_NAME		;SET ADDRESS OF FILE NAME DESCRIPTOR
	CLRL	FILE_NAME		;NO FILE NAME SO FAR
	MOVAB	FILE_NAMETXT,FILE_NAME+4	;RESET ADDRESS
	MOVL	CCB$L_WIND(R6),R4	;GET THE WINDOW ADDRESS
	BEQL	45$			;XFER IF NO WINDOW PRESENT
	BLBC	R4,50$			;XFER IF WINDOW NOW INTERLOCKED
	CLRL	R4			;ELSE NO WINDOW ADDRESS
45$:	BRW	70$			;SKIP THE FOLOWING TEST
50$:	TSTL	R4			;REAL WINDOW OR PST OFFSET
	BLSS	60$			;XFER IF REAL WINDOW
	CVTWL	R4,R4			;ELSE EXTEND OFFSET
	ADDL3	PCB+PCB$L_PHD,PHD+PHD$L_PSTBASOFF,R0	;CALC PST ADDRESS
	MOVAL	SEC$L_WINDOW(R0)[R4],R4	;GET ADDRESS OF THE WINDOW ADDRESS
	REQMEM	(R4),R4			;GET THE WINDOW ADDRESS
60$:	REQMEM	(R4),WCB,#WCB$C_LENGTH	;COPY WINDOW (MINUS MAP POINTERS)
	CMPB	WCB+WCB$B_TYPE,#DYN$C_WCB	;CHECK BLOCK TYPE
	BNEQ	70$			;XFER IF NOT A WCB
	MOVL	WCB+WCB$L_FCB,R3	;ELSE GET FCB ADDRESS
	BEQL	70$			;XFER IF NONE
	REQMEM	(R3),FCB,#FCB$C_LENGTH	;ELSE COPY THE FCB
	CMPB	FCB+FCB$B_TYPE,#DYN$C_FCB	;CHECK BLOCK TYPE
	BNEQ	70$			;XFER IF NOT AN FCB
	TSTW	WCB+WCB$L_PID		;IS FILE A SECTION?
	BNEQ	65$			;XFER IF NOT
	MOVAB	CHANSEC_TABLE+1,(R5)	;ELSE SET NEW ADDRESS
65$:	MOVZWL	#132,FILE_NAME		;ELSE RESET DESCRIPTOR SIZE
	CLRL	-(SP)			;MAKE ROOM FOR SECONDARY STATUS
	PUSHL	SP			;CONVERT FILE-ID TO A FILE NAME
	PUSHL	#0
	PUSHAB	FILE_NAME
	PUSHAB	FILE_NAME
	PUSHAB	FCB+FCB$W_FID
	PUSHAB	CHANNEL_DEVICE
	CALLS	#6,G^LIB$FID_TO_NAME
	MOVL	(SP)+,R1		;RETRIEVE SECONDARY STATUS
	BLBC	R0,70$			;CAN'T USE FILE NAME IF ANY ERRORS
	BLBS	R1,80$
70$:	CLRL	FILE_NAME		;NO FILE NAME DESCRIPTOR
	TSTL	FCB+FCB$W_FID		;ANY FILE-ID?
	BNEQ	100$			;XFER IF SO
	BRB	110$			;ELSE SKIP FOLLOWING
80$:	LOCC	#^A\[\,FILE_NAME,@FILE_NAME+4	;STRIP DEVICE NAME
	BEQL	90$			;XFER IF NONE
	MOVQ	R0,FILE_NAME		;ELSE SAVE NEW DESCRIPTOR
90$:	BLBS	CURRENT_SYSTEM,110$	;XFER IF THE RUNNING SYSTEM
100$:	MOVZWL	FCB+FCB$W_FID_RVN,-(SP)	;ELSE SAVE THE FILE-ID
	MOVZWL	FCB+FCB$W_FID_SEQ,-(SP)
	MOVZWL	FCB+FCB$W_FID_NUM,-(SP)
110$:	PUSHAB	CHANNEL_DEVICE		;SET THE DEVICE NAME
    	PUSHAB	NODE			;SET THE NODE NAME
	MOVAB	CHANBUSY_TABLE,-(SP)	;SET AS NOT BUSY
	TSTW	CCB$W_IOC(R6)		;RIGHT?
	BEQL	120$			;XFER IF SO
	MOVAB	CHANBUSY_TABLE+1,(SP)	;ELSE NOTE BUSY
120$:	MOVAB	CHANDPND_TABLE,-(SP)	;NO DEACCESS PENDING
	TSTL	CCB$L_DIRP(R6)		;RIGHT?
	BEQL	130$			;XFER IF SO
	MOVAB	CHANDPND_TABLE+1,(SP)	;ELSE NOTE DEACCESS
130$:	PUSHL	R4			;SAVE THE WINDOW ADDRESS
	SUBL3	R6,R8,-(SP)		;SET THE CHANNEL NUMBER
	TSTL	FCB+FCB$W_FID		;ANY FILE-ID TO PRINT?
	BEQL	150$			;XFER IF NOT
	TSTW	FILE_NAME		;DO I HAVE A FILE NAME?
	BEQL	140$			;YES, SKIP NEXT TEST
	BLBS	CURRENT_SYSTEM,150$	;DON'T DISPLAY FID IF CURRENT SYSTEM
140$:	PRINT	8,<  !XW	!XL	!5AC!5AC	!AC!AS:(!UW,!UW,!UW)!AS!AC>
	BRB	160$			;GO GET THE NEXT CHANNEL BLOCK
150$:	PRINT	5,<  !XW	!XL	!5AC!5AC	!AC!AS:!AS!AC>
160$:	SUBL2	#CCB$C_LENGTH,R6	;NEXT CCB PLEASE...
	CMPL	R6,CHANTBL_ADDR		;DONE WITH ALL OF THEM?
	BLSSU	170$			;XFER IF SO
	BRW	30$			;ELSE TRY ANOTHER
170$:	PUSHAB	CHANTBL_ADDR		;RELEASE MEMORY ALLOCATED FOR CCB TABLE
	PUSHAB	CHANTBL_SIZE
	CALLS	#2,G^LIB$FREE_VM
	RET				; AND RETURN

CHAN_TITLE:
	.WORD	0
	SKIP	1
	PRINT	0,<Channel	 Window		  Status	Device/file accessed>
	PRINT	0,<-------	 ------		  ------	-------------------->
	RET

CHANDEV_FMT:
	.ASCID	\!UW\			;FOR FORMATTING THE DEVICE UNIT NUMBER

	.DSABL	LSB

	.SBTTL	PROCESS_SUMMARY -- DISPLAY LIST OF RUNNING PROCESSES
;---
;
;	PROCESS_SUMMARY
;
;	PRINT A LIST OF THE PROCESSES CURRENTLY RUNNING
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

PROCESS_SUMMARY::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>

	SUBHD	<Current process summary>
	SKIP	PAGE
	CALLS	#0,SUMMARY_TITLE	; PRINT SUBHEADING LINE
	MOVAB	SUMMARY_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE

	REQMEM	@SCH$GL_PCBVEC,R2	; VECTOR OF PCB ADDRESSES
	REQMEM	@SCH$GL_MAXPIX,R3	; GET MAXIMUM PROCESS INDEX
	MOVL	R2,R7			; ADDRESS OF NULL PROCESS SLOT
	MOVAB	JIB,R8
	MOVAB	PCB,R4
	MOVAB	PHD,R5
10$:
	REQMEM	(R2),R9			; GET ADDRESS OF NEXT PCB
	GETMEM	(R9),(R4),#PCB$C_LENGTH  ; READ ENTIRE PCB
	BLBC	R0,12$			; SKIP IF ERROR READING
	TSTW	PCB$L_PID(R4)		; CHECK IF NULL PROCESS
	BNEQ	15$			; BRANCH IF NOT
	CMPL	R2,R7			; IS THIS THE REAL NULL PROCESS?
	BEQL	15$			; OK IF NULL PROCESS
12$:	BRW	50$			; BYPASS THIS ENTRY
15$:
;	MOVC5	#0,(SP),#0,#JIB$C_LENGTH,(R8)	; PRE-ZERO JIB IN CASE NOT THERE
	MOVL	#^A"    ",R0		; SET R0 TO SPACES
	MOVL	R0,JIB$T_USERNAME(R8)	; AND FILL THE USERNAME WITH SPACES
	MOVL	R0,JIB$T_USERNAME+4(R8)
	MOVL	R0,JIB$T_USERNAME+8(R8)
	TSTL	PCB$L_JIB(R4)		; CHECK FOR JIB
	BEQL	18$			; BR IF NONE
	TRYMEM	@PCB$L_JIB(R4),(R8),#JIB$C_LENGTH  ; GET JIB
18$:
	ADDW3	PCB$W_PPGCNT(R4),PCB$W_GPGCNT(R4),R0
	MOVZWL	R0,-(SP)		; WORKING SET SIZE (PHYS. MEM.)
	PUSHL	PCB$L_PHD(R4)		; PHD ADDRESS
	PUSHL	R9			; PCB ADDRESS
	SUBB3	PCB$B_PRI(R4),#31,R1	; CURRENT PRIORITY
	MOVZBL	R1,-(SP)
    	CMPW	PCB$W_STATE(R4),#SCH$C_MWAIT	; CHECK FOR MWAIT
    	BEQL	80$			; EQUAL, DETERMINE RESOURCE WAIT STATE
19$:	MOVZWL	PCB$W_STATE(R4),R1	; CURRENT STATE
	PUSHAQ	STATE_TABLE[R1]
20$:
	PUSHAB	JIB$T_USERNAME(R8)	; ADDRESS OF USERNAME
	PUSHL	#12			; LENGTH OF USERNAME
	PUSHAB	PCB$T_LNAME+1(R4)	; PROCESS NAME
	MOVZBL	PCB$T_LNAME(R4),-(SP)	; PROCESS NAME LENGTH
	PUSHL	PCB$L_PID(R4)		; INTERNAL PROCESS IDENTIFICATION
	PUSHL	PCB$L_EPID(R4)		; EXTENDED PROCESS IDENTIFICATION
	PRINT	10,< !XL !XW !15AF !12AF !5AC !2UB !XL !XL !5UL>
	BBC	#OPT$V_IMAGE,OPTIONS,50$; CHECK IF /IMAGE SPECIFIED
	PUSHAB	NOTAVAIL		; PRESET TO USE "NOT AVAILABLE" STRING
	CALLS	#0,READ_IMAGE		; READ IMAGE FILE NAME
	BLBC	R0,25$			; BRANCH IF ERROR READING
	MOVL	R6,(SP)			; ADDRESS OF NAME BUFFER
25$:
	TSTB	@(SP)			; DID IT GIVE US A NULL?
	BNEQ	35$
	ADDL2	#4,SP			; POP THE STRING OFF, DON'T PRINT
	BRB	50$
35$:	PRINT	1,<          !AC>
50$:
	ADDL2	#4,R2			; NEXT PCB ADDRESS
	DECL	R3			; DECREMENT ITERATION COUNT
	BLSS	90$			; BRANCH IF FINISHED
	BRW	10$			; CONTINUE UNTIL DONE

80$:	PUSHR	#^M<R2,R3>		; SAVE NEXT PCB ADDRESS AND COUNTER
	MOVL	PCB$L_EFWM(R4),R2	; RESOURCE WAIT
	MOVAB	RESOURCE_WAIT,R3	; ADDRESS OF TABLE OF STATES
	JSB	G^TRANSLATE_ADDRESS	; DETERMINE STATE
    	POPR	#^M<R2,R3>		; RESTORE PCB ADDRESS AND COUNTER
    	BNEQ	85$			; MATCH FOUND, IF NOT EQUAL
    	TSTL	PCB$L_EFWM(R4)		; CHECK FOR MUTEX ADDRESS
    	BGEQ	19$			; BRANCH IF NOT ADDRESS
    	PUSHAB	MWAIT			; ADDRESS OF MUTEX COUNTED STRING	
    	BRW	20$			; RETURN TO MAIN PATH
85$:	PUSHL	R0			; ADDRESS OF RESOURCE WAITING FOR
	BRW	20$			; RETURN TO MAIN PATH

90$:
	CALLS	#0,SET_PROCESS		; RESET PROCESS PAGE REGISTERS
	STATUS	SUCCESS
	RET

	.DSABL	LSB

;
;	SUBROUTINE TO PRINT TITLE LINE
;
SUMMARY_TITLE:
	.WORD	0

	PRINT	0,< Extended Indx Process name    Username    State Pri   PCB      PHD    Wkset>
	PRINT	0,<-- PID -- ---- --------------- ----------- ----- --- -------- -------- ----->
	RET

	.SBTTL	READ_IMAGE, READ IMAGE FILE NAME STRING
;---
;
;	SUBROUTINE TO READ THE IMAGE FILE NAME FOR THE
;	PROCESS DESCRIBED BY THE SPECIFIED PCB AND PHD.
;
;	R4 = ADDRESS OF PCB
;	R5 = ADDRESS OF PHD
;	CALL
;	R0 = SUCCESS/FAILURE FLAG
;	R6 = ADDRESS OF BUFFER CONTAINING ASCIC FILE NAME
;
;---

READ_IMAGE:
	.WORD	^M<R2>

	MOVAB	L^BUFFER,R6		; SET BUFFER ADDRESS
	CLRB	(R6)			; PRESET TO NULL STRING
	CMPW	PCB$L_PID(R4),#1	; CHECK IF INDEX = 0 OR 1
	BGTRU	15$			; IF NULL,SWAPPER SKIP THIS
	BRW	50$			; IF NULL,SWAPPER SKIP THIS
15$:	TSTL	PCB$L_PHD(R4)		; CHECK IF ZERO
	BEQL	18$			; BRANCH IF SWAPPED OUT
	TRYMEM	@PCB$L_PHD(R4),(R5),#PHD$C_LENGTH  ; READ PROCESS HEADER
	BLBS	R0,20$			; BRANCH IF OK
18$:	CLRL	R0
	RET
20$:	MOVAQ	P0BR,R0
	MOVQ	PHD$L_P0BR(R5),(R0)	; SETUP RELOCATION REGISTERS
	MOVQ	PHD$L_P1BR(R5),8(R0)
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,4(R0),4(R0)
	MOVL	PCB$L_PID(R4),PROC_PID	; SET PROCESS PID TO READ
	BLBS	VERSION_FLAGS,10$	; BRANCH IF RELEASE 2
;
;	VMS RELEASE 1 - IMAGE FILE NAME RESIDES IN IFD BUFFER
;
	MOVL	MMG$IMGHDRBUF,R1	; ADDRESS OF IMAGE BUFFER
	TRYMEM	4(R1),R2		; GET ADDRESS OF IFD
	BLBC	R0,90$			; BRANCH IF ERROR
	TRYMEM	IFD$W_FILNAMOFF(R2)	; GET OFFSET TO FILE NAME
	BLBC	R0,90$			; BRANCH IF ERROR
	CVTWL	R1,R1
	BEQL	50$			; BRANCH IF ZERO OFFSET
	TRYMEM	(R2)[R1],(R6),#32	; GET ASCIC IMAGE FILE NAME
	BLBC	R0,90$			; BRANCH IF ERROR
	CMPB	(R6),#32		; CHECK IF OVER 32 CHARACTERS
	BLEQU	50$			; BRANCH IF OK
	MOVB	#32,(R6)		; TRUNCATE TO 32 CHARACTERS
50$:	MOVL	#1,R0			; SET NO IMAGE NAME
90$:	CLRL	PROC_PID		; CLEAR PID ON EXIT SO THAT MEMORY
					; REQUESTS FOR SYSTEM SPACE WILL GO
					; FASTER (DON'T NEED THIS CONTEXT)
	RET
;
;	VMS RELEASE 2 - IMAGE FILE DESCRIBED BY IFD$Q_CURPROG
;
10$:	TRYMEM	@CTL$GL_IMGHDRBF	; READ ADDRESS OF IMAGE HEADER
	BLBC	R0,90$			; BRANCH IF ERROR
	TSTL	R1			; ANY IMAGE HEADER?
	BEQL	50$			; BRANCH IF NONE
	TRYMEM	4(R1)			; READ IFD POINTER
	BLBC	R0,90$			; BRANCH IF ERROR
	TRYMEM	IFD$Q_CURPROG(R1),(R6),#8	; READ DESCRIPTOR
	BLBC	R0,90$			; BRANCH IF ERROR
	MOVZBL	(R6),R0			; CHECK LENGTH OF STRING
	BEQL	50$			; BRANCH IF NULL
	TRYMEM	@4(R6),1(R6),R0		; READ FILE NAME STRING
	BLBC	R0,90$			; BRANCH IF ERROR
	BRB	50$			; SUCCESS


	.END
