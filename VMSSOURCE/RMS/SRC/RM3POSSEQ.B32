MODULE RM3POSSEQ (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 Index Sequential File Organization
!
! ABSTRACT:
!		Routines to position sequentially to the next record
!
!
! ENVIRONMENT:
!
!		VAX/VMS Operating System
!
!--

!
! AUTHOR:	Todd M. Katz	CREATION DATE:		23-Jun-1982
!
!
! MODIFIED BY:
!
!	V03-016 TSK0001		Tamar Krichevsky	15-Jun-1983
!		Change addressing mode of RM$RU_RECLAIM to long relative.
!
!	V03-015 MCN0002		Maria del C. Nasr	24-Mar-1983
!		More linkages reorganization.
!
!	V03-014	TMK0009		Todd M. Katz		11-Mar-1983
!		Make sure that all bucket locks are taken out as exclusive 
!		whenever the possibility exists that some reclamation maybe
!		done. Reclamation is possible whenever the positioning is by
!		alternate key of reference, or whenever the file has been
!		write accessed and is Recovery Unit Journallable.
!
!	V03-013 MCN0001		Maria del C. Nasr	28-Feb-1983
!		Reorganize linkages
!
!	V03-012	TMK0008		Todd M. Katz		24-Feb-1983
!		Fix a bug in and add several performance enhancements to
!		RM$FIND_NONDEL. The bug was that when this routine exhausts the
!		current bucket in its search for a non-deleted primary data 
!  		record and continues with the next bucket it should be resetting
!		IRB$L_LST_NCMP to point to the first record in the next bucket
!		when primary key compression is enabled. Because it was not,
!		when the time came to re-expand the key of the non-deleted 
!		primary data record positioned to, this key expansion was done
!		incorrectly. The enhancements consist of making sure as RMS
!		scans the current bucket for a non-deleted primary data record

!
!	V03-011	TMK0007		Todd M. Katz		17-Jan-1983
!		Add support for Recovery Unit Journalling and RU ROLLBACK
!		Recovery of ISAM files. Support involves modifications to
!		RM$POS_SEQ and RM$FIND_NONDEL. 
!
!		The purpose of the routines within this module is to find the 
!		next non-deleted primary data record sequentially. If during 
!		its search RMS encounters records that are marked RU_DELETE, it 
!		will try and delete them for good at this time provided it has 
!		write access to the file and the Recovery Unit in which they 
!		were deleted has completed successfully. 
!
!		If RMS is able to delete a primary data record marked RU_DELETE,
!		then RMS proceeds to continue looking for a non-deleted primary
!		data record just as if it had encountered a deleted record in
!		the first place. Likewise, if RMS is unable to delete a record
!		that is marked RU_DELETE because it does not have write access
!		to the file, it merely continues its search with the next
!		record. However, if RMS is unable to delete the record for good
!		because the Recovery Unit in which it was marked RU_DELETE has
!		not successfully terminated, then RMS returns this record as if
!		it was the next non-deleted primary data record, and lets a 
!		higher level routine decide whether or not to wait for the
!		Recovery Unit in which the record was deleted to complete, or to
!		return an error to the user.
!
!		RMS will also re-format any records that are marked RU_UPDATE
!		and are in a special format provided the stream has write access
!		to the file, and the Recovery Unit in which the record was 
!		updated has terminated.
!
!	V03-010	TMK0006		Todd M. Katz		09-Nov-1982
!		The routine RM$FIND_SIDR never returns an end-of-file error so
!		remove all references to this particular error.
!
!	V03-009	TMK0005		Todd M. Katz		20-Oct-1982
!		An infinite loop existed in RM$POS_SEQ. When a search must be
!		made for the current primary data record by calling 
!		RM$CSEARCH_TREE and duplicates are allowed, then the duplicate
!		chain is searched for the current record. If the first duplicate
!		in the chain was not the current record, then RMS was assuming
!		that if it called RM$CSEARCH_TREE, this routine would position
!		to the next record, and return status indicating whether it
!		too was a duplicate. This assumption is incorrect. The routine
!		RM$CSEARCH_TREE works as follows: If the routine 
!		RM$CSEARCH_TREE is called with REC_ADDR pointing to a place in 
!		a bucket, whose BDB's address is saved in IRB$L_CURBDB, then 
!		RM$CSEARCH_TREE determines whether or not the key of this 
!		record matches the key in keybuffer 2 according to the search 
!		characteristics. Thus, this routine does not position RMS to the
!		very next record, which what was being incorrectly assumed, but
!		just checks out the key of the current record. The fix is to
!		explicitely position to the next primary data record if the
!		record currently positioned to is not the current record, before
!		calling RM$CSEARCH_TREE to see if this record is a member of the
!		duplicate chain.
!
!	V03-008	TMK0004		Todd M. Katz		19-Oct-1982
!		I have made two changes to the routine RM$POS_SEQ. First, if
!		RMS was unable to position to any record using the current NRP
!		information, then RMS should not be checking whether the record
!		it has positioned to is a non-deleted RRV (because of course, 
!		RMS has not positioned to any record). At present, this check
!		is made in RM$POS_SEQ. Second, RMS should not be releasing 
!		buckets, and then referencing addresses within them. This also
!		is currently taking place within RM$POS_SEQ. 
!
!	V03-007	TMK0003		Todd M. Katz		09-Sep-1982
!		The field IRB$B_SRCHFLAGS is now a word in size. Fix all
!		references to it.
!
!		Add support for prologue 3 SIDRs. A change is required to 
!		RM$POS_SEQ. When positioning sequentially for the first time 
!		following a $CONNECT or $REWIND. RMS wants to position to
!		the first non-empty bucket. Because prolgoue 3 SIDRs do not have
!		control bytes, RMS can't just check for a RRV record as its 
!		indicator of an empty bucket. It can only make this check for
!		primary data buckets. This change has been made. Furthermore, 
!		RMS will also now check for an empty SIDR bucket (this was not 
!		being done) by checking the freespace offset pointer.
!
!	V03-006	KBT0296		Keith B. Thompson	24-Aug-1982
!		Reorganize psects
!
!	V03-005	TMK0002		Todd M. Katz		28-Jul-1982
!		When positioning sequentially by alternate key, the routine
!		RM$FIND_SIDR is called to find the current SIDR, or to position
!		to the next SIDR if the current SIDR has been deleted. If a 
!		stream's current SIDR is the last SIDR in the index, and it is
!		deleted by another stream, RM$FIND_SIDR returns the error
!		RMS$_RNF because it is unable to find any SIDR in the 
!		greater-than-or-equal search of the file it makes (using as the 
!		search key the key of the current record) when it decides that
!		the stream's current SIDR has been deleted. In this case 
!		RM$POS_SEQ should convert this error into RMS$_EOF and return 
!		it to indicate that the end of the file has been reached.
!
!	V03-004	TMK0001		Todd M. Katz		22-Jun-1982
!		Revised entire module.
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! Define default PSECTS for code
!
PSECT
    CODE = RM$RMS3(PSECT_ATTR),
    PLIT = RM$RMS3(PSECT_ATTR);

! Linkages
!
LINKAGE
    L_PRESERVE1,
    L_REC_OVHD,
    L_SIDR_FIRST,
    L_RABREG_457,
    L_RABREG_567,
    L_RABREG_67,

    ! Local Linkages
    !
    RL$LINKAGE 		= JSB ()
			: GLOBAL (R_IDX_DFN, R_REC_ADDR, COMMON_RABREG);

! External Routines
!
EXTERNAL ROUTINE
    RM$COMPARE_REC	: RL$RABREG_67,
    RM$CSEARCH_TREE	: RL$RABREG_67,
    RM$FIND_BY_RFA	: RL$RABREG_67,
    RM$FIND_BY_RRV	: RL$RABREG_67,
    RM$GETBKT		: RL$RABREG_457,
    RM$GETNEXT_REC	: RL$RABREG_67,
    RM$RECORD_ID	: RL$RABREG_67,
    RM$RECORD_VBN	: RL$PRESERVE1,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$RLSBKT		: RL$PRESERVE1,
    RM$RU_RECLAIM	: RL$RABREG_67 ADDRESSING_MODE( LONG_RELATIVE ),
    RM$SEARCH_SIDR	: RL$RABREG_67,
    RM$SIDR_FIRST	: RL$SIDR_FIRST,
    RM$SRCH_BY_KEY	: RL$RABREG_567;

! Define a local macro to return on error and
! to change a 'RNF' error to 'EOF' ( this is seq. proccessing )
!
MACRO
    RET_ON_ERR_EOF (X) =
	(RETURN_ON_ERROR(X,
	IF .STATUS<0,16> EQL RMSERR(RNF) THEN STATUS = RMSERR(EOF))) %;


%SBTTL 'RM$CHECK_RRV'
ROUTINE RM$CHECK_RRV : RL$LINKAGE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine compares the RRV pointer of the record RMS is currently
!	positioned to with the RFA address of the current record, and returns 
!	the result of that match verifying whether or not the two are one and
!	the same - ie the record RMS is currently positioned to is the current 
!	record.
!	
! CALLING SEQUENCE:
!
!	BSBW RM$CHECK_RRV()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IRAB			- address of the IRAB
!	    IRB$W_POS_ID	- ID of user data record for NRP positioning
!	    IRB$L_POS_VBN	- VBN of user data record for NRP positioning
!
!	REC_ADDR		- address of primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
!	SUC - the RRV of the current primary data record matches the current 
!	      records RFA address.
!
!	0   - the RRV of the current primary data record does not match the 
!	      current records RFA address.
!
! SIDE EFFECTS:
!
!	AP is trashed.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR;

    GLOBAL REGISTER
	R_BDB;

    AP = 3;

    ! If the two addresses match, return success. The record RMS is positioned
    ! to is in fact the current record.
    !
    IF  (.IRAB[IRB$W_POS_ID] EQL RM$RECORD_ID())
	 AND
	(.IRAB[IRB$L_POS_VBN] EQL RM$RECORD_VBN())
    THEN 
	RETURN RMSSUC()

    ! Otherwise, the record RMS is currently positioned to is not the current
    ! record
    !
    ELSE
	RETURN 0;

    END;					! {  of routine }

%SBTTL 'RM$FIND_NONDEL'
ROUTINE RM$FIND_NONDEL (FLAG) : RL$LINKAGE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches for the next next non-deleted primary data record
!	in the file. If the input parameter is 1, the search starts with the
!	record RMS is currently positioned to, but if its 0, the search will 
!	start with the very next bucket.
!
!	If RMS encounters a record that is marked RU_DELETE and the Recovery 
!	Unit in which the record was deleted it still active, then RMS returns
!	this record as the next non-deleted primary data record and lets a 
!	higher level routine decide what to do. If the Recovery Unit in which
!	the record was deleted has successfully terminated, then RMS will 
!	continue its search for a non-deleted primary data record after deleting
!	this RU_DELETEd record (the latter if it has write access to the file).
!
!	If RMS encounters a record that is marked RU_UPDATE and is in a special
!	format then RMS will return this record as the next non-deleted primary
!	data record after reformatting it. The reformatting is done if RMS has 
!	write access to the file, and the Recovery Unit in which it was updated 
!	has successfully terminated.
!	
! CALLING SEQUENCE:
!
!	BSBW RM$FIND_NONDEL()
!
! INPUT PARAMETERS:
!
!	FLAG		- if 1, start search with the record RMS is currently
!			        positioned to
!
! IMPLICIT INPUTS:
!
!	IDX_DFN			- address of index descriptor
!	    IDX$B_DATBKTSZ	- data bucket size
!	    IDX$V_KEY_COMPR	- if set, primary key compression is enabled
!
!	IFAB			- address of IFAB
!	    IFB$V_RU		- if set, file is Recovery Unit Journallable
!	    IFB$V_WRTACC	- if set, stream has write access to the file
!
!	IRAB			- address of IRAB
!	    IRB$L_CURBDB	- address of BDB for accessed data bucket
!
!	REC_ADDR		- address of record RMS is positioned to
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRB$L_CURBDB	- address of BDB describing primary data bucket
!	IRB$V_DEL_SEEN	- set if deleted records encountered
!	IRB$L_LST_NCMP	- updated to last record with a 0 front compressed key 
!	REC_ADDR	- address of next non-deleted primary data record
!
! ROUTINE VALUE:
!
!	SUC	- found next non-deleted primary data record.
!	EOF	- end-of-file encountered before record found.
!	various I/O errors
!
! SIDE EFFECTS:
!
!	SUC - REC_ADDR points to next non-deleted primary data record, and
!	      IRB$L_CURBDB contains the address of the BDB describing the
!	      primary data bucket.
!	On all errors, no primary data bucket is accessed.
!	If deleted reords are encountered the flag IRB$V_DEL_SEEN is set.
!	IF RU_DELETEd records are encountered, they might have been deleted.
!	If RU_UPDATEd records are encountered, they might have been reformatted.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	COMMON_IO_STR;

    LOCAL
	VBN;

    ! Retrieve the address of the start of the primary data bucket.
    !
    BDB = .IRAB[IRB$L_CURBDB];
    BKT_ADDR = .BDB[BDB$L_ADDR];

    ! If RMS is to start the positioning to the next non-deleted primary data
    ! record with the next record, and not the record it is currently 
    ! positioned to, position to the next record.
    !
    IF NOT .FLAG
    THEN
	BEGIN

	! If primary key compression is enabled and the key of the record is 
	! zero-front compressed, then save the address of the record as the last
	! record encountered with a zero-front compressed key.
	!
	IF .IDX_DFN[IDX$V_KEY_COMPR]
	    AND
	   .(.REC_ADDR + RM$REC_OVHD(0))<8,8> EQLU 0
	THEN
	    IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

	RM$GETNEXT_REC();
	END;

    ! Continue to look for the next non-deleted record until either one is
    ! found, the end-of-file is encountered or some random I/O error occurs.
    !
    WHILE 1
    DO
	BEGIN

	! Continue the search for a non-deleted primary data record in the
	! current bucket until either all the record are exhausted, or the
	! first RRV is encountered.
	!
	WHILE .REC_ADDR LSSA (.BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE])
	       AND
	      NOT .REC_ADDR[IRC$V_RRV]
	DO

	    ! If RMS finds that the current record has been deleted within a
	    ! Recovery Unit, then it subjects this record to further processing
	    ! before deciding whether to return this record as the next
	    ! non-deleted primary data record, or to continue with the search.
	    !
	    IF 	.REC_ADDR[IRC$V_RU_DELETE]
	    THEN
		BEGIN

		LOCAL
		    RECORD_ID : WORD,
		    STATUS;

		RECORD_ID = .REC_ADDR[IRC$W_ID];

		! If the Recovery Unit in which the record was deleted is
		! still active, or the file is not open for write access then 
		! RMS will not be able to recover any space from the current 
		! record; however, RMS may still want to return this record as 
		! the next non-deleted primary data record.
		!
		IF  NOT (STATUS = RM$RU_RECLAIM())
		THEN

		    ! RMS will return the current record as the next non-deleted
		    ! primary data record if this record was deleted by another 
		    ! process whose Recovery Unit has not yet completed.
		    !
		    IF .STATUS<0,16> EQLU RMSERR(RLK)
		    THEN
			RETURN RMSSUC()

		    ! If the current record was deleted in a Recovery Unit by 
		    ! the current process and this process is still within a
		    ! Recovery Unit; or, if RMS is able to lock this record but
		    ! has not write accessed the file, then RMS treats the 
		    ! current record as if it actually is deleted, and 
		    ! positions to the next record so as to continue the search.
		    !
		    ELSE
			BEGIN

			! If index compression is enabled and the key of the 
			! record is zero-front compressed, then save the 
			! address of the record as the last record encountered 
			! with a zero-front compressed key.
			!
			IF .IDX_DFN[IDX$V_KEY_COMPR]
	    		    AND
	   		   .(.REC_ADDR + RM$REC_OVHD(0))<8,8> EQLU 0
			THEN
			    IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

			IRAB[IRB$V_DEL_SEEN] = 1;
			RM$GETNEXT_REC();
			END

		! RMS was able to reclaim some space from the current
		! record because the Recovery Unit in which the record had
		! been deleted has successfully terminated. RMS will 
		! continue the search for a non-deleted primary data record
		! with the next record in the file.
		!
		ELSE
		    IF .RECORD_ID NEQU .REC_ADDR[IRC$W_ID]
		    THEN
			IRAB[IRB$V_DEL_SEEN] = 1;
		END

	    ! If the record RMS has positioned to is not deleted, then RMS has
	    ! found its next non-deleted primary data record, and can return 
	    ! success. Otherwise, set the deleted record seen bit, and position
	    ! to the very next record in the primary data bucket.
	    !
	    ELSE
		IF NOT .REC_ADDR[IRC$V_DELETED]
		THEN
		    BEGIN

		    ! If the current non-deleted primary data record has been
		    ! updated within a Recovery Unit then it maybe re-formated
		    ! before it is returned provided the file has been open
		    ! for write access, and the Recovery Unit in which it was
		    ! eas updated has completed successfully.
		    !
		    IF  .REC_ADDR[IRC$V_RU_UPDATE]
			 AND
			.IFAB[IFB$V_WRTACC]
		    THEN
			RM$RU_RECLAIM();

		    RETURN RMSSUC();
		    END
		ELSE
		    BEGIN

		    ! If index compression is enabled and the key of the record 
		    ! is zero-front compressed, then save the address of the 
		    ! record as the last record encountered with a zero-front 
		    ! compressed key.
		    !
		    IF  .IDX_DFN[IDX$V_KEY_COMPR]
			 AND
			.(.REC_ADDR + RM$REC_OVHD(0))<8,8> EQLU 0
		    THEN
			IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

		    IRAB[IRB$V_DEL_SEEN] = 1;	    
		    RM$GETNEXT_REC();
		    END;

	! If all records in the current record have been exhausted without
	! find a non-deleted primary data record, and this is the very last
	! bucket in the horizontal chain, then return an error of end-of-file.
	!
	IF .BKT_ADDR[BKT$V_LASTBKT]
	THEN
	    BEGIN
	    RELEASE (IRAB[IRB$L_CURBDB]);
	    RETURN RMSERR(EOF);
	    END;

	! If this is not the last bucket in the horizontal chain, get the 
	! very next bucket and continue the search for the next non-deleted
	! primary data bucket in it.
	!
	VBN = .BKT_ADDR[BKT$L_NXTBKT];
	RELEASE (IRAB[IRB$L_CURBDB]);

	! If the file is Recovery Unit Journallable and write accessed, then
	! make sure the next primary data bucket in the horizontal chain is
	! exclusively accessed.
	!
	IF .IFAB[IFB$V_WRTACC]
	    AND
	   .IFAB[IFB$V_RU]
	THEN
	    IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

	RETURN_ON_ERROR (RM$GETBKT (.VBN, .IDX_DFN[IDX$B_DATBKTSZ] * 512));

	IRAB[IRB$L_CURBDB] = .BDB;

	REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;

	! Make sure the address of the first record in this bucket is placed
	! in IRB$L_LST_NCMP if primary key compression is enabled.
	!
	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    IRAB[IRB$L_LST_NCMP] = .REC_ADDR;
	END;

    END;					! {  of routine }

%SBTTL 'RM$FIND_SIDR'
ROUTINE RM$FIND_SIDR : RL$LINKAGE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	The function of this routine is to position to a particular SIDR. 
!
!	If the NRP key of reference coincides with the key of reference of the
!	current index descriptor, then this SIDR is the current record. In such
!	a case the NRP information is used to attempt to position to the 
!	current SIDR, and if that fails an attempt is made to position to the 
!	current SIDR by means of a random search of the alternate index. If RMS
!	is able to locate the current record, the number of array elements 
!	preceeding the current element is placed in IRB$W_SAVE_POS, and success
!	is returned. If RMS is unable to position to the current record because
!	it has been deleted, then IRB$W_SAVE_POS is zeroed, and an RMS error
!	of record deleted is returned. This status may not represent an actual
!	error, and so the SIDR positioned to is also returned. If RMS is unable
!	to locate any record, than an error of RNF is returned.
!
!	If the NRP key of reference is not equal to the key of reference of the
!	current index descriptor, then RMS positions to the first SIDR with a 
!	key greater than or equal to to the key found in keybuffer 2, or to the
!	first SIDR with a key equal to the key in keybuffer 2, depending upon
!	the IRB$B_SRCHKEY bit settings. If RMS is successful at positioning to 
!	a SIDR, IRB$W_SAVE_POS will always be zero and a status of success is
!	returned; otherwise, a RMS error of record not found is returned.
!	
! CALLING SEQUENCE:
!
!	BSBW RM$FIND_SIDR()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN			- index descriptor of index to search
!	    IDX$B_DATBKTSZ	- size of SIDR bucket in VBNs
!	    IDX$B_KEYREF	- key of reference of index descriptor
!	    IDX$B_KEYSZ		- size of SIDR key
!
!	IFAB			- address of IFAB
!	    IFB$W_KBUFSZ	- size of a keybuffer
!	    IFB$V_RU		- if set, file is Recovery Unit Journallable
!	    IFB$V_WRTACC	- if set, stream has write access to the file
!
!	IRAB			- address of IRAB
!	    IRB$L_CURBDB	- must be zero
!	    IRB$W_CUR_COUNT	- number of elements preceeding current element
!	    IRB$B_CUR_KREF	- key of reference of current SIDR record
!	    IRB$L_KEYBUF	- address of stream's five keybuffers
!	    IRB$W_SIDR_ID	- ID of current SIDR's first array element
!	    IRB$L_SIDR_VBN	- VBN of current SIDR's first array element
!	    IRB$V_SRCHGE	- if set, search for GE match 
!	    IRB$V_SRCHGT	- if set, search for GT match 
!	    IRB$B_STOPLEVEL	- level at which to stop search (must be 0)
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRB$L_CURBDB	- address of SIDR bucket's BDB
!	IRB$W_SAVE_POS	- number of elements preceeding the current one
!	REC_ADDR	- address of SIDR record
!
! ROUTINE VALUE:
!
!	DEL	- if RMS was to position to the current SIDR and found it
!		  deleted.
!	RNF	- if RMS was unable to find any SIDR to position to and EOF
!		  was not encountered.
!	SUC	- if the desired SIDR was positioned to.
!	various I/O errors.
!
! SIDE EFFECTS:
!
!	If RMS is successful at positioning to the current SIDR by means of the
!	    NRP information, IRB$W_SAVE_POS, REC_ADDR, and IRB$L_CURBDB all
!	    have their stated values and a status of SUC is returned.
!	If RMS is unable to successfully position to the current SIDR by means
!	    of the NRP information, but is able to position to a record, then
!	    REC_ADDR and IRB$L_CURBDB have their assigned values,
!	    IRB$W_SAVE_POS is set to 0, and a status of DEL is returned.
!	If RMS is not positioning to the current SIDR and is able to position
!	    to some record, then IRB$W_SAVE_POS is set to 0, REC_ADDR and 
!	    IRB$L_CURBDB have their assigned values, and a status of SUC is 
!	    returned.
!	If RMS is not positioning to the current SIDR and is unable to position
!	    to some record, then IRB$W_SAVE_POS is set to 0, and a status of 
!	    RNF is returned.
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR;

    LOCAL
	FLAGS	: BLOCK[1];

    MACRO
	FIRST_TIME = 0,0,1,0 %,
	NRP	   = 0,1,1,0 %;

    ! Initialize some variables.
    !
    FLAGS = 0;
    FLAGS[FIRST_TIME] = 1;

    IRAB[IRB$W_SAVE_POS] = 0;

    ! If the index descriptor is for the current key of reference, then the 
    ! NRP information will be used in the positioning.
    !
    IF (.IDX_DFN[IDX$B_KEYREF] EQLU .IRAB[IRB$B_CUR_KREF])
    THEN
	FLAGS[NRP] = 1;

    ! We may have to make two circuits through roughly the same code; 
    ! therefore, setup the circumstances for doing so - ie simulate a GOTO.
    ! This loop can only be exited by returning to the calling routine.
    !
    WHILE 1
    DO
	BEGIN

	GLOBAL REGISTER
	    COMMON_IO_STR;

	LOCAL
	    SEARCH_RESULT;

	! If the next record positioning formation is to be used, and this is 
	! the first time through the loop, then use the next record context in
	! the attempt to positioning to the desired SIDR.
	!
	IF  .FLAGS[NRP] AND .FLAGS[FIRST_TIME]
	THEN
	    BEGIN

	    ! All SIDR buckets are exclusively accessed in case space 
	    ! reclamation will be required.
	    !
	    IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

	    ! First, access the bucket hopefully containing the current record
	    ! using the next record context information. 
	    !
	    RETURN_ON_ERROR (RM$GETBKT (.IRAB[IRB$L_CUR_VBN],
					.IDX_DFN[IDX$B_DATBKTSZ]*512));
	    IRAB[IRB$L_CURBDB] = .BDB;

	    ! Next, do a search through this bucket looking for a SIDR with a 
	    ! key value the same as that of the current record, the key of 
	    ! which maybe found in keybuffer 2.
	    !
	    BKT_ADDR = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];
	    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;

	    SEARCH_RESULT = RM$SRCH_BY_KEY();
	    END

	! If the next record positioning information can not be used to 
	! position to the desired SIDR either because it is for the wrong key
	! of reference, or because this is not the first time through this
	! loop, then perform a random search of the alternate index using as 
	! the search key the key in keybuffer 2.
	!
	ELSE
	    BEGIN

	    RETURN_ON_ERROR (RM$CSEARCH_TREE());

	    ! Determine whether the SIDR positioned to has a key greater 
	    ! than or equal to or less than the key in keybuffer 2.
	    !
	    SEARCH_RESULT = RM$COMPARE_REC (KEYBUF_ADDR(2), 
					    .IDX_DFN[IDX$B_KEYSZ],
					    0);
	    END;

	! The SEARCH_RESULT can be greater-than only if RMS is currently 
	! positioning using the NRP context information, and the key in 
	! keybuffer 2 is greater than the key of every SIDR in the current 
	! bucket. In such a situation, RMS knows that the SIDR it was looking 
	! for has moved since it was accessed by this process. Therefore, this
	! SIDR could not have been in a continuation bucket, and if its still 
	! in the ISAM file it can be positioned to by performing a random 
	! search of the alternate key index using the record's key value after
	! releasing the current SIDR bucket.
	!
	IF .SEARCH_RESULT GTR 0
	THEN
	    BEGIN
	    FLAGS[FIRST_TIME] = 0;
	    RELEASE (IRAB[IRB$L_CURBDB]);
	    END

	! The SEARCH_RESULT can be less-than only if RMS was unable to find
	! a SIDR record with a key equal to the key in keybuffer 2 either in 
	! the current bucket (if the NRP context information was being 
	! utilized) or anywhere in the alternate index (if it was not). Under
	! such circumstances, the SIDR RMS has positioned to, which has a key
	! greater than the key in keybuffer 2, is the desired SIDR. 
	!
	ELSE
	    IF .SEARCH_RESULT LSS 0	
	    THEN

		! If RMS had been using the NRP context information to position
		! to the current SIDR then this means that the current SIDR has
		! been deleted. To indicate this IRB$W_SAVE_POS is left at 
		! zero and an RMS error of record delete is returned although
		! whether this is an error or not depends upon the context in 
		! which this routine is called.
		!
		IF .FLAGS[NRP]
		THEN
		    RETURN RMSERR(DEL)

		! If the NRP context information had never been used, then this
		! SIDR represents the desired SIDR, and a successful status is
		! returned.
		!
		ELSE
		    RETURN RMSSUC()

	    ! RMS has successfully positioned to a SIDR with a key exactly
	    ! matching the key to be found in keybuffer 2.
	    !
	    ELSE

		! If the SIDR RMS is to retrieve is in fact the current record,
		! then even though RMS has been able to position to a SIDR
		! with the same key as the current record, this SIDR may not be
		! the current record. To determine this, the RFA pointer of
		! the found SIDR's first array element must be compared with 
		! the RFA pointer of the first element of the current record
		! which is part of the next record context found in the IRAB.
		!
		IF .FLAGS[NRP]
		THEN
		    BEGIN

		    LOCAL
			FIRST_VBN,
			FIRST_ID;

		    ! Retrieve the RFA pointer of the SIDR's first element.
		    !
		    RM$SIDR_FIRST (1;FIRST_VBN, FIRST_ID);

		    ! If the RFA pointer of the SIDR's first element matches
		    ! the RFA pointer of the current SIDR's first element
		    ! saved as part of the next record positioning context, 
		    ! then RMS has been able to successfully position to the 
		    ! current record. Load the number of array elements 
		    ! preceeding the current element in to IRB$W_SAVE_POS and
		    ! return success.
		    !
		    IF  (.FIRST_VBN EQLU .IRAB[IRB$L_SIDR_VBN])
			 AND
			(.FIRST_ID EQLU .IRAB[IRB$W_SIDR_ID])
		    THEN
			BEGIN
			IRAB[IRB$W_SAVE_POS] = .IRAB[IRB$W_CUR_COUNT];
			RETURN RMSSUC();
			END

		    ! If either the VBN or the ID of the first element of the
		    ! current record and the first element of the SIDR RMS has
		    ! positioned to do not match, then the current SIDR has
		    ! been deleted, IRB$W_SAVE_POS is left at 0, and a RMS 
		    ! error of record deleted is returned (although whether 
		    ! this is an error or not depends upon the context in 
		    ! which this routine is called.
		    !
		    ELSE
			RETURN RMSERR(DEL);
		    END

		! If RMS is not asked to specifically retrieve the current
		! record, then this SIDR with a key equal to the key in
		! keybuffer 2 is the desired SIDR, and a status of success
		! is returned.
		!
		ELSE
		    RETURN RMSSUC();

	END;


    END;					! {  of routine }

%SBTTL 'RM$POS_SEQ'
GLOBAL ROUTINE RM$POS_SEQ : RL$RABREG_67 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routines responsibility is to direct RMS's positioning to the next
!	primary data record to be returned. In some cases the next primary data
!	record will be the current primary data record (if IRB$V_SKIP_NEXT is 
!	not set and the current record is not deleted), but in most cases the 
!	next primary data record will in fact be the first non-deleted primary
!	data record RMS can position to after positioning to the current 
!	primary data record or SIDR array element.
!
!	This routine handles the positioning itself if the primary key is the
!	current key of reference, and it also directs the positioning to the 
!	very first SIDR if the current index is an alternate index, and this is
!	the first positioning attempt after a $CONNECT or $REWIND. However, 
!	this routine handles all subsequent SIDR positionings by calling 
!	RM$FIND_SIDR to position to the current SIDR and RM$SEARCH_SIDR to 
!	position to the current array within the SIDR.
!
!	RMS's first task is to position to the current record (to the current
!	SIDR array element if the current record is a SIDR). One basic 
!	assumption is made by this routine, and that is that if RMS is 
!	positioning by the primary key of reference and duplicate primary keys
!	ARE allowed then this process's current record MUST be present in 
!	the file. This is because the only time the space held by a record can
!	be reclaimed on that record's deletion is if duplicate primary keys are
!	not allowed in the file. The same can not be said to be true for 
!	SIDRs. If every element in a SIDR array is deleted it will be possible 
!	to delete the entire SIDR regardless of whether it is any process's
!	current record or not.
!	
!	Once RMS has positioned to the current record, it can position to the
!	primary data record to be returned (which may in fact be the current
!	primary data record). This positioning is accomplished by this routine,
!	if the primary key is the current key of reference, or by 
!	RM$SEARCH_SIDR if it is not.
!
!	The algorithm used by this routine in positioning to the current record
!	when the primary key is the key of reference is as follows:
!
!	1) If this is the first time a positioning is attempted after a 
!	   $CONNECT or $REWIND there is no current record so position to the
!	   very first non-deleted primary data record in the file.
!
!	2) Otherwise, the current record information is used to access the
!	   current bucket and search for the record in there.
!
!	3) If the current record is not found in the current bucket and the
!	   VBN of the current primary data record and current bucket differ, 
!	   then attempt to find the current primary data record utilizing its 
!	   RFA address.
!
!	4) If RMS is still unable to find the current record it must have been
!	   deleted; therefore RMS performs a random search of the index either
!	   to locate the deleted record (just marked deleted) or to find the 
!	   next record (prologue 3 files not allowing duplicate primary keys 
!	   only).
!
!	   a) If duplicates are allowed the search is for the first record with
!	      an identical key. A search is then made of all primary data 
!	      records with this key value until the current record, which is
!	      guarenteed to be in the file, is found.
!
!	   b) If duplicates are not allowed then the search is for the first 
!	      record with a key greater than or equal to the key of the 
!	      current record. This is because if duplicates are not allowed
!	      a greater-than or equal search will position RMS to the first
!	      record of identical or greater key value, and the next 
!	      non-deleted record, (including thwe one directly positioned to)
!	      is the record RMS wants to return.
!
! CALLING SEQUENCE:
!	BSBW RM$POS_SEQ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN			- address of index descriptor
!	    IDX$B_DATBKTSZ	- size of data bucket
!	    IDX$B_KEYREF	- key of reference
!
!	IFAB			- address of IFAB
!	    IFB$W_KBUFSZ	- keybuffer size
!	    IFB$V_RU		- if set, file is Recovery Unit Journallable
!	    IFB$V_WRTACC	- if set, stream has write access to the file
!
!	IRAB			- address of IRAB
!	    IRB$W_CUR_ID	- ID of current record
!	    IRB$L_CUR_VBN	- VBN of current record
!	    IRB$L_KEYBUF	- address of keybuffers
!	    IRB$V_SKIP_NEXT	- if set, skip current record and return next
!	    IRB$W_POS_ID	- ID of user data record for NRP positioning
!	    IRB$L_POS_VBN	- VBN of user data record for NRP positioning
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRB$L_CURBDB	- address of the BDB describing the primary data bucket
!	IRB$V_DEL_SEEN	- deleted records seen between current and next record
!	IRB$W_FIRST_ID	- ID of the next SIDR's first element's RRV pointer
!	IRB$L_FIRST_VBN	- VBN of the next SIDR's first element's RRV pointer
!	IRB$W_RFA_ID	- ID of the next record (primary data only)
!	IRB$L_RFA_VBN	- VBN of the next record (SIDR or primary data)
!	IRB$W_SAVE_POS	- number of elements preceeding next SIDR array element
!	REC_ADDR	- address of next primary data record
!	
! ROUTINE VALUE:
!
!	EOF - end-of-file encountered before record to be returned is found.
!	SUC - found non-deleted primary data record to return.
!	BUG - serious internal error precluded positioning to a record.
!	various I/O errors
!
! SIDE EFFECTS:
!
!	SUC - if the primary key is the key of reference, IRB$L_RFA_VBN and
!	      IRB$W_RFA_ID have their assigned values, and if not, 
!	      IRB$L_RFA_VBN, IRB$L_FIRST_VBN, IRB$W_FIRST_ID, and 
!	      IRB$W_SAVE_POS have their assign values. In both cases, REC_ADDR,
!	      IRB$V_DEL_SEEN, and IRB$L_CURBDB have their assigned values.
!	In all other cases, these fields have indeterminate values and all
!	      bucket locks have been released.
!	AP IS TRASHED
!	IRB$B_STOPLEVEL is 0
!	IRB$W_SRCHFLGS is of indeterminate status
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;


    ! Initialize some search control fields.
    !
    IRAB[IRB$B_STOPLEVEL] = 0;
    IRAB[IRB$W_SRCHFLAGS] = 0;

    ! If this is the very first time RMS is positioning after a $CONNECT or
    ! $REWIND then position to the very first non-RRV record in the very first
    ! SIDR/primary data bucket.
    !
    IF  (.IRAB[IRB$L_CUR_VBN] EQLU 0)
	 AND
	(.IRAB[IRB$L_POS_VBN] EQLU 0)
    THEN
	BEGIN

	IRAB[IRB$V_FIRST_TIM] = 1;
	RET_ON_ERR_EOF(RM$CSEARCH_TREE(), IRAB[IRB$V_FIRST_TIM] = 0);

	! If RM$CSEARCH_TREE positioned RMS to an empty bucket, position to the
	! first non-empty bucket or until the end-of-file is encountered.
	!
	WHILE 1
	DO
	    BEGIN

	    GLOBAL REGISTER
		COMMON_IO_STR;

	    LOCAL
		VBN;

	    BKT_ADDR = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];

	    ! If RMS has positioned to a RRV in a primary data bucket, or if
	    ! the bucket is empty, then RMS nust release this bucket, and access
	    ! the next one in the horizontal chain. Otherwise, RMS starts its
	    ! search for the first non-deleted primary data record with the
	    ! first record in this bucket.
	    !
	    IF  NOT ((.IDX_DFN[IDX$B_KEYREF] EQLU 0
				 AND
				.REC_ADDR[IRC$V_RRV])
		      OR
		     (.BKT_ADDR[BKT$W_FREESPACE] LEQU BKT$C_OVERHDSZ))
	    THEN
		EXITLOOP;

	    ! If this is the last data bucket in the horizontal chain then
	    ! every single bucket is empty. End the search for the first
	    ! non-empty bucket and return end-of-file.
	    !
	    IF .BKT_ADDR[BKT$V_LASTBKT]
	    THEN
		BEGIN
		RELEASE(IRAB[IRB$L_CURBDB]);
		RETURN RMSERR(EOF);
		END;

	    ! Save the VBN of the next bucket in the horizontal chain, release
	    ! the current bucket, and then access the next bucket by its VBN.
	    !
	    VBN = .BKT_ADDR[BKT$L_NXTBKT];
	    RELEASE(IRAB[IRB$L_CURBDB]);

	    ! If the file is Recovery Unit Journallable and write accessed or 
	    ! the positioning is being done by alternate key of reference, then
	    ! make sure the next data bucket in the horizontal chain is 
	    ! exclusively accessed.
	    !
	    IF  (.IFAB[IFB$V_WRTACC]
			 AND
			.IFAB[IFB$V_RU])
		 OR
		.IDX_DFN[IDX$B_KEYREF] NEQU 0
	    THEN
		IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

	    RETURN_ON_ERROR (RM$GETBKT(.VBN, .IDX_DFN[IDX$B_DATBKTSZ]*512));

	    IRAB[IRB$L_CURBDB] = .BDB;
	    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
	    END;

	! When the first non-empty bucket has been encountered and REC_ADDR 
	! is setup to point to the first record in that bucket, then clear the
	! first time flag.
	!
	IRAB[IRB$V_FIRST_TIM] = 0;

	! If the key of reference is the primary key, then RMS must find the
	! first non-deleted primary data record in the file. If this is an 
	! alternate index, RMS does not need to do this positioning because 
	! that will be done when RMS positions to the first non-deleted 
	! primary data record.
	!
	IF .IDX_DFN[IDX$B_KEYREF] EQL 0
	THEN
	    RETURN_ON_ERROR (RM$FIND_NONDEL (1))

	! If the key of reference is not the primary key, then RMS is to
	! start its search for the first non-deleted primary data record in 
	! the file with the very first array element of the SIDR it has 
	! positioned to.
	!
	ELSE
	    IRAB[IRB$W_SAVE_POS] = 0;
	END

    ! This is not the first time RMS has sequentially accessed the file since
    ! a $CONNECT, or $REWIND was done. If RMS is positioning by means of an
    ! alternate key of reference, then all of the positioning to the current 
    ! SIDR and the current array element within that SIDR is done by the 
    ! routine RM$FIND_SIDR.
    !
    ELSE
	IF .IDX_DFN[IDX$B_KEYREF] NEQ 0
	THEN
	    BEGIN

	    LOCAL
		STATUS;

	    IRAB[IRB$V_SRCHGE] = 1;

	    ! If some serious error occurred during RMS's positioning to the
	    ! current SIDR, then immediately return the error. However, if
	    ! RMS has successfully positioned to the current SIDR then
	    ! IRB$W_SAVE_POS contains the number of array elements preceeding
	    ! the current SIDR array element.
	    !
	    IF NOT ((STATUS = RM$FIND_SIDR())
		     OR
		    (.STATUS<0,16> EQL RMSERR(DEL)))
	    THEN

		! If the current SIDR was the last SIDR in the file, and it
		! has been deleted, return EOF indicating that the end of the
		! file has been encountered; otherwise, return the actual error.
		!
		IF .STATUS<0,16> EQLU RMSERR(RNF)
		THEN
		    RETURN RMSERR(EOF)
		ELSE
		    RETURN .STATUS;

	    ! If RMS is successful at positioning to the current SIDR then 
	    ! setup to return the next record provided RMS is to return the 
	    ! next record (IRB$V_SKIP_NEXT is set).
	    !
	    IF .STATUS AND .IRAB[IRB$V_SKIP_NEXT]
	    THEN
		IRAB[IRB$W_SAVE_POS] = .IRAB[IRB$W_SAVE_POS] + 1;
	    END

	! If this is not the first time sequentially accessing a record after
	! a $REWIND or $CONNECT, and RMS is to position by the primary key of
	! reference, then RMS's strategy is to first position to the current
	! record which must be present somewhere in the file if it allows
	! duplicate primary keys. RMS will return either its position or that 
	! of the next non-deleted primary data record which follows it based 
	! upon whether or not it found the current record to be deleted, and 
	! whether it was to return the current or the next record.
	!
	ELSE
	    BEGIN

	    FIELD 
		POS_FLAGS =
		    SET
		    FND_BY_RRV	= [0,0,1,0],
		    FND_BY_SRCH	= [0,1,1,0]
		    TES;

	    LOCAL
		FLAG	: BLOCK[1,BYTE]
			  FIELD (POS_FLAGS);

	    FLAG = 0;

	    ! RMS will use the VBN and ID of the current record positioning
	    ! information to attempt to position directly to the current 
	    ! primary data record.
	    !
	    BEGIN

	    BUILTIN
		AP;

	    LOCAL 
		STATUS;

	    ! If the file is Recovery Unit Journallable and write accessed, then
	    ! make sure the current primary data bucket exclusively accessed.
	    !
	    IF  .IFAB[IFB$V_WRTACC]
		 AND
		.IFAB[IFB$V_RU]
	    THEN
		IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

	    AP = .IRAB[IRB$W_CUR_ID];
	    STATUS = RM$FIND_BY_RFA (.IRAB[IRB$L_CUR_VBN]);

	    ! On any errors other than record not found or record deleted
	    ! return immediately. These will be I/O errors.
	    !
	    IF NOT (.STATUS
		    OR
		   (.STATUS<0,16> EQL RMSERR(RNF))
		    OR
		   (.STATUS<0,16> EQL RMSERR(DEL)))
 	    THEN
		RETURN .STATUS;

	    ! If RMS is unable to find any record through use of the
	    ! current record information, or if it finds a RRV then this
	    ! indicates that the current record must have moved, or may have
	    ! been deleted.
	    !
	    IF  NOT .STATUS
		 OR
		.REC_ADDR[IRC$V_RRV]
	    THEN
		BEGIN

		GLOBAL REGISTER
		    COMMON_IO_STR;

		! If the VBN of the current record is not the same as the
		! VBN of the current record's RFA address, then RMS has no
		! way of knowing what has happened to the record. RMS has 
		! no way of knowing whether it has not been deleted and 
		! can still be access through its RFA, or whether it has 
		! been deleted and can not. In this case, RMS must search 
		! for the record by its RFA address, saved as part of the 
		! next record positioning context information, to confirm 
		! its status.
		!
		IF .IRAB[IRB$L_CUR_VBN] NEQ .IRAB[IRB$L_POS_VBN]
		THEN
		    FLAG[FND_BY_RRV] = 1

		! If RMS has positioned to a RRV through the use of the
		! current record information, and the VBN of that bucket is
		! the same as the VBN of the current record's RFA address,
		! then RMS has positioned to the RRV for the current 
		! record. Provided, the RRV is not marked deleted, RMS will
		! be able to position to the current record by means of its
		! RFA address.
		!
		ELSE
		    IF  .STATUS
			 AND
			.REC_ADDR[IRC$V_RRV]
			 AND
			NOT .REC_ADDR[IRC$V_DELETED]
		    THEN
			FLAG[FND_BY_RRV] = 1

		    ! If the VBN of the current record is the same as the 
		    ! VBN of the current record's RFA address, and RMS 
		    ! was unable to position to a record (Prologue 3 - RRVs
		    ! are deleted entirely although the record is just
	  	    ! marked), or it was able to position to a deleted RRV
		    ! (Prologue 1), then this indicates that the current
		    ! record has been deleted. In such a situation a random
		    ! search of the primary index will have to be done
	 	    ! either to locate the next record itself (primary key 
		    ! duplicates NOT allowed), or to locate the current record.
		    !
		    ELSE
			FLAG[FND_BY_SRCH] = 1;

		! It will be necessary to release the primary data bucket
		! described by the current record information, if RMS has
		! positioned to an RRV, and the bucket is still locked.
		!
		IF .STATUS
		THEN
		    RELEASE (IRAB[IRB$L_CURBDB]);

		END

	    ! RMS has successfully positioned to a non-RRV record by means
	    ! of the next record positioning context information in the
	    ! IRAB. This does not mean that RMS has positioned to the 
	    ! current record because it would be possible in a prologue 1 file
	    ! for the current record to move, and its ID re-used by another 
	    ! record (ID recycling is allowed in one special circumstance). 
	    ! Therefore, that the record RMS has positioned to is in fact the 
	    ! current record must be verified by comparing the RRV in the 
	    ! record positioned to with the RFA address of the current record.
	    ! 
	    ELSE

		! If the RRV of the record RMS has positioned to is not the
		! same as the RFA address of the current record, then RMS
		! has failed to position to the current record. If this is
		! a prologue 3 file, then this represents a serious error
		! because IDs within a bucket may not be recycled. If this
		! is a prologue 1 file this does not represent a serious
		! error because IDs maybe recycled; therefore, attempt to
		! position to the current record by means of its RFA 
		! address.
		!
		IF NOT RM$CHECK_RRV()
		THEN
		    BEGIN

		    GLOBAL REGISTER
			COMMON_IO_STR;

		    RELEASE (IRAB[IRB$L_CURBDB]);

		    IF .IFAB[IFB$B_PLG_VER] GEQU PLG$C_VER_3
		    THEN
			 RETURN RMSERR(BUG)
		    ELSE
			FLAG[FND_BY_RRV] = 1
		    END

		! If the RRV of the record RMS has positioned to is the
		! same as the RFA address of the current record, then RMS 
		! has successfully positioned to the current record.
		!
		! Look for the next non-deleted primary data record. Begin
		! the search with the current record if and only if the
		! state bit IRB$V_SKIP_NEXT is clear.
		!
		ELSE
		    RETURN_ON_ERROR 
			(RM$FIND_NONDEL (NOT .IRAB[IRB$V_SKIP_NEXT]));
	    END;

	    ! If RMS was unable to position to the current record by means
	    ! of the current record information, then it may try to position
	    ! to the current record by means of its RFA address. It will try
	    ! to do so as long as it knows that the current record has not
	    ! been deleted. 
	    !
	    IF .FLAG[FND_BY_RRV]
	    THEN
		BEGIN

		LOCAL
		    STATUS;

		! If the file is Recovery Unit Journallable and write accessed, 
		! then make sure the primary data bucket bucket containing the 
		! current primary data record is exclusively accessed.
		!
		IF .IFAB[IFB$V_WRTACC]
		    AND
		   .IFAB[IFB$V_RU]
		THEN
		    IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

		! Position to the current record by means of its RFA address.
		!
		STATUS = RM$FIND_BY_RRV (.IRAB[IRB$L_POS_VBN], 
					 .IRAB[IRB$W_POS_ID],
					 0);

		! If RMS is unable to position to the current record by means
		! of its RFA address, and the status is other than record
		! deleted, then save the real reason for the failure in the
		! RAB's STV field and return an invalid internal condition.
		!
		IF NOT .STATUS
		    AND
		   (.STATUS<0,16> NEQ RMSERR(DEL))
		THEN
		    BEGIN
		    RAB[RAB$L_STV] = .STATUS;
		    RETURN RMSERR(BUG);
		    END

		! If RMS is unable to position to the current record because
		! it has been deleted, then indicate that a random search of 
		! the primary index to either locate the current record or
		! to locate the next primary data record (primary key 
		! duplicates not allowed) must be done.
		!
		ELSE
		    IF NOT .STATUS
		    THEN
			FLAG[FND_BY_SRCH] = 1

		    ! RMS has successfully positioned to a primary data record
		    ! through the use of the RFA address of the current record
		    ! saved as part of the IRAB's next record positioning
		    ! context. Before continuing, verify that the record RMS
		    ! has positioned to is in fact the current record.
		    !
		    ELSE

		        ! If the RRV of the record RMS has positioned to is 
			! not the same as the RFA address of the current record
			! then RMS has failed to position to the current record
			! by means of the next record context information. This
			! represents a serious error, regardless of the 
			! prologue. Release the primary data bucket and return
			! a status of invalid internal condition or bug error.
			!
			IF NOT RM$CHECK_RRV()
			THEN
			    BEGIN

			    GLOBAL REGISTER
				COMMON_IO_STR;

			    RELEASE (IRAB[IRB$L_CURBDB]);

			    RETURN RMSERR(BUG)
			    END

			! If the RRV of the record RMS has positioned to is the
			! same as the RFA address of the current record, then 
			! RMS has successfully positioned to the current record
			! by means of its RFA address.
			!
			! Look for the next non-deleted primary data record.
			! Begin the search with the current record if and 
			! only if the state bit IRB$V_SKIP_NEXT is clear.
			!
			ELSE
			    RETURN_ON_ERROR 
				(RM$FIND_NONDEL (NOT .IRAB[IRB$V_SKIP_NEXT]));
		END;

	    ! If the current record has been deleted then a random search
	    ! of the primary index must be done as part of positioning to 
	    ! the primary data record to be returned.
	    !
	    IF .FLAG[FND_BY_SRCH]
	    THEN
		BEGIN

		! If duplicate keys are not allowed and the current record is 
		! deleted then it will have been completely deleted from a 
		! prologue 3 file, and only a RRV will be left in a prologue 2
		! file. Therefore, a search for the first non-deleted primary 
		! data record with a key equal to or greater than the key of 
		! the current record will position RMS to the record it is to 
		! return. 
		!
		IF NOT .IDX_DFN[IDX$V_DUPKEYS]
		THEN
		    BEGIN

		    ! Position to the next first record with a key value equal
		    ! to or greater than the key of the current record.
		    !
		    IRAB[IRB$V_SRCHGE] = 1;
		    RETURN_ON_ERROR (RM$CSEARCH_TREE());

		    ! Return the first non-deleted primary record encountered
		    ! beginning the search with the record RMS has positioned
		    ! to.
		    !
		    RETURN_ON_ERROR (RM$FIND_NONDEL(1));
		    END

		! If duplicate primary keys are allowed then the deleted 
		! current record must still be somewhere in the file although 
		! marked deleted. Position to it by searching all records of 
		! key value identical to that of the current record until it 
		! is located.
		!
		ELSE
		    BEGIN

		    ! Search for the first record in the file with the same 
		    ! primary key value as the key of the current record. If 
		    ! none is found then this represents a serious problem 
		    ! because the current record itself must always be 
		    ! somewhere in the file even if it has been deleted.
		    !
		    IF NOT RM$CSEARCH_TREE()
		    THEN
			RETURN RMSERR(BUG)

		    ! RMS has successfully positioned to a primary data record 
		    ! with the same key as that of the current record. 
	   	    ! Somewhere in this bucket (or in any of the following 
		    ! continuation buckets if duplicates are allowed) must be 
		    ! the (marked) deleted current record. Position to the 
		    ! current record. After positioning to the current record,
		    ! the next non-deleted primary data record in the file is 
		    ! the record RMS wants to return.
		    !
		    ELSE
			BEGIN

			LOCAL
			    STATUS;

			! Since the current record must be in the file even if
			! it is just marked deleted, RMS's search criteria is 
			! to sequentially find all records with key value 
			! equal to that of the current record until the current
			! record is positioned to.
			!
			STATUS = 1;

			DO
			
			    ! The record RMS has currently positioned to is 
			    ! the current record when its RRV matches the RFA 
			    ! address of the current record. In such a case 
			    ! find the next non-deleted primary data record in
			    ! the file.
			    !
			    IF RM$CHECK_RRV() 
			    THEN
				BEGIN
				RETURN_ON_ERROR (RM$FIND_NONDEL (0));
				EXITLOOP;
				END

			    ! If the record RMS has positioned to is not the
			    ! current record (its RRV does not match the RFA
			    ! of the current record), then position to the next
			    ! record. RM$CSEARCH_TREE will then determine 
			    ! whether the key of this next record is the same
			    ! as the key of the current record.
			    !
			    ELSE
				RM$GETNEXT_REC()

			    WHILE (STATUS = RM$CSEARCH_TREE());

			! If RMS was unable to find the current record in the
			! file then this represents a serious error because
			! current records can never be completely deleted from
			! the file while they remain current records. Return 
			! status indicative of an invalid internal condition.
			!
			IF NOT .STATUS
			THEN
			    IF .STATUS<0,16> EQL RMSERR(RNF)
			    THEN
				RETURN RMSERR(BUG)
			    ELSE
				RETURN .STATUS;
			END;
		    END;
		END;
	    END;

    ! If RMS is positioning by primary key of reference then all RMS has to do
    ! is set up the next record list context for this record, and return 
    ! success.
    !
    IF .IDX_DFN[IDX$B_KEYREF] EQL 0
    THEN
	BEGIN
	IRAB[IRB$W_RFA_ID] = IRC$_ID(REC_ADDR);
	IRAB[IRB$L_RFA_VBN] = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_VBN];
	BBLOCK[.IRAB[IRB$L_CURBDB], BDB$V_PRM] = 1;
	RETURN RMSSUC()
	END

    ! If RMS is positioning by means of an alternate key, it still must 
    ! position to the array element pointing to the non-deleted primary data 
    ! record to be returned.
    !
    ELSE
	BEGIN

	LOCAL
	    STATUS;

	STATUS = 1;

	! Search all SIDRs having the same key as the SIDR RMS has positioned 
	! to until the primary data record to be returned has been found, or 
	! until there are no more SIDRs with this key value.
	!
	WHILE .STATUS
	DO
	    BEGIN
	    IRAB[IRB$V_SRCHGE] = 0;
	    IRAB[IRB$V_PRM] = 1;

	    ! If RMS has successfully positioned to a non-deleted primary data
	    ! record, return success
	    !
	    IF STATUS = RM$SEARCH_SIDR()
	    THEN
		RETURN .STATUS;

	    ! If RMS was unable to find a non-deleted primary data record with
	    ! an alternate key with the same value as the SIDR RMS has 
	    ! positioned to, then move onto the next SIDR with a key greater
	    ! then that of the current SIDR.
	    !
	    IF .STATUS<0, 16> EQL RMSERR(RNF)
	    THEN
		BEGIN
		IRAB[IRB$V_SRCHGE] = 1;
		STATUS = RM$CSEARCH_TREE();

		! If RMS is unable to find a SIDR on a greater or equal search
		! then this can only be because it has reached the 
		! end-of-file, and so return the appropriate status.
		!
		IF .STATUS<0, 16> EQL RMSERR(RNF)
		THEN
		    STATUS = RMSERR(EOF)

		! Otherwise continue the search for a non-deleted primary data 
		! record with the first array element of the next SIDR.
		!
		ELSE
		    IRAB[IRB$W_SAVE_POS] = 0;
		END;

	    END;

	RETURN .STATUS;

	END;

    END;					! { end of routine  }

END

ELUDOM
