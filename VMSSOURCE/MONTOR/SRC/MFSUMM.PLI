MFSUM_REQUEST: Procedure	Returns(Fixed Binary(31))		/* Routine to execute multi-file summary request */
				Options(Ident('V04-000'));

/*
/****************************************************************************
/*									    *
/*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
/*  ALL RIGHTS RESERVED.						    *
/* 									    *
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
/*  TRANSFERRED.							    *
/* 									    *
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
/*  CORPORATION.							    *
/* 									    *
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
/* 									    *
/*									    *
/****************************************************************************
/*/

/*
/*++
/* FACILITY:  MONITOR Utility 
/*
/* ABSTRACT:  MFSUM_REQUEST Routine.
/*		
/*		 Called from MONMAIN routine to execute a single
/*		   MONITOR multi-file summary request.
/*
/*
/* ENVIRONMENT:
/*
/*		Unprivileged user mode.
/*
/* AUTHOR:  Thomas L. Cafarella, January, 1984
/*
/*
/* MODIFIED BY:
/*
/*	V03-006	TLC1088		Thomas L. Cafarella	25-Jul-1984	14:00
/*		Free virtual memory obtained for multi-file summary.
/*
/*	V03-005	TLC1077		Thomas L. Cafarella	11-Jul-1984	14:00
/*		Continue multi-file summary even if some input files are empty.
/*
/*	V03-004	TLC1071		Thomas L. Cafarella	17-Apr-1984	14:00
/*		Add "number of input files" to multi-file summary report.
/*
/*	V03-003	TLC1069		Thomas L. Cafarella	13-Apr-1984	14:00
/*		Fix ACCVIO when multi-file summary requested for SYSTEM class
/*		and single-statistic.
/*
/*	V03-002	PRS1021		Paul R. Senn		12-Apr-1984	10:00
/*		Make SYSTEM class work with multi-file summary.
/*
/*	V03-002	PRS1020		Paul R. Senn		12-Apr-1984	10:00
/*		Make XQP class work with multi-file summary.
/*
/*	V03-002	TLC1060		Thomas L. Cafarella	12-Mar-1984	11:00
/*		Make multi-file summary work for homogeneous classes.
/*
/*	V03-001	TLC1053		Thomas L. Cafarella	07-Mar-1984	11:00
/*		Add support to ignore unused files for multi-file summary.
/*
/*--
/*/

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MFSUM_REQUEST
/*
/*	TBS
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	Monitor Request Block (MRB), pointed to by MRBPTR.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/* SIDE EFFECTS:
/*
/*	None
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */
%INCLUDE	$CHFDEF;					/* Condition handler facility definitions */
%INCLUDE	$STSDEF;					/* Status value definitions */
%INCLUDE	SYS$CANCEL;					/* $CANCEL system service */
%INCLUDE	SYS$PUTMSG;					/* $PUTMSG system service */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MAX_CLASS_NO	FIXED BINARY(31) GLOBALREF VALUE,		/* Maximum defined class number */
PROCS_CLSNO	FIXED BINARY(31) GLOBALREF VALUE,		/* Class number for the PROCESSES class */
MAXELTS_MFS	FIXED BINARY(31) GLOBALREF VALUE,		/* Max no. of elements for a homogeneous class m.f. summary */
MAX_ELIDLEN	FIXED BINARY(31) GLOBALREF VALUE,		/* Max length of an element id for a homogeneous class */
MAX_HOM_ITEMS	FIXED BINARY(31) GLOBALREF VALUE,		/* Max no. of items for a homogeneous class */
MAX_INP_FILES	FIXED BINARY(31) GLOBALREF VALUE,		/* Max no. of input files for multi-file summary */
ECOUNT_SYS_ALL	FIXED BINARY(31) GLOBALREF VALUE;		/* Element count for SYS/ALL */

Declare
CDBPTR			POINTER GLOBALREF,			/* Pointer to CDB (Class Descriptor Block) */
C			POINTER DEFINED(CDBPTR),		/* Synonym for CDBPTR */
MCAPTR			POINTER GLOBALREF,			/* Pointer to MCA (Monitor Communication Area) */
MC			POINTER DEFINED(MCAPTR),		/* Synonym for MCAPTR */
MRBPTR			POINTER GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
M			POINTER DEFINED(MRBPTR);		/* Synonym for MRBPTR */

Declare
H			POINTER GLOBALREF;			/* Pointer to input file header */

Declare
INPUT_FILE	FILE RECORD INPUT;				/* Monitor Input (Playback) File */

Declare
CTRLCZ_CHAN	FIXED BINARY(31) GLOBALREF,			/* Channel number for CTRL-C and CTRL-Z */
CTRLCZ_HIT	BIT(1) ALIGNED	 GLOBALREF,			/* YES => CTRL-C or CTRL-Z has been hit */
NORMAL		FIXED BINARY(31) GLOBALREF;			/* MONITOR normal return status */

Declare
1 CDBHEAD GLOBALREF,						/* Table of CDB's */
  2 CDBLOCK (0:127) CHAR(CDB$K_SIZE);


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL ROUTINE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
EXECUTE_REQUEST	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR routine to execute a MONITOR request */
ESTAB_CTRLCZ	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to set up CTRL-C and CTRL-Z handlers */
INPUT_INIT	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR routine to do initialization on input file */
INPUT_CLEANUP	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR routine to do cleanup on input file */
SUMMARY_INIT	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to do summary init */
SUMMARY_CLEANUP	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR routine to do cleanup on summary file */
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),	/* MONITOR MACRO-32 routine to log synchronous errors */
SIGNAL_MON_ERR	ENTRY,						/* MONITOR MACRO-32 routine to signal MONITOR errors */
LINK_MON_ERR	ENTRY (ANY VALUE, ANY VALUE),			/* MONITOR MACRO-32 routine to link a MONITOR error to another */
QUAD_LT_QUAD	ENTRY (BIT(64) ALIGNED, BIT(64) ALIGNED) 	/* MONITOR MACRO-32 unsigned quadword compare routine */
		RETURNS(BIT(1));



/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			     MESSAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MNR$_NOCLASS	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_CLASDISAB	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOCOMMSTLEV FIXED BINARY(31) GLOBALREF VALUE,
MNR$_PREMEOF	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_INVINPFIL	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOCLASSES	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOINPFILES	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_IGNFIL	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOSUMM	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_DISPERR	FIXED BINARY(31) GLOBALREF VALUE;


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		       GLOBAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MFSPTR		POINTER GLOBALDEF,				/* Pointer to Multi-File Summary Block (MFS) */
CSBVEC_PTR	POINTER	GLOBALDEF,				/* Pointer to CSB Vector */
1 CSBVEC,							/* CSB Vector (of ptrs to CSBs) */
  2 CSB_POINTER	(1:MAX_INP_FILES) POINTER;			/* CSB pointers */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	NOT_SUCCESSFUL		BY '0'B;		/* Failing status bit */
%REPLACE 	YES			BY '1'B;		/* For general use */
%REPLACE 	NO			BY '0'B;		/* For general use */
%REPLACE	AND_OP			BY '0001'B;		/* AND Boolean operation */
%REPLACE	OR_OP			BY '0111'B;		/* OR Boolean operation */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CALL		FIXED BINARY(31),				/* Holds function value (return status) of called routines */ 
STATUS		BIT(1)	BASED(ADDR(CALL));			/* Low-order status bit for called routines */

Declare
IFBPTR		POINTER,					/* Pointer to Input File Block (IFB) */
CSBPTR		POINTER,					/* Pointer to Column Summary Block (CSB) */
DCDB		POINTER STATIC;					/* CDB for current class */

Declare
IFB_TAB_PTR	POINTER,					/* Pointer to IFB_TABLE */
1 IFB_TABLE	BASED(IFB_TAB_PTR),				/* Input File Block (IFB) Table */
  2 AN_IFB	(1:MAX_INP_FILES)  CHAR(IFB$K_SIZE);		/* A single IFB */

Declare
01 CURR_CLASS_DESCR (MAX_CLASS_NO+1),				/* Current Class Descriptor */
								/* This array of structures includes a CCD (Current */
								/* Class Descriptor) for each possible class. */
    02 CURR_CDBPTR	POINTER,				/* CDBPTR for current class */
    02 CURR_CLASS_NO	FIXED BINARY(7);			/* Class number for current class */

Declare
1 BUFFERS	BASED(MFS$A_STATSBUF),				/* Statistics buffers */
  2 TOT	(1:MAXELTS_MFS)	FIXED BINARY(31),			/* TOTAL statistics buffer */
  2 MIN	(1:MAXELTS_MFS)	FIXED BINARY(31),			/* MINIMUM statistics buffer */
  2 MAX	(1:MAXELTS_MFS)	FIXED BINARY(31);			/* MAXIMUM statistics buffer */

Declare
I		FIXED BINARY(15),				/* Loop control */
J		FIXED BINARY(15),				/* Loop control */
NON_EMPTY_FILES	FIXED BINARY(15),				/* Count of non-empty input files */
ST_LEV_COMM	CHAR(8),					/* Common file structure level */
FILE_CLASSES	BIT(128) ALIGNED,				/* Class bit string from current input file */
ALL_FILE_CLASSES BIT(128) ALIGNED,				/* Class bit string which is union (OR) of all input files */
CURR_NODENAME	CHAR(16),					/* Nodename from current input file */
FOUND_NODE	BIT(1) ALIGNED,					/* YES => a matching node was found in a CSB */
CURR_ERRCODE	FIXED BINARY(31),				/* MONITOR error status code currently expected */
MF_REQ_STATUS	FIXED BINARY(31),				/* MFSUM_REQUEST status code */
ALREADY_FAILED	BIT(1) ALIGNED;					/* YES => a failure has already been signaled */

ON FINISH;							/* On finish, do nothing */
ALREADY_FAILED = NO;						/* Indicate no failure yet signaled */
CURR_ERRCODE = 0;						/* Set expected MONITOR code to default */

/*
/*	Set up condition handler to terminate the MONITOR request on:
/*		1) any asynchronous error condition, such as file and I/O errors;
/*		2) any synchronous MONITOR-detected condition.
/*/

ON ANYCONDITION							/* On any condition signaled, */
BEGIN;

Declare
  MNR$_ERRINPFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
  MNR$_ERRRECFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
  MNR$_UNEXPERR		FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
  MON_CODE		FIXED BINARY(31),			/* Monitor message code */
  TEMP			FIXED BINARY(31),			/* Temporary scratch area */
  MNR$_FACNO		FIXED BINARY(31) GLOBALREF VALUE,	/* MONITOR facility number */
  ON_FILE		CHAR(100) VARYING,			/* Holds possible file name string */
  SIGNALED_ERR ENTRY (ANY VALUE, ANY VALUE, ANY VALUE, ANY);	/* Rtn to set up PUTMSGVEC */

IF ^ ALREADY_FAILED						/* If a failure not already signaled, */
    THEN DO;
	 ALREADY_FAILED = YES;					/* Indicate a failure has been signaled */
	 CHF$ARGPTR = ONARGSLIST();				/* Get signal array pointer */
	 STS$VALUE = CHF$SIG_NAME;				/* Get code for signaled condition */
	 UNSPEC(TEMP) = STS$FAC_NO;				/* Convert facility no. to binary in TEMP */
	 IF TEMP = MNR$_FACNO					/* If a MONITOR code, */
	     THEN MON_CODE = STS$VALUE;				/*     then remember it */
	     ELSE DO;						/* Otherwise, need to set the MON_CODE */
		  ON_FILE = ONFILE();				/* Get PL/I file constant if I/O cond */
		  IF ON_FILE = 'INPUT_FILE'			/* If input file error, */
		      THEN MON_CODE = MNR$_ERRINPFIL;		/* Set Monitor status code accordingly */
		      ELSE IF CURR_ERRCODE = 0			/* Else, see if an error is currently expected */
			       THEN MON_CODE = MNR$_UNEXPERR;	/* No, set "unexpected" code */
			       ELSE MON_CODE = CURR_ERRCODE;	/* Yes, set currently expected code */
		  CURR_ERRCODE = 0;				/* Reset to default MONITOR error code ("unexpected") */
		  CALL SIGNALED_ERR(MON_CODE,STS$VALUE,DIM(CHF$SIG_ARG,1),CHF$SIG_ARG); /* Log the error */
		  END;

	 MF_REQ_STATUS = MON_CODE;				/* Set up code for MONITOR request termination */
	 CALL MF_REQ_CLEANUP();					/* Perform cleanup for files, memory, etc. */
	 END;

GO TO MF_REQ_EXIT;						/* Go return from MFSUM_REQUEST (PL/I does an UNWIND) */

END;								/* End of ON-condition routine */

MC->MCA$V_EOF = NO;						/* End-of-file not hit yet */
ON ENDFILE(INPUT_FILE) MC->MCA$V_EOF = YES; 			/* Set up EOF condition */

CALL = MFSUM_INIT();						/* Perform init for this m.f. summary request */
IF STATUS = NOT_SUCCESSFUL THEN CALL SIGNAL_MON_ERR();		/* Signal error if failure */

/*
/*	Establish CTRL-C and CTRL-Z handlers for terminating the MONITOR request.
/*	CTRL-C causes a MONITOR> prompt. CTRL-Z returns to DCL.
/*/

CALL = ESTAB_CTRLCZ();						/* Establish CTRL-C and CTRL-Z handlers */
								/* If error, do not terminate; simply ignore CTRL-C's & CTRL-Z's */

/*
/*	For each input file, open it, do some checking of structure level, and classes,
/*	and build the Column Summary Block (CSB) (if necessary) to represent the column
/*	required in the summary report. There will be one column per file, or, if a
/*	by-node report was requested, one column per node.
/*/

NON_EMPTY_FILES = 0;						/* Init count of non-empty input files */
DO I = 1 TO M->MRB$B_INP_FILES  WHILE(CTRLCZ_HIT = NO);		/* Loop once per input file */
								/* ... as long as user has not terminated */
IFBPTR = ADDR(AN_IFB(I));					/* Establish current Input File Block */
M->MRB$A_INPUT = IFB$A_INPUT;					/* Establish current input file */
MC->MCA$V_EOF = NO;						/* End-of-file not hit yet */

CALL = INPUT_INIT();						/* Open input file and establish H as header record ptr */
IF STATUS = NOT_SUCCESSFUL THEN					/* If failed, */
  IF CALL ^= MNR$_PREMEOF THEN CALL SIGNAL_MON_ERR();		/*   then signal error for all but PREMEOF (empty file) */
  ELSE DO;							/*   but for PREMEOF, */
       IFB$B_COL_NO = 0;					/*   zero out column number, */
       CALL LINK_MON_ERR(MNR$_IGNFIL,IFB$A_INPUT);		/*   ... and issue info msg */
       END;

ELSE								/* If successful, */
  DO;								/* Beginning of successful do-group */
  NON_EMPTY_FILES = NON_EMPTY_FILES + 1;			/* Count this good file */
  IF NON_EMPTY_FILES = 1					/* If first file, */
      THEN ST_LEV_COMM = H->MNR_HDR$T_LEVEL;			/* ... then establish common structure level */
      ELSE IF ST_LEV_COMM ^= H->MNR_HDR$T_LEVEL			/* ... otherwise, file level must match common */
	       THEN DO;
		    CALL MON_ERR(MNR$_NOCOMMSTLEV);		/* ... if not, it's an error */
		    CALL SIGNAL_MON_ERR();			/* ... signal it */
		    END;

  IF MNR_HDR$K_CLASSBITS < MC->MCA$L_INPUT_LEN			/* If CLASSBITS field is defined for input file, */
      THEN FILE_CLASSES = H->MNR_HDR$O_CLASSBITS;		/*   then get file classes from usual place */
      ELSE FILE_CLASSES = H->MNR_HDR$O_REV0CLSBITS;		/*   else get them from another place */
								/* NOTE -- MNR_HDR$O_REV0CLSBITS is used for compatibility */
								/*         with MONSL001 and MONBA001 file struct levels */

  ALL_FILE_CLASSES = BOOL(ALL_FILE_CLASSES,FILE_CLASSES,OR_OP);	/* Augment class string with class bits from this file */

  CALL = GET_NODENAME();					/* Get node name from current file */
  IF STATUS = NOT_SUCCESSFUL THEN CALL SIGNAL_MON_ERR();	/* Signal error if failure */

  /*
  /* 	Set up Column Summary Block (CSB)
  /*/

  IF ^ M->MRB$V_BY_NODE | NON_EMPTY_FILES = 1			/* If not by-node request, or first input file */
    THEN CALL CREATE_NEW_CSB();					/*   then create a new CSB for a new column */
    ELSE DO;							/*   else go look for a column with same node */
								/*        name as input file */
	 FOUND_NODE = NO;					/* Indicate haven't found a matching node yet */
	 DO J = 1 TO MFS$B_COLUMNS WHILE (FOUND_NODE = NO);	/* Loop once per CSB until found one */
	   CSBPTR = CSB_POINTER(J);				/* Get next CSB pointer */
	   IF CURR_NODENAME = CSB$T_NODENAME			/* If CSB node same as input file node, */
	       THEN DO;
		    IFB$B_COL_NO = J;				/* Stash column no. in IFB for later use */
		    FOUND_NODE = YES;				/* Indicate found a matching node */
		    END;
	 END;
	 IF FOUND_NODE = NO					/* If no matching node found in all CSBs, */
	     THEN CALL CREATE_NEW_CSB();			/*   then create a new one */
	 END;
  END;								/* End of successful do-group */

/*
/*	Perform cleanup operations on this input file (close it and free buffer).
/*/

IF M->MRB$V_INP_CL_REQ						/* If cleanup required for this file, */
    THEN CALL = INPUT_CLEANUP();				/* ... then do cleanup for it */

END;

IF NON_EMPTY_FILES = 0						/* If all files are empty, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOINPFILES);				/*   then log the error */
	 CALL SIGNAL_MON_ERR();					/*   ... and signal it */
	 END;

/*
/*	Eliminate unnecessary classes and set up Current Class Descriptor Array
/*/

IF CTRLCZ_HIT = NO						/* If request is still running, */
    THEN DO;
	 MFS$O_CLASSBITS = BOOL(ALL_FILE_CLASSES,MFS$O_CLASSBITS,AND_OP); /* Eliminate requested classes not in input files */
	 IF MFS$O_CLASSBITS = '0'B				/* If no classes left to do, */
	     THEN DO;
		  CALL MON_ERR(MNR$_NOCLASS);			/*   then log error */
		  CALL SIGNAL_MON_ERR();			/* ... and signal it */
		  END;


	 /* NOTE ***** steal code to print warning message if one or more classes missing from the host of input files */

	 /*
	 /*	Establish Current Class Descriptor Array
	 /*/

	 CALL = ESTAB_CCD();						/* Set up CCD */
	 IF STATUS = NOT_SUCCESSFUL THEN CALL SIGNAL_MON_ERR();		/* Signal error if failure */

	 END;


/*
/*	Main processing loop. For each input file, call EXECUTE_REQUEST
/*	to perform the MONITOR request for that file. After each request
/*	has terminated, the SUM buffer for each class will have been stored
/*	in the multi-file summary buffer.
/*	Then, when all input files have been processed, execute MF_SUMMARY_EVENT
/*	to transform the multi-file summary buffer into the summary report.
/*/

/*
/*	Temporarily de-establish CTRL/C and CTRL/Z handlers, since they will be
/*	established during each call to EXECUTE_REQUEST.
/*/

IF CTRLCZ_HIT = NO & CTRLCZ_CHAN ^= 0				/* If request is still running, */
    THEN DO;
	 CALL = SYS$CANCEL(CTRLCZ_CHAN);			/* Cancel CTRL-C and CTRL-Z handlers */
	 CTRLCZ_CHAN = 0;					/* ... and indicate their disestablishment */
	 END;

DO I = 1 TO M->MRB$B_INP_FILES  WHILE(CTRLCZ_HIT = NO);		/* Loop once for each input file */
								/* ... as long as user has not killed request */
IFBPTR = ADDR(AN_IFB(I));					/* Get next IFB pointer */
IF IFB$B_COL_NO ^= 0						/* If this is a non-empty file, */
    THEN DO;
	 MFS$B_CUR_COL = IFB$B_COL_NO;					/* Set up current column no. for use by EXECUTE_REQUEST */
	 M->MRB$A_INPUT = IFB$A_INPUT;					/* Set up MRB to refer to current input file */
	 M->MRB$Q_BEGINNING = MFS$Q_BEGINNING;				/* Set up requested beginning time */
	 M->MRB$Q_ENDING = MFS$Q_ENDING;				/* Set up requested ending time */
	 M->MRB$O_CLASSBITS = MFS$O_CLASSBITS;				/* Start off each file with requested classes */

	 CALL = EXECUTE_REQUEST();					/* Execute MONITOR request for this input file */
	 IF STATUS = NOT_SUCCESSFUL					/* If request failed, */
	 THEN CALL LINK_MON_ERR(MNR$_IGNFIL,IFB$A_INPUT);		/* Let user know we ignored a file */

	 ELSE DO;							/* Request successful ... check begin and end times */
	      CSBPTR = CSB_POINTER(IFB$B_COL_NO);			/* Get CSB pointer for current column */
	      CSB$B_FILES = CSB$B_FILES + 1;				/* Count this file in this column */
	      IF ^ M->MRB$V_BY_NODE | QUAD_LT_QUAD(M->MRB$Q_BEGINNING,CSB$Q_BEGINNING) /* If new beginning established, */
		THEN CSB$Q_BEGINNING = M->MRB$Q_BEGINNING ;			       /* ... store it into CSB */
	      IF ^ M->MRB$V_BY_NODE | QUAD_LT_QUAD(CSB$Q_ENDING,M->MRB$Q_ENDING) /* If new ending established, */
		THEN CSB$Q_ENDING = M->MRB$Q_ENDING ;			    	 /* ... store it into CSB */
	      END;
	 END;
END;

IF CTRLCZ_HIT = NO						/* If user hasn't hit CTRL/C or /Z, */
    THEN CALL = ESTAB_CTRLCZ();					/*   then re-establish CTRL-C and CTRL-Z handlers */
								/* If error, do not terminate; simply ignore CTRL-C's & CTRL-Z's */
/*
/*	Summarize all accumulated data into a single report.
/*/

IF CTRLCZ_HIT = NO						/* If user is still patient, */
    THEN DO;
	 CALL = MF_SUMMARY_EVENT();				/* Output entire summary buffer for all classes */
	 IF STATUS = NOT_SUCCESSFUL THEN CALL SIGNAL_MON_ERR();	/* Signal error if failure */
	 END;

/*
/*	Perform cleanup operations for this M.F. Summary request
/*/

CALL MF_REQ_CLEANUP();						/* Execute various cleanup routines */

/*
/*	Exit from MFSUM_REQUEST routine.
/*	Note -- we get to this point either by falling through
/*	the above code (normal path), or by direct branch from
/*	the condition-handling routine (error path).
/*/

MF_REQ_STATUS = NORMAL;						/* Normal status if we get to this point */

MF_REQ_EXIT:

RETURN(MF_REQ_STATUS);						/* Return to MONMAIN with completion status */


MFSUM_INIT: Procedure Returns(Fixed Binary(31));		/* Initialization for M.F. Summary Request */

Declare
CLASSES	BIT(128),						/* Temporary class bit string */
CLASSES_VEC (0:127) BIT(1) DEFINED(CLASSES);			/* Bit-addressable alias */

CTRLCZ_HIT = NO;						/* Indicate CTRL-C and CTRL-Z not hit */
CTRLCZ_CHAN = 0;						/* ... and no channel assigned for them */

CSBVEC_PTR = ADDR(CSBVEC);					/* Stash address of CSB Vector for later use */

ALLOCATE MFS;							/* Allocate space for Multi-File Summary block */

MFS$B_COLUMNS = 0;						/* Start out request with no columns */

ALL_FILE_CLASSES = '0'B;					/* Start out request with no input file classes */

/*
/*	Save requested BEGINNING and ENDING times in the MFS so they
/*	can later be re-loaded to the MRB as EXECUTE_REQUEST is called
/*	for each input file.
/*/

MFS$Q_BEGINNING = M->MRB$Q_BEGINNING;				/* Save beginning time */
MFS$Q_ENDING = M->MRB$Q_ENDING;					/* Save ending time */

MFS$A_IFB_TAB = M->MRB$A_INPUT;					/* Save pointer to IFB Table for later use */
IFB_TAB_PTR = MFS$A_IFB_TAB;					/* Set up IFB Table */

/*
/*	Obtain space for statistics buffers
/*/

ALLOCATE BUFFERS;						/* Get the space and set up MFS$A_STATSBUF */
MFS$L_STATSBUF = 4 * 3 * MAXELTS_MFS;				/* Compute and save its length (in bytes) */

/*
/*	Turn off class bits for classes not eligible for
/*	multi-file summary.
/*/

CLASSES = M->MRB$O_CLASSBITS;					/* Get list of requested classes */
CLASSES_VEC(PROCS_CLSNO) = NO;					/* Turn off PROCESSES class bit */

MFS$O_CLASSBITS = CLASSES;					/* Move updated class bit string to the MFS */

IF MFS$O_CLASSBITS = '0'B					/* If no classes left to do, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOCLASSES);				/*   then log error */
	 RETURN(MNR$_NOCLASSES);				/*   ... and return with status */
	 END;

/*
/*	Check for /SUMMARY qualifier specified, and return
/*	error if not. Move summary file spec ptr from MRB to
/*	MFS, and explicitly clear the /SUMMARY, /DISPLAY
/*	and /RECORD file spec ptrs from the MRB.
/*/

IF M->MRB$A_SUMMARY = NULL()					/* If no summary qualifier, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOSUMM);				/*   then log the error */
	 RETURN(MNR$_NOSUMM);					/*   ... and return with status */
	 END;
    ELSE DO;
	 MFS$A_SUMMARY = M->MRB$A_SUMMARY;			/* Move /SUMMARY file spec ptr to MFS */
	 M->MRB$A_SUMMARY = NULL();				/* Indicate no regular /SUMMARY */
	 M->MRB$A_DISPLAY = NULL();				/* Indicate no /DISPLAY */
	 M->MRB$A_RECORD = NULL();				/* Indicate no /RECORD */
	 END;

RETURN(NORMAL);							/* Return */
END MFSUM_INIT;

CREATE_NEW_CSB: Procedure;					/* Create a new Column Summary Block */

MFS$B_COLUMNS = MFS$B_COLUMNS + 1;				/* Count a new column */
IFB$B_COL_NO = MFS$B_COLUMNS;					/* ... and store its number in current IFB */

ALLOCATE CSB;							/* Get space for CSB */
CSB_POINTER(MFS$B_COLUMNS) = CSBPTR;				/* Add its pointer to CSB vector */
CSB$T_NODENAME = CURR_NODENAME;					/* Get nodename from current file */
CSB$Q_BEGINNING = 'FFFFFFFFFFFFFFFF'B4;				/* Init to latest beginning time */
CSB$Q_ENDING = '0'B;						/* ... and earliest ending time */
CSB$B_FILES = 0;						/* Init no. of files in this column */
CSB$V_IGNORE = NO;						/* Don't ignore this column */

RETURN;								/* Return */
END CREATE_NEW_CSB;

GET_NODENAME: Procedure Returns(Fixed Binary(31));		/* Get nodename from current input file */

Declare
READ_INPUT	ENTRY (FIXED BINARY(31)),			/* MONITOR routine to read an input (playback) file record */
NEXT_REC	FIXED BINARY(31) GLOBALREF VALUE;		/* Read next record indicator for READ_INPUT rtn */

Declare
SYI_TYPE	FIXED BINARY(15) GLOBALREF,			/* Type for MONITOR recording file sys info record */
TEMP_TYPE	BIT(8) ALIGNED,					/* Temporary area for record type byte */
SYIPTR		POINTER;					/* Pointer to sys info record */

CALL READ_INPUT(NEXT_REC);					/* Read system information record */
IF MC->MCA$V_EOF						/* If end-of-file, */
    THEN DO;
	 CALL MON_ERR(MNR$_PREMEOF);				/* Can't find sys info record; log the error */
	 RETURN (MNR$_PREMEOF);					/* ... and return to caller */
	 END;

SYIPTR = MC->MCA$A_INPUT_PTR;					/* Establish ptr to sys info record */
TEMP_TYPE = UNSPEC(SYI_TYPE);					/* Get sys info type into a byte for compare */
IF SYIPTR->MNR_SYI$B_TYPE ^= TEMP_TYPE				/* If this record is not the sys info rec, */
    THEN DO;
	 CALL MON_ERR(MNR$_INVINPFIL);				/* Log an error */
	 RETURN(MNR$_INVINPFIL);				/* ... and return to caller */
	 END;

IF MNR_SYI$K_NODENAME < MC->MCA$L_INPUT_LEN			/* If NODENAME field is defined for input file, */
    THEN CURR_NODENAME = SYIPTR->MNR_SYI$T_NODENAME;		/* ... then pick it up from there */
    ELSE UNSPEC(CURR_NODENAME) = '0'B;				/* Otherwise, simply clear it */

RETURN(NORMAL);							/* Return */
END GET_NODENAME;

ESTAB_CCD: Procedure Returns(Fixed Binary(31));			/* Establish Current Class Descriptor array */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
DO_CLASSES	BIT(128),					/* Classes to do */
DO_CLASSES_VEC (0:127) BIT(1) DEFINED(DO_CLASSES),		/* Bit-addressable alias */
CLASS_NO	FIXED BINARY(7);				/* Class number */

/*
/*	Given MFS$O_CLASSBITS, execute do loop using INDEX builtin
/*	to fill in the CCD (Current Class Descriptor) array.
/*/

DO_CLASSES = MFS$O_CLASSBITS;					/* Get list of classes to do */
CLASS_NO = 0;							/* Initialize class number */
DO I = 1 TO MAX_CLASS_NO + 1  WHILE(CLASS_NO >= 0);		/* Loop once for each possible class */
  CLASS_NO = INDEX(DO_CLASSES,YES) - 1;				/* Find next requested class number */
  IF CLASS_NO >= 0						/* Only continue if a class was found */
    THEN DO;
         DO_CLASSES_VEC(CLASS_NO) = NO;				/* Eliminate it from future consideration */
         CURR_CLASS_NO(I) = CLASS_NO;				/* Store class_no in CCD table */
         MFS$W_CLASSCT = I;					/* Keep track of class count */
         CURR_CDBPTR(I) = ADDR(CDBLOCK(CLASS_NO));		/* ... and store it in CCD table */
	 DCDB = CURR_CDBPTR(I);					/* Get CDB address'ty */
	 DCDB->CDB$A_SUMBUF = NULL();				/* Make sure we get a new summary buffer */
	 IF CURR_CDBPTR(I)->CDB$V_DISABLE = YES			/* If this class is disabled, */
	     THEN DO;
		  CALL MON_ERR(MNR$_CLASDISAB);			/* Log the error */
		  RETURN(MNR$_CLASDISAB);			/* ... and return */
		  END;
         END;
END;

RETURN(NORMAL);							/* Normal return */

END ESTAB_CCD;

MF_SUMMARY_EVENT: Procedure Returns(Fixed Binary(31));		/* Multi-File Summary Event */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MF_SUMMARY_EVENT
/*
/*	Called by MFSUM_REQUEST once per request to create a
/*	summary file containing one or more screen images for
/*	each of the requested classes.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CURR_CLASS		FIXED BINARY(15),			/* Consec no (not class no) of current class */
FULL_PAGES		FIXED BINARY(7),			/* Number of full pages to display */
PARTIAL_PAGE_COLS	FIXED BINARY(7),			/* Number of columns on the partial (last) page */
COLS_PER_PAGE		FIXED BINARY(7) INIT(5);		/* Number of columns which fit on a single page */

Declare
LARGE_NO	FIXED BINARY(31) GLOBALREF VALUE,		/* Very large number (integer or floating) */
1 BUFFERS	BASED(MFS$A_STATSBUF),				/* Statistics buffers */
  2 TOT	(1:MAXELTS_MFS)	FIXED BINARY(31),			/* TOTAL statistics buffer */
  2 MIN	(1:MAXELTS_MFS)	FIXED BINARY(31),			/* MINIMUM statistics buffer */
  2 MAX	(1:MAXELTS_MFS)	FIXED BINARY(31);			/* MAXIMUM statistics buffer */

Declare
PUT_LEN		FIXED BINARY(31),				/* Length of buffer for DISPLAY_PUT to put */
1 DPUT_FLAGS,							/* DISPLAY_PUT routine flags */
  2 FAOL_REQUESTED BIT(8) ALIGNED,				/* YES => Xlate buffer with FAOL first */
  2 OUTP_REQUESTED BIT(8) ALIGNED;				/* YES => Really output buffer */

Declare
DISPLAY_PUT	ENTRY(ANY, FIXED BINARY(31), ANY, ANY)		/* MACRO-32 rtn to put a display string */
		OPTIONS(VARIABLE)
		RETURNS(FIXED BINARY(31)),
ADV_HOM_ITEM	ENTRY (POINTER);				/* MACRO-32 rtn to advance homog class to next display item */

Declare
DCDB		POINTER STATIC;					/* CDB for current class */

Declare
SPTR		POINTER GLOBALREF;				/* Pointer to SYI (System Information Area) */


UNSPEC(SPTR->MNR_SYI$T_NODENAME) = '0'B;			/* Clear nodename to avoid misleading node in heading */

/*
/*	Loop through CSBs (Column Summary Blocks), turning on CSB$V_IGNORE
/*	for each one with CSB$Q_ENDING = 0. These are columns which never
/*	accumulated any data. If all columns are ignored, terminate the
/*	MONITOR request. Establish new value for MFS$B_COLUMNS which is
/*	the new column count, excluding ignored columns.
/*/

J = 0;								/* Init count of ignored columns */
DO I = 1 TO MFS$B_COLUMNS;					/* Loop once for each column */
CSBPTR = CSB_POINTER(I);					/* Get CSB pointer for this column */
IF CSB$Q_ENDING = '0'B						/* If no data for this column, */
    THEN DO;
	 CSB$V_IGNORE = YES;					/*   ignore it, */
	 J = J + 1;						/*   ... and count it */
	 END;
END;

MFS$B_COLUMNS = MFS$B_COLUMNS - J;				/* Compute new column count */
IF MFS$B_COLUMNS = 0						/* If no columns, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOINPFILES);				/*   then log the error */
	 RETURN(MNR$_NOINPFILES);				/*   ... and return with status */
	 END;

M->MRB$A_SUMMARY = MFS$A_SUMMARY;				/* Get /SUMMARY file spec ptr to MRB for call */
CALL = SUMMARY_INIT();						/* Do summary file init */
IF STATUS = NOT_SUCCESSFUL					/* Failed? */
    THEN DO;
	 CALL MON_ERR(MNR$_DISPERR,CALL);			/* Yes -- log the error */
	 RETURN(MNR$_DISPERR);					/* ... and return with status */
	 END;

FULL_PAGES = DIVIDE(MFS$B_COLUMNS,COLS_PER_PAGE,7);		/* Compute no. of full report pages of data */
PARTIAL_PAGE_COLS = MFS$B_COLUMNS - (FULL_PAGES * COLS_PER_PAGE); /* ... and number of partially filled pages */


/*
/*	Summarize each class individually.
/*/

DO CURR_CLASS = 1 TO MFS$W_CLASSCT;				/* Loop once for each requested class */

DCDB = CURR_CDBPTR(CURR_CLASS);					/* Get CDB ptr for current class */

IF DCDB->CDB$V_HOMOG						/* If homogeneous class, */
    THEN MFS$L_ELEMS = DCDB->CDB$A_CDX->CDX$L_DCOUNT;		/*  then set this many elements */
    ELSE IF DCDB->CDB$V_SYSCLS					/*  else if SYSTEM class, */
	    THEN DO;
		 MFS$L_ELEMS = ECOUNT_SYS_ALL;			/* 	 then use SYS/ALL element count */
		 DCDB->CDB$B_ST = ALL_STAT;			/*	      and force a tabular display */
		 END;
	    ELSE MFS$L_ELEMS = DCDB->CDB$L_ECOUNT;		/*  this many elements for other heteros */

IF DCDB->CDB$V_HOMOG						/* If homogeneous class, */
    THEN DO;
	 DCDB->CDB$A_CDX->CDX$B_IDISCONSEC = 0;			/* Init consec display item number */
	   DO WHILE(DCDB->CDB$A_CDX->CDX$B_IDISCONSEC < DCDB->CDB$A_CDX->CDX$B_IDISCT);
	   CALL ADV_HOM_ITEM(DCDB);				/* Advance to next display item */
	   CALL = SUMM_ONE_CLASS();				/* Summarize once for each item */
	   IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);	/* Check call */
	   END;
	 END;

    ELSE DO;							/* Heterogeneous class or PROCESSES */
	 CALL = SUMM_ONE_CLASS();				/* Only need to call once */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);		/* Check call */
	 END;

END;

RETURN(NORMAL);							/* Return */

SUMM_ONE_CLASS: Procedure Returns(Fixed Binary(31));		/* Perform m.f. summary output for a single class */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	SUMM_ONE_CLASS
/*
/*	Called by MF_SUMMARY_EVENT to put screen images to the
/*	summary file for a single class.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--

/*/
/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
PAGES		FIXED BINARY(15);				/* No. of full pages to display (loop control) */

Declare
START_COL	FIXED BINARY(7),				/* Starting column number */
COLS_TO_DO	FIXED BINARY(7),				/* Number of columns to display */
END_COL		FIXED BINARY(7),				/* Ending column number */
STAT_IND	BIT(1) ALIGNED;					/* Statistics Indicator -- YES => display statistics */


/*
/*	Initialize statistics (TOT, MIN, and MAX) buffers.
/*/

DO I = 1 TO MFS$L_ELEMS;					/* Loop once per element */
TOT(I) = 0;							/* Clear total to 0 */
MIN(I) = LARGE_NO;						/* Set min to largest number */
MAX(I) = 0;							/* Set max to smallest number */
END;

MFS$B_DATA_COLS = 0;						/* Init no. of columns of data (used by FILL_MFSUM_FAOSTK) */

/*
/*	Put as many full pages of variable information to summary file as
/*	required by this class.
/*/

START_COL = 1;							/* Start with column 1 */

DO PAGES = 1 TO FULL_PAGES;					/* Loop once for each full page */
CALL = PUT_SUMM_PAGE(START_COL,COLS_PER_PAGE,END_COL,NO);	/* Put a single page for this class */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);			/* Check status */
START_COL = END_COL + 1;					/* Establish new starting column for next page */
END;

/*
/*	Now put one or, possibly, two partial pages of variable information
/*	to the summary file for this class.
/*/

IF PARTIAL_PAGE_COLS <= 4					/* If no more than 4 columns on partial page, */
    THEN DO;							/* ... then can fit the statistics on same page */
	 CALL = PUT_SUMM_PAGE(START_COL,PARTIAL_PAGE_COLS,END_COL,YES); /* Put a single page for this class */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

    ELSE DO;							/* ... otherwise, one page for data and one for stats */
	 CALL = PUT_SUMM_PAGE(START_COL,PARTIAL_PAGE_COLS,END_COL,NO); /* Put a single page for this class */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 CALL = PUT_SUMM_PAGE(START_COL,0,END_COL,YES);		/* Put a single page for this class */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;


RETURN(NORMAL);

END SUMM_ONE_CLASS;

PUT_SUMM_PAGE: Procedure (START_COL,COLS_TO_DO,END_COL,STAT_IND)	/* Output a single summary page for curr class */
		Returns(Fixed Binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	PUT_SUMM_PAGE
/*
/*	TBS
/*
/* INPUTS:
/*
/*	START_COL  -- Column number of 1st column to display.
/*
/*	COLS_TO_DO -- Number of columns to display.
/*
/*	STAT_IND   -- Flag indicating whether or not to display statistics.
/*			   ON means "display statistics".
/*			   OFF means "don't display statistics".
/*
/* OUTPUTS:
/*
/*	END_COL	   -- Column number of last column displayed.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
START_COL	FIXED BINARY(7),				/* Starting column number */
COLS_TO_DO	FIXED BINARY(7),				/* Number of columns to display */
END_COL		FIXED BINARY(7),				/* Ending column number */
STAT_IND	BIT(1) ALIGNED;					/* Statistics Indicator -- YES => display statistics */

Declare
DISP_TEMPLATE	ENTRY (POINTER, BIT(1) ALIGNED)			/* Rtn to display the summary template */
		RETURNS (FIXED BINARY(31)),
FILL_MFSUM_FAOSTK ENTRY(POINTER, FIXED BINARY(7), FIXED BINARY(7), BIT(1) ALIGNED)
		RETURNS (FIXED BINARY(31)),			/* MACRO-32 rtn to fill the FAOSTK with data */
DISPLAY_HOMOG	ENTRY (POINTER)					/* MACRO-32 rtn to display homog class data */
		RETURNS (FIXED BINARY(31));

Declare
1 MF_SUMM1_STR	GLOBALREF,					/* M.F. Summary fixed FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
DATA_STR	CHAR(1)	BASED(DCDB->CDB$A_FAOCTR),		/* First char of FAO ctr str for summary data */
FAOSTK		FIXED BINARY(31) GLOBALREF;			/* First longword of FAOL parm list */



/*
/*	Fill FAOSTK with data for this page for this class
/*/

CALL = FILL_MFSUM_FAOSTK(DCDB,START_COL,COLS_TO_DO,STAT_IND);	/* Fill FAOSTK with data */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);			/* Check status */

/*
/*	Put out template, including utility identification, class name,
/*	element labels for hetero classes, etc.
/*/

CALL = DISP_TEMPLATE(DCDB,NO);					/* Send template to SCRPKG, but don't output yet */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);			/* Check call */

/*
/*	Put out column headings, including node name, beginning and
/*	ending times, and statistics headings (TOT, AVE, MIN, MAX) if requested.
/*/

/*
/*	Start with fixed portions of "screen."
/*
/*/

PUT_LEN = MF_SUMM1_STR.L;					/* Length of fixed summary control string */
FAOL_REQUESTED = YES;						/* Run it through FAOL */
OUTP_REQUESTED = NO;						/* ... but don't output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MF_SUMM1_STR.S,); 	/* Send summary line to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);			/* Check status */

/*
/*	Next display node name column headings
/*/

CALL = MFSUM_HEADINGS(START_COL,COLS_TO_DO,END_COL,STAT_IND);	/* Display column headings */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);			/* Check status */

/*
/*	Put a screenful of data to summary file
/*/

IF DCDB->CDB$V_HOMOG						/* Check type of standard class */
    THEN DO;							/* Homogeneous Standard Class */
	 CALL = DISPLAY_HOMOG(DCDB);				/* Send homog data display lines to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;
    ELSE DO;							/* Heterogeneous Standard Class */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = YES;					/* Output it now */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,DCDB->CDB$L_FAOCTR,DATA_STR,FAOSTK);
								/* Send display data to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

RETURN(NORMAL);							/* Return */

END PUT_SUMM_PAGE;

MFSUM_HEADINGS: Procedure (START_COL,COLS_TO_DO,END_COL,STAT_IND) /* Output column headings for curr class and page */
		Returns(Fixed Binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MFSUM_HEADINGS
/*
/*	Send to SCRPKG a column heading for each of the requested columns
/*	for the current output page and class. The heading consists of a
/*	nodename and beginning and ending times.
/*
/* INPUTS:
/*
/*	START_COL  -- Column number of 1st column to display.
/*
/*	COLS_TO_DO -- Number of columns to display.
/*
/*	STAT_IND   -- Flag indicating whether or not to display statistics.
/*			   ON means "display statistics headings".
/*			   OFF means "don't display statistics headings".
/*
/* OUTPUTS:
/*
/*	END_COL	   -- Column number of last column displayed.
/*
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MFS_NOD_SEGLEN	FIXED BINARY(31) GLOBALREF VALUE,		/* Length of a segment of node control string */
MFS_TIM_SEGLEN	FIXED BINARY(31) GLOBALREF VALUE;		/* Length of a segment of time control string */

Declare
START_COL	FIXED BINARY(7),				/* Starting column number */
COLS_TO_DO	FIXED BINARY(7),				/* Number of columns to display */
END_COL		FIXED BINARY(7),				/* Ending column number */
STAT_IND	BIT(1) ALIGNED;					/* Statistics Indicator -- YES => display statistics headings */

Declare
STHEAD_COL	FIXED BINARY(7);				/* Starting column no. for stats heading */

Declare
SCR$SET_CURSOR	ENTRY (ANY VALUE, ANY VALUE);			/* SCRPKG rtn to set the cursor position */

Declare
1 MFS_NODE_PARMS,						/* FAOL parms for nodenames */
 2  MFS_NODE_P (1:COLS_PER_PAGE),
  3 MFS_NODE_PARM POINTER,					/* Node name parameter */
  3 MFS_FIELD_PARM FIXED BINARY(31),				/* "Number of files" field width */
  3 MFS_FILES_PARM FIXED BINARY(31);				/* "Number of files" parameter */


Declare
1 MFS_BEG_PARMS,						/* FAOL parms for beginning times */
  2 MFS_BEG_PARM (1:COLS_PER_PAGE) POINTER;			/* One parm per column */

Declare
1 MFS_END_PARMS,						/* FAOL parms for ending times */
  2 MFS_END_PARM (1:COLS_PER_PAGE) POINTER;			/* One parm per column */

Declare
1 MFS_NODE_STR	GLOBALREF,					/* M.F. Summary nodename FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 MFS_TIME_STR	GLOBALREF,					/* M.F. Summary beg/end time FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 MFS_STHEAD1_STR GLOBALREF,					/* M.F. Summary stats head FAO control string (1st) */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
1 MFS_STHEAD2_STR GLOBALREF,					/* M.F. Summary stats head FAO control string (2nd) */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */


IF COLS_TO_DO ^= 0						/* If there is some work to do, */
    THEN DO;

	 /*
	 /*	Fill parameter lists for nodename and beginning and ending times.
	 /*/

	 J = 0;							/* Clear count of columns actually processed */

	 DO I = START_COL TO MAX_INP_FILES  WHILE(J ^= COLS_TO_DO); /* Keep looking at columns until all processed */
	 END_COL = I;						/* Remember ending column number for caller */
	 CSBPTR = CSB_POINTER(I);				/* Get next CSB (Column Summary Block) ptr */
	 IF CSB$V_IGNORE = NO					/* If it is actually to be processed, */
	     THEN DO;
		  J = J + 1;					/* Count this column */
		  MFS_NODE_PARM(J) = ADDR(CSB$T_NODENAME);	/* Move nodename parm to list */
		  MFS_FILES_PARM(J) = CSB$B_FILES;		/* Move "number of files" parm to list */
		  IF CSB$B_FILES <= 1				/* If 1 or no files, */
		      THEN MFS_FIELD_PARM(J) = 0;		/*   then field width = 0 (no display) */
		      ELSE MFS_FIELD_PARM(J) = 5;		/*   otherwise, field width = 5 */
		  MFS_BEG_PARM(J) = ADDR(CSB$Q_BEGINNING);	/* Move beginning time parm to list */
		  MFS_END_PARM(J) = ADDR(CSB$Q_ENDING);		/* Move ending time parm to list */
		  END;
	 END;

	 /*
	 /*	Put out node names.
	 /*/

	 PUT_LEN = COLS_TO_DO * MFS_NOD_SEGLEN;			/* Compute length of control string */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MFS_NODE_STR.S,MFS_NODE_PARMS); /* Send all nodenames to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 /*
	 /*	Put out beginning times
	 /*/

	 CALL SCR$SET_CURSOR(7,20);				/* Explicitly set cursor */
	 PUT_LEN = COLS_TO_DO * MFS_TIM_SEGLEN;			/* Compute length of control string */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MFS_TIME_STR.S,MFS_BEG_PARMS); /* Send all beg times to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 /*
	 /*	Put out ending times
	 /*/

	 CALL SCR$SET_CURSOR(8,20);				/* Explicitly set cursor */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MFS_TIME_STR.S,MFS_END_PARMS); /* Send all end times to SCRPKG */
								/* Note -- uses most arguments from previous call */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 END;


IF STAT_IND = YES						/* If statistics headings requested, */
    THEN DO;

	 /*
	 /*	Put out statistics column headings for stats (TOT AVE MIN MAX).
	 /*/

	 STHEAD_COL = 20 + (19 * COLS_TO_DO) - 1;		/* Calculate column number */
	 IF COLS_TO_DO = 0					/* If no data columns, */
	     THEN STHEAD_COL = STHEAD_COL + 9;			/*  then move stats columns to the right */
	 CALL SCR$SET_CURSOR(7,STHEAD_COL);			/* Explicitly set cursor */
	 PUT_LEN = MFS_STHEAD1_STR.L;				/* Length of stats head control string */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MFS_STHEAD1_STR.S,); /* Send 1st stats heading line to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 CALL SCR$SET_CURSOR(8,STHEAD_COL);			/* Explicitly set cursor */
	 PUT_LEN = MFS_STHEAD2_STR.L;				/* Length of stats head control string */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,MFS_STHEAD2_STR.S,); /* Send 2nd stats heading line to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

	 END;

RETURN(NORMAL);

END MFSUM_HEADINGS;

END MF_SUMMARY_EVENT;

MF_REQ_CLEANUP: Procedure;					/* M.F. Summary cleanup procedure */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MF_REQ_CLEANUP
/*
/*	Called by MFSUM_REQUEST, either in mainline path, or
/*	from its condition handler, to close files, free
/*	virtual memory and generally release acquired resources.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	None
/*
/*--
/*/

Declare
MFS_FREE_MEM	ENTRY RETURNS(FIXED BINARY(31));		/* MONITOR MACRO-32 routine to issue LIB$FREE_VM's */


IF CTRLCZ_CHAN ^= 0						/* If CTRL/C and CTRL/Z handlers present, */
    THEN DO;
	 CALL = SYS$CANCEL(CTRLCZ_CHAN);			/* Get rid of them */
	 CTRLCZ_CHAN = 0;					/* ... and indicate their disestablishment */
	 END;

IF M->MRB$V_INP_CL_REQ						/* If cleanup required for an input file, */
    THEN CALL = INPUT_CLEANUP();				/* ... then do cleanup for it */

IF M->MRB$V_SUM_CL_REQ						/* If summary cleanup required, */
    THEN DO;
	 M->MRB$A_SUMMARY = MFS$A_SUMMARY;			/* Get /SUMMARY file spec ptr to MRB for call */
	 CALL = SUMMARY_CLEANUP();				/* ... and do it */
	 END;

CALL = MFS_FREE_MEM();						/* Free CDB$A_SUMBUF and CDX$A_SELIDTABLE */
FREE MFS;							/* Free Multi-File Summary Block */

RETURN;

END MF_REQ_CLEANUP;

END MFSUM_REQUEST;
