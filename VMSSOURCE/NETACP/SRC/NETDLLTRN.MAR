	.TITLE	NETDLLTRN  - Routing & Datalink control layer
	.IDENT	'V04-000'
	.DEFAULT DISPLACEMENT,LONG

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;


;++
; FACILITY:	NETWORK ACP
;
; ABSTRACT:
; 
;
; ENVIRONMENT:
;
;	Kernel mode 
;
; AUTHOR:	A.Eldridge, CREATION DATE: 11-APR-80
;
; MODIFIED BY:
;
;	V040	TMH0040		Tim Halvorsen	20-Jul-1984
;		Fix code which accidentally drops an area routing message
;		on a point-to-point circuit when it is received before the
;		circuit can be changed into the "run" state (this is a
;		race condition, and will occur whenever the remote node
;		is faster, and can send routing messages quickly after
;		node initialization; e.g. RSX).  The symptoms are that
;		the remote area is "unreachable" for up to 3 minutes,
;		even though the circuit has initialized.
;
;	V039	TMH0039		Tim Halvorsen	24-May-1984
;		Remove CANCEL on DLM circuits during shutdown (TMH0036)
;		which turned out to act like a DEACCESS, and removed all
;		X.25 level 3 knowledge of the outstanding reset status,
;		putting the circuit into a stuck state.
;		Only issue an PVC ACCESS once in the life of the circuit,
;		meaning that circuit re-initialization due to a remote RESET
;		will just issue a RESET-CONFIRM and transmit a "Start" msg.
;		Just issue a "reset confirm" when we get notification of an
;		incoming reset message - the failed receive IRP will be
;		sufficient mechanism for recycling the circuit.  (This
;		obsoletes ACT_RUN_RESET).
;		When exiting the run state for any reason (like either
;		software error or remote reset), issue a reset message to
;		the remote side to ensure that it recycles thru node init.
;		Minimize the computation of the Square Root Limit result with
;		the maximum allowed value of 127.
;
;	V038	TMH0038		Tim Halvorsen	22-Apr-1984
;		Wait a few seconds after circuit initialization before
;		declaring ourself the designated router.  This is so that
;		we give some time to receive Router Hello messages from
;		remote nodes which might have a higher priority than us.
;		When the decision algorithm can't decide between two paths
;		of equal cost, use the highest node address of the adjacent
;		nodes as the tiebreaker.
;
;	V037	RNG0037		Rod Gamache	 7-Feb-1984
;		Fix problem where if 2 Level II routers where in different areas
;		and there are no other nodes in their respective areas, then
;		the remained "unreachable"! This has to do with the fact that
;		the RTG_CHG flag never got set, so the decision algorithm was
;		never run.
;
;	V036	TMH0036		Tim Halvorsen	15-Sep-1983
;		When a X.25 reset mailbox message is received while doing
;		PVC_START initialization, ignore it, since PVC_START always
;		does a "reset confirm" as the last thing it does.  This
;		prevents a duplicate Reset from being sent, and prevents
;		aborting the remote side's node initialization if it gets
;		it after starting node init.
;
;		When a X.25 reset mailbox message is received during node
;		init, restart the entire node init process, rather than
;		ignoring it, since it is possible that a node init message
;		got lost in the PVC reset.
;
;		Issue CANCEL on DLM circuits during shutdown to clean up
;		outstanding PSI requests, such as outstanding resets.
;
;		Fix code which accidentally drops a routing message on a
;		point-to-point circuit when it is received before the
;		circuit can be changed into the "run" state (this is a
;		race condition, and will occur whenever the remote node
;		is faster, and can send routing messages quickly after
;		node initialization; e.g. RSX).  The symptoms are that
;		the remote node is "unreachable" for up to 3 minutes,
;		even though the circuit has initialized.
;
;	V035	TMH0035		Tim Halvorsen	11-Jul-1983
;		Support alias local addresses (cluster addresses) by
;		zeroing the cost/hops entry for that address in routing
;		messages.
;
;	V034	TMH0034		Tim Halvorsen	06-Jun-1983
;		Detect null passwords from RSX Phase III nodes, which
;		are sent as 8 bytes of 0, rather than a 0 byte string.
;
;	V033	TMH0033		Tim Halvorsen	25-May-1983
;		Fix BC circuit rundown so that it calls DLE$BC_DOWN
;		even though we are an endnode.  Previously, if we were
;		an endnode, it was skipping the call and leaving the
;		channels assigned, preventing further service functions.
;		Use our own node type (in the LPD) to determine what kind
;		of message to send, rather than using the remote node's type
;		and jamming his type to support TRANSPORT TYPE.  This is
;		basically a cleanup of the logic, and should not change
;		the effective algorithm.
;		Fix bug in forced phase resynchronization which caused our
;		side to "act" as the same type as the remote node if we receive
;		his start msg before successfully initiating the transmission
;		of our start msg.
;
;	V032	TMH0032		Tim Halvorsen	17-May-1983
;		Fix bug in version checking in the error path which
;		crashes the system.
;
;	V031	TMH0031		Tim Halvorsen	06-May-1983
;		Fix bug in endnode decision algorithm which prevented
;		endnodes from talking to other endnodes over point-to-point
;		circuits.
;
;	V030	TMH0030		Tim Halvorsen	26-Apr-1983
;		Log "dropped by adjacent node" when we receive an
;		"I'm going away" RHEL from a remote node.
;		Require verification passwords from Phase III nodes
;		during point-to-point node init. to prevent accidental
;		"merging" of area address spaces via an intermediate
;		Phase III node between them.
;
;	V029	RNG0029		Rod Gamache	20-Apr-1983
;		Fix branch destinations out of range.
;
;	V028	TMH0028		Tim Halvorsen	06-Apr-1983
;		Fix code which attempts to ignore Transport data packets
;		when parsing messages from new adjacencies.
;		Allow no more than 20 outstanding transmits (of routing msgs)
;		on an NI circuit, to prevent queue pileup of a stuck datalink,
;		and to prevent too much storage from being tied up in such a
;		condition.
;		Remove some obsolete symbols.
;		If NBRA is exceeded when trying to add a new BRA, then eject
;		the lowest priority BRA (rather than simply ignoring the new
;		BRA).  This way, all BRAs eject the same node from the
;		"cluster" of BRAs.  Log "adjacency rejected" when a BRA is
;		thrown out due to the database being full.
;		Log "address change" reason when a remote adjacency is detected
;		to have recycled, rather than "listener timeout".
;
;	V027	TMH0027		Tim Halvorsen	02-Mar-1983
;		Completely rewrite DLE handling.
;		Fix bug which caused BUFFAIL conditions to leave an LPD
;		in the off-synchronizing state if the last message sent
;		to the ACP for the LPD was ignored.
;		Force the cost/hops to infinity when the area becomes
;		unreachable, to speed up process of an area going away.
;		Set flag in RCB if we are allowed to use level 2 routing
;		or not - set false if we detect ourselves to be an isolated
;		area router.
;		Do not allow transport type other than Phase IV on broadcast
;		circuits.
;		Adapt to Phase III endnodes properly by acting as a Phase
;		III router (rather than a Phase III endnode).
;		Change size of hello timer in Start, RHEL and EHEL messages
;		to be a word rather than a byte, and add temporary code to
;		continue to receive messages in the old format (1 byte hello).
;		Remove code to parse/save seed value from messages.  It is
;		never looked at.
;		Send "I'm going away" message (empty RHEL) when a BC circuit
;		is manually turned off.
;		Fix code which attempts to allow more than one area to coexist
;		on the NI by disallowing level2-level1 connections, by dropping
;		level 1 routing messages from other areas even if we're an area
;		router, and by discounting nodes in other areas while electing
;		a designated router.
;		Rather than sending out RHELs every second if there is at least
;		one 1-way connection, send out RHELs only if it has changed
;		since the last time we sent one.  This prevents RHELs every
;		second in the event that a connection is stuck in 1-way mode.
;		Remove incorrect check which required a remote Phase IV router
;		to have it's block size large enough to hold an entire routing
;		message - this check should only be done for Routing III nodes.
;		Remove obsolete XMT_RESTR mechanism - it assumed that incorrect
;		implementations of Phase III nodes could accept a Phase IV
;		start because it looked like a Phase III start.  This is not
;		the case - Phase IV node numbers make them unacceptable to any
;		Phase III node.
;		Dally for a few seconds before sending the initial start msg.
;		This gives us a chance to hear the remote node's start message,
;		and figure out what he is, before sending him a Phase IV msg
;		he may not like (some implementations can't handle Phase IV
;		messages, even to ignore them).
;		Remove code which "remembers" the remote node's type over a
;		circuit recycle.  This was the old method of phase resynch,
;		but was error prone when patching different systems of
;		different types into the same line.
;
;	V026	TMH0026		Tim Halvorsen	24-Jan-1983
;		Fix bug which prevented forced Phase III circuits to
;		endnodes from correctly detecting the remote node as
;		a Phase III endnode.
;		Allow LPD to be set as a Phase III endnode, so that
;		we can adapt to remote Phase III routers as an endnode.
;		This means changing all endnode checks to check for both
;		Phase III and Phase IV endnode node types.
;		Fix bug in code which tries to prevent sending of routing
;		messages for forced-endnode circuits - wasn't clearing
;		the work flag, and we went into an infinite loop.
;		Init cell in LPD which gives the datalink buffer size
;		and use it throughout, rather than the RCB value.  This
;		is so that datalink buffer sizes can be variable depending
;		on the datalink's route header.
;		Remove any maximum on a circuit's "input packet limiter".
;		Fix bug in computation of "nearest level 2 router" that
;		was causing it to be wiped out on partial decision
;		algorithms.
;		If the MAXIMUM WINDOW parameter is specified, then use it
;		as the input packet limiter for non-X.25 circuits.  This
;		essentially expands the usage of MAXIMUM WINDOW to both
;		X.25 and non-X.25 circuits.
;		Add endnode key support.
;		Prevent transport-type from being set to a router if
;		the executor is set to an endnode.
;		Add code to toggle a DMC line on listener timeouts.
;		Fix forced-phase III circuits to correctly ignore messages
;		with versions higher than phase III, so that node init
;		with higher version nodes works correctly.
;
;	V025	TMH0025		Tim Halvorsen	08-Jan-1983
;		Add Decision Update Vector which gets updated any time
;		a routing message is received which is different than
;		the last one we heard from the same place.  It is used
;		to limit the number of nodes which need to be looked
;		at in the Decision algorithm.
;		Fix loopback check for forced Phase II links to work
;		(it was broken by areas in the local address).
;		Journal new records at the start and finish of the
;		decision algorithm, so routing analysis can be done.
;		Journal all messages written directly to the datalink
;		via QIO from this routine.
;		Remove restriction that prevents a Phase II circuit
;		from initializing if the partner node is already
;		reachable in another part of the network.  This was
;		a restriction needed for the Phase II routing architecture,
;		and is no longer applicable for the current needs of
;		Phase II circuits.
;
;	V024	TMH0024		Tim Halvorsen	17-Dec-1982
;		Re-arrange received message dispatching to locate the
;		CNF, LPD and ADJ blocks before parsing the message.
;		Ignore all messages on NI from another area if we
;		are a level 2 router.
;		Fix circuit re-cycling, so that startup attempts wait
;		for NETDRIVER's IRPCNT in the LPD to go to zero before
;		recycling.  Prevents late breaking CRDs from interrupting
;		the next circuit startup attempt, resulting in TWO line
;		synchronization lost events.
;		Fix calculation of routing update loss for Phase IV
;		route messages, so that it correctly uses the highest
;		reachable node, rather than the highest unreachable
;		node.
;
;	V023	TMH0023		Tim Halvorsen	01-Dec-1982
;		Disable listen timer for Phase II links, since Phase
;		II didn't have any mandatory hello timer.
;		Make RECALL TIMER parameter work for all types of
;		circuits, to give control over Initialization retry
;		attempts.  Increase size of default interval from 3
;		seconds to 10 seconds to cut down on overhead when
;		a datalink goes down, especially if the datalink is
;		going up and down continuously.
;		
;	V022	TMH0022		Tim Halvorsen	13-Oct-1982
;		Select incoming DLM circuits by DTE address,
;		if specified on the incoming circuits.
;		Fix so that a full routing message is sent
;		when a new BRA enters the run state (propagating
;		the database very quickly for the new node).  This
;		is done by the existing BRA, because the new BRA's
;		"request for routing info" (a routing msg) may have
;		been dropped by all routers while waiting for 2-way
;		communication to be established.
;		Add area routing support.
;		Fix bug which prevents values of MAX RECALLS greater
;		than 127 from working (sign bit was being tested).
;		Fix bug in outgoing calls which constructed an illegal
;		PSI NCB if either the WINDOW SIZE or MAXIMUM DATA were
;		specified.
;		Change order of "MOP detected" events, so that line synch.
;		lost comes out before remotely initiated state change.
;		Set the local cost/hops for endnodes to 0, since the
;		decision algorithm is never run (which does it normally).
;		Only reset partner node type every other startup attempt,
;		so that if a startup attempt fails due to wrong version,
;		then the next one will start with the right version.
;		Force the cost/hops to infinity when the node becomes
;		unreachable, to speed up process of node going away.
;
;	V021	TMH0021		Tim Halvorsen	26-Sep-1982
;		Do not allow BLOCKING parameter to be specified,
;		since we don't currently support X.25 blocking.
;		Add endnode support.
;		Fix bug in point-to-point initialization with
;		endnodes.
;
;	V020	TMH0020		Tim Halvorsen	20-Sep-1982
;		Fix "phase resynchronization", so that if we are the
;		higher phase, then process the start message received
;		from the other side (since the lower phase won't ever
;		retransmit it).
;		Allow "late arrival" of start and verification messages
;		to take care of phase resynchronization problems.
;		Fix bug in endnode handling which caused crash when
;		the endnode came up.
;
;	V019	TMH0019		Tim Halvorsen	30-Aug-1982
;		Fix DLE cancel, so that it correctly causes the XWB
;		to be aborted (prevents consistency bugcheck) by using
;		the full path ID, rather than the LPD index in all cases.
;		Fix transport resynchronization, so that the start message
;		is not reset if we receive a higher phase start, but only
;		if we "lower" our start phase (essentially entering
;		compatibility mode).
;		Fix so that Phase II nodes are not included in Phase IV
;		routing messages (and clean up the code a little by removing
;		Phase II "OL vector" and using the adjacency block instead).
;		Allow Phase II node init from a node address greater
;		than 241 (up to the phase III limit of 255) to allow
;		"forced phase II" gateways using "hidden nodes".
;
;	V018	TMH0018		Tim Halvorsen	02-Jul-1982
;		Don't ever modify the LPD$V_ACTIVE flag - that flag
;		is only to be modified by NETDRIVER, since it is used
;		as a flag to decide whether the IRP_DOWN signal needs
;		to be sent to the ACP or not.
;		Fix bug in code which toggles the line off and on when
;		a fatal controller error is detected by the circuit.
;		It was causing circuits to stay in the synchronizing
;		substate, rather than restarting themselves.
;		Change psect name on DLLTRN state table, so that it is
;		mapped after the main body of the ACP code and data.
;		Add support for broadcast circuits (UNA).
;		Change routines which reference local LPD and which scan
;		LPD vector to use new LPD vector, which is a vector of
;		longword pointers to the actual LPD blocks.  Change the
;		code which allocates LPD slots, to actually allocate an
;		LPD structure from non-paged pool, and insert it's address
;		into the LPD pointer vector.
;		Remove the cost/hops matrix, and instead, allocate a cost/
;		hops buffer for each LPD as it gets initialized, and store
;		the address of each cost/hops buffer into a new vector,
;		based on LPD index.
;		Remove DLL_COST vector, and instead, store and retreive
;		the circuit cost from the LPD block.
;		Add code to support adjacencies in conjunction with NETDRIVER.
;		Add check to ensure that NUMBER is specified with OUTGOING DLM
;		X.25 circuits.
;		Add missing code to pass the maximum window and maximum packet
;		size to PSI when making an outgoing DLM call.
;		Change calling interface to PROC_EVT and DLL_PRC_WQE so that
;		R1 doesn't have to be set to the event longword.
;
;	V017	TMH0017		Tim Halvorsen	28-Jun-1982
;		Enable use of X.25 datagrams by NETDRIVER.
;		Store PSI UCB address in LPD for DLM circuits.
;		Do not touch IOST2 field in X.25 IRP, but assume
;		that the datalink has gone down.
;
;	V016	TMH0016		Tim Halvorsen	25-Mar-1982
;		Fix bug in parsing of node address field for Phase II and
;		Phase III messages.
;		Heavily comment this module and add subtitles.
;		Fix psect naming conventions.
;		Remove all explicit displacement specifiers from operands
;		and make default displacement = word for the entire module.
;		Remove X state, which used to wait for a SHUTDOWN to complete,
;		but the W state already does this.
;		Remove transition which causes SHUTDOWN to be re-issued if
;		a new access comes in.
;		Get rid of CND_SHUT (action routine 7), change all references
;		of CND_SHUT to a new redefined action routine 2 (CND_STRT),
;		which issues a startup QIO if ASTCNT is zero.
;		Remove IRP_EVT event, which was used to dispatch to IRP_DOWN
;		or IRP_MM, based on the contents of the IRP.  Now, this
;		dispatching is done upon immediately receiving the IRP.
;		Remove obsolete CNF_CRI event - no longer referenced.
;		Get rid of ACT_RCV_STRTIM (action routine 3), and cleanup
;		the timer events to eliminate needless chaining.
;		Cleanup I/O timer code.
;		Add X.25 datalink support.
;		Remove RCV_UNK event, since it didn't do anything.
;		Log "packet format error" if we get an unrecognized message.
;		Change ACT_ENT_MOP to log the event 5.0 or 5.1 (datalink
;		state change) when we go into MOP mode.
;		Log "aborted service request, line open error" if we are
;		unable to create the detached NML process to handle remotely
;		initiated service functions.
;-

	.SBTTL	Declarations
;
; INCLUDE FILES:
;
	$CCBDEF
	$CNFDEF
	$CXBDEF
	$NFBDEF
	$NMADEF
	$DDTDEF
	$DEVTRNDEF
	$DLLQIODEF
	$EVCDEF
	$IRPDEF
	$LPDDEF
	$ADJDEF
	$MSGDEF
	$NETMSGDEF
	$NETSYMDEF
	$NETUPDDEF
	$NSPMSGDEF		; DNA architecture definitions
	$RCBDEF
	$UCBDEF
	$WQEDEF
 	$XMDEF
	$PSIDEF			; PSI user definitions (for PSI NCB structure)

;
;  EQUATED SYMBOLS
;
FDT_LEGAL  = 0			; FDT offset to legal functions
FDT_IOTYPE = 8			; FDT offset to function type (buffer/direct)

TR$C_TIM_DLLIO	= 3*60		; ACP datalink I/O timeout period (sec)
TR$C_TIM_RESTRT	= 10		; Transport Init retry interval (sec)
TR$C_TIM_DALLY	= 2		; Dally for 2 seconds before sending start
				; msg for resynch with dumb Phase III nodes
TR$C_TIM_DRDELAY = 5		; Wait at least 5 seconds before declaring
				; ourself "designated router" to give us time
				; to hear from other routers on the NI.

;
;  Define Phase IV Transport message symbols
;
TR4C_MSG_RHEL	=  ^B00001011	; Phase IV Router Hello message
TR4C_RHEL_LNG	=	   27	; Length of fixed portion of message
TR4C_MAX_RSLIST	=	  236	; Maximum size of R/S list
TR4V_RS_PRIO	=	    0	; Start of router priority field in R/S LIST
TR4S_RS_PRIO	=	    6	; Length of field
TR4V_RS_TWOWAY	=	    7	; flag set if 2-way communication with router

TR4C_MSG_EHEL	=  ^B00001101	; Phase IV Endnode Hello message
TR4C_EHEL_LNG	=	   32	; Length of fixed portion of message

TR4C_MSG_STR	=  ^B00000001	; Start message type code
TR4C_STR_LNG	=	   12	; Fixed start message length
TR4V_REQ_NTY	=	    0	; Start of TLINFO field specifying node type
TR4S_REQ_NTY	=	    2	; Length of the field
TR4C_NTY_ARO	=	    1	; Field value for area routing nodes
TR4C_NTY_ROU	=	    2	; Field value for routing nodes
TR4C_NTY_NROU	=	    3	; Field value for non-routing nodes
TR4V_REQ_VRF	=	    2	; TIINFO bit - set if verification is requested

TR4C_MSG_VRF	=  ^B00000011	; Verification message type code
TR4C_VRF_LNG	=	    4	; Length of fixed portion of verfication msg
TR4C_VRF_MXL	=	   68	; Verification message max length
TR4C_MAX_PSW	=	   64	; Maximum password text length

TR4C_MSG_ART	=  ^B00001001	; Area routing message type code
TR4C_ART_LNG	=	    6	; Length of fixed portion of routing message

TR4C_MSG_RT	=  ^B00000111	; Routing message type code
TR4C_RT_LNG	=	    6	; Length of fixed portion of routing message
TR4V_RT_COST	=	    0	; Begining of COST field
TR4S_RT_COST	=	   10	; Size of COST field
TR4V_RT_HOPS	=	   10	; Begining of HOPS field
TR4S_RT_HOPS	=	    5	; Size of HOPS field

TR4C_MSG_ENH	=  ^B00000110	; Phase IV endnode data packet - always ignored here

TR4C_TIVER	=    ^X000002	; Phase IV version = 2.0.0
TR4C_T3MULT	=	    2	; Hello/listen factor for non-broadcast circuits
TR4C_BCT3MULT	=	    3	; Hello/listen factor for broadcast circuits

;
;  Define Phase III Transport message symbols
;
TR3C_MSG_STR	=  ^B00000001	; Start message type code
TR3C_STR_LNG	=	   10	; Fixed start message length
TR3C_STR_RSXL	=	    9	;!RSX work around
TR3V_REQ_NTY	=	    0	; Start of TLINFO field specifying node type
TR3S_REQ_NTY	=	    2	; Length of the field
TR3C_NTY_PH3	=	    2	; Field value for routing nodes
TR3C_NTY_PH3N	=	    3	; Field value for non-routing nodes
TR3V_REQ_VRF	=	    2	; TLINFO bit - set if verification is requested

TR3C_MSG_VRF	=  ^B00000011	; Verification message type code
TR3C_VRF_LNG	=	    4	; Length of fixed portion of verfication msg
TR3C_VRF_MXL	=	   68	; Verification message max length
TR3C_MAX_PSW	=	   64	; Maximum password text length

TR3C_MSG_RT	=  ^B00000111	; Routing message type code
TR3C_RT_LNG	=	    5	; Length of fixed portion of routing message
TR3V_RT_COST	=	    0	; Begining of COST field
TR3S_RT_COST	=	   10	; Size of COST field
TR3V_RT_HOPS	=	   10	; Begining of HOPS field
TR3S_RT_HOPS	=	    5	; Size of HOPS field

TR3C_MSG_RTH	=  ^B00000010	; Phase III/IV data packet - always ignored here

TR3C_TIVER	=    ^X000301	; Phase III version = 1.3.0
TR3C_MSG_TST	=  ^B00000101	; Test (hello) message type code
;!TR3C_TST_MAX	=	  128	; Maximum size of test data field
TR3C_TST_MAX	=	  127	;!RSX work-around
TR3C_NUM_TST	=	    3	; Number of test messages to send during 
				; acceptance testing.
;
;  Define Phase II Transport message symbols
;
TR2C_MAX_PNA	=	  255	; Maximum Phase II partner node address

TR2C_MSG_NOP	=  ^B00001000	; NOP message type code
TR2C_NOP_LNG	=	    1	; Mininum NOP message length
TR2C_NUM_NOP	=	    0	; Number of NOP message to send to test the
				; circuit during initialization

TR2C_MSG_INI	=  ^B01011000	; Initialization message type code

TR2C_INI_STR	=  ^B00000001	; Initialization start sub-type code
TR2C_STR_LNG	=	   10	; Length of fixed portion of start message  ;!
TR2C_STR_MXL	=	   80	; Max length of start message		    ;!
TR2C_STR_FCT	=  ^B00000000	; Expected start message "function" field value
TR2C_STR_REQ	=  ^B00000110	; Expected start message "request" field value
TR2V_REQ_VRF	=	    0	; "request" field modifier to request a 
TR2M_REQ_VRF	=       ^X<01>	;   verification message
TR2M_FCT_INT	=	^X<02>	; "function" field modifier to show that the 
				; node does intercept functions

TR2C_INI_VRF	=  ^B00000010	; Initialization verification sub-type code
TR2C_VRF_LNG	=	    2	; Length of verf msg minus password length
TR2C_PSW_LNG	=	    8	; Length of verf msg password
;
;  Define common Routing constants
;
TR_C_VRF_LNG	= TR3C_VRF_MXL	; Maximum verification msg size
TR_C_MAX_PSW	= TR3C_MAX_PSW	; Maximum size of verification password

	.SBTTL	Macros

;
;  MACROS
;
.MACRO	$LOG  code,qual1,qual2,reg		; Setup logging info

			_$log = evc$c_'code'
	.IIF NB,qual1,	_$log = _$log + <<evc$c_'qual1'>@16>
	.IIF NB,qual2,	_$log = _$log + <<evc$c_'qual2'>@24>

	MOVL	#_$log,WQE$W_EVL_CODE(reg)
.ENDM	$LOG


.MACRO	$DSP_TABLE  list			; Setup dispatch table

	.MACRO	$dspent	_$dspinx,_$dspact

		.IIF GT,  <_$dspinx-_$maxinx>,	_$maxinx = _$dspinx
		.	 = _$tmp + <4 * _$dspinx>
		.address   _$dspact
	.ENDM	$dspent

	_$tmp	 = .
	_$maxinx = 0
	.IRP	a,<LIST>
	$dspent	a
	.ENDR

. = _$tmp + <4 * _$maxinx> + 4

.ENDM	$DSP_TABLE


LEV$C_STATES   = 16				; Number of columns in the table
LEV$C_MAX_EVT  = -1 				; Init the number of rows

.MACRO	$LEV  event, s, w,y, m, a,b,c,d,j, r 	; Create state table entries  
						; for the specified circuit event

	LEV$C_MAX_EVT = LEV$C_MAX_EVT + 1	; Bump max event value
	LEV$C_'event' == LEV$C_MAX_EVT		; Define circuit event symbol

		$ENT	s,_s			; Create table entry

		$ENT	w,_w
		$ENT	y,_y

		$ENT	m,_m

		$ENT	a,_a
		$ENT	b,_b
		$ENT	c,_c
		$ENT	d,_d
		$ENT	j,_j

		$ENT	r,_r

		$ENT	?,_s			; Pad so that each row in the
		$ENT	?,_s			; table is a multiple of 16
		$ENT	?,_s			; so that the state table
		$ENT	?,_s			; journal file is easy to read
		$ENT	?,_s
		$ENT	?,_s
.ENDM	$LEV



.MACRO	$ENT	entry,def_sta			; Create state table entry

		_$ent = %LENGTH(entry)-1
		lev$c_sta_. = lev$c_sta'def_sta'; Define default next state

	.IF IDN,entry,?				; ? => bug 
	    .BYTE  lev$c_sta_.			; Use current state
	    .BYTE  4				; Action is bug-check
	.IFF
	    .BYTE  lev$c_sta_%EXTRACT(0,1,entry); Setup next state
	    .BYTE  %EXTRACT(1,_$ent,entry)	; Setup action routine index

	.ENDC
.ENDM	$ENT

	.SBTTL	Define circuit states
;
;  Circuit LPD States (LPD$B_STI values)
;
$EQULST LEV$C_STA_,,0,1,<-;

	<S> 	-; Stopping: There is an active channel to the device but has
	 	-;	     either been stopped or has been given a command to
		-;	     stop. There may be timer or I/O ast's pending.
		-;
		-;
		-;   DATA LINK LAYER INITIALIZATION OR RESTART
		-;
	<W>	-; Shutting: A shutdown QIO was issued, and completion pending.
		-;	     The device has been given a command to shutdown so
	 	-;	     that it is in a known state prior to being started.
		-;
	<Y> 	-; Starting: A startup QIO was issued, and completion pending.
		-;
		-;
		-;   NORMAL MAINTAINANCE MODE STATE (MOP MODE)
		-;
	<M>	-; Maintenance: In use by another process for service functions
	 	-;
		-;
		-;   TRANSPORT LAYER INITIALIZATION
	 	-;
	<A> 	-; Waiting for:  xmt idle, rcv verf, rcv init
	<B> 	-; Waiting for:  xmt idle, rcv verf
	<C> 	-; Waiting for:  xmt idle
	<D> 	-; Waiting for:  	   rcv verf
		-;
	<J>	-; Undergoing circuit acceptance testing
		-;
		-;
		-;   NORMAL RUNNING STATES
		-;
	<R> 	-; Running:  Available for normal traffic.
>

	.SBTTL	Define circuit transition action routines

	.PSECT	NET_PURE,NOWRT,NOEXE,LONG

LEV_AL_ACTTAB:

    $DSP_TABLE  -
    <-
	< 0, ACT_NOP>		-; Nop action routine
	<32, ACT_EXIT>		-; Exit state table processing
	< 4, ACT_BUG>		-; Bugcheck
	<11, ACT_NYI>		-; Not yet implemented
	< 2, ACT_QIO_STRT>	-; If LPD$B_ASTCNT=0,
				-; Issue startup QIO,  reset i/o timer
	<34, ACT_X25_CALL>	-; Accept incoming X.25 call on circuit
	<42, ACT_X25_RESET>	-; Respond to X.25 reset during initialization
	<17, ACT_PVC_START>	-; Startup PVC in multiple steps
	< 1, ACT_QIO_SHUT>	-; Issue shutdown QIO, reset i/o timer
	< 6, ACT_RUN_SYNC>	-; Synchronization lost in run state
	< 8, ACT_RUN_UXPK>	-; Unexpected packet rcv'd in run state
	<16, ACT_RUN_SHUT>	-; Shut down from RUN state
	<39, ACT_ADJ_DOWN>	-; Mark adjacency down
				-;
	<18, ACT_DLL_UP>	-; The datalink has initialized, begin next
				-; phase (Transport or DLE) of activity
	<10, ACT_ENT_RUN>	-; Enter RUN state
	<22, ACT_ENT_MPR>	-; Circuit entered MOP mode while in RUN state
	< 9, ACT_ENT_MOP>	-; Circuit entered MOP mode
	<26, ACT_ENT_DLE>	-; The circuit has become available for use by
				-; a server process for direct-line access
	<37, ACT_BC_UP>		-; A broadcast circuit has initialized
				-;
	<19, ACT_XMT>		-; Send a message if possible
	<30, ACT_RCV_2STR>	-; Respond to second rcvd "start" msg
	<12, ACT_RCV_STR>	-; Respond to rcvd "start" msg
	<13, ACT_RCV_VRF>	-; Respond to rcvd "verification" msg
	<20, ACT_RCV_RT>	-; Respond to rcvd Routing msg
	<29, ACT_RCV_RTA>	-; Receive Routing msg while acceptance testing
	<35, ACT_RCV_ART>	-; Respond to rcvd area routing msg
	<36, ACT_RCV_ARTA>	-; Receive area routing msg while testing
	<40, ACT_RCV_RHEL>	-; Respond to rcvd "Router Hello" msg
	<41, ACT_RCV_EHEL>	-; Respond to rcvd "Endnode Hello" msg
				-;
	<44, ACT_ELECT>		-; Elect 1st "designated router"
				-;
	<43, ACT_FAILED>	-; Mark a circuit "failed"
	< 5, ACT_RUN_DOWN>	-; Cancel all timers, etc.
	<31, ACT_SET_OPER>	-; Simulate a "set operators state" event
	<15, ACT_EXI_SERV>	-; Exit service state if needed
				-;
	<21, ACT_TST_DL>	-; Run acceptance algorithm
	<23, ACT_REQ_UPDATE>	-; Request routing database update
				-;
	<25, ACT_LOG_NFE>	-; Log event
	<24, ACT_LOG_CDE>	-; Log event & shutdown circuit
	<38, ACT_LOG_ADE>	-; Log event & shutdown adjacency
				-;
	<27, ACT_SYN_FAIL>	-; The circuit failed to synchronize
	<28, ACT_INI_FAIL>	-; I/O failure during transport initialization
   >

	.SBTTL	Define circuit state table

	.SAVE_PSECT
	.PSECT	TABLES_PURE,NOEXE,NOWRT,GBL	; Separate psect for ease
						; of journalling display

LEV$AW_STA_TAB:
;
;                 S   W   Y     M     A   B   C   D   J     R
;       ----------+---+---+-----+-----+---+---+---+---+-----+--
$LEV  NO_EVT	  .5  .32 .32   .19   .19 .19 .19 .32 .21  .19
$LEV  EXIT	  .   .   .     .     .   .   .   .   .     .
$LEV  BUG	  ?   ?   ?     .     ?   ?   ?   ?   ?     ?

$LEV  UNJAM	  .   W1  W1    W1    W1  W1  W1  W1  W1    W6
$LEV  REQ_SHUT	  .1  W1  W1    W1    W1  W1  W1  W1  W1    W1

$LEV  OPR_OFF	  .   S27 S27   S27   S1  S1  S1  S1  S1    W6
$LEV  OPR_ON	  W1  .15 .15   .15   .   .   .   .   .     .23
$LEV  OPR_SRV	  W1  .   .     .     W1  W1  W1  W1  W1    W6

$LEV  RCV_STR	  .   .   .     .     B12 B30 B30 B30 B30   .8
$LEV  RCV_VRF	  .   .   .     .     .   .13 W1  .13 W1    .8
$LEV  RCV_VVF	  .   .   .     .     ?   C19 ?   J21 W1    ? 
$LEV  RCV_RT	  .   .   .     .     .   .   .   .   .29   .20
$LEV  RCV_ART	  .   .   .     .     .   .   .   .   .36   .35
$LEV  RCV_RHEL    .   .   .     .     .   .   .   .   .     .40
$LEV  RCV_EHEL    .   .   .     .     .   .   .   .   .     .41

$LEV  XMT_IDLE	  .   .   .     .     ?   D   J21 .32 R10   .32

$LEV  LIN_UP	  .   .   A18   .     ?   ?   ?   ?   R10   .
$LEV  LIN_DOWN    .   .   W27   W27   W1  W1  W1  W1  W1    W16
$LEV  ADJ_DOWN	  .   .   W27   W27   W1  W1  W1  W1  W1    .39

$LEV  BC_UP	  ?   ?   R37   ?     ?   ?   ?   ?   ?     ?

$LEV  IO_TIMOUT	  .31 .27 W27   .     W27 W28 W28 W28 W28   W6
$LEV  IO_FAIL	  .   Y2  W27   W27   W27 W28 W28 W28 W28   W6
$LEV  IO_SUCC	  .   Y2  A18   .9    .   .   .   ?   .     .

$LEV  X25_CALL	  .   Y34 ?     ?     ?   ?   ?   ?   ?     ?
$LEV  PVC_START	  .   .   .17   ?     ?   ?   ?   ?   ?     ?
$LEV  X25_RESET	  .   Y42 .     .     .42 .42 .42 .42 .42   .42

$LEV  STRT_TIM	  .   Y2  .     .     .   .   .   .   .     .
$LEV  ELECT_TIM   .   .   .     .     .   .   .   .   .     .44

$LEV  FAILED	  ?   S43 S43   ?     ?   ?   ?   ?   ?     ?

$LEV  ENT_DLE	  ?   ?   M26   ?     ?   ?   ?   ?   ?     ?
$LEV  DLE_ACC	  W1  W1  W1    .26   W1  W1  W1  W1  W1    W16

$LEV  IRP_RESET	  .   Y2  W27   W27   W27 W28 W28 W28 W28   W6
$LEV  IRP_DOWN	  .   Y2  W27   W27   W27 W28 W28 W28 W28   W6
$LEV  IRP_MM 	  S9  S9  S9    W27   S9  S9  S9  S9  S9    W22

$LEV  LOG_NFE	  .25 .25 .25   .25   .25 .25 .25 .25 .25   .25
$LEV  LOG_CDE	  .24 .24 .24   .24   .24 .24 .24 .24 .24   .24
$LEV  LOG_ADE	  .38 .38 .38   .38   .38 .38 .38 .38 .38   .38

LEV$C_EVENTS  = LEV$C_MAX_EVT+1

	.RESTORE_PSECT

;
; NOTE:	Action routines which are dispatched to upon the LEV$C_NO_EVT event
;	must not exit with the LEV$C_NO_EVT; if no events are to be chained 
;	to then these routines must exit with LEV$C_EXIT.  Failure to adhere
;	to this rule will result in an infinite loop in the state table.
;
;	If an action routine is never dispatched to upon the LEV$C_NO_EVT
;	event then it must never exit with LEV$C_EXIT; if no events are to
;	be chained to then these routines must exit with LEV$C_NO_EVT.
;	Failure to adhere to this rule could result in failure to deallocate
;	an LPD which is no longer needed.
;

	.SBTTL	Define message mapping table
;
;  Define message mapping table
;
.MACRO	MSGTAB	  parser,min_siz,msg_typ	

	.ADDRESS  parser
	.WORD     min_siz
	.WORD     msg_typ

.ENDM	MSGTAB
;
MSG_MAP_TABLE:

    MSGTAB	RCV_STR2,  TR2C_STR_LNG,  <<TR2C_INI_STR@8>!TR2C_MSG_INI>
    MSGTAB	RCV_VRF2,  TR2C_VRF_LNG,  <<TR2C_INI_VRF@8>!TR2C_MSG_INI>
    MSGTAB	RCV_STR3,  TR3C_STR_RSXL,		    TR3C_MSG_STR
    MSGTAB	RCV_VRF3,  TR3C_VRF_LNG,		    TR3C_MSG_VRF
    MSGTAB	RCV_RT,	   TR3C_RT_LNG, 		    TR3C_MSG_RT
    MSGTAB	RCV_ART,   TR4C_ART_LNG,		    TR4C_MSG_ART
    MSGTAB	RCV_RHEL,  TR4C_RHEL_LNG,		    TR4C_MSG_RHEL
    MSGTAB	RCV_EHEL,  TR4C_EHEL_LNG,		    TR4C_MSG_EHEL
    MSGTAB	0,	   0,		    0


;
;  Setup mapping from CRI states to operator events
;
	ASSUME	NMA$C_STATE_ON  EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	ASSUME	NMA$C_STATE_SER EQ 2

OPR_EVT_MAP:	.BYTE	LEV$C_OPR_ON
		.BYTE	LEV$C_OPR_OFF
		.BYTE	LEV$C_OPR_SRV
		.BYTE	0

;
; Define "destination NI addresses" for broadcast QIOs issued here
;

NET$G_ALL_ROU:
	.LONG	TR$C_NI_ALLROU1		; Multicast = "all routers"
	.WORD	TR$C_NI_ALLROU2

;
; Define a CRC polyonomial table to compute CRC-16 checksums
;

CRC16:	.LONG	^X00000000
	.LONG	^X0000CC01
	.LONG	^X0000D801
	.LONG	^X00001400
	.LONG	^X0000F001
	.LONG	^X00003C00
	.LONG	^X00002800
	.LONG	^X0000E401
	.LONG	^X0000A001
	.LONG	^X00006C00
	.LONG	^X00007800
	.LONG	^X0000B401
	.LONG	^X00005000
	.LONG	^X00009C01
	.LONG	^X00008801
	.LONG	^X00004400

	.SBTTL	Storage definitions

	.PSECT	NET_IMPURE,WRT,NOEXE,LONG
;
;  Define miscellaneous storage
;
NET$GL_INITVER::.LONG	0	; For saving received Init Message version
LEV_Q_CRI:	.QUAD	0	; For saving CRI CNF and CNR
LEV_L_LPD:	.LONG	0	; For saving LPD address
LEV_L_ADJ:	.LONG	0	; For saving ADJ address
LEV_W_PNA:	.LONG	0	; For saving partner's address
LEV_W_BLKSIZE:	.LONG	0	; Partner's receive block size
LEV_B_PRIORITY:	.LONG	0	; Partner's router priority
LEV_W_HELLO:	.LONG	0	; Partner's hello timer
LEV_Q_PSWDESC:	.QUAD	0	; For saving descriptor of rcvd password
MAX_HOPS:	.LONG	0	; Max total hops allowed
MAX_COST:	.LONG	0	; Max total path cost allowed
XMTFLG:		.LONG	0	; For LPD$B_XMTFLG image
PTYPE:		.LONG	0	; Type of partner node (routing, endnode, etc.)
NULL:		.LONG	0	; For dummy node name
RTGFLG:		.WORD	0	; Routing flags
RTG_V_RUS = 0			; Update supression timer is ticking
RTG_V_UPD = 1			; Request was made to run "update"

	.PSECT	NET_PURE,NOWRT,NOEXE,LONG

;
; Maximum value allowed for computed Square Root Limit (SRL).
;
MAX_SRL:	.LONG	127	; Maximum signed byte value

;
; Table to convert partner type codes into a "phase" designation
; (i.e. Phase II, Phase III, etc.) to be used in transport re-synchronization.
;

	.MACRO	PHDEF	PTY,PHASE
	.SAVE_PSECT
	. = PTY_TO_PHASE + PTY
	.BYTE	PHASE
	.RESTORE_PSECT
	.ENDM

PTY_TO_PHASE:
	.BLKB	10			; Allocate table of 10 cells
					; and fill them in with:
	PHDEF	ADJ$C_PTY_PH2,2
	PHDEF	ADJ$C_PTY_PH3,3
	PHDEF	ADJ$C_PTY_PH3N,3
	PHDEF	ADJ$C_PTY_PH4,4
	PHDEF	ADJ$C_PTY_PH4N,4
	PHDEF	ADJ$C_PTY_AREA,4
	

;
; Table to convert partner type codes into a version number to be used in
; message version checking.
;

	.MACRO	VERDEF	PTY,VERS
	.SAVE_PSECT
	. = PTY_TO_VERSION + <2*PTY>
	.WORD	VERS
	.RESTORE_PSECT
	.ENDM

PTY_TO_VERSION:
	.BLKW	10			; Allocate table of 10 cells
					; and fill them in with:
	VERDEF	ADJ$C_PTY_PH2,0
	VERDEF	ADJ$C_PTY_PH3,TR3C_TIVER
	VERDEF	ADJ$C_PTY_PH3N,TR3C_TIVER
	VERDEF	ADJ$C_PTY_PH4,TR4C_TIVER
	VERDEF	ADJ$C_PTY_PH4N,TR4C_TIVER
	VERDEF	ADJ$C_PTY_AREA,TR4C_TIVER
	

	.PSECT	TABLES_IMPURE,NOEXE,WRT,GBL,LONG

NUM_NODES = NET$C_MAX_NODES + 1		; Use zero indexed structures
NUM_CIRCS = NET$C_MAX_LINES + 1
NUM_AREAS = NET$C_MAX_AREAS + 1


REACH_EVT:
	.BLKB	<NUM_NODES+7>/8		; Bit vector used to monitor
					; node reachability changes

RTG_CHG:
	.BLKB	<NUM_NODES+7>/8		; Bit vector used to monitor
RTG_CHG_LEN = .-RTG_CHG			; node routing info changes

	.ALIGN WORD

NET$AW_MIN_C_H::
	.BLKW	NUM_NODES		; Minimum Cost/Hops vector

NET$AW_AREA_C_H::
	.BLKW	NUM_AREAS		; Area Minimum Cost/Hops vector

	.ALIGN LONG

NET$AL_CH_VEC::
	.BLKL	1+NUM_CIRCS+NUM_NODES
					; Vector of addresses of buffers
					; which hold the last levl 1 routing message
					; received from the circuit or BRA.
					; NUM_NODES should be enough space for
					; the maximum broadcast routers.

NET$AL_AREA_CH::
	.BLKL	1+NUM_CIRCS+NUM_NODES
					; Vector of addresses of buffers
					; which hold the last area routing message
					; received from the circuit or BRA.
					; NUM_NODES should be enough space for
					; the maximum broadcast routers.

	.PSECT	NET_CODE,NOWRT,EXE

	.SBTTL	NET$INIT_ROUTING - Initialize routing database
;+
; NET$INIT_ROUTING - Initialize routing database
;
; This routine is called when the ACP is starting up, to initialize
; any routing database that needs it.
;
; Inputs:
;
;	None
;
; Outputs:
;
;	R0 = Status code
;
;	All other registers are destroyed.
;-
NET$INIT_ROUTING::
	;
	;   Initialize the minimum cost/hops vector
	;
	MOVC5	#0,(SP),#-1,#2*NUM_AREAS,NET$AW_AREA_C_H ; Min. area cost/hops
	MOVC5	#0,(SP),#-1,#2*NUM_NODES,NET$AW_MIN_C_H  ; Min. cost/hops vector 
	BSBW	FORCE_FULL_DECISION	; Force full decision algorithm
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

	.SBTTL	NET$DLLUPDLNI - Process modified LNI parameters
;+
; NET$DLLUPDLNI - Process modified LNI parameters
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called from module NETACPTRN whenever the LNI data base has
; been updated.
;
; INPUTS:	None
;
; OUTPUTS:	R0	Status code
;
;
;		R1 is destroyed.
;-
	.SAVE_PSECT
	.PSECT	NET_LOCK_CODE,NOWRT,EXE,GBL

NET$DLLUPDLNI::				; Update datalink control layer
UPDATE_ALL:				; Update all routing databases
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R10,R11>; Save regs
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB pointer
	;
	;   Calculate the maximum datalink queue length.  The formula
	;   dictated by the Transport Archictecture is the number of
	;   buffers divided by the square root of the number of circuits.
	;
	MOVZBL	RCB$B_MAX_SNK(R4),R0	; Setup R0 in case no active circuits
	MOVZBL	RCB$B_ACT_DLL(R4),R1	; Get total number of active circuits
	BEQL	20$			; Done if EQL
	MOVZWL	RCB$W_MAX_PKT(R4),R2	; Get the total number of buffers
	MULL	R2,R2			; Square it
	DIVL	R1,R2			; Divide by the number of circuits
	MOVL	#1,R0			; Establish tentative value
	MOVL	#1,R1			; Square of this value
10$:	CMPL	R1,R2			; Compare square of value to
					; (buffs**2)/circuits
	BGEQU	20$			; If GEQU then we're done
	ADDL	R0,R1			; Begin (n+1)**2 calculation
	INCL	R0			;  n = n+1
	ADDL	R0,R1			; (n+1)**2 = n**2 + 2*n + 1
	BRB	10$
20$:	;
	;   Validate maximum allowed value for SRL (Square Root Limit)
	;
	CMPL	R0,MAX_SRL		; Is value too large?
	BLEQU	25$			; Br if no, okay
	MOVL	MAX_SRL,R0		; Else, set to maximum allowed
25$:	;
	;   Update the maximum output queue lengths
	;
	MOVZBL	RCB$B_MAX_SNK(R4),R1	; Get old max queue length	
	MOVB	R0,RCB$B_MAX_SNK(R4)	; Update it
	SUBL	R1,R0			; Get difference (could be negative)
	MOVZBL	RCB$B_MAX_LPD(R4),R5	; Get number of cells
	BEQL	50$			; If EQL then none
	DSBINT	#NET$C_IPL		; Synch with NETDRIVER
30$:	MOVL	@RCB$L_PTR_LPD(R4)[R5],R6 ; Get LPD address
	BGEQ	40$			; Branch if none in this slot
	TSTL	LPD$L_UCB(R6)		; Any datalink associated with this LPD?
	BEQL	40$			; Branch if not (local LPD)
	BBC	#LPD$V_RUN,-		;
		 LPD$W_STS(R6),40$	; Adjust only if in run state
	ADDB	R0,LPD$B_XMT_SRL(R6)	; Adjust square root limiter (could go
					; negative until some I/O completes!)
40$:	SOBGTR	R5,30$			; Loop for each cell
	ENBINT				; Restore IPL
50$:	;
	;   On all routing circuits, force a routing message to
	;   be sent next time around.
	;
	MOVZBL	RCB$B_MAX_LPD(R4),R5	; Get number of circuits
60$:	MOVL	@RCB$L_PTR_LPD(R4)[R5],R6 ; Get LPD address
	BGEQ	65$			; Branch if slot not valid
	BBC	#LPD$V_RUN,LPD$W_STS(R6),65$ ; Branch if circuit inactive
	MOVL	@RCB$L_PTR_ADJ(R4)[R5],R7 ; Get ADJ address
	BBC	#ADJ$V_RTG,ADJ$B_STS(R7),65$ ; Branch if non-routing partner
	ASSUME	LPD$C_SRM_SIZE EQ 32
	MNEGL	#1,LPD$G_SRM(R6)	; Force rtginfo for all nodes to be sent
	ASSUME	LPD$C_ASRM_SIZE EQ 1	; && fix this
	MNEGL	#1,LPD$G_ASRM(R6)	; Force area rtginfo to all level 2 nodes
65$:	SOBGTR	R5,60$			; Loop through all circuits
	;
	;   Re-run the decision algorithm in 1 second, and send routing
	;   messages to our routing neighbors.
	;
	MOVZWL	#<<WQE$C_QUAL_RTG>@8>!-	; Set timer ID
		NET$C_TID_XRT,R1
	MOVAB	UPDATE_TIMER,R2		; Setup action routine address
	MOVQ	#10*1000*1000,R3	; Timer = 1 second
	BSBW	WQE$RESET_TIM		; Set the timer ticking
90$:	MOVL	#1,R0			; Indicate success
100$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R10,R11>; Restore regs
	RSB

	.RESTORE_PSECT

;
; This timer routine is called to run the decision algorithm.  It
; is done on a timed basis, to avoid sending routing messages in
; the above routine.
;

UPDATE_TIMER:
	BSBW	KILL_WQE		; Deallocate timer WQE
	BSBB	FORCE_FULL_DECISION	; Force full decision algorithm
	BSBW	REQUEST_UPDATE		; Request decision 
	RSB

	.SBTTL	FORCE_FULL_DECISION - Force full decision algorithm
;+
; FORCE_FULL_DECISION - Force decision algorithm to be run on all nodes
;
; This routine is called whenever any routing related parameters have
; changes which might affect cost/hop calculations.
;
; Inputs:
;
;	None
;
; Outputs:
;
;	None
;
;	No registers are destroyed.
;-
FORCE_FULL_DECISION:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC5	#0,(SP),#-1,-		; Store 1's in bitvector
		#RTG_CHG_LEN,RTG_CHG
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	RSB

	.SBTTL	NET$DLL_ALL_OFF - Turn off all circuits
;+
; NET$DLL_ALL_OFF - Turn off all circuits
;
; FUNCTIONAL DESCRIPTION:
;
; Each CRI entry is forced to the OFF state and an operator event is generated.
;
; INPUTS:	None
;
; OUTPUTS:	All registers are destroyed
;
;-
NET$DLL_ALL_OFF::			; Turn off all circuits
	MOVL	NET$GL_PTR_VCB,R4	; Get the RCB address
	MOVZBL	RCB$B_MAX_LPD(R4),R5	; Get number of cells
	BEQL	50$			; If EQL then none
30$:	MOVL	R5,R8			; Get LPD i.d.
	BSBW	NET$GET_LPD_CRI		; Get LPD and CRI blocks
	BLBC	R0,40$			; If LBC then not active
	MOVL	#NMA$C_STATE_OFF,R8	; Setup new state value
	$PUTFLD	cri,l,sta		; Stuff it into the CRI CNF
	MOVZBL	OPR_EVT_MAP(R8),R0	; Get corresponding event
	BSBW	SET_DLL_EVT		; Queue the event - always succeeds
40$:	SOBGTR	R5,30$			; Loop for each cell
50$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

	.SBTTL	NET$DLL_OPR_SET - Process operator generated event
;+
; NET$DLL_OPR_SET - Setup operator generated event
;
; FUNCTIONAL DESCRIPTION:
;
; The CRI has been updated and is about to be inserted in the database.  Since
; the circuit "state" may have changed, schedule an event.
;
; INPUTS:	R11	CRI root block pointer
;		R10	CRI block pointer
;		R9	Scratch
;		R8	Value of <cri,l,sta> (operater state)
;		R7-R0	Scratch
;
; OUTPUTS:	R11,R10	 are preserved
;		R0	Low bit set if successful
;			VMS status code otherwise (R9 = Field ID in error)
;
;		All other registers are destroyed.
;
;-
NET$DLL_OPR_SET::			; Setup operator generated event
	PUSHL	R8			; Save state
	CLRL	LEV_L_LPD		; No LPD allocated yet
	JSB	NET$GET_VEC		; Prepare the line
	BLBC	R0,2$			; If LBC then error
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	CMPB	RCB$B_ETY(R4),#ADJ$C_PTY_PH4N ; If endnode,
	BEQL	1$			; branch
	JSB	NET$GET_RTG		; Get routing info
	BLBC	R0,2$			; Branch if error
1$:	BSBW	NET$LOCATE_LPD		; Locate associated LPD
					; R6 = 0 on return if none
	JSB	NET$GET_VEC3		; Check the line state
	BLBC	R0,2$			; If LBC then error
	CMPB	(SP),#NMA$C_STATE_OFF	; Is the STATE OFF ?
	BNEQ	5$			; If NEQ then no
	TSTL	R6			; Is there an LPD
	BNEQ	3$			; If NEQ yes, generate state table event
	BRW	90$			; Else just return
2$:	BRW	100$			; Exit
3$:	BRW	80$			; Generate state table event
5$:	;
	;   If STATE is ON, then ensure that all required parameters are set
	;
	CMPB	(SP),#NMA$C_STATE_ON	; Is new STATE ON ?
	BNEQ	10$			; If no, then skip checks
	BSBW	CHECK_REQ_PARAMS	; Ensure required parameters are set
	BLBS	R0,10$			; Branch if ok
109$:	BRW	100$			; Exit with error
	;
	;   Allocate an LPD, if one does not already exist for this circuit.
	;
10$:	TSTL	R6			; Is there an LPD ?
	BNEQ	20$			; If NEQ then yes
	BSBW	ALLOC_LPD		; Else allocate one
	BLBC	R0,109$			; If LBC then failed
	MOVL	R6,LEV_L_LPD		; Save new LPD pointer
20$:	;
	;   Validate circuit parameters with the datalink driver in
	;   order to return any simple errors immediately to the user.
	;   All errors after this point will simply leave the circuit
	;   in an "on-synchronizing" state.
	;
	;   This is not done for X.25 datalinks, since they don't have
	;   any concept of parameter validation without starting the circuit.
	;
	BBS	#LPD$V_X25,LPD$W_STS(R6),50$ ; Skip if X.25 datalink
	$CNFFLD	cri,s,chr,R9		; Identify characteristics buffer
	MOVZWL	LPD$W_CHAN(R6),R2	; Get I/O channel
	CLRL	R1			; Clear illegal I/O modifier mask
	BSBW	NET$SET_QIOW		; Get buffer and issue $QIOW
	BLBC	R0,100$			; If LBC then failed
50$:	;
	;   Store cost associated with this circuit
	;
	$GETFLD	cri,l,cos		; Get circuit cost
					; (must be specified at this point)
	MOVB	R8,LPD$B_COST(R6)	; Update circuit's cost
	;
	;   Store our NI router priority for this circuit
	;
	$GETFLD	cri,l,rpr		; Get NI router priority
					; (if not set, default it to zero)
	MOVB	R8,LPD$B_BCPRI(R6)	; Store router priority
	;
	;   Save hello timer in LPD
	;
	$GETFLD cri,l,het		; Get the hello timer
	BLBS	R0,60$			; If LBS then it parameter was found
	MOVL	#13,R8			; Else set the default
	BSBW	CNF$PUT_FIELD		; Store it in the CRI
60$:	MOVW	R8,LPD$W_INT_TLK(R6)	; Setup the talker interval
	;
	;   Store X.25 BLOCKING flag into LPD
	;
	$GETFLD	cri,l,blk		; Get BLOCKING parameter
	BLBC	R0,80$			; If not specified, leave flag=off
;&&	BLBC	R8,80$			; Branch if parameter off
;&&	SETBIT	LPD$V_X25BLK,LPD$W_STS(R6) ; Set flag value into LPD
	MOVZWL	#SS$_BADPARAM,R0	;&& We don't currently support this
	BRB	100$			; Exit with error
	;
	;   Force full decision algorithm to be run on all nodes, in case
	;   the cost has changed for this circuit.
	;
80$:	BSBW	FORCE_FULL_DECISION	; Force full decision algorithm
	;
	;   Generate an event to drive the circuit's state table
	;
	MOVZBL	(SP),R8			; Get new STATE value
	MOVZBL	OPR_EVT_MAP(R8),R0	; Get corresponding event
	BSBW	SET_DLL_EVT		; Queue the event - always succeeds

90$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
100$:	TSTL	(SP)+			; Cleanup stack
	BLBS	R0,110$			; Exit if success
	TSTL	LEV_L_LPD		; Was LPD just allocated ?
	BEQL	110$			; If EQL then no
	PUSHL	R0			; Remember status
	BSBW	DEAL_LPD		; Deallocate the LPD
	POPL	R0			; Restore status
110$:	RSB

	.SBTTL	ALLOC_LPD - Allocate LPD
;+
; ALLOC_LPD	- Allocate and initialize an LPD cell
;
; FUNCTIONAL DESCRIPTION:
;
; A free LPD cell is allocated and initialized.  A channel is assigned to it.
;
;
; INPUTS:	R11	CRI CNR address
;		R10	CRI CNF address
;		R9-R0	Scratch
;
; OUTPUTS:	R11,R10	Unchanged
;		R8	Assigned path i.d.
;		R6	Path's LPD address
;		R0	Low bit set if path was found (or assigned)
;			Low bit clear otherwise (R9 = field ID in error)
;-
ALLOC_LPD:				; Allocate/init an LPD cell
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	CLRL	R6			; Mark no LPD allocated yet
	;
	;   Find a free LPD cell
	;
	MOVZBL	RCB$B_MAX_LPD(R4),R5	; Get max path index
	MOVL	#1,R8			; Start at beginning of vector
110$:	MOVL	@RCB$L_PTR_LPD(R4)[R8],R3 ; Get LPD address for this index
	BGEQ	130$			; Branch if index not in use
	INCL	R8			; Advance to next slot
	SOBGTR	R5,110$			; Loop 
	MOVZWL	#SS$_INSFMEM,R0		; Indicate failure
119$:	BRW	300$			; Take common exit
	;
	;   Allocate an LPD block from non-paged pool
	;
130$:	MOVL	#LPD$C_LENGTH,R1	; Set length of LPD block
	BSBW	NET$ALONPGD_Z		; Allocate LPD block
	BLBC	R0,119$			; Branch if unable to allocate
	MOVL	R2,R6			; Point to new LPD block
	MOVL	R6,@RCB$L_PTR_LPD(R4)[R8] ; Mark the slot in use
	;
	;   Allocate a buffer from ACP process space to hold the last
	;   routing message received over this circuit.
	;
	$DISPATCH RCB$B_ETY(R4),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,135$>,-	; skip the following
		<ADJ$C_PTY_PH3N,135$>>
	BSBW	ALLOC_COSTHOPS		; Allocate cost/hops buffer
	BLBC	R0,119$			; Branch if error detected
135$:	;
	;   Initialize the LPD cell
	;
	ADDW3	#^X<0100>,R3,LPD$W_PTH(R6) ; Set the new path ID
					; (increment sequence number)
	MOVB	#1,LPD$B_XMT_IPL(R6)	; Setup input packet limiter
	MOVB	RCB$B_MAX_SNK(R4),-	;
		LPD$B_XMT_SRL(R6)	; Setup square root limiter
	ASSUME	LPD$Q_REQ_WAIT EQ 0	;
	MOVL	R6,(R6)			; Init the queue header
	MOVL	R6,4(R6)		;
	MOVL	G^EXE$GL_ABSTIM,-	;
		LPD$L_ABS_TIM(R6)	; Time counters were zeroed
	SUBW3	#CXB$C_OVERHEAD,-	; Default datalink buffer size
		RCB$W_TOTBUFSIZ(R4),-	; in case PLVEC doesn't exist
		LPD$W_BUFSIZ(R6)
	;
	;   Determine if this is an X.25 datalink mapping circuit,
	;   and if so, mark it as such.
	;
	$GETFLD	cri,l,typ		; Get TYPE parameter
	BLBC	R0,140$			; Branch if not specified
	CMPL	R8,#NMA$C_CIRTY_X25	; X.25 circuit?
	BNEQ	140$			; Branch if not
	SETBIT	LPD$V_X25,LPD$W_STS(R6)	; Mark the circuit as X.25 datalink
140$:	;
	;   Locate the line entry, by searching the line database
	;   looking for a line with the same VMS initial device name.
	;   In order to handle drivers which clone UCBs on each assign
	;   (and so, we can't assign another channel for the circuit
	;   without getting another UCB), we get the actual device name
	;   used by the line (with the cloned unit number filled in)
	;   and assigning a channel to that UCB for the circuit.
	;
	;   In addition, as long as we are looking for the associated
	;   line, copy the line's datalink buffer size to the LPD for
	;   easier access.  If it isn't found for some reason, the LPD
	;   buffer size has been setup earlier with a default value.
	;
	MOVZWL	#SS$_NOSUCHDEV,R0	; Assume error if bad line name
	$GETFLD	cri,s,vmsnam		; Get device name descriptor
	BLBS	R0,142$			; Br on success
	BRW	300$			; Else, take common exit
142$:	BBS	#LPD$V_X25,LPD$W_STS(R6),149$ ; No line for X25 circuits
	PUSHR	#^M<R10,R11>		; Save CNR/CNF pointers
	MOVL	NET$GL_CNR_PLI,R11	; Point to line database
	CLRL	R10			; Start at beginning
	$SEARCH	eql,pli,s,vmsnam	; Search for line with the same device
	BLBC	R0,145$			; Error if no corresponding line
	$GETFLD	pli,l,bus		; Get datalink buffer size
	BLBC	R0,144$			; Skip if not returned
	MOVW	R8,LPD$W_BUFSIZ(R6)	; Save datalink buffer size
144$:	$GETFLD	pli,s,devnam		; Get actual device name for line
145$:	POPR	#^M<R10,R11>		; Restore registers
	BLBC	R0,155$			; Branch if error detected
149$:	;
	;   Assign a channel to the device.
	;
	MOVQ	R7,-(SP)		; Save name descriptor
	MOVL	SP,R0			; $ASSIGN_S modifies the SP
	$ASSIGN_S  -			; Get a channel to the device
		DEVNAM = (R0),-
		CHAN   = LPD$W_CHAN(R6),-
		MBXNAM = NET$GQ_MBX_NAME  ; For PSI UCBs, get all mbx msgs
					; (For other UCBs, this does nothing)
	CLRQ	(SP)+			; Cleanup the stack
	BLBC	R0,155$			; Br on error
	;
	;   Find associated LINE (PLVEC) with this device UCB and claim it
	;
	MOVZWL	LPD$W_CHAN(R6),R0	; Get channel for call
	JSB	G^IOC$VERIFYCHAN	; Get the CCB, ignore errors --
					; CCB is returned anyway
	MOVL	CCB$L_UCB(R1),R0	; Get the UCB pointer
	MOVL	R0,LPD$L_UCB(R6)	; Setup the UCB pointer
	BBS	#LPD$V_X25,LPD$W_STS(R6),170$ ; X.25 datalink has no PLVEC
	MOVZBL	PLVEC$GB_MAX,R8		; Get max PLVEC index
150$:	CMPL	PLVEC$AL_UCB[R8],R0	; Is this it ?
	BEQL	160$			; If EQL then yes
	SOBGTR	R8,150$			; Else loop (index 0 is not used)
	$DASSGN_S  CHAN = LPD$W_CHAN(R6); Deassign the channel
	MOVZWL	#SS$_NOSUCHDEV,R0	; Indicate error
155$:	BRW	300$			; Take common exit
160$:	INCB	PLVEC$AB_REFC[R8]	; Another PLVEC cell reference
	MOVB	R8,LPD$B_PLVEC(R6)	; Setup PLVEC index
	;
	;   For point-to-point pseudo UNA datalink, always use the same
	;   channel for both line and circuit, so that shared PID/CHAN
	;   matching works in the UNA driver.
	;
	CMPB	PLVEC$AB_DEV[R8],-	; Point-to-point pseudo UNA datalink?
		#DEVTRN$C_DEV_PPUNA
	BNEQ	161$			; If so,
	PUSHL	R0			; Save datalink UCB address
	$DASSGN_S CHAN = LPD$W_CHAN(R6)	; Deassign the channel done above
	POPL	R0			; Restore UCB address for later on
	MOVW	PLVEC$AW_CHAN[R8],-	; Use the line's channel
		LPD$W_CHAN(R6) 		; for the circuit as well
161$:	;
	;   If the associated line is of PROTOCOL NI, then mark the LPD
	;   as a broadcast circuit and set a flag forcing all I/O to be
	;   word aligned.
	;
	CMPB	PLVEC$AB_DEV[R8],#DEVTRN$C_DEV_UNA	; UNA?
	BNEQ	165$			; Branch if not
	SETBIT	#LPD$V_BC,LPD$W_STS(R6)	; Mark as broadcast circuit
	SETBIT	#LPD$V_ALIGNW,LPD$W_STS(R6) ; Always word-align UNA I/O
165$:	;
	;   If the associated line is of PROTOCOL CI, then set a flag
	;   forcing all I/O to be quadword aligned.
	;
	CMPB	PLVEC$AB_DEV[R8],#DEVTRN$C_DEV_CI	; CI?
	BNEQ	166$			; Branch if not
	SETBIT	#LPD$V_ALIGNQ,LPD$W_STS(R6) ; Always quadword-align the CI
166$:	;
	;   Determine whether the datalink driver can support buffered
	;   or direct I/O based on it's FDT table.
	;
170$:	MOVL	UCB$L_DDT(R0),R0	; Get DDT address
	MOVL	DDT$L_FDT(R0),R0	; Get FDT
	BBC	#IO$_READLBLK,-		; If BC then direct I/O function
		FDT_IOTYPE(R0),180$	;
	SETBIT	LPD$V_RBF,LPD$W_STS(R6)	; Mark for buffered receives
180$:	BBC	#IO$_WRITELBLK,-	; If BC then direct I/O function
		FDT_IOTYPE(R0),200$	; 
	SETBIT	LPD$V_XBF,LPD$W_STS(R6)	; Mark for buffered transmissions
200$:	;
	;   If this is a broadcast circuit, then do not allow the circuit
	;   TRANSPORT TYPE to be any value other than Phase IV values.
	;
	BBC	#LPD$V_BC,LPD$W_STS(R6),205$ ; If broadcast circuit,
	$GETFLD	cri,l,xpt		; Get transport type parameter
	BLBC	R0,205$			; Skip if not specified
	BSBW	XPT_TO_PTY		; Translate XPT to node type
	$DISPATCH R8,<-			; Allow only if set to one of:
		<ADJ$C_PTY_PH4,205$>,-	; Phase IV routing
		<ADJ$C_PTY_PH4N,205$>,-	; Phase IV endnode
		<ADJ$C_PTY_AREA,205$>>	; Phase IV area routing
	MOVZWL	#SS$_BADPARAM,R0	; Else, illegal protocol
	BRB	300$			; Exit with error
205$:	;
	;   Allocate an ADJ control block, to maintain adjacency-related
	;   parameters.  The first MAX_LPD slots in the ADJ vector correspond
	;   exactly to the LPD of the same index, so allocation is easy.
	;
	MOVZBL	LPD$B_PTH_INX(R6),R7	; Get LPD index
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R7 ; Get pointer to ADJ block
	PUSHL	R4			; Save registers
	MOVC5	#0,(SP),#0,#ADJ$C_LENGTH,(R7) ; Zero ADJ cell
	POPL	R4			; Restore registers
	MOVW	LPD$W_PTH(R6),ADJ$W_LPD(R7) ; Store associated LPD index in ADJ
	MOVB	#ADJ$C_PTY_UNK,ADJ$B_PTYPE(R7) ; Mark partner type unknown
	SETBIT	ADJ$V_INUSE,ADJ$B_STS(R7)   ; Mark cell in use
	;
	;   For broadcast circuits, initialize the "designated router"
	;   to be the NI itself.  For point-to-point circuits, initialize
	;   the "designated router" to be the remote partner node.
	;
	MOVZBW	LPD$B_PTH_INX(R6),-	; Preset ADJ index of "DRT" to that of
		LPD$W_DRT(R6)		; the circuit itself ("none")
	;
	;   If this is a broadcast circuit, then allocate a buffer to hold
	;   the current state of the "router election".
	;
	$DISPATCH RCB$B_ETY(R4),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,210$>,-	; skip the following
		<ADJ$C_PTY_PH3N,210$>>
	BBC	#LPD$V_BC,LPD$W_STS(R6),210$ ; Skip if non-broadcast circuit
	MOVL	#12+1+TR4C_MAX_RSLIST,R1 ; Set size of buffer needed
	BSBW	NET$ALONPGD_Z		; Allocate buffer from nonpaged pool
	BLBC	R0,300$			; Branch if error detected
	MOVAB	12(R2),LPD$L_RTR_LIST(R6) ; Store address of buffer
210$:	;
	;   Link the new LPD to the CNF block
	;
	MOVZWL	LPD$W_PTH(R6),R8	; Get path i.d.
	MOVW	R8,CNF$W_ID(R10)	; Link CNF to LPD
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
300$:	BLBS	R0,390$			; If error on exit,
	TSTL	R6			; Was an LPD allocated?
	BEQL	390$			; Branch if not
	PUSHR	#^M<R0,R9>		; Save final status
	BSBW	DEAL_LPD		; If so, cleanup LPD
	POPR	#^M<R0,R9>		; Restore final status
390$:	RSB				; Return status in R0

	.SBTTL	ALLOC_COSTHOPS - Allocate a cost/hops buffer
;+
; ALLOC_COSTHOPS - Allocate a cost/hops buffer for an adjacency
;
; This routine is called to allocate a buffer in ACP process space
; to hold the last routing message received from the circuit or
; broadcast router.  This is called when a circuit LPD is created,
; or when we hear from a new broadcast router.  The address of
; the buffer is stored in the NET$AL_CH_VEC pointer vector.
;
; Inputs:
;
;	R8 = ADJ index
;
; Outputs:
;
;	R0 = status code
;
;	R1-R2 is destroyed.
;-
ALLOC_COSTHOPS:
	PUSHR	#^M<R3,R4,R5>		; Save registers
	JSB	NET$GET_RTG2		; Get routing info
	BLBC	R0,90$			; Branch if error
	MOVL	#12+<2*NUM_NODES>,R1	; Set length of block
	BSBW	NET$ALLOCATE		; Allocate the buffer
	BLBC	R0,90$			; Branch if unable to allocate
	ADDL	#12,R2			; Point to first available byte
	SUBL	#12,R1
	MOVL	R2,NET$AL_CH_VEC[R8]	; Store address in vector
	MOVC5	#0,(SP),#-1,R1,(R2)	; Initialize it to max cost/hops
	;
	;   If we are an area router, then allocate one for area
	;   routing messages as well.
	;
	MOVL	NET$GL_PTR_VCB,R1	; Get RCB address
	CMPB	RCB$B_ETY(R1),#ADJ$C_PTY_AREA ; Are we an area router?
	BNEQ	80$			; If not, then exit
	MOVL	#12+<2*NUM_AREAS>,R1	; Set length of block
	BSBW	NET$ALLOCATE		; Allocate the buffer
	BLBC	R0,90$			; Branch if unable to allocate
	ADDL	#12,R2			; Point to first available byte
	SUBL	#12,R1
	MOVL	R2,NET$AL_AREA_CH[R8]	; Store address in vector
	MOVC5	#0,(SP),#-1,R1,(R2)	; Initialize it to max cost/hops
80$:	MOVL	#1,R0			; Success
90$:	POPR	#^M<R3,R4,R5>		; Restore registers
	RSB

	.SBTTL	DEAL_LPD - Deallocate LPD
;++
; COND_DEAL_LPD	- Conditionally deallocate LPD
; DEAL_LPD	- Unconditionally deallocate LPD
;
; The I/O channel is $DEASSGN'd, and the LPD block is deallocated.
; The LPD is unhooked from the CRI CNF.
;
; INPUTS:	R11	CRI CNR pointer
;		R10	CRI CNF pointer
;		R6	LPD pointer
;
; OUPUTS:	R6	Zero
;		R0	LBS if successful
;			LBC otherwise
;
;		R1-R4,R7-R9 are destroyed
;--
COND_DEAL_LPD:				; Conditionally deallocate LPD
	$GETFLD	cri,l,sta		; Get the operater state
	BLBC	R0,10$			; If LBC then assume "off"
	CLRL	R0			; Assume can't deallocate
	CMPB	R8,#NMA$C_STATE_OFF	; Is the state "off"
	BNEQ	20$			; If NEQ then can't deallocate
10$:	TSTB	LPD$B_ASTCNT(R6)	; Has LPD run-down?
	BNEQ	20$			; If NEQ no, return error
	TSTB	LPD$B_IRPCNT(R6)	; Does NETDRIVER still have references?
	BNEQ	20$			; If NEQ, then wait for NETDRIVER
					; to wake us up with CRD event
	BBS	#LPD$V_ACCESS,-		; If accessed for "service" then
		    LPD$W_STS(R6),20$	; cannot deallocate
	BSBB	DEAL_LPD		; Deallocate LPD
20$:	RSB				; Done

DEAL_LPD:				; Deallocate LPD
	MOVZBL	LPD$B_PLVEC(R6),R0	; Get PLVEC index
	BEQL	10$			; If EQL then none
	CLRB	LPD$B_PLVEC(R6)		; Init the PLVEC index
	DECB	PLVEC$AB_REFC[R0]	; No longer referencing it
	CMPW	PLVEC$AW_CHAN[R0],-	; Are the line and circuit channels
		LPD$W_CHAN(R6)		; the same?
	BEQL	15$			; If so, let line-related code deassign it
10$:	$DASSGN_S CHAN = LPD$W_CHAN(R6)	; De-assign channel
15$:	CLRW	CNF$W_ID(R10)		; Unbind LPD from CRI
	MOVZWL	LPD$W_PTH(R6),R4	; Get current path index & seq. no
	MOVZBL	R4,R2			; Get LPD index
	MOVL	NET$AL_CH_VEC[R2],R0	; Get address of routing msg buffer
	BEQL	20$			; Branch if none
	SUBL	#12,R0			; Point to real start of block
	BSBW	NET$DEALLOCATE		; Deallocate routing message buffer
	CLRL	NET$AL_CH_VEC[R2]	; Invalidate pointer
20$:	MOVL	NET$AL_AREA_CH[R2],R0	; Get address of area routing buffer
	BEQL	25$			; Branch if none
	SUBL	#12,R0			; Point to real start of block
	BSBW	NET$DEALLOCATE		; Deallocate routing message buffer
	CLRL	NET$AL_AREA_CH[R2]	; Invalidate pointer
25$:	MOVL	NET$GL_PTR_VCB,R1	; Get RCB address
	MOVL	@RCB$L_PTR_ADJ(R1)[R2],R0 ; Get address of ADJ block
	PUSHR	#^M<R1,R2,R4>		; Save registers
	MOVC5	#0,(SP),#0,#ADJ$C_LENGTH,(R0) ; Zero ADJ - including INUSE bit
	POPR	#^M<R1,R2,R4>		; Restore registers
	MOVL	LPD$L_RTR_LIST(R6),R0	; Get address of RTR_LIST buffer
	BEQL	30$			; Branch if none
	SUBL	#12,R0			; Point to real start of block
	BSBW	NET$DEALLOCATE		; Deallocate the buffer
30$:	MOVL	R6,R0			; Point to LPD structure
	BSBW	NET$DEALLOCATE		; Deallocate LPD block
	CLRL	R6			; Invalidate LPD pointer
	MOVL	R4,@RCB$L_PTR_LPD(R1)[R2] ; Invalidate LPD vector slot
					; and store current index & seq. no
					; instead of a pointer (bit 31 clear)
	MOVL	S^#SS$_NORMAL,R0	; Setup status
	RSB

	.SBTTL	CHECK_REQ_PARAMS - Check that required parameters are set
;+
; CHECK_REQ_PARAMS - Check that required circuit parameters are specified
;
; This routine is called when a circuit is turned on, in order to ensure
; that the proper parameters were specified, depending on the type of
; circuit.  This is done here, so that immediate feedback can be given
; to the requestor.
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;
; Outputs:
;
;	R0 = status code
;-
CHECK_REQ_PARAMS:
	;
	;   COST must be specified for all routing circuits.
	;
	$GETFLD	cri,l,cos		; Get the COST value
	BLBS	R0,10$			; Branch if okay
	BRW	80$			; Else, error
	;
	;   If we are an endnode, do not allow TRANSPORT TYPE
	;   parameter to be set to a router.
	;
10$:	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	$DISPATCH RCB$B_ETY(R4),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,15$>,-
		<ADJ$C_PTY_PH3N,15$>>
	BRB	20$
15$:	$GETFLD	cri,l,xpt		; Get TRANSPORT TYPE
	BLBC	R0,20$			; If specified,
	BSBW	XPT_TO_PTY		; Translate XPT to node type
	$DISPATCH R8,<-			; These are the allowable values
		<ADJ$C_PTY_PH4N,20$>,-
		<ADJ$C_PTY_PH3N,20$>>
	MOVZWL	#SS$_BADPARAM,R0	; Illegal parameter
	BRB	90$
20$:	;
	;   If X.25 circuit, then check additional parameters
	;
	$GETFLD	cri,l,typ		; Get circuit type
	BLBC	R0,50$			; Branch if not set
	CMPL	R8,#NMA$C_CIRTY_X25	; X.25 circuit?
	BNEQ	50$			; Branch if not
	;
	;   For X.25 circuits, USAGE must be specified, and for outgoing
	;   DLM circuits, NUMBER must be specified.
	;
	$GETFLD	cri,l,use		; Get USAGE
	BLBC	R0,80$			; Error if not specified
	CMPL	R8,#NMA$C_CIRUS_OUT	; Outgoing?
	BNEQ	50$			; Branch if not
	$GETFLD	cri,l,num		; Get NUMBER
	BLBC	R0,80$			; Error if not specified
50$:	MOVL	S^#SS$_NORMAL,R0	; Successful
	BRB	90$
80$:	MOVZWL	#SS$_INSFARG,R0		; COST value missing
90$:	RSB

	.SBTTL	NET$DLL_X25_CALL - Process incoming X.25 call
;+
; NET$DLL_X25_CALL - Process incoming X.25 call
;
; Attempt to associate the incoming call with a waiting X.25 DLM circuit
; which is marked "waiting for incoming call".  If a circuit is found,
; queue an event to the circuit.
;
; Inputs:
;
;	R9 = Unit number reported in mailbox message
;	R10/R11 = Descriptor of message data in mailbox message
;		(which is a byte-counted string containing incoming NCB)
;
; Outputs:
;
;	None
;-
NET$DLL_X25_CALL::
	MOVZBL	(R11)+,R10		; Construct descriptor of incoming NCB
	MOVQ	R10,-(SP)		; Save NCB descriptor on stack
	CLRQ	-(SP)			; Preset descriptor of remote DTE
;
;   Locate the remote DTE address in the NCB
;
10$:	CMPW	2(R11),#PSI$C_NCB_REMDTE ; Have we found remote DTE entry?
	BNEQ	15$			; If not, continue looking
	MOVZBL	4(R11),(SP)		; Save descriptor of remote DTE string
	MOVAB	5(R11),4(SP)
15$:	MOVZWL	(R11),R0		; Get length of entry
	ADDL	R0,R11			; Skip to next entry
	SUBL	R0,R10			; Subtract from length of NCB left
	BGTR	10$			; If more left, continue search
;
;   Search for an incoming circuit, waiting for a call,
;   and which matches the remote DTE address, if the
;   incoming circuit was restricted to a given remote DTE.
;
	MOVL	NET$GL_CNR_CRI,R11	; Get address of CRI root
	CLRL	R10			; Start at beginning of list
30$:	MOVL	#NMA$C_CIRUS_INC,R8	; Set value of "incoming"
	$SEARCH	eql,cri,l,use		; Search for USAGE INCOMING circuits
	BLBC	R0,50$			; Reject call if none found
	BSBW	NET$LOCATE_LPD		; Locate LPD associated with circuit
	BLBC	R0,30$			; If none, ignore circuit
	$GETFLD	cri,s,num		; Get specific remote DTE, if specified
	BLBC	R0,35$			; If not specified, allow everybody
	CMPC5	R7,(R8),#0,(SP),@4(SP)	; Does the remote DTE match?
	BNEQ	30$			; If not, skip this circuit
35$:	BBCC	#LPD$V_INCOMING,LPD$W_STS(R6),30$ ; Check if waiting for call
					; and mark it "no longer waiting"
;
; Circuit found - queue event to circuit with WQE containing
; the actual X.25 NCB for the incoming call.
;
	ADDL	#8,SP			; Pop remote DTE descriptor off stack
	MOVQ	(SP)+,R10		; Retreive NCB descriptor
	MOVL	R10,R1			; Set size of extra WQE space
	MOVL	#WQE$C_SUB_ACP,R0	; Set type of WQE
	BSBW	WQE$ALLOCATE		; Allocate a WQE
	MOVB	#LEV$C_X25_CALL,WQE$B_EVT(R2)	; Set event code
	MOVW	LPD$W_PTH(R6),WQE$W_REQIDT(R2)	; Set path ID
	MOVL	R10,WQE$L_PM2(R2)	; Set size of NCB
	PUSHL	R2			; Save WQE address
	MOVC	R10,(R11),WQE$C_LENGTH(R2) ; Copy incoming NCB into WQE
	POPL	R5			; Restore WQE address into R5
	BSBW	NET$DLL_PRC_WQE		; Process event and deallocate WQE
	RSB

;
; No circuit could be found to handle the call.  Issue a QIO to reject it.
;
50$:	ADDL	#8,SP			; Pop remote DTE descriptor off stack
	MOVL	SP,R0			; Make pointer to NCB descriptor
	$QIO_S	CHAN=NET$GW_X25_CHAN,-	; Reject incoming call
		FUNC=#IO$_ACCESS!IO$M_ABORT,-
		P2=R0
	ADDL	#8,SP			; Pop NCB descriptor
	RSB				; and exit

	.SBTTL	NET$DLL_X25_RESET - X.25 reset detected
;+
; NET$DLL_X25_RESET - X.25 circuit was reset by other side
;
; This routine is called when a mailbox message is received from PSI
; indicating that the X.25 circuit has been reset.  Our action is to
; issue a "reset confirmation", allowing the reset operation on the
; other side to complete.  This is primarily needed during datalink
; initialization, when there is no receive IRP available to detect
; reset requests on the circuit.
;
; Inputs:
;
;	R9 = Unit number reported in mailbox message
;	R10/R11 = Descriptor of message data in mailbox message
;		(which is 3 bytes of: diagnostic, cause, reason)
;
; Outputs:
;
;	None
;-
NET$DLL_X25_RESET::
	;
	;   Find the LPD whose channel corresponds to the unit
	;   number in the mailbox message.
	;
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVZBL	RCB$B_MAX_LPD(R4),R5	; Get number of LPDs
	BEQL	30$			; If none, ignore message
10$:	MOVL	@RCB$L_PTR_LPD(R4)[R5],R6 ; Get LPD address
	BGEQ	20$			; Branch if slot not valid
	BBC	#LPD$V_X25,LPD$W_STS(R6),20$ ; Skip if not X.25 circuit
	MOVL	LPD$L_UCB(R6),R0	; Get UCB address
	BEQL	20$			; Skip if no datalink
	CMPW	R9,UCB$W_UNIT(R0)	; Does unit number match?
	BEQL	50$			; Exit loop if it matches
20$:	SOBGTR	R5,10$			; Loop through all LPDs
30$:	RSB				; Ignore mailbox message
	;
	;   We have found the proper X.25 circuit.  Queue an event.
	;
50$:	CLRL	R1			; No extra WQE space needed
	MOVL	#WQE$C_SUB_ACP,R0	; Indicate type of WQE
	BSBW	WQE$ALLOCATE		; Allocate a work queue entry
	MOVL	R2,R5			; Copy WQE address
	MOVB	#LEV$C_X25_RESET,WQE$B_EVT(R5) ; Set event code
	MOVW	LPD$W_PTH(R6),WQE$W_REQIDT(R5) ; Set path ID
	BSBW	NET$DLL_PRC_WQE		; Process event and deallocate WQE
	RSB

	.SBTTL	NET$DLL_RCV - Process message received from driver
;+
; NET$DLL_RCV - Process block received from the Transport layer
;
; FUNCTIONAL DESCRIPTION:
;
; Received messages are passed to the ACP from NETDRIVER by queuing the non-
; paged DYN$C_NET buffer directly to the ACP's AQB.  The WQE header and the
; body of the message are stored within the same buffer.  The message is
; scanned to determine its type, an event code is generated, and the event is 
; dispatched.
;
; When a datalink is initialized, NETDRIVER allocates a single IRP for queuing
; receives to the datalink.  Post processing for this IRP takes place in 
; NETDRIVER which detaches the received buffer and recycles the IRP by queuing
; it again to the same datalink.  However, prior to recycling the IRP, if the
; XM$B_STS_ACTIVE bit in IRP$L_IOST2 is clear then NETDRIVER realizes that the
; device has shutdown and passes the IRP to the ACP instead of the datalink.
; The ACP comes here to process this returned IRP.  The eventual action should
; be to read the entire IRP$L_IOST2 image to detect such things as device
; entering maintenance mode and to log this event.  For now, the IRP is assumed
; to be a signal that the device has shutdown.
;
; On return, the block is eventually deallocated.
;
; INPUTS:	R5	WQE ptr
;
;		All others are scratch.
;
; OUTPUTS:	All registers are clobbered.
;
;-

;
;  The expected messages have the following format:
;
;
; Phase 2 init	    <0101 1000><1K_1><EX2_add><I6_nam><1B_fct><1B_req>-
;			         <2B_blksiz><2B_nspsiz><2B_maxlnk>-
;				 <3b_rtver><3b_comver><I32_sysid>
; Phase 2 verf	    <0101 1000><1K_2><8B_psw>
; 
;			<1B_fct>    ::== <1k_0>		no intercept functions
;					 <1k_7>		intercept functions
;
;			<1B_req>    ::== low bit = 0 => verf requested
;					 low bit = 1 => no verf requested
;					 ignore other requests
;
;			<3B_rtver>  ::== <1K_3><1K_1><1K_0>
;			<3B_comver> ::== <1K_3><1K_1><1K_0>
;
;
; Phase 3 init	    <0000 0001><2B_srcnode><1B_tiinfo><2B_blksiz>-
;			   	       <3b_tiver><I64_seed>
; Phase 3/4 verf    <0000 0011><2B_srcnode><I64_psw>
; Phase 3/4 test    <0000 0101><2B_srcnode><I128_data>
; Phase 3 rout	    <0000 0111><2B_srcnode><rtginfo><checksum>
;
; 			<1B_tiinfo> ::== <0000bvnn>  nn = 00 reserved
;							= 01 reserved
;							= 10 routing
;							= 11 nonrouting
;						      v =  0 no verf requested
;						        =  1 verf requested
;						      b =  0 no DLM blocking
;							=  1 DLM block requested
;
;			<3B_tiver>  ::== <1K_1><1K_3><1K_0>
;			<64I_seed>  ::== <1K_0>
;
; Phase 4 init	    <0000 0001><2B_srcnode><1B_tiinfo><2B_blksiz>-
;			   	       <3b_tiver><2B_hello><I64_seed>
; Phase 4 rout	    <0000 0111><2B_srcnode><1K_0><rtginfo><checksum>
; Phase 4 area rout <0000 1001><2B_srcnode><1K_0><rtginfo><checksum>
;
; 			<1B_tiinfo> ::== <0000bvnn>  nn = 00 reserved
;							= 01 area routing
;							= 10 routing
;							= 11 nonrouting
;						      v =  0 no verf requested
;						        =  1 verf requested
;						      b =  0 no DLM blocking
;							=  1 DLM block requested
;
;			<3B_tiver>  ::== <1K_2><1K_0><1K_0>
;			<64I_seed>  ::== <1K_0>
;
;
NET$DLL_RCV::				; Process received message
	;
	;   Establish the context for the event
	;
	CLRB	XMTFLG			; Clear all xmit flags
	CLRB	PTYPE			; Clear partner node type
	CLRL	LEV_L_LPD		; Clear the LPD pointer
	CLRL	LEV_L_ADJ		; Clear the ADJ pointer
	CLRQ	LEV_Q_CRI		; Clear the CRI CNF,CNR ptrs
	CLRW	LEV_W_PNA		; Clear partner's node address
	CLRW	LEV_W_BLKSIZE		; Clear partner's block size
	CLRB	LEV_B_PRIORITY		; Clear router priority
	CLRW	LEV_W_HELLO		; Clear partner's hello timer
	CLRQ	LEV_Q_PSWDESC		; Clear init password descriptor
	CLRL	NET$GL_INITVER		; Clear recevied INIT message version
	MOVZWL	WQE$L_PM2(R5),R1	; Get offset to message
	ADDL	R5,R1			; Convert to pointer
	MOVL	R1,WQE$L_EVL_PKT(R5)	; Store ptr in case packet header 
					; is logged
	BSBW	FIND_WQE_CTX		; Locate CNF, LPD, ADJ blocks
	BLBC	R0,20$			; If LPD no longer exists, skip event
	MOVL	R6,LEV_L_LPD		; Save the LPD pointer in case
					; DISPATCH fails (for code below)
	MOVL	NET$GL_PTR_VCB,R4	; Get the RCB pointer
	BSBB	DISPATCH		; Dispatch to determine the event
	BLBC	R0,10$			; If cannot determine, skip event
	BSBW	PROC_EVT		; Process the event
10$:	;
	;   If LPD's receiver is suspended waiting for a buffer then pass this
	;   this buffer back to NETDRIVER.  Else, deallocate it.
	;
	PUSHAB	B^30$			; Setup return address
	MOVL	LEV_L_LPD,R6		; Get the LPD
	BEQL	20$			; If EQL then none
	MOVL	LPD$L_RCV_IRP(R6),R0	; Is there a waiting receive IRP?
	BEQL	20$			; If EQL then none
	MOVL	R5,IRP$L_SVAPTE(R0)	; Attach buffer to it
	CLRL	R5			; ...and erase our pointer to it
	MOVL	S^#NETUPD$_REACT_RCV,R0	; Fct code is "reactivate receiver"
	BRW	TELL_NETDRIVER		; Give the buffer back to NETDRIVER
20$:	BSBW	KILL_WQE		; Else, deallocate the buffer
30$:	RSB

	.SBTTL	Received message pre-processing routines
;+
; These routines are called after receiving a message to pre-process (parse)
; the message, and store common results in known cells.  This partially masks
; the difference between various versions which are supported.
;
; Inputs:
;
; 	R11	CNR address
;	R10	CNF address
;	R7	ADJ address
;	R6	LPD address
;	R5	WQE address
;	R4	RCB address
;
; Outputs:
;
;	WQE$B_EVT = Event to be queued to state transition mechanism.
;
;	All input registers must be preserved by the parsing routines.
;-
DISPATCH:
	MOVZBL	WQE$B_EVT(R5),R3	; Get Transport layer event code
	$DISPATCH R3,<-
		<NETMSG$C_IRP,   IRP>,-	; IRP event
		<NETMSG$C_UNK,	 UNK>,-	; Possibly transport control message
		<NETMSG$C_APL,   APL>,-	; Aged packet
		<NETMSG$C_OPL,	 OPL>,-	; Oversized packet loss
		<NETMSG$C_NOL,	 NOL>,-	; Packet for out-of-range node
		<NETMSG$C_NUL,	 NUL>,-	; Packet for unreachable node
		<NETMSG$C_PFE,	 PFE>,-	; Packet with format error
		<NETMSG$C_LSN,	 LSN>,-	; Listener timeout
		<NETMSG$C_CRD,	 CRD>,-	; Circuit run down
		<NETMSG$C_ADJ,	 ADJ>,-	; Adjacency up
	>
	BUG_CHECK  NETNOSTATE,FATAL	; Bug if unknown

;
; The CRD message says that NETDRIVER has just completed it's last reference
; to the LPD, so that it can be deallocated.  This is handled by queueing an
; IRP_DOWN event, which causes the state table to eventually try and deallocate
; the LPD again - which this time, will succeed.
;
; For the last IRP that NETDRIVER converts into a CRD message, the IRPCNT
; in the LPD is not decremented until the message actually is processed by
; NETACP.   This prevents any activity on the LPD until all relevant messages
; have been handled.
;
CRD:	DECB	LPD$B_IRPCNT(R6)	; Indicate receipt of CRD message
					; (allow startup activity to continue)
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,30$			; Branch if journalling not enabled
	MOVB	#^X33,(R1)+		; Journal record type = Returned IRP
	MOVB	LPD$B_PTH_INX(R6),(R1)+	; LPD index
	CLRW	(R1)+			; Indicate no I/O function code
	CLRQ	(R1)+			; Indicate no I/O completion status
	JSB	@(SP)+			; Log the journalling record
30$:	MOVB	#LEV$C_IRP_DOWN,WQE$B_EVT(R5) ; Device has shut down
	MOVL	#1,R0			; Process the event
	RSB				; Enter state transition


;
; IRP - "FATAL DATALINK I/O ERROR"
;
; Inputs:
;
;	WQE$W_REQIDT = LPD index
;
; An IRP was just returned from the datalink layer.  Check to see if it
; applies to the local LPD, because if so, it is a signal that NETDRIVER
; is shutting down.
;
IRP:	CMPB	WQE$W_REQIDT(R5),#LPD$C_LOC_INX ; Local LPD index?
	BNEQ	10$			; Branch if not
	BSBW	NET$LOCLPD_DOWN		; Report NETDRIVER shutting down
	CLRL	R0			; Do not process any event
	RSB
;
; An IRP was just returned for a standard LPD.  This is either due
; to the line going down, or we just entered MOP mode.  Set the appropriate
; event so we can enter the state table.
;
10$:	DECB	LPD$B_ASTCNT(R6)	; Reduce NETACP's claim on the LPD
					; (for it's receive IRP)
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,30$			; Branch if journalling not enabled
	MOVB	#^X33,(R1)+		; Journal record type = Returned IRP
	MOVB	LPD$B_PTH_INX(R6),(R1)+	; LPD index
	MOVW	IRP$W_FUNC(R5),(R1)+	; I/O function code
	MOVQ	IRP$L_IOST1(R5),(R1)+	; I/O completion status
	JSB	@(SP)+			; Log the journalling record
30$:	MOVB	#LEV$C_IRP_RESET,WQE$B_EVT(R5) ; Assume X.25 circuit was reset
	CMPW	IRP$L_IOST1(R5),#SS$_RESET ; Was X.25 circuit reset?
	BEQL	50$			; Branch if yes
	MOVB	#LEV$C_IRP_DOWN,WQE$B_EVT(R5) ; Assume device has shut down
	BBS	#LPD$V_X25,LPD$W_STS(R6),50$  ; Don't check MOP if X.25
	BBC	#XM$V_ERR_MAINT,-	; Br if not MOP mode
		IRP$L_IOST2(R5),50$	;
	MOVB	#LEV$C_IRP_MM,WQE$B_EVT(R5) ; Device entered MOP mode
50$:	MOVL	#1,R0			; Process the event
	RSB				; Enter state transition


;
; ADJ - "ADJACENCY UP"
;
; Inputs:
;
;	WQE$W_REQIDT = LPD index
;	WQE$L_PM2 = Descriptor of message (word of length, word of offset)
;
; For adjacency up message, parse the message received by NETDRIVER,
; and if the message makes sense, then create an adjacency block
; for the new Router or Endnode.  The only messages that are allowed
; are: Start, Router Hello and Endnode Hello.  All other types of
; messages are ignored.
;
ADJ:	BSBW	UNK			; Parse received message
	BLBC	R0,40$			; If cannot parse, then ignore it
	$DISPATCH WQE$B_EVT(R5),TYPE=B,<- ; Based on type of message,
		<LEV$C_RCV_RHEL,10$>,-	; Router Hello message
		<LEV$C_RCV_EHEL,20$>,-	; Endnode Hello message
		<LEV$C_RCV_STR,50$>,-	; Start message - process it
		<LEV$C_LOG_NFE,50$>,-	; If error detected, log event
		<LEV$C_LOG_ADE,50$>,-	;	"
		<LEV$C_LOG_CDE,50$>>	;	"
40$:	BRB	IGNORE_MSG		; Otherwise, ignore the message
50$:	RSB				; Return to queue the event

	;
	;   Router Hello message - process new router adjacency
	;
10$:	BBC	#LPD$V_RUN,-		; Skip if circuit not in RUN state
		LPD$W_STS(R6),IGNORE_MSG
	BSBW	BRA_UP			; Broadcast router is up
					; Reset R7 to point to new ADJ block
	BLBC	R0,IGNORE_MSG		; If cannot allocate, then forget it
	MOVW	R8,WQE$W_ADJ_INX(R5)	; Store new ADJ index
	RSB				; Queue event set by UNK
	;
	;   Endnode Hello message - process new endnode adjacency
	;
20$:	BBC	#LPD$V_RUN,-		; Skip if circuit not in RUN state
		LPD$W_STS(R6),IGNORE_MSG
	BSBW	BEA_UP			; Broadcast endnode is up
					; Reset R7 to point to new ADJ block
	BLBC	R0,IGNORE_MSG		; If cannot allocate, then forget it
	MOVW	R8,WQE$W_ADJ_INX(R5)	; Store new ADJ index
	$LOG	TPL_AUP,,,R5		; Set "adjacency up" event
	BSBW	NET$EVT_INTRAW		; Log the event record
	RSB				; Queue event set by UNK

;
;   This routine is called when we have received a message which
;   is valid when a adjacency is normally up, but which must be
;   ignored when the adjacency is still undergoing initialization.
;

IGNORE_MSG:
	CLRL	R0			; Do not queue any event
	RSB

;
;   Determine the type of message received, dispatch to parse it
;

UNK:	CMPZV	#0,#2,(R1),#TR3C_MSG_RTH ; Phase III/IV Data Packet?
	BEQL	IGNORE_MSG		; If so, drop message on the floor
	MOVAB	MSG_MAP_TABLE,R9	; Setup the message mapping table ptr
	MOVZBL	(R1)+,R3		; Get the message type
	CMPB	R3,#TR2C_MSG_INI 	; Is this a Phase II init message?
	BNEQ	80$			; If not, branch
	TSTB	-(R1)			; Backup
	MOVZWL	(R1)+,R3		; Get the type and subtype
80$:	MOVL	(R9)+,R0		; Get message parser routine address
	BEQL	PFE			; If at end of table, log error
	MOVZWL	(R9)+,R2		; Get minimum msg size
	CMPW	R3,(R9)+		; Is this it ?
	BNEQ	80$			; If not, loop
	SUBW	R2,WQE$L_PM2+2(R5)	; Update bytes left
	BLSS	PFE		   	; If LSS then packet format error
	JSB	(R0)			; Parse the message
	RSB

;
;   NETDRIVER messages which cause a DECnet event record to be written
;   and the adjacency to be shutdown.
;

LSN:					; Adjacncy listener timeout
;
;   If this is a DMC line, then we will toggle the line as well as the
;   circuit to force any modem connections, to hang up. This is done
;   here because the DMC driver cannot figure out on it's own when to
;   hang up the modem.
;
	MOVZBL	LPD$B_PLVEC(R6),R0	; Get PLVEC index
	CMPB	PLVEC$AB_DEV[R0],-	; Is this a DMC11?
		#DEVTRN$C_DEV_DMC	;
	BNEQ	10$			; Br if no
	BISW	#LPD$M_TOGGLE,-		; Else, force a line toggle
		LPD$W_STS(R6)		;
10$:	CLRL	WQE$L_EVL_PKT(R5)	; Indicate no packet for this event
	$LOG	TPL_LDS,TPL_PRSN_LTMO,,R5 ; Store logging info in WQE
	BRB	ADJ_DOWN_EVENT
PFE:					; Packet format error
	BUMP	B,RCB$B_CNT_PFE(R4)	; Increment packet format error count
	$LOG	TPL_PFM,,,R5		; Store logging info in WQE
ADJ_DOWN_EVENT:
	MOVB	#LEV$C_LOG_ADE,WQE$B_EVT(R5) ; Setup to log event
	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

;
;   NETDRIVER messages which simply cause a DECNET event record to be written.
;

OPL:					; Oversized packet loss
	$LOG	TPL_OPL,,,R5		; Store logging info into WQE
	BRB	NON_FATAL		; Take common exit
APL:					; Aged packet loss
	BUMP	B,RCB$B_CNT_APL(R4)	; Increment aged packet loss count
	$LOG	TPL_APL,,,R5		; Store logging info in WQE
	BRB	NON_FATAL		; Take common exit
NUL:					; Node unreachable packet loss
	BUMP	W,RCB$W_CNT_NUL(R4)	; Increment node unreachable loss count
	$LOG	TPL_UPL,,,R5		; Store logging info in WQE
	BRB	NON_FATAL		; Take common exit
NOL:					; Node out-of-range packet loss
	BUMP	B,RCB$B_CNT_NOL(R4)	; Increment node out of range loss count
	$LOG	TPL_RPL,,,R5		; Store logging info in WQE
NON_FATAL:				; Common non-fatal event exit
	MOVB	#LEV$C_LOG_NFE,WQE$B_EVT(R5) ; Setup for "log non-fatal event"
	MOVL	#1,R0			; Process event
	RSB				; Return true - process event


	.SBTTL	RCV_STR2 - Received Phase II start message
;+
; RCV_STR2  - Process received Phase II Transport Initialization Start message
;
; FUNCTIONAL DESCRIPTION:
;
; The message is parsed to determine correctness, node address, and the 
; database is checked to determine whether a verification message needs to be
; sent.
;
; The possible events returned in WQE$B_EVT are:
;
;		LEV$C_RCV_STR	- Rcv Transport Layer "start" msg
;		LEV$C_LOG_FTE	- Fatal event
;
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other regs may be clobbered.
;
;-
RCV_STR2:				; Process rcvd phase II Start msg
	;
	;   Parse the node address.
	;
	BSBW	PARSE_PH2_ADDR		; Parse Phase II node address
	BLBC	R0,50$			; If LBC error, chain to event setup
					; by PARSE_PH2_ADDR
	;
	;   Process the nodename field.  The size is checked but the name text
	;   itself is ignored (this is consistent with not knowing the name of
	;   a Phase III node and allows the rules for Phase II and Phase III
	;   nodes to be the same with respect to whether or not there needs
	;   to be an NDI in the database for that node -- i.e., an NDI is
	;   needed only if "verification" is required for the circuit which
	;   connects to the node).
	;
	MOVZBL	(R1)+,R0		; Get bytes in node name
	SUBW	R0,WQE$L_PM2+2(R5)	; Account for them
	BLSS	100$			; If LSS then msg is too small
	ADDL	R0,R1			; Advance past name
	;
	;   Ignore the FUNCTIONS field
	;
20$:	TSTB	(R1)+			; If LSS then field is extended
	BGEQ	22$			; If GEQ then okay
	DECW	WQE$L_PM2+2(R5)		; Account for next (optional) byte
	BLSS	100$			; If LSS then format error
	BRB	20$			; Loop
22$:	;
	;   Process the REQUESTS field
	;
	BBC	#TR2V_REQ_VRF,(R1),25$	; If LBC verification not required
	SETBIT	LPD$V_XMT_VRF,XMTFLG	; Indicate verification required
25$:	TSTB	(R1)+			; If LSS then field is extended
	BGEQ	27$			; If GEQ then okay
	DECW	WQE$L_PM2+2(R5)		; Account for next (optional) byte
	BLSS	100$			; If LSS then format error
	BRB	25$			; Loop
27$:	;
	;   Get the partner's block size and version
	;
	MOVW	(R1)+,LEV_W_BLKSIZE	; Save partner's block size
	TSTL	(R1)+			; Skip over partner's NSP block size
					; and his MAX LINKS specifier
	MOVB	#ADJ$C_PTY_PH2,PTYPE	; Mark adjacent node as Phase II
	MOVW	(R1)+,NET$GL_INITVER	; Save INIT version (3 bytes)
	MOVB	(R1)+,NET$GL_INITVER+2	
	MOVB	#LEV$C_RCV_STR,WQE$B_EVT(R5) ; Event is 'rcvd start msg'
50$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

100$:	BRW	PFE			; Packet format error

	.SBTTL	RCV_STR3 - Received Phase III start message
;+
; RCV_STR3  - Process received Phase II Transport Initialization Start message
;
; FUNCTIONAL DESCRIPTION:
;
; The message is parsed to determine correctness, node address, and the 
; database is checked to determine whether a verification message needs to be
; sent.
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other regs may be clobbered.
;
;-
RCV_STR3:				; Process rcvd phase III/IV Start msg
	;
	;   Compare version numbers.  If we receive a start from a node
	;   with a higher version number, then drop the message.  The
	;   other node will detect that we are lower version and re-send
	;   the correct start message.  If the version is lower than ours,
	;   but we don't recognize or support it, then log "version skew".
	;
	PUSHL	R1			; Save current pointer
	MOVAB	5(R1),R1		; Point to version field
	BSBW	PARSE_VERSION		; Parse version number field
	POPL	R1			; Restore current pointer
	CMPW	5(R1),#TR3C_TIVER	; Is it Phase III version?
	BEQL	5$			; If so, override error - we can handle it
	BLBC	R0,30$			; If error, chain to new event
	BRB	RCV_STR4		; If no error, then Phase IV
	;
	;   Parse the Phase III start message.
	;
5$:	BSBW	PARSE_PH3_ADDR		; Parse phase III node address field
	BLBC	R0,30$			; Br on error with new event setup by
					; PARSE_PH3_ADDR
	BBC	#TR3V_REQ_VRF,(R1),10$	; Br unless verification is requested
	SETBIT	LPD$V_XMT_VRF,XMTFLG	; Need to send verif. msg
10$:	EXTZV	#TR3V_REQ_NTY,-		; Get node type
		#TR3S_REQ_NTY,(R1)+,R0	;
	MOVB	#ADJ$C_PTY_PH3,PTYPE	; Assume Phase III routing
	CMPB	R0,#TR3C_NTY_PH3	; Is it a routing node?
	BEQL	20$			; If EQL yes, continue
	MOVB	#ADJ$C_PTY_PH3N,PTYPE	; Assume Phase III non-routing
	CMPB	R0,#TR3C_NTY_PH3N	; Is it a non-routing node?
	BEQL	20$			; If EQL yes, continue
	BRW	PFE			; Else report "packet format error"
20$:	MOVW	(R1)+,LEV_W_BLKSIZE	; Store partner's block size
	ADDL	#3,R1			; Skip version field
	MOVB	#LEV$C_RCV_STR,WQE$B_EVT(R5) ; Event is 'rcvd start msg'
30$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

	.SBTTL	RCV_STR4 - Received Phase IV start message
;+
; RCV_STR4  - Process received Phase IV Transport Initialization Start message
;
; FUNCTIONAL DESCRIPTION:
;
; The message is parsed to determine correctness, node address, and the 
; database is checked to determine whether a verification message needs to be
; sent.
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other regs may be clobbered.
;
;-
RCV_STR4:				; Process rcvd phase IV Start msg
	BSBW	PARSE_PH4_ADDR		; Parse phase IV node address field
	BLBC	R0,30$			; Br on error with new event setup by
					; PARSE_PH4_ADDR
	BBC	#TR4V_REQ_VRF,(R1),10$	; Br unless verification is requested
	SETBIT	LPD$V_XMT_VRF,XMTFLG	; Need to send verif. msg
10$:	EXTZV	#TR3V_REQ_NTY,-		; Get node type
		#TR3S_REQ_NTY,(R1)+,R0	;
	MOVB	#ADJ$C_PTY_PH4,PTYPE	; Assume Phase IV routing
	CMPB	R0,#TR4C_NTY_ROU	; Is it a routing node?
	BEQL	20$			; Branch if so
	MOVB	#ADJ$C_PTY_PH4N,PTYPE	; Assume Phase IV non-routing
	CMPB	R0,#TR4C_NTY_NROU	; Is it a non-routing node?
	BEQL	20$			; If EQL yes, continue
	MOVB	#ADJ$C_PTY_AREA,PTYPE	; Assume Phase IV area routing
	CMPB	R0,#TR4C_NTY_ARO	; Is it area-router?
	BEQL	20$			; Branch if so
	BRW	PFE			; Else report "packet format error"
20$:	MOVW	(R1)+,LEV_W_BLKSIZE	; Store partner's block size
	ADDL	#3,R1			; Skip version field
	TSTW	WQE$L_PM2+2(R5)		; && Was msg exactly 10 bytes?
	BNEQ	25$			; && If so,
	CLRB	1(R1)			; && Clear high order byte for those
					; && impl. who onlyused 1 byte hello
25$:	MOVW	(R1)+,LEV_W_HELLO	; Store partner's hello timer
	MOVB	#LEV$C_RCV_STR,WQE$B_EVT(R5) ; Event is 'rcvd start msg'
30$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

	.SBTTL	RCV_VRF - Received routing verification message
;+
; RCV_VRF2 - Process received Transport Phase II Verification message
; RCV_VRF3 - Process received Transport Phase III Verification message
; RCV_VRF4 - Process received Transport Phase IV Verification message
;
; FUNCTIONAL DESCRIPTION:
;
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB pointer
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other registers may be clobbered.
;
;-
	.ENABL	LSB

RCV_VRF2:				; Preprocess rcv'd Phase II Verf msg
	MOVB	#ADJ$C_PTY_PH2,PTYPE	; Mark node is Phase II
	CMPW	S^#TR2C_PSW_LNG,-	; Is the msg size correct?
		WQE$L_PM2+2(R5)		; 
	BEQL	5$			; If EQL yes, save password
	BRW	PFE			; Else report "packet format error"

RCV_VRF3:
RCV_VRF4:
	BSBW	PARSE_PH3_ADDR		; Get partner's address
	BLBC	R0,10$			; If LBC error, exit with event setup
					; by PARSE_PH3_ADDR
	MOVZBL	(R1)+,R0		; Get count of password text
	CMPW	R0,WQE$L_PM2+2(R5)	; Does it match bytes left?
	BNEQ	20$			; If not, illegal message
	CMPB	R0,#TR3C_MAX_PSW	; Is it too large
	BGTRU	20$			; If so, illegal message
	;
	;   Store the password descriptor
	;
5$:	MOVB	#LEV$C_RCV_VRF,WQE$B_EVT(R5)	; Setup event code
	MOVZBL	WQE$L_PM2+2(R5),LEV_Q_PSWDESC	; Save password size
	MOVL	R1,LEV_Q_PSWDESC+4		; Save password pointer
10$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

20$:	BRW	PFE			; Report "packet format error"

	.DSABL	LSB

	.SBTTL	RCV_RHEL - Received Phase IV Router Hello message
;+
; RCV_RHEL  - Process received Phase IV NI Router Hello message
;
; FUNCTIONAL DESCRIPTION:
;
; The message is parsed and validated, and an event is queued indicating
; that the message needs processing.
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other regs may be clobbered.
;-
RCV_RHEL:				; Process rcvd Phase IV Router Hello
	;
	;   Compare version numbers.  If we receive a message from a node
	;   with a higher version number, then drop the message.  The
	;   other node will detect that we are lower version and re-send
	;   the correct message.  If the version is lower than ours,
	;   but we don't recognize or support it, then log "version skew".
	;
	BSBW	PARSE_VERSION		; Parse the version field
	BLBC	R0,30$			; If error, chain to new event
	;
	;   Parse the remote node's address
	;
	CMPL	(R1)+,#TR$C_NI_PREFIX	; Standard NI prefix?
	BNEQ	70$			; Ignore msg if not
	BSBW	PARSE_PH4_ADDR		; Parse phase IV node address field
	BLBC	R0,30$			; Br on error with new event setup by
					; PARSE_PH4_ADDR
	;
	;   Parse the node type code
	;
	EXTZV	#TR3V_REQ_NTY,-		; Get node type
		#TR3S_REQ_NTY,(R1)+,R0	;
	MOVB	#ADJ$C_PTY_PH4,PTYPE	; Assume Phase IV routing
	CMPB	R0,#TR4C_NTY_ROU	; Is it a routing node?
	BEQL	20$			; Branch if so
	MOVB	#ADJ$C_PTY_AREA,PTYPE	; Assume Phase IV area routing
	CMPB	R0,#TR4C_NTY_ARO	; Is it area-router?
	BEQL	20$			; Branch if so
	BRW	PFE			; Else report "packet format error"
20$:	;
	;   If this is a message from a node in another area, then ignore
	;   it unless then node is also a level 2 router.  We assume that
	;   the only way to get a message from another area past the address
	;   parsing routine is for us to be a level 2 router.
	;
	;   This essentially allows level2-level2 connections, but
	;   disallows level2-level1 connections over the NI.
	;
	EXTZV	#TR4$V_ADDR_AREA,-	; Get area number of sending node
		#TR4$S_ADDR_AREA,R8,R0
	CMPB	R0,RCB$B_HOMEAREA(R4)	; Our area?
	BEQL	22$			; If not, drop the message
	CMPB	PTYPE,#ADJ$C_PTY_AREA	; Is the remote node a level 2 router?
	BNEQ	70$			; If not, ignore the message
22$:	;
	;   Parse remaining fields
	;
	MOVW	(R1)+,LEV_W_BLKSIZE	; Store partner's block size
	MOVB	(R1)+,LEV_B_PRIORITY	; Store router priority
	INCL	R1			; Skip AREA reserved field
	MOVW	(R1)+,LEV_W_HELLO	; Store partner's hello timer
	BNEQ	25$			; && If not filled in, assume old impl.
	MOVZBW	(R1),LEV_W_HELLO	; && who still used 1 byte hello
25$:	ADDL	#1+1+7,R1		; Skip reserved, count byte, LOGICAL NAME
	MOVZBW	(R1)+,WQE$L_PM2+2(R5)	; Store size of R/S LIST
	SUBL	R5,R1			; Compute offset to R/S LIST
	MOVW	R1,WQE$L_PM2(R5)	; Store offset to list
	MOVB	#LEV$C_RCV_RHEL,WQE$B_EVT(R5) ; Event is 'rcvd Router Hello'
30$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

;
; Drop the message on the floor.
;

70$:	CLRL	R0			; Return false - do not queue event
	RSB

	.SBTTL	RCV_EHEL - Received Phase IV Endnode Hello message
;+
; RCV_EHEL  - Process received Phase IV NI Endnode Hello message
;
; FUNCTIONAL DESCRIPTION:
;
; The message is parsed and validated, and an event is queued indicating
; that the message needs processing.
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other regs may be clobbered.
;-
RCV_EHEL:				; Process rcvd Phase IV Endnode Hello
	;
	;   Compare version numbers.  If we receive a message from a node
	;   with a higher version number, then drop the message.  The
	;   other node will detect that we are lower version and re-send
	;   the correct message.  If the version is lower than ours,
	;   but we don't recognize or support it, then log "version skew".
	;
	BSBW	PARSE_VERSION		; Parse the version field
	BLBC	R0,30$			; If error, chain to new event
	;
	;   Parse the Endnode Hello message
	;
	CMPL	(R1)+,#TR$C_NI_PREFIX	; Standard NI prefix?
	BNEQ	70$			; Ignore msg if not
	BSBW	PARSE_PH4_ADDR		; Parse phase IV node address field
	BLBC	R0,30$			; Br on error with new event setup by
					; PARSE_PH4_ADDR
	EXTZV	#TR4$V_ADDR_AREA,-	; Get area number of sending node
		#TR4$S_ADDR_AREA,R8,R0
	CMPB	R0,RCB$B_HOMEAREA(R4)	; Our area?
	BNEQ	70$			; If not, drop the message
	CMPZV	#TR3V_REQ_NTY,-		; Get node type
		#TR3S_REQ_NTY,(R1)+,-	;
		#TR4C_NTY_NROU		; Is it a endnode?
	BEQL	20$			; Branch if so
	BRW	PFE			; Else report "packet format error"
20$:	MOVB	#ADJ$C_PTY_PH4N,PTYPE	; Mark Phase IV endnode message
	MOVW	(R1)+,LEV_W_BLKSIZE	; Store partner's block size
	ADDL	#1+8+6,R1		; Skip AREA, SEED reserved fields
					; Skip NEIGHBOR (designated router)
	MOVW	(R1)+,LEV_W_HELLO	; Store partner's hello timer
	BNEQ	25$			; && If not filled in, assume old impl.
	MOVZBW	(R1),LEV_W_HELLO	; && who still used 1 byte hello
25$:	MOVB	#LEV$C_RCV_EHEL,WQE$B_EVT(R5) ; Event is 'rcvd Endnode Hello'
30$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

;
; Drop the message on the floor.
;

70$:	CLRL	R0			; Return false - do not queue event
	RSB

	.SBTTL	RCV_RT3 - Received Phase III routing message
;+
; RCV_RT - Routing message received
;
; FUNCTIONAL DESCRIPTION:
;
;	Verify the routing message header and checksum and queue a 
;	routing update event.
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB pointer
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other registers may be clobbered.
;
;-
RCV_RT:					; Process a routing message
	CMPB	ADJ$B_PTYPE(R7),#ADJ$C_PTY_PH3 ; Phase III or Phase IV?
	BEQL	RCV_RT3			; Branch if Phase III
	SUBW	#TR4C_RT_LNG-TR3C_RT_LNG,- ; Adjust length of msg left
		WQE$L_PM2+2(R5)		; for Phase IV message
	BRW	RCV_RT4			; Process Phase IV routing message

RCV_RT3:
	MOVB	#ADJ$C_PTY_PH3,PTYPE	; Indicate type of message
	BSBW	PARSE_PH3_ADDR		; Parse the node address
	BLBC	R0,15$			; If LBC then error
	SUBW3	R5,R1,WQE$L_PM2(R5)	; Save offset to current msg byte
	MOVZWL	WQE$L_PM2+2(R5),R9	; Get msg bytes remaining
	BLBS	R9,13$			; Must be an even number
	DIVL	#2,R9			; Get number of words
	BEQL	13$			; Illegal msg if EQL
	;
	;   Calculate checksum  --  R9 does not include the checksum. 
	;   The highest node address associated with a non-infinite cost/hops
	;   message cell is determined.  If that address is greater than
	;   our current "max address" then it is reported as an event.
	;
	MOVL	#1,R0			; Setup loop counter	
	CLRQ	R2			; Init check sum (R2) and highest node
					; (R3) reachable by partner
10$:	CMPW	(R1),#^X<7FFF>		; Compare to infinite "cost,hops"
	BGTRU	13$			; If GTRU then field is invalid
	BEQL	11$			; If EQL then not reachable by partner
	MOVL	R0,R3			; Save highest reachable address
11$:	ADDW	(R1)+,R2		; Calculate checksum via 1's complement
	ADWC	#0,R2			;   add - needs "end around carry"
	AOBLEQ	R9,R0,10$		; Loop until all segments processed
	MOVB	#LEV$C_RCV_RT,WQE$B_EVT(R5) ; Set up event assuming valid checksum
	CMPW	R2,(R1)			; Check sum valid ?
	BEQL	15$			; If EQL then  valid
13$:	$LOG	TPL_LDS,TPL_PRSN_RUCS,,R5 ; due to "routing update checksum"
	BRW	ADJ_DOWN_EVENT		; Report fatal event
	;
	;   The message is okay.  Log "partial routing update loss" if needed.
	;
15$:	CMPW	R3,RCB$W_MAX_ADDR(R4)	; Is partner's highest reachable node
					; address within range?
	BLEQU	50$			; If LEQU then yes
	BUMP	B,RCB$B_CNT_RUL(R4)	; Inc count for this event
	$LOG	TPL_PRU,,,R5		; Setup event logging code
	MOVW	R3,WQE$B_EVL_DT1(R5)	; Store partner's highest reachable node
	BSBW	NET$EVT_INTRAW		; Log the event
50$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

	.SBTTL	RCV_RT4 - Received Phase IV routing message
;+
; RCV_RT4 - Phase IV routing message received
;
;	Verify the routing message header and checksum, and queue a
;	routing update event.
;
; Inputs:
;
;	R11 = CNR address
;	R10 = CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;	R1 = Pointer to next byte in message
;
; Outputs:
;
;	R0 = True if event to be queued, false if not
;-
RCV_RT4:
	MOVB	#ADJ$C_PTY_PH4,PTYPE	; Indicate type of message
	BSBW	PARSE_PH4_ADDR		; Parse Phase IV node address
	BLBC	R0,90$			; If error, do event setup by parse
	EXTZV	#TR4$V_ADDR_AREA,-	; Get area number of sending node
		#TR4$S_ADDR_AREA,R8,R0
	CMPB	R0,RCB$B_HOMEAREA(R4)	; Our area?
	BNEQ	70$			; If not, drop the message
	INCL	R1			; Skip reserved byte
	SUBW3	R5,R1,WQE$L_PM2(R5)	; Save offset to first segment
	MOVZWL	WQE$L_PM2+2(R5),R3	; Get msg bytes remaining
	BLBS	R3,80$			; If odd, packet format error
	DIVL	#2,R3			; Get number of words
	BEQL	80$			; Illegal msg if EQL
	;
	;   Calculate checksum and check it
	;
	MOVL	#1,R2			; Init check sum
10$:	ADDW	(R1)+,R2		; Calculate checksum via 1's complement
	ADWC	#0,R2			;   add - needs "end around carry"
	SOBGTR	R3,10$			; Loop thru all segments
	CMPW	R2,(R1)			; Check sum valid ?
	BNEQ	80$			; If NEQ, then checksum error
	;
	;   Check if any routing update loss, and if so, log an event.
	;
	MOVZWL	RCB$W_MAX_ADDR(R4),R8	; Set upper limit for rtginfo
	BSBW	CHK_RUS4		; Check for routing update loss
	BLBC	R0,80$			; Branch if packet format error
	;
	;   Accept the message as valid.  Set up event to process it.
	;
	MOVB	#LEV$C_RCV_RT,WQE$B_EVT(R5) ; Set up event
90$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

70$:	CLRL	R0			; Ignore message
	RSB

;
; Log a "routing checksum" event
;
80$:	$LOG	TPL_LDS,TPL_PRSN_RUCS,,R5 ; due to "routing update checksum"
	BRW	ADJ_DOWN_EVENT		; Report fatal event

	.SBTTL	RCV_ART - Area Routing message received
;+
; RCV_ART - Area Routing message received
;
; FUNCTIONAL DESCRIPTION:
;
;	Verify the area routing message header and checksum and queue a 
;	routing update event.
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB pointer
;		R1	Ptr to next byte in the message
;
;		All others are scratch
;
; OUTPUTS:	R5	Unchanged
;		R0	True if event to be processed, false if not
;
;		All other registers may be clobbered.
;
;-
RCV_ART:				; Process an area routing message
	MOVB	#ADJ$C_PTY_AREA,PTYPE	; Indicate type of message
	BSBW	PARSE_PH4_ADDR		; Parse Phase IV node address
	BLBC	R0,90$			; Branch if error detected
	INCL	R1			; Skip reserved byte
	SUBW3	R5,R1,WQE$L_PM2(R5)	; Save offset to first segment
	MOVZWL	WQE$L_PM2+2(R5),R3	; Get msg bytes remaining
	BLBS	R3,80$			; If odd, packet format error
	DIVL	#2,R3			; Get number of words
	BEQL	80$			; Illegal msg if EQL
	;
	;   Calculate checksum and check it
	;
	MOVL	#1,R2			; Init check sum
10$:	ADDW	(R1)+,R2		; Calculate checksum via 1's complement
	ADWC	#0,R2			;   add - needs "end around carry"
	SOBGTR	R3,10$			; Loop thru all segments
	CMPW	R2,(R1)			; Check sum valid ?
	BNEQ	80$			; If NEQ, then checksum error
	;
	;   Check if any routing update loss, and if so, log an event.
	;
	MOVZBL	RCB$B_MAX_AREA(R4),R8	; Set upper limit for rtginfo
	BSBW	CHK_RUS4		; Check for routing update loss
	BLBC	R0,80$			; Branch if packet format error
	;
	;   Accept the message as valid.  Set up event to process it.
	;
	MOVB	#LEV$C_RCV_ART,WQE$B_EVT(R5) ; Set up event
90$:	MOVL	#1,R0			; Process event
	RSB				; Return true - process event

;
; Log a "routing checksum" event
;
80$:	$LOG	TPL_LDS,TPL_PRSN_RUCS,,R5 ; due to "routing update checksum"
	BRW	ADJ_DOWN_EVENT		; Report fatal event

	.SBTTL	Check for routing update loss
;+
; CHK_RUS4 - Check for routing update loss in Phase IV format messages
;
; Inputs:
;
;	R5 = WQE address
;	R4 = RCB address
;	R8 = Maximum allowed node/area number in message
;
; Outputs:
;
;	R0 = True if packet scanned successfully, False if format error
;	Event is logged, if necessary
;
;	R1-R3 are destroyed.
;-
CHK_RUS4:
	PUSHR	#^M<R6,R7,R8,R9>	; Save registers
	;
	;   Compute the highest reachable node in this routing message
	;   to be used to check for routing update loss.  Note that
	;   only segments which contain info for nodes higher than
	;   max address are even checked for the highest reachable
	;   node, as an optimization.
	;
	CLRL	R3			; Preset "highest reachable node"
	MOVZWL	WQE$L_PM2(R5),R9	; Get msg offset to routing info
	ADDL	R5,R9			; Convert to pointer
	MOVZWL	WQE$L_PM2+2(R5),R7	; Get number of bytes of rtginfo
50$:	SUBL	#4,R7			; Account for COUNT & STARTID
	BLEQ	80$			; Branch if packet format error
	MOVZWL	(R9)+,R1		; Get number of nodes in segment
	MOVZWL	(R9)+,R2		; Get starting node number
	ASHL	#1,R1,R6		; Compute number of bytes of rtginfo
	SUBL	R6,R7			; Account for cost/hops info
	BLSS	80$			; Branch if packet format error
	MOVAB	-1(R1)[R2],R0		; Compute highest node in segment
	CMPL	R0,R8			; Within max address?
	BGTRU	53$			; If within range, skip scanning segment
	ADDL	R6,R9			; Skip past entire segment
	BRB	58$			; Continue with next segment
53$:	CMPW	(R9)+,#^X<7FFF>		; Compare with infinite cost/hops
	BGTRU	80$			; If GTR, then field is invalid
	BEQL	55$			; Branch if not reachable by partner
	CMPL	R2,R3			; Is this the highest reachable node?
	BLEQU	55$			; Branch if not
	MOVL	R2,R3			; Else, save highest reachable node
55$:	INCL	R2			; Skip to next node
	SOBGTR	R1,53$			; Loop thru all nodes in segment
58$:	TSTL	R7			; Any more segments?
	BGTR	50$			; If so, continue
	;
	;   If the highest reachable node is greater than our maximum
	;   address, then log a non-fatal event.
	;
	CMPL	R3,R8			; Greater than max address?
	BLEQU	60$			; Branch if ok
	BUMP	B,RCB$B_CNT_RUL(R4)	; Inc count for this event
	$LOG	TPL_PRU,,,R5		; Setup event logging code
	MOVW	R3,WQE$B_EVL_DT1(R5)	; Store partner's highest reachable node
	BSBW	NET$EVT_INTRAW		; Log the event
60$:	MOVL	#1,R0			; Packet format is ok
90$:	POPR	#^M<R6,R7,R8,R9>	; Restore registers
	RSB

80$:	CLRL	R0			; Indicate bad packet format
	BRB	90$			; exit

	.SBTTL	Parse phase II/III/IV address
;+
; PARSE_PH2_ADDR	- Parse Phase II  address field
; PARSE_PH3_ADDR	- Parse Phase III address field
; PARSE_PH4_ADDR	- Parse Phase IV  address field
;
;
; INPUTS:	R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R1	Pointer to next field in message (node address)
;		R0	Scratch
;
; OUTPUTS:	R8	Node address from message
;		R1	Advance passed node address field in message
;		R0	LBS if successful
;			LBC otherwise.  In this case an event code is setup
;			for the state table processing and the Event Logging
;			info are setup in the WQE.
;
;		All other regs are unchanged
;
;-
	.ENABL	LSB

PARSE_PH2_ADDR:				; Parse Phase II node address field
	CVTBL	(R1)+,R8		; Get partner's node address
	BGEQ	10$			; Br unless field is extended
	MOVZBL	(R1)+,R0		; Get next (final) byte of field
	INSV	R0,#7,#25,R8		; Merge with low order bits
	$LOG	TPL_PFM,,,R5		; Assume fatal event is "format error"
	DECW	WQE$L_PM2+2(R5)		; Account for extra byte
	BLSS	40$			; If LSS then msg is too small
10$:	$LOG	TPL_ISF,TPL_PRSN_ADJR,,R5 ; Assume address out of range
	CMPL	R8,#TR2C_MAX_PNA	; Less than max Phase II address ?
	BGTRU	30$			; Out of range if GTRU
	BRB	20$			; Continue in common

PARSE_PH3_ADDR:				; Parse Phase III node address field
PARSE_PH4_ADDR:				; Parse Phase IV node address field
	CVTWL	(R1)+,R8		; Get the node address
	CMPB	RCB$B_ETY(R4),#ADJ$C_PTY_AREA ; Are we a level 2 router?
	BEQL	20$			; If so, skip the following check
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,R8,R0
	BEQL	20$			; If area = 0, allow it
	CMPB	R0,RCB$B_HOMEAREA(R4)	; Is it in our area?
	BEQL	20$			; If so, then ok
	BBC	#LPD$V_BC,LPD$W_STS(R6),30$ ; If non-BC circuit, then error
	BRB	70$			; If NI, then simply ignore it so that
					; multiple areas can co-exist without
					; interference from other areas
20$:	EXTZV	#TR4$V_ADDR_DEST,-	; Extract the node address (from area)
		#TR4$S_ADDR_DEST,R8,R0
	CMPW	R0,RCB$W_MAX_ADDR(R4)	; Within bounds?
	BGTRU	30$			; If not, report error
	MOVL	#1,R0			; Success
	BRB	50$

30$:	$LOG	TPL_LDO,-		; Line down due to "address out 
		TPL_PRSN_ADJR,,R5	; of range"
40$:	MOVB	#LEV$C_LOG_ADE,WQE$B_EVT(R5) ; Log event record & shutdown adjacency
	CLRB	R0			; Set error flag

50$:	MOVW	R8,LEV_W_PNA		; Save the node address
	RSB

;
; Drop the message on the floor.
;

70$:	MOVB	#LEV$C_NO_EVT,WQE$B_EVT(R5) ; Do nothing - drop message
	CLRL	R0			; Signal error detected
	RSB

	.DSABL	LSB

	.SBTTL	PARSE_VERSION - Parse version number field
;+
; PARSE_VERSION - Parse the 3 byte version number field
;
; Inputs:
;
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;	R1 = Pointer to next byte in msg (version number)
;
; Outputs:
;
;	R0 = True if Phase IV, else WQE setup to chain to another event
;	R1 = Advanced past version number field
;	R8 = First 2 bytes of version number (Version & ECO level)
;
;	NET$GL_INITVER = Saved copy of version number (for event logging)
;
;	All other registers are preserved.
;-
PARSE_VERSION:
	CLRL	-(SP)			; Allocate 4 bytes of scratch space
	;
	;   Get our version number.  This may be one of several values
	;   depending on whether the circuit has been forced to operate
	;   as a certain version type.
	;
	MOVZBL	LPD$B_ETY(R6),R0	; Get our node type for this circuit
	CMPB	R0,#ADJ$C_PTY_UNK	; Have we been assigned a node type?
	BEQL	70$			; If not, drop msg on the floor
	MOVZWL	PTY_TO_VERSION[R0],(SP)	; Get the 2 byte version number
	;
	;   Compare version numbers.  If we receive a message from a node
	;   with a higher version number, then drop the message.  The
	;   other node will detect that we are lower version and re-send
	;   the correct message.  If the version is lower than ours,
	;   but we don't recognize or support it, then log "version skew".
	;
	CMPB	(R1),(SP)		; Compare version numbers
	BGTRU	70$			; If higher than ours, ignore msg
	BLSSU	5$			; If equal, then
	CMPB	1(R1),1(SP)		; Compare ECO numbers
	BGTRU	70$			; If higher than ours, ignore msg
5$:	CMPW	(R1),(SP)		; Is it our version?
	BNEQ	60$			; If not, version skew
	MOVZWL	(R1),R8			; Return version to caller
	MOVW	(R1)+,NET$GL_INITVER	; Save INIT version (3 bytes)
	MOVB	(R1)+,NET$GL_INITVER+2	
	MOVL	#1,R0			; Success
90$:	ADDL	#4,SP			; Pop scratch space
	RSB

;
; Version number is lower than ours, but we can't handle it.  Log an event.
;

60$:	$LOG	TPL_LDS,TPL_PRSN_VRSK,,R5 ; Setup "version skew" event
	MOVB	#LEV$C_LOG_ADE,WQE$B_EVT(R5) ; Signal "adjacency down event"
	CLRL	R0			; Signal error detected
	BRB	90$

;
; Version number is higher than ours.  Drop the message on the floor.
;

70$:	MOVB	#LEV$C_NO_EVT,WQE$B_EVT(R5) ; Do nothing - drop message
	CLRL	R0			; Signal error detected
	BRB	90$

	.SBTTL	SET_DLL_EVT - Schedule event transition
;+
; SET_DLL_EVT - Schedule the processing of an event
;
; Inputs:	R0 = Event code
;		R6 = LPD address
;
; Outputs:	R0 = Status
;
;-
SET_DLL_EVT::
	PUSHR	#^M<R0,R1,R2>		; Save regs
	CLRL	R1			; Indicate no addition WQE space needed
	MOVL	#WQE$C_SUB_ACP,R0	; Indicate WQE subtype
	BSBW	WQE$ALLOCATE		; Allocate WQE (always succeeds!)
	MOVL	R2,R0			; Transfer WQE address
	CVTLB	(SP)+,WQE$B_EVT(R0)	; Enter event code
	MOVQ	(SP)+,R1		; Recover R1,R2 and cleanup stack
	MOVW	LPD$W_PTH(R6),-		; Enter LPD index
		    WQE$W_REQIDT(R0)	;
	MOVAB	B^NET$DLL_PRC_WQE,-	; Enter action routine address
		    WQE$L_ACTION(R0)	;
	BSBW	WQE$INSQUE		; Queue the WQE
10$:	MOVB	#1,R0			; Indicate success
	RSB

	.SBTTL	NET$DLL_PRC_WQE - Process work queue element
;+
; NET$DLL_PRC_WQE  - Process Work Queue Element
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called by the work queue dispatcher after the WQE is 
; dequeued from the work queue.  The WQE is deallocated below once it has
; been processed.
;
; INPUTS:	R5	WQE address
;
;		All other registers are scratch.
;
; OUTPUTS:	All registers are clobbered.
;
;-
NET$DLL_PRC_WQE:			; Process DLL WQE event
	BSBW	FIND_WQE_CTX		; Locate CNF, LPD, ADJ blocks
	BLBC	R0,KILL_WQE		; If LPD no longer exists, skip event
	BSBB	PROC_EVT		; Process the event
KILL_WQE:				; Deallocate WQE if its there
	MOVL	R5,R0			; Get WQE for deallocation
	BEQL	20$			; If EQL then none
	CLRL	R5			; Nullify normal pointer to it
	BSBW	WQE$DEALLOCATE		; Deallocate the WQE
20$:	RSB				; Done

	.SBTTL	PROC_EVT - Process an event
;+
; PROC_EVT	- Process DLL event
;
; This routine processes all Data Link Layer events and is state table driven.
; Action routines are called until the null event is detected.  Each action
; routine generates a new event, which it returns in R1, and returns with the 
; low bit set in R0 only if the indicated state change is to be performed.
;
; Inputs:
;
;	R11 = CNR address
;	R10 = CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R5 = WQE address
;
; Outputs:
;
;	R5 = WQE address
;
;	All other registers are clobbered
;-
PROC_EVT:				; Process all DLL events
	MOVL	R6,LEV_L_LPD		; Save the LPD pointer
	MOVL	R7,LEV_L_ADJ		; Save the ADJ pointer
	MOVQ	R10,LEV_Q_CRI		; Save the CRI CNF and CNR ptrs
	;
	;   Find appropriate state table entry
	;
	MOVZBL	WQE$B_EVT(R5),R1	; Get the event code
5$:	MOVZBL	LPD$B_STI(R6),R3	; Get LPD internal state
	CMPL	S^#LEV$C_MAX_EVT,R1	; Is event within range ?
	BLSSU	30$			; If LSSU then bug exists
	MULL3	S^#LEV$C_STATES,R1,R4	; Bias for current event
	ADDL	R3,R4			; Add current state offset
	MOVAW	LEV$AW_STA_TAB[R4],R3	; Address state table entry
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
					; (Clobbers R0; stack has been changed)
	BLBC	R0,14$			; If LBC journalling is inactive
	BSBW	FILL_JNL		; Fill the record
	JSB	@(SP)+			; Store the journal record
14$:	CMPL	S^#LEV$C_EXIT,R1	; Are we done ?
	BEQL	18$			; If so, exit processing
	;
	;
	;   Dispatch to the action routine with the following:
	;
	;   INPUTS:	R11	CRI CNR ptr
	;		R10	CRI CNF ptr
	;		R7	ADJ address
	;		R6	LPD address
	;		R5	WQE address
	;		R4	RCB address
	;
	;   ON RETURN:	R5	Unchanged
	;		R1	Next event to be processed
	;		R0	Low bit set if state change is permitted,
	;			Low bit clear to avoid state change
	;
	;		All other regs may be clobbered
	;
	PUSHAB	(R3)+			; Save table address
	MOVZBL	(R3),R3			; Get action routine index
	MOVL	LEV_AL_ACTTAB[R3],R0	; Get action routine address
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB pointer
	JSB	(R0)			; Dispatch
	POPL	R3			; Get next state, cleanup stack
	MOVL	LEV_L_LPD,R6		; Get LPD address
	BEQL	20$			; If EQL then its been deallocated
	BLBC	R0,15$			; Avoid state change if LBC
	MOVB	(R3),LPD$B_STI(R6)	; Change state
15$:	MOVL	LEV_L_ADJ,R7		; Recover ADJ address
	MOVQ	LEV_Q_CRI,R10		; Recover CRI context
	BRB	5$			; Process next event

18$:	BSBW	COND_DEAL_LPD		; Clean-up if necessary
20$:	RSB

30$:	BUG_CHECK  NETNOSTATE,FATAL	; Signal the bug


FILL_JNL:
	MOVB	#^X<CC>,(R1)+		; Enter journal record type
	MOVB	LPD$B_STI(R6),(R1)+	; Current state
	PUSHAB	LEV$AW_STA_TAB		; Base of state table
	SUBL3	(SP)+,R3,(R1)		; State table offset
	BICL	#^X1F,(R1)+		; Display only base offset of event
	MOVW	(R3),(R1)+		; Enter table contents
	MOVW	LPD$W_PTH(R6),(R1)+	; Enter path ID
	MOVW	LPD$W_STS(R6),(R1)+	; Enter current status
	MOVB	LPD$B_XMTFLG(R6),(R1)+	; Enter xmit flags
	MOVB	LPD$B_ASTCNT(R6),(R1)+	; Enter asynch activity count
	MOVW	ADJ$W_PNA(R7),(R1)+	; Enter the partner's address
	MOVW	ADJ$W_BUFSIZ(R7),(R1)+	; Enter partner's block size
	MOVB	LPD$B_PVCFLG(R6),(R1)+	; Enter PVC startup flags
	RSB

	.SBTTL	FIND_WQE_CTX - Find context for a new WQE
;+
; FIND_WQE_CTX - Find CNF, LPD and ADJ for a new WQE to be processed
;
; This routine is called to locate the CNF, LPD and ADJ corresponding to a
; WQE to be processed.
;
; Inputs:
;
;	R5 = WQE address
;
; Outputs:
;
;	R11 = CNR address
;	R10 = CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R5 = WQE address
;	R0 = True if LPD found, else false
;
;	R8 is destroyed.
;-
FIND_WQE_CTX:
	PUSHL	#0			; Scratch for holding LPD address
	MOVZWL	WQE$W_REQIDT(R5),R8	; Get LPD index
	;
	;   If this is the local LPD, then skip looking up the CNF block,
	;   since there is none.
	;
	CMPB	R8,#LPD$C_LOC_INX	; Local LPD index?
	BEQL	50$			; If so, handle it specially
	;
	;   Find the LPD and CRI
	;
	BSBW	NET$GET_LPD_CRI		; Find LPD and CRI for this index
	BLBC	R0,90$			; Branch if not found
	MOVL	R6,(SP)			; Save LPD address
	;
	;   Find the ADJ.  If the ADJ index in the WQE is zero, then use
	;   the LPD index so that the static ADJ block is used.
	;
	MOVZWL	WQE$W_ADJ_INX(R5),R8	; Is ADJ index 0?
	BEQL	10$			; Branch if so
	BSBW	NET$FIND_ADJ		; Locate ADJ block
					; and get LPD corresponding to ADJ
	BLBC	R0,90$			; If it went away, skip event
	BRB	20$
10$:	MOVZBW	LPD$B_PTH_INX(R6),WQE$W_ADJ_INX(R5) ; Set ADJ index
	MOVZWL	WQE$W_ADJ_INX(R5),R8	; Get ADJ index
	BSBW	NET$FIND_ADJ		; Locate ADJ block (returns 0 if none)
					; and get LPD corresponding to ADJ
20$:	CMPL	R6,(SP)			; Was ADJ$W_LPD different than WQE LPD?
	BNEQ	30$			; If so, bugcheck
	MOVL	#1,R0			; Success
90$:	ADDL	#4,SP			; Pop scratch storage
	RSB

;
; Special handing for local LPD
;

50$:	BSBW	NET$FIND_LPD		; Find the LPD via index in R8
	BLBS	R0,90$			; Exit if ok
					; Else, bugcheck

30$:	BUG_CHECK  NETNOSTATE,FATAL	; Signal the bug

	.SBTTL	Simple transition routines
;+
; Various "simple" data link state transition action routines.
;
; ACT_BUG	- Bugcheck failure
; ACT_NYI	- Not-yet-implemented error
; ACT_NOP	- No-operation
; ACT_IRP_EVT	- I/O Request Packet returned to ACP
; ACT_LOG_NFE	- Log event record
; ACT_LOG_CDE	- Log event record & shutdown circuit
; ACT_LOG_ADE	- Log event record & shutdown adjacency
;
;   INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;
;   OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered
;
ACT_BUG:
	BUG_CHECK  NETNOSTATE,FATAL	; Signal the bug
ACT_NYI:
	BUG_CHECK  NETNOSTATE,FATAL	; Signal the bug

ACT_EXIT:				; Exit state table processing
	MOVL	#LEV$C_EXIT,R1		; Signal last event
	MOVB	#1,R0			; Allow state transition
	RSB

ACT_NOP:				; Nop action routine
	MOVL	#LEV$C_NO_EVT,R1	; Signal last event
	MOVB	#1,R0			; Allow state transition
	RSB

ACT_LOG_CDE:				; Log event record & shutdown circuit
	BSBW	NET$EVT_INTRAW		; Call internal raw event logger
	MOVL	#LEV$C_LIN_DOWN,R1	; Generate circuit down event
	MOVB	#1,R0			; Allow state change
	RSB

ACT_LOG_ADE:				; Log event record & shutdown adjacency
	BSBW	NET$EVT_INTRAW		; Call internal raw event logger
	MOVL	#LEV$C_ADJ_DOWN,R1	; Generate circuit down event
	MOVB	#1,R0			; Allow state change
	RSB

ACT_LOG_NFE:				; Log event record
	BSBW	NET$EVT_INTRAW		; Call internal raw event logger
	MOVL	#LEV$C_NO_EVT,R1	; No new events
	MOVB	#1,R0			; Allow state change
	RSB

	.SBTTL	ACT_RCV_STR - Received start message
;+
; ACT_RCV_2STR - Second start message received
; ACT_RCV_STR - Start message received
;
; Inputs:	R11 = CRI CNR address
;		R10 = CRI CNF address
;		R7 = ADJ address
;		R6 = LPD address
;		R5 = WQE address
;		R4 = RCB address
;
; Outputs:	R0 = True if state change requested
;		R1 = Next event to be processed
;
;		R6 is the only register preserved.
;-
ACT_RCV_2STR:				; Second start msg received
	BISB	#LPD$M_XMT_STR!-	; Retransmit everything
		 LPD$M_XMT_VRF!-
		 LPD$M_XMT_IDLE,-
		LPD$B_XMTFLG(R6)

ACT_RCV_STR:
	;
	;   If the message we just received doesn't match the type
	;   that we sent, then we need to retransmit a start message
	;   again, only this time in the right Phase.
	;   
	MOVAB	PTY_TO_PHASE,R2		; Get address of phase conversion table
	MOVZBL	LPD$B_ETY(R6),R0	; Get our node type
	MOVZBL	PTYPE,R1		; Get his node type (from msg)
	CMPB	(R2)[R1],(R2)[R0]	; Does msg "phase" match ours?
	BEQL	5$			; If same phase, process message
	BGTR	4$			; If higher phase, ignore msg.
					; Else, restart init. sequence by ...
	SETBIT	LPD$V_XMT_STR,-		; Retransmit start msg (the start
		LPD$B_XMTFLG(R6)	; msg we already sent was wrong)
	;
	;   The message type we received doesn't match what we sent.
	;
	;   If this circuit has been forced into a certain type by
	;   the network manager, then ignore the message we just
	;   received because it doesn't match what we want.
	;   Otherwise, process the message (storing the correct type),
	;   and we will later send the correct start message because
	;   we were just marked for "start transmit" above.
	;
	PUSHL	R7			; Save ADJ address
	$GETFLD	cri,l,xpt		; Were we forced into a specific type?
	POPL	R7			; Restore ADJ address
	BLBS	R0,4$			; If so, then ignore the message
	BSBW	ADAPT_TO_PARTNER	; Adapt to partner's node type
	BRB	5$			; Process the message now
	;
	;   Ignore the message
	;
4$:	CLRB	R0			; No state change
	BRW	40$
	;
	;   Process message.  Dispatch on message type.
	;
5$:	$DISPATCH PTYPE,<-		; Dispatch on message type
		<ADJ$C_PTY_PH2,7$>,-	; Phase II
		<ADJ$C_PTY_PH3,8$>>	; Phase III routing
	BRB	10$			; Else, no special processing here
	;
	;   Partner is a Phase II node.  Set the number of NOP messages to
	;   send for circuit acceptance test.
	;
7$:	MOVB	#TR2C_NUM_NOP,-		; Setup # of NOP msgs to send
		LPD$B_TSTCNT(R6)	; to test the circuit
	BRB	20$
	;
	;   Partner is a Phase III routing node.  Determine if his receive 
	;   buffer size is adequate to receive a maximum sized routing message.
	;
8$:	MOVZWL	RCB$W_MAX_ADDR(R4),R0	; Get max node address
	MULL	#NET$C_TRCTL_CEL,R0	; Cell size for node in 
					; routing message
	ADDL	#NET$C_TRCTL_OVR,R0	; Routing message overhead
	CMPW	LEV_W_BLKSIZE,R0	; Can partner receive rtg msg?
	BLSSU	50$			; If LSSU buffer is too small
	;
	;   Setup number of test messages to send for circuit acceptance test
	;   for all nodes except Phase II nodes.
	;
10$:	MOVB	#TR3C_NUM_TST,-		; Setup number of test messages
		LPD$B_TSTCNT(R6)
	;
	;   Store partner's block size, set flags to schedule initialization
	;   message transmission.
	;
20$:	CMPW	LEV_W_BLKSIZE,#NET$C_MINBUFSIZ	; At least as big as minimum?
	BLSSU	50$				; If LSSU then no
	MOVW	LEV_W_BLKSIZE,ADJ$W_BUFSIZ(R7)	; Setup partner's buff size
	MOVW	LEV_W_PNA,ADJ$W_PNA(R7)		; Setup partner's node address
	MOVZWL	LEV_W_HELLO,R0			; Get partner's hello timer
	BNEQ	22$				; If not specified (Phase III),
	MOVZWL	LPD$W_INT_TLK(R6),R0		; then use our own hello timer
22$:	MULL	#TR4C_T3MULT,R0			; Multiply by hello/listen factor
	MOVW	R0,ADJ$W_INT_LSN(R7)		; Set listen interval
	MOVW	R0,ADJ$W_TIM_LSN(R7)		; Start listen timer
	MOVB	PTYPE,ADJ$B_PTYPE(R7)		; Setup partner's node type
	$DISPATCH PTYPE,<-
		<ADJ$C_PTY_PH3,25$>,-		; If Phase III router,
		<ADJ$C_PTY_PH4,25$>,-		; Or Phase IV level 1 router,
		<ADJ$C_PTY_AREA,25$>>		; Or Phase IV level 2 router,
	BRB	28$
25$:	SETBIT	ADJ$V_RTG,ADJ$B_STS(R7)		; then set RTG flag
28$:	BISB	XMTFLG,LPD$B_XMTFLG(R6)		; Setup xmit flags
	BBS	#LPD$V_XMT_VRF,XMTFLG,30$	; Br if verification msg needed
	CLRBIT	LPD$V_XMT_VRF,LPD$B_XMTFLG(R6)	; Clear flag to send the msg
30$:	MOVB	#1,R0				; Allow state change

40$:	MOVL	S^#LEV$C_NO_EVT,R1		; No further events
	RSB

;
; Log "invalid partner block size" event
;
50$:	$LOG	TPL_IOF,TPL_PRSN_ADJB,,R5 	; Buffer size too small
	MOVL	#LEV$C_LOG_CDE,R1		; Signal "circuit down event"
	MOVL	#1,R0				; Make state change
	RSB

	.SBTTL	ADAPT_TO_PARTNER - Adapt to partner's node type
;+
; ADAPT_TO_PARTNER - Adapt to partner's node type
;
; This routine is called when our partner is speaking a older Routing
; version than we are.  The function is to figure out what version we want
; to speak, based on his version, and store it in the LPD block so that
; we only speak the older version from now on.
;
; Inputs:
;
;	R7 = ADJ address
;	R6 = LPD address
;	R4 = RCB address
;	PTYPE = Partner node type (based on Start message)
;	LPD$B_ETY = Our node type
;
; Outputs:
;
;	LPD$B_ETY = Our new adapted node type for this circuit
;
;	R0-R2 are destroyed.
;-
ADAPT_TO_PARTNER:
	MOVZBL	PTYPE,R1		; Get partner node type
	MOVZBL	LPD$B_ETY(R6),R0	; Get our node type
	$DISPATCH R0,<-			; If we are an endnode,
		<ADJ$C_PTY_PH4N,20$>,-	; then drop to his version only as
		<ADJ$C_PTY_PH3N,20$>>	; an endnode
	;
	;   We are a router.  Make sure that we drop to his version,
	;   BUT as a router of that version, and not an endnode.
	;
	MOVZBL	PTY_TO_PHASE[R1],R2	; Get his "phase" (II, III or IV)
	$DISPATCH R2,<-			; Dispatch on phase #
		<2,50$>,-		; Drop to Phase II
		<3,13$>>		; Drop to Phase III router
	BRB	70$			; All other values illegal

13$:	MOVB	#ADJ$C_PTY_PH3,R1	; Act as a Phase III router
	BRB	50$

	;
	;   We are an endnode.  Make sure that we drop to his version,
	;   BUT as an endnode of that version, and not a router.
	;
20$:	MOVZBL	PTY_TO_PHASE[R1],R2	; Get his "phase" (II, III or IV)
	$DISPATCH R2,<-			; Dispatch on phase #
		<2,50$>,-		; Phase II
		<3,23$>>		; Phase III endnode
	BRB	70$			; All other values illegal

23$:	MOVB	#ADJ$C_PTY_PH3N,R1	; Act as a Phase III endnode

50$:	MOVB	R1,LPD$B_ETY(R6)	; Set our new node type
	RSB

;
; Cannot adapt to his version
;

70$:	BUG_CHECK NETNOSTATE,FATAL

	.SBTTL	ACT_RCV_VRF - Received verification message
;+
; ACT_RCV_VRF - React to received verification message
;
; Inputs:	R11 = CRI CNR address
;		R10 = CRI CNF address
;		R7 = ADJ address
;		R6 = LPD address
;		R5 = WQE address
;
; Outputs:	R0 = True if state change requested
;		R1 = Next event to be processed
;
;		R6 is the only register preserved.
;-
ACT_RCV_VRF:
	;
	;   Is phase of verification message the same as that of the Init msg?
	;
	MOVZWL	 ADJ$W_PNA(R7),R8	; Get partner's address
	$LOG	TPL_ISF,TPL_PRSN_UXPK,,R5 ; Assume phase change
					
	CMPB	ADJ$B_PTYPE(R7),#ADJ$C_PTY_PH2 ; Phase II message expected?
	BNEQ	5$			; Branch if not
	CMPB	PTYPE,#ADJ$C_PTY_PH2	; Phase II message?
	BEQL	10$			; Ok if so
4$:	BRW	30$			; Else phase change - log it
5$:	CMPB	PTYPE,#ADJ$C_PTY_PH2	; Phase II message?
	BEQL	4$			; If so, phase change - log it
	;
	;   Did the operator change the adjacent node's address?
	;
	$LOG	TPL_IOF,TPL_PRSN_ADJC,,R5 ; Assume address change
	CMPW	R8,LEV_W_PNA		; Is the address the same as it was?
	BNEQ	4$			; If not the same, log the event
	;
	;   If the remote node is a Phase III router, then REQUIRE that
	;   a non-null password has been specified on the remote node,
	;   and that it matches the receive password specified on this node.
	;   This is intended to prevent accidental "cost/hops leakage"
	;   (i.e. address merging) between two different areas if they
	;   are accidentally connected between 1 or more Phase III routers.
	;   The recommendation to customers is that they use passwords
	;   containing the area number so that Phase III node can't be
	;   accidentally connected to another area.
	;
	;   This check is only done if we are in a hierarchical network,
	;   which is assumed if our homearea is not "1".
	;
10$:	PUSHR	#^M<R7,R10,R11>		; Save registers
	CLRL	R3			; Preset "exact match" flag = false
	CMPB	RCB$B_HOMEAREA(R4),#1	; Is our area anything but "1"?
	BEQL	11$			; Branch if not
	CMPB	ADJ$B_PTYPE(R7),-	; Is adjacent node Phase III router?
		#ADJ$C_PTY_PH3
	BNEQ	11$			; Branch if not
	MOVL	#1,R3			; Require exact password match
	PUSHR	#^M<R3>			; Save flag
	CMPC5	#0,(SP),#0,-		; Check if remote node gave
		LEV_Q_PSWDESC,-		; null password (RSX sends 8 bytes
		@LEV_Q_PSWDESC+4	; of 0, rather than 0 byte string)
	POPR	#^M<R3>			; Restore flag - use POPR, saving PSL
	BNEQ	12$			; If null password,
	$LOG	TPL_ISF,TPL_PRSN_VREQ,,R5 ; Log "verification req. from PH3 node"
	CLRL	WQE$L_EVL_PKT(R5)	; Don't print any packet header either
	BRB	29$			; log event and bring down circuit
	;
	;   If the circuit has specified that verification is required
	;   for all remote nodes over this circuit, then require verification.
	;
11$:	$GETFLD	cri,v,ver		; Is verification required ?
	ASSUME	NMA$C_CIRVE_ENA  EQ  0
	ASSUME	NMA$C_CIRVE_DIS  EQ  1
	BLBS	R8,20$			; If disabled (or not set), skip it
					; Require match only if RPA set
	;
	;   Verification is required.  Does the receive password match?
	;   If no node database entry is found, or if the passwords don't
	;   match, then reject the connection.
	;
12$:	MOVL	NET$GL_CNR_NDI,R11	; Setup the root pointer
	MOVZWL	LEV_W_PNA,R8		; Get node address
	BSBW	NET$NDI_BY_ADD		; Find the matching NDI
	BLBS	R0,15$			; If LBS then found
	$LOG	TPL_VFR,,,R5		; due to "node not in database"
	BRB	29$			; Log the event and bring line down
15$:	$GETFLD	ndi,s,rpa		; Get the receive password 
	BLBS	R3,18$			; If exact match not required,
	BLBC	R0,20$			; and no password specified, skip check
					; (else, try match even with null RPA)
18$:	$LOG	TPL_VFR,,,R5 		; Assume password mismatch
	CMPC5	R7,(R8),#0,-		;
		LEV_Q_PSWDESC,-		; Does it match ?
		@LEV_Q_PSWDESC+4	;
	BNEQ	29$			; If NEQ no - verification failure
20$:	POPR	#^M<R7,R10,R11>		; Restore registers
	MOVL	S^#LEV$C_RCV_VVF,R1	; Indicate "valid verification"
	MOVB	#1,R0			; Allow state change
	RSB

29$:	POPR	#^M<R7,R10,R11>		; Restore registers
					; and log verification failure
;
; Log verification failure and bring the line down
;
30$:	MOVL	#LEV$C_LOG_CDE,R1	; Switch to circuit down event
	MOVL	#1,R0			; Make state change
	RSB

	.SBTTL	ACT_RCV_RHEL - Received Router Hello message
;+
; ACT_RCV_RHEL - Router Hello message received
;
; Inputs:	R11 = CRI CNR address
;		R10 = CRI CNF address
;		R7 = ADJ address
;		R6 = LPD address
;		R5 = WQE address
;
; Outputs:	R0 = True if state change requested
;		R1 = Next event to be processed
;
;		R6 is the only register preserved.
;-
ACT_RCV_RHEL:
	;
	;   Check that buffer size is reasonable
	;
	CMPW	LEV_W_BLKSIZE,#NET$C_MINBUFSIZ	; At least as big as minimum?
	BGEQU	10$				; If LSSU then no
	$LOG	TPL_IOF,TPL_PRSN_ADJB,,R5 	; Buffer size too small
	BRW	70$				; Log the event, bring adj down
10$:	;
	;   Check that partner's node type hasn't changed
	;
	CMPB	PTYPE,ADJ$B_PTYPE(R7)		; Node type changed?
	BEQL	20$				; Branch if ok
	$LOG	TPL_LDS,TPL_PRSN_UXPK,,R5	; Unexpected message
	BRW	70$				; Log the event, bring adj down
20$:	;
	;   Store partner's block size, router priority and listen timer
	;   parsed from message.
	;
	MOVW	LEV_W_BLKSIZE,ADJ$W_BUFSIZ(R7)	; Setup partner's buff size
	MOVB	LEV_B_PRIORITY,ADJ$B_BCPRI(R7)	; Set router priority
	MOVZWL	LEV_W_HELLO,R0			; Get partner's hello timer
	MULL	#TR4C_BCT3MULT,R0		; Multiply by hello/listen factor
	MOVW	R0,ADJ$W_INT_LSN(R7)		; Set listen interval
	MOVW	R0,ADJ$W_TIM_LSN(R7)		; Start listen timer
	;
	;   If this router buffer size is less than the current "minimum",
	;   then we want to update the main ADJ$W_BUFSIZ for the BC, so that
	;   it always contains the minimum buffer size of all BRAs on the NI.
	;
	MOVZBL	LPD$B_PTH_INX(R6),R0		; Get LPD index
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R0	; Get main ADJ for BC
	CMPW	ADJ$W_BUFSIZ(R7),ADJ$W_BUFSIZ(R0) ; Is bufsiz less than minimum?
	BGEQU	25$				; Branch if not
	MOVW	ADJ$W_BUFSIZ(R7),ADJ$W_BUFSIZ(R0) ; If so, store the minimum
25$:	;
	;   If we are an endnode, then simply remember this router as being
	;   our "designated router", and mark the BRA up.
	;
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<- 	; If we are an endnode,
		<ADJ$C_PTY_PH4N,27$>,-
		<ADJ$C_PTY_PH3N,27$>>
	BRB	29$
27$:	BBSS	#ADJ$V_RUN,ADJ$B_STS(R7),26$	; Set into RUN state
	$LOG	TPL_AUP,,,R5			; Set "adjacency up" event
	BSBW	NET$EVT_INTRAW			; Log the event record
26$:	MOVW	WQE$W_ADJ_INX(R5),LPD$W_DRT(R6)	; Store ADJ index of DRT
	BSBW	UPDATE_ALL			; Update output path if changed
	BRW	90$				; Exit with success
29$:	;
	;   See if two-way communication has been reached with the remote
	;   partner by checking to see if our node address appears in his
	;   election list.
	;
	MOVZWL	WQE$L_PM2+2(R5),R2		; Get number of bytes in list
	MOVZWL	WQE$L_PM2(R5),R3		; Get offset to list
	ADDL	R5,R3				; Get address of list
	BRB	40$
30$:	CMPL	(R3),#TR$C_NI_PREFIX		; Standard Phase IV prefix?
	BNEQ	69$				; If not, packet format error
	CMPW	4(R3),RCB$W_ADDR(R4)		; Our address?
	BEQL	42$				; Branch if so
35$:	SUBL	#7,R2				; Skip entry in list
	ADDL	#7,R3
40$:	TSTL	R2				; Any bytes left?
	BGTR	30$
	;
	;   Our node address is not in his list.  If this adjacency
	;   was already up, the bring it down (since it represents
	;   a change in his status).  If we are waiting for 2-way
	;   communication, then continue to wait.
	;
	BBC	#ADJ$V_RUN,-		; If not in RUN state,
		ADJ$B_STS(R7),45$	; then keep waiting
	$LOG	TPL_LDS,TPL_PRSN_DROP,,R5 ; Log "dropped by adjacent node"
	CLRL	WQE$L_EVL_PKT(R5)	; Don't print any packet header either
	BRW	70$			; Bring down adjacency

69$:	BRW	60$			; Report packet format error
	;
	;   2-way communication has been established to the partner node.
	;   Mark the broadcast router adjacency in run state and log the
	;   adjacency up.
	;
42$:	BBSS	#ADJ$V_RUN,-		; Set into RUN state
		ADJ$B_STS(R7),45$	; Skip if already in run state
	$LOG	TPL_AUP,,,R5		; Set "adjacency up" event
	BSBW	NET$EVT_INTRAW		; Log the event record
	BSBW	UPDATE_ALL		; Force routing msgs to be sent
45$:	;
	;   Build new NI router list for our Router Hello message
	;
	;   If there was at least one router in the election list which
	;   is still waiting for two-way communication to be established,
	;   then cause a Router Hello message to be sent in 1 second, so
	;   that elections are resolved quickly on the NI.
	;
	BSBW	BUILD_RTR_LIST			; Re-build NI router list
	BLBS	R0,48$				; Branch if election stabilized
	MOVW	#1,LPD$W_TIM_TLK(R6)		; Make talker fire in 1 sec.
48$:	;
	;   If we have just initialized the circuit ("waiting for ballots"),
	;   then wait to resolve the election after we've had time to hear
	;   from everyone.  The election timer will eventually resolve the
	;   election in this case.
	;
	BBS	#LPD$V_ELECT_TIM,-		; If we are waiting for ballots,
		LPD$W_STS(R6),90$		; then wait for timer to fire
	;
	;   Store designated router address in LPD.  If we are the
	;   designated router, then NETDRIVER will send our Router Hello
	;   messages to "all endnodes" as well as "all routers".
	;
	BSBW	ELECT_ROUTER			; Elect a designated router
	MOVW	R1,LPD$W_DRT(R6)		; Store designated router index
90$:	MOVL	S^#LEV$C_NO_EVT,R1		; No further events
	MOVB	#1,R0				; Allow state change
	RSB

;
; Log "packet format error" & bring adjacency down
;
60$:	BUMP	B,RCB$B_CNT_PFE(R4)		; Bump packet format error count
	$LOG	TPL_PFM,,,R5			; Packet format error

;
; Log event record & bring adjancency down
;
70$:	MOVL	#LEV$C_LOG_ADE,R1		; Signal "adjacency down event"
	MOVL	#1,R0				; Make state change
	RSB

	.SBTTL	ACT_ELECT - Resolve election after waiting for ballots
;+
; ACT_ELECT - Resolve election which is waiting for ballots
;
; This routine must only be called if we are a router (if an endnode
; was to set its DRT to ourself, we would probably crash).
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;
; Outputs:
;
;	R0 = True if state change requested
;	R1 = Next event to be processed
;
;	R6 is the only register preserved.
;-
ACT_ELECT:
	;
	;   Clear the election suppression flag.  This means that after
	;   this point, the routine which receives the Router Hello messages
	;   will be free to run the election algorithm itself.
	;
	CLRBIT	#LPD$V_ELECT_TIM,-		; Clear election suppression
		LPD$W_STS(R6)
	;
	;   Store designated router address in LPD.  If we are the
	;   designated router, then NETDRIVER will send our Router Hello
	;   messages to "all endnodes" as well as "all routers".
	;
	BSBW	ELECT_ROUTER			; Elect a designated router
	MOVW	R1,LPD$W_DRT(R6)		; Store designated router index

	MOVL	S^#LEV$C_NO_EVT,R1		; No further events
	MOVB	#1,R0				; Allow state change
	RSB

	.SBTTL	ACT_RCV_EHEL - Received Endnode Hello message
;+
; ACT_RCV_EHEL - Endnode Hello message received
;
; Inputs:	R11 = CRI CNR address
;		R10 = CRI CNF address
;		R7 = ADJ address
;		R6 = LPD address
;		R5 = WQE address
;		R4 = RCB address
;
; Outputs:	R0 = True if state change requested
;		R1 = Next event to be processed
;
;		R6 is the only register preserved.
;-
ACT_RCV_EHEL:
	;
	;   Check that buffer size is reasonable
	;
	CMPW	LEV_W_BLKSIZE,#NET$C_MINBUFSIZ	; At least as big as minimum?
	BGEQU	10$				; If LSSU then no
	$LOG	TPL_IOF,TPL_PRSN_ADJB,,R5 	; Buffer size too small
	BRB	70$				; Log the event, bring adj down
10$:	;
	;   Check that partner's node type hasn't changed
	;
	CMPB	PTYPE,ADJ$B_PTYPE(R7)		; Node type changed?
	BEQL	20$				; Branch if ok
	$LOG	TPL_LDS,TPL_PRSN_UXPK,,R5	; Unexpected message
	BRB	70$				; Log the event, bring adj down
20$:	;
	;   Store partner's block size and listen timer parsed from message.
	;
	MOVW	LEV_W_BLKSIZE,ADJ$W_BUFSIZ(R7)	; Setup partner's buff size
	MOVZWL	LEV_W_HELLO,R0			; Get partner's hello timer
	MULL	#TR4C_BCT3MULT,R0		; Multiply by hello/listen factor
	MOVW	R0,ADJ$W_INT_LSN(R7)		; Set listen interval
	MOVW	R0,ADJ$W_TIM_LSN(R7)		; Start listen timer
	MOVL	S^#LEV$C_NO_EVT,R1		; No further events
	MOVB	#1,R0				; Allow state change
	RSB

;
; Log event record & bring adjancency down
;
70$:	MOVL	#LEV$C_LOG_ADE,R1		; Signal "adjacency down event"
	MOVL	#1,R0				; Make state change
	RSB

	.SBTTL	ACT_RCV_RT - Receive routing message
;+
; ACT_RCV_RT - React to received routing message
; ACT_RCV_RTA - React to routing message received while in acceptance algorithm
;
; Inputs:	R11 = CRI CNR address
;		R10 = CRI CNF address
;		R7 = ADJ address
;		R6 = LPD address
;		R5 = WQE address
;
; Outputs:	R0 = True if state change requested
;		R1 = Next event to be processed
;
;		R6 is the only register preserved.
;-
ACT_RCV_RT:				; React to rcv'd routing message
	BSBB	PROC_RT			; Do common processing
	BLBC	R0,10$			; If LBC then something's wrong
	BSBW	REQUEST_UPDATE		; Request running of update algorithm
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
10$:	RSB				; Return state table control in R0/R1

ACT_RCV_RTA:				; Receive routing message while running
					; the acceptance algorithm
	BSBB	PROC_RT			; Do common processing
	BLBC	R0,10$			; If LBC then something's wrong
	;
	;   Terminate the acceptance testing and generate a "circuit up"
	;   event.  This is necessary since we've just updated the matrix.
	;
	CLRB	LPD$B_TSTCNT(R6)	; Don't send any more test messages
	MOVL	#LEV$C_LIN_UP,R1	; Signal "circuit up"
10$:	RSB				; Return state table control in R0/R1

PROC_RT:				; Common Routing message processing
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,5$>,-	; never process rtg messages
		<ADJ$C_PTY_PH3N,5$>>
	;
	;   Is the adjacency in the RUN state?  If not, ignore the routing
	;   message, since it might have preceeded the necessary Router
	;   Hello messages (for broadcast circuits ONLY).
	;
	BBC	#LPD$V_BC,LPD$W_STS(R6),10$ ; If broadcast circuit,
	BBS	#ADJ$V_RUN,ADJ$B_STS(R7),10$ ; and if not in "run" state,
5$:	MOVL	#LEV$C_NO_EVT,R1	; Drop message - No more events
	CLRL	R0			; Indicate nothing happened
	RSB
10$:	;
	;   Did the operator change the adjacent node's address?
	;
	CMPW	ADJ$W_PNA(R7),LEV_W_PNA	  ; Is the address the same as it was?
	BNEQ	80$			  ; If NEQ then not the same
	;
	;   Determine if this is a Phase III or Phase IV routing message.
	;   Phase III routing messages are unsegmented, so we can copy
	;   the entire routing portion into the cost/hops buffer.  Phase IV
	;   routing messages are segmented, so we must run through each
	;   segment, copying the information into the right place.
	;
	MOVZWL	WQE$W_ADJ_INX(R5),R0	; Get the ADJ index
	MOVL	NET$AL_CH_VEC[R0],R0	; Point to cost/hops buffer
	BEQL	70$			; If none, then message error
	MOVZWL	WQE$L_PM2(R5),R9	; Get msg offset to routing info
	ADDL	R5,R9			; Convert to pointer
	MOVZWL	WQE$L_PM2+2(R5),R8	; Get number of bytes of rtginfo
	CMPB	PTYPE,#ADJ$C_PTY_PH3	; Is it Phase III message?
	BNEQ	50$			; If not, then Phase IV
	;
	;   If Phase III routing message, then copy the entire cost/hops
	;   portion into the cost/hops buffer for this circuit.
	;
	MOVL	R9,R3			; Set address of rtginfo
	ASHL	#-1,R8,R1		; Compute number of nodes
	MOVL	#1,R2			; Set starting node number
	BSBB	UPDATE_MATRIX		; Update the routing matrix
	BRB	90$
	;
	;   If Phase IV routing message, the run through the segments,
	;   copying each portion into the right place in the cost/hops buffer.
	;
50$:	SUBL	#4,R8			; Account for COUNT & STARTID
	BLEQ	70$			; Branch if packet format error
	MOVZWL	(R9)+,R1		; Get number of nodes in segment
	MOVZWL	(R9)+,R2		; Get starting node number
	MOVL	R9,R3			; Set address of rtginfo
	ADDL3	R1,R2,-(SP)		; Compute ending+1 node number
	CMPL	(SP)+,#NUM_NODES	; Larger than our buffer?
	BGTRU	70$			; If so, error in routing message
	ASHL	#1,R1,-(SP)		; Compute number of bytes of rtginfo
	ADDL	(SP),R9			; Skip past rtginfo
	SUBL	(SP)+,R8		; Account for cost/hops info
	BLSS	70$			; Branch if packet format error
	BSBB	UPDATE_MATRIX		; Update the routing matrix
	TSTL	R8			; Anything more?
	BGTR	50$			; If so, continue
90$:	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
	RSB


;
; Routing message format error
;
70$:	$LOG	TPL_LDF,TPL_PRSN_RUCS,,R5	; Log "checksum error"
	BRB	85$				; Log the event record
;
; Adjacent node address has changed - log event and bring line down
;
80$:	$LOG	TPL_LDO,TPL_PRSN_ADJC,,R5	; Assume address change
85$:	MOVL	#LEV$C_LOG_ADE,R1		; Signal adjacency down event
	MOVL	#1,R0				; Make state change
	RSB

	.SBTTL	UPDATE_MATRIX - Update the routing matrix
;-
; UPDATE_MATRIX - Update the routing matrix
;
; Inputs:
;
;	R0 = Base address of node column in routing matrix for the adjacency
;	R1 = Number of nodes (non-zero)
;	R2 = Starting node number
;	R3 = Address of cost/hops routing information
;	(R6 = LPD address, for journalling of routing changes)
;	(R7 = ADJ address, for journalling of routing changes)
;
; Outputs:
;
;	None
;
;	The RTG_CHG vector is updated to reflect modifications
;	to the "node column" of the routing matrix.
;
;	All registers are preserved.
;-
UPDATE_MATRIX:
	PUSHR	#^M<R0,R1,R2,R3,R4>	; Save registers
	MOVAW	(R0)[R2],R4		; Address of 1st node in matrix
	MOVL	NET$GL_PTR_VCB,R0	; Get RCB address
	TSTL	RCB$L_PTR_JNX(R0)	; Is journalling enabled?
	BNEQ	60$			; If so, use a slower loop
	;
	;   This loop is used when journalling is turned off, so that
	;   journalling doesn't slow down this loop when disabled.
	;
10$:	CMPW	(R3)+,(R4)+		; Same info as last message?
	BEQL	20$			; If so, no need to do anything
	MOVW	-2(R3),-2(R4)		; Store the changed cost/hops
	SETBIT	R2,RTG_CHG		; Update "node changes" vector
20$:	INCL	R2			; Increment node number
	SOBGTR	R1,10$			; Loop until all nodes done
	BRB	90$
	;
	;   This loop is used when journalling is turned on.  The idea
	;   is to log all changes in routing information, so that using
	;   the journal, we can trace the routing activity of a node.
	;
60$:	CMPW	(R3)+,(R4)+		; Same info as last message?
	BEQL	70$			; If so, no need to do anything
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,65$			; Skip if not enabled for some reason
	MOVB	#^X04,(R1)+		; Record type = routing change
	MOVB	LPD$B_PTH_INX(R6),(R1)+	; LPD index
	MOVW	ADJ$W_PNA(R7),(R1)+	; Neighbor node issuing rtg msg
	MOVW	R2,(R1)+		; Node number
	MOVW	-2(R4),(R1)+		; Old routing info
	MOVW	-2(R3),(R1)+		; New routing info
	JSB	@(SP)+			; Log the journal record
65$:	MOVW	-2(R3),-2(R4)		; Store the changed cost/hops
	SETBIT	R2,RTG_CHG		; Update "node changes" vector
70$:	INCL	R2			; Increment node number
	SOBGTR	R1,60$			; Loop until all nodes done
90$:	POPR	#^M<R0,R1,R2,R3,R4>	; Restore registers
	RSB

	.SBTTL	ACT_RCV_ART - Receive area routing message
;+
; ACT_RCV_ART - React to received area routing message
; ACT_RCV_ARTA - React to area routing message received while in acceptance algorithm
;
; Inputs:	R11 = CRI CNR address
;		R10 = CRI CNF address
;		R7 = ADJ address
;		R6 = LPD address
;		R5 = WQE address
;
; Outputs:	R0 = True if state change requested
;		R1 = Next event to be processed
;
;		R6 is the only register preserved.
;-
ACT_RCV_ART:				; React to rcv'd area routing message
	BSBB	PROC_ART		; Do common processing
	BLBC	R0,10$			; If LBC then something's wrong
	BSBW	REQUEST_UPDATE		; Request running of update algorithm
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
10$:	RSB				; Return state table control in R0/R1

ACT_RCV_ARTA:				; Receive routing message while running
					; the acceptance algorithm
	BSBB	PROC_ART		; Do common processing
	BLBC	R0,10$			; If LBC then something's wrong
	;
	;   Terminate the acceptance testing and generate a "circuit up"
	;   event.  This is necessary since we've just updated the matrix.
	;
	CLRB	LPD$B_TSTCNT(R6)	; Don't send any more test messages
	MOVL	#LEV$C_LIN_UP,R1	; Signal "circuit up"
10$:	RSB				; Return state table control in R0/R1

PROC_ART:				; Common Routing message processing
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,5$>,-	; never process rtg messages
		<ADJ$C_PTY_PH3N,5$>>
	;
	;   Is the adjacency in the RUN state?  If not, ignore the routing
	;   message, since it might have preceeded the necessary Router
	;   Hello messages (for broadcast circuits).
	;
	BBC	#LPD$V_BC,LPD$W_STS(R6),10$ ; If broadcast circuit,
	BBS	#ADJ$V_RUN,ADJ$B_STS(R7),10$ ; and if not in "run" state,
5$:	MOVL	#LEV$C_NO_EVT,R1	; No more events
	CLRL	R0			; Indicate nothing happened
	RSB
10$:	;
	;   Did the operator change the adjacent node's address?
	;
	CMPW	ADJ$W_PNA(R7),LEV_W_PNA	  ; Is the address the same as it was?
	BNEQ	80$			  ; If NEQ then not the same
	;
	;   Copy the routing information into the buffer associated with
	;   this routing adjacency.
	;
	MOVZWL	WQE$W_ADJ_INX(R5),R0	; Get the ADJ index
	MOVL	NET$AL_AREA_CH[R0],R0	; Point to cost/hops buffer
	BEQL	70$			; If none, then message error
	MOVZWL	WQE$L_PM2(R5),R9	; Get msg offset to routing info
	ADDL	R5,R9			; Convert to pointer
	MOVZWL	WQE$L_PM2+2(R5),R8	; Get number of bytes of rtginfo
50$:	SUBL	#4,R8			; Account for COUNT & STARTID
	BLEQ	70$			; Branch if packet format error
	MOVZWL	(R9)+,R1		; Get number of nodes in segment
	MOVZWL	(R9)+,R2		; Get starting node number
	ASHL	#1,R1,R1		; Compute number of bytes of rtginfo
	ASHL	#1,R2,R2		; Compute offset to node's cost/hops
	SUBL	R1,R8			; Account for cost/hops info
	BLSS	70$			; Branch if packet format error
	ADDL3	R1,R2,-(SP)		; Compute ending offset into buffer
	CMPL	(SP)+,#NUM_AREAS*2	; Greater than size of buffer?
	BGTRU	70$			; If so, error in routing message
	PUSHR	#^M<R0,R1,R4,R5>	; Save registers
	MOVC	R1,(R9),(R0)[R2]	; Copy into cost/hops buffer
	POPR	#^M<R0,R1,R4,R5>	; Restore registers
	ADDL	R1,R9			; Skip past rtginfo
	TSTL	R8			; Anything more?
	BGTR	50$			; If so, continue
90$:	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
	RSB


;
; Routing message format error
;
70$:	$LOG	TPL_LDF,TPL_PRSN_RUCS,,R5	; Log "checksum error"
	BRB	85$				; Log the event record
;
; Adjacent node address has changed - log event and bring line down
;
80$:	$LOG	TPL_LDO,TPL_PRSN_ADJC,,R5	; Assume address change
85$:	MOVL	#LEV$C_LOG_ADE,R1		; Signal adjacency down event
	MOVL	#1,R0				; Make state change
	RSB

	.SBTTL	REQUEST_UPDATE - Request update of routing database
;+
; REQUEST_UPDATE - Request running of the "update" algorithm
;
; This routine is called for all normal updates to the routing database.
; It prevents the update algorithm from being run too often, and hogging
; the machine, by using a supression timer.
;
; Inputs:
;
;	None
;
; Outputs:
;
;	None
;
;	R4-R6,R10-R11 are preserved.
;-
ACT_REQ_UPDATE:				; Update database based on CRI change
	BSBB	REQUEST_UPDATE		; Request update
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
	RSB

REQUEST_UPDATE:				; Request running of update algorithm
	;
	;   If the suppression timer is not already ticking exit and wait for 
	;   it to fire.  Otherwise reset it and run the update algorithm.
	;
	SETBIT	#RTG_V_UPD,RTGFLG	; Remember request to update
	BBSS	#RTG_V_RUS,RTGFLG,20$	; Exit if supression timer is ticking
  	MOVZWL	#<<WQE$C_QUAL_RTG>@8>!-	; Setup suppression timer i.d.
		NET$C_TID_RUS,R1	;
	MOVAB	B^TIMER_RUS,R2		; Setup action routine
	PUSHR	#^M<R7,R8,R9,R10,R11>	; Save registers
	MOVL	NET$GL_CNR_LNI,R11	; Set CNR address
	MOVL	NET$GL_PTR_LNI,R10	; Set local CNF address
	$GETFLD	lni,l,rsi		; Get routing suppression timer value
	MOVL	R8,R3			; Move to another register
	POPR	#^M<R7,R8,R9,R10,R11>	; Restore registers
	BLBS	R0,10$			; If not set, provide default
	MOVL	#1,R3
10$:	EMUL	#10*1000*1000,R3,#0,R3	; Convert to standard VMS time
	BSBW	WQE$RESET_TIM		; Reset the routing suppression timer
	;
	;   Run the update algorithm on the data base.
	;
	CLRBIT	#RTG_V_UPD,RTGFLG	; Indicate update request satisfied
	BSBB	UPDATE			; Update the routing data base
20$:	RSB

TIMER_RUS:				; Update suppression timer has fired
	BSBW	KILL_WQE		; Deallocate the timer block
	CLRBIT	#RTG_V_RUS,RTGFLG	; Indicate timer no longer ticking
	BBC	#RTG_V_UPD,RTGFLG,10$	; If BS then update has been requested
	BSBB	REQUEST_UPDATE		; Perform the update & reset timer
10$:	RSB

	.SBTTL	UPDATE - Update database and neighbors
;+
; UPDATE - Update the routing data base
;
; Run the routing algorithm, update the routing data base, and
; schedule routing message transmission to all routing nodes.
;
; INPUTS:	None
;
; OUTPUTS:	None
;
;		R4-R6,R10-R11 are preserved.
;-
UPDATE:					; Update the routing data base
	PUSHR	#^M<R4,R5,R6,R10,R11>	; Save registers
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	$DISPATCH RCB$B_ETY(R4),TYPE=B,<- ; Do the full decision if we are:
		<ADJ$C_PTY_AREA,5$>,-	; A level 2 router
		<ADJ$C_PTY_PH4,5$>,-	; A level 1 router
		<ADJ$C_PTY_PH3,5$>>	; A Phase III router
	;
	;   If we are an endnode, then run a much shorter and simpler
	;   decision algorithm.
	;
	BSBW	ENDNODE_DECISION	; Run endnode algorithm
	BRW	90$			; exit

5$:	JSB	NET$GET_RTG3		; Get routing info
	BLBC	R0,9$			; Branch if error
	TSTW	RCB$W_MAX_RTG(R4)	; Any routing adjacencies?
	BNEQ	10$			; Continue if so
9$:	BRW	90$			; Nothing to do
10$:	;
	;   If we are a level 2 router, then update the area database
	;
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	CMPB	RCB$B_ETY(R4),#ADJ$C_PTY_AREA ; Are we level 2 router?
	BNEQ	20$			; Skip if not
	MOVL	NET$GL_CNR_LNI,R11	; Get LNI root
	MOVL	NET$GL_PTR_LNI,R10	; Get LNI CNF
	$GETFLD	lni,l,amh		; Fetch max hops field
	BLBC	R0,20$			; Br on error
	MOVZBL	R8,MAX_HOPS		; Store it
	$GETFLD	lni,l,amc		; Fetch max cost field
	BLBC	R0,20$			; Br on error
	MOVZWL	R8,MAX_COST		; Store it
	MOVZBL	RCB$B_MAX_AREA(R4),R8	; Get max area address
	INCL	R8			; Get number of area addresses counting
					; address #0
	MOVAW	@RCB$L_PTR_AOA(R4)[R8],R10 ; Point past last OA entry
	MOVAW	NET$AW_AREA_C_H[R8],R11	; Point past last Cost/Hops entry
	BSBW	AREA_DECISION		; Update the area data base
20$:	;
	;   Call the DECISION algorithm to update the level 1 forwarding database
	;
	MOVL	NET$GL_CNR_LNI,R11	; Get LNI root
	MOVL	NET$GL_PTR_LNI,R10	; Get LNI CNF
	$GETFLD	lni,l,mho		; Fetch max hops field
	BLBC	R0,50$			; Br on error
	MOVZBL	R8,MAX_HOPS		; Store it
	$GETFLD	lni,l,mco		; Fetch max cost field
	BLBC	R0,50$			; Br on error
	MOVZWL	R8,MAX_COST		; Store it
	MOVZWL	RCB$W_MAX_ADDR(R4),R8	; Get max node address
	INCL	R8			; Get number of node addresses counting
					; address #0
	MOVAW	@RCB$L_PTR_OA(R4)[R8],R10 ; Point past last OA entry
	MOVAW	NET$AW_MIN_C_H[R8],R11  ; Point past last Cost/Hops entry
	BSBB	DECISION		; Update the data base
	;
	;   Send routing messages to our neighbors, if the database changed
	;
50$:	BSBW	UPD_NEIGHBORS
90$:	POPR	#^M<R4,R5,R6,R10,R11>	; Restore registers
	RSB

	.SBTTL	DECISION - Update forwarding database
;+
; DECISION - Update the routing and forwarding databases.
;
; Inputs:
;
;	R11 = Address of last entry+1 of min. cost/hops buffer
;	R10 = Address of last entry+1 of OA vector
;	R8 = Ending address corresponding to last entry in vectors
;	MAX_COST = Maximum cost value allowed for routing database
;	MAX_HOPS = Maximum hops value allowed for routing database
;	RTG_CHG = Vector which indicates which nodes must be processed.
;
; OUTPUTS:	None
;
;		All registers are destroyed.
;-
DECISION:
	;
	;   See if we need to do anything at all.
	;
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	MOVZWL	RCB$W_MAX_ADDR(R4),R7	; Get max address
	ADDL	#7,R7			; Allow for roundoff
	ASHL	#-3,R7,R7		; Divide by bits/byte
	CMPC5	R7,RTG_CHG,-		; Is the entire RTG_CHG vector 0?
		#0,#0,(SP)
	BNEQ	5$			; If at least 1 bit set, do it
	RSB				; Otherwise, exit now
5$:	;
	;   Record a journal record marking when we have started the
	;   routing algorithms.
	;
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,8$			; Skip if journalling not enabled
	MOVB	#^X02,(R1)+		; Record type = Starting algorithm
	CLRB	(R1)+			; spare byte
	MOVC5	R7,RTG_CHG,#0,#64-8-2,(R1) ; Journal the routing bitvector
	MOVL	R3,R1			; Update pointer past record
	JSB	@(SP)+			; Log the journal record
8$:	;
	;   Force the cost/hops for node #0 to always be re-evaluated
	;   each time, because of the code at the bottom of the loop
	;   which resets the "nearest level 2 router" based on the
	;   adjacency for node #0.
	;
	SETBIT	#0,RTG_CHG		; Always re-evaluate node #0
	;
	;   Init registers, and start the loop
	;
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	BRW	100$			; Advance to the end of the loop
	;
	;   See if this node needs to be looked at.  If we haven't received
	;   a routing message from any of our neighbors indicating that the
	;   node cost/hops has changed since last time, then skip the node.
	;
10$:	BBSC	R8,RTG_CHG,15$		; Lookup node if necessary
	SUBL	#2,R10			; Skip past OA entry for node
	SUBL	#2,R11			; Skip past min cost/hops for node
	BRW	100$			; Else, skip the node entirely
15$:	;
	;   Determine least cost path to this node
	;
	BSBW	FIND_PATH_TO_NODE	; Find hops, costs, and adjacency
	;
	;   If the cost or hops to this node exceeds our maximums,
	;   then declare the node unreachable.
	;
	CMPB	R1,MAX_HOPS		; Is the node within range?
	BGTRU	30$			; If GTRU then no
	CMPW	R2,MAX_COST		; Is the node within range?
	BLEQU	40$			; If LEQU then yes
30$:	CLRL	R0			; Node is unreachable
40$:	;
	;   Build the packed cost/hops field
	;
	ASSUME	TR3V_RT_COST  EQ  0
	INSV	R1,#TR3V_RT_HOPS,-
		#TR3S_RT_HOPS,R2	; Merge hops/cost
	ASSUME	TR3S_RT_HOPS+TR3S_RT_COST EQ 15
	BICW	#^X<8000>,R2		; The high bit must be zero (Transport
					; architectural requirement)
	;
	;   If the node is now unreachable, then force the cost and hops
	;   to infinity, so that our neighbors realize the node is down now
	;   (they might have a higher maxcost, and wouldn't realize the
	;   node is unreachable until much later).
	;
	TSTL	R0			; Is the node reachable?
	BNEQ	55$			; If not,
	MOVZWL	#^X<7FFF>,R2		; then make cost/hops infinite
55$:	;
	;   Send routing msg only if  MINCOST or MINHOPS have changed.  If
	;   there has been a change in the node's reachability then record
	;   this fact so that it can be sent to the event logger.
	;
	ASSUME	TR3S_RT_HOPS+TR3S_RT_COST EQ 15
	BICW	#^X<8000>,-(R11)	; Ignore high bit
	CMPW	R2,(R11)		; Was there a hops or cost change ?
	BEQL	90$			; If EQL then no
	CMPW	R2,#^X<7FFF>		; Is node currently unreachable?
	BGEQU	57$			; If GEQU yes, reachability change
	CMPW	(R11),#^X<7FFF>		; Was node unreachable before?
	BLSSU	58$			; If LSSU no, no reachability change
57$:	SETBIT	R8,REACH_EVT		; Indicate change in reachability status
58$:	MOVW	R2,(R11)		; Update the vector
	ASHL	#-LPD$C_SRM_SHFT,R8,R1	; Compute SRM bit for this node
	MOVZBL	RCB$B_MAX_LPD(R4),R2	; Get number of circuits
60$:	MOVL	@RCB$L_PTR_LPD(R4)[R2],R3 ; Get LPD address
	BGEQ	65$			; Branch if slot not valid
	BBC	#LPD$V_RUN,LPD$W_STS(R3),65$ ; Branch if circuit not up
					; (skip ADJ$V_RTG check to save time)
	SETBIT	R1,LPD$G_SRM(R3)	; Set SRM flag
65$:	SOBGTR	R2,60$			; Loop through all circuits
	;
	;   If the node is a direct partner, and is a Phase II adjacency,
	;   then do not include the node in routing messages, to enforce
	;   Phase II non-routing rules, but keep the OA vector pointing
	;   to the output adjacency for the Phase II node.
	;
	TSTL	R0			; Is node directly adjacent?
	BEQL	70$			; If not, skip Phase II check
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R1 ; Get output ADJ address
 	CMPB	ADJ$B_PTYPE(R1),#ADJ$C_PTY_PH2 ; Phase II direct adjacency?
	BNEQ	70$			; Branch if not
	MOVW	#^X<7FFF>,(R11)		; If so, don't include in routing msgs
70$:	;
	;   Update the OA (output adjacency) vector.
	;
90$:	MOVW	R0,-(R10)		; Update output adjacency to node
100$:	SOBGEQ	R8,102$			; Loop for each node address
	BRB	105$			; Loop finished - go on
102$:	BRW	10$			; Branch helper - continue looping
105$:	;
	;   For entry #0 (nearest level 2 router), we must decide if we
	;   are the nearest level 2 router.  If so, force node #0 to a cost
	;   and hops of 0.  Else, leave the value as computed from neighbors.
	;
	;   If no other areas are reachable except our own, then it may mean
	;   we are an isolated area router.  If this is the case, then allow
	;   routing to continue by simply pretending we are a level 1 router,
	;   and propagate the "nearest level 2 router" as determined by our
	;   neighbors, and never use the AOA vector for forwarding (since we
	;   may not really know the state of the level 2 network).
	;
	CLRBIT	#RCB$V_LVL2,-		; Assume we cannot do level 2 routing
		RCB$B_STATUS(R4)
	CMPB	RCB$B_ETY(R4),#ADJ$C_PTY_AREA ; Are we an area router?
	BNEQ	120$			; Skip if not
	MOVZBL	RCB$B_MAX_AREA(R4),R8	; Get the maximum area number
110$:	TSTW	@RCB$L_PTR_AOA(R4)[R8]	; Is any other area reachable?
	BEQL	115$			; If not, continue searching
	CMPB	R8,RCB$B_HOMEAREA(R4)	; Our own area?
	BEQL	115$			; Skip our own area - it doesn't count
	MOVW	#LPD$C_LOC_INX,(R10)	; If so, mark "nearest" as local ADJ
	CLRW	(R11)			; and send "nearest = 0 cost/hops"
	SETBIT	#RCB$V_LVL2,-		; Tell Transport it can use the AOA
		RCB$B_STATUS(R4)	; vector - we are not isolated.
115$:	SOBGTR	R8,110$			; Loop thru all areas
120$:	;
	;   Take the value for entry #0 (nearest level 2 router) and store
	;   it in a special place in the RCB so that TRANSPORT can get at
	;   it easily.  In addition, set OA(0) to point to ourselves, since
	;   the internal convention is that node #0 refers to ourselves.
	;
	MOVW	(R10),RCB$W_LVL2(R4)	; Store path to nearest level 2 router
	MOVW	#LPD$C_LOC_INX,(R10)	; Set "local" adjacency for node 0
					; (node 0 is the always the local node)
	;
	;   Log an event for each node whose reachability status has changed.
	;
	MOVZWL	#NUM_NODES-1,R8		; Setup max node address
200$:	BBCC	R8,REACH_EVT,210$	; If BS then reachability change
	PUSHL	R8			; Save node address
	MOVAB	NET$AB_EVT_WQE,R5	; Point to common event WQE
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB
	MOVL	NET$GL_CNR_NDI,R11	; Get the NDI root block
	BSBW	NET$LOCATE_NDI		; Get node's CNF block
	MOVW	R8,WQE$W_REQIDT(R5)	; Setup the node address
	INSV	RCB$B_HOMEAREA(R4),-	; using the current area
		#TR4$V_ADDR_AREA,-
		#TR4$S_ADDR_AREA,WQE$W_REQIDT(R5)
	MOVB	#EVC$C_TPL_PSTS_RCH,-	; Assume node is now reachable
		WQE$B_EVL_DT1(R5)	;
	TSTW	@RCB$L_PTR_OA(R4)[R8]	; Is node now reachable?
	BNEQ	205$			; If NEQ then yes
	MOVB	#EVC$C_TPL_PSTS_URC,-	; Signal "unreachable"
		WQE$B_EVL_DT1(R5)	;
205$:	MOVW	#EVC$C_TPL_RCH,-	; Setup event logging code
		WQE$W_EVL_CODE(R5)	;
	BSBW	NET$EVT_INTRAW		; Log the event
	POPL	R8			; Restore node address
210$:	SOBGTR	R8,200$			; Loop for each node
	;
	;   Record a journal record marking when we have finished the
	;   routing algorithms.
	;
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,300$			; Skip if journalling not enabled
	MOVB	#^X03,(R1)+		; Record type = Ending algorithm
	JSB	@(SP)+			; Log the journal record
300$:	RSB				; Exit

	.SBTTL	FIND_PATH_TO_NODE - Find least cost path to node
;+
; FIND_PATH_TO_NODE - Find least cost path to a node in our area
;
; Inputs:	R8 = Node address
;		R4 = RCB address
;
; Outputs:	R1 = Number of hops to node
;		R2 = Cost to node
;		R0 = New ADJ index of path to node
;
;		R4 is preserved.
;-
FIND_PATH_TO_NODE:
	PUSHR	#^M<R10>		; Save registers
	CMPZV	#TR4$V_ADDR_DEST,-	; Is this the local node?
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R8
	BEQL	3$			; Branch if so
	TSTW	RCB$W_ALIAS(R4)		; Is there an alias?
	BEQL	5$			; If so,
	CMPZV	#TR4$V_ADDR_DEST,-	; Is this the alias node number?
		#TR4$S_ADDR_DEST,RCB$W_ALIAS(R4),R8
	BNEQ	5$			; If not, proceed
3$:	MOVZBL	#LPD$C_LOC_INX,R0	; Setup index for 'local' adjacency
	CLRQ	R1			; Zero cost, hops
	BRW	100$			; and exit with success

5$:	MOVL	#1,R7			; Init adjacency index
	CLRL	R0			; Assume unreachable
	MNEGL	#1,R1			; Init min hops value to infinity
	MNEGL	#1,R2			; Init min cost value to infinity
7$:	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R9 ; Get ADJ address
	BBC	#ADJ$V_RUN,ADJ$B_STS(R9),10$ ; Skip check if PNA not valid and
					; assume cost/hops applies to our area
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area that cost/hops applies to
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R9),R9
	BEQL	10$			; If area = 0, assume our area
	CMPB	R9,RCB$B_HOMEAREA(R4)	; Is it for our area?
	BNEQ	20$			; If not, skip this one
10$:	MOVL	NET$AL_CH_VEC[R7],R9	; Point to cost/hops buffer
	BEQL	20$			; Skip if none for this circuit
	MOVL	R7,R10			; Remember ADJ index for this path
	MOVAW	(R9)[R8],R9		; Point to entry for this node
	;
	;   Get the cost/hops for this node over this adjacency,
	;   and increase it by the hop for ourself.  Also compute
	;   the new cost for this path.
	;
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R6 ; Get address of ADJ block
	MOVZBL	ADJ$B_LPD_INX(R6),R6	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R4)[R6],R6 ; Get address of LPD
	MOVZBL	LPD$B_COST(R6),R6	; Get cost for this circuit

	ASSUME	TR3V_RT_COST  EQ  0
	ASSUME	TR3S_RT_COST  EQ 10

	BICW3	#^X<FC00>,(R9),R3	; Get the cost value
	ADDW	R6,R3			; Add in the circuit's cost
	BVS	20$			; If VS then cost is infinite
	CMPW	#^X<2FF>,R3		; Has cost overflowed allowed limit?
	BLSSU	20$			; If LSSU then yes, it's not a minimum
	;
	;   For a broadcast circuit, the cost/hops buffer contains
	;   the state of all endnodes on that broadcast circuit.
	;   So, if the node is "reachable" over the broadcast circuit,
	;   then we have found the shortest path (by definition),
	;   and return success immediately.
	;
	CMPB	R7,RCB$B_MAX_LPD(R4)	; Is this a main LPD adjacency?
	BGTRU	15$			; Branch if not
	MOVL	@RCB$L_PTR_LPD(R4)[R7],R6 ; Get LPD address
	BBC	#LPD$V_BC,LPD$W_STS(R6),15$ ; Branch if not broadcast circuit
	BSBB	FIND_ENDNODE_BEA	; Put node's BEA index in R10
	BEQL	20$			; Branch if not found (& unlikely)
15$:	;
	;   Check to see if this path is "less cost" than the previous
	;   minimum cost.  If so, remember this path as the best one.
	;   Use the node address of the adjacent node as a tiebreaker.
	;
	CMPW	R3,R2			; Is cost value a new minumum ?
	BGTRU	20$			; If GEQU then no
	BLSSU	18$			; If LSSU then yes
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R6 ; Get address of new ADJ
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R5 ; Get address of old ADJ
	CMPW	ADJ$W_PNA(R6),ADJ$W_PNA(R5) ; Highest adj. node address
	BLEQU	20$			; is the tiebreaker for equal costs
18$:	EXTZV	#TR3V_RT_HOPS,-
		#TR3S_RT_HOPS,(R9),R5	; Get the hops value	
	INCB	R5			; Add in the hop to the adjacent node
	CMPB	R5,#^X<1F>		; Has the max hops overflowed ?
	BGTRU	20$			; If LSSU then yes, it's not a minimum
	MOVW	R3,R2			; Save new minimum cost to node
	MOVB	R5,R1			; Save hops to node
	MOVL	R10,R0			; Save output ADJ index for path
20$:	MOVZWL	RCB$W_MAX_RTG(R4),R3	; Get number of routing adjacencies
	AOBLEQ	R3,R7,30$		; Loop until done
	BRB	100$			; Exit with success
30$:	BRW	7$			; Continue looping
100$:	POPR	#^M<R10>		; Restore registers
	RSB

;
; Find BEA adjacency index to an endnode.
;

FIND_ENDNODE_BEA:
	MOVZWL	RCB$W_MAX_RTG(R4),R10	; Get starting BEA index
	BRB	8$			; Start at NBRA+1
5$:	MOVL	@RCB$L_PTR_ADJ(R4)[R10],R6 ; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R6),8$ ; Skip if not active
	EXTZV	#TR4$V_ADDR_AREA,-	; Get partner's area number
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R6),R5
	BEQL	6$			; If area = 0, assume our area
	CMPB	R5,RCB$B_HOMEAREA(R4)	; Our area?
	BNEQ	8$			; If not, skip this adjacency
6$:	CMPZV	#TR4$V_ADDR_DEST,-	; Does this BEA correspond to the node?
		#TR4$S_ADDR_DEST,ADJ$W_PNA(R6),R8
	BEQL	15$			; If so, exit with R10 = BEA index
8$:	MOVZWL	RCB$W_MAX_ADJ(R4),R6	; Get index of last BEA
	AOBLEQ	R6,R10,5$		; Loop thru all BEAs
	CLRL	R10			; If BEA not found, skip this path
					; (& this should not happen)
15$:	TSTL	R10			; Return with PSL set
	RSB

	.SBTTL	AREA_DECISION - Update area forwarding database
;+
; AREA_DECISION - Update the area routing and forwarding databases.
;
; Inputs:
;
;	R11 = Address of last entry+1 of AOA vector
;	R10 = Address of last entry+1 of min. cost/hops buffer
;	R8 = Ending address corresponding to last entry in vectors
;	MAX_COST = Maximum cost value allowed for routing database
;	MAX_HOPS = Maximum hops value allowed for routing database
;
; OUTPUTS:	None
;
;		All registers are destroyed.
;-
AREA_DECISION:
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB address
	BRW	100$			; Advance to the end of the loop
	;
	;   Determine least cost path to this node
	;
10$:	BSBW	FIND_PATH_TO_AREA	; Find hops, costs, and adjacency
	;
	;   If the cost or hops to this node exceeds our maximums,
	;   then declare the node unreachable.
	;
	CMPB	R1,MAX_HOPS		; Is the node within range?
	BGTRU	30$			; If GTRU then no
	CMPW	R2,MAX_COST		; Is the node within range?
	BLEQU	40$			; If LEQU then yes
30$:	CLRL	R0			; Node is unreachable
40$:	;
	;   Build the packed cost/hops field
	;
	ASSUME	TR3V_RT_COST  EQ  0
	INSV	R1,#TR3V_RT_HOPS,-
		#TR3S_RT_HOPS,R2	; Merge hops/cost
	ASSUME	TR3S_RT_HOPS+TR3S_RT_COST EQ 15
	BICW	#^X<8000>,R2		; The high bit must be zero (Transport
					; architectural requirement)
	;
	;   If the area is now unreachable, then force the cost and hops
	;   to infinity, so that our neighbors realize the area is down now
	;   (they might have a higher maxcost, and wouldn't realize the
	;   area is unreachable until much later).
	;
	TSTL	R0			; Is the node reachable?
	BNEQ	55$			; If not,
	MOVZWL	#^X<7FFF>,R2		; then make cost/hops infinite
55$:	;
	;   Send routing msg only if  MINCOST or MINHOPS have changed.  If
	;   there has been a change in the node's reachability then record
	;   this fact so that it can be sent to the event logger.
	;
	ASSUME	TR3S_RT_HOPS+TR3S_RT_COST EQ 15
	BICW	#^X<8000>,-(R11)	; Ignore high bit
	CMPW	R2,(R11)		; Was there a hops or cost change ?
	BEQL	90$			; If EQL then no
	CMPW	R2,#^X<7FFF>		; Is node currently unreachable?
	BGEQU	57$			; If GEQU yes, reachability change
	CMPW	(R11),#^X<7FFF>		; Was node unreachable before?
	BLSSU	58$			; If LSSU no, no reachability change
57$:	SETBIT	R8,REACH_EVT		; Indicate change in reachability status
58$:	MOVW	R2,(R11)		; Update the vector
	ASHL	#-LPD$C_ASRM_SHFT,R8,R1	; Compute SRM bit for this node
	MOVZBL	RCB$B_MAX_LPD(R4),R2	; Get number of circuits
60$:	MOVL	@RCB$L_PTR_LPD(R4)[R2],R3 ; Get LPD address
	BGEQ	65$			; Branch if slot not valid
	BBC	#LPD$V_RUN,LPD$W_STS(R3),65$ ; Branch if circuit not up
					; (skip ADJ$V_RTG check to save time)
	SETBIT	R1,LPD$G_ASRM(R3)	; Set SRM flag
65$:	SOBGTR	R2,60$			; Loop through all circuits
	;
	;   Update the AOA (area output adjacency) vector.
	;
90$:	MOVW	R0,-(R10)		; Update output adjacency to node
100$:	SOBGTR	R8,10$			; Loop for each node address
	MOVW	#LPD$C_LOC_INX,-(R10)	; Use "local" adjacency for node 0
					; (node 0 is the always the local node)
	CLRW	-(R11)			; Use 0 cost/hops for the local area

	;
	;   Log an event for each node whose reachability status has changed.
	;
	MOVZWL	#NUM_AREAS-1,R8		; Setup max area address
200$:	BBCC	R8,REACH_EVT,210$	; If BS then reachability change
	PUSHL	R8			; Save node address
	MOVAB	NET$AB_EVT_WQE,R5	; Point to common event WQE
	MOVL	NET$GL_PTR_VCB,R4	; Get RCB
	MOVW	R8,WQE$W_REQIDT(R5)	; Setup the area address
	MOVB	#EVC$C_TPL_PSTS_RCH,-	; Assume node is now reachable
		WQE$B_EVL_DT1(R5)	;
	TSTW	@RCB$L_PTR_AOA(R4)[R8]	; Is node now reachable?
	BNEQ	205$			; If NEQ then yes
	MOVB	#EVC$C_TPL_PSTS_URC,-	; Signal "unreachable"
		WQE$B_EVL_DT1(R5)	;
205$:	MOVW	#EVC$C_TPL_ACH,-	; Setup "area reachability change"
		WQE$W_EVL_CODE(R5)	;
	BSBW	NET$EVT_INTRAW		; Log the event
	POPL	R8			; Restore node address
210$:	SOBGTR	R8,200$			; Loop for each node

	RSB				; Exit

	.SBTTL	FIND_PATH_TO_AREA - Find least cost path to area
;+
; FIND_PATH_TO_AREA - Find least cost path to area
;
; Inputs:	R8 = Area address
;		R4 = RCB address
;
; Outputs:	R1 = Number of hops to area
;		R2 = Cost to area
;		R0 = New ADJ index of path to area
;
;		R4 is preserved.
;-
FIND_PATH_TO_AREA:
	PUSHR	#^M<R10>		; Save registers
	CMPB	R8,RCB$B_HOMEAREA(R4)	; Is this the local area ?
	BNEQ	5$			; If so,
	MOVZBL	#LPD$C_LOC_INX,R0	; Setup index for 'local' adjacency
	CLRQ	R1			; Zero cost, hops
	BRW	100$			; and exit

5$:	MOVL	#1,R7			; Init adjacency index
	CLRL	R0			; Assume unreachable
	MNEGL	#1,R1			; Init min hops value to infinity
	MNEGL	#1,R2			; Init min cost value to infinity
7$:	MOVL	NET$AL_AREA_CH[R7],R9	; Point to cost/hops buffer
	BEQL	20$			; Skip if none for this circuit
	MOVL	R7,R10			; Remember ADJ index for this path
	MOVAW	(R9)[R8],R9		; Point to entry for this area
	;
	;   Get the cost/hops for this area over this adjacency,
	;   and increase it by the hop for ourself.  Also compute
	;   the new cost for this path.
	;
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R6 ; Get address of ADJ block
	MOVZBL	ADJ$B_LPD_INX(R6),R6	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R4)[R6],R6 ; Get address of LPD
	MOVZBL	LPD$B_COST(R6),R6	; Get cost for this circuit

	ASSUME	TR3V_RT_COST  EQ  0
	ASSUME	TR3S_RT_COST  EQ 10

	BICW3	#^X<FC00>,(R9),R3	; Get the cost value
	ADDW	R6,R3			; Add in the circuit's cost
	BVS	20$			; If VS then cost is infinite
	CMPW	#^X<2FF>,R3		; Has cost overflowed allowed limit?
	BLSSU	20$			; If LSSU then yes, it's not a minimum
	;
	;   For a broadcast circuit, the cost/hops buffer contains
	;   the state of all endnodes on that broadcast circuit.
	;   So, if the area is "reachable" over the broadcast circuit,
	;   then we have found the shortest path (by definition),
	;   and return success immediately.
	;
	CMPB	R7,RCB$B_MAX_LPD(R4)	; Is this a main LPD adjacency?
	BGTRU	15$			; Branch if not
	MOVL	@RCB$L_PTR_LPD(R4)[R7],R6 ; Get LPD address
	BBC	#LPD$V_BC,LPD$W_STS(R6),15$ ; Branch if not broadcast circuit
	BSBW	FIND_ENDNODE_BEA	; Put node's BEA index in R10
	BEQL	20$			; Branch if not found (&& unlikely)
15$:	;
	;   Check to see if this path is "less cost" than the previous
	;   minimum cost.  If so, remember this path as the best one.
	;   Use the node address of the adjacent node as a tiebreaker.
	;
	CMPW	R3,R2			; Is cost value a new minumum ?
	BGTRU	20$			; If GEQU then no
	BLSSU	18$			; If LSSU then yes
	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R6 ; Get address of new ADJ
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R5 ; Get address of old ADJ
	CMPW	ADJ$W_PNA(R6),ADJ$W_PNA(R5) ; Highest adj. node address
	BLEQU	20$			; is the tiebreaker for equal costs
18$:	EXTZV	#TR3V_RT_HOPS,-
		#TR3S_RT_HOPS,(R9),R5	; Get the hops value	
	INCB	R5			; Add in the hop to the adjacent node
	CMPB	R5,#^X<1F>		; Has the max hops overflowed ?
	BGTRU	20$			; If LSSU then yes, it's not a minimum
	MOVW	R3,R2			; Save new minimum cost to area
	MOVB	R5,R1			; Save hops to area
	MOVL	R10,R0			; Save output ADJ index for path
20$:	MOVZWL	RCB$W_MAX_RTG(R4),R3	; Get number of routing adjacencies
	AOBLEQ	R3,R7,7$		; Loop until done
100$:	POPR	#^M<R10>		; Restore registers
	RSB

	.SBTTL	UPD_NEIGHBORS - Schedule routing messages
;+
; UPD_NEIGHBORS - Schedule routing messages for neighboring nodes
;
; Schedule routing message transmission on all routing and broadcast LPD's.
;
; Inputs:	None
;
; OUTPUTS:	None
;
;		R0-R2 are destroyed.
;-
UPD_NEIGHBORS:
	PUSHR	#^M<R4,R6,R7,R8>		; Save registers
	MOVL	NET$GL_PTR_VCB,R4		; Get RCB address
	$DISPATCH RCB$B_ETY(R4),TYPE=B,<-	; If we are an endnode,
		<ADJ$C_PTY_PH4N,200$>,-		; never send rtg messages
		<ADJ$C_PTY_PH3N,200$>>
	JSB	NET$GET_RTG3			; Get routing info
	BLBC	R0,9$				; Branch if error
	MOVZBL	RCB$B_MAX_LPD(R4),R8		; Get number of circuits
	BNEQ	110$				; If nonzero, then go ahead
9$:	BRW	200$				; Skip entire thing
	;
	;   Schedule routing message transmission on all routing LPDs
	;
110$:	MOVL	@RCB$L_PTR_LPD(R4)[R8],R6	; Get address of LPD
	BGEQ	113$				; Branch if slot not valid
	BBC	#LPD$V_RUN,LPD$W_STS(R6),113$	; Br if LPD's circuit inactive
	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7	; Get address of ADJ block
	BBS	#LPD$V_BC,LPD$W_STS(R6),115$	; If broadcast circuit
	BBS	#ADJ$V_RTG,ADJ$B_STS(R7),115$	; or if routing node, go ahead
113$:	BRW	130$				; Else, skip this LPD entirely
	;
	;   Send area routing messages to adjacent area routers
	;
	ASSUME	LPD$C_ASRM_SIZE EQ 1		; && fix this
115$:	CMPB	RCB$B_ETY(R4),#ADJ$C_PTY_AREA	; Are we an area router?
	BNEQ	117$				; If not, skip this
	BBS	#LPD$V_BC,LPD$W_STS(R6),116$	; Skip check if broadcast circuit
	CMPB	ADJ$B_PTYPE(R7),#ADJ$C_PTY_AREA	; Is the neighbor an area rtr?
	BNEQ	117$				; If not, skip it
116$:	TSTL	LPD$G_ASRM(R6)			; Any area stuff to send?
	BEQL	117$				; Branch if not
	BBSS	#LPD$V_XMT_ART,-		; Flag need to send area rtg msg
		LPD$B_XMTFLG(R6),118$		; and defer if already in progress
	MOVL	LPD$G_ASRM(R6),LPD$G_XMT_ASRM(R6) ; Copy SRM flags for transmission
	CLRL	LPD$G_ASRM(R6)			; and clear primary flags
	INCB	LPD$B_ASRM_POS(R6)		; Make sure we don't start at the
						; same place in the bitmask each time
						; (to prevent segment loss repetition)
	MOVB	#LPD$C_ASRM_SIZE,-		; Set number of bits to check
		LPD$B_ASRM_LEFT(R6)
	MOVL	#LEV$C_NO_EVT,R0		; Setup event
	BSBW	SET_DLL_EVT			; Schedule LPD activity
	BRB	118$
117$:	CLRBIT	#LPD$V_XMT_ART,LPD$B_XMTFLG(R6)	; Do not send level 2 msgs
	;
	;   Send level 1 routing messages to adjacent level 1 routers
	;
118$:	BBS	#LPD$V_BC,LPD$W_STS(R6),119$	; Skip check if broadcast circuit
	EXTZV	#TR4$V_ADDR_AREA,-		; Get area of partner node
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R7),R1
	BEQL	119$				; If area = 0, assume our area
	CMPB	R1,RCB$B_HOMEAREA(R4)		; In our area?
	BNEQ	120$				; If not, don't send level 1 msg
119$:	ASSUME	LPD$C_SRM_SIZE EQ 32
	TSTL	LPD$G_SRM(R6)			; Anything to send?
	BEQL	120$				; Branch if not
	BBSS	#LPD$V_XMT_RT,-			; Flag need to send routing msg
		     LPD$B_XMTFLG(R6),130$	; and defer if already in progress
	MOVL	LPD$G_SRM(R6),LPD$G_XMT_SRM(R6)	; Copy SRM flags for transmission
	CLRL	LPD$G_SRM(R6)			; and clear primary flags
	INCB	LPD$B_SRM_POS(R6)		; Make sure we don't start at the
						; same place in the bitmask each time
						; (to prevent segment loss repetition)
	MOVB	#LPD$C_SRM_SIZE,-		; Set number of bits to check
		LPD$B_SRM_LEFT(R6)
	MOVL	#LEV$C_NO_EVT,R0		; Setup event
	BSBW	SET_DLL_EVT			; Schedule LPD activity
	BSBB	START_XRT			; Reset routing update timer
	BRB	130$				; Continue
120$:	CLRBIT	LPD$V_XMT_RT,LPD$B_XMTFLG(R6)	; No need for routing msg

130$:	SOBGTR	R8,140$				; Loop for all LPDs
	BRB	200$				; Exit when loop completes
140$:	BRW	110$				; Continue looping

200$:	POPR	#^M<R4,R6,R7,R8>		; Restore registers
	RSB

	.SBTTL	TIMER_XRT - Automatic routing update timer
;+
; TIMER_XRT - Routing update timer has expired
;
; Inputs:	R5 = WQE address
;
; Outputs:	None
;
;		The WQE is deallocated.
;-
TIMER_XRT:				; Entered when the routing timer fires
	MOVZWL	WQE$W_REQIDT(R5),R8	; Get LPD index
	BSBW	KILL_WQE		; Deallocate the timer block
	BSBW	NET$FIND_LPD		; Locate LPD
	BLBC	R0,90$			; If not found, just go away
	;
	;   Set all bits in the SRM bitmask for this circuit, so that
	;   when it comes time to update the neighbor, a complete update
	;   will be sent for all nodes.
	;
	ASSUME	LPD$C_SRM_SIZE EQ 32
	MNEGL	#1,LPD$G_SRM(R6)	; Force rtginfo for all nodes to be sent
	ASSUME	LPD$C_ASRM_SIZE EQ 1	; && fix this
	MNEGL	#1,LPD$G_ASRM(R6)	; Force rtginfo for all areas to be sent
	;
	;   Send routing messages to all our neighbors which have the SRM
	;   flags set, as we have done above.  If the decision algorithm
	;   is scheduled to be run soon, then don't send the messages now,
	;   since they may be out-of-date.  Instead, we rely on the fact
	;   that routing messages are automatically sent to all our neighbors
	;   after the algorithm is run.
	;
	BBS	#RTG_V_RUS,RTGFLG,90$	; If decision pending, msgs will
					; be sent automatically after it runs
	BSBW	UPD_NEIGHBORS		; Else, explicitly send the messages
90$:	RSB

	.SBTTL	Start automatic routing update timer
;+
; START_XRT - Start or reset the automatic routing update timer
;
; Inputs:
;
;	R6 = LPD address
;
; Outputs:
;
;	None
;
;	R0-R3 are destroyed.
;-
START_XRT:				; Start routing update timer for LPD
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>	; Save registers
	MOVL	NET$GL_CNR_LNI,R11	; Get LNI root
	MOVL	NET$GL_PTR_LNI,R10	; Get LNI CNF
	BBS	#LPD$V_BC,LPD$W_STS(R6),10$ ; Branch if broadcast circuit
	$CNFFLD	lni,l,rti,R9		; Use non-broadcast routing timer 
	BRB	20$
10$:	$CNFFLD	lni,l,brt,R9		; Use broadcast routing timer
20$:	BSBW	CNF$GET_FIELD		; Get the routing timer value
	BLBC	R0,90$			; No timer if parameter not set
	ASHL	#16,LPD$W_PTH(R6),R1	; Shift LPD index into REQIDT
	MOVW	#<<WQE$C_QUAL_RTG>@8>!-	; Set routing update timer i.d.
		    NET$C_TID_XRT,R1	; into lower word
	MOVAB	B^TIMER_XRT,R2		; Setup action routine
	EMUL	#10*1000*1000,R8,#0,R3	; Convert to standard VMS time
	BSBW	WQE$RESET_TIM		; Reset the routing update timer
90$:	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>	; Restore registers
	RSB

	.SBTTL	ENDNODE_DECISION -  Endnode decision algorithm
;+
; ENDNODE_DECISION - Endnode decision algorithm
;
; This routine is called each time we want to run the decision algorithm
; and we are an endnode.  It simply ensures that the cost/hops to ourselves
; is zero, and chooses the least cost circuit as the "designated output
; adjacency".
;
; Inputs:
;
;	R4 = RCB address
;
; Outputs:
;
;	None
;
;	Registers R0-R3, R5-R8 are destroyed.
;-
ENDNODE_DECISION:
	;
	;   Ensure that the cost/hops to ourselves is always 0.
	;
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the local node number
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0
	BEQL	10$			; If zero, then skip it
	CLRW	NET$AW_MIN_C_H[R0]	; Zero our own entry
	EXTZV	#TR4$V_ADDR_DEST,-	; Get the alias node number
		#TR4$S_ADDR_DEST,RCB$W_ALIAS(R4),R0
	BEQL	10$			; If zero, then skip it
	CLRW	NET$AW_MIN_C_H[R0]	; Zero our own entry
10$:	;
	;   Choose the least cost circuit as the "designated output
	;   circuit".
	;
	MNEGL	#1,R2			; Init R2 to least cost so far
	CLRL	R3			; Init R3 to least cost DRT so far
	MOVZBL	RCB$B_MAX_LPD(R4),R8	; Get # circuits
20$:	MOVL	@RCB$L_PTR_LPD(R4)[R8],R6 ; Get address of LPD
	BGEQ	30$			; Branch if slot not valid
	CMPL	R8,#LPD$C_LOC_INX	; Local LPD?
	BEQL	30$			; Skip the local LPD
	BBC	#LPD$V_RUN,LPD$W_STS(R6),30$ ; Br if inactive
	CMPB	LPD$B_COST(R6),R2	; Least cost circuit?
	BGEQU	30$			; If not, keep looking
	MOVZBL	LPD$B_COST(R6),R2	; Save new least cost value
	MOVZWL	LPD$W_DRT(R6),R3	; Save new least cost designated router
30$:	SOBGTR	R8,20$			; Loop thru all circuits
	MOVW	R3,RCB$W_DRT(R4)	; Set DRT for all outgoing transmits
					; with an unspecified circuit
	RSB

	.SBTTL	ACT_ENT_MOP - Enter MOP state
;+
; ACT_ENT_MOP	- Circuit has entered MOP mode while in the "run" state
; 
; This routine is called when a it is detected that the circuit has entered
; the so called "maintenance mode" -- also known as the "service mode".
; An NML process is created to service the circuit.
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD ptr
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_ENT_MOP:				; Put the circuit into a service substate
	;
	;   Notify the DLE module
	;
	BSBW	DLE$MOP_REQUEST		; Handle "MOP mode" condition
	;
	;   Recycle the circuit
	;
	MOVL	#LEV$C_LIN_DOWN,R1	; Switch to line down event
	MOVL	#1,R0			; Make state change
	RSB

	.SBTTL	ACT_DLL_UP - Datalink has initialized
;+
; ACT_DLL_UP  -	The datalink has initialized
;
; This routine is called after datalink protocol initialization.  It chooses
; one of three actions to take:
;
;
;   1.	If the operator state is "off" then the circuit is undergoing restart
;	in order to notify the partner node that it is shutting down.  In this
;	case, the state change is pre-empted with the LEV$C_OPR_OFF event.
;
;   2.	Else, if the circuit substate is "service" then the routine pre-empts 
;	the state change and exits with the LEV$C_ENT_DLE event.
;
;   3.	Else, the  LPD is prepared to commence Transport layer initialization
;	over the circuit.
;
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R9-R8	Scratch
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;		R3-R0	Scratch
;
; OUTPUTS:	R5-R7	Preserved
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_DLL_UP:				; The datalink has initialized
	PUSHL	R7			; Save ADJ address
	;
	;   If the operator state is "off" then we are going thru data-link
	;   re-init as a means to notify the opposite end of the circuit that
	;   the link is shutting down.
	;
	$GETFLD	 cri,l,sta		; Get the operator state
	BLBC	 R0,10$			; If LBC then the same as "off"
	$DISPATCH R8,<-			; Case on operator state
	    <NMA$C_STATE_OFF, 10$>,-
	    <NMA$C_STATE_SER, 20$>,-
	    <NMA$C_STATE_ON,  20$>,-
	>
10$:	MOVL	#LEV$C_OPR_OFF,R1	; Generate "operator says off" event
	CLRL	 R0			; Prevent previously intended state
					; transition
	BRB	 90$			; Take common exit
20$:	;
	;   The operator is not shutting down the circuit.  Either init for
	;   use by Transport, or give it to a direct-access server process.
	;
	BBC	#LPD$V_DLE,-		; If BS then marked for direct access
		 LPD$W_STS(R6),30$	; (state could be ON or SERVICE)
	MOVL	#LEV$C_ENT_DLE,R1	; Generate new event
	CLRL	 R0			; Prevent state change
	BRB	 90$			; Take common exit
	;
	;   The datalink is undergoing a normal startup sequence.  Tell 
	;   NETDRIVER about new LPD and schedule the Transport init messages.
	;
30$:	MOVL	#NETUPD$_DLL_ON,R0	; Setup function code
	BSBW	TELL_NETDRIVER		; Tell NETDRIVER
	INCB	LPD$B_ASTCNT(R6)	; Account for Rcv IRP queued to the
					; datalink by NETDRIVER on our behalf
	;
	;   If we have been forced into Phase II protocol, mark the
	;   adjacency as Phase II now, so that the correct start msg
	;   is sent.
	;
	MOVB	RCB$B_ETY(R4),-		; Preset "our node type" for circuit
		LPD$B_ETY(R6)
	$GETFLD	cri,l,xpt		; Circuit transport protocol
	BLBC	R0,50$			; Branch if not set
	MOVL	(SP),R7			; Restore ADJ address
	BSBB	XPT_TO_PTY		; Translate XPT to node type
	MOVB	R8,LPD$B_ETY(R6)	; Set "our node type" for circuit
50$:	;
	;   If this is a broadcast circuit, then skip the start/verification
	;   messages, and chain to another action routine, which will handle
	;   broadcast circuit startup.
	;
	BBC	#LPD$V_BC,LPD$W_STS(R6),31$ ; Branch if not broadcast circuit
	MOVL	#LEV$C_BC_UP,R1		; Generate new event
	CLRL	R0			; Prevent state change this time
	BRB	90$
31$:	;
	;   Schedule transmission of start/verification messages for a
	;   non-broadcast circuit.
	;
	$GETFLD	cri,l,xpt		; Were we forced into a specific type?
	MOVL	(SP),R7			; Restore ADJ address
	BLBS	R0,32$			; If so, don't dally at all
	SETBIT	LPD$V_XMT_DALLY,-	; Dally before sending 1st "start"
		LPD$B_XMTFLG(R6)	; so that we can adapt to remote node
32$:	BISB	#LPD$M_XMT_STR!-	; Schedule "start" msg
		 LPD$M_XMT_VRF!-	; Schedule "verification" msg
		 LPD$M_XMT_IDLE,-	; Flag to detect when last msg was sent
		 LPD$B_XMTFLG(R6)	;
	;
	;   Enter "on-starting" state
	;
	MOVB	#NMA$C_LINSS_STA,-	; Enter "starting" substate
		    LPD$B_SUB_STA(R6)	;
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVB	#1,R0			; Allow state transition
90$:	POPL	R7			; Restore ADJ address
	RSB

;
; Map TRANSPORT TYPE parameter to node type
;
; Inputs:
;
;	R8 = Transport type parameter value
;
; Outputs:
;
;	R8 = Corresponding node type (ADJ$C_PTY_xxx)
;
XPT_TO_PTY:
	$DISPATCH R8,<-
		<NMA$C_CIRXPT_PH2,40$>,- ; Force Phase II init
		<NMA$C_CIRXPT_PH3,42$>,- ; Force Phase III Routing init
		<NMA$C_CIRXPT_NR4,44$>>	; Force Phase IV endnode init
	MOVZBL	#ADJ$C_PTY_UNK,R8	; Unknown
	BRB	48$
40$:	MOVB	#ADJ$C_PTY_PH2,R8	; Phase II
	BRB	48$
42$:	MOVB	#ADJ$C_PTY_PH3,R8	; Routing III
	BRB	48$
44$:	MOVB	#ADJ$C_PTY_PH4N,R8	; Nonrouting IV
48$:	RSB

	.SBTTL	DLE-related state changes
;+
; ACT_ENT_DLE	-  Tell server process that circuit is ready 
; ACT_EXI_SERV	-  Exit service state if needed
; ACT_SYN_FAIL  -  The circuit failed to synchronize
; ACT_INI_FAIL  -  I/O failure during Transport initialization.
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD ptr
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_ENT_DLE:				; Tell server the circuit is ready
	BBS	#LPD$V_ACCESS,-		; If BS then circuit is accessed by
		 LPD$W_STS(R6),40$	; server process
	;
	;   The circuit is up (or at least the driver thinks so) but there is
	;   no server process accessing the circuit.  Queue a receive to the
	;   circuit.  When the receive completes it will serve as a signal that
	;   the remote end of the circuit is requesting service.
	;
	MOVZBL	#LEV$C_UNJAM,R1		; Assume some I/O is pending
	TSTB	LPD$B_ASTCNT(R6)	; Any other I/O pending ?
	BNEQ	100$			; If NEQ yes, recycle the circuit
	MOVZBL	#128,R1			; Setup size of P1 buffer
	BSBW	NET$DLL_QIO_CO		; Call co-routine to init WQE
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to buffer
	MOVZBL	#128,WQE$C_LENGTH+P2(R2); Setup buffer size
	MOVL	S^#IO$_READLBLK,R0	; Setup I/O function
	RSB				; Return to issue I/O, and exit
	;
	;   The circuit is already being accessed by a server process.  Tell
	;   the circuit access module that the circuit is up and then tell
	;   NETDRIVER to start its receiver.
	;
40$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	BSBW	DLE$LPD_STATUS		; Tell DLE module of circuit transition
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
100$:	RSB

ACT_EXI_SERV:				; Exit service state if needed
	BBC	#LPD$V_DLE,-		; If not marked for direct-access then
		 LPD$W_STS(R6),10$	; nothing to do
	BBS	#LPD$V_ACCESS,-		; If currently being accessed then 
		 LPD$W_STS(R6),10$	; allow operation to complete

	BUG_CHECK NETNOSTATE		; && What are we doing here??
	CLRBIT	LPD$V_DLE,LPD$W_STS(R6)	; Else clear direct-access flag
	MOVL	#LEV$C_REQ_SHUT,R1	; Chain to "request shutdown" event
	MOVL	S^#SS$_NORMAL,R0	; Allow state change
	RSB
10$:	MOVL	#LEV$C_NO_EVT,R1	; No further events
	MOVL	S^#SS$_NORMAL,R0	; Allow state change
	RSB

ACT_SYN_FAIL:				; The circuit failed to synchronize
	BBC	#LPD$V_ACCESS,-		; If BC then circuit is not being "accessed"
		 LPD$W_STS(R6),10$	; for direct-link sevice
	MOVZWL	#SS$_DEVINACT,R0	; "circuit no longer active"
	BSBW	DLE$LPD_STATUS		; Tell DLE module of circuit transition
10$:	MOVL	#LEV$C_REQ_SHUT,R1	; Chain to "request shutdown" event
	MOVL	S^#SS$_NORMAL,R0	; Allow state change
	RSB

ACT_INI_FAIL:				; I/O failure during transport init
	BUMP	B,LPD$B_CNT_IFL(R6)	; Increment circuit init failure count
	MOVL	#LEV$C_LIN_DOWN,R1	; Signal "circuit down" event
	CLRL	R0			; Do not change state for this event
	RSB

ACT_X25_RESET:				; X.25 "reset"
	CLRL	R1			; No QIO buffer needed
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	#PSI$C_RESET,WQE$C_LENGTH+P4(R2) ; Set P4 to "reset confirmation"
	MOVB	#LEV$C_NO_EVT,WQE$B_EVT(R2) ; Do nothing when I/O completes
	MOVB	#LEV$C_NO_EVT,WQE$L_PM2(R2) ; Do nothing if I/O fails
	MOVZWL	#IO$_NETCONTROL,R0	; Set I/O function code
	RSB				; Issue I/O and exit

	.SBTTL	ACT_RUN_DOWN, ACT_SET_OPER
;+
; ACT_RUN_DOWN - Run down a circuit
; ACT_SET_OPER - Restart a stalled circuit
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD ptr
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next "event longword" to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other registers may be clobbered
;-
ACT_FAILED:
	MOVB	#NMA$C_LINSS_FAI,-	; Mark outgoing call "failed"
		LPD$B_SUB_STA(R6)	; (requiring operator intervention)
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change (to S state)
	RSB
	
ACT_RUN_DOWN:				; Cancel all timers, etc.
	MOVZBL	LPD$B_PTH_INX(R6),R1	; Get LPD index
	ASHL	#16,R1,R1		; Shift into upper word
	MOVW	#WQE$C_QUAL_DLL@8,R1	; Setup QUAL, zero EVT for cancel all
	BSBW	WQE$CANCEL_TIM		; Cancel all timers for the LPD cell
	CLRBIT	LPD$V_STRTIM,-		; Start suppression timer is no longer
		LPD$W_STS(R6)		; ticking
	$GETFLD	cri,l,sta		; Get "operator" state
	BLBC	R0,10$			; If LBC then assume OFF
	CMPB	#NMA$C_STATE_OFF,R8	; Is it OFF ?
	BNEQ	50$			; If NEQ no
10$:	;
	;   The operator is turning the line off.
	;
	BBC	#LPD$V_ACCESS,LPD$W_STS(R6),100$ ; If server process active,
	MOVZWL	#SS$_DEVINACT,R0	; "circuit no longer active"
	BSBW	DLE$LPD_STATUS		; Tell DLE module of circuit transition
	BRB	100$			; Continue
	;
	;   If the circuit substate has been marked "failed" (as a
	;   result of "maximum recalls" exceeded), then do not allow
	;   further circuit startup attempts until the operator explicitly
	;   turns the circuit on (which clears substate).
	;
50$:	CMPB	LPD$B_SUB_STA(R6),-	; "failed" circuit?
		#NMA$C_LINSS_FAI
	BEQL	100$			; If so, stay in this state
					; until operator intervention
	;
	;   The circuit is entering a stalled state waiting for a server
	;   process to start some activity.  Set a timer so that we don't wait
	;   for ever.  
	;
	MOVQ	#60*<10*1000*1000>,R3	; Wait 60 seconds
	BSBW	SET_IOTIM		; Start the timer
100$:	MOVL	#LEV$C_EXIT,R1		; No further events
	MOVL	#1,R0			; Allow state transition
	RSB


ACT_SET_OPER:				; Restart a stalled line
	BBC	#LPD$V_ACCESS,LPD$W_STS(R6),100$ ; If server process active,
	MOVZWL	#SS$_DEVINACT,R0	; "circuit no longer active"
	BSBW	DLE$LPD_STATUS		; Tell DLE module of circuit transition
100$:	$GETFLD	cri,l,sta		; Get "operator" state
	MOVZBL	OPR_EVT_MAP(R8),R1	; Get corresponding event
	MOVL	#1,R0			; Allow state change
	RSB				; Process new event

	.SBTTL	ACT_TST_DL - Circuit acceptance algorithm
;+
; ACT_TST_DL  -	Run circuit acceptance algorithm
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5-R7	Preserved
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_TST_DL:				; Run circuit acceptance algorithm
	BSBW	CHK_IO			; Okay to xmit?
	MOVL	#LEV$C_EXIT,R1		; Assume we cannot xmit
	BLBC	R0,10$			; If LBC then no
	TSTB	LPD$B_TSTCNT(R6)	; Any test messages to xmit?
	BGTRU	20$			; If so, send one
	MOVL	#LEV$C_LIN_UP,R1	; Signal circuit up event
10$:	MOVB	#1,R0			; Always allow state change
	RSB

	;
	;    Allocate and setup the buffer
	;
20$:	MOVZBL	#1+2+1+TR3C_TST_MAX,R1	; Setup max test size
	CMPW	R1,ADJ$W_BUFSIZ(R7)	; Too big?
	BLEQU	30$			; If LEQU then no
	MOVZWL	ADJ$W_BUFSIZ(R7),R1	; Use partner's rcv buf size
30$:	SUBL3	#1+2+1,R1,R8		; Save size of test data field
	BSBW	NET$DLL_QIO_CO		; Call co-routine to allocate buffer
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to I/O buffer
	MNEGL	R3,WQE$C_LENGTH+P2(R2)	; Bias I/O buffer length
	;
	;   Build the message
	;
	MOVB	#TR2C_MSG_NOP,(R3)+	; Enter Phase II test msg type code
	CMPB	ADJ$B_PTYPE(R7),#ADJ$C_PTY_PH2 ; Phase II partner?
	BEQL	40$			; If so, assumption correct
	MOVB	#TR3C_MSG_TST,-1(R3)	; Partner is Phase III, replace type
					; code with Phase III test msg type code
	EXTZV	#TR4$V_ADDR_DEST,-	; Get our address (without area)
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0
	MOVW	R0,(R3)+		; Enter source node address
	MOVB	R8,(R3)+		; Enter # of test data bytes
	PUSHR	#^M<R2,R4,R5>		; Save regs
	MOVC5	#0,(SP),#^X<AA>,R8,(R3)	; Enter test data
	POPR	#^M<R2,R4,R5>		; Restore regs
40$:	DECB	LPD$B_TSTCNT(R6)	; Account for this test message
	ADDL	R3,WQE$C_LENGTH+P2(R2)	; Setup buffer size
	MOVL	S^#IO$_WRITELBLK,R0	; Setup I/O fct code
	RSB				; Return to co-routine to xmit

	.SBTTL	ACT_ENT_RUN - Enter RUN state
;+
; ACT_ENT_RUN -	Enter the RUN state for a non-broadcast circuit
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5-R7	Preserved
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_ENT_RUN:				; Enter RUN state
	BBSS	#LPD$V_RUN,-		;
		LPD$W_STS(R6),7$	; Mark circuit as active for data msgs
	INCB	RCB$B_ACT_DLL(R4)	; Account for datalink
	MOVB	RCB$B_MAX_SNK(R4),-	; Init square root limiter
		LPD$B_XMT_SRL(R6)	;
7$:	SETBIT	#ADJ$V_RUN,ADJ$B_STS(R7) ; Mark adjacency is up
	;
	;   Start listen timer going, as long as this isn't a Phase II
	;   link (Phase II didn't have any mandatory hello timer).
	;
	CMPB	ADJ$B_PTYPE(R7),#ADJ$C_PTY_PH2 ; If not Phase II link,
	BEQL	8$
	SETBIT	#ADJ$V_LSN,ADJ$B_STS(R7) ; Start listen timer going
8$:	;
	;   If the partner node is a endnode or a Phase II node, then init
	;   the cell in the cost/hops matrix associated with this node to
	;   indicate that the node is directly adjacent.  This is because
	;   we will never get any other notification (such as a routing
	;   message) to update the cell.  The actual cost will be correctly
	;   computed when the decision algorithm is run.
	;
	$DISPATCH ADJ$B_PTYPE(R7),TYPE=B,<- ; Based on adjacency type
		<ADJ$C_PTY_PH2,10$>,-	; Phase II nodes
		<ADJ$C_PTY_PH3N,10$>,-	; Phase III endnodes
		<ADJ$C_PTY_PH4N,10$>>	; Phase IV endnodes
	BRB	40$			; Else, skip it

10$:	MOVZBL	ADJ$B_LPD_INX(R7),R1	; Get the circuit's index
	EXTZV	#TR4$V_ADDR_AREA,-	; Get area address
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R7),R2
	BEQL	30$			; If area = 0, assume our area
	CMPB	R2,RCB$B_HOMEAREA(R4)	; Our area?
	BEQL	30$			; If so, set the right cost/hops
	MOVL	NET$AL_AREA_CH[R1],R1	; Get address of area cost/hops buffer
	BEQL	40$			; If none, skip it
	CLRW	(R1)[R2]		; Set area cost/hops to "adjacent"
	BRB	40$
30$:	EXTZV	#TR4$V_ADDR_DEST,-	; Get node address within our area
		#TR4$S_ADDR_DEST,ADJ$W_PNA(R7),R2
	MOVL	NET$AL_CH_VEC[R1],R1	; Get address of cost/hops buffer
	BEQL	40$			; If none, skip it
	CLRW	(R1)[R2]		; Set cost/hops word to "adjacent"
40$:	BSBW	UPDATE_ALL		; Re-run decision algorithm
					; and force routing msgs to be sent
	;
	;   Announce the circuit is up
	;
	$LOG	TPL_LUP,,,R5		; Set "circuit up" event
	BSBW	NET$EVT_INTRAW		; Log the event record
	;
	;   Start the automatic routing update timer, which causes
	;   a routing message to be sent on this circuit each tick.
	;
	BSBW	START_XRT		; Start routing timer
	MOVL	#LEV$C_NO_EVT,R1	; No more transitions
	MOVB	#1,R0			; Allow state change
	RSB

	.SBTTL	ACT_BC_UP - Broadcast datalink has initialized
;+
; ACT_BC_UP	-  Start broadcast circuit Transport initialization
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;
; Outputs:
;
;	R1 = Next event to be processed
;	R0 = True if state change allowed, false if not.
;-
ACT_BC_UP:
	BBSS	#LPD$V_RUN,-		;
		LPD$W_STS(R6),7$	; Mark circuit as active for data msgs
	INCB	RCB$B_ACT_DLL(R4)	; Account for datalink
	MOVB	RCB$B_MAX_SNK(R4),-	; Init square root limiter
		LPD$B_XMT_SRL(R6)	;
7$:	SETBIT	ADJ$V_RTG,ADJ$B_STS(R7)	; Mark as routing adjacency
	;
	;   For broadcast circuits, preset the "partner buffer size" in
	;   the main adjacency to our own buffer size.  This field will
	;   be updated to always contain the minimum buffer size of all
	;   the BRAs on the circuit.
	;
	MOVW	LPD$W_BUFSIZ(R6),-	; Preset partner buffer size to our
		ADJ$W_BUFSIZ(R7)	; buffer size (main BC ADJ case)
	;
	;   Tell NETDRIVER to send a Router/Endnode Hello message immediately
	;
	MOVZBL	#NETUPD$_SEND_HELLO,R0	; Set function code
	BSBW	TELL_NETDRIVER		; Call NETDRIVER to send hello msg
	;
	;   Re-calculate the square root limiters, to account for the
	;   additional circuit now active.
	;
	BSBW	UPDATE_ALL		; Update routing database
	;
	;   Log a "circuit up" event record.
	;
	$LOG	TPL_LUP,,,R5		; Set "circuit up" event
	BSBW	NET$EVT_INTRAW		; Log the event record
	;
	;   If we are a router, start the "election suppression" timer to
	;   prevent our election from being resolved before we've had a chance
	;   to hear from everybody.
	;
	CMPB	LPD$B_ETY(R6),#ADJ$C_PTY_PH4N ; Are we an endnode?
	BEQL	20$			; If so, skip this
	MOVZBL	LPD$B_PTH_INX(R6),R1	; Get LPD index
	ASHL	#16,R1,R1		; Shift into upper word
	MOVW	#<<WQE$C_QUAL_DLL>@8>!-	; Overlay QUAL and EVT fields
		   LEV$C_ELECT_TIM,R1
	MOVAB	NET$DLL_PRC_WQE,R2	; Setup action routine address
	EMUL	#TR$C_TIM_DRDELAY,-	; Set timer value
		#10*1000*1000,#0,R3
	BSBW	WQE$RESET_TIM		; Set the timer
	MOVL	NET$GL_PTR_VCB,R4	; Recover RCB address	
	SETBIT	#LPD$V_ELECT_TIM,-	; Mark suppression timer ticking
		LPD$W_STS(R6)
20$:	;
	;   Start the automatic routing update timer, which causes
	;   a routing message to be sent on this circuit each tick.
	;
	BSBW	START_XRT		; Start routing timer
	;
	;   Notify DLE module that broadcast circuit is up, so that it
	;   can enable the "load/dump" and "loopback" protocol types.
	;
	BSBW	DLE$BC_UP		; Enable service on circuit
	MOVL	#LEV$C_NO_EVT,R1	; No more transitions
	MOVB	#1,R0			; Allow state change
	RSB

	.SBTTL	BRA_UP - Setup new adjacency for BRA
;+
; BRA_UP - Setup new adjacency control block for broadcast router
;
; This routine is called when a broadcast router is heard from to
; allocate a new ADJ block and declare the node up.
;
; Inputs:
;
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;	LEV_W_PNA = Address of node which sent message
;	LEV_B_PRIORITY = BRA's router priority (0 if none or not available)
;	PTYPE = Type of node parsed from message
;
; Outputs:
;
;	R0 = status code
;	R6 = LPD address
;	R7 = ADJ address
;	R8 = ADJ index
;
;	R1-R3 are destroyed.
;-
BRA_UP:
	;
	;   See if there is already a BRA slot for this circuit/node
	;   pair.  This would be the case if we received several Router
	;   Hello messages in a row - the first would create the BRA,
	;   and the subsequent messages should not create duplicate BRAs.
	;
	MOVZBL	RCB$B_MAX_LPD(R4),R8	; Get number of circuits
	MOVZWL	RCB$W_MAX_RTG(R4),R3	; Set ending ADJ index
	BRB	5$			; Start with slot NC+1
2$:	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7 ; Get ADJ address
	CMPW	LEV_W_PNA,ADJ$W_PNA(R7)	; Does the node address match?
	BNEQ	5$			; Branch if not
	CMPB	LPD$B_PTH_INX(R6),-	; Does the circuit match?
		ADJ$B_LPD_INX(R7)
	BNEQ	5$			; If duplicate found,
	BRW	90$			; Do nothing - exit with this ADJ
5$:	AOBLEQ	R3,R8,2$		; Loop thru all BRA slots
	;
	;   If we are an endnode, do not allow more than 1 BRA at
	;   a time (since the BRA is always the designated router).
	;   As a result, if we have encountered a new BRA at this
	;   point, bring down the old BRA with "adjancency down".
	;
	CMPB	LPD$B_ETY(R6),#ADJ$C_PTY_PH4N	; Are we an endnode?
	BNEQ	8$			; Branch if not
	MOVZBL	RCB$B_MAX_LPD(R4),R0	; Get # circuits
	CMPW	LPD$W_DRT(R6),R0	; Any external DRT active now?
	BLEQ	8$			; Branch if not
	MOVW	LPD$W_DRT(R6),-		; Move DRT adjacency index to WQE
		WQE$W_ADJ_INX(R5)
	$LOG	TPL_ARJ,,,R5		; Setup "adjacency rejected"
	CLRL	WQE$L_EVL_PKT(R5)	; Indicate no packet for this event
	BSBW	NET$EVT_INTRAW		; Log the event record
	MOVZWL	LPD$W_DRT(R6),R8	; Get designated BRA index
	BSBW	ADJ_DOWN		; Bring the adjacency down
	;
	;   Allocate a new BRA adjacency slot
	;
8$:	MOVZBL	RCB$B_MAX_LPD(R4),R8	; Get number of circuits
	MOVZWL	RCB$W_MAX_RTG(R4),R3	; Set ending ADJ index
	BRB	15$			; Start with slot NC+1
10$:	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7 ; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R7),20$ ; Branch if slot available
15$:	AOBLEQ	R3,R8,10$		; Loop thru all BRA slots
	;
	;   The BRA database is full.  Eject the lowest priority BRA.
	;
	MOVZBL	LEV_B_PRIORITY,R2	; Get BRA router priority, if known
	BEQL	18$			; If not known, then eject newest BRA
	MOVZWL	LEV_W_PNA,R3		; Pass newest BRA's address
	BSBB	LOWEST_PRIO_BRA		; Determine lowest priority BRA
	TSTL	R8			; If newest BRA is lowest priority,
	BEQL	18$			; then simply ignore the message
	MOVW	R8,WQE$W_ADJ_INX(R5)	; Move adjacency index to WQE
	$LOG	TPL_ARJ,,,R5		; Setup "adjacency rejected"
	CLRL	WQE$L_EVL_PKT(R5)	; Indicate no packet for this event
	BSBW	NET$EVT_INTRAW		; Log the event record
	BSBW	ADJ_DOWN		; Bring the adjacency down
	BRB	8$			; Now allocate the slot just freed up
	;
	;   The new BRA happens to be the lowest priority BRA, and thus,
	;   we must ignore the message we just received from it.
	;
18$:	MOVZWL	#SS$_INSFMEM,R0		; Indicate BRA database full
	RSB				; and exit
	;
	;   ADJ slot found - initialize it
	;
20$:	PUSHR	#^M<R4,R5>		; Save registers
	MOVC5	#0,(SP),#0,#ADJ$C_LENGTH,(R7) ; Zero ADJ cell
	POPR	#^M<R4,R5>		; Restore registers
	BISB	#ADJ$M_INUSE!-		; Mark the slot in use
		 ADJ$M_RTG!-		; Mark as routing adjacency
		 ADJ$M_LSN,-		; Start the listen timer going
		ADJ$B_STS(R7)
	MOVW	LPD$W_PTH(R6),ADJ$W_LPD(R7) ; Store associated LPD
	MOVW	LEV_W_PNA,ADJ$W_PNA(R7)	; Set partner node address
	MOVB	PTYPE,ADJ$B_PTYPE(R7)	; Set partner type
	;
	;   Allocate cost/hops buffer for routing with this node
	;
	BSBW	ALLOC_COSTHOPS		; Allocate a cost/hops buffer
	;
	;   Leave RUN flag off, until we hear a Router Hello message from
	;   the remote router node with our address in it, indicating that
	;   two-way communication has been established.  Only then will
	;   the router be declared up.
	;
90$:	MOVL	S^#SS$_NORMAL,R0	; Successful
	RSB

	.SBTTL	LOWEST_PRIO_BRA - Find lowest priority BRA
;+
; LOWEST_PRIO_BRA - Determine the lowest priority BRA
;
; This routine is called when we must determine the lowest priority
; BRA in the event that the BRA database is full, and we just heard
; from another BRA.
;
; Inputs:
;
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;	R3 = Newest BRA's address
;	R2 = Newest BRA's router priority
;
; Outputs:
;
;	R8 = Lowest priority BRA, 0 if "Newest BRA" is lowest priority
;
;	R0-R3,R7 are destroyed.
;-
LOWEST_PRIO_BRA:
	CLRL	R8				; Indicate no lowest ADJ yet
	MOVZBL	RCB$B_MAX_LPD(R4),R7		; Get number of circuits
	MOVZWL	RCB$W_MAX_RTG(R4),R1		; Set ending ADJ index
	BRB	55$				; Start at slot NC+1
50$:	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R0	; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R0),55$	; Skip if slot not in use
	CMPB	ADJ$B_BCPRI(R0),R2		; Lower priority?
	BGTRU	55$				; Branch if not
	BLSSU	52$				; Branch if so
	CMPW	ADJ$W_PNA(R0),R3		; If equal, compare addresses
	BGEQU	55$				; If address lower,
52$:	MOVZWL	ADJ$W_PNA(R0),R3		; Update "lowest priority BRA"
	MOVZBL	ADJ$B_BCPRI(R0),R2		; Update "lowest priority"
	MOVL	R7,R8				; Update "lowest prio. index"
55$:	AOBLEQ	R1,R7,50$			; Loop thru all routers
	RSB

	.SBTTL	BEA_UP - Setup new adjacency for BEA
;+
; BEA_UP - Setup new adjacency control block for broadcast endnode
;
; This routine is called when a broadcast endnode is heard from to
; allocate a new ADJ block and declare the node up.
;
; Inputs:
;
;	R6 = LPD address
;	LEV_W_PNA = Address of node which sent message
;
; Outputs:
;
;	R0 = status code
;	R6 = LPD address
;	R7 = ADJ address
;	R8 = ADJ index
;
;	R1-R5 are destroyed.
;-
BEA_UP:
	;
	;   See if there is already a BEA slot for this endnode.
	;   This would be the case if we received several Hello
	;   messages in a row - the first would create the BEA, and
	;   the subsequent messages should not create duplicate BEAs.
	;
	MOVZWL	RCB$W_MAX_RTG(R4),R8	; Get NC + NBRA
	MOVZWL	RCB$W_MAX_ADJ(R4),R3	; Set ending ADJ index
	BRB	5$			; Start with slot NC+1
2$:	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7 ; Get ADJ address
	CMPW	LEV_W_PNA,ADJ$W_PNA(R7)	; Does the node address match?
	BEQL	90$			; If duplicate found, do nothing
5$:	AOBLEQ	R3,R8,2$		; Loop thru all BRA slots
	;
	;   Allocate a new BEA adjacency slot
	;
	MOVZWL	RCB$W_MAX_RTG(R4),R8	; Get NC + NBRA
	MOVZWL	RCB$W_MAX_ADJ(R4),R3	; Set ending ADJ index
	BRB	15$			; Start with slot NC+NBRA+1
10$:	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7 ; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R7),20$ ; Branch if slot available
15$:	AOBLEQ	R3,R8,10$		; Loop thru all BEA slots
	MOVZWL	#SS$_INSFMEM,R0		; Indicate BEA database full
	RSB				; and exit
20$:	;
	;   ADJ slot found - initialize it
	;
	PUSHR	#^M<R4,R5>		; Save registers
	MOVC5	#0,(SP),#0,#ADJ$C_LENGTH,(R7) ; Zero ADJ cell
	POPR	#^M<R4,R5>		; Restore registers
	BISB	#ADJ$M_INUSE!-		; Mark the slot in use
		 ADJ$M_RUN!-		; Mark adjacency up for routing
		 ADJ$M_LSN,-		; Start the listen timer going
		ADJ$B_STS(R7)		; and mark adjacency up for routing
	MOVW	LPD$W_PTH(R6),ADJ$W_LPD(R7) ; Store associated LPD
	MOVW	LEV_W_PNA,ADJ$W_PNA(R7)	; Set partner node address
	MOVB	#ADJ$C_PTY_PH4N,ADJ$B_PTYPE(R7)	; Set partner type
	;
	;   Set entry in cost/hops matrix for the main NI adjacency
	;   to indicate that it is reachable (hops=0, cost=0).  The
	;   cost/hops will be correctly computed to include this
	;   node when the decision algorithm is run.
	;
	MOVZBL	LPD$B_PTH_INX(R6),R1	; Get LPD index
	EXTZV	#TR4$V_ADDR_AREA,-	; Get area address
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R7),R2
	BEQL	30$			; If area = 0, assume our area
	CMPB	R2,RCB$B_HOMEAREA(R4)	; Our area?
	BEQL	30$			; If so, set the right cost/hops
	MOVL	NET$AL_AREA_CH[R1],R1	; Get address of area cost/hops buffer
	BEQL	40$			; If none, skip it
	CLRW	(R1)[R2]		; Set area cost/hops to "adjacent"
	BRB	40$
30$:	EXTZV	#TR4$V_ADDR_DEST,-	; Get node address within our area
		#TR4$S_ADDR_DEST,ADJ$W_PNA(R7),R2
	MOVL	NET$AL_CH_VEC[R1],R1	; Get address of cost/hops buffer
	BEQL	40$			; If none, skip it
	CLRW	(R1)[R2]		; Set cost/hops word to "adjacent"
40$:	;
	;   Update the routing database
	;
	BSBW	UPDATE_ALL		; Re-run decision algorithm
					; and force routing msgs to be sent
90$:	MOVL	S^#SS$_NORMAL,R0	; Successful
	RSB

	.SBTTL	Error action routines for "RUN" state
;+
; ACT_RUN_SYNC -   Synchronization lost while in the "run" state
; ACT_RUN_UXPK -   Unexpected packet type while in the "run" state
; ACT_ENT_MPR  -   Circuit has entered MOP mode while in the "run" state
; ACT_RUN_SHUT -   Shut down the datalink while in the "run" state
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD ptr
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_RUN_SYNC:				; Circuit down - synchronization lost
	$LOG	TPL_LDF,TPL_PRSN_SYNC,,R5 ; Setup logging data
	MOVL	#LEV$C_LOG_CDE,R1	; Signal "circuit down" event
	CLRL	R0			; Do not change state for this event
	RSB

ACT_RUN_UXPK:				; Circuit down - unexpected packet type
	$LOG	TPL_LDS,TPL_PRSN_UXPK,,R5 ; Setup logging data
	MOVL	#LEV$C_LOG_ADE,R1	; Signal "adjacency down" event
	CLRL	R0			; Do not change state for this event
	RSB

ACT_ENT_MPR:				; Enter MOP mode from the run state
	BSBB	EXIT_RUN_STATE		; Exit the "run" state
	BSBW	ACT_QIO_SHUT		; Shutdown the circuit
	MOVL	#LEV$C_IRP_MM,R1	; Resignal MOP mode event
	MOVL	#1,R0			; Allow state change
	RSB

ACT_RUN_SHUT:
	BSBB	EXIT_RUN_STATE		; Exit the "run" state
	MOVL	#LEV$C_REQ_SHUT,R1	; Chain to "request shutdown" event
	MOVL	#1,R0			; Allow state change
	RSB

ACT_ADJ_DOWN:
	;
	;   If this is a non-broadcast circuit, or the adjacency is the
	;   primary circuit adjacency, then bring down the entire circuit.
	;   Otherwise, mark the adjacency down, and leave the circuit running.
	;
	BBC	#LPD$V_BC,LPD$W_STS(R6),50$ ; Branch if non-broadcast circuit
	MOVZBL	RCB$B_MAX_LPD(R4),R0	; Get number of circuits
	CMPW	WQE$W_ADJ_INX(R5),R0	; Is it the main circuit adjacency?
	BLEQU	50$			; If so, shutdown entire circuit
	MOVZWL	WQE$W_ADJ_INX(R5),R8	; Get ADJ index
	BSBW	ADJ_DOWN		; Mark adjacency down
	MOVL	#LEV$C_NO_EVT,R1	; Nothing more to do
	MOVL	#1,R0
	RSB
	;
	;   Shutdown the entire circuit
	;
50$:	MOVL	#LEV$C_LIN_DOWN,R1	; Chain to bring down entire circuit
	CLRL	R0			; Do not change state
	RSB

	.SBTTL	EXIT_RUN_STATE - Exit the RUN state
;+
; EXIT_RUN_STATE - Perform any cleanup before exiting the "run" state
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	None
;-
EXIT_RUN_STATE:
	BUMP	B,LPD$B_CNT_LDN(R6)	; Increment circuit down count
	BBCC	#LPD$V_RUN,-		; If leaving run state then
		 LPD$W_STS(R6),7$	;
	DECB	RCB$B_ACT_DLL(R4)	; Account for loss of datalink
7$:	;
	;   Mark as unreachable all nodes which were to use this path
	;
	MOVZBL	LPD$B_PTH_INX(R6),R3	; Get index of LPD now inactive
	MOVZWL	RCB$W_MAX_ADDR(R4),R2	; Get maximum number of nodes
	MOVL	#1,R1			; Start at node #1
10$:	MOVZWL	@RCB$L_PTR_OA(R4)[R1],R0 ; Get output ADJ for this node
	BEQL	20$			; Branch if none
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R0 ; Get ADJ address
	CMPW	ADJ$B_LPD_INX(R0),R3	; Does this ADJ use the LPD?
	BNEQ	20$			; Branch if not
	CLRW	@RCB$L_PTR_OA(R4)[R1]	; Mark node unreachable
20$:	AOBLEQ	R2,R1,10$		; Loop through entire OA vector
	;
	;   Mark as unreachable all nodes which were to use this path
	;
	TSTL	RCB$L_PTR_AOA(R4)	; Are we an area router?
	BEQL	25$			; If not, skip it
	MOVZBL	RCB$B_MAX_AREA(R4),R2	; Get maximum number of areas
	MOVL	#1,R1			; Start at area #1
22$:	MOVZWL	@RCB$L_PTR_AOA(R4)[R1],R0 ; Get output ADJ for this area
	BEQL	24$			; Branch if none
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R0 ; Get ADJ address
	CMPW	ADJ$B_LPD_INX(R0),R3	; Does this ADJ use the LPD?
	BNEQ	24$			; Branch if not
	CLRW	@RCB$L_PTR_AOA(R4)[R1]	; Mark area unreachable
24$:	AOBLEQ	R2,R1,22$		; Loop through entire AOA vector
25$:	;
	;   Bring down the adjacency which initiated this event
	;
	MOVZWL	WQE$W_ADJ_INX(R5),R8	; Set index of ADJ we have in-hand
	BSBW	ADJ_DOWN		; Bring down adjacency
	;
	;   If this is a broadcast circuit, then bring down any
	;   adjacencies that are associated with this circuit.
	;
	BBC	#LPD$V_BC,LPD$W_STS(R6),50$ ; If non-broadcast circuit, we're done
	MOVZWL	RCB$W_MAX_ADJ(R4),R2	; Get number of adjacencies
	MOVL	#1,R8			; Start at ADJ #1
30$:	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R0 ; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R0),40$ ; Branch if slot not in use
	CMPB	ADJ$B_LPD_INX(R0),LPD$B_PTH_INX(R6) ; Does it point to LPD?
	BNEQ	40$			; If not, go on
	BSBW	ADJ_DOWN		; Bring down the adjacency
40$:	AOBLEQ	R2,R8,30$		; Loop thru entire ADJ vector
	;
	;   Make sure the "designated router" is reset when the
	;   circuit is brought down, just in case it fails to get
	;   reset properly elsewhere.
	;
	MOVZBW	LPD$B_PTH_INX(R6),-	; Indicate no "known" designated router
		LPD$W_DRT(R6)		; (make it the circuit itself)
	;
	;   Reset router/state list to a null string, since there are
	;   no longer any BRAs for this adjacency.
	;
	MOVL	LPD$L_RTR_LIST(R6),R0	; Get address of election list
	BEQL	45$			; Skip if none
	CLRB	(R0)			; Reset election list to null
	;
	;   Send an "I'm going away" message (empty RHEL), if possible,
	;   to notify other nodes that we are going away.
	;
	MOVZBL	#NETUPD$_SEND_HELLO,R0	; Set function code
	BSBW	TELL_NETDRIVER		; Call NETDRIVER to send hello msg
45$:	;
	;   Notify DLE module that broadcast circuit is down, so that it
	;   can disable the "load/dump" and "loopback" protocol types.
	;
	BSBW	DLE$BC_DOWN		; Disable service on circuit
	;
	;   Store infinite cost/hops for all nodes in the cost/hops buffer
	;   associated with the circuit going down.  When the decision
	;   algorithm is run again, the cost/hops to all nodes will be
	;   re-computed.
	;
50$:	MOVZBL	LPD$B_PTH_INX(R6),R3	; Get index of LPD now inactive
	PUSHR	#^M<R3,R4,R5>		; Save critical regs
	MOVL	NET$AL_CH_VEC[R3],R0	; Get address of cost/hops buffer
	BEQL	52$			; Skip if none
	MOVC5	#0,(SP),#-1,-		; Store infinity in each cell for
		#2*NUM_NODES,(R0)	;  each node as known to this circuit
	MOVL	(SP),R3			; Recover R3
52$:	MOVL	NET$AL_AREA_CH[R3],R0	; Get address of cost/hops buffer
	BEQL	55$			; Skip if none
	MOVC5	#0,(SP),#-1,-		; Store infinity in each cell for
		#2*NUM_AREAS,(R0)	;  each node as known to this circuit
55$:	POPR	#^M<R3,R4,R5>		; Restore regs
	;
	;   When exiting "run" state for any reason on a X.25 PVC (including
	;   because the remote side sent us a reset), issue a reset to the
	;   remote side to ensure that it restarts the initialization sequence.
	;   We can't get into an infinite loop doing this, because its only
	;   done when exiting the run state.
	;
	BBC	#LPD$V_X25,-		; If X.25 circuit,
		LPD$W_STS(R6),60$
	$GETFLD	cri,l,use		; Get circuit usage
	BLBC	R0,60$
	CMPL	R8,#NMA$C_CIRUS_PER	; X.25 PVC?
	BNEQ	60$			; If so,
	CLRL	R1			; No QIO buffer needed
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	#PSI$C_RESET,WQE$C_LENGTH+P4(R2) ; Set P4 to "reset initiate"
	MOVZWL	#IO$_NETCONTROL,R0	; Set I/O function code
	JSB	@(SP)+			; Issue I/O request
60$:	;
	;   Update the routing data base to account for the decrease
	;   in active circuits, as well as to remove all least cost
	;   paths over this circuit.
	;
	BSBW	UPDATE_ALL		; Re-run decision algorithm
					; and force routing msgs to be sent
	RSB

	.SBTTL	ADJ_DOWN - Mark adjacency as shutdown
;+
; ADJ_DOWN - Shutdown the adjacency
;
; This routine is called to mark an adjacency as shutdown.
;
; Inputs:
;
;	R8 = ADJ index
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	None
;
;	No registers are destroyed.
;-
ADJ_DOWN:
	PUSHR	#^M<R1,R2,R3,R7>	; Save registers
	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7 ; Get ADJ address
	EXTZV	#TR4$V_ADDR_DEST,-	; Save node # for later in routine
		#TR4$S_ADDR_DEST,ADJ$W_PNA(R7),R3 ; (assume it's in our area)
	CLRW	ADJ$W_PNA(R7)		; Adjacent node is unknown
	CLRW	ADJ$W_BUFSIZ(R7)	; Reset buffer size
	BICB	#ADJ$M_RUN!ADJ$M_LSN!ADJ$M_RTG,- ; Clear flags
		ADJ$B_STS(R7)
	MOVB	#ADJ$C_PTY_UNK,-	; Mark partner type unknown
		ADJ$B_PTYPE(R7)
	;
	;   If this is the main circuit adjacency, then do nothing more
	;   then resetting the fields in the ADJ.
	;
	MOVZBL	RCB$B_MAX_LPD(R4),R0	; Get number of circuits
	CMPW	R8,R0			; Is this the main circuit adajcency?
	BLEQU	90$			; If so, don't ever deallocate it
	BBCC	#ADJ$V_INUSE,-		; Mark slot no longer in use
		ADJ$B_STS(R7),90$	; and exit if already was marked down
	CLRL	R7			; Invalidate pointer
	CMPW	R8,RCB$W_MAX_RTG(R4)	; BRA or BEA?
	BGTR	30$			; Branch if endnode
	;
	;   If this is a broadcast router, then call another routine
	;   to handle it.
	;
	BSBW	BRA_DOWN		; Mark BRA down
	BRB	50$
	;
	;   If this is an endnode, then set the cost/hops to this node
	;   to infinity.
	;
30$:	MOVZBL	LPD$B_PTH_INX(R6),R0	; Get LPD index
	MOVL	NET$AL_CH_VEC[R0],R0	; Get address of cost/hops buffer
	BEQL	50$			; If none, skip it
	MNEGW	#1,(R0)[R3]		; Set cost/hops to infinity
	;
	;   Update the routing database to account for the change in
	;   the cost/hops matrix.
	;
50$:	BSBW	UPDATE_ALL		; Re-run decision algorithm
					; and force routing msgs to be sent
90$:	MOVL	#1,R0			; Success
	POPR	#^M<R1,R2,R3,R7>	; Restore registers
	RSB

	.SBTTL	BRA_DOWN - Mark BRA down
;+
; BRA_DOWN - Mark BRA down
;
; This routine is called when a BRA is removed from the adjacency database.
;
; Inputs:
;
;	R8 = ADJ index
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	None
;
;	R0-R3 are destroyed.
;-
BRA_DOWN:
	;
	;   If this BRA was the designated router, then reset the ADJ index
	;   for the designated router, indicating no designated router.
	;
	CMPW	R8,LPD$W_DRT(R6)	; Is the designated router going down?
	BNEQ	5$			; Branch if not
	MOVZBW	LPD$B_PTH_INX(R6),-	; Indicate no "known" designated router
		LPD$W_DRT(R6)		; (make it the NI itself)
5$:	;
	;   For broadcast routers, remove its entry from our Router
	;   Hello NI LIST, and set cost/hops to all nodes thru this
	;   router to infinity (by deallocating the cost/hops buffer
	;   for this router adjacency slot).
	;
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,10$>,-	; skip the following
		<ADJ$C_PTY_PH3N,10$>>
	BSBW	BUILD_RTR_LIST		; Re-build RTR_LIST, minus this router
	MOVL	NET$AL_CH_VEC[R8],R0	; Get cost/hops buffer
	BEQL	10$			; Skip if not there
	SUBL	#12,R0			; Get address of real buffer
	BSBW	NET$DEALLOCATE		; Deallocate it
	CLRL	NET$AL_CH_VEC[R8]	; Indicate buffer no longer present
10$:	MOVL	NET$AL_AREA_CH[R8],R0	; Get area cost/hops buffer
	BEQL	15$			; Skip if not there
	SUBL	#12,R0			; Get address of real buffer
	BSBW	NET$DEALLOCATE		; Deallocate it
	CLRL	NET$AL_AREA_CH[R8]	; Indicate buffer no longer present
15$:	;
	;   Re-calculate the "minimum blocksize of all BRAs on the NI"
	;   (which is stored in the main adjacency of the NI, and is used
	;   to determine the size of routing messages sent over the NI)
	;   by scanning all active BRAs left, and determining the minimum.
	;
	MOVZBL	LPD$B_PTH_INX(R6),R0	; Get LPD index
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R0 ; Get main ADJ address for BC
	MOVW	LPD$W_BUFSIZ(R6),-	; Preset minimum to our size
		ADJ$W_BUFSIZ(R0)
	MOVZBL	RCB$B_MAX_LPD(R4),R2	; Get number of circuits
	MOVZWL	RCB$W_MAX_RTG(R4),R3	; Set ending ADJ index
	BRB	25$			; Start with slot NC+1
20$:	MOVL	@RCB$L_PTR_ADJ(R4)[R2],R1 ; Get ADJ address
	BBC	#ADJ$V_RUN,ADJ$B_STS(R1),25$ ; Skip if BRA not running
	CMPB	LPD$B_PTH_INX(R6),-	; Is it on this NI?
		ADJ$B_LPD_INX(R1)
	BNEQ	25$			; If not, skip it
	CMPW	ADJ$W_BUFSIZ(R1),-	; Buffer size less than minimum?
		ADJ$W_BUFSIZ(R0)
	BGEQU	25$			; Branch if not
	MOVW	ADJ$W_BUFSIZ(R1),-	; If so, store the minimum
		ADJ$W_BUFSIZ(R0)
25$:	AOBLEQ	R3,R2,20$		; Loop thru all BRA slots
	RSB

	.SBTTL	BUILD_RTR_LIST - Re-build NI router/state list
;+
; BUILD_RTR_LIST - Re-build NI router/state list
;
; This routine is called when the router adjacency database changes,
; to rebuild the NI router/state list for our Router Hello message.
;
; Inputs:
;
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	R0 = True if election list has not changed since the last one
;		("election stablized").  False if it's different than
;		the last one (send it out now).
;
;	R1-R3 are destroyed.
;-
BUILD_RTR_LIST:
	PUSHR	#^M<R7,R8>			; Save registers
	SUBL	#1+TR4C_MAX_RSLIST,SP		; Allocate buffer on stack
	MOVL	SP,R3				; Point to buffer
	;
	;   Scan all BRA adjacencies, and for each slot in use on this LPD,
	;   store an entry in the list.
	;
	MOVZBL	RCB$B_MAX_LPD(R4),R8		; Get number of circuits
	INCL	R8				; Set starting ADJ index
	MOVZWL	RCB$W_MAX_RTG(R4),R1		; Set ending ADJ index
50$:	MOVL	@RCB$L_PTR_ADJ(R4)[R8],R7	; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R7),55$	; Skip if slot not in use
	CMPB	LPD$B_PTH_INX(R6),-		; Is it on this NI?
		ADJ$B_LPD_INX(R7)
	BNEQ	55$				; If not, skip it
	MOVL	#TR$C_NI_PREFIX,(R3)+		; Store standard Phase IV prefix
	MOVW	ADJ$W_PNA(R7),(R3)+		; Store node address
	ASSUME	TR4V_RS_PRIO EQ 0
	MOVB	ADJ$B_BCPRI(R7),(R3)+		; Store router priority
	SETBIT	TR4V_RS_TWOWAY,-1(R3)		; Assume two-way established
	BBS	#ADJ$V_RUN,ADJ$B_STS(R7),55$	; Branch if two-way
	CLRBIT	TR4V_RS_TWOWAY,-1(R3)		; Else, clear two-way flag
55$:	AOBLEQ	R1,R8,50$			; Loop thru all routers
	SUBL	SP,R3				; Compute size of new list
	;
	;   See if new election list is different than our old one.  If
	;   so, set a flag for the caller.
	;
	PUSHR	#^M<R1,R2,R3,R4,R5>		; Save registers
	MOVL	LPD$L_RTR_LIST(R6),R1		; Get address of buffer
	MOVZBL	(R1)+,R0			; Get size of current list
	CMPC5	R3,5*4(SP),#0,R0,(R1)		; Is the new list different?
	BEQL	57$				; If so,
	CLRL	R0				; "Election not stable yet"
	BRB	59$
57$:	MOVL	#1,R0				; "Election stablized"
59$:	POPR	#^M<R1,R2,R3,R4,R5>		; Restore registers
	;
	;   Store new list in LPD buffer
	;
	MOVL	LPD$L_RTR_LIST(R6),R1		; Get address of buffer
	MOVB	R3,(R1)+			; Store size of list
	PUSHR	#^M<R0,R4,R5>			; Save registers
	MOVC	R3,3*4(SP),(R1)			; Store entire list
	POPR	#^M<R0,R4,R5>			; Restore registers
	ADDL	#1+TR4C_MAX_RSLIST,SP		; Deallocate buffer on stack
	POPR	#^M<R7,R8>			; Restore registers
	RSB

	.SBTTL	ELECT_ROUTER - Elect designated router
;+
; ELECT_ROUTER - Elect the "designated router" for this circuit
;
; This routine elects the designated router from among all the routers
; on this NI.  Since every router uses the same algorithm to decide,
; all the routers arrive at the same conclusion without consultation.
; This routine must only be called if we are a router (if an endnode
; was to set its DRT to ourself, we would probably crash).
;
; Inputs:
;
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	R1 = Adjacency index of "designated router"
;	R2 = Priority of "designated router"
;	R3 = Node address of "designated router"
;
;	R0 is destroyed.
;-
ELECT_ROUTER:
	PUSHR	#^M<R7,R8,R9>			; Save registers
	MOVZBL	RCB$B_HOMEAREA(R4),R9		; Get our own area number
	MOVL	#LPD$C_LOC_INX,R8		; Set "current DRT adj index"
	MOVZBL	LPD$B_BCPRI(R6),R2		; Set "highest priority"
	MOVZWL	RCB$W_ADDR(R4),R3		; Set "current DRT address"
	MOVZBL	RCB$B_MAX_LPD(R4),R7		; Get number of circuits
	MOVZWL	RCB$W_MAX_RTG(R4),R1		; Set ending ADJ index
	BRB	55$				; Start at slot NC+1
50$:	MOVL	@RCB$L_PTR_ADJ(R4)[R7],R0	; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R0),55$	; Skip if slot not in use
	CMPB	LPD$B_PTH_INX(R6),-		; Is it on this NI?
		ADJ$B_LPD_INX(R0)
	BNEQ	55$				; If not, skip it
	CMPZV	#TR4$V_ADDR_AREA,-		; Is it in our area?
		#TR4$S_ADDR_AREA,ADJ$W_PNA(R0),R9
	BNEQ	55$				; If not, skip it
	CMPB	ADJ$B_BCPRI(R0),R2		; Higher priority?
	BLSSU	55$				; Branch if not
	BGTRU	52$				; Branch if so
	CMPW	ADJ$W_PNA(R0),R3		; If equal, compare addresses
	BLEQU	55$				; If address lower, skip it
52$:	MOVZWL	ADJ$W_PNA(R0),R3		; Update "current DRT address"
	MOVZBL	ADJ$B_BCPRI(R0),R2		; Update "highest priority"
	MOVL	R7,R8				; Update "current DRT index"
55$:	AOBLEQ	R1,R7,50$			; Loop thru all routers
	MOVL	R8,R1				; Return DRT index in R1
	POPR	#^M<R7,R8,R9>			; Restore registers
	RSB

	.SBTTL	ACT_QIO_SHUT - Shutdown the datalink
;+	
; ACT_QIO_SHUT   -  Shutdown the datalink 
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD ptr
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_QIO_SHUT:				; Shut down the datalink
	;
	;   Reset LPD fields
	;
	CLRBIT	LPD$V_INCOMING,LPD$W_STS(R6) ; Clear X.25 incoming call flag
	CLRB	LPD$B_XMTFLG(R6)	; Clear Transport xmit flags
	MOVB	#ADJ$C_PTY_UNK,-	; Clear "our node type" for this circuit
		LPD$B_ETY(R6)		; (setup later in DLL_UP)
	;
	;   Reset the main circuit adjacency, in the event that we got
	;   here as a result of an initialization failure (since if we
	;   exit run state, the main circuit adjacency is reset).
	;
	MOVZBL	LPD$B_PTH_INX(R6),R8	; Get LPD index
	BSBW	ADJ_DOWN		; Reset main circuit adjacency
	;
	;   Reset substate for circuit
	;
	MOVB	#NMA$C_LINSS_SYN,-	; Change to "synchronizing" substate
		LPD$B_SUB_STA(R6)	;
	BBC	#LPD$V_DLE,-		; If BC then not going down for
		LPD$W_STS(R6),10$	; "service" functions
	MOVB	#NMA$C_LINSS_ASE,-	; Init substate as "auto-service"
		LPD$B_SUB_STA(R6)	;
10$:	BBS	#LPD$V_X25,LPD$W_STS(R6),- ; If X.25, use DEACCESS, not SETMODE
		X25_SHUTDOWN
	;
	;   Cancel any outstanding QIOs in progress on the datalink
	;
	BSBW	RESET_CHAN		; Cancel any lingering I/O
	;
	;   Issue a SETMODE to reset the datalink
	;
	CLRL	R1			; Indicate no need to extend P1 buffer
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVZWL	#IO$_SETMODE!-		; Setup function code
		IO$M_SHUTDOWN,R0	;
	RSB				; Return to co-routine 

;
; Shutdown X.25 datalink using DEACCESS
;
X25_SHUTDOWN:
	$GETFLD	cri,l,use		; Get circuit usage
	BLBC	R0,X25_DEACCESS		; Error if not found
	CMPL	R8,#NMA$C_CIRUS_PER	; PVC?
	BEQL	X25_PVC_SHUTDOWN	; If so, use different shutdown
X25_DEACCESS:
	CLRBIT	LPD$V_PVC_ACCESSED,-	; Indicate circuit no longer ACCESSed
		LPD$B_PVCFLG(R6)
	CLRL	R1			; Indicate no need for QIO buffer
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVZWL	#IO$_DEACCESS,R0	; Setup function code
	RSB				; Issue QIO and exit

;
; Only issue a DEACCESS of a PVC if we are turning off the circuit.  This
; allows the X.25 level 2 software to retain its knowledge of the state of
; the circuit - so that if a "reset" is outstanding, our next reset will
; confirm it and keep the circuit in a consistent state.
;

X25_PVC_SHUTDOWN:
	$GETFLD	cri,l,sta		; Get circuit state
	BLBC	R0,X25_DEACCESS		; Error if not found
	CMPL	R8,#NMA$C_STATE_OFF	; Turning circuit off?
	BEQL	X25_DEACCESS		; If so, DEACCESS circuit
	MOVL	S^#LEV$C_IO_SUCC,R1	; Signal IO_SUCC to go to next state
	MOVL	#1,R0			; Allow state change
	RSB

	.SBTTL	ACT_QIO_STRT - Start the datalink
;+	
; ACT_QIO_STRT    -  Startup the datalink 
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R6	LPD ptr
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_QIO_STRT:				; Startup the datalink
	;
	;   If there is still an I/O pending to the circuit, then wait
	;   a bit for remaining I/O to be rundown.
	;
	;   This is done because we may still have messages on the AQB
	;   from NETDRIVER relating to this circuit left to process.
	;   This is done BEFORE the suppression timer so that minor
	;   delays in processing the AQB messages do not force circuit
	;   recycle to wait a full suppression interval.
	;
	TSTB	LPD$B_ASTCNT(R6)	; Any asynch activity outstanding?
	BNEQ	18$			; If yes, then cannot continue
	TSTB	LPD$B_IRPCNT(R6)	; Does NETDRIVER still have references?
	BEQL	20$			; If NEQ, then wait for NETDRIVER
					; to wake us up with CRD event
18$:	MOVL	#LEV$C_EXIT,R1		; Exit state table immediately
	BRW	90$			; Exit inhibiting state change
20$:	;
	;   Start the "start suppression" timer to prevent the circuit from
	;   restarting too rapidly.  If the RECALL TIMER parameter is
	;   specified, use that delay.  Otherwise, use a fixed timer value.
	;
	BBCS	#LPD$V_STRTIM,-		; If BS then timer is already ticking
		LPD$W_STS(R6),10$
	BRW	80$
10$:	MOVZBL	LPD$B_PTH_INX(R6),R1	; Get LPD index
	ASHL	#16,R1,R1		; Shift into upper word
	MOVW	#<<WQE$C_QUAL_DLL>@8>!-	; Overlay QUAL and EVT fields
		   LEV$C_STRT_TIM,R1	;
	MOVAB	STRT_TIMER_TICK,R2	; Setup action routine address
	$GETFLD	cri,l,rct		; Get RECALL TIMER parameter
	BLBS	R0,15$			; If not set, use default timer
	MOVL	#TR$C_TIM_RESTRT,R8	; Provide a default value
15$:	EMUL	R8,#10*1000*1000,#0,R3	; Set start supression timer
	BSBW	WQE$RESET_TIM		; Reset the timer
	MOVL	NET$GL_PTR_VCB,R4	; Recover RCB address	
	;
	;   Check if the associated line is turned on
	;
	BSBW	CHK_CIRC_START		; Check if circuit can be started
	BLBC	R0,80$			; If not allowed, exit
	;
	;   Increment the number of startup attempts we've made in trying
	;   to get this circuit initialized.  (This counter is used for
	;   outgoing X.25 calls to prevent too many charges from piling
	;   up.  It also can be used for statistics).
	;
	INCB	LPD$B_STARTUPS(R6)	; Increment number of startup attempts
	;
	;   If the state is set to SERVICE, setup for direct-access mode
	;
	$GETFLD	cri,l,sta		; Get the "operater" state
	BLBC	R0,60$			; If LBC then assume "OFF" state
	CMPL	S^#NMA$C_STATE_SER,R8	; Service state ?
	BNEQ	60$			; If NEQ then no
	SETBIT	LPD$V_DLE,LPD$W_STS(R6)	; Else setup for direct-access
60$:	;
	;   For X.25 circuits, use different startup sequence
	;
	BBC	#LPD$V_X25,LPD$W_STS(R6),65$ ; Branch if not X.25
	BRW	X25_STARTUP		; Use different startup sequence
	;
	;   If LPD$_TOGGLE is set, then we must toggle the controller or
	;   if XM$_ERR_FATAL is set then we must restart the controller.
	;   This check must be made in the UCB.
	;
65$:	MOVZBL	LPD$B_PLVEC(R6),R2	; Get PLVEC index
	MOVL	LPD$L_UCB(R6),R0	; Get device UCB
	BEQL	70$			; If EQL then none
	BBSC	#LPD$V_TOGGLE,-		; Br if we must toggle the line
		LPD$W_STS(R6),67$	;
	CMPB	PLVEC$AB_DEV[R2],- 	; DMC11 ?
		#DEVTRN$C_DEV_DMC	;
	BEQL	70$			; If EQL yes, ignore XM$V_ERR_FATAL
	BBC	#XM$V_ERR_FATAL,-	; If BS the fatal controller error,
		UCB$L_DEVDEPEND(R0),70$	; must toggle controller
67$:	BSBW	TOGGLE_LINE		; Toggle the controller
					; ...ignore errors
	;
	;   Reset the Circuit characteristics
	;
70$:	$CNFFLD	cri,s,chr,R9		; Identify characteristics buffer
	MOVZWL	LPD$W_CHAN(R6),R2	; Get I/O channel
	CLRL	R1			; Clear illegal I/O modifier mask
	BSBW	NET$SET_QIOW		; Get buffer and issue $QIOW
	BLBS	R0,200$			; If LBS then okay, br to continue
80$:	MOVL	#LEV$C_NO_EVT,R1	; Nothing else to do
90$:	CLRB	R0			; Don't allow state change
	RSB
200$:	;
	;   Setup the "input packet limiter" value based on the number of
	;   receive buffers assigned to the circuit's controller.  This is a
	;   heuristic based on the idea that controller's requiring more
	;   receive buffering (fast lines, satellite lines) also should be
	;   allowed more local packet output buffering in order to prevent
	;   severe performance degradation.
	;
	$GETFLD	cri,l,mwi		; Get maximum X.25 window size
	BLBS	R0,210$			; If set, use it as "input packet
					; limiter" for non-X.25 circuit
	PUSHR	#^M<R10,R11>		; Save regs
	MOVL	NET$GL_CNR_PLI,R11	; Get PLI root block
	CLRL	R10			; Search from begining of list
	MOVZBL	LPD$B_PLVEC(R6),R8	; Search key is the PLVEC index
	$SEARCH	eql,pli,l,plvec		; Find PLI's CNF block
	BLBC	R0,205$			; If LBC then not found
	$GETFLD	pli,l,bfn		; Get number of receive buffers
205$:	POPR	#^M<R10,R11>		; Restore regs
	BLBS	R0,210$			; If LBS then <pli,l,bfn> value exists
	MOVL	#4,R8			; Use 4 as the default
210$:	MOVB	R8,LPD$B_XMT_IPL(R6)	; Use it as input packet limiter
	;
	;   Issue startup QIO
	;
	CLRL	R1			; No I/O buffer needed
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVZBL	LPD$B_PLVEC(R6),R7	; Get PLVEC index
	CMPB	PLVEC$AB_DEV[R7],-	; DMC?
		#DEVTRN$C_DEV_DMC
	BNEQ	240$			; If so,
	MOVL	R8,WQE$C_LENGTH+P3(R2)	; Setup DMC # buffers parameter in P3
240$:	MOVZWL	#IO$_SETMODE!-		; Setup the default function code
		 IO$M_STARTUP,R0	;
	RSB				; Return to issue QIO

;
; The start supression timer has expired.  Another attempt at starting the
; datalink should be initiated.
;

STRT_TIMER_TICK:
	BSBW	FIND_WQE_CTX		; Locate CNF, LPD, ADJ blocks
	BLBC	R0,10$			; If LPD no longer exists, skip event
	CLRBIT	LPD$V_STRTIM,LPD$W_STS(R6) ; Indicate timer no longer running
	BSBW	PROC_EVT		; Process the event
10$:	BSBW	KILL_WQE		; Deallocate the WQE
	RSB				; Return to caller


;
; Startup X.25 datalink
;

X25_STARTUP:
	$GETFLD	cri,l,mwi		; Get maximum X.25 window size
	BLBS	R0,62$			; Use it, if specified
	MOVL	#4,R8			; Use default value of 4
62$:	MOVB	R8,LPD$B_XMT_IPL(R6)	; Set input packet limiter
	$GETFLD	cri,l,use		; Get circuit usage parameter
	BLBC	R0,80$			; If not present, defaulting error
	$DISPATCH R8,<-			; Dispatch on X.25 circuit usage
	   <NMA$C_CIRUS_PER,100$>,-	; Permanent virtual circuit
	   <NMA$C_CIRUS_OUT,200$>,-	; Outgoing switched virtual circuit
	   <NMA$C_CIRUS_INC,300$>,-	; Wait for incoming call
	>
80$:	MOVL	#LEV$C_NO_EVT,R1	; No more events
	CLRL	R0			; Do not allow state change
	RSB

;
; Schedule PVC startup event.  This is done as a separate event because
; PVC startup is a multiple step process, since 3 QIOs have to be issued
;
100$:	BBS	#LPD$V_PVC_ACCESSED,-	; Is circuit already ACCESSed?
		LPD$B_PVCFLG(R6),150$	; then skip this step
	BISB	#LPD$M_PVC_ACCESS!-	; For X.25 startup, schedule access,
		 LPD$M_PVC_RESTRT!-	; restart, and
		 LPD$M_PVC_RESET,-	; reset operations for the
		LPD$B_PVCFLG(R6)	; next time we start the X.25 datalink
	MOVL	#LEV$C_PVC_START,R1	; Signal PVC startup needed
	MOVL	#1,R0			; Allow state change
	RSB

150$:	MOVL	#LEV$C_LIN_UP,R1	; Signal circuit is "up"
	MOVL	#1,R0			; Allow state change
	RSB

;
; Make outgoing switched call for X.25 datalink
;
200$:	;
	;   If we have attempted to make the outgoing call too many times
	;   (controlled by the MAXIMUM RECALLS parameter), then give up
	;   and marked the circuit "failed".  This is done, rather than
	;   turning off the circuit and deallocating the LPD, so that
	;   the counters remain around afterwards.
	;
	$GETFLD	cri,l,mrc		; Get MAXIMUM RECALLS parameter
	BLBC	R0,210$			; If not set, allow infinite retry
	CMPB	LPD$B_STARTUPS(R6),R8	; Have we exceed the maximum?
	BLEQU	210$			; If not, let it go
	CLRB	LPD$B_STARTUPS(R6)	; Reset # startup attempts
	MOVL	#LEV$C_FAILED,R1	; Mark circuit "failed"
	CLRL	R0			; Do not change state
	RSB				; Process next event
	;
	;   Call PSI to make the call
	;
210$:	$GETFLD	cri,l,mbl		; Get MAXIMUM DATA parameter
	PUSHL	R8			; Push value (0 if not set)
	$GETFLD	cri,l,mwi		; Get MAXIMUM WINDOW parameter
	PUSHL	R8			; Push value (0 if not set)
	$GETFLD	cri,s,num		; Get remote DTE address
	BLBC	R0,290$			; If not present, defaulting error
	MOVL	SP,R9			; Point to MWI, MBL longwords
	MOVL	#8+21+15,R1		; Set length of extra QIO buffer
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	R3,WQE$C_LENGTH+P2(R2)	; Set P2 to NCB descriptor
	MOVAB	8(R3),R0		; Point to actual P2 buffer
	MNEGL	R0,(R3)+		; Construct NCB descriptor
	MOVL	R0,(R3)+
	TSTL	(R9)			; MAXIMUM WINDOW specified?
	BEQL	230$			; Branch if not
	MOVW	#8,(R3)+		; Set size of item
	MOVW	#PSI$C_NCB_WINSIZE,(R3)+ ; Set item code
	MOVL	(R9),(R3)+		; Store maximum window size
230$:	TSTL	4(R9)			; MAXIMUM DATA specified?
	BEQL	240$			; Branch if not
	MOVW	#8,(R3)+		; Set size of item
	MOVW	#PSI$C_NCB_PKTSIZE,(R3)+ ; Set item code
	MOVL	4(R9),(R3)+		; Store maximum packet size
240$:	ADDW3	#5,R7,(R3)+		; Set size of item
	MOVW	#PSI$C_NCB_REMDTE,(R3)+	; Set item code
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVB	R7,(R3)+		; Move byte count of DTE string
	MOVC	R7,(R8),(R3)		; Move DTE address into NCB
	POPR	#^M<R2,R4,R5>		; Restore registers
	ADDL	R3,@WQE$C_LENGTH+P2(R2)	; Set size in P2 descriptor
	MOVZWL	#IO$_ACCESS,R0		; Setup I/O function code
	JSB	@(SP)+			; Queue I/O
290$:	ADDL	#8,SP			; Pop max window & max data
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	RSB				; Exit with R0 set true/false

;
; Mark the circuit as being able to accept incoming X.25 calls
;
300$:	SETBIT	LPD$V_INCOMING,LPD$W_STS(R6) ; Mark circuit waiting for call
	BRW	80$			; Exit without any state change

	.SBTTL	ACT_PVC_START - Start an X.25 PVC in multiple steps
;+
; ACT_PVC_START - Start a PVC in multiple steps
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;
; Outputs:
;
;	R1 = Next event to be processed
;	R0 = True if state change allowed, false if not.
;-
ACT_PVC_START:
;
;   Determine the next step to be done in the startup process
;
	FFS	#0,#4,LPD$B_PVCFLG(R6),R2 ; Get next thing we have to do
					; (NOTE: only use low nibble)
	BEQL	900$			; If nothing left, startup is complete
	$DISPATCH R2,<-			; Dispatch on flag
	   <LPD$V_PVC_ACCESS,110$>,-	; Issue the IO$_ACCESS function
	   <LPD$V_PVC_RESTRT,120$>,-	; Issue a "restart confirmation"
	   <LPD$V_PVC_RESET,130$>,-	; Issue a "reset" or "reset confirmation"
	>
900$:	MOVL	#LEV$C_LIN_UP,R1	; Signal that startup is complete
	MOVL	#1,R0			; Allow state change
	RSB
;
; Issue IO$_ACCESS function to access the PVC
;
110$:	$GETFLD	cri,s,nam		; Get PVC name
	BLBC	R0,80$			; If not present, CNF is not right
	CLRBIT	LPD$V_PVC_ACCESS,LPD$B_PVCFLG(R6) ; Indicate this work is done
	MOVL	#8+5+15,R1		; Set length of extra QIO buffer
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	R3,WQE$C_LENGTH+P2(R2)	; Set P2 to NCB descriptor
	ADDL3	#5,R7,(R3)+		; Construct NCB descriptor
	MOVAB	4(R3),(R3)+
	ADDW3	#5,R7,(R3)+		; Set size of item
	MOVW	#PSI$C_NCB_PVCNAM,(R3)+	; Set item code
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVB	R7,(R3)+		; Move byte count of PVC name
	MOVC	R7,(R8),(R3)		; Move PVC name into NCB
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	MOVZWL	#IO$_ACCESS,R0		; Setup I/O function code
	MOVB	#LEV$C_PVC_START,WQE$B_EVT(R2) ; Return here if I/O successful
	RSB				; Issue I/O and exit
;
; Issue "restart confirmation" on the PVC, and ignore any error if there
; is no restart to confirm.  This is done because the PVC is always active,
; and a restart operation puts the circuit into a known state.
;
120$:	SETBIT	LPD$V_PVC_ACCESSED,-	; Indicate PVC now ACCESSed
		LPD$B_PVCFLG(R6)
	CLRBIT	LPD$V_PVC_RESTRT,LPD$B_PVCFLG(R6) ; Indicate this work is done
	CLRL	R1			; No QIO buffer needed
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	#PSI$C_RESTART,WQE$C_LENGTH+P4(R2) ; Set P4 to "restart"
	MOVZWL	#IO$_NETCONTROL,R0	; Set I/O function code
	MOVB	#LEV$C_PVC_START,WQE$B_EVT(R2) ; Return here if I/O successful
	MOVB	#LEV$C_PVC_START,WQE$L_PM2(R2) ; Return here if I/O fails too
	RSB				; Issue I/O and exit
;
; Issue "reset" or "reset confirmation" on the PVC, and ignore any errors.
; This is done to clear any outstanding received messages from the previous
; user of the PVC.
;
130$:	CLRBIT	LPD$V_PVC_RESET,LPD$B_PVCFLG(R6) ; Indicate this work is done
	CLRL	R1			; No QIO buffer needed
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	#PSI$C_RESET,WQE$C_LENGTH+P4(R2) ; Set P4 to "reset"
	MOVZWL	#IO$_NETCONTROL,R0	; Set I/O function code
	MOVB	#LEV$C_PVC_START,WQE$B_EVT(R2) ; Return here if I/O successful
	MOVB	#LEV$C_PVC_START,WQE$L_PM2(R2) ; Return here if I/O fails too
	RSB				; Issue I/O and exit

;
; Come here if an error was encountered before beginning the startup
; to abort the operation, and wait until the supression timer causes it to
; be tried again.
;
80$:	MOVL	#LEV$C_NO_EVT,R1	; No more events
	CLRL	R0			; Don't allow state change
	RSB

	.SBTTL	ACT_X25_CALL - Accept incoming X.25 call
;+
; ACT_X25_CALL - Accept incoming X.25 call
;
; This circuit has already been determined to be waiting for an incoming
; call and allocated for that purpose.  All we have to do for this event
; is issue the ACCEPT QIO.  On successful I/O completion, the transition
; will be made to the Routing Initialization state.
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R6 = LPD address
;	R5 = WQE address
;	R4 = RCB address
;
; Outputs:
;
;	R1 = Next event to be processed
;	R0 = True if state change allowed, false if not.
;-
ACT_X25_CALL:
	MOVZWL	WQE$L_PM2(R5),R1	; Get size of X.25 NCB
	ADDL	#8,R1			; Add in size of NCB descriptor
	BSBW	NET$DLL_QIO_CO		; Allocate and init WQE (co-routine)
	MOVL	R3,WQE$C_LENGTH+P2(R2)	; Set P2 to NCB descriptor
	MOVZWL	WQE$L_PM2(R5),(R3)+	; Construct NCB descriptor
	MOVAB	4(R3),(R3)+
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC	WQE$L_PM2(R5),-		; Move NCB into I/O WQE
		WQE$C_LENGTH(R5),(R3)
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	BSBB	CHK_CIRC_START		; Check if circuit can be started
	BLBC	R0,10$			; Branch if not
	MOVZWL	#IO$_ACCESS!IO$M_ACCEPT,R0 ; Setup I/O function code
	RSB				; Issue QIO and exit
;
; Circuit is not in a state to be started - change QIO to be a "REJECT"
; and on I/O completion, cause the circuit to be recycled.
;
10$:	MOVZWL	#IO$_ACCESS!IO$M_ABORT,R0 ; Setup I/O function code
	MOVB	#LEV$C_REQ_SHUT,WQE$B_EVT(R2) ; Recycle circuit on success
	RSB				; Issue QIO and exit

	.SBTTL	CHK_CIRC_START - Check if circuit can be started
;+
; CHK_CIRC_START - Check if circuit can be started
;
; Determine if the circuit can be started by examining the associated
; line state, and by making sure that the ACP's state is on.
;
; Inputs:
;
;	R4 = RCB address
;	R6 = LPD address
;
; Outputs:
;
;	R0 = True if startup allowed, else false
;
;	No other registers are destroyed.
;-
CHK_CIRC_START:
	PUSHL	R2			; Save registers
	;
	;   Check to make sure that the associated line is "on"
	;
	MOVZBL	LPD$B_PLVEC(R6),R2	; Get the associated line index
	JSB	NET$GET_VEC2		; Setup the line
	BLBC	R0,80$			; If LBC then setup failed
	BBS	#LPD$V_X25,LPD$W_STS(R6),25$ ; If X.25, there is no assoc. line
	CMPB	PLVEC$AB_STATE[R2],-	; Is the line "on"
		#NMA$C_STATE_ON		;
	BNEQ	80$			; If NEQ no, can't start circuit
	;
	;   Check to make sure that the ACP state is not "off" or "init".
	;
25$:	$DISPATCH TYPE=B,RCB$B_STI(R4),<-
		<ACP$C_STA_I, 80$>,-	; Initializing
		<ACP$C_STA_N, 50$>,-	; On
		<ACP$C_STA_R, 50$>,-	; Restricted
		<ACP$C_STA_S, 30$>,-	; Shut
		<ACP$C_STA_F, 80$>,-	; Off
		<ACP$C_STA_H, 80$>,-	; Hibernating (due to bug)
	>
30$:	TSTW	RCB$W_MCOUNT(R4)	; Time to shut down ?
	BEQL	80$			; If so, go away
50$:	MOVL	#1,R0			; Successful
	BRB	90$

80$:	CLRL	R0			; Do not allow circuit on
90$:	POPL	R2			; Restore registers
	RSB

	.SBTTL	TOGGLE_LINE - Shutdown and startup line
;+
; TOGGLE_LINE - Toggle line state
;
; The line is indicating a fatal device error.  Turn the device
; OFF and ON in order to re-initialize it.
;
; Inputs:
;
;	R2 = PLVEC index
;
; Outputs:
;
;	R0 = Status from startup operation
;-
TOGGLE_LINE:				; Toggle line state
	PUSHR	#^M<R2,R5,R6,R10,R11>	; Save crucial regs
	MOVL	R2,R6			; Move PLVEC pointer to safe reg
	MOVL	NET$GL_CNR_PLI,R11	; Get PLI root block
	CLRL	R10			; Search from begining of list
	MOVL	R6,R8			; Search key is the PLVEC index
	$SEARCH	eql,pli,l,plvec		; Find PLI's CNF block
	BLBC	R0,100$			; If LBC then not found
	MOVZBL	PLVEC$AB_STATE[R6],-(SP); Save previous state
	MOVB	#NMA$C_STATE_OFF,-	; Prepare to turn line off
		PLVEC$AB_STATE[R6]	;
	BSBB	110$			; Turn the line off
					; ...ignore errors
	CVTLB	(SP)+,-			; Prepare to turn line back on
		PLVEC$AB_STATE[R6]	;
	BSBB	110$			; Turn the line on
100$:	POPR	#^M<R2,R5,R6,R10,R11>	; Restore regs
	RSB				; Return status in R0

110$:	MOVZWL	PLVEC$AW_CHAN[R6],R2	; Get I/O channel
	CLRL	R1			; Clear "illegal" I/O fct code mask
	$CNFFLD	pli,s,chr,R9		; Setup characteristics buffer i.d.
	BSBW	NET$SET_QIOW		; Turn the line on
	RSB

	.SBTTL	ACT_XMT - Transmit pending messages
;+
; ACT_XMT   -	Conditionally xmit a message
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R7	ADJ address
;		R6	LPD address
;		R5	WQE address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered.
;-
ACT_XMT:				; Xmit message if possible
	BSBW	CHK_IO			; Okay to xmit?
	BLBC	R0,10$			; If LBC no
	FFS	#0,#8,LPD$B_XMTFLG(R6),R2 ; Get xmit flag
	BEQL	10$			; If EQL then none set
	$DISPATCH R2,<-			; Dispatch on xmit flag
	    <LPD$V_XMT_DALLY,XMT_DALLY>,- ; Wait to send start message
	    <LPD$V_XMT_STR,  XMT_STR>,-	; Transport "Start" message
	    <LPD$V_XMT_VRF,  XMT_VRF>,-	; Transport "Verification" message
	    <LPD$V_XMT_RT,   XMT_RT>,-	; Transport "Routing" message
	    <LPD$V_XMT_ART,  XMT_ART>,- ; Transport "Area Routing" message
	    <LPD$V_XMT_IDLE, 100$>,-	; All Transport init messages xmitted
	>
10$:	MOVL	#LEV$C_EXIT,R1		; Nothing to do, exit state table
	MOVL	#1,R0			; Allow state change
	RSB				;

100$:	CLRBIT	LPD$V_XMT_IDLE,-	; Clear the flag
		 LPD$B_XMTFLG(R6)	;
	MOVL	S^#LEV$C_XMT_IDLE,R1	; Xmitter is idle during Transport init
	MOVL	#1,R0			; Allow state change
	RSB				;

	.SBTTL	XMT_DALLY - Dally before sending start message
;+
; XMT_DALLY - Dally before sending start message
;
; This routine is called to dally for a while before sending out the
; Start message.  This is so that we can properly initialize with older
; nodes which do not properly parse/ignore Phase IV start messages.  By
; dallying a while before sending, it gives us a chance to hear his start
; message, and send the correct version of the message based on the type
; of message he sends.
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R7 = ADJ address
;	R6 = LPD address
;
; Outputs:
;
;	None
;-
XMT_DALLY:
	MOVZWL	LPD$W_PTH(R6),R1	; Get LPD ID
	ASHL	#16,R1,R1		; Shift into upper word (REQIDT)
	MOVW	#<WQE$C_QUAL_DLL@8>!-	; Setup timer qualifier
		LEV$C_NO_EVT,R1		; and timer event
	MOVQ	#TR$C_TIM_DALLY*-	; Set dally timer
		10*1000*1000,R3
	MOVAB	NET$DLL_PRC_WQE,R2	; and process event when it fires
	BSBW	WQE$RESET_TIM		; Start timer
	CLRBIT	#LPD$V_XMT_DALLY,-	; We've done this now
		LPD$B_XMTFLG(R6)
	MOVL	#LEV$C_EXIT,R1		; Exit state table immediately
	MOVL	#1,R0			; Allow state change (if any)
	RSB

	.SBTTL	XMT_STR - Transmit start message
;+
; XMT_STR -	Build and transmit a Transport "start" message
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R7	ADJ address
;		R6	LPD address
;		R4	RCB address
;
; OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other registers may be clobbered
;-
XMT_STR:				; Xmt a transport initialization msg
	ASSUME	TR3C_STR_LNG  LE TR2C_STR_MXL

	MOVZBL	#TR2C_STR_MXL,R1	; Setup size of P1 buffer
	BSBW	NET$DLL_QIO_CO		; Call co-routine to init WQE
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to buffer
	MNEGL	R3,WQE$C_LENGTH+P2(R2)	; Bias I/O buffer size
	MOVL	NET$GL_CNR_LNI,R11	; Set CNR for local data base
	MOVL	NET$GL_PTR_LNI,R10	; Get LNI CNF
	MOVZBL	LPD$B_ETY(R6),R0	; Get our (adapted) "node type"
	MOVZBL	PTY_TO_PHASE[R0],R0	; Get our (adapted) "phase"
	$DISPATCH R0,<-
		<2,STR2>,-		; Phase II
		<3,STR3>,-		; Phase III
		<4,STR4>>		; Phase IV
	MOVL	S^#LEV$C_EXIT,R1	; Don't do anything
	CLRB	R0			; Inhibit state change
	RSB				; Return with LBC in R0 
	;
	;   Build and transmit Phase II "init" message
	;
STR2:	PUSHL	R7			; Save registers
	MOVB	#TR2C_MSG_INI,(R3)+	; Enter message type code
	MOVB	#TR2C_INI_STR,(R3)+	; Enter message sub-type code 
					;
	EXTZV	#TR4$V_ADDR_DEST,-	; Get our address (without area)
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0
	MULW	#2,R0			; Start converting address to EX-2 field
	DIVB2	#2,R0			; Now bits 7-15 are shifted
	BISW3	#128,R0,(R3)+		; Set the extend bit and enter it
	$CNFFLD	lni,s,nam,R9		; Identify local node name field
	BSBW	MOVIT			; Fetch and enter the string
	MOVB	#TR2C_STR_FCT,(R3)+	; Enter supported functions
	MOVB	#TR2C_STR_REQ!-		;
		 TR2M_REQ_VRF,(R3)+	; Enter 'requests'
	MOVW	LPD$W_BUFSIZ(R6),(R3)+	; Enter block size
	MOVW	RCB$W_ECLSEGSIZ(R4),(R3)+ ; Enter NSP segment size
	MOVW	RCB$W_MAX_LNK(R4),(R3)+	  ; Enter max links
	MOVW	#^X<0103>,(R3)+		; Enter PhaseII compatable routing
	CLRB	(R3)+			; version (3.1.0)
	MOVW	#^X<0103>,(R3)+		; Enter PhaseII compatable NSP version
	CLRB	(R3)+			; (3.1.0)
	$CNFFLD	lni,s,ide,R9		; Identify system version field
	BSBB	MOVIT			; Fetch and enter the string
	POPL	R7			; Restore registers
	BRB	XMT			; Return to co-routine to xmt the msg
	;
	;   Build Phase III "start" message
	;
STR3:	MOVB	#TR3C_MSG_STR,(R3)+	; Enter msg type code
	EXTZV	#TR4$V_ADDR_DEST,-	; Get our address (without area)
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0
	MOVW	R0,(R3)+		; Enter the local address in msg
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<-
		<ADJ$C_PTY_PH3,2$>,-	; Phase III routing
		<ADJ$C_PTY_PH3N,3$>>	; Phase III endnode
2$:	MOVB	#TR3C_NTY_PH3,(R3)+	; Set local node type (Level 1 Routing)
	BRB	10$
3$:	MOVB	#TR3C_NTY_PH3N,(R3)+	; Set local node type (Nonrouting)
10$:	SETBIT	#TR3V_REQ_VRF,-1(R3)	; request for verification
	MOVW	LPD$W_BUFSIZ(R6),(R3)+	; Enter block size
	MOVW	#TR3C_TIVER,(R3)+	; Enter routing version number
	MOVB	#0,(R3)+		; Enter user ECO number
	CLRB	(R3)+			; Enter the verification seed
	BRB	XMT			; Transmit the message
	;
	;   Build and transmit Phase IV "start" message
	;
STR4:	MOVB	#TR4C_MSG_STR,(R3)+	; Enter msg type code
	MOVW	RCB$W_ADDR(R4),(R3)+	; Enter the local address
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<-
		<ADJ$C_PTY_AREA,1$>,-	; Phase IV level 2 routing
		<ADJ$C_PTY_PH4,2$>,-	; Phase IV routing
		<ADJ$C_PTY_PH4N,3$>>	; Phase IV endnode
2$:	MOVB	#TR4C_NTY_ROU,(R3)+	; Set local node type (Level 1 Routing)
	BRB	10$
1$:	MOVB	#TR4C_NTY_ARO,(R3)+	; Set local node type (Level 2 Routing)
	BRB	10$
3$:	MOVB	#TR4C_NTY_NROU,(R3)+	; Set local node type (Nonrouting)
10$:	SETBIT	#TR4V_REQ_VRF,-1(R3)	; Set request for verification
	MOVW	LPD$W_BUFSIZ(R6),(R3)+	; Enter block size
	MOVW	#TR4C_TIVER,(R3)+	; Enter routing version number
	MOVB	#0,(R3)+		; Enter user ECO number
	MOVW	LPD$W_INT_TLK(R6),(R3)+	; Enter hello timer
	CLRB	(R3)+			; No optional data
	;
	;   Transmit message
	;
XMT:	ADDL	R3,WQE$C_LENGTH+P2(R2)	; Calculate I/O buffer size
	MOVL	S^#IO$_WRITELBLK,R0	; Setup I/O function
	CLRBIT	LPD$V_XMT_STR,-		; No further need to send message
		 LPD$B_XMTFLG(R6)	;
	RSB				; Return to co-routine, then to caller

	
MOVIT:	BSBW	CNF$GET_FIELD		; Fetch the string
	MOVB	R7,(R3)+		; Enter count field
	BRB	MOVITU			; Go to end of loop
MC1:	MOVB	(R8)+,(R3)+		; Enter text without clobbering  R0-R5
MOVITU:	SOBGEQ	R7,MC1			; Loop for each character
	RSB

	.SBTTL	XMT_VRF - Transmit verification message
;+
; XMT_VRF   - Build and transmit Transport verification message
;
; INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R7	ADJ ptr
;		R6	LPD ptr
;		R4	RCB ptr
;
; OUTPUTS:	R5	Unchanged
;		R1	Next "event longword" to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other registers may be clobbered
;-
XMT_VRF:				; Xmt Transport verification message
	MOVL	NET$GL_CNR_NDI,R11	; Set CNR for remote node data base
	MOVZWL	ADJ$W_PNA(R7),R8	; Get partner's node address
	BNEQ	20$			; Not yet known  if EQL
	MOVL	S^#LEV$C_EXIT,R1	; Partner is not yet known, - i.e.,
					;  no 'start' message yet
	CLRB	R0			; Inhibit state change
	RSB				; Return with LBC in R0 
20$:	;
	;   Get the transmit verification password
	;
	PUSHL	R7			; Save ADJ address
	BSBW	NET$NDI_BY_ADD		; Find NDI CNF for partner node
	CLRL	R7			; Zero password string size assuming
					; no NDI was found
	BLBC	R0,30$			; If LBC then no NDI was found
	$GETFLD	ndi,s,tpa		; Get transmit password descriptor
					; R7,R8 = 0 on return if field is null 
30$:	MOVQ	R7,R8			; Pass password descriptor in R8/R9
	POPL	R7			; Restore ADJ address
	;
	;   Build and transmit the message
	;
	MOVZBL	#TR_C_VRF_LNG+2,R1	; Setup size of I/O buffer   ;! +2 is tmp
	BSBW	NET$DLL_QIO_CO		; Call co-routine to init WQE
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to buffer
	MNEGL	R3,WQE$C_LENGTH+P2(R2)	; Bias I/O buffer size
	MOVZBL	LPD$B_ETY(R6),R0	; Get our (adapted) "node type"
	MOVZBL	PTY_TO_PHASE[R0],R0	; Get our (adapted) "phase"
	$DISPATCH R0,<-
		<2,60$>,-		; Phase II
		<3,50$>,-		; Phase III
		<4,40$>>		; Phase IV
	MOVL	S^#LEV$C_EXIT,R1	; Don't do anything
	CLRB	R0			; Inhibit state change
	RSB				; Return with LBC in R0 
	;
	;   Build Phase IV header
	;
40$:	MOVB	#TR4C_MSG_VRF,(R3)+	; Enter message type code
	MOVW	RCB$W_ADDR(R4),(R3)+	; Enter local node address
	MOVB	R8,(R3)+		; Enter length of password
	MOVL	R8,R0			; Setup msg psw field size
	BRB	70$			; Continue in common
	;
	;   Build Phase III header
	;
50$:	MOVB	#TR3C_MSG_VRF,(R3)+	; Enter message type code
	EXTZV	#TR4$V_ADDR_DEST,-	; Get our address (without area)
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0
	MOVW	R0,(R3)+		; Enter local node address
	MOVB	R8,(R3)+		; Enter length of password
	MOVL	R8,R0			; Setup msg psw field size
	BRB	70$			; Continue in common
	;
	;   Build Phase II header
	;
60$:	MOVB	#TR2C_MSG_INI,(R3)+	; Enter message type code
	MOVB	#TR2C_INI_VRF,(R3)+	; Enter message sub-type code 
	MOVL	#8,R0			; Setup msg psw field size
	;
	;   Move the password
	;
70$:	PUSHR	#^M<R2,R4,R5>		; Save regs
	MOVC5	R8,(R9),#0,R0,(R3)	; Move the password - null fill
	POPR	#^M<R2,R4,R5>		; Restore regs
	ADDL	R3,WQE$C_LENGTH+P2(R2)	; Calculate I/O buffer size
	MOVL	S^#IO$_WRITELBLK,R0	; Setup I/O function
	CLRBIT	LPD$V_XMT_VRF,-		; No further need to send message
		 LPD$B_XMTFLG(R6)	;
	RSB				; Return to co-routine, then to caller

	.SBTTL	XMT_RT - Transmit a routing message
;+
; XMT_RT - Transmit a routing message
;
;   INPUTS:	R11	CRI CNR ptr
;		R10	CRI CNF ptr
;		R7	ADJ ptr
;		R6	LPD ptr
;		R4	RCB address
;
;   OUTPUTS:	R5	Unchanged
;		R1	Next event to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		All other regs may be clobbered
;-
XMT_RT:					; Xmit routing message
	$DISPATCH LPD$B_ETY(R6),TYPE=B,<- ; If we are an endnode,
		<ADJ$C_PTY_PH4N,110$>,-	; never send rtg messages
		<ADJ$C_PTY_PH3N,110$>>
	BBS	#LPD$V_BC,-		; If broadcast circuit, always
		LPD$W_STS(R6),XMT_RT4	; send Phase IV routing messages
	MOVZBL	LPD$B_ETY(R6),R0	; Get our (adapted) "node type"
	CMPB	PTY_TO_PHASE[R0],#4	; Are we supposed to be Phase IV?
	BEQL	XMT_RT4			; If so, go to Phase IV routine
	;
	;    Allocate and setup the buffer
	;
	MOVZWL	RCB$W_MAX_ADDR(R4),R1	; Get number of nodes
	ADDL	R1,R1			; Need 1 word per entry
	ADDL	#3+2,R1			; Add in header and trailer
	BSBW	NET$DLL_QIO_CO		; Call co-routine to allocate buffer
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to I/O buffer
	MNEGL	R3,WQE$C_LENGTH+P2(R2)	; Bias the I/O buffer length
	;
	;   Build the message
	;
	PUSHL	R7			; Save registers
	MOVB	#TR3C_MSG_RT,(R3)+	; Enter type code
	EXTZV	#TR4$V_ADDR_DEST,-	; Get our address (without area)
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0
	MOVW	R0,(R3)+		; Enter source node address
	CLRL	R7			; Init check sum
	MOVZWL	RCB$W_MAX_ADDR(R4),R0	; Get number of nodes
	MOVL	#1,R1			; Init the node index
50$:	MOVW	NET$AW_MIN_C_H[R1],R8	; Get cost-hops to the node
	MOVW	R8,(R3)+		; Enter cost-hops to the node
	ADDW	R8,R7			; Include in checksum
	ADWC	#0,R7			; 1's complement add - needs
					; "end around carry"
	INCL	R1			; Advance the node index
	SOBGTR	R0,50$			; Loop for each node
	MOVW	R7,(R3)+		; Enter the check sum
	POPL	R7			; Restore registers
	ADDL	R3,WQE$C_LENGTH+P2(R2)	; Setup I/O buffer size
	MOVL	S^#IO$_WRITELBLK,R0	; Setup I/O fct code
	CLRBIT	LPD$V_XMT_RT,-		; No further need to send message
		 LPD$B_XMTFLG(R6)	;
	RSB				; Return to co-routine to xmit

;
; We are an endnode.  Don't send routing messages.
;

110$:	CLRBIT	LPD$V_XMT_RT,-		; No further need to send message
		 LPD$B_XMTFLG(R6)	;
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
	RSB

	.SBTTL	XMT_RT4 - Transmit a Phase IV routing message
;+
; XMT_RT4 - Transmit a Phase IV segmented routing message
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	R1 = Next event to be processed
;	R0 = True if state change allowed, else false.
;-
XMT_RT4:
	TSTB	LPD$B_SRM_LEFT(R6)	; Any bits left to check?
	BNEQ	5$			; Branch if so
3$:	CLRBIT	LPD$V_XMT_RT,LPD$B_XMTFLG(R6) ; Indicate "transmission" done
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
	RSB
5$:	;
	;   Allocate and setup the buffer
	;
	MOVZWL	ADJ$W_BUFSIZ(R7),R9	; Get adjacent node's buffer size
	BNEQ	8$			; Branch if "known"
	MOVZWL	LPD$W_BUFSIZ(R6),R9	; (& should never get here)
					; Else, use our own buffer size
8$:	MOVL	R9,R1			; Indicate size of extra buffer
	BSBW	NET$DLL_QIO_CO		; Call co-routine to allocate buffer
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to I/O buffer
	MNEGL	R3,WQE$C_LENGTH+P2(R2)	; Bias the I/O buffer size
	SUBL3	#6,R9,R8		; Subtract out required overhead
	DIVL	#4+<2*LPD$C_SRM_NODES>,R8 ; Compute number of segments
					; which neighbor can handle in 1 packet
	MOVB	#TR4C_MSG_RT,(R3)+	; Enter type code
	MOVW	RCB$W_ADDR(R4),(R3)+	; Enter source node address
	CLRB	(R3)+			; Skip reserved byte
	PUSHL	R3			; Save address of first segment
	;
	;   For each segment with it's bit set in the SRM bitmask,
	;   copy the associated cost/hops entries from the cost/hops matrix
	;   into the message.  Make special provisions so that node numbers
	;   less than 1, and greater than MAX ADDRESS are not sent.
	;
	ASSUME	LPD$C_SRM_SIZE EQ 32
10$:	BICB	#^C<LPD$C_SRM_SIZE-1>,-	; Make sure index is always a modulo
		LPD$B_SRM_POS(R6)	; of the bitmask size (wrap around)
	MOVZBL	LPD$B_SRM_POS(R6),R0	; Get current position in SRM bitmask
	INCB	LPD$B_SRM_POS(R6)	; Update current segment number
	BBCC	R0,LPD$G_XMT_SRM(R6),30$ ; Skip if segment not to be sent
	CLRBIT	R0,LPD$G_SRM(R6)	; Optimize next pass; already done
	ASHL	#LPD$C_SRM_SHFT,R0,R0	; Compute starting node address
	CMPW	R0,RCB$W_MAX_ADDR(R4)	; Higher than MAX ADDRESS?
	BGTRU	30$			; If so, do not send
	ADDL3	#LPD$C_SRM_NODES,R0,R1	; Compute ending+1 node address
	DECL	R1			; Compute ending node address
	CMPW	R1,RCB$W_MAX_ADDR(R4)	; Ending address < MAX ADDRESS ?
	BLEQU	20$			; Branch if ok
	MOVZWL	RCB$W_MAX_ADDR(R4),R1	; Never send > MAX ADDRESS
20$:	SUBL	R0,R1			; Compute number of nodes-1 in segment
	INCL	R1			; Compute number of nodes in segment
	BEQL	30$			; Branch if nothing to send
	MOVW	R1,(R3)+		; Set number of nodes in segment
	MOVW	R0,(R3)+		; Set starting node address
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVAW	NET$AW_MIN_C_H[R0],R0	; Get address of cost/hops entries
	MULL	#2,R1			; Compute number of bytes in segment
	MOVC	R1,(R0),(R3)		; Store cost/hops entries in msg
	POPR	#^M<R2,R4,R5>		; Restore registers
	DECL	R8			; Indicate segment filled
	BEQL	35$			; Branch if cannot fit any more segments
30$:	DECB	LPD$B_SRM_LEFT(R6)	; Decrement number of bits left to check
	BGTR	10$			; Loop through all segments
	;
	;   Compute checksum on all segments in message, and store it
	;
35$:	POPL	R0			; Get address of first segment
	CMPL	R0,R3			; Any segments at all?
	BEQL	70$			; Branch if not
	MOVL	#1,R1			; Init checksum
40$:	ADDW	(R0)+,R1		; Add to 1's complement checksum
	ADWC	#0,R1			; add "end around carry"
	CMPL	R0,R3			; At end of message?
	BLSSU	40$			; Continue if not
	MOVW	R1,(R3)+		; Store checksum
	;
	;   Send the message
	;
	ADDL	R3,WQE$C_LENGTH+P2(R2)	; Set I/O buffer size
	MOVL	S^#IO$_WRITELBLK,R0	; Set I/O function code
	RSB				; Return to issue I/O

	;
	;   No segments in message.  Do not send anything.
	;
70$:	CLRL	R0			; Do not issue I/O
	JSB	@(SP)+			; Return to abort co-routine
	BRW	3$			; Indicate we are done

	.SBTTL	XMT_ART - Transmit a Phase IV area routing message
;+
; XMT_ART - Transmit a Phase IV segmented area routing message
;
; Inputs:
;
;	R11 = CRI CNR address
;	R10 = CRI CNF address
;	R7 = ADJ address
;	R6 = LPD address
;	R4 = RCB address
;
; Outputs:
;
;	R1 = Next event to be processed
;	R0 = True if state change allowed, else false.
;-
XMT_ART:
	TSTB	LPD$B_ASRM_LEFT(R6)	; Any bits left to check?
	BNEQ	5$			; Branch if so
3$:	CLRBIT	LPD$V_XMT_ART,LPD$B_XMTFLG(R6) ; Indicate "transmission" done
	MOVL	#LEV$C_NO_EVT,R1	; No more events
	MOVL	#1,R0			; Allow state change
	RSB
5$:	;
	;   Allocate and setup the buffer
	;
	MOVZWL	ADJ$W_BUFSIZ(R7),R9	; Get adjacent node's buffer size
	BNEQ	8$			; Branch if "known"
	MOVZWL	LPD$W_BUFSIZ(R6),R9	; (& should never get here)
					; Else, use our own buffer size
8$:	MOVL	R9,R1			; Indicate size of extra buffer
	BSBW	NET$DLL_QIO_CO		; Call co-routine to allocate buffer
	MOVL	R3,WQE$C_LENGTH+P1(R2)	; Point to I/O buffer
	MNEGL	R3,WQE$C_LENGTH+P2(R2)	; Bias the I/O buffer size
	SUBL3	#6,R9,R8		; Subtract out required overhead
	DIVL	#4+<2*LPD$C_ASRM_AREAS>,R8 ; Compute number of segments
					; which neighbor can handle in 1 packet
	MOVB	#TR4C_MSG_ART,(R3)+	; Enter type code
	MOVW	RCB$W_ADDR(R4),(R3)+	; Enter source area address
	CLRB	(R3)+			; Skip reserved byte
	PUSHL	R3			; Save address of first segment
	;
	;   For each segment with it's bit set in the SRM bitmask,
	;   copy the associated cost/hops entries from the cost/hops matrix
	;   into the message.  Make special provisions so that node numbers
	;   less than 1, and greater than MAX ADDRESS are not sent.
	;
	ASSUME	LPD$C_ASRM_SIZE EQ 1	; && fix this
10$:	BICB	#^C<LPD$C_ASRM_SIZE-1>,- ; Make sure index is always a modulo
		LPD$B_ASRM_POS(R6)	; of the bitmask size (wrap around)
	MOVZBL	LPD$B_ASRM_POS(R6),R0	; Get current position in SRM bitmask
	INCB	LPD$B_ASRM_POS(R6)	; Update current segment number
	BBCC	R0,LPD$G_XMT_ASRM(R6),30$ ; Skip if segment not to be sent
	CLRBIT	R0,LPD$G_ASRM(R6)	; Optimize next pass; already done
	ASHL	#LPD$C_ASRM_SHFT,R0,R0	; Compute starting area address
	CMPB	R0,RCB$B_MAX_AREA(R4)	; Higher than MAX AREA?
	BGTRU	30$			; If so, do not send
	ADDL3	#LPD$C_ASRM_AREAS,R0,R1	; Compute ending+1 area address
	DECL	R1			; Compute ending area address
	TSTL	R0			; Starting address > 0 ?
	BGTRU	15$			; Branch if ok
	INCL	R0			; Never send area #0
15$:	CMPB	R1,RCB$B_MAX_AREA(R4)	; Ending address < MAX AREA ?
	BLEQU	20$			; Branch if ok
	MOVZBL	RCB$B_MAX_AREA(R4),R1	; Never send > MAX AREA
20$:	SUBL	R0,R1			; Compute number of nodes-1 in segment
	INCL	R1			; Compute number of nodes in segment
	BEQL	30$			; Branch if nothing to send
	MOVW	R1,(R3)+		; Set number of nodes in segment
	MOVW	R0,(R3)+		; Set starting node address
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVAW	NET$AW_AREA_C_H[R0],R0	; Get address of cost/hops entries
	MULL	#2,R1			; Compute number of bytes in segment
	MOVC	R1,(R0),(R3)		; Store cost/hops entries in msg
	POPR	#^M<R2,R4,R5>		; Restore registers
	DECL	R8			; Indicate segment filled
	BEQL	35$			; Branch if cannot fit any more segments
30$:	DECB	LPD$B_ASRM_LEFT(R6)	; Decrement number of bits left to check
	BGTR	10$			; Loop through all segments
	;
	;   Compute checksum on all segments in message, and store it
	;
35$:	POPL	R0			; Get address of first segment
	CMPL	R0,R3			; Any segments at all?
	BEQL	70$			; Branch if not
	MOVL	#1,R1			; Init checksum
40$:	ADDW	(R0)+,R1		; Add to 1's complement checksum
	ADWC	#0,R1			; add "end around carry"
	CMPL	R0,R3			; At end of message?
	BLSSU	40$			; Continue if not
	MOVW	R1,(R3)+		; Store checksum
	;
	;   Send the message
	;
	ADDL	R3,WQE$C_LENGTH+P2(R2)	; Set I/O buffer size
	MOVL	S^#IO$_WRITELBLK,R0	; Set I/O function code
	RSB				; Return to issue I/O

	;
	;   No segments in message.  Do not send anything.
	;
70$:	CLRL	R0			; Do not issue I/O
	JSB	@(SP)+			; Return to abort co-routine
	BRW	3$			; Indicate we are done

	.SBTTL	CHK_IO - Check for multiple transmits
;+
; CHK_IO - See if its okay to transmit a message
;
; This routine ensures that only 1 transmit is outstanding at a time.
; This restriction applies only to non-broadcast circuits.
;
; Inputs:	R6 = LPD address
;
; Outputs:	R0 = True if ok to send
;		     False if transmit is outstanding - cannot transmit
;-
CHK_IO:					; See if its okay to xmit
	BBC	#LPD$V_ACTIVE,-		; If circuit is no longer active,
		    LPD$W_STS(R6),70$	; do not allow the I/O
	MOVL	#1,R0			; Assume its okay to xmit
	BBC	#LPD$V_BC,LPD$W_STS(R6),20$ ; If broadcast circuit, its ok
	;
	;   Allow up to 20 transmits at a time for NI circuits
	;
	CMPB	LPD$B_ASTCNT(R6),#21	; Is AST queue getting too big?
	BLEQU	90$			; If not, allow it
	BRB	70$			; Else, disallow it
	;
	;   Allow only 1 transmit at a time for point-to-point circuits
	;
20$:	CMPB	LPD$B_ASTCNT(R6),#1	; Is AST queue getting too big?
					; (ASTCNT=1 if no transmits are active,
					;  the 1 is for the active receiver)
	BLEQU	90$			; If not, allow it
70$:	CLRL	R0			; Message cannot be sent
90$:	RSB				; Done

	.SBTTL	NET$DLL_QIO_CO - Common QIO routine
;+
; NET$DLL_QIO_CO	- Common co-routine to issue a DLL QIO
;
; Inputs:	R6 = LPD address
;		R1 = Maximum size of optional buffer needed for QIO
;
; Outputs:	R1	Next "event longword" to be processed
;		R0	Low bit set if state change is permitted,
;			Low bit clear to avoid state change
;
;		R2-R4 are destroyed.
;
; This routine makes a co-routine call back to the caller after it sets
; up the WQE for the QIO.  On return from the co-routine call, this routine
; will issue the QIO and cause the appropriate event transition to be taken.
;
; Input to co-routine:
;
;		R2 = WQE address
;		R3 = Pointer to optional QIO buffer (if any)
;		R6 = LPD address
;
;		R4-R5,R7-R11 contain original values.
;
; Output from co-routine:
;
;		R0 = Function code for QIO
;-
	IOSB =   0			; Define WQE extensions to hold the I/O
	P5   =   8			; status block and the QIO parameters
	P4   =  12			;
	P3   =  16			;
	P2   =  20			;
	P1   =  24			; 
	FUNC =  28			; I/O function (word)
	IOWQE_LENGTH = 32		; Size of extension (longword aligned)
					;
NET$DLL_QIO_CO:				; Common DLL Qio co-routine
	MOVL	#WQE$C_SUB_AST,R0	; Indicate WQE subtype
	ADDL	#IOWQE_LENGTH+2,R1	; Add in WQE I/O extension
					; Add 2 bytes in case CRC16 needed (X25)
	BSBW	WQE$ALLOCATE		; Allocate the element - always succeeds
	MOVW	LPD$W_PTH(R6),-		;
		    WQE$W_REQIDT(R2)	; Setup path i.d.
	MOVZBW	S^#LEV$C_IO_SUCC,-	; Setup default QIO success event
		    WQE$B_EVT(R2)	;
	MOVL	#LEV$C_IO_FAIL,-	; Setup default QIO failure event
		    WQE$L_PM2(R2)	;
	MOVAB	QIOAST,WQE$L_ACTION(R2)	; Setup post processing routine
	MOVAB	WQE$C_LENGTH+IOSB(R2),R3; Get start WQE extension
	CLRQ	(R3)+			; Zero the IOSB image
	CLRQ	(R3)+			; Zero P5 and P4
	CLRQ	(R3)+			; Zero P3 and P2
	CLRL	(R3)+			; Zero P1
	BBC	#LPD$V_BC,LPD$W_STS(R6),10$ ; Skip if non-broadcast driver
	MOVAB	NET$G_ALL_ROU,WQE$C_LENGTH+P5(R2) ; Set P5 = "all routers"
10$:	MOVAB	WQE$C_LENGTH+IOWQE_LENGTH+2(R2),R3 ; Point to optional buffer
	JSB	@(SP)+			; Get QIO data
	MOVW	R0,WQE$C_LENGTH+FUNC(R2); Store I/O function code
	BNEQ	15$			; Br if function supplied
	BRW	200$			; Caller bailed out of I/O
15$:	;
	;   If we are transmitting an X.25 datagram, then calculate the CRC-16
	;   and append it to the front of the buffer.
	;
	BBC	#LPD$V_X25,LPD$W_STS(R6),20$ ; Skip if not X.25 datalink
	CMPW	R0,#IO$_WRITELBLK	; Writing a datagram?
	BNEQ	20$			; Branch if not
	PUSHL	R2			; Save WQE address
	CRC	CRC16,#0,-		; Calculate CRC16 checksum
		WQE$C_LENGTH+P2(R2),-
		@WQE$C_LENGTH+P1(R2)
	POPL	R2			; Restore WQE address
	ADDL	#2,WQE$C_LENGTH+P2(R2)	; Account for CRC16 in length
	SUBL	#2,WQE$C_LENGTH+P1(R2)	; Move back message pointer
	MOVW	R0,@WQE$C_LENGTH+P1(R2)	; Append to front of msg
20$:	;
	;   If this is a write request, then journal the data
	;
	CMPW	WQE$C_LENGTH+FUNC(R2),-	; Write request?
		#IO$_WRITELBLK
	BNEQ	25$			; If so,
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,25$			; Skip if journalling not enabled
	CLRB	(R1)+			; Record type = start of transmit
	MOVB	LPD$B_PTH_INX(R6),(R1)+	; LPD index
	MOVW	WQE$C_LENGTH+P2(R2),(R1)+ ; Length of message
	MOVC5	WQE$C_LENGTH+P2(R2),-	; Store data into journal record
		@WQE$C_LENGTH+P1(R2),-
		#0,#64-12,(R1)
	MOVL	R3,R1			; Set ending address of record
	JSB	@(SP)+			; Log the journal record
25$:	;
	;   Queue the I/O
	;
	$QIO_S	-			; Issue QIO
	    FUNC = WQE$C_LENGTH+FUNC(R2),-
	    EFN	 = #NET$C_EFN_ASYN,-
	    CHAN = LPD$W_CHAN(R6),-
	    IOSB = WQE$C_LENGTH+IOSB(R2),-
	    P5	 = WQE$C_LENGTH+P5(R2),-
	    P4	 = WQE$C_LENGTH+P4(R2),-
	    P3	 = WQE$C_LENGTH+P3(R2),-
	    P2	 = WQE$C_LENGTH+P2(R2),-
	    P1	 = @WQE$C_LENGTH+P1(R2),-; $QIO_S macro does a PUSHAB for P1
	    ASTADR = B^NET$DLLQIOAST,-	;
	    ASTPRM = R2			; Use the WQE ptr as parameter
	INCB	LPD$B_ASTCNT(R6)	; Account for $QIO
	MOVL	R0,R3			; Save I/O status
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,30$			; Branch if journalling not enabled
	MOVB	#^X11,(R1)+		; Journal record type = QIO
	MOVB	LPD$B_PTH_INX(R6),(R1)+	; LPD index
	MOVW	WQE$C_LENGTH+FUNC(R2),(R1)+ ; I/O function code
	MOVL	R3,(R1)+		; Status from QIO request
	JSB	@(SP)+			; Log the journalling record
30$:	BLBC	R3,50$			; Br if QIO request failed
	;
	;   I/O queued.  Set timer and wait for AST
	;
	MOVQ	#TR$C_TIM_DLLIO*-	; Setup I/O timer interval
		10*1000*1000,R3		; in quadword VMS clock ticks
	BSBW	SET_IOTIM		; Cancel old timer, set new one
	BRB	100$			; Continue
	;
	;   I/O failure.  Setup status and queue WQE
	;	
50$:	MOVW	R3,WQE$C_LENGTH+IOSB(R2); Store status in IOSB field
	MOVL	R2,R0			; Get the WQE address
	BSBW	WQE$INSQUE		; Queue it
100$:	MOVL	S^#LEV$C_NO_EVT,R1	; Setup next event longword
	MOVB	#1,R0			; Allow state change
	RSB

200$:					; Caller doesn't want to issue I/O
	MOVL	R2,R0			; Set the WQE address
	BSBW	NET$DEALLOCATE		; Deallocate it
	BRB	100$			; and return success

NET$DLLQIOAST:
	.WORD	0			; No need to save regs
	MOVL	4(AP),R0		; Get the WQE address
	BSBW	WQE$INSQUE		; Queue it
	RET

QIOAST:	MOVL	WQE$W_REQIDT-2(R5),R1	; Put Path i.d. into high order word
	MOVW	#<<WQE$C_QUAL_DLL>@8>!-	; Setup timer qualifier
		   LEV$C_IO_TIMOUT,R1	; and timer event
	BSBW	WQE$CANCEL_TIM		; Cancel the timer
	BSBW	FIND_WQE_CTX		; Locate CNF, LPD, ADJ blocks
	BLBC	R0,230$			; If LPD no longer exists, skip event
	DECB	LPD$B_ASTCNT(R6)	; Account for AST
	BSBW	NET$JNX_CO		; Initialize journalling co-routine
	BLBC	R0,30$			; Branch if journalling not enabled
	MOVB	#^X22,(R1)+		; Journal record type = QIO AST
	MOVB	LPD$B_PTH_INX(R6),(R1)+	; LPD index
	MOVW	WQE$C_LENGTH+FUNC(R5),(R1)+ ; I/O function code
	MOVQ	WQE$C_LENGTH+IOSB(R5),(R1)+ ; I/O completion status
	JSB	@(SP)+			; Log the journalling record
30$:	BLBS	WQE$C_LENGTH+IOSB(R5),220$ ; If LBC then I/O failed
	MOVB	WQE$L_PM2(R5),WQE$B_EVT(R5) ; Set failure event
220$:	BSBW	PROC_EVT		; Process the event
230$:	BSBW	KILL_WQE		; Deallocate the WQE
	RSB

500$:	BUG_CHECK  NETNOSTATE,FATAL	; Signal the bug

	.SBTTL	SET_IOTIM - Set I/O timer
;+
; SET_IOTIM - Set I/O timer
;
; INPUTS:	R6	LPD ptr
;		R3/R4	Quadword value of timer
;
; OUTPUTS:	R5-R11	Preserved
;-
SET_IOTIM:				; Start the I/O timer
	MOVW	#<<WQE$C_QUAL_DLL>@8>!-	; Setup timer qualifier
		   LEV$C_IO_TIMOUT,R0	; and timer event
	MOVW	LPD$W_PTH(R6),R1	; Get LPD index
	ASHL	#16,R1,R1		; Shift into upper word (REQIDT)
	MOVW	R0,R1			;
	MOVAB	NET$DLL_PRC_WQE,R2	; Setup action routine address
	BSBW	WQE$RESET_TIM		; Reset the timer
	RSB

	.SBTTL	RESET_CHAN - Cancel all device I/O
;+
; RESET_CHAN	- Cancel all the I/O queued to device.
;
; FUNCTIONAL DESCRIPTION:
;
; If a channel is active to the driver then call the driver to cancel ALL
; the I/O on the device.  A $CANCEL is not sufficient since the PID field 
; of the internal IRPs queued to the data link driver by NETDRIVER would 
; not match hence not all of the packets would be cancelled.
;
; INPUTS:	R11	CRI CNR pointer
;		R10	CRI CNF pointer
;		R6	LPD pointer
;
; OUTPUTS:	R0	Status
;
;		All registers are preserved
;-
RESET_CHAN:
	$CANCEL_S CHAN = LPD$W_CHAN(R6)	; Cancel stuff on the queue
	MOVL	#1,R0			; Return success
	RSB

	.SBTTL	NET$GET_LPD_CRI - Locate CNF given LPD index
;+
; NET$GET_LPD_CRI - Locate CNR and CNF given LPD index
;
; INPUTS	R11-R9	Scratch
;		R8	Low byte contains LPD index
;		R7,R6	Scratch
;
; OUTPUTS:	R11	CNR address 
;		R10	CNF address 
;		R9-R7	Garbage
;		R6	LPD if low bit set in R0
;		R0	Low bit set if successful
;			Low bit clear otherwise
;-
NET$GET_LPD_CRI::
	MOVL	NET$GL_CNR_CRI,R11	; Get data base root for CRI
	CLRL	R10			; No CNF yet
	BSBB	NET$FIND_LPD		; Find the LPD via index in R8
	BLBC	R0,10$			; If LPD then none
	MOVL	R11,R0			; Make a copy
	MOVZWL	LPD$W_PTH(R6),R8	; Get full LPD path i.d.
5$:	MOVL	CNF$L_FLINK(R0),R0	; Get next CNF
	CMPL	R0,R11			; At head of list?
	BEQL	10$			; If EQL yes, return with LBC in R0
	CMPW	R8,CNF$W_ID(R0)		; This it?
	BNEQ	5$			; If NEQ keep trying
	MOVL	R0,R10			; Copy CNF address
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Done

	.SBTTL	NET$ADJ_LPD_CRI - Locate CNF given ADJ index
;+
; NET$ADJ_LPD_CRI - Locate CNR and CNF given ADJ index
;
; INPUTS	R11-R9	Scratch
;		R8	Low byte contains ADJ index
;		R7,R6	Scratch
;
; OUTPUTS:	R11	CNR address 
;		R10	CNF address 
;		R9-R8	Garbage
;		R7	ADJ address
;		R6	LPD address
;		R0	Low bit set if successful
;			Low bit clear otherwise
;-
NET$ADJ_LPD_CRI::
	MOVL	NET$GL_CNR_CRI,R11	; Get data base root for CRI
	CLRL	R10			; No CNF yet
	BSBB	NET$FIND_ADJ		; Find LPD & ADJ via index in R8
	BLBC	R0,10$			; If LPD then none
	MOVL	R11,R0			; Make a copy
	MOVZWL	LPD$W_PTH(R6),R8	; Get full LPD path i.d.
5$:	MOVL	CNF$L_FLINK(R0),R0	; Get next CNF
	CMPL	R0,R11			; At head of list?
	BEQL	10$			; If EQL yes, return with LBC in R0
	CMPW	R8,CNF$W_ID(R0)		; This it?
	BNEQ	5$			; If NEQ keep trying
	MOVL	R0,R10			; Copy CNF address
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Done

	.SBTTL	NET$LOCATE_LPD - Locate LPD given CNF
;+
; NET$LOCATE_LPD
;
; INPUTS:	R11	CNR address
;		R10	CNF address
;		R9-R6	Scratch
;
; OUTPUTS:	R11,R10	Preserved
;		R9-R7	Garbage
;		R6	LPD if low bit set in R0
;			Zero if low bit clear in R0
;		R0	SS$_NORMAL    if successful
;			SS$_DEVINACT  otherwise
;-
NET$LOCATE_LPD::
	MOVZWL	CNF$W_ID(R10),R8	; Get LPD i.d.
					; And fall thru

	.SBTTL	NET$FIND_LPD - Find LPD given LPD index
;+
; NET$FIND_LPD - Find LPD given LPD index
;
; INPUTS:	R8	Low byte contains LPD index
;		R6	Scratch
;
; OUTPUTS:	R8	Garbage
;		R6	LPD if low bit set in R0
;			Zero if low bit clear in R0
;		R0	SS$_NORMAL    if successful
;			SS$_DEVINACT  otherwise
;-
NET$FIND_LPD::
	MOVL	NET$GL_PTR_VCB,R0	; Get the RCB address
	MOVZBL	R8,R8			; Get low byte of LPD index
	BEQL	10$			; If EQL then there's none
	CMPB	R8,RCB$B_MAX_LPD(R0)	; Within range ?
	BGTR	10$			; If not, branch
	MOVL	@RCB$L_PTR_LPD(R0)[R8],R6 ; Get LPD address
	BGEQ	10$			; Branch if not valid
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	BRB	15$			; Take common exit
10$:	CLRL	R6			; Nullify LPD pointer
	MOVZWL	#SS$_DEVINACT,R0	; Indicate failure
15$:	RSB

	.SBTTL	NET$FIND_ADJ - Find LPD & ADJ given ADJ index
;+
; NET$FIND_ADJ - Find LPD & ADJ given ADJ index
;
; INPUTS:	R8	Low word contains ADJ index
;		R6-R7	Scratch
;
; OUTPUTS:	R8	Garbage
;		R7	ADJ address
;		R6	LPD address
;		R0	SS$_NORMAL    if successful
;			SS$_DEVINACT  otherwise
;-
NET$FIND_ADJ::
	MOVL	NET$GL_PTR_VCB,R0	; Get the RCB address
	MOVZWL	R8,R8			; Get low word of ADJ index
	BEQL	10$			; If EQL then there's none
	CMPW	R8,RCB$W_MAX_ADJ(R0)	; Within range ?
	BGTR	10$			; If not, branch
	MOVL	@RCB$L_PTR_ADJ(R0)[R8],R7 ; Get ADJ address
	BBC	#ADJ$V_INUSE,ADJ$B_STS(R7),10$ ; Branch if slot not in use
	MOVZBL	ADJ$B_LPD_INX(R7),R8	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R0)[R8],R6 ; Get LPD address
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

10$:	CLRL	R7			; Nullify pointer
	MOVZWL	#SS$_DEVINACT,R0	; Indicate failure
	RSB

	.SBTTL	NET$GET_PLVECLPD - Find next active LPD
;+
; NET$GET_PLVECLPD	- Find next active LPD using the indicated line (PLVEC)
;
; INPUTS:	R4	PLVEC index
;		R1	Previous LPD index (scan starts with R1 +1)
;
; OUPUTS:	R1	New LPD address
;		R0	SS$_NORMAL    if successful
;			SS$_DEVINACT  otherwise
;-
NET$GET_PLVECLPD::			; Find next active LPD using this line
	PUSHL	R3			; Save reg
	MOVL	NET$GL_PTR_VCB,R3	; Get the RCB address
20$:	INCL	R1			; Start at next LPD
	CMPB	R1,RCB$B_MAX_LPD(R3)	; Within range ?
	BGTRU	100$			; If not, branch
	MOVL	@RCB$L_PTR_LPD(R3)[R1],R0 ; Get next LPD address
	BGEQ	20$			; Branch if not valid
	BBC	#LPD$V_ACTIVE,-		; Is LPD active ?
		    LPD$W_STS(R0),20$	; If BC then no
	CMPB	R4,LPD$B_PLVEC(R0)	; Is it using the indicated line?
	BNEQ	20$			; If EQL yes, we've found the LPD
	MOVL	R0,R1			; Copy LPD pointer
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	BRB	110$			; Take common exit
100$:	CLRL	R1			; Nullify LPD pointer
	MOVZWL	#SS$_DEVINACT,R0	; Indicate failure
110$:	POPL	R3			; Restore reg
	RSB


	.SBTTL	TELL_NETDRIVER - Inform NETDRIVER of an event
;+
; TELL_NETDRIVER	- Inform NETDRIVER of an event
;
; INPUTS:	R0 = Function code (NETUPD$_DLL_)
;		R6 = LPD address
;
; OUTPUTS:	R0 = Status
;
;		All other registers are preserved.
;-
TELL_NETDRIVER:				;
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save critical regs
	MOVL	NET$GL_NET_UCB,R5	; Get the ACP's NET UCB
	MOVL	NET$GL_PTR_VCB,R2	; Get RCB
	MOVL	R6,R1			; Get the LPD address
	BSBW	CALL_NETDRIVER		; Tell NETDRIVER
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore regs
	RSB
.END

