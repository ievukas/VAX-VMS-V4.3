
MODULE RM3MISPUT (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                Miscellaneous put routines
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Christian Saether     CREATION DATE:        	6-JUL-78  10:56
!
!
! MODIFIED BY:
!
!	V03-012	MCN0010		Maria del C. Nasr	04-Apr-1983
!		Change linkage of RM$COMPRESS_KEY.
!
!	V03-011	MCN0009		Maria del C. Nasr	15-Mar-1983
!		More linkages reorganization
!
!	V03-010 MCN0008		Maria del C. Nasr	22-Feb-1983
!		RM$BLD_IDX_REC and RM$MOVE_IN_VBN are not global routines
!		anymore, make them local.  Also, make local linkages more
!		general, and reorganize linkages.
!
!	V03-009	TMK0006		Todd M. Katz		10-Sep-1982
!		Add support for Prologue 3 SIDRs. The routines which have been
!		modified or rewritten are: RM$RECORD_SIZE, RM$ADD_TO_ARRAY,
!		RM$BLD_NEW_SIDR, and RM$INS_REC.
!
!		I also reformatted the whole module, putting the routines in
!		alphabetical order, and redid some of the linkages.
!
!	V03-008	KBT0222		Keith B. Thompson	23-Aug-1982
!		Reorganize psects
!
!	V03-007	TMK0005		Todd M. Katz		02-Jun-1982
!		Implement the RMS cluster solution for next record processing.
!		There is no longer any need to reference the NRP cell to obtain
!		the RFA address of the current primary data record because that
!		information is now kept locally in the IRAB as part of the next
!		record context instead of in the NRP cell which has been 
!		deleted. Also refer to the fields IRB$_PUTUP_VBN and 
!		IRB$W_PUTUP_ID when refering to the new/changed primary data
!		which requires the SIDR entry.
!
!	V03-006	KBT0066		Keith B. Thompson	17-Jun-1982
!		Remove rm$move_sig_cnt routine
!
!	V03-005	TMK0004		Todd M. Katz		11-May-1982
!		Added code for the support of two index bucket split cases
!		which are currently not supported. At the present time when
!		one of these split cases occur, the routines in this module are
!		never called, but instead, a higher routine returns an 
!		alternate success status of index not updated. These two split
!		cases are: two-pass two-bucket with empty bucket split case
!		and two-pass multi-bucket with empty bucket split case. Support
!		has been added for all prologue versions. The routines which 
!		have been modified are RM$RECORD_SIZE, RM$SHFT_VBNS, 
!		RM$BLD_IDX_REC, and RM$V3_IDX_REC. These routines have been
!		modified so that they can perform their individual functions
!		during each of the two individual passes required to correctly
!		update the index during these two-pass empty bucket index
!		bucket split cases. During the first pass, these routines 
!		function on the old (left) index bucket, and during the second
!		pass these routines function on the new (right) index bucket.
!
!	V03-004 TMK0003		Todd M. Katz		26-Apr-1982
!		Redid the way all empty bucket splits are done for prologue
!		3 files. There were many errors in the way they were being done
!		especially in those cases when a decision was made not to swing
!		the level one index pointer from the old (left) bucket to a
!		new (middle) bucket because the downpointer was not currently
!		pointing to the left bucket. Changes were made to the routine
!		RM$RECORD_SIZE so that the size of the new index record(s)
!		could be correctly computed for all empty bucket involving
!		index updates. Changes were made to the routine RM$SHFT_VBNS
!		so that the spreading apart of VBNs during index updating was
!		performed correctly for all index updates involving empty data
!		buckets. Finally, the routine RM$V3_IDX_REC was modified to
!		correctly perform all index updates involving empty buckets,
!		and most especially those updates were no pointer is to be
!		swung because the level one index down pointer does not point
!		to the old (leftmost) data bucket. These changes will be 
!		included as a patch on the V3.1 update floopy.
!
!	V03-003 TMK0002		Todd M. Katz		13-Apr-1982
!		Fixed a bug in RM$RECORD_SIZE. This bug only showed up when
!		a multi-bucket data level split of a prolog 3 file with index
!		compression required updating of the level 1 index with two
!		index records. The size of these two index records was being
!		incorrectly computed. I was refering to keybuffer 5 (containing
!		the compressed key of the first record) in one instance when 
!		I should have been refering to keybuffer 4 (containing the
!		compressed key of the second record), and thus the combined
!		size of the two index records was being incorrectly computed.
!
!	V03-002 LJA0007		Laurie Anderson 	25-Mar-1982
!		Change KBUFSZ to reference a macro when computing buffer 
!		size and make IFB$B_KBUFSZ a word, now: IFB$W_KBUFSZ.
!
!	V03-001	TMK0001		Todd M. Katz		03-Mar-1982
!		Fixed a bug in the determination of the record size of
!		a two-bucket with empty bucket bucket split case involving
!		prolog 3 index buckets with compressed keys.  In such a case
!		there is no key to be inserted, but due to insufficient
!		checks the routine RM$V3KEY_SZ was being called as if there
!		was a key. This routine thinks there is a key in keybuffer 2
!		and attempts to move it into keybuffer 5 so it can compress
!		it. Since there isn't a key, it ends up moving garbage into
!		the keybuffer and into the RLB which follows it guarenteeing an
!		access violation the next time RM$UNLOCK is called. The fix 
!		is to make sure that this routine will never be called for
!		this particluar prolog 3 bucket split case.
!
!
!	V02-022 KPL0001		Peter Lieberwirth	 2-Mar-1982
!		Fix linkage from v02-021
!
!	V02-021	TMK0005		Todd M. Katz		02-Mar-1982
!		Made several changes to the routines in this module:
!
!		1. RM$V3KEY_SZ is no longer a global routine.
!
!		2. Added a symbol to RM$FOOLED_YUH so that reprobing of the
!		   RAB would not be neccessairy.
!
!		3. Added support for rear-end truncation of keys in prolog 3
!		   buckets containing compressed keys. This included changes in
!		   the way the size of two compressed keys (from a multibucket
!		   split) is computed in RM$RECORD_SIZE, changes in the way the
!		   size of a single key is determined in RM$V3KEY_SZ, and 
!		   changes in the way in which keys are inserted into prolog 3
!		   buckets (with compressed keys) in RM$ADD_V3KEY. All these
!		   changes reflect the fact that compressed keys are now 
!		   rear-end truncated as well as front-end compressed.
!
!	V02-020	TMK0004		Todd M. Katz		12-Feb-1982
!		Add checks for a multibucket split in RM$RECORD_SIZE and 
!		RM$BLD_IDX_REC in all instances when it isn't absolutely
!		clear whether RMS is currently processing a two-pass two-bucket
!		split case or a two-pass multibucket split case (where both
!		records are to go in the same bucket).
!
!	V02-019	TMK0003		Todd M. Katz		08-Feb-1982
!		Document what is going on in RM$RECORD_SIZE so that someone
!		besides me might possibly understand what is going on from 
!		the comments. The current comments are both confusing and
!		wrong.
!
!	V02-018	TMK0002		Todd M. Katz		30-Jan-1982
!		Made many changes to several of these miscellaneous routines
!		inorder to fix a variety of bugs, and to add functionality
!		that was lacking. I will list the reasons for the changes
!		made, and how the routines were changed.
!
!		1. Added REC_SZ as an arguement to both RM$BLD_IDX_REC
!		   and RM$V3_IDX_REC. It was require in the former to pass
!		   it to the latter, and in the latter to fix the prolog 3
!		   multibucket split trailing key recompression bug described
!		   below.
!
!		2. Fixed a prolog 3 multibucket split key recompression bug.
!		   When a multibucket split occurs, and the index must be
!		   updated with two keys, the key at the insertion point
!		   must have its front compression redetermined. However,
!		   the key recompression routine, RM$RECOMPR_KEY, is unable
!		   to recompute the front compression of a key if its
!		   current front compression is not equal to the front
!		   compression of the key preceeding it. If it has greater
!		   compression the index is out-of-order, and if it has less,
!		   it assumes there is no need for recompression. Well, if
!		   the two keys BB AND BC were to be inserted between AA and
!		   BD, the trailing key BD was not being recompressed because
!		   its current fron compression (0) was less than the 
!		   compression of the record preceeding it (1) even though
!		   it should be recompressed to have a new front compression
!		   value of 1. The fix was that on a multibucket split, the
!		   first key is inserted and used to recompress what will
!		   become the trailing key, and then the second key is inserted
!		   and used to recompress the trailing key. This required
!		   changes to RM$ADD_V3KEY, so that recompression is NOT
!		   performed if the key being inserted is the first of two
!		   keys, and changes to RM$V3_IDX_REC, to recompress what
!		   will become the trailing key after the first of two keys
!		   is inserted, based on the first key that is inserted. In
!		   addition, I also added the change such that if the first 
!		   of two compressed keys to be inserted is zero front 
!		   compressed, then the pointer to the last noncompressed key 
!		   is incremented to this key to facilitate the determination 
!		   of the front compression of the next key when it is 
!		   inserted.
!
!		3. Added code to restrict when trailing key recompression
!		   is required. If one or two keys are inserted into a
!		   prolog 3 index bucket containing compressed keys at the
!		   beginning of the bucket's freespace, there is no need to 
!		   redetermine the front compression of the trailing key 
!		   because there is no trailing key! Formerly, the front
!		   compression of the trailing key was blindly determined
!		   as part of the process of inserting any compressed key
!		   regardless of whether there was any key that trailed the
!		   key inserted or not.
!
!		4. Changed the decision by which the keys and VBNs in prolog 
!		   3 index buckets are shifted in order to make room for the 
!		   insertion of a new key-VBN pair. At the present time, if
!		   the key/VBN is to be added as the hish order key in the 
!		   bucket, neither the keys nor the VBNs are shifted since
!		   both "grow" inward towards the center. An additional check
!		   is added to also not shift the keys or VBNs, if the
!		   number of bytes by which they are to be shifted "inwards"
!		   is 0. This will occur when the split point of an index
!		   bucket matches the insertion point, and just the VBN of
!		   the new lower order key of the new (right) bucket is to
!		   be updated to its new value.
!
!		5. Added code necesaary for support of a Prolog 1 & 2 split
!		   case. When the insertion point of a multibucket split is
!		   found to be at the split point, but there is sufficient room
!		   in an index bucket for only two index records, and the 
!		   insertion point happens to come at the bucket's beginning,
!		   both of the old index records must be moved out of the old
!		   bucket to make room for the two new index records which are
!		   both put in the old bucket. This index bucket split case
!		   required code to be added to RM$RECORD_SIZE and 
!		   RM$BLD_IDX_REC. As this split case is handled by making two
!		   passes, one for insertion of the two new index records in 
!		   the old index bucket, and the second to update a VBN pointer
!		   in the low order key of the new bucket, both of these 
!		   routines had to be modified, to take the proper action for
!		   each of the passes of this case. RM$BLD_IDX_REC oversees
!		   addition of the both keys and a VBN during the first pass,
!		   and updates a VBN during the second, while RM$RECORD_SIZE
!		   makes sure to return the proper size of the index record
!		   to be added during each pass.
!
!		6. There are three bucket split cases for when the insertion
!		   point and the bucket split point are the same and no empty
!		   buckets are involved. For all three cases, two passes must
!		   be made, and for all three cases no code existed for Prolog 
!		   3 buckets. Changes were made to RM$RECORD_SIZE, RM$SHFT_VBNS
!		   and RM$V3_IDX_REC to support these three bucket split cases.
!		   The changes made to RM$V3_IDX_REC allow the routine to
!		   recognize these three two-pass bucket split cases, which of 
!		   the two passes is in progress, and to take the appropriate
!		   action. As the VBNs in prolog 3 buckets are order from
!		   right to left and "grow inwards", if a index record with a
!		   key value less than the current high key value of the bucket
!		   is inserted, the VBNs must be shifted to make room for the
!		   VBN associated with the just inserted key. The routine which
!		   performs this shifting (RM$SHFT_VBNS) had to be modified to 
!		   recognize these three bucket split cases, which of the two 
!		   passes was current, and perform any required VBN shifting. 
!		   Finally, RM$RECORD_SIZE had to be similary modified so that
!		   it would return the size of the index record to be inserted
!		   into the "current" bucket. The size, of course, as well as 
!		   the current bucket depends upon the split case, and which 
!		   of the two passes is currently under way. The three bucket 
!		   split cases and their effect on these routines are as 
!		   follows:
!
!		   TWO-BUCKET SPLIT:
!		   During the first pass (when the index record contents of the
!		   old bucket are updated) just a key is added. The size of the
!		   record is the size of the key, and no VBNs need be shifted.
!		   During the second pass (when the index record contents of 
!		   the new index bucket are appropriately modified), just a VBN
!		   is updated. The size of the record is the difference between
!		   the VBN size required to hold the old data level VBN and the
!		   size required to hold the new data level VBN. No VBN 
!		   shifting is required unless the size is greater than 0.
!
!		   THREE-BUCKET SPLIT - ONE KEY IN EACH INDEX BUCKET:
!		   During the first pass, just a key is added to the contents 
!		   of the old index bucket so the record size is the size of
!		   the key and the no VBNs need be shifted. During the second 
!		   pass, a new key and VBN is added as the low order key in the
!		   new index bucket, and a VBN is also updated. In this case
!		   VBNs must be shifted to make room for the new VBN and any
!		   change in VBN size, and the record size includes the key 
!		   added, the VBN added, and any difference in data level 
!		   VBN size.
!
!		   THREE-BUCKET SPLIT - BOTH KEYS IN OLD INDEX BUCKET:
!		   This split case only occurs when the insertion point and
!		   the split point are at the beginning of the old index
!		   bucket and both keys in the old bucket must be moved out
!		   to make room for the two new keys. During the first pass,
!		   both keys are added as is a VBN. The record size is the
!		   size of the two keys and the VBN added, and no VBN shifting
!		   need take place. During the second pass just a VBN is
!		   updated. The record size is computed to be any difference
!		   in sizes required to hold data level VBNs, and VBN shifting
!		   takes place only if there is a difference.
!
!	V02-017	TMK0001		Todd M. Katz		11-Jan-1982
!		Make a change to RM$SHFT_VBNS which affects three-way bucket
!		splits where one of the resulting buckets is empty. The
!		routine was adjusting the offset pointer to where the
!		VBN shift should start. This is wrong, and in fact, caused
!		index corruption so I removed it.
!
!	V02-016	PSK0007		Paulina S. Knibbe	14-Dec-1981
!		Change record_size to take BKT_ADDR as an input
!
!	V02-015	PSK0006		Paulina S. Knibbe	26-Oct-1981
!		Add support for compressed indexes to rm$v3key_sz
!
!	V02-014	PSK0005		Paulina S. Knibbe	15-Aug-1981
!		Fix some problems w/large VBNs in index buckets.
!
!	V02-013	PSK0004		Paulina S. Knibbe	29-Jul-1981
!		Remove support for growing prologue three compressed
!		indexes. Add code to handle indexes with no  chars
!		compressed off of the rear.
!
!	V02-012	PSK0003		Paulina S. Knibbe	24-Jul-1981
!		Fix off-by-one error in SHIFT_VBNS; other problems
!		with growing VBNs
!
!	V02-011	PSK0002		Paulina S. Knibbe	13-Jul-1981
!		Add 'RM$SHFT_VBNS' to handle spreading the VBN chain
!		in prologue three index buckets.
!
!	V02-010	MCN0007		Maria del C. Nasr	28-Jun-1981
!		Add RM$MOVE_SIG_CNT. 
!
!	V02-009	PSK0001		Paulina S. Knibbe	08-Jun-1981
!		Add support for prologue three index buckets:
!		RM$RECORD_SIZE, RM$NEW_VBN_BYTES, RM$V3KEY_SZ
!		RM$V3_IDX_REC,RM$ADD_V3VBN,RM$ADD_V3KEY
!
!	V02-008	MCN0006		Maria del C. Nasr	16-Mar-1981
!		Increase size of record identifier to a word in the NRP.
!		Change linkage to RM$RECORD_SIZE to include IFAB.
!
!	V02-007	REFORMAT	C D Saether	01-Aug-1980	18:10
!
!	V0006	CDS0077		C D SAETHER	24-JAN-1980	13:50
!		Don't want to create dupes count field on continuation
!		SIDR arrays either.
!
!	V0005	CDS0071		C D SAETHER	15-JAN-1980	12:28
!		Fix bug creating dupes count field in SIDR records when
!		dupes aren't allowed (rm$record_size and rm$bld_new_sidr).
!
! Revision history:
!
!   Wendy Koenig, 	24-OCT-78  14:02
!   X0002 - MAKE CHANGES CAUSED BY SHARING CONVENTIONS
!
!   Christian Saether, 	26-JAN-79  9:01
!   X0003 - check down pointer before attempting to swing from empty bucket
!
!   Christian Saether,  1-july-79  11:00
!   X0004 - fix nxtrecid logic in RM$INS_REC (caused re-use of ID's)
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

!
! define default psects for code
!

PSECT
    CODE = RM$RMS3(PSECT_ATTR),
    PLIT = RM$RMS3(PSECT_ATTR);

!
! Linkages

LINKAGE
    L_COMPARE_KEY,
    L_JSB,
    L_JSB01,
    L_PRESERVE1,
    L_RABREG_567,
    L_RABREG_67,
    L_RABREG_7,
    L_REC_OVHD,

    ! Local Linkages
    !
    RL$ADD_TO_ARRAY = JSB () :
		      GLOBAL (R_IDX_DFN, R_IRAB, R_IFAB, R_REC_ADDR),
    RL$COMMON_LINK  = JSB (STANDARD) :
	      	      GLOBAL (R_BKT_ADDR, R_IFAB, R_IRAB, R_IDX_DFN, R_REC_ADDR),
    RL$MOVE_IN_VBN  = JSB (REGISTER = 2) :
		      GLOBAL (R_REC_ADDR)
		      NOPRESERVE (2),
    RL$NEW_VBN_BYTES = JSB () : 
		       GLOBAL (R_BKT_ADDR, R_IDX_DFN);

! Forward Routines
!
FORWARD ROUTINE
    RM$MOVE_IN_VBN	: RL$MOVE_IN_VBN NOVALUE,
    RM$SHFT_VBNS	: RL$COMMON_LINK NOVALUE,
    RM$V3_IDX_REC	: RL$COMMON_LINK NOVALUE,
    RM$V3KEY_SZ		: RL$COMMON_LINK,
    RM$VBN_SIZE		: RL$PRESERVE1;

! External Routines
!
EXTERNAL ROUTINE
    RM$CNTRL_ADDR	: RL$RABREG_567,
    RM$COMPARE_KEY	: RL$COMPARE_KEY,
    RM$COMPRESS_KEY	: RL$JSB01,
    RM$GETNEXT_REC	: RL$RABREG_67,
    RM$MOVE		: RL$PRESERVE1,
    RM$NOREAD_LONG	: RL$JSB,
    RM$RECOMPR_KEY	: RL$JSB01,
    RM$RECORD_VBN	: RL$PRESERVE1,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$V3_VBN		: RL$RABREG_567;

MACRO
    KEY_LEN	= 0,0,8,0 %,
    CMPR_CNT	= 1,0,8,0 %;


%SBTTL	'RM$ADD_TO_ARRAY'
ROUTINE RM$ADD_TO_ARRAY : RL$ADD_TO_ARRAY NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds a new array to an existing SIDR array, and updates
!	the size field of the SIDR.
!
! CALLING SEQUENCE:
!
!	RM$ADD_TO_ARRAY()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IFAB			- address of IFAB
!	    IFB$B_PLG_VER	- prologue version of the file
!
!	IRAB			- address of IRAB
!	    IRB$L_LST_REC	- address of beginning of SIDR
!	    IRB$W_PUTUPD_ID	- ID of UDR to put into record pointer
!	    IRB$L_PUTUPD_VBN	- VBN of UDR to put into record pointer
!
!	REC_ADDR		- address of where new array element is to go
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	
!	REC_ADDR points 	- address of SIDR's size field
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IDX_DFN,
	R_IFAB_STR,
	R_IRAB_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	R_RAB,
	R_IMPURE,
	R_BDB;

    LOCAL
	VBN_SIZE	: BYTE,
	TOTAL_SIZE	: BYTE;

    ! Determine what will be the size of the record pointer's VBN.
    !
    VBN_SIZE = RM$VBN_SIZE (.IRAB[IRB$L_PUTUP_VBN]);

    ! Set up the pointer size field in the new array element's control byte.
    !
    (.REC_ADDR)<0, 8> = .VBN_SIZE - 2;
    REC_ADDR = .REC_ADDR + 1;

    ! Insert the record pointer's ID into the new SIDR array element, and
    ! compute the overall size of the new SIDR array element. Both of these
    ! steps are prologue dependent.
    !
    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	BEGIN
	(.REC_ADDR)<0, 8> = .IRAB[IRB$W_PUTUP_ID];
	REC_ADDR = .REC_ADDR + 1;
	TOTAL_SIZE = .VBN_SIZE + IRC$C_DATOVHDSZ;
	END
    ELSE
	BEGIN
	(.REC_ADDR)<0, 16> = .IRAB[IRB$W_PUTUP_ID];
	REC_ADDR = .REC_ADDR + 2;
	TOTAL_SIZE = .VBN_SIZE + IRC$C_DATOVHSZ3;
	END;

    ! Insert the record pointer's VBN into the new SIDR array element.
    !
    (.REC_ADDR)<0, .VBN_SIZE*8> = .IRAB[IRB$L_PUTUP_VBN];

    ! Position to the size field of the SIDR, and update it to reflect
    ! the addition of the new array element. 
    !
    REC_ADDR = .IRAB[IRB$L_LST_REC];
    REC_ADDR = .REC_ADDR + RM$REC_OVHD(-1) - IRC$C_DATSZFLD;
    (.REC_ADDR)<0, 16> = .(.REC_ADDR)<0, 16> + .TOTAL_SIZE;
    END;

%SBTTL	'RM$ADD_V3KEY'
ROUTINE RM$ADD_V3KEY (KEY_ADDR) : RL$COMMON_LINK NOVALUE =
!++
!
! RM$ADD_V3KEY
!
!	This routine inserts the key at KEY_ADDR into the bucket at REC_ADDR
!	The contents of the bucket have already been spread apart. The
!	trailing record is recompressed if necessary.
!
! CALLING SEQUENCE:
!
!	RM$ADD_V3KEY()
!
! IMPLICIT INPUTS:
!	IFAB
!	REC_ADDR
!	BKT_ADDR
!	IDX_DFN
!	IRAB[IRB$V_BIG_SPLIT]
!	IRAB[IRB$V_EMPTY_BKT]
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	REC_ADDR points past the inserted key
!	IRAB[IRB$L_LST_NCMP] may possibly be updated
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    MAP
	KEY_ADDR : REF BBLOCK;

    EXTERNAL REGISTER
	R_IDX_DFN_STR,
	R_IFAB_STR,
	R_REC_ADDR_STR,
	R_BKT_ADDR_STR,
	R_IRAB_STR;

    GLOBAL REGISTER
	R_BDB,
	R_IMPURE,
	R_RAB;

    IF NOT .IDX_DFN [IDX$V_IDX_COMPR]
    THEN

	! Fixed length index key.
	!
	BEGIN
	REC_ADDR = RM$MOVE (.IDX_DFN [IDX$B_KEYSZ], .KEY_ADDR, .REC_ADDR);
	RETURN
	END;

    ! Compressed index key
    ! First fill in the length and compression count
    !
    RM$COMPRESS_KEY (.KEY_ADDR);

    ! Now move in the new key including the two bytes of compression overhead.
    !
    RM$MOVE (.KEY_ADDR[KEY_LEN] + 2,
	     .KEY_ADDR,
	     .REC_ADDR);

    ! Fix up next record (front compression might change). This will be done
    ! only when a single a key is to be added, or when the second of two keys
    ! is being added. A key must also trail the key just inserted for this
    ! recompression to be performed.
    !
    IF (NOT .IRAB[IRB$V_BIG_SPLIT] OR  .IRAB[IRB$V_EMPTY_BKT])
	AND
	(.REC_ADDR + .REC_ADDR[KEY_LEN] + 2 
		LSSU .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE])
    THEN 
	RM$RECOMPR_KEY (.REC_ADDR, .REC_ADDR + .REC_ADDR [KEY_LEN] + 2);

    ! If the key to be added is the first of two keys (from a multibucket split)
    ! and the front compression of the key just added is 0, increment the pointer
    ! to the last noncompressed key to this key to make the determination of the
    ! front compression of the second of the two keys easier.
    !
    IF .IRAB[IRB$V_BIG_SPLIT] AND (.REC_ADDR[CMPR_CNT] EQLU 0)
    THEN
	IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

    ! Reset REC_ADDR to point to the key which follows the key(s) just inserted
    !
    REC_ADDR = .REC_ADDR + .REC_ADDR [KEY_LEN] + 2;

    RETURN

    END;

%SBTTL	'RM$ADD_V3VBN'
ROUTINE RM$ADD_V3VBN (VBN) : RL$COMMON_LINK NOVALUE =
!++
!
! RM$ADD_V3VBN
!
!	This routine adds a VBN to the chain at the end of the bucket.
!	If the VBN is longer than the current VBN size all VBNs grow
!	by the appropriate number of bytes.
!
! CALLING SEQUENCE:
!
!	RM$ADD_V3VBN(.VBN)
!
! IMPLICIT INPUTS:
!	IRAB
!	BKT_ADDR
!	IDX_DFN
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    MACRO
	OFFSET = 0,0,16,0 %;

    EXTERNAL REGISTER
	R_IDX_DFN_STR,
	R_IRAB_STR,
	R_REC_ADDR_STR,
	R_IFAB_STR,
	R_BKT_ADDR_STR;

    GLOBAL REGISTER
	R_BDB,
	R_RAB,
	R_IMPURE;

    LOCAL
	NEW_SIZE,
	OLD_SIZE;

    NEW_SIZE = RM$VBN_SIZE (.VBN);
    OLD_SIZE = .BKT_ADDR [BKT$V_PTR_SZ] + 2;

    IF .NEW_SIZE GTRU .OLD_SIZE
    THEN

	! We need to shuffle all of the VBNs down
	! First figure out where to move them.
	!
	BEGIN

	LOCAL
	    OLD_END	: REF BBLOCK,
	    NUM_RECS,
	    NEW_END,
	    SAVE;

	OLD_END = .BKT_ADDR  + (.IDX_DFN [IDX$B_IDXBKTSZ] * 512) - BKT$C_ENDOVHD;
	NUM_RECS = (.OLD_END - (.BKT_ADDR+.OLD_END [OFFSET])) / .OLD_SIZE;
	NEW_END = .OLD_END - (.NUM_RECS * .NEW_SIZE);

	IF .BKT_ADDR [BKT$B_LEVEL] EQLU 0
	    AND .IDX_DFN [IDX$V_DUPKEYS]
	THEN
	    NEW_END = .NEW_END - 4;

	OLD_END [OFFSET] = .NEW_END - .BKT_ADDR - 1;

	! Now actually move them
	!
	SAVE = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_REC_COUNT] = .NUM_RECS - 1;

	WHILE .IRAB [IRB$L_REC_COUNT] GEQ 0
	DO
	    BEGIN
	    (.NEW_END) <0,8 * .NEW_SIZE> = .(RM$CNTRL_ADDR())<0,8*.OLD_SIZE>;
	    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] - 1;
	    NEW_END = .NEW_END + .NEW_SIZE
	    END;

	IRAB [IRB$L_REC_COUNT] = .SAVE;

	! Update the VBN size
	!
	BKT_ADDR [BKT$V_PTR_SZ] = .NEW_SIZE - 2

	END;

    ! Actually add the new VBN
    !
    BEGIN

    LOCAL
	ADDR;

    ADDR = RM$CNTRL_ADDR();
    (.ADDR) <0,.NEW_SIZE * 8> = .VBN

    END; ! Of local ADDR

    END;

%SBTTL	'RM$BKT_SORT'
GLOBAL ROUTINE RM$BKT_SORT (BKT_ADDR) : RL$RABREG_7 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! this routine scans the bucket, makes a table of all used ID's,
! and then updates the NXTRECID and LSTRECID fields to reflect the existence
! of the lowest range of un-used ID's available.
!
! CALLING SEQUENCE:
!	RM$BKT_SORT (BKT_ADDR)
!
! INPUT PARAMETERS:
!	BKT_ADDR - pointer to bucket to be searched for ID's
!
! IMPLICIT INPUTS:
!	IDX_DFN - pointer to index descriptor
!	IRAB - pointer to internal RAB
!	IFAB - IFAB
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	low bit set if success (at least one ID was found)
!	low bit clear if all ID's in use
!
! SIDE EFFECTS:
!	NXTRECID is set to lowest ID available
!	LSTRECID is set to highest contiguous ID available after NXTRECID
!
!--

    BEGIN

    MAP
	BKT_ADDR	: REF BBLOCK;

    EXTERNAL REGISTER
	R_IDX_DFN,
	R_IFAB,
	R_IRAB;

    GLOBAL REGISTER
	R_REC_ADDR_STR;

    LOCAL
	BIT_NUM,
	BIT_LEN;

    ! create 8 longword array for table of used ID's
    !

    STACKLOCAL
	USED_IDS	: VECTOR [8];

    LOCAL
	EOB;

    DECR I FROM 7 TO 0 DO
	USED_IDS[.I] = 0;

    BEGIN

    MAP
	USED_IDS	: BITVECTOR [256];

    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    EOB = .BKT_ADDR[BKT$W_FREESPACE] + .BKT_ADDR;

    ! scan records in bucket.  set bit in bitvector for those id values found.
    !
    WHILE .REC_ADDR LSSA .EOB
    DO
	BEGIN

	GLOBAL REGISTER
	    R_RAB,
	    R_IMPURE;

	USED_IDS[.REC_ADDR[IRC$B_ID]] = 1;
	RM$GETNEXT_REC();
	END;

    USED_IDS[0] = 0;				! flag set when a free id found
    USED_IDS[255] = 1;				! make sure last one always set
    END;					! of USED_IDS as bitvector
    BIT_LEN = 31;
    BIT_NUM = 1;

    ! now search the bit array for the first clear bit (that corresponds to
    ! an unused id value) one longword at a time.  when found, check the
    ! remaining bits in that longword looking for a used id.  if none found
    ! there, continue searching the remaining longwords in the array to
    ! determine the extent of the unused id values.
    !
    INCR I FROM 0 TO 7 DO

	IF NOT .USED_IDS
	THEN
	    BEGIN

	    IF NOT FFC(BIT_NUM, BIT_LEN, USED_IDS[.I], BIT_NUM)
	    THEN
		BEGIN
		BKT_ADDR[BKT$B_NXTRECID] = .I*32 + .BIT_NUM;
		USED_IDS<0, 1> = 1;
		BIT_LEN = 32 - .BIT_NUM;

		IF NOT FFS(BIT_NUM, BIT_LEN, USED_IDS[.I], BIT_NUM)
		THEN
		    BEGIN
		    BKT_ADDR[BKT$B_LSTRECID] = .I*32 + .BIT_NUM - 1;
		    EXITLOOP;

		    END
		ELSE
		    BIT_LEN = 32;

		END;

	    BIT_NUM = 0;
	    END
	ELSE

	    IF NOT FFS(BIT_NUM, BIT_LEN, USED_IDS[.I], BIT_NUM)
	    THEN
		BEGIN
		BKT_ADDR[BKT$B_LSTRECID] = .I*32 + .BIT_NUM - 1;
		EXITLOOP;

		END
	    ELSE
		BEGIN
		BIT_LEN = 32;
		BIT_NUM = 0;
		END;

    ! if this is clear, no free id's were found.  if set, at least one
    ! is available.
    !
    RETURN .USED_IDS[0];

    END;

%SBTTL	'RM$BLD_IDX_REC'
ROUTINE RM$BLD_IDX_REC (REC_SZ) : RL$COMMON_LINK NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine builds an index record in the buffer.  It will do one of the
! following:
!
!	0) Call RM$V3_IDX_REC to do everything for prologue three index
!	buckets.
!
!	1) replace key value of existing down pointer with the new high key
!	value (in keybuffer 2) of the original bucket (described as vbn_left)
!	and use that key value along with the value of vbn_right to create
!	a new index record pointing to the right hand bucket of the split.
!
!	2) same as the above except create another record between the two
!	described using the contents of keybuffer 3 and vbn_right.  this
!	record points to the middle record of a 3 or 4 bucket split.
!
!	3) as an option on the first situation (1), change the down
!	pointer to be the value of vbn_mid if the current down pointer matches
!	the value in vbn_left.
!
!	4) build only the left hand part of the possible pieces described above
!	and make the break just before the potential new middle bucket pointer.
!
!	5) build the part remaining after only doing 4).
!
! Any modifications to this code should be done only after thoroughly
! understanding the interactions between this routine, RM$RECORD_SIZE,
! and RM$SPLIT_EM.
!
! CALLING SEQUENCE:
!	RM$BLD_IDX_REC (REC_SZ)
!
! INPUT PARAMETERS:
!	REC_SZ	- total size of record to be inserted
!
! IMPLICIT INPUTS:
!	REC_ADDR - points to location in buffer where record is to be built
!
!	IRAB	[vbn_left] - left hand (original) bucket in split.  zero if
!			only right hand part of record to be built.
!		[vbn_mid] - possible middle bucket in 3 or 4 bucket split
!		[vbn_right] - right hand bucket of split
!		[empty_bkt] - left hand bucket is dead, i.e., no data records
!		[big_split] - more than 1 new bucket in split
!		[spl_idx] - only build left hand part of index record
!		[pos_ins] - position of insert of the new record
!		[keybuf] - address of keybuffers
!
!	IFAB	[kbufsz] - size of keybuffers
!
!	IDX_DFN	[keysz] - size of this key
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR - points to first byte beyond record.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_REC_ADDR_STR,
	R_IRAB_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR;

    GLOBAL REGISTER
	R_BDB,
	R_IMPURE,
	R_RAB;

    IF .IFAB [IFB$B_PLG_VER] EQLU PLG$C_VER_3
    THEN

	! Prologue three index records. They basically
	! have nothing in common with pre-prologue three
	! index records. Just call the routine that
	! handles them and get out.
	!
	BEGIN

	RM$V3_IDX_REC (.REC_SZ);
	RETURN
	END;

    ! first key we have to build if present is the new key for the left
    ! hand bucket this will be zero only when splitting up index record when
    ! two new key values are required - currently 'empty' buckets (i.e.,
    ! buckets which end up without any records in them after a split) are not
    ! removed from the index
    !

    IF .IRAB[IRB$L_VBN_LEFT] NEQ 0
    THEN

	! the bucket has already been spread apart but the index record we
	! positioned to still exists where we found it, so using the existing
	! pointer, change the key value to the high key of VBN_LEFT
	!
	BEGIN

	! check for empty bucket situation, compare down pointers before
	! deciding whether to modify down pointer or not
	!

	IF .IRAB[IRB$V_EMPTY_BKT]
	THEN
	    BEGIN

	    BUILTIN
		AP;

	    AP = 1;				! set for index level

	    IF .IRAB[IRB$L_VBN_LEFT] EQLA RM$RECORD_VBN()

		! current down pointer matches so modify down pointer
		!
	    THEN
		RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_MID])
	    ELSE
		REC_ADDR = .REC_ADDR + .REC_ADDR[IRC$V_PTRSZ] + IRC$C_IDXPTRBAS
		+ IRC$C_IDXOVHDSZ;		! advance past pointer

	    IF NOT .IRAB[IRB$V_BIG_SPLIT]
	    THEN
		RETURN;				! no more to do, quit

	    END
	ELSE
	    REC_ADDR = .REC_ADDR + .REC_ADDR[IRC$V_PTRSZ] + IRC$C_IDXPTRBAS +
	    IRC$C_IDXOVHDSZ;

	! move in key from keybuffer 2
	!
	REC_ADDR = RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(2), .REC_ADDR);

	! We move in the VBN from IRB$L_VBN_RIGHT if and only if this is a
	! one-pass multi-bucket empty bucket split case.
	!
	IF (.IRAB[IRB$V_EMPTY_BKT]
	    AND
	   .IRAB[IRB$V_BIG_SPLIT]
	    AND
	   NOT .IRAB[IRB$V_SPL_IDX])
	THEN
	    RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_RIGHT]);

	! We are done if this was a empty bucket split case
	!
	IF .IRAB[IRB$V_EMPTY_BKT]
	THEN
	    RETURN;

	END;

    ! At this point all bucket splits involving empty buckets have completed
    ! except for the second pass of the two-pass multi-bucket with empty
    ! bucket split case.
    !
    ! We continue for all other cases with one exception. When the insertion 
    ! point is found to be at the split point, two passes must be made - one
    ! to update the old bucket, and the second to update the new bucket. If
    ! this is the first pass to update the old bucket components we do not
    ! continue unless a multibucket split had occurred, two and only two
    ! index records could fit in an index bucket, and the split point requires
    ! both of them to be moved to the new bucket to make room for the two new 
    ! index records. In all other "first pass" situations we do not continue.
    !
    IF NOT .IRAB[IRB$V_SPL_IDX]
	OR
       (.IRAB[IRB$V_SPL_IDX] 
	    AND .IRAB[IRB$V_BIG_SPLIT]
	    AND .IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ)
    THEN
	BEGIN

	! If a multibucket split occurred, the middle VBN and its corresponding
	! key are inserted into the current index bucket with two exceptions.
	! If this is the second pass of a two-pass multibucket split case where
	! both records had to be put in the old index bucket, or of a two-pass
	! multi-bucket empty bucket split case, then this bucket updating does 
	! not take place.
	!
	IF .IRAB[IRB$V_BIG_SPLIT]
	    AND
	   (.IRAB[IRB$L_VBN_MID] NEQU 0)
	THEN
	    BEGIN
	    RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_MID]);

	    ! move in key from keybuffer 3
	    !
	    REC_ADDR = RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], 
		KEYBUF_ADDR(3), .REC_ADDR);
	    END;

	! Unless this is the first pass of one of the three two-pass index
	! bucket split cases, we always swing the pointer for VBN right.
	! If this is the first of two passes, we do not swing the pointer
	! because this pass is used to update the old index bucket components
	! and VBN_RIGHT must be swung during the second pass when the new
	! index components are updated.
	!
	IF NOT .IRAB[IRB$V_SPL_IDX]
	THEN 
	    RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_RIGHT]);
	END;

    END;

%SBTTL	'RM$BLD_NEW_SIDR'
ROUTINE RM$BLD_NEW_SIDR (SIDR_SIZE) : RL$COMMON_LINK NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! 	This routine builds a new SIDR using the key found in keybuffer 2.
!
! CALLING SEQUENCE:
!
!	RM$BLD_NEW_SIDR()
!
! INPUT PARAMETERS:
!
!	SIDR_SIZE	- full size of the new SIDR
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR		- address of SIDR bucket
!	    BKT$W_FREESPACE	- offset to first free byte in bucket
!	    BKT$B_NXTRECID	- next available ID in bucket
!
!	IDX_DFN			- address of index descriptor
!	    IDX$V_DUPKEYS	- if set, duplicate alternate keys are allowed
!	    IDX$V_KEY_COMPR	- if set, SIDR key compression is enabled
!	    IDX$B_KEYSZ		- size of alternate key
!
!	IFAB			- addres of IFAB
!	    IFB$W_KBUFSZ	- size of each of the contigious keybuffers
!	    IFB$B_PLG_VER	- prologue version of file
!
!	IRAB			- address of IRAB
!	    IRB$V_CONT_BKT	- if set, bucket is a continuation bucket
!	    IRB$V_DUP_KEY	- if set, not first SIDR with this key value
!	    IRB$L_KEYBUF	- address of contigious keybuffers
!
!	REC_ADDR		- address of point of insertion of new SIDR
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB[IRB$L_LST_REC]	- address of new SIDR
!	REC_ADDR 		- address of first byte following new SIDR 
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!
!	If the file is a prologue 1 or 2 file, BKT_ADDR[BKT$B_NXTRECID] will
!	    have been incremented by 1.
!	If key compression is enabled, and a SIDR follows the new SIDR being
!	    added, then its key will be re-compressed, and the SIDR bucket's
!	    freespace offset pointer updated appropriately.
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_IFAB_STR,
	R_IRAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    LOCAL
	FIRST_ARRAY_ADDR	: REF BBLOCK;

    ! Save the address of the point of insertion of the new SIDR.
    !
    IRAB[IRB$L_LST_REC] = .REC_ADDR;

    ! Create the record control byte, DUP_CNT (if appropriate), and record ID
    ! fields for the prologue 1 or 2 SIDR. It is not necessary to do this
    ! for prologue 3 SIDRs because they don't have any of these fields. After
    ! this step, REC_ADDR will be pointing to the size field of the new SIDR, 
    ! regardless of the file's prologue version.
    !
    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	BEGIN
	
	! If duplicate keys are allowed on this index, and this bucket is not a
	! continuation bucket, then a DUP_CNT field will be created as part
	! of the overhead of the new SIDR even though this field will not be
	! maintained. The control byte, ID, and DUP_CNT fields are initialized.
	!
	IF .IDX_DFN[IDX$V_DUPKEYS]
	    AND
	   NOT .IRAB[IRB$V_CONT_BKT]
	THEN
	    BEGIN
	    (.REC_ADDR)<0, 8> = 1;
	    REC_ADDR = .REC_ADDR + 1;

	    (.REC_ADDR)<0, 8> = .BKT_ADDR[BKT$B_NXTRECID];
	    REC_ADDR = .REC_ADDR + 1;

	    (.REC_ADDR)<0, 32> = 0;
	    REC_ADDR = .REC_ADDR + IRC$C_DCNTSZFLD;
	    END

	! Either duplicate alternate keys are not allowed, or if they are, this
	! bucket is a continuation bucket. In either case, it is not necessary
	! to allocate and initialize a DUP_CNT field. Just the control byte
	! and the ID field of the new record are intialized.
	!
	ELSE
	    BEGIN
	    (.REC_ADDR)<0, 8> = IRC$M_NODUPCNT;
	    REC_ADDR = .REC_ADDR + 1;

	    (.REC_ADDR)<0, 8> = .BKT_ADDR[BKT$B_NXTRECID];
	    REC_ADDR = .REC_ADDR + 1;
	    END;

	! Increment the next record ID field in the bucket.
	!
	BKT_ADDR[BKT$B_NXTRECID] = .BKT_ADDR[BKT$B_NXTRECID] + 1;
	END;

    ! If key compression is not enabled, copy the new SIDR's key from keybuffer
    ! 2 into its place in the SIDR bucket, and initialize the new SIDR's record
    ! size to be the size of the key. This size field will be updated to its
    ! correct value (key size + SIDR array size) by the routine which will 
    ! create the first element in the SIDR array.
    !
    BEGIN

    GLOBAL REGISTER
	R_BDB,
	R_IMPURE,
	R_RAB;

    IF NOT .IDX_DFN[IDX$V_KEY_COMPR]
    THEN
	BEGIN
	(.REC_ADDR)<0, 16> = .IDX_DFN[IDX$B_KEYSZ];
	REC_ADDR = .REC_ADDR + IRC$C_DATSZFLD;

	REC_ADDR = RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(2), .REC_ADDR);
	END

    ! If key compression is enabled, the key in keybuffer 2 must first be
    ! compressed before it is moved into the SIDR bucket. The key of the 
    ! following SIDR (if there is one) must also be re-compressed using the
    ! new SIDR's key. Finally, the size field must be initialized to the size of
    ! the new SIDR's compressed key plus the two bytes of key compression
    ! overhead. This size field will be updated to its correct value (key size +
    ! SIDR array size) by the routine which will create the first element in 
    ! the SIDR array.
    !
    ELSE
	BEGIN

	LOCAL
	    KEYBUF	: REF BBLOCK;

	! Compress the new SIDR's key within its keybuffer - keybuffer 2.
	!
	KEYBUF = KEYBUF_ADDR(2);
	RM$COMPRESS_KEY (.KEYBUF);

	! Fix up the front compression of the following record because it might
	! change due to the insertion of this new SIDR. Of course, this step
	! is unnecessary, if there is no following record.
	!
	IF (.REC_ADDR + .SIDR_SIZE LSSU .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE])
	THEN
	    RM$RECOMPR_KEY (.KEYBUF, .REC_ADDR + IRC$C_DATSZFLD + .SIDR_SIZE);

	! Initialize the size field of the new SIDR to the size of the 
	! compressed key plus the two bytes of key compression overhead, and
	! move the new SIDR key into the bucket including the two bytes of
	! compression overhead.
	!
	(.REC_ADDR)<0,16> = .KEYBUF[KEY_LEN] + IRC$C_KEYCMPOVH;
	REC_ADDR = .REC_ADDR + IRC$C_DATSZFLD;

	REC_ADDR = RM$MOVE (.KEYBUF[KEY_LEN] + 2, .KEYBUF, .REC_ADDR);
	END;
    END;

    ! Save the address of what will be the first array element in this SIDR
    ! before creating the array.
    !
    FIRST_ARRAY_ADDR = .REC_ADDR;
    RM$ADD_TO_ARRAY();

    ! If this is a prologue 3 file, and this is the first such SIDR with this 
    ! key value in the file, then set a bit indicating this in the control byte 
    ! of the SIDR array's first element.
    !
    IF  .IFAB[IFB$B_PLG_VER] GEQU PLG$C_VER_3
	 AND
	NOT .IRAB[IRB$V_DUP_KEY]
    THEN
	FIRST_ARRAY_ADDR[IRC$V_FIRST_KEY] = 1;
    END;

%SBTTL	'RM$FOOLED_YUH'
GLOBAL ROUTINE RM$FOOLED_YUH : RL$RABREG_7 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! routine to do all the probing, etc. to make sure the user hasn't
! been fooling around w/ rsz, rbf or the buffer describing his record
! between the time i started to position for insert and i go to insert
!
!
! CALLING SEQUENCE:
!	bsbw rm$fooled_yuh
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	irab -- mode, address of internal key buffer to check against
!	IFAB -- kbufsz
!	rab -- rsz, rbf
!	idx_dfn -- minrecsz, keysz
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	rmssuc if the user has been considerate
!	rsz or rbf if not
!
! SIDE EFFECTS:
!	ap is clobbered
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_IRAB_STR,
	R_RAB_STR,
	R_IDX_DFN_STR;

    LOCAL
	RBF_ADDR,
	STATUS;

    BUILTIN
	AP;

    ! do all the probing and comparing to make sure the user hasn't been
    ! fooling around w/ the record buffer
    !

    IF .RAB[RAB$W_RSZ] LSSU .IDX_DFN[IDX$W_MINRECSZ]
    THEN
	RETURN RMSERR(RSZ);

    RBF_ADDR = .RAB[RAB$L_RBF];
    IF RM$NOREAD_LONG(.RAB[RAB$W_RSZ], .RBF_ADDR, .IRAB[IRB$B_MODE])
    THEN
	RETURN RMSERR(RBF);

    AP = 2;

    ! If keys do not match, return error
    !

    IF RM$COMPARE_KEY(.RBF_ADDR,
		KEYBUF_ADDR(3),
		.IDX_DFN[IDX$B_KEYSZ])
    THEN
	RETURN RMSERR(RBF);

    RETURN RMSSUC()

    END;

%SBTTL	'RM$INS_REC'
GLOBAL ROUTINE RM$INS_REC (BUCKET, REC_SZ) : RL$RABREG_67 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Insert new record into bucket.  Check for ID availability if required,
! make room by spreading existing records apart, and call appropriate
! routine to build the record.
!
! CALLING SEQUENCE:
!
!	RM$INS_REC()
!
! INPUT PARAMETERS:
!
!	BKT_ADDR - address of bucket in which to insert record
!	
!	REC_SZ - total size of record to be inserted
!
! IMPLICIT INPUTS:
!
!	REC_ADDR - is where to build the record
!
!	IRAB - internal stream context
!	    [dups_seen] - this is a duplicate record
!	    [spl_idx] - left hand part only of index record
!	    [pos_ins] - offset to position of insert
!
!	IFAB - internal file context, used by called routines
!
!	IDX_DFN - index descriptor, used by called routines
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	success
!	low bit clear if no id's available
!
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    GLOBAL REGISTER
  	R_BKT_ADDR_STR;

    LOCAL
	TEMP	: BBLOCK [6];

    MACRO
	OLD_OVHD 	= TEMP[0,0,16,0] %,
	LENGTH 		= TEMP[2,0,32,0] %,
	KEY_SZ		= REC_SZ<0,16> %,
	VBN_SZ		= REC_SZ<16,16>%;

    BKT_ADDR = .BUCKET;

    OLD_OVHD = 0;

    IF .IFAB [IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN

	BEGIN

	IF .BKT_ADDR [BKT$B_LEVEL] EQL 0
	THEN
	    BEGIN

	    IF NOT .IRAB[IRB$V_DUPS_SEEN]
		    AND
			(.BKT_ADDR [BKT$B_NXTRECID] EQL 0
			OR
			(.BKT_ADDR [BKT$B_NXTRECID] GTRU .BKT_ADDR [BKT$B_LSTRECID]))
	    THEN
		RETURN_ON_ERROR (RM$BKT_SORT(.BKT_ADDR));

	    END
	ELSE
	    IF NOT .IRAB[IRB$V_SPL_IDX]
	    THEN
		OLD_OVHD = .REC_ADDR[IRC$V_PTRSZ] + IRC$C_IDXPTRBAS +
			    IRC$C_IDXOVHDSZ;
	END;

    ! Figure out length of data to move and do it if non-zer0 - it will
    ! be zer0 when SIDR record is being inserted at the end of the bucket
    !
    !
    LENGTH = .BKT_ADDR[BKT$W_FREESPACE] - .IRAB[IRB$W_POS_INS] - .OLD_OVHD;

    IF (.LENGTH GTR 0)
	AND
       (.KEY_SZ GTR 0)
    THEN
	BEGIN

	GLOBAL REGISTER
	    R_BDB;

	RM$MOVE(.LENGTH, .REC_ADDR + .OLD_OVHD,
	    .REC_ADDR + .KEY_SZ + .OLD_OVHD);
	END;

    ! Update the freespace pointer to reflect new size of data area
    !
    BKT_ADDR [BKT$W_FREESPACE] = .BKT_ADDR [BKT$W_FREESPACE] + .KEY_SZ;

    IF  (.IFAB [IFB$B_PLG_VER] GEQU PLG$C_VER_3)
	 AND
	(.BKT_ADDR[BKT$B_LEVEL] GTRU 0)
    THEN

	! We must spread apart the VBN list for prologue 3 index records, also.
	!
	RM$SHFT_VBNS();

    ! Insert new index record and return success.
    !
    IF .BKT_ADDR [BKT$B_LEVEL] NEQU 0
    THEN
	BEGIN
	RM$BLD_IDX_REC (.REC_SZ);
	RETURN 1
	END;

    ! If duplicates have been seen, then RMS merely has to add a new SIDR
    ! array element to an existing array, otherwise, it must create a new
    ! SIDR.
    !
    IF .IRAB[IRB$V_DUPS_SEEN]
    THEN
	RM$ADD_TO_ARRAY()
    ELSE
	RM$BLD_NEW_SIDR (.REC_SZ);

    RETURN 1
    END;

%SBTTL	'RM$MOVE_IN_VBN'
ROUTINE RM$MOVE_IN_VBN (VBN) : RL$MOVE_IN_VBN NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! set pointer size field and move in VBN, updating REC_ADDR
!
! CALLING SEQUENCE:
!	RM$MOVE_IN_VBN(VBN)
!
! INPUT PARAMETERS:
!	VBN - VBN to move in
!
! IMPLICIT INPUTS:
!	REC_ADDR - address to move value to
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR - points one byte beyond where value placed
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_REC_ADDR;

    GLOBAL REGISTER
	COMMON_RABREG,
	R_BDB,
	R_IDX_DFN;

    BEGIN

    REGISTER
	SIZE = 1	: BYTE;

    ! get vbn size and set pointer field
    !
    SIZE = RM$VBN_SIZE(.VBN);
    (.REC_ADDR)<0, 8> = .SIZE - 2;
    REC_ADDR = .REC_ADDR + 1;

    ! stick in bucket pointer
    !
    (.REC_ADDR)<0, .SIZE*8> = .VBN;
    REC_ADDR = .REC_ADDR + .SIZE;
    END;
    END;

%SBTTL	'RM$NEW_VBN_BYTES'
ROUTINE RM$NEW_VBN_BYTES (VBN_SIZE) : RL$NEW_VBN_BYTES =
!++
!
! RM$NEW_VBN_BYTES
!
!    This routine returns the number of additional bytes which will
!    be needed if all the VBNs grow to VBN_SIZE
!
! CALLING SEQUENCE:
!
!	RM$NEW_VBN_BYTES (VBN_SIZE)
!
! INPUT PARAMETERS:
!	
!	VBN_SIZE - potential number of bytes per VBN
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR -  address of current bucket
!	IDX_DFN  -  index descriptor structure
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
!	R0 - number of new bytes which will be needed if all the
!	     VBNs in the bucket grow to be VBN_SIZE long
!
!--

    BEGIN

    MACRO
	FREESPC	= 0,0,16,0 %;

    GLOBAL REGISTER
	R_BKT_ADDR_STR,
	R_IDX_DFN_STR;

    LOCAL
	CUR_VBN_SZ,
	FIRST_VBN	: REF BBLOCK,
	NUM_VBNS;

    CUR_VBN_SZ = .BKT_ADDR [BKT$V_PTR_SZ] + 2;

    ! If VBNs didn't grow return
    !
    IF .VBN_SIZE LEQU .CUR_VBN_SZ
    THEN
	RETURN 0;

    ! Number of new bytes = (new_size - old_size) * num_vbns
    !
    FIRST_VBN = .BKT_ADDR + (.IDX_DFN [IDX$B_IDXBKTSZ] * 512) - BKT$C_ENDOVHD;
    NUM_VBNS = (.FIRST_VBN - (.BKT_ADDR + .FIRST_VBN [FREESPC]))/ (.BKT_ADDR [BKT$V_PTR_SZ] + 2);
    RETURN (.VBN_SIZE - .CUR_VBN_SZ) * .NUM_VBNS

    END;

%SBTTL	'RM$RECORD_SIZE'
GLOBAL ROUTINE RM$RECORD_SIZE : RL$RABREG_567 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Calculate record size of SIDR or index records
!
! CALLING SEQUENCE:
!
!	RM$RECORD_SIZE()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	IFAB		- for RM$RECORD_VBN
!	IRAB		- pointer to internal RAB
!		[ STOPLEVEL ] - current level in tree
!		[ DUPS_SEEN ] - flag set if duplicates seen
!		[ CONT_BKT ] - this is continuation bucket
!		[ BIG_SPLIT ] - flag set if more than two bucket split
!		[ VBN_LEFT ]  - VBN of leftmost bucket in split
!		[ VBN_RIGHT ] - VBN of rightmost bucket in split
!		[ VBN_MID ] - VBN of middle bucket in 3-4 bucket split
!		[ REC_COUNT ] - which record this is in the bucket
!		[ POS_INS ]  - position of insert of this record
!		[ KEYBUF ] - pointer to the 5 contigious keybuffers
!		[ PUTUP_VBN ] - VBN of new primary data record (for SIDR ptr)
!		[ PUTUP_ID ] - ID of new primary data record (for SIDR ptr)
!	IDX_DFN		- pointer to index descriptor structure
!		[ DUPKEYS ] - duplicate keys are allowed
!		[ KEYSZ ] - size of key
!	REC_ADDR - position of insert (used on index levels only)
!	BKT_ADDR - pointer to current bucket
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	size of record required
!
!	PROLOG 1 & 2:	Size is returned as a single quantity
!
!	PROLOG 3 Index:	Size is returned as two contigious words. 
!			High order word contains number of VBN bytes
!			Low order word contains number of key bytes
!
!	PROLOG 3 SIDR:  Size is returned as a single quantity
!
! SIDE EFFECTS:
!
!	sets AP = 1 when checking down pointer on empty bucket cases 
!	(index level).
!	Keybuffer 5 will be used if index/key compression is enabled.
!	Keybuffer 4 will be used if index compression is enabled and a big
!	split occurred.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_BKT_ADDR_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    GLOBAL REGISTER
	R_BDB;

    LOCAL
	SIZE;

    ! RMS is to determine the size of a new SIDR or SIDR array element.
    !
    IF .IRAB[IRB$B_STOPLEVEL] EQL 0
    THEN
	BEGIN

	! Calculate the size of the record pointer part of record (which will 
	! always be present). 
	!
	SIZE = RM$VBN_SIZE(.IRAB[IRB$L_PUTUP_VBN]);

	IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
	THEN
	    SIZE = .SIZE + IRC$C_DATOVHDSZ
	ELSE
	    SIZE = .SIZE + IRC$C_DATOVHSZ3;


	! If a new SIDR is required, then add in the size of the key, and the 
	! overhead associated with a SIDR.
	!
	IF NOT .IRAB[IRB$V_DUPS_SEEN]
	THEN

	    ! Prologue 1 and 2 SIDR.
	    !
	    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
	    THEN
		BEGIN
		
		! If duplicates are allowed, then the overhead for the SIDR
		! includes a four byte duplicate count field which will never
		! be used but is there for compatibility. This field is 
		! unnecessary, if the new SIDR is to go into a continuation 
		! bucket.
		!
		IF .IDX_DFN[IDX$V_DUPKEYS]
		    AND
		   NOT .IRAB[IRB$V_CONT_BKT]
		THEN
		    SIZE = .SIZE + IRC$C_DATOVHDSZ + IRC$C_DATSZFLD 
						   + IRC$C_DCNTSZFLD
		ELSE
		    SIZE = .SIZE + IRC$C_DATOVHDSZ + IRC$C_DATSZFLD;

		SIZE = .SIZE + .IDX_DFN[IDX$B_KEYSZ];
		END

	    ! Prologue 3 SIDR.
	    !
	    ELSE
		BEGIN
		SIZE = .SIZE + IRC$C_SDROVHSZ3 + RM$V3KEY_SZ (KEYBUF_ADDR(2));

		IF .IDX_DFN[IDX$V_KEY_COMPR]
		THEN
		    SIZE = .SIZE + IRC$C_KEYCMPOVH;
		END;
	END					! of SIDR data level


    ELSE

	IF .IFAB [IFB$B_PLG_VER] LSSU PLG$C_VER_3
	THEN

	    ! This is a Prolog 1 or 2 index bucket. The size to be returned is
	    ! given below for each of the possible split cases.
	    !
	    !  1) two-bucket split no empty buckets: 
	    !
	    !     size of new key + size of VBN_RIGHT 
	    !
	    !  2) two-bucket split empty bucket:
	    !
	    !     size of VBN_MID - size of old VBN in record 
	    !	  (only update VBN pointer)
	    !
	    !  3) multibucket split no empty buckets:
	    !
	    !     size of two new keys + size of first new VBN (VBN_MID)
	    !			       + size of second new VBN (VBN_RIGHT)
	    !
	    !  4) multibucket split with empty buckets:
	    !
	    !     size of two new keys + size of VBN_RIGHT
	    !     		       + size of VBN_MID 
	    !			       - size of old VBN in record 
	    !     (update one VBN pointer)
	    !
	    ! Two-pass Split Cases Without Empty Buckets.
	    !
	    !  5) first pass of two-pass two-bucket split case:
	    !
	    !     size of new key + size of old VBN in record
	    !
	    !  6) second pass of two-pass two-bucket split case:
	    !
	    !     size of VBN_RIGHT - size of old VBN in record 
	    !	  (only update VBN pointer)
	    !
	    !  7) first pass of two-pass multibucket split case -
	    !	  one of the new keys in each bucket:
	    !
	    !     size of first new key + size of old VBN in record
	    !
	    !  8) second pass of two-pass multibucket split case - 
	    !	  one of the new keys in each bucket:
	    !
	    !     size of second new key + size of new VBN (VBN_MID) 
	    !     			 + size of VBN_RIGHT 
	    !				 - size of old VBN in record
	    !	  (update one VBN pointer)
	    !
	    !  9) first pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     size of the two new keys + size of new VBN (VBN_MID)
	    !				   + size of old VBN in record
	    !
	    ! 10) second pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     size of VBN_RIGHT - size of old VBN in record 
	    !	  (only update VBN pointer) 
	    !
	    ! Two-pass Bucket Split Cases with Empty Buckets
	    !
	    ! 11) second pass of two-pass two-bucket split case:
	    !
	    !	  size of VBN_MID - size of old VBN in record
	    !	  (only update VBN pointer)
	    !
	    ! 11) first pass of two-pass multi-bucket split case:
	    !
	    !	  size of new key + size of VBN_MID
	    !			  - size of old VBN in record
	    !	  (only update VBN in pointer)
	    !
	    ! 13) second pass of two-pass multi-bucket split case:
	    !
	    !	  size of VBN_RIGHT - size of old VBN in record
	    !	  (update VBN pointer)
	    !
	    ! sizes are always computed so as to include any control bytes 
	    ! required
	    !
	    BEGIN
	    SIZE = 0;

	    ! Handle all empty bucket split cases
	    !
	    IF .IRAB[IRB$V_EMPTY_BKT]
	    THEN
	    	BEGIN
		AP = 1;				! set for index level

		! In all empty bucket split cases the existing down pointer
		! must match VBN_LEFT before we modify it. If it doesn't
		! match we can't change it or we may be causing crossed 
		! pointers down to the level below.
		!
	    	IF .IRAB[IRB$L_VBN_LEFT] EQLA RM$RECORD_VBN()
	    	THEN

		    ! If this is the first pass of the two-pass multi-bucket
		    ! with empty bucket split case then if we are going to 
		    ! swing the pointer the size is IRB$L_VBN_MID.
		    !
		    IF .IRAB[IRB$V_SPL_IDX]
		    THEN
			SIZE = RM$VBN_SIZE (.IRAB[IRB$L_VBN_MID])

		    ! Otherwise we are just going to change the VBN pointer in
		    ! place and the size is the difference between the current
		    ! size, and the size of the VBN that wuill replace it
		    ! (found in IRB$L_VBN_MID).
		    !
		    ELSE
			SIZE = RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]) -
			       .REC_ADDR[IRC$V_PTRSZ] - 2;

		IF NOT .IRAB[IRB$V_BIG_SPLIT]
		THEN
		    RETURN .SIZE;

		! If this is a sizing for the second pass of a two-pass
		! multi-bucket empty bucket split case, then the size of
		! the index record to be inserted is only the difference
		! between the size of the current record's VBN and the size
		! of the VBN that is to replace it.
		!
		IF (.IRAB[IRB$L_VBN_LEFT] EQLA 0)
		THEN
		    SIZE = RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT])
				- .REC_ADDR[IRC$V_PTRSZ] - 2

		! For all other multi-bucket empty bucket split cases, the
		! size of the index record(s) to be inserted includes the
		! key size, and in the case of the one-pass multi-bucket
		! empty bucket split case includes the size of the VBN in
		! IRB$L_VBN_RIGHT.
		!
		ELSE
		    BEGIN
		    SIZE = .SIZE + .IDX_DFN[IDX$B_KEYSZ] + 1;

		    IF NOT .IRAB[IRB$V_SPL_IDX]
		    THEN
			SIZE = .SIZE + RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]);
		    END;

		RETURN .SIZE;
		END;


	    ! Determine size of index records to be added for all bucket split
	    ! cases not involving empty buckets.
	    !
	    ! If this is not the first pass of a two-pass bucket split case,
	    ! compute the difference between the current record VBN pointer 
	    ! size and the size of the VBN to swing (VBN_RIGHT). This will
	    ! facilitate computation of the record size during the second
	    ! pass of all two-pass bucket split cases when a VBN pointer must
	    ! be updated (in fact becomes the size for two of the two-pass 
	    ! bucket split cases), and it becomes part of the compuation
	    ! of the VBN pointer size required for VBN_RIGHT for all one-pass
	    ! bucket split cases.
	    !
	    IF NOT .IRAB[IRB$V_SPL_IDX]
	    THEN
		SIZE = RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT])
			 - .REC_ADDR[IRC$V_PTRSZ] - 2;

	    ! The size of the middle key key and its corresponding VBN must be 
	    ! included in the computation of record size if this is a one-pass 
	    ! multibucket case, the first pass of the two-pass multibucket 
	    ! split case where both keys go in the same (old/left) index 
	    ! bucket, or the second pass of the two-pass multibucket split 
	    ! case where one of the new keys goes in each of the old and new 
	    ! index buckets and we are currently updating the new index 
	    ! bucket with the second of the two keys and its corresponding VBN.
	    !
	    IF (.IRAB[IRB$V_BIG_SPLIT] AND NOT .IRAB[IRB$V_SPL_IDX] AND
			.IRAB[IRB$L_VBN_MID] NEQU 0)
		OR
	       (.IRAB[IRB$V_SPL_IDX] 
			AND .IRAB[IRB$V_BIG_SPLIT]
			AND (.IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ))
	    THEN
		SIZE = .SIZE + RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]) +
		       .IDX_DFN[IDX$B_KEYSZ] + 1;

	    ! Finally, the size of the record must include the size of the
	    ! first key on all one-pass bucket split cases not involving
	    ! empty buckets, and on all two-pass bucket split cases during
	    ! the first pass when the contents of the old index buckets
	    ! are being updated. 
	    !
	    ! Note that the current record size is also added in. If this is a 
	    ! one-pass bucket split cases this quantity plus the difference 
	    ! between the VBN pointer size in the old record and the VBN 
	    ! pointer size required for VBN_RIGHT (already included within 
	    ! SIZE) yield the size of VBN_RIGHT. If this is one of the two-pass
	    ! bucket split cases, it is at this point that we include in the 
	    ! size determination the size of the old record's VBN pointer.
	    !
	    IF .IRAB[IRB$L_VBN_LEFT] NEQ 0
	    THEN
		SIZE = .SIZE + .REC_ADDR[IRC$V_PTRSZ] + 2 +
			.IDX_DFN[IDX$B_KEYSZ] + 1;

	    END

	
	ELSE

	    ! This is a Prolog 3 index bucket. The size to be returned is
	    ! given below for each of the possible split cases. Note that it
	    ! will always be possible for the VBN pointer size to change in
	    ! a bucket. This requires that the additional bytes needed to 
	    ! increase the VBN pointer size of every currently existing index 
	    ! record in the current bucket to the new value be included in the 
	    ! size determination.
	    !
	    !  1) two-bucket split no empty buckets: 
	    !
	    !     size of new key + VBN pointer size of bucket
	    !			  + number of new VBN bytes
	    !
	    !  2) two-bucket split empty bucket:
	    !
	    !     number of new VBN bytes
	    !	  (only update VBN pointer)
	    !
	    !  3) multibucket split no empty buckets:
	    !
	    !     size of two new keys + 2 * VBN pointer size of bucket
	    !			       + number of new VBN bytes
	    !
	    !  4) multibucket split with empty buckets:
	    !
	    !     size of two new keys + VBN pointer size of bucket
	    !     		       + number of new VBN bytes
	    !     (update one VBN pointer)
	    !
	    ! Two-pass Bucket Split Cases Without Empty Buckets
	    !
	    !  5) first pass of two-pass two-bucket split case:
	    !
	    !     size of new key + VBN pointer size of bucket
	    !			    number of new VBN bytes
	    !
	    !  6) second pass of two-pass two-bucket split case:
	    !
	    !     number of new VBN bytes
	    !	  (only update VBN pointer)
	    !
	    !  7) first pass of two-pass multibucket split case -
	    !	  one of the new keys in each bucket:
	    !
	    !     size of first new key + VBN pointer size of bucket
	    !				+ number of new VBN bytes
	    !
	    !  8) second pass of two-pass multibucket split case - 
	    !	  one of the new keys in each bucket:
	    !
	    !     size of second new key + VBN pointer size of bucket
	    !     			 + number of new VBN bytes
	    !	  (update one VBN pointer)
	    !
	    !  9) first pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     size of the two new keys + 2 * VBN pointer size of bucket
	    !				   + number of new VBN bytes
	    !
	    ! 10) second pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     number of new VBN bytes
	    !	  (only update VBN pointer) 
	    !
	    ! Two-pass Bucket Split Cases With Empty Buckets
	    !
	    ! 11) second pass of two-pass two-bucket split case:
	    !
	    !	  number of new VBN bytes
	    !	  (only update VBN pointer)
	    !
	    ! 12) first pass of two-pass multi-bucket split case:
	    !
	    !	  size of new key + number of new VBN bytes
	    !	  (update VBN pointer)
	    !
	    ! 13) second pass of two-pass multi-bucket split case:
	    !
	    !	  number of new VBN bytes
	    !	  (only update VBN pointer)
	    !
	    ! Sizes are always computed so as to include any control bytes 
	    ! required. For cases 3, 4, and 9, key size include compression
	    ! of the second record if compression is enabled.
	    !
	    BEGIN

	    ! First set up some useful constants
	    !
	    LOCAL
		CONTEXT	: REF BBLOCK,   ! Address of block containing context
					! for potential update of an existing 
					! index rec
		KEY_SZ,			! Number of bytes needed to store the
					! key of the index record(s)
					! (compression index is added in and
					! front compression of the second 
					! record is subtracted)
		VBN_SZ,			! Size of all the VBNs after the 
					! insertion (they could all grow by 
					! one or two bytes)
		NEW_VBN_BYTES;		! Number of bytes which will be added 
					! to the existing VBNs because of
					! changing to a larger VBN size 
					! (may be 0)

	    ! Determine the size (VBN_SZ) of the VBNs after insertion of the 
	    ! index records to be inserted, and the number of VBN bytes
	    ! (NEW_VBN_BYTES) which will have to be added inorder adjust the
	    ! VBN pointer size of the pre-existing index records to this value.
	    ! Determination of VBN_SZ will directly depend upon the bucket
	    ! split case of the current invocation of this routine.
	    !
	    NEW_VBN_BYTES = 0;

	    ! For all one-pass bucket split cases and two-pass two-bucket 
	    ! empty bucket split cases the VBN pointer size is the maximum of 
	    ! the number of bytes need to store the current bucket pointer 
	    ! size, VBN_RIGHT, and VBN_MID.
	    !
	    IF (NOT .IRAB[IRB$V_SPL_IDX])
		AND 
	       (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
	    THEN 
		VBN_SZ =  MAXU (RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]),
				RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]),
		   		.BKT_ADDR[BKT$V_PTR_SZ]+2)
	    ELSE

		! Determine VBN_SZ for the first pass of all two-pass
		! bucket split cases.
		!
		IF .IRAB[IRB$V_SPL_IDX]
		THEN 

		    ! For case 9 (two-pass multi-bucket split with both keys
		    ! in the same bucket) and case 12 (multi-pass multi-bucket
		    ! empty bucket split) VBN_SZ is the maximum number of 
		    ! bytes needed to store VBN_MID and the current bucket
		    ! VBN pointer size.
		    !
		    IF .IRAB[IRB$V_BIG_SPLIT]
		        AND
		       ((.IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ)
				 OR
				.IRAB[IRB$V_EMPTY_BKT])
		    THEN 
			VBN_SZ =  MAXU (RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]),
		   			.BKT_ADDR[BKT$V_PTR_SZ]+2)

		    ! For all other two-pass bucket split cases, the VBN_SZ
		    ! is the number of bytes need to store the current VBN 
		    ! pointer bucket size.
		    !
		    ELSE 
			VBN_SZ = .BKT_ADDR[BKT$V_PTR_SZ]+2

		! Determine VBN_SZ for the second pass of all two-pass
		! bucket split cases.
		!
		ELSE

		    ! For case 8 (two-pass multibucket split with a key
		    ! inserted in each of the buckets) VBN_SZ is the
		    ! number of bytes needed to store the maximum of the
		    ! current VBN bucket pointer size and VBN_MID.
		    !
		    IF .IRAB[IRB$L_VBN_MID] NEQU 0
		    THEN 
			VBN_SZ =  MAXU (RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]),
		   			RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]))

		    ! For all other two-pass bucket split cases, VBN_SZ becomes
		    ! the number of bytes needed to store VBN_RIGHT.
		    !
		    ELSE 
			VBN_SZ = RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]);

 	    NEW_VBN_BYTES = RM$NEW_VBN_BYTES(.VBN_SZ);

	    ! Determine the key size of the first key to be inserted.
	    ! The two bytes required as overhead for key compression are
	    ! included in the key size if index compression is enabled.
	    !
	    IF .IDX_DFN [IDX$V_IDX_COMPR]
	    THEN 
		KEY_SZ = 2
	    ELSE 
		KEY_SZ = 0;

	    ! For all one-pass bucket split cases where there are keys to be
	    ! inserted, and for the first pass of all two-pass bucket split
	    ! cases, the first key to be inserted is the key found in key
	    ! buffer 2.
	    !
	    IF (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
		AND
	       (NOT (.IRAB[IRB$V_EMPTY_BKT] AND NOT .IRAB[IRB$V_BIG_SPLIT]))
	    THEN 
		KEY_SZ = .KEY_SZ + RM$V3KEY_SZ (KEYBUF_ADDR(2))
	    ELSE

		! For the second pass of the two-pass multibucket split case
		! where a key goes in each of the two index buckets (case 8)
		! the first and only key to be inserted is actually the second
		! of the two keys to be inserted, and it is found in key
		! buffer 3.
		!
		IF NOT .IRAB[IRB$V_EMPTY_BKT]
		    AND
		   (.IRAB[IRB$L_VBN_MID] NEQU 0)
		THEN 
		    KEY_SZ = .KEY_SZ + RM$V3KEY_SZ (KEYBUF_ADDR(3))

		! For the second pass of all other two-pass split cases,
		! the key size is zero.
		!
		ELSE 
		    KEY_SZ = 0;

	    IF .IRAB [IRB$V_EMPTY_BKT]
	    THEN

		! We have an empty bucket. 
		!
		BEGIN
		SIZE = 0;

		! If there was a multiple bucket split, add new key and VBN
		! unless this is the second pass of a two-pass multi-bucket
		! empty bucket split case.
		!
		IF (.IRAB[IRB$V_BIG_SPLIT] 
		    AND
		   (.IRAB[IRB$L_VBN_LEFT] NEQA 0))
		THEN
		    BEGIN
		    SIZE = .KEY_SZ;

		    ! If this is not a two-pass split case, the number of
		    ! new VBN bytes is VBN size plus the number of bytes
		    ! which will have to be added because of a possible
		    ! VBN size change within the index bucket (will be
		    ! zero if no VBN size change occurred).
		    !
		    IF NOT .IRAB[IRB$V_SPL_IDX]
		    THEN
			NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ

		    ! If this is the first pass of a two-pass multi-bucket
		    ! empty bucket split case then the number of new VBN bytes
		    ! will be the number of bytes which will have to be added
		    ! because of a possible VBN size change within the index 
		    ! bucket provided we are allowed to update the VBN of the
		    ! current record because it is the same as the VBN of the
		    ! leftmost primary data bucket. If this is not the case,
		    ! then because we can't update the VBN (this could cause
		    ! crossed pointers down to the data level), the number
		    ! of new VBN bytes is set to zero.
		    !
		    ELSE
			IF (.IRAB[IRB$L_VBN_LEFT] NEQA RM$V3_VBN())
			THEN
			    NEW_VBN_BYTES = 0;
		    END

		! If there wasn't a multibucket split, and we are not going
		! to swing a pointer because this could be causing crossed
		! pointers down to the level below, then there is need to add
		! new VBN bytes.
		!
		ELSE 
		    IF  (NOT .IRAB[IRB$V_BIG_SPLIT]
			 AND
			(.IRAB [IRB$L_VBN_LEFT] NEQU RM$V3_VBN()))
		    THEN
			NEW_VBN_BYTES = 0;

	        END

	    ELSE
		    
		! No empty buckets. For now, assume that entire record
		! will fit into one bucket and compute its size.
		! Always add VBN and key unless this is the second pass of one 
		! of the two-pass bucket split cases where all we are going
		! to do is update a VBN pointer. In such cases, the size
		! returned does not include the size of a VBN and a key.
		!
		BEGIN
		SIZE = .KEY_SZ;

		IF (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
		    OR
		   (.IRAB[IRB$L_VBN_MID] NEQU 0)
		THEN
		    NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ;

		! If this is a one-pass multibucket split or the first pass
		! of a two-pass multibucket split where both index records
		! are to go in the same (old) index bucket, the size of the
		! index record must include (in addition to the key size of the
		! first index record, the new VBN size of the bucket, and the 
		! number of new VBN bytes which must be added to all 
		! pre-existing VBN pointers to make them all the same size) the
		! key size of the second index record (less its front 
		! compression if index compression is enabled) and the size of
		! another new VBN. If index compression is enabled, then the
		! key size will not include any rear-end truncated characters.
		!
		IF .IRAB[IRB$V_BIG_SPLIT]
		   AND
			((NOT .IRAB[IRB$V_SPL_IDX]
			 	AND .IRAB[IRB$L_VBN_LEFT] NEQU 0)
			 OR
			(.IRAB[IRB$V_SPL_IDX]
				AND .IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ))
	 	THEN
		    BEGIN
		    NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ;

		    IF NOT .IDX_DFN [IDX$V_IDX_COMPR]
		    THEN
			SIZE = .SIZE + .IDX_DFN [IDX$B_KEYSZ]
		    ELSE
			BEGIN

			LOCAL
			    KEYBUF3	: REF BBLOCK,
			    KEYBUF4	: REF BBLOCK,
			    KEYBUF5	: REF BBLOCK,
			    SAVE_BKT_ADDR;

			! To determine the size of both keys, we will
			! need key buffers 3, 4, and 5.
			!
			KEYBUF3 = KEYBUF_ADDR(3);
			KEYBUF4 = KEYBUF_ADDR(4);
			KEYBUF5 = KEYBUF_ADDR(5);

			! Move the second key into key buffer 4 and compress
			! it as if it was to go at the point of insertion
			! instead of following the first key (which is to
			! be inserted there). Then recompress the second key
			! based upon the first key (which is still in key 
			! buffer 5).
			!
			RM$MOVE (.KEYBUF3[KEY_LEN] + 2,
				 .KEYBUF3,
				 .KEYBUF4);
			RM$COMPRESS_KEY (.KEYBUF4);

			SAVE_BKT_ADDR = .BKT_ADDR;
			BKT_ADDR = 0;
			RM$RECOMPR_KEY (.KEYBUF5, .KEYBUF4);
			BKT_ADDR = .SAVE_BKT_ADDR;

			! Add the size of the second key to the size of the
			! first key to obtain the key contribution to the
			! size of the record.
			!
			SIZE = .SIZE + .KEYBUF4[KEY_LEN] + 2;
		        END;
		    END;
		END;

	    ! Return the size of the record for prolog 3 index buckets as two
	    ! contigious words. The high order word contains the number of VBN
	    ! bytes required while the low order word contains the number of
	    ! bytes required to hold the key(s).
	    !
	    RETURN (.NEW_VBN_BYTES)^16 + .SIZE;
	    END;

    ! Return the size of the prologue 1 & 2 record or Pprologue 3 SIDR as 
    ! a single unified quantity.
    !
    RETURN .SIZE;
    END;

%SBTTL	'RM$SHFT_VBNS'
ROUTINE RM$SHFT_VBNS : RL$COMMON_LINK NOVALUE =

!++
! 
!   RM$SHFT_VBNS
!
!	Spread the VBNs at the end of the bucket to make room for
!	the new VBN(s).
!
!	This routine handles the following conditions:
!		
!		1) two bucket split, no empty buckets
!		2) two bucket split, empty bucket
!		3) multi-bucket split (three or four), no empty buckets
!		4) multi-bucket split, empty buckets
!
!	The two-pass non-empty bucket bucket split cases which occur when the 
!	insertion point is found to be the same as the bucket split point are
!	handled as follows:
!
!		5) first pass two bucket split    - treated as 1)
!		6) second pass two bucket split   - treated as 2)
!		   first pass multi-bucket split
!		7) 	one in each bucket	  - treated as 4)
!		8)	both in old bucket	  - treated as 3)
!		   second pass multi-bucket split
!		9)	one in each bucket	  - treated as 4)
!	       10)	both in old bucket	  - treated as 2)
!
!	The two-pass empty bucket bucket split cases which occur when the 
!	insertion point is found to be the same as the bucket split point are
!	handled as follows:
!
!	       11) second pass two bucket split   - treated as 2)
!	       12) first pass multi-bucket split  - treated as 4)
!              13) second pass multi-bucket split - treated as 2)
!
!	In all cases it assumes that the new VBNs will be the same size
!	as the current VBNs. If they actually are larger, the routine that
!	inserts them will have to grow each one individually.
!
!    INPUT
!
!	none
!
!    IMPLICIT INPUT
!
!	IRAB
!	    [EMPTY_BUCKET]
!	    [BIG_SPLIT]
!	    [VBN_LEFT]
!	    [VBN_MID]
!	    [SPL_IDX]
!	    [POS_INS]
!	BKT_ADDR
!
!    OUTPUT
!
!	none
!
!    IMPLICIT OUTPUT
!
!	The VBN chain is spread apart and ready to insert new VBNs
!
!---

    BEGIN

    EXTERNAL REGISTER
	R_REC_ADDR_STR,
	R_BKT_ADDR_STR,
	R_IRAB_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR;

    GLOBAL REGISTER
	R_RAB,
	R_BDB,
	R_IMPURE;

    MACRO
	OFFSET = 0,0,16,0 %;

    LOCAL
	FREE_SPACE : REF BBLOCK,! Address of offset to VBN freespace
	LENGTH,			! Number of bytes to move
	SWING_FLG,		! Logical - so we don't have to check swing conditions
				!	    every time around
	INS_ADDR,		! Address where the new VBN will be inserted
	NUM_BYTES;		! Number of bytes which will be inserted

    ! The swing flag is set under the following bucket split cases:
    !
    !	1. All empty bucket split cases			 
    !	2. First pass multibucket split cases where one key goes 
    !	   in each of the two index buckets
    !	3. All second pass bucket split cases
    !    
    SWING_FLG = 0;

    IF .IRAB[IRB$V_EMPTY_BKT] 
	OR
	(.IRAB[IRB$L_VBN_LEFT] EQLU 0)
	OR
	(.IRAB[IRB$V_SPL_IDX]
		AND .IRAB[IRB$V_BIG_SPLIT]
		AND .IRAB[IRB$W_POS_INS] NEQU BKT$C_OVERHDSZ)
    THEN
	SWING_FLG = 1;

    ! Assume a two bucket split with no empties
    !
    INS_ADDR = RM$CNTRL_ADDR();
    NUM_BYTES = .BKT_ADDR [BKT$V_PTR_SZ] + 2;

    ! Consider all nonmulti-bucket cases, the second pass of the multibucket
    ! case where both index records go in the same (old) index bucket, and the
    ! second pass of the multi-bucket with empty bucket split case.
    !
    IF (NOT .IRAB [IRB$V_BIG_SPLIT])
	OR
	(.IRAB[IRB$L_VBN_MID] EQLA 0)
    THEN
	BEGIN

	IF .SWING_FLG
	THEN

	    ! For cases 2, 6, 10, 11, and 13 - just update the VBN in place
	    !
	    NUM_BYTES = 0;

	END

    ! For cases 1, and 5 - shift the VBNs to make room for 1 new VBN
    !
    ! Consider all multibucket cases except case 10 and 13 handled above.
    !
    ELSE

	IF NOT .SWING_FLG
	THEN

	    ! For cases 3, and 8 - shift the VBNs to make room for 2 new VBNs
	    !
	    NUM_BYTES = .NUM_BYTES * 2;

    ! For cases 4, 7, 9, and 12 - shift the VBNs to make room for 1 new VBN
    ! Cases 4, and 9 will also update one VBN in place
    !
    ! Now actually shift the VBN chain provided at least one VBN is being added
    ! and it is not being added to the end of the chain (ie the index record(s)
    ! to be added do not have key values higher than all index records currently
    ! in the bucket)
    !
    FREE_SPACE = .BKT_ADDR + (.IDX_DFN[IDX$B_IDXBKTSZ] * 512) - BKT$C_ENDOVHD;
    LENGTH = .INS_ADDR - (.BKT_ADDR + .FREE_SPACE [OFFSET]);

    IF (.LENGTH GTR 0)
	AND
	(.NUM_BYTES GTR 0)
    THEN
	RM$MOVE (.LENGTH, .BKT_ADDR + .FREE_SPACE [OFFSET],
		.BKT_ADDR + .FREE_SPACE [OFFSET] - .NUM_BYTES);

    ! Update the free space pointer.
    !
    FREE_SPACE [OFFSET] = .FREE_SPACE [OFFSET] - .NUM_BYTES

    END;


%SBTTL	'RM$V3_IDX_REC'
ROUTINE RM$V3_IDX_REC (REC_SZ) : RL$COMMON_LINK NOVALUE =
!++
!
! RM$V3_IDX_REC
!
!	This routine builds a new prologue three index record. It does 
!	one of the following
!
!		2) Change a VBN (swing pointer because of empty bucket)
!		3) Add a key and VBN
!		4) Add an additional key and VBN
!
! CALLING SEQUENCE:
!
!	RM$V3_KEY_REC (REC_SZ)
!
! INPUT PARAMETERS:
!	REC_SZ	- total size of record to be inserted
!
! IMPLICIT INPUTS:
!	IRAB
!	REC_ADDR
!	BKT_ADDR
!	IDX_DFN
!	IRAB[IRB$V_SPL_IDX]
!	IRAB[IRB$V_EMPTY_BKT]
!	IRAB[IRB$B_BIG_SPLIT]
!	IRAB[IRB$W_POS_INS]
!	IRAB[IRB$L_VBN_LEFT]
!	IRAB[IRB$L_VBN_MID]
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	REC_ADDR is updated to point past the record(s) inserted
!	REC_COUNT is incremented by the number of VBN's inserted
!
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IRAB_STR,
	R_IFAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR,
	R_BKT_ADDR_STR;

    LOCAL
	SAVE_REC_ADDR;

    MACRO
	KEY_SZ		= REC_SZ<0,16> %,
	VBN_SZ		= REC_SZ<16,16>%;

    ! Handle all empty bucket cases
    !
    IF .IRAB [IRB$V_EMPTY_BKT]
    THEN

	BEGIN

	GLOBAL REGISTER
	    R_RAB,
	    R_IMPURE;

	! We will only swing the VBN, if the VBN of the current index record
	! is the same as the VBN of the leftmost primary data bucket. This may
	! not be the case because of a previous index update failure, system
	! crash, or during certain continuation bucket splits. In such cases
	! if we swing the VBN we could be causing crossed pointers to the
	! level below.
	!
	! The only time this VBN swing is not done (besides when the
	! downpointer of the current index record is not equal to the leftmost
	! data VBN) is during the second pass of the two-pass multi-bucket
	! empty bucket split case.
	!
	IF .IRAB [IRB$L_VBN_LEFT] EQLA RM$V3_VBN()
	THEN
	    RM$ADD_V3VBN(.IRAB [IRB$L_VBN_MID]);

	! If there was a multi-bucket split involving empty buckets, RMS
	! continues the processing here.
	!
	IF .IRAB[IRB$V_BIG_SPLIT]
	THEN
	    BEGIN

	    ! Unless this is the second pass of the two-pass multi-bucket split
	    ! case insert the key that is in keybuffer 2. If this is a one-pass
	    ! split, also increment IRB$L_REC_COUNT, the counter of the number
	    ! of VBNs succeeding the position where the VBN corresponding to
	    ! the just inserted key is to be inserted.
	    !
	    IF (.IRAB[IRB$L_VBN_LEFT] NEQA 0)
	    THEN
		BEGIN
		RM$ADD_V3KEY (KEYBUF_ADDR(2));

		IF NOT .IRAB[IRB$V_SPL_IDX]
		THEN
		    IRAB[IRB$L_REC_COUNT] = .IRAB[IRB$L_REC_COUNT] + 1

		END;

	    ! Provided this is not the first pass of the two-pass multi-bucket
	    ! with empty bucket split case, RMS now updates the VBN down pointer
	    ! associated with the index record representing the high key of the 
	    ! old (left) data bucket before the data bucket split, and its high key
	    ! became the high key of the rightmost data bucket.
	    !
	    IF NOT .IRAB[IRB$V_SPL_IDX]
	    THEN
		RM$ADD_V3VBN (.IRAB[IRB$L_VBN_RIGHT])

	    END;

	RETURN

	END;

    ! Handle all split cases not involving empty buckets.
    !
    ! We will always add at least one key provided this is not the second pass
    ! of one of the three two-pass bucket split cases. If this is one of those
    ! three cases, the key we always add was added during the first pass when the
    ! old index bucket contents were updated, and should not be again added during
    ! this update of the new index bucket contents.
    !
    SAVE_REC_ADDR = .REC_ADDR;

    IF .IRAB[IRB$L_VBN_LEFT] NEQU 0
    THEN
	RM$ADD_V3KEY (KEYBUF_ADDR(2));

    ! On a multibucket split, the key which will trail the two keys added must
    ! be recompressed based on the first of the two keys added. This recompression
    ! is not done if the keys being added are being added to the end of the index
    ! bucket (no trailing key), if the multibucket split case is the two-pass case
    ! where a key is added to each of the two index buckets and this is either of
    ! the two passes, or if index compression is not enabled (of course).
    !
    IF (.IRAB[IRB$V_BIG_SPLIT]
	AND NOT .IRAB[IRB$V_SPL_IDX]
	AND .IRAB[IRB$L_VBN_LEFT] NEQU 0)
	AND
	(.IDX_DFN[IDX$V_IDX_COMPR]
	AND (.SAVE_REC_ADDR + .KEY_SZ LSSA .BKT_ADDR +
					   .BKT_ADDR[BKT$W_FREESPACE]))
    THEN 
	RM$RECOMPR_KEY (.SAVE_REC_ADDR , .SAVE_REC_ADDR + .KEY_SZ);

    ! A key and VBN must be added for all multibucket split cases. For the one-
    ! pass multibucket split case and the two-pass multibucket split case this
    ! key is the second of two keys to be added during this current pass and the 
    ! first VBN. For the latter case, both keys and the VBN get added during the 
    ! first pass and none get added during the second pass. For the two-pass
    ! multibucket split case where a key is inserted in each of the old and new
    ! index buckets, this key and its corresponding VBN are inserted as the low
    ! order key in the new index bucket during the second pass having inserted
    ! the first key in the old index bucket during the first pass.
    !
    IF .IRAB [IRB$V_BIG_SPLIT]
	AND
       ((NOT .IRAB[IRB$V_SPL_IDX] 
		AND .IRAB[IRB$L_VBN_MID] NEQU 0)
	OR
	(.IRAB[IRB$V_SPL_IDX] 
		AND .IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ))
    THEN
	BEGIN

	IF .IRAB[IRB$L_VBN_LEFT] NEQU 0
	THEN 
	    IRAB[IRB$L_REC_COUNT] = .IRAB[IRB$L_REC_COUNT] + 1;

	RM$ADD_V3VBN (.IRAB[IRB$L_VBN_MID]);

	IRAB[IRB$V_BIG_SPLIT] = 0;
	RM$ADD_V3KEY (KEYBUF_ADDR(3));
	IRAB[IRB$V_BIG_SPLIT] = 1

	END;

    ! A VBN update is always required for one-pass bucket split cases. This is
    ! because the VBN pointer of at least one of the index records on the current 
    ! level has changed because of the split at the level below it. For all 
    ! two-pass bucket split cases, this VBN updating must also take place, for the
    ! same reason. However, it always takes place during the second of the two 
    ! passes when the contents of the new index bucket are being modified since it
    ! it is the VBN pointer of one of those index records that has changed.
    !
    IF NOT .IRAB[IRB$V_SPL_IDX]
    THEN
	BEGIN

	IF (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
	    OR
	    (.IRAB[IRB$L_VBN_MID] NEQU 0)
	THEN
	    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] + 1;

	RM$ADD_V3VBN (.IRAB [IRB$L_VBN_RIGHT])

	END;

    END;

%SBTTL	'RM$V3KEY_SZ'
ROUTINE RM$V3KEY_SZ (KEY_ADDR) : RL$COMMON_LINK =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!    This routine computes the number of chars needed to store the
!    prologue three key in KEY_ADDR at REC_ADDR.
!
! CALLING SEQUENCE:
!
!	RM$V3KEY_SZ() 
!
! INPUT PARAMETERS:
!
!	KEY_ADDR - Address of the key to be inserted
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR - Pointer to the current bucket
!	IDX_DFN  - Pointer to index descriptor structure
!	IFAB	 - Pointer to internal FAB
!	IRAB	 - Pointer to Internal RAB
!	REC_ADDR - Address to insert key
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
!	R0 - number of bytes needed to store the key after front compression
!	     and rear-end truncation (doesn't include two bytes of overhead).
!
!--

    BEGIN

    MAP
	KEY_ADDR : REF BBLOCK;

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR,
	R_IFAB_STR,
	R_IRAB_STR;

    GLOBAL REGISTER
	R_IMPURE,
	R_RAB,
	R_BDB;

    LOCAL
	KEYBUF	: REF BBLOCK;

    ! Data level.
    !
    IF .BKT_ADDR [BKT$B_LEVEL] EQLU 0
    THEN
	BEGIN

	IF NOT .IDX_DFN [IDX$V_KEY_COMPR]
	THEN
	    RETURN .IDX_DFN [IDX$B_KEYSZ];
	END

    ! Index level.
    !
    ELSE
	BEGIN

	IF NOT .IDX_DFN [IDX$V_IDX_COMPR]
	THEN
	    RETURN .IDX_DFN [IDX$B_KEYSZ];
	END;

    ! Must be a compressed key. Move key into keybuffer 5, compress it, and
    ! return its size (not including the two byte of compression overhead).
    ! 
    KEYBUF = KEYBUF_ADDR(5);
    RM$MOVE (.KEY_ADDR[KEY_LEN] + 2, .KEY_ADDR, .KEYBUF);

    RM$COMPRESS_KEY (.KEYBUF);

    RETURN .KEYBUF[KEY_LEN]

    END;

%SBTTL	'RM$VBN_SIZE'
GLOBAL ROUTINE RM$VBN_SIZE (VBN) : RL$PRESERVE1 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Calculate number of bytes required to describe input VBN
!
! CALLING SEQUENCE:
!	RM$VBN_SIZE (VBN)
!
! INPUT PARAMETERS:
!	VBN - VBN whose size is to be determined
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	number of bytes needed to describe VBN
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    LOCAL
	SIZE;

    MAP
	VBN	: VECTOR [4, BYTE];

    SIZE = 3;

    DO

	IF .VBN[.SIZE] NEQ 0
	THEN
	    BEGIN
	    SIZE = .SIZE + 1;
	    RETURN .SIZE
	    END

	ELSE
	    SIZE = .SIZE - 1

    UNTIL .SIZE EQL 1;

    SIZE = .SIZE + 1
    END;

END

ELUDOM

