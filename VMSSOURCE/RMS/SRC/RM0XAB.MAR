	$BEGIN	RM0XAB,000,RM$RMS0,<XAB PROCESSING ROUTINES>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: rms32
;
; Abstract:
;		this module contains the routines to process xabs
;		for open, display, create and modify.
;
; Environment:
;		star processor running starlet exec.
;
; Author: l f laverdure	,creation date: 27-SEP-1977
;
; Modified By:
;
;	V03-040	RAS0291		Ron Schaefer		11-Apr-1984
;		Clear XAB$L_ACLSTS before the ACP operation.
;		We really ought to return an alternate status but
;		it's impossibly awkward to bubble this obscure failure
;		up the chain to turn it into an alternate success/warning.
;
;	V03-039	RAS0284		Ron Schaefer		29-Mar-1984
;		Fix error path and STV value for XABALL processing.
;
;	V03-038	DGB0029		Donald G. Blair		16-Mar-1984
;		Implement ACLs and the PROPAGATE bit -- all in the 
;		protection XAB.
;
;	V03-037	DBG0004		Donald G. Blair		23-Feb-1984
;		Implement access mode protected files.
;
;	V03-036	DAS0004		David Solomon		03-Feb-1984
;		Tie off journaling: disable processing of $XABJNL on $CREATE.
;		Fix incorrect register usage in probe of user AT journal name.
;		Fix minor bug in $XABCXR restart code.
;
;	V03-035	JWT0148		Jim Teague		16-Dec-1983
;		Make sure user can't $CREATE file with conflicting
;		RU attributes in the JNL XAB.
;
;	V03-034	JWT0141		Jim Teague		11-Nov-1983
;		Change IFB$V_RUM to IFB$V_ONLY_RU
;
;	V03-033	LMP0133		L. Mark Pilant,		3-Aug-1983  14:58
;		Get default protection from PCB instead of P1 space.  Also
;		don't supply the protection attribute unless explicitly
;		given in a PROtection XAB.
;
;	V03-032	RAS0177		Ron Schaefer		29-Jul-1983
;		Improve RMS exit performance by simplifying the
;		non-context extraction path thru RM$SETEXTRMS.
;
;	V03-031	DAS0003		David Solomon		29-Jul-1983
;		XABJNL JOP bit RUA is now called ONLY_RU; add ASSUMEs.
;
;	V03-030	KBT0546		Keith B. Thompson	22-Jun-1983
;		Stuff the XAB$W_VERLIMIT in the FHCXAB
;
;	V03-029	KPL0001		Peter Lieberwirth	17-May-1983
;		Fix XABCLSPRO so IFB isn't overwritten when a spurious
;		attempt to update the FWA was made.  The fix is to
;		avoid altogether updating the FWA on CLOSE.
;
;	V03-028	RAS0153		Ron Schaefer		 2-May-1983
;		Delete reference to $XABACEDEF missed by RAS0148.
;
;	V03-027	RAS0148		Ron Schaefer		26-Apr-1983
;		Add initial support for extended XABPRO and eliminate
;		support for XABACE.
;
;	V03-026	RAS0138		Ron Schaefer		22-Mar-1983
;		Delete global symbol/data XCONN03_ARGS.
;
;	V03-025	JWH0190		Jeffrey W. Horn		14-Mar-1983
;		Add XABACE support.
;
;	V03-024	MCN0010		Maria del C. Nasr	08-Mar-1983
;		I forgot to include $BKTDEF for MCN0009.
;
;	V03-023 MCN0009		Maria del C. Nasr	07-Mar-1983
;		Use symbolic name for maximum bucket size.
;
;	V03-022	LJA0068		Laurie J. Anderson	01-Mar-1983
;		Check new field in XABCXR, CXRBFZ (the number of bytes
;		in length of the user provided buffer CXRBUF) to make 
;		sure that it is at least XAB$C_CXRBLEN (the length which
;		is necessary for storing two keys).
;
;	V03-021	JWH0189		Jeffrey W. Horn		15-Feb-1983
;		Fill in UIC and Protection FWA fields when processing
;		the protection XAB.
;
;	V03-020	DAS0002		David Solomon		09-Feb-1983
;		Add XABTRM support.
;
;	V03-019	LJA0057		Laurie J. Anderson	 25-Jan-1983
;		Fix a couple more things
;
;	V03-018	LJA0056		Laurie J. Anderson	 24-Jan-1983
;		Fix a couple things with RMS context extraction and in LJA0048
;
;	V03-017	LJA0048		Laurie J. Anderson	 4-Jan-1983
;		- Add NRP for SEQ/REL
;		- Fix setting of LRL in IFAB.  If this is NOT a create, then
;		do NOT copy the LRL value from the FHC XAB into the IFAB.
;
;	V03-016	JWH0162		Jeffrey W. Horn		21-Dec-1982
;		Place journal names in seperate ACEs.
;
;	V03-015	MCN0008		Maria del C. Nasr	08-Dec-1982
;		- Return area id number (AID) in STV instead of XAB
;		address for AID and BKZ errors.
;		- Maximum bucket size was increased to 127.
;		- In XABCREALL1, make sure we only process area 0, and
;		not the first one since the XABs can come in any order.
;
;	V03-014	RAS0108		Ron Schaefer		15-Dec-1982
;		Change XAB$B_JOP to XAB$W_JOP and
;		fix bad branch for ISAM context restart.
;
;	V03-013	ACG0306		Andrew C. Goldstein,	13-Dec-1982  14:58
;		Remove obsolete file header symbols
;
;	V03-012	JWH0140		Jeffrey W. Horn		30-Nov-1982
;		Add return length fields for journal XAB.
;
;	V03-011 LJA0037		Laurie J. Anderson 	 4-Nov-1982
;		Add NRP processing for ISAM files.
;
;	V03-010 LJA0027		Laurie J. Anderson 	26-Oct-1982
;		Delete fields no longer in use.
;
;	V03-009	JWH0112		Jeffrey W. Horn		12-Oct-1982
;		Change journal names to be .ASCIC strings.
;
;	V03-008	LJA0023		Laurie J. Anderson	 5-Oct-1982
;		Check for Uniqueness of Context XAB's on Restart.
;		Error if duplicates.
;
;	V03-007	LJA0022		Laurie J. Anderson	28-Sep-1982
;		Use yet another register, R1, instead of R2 in xab_scan.
;
;	V03-006	KBT0343		Keith B. Thompson	23-Sep-1982
;		Use R2 instead of R6 in xab_scan (fix krm0061)
;
;	V03-005	KRM0061		Karl Malik		22-Sep-1982
;		Modify RM$XAB_SCAN to save R7. 
;
;	V03-004 LJA0012		Laurie Anderson		03-Sep-1982
;		Add Context XAB Processing for Exiting RMS Services.
;		Add Create and Open Restart processing of XABCXF.
;		Add Connect Restart processing of XABCXR.
;
;	V03-003	KBT0302		Keith B. Thompson	28-Aug-1982
;		Reorganize psects
;
;	V03-002	JWH0002		Jeffrey W. Horn		02-Jun-1982
;		Add Journal XAB processing.
;
;	V03-001	RAS0084		Ron Schaefer		 2-Apr-1982
;		Return RAT=CR for stream format files even if
;		the file attribute is none.
;
;--


	.SBTTL	DECLARATIONS

;
; Include Files:
;

;
; Macros:
;

	$ACEDEF
	$ATRDEF
	$BKTDEF
	$FABDEF
	$RABDEF
	$FCHDEF
	$FIBDEF
	$FWADEF
	$IFBDEF
	$IRBDEF
	$RMSDEF
	$XABDEF
	$XABALLDEF
	$XABCXFDEF
	$XABCXRDEF
	$XABDATDEF
	$XABFHCDEF
	$XABJNLDEF
	$XABKEYDEF
	$XABPRODEF
	$XABRDTDEF
	$XABSUMDEF
	$XABTRMDEF
	$PCBDEF

;
; Equated Symbols:
;

	FOP=FAB$L_FOP*8			; bit offset to fop field

;
; define case index values for xab dispatching
; (note: these must correspond to the offsets in the xab case dispatch)
;

	XBC$C_OPNFHC	== 0		; fhc xab handler for open
	XBC$C_OPNFHC1	== 1		; fhc xab handler for open (part 2)
	XBC$C_OPNPRO	== 2		; pro xab handler for open/display
	XBC$C_OPNDAT	== 3		; dat xab handler for open
	XBC$C_CREALL0	== 4		; all xab handler for create
					; (for seq. and rel. f.o.)
	XBC$C_EXTALL	== 5		; all xab handler for extend
	XBC$C_CREALL1	== 6		; all xab handler for create (part 2)
	XBC$C_CREPRO	== 7		; pro xab handler for create
	XBC$C_OPNRDT	== 8		; rdt xab handler for open
	XBC$C_OPNALL	== 9		; all xab handler for open
	XBC$C_CLSPRO	== 10		; pro xab handler for close
	XBC$C_CLSRDT	== 11		; rdt xab handler for close
	XBC$C_DSPFHC	== 12		; fhc xab handler for display
	XBC$C_DSPFHC1	== 13		; fhc xab handler for display (part 2)
	XBC$C_DSPALL	== 14		; all xab handler for display
	XBC$C_DSPALL1	== 15		; all xab handler for display (part 2)
	XBC$C_CREALL2	== 16		; all xab handler for create (part 3)
	XBC$C_OPNSUM3	== 17		; summary xab handler / open and display
	XBC$C_OPNALL3	== 18		; alloc xab handler / open & display
	XBC$C_OPNKEY3	== 19		; key xab handler for open and display
	XBC$C_OPNJNL	== 20		; journal xab handler for open
	XBC$C_CREJNL	== 21		; journal xab handler for create
	XBC$C_EXTCXF	== 22		; CXR Context XAB Handler for RMS Exit
	XBC$C_EXTCXR	== 23		; CXR Context XAB Handler for RMS Exit
	XBC$C_OPNCXF	== 24		; Open and create Restart Handler
	XBC$C_CONNCXR	== 25		; Connect Restart Handler
	XBC$C_XCONN03	== 26		; ISAM NRP processing routine for XABCXR
	XBC$C_GETPUTTRM	== 27		; TRM XAB handler for get/put
	XBC$C_OPNPRO1	== 28		; pro xab handler for open/disp (part 2)
	XBC$C_ENTPRO	== 29		; protecton xab handler for enter/rename
	XBC$C_CREPRO1	== 30		; pr xab handler for create (part 2)
; Watch out -- these xbc$ constants cannot be larger than 31!!

;
; Own Storage:
;
;
;  table with all valid FAB xab codes for validation
;

XABTBL:	.BYTE	XAB$C_ALL,XAB$C_DAT,XAB$C_FHC,XAB$C_KEY,XAB$C_PRO,-
		XAB$C_RDT,XAB$C_SUM,XAB$C_TRM,XAB$C_JNL,XAB$C_CXF
XABTBLLEN=.-XABTBL

;
;  Table with all valid RAB xab codes for validation
;

RXABTBL:
	.BYTE	XAB$C_CXR, XAB$C_TRM
RXABTBLEN=.-RXABTBL


	.SBTTL	RM$OPEN_XAB - PROCESS XABS FOR $OPEN

;++
;
; RM$OPEN_XAB:	Process XABs for $OPEN, first part
; RM$OPEN_XAB1:	Process XABs for $OPEN, second part
;
;  these subroutines process the xabs for open.  they are handled in
;  two parts, the first executing before doing the access qio,
;  the other after.
;
;  this section of the module also includes the common xab chain
;  following and dispatch code.
;
; Calling sequence:
;
;	bsbw	rm$open_xab		; first part
;	bsbw	rm$open_xab1		; second part
;
; Input Parameters:  (For RM$XAB_SCAN, also) 
;
;	r11	impure area address
;	r10	file work page address or ifab (if r9 is irab)
;	r9	ifab address or irab address (if rab xab)
;	r8	fab address or rab address (if rab xab)
;	r7	nwa address (if any)
;		Or
;		If called from EXTRMS, and there is not an IFB/IRB structure
;		available, then (r7) has the user calling mode.
;	r6	fib address (if any)
;	r5	next attribute address (if applicable)
;
; Implicit Inputs:
;
;	fab$l_xab and the xabs within the chain thus defined
;
; Output Parameters:
;
;	attribute list entries are added such that the requested file
;	attributes are filled in.
;	r5	updated to point to the next available attribute address.
;		For call to scan for XABTRM, R5 points to XABTRM.
;	r4	zero if no xabs processed, otherwise non-zero
;		(in general, bit corresponding to case handler index
;		is set for each handler called)
;	r1-r3,ap	destroyed
;	r0	status code
;
; Implicit Outputs:
;
;	the various fields of the xabs are filled in.
;
; Completion Codes:
;
;	standard rms, in particular suc, xab, cod, imx and various others.
;
; Side Effects:
;
;	none
;
;--



;
; the following table provides the dispatching information for those xabs
; that are input to $open and require an entry in the files attribute list.
; the entries consist of the xab code, its length, and its case index.
;

OPNXAB_ARGS:
	.BYTE	XAB$C_FHC,XAB$C_FHCLEN,XBC$C_OPNFHC
	.BYTE	XAB$C_PRO,XAB$C_PROLEN_V3,XBC$C_OPNPRO
	.BYTE	XAB$C_DAT,XAB$C_DATLEN_V2,XBC$C_OPNDAT
	.BYTE	XAB$C_RDT,XAB$C_RDTLEN,XBC$C_OPNRDT
	.BYTE	0			; end of table flag

;
; the following table specifies those xabs to open that require processing
; after the access qio has been performed.
;

OPNXAB1_ARGS:
	.BYTE	XAB$C_FHC,XAB$C_FHCLEN,XBC$C_OPNFHC1
	.BYTE	XAB$C_ALL,XAB$C_ALLLEN,XBC$C_OPNALL
	.BYTE	XAB$C_JNL,XAB$C_JNLLEN,XBC$C_OPNJNL
	.BYTE	XAB$C_PRO,XAB$C_PROLEN_V3,XBC$C_OPNPRO1
	.BYTE	0

;
; entry point for processing open xabs (part 2)
;

RM$OPEN_XAB1::
	MOVAB	OPNXAB1_ARGS,AP		; set arg list addr
	BRB	XAB_SCAN		; and go process

;
; entry point for processing open xabs (part 1)
;

RM$OPEN_XAB::
	MOVAB	OPNXAB_ARGS,AP		; set arg list addr

;
; and fall thru to xab_scan
;


	.SBTTL	XAB_SCAN - COMMON XAB DISPATCH ROUTINE

;++
; RM$XAB_SCAN:	Scan XAB chain for processing
;
; this routine scans the xab chain for a match on any of those xabs
; specified in the argument list.  if an xab is found it is probed
; and dispatch is made to the routine indicated by the argument list
; case index.
;--

RM$XAB_SCAN::
XAB_SCAN:
	CLRL	R4			; clear uniqueness vector

	ASSUME	FAB$B_BID	EQ	RAB$B_BID

	CMPB	FAB$B_BID(R8),#FAB$C_BID ; Is the user structure a FAB or RAB?
	BNEQ	5$			; Not a FAB, Must be a RAB
	MOVL	FAB$L_XAB(R8),R3	; get 1st xab address from FAB
	BRB	CHKXAB			; Continue - check if XAB present
5$:	MOVL	RAB$L_XAB(R8),R3	; get 1st XAB address from RAB
CHKXAB:	BNEQ	6$			; (another) XAB present
	BRW	SUCXIT			; All done if none.
6$:	TSTL	R9			; If called from EXTRMS, then could..
	BEQL	7$			; ..not have an IFB/IRB structure.

	ASSUME	IFB$B_MODE	EQ	IRB$B_MODE

	MOVZBL	IFB$B_MODE(R9),R1	; get mode in R1 for probe
	BRB	8$			; Continue - probe structure

7$:	MOVL	R7,R1			; Move the user calling mode to R1
8$:	PROBER	R1,#XAB$L_NXT+4,(R3)	; probe readability
	BNEQ	9$
	BRW	ERRXAB			; error if no access.
9$:	MOVL	AP,R2			; get address of scan table
10$:	CMPB	(R2)+,XAB$B_COD(R3)	; xab code match this entry?
	BEQL	GOTXAB			; branch if yes
	ADDL2	#2,R2			; next table entry
	TSTB	(R2)			; end of table?
	BNEQ	10$			; branch if not

;
; found no match in the table.
; check against all xab codes for at least valid and if so ignore it.
;

	ASSUME	FAB$B_BID	EQ	RAB$B_BID

	CMPB	FAB$B_BID(R8),#FAB$C_BID ; Is the user structure a FAB or RAB?
	BNEQ	15$			; Not a FAB, Must be a RAB
	LOCC	XAB$B_COD(R3),#XABTBLLEN,XABTBL ; known FAB XAB code?
	BRB	20$			; Continue 
15$:	LOCC	XAB$B_COD(R3),#RXABTBLEN,RXABTBL ; known RAB XAB code?
20$:	BEQL	ERRCOD			; branch if not
NXTXAB:	MOVL	XAB$L_NXT(R3),R3	; get next xab in chain
	BRB	CHKXAB			; go process

;
; found a match in the xab table.
; check the length, probe it, and dispatch to the handler.
;

GOTXAB:	MOVZBL	XAB$B_BLN(R3),R0	; get xab length field
	CMPB	R0,(R2)+		; is length < min.?
	BLSSU	ERRXAB			; branch if yes
	TSTL	R9			; If called from EXTRMS, then could..
	BEQL	30$			; ..not have an IFB/IRB structure.

	ASSUME	IFB$B_MODE	EQ	IRB$B_MODE

	MOVZBL	IFB$B_MODE(R9),R1	; get mode in R1 for probe
	BRB	35$			; Continue - probe structure

30$:	MOVL	R7,R1			; Move the user calling mode to R1
35$:	PROBEW	R1,R0,(R3)		; probe writeability
	BEQL	ERRXAB			; branch if no access
	PUSHAB	NXTXAB			; push return pc
	CASE	TYPE=B,SRC=(R2),-	; and go process
	DISPLIST=<XABOPNFHC,XABOPNFHC1,XABOPNPRO,XABOPNDAT,-
		XABCREALL0,RM$EXTEND_XAB,XABCREALL1,XABCREPRO,-
		XABOPNRDT,XABOPNALL,XABCLSPRO,XABCLSRDT,-
		XABDSPFHC,XABDSPFHC1,XABDSPALL,XABDSPALL1,-
		XABCREALL2,RM$ISUMO3,RM$IALLO3,RM$IKEYO3,-
		XABOPNJNL,XABCREJNL,XABEXTCXF,XABEXTCXR,-
		XABOPNCXF,XABCONNCXR,XCONN03,XABTRM,XABOPNPRO1,-
		XABENTPRO,XABCREPRO1>

;
; (note: should never fall thru)
;
; dispatch with standard r8 thru r11 and
;	r6 = fib address
;	r5 = addr to build next attribute list entry
;	r4 = xab uniqueness bit vector
;	r3 = xab address
;
; must return with r4 and r5 updated as necessary and only r0 thru r2
; modified.  note: ap must not be modified.
;
; error routine should clean return pc from stack and rsb with error code in r0.
;

SUCXIT:	RMSSUC
	RSB

;
; Conflicting XABJNL RU attributes
;

ERR_CONFRU:
	RMSERR 	XCR			; no arguments
	BRB	CLNSTK

;
; handle errors.  problem could be:
;
;	- non-accessible xab
;	- invalid xab length
;

ERRXAB:
	RMSERR	XAB			; declare error
SETSTV:	MOVL	R3,FAB$L_STV(R8)	; give address
	RSB

;
; handle invalid xab code error
;

ERRCOD:
	RMSERR	COD
	BRB	SETSTV

;
; handle invalid duplicate xab error
;

ERRIMX:
RM$ERRIMX::
	RMSERR	IMX
CLNSTK:	TSTL	(SP)+			; remove return pc from stack
	BRB	SETSTV



	.SBTTL	FHC XAB PROCESSING ROUTINES

;++
;
; XABDSPFHC:	Process file header XAB for $DISPLAY, part 1
; XABOPNFHC:	Process file header XAB for $OPEN and $CREATE, part 1
; XABDSPFHC1:	Process file header XAB for $DISPLAY. part 2
; XABOPNFHC1:	Process file header XAB for $OPEN and $CREATE, part 2
;
;  xab routine to process the file header characteristics xab for $open,
;  $create, and $display
;
;  called in two parts.  the first part merely builds an attribute list
;  entry to read the record attributes into the user's xab.
;
;  the second part fills in the sbn and swaps the ebk and hbk fields.
;
;--

;++
;
; entry point for $display processing. (must read in statistics block)
;
;--

XABDSPFHC:
	MOVW	#4,(R5)+		; read only sbn longword
	MOVW	#ATR$C_STATBLK,(R5)+	;   of statistics block
	MOVAL	XAB$L_SBN(R3),(R5)+	; read directly into xab

;++
;
; entry point for $open and $create processing. (read in record attributes)
;
;--

XABOPNFHC:
	CMPB	#IFB$C_IDX,IFB$B_ORGCASE(R9) ; if this is not an indexed file
	BNEQ	5$			;    process xab
	TSTB	XAB$B_AID(R3)		; if not 1st area xab
	BNEQ	10$			;    skip processing
5$:	BBSS	#XBC$C_OPNFHC,R4,ERRIMX	; flag xab seen, error

;
; if already one
;

	MOVW	#32,(R5)+		; return all 32 bytes
	MOVW	#ATR$C_RECATTR,(R5)+	; read record attributes
	MOVAL	XAB$B_RFO(R3),(R5)+	; address to read attr.s
	CMPB	FAB$B_RFM(R8),#FAB$C_FIX ; fixed rec. format?
	BEQL	10$			; branch if yes
	BBC	#IFB$V_CREATE,(R9),10$	; skip copy of LRL if not create
	MOVW	XAB$W_LRL(R3),IFB$W_LRL(R9); copy longest rec. len.

;
; in case this is $create
;

10$:	RSB

;++
;
;  part 2 (called after the access qio)
;
;--

;++
;
; entry point for $open
;
;--

XABOPNFHC1:
	MOVL	FWA$L_SBN(R10),XAB$L_SBN(R3)	; set starting lbn
	MOVW	FIB$W_VERLIMIT(R6),-		; and version limit
		XAB$W_VERLIMIT(R3)

;++
;
; entry point for $display
;
;--

XABDSPFHC1:
	ROTL	#16,XAB$L_SBN(R3),XAB$L_SBN(R3) ; swap halves of start lbn
	ROTL	#16,XAB$L_EBK(R3),XAB$L_EBK(R3) ; swap halves of ebk
	BNEQ	10$			; branch if non-zero

	ASSUME	FAB$C_SEQ	EQ	0

	TSTB	IFB$B_ORGCASE(R9)	; sequential file org?
	BEQL	10$			; branch if yes
	ADDL3	#1,IFB$L_HBK(R9),XAB$L_EBK(R3) ; set ebk from hbk + 1
10$:	MOVL	IFB$L_HBK(R9),XAB$L_HBK(R3) ; set hbk from ifab

;
; force stream format files to appear to have RAT non-null,
; even if they don't.
;

	ASSUME	FAB$C_STM	LT	FAB$C_STMLF
	ASSUME	FAB$C_STM	LT	FAB$C_STMCR
	ASSUME	FAB$V_ORG	EQ	4
	ASSUME	FAB$S_ORG	EQ	4

	EXTZV	#0,#4,XAB$B_RFO(R3),R0	; extract record format
	CMPB	R0,#FAB$C_STM		; stream format?
	BLSSU	30$			; nope
	BITB	#<FAB$M_CR!FAB$M_FTN!FAB$M_PRN>,-
		XAB$B_ATR(R3)		; carriage control already set?
	BNEQ	30$			; ok
	BISB2	#FAB$M_CR,XAB$B_ATR(R3)	; force RAT=CR
30$:	RSB

	.SBTTL	DAT XAB ROUTINE

;++
;XABOPNDAT:  Process the date and time xab for $open, $create, & $display.
;
; in all three cases attribute list entries are made for creation date & time,
; expiration date & time, revision date & time, and revision count.
;
; !!! \note: this routine should be modified when a single attribute can
;	      handle all four.\ !!!
;
;--

XABOPNDAT:
	BBSS	#XBC$C_OPNDAT,R4,ERRIMX	; flag xab seen, error

;
; if already one
;
; make attrbute list entries for creation & expiration date & time
;

	MOVW	#8,(R5)+		; date length
	MOVW	#ATR$C_CREDATE,(R5)+	; xfer creation date

	BISL3	XAB$L_CDT0(R3),XAB$L_CDT4(R3),R0 ; is date 0?
	BNEQU	10$			; no - use date
	$GETTIM_S	TIMADR=XAB$Q_CDT(R3) ; yes - use current date
10$:	MOVAL	XAB$Q_CDT(R3),(R5)+	; xfer address

;
; don't default expiration date
;

	MOVW	#8,(R5)+		; date length
	MOVW	#ATR$C_EXPDATE,(R5)+	; xfer expiration date
	MOVAL	XAB$Q_EDT(R3),(R5)+	; xfer address

;
; Only process the backup date and time if the length of the XAB block
; includes it.  Do not default it.
;

	CMPB	XAB$B_BLN(R3),#XAB$C_DATLEN ; does it include backup date?
	BLSSU	20$			; branch, if it does not
	MOVW	#8,(R5)+		; date length
	MOVW	#ATR$C_BAKDATE,(R5)+	; transfer backup date attribute code
	MOVAL	XAB$Q_BDT(R3),(R5)+	; transfer address
20$:	BRB	REV_DATE_COUNT		; make attr entries for revision
					; date & count and return


	.SBTTL	RDT XAB ROUTINES

;++
; XABOPNRDT: process the revision date and time xab for $open, $create, & $display.
; XABCLSRDT: process the revision date and time xab for $close
;
;  in all three cases attribute list entries are made for revision date & time
;  and revision count.
;
;  !!! \note: this routine should be modified when a single attribute can
;	      handle both.\ !!!
;
;--

XABOPNRDT:
	BBCS	#XBC$C_OPNRDT,R4,10$	; flag xab seen,
	BRW	ERRIMX_BR1		; error if already set
10$:
REV_DATE_COUNT:
	MOVW	#8,(R5)+		; date length
	MOVW	#ATR$C_REVDATE,(R5)+	; xfer revision date

	BISL3	XAB$L_RDT0(R3),XAB$L_RDT4(R3),R0 ; is date 0 ?
	BNEQU	30$			; no - use it
	$GETTIM_S	TIMADR=XAB$Q_RDT(R3) ; yes - get current date
30$:	MOVAL	XAB$Q_RDT(R3),(R5)+	; xfer address

	MOVW	#2,(R5)+		; revision count length
	MOVW	#ATR$C_ASCDATES,(R5)+	; revision count attribute code
	MOVAW	XAB$W_RVN(R3),(R5)+	; address to xfer rvn
	RSB

;++
; routine to process rdt xab for $close.
;
; same processing as for $open rdt except that attribute list entries are
; built on the stack.
;
;--

XABCLSRDT:
	BBCS	#XBC$C_CLSRDT,R4,10$	; branch xab not seen
	BRW	ERRIMX			 ; flag xab seen , error

;
; if already one
;

10$:	SUBL2	#8,SP			; create 8 bytes on stack
	MOVL	SP,R5			; build attr. list entries here
	MOVQ	8(SP),-(SP)		; return addrs to bottom of stk
	BRB	REV_DATE_COUNT		; build attr list entries

	.SBTTL	PRO XAB ROUTINES

;++
; XABOPNPRO: Process the protection xab for $open and $display.  Make
; entries in the attribute list to have the ACP fill in the xab fields
; directly.
;
;--

XABOPNPRO:
	BBCS	#XBC$C_OPNPRO,R4,5$	; br if no xab seen (okay)
	BRW	ERRIMX			; else flag duplicate xabpro

5$:	BSBB	UIC			; make uic attr. list entry
	BSBB	MTACC			; make ansi accessibility entry
	BSBB	PRO			; make file protection entry
	CMPB	XAB$B_BLN(R3),#XAB$K_PROLEN ; Extended length XABPRO? (New V4)
	BLSSU	10$			; skip if not
	BSBB	PROT_MODE		; make access mode protection entry
	MOVL	#<ATR$C_ACLLENGTH@16>+2,(R5)+ ; attribute to return acl length
	MOVAL	XAB$W_ACLLEN(R3),(R5)+	; xfer directly to xab
	TSTL	XAB$L_ACLBUF(R3)	; did user specify an acl buffer?
	BEQLU	10$			; branch if not
	MOVW	XAB$W_ACLSIZ(R3),(R5)+	; size of acl buffer
	MOVW	#ATR$C_READACL,(R5)+	; attribute to place acl in user buffer
	MOVL	XAB$L_ACLBUF(R3),(R5)+	; addr of acl buffer
	MOVL	XAB$L_ACLCTX(R3),-	; pass acl context to file system
		FIB$L_ACLCTX(R6)
	CLRL	XAB$L_ACLSTS(R3)	; clear acl status
10$:	RSB


;++
; XABOPNPRO1: This routine contains protection xab processing which must 
; follow the call to the acp for $open/$display operations. 
;
;--

XABOPNPRO1:
	CMPB	XAB$B_BLN(R3),-		; extended-length xabpro?
		#XAB$K_PROLEN
	BLSSU	10$			; branch if not.
	MOVL	FIB$L_ACLCTX(R6),-	; place acl context in xab
		XAB$L_ACLCTX(R3)
	MOVL	FIB$L_ACL_STATUS(R6),-	; return status for acl operation
		XAB$L_ACLSTS(R3)
10$:	RSB




;
; Miscellaneous subroutines used by protection xab routines.
;

;
; put protection attribute code into attribute list
;
PRO:	MOVL	#<ATR$C_FPRO@16>+2,(R5)+; display SOWG protection - 2-byte field
	MOVAL	XAB$W_PRO(R3),(R5)+	; xfer directly to xab
	RSB

;
; put uic attribute code into attribute list
;
UIC:	MOVL	#<ATR$C_UIC@16>+4,(R5)+ ; display uic in longword field
	MOVAL	XAB$L_UIC(R3),(R5)+	; xfer directly to xab
	RSB

;
; put ansi accessibility attribute code into attribute list
;
MTACC:	MOVL	#<ATR$C_HDR1_ACC@16>+1,(R5)+ ; display ansi accessibility byte
	MOVAL	XAB$B_MTACC(R3),(R5)+	; xfer directly to xab
	RSB

;
; put access mode protection attribute code into attribute list
;
PROT_MODE: 
	MOVL	#<ATR$C_ACLEVEL@16>+1,(R5)+ ; display access mode prot. byte
	MOVAL	XAB$B_PROT_MODE(R3),(R5)+   ; xfer directly to xab
	RSB

;++
; XABCREPRO: Process the protection xab for $create
;
; If nonzero uic, then enter attribute to write the uic.  If uic=0
; and the fab$v_cif bit is set,
; make the attribute atr$c_uic_ro which means although this is a 
; WRITE ATTRIBUTES subfunction, but won't you please READ ATTRIBUTES
; the uic if this turns out to be an open of an existing file so that the
; uic isn't altered.
;
; Enter attribute to write the protection field unless the default -1 
; is set.  Note that since -1 (^XFFFF) indicates "No access", you cannot
; $CREATE a file for no access using RMS.
;
;--

XABCREPRO:
	BBSS	#XBC$C_CREPRO,R4,ERRIMX_BR1 ; flag xab seen, error

;
; handle uic
;

	MOVL	XAB$L_UIC(R3),FWA$L_UIC(R10) ; copy uic to FWA
	BNEQ	20$			; branch if not zero

;
; zero uic
;

	BBC	#FAB$V_CIF+FOP,(R8),40$	; branch unless cif set
	BSBB	UIC			; specify uic read
	MOVW	#ATR$C_UIC_RO,-6(R5)	; make sure uic not written
	BRB	40$

20$:	BSBB	UIC			; use non-zero uic

;
; handle ansii accessibility
;

40$:	TSTB	XAB$B_MTACC(R3)		; any specified?
	BEQL	50$			; branch if yes
	BSBB	MTACC

;
; handle protection
;

50$:	MOVW	XAB$W_PRO(R3),FWA$W_PRO(R10) ; put prot into FWA
	ADDW3	#1,FWA$W_PRO(R10),R0	; is protection = -1? (i.e. default)
	BEQL	60$			; branch if so
	BSBB	PRO			; include attribute to write protection
60$:	CMPB	XAB$B_BLN(R3),#XAB$K_PROLEN ; extended length XABPRO? (New V4)
	BLSSU	70$			; skip if not
	BSBB	PROT_MODE		; attribute for access mode protection
	TSTL	XAB$L_ACLBUF(R3)	; did user specify an acl buffer?
	BEQLU	70$			; branch if not
	MOVW	XAB$W_ACLSIZ(R3),(R5)+	; siz of acl buffer
	MOVW	#ATR$C_ADDACLENT,(R5)+	; attribute to create acl
	MOVL	XAB$L_ACLBUF(R3),(R5)+	; address of user's acl buffer
	CLRL	XAB$L_ACLSTS(R3)	; clear acl status
70$:	RSB

;
; extended branch for error
;

ERRIMX_BR1:
	BRW	ERRIMX

;++
; XABCREPRO1: Process the protection xab for $create, part 2.
;
; If extended xabpro then return acl status.
;--

XABCREPRO1:
	CMPB	XAB$B_BLN(R3),-		; extended-length xabpro?
		#XAB$K_PROLEN
	BLSSU	10$			; branch if not
	MOVL	FIB$L_ACL_STATUS(R6),-	; return status for acl operation
		XAB$L_ACLSTS(R3)
10$:	RSB



;++
; XABCLSPRO:	Process the pro xab for $close
;
; checks for default uic (i.e., 0) and if found then don't process uic
;
; also check for default pro (i.e., -1  -  no access to anyone), and if found
; don't touch the protection
;
;--

XABCLSPRO:
	BBSS	#XBC$C_CLSPRO,R4,ERRIMX_BR1 ; flag xab seen, error

;
; if already one
;
; handle uic
;

	TSTL	XAB$L_UIC(R3)		; uic = 0?
	BEQL	10$			; branch if yes
	MOVL	SP,R5			; point to attr. list entry on stack
	MOVQ	(SP),-(SP)		; create 8 bytes on stack

;
; for uic attribute entry
;

	BSBW	UIC			; specify uic write
10$:

;
; process pro
;

	ADDW3	#1,XAB$W_PRO(R3),R0	; is pro spec = -1?
	BEQL	20$			; branch if so
	MOVL	SP,R5			; point to attr. list entry on stack
	MOVQ	(SP),-(SP)		; create 8 free bytes on stack
	BRW	PRO			; go process protection
20$:	RSB


;++
; XABENTPRO: process the protection xab for the directory "enter" which
; occurs during an $enter or a $rename operation.  Currently, the only
; thing to do is to pass the xab$v_propagate bit on to the file system.
;
;__

XABENTPRO:
	BBSS	#XBC$C_ENTPRO,R4,ERRIMX_BR1	; only allow 1 xabpro
	ASSUME	XAB$V_PROPAGATE EQ 0
	BLBC	XAB$B_PROT_OPT(R3),20$		; skip if propagate not set
	SSB	#FIB$V_PROPAGATE,-		; set propagate bit in fib
		FIB$L_STATUS+FWA$T_FIBBUF(R10)
20$:	RSB

	.SBTTL	ALL XAB ROUTINES

;++
; XABDSPALL:	Process allocation xab for $display, part 1
; XABOPNALL:	Process allocation xab for $open
; XABDSPALL:	Process allocation xab for $display, part 2
;
; sets the alq, deq, bkz, and aop (ctg and cbt bits only) fields of the xab
;
;--

;++
;
; entry point for $display to cause the user characteristics bits to
; be read into the xab.
;
;--

XABDSPALL:
	CMPB	#IFB$C_IDX,IFB$B_ORGCASE(R9) ; indexed file?
	BNEQ	10$			; branch if not
	TSTB	XAB$B_AID(R3)		; is this the first area id?
	BNEQ	20$			; branch if not
10$:	BBSS	#XBC$C_DSPALL,R4,ERRIMX_BR1 ; error is xab already seen
	MOVW	#1,(R5)+		; just read 1st byte
	MOVW	#ATR$C_UCHAR,(R5)+	; user char. attr. code
	MOVAB	XAB$B_AOP(R3),(R5)+	; addr for read
20$:	RSB

;++
;
; entry point for $open processing
;
;--

XABOPNALL:
	MOVB	FWA$W_UCHAR(R10),XAB$B_AOP(R3) ; set aop byte from user char.

;++
;
; entry point for 2nd part of $display processing
;
;--

XABDSPALL1:

	ASSUME	FCH$V_CONTIG	EQ	XAB$V_CTG
	ASSUME	FCH$V_CONTIGB	EQ	XAB$V_CBT

	BICB2	#255 \ <XAB$M_CTG!XAB$M_CBT>,XAB$B_AOP(R3) ; clear other bits
	CMPB	#IFB$C_IDX,IFB$B_ORGCASE(R9) ; indexed file?
	BEQL	IDXRET			; branch if indexed
	MOVW	IFB$W_DEQ(R9),XAB$W_DEQ(R3); set deq
	MOVB	IFB$B_BKS(R9),XAB$B_BKZ(R3); set bkz
SETALQ:	MOVL	IFB$L_HBK(R9),XAB$L_ALQ(R3); set alq
IDXRET:	RSB



;++
; XABCREALL1:	Process allocation xab for $create, part 1
; XABCREALL2:	Process allocation xab for $create, part 2
;
; Process allocation XAB for area 0 only, since called by RM$CREATECOM
; when file created.  Uses the allocation xab parameters to set up the FIB,
; whose address must be in r6.
;
;--

XABCREALL1:
	BBSS	#XBC$C_CREALL1,R4,10$	; set alloc XAB found
10$:	TSTB	XAB$B_AID(R3)		; area 0?
	BNEQ	50$			; branch if not (do not process)
	PUSHL	R6			; save fib address
	MOVL	R6,R1			; copy it to r1
	MOVL	R3,R6			; xab address to r6
	BSBW	RM$SET_XABALL		; set up fib from xab
	MOVL	(SP)+,R6		; restore fib addr
	BLBC	R0,60$			; branch if bad values
	BBC	#FIB$V_ALCONB,FIB$W_EXCTL(R6),20$ ; branch if not cbt
	BBCS	#FCH$V_CONTIGB,FWA$W_UCHAR(R10),50$ ; set cbt file attr. & branch
20$:	BBC	#FIB$V_ALCON,FIB$W_EXCTL(R6),50$ ; branch if not ctg
	BISB2	#1@FCH$V_CONTIG,FWA$W_UCHAR(R10) ; set ctg file attribute
50$:	RSB

;

60$:	BRW	STVRSB			; load stv with AID number and return

;++
;
; xabcreall2 routine to process filling in of alq field with actual
; first extent size on $create.
;
;--

XABCREALL2:
	CMPB	#IFB$C_IDX,IFB$B_ORGCASE(R9) ; indexed file?
	BNEQ	5$			; branch if not
	TSTB	XAB$B_AID(R3)		; first one?
	BEQL	5$			; branch if so
	RSB				; return
5$:	BRB	SETALQ

	.SBTTL	RM$SETALLOC - ROUTINE TO HANDLE ALLOC XAB FOR SEQ. & REL. F.O.

;++
; RM$SETALLOC:	Process the allocation xab for the sequential and relative
;		file organizations.
;
; XABCREALL0:	routine called by xab_scan if an allocation xab is found
;
; if an allocation xab is found, it is checked for defining area 0 only and
; it is used to provide the alq, deq, and bks fields, these being copied to
; the fab for later processing.  placement information is processed when the
; file creation is actually done.
;
; the entire xab chain is checked for validity.
;
;--

CREXAB0_ARGS:
	.BYTE	XAB$C_ALL,XAB$C_ALLLEN,XBC$C_CREALL0,0

RM$SETALLOC::
	MOVAB	CREXAB0_ARGS,AP		; set arg list addr
	BSBW	XAB_SCAN		; go scan xab chain

;
; use fab deq field to set both deq and run-time deq fields of ifab
;

	MOVW	FAB$W_DEQ(R8),IFB$W_DEQ(R9)
	MOVW	FAB$W_DEQ(R8),IFB$W_RTDEQ(R9)
	RSB

;++
; xabcreall0 routine called by xab_scan if an allocation xab is found
;
; verify this is the only allocation xab and that its aid = 0.
; copy the alq, deq, and bkz fields from the xab to the fab.
;
;--

XABCREALL0:
	CMPB	#IFB$C_IDX,IFB$B_ORGCASE(R9); indexed file?
	BNEQ	5$			; branch if not
	TSTB	XAB$B_AID(R3)		; is this the first area id?
	BNEQ	10$			; branch if not
5$:	BBSS	#XBC$C_CREALL0,R4,ERRIMX_BR ; error is all. xab already seen
	TSTB	XAB$B_AID(R3)		; aid = 0?
	BNEQ	ERRAID			; branch if not (error)
	MOVL	XAB$L_ALQ(R3),FAB$L_ALQ(R8) ; copy alq to fab
	MOVW	XAB$W_DEQ(R3),FAB$W_DEQ(R8) ; and deq
	CMPB	XAB$B_BKZ(R3),-
		 #BKT$C_MAXBKTSIZ	; bkz in range?
	BGTRU	ERRBKZ			; branch if not
	MOVB	XAB$B_BKZ(R3),FAB$B_BKS(R8) ; and bks

	ASSUME	FAB$C_SEQ	EQ	0

	TSTB	IFB$B_ORGCASE(R9)	; sequential file org?
	BEQL	10$			; branch if yes
	MOVB	XAB$B_BKZ(R3),IFB$B_BKS(R9) ; set ifab bks from xab bkz
10$:	RSB				; continue xab scan for validity

;

ERRIMX_BR:
	BRW	ERRIMX			; extended branch to handle error

;
; handle invalid aid field error (not = 0)
;

ERRAID:
RM$ERRAID::
	RMSERR	AID
	BRB	STVRSB			; load stv with AID number and return

;
; handle invalid bkz field error
;

ERRBKZ:
	RMSERR	BKZ
STVRSB: TSTL	(SP)+			; remove return PC from stack
	MOVZBL	XAB$B_AID(R3),FAB$L_STV(R8) ; set AID number in STV
	RSB				; return



	.SBTTL	JNL XAB ROUTINES
;++
; XABCREJNL rouine called if a journal XAB is found for a $CREATE
;
; Attribute list entry is made to set journaling attributes.  FWA is filled
; in with journal names.  IFB is filled in with journaling attributes.
;
;--

XABCREJNL:
	BBSS	#XBC$C_CREJNL,R4,ERRIMX_BR		; flag XAB seen, error

;**JNL** begin temporary code to tie off journaling (NOP to restore support)
	RMSERR	ENV			;**JNL** return error if XAB seen
	BRW	CLNSTK			;**JNL** and exit
;**JNL** end temporary code to tie off journaling

;
;	Set up journal flags attribute, copy to IFB
;

	ASSUME	XAB$V_ONLY_RU	EQ	IFB$V_ONLY_RU
	ASSUME	XAB$V_RU	EQ	IFB$V_RU
	ASSUME	XAB$V_BI	EQ	IFB$V_BI
	ASSUME	XAB$V_AI	EQ	IFB$V_AI
	ASSUME	XAB$V_AT	EQ	IFB$V_AT
	ASSUME	XAB$V_NEVER_RU	EQ	IFB$V_NEVER_RU

	MOVB	XAB$W_JOP(R3),IFB$B_JNLFLG(R9)		; copy journaing bits
	BNEQ	5$					; continue if any
	BRW	40$					; branch otherwise

;
;	Make sure that the RU attributes don't conflict
;
5$:
	BBS	#XAB$V_ONLY_RU,XAB$W_JOP(R3),6$		; Make sure that 1
	BBS	#XAB$V_NEVER_RU,XAB$W_JOP(R3),7$	;  and only 1 of
	BRB	9$					;  the RU bits are set
6$:	BBS	#XAB$V_NEVER_RU,XAB$W_JOP(R3),8$
7$:	BBS	#XAB$V_RU,XAB$W_JOP(R3),8$
	BRB	9$					

8$:	BRW	ERR_CONFRU				; More than 1 set

9$:
	MOVW	#1,(R5)+				; set one byte attr
	MOVW	#ATR$C_JOURNAL,(R5)+			; set journaling attr
	MOVAB	IFB$B_JNLFLG(R9),(R5)+			; set attr address

;
;	Copy appropritate journal names to FWA
;

	PUSHR	#^M<R2,R3,R4,R5,R6>			; save registers
	BBC	#IFB$V_BI,IFB$B_JNLFLG(R9),10$		; branch if no BI
	MOVZBL	XAB$B_BIS(R3),R6			; get lenth
	BEQL	10$					; branch if zero
	PROBER	IFB$B_MODE(R9),R6,@XAB$L_BIA(R3)	; probe buff
	BEQL	ERRXAB_BRJ				; branch if cant read
	MOVC5	R6,@XAB$L_BIA(R3),#^A/ /,-
		#FWA$S_BIJNLN,FWA$T_BIJNLN(R10)		; copy name
	SUBL3	R0,R6,FWA$Q_BIJNL(R10)			; store length
	MOVL	4(SP),R3				; Restore XAB addr

10$:	BBC	#IFB$V_AI,IFB$B_JNLFLG(R9),20$		; branch if no AI
	MOVZBL	XAB$B_AIS(R3),R6			; get length
	BEQL	20$					; branch if zero
	PROBER	IFB$B_MODE(R9),R6,@XAB$L_AIA(R3)	; probe buff
	BEQL	ERRXAB_BRJ				; branch if cant read
	MOVC5	R6,@XAB$L_AIA(R3),#^A/ /,-
		#FWA$S_AIJNLN,FWA$T_AIJNLN(R10)		; copy name
	SUBL3	R0,R6,FWA$Q_AIJNL(R10)			; store length
	MOVL	4(SP),R3				; Restore XAB addr

20$:	BBC	#IFB$V_AT,IFB$B_JNLFLG(R9),30$		; branch if no AT
	MOVZBL	XAB$B_ATS(R3),R6			; get length
	BEQL	30$					; branch if zero
	PROBER	IFB$B_MODE(R9),R6,@XAB$L_ATA(R3)	; probe buff
	BEQL	ERRXAB_BRJ				; branch if cant read
	MOVC5	R6,@XAB$L_ATA(R3),#^A/ /,-
		#FWA$S_ATJNLN,FWA$T_ATJNLN(R10)		; copy name
	SUBL3	R0,R6,FWA$Q_ATJNL(R10)			; store length
	
30$:	POPR	#^M<R2,R3,R4,R5,R6>			; restore registers

40$:	RSB


ERRXAB_BRJ:
	POPR	#^M<R2,R3,R4,R5,R6>			; restore registers
	RMSERR	XAB					; indicate XAB error
	BRW	CLNSTK

ERRIMX_BRJ:
	BRW	ERRIMX					; extended branch

;++
; XABOPNJNL routine called if journal XAB is found on $OPEN or $DISPLAY,
; called after file is accessed.
;
; XAB filled in from IFB and FWA
;
;--

XABOPNJNL:

;
;	Copy journaling bits
;

	BBSS	#XBC$C_OPNJNL,R4,ERRIMX_BRJ	; flag XAB seen, error
	BICB3	#^C<XAB$M_ONLY_RU!XAB$M_RU!XAB$M_AI!XAB$M_BI!XAB$M_AT!XAB$M_NEVER_RU>,-
		IFB$B_JNLFLG(R9),XAB$W_JOP(R3) ; copy journaling bits
	BNEQ	5$
	BRW	40$				; branch if none

;
;	Copy journal names, name lengths
;

5$:	PUSHR	#^M<R2,R3,R4,R5,R6>			; save registers
	BBC	#IFB$V_BI,IFB$B_JNLFLG(R9),10$		; branch if no BI
	MOVZBL	XAB$B_BIS(R3),R2			; get buffr size
	BEQL	10$					; branch if no buff
	PROBEW	IFB$B_MODE(R9),R2,@XAB$L_BIA(R3)	; probe buff
	BEQL	ERRXAB_BRJ				; branch on error

	ASSUME	ACE$B_SIZE	EQ	0

	MOVZBL	FWA$T_BIACE(R10),R6			; get ACE size
	SUBB	#ACE$L_ACCESS,R6			; calculate BI name size
	MOVC5	R6,FWA$T_BIJNLN(R10),#^A/ /,R2,@XAB$L_BIA(R3)
	MOVL	4(SP),R3				; Restore XAB addr
	SUBB3	R0,R6,XAB$B_BIL(R3)			; calculate moved size

10$:	BBC	#IFB$V_AI,IFB$B_JNLFLG(R9),20$		; branch if no AI
	MOVZBL	XAB$B_AIS(R3),R2			; get buffr size
	BEQL	20$					; branch if no buff
	PROBEW	IFB$B_MODE(R9),R2,@XAB$L_AIA(R3)	; probe buff
	BEQL	ERRXAB_BRJ				; branch on error
	MOVZBL	FWA$T_AIACE(R10),R6			; get ACE size
	SUBB	#ACE$L_ACCESS,R6			; calculate AI name size
	MOVC5	R6,FWA$T_AIJNLN(R10),#^A/ /,R2,@XAB$L_AIA(R3)
	MOVL	4(SP),R3				; Restore XAB addr
	SUBB3	R0,R6,XAB$B_AIL(R3)			; calculate moved size

20$:	BBC	#IFB$V_AT,IFB$B_JNLFLG(R9),30$		; branch if no AT
	MOVZBL	XAB$B_ATS(R3),R2			; get buffr size
	BEQL	30$					; branch if no buff
	PROBEW	IFB$B_MODE(R9),R2,@XAB$L_ATA(R3)	; probe buff
	BNEQ	25$
	BRW	ERRXAB_BRJ				; branch on error
25$:	MOVZBL	FWA$T_ATACE(R10),R6			; get ACE size
	SUBB	#ACE$L_ACCESS,R6			; calculate AT name size
	MOVC5	R6,FWA$T_ATJNLN(R10),#^A/ /,R2,@XAB$L_ATA(R3)
	MOVL	4(SP),R3				; Restore XAB addr
	SUBB3	R0,R6,XAB$B_ATL(R3)			; calculate moved size

30$: 	POPR	#^M<R2,R3,R4,R5,R6>			; restore registers

40$:	RSB


	.SBTTL	RM$SETEXTRMS - ROUTINE TO HANDLE CONTEXT XAB FOR FAB & RAB

;++
; RM$SETEXTRMS:	Process the Context XABs for the FAB and RAB on RMS exit
;
;
; if a context xab is found, it is filled in with information from the
; IFB or IRB, and FAB or RAB, as needed.
;
; the entire xab chain is checked for validity by XAB_SCAN
;
;--

EXTXAB_ARGS:
	.BYTE	XAB$C_CXF,XAB$C_CXFLEN,XBC$C_EXTCXF
	.BYTE	0

EXTXABR_ARGS:
	.BYTE	XAB$C_CXR,XAB$C_CXRLEN,XBC$C_EXTCXR
	.BYTE	0

RM$SETEXTRMS::

	ASSUME	FAB$B_BID	EQ	RAB$B_BID
	ASSUME	FAB$L_STS	EQ	RAB$L_STS

	CMPB	FAB$B_BID(R8),#FAB$C_BID ; Is the user structure a FAB or RAB?
	BNEQ	10$			; Not a FAB, Must be a RAB
	TSTL	FAB$L_XAB(R8)		; any XABs?
	BEQL	40$			; don't bother checking
	PUSHL	AP			; save register
	MOVAB	EXTXAB_ARGS,AP		; set arg list addr for a FAB
	BRB	20$			; Continue - Call XAB_SCAN
10$:	TSTL	RAB$L_XAB(R8)		; any XABs?
	BEQL	40$			; don't bother checking
	PUSHL	AP			; save register
	MOVAB	EXTXABR_ARGS,AP		; set arg list addr for a RAB
20$:	BSBW	XAB_SCAN		; go scan xab chain
	POPL	AP			; restore register
	BLBS	R0,30$			; success
	SSB	#16,R0			; add facility code on failure
	MOVL	R0,FAB$L_STS(R8)	; save failure status
30$:	MOVL	FAB$L_STS(R8),R0	; restore actual status
40$:	RSB


;
;  Fill in the contents of the FAB associated Context XAB,
;  on exit from the RMS service.  
;
;  (R3) = address of the context XAB, already probed.
;
;  If this is a restart operation, clear the restart bit and copy the
;  bookkeeping bits to the IFAB (and anything else that has to be copied
;  to the IFAB last).  For optimization's sake, do not copy context into
;  XAB for a restart.
;

XABEXTCXF:
	TSTL	R9				; Is this a structureless exit?
	BEQL	2$				; Yes - Skip bit clear

	ASSUME	IRB$V_RESTART	EQ	IFB$V_RESTART

	BBSC	#IRB$V_RESTART,(R9),50$		; Clear restart bit and return

	ASSUME	XAB$L_CXFSTS+4	EQ	XAB$L_CXFSTV

2$:	MOVQ	FAB$L_STS(R8),XAB$L_CXFSTS(R3)	; copy STS/STV fields.
	MOVW	FAB$W_IFI(R8),XAB$W_CXFIFI(R3)	; copy over IFI.
	MOVB	#XAB$C_CXT_VER1,XAB$B_CXFVER(R3) ; Record the version.
;
;  If there is not an internal RMS structure available, this exit is 
;  probably an error, or a close.  Does not make sense to copy anything 
;  else into the context XAB. (cannot copy most things due to no structure)
;
	TSTL	R9					; Is this a structureless exit?
	BEQL	EX_NOIFB				; Yes, No IFAB available.
	MOVL	IFB$L_BKPBITS(R9),XAB$L_CXFBKP(R3)	; Copy bookkeeping bits
	MOVW	IFB$W_RTDEQ(R9),XAB$W_CXFDEQ(R3)	; Run time Default Extend Quan.
	MOVB	IFB$B_FAC(R9),XAB$B_CXFFAC(R3)		; File Access 
	MOVB	IFB$B_SHR(R9),XAB$B_CXFSHR(R3)		; Share 
	MOVZBL	IFB$B_ORGCASE(R9),R0			; File Organization
	ASHL	#4,R0,XAB$B_CXFORG(R3)			; Shift over for XAB
	MOVW	IFB$W_GBC(R9),XAB$W_CXFGBC(R3)		; Global Buffer count
	MOVL	IFB$L_FWA_PTR(R9),R0			; Get FWA address
	MOVAB	@FWA$Q_FIB+4(R0),R0			; Get ptr to FIB in FWA
	MOVB	FIB$B_WSIZE(R0),XAB$B_CXFRTV(R3)	; Copy Retrieval Window from FIB
	BRB	EX_NOIFB				; return

50$:	MOVL	XAB$L_CXFBKP(R3),IFB$L_BKPBITS(R9)	; transfer bookkeeping bits
;
EX_NOIFB:
	RSB				; Return

;
;  Fill in the contents of the RAB associated Context XAB.
;  on exit from the RMS service. 
;  (R3) = address of the context XAB, already probed.
;
;  For optimization's sake, do not copy context into the XAB for a restart
;  operation.
;

XABEXTCXR:
	TSTL	R9				; Is this a structureless exit?
	BEQL	2$				; Yes - Skip bit clear.

	ASSUME	IRB$V_RESTART	EQ	IFB$V_RESTART

	BBSC	#IRB$V_RESTART,(R9),30$		; Clear restart bit while noting restart

	ASSUME	XAB$L_CXRSTS+4	EQ	XAB$L_CXRSTV

2$:	MOVQ	RAB$L_STS(R8),XAB$L_CXRSTS(R3)	; copy STS/STV fields.
	MOVW	RAB$W_ISI(R8),XAB$W_CXRISI(R3)	; copy over IFI.
	MOVB	#XAB$C_CXT_VER1,XAB$B_CXRVER(R3) ; Record version
;
;  If there is not an internal RMS structure available, this exit is 
;  probably an error, or a disconnect.  Does not make sense to copy anything 
;  else into the context XAB (cannot copy some things due to no struture).
;
	TSTL	R9					; Is this a structureless exit?
	BNEQ	20$					; No, continue
	BRW	EX_NOIRB				; Yes, No IRAB available.
20$:	MOVL	IRB$L_BKPBITS(R9),XAB$L_CXRBKP(R3)	; Copy bookkeeping bits
	MOVB	IRB$B_MBC(R9),XAB$B_CXRMBC(R3)		; Copy Multi-block cnt
	MOVB	IRB$B_MBF(R9),XAB$B_CXRMBF(R3)		; Copy Multi-buffer cnt
	CASE	TYPE=B,SRC=IFB$B_ORGCASE(R10),-		; Case on organization
		DISPLIST=<EX_SEQ,EX_REL,EX_ISAM>	; copy different stuff
	RMSERR	ORG					; Organization error
	BRW	CLNSTK					; Remove return PC from 
							;  stack and return.
;
;	Finish coping the last of the items for SEQ and REL restart connect.
;
30$:	
	MOVL	XAB$L_CXRVBN(R3),IRB$L_NRP_VBN(R9)	; copy NRP information -
	MOVW	XAB$W_CXROFF(R3),IRB$W_NRP_OFF(R9)	;  VBN and offset
	MOVL	XAB$L_CXRBKP(R3),IRB$L_BKPBITS(R9)	; copy bookkeeping bits
	BRW	EX_NOIRB				; branch to return 
;
;	For each file organization, need to save different NRP context
;
;	For Sequential and Relative files, copy the same stuff
;
EX_SEQ:							; Sequential files
;
EX_REL:							; Relative files
	MOVL	IRB$L_NRP_VBN(R9),XAB$L_CXRVBN(R3)	; copy nrp vbn
	MOVW	IRB$W_NRP_OFF(R9),XAB$W_CXROFF(R3)	; copy nrp offset
	BRW	EX_NOIRB
;
;  The following will copy all ISAM specific current and next record
;  positioning information to the context XAB.
;
;  Copy the buffer version number into the XAB for restart comparison.
;  This version number indicates what the attached context buffer looks
;  like.  If the buffer changes in internal character, this version needs
;  to be updated. 
;  Note: that the RFA's are copied from the IRAB to the context block.
;  The high order word of the id field of the RFA is forced to Zero.
;  This high order word is checked to be zero on restart.
;
;  Probe the user's key buffer and write counted ascii key strings
;  into it.  The buffer will contain the size of the key followed by 
;  keybuffer 1, then, the size of the key followed by keybuffer 6.  The
;  size field will be verified on restart to all match with the key size
;  kept in the XAB context block.
;
EX_ISAM:						; Indexed files
	INSV	#XAB$C_CXB_VER1,#XAB$V_CXRBVER,#XAB$S_CXRBVER,XAB$L_CXRCOP(R3)
	MOVL	IRB$L_POS_VBN(R9),XAB$L_CXRPOS0(R3)	; Primary record NRP RFA
	MOVZWL	IRB$W_POS_ID(R9),XAB$W_CXRPOS4(R3)	; Primary record NRP RFA
	MOVL	IRB$L_CUR_VBN(R9),XAB$L_CXRCUR0(R3)	; Primary record RFA
	MOVZWL	IRB$W_CUR_ID(R9),XAB$W_CXRCUR4(R3)	; Primary record RFA
	MOVL	IRB$L_SIDR_VBN(R9),XAB$L_CXRSID0(R3)	; SIDR RFA
	MOVZWL	IRB$W_SIDR_ID(R9),XAB$W_CXRSID4(R3)	; SIDR RFA
	MOVW	IRB$W_CUR_COUNT(R9),XAB$W_CXRCNT(R3)	; SIDR array count
	MOVB	IRB$B_CUR_KREF(R9),XAB$B_CXRKREF(R3)	; Current key of ref.
	MOVZWL	IFB$W_KBUFSZ(R10),R0			; Key buffer size
	CMPW	R0,#255					; find out if key size max
	BLEQU	50$					; key sz less than 255
	MOVB	#255,R0					; key size is max.
50$:	MOVB	R0,XAB$B_CXRKLEN(R3)			; Key buffer size
	MOVL	XAB$L_CXRBUF(R3),R1			; (r1) = user buffer
	PROBEW	IRB$B_MODE(R9),XAB$W_CXRBFZ(R3),(R1)	; Probe writability
	BEQL	XABERR					; buffer not okay for use
	CMPW	XAB$W_CXRBFZ(R3),#XAB$C_CXRBLEN		; Make sure long enough
	BLSSU	XABERR					; must be at least that
;
;  (R0) = key size
;  (R1) = User key buffer address.
;  Save the input registers for the MOVC#.  First move keybuffer 1, put in
;  the key size, then after computing the size of keybuffer 6, move in that
;  key.  Fill the remaining part of the user key buffer with zeros.
;
	PUSHR	#^M<R3,R5,R6>				; save registers for MOVC
	MOVL	R0,R6					; save the length there
	MOVB	R0,(R1)+				; Move keybuf size, inc pointer
	MOVC3	R0,@IRB$L_KEYBUF(R9),(R1)		; Move keybuffer 1
	MOVB	R6,(R3)+				; Move in key size
	MULL3	#5,R6,R0				; compute addr of key buffer 6
	ADDL2	IRB$L_KEYBUF(R9),R0			; add in base address
	MOVC5	R6,(R0),#0,R6,(R3)			; move key, fill with 0's
	POPR	#^M<R3,R5,R6>				; restore registers
;
EX_NOIRB:
	RSB				; Return


	.SBTTL	RM$OPNCREXAB - ROUTINE TO RESTART OPEN OR CREATE

;++
; RM$OPNCREXAB:	Process restart operation for Open or Create.
;
;
; if the restart bit is set, use the information from the
; XABCXF to fill in the FAB or IFB as needed for restart.
;
; the entire xab chain is checked for validity by XAB_SCAN
;
;--

OPNCRE_ARGS:
	.BYTE	XAB$C_CXF,XAB$C_CXFLEN,XBC$C_OPNCXF
	.BYTE	0

RM$OPNCREXAB::
	MOVAB	OPNCRE_ARGS,AP		; Set arg list addr
	BRW	XAB_SCAN		; Look for context XAB.

;
; Check for Restart bit in XABCXF (FAB associated Context XAB).
; If restart (set), then verify input and place into FAB or IFB as
; needed for restart.
;
XABOPNCXF:
	BBC	#XAB$V_CXFRST,XAB$L_CXFCOP(R3),RET ;Check to see if restart
	BBSS	#XBC$C_OPNCXF,R4,XABERR		; Check uniqueness of XABCXF
	CMPB	XAB$B_CXFVER(R3),#XAB$C_CXT_VER1 ; Check version of context block
	BNEQ	XABERR				; error if not version 1
	SSB	#IFB$V_RESTART,(R9)		; Remember restart in the IFAB
	MOVW	XAB$W_CXFIFI(R3),FAB$W_IFI(R8)	; Move IFI to FAB 
	BEQL	XABERR				; Restart error if IFI = zero.
;
;  Move saved context into FAB for restart operation.
;
	MOVW	XAB$W_CXFDEQ(R3),FAB$W_DEQ(R8)	; Default extend quantity
	MOVB	XAB$B_CXFFAC(R3),FAB$B_FAC(R8)	; File access
	MOVB	XAB$B_CXFSHR(R3),FAB$B_SHR(R8)	; File Sharing bits
	MOVW	XAB$W_CXFGBC(R3),FAB$W_GBC(R8)	; Global buffer count
	MOVB	XAB$B_CXFRTV(R3),FAB$B_RTV(R8)	; Retrieval window
;
RET:	RMSSUC				; Indicate success
	RSB				; And return

XABERR:
	RMSERR	XAB			; declare XAB error
	BRW	CLNSTK			; remove return pc from stack and RSB


	.SBTTL	RM$CONNXAB - ROUTINE TO RESTART CONNECT

;++
; RM$CONNXAB:	Process restart operation for connect
;
;
; if the restart bit is set, use the information from the
; XABCXR to fill in the RAB or IRB as needed for restart.
;
; the entire xab chain is checked for validity by XAB_SCAN
;
;--

CONNXAB_ARGS:
	.BYTE	XAB$C_CXR,XAB$C_CXRLEN,XBC$C_CONNCXR
	.BYTE	0

RM$CONNXAB::
	MOVAB	CONNXAB_ARGS,AP		; Set arg list addr
	BRW	XAB_SCAN		; Look for context XAB.

;
; Check for Restart bit in XABCXR (RAB associated Context XAB).
; If restart (set), then verify input and place into RAB or IRB as
; needed for restart.
;
XABCONNCXR:
	BBC	#XAB$V_CXRRST,XAB$L_CXRCOP(R3),50$ ;Check to see if restart
	BBSS	#XBC$C_CONNCXR,R4,60$		; Check uniqueness of XABCXR
	CMPB	XAB$B_CXRVER(R3),#XAB$C_CXT_VER1 ; verify version
	BNEQ	60$				; Error on version
	SSB	#IRB$V_RESTART,(R9)		; Remember restart in the IRAB
	CMPL	XAB$L_CXRSTS(R3),#RMS$_STALL	; Verify that status is okay
	BEQL	60$				; Restart error
	CMPL	XAB$L_CXRSTS(R3),#RMS$_PENDING	; Make sure Async I/O Finished
	BEQL	60$				; Restart error 
	MOVW	XAB$W_CXRISI(R3),RAB$W_ISI(R8)	; Move ISI to RAB 
	BEQL	60$				; Restart error if ISI = zero.
	MOVB	XAB$B_CXRMBC(R3),RAB$B_MBC(R8)	; Copy back the Multi-block cnt
	MOVB	XAB$B_CXRMBF(R3),RAB$B_MBF(R8)	; copy back the multi-buffer cnt

50$:	RMSSUC				; Indicate success
	RSB				; And return

60$:	RMSERR	XAB			; declare XAB error
	BRW	CLNSTK			; remove return pc from stack and RSB

;++
;
;  XCONN03::
;
;  This routine is used to recreate the ISAM stream NRP context.
;
;  At this point, I KNOW that everything about the connect has gone okay.
;  This routine will copy all ISAM specific current and next record
;  positioning information from the context XAB into the IRAB and key
;  buffers allocated on the Connect.
;
;  A certain amount of sanity checking is done to verify that the NRP
;  information is correct.  On any error, return is immediate and no
;  context restoration is done.  First, a check is made to see if the
;  version of the context block and the version number of the attached context
;  buffer is VER1.  Next, the high order word of each RFA is verified
;  to be zero.  The key size fields are checked to be the same.  The user
;  data record VBN/ID pair are zeroed to indicate that there is NO current
;  record with respect to the operations such as Delete, and Update.  These
;  operations imply record locking which does not take place on process restart.
;
;--

XCONN03:
	BBCC	#XBC$C_CONNCXR,R4,5$			; Check uniqueness of XABCXR
	BRW	60$					; error - multiple XAB's
5$:	CMPB	XAB$B_CXRVER(R3),#XAB$C_CXT_VER1	; verify version
	BEQL	8$
	BRW	60$					; error on version
8$:	CMPZV	#XAB$V_CXRBVER,#XAB$S_CXRBVER,XAB$L_CXRCOP(R3),#XAB$C_CXB_VER1
	BNEQ	60$					; Error - not correct ver
	MOVL	XAB$L_CXRPOS0(R3),IRB$L_POS_VBN(R9)	; Primary record NRP RFA
	MOVW	XAB$W_CXRPOS4(R3),IRB$W_POS_ID(R9)	; Primary record NRP RFA
	TSTW	XAB$W_CXRPOS4+2(R3)			; Check the MBZ field of RFA
	BNEQ	60$					; Error out if not zero
	MOVL	XAB$L_CXRCUR0(R3),IRB$L_CUR_VBN(R9)	; Primary record RFA
	MOVW	XAB$W_CXRCUR4(R3),IRB$W_CUR_ID(R9)	; Primary record RFA
	TSTW	XAB$W_CXRCUR4+2(R3)			; check MBZ field of RFA
	BNEQ	60$					; error out if not zero
	MOVL	XAB$L_CXRSID0(R3),IRB$L_SIDR_VBN(R9)	; SIDR RFA
	MOVW	XAB$W_CXRSID4(R3),IRB$W_SIDR_ID(R9)	; SIDR RFA
	TSTW	XAB$W_CXRSID4+2(R3)			; Check MBZ field of RFA
	BNEQ	60$					; error out if not zero
	MOVW	XAB$W_CXRCNT(R3),IRB$W_CUR_COUNT(R9)	; SIDR array count
	MOVB	XAB$B_CXRKREF(R3),IRB$B_CUR_KREF(R9)	; Current key of ref.
	MOVL	XAB$L_CXRBKP(R3),IRB$L_BKPBITS(R9)	; copy bookkeeping bits
	CLRL	IRB$L_UDR_VBN(R9)			; make sure User Data RFA is zero
	CLRW	IRB$W_UDR_ID(R9)			; And id too.
;
;  Probe the user's key buffer and copy the counted ascii key strings
;  (minus the count) into the internal key buffers.
;
	MOVZWL	IFB$W_KBUFSZ(R10),R0			; Key buffer size
	CMPW	R0,#255					; find out if key size max
	BLEQU	50$					; key sz less than 255
	MOVB	#255,R0					; key size is max.
50$:	CMPB	R0,XAB$B_CXRKLEN(R3)			; compare that key size same
	BNEQ	60$					; buffer not okay for use
	MOVL	XAB$L_CXRBUF(R3),R1			; (r1) = user buffer
	PROBER	IRB$B_MODE(R9),XAB$W_CXRBFZ(R3),(R1)	; Probe readability
	BEQL	58$					; Buffer not okay for use
	CMPW	XAB$W_CXRBFZ(R3),#XAB$C_CXRBLEN		; Make sure long enough
	BGEQU	70$					; must be at least that
;
58$:	POPR	#^M<R3,R5,R6,R7>			; restore registers
60$:	RMSERR	XAB
	BRW	CLNSTK
;
;  (R0) = key size from IFAB.
;  (R1) = User key buffer address.
;  Save the input registers for the MOVC#.  First move the saved key into 
;  keybuffer 1, then after computing the size of keybuffer 6, move in that
;  key.  Verify that the remaining part of the user key buffer is zeros.
;
70$:	PUSHR	#^M<R3,R5,R6,R7>			; save registers for MOVC
	MOVL	R0,R6					; save the length there
	MOVB	(R1)+,R0				; Move keybuf size, inc pointer
	CMPB	R0,R6					; compare size fields
	BNEQ	58$					; No match - invalid buffer
	MOVC3	R0,(R1),@IRB$L_KEYBUF(R9)		; Move keybuffer 1
	CMPB	(R1)+,R6				; Compare key size fields
	BNEQ	58$					; No match - invalid buffer
;
;  Compute the size of keybuffer 6 and move the key from the user buffer
;
	MULL3	#5,R6,R0				; compute addr of key buffer 6
	ADDL2	IRB$L_KEYBUF(R9),R0			; add in base address
	MOVC3	R6,(R1),(R0)				; move key
;
;  Compute the total number of characters written into user buffer
;
	ADDL	R6,R6					; (r6) size of key
	ADDL	#2,R6					; add the counted ascii part
	SUBL3	R6,#XAB$C_CXRBLEN,R6			; subtract from total length
	SKPC	#0,R6,(R1)				; make sure they are zero
	BNEQ	58$					; not valid buffer....
	POPR	#^M<R3,R5,R6,R7>			; restore registers

80$:	RMSSUC
	RSB

	.SBTTL	Terminal XAB Routines

;++
; XABTRM rouine called if a terminal XAB is found for a $GET/$PUT.
;
; Simply save address of XABTRM in R5 for use by caller of RM$XAB_SCAN.
;--

XABTRM:
	BBSS	#XBC$C_GETPUTTRM,R4,ERRIMX_TRM
					; Flag XAB seen; if seen, error.
	MOVL	R3, R5			; Save XAB address in R5 for later use.
	RMSSUC				; Indicate success.
	RSB				; All done.

ERRIMX_TRM:
	BRW	ERRIMX			; Need extended branch.

	.END
