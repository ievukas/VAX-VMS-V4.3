module lnk_maproutines 			! LINKER MAP ROUTINES
		(ident = 'V04-000'
		,addressing_mode 
			(external    = general
			,nonexternal = long_relative
			)
		) =
begin
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	LINKER
!
! ABSTRACT:	PRODUCES THE MAP
!
! ENVIRONMENT:
!
! AUTHOR: K.D. MORSE, CREATION DATE: 27-MAR-77
!
! MODIFIED BY:
!
!	V03-007	ADE0004		Alan D. Eldridge	22-Jun-1984
!		Adhere to Grammer Rules for output file spec's as defined
!		in the Command Language User's Guide.
!
!	V03-006	ADE0003		Alan D. Eldridge	29-Apr-1984
!		Don't suppress zero lengthed PSECT's from the Program
!		Section Synopsis.
!
!	V03-005	ADE0002		Alan D. Eldridge	12-Apr-1984
!		Use 'output file parse' option only if /MAP was not
!		a command qualifier.
!
!	V03-004	ADE0001		Alan D. Eldridge	 5-Mar-1984
!		Call LIB$TRIM_FILESPEC to appropiately trim file names.
!
!	V03-003	JWT0113		Jim Teague		20-Apr-1983
!		Call $getjpi to get number of open files left.
!
!	V03-002 JWT0044		Jim Teague		30-Jul-1982
!		Open file performance boost.
!
!	V03-001	JWT0038		Jim Teague		23-Jun-1982
!		Clean up INFO#212 errors.
!
!--

!++
!
! MODULE DESCRIPTION:
!
! THIS MODULE CONTAINS ALL THE ROUTINES NEEDED TO CREATE A MAP FOR THE
! LINKER.  THERE IS A GLOBAL ROUTINE TO PRODUCE EACH SECTION OF
! THE MAP AND SEVERAL LOCAL SUBROUTINES TO HANDLE THE ACTUAL OUTPUT.
!
! THE CALLING SEQUENCES OF THE GLOBAL ROUTINES ARE:
!	LNK$MAPINIT()
!	LNK$MAPMHD(OBJREC,OBJMODDSC)
!	LNK$MAPLNG(LANGADDR,LANGLEN)
!	LNK$MAPADROMD()
!	LNK$MAPPSCTS()
!	LNK$MAPSYMS()
!	LNK$MAPISCTS()
!	LNK$MAPOUT(LINEADDR,COUNT)
!
! WHERE:
!
!	OBJREC IS THE ADDRESS OF A MODULE HEADER RECORD (SEE OBJFMT)
!	OBJMODDSC IS THE ADDRESS OF AN OBJECT MODULE DESCRIPTOR (SEE DATBAS)
!	LANGADDR IS THE ADDRESS OF THE LANGUAGE PROCESSOR SUB-HEADER RECORD
!	LANGLEN IS THE LENGTH OF THE LANGUAGE PROCESSOR NAME
!	LINEADDR IS THE ADDRESS OF A LINE TO BE OUTPUT TO THE MAP (E.G. ERROR MESSAGES)
!	COUNT IS THE NUMBER OF BYTES IN THE OUTPUT LINE
!
!--

!
! TABLE OF CONTENTS:
!
forward routine
    crferror 		: novalue,		! CALLED BY CREF ON ERRORS
    faofail 		: novalue,		! HANDLES FAILURES FROM FAO
    trimfail		: novalue,		! HANDLES FAIURES FROM LIB$TRIM_FILESPEC
    lnk$mapinit 	: novalue,		! INITIALIZE MAP FILE
    lnk$closmapfil 	: novalue,		! CLOSE THE MAP FILE
    mapfail 		: novalue,		! MAP I/O FAILURE ROUTINE
    lnk$mapmhd 		: novalue,		! CREATE OBJECT MODULE LINE
    lnk$maplng 		: novalue,		! INSERT CREATOR IN MHD LINE
    lnk$mapadromd 	: novalue,		! LIST MODULES CONTAINING ADDRESS DATA
    lnk$mappscts 	: novalue,		! CREATE THE PSECT MAP SECTION
    lnk$mapsyms 	: novalue,		! CREATE ALL MAP SECTIONS FOR SYMBOLS
    lnk$mapiscts 	: novalue,		! CREATE THE IMAGE SECTION SYNOPSIS
    lnk$mapstats 	: novalue,		! OUTPUT LINKER'S RUN STATISTICS
    mapbox,					! OUTPUT A HEADER IN A BOX
    lnk$mapout,					! OUTPUT ONE LINE ALREADY FORMATTED
    lnk$crfout,					! OUTPUT CROSS REF LINE
    mapsubhdr,					! CREATE A NEW SUBHEADER LINE AND OUTPUT IT
    newpage,					! OUTPUT NEW PAGE, HEADER, AND SUB-HEADER
    newline;					! OUTPUT BLANK LINE
!
! INCLUDE FILES:
!
library 'LIBL32';				! SYSTEM STRUCTURE DEFINITIONS
require 'PREFIX';				! GET GENERAL DEFINITIONS
library 'DATBAS';				! GET BASIC DATA BASE DEFINITIONS
require 'ISGENC';				! GET OBJECT LANGUAGE RECORD FORMAT ANE ISD LAYOUT
require 'CRFMDL';				! CREF FIELD DEFINITIONS

!
! EQUATED SYMBOLS:
!
global literal
    len$c_mapline = 132,			! LENGTH OF LINES ON THE MAP
    len$c_lngnam  =  30;			! MAXIMUM LENGTH OF MODULE CREATOR NAME

literal
    date_fld_lng  = 17,				! LENGTH OF DATE FIELD IN OBJ MOD HDR REC
    maj_ident_lng =  2,				! LENGTH OF MAJOR IDENT
    min_ident_lng =  2,				! LENGTH OF MINOR IDENT
    max_k_rmsmbc  =  8,				! MAXIMUM NUMBER FOR RMS BLOCKING
    boxlines      =  3 ;			! NUMBER OF LINES IN BOX HEADINGS

!
! OWN STORAGE:
!
psect
    own = $plit$(nopic, concatenate, local, noshare, noexecute, nowrite);

own
!
! FAO CONTROL STRINGS
!
    contrbstr	    : descriptor ('!16AC!15AC!3(9XL) (!11UL.) !5AC!1ZB'),	! PSECT CONTRIBUTION
    contrbst1	    : descriptor ('!31AC!3(9XL) (!11UL.) !5AC!1ZB'),
    contrbst2	    : descriptor ('!16AC!39AC'),
    contrbst3	    : descriptor ('!31AC!3(9XL) (!11UL.) !5AC!1ZB'),
    psc_cntrl_str   : descriptor ('!16AC!15AC!3(9XL) (!11UL.) !5AC!ZB !10(AC)'),
    psc_cntrl_st1   : descriptor ('!31AC!3(9XL) (!11UL.) !5AC!ZB !10(AC)'),
    hdr_cntrl_str   : descriptor ('!64AS!25<!17%D!>!33<VAX-11 Linker V!AD-!AD!>Page!5UL'),
										! MAP PAGE HEADING
    ff_cntrl_str    : descriptor ('!^'),					! NEW PAGE
    objmd_cntrl_str : descriptor ('!16AC!15AC!10UL !37AD!19AD'),		! OBJ MOD SECTION
    objmd_cntrl_st1 : descriptor ('!31AC'),
    objmd_cntrl_st2 : descriptor ('!31AC!10UL !37AD!19AD'),
    creat_cntrl_str : descriptor ('!AD'),					! CREATOR OF MODULE
    omdadrstr 	    : descriptor ('!33AC!8UL  '),				! MODULE .ADDRESS COUNT
    abbrvtbl1_str   : descriptor ('!_!_+!18*-+'),
    abbrvtbl2_str   : descriptor ('!_!_!!!AC!!'),
    isect_cntrl_str : descriptor ('!16AC!4UB!6UW  !2AC!8XL!2AC!9UL!4UB !AC !AC !AC'),
    gblis_cntrl_str : descriptor (
		    '!16AC!4UB!6UW  !2AC!8XL!2AC!9UL!4UB!28< !AC !AC !AC!>!16AC !12AC !6UB  !8UL'),
!
! FAO CONTROL STRINGS FOR LINK-WIDE SYNOPSIS
!
    virmemline      : descriptor ('!49<Virtual memory allocated:!>!3(9XL) (!UL. byte!%S, !UL. page!%S)'),
    stackline       : descriptor ('!50<Stack size:!>!8UW. page!%S'),
    mapformat       : descriptor ('!50<Map format:!>!AC!ACin file !AD'),
    maplength       : descriptor ('!50<Estimated map length:!>!UL. blocks'),
    imghdrblkline   : descriptor ('!50<Image header virtual block limits:!>!8UL.!9UW. (!5UW. block!%S)'),
    imgbinblkline   : descriptor ('!50<Image binary virtual block limits:!>!8UL.!9UL. (!5UW. block!%S)'),
    identline       : descriptor ('!50<Image name and identification:!>!AC !AC'),
    nfilline        : descriptor ('!50<Number of files:!>!8UW.'),
    nmodline        : descriptor ('!50<Number of modules:!>!8UW.'),
    npscline        : descriptor ('!50<Number of program sections:!>!8UW.'),	! NO. OF P-SECTS IN LINK
    nsymline        : descriptor ('!50<Number of global symbols:!>!8UW.'),	! NO. OF GLOBAL SYMBOLS
    nundfline       : descriptor ('!50<Including undefined count of:!>!8UW.'),	! NO. OF UNDEFINED SYMBOLS
    ncrosrefs       : descriptor ('!50<Number of cross references:!>!8UW.'),
    niscline        : descriptor ('!50<Number of image sections:!>!8UW.'),	! NO. OF IMAGE SECTIONS
    nadrefline      : descriptor ('!50<Number of address fixups:!>!8UL.'),	! NO. OF .ADDRESSES FIXED UP
    nshrsymline     : descriptor ('!50<Number of code references to shareable images:!>!8UL.'),
    dbgtfrline      : descriptor ('!50<Debugger transfer address:!>!8XL'),	! DEBUGGER TRANSFER ADDRESS
    otstfrline      : descriptor ('!50<OTS transfer address - !AC:!>!8XL'),	! OTS TRANSFER ADDRESS
    usrtfrline      : descriptor ('!50<User transfer address:!>!8XL'),		! USER TRANSFER ADDRESS
    imgatrline      : descriptor ('!50<Image type:!>!AC.'),			! IMAGE ATTRIBUTES LINE
    imgshrline      : descriptor (						! IMAGE ATTRIBUTES LINE
			'!50<Image type:!>!AC!AC. Global Section Match=!AC, Ident, Major=!UB, Minor=!UL') ;

bind
    alignbyte	= cstring ('BYTE '),				! BYTE ALIGNMENT ASCIC STRING
    alignword	= cstring ('WORD '),				! WORD ALIGNMENT ASCIC STRING
    alignlong	= cstring ('LONG '),				! LONGWORD ALIGNMENT ASCIC STRING
    alignquad	= cstring ('QUAD '),				! QUADWORD ALIGNMENT ASCIC STRING
    align2   	= cstring ('2 ** '),				! OTHER ALIGNMENT ASCIC STRING
    alignpage	= cstring ('PAGE '),				! PAGE ALIGNMENT ASCIC STRING
    blanks	= cstring (' '),				! ASCIC STRING OF SPACE
    hyphens   	= cstring ('-'),				! ASCIC STRING OF HYPHENS
    hyphen_r 	= cstring ('-R'),				! ASCIC STRING OF HYPHEN AND "R"
    p_hyphen	= cstring ('P-'),				! TO INDICATE SECTION IS PROTECTED
    pic		= cstring ('  PIC,'),				! PIC ATTRIBUTE ASCIC STRING
    lib		= cstring ('LIB,'),				! LIB ATTRIBUTE ASCIC STRING
    ovr		= cstring ('OVR,'),				! OVR ATTRIBUTE ASCIC STRING
    rel		= cstring ('REL,'),				! REL ATTRIBUTE ASCIC STRING
    gbl		= cstring ('GBL,'),				! GBL ATTRIBUTE ASCIC STRING
    vec		= cstring ('  VEC'),				! VECTOR PSECT
    shr		= cstring ('  SHR,'),				! SHR ATTRIBUTE ASCIC STRING
    exe		= cstring ('  EXE,'),				! EXE ATTRIBUTE ASCIC STRING
    rd		= cstring ('  RD,'),				! RD ATTRIBUTE ASCIC STRING
    wrt 	= cstring ('  WRT,'),				! WRITEABLE
    nopic	= cstring ('NOPIC,'),				! WRT ATTRIBUTE ASCIC STRING
    usr		= cstring ('USR,'),				! USR ATTRIBUTE ASCIC STRING
    con		= cstring ('CON,'),				! CON ATTRIBUTE ASCIC STRING
    abs		= cstring ('ABS,'),				! ABS ATTRIBUTE ASCIC STRING
    lcl		= cstring ('LCL,'),				! LCL ATTRIBUTE ASCIC STRING
    novec	= cstring ('NOVEC'),				! NOT VECTOR PSECT
    noshr	= cstring ('NOSHR,'),				! NOSHR ATTRIBUTE ASCIC STRING
    noexe	= cstring ('NOEXE,'),				! NOEXE ATTRIBUTE ASCIC STRING
    nord	= cstring ('NORD,'),				! NORD ATTRIBUTE ASCIC STRING
    nowrt	= cstring ('NOWRT,'),				! NOT WRITEABLE
    exeimage	= cstring ('EXECUTABLE'),			! EXECUTABLE IMAGE
    sysimage	= cstring ('SYSTEM'),				! SYSTEM IMAGE
    shrimage	= cstring (' SHAREABLE'),			! AND LINKABLE IMAGE
    briefmap	= cstring ('BRIEF'),				! BRIEF MAP FORMAT
    alltime	= cstring ('ALWAYS'),				! GS MATCH = ALWAYS
    never	= cstring ('NEVER'),				! GS MATCH = NEVER
    equal	= cstring ('EQUAL'),				! GS MATCH = EQUAL
    lssequal	= cstring ('LESS/EQUAL'),			! GS MATCH = LESS/EQUAL
    defaultmap	= cstring ('DEFAULT'),				! DEFAULT FORMAT
    longmap	= cstring ('FULL'),				! LONG FORMAT
    crefmap	= cstring (' WITH CROSS REFERENCE '),		! WITH CROSS REFERENCES
    readwrite	= cstring ('READ WRITE'),
    readonly	= cstring ('READ ONLY'),
    demandzero	= cstring ('DEMAND ZERO'),
    copyonref 	= cstring ('COPY ON REF'),
    addrdata  	= cstring ('NON-SHAREABLE ADDRESS DATA'),
    fixupsection= cstring ('FIXUP VECTORS'),
    chardef_str	= cstring ('	  Key for special characters above:') : vector [, byte],
    undef_str	= cstring (' *  - Undefined   '),
    univ_str	= cstring (' U  - Universal   '),
    ext_str	= cstring (' X  - External    '),
    reloc_str	= cstring (' R  - Relocatable '),
    weak_str	= cstring (' WK - Weak        '),
    protect_str	= cstring (' P  - Protected   '),
    str_pointer	= uplit  (long  (undef_str
				,univ_str
				,reloc_str
				,ext_str
				,weak_str))   : vector [, long],
    istr_pointer = uplit (long (reloc_str,
				protect_str)) : vector [, long],
!
! BOXED HEADERS
!
    imagesections = cstring ('! Image Section Synopsis !'),	! IMAGE SECTION HEADER
    psecthdr	= cstring ('! Program Section Synopsis !'),	! PSECT SECTION HEADER
    objmodhdr	= cstring ('! Object Module Synopsis !'),	! OBJECT MODULE SECTION HEADER
    omdadrhdr	= cstring ('! Module Relocatable Reference Synopsis !'), ! COUNT OF .ADDRESSES IN A MODULE
    linkwidehdr	= cstring ('! Image Synopsis !'),		! LINK-WIDE INFORMATION HEADER
    symbyname	= cstring ('! Symbols By Name !'),		! SYMBOL TABLE
    symbolcref	= cstring ('! Symbol Cross Reference !'),	! WITH CROSS REFERENCE
    symbyvalue	= cstring ('! Symbols By Value !'),		! SYMBOL TABLE PRINTED BY VALUES
    linkstats	= cstring ('! Link Run Statistics !') ;		! STATISTICS OF THE RUN

!
! SUB-HEADERS
!

own
    psectsubhdr : vector [4] 
      initial 
	(stringdesc 
	    ('!16<Psect Name!>!18<Module Name!>!9<Base!>!14<End!>!18<Length!>!22<Align!>Attributes')
	,stringdesc
	    ('!16<!10*-!>!18<!11*-!>!9<!4*-!>!14<!3*-!>!18<!6*-!>!22<!5*-!>!10*-')
	),
!
    objmodsubhdr : vector [4] 
      initial 
	(stringdesc 
	    ('!16<Module Name!>!19<Ident!>!11<Bytes!>!36<File!>!19<Creation Date!>Creator')
	,stringdesc
	    ('!16<!11*-!>!19<!5*-!>!11<!5*-!>!36<!5*-!>!19<!13*-!>!7*-')
	),
    omdadrsubhdr : vector [4] 
      initial 
	(stringdesc 
	    (
	'!33<Module Name!>!8<  Number!>  !33<Module Name!>!8<  Number!>  !33<Module Name!>!8<  Number!>'
	     )
	,stringdesc 
	    ('!33<!11*-!>!8<  !6*-!>  !33<!11*-!>!8<  !6*-!>  !33<!11*-!>!8<  !6*-!>')
	),
!
    crfsubhd1	  : descriptor ('<Symbol!>!16<Value!>!'),
    crfsubhd2     : descriptor ('<Defined By!>Referenced By ...'),
    crfsubhd3     : descriptor ('<!6*-!>!16<!5*-!>!'),
    crfsubhd4     : descriptor ('<!10*-!>!17*-'),
    fao_crefsubhd : descriptor ('!!!UL!AS!UL!AS'),	!FAO CONTROL STRING TO CREATE CRF SUB HEADER
    fao_cre1      : descriptor ('!!!ULAC'),		!FAO CONTROL STRING TO CREATE FAO CONTROL STRING
!
    symsubhdr : vector [4] 
      initial 
	(stringdesc 
	    ('!16<Symbol!>!19<Value!>!16<Symbol!>!19<Value!>!16<Symbol!>!19<Value!>!16<Symbol!>Value')
	,stringdesc
	    ('!16<!6*-!>!19<!5*-!>!16<!6*-!>!19<!5*-!>!16<!6*-!>!19<!5*-!>!16<!6*-!>!5*-')
	),
!
! SYMBOL TABLE SUB-HEADER USED IF LONG SYMBOL NAME SEEN
!
    symlngsubhdr : vector [4] 
      initial 
	(stringdesc 
	    ('!32<Symbol!>!12<Value!>!32<Symbol!>!12<Value!>!32<Symbol!>!12<Value!>')
	,stringdesc
	    ('!32<!6*-!>!12<!5*-!>!32<!6*-!>!12<!5*-!>!32<!6*-!>!12<!5*-!>')
	),
!
    valsubhdr : vector [4] 
      initial 
	(stringdesc 
	    ('!40<Value!>Symbols...'),stringdesc('!40<!5*-!>!10*-')
	),
!
    isdsubhdr : vector [4] 
      initial 
	(stringdesc 
	    (
   '!16<   Cluster!>!5<Type!>!8<Pages!>!51<!AC!>!16<Global Sec. Name!>!12<   Match!> Majorid   Minorid'
	    )
	,stringdesc
	    ('!16<   !7*-!>!5<!4*-!>!8<!5*-!>!9*-  !8*- !3*- !27<!21*-!>!16*-!12<   !5*-!> !7*-   !7*-')
	) ;

psect
    own = $own$(nopic, concatenate, local, noshare, noexecute, write) ;
!
! READ/WRITE OWN STORAGE
!
own
!
! BUFFERS AND DESCRIPTORS
!
    alignment,							! ADDRESS OF ALIGNMENT DESCRIPTION
    outline	: ch$sequence [len$c_mapline],			! OUTPUT LINE BUFFER
    outdes	: vector [2] initial (len$c_mapline, outline),	! OUTPUT LINE DESCRIPTOR
    outsize	: word,						! SIZE OF OUTPUT STRING
    args	: vector [10],					! FAO ARGUMENTS
    linecnt,							! NUMBER OF LINES OUTPUT ON CURRENT PAGE
    pagenum,							! NEXT PAGE NUMBER
    subhdline,							! ADDR OF SUB-HEADER LINE DESCRIPTOR
    crfsubhdr	: block [dsc$c_s_bln*2, byte],
    fao_sym	: block [8, byte],
    fao_symdesc : block [dsc$c_s_bln, byte] initial (8, fao_sym),
    fao_mod 	: block [8, byte],
    fao_modesc 	: block [dsc$c_s_bln, byte] initial (8, fao_mod);

bind
    isdtxt = cstring ('Base Addr  Disk VBN PFC Protection and Paging');

!
! EXTERNAL REFERENCES:
!

external routine
    lnk$closefile 	: novalue,			! ROUTINE TO CLOSE A FILE
    crf$out,						! CROSS REFERENCE AND SYMBOL TABLE OUTPUT
    sys$fao,						! FORMATTED ASCII OUTPUT
    lnk$filnamdsc,					! RETURN FILE NAME FROM FAB
    lib$traverse_tree,					! TRAVERSE BINARY TREE
    lib$lp_lines,					! DETERMINE NUMBER OF LINES PER PAGE
    lib$trim_filespec,					! TRIMS FILE SPEC
    sys$gettim,						! GETS CURRENT TIME FROM SYSTEM
    lnk$statsout;					! DOES ALL THE WORK

external literal
    lin$_crferr,					! CROSS REFERENCE ERROR
    lin$_closeout,					! CLOSE ERROR MESSAGE
    lin$_faofail,					! FAILURE RETURN FROM FAO
    lin$_openout,					! ERROR OPENING OUTPUT FILE
    lin$_writeerr;					! ERROR MESSAGE CODE FOR PUT FAILURE

external
    lnk$gl_filesleft,
    lnk$gt_jpilst,
    lnk$gl_omdadrlst,					! LIST HEAD OF OBJ MODULES WITH ADDRESS DATA
    lnk$gl_nadromd,					! NUMBER OF OBJECT MODULES WITH ADDRESS DATA
    lnk$gl_matchid,					! PNTR TO GLOB SEC ID
    lnk$gb_matchctl 	: block [, byte],		! GLOB SEC MATCH CTL FLG
    lnk$gl_inrelnam,					! NAM BLOCK FOR FIRST INPUT FILE
    lnk$gl_relnam_map,					! NAM BLOCK OF INPUT FILE ASSOC. WITH /MAP
    lnk$gb_locnov_map	: byte,				! SET IF /MAP WAS 'LOCAL' WITHOUT A VALUE
    lnk$gl_ctlmsk 	: block [, byte],		! CONTROL BIT MASK LONGWORD
    lnk$gl_curfil 	: ref block [, byte],		! CURRENT FILE DESCRIPTOR
    lnk$gl_imgfil 	: ref block [, byte],		! IMAGE FILE DESCRIPTOR
    lnk$gl_mapfil 	: ref block [, byte],		! MAP FILE DESCRIPTOR
    lnk$gl_errlist,					! LIST HEAD OF NON-MODULE ERRORS
    lnk$gq_startim,					! STARTING DATE AND TIME
    lnk$aw_version 	: block [lid$c_size, byte],	! VERSION OF LINKER
    lnk$gw_hdrblks 	: word,				! NUMBER OF IMAGE HEADER BLOCKS
    lnk$gw_imgblks 	: word,				! NUMBER OF IMAGE BINARY BLOCKS
    lnk$gl_curclu 	: ref block [, byte],		! CURRENT CLUSTER DESCRIPTOR
    lnk$gl_fixisd 	: ref block [, byte],		! ADDRESS OF FIXUP ISECT DESCRIPTOR
    lnk$gl_clulst,					! CLUSTR LISTHEAD
    lnk$gl_maplst,					! LIST OF P-SECTIONS FOR MAP
    lnk$gl_maxva,					! MAXIMUM VIRTUAL ADDRESS ALLOCATED
    lnk$gl_minva,					! MINIMUM
    lnk$gl_adrefs,					! NUMBER OF .ADDRESS FIXUPS
    lnk$gl_shrsyms,					! NUMBER REFERENCES TO SHAREABLE IMAGE SYMBOLS
    lnk$gw_stack 	: word,				! SIZE OF STACK
    lnk$gw_nfiles 	: word,				! NUMBER OF FILES IN LINK
    lnk$gw_nmodules 	: word,				! NUMBER OF MODULES IN LINK
    lnk$gw_npsects 	: word,				! NUMBER OF P-SECTS IN LINK
    lnk$gw_nsymbols 	: word,				! NUMBER OF SYMBOLS IN LINK
    lnk$gw_ncrosrfs 	: word,				! NUMBER OF SYMBOL CROSS REFERENCES
    lnk$gw_nudfsyms 	: word,				! NUMBER OF UNDEFINED SYMBOLS
    lnk$gl_tfradr 	: long,				! USER TRANSFER ADDRESS
    lnk$gl_dbgtfr 	: long,				! DEBUGGER TRANSFER ADDRESS
    lnk$gl_otsepdsc 	: ref block [, byte],		! SYMBOL TABLE ENTRY FOR OTS RESERVED SYMBOL
    lnk$gw_nisects 	: word,				! NUMBER OF IMAGE SECTIONS
    lnk$gl_tfrpsc 	: long,				! PSECT DEFINING USER TRANSFER ADDRESS
    lnk$gl_dbgtfps 	: long,				! PSECT DEFINING DEBUGGER TRANSFER ADDRESS
    lnk$gt_imgnam 	: vector [, byte],		! IMAGE NAME STRING
    lnk$gt_imgid 	: vector [, byte];		! IMAGE ID STRING

own
    lastomd 		: ref block [, byte],			! POINTER TO LAST OBJ MODULE DESCRIPTOR
    mapestim,							! ESTIMATE OF MAP LENGTH
    imagefilename 	: descriptor ('No image file created'),	! STRING TO PRINT WHEN THERE
    								! WAS NO IMAGE CREATED
    psectnameline,						! 0 OR POINTER TO PSECT SYNOPSIS LINE
    auxfnb 		: ref block [, byte],			! PTR TO FILE'S AUXILIARY FILENAME BLOCK
    rmserror,							! ERROR CODE RETURNED BY RMS
    maprab 		: $rab (rac = seq, rop = wbh),		! SEQUENTIAL
    mapifi 		: word,					! SAVED INTERNAL IDENT FOR CLOSE
    symbolfield 	: $crffield (fao_string = '!15AC', 	! THE KEY 1 FIELD IS THE
				     field_width = 15),		! SYMBOL
    symbolend 		: $crffieldend,
    spacefield 		: $crffield (fao_string = ' ', 		! SPACES BETWEEN SYMBOL AND VALUE
				     field_width = 1),
    spaceend 		: $crffieldend,
    valuefield 		: $crffield (fao_string = '!XL', 	! HEX LONGWORD VALUE
				     field_width = 8),
    valueend 		: $crffieldend,
    valueflags 		: $crffield (fao_string = '!3* ', 	! DEFAULT SUFFIX
				     field_width = 3),		! WHEN NONE OF FOLLOWING APPLIES
    reloc_suf 		: $crffield (bit_mask = gsy$m_rel, 	! RELOCATABLE ONLY
				     fao_string = '-R ', 	! SUFFIX
				     field_width = 3),
    univ_suf 		: $crffield (bit_mask = gsy$m_uni, 	! SUFFIX ON UNIVERSAL
				     fao_string = '-U ', 
				     field_width = 3),
    rel_uni_suf 	: $crffield (bit_mask = 		! SUFFIX ON RELOCATABLE
	    			      (gsy$m_uni or gsy$m_rel), ! AND UNIVERSAL
				       fao_string = '-RU', 
				       field_width = 3),
    ext_suf 		: $crffield (bit_mask = sym$m_gref, 	! EXTERNAL SYMBOL, NOT RELOCATABLE
				     fao_string = '-X ', 
				     field_width = 3),
    rel_ext_suf 	: $crffield (bit_mask = 		! RELOCATABLE EXTERNAL SYMBOL
				      (gsy$m_rel or sym$m_gref), 
				     fao_string = '-RX', 
				     field_width = 3),
    undef_suf 		: $crffield (bit_mask = gsy$m_def, 	! SUFFIX ON UNDEFINED
				     set_clear = 0, 		! SYMBOL VALUES
				     fao_string = '-* ', 
				     field_width = 3),
    valflgsend 		: $crffieldend,
    refnceflags 	: $crffield (fao_string = '!6* ', 	! DEFAULT SPACES WHEN NONE OF
				     field_width = 6),		! THE FOLLOWING REFERENCES
    weak_pre 		: $crffield (bit_mask = gsy$m_weak, 	! PREFIX FOR WEAK REFERENCE
				     fao_string = '!3* WK-', 
				     field_width = 6),
    reflagsend 		: $crffieldend,
    referencer 		: $crffield (fao_string = '!16AC', 	! NAME OF THE REFERENCING MODULE
				     field_width = 16),
    referencend 	: $crffieldend,
!
    relsymval 	 : $crffield (fao_string = '!4* ', field_width = 4),
    reloc_pre 	 : $crffield (bit_mask = gsy$m_rel, fao_string = '  R-', field_width = 4),
    univ_pre 	 : $crffield (bit_mask = gsy$m_uni, fao_string = '  U-', field_width = 4),
    rel_uni_pre  : $crffield (bit_mask = (gsy$m_uni or gsy$m_rel), fao_string = ' RU-', field_width = 4),
    ext_pre 	 : $crffield (bit_mask = sym$m_gref, fao_string = '  X-', field_width = 4),
    rel_ext_pre	 : $crffield (bit_mask = (gsy$m_rel or sym$m_gref), fao_string = ' RX-', field_width = 4),
    relsymvalend : $crffieldend ;

!
global
    lnk$gq_endtim 	: vector [2],			! END TIME IS THE TIME WE GET TO HERE
    lnk$gb_linespp 	: byte,				! NUMBER OF LINES PER PAGE
    lnk$gl_maxsymsz 	: initial (6),			! MAX LENGTH SYMBOL SEEN
    lnk$gl_maxmodsz 	: initial (9),			! MAX LENGTH MODULE SEEN
    lnk$al_sytblfmt 	: $crfctltable 			! DEFINE THE TABLE THAT DRIVES
				(keytype   = ascic	! THE CROSS REFERENCE TO PRODUCE
				,error     = crferror	! THE FORMATED SYMBOL TABLE
				,output    = lnk$crfout	! LISTING LINES
				,key1table = symbolfield  ! EACH ENTRY HERE IS A
				,key2table = spacefield	! POINTER TO THE FORMATS
	    			,val1table = valuefield
	    			,val2table = valueflags 
				,ref2table = referencer
				,ref1table = refnceflags
				),			
    lnk$al_valctltb 	: $crfctltable 			! DEFINE THE TABLE THAT DRIVES
				(keytype   = bin_u32 	! CREF TO PRODUCE THE CROSS
				,error     = crferror	! REFERENCE OF SYMBOLS
				,output    = lnk$crfout	! SORTED BY VALUE
				,key1table = valuefield
				,key2table = spacefield
				,val1table = spacefield 
				,val2table = spacefield
				,ref2table = symbolfield
				,ref1table = relsymval
				) ;


global routine lnk$mapinit : novalue = 		! ROUTINE TO INITIALIZE MAP FILE OUTPUT
!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE PERFORMS ALL INITIALIZATION NEEDED TO CREATE THE MAP FILE.
! IT OPENS THE MAP FILE, SETS UP THE PAGE COUNTER, LINE COUNTER, AND PERFORMS
! ANY NECESSARY TASKS DEPENDING ON THE MAP QUALIFIERS SPECIFIED BY THE USER.
! IT SETS UP THE MAP FILE PAGE HEADER AND OUTPUTS THE LINK-WIDE SUMMARY.
! AT THE PRESENT, IT IS USED TO DRIVE THE OTHER MAP ROUTINES, WHICH EVENTUALLY
! WILL BE CALLED BY THE LINKER ITSELF.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE TABLES CONTAINING THE LINKER DATA ARE ALREADY SET UP.
!
! IMPLICIT OUTPUTS:
!
!	THE MAP FILE IS OPENED FOR OUTPUT.
!	THE PAGE AND LINE NUMBERS ARE INTIALIZED.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
begin
local
	eblock 		: ref block [, byte],		! ERROR BLOCK POINTER
	saveblock,
	sympscadder,					! BLOCKS ESTIMATED FOR SYMS + PSECTS
	rmsstv,						! RMS STV CODE
	mapfab 		: block [fab$c_bln, byte];	! FILE ACCESS BLOCK - FOR OPEN AND CONNECT

bind
	imgauxfnb = lnk$gl_imgfil [fdb$t_auxfnb]	! REFERENCE THE IMAGE FILE'S AUXILIARY
			: block [nam$c_bln, byte];	! FILENAME BLOCK

auxfnb   = lnk$gl_mapfil [fdb$t_auxfnb];		! SET ADDRESS OF AUXILIARY FILENAME BLOCK
mapestim = 7 + .lnk$gw_nmodules/4;			! MINIMUM MAP ESTIMATE

if not .lnk$gl_ctlmsk [lnk$v_brief]			! IF NOT A BRIEF MAP
then begin						! MUST DO SOME MORE
     if .lnk$gl_ctlmsk [lnk$v_cros]			! IF A CROSS REFERENCE
     then mapestim = .mapestim + .lnk$gw_ncrosrfs/20;	! ADD IN AN ESTIMATE

     sympscadder   = .lnk$gw_npsects + .lnk$gw_nsymbols/16;	! COMPUTE SYMBOL + PSECTS COMPONENT
     mapestim      = (if .lnk$gl_ctlmsk [lnk$v_long]		! IF A LONG MAP
		      then (.mapestim + 2*.sympscadder)		! ADD IN DOUBLE THAT
		      else (.mapestim + .sympscadder) 		! ONE TIMES FOR DEFAULT FORM
		     )
     end;

$fab_init	(fab = mapfab				! INITIALIZE THE FAB
		,fac = put
		,rfm = var
		,rat = cr
		,fns = .lnk$gl_mapfil [fdb$w_usrnamlen]
		,fna = .lnk$gl_mapfil [fdb$l_usrnamadr]
		,dns = (if .lnk$gb_locnov_map
			then %charcount ('.MAP')
			else %charcount ('SYS$DISK:[].MAP')
		       )
		,dna = (if .lnk$gb_locnov_map
			then uplit (byte ('.MAP'))
			else uplit (byte ('SYS$DISK:[].MAP'))
		       )
		,nam = .auxfnb
		,alq = .mapestim
		);

if  .lnk$gb_locnov_map					! USE 'OUTPUT FILE PARSING' UNLESS
then mapfab [fab$v_ofp] = false				! /MAP WAS A LOCAL QUALIFIER
else mapfab [fab$v_ofp] = true ;			! WITHOUT A SPECIFED VALUE

maprab [rab$l_fab] = mapfab;				! THE RAB POINTS TO FAB FOR CONNECT
maprab [rab$b_mbc] = minu (.mapestim, max_k_rmsmbc);	! SET THE MULTI-BLOCK COUNT
auxfnb [nam$l_rlf] = .lnk$gl_relnam_map;		! SET RELATED NAM BLOCK ADDRESS

if not ($getjpi (itmlst=lnk$gt_jpilst);
	if  .lnk$gl_filesleft leq 3
	then lnk$closefile ();				! THEN CLOSE A FILE
	rmserror = $create (fab = mapfab);		!  AND TRY AGAIN
	rmsstv = .mapfab [fab$l_stv]; 
	.rmserror
       ) 
or not (rmserror = $connect (rab = maprab);		! CONNECT THE RAB AND
	rmsstv = .maprab [rab$l_stv]; 
	.rmserror
       )
then begin						! AND IF THERE IS AN ERROR
     signal (lin$_openout, 1, lnk$filnamdsc (mapfab) 	! REPORT THE ERROR
	    ,.rmserror, .rmsstv
	    );
     return;						! AND GIVE UP
     end;

mapifi = .mapfab [fab$w_ifi];				! SAVE INTERNAL IDENT FOR CLOSE
lnk$gl_ctlmsk [lnk$v_mapopn] = true;			! SET BIT FOR MAP FILE OPEN
ch$move (dsc$c_s_bln, lnk$filnamdsc (mapfab)		! SAVE AWAY REAL FILE NAME
	,lnk$gl_mapfil [fdb$q_filename]
	);
!
! SET UP THE DESCRIPTOR OF THE IMAGE FILE (IF ANY)
!
if .lnk$gl_imgfil neq 0					! PROVIDED AN IMAGE WAS SPECIFIED
then	begin
	imagefilename [0] = .lnk$gl_imgfil [fdb$w_usrnamlen];	! SET LENGTH OF FILE NAME
	imagefilename [1] = .lnk$gl_imgfil [fdb$l_usrnamadr];	! AND POINTER TO IT
	end;

!
! START MAP OUTPUT
!
lnk$gb_linespp = lib$lp_lines () - 8;			! GET NUMBER OF LINES PER PAGE
psectnameline  = 0;					! NO PSECTS YET
subhdline      = 0;					! INITIALIZE FOR NO SUB-HEADER GENERATION
pagenum        = 1;					! NEXT PAGE NUMBER

if not newpage () then return;				! OUTPUT FIRST PAGE AND HEADERS
if not mapbox (objmodhdr) then return;			! OUTPUT OBJECT MODULE SYNOPSIS HEADER

!
! IF THERE ARE ANY NON-MODULE ERRORS, DUMP THEM NOW
!
eblock = .lnk$gl_errlist;				! GET LIST POINTER

while .eblock neq 0					! WHILE THERE ARE MORE TO DO
do	begin
	lnk$mapout (eblock [oeb$t_text], .eblock [oeb$w_bytcnt]);	! DUMP THE MESSAGE
	saveblock = .eblock [oeb$l_nxtoeb];
	eblock    = .saveblock;
	end;

mapsubhdr (objmodsubhdr);			! OUTPUT OBJECT MODULE SUB-HEADER TITLE
return;
end;


routine trimfail (errcode) : novalue =
    begin
!
!	THIS ROUTINE IS CALLED FOR ANY FAILURE RETURN FROM LIB$TRIM_FILESPEC
!
    signal (lin$_faofail, 0, .errcode);		!& need new message
    return;
    end;

routine faofail (fao_errcode) : novalue =
    begin
!
!	THIS ROUTINE IS CALLED FOR ANY FAILURE RETURN FROM FAO
!
    signal (lin$_faofail, 0, .fao_errcode);
    return;
    end;

routine crferror (errorcode) : novalue =
    begin
!
!	THIS ROUTINE IS CALLED BY THE CROSS REFERENCE PROGRAM WHENEVER
!	IT INCURRS AN ERROR. THE ROUTINE MERELY PRINTS A DIAGNOSTIC MESSAGE
!
    signal (lin$_crferr, 0, .errorcode);	! OUTPUT DIAGNOSTIC
    return;
    end;

routine mapfail : novalue = 			! ROUTINE TO REPORT MAP I/O FAILURE

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE REPORTS A MAP I/O FAILURE, THEN CLOSES THE FILE CLEARING
! THE APPROPRIATE CONTROL BIT TO ENSURE NO MORE ATTEMPTS TO WRITE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	THE MAP FILE IS CLOSED FOR OUTPUT.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin
    lnk$gl_ctlmsk [lnk$v_mapopn] = false;	! TURN OFF MAP OPEN FLAG
    signal (lin$_writeerr, 1, 			! REPORT MAP I/O FAILURE
	lnk$gl_mapfil [fdb$q_filename], .rmserror, .maprab [rab$l_stv]);
    lnk$closmapfil ();				! THEN CLOSE THE FILE, IF POSSIBLE
    return;
    end;


global routine lnk$closmapfil : novalue =
!

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE CLOSES THE MAP FILE
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LNK$GL_MAPFIL = POINTER TO MAP FILE DESCRIPTOR BLOCK
!	AUXFNB        =   "      " AUXILIARY FILENAME BLOCK
!	MAPIFI        = INTERNAL FILE IDENTIFIER
!
! IMPLICIT OUTPUTS:
!
!	THE MAP FILE IS CLOSED FOR OUTPUT.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin

    local
	mapfab : block [fab$c_bln, byte],	! FAB FOR THE CLOSE
	closerror;				! ERROR CODE RETURNED BY RMS ON CLOSE

    if .mapifi neq 0				! IF THE MAP FILE IS STILL OPEN,
    then
	begin
	$fab_init (fab = mapfab, fop = tef);
	mapfab [fab$w_ifi] = .mapifi;		! INSERT THE SAVED FILE ID

	if (closerror = $wait (rab = maprab))	! WAIT FOR POSSIBLE ASYNCHRONOUS OUTPUT
	then
	    begin				! AND IF OK
	    lnk$gl_ctlmsk [lnk$v_mapopn] = false;	! TURN OFF THE CONTROL BIT

	    if (closerror = $close (fab = mapfab))	! ATTEMPT THE CLOSE AND IF IT
	    then
		begin				! SUCCEEDS
		mapifi = 0;			! WE ARE ALL DONE
		return;
		end;

	    end;				! BUT IF ANYTHING

	signal (lin$_closeout, 1, 		! FAILS, ISSUE THE ERROR MESSAGE BUT
	    lnk$gl_mapfil [fdb$q_filename], .closerror, .mapfab [fab$l_stv]);
	mapifi = 0;				! AND CLOSE IS COMPLETE
	end;

    return;
    end;


global routine lnk$mapmhd (objrec, objmoddsc) : novalue = 	! ROUTINE TO COLLECT MHD INFORMATION

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE EXTRACTS THE INFORMATION CONTAINED IN THE MODULE HEADER
! RECORD AND CREATES A PART OF AN OUTPUT LINE FOR THE OBJECT MODULE SYNOPSIS
! SECTION.  THE ROUTINE, LNK$MAPLNG, WILL INSERT THE LANGUAGE PROCESSOR
! INFORMATION AND ACTUALLY WRITE THE LINE.  THE INPUT PARAMETERS INCLUDE
! THE ADDRESSES OF THE MODULE HEADER RECORD AND THE OBJECT MODULE
! TABLE ENTRY.
!
! FORMAL PARAMETERS:
!
!	OBJREC    -- THE ADDRESS OF THE OBJECT MODULE HEADER RECORD
!			(SUB-HEADER BYTE)
!	OBJMODDSC -- THE ADDRESS OF THE OBJECT MODULE DESCRIPTOR
!
! IMPLICIT INPUTS:
!
!	THE NECESSARY LINKER TABLES MUST BE ALREADY SET UP.
!
! IMPLICIT OUTPUTS:
!
!	THE OUTPUT LINE IS BUILT SAVE FOR THE CREATOR DATA.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
begin
literal
    filnam_lng = 37 - 1 ;				! FILENAME OUTPUT FIELD SIZE

local
    cre8date,						! ADDRESS OF CREATION DATE
    fao_errcode,					! FAO ERROR CODE
    modident	: ref vector [, byte],			! REFERENCE TO MODULE IDENT
    filnam	: block [8,byte],			! FILE NAME DESCRIPTOR
    filnam_buf	: block [filnam_lng,byte] ;		! BUFFER FOR TRIMMED FILENAME

map
    objmoddsc	: ref block  [, byte],			! REFERENCE TO OBJ MOD DESCRIPTOR
    objrec	: ref vector [, byte] ;			! REFERENCE TO OBJECT MODULE HEADER RECORD

bind
    mhdrec    = .objrec		: block [, byte],	! NAME OBJECT RECORD AS MODULE HEADER RECORD
    objauxfnb = lnk$gl_curfil [fdb$t_auxfnb]  		! THE AUXILIARY FILENAME BLOCK OF CURRENT OBJ
				: block [nam$c_bln, byte] ;

!
lastomd    = .objmoddsc ;					! SAVE ADDRESS OF OBJ MODULE DESCRIPTOR
modident   = mhdrec [mhd$b_namlng] + .mhdrec [mhd$b_namlng] + 1 ; ! GET OFFSET TO VERSION
cre8date   = modident [0] + .modident [0] + 1	;		! GET OFFSET TO CREATION DATE
outdes [0] = len$c_mapline ;					! RESET OUTPUT BUFFER DESCRIPTOR
outdes [1] = outline ;						! POINT TO FIRST CHARACTER OF OUTPUT LINE


if .objauxfnb [nam$b_rsl] lequ filnam_lng
then
    !
    !   NO NEED TO TRIM FILE SPEC
    !
    begin
    filnam [dsc$w_length]  = .objauxfnb [nam$b_rsl] ;
    filnam [dsc$a_pointer] = .objauxfnb [nam$l_rsa] ;
    end 
else
    !
    !   TRIM FILE SPEC TO ALLOWABLE OUTPUT FIELD SIZE
    !
    begin
    local  	status,
		size,
		rs_nam : vector [2] ;

    rs_nam [0] = .objauxfnb [nam$b_rsl] ;
    rs_nam [1] = .objauxfnb [nam$l_rsa] ;

    filnam [dsc$w_length]  = filnam_lng ;
    filnam [dsc$b_dtype]   = dsc$k_dtype_t ;
    filnam [dsc$b_class]   = dsc$k_class_s ;
    filnam [dsc$a_pointer] = filnam_buf ;

    if (status = lib$trim_filespec (rs_nam, filnam, %ref (filnam_lng), size))
    then
	filnam [dsc$w_length] = .size
    else
	trimfail (.status) ;
    end ;

if .mhdrec [mhd$b_namlng] lequ sym$c_shortname		
then
    !
    !   MODULE HAS SHORT NAME
    !
    begin
    if .modident [0] lequ sym$c_shortname 
    then 
	begin
 	fao_errcode = 
	    sys$fao (objmd_cntrl_str, outsize, outdes
		    ,mhdrec [mhd$b_namlng]
		    ,modident [0]
		    ,.objmoddsc [omd$l_alloc]
		    ,.filnam [dsc$w_length], .filnam [dsc$a_pointer]
		    ,date_fld_lng, .cre8date
		    ) 
	end
    else
	begin
	if (fao_errcode = sys$fao (objmd_cntrl_st1, outsize, outdes, mhdrec [mhd$b_namlng]))
	then
	    begin
	    lnk$mapout (outline, .outsize) ;
	    outdes [0] = len$c_mapline ;
	    outdes [1] = outline ;
	    fao_errcode =
		sys$fao (objmd_cntrl_st2, outsize, outdes
			,modident [0]
			,.objmoddsc [omd$l_alloc]
			,.filnam [dsc$w_length], .filnam [dsc$a_pointer]
			,date_fld_lng, .cre8date
			)
	    end ;
	end ;
    end
else
    !
    !   MODULE HAS LONG NAME
    !
    begin
    if (fao_errcode = sys$fao (objmd_cntrl_st1, outsize, outdes, mhdrec [mhd$b_namlng]))
    then
	begin
	lnk$mapout (outline, .outsize) ;			! OUTPUT MODULE NAME
	outdes [0] = len$c_mapline ;				! RESET
	outdes [1] = outline ;

	if .modident [0] lequ sym$c_shortname 
	then 
	    fao_errcode = 
		sys$fao (objmd_cntrl_str, outsize, outdes
			,blanks
			,modident [0]
			,.objmoddsc [omd$l_alloc]
			,.filnam [dsc$w_length], .filnam [dsc$a_pointer]
			,date_fld_lng, .cre8date
			) 
	else 
	    fao_errcode = 
		sys$fao (objmd_cntrl_st2, outsize, outdes
			,modident [0]
			,.objmoddsc [omd$l_alloc]
			,.filnam [dsc$w_length], .filnam [dsc$a_pointer]
			,date_fld_lng, .cre8date
			)
	end ;
    end ;

if not .fao_errcode
then
    faofail (.fao_errcode)
else
    begin
    outdes [1] = outline + .outsize ;				! POINT TO CREATOR FIELD
    outdes [0] = .outdes [0] - .outsize ;
    end ;
end ;


global routine lnk$maplng (langaddr, langlen) : novalue = 	! ROUTINE TO OUTPUT LANGUAGE PROCESSOR DATA

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE TAKES INFORMATION FROM THE LANGUAGE PROCESSOR SUB-HEADER
! RECORD AND INSERTS IT INTO THE OBJECT MODULE OUTPUT LINE.  THIS OUTPUT
! LINE IS THEN WRITTEN TO THE MAP.
!
! FORMAL PARAMETERS:
!
!	LANGADDR -- ADDRESS OF THE LANGUAGE PROCESSOR NAME STRING
!	LANGLEN -- LENGTH OF THE LANGUAGE PROCESSOR NAME STRING
!
!
! IMPLICIT INPUTS:
!
!	THE MAIN BODY OF THE OBJECT MODULE OUTPUT LINE IS ALREADY BUILT.
!
! IMPLICIT OUTPUTS:
!
!	THE OBJECT MODULE OUTPUT LINE IS WRITTEN TO THE MAP FILE.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	THE LANGUAGE NAME WILL BE TRUNCATED TO THE MAXIMUM ALLOWED LENGTH
!		AS DEFINED BY "LEN$C_LNGNAM"
!
!--
    begin

    local
	eblock : ref block [, byte],		! POINTER TO ERROR TEXT BLOCK
	nextblock : ref block [, byte],		! TEMPORARY POINTER
	fao_errcode;				! FAO ERROR CODE

    if not (fao_errcode = sys$fao (creat_cntrl_str, outsize, outdes, 	! FORMAT LINE
	    min (len$c_lngnam, .langlen), .langaddr))	! TRUNCATING TO MAXIMUM ALLOWED LENGTH
    then
	faofail (.fao_errcode);			! FAO FAILURE

    outsize = .outsize + .outdes [1] - outline;	! CALCULATE TOTAL LINE SIZE
    lnk$mapout (outline, .outsize);		! OUTPUT LINE
    outdes [0] = len$c_mapline;			! RESET THE OUTPUT BUFFER DESCRIPTOR
    outdes [1] = outline;			! FOR NEXT USAGE
!
! IF THERE IS ANY ERROR TEXT STASHED AWAY TO PRINT NOW, THEN DO IT
!
    if (eblock = .lastomd [omd$l_errtxt]) neq 0	! IF THERE IS TEXT TO PRINT
    then

	while .eblock neq 0			! THEN PRINT IT ALL
	do
	    begin
	    lnk$mapout (eblock [oeb$t_text], .eblock [oeb$w_bytcnt]);	! PRINT A MESSAGE
	    nextblock = .eblock [oeb$l_nxtoeb];	! GET ADDRESS OF NEXT TEXT BLOCK
	    eblock = .nextblock;		! AND GO AGAIN
	    end;

    lastomd [omd$l_errtxt] = 0;			! CLEAR ERRTXT FIELD (USED AS NXTADR DURING PASS 2)
    lastomd [omd$l_lsterr] = 0;			! CLEAR LSTERR FIELD (WHICH IS ALSO ADRCNT DURING PASS 2)
    return;					! NO MORE TO DO
    end;


global routine lnk$mapadromd : novalue =
    begin

!++
! THIS ROUTINE PRINTS THE OBJECT MODULE ADDRESS DATA SYNOPSIS.
! IT IS ONLY PRINTED IF CREATING A SHAREABLE IMAGE AND A FULL
! MAP HAS BEEN GENERATED.
!
!--
    local
	desc : block [dsc$c_s_bln, byte],
	status,
	outlen,
	omdnum,
	omdptr : ref block [, byte];

!
! IF NOTHING TO PRINT THEN RETURN
!
    if .lnk$gl_nadromd eql 0 then return;

!
! PRINT A BLANK LINE, FOLLOWED BY THE BOXED HEADER, AND
! THEN THE SUB-HEADER
!

    if .linecnt + 10 gtr .lnk$gb_linespp	! ENSURE ROOM FOR HEADER, SUBHEADER AND FIRST LINE OF TEXT
    then
	begin
	linecnt = .lnk$gb_linespp;

	if not lnk$mapout (outline, 0) then return;

	end;

    if not newline () or not mapbox (omdadrhdr) or not mapsubhdr (omdadrsubhdr) then return;
!
! OUTPUT THE INFO
!
    omdnum = 0;
    outlen = 0;
    ch$move (dsc$c_s_bln, outdes, desc);
    omdptr = .lnk$gl_omdadrlst;

    while .omdptr neq 0 do
	begin

	if not (status = sys$fao (omdadrstr, outlen, desc, omdptr [omd$b_namlng], .omdptr [omd$l_adrcnt]))
	then
	    faofail (.status);

	desc [dsc$w_length] = .desc [dsc$w_length] - .outlen;
	desc [dsc$a_pointer] = .desc [dsc$a_pointer] + .outlen;
	omdnum = .omdnum + 1;

	if .omdnum eql 3			! IF 3 ON LINE, OUTPUT AND RESET
	then
	    begin

	    if not lnk$mapout (outline, len$c_mapline - .desc [dsc$w_length]) then return;

	    omdnum = 0;
	    ch$move (dsc$c_s_bln, outdes, desc);
	    end;

	omdptr = .omdptr [omd$l_nxtadr];
	end;

    if .omdnum neq 0 then lnk$mapout (outline, len$c_mapline - .desc [dsc$w_length]);

    return;
    end;


global routine lnk$mappscts : novalue = 	! ROUTINE TO OUTPUT PSECT SYNOPSIS

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE PSECT TABLES MUST HAVE ALREADY BEEN COMPLETED.
!	THE OBJECT MODULE TABLES AND THE CURRENT FILE DESCRIPTOR MUST
!	BE AVAILABLE.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
begin
	routine print_psect (node) =
	!
	! ROUTINE CALLED TO PRINT ONE PSECT
	!
	begin
	map	node : ref block [, byte];

	bind	psectaddr = .node [node$l_ptr] : block [, byte];

	local	psctcontr	: ref block [, byte],
		psctowner	: ref block [, byte],
		psectnamebuf	: block [len$c_mapline, byte],	! BUFFER FOR LAST PSECT SUMMARY LINE
		fao_errcode,					! FAO ERROR CODE
		psectoffset,					! MODULE CONTR BASE ADDR
		psectend,					! END ADDRESS OF PSECT
		psectbase;					! BASE ADDRESS OF PSECT

	!
	! OUTPUT PSECT SECTION LINES TO MAP.
	!
	if  (.psectaddr [psc$w_flags] and gps$m_rel) neq 0	! PROVIDED THAT IT IS RELOCATABLE
	and (.psectaddr [psc$w_flags] and (gps$m_lib or psc$m_supres))	! AND NOT FROM SHR LIB
	    	neq (gps$m_lib or psc$m_supres)			! SPECIALLY DEFINED PSECT
	and (if .lnk$gl_ctlmsk [lnk$v_long]			! PROVIDED IT IS LONG MAP
	     then (if newline () 				! OUTPUT A NEW LINE
		   then true
		   else return false	
		  ) 
	     else   if not .psectaddr [psc$v_supres]		! OR THE P-SECTION
		       and .psectaddr [psc$l_length] neq 0	! IS NOT EMPTY AND 
		   then true					! IS NOT SUPPRESSD
		   else false
	    )
	 then
	    begin
	    psectnameline = 0;					! ZERO IN CASE OF NEW PAGE
	    psectbase     = .psectaddr [psc$l_base];		! REMEMBER BASE ADDR
	    psectend      = .psectbase + .psectaddr [psc$l_length]; ! CALCULATE END ADDR

	    if (.psectaddr [psc$l_length] neq 0) 
	    then psectend = .psectend - 1;			! CALCULATE END ADDR

	    alignment = (case .psectaddr [psc$b_align] 		! FIND ALIGNMENT ASCIC 
			  from 0 to 9 of 			! STRING ADDRESS
				set
				[0]	 : alignbyte;		! BYTE ALIGNED
				[1]	 : alignword;		! WORD ALIGNED
				[2]	 : alignlong;		! LONGWORD ALIGNED
				[3]	 : alignquad;		! QUAD WORD ALIGNED
				[4 to 8] : align2;		! OTHER ALIGNED
				[9]	 : alignpage;		! PAGE ALIGNED
				tes
			   );					! GOT ALIGNMENT

	    args [0] = (if (.psectaddr [psc$w_flags] and gps$m_pic) eql 0	! DECIDE IF PSECT IS
	    		then nopic					! NOT POSITION INDEPENDENT,
			else pic);					! OR IS POSITION INDEPENDENT
	    args [1] = (if (.psectaddr [psc$w_flags] and gps$m_lib) eql 0	! DECIDE IF PSECT IS
			then usr					! DEFINED BY THE USER
			else lib);					! OR FROM A LIBRARY
	    args [2] = (if (.psectaddr [psc$w_flags] and gps$m_ovr) eql 0	! DECIDE IF PSECT IS
			then con					! CONCATENATED
			else ovr);					! OR OVERLAID
	    args [3] = (if (.psectaddr [psc$w_flags] and gps$m_rel) eql 0	! DECIDE IF PSECT IS
			then abs					! ABSOLUTE
			else rel);					! OR RELOCATABLE
	    args [4] = (if (.psectaddr [psc$w_flags] and gps$m_gbl) eql 0	! DECIDE IF PSECT IS
			then lcl					! LOCALLY DEFINED
			else gbl);					! OR GLOBALLY DEFINED
	    args [5] = (if (.psectaddr [psc$w_flags] and gps$m_shr) eql 0	! DECIDE IF PSECT IS
			then noshr					! NOT SHAREABLE
			else shr);					! OR IS SHAREABLE
	    args [6] = (if (.psectaddr [psc$w_flags] and gps$m_exe) eql 0	! DECIDE IF PSECT IS
			then noexe					! NOT EXECUTABLE
			else exe);					! OR IS EXECUTABLE
	    args [7] = (if (.psectaddr [psc$w_flags] and gps$m_rd) eql 0	! DECIDE IF PSECT IS
			then nord					! NOT READABLE
			else rd);					! OR IS READABLE
	    args [8] = (if (.psectaddr [psc$w_flags] and gps$m_wrt) eql 0	! DECIDE IF PSECT IS
			then nowrt					! NOT WRITEABLE
			else wrt);					! OR IS WRITEABLE
	    args [9] = (if (.psectaddr [psc$w_flags] and gps$m_vec) eql 0	!
			then novec 
			else vec);

	    if not (fao_errcode = 				! FORMAT THE PSECT SUMMARY ALLOCATION LINE
			(if .psectaddr [psc$b_namlng] lequ sym$c_shortname 
			 then  sys$fao	( psc_cntrl_str, outsize, outdes
					, psectaddr [psc$b_namlng], blanks, .psectaddr [psc$l_base], .psectend
					,.psectaddr [psc$l_length], .psectaddr [psc$l_length], .alignment
					,.psectaddr [psc$b_align], .args [0], .args [1], .args [2]
					,.args [3], .args [4], .args [5], .args [6], .args [7], .args [8]
					,.args [9]
					) 
			 else sys$fao	( psc_cntrl_st1, outsize, outdes
					, psectaddr [psc$b_namlng], .psectaddr [psc$l_base], .psectend
					,.psectaddr [psc$l_length], .psectaddr [psc$l_length], .alignment
					,.psectaddr [psc$b_align], .args [0], .args [1], .args [2]
					,.args [3], .args [4], .args [5], .args [6], .args [7], .args [8]
					,.args [9]
		    )   )    		)
	    then
		faofail (.fao_errcode)
	    else
		if not lnk$mapout (outline, .outsize)			! OUTPUT THE PSECT ALLOCATION SUMMARY LINE
		then					
		    return false;					! NO MORE OUTPUT, I/O FAILURE

	    ch$copy (.outsize, outline, %ascii' ', len$c_mapline, psectnamebuf);
									! COPY PSECT SUMMARY LINE TO BUFFER
	    psectnameline =  psectnamebuf;				! AND FLAG WE HAVE ONE
	    psctcontr     = .psectaddr [psc$l_mpclst];			! GET THE FIRST CONTRIBUTING OBJECT MODULE

	    while (.psctcontr neq 0) do 				! LOOP ONCE FOR EACH CONTRIBUTOR
		begin
		psectoffset = .psectbase   + .psctcontr [mpc$l_offset];	! CALCULATE BASE OF THIS CONTRIBUTION
		psectend    = .psectoffset + .psctcontr [mpc$l_length];	! CALCULATE END OF THIS CONTRIBUTION

		if (.psctcontr [mpc$l_length] neq 0) 
		then psectend = .psectend - 1;				! CALCULATE END ADDRESS

		alignment = (case .psctcontr [mpc$b_align] 
			      from 0 to 9 of				! FIND ALIGNMENT OF THIS CONTRIBUTION
				set
				[0]	 : alignbyte;		! BYTE ALIGNED
				[1]	 : alignword;		! WORD ALIGNED
				[2]	 : alignlong;		! LONGWORD ALIGNED
				[3]	 : alignquad;		! QUADWORD ALIGNED
				[4 to 8] : align2;		! OTHER ALIGNED
				[9]	 : alignpage;		! PAGE ALIGNED
				tes				! GOT ALIGNMENT
			     );
		psctowner = .psctcontr [mpc$l_ownomd];		! FIND OBJ MOD NAME

		if .lnk$gl_ctlmsk [lnk$v_long]			! IF A FULL MAP
		or (((.psctcontr [mpc$l_length] neq 0))		! OR A NON ZERO CONTRIBUTION
		     and 					! FROM A MAPPED MODULE IN
		    ((.psctowner [omd$b_flags] and omd$m_mapmod)) neq 0	  ! A DEFAULT MAP
		   )
		then
		    begin					! OUTPUT THE CONTRIBUTION LINE
		    if .psctowner [omd$b_namlng] lequ sym$c_shortname 
		    then fao_errcode = 	sys$fao	( contrbstr, outsize, outdes
						, blanks, psctowner [omd$b_namlng]
						,.psectoffset, .psectend
						,.psctcontr [mpc$l_length],.psctcontr [mpc$l_length]
						,.alignment, .psctcontr [mpc$b_align]
						) 
		    else fao_errcode = sys$fao	( contrbst2, outsize, outdes
						, blanks, psctowner [omd$b_namlng]
						) ;

		    if not .fao_errcode
		    then faofail (.fao_errcode)
		    else if not lnk$mapout (outline, .outsize)	! OUTPUT CONTRIBUTING MODULE LINE
			 then return false;			! NO MORE OUTPUT, I/O FAILURE

		    if .psctowner [omd$b_namlng] gtru sym$c_shortname 	! IF NOT SHORTNAME
		    then begin						! THEN OUTPUT REMAINDER
			 fao_errcode = sys$fao	( contrbst3, outsize, outdes
						, blanks
						,.psectoffset, .psectend, .psctcontr [mpc$l_length]
						,.psctcontr [mpc$l_length], .alignment
						,.psctcontr [mpc$b_align]
			 			) ;
			 if not .fao_errcode
			 then faofail (.fao_errcode)
			 else 	if not lnk$mapout (outline, .outsize)	! OUTPUT CONTRIBUTING MODULE LINE
			 	then return false;			! NO MORE OUTPUT, I/O FAILURE
			 end ;
		    end;

		psctcontr = .psctcontr [mpc$l_nxtmpc];		! GET NEXT CONTRIBUTING MODULE
		end;						! END THE CONTRIBUTOR LOOP

	    psectnameline = 0;					! ENSURE NO LINE PRINTED
	    end;
	return true
	end;

!
! MAIN BODY OF LNK$MAPPSCTS
!
! START ROUTINE OUTPUT.
!

if .lnk$gl_ctlmsk [lnk$v_brief]				! MORE THAN A BRIEF MAP?
then return;						! NO, RETURN

subhdline = 0;						! INITIALIZE SUBHEADER ADDR

if .lnk$gl_ctlmsk [lnk$v_long]				! IF A FULL MAP
then (if not newpage () then return )			! OUTPUT NEW PAGE AND HEADER
else (if not newline () then return );			! OTHERWISE JUST A NEW LINE

if not mapbox (psecthdr)				! OUTPUT PSECT HEADER
then return;

if not mapsubhdr (psectsubhdr)				! OUTPUT PSECT SUB-HEADER
then return;

lib$traverse_tree (lnk$gl_maplst, print_psect);		! TRAVERSE TREE TO PRINT PSECTS
return true

end;							! OF LNK$MAPPSCTS


global routine lnk$mapsyms : novalue = 		! ROUTINE TO OUTPUT SYMBOL INFORMATION

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS ANY SYNOPSIS OF GLOBAL SYMBOLS REQUESTED BY
!	THE USER, INCLUDING THE CROSS REFERENCE SUMMARY.  IT THEN CLOSES
!	THE MAP FILE AND SPOOLS IT (IF SO REQUESTED).
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ALL GLOBAL SYMBOLS MUST HAVE BEEN PREVIOUSLY RELOCATED AND SENT
!	TO THE CROSS REFERENCE PROGRAM FOR STORAGE.
!
! IMPLICIT OUTPUTS:
!
!	THIS ROUTINE OUTPUTS THE GLOBAL SYMBOL SYNOPSES, BASED ON THE USER
!	SPECIFIED MAP QUALIFIERS.  THESE INCLUDE THE GLOBAL SYNOPSIS ORDERED
!	BY NAME AND BY VALUE AND THE CROSS REFERENCE SUMMARY.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin

    local
	crfsubhdr1 : block [len$c_mapline, byte],
	crfsubhdr2 : block [len$c_mapline, byte],
	desc : ref block [, byte],
	errorcode,				! LOCAL ERROR CODE
	linespage1,				! NUMBER OF LINES ON FIRST PAGE
	string_ptr,				! PTR TO SUBHDR FAO STRING
	crefmode;				! NUMBER OF SYMBOLS ACROSS PAGE IS DEFINED

    						! BY THE MODE
!
    psectnameline = 0;				! ENSURE NO PSECT SUMMARY PRINTED

    if not .lnk$gl_ctlmsk [lnk$v_brief]		! MORE THAN A BRIEF MAP?
    then
	begin					! YES, THEN PROCEED, ELSE SKIP
	subhdline = 0;				! NO SUB HEADER FOR NEW PAGE YET

	if .lnk$gl_ctlmsk [lnk$v_long]		! IF A FULL MAP
	then
	    (if not newpage () then return )	! GIVE UP IF FAIL TO GET NEW PAGE
	else
	    (if not newline () then return );	! OR NEW LINE IF NOT FULL MAP

	if .lnk$gl_ctlmsk [lnk$v_cros]		! PICK THE SYMBOL TABLE HEADING
	then
	    begin

	    if not mapbox (symbolcref) then return;	! FOR CROSS REFERENCED OR NOT

!
! CREATE THE FAO CONTROL STRINGS FOR CREF SUB HEADER
!
	    crfsubhdr [dsc$w_length] = len$c_mapline;
	    crfsubhdr [dsc$a_pointer] = crfsubhdr1;
	    sys$fao (fao_crefsubhd, crfsubhdr, crfsubhdr, .lnk$gl_maxsymsz + 1, crfsubhd1,
		.lnk$gl_maxmodsz + 6, crfsubhd2);
	    desc = crfsubhdr + dsc$c_s_bln;
	    desc [dsc$w_length] = len$c_mapline;
	    desc [dsc$a_pointer] = crfsubhdr2;
	    sys$fao (fao_crefsubhd, .desc, .desc, .lnk$gl_maxsymsz + 1, crfsubhd3, .lnk$gl_maxmodsz + 6,
		crfsubhd4);
	    sys$fao (fao_cre1, fao_symdesc, fao_symdesc, .lnk$gl_maxsymsz);
	    sys$fao (fao_cre1, fao_modesc, fao_modesc, .lnk$gl_maxmodsz + 1);
	    symbolfield [fld$b_maxlng] = .lnk$gl_maxsymsz;
	    referencer [fld$b_maxlng] = .lnk$gl_maxmodsz + 1;
	    ch$move (dsc$c_s_bln, fao_symdesc, symbolfield [fld$b_faodsc]);
	    ch$move (dsc$c_s_bln, fao_modesc, referencer [fld$b_faodsc]);

	    if not mapsubhdr (crfsubhdr) then return;

	    crefmode = crf$k_defs_refs;		! FULL CROSS REFERENCE
	    end
	else
	    begin

	    if not mapbox (symbyname) then return;	! GIVE UP IF FAIL TO OUTPUT THE BOXED HEADING

	    string_ptr = symsubhdr;		! ASSUME SHORT SYMBOLS
	    desc = sym$c_shortname;

	    if .lnk$gl_maxsymsz gtr sym$c_shortname
	    then
		begin
		string_ptr = symlngsubhdr;
		desc = sym$c_maxlng;
		end;

	    sys$fao (fao_cre1, fao_symdesc, fao_symdesc, .desc);
	    ch$move (dsc$c_s_bln, fao_symdesc, symbolfield [fld$b_faodsc]);
	    symbolfield [fld$b_maxlng] = .desc;

	    if not mapsubhdr (.string_ptr) then return;

	    crefmode = crf$k_values;		! JUST WANT THE KEYS AND VALUES
	    end;

	linespage1 = .lnk$gb_linespp - .linecnt;	! SET NUMBER OF LINES ON FIRST PAGE

	if not (errorcode = crf$out (lnk$al_sytblfmt, len$c_mapline, 	! CALL CRF TO DO THE WORK
		.linespage1, .lnk$gb_linespp - 6, .crefmode, crf$k_save))
	then
	    signal (lin$_crferr, 0, .errorcode);

!
!	NOW FOR SYMBOLS BY VALUE IF REQUESTED
!
	if .lnk$gl_ctlmsk [lnk$v_long]		! WANT A LONG MAP?
	then
	    begin				! YES, ADD THE VALUE CROSS REFERENCE
	    sys$fao (fao_cre1, fao_symdesc, fao_symdesc, .lnk$gl_maxsymsz);
	    ch$move (dsc$c_s_bln, fao_symdesc, symbolfield [fld$b_faodsc]);
	    symbolfield [fld$b_maxlng] = .lnk$gl_maxsymsz;
	    subhdline = 0;			! NO SUBHEADING YET

	    if not newpage () then return;	! GIVE UP IF NO NEW PAGE

	    if not mapbox (symbyvalue) then return;	! GIVE UP ON FAILURE TO OUTPUT THE BOX HEADING

	    if not mapsubhdr (valsubhdr) then return;	! OR THE TABLE HEADING

	    linespage1 = .lnk$gb_linespp - .linecnt;	! SET NUMBER OF LINES ON FIRST PAGE

	    if not (errorcode = crf$out (lnk$al_valctltb, 	! AND CALL CRF TO DO
		    len$c_mapline, .linespage1, 	! ITS THING
		    .lnk$gb_linespp - 3, crf$k_vals_refs, 	! AND SAVE THE TABLE
		    crf$k_save))
	    then
		signal (lin$_crferr, 0, .errorcode);

	    end;

	if .linecnt + 10 gtr .lnk$gb_linespp	! ENSURE ROOM FOR KEY TO SPECIAL CHARS LINE
	then
	    begin
	    linecnt = .lnk$gb_linespp;		! FORCE A NEW PAGE

	    if not lnk$mapout (outline, 0) then return;

	    end;

	incru i from 1 to 3 do

	    if not lnk$mapout (outline, 0)	! SKIP 3 LINES
	    then
		return;

	if not lnk$mapout (chardef_str [1], .chardef_str [0]) then return;

	if not (errorcode = $fao (abbrvtbl1_str, outsize, outdes))
	then
	    faofail (.errorcode)
	else

	    if not lnk$mapout (outline, .outsize) then return;

	incru i from 0 to 3 do
	    begin

	    if not (errorcode = $fao (abbrvtbl2_str, outsize, outdes, .str_pointer [.i]))
	    then
		faofail (.errorcode)
	    else

		if not lnk$mapout (outline, .outsize) then return;

	    end;

	if not (errorcode = $fao (abbrvtbl1_str, outsize, outdes))
	then
	    faofail (.errorcode)
	else

	    if not lnk$mapout (outline, .outsize) then return;

	end;

    return;
    end;


global routine lnk$mapiscts : novalue = 	! ROUTINE TO OUTPUT IMAGE SECTION INFORMATION
    begin

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS THE IMAGE SECTION SYNOPSIS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE IMAGE SECTION DESCRIPTOR LIST - HEAD IS LNK$GL_ISDLST
!	AND THE IMAGE FILE DESCRIPTOR BLOCK.
!
! IMPLICIT OUTPUTS:
!
!	THIS ROUTINE OUTPUTS THE IMAGE SECTION SYNOPSIS.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    local
	fao_errcode,				! FAO ERROR CODE
	match_str,				! POINTER TO MATCH CONTROL STRING
	fao_ctl_str,				! POINTER TO FAO CONTROL STRING
	nextisd : ref block [, byte],		! ISECT DESCRIPTOR BLOCK
	cluster : ref vector [, byte],		! ADDRESS OF CLUSTER NAME STRING
	proprefix,				! ADDRESS OF "P-" OR BLANKS
	relsfx,					! ADDRESS OF "-R" OR BLANKS
	diskvbn,				! DISK VBN OF ISECTION
	protect,				! ADDRESS OF PROTECTION STRING
	otheratribs1,				! FOR ADDITIONAL ATTRIBUTES
	otheratribs2,
	baseva;					! BASE VIRTUAL PAGE NUMBER

!

    bind
	imgauxfnb = lnk$gl_imgfil [fdb$t_auxfnb]	! REFERENCE THE IMAGE FILE'S AUXILIARY
	: block [nam$c_bln, byte];		! FILENAME BLOCK

!
! RE-SET UP THE DESCRIPTOR OF THE IMAGE FILE (IF ANY), BECAUSE
!	IT IS PROBABLY CREATED NOW.
!

    if .lnk$gl_imgfil neq 0			! PROVIDED AN IMAGE WAS SPECIFIED
	and .lnk$gl_ctlmsk [lnk$v_image]	! AND SUCCESSFULLY CREATED
    then
	begin
	imagefilename [0] = .imgauxfnb [nam$b_rsl];	! SET LENGTH OF RESULTANT FILE NAME
	imagefilename [1] = .imgauxfnb [nam$l_rsa];	! AND POINTER TO IT
	end;

    if not .lnk$gl_ctlmsk [lnk$v_long]		! IF A LONG MAP
	or .lnk$gw_nisects eql 0		! AND SOME IMAGE SECTIONS
    then
	return;					! NO, RETURN

    subhdline = 0;				! RESET HEADER LINE

    if not newpage ()				! GIVE UP IF FAIL TO GET NEW PAGE
    then
	return;

    if not mapbox (imagesections)		! AND IF THE BOX HEADING FAILS
    then
	return;

    if not mapsubhdr (isdsubhdr, isdtxt)	! DITTO FOR ISECTIION SUBHEADER
    then
	return;

    lnk$gl_curclu = lnk$gl_clulst;		! START AT TOP OF CLUSTER LIST

    while (lnk$gl_curclu = .lnk$gl_curclu [clu$l_nxtclu]) neq 0	! GET NEXT CLUSTER DESCRIPTOR
    do
	begin

	if not newline ()			! OUTPUT A BLANK LINE
	then
	    return;

	if not .lnk$gl_curclu [clu$v_based]	! IF CLUSTER IS NOT BASED
	    and (.lnk$gl_curclu [clu$v_shrimg]	!  AND IS FROM A SHAREABLE IMAGE
	    or .lnk$gl_ctlmsk [lnk$v_shr])	!  OR WE ARE CREATING A SHAREABLE IMAGE
	then
	    relsfx = hyphen_r			! THEN FLAG THAT IN MAP
	else
	    relsfx = blanks;			! OTHERWISE USE BLANKS

	cluster = lnk$gl_curclu [clu$b_namlng];	! SET ITS NAME POINTER
	nextisd = lnk$gl_curclu [clu$l_fstisd];	! GO DOWN LIST OF DESCRIPTORS

	while (nextisd = .nextisd [isl$l_nxtisd]) neq 0	! TILL ZERO TERMINATED END
	do
	    begin

	    bind
		isectdesc = nextisd [isl$t_hdrisd] : block [, byte];	! POINT TO THE HEADER PART

	    if .isectdesc [isd$w_pagcnt] neq 0	! IF NON-NULL ISECT
		or .isectdesc [isd$b_type] eql isd$k_usrstack	!  OR THE STACK ISECT
	    then
		begin
		fao_ctl_str = ch$ptr (isect_cntrl_str, 0);	! ASSUME ISECT IS NOT GLOBAL
		baseva = .isectdesc [isd$v_vpg]^9;	! GET BASE VIRTUAL ADDRESS
		proprefix = blanks;		! ASSUME ISECT NOT PROTECTED

		if .isectdesc [isd$v_protect]	! IF IT IS PROTECTED
		then
		    proprefix = p_hyphen;	!  THEN TELL THAT

		if .isectdesc [isd$v_dzro]	! IF A DEMAND ZERO IMAGE SECTION
		then
		    begin			! THERE IS NO DISK SPACE ALLOCATED
		    diskvbn = 0;		! SO ZERO THE VBN
		    otheratribs1 = demandzero;	! AND SET THE DESCRIPTIONSTRING
		    end
		else
		    begin
		    diskvbn = .isectdesc [isd$l_vbn];	! GET BASE VBN ON DISK
		    otheratribs1 = blanks;
		    end;

		if .isectdesc [isd$v_wrt]	! IF THE SECTION IS WRITABLE
		then
		    protect = readwrite		! THEN SAY SO
		else
		    protect = readonly;		! OTHERWISE TELL THEM READ ONLY

		if .nextisd eql .lnk$gl_fixisd	!  IF IT'S THE FIXUP SECTION
		    or (.nextisd eql .lnk$gl_curclu [clu$l_fixisd])
						!  OR THE FIXUP SECTION IN ANOTHER IMAGE
		then
		    otheratribs2 = fixupsection
		else

		    if .isectdesc [isd$v_crf]	! IF COPY ON REFERENCE
		    then
			otheratribs2 = (if not .nextisd [isl$v_reprot]	! THEN SAY COPY ON REF
			then copyonref else addrdata)	! UNLESS IT HAS .ADDRESS DATA IN IT
		    else
			otheratribs2 = blanks;	! ELSE SAY NOTHING

		if .isectdesc [isd$v_gbl]
		then
		    begin
		    fao_ctl_str = ch$ptr (gblis_cntrl_str, 0);	! USE GLOBAL ISECT FAO CONTROL STRING
		    match_str = (selectone .isectdesc [isd$v_matchctl] of
			set
			[isd$k_matall] : alltime;	! SELECT MATCH = ALWAYS
			[isd$k_matnev] : never;	! SELECT MATCH = NEVER
			[isd$k_matequ] : equal;	! SELECT MATCH = EQUAL
			[isd$k_matleq] : lssequal;	! SELECT MATCH = LESS/EQUAL
			[otherwise] : blanks;	! NO MATCH SET
			tes);
		    end;

		begin

		bind
		    gsmajid = .(isectdesc [isd$l_ident])<24, 8, 0>,	! GLOB SEC MAJOR ID
		    gsminid = .(isectdesc [isd$l_ident])<0, 24, 0>;	! GLOB SEC MINOR ID

		if .cluster [0] gtru 16		! IF CLUSTER NAME IS LONG
		then
		    begin

		    if not (fao_errcode = sys$fao (objmd_cntrl_st1, 	! PUT CLUSTER NAME ON SEPARATE LINE
			    outsize, outdes, .cluster))
		    then
			faofail (.fao_errcode)
		    else

			if not lnk$mapout (outline, .outsize) then return;

		    cluster = blanks;		! THEN SET CLUSTER NAME TO BLANKS
		    end;

		if not (fao_errcode = sys$fao (.fao_ctl_str, outsize, outdes, .cluster,
						! GO FORMAT THE LINE
			.isectdesc [isd$b_type], .isectdesc [isd$w_pagcnt], .proprefix, .baseva, .relsfx,
			.diskvbn, .isectdesc [isd$b_pfc], .protect, .otheratribs1, .otheratribs2,
			isectdesc [isd$t_gblnam], .match_str, gsmajid, gsminid))
		then
		    faofail (.fao_errcode)	! AND REPORT ANY ERROR
		else

		    if not lnk$mapout (outline, .outsize)	! OUTPUT THE LINE
		    then
			return;			! AND GIVE UP ON FAILURE

		end;
		cluster = blanks;		! SET CLUSTER NAME TO BLANKS FOR REST OF ISECTS
		end;
	    end;
	end;
!
! PRINT KEY TO SPECIAL CHARACTERS
!

    if .linecnt + 8 gtr .lnk$gb_linespp		! ENSURE ROOM FOR KEY TO SPECIAL CHARS LINE
    then
	begin
	linecnt = .lnk$gb_linespp;		! FORCE A NEW PAGE

	if not lnk$mapout (outline, 0) then return;

	end;

    incru i from 1 to 3 do

	if not lnk$mapout (outline, 0)		! SKIP 3 LINES
	then
	    return;

    if not lnk$mapout (chardef_str [1], .chardef_str [0]) then return;

    if not (fao_errcode = $fao (abbrvtbl1_str, outsize, outdes))
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize) then return;

    incru i from 0 to 1 do
	begin

	if not (fao_errcode = $fao (abbrvtbl2_str, outsize, outdes, .istr_pointer [.i]))
	then
	    faofail (.fao_errcode)
	else

	    if not lnk$mapout (outline, .outsize) then return;

	end;

    if not (fao_errcode = $fao (abbrvtbl1_str, outsize, outdes))
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize) then return;

    return;					! AND ALL DONE
    end;


global routine lnk$mapstats : novalue = 	! RUN TIME STATISTICS
    begin

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE GATHERS SOME STATISTICS OF THE LINK RUN
!	AND OUTPUTS THEM TO THE MAP.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE MAP FILE MUST HAVE BEEN PREVIOUSLY OPENED.
!	DATA GATHERED DURING THE LINK
!
! IMPLICIT OUTPUTS:
!
!	EACH LINE IS OUTPUT TO THE MAP ON A NEW PAGE IF NEED BE.
!	THE LINE COUNTER IS INCREMENTED.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    local
	fao_errcode,				! FAO ERROR CODE
	value1 : long,				! INTERMEDIATE DATA STORAGE
	value2 : long,				! INTERMEDIATE DATA STORAGE
	value3 : long,				! INTERMEDIATE DATA STORAGE
	fao_ctl_ptr : ref block [, byte];	! POINTER TO FAO CONTROL STRING DESCRIPTOR

    bind
	auxfnb = lnk$gl_mapfil [fdb$t_auxfnb]	! REFERENCE THE MAP FILE'S AUXILIARY
	: block [nam$c_bln, byte];		! FILENAME BLOCK

!
    subhdline = 0;				! RESET SUB HEADING

    if not newpage () then return;		! OUTPUT NEW PAGE FOR IMAGE SYNOPSIS

    if not mapbox (linkwidehdr) then return;	! OUTPUT LINK-WIDE SYNOPSIS HEADER

!
! OUTPUT LINK-WIDE SYNOPSIS SECTION
!
!
! VIRTUAL MEMORY LIMITS
!
    value2 = .lnk$gl_maxva - .lnk$gl_minva + 1;	! CALCULATE MEMORY SIZE IN BYTES
    value1 = (.value2 + 511)/512;		! CALCULATE MEMORY SIZE IN PAGES

    if not lnk$mapout (outline, 0)		! SKIP A LINE
    then
	return;

    if not (fao_errcode = sys$fao (virmemline, outsize, outdes, .lnk$gl_minva, .lnk$gl_maxva, .value2,
	    .value2, .value1))			! FORMAT LINE
    then
	faofail (.fao_errcode)			!
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! STACK SIZE
!

    if not (fao_errcode = sys$fao (stackline, outsize, outdes, .lnk$gw_stack))	! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! IMAGE HEADER VIRTUAL BLOCK UNITS
!

    if .lnk$gw_hdrblks neq 0			! BASE BLOCK IS ALWAYS ONE (IF ANY HEADER)
    then

	if not (fao_errcode = sys$fao (imghdrblkline, outsize, outdes, 1, .lnk$gw_hdrblks, .lnk$gw_hdrblks))
	then
	    faofail (.fao_errcode)
	else

	    if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	    then
		return;				! NO MORE OUTPUT, I/O FAILURE

!
! IMAGE BINARY VIRTUAL BLOCK UNITS
!

    if .lnk$gw_imgblks eql 0			! IF NO BLOCKS OF BINARY
    then
	(value2 = 0; value1 = 0)		! THAT IS WHAT WE PRINT
    else
	(value2 = .lnk$gw_hdrblks + 1;		! CALCULATE BASE BLOCK
	value1 = .value2 + .lnk$gw_imgblks - 1);	! CALCULATE TOP OF BINARY BLOCKS

    if not (fao_errcode = sys$fao (imgbinblkline, outsize, outdes, .value2, .value1, .lnk$gw_imgblks))
						! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! IDENTIFICATION
!

    if not (fao_errcode = sys$fao (identline, outsize, outdes, 	! FORMAT LINE
	    lnk$gt_imgnam, lnk$gt_imgid))	! WITH THE STRINGS
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! NUMBER OF FILES
!

    if not (fao_errcode = sys$fao (nfilline, outsize, outdes, .lnk$gw_nfiles))	! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! NUMBER OF MODULES
!

    if not (fao_errcode = sys$fao (nmodline, outsize, outdes, .lnk$gw_nmodules))	! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! NUMBER OF P-SECTS
!

    if not (fao_errcode = sys$fao (npscline, outsize, outdes, .lnk$gw_npsects))	! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! NUMBER OF GLOBAL SYMBOLS
!

    if not (fao_errcode = sys$fao (nsymline, outsize, outdes, .lnk$gw_nsymbols))	! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

!
! INCLUDING UNDEFINED COUNT OF:
!

    if (.lnk$gw_nudfsyms neq 0)
    then 					!
	begin					!

	if not (fao_errcode = sys$fao (nundfline, outsize, outdes, .lnk$gw_nudfsyms))	! FORMAT LINE
	then
	    faofail (.fao_errcode)
	else

	    if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	    then
		return;				! NO MORE OUTPUT, I/O FAILURE

	end;

!
! NUMBER OF CROSS REFERENCES
!

    if .lnk$gw_ncrosrfs neq 0
    then

	if not (fao_errcode = sys$fao (ncrosrefs, outsize, outdes, .lnk$gw_ncrosrfs))
	then
	    faofail (.fao_errcode)
	else

	    if not lnk$mapout (outline, .outsize) then return;

!
! NUMBER OF IMAGE SECTIONS
!

    if (.lnk$gw_nisects neq 0)
    then
	begin

	if not (fao_errcode = sys$fao (niscline, outsize, outdes, .lnk$gw_nisects))	! FORMAT LINE
	then
	    faofail (.fao_errcode)
	else

	    if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	    then
		return;				! NO MORE OUTPUT, I/O FAILURE

	end;

    if not .lnk$gl_ctlmsk [lnk$v_sys]
    then
	begin
!
! USER TRANSFER ADDRESS
!

	if (.lnk$gl_tfrpsc neq 0)
	then
	    begin

	    if not (fao_errcode = sys$fao (usrtfrline, outsize, outdes, .lnk$gl_tfradr))	! FORMAT LINE
	    then
		faofail (.fao_errcode)
	    else

		if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
		then
		    return;			! NO MORE OUTPUT, I/O FAILURE

	    end;				!

!
! DEBUGGER TRANSFER ADDRESS
!

	if (.lnk$gl_dbgtfps neq 0)
	then
	    begin

	    if not (fao_errcode = sys$fao (dbgtfrline, outsize, outdes, .lnk$gl_dbgtfr))	! FORMAT LINE
	    then
		faofail (.fao_errcode)
	    else

		if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
		then
		    return;			! NO MORE OUTPUT, I/O FAILURE

	    end;				!

!
! COUNT OF ADDRESS FIXUPS
!

	if .lnk$gl_adrefs neq 0
	then
	    begin

	    if not (fao_errcode = sys$fao (nadrefline, outsize, outdes, .lnk$gl_adrefs))
	    then
		faofail (.fao_errcode)
	    else

		if not lnk$mapout (outline, .outsize) then return;

	    end;

!
! COUNT OF SYMBOL REFERENCES IN SHAREABLE IMAGES
!

	if .lnk$gl_shrsyms neq 0
	then
	    begin

	    if not (fao_errcode = sys$fao (nshrsymline, outsize, outdes, .lnk$gl_shrsyms))
	    then
		faofail (.fao_errcode)
	    else

		if not lnk$mapout (outline, .outsize) then return;

	    end;

!
! OTS TRANSFER ADDRESS
!

	if .lnk$gl_otsepdsc neq 0		! IF THE OTS TRANSFER ADDRESS WAS
	then
	    begin				! FOUND THEN OUTPUT IT TO

	    bind
		otsepsnb = .lnk$gl_otsepdsc - .lnk$gl_otsepdsc [sym$b_namlng] - snb$c_fxdlen : block [, byte];

	    if not (fao_errcode = sys$fao (otstfrline, outsize, outdes, 	! THE MAP ALSO. INCLUDE
		    otsepsnb [snb$b_namlng], 	! THE NAME OF THE RESERVED
		    .lnk$gl_otsepdsc [sym$l_value]))	! ENTRY POINT AS WELL AS ADDRESS
	    then
		faofail (.fao_errcode)		! REPORT ANY FORMATTING ERROR
	    else

		if not lnk$mapout (outline, .outsize)	! OUTPUT IT
		then
		    return;			! EXITING ON ERROR
	    end;
	end;
!
! IMAGE TYPE
!
    value2 = blanks;
    fao_ctl_ptr = ch$ptr (imgatrline, 0);	! ASSUME IMAGE IS NOT SHARABLE

    if .lnk$gl_ctlmsk [lnk$v_exe]		! SELECT EXE IMAGE PRINT
    then
	value1 = exeimage;			! LINE

    if .lnk$gl_ctlmsk [lnk$v_sys]		! SELECT SYS IMAGE PRINT
    then
	value1 = sysimage;			! LINE

    if .lnk$gl_ctlmsk [lnk$v_shr]		! SELECT SHR IMAGE PRINT
    then
	begin
	fao_ctl_ptr = ch$ptr (imgshrline, 0);	! USE SHARABLE IMAGE FAO CONTROL STRING

	if .lnk$gl_ctlmsk [lnk$v_picimg] then value1 = pic else value1 = nopic;

	value2 = shrimage;
	value3 = (selectone .lnk$gb_matchctl of
	    set
	    [isd$k_matall] : alltime;		! SELECT MATCH = ALWAYS
	    [isd$k_matnev] : never;		! SELECT MATCH = NEVER
	    [isd$k_matequ] : equal;		! SELECT MATCH = EQUAL
	    [isd$k_matleq] : lssequal;		! SELECT MATCH = LESS/EQUAL
	    [otherwise] : blanks;		! NO MATCH SET
	    tes);
	end;

    begin

    bind
	gsmajid = .lnk$gl_matchid<24, 8, 0>,	! GLOB SEC MAJOR ID
	gsminid = .lnk$gl_matchid<0, 24, 0>;	! GLOB SEC MINOR ID

    if not (fao_errcode = sys$fao (.fao_ctl_ptr, outsize, outdes, .value1, .value2, .value3, gsmajid, gsminid)
	)					! FORMAT LINE
    then
	faofail (.fao_errcode)
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT LINE
	then
	    return;				! NO MORE OUTPUT, I/O FAILURE

    end;
!
!	MAP FORMAT LINE
!
    if .lnk$gl_ctlmsk [lnk$v_brief]		! SELECT BRIEF FIELD
    then
	value1 = briefmap
    else

	if .lnk$gl_ctlmsk [lnk$v_long]		! SELECT LONG FIELD
	then
	    value1 = longmap
	else
	    value1 = defaultmap;

    if .lnk$gl_ctlmsk [lnk$v_cros]		! SELECT POSSIBLE CREF SUFFIX
    then
	value2 = crefmap
    else
	value2 = blanks;

    if not (fao_errcode = sys$fao (mapformat, outsize, outdes, .value1, .value2, 	! FORMAT THE LINE
	    .auxfnb [nam$b_rsl], .auxfnb [nam$l_rsa]))
    then
	faofail (.fao_errcode)			! REPORTING FAILURE
    else

	if not lnk$mapout (outline, .outsize)	! OUTPUT THE LINE
	then
	    return;				! GIVING UP ON FAILURE

    if not (fao_errcode = sys$fao (maplength, outsize, outdes, .mapestim))	! FORMAT LENGTH ESTIMATE LINE
    then
	faofail (.fao_errcode)			! AND GIVE UP ON FAILURE
    else

	if not lnk$mapout (outline, .outsize) then return;	! OUTPUT THE LINE GIVING UP ON ERROR

!
! DONE WITH LINK-WIDE SYNOPSIS
!
    sys$gettim (lnk$gq_endtim);			! GET THE TIME NOW
!
!	NOW GIVE THEM THE RUN STATISTICS
!

    if not mapbox (linkstats) then return;	! GIVE UP ON FAILURE OF BOX HEADING

    lnk$statsout ();				! AND GO DO THE WORK
    return;
    end;


routine mapbox (addr) = 			! OUTPUT HEADER IN A BOX

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A HEADER CONTAINED IN A BOX AND FOLLOWED BY
!	A BLANK LINE.
!
! FORMAL PARAMETERS:
!
!	ADDR -- THE ADDRESS OF THE HEADER, AN ASCIC STRING CONTAINING THE
!		 SIDES OF THE BOX
!
! IMPLICIT INPUTS:
!
!	THE BOXED HEADER IS WRITTEN TO THE MAP AND FOLLOWED BY A BLANK LINE.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin

    map
	addr : ref vector [, byte];		! REFERENCE A COUNTED ASCII STRING

    local
	outsiz : word,				! OUTPUT LINE SIZE
	chpntr : long,				! CHARACTER POINTER FOR OUTPUT LINE
	boxpntr : long,				! CHARACTER POINTER FOR OUTPUT LINE
	outbufr : ch$sequence (len$c_mapline);	! OUTPUT BUFFER

    if not .lnk$gl_ctlmsk [lnk$v_mapopn]	! MAP FILE OPEN?
    then
	return false;				! NO, RETURN

    chpntr = ch$ptr (outbufr);			! INITIALIZE CHARACTER POINTER
    outsiz = (len$c_mapline - .addr [0])/2 - 8;	! COMPUTE NUMBER OF SPACES BEFORE BOX
    chpntr = ch$fill (%c' ', .outsiz, .chpntr);	! MOVE IN SPACES
    boxpntr = .chpntr;				! REMEMBER WHERE BOX STARTS
    chpntr = ch$fill (%c'+', 1, .chpntr);	! MOVE IN BOX CORNER
    chpntr = ch$fill (%c'-', .addr [0] - 2, .chpntr);	! MOVE IN TOP OF BOX
    chpntr = ch$fill (%c'+', 1, .chpntr);	! MOVE IN BOX CORNER
    outsiz = .outsiz + .addr [0];		! COMPUTE LENGTH OF OUTPUT LINE

    if not lnk$mapout (outbufr, .outsiz)	! OUTPUT TOP OF BOX
    then
	return false;				! NO MORE OUTPUT, I/O FAILURE

    ch$move (.addr [0], addr [1], .boxpntr);	! MOVE IN TITLE AND BOX SIDES

    if not lnk$mapout (outbufr, .outsiz)	! OUTPUT HEADER IN BOX
    then
	return false;				! NO MORE OUTPUT, I/O FAILURE

    chpntr = ch$fill (%c'+', 1, .boxpntr);	! MOVE IN BOX CORNER
    chpntr = ch$fill (%c'-', .addr [0] - 2, .chpntr);	! MOVE IN BOTTOM OF BOX
    chpntr = ch$fill (%c'+', 1, .chpntr);	! MOVE IN BOX CORNER

    if not lnk$mapout (outbufr, .outsiz)	! OUTPUT BOTTOM OF BOX
    then
	return false;				! NO MORE OUTPUT, I/O FAILURE

    return true;				! SUCCESSFUL RETURN
    end;

routine lnk$crfout (linedesc) =
    begin

!++
!	THIS ROUTINE IS CALLED BY CROSS REFERENCE TO OUTPUT
!	EACH LINE OF THE CROSS REFERENCE.
!
! INPUTS:
!
!	LINEDESC	ADDRESS OF A STRING DESCRIPTOR FOR THE LINE
!
!--

    map
	linedesc : ref block [, byte];

    return lnk$mapout (.linedesc [dsc$a_pointer], .linedesc [dsc$w_length])
    end;					! OF LNK$CRFOUT


global routine lnk$mapout (addr, length) =
					! CONDITIONALLY OUTPUT A LINE OF THE MAP, CHECKING FOR NEW PAGE

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A LINE OF DATA TO THE MAP FILE.  IT ALSO
!	INSERTS A NEW PAGE AND THE APPROPRIATE HEADERS WHENEVER NEEDED.
!
! FORMAL PARAMETERS:
!
!	ADDR -- ADDRESS OF THE ASCII STRING TO BE OUTPUT
!	LENGTH -- LENGTH OF THE ASCII STRING TO BE OUTPUT
!
! IMPLICIT INPUTS:
!
!	THE MAP FILE MUST BE ALREADY OPEN.
!
! IMPLICIT OUTPUTS:
!
!	THE OUTPUT LINE IS WRITTEN TO THE MAP FILE.  THE PAGE COUNTER IS INCREMENTED.
!	IF THE CURRENT PAGE IS FULL, A NEW PAGE WITH HEADER LINES IS OUTPUT
!	BEFORE THE CURRENT OUTPUT LINE.
!
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin

    map
	addr : ref vector [, byte];		! REFERENCE AN OUTPUT BUFFER

    literal
	lfchar = 10;				! LITERAL VALUE OF LINEFEED

    local
	blength,
	bptr,
	eptr,
	lptr;

!

    if not .lnk$gl_ctlmsk [lnk$v_mapopn]	! IF THE MAP FILE IS NO LONGER
    then
	return true;				! OPEN, RETURN IMMEDIATELY

    if .linecnt geq .lnk$gb_linespp		! CHECK IF A NEW PAGE IS NEEDED
    then

	if not newpage () then return false;	! AND OUTPUT IT IF SO GIVING UP ON FAILURE

    if not (rmserror = $wait (rab = maprab))	! WAIT FOR POSSIBLE PREVIOUS
    then
	begin					! OUTPUT AND
	mapfail ();				! REPORT ANY ERROR
	return false;				! GIVING UP ON IT
	end;

    bptr = .addr;				! POINT TO START OF STRING
    eptr = .bptr + .length;			! COMPUTE END OF STRING
    blength = .length;

    while not (ch$fail (lptr = ch$find_ch (.blength, .bptr, lfchar)))	! LOOK FOR MULTI-LINE OUTPUT
    do
	begin

	if not lnk$mapout (.bptr, .lptr - .bptr - 1)	! WRITE OUT THE LINE
	then
	    return false;

	blength = .blength - (.lptr - .bptr + 1);	! UPDATE LENGTH LEFT TO WRITE
	bptr = .lptr + 1;

	if .bptr geqa .eptr then return true;

	end;

    maprab [rab$l_rbf] = .bptr;			! SET THE RECORD ADDRESS IN RAB
    maprab [rab$w_rsz] = .blength;		! AND THE RECORD LENGTH

    if not (rmserror = $put (rab = maprab))	! AND OUTPUT IT
    then
	begin					! BUT IF AN ERROR REPORT
	mapfail ();				! IT NOW AND
	return .rmserror;			! AND GIVE UP
	end;

    linecnt = .linecnt + 1;			! INCREMENT NUMBER OF LINES OUTPUT ON CURRENT PAGE
    return true;				! REPORT SUCCESS
    end;


routine mapsubhdr (subhdrdsc, arg1) = 		! OUTPUT PAGE SUB HEADING
    begin

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE BUILDS A SUB-HEADER TITLE AND OUTPUTS IT TO THE MAP
!	FILE.  IT INITIALIZES THE AUTOMATIC MAP SUB-HEADER GENERATION.
!
! FORMAL PARAMETERS:
!
!	SUBHDRDSC -- ADDRESS OF 2 FAO CONTROL STRING DESCRIPTORS FOR THE SUB-HEADER
!			WHICH IS ASSUMED TO BE TWO LINES LONG,
!			CONSISTING OF UNDERLINED COLUMN HEADERS
!	ARG1 -- FAO ARGUMENT FOR SUBHEADER WHICH WAS TOO LONG TO MAKE ONE
!			COUNTED ASCII STRING
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	THE SUBHEADER IS SET UP AND WRITTEN TO THE MAP FILE.  IT IS
!	STORED AS POSSIBLE OUTPUT ON FUTURE PAGES.  SUBHDLINE IS
!	INITIALIZED TO CAUSE AUTOMATIC SUB-HEADER GENERATION.  A BLANK
!	LINE IS OUTPUT FOLLOWING THE SUB-HEADER LINE.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    own
	extra_fao_arg;				! REMEMBER PREVIOUS VALUE OF ARG1

    builtin
	actualcount;

    map
	subhdrdsc : ref vector;			! POINTER TO DESCRIPTOR VECTOR

    local
	fao_errcode,				! FAO ERROR CODE
	subheadlng,				! LENGTH OF FORMATTED LINE (RETURNED BY FAO)
	subheadbuf : ch$sequence (len$c_mapline),	! BUFFER FILLED BY FAO
	subheadbufdsc : vector [2];		! DESCRIPTOR OF ABOVE BUFFER

    if .subhdrdsc eql 0 then return true;	! IF THERE IS NONE,RETURN

    if actualcount () eql 2			! IF A SECOND ARGUMENT PRESENT,
    then
	extra_fao_arg = .arg1;			! REMEMBER FOR NEXT TIME

    subheadbufdsc [0] = len$c_mapline;		! INITIALIZE THE BUFFER DESCRIPTOR
    subheadbufdsc [1] = subheadbuf;		! FOR CALL TO FAO

    if not lnk$mapout (subheadbuf, 0)		! SKIP A LINE
    then
	return false;

    incr i from 0 to 2 by 2			! LOOP TO DO BOTH LINES
	do
	begin

	if not (fao_errcode = sys$fao (subhdrdsc [.i], subheadlng, subheadbufdsc, .extra_fao_arg))
						! FORMAT THE NEXT LINE
	then
	    faofail (.fao_errcode);

	if not lnk$mapout (subheadbuf, .subheadlng)	! OUTPUT IT
	then
	    return false;			! EXITING IF FAILURE

	end;					! END LOOP TO INSERT SUBHEADER

    subhdline = .subhdrdsc;			! SET A SUBHEADER ADDRESS
    return true;				! SUCCESSFUL RETURN
    end;

routine newpage = 				! OUTPUT NEW PAGE, ITS HEADING AND SUBHEADER

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A FORM FEED AND THE MAP HEADER LINE.  IT
!	CONDITIONALLY OUTPUTS A SUB-HEADER LINE.  BALNK LINES FOLLOW
!	THE HEADERS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	A NEW PAGE WITH THE APPROPRIATE HEADERS IS WRITTEN TO THE MAP FILE.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin

    local
	fao_errcode,				! FAO ERROR CODE
	hdrdsc : vector [2],			! HEADER BUFFER DESCRIPTOR
	hdrbuf : ch$sequence [len$c_mapline],	! HEADER BUFFER
	hdrsiz;					! HEADER LINE LENGTH FROM FAO

!
    linecnt = 0;				! RESET COUNT OF LINES ON CURRENT PAGE
    hdrdsc [0] = len$c_mapline;			! INITIALIZE THE HEADER BUFFER
    hdrdsc [1] = hdrbuf;			! DESCRIPTOR FOR FAO
!

    if not (fao_errcode = sys$fao (ff_cntrl_str, hdrsiz, hdrdsc))
    then
	begin
	faofail (.fao_errcode);
	return false;
	end;

    if not lnk$mapout (hdrbuf, .hdrsiz) then return false;

    if not (fao_errcode = sys$fao (hdr_cntrl_str, hdrsiz, hdrdsc, imagefilename, lnk$gq_startim,
	    maj_ident_lng, lnk$aw_version [lid$w_major], min_ident_lng, lnk$aw_version [lid$w_minor],
	    .pagenum))				! FORMAT HEADER LINE
    then
	begin
	faofail (.fao_errcode);
	return false;				! REPORT ERROR
	end;					!

    pagenum = .pagenum + 1;			! COUNT NEW PAGE

    if not lnk$mapout (hdrbuf, .hdrsiz)		! OUTPUT MAIN PAGE HEADING
    then
	return false;				! GIVING UP ON FAILURE

    if not lnk$mapout (hdrbuf, 0)		! SKIP A LINE
    then
	return false;

    mapsubhdr (.subhdline);			! OUTPUT SUB HEADING IF ANY

    if .psectnameline neq 0			! IF PRINTING PSECTS NOW
    then
	lnk$mapout (.psectnameline, len$c_mapline);	!  THEN PRINT SUMMARY FOR CURRENT PSECT

    return true;				! RETURN SUCCESS STATUS
    end;

routine newline = 				! ROUTINE TO OUTPUT A BLANK LINE

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A BLANK LINE TO THE MAP FILE, UPDATING THE
!	LINE COUNTER.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	OUTPUTS A BLANK LINE TO THE MAP FILE.
!	INCREMENTS THE LINE COUNTER.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    begin

    if not lnk$mapout (outline, 0)		! OUTPUT A BLANK LINE
    then
	return false;				! AND GIVE UP IF IT FAILS

    return true;				! REPORT SUCCESS
    end;
end

eludom
