
MODULE MOUVOL (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  MTAACP
!
! ABSTRACT:
!	This module mounts a volume
!
!
! ENVIRONMENT:
!
!	VMS operating system, including privileged system services
!	and internal exec routines.
!
!--

!
!
! AUTHOR:  D. H. GILLESPIE,	 CREATION DATE:  24-AUG-1977
!
! MODIFIED BY:
!
!	V03-013	HH0041		Hai Huang		24-Jul-1984
!		Remove REQUIRE 'LIBD$:[VMSLIB.OBJ]MOUNTMSG.B32'.
!
!	V03-012	MMD0288		Meg Dumont,	10-Apr-1984  14:14
!		Fix to the return from $MTACCESS code where ACCESS could
!		be set to normal processing before all the error conditions
!		where checked.
!
!	V03-011	LMP0221		L. Mark Pilant,		28-Mar-1984  14:45
!		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
!		ORB$W_PROT.
!
!	V03-010	MMD0271		Meg Dumont,	23-Mar-1984  9:34
!		Change the processing of the accessibility character fields
!		in the VOL1 label to call the installation
!		specific accessibility routine. The return from this
!		routine determines the users access to the volume.
!
!	V03-009	MMD0185		Meg Dumont,	6-Jul-1983  18:32
!		Make the default for AVL/AVR the same from the DCL call
!		and from the system service call.
!
!	V03-008	MMD0176		Meg Dumont,	26-May-1983  15:11
!		Fix to support new input to IOC$CVT_DEVNAM
!
!	V03-007	MMD0174		Meg Dumont,	9-May-1983  15:16
!		Fix to make IO_STATUS consistently defined within module
!
!	V03-006	MMD0164		Meg Dumont,	26-Apr-1983  9:43
!		Change the references to 80 to be the symbol ANSI_LBLSZ. Change
!		the reference to 240 to be the symbol SCRATCH_OFFSET.
!
!	V03-005	MMD0134		Meg Dumont,	12-Apr-1983  17:24
!		Added support for writng and interrupting the VOL1
!		OWNER IDENTIFIER field, so that it is no longer
!		treated as a VMS field, strictly. Bugfix to the AVL, AVR
!		code where MOUNT/INIT would not work under all circumstances.
!
!	V03-004	MMD0120		Meg Dumont,	29-Mar-1983  0:44
!		Added support for the VOL2 label inside the MTAACP
!
!	V03-003	MMD0103		Meg Dumont,	17-Feb-1983  13:14
!		Use GET_DEV_NAME to get the tape units device name. Added
!		the routine GET_DEV_NAME to call the system routine
!		IOC$CVT_DEVNAM to get the tape units name. Added the code
!		to do automatic volume recognition and labeling (AVR and
!		AVL).
!
!	V03-002	MMD0002		Meg Dumont,	3-Jan-1983  15:43
!		Allow user with read access to a tape to mount the tape 
!		writelocked. Add modifier IO$M_CLRSEREXCP to all QIO's issued 
!		by the MTAACP, necessary for the MSCP tape drives.

!
!	V03-001	MMD0001		Meg Dumont,	23-Mar-1982  10:16
!		Added a check for member UIC match when mounting a volume.
!
!      	V02-014 DMW00071	David Michael Walp	21-Jan-1981
!		Handle Volume Invalid during verification

!	V02-014 DMW00059	David Michael Walp	 7-Dec-1981
!		Moved Rename TRANSLATION_TABLE to ANSI_A_BAD, ANSI_A_GOOD
!
!	V02-013 DMW00036	David Michael Walp	17-Sep-1981
!		Correct error messages given ( MOUNT, REMOUNT switched )
!
!	V02-012 DMW00030	David Michael Walp	18-Aug-1981
!		Volume Access and ANSI 'a' character in Volume Names
!
!	V02-011 DMW00017	David Michael Walp	20-May-1981
!		Copy the new fields ( File-Set-Id and Vol_Acc ) then
!		creating New MVL.
!
!	V02-010 DMW00014	David Michael Walp	14-Mar-1981
!		Changed the calculation of the CCB address to GET_CCB
!
!	V02-009	REFORMAT	Maria del C. Nasr	30-Jun-1980
!
!	A0008	MCN0003		Maria del C. Nasr	15-Oct-1979   9:23
!		Add HDR3 processing
!
!**

LIBRARY 'SYS$LIBRARY:LIB.L32';

REQUIRE 'SRC$:MTADEF.B32';

REQUIRE 'LIBD$:[VMSLIB.OBJ]INITMSG.B32';

LINKAGE
    L$CHOOSE_UNIT   = JSB :  GLOBAL (CURRENT_VCB = 11) 
			      NOTUSED (2, 3, 4, 5, 6, 7, 8, 9, 10),
    MVL_UCB	    = CALL : GLOBAL (MVL_ENTRY = 9, UCB_LIST = 10,
			      CURRENT_VCB = 11);

FORWARD ROUTINE
    ASSUME_MOUNTED	: NOVALUE MVL_UCB,	! assume correct volume is 
						!  mounted
    CLPREV_MAKECUR	: NOVALUE MVL_UCB,	! clear prev use of volume and
						!  make it current
    CHECK_ACCESS	: MVL_UCB,		! check the access rights to a 
						!  tape
    CHECK_RING		: COMMON_CALL,		! check for the write ring
    CHOOSE_UNIT		: L$CHOOSE_UNIT,	! choose unit for mount
    CLEAR_UNIT		: NOVALUE MVL_UCB,	! clear last mounted volume
    CREATE_LABEL	: COMMON_CALL,		! create a label for the volume
    GET_DEV_NAME	: COMMON_CALL NOVALUE,	! given the UCB addr get dev nam
    MAKE_CUR_VOL	: NOVALUE MVL_UCB,	! make volume current
    MAKE_VOL_ENTRY	: COMMON_CALL,		! make volume entry in MVL
    OPERATOR_LBL	: MVL_UCB,		! record operator supplied
						!  label
    SET_MVL_OVERIDE	: NOVALUE MVL_UCB;	! set the MVL overide bit

EXTERNAL
    CURRENT_UCB		: REF BBLOCK,	! address of current unit control block
    CURRENT_WCB		: REF BBLOCK,	! address of current WCB
    IO_CHANNEL,				! acp io channel
    IO_STATUS		: VECTOR [2],	! status of io
    MAIL_CHANNEL,
    WORK_AREA;

EXTERNAL ROUTINE
    BLOCK,				! block activity on current volume set
    CHECK_PROT,					! check VMS protection rights
    ENABLE_MAIL_AST	: COMMON_CALL,
    GET_CCB,				! get the address of the CCB
					! get devname given its UCB
    GET_RECORD,				! get the record tape is currently reading
    IOC$CVT_DEVNAM 	: L$IOC_CVT_DEVNAM ADDRESSING_MODE (ABSOLUTE),
    PRINT_OPR_MSG	: L$PRINT_OPR_MSG,
    PRINT_NOT_LABEL	: JSB,		! print not correct label
    PROCESS_VOL2_LABEL,			! interpret the contents of VOL2    
    READ_BLOCK		: COMMON_CALL,	! read mag tape block
    REWIND_AND_WAIT	: COMMON_CALL,	! rewind volume and wait for completion
    SEND_ERRLOG,
    SYS$FAO		: ADDRESSING_MODE (ABSOLUTE),	! format ascii output
    SYS$QIOW		: ADDRESSING_MODE (ABSOLUTE),	! queue I/O and wait
    SYS$SETIMR		: ADDRESSING_MODE (ABSOLUTE),	! set time request
    SYS$WAITFR		: ADDRESSING_MODE (ABSOLUTE),	! wait for event
    TAPE_OWN_PROT,			! determine the owner and
					! protection of a tape
    TERMINATE_VOL;			! terminate mount request

BIND
    MAIL   = WORK_AREA	: BBLOCK [MSGSIZE],
    MAILSZ = MAIL + MSGSIZE,
    STARID = UPLIT ('DECFILE11A');

OWN
    TAPE_OWNER,
    TAPE_PROT		: BITVECTOR [16],
    LABEL_SPEC		: BITVECTOR [1],    	! set if oper specified label
    INFORM_OPER		: BITVECTOR [1],        ! set if oper should know that
						! a mount happen without their
						! involvment
    CVT_DEVNAM		: VECTOR [MAX_DEVNAM_LENGTH,BYTE], ! Converted device
							   ! name 
    CVT_DEVNAM_LENGTH	: BYTE;		     	! length of device name

GLOBAL ROUTINE MOUNT_VOL (VOL, FLAGS) : COMMON_CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!& REWRITE THIS DESCRIPTION
!&
!	This routine mounts the specified relative volume.  If it is
!	already mounted and the rewind flag is set then the volume will be
!	rewound and the VOL1 label rechecked.  If the volume is not mounted,
!	a request is issued to the operator, the process blocks until the oper
!	replies that the volume has been mounted.  Then if the label flag
!	is set, the VOL1 label is checked against the one entered at the
!	original mount time or one entered by the operator when indicating
!	that the volume was mounted.
!
! CALLING SEQUENCE:
!	MOUNT_VOL(ARG1,ARG2)
!
! INPUT PARAMETERS:
!	ARG1 - relative volume number to mount
!	ARG2 - flags
!		MOU$V_REWIND   - request rewind of volume
!		MOU$V_LBLCHECK - request check of label
!		MOU$V_CHKIFSPC - check the label only if the operator supplied
!		MOU$V_MOUNTERR - error on last mount, so force mount
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	volume is mounted and set current
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    BIND
	SECONDS = UPLIT (-10000000, -1);    ! one second in 100 nsec units

    MAP
	FLAGS	: BBLOCK;

    GLOBAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK ,	    ! addr of MVL entry for current vol
	UCB_LIST = 10	: REF VECTOR;	    ! addr of list of UCB's for vol set

   EXTERNAL REGISTER	
	COMMON_REG;

    LOCAL
	MVL	: REF BBLOCK;		    ! address of MVL control block


    ! get the MVL and see if we need to increase its size. This means that
    ! if we have more volumes in the set then originally specified then we
    ! must create more MVL enties for those volumes. Each volume in a volume
    ! set has its own MVL for the duration of the mount of that volume set.

    MVL = .CURRENT_VCB[VCB$L_MVL];
    IF .MVL[MVL$B_NVOLS] LSS .VOL
    THEN
	MVL = KERNEL_CALL(MAKE_VOL_ENTRY, .VOL, .MVL);

    ! point at the current MVL label

    MVL_ENTRY = .MVL + MVL$K_FIXLEN + ((.VOL - 1)*MVL$K_LENGTH);

    ! if volume mounted then make the volume and the unit it is mounted on
    ! current. Else if the MTAACP is running in Automatic mode then all
    ! we need to do is get the next free drive. We must assume that if
    ! the drive has a vaild reel on it then it is the next reel the 
    ! operator wishes us to use. If we are not running in Automatic mode this
    ! is not true and we must choose a unit, clear its previous use, and 
    ! make the volume and the new unit current.

    UCB_LIST = BBLOCK[.CURRENT_VCB[VCB$L_RVT], RVT$L_UCBLST];
    IF .MVL_ENTRY[MVL$V_MOUNTED] AND NOT .FLAGS[MOU$V_MOUNTERR]
    THEN KERNEL_CALL(MAKE_CUR_VOL, .MVL_ENTRY[MVL$B_RVN], .VOL)
    ELSE 
    BEGIN

	! If we are running in Automatic mode then we want to unload the
	! last volume so that the operator can put the next reel on the drive.
	! However we also want to special case the fact that the user
	! may have only one drive and thus force the operator to intervene.

	IF NOT .CURRENT_VCB[VCB$V_NOAUTO] 
	   AND (.BBLOCK [.CURRENT_VCB[VCB$L_RVT], RVT$B_NVOLS] GTR 1)
	THEN 
	BEGIN
	   KERNEL_CALL(CLEAR_UNIT);
	   KERNEL_CALL(MAKE_CUR_VOL, CHOOSE_UNIT(), .VOL);
	END
	ELSE KERNEL_CALL(CLPREV_MAKECUR, CHOOSE_UNIT(), .VOL);
    END;

    ! now if the volume is mounted and no rewind is required just return

    IF	.MVL_ENTRY[MVL$V_MOUNTED]
	AND NOT .FLAGS[MOU$V_MOUNTERR]
	AND NOT .FLAGS[MOU$V_REWIND]
	    THEN RETURN .MVL_ENTRY;

    ! Assume that we won't send a message to the operators console. We would
    ! want to sent one if we switched to a new reel on a volume set without
    ! the operator getting involved in anyway. That is automatic volume 
    ! recognition is turned on and no errors occured while mounting the 
    ! next volume. Also assume that no label will be specified.

    INFORM_OPER [0] = FALSE;
    LABEL_SPEC [0] = FALSE;

    ! Call to get the device name and length of the name. These fields are
    ! stored in fields accessible to other routines in this module so that
    ! only one call need be done.

    GET_DEV_NAME (CVT_DEVNAM_LENGTH, CVT_DEVNAM);

    ! When the Mtaacp is running in Automtic mode, before asking the 
    ! operator for the tape and label try to generate the label with 
    ! in the ACP. And try to mount the volume on the given unit with 
    ! that label.

    IF NOT .CURRENT_VCB[VCB$V_NOAUTO] 
    THEN
    BEGIN
	IF KERNEL_CALL(CREATE_LABEL, .VOL, .MVL)
	   THEN
	   BEGIN

		! Default the following fields
		! LABEL_SPEC : We have a label for the next volume to mount.
		! INFORM_OPER : If this mount works inform the operator that
		!		we have mounted a volume "behind his back".
	
		LABEL_SPEC [0] = TRUE;
		INFORM_OPER [0] = TRUE;

		! If there is only one drive in this volume set then must give
		! the operator some time to put the tape on the drive.

       		IF .BBLOCK [.CURRENT_VCB[VCB$L_RVT], RVT$B_NVOLS] GTR 1
		THEN
		BEGIN
		   KERNEL_CALL(ASSUME_MOUNTED);
		   KERNEL_CALL(SEND_ERRLOG,1,.CURRENT_UCB);
		END;
	   END;
    END;

    ! loop until we have a good mount

    WHILE 1 DO
	BEGIN

	LOCAL  STATUS;

	! assume all is going to work

	STATUS = TRUE;

	! Does the operator need to get involved ( mount a reel on a drive )

	IF NOT .MVL_ENTRY[MVL$V_MOUNTED] OR .FLAGS[MOU$V_MOUNTERR]
	THEN
	    BEGIN

	    LOCAL 
		LABEL_ADDR : REF VECTOR [,BYTE],
		LABEL_SZ,
		MESSAGE_NUMBER;

	    ! find the size to the label, do not print trailing spaces
	    !
	    LABEL_ADDR = MVL_ENTRY [ MVL$T_VOLLBL ];
	    IF .MVL_ENTRY [MVL$V_UNUSED]
	    THEN LABEL_SZ = 0
	    ELSE
		BEGIN
		LABEL_SZ = 6;
		DECR I FROM MVL$S_VOLLBL - 1 TO 0 DO
		    IF .LABEL_ADDR [.I] NEQ ' '
		    THEN EXITLOOP
		    ELSE LABEL_SZ = .LABEL_SZ - 1;
		END;

	    ! tell the operator to mount the reel
	    !
	    IF .FLAGS[MOU$V_LBLCHECK] 
	    THEN MESSAGE_NUMBER = MOUN$_REMOUVOL
	    ELSE IF .FLAGS[MOU$V_CHKIFSPC]
		 THEN MESSAGE_NUMBER = MOUN$_MOUVOL
		 ELSE MESSAGE_NUMBER = MOUN$_MOUNEWVOL;
	    IF NOT PRINT_OPR_MSG(.MESSAGE_NUMBER, .MAIL_CHANNEL,
		    .CURRENT_VCB[VCB$B_CUR_RVN], .LABEL_SZ, .LABEL_ADDR,
		    .CVT_DEVNAM_LENGTH, CVT_DEVNAM)
	    THEN
		BEGIN
		KERNEL_CALL(TERMINATE_VOL, .CURRENT_WCB);
		ERR_EXIT(SS$_NOTAPEOP);
		END;

	    ! block the process and wait for the operator to reply
	    !
	    ENABLE_MAIL_AST();
	    BLOCK(VCB$M_WAIMOUVOL);

	    ! The operator has replied so check if a label has been specified 
	    ! If it has then check it to be sure that it is a valid ANSI label.

	    IF .MAILSZ GTR 0
	    THEN
		BEGIN

		! stuff the label in MVL after doing ANSI checks

		STATUS = KERNEL_CALL(OPERATOR_LBL);
		IF NOT .STATUS
		THEN PRINT_OPR_MSG ( .STATUS, 0,
				.CVT_DEVNAM_LENGTH, CVT_DEVNAM)
		ELSE LABEL_SPEC [0] = TRUE; 
		END;

	    ! No need to send another message to the operators console

	    INFORM_OPER [0] = FALSE;

	    ! assume device is mounted

	    KERNEL_CALL(ASSUME_MOUNTED);
	    KERNEL_CALL(SEND_ERRLOG, 1, .CURRENT_UCB);
	    END;

	! the reel was just mount or was already mounted now check it for
	! being on online and valid
	!
	IF .STATUS
	THEN

	    ! Rewind the reel
	    !
	    INCRU J FROM 0 TO 29 DO
		BEGIN
		STATUS = REWIND_AND_WAIT();

		! if on_line, then exit loop
		!
		IF .STATUS THEN EXITLOOP;

		! wait one second if offline
		!
		IF SYS$SETIMR(TIMEFN, SECONDS, 0, 0)
		THEN SYS$WAITFR(TIMEFN);
		END;

	! check for the write ring if needed
	!
	IF .STATUS AND ( NOT .BBLOCK[CURRENT_UCB[UCB$L_DEVCHAR],DEV$V_SWL] )
	THEN IF NOT (STATUS = CHECK_RING ())
	     THEN PRINT_OPR_MSG ( MOUN$_WRITLCK, 0,
			    .CVT_DEVNAM_LENGTH, CVT_DEVNAM);

	! check the users privileges to write and read to the volume
	!
	IF .STATUS
	THEN
	    BEGIN

	    ! assume device is mounted
	    !
	    KERNEL_CALL(ASSUME_MOUNTED);

	    ! exit if "/BLANK" on the reply command on a write next volume
	    ! operation
	    !
	    IF ((.MAIL[OPC$W_MS_STATUS] EQL (OPC$_BLANKTAPE AND %X'FFFF'))
	       OR .CURRENT_VCB[VCB$V_BLANK] )
	       AND NOT ( .FLAGS [MOU$V_CHKIFSPC] OR .FLAGS [MOU$V_LBLCHECK] )
	    THEN
		BEGIN

		! if the use writes the tape he has override privs
		!
		KERNEL_CALL( SET_MVL_OVERIDE, TRUE);

		! mount has succeeded exit "try till good mount" loop
		!
		EXITLOOP;
		END;

	    ! now check for ANSI accessiblity and VMS protection and
	    ! exit the "try till good mount" loop in everything is OK
	    !
	    IF CHECK_ACCESS ( .FLAGS ) THEN EXITLOOP;

	    END;

	! mount did not work for some reason, force operator intervention
	!
	FLAGS = .FLAGS OR $FIELDMASK(MOU$V_MOUNTERR);

	! reset the state of things
	!
	KERNEL_CALL(CLPREV_MAKECUR, .MVL_ENTRY[MVL$B_RVN], .VOL);
	END;					! end of while not good mount

    ! Check to see if the operator should hear about the switch then return.

    IF .INFORM_OPER [0]
	THEN 
	BEGIN
	   LOCAL
	   DESCR : VECTOR [2];			! Descr of the device name for
						! the FAO field in the msg

	   DESCR [0] = .CVT_DEVNAM_LENGTH;	! Length of dev name
	   DESCR [1] = CVT_DEVNAM;		! Address of the dev name

	   ! Assume that the size of the label is 6. This is a safe assumption
	   ! because we generated the label.

	   PRINT_OPR_MSG (MOUN$_MOUNTED, 0, 6, MVL_ENTRY[MVL$T_VOLLBL],DESCR);
         END;
    RETURN .MVL_ENTRY;

    END;					! end of routine MOUNT_VOL

GLOBAL ROUTINE GET_DEV_NAME(LEN, C_DEVN) : COMMON_CALL NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine converts a UCB address into te device's name by calling
!	the system routine IOC$CVT_DEVANM.
!
! CALLING SEQUENCE:
!	GET_DEV_NAME(ARG1,ARG2)
!
! INPUT PARAMETERS:
!	ARG1 - Address to store the length of the device name
!	ARG2 - Address to store the name of the device
!
! IMPLICIT INPUTS:
!	CURRENT_UCB - address of current unit control block
!
! OUTPUT PARAMETERS:
!	The length of the device name and the device name are returned
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!	
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_REG;

    BIND
	CVT_DEVNAME =  .C_DEVN,		    ! Storage for cvted device name
	LENGTH	    =  .LEN,		    ! Length of device name
	IN_NAME_LENGTH = MAX_DEVNAM_LENGTH; ! Set the maxium lentgh if dev nam

    LOCAL
	OUT_NAME_LENGTH	: BYTE,		    ! Actual length of device name gotten from the convert
	CVT_DEVNAM_STATUS,		    ! Status of the convert on devnam
	DEV_NAME : VECTOR [MAX_DEVNAM_LENGTH,BYTE]; ! Local storage for the
	  					  ! name from the convert

    ! Call to the system routine to get the device name of the drive to use
    ! given the UCB associated with that drive. This routine gets both
    ! the node name and the device name.
    ! NOTE: DEV_NAME must be in local storage, because the routine expects
    ! this field to be always accessible.

    CVT_DEVNAM_STATUS = IOC$CVT_DEVNAM ( IN_NAME_LENGTH, DEV_NAME, 0,
					.CURRENT_UCB; OUT_NAME_LENGTH);

    ! Move the resultant string into a field accessable to the entire module.
    ! Also fill the first byte of the string with the size of the string for
    ! the call to PRINT_OPR_MSG. The FAO string expects the device name to be
    ! in this format.

    CH$MOVE (.OUT_NAME_LENGTH,DEV_NAME,CVT_DEVNAME);
    LENGTH = .OUT_NAME_LENGTH;
    END;



ROUTINE CHOOSE_UNIT : L$CHOOSE_UNIT =

!++
!
! FUNCTIONAL DESCRIPTION:
!	this routine chooses the next unit to use
!
! CALLING SEQUENCE:
!	CHOOSE_UNIT()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	CURRENT_VCB - address of current volume control block
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	relative unit number
!
! SIDE EFFECTS:
!	The current algorythm is increment current unit.
!	If it is allocated then use it else wrap around to first unit.
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_REG;

    LOCAL
	NUNITS,					! number of units allocated
	RVT	: REF BBLOCK,			! address of unit table
	UNIT;					! unit to use

    RVT = .CURRENT_VCB[VCB$L_RVT];		! get address of unit table

    NUNITS = .RVT[RVT$B_NVOLS];		        ! get # of units allocated to
						!  this volume set
    UNIT = .CURRENT_VCB[VCB$W_RVN] + 1;		! inc current rel unit number

    IF .UNIT GEQ .NUNITS
    THEN
	UNIT = 0;				! if not allocated, use 1st one

    RETURN .UNIT;

    END;					! end of routine CHOOSE_UNIT

ROUTINE CLEAR_UNIT : NOVALUE MVL_UCB =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine dismounts the last used volume in a volume set. It does
!	this by checking the Current UCB against the list of UCB's to find the
!	unit number. Then checking each entry in the MVL for that unit number.
!	If that unit is marked mounted then a QIO is issued to dismount and
!	unload that volume and the MVL is marked dismounted. This will allow 
!	the operator to mount the next reel in the volume set before it is
!	actually needed by MTAACP processing.
!
! CALLING SEQUENCE:
!	CLEAR_UNIT() called in Kernel mode
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	CURRENT_VCB - address of current volume control block
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Last mounted volume is dismount and unloaded.
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!
!--

    BEGIN

    EXTERNAL REGISTER
	MVL_ENTRY = 9 : REF BBLOCK,		! Address of current MVL not
						! used by this routine
	UCB_LIST = 10 : REF VECTOR,		! Addr of UCB list for vol set
	COMMON_REG;

    LOCAL
	NUNITS,					! number of units allocated
	RVT	: REF BBLOCK,			! address of unit table
	UNIT,					! unit currently in use
	NVOLS,					! number of volumes in set
	MVL	: REF BBLOCK,			! addr of magtape volume list
	MVL_ADDR : REF BBLOCKVECTOR [10,MVL$K_LENGTH];
						! addr of MVL control block


    RVT = .CURRENT_VCB[VCB$L_RVT];		! get address of unit table
    NUNITS = .RVT[RVT$B_NVOLS];		        ! get # of units allocated to
    UNIT = 0;					! Set first unit

! Check thru the list of UCB to find the unit number of the UCB currently
! in use.
   
    INCR I FROM 0 TO .NUNITS - 1 DO
	IF .UCB_LIST [ .UNIT ] EQL .CURRENT_UCB
	THEN EXITLOOP
	ELSE UNIT = .UNIT + 1;
    MVL = .CURRENT_VCB[VCB$L_MVL];		! get the magtape vol list addr
    NVOLS = .MVL[MVL$B_NVOLS];			! get the numb of volume in set
    MVL_ADDR = .MVL + MVL$K_FIXLEN;		! get the first volume entry

! Check thru the mounted volume labels to find the entry which points
! at the current unit and is mark as mounted. When we find that entry,
! a message is send to the ERRORLOG saying the volume has been dismounted;
! the entry is marked dismounted and a QIO is issued to the drive to unload
! the reel from the drive.

    INCR I FROM 0 TO .NVOLS - 1 DO
	IF .MVL_ADDR [ .I, MVL$V_MOUNTED ]
	   AND
	   .UNIT EQL .MVL_ADDR [ .I, MVL$B_RVN ]
	THEN
	BEGIN
	   KERNEL_CALL(SEND_ERRLOG,0,.UCB_LIST[.UNIT]);
	   MVL_ADDR [ .I, MVL$V_MOUNTED ] = 0;
	   SYS$QIOW ( 0, .IO_CHANNEL,
		      IO$_UNLOAD OR IO$M_NOWAIT OR IO$M_CLSEREXCP,
		      0, 0, 0, 0, 0, 0, 0, 0, 0);
	   EXITLOOP;
	END;
    END;


ROUTINE CLPREV_MAKECUR (UNIT, VOL) : MVL_UCB NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine clears the previous use of this unit in the
!	mag tape volume list and makes the unit and rel volume current
!
! CALLING SEQUENCE:
!	CLPREV_MAKECUR(ARG1,ARG2), CALLED IN KERNEL MODE
!
! INPUT PARAMETERS:
!	ARG1 - relative unit number
!	ARG2 - relative volume number
!
! IMPLICIT INPUTS:
!	CURRENT_VCB - address of current volume control block
!	MVL_ENTRY - address of current entry in mvl for volume
!	UCB_LIST - address of ucb's available for this unit
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	if volume currently mounted on unit, rewind issued
!
!--

    BEGIN

    EXTERNAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK,	! address of current rel vol in mvl
	UCB_LIST = 10	: REF VECTOR,	! address of UCB's
	COMMON_REG;

    LOCAL
	CCB		: REF BBLOCK,		! addr of ACP IO channel
						!   control block
	MVL		: REF BBLOCK,		! addr magtape volume list
	MVL_ADDR	: REF BBLOCKVECTOR [10, MVL$K_LENGTH],
						! address of MVL entries
	NVOLS;


    CCB = GET_CCB ( .IO_CHANNEL );		! calc ACP IO CCB
    MVL = .CURRENT_VCB[VCB$L_MVL];		! address of mvl control block
    NVOLS = .MVL[MVL$B_NVOLS];			! number of relative volume
    MVL_ADDR = .MVL + MVL$K_FIXLEN;		! addr of entries for rel vol

    INCR I FROM 0 TO .NVOLS - 1 DO 		! check each relative volume
	BEGIN

	IF .MVL_ADDR[.I, MVL$V_MOUNTED]
	    AND
	    					! if mounted
	    .UNIT EQL .MVL_ADDR[.I, MVL$B_RVN]	! on unit about to be used
	THEN
	    BEGIN

	    KERNEL_CALL(SEND_ERRLOG, 0, .UCB_LIST[.UNIT]);
						! before mounted is cleared!!
	    MVL_ADDR[.I, MVL$V_MOUNTED] = 0;	! mark it dismounted,

	    ! assign channel to it's unit,
	    !
	    CCB[CCB$L_UCB] = .UCB_LIST[.UNIT];
	    SYS$QIOW(0, .IO_CHANNEL, 
		     IO$_UNLOAD	OR IO$M_NOWAIT OR IO$M_CLSEREXCP,
		     0,0,0,0,0,0,0,0,0 ); ! unload the tape, please
	    EXITLOOP;

	    END;

	END;

    MAKE_CUR_VOL(.UNIT, .VOL);
    END;					! end of routine CLPREV_MAKECUR

ROUTINE MAKE_CUR_VOL (UNIT, VOL) : NOVALUE MVL_UCB =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine makes the relative volume number on the rel unit the
!	current volume it notes that the current volume is mounted on this
!	relative unit
!
! CALLING SEQUENCE:
!	MAKE_CUR_VOL(ARG1,ARG2) in kernel mode
!
! INPUT PARAMETERS:
!	ARG1 - relative unit number on which the relative volume is mounted
!	ARG2 - relative volume number(starts at 1)
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK,	! address of current rel vol in mvl
	UCB_LIST = 10	: REF VECTOR,	! address of ucb's allocated
	COMMON_REG;

    LOCAL
	CCB	: REF BBLOCK;		! address of channel control block

    ! calculate address of channel control block
    !
    CCB = GET_CCB ( .IO_CHANNEL );

    ! assign channel to unit and set current ucb
    !
    CCB[CCB$L_UCB] = .UCB_LIST[.UNIT];
    CURRENT_UCB = .UCB_LIST[.UNIT];

    ! now set volume control block fields
    !
    CURRENT_VCB[VCB$W_RVN] = .UNIT;
    CURRENT_VCB[VCB$B_CUR_RVN] = .VOL;

    ! note which unit the volume is mounted on
    !
    MVL_ENTRY [ MVL$B_RVN ] = .UNIT;
    END;					! end of routine MAKE_CUR_VOL

ROUTINE MAKE_VOL_ENTRY (VOL, MVL) : COMMON_CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine puts a relative volume in the magnetic tape volume
!	list by making a new block and deallocating the old one
!
! CALLING SEQUENCE:
!	MAKE_VOL_ENTRY(ARG1,ARG2), CALLED IN KERNEL MODE
!
! INPUT PARAMETERS:
!	ARG1 - volume number
!	ARG2 - address of magnetic tape volume list
!
! IMPLICIT INPUTS:
!	CURRENT_VCB - address of current volume control block
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	MVL rebuilt
!
! ROUTINE VALUE:
!	address of mvl control block
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_REG;

    MAP
	MVL	: REF BBLOCK;			! addr of mag tape volume list

    LOCAL

	MVL_ADDR: REF BBLOCKVECTOR [10, MVL$K_LENGTH],
						! address of MVL control block
	NEWMVL	: REF BBLOCK,			! address of new MVL
	NVOL;					! number of volumes

    EXTERNAL ROUTINE
	ALLOCATE,				! allocate non_paged system mem
	DEALLOCATE;				! deallocate non_paged sys mem

    VOL	 = .VOL + 4;				! grab some extra slots
    NVOL = .MVL[MVL$B_NVOLS];			! get # of vols it will hold
    NEWMVL = ALLOCATE((.VOL*MVL$K_LENGTH) + MVL$K_FIXLEN);
					        ! allocate non_paged sys space

    ! initialize new MVL
    !
    NEWMVL[MVL$B_TYPE]	= DYN$C_MVL;
    NEWMVL[MVL$L_VCB]	= .CURRENT_VCB;
    NEWMVL[MVL$B_NVOLS] = .VOL;

    ! copy all the old volume labels, File-Set-ID, and Vol_Acc
    !
    CH$MOVE(.MVL[MVL$W_SIZE] - 12, .MVL + 12, .NEWMVL + 12);

    ! blank new relative volume lables
    !
    MVL_ADDR = .NEWMVL + MVL$K_FIXLEN;
    INCR I FROM .NVOL TO .VOL - 1 DO
	BEGIN
	CH$FILL(' ', MVL$S_VOLLBL, MVL_ADDR[.I, MVL$T_VOLLBL]);
	MVL_ADDR [ .I, MVL$V_UNUSED  ] = 1;
	MVL_ADDR [ .I, MVL$V_MOUNTED ] = 0;
	END;

    ! set pointers to the new
    !
    CURRENT_VCB[VCB$L_MVL] = .NEWMVL;
    
    ! get rid of the old
    !
    DEALLOCATE(.MVL);

    RETURN .NEWMVL;

    END;					! end of routine MAKE_VOL_ENTRY

ROUTINE CREATE_LABEL (VOL, MVL) : COMMON_CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine will create a label for a given volume if it does not
!	already have a label. It does this by getting the first four characters
!	of the label from the MVL of the previous reel in the volume set;
!	padding the blanks with the underscore character and putting in the
!	RVN of the current reel as the last two chars. This means
!	that only up to 99 different labels can be generate for a given volume
!	set.
!	
!
! CALLING SEQUENCE:
!	CREATE_LABEL(ARG1,ARG2), CALLED IN KERNEL MODE
!
! INPUT PARAMETERS:
!	ARG1 - volume number
!	ARG2 - address of magnetic tape volume list
!
! IMPLICIT INPUTS:
!	CURRENT_VCB - address of current volume control block
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	MVL for the current reel is given a Volume Label
!
! ROUTINE VALUE:
!	True : The label could be generated
!	False : The label could not be generated
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_REG;

    MAP
	MVL	: REF BBLOCK;			! addr of mag tape volume list

    LOCAL

	CUR_MVL_ADDR: REF BBLOCK,
						! address of MVL control block
	PRE_MVL_ADDR: REF BBLOCK,
						! address of MVL control block
	LABEL_ADDR : REF VECTOR [,BYTE],	! Place in label top reel numb
	NUMBER_OF_TAPE,				! Number of current reel mod 99
	DESCR : VECTOR [2];			! Descr for FAO string 

! Get the number of he previous  volume
! and if that volume number is less than 0 then the current volume we
! are using must be the first volume in the reel
!
	IF (.VOL-1) LEQ 0 THEN RETURN FALSE;

! Get the individual MVL portion of the MVL block
! and move he first four chars of the previous reel's label into 
! the current reels' label

	PRE_MVL_ADDR = .MVL + MVL$K_FIXLEN + ((( .VOL-1 ) - 1) * MVL$K_LENGTH);
	CUR_MVL_ADDR = .MVL + MVL$K_FIXLEN + (( .VOL-1 ) * MVL$K_LENGTH);
	CH$MOVE ((MVL$S_VOLLBL-2), PRE_MVL_ADDR [ MVL$T_VOLLBL ],
		 CUR_MVL_ADDR [ MVL$T_VOLLBL ]);

! Check thru the new label for blanks and overwrite them with the underscore
! character.

	LABEL_ADDR = CUR_MVL_ADDR [ MVL$T_VOLLBL ];
	DECR I FROM MVL$S_VOLLBL TO 2 DO
	   IF .LABEL_ADDR [ .I ] EQL ' ' 
	   THEN LABEL_ADDR [ .I ] = %C'_';

! Now check to see if the RVN of this reel is greater then 99 decimal. If
! it is then set it to the RVN modulo 99.

	NUMBER_OF_TAPE = .VOL;
	IF .NUMBER_OF_TAPE GTR 99
	  THEN NUMBER_OF_TAPE = (.NUMBER_OF_TAPE MOD 99);

! Set up the descriptors for the call to FAO and call FAO to convert the number
! to an ASCII string and insert it into the label field in the MVL of the
! current volume. Then set that the MVL is used and return to caller.

	DESCR[0] = 2;					! Size of output buffer
	DESCR[1] = CUR_MVL_ADDR [ MVL$T_VOLLBL ] + (MVL$S_VOLLBL-2);
							! Addr of output buffer
	SYS$FAO (DESCRIPTOR ('!2ZB'),
		 0,
		 DESCR,
		 .NUMBER_OF_TAPE);
	CUR_MVL_ADDR[ MVL$V_UNUSED ] = 0;
	RETURN TRUE;
    END;



ROUTINE ASSUME_MOUNTED : NOVALUE MVL_UCB =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine indicates that the volume is mounted
!	and sets position pointers to the beginning of tape
!
! CALLING SEQUENCE:
!	ASSUME_MOUNTED(ARG1), CALLED IN KERNEL MODE
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MVL_ENTRY - address of current rel volume entry in mvl
!	CURRENT_VCB - address of current volume control block
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK,
	COMMON_REG;

    MVL_ENTRY [ MVL$V_MOUNTED  ] = 1;		! set it mounted
    CURRENT_VCB[VCB$B_TM]	 = 0;
    CURRENT_VCB[VCB$L_ST_RECORD] = 0;
    CURRENT_VCB[VCB$V_LOGICEOVS] = 0;
    END;				    ! end of routine ASSUMED_MOUNTED

ROUTINE OPERATOR_LBL : MVL_UCB =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine records the label entered by the operator
!
! CALLING SEQUENCE:
!	OPERATOR_LBL, CALLED IN KERNEL MODE
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	operator mailbox message and size
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Magnetic Tape volume label
!
! ROUTINE VALUE:
!	Value of error number
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK,
	COMMON_REG;

    EXTERNAL				! translation table for ANSI 'a' char
	ANSI_A_BAD	: VECTOR [ , BYTE ],
	ESC_CHAR	: BYTE;

    LOCAL
	OPR_INPUT	: REF VECTOR [, BYTE],
	TEMP_LABEL	: VECTOR [ MVL$S_VOLLBL, BYTE ];


    OPR_INPUT = MAIL[OPC$L_MS_TEXT];

    ! check length of label for volume
    !
    IF .MAILSZ GTRU MVL$S_VOLLBL
    THEN RETURN INIT$_MTLBLLONG
    ELSE
	BEGIN

	! translate the label into upper case and test for invalid characters
	!
	IF 0 NEQ MOVTUC ( MAILSZ, MAIL[OPC$L_MS_TEXT], ESC_CHAR, ANSI_A_BAD, 
			  %REF ( MVL$S_VOLLBL ), TEMP_LABEL )
	THEN RETURN INIT$_MTLBLNONA
	ELSE
	    BEGIN
	    CH$COPY ( .MAILSZ, TEMP_LABEL, ' ',
		      MVL$S_VOLLBL, MVL_ENTRY [ MVL$T_VOLLBL ] );
	    MVL_ENTRY [ MVL$V_UNUSED ] = 0;
	    RETURN 1;
	    END;
	END;
    END;			    ! end of routine OPERATOR_LBL

ROUTINE CHECK_RING : COMMON_CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!	Check to see if the write ring is in the tape.
!
! CALLING SEQUENCE:
!	CHECK_RING ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	CURRENT_VCB - address of current volume control block
!	IO_CHANNEL - ACP IO channel
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	0 - the volume is Hardware write lock	    ( NO RING )
!	1 - the volume is NOT Hardware write lock   ( RING )
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_REG;

    EXTERNAL ROUTINE
	ISSUE_IO	: L$ISSUE_IO;

    EXTERNAL
	IO_STATUS	: VECTOR [ 2, LONG ],	! QIO's Status
	USER_STATUS	: VECTOR [ 2, LONG ];	! User's Status

    LOCAL
	STATUS		: LONG;			! status of IO

    ! get at the information nicely

    BIND DEVICE_DEPENDENT = IO_STATUS [ 1 ] : BBLOCK;


    ! do a sensemode operation

    STATUS = ISSUE_IO ( IO$_SENSEMODE, 0, 0 );

    IF NOT .STATUS
    THEN
	BEGIN
	USER_STATUS[0] = .STATUS;
	USER_STATUS[1] = SS$_FCPREADERR;
	ERR_EXIT();
	END;

    RETURN NOT (.DEVICE_DEPENDENT [ MT$V_HWL ]);
    END; 			    ! end of routine CHECK_RING


ROUTINE CHECK_ACCESS ( FLAGS ): MVL_UCB =

!++
!
! FUNCTIONAL DESCRIPTION:
!	this routine check the user's access rights to a tape reel
!
! CALLING SEQUENCE:
!	CHECK_ACCESS ( ARG1 )
!
! INPUT PARAMETERS:
!	ARG1 - the mount_volume flages ( passed by value )
!
! IMPLICIT INPUTS:
!	This routine assumes that the operator has responed to the MTAACP via
!	the REPLY command and that MAIL[OPC$W_MS_STATUS] is set to some value
!	according to that responce.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	MVL_ENTRY [ MVL$V_OVERIDE ] is set correctly
!
! ROUTINE VALUE:
!	TRUE  - if the uses has the needed rights to access the tape
!	FALSE - otherwise
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

    BEGIN

    MAP
	FLAGS		: BBLOCK;

    EXTERNAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK,	! addr of MVL entry for current vol
	COMMON_REG;

    EXTERNAL				! translation table for ANSI 'a' char
	ANSI_A_GOOD	: VECTOR [ , BYTE ];

    LOCAL
	ACCESS,				! Access to tape from $MTACCESS
	CURRENT_RECORD,			! current record tape drive is reading
	DEVCHAR		: REF BBLOCK,
	TEMP_LABEL	: VECTOR [ VL1$S_VOLLBL, BYTE ],
	TAPE_OWNER_STS	: LONG,
	VMS_TAPE,
	STATUS		: LONG,
	ORB		: REF BBLOCK,	! ORB address
	MVL		: REF BBLOCK,
	SCRATCH		: REF BBLOCK,
	WRITE_RING	: BITVECTOR [1];

    EXTERNAL
	HDR1		: REF BBLOCK;	! address of HDR1(EOF1) label


    ! get a handle on the current MVL

    MVL = .CURRENT_VCB[VCB$L_MVL];

    ! setup address of scratch area and read the VOL1 label

    SCRATCH = .HDR1 + SCRATCH_OFFSET;

    ! setup default tape owner and protection

    ORB = .CURRENT_UCB[UCB$L_ORB];
    TAPE_OWNER = .ORB[ORB$L_OWNER];
    TAPE_PROT = 0;

    ! read the first block on the tape

    STATUS = READ_BLOCK(.SCRATCH, ANSI_LBLSZ);

    ! if this is ( a NOT valid ANSI tape) 

    IF  NOT ( .STATUS AND (.SCRATCH[VL1$L_VL1LID] EQL 'VOL1'))
    THEN
	BEGIN

	! AND a valid init THEN RETURN

	IF (      (.MAIL[OPC$W_MS_STATUS] EQL (OPC$_INITAPE AND %X'FFFF'))
	      OR  .CURRENT_VCB[VCB$V_INIT]
	      AND (NOT (.FLAGS[MOU$V_LBLCHECK] OR .FLAGS[MOU$V_CHKIFSPC]))
	   )
	THEN
	    BEGIN
	    KERNEL_CALL ( SET_MVL_OVERIDE, TRUE );
	    RETURN TRUE;
	    END
	
	! else it is an error

	ELSE
	    BEGIN
	    PRINT_OPR_MSG(MOUN$_NOTANSI, 0,
			.CVT_DEVNAM_LENGTH, CVT_DEVNAM);
	    RETURN FALSE;
	    END;
	END;

   ! Set the override switch in this volumes portion of the MVL.
   ! If the user has specified override privilege in the MOUNT command.

   KERNEL_CALL ( SET_MVL_OVERIDE, .MVL [ MVL$V_OVRPRO ]);

   ! Call the accessibility system service to check the accessibility char
   ! on the VOL1 label.
   ! First keep the record that the UCB is reading. The accessibility 
   ! routine can not move the tape from under us! Thus we will compare
   ! this to the field after the call and if the tape was moved we punt
   ! the operation. Then check the codes that the routine can return
   ! to make sure the user has access to the tape.

   CURRENT_RECORD = KERNEL_CALL (GET_RECORD, .CURRENT_UCB);
   ACCESS = $MTACCESS(LBLNAM = .SCRATCH,
		      UIC = .ORB[ORB$L_OWNER],
		      STD_VERSION = .MVL[MVL$B_STDVER],
		      ACCESS_CHAR = 0,
		      ACCESS_SPEC = MTA$K_NOCHAR,
		      TYPE = MTA$K_INVOL1);

    STATUS = KERNEL_CALL(GET_RECORD, .CURRENT_UCB);
    IF .CURRENT_RECORD NEQ .STATUS
	THEN 
	BEGIN
	   PRINT_OPR_MSG( MOUN$_TAPEPOSLOST,0,
			  .CVT_DEVNAM_LENGTH, CVT_DEVNAM);
	   RETURN FALSE;
	END;

    IF .ACCESS EQL SS$_FILACCERR
	THEN
	BEGIN
	   IF NOT (.CURRENT_VCB[VCB$V_OVRACC] AND .MVL_ENTRY[MVL$V_OVERIDE])
		THEN
		BEGIN
		   PRINT_OPR_MSG(MOUN$_ACCERR, 0,
				.CVT_DEVNAM_LENGTH, CVT_DEVNAM);
		   RETURN FALSE;
		END;
	   ACCESS = SS$_NORMAL;
	END;

    IF .ACCESS EQL SS$_NOVOLACC
	THEN
	BEGIN
	   PRINT_OPR_MSG(MOUN$_NOVOLACC, 0,
			.CVT_DEVNAM_LENGTH, CVT_DEVNAM);
	   RETURN FALSE;
	END;

    IF .ACCESS EQL SS$_NOFILACC
	THEN
	BEGIN
	   PRINT_OPR_MSG(MOUN$_NOFILACC, 0,
			.CVT_DEVNAM_LENGTH, CVT_DEVNAM);
	   RETURN FALSE;
	END;


    ! Find out who owns the tape. If the field is in VMS format then
    ! treat the field like the protection field in the VOL2 label.

    TAPE_OWNER_STS = (TAPE_OWN_PROT ( TAPE_OWNER, TAPE_PROT, 
			  .ORB[ORB$L_OWNER], .SCRATCH ));

    ! Set the override switch in this volumes portion of the MVL.
    ! If the users UIC matches the UIC of the volume or the user
    ! has priv.

    KERNEL_CALL ( SET_MVL_OVERIDE,
		  (    (.TAPE_OWNER EQL .ORB[ORB$L_OWNER])
		    OR .MVL [ MVL$V_OVRPRO ]));

    ! If the ACCESS field allows to check the VMS volume protection then
    ! do so using the following rule:
    ! If the owner identifier field of the VOL1 label was not a VMS protection
    ! and this is a pre ANSI standard version 4 tape and there was D% INFO
    ! in the volume field then make sure that the user has the correct priv's
    ! to mount the tape.
    ! Else reset the VMS protection such that the user has complete access.

    IF .ACCESS 
	THEN 
	BEGIN
	   IF NOT .TAPE_OWNER_STS
	      AND ( NOT (.CURRENT_VCB[VCB$V_OVRVOLO] 
		    AND .MVL_ENTRY[MVL$V_OVERIDE]))
		THEN
		BEGIN
		   PRINT_OPR_MSG(MOUN$_VOLOERR,0,.CVT_DEVNAM_LENGTH,CVT_DEVNAM);
		   RETURN FALSE;
		END
	END
	ELSE
	   TAPE_PROT = 0;

    ! Check to see if this tape was created on VMS. If it was then we will
    ! want to process to VOL2 label if there is one.

    IF CH$EQL(10,STARID,10,SCRATCH[VL1$T_SYSCODE],0)
	THEN VMS_TAPE = 1
	ELSE VMS_TAPE = 0;

    ! Read the VOL2 label if specified and use this as the VMS protection 
    ! for the tape, unless the ACCESS is set such that the user has complete 
    ! access to the volume. After we have read the VOL2 label we want to be sure
    ! to reposition the tape back to teh VOL1 label to continue processing
    ! the ANSI VOL1 label. 

    STATUS = READ_BLOCK (.SCRATCH, ANSI_LBLSZ);
    IF .VMS_TAPE AND .SCRATCH[VL2$L_VL2LID] EQL 'VOL2'
	THEN 
	BEGIN
	   PROCESS_VOL2_LABEL(TAPE_OWNER,TAPE_PROT,
			     .ORB[ORB$L_OWNER],.SCRATCH);
	   IF NOT .ACCESS
		THEN TAPE_PROT = 0;
	END;

    ! Set the tape back to the begining and reread the VOL1 label.

    IF NOT REWIND_AND_WAIT()
	THEN
	BEGIN
	   PRINT_OPR_MSG(MOUN$_IOERROR,0,.CVT_DEVNAM_LENGTH,CVT_DEVNAM);
	   RETURN FALSE;
	END;
    STATUS = READ_BLOCK (.SCRATCH, ANSI_LBLSZ);


    ! Translate the VOL1 label into upper case and put in '@' for any non-ANSI
    !  a characters found  ( this is done for backward compatiblility )

    CH$TRANSLATE ( ANSI_A_GOOD, VL1$S_VOLLBL, SCRATCH[VL1$T_VOLLBL], ' ',
				VL1$S_VOLLBL, TEMP_LABEL );

    ! Labels spec either generated buy the MTAACP or supplied by teh oper
    ! must match except under the following circumstances:
    !   A valid "REPLY/INIT" or "MOUNT/INIT"
    !   A valid no label need be specified
    !   A valid "MOUNT/OVER=ID"

    IF 
	    (	(   .FLAGS[MOU$V_LBLCHECK]
		 OR .FLAGS[MOU$V_CHKIFSPC]
		 OR ( NOT .CURRENT_VCB[VCB$V_INIT]
			AND (.MAIL[OPC$W_MS_STATUS]
				NEQ (OPC$_INITAPE AND %X'FFFF')))
		)
	      AND
		NOT (.FLAGS[MOU$V_CHKIFSPC] AND (NOT .LABEL_SPEC [ 0 ]))
	      AND
		NOT (.CURRENT_VCB[VCB$V_OVRLBL] AND .MVL_ENTRY[MVL$V_OVERIDE])
	    )
	AND CH$NEQ ( MVL$S_VOLLBL, MVL_ENTRY[MVL$T_VOLLBL], 
		     VL1$S_VOLLBL, TEMP_LABEL )
    THEN
	BEGIN
	PRINT_NOT_LABEL(.MVL_ENTRY);
	RETURN FALSE;
	END;

    ! check VMS volume UIC protection or user has bypass, sysprv or volpro

    DEVCHAR = CURRENT_UCB[UCB$L_DEVCHAR];
    WRITE_RING [0] = .DEVCHAR <$BITPOSITION(DEV$V_SWL) ,1>;
    IF NOT (	KERNEL_CALL ( CHECK_PROT, TAPE_PROT, TAPE_OWNER,
			       .ORB[ORB$L_OWNER], 
			       WRITE_RING)
	     OR .MVL [ MVL$V_OVRPRO ]
	   )
    THEN
	BEGIN
	PRINT_OPR_MSG(MOUN$_NOPRIV, 0,
			.CVT_DEVNAM_LENGTH, CVT_DEVNAM);
	RETURN FALSE;
	END;

    ! set override switches are valid in the MVL if a valid init

    DEVCHAR <$BITPOSITION(DEV$V_SWL) ,1> = .WRITE_RING [0] ;
    IF NOT (.FLAGS[MOU$V_LBLCHECK] OR .FLAGS[MOU$V_CHKIFSPC])
    THEN KERNEL_CALL ( SET_MVL_OVERIDE, TRUE );

    RETURN TRUE;
    END;			    ! end of routine CHECK_ACC

ROUTINE SET_MVL_OVERIDE ( VALUE ) : NOVALUE MVL_UCB =

!++
!
! FUNCTIONAL DESCRIPTION:
!	this routine sets the MVL "can override" bit for this reel
!
! CALLING SEQUENCE:
!	SET_MVL_OVERIDE(ARG1)	 KERNEL CALL!!!!
!
! INPUT PARAMETERS:
!	ARG1 - the value to which the bit should be set ( passed by value )
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	MVL_ENTRY = 9	: REF BBLOCK;

    MVL_ENTRY [ MVL$V_OVERIDE ] = .VALUE;
    
    END;				    ! end of Routine SET_MVL_OVERIDE

END

ELUDOM
