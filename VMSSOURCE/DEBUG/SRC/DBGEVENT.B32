MODULE DBGEVENT (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Sidney R Maxwell III	May, 1982
!
! MODULE FUNCTION
!	This module contains the support routines for the new event-points.
!	Included are the syntax and semantics routines for processing the
!	new command forms, and the support for the new data structures.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY	'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$EVENT_INITIALIZATION : NOVALUE, ! Initialize the event structures
    DBG$EVENT_SYNTAX,			! Handle BREAK/TRACE/WATCH syntax
    DBG$EVENT_SEMANTICS,		! Handle BREAK/TRACE/WATCH semantics
    DBG$EVENT_SHOW_CANCEL_SYNTAX,	! [SHOW|CANCEL] BREAK/TRACE/WATCH syntax
    DBG$EVENT_SHOW_CANCEL_SEMANTICS,	! Handle BREAK/TRACE/WATCH semantics
    DBG$EVENT_CANCEL_ALL: NOVALUE,	! Cancel all eventpoints
    DBG$ACTIVATE_EVENTS: NOVALUE,	! Activate all set events
    DBG$ACTIVATE_EVENT: NOVALUE,	! Activate a set event
    DBG$DEACTIVATE_EVENTS: NOVALUE,	! Deactivate all set events
    DBG$DEACTIVATE_EVENT: NOVALUE,	! Deactivate a set event
    DBG$EXCEPTION_HANDLER,		! Event Exception Handler
    DBG$PROCESS_EVENT,			! Process an event
    DBG$UPDATE_WATCHPOINTS: NOVALUE,	! Update the current value of each watchpoint
    ANNOUNCE_EVENT: NOVALUE,		! Announce an event
    INSQUE1: NOVALUE,			! Insert a queue entry (1st vs 0th)
    REMQUE1: NOVALUE,			! Remove a queue entry (1st vs 0th)
    SHOW_EVENT_ENTRY: NOVALUE,		! Show an Event Entry
    DELETE_EVENT_ENTRY: NOVALUE,	! Delete an Event Entry (et al)
    PRINT_SOURCE: NOVALUE,		! Print a source line
    PRINT_PC_AND_INSTRUCTION: NOVALUE,	! Print PC and instruction
    PRINT_PC_INST_HANDLER,		! Handler for above
    COMPARE_VMSDESC,			! ???
    GET_WATCH_POINT_VALUE: NOVALUE,	! Get the value of the watch pointing
    					!        variable
    PRIM_TO_VAL: NOVALUE,		! Local cover routine for DBG$PRIM_TO_VAL
    PRIM_TO_VAL_HANDLER,		! Handler for above
    PARSE_WHEN_CONDITION: NOVALUE,	! Handler to catch the bad status
					!	 from parsing the WHEN clause
    MATCH_RIGHT_CALL_FRAME;		! Make sure the call frame we got is
					!        the one we set bit 15 in saved
					!        PSW

EXTERNAL ROUTINE
    DBG$NGET_ADDRESS,			! Get and address from a primary
    DBG$MAKE_VAL_DESC,			! VMS desc to valdesc
    DBG$PRIM_TO_VAL,			! Get a value descriptor from a primary
    DBG$NGET_SYMID,			! Get a SYMID
    DBG$NCOPY_DESC,			! Copy a primary descriptor
    DBG$NFREE_DESC,			! Free a primary descriptor
    DBG$STA_LOCK_SYMID,			! Lock a SYMID
    DBG$STA_UNLOCK_SYMID,		! Unlock a SYMID
    DBG$PRINT,				! 'Print' an FAO string
    DBG$NEWLINE,			! Dump 'printed' buffer
    DBG$PRINT_VALUE,			! 'Print' a value from a val desc
    DBG$PRINT_IDENTIFIER,		! 'Print' an identifier from a primary
    DBG$PRINT_IDENTIFIER_PC,		! 'Print' an identifier from an address
    DBG$PUTMSG,				! Put an exception message
    DBG$PC_TO_LINE_LOOKUP,		! Match a PC to line
    DBG$SRC_TYPE_PC_SOURCE: NOVALUE,	! Display source line
    DBG$INS_DECODE,			! Decode [and display] instruction
    DBG$OPCODE_INDEX,			! Get opcode from mnemonic
    DBG$FINAL_HANDL,			! DEBUG's final handler
    DBG$READ_ACCESS,			! Check for read access
    DBG$MAP_TO_REG_ADDR,		! Map an address to register space
    DBG$NGET_PAGES,			! Get pages from a primary
    DBG$DATA_LENGTH,			! Get data bit length from VMS descriptor
    DBG$IS_IT_ENTRY,			! Checks address for entry point
    DBG$NMAKE_ARG_VECT,			! Constructs a message argument vector
    DBG$NSAVE_DECIMAL_INTEGER,		! Saves an inline numeric literal
    DBG$NSAVE_BREAK_BUFFER: NOVALUE,	! Saves away a break action buffer
    DBG$GET_MEMORY,			! Get a block of permanent memory
    DBG$REL_MEMORY,			! Release a block of permanent memory
    DBG$GET_TEMPMEM,			! Get a block of temporary memory
    DBG$REL_TEMPMEM,			! Release all of temporary memory
    DBG$RST_TEMP_RELEASE: NOVALUE,	! Release all temporary RST entries
    DBG$NNEXT_WORD,			! Isolates next word for syntax errors
    DBG$NMATCH,				! Routine to match keywords
    DBG$NPARSE_ADDRESS,			! Interface routine to Address Expression Interpreter
    DBG$NPARSE_EXPRESSION,		! Prase an expression
    DBG$NTYPE_CONV,			! Type converter
    DBG$WRITE_MEM,			! Write into memory
    DBG$NCIS_ADD,			! Add command string
    DBG$COMMAND_PROC,			! Execute a command list
    DBG$NINITIALIZE,			! Initialize for user commands
    DBG$NSYNTAX_ERROR,			! Constructs a syntax error message
    DBG$SET_STP_LVL : NOVALUE,		! Set step level
    DBG$PSEUDO_PROG,			! DEBUG's call code
    LIB$SIGNAL: ADDRESSING_MODE (GENERAL),
    LIB$STOP;

EXTERNAL
    DBG$GB_CALL_NORMAL_RET: BYTE,	! CALL command status flag; 0 = not in
					!      a CALL command, 1 = in a CALL
					!      that has not yet returned, 2 =
					!      in normal return from a CALL cmd
    DBG$GB_RADIX: VECTOR[3, BYTE],	! Radix settings
    DBG$GB_LANGUAGE: BYTE,		! Current set lang
    DBG$GL_SIGN_FLAG,			! Flag set to print '+' before signed
					!      variable
    DBG$GV_CONTROL: DBG$CONTROL_FLAGS,	! Major State of DEBUG
    DBG$GB_STP_PTR:			! Current stepping modes
	REF EVENT$STEPPING_DESCRIPTOR,	!
    DBG$GB_MOD_PTR: REF VECTOR[,BYTE], 	! Current mode flags
    DBG$GL_CISHEAD,			! Head of command input stream
    DBG$GL_CIS_LEVELS,			! Number of levels of CIS nesting
    DBG$GL_LIB_SIGNAL_ADDR,		! Address of LIB$SIGNAL
    DBG$GL_LIB_STOP_ADDR,		! Address of LIB$STOP
    DBG$GL_STEP_NUM,			! Step count
    DBG$GB_TAKE_CMD: BYTE,		! User commands okay (no go etc.)
    DBG$RUNFRAME: BLOCK[,BYTE],		! Run frame
    DBG$GB_EXC_BRE_FLAG: BYTE,		! Encountered an exception break
    DBG$GB_GO_ARG_FLAG: BYTE,		! GO command had an argument
    DBG$GB_NO_GLOBALS: BYTE,		! Don't convert to global symbol
    DBG$OPCODE_KIND_TABLE:		! ???
		VECTOR [512,WORD],	!
    DBG$OPCODE_NAME_TABLE:		! ???
		BLOCKVECTOR [,10,BYTE],	!
    DBG$PSEUDO_EXIT,			! Label in pseudo code for CALL
    DBG$PSEUDO_SSI,			! Label in pseudo code for 
					!    DBG_SSI_ROUTINE
    DBG$GB_SET_SSI_CNT: BYTE,		! Is watch pointing active? 
    DBG$TERM_HANDLR,			! Label in termination handler
    DBG$USER_EXIT,			! Label in exit code
    PRIM_HANDL_2,			! Label in primary handler
    DBG$GL_OUTPRAB: BLOCK[,BYTE],	! RAB for 'OUTPUT'
    DBG$GL_ORIG_COMMAND_PTR,		! Pointer to original command string
    DBG$GL_UPCASE_COMMAND_PTR: VECTOR[2];
    					! Pointers to start and end
    					!    of current command string

GLOBAL
    DBG$GB_SET_BREAK_FLAG:		! Set to TRUE during processing
		BYTE INITIAL(0),	!      of address in SET BREAK
    DBG$GB_SET_WATCH_FLAG:		! Set to TRUE during processing
    		BYTE INITIAL (0);	!      of System service cycle
					!      (CALL to RET) for watch point
					!      value comparison

OWN
    INVALID_FLAG,			! Set to TRUE when a Primary becomes
    					!    invalid (PRIM_TO_VAL_HANDLER)
    NEWVALUE: REF DBG$VALDESC,		! New value for watch point variable
    OLDVALUE: REF DBG$VALDESC,		! Old value for watch point variable
    TYPE_SOURCE,			! It's okay to type source
    ACCVIO_PC,				! PC at an ACCVIO
    WATCH_PC,				! PC at next instruction after System
					!      service call when watch pointing
					!      is trigged, used to report watch
					!      point address
    SKIP_ACCVIOS : INITIAL (FALSE),	! We're [not initially] skipping ACCVIO's
    SKIP_WATCHES : INITIAL (FALSE),	! Flag set to indicate We t-bit over RET
					!      of Service call, report watched
					!      value if there is one
    WHEN_CONDITION: REF DBG$VALDESC;	! Condition for WHEN clause

BUILTIN
    INSQUE,				! Insert an entry on a list
    REMQUE,				! Remove an entry from a list
    PROBER;				! Probe a location for read-access

! Define the QUEUE_HEAD data structure, used to reference the head of
! a queue.
!
FIELD
    QUEUE_HEAD_FIELDS =
	SET
	A_QUEUE_ENTRY =	[0,A_],	    ! Queue entry's address

	L_QUEUE_FLINK =	[0,L_],	    ! Queue's 0th (normal) Forward LINK
	L_QUEUE_BLINK =	[1,L_],	    ! Queue's 0th (normal) Backward Link

	L_QUEUE_FLINK1 = [2,L_],    ! Queue's 1st Forward LINK
	L_QUEUE_BLINK1 = [3,L_]	    ! Queue's 1st Backward Link
	TES;


MACRO QUEUE_HEAD = BLOCK [4,LONG] FIELD (QUEUE_HEAD_FIELDS)%;
    
GLOBAL
    EVENT$CMD_QUEUE:	    QUEUE_HEAD,		! Command Queue
    EVENT$DO_LIST_QUEUE:    QUEUE_HEAD,		! DO List Queue
    EVENT$WHEN_QUEUE:	    QUEUE_HEAD,		! WHEN    Queue
    EVENT$PAGE_QUEUE:	    QUEUE_HEAD,		! PAGE    Queue


    ! The following is used to flag a stop, such as from a BREAK or the
    ! end of a STEP, as opposed to a TRACE....
    !
    EVENT$B_STOP_USER :	    BYTE;

OWN
    ! Opcode Table for /INSTRUCTION = (<mnemonic> ,...)
    !
    DBG$OPCODES_USER :	BITVECTOR[512],


    ! Opcode Table for STEP/INSTRUCTION = (<mnemonic> ,...)
    !
    DBG$OPCODES_STEP_USER : BITVECTOR[512],


    ! Opcode Table for /CALL events.
    !
    DBG$OPCODES_CALL :	BITVECTOR[512]
			PRESET
			([%X'0FB'] = 1,	! CALLS
			 [%X'0FA'] = 1,	! CALLG
			 [%X'030'] = 1,	! BSBW
			 [%X'010'] = 1,	! BSBB
			 [%X'016'] = 1,	! JSB
			 [%X'005'] = 1,	! RSB
			 [%X'004'] = 1	! RET
			),


    ! Opcode Table for /BRANCH events.
    !
    DBG$OPCODES_BRANCH :	BITVECTOR[512]
			PRESET
			([%X'012'] = 1,	! BNEQ or BNEQU
			 [%X'013'] = 1,	! BEQL or BEQLU
			 [%X'014'] = 1,	! BGTR
			 [%X'015'] = 1,	! BLEQ
			 [%X'018'] = 1,	! BGEQ
			 [%X'019'] = 1,	! BLSS
			 [%X'01A'] = 1,	! BGTRU
			 [%X'01B'] = 1,	! BLEQU
			 [%X'01C'] = 1,	! BVC
			 [%X'01D'] = 1,	! BVS
			 [%X'01E'] = 1,	! BGEQU or BCC
			 [%X'01F'] = 1,	! BLSSU or BCS
			 [%X'011'] = 1,	! BRB
			 [%X'031'] = 1,	! BRW
			 [%X'017'] = 1,	! JMP
			 [%X'0E0'] = 1,	! BBS
			 [%X'0E1'] = 1,	! BBC
			 [%X'0E2'] = 1,	! BBSS
			 [%X'0E3'] = 1,	! BBCS
			 [%X'0E4'] = 1,	! BBSC
			 [%X'0E5'] = 1,	! BBCC
			 [%X'0E6'] = 1,	! BBSSI
			 [%X'0E7'] = 1,	! BBCCI
			 [%X'0E8'] = 1,	! BLBS
			 [%X'0E9'] = 1,	! BLBC
			 [%X'09D'] = 1,	! ACBB
			 [%X'03D'] = 1,	! ACBW
			 [%X'0F1'] = 1,	! ACBL
			 [%X'04F'] = 1,	! ACBF
			 [%X'06F'] = 1,	! ACBD
			 [%X'14F'] = 1,	! ACBG
			 [%X'16F'] = 1,	! ACBH
			 [%X'0F3'] = 1,	! AOBLEQ
			 [%X'0F2'] = 1,	! AOBLSS
			 [%X'0F4'] = 1,	! SOBGEQ
			 [%X'0F5'] = 1,	! SOBGTR
			 [%X'08F'] = 1,	! CASEB
			 [%X'0AF'] = 1,	! CASEW
			 [%X'0CF'] = 1	! CASEL
			),


    ! Opcode Table for stepping /OVER.
    !
    DBG$OPCODES_STEP_OVER : BITVECTOR[512]
			PRESET
			([%X'0FB'] = 1,	! CALLS
			 [%X'0FA'] = 1,	! CALLG
			 [%X'030'] = 1,	! BSBW
			 [%X'010'] = 1,	! BSBB
			 [%X'016'] = 1	! JSB
			);

MACRO

    ! Calculate word length from bit length.
    !
    BIT_TO_WORD_LENGTH (BIT_LENGTH) =
	((BIT_LENGTH + %BPVAL - 1) / %BPVAL)
    %,


    ! Setup a UPLIT %ASCIC string.
    !
    $AC (STRING) =
	UPLIT BYTE (%ASCIC STRING)
    %,


    ! Test <string> for a match with the input string.
    !
    MATCH (STRING) =
	(DBG$NMATCH(.INPUT_DESC, STRING,
		%IF %NULL (%REMAINING) %THEN 1 %ELSE %REMAINING %FI)) %,


    ! Match <string> to the input string, and give a syntax
    ! error if <string> does not match.
    !
    NEED_MATCH (STRING) =
	(IF NOT MATCH (STRING) THEN SYNTAX_ERROR;) %,


    ! Syntax Error
    !
    SYNTAX_ERROR =
	BEGIN
	.MESSAGE_VECT =
	    (IF MATCH (DBG$CS_CR)
	     THEN
		DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE)
	     ELSE
		DBG$NSYNTAX_ERROR (DBG$NNEXT_WORD (.INPUT_DESC))
	    );
	    RETURN STS$K_SEVERE
	END
    %,


    ! Allocate an adverb node.
    !
    GET_ADVERB_NODE =
	BEGIN
	ADVERB_NODE = DBG$GET_TEMPMEM (DBG$K_ADVERB_NODE_SIZE);
	ADVERB_NODE [DBG$L_ADVERB_LINK] = 0;
	.ADVERB_LINK = .ADVERB_NODE;
	ADVERB_LINK = ADVERB_NODE [DBG$L_ADVERB_LINK]
	END
    %,


    ! Allocate a noun node.
    !
    GET_NOUN_NODE =
	BEGIN
	NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);
	NOUN_NODE [DBG$L_NOUN_LINK] = 0;
	.NOUN_LINK = .NOUN_NODE;
	NOUN_LINK = NOUN_NODE [DBG$L_NOUN_LINK]
	END
    %,


    ! Write an opcode to memory.
    !
    WRITE_OPCODE (ADDRESS, OPCODE) =
	(   LOCAL
		OP;

	    OP = OPCODE;
	    DBG$WRITE_MEM (ADDRESS, OP, 1)
	)
    %;

! Literals
!
LITERAL


    ! Define the adverb literals, used to describe the contents
    ! of an adverb node.
    !
    ENUMERATE	(0, ADVERB_AFTER,
		    ADVERB_TEMPORARY,
		    ADVERB_SILENT,
    		    ADVERB_NOSILENT,
		    ADVERB_WHEN,
		    ADVERB_DO,

		    ADVERB_READ,
		    ADVERB_WRITE,
		    ADVERB_MODIFY,
		    ADVERB_EXECUTE,
		    ADVERB_RETURN,
		    ADVERB_EXCEPTION,
		    ADVERB_SOURCE,
		    ADVERB_NOSOURCE,
		    ADVERB_SYSTEM,
		    ADVERB_NOSYSTEM,
		    ADVERB_INTO,
		    ADVERB_OVER,
		    ADVERB_CALL,
		    ADVERB_BRANCH,
		    ADVERB_LINE,
		    ADVERB_INSTRUCTION,
		    ADVERB_OPCODE,
		    ADVERB_ALL
		);


GLOBAL ROUTINE DBG$EVENT_INITIALIZATION: NOVALUE =
!
! FUNCTION
!	This routine is called to initialize the event structures when
!	DEBUG is first entered.
!
! INPUTS
!	None
!
! OUTPUTS
!	None
!

    BEGIN


    ! Intialize the head of the Command Queue.
    !
    EVENT$CMD_QUEUE [L_QUEUE_FLINK] = EVENT$CMD_QUEUE;
    EVENT$CMD_QUEUE [L_QUEUE_BLINK] = EVENT$CMD_QUEUE;
    EVENT$CMD_QUEUE [L_QUEUE_FLINK1] = EVENT$CMD_QUEUE;
    EVENT$CMD_QUEUE [L_QUEUE_BLINK1] = EVENT$CMD_QUEUE;


    ! Initialize the head of the DO List Queue.
    !
    EVENT$DO_LIST_QUEUE [L_QUEUE_FLINK] = EVENT$DO_LIST_QUEUE;
    EVENT$DO_LIST_QUEUE [L_QUEUE_BLINK] = EVENT$DO_LIST_QUEUE;


    ! Initialize the head of the WHEN Queue.
    !
    EVENT$WHEN_QUEUE [L_QUEUE_FLINK] = EVENT$WHEN_QUEUE;
    EVENT$WHEN_QUEUE [L_QUEUE_BLINK] = EVENT$WHEN_QUEUE;


    ! Initialize the head of the PAGE Queue.
    !
    EVENT$PAGE_QUEUE [L_QUEUE_FLINK] = EVENT$PAGE_QUEUE;
    EVENT$PAGE_QUEUE [L_QUEUE_BLINK] = EVENT$PAGE_QUEUE;
    END;

GLOBAL ROUTINE DBG$EVENT_SYNTAX(INPUT_DESC, VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine parses a step, break, trace, or watch point command,
!	after the '[SET] STEP', 'SET BREAK', 'SET TRACE', or 'SET WATCH'
!	has been parsed.  This routine is called from DBGNSET (or DBGNSTEP).
!
!	The following syntax is accepted:
!
!	SET [ BREAK | TRACE | WATCH ]
!	    [ /AFTER : <n> ] 
!	    [ /TEMPORARY ]
!	    [ /[NO]SILENT ]
!	    <event>
!	    [ WHEN (<expression>) ]
!	    [ DO (<command list>) ]
!
!	If the event is a watchpoint, <event> is:
!
!	<address> [ , <address> ]*
!
!	otherwise, <event> is:
!
!	[ /READ | /WRITE | /MODIFY | /EXECUTE | /RETURN ]
!	    <address> [ , <address> ]* |
!	[ /EXCEPTION ] |
!	[ /[NO]SOURCE | /[NO]SYSTEM | /INTO | /OVER ]*
!	    [  /CALLS | /RETURN | /BRANCH | /LINE | /INSTRUCTION
!		[ = [ <mnemonic> | ( <mnemonic> [ , <mnemonic> ] ) ]]
!	    ]
!
!	SET STEP
!	[ [NO]SILENT 
!	[ [NO]SOURCE | [NO]SYSTEM | INTO | OVER ]*
!	    [  CALLS | RETURN | BRANCH | LINE | INSTRUCTION
!		[ = [ <mnemonic> | ( <mnemonic> [ , <mnemonic> ] ) ]]
!	    ]
!
!	STEP
!	[ /[NO]SILENT 
!	[ /[NO]SOURCE | /[NO]SYSTEM | /INTO | /OVER ]*
!	    [  /CALLS | /RETURN | /BRANCH | /LINE | /INSTRUCTION
!		[ = [ <mnemonic> | ( <mnemonic> [ , <mnemonic> ] ) ]]
!	    ]
!
!
! INPUTS
!	INPUT_DESC:	The current command line input descriptor.
!	VERB_NODE:	A pointer to a DEBUG verb node, with the COMPOSITE
!			attribute set to EVENT$K_SET_BREAK, EVENT$K_SET_TRACE,
!			EVENT$K_SET_WATCH, EVENT$K_SET_STEP, or EVENT$K_STEP.
!
!	MESSAGE_VECT:	The address of a longword to contain the address
!			of a message argument vector.
!
! OUTPUTS
!	The parse tree headed by VERB_NODE is created to represent the
!	command parsed.  Errors cause this routine to return STS$K_SEVERE,
!	otherwise STS$K_SUCCESS.
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Verb node pointer

    LOCAL
	STATUS,				! Returned status
	ADVERB_NODE: REF DBG$ADVERB_NODE, ! Adverb node pointer
	ADVERB_LINK: REF DBG$ADVERB_NODE, ! Adverb node link
	NOUN_NODE: REF DBG$NOUN_NODE,	! Noun node pointer
	NOUN_LINK: REF DBG$NOUN_NODE,	! Noun node link
	CMD_TYPE,			! Command type
	CMD_KIND,			! Command Kind
	SUB_KIND,			! Command sub-kind
	AFTER_COUNT,			! After count
	TEMPORARY,			! Temporary flag
	SILENT,				! Silent flag
	SOURCE,				! Source flag
	NOSILENT,			! Nosilent flag
	NOSOURCE,			! Nosource flag
	SYSTEM,				! System flag
	NOSYSTEM,			! Nosystem flag
	INTO,				! Into flag
	OVER;				! Over flag


    BIND


	! Define the character strings to parse.
	!
	DBG$CS_AFTER =		$AC ('AFTER'),
	DBG$CS_TEMPORARY =	$AC ('TEMPORARY'),
	DBG$CS_SILENT =		$AC ('SILENT'),
    	DBG$CS_NOSILENT =	$AC ('NOSILENT'),
	DBG$CS_WHEN =		$AC ('WHEN'),
	DBG$CS_DO =		$AC ('DO'),
	DBG$CS_READ =		$AC ('READ'),
	DBG$CS_WRITE =		$AC ('WRITE'),
	DBG$CS_MODIFY =		$AC ('MODIFY'),
	DBG$CS_EXECUTE =	$AC ('EXECUTE'),
	DBG$CS_RETURN =		$AC ('RETURN'),
	DBG$CS_SOURCE =		$AC ('SOURCE'),
	DBG$CS_NOSOURCE =	$AC ('NOSOURCE'),
	DBG$CS_SYSTEM =		$AC ('SYSTEM'),
	DBG$CS_NOSYSTEM =	$AC ('NOSYSTEM'),
	DBG$CS_INTO =		$AC ('INTO'),
	DBG$CS_OVER =		$AC ('OVER'),
	DBG$CS_EXCEPTION =	$AC ('EXCEPTION'),
	DBG$CS_CALL =		$AC ('CALLS'),
	DBG$CS_BRANCH =		$AC ('BRANCH'),
	DBG$CS_LINE =		$AC ('LINE'),
	DBG$CS_INSTRUCTION =	$AC ('INSTRUCTION'),
	DBG$CS_EQUALS =		$AC ('='),
	DBG$CS_L_PAREN =	$AC ('('),
	DBG$CS_R_PAREN =	$AC (')'),
	DBG$CS_COMMA =		$AC (','),
	DBG$CS_SLASH =		$AC ('/'),
	DBG$CS_COLON =		$AC (':'),
	DBG$CS_CR =		UPLIT BYTE (1, DBG$K_CAR_RETURN);



    ! Initialize the verb's adverb and noun pointers to null.
    !
    VERB_NODE [DBG$L_VERB_ADVERB_PTR] = 0;
    VERB_NODE [DBG$L_VERB_OBJECT_PTR] = 0;


    ! Initialize the adverb and noun links.
    !
    ADVERB_LINK = VERB_NODE [DBG$L_VERB_ADVERB_PTR];
    NOUN_LINK = VERB_NODE [DBG$L_VERB_OBJECT_PTR];


    ! Set the default command descriptors....
    !
    SELECTONE .VERB_NODE [DBG$B_VERB_COMPOSITE] OF
	SET


	[EVENT$K_SET_BREAK]:
	    BEGIN
	    CMD_TYPE = EVENT$K_TYPE_BREAK;
	    CMD_KIND = EVENT$K_KIND_ACC;
	    SUB_KIND = EVENT$K_ACC_EXEC;
	    END;


	[EVENT$K_SET_TRACE]:
	    BEGIN
	    CMD_TYPE = EVENT$K_TYPE_TRACE;
	    CMD_KIND = EVENT$K_KIND_ACC;
	    SUB_KIND = EVENT$K_ACC_EXEC;
	    END;


	[EVENT$K_SET_WATCH]:
	    BEGIN
	    CMD_TYPE = EVENT$K_TYPE_WATCH;
	    CMD_KIND = EVENT$K_KIND_ACC;
	    SUB_KIND = EVENT$K_ACC_MDFY;
	    END;


	[EVENT$K_SET_STEP,EVENT$K_STEP]:
	    BEGIN
	    CMD_TYPE = EVENT$K_TYPE_STEPS;
	    SUB_KIND = .DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND];
	    IF .SUB_KIND EQLU EVENT$K_ACC_RTRN
	    THEN
		CMD_KIND = EVENT$K_KIND_ACC

    	    ELSE IF .SUB_KIND EQLU EVENT$K_EXC_EXC
    	    THEN
    		CMD_KIND = EVENT$K_KIND_EXC

	    ELSE
		CMD_KIND = EVENT$K_KIND_INS;

	    END;

	TES;


    ! Setup the other default values.
    !
    AFTER_COUNT = 1;
    TEMPORARY = FALSE;
    SILENT = FALSE;
    NOSILENT = FALSE;
    SOURCE = FALSE;
    NOSOURCE = FALSE;
    SYSTEM = FALSE;
    NOSYSTEM = FALSE;
    INTO = FALSE;
    OVER = FALSE;
    IF .VERB_NODE [DBG$B_VERB_COMPOSITE] EQL EVENT$K_STEP
    THEN
    	SILENT = NOT .DBG$GB_STP_PTR[EVENT$V_STEPPING_NOSILENT];


    ! Parse the command.  If this is not a SET STEP command, meaning that it
    ! is SET BREAK, SET TRACE, SET WATCH, or STEP, we look for qualifiers with
    ! "/" preceeding.
    !
    IF .VERB_NODE [DBG$B_VERB_COMPOSITE] NEQU EVENT$K_SET_STEP
    THEN
	BEGIN


	! Look for the qualifiers....
	!
	! Parse the command according to the following syntax:
	!
	!	[ /AFTER : <n> ]
	!	[ /[NO]SILENT ]
	!	[ /TEMPORARY ]
	!	[ /READ | /WRITE | /MODIFY | /EXECUTE | /RETURN ]
	!	    <address> [ , <address> ]*
	!	/EXCEPTION
	!	[ /[NO]SOURCE | /[NO]SYSTEM | /INTO | /OVER ]
	!	/CALLS
	!	/RETURN
	!	/BRANCH
	!	/INSTRUCTION [ = [ <mnemonic> | [( <mnemonic> [ , <mnemonic> ]* ) ]]
	!
	NOSILENT = TRUE;
	WHILE MATCH(DBG$CS_SLASH) DO
	    BEGIN
	    SELECTONE TRUE OF
		SET


		! Parse the /AFTER : <n> qualifier.
		!
		[MATCH (DBG$CS_AFTER)]:
		    BEGIN
		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN


			! Match the ':'.
			!
			NEED_MATCH (DBG$CS_COLON);
	 
	 
			! Fill in the details.
			!
			IF NOT DBG$NSAVE_DECIMAL_INTEGER
			       (.INPUT_DESC,
				AFTER_COUNT,
				.MESSAGE_VECT
			       )
			THEN
			    RETURN STS$K_SEVERE;

			END

		    ELSE
			SYNTAX_ERROR;

		    END;
     
     
    		! Parse the /TEMPORARY qualifier.
		!
		[MATCH (DBG$CS_TEMPORARY)]:
		    BEGIN


		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN


			! Fill in the details.
			!
			TEMPORARY = TRUE;
    			END

		    ELSE
			SYNTAX_ERROR;

		    END;
     
     
		! Parse the /SILENT qualifier.
		!
		[MATCH (DBG$CS_SILENT, 2)]:
		    BEGIN
		    SILENT = TRUE;
		    NOSILENT = FALSE;
		    END;


		! Parse the /NOSILENT qualifier.
		!
		[MATCH (DBG$CS_NOSILENT, 4)]:
		    BEGIN
		    NOSILENT = TRUE;
    		    SILENT = FALSE;
		    END;
     
     
		! Parse /READ.
		!
		[MATCH (DBG$CS_READ)]:
		    BEGIN


		    ! Make sure that this is a SET BREAK or SET TRACE command,
		    ! and then set the command kind to read access.
		    !
		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_ACC;
			SUB_KIND = EVENT$K_ACC_READ;
			END

		    ELSE
			SYNTAX_ERROR;
		    END;


		! Parse /WRITE.
		!
		[MATCH (DBG$CS_WRITE)]:
		    BEGIN


		    ! Make sure that this is a SET BREAK or SET TRACE command,
		    ! and then set the command kind to write access.
		    !
		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_ACC;
			SUB_KIND = EVENT$K_ACC_WRIT;
			END

		    ELSE
			SYNTAX_ERROR;
		    END;


		! Parse /MODIFY.
		!
		[MATCH (DBG$CS_MODIFY)]:
		    BEGIN


		    ! Make sure that this is a SET BREAK or SET TRACE command,
		    ! and then set the command kind to modify access.
		    !
		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_ACC;
			SUB_KIND = EVENT$K_ACC_MDFY;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /EXECUTE <address> [ , <address> ]*.
		!
		[MATCH (DBG$CS_EXECUTE)]:
		    BEGIN


		    ! Make sure that this is a SET BREAK or SET TRACE command,
		    ! and then set the command kind to execute access.
		    !
		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_ACC;
			SUB_KIND = EVENT$K_ACC_EXEC;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /RETURN <address> [ , <address> ]*.
		!
		[MATCH (DBG$CS_RETURN)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to return access.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_ACC;
			SUB_KIND = EVENT$K_ACC_RTRN;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /EXECEPTION.
		!
		[MATCH (DBG$CS_EXCEPTION)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to execption.
		    !
		    IF .CMD_TYPE EQLU EVENT$K_TYPE_BREAK OR
		       .CMD_TYPE EQLU EVENT$K_TYPE_TRACE OR
    		       .CMD_TYPE EQLU EVENT$K_TYPE_STEPS
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_EXC;
    			SUB_KIND = EVENT$K_EXC_EXC;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /SOURCE.
		!
		[MATCH (DBG$CS_SOURCE, 2)]:
		    BEGIN
		    SOURCE = TRUE;
		    NOSOURCE = FALSE;
		    END;


		! Parse /NOSOURCE.
		!
		[MATCH (DBG$CS_NOSOURCE, 4)]:
		    BEGIN
		    NOSOURCE = TRUE;
		    SOURCE = FALSE;
		    END;


		! Parse /SYSTEM.
		!
		[MATCH (DBG$CS_SYSTEM, 2)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to call.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			SYSTEM = TRUE;
			NOSYSTEM = FALSE;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /NOSYSTEM.
		!
		[MATCH (DBG$CS_NOSYSTEM, 4)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to call.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			NOSYSTEM = TRUE;
			SYSTEM = FALSE;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /INTO.
		!
		[MATCH (DBG$CS_INTO)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to call.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			INTO = TRUE;
			OVER = FALSE;
			END

		    ELSE
			SYNTAX_ERROR;
		    END;


		! Parse /OVER.
		!
		[MATCH (DBG$CS_OVER)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to call.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			OVER = TRUE;
			INTO = FALSE;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /CALLS.
		!
		[MATCH (DBG$CS_CALL)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to call.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_INS;
			SUB_KIND = EVENT$K_INS_CALL;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /BRANCH.
		!
		[MATCH (DBG$CS_BRANCH)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to branch.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_INS;
			SUB_KIND = EVENT$K_INS_BRAN;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /LINE.
		!
		[MATCH (DBG$CS_LINE)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to line.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_INS;
			SUB_KIND = EVENT$K_INS_LINE;
			END

		    ELSE
			SYNTAX_ERROR;

		    END;


		! Parse /INSTRUCTION
		!	    [ = [ <mnemonic> | ( <mnemonic> [ , <mnemonic> ]* ) ]].
		!
		[MATCH (DBG$CS_INSTRUCTION)]:
		    BEGIN


		    ! Make sure that this is not a SET WATCH command,
		    ! and then set the command kind to instruction.
		    !
		    IF .CMD_TYPE NEQU EVENT$K_TYPE_WATCH
		    THEN
			BEGIN
			CMD_KIND = EVENT$K_KIND_INS;
			SUB_KIND = EVENT$K_INS_EVRY;


			! Look for a possible '='.
			!
			IF MATCH (DBG$CS_EQUALS)
			THEN
			    BEGIN

			    ! Set the kind to user defined instead of every.
			    !
			    SUB_KIND = EVENT$K_INS_USER;


			    ! Collect mnemonic(s).
			    !
			    IF MATCH (DBG$CS_L_PAREN)
			    THEN


				! Collect mnemonic(s) and build an noun list.
				!
				BEGIN
				DO
				    BEGIN


				    ! Get a noun node for a <mnemonic>.
				    !
				    GET_NOUN_NODE;

				    NOUN_NODE [DBG$L_NOUN_VALUE] =
					DBG$OPCODE_INDEX(.INPUT_DESC);

				    END
				WHILE (MATCH (DBG$CS_COMMA));


				! Match the ')'.
				!
				NEED_MATCH (DBG$CS_R_PAREN);
				END

			    ELSE
				BEGIN


				! Get a noun node for a <mnemonic>.
				!
				GET_NOUN_NODE;
				NOUN_NODE [DBG$L_NOUN_VALUE] =
				    DBG$OPCODE_INDEX(.INPUT_DESC);
				END;

			    END;

			END

		    ELSE
			SYNTAX_ERROR;

		    END;


    		! Check for ambiguous cases.
    		!
    		[MATCH(UPLIT BYTE(%ASCIC 'S'))]:
    		    SIGNAL(DBG$_AMBIGQUAL, 1, UPLIT BYTE(%ASCIC 'S'));

    		[MATCH(UPLIT BYTE(%ASCIC 'NOS'), 3)]:
    		    SIGNAL(DBG$_AMBIGQUAL, 1, UPLIT BYTE(%ASCIC 'NOS'));


		! Otherwise, we've got an undefined qualifier....
		!
		[OTHERWISE]:
		    SYNTAX_ERROR;

		TES;

	    END;			! End of WHILE loop over qualifiers

	END				! End of non-SET STEP command parse


    ! Handle the SET STEP command qualifiers.
    !
    ELSE
	BEGIN


	! Parse the SET STEP command according to the following syntax:
	!
    	!       [ [NO]SILENT ]
	!	[ [NO]SOURCE | [NO]SYSTEM | INTO | OVER ]
	!	CALLS
	!	RETURN
	!	BRANCH
	!	INSTRUCTION [ = [ <mnemonic> | [( <mnemonic> [ , <mnemonic> ]* ) ]]
	!
	DO
	    BEGIN
	    SELECTONE TRUE OF
		SET


		! Parse RETURN
		!
		[MATCH (DBG$CS_RETURN)]:
		    BEGIN
		    CMD_KIND = EVENT$K_KIND_ACC;
		    SUB_KIND = EVENT$K_ACC_RTRN;
		    END;


		! Parse SOURCE.
		!
		[MATCH (DBG$CS_SOURCE, 2)]:
		    BEGIN
		    SOURCE = TRUE;
		    NOSOURCE = FALSE;
		    END;


		! Parse NOSOURCE.
		!
		[MATCH (DBG$CS_NOSOURCE, 4)]:
		    BEGIN
		    NOSOURCE = TRUE;
		    SOURCE = FALSE;
		    END;


		! Parse SYSTEM.
		!
		[MATCH (DBG$CS_SYSTEM, 2)]:
		    BEGIN
		    SYSTEM = TRUE;
		    NOSYSTEM = FALSE;
		    END;


		! Parse NOSYSTEM.
		!
		[MATCH (DBG$CS_NOSYSTEM, 4)]:
		    BEGIN
		    NOSYSTEM = TRUE;
		    SYSTEM = FALSE;
		    END;


		! Parse SILENT.
		!
		[MATCH (DBG$CS_SILENT, 2)]:
		    BEGIN
		    SILENT = TRUE;
		    NOSILENT = FALSE;
		    END;


		! Parse NOSILENT.
		!
		[MATCH (DBG$CS_NOSILENT, 4)]:
		    BEGIN
		    SILENT = FALSE;
		    NOSILENT = TRUE;
		    END;


		! Parse INTO.
		!
		[MATCH (DBG$CS_INTO)]:
		    BEGIN
		    INTO = TRUE;
		    OVER = FALSE;
		    END;


		! Parse OVER.
		!
		[MATCH (DBG$CS_OVER)]:
		    BEGIN
		    OVER = TRUE;
		    INTO = FALSE;
		    END;


		! Parse CALLS.
		!
		[MATCH (DBG$CS_CALL)]:
		    BEGIN
		    CMD_KIND = EVENT$K_KIND_INS;
		    SUB_KIND = EVENT$K_INS_CALL;
		    END;


		! Parse BRANCH.
		!
		[MATCH (DBG$CS_BRANCH)]:
		    BEGIN
		    CMD_KIND = EVENT$K_KIND_INS;
		    SUB_KIND = EVENT$K_INS_BRAN;
		    END;


    		! Parse EXCEPTION
    		!
    		[MATCH (DBG$CS_EXCEPTION)]:
    		    BEGIN
    		    CMD_KIND = EVENT$K_KIND_EXC;
    		    SUB_KIND = EVENT$K_EXC_EXC;
    		    END;


		! Parse LINE.
		!
		[MATCH (DBG$CS_LINE)]:
		    BEGIN
		    CMD_KIND = EVENT$K_KIND_INS;
		    SUB_KIND = EVENT$K_INS_LINE;
		    END;


		! Parse INSTRUCTION
		!	    [ = [ <mnemonic> | ( <mnemonic> [ , <mnemonic> ]* ) ]].
		!
		[MATCH (DBG$CS_INSTRUCTION)]:
		    BEGIN
		    CMD_KIND = EVENT$K_KIND_INS;
		    SUB_KIND = EVENT$K_INS_EVRY;


		    ! Look for a possible '='.
		    !
		    IF MATCH (DBG$CS_EQUALS)
		    THEN
			BEGIN

			! Set the kind to user defined instead of every.
			!
			SUB_KIND = EVENT$K_INS_USER;

			! Collect mnemonic(s).
			!
			IF MATCH (DBG$CS_L_PAREN)
			THEN

			    ! Collect mnemonic(s) and build an noun list.
			    !
			    BEGIN
			    DO
				BEGIN

				! Get a noun node for a <mnemonic>.
				!
				GET_NOUN_NODE;

				NOUN_NODE [DBG$L_NOUN_VALUE] =
				    DBG$OPCODE_INDEX(.INPUT_DESC);

				END
			    WHILE (MATCH (DBG$CS_COMMA));


			    ! Match the ')'.
			    !
			    NEED_MATCH (DBG$CS_R_PAREN);
			    END

			ELSE
			    BEGIN

			    ! Get a noun node for a <mnemonic>.
			    !
			    GET_NOUN_NODE;
			    NOUN_NODE [DBG$L_NOUN_VALUE] =
				DBG$OPCODE_INDEX(.INPUT_DESC);
			    END;

			END;

		    END;


    		! Check for ambiguous cases.
    		!
    		[MATCH(UPLIT BYTE(%ASCIC 'S'))]:
    		    SIGNAL(DBG$_AMBIGQUAL, 1, UPLIT BYTE(%ASCIC 'S'));

    		[MATCH(UPLIT BYTE(%ASCIC 'NOS'), 3)]:
    		    SIGNAL(DBG$_AMBIGQUAL, 1, UPLIT BYTE(%ASCIC 'NOS'));


		! Otherwise, we've got an undefined qualifier (or something).
		!
		[OTHERWISE]:
		    SYNTAX_ERROR;

		TES;

	    END

	WHILE (MATCH (DBG$CS_COMMA));

	END;				! End of SET STEP qualifier parsing


    ! Build up the adverb list based on what we've got so far.
    ! Note that if we've reached this point, we should have
    ! all qualifiers done, and the working variables reflect
    ! the command desired.
    !
    ! Set up the command kind and possibly the sub-kind adverbs.
    !
    GET_ADVERB_NODE;
    SELECTONE .CMD_KIND OF
	SET
	[EVENT$K_KIND_ACC]:
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
	    (SELECTONE .SUB_KIND OF
		SET
		[EVENT$K_ACC_READ]:
		    ADVERB_READ;
		[EVENT$K_ACC_WRIT]:
		    ADVERB_WRITE;
		[EVENT$K_ACC_MDFY]:
		    ADVERB_MODIFY;
		[EVENT$K_ACC_EXEC]:
		    ADVERB_EXECUTE;
		[EVENT$K_ACC_RTRN]:
		    ADVERB_RETURN;
		TES
	    );


	[EVENT$K_KIND_EXC]:
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_EXCEPTION;


	[EVENT$K_KIND_INS]:
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
	    (SELECTONE .SUB_KIND OF
		SET
		[EVENT$K_INS_CALL]:
		    ADVERB_CALL;
		[EVENT$K_INS_BRAN]:
		    ADVERB_BRANCH;
		[EVENT$K_INS_EVRY]:
		    ADVERB_INSTRUCTION;
		[EVENT$K_INS_USER]:
		    ADVERB_OPCODE;
		[EVENT$K_INS_LINE]:
		    ADVERB_LINE;
		TES
	    );

	TES;


    ! If the /AFTER, /UNTIL, and /EVERY are not at their defaults,
    ! setup an adverb node for the problem boys.
    !
    IF .AFTER_COUNT NEQU 1
    THEN
	BEGIN
	GET_ADVERB_NODE;


	! If the /AFTER count is 0, then this is really a kludge ah, I
	! mean /TEMPORARY.
	!
	IF .AFTER_COUNT EQLU 0
	THEN
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_TEMPORARY
	ELSE
	    BEGIN
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_AFTER;
	    ADVERB_NODE [DBG$L_ADVERB_VALUE] = .AFTER_COUNT;
	    END;
	END;


    ! If the /SILENT or /NOSILENT qualifier is present, make an Adverb Node
    ! for whichever one was specified last.
    !
    IF .SILENT
    THEN
	BEGIN
	GET_ADVERB_NODE;
	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_SILENT;
	END

    ELSE IF .NOSILENT
    THEN
    	BEGIN
    	GET_ADVERB_NODE;
    	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_NOSILENT;
        END;


    ! If the /TEMPORARY qualifier is present, make an Adverb Node for it.
    !
    IF .TEMPORARY
    THEN
	BEGIN
	GET_ADVERB_NODE;
	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_TEMPORARY;
	END;


    ! If the /SOURCE or /NOSOURCE qualifier was present, make an Adverb Node
    ! for it.
    !
    IF .SOURCE
    THEN
        BEGIN
	GET_ADVERB_NODE;
	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_SOURCE;
	END;

    IF .NOSOURCE
    THEN
        BEGIN
	GET_ADVERB_NODE;
	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_NOSOURCE;
	END;


    ! Handle /[NO]SYSTEM's, /INTO's or /OVER's.
    !
    IF .CMD_KIND EQLU EVENT$K_KIND_INS OR
       (.CMD_KIND EQLU EVENT$K_KIND_ACC AND
	.SUB_KIND EQLU EVENT$K_ACC_RTRN)
    THEN
	BEGIN
	IF .SYSTEM
	THEN
	    BEGIN
	    GET_ADVERB_NODE;
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_SYSTEM;
	    END;

	IF .NOSYSTEM
	THEN
	    BEGIN
	    GET_ADVERB_NODE;
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_NOSYSTEM;
	    END;

	IF .INTO
	THEN
	    BEGIN
	    GET_ADVERB_NODE;
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_INTO;
	    END;

	IF .OVER
	THEN
	    BEGIN
	    GET_ADVERB_NODE;
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_OVER;
	    END;

	END;


    ! If the command kind is an access kind, get the <address> [ , <address> ]*
    ! as long as an <address> is terminated with a ','.
    !
    IF .CMD_TYPE NEQU EVENT$K_TYPE_STEPS AND
       .CMD_KIND EQLU EVENT$K_KIND_ACC
    THEN
	BEGIN
	DO
	    BEGIN
	    

	    ! Get a noun node for an <address>.
	    !
	    GET_NOUN_NODE;


	    ! Get an <address> - the is a status warning
	    ! if more is on the line. Surrounding this call, we
    	    ! turn on a flag saying we are picking up the address in
    	    ! a set break command. This is used in DBGPARSER to 
    	    ! resolve potential ambiguities in SET BRE . DO (command)
	    ! 
    	    DBG$GB_SET_BREAK_FLAG = TRUE;
	    STATUS = DBG$NPARSE_ADDRESS(.INPUT_DESC,
			NOUN_NODE [DBG$L_NOUN_VALUE],
			.DBG$GB_RADIX[DBG$B_RADIX_INPUT],
			TOKEN$K_TERM_CMWHDO, .MESSAGE_VECT);
    	    DBG$GB_SET_BREAK_FLAG = FALSE;


	    ! If the status indicates success, there is no
	    ! more on the line, and we exit this loop.
	    !
	    IF .STATUS EQLU STS$K_SUCCESS
	    THEN
		EXITLOOP;


	    ! If the status is not a warning, something is
	    ! wrong, so return with a failure.
	    !
	    IF .STATUS NEQU STS$K_WARNING
	    THEN
		RETURN .STATUS

	    END
	WHILE (MATCH (DBG$CS_COMMA));

	END;


    ! Check the input for a <cr> after parsing <address> [ , <address> ]*
    ! or <mnemonic> [ , <mnemonic> ].  If there's nothing left on the
    ! line we can leave.
    !
    IF MATCH (DBG$CS_CR)
    THEN RETURN STS$K_SUCCESS;


    ! We didn't match a <cr>, there's more on the line.  If this is a STEP
    ! command, get the step count....
    !
    IF .CMD_TYPE EQLU EVENT$K_TYPE_STEPS
    THEN
	IF .VERB_NODE [DBG$B_VERB_COMPOSITE] EQLU EVENT$K_STEP
	THEN
	    BEGIN


	    ! Get an adverb node for a <step count>.
	    !
	    GET_ADVERB_NODE;


	    ! Get a <step count> - there is a status warning
	    ! if more is on the line.
	    !
	    ! Fill in the details.
	    !
	    ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_AFTER;
	    IF NOT DBG$NSAVE_DECIMAL_INTEGER
		   (.INPUT_DESC,
		    ADVERB_NODE [DBG$L_ADVERB_VALUE],
		    .MESSAGE_VECT
		   )
	    THEN
		RETURN STS$K_SEVERE
	    ELSE
		RETURN STS$K_SUCCESS;
	    END
	ELSE
	    SYNTAX_ERROR;


    ! This isn't a STEP command, but there's more on the line - maybe
    ! a WHEN or a DO....
    !
    ! Parse a possible WHEN (<expression>).
    !
    IF MATCH (DBG$CS_WHEN)
    THEN
	BEGIN


	! Match the '('.
	!
	NEED_MATCH (DBG$CS_L_PAREN);


	! Get a new adverb node for the conditional expression.
	!
	GET_ADVERB_NODE;


	! Flag a 'WHEN' and save the <expression>.
	!
	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_WHEN;
	DBG$NSAVE_BREAK_BUFFER (.INPUT_DESC, ADVERB_NODE [DBG$L_ADVERB_VALUE]);
	END;


    ! Parse a Possible DO <command list>.
    !
    IF MATCH (DBG$CS_DO)
    THEN
	BEGIN


	! Match the '('.
	!
	NEED_MATCH (DBG$CS_L_PAREN);


	! Get a new adverb node for the command list.
	!
	GET_ADVERB_NODE;


	! Flag a 'DO' and save the <command list>.
	!
	ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_DO;
	DBG$NSAVE_BREAK_BUFFER (.INPUT_DESC, ADVERB_NODE [DBG$L_ADVERB_VALUE]);
    	RETURN STS$K_SUCCESS;
	END;


    ! If there's more on the line, it's nothing we recognise.  Signal
    ! a syntax error.
    !
    IF MATCH (DBG$CS_CR) THEN RETURN STS$K_SUCCESS;
    .MESSAGE_VECT = DBG$NSYNTAX_ERROR (DBG$NNEXT_WORD (.INPUT_DESC));
    RETURN STS$K_SEVERE;
    END;

GLOBAL ROUTINE DBG$EVENT_SEMANTICS(VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine builds the event data stuctures based on the
!	parse tree passed via the VERB_NODE address.  This routine
!	is called from DBGNSET.
!
! INPUTS
!	VERB_NODE:	A pointer to a DEBUG verb node, which defines,
!			along with the verb's descendants, the desired
!			command.
!	MESSAGE_VECT:	The address of a longword to contain the address
!			of a message argument vector.
!
! OUTPUTS
!	The event data structure(s) are updated to include the new event,
!	and may include:
!
!	    EVENT$CMD_QUEUE,
!	    EVENT$WHEN_QUEUE,
!	    EVENT$DO_LIST_QUEUE,
!	    EVENT$PAGE_QUEUE
!
!	STS$K_SEVERE is return on error, otherwise STS$K_SUCCESS
!
    BEGIN

    MAP
	VERB_NODE :	REF DBG$VERB_NODE;	! Verb node pointer

    LOCAL
    	DUMMY,
	EVENT_QUEUE :	QUEUE_HEAD,		! Working queue head
	QUEUE_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event queue entry pointer
	NEXTQ_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event queue entry pointer
	EVENT_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	DO_ENTRY :	REF EVENT$DO_LIST_DESCRIPTOR, ! DO List entry pointer
	WHEN_ENTRY :	REF EVENT$WHEN_DESCRIPTOR, ! WHEN entry pointer
	ADVERB_NODE : 	REF DBG$ADVERB_NODE,	! Adverb node link
	NOUN_NODE :	REF DBG$NOUN_NODE,	! Noun node link

	PRIMARY :	REF DBG$PRIMARY,	! Event primary descriptor
	VALUE :		REF DBG$VALDESC,	! Event value descriptor

	ADDRESS :	VECTOR [2],		! Event address
	ADR_TYP,				! Event address type
	LENGTH,					! Event value length

	STRING :	REF VECTOR [, BYTE],	! Text pointer
	COUNTER;				! Counter variable


    ! Initialize the working queue to be empty.
    !
    EVENT_QUEUE [L_QUEUE_FLINK] = EVENT_QUEUE;
    EVENT_QUEUE [L_QUEUE_BLINK] = EVENT_QUEUE;


    ! Get an event descriptor from permanent memory, and
    ! link it into the working queue. Also inititialize the
    ! inside queue header.
    !
    EVENT_ENTRY = DBG$GET_MEMORY (EVENT$K_EVENT_DESCRIPTOR_SIZE);
    INSQUE (.EVENT_ENTRY, EVENT_QUEUE);
    EVENT_ENTRY[EVENT$L_EXC_FLINK] = .EVENT_ENTRY;
    EVENT_ENTRY[EVENT$L_EXC_BLINK] = .EVENT_ENTRY;


    ! Set the event's command type, found in the verb.
    !
    SELECTONE .VERB_NODE [DBG$B_VERB_COMPOSITE] OF
	SET

	[EVENT$K_SET_BREAK]:
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_BREAK;

	[EVENT$K_SET_BREAK_EXC]:
	    BEGIN
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_BREAK;
	    EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_EXC;
	    END;

	[EVENT$K_SET_TRACE]:
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_TRACE;

	[EVENT$K_SET_WATCH]:
	    BEGIN
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_WATCH;
	    EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;
	    EVENT_ENTRY [EVENT$B_SUB_KIND] = EVENT$K_ACC_MDFY
	    END;

	[EVENT$K_SET_STEP,
	 EVENT$K_STEP]:
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_STEPS;

	[OTHERWISE]:
	    $DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 10');
	
	TES;


    ! Initialize the Deleted, Silent, Once (Temporary), Threaded, and
    ! Has Value Descriptor flags.
    !
    EVENT_ENTRY [EVENT$B_CMD_FLAGS] = 0;


    ! Initialize the step-type flags.  If the command is STEP or SET STEP,
    ! we set up the Event Entry using the current default stepping modes.
    !
    EVENT_ENTRY[EVENT$L_STEP_FLAGS] = 0;
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS
    THEN
	BEGIN
	EVENT_ENTRY[EVENT$V_STEP_LINE] = .DBG$GB_STP_PTR[EVENT$V_STEPPING_LINE];
	EVENT_ENTRY[EVENT$V_STEP_OVER] = .DBG$GB_STP_PTR[EVENT$V_STEPPING_OVER];
	EVENT_ENTRY[EVENT$V_STEP_SOURCE] =
			.DBG$GB_STP_PTR[EVENT$V_STEPPING_SOURCE];
	EVENT_ENTRY[EVENT$V_OVRD_SOURCE] = FALSE;
	EVENT_ENTRY[EVENT$V_STEP_NOSYSTEM] =
			.DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSYSTEM];
    	EVENT_ENTRY[EVENT$V_STEP_NOSILENT] =
			.DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSILENT];
	END


    ! If the command is SET BREAK, SET TRACE, or SET WATCH, we initialize the
    ! various flags to FALSE.
    !
    ELSE
	BEGIN
	EVENT_ENTRY[EVENT$V_STEP_LINE] = FALSE;
	EVENT_ENTRY[EVENT$V_STEP_OVER] = FALSE;
	EVENT_ENTRY[EVENT$V_STEP_SOURCE] = FALSE;
	EVENT_ENTRY[EVENT$V_OVRD_SOURCE] = FALSE;
	EVENT_ENTRY[EVENT$V_STEP_NOSYSTEM] = FALSE;
    	EVENT_ENTRY[EVENT$V_STEP_NOSILENT] = FALSE;
	END;


    ! Initialize the Primary pointer to NULL.
    !
    EVENT_ENTRY [EVENT$L_PRIMARY] = 0;


    ! Initialize the event entry /AFTER count to 1.
    !
    EVENT_ENTRY [EVENT$L_AFTER_COUNT] = 1;


    ! Initialize the WHEN and DO List pointers to NULL.
    !
    EVENT_ENTRY [EVENT$L_WHEN] = 0;
    EVENT_ENTRY [EVENT$L_DO] = 0;


    ! Point to the verb's noun list.
    !
    NOUN_NODE = .VERB_NODE [DBG$L_VERB_OBJECT_PTR];


    ! Point to the verb's adverb list.
    !
    ADVERB_NODE = .VERB_NODE [DBG$L_VERB_ADVERB_PTR];


    ! For each existing adverb, process it.
    !
    WHILE .ADVERB_NODE NEQA 0 DO
	BEGIN


	! Process adverbs based on the literal set by the
	! syntactic processing.
	!
	SELECTONE .ADVERB_NODE [DBG$B_ADVERB_LITERAL] OF
	    SET


	    ! Process the /AFTER : <n> adverb.
	    !
	    [ADVERB_AFTER]:
		EVENT_ENTRY [EVENT$L_AFTER_COUNT] =
		    .ADVERB_NODE [DBG$L_ADVERB_VALUE];


	    ! Process the /TEMPORARY adverb.
	    !
	    [ADVERB_TEMPORARY]:
		EVENT_ENTRY [EVENT$V_ONCE_ONLY] = TRUE;


	    ! Process the /SILENT adverb.
	    !
	    [ADVERB_SILENT]:
    		BEGIN
		EVENT_ENTRY [EVENT$V_SILENT] = TRUE;
		EVENT_ENTRY [EVENT$V_STEP_NOSILENT] = FALSE;
		EVENT_ENTRY [EVENT$V_OVRD_NOSILENT] = TRUE;
    		END;


    	    ! Process the /NOSILENT adverb.
    	    !
    	    [ADVERB_NOSILENT]:
    		BEGIN
		EVENT_ENTRY [EVENT$V_SILENT] = FALSE;
		EVENT_ENTRY [EVENT$V_STEP_NOSILENT] = TRUE;
		EVENT_ENTRY [EVENT$V_OVRD_NOSILENT] = TRUE;
    		END;


	    ! Process the WHEN adverb.
	    !
	    [ADVERB_WHEN]:
		BEGIN
    		LOCAL
    		    LENGTH;

		! Get a WHEN descriptor from permanent memory, and
		! link it into the WHEN queue.
		!
		WHEN_ENTRY = DBG$GET_MEMORY (EVENT$K_WHEN_DESCRIPTOR_SIZE);
		INSQUE (.WHEN_ENTRY, EVENT$WHEN_QUEUE);


		! Point the event entry to the WHEN entry.
		!
		EVENT_ENTRY [EVENT$L_WHEN] = .WHEN_ENTRY;


		! Put a <cr> at the end of the WHEN string.
		!
		STRING = .ADVERB_NODE [DBG$L_ADVERB_VALUE];
    		LENGTH = .(.STRING)<0,16,0>;
		STRING [.LENGTH+1] = DBG$K_CAR_RETURN;


		! Fill in the WHEN entry.
		!
		WHEN_ENTRY [EVENT$L_WHEN_COUNT] = 1;
		WHEN_ENTRY [EVENT$L_WHEN_POINT] = .STRING;
		END;


	    ! Process the DO adverb.
	    !
	    [ADVERB_DO]:
		BEGIN
    		LOCAL
    		    LENGTH;


		! Get a DO LIST descriptor from permanent memory, and
		! link it into the DO LIST queue.
		!
		DO_ENTRY = DBG$GET_MEMORY (EVENT$K_DO_LIST_DESCRIPTOR_SIZE);
		INSQUE (.DO_ENTRY, EVENT$DO_LIST_QUEUE);


		! Point the event entry to the DO LIST entry.
		!
		EVENT_ENTRY [EVENT$L_DO] = .DO_ENTRY;


		! Put a <cr> at the end of the DO string.
		!
		STRING = .ADVERB_NODE [DBG$L_ADVERB_VALUE];
    		LENGTH = .(.STRING)<0,16,0>;
		STRING [.LENGTH+1] = DBG$K_CAR_RETURN;


		! Fill in the DO entry.
		!
		DO_ENTRY [EVENT$L_DO_LIST_COUNT] = 1;
		DO_ENTRY [EVENT$L_DO_LIST_POINT] = .STRING;
		END;


	    ! Process the /READ, /WRITE, /MODIFY, /EXECUTE, and /RETURN
	    ! access adverbs.
	    !
	    [ADVERB_READ,ADVERB_WRITE,ADVERB_MODIFY,
	     ADVERB_EXECUTE,ADVERB_RETURN]:
		BEGIN


		! Define the command kind to be access.
		!
		EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;


		! Define the sub-kind as appropriate.
		!
		EVENT_ENTRY [EVENT$B_SUB_KIND] =
		    (SELECTONE .ADVERB_NODE [DBG$B_ADVERB_LITERAL] OF
			    SET
			    [ADVERB_READ]:
				EVENT$K_ACC_READ;
			    [ADVERB_WRITE]:
				EVENT$K_ACC_WRIT;
			    [ADVERB_MODIFY]:
				EVENT$K_ACC_MDFY;
			    [ADVERB_EXECUTE]:
				EVENT$K_ACC_EXEC;
			    [ADVERB_RETURN]:
				EVENT$K_ACC_RTRN;
			    [OTHERWISE]:
				$DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 20');
			    TES
		    );
		END;


	    ! Process the /EXCEPTION adverb.
	    !
	    [ADVERB_EXCEPTION]:
    		BEGIN
		EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_EXC;
    		EVENT_ENTRY [EVENT$B_SUB_KIND] = EVENT$K_EXC_EXC;
    		END;


	    ! Process the /CALL, /RETURN, /BRANCH, /OPCODE, /INSTRUCTION and
	    ! /LINE instruction-kind adverbs.
	    !
	    [ADVERB_CALL,
	     ADVERB_RETURN,
	     ADVERB_BRANCH,
	     ADVERB_OPCODE,
	     ADVERB_INSTRUCTION,
	     ADVERB_LINE]:
		BEGIN
		LOCAL 
    		    LINENO,	! Line number returned from PC_TO_LINE
    		    MODRST,	! Module RST returned from PC_TO_LINE
    		    STATUS,	! Status returned from PC_TO_LINE
    		    STMTNO;	! Statement number returned from PC_TO_LINE

		! Define the event kind to be instruction.
		!
		EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_INS;


		! Define the subkind according to the adverb.
		!
		EVENT_ENTRY [EVENT$B_SUB_KIND] =
		    (SELECTONE .ADVERB_NODE [DBG$B_ADVERB_LITERAL] OF
			SET
			[ADVERB_CALL]:
			    EVENT$K_INS_CALL;
			[ADVERB_BRANCH]:
			    EVENT$K_INS_BRAN;
			[ADVERB_LINE]:
			    EVENT$K_INS_LINE;
			[ADVERB_OPCODE]:
			    EVENT$K_INS_USER;
			[ADVERB_INSTRUCTION]:
			    EVENT$K_INS_EVRY;
			[OTHERWISE]:
			    $DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 30');
			TES
		    );


		! Set the line stepping flag appropriately.
		!
		EVENT_ENTRY [EVENT$V_STEP_LINE] =
		    (.EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU EVENT$K_INS_LINE);


		! We're not in the middle of a step over....
		!
		EVENT_ENTRY [EVENT$V_STEP_BPT] = FALSE;


		! Initialize the LO and HI PC values by calling PC_TO_LINE
    		! with the current PC. This gives us a PC range for the
    		! line number containing the current PC. This PC range
    		! will be used later to determine when a step by line ends.
    		! If PC_TO_LINE returns FALSE we are not in a line. In that
    		! case, initialize LO and HI PC to 1 and 0, so we will
    		! immediately be out of the "range" the next time we check.
    		!
    		STATUS = 0;
    		MODRST = 0;
		IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU EVENT$K_INS_LINE
    		THEN
		    STATUS = DBG$PC_TO_LINE_LOOKUP(
				.DBG$RUNFRAME[DBG$L_USER_PC],  
    				LINENO,  
    				STMTNO,
				EVENT_ENTRY[EVENT$L_STEP_LO_PC],
				EVENT_ENTRY[EVENT$L_STEP_HI_PC],
				MODRST);
		IF NOT .STATUS 
    		THEN
		    BEGIN
		    EVENT_ENTRY[EVENT$L_STEP_LO_PC] = 1;
		    EVENT_ENTRY[EVENT$L_STEP_HI_PC] = 0;
		    END;
		END;


	    ! Process the /SOURCE adverb.
	    !
	    [ADVERB_SOURCE]:
		BEGIN
		EVENT_ENTRY [EVENT$V_STEP_SOURCE] = TRUE;
		EVENT_ENTRY [EVENT$V_OVRD_SOURCE] = TRUE;
		END;


	    ! Process the /NOSOURCE adverb.
	    !
	    [ADVERB_NOSOURCE]:
		BEGIN
		EVENT_ENTRY [EVENT$V_STEP_SOURCE] = FALSE;
		EVENT_ENTRY [EVENT$V_OVRD_SOURCE] = TRUE;
		END;


	    ! Process the /SYSTEM adverb.
	    !
	    [ADVERB_SYSTEM]:
		BEGIN
		EVENT_ENTRY [EVENT$V_STEP_NOSYSTEM] = FALSE;
		EVENT_ENTRY [EVENT$V_OVRD_NOSYSTEM] = TRUE;
		END;


	    ! Process the /NOSYSTEM adverb.
	    !
	    [ADVERB_NOSYSTEM]:
		BEGIN
		EVENT_ENTRY [EVENT$V_STEP_NOSYSTEM] = TRUE;
		EVENT_ENTRY [EVENT$V_OVRD_NOSYSTEM] = TRUE;
		END;


	    ! Process the /INTO adverb.
	    !
	    [ADVERB_INTO]:
		BEGIN
		EVENT_ENTRY [EVENT$V_STEP_OVER] = FALSE;
		EVENT_ENTRY [EVENT$V_OVRD_OVER] = TRUE;
		END;


	    ! Process the /OVER adverb.
	    !
	    [ADVERB_OVER]:
		BEGIN
		EVENT_ENTRY [EVENT$V_STEP_OVER] = TRUE;
		EVENT_ENTRY [EVENT$V_OVRD_OVER] = TRUE;
		END;


	    ! An invalid adverb literal - yell !
	    !
	    [OTHERWISE]:
		$DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 40');

	    TES;


	! Point to the next adverb in the list.
	!
	ADVERB_NODE = .ADVERB_NODE [DBG$L_ADVERB_LINK];
	END;


    ! Now, based on the command kind (access or instruction),
    ! process the noun node list.
    !
    SELECTONE .EVENT_ENTRY [EVENT$B_CMD_KIND] OF
	SET


	! Access events....
	!
	[EVENT$K_KIND_ACC]:

	    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_STEPS
	    THEN
		BEGIN

		LOCAL
		    SYMID_LIST;	! Pointer to SYMID
		

		! Make sure there's a noun node present.
		!
		IF .NOUN_NODE EQLA 0
		THEN
		    $DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 50');


		! Build duplicate event entries, one for each
		! address found in the noun node list.
		!
		WHILE TRUE DO
		    BEGIN


		    ! Obtain the primary descriptor.
		    !
		    PRIMARY = .NOUN_NODE [DBG$L_NOUN_VALUE];


		    ! Obtain the symid list, and lock it.
		    !
		    DBG$NGET_SYMID (.PRIMARY, SYMID_LIST, DUMMY);
		    DBG$STA_LOCK_SYMID (.SYMID_LIST);
			

		    ! Save the primary descriptor by making a copy of the primary
		    ! descriptor out of permanent storage.
		    !
		    DBG$NCOPY_DESC (.PRIMARY, EVENT_ENTRY[EVENT$L_PRIMARY],
							DUMMY, TRUE);


		    ! Now, get and save the VMS descriptor. (We do this 
    		    ! after saving the Primary since PRIM_TO_VAL sometimes
    		    ! modifies the Primary.)
		    !
		    DBG$PRIM_TO_VAL (.PRIMARY, DBG$K_V_VALUE_DESC, VALUE);
		    CH$MOVE (12, VALUE [DBG$A_VALUE_VMSDESC],
					EVENT_ENTRY [EVENT$A_VMSDESC]);


    		    ! Next, we determine the address where we put the 
    		    ! breakpoint. We pass our Primary into DBG$NGET_ADDRESS.
    		    ! For routines and entry points, NGET_ADDRESS takes a
    		    ! flag that says to return the "break address" instead
    		    ! of the start address. For routines, the break address
    		    ! is after the routine prolog (or, if there is no prolog,
    		    ! it is at routine_start+2).
    		    !
		    EVENT_ENTRY [EVENT$V_BREAK_ADDRESS] = FALSE;
    		    IF ((.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_BREAK) OR
    		        (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_TRACE))
    						AND
    			(.EVENT_ENTRY [EVENT$B_SUB_KIND] NEQ EVENT$K_ACC_RTRN)
    		    THEN
    			BEGIN
    			IF  (.PRIMARY[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC) 
    						AND
    			   ((.PRIMARY[DBG$B_DHDR_KIND] EQL RST$K_ROUTINE) OR
    			    (.PRIMARY[DBG$B_DHDR_KIND] EQL RST$K_ENTRY))
    			THEN
    			    EVENT_ENTRY [EVENT$V_BREAK_ADDRESS] = TRUE;
    			END;


    		    ! Get the address where we place the breakpoint.
    		    !
		    IF NOT DBG$NGET_ADDRESS(.PRIMARY, ADDRESS[0], ADR_TYP,
    			     .EVENT_ENTRY[EVENT$V_BREAK_ADDRESS], .MESSAGE_VECT)
		    THEN
			RETURN STS$K_SEVERE;
		    EVENT_ENTRY [EVENT$L_ADDRESS] = .ADDRESS[0];


    		    ! We may still need to adjust the address of the breakpoint
    		    ! by +2 to get past the entry mask of a routine. This 
    		    ! will be the case if the user set a break on an absolute
    		    ! address which happens to be the start of a routine,
    		    ! or on data of type ZEM, BPV, or BLV (e.g., if
    		    ! the address of a routine is passed as a parameter and
    		    ! and a breakpoint is set on that passed-in routine, then
    		    ! the Primary describe data of type BPV). These cases
    		    ! are not covered by the above "break address" code.
    		    !
    		    IF NOT .EVENT_ENTRY [EVENT$V_BREAK_ADDRESS]
    		    THEN
    			BEGIN


    			! If we can determine from the static address table
    			! that this is an entry point, then add two to get
    			! past the entry mask.
    			!
    			IF DBG$IS_IT_ENTRY (.ADDRESS [0])
    			THEN
    			    EVENT_ENTRY [EVENT$L_ADDRESS] = .ADDRESS[0] + 2

    			ELSE
    			    BEGIN


    			    ! If the data type in the value descriptor says
    			    ! that we have an entry mask, then add two to
    			    ! get past the entry mask.
    			    !
    			    IF (.VALUE[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZEM) OR
    			       (.VALUE[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_BPV) OR
    			       (.VALUE[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_BLV)
    			    THEN
    			        EVENT_ENTRY [EVENT$L_ADDRESS] = .ADDRESS[0] + 2;
    			    END;
    			END;


		    ! Make sure that we can access the value indicated.
		    !
		    DBG$READ_ACCESS (.EVENT_ENTRY [EVENT$L_ADDRESS],
			(DBG$DATA_LENGTH(EVENT_ENTRY[EVENT$A_VMSDESC]) + 7)
									^ -3);


		    ! Process the event's address additionally based on the
		    ! access type.
		    !
		    SELECTONE .EVENT_ENTRY [EVENT$B_SUB_KIND] OF
			SET
			[EVENT$K_ACC_EXEC,
			 EVENT$K_ACC_RTRN]:
			    BEGIN
			    LOCAL
				EVENT_ADDRESS :	REF VECTOR [, BYTE];

			    EVENT_ADDRESS = .EVENT_ENTRY [EVENT$L_ADDRESS];
			    IF NOT WRITE_OPCODE (.EVENT_ADDRESS,
						 .EVENT_ADDRESS [0]
						)
			    THEN
				BEGIN
				SIGNAL (DBG$_NOACCESSW, 1, .EVENT_ADDRESS);
				RETURN STS$K_SEVERE;
				END;


    			    ! Mark the fact We are at /RET .PC, for we want
    			    ! to take the RET SS$_ROPRAND fault starting
    			    ! from current PC.  Normally, we won't take
    			    ! the event if we are at current PC.
    			    !
    			    ! IF .EVENT_ADDRESS EQL .DBG$RUNFRAME[DBG$L_USER_PC]
    			    ! THEN
    			    !	EVENT_ENTRY [EVENT$V_RET_AT_PC] = TRUE;
			    END;
			
			[EVENT$K_ACC_MDFY]:


			    ! Process /MODIFY types by building and saving a non-
			    ! volatile value descriptor (i.e. a copy) of the value
			    ! indicated.
			    !
			    BEGIN
			    LOCAL
				PRIMARY: REF DBG$PRIMARY;

			    ! First, get the value descriptor.
			    ! Before we call PRIM_TO_VAL, however, we check
			    ! whether the Primary represents an aggregate,
			    ! such as an entire array. The scheme of saving
			    ! away value descriptors does not work for aggregates,
			    ! because we currently do not represent arrays
		 	    ! and records with value descriptors. So, for now
			    ! we signal an error saying that we do
			    ! not currently support watchpointing of aggregates.
			    !
    			    DBG$NCOPY_DESC(.EVENT_ENTRY[EVENT$L_PRIMARY], 
    				PRIMARY, DUMMY, FALSE);

			    IF .PRIMARY[DBG$V_DHDR_AGGR] 
    			    THEN 
    				SIGNAL(DBG$_NOWATAGGR);


    			    ! In order to keep the code path consistency
    			    ! it is better to turn the volatile value
    			    ! descriptor into value descriptor.
    			    !
    			    DBG$PRIM_TO_VAL (.PRIMARY,
    					     DBG$K_V_VALUE_DESC,
    					     VALUE);
			    DBG$PRIM_TO_VAL (.VALUE,
					     DBG$K_VALUE_DESC,
					     VALUE
					    );

			    IF .VALUE [DBG$B_DHDR_TYPE] NEQU DBG$K_VALUE_DESC
			    THEN
				SIGNAL(DBG$_WATCHSIZE)

			    ELSE
				BEGIN
				LOCAL
				    PAGE_ENTRY :    REF EVENT$PAGE_DESCRIPTOR,
				    PAGE_LIST :	    REF VECTOR [, LONG],
				    PAGE_FOUND;


				! The user is not permitted to set a watchpoint in
				! P1 space (or in system space)
				!
				IF .EVENT_ENTRY [EVENT$L_ADDRESS] GEQA P1_SPACE
				THEN
				    BEGIN
				    SIGNAL(DBG$_BADWATCH, 1,
					    .EVENT_ENTRY[EVENT$L_ADDRESS]);
				    RETURN STS$K_SEVERE;
				    END;


				! The user is not permitted to set a watchpoint on
				! a variable bound to either the context registers
				! or the user runframe registers.
				!
				IF DBG$MAP_TO_REG_ADDR
					(.EVENT_ENTRY [EVENT$L_ADDRESS], DUMMY)
				THEN
				    BEGIN
				    SIGNAL (DBG$_NOWATTAR);
				    RETURN STS$K_SEVERE;
				    END;

				IF (DBG$RUNFRAME [DBG$L_USER_REGS] LEQA
				    .EVENT_ENTRY [EVENT$L_ADDRESS]) AND
				   (.EVENT_ENTRY [EVENT$L_ADDRESS] LSSA
				    DBG$RUNFRAME [DBG$L_USER_REGS] + 68)
				THEN
				    BEGIN
				    SIGNAL(DBG$_BADWATCH, 1,
					    .EVENT_ENTRY[EVENT$L_ADDRESS]);
				    RETURN STS$K_SEVERE;
				    END;


				! Save the value descriptor by making a copy of
				! the value descriptor out of non-volatile storage.
				!
				! Obtain the symid list, and lock it.
				!
				DBG$NGET_SYMID (.VALUE, SYMID_LIST, DUMMY);
				DBG$STA_LOCK_SYMID (.SYMID_LIST);
				    

				! Copy the value descriptor.
				!
				DBG$NCOPY_DESC (.VALUE,
						EVENT_ENTRY [EVENT$L_VALDESC],
						DUMMY);


				! Flag that this event has a value descriptor, and
				! point the event entry to it's value.
				!
				EVENT_ENTRY [EVENT$V_HAS_VAL_DSCR] = TRUE;


				! Get the pages associated with this value
				!
				IF NOT DBG$NGET_PAGES
					    (.EVENT_ENTRY[EVENT$L_PRIMARY],
					     PAGE_LIST, .MESSAGE_VECT)
				THEN
				    BEGIN
				    SIGNAL(DBG$_BADWATCH, 1,
					    .EVENT_ENTRY[EVENT$L_ADDRESS]);
				    RETURN STS$K_SEVERE;
				    END;


				! While there are entries in the page list, add a
				! new page reference in the page queue.
				!
				DO
				    BEGIN


				    ! Search through the existing entries in the
				    ! page queue for this page.
				    !
				    PAGE_ENTRY = .EVENT$PAGE_QUEUE [L_QUEUE_FLINK];
				    PAGE_FOUND = FALSE;
				    WHILE .PAGE_ENTRY NEQA EVENT$PAGE_QUEUE DO
					BEGIN
					IF .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS] EQLA
					   .PAGE_LIST [1]
					THEN


					    ! A match is found, so bump the refer-
					    ! ence count, flag a find, and exit
					    ! this loop.
					    !
					    BEGIN
					    PAGE_ENTRY [EVENT$W_PAGE_REF_COUNT] =
						.PAGE_ENTRY [EVENT$W_PAGE_REF_COUNT] + 1;
					    PAGE_FOUND = TRUE;
					    EXITLOOP;
					    END


					! Not found yet, point to the next one.
					!
					ELSE
					    PAGE_ENTRY = .PAGE_ENTRY [EVENT$L_PAGE_FLINK];

					END;


				    ! If no match was found, add a new entry to the
				    ! page queue, and fill it in.
				    !
				    IF NOT .PAGE_FOUND
				    THEN
					BEGIN
					LOCAL
					    ADDRESS :	VECTOR [2],
					    PROTECT;

					ADDRESS [0] = .PAGE_LIST [1];
					ADDRESS [1] = .PAGE_LIST [1];
					IF NOT $SETPRT (INADR	=   ADDRESS,
							PROT	=   PRT$C_UR,
							PRVPRT	=   PROTECT
						       )
					THEN
					    BEGIN
					    SIGNAL (DBG$_BADWATCH, 1, .PAGE_LIST [1]);
					    RETURN STS$K_SEVERE;
					    END;
					IF NOT $SETPRT (INADR	=   ADDRESS,
							PROT	=   .PROTECT
						       )
					THEN
					    BEGIN
					    SIGNAL (DBG$_NOWPROT);
					    RETURN STS$K_SEVERE;
					    END;
					PAGE_ENTRY = DBG$GET_MEMORY (EVENT$K_PAGE_DESCRIPTOR_SIZE);
					INSQUE (.PAGE_ENTRY, EVENT$PAGE_QUEUE);
					PAGE_ENTRY [EVENT$L_PAGE_ADDRESS] = 
					    .PAGE_LIST [1];
					PAGE_ENTRY [EVENT$W_PAGE_REF_COUNT] = 1;
					END;
				    PAGE_LIST = .PAGE_LIST [0];
				    END
				WHILE .PAGE_LIST;
				END;
			    END;
			TES;


		    ! Point to the next noun node.
		    !
		    NOUN_NODE = .NOUN_NODE [DBG$L_NOUN_LINK];


		    ! If there's more addresses, get an new event descriptor
		    ! from permanent memory, copy the current one to it, and
		    ! link it to the working queue; otherwise, exit this loop.
		    !
		    IF .NOUN_NODE NEQA 0
		    THEN
			BEGIN


			! Get another event descriptor, and copy the old
			! one into it.
			!
			EVENT_ENTRY = DBG$GET_MEMORY
					(EVENT$K_EVENT_DESCRIPTOR_SIZE);
			CH$MOVE
			    (EVENT$K_EVENT_DESCRIPTOR_SIZE * 4,
			     .EVENT_QUEUE [L_QUEUE_FLINK],
			     .EVENT_ENTRY
			    );


			! Link the new one into the working queue.
			!
			INSQUE (.EVENT_ENTRY, EVENT_QUEUE);


			! If the old entry has a WHEN, bump the WHEN's
			! reference count.
			!
			IF .EVENT_ENTRY [EVENT$L_WHEN] NEQA 0
			THEN
			    WHEN_ENTRY [EVENT$L_WHEN_COUNT] =
				.WHEN_ENTRY [EVENT$L_WHEN_COUNT] + 1;


			! If the old entry has a DO LIST, bump the DO LIST's
			! reference count.
			!
			IF .EVENT_ENTRY [EVENT$L_DO] NEQA 0
			THEN
			    DO_ENTRY [EVENT$L_DO_LIST_COUNT] =
				.DO_ENTRY [EVENT$L_DO_LIST_COUNT] + 1;

			END

		    ELSE
			EXITLOOP;

		    END

		END;


	! Instruction events...
	!
	[EVENT$K_KIND_INS]:
	    SELECTONE .EVENT_ENTRY [EVENT$B_SUB_KIND] OF
		SET
		[EVENT$K_INS_CALL]:
		    EVENT_ENTRY [EVENT$L_OPCODE_LIST] = DBG$OPCODES_CALL;
		[EVENT$K_INS_BRAN]:
		    EVENT_ENTRY [EVENT$L_OPCODE_LIST] = DBG$OPCODES_BRANCH;
		[EVENT$K_INS_EVRY]:
		    EVENT_ENTRY [EVENT$L_OPCODE_LIST] = 0;
		[EVENT$K_INS_USER]:
		    BEGIN
    		    LOCAL
    			OPCODE_LIST: REF BITVECTOR[512];


    	    	    ! Allocate space for the opcode list.
    	    	    ! 512 bits = 16 longwords
    	    	    !
    	    	    OPCODE_LIST = DBG$GET_MEMORY(16);


    		    ! If this is a STEP or SET STEP command without any /INST=(opcode...)
    		    ! and we get here then the user must have previously
    		    ! done SET STEP INST=(opcode-list). In this case we
    		    ! initialize the OPCODE_LIST from the copy of
    		    ! the opcode list that we saved away on the SET STEP command.
    		    ! Otherwise, we just clear the opcode list.
		    !
    		    IF (.NOUN_NODE EQLA 0) AND
    		       ((.VERB_NODE[DBG$B_VERB_COMPOSITE] EQL EVENT$K_STEP) OR
    		        (.VERB_NODE[DBG$B_VERB_COMPOSITE] EQL EVENT$K_SET_STEP))
       		    THEN
    			BEGIN
    			CH$MOVE (64, DBG$OPCODES_STEP_USER, .OPCODE_LIST);
    			CH$MOVE (64, DBG$OPCODES_STEP_USER, DBG$OPCODES_USER);
    			END
    		    ELSE
    			BEGIN
		        CH$FILL (0, 64, .OPCODE_LIST);
		        CH$FILL (0, 64, DBG$OPCODES_USER);
    			END;


		    ! For each opcode (found in the noun node(s) value,
		    ! set the corresponding opcode's bit in the User
		    ! opcode bitmap.
		    !
		    WHILE .NOUN_NODE NEQA 0 DO
			BEGIN
			OPCODE_LIST [.NOUN_NODE [DBG$L_NOUN_VALUE]] = 1;
			DBG$OPCODES_USER [.NOUN_NODE [DBG$L_NOUN_VALUE]] = 1;
			NOUN_NODE = .NOUN_NODE [DBG$L_NOUN_LINK]
			END;


		    ! Now point the event entry to the user opcode bitmap.
		    !
		    EVENT_ENTRY [EVENT$L_OPCODE_LIST] = .OPCODE_LIST;
		    END;


		[EVENT$K_INS_LINE]:
		    EVENT_ENTRY [EVENT$L_OPCODE_LIST] = 0;


		! An invalid sub-kind, yell !
		!
		[OTHERWISE]:
		    $DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 60');

		TES;


	! /EXCEPTION kind - do nothing.
	!
	[EVENT$K_KIND_EXC]:
	    0;

	! An invalid kind, yell !
	!
	[OTHERWISE]:
	    $DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 70');

	TES;


    ! If this is a STEP or SET STEP command, process the entry now.
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS
    THEN
	BEGIN


	! If this is a SET STEP command, just point to the user-defined STEP
	! definitions.
	!
	IF .VERB_NODE [DBG$B_VERB_COMPOSITE] EQLU EVENT$K_SET_STEP
	THEN
	    DBG$SET_STP_LVL (USER_DEF_STEP)


	! This is a STEP command.
	!
	ELSE
	    BEGIN


	    ! This is a STEP command.  Make sure that we're not trying to
	    ! step from an exception.
	    !
	    IF .DBG$GB_EXC_BRE_FLAG
	    THEN
		SIGNAL(DBG$_STEFROEXC)


	    ! We are not stepping from an exception, so we can indeed step.'
	    !
	    ELSE
		BEGIN


		! Make sure that we can start up where we are at.
		!
		IF NOT PROBER(%REF(0), %REF(1), .DBG$RUNFRAME[DBG$L_USER_PC])
		THEN
		    SIGNAL(DBG$_BADSTARTPC, 1, .DBG$RUNFRAME[DBG$L_USER_PC])


		! We can indeed start here, so this STEP is okay.
		!
		ELSE
		    BEGIN


		    ! Point to STEP override definitions.
		    !
		    DBG$SET_STP_LVL (OVERRIDE_STEP);


		    ! Update the step count (probably not needed any more).
		    !
		    DBG$GL_STEP_NUM = .EVENT_ENTRY [EVENT$L_AFTER_COUNT];


		    ! Is the user didn't type STEP 0 (a NOP), add this entry
		    ! to the event queue.
		    !
		    IF .EVENT_ENTRY [EVENT$L_AFTER_COUNT] GTRU 0
    		    THEN
			BEGIN


			! Remove this new entry from the working queue, and
			! insert it into HEAD end of the Command Queue (we
			! want steps to show up first).
			!
			REMQUE (.EVENT_ENTRY, EVENT_ENTRY);
			INSQUE (.EVENT_ENTRY, EVENT$CMD_QUEUE);


			! Initialize the queue header within the entry (FLINK1
			! and BLINK1) to be empty....
			!
			EVENT_ENTRY [EVENT$L_EXC_FLINK] = .EVENT_ENTRY;
			EVENT_ENTRY [EVENT$L_EXC_BLINK] = .EVENT_ENTRY;


			! If this is a STEP/RETURN, save the current PC and
			! set the saved FP to the current FP (unless we are
			! looking at a RET instruction, in which case we're
			! going to STEP out one routine level).
			!
			IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU
			   EVENT$K_ACC_RTRN
			THEN
			    BEGIN
			    BUILTIN PROBER;
			    LOCAL
    				CALL_FRAME      : REF VECTOR[,LONG],
				STACK_FRAME	: REF BLOCK [,BYTE],
				INSTRUCTION	: BYTE;

			    EVENT_ENTRY [EVENT$L_USERS_PC] = .DBG$RUNFRAME [DBG$L_USER_PC];
			    EVENT_ENTRY [EVENT$L_USERS_FP] = .DBG$RUNFRAME [DBG$L_USER_FP];
			    IF PROBER(%REF(0),%REF(1),.DBG$RUNFRAME[DBG$L_USER_PC])
			    THEN
				BEGIN
				INSTRUCTION = .(.DBG$RUNFRAME[DBG$L_USER_PC])<0,8,0>;
				IF (.INSTRUCTION EQLU %X'04')
				THEN
				    BEGIN
				    STACK_FRAME = .DBG$RUNFRAME[DBG$L_USER_FP];
				    IF PROBER(%REF(0), %REF(20), .STACK_FRAME)
				    THEN
					EVENT_ENTRY[EVENT$L_USERS_FP] =
						.STACK_FRAME[SF$L_SAVE_FP];
				    END;
				END;

    			    ! Save more info from FP. in the Event.
    			    !
    			    CALL_FRAME = DBG$GET_MEMORY(5);
    			    EVENT_ENTRY[EVENT$L_CALL_FRAME] = .CALL_FRAME;
    			    CH$MOVE(20,.EVENT_ENTRY[EVENT$L_USERS_FP],.CALL_FRAME);
			    END;


			! This was a STEP command - stop taking commands.
			!
			DBG$GB_TAKE_CMD = FALSE;
			END;

		    END;

		END;

	    END;


	! Setup the stepping flags.
	!
	DBG$GB_STP_PTR [EVENT$B_STEPPING_KIND] =
	    .EVENT_ENTRY [EVENT$B_SUB_KIND];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_LINE] =
	    .EVENT_ENTRY [EVENT$V_STEP_LINE];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_OVER] =
	    .EVENT_ENTRY [EVENT$V_STEP_OVER];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_SOURCE] =
	    .EVENT_ENTRY [EVENT$V_STEP_SOURCE];
	DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSYSTEM] =
	    .EVENT_ENTRY [EVENT$V_STEP_NOSYSTEM];
    	DBG$GB_STP_PTR [EVENT$V_STEPPING_NOSILENT] =
    	    .EVENT_ENTRY [EVENT$V_STEP_NOSILENT];


    	! Save away the opcode list we have built. We get here on
    	! SET STEP INST= (opcode-list)
    	!
    	IF .VERB_NODE[DBG$B_VERB_COMPOSITE] EQL EVENT$K_SET_STEP
    	THEN
    	    BEGIN
    	    IF .EVENT_ENTRY[EVENT$B_SUB_KIND] EQL EVENT$K_INS_USER
    	    THEN
    	        BEGIN
    	        CH$MOVE(64, DBG$OPCODES_USER, DBG$OPCODES_STEP_USER);
    	        DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST] = DBG$OPCODES_STEP_USER;
    	        END

    	    ELSE
    	        DBG$GB_STP_PTR [EVENT$L_STEPPING_OP_LIST] = 0;
    	    END;
	END


    ! This is not a STEP or SET STEP command, so it must be SET BREAK, SET
    ! TRACE, or SET WATCH.
    !
    ELSE
	BEGIN


	! Now that we've built a working list of event entries, add them to
	! the Command Queue, deleting existing entries that match new ones.
	!
	! For each new event entry, check the existing entries in the
	! Command queue for any entries that match (command types, and
	! addresses if the command type is an access type).
	!
	! So, while there are (still) entries on the working queue....
	!
	WHILE .EVENT_QUEUE [L_QUEUE_FLINK] NEQA EVENT_QUEUE DO
	    BEGIN


	    ! Point EVENT_ENTRY to the first new event entry on the
	    ! working queue.
	    !
	    EVENT_ENTRY = .EVENT_QUEUE [L_QUEUE_FLINK];


	    ! Point to the first and next existing entries in the Command Queue.
	    !
	    QUEUE_ENTRY = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
	    NEXTQ_ENTRY = .QUEUE_ENTRY [EVENT$L_CMD_FLINK];


	    ! For each existing entry...
	    !
	    WHILE .QUEUE_ENTRY NEQA EVENT$CMD_QUEUE DO
		BEGIN


		! Ignore any 'deleted' entries that haven't actually been
		! removed.
		!
		IF NOT .QUEUE_ENTRY [EVENT$V_DELETED]
		THEN
		    BEGIN


		    ! Compare the command kind of this existing entry and the
		    ! new one.
		    !
		    IF .EVENT_ENTRY [EVENT$B_CMD_KIND] EQLU
		       .QUEUE_ENTRY [EVENT$B_CMD_KIND]
		    THEN
			BEGIN


			! The command kinds match.  Select on the kind.
			!
			SELECTONE .EVENT_ENTRY [EVENT$B_CMD_KIND] OF
			    SET


			    ! The command kind is access (/READ, /WRITE,
			    ! /MODIFY, /EXECUTE, or /RETURN).  We now have to
			    ! compare the entries to determine if the existing
			    ! one must be deleted.
			    !
			    [EVENT$K_KIND_ACC]:
				BEGIN
				LOCAL CODE_1,CODE_2;
				
				!   If either of the entries is /EXECUTE or
				! /RETURN, we'll compare the byte addresses,
				! otherwise compare the two VMS descriptors,
				! and delete the exisiting entry if they're
				! the same.
				!
				CODE_1 = .EVENT_ENTRY [EVENT$B_SUB_KIND];
				CODE_2 = .QUEUE_ENTRY [EVENT$B_SUB_KIND];
				IF (IF (.CODE_1 EQLU EVENT$K_ACC_EXEC)
				    OR (.CODE_1 EQLU EVENT$K_ACC_RTRN)
				    OR (.CODE_2 EQLU EVENT$K_ACC_EXEC)
				    OR (.CODE_2 EQLU EVENT$K_ACC_RTRN)
				    THEN
					.EVENT_ENTRY [EVENT$L_ADDRESS] EQLA
					.QUEUE_ENTRY [EVENT$L_ADDRESS]
				    ELSE
					COMPARE_VMSDESC(EVENT_ENTRY [EVENT$A_VMSDESC],
							QUEUE_ENTRY [EVENT$A_VMSDESC])
				   )
				THEN
				    QUEUE_ENTRY [EVENT$V_DELETED] = TRUE;
				END;


			    ! The command kind is instruction.  Compare the two
			    ! entries' subkind, and delete the existing entry
			    ! if they're the same.
			    !
			    [EVENT$K_KIND_INS]:
				CASE .EVENT_ENTRY [EVENT$B_SUB_KIND]
				FROM EVENT$K_INS_CALL TO EVENT$K_INS_USER OF
				    SET
				    [EVENT$K_INS_CALL TO EVENT$K_INS_LINE]:
					IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU
					   .QUEUE_ENTRY [EVENT$B_SUB_KIND]
					THEN
					    QUEUE_ENTRY [EVENT$V_DELETED] =
						TRUE;
				    [EVENT$K_INS_EVRY TO EVENT$K_INS_USER]:
					IF (.QUEUE_ENTRY [EVENT$B_SUB_KIND] EQLU
					    EVENT$K_INS_EVRY) OR
					   (.QUEUE_ENTRY [EVENT$B_SUB_KIND] EQLU
					    EVENT$K_INS_USER)
					THEN
					    QUEUE_ENTRY [EVENT$V_DELETED] =
						TRUE;
				    TES;


			    ! The access type is exception, so delete the
			    ! existing entry.
			    !
			    [EVENT$K_KIND_EXC]:
				QUEUE_ENTRY [EVENT$V_DELETED] = TRUE;


			    ! The command kind is invalid - yell !
			    !
			    [OTHERWISE]:
				$DBG_ERROR('DBGEVENT\EVENT_SEMANTICS 80');

			    TES;

			END;

		    END;


		! Point to the next Command Queue entries.
		!
		QUEUE_ENTRY = .NEXTQ_ENTRY;
		NEXTQ_ENTRY = .QUEUE_ENTRY [EVENT$L_CMD_FLINK];
		END;


	    ! Remove this new entry from the working queue, and insert
	    ! it into tail end of the Command Queue.
	    !
	    REMQUE (.EVENT_ENTRY, EVENT_ENTRY);
	    INSQUE (.EVENT_ENTRY, .EVENT$CMD_QUEUE [L_QUEUE_BLINK]);


	    ! Initialize the queue header within the entry (FLINK1 and BLINK1)
	    ! to be empty.
	    !
	    EVENT_ENTRY [EVENT$L_EXC_FLINK] = .EVENT_ENTRY;
	    EVENT_ENTRY [EVENT$L_EXC_BLINK] = .EVENT_ENTRY;
	    END;

	END;


    ! Delete any entries that remain in the working queue.
    ! This happens on SET STEP or on STEP 0.
    !
    EVENT_ENTRY = .EVENT_QUEUE[L_QUEUE_FLINK];
    WHILE .EVENT_ENTRY NEQU EVENT_QUEUE DO
    	BEGIN
    	LOCAL
    	    NEW_EVENT_ENTRY;
    	NEW_EVENT_ENTRY = .EVENT_ENTRY[EVENT$L_CMD_FLINK];
    	DELETE_EVENT_ENTRY(.EVENT_ENTRY);
    	EVENT_ENTRY = .NEW_EVENT_ENTRY;
    	END;


    ! All's well that ends well.
    !
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$EVENT_SHOW_CANCEL_SYNTAX(INPUT_DESC,
						VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine parses a show or cancel break, trace, or watch point
!	command,
!	after the '[SHOW|CANCEL] BREAK', '[SHOW|CANCEL] TRACE', or
!	'[SHOW|CANCEL] WATCH' has been parsed.  This routine is called
!	from DBGNSET.
!
!	The following syntax is accepted:
!
!	<event>
!
!	If the event is a watchpoint, <event> is:
!
!	/ALL |
!	[ <address> [ , <address> ]*]
!
!	otherwise, <event> is:
!
!	/EXCEPTION |
!	/CALL |
!	/RETURN |
!	/BRANCH |
!	/LINE |
!	/INSTRUCTION [ = ( <mnemonic> [ , <mnemonic> ] ) ]
!	/ALL |
!	[ <address> [ , <address> ]*]
!
! INPUTS
!	INPUT_DESC:	The current command line input descriptor.
!	VERB_NODE:	A pointer to a DEBUG verb node, with the COMPOSITE
!			attribute set to:
!
!			    EVENT$K_SHOW_BREAK, EVENT$K_SHOW_TRACE,
!			    EVENT$K_SHOW_WATCH,
!			    EVENT$K_CANCEL_BREAK, EVENT$K_CANCEL_TRACE,
!			    EVENT$K_CANCEL_WATCH.
!
!	MESSAGE_VECT:	The address of a longword to contain the address
!			of a message argument vector.
!
! OUTPUTS
!	The parse tree headed by VERB_NODE is created to represent the
!	command parsed.  Errors cause this routine to abort.
!
    BEGIN

    MAP
	VERB_NODE :	REF DBG$VERB_NODE;	! Verb node pointer

    LOCAL
	STATUS,					! Returned status
	ADVERB_NODE : 	REF DBG$ADVERB_NODE,	! Adverb node pointer
	ADVERB_LINK : 	REF DBG$ADVERB_NODE,	! Adverb node link
	NOUN_NODE :	REF DBG$NOUN_NODE,	! Noun node pointer
	NOUN_LINK :	REF DBG$NOUN_NODE;	! Noun node link

    BIND


	! Define the character strings to parse.
	!
	DBG$CS_EXCEPTION =	$AC ('EXCEPTION'),
	DBG$CS_INSTRUCTION =	$AC ('INSTRUCTION'),
	DBG$CS_CALL =		$AC ('CALL'),
	DBG$CS_RETURN =		$AC ('RETURN'),
	DBG$CS_BRANCH =		$AC ('BRANCH'),
	DBG$CS_LINE =		$AC ('LINE'),
	DBG$CS_ALL =		$AC ('ALL'),
	DBG$CS_COMMA =		$AC (','),
	DBG$CS_SLASH =		$AC ('/'),
	DBG$CS_CR =		UPLIT BYTE (1, DBG$K_CAR_RETURN);


    ! Initialize status to success, in case we don't need to
    ! parse any addresses.
    !
    STATUS = STS$K_SUCCESS;


    ! Initialize the verb's adverb and noun pointers to null.
    !
    VERB_NODE [DBG$L_VERB_ADVERB_PTR] = 0;
    VERB_NODE [DBG$L_VERB_OBJECT_PTR] = 0;


    ! Initialize the adverb and noun links.
    !
    ADVERB_LINK = VERB_NODE [DBG$L_VERB_ADVERB_PTR];
    NOUN_LINK = VERB_NODE [DBG$L_VERB_OBJECT_PTR];


    ! Case on the verb composite - the command type is [SHOW|CANCEL] BREAK,
    ! [SHOW|CANCEL] TRACE, or [SHOW|CANCEL] WATCH.
    !
    SELECTONE .VERB_NODE [DBG$B_VERB_COMPOSITE] OF
	SET


	! [SHOW|CANCEL] BREAK and [SHOW|CANCEL] TRACE come here,
	! to determine the event type.
	!
	[EVENT$K_SHOW_BREAK, EVENT$K_CANCEL_BREAK,
	 EVENT$K_SHOW_TRACE, EVENT$K_CANCEL_TRACE]:
	    BEGIN


	    ! Parse the command according to the following syntax:
	    !
	    !	/EXCEPTION
	    !	/CALL
	    !	/RETURN
	    !	/BRANCH
	    !	/LINE
	    !	/INSTRUCTION
	    !	/ALL
	    !	[ <address> [ , <address> ]*]
	    !
	    ! First, look for a '/'...
	    !
	    IF MATCH (DBG$CS_SLASH)
	    THEN
		BEGIN


		! Get an node for the qualifier.
		!
		GET_ADVERB_NODE;


		! Parse the qualifier.
		!
		SELECTONE TRUE OF
		    SET


		    ! Parse /EXECEPTION.
		    !
		    [MATCH (DBG$CS_EXCEPTION)]:
			ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
			    ADVERB_EXCEPTION;
	 
	 
		    ! Parse /CALL.
		    !
		    [MATCH (DBG$CS_CALL)]:
			ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
			    ADVERB_CALL;


		    ! Parse /BRANCH.
		    !
		    [MATCH (DBG$CS_BRANCH)]:
			ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
			    ADVERB_BRANCH;


		    ! Parse /LINE.
		    !
		    [MATCH (DBG$CS_LINE)]:
			ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
			    ADVERB_LINE;


		    ! Parse /INSTRUCTION
		    !
		    [MATCH (DBG$CS_INSTRUCTION)]:
			ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
			    ADVERB_INSTRUCTION;


		    ! Parse /ALL
		    !
		    [MATCH (DBG$CS_ALL)]:
			ADVERB_NODE [DBG$B_ADVERB_LITERAL] =
			    ADVERB_ALL;


		    ! Otherwise, we've got a syntax error....
		    !
		    [OTHERWISE]:
			SYNTAX_ERROR;
		    TES
		END

	    ELSE

     
		! Parse the defaulting <address> [ , <address> ]*.
		!
		BEGIN


		! If we're not standing on a <cr>, get the
		! <address> [ , <address> ], as long as
		! an <address> is terminated with a ','.
		!
		IF	(NOT MATCH (DBG$CS_CR))
		THEN
		    DO
			BEGIN

			! Get a noun node for an <address>.
			!
			GET_NOUN_NODE;


			! Get an <address> - the is a status warning
			! if more is on the line.
			!
			STATUS = DBG$NPARSE_ADDRESS(.INPUT_DESC,
					NOUN_NODE[DBG$L_NOUN_VALUE],
					.DBG$GB_RADIX[DBG$B_RADIX_INPUT],
					TOKEN$K_TERM_COMMA, .MESSAGE_VECT);


			! If the status indicates success, there is no
			! more on the line, and we exit this loop.
			!
			IF .STATUS EQLU STS$K_SUCCESS
			THEN
			    EXITLOOP;


			! If the status is not a warning, something is
			! wrong, so return with a failure.
			!
			IF .STATUS NEQU STS$K_WARNING
			THEN
			    RETURN .STATUS
			END
		    WHILE (MATCH (DBG$CS_COMMA));

		END;

	    END;


	! Parse [SHOW|CANCEL] WATCH [[ /ALL | <address> [ , <address> ]*]].
	!
	[EVENT$K_SHOW_WATCH, EVENT$K_CANCEL_WATCH]:
	    BEGIN
	    IF MATCH (DBG$CS_SLASH)
	    THEN
		BEGIN
		GET_ADVERB_NODE;
		NEED_MATCH (DBG$CS_ALL);
		ADVERB_NODE [DBG$B_ADVERB_LITERAL] = ADVERB_ALL;
		END

	    ELSE
		BEGIN
		IF NOT MATCH (DBG$CS_CR)
		THEN
		    ! Get the <address> [ , <address> ], as long as
		    ! an <address> is terminated with a ','.
		    !
		    DO
			BEGIN
			

			! Get a noun node for an <address>.
			!
			GET_NOUN_NODE;


			! Get an <address> - the is a status warning
			! if more is on the line.
			!
			STATUS = DBG$NPARSE_ADDRESS(.INPUT_DESC,
					NOUN_NODE[DBG$L_NOUN_VALUE],
					.DBG$GB_RADIX[DBG$B_RADIX_INPUT],
					TOKEN$K_TERM_COMMA, .MESSAGE_VECT);


			! If the status indicates success, there is no
			! more on the line, and we exit this loop.
			!
			IF .STATUS EQLU STS$K_SUCCESS
			THEN
			    EXITLOOP;


			! If the status is not a warning, something is
			! wrong, so return with a failure.
			!
			IF .STATUS NEQU STS$K_WARNING
			THEN
			    RETURN .STATUS;

			END
		    WHILE (MATCH (DBG$CS_COMMA));

		END;

	    END;

	TES;


    ! Check the status after parsing <address> [ , <address> ] or <mnemonic>
    ! [ , <mnemonic> ].  If there's nothing left on the line, the status will
    ! be success, and we can leave.  Otherwise we signal a syntax error.
    !
    IF .STATUS EQLU STS$K_SUCCESS THEN RETURN STS$K_SUCCESS;
    .MESSAGE_VECT = DBG$NSYNTAX_ERROR (DBG$NNEXT_WORD (.INPUT_DESC));
    RETURN STS$K_SEVERE

    END;

GLOBAL ROUTINE DBG$EVENT_SHOW_CANCEL_SEMANTICS(VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine builds the event data stuctures based on the
!	parse tree passed via the VERB_NODE address.  This routine
!	is called from DBGNSET.
!
! INPUTS
!	VERB_NODE:	A pointer to a DEBUG verb node, which defines,
!			along with the verb's descendants, the desired
!			command.
!	MESSAGE_VECT:	The address of a longword to contain the address
!			of a message argument vector.
!
! OUTPUTS
!	The event data structure(s) are updated to include the new event,
!	and may include:
!
!	    EVENT$CMD_QUEUE,
!	    EVENT$WHEN_QUEUE,
!	    EVENT$DO_LIST_QUEUE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Verb node pointer

    MACRO
	SHOW_OR_DELETE_EVENT_ENTRY (EVENT_ENTRY) =
	    BEGIN
	    IF .VERB_NODE [DBG$B_VERB_LITERAL] EQLU DBG$K_SHOW_VERB
	    THEN
	        SHOW_EVENT_ENTRY (.EVENT_ENTRY)

	    ELSE
		EVENT_ENTRY [EVENT$V_DELETED] = TRUE;

	    SHOWED_CANCELED_ONE = TRUE;
	    END
	%;

    LOCAL
    	DUMMY,
	EVENT_QUEUE: QUEUE_HEAD,		! Working queue head
	QUEUE_ENTRY: REF EVENT$EVENT_DESCRIPTOR,! Event queue entry pointer
	NEXTQ_ENTRY: REF EVENT$EVENT_DESCRIPTOR,! Event queue entry pointer
	EVENT_ENTRY: REF EVENT$EVENT_DESCRIPTOR,! Event entry pointer
	DO_ENTRY: REF EVENT$DO_LIST_DESCRIPTOR, ! DO List entry pointer
	WHEN_ENTRY: REF EVENT$WHEN_DESCRIPTOR,	! WHEN entry pointer
	ADVERB_NODE: REF DBG$ADVERB_NODE,	! Adverb node link
	NOUN_NODE: REF DBG$NOUN_NODE,		! Noun node link
	PRIMARY: REF DBG$PRIMARY,		! Event primary descriptor
	VALUE: REF DBG$VALDESC,			! Event value descriptor
	ADDRESS: VECTOR [2],			! Event address
	ADR_TYP,				! Event address type
	SHOW_CANCEL_ALL,			! Show or Cancel all ?
	SHOWED_CANCELED_ANY,			! Did we show/cancel any yet ?
	SHOWED_CANCELED_ONE,			! Did we show/cancel one yet ?
	COUNTER;				! Counter variable



    ! Initialize the working queue to be empty.
    !
    EVENT_QUEUE [L_QUEUE_FLINK] = EVENT_QUEUE;
    EVENT_QUEUE [L_QUEUE_BLINK] = EVENT_QUEUE;


    ! Get an event descriptor from permanent memory, and
    ! link it into the working queue.
    !
    EVENT_ENTRY = DBG$GET_MEMORY (EVENT$K_EVENT_DESCRIPTOR_SIZE);
    INSQUE (.EVENT_ENTRY, EVENT_QUEUE);


    ! Initialize the command kind to access (default).
    !
    EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;


    ! Set the event's command type, found in the verb.
    !
    SELECTONE .VERB_NODE [DBG$B_VERB_COMPOSITE] OF
	SET

	[EVENT$K_SHOW_BREAK, EVENT$K_CANCEL_BREAK]:
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_BREAK;

	[EVENT$K_CANCEL_BREAK_EXC]:
	    BEGIN
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_BREAK;
	    EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_EXC;
	    END;

	[EVENT$K_SHOW_TRACE, EVENT$K_CANCEL_TRACE]:
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_TRACE;

	[EVENT$K_SHOW_WATCH, EVENT$K_CANCEL_WATCH]:
	    EVENT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_WATCH;

	[OTHERWISE]:
	    $DBG_ERROR('DBGEVENT\EVENT_SHOW_CANCEL_SEMANTICS 10');
	
	TES;


    ! Initialize Has Value Descriptor flag.
    !
    EVENT_ENTRY [EVENT$V_HAS_VAL_DSCR] = FALSE;


    ! Initialize the Primary pointer to NULL.
    !
    EVENT_ENTRY [EVENT$L_PRIMARY] = 0;


    ! Point to the verb's noun list.
    !
    NOUN_NODE = .VERB_NODE [DBG$L_VERB_OBJECT_PTR];


    ! Point to the verb's adverb list.
    !
    ADVERB_NODE = .VERB_NODE [DBG$L_VERB_ADVERB_PTR];


    ! Initialize the All flag.
    !
    SHOW_CANCEL_ALL = FALSE;


    ! If an adverb exists, process it.
    !
    IF .ADVERB_NODE NEQA 0
    THEN
	BEGIN


	! Process adverbs based on the literal set by the
	! syntactic processing.
	!
	SELECTONE .ADVERB_NODE [DBG$B_ADVERB_LITERAL] OF
	    SET


	    ! Process the /EXCEPTION adverb.
	    !
	    [ADVERB_EXCEPTION]:
		    EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_EXC;


	    ! Process the /CALL, /RETURN, /BRANCH, /LINE, /OPCODE
	    ! and /INSTRUCTION instruction-kind adverbs.
	    !
	    [ADVERB_CALL, ADVERB_RETURN, ADVERB_BRANCH,
	     ADVERB_LINE, ADVERB_OPCODE, ADVERB_INSTRUCTION]:
		BEGIN


		! Define the event kind to be instruction.
		!
		EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_INS;


		! Define the subkind according to the adverb.
		!
		EVENT_ENTRY [EVENT$B_SUB_KIND] =
		    (SELECTONE .ADVERB_NODE [DBG$B_ADVERB_LITERAL] OF
			SET
			[ADVERB_CALL]:
			    EVENT$K_INS_CALL;
			[ADVERB_BRANCH]:
			    EVENT$K_INS_BRAN;
			[ADVERB_LINE]:
			    EVENT$K_INS_LINE;
			[ADVERB_OPCODE]:
			    EVENT$K_INS_USER;
			[ADVERB_INSTRUCTION]:
			    EVENT$K_INS_EVRY;
			[OTHERWISE]:
			    $DBG_ERROR('DBGEVENT\EVENT_SHOW_CANCEL_SEMANTICS 20');
			TES
		    )
		END;


	    ! Process the /ALL adverb.
	    !
	    [ADVERB_ALL]:
		SHOW_CANCEL_ALL = TRUE;


	    ! An invalid adverb literal - yell !
	    !
	    [OTHERWISE]:
		$DBG_ERROR('DBGEVENT\EVENT_SHOW_CANCEL_SEMANTICS 30');

	    TES;

	END;


    ! If there are no noun nodes, set the All flag if this is a
    ! SHOW command.  Otherwise, make sure the command kind is
    ! (still) access, and process the address(es).
    !
    IF .NOUN_NODE EQLA 0
    THEN
	BEGIN
	IF .VERB_NODE [DBG$B_VERB_LITERAL] EQLU DBG$K_SHOW_VERB
	THEN
	    SHOW_CANCEL_ALL = TRUE;

	END

    ELSE
	BEGIN


	! Build duplicate event entries, one for each
	! address found in the noun node list.
	!
	WHILE TRUE DO
	    BEGIN


	    ! Using the address's primary descriptor, get the address.
	    !
	    PRIMARY = .NOUN_NODE [DBG$L_NOUN_VALUE];
	    EVENT_ENTRY [EVENT$V_BREAK_ADDRESS] = FALSE;
	    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_BREAK OR
	       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_TRACE
	    THEN
		BEGIN
		IF .PRIMARY[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
		THEN
		    BEGIN
		    IF .PRIMARY[DBG$B_DHDR_KIND] EQL RST$K_ROUTINE OR
		       .PRIMARY[DBG$B_DHDR_KIND] EQL RST$K_ENTRY
		    THEN
			EVENT_ENTRY [EVENT$V_BREAK_ADDRESS] = TRUE;

		    END;

		END;

    	    IF NOT DBG$NGET_ADDRESS(.PRIMARY, ADDRESS[0], ADR_TYP,
		     (IF .EVENT_ENTRY [EVENT$V_BREAK_ADDRESS]
    		      THEN
			 TRUE
    		      ELSE
    			 FALSE),
		     .MESSAGE_VECT)
	    THEN
		RETURN STS$K_SEVERE;


	    EVENT_ENTRY [EVENT$L_ADDRESS] = .ADDRESS[0];
    	    IF NOT .EVENT_ENTRY [EVENT$V_BREAK_ADDRESS]
    	    THEN
    		BEGIN
    		IF DBG$IS_IT_ENTRY (.ADDRESS [0])
    		THEN
    		    EVENT_ENTRY [EVENT$L_ADDRESS] = .ADDRESS[0] + 2;

    		END;
	

	    ! Save the event's primary.
	    !
	    EVENT_ENTRY [EVENT$L_PRIMARY] = .NOUN_NODE [DBG$L_NOUN_VALUE];
    	    DBG$NCOPY_DESC(.EVENT_ENTRY [EVENT$L_PRIMARY], PRIMARY, DUMMY, FALSE);


	    ! Now, get and save the VMS descriptor.
	    !
	    DBG$PRIM_TO_VAL(.PRIMARY, DBG$K_V_VALUE_DESC, VALUE);
	    CH$MOVE(12, VALUE[DBG$A_VALUE_VMSDESC],
					EVENT_ENTRY[EVENT$A_VMSDESC]);


	    ! Point to the next noun node.
	    !
	    NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];


	    ! If there's more addresses, get an new event descriptor
	    ! from permanent memory, copy the current one to it, and
	    ! link it to the working queue; otherwise, exit this loop.
	    !
	    IF .NOUN_NODE NEQA 0
	    THEN
		BEGIN


		! Get another event descriptor, and copy the old
		! one into it.
		!
		EVENT_ENTRY = DBG$GET_MEMORY(EVENT$K_EVENT_DESCRIPTOR_SIZE);
		CH$MOVE(EVENT$K_EVENT_DESCRIPTOR_SIZE * 4,
				.EVENT_QUEUE [L_QUEUE_FLINK], .EVENT_ENTRY);


		! Link the new one into the working queue.
		!
		INSQUE (.EVENT_ENTRY, EVENT_QUEUE);
		END

	    ELSE
		EXITLOOP;

	    END

	END;


    ! Now that we've built a working list of event entries, compare them to
    ! the Command Queue, showing or deleting existing entries that match new
    ! ones.
    !
    ! For each new event entry, check the existing entries in the
    ! Command queue for any entries that match (command types, and
    ! addresses if the command type is an access type).
    !
    ! So, while there are (still) entries on the working queue....
    !
    SHOWED_CANCELED_ANY = FALSE;
    WHILE .EVENT_QUEUE [L_QUEUE_FLINK] NEQA EVENT_QUEUE DO
	BEGIN


	! Point EVENT_ENTRY to the first new event entry on the
	! working queue.
	!
	EVENT_ENTRY = .EVENT_QUEUE [L_QUEUE_FLINK];


	! Point to the first and next existing entries in the Command Queue.
	!
	QUEUE_ENTRY = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];


	! For each existing entry...
	!
	SHOWED_CANCELED_ONE = FALSE;
	WHILE .QUEUE_ENTRY NEQA EVENT$CMD_QUEUE DO
	    BEGIN


	    ! Ignore 'deleted' entries that haven't been removed.
	    !
	    IF NOT .QUEUE_ENTRY [EVENT$V_DELETED]
	    THEN
		BEGIN


		! Compare the command type with the existing one.
		!
		IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
		   .QUEUE_ENTRY [EVENT$B_CMD_TYPE]
		THEN
		    BEGIN


		    ! We found an existing entry of the right type, so
		    ! there is/are BREAK(s), TRACE(s), or WATCH(es) to
		    ! be checked.
		    !
		    SHOWED_CANCELED_ANY = TRUE;


		    ! If the /ALL qualifier was used, the show or delete
		    ! this entry.  Otherwise, we've got more checking to
		    ! do....
		    !
		    IF .SHOW_CANCEL_ALL
		    THEN
			SHOW_OR_DELETE_EVENT_ENTRY (QUEUE_ENTRY)

		    ELSE
			BEGIN


			! Compare the command kind of this existing entry
			! and the new one.
			!
			IF .EVENT_ENTRY [EVENT$B_CMD_KIND] EQLU
			   .QUEUE_ENTRY [EVENT$B_CMD_KIND]
			THEN
			    BEGIN


			    ! The command kinds match.  Select on the kind.
			    !
			    SELECTONE .EVENT_ENTRY [EVENT$B_CMD_KIND] OF
				SET


				! The command kind is access (/READ, /WRITE,
				! /MODIFY, /EXECUTE, or /RETURN).  We now have
				! to compare the addresses of the entries to
				! determine if this existing one must be deleted.
				!
				[EVENT$K_KIND_ACC]:
				    BEGIN
				    LOCAL CODE_1,CODE_2;
				    
				    ! If either of the entries is /EXECUTE or
				    ! /RETURN, we'll compare the byte addresses,
				    ! otherwise compare the two VMS descriptors,
				    ! and delete the exisiting entry if they're
				    ! the same.
				    !
				    CODE_1 = .EVENT_ENTRY [EVENT$B_SUB_KIND];
				    CODE_2 = .QUEUE_ENTRY [EVENT$B_SUB_KIND];
				    IF (IF (.CODE_1 EQLU EVENT$K_ACC_EXEC)
					OR (.CODE_1 EQLU EVENT$K_ACC_RTRN)
					OR (.CODE_2 EQLU EVENT$K_ACC_EXEC)
					OR (.CODE_2 EQLU EVENT$K_ACC_RTRN)
					THEN
					    .EVENT_ENTRY [EVENT$L_ADDRESS] EQLA
					    .QUEUE_ENTRY [EVENT$L_ADDRESS]
					ELSE
					    COMPARE_VMSDESC(EVENT_ENTRY [EVENT$A_VMSDESC],
							    QUEUE_ENTRY [EVENT$A_VMSDESC])
				       )
				    THEN
					SHOW_OR_DELETE_EVENT_ENTRY (QUEUE_ENTRY);
				    END;


				! The command kind is instruction.  Compare the two
				! entries' subkind, and delete the existing entry if
				! they're the same.
				!
				[EVENT$K_KIND_INS]:
				    CASE .EVENT_ENTRY [EVENT$B_SUB_KIND]
				    FROM EVENT$K_INS_CALL TO EVENT$K_INS_USER OF
					SET
					[EVENT$K_INS_CALL TO EVENT$K_INS_LINE]:
					    BEGIN
					    IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU
					       .QUEUE_ENTRY [EVENT$B_SUB_KIND]
					    THEN
						SHOW_OR_DELETE_EVENT_ENTRY (QUEUE_ENTRY);
					    END;
					[EVENT$K_INS_EVRY TO EVENT$K_INS_USER]:
					    BEGIN
					    IF (.QUEUE_ENTRY [EVENT$B_SUB_KIND] EQLU
						EVENT$K_INS_EVRY) OR
					       (.QUEUE_ENTRY [EVENT$B_SUB_KIND] EQLU
						EVENT$K_INS_USER)
					    THEN
						SHOW_OR_DELETE_EVENT_ENTRY (QUEUE_ENTRY);
					    END;
					TES;


				! The access type is exception, so delete the existing
				! entry.
				!
				[EVENT$K_KIND_EXC]:
				    SHOW_OR_DELETE_EVENT_ENTRY (QUEUE_ENTRY);


				! The command kind is invalid - yell !
				!
				[OTHERWISE]:
				    $DBG_ERROR('DBGEVENT\EVENT_SHOW_CANCEL_SEMANTICS 40');

				TES;

			    END;

			END;

		    END;

		END;


	    ! Point to the next Command Queue entries.
	    !
	    QUEUE_ENTRY = .QUEUE_ENTRY [EVENT$L_CMD_FLINK];
	    END;


	! If this entry wasn't shown or cancelled, announce the fact, but we
	! did find one of this type, say we couldn't find this one.
	!
	IF NOT .SHOWED_CANCELED_ONE AND .SHOWED_CANCELED_ANY
	THEN
	    SIGNAL	(SELECTONE .VERB_NODE [DBG$B_VERB_COMPOSITE] OF
			     SET
			     [EVENT$K_SHOW_BREAK, EVENT$K_CANCEL_BREAK,
    			      EVENT$K_CANCEL_BREAK_EXC]:
				 DBG$_NOSUCHBPT;
			     [EVENT$K_SHOW_TRACE, EVENT$K_CANCEL_TRACE]:
				 DBG$_NOSUCHTPT;
			     [EVENT$K_SHOW_WATCH, EVENT$K_CANCEL_WATCH]:
				 DBG$_NOSUCHWPT;
			     TES
			);


	! Remove this new entry from the working queue.
	!
	REMQUE (.EVENT_ENTRY, EVENT_ENTRY);
	DBG$REL_MEMORY (.EVENT_ENTRY);
	END;


    ! If we couldn't find an entry of the right type, announce the fact.
    !
    IF NOT .SHOWED_CANCELED_ANY
    THEN
	SIGNAL   (SELECTONE .VERB_NODE [DBG$B_VERB_COMPOSITE] OF
		     SET
		     [EVENT$K_SHOW_BREAK, EVENT$K_CANCEL_BREAK,
    		      EVENT$K_CANCEL_BREAK_EXC]:
			DBG$_NOBREAKS;
		     [EVENT$K_SHOW_TRACE, EVENT$K_CANCEL_TRACE]:
			DBG$_NOTRACES;
		     [EVENT$K_SHOW_WATCH, EVENT$K_CANCEL_WATCH]:
			DBG$_NOWATCHES;
		     TES
		    );


    ! We're done, bye.
    !
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$EVENT_CANCEL_ALL: NOVALUE =
!
! FUNCTION
!	This routine cancels all eventpoints.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	All command event entries are deleted from the command queue.
!

    BEGIN
    LOCAL
	EVENT_ENTRY :	REF EVENT$EVENT_DESCRIPTOR; ! Event entry pointer



    ! Starting at the head of the command queue, 'delete' the command
    ! entries.
    !
    EVENT_ENTRY = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
    WHILE .EVENT_ENTRY NEQA EVENT$CMD_QUEUE DO
	BEGIN


	! Ignore 'deleted' entries that haven't been removed.
	!
	IF NOT .EVENT_ENTRY [EVENT$V_DELETED]
	THEN


	    ! If this is a BREAK, TRACE, or WATCH command, delete it.
	    !
	    IF (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
	        EVENT$K_TYPE_BREAK
	       ) OR
	       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
	        EVENT$K_TYPE_TRACE
	       ) OR
	       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
	        EVENT$K_TYPE_WATCH
	       )
	    THEN
		EVENT_ENTRY [EVENT$V_DELETED] = TRUE;


	! Point to the next Command Queue entries.
	!
	EVENT_ENTRY = .EVENT_ENTRY [EVENT$L_CMD_FLINK];
	END;
    END;

GLOBAL ROUTINE DBG$ACTIVATE_EVENTS: NOVALUE =
!
! FUNCTION
!	This routine activates all set events.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	The events are activated, including the setting of breakpoints, the
!	setting of protections, etc.  The exception lists are also built.
!

    BEGIN

    LOCAL
    	USERS_FP: REF BLOCK [,BYTE],
	EVENT_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	NEXT_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	PAGE_ENTRY :	REF EVENT$PAGE_DESCRIPTOR;  ! Page entry pointer


    ! Turn off the TBIT flag, which will be set by any event(s) that need
    ! to use it....
    !
    DBG$RUNFRAME [DBG$V_TBIT] = FALSE;


    ! Point to the first Command Queue entry, and begin to process each entry
    ! in turn.
    !
    USERS_FP = 0;
    EVENT_ENTRY = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
    WHILE .EVENT_ENTRY NEQA EVENT$CMD_QUEUE [A_QUEUE_ENTRY] DO
	BEGIN


	! Point to the next entry (in case we end up deleting this one !!!
	!
	NEXT_ENTRY = .EVENT_ENTRY [EVENT$L_CMD_FLINK];


	! 'Delete' IGNOR entries....
	!
	IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_IGNOR
	THEN
	    EVENT_ENTRY [EVENT$V_DELETED] = TRUE;


	! Delete or Activate this event.
	!
	IF .EVENT_ENTRY [EVENT$V_DELETED]
	THEN
    	    BEGIN

	    ! *****SSI
	    ! EVENT$K_TYPE_SSINT Event is put on Event List, when we see 
	    ! DBG$_SS_INT signal comes in (DEBUG interception routine is 
	    ! called, trigged by System Service Call).  Bit 15 is set in
	    ! saved PSW in the FP for System service.  When system service
	    ! returns, DEBUG catches Reserved Operand Fault, EVENT$K_TYPE_SSINT
	    ! is marked deleted.  Now, we just about to take this event entry 
	    ! off the Event List.
    	    ! Check to see if we just got back from Reserved Operand Fault
    	    ! from intercept system service RET, if it is, remember FP.
    	    ! For we need to turn S/RET active entry to delete entry.
    	    ! S/RET was built from step over the CALLS SYS$XXX entry, since 
    	    ! we already got Reserved Operand Fault from RET, so we don't
    	    ! want to do it again, so later on we can turn S/RET into normal
	    ! step entry.
    	    !
    	    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_SSINT
    	    THEN
    		USERS_FP = .EVENT_ENTRY [EVENT$L_USERS_FP]
    	    ELSE
    		USERS_FP = 0;
	    DELETE_EVENT_ENTRY (.EVENT_ENTRY);
    	    END
	ELSE
	    DBG$ACTIVATE_EVENT (.EVENT_ENTRY);


	! Point to the next event and continue.
	!
	EVENT_ENTRY = .NEXT_ENTRY;


	! *****SSI
	! Check to see if this the case we noted above.  Turn S/RET into
	! normal Step entry.
	!
    	IF .USERS_FP NEQ 0
        THEN
    	    BEGIN
    	    IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQL EVENT$K_ACC_RTRN
    	    THEN
    	        BEGIN
    	        IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_STEPS
    	        THEN
    		    IF .USERS_FP EQL .EVENT_ENTRY [EVENT$L_USERS_FP]
    	            THEN


    			! Change it to regular step entry.
    			!
    			BEGIN
    			IF .EVENT_ENTRY [EVENT$V_STEP_BPT]
    			THEN
    			    BEGIN
    			    EVENT_ENTRY [EVENT$V_STEP_BPT] = FALSE;
    			    EVENT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_INS;
    			    EVENT_ENTRY [EVENT$B_SUB_KIND] = .EVENT_ENTRY [EVENT$B_SAVED_SUB_KIND];
    			    END;
    			END;
    	        END;
    	    END;
	END;


    ! As long as were not skipping ACCVIO's, for each entry in the page
    ! queue, write protect the page described.  If we ARE skipping then
    ! we have to TBIT.  
    ! *****SSI
    ! If we are in the middle of the system service cycle, we don't want
    ! want to put the protection back, for if we do, we may cause the
    ! system service to fail again.  Note: Some system service
    ! calls system service, the cycle starts from the call in user program
    ! till this call is returned to the user program.  During this time
    ! frame, we don't want to put protection back.
    !
    IF NOT .SKIP_ACCVIOS AND
       NOT .DBG$GB_SET_WATCH_FLAG
    THEN
	BEGIN
	PAGE_ENTRY = .EVENT$PAGE_QUEUE [L_QUEUE_FLINK];
	WHILE .PAGE_ENTRY NEQA EVENT$PAGE_QUEUE DO
	    BEGIN
	    LOCAL
		ADDRESS :	VECTOR [2];	! Address range for protect

	    ADDRESS [0] = .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS];
	    ADDRESS [1] = .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS];
	    IF NOT $SETPRT (INADR	= ADDRESS,
			    PROT	= PRT$C_UR,
			    PRVPRT	= PAGE_ENTRY [EVENT$B_PAGE_PROTECTION]
			   )
	    THEN
		SIGNAL (DBG$_NOWPROT)
	    ELSE
		PAGE_ENTRY = .PAGE_ENTRY [EVENT$L_PAGE_FLINK];
	    END;
	END;


    ! If we are skipping ACCVIO and WATCHES, T-bit over the cause.
    ! (just had a accvio from the instruction write to the page that was 
    !  protected for watch pointing) or (just had a RET from Systerm Service).
    !
    IF .SKIP_ACCVIOS OR .SKIP_WATCHES
    THEN
        BEGIN

	! About to TBIT over the instruction that triggered a watchpoint.
	! We also have to make sure that we don't get interrupted by ASTs.
    	!
	DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
	DBG$GV_CONTROL[DBG$V_CONTROL_TBIT] = TRUE;
    	END;

    END;

GLOBAL ROUTINE DBG$ACTIVATE_EVENT (EVENT): NOVALUE =
!
! FUNCTION
!	This routine activates an event.  Included in this action is the
!	building of a linked list for each exception type used to implement
!	any event:  BPT, TBIT, and ACCVIO.
!
! INPUTS
!	EVENT :		Pointer to an event entry.
!
! OUTPUTS
!	The event is activated, including the setting of breakpoints, the
!	setting of protections, etc.  The exception lists are also built.
!

    BEGIN
    MAP EVENT :		REF EVENT$EVENT_DESCRIPTOR; ! Event entry pointer
    BUILTIN PROBER;

    LOCAL
    	ADDRESS,
    	AT_LIBSIGNAL,				    ! Flag
    	CALL_FRAME: REF VECTOR[,LONG],		    ! Save part of the FP
	IGNOR_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	EVENT_ADDRESS :	REF VECTOR [, BYTE],	    ! Event byte address
	USERS_FP :	REF BLOCK [, BYTE],	    ! User's current FP
    	RET_PC,					    ! Return PC
	STATUS,					    ! Status value
    	USERS_PC: REF VECTOR[,BYTE];	    	    ! Users current PC

    ! Case on the kind of event entry, to determine whether how to activate
    ! the entry.
    !
    CASE .EVENT [EVENT$B_CMD_KIND]
    FROM EVENT$K_KIND_ACC TO EVENT$K_KIND_EXC OF
	SET
	[EVENT$K_KIND_ACC]:
	

	    ! Case on the access sub-kind....
	    !
	    CASE .EVENT[EVENT$B_SUB_KIND]
	    FROM EVENT$K_ACC_READ TO EVENT$K_ACC_RTRN OF
		SET


		[EVENT$K_ACC_READ]:
		    ;


		[EVENT$K_ACC_WRIT]:
		    ;


		[EVENT$K_ACC_MDFY]:
		    ;


		! Execution Access means that we've got to put a BPT 
		! instruction at the address indicated.
		!
		[EVENT$K_ACC_EXEC]:
		    BEGIN


		    ! Get the event's address.
		    !
		    EVENT_ADDRESS = .EVENT [EVENT$L_ADDRESS];


		    ! Next, copy the opcode at the event's address into the
		    ! event entry for safe keeping.
		    !
		    EVENT [EVENT$B_OPCODE] = .EVENT_ADDRESS [0];


		    ! If the address we're to place a BPT is the current user
		    ! address, (meaning we're about to put a BPT where we're
		    ! about to start), create a ignore-event instead....
		    !
		    IF .EVENT_ADDRESS EQLA .DBG$RUNFRAME[DBG$L_USER_PC]
		    THEN
			BEGIN

			
			! Get a new event descriptor, and link it into the
			! command queue.  Note that this entry is placed on
			! the HEAD of the queue, and should be encountered
			! first !!!
			!
			IGNOR_ENTRY = DBG$GET_MEMORY (EVENT$K_EVENT_DESCRIPTOR_SIZE);
			INSQUE (.IGNOR_ENTRY, EVENT$CMD_QUEUE);


			! Setup this entry to be a ignore-event.  Note that
			! we don't really need to initialize more than the
			! CMD_TYPE, including linking to the event entry
			! causing this mess, 'cause this entry will just be
			! deleted.  However, maybe in the future....
			!
			IGNOR_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_IGNOR;
			IGNOR_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;
			IGNOR_ENTRY [EVENT$B_SUB_KIND] = EVENT$K_ACC_EXEC;
			IGNOR_ENTRY [EVENT$V_ONCE_ONLY] = TRUE;
			INSQUE1 (.IGNOR_ENTRY, .EVENT);


			! Turn on the TBIT flag so that we'll TBIT over the
			! next instruction, and return.
			!
			DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
			DBG$GV_CONTROL[DBG$V_CONTROL_TBIT] = TRUE;
			RETURN;
			END;


		    ! BPT is okay, write a BPT instruction into that address.
		    ! Note that we won't actually do this if the original
		    ! opcode was a BPT.
		    !
		    IF .EVENT [EVENT$B_OPCODE] NEQU BPT_INSTRUCTION
		    THEN
			IF NOT WRITE_OPCODE (.EVENT_ADDRESS, BPT_INSTRUCTION)
			THEN
			    BEGIN
			    SIGNAL (DBG$_NOWBPT);
			    RETURN;
			    END;
		    END;


		! Return Access means that we've got to put a BPT 
		! instruction at the address indicated.
		!
		[EVENT$K_ACC_RTRN]:
		    BEGIN


		    ! Depending on the command type (STEP or otherwise)...
		    !
		    IF .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS OR
		       .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SKIPS OR
    		       .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SSINT
		    THEN
			BEGIN


			! If the save FP is 0, then we need to initialize
			! with the current one.
			!
    			USERS_FP = .EVENT [EVENT$L_USERS_FP];
			IF .USERS_FP EQLA 0
			THEN
    			    BEGIN
			    USERS_FP = .DBG$RUNFRAME [DBG$L_USER_FP];
			    EVENT [EVENT$L_USERS_FP] = .USERS_FP;
		            CALL_FRAME = DBG$GET_MEMORY(5);
    			    EVENT [EVENT$L_CALL_FRAME] = .CALL_FRAME;
    			    CH$MOVE(20,.EVENT[EVENT$L_USERS_FP],.CALL_FRAME);
    			    END;

			IF NOT PROBER (%REF(0), %REF(20), .USERS_FP)
			THEN 
    			    RETURN;


    			! Check for the special case where we have just
    			! called LIB$SIGNAL or LIB$STOP. The flag
    			! AT_LIBSIGNAL will be set to true if we are
    			! at LIB$SIGNAL or LIB$STOP
    			!
    			USERS_PC = .DBG$RUNFRAME[DBG$L_USER_PC];
    			AT_LIBSIGNAL = FALSE;


    			! Check for current PC being at one of these
    			! locations. Here the locations we are checking
    			! are the addresses of LIB$SIGNAL and LIB$STOP
    			! in the LIBRTL shareable library.
    			!
    			IF (.USERS_PC EQL LIB$SIGNAL+2) OR
    			   (.USERS_PC EQL LIB$STOP+2) 
    			THEN
    			    AT_LIBSIGNAL = TRUE;


    			! Also check for the current PC being at the 
    			! address of LIB$SIGNAL or LIB$STOP if these
    			! were linked into the users program with 
    			! /NOSYSSHR on the link. In this case the
    			! symbols show up in the GST and we remember
    			! their addresses when we initialize the GST.
    			!
    			IF (.USERS_PC EQL .DBG$GL_LIB_SIGNAL_ADDR+2) OR
    			   (.USERS_PC EQL .DBG$GL_LIB_STOP_ADDR+2)
    			THEN
    			    AT_LIBSIGNAL = TRUE;


    			! Also check for instruction at current location
    			! being a JMP to LIB$SIGNAL or LIB$STOP.
    			!
    			IF PROBER(%REF(0),
    			          %REF(6),
    				  .USERS_PC)
    			THEN
    			    BEGIN
    			    IF (.USERS_PC[0] EQL %X'17') AND
    			       (.USERS_PC[1] EQL %X'FF')
    			    THEN
    				BEGIN

    				! Get the jump address by adding the PC
    			        ! value plus the 6 bytes for the 
    				! JMP instruction itself.
    				!
    				CH$MOVE(4, USERS_PC[2], ADDRESS);
    				ADDRESS = .ADDRESS + .USERS_PC + 6;
    				IF PROBER(%REF(0),
    					  %REF(4),
    					  .ADDRESS)
    				THEN
    				    ADDRESS = ..ADDRESS;

    				IF (.ADDRESS EQL LIB$SIGNAL+2) OR
    				   (.ADDRESS EQL LIB$STOP+2)
    				THEN
    				    AT_LIBSIGNAL = TRUE;
    				END;
    			    END;

    			IF .AT_LIBSIGNAL
    			THEN
    			    BEGIN

    			    ! In this case, we do not want want to use
    			    ! the dirty-the-tbit approach because
    			    ! LIB$SIGNAL and LIB$STOP mess with the stack.
    			    ! So we revert to the temporary breakpoint 
    			    ! method.
    			    !
       			    RET_PC = .USERS_FP[SF$L_SAVE_PC];
    			    EVENT [EVENT$V_STEP_BPT] = TRUE;
    			    EVENT [EVENT$B_CMD_KIND] = EVENT$K_KIND_INS;
    			    EVENT [EVENT$B_SUB_KIND] = .EVENT [EVENT$B_SAVED_SUB_KIND];
    			    IF .EVENT [EVENT$B_SUB_KIND] EQL 0
    			    THEN
    				EVENT [EVENT$B_SUB_KIND] = EVENT$K_INS_EVRY;
    			    EVENT [EVENT$L_ADDRESS] = .RET_PC;
    			    EVENT [EVENT$B_OPCODE] = .(.RET_PC)<0,8>;
    			    IF NOT WRITE_OPCODE (.RET_PC, BPT_INSTRUCTION)
    			    THEN
    				SIGNAL(DBG$_NOWBPT);
    			    RETURN;
    			    END;


			! Turn on bit 15 in the user's run-
			! frame to get a reserved-operand
			! fault on the return.
			!
    			MATCH_RIGHT_CALL_FRAME(.EVENT);
    			USERS_FP = .EVENT [EVENT$L_USERS_FP];
			(USERS_FP [SF$W_SAVE_PSW])<15,1,0> = TRUE;
			END


		    ! This is a [BREAK|TRACE]/RETURN to set up.
		    !
		    ELSE
			BEGIN


			! Get the event's address.
			!
			EVENT_ADDRESS = .EVENT [EVENT$L_ADDRESS];


			! Next, copy the opcode at the event's address into the
			! event entry for safe keeping.
			!
			EVENT [EVENT$B_OPCODE] = .EVENT_ADDRESS [0];


			! If the address we're to place a BPT is the current
			! user address, (meaning we're about to put a BPT
			! where we're about to start), create a ignore-event
			! instead....
			!
			IF .EVENT_ADDRESS EQLA .DBG$RUNFRAME[DBG$L_USER_PC]
			THEN
			    BEGIN

    							    
			    ! Get a new event descriptor, and link it into the
			    ! command queue.  Note that this entry is placed on
			    ! the HEAD of the queue, and should be encountered
			    ! first !!!
			    !
			    IGNOR_ENTRY = DBG$GET_MEMORY
					    (EVENT$K_EVENT_DESCRIPTOR_SIZE);
			    INSQUE (.IGNOR_ENTRY, EVENT$CMD_QUEUE);


			    ! Setup this entry to be a ignore-event.  Note that
			    ! we don't really need to initialize more than the
			    ! CMD_TYPE, including linking to the event entry
			    ! causing this mess, 'cause this entry will just be
			    ! deleted.  However, maybe in the future....
			    ! If we are at /RET .PC, then we setup a skip entry
    			    ! instead of ignore entry.
    			    !
    			    IF .EVENT [EVENT$V_RET_AT_PC]
    			    THEN
			        IGNOR_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_SKIPS
    			    ELSE
			        IGNOR_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_IGNOR;

			    IGNOR_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;
			    IGNOR_ENTRY [EVENT$B_SUB_KIND] = EVENT$K_ACC_RTRN;
			    IGNOR_ENTRY [EVENT$V_ONCE_ONLY] = TRUE;
			    INSQUE1 (.IGNOR_ENTRY, .EVENT);


			    ! Turn on the TBIT flag so that we'll TBIT over the
			    ! next instruction, and return.
			    !
    			    IF NOT .EVENT [EVENT$V_RET_AT_PC]
    			    THEN
    				BEGIN
			        DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
			        DBG$GV_CONTROL[DBG$V_CONTROL_TBIT] = TRUE;
    				END;
			    RETURN;
			    END;


			! Write a BPT instruction into that address.  Note that
			! we won't actually do this if the original opcode was
			! a BPT.
			!
			IF .EVENT [EVENT$B_OPCODE] NEQU BPT_INSTRUCTION
			THEN
			    IF NOT WRITE_OPCODE (.EVENT_ADDRESS, BPT_INSTRUCTION)
			    THEN
				BEGIN
				SIGNAL (DBG$_NOWBPT);
				RETURN;
				END;
			END;
		    END;
		TES;


	[EVENT$K_KIND_INS]:
	    BEGIN
	    LOCAL OPCODE;

	    OPCODE = .(.DBG$RUNFRAME[DBG$L_USER_PC])<0,8,0>;
	    ! If stepping over and a) it's time to BPT or b) we WERE BPTing...
	    !
	    IF .EVENT [EVENT$V_STEP_OVER] AND
	    (.EVENT [EVENT$V_STEP_BPT] OR .DBG$OPCODES_STEP_OVER[.OPCODE])
	    THEN
		BEGIN

		! ... and we're not already in the middle...
		!
		IF NOT .EVENT [EVENT$V_STEP_BPT]
		THEN
		    BEGIN
		    IF (.OPCODE EQL %X'FA') OR (.OPCODE EQL %X'FB')
		    THEN
			BEGIN

			! This is a CALLS or CALLG instruction. We implement
			! STEP/OVER by a STEP/INTO,STEP/RETURN,STEP sequence
    			! We do this by temporarily turning the STEP event descriptor into a RETURN
    			! event descriptor (KIND = ACC, SUB_KIND = RTRN). This causes us to dirty up
    			! the call stack and get a reserved operand fault at the return. When we handle the
    			! ROPRAND then we change the return event back into a step event. We save the original
    			! sub-kind field to enable us to do this correctly.
    			!
			EVENT [EVENT$V_STEP_BPT] = TRUE;
			EVENT [EVENT$L_USERS_FP] = 0;
			EVENT [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;
    			EVENT [EVENT$B_SAVED_SUB_KIND] = .EVENT [EVENT$B_SUB_KIND];
			EVENT [EVENT$B_SUB_KIND] = EVENT$K_ACC_RTRN;
			DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
			DBG$GV_CONTROL[DBG$V_CONTROL_TBIT] = TRUE;
			RETURN;
			END
		    ELSE
			BEGIN

			! This is a JSB-type instruction.  Get the address
		        ! of the next instruction.
		        !
		        EVENT_ADDRESS = DBG$INS_DECODE (
    			    .DBG$RUNFRAME[DBG$L_USER_PC], 0, FALSE);


		        ! If the address is in system or P1 space...
		        !
		        IF .EVENT_ADDRESS GEQA P1_SPACE OR
		           .EVENT_ADDRESS EQLA 0
		        THEN


			    ! ... then we're going to TBIT ('cause we won't set a
			    ! BPT in P1 space or in system space).
			    !
			    BEGIN


			    ! Check to see if this is address 0 or we're stepping
			    ! nosystem.  If so - belch.
			    !
			    IF .EVENT [EVENT$V_STEP_NOSYSTEM] OR
			       .EVENT_ADDRESS EQLA 0
			    THEN
			        SIGNAL (DBG$_STEPINTO, 1, .DBG$RUNFRAME[DBG$L_USER_PC]);


			    ! We're TBIT'n now...
			    !
			    DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
			    RETURN;
			    END;


		        ! Otherwise, everything is hunky dory, so continue.  We'll
		        ! Set up the address in the event entry for the BPT.
		        !
		        ! Save the next address in to entry for the step's BPT.
		        !
		        EVENT [EVENT$L_ADDRESS] = .EVENT_ADDRESS;


		        ! Flag that a stepping-into BPT is set.
		        !
		        EVENT [EVENT$V_STEP_BPT] = TRUE;
		        END;
		    END


		! We're in the middle of stepping over, but we've been
		! interrupted, so continue....
		!
		ELSE
		    EVENT_ADDRESS = .EVENT [EVENT$L_ADDRESS];



		! We get here when a) we're in the middle of a step/over (i.e,
		! something interrupted the step/over), or we're at the start
		! of one (i.e. at a CALL/JSB-type instruction), and we've got
		! the address set up in the event entry (see above).
		!
		! Next, copy the opcode at the event's address into the
		! event entry for safe keeping.
		!
		EVENT [EVENT$B_OPCODE] = .EVENT_ADDRESS [0];


		! Finally, write a BPT instruction into that address.
		! Note that we won't actually do this if the original
		! opcode was a BPT.
		!
		IF .EVENT [EVENT$B_OPCODE] NEQU BPT_INSTRUCTION
		THEN
		    IF NOT WRITE_OPCODE (.EVENT_ADDRESS, BPT_INSTRUCTION)
		    THEN
			BEGIN
			SIGNAL (DBG$_STEPINTO, 1, .DBG$RUNFRAME[DBG$L_USER_PC]);
			DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
    			EVENT [EVENT$V_STEP_BPT] = FALSE;
			RETURN;
			END;
		END
	    ELSE

		! We're not stepping over, or we aren't going to BPT, so we'll
		! TBIT.
		!
		BEGIN
		EVENT [EVENT$V_STEP_BPT] = FALSE;
		DBG$RUNFRAME [DBG$V_TBIT] = TRUE;
		END;
	    END;


	[EVENT$K_KIND_EXC]:
	    ;
	TES;
    END;

GLOBAL ROUTINE DBG$DEACTIVATE_EVENTS: NOVALUE =
!
! FUNCTION
!	This routine deactivates all set events.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	The events are deactivated, including the resetting of breakpoints, the
!	resetting of protections, etc.
!

    BEGIN

    LOCAL
	EVENT_ENTRY :	REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	PAGE_ENTRY  :	REF EVENT$PAGE_DESCRIPTOR;  ! Page entry pointer


    ! As long as were not skipping ACCVIO's, for each entry in the page
    ! queue, un-write protect the page described.
    !
    IF NOT .SKIP_ACCVIOS
    THEN
	BEGIN
	PAGE_ENTRY = .EVENT$PAGE_QUEUE [L_QUEUE_FLINK];
	WHILE .PAGE_ENTRY NEQA EVENT$PAGE_QUEUE DO
	    BEGIN
	    LOCAL
		ADDRESS :	VECTOR [2];	! Address range for protect

	    ADDRESS [0] = .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS];
	    ADDRESS [1] = .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS];
	    IF NOT $SETPRT (INADR	= ADDRESS,
			    PROT	= .PAGE_ENTRY [EVENT$B_PAGE_PROTECTION]
			   )
	    THEN
		SIGNAL (DBG$_NOWPROT)
	    ELSE
		PAGE_ENTRY = .PAGE_ENTRY [EVENT$L_PAGE_FLINK];
	    END;
	END;


    ! Deactivate the all events not 'deleted'.
    !
    EVENT_ENTRY = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
    WHILE .EVENT_ENTRY NEQA EVENT$CMD_QUEUE [A_QUEUE_ENTRY] DO
	BEGIN
	IF NOT .EVENT_ENTRY [EVENT$V_DELETED]
	THEN
	    DBG$DEACTIVATE_EVENT (.EVENT_ENTRY);
	EVENT_ENTRY = .EVENT_ENTRY [EVENT$L_CMD_FLINK];
	END;
    END;

GLOBAL ROUTINE DBG$DEACTIVATE_EVENT(EVENT_ENTRY): NOVALUE =
!
! FUNCTION
!	This routine deactivates an event.
!
! INPUTS
!	EVENT_ENTRY :		Pointer to an event entry.
!
! OUTPUTS
!	The event is deactivated, including the resetting of breakpoints, the
!	resetting of protections, etc.
!

    BEGIN

    MAP
	EVENT_ENTRY :	REF EVENT$EVENT_DESCRIPTOR; ! Event entry pointer

    LOCAL
	EVENT_ADDRESS :	REF VECTOR [, BYTE],	    ! Event byte address
	USERS_FP :	REF BLOCK [, BYTE],	    ! User's current FP
	STATUS;					    ! Status value


    ! If this is an IGNOR entry, ignore it !
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_IGNOR
    THEN
	RETURN;


    ! Case on the kind of event entry, to determine whether how to activate
    ! the entry.
    !
    CASE .EVENT_ENTRY [EVENT$B_CMD_KIND]
    FROM EVENT$K_KIND_ACC TO EVENT$K_KIND_EXC OF
	SET
	[EVENT$K_KIND_ACC]:
	

	    ! Case on the access sub-kind....
	    !
	    CASE .EVENT_ENTRY [EVENT$B_SUB_KIND]
	    FROM EVENT$K_ACC_READ TO EVENT$K_ACC_RTRN OF
		SET


		[EVENT$K_ACC_READ]:
		    ;


		[EVENT$K_ACC_WRIT]:
		    ;


		[EVENT$K_ACC_MDFY]:
		    ;


		! Execution Access means that we've got to replace a BPT
		! instruction at the address indicated.
		!
		[EVENT$K_ACC_EXEC]:
		    BEGIN


		    ! Get the event's address.
		    !
		    EVENT_ADDRESS = .EVENT_ENTRY [EVENT$L_ADDRESS];


		    ! Finally, overwrite the BPT instruction with the original
		    ! opcode into that address.  Note that we will NOT do this
		    ! if the orignal is a BPT.
		    !
		    IF .EVENT_ENTRY [EVENT$B_OPCODE] NEQU BPT_INSTRUCTION
		    THEN
			IF NOT WRITE_OPCODE (.EVENT_ADDRESS,
					     .EVENT_ENTRY [EVENT$B_OPCODE]
					    )
			THEN
			    BEGIN
			    SIGNAL (DBG$_NOWOPCO);
			    RETURN;
			    END;
		    END;


		! Return Access means that we've got to replace a BPT
		! instruction at the address indicated - or, if this
		! is was a STEP command, turn of the dirty bit in the
		! user's PSW.
		!
		[EVENT$K_ACC_RTRN]:
		    BEGIN
    		    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
    			EVENT$K_TYPE_SSINT
    		    THEN
    			BEGIN
    			LOCAL BIT_15_CNT: REF VECTOR[,BYTE];
    			BIT_15_CNT = .EVENT_ENTRY [EVENT$L_FP_RET_CNT];
    			IF .BIT_15_CNT[0] GEQ 1 THEN DBG$GB_SET_WATCH_FLAG = TRUE;
    			END;


		    ! Depending on whether this was a STEP command or not...
		    !
		    IF (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
		        EVENT$K_TYPE_STEPS
		       ) OR
		       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
		        EVENT$K_TYPE_SKIPS
		       ) OR
    		       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU
    			EVENT$K_TYPE_SSINT
    		       )
		    THEN
			BEGIN


			! Turn off bit 15 in the user's
			! runframe so we don't get another
			! ROPRAND fault on the return.
			!
			USERS_FP = .EVENT_ENTRY [EVENT$L_USERS_FP];
			IF .USERS_FP NEQ 0 
    			THEN
    			    BEGIN
    			    MATCH_RIGHT_CALL_FRAME(.EVENT_ENTRY);
    			    USERS_FP = .EVENT_ENTRY [EVENT$L_USERS_FP];
			    (USERS_FP [SF$W_SAVE_PSW])<15,1,0> = FALSE;
    			    END;
			END
		    ELSE
			BEGIN


			! Get the event's address.
			!
			EVENT_ADDRESS = .EVENT_ENTRY [EVENT$L_ADDRESS];


			! Finally, overwrite the BPT instruction with the
			! original opcode into that address.  Note that we
			! will NOT do this if the orignal is a BPT.
			!
			IF .EVENT_ENTRY [EVENT$B_OPCODE] NEQU BPT_INSTRUCTION
			THEN
			    IF NOT WRITE_OPCODE (.EVENT_ADDRESS,
						 .EVENT_ENTRY [EVENT$B_OPCODE]
						)
			    THEN
				BEGIN
				SIGNAL (DBG$_NOWOPCO);
				RETURN;
				END;
			END;
		    END;
		TES;


	[EVENT$K_KIND_INS]:
	    BEGIN


	    ! If this step was stepping over (had a BPT set), remove the
	    ! BPT instruction.
	    !
	    IF .EVENT_ENTRY [EVENT$V_STEP_OVER] AND
	       .EVENT_ENTRY [EVENT$V_STEP_BPT]
	    THEN
		BEGIN


		! Get the event's address.
		!
		EVENT_ADDRESS = .EVENT_ENTRY [EVENT$L_ADDRESS];


		! Finally, overwrite the BPT instruction with the original
		! opcode into that address.  Note that we will NOT do this
		! if the orignal is a BPT.
		!
		IF .EVENT_ENTRY [EVENT$B_OPCODE] NEQU BPT_INSTRUCTION
		THEN
		    IF NOT WRITE_OPCODE (.EVENT_ADDRESS,
					 .EVENT_ENTRY [EVENT$B_OPCODE]
					)
		    THEN
			BEGIN
			SIGNAL (DBG$_NOWOPCO);
			RETURN;
			END;
		END;
	    END;


	[EVENT$K_KIND_EXC]:
	    ;
	TES;
    END;

GLOBAL ROUTINE DBG$EXCEPTION_HANDLER(SIGNAL_ARG_PTR, MECHAN_ARG_PTR) =
!
! FUNCTIONAL DESCRIPTION:
!
!	Exception analyzer called by the primary vector exception handler,
!	which is a MARS routine found in DBGSTART.MAR.  The MARS routine
!	immediately resignals if the user program was not running.  Otherwise
!	it saves the registers of the user program and disables ASTs for the
!	time that DEBUG is running.
!
!	Then it calls this routine, where the exception is analyzed for the
!	type of exception.  Breakpoint, trace, and ACCVIO traps are given
!	special handling, which usually ends with control being passed to the
!	user.  If the breakpoint, trace, or ACCVIO trap was illegal, then the
!	exception is resignaled unless the user has asked for control on every
!	exception.
!
!	Some trace traps cause an interim halt that requires some action, but
!	doesn't pass control back to the user.  After checking the validity of
!	these trace traps, the value SS$_CONTINUE is returned.
!
!	After the exception is analyzed and it is determined that immediate
!	resignaling or continuing is not desired, the user_proc routine is
!	called.  This routine accepts user commands either from prespecified
!	action commands from breakpoints, or interactively from the terminal.
!	Eventually, a command is given that either causes the user program to
!	continue or DEBUG to exit. If the user program is to continue, the
!	value returned from user_proc is SS$_CONTINUE, and that value is
!	passed back to the MARS handler.
!
! 	If an exception occurs during DEBUG processing, the exception handler
!	is FINAL_HANDL, not this routine.
!
!
! FORMAL PARAMETERS:
!
!	SIGNAL_ARG_PTR	- address of block that contains at least four
!			longwords.  The pertinent words are the exception
!			name, the PC at the time of the exception, and the PSL
!			at the time of the exception.  The name is always the
!			second longword, the PC and the PSL the next to last
!			and last respectively.
!
!	MECHAN_ARG_PTR	- address of block that contains five longwords.  The
!			pertinent words are the saved R0 and R1.  They are in
!			the fourth and fifth longwords respectively.  Neither
!			is used at this time.
!
!
! IMPLICIT INPUTS:
!
!	Some variable number of additional arguments may exist between the
!	exception name and the PC.  Flags indicating the validity of TBITs and
!	breakpoints are referenced.  The flag DBG$GB_RESIGNAL causes illegal
!	exceptions to be resignaled if the flag is set to true.
!
!
! IMPLICIT OUTPUTS:
!
!	The TBIT in the RUNFRAME PSL may be changed.
!
!
! ROUTINE VALUE:
!
!	SS$_RESIGNAL or SS$_CONTINUE for resignaling and continuing
!	respectively.
!
!
! SIDE EFFECTS:
!
!	Any number of things.
!
    BEGIN
    MAP 
    	MECHAN_ARG_PTR : REF BLOCK[,BYTE],
    	SIGNAL_ARG_PTR : REF BLOCK[,BYTE];
    BUILTIN PROBER;
    LABEL scan;
    LOCAL
	EVENT :		REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	LAST1 :		REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	SKIPS_ENTRY :   REF EVENT$EVENT_DESCRIPTOR, ! Skip entry pointer
	ACTIVE_EVENT,				    ! Event match flag
	EXCEPTION_TYPE,
	USERS_PC :	REF BLOCK [, BYTE],
	USERS_FP :	REF BLOCK [, BYTE],
	OPCODE,
    	ORIG_TBIT,				    ! Original TBIT value
	STATUS;


    ! Save the original value of the TBIT.
    !
    ORIG_TBIT = .DBG$RUNFRAME[DBG$V_TBIT];


    ! Save the exception type (name);
    !
    EXCEPTION_TYPE = .SIGNAL_ARG_PTR [CHF$L_SIG_NAME];


    ! Save the User's PC.
    !
    USERS_PC = .DBG$RUNFRAME [DBG$L_USER_PC];
    IF NOT PROBER(%REF(0),%REF(1),.USERS_PC) THEN OPCODE = 0
    ELSE IF (((OPCODE = .(.USERS_PC)<0,8,0>) GEQU %X'FD')
	      AND PROBER(%REF(0),%REF(2),.USERS_PC))
    THEN OPCODE = %X'100' + .(.USERS_PC)<8,8,0>;


    ! If we got here via a TBIT, see if we're at one of the special DEBUG
    ! locations.  If so, just return SS$_CONTINUE.
    !
    IF .EXCEPTION_TYPE EQLU SS$_TBIT
    THEN
	BEGIN
	IF .USERS_PC EQLA DBG$PSEUDO_EXIT OR
	   .USERS_PC EQLA DBG$TERM_HANDLR OR
	   .USERS_PC EQLA DBG$USER_EXIT   OR
	   .USERS_PC EQLA PRIM_HANDL_2    OR
    	   .USERS_PC EQLA DBG$PSEUDO_SSI
	THEN
	    BEGIN
	    DBG$RUNFRAME [DBG$V_TBIT] = FALSE;
	    DBG$GL_OUTPRAB [RAB$V_CCO] = TRUE;
	    RETURN SS$_CONTINUE;
	    END;

	END;


    ! If we got here via an Opcode Request....
    !
    IF .EXCEPTION_TYPE EQLU SS$_DBGOPCREQ
    THEN
	BEGIN


	! This signal is generated by the library routine LIB$GET_OPCODE.
	! It is used to inquire what the real instruction was before the
	! debugger replaced the instruction with a BPT.
	!
	! (The emulator needs this capability).
	!
	! Note that the opcode involved was restored when we deactivated
	! the events.  This will have to be redone when we stop
	! automatically deactivating....
	!
	DBG$DEACTIVATE_EVENTS();
	(.SIGNAL_ARG_PTR [12,0,32,0]) <0, 8, 0> = .(.SIGNAL_ARG_PTR [8,0,32,0]) <0, 8, 0>;
	DBG$ACTIVATE_EVENTS();
	RETURN SS$_CONTINUE;
	END;


    ! *****SSI
    ! If we got here via System service interception...
    ! Build a SSI enty on the Event List, if this system service calls from
    ! user program, and nobody else has turned on bit 15 in saved PSW in
    ! System Service FP.  (This means that TDBG has seen this already, bit
    ! 15 is set, now is SDBG's turn to examine this singal).  Record the PC
    ! to report Watch At, unprotected the pages... 
    !
    IF .EXCEPTION_TYPE EQLU DBG$_SS_INT
    THEN
        BEGIN
    	LOCAL
	    ADDRESS : VECTOR [2],		! Address range for protect
            BIT_15_CNT: REF VECTOR[,BYTE],	! Has bit 15 turned on?
	    BIT_15_CNT_SSV: REF VECTOR[,BYTE],	! Are we called from System
    						!   Service's system service
    						!   call?
	    PAGE_ENTRY: REF EVENT$PAGE_DESCRIPTOR,! Page entry pointer
	    SIGARG: REF VECTOR[,LONG],		! Info. comes in with DBG$_SS_INT
	    SSINT_ENTRY: REF EVENT$EVENT_DESCRIPTOR,! SSI event entry
	    USERS_FP: REF BLOCK[,BYTE];		! System service call frame


    	! Get arg. list.
    	!
	SIGARG = SIGNAL_ARG_PTR[CHF$L_SIG_ARG1];

    	! Caused from System service's system call, simply ignore it.
    	! note: this variable is a communication variable, it is seen
    	! by DBG, TDBG and SDBG.
    	!    	
	BIT_15_CNT_SSV = .SIGARG[5];
    	IF .BIT_15_CNT_SSV[0] GTR 1 THEN RETURN SS$_CONTINUE;

    	! This type of entry is already built for somebody else (caused from
    	! the same source, went through different level).  Ignore it.
    	! note: this varialbe is a communication variable, it is seen
    	! by DBG, TDBG and SDBG.
    	!
	BIT_15_CNT = .SIGARG[4];
   	IF .BIT_15_CNT[0] GEQ 1 THEN RETURN SS$_CONTINUE;

    	! We'll take it.  Mark the cycle begins.  Build event entry, place
    	! it at the head of the event list.
    	!
	DBG$GB_SET_WATCH_FLAG = TRUE;
	USERS_FP = .SIGARG[3];
	EVENT = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
	SSINT_ENTRY = DBG$GET_MEMORY(EVENT$K_EVENT_DESCRIPTOR_SIZE);
	INSQUE (.SSINT_ENTRY, .EVENT[EVENT$L_CMD_BLINK]);
	SSINT_ENTRY [EVENT$B_CMD_TYPE] = EVENT$K_TYPE_SSINT;
	SSINT_ENTRY [EVENT$B_CMD_KIND] = EVENT$K_KIND_ACC;
	SSINT_ENTRY [EVENT$B_SUB_KIND] = EVENT$K_ACC_RTRN;
	SSINT_ENTRY [EVENT$V_ONCE_ONLY] = TRUE;
    	SSINT_ENTRY [EVENT$L_EXC_FLINK] = .SSINT_ENTRY;
    	SSINT_ENTRY [EVENT$L_EXC_BLINK] = .SSINT_ENTRY;
	SSINT_ENTRY [EVENT$L_USERS_FP] = .USERS_FP;
	(USERS_FP [SF$W_SAVE_PSW]) <15,1,0> = TRUE;
	SSINT_ENTRY [EVENT$L_SSV_COUNT] = .BIT_15_CNT_SSV;
	SSINT_ENTRY [EVENT$L_FP_RET_CNT] = .BIT_15_CNT;
	SSINT_ENTRY [EVENT$L_USERS_PC] = .USERS_FP[SF$L_SAVE_PC];
    	WATCH_PC = .USERS_FP[SF$L_SAVE_PC];
	BIT_15_CNT[0] = .BIT_15_CNT[0] + 1;
	IF .BIT_15_CNT[0] EQL 1
	THEN
	    BEGIN
	    PAGE_ENTRY = .EVENT$PAGE_QUEUE [L_QUEUE_FLINK];
	    WHILE .PAGE_ENTRY NEQA EVENT$PAGE_QUEUE DO
	        BEGIN
	        ADDRESS [0] = .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS];
	        ADDRESS [1] = .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS];
	        IF NOT $SETPRT (INADR	= ADDRESS,
				PROT	= .PAGE_ENTRY [EVENT$B_PAGE_PROTECTION]
			       )
	        THEN
		    SIGNAL (DBG$_NOWPROT)
	        ELSE
		    PAGE_ENTRY = .PAGE_ENTRY [EVENT$L_PAGE_FLINK];
	        END;
	    END;

    	RETURN SS$_CONTINUE;
	END;


    ! If this is an exception break or trace, we'll flag it later.
    !
    DBG$GB_EXC_BRE_FLAG = FALSE;


    ! Clear the event-match flag, to indicate that we have as yet found no
    ! matching event entry for this exception.
    !
    ACTIVE_EVENT = FALSE;


    ! Set the type-source flag, so that we will display the source line at
    ! the first opportunity.
    !
    TYPE_SOURCE = TRUE;


    ! Clear the STOP_USER flag, set when a break is valid, or step is over.
    ! This flag is usually set in PROCESS_EVENT when a break breaks, or a
    ! step stops....
    !
    EVENT$B_STOP_USER = FALSE;


    ! Set the flag allowing user commands, i.e. no GO, STEP, EXIT, or
    ! CONTINUE commands have been executed yet.  We have to do it here
    ! in case there are no DO's evaluated, since we test it later....
    !
    DBG$GB_TAKE_CMD = TRUE;


    ! Deactivate all events.  This will most probably be changed to take
    ! advantage of not HAVING to turn them all off, but later, LATER !
    !
    DBG$DEACTIVATE_EVENTS ();
    IF .EXCEPTION_TYPE EQLU SS$_DEBUG
    THEN
	BEGIN


	! This is the phony way into the user control. This exception name
	! is passed by the DEBUG startup routine, and by the final handler
	! when an exception generated in a user program has not been dealt
	! with by any user handlers (and so has been reported by the DEBUG
	! final handler),  when the user is passed control in order to fix
	! up the condition that caused the problem.
	!
	! We'll act as though a BREAKpoint was encountered.
	!
	EVENT$B_STOP_USER = TRUE;
	ACTIVE_EVENT = TRUE;
	END;


    ! If the user program has completed, cancel any pending STEP events.
    !
    IF .DBG$RUNFRAME[DBG$L_USER_PC] EQL 0
    THEN
	BEGIN
	EVENT = EVENT$CMD_QUEUE[A_QUEUE_ENTRY];
	WHILE TRUE DO
	    BEGIN
	    EVENT = .EVENT[EVENT$L_CMD_FLINK];
	    IF .EVENT EQLA EVENT$CMD_QUEUE[A_QUEUE_ENTRY] THEN EXITLOOP;
	    IF (.EVENT[EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_STEPS)
	    THEN
		EVENT[EVENT$V_DELETED] = TRUE;

	    END;

	END

    ELSE
	BEGIN


	! Based on exception name, handle the exception....
	!
	SELECTONE .EXCEPTION_TYPE OF
	    SET

	    [SS$_ROPRAND,SS$_DEBUG,SS$_BREAK,SS$_TBIT]:
	      IF (.EXCEPTION_TYPE NEQ SS$_DEBUG) OR
		 .DBG$GV_CONTROL[DBG$V_CONTROL_STOP]
	      THEN
		BEGIN


		! A BPT or TBIT gets us here.  These are two of the
		! exceptions DEBUG uses to make events happen, and so
		! are treated specially here.
		!
		! Point to the current last entry on the queue.  We'll only
		! examine entries until :
		! a) we're at the actual end of the queue, or
		! b) we've looked at the last entry we knew about when we started.
		! This is because processing a DO might add entries that we
		! then want to ignore....
		!
		LAST1 = .EVENT$CMD_QUEUE [L_QUEUE_BLINK];


		! For each event entry in the queue, check to see if it is
		! active....
		!
		EVENT = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
		WHILE .EVENT NEQA EVENT$CMD_QUEUE [A_QUEUE_ENTRY] DO
		    BEGIN


		    ! Make sure that the entry isn't deleted but not removed....
		    !
		    IF NOT .EVENT [EVENT$V_DELETED]
		    THEN
			BEGIN


			! If this entry is to be IGNORed....
			!
			IF .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_IGNOR
			THEN


			    ! IGNORed entries are always deleted.  If this wasn't
			    ! a TBIT exception, the entry will be re-entered when
			    ! the associated parent-event is re-activated ('cause
			    ! all IGNORed entries are used to TBIT over some
			    ! instruction).
			    !
			    BEGIN
			    EVENT [EVENT$V_DELETED] = TRUE;


			    ! Ignored entries are active if this is a TBIT.
			    !
			    IF .EXCEPTION_TYPE EQLU SS$_TBIT
			    THEN
				ACTIVE_EVENT = TRUE;
			    END

			ELSE


			    ! This is a 'real' event, not an IGNORed one.
			    !
			    BEGIN


			    ! Case on the kind of event entry, to determine whether
			    ! the exception is applicable, and if the entry is
			    ! active.
			    !
			    CASE .EVENT [EVENT$B_CMD_KIND]
			    FROM EVENT$K_KIND_ACC TO EVENT$K_KIND_EXC OF
				SET
				[EVENT$K_KIND_ACC]:
			    

				    ! Case on the access sub-kind....
				    !
				    CASE .EVENT [EVENT$B_SUB_KIND]
				    FROM EVENT$K_ACC_READ TO EVENT$K_ACC_RTRN OF
					SET


					[EVENT$K_ACC_READ]:
					    ;


					[EVENT$K_ACC_WRIT]:
					    ;


					[EVENT$K_ACC_MDFY]:


					    ! If we're skipping ACCVIOS (meaning
					    ! we had one, and it's page address
					    ! was one we're watching for....
    					    ! *****SSI
					    ! If we're returned from system
    					    ! service, or during system service
    					    ! cycle...
    					    !
					    IF .SKIP_ACCVIOS OR
    					       .SKIP_WATCHES OR
    					       .DBG$GB_SET_WATCH_FLAG
					    THEN
						BEGIN
						LOCAL
						    LENGTH;


						! We've got an active event.
						!
				    		ACTIVE_EVENT = TRUE;


						! Get the byte length of the
						! entry's value.  Note that we
						! actually get its bit length and
						! round up.  This should be okay
						! 'cause the values saved in a
						! value descriptor are padded out
						! to fill bytes.
						!
						LENGTH =
						    DBG$DATA_LENGTH
							(EVENT [EVENT$A_VMSDESC]);
						LENGTH = (.LENGTH + 7) ^ -3;
    						GET_WATCH_POINT_VALUE(.EVENT);
						OLDVALUE =
						    .EVENT [EVENT$L_VALDESC];


						! Now, compare the two values, and
						! process the event is they're the
						! same.
						!
						IF CH$EQL
						     (.LENGTH,
						      OLDVALUE [DBG$A_VALUE_ADDRESS],
						      .LENGTH,
						      NEWVALUE [DBG$A_VALUE_ADDRESS],
						      0
						     )
						THEN
    						    DBG$NFREE_DESC(.NEWVALUE)
    						ELSE
						    BEGIN


						    ! Process the entry.
						    !
    						    IF .SKIP_WATCHES OR
    						       .DBG$GB_SET_WATCH_FLAG
    						    THEN
    							ACCVIO_PC = .WATCH_PC;
						    STATUS = DBG$PROCESS_EVENT
								(.EVENT,
								 .SIGNAL_ARG_PTR
								);

    						    ! Update the value descriptor in the event entry to reflect the
    						    ! new value.
    						    ! Then, since we are finished with the value descriptor in NEWVALUE,
    						    ! free up the memory.
    						    ! 
						    CH$MOVE
							(.LENGTH,
							 NEWVALUE [DBG$A_VALUE_ADDRESS],
							 OLDVALUE [DBG$A_VALUE_ADDRESS]
							);
    						    DBG$NFREE_DESC(.NEWVALUE);

						    ! If we have been pre-
						    ! empted by a GO, STEP,
						    ! CONTINUE, or EXIT, we will
						    ! stop processing.
    						    !
						    IF .STATUS
						    THEN
							EXITLOOP;
						    END;
						END;


					! Process an /EXECUTION (BREAK/TRACE)
					! entry.
					!
					[EVENT$K_ACC_EXEC]:
					    BEGIN


					    ! Match the address of the eventpoint
					    ! with the current PC for an active
					    ! event...
					    !
					    IF .EVENT [EVENT$L_ADDRESS] EQLA .USERS_PC
					    THEN
						BEGIN


						! The event is active, so process
						! the entry.  If on return we have
						! been pre-empted by a GO, STEP,
						! CONTINUE, or EXIT, we will stop
						! processing.
						!
						ACTIVE_EVENT = TRUE;
						IF DBG$PROCESS_EVENT
							(.EVENT,
							 .SIGNAL_ARG_PTR
							)
						THEN
						    EXITLOOP;

						END;

					    END;


					! Process a /RETURN (BREAK/TRACE/STEPS/
					! SKIPS) entry.
					!
					[EVENT$K_ACC_RTRN]:
					    BEGIN


					    ! Based on the event command type....
					    !
					    SELECTONE .EVENT [EVENT$B_CMD_TYPE] OF
						SET


						! [BREAK|TRACE]/RETURN
						!
						[EVENT$K_TYPE_BREAK,
						 EVENT$K_TYPE_TRACE]:
						    BEGIN


						    ! Match the address of the
						    ! eventpoint with the current
						    ! PC for an active event...
    						    ! Also make sure the exception is not ROPRAND 
    						    ! (this is in case the user sets a
    						    ! return break at the RET).
						    !
						    IF (.EVENT [EVENT$L_ADDRESS] EQLA .USERS_PC) AND
    						       (.EXCEPTION_TYPE NEQ SS$_ROPRAND)
						    THEN
							BEGIN


							! The event is active.
							!
							ACTIVE_EVENT = TRUE;


							! Get a new event descriptor
							! and link it into the
							! command queue. Note that
							! this entry is placed in
							! the queue just in front 
							! of its parent, and should
							! be encountered first !!!
							!
							SKIPS_ENTRY =
							    DBG$GET_MEMORY
								(EVENT$K_EVENT_DESCRIPTOR_SIZE);
							INSQUE (.SKIPS_ENTRY,
								.EVENT [EVENT$L_CMD_BLINK]
							       );


							! Setup this entry to be a
							! /RETURN skip-event,
							! linking to the event
							! entry causing this mess.
							!
							SKIPS_ENTRY [EVENT$B_CMD_TYPE] =
							    EVENT$K_TYPE_SKIPS;
							SKIPS_ENTRY [EVENT$B_CMD_KIND] =
							    EVENT$K_KIND_ACC;
							SKIPS_ENTRY [EVENT$B_SUB_KIND] =
							    EVENT$K_ACC_RTRN;
							SKIPS_ENTRY [EVENT$V_ONCE_ONLY] =
							    TRUE;
							INSQUE1 (.SKIPS_ENTRY, .EVENT);


							! Initialize the FP to 0 so it gets
							! setup when activated.
							!
							SKIPS_ENTRY [EVENT$L_USERS_FP] = 0;
							END;
						    END;


						! [BREAK|TRACE/RETURN skips and
						! STEP/RETURN
						!
						[EVENT$K_TYPE_SKIPS,
						 EVENT$K_TYPE_STEPS]:
						    BEGIN
						    SELECTONE .EXCEPTION_TYPE OF
							SET
							[SS$_ROPRAND]:
							    BEGIN
    							    LOCAL
    								RIGHT_FP_FLAG;

    							    IF .OPCODE EQL %X'04'
    							    THEN
    							        RIGHT_FP_FLAG =  MATCH_RIGHT_CALL_FRAME(.EVENT)
    							    ELSE
    								RIGHT_FP_FLAG = FALSE;

    							    IF .RIGHT_FP_FLAG
							    THEN
								BEGIN
								ACTIVE_EVENT = TRUE;

    								! We've come to the RET instruction that we get to
    							        ! in the process of stepping over a routine. We now
    								! want to change our RETURN event back into an 
    								! ordinary STEP event, to resume stepping normally.
    								!
								IF .EVENT [EVENT$V_STEP_BPT]
								THEN
								    BEGIN
								    EVENT [EVENT$V_STEP_BPT] = FALSE;
								    EVENT [EVENT$B_CMD_KIND] = EVENT$K_KIND_INS;
								    EVENT [EVENT$B_SUB_KIND] = .EVENT [EVENT$B_SAVED_SUB_KIND];
								    END

								! Process the entry.  If on return we have been
								! preempted by a GO,  STEP,  CONTINUE,  or EXIT
								! we will stop processing.
								!
								ELSE IF DBG$PROCESS_EVENT
									(.EVENT,
									 .SIGNAL_ARG_PTR)
								THEN
								    EXITLOOP;

								END;

							    END;

							[SS$_TBIT]:
							    IF .EVENT [EVENT$V_STEP_BPT]
							       THEN ACTIVE_EVENT = TRUE;

							[OTHERWISE]:
							    0;
							TES;
						    END;

    						! *****SSI
    						! We are examing the SSI entry was built
    						! at DBG$_SS_INT signal...
    						!
    						[EVENT$K_TYPE_SSINT]:
    						    BEGIN

    						    ! Well?  Caused from Reserved Operand
    						    ! fault?
    						    !
    						    IF (.DBG$RUNFRAME [DBG$L_USER_FP] EQLA
    						        .EVENT [EVENT$L_USERS_FP])
    						    AND (.OPCODE EQLU %X'04')
    						    THEN
    							BEGIN
    							EVENT [EVENT$V_DELETED] = TRUE;
    							ACTIVE_EVENT = TRUE;
    							EVENT$B_STOP_USER = FALSE;
    							DBG$GB_TAKE_CMD = FALSE;
    							EXITLOOP;
    							END;
    						    END;
						TES;
					    END;
					TES;


				[EVENT$K_KIND_INS]:
				    BEGIN


				    ! If this is a TBIT (or DEBUG) or BREAK
				    ! exception when stepping over, process
				    ! a step.
				    !
				    IF (SELECTONE .EXCEPTION_TYPE OF
					    SET
					    [SS$_TBIT, SS$_DEBUG]:
						IF .EVENT [EVENT$V_STEP_BPT]
						THEN
						    IF .EVENT [EVENT$L_ADDRESS] EQLA .USERS_PC
						    THEN
							TRUE
						    ELSE
							FALSE
						ELSE
						    TRUE;
					    [SS$_BREAK]:
						IF .EVENT [EVENT$V_STEP_BPT]
						THEN
						    IF .EVENT [EVENT$L_ADDRESS] EQLA .USERS_PC
						    THEN
							TRUE
						    ELSE
							FALSE
						ELSE
						    FALSE;
					    [OTHERWISE]:
						FALSE;
					    TES
				       )
				    THEN
					BEGIN


					! The event is active, regardless.
					!
					ACTIVE_EVENT = TRUE;


					! If this was a BPT exception, turn off the
					! STEP_BPT flag - we're done stepping over.
					!
					IF .EXCEPTION_TYPE EQLU SS$_BREAK
					THEN
					    EVENT [EVENT$V_STEP_BPT] = FALSE;

					! Depending on the step type (line/instruction) process the step.
    				 	! We also check here that either we are stepping /system, or else we must
    					! not be in system space. That is, if we find that we are stepping nosystem
    					! and that we are indeed in system space, then the IF condition will be
    					! false and we will not process the event. We actually use ADDRESS GEQ P1_SPACE
    					! as our determination of what is system space, since most system services 
    					! are actually entered through P1 space now.
					!
					IF ((NOT .EVENT [EVENT$V_STEP_NOSYSTEM]) OR
    					    (.DBG$RUNFRAME[DBG$L_USER_PC] LSS P1_SPACE))
    						    AND
    					   (SELECTONE .EVENT [EVENT$B_SUB_KIND] OF
						SET
						[EVENT$K_INS_EVRY]:
						    TRUE;

						[EVENT$K_INS_CALL,EVENT$K_INS_BRAN,EVENT$K_INS_USER]:
						    BEGIN
						    BIND
							OP_MAP = EVENT[EVENT$L_OPCODE_LIST] : REF BITVECTOR [512];

						    ! Check the opcode bitmap to see if the current
						    ! instruction is one we're looking for.
						    !

						    .OP_MAP [.OPCODE]
						    END;

						[EVENT$K_INS_LINE]:

    						    ! In the following parenthesized expression,
    						    ! TRUE =>  process this event, which generally means
    						    !          stop tbit-ing and take user commands,
    						    ! FALSE => don't take this event,
    						    !          which generally means keep tbit-ing.

    					   	    ! If we are still in the range given by
    						    ! LO_PC, HI_PC then don't take the event -
    						    ! keep tbit-ing.
    						    !
						    (IF (.USERS_PC GEQA .EVENT [EVENT$L_STEP_LO_PC])
									    AND
							(.USERS_PC LEQA .EVENT [EVENT$L_STEP_HI_PC])
						    THEN FALSE
						    ELSE
							BEGIN
							LOCAL 
    							    LINENO, 
    							    MODRST, 
    							    STATUS,
    							    STMTNO;

    							! The PC is out of the LO_PC, HI_PC range.
    							! Call the PC lookup routine to get a new range.
    							! If the PC lookup routine returns FALSE
    							! (0 or 2) then the lookup failed. In this
    							! case re-initialize the range to 1,0 so
    							! that we immediately are out of the range
    							! again after the next tbit.
    							! 
    							MODRST = 0;
							STATUS = DBG$PC_TO_LINE_LOOKUP(
								.USERS_PC,  
    								LINENO,
    								STMTNO,
								EVENT[EVENT$L_STEP_LO_PC],
								EVENT[EVENT$L_STEP_HI_PC],
								MODRST);
							IF NOT .STATUS THEN
							    BEGIN
							    EVENT[EVENT$L_STEP_LO_PC] = 1;
							    EVENT[EVENT$L_STEP_HI_PC] = 0;
							    END;

    							! The lookup routine can return any of:
    							! 0 - no line number information for module
    							! 1 - exact match to line
    							! 2 - have pc/line tables, but no match for this PC
    						  	! 3 - found line, not exact match.
    							! We definitely want to stop and take user commands
    							! for 0 (examples are stepping into RTL or module
    							! that is not set).
    							! We also want to stop for 1 (stepped to the beginning
    							! of a new line), and 3 (stepped to the middle of
    							! a new line).
    							! For 2, we keep going - we have stepped to a 
    							! between-lines location. RPG generates this kind
    							! of code, and doesn't want us to stop at
    							! addresses without line numbers.
    							!
							(.STATUS NEQ 2)
							END);
						TES
					   )
					THEN


					    ! The entry is active.
					    !
					    BEGIN

					    ! Process the entry.  If on return we
					    ! have been preempted by a GO, STEP,
					    ! CONTINUE, or EXIT, we will stop
					    ! processing.
					    !
					    IF DBG$PROCESS_EVENT
						    (.EVENT,
						     .SIGNAL_ARG_PTR
						    )
					    THEN
						EXITLOOP;

					    END;

					END;

				    END;


				[EVENT$K_KIND_EXC]:
				    0;

				TES;


			    ! Release any temporary memory used during the
			    ! processing of this event.  Also release all
			    ! Temporary RST Entries that have zero reference
			    ! counts.
			    !
			    DBG$REL_TEMPMEM ();
			    DBG$RST_TEMP_RELEASE();
			    END;

			END;


		    ! If this entry was the 'last' one, exit this loop.  Any others
		    ! on the list now came from "SET BREAK ..." commands in some
		    ! entry's DO command list....
		    !
		    IF .EVENT EQLA .LAST1 THEN EXITLOOP;


		    ! Link to the next entry.
		    !
		    EVENT = .EVENT [EVENT$L_CMD_FLINK];
		    END;


		! We're not skipping ACCVIO's any longer.
		!
		SKIP_ACCVIOS = FALSE;
    		SKIP_WATCHES = FALSE;
		END;


	    [SS$_ACCVIO]:


		! DEBUG uses ACCVIO's for /MODIFY events.  When an ACCVIO occurs,
		! we search the page queue for a page address match.  If one is
		! found, we flag the event as active, flag that we're skipping
		! the ACCVIO, and we're done.
		!
		BEGIN
		LOCAL
		    PAGE_ENTRY :	REF EVENT$PAGE_DESCRIPTOR,  ! Page entry
		    PAGE_ADDRESS;

		IF NOT .SKIP_ACCVIOS
		THEN
		    BEGIN


		    ! Get the page address, and point to the 1st page entry.
		    !
		    PAGE_ADDRESS = .SIGNAL_ARG_PTR [12,0,32,0] AND %X'FFFFFE00';
		    PAGE_ENTRY = .EVENT$PAGE_QUEUE [L_QUEUE_FLINK];


		    ! Search the page queue for an entry with this address.
		    !
		    WHILE .PAGE_ENTRY NEQA EVENT$PAGE_QUEUE DO
			BEGIN
			IF .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS] EQLA .PAGE_ADDRESS
			THEN


			    ! Found the matching entry, so flag that we're skipping
			    ! 'cause of an ACCVIO, and exit the search loop.
			    !
			    BEGIN
			    SKIP_ACCVIOS = TRUE;
			    ACTIVE_EVENT = TRUE;
			    EXITLOOP;
			    END

			ELSE
			    PAGE_ENTRY = .PAGE_ENTRY [EVENT$L_PAGE_FLINK];

			END;


		    ! Save the current PC for announcing where we were after we've
		    ! finished executing this instruction.
		    !
		    ACCVIO_PC = .USERS_PC;
		    END;

		END;

	    TES;


	! If no active events were discovered, look through the queue (as we
	! remember it, sans any new additions) for an exception break.  If
	! found process it.
	!
	IF NOT .ACTIVE_EVENT
	THEN
	    BEGIN


	    ! For each event entry in the queue, check to see if it is active....
	    !
	    EVENT = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
	    WHILE .EVENT NEQA EVENT$CMD_QUEUE [A_QUEUE_ENTRY] DO
		BEGIN


		! Make sure that the entry isn't deleted but not removed....
		!
		IF NOT .EVENT [EVENT$V_DELETED]
		THEN


		    ! If this is an exception break....
		    !
    		    IF .EVENT [EVENT$B_CMD_KIND] EQLU EVENT$K_KIND_EXC
    		    THEN
			BEGIN


			! The event is active.
			!
			ACTIVE_EVENT = TRUE;


			! This is an exception break or trace, so flag it.
			!
			DBG$GB_EXC_BRE_FLAG = TRUE;


			! Process the event, and scoot (it's the only one).
			!
			DBG$PROCESS_EVENT (.EVENT, .SIGNAL_ARG_PTR);
			EXITLOOP;
			END;


		! If this entry was the 'last' one, exit this loop.  Any others
		! on the list now came from "SET BREAK ..." commands in some
		! entry's DO command list....
		!
		IF .EVENT EQLA .LAST1 THEN EXITLOOP;


		! Link to the next entry.
		!
		EVENT = .EVENT [EVENT$L_CMD_FLINK];
		END;

	    END;

	END;


    ! If an active event was found, meaning we understood the exception,
    ! return check to see if a break/step ended (and the user didn't go
    ! or step in some DO clause).  If this is the case, go back to the
    ! user for commands, otherwise continue.  If an active event wasn't
    ! found, return SS$_RESIGNAL....
    !
    IF .ACTIVE_EVENT
    THEN
	BEGIN


    	! If this was not a trace event, then the EVENT$B_STOP_USER flag will
    	! still be on, indicating that we want to accept DEBUG commands.
    	! Also, if the user has typed ctrl/Y, DEBUG, then the STOP flag
    	! will have been turned on, and in this case we also want to take
    	! user commands.
	!
	IF .EVENT$B_STOP_USER OR
    	   .DBG$GV_CONTROL[DBG$V_CONTROL_STOP]
	THEN
	    BEGIN
	    LOCAL
		START_PC :  REF VECTOR [, WORD];


	    ! Turn off RMS cancel Control-O bit so that user can toggle
	    ! Control-O in the normal fashion.
	    !
	    DBG$GL_OUTPRAB [RAB$V_CCO] = FALSE;


	    ! Mark that the user program has executed so that all screen
	    ! displays will be updated before we take the next command from
	    ! the user terminal.  Note that this is suppressed if we just
	    ! returned normally from a CALL command routine.  Hence the CALL
	    ! command does not update screen displays.  If we are about to
	    ! take commands, we also clear the CALL command status flag.
	    !
	    IF .DBG$GB_CALL_NORMAL_RET NEQ 2
	    THEN
		DBG$GV_CONTROL[DBG$V_CONTROL_SCREEN] = TRUE;

	    IF .DBG$GB_TAKE_CMD THEN DBG$GB_CALL_NORMAL_RET = 0;


	    ! As long as no commands in the any processed DO clause caused the
	    ! program to continue (or restart), the command taking flag will
	    ! still be turned on, and further commands can be processed from
	    ! the input device. Otherwise, the while loop below does not
	    ! execute at all.
	    !
	    WHILE .DBG$GB_TAKE_CMD DO
		DBG$COMMAND_PROC ();

	    END;


	! Activate events....
	!
	DBG$ACTIVATE_EVENTS ();


	! Return the proper status, depending primarily on whether this was
	! an EXCEPTION break/trace, or a normal type.
	!
	IF .DBG$GB_EXC_BRE_FLAG
	THEN
    	    BEGIN
    	    DBG$RUNFRAME[DBG$V_TBIT] = .ORIG_TBIT;


	    ! Resignal the exception so that handlers can get it
	    ! (unless the user said GO <address> to go somewhere
	    ! else).
	    !
	    IF NOT .DBG$GB_TAKE_CMD
	    THEN
		IF .DBG$GB_GO_ARG_FLAG
		    THEN
			RETURN SS$_CONTINUE
		    ELSE
			RETURN SS$_RESIGNAL
	    ELSE
		RETURN SS$_RESIGNAL
    	    END
	ELSE


	    ! Return to the user.
	    !
	    RETURN SS$_CONTINUE;
	END;


    ! Didn't find an active event, so resignal the exception....
    !
    DBG$ACTIVATE_EVENTS ();
    DBG$RUNFRAME[DBG$V_TBIT] = .ORIG_TBIT;
    RETURN SS$_RESIGNAL
    END;

GLOBAL ROUTINE DBG$PROCESS_EVENT(EVENT, SIGNAL_ARG_PTR) =
!
! FUNCTIONAL DESCRIPTION:
!
!	An eventpoint has been determined to be active.  It must now be
!	processed.  This includes handling any /AFTER, WHEN, and DO.
!
!
! FORMAL PARAMETERS:
!
!	EVENT :	The address of the event entry.
!
!
! IMPLICIT OUTPUTS:
!
!	Processing the event may involve the execution of user commands.
!
!
! ROUTINE VALUE:
!
!	TRUE is a GO, STEP, CONTINUE, or EXIT command was executed within
!	a DO clause.
!
!
! SIDE EFFECTS:
!
!	Any number of things.
!
    BEGIN

    MAP
	EVENT :		    REF EVENT$EVENT_DESCRIPTOR, ! Event entry pointer
	SIGNAL_ARG_PTR :    REF BLOCK[,BYTE];

    BUILTIN CALLG;
    EXTERNAL ROUTINE dbg$final_handl;

    LOCAL
	DO_LIST_ENTRY :	REF EVENT$DO_LIST_DESCRIPTOR, ! DO LIST descriptor
	MESSAGE_VECT,		! Message Vector
    	SAVED_CISHEAD,		! Saved pointer to DBG$GL_CISHEAD
    	SAVED_LEVEL,		! Saved level of CIS nesting
	EXCEPTION_TYPE;


    ENABLE dbg$final_handl;

    ! Save the exception type (name);
    !
    EXCEPTION_TYPE = .SIGNAL_ARG_PTR [CHF$L_SIG_NAME];


    ! If this is a skips-entry, 'delete' this one and point to the parent.
    ! It is the one we want to actually process.
    !
    IF .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SKIPS
    THEN
	BEGIN
	EVENT [EVENT$V_DELETED] = TRUE;
	WHILE .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SKIPS DO
	    EVENT = .EVENT [EVENT$L_EXC_FLINK];
	END;


    ! If this is a steps-event, process it differently from the others.
    !
    IF .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS
    THEN
	BEGIN


	! Decrement the step (after) count.
	!
	IF ((EVENT [EVENT$L_AFTER_COUNT] =
	     .EVENT [EVENT$L_AFTER_COUNT] - 1
	    ) EQLU 0
	   )
	THEN


	    ! The stepping is complete....
	    !
	    BEGIN

    	    ! Special case for STEP/EXCEPTION.
    	    !
    	    IF .EVENT[EVENT$B_CMD_KIND] EQL EVENT$K_KIND_EXC
    	    THEN
    		BEGIN


		! This is an exception break or trace, so flag it.
		!
		DBG$GB_EXC_BRE_FLAG = TRUE;


		! Format and output the message.
		!
		DBG$PUTMSG (.SIGNAL_ARG_PTR);
    		END;

	    ! Announce the step.
	    !
	    ANNOUNCE_EVENT (.EVENT, .EXCEPTION_TYPE);


	    ! Delete the step.
	    !
	    EVENT [EVENT$V_DELETED] = TRUE;


	    ! DEBUG will stop for commands.
	    !
	    EVENT$B_STOP_USER = TRUE;
	    END;


	! Return - we haven't executed any new commands....
	!
	RETURN FALSE;
	END;


    ! This is not a steps (or skips) entry.  Process normally.
    ! Update the /AFTER count.  If it becomes equal to 0, then the entry is
    ! now active.
    !
    IF ((EVENT [EVENT$L_AFTER_COUNT] =
	 .EVENT [EVENT$L_AFTER_COUNT] - 1
	) EQLU 0
       )
    THEN
	BEGIN


	! We've passed the /AFTER test.  Now set the /AFTER count to 1.
	!
	EVENT [EVENT$L_AFTER_COUNT] = 1;


	! If there is a WHEN expression, procees it....
	!
	IF .EVENT [EVENT$L_WHEN] NEQA 0
	THEN
	    BEGIN
    	    PARSE_WHEN_CONDITION(.EVENT);

    	    
	    ! If the condition is false, return FALSE.
	    !
	    IF NOT .WHEN_CONDITION
	    THEN
		RETURN FALSE;
	    END;


	! If this event is temporary, flag it as deleted now.  This shouldn't
	! affect any further processing, but the entry will be deleted when
	! we go off to the user program.
	!
	IF .EVENT [EVENT$V_ONCE_ONLY]
	THEN
	    EVENT [EVENT$V_DELETED] = TRUE;


	! Flag a stop, if this is a BREAK.
	!
	IF .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_BREAK OR
	   .EVENT [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_WATCH
	THEN
	    EVENT$B_STOP_USER = TRUE;


	! Case on the kind of event entry, to determine how to process it.
	!
	CASE .EVENT [EVENT$B_CMD_KIND]
	FROM EVENT$K_KIND_ACC TO EVENT$K_KIND_EXC OF
	    SET
	    [EVENT$K_KIND_ACC]:
		ANNOUNCE_EVENT (.EVENT, .EXCEPTION_TYPE);

	    [EVENT$K_KIND_INS]:
		ANNOUNCE_EVENT (.EVENT, .EXCEPTION_TYPE);

	    [EVENT$K_KIND_EXC]:
		BEGIN


		! This is an exception break or trace, so flag it.
		!
		DBG$GB_EXC_BRE_FLAG = TRUE;


		! Format and output the message.
		!
		DBG$PUTMSG (.SIGNAL_ARG_PTR);


		! Announce the break.
		!
		ANNOUNCE_EVENT (.EVENT, .EXCEPTION_TYPE);
		END;
	    TES;


	! If there is a DO associated with this entry, do it.
	! 
	IF .EVENT [EVENT$L_DO] NEQA 0
	THEN
	    BEGIN


	    ! We need a local pointer to the DO command string.
	    !
	    LOCAL
		DO_LENGTH,
		DO_STRING :   REF VECTOR [, BYTE];


	    ! Point to the DO LIST entry.
	    !
	    DO_LIST_ENTRY = .EVENT [EVENT$L_DO];


	    ! Point to the command string.
	    !
	    DO_LENGTH = .(.DO_LIST_ENTRY[EVENT$L_DO_LIST_POINT])<0,16,0>;

	    DO_STRING = DBG$GET_MEMORY((.DO_LENGTH/%UPVAL)+1);
	    CH$MOVE(.DO_LENGTH,.DO_LIST_ENTRY[EVENT$L_DO_LIST_POINT]+2,.DO_STRING);
	    DO_STRING[.DO_LENGTH] = 0;


	    ! Add a link to the command input stream. First remember the
    	    ! current pointer to the head of the CIS stack, and the number
    	    ! of levels of nesting.
	    !
    	    SAVED_CISHEAD = .DBG$GL_CISHEAD;
    	    SAVED_LEVEL = .DBG$GL_CIS_LEVELS;
	    IF NOT DBG$NCIS_ADD (.DO_STRING, .DO_LENGTH, CIS_INPBUF,
							0, 0, MESSAGE_VECT)
	    THEN
		CALLG (.MESSAGE_VECT, LIB$SIGNAL);


	    ! Process the DO clause. We repeatedly call COMMAND_PROC, each
    	    ! call executing one command from the DO list. We exit the
    	    ! loop if either: 1) the user said STEP or GO, thus resulting
    	    ! in the TAKE_CMD flag becoming false, or 2) We exhaust the
    	    ! commands in the current CIS, and get back to the SAVED_CISHEAD
    	    ! level. 
	    !
	    DBG$NINITIALIZE ();
    	    WHILE (.DBG$GB_TAKE_CMD) AND 
    		  (.DBG$GL_CISHEAD NEQ .SAVED_CISHEAD) AND
    	   	  (.DBG$GL_CIS_LEVELS GTR .SAVED_LEVEL) DO
	        DBG$COMMAND_PROC ();


	    ! If the user typed a GO, STEP, EXIT, or CONTINUE, return true,
	    ! otherwise false.
	    !
	    RETURN NOT .DBG$GB_TAKE_CMD;
	    END;
	END;


	! Return FALSE since the /AFTER count hasn't run out.
	!
	RETURN FALSE;
    END;

GLOBAL ROUTINE DBG$UPDATE_WATCHPOINTS: NOVALUE =
!
! FUNCTION
!	This routine updates the values in the watch point events.  This
!	is done in order to keep the watched values current even after a
!	DEPOSIT.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	All watch point event entries are updated with their current value.
!

    BEGIN

    LOCAL
	EVENT_ENTRY	: REF EVENT$EVENT_DESCRIPTOR,
        LENGTH,
	NEW_VALDESC	: REF DBG$VALDESC,
        OLD_VALDESC	: REF DBG$VALDESC;


    ! Starting at the head of the command queue, update each watch point
    ! entry.
    !
    EVENT_ENTRY = .EVENT$CMD_QUEUE [L_QUEUE_FLINK];
    WHILE .EVENT_ENTRY NEQA EVENT$CMD_QUEUE DO
	BEGIN

	! If this is a watch point entry, update it.
	!
	IF .EVENT_ENTRY[EVENT$B_SUB_KIND] EQL EVENT$K_ACC_MDFY
	THEN
            BEGIN

            ! Get the byte length of the entry's value.  Note that we actually
            ! get it's bit length and round up.
            ! 
            LENGTH = DBG$DATA_LENGTH(EVENT_ENTRY[EVENT$A_VMSDESC]);
            LENGTH = (.LENGTH + 7) ^ -3;

            ! Make a new value descriptor from the VMS descriptor in this
            ! event entry.  This will then contain the new current value
            ! we are looking for.
            !
            NEW_VALDESC = DBG$MAKE_VAL_DESC(EVENT_ENTRY[EVENT$A_VMSDESC],
                                            DBG$K_VALUE_DESC);

            ! Now copy the "new" value into the old value descriptor that
            ! hangs of this event entry.
            !
            OLD_VALDESC = .EVENT_ENTRY[EVENT$L_VALDESC];
            CH$MOVE(.LENGTH,
                    NEW_VALDESC [DBG$A_VALUE_ADDRESS],
                    OLD_VALDESC [DBG$A_VALUE_ADDRESS]);
            END;

	! Point to the next Command Queue entries.
	!
	EVENT_ENTRY = .EVENT_ENTRY [EVENT$L_CMD_FLINK];
	END;
    END;

ROUTINE ANNOUNCE_EVENT(EVENT_ENTRY, EXCEPTION_TYPE): NOVALUE =
!
! FUNCTION
!	This routine announces an event entry if the /SILENT flag is false.
!
! INPUTS
!	EVENT_ENTRY :		Pointer to event entry.
!
! OUTPUTS
!	Announces the event entry via DBG$PRINT.
!

    BEGIN

    MAP
	EVENT_ENTRY :	    REF EVENT$EVENT_DESCRIPTOR, ! Event Entry Pointer
	EXCEPTION_TYPE :    BLOCK [%UPVAL, BYTE];


    LOCAL
    	VMS_DESC: DBG$STG_DESC,
    	VAL_DESC: REF DBG$VALDESC,
	STRING_DESCRIPTOR : BLOCK [8, BYTE],
	OUTPUT_BUFFER : VECTOR [TTY_OUT_WIDTH, BYTE],
	DUMMY,

	ADDRESS;				    ! Entry address


    ! If the /SILENT flag is set, return without announcing.
    ! (This can be set by SET BREA/SILENT or STEP/SILENT).
    !
    IF .EVENT_ENTRY[EVENT$V_SILENT] THEN RETURN;


    ! Purge type ahead.
    !
    DBG$GL_OUTPRAB [RAB$V_CCO] = TRUE;


    ! Setup a string descriptor.
    !
    STRING_DESCRIPTOR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    STRING_DESCRIPTOR [DSC$B_CLASS] = DSC$K_CLASS_S;
    STRING_DESCRIPTOR [DSC$A_POINTER] = 0;
    STRING_DESCRIPTOR [DSC$W_LENGTH] = 0;


    ! Print the event type (break, trace, watch or stepto - point).
    !
    DBG$PRINT	($AC	('!AC'),
		 SELECTONE .EVENT_ENTRY [EVENT$B_CMD_TYPE] OF
		     SET
		     [EVENT$K_TYPE_BREAK]:
			 $AC ('break');
		     [EVENT$K_TYPE_TRACE]:
			 $AC ('trace');
		     [EVENT$K_TYPE_WATCH]:
			 $AC ('watch');
		     [EVENT$K_TYPE_STEPS]:
			 $AC ('stepped');
		     TES
		);


    ! Display the event kind (access, exception, instruction).
    !
    SELECTONE .EVENT_ENTRY [EVENT$B_CMD_KIND] OF
	SET


	! This is an access (read, write, modify, execute) kind
	! of event point.  Display the address.
	!
	[EVENT$K_KIND_ACC]:
	    BEGIN


	    ! If this is not an /EXECUTE type (we're done with those), continue
	    ! processing....
	    !
	    IF .EVENT_ENTRY [EVENT$B_SUB_KIND] NEQU EVENT$K_ACC_EXEC
	    THEN
		BEGIN


		! Print the access kind if read, write, modify, or return.
		! If the address is an entry point, indicate that it is a
		! routine.
		!
		DBG$PRINT   ($AC	(' !AC!AC'),
			     IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU
				EVENT$K_TYPE_WATCH
			     THEN
				SELECTONE .EVENT_ENTRY [EVENT$B_SUB_KIND] OF
				SET
				    [EVENT$K_ACC_READ]:
					$AC ('on read of ');
				    [EVENT$K_ACC_WRIT]:
					$AC ('on write of ');
				    [EVENT$K_ACC_MDFY]:
					$AC ('on modify of ');
				    [EVENT$K_ACC_RTRN]:
					$AC ('on return from ');
				TES
			     ELSE
				$AC ('of '),

    			     IF .EVENT_ENTRY [EVENT$V_BREAK_ADDRESS]
    			     THEN
    				$AC ('routine ')
    			     ELSE
    				BEGIN
			        IF DBG$IS_IT_ENTRY
				    (.EVENT_ENTRY [EVENT$L_ADDRESS] - 2)
			        THEN
				    $AC ('routine ')
			        ELSE
				    $AC ('')
    				END
			    );


		! Print the address.
		!
		IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS
		THEN
		    BEGIN
		    LOCAL
			FROM_ADDR;


		    ! Display 'ROUTINE' if the saved 'from' address points
		    ! after an entry point.
		    !
		    FROM_ADDR = .EVENT_ENTRY [EVENT$L_USERS_PC];
		    IF DBG$IS_IT_ENTRY (.FROM_ADDR - 2)
		    THEN
			BEGIN
			DBG$PRINT ($AC ('routine '));
			FROM_ADDR = .FROM_ADDR - 2;
			END;


		    ! Print the address, but symbolize it first.
		    !
		    DBG$PRINT_IDENTIFIER_PC (.FROM_ADDR);
		    END

		ELSE
    	            DBG$PRINT_IDENTIFIER (.EVENT_ENTRY [EVENT$L_PRIMARY]);

		END;


	    ! Depending on the command type....
	    !
	    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS
	    THEN
		DBG$PRINT ($AC (' to '))

	    ELSE
		DBG$PRINT ($AC (' at '));

	    END;


	! This is an instruction type.
	!
	[EVENT$K_KIND_INS]:
	    BEGIN


	    ! Display the instruction type (calls, branches, all, or user
	    ! list.
	    !
	    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_STEPS
	    THEN
		DBG$PRINT
			($AC	(' on !AC'),
			 SELECTONE .EVENT_ENTRY [EVENT$B_SUB_KIND] OF
			    SET
			    [EVENT$K_INS_CALL]:
				$AC ('calls');
			    [EVENT$K_INS_BRAN]:
				$AC ('branches');
			    [EVENT$K_INS_EVRY]:
				$AC ('instruction');
			    [EVENT$K_INS_USER]:
				$AC ('instruction(s)');
			    [EVENT$K_INS_LINE]:
				$AC ('lines');
			    TES
			);


	    ! Depending on the command type....
	    !
	    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS
	    THEN
		DBG$PRINT ($AC (' to '))
	    ELSE
		DBG$PRINT ($AC (' at '));
	    END;


	! This is an exception type.
	!
	[EVENT$K_KIND_EXC]:
	    BEGIN
	    LOCAL
		DST_PTR : REF DST$RECORD,
		RST_PTR : REF RST$ENTRY,
		TRAP_OR_FAULT,
		LINE_NO,
		STMT_NO,
		STATUS;


	    ! Determine the nature (trap or fault) of the exception.
	    !
	    IF .EXCEPTION_TYPE [STS$V_FAC_NO] EQL 0
	    THEN
		BEGIN
		SELECTONE .EXCEPTION_TYPE OF
		    SET

		    [SS$_ASTFLT, SS$_BREAK, SS$_COMPAT,
		     SS$_OPCCUS, SS$_OPCDEC, SS$_RADRMOD, SS$_ROPRAND]:
			TRAP_OR_FAULT = FAULT_EXC;

		    [OTHERWISE]:
			TRAP_OR_FAULT = TRAP_EXC;

		    TES;

		END


	    ! If the facility is not SS$, then we have a trap, meaning that the
	    ! PC points to the instruction after the LIB$SIGNAL or LIB$STOP call
	    ! that raised the exception.  (Non-SS$ exceptions can only be sig-
	    ! nalled, not raised by the hardware.)
	    !
	    ELSE
		TRAP_OR_FAULT = TRAP_EXC;


	    ! The PC is the address to display.
	    !
	    ADDRESS = .DBG$RUNFRAME [DBG$L_USER_PC];


	    ! Display the appropriate message.
	    !
	    DBG$PRINT ($AC (' on exception '));
	    IF .TRAP_OR_FAULT EQL TRAP_EXC
	    THEN
		DBG$PRINT ($AC ('preceding '))

	    ELSE
		DBG$PRINT ($AC ('at '));

	    END;

	TES;


    ! If this is a /MODIFY event (we used ACCVIO's), the address of the
    ! offending instruction is in ACCVIO_PC, otherwise it's just the
    ! current PC.
    !
    IF (.EVENT_ENTRY [EVENT$B_CMD_KIND] EQLU EVENT$K_KIND_ACC) AND
       (.EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU EVENT$K_ACC_MDFY)
    THEN
	ADDRESS = .ACCVIO_PC

    ELSE
	ADDRESS = .DBG$RUNFRAME [DBG$L_USER_PC];


    ! Symbolize and print address (and instruction)
    !
    PRINT_PC_AND_INSTRUCTION (.ADDRESS, .EVENT_ENTRY);
    DBG$NEWLINE ();


    ! If this is a modify-type, display the old and new values, and the
    ! BREAK message.
    !
    IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU EVENT$K_ACC_MDFY
    THEN
	BEGIN


	! Print the source line where the actual variable-access occurred if
	! appropriate.
	!
	IF (.EVENT_ENTRY[EVENT$V_OVRD_SOURCE] AND
				.EVENT_ENTRY[EVENT$V_STEP_SOURCE]) OR
	   ((NOT .EVENT_ENTRY[EVENT$V_OVRD_SOURCE]) AND
				.DBG$GB_STP_PTR[EVENT$V_STEPPING_SOURCE])
	THEN
	    PRINT_SOURCE(.ADDRESS);


	! Print the old value and the new value of the watched location.
	!
	DBG$PRINT($AC('   old value: '));
	DBG$PRINT_VALUE(.OLDVALUE, .DBG$GB_RADIX[DBG$B_RADIX_OUTPUT_OVER],
						.DBG$GL_SIGN_FLAG, FALSE);
	DBG$NEWLINE();
	DBG$PRINT($AC('   new value: '));
	DBG$PRINT_VALUE(.NEWVALUE, .DBG$GB_RADIX[DBG$B_RADIX_OUTPUT_OVER],
						.DBG$GL_SIGN_FLAG, FALSE);
	DBG$NEWLINE();


	! Display the 'BREAK AT <address>' message.
	!
	DBG$PRINT (IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU
		      EVENT$K_TYPE_TRACE
		   THEN
			$AC ('break at ')
		   ELSE
			$AC ('trace at ')
		  );

	! Symbolize and print address (and instruction)
	!
        PRINT_PC_AND_INSTRUCTION (.DBG$RUNFRAME [DBG$L_USER_PC], .EVENT_ENTRY);
	DBG$NEWLINE ();
	END;


    ! Display the source line, if source stepping is indicated.
    !
    IF .TYPE_SOURCE AND
       ((.EVENT_ENTRY[EVENT$V_OVRD_SOURCE] AND
				.EVENT_ENTRY[EVENT$V_STEP_SOURCE]) OR
	((NOT .EVENT_ENTRY[EVENT$V_OVRD_SOURCE]) AND
				.DBG$GB_STP_PTR[EVENT$V_STEPPING_SOURCE]))
    THEN
	BEGIN
	PRINT_SOURCE (.DBG$RUNFRAME [DBG$L_USER_PC]);
	TYPE_SOURCE = FALSE;
	END;


    ! We are all done--return.
    !
    RETURN;

    END;

ROUTINE INSQUE1(ENTRY_ADDRESS, QUEUE_ADDRESS): NOVALUE =
!
! FUNCTION
!	This routine adds an entry into a queue.  This routine is used when
!	the forward and backward links are not the 0th and 1st longwords in
!	the queue head and queue entry, but the 2nd and 3rd.
!
! INPUTS
!	QUEUE_ADDRESS :		Pointer to queue head.
!	ENTRY_ADDRESS :		Pointer to entry.
!
! OUTPUTS
!	None
!
    BEGIN

    MAP
	ENTRY_ADDRESS :	REF QUEUE_HEAD,
	QUEUE_ADDRESS : REF QUEUE_HEAD;

    LOCAL
	NEXTS_ADDRESS :	REF QUEUE_HEAD;	    ! Next entry's pointer.


    ! Point to the current 1st (next) entry.
    !
    NEXTS_ADDRESS = .QUEUE_ADDRESS [L_QUEUE_FLINK1];


    ! Link the queue entry into the queue at the head.
    !
    ENTRY_ADDRESS [L_QUEUE_FLINK1] = .QUEUE_ADDRESS [L_QUEUE_FLINK1];
    ENTRY_ADDRESS [L_QUEUE_BLINK1] = .QUEUE_ADDRESS;


    ! Link the queue to the queue entry.
    !
    QUEUE_ADDRESS [L_QUEUE_FLINK1] = .ENTRY_ADDRESS;
    NEXTS_ADDRESS [L_QUEUE_BLINK1] = .ENTRY_ADDRESS;
    END;

ROUTINE REMQUE1(ENTRY_ADDRESS): NOVALUE =
!
! FUNCTION
!	This routine deletes an entry from a queue.  This routine is used when
!	the forward and backward links are not the 0th and 1st longwords in
!	the queue head and queue entry, but the 2nd and 3rd.
!
! INPUTS
!	ENTRY_ADDRESS :		Pointer to entry.
!
! OUTPUTS
!	None
!
    BEGIN

    MAP
	ENTRY_ADDRESS :	REF QUEUE_HEAD;

    LOCAL
	NEXTS_ADDRESS :	REF QUEUE_HEAD,
	QUEUE_ADDRESS : REF QUEUE_HEAD;


    ! Point to the queue head and next entry.
    !
    QUEUE_ADDRESS = .ENTRY_ADDRESS [L_QUEUE_BLINK1];
    NEXTS_ADDRESS = .ENTRY_ADDRESS [L_QUEUE_FLINK1];


    ! Unlink the entry from the queue.
    !
    QUEUE_ADDRESS [L_QUEUE_FLINK1] = .NEXTS_ADDRESS;
    NEXTS_ADDRESS [L_QUEUE_BLINK1] = .QUEUE_ADDRESS;
    END;

ROUTINE PRINT_SOURCE(ADDRESS): NOVALUE =
    BEGIN
    BUILTIN
	FP;

    .FP = DBG$FINAL_HANDL;
    DBG$SRC_TYPE_PC_SOURCE (.ADDRESS, .ADDRESS, 0, TRUE);
    END;

ROUTINE PRINT_PC_AND_INSTRUCTION(ADDRESS, EVENT): NOVALUE =
    BEGIN
    MAP 
    	ADDRESS :	REF VECTOR [, BYTE],
    	EVENT   :	REF EVENT$EVENT_DESCRIPTOR;

    LOCAL ADDRESS_2;
    BUILTIN
    	FP;


    ! Establish a handler for errors. This is in case the instruction
    ! we have stepped to is invalid, and the INS_DECODE routine signals
    ! an error.
    !
    .FP = PRINT_PC_INST_HANDLER;


    ! Display 'ROUTINE' if the current address points after an entry point.
    !
    IF .EVENT [EVENT$V_BREAK_ADDRESS]
    THEN
    	DBG$PRINT ($AC ('routine '))

    ELSE
    	BEGIN
    	IF DBG$IS_IT_ENTRY ((ADDRESS_2 = .ADDRESS - 2))
    	THEN
	    DBG$PRINT ($AC ('routine '))
        ELSE
	    ADDRESS_2 = .ADDRESS;
    	END;


    ! Print the address, but symbolize it first.
    !
    IF .EVENT [EVENT$V_BREAK_ADDRESS]
    THEN
    	DBG$PRINT_IDENTIFIER (.EVENT [EVENT$L_PRIMARY])
    ELSE
        DBG$PRINT_IDENTIFIER_PC (.ADDRESS_2);


    ! Display the instruction we're at, if we're not line stepping.
    !
    IF .DBG$GB_STP_PTR [EVENT$V_STEPPING_LINE] THEN RETURN;

    DBG$PRINT($AC (': '));
    DBG$INS_DECODE (.ADDRESS, TRUE, FALSE);
    END;

ROUTINE PRINT_PC_INST_HANDLER(SIG_ARG_LIST) =
! 
! FUNCTION
!	Handler for errors that occur during the PRINT_PC_AND_INSTRUCTION
!	routine. We need a handler so that after displaying the error,
!	we will unwind to the caller of PRINT_PC_AND_INSTRUCTION, and
!	continue with any eventpoint processing that was being done.
!
! INPUTS
!	SIG_ARG_LIST	- The signal argument list that we get from
!			  the condition handling facility.
!	
! OUTPUTS
!
    BEGIN
    MAP
    	SIG_ARG_LIST: REF BLOCK[,BYTE];
    

    ! If informational just resignal
    !
    IF .SIG_ARG_LIST[CHF$L_SIG_NAME]
    THEN
    	RETURN SS$_RESIGNAL;


    ! If we are in the middle of an unwind then continue unwinding.
    !
    IF .SIG_ARG_LIST[CHF$L_SIG_NAME] EQL SS$_UNWIND
    THEN
    	RETURN SS$_CONTINUE;


    ! Otherwise, display a message saying that an error occurred during
    ! instruction decode and then display the actual error that occured.
    !
    SIGNAL(DBG$_ERRINSDEC);
    DBG$PUTMSG(.SIG_ARG_LIST);    


    ! Then unwind to the routine that called PRINT_PC_AND_INSTRUCTION.
    !
    SETUNWIND();
    RETURN SS$_CONTINUE;
    END;

ROUTINE SHOW_EVENT_ENTRY(EVENT_ENTRY): NOVALUE =
!
! FUNCTION
!	This routine displays an event entry as in:
!
!	SHOW [ BREAK | TRACE | WATCH ]
!
! INPUTS
!	EVENT_ENTRY :		Pointer to event entry.
!
! OUTPUTS
!	Displays the event entry via DBG$PRINT.
!

    BEGIN

    MAP
	EVENT_ENTRY: REF EVENT$EVENT_DESCRIPTOR; ! Event Entry Pointer


    LOCAL
    	VMS_DESC: DBG$STG_DESC,		!
    	VAL_DESC: REF DBG$VALDESC,	!
	WHEN_ENTRY:			! When Entry Pointer
		REF EVENT$WHEN_DESCRIPTOR,!
	DO_LIST_ENTRY:			! DO List Entry Pointer
		REF EVENT$DO_LIST_DESCRIPTOR,!
	STRING_DESCRIPTOR: BLOCK[8,BYTE],! String descriptor
	OUTPUT_BUFFER:			! Temporary formatting buffer
		VECTOR[TTY_OUT_WIDTH,BYTE],!
	DUMMY;				! Dummy routine argument



    ! Skip STEPS, SKIPS, and IGNOR entries.
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS OR
       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SKIPS OR
       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_IGNOR OR
       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SSINT
    THEN
	RETURN;


    ! Setup a string descriptor.
    !
    STRING_DESCRIPTOR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    STRING_DESCRIPTOR [DSC$B_CLASS] = DSC$K_CLASS_S;
    STRING_DESCRIPTOR [DSC$A_POINTER] = 0;
    STRING_DESCRIPTOR [DSC$W_LENGTH] = 0;


    ! For watchpoint events, see whether the watched Primary
    ! is still valid. If not, convert the Primary to a Volatile
    ! Value Descriptor and display an informational to that effect.
    !
    IF .EVENT_ENTRY[EVENT$B_SUB_KIND] EQL EVENT$K_ACC_MDFY
    THEN
    	BEGIN
    	LOCAL
    	    PRIMARY,
    	    SYMID_LIST,
    	    VALDESC,
    	    V_VALDESC: REF DBG$VALDESC;


      	! Copy the Primary since PRIM_TO_VAL sometimes has the side effect
    	! of modifying its argument. This copy is done into temporary
    	! memory (fourth parameter is FALSE). Then call PRIM_TO_VAL
    	! and get a Volatile Value Descriptor (this will have
    	! the real address of the watched variable embedded in it).
    	! PRIM_TO_VAL is a cover routine for DBG$PRIM_TO_VAL; it has
    	! a handler which sets INVALID_FLAG if the Primary is no longer
    	! valid (has gone out of scope).
    	!
    	DBG$NCOPY_DESC (.EVENT_ENTRY[EVENT$L_PRIMARY], PRIMARY, DUMMY, FALSE);
    	INVALID_FLAG = FALSE;
    	PRIM_TO_VAL (.PRIMARY, DBG$K_V_VALUE_DESC, V_VALDESC);


    	! Check whether the Primary is still valid, i.e., whether it still
    	! points to the same storage as it did when the watchpoint was set.
    	!
    	IF .INVALID_FLAG OR
    	   CH$NEQ (12, V_VALDESC[DBG$A_VALUE_VMSDESC], 
    	           12, EVENT_ENTRY[EVENT$A_VMSDESC])
    	THEN
    	    BEGIN


	    ! Print an informational saying the Primary is invalid.
	    !
	    DBG$PRINT ($AC ('%DEBUG-I-WATCHVAR, watched variable '));
            DBG$PRINT_IDENTIFIER(.EVENT_ENTRY[EVENT$L_PRIMARY]);
    	    IF .INVALID_FLAG
    	    THEN
                DBG$PRINT ($AC (' has gone out of scope'))
    	    ELSE
                DBG$PRINT ($AC (' now points to a different address'));
    	    DBG$NEWLINE();


	    ! Free up the Primary.
	    !
	    IF DBG$NGET_SYMID (.EVENT_ENTRY[EVENT$L_PRIMARY], SYMID_LIST, DUMMY)
    	    THEN
    	    	DBG$STA_UNLOCK_SYMID (.SYMID_LIST);
    	    DBG$NFREE_DESC (.EVENT_ENTRY[EVENT$L_PRIMARY], DUMMY);   


	    ! Replace it with the Volatile Value Descriptor.
	    !
	    V_VALDESC = DBG$MAKE_VAL_DESC(EVENT_ENTRY[EVENT$A_VMSDESC], DBG$K_V_VALUE_DESC);
	    IF DBG$NGET_SYMID (.V_VALDESC, SYMID_LIST, DUMMY)
	    THEN
		DBG$STA_LOCK_SYMID (.SYMID_LIST);
	    DBG$NCOPY_DESC (.V_VALDESC, EVENT_ENTRY[EVENT$L_PRIMARY], DUMMY, TRUE);
    	    END;
    	END;


    ! Print the event type: breakpoint, tracepoint, or watchpoint.
    !
    SELECTONE .EVENT_ENTRY[EVENT$B_CMD_TYPE] OF
	SET

	[EVENT$K_TYPE_BREAK]:
	    DBG$PRINT($AC('breakpoint'));

	[EVENT$K_TYPE_TRACE]:
	    DBG$PRINT($AC('tracepoint'));

	[EVENT$K_TYPE_WATCH]:
	    DBG$PRINT($AC('watchpoint'));

	TES;


    ! Display the event kind (access, exception, instruction).
    !
    SELECTONE .EVENT_ENTRY [EVENT$B_CMD_KIND] OF
	SET


	! This is an access (read, write, modify, execute) kind
	! of event point.  Display the address.
	!
	[EVENT$K_KIND_ACC]:
	    BEGIN


	    ! Print the access kind if read, write, or modify.  If the address
	    ! is an entry point, indicate that it is a routine.
	    !
	    IF .EVENT_ENTRY[EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_WATCH
	    THEN
		BEGIN
		SELECTONE .EVENT_ENTRY[EVENT$B_SUB_KIND] OF
		    SET

		    [EVENT$K_ACC_READ]:
			DBG$PRINT($AC(' on read of '));

		    [EVENT$K_ACC_WRIT]:
			DBG$PRINT($AC(' on write of '));

		    [EVENT$K_ACC_MDFY]:
			DBG$PRINT($AC(' on modify of '));

		    [EVENT$K_ACC_EXEC]:
			DBG$PRINT($AC(' at '));

		    [EVENT$K_ACC_RTRN]:
			DBG$PRINT($AC(' on return from '));

		    TES;

		END


	    ! For watchpoints, simply say "watchpoint of".
	    !
	    ELSE
		DBG$PRINT($AC (' of '));


	    ! We print the address next.  If the address is a routine address
	    ! (a CALLS/CALLG entry point), we refer to it as "routine XXX",
	    ! where XXX is the routine name.  If it is not a routine, we omit
	    ! the "routine" designation.
	    !
	    IF .EVENT_ENTRY[EVENT$V_BREAK_ADDRESS] OR
	       DBG$IS_IT_ENTRY(.EVENT_ENTRY[EVENT$L_ADDRESS] - 2)
	    THEN
		DBG$PRINT($AC('routine '));

	    DBG$PRINT_IDENTIFIER(.EVENT_ENTRY[EVENT$L_PRIMARY]);


	    ! Check for the /SOURCE or /NOSOURCE override switch.  If set, we
	    ! print "[source]" or "[nosource]", as appropriate.
	    !
	    IF .EVENT_ENTRY[EVENT$V_OVRD_SOURCE]
	    THEN
		BEGIN
		IF .EVENT_ENTRY[EVENT$V_STEP_SOURCE]
		THEN
		    DBG$PRINT($AC(' [source]'))

		ELSE
		    DBG$PRINT($AC(' [nosource]'));

		END;

	    END;			! End of case for access kind of event


	! This is an instruction type.
	!
	[EVENT$K_KIND_INS]:
	    BEGIN


	    ! Display the /SOURCE or /NOSOURCE qualifier if specified.
	    !
	    IF .EVENT_ENTRY[EVENT$V_OVRD_SOURCE]
	    THEN
		BEGIN
		IF .EVENT_ENTRY[EVENT$V_STEP_SOURCE]
		THEN
		    DBG$PRINT($AC('/source'))

		ELSE
		    DBG$PRINT($AC('/nosource'));

		END;


	    ! Display the /SOURCE or /NOSOURCE qualifier if specified.
	    !
	    IF .EVENT_ENTRY[EVENT$V_OVRD_NOSYSTEM]
	    THEN
		BEGIN
		IF .EVENT_ENTRY[EVENT$V_STEP_NOSYSTEM]
		THEN
		    DBG$PRINT($AC('/nosystem'))

		ELSE
		    DBG$PRINT($AC('/system'));

		END;


	    ! Display the /OVER or /INTO qualifier if specified.
	    !
	    IF .EVENT_ENTRY[EVENT$V_OVRD_OVER]
	    THEN
		BEGIN
		IF .EVENT_ENTRY[EVENT$V_STEP_OVER]
		THEN
		    DBG$PRINT($AC('/over'))

		ELSE
		    DBG$PRINT($AC('/into'));

		END;


	    ! Display the instruction type (calls, branches, all, or user
	    ! list.
	    !
	    DBG$PRINT	($AC	(' on !AC'),
			 SELECTONE .EVENT_ENTRY [EVENT$B_SUB_KIND] OF
			    SET
			    [EVENT$K_INS_CALL]:
				$AC ('calls:');
			    [EVENT$K_INS_BRAN]:
				$AC ('branches:');
			    [EVENT$K_INS_EVRY]:
				$AC ('instructions');
			    [EVENT$K_INS_USER]:
				$AC ('instruction(s):');
			    [EVENT$K_INS_LINE]:
				$AC ('lines');
			    TES
			);

	    END;


	! This is an exception type.
	!
	[EVENT$K_KIND_EXC]:
	    DBG$PRINT($AC(' on exception'));

	TES;


    ! If this entry is silent, say so.
    !
    IF .EVENT_ENTRY[EVENT$V_SILENT] THEN DBG$PRINT($AC(' [silent]'));


    ! If this entry is temporary, say so.
    !
    IF .EVENT_ENTRY[EVENT$V_ONCE_ONLY] THEN DBG$PRINT($AC(' [temporary]'));


    ! If this entry is an instruction type (/CALL, /BRANCH, etc.) and
    ! has an opcode bit map (i.e., is not for all instructions),
    ! display the opcode mnemonics indicated.
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_KIND] EQLU EVENT$K_KIND_INS AND
       .EVENT_ENTRY [EVENT$L_OPCODE_LIST] NEQA 0
    THEN
	BEGIN


	! Declare a pointer to an opcode list, and an opcode
	! variable.
	!
	LOCAL
	    OPCODE_LIST: REF BITVECTOR [512],
	    COLUMN;


	! Point to the opcode list, and set the column to 0.
	!
	OPCODE_LIST = .EVENT_ENTRY [EVENT$L_OPCODE_LIST];
	COLUMN = -1;
	INCR OPCODE FROM 0 TO 511 DO
	    BEGIN
	    IF .OPCODE_LIST [.OPCODE] THEN
		BEGIN
		LOCAL INDEX;
		COLUMN = (.COLUMN + 1) AND 7;
		IF .COLUMN EQLU 0 THEN DBG$NEWLINE();
		INDEX = .DBG$OPCODE_KIND_TABLE[.OPCODE];
		DBG$PRINT($AC ('!_!AD'), 6,
				DBG$OPCODE_NAME_TABLE[.INDEX,0,0,0,0]);
		END;

	    END;

	DBG$NEWLINE();
	END


    ! Otherwise, just print the line.
    !
    ELSE
	DBG$NEWLINE ();


    ! If the after count is not the default (1), print it.
    !
    IF .EVENT_ENTRY [EVENT$L_AFTER_COUNT] NEQU 1
    THEN
	BEGIN
	DBG$PRINT($AC('   /after: !UL'), .EVENT_ENTRY[EVENT$L_AFTER_COUNT]);
	DBG$NEWLINE();
	END;


    ! If there is a WHEN entry, print it.
    !
    IF .EVENT_ENTRY [EVENT$L_WHEN] NEQA 0
    THEN
	BEGIN
	LOCAL
	    STRING :	REF VECTOR [, WORD];

	WHEN_ENTRY = .EVENT_ENTRY [EVENT$L_WHEN];
	STRING = .WHEN_ENTRY [EVENT$L_WHEN_POINT];
	DBG$PRINT($AC('   when (!AD)'), .STRING[0] - 1, STRING[1]);
	DBG$NEWLINE();
	END;


    ! If there is a DO list entry, print it.
    !
    IF .EVENT_ENTRY [EVENT$L_DO] NEQA 0
    THEN
	BEGIN
	LOCAL
	    STRING :	REF VECTOR [, WORD];

	DO_LIST_ENTRY = .EVENT_ENTRY [EVENT$L_DO];
	STRING = .DO_LIST_ENTRY [EVENT$L_DO_LIST_POINT];
	DBG$PRINT($AC('   do (!AD)'), .STRING[0] - 1, STRING[1]);
	DBG$NEWLINE();
	END;

    END;

GLOBAL ROUTINE DELETE_EVENT_ENTRY(EVENT_ENTRY): NOVALUE =
!
! FUNCTION
!	This routine is called to delete an event entry from its queue
!	(the command queue and event queue if linked in), as well as
!	any value descriptor, WHEN, or DO entries.
!
! INPUTS
!	EVENT_ENTRY :		Pointer to the event entry to be deleted.
!
! OUTPUTS
!	None
!

    BEGIN

    MAP
	EVENT_ENTRY :	    REF EVENT$EVENT_DESCRIPTOR;

    LOCAL
	WHEN_ENTRY :	    REF EVENT$WHEN_DESCRIPTOR,	    ! WHEN pointer
	DO_LIST_ENTRY :	    REF EVENT$DO_LIST_DESCRIPTOR,   ! DO List pointer

	ADDRESS,					    ! Release address
	SYMID_LIST,
	DUMMY;


    ! *****SSI
    ! We just had Reserved Operand fault from RET of System service.
    ! It is time to take the entry off, erase what we have done, just
    ! as if nothing ever happened.
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQL EVENT$K_TYPE_SSINT
    THEN
	BEGIN
	LOCAL
	    BIT_15_CNT: REF VECTOR[,BYTE],
	    BIT_15_CNT_SSV: REF VECTOR[,BYTE],
	    USERS_FP: REF BLOCK [,BYTE];

	BIT_15_CNT_SSV = .EVENT_ENTRY [EVENT$L_SSV_COUNT];
	BIT_15_CNT = .EVENT_ENTRY [EVENT$L_FP_RET_CNT];


    	! We have got reserved operand fault.
    	!
	BIT_15_CNT[0] = .BIT_15_CNT[0] - 1;
	USERS_FP = .EVENT_ENTRY [EVENT$L_USERS_FP];


    	! This service is leaving.
    	!
	IF .BIT_15_CNT[0] EQL 0
	THEN
	    BEGIN


    	    ! Get ready to report watched value at T-bit RET time.
    	    !
    	    IF .DBG$GB_SET_SSI_CNT THEN SKIP_WATCHES = TRUE;
	    (USERS_FP [SF$W_SAVE_PSW])<15,1,0> = FALSE;
! Since we only have one entry on the event queue, so there is no need
! to match the nested system calls.
!	    BIT_15_CNT_SSV[0] = .BIT_15_CNT_SSV[0] - 1;

    	    ! Just about to return to the caller.
    	    !
    	    BIT_15_CNT_SSV[0] = 0;

    	    ! Cycle is all done.
    	    !
	    DBG$GB_SET_WATCH_FLAG = FALSE;
	    END

	ELSE


    	    ! Still more left to go.  More levels to go through, for example,
    	    ! SDBG sees it, next TDBG should see it.  Since we only make the
    	    ! reserved operand fault goes through one level, this should never
    	    ! happen.
    	    !
	    (USERS_FP [SF$W_SAVE_PSW])<15,1,0> = TRUE;
	END;


    ! If this entry is a skips-event, remove it from its parent's queue
    ! first.  If its NOT a skips, and the parent queue is not empty, we
    ! have (at the moment) and error...  The parent still has active
    ! offspring.
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SKIPS OR
       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_IGNOR OR
       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SSINT
    THEN
	REMQUE1 (.EVENT_ENTRY)

    ELSE IF .EVENT_ENTRY [EVENT$L_EXC_FLINK] NEQA .EVENT_ENTRY OR
	    .EVENT_ENTRY [EVENT$L_EXC_BLINK] NEQA .EVENT_ENTRY
    THEN
	RETURN;


    ! Remove the entry from the command queue.
    !
    REMQUE (.EVENT_ENTRY, EVENT_ENTRY);


    ! If this is not a STEPS, SKIPS or IGNOR entry....
    !
    IF (.EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_STEPS) AND
       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_SKIPS) AND
       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_IGNOR) AND
       (.EVENT_ENTRY [EVENT$B_CMD_TYPE] NEQU EVENT$K_TYPE_SSINT)
    THEN
	BEGIN


	! If the entry is an access type, release any primary
	! and value descriptor.
	!
	IF .EVENT_ENTRY [EVENT$B_CMD_KIND] EQLU EVENT$K_KIND_ACC
	THEN
	    BEGIN


	    ! Release any page entries.
	    !
	    IF .EVENT_ENTRY [EVENT$B_SUB_KIND] EQLU EVENT$K_ACC_MDFY
	    THEN
		BEGIN
		LOCAL
		    PAGE_LIST :	REF VECTOR [, LONG];


		! Get the pages associated with this value
		!
		IF DBG$NGET_PAGES (.EVENT_ENTRY [EVENT$L_PRIMARY],
				   PAGE_LIST,
				   DUMMY
				  )
		THEN
		    BEGIN


			! While there are entries in the page list, delete a
			! page reference from the page queue.
			!
			DO
			    BEGIN
			    LOCAL
				PAGE_ENTRY :	REF EVENT$PAGE_DESCRIPTOR;


			    ! Search through the existing entries in the page
			    ! queue for this page.
			    !
			    PAGE_ENTRY = .EVENT$PAGE_QUEUE [L_QUEUE_FLINK];
			    WHILE .PAGE_ENTRY NEQA EVENT$PAGE_QUEUE DO
				BEGIN
				IF .PAGE_ENTRY [EVENT$L_PAGE_ADDRESS] EQLA
				   .PAGE_LIST [1]
				THEN


				    ! A match is found, so de-bump the
				    ! reference count, deleting the entry if
				    ! the count goes to zero.
				    !
				    BEGIN
				    PAGE_ENTRY [EVENT$W_PAGE_REF_COUNT] =
					.PAGE_ENTRY [EVENT$W_PAGE_REF_COUNT] - 1;
				    IF .PAGE_ENTRY [EVENT$W_PAGE_REF_COUNT] EQLU 0
				    THEN
					BEGIN
					REMQUE (.PAGE_ENTRY, PAGE_ENTRY);
					DBG$REL_MEMORY (.PAGE_ENTRY);
					EXITLOOP;
					END;

				    END;


				! Not found yet, point to the next one.
				!
				PAGE_ENTRY = .PAGE_ENTRY [EVENT$L_PAGE_FLINK];
				END;

			    PAGE_LIST = .PAGE_LIST [0];
			    END
			WHILE .PAGE_LIST;
			END;
		    END;


	    ! Notify the RST to release symid's.
	    !
	    IF DBG$NGET_SYMID (.EVENT_ENTRY [EVENT$L_PRIMARY],
			       SYMID_LIST,
			       DUMMY
			      )
	    THEN
		DBG$STA_UNLOCK_SYMID (.SYMID_LIST);


	    ! Release the primary descriptor
	    !
	    DBG$NFREE_DESC (.EVENT_ENTRY [EVENT$L_PRIMARY], DUMMY);


	    ! Release any value descriptor.
	    !
	    IF .EVENT_ENTRY [EVENT$V_HAS_VAL_DSCR]
	    THEN
		BEGIN


		! Notify the RST to release symid's.
		!
		IF DBG$NGET_SYMID (.EVENT_ENTRY [EVENT$L_VALDESC],
				   SYMID_LIST,
				   DUMMY
				  )
		THEN
		    DBG$STA_UNLOCK_SYMID (.SYMID_LIST);


		! Release the value descriptor
		!
		DBG$NFREE_DESC (.EVENT_ENTRY [EVENT$L_VALDESC], DUMMY);
		END;
	    END;


	! Release any WHEN Entries.
	!
	WHEN_ENTRY = .EVENT_ENTRY [EVENT$L_WHEN];
	IF .WHEN_ENTRY NEQA 0
	THEN
	    BEGIN


	    ! We have a WHEN entry.  Decrement its reference count.
	    !
	    WHEN_ENTRY [EVENT$L_WHEN_COUNT] =
		.WHEN_ENTRY [EVENT$L_WHEN_COUNT] - 1;


	    ! Delete it if the count goes to 0 (or less !!!).
	    !
	    IF .WHEN_ENTRY [EVENT$L_WHEN_COUNT] LEQU 0
	    THEN
		BEGIN


		! Release the expression buffer.
		!
		DBG$REL_MEMORY (.WHEN_ENTRY [EVENT$L_WHEN_POINT]);


		! Release the WHEN descriptor.
		!
		DBG$REL_MEMORY (.WHEN_ENTRY);
		END
	    END;


	! Release any DO List Entries.
	!
	DO_LIST_ENTRY = .EVENT_ENTRY [EVENT$L_DO];
	IF .DO_LIST_ENTRY NEQA 0
	THEN
	    BEGIN


	    ! We have a DO List entry.  Decrement its reference count.
	    !
	    DO_LIST_ENTRY [EVENT$L_DO_LIST_COUNT] =
		.DO_LIST_ENTRY [EVENT$L_DO_LIST_COUNT] - 1;


	    ! Delete it if the count goes to 0 (or less !!!).
	    !
	    IF .DO_LIST_ENTRY [EVENT$L_DO_LIST_COUNT] LEQU 0
	    THEN
		BEGIN
!    		LOCAL
!    		    PREV_ENTRY: REF EVENT$DO_LIST_DESCRIPTOR,
!    		    NEXT_ENTRY: REF EVENT$DO_LIST_DESCRIPTOR;


		! Release the command buffer.
		!
		DBG$REL_MEMORY (.DO_LIST_ENTRY [EVENT$L_DO_LIST_POINT]);


    		! Unlink this DO_LIST entry from the list. The REMQUE
    		! instruction does the same as the following four lines
    		! (I hope).
    		!
    		! PREV_ENTRY = .DO_LIST_ENTRY [EVENT$L_DO_LIST_BLINK];
    		! NEXT_ENTRY = .DO_LIST_ENTRY [EVENT$L_DO_LIST_FLINK];
    		! PREV_ENTRY [EVENT$L_DO_LIST_FLINK] = .NEXT_ENTRY;
    		! NEXT_ENTRY [EVENT$L_DO_LIST_BLINK] = .PREV_ENTRY;
    		!
    		REMQUE (.DO_LIST_ENTRY, DO_LIST_ENTRY);


		! Release the DO_LIST descriptor.
		!
		DBG$REL_MEMORY (.DO_LIST_ENTRY);
		END;
	    END;
	END;


    ! Release the opcode list.
    !
    IF (.EVENT_ENTRY [EVENT$B_CMD_KIND] EQLU EVENT$K_KIND_INS) AND
       (.EVENT_ENTRY [EVENT$L_OPCODE_LIST] NEQA 0) AND
       (.EVENT_ENTRY [EVENT$L_OPCODE_LIST] NEQA DBG$OPCODES_CALL) AND
       (.EVENT_ENTRY [EVENT$L_OPCODE_LIST] NEQA DBG$OPCODES_BRANCH)
    THEN
    	DBG$REL_MEMORY (.EVENT_ENTRY [EVENT$L_OPCODE_LIST]);


    ! Release Copied FP.
    !
    IF .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_SKIPS OR
       .EVENT_ENTRY [EVENT$B_CMD_TYPE] EQLU EVENT$K_TYPE_STEPS 
    THEN
    	IF .EVENT_ENTRY [EVENT$L_CALL_FRAME] NEQA 0
    	THEN
    	    DBG$REL_MEMORY (.EVENT_ENTRY [EVENT$L_CALL_FRAME]);


    ! Finally, release the Event Entry, itself.
    !
    DBG$REL_MEMORY (.EVENT_ENTRY);
    END;

ROUTINE COMPARE_VMSDESC(DESC1, DESC2) =
!
! FUNCTION
!	Determines whether two VMS descriptors represent the same area
!	of storage. This is used, for example, in processing the SET WATCH
!	command, to determine whether we already have a watchpoint on
!	the given data item.
!
! INPUTS
!	DESC1 - 	Points to a VMS descriptor
!	DESC2 -		Points to a VMS descriptor
!
! OUTPUTS
!	The value TRUE or FALSE is returned.
!
    BEGIN
    MAP
	DESC1: REF DBG$STG_DESC,
	DESC2: REF DBG$STG_DESC;

    LOCAL
	LENGTH1,
	LENGTH2,
	OFFSET1,
	OFFSET2;

    ! Check whether the data given by the descriptors have
    ! the same address.
    !

    IF .DESC1[DSC$B_CLASS] EQL DSC$K_CLASS_UBS
    THEN OFFSET1 = .DESC1[DSC$L_POS] ELSE OFFSET1 = 0;

    IF .DESC2[DSC$B_CLASS] EQL DSC$K_CLASS_UBS
    THEN OFFSET2 = .DESC2[DSC$L_POS] ELSE OFFSET2 = 0;

    IF (.DESC1[DSC$A_POINTER] + .OFFSET1<3,29,1>) NEQ
       (.DESC2[DSC$A_POINTER] + .OFFSET2<3,29,1>)THEN RETURN FALSE;

    IF .OFFSET1<0,3,0> NEQ .OFFSET2<0,3,0> THEN RETURN FALSE;

    ! Compare the lengths.
    ! (Do we really want to do this? The implications are:
    !
    ! SET WATCH ARRAY and SET WATCH ARRAY(1) are two different watchpoints,
    ! since the watched areas have different lengths. This behavior seems
    ! to be correct.
    !
    ! Say X is a byte variable at address 200. Say the default type is LONG.
    ! Then SET WATCH X and SET WATCH 200 will be treated as two different
    ! watchpoints (since one has length 1 and the other has length 4).
    ! This does not seem to be a good thing. This problem could be solved
    ! if we attempted to symbolize the "200" before setting the watchpoint
    ! on it.)
    !
    LENGTH1 = DBG$DATA_LENGTH(.DESC1);
    LENGTH2 = DBG$DATA_LENGTH(.DESC2);
    RETURN .LENGTH1 EQL .LENGTH2;
    END;


ROUTINE GET_WATCH_POINT_VALUE (EVENT : REF EVENT$EVENT_DESCRIPTOR): NOVALUE =
!
! FUNCTION
!
!	This routine gets the new value for a variable that is watched.
!	It does so by converting the Primary in the Event Entry to a 
!	Value Descriptor which contains the value.
!
!	Along the way, this routine checks that the Primary is still
!	valid (i.e., still points to the same storage that it did when
!	the watchpoint was set). If it is not valid, the Primary is 
!	replaced by a Volatile Value Descriptor, and then the watchpoint
!	is on an absolute address instead of a primary expression.
!
! INPUTS
!	EVENT	- Event entry pointer which describes the watchpoint.
!
! OUTPUTS
!	The own variable NEWVALUE is set by this routine. The value in
!	NEWVALUE is then compared to the value in EVENT[EVENT$L_VALDESC]
!	to see if the watched variable has changed (this comparison
!	is done in DBG$EXCEPTION_HANDLER, the called of this routine).
!
    BEGIN
    LOCAL
    	DUMMY,				! Output parameter for subroutines
    	PRIMARY,			! Temporary copy of the Primary
    	SYMID_LIST,			! Symid list for LOCK_SYMID
    	VALDESC: REF DBG$VALDESC,	! Value descriptor with value of Primary
    	V_VALDESC: REF DBG$VALDESC;	! Volatile Value Descriptor


    ! Copy the Primary since PRIM_TO_VAL sometimes has the side effect
    ! of modifying its argument. This copy is done into temporary
    ! memory (fourth parameter is FALSE). Then call PRIM_TO_VAL
    ! and get a Volatile Value Descriptor (this will have
    ! the real address of the watched variable embedded in it).
    !
    DBG$NCOPY_DESC (.EVENT[EVENT$L_PRIMARY], PRIMARY, DUMMY, FALSE);
    INVALID_FLAG = FALSE;
    PRIM_TO_VAL (.PRIMARY, DBG$K_V_VALUE_DESC, V_VALDESC);


    ! Check whether the Primary is still valid, i.e., whether it still
    ! points to the same storage as it did when the watchpoint was set.
    !
    IF .INVALID_FLAG OR 
       CH$NEQ (12, V_VALDESC[DBG$A_VALUE_VMSDESC], 12, EVENT[EVENT$A_VMSDESC])
    THEN
    	BEGIN


    	! Print an informational saying the Primary is no longer valid.
    	!
        DBG$PRINT ($AC ('%DEBUG-I-WATCHVAR, watched variable '));
        DBG$PRINT_IDENTIFIER(.EVENT[EVENT$L_PRIMARY]);
    	IF .INVALID_FLAG
    	THEN
    	    DBG$PRINT ($AC (' has gone out of scope'))
    	ELSE
            DBG$PRINT ($AC (' now points to a different address'));
    	DBG$NEWLINE();


    	! Free up the old Primary.
    	!
    	IF DBG$NGET_SYMID (.EVENT[EVENT$L_PRIMARY], SYMID_LIST, DUMMY)
    	THEN
    	    DBG$STA_UNLOCK_SYMID (.SYMID_LIST);
    	DBG$NFREE_DESC (.EVENT[EVENT$L_PRIMARY], DUMMY);    	 


    	! Replace it with the Volatile Value Descriptor.
    	!
    	V_VALDESC = DBG$MAKE_VAL_DESC(EVENT[EVENT$A_VMSDESC], DBG$K_V_VALUE_DESC);
    	V_VALDESC[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    	IF DBG$NGET_SYMID (.V_VALDESC, SYMID_LIST, DUMMY)
    	THEN
    	    DBG$STA_LOCK_SYMID (.SYMID_LIST);
        DBG$NCOPY_DESC (.V_VALDESC, EVENT[EVENT$L_PRIMARY], DUMMY, TRUE);
    	END;


    ! Build a Value Descriptor.
    ! Then copy the value descriptor into permanent memory.
    ! This is needed so that the storage stays around even if we
    ! execute DO clauses on the watchpoint (which may in turn
    ! cause calls to REL_TEMPMEM).
    ! The memory for NEWVALUE is freed up in DBG$EXCEPTION_HANDLER
    ! when it is finished with the Value Descriptor.
    !
    DBG$PRIM_TO_VAL(.V_VALDESC, DBG$K_VALUE_DESC, VALDESC);
    DBG$NCOPY_DESC (.VALDESC, NEWVALUE, DUMMY, TRUE);
    RETURN 0;
    END;

ROUTINE PRIM_TO_VAL (PRIM_DESC, TARGET_TYPE, VAL_DESC) : NOVALUE =
!
! FUNCTION
!	This routine is a cover routine for DBG$PRIM_TO_VAL. It 
!	establishes a handler to catch error signals from DBG$PRIM_TO_VAL,
!	and then calls DBG$PRIM_TO_VAL to do the work.
!
! INPUTS
!	See DBG$PRIM_TO_VAL in DBGVALUES.
!
! OUTPUTS
!	See DBG$PRIM_TO_VAL in DBGVALUES.
!
    BEGIN
    ENABLE
    	PRIM_TO_VAL_HANDLER;
    DBG$PRIM_TO_VAL (.PRIM_DESC, .TARGET_TYPE, .VAL_DESC);
    END;

ROUTINE PRIM_TO_VAL_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This is the error handler for the routine PRIM_TO_VAL. If
!	an error occurs during the evaluation of a Primary then this
!	routine is invoked and it sets the own variable INVALID_FLAG 
!	to indicate that the Primary is now invalid.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector (EVENT pointer is passed in
!		from here).
!
! OUTPUT
!	The OWN variable INVALID_FLAG is set to TRUE.
!
    BEGIN
    MAP
    	ENBLARG: REF VECTOR[,LONG],
    	SIGARG: REF VECTOR[,LONG];


    ! If we were unwinding, continue unwinding.
    !
    IF .SIGARG[1] EQL SS$_UNWIND 
    THEN 
    	RETURN SS$_CONTINUE;


    ! Set the OWN flag saying the Primary is invalid.
    !
    INVALID_FLAG = TRUE;


    ! Unwind to the caller of PRIM_TO_VAL.
    !
    SETUNWIND();
    RETURN 0;
    END;

ROUTINE PARSE_WHEN_CONDITION(EVENT): NOVALUE =
!
! FUNCTION
!	This routine calls the parser to parse the when condition.
!	If any error occurs during the parsing, final handler catches
!	the error message, announce the message, WHEN_CONDITION is set 
!	to FALSE in this case, Break point remains set.
!
! INPUTS
!	EVENT	- The address of the event_entry.
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
    	EVENT: REF EVENT$EVENT_DESCRIPTOR;  ! Event entry pointer

    BUILTIN CALLG;

    LOCAL
    	CONDITION,			    ! local when condition value
	CONDITION_VAL :	    DBG$STG_DESC,   ! Condition Value Descr
	CONDITION_STR :	    DBG$STG_DESC,   ! Condition String Descr
	CONDITION_TXT :	    REF VECTOR [, WORD], ! Condition text
	CONDITION_RDX,			    !    radix
	MESSAGE_VECT,			    ! Message Vector
	WHEN_ENTRY :	REF EVENT$WHEN_DESCRIPTOR;  ! WHEN Descriptor

    ENABLE
    	DBG$FINAL_HANDL;


    ! Assume WHEN condition is always true to begin with, so just in
    ! case, bad things happened during the calls to other routine,
    ! break point is still taken.
    !
    WHEN_CONDITION = TRUE;


    ! Point to the WHEN entry.
    !
    WHEN_ENTRY = .EVENT [EVENT$L_WHEN];


    ! Point to the WHEN expression.
    !
    CONDITION_TXT = .WHEN_ENTRY [EVENT$L_WHEN_POINT];


    ! Set up the condition descriptors.
    !
    CONDITION_STR [DSC$B_CLASS] = DSC$K_CLASS_S;
    CONDITION_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    CONDITION_STR [DSC$W_LENGTH] = .CONDITION_TXT [0];
    CONDITION_STR [DSC$A_POINTER] = CONDITION_TXT [1];

    ! Set up some globals that C uses for purposes of preseving the
    ! original casing.
    !
    IF .DBG$GB_LANGUAGE EQL DBG$K_C
    THEN
    	BEGIN
        DBG$GL_ORIG_COMMAND_PTR = CONDITION_TXT [1];
        DBG$GL_UPCASE_COMMAND_PTR[0] = CONDITION_TXT [1];
        DBG$GL_UPCASE_COMMAND_PTR[1] = CONDITION_TXT[1] + .CONDITION_TXT[0] - 1;
    	END;

    ! Determine the current radix.
    !
    CONDITION_RDX = .DBG$GB_RADIX[DBG$B_RADIX_INPUT];


    ! Obtain a value descriptor for the condition.
    !
    IF NOT DBG$NPARSE_EXPRESSION
		(CONDITION_STR,
		 .CONDITION_RDX,
		 CONDITION,
		 TOKEN$K_TERM_NONE,
		 MESSAGE_VECT
		)
    THEN
	CALLG (.MESSAGE_VECT, LIB$SIGNAL);


    ! Set up the vax descriptor for the condition.
    ! For now, we just declare the descriptor to be longword integer,
    ! since this causes the fewest problems in the type converter. 
    ! Eventually, if we get a Boolean type and all languages support
    ! it then we will build a target descriptor of this type.
    !
    CONDITION_VAL [DSC$B_CLASS] = DSC$K_CLASS_S;
    CONDITION_VAL [DSC$B_DTYPE] = DSC$K_DTYPE_L;
    CONDITION_VAL [DSC$W_LENGTH] = 4;
    CONDITION_VAL [DSC$A_POINTER] = WHEN_CONDITION;
    CONDITION_VAL [DSC$L_POS] = 0;


    ! Special case for PASCAL. PASCAL returns descriptors
    ! of type Boolean (dsc$k_dtype_tf) for relational expressions.
    !
    IF .DBG$GB_LANGUAGE EQL DBG$K_PASCAL
    THEN
    	BEGIN
    	CONDITION_VAL [DSC$B_DTYPE] = DSC$K_DTYPE_TF;
    	CONDITION_VAL [DSC$W_LENGTH] = 1;
    	END;


    ! Do the conversion from value descriptor to integer.  NOTE THAT
    ! I'M REUSING THE DESCRIPTOR, AND CONDITION LONGWORD.
    !
    IF NOT DBG$NTYPE_CONV (.CONDITION,
			   DBG$K_DEFAULT,
			   DBG$K_VAX_DESC,
			   CONDITION_VAL,
			   MESSAGE_VECT
			  )
    THEN 
	CALLG (.MESSAGE_VECT, LIB$SIGNAL);

    RETURN 0;
    END;


ROUTINE MATCH_RIGHT_CALL_FRAME(EVENT) =
!
! FUNCTION
!	This routine is used to match the exact call frame at the time
!       we set bit 15, or turn off bit 15 in saved PSW and the time we got 
!	reserved operand fault.
!
!	For FP pointer may be changed inside of the call by the called
!       routine.  So to be safe, we don't just compare the pointers, we
!       check some call frame contents as well.
!
! INPUTS
!	Event entry for the event we consister.
!
! OUTPUTS
!	True for Yes, this is the frame caused the event,
!	Fasle for No, this is not the frame caused the event.
!

    BEGIN
    MAP
    	EVENT: REF EVENT$EVENT_DESCRIPTOR;

    LOCAL
	CALL_FRAME: REF BLOCK[,BYTE],	! Pointer to FP
    	CALL_MASK: WORD,		! Mask in Call frame
	RUN_FRAME: REF BLOCK[,BYTE],	! FP was saved in DEBUG run frame
    	RUN_MASK: WORD;			! Mask in current FP


    ! If there is no FP existed, simply returns.
    !
    IF .EVENT [EVENT$L_USERS_FP] EQL 0 THEN RETURN FALSE;

    ! Dig out current FP from DEBUG runframe.
    !
    RUN_FRAME = .DBG$RUNFRAME [DBG$L_USER_FP];

    ! If the call frame saved in event entry is the same as current FP,
    ! got it, no problem.
    !
    IF .EVENT [EVENT$L_USERS_FP] EQL .RUN_FRAME
    THEN
    	RETURN TRUE;

    ! Need to do further investigation.  Dig out the contents of the call
    ! frame was saved from Call frame.
    !
    CALL_FRAME = .EVENT [EVENT$L_CALL_FRAME];
    IF .CALL_FRAME EQL 0 THEN RETURN FALSE;

    ! Compare the mask.  But don't compare the stack alignment, compare
    ! register mask and calls flag.  Compare saved AP, and FP.
    !
    CALL_MASK = .CALL_FRAME[SF$W_SAVE_MASK];
    RUN_MASK = .RUN_FRAME[SF$W_SAVE_MASK];
    CALL_MASK = .CALL_MASK AND %X'7FFF';
    RUN_MASK = .RUN_MASK AND %X'7FFF';
    IF (.CALL_MASK EQL .RUN_MASK) AND
       (.CALL_FRAME[SF$L_SAVE_AP] EQL .RUN_FRAME[SF$L_SAVE_AP]) AND
       (.CALL_FRAME[SF$L_SAVE_FP] EQL .RUN_FRAME[SF$L_SAVE_FP])
    THEN
    	BEGIN

    	! Got it, update the FP to current FP.  So we can set/clear bit 15
    	! in saved PSW in the correct FP.
    	!
    	EVENT [EVENT$L_USERS_FP] = .RUN_FRAME;
    	RETURN TRUE;
    	END
    ELSE
    	RETURN FALSE;

    END;

END				! End of module

ELUDOM
