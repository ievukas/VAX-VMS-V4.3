MODULE RM3DELETE (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!	This module handles the deletion of index sequential records.
!
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Todd M. Katz	     CREATION DATE:     14-Jul-1982
!
!
! MODIFIED BY:
!
!	V03-025	JWT0181		Jim Teague		15-May-1984
!		RM$SQUISH moves too many bytes when squishing the
!		the data portion out of deleted records.
!
!	V03-024	DAS0001		David Solomon		25-Mar-1984
!		Fix broken branch to RM$RU_JOURNAL3.
!
!	V03-023	MCN0003		Maria del C. Nasr	04-Apr-1983
!		Change linkage of RM$NULLKEY to RL$JSB.
!
!	V03-022	TMK0013		Todd M. Katz		26-Mar-1983
!		Change the linkage for RM$RU_JOURNAL3 from RL$RABREG_467 to
!		RL$RABREG_67.
!
!	V03-021 MCN0002		Maria del C. Nasr	24-Mar-1983
!		More linkages reorganization.
!
!	V03-020	RAS0135		Ron Schaefer		17-mar-1983
!		Fix spelling of RJR$_DELET -> RJR$_DELETE.
!
!	V03-019	TMK0012		Todd M. Katz		16-Mar-1983
!		Change the linkage for RM$RU_JOURNAL3 from RL$RABREG_67 to
!		RL$RABREG_467.
!
!	V03-018	TMK0011		Todd M. Katz		16-Mar-1983
!		Change the symbol RMSR$_DELET to RJR$_DELET.
!
!	V03-017 MCN0001		Maria del C. Nasr	24-Feb-1983
!		Reorganize linkages
!
!	V03-016	TMK0010		Todd M. Katz		08-Jan-1983
!		Add support for Recovery Unit Journalling and RU ROLLBACK
!		Recovery of ISAM files. This support includes:
!
!		1. The restructuring of RM$DELETE3B so that the primary data
!		   record is unpacked and available for RU journalling before
!		   any part of the file is permanently modified.
!
!		2. The RU Journalling of all $DELETEs which occur on RU 
!		   Journalled files within Recovery Units.
!
!		3. Modifications to RM$DELETE_RRV, RM$SQUISH_SIDR, and 
!		   RM$DELETE_UDR so that no space is reclaimed when records of
!		   RU journalled files are $DELETEd within Recovery Units. The
!		   RRV, primary data record, or SIDR array element is just 
!		   marked RU_DELETE instead.
!
!		4. Modifications to RM$DELETE_RRV, RM$SQUISH_SIDR, and
!		   RM$DELETE_UDR so that RRVs, primary data records and SIDR 
!		   array elements maybe un-deleted during ROLLBACK of 
!		   prematurely terminated or aborted Recovery Units.
!
!		5. The addition of a second parameter (SCAN) to RM$SQUISH_SIDR. 
!		   If this parameter is 1 on entry, RMS will scan the entire 
!		   SIDR array looking for non-deleted elements even if no 
!		   duplicates are allowed in the key of reference. If SCAN is 0
!		   RMS will immediately delete the entire SIDR as was the case
!		   previously.
!
!	V03-015	TMK0009		Todd M. Katz		05-Jan-1983
!		The routine RM$DELETE_SIDR no longer calls the routine
!		RM$FND_SDR_ARRY to position to the SIDR element it is to
!		delete. It now performs its own positioning.
!
!	V03-014	TMK0008		Todd M. Katz		07-Dec-1982
!		Change the order in which the various parts of a record are
!		deleted during a $DELETE. First, eliminate the RRV. Next
!		eliminate the user data record. Finally, the alternate keys
!		which are represented in the primary data record are removed.
!		Previously, the SIDRs were eliminated before the primary data
!		record, and during this time a lock was kept on the the primary
!		data bucket. This meant that a bucket lock was being held for 
!		quite a long time, and that the routine that positioned to a
!		primary data record by means of an alternate index had to be
!		enhanced with a very complex and very large SIDR re-positioning
!		routine, so that the 1.5 SIDR deadlock case would not exist in
!		version 4. Changing the order of events that take place during
!		a $DELETE allowed a change in the bucket lock strategy which
!		had the dual benefits of eliminating the 1.5 SIDR deadlock
!		case without the expensive SIDR re-positioning code, and 
!		reducing the amount of time a lock on the primary data bucket
!		is kept to a minimum - which is an overall ISAM design goal.
!
!		This change is not without its cost. The reason why the old
!		strategy was orginally implemented, was so that the primary
!		data record would be available for the extraction of the 
!		alternate keys so that the corresponding SIDRs could be 
!		eliminated. Changing the bucket locking strategy such that
!		the primary data record is deleted and the bucket is released
!		before the SIDRs are deleted means that the primary data record
!		must be saved in an auxillary record buffer before it is deleted
!		so that it will be available for alternate key extraction.
!		However, this change is not as expensive as it might seem 
!		because if the file's prologue version is 3, the primary data
!		record would have to be unpacked into this same record buffer
!		before the keys could be extracted anyway. Thus, it was a
!		simple matter of unpacking either sooner or later. Any 
!		additional cost incurred by this new strategy is born solely by
!		prologue 1 and 2 files which previously could extract the 
!		alternate keys without moving the primary data record, and now
!		must perform an additional MOVC3. However, the benefits derived
!		from this new strategy more than outweigh the cost of this
!		additional MOVC3 required in the case of a prologue version
!		which will hopefully fade out of use.
!
!	V03-013	TMK0007		Todd M. Katz		06-Dec-1982
!		The routine RM$SQUISH_SIDR was recovering the space occupied
!		by a SIDR whenever duplicates were allowed and all the elements 
!		in the SIDR were deleted even if the SIDR occupied the 
!		physically last position in the SIDR bucket. This had the 
!		possibility of creating totally empty SIDR buckets, and the 
!		encountering of a totally empty SIDR bucket during a 
!		positioning for insertion when duplicates are allowed can not 
!		always be correctly handled. Thus, a bug existed in the 
!		$DELETE code which had capability of corrupting SIDR indicies. 
!
!		To fix this code I have decided that the space occupied by the
!		physically last SIDR in the bucket can never be recovered even
!		if all the elements in the array are deleted when duplicates
!		alternate keys are allowed. At best, if the file is a prologue 
!		3 file, and the element is not the first element in the SIDR 
!		array, the space occupied by the RRV pointer can be recovered. 
!		This fix which I have implemented by re-writing the routine 
!		RM$SQUISH_SIDR (both to implement the fix and to optimize the
!		existing code) guarentees both that empty SIDR buckets can 
!		never be created when duplicate SIDRs are allowed, and that NRP 
!		positioning context is maintained.
!
!	V03-012	TMK0006		Todd M. Katz		14-Nov-1982
!		The routine RM$DELETE_UDR no longer has to return a value.
!		Previously, it was returning a value because the routine that
!		was responsible for reclaiming space occupied by records that
!		were just marked deleted needed to know whether or no an
!		RRV had been created in the place of the reclaimed record.
!		This is no longer the case, as that routine has been modified
!		to no longer require this piece of information.
!
!	V03-011	TMK0005		Todd M. Katz		12-Nov-1982
!		The routine RM$FND_SDR_ARRY requires as implicit input the key
!		size of the SIDR it is to position to in IRB$B_KEYSZ. The
!		routine RM$DELETE_SIDR was not setting up the IRAB cell with
!		the key size before calling this routine. Therefore, the 
!		possibility existed that RM$FND_SDR_ARRY would position to
!		the wrong SIDR array, which would then be deleted. This in fact
!		has been seen, during the course of an $UPDATE when the old 
!		SIDRs that have been changed are removed, and this fix corrects
!		this problem.
!
!	V03-010	TMK0004		Todd M. Katz		11-Nov-1982
!		When SIDRs must be deleted and the file is a prologue 3 file,
!		the record must be unpacked so that the alternate keys can be
!		extracted. If RMS positioned by the primary key of reference
!		then it will already have a fully expanded copy of the primary 
!		key in keybuffer 1, and it can use this in the unpacking of the
!		record instead of scanning the bucket to re-expand the primary
!		key when primary key compression is enabled. There is one
!		case when it can not use the primary key in keybuffer 1 like
!		this, and that is when the record being deleted is not the same
!		as the current primary data record. This happens when RMS 
!		randomly $FINDs a record since this operation does not update 
!		the NRP conext. I was not checking for this case and this fix 
!		remedies this.
!
!	V03-009	TMK0003		Todd M. Katz		06-Oct-1982
!		When I completely re-wrote this routine (TMK0001), I broke
!		the deletion of prologue 3 fixed length records, in certain 
!		cases, because I had assummed that all prologue 3 records 
!		included as part of their record overhead a record size field
!		that needs to be updated when the portion of the prologue 3
!		primary data record occupied by the data is reclaimed. I thought
!		I had fixed this in TMK0002 (although I forgot to mention it in
!		the audit trial), but actually all I did was fix one $DELETE 
!		case and break others that occur more frequently. What I did 
!		was to make the assunmption that all fixed length prologue 3 
!		records do not include a record size field. This too is 
!		incorrect. Actually, if a prologue 3 record with fixed length
!		records has either key or data compression (or both) enabled,
!		then there is a record size field present as part of the
!		record overhead. If both compression types are disabled and the
!		record is fixed size then there is no need for a record size
!		field and one is not present. I was not checking any compression
!		bits, but rather, just for a fixed length record format, before
!		deciding whether or there was a record size field to update and 
!		this is what caused the problem in TMK0002.
!
!	V03-008	TMK0002		Todd M. Katz		04-Sep-1982
!		Add support for prologue 3 SIDRs. This involves changes
!		only to the routine RM$SQUISH_SIDR.
!
!		The field IRB$B_SRCHFLAGS is now a word. Change all references
!		to it.
!
!	V03-007	KBT0162		Keith B. Thompson	21-Aug-1982
!		Reorganize psects
!
!	V03-006	TMK0001		Todd M. Katz		02-Jul-1982
!
!		New version of $DELETE. This module now incorporates all
!		the routines which were formerly in RM3DELSDR.
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! Define default PSECTS for code.
!
PSECT
    CODE = RM$RMS3(PSECT_ATTR),
    PLIT = RM$RMS3(PSECT_ATTR);

! Linkages.
!
LINKAGE
    L_ERROR_LINK1,
    L_JSB,
    L_JSB01,
    L_LINK_7_10_11,
    L_PRESERVE1,
    L_RABREG,
    L_RABREG_4567,
    L_RABREG_567,
    L_RABREG_67,
    L_RABREG_7,
    L_REC_OVHD,
    L_SIDR_FIRST,

    ! Local Linkage
    !
    RL$DEL_ALL_SIDR = JSB ()
	 	    : GLOBAL (R_REC_ADDR,R_IDX_DFN,COMMON_RABREG),
    RL$SQUISH_DATA = JSB ()
	 	   : GLOBAL(R_REC_ADDR,R_BKT_ADDR,R_IDX_DFN,R_IFAB);

! External Routines
!
EXTERNAL ROUTINE
    RM$CLEAN_BDB	: RL$ERROR_LINK1,
    RM$CSEARCH_TREE	: RL$RABREG_67,
    RM$EXPAND_KEYD	: RL$JSB01,
    RM$EXT_ARRY_RFA	: RL$RABREG_67,
    RM$FIND_BY_ID	: RL$RABREG_567,
    RM$GET_NEXT_KEY	: RL$LINK_7_10_11,
    RM$GETNXT_ARRAY	: RL$RABREG_67,
    RM$KEY_DESC		: RL$RABREG_7,
    RM$MOVE		: RL$PRESERVE1,
    RM$NULLKEY		: RL$JSB,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$RECORD_ID	: RL$RABREG_67,
    RM$RECORD_KEY	: RL$PRESERVE1,
    RM$RECORD_VBN	: RL$PRESERVE1,
    RM$RLSBKT		: RL$PRESERVE1,
    RM$RU_JOURNAL3	: RL$RABREG_67 ADDRESSING_MODE( LONG_RELATIVE ),
    RM$SIDR_END		: RL$RABREG_67,
    RM$SIDR_FIRST	: RL$SIDR_FIRST,
    RM$UNPACK_REC	: RL$JSB01,
    RM$UPDDELCOM	: RL$RABREG_67;

! Forward Routines
!
FORWARD ROUTINE
    RM$DELETE_RRV	: RL$RABREG_4567,
    RM$DELETE_SIDR	: RL$RABREG_7,
    RM$DELETE_UDR	: RL$RABREG_4567  NOVALUE,
    RM$SQUISH_DATA	: RL$SQUISH_DATA NOVALUE,
    RM$SQUISH_SIDR	: RL$RABREG_567;

%SBTTL	'RM$DEL_ALL_SIDR'
ROUTINE	RM$DEL_ALL_SIDR (RECORD_SIZE) : RL$DEL_ALL_SIDR NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	The purpose of this routine is to delete every SIDR array element
!	pointing to the the current primary data record. Towards this goal
!	every secondary key represented in the current primary data record
!	is in turn extracted from the current primary data record which has 
!	been saved (in an unpacked form if prologue 3) in a record buffer, used 
!	to position to the SIDR array element pointing to the current primary 
!	data record in the appropriate index, and that array element is 
!	deleted. If the current primary data record does not possess one or 
!	more secondary keys either because the record is not of sufficient size 
!	or the key is null, or if a fast delete is requested and duplicates of 
!	one or more secondary keys are allowed, then the deletion of those 
!	secondary keys are bypassed.
!
! CALLING SEQUENCE:
!
!	RM$DEL_ALL_SIDR()
!
! INPUT PARAMETERS:
!
!	RECORD_SIZE		- size of the user data record in IRB$L_RECBUF
!
! IMPLICIT INPUTS:
!
!	IDX_DFN				- index descriptor for the primary key
!
!	IFAB				- address of the IFAB
!	    IFB$W_KBUFSZ		- size of each of the keybuffers
!	    IFB$B_PLG_VER		- prologue version of the file
!
!	IRAB				- address of the IRAB
!	    IRB$L_KEYBUF		- address of the contigious keybuffers
!	    IRB$L_RECBUF		- address of record unpacking buffer
!
!	RAB				- address of the RAB
!	    RAB$V_FDL			- if set, fast-delete requested
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!
!	AP and REC_ADDR are trashed.
!	Keybuffer 2 contains the key of the last SIDR deleted.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    LABEL
	BLOCK;

    ! Delete all of the secondary keys present in the current user data record.
    !
    WHILE RM$GET_NEXT_KEY()
    DO

	! Each secondary key in the file will in turn become the "current"
	! secondary key for the purpose of deleting its representative in the
	! current primary data record from the appropriate index.
	!
BLOCK:	BEGIN

	! If a fast-delete is requested, terminate the deletion of the current
	! secondary key only if this secondary key allows duplicates. If this 
	! secondary key does not allow duplicates, then a fast delete of it can
	! not be done, since the error caused by a later attempt to insert a 
	! record with a secondary key that is a duplicate of this one would go
	! undetected. 
	!
	IF .RAB[RAB$V_FDL] 
	    AND 
	   .IDX_DFN[IDX$V_DUPKEYS]
	THEN
	    LEAVE BLOCK;

	! Check that the current primary data record is of a sufficient size to
	! include the current secondary key. If it is not, terminate the 
	! deletion process for this secondary key.
	!
	IF .RECORD_SIZE<0, 16> LSSU .IDX_DFN[IDX$W_MINRECSZ]
	THEN
	    LEAVE BLOCK;

	! In preparation for positioning to the SIDR array element for this
	! secondary key of the current primary data record, the secondary key 
	! must be extracted into keybuffer 2. 
	!
	REC_ADDR = .IRAB[IRB$L_RECBUF];

	! If this secondary key for the current primary data record is null, 
	! there will not be a SIDR array element in this index pointing to the
	! current primary data record. Therefore, there is no need to continue
	! with the process of deleting the current secondary key's 
	! representative in the current primary data record.
	!
	AP = 0;
	IF NOT RM$NULLKEY (.REC_ADDR)
	THEN
	    LEAVE BLOCK;

	! Extract out the current secondary key from the current primary data
	! record, and place it in keybuffer 2.
	!
	AP = 3;

	BEGIN

	GLOBAL REGISTER
	    R_BDB;

	RM$RECORD_KEY (KEYBUF_ADDR(2));
	END;

	! Position to and delete the SIDR array element pointing to the current
	! primary data record for this secondary key from the file.
	!
	RM$DELETE_SIDR();
	END;

    END;

%SBTTL	'RM$DELETE3B'
GLOBAL ROUTINE RM$DELETE3B : RL$RABREG =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine directs the deletion of the current primary data record.
!	To establish a current record, a $GET or $FIND is done. Fast delete
!	(SIDR entries are not deleted) can only take place when duplicates are
!	allowed. This is because allowing SIDR entries to not be deleted when
!	duplicates were not allowed, would mean that the the error condition 
!	"inserting duplicate when not allowed" could not be detected.
!
!	The steps involved in deleting the current record are as follows:
!
!	1. If the file defines alternate keys or is being RU Journalled, save 
!	   the primary data record in a record buffer. If the file is a 
!	   prologue 3 file then the primary data record will be saved in 
!	   unpacked format.
!
!	2. Delete the RRV. The space it occupies maybe completely reclaimed
!	   if the file is a prologue 3 file; otherwise, just the space
!	   occupied by the RRV pointer is recovered.
!
!	3. Delete the user data record. This may involve just marking it 
!	   deleted, eliminating just the data portion (prologue 3 only), or 
!	   eliminating the entire record depending upon the prologue version
!	   of the file, whether duplicate primary keys are allowed, and whether
!	   this primary data record is physically the last record in the primary
!	   data bucket.
!
!	4. Delete all secondary keys (unless fast delete is set and duplicates
!	   are allowed). The SIDR will be completely deleted if duplicates
!	   are not allowed, but if duplicates are allowed the SIDR element will
!	   just be marked deleted and the space occupied by the RRV pointer
!	   reclaimed if the file is a prologue 3 file.
!
!	NOTE: If this operation is occurring on a RU Journalled file within a
!	      recovery unit then the RRV, primary data record, and all SIDR
!	      elements are marked IRC$V_RU_DELETE and no space is reclaimed.
!
! CALLING SEQUENCE:
!
!	RM$DELETE3B()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IFAB			- address of IFAB
!	    IFB$B_NUM_KEYS	- number of keys in the file
!	    IFB$B_PLG_VER	- prologue version of the file
!	    IFB$V_RUP		- if set, Recovery Unit is in progress
!
!	IRAB			- address of IRAB
!	    IRB$B_CUR_KREF	- current positioning key of reference
!	    IRB$W_POS_ID	- ID of positioning primary data record
!	    IRB$L_POS_VBN	- VBN of positioning primary data record
!	    IRB$L_RECBUF	- address of record buffer
!	    IRB$W_UDR_ID	- ID of current primary data record
!	    IRB$L_UDR_VBN	- VBN of current primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB 
!	    IRB$V_FIND_LAST	- 0, last operation was not a $FIND
!	    IRB$V_PUTS_LAST 	- 0, last operation was not a $PUT
!	    IRB$V_UPDATE	- 0, last operation was not an $UPDATE
!
! ROUTINE VALUE:
!
!	CUR		- illegal or no current record
!	RNL		- current record not locked
!	SUC		- record successfully deleted
!	various I/O errors
!
! SIDE EFFECTS:
!
!	If record locking is unneccessary the record locks are not checked for.
!	If automatic locking is not specified, the then the deleted record is 
!		not unlocked.
!	If automatic locking is required, then the current primary data record
!		is always unlocked, on success or failure.
!	If the current process is within a Recovery Unit, and the file is being 
!		Recovery Unit Journalled, then the operation is RU Journalled
!		before any permanent modification to the file takes place
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	COMMON_RAB_STR;

    GLOBAL REGISTER
	COMMON_IO_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    LOCAL
	RECORD_SIZE;

    ! Perform checks common to both $UPDATE and $DELETE such as making sure 
    ! there is a current record and that it is locked, and then find the 
    ! current record by means of its RFA address. This will access both the
    ! bucket containing the current record and the bucket containing the 
    ! current record's RRV, if it has one. The address of the BDB for the 
    ! current record bucket will be returned in IRB$L_CURBDB, and the address 
    ! of the BDB for the RRV bucket will be returned in IRB$L_NXTBDB.
    !
    IRAB[IRB$V_UPDATE] = 0;

    RETURN_ON_ERROR (RM$UPDDELCOM());

    ! Retrieve the index descriptor for the primary key.
    !
    RM$KEY_DESC (0);

    ! If the file contains alternate keys, then save the primary data record
    ! (in unpacked format if the file's prologue version is 3), in a record
    ! buffer so that the primary data record maybe deleted, and the record will
    ! still available. This is so that the alternate keys maybe extracted from 
    ! it at a later time to be used in the deletion of the corresponding SIDRs.
    !
    ! If the process is within a recovery unit and the file is being RU 
    ! Journalled, then unpack the primary data record regardless of whether or
    ! not the file defines alternate keys.
    ! 
    IF  .IFAB[IFB$B_NUM_KEYS] GTRU 1
	 OR
	.IFAB[IFB$V_RUP]
    THEN
	BEGIN

	LOCAL
	    REC_SIZE,
	    SAVE_REC_ADDR	: REF BBLOCK;

	! Retrieve the size of the current primary data record, and position
	! past the record overhead to the user data record itself.
	!
	SAVE_REC_ADDR = .REC_ADDR;
	REC_ADDR = .REC_ADDR + RM$REC_OVHD(0; REC_SIZE);
	RECORD_SIZE = .REC_SIZE;

	! If the file is a prologue 3 file, then the current primary data 
	! record must be unpacked into the record buffer
	!
	IF .IFAB[IFB$B_PLG_VER] GEQU  PLG$C_VER_3
	THEN
	    BEGIN

	    ! If the record is in a special format, then retrieve the true size
	    ! of the record from the last two bytes in the record's reserved
	    ! space.
	    !
	    IF .SAVE_REC_ADDR[IRC$V_RU_UPDATE]
	    THEN
		RECORD_SIZE = .(.REC_ADDR + .RECORD_SIZE 
					  - IRC$C_DATSZFLD)<0,16>;

	    ! As part of the process of unpacking the current primary data
	    ! record, RMS must extract the primary key from its position in 
	    ! front of the rest of the data record, re-expand it if it is 
	    ! compressed, and re-integrate it. If the current NRP positioning 
	    ! key of reference is the primary key, then when RMS positioned to 
	    ! the current primary data record it extracted its primary key into 
	    ! keybuffer 1 where it serves as part of the local NRP context. If 
	    ! this is indeed the case, then signal the data record unpacking 
	    ! routine that the primary key for this data record maybe found in 
	    ! keybuffer 1, and that there is no need to again extract and 
	    ! re-expand the primary key as part of the unpacking process; 
	    ! otherwise, signal that the entire unpacking process must be gone 
	    ! through. 
	    !
	    ! There is one case when RMS must signal that the entire unpacking 
	    ! process must be gone through even though the primary key is the
	    ! current key of reference. This is when RMS positioned to the 
	    ! record by means of a random $FIND. This type of operation does 
	    ! not update the NRP context.
	    !
	    IF (.IRAB[IRB$B_CUR_KREF] EQLU 0)
	        AND
	       (.IRAB[IRB$W_POS_ID] EQLU .IRAB[IRB$W_UDR_ID])
	        AND
	       (.IRAB[IRB$L_POS_VBN] EQLU .IRAB[IRB$L_UDR_VBN])
	    THEN
		AP = 1
	    ELSE
		AP = 0;

	    RECORD_SIZE = RM$UNPACK_REC (.IRAB[IRB$L_RECBUF], .RECORD_SIZE);

	    ! If this file is being RU Journalled (Only Prologue 3 files are
	    ! journalled), and the current process is within a Recovery Unit,
	    ! then RU Journal the current operation and set the state bit
	    ! IRB$V_RU_DELETE ao that the deletions are done such that no space
	    ! at all is reclaimed.
	    !
	    IF .IFAB[IFB$V_RUP]
	    THEN
		BEGIN
		REC_ADDR = .IRAB[IRB$L_RECBUF];
		RETURN_ON_ERROR (RM$RU_JOURNAL3 (RJR$_DELETE, 
						 .IRAB[IRB$L_UDR_VBN],
						 .IRAB[IRB$W_UDR_ID],
						 .RECORD_SIZE),
				 RM$CLEAN_BDB());
		IRAB[IRB$V_RU_DELETE] = 1;
		END;
	    END

	! If the file is a prologue 1 or 2 file, then just move the primary data
	! record into the record buffer.
	!
	ELSE
	    RM$MOVE (.RECORD_SIZE, .REC_ADDR, .IRAB[IRB$L_RECBUF]);

	! Position back to the beginning of the primary data record - to the
	! first byte of the current primary data record's overhead.
	!
	REC_ADDR = .SAVE_REC_ADDR;
	END;

    ! If the current record is not in its original bucket, process the RRV for
    ! the current record. For prologue 3 files this involves deleting the RRV
    ! entirely. For all other files, just the space occupied by the RRV pointer
    ! to the current record is reclaimed. This means that the current record 
    ! can no longer be found through its secondary keys or by RFA access.
    !
    IF (BDB = .IRAB[IRB$L_NXTBDB]) NEQ 0
    THEN
	BEGIN
	IRAB[IRB$L_NXTBDB] = 0;
	RETURN_ON_ERROR (RM$DELETE_RRV(), BEGIN
					  IRAB[IRB$V_RU_DELETE] = 0;
					  RELEASE (IRAB[IRB$L_CURBDB]);
					  END);
	END;

    ! Delete the current primary data record, mark the bucket dirty and release
    ! it. If the current record's key is the high key in the primary data 
    ! bucket, then the current primary data record is just marked deleted.
    !
    BDB	= .IRAB[IRB$L_CURBDB];
    IRAB[IRB$L_CURBDB] = 0;

    RM$DELETE_UDR();

    BDB[BDB$V_DRT] = 1;
    RETURN_ON_ERROR (RM$RLSBKT(0), IRAB[IRB$V_RU_DELETE] = 0);

    ! If the file contains alternate keys, delete all the SIDR entries for 
    ! the current record.
    ! 
    IF .IFAB[IFB$B_NUM_KEYS] GTRU 1
    THEN
	RM$DEL_ALL_SIDR (.RECORD_SIZE);

    ! Clear the IRB$V_RU_DELETE state bit regardless of whether this operation
    ! was or wasn't RU Journalled, and then return success.
    !
    IRAB[IRB$V_RU_DELETE] = 0;
    RETURN RMSSUC();
    END;

%SBTTL	'RM$DELETE_RRV'
GLOBAL ROUTINE RM$DELETE_RRV : RL$RABREG_4567 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Delete the RRV for the current primary data record. If the file is a 
!	prologue 3 file the RRV is entirely deleted; otherwise, it is marked 
!	deleted and just the space occupied by the pointer is reclaimed.
!
!	If the state bit IRB$V_RU_DELETE is set, the RRV is just marked
!	RU_DELETE. Likewise, if the state bit IRB$V_RU_UNDEL is set, then the
!	RU_DELETE bit in the RRV;s control byte is cleared.
!
! CALLING SEQUENCE:
!
!	RM$DELETE_RRV()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	BDB 			- BDB of buffer with RRV bucket in it
!	    BDB$L_ADDR		- address of buffer
!
!	IFAB			- address of IFAB
!	    IFB$B_PLG_VER	- prologue version of file
!
!	IRAB
!	    IRB$V_RU_DELETE	- if set, mark RU_DELETE and do not reclaim 
!	    IRB$V_RU_UNDEL	- if set, un-delete the RRV
!
!	REC_ADDR 		- address of record whose RRV is to be deleted
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IDX_DFN			- index descriptor for the primary key
!
! ROUTINE VALUE:
!
!	Value of RLSBKT when writing out bucket with RRV deleted
!
! SIDE EFFECTS:
!
!	AP destroyed.
!	IDX_DFN is set up for the primary key.
!	The freespace offset in the RRV bucket is updated to reflect the
!	     amount of space reclaimed.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	R_BDB_STR,
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	R_BKT_ADDR_STR;

    LOCAL
	DEL_RRV_SIZE,
	LENGTH,
	RRV_SIZE,
	SAVE_REC_ADDR;

    ! Obtain the key descriptor for the primary key of reference.
    !
    RM$KEY_DESC(0);

    SAVE_REC_ADDR = .REC_ADDR;

    ! Extract the RRV ID of the current primary data record.
    !
    AP = RM$RECORD_ID();

    ! Position to the RRV to be deleted, the RRV for the current primary data 
    ! record. It is impossible for this positioning to fail as long as the 
    ! bucket containing the RRV has not been released since RM$FIND_BY_RRV 
    ! accessed it.
    !
    BKT_ADDR = .BDB[BDB$L_ADDR];
    RM$FIND_BY_ID();

    ! If is is indicated that the RRV should just be marked RU_DELETE and that
    ! no space should be reclaimed, then do so by setting the RU_DELETE bit
    ! within the RRV's control byte.
    !
    IF .IRAB[IRB$V_RU_DELETE]
    THEN
	REC_ADDR[IRC$V_RU_DELETE] = 1

    ! If it is indicated that the RRV should be un-deleted, then do so by
    ! clearing the RU_DELETE bit in the RRV's control byte.
    !
    ELSE
	IF .IRAB[IRB$V_RU_UNDEL]
	THEN
	    REC_ADDR[IRC$V_RU_DELETE] = 0

	! Delete the RRV reclaiming as much space as is possible.
	!
	ELSE
	    BEGIN

	    ! Setup a series of constants to be used in deleting the RRV. These 
	    ! constants are prologue dependent.
	    !
	    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
	    THEN
		BEGIN
		RRV_SIZE     = IRC$C_FIXOVHDSZ;
		DEL_RRV_SIZE = 2;
		END
	    ELSE
		BEGIN
		RRV_SIZE     = IRC$C_FIXOVHSZ3;
		DEL_RRV_SIZE = 0;
		END;

	    ! Delete/Squish the current primary data record's RRV and fix up 
	    ! the RRV bucket's freespace.
	    !
	    LENGTH = (.BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE]) 
			- (.REC_ADDR + .RRV_SIZE);
	
	    IF .LENGTH GTRU 0
	    THEN
		RM$MOVE (.LENGTH, 
			 .REC_ADDR + .RRV_SIZE, 
			 .REC_ADDR + .DEL_RRV_SIZE);

	    BKT_ADDR[BKT$W_FREESPACE] = .BKT_ADDR[BKT$W_FREESPACE] 
					 - .RRV_SIZE + .DEL_RRV_SIZE;

	    ! If the file is not a prologue 3 file, then the RRV of the current
	    ! primary data record was just squished. The RRV pointer was 
	    ! removed, but the control byte and record ID fields remain. In 
	    ! this case RMS wants to setup the control byte of the squished RRV 
	    ! to indicate that it has been deleted, is an RRV, and doesn't 
	    ! contain a pointer.
	    !
	    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
	    THEN
		REC_ADDR[IRC$B_CONTROL] = IRC$M_RRV OR IRC$M_DELETED 
						    OR IRC$M_NOPTRSZ;
	    END;

    ! Restore the address of the current primary data record and release the 
    ! RRV's bucket after marking it dirty.
    !
    REC_ADDR = .SAVE_REC_ADDR;

    BDB[BDB$V_DRT] = 1;
    RETURN RM$RLSBKT (RLS$M_WRT_THRU)

    END;

%SBTTL	'RM$DELETE_SIDR'
GLOBAL ROUTINE RM$DELETE_SIDR : RL$RABREG_7 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine's responsibility is to position to the SIDR array element
!	pointing to the current primary data record for a given key of 
!	reference and delete it. The secondary key in keybuffer 2, and the
!	RFA address of the current primary data record, found as part of the
!	local NRP context in the IRAB, are utilized in this positioning. 
!	Deletion of the appropriate SIDR array element consists of one of the
!	following:
!
!	1. Removal of the entire SIDR if duplicates are not allowed.
!
!	2. Marking the SIDR array element as deleted and not recovering any 
!	   space if duplicates are allowed for this key of reference and the 
!	   file is a prologue 1 or 2 file.
!
!	3. Marking the SIDR array element as deleted and not recovering any 
!	   space if duplicates are allowed for this key of reference, the file 
!	   is a prologue 3 file, and the element is the first element in the SIDR 
!	   array.
!
!	4. Marking the SIDR element deleted and squishing out the space 
!	   occupied by the RRV pointer if duplicates are allowed for this key 
!	   of reference, the file is a prologue 3 file, and the element is not 
!	   the first element in the SIDR array.
!
!	5. Removal of the entire SIDR array if duplicates are allowed, this is 
!	   the first SIDR with this key value, the SIDR is not the physically
!	   last SIDR in the bucket, and ever single element within the SIDR 
!	   array has been deleted.
!
! CALLING SEQUENCE:
!
!	RM$DELETE_SIDR()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN			- address of index descriptor
!	    IDX$B_KEYSZ		- size of alternate key
!
!	IRAB			- address of IRAB
!	    IRB$W_UDR_ID	- RFA VBN of the current primary data record
!	    IRB$L_UDR_VBN	- RFA ID of the current primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB			- address of IRAB
!	    IRB$B_KEYSZ		- size of alternate key for key of reference
!	    IRB$B_STOPLEVEL	- level of index to search to (set to 0)
!
! ROUTINE VALUE:
!
!	Status of the RM$RLSBKT call (success or error) that released
!	    the modified bucket.
!	BUG - if the SIDR array element could not be located
!
! SIDE EFFECTS:
!
!	Modified bucket is released.
!	IRB$V_POSDELETE set within IRB$W_SRCHFLGS.
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR;

    GLOBAL REGISTER
	COMMON_IO_STR,
	R_REC_ADDR_STR;

    LABEL
	FIND_ELEMENT;

    LOCAL
	BEGIN_OF_SIDR;

    ! Since RMS is going to position so it can delete a SIDR array element,
    ! set the appropriate search flag, and make sure the key size is set up.
    !
    IRAB[IRB$B_STOPLEVEL] = 0;
    IRAB[IRB$W_SRCHFLAGS] = IRB$M_POSDELETE;
    IRAB[IRB$B_KEYSZ] = .IDX_DFN[IDX$B_KEYSZ];

    ! Position to the SIDR array element pointing to the current primary data
    ! record for this key of reference. This loop will only be exited either
    ! when the array element has been located or all SIDR elements with this 
    ! key value are exhausted.
    !
FIND_ELEMENT:
    BEGIN

    LOCAL
	END_OF_SIDR,
	ID,
	STATUS,
	VBN;

    WHILE 1
    DO
	BEGIN

	! If RMS is unable to find an array element pointing to the current
	! primary data record, then something is very wrong. Return an internal
	! bug error, and save the status from RM$CSEARCH_TREE, in the RABs STV
	! field.
	!
	IF NOT (STATUS = RM$CSEARCH_TREE())
	THEN
	    BEGIN
	    RAB[RAB$L_STV] = .STATUS;
	    RETURN RMSERR(BUG);
	    END;

	! Prepare to search the SIDR array for the element pointing to the 
	! current primary data record.
	!
	BEGIN_OF_SIDR = .REC_ADDR;
	END_OF_SIDR = RM$SIDR_END();

	! Position to the first array element in the SIDR array.
	!
	REC_ADDR = RM$SIDR_FIRST(0);

	! Search the current SIDR array for the element corresponding to the
	! current primary data record.
	!
	WHILE .REC_ADDR LSSA .END_OF_SIDR
	DO

	    ! If after extracting out the RFA pointer from the current SIDR
	    ! array element, RMS finds that it does indeed point to the
	    ! current primary data record, then exit the search loop
	    !
	    IF  RM$EXT_ARRY_RFA (VBN, ID)
		 AND
		(.IRAB[IRB$W_UDR_ID] EQLU .ID)
		 AND
		(.IRAB[IRB$L_UDR_VBN] EQLU .VBN)
	    THEN
		LEAVE FIND_ELEMENT

	    ! If the current array element is deleted or does not point to the
	    ! current primary data record then proceed to the next element in 
	    ! the SIDR array.
	    !
	    ELSE
		RM$GETNXT_ARRAY();
	END;
    END;

    ! Delete the SIDR array pointing to the current primary data record
    ! for this key of reference. The deletion rules are stated above.
    !
    BDB = .IRAB[IRB$L_CURBDB];
    IRAB[IRB$L_CURBDB] = 0;

    BKT_ADDR = .BDB[BDB$L_ADDR];
    RM$SQUISH_SIDR (0, .BEGIN_OF_SIDR);
    
    ! Mark the bucket dirty, and release it.
    !
    BDB[BDB$V_DRT] = 1;
    RETURN RM$RLSBKT(0);

    END;

%SBTTL	'RM$DELETE_UDR'
GLOBAL ROUTINE RM$DELETE_UDR : RL$RABREG_4567 NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine's responsibility is the deletion of a primary data record.
!	Most but not all of the time, the record being deleted is the current
!	primary data record. The rules for how primary data records are deleted
!	are as follows:
!
!	1. If the primary data record is marked deleted, then the entire record
!	   is always deleted. 
!
!	2. If duplicate primary keys are not allowed, and the record is not the
!	   last primary data record in the bucket then the entire primary data
!	   record is deleted.
!
!	3. If duplicate primary keys are not allowed, and the record is the
!	   last primary data record in the bucket then the primary data record
!	   is marked deleted, and the space occupied by the data portion of the
!	   record is reclaimed if the file's prologue version is 3.
!
!	4. If duplicate primary keys are allowed then the primary data record 
!	   is marked deleted, and the space occupied by the data portion of the
!	   record is recovered if the file's prologue version is 3.
!
!	5. If the state bit IRB$V_RU_DELETE is set, then the primary data 
!	   record is just marked RU_DELETE and no space is reclaimed.
!
!	6. If the state bit IRB$V_RU_UNDEL is set, then the primary data record
!	   is un-deleted by clearing the RU_DELETE bit within the record control
!	   byte.
!
!	7. If the primary data record is completely deleted, the record was in
!	   its original bucket (ie - a RRV does not exist), and the file's 
!	   prologue version is 1 or 2, then a two-byte RRV is created at the 
!	   end of the bucket for this record to prevent its ID from being 
!	   recycled.
!
! CALLING SEQUENCE:
!
!	RM$DELETE_UDR()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	BDB			- address of BDB for primary data bucket buffer
!	    BDB$L_ADDR		- address of primary data bucket buffer
!	    BDB$L_VBN		- VBN of primary data bucket
!
!	IDX_DFN			- address of index descriptor for primary key 
!	    IDX$V_DUPKEYS	- if set, duplicate primary keys are allowed
!	    IDX$V_KEY_COMPR	- if set, primary key compression is enabled
!
!	IFAB			- address of IFAB
!	    IFB$W_KBUFSZ	- size of each keybuffer
!	    IFB$B_PLG_VER	- prologue version of the file
!
!	IRAB			- address of IRAB
!	    IRB$L_KEYBUF	- address of the contigious keybuffers
!	    IRB$V_RU_DELETE	- if set, mark RU_DELETE and do not reclaim 
!	    IRB$V_RU_UNDEL	- if set, un-delete the RRV
!
!	REC_ADDR		- address of primary data record to be deleted
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!
!	AP is trashed.
!	Keybuffer 5 is trashed (if the primary key of the following primary 
!	    data record had to be re-expanded).
!	The freespace offset in the bucket is updated to reflect the amount
!	    of space reclaimed.
!	REC_ADDR is unchanged. It either points to the deleted record if the
!	    target primary data record could not be completely removed, or 
!	    it points to whatever followed the deleted primary data record
!	    (if anything) if it could.
!	If this is a prologue 1 or 2 file, and the primary data record which was
!	    deleted is in its original bucket, then a two-byte RRV is created
!	    to replace the deleted primary data record, provided the space 
!	    occupied by the record was completely recovered.
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	R_BDB_STR,
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	R_BKT_ADDR_STR;

    FIELD
	DELETE_FLAGS =
	    SET
	    BUILD_RRV		= [0,0,1,0],
 	    LAST_RECORD		= [0,1,1,0],
	    RE_EXPAND_KEY	= [0,2,1,0]
	    TES;

    LOCAL
	END_OF_BUCKET	: REF BBLOCK,
	FLAGS		: BLOCK[1,BYTE]
			  FIELD(DELETE_FLAGS),
	NEXT_REC_ADDR	: REF BBLOCK,
	REC_OVHD;

    ! If is is indicated that the primary data record should just be marked 
    ! RU_DELETE and that no space should be reclaimed, then do so by setting 
    ! the RU_DELETE bit within the RRV's control byte.
    !
    IF .IRAB[IRB$V_RU_DELETE]
    THEN
	BEGIN
	REC_ADDR[IRC$V_RU_DELETE] = 1;
	RETURN;
	END

    ! If it is indicated that the primary data record should be un-deleted, 
    ! then do so by clearing the RU_DELETE bit in the pirmary data record's
    ! control byte.
    !
    ELSE
	IF .IRAB[IRB$V_RU_UNDEL]
	THEN
	    BEGIN
	    REC_ADDR[IRC$V_RU_DELETE] = 0;
	    RETURN;
	    END;

    ! Obtain the address of the primary data bucket, and compute the first
    ! free byte in the data bucket.
    !
    FLAGS = 0;
    BKT_ADDR = .BDB[BDB$L_ADDR];
    END_OF_BUCKET = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];

    ! Obtain the overhead for ALL records in this primary data bucket, and 
    ! compute the address of the first primary data record which would follow
    ! the primary data record to be deleted.
    !
    BEGIN

    LOCAL
	REC_SIZE;

    REC_OVHD = RM$REC_OVHD(0; REC_SIZE);
    NEXT_REC_ADDR = .REC_ADDR + .REC_OVHD + .REC_SIZE;
    END;

    ! Determine whether the primary data record to be deleted is the last
    ! record in the bucket, and set the local state flag accordingly.
    !
    IF  (.NEXT_REC_ADDR EQLA .END_OF_BUCKET)
	 OR
	.NEXT_REC_ADDR[IRC$V_RRV]
    THEN
	FLAGS[LAST_RECORD] = 1;

    ! If the target primary data record can not be completely deleted either
    ! because duplicates primary keys are allowed or it is the last record
    ! in the bucket, mark the record deleted, and squish out the data portion
    ! of the primary data record if it is squishable.
    !
    IF  NOT .REC_ADDR[IRC$V_DELETED]
	 AND
	(.IDX_DFN[IDX$V_DUPKEYS]
		 OR
		.FLAGS[LAST_RECORD])
    THEN
	BEGIN
	RM$SQUISH_DATA();
	REC_ADDR[IRC$V_DELETED] = 1;
	RETURN;
	END

    ! The primary data record can be completely deleted. It is either marked
    ! deleted (the only reason why RMS would be calling this routine would be 
    ! to elimiate it entirely), or duplicates are not allowed and it is not 
    ! the last primary data record in the bucket.
    !
    ELSE
	BEGIN

	LOCAL
	    UDR_ID;

	! If the file is a prologue 1 or 2 file and the primary data record to
	! be deleted is in its original bucket (ie - there is no RRV for it),
	! then a two-byte RRV will have to be created for it at the end of the
	! bucket inorder to reserve its ID and prevent it from being recycled.
	!
	AP = 3;

	IF (.IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3)
	    AND
	   (RM$RECORD_VBN() EQLA .BDB[BDB$L_VBN])
	THEN
	    BEGIN
	    FLAGS[BUILD_RRV] = 1;
	    UDR_ID = .REC_ADDR[IRC$B_ID];
	    END;

	! If primary key compression is enabled, and this primary data record
	! is not the last record in the file, then the key of the following
	! record, whose front compression is based on this record, will have 
	! to be re-expanded, after this target primary data record is 
	! completely removed. Set the local state bit accordingly and save the
	! entire key portion (both control bytes and key) of the target primary
	! data record in keybuffer 5 to be used in re-expanded the key of the
	! primary data record that follows.
	!
	IF .IDX_DFN[IDX$V_KEY_COMPR]
	    AND
	   NOT .FLAGS[LAST_RECORD]
	THEN
	    BEGIN
	    FLAGS[RE_EXPAND_KEY] = 1;

	    RM$MOVE (.(.REC_ADDR + .REC_OVHD)<0,8> + 2,
		     .REC_ADDR + .REC_OVHD,
		     KEYBUF_ADDR(5));
	    END;

	! If the primary data record being deleted is not the last entity in 
	! the bucket, recover the space it occupies by shifting everything 
	! that follows, and update the freespace offset in the bucket 
	! accordingly. If the primary data record being deleted is the last 
	! entity in the primary data bucket the space it occupies maybe 
	! recovered by just adjusting the freespace offset.
	!
	IF (.NEXT_REC_ADDR LSSA .END_OF_BUCKET)
	THEN
	    RM$MOVE (.END_OF_BUCKET - .NEXT_REC_ADDR,
		     .NEXT_REC_ADDR,
		     .REC_ADDR);

	BKT_ADDR[BKT$W_FREESPACE] = .BKT_ADDR[BKT$W_FREESPACE]
						- (.NEXT_REC_ADDR - .REC_ADDR);

	! If there is a record following the primary data record just deleted,
	! whose primary key is to be re-expanded, re-expand it. The routine
	! RM$EXPAND_KEYD will take care of re-adjusting the bucket freespace
	! offset.
	!
	IF .FLAGS[RE_EXPAND_KEY]
	THEN
	    RM$EXPAND_KEYD (KEYBUF_ADDR(5), .REC_ADDR + .REC_OVHD);

	! If a two-byte RRV must be built for the deleted primary data record,
	! then build it at the end of the bucket, and adjust the bucket 
	! freespace offset to reflect the RRV's size.
	!
	IF .FLAGS[BUILD_RRV]
	THEN
	    BEGIN
	    END_OF_BUCKET = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];
	    END_OF_BUCKET[IRC$B_CONTROL] = IRC$M_DELETED OR IRC$M_NOPTRSZ
							 OR IRC$M_RRV;
	    END_OF_BUCKET[IRC$B_ID] = .UDR_ID;
	    BKT_ADDR[BKT$W_FREESPACE] = .BKT_ADDR[BKT$W_FREESPACE] + 2;
	    END;

	END;

    END;

%SBTTL	'RM$SQUISH_DATA'
ROUTINE	RM$SQUISH_DATA : RL$SQUISH_DATA NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine's responsibility is the deletion of the data part of 
!	the current primary data record. This deletion can only take place if 
!	the file is a prologue 3 file.
!
! CALLING SEQUENCE:
!
!	RM$SQUISH_DATA()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR		- address of the primary data bucket
!
!	IDX_DFN			- address of the primary key index descriptor
!	    IDX$V_KEY_COMP	- if set, key compression is enabled
!	    IDX$B_KEYSZ		- size of the key
!	    IDX$V_REC_COMP	- if set, record compression is enabled
!
!	IFAB			- address of the IFAB
!	    IFB$B_PLG_VER	- prologue version of the file
!
!	REC_ADDR		- address of the current primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!
!	The freespace in the bucket is updated to reflect the space reclaimed.
!
!--
    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	R_RAB,
	R_IRAB,
	R_IMPURE,
	R_BDB;

    LOCAL
	REC_SIZE,
	KEY_SIZE,
	REC_OVHD,
	SIZE;

    ! If this is not a prologue 3 file then nothing can be done; however, if 
    ! this is a prologue 3 file then as the primary key is always kept separate
    ! from the data portion of a prologue 3 data record, the data portion
    ! of the current primary data record can always be squished out, and its
    ! space recovered.
    !
    IF .IFAB[IFB$B_PLG_VER] NEQ PLG$C_VER_3
    THEN
	RETURN;

    ! Obtain the size of the record overhead and the size of the current 
    ! primary data record. Note that the size of the key (and any key specific 
    ! control bytes) is always included as part of the size of the current 
    ! primary data record.
    !
    REC_OVHD = RM$REC_OVHD(0; REC_SIZE);

    ! Compute the contribution of the primary key of the record to the size of 
    ! the current primary data record. If primary key compression is enabled, 
    ! then the key size will include the two bytes of key compression overhead.
    !
    IF .IDX_DFN[IDX$V_KEY_COMPR]
    THEN
	KEY_SIZE = .(.REC_ADDR + .REC_OVHD)<0,8> + 2
    ELSE
	KEY_SIZE = .IDX_DFN[IDX$B_KEYSZ];

    ! Compute the size of the data portion of the current primary data record.
    ! If the current primary data record consists of the primary key alone, 
    ! return, as there is no data portion to squish out.
    !
    IF ((SIZE = .REC_SIZE - .KEY_SIZE) EQLU 0)
    THEN
	RETURN;

    ! Squish out the data portion of the current primary data record.
    !
    RM$MOVE ((.BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE]) 
			- (.REC_ADDR + .REC_OVHD + .REC_SIZE),
	     .REC_ADDR + .REC_OVHD + .REC_SIZE,
	     .REC_ADDR + .REC_OVHD + .KEY_SIZE);

    ! Update the record size of the current primary data record to reflect
    ! the squishing out of the data portion of the record. NOTE that if the
    ! record is fixed length and both key and record compression are disabled,
    ! then there will be no record size field to update.
    !
    IF NOT (.IFAB[IFB$B_RFMORG] EQLU FAB$C_FIX
	     AND
	    NOT .IDX_DFN[IDX$V_KEY_COMPR]
	     AND
	    NOT .IDX_DFN[IDX$V_REC_COMPR])
    THEN
	(.REC_ADDR + .REC_OVHD - 2)<0,16> = .(.REC_ADDR + .REC_OVHD - 2)<0,16> 
					    - .SIZE;

    ! Update the freespace pointer in the bucket to reflect the space that
    ! has been recovered by the squishing out of the data portion of the
    ! current primary data record.
    !
    BKT_ADDR[BKT$W_FREESPACE] = .BKT_ADDR[BKT$W_FREESPACE] - .SIZE;

    END;

%SBTTL	'RM$SQUISH_SIDR'
GLOBAL ROUTINE RM$SQUISH_SIDR (SCAN, BEGIN_OF_SIDR) : RL$RABREG_567 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine's responsibility is to delete the SIDR array element
!	pointing to the current primary data record for this key of reference.
!	Deletion of the SIDR array element goes according to one of the 
!	following rules:
!
!	1. Removal of the entire SIDR if duplicates are not allowed. NOTE that
!	   if the input parameter SCAN is 1 and the file is a prologue 3 file
!	   then for the purpose of this SIDR deletion it is assumed that this 
!	   key of reference does allow duplicates (See rules 2 through 5).
!
!	2. Marking the SIDR array element as deleted and not recovering any 
!	   space if duplicates are allowed for this key of reference and the 
!	   file is a prologue 1 or 2 file.
!
!	3. Marking the SIDR array element as deleted and not recovering any 
!	   space if duplicates are allowed for this key of reference, the file 
!	   is a prologue 3 file, and the element is the first element in the 
!	   SIDR array.
!
!	4. Marking the SIDR element deleted and squishing out the space 
!	   occupied by the RRV pointer if duplicates are allowed for this key 
!	   of reference, the file is a prologue 3 file, and the element is not 
!	   the first element in the SIDR array.
!
!	5. Removal of the entire SIDR array if duplicates are allowed, this is 
!	   the first SIDR with this key value, the SIDR is not the physically
!	   last SIDR in the bucket, and ever single element within the SIDR 
!	   array has been deleted.
!
!	6. If the state bit IRB$V_RU_DELETE is set, then the SIDR array element
!	   is just marked RU_DELETE and no space is reclaimed.
!
!	7. If the state bit IRB$V_RU_UNDEL is set, then the SIDR array element
!	   is un-deleted by clearing the RU_DELETE bit within the element's 
!	   control byte.
!
! CALLING SEQUENCE:
!
!	BSBW RM$SQUISH_SIDR()
!
! INPUT PARAMETERS:
!
!	SCAN		- if 1, scan the current SIDR array (if Prologue 3 file)
!
!	BEGIN_OF_SIDR	- pointer to the beginning of the SIDR record
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR 		- address of the SIDR bucket
!
!	IDX_DFN 		- address of the index descriptor
!	    IDX$V_DUPKEYS	- if set, duplicate keys are allowed
!	    IDX$V_KEY_COMPR	- if set, SIDR key compression is enabled
!
!	IFAB			- address of IFAB
!	    IFB$W_KBUFSZ	- size of one of the contigious keybuffers
!	    IFB$B_PLG_VER	- prologue version of file
!
!	IRAB 			- address of IRAB
!	    IRB$L_KEYBUF	- address of the contigious keybuffers
!	    IRB$V_RU_DELETE	- if set, mark RU_DELETE and do not reclaim 
!	    IRB$V_RU_UNDEL	- if set, un-delete the RRV
!
!	REC_ADDR 		- address of the SIDR array element
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	REC_ADDR	- address of next SIDR if the entire SIDR was deleted
!			  otherwise unchanged.
!
! ROUTINE VALUE:
!
!	1		- some space was recovered.
!	0		- no space was recovered.
!
! SIDE EFFECTS:
!
!	Keybuffer 5 will have been trashed, if any key re-expansion occurred.
!	The freespace in the bucket is updated to reflect the space reclaimed.
!	If the SIDR is completely deleted, SIDR key compression is enabled, and
!	    a SIDR follows the completely deleted SIDR, then the key of this
!	    following SIDR will have been re-expanded.
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    LABEL
	DUPS;

    LOCAL
	DELETE_START,
	DELETE_END,
	FLAGS		: BLOCK[1],
	LENGTH,
	NEXT_REC_ADDR,
	RECORD_OVHD,
	SAVE_REC_ADDR	: REF BBLOCK;

    MAP
	BEGIN_OF_SIDR	: REF BBLOCK;

    MACRO
	DELETE_SIDR	= 0,0,1,0 %,
	SQUISH_SIDR	= 0,1,1,0 %,
	RE_EXPAND_KEY	= 0,2,1,0 %;

    ! If is is indicated that the SIDR array element should just be marked 
    ! RU_DELETE and that no space should be reclaimed, then do so by setting 
    ! the RU_DELETE bit within the element's control byte.
    !
    IF .IRAB[IRB$V_RU_DELETE]
    THEN
	BEGIN
	REC_ADDR[IRC$V_RU_DELETE] = 1;
	RETURN 0;
	END

    ! If it is indicated that the SIDR array element should be un-deleted, 
    ! then do so by clearing the RU_DELETE bit in the element's control byte.
    !
    ELSE
	IF .IRAB[IRB$V_RU_UNDEL]
	THEN
	    BEGIN
	    REC_ADDR[IRC$V_RU_DELETE] = 0;
	    RETURN 0;
	    END;

    ! Save the address of the current SIDR element, and zero out the local 
    ! flag field.
    !
    FLAGS = 0;
    SAVE_REC_ADDR = .REC_ADDR;

    ! Determine the address of the first byte past the end of the current
    ! SIDR.
    !
    BEGIN

    LOCAL
	REC_SIZE;

    REC_ADDR = .BEGIN_OF_SIDR;
    RECORD_OVHD = RM$REC_OVHD(-1; REC_SIZE);
    NEXT_REC_ADDR = .REC_ADDR + .RECORD_OVHD + .REC_SIZE;
    END;

    ! If this secondary key of reference does not allow duplicate key values
    ! and either the file's prologue version is 1 or 2; or, the input parameter
    ! SCAN is 0, then the entire SIDR maybe deleted.
    !
    IF 	NOT .IDX_DFN[IDX$V_DUPKEYS]
	 AND
	(NOT .SCAN
		 OR
		.IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3)
    THEN
	FLAGS[DELETE_SIDR] = 1

    ! If this key of reference does allow duplicate SIDR keys or duplicates are
    ! not allowed but the file's prologue version is 3 and a scan of then entire
    ! SIDR array has been requested (SCAN is set to 1), then mark the current 
    ! element as deleted and under certain circumstances, reclaim the space
    ! occupied by the SIDR array element's RRV pointer. Under very restricted
    ! circumstances it will also be possible to reclaim the space occupied by
    ! the entire SIDR.
    !
    ELSE
DUPS:
	BEGIN
	SAVE_REC_ADDR[IRC$V_DELETED] = 1;

	! If the file is a prologue 2 file then marking the element deleted is
	! all that can be done. 
	!
	IF (.IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3)
	THEN
	    BEGIN
	    REC_ADDR = .SAVE_REC_ADDR;
	    RETURN 0;
	    END

	! The file is a prologue 3 file. If every single array element in this
	! SIDR array is deleted, if the SIDR is not physically the last SIDR in 
	! the bucket (this restriction applies to duplicates keys allowed only)
	! and if this SIDR is the first such SIDR with this key value in the 
	! file then it will be possible to delete the entire SIDR; otherwise, 
	! the space occupied by the element's RRV pointer is reclaimed unless 
	! it is the first element in the array in which case nothing more can 
	! be done.
	!
	ELSE
	    BEGIN

	    LABEL
		ENTIRE_SIDR;

	    LOCAL
		FIRST_SIDR	: REF BBLOCK;

	    ! Obtain the address of the first array element in the SIDR array.
	    !
	    FIRST_SIDR = RM$SIDR_FIRST(0);

	    ! If the first element in the array (which maybe the element being
	    ! deleted) is marked deleted, and this SIDR is the first such
	    ! record in the file with this key value, then it still maybe 
	    ! possible to delete the entire SIDR.
 	    !
	    IF  .FIRST_SIDR[IRC$V_DELETED]
		 AND
		.FIRST_SIDR[IRC$V_FIRST_KEY]
	    THEN
ENTIRE_SIDR:	BEGIN

		LOCAL
		    SCAN_START;

		! If the current SIDR is physically the last SIDR in the bucket
		! and duplicates keys are allowed then it will not be possible 
		! to reclaim the space occupied by the entire SIDR even if all 
		! its elements are deleted.
		!
		IF .NEXT_REC_ADDR GEQA (.BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE])
		    AND
		   .IDX_DFN[IDX$V_DUPKEYS]		    
		THEN
		    LEAVE ENTIRE_SIDR;

		! Scan the SIDR array starting with the second element up to
		! but not including the target element making sure that all 
		! these elements have been deleted. If a live element is found
		! then the space occupied by the entire SIDR can not be 
		! reclaimed.
		!
		SCAN_START = .FIRST_SIDR + .FIRST_SIDR[IRC$V_PTRSZ]
					 + IRC$C_DATPTRBS3
					 + 1;

		IF (.SCAN_START LSSA .SAVE_REC_ADDR)
		THEN
		    IF NOT CH$FAIL (CH$FIND_NOT_CH  
					(.SAVE_REC_ADDR - .SCAN_START,
					 .SCAN_START,
					 %CHAR(IRC$M_DELETED) 
						 OR 
						%CHAR(IRC$M_NOPTRSZ)))
		    THEN
			LEAVE ENTIRE_SIDR;

		! Scan the SIDR array starting with the first element past the
		! target element and ending with the last element in the SIDR 
		! making sure that all these elements have been deleted. If a 
		! live element is found then the space occupied by the entire 
		! SIDR can not be reclaimed.
		!
		SCAN_START = .SAVE_REC_ADDR + .SAVE_REC_ADDR[IRC$V_PTRSZ]
					    + IRC$C_DATPTRBS3
					    + 1;

		IF (.SCAN_START LSSA .NEXT_REC_ADDR)
		THEN
		    IF NOT CH$FAIL (CH$FIND_NOT_CH  
					(.NEXT_REC_ADDR - .SCAN_START,
					 .SCAN_START,
					 %CHAR(IRC$M_DELETED)
						 OR 
						%CHAR(IRC$M_NOPTRSZ)))
		    THEN
			LEAVE ENTIRE_SIDR;

		! Every single element in the current SIDR has been found to be
		! deleted, so the space occupied by the entire SIDR maybe
		! reclaimed. 
		!
		FLAGS[DELETE_SIDR] = 1;
		LEAVE DUPS;		    
		END;

	    ! If it is not possible to delete the entire SIDR then set up to 
	    ! reclaim the space occupied by the element's RRV pointer unless the
	    ! element is the first element in the array in which case nothing
	    ! more can be done. 
	    !
	    REC_ADDR = .SAVE_REC_ADDR;

	    IF (.REC_ADDR EQLA .FIRST_SIDR)
	    THEN
		RETURN 0
	    ELSE
		FLAGS[SQUISH_SIDR] = 1;
	    END;
	END;

    ! If the space occupies by the entire SIDR is to be reclaimed, set up to
    ! recover it.
    !
    IF .FLAGS[DELETE_SIDR]
    THEN
	BEGIN
	DELETE_START = .BEGIN_OF_SIDR;
	DELETE_END = .NEXT_REC_ADDR;

	! If key compression is enabled, and this SIDR is not the last SIDR 
	! in the bucket, save the key of the current SIDR in keybuffer 5, 
	! so that it maybe used in expanding the key of the following 
	! record.
	!
	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    BEGIN

	    GLOBAL REGISTER
		R_BDB;

	    FLAGS[RE_EXPAND_KEY] = 1;

	    RM$MOVE (.(.REC_ADDR + .RECORD_OVHD)<0,8> + 2,
		     .REC_ADDR + .RECORD_OVHD,
		     KEYBUF_ADDR(5));
	    END;
	END

    ! If the space occupies by the RRV pointer is to be reclaimed, set up to
    ! recover it.
    !
    ELSE
	BEGIN

	DELETE_START = .REC_ADDR + 1;
	DELETE_END   = .DELETE_START + .REC_ADDR[IRC$V_PTRSZ] 
				     + IRC$C_DATPTRBS3;

	REC_ADDR[IRC$V_NOPTRSZ] = 1;
	REC_ADDR[IRC$V_PTRSZ]   = 0;

	! Update the SIDR size field. As it is currently written, this
	! updating assumes that the size field is the first two bytes
	! (and the only two bytes) of the record overhead field.
	!
	(.BEGIN_OF_SIDR)<0,16> = .(.BEGIN_OF_SIDR)<0,16> 
					   - (.DELETE_END - .DELETE_START);
	END;

    ! Recover the space that can be recovered, and update the freespace offset
    ! in the SIDR bucket. If the SIDR is being completely deleted, and it is the
    ! last SIDR in the bucket then there will be nothing to move and only the
    ! bucket's freespace offset need be updated.
    !
    LENGTH = .BKT_ADDR[BKT$W_FREESPACE] - (.DELETE_END - .BKT_ADDR);

    IF .LENGTH GTRU 0
    THEN
	BEGIN

	GLOBAL REGISTER
	    R_BDB;

	RM$MOVE (.LENGTH, .DELETE_END, .DELETE_START);
	END;

    BKT_ADDR[BKT$W_FREESPACE] = .BKT_ADDR[BKT$W_FREESPACE]
				 - (.DELETE_END - .DELETE_START);

    ! If key compression is enabled, the space occupied by the current SIDR was
    ! completely reclaimed, and a SIDR follows whose key needs to be 
    ! re-expanded, do so at this point.
    !
    IF .FLAGS[RE_EXPAND_KEY]
    THEN
	RM$EXPAND_KEYD (KEYBUF_ADDR(5), .REC_ADDR + .RECORD_OVHD);

    ! Return indicating that some space has been recovered.
    !
    RETURN 1;
    END;

END

ELUDOM

