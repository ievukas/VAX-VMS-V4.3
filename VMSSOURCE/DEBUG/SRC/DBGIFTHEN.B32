MODULE DBGIFTHEN (IDENT = 'V04-000') =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!
!	DEBUG
!
! ABSTRACT:
!
!	This module contains the parse and execution networks for the 
!	DEBUG control structures: IF...THEN...ELSE, WHILE...DO, 
!	FOR loops, and REPEAT...DO
!
! ENVIRONMENT:
!
!	VAX/VMS
!
! AUTHOR:
!
!	Richard Title
!
! CREATION DATE:
!
!	1-10-82
!
! VERSION:
!
!	V03.0-001
!
! MODIFIED BY:
!	
!
! REVISION HISTORY:
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE	
	DBG$NPARSE_IF,				! Parse network
	DBG$NEXECUTE_IF,			! Execution network
	DBG$NPARSE_WHILE,			! Parse network
	DBG$NEXECUTE_WHILE,			! Execution network
    	DBG$NPARSE_FOR,				! Parse network for FOR
    	DBG$NEXECUTE_FOR,			! Execution network for FOR
	DBG$NPARSE_REPEAT,			! Parse network
	DBG$NEXECUTE_REPEAT;			! Execution network
    
! REQUIRE FILES:
!
REQUIRE 'SRC$:DBGPROLOG.REQ';
LIBRARY 'LIB$:DBGGEN.L32';

EXTERNAL
    dbg$gb_language: BYTE,		! Current language setting
    dbg$gb_radix: VECTOR[3, BYTE],	! Radix settings
    dbg$gb_take_cmd: BYTE,		! Flag that controls command taking
    dbg$gl_cishead: REF cis$link;	! Head of command input stream

EXTERNAL ROUTINE
    dbg$def_sym_add,			! Add a defined symbol
    dbg$get_memory,			! Allocate permanent memory
    dbg$get_tempmem,			! Allocates space
    dbg$ncis_add,			! Add a link to the command input stream
    dbg$nget_symid,			! Obtain a symid list
    dbg$nmake_arg_vect,			! Constructs error messages
    dbg$nmatch,				! Tries to match the next token
    dbg$nnext_word,			! Gets next word from input
    dbg$nparse_expression,		! Language specific expression interpreter
    dbg$nread_name,			! Pick up a name
    dbg$nsave_break_buffer: NOVALUE,	! Saves the action clause in a buffer
    dbg$nsyntax_error, 			! Reports a syntax error
    dbg$ntype_conv,			! Language specific type converter
    dbg$rel_memory: NOVALUE,		! Releases memory from DEBUG memory pool
    dbg$sta_lock_symid: NOVALUE;	! Lock a symid list

MACRO report_error =
    	BEGIN
    	.message_vect = 
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		 dbg$nmake_arg_vect(dbg$_needmore)
    	     ELSE
    		  dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
   	RETURN sts$k_severe;
    	END%;

GLOBAL ROUTINE dbg$nparse_if(input_desc, verb_node, message_vect) =
!
! Functional Description
!
!	ATN parse network for the IF verb.
!	This routine takes a verb node for the IF verb, and a string
!	descriptor for the remaining (unparsed) input.
!	A command execution tree is built. The form of the tree is:
!
!	 -----------       -----------       -----------        -----------   
!	| verb node |-->--| noun node |-->--| noun node |[-->--| noun node |]
!        -----------       -----------       -----------        -----------   
!
!	The first noun node points to a value descriptor for the IF clause.
!	The second noun node points to a counted string with the THEN clause.
!	The third noun node, which may be absent, points to a counted string
!	with the ELSE clause.
!  
! Formal Parameters
!
!	input_desc	- A longword containing the address of the 
!			  	command input descriptor.
!	verb_node	- A longword containing the address of the verb node.
!	message_vect	- The address of a longword to contain the address
!			  	of a standard message argument vector.
!
! Implicit Inputs
!
!	none
!
! Implicit Outputs
!	
!	On success, the command execution tree is constructed.
!	On failure, a message argument vector is constructed or obtained.
!
! Routine value
!
!	sts$k_success (1)	- Success. Command execution tree constructed.
!	sts$k_severe  (4)	- Failure. Error encountered. Message argument
!				  constructed and returned.
!
! Side Effects
!
!	Permanent storage is allocated for the string holding the THEN
!	clause; this is released in DBG$NEXECUTE_IF after execution
! 	of the THEN clause.
!

BEGIN

MAP
    input_desc  : REF dbg$stg_desc,
    verb_node	: REF dbg$verb_node;

BIND
    dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
    dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
    dbg$cs_else		= UPLIT BYTE (4, 'ELSE'),
    dbg$cs_then		= UPLIT BYTE (4, 'THEN');

LOCAL
    link,				! Temporary to links in the command
    					!     execution tree.
    noun_node : REF dbg$noun_node,	! A node in the command execution tree.
    radix,				! Holds the current radix setting.
    status;				! Holds return status from subroutine
    					!     calls.



    ! Create and link a noun node
    !
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    verb_node[dbg$l_verb_object_ptr] = .noun_node;


    ! Determine the current radix.
    !
    radix  = .dbg$gb_radix[dbg$b_radix_input];


    ! Obtain a value descriptor for the condition. The first noun node
    ! points to this descriptor.
    !
    STATUS = DBG$NPARSE_EXPRESSION (.INPUT_DESC, .RADIX,
			NOUN_NODE [DBG$L_NOUN_VALUE],
			TOKEN$K_TERM_THEN, .MESSAGE_VECT);


    ! The return status should be "warning", meaning that an expression
    ! was parsed and further input reamins. If an expression was parsed
    ! but no input remains, then DBG$NPARSE_EXPRESSION will return success.
    ! In this context, it is an error since "IF condition" by itself 
    ! is an error.
    !
    IF .status EQL sts$k_success THEN SIGNAL(DBG$_NEEDMORE);


    ! Severe status is also an error.
    !
    IF .status EQL sts$k_severe
    THEN
    	RETURN sts$k_severe;


    ! Eat the THEN
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_then, 1)
    THEN
    	BEGIN
    	.message_vect = 
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc)));

    	RETURN sts$k_severe;
        END;


    ! Allocate and link a noun node for the THEN clause.
    !
    link = noun_node [dbg$l_noun_link];
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    .link = .noun_node;

    ! Eat the left parenthesis which we require be present.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    THEN
    	BEGIN
    	.message_vect =
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		BEGIN
    		SIGNAL(dbg$_needparen);
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc))
    		END);
    	RETURN sts$k_severe;
    	END;

    ! Put a pointer to the counted string representing the THEN
    ! clause into the second noun node. (Note - the counted string
    ! is constructed out of "permanent" memory which is released
    ! in DBG$NEXECUTE_IF).
    ! (The third argument indicates that this routine is not being
    ! called during a SET BREAK DO (the behavior is slightly different
    ! in that case.))
    !
    dbg$nsave_break_buffer (.input_desc, noun_node [dbg$l_noun_value]);

    ! If we have reached the end of the line, return success (no else
    ! clause is present).
    !
    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
       OR .input_desc [dsc$w_length] EQL 0
    THEN
    	RETURN sts$k_success;

    ! Look for ELSE clause.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_else, 1)
    THEN
    	BEGIN
    	.message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
    	RETURN sts$k_severe;
    	END;

    ! Allocate and link a noun node for the ELSE clause.
    !
    link = noun_node [dbg$l_noun_link];
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    .link = .noun_node;

    ! Eat the left parenthesis which we require be present.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    THEN
    	BEGIN
    	.message_vect =
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		BEGIN
    		SIGNAL(dbg$_needparen);
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc))
    		END);
    	RETURN sts$k_severe;
    	END;

    ! Put a pointer to the counted string representing the ELSE
    ! clause into the third noun node. (Note - the counted string
    ! is constructed out of "permanent" memory which is released
    ! in DBG$NEXECUTE_IF).
    !
    dbg$nsave_break_buffer (.input_desc, noun_node [dbg$l_noun_value]);

    ! Return success.
    !
    RETURN sts$k_success;

    END;

GLOBAL ROUTINE dbg$nexecute_if (verb_node,message_vect) =
!++
! Functional Description
!	
!	This routine performs the action associated with the IF
!	command.
!
! Formal Parameters
!
!	verb_node	- A longword containing the address of the
!			  head (verb) node.
!	message_vect	- The address of a longword to contain the
!			  address of an error message vector
!
! Implicit Inputs
!
!	The command tree contains a verb node and a linked list
!	of two or three noun nodes. (See the diagram in the header for
!	DBG$NPARSE_IF). 
!
! Routine Value
!
!	A completion code.
!
! Completion Codes
!
!	sts$k_success (1) 	- Success. Command executed
!	sts$k_severe (4)	- Failure. The command could not be
!				  executed. An error message is constructed.
!
! Side Effects
!
!	Storage allocated for the THEN clause is freed up.
!--
    BEGIN

    MAP 
        verb_node : REF dbg$verb_node;

    LOCAL
    	condition_node: REF dbg$noun_node,	! The noun node for the IF condition
    	condition_value,			! Should be TRUE or FALSE
    	else_node: REF dbg$noun_node,		! The noun node for the ELSE clause.
    	else_string: REF VECTOR[,WORD],		! Counted string with the ELSE clause
    	then_node: 	REF dbg$noun_node,	! The noun node for the THEN clause
    	then_string:	REF VECTOR[,WORD],	! Counted string with the THEN clause
    	vax_desc: 	dbg$stg_desc;		! Target of the conversion from
    						!    the value descriptor 
    						!    representing the condition.

    ! Recover the two noun nodes.
    !
    condition_node = .verb_node [dbg$l_verb_object_ptr];
    then_node = .condition_node [dbg$l_noun_link];
    else_node = .then_node [dbg$l_noun_link];

    ! Set up the vax descriptor for the condition.
    ! *** For now, we just declare the descriptor to be longword integer,
    ! since this causes the fewest problems in the type converter. 
    ! Eventually, if we get a Boolean type and all languages support
    ! it then we will build a target descriptor of this type.
    !
    vax_desc [dsc$b_class] = dsc$k_class_s;
    vax_desc [dsc$b_dtype] = dsc$k_dtype_l;
    vax_desc [dsc$w_length] = 4;
    vax_desc [dsc$a_pointer] = condition_value;
    vax_desc [dsc$l_pos] = 0;

    ! *** Special case for PASCAL. Level 3 PASCAL returns descriptors
    ! of type Boolean (dsc$k_dtype_tf) for relational expressions.
    !
    IF .dbg$gb_language EQL dbg$k_pascal
    THEN
    	BEGIN
    	vax_desc [dsc$b_dtype] = dsc$k_dtype_tf;
    	vax_desc [dsc$w_length] = 1;
    	END;

    ! Initialize condition_value to 0
    !
    condition_value = 0;

    ! Do the conversion from value descriptor to integer.
    !
    IF NOT dbg$ntype_conv (.condition_node [dbg$l_noun_value],
    			   dbg$k_default,
    		 	   dbg$k_vax_desc,
    			   vax_desc,
    			   .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Recover the string(s).
    ! 
    then_string = .then_node [dbg$l_noun_value];
    IF .else_node NEQ 0 
    THEN
    	else_string = .else_node [dbg$l_noun_value]
    ELSE
    	else_string = 0;

    ! Process the THEN clause only if value of the condition is TRUE.
    ! For now, just use the BLISS semantics which say that a value is
    ! true iff the low bit is 1. We need to research which languages
    ! have different semantics and come up with a language-dependent
    ! method of doing this.
    !
    IF .condition_value
    THEN
    	BEGIN

    	! Add a new link to the command input stream.
    	!
    	IF NOT dbg$ncis_add (then_string[1], .then_string[0], 
    			     cis_if, 0, 0, 0, .message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	END

    ELSE ! Process the ELSE clause

    	IF .else_string NEQ 0
    	THEN
    	    BEGIN

    	    ! Add a new link to the command input stream.
    	    !
    	    IF NOT dbg$ncis_add (else_string[1], .else_string[0], 
    			         cis_if, 0, 0, 0, .message_vect)
    	    THEN
    		RETURN sts$k_severe;

    	    END;

    ! Return success.
    !
    RETURN sts$k_success;

    END; ! dbg$nexecute_if

GLOBAL ROUTINE dbg$nparse_while(input_desc, verb_node, message_vect) =
!
! Functional Description
!
!	ATN parse network for the WHILE verb.
!	This routine takes a verb node for the WHILE verb, and a string
!	descriptor for the remaining (unparsed) input.
!	A command execution tree is built. The form of the tree is:
!
!	 -----------       -----------       -----------
!	| verb node |-->--| noun node |-->--| noun node |
!        -----------       -----------       -----------
!
!	The first noun node points to a value descriptor for the condition.
!	The second noun node points to a counted string with the DO clause.
!  
! Formal Parameters
!
!	input_desc	- A longword containing the address of the 
!			  	command input descriptor.
!	verb_node	- A longword containing the address of the verb node.
!	message_vect	- The address of a longword to contain the address
!			  	of a standard message argument vector.
!
! Implicit Inputs
!
!	none
!
! Implicit Outputs
!	
!	On success, the command execution tree is constructed.
!	On failure, a message argument vector is constructed or obtained.
!
! Routine value
!
!	sts$k_success (1)	- Success. Command execution tree constructed.
!	sts$k_severe  (4)	- Failure. Error encountered. Message argument
!				  constructed and returned.
!
! Side Effects
!
!	Permanent storage is allocated for the string holding the DO clause;
!	this is released in DBG$NEXECUTE_WHILE after execution.
!

    BEGIN

    MAP
	input_desc: REF dbg$stg_desc,
	verb_node: REF dbg$verb_node;

    BIND
	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
	dbg$cs_do		= UPLIT BYTE (4, 'DO');

    LOCAL
	link,				! Temporary to hold links in the command
    					!     execution tree.
	noun_node : REF dbg$noun_node,	! A node in the command execution tree.
	radix,				! Holds the current radix setting.
	status;				! Return status from subroutine calls.



    ! Create and link a noun node
    !
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    verb_node[dbg$l_verb_object_ptr] = .noun_node;

    ! Determine the current radix.
    !
    radix = .dbg$gb_radix[dbg$b_radix_input];


    ! Obtain a value descriptor for the condition. The first noun node
    ! points to this value descriptor.
    !
    STATUS = DBG$NPARSE_EXPRESSION(.INPUT_DESC, .RADIX,	
			NOUN_NODE [DBG$L_NOUN_VALUE],
			TOKEN$K_TERM_DO, .MESSAGE_VECT);


    ! The return status should be "warning", meaning that an expression
    ! was parsed and further input remains. If an expression was parsed
    ! and no input remains, NPARSE_EXPRESSION will return "success". 
    ! In this context, it is an error since "WHILE exp" by itself
    ! is an error.
    !
    IF .status EQL sts$k_success
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;
    
    ! Severe status is also an error.
    !
    IF .status EQL sts$k_severe
    THEN
    	RETURN sts$k_severe;
    
    ! Eat the DO
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_do, 1)
    THEN
    	BEGIN
    	.message_vect = 
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	        OR .input_desc [dsc$w_length] EQL 0 
   	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
    	RETURN sts$k_severe;
        END;

    ! Allocate and link a noun node for the DO clause.
    !
    link = noun_node [dbg$l_noun_link];
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    .link = .noun_node;

    ! Eat the left parenthesis which we require be present.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    THEN
    	BEGIN
    	.message_vect =
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		BEGIN
    		SIGNAL(dbg$_needparen);
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc))
    		END);
    	RETURN sts$k_severe;
    	END;

    ! Put a pointer to the counted string representing the DO
    ! clause into the second noun node. (Note - the counted string
    ! is constructed out of "permanent" memory which is released
    ! in DBG$NEXECUTE_IF).
    !
    dbg$nsave_break_buffer (.input_desc, noun_node [dbg$l_noun_value]);

    ! Return success.
    !
    RETURN sts$k_success;

    END;

GLOBAL ROUTINE dbg$nexecute_while (verb_node,message_vect) =
!++
! Functional Description
!	
!	This routine performs the action associated with the WHILE
!	command.
!
! Formal Parameters
!
!	verb_node	- A longword containing the address of the
!			  head (verb) node.
!	message_vect	- The address of a longword to contain the
!			  address of an error message vector
!
! Implicit Inputs
!
!	The command tree contains a verb node and a linked list
!	of two noun nodes. (See the diagram in the header for
!	DBG$NPARSE_WHILE). 
!
! Routine Value
!
!	A completion code.
!
! Completion Codes
!
!	sts$k_success (1) 	- Success. Command executed
!	sts$k_severe (4)	- Failure. The command could not be
!				  executed. An error message is constructed.
!
! Side Effects
!
!	None
!--
    BEGIN

    MAP 
        verb_node : REF dbg$verb_node;

    LOCAL
    	condition_node: REF dbg$noun_node,	! The noun node for the IF condition
    	condition_value,			! Should be TRUE or FALSE
    	do_node: 	REF dbg$noun_node,	! The noun node for the THEN clause
    	do_string: REF VECTOR[,WORD],		! Counted string for the do clause
    	vax_desc:  dbg$stg_desc;		! Target of the conversion from
    						!	the value descriptor.


    ! Recover the two noun nodes.
    !
    condition_node = .verb_node [dbg$l_verb_object_ptr];
    do_node = .condition_node [dbg$l_noun_link];

    ! Set up the vax descriptor for the condition.
    !
    vax_desc [dsc$b_class] = dsc$k_class_s;
    vax_desc [dsc$b_dtype] = dsc$k_dtype_l;
    vax_desc [dsc$w_length] = 4;
    vax_desc [dsc$a_pointer] = condition_value;
    vax_desc [dsc$l_pos] = 0;

    ! Special case for level 3 PASCAL. PASCAL returns descriptors
    ! of type boolean (dsc$k_dtype_tf) for relational expressions.
    !
    IF .dbg$gb_language EQL dbg$k_pascal
    THEN
    	BEGIN
    	vax_desc [dsc$b_dtype] = dsc$k_dtype_tf;
    	vax_desc [dsc$w_length] = 1;
    	END;

    ! Initialize condition_value to zero.
    !
    condition_value = 0;

    ! Do the conversion from value descriptor to integer.
    !
    IF NOT dbg$ntype_conv (.condition_node [dbg$l_noun_value],
    			   dbg$k_default,
    			   dbg$k_vax_desc,
    			   vax_desc,
    			   .message_vect)
    THEN 
    	RETURN sts$k_severe;

    ! Continue only of condition is true. For now, just use BLISS semantics.
    !
    IF .condition_value
    THEN
    	BEGIN    

        ! Recover the do string.
        ! 
        do_string = .do_node [dbg$l_noun_value];

        ! Add a link to the command input stream
        !
    	IF NOT dbg$ncis_add (do_string[1], .do_string[0], cis_while,
    		 0, TRUE, 0, .message_vect)
    	THEN
    	    RETURN sts$k_severe;
    	
    	END

    ELSE
    	! Add a cis for null action
    	!
    	BEGIN
    	LOCAL
    	    dummy: REF VECTOR[,WORD];
    	dummy = dbg$get_memory (1);
    	IF NOT dbg$ncis_add (dummy[1], 0, cis_while, 0, FALSE, 0, .message_vect)
    	THEN
    	    RETURN sts$k_severe;
    	END;
 
    ! Return success.
    !
    RETURN sts$k_success;

    END; ! dbg$nexecute_while

GLOBAL ROUTINE dbg$nparse_for (input_desc, verb_node, message_vect) =
!
! Functional Description
!
!	ATN parse network for the FOR verb.
!	This routine takes a verb node for the FOR verb, and a string
!	descriptor for the remaining (unparsed) input.
!	A command execution tree is built. The form of the tree is:
!
!	 -----------       -----------       ----------- 	 -----------
!	| verb node |-->--| noun node |-->--| noun node | -->-- | noun node |
!        -----------       -----------       -----------         -----------
!
!	The first noun node contains a counted string with the name of the
!	loop variable.
!	The second noun node contains value descriptors with the lower and
!	upper bounds, and loop increment
!	The third noun node contains a counted string with the command list.
!  
! Formal Parameters
!
!	input_desc	- A longword containing the address of the 
!			  	command input descriptor.
!	verb_node	- A longword containing the address of the verb node.
!	message_vect	- The address of a longword to contain the address
!			  	of a standard message argument vector.
!
! Implicit Inputs
!
!	none
!
! Implicit Outputs
!	
!	On success, the command execution tree is constructed.
!	On failure, a message argument vector is constructed or obtained.
!
! Routine value
!
!	sts$k_success (1)	- Success. Command execution tree constructed.
!	sts$k_severe  (4)	- Failure. Error encountered. Message argument
!				  constructed and returned.
!
! Side Effects
!
!	Permanent storage is allocated for the string holding the action
!	clause and for the string holding the loop variable name.
!	This is released in DBG$NCIS_REMOVE after execution
! 	of the action clause.
!

    BEGIN

    MAP
	input_desc  : REF dbg$stg_desc,
	verb_node	: REF dbg$verb_node;

    BIND
    	dbg$cs_comma		= UPLIT BYTE (1, dbg$k_comma),
	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
   	dbg$cs_equal		= UPLIT BYTE (1, dbg$k_equal),
    	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
    	dbg$cs_by		= UPLIT BYTE (2, 'BY'),
	dbg$cs_do		= UPLIT BYTE (2, 'DO'),
    	dbg$cs_to		= UPLIT BYTE (2, 'TO');

    LOCAL
	link,				! Temporary to hold links in the command
    					!     execution tree.
	noun_node : REF dbg$noun_node,	! A node in the command execution tree.
	radix,				! Holds the current radix setting.
	status;				! Holds return status from subroutine
    					!     calls.


    ! Create and link a noun node
    !
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    verb_node[dbg$l_verb_object_ptr] = .noun_node;

    ! Pick up the name of the loop counter.
    ! Note that dbg$nread_name allocates permanent storage for the name.
    ! This must be released in DBG$NCIS_REMOVE when the command buffer is
    ! no longer needed.
    !
    IF NOT dbg$nread_name (.input_desc, 
    			   noun_node [dbg$l_noun_value],
    			   .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Eat the =
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
    THEN
    	report_error;

    ! Create and link a noun node
    !
    link = noun_node [dbg$l_noun_link];
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    .link = .noun_node;

    ! Determine the current radix.
    !
    radix  = .dbg$gb_radix[dbg$b_radix_input];

    ! Obtain a value descriptor for the lower bound. The noun_value field
    ! points to this descriptor.
    !
    STATUS = DBG$NPARSE_EXPRESSION(.INPUT_DESC, .RADIX,
				NOUN_NODE [DBG$L_NOUN_VALUE],
				TOKEN$K_TERM_TO, .MESSAGE_VECT);

    ! The return status should be "warning", meaning that an expression
    ! was parsed and further input reamins. If an expression was parsed
    ! but no input remains, then DBG$NPARSE_EXPRESSION will return success.
    ! In this context, it is an error since "REPEAT count" by itself 
    ! is an error.
    !
    IF .status EQL sts$k_success
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Severe status is also an error.
    !
    IF .status EQL sts$k_severe
    THEN
    	RETURN sts$k_severe;

    ! Eat the "TO".
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_to, 2)
    THEN
    	report_error;

    ! Obtain a value descriptor for the upper bound. The noun_value2 field
    ! points to this descriptor.
    !
    STATUS = DBG$NPARSE_EXPRESSION(.INPUT_DESC, .RADIX,
				NOUN_NODE [DBG$L_NOUN_VALUE2],
				TOKEN$K_TERM_BY, .MESSAGE_VECT);


    ! The return status should be "warning", meaning that an expression
    ! was parsed and further input reamins. If an expression was parsed
    ! but no input remains, then DBG$NPARSE_EXPRESSION will return success.
    ! In this context, it is an error since "REPEAT count" by itself 
    ! is an error.
    !
    IF .status EQL sts$k_success
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Severe status is also an error.
    !
    IF .status EQL sts$k_severe
    THEN
    	RETURN sts$k_severe;

    ! Check for BY clause.
    !
    IF dbg$nmatch (.input_desc, dbg$cs_by, 2)
    THEN
    	BEGIN

        ! Obtain a value descriptor for the increment. 
        !
        STATUS = DBG$NPARSE_EXPRESSION(.INPUT_DESC, .RADIX,
				NOUN_NODE [DBG$L_ADJECTIVE_PTR],
				TOKEN$K_TERM_DO, .MESSAGE_VECT);

        ! The return status should be "warning", meaning that an expression
        ! was parsed and further input reamins. If an expression was parsed
        ! but no input remains, then DBG$NPARSE_EXPRESSION will return success.
        ! In this context, it is an error since "FOR I=1 TO N BY" by itself 
        ! is an error.
        !
        IF .status EQL sts$k_success
        THEN
    	    BEGIN
    	    .message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	    RETURN sts$k_severe;
    	    END;

        ! Severe status is also an error.
        !
        IF .status EQL sts$k_severe
        THEN
    	    RETURN sts$k_severe;

    	END

    ELSE
    	noun_node [dbg$l_adjective_ptr] = 0;

    ! Eat the "DO".
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_do, 2)
    THEN
    	report_error;

    ! Allocate and link a noun node for the action clause.
    !
    link = noun_node [dbg$l_noun_link];
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    .link = .noun_node;

    ! Eat the left parenthesis which we require be present.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    THEN
    	report_error;

    ! Put a pointer to the counted string representing the action
    ! clause into the second noun node. (Note - the counted string
    ! is constructed out of "permanent" memory which is released
    ! in DBG$NCIS_REMOVE).
    ! The third argument indicates that save_break_buffer is not being
    ! called during parsing of a SET BREAK DO (The routine behaves
    ! slightly differently in that case)
    !
    dbg$nsave_break_buffer (.input_desc, noun_node [dbg$l_noun_value]);

    ! Return success.
    !
    RETURN sts$k_success;

    END;

GLOBAL ROUTINE dbg$nexecute_for (verb_node,message_vect) =
!++
! Functional Description
!	
!	This routine performs the action associated with the FOR
!	command.
!
! Formal Parameters
!
!	verb_node	- A longword containing the address of the
!			  head (verb) node.
!	message_vect	- The address of a longword to contain the
!			  address of an error message vector
!
! Implicit Inputs
!
!	The command tree contains a verb node and a linked list
!	of three noun nodes. (See the diagram in the header for
!	DBG$NPARSE_FOR). 
!
! Routine Value
!
!	A completion code.
!
! Completion Codes
!
!	sts$k_success (1) 	- Success. Command executed
!	sts$k_severe (4)	- Failure. The command could not be
!				  executed. An error message is constructed.
!
! Side Effects
!
!	None
!--
    BEGIN

    MAP 
        verb_node : REF dbg$verb_node;

    LOCAL
    	action_node: 	REF dbg$noun_node,	! The noun node for the action clause
    	action_string:	REF VECTOR[,WORD],	! Counted string with the action clause
    	bounds_node: REF dbg$noun_node,		! Noun node with the upper and
    						!     lower bounds
    	dummy,					! Dummy output parameter
    	loop_incr,				! Loop increment
    	lower_bound,				! An integer with the lower 
    						!     loop bound
    	new_valdesc: REF dbg$valdesc,		! A copy of a value descriptor
    	new_varname,				! Pointer to a copy of the
    						!     variable name
    	symid_list,				! Points to a list of symids
    	upper_bound,				! An integer with the upper 
    						!     loop bound
    	valdesc: REF dbg$valdesc,		! A pointer to a value 
    						!     descriptor
    	var_node: REF dbg$noun_node,		! The noun node with the loop
    						!     variable
    	var_name: REF VECTOR[,BYTE],		! The counted string with the
    						!     variable name
    	vax_desc: 	dbg$stg_desc;		! Target of the conversion from
    						!    the value descriptor 
    						!    representing the count.
    ! Recover the noun nodes.
    !
    var_node = .verb_node [dbg$l_verb_object_ptr];
    var_name = .var_node [dbg$l_noun_value];
    bounds_node = .var_node [dbg$l_noun_link];
    valdesc = .bounds_node [dbg$l_noun_value];
    action_node = .bounds_node [dbg$l_noun_link];
    action_string = .action_node [dbg$l_noun_value];

    ! Set up the vax descriptor for the bounds.
    ! This vax descriptor is of type integer longword, and is used to convert the
    ! language specific value descriptor for loop bounds to an 
    ! integer quantity that we can use in a language-independent way.
    !
    vax_desc [dsc$b_class] = dsc$k_class_s;
    vax_desc [dsc$b_dtype] = dsc$k_dtype_l;
    vax_desc [dsc$w_length] = 4;
    vax_desc [dsc$a_pointer] = lower_bound;

    ! Do the conversion from value descriptor to integer.
    !
    IF NOT dbg$ntype_conv (.valdesc,
    			   dbg$k_default,
    		 	   dbg$k_vax_desc,
    			   vax_desc,
    			   .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Do the conversion again, this time picking up the upper bound.
    !
    vax_desc [dsc$a_pointer] = upper_bound;
    IF NOT dbg$ntype_conv (.bounds_node [dbg$l_noun_value2],
    			   dbg$k_default,
    		 	   dbg$k_vax_desc,
    			   vax_desc,
    			   .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Do the conversion once again, this time with the loop increment.
    !
    IF .bounds_node [dbg$l_adjective_ptr] EQL 0
    THEN
    	loop_incr = 1
    ELSE
    	BEGIN
        vax_desc [dsc$a_pointer] = loop_incr;
        IF NOT dbg$ntype_conv (.bounds_node [dbg$l_adjective_ptr],
    			       dbg$k_default,
    		 	       dbg$k_vax_desc,
    			       vax_desc,
    			       .message_vect)
        THEN
    	    RETURN sts$k_severe;
    	END;

    ! If the loop increment is zero then signal an error.
    !
    IF .loop_incr EQL 0
    THEN
    	SIGNAL (dbg$_loopincr);

    ! If the upper bound is below the lower bound, do nothing.
    !
    IF (.loop_incr GTR 0 AND .upper_bound LSS .lower_bound)
    OR (.loop_incr LSS 0 AND .upper_bound GTR .lower_bound)
    THEN
    	RETURN sts$k_success;

    ! Make a value descriptor for the initial value of the loop variable.
    !
    new_valdesc = dbg$get_memory (dbg$k_valdesc_base_size+4);
    new_valdesc[dbg$w_dhdr_length] = (dbg$k_valdesc_base_size * 4) + 16;
    new_valdesc[dbg$b_dhdr_type] = dbg$k_value_desc;
    new_valdesc[dbg$b_dhdr_lang] = .dbg$gb_language;
    new_valdesc[dbg$b_dhdr_kind] = rst$k_data;
    new_valdesc[dbg$b_dhdr_fcode] = rst$k_type_atomic;
    new_valdesc[dbg$b_value_class] = dsc$k_class_s;
    new_valdesc[dbg$b_value_dtype] = dsc$k_dtype_l;
    new_valdesc[dbg$w_value_length] = 4;
    new_valdesc[dbg$l_value_pointer] = new_valdesc[dbg$l_value_value0];
    new_valdesc[dbg$l_value_value0] = .lower_bound;   

    ! Also make a copy of the variable name. This is because the original
    ! varname pointer is being saved away by dbg$ncis_add and we don't
    ! want to free it twice.
    !
    new_varname = dbg$get_memory (1+.var_name[0]/4);
    ch$move (1+.var_name[0], .var_name, .new_varname);
    IF NOT dbg$def_sym_add (.new_varname, define_value, 
    			    .new_valdesc,
    			    FALSE, dummy, .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Add a link to the command input stream, containing the action
    ! string and the upper bound.
    !
    IF NOT dbg$ncis_add (action_string[1], .action_string[0], cis_for,
    		 .upper_bound, .var_name, .loop_incr, .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Return success.
    !
    RETURN sts$k_success;

    END; ! dbg$nexecute_repeat

GLOBAL ROUTINE dbg$nparse_repeat(input_desc, verb_node, message_vect) =
!
! Functional Description
!
!	ATN parse network for the REPEAT verb.
!	This routine takes a verb node for the REPEAT verb, and a string
!	descriptor for the remaining (unparsed) input.
!	A command execution tree is built. The form of the tree is:
!
!	 -----------       -----------       ----------- 
!	| verb node |-->--| noun node |-->--| noun node |
!        -----------       -----------       ----------- 
!
!	The first noun node points to a value descriptor for the count.
!	The second noun node points to a counted string with the action clause.
!  
! Formal Parameters
!
!	input_desc	- A longword containing the address of the 
!			  	command input descriptor.
!	verb_node	- A longword containing the address of the verb node.
!	message_vect	- The address of a longword to contain the address
!			  	of a standard message argument vector.
!
! Implicit Inputs
!
!	none
!
! Implicit Outputs
!	
!	On success, the command execution tree is constructed.
!	On failure, a message argument vector is constructed or obtained.
!
! Routine value
!
!	sts$k_success (1)	- Success. Command execution tree constructed.
!	sts$k_severe  (4)	- Failure. Error encountered. Message argument
!				  constructed and returned.
!
! Side Effects
!
!	Permanent storage is allocated for the string holding the action
!	clause; this is released in DBG$NEXECUTE_REPEAT after execution
! 	of the action clause.
!

    BEGIN

    MAP
	input_desc  : REF dbg$stg_desc,
	verb_node	: REF dbg$verb_node;

    BIND
	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
	dbg$cs_do		= UPLIT BYTE (2, 'DO');

    LOCAL
	link,				! Temporary to hold links in the command
    					!     execution tree.
	noun_node : REF dbg$noun_node,	! A node in the command execution tree.
	radix,				! Holds the current radix setting.
	status;				! Holds return status from subroutine
    					!     calls.


    ! Create and link a noun node
    !
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    verb_node[dbg$l_verb_object_ptr] = .noun_node;

    ! Determine the current radix.
    !
    radix  = .dbg$gb_radix[dbg$b_radix_input];

    ! Obtain a value descriptor for the count. The first noun node
    ! points to this descriptor.
    !
    STATUS = DBG$NPARSE_EXPRESSION(.INPUT_DESC, .RADIX,
				NOUN_NODE [DBG$L_NOUN_VALUE],
				TOKEN$K_TERM_DO, .MESSAGE_VECT);


    ! The return status should be "warning", meaning that an expression
    ! was parsed and further input reamins. If an expression was parsed
    ! but no input remains, then DBG$NPARSE_EXPRESSION will return success.
    ! In this context, it is an error since "REPEAT count" by itself 
    ! is an error.
    !
    IF .status EQL sts$k_success
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Severe status is also an error.
    !
    IF .status EQL sts$k_severe
    THEN
    	RETURN sts$k_severe;

    ! Eat the DO.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_do, 1)
    THEN
    	BEGIN
    	.message_vect = 
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
    	RETURN sts$k_severe;
        END;

    ! Allocate and link a noun node for the action clause.
    !
    link = noun_node [dbg$l_noun_link];
    noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    .link = .noun_node;

    ! Eat the left parenthesis which we require be present.
    !
    IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    THEN
    	BEGIN
    	.message_vect =
    	    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	     THEN
    		dbg$nmake_arg_vect (dbg$_needmore)
    	     ELSE
    		BEGIN
    		SIGNAL(dbg$_needparen);
    		dbg$nsyntax_error (dbg$nnext_word (.input_desc))
    		END);
    	RETURN sts$k_severe;
    	END;

    ! Put a pointer to the counted string representing the action
    ! clause into the second noun node. (Note - the counted string
    ! is constructed out of "permanent" memory which is released
    ! in DBG$NEXECUTE_REPEAT).
    ! The third argument indicates that save_break_buffer is not being
    ! called during parsing of a SET BREAK DO (The routine behaves
    ! slightly differently in that case)
    !
    dbg$nsave_break_buffer (.input_desc, noun_node [dbg$l_noun_value]);

    ! Return success.
    !
    RETURN sts$k_success;

    END;

GLOBAL ROUTINE dbg$nexecute_repeat (verb_node,message_vect) =
!++
! Functional Description
!	
!	This routine performs the action associated with the REPEAT
!	command.
!
! Formal Parameters
!
!	verb_node	- A longword containing the address of the
!			  head (verb) node.
!	message_vect	- The address of a longword to contain the
!			  address of an error message vector
!
! Implicit Inputs
!
!	The command tree contains a verb node and a linked list
!	of two noun nodes. (See the diagram in the header for
!	DBG$NPARSE_REPEAT). 
!
! Routine Value
!
!	A completion code.
!
! Completion Codes
!
!	sts$k_success (1) 	- Success. Command executed
!	sts$k_severe (4)	- Failure. The command could not be
!				  executed. An error message is constructed.
!
! Side Effects
!
!	None
!--
    BEGIN

    MAP 
        verb_node : REF dbg$verb_node;

    LOCAL
    	action_node: 	REF dbg$noun_node,	! The noun node for the action clause
    	action_string:	REF VECTOR[,WORD],	! Counted string with the action clause
    	count_node: REF dbg$noun_node,		! The noun node for the count
    	count_value,				! The actual count
    	vax_desc: 	dbg$stg_desc;		! Target of the conversion from
    						!    the value descriptor 
    						!    representing the count.

    ! Recover the noun nodes.
    !
    count_node = .verb_node [dbg$l_verb_object_ptr];
    action_node = .count_node [dbg$l_noun_link];

    ! Set up the vax descriptor for the count.
    ! This vax descriptor is of type integer longword, and is used to convert the
    ! language specific value descriptor for a count to an 
    ! integer quantity that we can use in a language-independent way.
    !
    vax_desc [dsc$b_class] = dsc$k_class_s;
    vax_desc [dsc$b_dtype] = dsc$k_dtype_l;
    vax_desc [dsc$w_length] = 4;
    vax_desc [dsc$a_pointer] = count_value;

    ! Initialize count_value to 0
    !
    count_value = 0;

    ! Do the conversion from value descriptor to boolean.
    !
    IF NOT dbg$ntype_conv (.count_node [dbg$l_noun_value],
    			   dbg$k_default,
    		 	   dbg$k_vax_desc,
    			   vax_desc,
    			   .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Recover the string.
    ! 
    action_string = .action_node [dbg$l_noun_value];

    ! Add a link to the command input stream, containing the action
    ! string and the repeat count.
    !
    IF NOT dbg$ncis_add (action_string[1], .action_string[0], cis_repeat,
    		 .count_value, 0, 0, .message_vect)
    THEN
    	RETURN sts$k_severe;

    ! Return success.
    !
    RETURN sts$k_success;

    END; ! dbg$nexecute_repeat
END
ELUDOM
