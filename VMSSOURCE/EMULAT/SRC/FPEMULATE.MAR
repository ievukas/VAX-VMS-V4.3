 	.TITLE	VAX$EMULATE_FP - Emulate floating-point instructions
	.IDENT	/V04-000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: VMS Executive floating point emulation
;
; ABSTRACT:
;
;	Loadable code that emulates F, D, G and H floating instructions on
;	any processor.  Octaword integer emulation is included.
;
; ENVIRONMENT: Runs at any access mode, AST Reentrant
;
; AUTHOR: Steven B. Lionel, 22-March-1983
;
;	Emulation code based on LIB$EMULATE by Derek Zave.
;
; MODIFIED BY:
;
;       JCW1010		Jeffrey C. Wiener	21-Aug-1984
;	Added a missing CLRL REG_R1(FP) instruction to the POLYF emulation.
;
;	RNG0009		Rod N. Gamache		14-Aug-1984
;	Only require a P1 control region on exceptions if the exception
;	did not occur in kernel mode (i.e. we have to switch stacks), in
;	the routine VAX$OPCDEC.
;
;       JCW1008         Jeffrey C. Wiener       10-Aug-1984
;       Corrected a BBS instruction in MULTIPLY__FFLOAT. It had referred
;       to FRACTION1+8(FP). It should have been FRACTION1+12(FP)
;
;	LJK0025		Lawrence J. Kenah	8-Mar-1984
;	Change PRVMOD field in PSL that is in effect while emulator is
;	executing so that PROBEs work with correct access mode when the
;	emulator is used in exec or supervisor mode. Fix incorrect
;	register usage in READ_FAULT.
;
;	LJK0015		Lawrence J. Kenah	2-Feb-1984
;	Fix error destinations for inaccessible instruction stream or 
;	exception stack. Use G^ addressing for SYS.STB symbols.
;
;	JCW1005		Jeffrey C. Wiener	11-January-1984
;	Corrected the discription of the algorithm used to divide unsigned
;	multiple length integers. A fix was also added to the associated
;	code to fix an outstanding DIVG/DIVH bug. The fix checks a "carry-
;	over". If the "carry-over" is negative, then the "carry-over" is
;	zeroed.
;
;	SBL1004		Steven B. Lionel	19-October-1983
;	Fix FLOAT_LONG to properly convert -2**32.
;
;	SBL1003		Steven B. Lionel	24-June-1983
;	Correct "emulated opcode" check for 2-byte opcodes.
;
;	SBL1002		Steven B. Lionel	23-May-1983
;	Add check for no P1 region.
;
;	SBL1001		Steven B. Lionel	22-March-1983
;	Adapt LIB$EMULATE for integration into the VMS executive.
;--

	.SBTTL	DECLARATIONS
;
; LIBRARY MACRO CALLS:
;
	$SSDEF			; System Status Codes
	$PSLDEF			; Processor Status Longword definitions
	$PRDEF			; Processor register definitions
	$ARCDEF			; Architecture support flag definitions

;
; EXTERNAL DECLARATIONS:
;
	.DSABL	GBL		; Force all external symbols to be declared
	.EXTRN	EXE$SRCHANDLER	; System routine that looks for handlers
	.EXTRN	EXE$UNWIND	; Unwind exception
	.EXTRN	EXE$OPCDEC	; VMS entry to handle SS$_OPCDEC
	.EXTRN	EXE$ACVIOLAT	; VMS entry to handle SS$_ACCVIO
	.EXTRN	EXE$GL_ARCHFLAG	; Architecture support flags
	.EXTRN	CTL$AL_STACK	; Stack limit arrays
	.EXTRN	CTL$AL_STACKLIM	; Stack limit arrays

;
; MACROS:
;

;	Macro for Comparing Condition Codes
	.MACRO	CMPCOND	COND,LOC
	CMPZV	#3,#26,LOC,#COND@-3
	.ENDM

;	Macro for loading OP_TYPES with the types of the various operands,
	.MACRO	SET_OP_TYPES	OP1=F,OP2=F,OP3=F,OP4=F,OP5=F,OP6=F
	.NARG	N_ARGS
	.IF	EQ N_ARGS-6	; 6 arguments?
	MOVW	#<TYP_'OP5'+<TYP_'OP6'@8>>, OP_TYPES4(FP)
	.ENDC
	.IF	EQ N_ARGS-5	; 5 arguments?
	MOVB	#<TYP_'OP5'>, OP_TYPES4(FP)
	.ENDC
	.IF	GT N_ARGS-2	; more than 2 arguments?
	MOVL	#<TYP_'OP1'+ -
		 <TYP_'OP2'@8>+ -
		 <TYP_'OP3'@16>+ -
		 <TYP_'OP4'@24>>, OP_TYPES(FP)
	.ENDC
	.IF	EQ N_ARGS-2	; 2 arguments?
	MOVW	#<TYP_'OP1'+<TYP_'OP2'@8>>, OP_TYPES(FP)
	.ENDC
	.IF	EQ N_ARGS-1	; 1 argument?
	MOVB	#TYP_'OP1', OP_TYPES(FP)
	.ENDC
	.ENDM

;
; EQUATED SYMBOLS:
;
;	See body of routine
;
; OWN STORAGE:
;
;	NONE
;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*			Assorted Definitions		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;
	;	Parameters
	;
CALL_ARGS =	40			; flexible stack space (longwords)
	;
	;	Opcode range limits
	;
LO_1BYTE =	^X40
HI_1BYTE =	^X76
LO_2BYTE =	^X32
HI_2BYTE =	^XFF
	;
	;	Operand Area Layout
	;
ZERO	=	0			; zero indicator (byte)
SIGN	=	1			; sign indicator (byte)
POWER	=	4			; exponent (longword)
FRACTION =	8			; fraction area (octaword)
OPERAND_SIZE =	24			; operand area size (bytes)
	;
	;	Bits in the Processor Status Longword (PSL)
	;
PSL_C	=	0			; carry indicator
PSL_V	=	1			; overflow indicator
PSL_Z	=	2			; zero indicator
PSL_N	=	3			; negative indicator
PSL_T	=	4			; trace enable indicator
PSL_IV	=	5			; integer overflow trap enable
PSL_FU	=	6			; floating underflow fault enable
PSL_CAM =	24			; low bit of current access mode
PSL_FPD =	27			; instruction first part done
PSL_TP	=	30			; trace pending indicator
	;
	;	Masks for the Processor Status Longword
	;
PSLM_C	=	1@PSL_C 		; carry indicator
PSLM_V	=	1@PSL_V 		; overflow indicator
PSLM_Z	=	1@PSL_Z 		; zero indicator
PSLM_N	=	1@PSL_N 		; negative indicator
PSLM_VC =	PSLM_V+PSLM_C		; overflow and carry indicators
PSLM_NZVC =	PSLM_VC+PSLM_N+PSLM_Z	; condition code
PSLM_NZ =	PSLM_N+PSLM_Z		; comparison codes
PSLM_NZV =	PSLM_NZ+PSLM_V		; bits other than carry
PSLM_LSS =	PSLM_N			; less than condition code
PSLM_EQL =	PSLM_Z			; equals condition code
PSLM_GTR =	0			; greater than condition code
	;
	;	Call Frame Layout
	;
HANDLER =	0			; condition handler location
SAVE_PSW =	4			; saved processor status word
SAVE_MASK =	6			; register save mask
MASK_ALIGN =	14			; bit position of alignment bits
SAVE_AP =	8			; user's argument pointer
SAVE_FP =	12			; user's frame pointer
SAVE_PC =	16			; return point
REG_R0	=	20			; user's R0
REG_R1	=	24			; user's R1
REG_R2	=	28			; user's R2
REG_R3	=	32			; user's R3
REG_R4	=	36			; user's R4
REG_R5	=	40			; user's R5
REG_R6	=	44			; user's R6
REG_R7	=	48			; user's R7
REG_R8	=	52			; user's R8
REG_R9	=	56			; user's R9
REG_R10 =	60			; user's R10
REG_R11 =	64			; user's R11
FRAME_END =	68			; end of call frame
	;
	;	Call Frame Extension Layout
	;
REG_AP	=	68			; user's AP
REG_FP	=	72			; user's FP
REG_SP	=	76			; user's SP
REG_PC	=	80			; user's PC
PSL	=	84			; user's PSL
LOCAL_END =	88			; end of Emulator local storage
TEMP	=	88			; temporary area for arithmetic
	;
	;	Local Storage Layout
	;
SAVE_ALIGN = 	HANDLER-1		; saved copy of alignment bits
SAVE_PARCNT =	SAVE_ALIGN-1		; saved copy of parameter count
MODE	=	SAVE_PARCNT-1		; access mode for probes
FLAGS	=	MODE-1			; indicator flag bits
SHORT_LOCAL =	FLAGS-1			; start of short local storage
REGMOD_PC =	SHORT_LOCAL-1		; changes to user's PC
REGMOD_SP =	REGMOD_PC-1		; changes to user's SP
REGMOD_FP =	REGMOD_SP-1		; changes to user's FP
REGMOD_AP =	REGMOD_FP-1		; changes to user's AP
REGMOD_R11 =	REGMOD_AP-1		; changes to user's R11
REGMOD_R10 =	REGMOD_R11-1		; changes to user's R10
REGMOD_R9 =	REGMOD_R10-1		; changes to user's R9
REGMOD_R8 =	REGMOD_R9-1		; changes to user's R8
REGMOD_R7 =	REGMOD_R8-1		; changes to user's R7
REGMOD_R6 =	REGMOD_R7-1		; changes to user's R6
REGMOD_R5 =	REGMOD_R6-1		; changes to user's R5
REGMOD_R4 =	REGMOD_R5-1		; changes to user's R4
REGMOD_R3 =	REGMOD_R4-1		; changes to user's R3
REGMOD_R2 =	REGMOD_R3-1		; changes to user's R2
REGMOD_R1 =	REGMOD_R2-1		; changes to user's R1
REGMOD_R0 =	REGMOD_R1-1		; changes to user's R0
ADDRESS1 =	REGMOD_R0-4		; temporary address area #1
ADDRESS2 =	ADDRESS1-4		; temporary address area #2
ADDRESS3 =	ADDRESS2-4		; temporary address area #3
OPERAND1 =	ADDRESS3-OPERAND_SIZE	; temporary operand area #1
OPERAND2 =	OPERAND1-OPERAND_SIZE	; temporary operand area #2
OPERAND3 =	OPERAND2-OPERAND_SIZE	; temporary operand area #3
OP_TYPES4 =	OPERAND3-4		; Four bytes for operand type codes
OP_TYPES=	OP_TYPES4-4		; Four more bytes for operand type codes
OP_INDEX = 	OP_TYPES-4		; Pointer to current byte of OP_TYPES
LOCAL_START =	OP_INDEX		; start of Emulator local storage
	;
	;	Indicator Bit Numbers
	;	
FLAG0	=	0			; inhibit local store check
FLAG1	=	1			; register mode operand
FLAG2	=	2			; (not assigned)
FLAG3	=	3			; (not assigned)
FLAG4	=	4			; (not assigned)
FLAG5	=	5			; (not assigned)
FLAG6	=	6			; (not assigned)
FLAG7	=	7			; temporary use
	;
	;	Indicator Bit Masks
	;
FLAG0M	=	1@0			; inhibit local store check
FLAG1M	=	1@1			; register mode operand
FLAG2M	=	1@2			; (not assigned)
FLAG3M	=	1@3			; (not assigned)
FLAG4M	=	1@4			; (not assigned)
FLAG5M	=	1@5			; (not assigned)
FLAG6M	=	1@6			; (not assigned)
FLAG7M	=	1@7			; temporary use
	;
	;	Fields in the Operand Areas
	;
ZERO1	=	OPERAND1+ZERO		; zero flag of OPERAND1
ZERO2	=	OPERAND2+ZERO		; zero flag of OPERAND2
ZERO3	=	OPERAND3+ZERO		; zero flag of OPERAND3
SIGN1	=	OPERAND1+SIGN		; sign of OPERAND1
SIGN2	=	OPERAND2+SIGN		; sign of OPERAND2
SIGN3	=	OPERAND3+SIGN		; sign of OPERAND3
POWER1	=	OPERAND1+POWER		; exponent of OPERAND1
POWER2	=	OPERAND2+POWER		; exponent of OPERAND2
POWER3	=	OPERAND3+POWER		; exponent of OPERAND3
FRACTION1 =	OPERAND1+FRACTION	; fraction of OPERAND1
FRACTION2 =	OPERAND2+FRACTION	; fraction of OPERAND2
FRACTION3 =	OPERAND3+FRACTION	; fraction of OPERAND3
	;
	;	Access Type Code Definitions
	;
TYPE_READ =	1			; read only access
TYPE_WRITE =	2			; write only access
TYPE_MODIFY =	3			; modify access
TYPE_ADDRESS =	4			; address access
	;
	;	Data Type Code Definitions
	;
TYP_B	 =	1			; byte
TYP_W	 =	2			; word
TYP_L	 =	3			; longword
TYP_Q	 =	4			; quadword
TYP_O	 =	5			; octaword
TYP_F	 =	6			; F_floating
TYP_D	 =	7			; D_floating
TYP_G	 =	8			; G_floating
TYP_H	 =	9			; H_floating

	;
	; Instruction type definitions for optimization check
	;
IT_D = ARC$M_DFLT_EMUL@-ARC$V_DFLT_EMUL
IT_F = ARC$M_FFLT_EMUL@-ARC$V_DFLT_EMUL
IT_G = ARC$M_GFLT_EMUL@-ARC$V_DFLT_EMUL
IT_H = ARC$M_HFLT_EMUL@-ARC$V_DFLT_EMUL
IT_X = 0	; none

	.SUBTITLE	VAX$OPCDEC
;+
; Functional Description:
;
;	This routine is entered in kernel mode through the SCB vector for
;	the OPCDEC exception. It determines if the instruction that caused
;	the fault is one supported by this emulator. If so, the rest of the
;	emulation is carried out by an instruction-specific routine. If not,
;	control is transferred to the OPCDEC handler that is a part of the
;	VMS executive to allow normal exception dispatching to take place.
;
; Input Parameters:
;
;	0(SP) - PC of faulting instruction
;	4(SP) - PSL at the time of the fault
;
; Output Parameters:
;
;	The real output from this routine is the routine to which control
;	is passed, namely the routine that handles each separate instruction.
;-

	.PSECT	VAX$FPE_NONPAGED PIC, USR, CON, REL, LCL, SHR,-
		EXE, RD, NOWRT, QUAD
	.ALIGN	QUAD

VAX$OPCDEC::

	MOVQ	R0, -(SP)		; Save R0 and R1

; It is not clear whether the following PROBER is necessary. One approach is 
; that an inaccessible opcode would cause an access violation rather than
; a reserved instruction exception.

	MOVL	8(SP), R0		; R0 contains the PC of the instruction
	IFNORD	#1, (R0), 15$		; Insure that opcode can be read
	MOVZBL	(R0)+, R1		; Get first opcode byte, increment "PC"
	BBC	R1, W^OP_MASK_1BYTE, 90$; Test for opcode not emulated
	CMPB	R1, #^XFD		; Is it a two-byte opcode?
	BNEQ	10$			; Skip if not
	IFNORD	#1, (R0), 15$		; Can second byte be read?
	MOVZBL	(R0), R1		; Fetch second byte
	BBC	R1, W^OP_MASK_2BYTE, 90$; Test for opcode not emulated

;+
; Now the kernel stack looks as follows:
;
;	00(SP)	- Saved R0
;	04(SP)	- Saved R1
;	08(SP)	- PC of instruction
;	12(SP)	- PSL of instruction
;
;
; Switch stacks to that of the exception, push onto that stack the PC/PSL.
; Push the PSL with T, TP and FPD bits clear, the address of
; EMULATE_FP, and then REI to EMULATE_FP.
;-

10$:	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,12(SP),R1 ; Get previous mode
	BEQL	20$			; Br if kernel, no stack change needed
	IFNORD	#4,G^CTL$AL_STACK,90$	; Is there a control region?
					; Br if not, handle as a real exception
	ASSUME	PSL$C_KERNEL EQ 0
	ASSUME	PR$_ESP EQ PSL$C_EXEC
	ASSUME	PR$_SSP EQ PSL$C_SUPER
	ASSUME	PR$_USP EQ PSL$C_USER
	MFPR	R1, R0			; Get address of stack of excpt mode
	IFNOWRT	#8, -8(R0), 40$		; Br if cannot copy to excpt mode stk
	CMPL	R0,G^CTL$AL_STACK[R1]	; Top address of stack in range?
	BGTRU	40$			; If GTRU no.
	SUBL2	#8, R0			; Get new low stack address
	CMPL	#PSL$C_USER,R1		; Previous mode user?
	BEQL	12$			; If EQL yes.
	CMPL	R0,G^CTL$AL_STACKLIM[R1]; Bottom address of stack in range?
	BLSSU	40$			; If LSSU no.
12$:	MOVQ	8(SP), (R0)		; Push PC/PSL
	MTPR	R0, R1			; Set stack pointer to new value
	BICL2	#<PSL$M_TP!PSL$M_TBIT!PSL$M_FPD>,12(SP) ; Clear bits in PSL
	INSV	R1,#PSL$V_PRVMOD,#PSL$S_PRVMOD,12(SP)	; Set PRVMOD = CURMOD
	MOVAB	W^VAX$$EMULATE_FP, 8(SP); Set entry address
	MOVQ	(SP)+, R0		; Pop saved R0 and R1
	REI				; Jump to EMULATE_FP

15$:	BRB	40$			; Chain branch for ACCVIO test

;+
; We come here if the previous mode is kernel, since we don't need to
; switch modes.
;-

20$:	MOVQ	(SP)+, R0		; Pop saved R0 and R1
	BRW	VAX$$EMULATE_FP		; Emulate the instruction

;+
; If we don't handle the instruction, remove the things we pushed on the
; stack and jump to the EXECPTION code that handles SS$_OPCDEC
;-

90$:	MOVQ	(SP)+, R0		; Restore R0-R1
	JMP	G^EXE$OPCDEC		; Reflect exception

; If a PROBE of an outer access mode fails, then the exception is reported
; as an access violation rather than as a reserved instruction. This allows
; the stack expansion logic and other such things to be invoked without this
; emulator worrying about such things.

40$:	MOVQ	(SP), -(SP)		; Move saved R0-R1
	MOVL	R0,12(SP)		; Store inaccessible stack address
	MOVQ	(SP)+,R0		; Restore R0-R1

; Note that the access violation mask generated here (always zero) is not
; correct for the extremely rare case of an inaccessible exception stack.

	CLRL	(SP)			; Set mask to indicate a read
	JMP	G^EXE$ACVIOLAT		; Pass control to VMS handler


	.SBTTL	Mask of emulated opcodes

	;
	;	OP_MASK_1BYTE and OP_MASK_2BYTE are 256-bit bitmasks with
	;	bits set corresponding to opcodes of instructions that
	;	this emulator can handle.
	;

OP_MASK_1BYTE:		; Mask for 1-byte opcodes (including FD)
;		  FEDCBA9876543210FEDCBA9876543210
	.LONG	^B00000000000000000000000000000000	; 00-1F
	.LONG	^B00000000000000000000000000000000	; 20-3F
	.LONG	^B00000000011111111111111111111111	; 40-5F
	.LONG	^B00000000011111111111111111111111	; 60-7F
	.LONG	^B00000000000000000000000000000000	; 80-9F
	.LONG	^B00000000000000000000000000000000	; A0-BF
	.LONG	^B00000000000000000000000000000000	; C0-DF
	.LONG	^B00100000000000000000000000000000	; E0-FF

OP_MASK_2BYTE:		; Mask for 2-byte opcodes (second byte index)
;		  FEDCBA9876543210FEDCBA9876543210
	.LONG	^B00000000000000000000000000000000	; 00-1F
	.LONG	^B00000000000011000000000000000000	; 20-3F
	.LONG	^B00000000011111111111111111111111	; 40-5F
	.LONG	^B11110000011111111111111111111111	; 60-7F
	.LONG	^B00000011000000000000000000000000	; 80-9F
	.LONG	^B00000000000000000000000000000000	; A0-BF
	.LONG	^B00000000000000000000000000000000	; C0-DF
	.LONG	^B00000000110000000000000000000000	; E0-FF

	.SBTTL	VAX$$EMULATE_FP

	;
	;	VAX$$EMULATE_FP - Emulator Entrance
	;
	;		entered by branching
	;
	;		parameters	0(SP)	Instruction PC
	;				4(SP)	Instruction PSL
	;
	;	Discussion
	;
	;	    This routine provides a simple method of activating the
	;	Emulator. The PC and PSL for the instruction being emulated
	;	are pushed onto the stack and the routine is entered. The 
	;	routine simply allocates the simulated user stack space for
	;	the Emulator and calls the emulation procedure.
	;
	;	Notes:	1. The FPD bit may be set in the pushed PSL. This
	;		   bit will only be interpreted during the emulation
	;		   of the POLYx instructions where it is
	;		   interpreted as described in the VAX System 
	;		   Reference Manual.
	;
	;

	.PSECT	VAX$FPE_PAGED	PIC, USR, CON, REL, LCL, SHR,-
		EXE, RD, NOWRT, QUAD

VAX$$EMULATE_FP::
	MOVAB	-4*<CALL_ARGS-2>(SP),SP ; allocate the parameter block
	CALLS	#CALL_ARGS,B^EMULATOR	; call the Emulator
	JMP	G^EXE$OPCDEC		; shouldn't return here - 
					; indicate OPCDEC as fallback
	;

	.SBTTL	EMULATOR

	;
	;	EMULATOR - Start Instruction Emulation
	;
	;		parameters:	( Described Below )
	;
	;	Discussion
	;
	;	    This routine initializes the Emulator, processes the
	;	instruction code, and passes control to the appropriate 
	;	instruction emulation routine. The parameter list consists of
	;	CALL_ARGS longwords of which only the last two have any 
	;	meaning. These parameters are the PC and PSL for the emulation.
	;	The position following the parameter list is the
	;	user's stack pointer. The area covered by the parameter list
	;	is used to emulate the top of the user's stack.
	;
	;	    When the routine is entered the CALLS instruction saves
	;	the user's registers R0 to R11 in order and saves AP and FP
	;	elsewhere in the frame. The routine extends the saved
	;	registers by saving the user's AP, FP, SP, PC, and PSL after
	;	the saved register area (the last two are taken from the
	;	parameter list).
	;
	;	    The local storage is allocated by extending the stack and
	;	the register modification bytes are cleared (these bytes
	;	record small changes to the register values). The cell MODE
	;	is set equal to the current access mode for use in probing
	;	memory references. The alignment bits in the call frame and 
	;	the call parameter count are also saved so there is a safe
	;	copies to use when processing unwinds.
	;
	;	Notes:	1. From the description of the way the simulated
	;		   register area is constructed, it is clear that
	;		   the length longword of the parameter list is
	;		   overwritten. All of the methods of leaving the
	;		   Emulator put this longword back together. The
	;		   internal condition handler does this if it 
	;		   detects an unwind.
	;
	;		2. Here are some more details on the register change
	;		   bytes: Until the very end of instruction processing
	;		   when the results are output, all of the changes
	;		   which occur to the registers are caused by adding
	;		   or subtracting small values to or from a register.
	;		   These changes are also recorded in a corresponding 
	;		   register change byte so the register may be 
	;		   restored to its original value if a fault occurs.
	;		   Those instructions that save results in the
	;		   registers in order to be interruptable, use the FPD
	;		   bit in the PSL to indicate that this has been done
	;		   so different logic should be used for restarting
	;		   the instruction after a fault. In this case the 
	;		   change bytes should be cleared when FPD is set
	;		   except for the one for PC.
	;
	;		3. The location of the instruction being emulated is
	;		   stored in the return PC for the Emulator's frame
	;		   so it may be easily located from the traceback
	;		   report if the Emulator blows up.
	;
EMULATOR:				; entrance
	.WORD	^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; entry mask
	MOVAB	LOCAL_START(FP),SP	; allocate the local storage
	EXTZV	#MASK_ALIGN,#2,SAVE_MASK(FP),R0 ; R0 = alignment bits
	MOVB	R0,SAVE_ALIGN(FP)	; save them
	MOVB	#CALL_ARGS,SAVE_PARCNT(FP) ; save the parameter count
	CLRB	FLAGS(FP)		; clear the flag bits
	MOVAB	W^COND_HANDLER,HANDLER(FP) ; set up the condition handler
	CLRQ	REGMOD_R0(FP)		; clear register modification bytes
	CLRQ	REGMOD_R8(FP)		; clear register modification bytes
	MOVQ	SAVE_AP(FP),REG_AP(FP)	; move user's AP and FP into place
	MOVAB	4*<CALL_ARGS+1>(AP),REG_SP(FP) ; move user's SP into place
	MOVQ	4*<CALL_ARGS-1>(AP),REG_PC(FP) ; move PC and PSL into place
	EXTZV	#PSL_CAM,#2,PSL(FP),R0	; R0 = user's access mode
	MOVB	R0,MODE(FP)		; save it for probes
	MOVL	REG_PC(FP),R11		; get instruction PC
	MOVL	R11,SAVE_PC(FP)		; save PC in the return PC
	MOVAB	OP_TYPES(FP), OP_INDEX(FP); Initialize ptr to operand type codes
	MOVZBL	(R11)+,R0		; get first opcode byte
	INCL	REG_PC(FP)		; increment emulated PC
	INCL	REGMOD_PC(FP)		; remember the increment
	BBC	#PSL_T,PSL(FP),10$	; check for T-bit
	BBSS	#PSL_TP,PSL(FP),10$	; set TP if T set
10$:	BICL2	#PSLM_V,PSL(FP)		; clear the V bit in the PSL
	CMPB	R0,#^XFD		; two-byte instruction?
	BNEQ	DISPATCH_1BYTE		; skip if not
	MOVZBL	(R11)+,R0		; get next opcode byte
	INCL	REG_PC(FP)		; increment emulated PC
	INCL	REGMOD_PC(FP)		; remember the increment
	BRW	DISPATCH_2BYTE		; execute 2-byte opcode

	.SBTTL	DISPATCH_1BYTE

	;
	;	DISPATCH_1BYTE - Branch to emulation routine for 1-byte opcode
	;
	;		entered by branching
	;
	;		R0 contains opcode
	;

DISPATCH_1BYTE:
	CASEB	R0,#^X40,#<^X76-^X40>	; from ADDF2 through CVTDF
1$:	.WORD	INST_ADDF2-1$		; 40	ADDF2
	.WORD	INST_ADDF3-1$		; 41	ADDF3
	.WORD	INST_SUBF2-1$		; 42	SUBF2
	.WORD	INST_SUBF3-1$		; 43	SUBF3
	.WORD	INST_MULF2-1$		; 44	MULF2
	.WORD	INST_MULF3-1$		; 45	MULF3
	.WORD	INST_DIVF2-1$		; 46	DIVF2
	.WORD	INST_DIVF3-1$		; 47	DIVF3
	.WORD	INST_CVTFB-1$		; 48	CVTFB
	.WORD	INST_CVTFW-1$		; 49	CVTFW
	.WORD	INST_CVTFL-1$		; 4A	CVTFL
	.WORD	INST_CVTRFL-1$		; 4B	CVTRFL
	.WORD	INST_CVTBF-1$		; 4C	CVTBF
	.WORD	INST_CVTWF-1$		; 4D	CVTWF
	.WORD	INST_CVTLF-1$		; 4E	CVTLF
	.WORD	INST_ACBF-1$		; 4F	ACBF
	.WORD	INST_MOVF-1$		; 50	MOVF
	.WORD	INST_CMPF-1$		; 51	CMPF
	.WORD	INST_MNEGF-1$		; 52	MNEGF
	.WORD	INST_TSTF-1$		; 53	TSTF
	.WORD	INST_EMODF-1$		; 54	EMODF
	.WORD	INST_POLYF-1$		; 55	POLYF
	.WORD	INST_CVTFD-1$		; 56	CVTFD
	.WORD	10$-1$			; 57
	.WORD	10$-1$			; 58	ADAWI
	.WORD	10$-1$			; 59
	.WORD	10$-1$			; 5A
	.WORD	10$-1$			; 5B
	.WORD	10$-1$			; 5C	INSQHI
	.WORD	10$-1$			; 5D	INSQTI
	.WORD	10$-1$			; 5E	REMQHI
	.WORD	10$-1$			; 5F	REMQTI
	.WORD	INST_ADDD2-1$		; 60	ADDD2
	.WORD	INST_ADDD3-1$		; 61	ADDD3
	.WORD	INST_SUBD2-1$		; 62	SUBD2
	.WORD	INST_SUBD3-1$		; 63	SUBD3
	.WORD	INST_MULD2-1$		; 64	MULD2
	.WORD	INST_MULD3-1$		; 65	MULD3
	.WORD	INST_DIVD2-1$		; 66	DIVD2
	.WORD	INST_DIVD3-1$		; 67	DIVD3
	.WORD	INST_CVTDB-1$		; 68	CVTDB
	.WORD	INST_CVTDW-1$		; 69	CVTDW
	.WORD	INST_CVTDL-1$		; 6A	CVTDL
	.WORD	INST_CVTRDL-1$		; 6B	CVTRDL
	.WORD	INST_CVTBD-1$		; 6C	CVTBD
	.WORD	INST_CVTWD-1$		; 6D	CVTWD
	.WORD	INST_CVTLD-1$		; 6E	CVTLD
	.WORD	INST_ACBD-1$		; 6F	ACBD
	.WORD	INST_MOVD-1$		; 70	MOVD
	.WORD	INST_CMPD-1$		; 71	CMPD
	.WORD	INST_MNEGD-1$		; 72	MNEGD
	.WORD	INST_TSTD-1$		; 73	TSTD
	.WORD	INST_EMODD-1$		; 74	EMODD
	.WORD	INST_POLYD-1$		; 75	POLYD
	.WORD	INST_CVTDF-1$		; 76	CVTDF

10$:	BRW	OPCODE_FAULT		; unrecognized opcode

	.SBTTL	DISPATCH_2BYTE

	;
	;	DISPATCH_2BYTE - Branch to emulation routine for 2-byte opcode
	;
	;		entered by branching
	;
	;		R0 contains second opcode byte
	;

DISPATCH_2BYTE:
	CASEB	R0,#^X32,#<^X7F-^X32>	; Covers CVTDH through PUSHAO
1$:	.WORD	INST_CVTDH-1$		; 32FD	CVTDH
	.WORD	INST_CVTGF-1$		; 33FD	CVTGF
	.WORD	10$-1$			; 34FD
	.WORD	10$-1$			; 35FD
	.WORD	10$-1$			; 36FD
	.WORD	10$-1$			; 37FD
	.WORD	10$-1$			; 38FD
	.WORD	10$-1$			; 39FD
	.WORD	10$-1$			; 3AFD
	.WORD	10$-1$			; 3BFD
	.WORD	10$-1$			; 3CFD
	.WORD	10$-1$			; 3DFD
	.WORD	10$-1$			; 3EFD
	.WORD	10$-1$			; 3FFD
	.WORD	INST_ADDG2-1$		; 40FD	ADDG2
	.WORD	INST_ADDG3-1$		; 41FD	ADDG3
	.WORD	INST_SUBG2-1$		; 42FD	SUBG2
	.WORD	INST_SUBG3-1$		; 43FD	SUBG3
	.WORD	INST_MULG2-1$		; 44FD	MULG2
	.WORD	INST_MULG3-1$		; 45FD	MULG3
	.WORD	INST_DIVG2-1$		; 46FD	DIVG2
	.WORD	INST_DIVG3-1$		; 47FD	DIVG3
	.WORD	INST_CVTGB-1$		; 48FD	CVTGB
	.WORD	INST_CVTGW-1$		; 49FD	CVTGW
	.WORD	INST_CVTGL-1$		; 4AFD	CVTGL
	.WORD	INST_CVTRGL-1$		; 4BFD	CVTRGL
	.WORD	INST_CVTBG-1$		; 4CFD	CVTBG
	.WORD	INST_CVTWG-1$		; 4DFD	CVTWG
	.WORD	INST_CVTLG-1$		; 4EFD	CVTLG
	.WORD	INST_ACBG-1$		; 4FFD	ACBG
	.WORD	INST_MOVG-1$		; 50FD	MOVG
	.WORD	INST_CMPG-1$		; 51FD	CMPG
	.WORD	INST_MNEGG-1$		; 52FD	MNEGG
	.WORD	INST_TSTG-1$		; 53FD	TSTG
	.WORD	INST_EMODG-1$		; 54FD	EMODG
	.WORD	INST_POLYG-1$		; 55FD	POLYG
	.WORD	INST_CVTGH-1$		; 56FD	CVTGH
	.WORD	10$-1$			; 57FD
	.WORD	10$-1$			; 58FD
	.WORD	10$-1$			; 59FD
	.WORD	10$-1$			; 5AFD
	.WORD	10$-1$			; 5BFD
	.WORD	10$-1$			; 5CFD
	.WORD	10$-1$			; 5DFD
	.WORD	10$-1$			; 5EFD
	.WORD	10$-1$			; 5FFD
	.WORD	INST_ADDH2-1$		; 60FD	ADDH2
	.WORD	INST_ADDH3-1$		; 61FD	ADDH3
	.WORD	INST_SUBH2-1$		; 62FD	SUBH2
	.WORD	INST_SUBH3-1$		; 63FD	SUBH3
	.WORD	INST_MULH2-1$		; 64FD	MULH2
	.WORD	INST_MULH3-1$		; 65FD	MULH3
	.WORD	INST_DIVH2-1$		; 66FD	DIVH2
	.WORD	INST_DIVH3-1$		; 67FD	DIVH3
	.WORD	INST_CVTHB-1$		; 68FD	CVTHB
	.WORD	INST_CVTHW-1$		; 69FD	CVTHW
	.WORD	INST_CVTHL-1$		; 6AFD	CVTHL
	.WORD	INST_CVTRHL-1$		; 6BFD	CVTRHL
	.WORD	INST_CVTBH-1$		; 6CFD	CVTBH
	.WORD	INST_CVTWH-1$		; 6DFD	CVTWH
	.WORD	INST_CVTLH-1$		; 6EFD	CVTLH
	.WORD	INST_ACBH-1$		; 6FFD	ACBH
	.WORD	INST_MOVH-1$		; 70FD	MOVH
	.WORD	INST_CMPH-1$		; 71FD	CMPH
	.WORD	INST_MNEGH-1$		; 72FD	MNEGH
	.WORD	INST_TSTH-1$		; 73FD	TSTH
	.WORD	INST_EMODH-1$		; 74FD	EMODH
	.WORD	INST_POLYH-1$		; 75FD	POLYH
	.WORD	INST_CVTHG-1$		; 76FD	CVTHG
	.WORD	10$-1$			; 77FD
	.WORD	10$-1$			; 78FD
	.WORD	10$-1$			; 79FD
	.WORD	10$-1$			; 7AFD
	.WORD	10$-1$			; 7BFD
	.WORD	INST_CLRO-1$		; 7CFD	CLRO,CLRH
	.WORD	INST_MOVO-1$		; 7DFD	MOVO
	.WORD	INST_MOVAO-1$		; 7EFD	MOVAO,MOVAH
	.WORD	INST_PUSHAO-1$		; 7FFD	PUSHAO,PUSHAH

10$:	CMPB	R0,#^X99		; CVTFG?
	BGTRU	12$			; Skip if not
	BEQL	11$			; Skip if yes
	CMPB	R0,#^X98		; CVTFH?
	BNEQ	90$			; Error if not
	BRW	INST_CVTFH		; Execute CVTFH
11$:	BRW	INST_CVTFG		; Execute CVTFG
12$:	CMPB	R0,#^XF6		; CVTHF?
	BGTRU	13$			; Skip if not
	BNEQ	90$			; Error if LSSU
	BRW	INST_CVTHF		; Execute CVTHF
13$:	CMPB	R0,#^XF7		; CVTHD?
	BNEQ	90$			; Error if not
	BRW	INST_CVTHD		; Execute CVTHD

90$:	BRW	OPCODE_FAULT		; Shouldn't happen


	.SBTTL	NORMAL_EXIT

	;
	;	NORMAL_EXIT - Normal End of Instruction Emulation
	;
	;		entered by branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine restores control to the user program whenever
	;	the emulation ends without causing an exception. First the V
	;	and IV bits in the user's PSL are checked. If they are both 
	;	set then an integer overflow trap is signaled. When the
	;	Emulator returns, all of the registers, PC, and the PSL are
	;	set to the emulated values.
	;
	;	    The method of leaving the Emulator consists of pushing the
	;	user's PC and PSL onto the user's stack putting the saved AP
	;	and FP back in their proper places in the frame and performing
	;	the indicated adjustment so that when a RET instruction is
	;	executed all of the registers up to FP will be restored and
	;	the stack pointer will be positioned to the PC, PSL pair.
	;
	;	    At this point, a speed optimization is performed.  If the
	;	next instruction is also one we emulate, then we can bypass the
	;	overhead for the reserved opcode fault and exception 
	;	dispatching by merely looping back to the beginning of the
	;	emulator.  After the RET restores all registers, the stack
	;	contains the PC/PSL pair for the next instruction.  The PSL is
	;	examined to see if the T-bit is set.  If so, we can't do the
	;	optimization.  If T is clear, we then examine the next opcode.
	;	If it is one which we emulate, a branch is made to EMULATE$
	;	to begin emulation of the next instruction.  Note that the
	;	"arguments" to EMULATE$, a PC/PSL pair, are already in place!
	;
	;	If the optimization can not be performed, an REI is executed
	;	which restores the PC and PSL for the next instruction.
	;
NORMAL_EXIT:				; entrance
	BBC	#PSL_V,PSL(FP),1$	; no integer overflow - bypass
	BBC	#PSL_IV,PSL(FP),1$	; no integer overflow trap - skip
	BRW	INT_OVERFLOW		; process the integer overflow trap
1$:	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVL	#8,R0			; R0 = size of PC, PSL pair
	BSBW	TEST_FRAME		; make sure we have room to push it
	SUBL2	#8,REG_SP(FP)		; allocate room on the user's stack
	MOVQ	REG_PC(FP),@REG_SP(FP)	; push the PC, PSL pair
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put the user's PC, PSL pair back
	MOVAB	B^2$,SAVE_PC(FP)	; store our return point
	MOVAB	FRAME_END+4(FP),R0	; R0 = location of end of frame
	SUBL3	R0,REG_SP(FP),R1	; R1 = distance of user SP from it
	EXTZV	#0,#2,R1,R2		; R2 = stack alignment
	INSV	R2,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store it into the frame
	ADDL2	R2,R0			; compute the parameter area location
	ASHL	#-2,R1,-4(R0)		; store the parameter count
	RET				; return (to next instruction)

;+
; Perform instruction lookahead for speed optimization.
; At this point, 0(SP) contains the PC of the next user instruction, 4(SP)
; has the user PSL.
;-

2$:	BBS	#PSL_T, 4(SP), 90$	; If T-bit set, don't do lookahead
	MOVQ	R0, -(SP)		; Save R0-R1 temporarily
	MOVL	8(SP), R1		; Get PC in R1
	EXTZV	#PSL_CAM, #2, 12(SP), R0; Get current access mode in R0
	PROBER	R0, #2, (R1)		; Can we read the next TWO bytes?
	BEQL	80$			; If not, just return
	MOVZBL	(R1)+, R0		; Get next opcode byte in R0
	CMPB	R0, #^XFD		; 2-byte opcode?
	BEQL	20$			; Skip if yes
	CMPB	R0, #^X40		; Compare against ADDF2
	BLSSU	80$			; Not emulated if LSSU
	CMPB	R0, #^X76		; Compare against CVTDF
	BGTRU	80$			; Not emulated if GTRU
	MULL2	#4, R0			; Get bit offset of mask
	EXTZV	R0, #4, INST_TYPES_1BYTE, R1 ; Get inst-types mask in R1
	BRB	70$			; Join common code
20$:	CVTBL	(R1), R0		; Get next opcode byte in R0
	BLSS	30$			; Skip if greater than PUSHAO (^X7F)
	CMPB	R0, #^X32		; Compare against CVTDH
	BLSSU	80$			; Not emulated if LSSU
	MULL2	#4, R0			; Get bit offset of mask
	EXTZV	R0, #4, INST_TYPES_2BYTE, R1 ; Get inst-types mask in R1
	BRB	70$			; Join common code
80$:	MOVQ	(SP)+, R0		; Restore saved R0
90$:	REI				; Return to the next user instruction
30$:	MOVZBL	#<IT_F+IT_H>, R1	; Assume CVTFH or CVTHF
	CMPB	R0,#^X99		; Compare against CVTFG
	BGTRU	40$			; Not CVTFG or CVTFH if GTRU
	CMPB	R0,#^X98		; Compare against CVTFH
	BLSSU	80$			; Not emulated if LSSU
	BEQL	70$			; R1 mask is correct for CVTFH
	XORB2	#<IT_G+IT_H>, R1	; CVTFG - Switch to using F and G
	BRB	70$			; Join common code
40$:	CMPB	R0, #^XF6		; Compare against CVTHF
	BLSSU	80$			; Not emulated if LSSU
	BEQL	70$			; Join common code if CVTHF
	XORB2	#<IT_F+IT_D>, R1	; CVTHD - Switch to using H and D
70$:	ASHL	#ARC$V_DFLT_EMUL, R1, R1; Align mask with EXE$GL_ARCHFLAG
	BITL	R1, G^EXE$GL_ARCHFLAG	; Should we emulate this instruction?
	BEQL	80$			; If all bits test zero, no
	MOVQ	(SP)+, R0		; Pop saved R0 and R1
	BRW	VAX$$EMULATE_FP		; Emulate the next instruction
	ASSUME	ARC$V_FFLT_EMUL EQ ARC$V_DFLT_EMUL+1
	ASSUME	ARC$V_GFLT_EMUL EQ ARC$V_FFLT_EMUL+1
	ASSUME	ARC$V_HFLT_EMUL EQ ARC$V_GFLT_EMUL+1
	;

	.SBTTL	INSTRUCTION_TYPES

;+
; The following two tables provide information on what floating types
; are manipulated by each instruction.  For each opcode there are
; four bits which, if set, indicate that the instruction uses D, F, G
; and H_floating data, respectively.  These four bits are compared against
; the corresponding four bits in EXE$GL_ARCHFLAG to see if the next 
; instruction should be emulated; this test takes place in NORMAL_EXIT.
;-


	;+
	; Macro INST_TYPE generates table entries
	;-

	.MACRO	INST_TYPE	OPCODE1,OPCODE2
	$$x=0
	.IRPC	$$t,<OPCODE2>
	$$x=$$x+IT_'$$t'
	.ENDR
	$$x=$$x@4
	.IRPC	$$t,<OPCODE1>
	$$x=$$x+IT_'$$t'
	.ENDR
	.BYTE	$$x
	.ENDM

;+
; INST_TYPES_1BYTE - Masks for 1-byte instructions.
; Covers opcodes 40 (ADDF2) through 76 (CVTDF)
;-

INST_TYPES_1BYTE=.-<^X40/2>	; Offset for first opcode
	INST_TYPE	F,F		; ADDF2, ADDF3
	INST_TYPE	F,F		; SUBF2, SUBF3
	INST_TYPE	F,F		; MULF2, MULF3
	INST_TYPE	F,F		; DIVF2, DIVF3
	INST_TYPE	F,F		; CVTFB, CVTFW
	INST_TYPE	F,F		; CVTFL, CVTRFL
	INST_TYPE	F,F		; CVTBF, CVTWF
	INST_TYPE	F,F		; CVTLF, ACBF
	INST_TYPE	F,F		; MOVF, CMPF
	INST_TYPE	F,F		; MNEGF, TSTF
	INST_TYPE	F,F		; EMODF, POLYF
	INST_TYPE	FD,X		; CVTFD, <57>
	INST_TYPE	X,X		; ADAWI, <59>
	INST_TYPE	X,X		; <5A>, <5B>
	INST_TYPE	X,X		; INSQHI, INSQTI
	INST_TYPE	X,X		; REMQHI, REMQTI
	INST_TYPE	D,D		; ADDD2, ADDD3
	INST_TYPE	D,D		; SUBD2, SUBD3
	INST_TYPE	D,D		; MULD2, MULD3
	INST_TYPE	D,D		; DIVD2, DIVD3
	INST_TYPE	D,D		; CVTDB, CVTDW
	INST_TYPE	D,D		; CVTDL, CVTRDL
	INST_TYPE	D,D		; CVTBD, CVTWD
	INST_TYPE	D,D		; CVTLD, ACBD
	INST_TYPE	D,D		; MOVD, CMPD
	INST_TYPE	D,D		; MNEGD, TSTD
	INST_TYPE	D,D		; EMODD, POLYD
	INST_TYPE	FD,X		; CVTDF, <77>

;+
; INST_TYPES_2BYTE - Masks for 2-byte instructions.
; Covers opcodes 32FD (CVTDH) through 7FFD (PUSHAO)
;-

INST_TYPES_2BYTE=.-<^X32/2>	; Offset for first opcode
	INST_TYPE	DH,GF		; CVTDH, CVTGF
	INST_TYPE	X,X		; <34FD>, <35FD>
	INST_TYPE	X,X		; <36FD>, <37FD>
	INST_TYPE	X,X		; <38FD>, <39FD>
	INST_TYPE	X,X		; <3AFD>, <3BFD>
	INST_TYPE	X,X		; <3CFD>, <3DFD>
	INST_TYPE	X,X		; <3EFD>, <3FFD>
	INST_TYPE	G,G		; ADDG2, ADDG3
	INST_TYPE	G,G		; SUBG2, SUBG3
	INST_TYPE	G,G		; MULG2, MULG3
	INST_TYPE	G,G		; DIVG2, DIVG3
	INST_TYPE	G,G		; CVTGB, CVTGW
	INST_TYPE	G,G		; CVTGL, CVTRGL
	INST_TYPE	G,G		; CVTBG, CVTWG
	INST_TYPE	G,G		; CVTLG, ACBG
	INST_TYPE	G,G		; MOVG, CMPG
	INST_TYPE	G,G		; MNEGG, TSTG
	INST_TYPE	G,G		; EMODG, POLYG
	INST_TYPE	GH,X		; CVTGH, <57FD>
	INST_TYPE	X,X		; <58FD>, <59FD>
	INST_TYPE	X,X		; <5AFD>, <5BFD>
	INST_TYPE	X,X		; <5CFD>, <5DFD>
	INST_TYPE	X,X		; <5EFD>, <5FFD>
	INST_TYPE	H,H		; ADDH2, ADDH3
	INST_TYPE	H,H		; SUBH2, SUBH3
	INST_TYPE	H,H		; MULH2, MULH3
	INST_TYPE	H,H		; DIVH2, DIVH3
	INST_TYPE	H,H		; CVTHB, CVTHW
	INST_TYPE	H,H		; CVTHL, CVTRHL
	INST_TYPE	H,H		; CVTBH, CVTWH
	INST_TYPE	H,H		; CVTLH, ACBH
	INST_TYPE	H,H		; MOVH, CMPH
	INST_TYPE	H,H		; MNEGH, TSTH
	INST_TYPE	H,H		; EMODH, POLYH
	INST_TYPE	HG,X		; CVTHG, <77FD>
	INST_TYPE	X,X		; <78FD>, <79FD>
	INST_TYPE	X,X		; <7AFD>, <7BFD>
	INST_TYPE	H,H		; CLRO, MOVO
	INST_TYPE	H,H		; MOVAO, PUSHAO

	.SBTTL	TEST_FRAME

	;
	;	TEST_FRAME - Test Frame Location and Move If Necessary
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = Size of Information to be Pushed
	;
	;		returns with	R0 = Distance Frame was Moved
	;
	;	Discussion
	;
	;	    This routine determines whether or not the address given
	;	by subtracting R0 from the user's stack pointer can be made
	;	the location following a parameter list without the location
	;	being within the local storage. If this cannot be done then
	;	the entire procedure frame is moved so the condition can be
	;	satisfied. The distance that the procedure frame was moved
	;	is returned in R0. The value is zero if the frame is not 
	;	moved.
	;
	;	Note:	1. The switch from one frame location to another is
	;		   performed by a single indivisible POPR instruction
	;		   so the Emulator is never in an anomalous state.
	;
	;		2. If the frame is moved to a higher address, then
	;		   the saved AP and FP are changed to the values of
	;		   the emulated registers. The reason for this is
	;		   that the move may overlay a valid frame so it is
	;		   assumed that the user's AP and FP have been changed
	;		   by the instruction to information about a new valid
	;		   frame. The implementor thinks that all of this is
	;		   pretty strange but if the program will work with
	;		   the hardware it will still work with the Emulator.
	;
TEST_FRAME:				; entrance
	PUSHL	#0			; push a zero
	SUBL3	R0,REG_SP(FP),R0	; compute pushed information address
	BICL2	#3,R0			; align the value
	MOVAB	LOCAL_END(FP),R1	; R1 = end of local storage
	CMPL	R0,R1			; does push extend below the frame ?
	BGEQU	2$			; no - bypass
	BICL3	#3,SP,R3		; R3 = aligned stack pointer
	SUBL2	#24,R3			; adjust for additional pushes
	MOVL	R0,R2			; R2 = address following moved frame
	CMPL	R2,R3			; does it extend into the frame ?
	BLEQU	3$			; no - bypass
	MOVL	R3,R2			; yes - use address below the frame
	BRB	3$			; bypass
2$:	MOVAB	FRAME_END+1027(FP),R2	; R2 = last possible parameter end
	CMPL	R0,R2			; does the push end above it ?
	BLEQU	5$			; no - bypass
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; change the saved AP and FP
	BICL3	#3,R0,R2		; R2 = aligned user stack pointer
3$:	SUBL2	R1,R2			; R2 = distance of the move
	PUSHL	R2			; push the quantity
	PUSHAB	(SP)[R2]		; push the modified SP
	PUSHAB	(FP)[R2]		; push the modified FP
	PUSHAB	(AP)[R2]		; push the modified AP
	PUSHAB	SAVE_ALIGN(FP)[R2]	; push the new alignment bits location
	PUSHAB	SAVE_PARCNT(FP)[R2]	; push the new parameter count address
	MOVAB	FRAME_END+4(FP)[R2],R3	; R3 = new frame end + 4 location
	SUBL3	R3,R0,R3		; R3 = distance to user's SP
	ASHL	#-2,R3,-(SP)		; push the new parameter count
	SUBL3	SP,R1,R0		; R0 = number of bytes to move
	MOVL	SP,R1			; R1 = location of bytes to move
	TSTL	R2			; will we extend the stack ?
	BGEQ	4$			; no - skip
	ADDL2	R2,SP			; yes - extend the stack pointer
4$:	MOVC3	R0,(R1),(R1)[R2]	; move the frame
	CVTLB	(SP)+,@(SP)+		; store the new parameter count
	CLRB	@(SP)+			; clear the new alignment bits
	POPR	#^M<AP,FP,SP>		; switch to the new frame
5$:	POPR	#^M<R0>			; R0 = distance frame was moved
	RSB				; return
	;

	.SBTTL	COND_HANDLER

	;
	;	COND_HANDLER - Internal Condition Handler
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;	
	;	    This routine is the internal condition handler for the
	;	Emulator. Since the Emulator does not make constructive use
	;	of exceptions in its main procedure, this routine requests 
	;	resignaling of all conditions it intercepts.
	;
	;	    If the condition is SS$_UNWIND which indicates that an
	;	unwind is about to take place, then it restores the argument
	;	count longword in the parameter list for the procedure so the
	;	unwind will work properly.
	;
COND_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0,R1 = condition array locations
	CMPCOND	SS$_UNWIND,4(R0)	; is this an unwind ?
	BNEQ	1$			; no - bypass
	MOVL	4(R1),R0		; R0 = frame location
	MOVB	SAVE_ALIGN(R0),R1	; R1 = safe copy of alignment bits
	MOVZBL	SAVE_PARCNT(FP),-(SP)	; push the argument count
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(R0) ; store align bits in frame
	ADDL2	R1,R0			; add to the frame location
	MOVL	(SP)+,FRAME_END(R0)	; store the argument count
1$:	MOVZWL	#SS$_RESIGNAL,R0	; resignal the condition
	RET				; return
	;

	.SBTTL	Instruction Emulation Routines

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		Instruction Emulation Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    Following are the routines for emulating the individual 
	;	new instructions. There is one routine for each instruction
	;	but the structure of most of these routines is extremely
	;	simple so we have included all of the descriptive information
	;	here rather than duplicating it for each routine. Special
	;	discussions are given for those instructions or families of
	;	instructions which do not quite fit into the general patterns.
	;
	;	    The routines themselves have been written so that they
	;	will be easy to follow. Because of this the temptation to
	;	remove a considerable amount of duplicated code has been
	;	staunchly resisted.
	;
	;	    The emulation routines have names which are of the form
	;	"INST_mnemonic", are entered by branching from the routine
	;	EMULATOR, and when instruction is complete the routines branch
	;	to NORMAL_EXIT. When exceptions occur, then flow of control is
	;	somewhat more complicated and is described below.
	;
	;
	;	Operand Processing
	;	------------------
	;
	;	    The first step for each of the instructions is to process
	;	the instruction operands (this process is inhibited only for
	;	POLYx when FPD is set in the PSL). This is done by
	;	calling the operand scanning routines for each operand and by
	;	saving the operands values (for read and modify access
	;	operands) and operand addresses (for write, modify, and 
	;	address, access operands) in the special areas of the frame
	;	allocated for that purpose. Floating values of all types that
	;	are input are converted to our internal floating format by the
	;	UNPACK routines which are described below.
	;
	;
	;	Instruction Emulation
	;	---------------------
	;
	;	    After all of the operands have been processed, the action
	;	of the instruction is performed usually by calling one of the
	;	arithmetic routines. For many of the move and convert 
	;	instructions no special emulation action is necessary since
	;	everything is done by the PACK and UNPACK routines. All of the
	;	floating arithmetic is performed using our internal floating
	;	representation.
	;
	;
	;	Storing the Results
	;	-------------------
	;
	;	    The last step of instruction emulation is storing the
	;	resulting values and updating the condition codes. The values
	;	are stored in the order in which their corresponding operands
	;	occur so the instruction is emulated properly when the write
	;	or modify access operands overlap. Floating values are 
	;	converted from the internal floating representation to the
	;	target representation by one of the PACK routines described
	;	below. After the results are output, the condition codes in
	;	the emulated PSL are updated. This order of operation is 
	;	important since the PACK routines may convert very small
	;	nonzero values to zero values if an underflow occurs and FU is
	;	clear in the PSL. When the instruction emulation is complete
	;	the routine branches to NORMAL_EXIT.
	;
	;
	;	Exceptions
	;	----------
	;
	;	    Except for the integer overflow trap, all of the 
	;	exceptions that the Emulator checks for are faults. When
	;	faults occur the Emulator restores everything to a state in
	;	which the instruction can be restarted and signals the fault.
	;	For the integer overflow trap, the instruction is run to
	;	completion, possibly outputing a truncated result, and the
	;	trap is signaled. Here we describe how instruction emulation
	;	is organized so this can be accomplished. Further information
	;	can be found in the essay on exception processing which 
	;	appears below.
	;
	;
	;	Faults
	;
	;	    Until the results of an instruction are output, all of the
	;	changes which take place to any register are additions and 
	;	subtractions of small integers. These changes are also 
	;	recorded in the change bytes corresponding to the registers.
	;	Therefore the only requirement necessary for correct fault
	;	processing is to insure that all fault detection takes place
	;	before any of the instruction results are output (actually,
	;	things are a little more complicated for POLYx).
	;	This is done by making the result outputing steps the last
	;	part of instruction emulation. In this way fault detection
	;	can be placed anywhere in the Emulator it is convenient rather
	;	than requiring close synchronization with the instruction
	;	emulation logic. For this reason direct processing of faults
	;	(rather than, say, returning status codes) appears throughout
	;	the common Emulator subroutines.
	;
	;	    The architecture makes no special requirements on the
	;	the condition codes generated by a fault except that they
	;	be sufficient for correctly restarting the instruction. In
	;	general, the V bit is cleared by EMULATOR on entry to an
	;	instruction emulation routine since the bit is used for
	;	detecting integer overflow traps (see below). None of the
	;	other condition bits is altered until the results are output
	;	at the end of instruction emulation. Consequently all of the
	;	other condition bits are preserved into faults. (With the
	;	present set of emulated instructions the only preservation
	;	requirement is that the C bit be preserved on faults by the
	;	ACBx instructions.)
	;
	;
	;	Integer Overflow Traps
	;
	;	    When a integer overflow is detected (either in a common
	;	subroutine or in the instruction emulation routine) the V
	;	bit is set in the emulated condition codes and the value is
	;	truncated. Everything proceeds normally until control reaches
	;	NORMAL_EXIT where the V and IV bits in the emulated PSL are
	;	checked. If both are set then an integer overflow trap is
	;	signaled.
	;
	;
	;	Access Modes and Access Violations
	;
	;	    This version of the Emulator has been designed to operate
	;	at the same access mode as the instruction being emulated.
	;	However most of the instruction emulation logic has been 
	;	designed to operate at any access mode that is not less 
	;	privleged than that of the instruction (exceptions: the logic
	;	for getting in, the logic for getting out, and the exception
	;	signaling logic). All attempts to access memory on behalf of
	;	the instruction are probed using the access mode contained in
	;	the local cell MODE. This is normally set to the current 
	;	access mode but may be set to some less privleged access mode.
	;	Because this version of the Emulator operates on the user
	;	stack it is not necessary to probe stack operations, however,
	;	these probes are still done to insure that the code will 
	;	remain usable for different access modes.
	;
	;
	;	Notes on the ACBx Instructions
	;	---------------------------------------
	;
	;	    For these instructions the operands are processed, the
	;	step is added to the index, and the sum is packed and output.
	;	Afterwards the sum is unpacked again and compared with the
	;	limit, the type of comparison depending on the sign of the
	;	step. The packing and unpacking is necessary to truncate the
	;	sum to the correct number of bits, to perform any rounding,
	;	and to check for underflow or overflow exceptions. If the
	;	branch is to be taken, the branch destination is moved into
	;	the emulated PC.
	;
	;
	;	Notes on the EMODx Instructions
	;	-----------------------------------------
	;
	;	    For these instructions the first two operands are a 
	;	floating value of the appropriate type and a word containing
	;	some extension bits. When the extension bits are picked up
	;	they are stored in the correct position of the unpacked first
	;	operand. The remaining operands are scanned and flag bits 1
	;	and 7 are used to remember which output operands are in the
	;	registers. The multiply is then performed using the proper
	;	arithmetic routine and the product is truncated to the correct
	;	number of bits. Next the integer part is extracted and saved
	;	in an internal cell while the fraction part is extracted and
	;	packed. Next any register output operands are output and
	;	the routine TEST_FRAME is called to insure that the user's 
	;	stack pointer is within the parameter area. Next any output
	;	operands in memory are output with stores into the Emulator's
	;	working storage disabled .If both output operands are in the
	;	same type of storage, then the integer part is output before
	;	the fraction part. This complicated method of outputing the
	;	results is necessary because one of the register operands may
	;	contain SP and extend the user's stack into the Emulator's
	;	working storage. The call to TEST_FRAME will move the frame
	;	if this occurs so if the other operand will be stored into
	;	memory properly if it is not below the user's stack pointer.
	;
	;
	;	Notes on the POLYx Instructions
	;	-----------------------------------------
	;
	;	    These instructions have especially complicated emulation
	;	routines because they do a lot, have a large number of 
	;	implicit inputs and outputs, and are intended to be resumed
	;	instead of restarted when faults occur. For this reason we
	;	describe the action of the instruction emulation routines in
	;	some detail.
	;
	;	    These instructions can be thought as having two states.
	;	In the first of these states no unreversable changes have 
	;	been made to the registers so if a fault occurs the 
	;	instruction can be restarted. The instruction remains in this
	;	state until all of the operands have been processed and the
	;	first coefficient has been validated. After this point the
	;	instruction saves various things in the registers R0-R5 (and
	;	on the stack for POLYH) so the instruction can no longer be
	;	restarted but the information saved is sufficient for resuming
	;	the instruction after a fault. When this second state is
	;	reached the FPD bit is set in the PSL so the when the 
	;	instruction emulation routine is entered for resuming the 
	;	instruction it will know enough to do so.
	;
	;	    Following is an outline of the steps in the emulation of
	;	the two instructions. The text generally describes POLYG and
	;	the differences for POLYH are noted in parentheses.
	;
	;
	;	     1. This is the first step for the instruction emulation.
	;		If the FPD bit is clear in the PSL then control passes
	;		to Step 2. Otherwise the following actions which are
	;		concerned with restarting the instruction take place:
	;
	;		The length of the instruction operands is retrieved 
	;		from the high order three bytes of the user's R2 (R4
	;		for POLYH) and added to the current PC and to the 
	;		change byte for the PC. If the instruction terminates
	;		the PC will be positioned following the instruction
	;		and if the instruction faults it will be reset to the
	;		location of the instruction.
	;
	;		The result so far is unpacked from R0-R1 (R0-R3 for
	;		POLYH) and the unpacked value is stored in OPERAND2.
	;		The condition codes are set to describe this value.
	;
	;		The argument is unpacked from R4-R5 (from a stacked
	;		octaword for POLYH, which is probed) and the unpacked
	;		value is stored in OPERAND3.
	;
	;		The remaining coefficient count in the low order byte
	;		of R2 (R4 for POLYH) is checked for validity.
	;
	;		Finally control passes to Step 3.
	;
	;
	;	     2. This step performs all of the processing for initial
	;		entry to the instruction.
	;
	;		The first operand is processed and the unpacked
	;		argument is saved in OPERAND3.
	;
	;		The second operand is processed and the degree is 
	;		checked for validity and the value is saved 
	;		temporarily in ADDRESS1.
	;
	;		The third operand is processed and the address of the
	;		coefficient table is saved. The first coefficient is
	;		probed, unpacked, and saved in OPERAND2.
	;
	;		If the instruction is POLYH then the user's SP is 
	;		decremented by 16 (and so is the change byte) and
	;		the argument value in OPERAND3 is packed and output
	;		to the allocated stack area. (If a fault occurs before
	;		FPD is set then SP will be reinitilized properly.)
	;
	;		The coefficient in OPERAND2 is packed and stored in
	;		the user's registers R0-R1 (R0-R4 for POLYH), the
	;		address of the remaining coefficients is stored in the
	;		user's R4 (R6 for POLYH), the degree is stored in the
	;		low order byte of the user's R2 (R4 for POLYH), and
	;		the length of the instruction operands (the PC change
	;		byte minus two) is saved in the upper three bytes of
	;		that register. The condition codes are set based on
	;		the value in OPERAND2.
	;
	;		All of the change bytes except that for PC are cleared
	;		and the bit FPD is set in the emulated PSL.
	;
	;		If the instruction is POLYG then the argument in
	;		OPERAND3 is packed and saved in the user's R4-R5.
	;
	;		Control Passes to Step 3.
	;
	;
	;	     3. This step performs the basic polynomial evaluation 
	;		iteration.
	;
	;		If the remaining coefficient count in the low order
	;		byte of the user's R2 (R4 for POLYH) is zero then 
	;		control passes to Step 4.
	;	
	;		The value so far in OPERAND2 and the argument in
	;		OPERAND3 are multiplied and the unnormalized product
	;		is truncated to 63 (127 for POLYH) bits and stored
	;		in OPERAND1. The truncation is performed by clearing
	;		the low order bit of the 64 (128 for POLYH) bit
	;		product returned by the multiply routine.
	;
	;		The coefficient addressed by the user's R3 (R5 for 
	;		POLYH) is probed and unpacked to OPERAND2. The result
	;		is then added to OPERAND1.
	;
	;		The new value so far in OPERAND1 is packed and stored
	;		in the user's R0-R1 (R0-R3 for POLYH). The condition
	;		codes are set based on this value. The value is then
	;		unpacked and stored in OPERAND2.
	;
	;		The remaining coefficient count in the low order byte
	;		of R2 (R4 for POLYH) is decremented and the pointer to
	;		the next coeffiecient in R3 (R5 for POLYH) is
	;		incremented to point to the next coefficient.
	;
	;		Control then passes to the beginning of this step.
	;
	;
	;	     4. This step performs the termination of the instruction.
	;
	;		The register R2 (R4 for POLYH) which contains the
	;		instruction length and the coefficient count is
	;		cleared.
	;
	;		If the instruction was POLYG then the registers R4-R5
	;		which contained the argument value are cleared.
	;
	;		If the instruction was POLYH then the user's SP is
	;		incremented by 16 to unstack the argument.
	;
	;		The FPD bit in the PSL is cleared.
	;
	;		Instruction emulation is now complete.
	;
	;
	;	    Careful reading of the above outline will show that the
	;	POLYG and POLYH instructions are correctly emulated even down
	;	to the handling of faults. Faults may be detected at any of
	;	the probes and at some of the pack and unpack operations. When
	;	faults are detected control immediatly leaves the outline so
	;	it is important that everything be correct at the time the 
	;	check is made. The reader may notice that some results are
	;	packed and then immediatly unpacked. This is done to check for
	;	overflow and underflow and to perform any rounding specified
	;	by the architecture. This technique also converts nonstandard
	;	floating zero representations to standard ones.
	;

	;
	;	4F ACBF - Add Compare and Branch F_floating
	;
INST_ACBF:
	SET_OP_TYPES	F
	BRB	INST_ACBx

	;
	;	6F ACBD - Add Compare and Branch D_floating
	;
INST_ACBD:
	SET_OP_TYPES	D
	BRB	INST_ACBx

	;
	;	4FFD ACBG - Add Compare and Branch G_floating
	;
INST_ACBG:
	SET_OP_TYPES	G
	BRB	INST_ACBx

	;
	;	6FFD ACBH - Add Compare and Branch H_floating
	;
INST_ACBH:
	SET_OP_TYPES	H
	; BRB	INST_ACBx

INST_ACBx:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	BSBW	READ_ACCESS		; second operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	MODIFY_ACCESS		; third operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the operand address
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	BRANCH_WORD		; fourth operand is branch destination
	MOVL	R11,ADDRESS2(FP)	; save the branch destination
	BSBW	ADD_REAL		; add the step and index
	BSBW	PACK_FLOAT1		; pack the index value
	MOVL	ADDRESS1(FP),R11	; R11 = destination address
	BSBW	STORE_OPERAND		; store into third operand
	BSBW	UNPACK_FLOAT1		; put the value back
	MOVAB	OPERAND1(FP),R1 	; R1 = location of index value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICB2	#PSLM_V,PSL(FP) 	; clear V in the PSL
	MOVAB	OPERAND2(FP),R1 	; R1 = address of step value
	BSBW	TEST_REAL		; test the value
	BLSS	2$			; it's negative - bypass
	MOVAB	OPERAND1(FP),R1 	; R1 = address of index value
	MOVAB	OPERAND3(FP),R2 	; R2 = address of limit value
	BSBW	COMPARE_REAL		; have we passed the limit ?
	BGTR	3$			; yes - bypass
1$:	MOVL	ADDRESS2(FP),REG_PC(FP) ; perform the branch
	BRB	3$			; bypass
2$:	MOVAB	OPERAND1(FP),R1 	; R1 = address of index value
	MOVAB	OPERAND3(FP),R2 	; R2 = address of limit value
	BSBW	COMPARE_REAL		; have we passed the limit ?
	BGEQ	1$			; no - perform the branch
3$:	BRW	NORMAL_EXIT		; done

	;
	;	40 ADDF2 - Add F_floating (Two Operands)
	;
INST_ADDF2:				; entrance
	SET_OP_TYPES	F
	BRB	INST_ADDx2

	;
	;	60 ADDD2 - Add D_floating (Two Operands)
	;
INST_ADDD2:				; entrance
	SET_OP_TYPES	D
	BRB	INST_ADDx2

	;
	;	40FD ADDG2 - Add G_floating (Two Operands)
	;
INST_ADDG2:				; entrance
	SET_OP_TYPES	G
	BRB	INST_ADDx2

	;
	;	60FD ADDH2 - Add HFLOAT (Two Operands)
	;
INST_ADDH2:				; entrance
	SET_OP_TYPES	H
	;BRB	INST_ADDx2

INST_ADDx2:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	MODIFY_ACCESS		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_FLOAT1		; pack the sum
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	41 ADDF3 - Add F_floating (Three Operands)
	;
INST_ADDF3:				; entrance
	SET_OP_TYPES	F
	BRB	INST_ADDx3

	;
	;	61 ADDD3 - Add D_floating (Three Operands)
	;
INST_ADDD3:				; entrance
	SET_OP_TYPES	D
	BRB	INST_ADDx3

	;
	;	41FD ADDG3 - Add G_floating (Three Operands)
	;
INST_ADDG3:				; entrance
	SET_OP_TYPES	G
	BRB	INST_ADDx3

	;
	;	61FD ADDH3 - Add HFLOAT (Three Operands)
	;
INST_ADDH3:				; entrance
	SET_OP_TYPES	H
	;BRB	INST_ADDx3

INST_ADDx3:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	READ_ACCESS		; second operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	WRITE_ACCESS		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination address
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_FLOAT1		; pack the sum
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	7CFD CLRO - Clear Octaword
	;
	;	7CFD CLRH - Clear H_floating
	;
INST_CLRO:				; entrance
	SET_OP_TYPES	O
	BSBW	WRITE_ACCESS		; first operand is write only
	CLRQ	(R11)+			; clear the first part of the value
	CLRQ	(R11)			; clear the second part of the value
	BICL2	#PSLM_NZV,PSL(FP)	; clear the condition codes except C
	BISL2	#PSLM_Z,PSL(FP) 	; set the Z bit in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	51 CMPF - Compare F_floating
	;
INST_CMPF:				; entrance
	SET_OP_TYPES	F
	BRB	INST_CMPx

	;
	;	71 CMPD - Compare D_floating
	;
INST_CMPD:				; entrance
	SET_OP_TYPES	D
	BRB	INST_CMPx

	;
	;	51FD CMPG - Compare G_floating
	;
INST_CMPG:				; entrance
	SET_OP_TYPES	G
	BRB	INST_CMPx

	;
	;	71FD CMPH - Compare H_floating
	;
INST_CMPH:				; entrance
	SET_OP_TYPES	H
	;BRB	INST_CMPx

INST_CMPx:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	READ_ACCESS		; second operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	MOVAB	OPERAND1(FP),R1 	; R1 = location of first value
	MOVAB	OPERAND2(FP),R2 	; R2 = location of second value
	BSBW	COMPARE_REAL		; compare the values
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	4C CVTBF - Convert Byte to F_floating
	;
INST_CVTBF:				; entrance
	SET_OP_TYPES	B,F
	BRB	INST_CVTBx

	;
	;	6C CVTBD - Convert Byte to D_floating
	;
INST_CVTBD:				; entrance
	SET_OP_TYPES	B,D
	BRB	INST_CVTBx

	;
	;	4CFD CVTBG - Convert Byte to G_floating
	;
INST_CVTBG:				; entrance
	SET_OP_TYPES	B,G
	BRB	INST_CVTBx

	;
	;	6CFD CVTBH - Convert Byte to H_floating
	;
INST_CVTBH:				; entrance
	SET_OP_TYPES	B,H
	BRB	INST_CVTBx

	;
	;	4D CVTWF - Convert Word to F_floating
	;
INST_CVTWF:
	SET_OP_TYPES	W,F
	BRB	INST_CVTWx

	;
	;	6D CVTWD - Convert Word to D_floating
	;
INST_CVTWD:
	SET_OP_TYPES	W,D
	BRB	INST_CVTWx

	;
	;	4DFD CVTWG - Convert Word to G_floating
	;
INST_CVTWG:				; entrance
	SET_OP_TYPES	W,G
	BRB	INST_CVTWx

	;
	;	6DFD CVTWH - Convert Word to H_floating
	;
INST_CVTWH:				; entrance
	SET_OP_TYPES	W,H
	BRB	INST_CVTWx

	;
	;	4E CVTLF - Convert Long to F_floating
	;
INST_CVTLF:				; entrance
	SET_OP_TYPES	L,F
	BRB	INST_CVTLx

	;
	;	6E CVTLD - Convert Long to D_floating
	;
INST_CVTLD:				; entrance
	SET_OP_TYPES	L,D
	BRB	INST_CVTLx

	;
	;	4EFD CVTLG - Convert Long to G_floating
	;
INST_CVTLG:				; entrance
	SET_OP_TYPES	L,G
	BRB	INST_CVTLx

	;
	;	6EFD CVTLH - Convert Long to H_floating
	;
INST_CVTLH:				; entrance
	SET_OP_TYPES	L,H
	;BRB	INST_CVTLx

INST_CVTBx:
INST_CVTWx:
INST_CVTLx:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	FLOAT_LONG		; convert to floating and save value
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination address
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	48 CVTFB - Convert F_floating to Byte
	;
INST_CVTFB:
	SET_OP_TYPES	F,B
	BRB	INST_CVTxB

	;
	;	68 CVTDB - Convert D_floating to Byte
	;
INST_CVTDB:
	SET_OP_TYPES	D,B
	BRB	INST_CVTxB

	;
	;	48FD CVTGB - Convert G_floating to Byte
	;
INST_CVTGB:
	SET_OP_TYPES	G,B
	BRB	INST_CVTxB

	;
	;	68FD CVTHB - Convert H_floating to Byte
	;
INST_CVTHB:
	SET_OP_TYPES	H,B
	BRB	INST_CVTxB

	;
	;	49 CVTFW - Convert F_floating to Word
	;
INST_CVTFW:
	SET_OP_TYPES	F,W
	BRB	INST_CVTxW

	;
	;	69 CVTDW - Convert D_floating to Word
	;
INST_CVTDW:
	SET_OP_TYPES	D,W
	BRB	INST_CVTxW

	;
	;	49FD CVTGW - Convert G_floating to Word
	;
INST_CVTGW:
	SET_OP_TYPES	G,W
	BRB	INST_CVTxW

	;
	;	69FD CVTHW - Convert H_floating to Word
	;
INST_CVTHW:
	SET_OP_TYPES	H,W
	BRB	INST_CVTxW

	;
	;	4A CVTFL - Convert F_floating to Long
	;
INST_CVTFL:
	SET_OP_TYPES	F,L
	BRB	INST_CVTxL

	;
	;	6A CVTDL - Convert D_floating to Long
	;
INST_CVTDL:
	SET_OP_TYPES	D,L
	BRB	INST_CVTxL

	;
	;	4AFD CVTGL - Convert G_floating to Long
	;
INST_CVTGL:
	SET_OP_TYPES	G,L
	BRB	INST_CVTxL

	;
	;	6AFD CVTHL - Convert H_floating to Long
	;
INST_CVTHL:
	SET_OP_TYPES	H,L
	BRB	INST_CVTxL

INST_CVTxB:
INST_CVTxW:
INST_CVTxL:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	CMPB	@OP_INDEX(FP),#TYP_W	; case on datatype
	BGTR	30$			; skip if longword
	BEQL	10$			; skip if word
	CVTLB	R0,R0			; convert long to byte
	BRB	20$			; continue
10$:	CVTLW	R0,R0			; convert long to word
20$:	BVC	30$			; no overflow - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate integer overflow
30$:	MOVL	ADDRESS1(FP),R11	; get address of result
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done

	;
	;	56 CVTFD - Convert F_floating to D_floating
	;
INST_CVTFD:
	SET_OP_TYPES	F,D
	BRB	INST_CVTxy

	;
	;	99FD CVTFG - Convert Floating to G_floating
	;
INST_CVTFG:				; entrance
	SET_OP_TYPES	F,G
	BRB	INST_CVTxy

	;
	;	98FD CVTFH - Convert F_floating to H_floating
	;
INST_CVTFH:				; entrance
	SET_OP_TYPES	F,H
	BRB	INST_CVTxy

	;
	;	76 CVTDF - Convert D_floating to H_floating
	;
INST_CVTDF:				; entrance
	SET_OP_TYPES	D,F
	BRB	INST_CVTxy

	;
	;	32FD CVTDH - Convert D_floating to H_floating
	;
INST_CVTDH:
	SET_OP_TYPES	D,H
	BRB	INST_CVTxy

	;
	;	33FD CVTGF - Convert G_floating to F_floating
	;
INST_CVTGF:
	SET_OP_TYPES	G,F
	BRB	INST_CVTxy

	;
	;	56FD CVTGH - Convert G_floating to H_floating
	;
INST_CVTGH:
	SET_OP_TYPES	G,H
	BRB	INST_CVTxy

	;
	;	F6FD CVTHF - Convert H_floating to F_floating
	;
INST_CVTHF:
	SET_OP_TYPES	H,F
	BRB	INST_CVTxy

	;
	;	F7FD CVTHD - Convert H_floating to D_floating
	;
INST_CVTHD:
	SET_OP_TYPES	H,D
	BRB	INST_CVTxy

	;
	;	76FD CVTHG - COnvert H_floating to G_floating
	;
INST_CVTHG:
	SET_OP_TYPES	H,G
	;BRB	INST_CVTxy

INST_CVTxy:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	4B CVTRFL - Convert Rounded F_floating to Long
	;
INST_CVTRFL:
	SET_OP_TYPES	F,L
	BRB	INST_CVTRxL

	;
	;	6B CVTRDL - Convert Rounded D_floating to Long
	;
INST_CVTRDL:
	SET_OP_TYPES	D,L
	BRB	INST_CVTRxL

	;
	;	4BFD CVTRGL - Convert Rounded G_floating to Long
	;
INST_CVTRGL:				; entrance
	SET_OP_TYPES	G,L
	BRB	INST_CVTRxL

	;
	;	6BFD CVTRHL - Convert Rounded H_floating to Long
	;
INST_CVTRHL:				; entrance
	SET_OP_TYPES	H,L
	;BRB	INST_CVTRxL

INST_CVTRxL:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack the value
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	ROUND_REAL		; round the value
	MOVL	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done

	;
	;	46 DIVF2 - Divide F_floating (Two Operands)
	;
INST_DIVF2:
	SET_OP_TYPES	F
	BRB	INST_DIVx2

	;
	;	66 DIVD2 - Divide D_floating (Two Operands)
	;
INST_DIVD2:
	SET_OP_TYPES	D
	BRB	INST_DIVx2

	;
	;	46FD DIVG2 - Divide G_floating (Two Operands)
	;
INST_DIVG2:
	SET_OP_TYPES	G
	BRB	INST_DIVx2

	;
	;	66FD DIVH2 - Divide H_floating (Two Operands)
	;
INST_DIVH2:
	SET_OP_TYPES	H
	;BRB	INST_DIVx2

INST_DIVx2:				; entrance
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	BSBW	MODIFY_ACCESS		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	DIVIDE_FLOAT		; compute the quotient
	BSBW	PACK_FLOAT1		; pack the result
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	47 DIVF3 - Divide F_floating (Three Operands)
	;
INST_DIVF3:
	SET_OP_TYPES	F
	BRB	INST_DIVx3

	;
	;	67 DIVD3 - Divide D_floating (Three Operands)
	;
INST_DIVD3:
	SET_OP_TYPES	D
	BRB	INST_DIVx3

	;
	;	47FD DIVG3 - Divide G_floating (Three Operands)
	;
INST_DIVG3:
	SET_OP_TYPES	G
	BRB	INST_DIVx3

	;
	;	67FD DIVH3 - Divide HFLOAT (Three Operands)
	;
INST_DIVH3:				; entrance
	SET_OP_TYPES	H
	;BRB	INST_DIVx3

INST_DIVx3:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	BSBW	READ_ACCESS		; second operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	WRITE_ACCESS		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	DIVIDE_FLOAT		; compute the quotient
	BSBW	PACK_FLOAT1		; pack the result
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	54 EMODF - Extended Modulus F_floating
	;
INST_EMODF:
	SET_OP_TYPES	F,B,F,L,F
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the operand
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	READ_ACCESS		; second operand is read only
	MOVB	R0,FRACTION2+12(FP)	; insert bits 0-7 of the fraction
	INCL	OP_INDEX(FP)		; move to third operand
	BSBW	READ_ACCESS		; third operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	MOVB	#FLAG0M,FLAGS(FP)	; inhibit checking for local store
	INCL	OP_INDEX(FP)		; move to fourth operand
	BSBW	WRITE_ACCESS		; fourth operand is write only
	BBCC	#FLAG1,FLAGS(FP),1$	; not register mode - skip
	BBCS	#FLAG7,FLAGS(FP),1$	; make a note
1$:	MOVL	R11,ADDRESS1(FP)	; save the first destination address
	INCL	OP_INDEX(FP)		; move to fifth operand
	BSBW	WRITE_ACCESS		; fifth operand is write only
	MOVL	R11,ADDRESS2(FP)	; save the second destination address
	BSBW	MULTIPLY_FLOAT		; compute the product
	INSV	#0,#0,R0,FRACTION1+12(FP); truncate the product if necessary
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the product
	MOVL	R0,ADDRESS3(FP)		; save the integer part
	BSBW	FRACTION_REAL		; form the fractional part
	BSBW	PACK_FLOAT1		; pack the fraction value
	PUSHL	R0			; push the fraction
	BBC	#FLAG7,FLAGS(FP),2$	; fourth operand not register - skip
	MOVL	ADDRESS3(FP),@ADDRESS1(FP) ; output the integer part
2$:	BBC	#FLAG1,FLAGS(FP),3$	; fifth operand not register - skip
	MOVL	(SP)+,@ADDRESS2(FP)	; output the fraction
3$:	MOVL	#4,R0			; allow room for dummy store
	BSBW	TEST_FRAME		; move the frame if necessary
	BBS	#FLAG7,FLAGS(FP),4$	; fourth operand is register - bypass
	MOVL	#4,R10			; R10 = size of integer part
	MOVL	ADDRESS1(FP),R11	; R11 = location of fourth operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVL	ADDRESS3(FP),(R11)	; output the integer part
4$:	BBS	#FLAG1,FLAGS(FP),5$	; fifth operand is register - bypass
	MOVL	#4,R10			; R10 = size of the fraction
	MOVL	ADDRESS2(FP),R11	; R11 = location of second operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVL	(SP)+,(R11)		; output the fraction
5$:	MOVAB	OPERAND1(FP),R1 	; R1 = location of the fraction
	BSBW	TEST_REAL		; test the fraction
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done

	;
	;	74 EMODD - Extended Modulus D_floating
	;
INST_EMODD:
	SET_OP_TYPES	D,B,D,L,D
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the operand
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	READ_ACCESS		; second operand is read only
	MOVB	R0,FRACTION2+8(FP)	; insert bits 0-7 of the fraction
	BRB	COMMON_EMODdg		; join common D/G code

	;
	;	54FD EMODG - Extended Modulus G_floating
	;
INST_EMODG:				; entrance
	SET_OP_TYPES	G,W,G,L,G
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the operand
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	READ_ACCESS		; second operand is read only
	ROTL	#27,R0,R0		; position the high-order 11 bits
	INSV	R0,#0,#11,FRACTION2+8(FP) ; insert bits 0-10 of the fraction
COMMON_EMODdg:
	INCL	OP_INDEX(FP)		; move to third operand
	BSBW	READ_ACCESS		; third operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	MOVB	#FLAG0M,FLAGS(FP)	; inhibit checking for local store
	INCL	OP_INDEX(FP)		; move to fourth operand
	BSBW	WRITE_ACCESS		; fourth operand is write only
	BBCC	#FLAG1,FLAGS(FP),1$	; not register mode - skip
	BBCS	#FLAG7,FLAGS(FP),1$	; make a note
1$:	MOVL	R11,ADDRESS1(FP)	; save the first destination address
	INCL	OP_INDEX(FP)		; move to fifth operand
	BSBW	WRITE_ACCESS		; fifth operand is write only
	MOVL	R11,ADDRESS2(FP)	; save the second destination address
	BSBW	MULTIPLY_FLOAT		; compute the product
	INSV	#0,#0,R0,FRACTION1+8(FP); truncate the product if necessary
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the product
	MOVL	R0,ADDRESS3(FP)		; save the integer part
	BSBW	FRACTION_REAL		; form the fractional part
	BSBW	PACK_FLOAT1		; pack the fraction value
	PUSHR	#^M<R0,R1>		; push the fraction
	BBC	#FLAG7,FLAGS(FP),2$	; fourth operand not register - skip
	MOVL	ADDRESS3(FP),@ADDRESS1(FP) ; output the integer part
2$:	BBC	#FLAG1,FLAGS(FP),3$	; fifth operand not register - skip
	MOVQ	(SP)+,@ADDRESS2(FP)	; output the fraction
3$:	MOVL	#8,R0			; allow room for dummy store
	BSBW	TEST_FRAME		; move the frame if necessary
	BBS	#FLAG7,FLAGS(FP),4$	; fourth operand is register - bypass
	MOVL	#4,R10			; R10 = size of integer part
	MOVL	ADDRESS1(FP),R11	; R11 = location of fourth operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVL	ADDRESS3(FP),(R11)	; output the integer part
4$:	BBS	#FLAG1,FLAGS(FP),5$	; fifth operand is register - bypass
	MOVL	#8,R10			; R10 = size of the fraction
	MOVL	ADDRESS2(FP),R11	; R11 = location of second operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVQ	(SP)+,(R11)		; output the fraction
5$:	MOVAB	OPERAND1(FP),R1 	; R1 = location of the fraction
	BSBW	TEST_REAL		; test the fraction
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done

	;
	;	74FD EMODH - Extended Modulus HFLOAT
	;
INST_EMODH:				; entrance
	SET_OP_TYPES	H,W,H,L,H
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the operand
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	READ_ACCESS		; second operand is read only
	ROTL	#31,R0,R0		; position the high-order 15 bits
	INSV	R0,#0,#15,FRACTION2(FP) ; insert bits 0-14 of the fraction
	INCL	OP_INDEX(FP)		; move to third operand
	BSBW	READ_ACCESS		; third operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	MOVB	#FLAG0M,FLAGS(FP)	; inhibit checking for local store
	INCL	OP_INDEX(FP)		; move to fourth operand
	BSBW	WRITE_ACCESS		; fourth operand is write only
	BBCC	#FLAG1,FLAGS(FP),1$	; not register mode - skip
	BBCS	#FLAG7,FLAGS(FP),1$	; make a note
1$:	MOVL	R11,ADDRESS1(FP)	; save the first destination address
	INCL	OP_INDEX(FP)		; move to fifth operand
	BSBW	WRITE_ACCESS		; fifth operand is write only
	MOVL	R11,ADDRESS2(FP)	; save the second destination address
	BSBW	MULTIPLY_FLOAT		; compute the product
	INSV	#0,#0,R0,FRACTION1(FP)	; truncate the product if necessary
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the product
	MOVL	R0,ADDRESS3(FP)		; save the integer part
	BSBW	FRACTION_REAL		; form the fractional part
	BSBW	PACK_FLOAT1		; pack the fraction value
	PUSHR	#^M<R0,R1,R2,R3>	; push the fraction
	BBC	#FLAG7,FLAGS(FP),2$	; fourth operand not register - skip
	MOVL	ADDRESS3(FP),@ADDRESS1(FP) ; output the integer part
2$:	BBC	#FLAG1,FLAGS(FP),3$	; fifth operand not register - bypass
	MOVL	ADDRESS2(FP),R11	; R11 = location of the register
	MOVQ	(SP)+,(R11)+		; output first part of the fraction
	MOVQ	(SP)+,(R11)		; output second part of the fraction
3$:	MOVL	#16,R0			; allow room for dummy store
	BSBW	TEST_FRAME		; move the frame if necessary
	BBS	#FLAG7,FLAGS(FP),4$	; fourth operand is register - bypass
	MOVL	#4,R10			; R10 = size of integer part
	MOVL	ADDRESS1(FP),R11	; R11 = location of fourth operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVL	ADDRESS3(FP),(R11)	; output the integer part
4$:	BBS	#FLAG1,FLAGS(FP),5$	; fifth operand is register - bypass
	MOVL	#16,R10			; R10 = size of the fraction
	MOVL	ADDRESS2(FP),R11	; R11 = location of second operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVQ	(SP)+,(R11)+		; output first part of the fraction
	MOVQ	(SP)+,(R11)		; output second part of the fraction
5$:	MOVAB	OPERAND1(FP),R1 	; R1 = location of the fraction
	BSBW	TEST_REAL		; test the fraction
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done

	;
	;	52 MNEGF - Move Negated F_floating
	;
INST_MNEGF:
	SET_OP_TYPES	F
	BRB	INST_MNEGx

	;
	;	72 MNEGD - Move Negated D_floating
	;
INST_MNEGD:
	SET_OP_TYPES	D
	BRB	INST_MNEGx

	;
	;	52FD MNEGG - Move Negated G_floating
	;
INST_MNEGG:
	SET_OP_TYPES	G
	BRB	INST_MNEGx

	;
	;	72FD MNEGH - Move Negated HFLOAT
	;
INST_MNEGH:
	SET_OP_TYPES	H
	;BRB	INST_MNEGx

INST_MNEGx:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	7EFD MOVAO - Move Address of Octaword
	;
	;	7EFD MOVAH - Move Address of H_floating
	;
INST_MOVAO:				; entrance
	SET_OP_TYPES	O,L
	BSBW	ADDRESS_ACCESS		; first operand is address only
	MOVL	R11,ADDRESS1(FP)	; save the operand address
	INCL	OP_INDEX(FP)		; move to second operand
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	ADDRESS1(FP),(R11)	; output the operand address
	BSBW	SET_CONDITION		; capture the condition code
	BICL2	#PSLM_V,PSL(FP) 	; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	50 MOVF - Move F_floating
	;
INST_MOVF:
	SET_OP_TYPES	F
	BRB	INST_MOVx

	;
	;	70 MOVD - Move D_floating
	;
INST_MOVD:
	SET_OP_TYPES	D
	BRB	INST_MOVx

	;
	;	50FD MOVG - Move G_floating
	;
INST_MOVG:
	SET_OP_TYPES	G
	BRB	INST_MOVx

	;
	;	70FD MOVH - Move HFLOAT
	;
INST_MOVH:
	SET_OP_TYPES	H
	;BRB	INST_MOVx

INST_MOVx:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	MOVAB	OPERAND1(FP),R1		; R1 = location of the value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_V,PSL(FP)		; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	7DFD MOVO - Move Octaword
	;
INST_MOVO:
	SET_OP_TYPES	O
	BSBW	READ_ACCESS		; first operand is read only
	MOVQ	R0,OPERAND1(FP) 	; save the first part of the value
	MOVQ	R2,OPERAND1+8(FP)	; save the second part of the value
	BSBW	WRITE_ACCESS		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save destination location
	BSBW	TEST_OCTA		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_V,PSL(FP)		; clear the V bit in the PSL
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	OPERAND1(FP),(R11)+	; output the first part of the result
	MOVQ	OPERAND1+8(FP),(R11)	; output the second part of the result
	BRW	NORMAL_EXIT		; done

	;
	;	44 MULF2 - Multiply F_floating (Two Operands)
	;
INST_MULF2:
	SET_OP_TYPES	F
	BRB	INST_MULx2

	;
	;	64 MULD2 - Multiply D_floating (Two Operands)
	;
INST_MULD2:
	SET_OP_TYPES	D
	BRB	INST_MULx2

	;
	;	44FD MULG2 - Multiply G_floating (Two Operands)
	;
INST_MULG2:
	SET_OP_TYPES	G
	BRB	INST_MULx2

	;
	;	64FD MULH2 - Multiply HFLOAT (Two Operands)
	;
INST_MULH2:				; entrance
	SET_OP_TYPES	H
	;BRB	INST_MULx2

INST_MULx2:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the first operand
	BSBW	MODIFY_ACCESS		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_FLOAT3		; unpack and save the second operand
	BSBW	MULTIPLY_FLOAT		; compute the product
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	45 MULF3 - Multiply F_floating (Three Operands)
	;
INST_MULF3:
	SET_OP_TYPES	F
	BRB	INST_MULx3

	;
	;	65 MULD3 - Multiply D_floating (Three Operands)
	;
INST_MULD3:
	SET_OP_TYPES	D
	BRB	INST_MULx3

	;
	;	45FD MULG3 - Multiply G_floating (Three Operands)
	;
INST_MULG3:
	SET_OP_TYPES	G
	BRB	INST_MULx3

	;
	;	65FD MULH3 - Multiply HFLOAT (Three Operands)
	;
INST_MULH3:
	SET_OP_TYPES	H
	;BRB	INST_MULx3

INST_MULx3:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	READ_ACCESS		; second operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	BSBW	WRITE_ACCESS		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	MULTIPLY_FLOAT		; compute the product
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	55 POLYF - Evaluate Polynomial F_floating
	;
INST_POLYF:				; entrance
	SET_OP_TYPES	F,W,B,F		; phantom fourth operand
	BBC	#PSL_FPD,PSL(FP),1$	; not instruction resumption - bypass
	EXTZV	#8,#24,REG_R2(FP),R0	; R0 = saved instruction length
	ADDL2	R0,REG_PC(FP)		; position PC to end of instruction
	ADDB2	R0,REGMOD_PC(FP)	; increment the PC modification count
	MOVL	REG_R0(FP),R0		; R0 = result so far
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	MOVL	REG_R1(FP),R0		; R0 = argument value
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	CMPB	#31,REG_R2(FP)		; is the iteration count too large ?
	BGEQU	4$			; no - resume the instruction
	BRW	OPERAND_FAULT		; process the reserved operand
1$:	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	INCL	OP_INDEX(FP)		; look at second operand
	BSBW	READ_ACCESS		; second operand is read only
	CMPL	#31,R0			; is the value reserved ?
	BGEQU	2$			; no - skip
	BRW	OPERAND_FAULT		; process the reserved operand
2$:	MOVL	R0,ADDRESS1(FP) 	; save the operand value
	INCL	OP_INDEX(FP)		; look at third operand
	BSBW	ADDRESS_ACCESS		; third operand is address only
	PROBER	MODE(FP),#4,(R11)	; can we read the first longword?
	BNEQ	3$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
3$:	MOVL	(R11)+,R0		; R0 = the first table entry
	MOVL	R11,ADDRESS2(FP)	; save the following address
	INCL	OP_INDEX(FP)		; use "fourth operand" type for rest
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	PACK_FLOAT2		; pack the value
	MOVL	R0,REG_R0(FP)		; save the value in user's R0
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	MOVL	ADDRESS2(FP),REG_R3(FP)	; store next location in user's R3
	MOVL	ADDRESS1(FP),REG_R2(FP) ; save the remaining iteration count
	CVTBL	REGMOD_PC(FP),R0	; R0 = PC register modifications
	CLRQ	REGMOD_R0(FP)		; clear modifications for R0 to R7
	CLRQ	REGMOD_R8(FP)		; clear modifications for R8 to PC
	MOVB	R0,REGMOD_PC(FP)	; put the PC modifications back
	DECL	R0			; subtract the operation code length
	INSV	R0,#8,#24,REG_R2(FP)	; save the value for resumption
	BSBW	PACK_FLOAT3		; pack the argument value
	MOVL	R0,REG_R1(FP)		; save it for resumption
	BBSS	#PSL_FPD,PSL(FP),4$	; indicate first part done in PSL
4$:	TSTB	REG_R2(FP)		; more iterations to perform ?
	BEQL	6$			; no - finish up
	BSBW	MULTIPLY_FLOAT		; multiply the result and argument
	INCL	R0			; increment the shift count
	INSV	#0,#0,R0,FRACTION1+12(FP); truncate the product
	MOVL	REG_R3(FP),R11		; R11 = location of next table entry
	PROBER	MODE(FP),#4,(R11)	; can we read the next coefficient ?
	BNEQ	5$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
5$:	MOVL	@REG_R3(FP),R0		; R0 = next coefficient
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	ADD_REAL		; add the coefficient to the product
	BSBW	PACK_FLOAT1		; pack the result so far
	MOVL	R0,REG_R0(FP)		; save the value
	BSBW	UNPACK_FLOAT2		; unpack the result for next iteration
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	ADDL2	#4,REG_R3(FP)		; update the table pointer
	DECB	REG_R2(FP)		; decrement the iteration counter
	BRB	4$			; start the next iteration
6$:	CLRL	REG_R1(FP)		; clear the user's R1
	CLRL	REG_R2(FP)		; clear the user's R2
	BBCC	#PSL_FPD,PSL(FP),7$	; indicate instruction complete
7$:	BRW	NORMAL_EXIT		; done

	;
	;	75 POLYD - Evaluate Polynomial D_floating
	;
INST_POLYD:				; entrance
	SET_OP_TYPES	D,W,B,D		; phantom fourth operand
	BRB	INST_POLYdg

	;
	;	55FD POLYG - Evaluate Polynomial G_floating
	;
INST_POLYG:				; entrance
	SET_OP_TYPES	G,W,B,G		; phantom fourth operand
	;BRB	INST_POLYdg

INST_POLYdg:
	BBC	#PSL_FPD,PSL(FP),1$	; not instruction resumption - bypass
	EXTZV	#8,#24,REG_R2(FP),R0	; R0 = saved instruction length
	ADDL2	R0,REG_PC(FP)		; position PC to end of instruction
	ADDB2	R0,REGMOD_PC(FP)	; increment the PC modification count
	MOVQ	REG_R0(FP),R0		; R0,R1 = result so far
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	MOVQ	REG_R4(FP),R0		; R0,R1 = argument value
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	CMPB	#31,REG_R2(FP)		; is the iteration count too large ?
	BGEQU	14$			; no - resume the instruction
	BRW	OPERAND_FAULT		; process the reserved operand
14$:	BRW	4$
1$:	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	INCL	OP_INDEX(FP)		; look at second operand
	BSBW	READ_ACCESS		; second operand is read only
	CMPL	#31,R0			; is the value reserved ?
	BGEQU	2$			; no - skip
	BRW	OPERAND_FAULT		; process the reserved operand
2$:	MOVL	R0,ADDRESS1(FP) 	; save the operand value
	INCL	OP_INDEX(FP)		; look at third operand
	BSBW	ADDRESS_ACCESS		; third operand is address only
	PROBER	MODE(FP),#8,(R11)	; can we read the first quadword ?
	BNEQ	3$			; yes - skip
	MOVL	#8,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
3$:	MOVQ	(R11)+,R0		; R0,R1 = the first table entry
	MOVL	R11,ADDRESS2(FP)	; save the following address
	INCL	OP_INDEX(FP)		; use "fourth operand" type for rest
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	PACK_FLOAT2		; pack the value
	MOVQ	R0,REG_R0(FP)		; save the value in user's R0-R1
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	MOVL	ADDRESS2(FP),REG_R3(FP)	; store next location in user's R3
	MOVL	ADDRESS1(FP),REG_R2(FP) ; save the remaining iteration count
	CVTBL	REGMOD_PC(FP),R0	; R0 = PC register modifications
	CLRQ	REGMOD_R0(FP)		; clear modifications for R0 to R7
	CLRQ	REGMOD_R8(FP)		; clear modifications for R8 to PC
	MOVB	R0,REGMOD_PC(FP)	; put the PC modifications back
	DECL	R0			; subtract the operation code length
	CMPB	@OP_INDEX(FP),#TYP_G	; POLYG?
	BNEQ	31$			; Skip if not
	DECL	R0			; Subtract another opcode byte length
31$:	INSV	R0,#8,#24,REG_R2(FP)	; save the value for resumption
	BSBW	PACK_FLOAT3		; pack the argument value
	MOVQ	R0,REG_R4(FP)		; save it for resumption
	BBSS	#PSL_FPD,PSL(FP),4$	; indicate first part done in PSL
4$:	TSTB	REG_R2(FP)		; more iterations to perform ?
	BEQL	6$			; no - finish up
	BSBW	MULTIPLY_FLOAT		; multiply the result and argument
	INCL	R0			; increment the shift count
	INSV	#0,#0,R0,FRACTION1+8(FP); truncate the product
	MOVL	REG_R3(FP),R11		; R11 = location of next table entry
	PROBER	MODE(FP),#8,(R11)	; can we read the next coefficient ?
	BNEQ	5$			; yes - skip
	MOVL	#8,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
5$:	MOVQ	@REG_R3(FP),R0		; R0 = next coefficient
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	ADD_REAL		; add the coefficient to the product
	BSBW	PACK_FLOAT1		; pack the result so far
	MOVQ	R0,REG_R0(FP)		; save the value
	BSBW	UNPACK_FLOAT2		; unpack the result for next iteration
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	ADDL2	#8,REG_R3(FP)		; update the table pointer
	DECB	REG_R2(FP)		; decrement the iteration counter
	BRB	4$			; start the next iteration
6$:	CLRL	REG_R2(FP)		; clear the user's R2
	CLRQ	REG_R4(FP)		; clear the user's R4 and R5
	BBCC	#PSL_FPD,PSL(FP),7$	; indicate instruction complete
7$:	BRW	NORMAL_EXIT		; done

	;
	;	75FD POLYH - Evaluate Polynomial HFLOAT
	;
INST_POLYH:				; entrance
	SET_OP_TYPES	H,W,B,H		; use "phantom" fourth argument
	BBC	#PSL_FPD,PSL(FP),3$	; not instruction resumption - bypass
	EXTZV	#8,#24,REG_R4(FP),R0	; R0 = saved instruction length
	ADDL2	R0,REG_PC(FP)		; position PC to end of instruction
	ADDB2	R0,REGMOD_PC(FP)	; increment the PC modification count
	MOVQ	REG_R0(FP),R0		; R0,R1 = first part of result so far
	MOVQ	REG_R2(FP),R2		; R2,R3 = second part of result so far
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	MOVL	REG_SP(FP),R11		; R11 = user's stack pointer
	PROBER	MODE(FP),#16,(R11)	; can we read a stacked octaword ?
	BNEQ	1$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVQ	(R11)+,R0		; R0,R1 = first part of argument
	MOVQ	(R11),R2		; R2,R3 = second part of argument
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	CMPB	#31,R4			; is the iteration count too large ?
	BLSSU	2$			; no - skip
	BRW	OPERAND_FAULT		; processed the reserved operand
2$:	BRW	7$			; resume the instruction
3$:	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT3		; unpack and save the value
	INCL	OP_INDEX(FP)		; look at second operand
	BSBW	READ_ACCESS		; second operand is read only
	CMPL	#31,R0			; is the value reserved ?
	BGEQU	4$			; no - skip
	BRW	OPERAND_FAULT		; process the reserved operand
4$:	MOVL	R0,ADDRESS1(FP) 	; save the operand value
	INCL	OP_INDEX(FP)		; look at third operand
	BSBW	ADDRESS_ACCESS		; third operand is address only
	MOVL	R11,ADDRESS2(FP)	; save the table address
	INCL	OP_INDEX(FP)		; use dummy fourth operand for datatype
	BSBW	PACK_FLOAT3		; pack the argument value
	SUBL2	#16,REG_SP(FP)		; decrement the user SP
	SUBB2	#16,REGMOD_SP(FP)	; remember the decrement
	MOVL	REG_SP(FP),R11		; R11 = user's stack pointer
	PROBEW	MODE(FP),#16,(R11)	; can we stack the argument ?
	BNEQ	5$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	WRITE_FAULT		; process the access violation
5$:	MOVQ	R0,(R11)+		; save first part of argument
	MOVQ	R2,(R11)		; save second part of argument
	MOVL	ADDRESS2(FP),R11	; R11 = coefficient table address
	PROBER	MODE(FP),#16,(R11)	; can we read the first octaword ?
	BNEQ	6$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
6$:	MOVQ	(R11)+,R0		; R0,R1 = first part of coefficient
	MOVQ	(R11)+,R2		; R2,R3 = second part of coefficient
	MOVL	R11,ADDRESS2(FP)	; save the following address
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	PACK_FLOAT2		; pack the value again
	MOVQ	R0,REG_R0(FP)		; save first part of value so far
	MOVQ	R2,REG_R2(FP)		; save second part of value so far
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	MOVL	ADDRESS1(FP),REG_R4(FP) ; save the remaining iteration count
	MOVL	ADDRESS2(FP),REG_R5(FP)	; save the next coefficient address
	CVTBL	REGMOD_PC(FP),R0	; R0 = PC register modifications
	CLRQ	REGMOD_R0(FP)		; clear modifications for R0 to R7
	CLRQ	REGMOD_R8(FP)		; clear modifications for R8 to PC
	MOVB	R0,REGMOD_PC(FP)	; put the PC modifications back
	SUBL2	#2,R0			; subtract the operation code length
	INSV	R0,#8,#24,REG_R4(FP)	; save the value for resumption
	BBSS	#PSL_FPD,PSL(FP),7$	; indicate first part done in PSL
7$:	TSTB	REG_R4(FP)		; more iterations to perform ?
	BEQL	9$			; no - finish up
	BSBW	MULTIPLY_FLOAT		; multiply the result and argument
	INCL	R0			; increment the shift count
	INSV	#0,#0,R0,FRACTION1(FP)	; truncate the product
	MOVL	REG_R5(FP),R11		; R11 = location of next table entry
	PROBER	MODE(FP),#16,(R11)	; can we read the next coefficient ?
	BNEQ	8$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
8$:	MOVL	REG_R5(FP),R11		; R11 = location of next table entry
	MOVQ	(R11)+,R0		; R0,R1 = first part of next entry
	MOVQ	(R11),R2		; R2,R3 = second part of next entry
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	ADD_REAL		; add the coefficient to the product
	BSBW	PACK_FLOAT1		; pack the result so far
	MOVQ	R0,REG_R0(FP)		; save the first part of the value
	MOVQ	R2,REG_R2(FP)		; save the second part of the value
	BSBW	UNPACK_FLOAT2		; unpack the result for next iteration
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	ADDL2	#16,REG_R5(FP)		; update the table pointer
	DECB	REG_R4(FP)		; decrement the iteration counter
	BRB	7$			; start the next iteration
9$:	CLRL	REG_R4(FP)		; clear the user's R4
	ADDL2	#16,REG_SP(FP)		; unstack the argument value
	BBCC	#PSL_FPD,PSL(FP),10$	; indicate instruction complete
10$:	BRW	NORMAL_EXIT		; done

	;
	;	7FFD PUSHAO - Push Address of Octaword
	;
	;	7FFD PUSHAH - Push Address of H_floating
	;
INST_PUSHAO:
	SET_OP_TYPES	O
	BSBW	ADDRESS_ACCESS		; first operand is address only
	SUBL2	#4,REG_SP(FP)		; decrement the user SP
	SUBB2	#4,REGMOD_SP(FP)	; remember the decrement
	MOVL	R11,R0			; R0 = the operand address
	MOVL	REG_SP(FP),R11		; R11 = user's stack pointer
	PROBEW	MODE(FP),#4,(R11)	; can we write the operand address ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	WRITE_FAULT		; process the access violation
1$:	MOVL	R0,@REG_SP(FP)		; stack the operand address
	TSTL	R0			; test the operand address
	BSBW	SET_CONDITION		; capture the condition code
	BICL2	#PSLM_V,PSL(FP) 	; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	42 SUBF2 - Subtract F_floating (Two Operands)
	;
INST_SUBF2:
	SET_OP_TYPES	F
	BRB	INST_SUBx2

	;
	;	62 SUBD2 - Subtract D_floating (Two Operands)
	;
INST_SUBD2:
	SET_OP_TYPES	D
	BRB	INST_SUBx2

	;
	;	42FD SUBG2 - Subtract G_floating (Two Operands)
	;
INST_SUBG2:
	SET_OP_TYPES	G
	BRB	INST_SUBx2

	;
	;	62FD SUBH2 - Subtract HFLOAT (Two Operands)
	;
INST_SUBH2:
	SET_OP_TYPES	H
	;BRB	INST_SUBx2

INST_SUBx2:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	MODIFY_ACCESS		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	43 SUBF3 - Subtract F_floating (Three Operands)
	;
INST_SUBF3:
	SET_OP_TYPES	F
	BRB	INST_SUBx3

	;
	;	63 SUBD3 - Subtract D_floating (Three Operands)
	;
INST_SUBD3:
	SET_OP_TYPES	D
	BRB	INST_SUBx3

	;
	;	43FD SUBG3 - Subtract G_floating (Three Operands)
	;
INST_SUBG3:
	SET_OP_TYPES	G
	BRB	INST_SUBx3

	;
	;	63FD SUBH3 - Subtract HFLOAT (Three Operands)
	;
INST_SUBH3:
	SET_OP_TYPES	H
	;BRB	INST_SUBx3

INST_SUBx3:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	READ_ACCESS		; second operand is read only
	BSBW	UNPACK_FLOAT2		; unpack and save the value
	BSBW	WRITE_ACCESS		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_FLOAT1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	BSBW	STORE_OPERAND		; store result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	53 TSTF - Test F_floating
	;
INST_TSTF:
	SET_OP_TYPES	F
	BRB	INST_TSTx

	;
	;	73 TSTD - Test D_floating
	;
INST_TSTD:
	SET_OP_TYPES	D
	BRB	INST_TSTx

	;
	;	53FD TSTG - Test G_floating
	;
INST_TSTG:
	SET_OP_TYPES	G
	BRB	INST_TSTx

	;
	;	73FD TSTH - Test HFLOAT
	;
INST_TSTH:
	SET_OP_TYPES	H
	;BRB	INST_TSTx

INST_TSTx:
	BSBW	READ_ACCESS		; first operand is read only
	BSBW	UNPACK_FLOAT1		; unpack and save the value
	MOVAB	OPERAND1(FP),R1 	; R1 = location of the value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	BRW	NORMAL_EXIT		; done
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*	    Routines for Scanning Instruction Operands	       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The following section contains a complex of routines for
	;	scanning the operands of an instruction and determining the
	;	values and locations of operands. The code contains full error
	;	checking and also checks for the situations that the
	;	architecture considers to be unpredictable. In order to make
	;	the operand scanning in the instruction emulation routines 
	;	clear, separate entrys appear for each possible kind of
	;	operand.
	;
	;
	;	Operand Scanning Routines
	;	-------------------------
	;
	;	    The operand scanning routines are entered by subroutine
	;	branching and have entry names of the form
	;
	;		<access type>_<data type>
	;
	;	in which <access type> is any one of the following
	;
	;		READ		operand is read only
	;		WRITE		operand is write only
	;		MODIFY		operand is both read and write
	;		ADDRESS		only the operand address is required
	;		BRANCH		relative branch destintion
	;
	;	and in which <data type> is any one of the following
	;
	;		BYTE		byte
	;		WORD		word
	;		LONG		longword
	;		QUAD		quadword
	;		OCTA		octaword
	;		FLOAT		F-format floating
	;		DFLOAT		D-format floating
	;		GFLOAT		G-format floating
	;		HFLOAT		H-format floating
	;
	;	For an access type of BRANCH the data type refers to the
	;	size of the relative address rather than the properties of
	;	any addressed information.
	;
	;	    Entrys only exist for those types of operands which appear
	;	in the emulated instructions. If additional entrys are 
	;	required they can be added easily enough.
	;
	;	    When the routines are entered they scan the next 
	;	instruction operand starting at the value of the user's PC
	;	and check the operand for validity. If any exceptions are
	;	detected during operand scanning they are processed immediatly
	;	and the routines do not return. Any changes that are made to
	;	any of the registers (including PC) are recorded in the change
	;	bytes so faults will be handled properly.
	;
	;	    When the routines return the following rules describe the
	;	contents of the registers:
	;
	;	     o	If the access type is READ or MODIFY and the data type
	;		is BYTE, WORD, LONG, or FLOAT, then R0 is the value
	;		of the operand. If the data type is BYTE or WORD then
	;		the value is sign extended to a longword.
	;
	;	     o	If the access type is READ or MODIFY and the data type
	;		is QUAD, DFLOAT, or GFLOAT, then R0-R1 contains the
	;		value of the operand.
	;
	;	     o	If the access type is READ or MODIFY and the data type
	;		is OCTA or HFLOAT then R0-R3 contains the value of the
	;		operand.
	;
	;	     o	If the access type is WRITE, MODIFY, ADDRESS, or
	;		BRANCH, then R11 is the address of the operand or the
	;		branch destination.
	;
	;	If the instruction operand specifies register mode, then the
	;	address associated with the operand is the location of the
	;	emulated register. If an instruction operand with WRITE or
	;	MODIFY access addresses the Emulator's local storage then it
	;	is changed to an address that won't do any harm. This is 
	;	consistant with the notion that the area below the user's
	;	stack pointer is being continually garbaged. This check is not
	;	performed if flag bit 0 is set. The routines set flag bit 1 if
	;	the operand is a register mode operand.
	;
	;	    The subroutine LOCAL_TEST is available for checking for 
	;	stores into the Emulator's local storage in places where this
	;	is not done automatically.
	;
	;
	;	Exceptions
	;	----------
	;
	;	    The instruction operand scanning routines perform complete
	;	error checking and immediatly signal any exceptions detected.
	;	All of these exceptions are faults. The change bytes are
	;	constantly kept up to date so the instruction will be left in
	;	a consistant state for restarting if a fault occurs.
	;
	;	    All fetches from memory done in scanning the instruction
	;	operand or in fetching the operand or operand address are 
	;	probed and access violations are signaled if the probes fail.
	;	All of the addressing modes specified by the architecture to
	;	be reserved addressing modes or unpredictable are checked for
	;	and are signaled as reserved addressing modes if they are
	;	detected.
	;
	;
	;	Routine Organization
	;	--------------------
	;
	;	    Except for BRANCH access mode for which there are only
	;	isolated routines, the code at the individual routine 
	;	entrances simply loads the data type code into R9 and branches
	;	to a routine for the access type. This routine in turn loads
	;	the access type code into R8 and branches to the routine 
	;	GET_SPECIFIER which process the operand specifier byte.
	;
	;	    GET_SPECIFIER loads the length of the data type into R10
	;	and the operand specifier byte into R0. The high and low 
	;	order nibbles of this byte are stored in R1 and R2. The 
	;	register R7 which is reserved for the index modification is 
	;	cleared. The routine now branches on the high order nibble
	;	to a routine which will handle the specific kind of operand.
	;
	;	    For literals the values are expanded immediatly and the
	;	routine returns.
	;
	;	    For index mode operand specifiers, the index modification
	;	is computed and the next operand specifier byte is loaded into
	;	R0 and decomposed as before. Again we branch on the high order
	;	nibble but this time certain addressing modes which are 
	;	illegal with indexing are checked for. Also for those 
	;	addressing modes which change register values a check is made
	;	that the register is not the same as the index register.
	;
	;	    For register mode operands the address of the emulated
	;	register is loaded into R11. A check is made that the operand
	;	does not contain PC. Then flag bit 1 is set and control passes
	;	to the operand reading routine if the access type is READ or
	;	MODIFY and the routine returns otherwise.
	;
	;	    For the remaining addressing modes the operand addresses
	;	are computed in a straightforward manner and loaded into R11.
	;	for some of these addressing modes the values of registers may
	;	be changed. These changes are reflected in the change bytes.
	;	When the operand address is computed control passes to the 
	;	operand accessing routine.
	;	
	;	    For ADDRESS access mode operands the operand accessing
	;	routine returns but for all others it probes the operand 
	;	address and also checks for writes into the Emulator's local
	;	storage unless flag bit 0 is set. If the operand is READ or
	;	MODIFY access control passes to the operand reading routine.
	;
	;	    The operand reading routine simply reads the operand 
	;	value into the registers starting at R0 and then returns.
	;	Bytes and Words are sign extended into longwords. However
	;	this routine does not check for reserved floating values
	;	since this is done by the unpack routines.
	;

	;
	;	Process a Read Only Operand
	;
READ_ACCESS:				; entrance
	MOVL	#TYPE_READ,R8		; R8 = access type
	MOVZBL	@OP_INDEX(FP),R9	; R9 = data type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Process a Write Only Operand
	;
WRITE_ACCESS:				; entrance
	MOVL	#TYPE_WRITE,R8		; R8 = access type
	MOVZBL	@OP_INDEX(FP),R9	; R9 = data type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Process a Modified Operand
	;
MODIFY_ACCESS:				; entrance
	MOVL	#TYPE_MODIFY,R8 	; R8 = access type
	MOVZBL	@OP_INDEX(FP),R9	; R9 = data type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Process an Addressed Operand
	;
ADDRESS_ACCESS: 			; entrance
	MOVL	#TYPE_ADDRESS,R8	; R8 = access type
	MOVZBL	@OP_INDEX(FP),R9	; R9 = data type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Table of Data Type Lengths
	;
LENGTHS:				; table origin
	.BYTE	1			; 1 - byte
	.BYTE	2			; 2 - word
	.BYTE	4			; 3 - longword
	.BYTE	8			; 4 - quadword
	.BYTE	16			; 5 - octaword
	.BYTE	4			; 6 - F_floating
	.BYTE	8			; 7 - D_floating
	.BYTE	8			; 8 - G_floating
	.BYTE	16			; 9 - H_floating
	;
	;	Process the Next Operand Specifier
	;
GET_SPECIFIER:				; entrance
	MOVZBL	LENGTHS-1[R9],R10	; R10 = data type length
	CLRL	R7			; clear the index value
	MOVL	REG_PC(FP),R11		; R11 = specifier byte location
	PROBER	MODE(FP),#1,(R11)	; can we read the specifier byte ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process an access violation
1$:	MOVZBL	@REG_PC(FP),R0		; R0 = specifier byte
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the incrementation
	EXTZV	#4,#4,R0,R1		; R1 = high order nibble of specifier
	EXTZV	#0,#4,R0,R2		; R2 = low order nibble of specifier
	CASEL	R1,#0,#15		; branch on the high order nibble
2$:	.WORD	LITERAL_MODE-2$ 	; 0 - literal mode
	.WORD	LITERAL_MODE-2$ 	; 1 - literal mode
	.WORD	LITERAL_MODE-2$ 	; 2 - literal mode
	.WORD	LITERAL_MODE-2$ 	; 3 - literal mode
	.WORD	INDEX_MODE-2$		; 4 - index mode
	.WORD	REGISTER_MODE-2$	; 5 - register mode
	.WORD	REG_DEF_MODE-2$ 	; 6 - register deferred mode
	.WORD	DECR_MODE-2$		; 7 - autodecrement mode
	.WORD	INCR_MODE-2$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-2$	; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-2$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-2$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-2$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-2$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-2$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-2$	; F - long displacement deferred mode
	;
	;	Process a Literal Mode Operand Specifier
	;
LITERAL_MODE:				; entrance
	CASEL	R8,#1,#3		; branch on the access type
1$:	.WORD	2$-1$			; 1 - read only access
	.WORD	ADDRESS_FAULT-1$	; 2 - write only access
	.WORD	ADDRESS_FAULT-1$	; 3 - modify access
	.WORD	ADDRESS_FAULT-1$	; 4 - address access
2$:	CASEL	R9,#1,#8		; branch on the data type
3$:	.WORD	6$-3$			; 1 - byte
	.WORD	6$-3$			; 2 - word
	.WORD	6$-3$			; 3 - longword
	.WORD	5$-3$			; 4 - quadword
	.WORD	4$-3$			; 5 - octaword
	.WORD	8$-3$			; 6 - F_floating
	.WORD	7$-3$			; 7 - D_floating
	.WORD	9$-3$			; 8 - G_floating
	.WORD	10$-3$			; 9 - H_floating
4$:	CLRQ	R2			; clear second quadword of value
5$:	CLRL	R1			; clear second longword of value
6$:	RSB				; return with the literal value
7$:	CLRL	R1			; clear second longword of value
8$:	ASHL	#4,R0,R0		; position the literal bits
	BBCS	#14,R0,6$		; include exponent bias and return
9$:	ASHL	#1,R0,R0		; position the literal bits
	BBCS	#14,R0,5$		; include exponent bias and finish up
10$:	ROTL	#29,R0,R0		; position the literal bits
	BBCS	#14,R0,4$		; include exponent bias and finish up
	;
	;	Process an Index Mode Operand Specifier
	;
INDEX_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BNEQ	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	MULL3	R10,REG_R0(FP)[R2],R7	; R7 = index address modification
	MOVL	R2,R3			; save the register number
	MOVL	REG_PC(FP),R11		; R11 = location of next byte
	PROBER	MODE(FP),#1,(R11)	; can we read the next byte ?
	BNEQ	2$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	MOVZBL	@REG_PC(FP),R0		; R0 = next operand specifier
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the incrementation
	EXTZV	#4,#4,R0,R1		; R1 = high order nibble of specifier
	EXTZV	#0,#4,R0,R2		; R2 = low order nibble of specifier
	CASEL	R1,#0,#15		; branch on the low order nibble
3$:	.WORD	ADDRESS_FAULT-3$	; 0 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 1 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 2 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 3 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 4 - index mode
	.WORD	ADDRESS_FAULT-3$	; 5 - register mode
	.WORD	REG_DEF_MODE-3$ 	; 6 - register deferred mode
	.WORD	4$-3$			; 7 - autodecrement mode
	.WORD	4$-3$			; 8 - autoincrement mode
	.WORD	4$-3$			; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-3$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-3$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-3$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-3$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-3$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-3$	; F - long displacement deferred mode
4$:	CMPL	R2,R3			; is register the same as index ?
	BNEQ	5$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
5$:	CASEL	R1,#7,#2		; branch on the high order nibble
6$:	.WORD	DECR_MODE-6$		; 7 - autodecrement mode
	.WORD	INCR_MODE-6$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-6$	; 9 - autoincrement deferred mode
	;
	;	Process a Register Mode Operand Specifier
	;
REGISTER_MODE:				; entrance
	BISB2	#FLAG1M,FLAGS(FP)	; indicate a register mode operand
	MOVAL	(R10)[R2],R3		; byte position following operand
	CMPL	#60,R3			; does the operand overlap PC ?
	BGEQ	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	MOVAL	REG_R0(FP)[R2],R11	; R11 = location of user register
	CASEL	R8,#1,#3		; branch on the access type
2$:	.WORD	READ_VALUE-2$		; 1 - read only access
	.WORD	3$-2$			; 2 - write access
	.WORD	READ_VALUE-2$		; 3 - modify access
	.WORD	ADDRESS_FAULT-2$	; 4 - address access
3$:	RSB				; return with the register address
	;
	;	Process a Register Deferred Mode Operand Specifier
	;
REG_DEF_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	1$			; no - skip
	BRW	ADDRESS_FAULT 		; process the reserved addressing mode
1$:	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process an Autodecrement Mode Operand Specifier
	;
DECR_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	SUBL2	R10,REG_R0(FP)[R2]	; subtract data size from register
	SUBB2	R10,REGMOD_R0(FP)[R2]	; remember the subtraction
	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process an Autoincrement Mode Operand Specifier
	;
INCR_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	2$			; no - bypass
	CASEL	R8,#1,#3		; branch on the access type
1$:	.WORD	2$-1$			; 1 - read only access
	.WORD	ADDRESS_FAULT-1$	; 2 - write only access
	.WORD	ADDRESS_FAULT-1$	; 3 - modify access
	.WORD	2$-1$			; 4 - address access
2$:	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	ADDL2	R10,REG_R0(FP)[R2]	; add the data size to the register
	ADDB2	R10,REGMOD_R0(FP)[R2]	; remember the addition
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process an Autoincrement Deferred Mode Operand Specifier
	;
INCR_DEF_MODE:				; entrance
	MOVL	REG_R0(FP)[R2],R11	; R11 = register value
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL3	R7,(R11),R11		; form the operand address
	ADDL2	#4,REG_R0(FP)[R2]	; add longword size to the register
	ADDB2	#4,REGMOD_R0(FP)[R2]	; remember the incrementation
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Byte Displacement Mode Operand Specifier
	;
BYTE_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTBL	(R11),R11		; R11 = displacement value
	INCL	REG_PC(FP)		; increment PC
	INCL	REGMOD_PC(FP)		; remember the increment
	ADDL2	R7,R11			; add the displacement to the index
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the result
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Byte Displacement Deferred Mode Operand Specifier
	;
BYTE_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTBL	(R11),R11		; R11 = displacement value
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the increment
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access fault
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Word Displacement Mode Operand Specifier
	;
WORD_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = displacement value
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDB2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	R7,R11			; add the index to the displacement
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the result
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Word Displacement Deferred Mode Operand Specifier
	;
WORD_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = displacement value
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDB2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Long Displacement Mode Operand Specifier
	;
LONG_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVL	(R11),R11		; R11 = displacement value
	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDB2	#4,REGMOD_PC(FP)	; remember the increment
	ADDL2	R7,R11			; add the index to the displacement
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Long Displacement Deferred Mode Operand Specifier
	;
LONG_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVL	(R11),R11		; R11 = displacement value
	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDB2	#4,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Set Up the Type of Access Requested
	;
ACCESS_VALUE:				; entrance
	CASEL	R8,#1,#3		; branch on the access type
1$:	.WORD	READ_CHECK-1$		; 1 - read only access
	.WORD	WRITE_CHECK-1$		; 2 - write only access
	.WORD	MODIFY_CHECK-1$ 	; 3 - modify access
	.WORD	2$-1$			; 4 - address access
2$:	RSB				; return with the operand address
	;
	;	Perform Error Checking for Modify Access Operands
	;
MODIFY_CHECK:				; entrance
	BSBB	WRITE_CHECK		; check write (and read) access
	BRB	READ_VALUE		; load the value
	;
	;	Perform Error Checking for Read Only Access Operands
	;
READ_CHECK:				; entrance
	PROBER	MODE(FP),R10,(R11)	; can we read the operand ?
	BNEQ	1$			; yes - load the value
	BSBW	READ_FAULT		; process the access violation
1$:	BRB	READ_VALUE		; load the value
	;
	;	Perform Error Checking for Write Only Access Operands
	;
WRITE_CHECK:				; entrance
	PROBEW	MODE(FP),R10,(R11)	; can we write the operand ?
	BNEQ	1$			; yes - bypass
	BSBW	WRITE_FAULT		; process the access violation
	BBS	#FLAG0,FLAGS(FP),1$	; no local store checking - skip
	BSBW	LOCAL_TEST		; test for a write into local storage
1$:	RSB				; return
	;
	;	Load a Read Operand into the Registers
	;
READ_VALUE:				; entrance
	CASEL	R9,#1,#8		; branch on the data type
1$:	.WORD	2$-1$			; 1 - byte
	.WORD	3$-1$			; 2 - word
	.WORD	4$-1$			; 3 - longword
	.WORD	6$-1$			; 4 - quadword
	.WORD	5$-1$			; 5 - octaword
	.WORD	4$-1$			; 6 - F_floating
	.WORD	6$-1$			; 7 - D_floating
	.WORD	6$-1$			; 8 - G_floating
	.WORD	5$-1$			; 9 - H_floating
2$:	CVTBL	(R11),R0		; R0 = operand value
	RSB				; return
3$:	CVTWL	(R11),R0		; R0 = operand value
	RSB				; return
4$:	MOVL	(R11),R0		; R0 = operand value
	RSB				; return
5$:	MOVQ	8(R11),R2		; R2,R3 = high order quadword of value
6$:	MOVQ	(R11),R0		; R0,R1 = low order quadword of value
	RSB				; return
	;
	;	Process a Word Branch Displacement Operand
	;
BRANCH_WORD:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = branch displacement
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDB2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_PC(FP),R11		; compute the branch destination
	RSB				; return
	;
	;	Test for a Write into Local Storage
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Number of Bytes to be Written
	;				R11 = Distination Address
	;
	;		returns with	R11 = Corrected Destination Address
	;
	;	Discussion
	;	
	;	    This routine checks the write operation described by
	;	the parameters in R10 and R11 for a write into the Emulator's
	;	working storage. If such a write is about to take place, R11
	;	is changed to an address where the write will not do any harm.
	;
LOCAL_TEST:				; entrance
	MOVAB	LOCAL_END(FP),R3	; R3 = byte following local storage
	CMPL	R11,R3			; is the write above the frame ?
	BGEQU	1$			; yes - bypass
	ADDL3	R10,R11,R3		; R3 = byte following operand
	CMPL	R3,SP			; is it above the stack pointer ?
	BLEQU	1$			; no - operand is not in local storage
	MOVAB	TEMP(FP),R11		; redirect the write to TEMP
1$:	RSB				; return with the operand address
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*       Routines for Unpacking and Packing Floating Values     *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The following routines perform all of the conversions
	;	between the VAX floating representations and the internal 
	;	representation used by the Emulator. The unpack routines
	;	convert from the VAX representation to the internal 
	;	representation and the pack routines perform the opposite
	;	conversion. These routines perform all of the necessary
	;	rounding and check for reserved values, underflow, and 
	;	overflow.
	;
	;
	;	The Unpack Routines
	;	-------------------
	;
	;	    The unpack routines convert a value in one of the VAX
	;	floating representations to our internal representation.
	;	The value to be converted is assumed to be contained in
	;	the registers starting at R0. For floating and double 
	;	floating values the available unpack routines only place
	;	the converted value in OPERAND1. For GFLOAT and HFLOAT routines
	;	are available which place the result in all of the operand
	;	areas.
	;
	;	    The unpack routines all check for a reserved floating
	;	value (sign bit set and biased exponent equal to zero) and
	;	signal a reserved operand exception if one is found.
	;
	;
	;	The Pack Routines
	;	-----------------
	;
	;	    The pack routines convert a value in the internal 
	;	representation to one of the VAX floating representations.
	;	The value to be converted is assumed to be in one of the
	;	operand areas and the value must be in OPERAND1 if the value
	;	is to be converted to floating or double floating. For GFLOAT
	;	and HFLOAT routines are available to convert from each of the
	;	operand areas. The routines always leave the result in the
	;	registers starting at R0.
	;
	;	    Before the value is converted the rounding bit (the first
	;	bit of the fraction which will not appear in the converted
	;	result) is tested and if it is set the value is rounded by
	;	adding one to the next higher bit (the lowest one that will
	;	appear in the converted result) and processing any carries
	;	that occur. When the conversion is performed the biased
	;	exponent is checked for possible overflow or underflow. If an 
	;	overflow condition is detected, then the condition is
	;	signaled. If an underflow condition is detected, then the
	;	condition is signaled only if the FU bit is set in the user's
	;	PSL. If the bit is not set then a value of zero is returned.
	;	If a nonzero value is converted to zero because of underflow,
	;	the source value in operand area will be marked as zero so
	;	condition code determination will still work properly.
	;

	;
	;	UNPACK_FLOAT1 - Unpack a floating value to OPERAND1
	;
UNPACK_FLOAT1:
	MOVAB	OPERAND1(FP), R4	; operand area address
	BRB	UNPACK_FLOAT

	;
	;	UNPACK_FLOAT2 - Unpack a floating value to OPERAND2
	;
UNPACK_FLOAT2:
	MOVAB	OPERAND2(FP), R4	; operand area address
	BRB	UNPACK_FLOAT

	;
	;	UNPACK_FLOAT3 - Unpack a floating value to OPERAND3
	;
UNPACK_FLOAT3:
	MOVAB	OPERAND3(FP), R4	; operand area address
	;BRB	UNPACK_FLOAT

UNPACK_FLOAT:
	CASEB	@OP_INDEX(FP),#TYP_F,#<TYP_H-TYP_F>
1$:	.WORD	UNPACK_FFLOAT-1$	; 6 - F_floating
	.WORD	UNPACK_DFLOAT-1$	; 7 - D_floating
	.WORD	UNPACK_GFLOAT-1$	; 8 - G_floating
	.WORD	UNPACK_HFLOAT-1$	; 9 - H_floating

	;
	;	UNPACK_FFLOAT - Unpack a Floating Value 
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = Input Floating Value
	;
	;		returns with	(R4) = Converted Value
	;
	;		uses R0-R5
	;
UNPACK_FFLOAT:				; entrance
	CLRL	R1			; make F look like D
	;BRB	UNPACK_DFLOAT		; use D_floating unpack
	;

	;
	;	UNPACK_DFLOAT - Unpack a Double Floating Value 
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0,R1 = Input Double Floating Value
	;
	;		returns with	(R4) = Converted Value
	;
	;		uses R0-R5
	;
UNPACK_DFLOAT:				; entrance
	CLRL	(R4)			; clear the zero and sign flags
	EXTZV	#7,#8,R0,R5		; R5 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; double floating value is reserved
1$:	INCB	ZERO(R4)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN(R4)		; indicate a negative value
3$:	MOVAB	-128(R5),POWER(R4)	; store the unbiased exponent
	ROTL	#16,R0,R0		; R0 = leading bits of the fraction
	BBSS	#23,R0,4$		; set the hidden bit
4$:	INSV	R0,#8,#24,FRACTION+12(R4); store bits 40-63 of the fraction
	ROTL	#16,R1,R1		; R1 = trailing bits of the fraction
	MOVL	R1,FRACTION+9(R4)	; store bits 8-39 of the fraction
	CLRB	FRACTION+8(R4)	 	; clear bits 0-7 of the fraction
	CLRQ	FRACTION(R4)		; extend the fraction to 128 bits
	RSB				; return
	;

	;
	;	UNPACK_GFLOAT- Unpack a G_floating Floating Value 
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0,R1 = Input G_floating Floating Value
	;
	;		returns with 	(R4) = Converted Value
	;
	;		uses R0-R5
	;
UNPACK_GFLOAT:				; entrance
	CLRL	(R4)			; clear the zero and sign flags
	EXTZV	#4,#11,R0,R5		; R5 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; G_floating floating value is reserved
1$:	INCB	ZERO(R4)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN(R4)		; indicate a negative value
3$:	MOVAB	-1024(R5),POWER(R4)	; store the unbiased exponent
	ROTL	#16,R0,R0		; R0 = leading bits of the fraction
	BBSS	#20,R0,4$		; set the hidden bit
4$:	INSV	R0,#11,#21,FRACTION+12(R4); store bits 43-63 of the fraction
	ROTL	#16,R1,R1		; R1 = trailing bits of the fraction
	INSV	R1,#11,#32,FRACTION+8(R4); store bits 11-42 of the fraction
	INSV	#0,#0,#11,FRACTION+8(R4); clear bits 0-10 of the fraction
	CLRQ	FRACTION(R4)		; extend the fraction to 128 bits
	RSB				; return
	;

	;
	;	UNPACK_HFLOAT - Unpack a HFLOAT Floating Value 
	;
	;		entered by subroutine branching
	;	
	;		parameter:	R0,R1,R2,R3 = Input HFLOAT Value
	;
	;		returns with	(R4) = Converted Value
	;
	;		uses R0-R5
	;
	;
UNPACK_HFLOAT:				; entrance
	CLRL	(R4)			; clear the zero and sign flags
	EXTZV	#0,#15,R0,R5		; R5 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; HFLOAT floating value is reserved
1$:	INCB	ZERO(R4)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN(R4)		; indicate a negative value
3$:	MOVAB	-16384(R5),POWER(R4)	; store the unbiased exponent
	ROTL	#16,R0,R0		; R0 = leading bits of the fraction
	BBSS	#16,R0,4$		; set the hidden bit
4$:	INSV	R0,#15,#17,FRACTION+12(R4); store bits 111-127 of the fraction
	ROTL	#16,R1,R1		; R1 = next bits of the fraction
	INSV	R1,#15,#32,FRACTION+8(R4); store bits 79-110 of the fraction
	ROTL	#16,R2,R2		; R2 = next bits of the fraction
	INSV	R2,#15,#32,FRACTION+4(R4); store bits 47-78 of the fraction
	ROTL	#16,R3,R3		; R3 = next bits of the fraction
	INSV	R3,#15,#32,FRACTION(R4) ; store bits 15-46 of the fraction
	INSV	#0,#0,#15,FRACTION(R4)	; clear bits 0-14 of the fraction
	RSB				; return
	;

	;
	;	PACK_FLOAT1 - Pack a floating value to OPERAND1
	;
PACK_FLOAT1:
	MOVAB	OPERAND1(FP), R4	; operand area address
	BRB	PACK_FLOAT

	;
	;	PACK_FLOAT2 - Pack a floating value to OPERAND2
	;
PACK_FLOAT2:
	MOVAB	OPERAND2(FP), R4	; operand area address
	BRB	PACK_FLOAT

	;
	;	PACK_FLOAT3 - Pack a floating value to OPERAND3
	;
PACK_FLOAT3:
	MOVAB	OPERAND3(FP), R4	; operand area address
	;BRB	PACK_FLOAT

PACK_FLOAT:
	CASEB	@OP_INDEX(FP),#TYP_F,#<TYP_H-TYP_F>
1$:	.WORD	PACK_FFLOAT-1$		; 6 - F_floating
	.WORD	PACK_DFLOAT-1$		; 7 - D_floating
	.WORD	PACK_GFLOAT-1$		; 8 - G_floating
	.WORD	PACK_HFLOAT-1$		; 9 - H_floating


	;
	;	PACK_FFLOAT - Pack an F_floating Value 
	;
	;		entered by subroutine branching
	;
	;		parameter:	(R4) = Source Value
	;
	;		returns with	R0 = Converted Floating Value
	;
PACK_FFLOAT:				; entrance
	BLBC	ZERO(R4),2$		; value is not zero - bypass
1$:	CLRL	R0			; clear the value
	RSB				; return
2$:	BBC	#7,FRACTION+12(R4),3$	; rounding bit is zero - bypass
	ADDL2	#1@8,FRACTION+12(R4)	; round the value
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER(R4)		; increment the exponent
	CLRL	R0			; clear the fraction bits
	BRB	4$			; bypass
3$:	ROTL	#8,FRACTION+12(R4),R0	; load the fraction
4$:	ADDL3	#128,POWER(R4),R1	; R1 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,(R4) 		; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#255,R1 		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	INSV	R1,#7,#9,R0		; insert exponent and clear sign
	BLBC	SIGN(R4),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;
	;	PACK_DFLOAT - Pack a D_floating Value 
	;
	;		entered by subroutine branching
	;
	;		parameter:	(R4)= Source Value
	;
	;		returns with	R0,R1 = Converted Double Value
	;
PACK_DFLOAT:				; entrance
	BLBC	ZERO(R4),2$		; value is not zero - bypass
1$:	CLRQ	R0			; clear the value
	RSB				; return
2$:	BBC	#7,FRACTION+8(R4),3$	; rounding bit is zero - bypass
	ADDL2	#1@8,FRACTION+8(R4)	; round the value
	ADWC	#0,FRACTION+12(R4)	; propagate any carry
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER(R4)		; increment the exponent
	CLRQ	R0			; clear the fraction bits
	BRB	4$			; bypass
3$:	ROTL	#8,FRACTION+12(R4),R0	; load the first part of the fraction
	ROTL	#16,FRACTION+9(R4),R1	; load the second part of the fraction
4$:	ADDL3	#128,POWER(R4),R2	; R2 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,(R4)		 	; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#255,R2 		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	INSV	R2,#7,#9,R0		; insert exponent and clear sign
	BLBC	SIGN(R4),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;
	;	PACK_GFLOAT - Pack a G_floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	R4 = Location of Source Value
	;
	;		returns with 	R0,R1 = Converted G_floating Value
	;
PACK_GFLOAT:				; entrance
	BLBC	ZERO(R4),2$		; value is not zero - bypass
1$:	CLRQ	R0			; clear the value
	RSB				; return
2$:	BBC	#10,FRACTION+8(R4),3$	; rounding bit is zero - bypass
	ADDL2	#1@11,FRACTION+8(R4)	; round the value
	ADWC	#0,FRACTION+12(R4)	; propagate any carry
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER(R4)		; increment the exponent
	CLRQ	R0			; clear the fraction bits
	BRB	4$			; bypass
3$:	ROTL	#5,FRACTION+12(R4),R0	; load the first part of the fraction
	EXTV	#11,#32,FRACTION+8(R4),R1 ; load second part of the fraction
	ROTL	#16,R1,R1		; unscramble the bits
4$:	ADDL3	#1024,POWER(R4),R3	; R3 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,(R4) 		; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#2047,R3		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	INSV	R3,#4,#12,R0		; insert exponent and clear sign
	BLBC	SIGN(R4),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;
	;	PACK_HFLOAT - Pack an H_floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	R4 = Location of Source Value
	;
	;		returns with	R0,R1,R2,R3 = Converted HFLOAT Value
	;
PACK_HFLOAT:				; entrance
	BLBC	ZERO(R4),2$		; value is not zero - bypass
1$:	CLRQ	R0			; clear the first part of the value
	CLRQ	R2			; clear the second part of the value
	RSB				; return
2$:	BBC	#14,FRACTION(R4),3$	; rounding bit is zero - bypass
	ADDL2	#1@15,FRACTION(R4)	; round the value
	ADWC	#0,FRACTION+4(R4)	; propagate carry into third part
	ADWC	#0,FRACTION+8(R4)	; propagate carry into second part
	ADWC	#0,FRACTION+12(R4)	; propagate carry into first part
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER(R4)		; increment the exponent
	CLRQ	R0			; clear first part of the fraction
	CLRQ	R2			; clear second part of the fraction
	BRB	4$			; bypass
3$:	ASHL	#1,FRACTION+12(R4),R0	; load first part of the fraction
	EXTV	#15,#32,FRACTION+8(R4),R1 ; load second part of the fraction
	ROTL	#16,R1,R1		; reverse the words
	EXTV	#15,#32,FRACTION+4(R4),R2 ; load third part of the fraction
	ROTL	#16,R2,R2		; reverse the words
	EXTV	#15,#32,FRACTION(R4),R3 ; load	third part of the fraction
	ROTL	#16,R3,R3		; reverse the words
4$:	ADDL3	#16384,POWER(R4),R5	; R5 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,(R4) 		; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#32767,R5		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	MOVW	R5,R0			; insert exponent and clear sign
	BLBC	SIGN(R4),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	.SBTTL	STORE_OPERAND

	;
	;	STORE_OPERAND - Move result to destination
	;
	;	entered by BSBW
	;
	;	arguments:	R0-R3 contain operand to store
	;			R11 contains address of destination
	;			OP_INDEX(FP) contains pointer to type code
	;

STORE_OPERAND:
	CASEB	@OP_INDEX(FP),#TYP_B,#<TYP_H-TYP_B>
1$:	.WORD	2$-1$			; 1 - byte
	.WORD	3$-1$			; 2 - word
	.WORD	4$-1$			; 3 - longword
	.WORD	6$-1$			; 4 - quadword
	.WORD	5$-1$			; 5 - octaword
	.WORD	4$-1$			; 6 - F_floating
	.WORD	6$-1$			; 7 - D_floating
	.WORD	6$-1$			; 8 - G_floating
	.WORD	5$-1$			; 9 - H_floating

2$:	MOVB	R0,(R11)		; byte
	RSB				; 
3$:	MOVW	R0,(R11)		; word
	RSB				; 
4$:	MOVL	R0,(R11)		; longword
	RSB				; 
5$:	MOVQ	R2,8(R11)		; octaword
6$:	MOVQ	R0,(R11)		; quadword
	RSB				; 
	

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		      Arithmetic Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The routines which follow perform the actual floating
	;	arithmetic operations of the Emulator. These routines all
	;	work with the internal floating representation so only one
	;	routine is needed for each type of operation. However, since
	;	multiplication and division are comparatively slow operations
	;	separate routines have been included for the GFLOAT and HFLOAT
	;	versions of these operations so the GFLOAT operation will not
	;	be slowed to the speed of the HFLOAT operation.
	;
	;	    The algorithms for the individual routines will be
	;	described in the routines themselves. The following discussion
	;	will be limited to a description of our internal floating 
	;	format.
	;
	;
	;	Internal Floating Representation
	;	--------------------------------
	;
	;	    All of the floating arithmetic operations used by the 
	;	Emulator are performed using an internal floating format
	;	which is much easier to work with than any of the hardware
	;	floating representations and which is sufficiently accurate
	;	to represent all of the hardware representations. The format
	;	is also used as an intermediate representation for emulating
	;	the conversion instructions.
	;
	;	    The internal representation has the following four fields:
	;
	;
	;		ZERO		is a one byte field whose low order
	;				bit indicates that the represented
	;				value is nonzero.
	;
	;		SIGN		is a one byte field whose low order
	;				bit indicates that the represented
	;				value is negative. If the low order
	;				bit of ZERO is set then this field
	;				must be zero.
	;
	;		POWER		is a longword field which contains the
	;				exponent of the power of two which
	;				is used to scale the fraction
	;
	;		FRACTION	is a 128 bit field (four longwords)
	;				which hold the fraction as a single
	;				128 bit value. The decimal point is
	;				assumed to be at the end of the 
	;				fraction next to the high order bit.
	;				The fraction is considered to be a
	;				a positive value and is normalized
	;				if the high order bit is one.
	;
	;
	;	Three areas OPERAND1, OPERAND2, OPERAND3 are available for
	;	holding values in the internal representation. The name of
	;	of a field of one of these areas is found by appending the
	;	trailing digit of the area name to the field name. Thus
	;	POWER2 is the POWER field of OPERAND2.
	;

	;
	;	NEGATE_REAL - Negate a Real Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with 	OPERAND1 = The Negated Result
	;
	;	Discussion
	;	
	;	    If the value is nonzero, then the sign of the value
	;	is complemented.
	;
NEGATE_REAL:				; entrance
	BLBS	ZERO1(FP),1$		; don't negate zero
	XORB2	#1,SIGN1(FP)		; complement the sign
1$:	RSB				; return
	;
	;	FLOAT_LONG - Convert a Longword to a Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = The Longword Value
	;
	;		returns with	OPERAND1 = The Converted Value
	;
	;	Discussion
	;
	;	    The longword is converted to double floating using the
	;	hardware and then to the internal representation by one of
	;	the unpack routines.
	;
FLOAT_LONG:				; entrance
;*
; The original code used CVTLD, which we can no longer assume is supported
; in hardware.  The action of a CVTLD R0,R0 is therefore emulated using
; non-floating instructions.
;
;	CVTLD	R0,R0			; convert the value to double floating
;*
	MOVL	#<128+32>,R2		; set initial biased exponent
	CLRL	R1			; zero "low" longword
	TSTL	R0			; test sign of value
	BEQL	30$			; skip if zero
	BGTR	20$			; skip if positive
	BISW2	#^X100,R2		; remember that it is negative
	MNEGL	R0,R0			; get |R0|
	BVS	25$			; skip shift loop if -2**32
20$:	DECL	R2			; decrement binary exponent
	ASHL	#1,R0,R0		; shift value left one bit
	BVC	20$			; repeat until bit 31 set
25$:	ROTL	#8,R0,R0		; rearrange into floating format
	BICW3	#^X00FF,R0,R1		; move low 8 bits into place in R1
	INSV	R2,#7,#9,R0		; move sign+exponent into place
30$:	MOVAB	OPERAND1(FP),R4		; set operand address
	BSBW	UNPACK_DFLOAT		; unpack the value
	RSB				; return
	;


	;
	;	FIX_REAL - Convert a Floating Value to a Longword (Truncated)
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with	R0 = Longword Result
	;
	;	Discussion
	;
	;	    The exponent is used to determine where in the fraction
	;	the decimal point lies and any part of the integer part that
	;	exists within the signed fraction is extracted. If the
	;	fraction contains bits of higher order than those extracted,
	;	then the V bit is set in the user's PSL to indicate an integer
	;	overflow.
	;
FIX_REAL:				; entrance
	CLRL	R0			; clear the returned value
	BLBS	ZERO1(FP),2$		; the value is zero - return
	MNEGL	POWER1(FP),R1		; R1 = negated exponent
	BGEQ	2$			; value is less than one - return
	CMPL	#32,POWER1(FP)		; is the decimal point deep inside ?
	BLSS	3$			; yes - bypass
	EXTZV	R1,POWER1(FP),FRACTION1+16(FP),R0 ; extract leading bits
	BLBC	SIGN1(FP),1$		; the value is positive - skip
	MNEGL	R0,R0			; negate the value
1$:	ROTL	#1,R0,R1		; position the sign bit
	XORB2	SIGN1(FP),R1		; complement it if negative value
	BLBC	R1,2$			; the sign is correct - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
2$:	RSB				; return
3$:	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
	MOVAB	160(R1),R1		; switch origin to previous longword
	BLEQ	2$			; no nonzero bits - return
	EXTZV	R1,#32,FRACTION1-4(FP),R0 ; extract 32 bits from the fraction
	SUBL3	R1,#32,R1		; compute the bits to clear
	BLEQ	4$			; no bits to clear - bypass
	INSV	#0,#0,R1,R0		; clear some low order bits
4$:	BLBC	SIGN1(FP),2$		; the value is positive - return
	MNEGL	R0,R0			; complement the extracted bits
	RSB				; return
	;

	;
	;	ROUND_REAL - Convert a Floating Value to a Longword (Rounded)
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with	R0 = The Longword Result
	;
	;	Discussion
	;
	;	    The exponent of the floating value is used to determine
	;	where the decimal point goes within the signed fraction and
	;	whatever part of the integer part exists within the fraction
	;	is extracted. If the bit immediatly below the decimal point is
	;	nonzero, then the integer part is rounded by adding a value
	;	of one with the same sign as the floating value. If the value
	;	contains significant bits of higher order than those in the
	;	fraction or if overflow occured during the rounding operation
	;	then the V bit is set in the user's PSL to indicate an integer
	;	overflow.
	;
ROUND_REAL:				; entrance
	CLRL	R0			; clear the returned value
	BLBS	ZERO1(FP),3$		; the value is zero - return
	MNEGL	POWER1(FP),R1		; R1 = negated exponent
	BGTR	3$			; the value is less than 0.5 - return
	CMPL	#32,POWER1(FP)		; is the decimal point deep inside ?
	BLSS	4$			; yes - bypass
	EXTZV	R1,POWER1(FP),FRACTION1+16(FP),R0 ; extract some leading bits
	ADDL2	#63,R1			; *** equivalent sequence to ***
	BBC	R1,FRACTION1+8(FP),1$	; *** get around hardware problem ***
;	DECL	R1			; compute the rounding position
;	BBC	R1,FRACTION1+16(FP),1$	; rounding bit is clear - skip
	INCL	R0			; round the extracted bits
	BCC	1$			; no carry - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
1$:	BLBC	SIGN1(FP),2$		; is the floating value negative
	MNEGL	R0,R0			; yes - complement the value
2$:	ROTL	#1,R0,R1		; position the sign bit
	XORB2	SIGN1(FP),R1		; complment it if negative value
	BLBC	R1,3$			; the sign is correct - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
3$:	RSB				; return
4$:	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
	MOVAB	160(R1),R1		; switch origin to previous longword
	BLEQ	3$			; no nonzero bits - return
	EXTZV	R1,#32,FRACTION1-4(FP),R0 ; extract 32 bits from the fraction
	SUBL3	R1,#32,R2		; compute the bits to clear
	BLSS	5$			; possible rounding - skip
	INSV	#0,#0,R2,R0		; clear some low order bits
	BRB	6$			; bypass
5$:	DECL	R1			; compute the rounding bit
	BBC	R1,FRACTION1-4(FP),6$	; the rounding bit is clear - skip
	INCL	R0			; round the extracted bits
6$:	BLBC	SIGN1(FP),3$		; the value is positive - return
	MNEGL	R0,R0			; negate the value
	RSB				; return
	;

	;
	;	FRACTION_REAL - Isolate the Fraction Part of a Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with	OPERAND1 = The Fractional Part
	;
	;	Discussion
	;
	;	    The exponent is used to determine the position of the
	;	decimal point within the fraction and all of the bits of
	;	the fraction above the decimal point are cleared. The result
	;	is then normalized.
	;
FRACTION_REAL:				; entrance
	BLBS	ZERO1(FP),1$		; the value is zero - return
	MOVL	POWER1(FP),R0		; R0 = the exponent
	BLEQ	1$			; the value is all fraction - return
	EXTZV	#0,#5,R0,R1		; R1 = bits to clear in last longword
	ASHL	#-5,R0,R0		; R0 = number of longwords to clear
	CMPL	#4,R0			; will we clear the whole value ?
	BGTR	2$			; no - bypass
	MOVL	#1,OPERAND1(FP) 	; mark the value as zero
1$:	RSB				; return
2$:	SUBL3	R1,#32,R2		; compute the last clear position
	MOVAL	FRACTION1+16(FP),R3	; R3 = clear index
	BRB	4$			; enter the clear loop
3$:	CLRL	-(R3)			; clear a longword of the fraction
4$:	SOBGEQ	R0,3$			; more longwords to clear - loop
	INSV	#0,R2,R1,-4(R3) 	; perform the last clear
	BSBW	NORMALIZE		; normalize the result
	RSB				; return
	;

	;
	;	ADD_REAL - Add Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND1 = First Floating Operand
	;				OPERAND2 = Second Floating Operand
	;
	;		returns with	OPERAND1 = The Floating Result
	;
	;	Discussion
	;
	;	    This routine performs the addition of floating values
	;	in the internal representation in such a way that the sum is
	;	the exact sum truncated to 127 or 128 significant bits. This
	;	precision is sufficient for performing G_floating and HFLOAT addition
	;	since these operations are based on truncating the exact sum
	;	to smaller numbers of significant digits.
	;
	;	    After preliminary checks for zero operands, the general
	;	addition is performed by first identifying a primary and a
	;	secondary operand with the primary operand being sufficiently
	;	large that it will not need to be shifted to align the values.
	;	This choice is made by examining the exponents. If the 
	;	operands have opposite signs, the fractions are further 
	;	compared so the magnitude of the primary operand is larger 
	;	than the magnitude of the secondary operand. The primary and
	;	secondary operand fractions are loaded into groups of 
	;	registers and the primary operand is shifted to the right one
	;	bit to allow for overflows. The secondary operand fraction is
	;	shifted to line it up with the primary operand fraction. If
	;	the signs of the operands are not the same then a record is 
	;	made if any significant bits are lost during the alignment of
	;	the secondary operand fraction. The resulting fractions are
	;	added or subtracted and an additional one is subtracted if
	;	lost bits were detected in the test made above. The result
	;	is then normalized.
	;
ADD_REAL:				; entrance
	MOVAB	OPERAND1(FP),R0 	; R0 = location of first operand
	MOVAB	OPERAND2(FP),R1 	; R1 = location of second operand
	BLBS	ZERO(R1),3$		; second operand is zero - bypass
	BLBC	ZERO(R0),1$		; first operand is not zero - bypass
	MOVL	OPERAND2(FP),OPERAND1(FP) ; copy the sign and zero flags
	MOVL	POWER2(FP),POWER1(FP)	; copy the exponent
	MOVQ	FRACTION2(FP),FRACTION1(FP) ; copy second half of fraction
	MOVQ	FRACTION2+8(FP),FRACTION1+8(FP) ; copy first half of fraction
	RSB				; done
1$:	CMPL	POWER(R0),POWER(R1)	; compare the exponents
	BGTR	5$			; first is greater - bypass
	BLSS	4$			; second is greater - bypass
	CMPB	SIGN(R0),SIGN(R1)	; compare the signs
	BEQL	5$			; they're equal - bypass
	MOVAB	FRACTION+16(R0),R2	; R2 = position past first fraction
	MOVAB	FRACTION+16(R1),R3	; R3 = position past second fraction
	MOVL	#4,R4			; R4 = loop counter
2$:	CMPL	-(R2),-(R3)		; compare two fraction longwords
	BGTRU	5$			; first is greater - bypass
	BLSSU	4$			; second is greater - bypass
	SOBGTR	R4,2$			; more longwords to compare - loop
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
3$:	RSB				; return
4$:	MOVL	R0,R1			; R1 = secondary operand location
	MOVAB	OPERAND2(FP),R0 	; R0 = primary operand location
5$:	SUBL3	POWER(R1),POWER(R0),R2	; R2 = exponent difference
	ADDL3	#1,POWER(R0),POWER1(FP) ; store the result exponent
	XORB3	SIGN(R0),SIGN(R1),R3	; R3 = subtraction flag
	MOVL	(R0),OPERAND1(FP)	; store the result sign and zero flag
	ASHQ	#-1,FRACTION(R1),R4	; R4 = last shifted secondary longword
	ASHQ	#-1,FRACTION+4(R1),R5	; R5 = previous shifted longword
	ASHQ	#-1,FRACTION+8(R1),R6	; R6,R7 = first two shifted longwords
	BBCC	#31,R7,6$		; clear the high order bit
6$:	ASHQ	#-1,FRACTION(R0),FRACTION1(FP) ; shift fourth result longword
	ASHL	#1,FRACTION1+4(FP),FRACTION1+4(FP) ; position third longword
	ASHQ	#-1,FRACTION+4(R0),FRACTION1+4(FP) ; shift third longword
	ASHL	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; position second longword
	ASHQ	#-1,FRACTION+8(R0),FRACTION1+8(FP) ; shift first two longwords
	BBCC	#31,FRACTION1+12(FP),7$ ; clear the high order bit
7$:	MOVL	#1,R8			; R8 = negation adjustment
	CMPL	#127,R2 		; is the shift count large ?
	BGEQ	8$			; no - skip
	MOVZBL	#127,R2 		; yes - use a smaller one
8$:	TSTL	R2			; is the shift count zero ?
	BEQL	12$			; yes - bypass
	CMPL	#32,R2			; is the shift more than a longword ?
	BGEQ	10$			; no - bypass
	TSTL	R4			; is the last longword zero ?
	BEQL	9$			; no - skip
	CLRL	R8			; clear the negation adjustment
9$:	SUBL2	#32,R2			; decrement the shift count
	MOVQ	R5,R4			; shift the last two longwords
	MOVL	R7,R6			; shift the previous longword
	CLRL	R7			; clear the leading longword
	BRB	8$			; try again
10$:	MNEGL	R2,R9			; R9 = - shift count
	CMPZV	#0,R2,R4,#0		; are the low order bits zero ?
	BEQL	11$			; yes - skip
	CLRL	R8			; clear the negation adjustment
11$:	ASHQ	R9,R4,R4		; shift the last longword
	ASHL	R2,R5,R5		; position the previous longword
	ASHQ	R9,R5,R5		; shift the previous longword
	ASHL	R2,R6,R6		; position the previous longword
	ASHQ	R9,R6,R6		; shift the first two longwords
12$:	BLBC	R3,13$			; not subtraction - bypass
	MCOML	R7,R7			; complement first longword
	MCOML	R6,R6			; complement second longword
	MCOML	R5,R5			; complement third longword
	MCOML	R4,R4			; complement last longword
	ADDL2	R8,R4			; add the negation adjustment
	ADWC	#0,R5			; propagate any carry
	ADWC	#0,R6			; propagate any carry
	ADWC	#0,R7			; propagate any carry
13$:	ADDL2	R4,FRACTION1(FP)	; add the fourth longwords
	ADWC	R5,FRACTION1+4(FP)	; add the third longwords
	ADWC	R6,FRACTION1+8(FP)	; add the second longwords
	ADWC	R7,FRACTION1+12(FP)	; add the leading longwords
	BSBW	NORMALIZE		; normalize the result
	RSB				; return
	;

	.SBTTL	MULTIPLY_FLOAT

	;
	;	MULTIPLY_FLOAT - Multiply Two Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND2 = First Floating Factor
	;				OPERAND3 = Second Floating Factor
	;
	;		returns with	OPERAND1 = The Floating Product
	;				R0 = Normalization Shift Count
	;
	;		See MULYIPLY_xFLOAT routines for more information.
	;

MULTIPLY_FLOAT:
	CASEB	@OP_INDEX(FP),#TYP_F,#<TYP_H-TYP_F>
1$:	.WORD	MULTIPLY_FFLOAT-1$	; F_floating
	.WORD	MULTIPLY_DGFLOAT-1$	; D_floating
	.WORD	MULTIPLY_DGFLOAT-1$	; G_floating
	.WORD	MULTIPLY_HFLOAT-1$	; H_floating

	.SBTTL	MULTIPLY_FFLOAT

	;	Discussion
	;
	;	    This routine forms the product of two floating values 
	;	in the internal representation and deliberately limits the
	;	accuracy to 32 bits. Only the high order 32 bits of each of
	;	the operand fractions is used and the result is the high
	;	order 32 bits of the exact product. The remaining bits of the
	;	fraction are zero. Upon return the register R0 contains the
	;	distance the product was shifted during normalization.
	;

MULTIPLY_FFLOAT:
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	CLRL	R0			; clear the shift count
	BLBS	ZERO2(FP),2$		; first operand is zero - return
	BLBS	ZERO3(FP),2$		; second operand is zero - return
	CLRB	ZERO1(FP)		; clear the zero flag
	MOVL	#1,R0			; R0 = number of longwords to multiply
	MOVAB	FRACTION2+12(FP),R1	; R1 = location of first factor
	MOVAB	FRACTION3+12(FP),R2	; R2 = location of second factor
	MOVAB	FRACTION1+8(FP),R3	; R3 = location for product
	BSBW	MULTIPLY		; multiply the quadwords
	CLRL	R0			; clear the shift count
	ADDL3	POWER2(FP),POWER3(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN2(FP),SIGN3(FP),SIGN1(FP) ; compute the sign
	BBS	#31,FRACTION1+12(FP),1$ ; result is normalized - bypass
	INCL	R0			; set the shift count to one
	DECL	POWER1(FP)		; decrement the exponent
	ASHL	#1,FRACTION1+12(FP),FRACTION1+12(FP) ; normalize the fraction
	BBC	#31,FRACTION1+8(FP),1$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1+12(FP)	; set the low order bit
1$:	CLRQ	FRACTION1(FP)		; extend the fraction to an octaword
	CLRL	FRACTION1+8(FP)		;
2$:	RSB				; return
	;

	.SBTTL	MULTIPLY_DGFLOAT

	;	Discussion
	;
	;	    This routine forms the product of two floating values 
	;	in the internal representation and deliberately limits the
	;	accuracy to 64 bits. Only the high order 64 bits of each of
	;	the operand fractions is used and the result is the high
	;	order 64 bits of the exact product. The remaining bits of the
	;	fraction are zero. Upon return the register R0 contains the
	;	distance the product was shifted during normalization.
	;
MULTIPLY_DGFLOAT: 			; entrance
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	CLRL	R0			; clear the shift count
	BLBS	ZERO2(FP),2$		; first operand is zero - return
	BLBS	ZERO3(FP),2$		; second operand is zero - return
	CLRB	ZERO1(FP)		; clear the zero flag
	MOVL	#2,R0			; R0 = number of longwords to multiply
	MOVAB	FRACTION2+8(FP),R1	; R1 = location of first factor
	MOVAB	FRACTION3+8(FP),R2	; R2 = location of second factor
	MOVAB	FRACTION1(FP),R3	; R3 = location for product
	BSBW	MULTIPLY		; multiply the quadwords
	CLRL	R0			; clear the shift count
	ADDL3	POWER2(FP),POWER3(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN2(FP),SIGN3(FP),SIGN1(FP) ; compute the sign
	BBS	#31,FRACTION1+12(FP),1$ ; result is normalized - bypass
	INCL	R0			; set the shift count to one
	DECL	POWER1(FP)		; decrement the exponent
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the fraction
	BBC	#31,FRACTION1+4(FP),1$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1+8(FP)	; set the low order bit
1$:	CLRQ	FRACTION1(FP)		; extend the fraction to an octaword
2$:	RSB				; return
	;

	.SBTTL	MULTIPLY_HFLOAT

	;
	;	Discussion
	;	
	;	    This routine computes the product of two floating values
	;	in the internal representation. The fraction of the result 
	;	consists of the high order 128 bits of the exact product.
	;	Upon return the register R0 contains the distance the product
	;	was shifted during normalization.
	;
MULTIPLY_HFLOAT:
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	CLRL	R0			; clear the shift count
	BLBS	ZERO2(FP),2$		; first operand is zero - return
	BLBS	ZERO3(FP),2$		; second operand is zero - return
	CLRB	ZERO1(FP)		; clear the zero flag
	MOVL	#4,R0			; R0 = number of longwords to multiply
	MOVAB	FRACTION2(FP),R1	; R1 = location of first factor
	MOVAB	FRACTION3(FP),R2	; R2 = location of second factor
	MOVAB	TEMP(FP),R3		; use temporary area for result
	BSBW	MULTIPLY		; perform the multiplication
	CLRL	R0			; clear the shift count
	ADDL3	POWER2(FP),POWER3(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN2(FP),SIGN3(FP),SIGN1(FP) ; compute the sign
	MOVQ	TEMP+16(FP),FRACTION1(FP) ; insert second part of fraction
	MOVQ	TEMP+24(FP),FRACTION1+8(FP) ; insert first part of fraction
	BLSS	2$			; fraction is normalized - bypass
	INCL	R0			; set the shift count to one
	DECL	POWER1(FP)		; decrement the exponent
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the first part
	BBC	#31,FRACTION1+4(FP),1$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1+8(FP)	; set the low bit in the first part
1$:	ASHQ	#1,FRACTION1(FP),FRACTION1(FP) ; normalize the second part
	BBC	#31,TEMP+12(FP),2$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1(FP)	; set the low bit in the second part
2$:	RSB				; return
	;

	.SBTTL	DIVIDE_FLOAT

	;
	;	DIVIDE_FLOAT - Divide Two Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND2 = The Floating Dividend
	;				OPERAND3 = The Floating Divisor
	;	
	;		returns with	OPERAND1 = Floating Quotient
	;
	;	See DIVIDE_xFLOAT routines for more information.
	;

DIVIDE_FLOAT:
	CASEB	@OP_INDEX(FP),#TYP_F,#<TYP_H-TYP_F>
1$:	.WORD	DIVIDE_FFLOAT-1$	; F_floating
	.WORD	DIVIDE_DGFLOAT-1$	; D_floating
	.WORD	DIVIDE_DGFLOAT-1$	; G_floating
	.WORD	DIVIDE_HFLOAT-1$	; H_floating

	.SBTTL	DIVIDE_FFLOAT

	;	Discussion
	;	
	;	    This routine computes the quotient of two floating values
	;	in the internal representation. The fractions of the two input
	;	values consist of the high order 32 bits of the two operand 
	;	fractions and the fraction of the quotient consists of the
	;	high order 31 or 32 bits of the exact quotient. The remaining
	;	bits of the fraction are set to zero. If the divisor is zero
	;	then a floating division by zero fault is signaled.
	;
DIVIDE_FFLOAT:				; entrance
	BLBC	ZERO3(FP),1$		; divisor is not zero - skip
	BRW	DIVIDE_FAULT		; process the floating divide fault
1$:	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	BLBS	ZERO2(FP),3$		; dividend is zero - bypass
	ASHL	#-1,FRACTION2+12(FP),FRACTION2+12(FP) ; normalize for division
	BBCC	#31,FRACTION2+12(FP),2$ ; clear the high order bit
2$:	INCL	POWER2(FP)		; increment the exponent
	MOVL	#1,R0			; R0 = number of longwords in divisor
	MOVAB	FRACTION2+8(FP),R1	; R1 = dividend location
	MOVAB	FRACTION3+12(FP),R2	; R2 = divisor location
	MOVAB	FRACTION1+12(FP),R3	; R3 = quotient area location
	BSBW	DIVIDE			; perform the division
	CLRB	ZERO1(FP)		; indicate a nonzero result
	SUBL3	POWER3(FP),POWER2(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN3(FP),SIGN2(FP),SIGN1(FP) ; compute the sign
	CLRQ	FRACTION1(FP)		; extend the quotient to 128 bits
	BBS	#31,FRACTION1+12(FP),3$ ; the result is normalized - bypass
	ASHL	#1,FRACTION1+12(FP),FRACTION1+12(FP) ; normalize the quotient
	DECL	POWER1(FP)		; increment the exponent
3$:	RSB				; return
	;

	.SBTTL	DIVIDE_DGFLOAT

	;	Discussion
	;	
	;	    This routine computes the quotient of two floating values
	;	in the internal representation. The fractions of the two input
	;	values consist of the high order 64 bits of the two operand 
	;	fractions and the fraction of the quotient consists of the
	;	high order 63 or 64 bits of the exact quotient. The remaining
	;	bits of the fraction are set to zero. If the divisor is zero
	;	then a floating division by zero fault is signaled.
	;
DIVIDE_DGFLOAT:
	BLBC	ZERO3(FP),1$		; divisor is not zero - skip
	BRW	DIVIDE_FAULT		; process the floating divide fault
1$:	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	BLBS	ZERO2(FP),3$		; dividend is zero - bypass
	ASHQ	#-1,FRACTION2+8(FP),FRACTION2+8(FP) ; normalize for division
	BBCC	#31,FRACTION2+12(FP),2$ ; clear the high order bit
2$:	INCL	POWER2(FP)		; increment the exponent
	MOVL	#2,R0			; R0 = number of longwords in divisor
	MOVAB	FRACTION2(FP),R1	; R1 = dividend location
	MOVAB	FRACTION3+8(FP),R2	; R2 = divisor location
	MOVAB	FRACTION1+8(FP),R3	; R3 = quotient area location
	BSBW	DIVIDE			; perform the division
	CLRB	ZERO1(FP)		; indicate a nonzero result
	SUBL3	POWER3(FP),POWER2(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN3(FP),SIGN2(FP),SIGN1(FP) ; compute the sign
	CLRQ	FRACTION1(FP)		; extend the quotient to 128 bits
	BBS	#31,FRACTION1+12(FP),3$ ; the result is normalized - bypass
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the quotient
	DECL	POWER1(FP)		; increment the exponent
3$:	RSB				; return
	;

	.SBTTL	DIVIDE_HFLOAT

	;	Discussion
	;	
	;	    This routine computes the quotient of two floating values
	;	in the internal representation. The fraction of the quotient
	;	consists of the high order 127 or 128 bits of the exact 
	;	quotient. If the divisor is zero, then a floating divide by
	;	zero fault is signaled.
	;
DIVIDE_HFLOAT:
	BLBC	ZERO3(FP),1$		; the divisor is not zero - skip
	BRW	DIVIDE_FAULT		; process the floating divide fault
1$:	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	BLBS	ZERO2(FP),6$		; dividend is zero - bypass
	CLRQ	TEMP(FP)		; clear the last octaword of dividend
	CLRQ	TEMP+8(FP)		; clear the last octaword of dividend
	ASHQ	#-1,FRACTION2(FP),TEMP+16(FP) ; move last part of dividend
	ASHQ	#-1,FRACTION2+8(FP),TEMP+24(FP) ; move first part of dividend
	INCL	POWER2(FP)		; increment the exponent
	BBCC	#31,TEMP+20(FP),2$	; clear a sign extension bit
2$:	BLBC	FRACTION2+8(FP),3$	; should the bit have been set ?
	BBSS	#31,TEMP+20(FP),3$	; yes - set it
3$:	BBCC	#31,TEMP+28(FP),4$	; clear the high order bit of dividend
4$:	MOVL	#4,R0			; R0 = number of longwords in divisor
	MOVAB	TEMP(FP),R1		; R1 = location of dividend
	MOVAB	FRACTION3(FP),R2	; R2 = location of divisor
	MOVAB	FRACTION1(FP),R3	; R3 = location for quotient
	BSBW	DIVIDE			; perform the division
	CLRB	ZERO1(FP)		; mark the result as nonzero
	SUBL3	POWER3(FP),POWER2(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN3(FP),SIGN2(FP),SIGN1(FP) ; compute the sign
	BBS	#31,FRACTION1+12(FP),6$ ; the result is normalized - bypass
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the first part
	BBC	#31,FRACTION1+4(FP),5$	; should the low order bit be set ?
	BISL2	#1,FRACTION1+8(FP)	; yes - set the bit
5$:	ASHQ	#1,FRACTION1(FP),FRACTION1(FP) ; normalize the second part
	DECL	POWER1(FP)		; decrement the exponent
6$:	RSB				; return
	;

	;
	;	NORMALIZE - Normalize a Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Unnormalized Value
	;
	;		returns with	OPERAND1 = The Normalized Result
	;
	;	Discussion
	;
	;	    This routine normalizes a floating value in the internal
	;	representation so that the high order bit of the fraction is
	;	one. This is done by locating the high order significant bit
	;	of the fraction and then by shifting the fraction so that the
	;	bit appears in the proper position. The shift count is 
	;	subtracted from the exponent so the value does not change.
	;
NORMALIZE:				; entrance
	BLBS	ZERO1(FP),2$		; the value is zero - return
1$:	TSTL	FRACTION1+12(FP)	; test the first longword
	BLSS	2$			; value is already normalized - return
	BEQL	3$			; first longword is zero - bypass
	CLRL	R1			; set intitial shoft count
	MOVL	FRACTION1+12(FP),R0	; get high longword of fraction
11$:	INCL	R1			; increment shift count
	ASHL	#1,R0,R0		; shift one more bit
	BVC	11$			; repeat until high bit set
	MNEGL	R1,R0			; R0 = -shift count
;*
; The previous six instructions are a replacement for the following four
; instructions.  We can no longer guarantee that CVTLD is supported.
;
;	CVTLD	FRACTION1+12(FP),R0	; use hardware to find shift count
;	EXTZV	#7,#6,R0,R0		; R0 = high order bit position + 1
;	SUBL2	#32,R0			; R0 = - shift count
;	MNEGL	R0,R1			; R1 = shift count
;*
	ASHQ	R1,FRACTION1+8(FP),FRACTION1+8(FP) ; position first longword
	ASHL	R0,FRACTION1+8(FP),FRACTION1+8(FP) ; get second parts together
	ASHQ	R1,FRACTION1+4(FP),FRACTION1+4(FP) ; position second longword
	ASHL	R0,FRACTION1+4(FP),FRACTION1+4(FP) ; get other parts together
	ASHQ	R1,FRACTION1(FP),FRACTION1(FP) ; position last two longwords
	SUBL2	R1,POWER1(FP)		; increment the exponent
2$:	RSB				; return
3$:	SUBL2	#32,POWER1(FP)		; decrement the exponent
	TSTL	FRACTION1+8(FP) 	; test the second longword
	BEQL	4$			; it's zero - bypass
	MOVQ	FRACTION1+4(FP),FRACTION1+8(FP) ; shift first two longwords
	MOVL	FRACTION1(FP),FRACTION1+4(FP) ; shift third longword
	CLRL	FRACTION1(FP)		; clear the final longword
	BRB	1$			; finish up
4$:	SUBL2	#32,POWER1(FP)		; decrement the exponent
	TSTL	FRACTION1+4(FP) 	; test the third longword
	BEQL	5$			; it's zero - bypass
	MOVQ	FRACTION1(FP),FRACTION1+8(FP) ; position first two longwords
	CLRQ	FRACTION1(FP)		; clear the last two longwords
	BRB	1$			; finish up
5$:	SUBL2	#32,POWER1(FP)		; decrement the exponent
	TSTL	FRACTION1(FP)		; test the fourth longword
	BEQL	6$			; it's zero - bypass
	MOVL	FRACTION1(FP),FRACTION1+12(FP) ; position the first longword
	CLRL	FRACTION1+8(FP) 	; clear the second longword
	CLRQ	FRACTION1(FP)		; clear the last two longwords
	BRW	1$			; finish up
6$:	MOVL	#1,OPERAND1(FP) 	; mark the value as zero
	RSB				; return
	;

	;
	;	MULTIPLY - Unsigned Multiple Length Integer Multiply
	;
	;		entered by subroutine branching
	;
	;		parameters:	R0 = Size of Inputs in Longwords
	;				R1 = Location of First Factor
	;				R2 = Location of Second Factor
	;				R3 = Location of Destination Area
	;
	;	Discussion
	;
	;	    This routine computes the product of two multiple length
	;	unsigned integers and stores the unsigned product in a 
	;	specified area. The parameter R0 contains the number of 
	;	longwords in each of the input factors and the number of 
	;	longwords in the product is twice the value of R0. The 
	;	parameters R1 and R2 contain the locations of the input 
	;	factors and the parameter R3 contains the location of the
	;	area for the product.
	;
	;
	;	The Algorithm
	;
	;	    The algorithm used is perfectly straightforward. The
	;	second factor is multiplied by each of the unsigned longwords
	;	of the first factor and the aligned products are added to the
	;	destination area. The multiplications and additions are
	;	performed by a series of EMUL instructions in which the two
	;	factors are longwords from each of the factors and the added
	;	operand is formed by adding target longword of the result area
	;	and from carryover information from the previous iteration
	;	of the EMUL loop. The carryover information is formed by 
	;	adding the high order bits of the previous product, the 
	;	opposite factor for each factor longword which is negative
	;	from the previous multiplication, a one if the previous 
	;	carryover longword was negative, and a one if the previous
	;	additive operand was negative. Most of these contributions are
	;	compensations for the fact that the EMUL instruction assumes
	;	that the operands are signed.
	;
	;	    To show that the algorithm is correct the major step is
	;	to show that the EMUL operations do not loose information
	;	because of overflow. To show this we make use of the fact that
	;	for two's complemented addition and multiplication information
	;	only moves in the direction of the high order bits. Therefore,
	;	if the product fits into two unsigned longwords it is correct.
	;	The unsigned information input to each EMUL step is 
	;
	;		first factor <= 2^32-1
	;		second factor <= 2^32-1
	;		longword from result area <= 2^32-1
	;		unsigned carryover information <= 2^32-1
	;
	;	The output of the step is the product of the first two values
	;	plus the second two values. This does not exceed
	;	
	;		(2^32-1)^2+2*(2^32-1) = 2^64-1
	;
	;	which is representable in two unsigned longwords so the 
	;	output carryover information fits into an unsigned longword.
	;	Consequently no information can be lost during the EMUL steps.
	;	
	;
MULTIPLY:				; entrance
	CLRL	R4			; clear the loop index
1$:	CLRL	(R3)[R4]		; clear a longword of the result
	AOBLSS	R0,R4,1$		; more longwords to clear - loop
	CLRL	R4			; clear the loop index
2$:	CLRL	R5			; clear the inner loop index
	MOVL	(R1)+,R6		; R6 = next value from first factor
	MOVAL	(R3)+,R7		; R7 = area of product being affected
	CLRL	R9			; clear the carryover information
3$:	CLRL	R10			; clear the cell to take the carry
	ADDL2	(R7),R9 		; include value so far in carryover
	ADWC	#0,R10			; remember the carry
	MOVL	(R2)[R5],R8		; R8 = next value from second factor
	BGEQ	4$			; it's not negative - skip
	ADDL2	R6,R10			; make unsigned by adding other factor
4$:	BBC	#31,R6,5$		; first factor is not negative - skip
	ADDL2	R8,R10			; make unsigned by adding other factor
5$:	BBC	#31,R9,6$		; carryover is not negative - skip
	INCL	R10			; make unsigned by adding one
6$:	EMUL	R6,R8,R9,R8		; multiply factors including carryover
	MOVL	R8,(R7)+		; accumulate the product
	ADDL2	R10,R9			; form the new carryover
	AOBLSS	R0,R5,3$		; partial product not complete - loop
	MOVL	R9,(R7) 		; store the last part of the product
	AOBLSS	R0,R4,2$		; full product not complete - loop
	RSB				; return
	;

	;
	;	DIVIDE - Unsigned Multiple Length Integer Divide
	;
	;		entered by subroutine branching
	;
	;		parameters:	R0 = Size of the Divisor in Longwords
	;				R1 = Location of the Dividend
	;				R2 = Location of the Divisor
	;				R3 = Location of the Quotient Area
	;	
	;	Discussion
	;	
	;	    This routine performs unsigned multiple length division
	;	and develops a quotient and a remainder. The number of
	;	longwords in the divisor and in the quotient area is given
	;	by the parameter R0. The number of longwords in the dividend
	;	area is twice the value of R0. The parameter R1 is the 
	;	location of the dividend, R2 is the location of the divisor,
	;	and R3 is the location for the quotient. The remainder is
	;	formed in the low order R0 longwords of the dividend area.
	;	It is assumed that the high order bit of the divisor is one
	;	and that the high order bit of the dividend is zero. These
	;	conditions insure that the quotient will fit into the quotient
	;	area.
	;
	;
	;	The Algorithm
	;
	;	    The algorithm used is a variation of the classical divide
	;	and correct method which has been adapted for the above 
	;	specifications. The algorithm has been implemented using words
	;	rather than longwords because the word version is much easier
	;	to verify for correctness since there are no problems with 
	;	using signed arithmetic operations to perform unsigned
	;	arithmetic.
	;
	;	    We let A[0..2N-1] denote the dividend as an array of words
	;	with A[0] being the low order word, and N being twice the
	;	value of R0. Similarly we let B[0..N-1] denote the divisor and
	;	C[0..N-1] the quotient. The remainder will be developed in the
	;	array A[0..N-1]. The algorithm may be given as follows:
	;
	;
	;		Step 0. Let I = N.
	;
	;		Step 1.	Let I = I-1 and A[2N] = 0.
	;
	;			{ The use of A[2N] is only a simplification,
	;			  it does not really appear in the program. }
	;
	;		Step 2. Let Q = entier(A[I+N-1..I+N+1]/(B[N-1]+1)) and
	;			let R be the remainder from the division.
	;
	;			{ This operation is performed by a single
	;			  EDIV instruction. }
	;
	;		Step 3. Let X = b*B[N-1]+B[N-2]+1 and
	;			Y = -Q*B[N-2]+b*R+A[I+N-2]
	;			  =  Q*(b-B[N-2]-1)+b*R+A[I+N-2].
	;
	;			{ Here b denotes 2^16 which is the "base" of
	;			  the number system we are using and b-B[N-2]-1
	;			  is the ones complement of -B[N-2]. These
	;			  values are used to correct the quotient. }
	;
	;		Step 4. Let Y = Y-X. If  Y >= 0 then let Q = Q+1 and
	;			repeat this step.
	;
	;			{ When this step is complete the value of Q is
	;
	;			   entier(A[I+N-2..I+N+1]/(B[N-2..N-1]+1) }
	;
	;		Step 5. Let A[I..I+N] = A[I..I+N]-Q*B[0..N-1].
	;
	;		Step 6. Let C[I] = Q and if Q is too large then add
	;		 	the overflow to C[I+1..N-1]. If I > 2 then
	;			go to Step 2.
	;
	;		Step 7. If B[0..N-1] <= A[0..N] then let
	;			C[0..N-1] = C[0..N-1]+1 and 
	;			A[0..N-1] = A[0..N-1]-B[0..N-1].
	;			The division is complete.
	;
	;
DIVIDE: 				; entrance
	ASHL	#1,R0,R0		; convert the longword count to words
	MOVAW	(R1)[R0],R1		; R1 = current position in dividend
	MOVAW	(R2)[R0],R4		; R4 = position above divisor
	MOVAW	(R3)[R0],R3		; R3 = position above quotient area
	MOVZWL	-2(R4),R9		; R9 = leading word of divisor
	INCL	R9			; form the trial divisor
	MOVL	-4(R4),R10		; R10 = leading longword of divisor
	INCL	R10			; form the correction divisor
	MCOMW	-4(R4),R11		; R11 = complemented second word
	MOVZWL	R11,R11 		; form the correction multiplier
	MOVL	R0,R4			; R4 = loop counter
	CLRL	R6			; clear the carryover information
ONE$:	SUBL2	#2,R1			; R1 = current position in dividend
	SUBL2	#2,R3			; R3 = current position in quotient
	MOVAW	(R1)[R0],R5		; R5 = location of next dividend word
	MOVL	-2(R5),R5		; R5 = leading longword of dividend
	EDIV	R9,R5,R5,R6		; R5 = quotient, R6 = remainder
	CLRL	R8			; clear the double length adjustment
	ASHL	#16,R6,R6		; position the remainder
	BGEQ	2$			; is the value negative ?
	INCL	R8			; yes - the sum will need adjusting
2$:	MOVW	-4(R1)[R0],R6		; include next word from dividend
	EMUL	R5,R11,R6,R6		; form the correction remainder
	ADDL2	R8,R7			; adjust the second longword
3$:	CLRL	R8			; clear the subtraction adjustment
	BBS	#31,R10,4$		; is the correction divisor negative ?
	INCL	R8			; yes - difference will need adjusting
4$:	SUBL2	R10,R6			; subtract the first longwords
	SBWC	R8,R7			; subtract the second longwords
	BLSS	5$			; result is negative - bypass
	INCL	R5			; correct the quotient
	BRB	3$			; try for another correction
5$:	MOVL	R3,R6			; R6 = current word in quotient
	CLRW	(R6)			; clear the word
	ADDL2	R5,(R6)+		; add the current quotient into it
6$:	ADWC	#0,(R6)+		; propagate any carry
	BCS	6$			; another carry - loop
	MNEGL	R5,R5			; negate the quotient
	CLRL	R6			; clear the carryover information
	CLRL	R8			; clear the loop index
7$:	MOVZWL	(R1)[R8],R7		; R7 = next word from dividend
	ADDL2	R7,R6			; add it to the carryover
	MOVZWL	(R2)[R8],R7		; R7 = next word from divisor
	EMUL	R5,R7,R6,R6		; form next word of dividend
	MOVW	R6,(R1)[R8]		; store it
	ASHQ	#-16,R6,R6		; position the carryover information
	AOBLSS	R0,R8,7$		; remainder is not complete - loop
	MOVZWL	(R1)[R0],R7		; R7 = high order word of remainder
	ADDL2	R7,R6			; add it to the carryover
	BGEQ	GO_ON
	CLRL	R6			; the carry can not be negative
GO_ON:
	SOBGTR	R4,ONE$			; division is not complete - loop
	ASHL	#-1,R0,R0		; restore the count to longwords
	TSTL	R6			; is the carryover nonzero ?
	BNEQ	9$			; yes - bypass
	SUBL3	#1,R0,R4		; R4 = loop index
8$:	CMPL	(R1)[R4],(R2)[R4]	; compare remainder and divisor
	BLSSU	12$			; less than - bypass
	BGTRU	9$			; greater than - skip
	SOBGEQ	R4,8$			; more longwords to compare - loop
9$:	CLRL	R4			; clear the loop index
	BICPSW	#PSLM_C 		; clear the carry bit
10$:	SBWC	(R2)+,(R1)+		; subtract corresponding longwords
	AOBLSS	R0,R4,10$		; more lonwords to subtract - loop
	INCL	(R3)+			; increment the quotient
11$:	ADWC	#0,(R3)+		; propagate any carry
	BCS	11$			; another carry to propagate - loop
12$:	RSB				; return
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*	       Condition Code Processing Routines	       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    In order that condition code information be usable 
	;	directly by the code of the Emulator as well as be available
	;	for use in the emulated PSL, the routines which perform tests
	;	and compares set the hardware condition codes. The routine
	;	SET_CONDITION is used to move the hardware condition codes
	;	to the emulated PSL.
	;
	;	    The routines of this portion of the Emulator are extremely
	;	simple so the descriptions of routines are included with the
	;	routines. Here we will just discuss the general policy on 
	;	condition codes within the Emulator.
	;
	;
	;	General Policy on Condition Codes
	;	---------------------------------
	;
	;	    In general it is the responsibility of each of the
	;	instruction emulation routines to insure that the condition
	;	codes are correct. Since for most of the instructions
	;	presently emulated the condition codes reflect the floating
	;	value that appears in OPERAND1, the routine SET_CONDITION1
	;	is available for checking the value and setting the condition
	;	codes in the emulated PSL. In other cases these operations 
	;	must be done in line.
	;
	;	    For those instructions which return an integer result
	;	the V bit is used to indicate whether or not an integer 
	;	overflow took place. Because of this it is also checked in
	;	NORMAL_EXIT in order to determine if a integer overflow trap
	;	should be signaled. For this reason it is cleared when the
	;	instruction emulation is started in EMULATOR.
	;

	;
	;	SET_CONDITION - Capture the Condition Codes N and Z in the PSL
	;
	;		entered by subroutine branching
	;	
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the N and Z bits in the emulated PSL
	;	equal to those bits in PSL available on entry to the routine.
	;
SET_CONDITION:				; entrance
	BLSS	1$			; less than - bypass
	BGTR	2$			; greater than - bypass
	BICL2	#PSLM_NZ,PSL(FP)	; clear the N bit and Z bit in the PSL
	BISL	#PSLM_EQL,PSL(FP)	; specify equals in the PSL
	RSB				; return
1$:	BICL2	#PSLM_NZ,PSL(FP)	; clear the N bit and Z bit in the PSL
	BISL	#PSLM_LSS,PSL(FP)	; specify less than in the PSL
	RSB				; return
2$:	BICL2	#PSLM_NZ,PSL(FP)	; clear the N bit and Z bit in the PSL
	BISL2	#PSLM_GTR,PSL(FP)	; specify greater than in the PSL
	RSB				; return
	;
	;	SET_CONDITION1 - Test a Floating Value Setting the PSL
	;
	;		entered by subroutine branching
	;	
	;		parameter:	OPERAND1 = The Floating Value
	;
	;	Discussion
	;
	;	    This routine tests the floating value in OPERAND1 and
	;	sets the N and Z bits in the emulated PSL according to the
	;	outcome of the test. The V and C bits in the emulated PSL
	;	are cleared.
	;
SET_CONDITION1: 			; entrance
	MOVAB	OPERAND1(FP),R1 	; R1 = location of OPERAND1
	BSBB	TEST_REAL		; test the value
	BSBB	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	RSB
	;

	;
	;	TEST_REAL - Test all Floating Types
	;
	;		entered by subroutine branching
	;	
	;		parameter:	R1 = Floating Value Location
	;
	;	Discussion
	;
	;	    This routine tests the floating value in the internal 
	;	representation that is addressed by R1 and sets the hardware
	;	condition codes accordingly. These settings are available
	;	when the routine returns.
	;
TEST_REAL:				; entrance
	BLBS	ZERO(R1),TEST_EQL	; value is zero - bypass
	BLBC	SIGN(R1),TEST_GTR	; value is positive - bypass
	BRB	TEST_LSS		; value is negative - bypass
	;
	;	TEST_OCTA - Test an Octaword in OPERAND1
	;
	;		entered by subroutine branching
	;	
	;		parameter:	OPERAND1 = 128 Bit Octaword Value
	;
	;	Discussion
	;
	;	    This routine tests the octaword value which occupies 
	;	128 bits and starts at OPERAND1 (it is not in the internal
	;	floating representation) and sets the hardware condition
	;	codes according to the outcome of the test. These settings
	;	are available when the routine returns.
	;
TEST_OCTA:				; entrance
	MOVL	#3,R0			; initialize the index
	TSTL	OPERAND1(FP)[R0]	; test the first longword
	BGEQ	2$			; it's not negative - bypass
	RSB				; return indicating negative value
1$:	TSTL	OPERAND1(FP)[R0]	; test the next longword
2$:	BNEQ	TEST_GTR		; value is positive - bypass
	SOBGEQ	R0,1$			; more longwords to examine - loop
	BRB	TEST_EQL		; value is zero - bypass
	;

	;
	;	COMPARE_REAL - Compare Internal Format Floating Values 
	;
	;		entered by subroutine branching
	;
	;		parameters:	R1 = Location of First Floating Value
	;				R2 = Locaiton of Second Floating Value
	;
	;	Discussion
	;	
	;	    This routine compares the two floating values addressed
	;	by R1 and R2 and sets the hardware condition codes according
	;	to the outcome of the comparison. These settings are available
	;	when the routine returns.
	;
COMPARE_REAL:				; entrance
	CMPB	SIGN(R1),SIGN(R2)	; compare the sign indicators
	BNEQ	3$			; not equal - bypass
	CMPB	ZERO(R2),ZERO(R1)	; compare the zero indicators
	BNEQ	2$			; not equal - bypass
	BLBS	ZERO(R1),TEST_EQL	; both are zero and equal - bypass
	CMPL	POWER(R1),POWER(R2)	; compare the exponents
	BLSS	4$			; condition was less than - bypass
	BGTR	3$			; condition was greater - bypass
	MOVL	#3,R0			; R0 = loop index
1$:	CMPL	FRACTION(R1)[R0],-	; compare corresponding longwords
		FRACTION(R2)[R0]	; from the fractions
	BNEQ	2$			; not equal - bypass
	SOBGEQ	R0,1$			; more longwords to examine - loop
	BRB	TEST_EQL		; arrange an equals return
2$:	BLSSU	4$			; condition was less than - bypass
3$:	BLBC	SIGN(R1),TEST_GTR	; condition is greater than - bypass
	BRB	TEST_LSS		; condition is less than - bypass
4$:	BLBC	SIGN(R1),TEST_LSS	; condition is less than - bypass
	BRB	TEST_GTR		; condition is greater than - bypass
	;

	;
	;	TEST_LSS - Set the Condition Codes to Specify Less Than
	;
	;		entered by subroutine branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the hardware condition codes to specify
	;	a "less than" outcome. This setting is available when the 
	;	routine returns.
	;
TEST_LSS:				; entrance
	TSTB	#-1			; set the condition codes
	RSB				; return
	;
	;	TEST_EQL - Set the Condition Codes to Specify Equals
	;
	;		entered by subroutine branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the hardware condition codes to specify
	;	an "equals" outcome. This setting is available when the 
	;	routine returns.
	;
TEST_EQL:				; entrance
	TSTB	#0			; set the condition codes
	RSB				; return
	;
	;	TEST_GTR - Set the Condition Codes to Specify Greater Than
	;
	;		entered by subroutine branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the hardware condition codes to specify
	;	a "greater than" outcome. This setting is available when the
	;	routine returns.
	;
TEST_GTR:				; entrance
	TSTB	#1			; set the condition codes
	RSB				; return
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		Exception Processing Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    In order to simplify the design of the Emulator, it was
	;	decided that whenever fault conditions were detected during
	;	instruction emulation, that control would branch immediatly
	;	to the signaling routine rather than using status codes to
	;	inform some outer routine of the condition. Because of this
	;	some care was necessary in the ordering of operations so that
	;	the Emulator is always in the correct state when faults are
	;	detected. The only trap supported is the integer overflow
	;	trap and since this condition is only signaled when the 
	;	instruction emulation is complete, there is no problem with
	;	the flow of control.
	;
	;	    For each of the exceptions recognized, there is a routine
	;	which is branched to (except for access violations in which
	;	a subroutine branch is used instead) as soon as the condition
	;	is detected. This routine pushes a shortened version of the
	;	signal array onto the stack and branches to SIGNAL_START which
	;	builds the signal and mechanism arrays in the proper place in
	;	memory and enters the signal dispatcher to search for handlers
	;	to process the condition. If the exception was a fault, the
	;	routine FAULT_RESET is called to restore the registers to
	;	their values when the instruction was started.
	;
	;
	;	Access Violations
	;	-----------------
	;
	;	    The routines READ_FAULT and WRITE_FAULT are called by
	;	subroutine branching when memory probes of read and write
	;	access fail during instruction emulation. The register R11 is
	;	assumed to contain the location of the area being probed
	;	and the register R10 is assumed to contain its length. The
	;	routine tries to produce the fault under controlled conditions
	;	and returns if it can not produce the fault. If it can produce
	;	the fault the the fault is signaled with the reason mask being
	;	the reason mask from the attempt to produce the fault and with
	;	the violation address as the address of the first byte of the
	;	area for which the access violation occurs.
	;
	;	
	;	The Signal Dispatcher
	;	---------------------
	;
	;	    The Emulator presently contains all of the code necessary
	;	for signaling the condition since it is necessary that the
	;	emulator build the signal and mechanism arrays itself and
	;	since there is no "back door" to either the signal dispatcher
	;	in the common RTL or the one in VMS. The version contained in
	;	the emulator is a copy with minor modifications of the one in
	;	LIB$SIGNAL.
	;

	;
	;	READ_FAULT - Process a Read Access Violation Fault
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Size of Area being Read
	;				R11 = Location of Area being Read
	;
READ_FAULT:				; entrance
	PUSHR	#^M<R0,R1,R2>		; save R0,R1,R2
	MOVL	R11,R2			; R2 = probed address
	PROBER	MODE(FP),#1,(R2)	; is the first byte readable ?
	BEQL	1$			; no - bypass
	PROBER	MODE(FP),#1,-1(R2)[R10]	; is the last byte readable ?
	BNEQ	1$			; yes - bypass
	MOVAB	-1(R2)[R10],R2		; R2 = address of last byte
	BICW2	#511,R2			; compute address of first bad byte
1$:	CALLS	#0,B^READ_REASON	; get the reason mask
	BLBS	R0,2$			; the read went all right - bypass
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	PUSHL	R2			; push the bad address
	PUSHL	R1			; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
2$:	POPR	#^M<R0,R1,R2>		; restore R0,R1,R2
	RSB				; get back
	;
	;	READ_REASON - Get the Reason Mask for a Read Access Violation
	;
	;		parameter:	R2 = Address for which Probe Failed
	;
	;		returns with	R0 = Status of Access Attempt
	;				R1 = Reason Mask if Unsuccessful
	;
READ_REASON:				; entrance
	.WORD	0			; entry mask
	MOVAB	B^REASON_HANDLER,(FP)	; set up the condition handler
	TSTB	(R2)			; touch the location
	MOVL	#1,R0			; indicate a successful read
	RET				; return
	;
	;	REASON_HANDLER - Condition Handler for Reason Routines
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with 	R0 = Condition Response
	;
REASON_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0 and R1 = location of arrays
	TSTL	8(R1)			; condition from establisher frame ?
	BNEQ	1$			; no - bypass
	CMPCOND	SS$_ACCVIO,4(R0)	; access violation condition ?
	BNEQ	1$			; no - bypass
	CLRL	12(R1)			; return zero status in R0
	MOVL	8(R0),16(R1)		; return the reason mask in R1
	CLRQ	-(SP)			; default PC and level for unwind
	CALLS	#2,G^EXE$UNWIND		; unwind the reason routine frame
1$:	CVTWL	#SS$_RESIGNAL,R0	; specify condition not handled
	RET				; return
	;

	;
	;	WRITE_FAULT - Process a Write Access Violation Fault
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Size of Area being Written
	;				R11 = Location of Area being Written
	;
WRITE_FAULT:				; entrance
	PUSHR	#^M<R0,R1,R2>		; save R0,R1,R2
	MOVL	R11,R2			; R2 = probed address
	PROBEW	MODE(FP),#1,(R2)	; is the first byte writeable ?
	BEQL	1$			; no - bypass
	PROBEW	MODE(FP),#1,-1(R2)[R10]	; is the last byte writeable ?
	BNEQ	1$			; yes - bypass
	MOVAB	-1(R2)[R10],R2		; R2 = address of last byte
	BICW2	#511,R2			; compute address of first bad byte
1$:	CALLS	#0,B^WRITE_REASON	; get the reason mask
	BLBS	R0,2$			; the write went all right - bypass
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	PUSHL	R2			; push the bad address
	PUSHL	R1			; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
2$:	POPR	#^M<R0,R1,R2>		; restore R0,R1,R2
	RSB				; get back
	;
	;	WRITE_REASON - Get the Reason Mask for Write Access Violation
	;
	;		parameter:	R2 = Address for which Probe Failed
	;
	;		returns with	R0 = Status of Access Attempt
	;				R1 = Reason Mask if Unsuccessful
	;
WRITE_REASON:				; entrance
	.WORD	0			; entry mask
	MOVAB	B^REASON_HANDLER,(FP)	; set up the condition handler
	ADDB2	#0,(R2)			; try to change the location
	MOVL	#1,R0			; indicate a successful write
	RET				; return
	;

	;
	;	OPCODE_FAULT - Process an Opcode Reserved to Digital Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
OPCODE_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_OPCDEC,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	ADDRESS_FAULT - Process an Invalid Addressing Mode Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
ADDRESS_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_RADRMOD,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	OPERAND_FAULT - Processed a Reserved Operand Fault
	;
	;		entered by branching
	;	
	;		no parameters
	;
OPERAND_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_ROPRAND,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	UNDERFLOW - Process a Floating Underflow Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
UNDERFLOW:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_FLTUND_F,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	OVERFLOW - Process a Floating Overflow Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
OVERFLOW:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_FLTOVF_F,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	DIVIDE_FAULT - Process a Floating Divide by Zero Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
DIVIDE_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_FLTDIV_F,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	INT_OVERFLOW - Process an Integer Overflow Trap
	;
	;		entered by branching
	;
	;		no parameters
	;
INT_OVERFLOW:				; entrance
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_INTOVF,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;

	;
	;	FAULT_RESET - Perform Reinitialization Operations for a Fault
	;
	;		entered by subroutine branching
	;	
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine subtracts the sign-extended value of each
	;	of the register modification bytes from the corresponding
	;	emulated register and clears the trace pending bit in the
	;	PSL.
	;
FAULT_RESET:				; entrance
	CLRL	R0			; clear the index
1$:	CVTBL	REGMOD_R0(FP)[R0],R1	; R1 = modifications to R[R0]
	SUBL2	R1,REG_R0(FP)[R0]	; unmodify the register
	AOBLEQ	#15,R0,1$		; more registers to reset - loop
	BBCC	#PSL_TP,PSL(FP),2$	; clear the trace pending bit
2$:	RSB				; return
	;

	;
	;	SIGNAL_START - Build the Parameter Blocks for SIGNAL
	;
	;		entered by branching
	;
	;		parameters:	(SP) = Truncated Signal Array Size (M)
	;				4(SP) = Condition Code
	;				8(SP) = First Signal Argument
	;				  .
	;				  .
	;				  .
	;				4*<M-1>(SP) = Last Signal Argument
	;
	;	Discussion
	;
	;	    This routine builds the signal and mechanism arrays
	;	for a condition generated by the Emulator. It is entered
	;	with the signal array for the condition except for the 
	;	PC and PSL pair pushed onto the Emulator's stack (with the
	;	pushed array length correspondingly shortened). The signal
	;	array, mechanism array, and the handler parameter block
	;	are then constructed on the user's emulated stack. The routine
	;	then removes the Emulator frame from the stack and enters
	;	the signal dispatching loop at SIGNAL.
	;
	;	Notes:	1. The precise format of the information pushed onto
	;		   the user's stack is given in the description of
	;		   SIGNAL below.
	;
	;		2. The method of getting out of the Emulator used in
	;		   this routine is essentially the same as that used
	;		   in NORMAL_EXIT.
	;
SIGNAL_START:				; entrance
	MOVL	(SP)+,R7		; R7 = number of signal parameters
	ASHL	#2,R7,R8		; R8 = size of the signal parameters
	ADDL3	#52,R8,R0		; R0 = size of signal information
	BSBW	TEST_FRAME		; make sure we have room for it
	MOVL	REG_SP(FP),R6		; R6 = user's stack pointer
	MOVQ	REG_PC(FP),-(R6)	; push the PC, PSL pair
	SUBL2	R8,R6			; make room for the signal parameters
	MOVC3	R8,(SP),(R6)		; push the signal parameters
	ADDL3	#2,R7,-(R6)		; push the signal array length
	MOVL	#1,-(R6)		; push code for SIGNAL (vs. STOP)
	MOVQ	REG_R0(FP),-(R6)	; push user's R0 and R1
	MNEGL	#3,-(R6)		; push -3 (depth number)
	MOVL	REG_FP(FP),-(R6)	; push the user's FP
	MOVL	#4,-(R6)		; push the mechanism array length
	MOVL	R6,-(R6)		; push the mechanism array location
	MOVAB	28(R6),-(R6)		; push the signal array location
	MOVL	#2,-(R6)		; push the handler parameter count
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put the user's PC, PSL pair back
	MOVAB	B^SIGNAL,SAVE_PC(FP)	; store the return point
	MOVAB	FRAME_END+4(FP),R0	; R0 = location of end of frame
	SUBL2	R0,R6			; R6 = distance of user SP from it
	EXTZV	#0,#2,R6,R1		; R1 = stack alignment
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store it into the frame
	ADDL2	R1,R0			; compute the parameter area location
	ASHL	#-2,R6,-4(R0)		; store the parameter count
	RET				; return (to SIGNAL)
	;

	;
	;	SIGNAL - Signal the Condition
	;
	;		entered by branching
	;
	;		parameters:	( Described in Note 3 )
	;	
	;	Discussion
	;
	;		   Following is a description of the information which
	;		   is assumed to be pushed onto the stack when the
	;		   routine SIGNAL is entered. The values are all
	;		   longwords.
	;
	;		   Handler Parameter Block:
	;
	;			(SP)	2 (handler parameter block length)
	;			4(SP)	signal array location
	;			8(SP)	mechanism array location
	;
	;		   Mechanism Array:
	;
	;			12(SP)	4 (mechanism array length)
	;			16(SP)  user's FP (establisher frame)
	;			20(SP)	-3 (establisher depth)
	;			24(SP)	user's R0
	;			28(SP)	user's R1
	;
	;		   Information Not Part of any Array:
	;
	;			32(SP)	1 (code for SIGNAL rather than STOP)
	;
	;		   Signal Array:
	;
	;			36(SP)	signal array length M
	;			40(SP)	condition code
	;			44(SP)	first signal argument
	;			  .
	;			  .
	;			  .
	;			<4*M>+28(SP) last signal argument
	;			<4*M>+32(SP) user's PC
	;			<4*M>+36(SP) user's PSL
	;
	;		   The user's stack pointer should coincide with the
	;		   address <4*M>+40(SP).
	;
	;	We now jump to the special entry point in VMS to start
	;	the search for handlers.  Execution will not return to us.
	;-

SIGNAL: 				; entrance
	JMP	G^EXE$SRCHANDLER


;	************************************************************************
;	*								       *
;	*								       *
;	*	   End of EMULATE$ VAX Instruction Subset Emulator	       *
;	*								       *
;	*								       *
;	************************************************************************

	.END
