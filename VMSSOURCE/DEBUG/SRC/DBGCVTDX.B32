MODULE DBGCVTDX (IDENT = 'V04-000') =

BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
! 									    
!  WRITTEN BY
!	Farokh Morshed		01-09-1981
!	
!  MODIFIED BY:
!	* These modifications are to LIB$$FIND_CVT_PATH, and were done before
!	* debug modifications.
!	*
! 	1-001 - Original.  FM1001	01-09-1981
! 	1-002 - Put in a check for DSC$W_LENGTH to be 1 when class A, or NCA, and 
!	        if class NCA stride must be 1.  FM 9-9-81
! 	1-003 - Put in a new data type, DSC$K_DTYPE_VT.  FM 1-DEC-81.
! 	1-004 - Put in a feature where DST_INFO [D_LEN] can be picked up for 
!	        LIB$CVT_DX_DX. FM 2-DEC-81.
!
!	* These modifications are to LIB$CVT_DX_DX, and were done before 
!	* debug modifications.
!	*
! 	1-001 - Original.  FM1001	01-09-1981
! 	1-002 - Fix the problem with (SMLINT, LRGINT, DEC) to NBDS having an explicit
!	        sign when plus should be implied.  Also [DEC_NBDS] scaled twice, 
!	        changed it to scale only once.  FM 5-NOV-81.
! 	1-003 - Fix the problem with [K_DEC_NBDS].  The length of CLASS_S_DESC was
!	        not being reset. FM
! 	1-004 - Put in a new data type, DSC$K_DTYPE_VT.  Cleaned up data type B
!	        out of NBDS.  FM 1-DEC-81.
! 	1-005 - Fix the bug where destination length is not picked up from DST_INFO.
!	        FM 2-DEC-81.
! 	1-006 - Constants which are addressed by things like PACK_ZERO should be
!	        all longwords.
! 	1-007 - LIB$_ROPRAND was left out of the exception handler.  FM 8-FEB-82.
! 	1-008 - A couple of missing dots fixed -Q -> G and H.
!
!	* DEBUG modifications start here.
!	*
!	1-001 - Victoria Holt	Sept., 1982
!		Created module DBGCVTDX.  This module includes the two routines
!		FIND_CVT_PATH and DBG$CVT_DX_DX (originally LIB$$FIN_CVT_PATH
!		and LIB$CVT_DX_DX, respectively).  Both routines have been
!	 	modified to include additional DEBUG and language specific
!		dtypes and classes.
!	1-002 - VJH
!		Added routine DBG$COVER_DX_DX from DBGEVALOP.
!		Modified handler so that it signals errors rather than
!		returning a status code.
!	1-003 - WC3	Jul-83
!		Add support for Absolute Date Time to CVT_DX_DX
!	1-004 - WC3	Jul-83
!		Fix the decimal text to Octaword conversion
!	1-005 - BAB	Dec-83
!		Added support for scaled binary conversions. To and From.
!	1-006 - BAB	Jan-84
!		Fixed the bug where DEP/QUAD I=8000000000000000 does not work.
!		Also DEP/OCTA I=8000000000000000000000000000000.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LINKAGE
    JSB_R0 = JSB (REGISTER = 0): PRESERVE (0, 1),
    JSB_R1 = JSB (REGISTER = 0, REGISTER = 1): PRESERVE (0, 1),
    JSB_RETR0_R1 = JSB (REGISTER = 0, REGISTER = 1): PRESERVE (1),
    JSB_R2 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2): PRESERVE (0, 1),
    JSB_R3 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3): PRESERVE (0, 1),
    JSB_R6 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3, REGISTER = 4, REGISTER = 5):
    PRESERVE (0, 1),
    SCOPYR_JSB_R6 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2): NOPRESERVE (2),
    SCOPY_JSB_R6 = JSB (REGISTER = 0, REGISTER = 1): NOPRESERVE (2, 3, 4, 5, 6);

FORWARD ROUTINE
    DBG$COVER_DX_DX,				! Accepts value descriptors; calls DBG$CVT_DX_DX.
    COVER_VMSDESC_SETUP,			! Set up vms descriptor 
    DBG$CVT_DX_DX:  NOVALUE,			! Routine that does any-to-any type conversion.
    CVT_HANDLER,				! Error handler.
    FIND_CVT_PATH;				! Routine to find the conversion path
						! being done and report any

EXTERNAL ROUTINE
    DBG$CVT_ASHP_R1: JSB_R6 NOVALUE,
    DBG$CVT_CMPH_R1: JSB_RETR0_R1,
    DBG$CVT_CVTDH_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTLB_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTLH_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTLW_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTRDQ_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTHD_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTHF_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTHG_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTGH_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTRHL_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTRHO_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTRHQ_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTROUD_R1: JSB_R1 NOVALUE,
    DBG$CVT_CVTROUH_R1: JSB_R1 NOVALUE,
    DBG$CVT_DIVD2_R1: JSB_R1 NOVALUE,
    DBG$CVT_DIVH2_R1: JSB_R1 NOVALUE,
    DBG$CVT_DIVP_R1: JSB_R6 NOVALUE,
    DBG$CVT_MULD2_R1: JSB_R1 NOVALUE,
    DBG$CVT_MULH2_R1: JSB_R1 NOVALUE,
    DBG$CVT_MULP_R1: JSB_R6 NOVALUE,
    DBG$GET_SET_TYPEID,
    DBG$INS_ENCODE,
    DBG$MAP_DTYPE_CLASS,
    DBG$PERFORM_TYPEID_CHECK,
    DBG$STA_TYP_SUBRNG:  NOVALUE,
    DBG$STA_TYP_ATOMIC:  NOVALUE,
    DBG$STRIP_ZEROES,
    FOR$CVT_D_TE,
    FOR$CVT_D_TF,
    FOR$CVT_G_TE,
    FOR$CVT_G_TF,
    FOR$CVT_H_TE,
    FOR$CVT_H_TF,
    DBG$CVT_SCALE_OU_UP_BY_10_R1: JSB_R0 NOVALUE,
    DBG$CVT_SCALE_OU_DOWN_BY_10_R1: JSB_R0 NOVALUE,
    LIB$$CVT_SCALE_OU_UP_BY_10_R1: JSB_R0 NOVALUE,
    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1: JSB_R0 NOVALUE,
    DBG$CVT_SCALE_OU_UP_BY_2_R1: JSB_R0 NOVALUE,
    DBG$CVT_SCALE_OU_DOWN_BY_2_R1: JSB_R0 NOVALUE,
    LIB$MATCH_COND,
    LIB$SIG_TO_RET: NOVALUE,
    LIB$SCOPY_R_DX6: SCOPYR_JSB_R6,
    LIB$SCOPY_DXDX6: SCOPY_JSB_R6,
    LIB$STOP: NOVALUE,
    MTH$CVT_D_G: NOVALUE,
    OTS$CVT_L_TI,
    OTS$CVT_T_D,
    OTS$CVT_T_G,
    OTS$CVT_T_H,
    SYS$ASCTIM,									!					A003
    SYS$BINTIM;									!					A003

EXTERNAL
    LIB$AB_CVTTP_U,			! These are the translation tables
    LIB$AB_CVT_O_U,			! used when translating to or from
    LIB$AB_CVTTP_O,			! packed decimal.
    LIB$AB_CVT_U_O,
    LIB$AB_CVTPT_U,
    LIB$AB_CVTPT_O,
    LIB$AB_CVTPT_Z,
    LIB$AB_CVTTP_Z,
    DBG$GL_OPCODE_NAME:  REF VECTOR[, BYTE];  	! Used in error messages.

EXTERNAL LITERAL
   LIB$_STRTRU;				! String truncated.

BUILTIN
	CVTTP,
	CVTSP,
	CVTLF,
	CVTLD,
	CVTPT,
	CVTPS,
	CMPP,
	CMPD,
    	CVTDL,
    	CVTHL,
	CVTRDL,
	CVTRFL,
	CVTDF,
	CVTPL,
	CVTLP,
	BICPSW,
	BISPSW,
	TESTBITSC,
	SUBM,
	MOVP;

OWN
	DECIMAL_CONVERT,		! Tells if this is a packed decimal conversion.
					!   Needed so that "conversion error" can be
					!   signalled rather than "reserved operand".
	SAVE_RESULT;			! Used when signalling underflow.

! Literals.
!
LITERAL


    ! Some general values:
    !
    K_FIRST_LONGWORD = 0,		! Position of first longword in buffer.
    K_INTMED_DATA_LENGTH = 32,		! Intermediate data buffer length
    K_OUTPUT_BUFFER_LENGTH = 32,	! Output buffer length
    K_LRGST_WU = 65535,			! Largest unsigned word.
    K_LRGST_LU = 4294967295,		! Largest unsigned longword.
    K_LRGST_NEG_L = -2147483648,	! Largest negative longword.
    K_LRGCLSSUP = DSC$K_CLASS_UBS,	! Largest CLASS supported by routine
    K_SMLCLSSUP = DSC$K_CLASS_S,	! Smallest CLASS supported by routine
    K_MAX_DATA_TYPES = 43,		! Total number of DATA TYPES in the standard
    K_MAX_CLASSES = 15,			! Total number of classes supported,
  					! including the error case 0.
    K_MIN_CLASS = DSC$K_CLASS_S,	! Smallest class supported.
    K_MAX_CLASS = DSC$K_CLASS_UBS,	! Largest class supported.
    K_MAX_CLASS_STA = DSC$K_CLASS_UBA,	! Max. class number supported by standard.
    K_MIN_DTYPE_STA = DSC$K_DTYPE_V,    ! Min. data type number supported by standard.
    K_MAX_DTYPE_STA = DSC$K_DTYPE_SVU,	! Max. data type number supported by standard.
    K_ACTUAL_CLASSES = 7,		! Total classes that are allowed by the STATES table.
    K_MSTNEGERR = -7,			! Most negative error state
    K_LRGST_NEG_B = -128,		! Largest negative signed byte.
    K_LRGST_NEG_W = -32768,		! Largest negative signed word.
    K_LRGST_B = 127,			! Largest positive signed byte.
    K_LRGST_W = 32767,			! Largest positive signed word.
    K_LRGST_BU = 255,			! Largest unsigned byte.
    K_LRGST_L = 2147483647,		! Largest signed longword.
    K_PACK_LU_LEN = 10,


    ! Status returned by FIND_CVT_PATH.
    !
    K_UNSCLAROU = -1,			! Unsupported CLASS by routine.
    K_UNSDTYROU = -2,			! Unsupported DATA TYPE by routine.
    K_UNSDESROU = -3,			! Unsupported descriptor by routine.
    K_UNSDESSTA = -4,			! Unsupported descriptor by standard.
    K_UNSCLASTA = -5,			! Unsupported CLASS by standard.
    K_UNSDTYSTA = -6,			! Unsupported DTYPE by standard
    K_INVNBDS = -7,			! Invalid NBDS
    					! because either array size is larger
    					! than a WU or it is not a one
    					! dimensional array.
    K_SUPPORTED = 1,			! This descriptor is supported, and valid.


    ! These are the values of the members of K_ACTUAL_CLASSES:
    ! (K_ACTUAL_CLASSES being those classes that not only exist, but are
    ! actually used by the caller.  Any other valid classes not in this
    ! group are presently treated as an error condition.)
    !
    K_STATE1_CLASS_S = DSC$K_CLASS_S,
    K_STATE2_CLASS_D = DSC$K_CLASS_D,
    K_STATE4_CLASS_A = DSC$K_CLASS_A,
    K_STATE9_CLASS_SD = DSC$K_CLASS_SD,
    K_STATE10_CLASS_NCA = DSC$K_CLASS_NCA,
    K_STATE11_CLASS_VS = DSC$K_CLASS_VS,
    K_STATE13_CLASS_UBS = DSC$K_CLASS_UBS,


    ! These are the intermediate data type groupings.  All data types fit into
    ! one of these groups.  The groups can represent either the left or right
    ! hand side of the conversion index.  When combined together (as in
    ! K_SMLINT_SMLINT - convert small integer to small integer, eg. byte to 
    ! word), they represent the current state.
    !
    K_SMLINT = 1,
    K_LRGINT = 2,
    K_SMLFLT_CMPLX = 3,
    K_LRGFLT_CMPLX = 4,
    K_DEC = 5,
    K_NBDS = 6,

    K_TOT_CAT = 6,


    ! These are the index values to the main CASE statement in DBG$CVT_DX_DX.
    !
    K_SMLINT_SMLINT = 1,
    K_SMLINT_LRGINT = 2,
    K_SMLINT_SMLFLTCMPLX = 3,
    K_SMLINT_LRGFLTCMPLX = 4,
    K_SMLINT_DEC = 5,
    K_SMLINT_NBDS = 6,
    K_LRGINT_SMLINT = 7,
    K_LRGINT_LRGINT = 8,
    K_LRGINT_SMLFLTCMPLX = 9,
    K_LRGINT_LRGFLTCMPLX = 10,
    K_LRGINT_DEC = 11,
    K_LRGINT_NBDS = 12,
    K_SMLFLTCMPLX_SMLINT = 13,
    K_SMLFLTCMPLX_LRGINT = 14,
    K_SMLFLTCMPLX_SMLFLTCMPLX = 15,
    K_SMLFLTCMPLX_LRGFLTCMPLX = 16,
    K_SMLFLTCMPLX_DEC = 17,
    K_SMLFLTCMPLX_NBDS = 18,
    K_LRGFLTCMPLX_SMLINT = 19,
    K_LRGFLTCMPLX_LRGINT = 20,
    K_LRGFLTCMPLX_SMLFLTCMPLX = 21,
    K_LRGFLTCMPLX_LRGFLTCMPLX = 22,
    K_LRGFLTCMPLX_DEC = 23,
    K_LRGFLTCMPLX_NBDS = 24,
    K_DEC_SMLINT = 25,
    K_DEC_LRGINT = 26,
    K_DEC_SMLFLTCMPLX = 27,
    K_DEC_LRGFLTCMPLX = 28,
    K_DEC_DEC = 29,
    K_DEC_NBDS = 30,
    K_NBDS_SMLINT = 31,
    K_NBDS_LRGINT = 32,
    K_NBDS_SMLFLTCMPLX = 33,
    K_NBDS_LRGFLTCMPLX = 34,
    K_NBDS_DEC = 35,
    K_NBDS_NBDS = 36,


    ! Length of source and destination info records in bytes.
    ! The info records are used to hold information gathered in FIND_CVT_PATH,
    ! so that it can be easily recovered and used by DBG$CVT_DX_DX.
    !
    K_SRC_INFO_LENGTH = 8,
    K_DST_INFO_LENGTH = 8,
    K_TEMP_BUF_LENGTH = 50,


    ! Define bit patterns for calling OTS conversion routines.
    !
    K_IGN_BLKS = 1,
    K_ENB_UNDERFLOW = 4,
    K_IGN_TABS = 16,
    K_ENB_SCALE = 64,


    ! Bit map to use to set all arithmetic traps
    !
    K_SET_ARITHMETIC_TRAP = 32 + 64 + 128;

! Macros.
!
MACRO


    ! These macros define portions of intermediate data buffer.
    !
    LONG_1 =   0, 0, 32, 0 %,
    LONG_2 =   4, 0, 32, 0 %,
    LONG_3 =   8, 0, 32, 0 %,
    LONG_4 =  12, 0, 32, 0 %,
    LONG_5 =  16, 0, 32, 0 %,
    LONG_6 =  20, 0, 32, 0 %,
    LONG_7 =  24, 0, 32, 0 %,
    LONG_8 =  28, 0, 32, 0 %,
    S_LONG_1 = 0, 0, 32, 1 %,
    S_LONG_2 = 4, 0, 32, 1 %,
    S_BYTE_1 = 0, 0,  8, 1 %,
    BYTE_1 =   0, 0,  8, 0 %,
    BYTE_2 =   1, 0,  8, 0 %,
    S_WORD_1 = 0, 0, 16, 1 %,
    WORD_1 =   0, 0, 16, 0 %,
    WORD_2 =   2, 0, 16, 0 %,
    NIBBLE_1 = 0, 0,  4, 0 %,
	    

    ! This macro calculates final states given the current state and the token.
    !
    FINAL_STATE (CLASS, DATA_TYPE) = 
	((K_MAX_DATA_TYPES *
	BEGIN
	    CASE CLASS FROM K_MIN_CLASS TO K_MAX_CLASS OF
	    	SET

		! These are presenty the only classes permitted.
		!
	    	[K_STATE1_CLASS_S]:    0;
	    	[K_STATE2_CLASS_D]:    1;
	    	[K_STATE4_CLASS_A]:    2;
	    	[K_STATE9_CLASS_SD]:   3;
	    	[K_STATE10_CLASS_NCA]: 4;
	    	[K_STATE11_CLASS_VS]:  5;
	    	[K_STATE13_CLASS_UBS]: 6;
		[INRANGE]:
		    BEGIN
		    $DBG_ERROR ('DBGCVTDX:  invalid class');
		    0
		    END;
		TES
	END ) + DATA_TYPE) %,
	    

    ! Again, the SRC and DST_INFO records are filled in by FIND_CVT_PATH
    ! so that information concerning the source and/or destination descriptors
    ! is readily available to DBG$CVT_DX_DX.
    !
    ! These macros are used for SRC_INFO or DST_INFO scale fields.
    !
    M_SCALE = 0, 0, 8, 1 %,
    M_BIN_SCALE = 7, 1, 1, 0 %,
	    

    ! This macro is used for SRC_INFO or DST_INFO length field.
    !
    M_LEN = 5, 0, 16, 0 %,


    ! Define the start state.
    !
    START_STATE = VECTOR [K_MAX_CLASSES, BYTE, SIGNED] %,

	    
    ! These MACROs are defined for the purpose of clarity, less typing, and anticipation
    ! of future support of BUILTINs.
    !
    ASHP    = DBG$CVT_ASHP_R1 %,
    CMPH    = DBG$CVT_CMPH_R1 %,
    CVTDH   = DBG$CVT_CVTDH_R1 %,
    CVTHD   = DBG$CVT_CVTHD_R1 %,
    CVTHF   = DBG$CVT_CVTHF_R1 %,
    CVTHG   = DBG$CVT_CVTHG_R1 %,
    CVTGH   = DBG$CVT_CVTGH_R1 %,
    CVTLB   = DBG$CVT_CVTLB_R1 %,
    CVTLH   = DBG$CVT_CVTLH_R1 %,
    CVTLW   = DBG$CVT_CVTLW_R1 %,
    CVTRDQ  = DBG$CVT_CVTRDQ_R1 %,
    CVTRHL  = DBG$CVT_CVTRHL_R1 %,
    CVTRHO  = DBG$CVT_CVTRHO_R1 %,
    CVTRHQ  = DBG$CVT_CVTRHQ_R1 %,
    CVTROUD = DBG$CVT_CVTROUD_R1 %,
    CVTROUH = DBG$CVT_CVTROUH_R1 %,
    DIVD2   = DBG$CVT_DIVD2_R1 %,
    DIVH2   = DBG$CVT_DIVH2_R1 %,
    DIVP    = DBG$CVT_DIVP_R1 %,
    MULD2   = DBG$CVT_MULD2_R1 %,
    MULH2   = DBG$CVT_MULH2_R1 %,
    MULP    = DBG$CVT_MULP_R1 %,


! The following macros scale the intermediate data.
!
! These macros scale the longword in INTMED_DATA buffer.
!
M_SCALE_L_L =
    WHILE .BIN_SCALE GTR 0 DO
    	BEGIN
    	INTMED_DATA [LONG_1] = .INTMED_DATA [S_LONG_1]*2;
    	BIN_SCALE = .BIN_SCALE - 1;
    	END;
    WHILE .BIN_SCALE LSS 0 DO
    	BEGIN
    	INTMED_DATA [LONG_1] = .INTMED_DATA [S_LONG_1]/2;
    	BIN_SCALE = .BIN_SCALE + 1;
    	END;
    WHILE .SCALE GTR 0 DO
	BEGIN
	INTMED_DATA [LONG_1] = .INTMED_DATA [S_LONG_1]*10;
	SCALE = .SCALE - 1;
	END;
    WHILE .SCALE LSS 0 DO
	BEGIN
	INTMED_DATA [LONG_1] = .INTMED_DATA [S_LONG_1]/10;
	SCALE = .SCALE + 1;
	END
    %,


    ! Convert L to OU and scale it.  INTMED_DATA is used for L and OU
    !
    M_SCALE_L_OU =

	IF .INTMED_DATA [S_LONG_1] LSS 0
	THEN
	    BEGIN
	    INTMED_DATA [LONG_1] = ABS (.INTMED_DATA [S_LONG_1]);
	    SRC_INFO [S_SIGN] = 1;
	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_UP_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END;

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    DBG$CVT_SCALE_OU_UP_BY_2_R1 (INTMED_DATA);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DBG$CVT_SCALE_OU_DOWN_BY_2_R1 (INTMED_DATA);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END

    %,


    ! Convert L to D, and scale it.  INTMED_DATA buffer is used for L and D.
    !
    M_SCALE_L_D =
	CVTLD (INTMED_DATA, INTMED_DATA);

        WHILE .BIN_SCALE GTR 0 DO
            BEGIN
    	    MULD2 (UPLIT (%D'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE - 1;
    	    END;

        WHILE .BIN_SCALE LSS 0 DO
    	    BEGIN
    	    DIVD2 (UPLIT (%D'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE + 1;
    	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Convert L to P, and scale it.  INTMED_DATA is the buffer for L and P.
    !
    M_SCALE_L_P =

	IF .INTMED_DATA [S_LONG_1] LSS 0 THEN SRC_INFO [S_SIGN] = 1;

	NO_DIGITS = 31;
	CVTLP (INTMED_DATA, NO_DIGITS, INTMED_DATA);

	IF .SCALE NEQ 0
	THEN
	    BEGIN
	    MOVP (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
    	    IF .CVT_ROUND_FLAG
    	    THEN
	        ASHP (SCALE, NO_DIGITS, TEMP_BUF1, %REF (5), NO_DIGITS, INTMED_DATA)
    	    ELSE
	        ASHP (SCALE, NO_DIGITS, TEMP_BUF1, %REF (0), NO_DIGITS, INTMED_DATA);

	    END;

        WHILE .BIN_SCALE GTR 0 DO
            BEGIN
	    MOVP (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
    	    MULP (%REF (1), UPLIT (%P'2'), NO_DIGITS, TEMP_BUF1, NO_DIGITS, INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE - 1;
    	    END;

        WHILE .BIN_SCALE LSS 0 DO
    	    BEGIN
	    MOVP (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
    	    DIVP (%REF (1), UPLIT (%P'2'), NO_DIGITS, TEMP_BUF1, NO_DIGITS, INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE + 1;
    	    END

    %,


    ! Scale the OU in INTMED_DATA buffer.
    !
    M_SCALE_OU_OU =

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_UP_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END;

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    DBG$CVT_SCALE_OU_UP_BY_2_R1 (INTMED_DATA);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DBG$CVT_SCALE_OU_DOWN_BY_2_R1 (INTMED_DATA);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END

    %,


    ! Convert OU to D, and scale it.  INTMED_DATA is used for OU and D.
    !
    M_SCALE_OU_D =
	CVTROUD (INTMED_DATA, TEMP_BUF1);
	CH$MOVE (8, TEMP_BUF1, INTMED_DATA);

        WHILE .BIN_SCALE GTR 0 DO
            BEGIN
    	    MULD2 (UPLIT (%D'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE - 1;
    	    END;

        WHILE .BIN_SCALE LSS 0 DO
    	    BEGIN
    	    DIVD2 (UPLIT (%D'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE + 1;
    	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Convert OU to H, and scale it.  INTMED_DATA is used for OU and H.
    !
    M_SCALE_OU_H =
	CVTROUH (INTMED_DATA, TEMP_BUF1);
	CH$MOVE (16, TEMP_BUF1, INTMED_DATA);

        WHILE .BIN_SCALE GTR 0 DO
            BEGIN
    	    MULH2 (UPLIT (%H'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE - 1;
    	    END;

        WHILE .BIN_SCALE LSS 0 DO
    	    BEGIN
    	    DIVH2 (UPLIT (%H'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE + 1;
    	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Convert L to H, and scale it.  INTMED_DATA is used for L and H.
    !
    M_SCALE_L_H =
	CVTLH (INTMED_DATA, INTMED_DATA);

        WHILE .BIN_SCALE GTR 0 DO
            BEGIN
    	    MULH2 (UPLIT (%H'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE - 1;
    	    END;

        WHILE .BIN_SCALE LSS 0 DO
    	    BEGIN
    	    DIVH2 (UPLIT (%H'2'), INTMED_DATA);
    	    BIN_SCALE = .BIN_SCALE + 1;
    	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Scale D in INTMED_DATA.
    !
    M_SCALE_D_D =

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'2'), INTMED_DATA);
	    MULD2 (UPLIT (%D'2'), INTMED_DATA+8);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'2'), INTMED_DATA);
	    DIVD2 (UPLIT (%D'2'), INTMED_DATA+8);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'10'), INTMED_DATA);
	    MULD2 (UPLIT (%D'10'), INTMED_DATA+8);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA);
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA+8);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Convert D to H, and scale it.  INTMED_DATA is used for D and H.
    !
    M_SCALE_D_H =
	CVTDH (INTMED_DATA, TEMP_BUF1);
	CVTDH (INTMED_DATA+8, INTMED_DATA+16);
	CH$MOVE (16, TEMP_BUF1, INTMED_DATA);

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'2'), INTMED_DATA);
	    MULH2 (UPLIT (%H'2'), INTMED_DATA+16);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'2'), INTMED_DATA);
	    DIVH2 (UPLIT (%H'2'), INTMED_DATA+16);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    MULH2 (UPLIT (%H'10'), INTMED_DATA+16);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA+16);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Convert G to H, and scale it.  INTMED_DATA is used for G and H.
    !
    M_SCALE_G_H =
	BEGIN
	CVTGH (INTMED_DATA, TEMP_BUF1);
	CVTGH (INTMED_DATA+8, INTMED_DATA+16);
	CH$MOVE (16, TEMP_BUF1, INTMED_DATA);

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'2'), INTMED_DATA);
	    MULH2 (UPLIT (%H'2'), INTMED_DATA+16);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'2'), INTMED_DATA);
	    DIVH2 (UPLIT (%H'2'), INTMED_DATA+16);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    MULH2 (UPLIT (%H'10'), INTMED_DATA+16);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA+16);
	    SCALE = .SCALE + 1;
	    END;
	END

    %,


    ! Scale H in INTMED_DATA.
    !
    M_SCALE_H_H =

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'2'), INTMED_DATA);
	    MULH2 (UPLIT (%H'2'), INTMED_DATA+16);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'2'), INTMED_DATA);
	    DIVH2 (UPLIT (%H'2'), INTMED_DATA+16);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    MULH2 (UPLIT (%H'10'), INTMED_DATA+16);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA+16);
	    SCALE = .SCALE + 1;
	    END

    %,


    ! Scale P in INTMED_DATA
    !
    M_SCALE_P_P =
	NO_DIGITS = .SRC_INFO [S_LEN];

	IF (CMPP (NO_DIGITS, INTMED_DATA, %REF (1), .PACK_ZERO) LSS 0) THEN SRC_INFO [S_SIGN] = 1;

	IF .SCALE NEQ 0
	THEN
	    BEGIN
	    MOVP (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
    	    IF .CVT_ROUND_FLAG
    	    THEN
	        ASHP (SCALE, NO_DIGITS, TEMP_BUF1, %REF (5), NO_DIGITS, INTMED_DATA)
    	    ELSE
    	        ASHP (SCALE, NO_DIGITS, TEMP_BUF1, %REF (0), NO_DIGITS, INTMED_DATA);
    	    END;


!	I (PS) added the following code, because, if I deposit a packed decimal
!	number 999.888 into a 4 digits decimal number scaled -2, I want to get
!	a result of 99.88, instead of later on I will get overflow error, and
! 	have nothing as result.  Check to see if the siganificant digits of
!	source is greater than the siganificant digits of the destination.
!
!	This piece of code is used only if both operands are packed.
!

        IF (.SOURCE[DSC$W_LENGTH] + .SOURCE[DSC$B_SCALE] GTR
    	    .DESTINATION[DSC$W_LENGTH] + .DESTINATION[DSC$B_SCALE]) AND
    	   (.SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_P AND
    	    .DESTINATION[DSC$B_DTYPE] EQL DSC$K_DTYPE_P)
    	THEN
    	    BEGIN
    	    LOCAL
    		HIGH_NIBBLE_PTR: REF VECTOR[,BYTE],
    		LOW_NIBBLE_PTR: REF VECTOR[,BYTE];


    	    ! Point to the last digits.
    	    !
    	    HIGH_NIBBLE_PTR = INTMED_DATA + 16 - 1;


    	    ! Backup the pointer to the siganificant digit
    	    ! needs to be truncated.  Zero out everything
    	    ! before that.
    	    !
    	    LOW_NIBBLE_PTR = .HIGH_NIBBLE_PTR - 
    		    (.DESTINATION[DSC$W_LENGTH] / 2 + 1) + 1;


   	    ! If destination digits is even, we need to
    	    ! zero out one nibble.  Note: this may be already zero.
    	    !
    	    IF (.DESTINATION[DSC$W_LENGTH] MOD 2) EQL 0
    	    THEN
    		LOW_NIBBLE_PTR[0] = .LOW_NIBBLE_PTR[0] AND %X'0F';


    	    ! Zero out everything before it.  Note: this may be already
    	    ! zero.
    	    !
    	    LOW_NIBBLE_PTR = .LOW_NIBBLE_PTR - 1;
    	    WHILE .LOW_NIBBLE_PTR GEQ INTMED_DATA DO
    	        BEGIN
    		LOW_NIBBLE_PTR[0] = %X'00';
    		LOW_NIBBLE_PTR = .LOW_NIBBLE_PTR - 1;
    		END;
    	
            SIGNAL(DBG$_INUMTRUNC, 1, .DBG$GL_OPCODE_NAME);
	    END

    %,


    ! Convert P to OU, and scale it.  INTMED_DATA is used for P and OU.
    !
    M_SCALE_P_OU =
	NO_DIGITS = .SRC_INFO [S_LEN];
	CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
	CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
	CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF1;
	OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF2);

	IF .TEMP_BUF2 [0, 15, 1, 0]
	THEN
	    BEGIN
	    TEMP_BUF2 [0, 15, 1, 0] = 0;
	    SRC_INFO [S_SIGN] = 1;
	    END;

	CVTRHO (TEMP_BUF2, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_UP_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END;

	WHILE .BIN_SCALE GTR 0 DO
	    BEGIN
	    DBG$CVT_SCALE_OU_UP_BY_2_R1 (INTMED_DATA);
	    BIN_SCALE = .BIN_SCALE - 1;
	    END;

	WHILE .BIN_SCALE LSS 0 DO
	    BEGIN
	    DBG$CVT_SCALE_OU_DOWN_BY_2_R1 (INTMED_DATA);
	    BIN_SCALE = .BIN_SCALE + 1;
	    END

    %,


    ! Convert P to D, and scale it.  INTMED_DATA is used for P and D.
    !
    M_SCALE_P_D =
	NO_DIGITS = .SRC_INFO [S_LEN];

    	! In the case of scaled packed, we need to get the scale this way.
    	!
    	IF .SOURCE[DSC$B_CLASS] EQL DSC$K_CLASS_SD
    	THEN
    	    SCALE = - .SOURCE[DSC$B_SCALE];

	CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
	CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
	CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF1;
	STATUS = OTS$CVT_T_D (CLASS_S_DESC, INTMED_DATA, 0, .SCALE, (K_ENB_UNDERFLOW OR K_ENB_SCALE));

	IF NOT .STATUS
	THEN
	    IF .SCALE LSS 0
	    	THEN SIGNAL (DBG$_IFLTUND, 1, .DBG$GL_OPCODE_NAME)
	    	ELSE SIGNAL (DBG$_FLTOVF, 1, .DBG$GL_OPCODE_NAME); %,


    ! Convert P to H, and scale it.  INTMED_DATA is used for P and H.
    !
    M_SCALE_P_H =
	NO_DIGITS = .SRC_INFO [S_LEN];

    	! In the case of scaled packed, we need to get the scale this way.
    	!
    	IF .SOURCE[DSC$B_CLASS] EQL DSC$K_CLASS_SD
    	THEN
    	    SCALE = - .SOURCE[DSC$B_SCALE];

	CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
	CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
	CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF1;
	STATUS = OTS$CVT_T_H (CLASS_S_DESC, INTMED_DATA, 0, .SCALE, (K_ENB_UNDERFLOW OR K_ENB_SCALE));

	IF NOT .STATUS
	THEN
	    IF .SCALE LSS 0
	    	THEN SIGNAL (DBG$_IFLTUND, 1, .DBG$GL_OPCODE_NAME)
	    	ELSE SIGNAL (DBG$_FLTOVF, 1, .DBG$GL_OPCODE_NAME); %;

! Structure and Field Definitions.
!
! STATES is a structure into which go all the states other than the first.
! The final states and the states that never get used (such as the states that
! contain non-supported CLASSes) will not be in this structure.
!
STRUCTURE
    STATES [STATE, TOKEN] =
	[K_ACTUAL_CLASSES*K_MAX_DATA_TYPES]
	(STATES + (K_MAX_DATA_TYPES*
	BEGIN
	CASE STATE FROM K_MIN_CLASS TO K_MAX_CLASS OF
	    SET
	    [K_STATE1_CLASS_S]:    0;
	    [K_STATE2_CLASS_D]:    1;
	    [K_STATE4_CLASS_A]:    2;
	    [K_STATE9_CLASS_SD]:   3;
	    [K_STATE10_CLASS_NCA]: 4;
	    [K_STATE11_CLASS_VS]:  5;
	    [K_STATE13_CLASS_UBS]: 6;
	    [INRANGE, OUTRANGE]:  
		BEGIN
		$DBG_ERROR ('DBGCVTDX:  invalid class');
		0
		END;
	    TES
	END
	) + TOKEN)<0, %BPUNIT, 1>;


! SRC and DST INFO record fields.
!
FIELD
    SRC_INFO_FIELDS =
	SET
	S_SCALE = [0, 0, 8, 1],
	S_POINTER = [1, 0, 32, 0],
	S_LEN = [5, 0, 16, 0],
	S_SIGN = [7, 0, 1, 0],
    	S_BIN_SCALE = [7, 1, 1, 0]	! Flag indicating scale is binary
	TES;

FIELD
    DST_INFO_FIELDS =
	SET
	D_SCALE = [0, 0, 8, 1],
	D_LEN = [5, 0, 16, 0],
    	D_BIN_SCALE = [7, 1, 1, 0]	! Flag indicating scale is binary
	TES;

! State Table.
!
! Start States (all classes).  CLASS_TABLE.
! These are the start state entries.
! For each CLASS in the standard there is an entry here.  They are:
!       Z     ,S    ,D    ,V     ,A
!      ,P     ,none ,J    ,none  ,SD
!      ,NCA   ,VS   ,VSA  ,UBS   ,UBA.
!
BIND
    CLASS_TABLE = UPLIT BYTE
    %( Start state.  All classes. )%
    (K_UNSCLAROU,DSC$K_CLASS_S,DSC$K_CLASS_D,K_UNSCLAROU,DSC$K_CLASS_A
    ,K_UNSCLAROU,K_UNSCLASTA,K_UNSCLAROU,K_UNSCLASTA,DSC$K_CLASS_SD
    ,DSC$K_CLASS_NCA,DSC$K_CLASS_VS,K_UNSCLAROU,DSC$K_CLASS_UBS,K_UNSCLAROU): START_STATE;


! Remaining States.  DTYPE_TABLE.
!
! This is the rest of the state table.  It is separate for space efficiency.
! Each state contains entries for each data type supported by the standard.
! Note that for space efficiency the final states are not in the vector.
! Also since each state represents a supported CLASS, if a CLASS is not
! supported (by the standard or routine), then the state has no entry in
! the vector.  The index table for the vector will index to the proper place
! in the vector below.
! The table below shows graphically what descriptors are valid.
!
!                                  DSC$K__DTYPE__x
!                  BU WU LU B W L Q F D G H T NU NL NLO NR NRO NZ P VT AC AZ TF V SV VU SVU
!DSC$K__CLASS__S   x  x  x  x x x x x x x x x x  x  x   x  x   x  x             x  x
!DSC$K__CLASS__D                            x
!DSC$K__CLASS__SD           x x x x x x x x x x  x  x   x  x   x  x
!DSC$K__CLASS__VS                           x                        x  x  x
!DSC$K__CLASS__A   x                        x
!DSC$K__CLASS__NCA x                        x
!DSC$K__CLASS__UBS							      x       x   x
!
!
! Note that these data types are hard coded in (zero based vector, and position
! of each data type is determined be the value of the symbol), so if data type
! values are ever rearranged this table must be rearranged.
!
BIND
    DTYPE_TABLE = UPLIT BYTE
    %( State zero. Class z. )%
    %( State one.  Class s. )%
    	(K_UNSDTYROU,DSC$K_DTYPE_V,DSC$K_DTYPE_BU,DSC$K_DTYPE_WU,DSC$K_DTYPE_LU
    	,DSC$K_DTYPE_QU,DSC$K_DTYPE_B,DSC$K_DTYPE_W,DSC$K_DTYPE_L,DSC$K_DTYPE_Q
    	,DSC$K_DTYPE_F,DSC$K_DTYPE_D,DSC$K_DTYPE_FC,DSC$K_DTYPE_DC,DSC$K_DTYPE_T
    	,DSC$K_DTYPE_NU,DSC$K_DTYPE_NL,DSC$K_DTYPE_NLO,DSC$K_DTYPE_NR,DSC$K_DTYPE_NRO
    	,DSC$K_DTYPE_NZ,DSC$K_DTYPE_P,DSC$K_DTYPE_ZI,K_UNSDTYROU,K_UNSDESSTA
    	,K_UNSDTYROU,DSC$K_DTYPE_O,DSC$K_DTYPE_G,DSC$K_DTYPE_H,DSC$K_DTYPE_GC
    	,DSC$K_DTYPE_HC,K_UNSDTYROU,K_UNSDTYROU,K_UNSDTYROU,K_UNSDTYROU
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,DSC$K_DTYPE_TF
	,DSC$K_DTYPE_SV,K_UNSDTYROU
    %( State two.  Class d. )%
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,DSC$K_DTYPE_T
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    %( State three.  Class v. )%
    %( State four.  Class a. )%
     	,K_UNSDTYROU,K_UNSDTYROU,DSC$K_DTYPE_BU,K_UNSDESROU,K_UNSDESROU
     	,K_UNSDTYROU,K_UNSDESROU,K_UNSDESROU,K_UNSDESROU,K_UNSDESROU
     	,K_UNSDESROU,K_UNSDESROU,K_UNSDTYROU,K_UNSDTYROU,DSC$K_DTYPE_T
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDTYROU
     	,K_UNSDTYROU,K_UNSDTYROU,K_UNSDESROU,K_UNSDESROU,K_UNSDTYROU
     	,K_UNSDESSTA,K_UNSDTYROU,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    %( State five.  Class p. )%
    %( State six.  Class 'undefined' )%
    %( State seven.  Class j. )%
    %( State eight.  Class 'undefined' )%
    %( State nine.  Class sd. )%
     	,K_UNSDESSTA,K_UNSDESSTA,DSC$K_DTYPE_BU,DSC$K_DTYPE_WU,DSC$K_DTYPE_LU
     	,DSC$K_DTYPE_QU,DSC$K_DTYPE_B,DSC$K_DTYPE_W,DSC$K_DTYPE_L,DSC$K_DTYPE_Q
     	,DSC$K_DTYPE_F,DSC$K_DTYPE_D,DSC$K_DTYPE_FC,DSC$K_DTYPE_DC,DSC$K_DTYPE_T
     	,DSC$K_DTYPE_NU,DSC$K_DTYPE_NL,DSC$K_DTYPE_NLO,DSC$K_DTYPE_NR,DSC$K_DTYPE_NRO
     	,DSC$K_DTYPE_NZ,DSC$K_DTYPE_P,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,DSC$K_DTYPE_O,DSC$K_DTYPE_G,DSC$K_DTYPE_H,DSC$K_DTYPE_GC
     	,DSC$K_DTYPE_HC,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    %( State ten.  Class nca. )%
     	,K_UNSDTYROU,K_UNSDTYROU,DSC$K_DTYPE_BU,K_UNSDESROU,K_UNSDESROU
     	,K_UNSDTYROU,K_UNSDESROU,K_UNSDESROU,K_UNSDESROU,K_UNSDESROU
     	,K_UNSDESROU,K_UNSDESROU,K_UNSDTYROU,K_UNSDTYROU,DSC$K_DTYPE_T
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDTYROU
     	,K_UNSDTYROU,K_UNSDTYROU,K_UNSDESROU,K_UNSDESROU,K_UNSDTYROU
     	,K_UNSDESSTA,K_UNSDTYROU,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    %( State eleven.  Class vs. )%
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,DSC$K_DTYPE_T
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
     	,K_UNSDESSTA,K_UNSDESSTA,DSC$K_DTYPE_VT,DSC$K_DTYPE_AC
	,DSC$K_DTYPE_AZ,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
    %( State twelve.  Class vsa. )%
    %( State thirteen.  Class ubs. )%
    	,K_UNSDTYROU,DSC$K_DTYPE_V,DSC$K_DTYPE_BU,DSC$K_DTYPE_WU,DSC$K_DTYPE_LU
    	,DSC$K_DTYPE_QU,DSC$K_DTYPE_B,DSC$K_DTYPE_W,DSC$K_DTYPE_L,DSC$K_DTYPE_Q
    	,DSC$K_DTYPE_F,DSC$K_DTYPE_D,DSC$K_DTYPE_FC,DSC$K_DTYPE_DC,DSC$K_DTYPE_T
    	,DSC$K_DTYPE_NU,DSC$K_DTYPE_NL,DSC$K_DTYPE_NLO,DSC$K_DTYPE_NR,DSC$K_DTYPE_NRO
    	,DSC$K_DTYPE_NZ,DSC$K_DTYPE_P,K_UNSDTYROU,K_UNSDTYROU,K_UNSDESSTA
    	,K_UNSDTYROU,DSC$K_DTYPE_O,DSC$K_DTYPE_G,DSC$K_DTYPE_H,DSC$K_DTYPE_GC
    	,DSC$K_DTYPE_HC,K_UNSDTYROU,K_UNSDTYROU,K_UNSDTYROU,DSC$K_DTYPE_VU
    	,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA,K_UNSDESSTA
	,DSC$K_DTYPE_TF,DSC$K_DTYPE_SV,DSC$K_DTYPE_SVU
    %( State fourteen.  Class uba. )%
    %( Add more states below )%
    ) : STATES;


! Final States.
!
!These are the final states that are valid CLASS, DATA TYPE combinations.
!The rest of the final states are error states.
!The first argument to the macro is CLASS, and the second is the DATA TYPE.
!
LITERAL
    K_S_BU = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_BU),
    K_S_WU = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_WU),
    K_S_LU = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_LU),
    K_S_B = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_B),
    K_S_W = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_W),
    K_S_L = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_L),
    K_S_V = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_V),
    K_S_SV = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_SV),
    K_S_TF = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_TF),
    K_S_Q = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_Q),
    K_S_QU = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_QU),
    K_S_O = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_O),
    K_S_F = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_F),
    K_S_FC = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_FC),
    K_S_D = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_D),
    K_S_DC = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_DC),
    K_S_T = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_T),
    K_S_NU = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_NU),
    K_S_NL = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_NL),
    K_S_NLO = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_NLO),
    K_S_NR = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_NR),
    K_S_NRO = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_NRO),
    K_S_NZ = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_NZ),
    K_S_ZI = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_ZI),
    K_S_P = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_P),
    K_S_G = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_G),
    K_S_GC = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_GC),
    K_S_H = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_H),
    K_S_HC = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_HC),
    K_UBS_V = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_V),
    K_UBS_BU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_BU),
    K_UBS_WU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_WU),
    K_UBS_LU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_LU),
    K_UBS_B = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_B),
    K_UBS_W = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_W),
    K_UBS_L = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_L),
    K_UBS_Q = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_Q),
    K_UBS_QU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_QU),
    K_UBS_F = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_F),
    K_UBS_D = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_D),
    K_UBS_FC = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_FC),
    K_UBS_DC = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_DC),
    K_UBS_T = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_T),
    K_UBS_NU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_NU),
    K_UBS_NL = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_NL),
    K_UBS_NLO = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_NLO),
    K_UBS_NR = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_NR),
    K_UBS_NRO = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_NRO),
    K_UBS_NZ = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_NZ),
    K_UBS_P = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_P),
    K_UBS_O = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_O),
    K_UBS_G = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_G),
    K_UBS_H = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_H),
    K_UBS_GC = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_GC),
    K_UBS_HC = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_HC),
    K_UBS_SV = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_SV),
    K_UBS_VU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_VU),
    K_UBS_SVU = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_SVU),
    K_UBS_TF = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_TF),
    K_D_T = FINAL_STATE (DSC$K_CLASS_D, DSC$K_DTYPE_T),
    K_A_BU = FINAL_STATE (DSC$K_CLASS_A, DSC$K_DTYPE_BU),
    K_A_T = FINAL_STATE (DSC$K_CLASS_A, DSC$K_DTYPE_T),
    K_SD_BU = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_BU),
    K_SD_WU = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_WU),
    K_SD_LU = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_LU),
    K_SD_B = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_B),
    K_SD_W = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_W),
    K_SD_L = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_L),
    K_SD_Q = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_Q),
    K_SD_QU = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_QU),
    K_SD_O = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_O),
    K_SD_F = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_F),
    K_SD_FC = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_FC),
    K_SD_D = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_D),
    K_SD_DC = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_DC),
    K_SD_G = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_G),
    K_SD_GC = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_GC),
    K_SD_H = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_H),
    K_SD_HC = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_HC),
    K_SD_T = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_T),
    K_SD_NU = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_NU),
    K_SD_NL = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_NL),
    K_SD_NLO = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_NLO),
    K_SD_NR = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_NR),
    K_SD_NRO = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_NRO),
    K_SD_NZ = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_NZ),
    K_SD_P = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_P),
    K_NCA_BU = FINAL_STATE (DSC$K_CLASS_NCA, DSC$K_DTYPE_BU),
    K_NCA_T = FINAL_STATE (DSC$K_CLASS_NCA, DSC$K_DTYPE_T),
    K_VS_AC = FINAL_STATE (DSC$K_CLASS_VS, DSC$K_DTYPE_AC),
    K_VS_AZ = FINAL_STATE (DSC$K_CLASS_VS, DSC$K_DTYPE_AZ),
    K_VS_T = FINAL_STATE (DSC$K_CLASS_VS, DSC$K_DTYPE_T),
    K_VS_VT = FINAL_STATE (DSC$K_CLASS_VS, DSC$K_DTYPE_VT),
    K_SMLFINSTA = FINAL_STATE (DSC$K_CLASS_S, DSC$K_DTYPE_V),		! Smallest final state supported.
    K_LRGFINSTA = FINAL_STATE (DSC$K_CLASS_UBS, DSC$K_DTYPE_SVU),	! Largest final state supported.
    K_TOP_SD = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_HC),		! Top state for class SD.
    K_BOTTOM_SD = FINAL_STATE (DSC$K_CLASS_SD, DSC$K_DTYPE_B);		! Bottom state for class SD.

GLOBAL ROUTINE DBG$COVER_DX_DX (SRC_VALUE_DESC, DST_VALUE_DESC, CVT_ROUND_FLAG) =
!
! FUNCTION
!	This routine is a cover function for DBG$CVT_DX_DX. It has
!	two purposes:
!	1. To declare a handler which screens errors and changes them to
!	the appropriate DEBUG error.
!	2. To dummy in the correct class for DBG$CVT_DX_DX
!
! INPUTS
!	SRC_VALUE_DESC	- Pointer to a value descriptor to be type-converted.
!
!	DST_VALUE_DESC	- Pointer to the target value descriptor.
!
!	CVT_ROUND_FLAG  - A flag set to TRUE to indicate the rounding takes
!			  place in conversion.
!
! OUTPUTS
!	A pointer to a value descriptor is returned.  The target descriptor 
!	is filled in with the result of the conversion.
!
    BEGIN

    MAP
    	SRC_VALUE_DESC: REF DBG$VALDESC,
    	DST_VALUE_DESC: REF DBG$VALDESC;

    LOCAL
    	DUMMY,				! A dummy parameter.
    	FCODE,				! Fcode for the data object
	STATUS,				! Return status from typeid check.
    	SOURCE_CLASS: BYTE,		! Class of Source VMS descriptor
    	TARGET_CLASS: BYTE,		! Class of Target VMS descriptor
	SOURCE_DTYPE: BYTE,		! Dtype of Source VMS descriptor
	TARGET_DTYPE: BYTE,		! Dtype of Target VMS descriptor
    	SOURCE_LENGTH: WORD,		! Length of Source VMS descriptor
    	TARGET_LENGTH: WORD,		! Length of Target VMS descriptor
	DESC_VAL: REF DBG$VALDESC,	! Pointer to source or target value descriptor
	DESC_PTR: REF BLOCK[,BYTE],	! Pointer to source or target descriptor.
       	SOURCE: REF BLOCK[,BYTE],	! Address of VMS descriptor
    	TARGET: REF BLOCK[,BYTE],	! Address of VMS descriptor
    	TYPEID_INDEX;			! Typeid index to perform the typeid
    					!	check


    ! Recover the VMS descriptors.
    !
    SOURCE = SRC_VALUE_DESC[DBG$A_VALUE_VMSDESC];
    TARGET = DST_VALUE_DESC[DBG$A_VALUE_VMSDESC];


    ! Save pointer to result.
    !
    SAVE_RESULT = .DST_VALUE_DESC[DBG$L_VALUE_POINTER];


    ! Dummy in the correct class field. (First saving away the old ones.)
    !
    SOURCE_CLASS = .SOURCE[DSC$B_CLASS];
    TARGET_CLASS = .TARGET[DSC$B_CLASS];
    SOURCE_DTYPE = .SOURCE[DSC$B_DTYPE];
    TARGET_DTYPE = .TARGET[DSC$B_DTYPE];
    SOURCE_LENGTH = .SOURCE[DSC$W_LENGTH];


    ! The debugger doesn't handle dynamic string descriptors.  Some output is
    ! better than none, so we treat them as regular string descriptors, and
    ! truncate/pad as required.
    !
    IF .SOURCE_CLASS EQL DSC$K_CLASS_D AND .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_T
    THEN
	SOURCE[DSC$B_CLASS] = DSC$K_CLASS_S;
    IF .TARGET_CLASS EQL DSC$K_CLASS_D AND .TARGET[DSC$B_DTYPE] EQL DSC$K_DTYPE_T
    THEN
	TARGET[DSC$B_CLASS] = DSC$K_CLASS_S;


    ! If class field is zero, map in correct class/dtype.
    !
    IF .SOURCE[DSC$B_CLASS] EQL 0 
    THEN 
    	SOURCE[DSC$B_CLASS] = DBG$MAP_DTYPE_CLASS(.SOURCE[DSC$B_DTYPE], FALSE);

    IF .TARGET[DSC$B_CLASS] EQL 0 
    THEN
    	TARGET[DSC$B_CLASS] = DBG$MAP_DTYPE_CLASS(.TARGET[DSC$B_DTYPE], FALSE);


    ! Case on the Fcode.  If the target data is one of the non-standard
    ! data types then typeid and/or range value will be validated by
    ! calling DBG$PERFORM_TYPEID_CHECK.  First set up the routine check
    ! index according to fcode.
    !
    FCODE = .DST_VALUE_DESC[DBG$B_DHDR_FCODE];
    CASE .FCODE FROM RST$K_TYPE_MINIMUM	TO RST$K_TYPE_MAXIMUM OF
    	SET
    	[RST$K_TYPE_ENUM]:
    	    TYPEID_INDEX = ORT$K_TYPEID_ENUM_ENUM;

    	[RST$K_TYPE_SET]:
    	    TYPEID_INDEX = ORT$K_TYPEID_SET_SET;

    	[RST$K_TYPE_SUBRNG]:
    	    TYPEID_INDEX = ORT$K_TYPEID_SUBRNG_SUBRNG;

    	[INRANGE, OUTRANGE]:
    	    TYPEID_INDEX = 0;

        TES;


    ! If routine check index is set up, call dbg$perform_typeid_check
    ! to perform the typeid check.
    !
    IF .TYPEID_INDEX NEQ 0
    THEN
    	BEGIN
    	STATUS = DBG$PERFORM_TYPEID_CHECK(.TYPEID_INDEX,
        		.SRC_VALUE_DESC, .DST_VALUE_DESC, 0);

        IF NOT .STATUS THEN SIGNAL(DBG$_OPNOTALLOW, 1, .DBG$GL_OPCODE_NAME);
    	END;


    ! Now, typeid has checked, deposit is legal operation for both
    ! standard and non-standard data types at this point.
    ! Fixup the class and dtype fields to be vax standard format, so
    ! DBG$CVT_DX_DX can be called to perform the conversion.
    !
    INCR I FROM 0 TO 1 DO
	BEGIN
	IF .I EQL 0
	THEN
	    BEGIN
	    DESC_VAL = .SRC_VALUE_DESC;
	    DESC_PTR = .SOURCE;
	    END
	ELSE
	    BEGIN
	    DESC_VAL = .DST_VALUE_DESC;
	    DESC_PTR = .TARGET;
	    END;

    	IF (.DESC_VAL[DBG$B_VALUE_DTYPE] EQL 0 AND
    	    .DESC_VAL[DBG$B_VALUE_CLASS] EQL 0) 
    	THEN
    	    DESC_PTR = COVER_VMSDESC_SETUP(.DESC_VAL[DBG$L_DHDR_TYPEID],
    				.DESC_PTR);
	END;


    ! Adjust the length of the source.  So we won't get truncation message.
    ! This is used for, ie., DEP enum=1, where enum is allocated 1 byte, and
    ! 1 is 1 longword.  in some cases, we'll get integer overflow message.
    !
    SELECTONE .FCODE OF
    	SET
    	[RST$K_TYPE_ENUM, RST$K_TYPE_SUBRNG]:
    	    BEGIN
    	    IF .SRC_VALUE_DESC[DBG$L_DHDR_TYPEID] EQL 0
    	    THEN
    		BEGIN
    		IF .SRC_VALUE_DESC[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC
    		THEN
    		    BEGIN
    		    SOURCE[DSC$B_CLASS] = .TARGET[DSC$B_CLASS];
    		    SOURCE[DSC$B_DTYPE] = .TARGET[DSC$B_DTYPE];
    		    SOURCE[DSC$W_LENGTH] = .TARGET[DSC$W_LENGTH];
    		    END;

    		END;

    	    END;

    	[OTHERWISE]:
    	    0;
    	TES;


    ! Do the conversion.  Put everything back.
    !
    SELECTONE .FCODE OF
    	SET
    	[RST$K_TYPE_RFA]:
    	    CH$MOVE(.DST_VALUE_DESC[DBG$W_VALUE_LENGTH],
    		    .SRC_VALUE_DESC[DBG$L_VALUE_POINTER], .DST_VALUE_DESC[DBG$L_VALUE_POINTER]);
    		
    	[RST$K_TYPE_SET]:
    	    BEGIN
    	    LOCAL
    		INDEX,
		SETVALUE: REF BITVECTOR[];

    	    IF .SRC_VALUE_DESC[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_SET
    	    THEN
    		BEGIN
    		CH$MOVE(.DST_VALUE_DESC[DBG$W_VALUE_LENGTH],
    		    .SRC_VALUE_DESC[DBG$L_VALUE_POINTER], .DST_VALUE_DESC[DBG$L_VALUE_POINTER]);
    		END

    	    ELSE
    		BEGIN
    	        INDEX = ..SRC_VALUE_DESC[DBG$L_VALUE_POINTER];
    		IF .INDEX LSS 0 THEN SIGNAL(DBG$_BITRANGE);
    	        SETVALUE = .DST_VALUE_DESC[DBG$L_VALUE_POINTER];
    	        IF .INDEX LEQ (.DST_VALUE_DESC[DBG$W_VALUE_LENGTH] * 8 - 1)
    	        THEN
    	            SETVALUE[.INDEX] = 1
    	        ELSE
    		    SIGNAL(DBG$_BITRANGE);
    		END;
    	    END;

    	[OTHERWISE]:
            DBG$CVT_DX_DX (.SOURCE, .TARGET, DUMMY, .CVT_ROUND_FLAG);
    	TES;


    SOURCE[DSC$B_CLASS] = .SOURCE_CLASS;
    SOURCE[DSC$B_DTYPE] = .SOURCE_DTYPE;
    SOURCE[DSC$W_LENGTH] = .SOURCE_LENGTH;
    TARGET[DSC$B_CLASS] = .TARGET_CLASS;
    TARGET[DSC$B_DTYPE] = .TARGET_DTYPE;


    ! Do range check.
    !
    IF .TYPEID_INDEX NEQ 0
    THEN
        BEGIN
	STATUS = DBG$PERFORM_TYPEID_CHECK (.TYPEID_INDEX, 
    			.SRC_VALUE_DESC, 0, .DST_VALUE_DESC);
        IF NOT .STATUS
    	THEN
 	    SIGNAL (DBG$_IVALOUTBNDS, 1, .DBG$GL_OPCODE_NAME);
    	END;

    RETURN .DST_VALUE_DESC;
    END;

ROUTINE COVER_VMSDESC_SETUP(TYPEID, VMSDESC) =
!
! FUNCTION
!	This routine is a hack routine called depending on FCODE in the
!	TYPEID. The purpose of this routine is to plunge in the class code 
!	and dtype so that the DBG$CVT_DX_DX can be called.  
!
! INPUTS
!	TYPEID 	- Typeid of the data object.
!
!	VMSDESC	- Vax standard Descriptor.
!
! OUTPUTS
!	VMSDESC is returned.  
!

    BEGIN
    MAP
    	TYPEID: REF RST$ENTRY,
    	VMSDESC: REF BLOCK[,BYTE];

    VMSDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    SELECTONE .TYPEID[RST$B_FCODE] OF
    	SET
	[RST$K_TYPE_ENUM]:
    	    BEGIN
	    SELECTONE .VMSDESC[DSC$W_LENGTH] OF
    		SET
    		[1]:
    		    VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_BU;
		[2]:
    		    VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_WU;
		[OTHERWISE]:
    		    VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_LU;
		TES;
    	    END;

    	[RST$K_TYPE_SUBRNG]:
    	    BEGIN
    	    LOCAL
    		DUMMY1, DUMMY2, DUMMY3, DTYPE;

    	    WHILE .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
    		DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, DUMMY1, DUMMY2, DUMMY3);

    	    SELECTONE .TYPEID[RST$B_FCODE] OF
    		SET
    		[RST$K_TYPE_ENUM]:
    		    VMSDESC = COVER_VMSDESC_SETUP(.TYPEID, .VMSDESC);
    		    
    		[RST$K_TYPE_ATOMIC]:
    		    BEGIN
    		    DBG$STA_TYP_ATOMIC(.TYPEID, DTYPE, DUMMY3);
    		    IF .DTYPE EQL DST$K_BOOL THEN DTYPE = DSC$K_DTYPE_TF;
    		    VMSDESC[DSC$B_DTYPE] = .DTYPE;


		    ! In here we have a bit of problem, for the size of
		    ! the parant and the size of the subrange is different.
    		    ! For example, subrange's parant can be longword integer
		    ! and subrange can be 1 byte.  In order for the type
		    ! converter to take the right value, we adjust the dtype
		    ! by the length.
		    !
		    IF (.DTYPE NEQ DSC$K_DTYPE_T AND .DTYPE NEQ DSC$K_DTYPE_TF)
		    THEN
			BEGIN
	    	    	SELECTONE .VMSDESC[DSC$W_LENGTH] OF
			    SET
			    [1]:
		    	        VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_B;
			    [2]:
		    	        VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_W;
			    [OTHERWISE]:
		    	        VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_L;
			    TES;
			END;
    		    END;

    		TES;

    	    END;

    	[RST$K_TYPE_SET, RST$K_TYPE_TPTR]:
    	    VMSDESC[DSC$B_DTYPE] = DSC$K_DTYPE_L;

    	[RST$K_TYPE_RFA]:
    	    VMSDESC[DSC$B_CLASS] = 0;

    	[OTHERWISE]:
    	    $DBG_ERROR('DBGCVTDX\COVER_VMSDESC_SETUP');
	TES;

    RETURN .VMSDESC;
    END;

GLOBAL ROUTINE DBG$CVT_DX_DX (SOURCE, DESTINATION, OUTLEN):  NOVALUE =
!
!		This is the general data type conversion facility.
!		Given two parameters, one the source descriptor,
!		second the destination descriptor this routine
!		will convert the source to destination.
!		The permitted set of class, data type and combination
!		of the two is a subset of the ones allowed in the
!		calling standard.
!
!	The following is a general description of DBG$CVT_DX_DX.
!
!       This module is divided into two routines on the bases of functional
!	modularity.  The front-end (FIND_CVT_PATH), and back-end (DBG$CVT_DX_DX).
!	The front-end converts the source into an intermediate data type, and
!	frees the back-end of any error checking of invalid classes and/or
!	data types (or combination of the two), and of decisions that require
!	knowledge of which class or data type is being converted.  The only
!	information that the back-end knows about is what the conversion path
!	is, and where the intermediate data is.  The back-end then scales the
!	intermediate data if necessary and converts it to the destination
!	data type.  Note that even though a scale may not be necessary, the
!	intermediate data is still converted to a second intermediate data type
!	just to be consistent.
!
!     1.  Upon entry to DBG$CVT_DX_DX, FIND_CVT_PATH routine is called.
!	  FIND_CVT_PATH has 4 functions, they are:
!		a. Find any errors concerning the class and data type of
!		   source and destination descriptor.  These errors can be
!		   invalid class, invalid data type, or invalid combination
!		   of a class and data type.  It can also tell which descriptors
!		   are supported by the VAX-11 calling standard and which are
!		   supported by this routine.
!
!		b. Figure out what the conversion path is, i.e. class,dtype --> class,dtype.
!		   These paths are given names such as K_SMLINT_DEC, which reads
!		   "from small integer to decimal" (categories are defined later).
!
!		c. Convert the source data to an intermediate data.  The strategy
!		   used to select the appropriate intermediate data is explained later.
!		   Precision should not be lost in converting to the intermediate type.
!
!		d. Put whatever information needed about the source and destination
!		   descriptor in two structures passed by DBG$CVT_DX_DX.
!		   These two structures SRC_INFO, and DST_INFO, contain the kind
!		   of information that can only be visible when the class, and
!		   data type of the source and destination descriptors are being
!		   manipulated. These two structures can be expanded to contain
!		   more information as new class, and data types may require it.
!
!
!     2.  The following is an overview of the design of FIND_CVT_PATH:
!	  The problem to be solved is to recognize "valid" descriptors.
!	  A descriptor is valid if the CLASS and DATA TYPE fields of the 
!	  descriptor satisfy certain conditions.
!	  With this problem in mind we shall use some formal language theory
!	  and applications to solve it.
!	  Let us take a hypothetical problem that is very close but smaller in
!	  magnitude of the original problem and solve it.
!	  Suppose that the set of classes that we are interested in are
!	  CLASS = { c1, c2, c3 }, and the set of data types are
!	  DTYPE = { d1, d2, d3, d4 }.  Then suppose that only a certain combinations
!	  of CLASS and DTYPE are valid, and they are c1d3, c2d1, c3d2, c3d4.
!	  Hence language L(G) is consisted of sentences { c1d3, c2d1, c3d2, c3d4 }.
!	  First we need to come up with a grammar for the language L(G).
!	  Grammar for L(G) :
!		Z  -->  <S1>d3 | <S2>d1 | <S3>d2 | <S3>d4
!		S1 -->  c1
!		S2 -->  c2
!		S3 -->  c3
!		S4 -->  c4
!	  A close look shows that this is a Chomsky type 3 regular grammar,
!	  because productions are all
!		NON-TERMINAL --> terminal
!			or
!		NON_TERMINAL --> <NON-TERMINAL>terminal
!	  This type of grammar has the nice feature that its sentential forms
!	  can be "accepted" by a finite state machine.
!	  The sentential forms of this grammar can also be accepted by a
!	  deterministic finite automaton (DFA) because each right hand side 
!	  has a unique left hand side.
!	  A DFA can be written to recognize sentences of this grammar and to
!	  reject sentences that are not in the language.
!	  The original problem is very similar to this hypothetical one, the
!	  only difference is that the set of CLASSES and DTYPES is larger.
!	  FIND_CVT_PATH is just a DFA that accepts sentences of language L(V)
!	  when L(V) is pairs of VAX-11 DSC$K_CLASS_x DSC$K_DTYPE_y.  The 
!	  grammar for L(V) is very similar to the grammar for L(G) above.
!
!     3.  In order to achieve the conflicting goals:  fast, not large in size,
!         expandable, no loss of precision as a result of intermediate values,
!         there is a need for  a  compromise.  The strategy for categorizing
!	  the data types is based on three goals:  precision should not be lost
!	  as a result of converting to intermediate data types, data types of
!	  the same category should share similar internal representations so
!	  they can be converted to and from each other easily, and data types
!  	  that have to be converted through software should be separated from
!	  those that have associated machine instructions.  The third goal
!	  provides easy and fast conversions for those data types with
!	  associated machine instructions.
!	  The current categories were formulated by the following strategy:
!	      Divide  the  integers into two groups, small and large integers.
!	      Divide the floating numbers into two categories small and large
!	      floating. The small category will be the data types
!	      that machine instructions are available for their conversions.
!	      The large category consist of data types that there are no machine instructions for
!	      their conversions or the instructions must be emulated (LIB$EMULATE)
!	      for some VAX machines.
!	  This categorization will provide conversions that are fast and smooth.
!	  As a result we have the following :
!
!	  INTEGER	--> SMALL_INTEGER | LARGE_INTEGER
!	  FLOAT		--> SMALL_FLOAT | LARGE_FLOAT
!	  SMALL_INTEGER	--> bu | wu | b | w | l		!Intermediate L
!	  LARGE_INTEGER	--> lu | q			!Intermediate OU
!	  SMALL_FLOAT	--> f | d			!Intermediate D
!	  LARGE_FLOAT	--> g | h			!Intermediate H
!	  DEC		--> nu | nl | nlo | nr | nro | nz !Intermediate P
!	  NBDS          --> nbds			!Intermediate T
!
!     4.  Upon return from FIND_CVT_PATH, the main routine then enters a
!	  CASE statement that selects the desired conversion.  This CASE
!	  is explained in detail in the first paragraph of the statement.
!
! AUTHOR:	Farokh Morshed		01-09-1981
!
! FUNCTIONAL DESCRIPTION:
!
!	Upon entry, FIND_CVT_PATH is called to identify which conversion is to be
!	done, i.e. from which CLASS, DTYPE combination to which CLASS, DTYPE
!	combination.
!	Also, FIND_CVT_PATH will do all the work of identifying the errors such
!	as unsupported class, data type, or combinations.
!	This routine is just a tree of CASE statements, where the outermost
!	level CASE statement labels have been determined by the FIND_CVT_PATH
!	routine.
!
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = DBG$CVT_DX_DX ( SOURCE.rx.dx, DESTINATION.wx.dx
!					   <OUTLEN.wwu.r> <CVT_ROUND_FLAG>)
!
! FORMAL PARAMETERS:
!
!	SOURCE			Address of source descriptor.
!	DESTINATION		Address of destination descriptor.
!	OUTLEN			Output length.  Optional parameter for this
!				routine to put the length of actual data (without padding) in.
!				This is used only when destination is of data
!				type T.
!	CVT_ROUND_FLAG		A flag set to true to indicate the conversion
!				result is rounded.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! SIDE EFFECTS
!	Every routine in this module turns on every arithmetic trap in PSW.
!	Caller must have LIB$EMULATE as handler if any G or H conversions are
!	asked for.
!
    BEGIN

    LOCAL
    	CVT_ROUND_FLAG,
	SRC_INFO:  BLOCK [K_SRC_INFO_LENGTH, BYTE] FIELD (SRC_INFO_FIELDS),  	! Source information structure.
	DST_INFO:  BLOCK [K_DST_INFO_LENGTH, BYTE] FIELD (DST_INFO_FIELDS),	! Destination information structure.
	OUTPUT_BUFFER:  BLOCK[K_OUTPUT_BUFFER_LENGTH, BYTE],
	OUTPUT,
	DESTINATION_PTR,							! Ptr to destination
	INTMED_DATA:  BLOCK [K_INTMED_DATA_LENGTH, BYTE],			! Intermediate data buffer.
	TEMP_BUF1:  BLOCK [K_TEMP_BUF_LENGTH, BYTE],				! Holds temporary data.
	TEMP_BUF2:  BLOCK [K_TEMP_BUF_LENGTH, BYTE],				! Holds temporary data.
	CLASS_S_DESC:  BLOCK [8, BYTE],						! A class S descriptor for any use.
	CLASS_SOURCE:  BYTE,							! Class of source VMS descriptor.
	CLASS_TARGET:  BYTE,							! Class of target VMS descriptor.
	FINAL_LEN,								! Length of data in TEMP_BUF2.
	CVT_PATH,								! Calculated convert path.
	NO_DIGITS,								! Number of digits in decimal number.
	DIGITS_IN_FRACT,							! Fractional digits (OTS$CVT_X_TE).
        FLOAT_SCALE,                                                            ! Scale of a Floating number.
        SIGN,                                                                   ! Sign of the Floating number.
	STATUS,									! Return status.
	LRGST_P_LU,								! Largest LU in a packed decimal.
	LRGST_D_LU,								! Largest LU in a double floating.
	PACK_ZERO,								! A zero in a packed decimal.
	LRGST_H_LU,								! Largest LU in a H floating.
	BUF_OFFSET,								! Offset to actual data in TEMP_BUF1 or 2.
	NEXT_BLANK,								! Location of next blank in output buffer.
	OUTPUT_STR_LEN,								! Length of actual string that has been written
	SRC_POS,								! Bit offset in source.
	DST_POS,								! Bit offset in destination.
										! to destination (optional parameter).
    	BIN_SCALE,
	SCALE;									! Effective scale (source scale - dest. scale).

    MAP
	OUTPUT:  REF BLOCK[, BYTE],
	DESTINATION_PTR: REF BLOCK[, BYTE],
	SOURCE:  REF BLOCK[,BYTE],						! Source VMS descriptor.
	DESTINATION:  REF BLOCK[,BYTE];						! Destination VMS descriptor.

    BUILTIN
    	ACTUALPARAMETER,
	ACTUALCOUNT;


    ! Establish CVT_HANDLER as handler.
    !
    ENABLE
	CVT_HANDLER;


    ! These literals are used a few lines down to test whether we
    ! are doing a conversion from decimal string or packed.
    !
    LITERAL
    	MIN_DEC_DTYPE = DSC$K_DTYPE_NU,	! 15
    	MAX_DEC_DTYPE = DSC$K_DTYPE_P;	! 21

    !++
    !  If the destination or source is Absolute Date Time cut it off here 
    !  and do the conversion.
    !--
    IF (.DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_ADT)  OR			!					A003
       (.SOURCE [DSC$B_DTYPE] EQL DSC$K_DTYPE_ADT)				!					A003
    THEN									!					A003
	IF (.DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)  AND			! ADT to text				A003
	   (.SOURCE [DSC$B_DTYPE] EQL DSC$K_DTYPE_ADT)				!					A003
	THEN									!					A003
	    BEGIN								!					A003
	    LOCAL								!					A003
		TEMP;								!					A003
	    CLASS_S_DESC[dsc$b_class]   = dsc$k_class_s;			! Build the string descriptor		A003
	    CLASS_S_DESC[dsc$b_dtype]   = dsc$k_dtype_t;			!					A003
	    CLASS_S_DESC[dsc$w_length]  = 23;					!					A003
	    CLASS_S_DESC[dsc$a_pointer] = .DESTINATION [DSC$A_POINTER];		!					A003
	    IF NOT (SYS$ASCTIM (TEMP, CLASS_S_DESC, .SOURCE [DSC$A_POINTER], 0))!					A003
	    THEN
		SIGNAL( DBG$_DELTIMTOO );
	    OUTPUT_STR_LEN = .TEMP;						!					A003
	    END									!					A003
	ELSE									!					A003
	    IF (.DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_ADT)  AND		! Text to ADT				A003
	       (.SOURCE [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)			!					A003
	    THEN								!					A003
		BEGIN								!					A003
		CLASS_S_DESC[dsc$b_class]   = dsc$k_class_s;			! Build the string descriptor		A003
		CLASS_S_DESC[dsc$b_dtype]   = dsc$k_dtype_t;			!					A003
		CLASS_S_DESC [DSC$W_LENGTH] = .SOURCE [DSC$W_LENGTH];		!					A003
		CLASS_S_DESC [DSC$A_POINTER] = .SOURCE [DSC$A_POINTER];		!					A003
		IF NOT (SYS$BINTIM( CLASS_S_DESC, .DESTINATION [DSC$A_POINTER]))!					A003
		THEN								!					A003
		    SIGNAL( DBG$_ABSDATSYN );					! He didn't like to text format		A003
		END								!					A003
	    ELSE								!					A003
		SIGNAL( DBG$_ILLTYPE )						! Nothing but ADT to text or Text to ADT allowed
    ELSE									!					A003
    BEGIN									!					A003
    ! Get the conversion rounding flag.  TRUE = round.  
    !
    IF ACTUALCOUNT() GTR 3
    THEN
    	CVT_ROUND_FLAG = ACTUALPARAMETER(4)
    ELSE
    	CVT_ROUND_FLAG = FALSE;


    ! Strip the non-significant zeros for packed decimal.
    !
    IF .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_P AND
       .DESTINATION[DSC$B_DTYPE] NEQ DSC$K_DTYPE_T
    THEN
        SOURCE = DBG$STRIP_ZEROES(.SOURCE);


    ! This flag is so that a special error can
    ! be signalled for reserved operand during a decimal string conversion.
    ! Note that this test relies on the fact that the dtypes for the 
    ! decimal string data types are cover the range from the MIN_DEC_DTYPE
    ! code to the MAX_DEC_DTYPE code.
    !
    DECIMAL_CONVERT = 
       (.SOURCE[DSC$B_DTYPE] GEQ MIN_DEC_DTYPE) AND
       (.SOURCE[DSC$B_DTYPE] LEQ MAX_DEC_DTYPE);


    ! DESTINATION_PTR is used to indicate the destination
    ! of the converted data.  If the data type is unaligned, then
    ! the output-buffer pointer points to a temporary buffer.  Else,
    ! the output-buffer pointer points to the caller's buffer.
    !
    IF .DESTINATION[DSC$B_CLASS] EQL DSC$K_CLASS_UBS
    THEN
	BEGIN
	OUTPUT = OUTPUT_BUFFER;
    	DESTINATION_PTR = .DESTINATION[DSC$A_POINTER];
	END
    ELSE
	OUTPUT = .DESTINATION[DSC$A_POINTER];


    ! Zero and blank out these records for FIND_CVT_PATH.
    !
    CH$FILL (0, K_SRC_INFO_LENGTH, SRC_INFO);
    CH$FILL (0, K_DST_INFO_LENGTH, DST_INFO);
    CH$FILL (0, K_INTMED_DATA_LENGTH, INTMED_DATA);
    CH$FILL (%C' ', K_TEMP_BUF_LENGTH, TEMP_BUF1);
    CH$FILL (%C' ', K_TEMP_BUF_LENGTH, TEMP_BUF2);
    OUTPUT_STR_LEN = 0;


    ! This descriptor is always class S, dtype T.
    ! It is used on various occasions to call routines that require 
    ! descriptors as their parameters.
    !
    CLASS_S_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    CLASS_S_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;


    ! Initialize some constants.
    !
    LRGST_P_LU = UPLIT (%P'+4294967295');
    LRGST_D_LU = UPLIT (%D'+4294967295');
    LRGST_H_LU = UPLIT (%H'+4294967295');
    PACK_ZERO = UPLIT (%P'+0');


    ! SRC_INFO structure will contain the information about the source data.  In
    ! most cases it will point to the INTMED_DATA buffer because the source data is
    ! usually converted to an intermediate, so before calling FIND_CVT_PATH we
    ! set up the pointer and length fields of SRC_INFO to be INTMED_DATA.
    !
    SRC_INFO [S_POINTER] = INTMED_DATA;
    SRC_INFO [S_LEN] = K_INTMED_DATA_LENGTH;


    ! Call FIND_CVT_PATH to get information on the source and destination
    ! (SRC_INFO and DST_INFO), and to determine the conversion path
    ! (CVT_PATH).
    !
    STATUS = FIND_CVT_PATH (.SOURCE, .DESTINATION, SRC_INFO, DST_INFO, CVT_PATH);


    ! If we got an error returned to us by FIND_CVT_PATH, it means that one of the
    ! descriptors - SOURCE or DESTINATION - was invalid to this routine.
    ! Errors are represented as negative values.  They are listed in the completion 
    ! status section of FIND_CVT_PATH.  Although we get a variety of errors, 
    ! from -1 to -7, overlapping can occur.
    !
    IF .STATUS LSS 0
    THEN
	BEGIN
	CASE .STATUS FROM K_INVNBDS TO K_UNSCLAROU OF
	    SET
	    [K_UNSDTYSTA, K_UNSDTYROU]:  $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  invalid dtype in descriptor');
	    [K_UNSCLASTA, K_UNSCLAROU]:  $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  invalid class in descriptor');
	    [K_UNSDESSTA, K_UNSDESROU]:  $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  invalid class-dtype combination');
	    [K_INVNBDS]:                 $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  invalid numeric byte string data');
	    TES;
	END;


    ! Enable all arithmetic traps, and figure out the scale fator to be used by
    ! the main CASE statement below. The scale factor in SCALE will be a decimal
    ! scale factor. The scale factor in BIN_SCALE will be a binary scale factor.
    !
    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
    SCALE = (IF .SRC_INFO[S_BIN_SCALE] THEN 0 ELSE .SRC_INFO [S_SCALE]) -
    	    (IF .DST_INFO[D_BIN_SCALE] THEN 0 ELSE .DST_INFO [D_SCALE]);
    BIN_SCALE = (IF .SRC_INFO[S_BIN_SCALE] THEN .SRC_INFO [S_SCALE] ELSE 0) -
    	        (IF .DST_INFO[D_BIN_SCALE] THEN .DST_INFO [D_SCALE] ELSE 0);


    ! We now have SRC_INFO, DST_INFO, and CVT_PATH, and the source data
    ! has been converted to an intermediate type.  Next step:  to go from
    ! the intermediate form to a scaled version to the actual data type
    ! called for by the destinaton descriptor.
    !
    ! The following explains the objective of the conversions:
    !
    !		The objective is to convert from intermediate data type provided by
    !		FIND_CVT_PATH routine to the data type that the user has requested in
    !		the destination descriptor.
    !
    !		The intermediate data is in INTMED_DATA, except for when source is
    !		of data type T.  FIND_CVT_PATH does not convert or transform the T
    !		data types, so the intermediate data for this data type is described
    !		by the SOURCE descriptor itself.
    !
    !		The first step is to scale the intermediate data.  The scale is
    !		calculated as:    SCALE = (source scale) - (destination scale).
    !		Scaling cannot always be done on the intermediate data because there
    !		may be under/over flow, so scaling is done on either the intermediate
    !		or the higest data type of the category that the destination data type
    !		falls in.  The data type with greater range is always selected.
    !		Caution is taken not to select a scaling intermediate
    !		data type that requires G, H, or O instructions, unless source or
    !		destination is of these types.
    !		At the beginning of each sub-case statement, there is a macro;
    !		each macro is type specific, and scales the intermediate data type
    !		involved in that sub-case.
    !		Regardless of whether there is scaling involved or not the intermediate
    !		data type is converted to scaling intermediate data type.
    !		The scaled intermediate data will again end up in INTMED_DATA buffer.
    !
    !		Macros that do this scaling are called M_SCALE_x_y:  convert x to y, where
    !		the result value in y is scaled according to the scale specified
    !		in source and destination descriptors.
    !
    !		The next step is to convert the scaled intermediate data to destination
    !		data type and move it to where the destination address points to.
    !		This is done as close to a 'interrupt proof' manner as possible.
    !		Since only NBDS can be of semantics other than fixed, only in case of
    !		NBDS (or just text) is the destination copied via a RTL call (LIB$SCOPY_x).
    !
    !		PSW is masked such that IV, FU, DV bits are set.
    !
    CASE .CVT_PATH FROM K_SMLINT_SMLINT TO K_NBDS_NBDS OF
	SET


	[K_SMLINT_SMLINT]:
	    BEGIN
	    M_SCALE_L_L;
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_V TO DSC$K_DTYPE_SVU OF
		SET

		[DSC$K_DTYPE_BU]:
		    BEGIN
		    IF (OUTPUT [BYTE_1] = .INTMED_DATA [LONG_1]) GTRU K_LRGST_BU 
			THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    END;

		[DSC$K_DTYPE_WU]:
		    BEGIN
		    IF (OUTPUT [WORD_1] = .INTMED_DATA [S_LONG_1]) GTRU K_LRGST_WU
			THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    END;

		[DSC$K_DTYPE_B]:
		    CVTLB (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_W]:
		    CVTLW (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_L]:
		    OUTPUT [LONG_1] = .INTMED_DATA [S_LONG_1];

		[DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
		    BEGIN
		    MAP
			OUTPUT:  REF BITVECTOR[K_OUTPUT_BUFFER_LENGTH * 8],
		 	INTMED_DATA:  BITVECTOR[K_INTMED_DATA_LENGTH * 8];

		    INCR I FROM 0 TO .DST_INFO[D_LEN]-1 DO
			BEGIN
			OUTPUT[.I] = .INTMED_DATA[.I];
			END;
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlint_smlint');
		TES;				!For SMLINT_SMLINT
	    END;


	[K_SMLINT_LRGINT, K_LRGINT_LRGINT]:
	    BEGIN
	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_LRGINT]:
		    BEGIN
		    M_SCALE_L_OU;
		    END;

		[K_LRGINT_LRGINT]:
		    BEGIN
		    M_SCALE_OU_OU;
		    END;
		TES;

	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_LU]:
		    BEGIN
		    IF (.INTMED_DATA [LONG_2] OR .INTMED_DATA [LONG_3] OR .INTMED_DATA [LONG_4]) NEQ 0
		    	THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [LONG_1] = .INTMED_DATA [LONG_1];
		    IF .SRC_INFO[S_SIGN]
		    THEN
			OUTPUT[LONG_1] = -.OUTPUT[S_LONG_1];
		    END;

		[DSC$K_DTYPE_Q, DSC$K_DTYPE_QU]:
		    BEGIN
		    IF (.INTMED_DATA [LONG_3] OR .INTMED_DATA [LONG_4]) NEQ 0
		    	THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    IF .SRC_INFO [S_SIGN]
		    THEN
			IF .INTMED_DATA [LONG_1] EQL 0
			THEN
			    BEGIN
                            IF .INTMED_DATA [LONG_2] NEQU %X'80000000'
                            THEN
                                BEGIN
			        INTMED_DATA [LONG_2] = .INTMED_DATA [LONG_2] XOR %X'FFFFFFFF';
			        INTMED_DATA [LONG_2] = .INTMED_DATA [LONG_2] + 1;
                                END;
			    END
			ELSE
                            BEGIN
			    INTMED_DATA [LONG_1] = .INTMED_DATA [LONG_1] XOR %X'FFFFFFFF';
			    INTMED_DATA [LONG_2] = .INTMED_DATA [LONG_2] XOR %X'FFFFFFFF';
			    INTMED_DATA [LONG_1] = .INTMED_DATA [LONG_1] + 1;
                            END;
		    OUTPUT [LONG_1] = .INTMED_DATA [LONG_1];
		    OUTPUT [LONG_2] = .INTMED_DATA [LONG_2];
		    END;

		[DSC$K_DTYPE_O]:
		    BEGIN

    		    ! The S_SIGN field is set if we need to negate the octaword.
    		    !
		    IF .SRC_INFO[S_SIGN]
		    THEN
			BEGIN

                        ! Check for %X'80000000000000000000000000000000'
                        ! This should not go through the code below, but rather
                        ! just be deposited.
                        !
                        IF NOT (.INTMED_DATA[LONG_1] EQL 0 AND
                                .INTMED_DATA[LONG_2] EQL 0 AND
                                .INTMED_DATA[LONG_3] EQL 0 AND
                                .INTMED_DATA[LONG_4] EQL %X'80000000')
                        THEN
                            BEGIN
			    MAP
			        INTMED_DATA:  VECTOR[K_INTMED_DATA_LENGTH/4];

    			    ! Take the one's complement.
    			    !
			    INCR NEXT_LONGWORD FROM 0 TO 3 DO
			        INTMED_DATA[.NEXT_LONGWORD] = 
    				    .INTMED_DATA[.NEXT_LONGWORD] XOR %X'FFFFFFFF';

    			    ! Add 1 to the result.
    			    !
    			    INCR NEXT_LONGWORD FROM 0 TO 3 DO
    			        IF .INTMED_DATA[.NEXT_LONGWORD] EQLU %X'FFFFFFFF'
    			        THEN
    				    INTMED_DATA[.NEXT_LONGWORD] = 0
    			        ELSE
    				    BEGIN
    				    INTMED_DATA[.NEXT_LONGWORD] = 
    				        .INTMED_DATA[.NEXT_LONGWORD] + 1;
    				    EXITLOOP;
    				    END;
			    END;
                        END;

		    CH$MOVE (16, INTMED_DATA, .OUTPUT);
		    END;

		[OTHERWISE]:
	    	    SELECTONE .CVT_PATH OF
			SET
			[K_SMLINT_LRGINT]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlint_lrgint');

			[K_LRGINT_LRGINT]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgint_lrgint');
			TES;
		TES;				!For SMLINT_LRGINT, LRGINT_LRGINT.
	    END;


	[K_SMLINT_SMLFLTCMPLX, K_LRGINT_SMLFLTCMPLX, K_SMLFLTCMPLX_SMLFLTCMPLX, K_DEC_SMLFLTCMPLX, K_NBDS_SMLFLTCMPLX]:
	    BEGIN
	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_SMLFLTCMPLX]:
		    BEGIN
		    M_SCALE_L_D;
		    END;

		[K_LRGINT_SMLFLTCMPLX]:
		    BEGIN
		    M_SCALE_OU_D;
		    END;

		[K_SMLFLTCMPLX_SMLFLTCMPLX]:
		    BEGIN
		    M_SCALE_D_D;
		    END;

		[K_DEC_SMLFLTCMPLX]:
		    BEGIN
		    M_SCALE_P_D;
		    END;

		[K_NBDS_SMLFLTCMPLX]:
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_D (CLASS_S_DESC, INTMED_DATA, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
		    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);
		    END;
		TES;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
		SET

		[DSC$K_DTYPE_F]:
		    CVTDF (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_D]:
		    BEGIN
		    OUTPUT [LONG_1] = .INTMED_DATA [LONG_1];
		    OUTPUT [LONG_2] = .INTMED_DATA [LONG_2];
		    END;

		[INRANGE, OUTRANGE]:
		    CASE .DESTINATION[DSC$B_DTYPE] FROM DSC$K_DTYPE_FC TO DSC$K_DTYPE_DC OF
			SET

			[DSC$K_DTYPE_FC]:
			    BEGIN
			    CVTDF (INTMED_DATA, .OUTPUT);
			    CVTDF (INTMED_DATA+8, .OUTPUT+4);
			    END;

			[DSC$K_DTYPE_DC]:
			    CH$MOVE (16, INTMED_DATA, .OUTPUT);

			[INRANGE, OUTRANGE]:
			    SELECTONE .CVT_PATH OF
				SET
				[K_SMLINT_SMLFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlint_smlfltcmplx');
				[K_LRGINT_SMLFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgint_smlfltcmplx');
				[K_SMLFLTCMPLX_SMLFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlfltcmplx_smlfltcmplx');
				[K_DEC_SMLFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  dec_smlfltcmplx');
				[K_NBDS_SMLFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  nbds_smlfltcmplx');
				TES;
			TES;
		TES;				!For SMLINT_SMLFLTCMPLX, LRGINT_SMLFLTCMPLX, SMLFLTCMPLX_SMLFLTCMPLX, DEC_SMLFLTCMPLX, NBDS_SMLFLTCMPLX.

	    IF .SRC_INFO [S_SIGN] THEN OUTPUT [0, 15, 1, 0] = 1;
	    END;


	[K_SMLINT_LRGFLTCMPLX, K_LRGINT_LRGFLTCMPLX, K_SMLFLTCMPLX_LRGFLTCMPLX, K_LRGFLTCMPLX_LRGFLTCMPLX, K_DEC_LRGFLTCMPLX]:
	    BEGIN
	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_LRGFLTCMPLX]:
		    BEGIN
		    M_SCALE_L_H;
		    END;

		[K_LRGINT_LRGFLTCMPLX]:
		    BEGIN
		    M_SCALE_OU_H;
		    END;

		[K_SMLFLTCMPLX_LRGFLTCMPLX]:
		    BEGIN
		    M_SCALE_D_H;
		    END;

		[K_LRGFLTCMPLX_LRGFLTCMPLX]:
		    BEGIN
		    IF .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_G OR
		       .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_GC
		    THEN
			M_SCALE_G_H
		    ELSE
		     	M_SCALE_H_H;
		    END;

		[K_DEC_LRGFLTCMPLX]:
		    BEGIN
		    M_SCALE_P_H;
		    END;
		TES;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
		SET

		[DSC$K_DTYPE_G]:
		    CVTHG (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_H]:
		    CH$MOVE (16, INTMED_DATA, .OUTPUT);

		[INRANGE, OUTRANGE]:
		    CASE .DESTINATION[DSC$B_DTYPE] FROM DSC$K_DTYPE_GC TO DSC$K_DTYPE_HC OF
			SET

			[DSC$K_DTYPE_GC]:
			    BEGIN
			    CVTHG (INTMED_DATA, .OUTPUT);
			    CVTHG (INTMED_DATA+16, .OUTPUT+8);
			    END;

			[DSC$K_DTYPE_HC]:
			    CH$MOVE (32, INTMED_DATA, .OUTPUT);

			[INRANGE, OUTRANGE]:
			    SELECTONE .CVT_PATH OF
				SET
				[K_SMLINT_LRGFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlint_lrgfltcmplx');
				[K_LRGINT_LRGFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgint_lrgfltcmplx');
				[K_SMLFLTCMPLX_LRGFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlfltcmplx_lrgfltcmplx');
				[K_LRGFLTCMPLX_LRGFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgfltcmplx_lrgfltcmplx');
				[K_DEC_LRGFLTCMPLX]:
				    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  dec_lrgfltcmplx');
				TES;
			TES;
		TES;		!For SMLINT_LRGFLTCMPLX, LRGINT_LRGFLTCMPLX, SMLFLTCMPLX_LRGFLTCMPLX, LRGFLTCMPLX_LRGFLTCMPLX, DEC_LRGFLTCMPLX.

	    IF .SRC_INFO [S_SIGN] THEN OUTPUT [0, 15, 1, 0] = 1;
	    END;


	[K_SMLINT_DEC, K_DEC_DEC]:
	    BEGIN
	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_DEC]:
		    BEGIN
		    M_SCALE_L_P;
		    END;

		[K_DEC_DEC]:
		    BEGIN
		    M_SCALE_P_P;
		    END;
		TES;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_NU TO DSC$K_DTYPE_P OF
		SET

		[DSC$K_DTYPE_NU]:
		    BEGIN
		    IF .SRC_INFO [S_SIGN] THEN SIGNAL (DBG$_CVTNEGUNS, 1, .DBG$GL_OPCODE_NAME);
		    CVTPT (NO_DIGITS, INTMED_DATA, LIB$AB_CVTPT_U, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[DSC$K_DTYPE_NL]:
		    CVTPS (NO_DIGITS, INTMED_DATA,
			%REF (
			    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1)
		    , .OUTPUT);

		[DSC$K_DTYPE_NLO]:
		    BEGIN
		    CVTPT (NO_DIGITS, INTMED_DATA, LIB$AB_CVTPT_U, DESTINATION [DSC$W_LENGTH], TEMP_BUF1);
		    TEMP_BUF1 [BYTE_1] = (IF .SRC_INFO [S_SIGN] THEN .(.TEMP_BUF1 [BYTE_1] + LIB$AB_CVT_U_O -
			48 + 10) ELSE .(.TEMP_BUF1 [BYTE_1] + LIB$AB_CVT_U_O - 48));
		    CH$MOVE (.DESTINATION [DSC$W_LENGTH], TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NR]:
		    BEGIN
		    LOCAL
			DES_LEN;
		    DES_LEN =
		    BEGIN
		    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1
		    END;
		    CVTPS (NO_DIGITS, INTMED_DATA, DES_LEN, TEMP_BUF1);
		    BLOCK [INTMED_DATA + .DES_LEN, 0, 0, 8, 0;, BYTE] = .TEMP_BUF1 [BYTE_1];
		    CH$MOVE (.DES_LEN, TEMP_BUF1 + 1, INTMED_DATA);
		    CH$MOVE (.DES_LEN + 1, INTMED_DATA, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NRO, DSC$K_DTYPE_NZ]:
		    CVTPT (NO_DIGITS, INTMED_DATA,
			(IF .DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_NRO THEN LIB$AB_CVTPT_O ELSE
			    LIB$AB_CVTPT_Z), DESTINATION [DSC$W_LENGTH], .OUTPUT);

		[DSC$K_DTYPE_P]:
		    BEGIN
!		    CVTPS (NO_DIGITS, INTMED_DATA, DESTINATION [DSC$W_LENGTH], TEMP_BUF1);
!		    CVTSP (DESTINATION [DSC$W_LENGTH], TEMP_BUF1, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
		    CVTSP (NO_DIGITS, TEMP_BUF1, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[INRANGE, OUTRANGE]:
		    SELECTONE .CVT_PATH OF
			SET
			[K_SMLINT_DEC]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlint_dec');
			[K_DEC_DEC]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  dec_dec');
			TES;
		TES;				!For SMLINT_DEC, DEC_DEC
	    END;


	[K_LRGINT_SMLINT]:
	    BEGIN
	    M_SCALE_OU_OU;
	    IF (.INTMED_DATA [LONG_2] OR .INTMED_DATA [LONG_3] OR .INTMED_DATA [LONG_4]) NEQ 0
	    THEN
		SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_V TO DSC$K_DTYPE_SVU OF
		SET

		[DSC$K_DTYPE_BU]:
		    BEGIN
		    IF .INTMED_DATA [BYTE_2] OR .INTMED_DATA [WORD_2] NEQ 0 
			THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [BYTE_1] = .INTMED_DATA [LONG_1];
		    END;

		[DSC$K_DTYPE_WU]:
		    BEGIN
		    IF .INTMED_DATA [WORD_2] NEQ 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [WORD_1] = .INTMED_DATA [LONG_1];
		    END;

		[DSC$K_DTYPE_B]:
		    BEGIN
		    IF .INTMED_DATA [S_LONG_1] LSS 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    IF .SRC_INFO [S_SIGN] THEN INTMED_DATA [LONG_1] = -.INTMED_DATA [S_LONG_1];
		    CVTLB (INTMED_DATA, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W]:
		    BEGIN
		    IF .INTMED_DATA [S_LONG_1] LSS 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    IF .SRC_INFO [S_SIGN] THEN INTMED_DATA [LONG_1] = -.INTMED_DATA [S_LONG_1];
		    CVTLW (INTMED_DATA, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L]:
		    BEGIN
		    IF .INTMED_DATA [S_LONG_1] EQL K_LRGST_NEG_L AND .SRC_INFO [S_SIGN] EQL 1
		    THEN
			OUTPUT [LONG_1] = .INTMED_DATA [S_LONG_1]
		    ELSE
			BEGIN
			IF .INTMED_DATA [S_LONG_1] LSS 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
			IF .SRC_INFO [S_SIGN] THEN INTMED_DATA [LONG_1] = -.INTMED_DATA [S_LONG_1];
			OUTPUT [LONG_1] = .INTMED_DATA [S_LONG_1];
			END;
		    END;

		[DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
		    BEGIN
		    MAP
			OUTPUT:  REF BITVECTOR[K_OUTPUT_BUFFER_LENGTH * 8],
		 	INTMED_DATA:  BITVECTOR[K_INTMED_DATA_LENGTH * 8];

		    INCR I FROM 0 TO .DST_INFO[D_LEN] - 1 DO
			BEGIN
			OUTPUT[.I] = .INTMED_DATA[.I];
			END;
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgint_smlint');
		TES;				!For LRGINT_SMLINT
	    END;


	[K_LRGINT_DEC, K_SMLFLTCMPLX_DEC, K_LRGFLTCMPLX_DEC, K_NBDS_DEC]:
	    BEGIN
	    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
	    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
	    SELECTONE .CVT_PATH OF
		SET

		[K_LRGINT_DEC]:
		    BEGIN
		    CVTROUH (INTMED_DATA, TEMP_BUF1);
		    IF .SRC_INFO [S_SIGN] THEN TEMP_BUF1<15, 1, 0> = 1;
		    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, 0, .SCALE, 0, 0, 1);
		    END;

		[K_SMLFLTCMPLX_DEC]:
		    BEGIN
		    IF .INTMED_DATA<15, 1, 0> THEN SRC_INFO [S_SIGN] = 1;
		    STATUS = FOR$CVT_D_TF (INTMED_DATA, CLASS_S_DESC, 0, .SCALE, 0, 0, 1);
		    END;

		[K_LRGFLTCMPLX_DEC]:
		    BEGIN
		    IF .INTMED_DATA<15, 1, 0> THEN SRC_INFO [S_SIGN] = 1;
		    IF .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_G OR
		       .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_GC
		    THEN
		    	STATUS = FOR$CVT_G_TF (INTMED_DATA, CLASS_S_DESC, 0, .SCALE, 0, 0, 1)
		    ELSE
		    	STATUS = FOR$CVT_H_TF (INTMED_DATA, CLASS_S_DESC, 0, .SCALE, 0, 0, 1);
		    END;

		[K_NBDS_DEC]:
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
		    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);
		    IF .TEMP_BUF1<15, 1, 0> THEN SRC_INFO [S_SIGN] = 1;
		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, 0, 0, 0, 0, 1);
		    END;
		TES;

	    IF NOT .STATUS THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
	    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
	    NO_DIGITS = K_TEMP_BUF_LENGTH - .BUF_OFFSET - 2;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_NU TO DSC$K_DTYPE_P OF
		SET

		[DSC$K_DTYPE_NU]:
		    BEGIN
		    IF .SRC_INFO [S_SIGN] THEN SIGNAL (DBG$_CVTNEGUNS, 1, .DBG$GL_OPCODE_NAME);
		    IF .NO_DIGITS GTR .DESTINATION [DSC$W_LENGTH] THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
		    CH$FILL (%X'30', .DESTINATION [DSC$W_LENGTH] - .NO_DIGITS, TEMP_BUF1);
		    CH$MOVE (.NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET + 1,
			TEMP_BUF1 + .DESTINATION [DSC$W_LENGTH] - .NO_DIGITS);
		    CH$MOVE (.DESTINATION [DSC$W_LENGTH], TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NL]:
		    BEGIN
		    LOCAL
			DES_LEN;
		    DES_LEN =
		    BEGIN
		    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1
		    END;
		    IF .DES_LEN LSS .NO_DIGITS THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
		    CVTSP (NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET, DES_LEN, TEMP_BUF1);
		    CVTPS (DES_LEN, TEMP_BUF1, DES_LEN, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NLO]:
		    BEGIN
		    CH$FILL (%X'30', .BUF_OFFSET + 1, TEMP_BUF2);
		    IF .NO_DIGITS GTR .DESTINATION [DSC$W_LENGTH] THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
		    BUF_OFFSET = K_TEMP_BUF_LENGTH - .DESTINATION [DSC$W_LENGTH] - 1;
		    BLOCK [TEMP_BUF2 + .BUF_OFFSET, 0, 0, 8, 0;, BYTE] = (IF .SRC_INFO [S_SIGN] THEN .(.BLOCK
			[TEMP_BUF2 + .BUF_OFFSET, 0, 0, 8, 0;, BYTE] + LIB$AB_CVT_U_O - 48 + 10) ELSE .(
			.BLOCK [TEMP_BUF2 + .BUF_OFFSET, 0, 0, 8, 0;, BYTE] + LIB$AB_CVT_U_O - 48));
		    CH$MOVE (.DESTINATION [DSC$W_LENGTH], TEMP_BUF2 + .BUF_OFFSET, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NR]:
		    BEGIN
		    LOCAL
			DES_LEN;
		    DES_LEN =
		    BEGIN
		    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1
		    END;
		    IF .NO_DIGITS GTR .DES_LEN THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
		    CH$FILL (%X'30', .DES_LEN - .NO_DIGITS + 1, TEMP_BUF1);
		    CH$MOVE (.NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET + 1, TEMP_BUF1 + .DES_LEN - .NO_DIGITS);
		    BLOCK [TEMP_BUF1 + .DES_LEN, 0, 0, 8, 0;, BYTE] = .BLOCK [TEMP_BUF2 + .BUF_OFFSET, 0,
			0, 8, 0;, BYTE];
		    CH$MOVE (.DES_LEN + 1, TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NRO, DSC$K_DTYPE_NZ]:
		    BEGIN
		    IF .NO_DIGITS GTR .DESTINATION [DSC$W_LENGTH] THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
		    CVTSP (NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET, DESTINATION [DSC$W_LENGTH], TEMP_BUF1);
		    CVTPT (DESTINATION [DSC$W_LENGTH], TEMP_BUF1,
			(IF .DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_NRO THEN LIB$AB_CVTPT_O ELSE
			    LIB$AB_CVTPT_Z), DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[DSC$K_DTYPE_P]:
		    BEGIN
		    IF .NO_DIGITS GTR 31 THEN SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
		    CVTSP (NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[INRANGE, OUTRANGE]:
		    SELECTONE .CVT_PATH OF
			SET
			[K_LRGINT_DEC]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgint_dec');
			[K_SMLFLTCMPLX_DEC]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlfltcmplx_dec');
			[K_LRGFLTCMPLX_DEC]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgfltcmplx_dec');
			[K_NBDS_DEC]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  nbds_dec');
			TES;
		TES;				!For LRGINT_DEC, SMLFLTCMPLX_DEC, LRGFLTCMPLX_DEC, NBDS_DEC.
	    END;


	[K_SMLINT_NBDS, K_LRGINT_NBDS, K_DEC_NBDS]:
	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT, DSC$K_DTYPE_AC, DSC$K_DTYPE_AZ]:
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;

    		    ! Compute 'DIGITS_IN_FRACT' based on scale. 
    		    ! For negative scales, the number of digits in the fraction
    		    ! is just the absolute value of the scale. This seems
    		    ! to work for both binary and decimal scales. For example,
    		    ! (binary 101 with scale factor -2) = binary 1.01 =
    		    ! 1 + 0/2 + 1/4 = 1.25, which has 2 digits in the fraction.
    		    ! For non-negative scale, DIGITS_IN_FRACT is zero.
    		    ! First do a consistency check to ensure we do not have
    		    ! both decimal and binary scale factors - if we do, 
    		    ! something is wrong.
    		    !
    		    DIGITS_IN_FRACT = 0;
    		    IF (.BIN_SCALE NEQ 0) AND (.SCALE NEQ 0)
    		    THEN
    			$DBG_ERROR('DBGCVTDX\DBG$CVT_DX_DX inconsistent scale factors');
    		    IF .BIN_SCALE LSS 0
    		    THEN
    			DIGITS_IN_FRACT = -.BIN_SCALE;
		    IF .SCALE LSS 0 
    		    THEN 
    			DIGITS_IN_FRACT = -.SCALE;
    		    
		    SELECTONE .CVT_PATH OF
			SET

			[K_SMLINT_NBDS]:
			    BEGIN
			    CVTLD (INTMED_DATA, TEMP_BUF1);

	    		    ! Take care of binary scale factors by doing
    			    ! the divide or multiply.
    			    !
    			    WHILE .BIN_SCALE LSS 0 DO
    			 	BEGIN
    				DIVD2(UPLIT (%D'2.0'), TEMP_BUF1);
    			 	BIN_SCALE = .BIN_SCALE + 1;
    				END;
    			    WHILE .BIN_SCALE GTR 0 DO
    				BEGIN
    				MULD2(UPLIT (%D'2.0'), TEMP_BUF1);
    				BIN_SCALE = .BIN_SCALE - 1;
    				END;

			    STATUS = FOR$CVT_D_TF (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE);
			    END;

			[K_LRGINT_NBDS]:
			    IF .SOURCE[ DSC$B_DTYPE ] NEQ DSC$K_DTYPE_O			! A004
			    THEN							! A004
				BEGIN
		    	    	CVTROUH (INTMED_DATA, TEMP_BUF1);
		    	    	IF .SRC_INFO [S_SIGN] THEN TEMP_BUF1<15, 1, 0> = 1;


    			        ! Take care of binary scale factors by doing
    			        ! the divide or multiply.
    			        !
    			        WHILE .BIN_SCALE LSS 0 DO
    			 	    BEGIN
    				    DIVH2(UPLIT (%H'2.0'), TEMP_BUF1);
    			 	    BIN_SCALE = .BIN_SCALE + 1;
    				    END;
    			        WHILE .BIN_SCALE GTR 0 DO
    				    BEGIN
    			  	    MULH2(UPLIT (%H'2.0'), TEMP_BUF1);
    				    BIN_SCALE = .BIN_SCALE - 1;
    				    END;

		    	    	STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE);
			    	END
			    ELSE							! A004
			    	BEGIN							! A004
				LOCAL							! A004
				    Previous_Value : VECTOR[4];				! A004

			    	MAP							! A004
				    INTMED_DATA : VECTOR[4];				! A004

    				! Don't support scale factor on octaword.
    				!
    				IF .BIN_SCALE NEQ 0
    				THEN
    				    $DBG_ERROR('DBGCVTDX\DBG$CVT_DX_DX scale factor on octaword not supported');

		    		CLASS_S_DESC[ DSC$W_LENGTH ] = 0;			! A004  

				!++
			    	! Init the Previous value
			    	!--
			    	CH$MOVE( 16, 						! A004
					 CH$PTR( INTMED_DATA),				! A004
					 CH$PTR( Previous_value ) );			! A004

			    	!++						
				! By dividing the value by ten and multiplying it by
				!    ten the original value and the new value may be
				!    subtracted to obtain the value of the least
				!    significant digit.				
				! Repeating allows the building up of the string
				!    from the back.				
			    	!--						
			    	DO							! A004
				    BEGIN						! A004
			    	    LOCAL						! A004
				    	Saved_Value : VECTOR[4];			! A004

				    !++
			    	    ! Save the previous value
			    	    !--
			    	    CH$MOVE( 16, 					! A004
					     CH$PTR( INTMED_DATA),			! A004
					     CH$PTR( Previous_value ) );		! A004

				    !++
				    ! Divide by ten
				    !--
				    DBG$CVT_SCALE_OU_DOWN_BY_10_R1( INTMED_DATA );	! A004

				    !++
				    ! Save the divided value for the next time
				    !--
				    CH$MOVE( 16, 					! A004
					     CH$PTR( INTMED_DATA),			! A004
					     CH$PTR( Saved_value ) );			! A004

				    !++
				    ! Multiply by ten to remove for the subtraction
				    !--
				    DBG$CVT_SCALE_OU_UP_BY_10_R1( INTMED_DATA );	! A004

				    !++
				    ! Move the previous digits down
				    !--
				    DECR Current_position FROM .CLASS_S_DESC[DSC$W_LENGTH] - 1				    ! A004
							  TO 0 DO			    				    ! A004
					CH$WCHAR( CH$RCHAR( CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER ] + .Current_position ) ), ! A004
						  CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER ] + .Current_position + 1 ) );	    ! A004

				    !++
				    ! Subtract and put the new digit in the string
				    !--
				    CH$WCHAR(.Previous_value[0]-.INTMED_DATA[0] + %C'0',  ! A004
					        CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER] ) );! A004

				    !++
				    ! Increment the length
				    !--
				    CLASS_S_DESC[ DSC$W_LENGTH ] = 			! A004
					    .CLASS_S_DESC[ DSC$W_LENGTH ] + 1;		! A004

				    !++
				    ! Saved value becomes the previous value
				    !--
				    CH$MOVE( 16, 					! A004
					     CH$PTR( Saved_value),			! A004
					     CH$PTR( INTMED_DATA ) );			! A004

				    END							! A004
			    	WHILE (.INTMED_DATA[ 3 ] NEQ 0)  OR			! A004
				      (.INTMED_DATA[ 2 ] NEQ 0)  OR			! A004
				      (.INTMED_DATA[ 1 ] NEQ 0)  OR			! A004
				      (.INTMED_DATA[ 0 ] NEQ 0);			! A004
											! A004
				!++
				! Load in a '-' if there is one
				!--
				IF .SRC_INFO[ S_SIGN ]									    ! A004
				THEN											    ! A004
				    BEGIN										    ! A004
				    DECR Current_position FROM .CLASS_S_DESC[DSC$W_LENGTH] - 1				    ! A004
							  TO 0 DO			    				    ! A004
					CH$WCHAR( CH$RCHAR( CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER ] + .Current_position ) ), ! A004
						  CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER ] + .Current_position + 1 ) );	    ! A004
				    CH$WCHAR( %C'-',									    ! A004
					      CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER] ) );				    ! A004
				    CLASS_S_DESC[ DSC$W_LENGTH ] = .CLASS_S_DESC[ DSC$W_LENGTH ] + 1;			    ! A004
				    END;										    ! A004

				!++
				! Put a '.' on the end just like CVTROUH
				!--
				CH$WCHAR(%C'.', CH$PTR( .CLASS_S_DESC[ DSC$A_POINTER] + ! A004
							.CLASS_S_DESC[ DSC$W_LENGTH ]));! A004

			        STATUS = SS$_NORMAL;					! A004
			        END;							! A004

			[K_DEC_NBDS]:
			    BEGIN

    			    ! Don't support binary scale factor on packed.
    			    !
    			    IF .BIN_SCALE NEQ 0
    			    THEN
    				$DBG_ERROR('DBGCVTDX\DBG$CVT_DX_DX binary scale factor on packed not supported');

			    NO_DIGITS = .SRC_INFO [S_LEN];
			    CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF2);
			    CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
			    OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, 0,
				(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS ));
			    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE);
			    END;
			TES;

		    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
		    NEXT_BLANK = CH$FIND_CH (K_TEMP_BUF_LENGTH-.BUF_OFFSET, TEMP_BUF2+.BUF_OFFSET, %C' ');
		    IF .NEXT_BLANK EQL 0
		    THEN
			FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET
		    ELSE
		    	FINAL_LEN = .NEXT_BLANK - .BUF_OFFSET - TEMP_BUF2;
		    IF .DIGITS_IN_FRACT EQL 0
		    THEN
			FINAL_LEN = .FINAL_LEN - 1;

		    IF NOT .STATUS
		    THEN
			BEGIN
			CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
			IF .CVT_PATH EQL K_DEC_NBDS
			THEN
			    DIGITS_IN_FRACT = 31
			ELSE
			    IF .DST_INFO [D_LEN] - 9 LEQ 0
			    THEN
			    	DIGITS_IN_FRACT = 33
			    ELSE
			    	DIGITS_IN_FRACT = MIN (33, .DST_INFO [D_LEN] - 9);
			STATUS = FOR$CVT_H_TE (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0, 4);
			IF NOT .STATUS THEN $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  error in h-to-te conversion');
			BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
			FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
			END;

		    OUTPUT_STR_LEN = .FINAL_LEN;
		    SELECTONE .DESTINATION[DSC$B_DTYPE] OF
			SET
			[DSC$K_DTYPE_AC]:
			    BEGIN
			    MAP
				OUTPUT:  REF VECTOR[, BYTE];
			    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[1];
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    OUTPUT[0] = .FINAL_LEN;
			    END;

		  	[DSC$K_DTYPE_AZ]:
			    BEGIN
			    MAP
				OUTPUT:  REF VECTOR[, BYTE];
			    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[0];
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    OUTPUT[.FINAL_LEN + 1] = 0;
			    END;

			[OTHERWISE]:
			    BEGIN
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    END;
			TES;
		    END;

		[OTHERWISE]:
		    SELECTONE .CVT_PATH OF
			SET
			[K_SMLINT_NBDS]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlint_nbds');
			[K_LRGINT_NBDS]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgint_nbds');
			[K_DEC_NBDS]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  dec_nbds');
			TES;
		TES;				!For SMLINT_NBDS, LRGINT_NBDS, DEC_NBDS



	[K_SMLFLTCMPLX_SMLINT]:
	    BEGIN
	    M_SCALE_D_D;
    	    IF .CVT_ROUND_FLAG
    	    THEN
	        CVTRDL (INTMED_DATA, TEMP_BUF1)
    	    ELSE
    		CVTDL  (INTMED_DATA, TEMP_BUF1);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_V TO DSC$K_DTYPE_SVU OF
		SET

		[DSC$K_DTYPE_BU]:
		    BEGIN
		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_BU THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [BYTE_1] = .TEMP_BUF1 [BYTE_1];
		    END;

		[DSC$K_DTYPE_WU]:
		    BEGIN
		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_WU THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [WORD_1] = .TEMP_BUF1 [WORD_1];
		    END;

		[DSC$K_DTYPE_B]:
		    BEGIN
		    CVTLB (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W]:
		    BEGIN
		    CVTLW (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L]:
		    OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1];

		[DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
		    BEGIN
		    MAP
			OUTPUT:  REF BITVECTOR[K_OUTPUT_BUFFER_LENGTH * 8],
		 	INTMED_DATA:  BITVECTOR[K_INTMED_DATA_LENGTH * 8];

		    INCR I FROM 0 TO .DST_INFO[D_LEN] - 1 DO
			BEGIN
			OUTPUT[.I] = .INTMED_DATA[.I];
			END;
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlfltcmplx_smlint');
		TES;				!For SMLFLTCMPLX_SMLINT
	    END;


	[K_SMLFLTCMPLX_LRGINT]:
	    BEGIN
	    M_SCALE_D_D;
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_O OF
		SET

		[DSC$K_DTYPE_LU]:
		    BEGIN
		    IF CMPD (INTMED_DATA, .LRGST_D_LU) GTR 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
    		    IF .CVT_ROUND_FLAG
    		    THEN
		        CVTRDL (INTMED_DATA, .OUTPUT)
    		    ELSE
    			CVTDL  (INTMED_DATA, .OUTPUT);

		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q, DSC$K_DTYPE_QU]:
		    CVTRDQ (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_O]:
		    BEGIN
		    CVTDH (INTMED_DATA, TEMP_BUF1);
		    CVTRHO (TEMP_BUF1, .OUTPUT);
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlfltcmplx_lrgint');
		TES;				!For SMLFLTCMPLX_LRGINT
	    END;


	[K_SMLFLTCMPLX_NBDS]:
	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT, DSC$K_DTYPE_AC, DSC$K_DTYPE_AZ]:
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    DIGITS_IN_FRACT =
		    BEGIN
		    CASE .SOURCE [DSC$B_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
			SET

			[DSC$K_DTYPE_F]:
			    7;

			[DSC$K_DTYPE_D]:
			    16;
			TES
		    END;
		    IF .DST_INFO [D_LEN] - 7 GTR 0
		    THEN
			DIGITS_IN_FRACT = MIN (.DIGITS_IN_FRACT,
			    .DST_INFO [D_LEN] - 7);
		    STATUS = FOR$CVT_D_TE (INTMED_DATA, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0);
		    IF NOT .STATUS THEN $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  error in d-to-te conversion');
		    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
		    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
		    OUTPUT_STR_LEN = .FINAL_LEN;

		    SELECTONE .DESTINATION[DSC$B_DTYPE] OF
			SET
			[DSC$K_DTYPE_AC]:
			    BEGIN
			    MAP
				OUTPUT:  REF VECTOR[, BYTE];
			    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[1];
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1,.DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    OUTPUT[0] = .FINAL_LEN;
			    END;

		  	[DSC$K_DTYPE_AZ]:
			    BEGIN
			    MAP
				OUTPUT:  REF VECTOR[, BYTE];
			    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[0];
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    OUTPUT[.FINAL_LEN + 1] = 0;
			    END;

			[OTHERWISE]:
			    BEGIN
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    END;
			TES;
		    END;

		[OTHERWISE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  smlfltcmplx_nbds');
		TES;				!For SMLFLTCMPLX_NBDS


	[K_LRGFLTCMPLX_SMLINT]:
	    BEGIN
	    IF .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_G OR
	       .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_GC
	    THEN
		M_SCALE_G_H
	    ELSE
	    	M_SCALE_H_H;
    	    IF .CVT_ROUND_FLAG
    	    THEN
	        CVTRHL (INTMED_DATA, TEMP_BUF1)
    	    ELSE
    		CVTHL  (INTMED_DATA, TEMP_BUF1);
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_V TO DSC$K_DTYPE_SVU OF
		SET

		[DSC$K_DTYPE_BU]:
		    BEGIN
		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_BU THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [BYTE_1] = .TEMP_BUF1 [BYTE_1];
		    END;

		[DSC$K_DTYPE_WU]:
		    BEGIN
		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_WU THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [WORD_1] = .TEMP_BUF1 [WORD_1];
		    END;

		[DSC$K_DTYPE_B]:
		    BEGIN
		    CVTLB (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W]:
		    BEGIN
		    CVTLW (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L]:
		    OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1];

		[DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
		    BEGIN
		    MAP
			OUTPUT:  REF BITVECTOR[K_OUTPUT_BUFFER_LENGTH * 8],
		 	INTMED_DATA:  BITVECTOR[K_INTMED_DATA_LENGTH * 8];

		    INCR I FROM 0 TO .DST_INFO[D_LEN] - 1 DO
			BEGIN
			OUTPUT[.I] = .INTMED_DATA[.I];
			END;
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgfltcmplx_smlint');
		TES;				!For LRGFLTCMPLX_SMLINT
	    END;


	[K_LRGFLTCMPLX_LRGINT]:
	    BEGIN
	    IF .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_G OR
	       .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_GC
	    THEN
		M_SCALE_G_H
	    ELSE
	    	M_SCALE_H_H;
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_O OF
		SET

		[DSC$K_DTYPE_LU]:
		    BEGIN
		    IF CMPH (INTMED_DATA, .LRGST_H_LU) GTR 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
    		    IF .CVT_ROUND_FLAG
    		    THEN
		        CVTRHL (INTMED_DATA, .OUTPUT)
    		    ELSE
    			CVTHL  (INTMED_DATA, .OUTPUT);
		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q, DSC$K_DTYPE_QU]:
		    CVTRHQ (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_O]:
		    CVTRHO (INTMED_DATA, .OUTPUT);

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgfltcmplx_lrgint');
		TES;				!For LRGFLTCMPLX_LRGINT
	    END;


	[K_LRGFLTCMPLX_SMLFLTCMPLX]:
	    BEGIN
	    IF .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_G OR
	       .SOURCE[DSC$B_DTYPE] EQL DSC$K_DTYPE_GC
	    THEN
		M_SCALE_G_H
	    ELSE
	    	M_SCALE_H_H;
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
		SET

		[DSC$K_DTYPE_F]:
		    CVTHF (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_D]:
		    CVTHD (INTMED_DATA, .OUTPUT);

		[INRANGE, OUTRANGE]:
		    CASE .DESTINATION[DSC$B_DTYPE] FROM DSC$K_DTYPE_FC TO DSC$K_DTYPE_DC OF
			SET

			[DSC$K_DTYPE_FC]:
			    BEGIN
			    CVTHF (INTMED_DATA, .OUTPUT);
			    CVTHF (INTMED_DATA+16, .OUTPUT+4);
			    END;

			[DSC$K_DTYPE_DC]:
			    BEGIN
			    CVTHD (INTMED_DATA, .OUTPUT);
			    CVTHD (INTMED_DATA+16, .OUTPUT+8);
			    END;

			[INRANGE, OUTRANGE]:
			    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgfltcmplx_smlfltcmplx');
			TES;
		TES;				!For LRGFLTCMPLX_SMLFLTCMPLX
	    END;


	[K_LRGFLTCMPLX_NBDS]:
	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT, DSC$K_DTYPE_AC, DSC$K_DTYPE_AZ]:
		    BEGIN
		    LOCAL
			DIGITS_IN_EXP,
			NOT_DIGITS;

		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    CASE .SOURCE [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
			SET
			[DSC$K_DTYPE_G]:
			    BEGIN
			    DIGITS_IN_FRACT = 15;
			    DIGITS_IN_EXP = 3;
			    NOT_DIGITS = 7;
		    	    IF .DST_INFO [D_LEN] - .NOT_DIGITS GTR 0
		    	    THEN
				DIGITS_IN_FRACT = MIN (.DIGITS_IN_FRACT, .DST_INFO [D_LEN] - .NOT_DIGITS);
		    	    STATUS = FOR$CVT_G_TE (INTMED_DATA, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0, .DIGITS_IN_EXP);
		    	    IF NOT .STATUS THEN $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  error in g-to-te conversion');
			    END;

			[DSC$K_DTYPE_H]:
			    BEGIN
			    DIGITS_IN_FRACT = 33;
			    DIGITS_IN_EXP = 4;
			    NOT_DIGITS = 8;
		    	    IF .DST_INFO [D_LEN] - .NOT_DIGITS GTR 0
		    	    THEN
				DIGITS_IN_FRACT = MIN (.DIGITS_IN_FRACT, .DST_INFO [D_LEN] - .NOT_DIGITS);
		    	    STATUS = FOR$CVT_H_TE (INTMED_DATA, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0, .DIGITS_IN_EXP);
		    	    IF NOT .STATUS THEN $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  error in h-to-te conversion');
			    END;
			TES;

		    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
		    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
		    OUTPUT_STR_LEN = .FINAL_LEN;

		    SELECTONE .DESTINATION[DSC$B_DTYPE] OF
			SET
			[DSC$K_DTYPE_AC]:
			    BEGIN
			    MAP
				OUTPUT:  REF VECTOR[, BYTE];
			    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[1];
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    OUTPUT[0] = .FINAL_LEN;
			    END;

		  	[DSC$K_DTYPE_AZ]:
			    BEGIN
			    MAP
				OUTPUT:  REF VECTOR[, BYTE];
			    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[0];
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    OUTPUT[.FINAL_LEN + 1] = 0;
			    END;

			[OTHERWISE]:
			    BEGIN
		    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);
		    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    END;
			TES;
		    END;

		[OTHERWISE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  lrgfltcmplx_nbds');
		TES;				!For LRGFLTCMPLX_NBDS


	[K_DEC_SMLINT]:
	    BEGIN

            IF .DESTINATION [DSC$V_FL_BINSCALE]
            THEN
                BEGIN
                ! This is a HACK for scaled binary.  The Idea is to run the
                ! scaled packed decimal up to H_Float and then back down to
                ! the particular dtype below.  The algorithm is as follows:
                !
                ! The destination is a binary scale type so the conversion is
                ! done by hand.
                ! 1) Get the sign.
                ! 2) Get the scale of the H_Float.
                ! 3) Check if an overflow will occur.  An underflow is
                !        acceptable and will be truncated automatically.
                ! 4) Move the most significant H_Float fractional bits
                !        into the temporary destination.
                !        (Note: this includes the redundant most significant 
                !        fraction bit.
                ! 5) Alter the destination to the correct scale.
                ! 6) This is an absolute value so correct for the sign.
                ! 7) Move the result into the final destination.
                !
                ! ***************** HACK - BAB Dec. 1983 ********************
                !
                M_SCALE_P_H;
                END
            ELSE
                BEGIN
                M_SCALE_P_P;
                CVTPL (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
                END;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_V TO DSC$K_DTYPE_SVU OF
		SET

		[DSC$K_DTYPE_BU]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
                        BEGIN
   		        IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_BU
                        THEN
                            SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		        OUTPUT [BYTE_1] = .TEMP_BUF1 [BYTE_1];
                        END
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[BYTE_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (7 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<6, 1, 0> = 1;
                                TEMP_BUF1<0, 6, 0> = .INTMED_DATA<26, 6, 0>;
                                FLOAT_SCALE = 7 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [BYTE_1] = .TEMP_BUF1 [S_BYTE_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_WU]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
                        BEGIN
		        IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_WU
                        THEN
                            SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		        OUTPUT [WORD_1] = .TEMP_BUF1 [WORD_1];
                        END
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[WORD_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (15 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<14, 1, 0> = 1;
                                TEMP_BUF1<0, 14, 0> = .INTMED_DATA<18, 14, 0>;
                                FLOAT_SCALE = 15 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [WORD_1] = .TEMP_BUF1 [S_WORD_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_B]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
		        CVTLB (TEMP_BUF1, .OUTPUT)
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[BYTE_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (7 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<6, 1, 0> = 1;
                                TEMP_BUF1<0, 6, 0> = .INTMED_DATA<26, 6, 0>;
                                FLOAT_SCALE = 7 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [BYTE_1] = .TEMP_BUF1 [S_BYTE_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_W]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
  		        CVTLW (TEMP_BUF1, .OUTPUT)
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[WORD_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (15 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<14, 1, 0> = 1;
                                TEMP_BUF1<0, 14, 0> = .INTMED_DATA<18, 14, 0>;
                                FLOAT_SCALE = 15 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [WORD_1] = .TEMP_BUF1 [S_WORD_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_L]:
                    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
                        OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1]
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[LONG_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (31 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<30, 1, 0> = 1;
                                TEMP_BUF1<14, 16, 0> = .INTMED_DATA<16, 16, 0>;
                                TEMP_BUF1<0, 14, 0> = .(INTMED_DATA+4)<18, 14, 0>;
                                FLOAT_SCALE = 31 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1];
                                END;
                            END;
                    END;

		[DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
		    BEGIN
		    MAP
			OUTPUT:  REF BITVECTOR[K_OUTPUT_BUFFER_LENGTH * 8],
		 	INTMED_DATA:  BITVECTOR[K_INTMED_DATA_LENGTH * 8];

		    INCR I FROM 0 TO .DST_INFO[D_LEN] - 1 DO
			BEGIN
			OUTPUT[.I] = .INTMED_DATA[.I];
			END;
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  dec_smlint');
		TES;				!For DEC_SMLINT
	    END;


	[K_DEC_LRGINT]:
	    BEGIN
	    M_SCALE_P_P;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_O OF
		SET

		[DSC$K_DTYPE_LU]:
		    BEGIN
		    IF (CMPP (NO_DIGITS, INTMED_DATA, %REF (K_PACK_LU_LEN), .LRGST_P_LU) GEQ 0)
		    THEN
			SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    CVTPL (NO_DIGITS, INTMED_DATA, .OUTPUT);
		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q, DSC$K_DTYPE_QU, DSC$K_DTYPE_O]:
		    BEGIN
		    CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF2);
		    CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1);
		    IF .DESTINATION[DSC$B_DTYPE] EQL DSC$K_DTYPE_Q OR
    		       .DESTINATION[DSC$B_DTYPE] EQL DSC$K_DTYPE_QU
		    THEN
		        CVTRHQ (TEMP_BUF1, .OUTPUT)
		    ELSE
			CVTRHO (TEMP_BUF1, OUTPUT);
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  dec_lrgint');
		TES;				!For DEC_LRGINT
	    END;


	[K_NBDS_SMLINT]:
	    BEGIN
	    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
	    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
	    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
		(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
	    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);

            ! This is a HACK for scaled binary.  If the destination is Scaled
            ! Binary we will leave the value as a H_Float so that we can
            ! do the convert to Scaled Binary by hand.  The algorithm follows:
            !
            ! This is the algorithm for the code in the particular case below:
            ! 1) Get the sign.
            ! 2) Get the scale of the H_Float.
            ! 3) Check if an overflow will occur.  An underflow is
            !        acceptable and will be truncated automatically.
            ! 4) Move the most significant H_Float fractional bits
            !        into the temporary destination.
            !        (Note: this includes the redundant most significant 
            !        fraction bit.
            ! 5) Alter the destination to the correct scale.
            ! 6) This is an absolute value so correct for the sign.
            ! 7) Move the result into the final destination.
            !
            ! ***************** HACK - BAB Dec. 1983 ********************
            !
            IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
            THEN
                IF .CVT_ROUND_FLAG
    	        THEN
	            CVTRHL (TEMP_BUF1, TEMP_BUF2)
    	        ELSE
    		    CVTHL  (TEMP_BUF1, TEMP_BUF2);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_V TO DSC$K_DTYPE_SVU OF
		SET

		[DSC$K_DTYPE_BU]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
                        BEGIN
   		        IF .TEMP_BUF2 [LONG_1] GTRU K_LRGST_BU
                        THEN
                            SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		        OUTPUT [BYTE_1] = .TEMP_BUF2 [BYTE_1];
                        END
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[BYTE_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (7 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<6, 1, 0> = 1;
                                TEMP_BUF1<0, 6, 0> = .INTMED_DATA<26, 6, 0>;
                                FLOAT_SCALE = 7 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [BYTE_1] = .TEMP_BUF1 [S_BYTE_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_WU]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
                        BEGIN
		        IF .TEMP_BUF2 [LONG_1] GTRU K_LRGST_WU
                        THEN
                            SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		        OUTPUT [WORD_1] = .TEMP_BUF2 [WORD_1];
                        END
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[WORD_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (15 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<14, 1, 0> = 1;
                                TEMP_BUF1<0, 14, 0> = .INTMED_DATA<18, 14, 0>;
                                FLOAT_SCALE = 15 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [WORD_1] = .TEMP_BUF1 [S_WORD_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_B]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
		        CVTLB (TEMP_BUF2, .OUTPUT)
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[BYTE_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (7 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<6, 1, 0> = 1;
                                TEMP_BUF1<0, 6, 0> = .INTMED_DATA<26, 6, 0>;
                                FLOAT_SCALE = 7 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [BYTE_1] = .TEMP_BUF1 [S_BYTE_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_W]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
  		        CVTLW (TEMP_BUF2, .OUTPUT)
                    ELSE

                        ! If the sign and the scale of the H_Float are zero,
                        ! then the value is zero.
                        !
                        IF .INTMED_DATA[WORD_1] EQL 0
                        THEN
                            OUTPUT[WORD_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF1 = 0;
                            SIGN = .INTMED_DATA<15, 1, 0>;
                            INTMED_DATA<15, 1, 0> = 0;
                            FLOAT_SCALE = .INTMED_DATA[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (15 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF1<14, 1, 0> = 1;
                                TEMP_BUF1<0, 14, 0> = .INTMED_DATA<18, 14, 0>;
                                FLOAT_SCALE = 15 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF1[LONG_1] = .TEMP_BUF1[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF1 = 0 - .TEMP_BUF1;
                                OUTPUT [WORD_1] = .TEMP_BUF1 [S_WORD_1];
                                END;
                            END;
		    END;

		[DSC$K_DTYPE_L]:
		    BEGIN

                    ! If the target is not a binary scale, then just move the
                    ! converted value in.
                    !
                    IF NOT .DESTINATION [DSC$V_FL_BINSCALE]
                    THEN
                        OUTPUT [LONG_1] = .TEMP_BUF2 [S_LONG_1]
                    ELSE

                        ! If the sign and the scale of the D_Float are zero,
                        ! then the value is zero.
                        !
                        IF .TEMP_BUF1[WORD_1] EQL 0
                        THEN
                            OUTPUT[LONG_1] = 0
                        ELSE
                            BEGIN
                            TEMP_BUF2 = 0;
                            SIGN = .TEMP_BUF1<15, 1, 0>;
                            TEMP_BUF1<15, 1, 0> = 0;
                            FLOAT_SCALE = .TEMP_BUF1[WORD_1] - 16384;
                            IF .FLOAT_SCALE GTR (31 + .DESTINATION[DSC$B_SCALE])
                            THEN
                                SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME)
                            ELSE
                                BEGIN
                                TEMP_BUF2<30, 1, 0> = 1;
                                TEMP_BUF2<14, 16, 0> = .TEMP_BUF1<16, 16, 0>;
                                TEMP_BUF2<0, 14, 0> = .(TEMP_BUF1+4)<18, 14, 0>;
                                FLOAT_SCALE = 31 + .DESTINATION[DSC$B_SCALE] - .FLOAT_SCALE;
                                WHILE .FLOAT_SCALE GTR 0 DO
                                    BEGIN
                                    TEMP_BUF2[LONG_1] = .TEMP_BUF2[S_LONG_1] / 2;
                                    FLOAT_SCALE = .FLOAT_SCALE - 1;
                                    END;
                                IF .SIGN THEN TEMP_BUF2 = 0 - .TEMP_BUF2;
                                OUTPUT [LONG_1] = .TEMP_BUF2 [S_LONG_1];
                                END;
                            END;
                    END;

		[DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
		    BEGIN
		    MAP
			OUTPUT:  REF BITVECTOR[K_OUTPUT_BUFFER_LENGTH * 8],
		 	INTMED_DATA:  BITVECTOR[K_INTMED_DATA_LENGTH * 8];

		    INCR I FROM 0 TO .DST_INFO[D_LEN] - 1 DO
			BEGIN
			OUTPUT[.I] = .INTMED_DATA[.I];
			END;
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  nbds_smlint');
		TES;				!For NBDS_SMLINT
	    END;


	[K_NBDS_LRGINT]:
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_O OF
		SET

		[DSC$K_DTYPE_LU]:
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_D (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
		    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1 , .DBG$GL_OPCODE_NAME);
		    IF .TEMP_BUF1<15, 1, 0> THEN SIGNAL (DBG$_CVTNEGUNS, 1, .DBG$GL_OPCODE_NAME);
		    IF CMPD (TEMP_BUF1, .LRGST_D_LU) GTR 0 THEN SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
    		    IF .CVT_ROUND_FLAG
    		    THEN
		        CVTRDL (TEMP_BUF1, .OUTPUT)
    		    ELSE
    			CVTDL  (TEMP_BUF1, .OUTPUT);

		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q, DSC$K_DTYPE_QU]:				! M003
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
		    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);
		    CVTRHQ (TEMP_BUF1, .OUTPUT)
		    END;

		[DSC$K_DTYPE_O]:						! A004
		    BEGIN							! A004
		    LOCAL							! A004
			Sign_flag : INITIAL( 0 ),				! A004
			Current_character;					! A004

		    MAP OUTPUT : REF VECTOR[4];					! A004

		    !++								! A004
		    ! Init the octaword						! A004
		    !--								! A004
		    OUTPUT[ 3 ] = 0;						! A004
		    OUTPUT[ 2 ] = 0;						! A004
		    OUTPUT[ 1 ] = 0;						! A004
		    OUTPUT[ 0 ] = CH$RCHAR( .SRC_INFO[ S_POINTER ] ) - %C'0';	! A004

		    !++								! A004
		    ! Test for bad characters					! A004
		    !--								! A004
		    IF .OUTPUT[ 0 ] LSS 0  OR  .OUTPUT[ 0 ] GTR 9		! A004
		    THEN							! A004
			IF .OUTPUT[ 0 ] EQL %C'-' - %C'0'			! A004
			THEN							! A004
			    BEGIN						! A004
			    SRC_INFO[ S_POINTER ] = .SRC_INFO[ S_POINTER ] + 1;	! A004
			    SRC_INFO[ S_LEN ] = .SRC_INFO[ S_LEN ] - 1;		! A004
		    	    OUTPUT[ 0 ] = CH$RCHAR( .SRC_INFO[ S_POINTER ] ) -	! A004
					  %C'0';				! A004
			    Sign_flag = 1;					! A004
			    END							! A004
			ELSE							! A004
		    	    SIGNAL( DBG$_INVDIGDEC, 2, 1, .SRC_INFO[S_POINTER]);! A004

		    !++								! A004
		    ! For each character					! A004
		    !    multiply by 10						! A004
		    !    add it to the low order long word			! A004
		    !--								! A004
		    INCR Current_char_num FROM 1 TO .SRC_INFO [S_LEN] - 1 DO	! A004
			BEGIN							! A004
			DBG$CVT_SCALE_OU_UP_BY_10_R1( .OUTPUT );		! A004
			Current_character = CH$RCHAR( .SRC_INFO[ S_POINTER ] +	! A004
						      .Current_char_num ) - 	! A004
					    %C'0';				! A004

		   	!++							! A004
		    	! Test for bad characters				! A004
		    	!--							! A004
		    	IF (.Current_character LSS 0)  OR  			! A004
			   (.Current_character GTR 9)				! A004
		    	THEN							! A004
		    	    SIGNAL( DBG$_INVDIGDEC, 2, 1, .SRC_INFO[S_POINTER] +! A004
						          .Current_char_num );	! A004

			OUTPUT[ 0 ] = .OUTPUT[ 0 ] + .Current_character;	! A004
			END;							! A004

			!++
			! When there was a negative we subtract from 0
			!--
			IF .Sign_flag						! A004
			THEN							! A004
			    BEGIN						! A004
			    LOCAL						! A004
				Octaword_zero : VECTOR[4];			! A004

	    		    Octaword_zero[ 3 ] = 0;				! A004
			    Octaword_zero[ 2 ] = 0;				! A004
			    Octaword_zero[ 1 ] = 0;				! A004
			    Octaword_zero[ 0 ] = 0;				! A004

			    SUBM( 4, .OUTPUT, Octaword_zero, .OUTPUT );		! A004

			    END;						! A004

		    END;							! A004

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  nbds_lrgint');
		TES;				!For NBDS_LRGINT


	[K_NBDS_LRGFLTCMPLX]:
	    BEGIN
	    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
	    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_HC OF
		SET

		[DSC$K_DTYPE_G, DSC$K_DTYPE_GC]:
		    BEGIN
		    STATUS = OTS$CVT_T_G (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
		    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);
		    OUTPUT [LONG_1] = .TEMP_BUF1 [LONG_1];
		    OUTPUT [LONG_2] = .TEMP_BUF1 [LONG_2];
		    IF .DESTINATION[DSC$B_DTYPE] EQL DSC$K_DTYPE_GC
		    THEN
			BEGIN


			! Fill in imaginary part with 0;
			!
			OUTPUT[LONG_3] = 0;
			OUTPUT[LONG_4] = 0;
			END;
		    END;

		[DSC$K_DTYPE_H, DSC$K_DTYPE_HC]:
		    BEGIN
		    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
		    IF NOT .STATUS THEN SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);
		    CH$MOVE (16, TEMP_BUF1, .OUTPUT);
		    IF .DESTINATION[DSC$B_DTYPE] EQL DSC$K_DTYPE_HC
		    THEN


			! Fill in imaginary part with 0.
			!
			CH$FILL (0, 16, .OUTPUT+16);
		    END;

		[INRANGE, OUTRANGE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  nbds_lrgfltcmplx');
		TES;				!For NBDS_LRGFLTCMPLX
	    END;


	[K_NBDS_NBDS]:
	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT, DSC$K_DTYPE_AC, DSC$K_DTYPE_AZ]:
		    BEGIN
		    IF .SCALE NEQ 0
		    THEN
			BEGIN
			CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
			CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
			STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			    (K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));
			IF .STATUS
			THEN
			    BEGIN
			    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
			    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
			    IF .DST_INFO [D_LEN] - 9 LEQ 0
			    THEN
				DIGITS_IN_FRACT = 33
			    ELSE
				DIGITS_IN_FRACT = MIN (33, .DST_INFO [D_LEN] - 9);
			    STATUS = FOR$CVT_H_TE (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, 0, 0, 4);
		    	    IF NOT .STATUS THEN $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  error in h-to-te conversion');
			    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
			    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
			    OUTPUT_STR_LEN = .FINAL_LEN;

		    	    SELECTONE .DESTINATION[DSC$B_DTYPE] OF
				SET
				[DSC$K_DTYPE_AC]:
			            BEGIN
			    	    MAP
					OUTPUT:  REF VECTOR[, BYTE];
			    	    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    	    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[1];
		    	    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    	    OUTPUT[0] = .FINAL_LEN;
			    	    END;

		  		[DSC$K_DTYPE_AZ]:
			    	    BEGIN
			    	    MAP
					OUTPUT:  REF VECTOR[, BYTE];
			    	    CLASS_S_DESC[DSC$W_LENGTH] = .FINAL_LEN;
			    	    CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[0];
		    	    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, CLASS_S_DESC);
		    	    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    	    OUTPUT[.FINAL_LEN + 1] = 0;
			    	    END;

				[OTHERWISE]:
			    	    BEGIN
		    	    	    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);
		    	    	    IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
			    	    END;
				TES;
			    END
			ELSE
			    SIGNAL (DBG$_INVNUMSTR, 1, .DBG$GL_OPCODE_NAME);
			END
		    ELSE
			BEGIN
			OUTPUT_STR_LEN = .SOURCE [DSC$W_LENGTH];
		        SELECTONE .DESTINATION[DSC$B_DTYPE] OF
			    SET
			    [DSC$K_DTYPE_AC]:
			    	BEGIN
			    	MAP
				    OUTPUT:  REF VECTOR[, BYTE];
			    	CLASS_S_DESC[DSC$W_LENGTH] = .SOURCE[DSC$W_LENGTH];
			    	CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[1];
				STATUS = LIB$SCOPY_DXDX6 (.SOURCE, CLASS_S_DESC);
		    	    	IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    	IF NOT .STATUS THEN SIGNAL (.STATUS);
			    	OUTPUT[0] = .SOURCE[DSC$W_LENGTH];
			    	END;

		  	    [DSC$K_DTYPE_AZ]:
			    	BEGIN
			    	MAP
				    OUTPUT:  REF VECTOR[, BYTE];
			    	CLASS_S_DESC[DSC$W_LENGTH] = .SOURCE[DSC$W_LENGTH];
			    	CLASS_S_DESC[DSC$A_POINTER] = OUTPUT[0];
				STATUS = LIB$SCOPY_DXDX6 (.SOURCE, CLASS_S_DESC);
		    	    	IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    	IF NOT .STATUS THEN SIGNAL (.STATUS);
			    	OUTPUT[.SOURCE[DSC$W_LENGTH]] = 0;
			    	END;

			    [OTHERWISE]:
			    	BEGIN
				STATUS = LIB$SCOPY_DXDX6 (.SOURCE, .DESTINATION);
		    	    	IF .STATUS EQL LIB$_STRTRU THEN SIGNAL (DBG$_ISTRTRU, 1, .DBG$GL_OPCODE_NAME);
		    	    	IF NOT .STATUS THEN SIGNAL (.STATUS);
			    	END;
			    TES;
			END;
		    END;

		[DSC$K_DTYPE_ZI]:
		    BEGIN
		    OWN
			INPUT_STR:  VECTOR[100, BYTE],
			OUTPUT_STR:  VECTOR[100, BYTE];
		    INPUT_STR[0] = .SRC_INFO[S_LEN];
		    CH$MOVE (.INPUT_STR[0], .SRC_INFO[S_POINTER], INPUT_STR[1]);
		    STATUS = DBG$INS_ENCODE (INPUT_STR, OUTPUT_STR, .DESTINATION[DSC$A_POINTER]);
		    IF NOT .STATUS THEN SIGNAL (.STATUS);
		    DESTINATION[DSC$W_LENGTH] = .OUTPUT_STR[0];
		    CH$MOVE (.OUTPUT_STR[0], OUTPUT_STR[1], .DESTINATION[DSC$A_POINTER]);
		    END;
 
		[OTHERWISE]:
		    $DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  nbds_nbds');
		TES;				!For NBDS_NBDS

	TES;					!End of the main CASE statement.


    ! If the destination class is unaligned, then the output will be in a temporary buffer.
    ! Copy from the temporary buffer to:  .(destination pointer + number of bits to be offset).
    !
    IF .DESTINATION[DSC$B_CLASS] EQL DSC$K_CLASS_UBS
    THEN
	BEGIN
	SRC_POS = 0;
	DST_POS = .DESTINATION[DSC$L_POS];
    	CASE .DESTINATION[DSC$B_DTYPE] FROM K_MIN_DTYPE_STA TO K_MAX_DTYPE_STA OF
	    SET
	    [DSC$K_DTYPE_V, DSC$K_DTYPE_SV, DSC$K_DTYPE_VU, DSC$K_DTYPE_SVU, DSC$K_DTYPE_TF]:
	    	BEGIN
	    	MAP
		    DESTINATION_PTR:  REF BITVECTOR,
		    OUTPUT:  REF BITVECTOR;

	    	INCR I FROM 1 TO .DESTINATION[DSC$W_LENGTH] DO
		    BEGIN
		    DESTINATION_PTR[.DST_POS] = .OUTPUT[.SRC_POS];
		    DST_POS = .DST_POS + 1;
	 	    SRC_POS = .SRC_POS + 1;
		    END;
	    	END;

	    [INRANGE]:
	    	BEGIN
	        INCR I FROM 1 TO .DESTINATION[DSC$W_LENGTH] DO
		    BEGIN
		    (.DESTINATION_PTR)<.DST_POS, 8> = .(.OUTPUT)<.SRC_POS, 8>;
		    DST_POS = .DST_POS + 8;
		    SRC_POS = .SRC_POS + 8;
		    END;
	    	END;

	    [OUTRANGE]:
	    	$DBG_ERROR ('DBGCVTDX\DBG$CVT_DX_DX:  invalid dtype');
 	    TES;
	END;

    END;					! End the ELSE part of the Absolute Date Time IF			A003

    ! If output string length is requested then supply it.
    !
    IF ACTUALCOUNT() GTR 2 THEN (.OUTLEN)<0, 16, 0> = .OUTPUT_STR_LEN;

    END;					! End of routine DBG$CVT_DX_DX.

ROUTINE CVT_HANDLER (SIG, MECH) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This handler will resignal opcode reserved to digital; it
!	otherwise translates system service signals to debug
!	error codes and resignals.
!
! FORMAL PARAMETERS:
!
!	SIG_rr.r	A counted vector of parameters describing the condition.
!	MECH.rr.r	A counted vector of parameters from CHF.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS: (or ROUTINE VALUE:)
!
!	SS$_RESIGNAL when opcode reserved to digital exception.  Any other case
!	will result in a debug condition being signalled.
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN
    MAP
	SIG : REF VECTOR,
	MECH : REF VECTOR;


    !Translate error code if this is not an UNWIND, or opcode reserved to digital.
    !Otherwise, signal debug error.  
    !
    IF (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND), %REF (SS$_OPCDEC))) GTR 0 
    THEN 
	RETURN (SS$_RESIGNAL);


    !Translate all numeric exceptions to debug's facility code.
    !Also, translate SS$_ROPRAND to DBG$_ROPRANDF.
    !
    SELECTONE .SIG[1] OF
	SET
	[SS$_INTOVF]:
	    SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_DECOVF]:
	    SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_FLTOVF, SS$_FLTOVF_F]:
	    SIGNAL (DBG$_FLTOVF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_FLTUND, SS$_FLTUND_F]:
	    BEGIN
	    .SAVE_RESULT = 0;
	    SIGNAL (DBG$_IFLTUND, 1, .DBG$GL_OPCODE_NAME);
	    END;
	[SS$_ROPRAND]:
	    BEGIN
	    IF .DECIMAL_CONVERT
	    THEN
		SIGNAL (DBG$_DECROPRAND)
	    ELSE
	    	SIGNAL (DBG$_ROPRANDF, 1, .DBG$GL_OPCODE_NAME);
 	    END;
	[OTHERWISE]:
	    RETURN (SS$_RESIGNAL);
	TES;

    SETUNWIND();
    RETURN 0;
    END;					! End of CVT_HANDLER

ROUTINE FIND_CVT_PATH (SOURCE, DESTINATION, SRC_INFO, DST_INFO, CVT_PATH) =
!
! FUNCTION
!	This routine is called by DBG$CVT_DX_DX, and has the following four
!	functions:
!	  
!	    a.  It finds any errors concerning the class and data type of the source
!		and destination descriptors.  These errors can be invalid class,
!		invalid data type, or invalid combination of a class and data type.
!		It can also tell which descriptors are supported by this
!		routine.
!
!	    b.  It figures out what the conversion path is; ie, 
!		class,dtype --> class,dtype.  These paths are given names such
!		as K_SMLINT_DEC, which reads "from small integer to decimal"
!		(categories defined later).
!
!	    c.  Converts the source data to an intermediate data.  The strategy
!		used to select the appropriate intermediate data is explained later.
!
!	    d.  Puts whatever information is needed about the source and destination
!		descriptor in two structures passed by DBG$CVT_DX_DX.  These
!		two structures, SRC_INFO and DST_INFO, contain the kind of
!		information that can only be visible when the class and data
!		type of the source and destination descriptors are being
!		manipulated.  These two structures can be expanded to contain
!		more information as new class, and dta types may require it.
!
!	This routine is comprised of a Deterministic Finite Automaton, defined
!	as a 5 tuple:
!	States		: There is a state for each CLASS, and CLASS, DATA TYPE
!			  combination.
!	Alphabet	: Classes and Data types.
!	Mappings	: M(CLASS_S , DTYPE_B) := CLASS_S_DTYPE_B
!			  . . . . . . . . . . . . . . . . . . . .
!			  . . . . . . . . . . . . . . . . . . . .
!			  M(CLASS_D , DTYPE_W) := error
!			  . . . . . . . . . . . . . . . . . . . .
!			  . . . . . . . . . . . . . . . . . . . .
!	Start state	:
!	Final states	: All possible combinations of CLASS, DTYPE.
!			  Some of these combinations are allowed, others
!			  are not. The error combinations are denoted by
!			  negative numbers as states.
!
!	
! MAINTENANCE OF THIS ROUTINE:
!
! This routine knows about all classes and data types of Appendix C V8.3.
! (You may want to update the above line everytime a change is made)
! To make an already existing CLASS, DATA TYPE combination a valid one, as
! opposed to an error you must:
!	1. Insert the symbol for that data type in DTYPE_TABLE in place of the
!	   error state.
!	2. Define a FINAL_STATE for this combination.
!	3. Give it an action routine.
!
! To add a new data type you must:
!	1. Increment K_MAX_DATA_TYPES.
!	2. Set K_MAX_DTYPE_STA to value of the new data type.
!	3. Does any of the following need to be changed?
!		a. K_SMLFINSTA
!		b. K_LRGFINSTA
!		c. K_TOP_SD
!		d. K_BOTTOM_SD
!	4. Define a new FINAL_STATE.
!	5. Each category in DTYPE_TABLE must have a new entry for the data type.
!	   Note that the position (starting at 0) of each entry in each category is equivalent
!	   to the data type value.
!	6. Add the new lable into the action routines CASE statement and
!	   the sub-CASE statements in DBG$CVT_DX_DX will need to be modified to
!	   include this new data type.
!
! To add a new class you must:
!	1. Increment K_MAX_CLASSES
!	2. Set K_MAX_CLASS_STA to value of the new class.
!	3. Increment K_ACTUAL_CLASSES.
!	4. Make a new K_STATEx_CLASS_y, where x is class value and y is the
!	   symbol of the class.
!	5. Make a new FINAL_STATE.
!	6. Add a new category to the STATES structure at the end, with a index
!	   value of one higher than the last category.
!	7. Make a new entry in CLASS_TABLE.
!	8. Make a new category in DTYPE_TABLE.
!	9. Make a new lable in the action routine CASE statement.
!
!
! CALLING SEQUENCE:
!	ret_status.wlc.v = FIND_CVT_PATH (SOURCE.rx.dx,
!				      DESTINATION.rx.dx,
!				      SRC_INFO.wr.r,
!				      DST_INFO.wr.r,
!				      CVT_PATH.wlu.r)
!
! FORMAL PARAMETERS:
!	SOURCE		Address of source descriptor passed to DBG$CVT_DX_DX.
!	DESTINATION	Address of destination descriptor passed to DBG$CVT_DX_DX.
!	SRC_INFO	Address of a record in DBG$CVT_DX_DX.  Source information goes here.
!	DST_INFO	Address of a record in DBG$CVT_DX_DX.  Destination info goes here.
!	CVT_PATH	Address of a longword in DBG$CVT_DX_DX.  This code will determine which
!			CASE label is taken in DBG$CVT_DX_DX.
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! COMPLETION STATUS: (or ROUTINE VALUE:)
!	K_UNSCLAROU		: -1 Unsupported CLASS by routine.
!	K_UNSDTYROU		: -2 Unsupported DTYPE by routine.
!	K_UNSDESROU		: -3 Unsupported descriptor by routine.
!	K_UNSDESSTA		: -4 Unsupported descriptor by standard.
!	K_UNSCLASTA		: -5 Unsupported CLASS by standard.
!	K_UNSDTYSTA		: -6 Unsupported DTYPE by standard.
!	K_INVNBDS		: -7 Invalid NBDS because array size is greater
!				     than WU or dimension is not one.
!	K_SUPPORTED		:  1 This descriptor is supported.
!
! SIDE EFFECTS:
!	Caller of DBG$CVT_DX_DX must have LIB$EMULATE as a handler, if the
!	source or destination descriptor explicitely ask for G, H, O conversions.
!
    BEGIN
    LOCAL
	STATUS,					! Status of this routine
	STATE,					! State
	CLASS,					! Current CLASS being looked at
	DTYPE,					! Current DTYPE being looked at
	TOKEN,					! The value of each data type supported
	LEFT_CVT : VECTOR [1],			! Left side of conversion index.
	RIGHT_CVT : VECTOR [1],			! Right side of conversion index.
	LEFT_OR_RIGHT_CVT : REF VECTOR,		! Left or right side of conversion index.
	SRC_OR_DST_INFO : REF BLOCK [, BYTE],	! Source or destination info.
	SRC_OR_DST : REF BLOCK [, BYTE],	! Source or destination.
	TEMP_BUF : BLOCK [K_INTMED_DATA_LENGTH, BYTE];	! Temporary buffer for reshuffling things.

    MAP
	SOURCE : REF BLOCK [, BYTE],
	DESTINATION : REF BLOCK [, BYTE],
	SRC_INFO : REF BLOCK [, BYTE] FIELD (SRC_INFO_FIELDS),
	DST_INFO : REF BLOCK [, BYTE] FIELD (DST_INFO_FIELDS);


! Traverse through the state table twice, once for source, and once for
! the destination descriptor.  Each time through, it determines a an
! intermediate type; ie, an intermediate type for the source and an
! intermediate type for the destination.  Eg.  SMLINT or LRGFLTCMPLX.
! The action routines also build SRC_INFO, and DST_INFO, and they 
! convert the source to its intermediate value.
! After determining the intermediate mappings for both the source and
! destination descriptors, a formula maps both intermediate states into
! one final state, eg. K_SMLINT_LRGFLTCMPLX.  This final result is used
! as the main CASE index in DBG$CVT_DX_DX.
!
! The loop goes from 0 to 3:  once for source, once for destination; if it makes
! it to .TURN EQL 2, then it exits the loop with a successful status.
! If the state table indicates an error (eg. invalid dtype-class combination), 
! or an error is detected in an action routine (eg. size of array cannot fit in WU),
! then the routine exits the loop with an error code.
!
    BEGIN
    STATUS = (INCRU TURN FROM 0 TO 3 DO
	BEGIN


	! Determine CLASS and DTYPE of this go around, also set up LEFT_OR_RIGHT_CVT,
	! and SRC_OR_DST, and SRC_OR_DST_INFO.
	! If this is the third time through this loop, we are finished.
	!
	CASE .TURN FROM 0 TO 2 OF
	    SET
	    [0]:
		BEGIN
		CLASS = .SOURCE [DSC$B_CLASS];
		DTYPE = .SOURCE [DSC$B_DTYPE];
		SRC_OR_DST = .SOURCE;
		SRC_OR_DST_INFO = .SRC_INFO;
		LEFT_OR_RIGHT_CVT = LEFT_CVT;
		END;
	    [1]:
		BEGIN
		CLASS = .DESTINATION [DSC$B_CLASS];
		DTYPE = .DESTINATION [DSC$B_DTYPE];
		SRC_OR_DST = .DESTINATION;
		SRC_OR_DST_INFO = .DST_INFO;
		LEFT_OR_RIGHT_CVT = RIGHT_CVT;
		END;
	    [2]:
		EXITLOOP K_SUPPORTED;
	    TES;


	! Filter out the out-of-range CLASS and DTYPE.
	!
	IF .CLASS GTRU K_MAX_CLASS_STA THEN EXITLOOP K_UNSCLASTA;
	IF .DTYPE GTRU K_MAX_DTYPE_STA THEN EXITLOOP K_UNSDTYSTA;


	! Crank up the finite state machine. start looking in the start state.
	!
	STATE = .CLASS_TABLE [.CLASS];


	! Action code for each state that results from the start state.
	!
	CASE .STATE FROM K_MSTNEGERR TO K_LRGCLSSUP OF
	    SET
	    [K_INVNBDS TO K_UNSCLAROU] :


		! Exit the INCR with the error resulting from the
		! start state.
		!
		EXITLOOP .STATE;
	    [K_SMLCLSSUP TO K_LRGCLSSUP] :
		BEGIN


		! This is a final state, but some constants need to be
		! applied to it yet.  This is just a data type, or a
		! negative number if error.
		!
		TOKEN = .DTYPE_TABLE [.STATE, .DTYPE];


		! Exit INCR with the error resulting in a final state.
		!
		IF .TOKEN LSS 0 THEN EXITLOOP .TOKEN;


		! Find the final state.
		!
		STATE = FINAL_STATE (.STATE, .TOKEN);
		END;
	    [INRANGE, OUTRANGE] :
		$DBG_ERROR ('DBGCVTDX\FIND_CVT_PATH:  invalid state');
	    TES;

	! This CASE statement contains the action code for each final state other than
	! the error states.
	! The caller of this routine has set up the pointer and length of SRC_INFO
	! to be the intermediate data area (INTMED_DATA); in the CASE below we change
	! the pointer and length if needed (e.g. any NBDS), otherwise we never
	! touch it.
	! If .TURN is 0 then we are processing the left side of the conversion, when
	! it is 1 we are processing the right side of the conversion. In other words,
	! if .TURN is 0 we are looking at the CLASS, DATA TYPE of source; if .TURN
	! is 1 we are looking at CLASS, DATA TYPE of destination.
	! These action codes determine which category (e.g. K_SMLINT or K_DEC as
	! described in DBG$CVT_DX_DX documentation) the source or destination data type
	! falls into.  They also convert the source data type to an intermediate
	! data type.  For more detail refer to the functional description of
	! DBG$CVT_DX_DX.
	!
	CASE .STATE FROM K_SMLFINSTA TO K_LRGFINSTA OF
	    SET

	    [K_S_BU, K_SD_BU, K_UBS_BU]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLINT;
		IF .STATE EQL K_SD_BU THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 8, 0;,
			BYTE];
		END;

	    [K_S_WU, K_SD_WU, K_UBS_WU]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLINT;
		IF .STATE EQL K_SD_WU THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;    		
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 16, 0;,
			BYTE];
		END;

	    [K_S_LU, K_SD_LU, K_UBS_LU]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGINT;
		IF .STATE EQL K_SD_LU THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 0;,
			BYTE];
		END;

	    [K_S_B, K_SD_B, K_UBS_B]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLINT;
		IF .STATE EQL K_SD_B THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 8, 1;,
			BYTE];
		END;

	    [K_S_W, K_SD_W, K_UBS_W]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLINT;
		IF .STATE EQL K_SD_W THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 16, 1;,
			BYTE];
		END;

	    [K_S_L, K_SD_L, K_UBS_L]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLINT;
		IF .STATE EQL K_SD_L THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 1;,
			BYTE];
		END;

	    [K_S_V, K_S_SV, K_S_TF, K_UBS_VU, K_UBS_SVU, K_UBS_TF]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLINT;
		SRC_OR_DST_INFO[M_LEN] = .SRC_OR_DST[DSC$W_LENGTH];
		IF .TURN EQL 0
		THEN
		    BEGIN
		    LOCAL
			BITPOS, SRC_PTR;

		    IF .SOURCE[DSC$B_CLASS] EQL DSC$K_CLASS_UBS
		    THEN
			BITPOS = .SOURCE[DSC$L_POS]
		    ELSE
			BITPOS = 0;
		    SRC_PTR = .SOURCE[DSC$A_BASE];
		    IF .STATE EQL K_S_SV OR .STATE EQL K_UBS_SVU
		    THEN
			.SRC_INFO[S_POINTER] = .(.SRC_PTR)<.BITPOS, .SOURCE[DSC$W_LENGTH], 1>
		    ELSE
			BEGIN
			.SRC_INFO[S_POINTER] = .(.SRC_PTR)<.BITPOS, .SOURCE[DSC$W_LENGTH], 0>;
			IF .BLOCK [.SRC_INFO[S_POINTER], 0, 31, 1, 0;, BYTE]
			THEN
			    .LEFT_OR_RIGHT_CVT = K_LRGINT;
			END;
		    END;
		END;

	    [K_S_Q, K_SD_Q, K_UBS_Q, K_S_QU, K_SD_QU, K_UBS_QU]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGINT;
		IF .STATE EQL K_SD_Q OR .STATE EQL K_SD_QU
    		THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 0;, BYTE];
		    (.SRC_INFO [S_POINTER] + 4) = .BLOCK [.SOURCE [DSC$A_POINTER] + 4, 0, 0, 32, 0;, BYTE];
		    IF .BLOCK [.SRC_INFO [S_POINTER], 4, 31, 1, 0;, BYTE]
		    THEN
			BEGIN
			.SRC_INFO [S_POINTER] = ..SRC_INFO [S_POINTER] XOR %X'FFFFFFFF';
			.SRC_INFO [S_POINTER] + 4 = .(.SRC_INFO [S_POINTER] + 4) XOR %X'FFFFFFFF';
			IF ..SRC_INFO [S_POINTER] EQLU K_LRGST_LU
			THEN
			    BEGIN
			    .SRC_INFO [S_POINTER] = 0;
			    .SRC_INFO [S_POINTER] + 4 = .(.SRC_INFO [S_POINTER] + 4) + 1;
			    END
			ELSE
			    .SRC_INFO [S_POINTER] = ..SRC_INFO [S_POINTER] + 1;
			SRC_INFO [S_SIGN] = 1;
			END;
		    END;
		END;

	    [K_S_O, K_SD_O, K_UBS_O]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGINT;
		IF .STATE EQL K_SD_O THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    CH$MOVE (16, .SOURCE[DSC$A_POINTER], .SRC_INFO[S_POINTER]);
		    IF .BLOCK [.SRC_INFO [S_POINTER], 12, 31, 1, 0;, BYTE]
		    THEN
			BEGIN
			INCR I FROM 0 TO 12 BY 4 DO
			    .SRC_INFO[S_POINTER] + .I = .(.SRC_INFO[S_POINTER] + .I) XOR %X'FFFFFFFF';
			IF ..SRC_INFO [S_POINTER] EQLU K_LRGST_LU
			THEN
			    BEGIN
			    .SRC_INFO [S_POINTER] = 0;
			    INCR I FROM 4 TO 12 BY 4 DO
			        .SRC_INFO [S_POINTER] + .I = .(.SRC_INFO [S_POINTER] + .I) + 1;
			    END
			ELSE
			    .SRC_INFO [S_POINTER] = ..SRC_INFO [S_POINTER] + 1;
			SRC_INFO [S_SIGN] = 1;
			END;
		    END;
		END;

	    [K_S_F, K_SD_F, K_UBS_F]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLFLT_CMPLX;
		IF .STATE EQL K_SD_F THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 0;, BYTE];
		END;

	    [K_S_FC, K_SD_FC, K_UBS_FC]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLFLT_CMPLX;
		IF .STATE EQL K_SD_FC THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 0;, BYTE];


		    ! Intermediate data type is double complex.
		    !
		    (.SRC_INFO [S_POINTER] + 8) = .BLOCK [.SOURCE [DSC$A_POINTER] + 4, 0, 0, 32, 0;, BYTE];
		    END;
		END;

	    [K_S_D, K_SD_D, K_UBS_D]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLFLT_CMPLX;
		IF .STATE EQL K_SD_D THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN


		    ! The intermediate data buffer is initialized to zero, so
		    ! don't have to worry about filling imaginary part.
		    ! (Intermediate data type is double complex).
		    !
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 0;, BYTE];
		    (.SRC_INFO [S_POINTER] + 4) = .BLOCK [.SOURCE [DSC$A_POINTER] + 4, 0, 0, 32, 0;, BYTE];
		    END;
		END;

	    [K_S_DC, K_SD_DC, K_UBS_DC]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_SMLFLT_CMPLX;
		IF .STATE EQL K_SD_D THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    CH$MOVE (16, .SOURCE[DSC$A_POINTER], .SRC_INFO[S_POINTER]);
		END;

	    [K_S_G, K_SD_G, K_UBS_G]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGFLT_CMPLX;
		IF .STATE EQL K_SD_G THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    .SRC_INFO [S_POINTER] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 32, 0;, BYTE];
		    (.SRC_INFO [S_POINTER] + 4) = .BLOCK [.SOURCE [DSC$A_POINTER] + 4, 0, 0, 32, 0;, BYTE];
		    END;
		END;

	    [K_S_GC, K_SD_GC, K_UBS_GC]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGFLT_CMPLX;
		IF .STATE EQL K_SD_GC THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    CH$MOVE (16, .SOURCE[DSC$A_POINTER], .SRC_INFO[S_POINTER]);
		END;

	    [K_S_H, K_SD_H, K_UBS_H]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGFLT_CMPLX;
		IF .STATE EQL K_SD_H THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0 THEN CH$MOVE (16, .SOURCE [DSC$A_POINTER], .SRC_INFO [S_POINTER]);
		END;

	    [K_S_HC, K_SD_HC, K_UBS_HC]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_LRGFLT_CMPLX;
		IF .STATE EQL K_SD_HC THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0 
		THEN 
		    CH$MOVE (32, .SOURCE [DSC$A_POINTER], .SRC_INFO [S_POINTER]);
		END;

	    [K_S_T, K_SD_T, K_UBS_T]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_NBDS;
		SRC_OR_DST_INFO [M_LEN] = .SRC_OR_DST [DSC$W_LENGTH];
		IF .STATE EQL K_SD_T THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_POINTER] = .SOURCE [DSC$A_POINTER];
		    END;
		END;

	    [K_S_NU, K_SD_NU]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_NU THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_LEN] = 31;
		    CVTTP (SOURCE [DSC$W_LENGTH], .SOURCE [DSC$A_POINTER], LIB$AB_CVTTP_U,
			SRC_INFO [S_LEN], .SRC_INFO [S_POINTER]);
		    END;
		END;

	    [K_S_NL, K_SD_NL]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_NL THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_LEN] = 31;
		    CVTSP (%REF (
			    IF .SOURCE [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .SOURCE [DSC$W_LENGTH] - 1),
			.SOURCE [DSC$A_POINTER], SRC_INFO [S_LEN], .SRC_INFO [S_POINTER]);
		    END;
		END;

	    [K_S_NLO, K_SD_NLO]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_NLO THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    LOCAL
			LF_SIGN:  REF VECTOR[, BYTE],
			RT_SIGN:  REF VECTOR[, BYTE],
			ZERO_FLAG,
			SIGN_FLAG,
			PACK_ZERO: VECTOR [1];
		    PACK_ZERO = UPLIT (%P'+0');
		    SRC_INFO [S_LEN] = 31;
!		    CH$TRANSLATE (LIB$AB_CVT_O_U, .SOURCE [DSC$W_LENGTH], .SOURCE [DSC$A_POINTER], 0,
!			.SOURCE [DSC$W_LENGTH], TEMP_BUF);
!		    CVTTP (SOURCE [DSC$W_LENGTH], TEMP_BUF, LIB$AB_CVTTP_U, SRC_INFO [S_LEN],
!			.SRC_INFO [S_POINTER]);
!
! Orignal code turns negative NLO type into positive NLO.  If the negative
! type comes into this piece of code without CH$TRANSLATE gives Reserved
! Operand fault.  What I did here is to move the left overpunched sign
! to the right overpunched sign then performs the conversion.  After the 
! conversion, put the sign back to where it belonged.
! 
		    RT_SIGN = .SOURCE [DSC$A_POINTER] + .SOURCE [DSC$W_LENGTH] - 1;
		    LF_SIGN = .SOURCE [DSC$A_POINTER];
		    ZERO_FLAG = FALSE;
		    SELECTONE .LF_SIGN[0] OF
			SET

			! Positive 1 -- 9
			!
			[%X'41' TO %X'49']: SIGN_FLAG = TRUE;

			! Negative 1 -- 9
			!
			[%X'4A' TO %X'52']: SIGN_FLAG = FALSE;

			! Positive 0
			!
			[%X'7B']:
			    BEGIN
			    SIGN_FLAG = TRUE;
			    ZERO_FLAG = TRUE;
			    LF_SIGN[0] = %X'30';
			    IF .RT_SIGN[0] EQL %X'30'
			    THEN
				RT_SIGN[0] = %X'7B'
			    ELSE
			        RT_SIGN[0] = .RT_SIGN[0] + %X'10';
			    END;

			! Negative 0
			!
			[%X'7D']:
			    BEGIN
			    SIGN_FLAG = FALSE;
			    ZERO_FLAG = TRUE;
			    LF_SIGN[0] = %X'30';
		            IF .RT_SIGN[0] EQL %X'30'
			    THEN
				RT_SIGN[0] = %X'7D'
			    ELSE
			        RT_SIGN[0] = .RT_SIGN[0] + %X'19';
			    END;

			[OTHERWISE]: $DBG_ERROR('DBGCVTDX\FIND_CVT_PATH');
			TES;

		    IF NOT .ZERO_FLAG
		    THEN
			BEGIN
		        IF .SIGN_FLAG
		        THEN
			    BEGIN
			    LF_SIGN[0] = .LF_SIGN[0] - %X'10';
			    IF .RT_SIGN[0] EQL %X'30'
			    THEN
				RT_SIGN[0] = %X'7B'
			    ELSE
			        RT_SIGN[0] = .RT_SIGN[0] + %X'10';
			    END

		        ELSE
			    BEGIN
			    LF_SIGN[0] = .LF_SIGN[0] - %X'19';
			    IF .RT_SIGN[0] EQL %X'30'
			    THEN
				RT_SIGN[0] = %X'7D'
			    ELSE
			        RT_SIGN[0] = .RT_SIGN[0] + %X'19';
			    END;		

			END;

		    CVTTP (SOURCE [DSC$W_LENGTH], .SOURCE [DSC$A_POINTER], LIB$AB_CVTTP_O, 
				SRC_INFO [S_LEN], .SRC_INFO [S_POINTER]);

		    ! Now put the sign back.
		    !
	            IF .SIGN_FLAG
		    THEN
			BEGIN
			IF .RT_SIGN[0] EQL %X'7B'
			THEN
			    RT_SIGN[0] = %X'30'
			ELSE
			    RT_SIGN[0] = .RT_SIGN[0] - %X'10';

			IF .LF_SIGN[0] EQL %X'30'
			THEN
			    LF_SIGN[0] = %X'7B'
			ELSE
			    LF_SIGN[0] = .LF_SIGN[0] + %X'10';

			END

		    ELSE
			BEGIN
			IF .RT_SIGN[0] EQL %X'7D'
			THEN
			    RT_SIGN[0] = %X'30'
			ELSE
			    RT_SIGN[0] = .RT_SIGN[0] - %X'19';

			IF .LF_SIGN[0] EQL %X'30'
			THEN
			    LF_SIGN[0] = %X'7D'
			ELSE
			    LF_SIGN[0] = .LF_SIGN[0] + %X'19';
		
			END;

		    IF CMPP (SRC_INFO [S_LEN], .SRC_INFO [S_POINTER], %REF (1), .PACK_ZERO) EQLU 0
		    THEN
			BLOCK [.SRC_INFO [S_POINTER] + .SRC_INFO [S_LEN]/2, 0, 0, 4, 0;, BYTE] = .BLOCK [
			    .LIB$AB_CVTTP_O + .SOURCE [DSC$A_POINTER], 0, 0, 4, 0;, BYTE];
		    END;
		END;

	    [K_S_NR, K_SD_NR]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_NR THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    LOCAL
			SOU_LEN;
		    SOU_LEN =
		    BEGIN
		    IF .SOURCE [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .SOURCE [DSC$W_LENGTH] - 1
		    END;
		    TEMP_BUF [0, 0, 8, 0] = .BLOCK [.SOURCE [DSC$A_POINTER] + .SOU_LEN, 0, 0, 8, 0;, BYTE];
		    CH$MOVE (.SOU_LEN, .SOURCE [DSC$A_POINTER], TEMP_BUF + 1);
		    SRC_INFO [S_LEN] = 31;
		    CVTSP (SOU_LEN, TEMP_BUF, SRC_INFO [S_LEN], .SRC_INFO [S_POINTER]);
		    END;
		END;

	    [K_S_NRO, K_SD_NRO]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_NRO THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_LEN] = 31;
		    CVTTP (SOURCE [DSC$W_LENGTH], .SOURCE [DSC$A_POINTER], LIB$AB_CVTTP_O,
			SRC_INFO [S_LEN], .SRC_INFO [S_POINTER]);
		    END;
		END;

	    [K_S_NZ, K_SD_NZ]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_NZ THEN 
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_LEN] = 31;
		    CVTTP (SOURCE [DSC$W_LENGTH], .SOURCE [DSC$A_POINTER], LIB$AB_CVTTP_Z,
			SRC_INFO [S_LEN], .SRC_INFO [S_POINTER]);
		    END;
		END;

	    [K_S_P, K_SD_P]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_DEC;
		IF .STATE EQL K_SD_P THEN
    		    BEGIN
    		    SRC_OR_DST_INFO [M_SCALE] = 
    			.SRC_OR_DST [DSC$B_SCALE];
    		    SRC_OR_DST_INFO [M_BIN_SCALE] = 
    			.SRC_OR_DST[DSC$V_FL_BINSCALE];
    		    END;
		IF .TURN EQL 0
		THEN
		    BEGIN
                    CVTPS (SOURCE [DSC$W_LENGTH], .SOURCE [DSC$A_POINTER], %REF (31), TEMP_BUF);
                    CVTSP (%REF (31), TEMP_BUF, %REF (31), .SRC_INFO [S_POINTER]);
                    SRC_INFO [S_LEN] = 31;
		    END;
		END;

	    [K_S_ZI]:
		.LEFT_OR_RIGHT_CVT = K_NBDS;

	    [K_D_T]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_NBDS;
		SRC_OR_DST_INFO [M_LEN] = .SRC_OR_DST [DSC$W_LENGTH];
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_POINTER] = .SOURCE [DSC$A_POINTER];
		    END;
		END;

	    [K_A_BU, K_A_T, K_NCA_BU, K_NCA_T]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_NBDS;
		IF (.SRC_OR_DST [DSC$L_ARSIZE] GTR K_LRGST_WU OR .SRC_OR_DST [DSC$B_DIMCT] NEQ 1 OR
		    .SRC_OR_DST [DSC$W_LENGTH] NEQ 1)
		THEN
		    EXITLOOP K_INVNBDS;
		IF (.STATE EQL K_NCA_BU OR .STATE EQL K_NCA_T)
		THEN
		    BEGIN
		    IF .SRC_OR_DST [DSC$L_S1] NEQ 1 THEN EXITLOOP K_INVNBDS;
		    END;
		SRC_OR_DST_INFO [M_SCALE] = .SRC_OR_DST [DSC$B_SCALE];
    		SRC_OR_DST_INFO [M_BIN_SCALE] = .SRC_OR_DST [DSC$V_FL_BINSCALE];
		SRC_OR_DST_INFO [M_LEN] = .SRC_OR_DST [DSC$L_ARSIZE];
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_POINTER] = .SOURCE [DSC$A_POINTER];
		    END;
		END;

	    [K_VS_T, K_VS_VT]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_NBDS;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_POINTER] = .SOURCE [DSC$A_POINTER] + 2;
		    SRC_INFO [S_LEN] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 16, 0;, BYTE];
		    END
		ELSE
		    DST_INFO [D_LEN] = .DESTINATION [DSC$W_LENGTH];
		END;

	    [K_VS_AC]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_NBDS;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    SRC_INFO [S_POINTER] = .SOURCE [DSC$A_POINTER] + 1;
		    SRC_INFO [S_LEN] = .BLOCK [.SOURCE [DSC$A_POINTER], 0, 0, 8, 0;, BYTE];
		    END
		ELSE
		    DST_INFO [D_LEN] = .DESTINATION [DSC$W_LENGTH];
		END;

	    [K_VS_AZ]:
		BEGIN
		.LEFT_OR_RIGHT_CVT = K_NBDS;
		IF .TURN EQL 0
		THEN
		    BEGIN
		    LOCAL
		    	SRC_PTR:  REF VECTOR[, BYTE],
		    	COUNT;
		    COUNT = 0;
		    SRC_PTR = .SOURCE[DSC$A_POINTER];
		    WHILE .SRC_PTR[.COUNT] NEQ 0 DO
			COUNT = .COUNT + 1;
		    SRC_INFO[S_LEN] = .COUNT;
		    SRC_INFO [S_POINTER] = .SOURCE [DSC$A_POINTER];
		    END
		ELSE
		    DST_INFO [D_LEN] = .DESTINATION [DSC$W_LENGTH];
		END;

	    [INRANGE, OUTRANGE]:
		$DBG_ERROR ('DBGCVTDX\FIND_CVT_PATH:  invalid final state');
	    TES;
	END
    )						! End of INCRU, with a EXITLOOP value.
    END;					! End of STATUS.


    ! Map the left and right of the conversion, (i.e. if the conversion is
    ! K_SMLINT_LRGFLTCMPLX, then LEFT_CVT is SMLINT and RIGHT_CVT is LRGFLTCMPLX)
    ! into a final conversion index and return with the status of this routine.
    !
    .CVT_PATH = (.LEFT_CVT - 1)*K_TOT_CAT + .RIGHT_CVT;
    RETURN .STATUS;
    END;					! End of routine FIND_CVT_PATH

END						! End of module DBGCVTDX.
ELUDOM
