	.NOSHOW	CONDITIONALS
	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	.TITLE	ADPSUB780 - ADAPTER SUBROUTINES FOR VAX 11/780
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	.TITLE	ADPSUB750 - ADAPTER SUBROUTINES FOR VAX 11/750
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	.TITLE	ADPSUB730 - ADAPTER SUBROUTINES FOR VAX 11/730
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	.TITLE	ADPSUB790 - ADAPTER SUBROUTINES FOR VAX 11/790
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	.TITLE	ADPSUBUV1 - ADAPTER SUBROUTINES FOR MICRO-VAX I
	.ENDC

	.IDENT	'V04-000'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Facility: System bootstrapping and initialization
;
; Abstract: This module contains initialization routines that are loaded
;	     during system initialization (rather than linked into the system).
;
; Environment: Mode = KERNEL, Executing on INTERRUPT stack, IPL=31
;
; Author:  Kerbey T. Altmann		Creation date: 30-Oct-1982
;
; Modification history:
;
;	V03-007	TCM0002		Trudy C. Matthews	04-Jun-1984
;		Include more 780-specific code for the 11/790 version of
;		this routine.
;
;	V03-006	KPL0001		Peter Lieberwirth	12-Apr-1984
;		Init ADP$L_SHB properly again; V03-004 ASSUMEd this field
;		was at a certain constant offset, and a change to the ADP
;		moved it.  Note - this is a 780 change only.
;
;	V03-005	KDM0081		Kathleen D. Morse	13-Sep-1983
;		Create version for Micro-VAX I.
;
;	V03-004	ROW0196		Ralph O. Weber		27-JUL-1983
;		Correct INI$MPMADP so the ADP$L_SHB is correctly initialized 
;		to zero.
;
;	V03-003	MSH0001		Maryann Hinden		06-Dec-1982
;		Add initialization for DW750.
;
;	V03-002	ROW0142		Ralph O. Weber		23-NOV-1982
;		Correct JMP in multiport memory interrupt dispatching code 
;		prototype, MPMINTD, to a JSB.  MA$INT expects to receive 
;		control via a JSB.
;
;	V03-001	TCM0001		Trudy C. Matthews	8-Nov-1982
;		Initialize field ADP$L_AVECTOR in INI$MPMADP.
;
;--

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	C780_LIKE = 1
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP790
	C780_LIKE = 1
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	C780_LIKE = 0
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	C780_LIKE = 0
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYPUV1
	C780_LIKE = 0
	.ENDC
;
; MACRO LIBRARY CALLS
;
	$ADPDEF				; Define ADP offsets.
	$CRBDEF				; Define CRB offsets.
	$DCDEF				; Define AT codes.
	$DDBDEF				; Define DDB offsets.
	$DDTDEF				; Define DDT offsets.
	$DYNDEF				; Define data structure type codes.
	$IDBDEF				; Define interrupt dispatcher offsets.
	$MBADEF				; Define MASSBUS registers.
	$MCHKDEF			; Define machine check masks.
	$MPMDEF				; Define multi-port memory.
	$NDTDEF				; Define nexus device types.
	$PRDEF				; Define IPR numbers.
	$PTEDEF				; Define Page Table Entry bits.
	$RPBDEF				; Define Restart Parameter Block fields.
	$SSDEF				; Define system service codes.
	$UBADEF				; Define UBA register offsets.
	$UBIDEF				; Define UNIBUS interconnect
					;  register offsets.
	$UCBDEF				; Define unit control block.
	$VADEF				; Define virtual address fields.
	$VECDEF				; Define vec offsets.
	
	.IF	NE,C780_LIKE
	$CEBDEF				; COMMON EVENT BLOCK
	$FKBDEF				; FORK BLOCK
	$IPLDEF				; INTERRUPT PRIORITY LEVELS
	$PRIDEF				; PRIORITY INCREMENT DEFINITIONS
	$PRQDEF				; INTER-PROCESSOR REQUEST
	$RSNDEF				; RESOURCE NUMBER DEFINITIONS
	$SHBDEF				; SHARED MEMORY CONTROL BLOCK
	$SHDDEF				; SHARED MEMORY DATAPAGE
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	$UASDEF				; DEFINE DW750 IPEC REGISTERS
	.ENDC

	.PSECT	SYSLOA,LONG

	.SBTTL	CI$INT - CI INTERRUPT HANDLER
;+
; CI$INT - CI INTERRUPT HANDLER
;
;	THIS MODULE IS A DUMMY CI32 INTERRUPT HANDLER WHICH IS USED
;	UNTIL THE REAL CI DRIVER (PADRIVER) IS LOADED. IT ALSO CONTAINS
;	A DUMMY CI32 CONTROLLER INITIALIZATION	ENTRY POINT.
;
; INPUTS:
;
;	THE STACK ON ENTRY IS AS FOLLOWS:
;
;		0(SP)		ADDRESS OF IDB ADDRESS
;      4(SP) - 16(SP)		SAVED R2 - R5
;	       20(SP)		INTERRUPT PC
;	       24(SP)		INTERRUPT PSL
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	INTERRUPTS ARE DISABLED ON THE CI32
;-

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1

;
; $PAREGDEF -- Define offsets to CI registers and fields in the registers.
;

	$DEFINI	PAREG

	$DEF	PA_CNF	.BLKL	1		; Configuration register

	_VIELD	PA_CNF,0,<-			; Define config register fields:
	<ADPTYP,8,M>,-				;  Adapter type code
	<PFD,,M>,-				;  Powerfail disable
	<TDEAD,,M>,-				;  Transmit dead
	<TFAIL,,M>,-				;  Transmit fail
	<,5>,-					;  5 unused bits
	<CRD,,M>,-				;  CRD on port init'd read
	<RDS,,M>,-				;  RDS on port init'd read
	<CXTER,,M>,-				;  SBI error confirm
	<RDTO,,M>,-				;  Port init'd read timeout on SBI
	<CSTMO,,M>,-				;  Port init'd command xmit timeout
	<,1>,-					;  1 unused bit
	<PUP,,M>,-				;  Adapter power up
	<PDN,,M>,-				;  Adaptor power down
	>					;

	$DEF	PA_PMC	.BLKL	1		; Port maint control/status register

	_VIELD	PA_PMC,0,<-			; Define register fields:
	<MIN,,M>,-				;  Maint initialized
	<MTD,,M>,-				;  Maint timer disable
	<MIE,,M>,-				;  Maint interrupt enable
	<MIF,,M>,-				;  Maint intterupt flag 
	>					;

	$DEFEND PAREG

CI$INT::
	MOVL	@(SP)+,R3			; GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4		; GET ADDRESS OF FIRST CSR
	MOVL	#PA_CNF_M_PUP,PA_CNF(R4)	; CLEAR POWER UP
	MOVL	#PA_CNF_M_PDN,PA_CNF(R4)	; CLEAR POWER DOWN
	MOVL	#PA_PMC_M_MIN,PA_PMC(R4)	; SET MAINTENCE INITIALIZE
	MOVQ	(SP)+,R2			; RESTORE REGISTERS
	MOVQ	(SP)+,R4
	REI

	.ENDC
	.ENDC

CI$INITIAL::					; CONTROLLER INITIALIZATION
CI$SHUTDOWN::					; CONTROLLER SHUTDOWN

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1

	MOVL	#PA_PMC_M_MIN,PA_PMC(R4)	; SET MAINTENCE INITIALIZE
	.ENDC
	.ENDC

	RSB

	.SBTTL	DR$INT - DR INTERRUPT HANDLER
;+
; DR$INT - DR INTERRUPT HANDLER
;
;	THIS MODULE IS A DUMMY DR32 INTERRUPT HANDLER WHICH IS USED
;	UNTIL THE REAL DR DRIVER (XFDRIVER) IS LOADED. IT ALSO CONTAINS
;	A DUMMY DR32 CONTROLLER INITIALIZATION	ENTRY POINT.
;
; INPUTS:
;
;	THE STACK ON ENTRY IS AS FOLLOWS:
;
;		0(SP)		ADDRESS OF IDB ADDRESS
;      4(SP) - 16(SP)		SAVED R2 - R5
;	       20(SP)		INTERRUPT PC
;	       24(SP)		INTERRUPT PSL
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	INTERRUPTS ARE DISABLED ON THE DR32
;-

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1

;
; DR32 DCR REGISTER DEFINITIONS
;-

	$DEFINI	DR
$DEF	DR_DCR		.BLKL	1	; DR32 CONTROL REGISTER
	_VIELD	DR_DCR,0,<-
		<ADPTYP,8>,-		; ADAPTER TYPE
		<ID2ERR,,M>,-		; ID2 ERROR
		<ID2TOS,2>,-		; ID2 TIME-OUT STATUS
		<,1>,-			; RESERVED
		<ID1ERR,,M>,-		; ID1 ERROR
		<ID1TOS,2>,-		; ID1 TIME-OUT STATUS
		<RDS,,M>,-		; READ DATA SUBSTITUTE
		<CRD,,M>,-		; CORRECTED READ DATA
		<DCRHLT,,M>,-		; DCR HALT
		<DCRABT,,M>,-		; DCR ABORT INTERRUPT
		<PKTINT,,M>,-		; PACKET INTERRUPT
		<INTENB,,M>,-		; INTERRUPT ENABLE
		<,1>,-			; RESERVED
		<PWR_UP,,M>,-		; ADAPTER POWER UP
		<PWR_DN,,M>,-		; ADAPTER POWER DOWN
		<EXTABT,,M>,-		; EXTERNAL ABORT
		<,1>,-			; RESERVED
		<IMPDEP,6>,-		; IMPLEMENTATION DEPENDENT BITS
	>

; DCR CONTROL FIELD A CODES (USED WHEN WRITING TO DCR)

	DCR_K_CLRPWRUP=^X100
	DCR_K_CLRPWRDN=^X200			; CLEAR POWER DOWN
	DCR_K_CLREXTABT=^X300			; CLEAR EXTERNAL ABORT
	DCR_K_CLRABTINT=^X400			; CLEAR ABORT INTERRUPT
	DCR_K_CLRINTENB=^X500			; CLEAR INTERRUPT ENABLE
	DCR_K_SETINTENB=^X600			; SET INTERRUPT ENABLE
	DCR_K_CLRHLT=^X700			; CLEAR HALT

; DCR CONTROL FIELD B CODES (USED WHEN WRITING TO DCR)

	DCR_K_CLRCRD=^X1000			; CLEAR CRD
	DCR_K_SETEXTABT=^X2000			; SET EXTERNAL ABORT
	DCR_K_CLRPKTINT=^X3000			; CLEAR PACKET INTERRUPT
	DCR_K_RESET=^X4000			; RESET
	DCR_K_SETOSQTST=^X5000			; SET OSEQ TEST
	DCR_K_CLROSQTST=^X6000			; CLEAR OSEQ TEST
	$DEFEND	DR

DR$INT::
	MOVL	@(SP)+,R3			; GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4		; GET ADDRESS OF FIRST CSR
	MOVL	#DCR_K_CLRPWRUP,DR_DCR(R4)	; CLEAR POWER UP
	MOVL	#DCR_K_CLRPWRDN,DR_DCR(R4)	; CLEAR POWER DOWN
	MOVQ	(SP)+,R2			; RESTORE REGISTERS
	MOVQ	(SP)+,R4
	REI

	.ENDC
	.ENDC

DR$INITIAL::					; CONTROLLER INITIALIZATION
DR$SHUTDOWN::					; CONTROLLER SHUTDOWN

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1

	MOVZWL	#DCR_K_RESET,(R4)		; RESET DR (R4 POINTS TO CSR)
	.ENDC
	.ENDC

	RSB

	.SBTTL	UBA$INITIAL - CPU-DEPENDENT UNIBUS ADAPTER INITIALIZATION
;+
; UBA$INITIAL - UNIBUS ADAPTER INITIALIZATION
;
; THIS ROUTINE IS CALLED VIA A JSB INSTRUCTION AT SYSTEM STARTUP AND AFTER
; A POWER RECOVERY RESTART TO ALLOW INITIALIZATION OF UNIBUS ADAPTERS.
;	(POWERFAIL AND INITADP)
; 
; INPUTS:
;
;	R2 = ADDRESS OF ADAPTER CONTROL BLOCK  (11/780 AND 11/750)
;	R4 = ADDRESS OF UNIBUS ADAPTER CONFIGURATION STATUS REGISTER (11/780)
;
;	ALL INTERRUPTS ARE LOCKED OUT.
;
; OUTPUTS:
;
;	THE UNIBUS ADAPTER IS INITIALIZED AND INTERRUPTS ARE ENABLED.
;-
 
UBA$INITIAL::				;UNIBUS ADAPTER INITIALIZATION

	.IF	NE,C780_LIKE
					;
	MCOML	#0,UBA$L_CSR(R4)	;CLEAR ALL ADAPTER CONFIGURATION ERRORS
	MCOML	#0,UBA$L_SR(R4)		;CLEAR ALL ADAPTER STATUS BITS
	MOVZWL	ADP$W_UMR_DIS(R2),R0	;PICK UP THE NUMBER OF UMR'S TO DISABLE
	ASHL	#UBA$V_CR_MRDSB-4,R0,R0	;DIVIDE BY 16 THEN SHIFT INTO POSITION
	BISL3	#UBA$M_CR_SUEFIE!-	;ENABLE INTERRUPTS
		 UBA$M_CR_BRIE!-
		 UBA$M_CR_CNFIE!-
		 UBA$M_CR_USEFIE!-
		 UBA$M_CR_IFSIE,-
		R0,UBA$L_CR(R4)
 
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750

	MOVZWL	ADP$W_TR(R2),R0		;GET TR NUMBER
	CMPW	#9,R0			;IS THIS FOR ADAPTER AT TR#9?
	BNEQ	10$			;IF NOT, DON'T BOTHER
	BISW	#UAS$M_IP_CR1_PIE, -
		@ADP$L_UBASCB+12(R2)	;SET POWERFAIL INT ENABLE IN IPEC REG

	.ENDC
	
10$:					;NO SPECIAL INIT FOR 11/730 OR uVAX I
	RSB				;
;
; IGNORE UNEXPECTED UNIBUS INTERRUPTS
;
 
	.ALIGN	LONG
 
UBA$INT0::				; PASSIVE RELEASES THROUGH VECTOR 0
 
	INCL	@#IO$GL_UBA_INT0	; COUNT THEM
	BRB	UBA_UNEXINT		; JOIN COMMON CODE, VECTORS ARE ALLIGNED
 
	.ALIGN	LONG

;
; NOTE:	UBA$UNEXINT is the label in the EXEC that is a JMP @#UBA_UNEXINT.
;	This seeming duplicity is necesary since there is code that must
;	refer to the EXEC address from within the SYSLOA image.
;
UBA_UNEXINT::				; UNEXPECTED INTERRUPT CODE

	.IF	NE,C780_LIKE
					; FOR 780-LIKE PROCESSORS, RESTORE
					; SAVED REGISTERS
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;
	.ENDC
	.IF	NE,CPU_TYPE-PR$_SID_TYP750
					; FOR 11/750, NO REGISTERS SAVED
	.ENDC
	REI				; IGNORE INTERRUPT
	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	.PAGE
	.SBTTL	MASSBUS ADAPTER INTERRUPT DISPATCHER
;+
; MBA$INT - MASSBUS ADAPTER INTERRUPT DISPATCHER
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS
; ON A MASSBUS ADAPTER. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) = SAVED R2.
;	08(SP) = SAVED R3.
;	12(SP) = SAVED R4.
;	16(SP) = SAVED R5.
;	20(SP) = INTERRUPT PC.
;	24(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	IF THE INTERRUPTING ADAPTER IS CURRENTLY OWNED AND THE OWNER UNIT
;	IS EXPECTING AN INTERRUPT, THEN THAT UNIT IS DISPATCHED FIRST. ALL
;	OTHER UNITS ARE DISPATCHED BY READING THE ATTENTION SUMMARY REG-
;	ISTER AND SCANNING FOR UNITS THAT HAVE ATTENTION SET. AS EACH UNIT
;	IS FOUND, ITS ATTENTION SUMMARY BIT IS CLEARED AND THEN A TEST IS
;	MADE TO DETERMINE IF AN INTERRUPT IS EXPECTED ON THE UNIT. IF YES,
;	THEN THE DRIVER IS CALLED AT ITS INTERRUPT RETURN ADDRESS. ELSE
;	THE DRIVER IS CALLED AT ITS UNSOLICITED INTERRUPT ADDRESS. AS EACH
;	CALL TO THE DRIVER RETURNS, THE ATTENTION SUMMARY REGISTER IS RE-
;	READ AND AN ATTEMPT IS MADE TO FIND ANOTHER UNIT TO DISPATCH. WHEN
;	NO UNITS REQUESTING ATTENTION REMAIN, THE INTERRUPT IS DISMISSED.
;-
 
	.ALIGN	LONG

MBA$INT::				;MASSBUS ADAPTER INTERRUPT DISPATCHER
	MOVL	@(SP),R3		;GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF CONFIGURATION STATUS REGISTER

	.IF	NE,C780_LIKE

	BITL	#MBA$M_CSR_PD,-
		 MBA$L_CSR(R4)		;CHECK FOR MBA POWER DOWN
	BNEQ	45$			;BRANCH IF POWERFAIL

	.IFF

	BITL	#MBA$M_SR_CBHUNG,-
		 MBA$L_SR(R4)		;CHECK FOR MBA HUNG
	BNEQ	50$			;BRANCH IF HUNG

	.IFTF

	MOVL	IDB$L_OWNER(R3),R5	;GET OWNER UNIT UCB ADDRESS
	BEQL	10$			;IF EQL NO OWNER
	MOVZBL	UCB$B_SLAVE(R5),R2	;GET OWNER SLAVE CONTROLLER NUMBER
	BBS	#UCB$V_INT,UCB$W_STS(R5),20$ ;IF SET, INTERRUPT EXPECTED
10$:	MOVL	@(SP),R3		;RETRIEVE ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;RETRIEVE MBA CONFIGURATION REGISTER ADDRESS
	MCOML	#0,MBA$L_SR(R4)		;CLEAR ALL MBA STATUS BITS
	MOVL	MBA$L_AS(R4),R2		;READ ATTENTION SUMMARY REGISTER
	FFS	#0,#8,R2,R2		;FIND FIRST UNIT REQUESTING ATTENTION
	BNEQ	20$			;IF NEQ UNIT FOUND
	ADDL	#4,SP			;REMOVE IDB ADDRESS FROM STACK
	MOVQ	(SP)+,R2		;RESTORE REGISTERS
	MOVQ	(SP)+,R4		;
	REI				;

20$:	MOVL	IDB$L_UCBLST(R3)[R2],R5	;GET ADDRESS OF UCB OR INTERRUPT DISPATCHER
	BLBS	R5,40$			;IF LBS INTERRUPT DISPATCHER FOR MULTI-
					; DEVICE CONTROLLER
	ASHL	R2,#1,MBA$L_AS(R4)	;CLEAR ATTENTION SUMMARY BIT
	TSTL	R5			;SEE IF UCB DEFINED
	BEQL	10$			;IF EQL NONE DEFINED
	BBCC	#UCB$V_INT,UCB$W_STS(R5),30$ ;IF CLR, INTERRUPT NOT EXPECTED
	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDRESS
	BRB	10$			;

30$:	MOVL	UCB$L_DDT(R5),R3	;GET ADDRESS OF DDT
	JSB	@DDT$L_UNSOLINT(R3)	;CALL UNSOLICITED INTERRUPT ROUTINE
	BRB	10$			;

40$:	MOVPSL	-(SP)			;READ CURRENT PSL
	JSB	-(R5)			;CALL SLAVE CONTROLLER INTERRUPT DISPATCHER
	BRB	10$			;

	.IFT				; FOR 11/780-LIKE PROCESSORS ONLY

;
; IN CASE OF ADAPTER POWER DOWN BIT ASSERTED, RETRIEVE ADP ADDRESS AND JUMP
; TO ADAPTER ERROR ROUTINE IN SYSLOA780.
;

45$:	MOVL	IDB$L_ADP(R3),R4	;GET ADP ADDRESS
	BRW	EXE$RH780_INT		;JUMP TO ERROR ROUTINE

	.IFF				; FOR 11/750 & 11/730

;
; IN CASE OF CBHUNG SAVE MBA INFORMATIION FOR BUGCHECK LOG AND
; BUGCHECK.  CBHUNG IS IMPLEMENTED ONLY ON THE VAX 11/750 CPU.
; IT MEANS THAT AN ACCESS TO A REGISTER OF AN EXISTENT CONTROLLER
; FAILED TO COMPLETE IN 1.5 USEC.
;

50$:	MOVL	IDB$L_OWNER(R3),R5	;SAVE OWNER UCB IF ANY
	MOVL	MBA$L_SR(R4),R0		;SAVE MBA STATUS REGISTER,
	MOVL	MBA$L_CSR(R4),R1	; CONFIGURATION REGISTER,
	MOVL	MBA$L_DR(R4),R2		; DIAGNOSTIC REGISTER,
	MOVL	IDB$L_ADP(R3),R3	;GET ADP ADDRESS
	MOVZWL	ADP$W_TR(R3),R3		;SAVE NEXUS NUMBER TO IDENTIFY
					; OFFENDING MBA
	BUG_CHECK MBACBHUNG,FATAL	;FATAL ERROR

	.ENDC				;780/750 CONDITIONAL
	.ENDC				;UV1 CONDITIONAL
	.ENDC				;730 CONDITIONAL

	.PAGE
	.SBTTL	MASSBUS ADAPTER INITIALIZATION
;+
; MBA$INITIAL - MASSBUS ADAPTER INITIALIZATION
;
; THIS ROUTINE IS CALLED VIA A JSB INSTRUCTION AT SYSTEM STARTUP AND AFTER
; A POWER RECOVERY RESTART TO ALLOW INITIALIZATION OF MASSBUS ADAPTERS.
; 
; INPUTS:
;
;	R4 = CSR ADDRESS OF MASSBUS ADAPTER.
;	R5 = ADDRESS OF ADAPTER IDB.
;
;	ALL INTERRUPTS ARE LOCKED OUT.
;
; OUTPUTS:
;
;	THE MASSBUS ADAPTER IS INITIALIZED AND INTERRUPTS ARE ENABLED.
;-
 
MBA$INITIAL::				;MASSBUS ADAPTER INITIALIZATION

	.IF	NE,CPU_TYPE-PR$_SID_TYP730
	.IF	NE,CPU_TYPE-PR$_SID_TYPUV1
	MOVL	#MBA$M_CR_INIT,-
		 MBA$L_CR(R4) 		;INITIALIZE MASSBUS ADAPTER
	MOVL	#MBA$M_CR_IE,-
		 MBA$L_CR(R4) 		;ENABLE INTERRUPTS
	.ENDC
	.ENDC

	RSB

	.SBTTL	INI$MPMADP - BUILD ADP AND INITIALIZE MULTI-PORT MEMORY
;+
; INI$MPMADP IS CALLED AFTER  MAPPING THE REGISTERS FOR A MULTI-PORT
; MEMORY ADAPTER.  AN ADAPTER CONTROL BLOCK IS ALLOCATED AND FILLED.
; THE HARDWARE ADAPTER IS THEN INITIALIZED BY CALLING MPM$INITIAL.
;
; NOTE:	THIS ROUTINE HAS BEEN LOCATED HERE IN SYSLOAXXX.EXE INSTEAD OF
;	INILOA.EXE BECAUSE IT CAN BE CALLED WHILE THE SYSTEM IS RUNNING
;	LONG AFTER INILOA.EXE HAS BEEN DELETED!!!
;
; INPUT:
;	R4 - nexus identification number of this nexus
;
; OUTPUTS:
;	ALL REGISTERS PRESERVED
;-

NUMMPMVEC = 16				; NUMBER OF INTER-PORT INTERRUPT VECTORS

INI$MPMADP::				; INITIALIZE MPM DATA STRUCTURES

	.IF	NE,CPU_TYPE-PR$_SID_TYP780
	RSB				; DUMMY ENTRY FOR SYSGEN

	.IFF
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; SAVE REGISTERS
;
; Allocate and initialize Adapter Control Block (ADP).
;
	MOVZWL	#ADP$C_MPMADPLEN+-	; GET SIZE OF ADP PLUS VECTOR
		<NUMMPMVEC * 4>,R1	; DISPATCH TABLE
	JSB	@#EXE$ALONONPAGED	; ALLOCATE ADP FOR ADAPTER
	MOVL	R2,R3			; COPY ADDRESS
	MOVL	@#MMG$GL_SBICONF,R8	; GET SYSTEM ADDRESS OF CONFIG ARRAY
	ASSUME	ADP$L_CSR EQ 0
	MOVL	(R8)[R4],(R3)+		; SET ADDRESS OF CONFIG REGISTER
	ASSUME	ADP$L_LINK EQ 4
	CLRL	(R3)+			; CLEAR LINK FIELD
	ASSUME	ADP$W_SIZE EQ 8
	MOVW	R1,(R3)+		; SET SIZE OF STRUCTURE
	MOVZBW	#DYN$C_ADP,(R3)+	; SET TYPE OF STRUCTURE
	ASSUME	ADP$W_TR EQ 12
	MOVW	R4,(R3)+		; SET NEXUS NUMBER OF ADAPTER
	ASSUME	ADP$W_ADPTYPE EQ 14
	MOVW	#AT$_MPM,(R3)+		; SET THE ADAPTER TYPE
	ASSUME	ADP$L_VECTOR EQ 16
	MOVAL	ADP$L_INTD+8(R2),R1	; GET ADDRESS OF DISPATCH TABLE
	MOVL	R1,(R3)+		; SET ADDRESS OF DISPATCH TABLE
	ASSUME	ADP$L_PRQQFL EQ 20
	ASSUME	ADP$L_PRQQBL EQ 24
	MOVL	R3,(R3)+		; INIT PRQ WAIT QUEUE FORWARD PTR.
	MOVAL	ADP$L_PRQQFL(R2),(R3)+ 	; INIT PRQ WAIT QUEUE BACKWARD PTR.
	CLRQ	ADP$L_SHB(R2)		; CLEAR SHB FIELD
;
; Initialize adapter interrupt vectors in System Control Block.
;
	MOVL	@#EXE$GL_SCB,R0		; GET ADDRESS OF SCB
	EXTZV	#0,#4,R4,R4		; Get low 4 bits of nexus number.
	MOVAL	^X100(R0)[R4],R0	; COMPUTE ADDR OF 1ST INT VECTOR
	MOVL	R0,ADP$L_AVECTOR(R2)	; SAVE ADDRESS OF ADAPTER'S SCB VECTORS
					; *** VECTORS WITHOUT JUMPER ***
	MOVAB	ADP$L_INTD+1(R2),(R0)	; CONNECT IPL 20 TO DISPATCHER
	MOVAB	W^EXE$INT58+1,64(R0)	; CONNECT IPL 21 TO ERROR LOGGER
					; *** VECTORS WITH JUMPER ***
	MOVAB	ADP$L_INTD+1(R2),128(R0) ; CONNECT IPL 22 TO DISPATCHER
	MOVAB	W^EXE$INT58+1,192(R0)	; CONNECT IPL 23 TO ERROR LOGGER
					; ***
;
; Initialize inter-port dispatcher.
;
	MOVL	B^MPMINTD,ADP$L_INTD(R2) ; INIT INTER-PORT DISPATCHER
	MOVAB	W^MA$INT,ADP$L_INTD+4(R2);  AND ADDRESS
	MOVL	#NUMMPMVEC,R0		; GET NUMBER OF VECTORS IN TABLE
10$:
	CLRL	(R1)+			; SET VECTOR TO "NOT IN USE"
	SOBGTR	R0,10$			; DECREMENT COUNT AND LOOP
	MOVL	ADP$L_CSR(R2),R4	; GET ADAPTER CSR ADDRESS
	MOVL	MPM$L_CSR(R4),R0	; GET CSR VALUE
	EXTZV	#MPM$V_CSR_PORT,-	; GET PORT NUMBER
		#MPM$S_CSR_PORT,R0,R0	;
	MOVB	R0,ADP$B_PORT(R2)	; SAVE PORT NUMBER
	BSBW	ADPLINK			; LINK ADP TO END OF CHAIN
;
; Initialize adapter hardware.
;
	BSBB	MA$INITIAL 		; INITIALIZE THE ADAPTER
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; RESTORE REGS
	RSB

MPMINTD:				; MULTI-PORT INTERRUPT DISPATCHER
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;
	JSB	@#0			;
	.IFTF
	.PAGE
	.SBTTL	MA$INITIAL - INITIALIZE MULTI-PORT MEMORY ADAPTER
;++
;
; MPM$INITIAL - INITIALIZE MULTI-PORT MEMORY ADAPTER
;
; THIS ROUTINE IS CALLED AT SYSTEM INTIALIZATION AND AFTER A POWER
; RECOVERY RESTART TO INITIALIZE THE PORT ADAPTER BY CLEARING ANY
; ERRORS AND ENABLING ALL INTERRUPTS.
;
; INPUTS:
;
;	R4 = ADDR OF ADAPTER CSR.
;
;	IPL = 31
;
; OUPUTS:
;
;	ANY ERRORS IN PORT ARE CLEARED AND ALL INTERRUPTS ARE ENABLED.
;--

MA$INITIAL::				; INTIALIZE PORT

	.IFT
	RSB

	.IFF
	CLRL	MPM$L_CR(R4)		; CLEAR INTERRUPT ENABLE AND DIAG BITS
	CLRL	MPM$L_SR(R4)		; CLEAR INVALIDATE DISABLE AND DIAG BITS
	MOVL	MPM$L_INV(R4),R0	; GET INVALIDATION REGISTER CONTENTS
	BICL	#^C<MPM$M_INV_STADR>,R0	; CLEAR ALL BITS BUT STARTING ADDRESS
	ASSUME	MPM$V_INV_ID EQ 0	; CACHED ID'S START AT BIT 0
	BISL3	#1@0,R0,MPM$L_INV(R4)	; SET CPU (NEXUS 0) AS CACHED
	CLRL	MPM$L_CSR1(R4)		; CLEAR DIAGNOSTIC BITS
	CLRL	MPM$L_MR(R4)		; CLEAR DIAGNOSTIC BITS
	MOVL	#MPM$M_CSR_PU,-		; CLEAR ANY POWER-UP STATUS
		MPM$L_CSR(R4)		;
	MOVL	#MPM$M_CR_ERRS,-	; CLEAR ANY PORT ERRORS
		MPM$L_CR(R4)		;
	MOVL	#MPM$M_SR_SS!-		; CLEAR ANY STATUS ERRORS AND
		MPM$M_SR_IDL!-		;  ENABLE ERROR INTERRUPTS
		MPM$M_SR_IT!-		;
		MPM$M_SR_AGP!-		;
		MPM$M_SR_MXF!-		;
		MPM$M_SR_ACA!-		;
		MPM$M_SR_EIE,-		;
		MPM$L_SR(R4)		;
	MOVL	#MPM$M_ERR_ELR!-	; CLEAR ANY ARRAY ERRORS
		MPM$M_ERR_IMP,-		;
		MPM$L_ERR(R4)		;
	BBS	S^#EXE$V_CRDENABL,-	; BRANCH IF CRD ERROR LOGGING ENABLED
		G^EXE$GL_DEFFLAGS,10$	;
	MOVL	#MPM$M_ERR_ICRD,-	; ELSE, INHIBIT CRD ERROR LOGGING
		MPM$L_ERR(R4)		;
10$:	MOVL	#MPM$M_CSR1_MIA,-	; CLEAR ANY ERROR
		MPM$L_CSR1(R4)		;
	CLRL	MPM$L_MR(R4)		; CLEAR ANY DIAGNOSTIC SETTINGS
	MOVL	MPM$L_CSR(R4),R0	; GET CSR REGISTER
	EXTZV	#MPM$V_CSR_PORT,-	; GET PORT NUMBER
		#MPM$S_CSR_PORT,R0,R0	;
	MULL	#MPM$C_PORTS,R0		; COMPUTE INTERRUPT ENABLE BIT #
	ADDL	#MPM$V_IIE_CTL,R0	; ...
	ASHL	R0,#^XF,MPM$L_IIE(R4)	; ENABLE INTERPORT INTERRUPTS
	MOVL	#MPM$M_CR_MIE!-		; ENABLE ALL INTERRUPTS
		MPM$M_CR_EIE,-		;
		MPM$L_CR(R4)		;
					;  FROM ALL PORTS
	RSB				; RETURN
	.IFTF
	.PAGE
	.SBTTL	INTER-PROCESSOR REQUEST HANDLER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY A DRIVER OR AN EXEC FUNCTION TO
;	EITHER SEND A REQUEST TO OR JUST INTERRUPT ANOTHER PROCESSOR
;	THAT IS CONNECTED TO A PORT OF THE MULTIPORT MEMORY.
;
; INPUTS:
;
;	R4 = ADAPTER CONTROL BLOCK ADDRESS.
;	R5 = IF LSS 0 - ADDRESS OF A FORK BLOCK TO USE IF REQUEST
;			BLOCK IS NOT AVAILABLE.
;	     IF GEQ 0 - PORT NUMBER OF PROCESSOR TO JUST INTERRUPT.
;
; OUTPUTS:
;
;	WHEN THIS ROUTINE IS CALLED WITH A FORK BLOCK ADDRESS, IT WILL
;	ATTEMPT TO ALLOCATE A REQUEST BLOCK.  IF THE REQUEST FAILS,
;	THE CONTEXT OF THE CALLER WILL BE SAVED IN THE FORK BLOCK, THE
;	FORK BLOCK BLOCK WILL BE INSERTED IN THE REQUEST BLOCK WAIT 
;	QUEUE AND A RETURN TO THE CALLER'S CALLER IS EXECUTED.
;
;	IF A REQUEST BLOCK IS ALLOCATED SUCCESSFULLY, CONTROL WILL
;	RETURN TO THE CALLER VIA A CO-ROUTINE CALL SO THE CALLER CAN
;	FILL-IN THE REQUEST BLOCK.
;
;	THE CALLER WILL THEN PERFORM ANOTHER CO-ROUTINE CALL TO RETURN
;	TO THIS ROUTINE SO THE BLOCK CAN BE INSERTED IN THE DESIRED
;	PROCESSOR'S INTER-PROCESSOR REQUEST QUEUE.  IF IT IS THE
;	FIRST REQUEST IN THE QUEUE AN INTER-PORT INTERRUPT WILL
;	ALSO BE REQUESTED TO WAKE-UP THE DISPATCHER ON THE PORT.
;
;
;	IF THIS ROUTINE IS CALLED WITH A PORT NUMBER INSTEAD OF A
;	FORK BLOCK ADDRESS, IT WILL JUST REQUEST AN INTERRUPT FOR
;	THE PROCESSOR ON THE SPECIFIED PORT.  IT IS THEN UP TO THE
;	INTERRUPTED PROCESSOR TO DETERMINE WHAT THE INTERRUPT WAS 
;	FOR.
;
;	R0 = SUCCESS OR FAILURE OF OPERATION.  THIS SHOULD BE CHECKED
;	     BY THE CALLER BOTH TIMES THIS ROUTINE RETURNS.
;
;	R3,R4,R5 ARE PRESERVED.
;
;--

MA$REQUEST::				; REQUEST HANDLER

	.IFT
	RSB

	.IFF
	MOVL	R5,R1			; FORK BLOCK ADDRESS SPECIFIED?
	BGEQ	REQ_INTERRUPT		; IF GEQ, NO - JUST AN INTERRUPT
	MOVL	ADP$L_SHB(R4),R1	; GET SHB ADDRESS
	MOVL	SHB$L_DATAPAGE(R1),R1	; GET DATAPAGE ADDRESS
	MOVZBL	ADP$B_PORT(R4),R0	; GET OUR PORT NUMBER
	BBSSI	R0,SHD$W_PRQWAIT(R1),5$	; ASSUME FAILURE (AVOID MISSING NOTIFICATION)
5$:	QRETRY	SUCCESS=10$-		; GET A REQUEST BLOCK
	REMQHI	SHD$Q_PRQ(R1),R2	;
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS CODE
	RSB				
10$:
	BVS	NOBLOCKS		; IF V-SET, NO BLOCKS LEFT
	MOVZBL	ADP$B_PORT(R4),R0	; GET OUR PORT NUMBER
	BBCCI	R0,SHD$W_PRQWAIT(R1),RETURN_BLOCK ; CLEAR WAITING FLAG
;
; RETURN ADDRESS OF REQUEST BLOCK TO CALLER
;
RETURN_BLOCK:				; RETURN ADDRESS OF BLOCK
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	JSB	@(SP)+			; CO-ROUTINE CALL CALLER BACK
;
; INSERT BLOCK IN DESIRED PORT'S REQUEST QUEUE
;
	PUSHL	R4			; SAVE REGISTER
	MOVZWL	PRQ$W_TO_PORT(R2),R1	; GET DESIRED PORT NUMBER
	MOVL	ADP$L_SHB(R4),R0	; GET SHB ADDRESS
	MOVL	SHB$L_DATAPAGE(R0),R4	; GET DATAPAGE ADDRESS
	QRETRY 	SUCCESS=10$-		; INSERT REQUEST IN PORT'S WORK QUEUE
	INSQTI	(R2),SHD$Q_PRQWRK(R4)[R1]
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS CODE
	BRB	20$			;
10$:	BEQL	30$			; IF EQL, FIRST ENTRY IN QUEUE
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
20$:	POPL	R4			; RESTORE REGISTER
	RSB				;

30$:	POPL	R4			; RESTORE REGISTER
;
; REQUEST AN INTER-PORT INTERRUPT TO WAKE-UP PROCESSOR ON DESIRED
; PORT.
;
REQ_INTERRUPT:				; REQUEST AN INTER-PORT INTERRUPT
	MOVZBL	ADP$B_PORT(R4),R0	; GET OUR PORT NUMBER
	MULL	#MPM$C_PORTS,R0		; COMPUTE INTERRUPT REQUEST BIT #
	ADDL	R1,R0			; ...
	ADDL	#MPM$V_IIR_CTL,R0	; ...
	MOVL	ADP$L_CSR(R4),R1	; GET ADAPTER CSR ADDRESS
	ASHL	R0,#1,MPM$L_IIR(R1)	; SET PORT INTERRUPT REQUEST BIT
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	RSB				;
;
; NO BLOCKS ARE AVAILABLE.  SAVE THE CALLER'S CONTEXT IN THE FORK
; BLOCK, INSERT THE FORK BLOCK IN THE REQUEST BLOCK WAIT QUEUE, AND
; RETURN TO THE CALLER'S CALLER.
;
NOBLOCKS:				; NO REQUEST BLOCKS AVAILABLE
	MOVQ	R3,FKB$L_FR3(R5)	; SAVE REGISTERS
	POPL	FKB$L_FPC(R5)		; SAVE RETURN ADDRESS
	INSQUE	(R5),@ADP$L_PRQQBL(R4)	; INSERT FORK BLOCK IN WAIT QUEUE
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	RSB				; RETURN TO CALLER'S CALLER
	.IFTF
	.PAGE
	.SBTTL	REPORT RESOURCE AVAILABILITY TO INTERESTED PORTS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO REPORT TO ANY PROCESSORS THAT A RESOURCE
;	HAS BEEN MADE AVAILABLE.
;
; INPUTS:
;
;	R0 = RESOURCE NUMBER OF RESOURCE MADE AVAILABLE.
;	R1 = SHARED MEMORY CONTROL BLOCK (SHB) ADDRESS.
;
; OUTPUTS:
;
;	ANY PROCESSORS WAITING FOR THE SPECIFIED RESOURCE ARE INTERRUPTED
;	TO NOTIFY THEM THE RESOURCE IS AVAILABLE.
;
;	R0,R1,R2,R3 ARE NOT PRESERVED.
;--

MA$RAVAIL::

	.IFT
	RSB

	.IFF
	MOVL	SHB$L_DATAPAGE(R1),R2	; GET ADDRESS OF DATAPAGE
	TSTW	SHD$W_RESWAIT(R2)[R0]	; ANYONE WAITING FOR THE RESOURCE?
	BEQL	30$			; IF EQL, NO
	PUSHL	SHB$L_ADP(R1)		; SAVE ADDRESS OF ADAPTER CONTROL BLOCK
	CLRL	R3			; INIT PORT NUMBER

10$:	MOVAW	SHD$W_RESWAIT(R2)[R0],R1 ; GET ADDRESS OF RESOURCE WAIT MASK
	BBC	R3,(R1),20$ 		; IF CLR, NO ONE WAITING AT PORT
	MOVAW	SHD$W_RESAVAIL(R2)[R0],R1 ; GET ADDRESS OF AVAILABLE MASK
	BBSSI	R3,(R1),15$		; SET PORT'S RESOURCE AVAIL BIT
15$:	BBSSI	R3,SHD$W_RESSUM(R2),20$ ; SET PORT'S RESOURCE AVAIL SUMMARY BIT
20$:	AOBLSS	#MPM$C_PORTS,R3,10$	; INCREMENT PORT NUMBER AND LOOP
	POPL	R3			; GET ADDRESS OF ADAPTER CONTROL BLOCK
	MOVZWL	SHD$W_RESWAIT(R2)[R0],R1 ; GET RESOURCE WAIT MASK
	BSBW	INTERRUPT_PORTS		; INTERRUPT WAITING PORTS
30$:	RSB				;
	.PAGE
	.SBTTL	INTER-PORT INTERRUPT DISPATCHER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT
;	OCCURS ON A MULTI-PORT MEMORY.  THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF BYTE FOLLOWING "JSB  @#MA$INT" IN ADP$L_INTD.
;	04(SP) - 24(SP) = SAVED R0 - R5.
;	28(SP) = INTERRUPT PC.
;	32(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	THE FIRST REQUEST BLOCK IN THIS PORT'S INTER-PROCESSOR REQUEST
;	QUEUE IS DEQUEUED.  THE REQUEST BLOCK IS THEN USED AS A FORK
;	BLOCK WHICH IS THEN ENTERED INTO THE LOWEST IPL DEVICE DRIVER
;	FORK QUEUE.  IF THE FORK BLOCK WAS THE FIRST IN THE FORK QUEUE,
;	A SOFTWARE INTERRUPT IS POSTED TO DISPATCH THE FORK PROCESS WHEN
;	THE IPL IS LOW ENOUGH.  WHEN ALL THE REQUEST BLOCKS HAVE BEEN
;	DEQUEUED FROM THE PORT'S INTER-PROCESSOR REQUEST QUEUE, AND
;	REQUEUED TO THE FORK QUEUE, THE INTERRUPT IS DISMISSED.
;--

MA$INT:					; MA780 INTERRUPT DISPATCHER

	MOVL	(SP)+,R3		; GET ADDRESS OF BYTE IN ADP
	MOVAB	-<ADP$L_INTD+8>(R3),R3	; COMPUTE ADDRESS OF ADP
	MOVL	ADP$L_CSR(R3),R0	; GET CSR ADDRESS
	MOVZBL	ADP$B_PORT(R3),R2	; GET PORT NUMBER
	MULL3	#MPM$C_PORTS,R2,R1	; COMPUTE INTERRUPT REQUEST BIT #
	ASHL	R1,#^XF,MPM$L_IIR(R0)	; CLEAR ANY INTERRUPT REQUESTS
	MOVL	ADP$L_SHB(R3),R4	; GET ADDRESS OF SHB
	BNEQ	10$			; IF NEQ, MEMORY CONNECTED
	BRW	INT_EXIT		; ELSE, IGNORE INTERRUPT
10$:	MOVL	SHB$L_DATAPAGE(R4),R4	; GET ADDRESS OF DATAPAGE
					; R2 = PORT NUMBER
					; R3 = ADP ADDRESS
					; R4 = DATAPAGE ADDRESS
	PUSHR	#^M<R3,R4>		; SAVE R3-R4
	BBSSI	R2,SHD$W_POLL(R4),DEQUEUE_BLOCK ; INDICATE THIS PROCESSOR ACTIVE
;
; DEQUEUE THE NEXT REQUEST BLOCK IN OUR WORK QUEUE AND REQUEUE TO THE
; APPROPRIATE FORK QUEUE.
;
DEQUEUE_BLOCK:				; DEQUEUE NEXT REQUEST BLOCK
	MOVQ	(SP),R3			; RESTORE R3-R4
	QRETRY	SUCCESS=10$-		; DEQUEUE THE NEXT REQUEST BLOCK
	REMQHI	SHD$Q_PRQWRK(R4)[R2],R5	;
	BUG_CHECK BADQHDR		; REMQHI FAILED - BAD QUEUE HEADER
10$:	BVS	BLOCK_AVAIL		; IF V-SET, NO BLOCKS LEFT
	PUSHAB	DEQUEUE_BLOCK		; SET RETURN PC
	PUSHAB	W^REQUEST_DISP		; SET FORK PC
	JMP	G^EXE$FORK		; INSERT BLOCK IN FORK QUEUE
;
; IF THERE ARE ANY FORK PROCESSES ON THIS PROCESSOR WAITING FOR INTER-PROCESSOR
; REQUEST BLOCKS, AND IF ANY BLOCKS ARE NOW AVAILABLE, GIVE THEM TO THE
; PROCESSES AND RESTART THEM.
;
BLOCK_AVAIL:				; CHECK IF ANY BLOCKS AVAILABLE
	BBC	R2,SHD$W_PRQWAIT(R4),RESOURCE_AVAIL ; IF CLR, NO PROCESSES WAITING
10$:	MOVQ	(SP),R3			; RESTORE R3-R4
	QRETRY	SUCCESS=20$-		; ATTEMPT TO ALLOCATE A FREE BLOCK
	REMQHI	SHD$Q_PRQ(R4),R5	;
	BUG_CHECK BADQHDR		; REMQHI FAILED - BAD QUEUE HEADER
20$:	BVS	RESOURCE_AVAIL		; IF V-SET, NO BLOCK AVAILABLE
	REMQUE	@ADP$L_PRQQFL(R3),R1	; GET NEXT WAITING FORK BLOCK
	BNEQ	30$			; IF NEQ, NOT LAST ENTRY
	BBCCI	R2,SHD$W_PRQWAIT(R4),30$ ; ELSE LAST, CLEAR WAITING FLAG
30$:	BVS	50$			; IF SET, NO PROCESSES LEFT
	MOVL	R1,R3			; SET ADDRESS OF FORK BLOCK
	MOVB	FKB$B_FIPL(R3),FKB$B_FIPL(R5) ; SET FORK IPL
	PUSHAB	B^10$			; SET RETURN PC
	PUSHAB	B^40$			; SET FORK PC
	JMP	G^EXE$FORK		; INSERT BLOCK IN FORK QUEUE
40$:
	MOVL	R5,R2			; SET ADDRESS OF REQUEST BLOCK
	MOVL	R3,R5			; SET ADDRESS OF DRIVER FORK BLOCK
	MOVQ	FKB$L_FR3(R5),R3	; RESTORE REGISTERS
	PUSHL	FKB$L_FPC(R5)		; SET RETURN ADDRESS OF HANDLER CALLER
	BRW	RETURN_BLOCK		; RETURN TO HANDLER
	RSB				;
50$:
	BSBW	DEALLOC_BLOCK		; DEALLOCATE UNEEDED BLOCK
;
; IF THERE IS A RESOURCE NOW AVAILABLE THAT PROCESS(S) ON THIS PROCESSOR
; ARE WAITING FOR, CREATE A FORK PROCESS TO REPORT THE AVAILABILITY TO
; THE SCHEDULER.
;
RESOURCE_AVAIL:				;
	BBC	R2,SHD$W_RESSUM(R4),50$ ; IF CLR, NONE TO REPORT
	BBSSI	R2,SHD$W_PRQWAIT(R4),50$ ; ASSUME NO BLOCKS AVAILABLE
					; AND IF THERE ALREADY AREN'T, EXIT
	QRETRY	SUCCESS=20$-		; ATTEMPT TO ALLOCATE A BLOCK
	REMQHI	SHD$Q_PRQ(R4),R5	;
	BUG_CHECK BADQHDR		; REMQHI FAILED - BAD QUEUE HEADER
20$:	BVS	50$			; IF V-SET, NO BLOCK AVAILABLE
	BBCCI	R2,SHD$W_PRQWAIT(R4),30$ ; CLEAR WAIT FLAG
30$:	BBCCI	R2,SHD$W_RESSUM(R4),40$	; CLEAR RESOURCE REPORT SUMMARY
40$:	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5) ; SET FORK IPL
	MOVW	#PRQ$C_EXEC,PRQ$W_DISPATCH(R5) ; SET EXEC DISPATCHER ID
	MOVW	#PRQ$C_RESAVL,PRQ$W_REQTYPE(R5) ; SET RESOURCE AVAILABLE TYPE
	PUSHAB	B^50$			; SET RETURN PC
	PUSHAB	W^REQUEST_DISP		; SET FORK PC
	JMP	G^EXE$FORK		; CREATE FORK PROCESS
50$:	ADDL	#8,SP			; REMOVE SAVED R3-R4
INT_EXIT:				; EXIT INTERRUPT
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	REI				;
	.PAGE
	.SBTTL	INTER-PROCESSOR REQUEST DISPATCHER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY THE FORK PROCESS DISPATCHER WHEN
;	IT DISPATCHES A FORK BLOCK THAT IS AN INTER-PROCESSOR REQUEST
;	BLOCK.
;
; INPUTS:
;
;	R0-R2 = SCRATCH.
;	R3 = ADAPTER CONTROL BLOCK ADDRESS.
;	R4 = SHARED MEMORY DATAPAGE ADDRESS.
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS.
;
; DISPATCHING OCCURS AS FOLLOWS:
;
;	THE REQUEST DISPATCHER ID CODE IS EXAMINED AND IF IT IS
;	AN EXECUTIVE REQUEST (PRQ$C_EXEC) THEN THE EXEC REQUEST HANDLER
;	IS CALLED.  IF IT IS NOT THE EXECUTIVE REQUEST ID, THE ID
;	CODE IS USED AS AN INDEX INTO THE DRIVER DISPATCHER VECTOR
;	TABLE TO CALL THE DRIVER INTER-PROCESSOR REQUEST DISPATCHER.
;
;	WHEN THE CALLED DISPATCHER RETURNS, THE REQUEST BLOCK IS
;	DEALLOCATED TO THE SHARED MEMORY REQUEST QUEUE AND A RETURN
;	TO THE FORK PROCESS DISPATCHER IS EXECUTED.
;
;--
REQUEST_DISP:				; PROCESSOR REQUEST DISPATCHER
	PUSHR	#^M<R3,R4,R5>		; SAVE REGISTERS
	ASSUME	PRQ$C_EXEC EQ 0
	MOVZWL	PRQ$W_DISPATCH(R5),R1	; GET DISPATCHER ID
	BNEQ	10$			; IF NEQ, NOT EXECUTIVE REQUEST
;
; CALL APPROPRIATE EXECUTIVE INTER-PROCESSOR REQUEST HANDLER
;
	PUSHAB	B^15$			; SET RETURN ADDRESS
	CASE	PRQ$W_REQTYPE(R5),<-	; CALL REQUEST HANDLER
		SETEF,-			;  UPDATE EVENT FLAGS
		RESAVL-			;  REPORT RESOURCE AVAILABLE
		>			;
5$:	BUG_CHECK UNKNPRQ		; UNKNOWN REQUEST ID
	BRB	15$			;
;
; CALL CLASS DRIVER INTER-PROCESSOR REQUEST DISPATCHER
;
10$:
	MOVL	ADP$L_VECTOR(R3),R0	; GET ADDRESS OF VECTOR TABLE
	MOVL	(R0)[R1],R0		; GET ADDRESS OF DISPATCHER
	BEQL	15$			; IF EQL, UNUSED VECTOR
					; (CAN OCCUR AFTER CRASH IF REQUESTS ARE LEFT)
	JSB	(R0)			; CALL DRIVER DISPATCHER
15$:
	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
;
; DEALLOCATE THE REQUEST BLOCK
;
DEALLOC_BLOCK:				; DEALLOCATE THE REQUEST BLOCK
	QRETRY	SUCCESS=10$-		; DEALLOCATE REQUEST BLOCK
	INSQTI	(R5),SHD$Q_PRQ(R4)	;
	BUG_CHECK BADQHDR		; INSQTI FAILED - BAD QUEUE HEADER
10$:
	MOVZWL	SHD$W_PRQWAIT(R4),R1	; AN PROCESSORS WAITING FOR A BLOCK?
	BEQL	20$			; IF EQL, NO
	BSBB	INTERRUPT_PORTS		; NOTIFY WAITING PORTS
20$:	RSB				;
	.PAGE
	.SBTTL	INTERRUPT_PORTS - ROUTINE TO INTERRUPT SELECTED PORTS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS THE INTERRUPT REQUEST BITS FOR THE SELECTED PORTS.
;
; INPUTS:
;
;	R1 = MASK OF PORTS TO BE INTERRUPTED.
;	R3 = ADAPTER CONTROL BLOCK ADDRESS
;--
INTERRUPT_PORTS:			;
	MOVZBL	ADP$B_PORT(R3),R0	; GET OUR PORT NUMBER
	MULL	#MPM$C_PORTS,R0		; COMPUTE INTERRUPT REQUEST BIT #
	ADDL	#MPM$V_IIR_CTL,R0	; ...
	ASHL	R0,R1,R0		; ...
	MOVL	ADP$L_CSR(R3),R1	; GET ADAPTER CSR ADDRESS
	MOVL	R0,MPM$L_IIR(R1)	; SET PORTS' INTERRUPT REQUEST BIT(S)
	RSB				;
	.PAGE
	.SBTTL	UPDATE LOCAL COPY OF EVENT FLAG CLUSTER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE HANDLES THE INTER-PROCESSOR REQUEST TO COPY THE MASTER
;	COMMON EVENT FLAGS INTO THE SLAVE COMMON EVENT BLOCK.  SOME PRQS
;	MAY BE DELIVERED AFTER THE SLAVE COMMON EVENT BLOCK HAS BEEN
;	DELETED.  THIS HAPPENS FREQUENTLY AFTER A PROCESSOR CRASHES
;	AND REBOOTS.  THE LOGIC HANDLES THIS BY IGNORING THE PRQ.
;
; INPUTS:
;
;	R4 = SHARED MEMORY DATA PAGE ADDRESS
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL - SUCCESSFUL RETURN
;--
SETEF:
	DSBINT	#IPL$_SYNCH		; RAISE TO SYNCH FOR REFCNT CHANGE
	MOVZWL	PRQ$L_PARAM(R5),R0	; GET INDEX TO MASTER CEB
	ADDL3	SHD$L_CEFPTR(R4),R4,R3	; GET ADR OF 1ST MASTER CEB
	MOVZWL	CEB$W_SIZE(R3),R2	; GET THE SIZE OF ONE MASTER CEB
	MULL2	R0,R2			; GET BYTE OFFSET TO THIS MASTER
	ADDL2	R2,R3			; R3=ADR OF MASTER CEB
	MOVZWL	PRQ$W_TO_PORT(R5),R1	; RECEIVER PORT #
	MOVL	CEB$L_VASLAVE1(R3)[R1],R1 ; R1=ADR OF SLAVE CEB, OR 0
	BEQL	40$			; BR IF SLAVE NO LONGER EXISTS
	MOVL	CEB$L_EFC(R3),CEB$L_EFC(R1) ; COPY FLAGS FROM MASTER
	PUSHR	#^M<R3,R4,R5,R6>	; SAVE REGISTERS
	MOVAB	CEB$L_WQFL(R1),R6	; GET HEAD OF WAIT QUEUE FOR CEFC
	MOVZBL	#PRI$_IOCOM,R2		; SET PRIORITY INCREMENT
	MOVL	(R6),R4			; GET FIRST PCB IN WAIT QUEUE
20$:	CMPL	R4,R6			; IS THIS THE END OF THE QUEUE?
	BEQL	30$			; BR IF END OF QUEUE
	MOVL	(R4),R5			; REMEMBER NEXT PCB IN QUEUE
	MOVAL	<CEB$L_EFC-CEB$L_WQFL>(R6),R0 ; POINT TO EVENT FLAG MASK
	JSB	G^EXE$CHKWAIT2		; CHECK IF THE PROCESS CAN RUN NOW
	MOVL	R5,R4			; GET NEXT PCB IN WAIT QUEUE
	BRB	20$			; CONTINUE LOOPING THROUGH ALL OF QUEUE
30$:					; NO MORE PCB'S IN WAIT QUEUE
	POPR	#^M<R3,R4,R5,R6>	; RESTORE REGISTERS
40$:					; NO SLAVE CEB EXISTED, SO NO WAITERS
	MOVZBL	#SS$_NORMAL,R0		; RETURN SUCCESS STATUS
	ENBINT				; LOWER FROM SYNCH
	RSB				; RETURN
	.PAGE
	.SBTTL	REPORT RESOURCE AVAILABILITY TO LOCAL SYSTEM
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE HANDLES THE INTERPROCESSOR REQUEST TO REPORT
;	THAT A RESOURCE IS AVAILABLE TO THE LOCAL SYSTEM.
;
; INPUTS:
;
;	R3 = ADAPTER CONTROL BLOCK ADDRESS.
;	R4 = SHARED MEMORY DATAPAGE ADDRESS.
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS.
;
; OUTPUTS:
;
;	RESOURCE AVAILABILITY IS REPORTED, THEREBY UNBLOCKING ANY PROCESSES
;	THAT ARE WAITING FOR THE RESOURCE.
;--
RESAVL:					;
	DSBINT	#IPL$_SYNCH		; SYNCHRONIZE DATABASE ACCESS
	MOVZBL	ADP$B_PORT(R3),R2	; GET OUR PORT NUMBER
	PUSHR	#^M<R2,R3>		; SAVE REGISTERS
	MOVL	#1,R0			; INIT RESOURCE NUMBER

10$:	MOVAW	SHD$W_RESAVAIL(R4)[R0],R1 ; GET ADDRESS OF AVAILABLE MASK
	BBCCI	(SP),(R1),20$		; IF CLR, RESOURCE NOT AVAILABLE
	MOVAW	SHD$W_RESWAIT(R4)[R0],R1 ; GET ADDRESS OF WAIT MASK
	BBCCI	(SP),(R1),20$		; IF CLR, NO PROCESSES WAITING
	JSB	G^SCH$RAVAIL		; REPORT RESOURCE AVAILABLE
20$:	AOBLSS	#RSN$_MAX,R0,10$	; INCREMENT RESOURCE NUMBER AND LOOP
	POPR	#^M<R2,R3>		; RESTORE REGISTERS
	ENBINT				; RESTORE IPL
	RSB

	.ENDC
	.END
