MODULE SOR$INTERFACE (
		IDENT = 'V04-000')=	! File: SORINTERF.B32 Edit: PDG3059
BEGIN
MACRO		IDENT = 'V03-059' %;
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:	VAX-11 SORT/MERGE
!
! ABSTRACT:
!
!	This module contains the user-visible interface routines to Sort/Merge.
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: Peter D Gilbert, CREATION DATE: 07-Jan-1982
!
! MODIFIED BY:
!
!	T03-015		Original
!	T03-019	Use COM_RDT_SIZ (instead of COM_FORMATS) to determine whether
!		spec file processing is needed.  PDG 13-Dec-1982
!	T03-020	Free COM_WRK_EFN.  If DDB_CHAN is non-zero, deass the channel.
!		PDG 30-Dec-1982
!	T03-021	Make work-file description blocks (WFBs) distinct from DDBs.
!		PDG 31-Dec-1982
!	T03-022	Change stat names to SOR$K_xxx.  PDG 3-Jan-1983
!	T03-023	Add clean-up routines.  Make the deallocation routine global,
!		and have it clear the address.  PDG 4-Jan-1983
!	T03-024	Allow SOR$STATISTIC to be called at any time.  PDG 5-Jan-1983
!	T03-025	New interface for collating sequence.  PDG 26-Jan-1983
!	T03-026	Change WRK_USE to WRK_ALQ.  Allow stable option for merges.
!		PDG 27-Jan-1983
!	T03-027	Use COM_MERGE (rather than COM_MRG_ORDER) to indicate a merge.
!		PDG 31-Jan-1983
!	T03-028	Changes for hostile environment.  PDG 3-Feb-1983
!	T03-029	Some fixes for asynchronous aborts.  PDG 4-Feb-1983
!	T03-030	Call COLL$TIE_BREAK for DEC_MULTI.  PDG 16-Feb-1983
!	T03-031	Complete asynchronous aborts.  PDG 28-Feb-1983
!	T03-032	Changed name of SOR$STAT.  PDG 3-Mar-1983
!	T03-033	Return worst status encountered.  PDG 7-Mar-1983
!	T03-034	Remove need for COLL$COMPRESS.  PDG 5-Apr-1983
!	T03-035	Give the SOR$RO_CODE__n PSECTs the EXE attr.  PDG 7-Apr-1983
!	T03-036	SIGNAL option changed to NOSIGNAL.  PDG 11-Apr-1983
!	T03-037	Reverse sense of tie-breaking only for DEC_MULTI.
!		Information hiding of WFB structure.  PDG 12-Apr-1983
!	T03-038	Fix access violation if END_SORT called when there's no
!		context area for the sort/merge.  PDG 14-Apr-1983
!	T03-039	Always reverse sense of tie-breaking.  PDG 18-Apr-1983
!	T03-040	Recover from RMS$_RTB errors.  PDG 21-Apr-1983
!	T03-041	Correctly set the COM_SIGNAL flag.  PDG 27-Apr-1983
!	V03-042	Change ident.  PDG 28-Apr-1983
!	V03-043	Make the SOR$$END_PSECTs long-relative.  PDG 2-Mar-1983
!	V03-044	Improve code in the $PUT loop.  PDG 11-May-1983
!	V03-045	Make RETURN_REC keep returning SS$_ENDOFFILE.  PDG 14-Jul-1983
!	V03-046	Don't complain so much if LIB$FREE_VM fails.  PDG 31-Aug-1983
!		Return useful STAT_K_INI_RUNS during dispersion phase.
!	V03-047	Add support for checkpointing.  PDG 28-Sep-1983
!	V03-048	Fix error in comparing worst severities.  PDG 14-Dec-1983
!	V03-049	Check for specifying both NODUPS and STABLE.  PDG 16-Dec-1983
!	V03-050	Make SOR_CONTEXT not writable if hostile.  PDG 16-Dec-1983
!	V03-051	For hostile sorts, default the value of FILE_ALLOC here,
!		since SOR$$OPEN is not called.  PDG 24-Jan-1984
!	V03-052	Call SOR$$EBCDIC to initialize EBCDIC tables.  PDG 31-Jan-1984
!	V03-053	Add COLL_DESC parameter to SOR$SPEC_FILE.  PDG 22-Feb-1984
!	V03-054	Add comments on the calculation for TREE_INIT.  PDG 13-Mar-1984
!	V03-055	Add VAXELN specific code.  Jeff East 1/2/84
!	V03-056	Add recovery from RMS$_RLK errors.  PDG 2-Apr-1984
!	V03-057	Minor changes allocating buffers for MERGE.  PDG 9-Apr-1984
!	V03-058	Set context longword back to zero within the CONTEXT_ macro
!		if END_SORT is called with zero context.  PDG 15-May-1984
!	V03-059	Change COM_RHB to COM_RHB_INP and COM_RHB_OUT.
!		This is to avoid problems with merge, where an incoming
!		record overwrites the VFC area for the outgoing record.
!		PDG 24-Jul-1984
!--

LIBRARY	'SYS$LIBRARY:STARLET';
REQUIRE	'SRC$:COM';

%IF NOT HOSTILE %THEN
OWN
    SOR_CONTEXT:	REF BLOCK;		! Default sort context info
%ELSE
BIND
    SOR_CONTEXT=	UPLIT(0);		! Longword not writable
%FI

LITERAL
    REG_INI_CTX = 3;
LINKAGE
    AND_RETURN_R1 = CALL(;REGISTER=1),
    JSB_INI_CTX = JSB(REGISTER=REG_INI_CTX):
	NOPRESERVE(0,1,2,4,5)
	NOTUSED(6,7,8,9,10)
	GLOBAL(CTX=COM_REG_CTX);

FORWARD ROUTINE
    COND_HAND,					! Handle exception conditions
    SOR$$ERROR,					! Issue error diagnostic
    INI_CTX:		JSB_INI_CTX NOVALUE,	! Initialize context area
    SOR$$ALLOCATE:	CAL_CTXREG,		! Allocate storage
    SOR$$DEALLOCATE:	CAL_CTXREG NOVALUE,	! Deallocate storage
    SOR$BEGIN_SORT,				! Initialize the sort
    SOR$SORT_MERGE,				! Sort or merge the data
    SOR$RELEASE_REC,				! Release record to sort/merge
    SOR$RETURN_REC,				! Return record from sort/merge
    AST_END_SORT:	JSB_INI_CTX,		! Asynchronous termination
    SOR$END_SORT,				! Termination routine
    SOR$BEGIN_MERGE,				! Initialize the merge
    %IF NOT HOSTILE %THEN
    CLOSE_FILE:		CAL_CTXREG NOVALUE,	! Close a file
    FREE_DDBS:		CAL_CTXREG NOVALUE,	! Free storage for list of DDBs
    MRG_OUTPUT:		CAL_CTXREG NOVALUE,	! Merge into the output file
    SOR$PASS_FILES:	AND_RETURN_R1,		! Pass file information to sort
    SOR$SPEC_FILE,				! Process the specification file
    %FI
    SOR$STAT;					! Get a statistic

LITERAL
    SOR_K_END_AST =	TRUE;	! Indicates SOR$END_SORT should work with ASTs

%IF HOSTILE
%THEN
    MACRO
	LIB$GET_VM = SOR$LIB$GET_VM %,
	LIB$FREE_VM = SOR$LIB$FREE_VM %,
	LIB$SIGNAL = SOR$LIB$SIGNAL %,
	LIB$AST_IN_PROG = SOR$LIB$AST_IN_PROG %,
	SYS$CLRAST = SOR$SYS$CLRAST %,
	SYS$DCLAST = SOR$SYS$DCLAST %,
	SYS$UNWIND = SOR$SYS$UNWIND %,
	SYS$ADJWSL = SOR$SYS$ADJWSL %;
%FI

! Define user-visible literals
!
MACRO
    FNV_(O,P,S,E) = P %,
    FNM_(O,P,S,E) = 1^P %,
    DFX_(A,B,C)[D] = %NAME(A,D) = C (%NAME(B,D)) %;
MACRO
    OPTION_FIELDS =
	'EBCDIC',
!	'FIXED',
	'MULTI',
	'NODUPS',
	'NOSIGNAL',
	'SEQ_CHECK',
	'STABLE',
	'LOAD_FILL' %;

GLOBAL LITERAL
    DFX_('SOR$GK_', 'TYP_K_', ,
	'RECORD', 'TAG', 'INDEX', 'ADDRESS'),
    DFX_('SOR$M_', 'OPT_', %QUOTE FNM_, OPTION_FIELDS),
    DFX_('SOR$V_', 'OPT_', %QUOTE FNV_, OPTION_FIELDS),
    DFX_('SOR$K_', 'STAT_K_', ,
	'MAX_STAT', 'IDENT', 'REC_INP', 'REC_SOR', 'REC_OUT', 'LRL_INP',
	'LRL_INT',
	'LRL_OUT', 'NODES', 'INI_RUNS', 'MRG_ORDER', 'MRG_PASSES', 'WRK_ALQ',
	'MBC_INP', 'MBC_OUT', 'MBF_INP', 'MBF_OUT');

! Macros to test for optional parameters.
!
!   FIRSTPARAMETER_
!	Define the first parameter, for use by PRESENT_ and NULL_.
!
!   PRESENT_
!	Test for a parameter present.
!
!   NULL_
!	Test for a parameter present, and whether it equals zero.
!
MACRO
    PRESENT_(X) =
	BEGIN
	BUILTIN ACTUALCOUNT;
	LITERAL Y__ = 1+(X-FIRSTPARAMETER__)/%UPVAL;
	ACTUALCOUNT() GEQU Y__
	END %,
    NULL_(X) =
	BEGIN
	BUILTIN NULLPARAMETER;
	LITERAL Y__ = 1+(X-FIRSTPARAMETER__)/%UPVAL;
	NULLPARAMETER(Y__)
	END %,
    FIRSTPARAMETER_(X) =
	MACRO FIRSTPARAMETER__ = X %QUOTE % %;

! Macro to return status from the user-visible routines
! Note that all successful returns from the user-visible routines
! (except END_SORT and STAT) should use this macro, passing SS$_NORMAL.
!
MACRO
    RETURN__(X) =
	BEGIN
	%IF SOR_K_END_AST %THEN CTX__[0] = .CTX__[0] AND NOT %B'1'; %FI
	%IF %IDENTICAL(X, SS$_NORMAL)
	%THEN
	    CTX[COM_FLO_ABORT] = FALSE;
	    RETURN .CTX[COM_WORST]
	%ELSE
	    RETURN X
	%FI
	END %;

! Macro to get the address of common context information.
!
MACRO
    CONTEXT_(CONTEXT,ERR) =
	GLOBAL REGISTER
	    CTX = COM_REG_CTX:	REF CTX_BLOCK;
	LOCAL
	    CTX__:	REF VECTOR[1] VOLATILE;	! Address of context longword
	ENABLE
	    COND_HAND(CTX__);
	BEGIN
	BUILTIN
	    TESTBITSS;
	REGISTER
	    P__ = REG_INI_CTX:	REF VECTOR[1];	! Address of context pointer
	MACRO
	    IS_END_SORT	= NOT %NULL(ERR) AND ERR+0 %QUOTE %,
	    IS_STAT	= NOT %DECLARED(COM_FLO_ABORT) %QUOTE %;
	!
	! Get the address to store the address of the context area.
	! If the context parameter is missing, use the default context pointer.
	! If present and non-zero, use it.
	! If present and zero, use the default context pointer.
	!
	%IF NOT HOSTILE
	%THEN
	    IF NOT PRESENT_(CONTEXT) THEN P__ = SOR_CONTEXT
	    ELIF (P__ = .CONTEXT) NEQ 0 THEN 0
	    ELSE P__ = SOR_CONTEXT;
	%ELSE
	    P__ = .CONTEXT;
	%FI
	%IF NOT IS_STAT
	%THEN
	    CTX__ = P__[0];
	%FI
	!
	! Test and set the synchronization bit to see whether any other
	! routines for this sort/merge are currently active.
	!
	%IF SOR_K_END_AST AND NOT IS_STAT
	%THEN
	    IF TESTBITSS(P__[0])
	    THEN
		%IF IS_END_SORT
		%THEN
		    RETURN AST_END_SORT(P__[0])
		%ELSE
		    ! Only END_SORT and STAT may be called asynchronously.
		    !
		    RETURN SOR$_SORT_ON
		%FI;
	%FI
	!
	! Fetch the address of the context area
	!
	IF (CTX = .P__[0] AND NOT %B'1') EQL 0
	THEN
	    %IF %NULL(ERR)
	    %THEN
		BEGIN
		!
		! Allocate and initialize the context area
		!
		INI_CTX(P__[0]);
		END
	    %ELSE
		BEGIN
		!
		! This routine does not initialize the context area
		!
		%IF IS_END_SORT %THEN
		    CTX__[0] = 0;
		%FI
		%IF IS_STAT OR IS_END_SORT %THEN
		    RETURN ERR
		%ELSE
		    RETURN__(ERR)
		%FI
		END
	    %FI;
	!
	! Test and set a bit indicating that this sort is only fit
	! to be aborted.
	!
	%IF IS_END_SORT %THEN
	    CTX[COM_FLO_ABORT] = TRUE
	%ELSE %IF IS_STAT %THEN
	    0
	%ELSE
	    IF TESTBITSS(CTX[COM_FLO_ABORT])
	    THEN
		RETURN__(SOR$_SORT_ON)
	%FI %FI;
	CTX[COM_WORST] = SS$_NORMAL;
	END %;

! This macro causes a checkpoint to be taken when needed
!
MACRO
    CHECKPOINT_COUNTDOWN( DUMMY ) =
	%IF FUN_K_CHECKPOINT
	%THEN
	    BEGIN
	    %IF NOT %DECLARED(R0) %THEN BUILTIN R0; %FI
	    IF (CTX[COM_COUNTDOWN] = .CTX[COM_COUNTDOWN] - 1) LSS 0
	    THEN
		R0 = SOR$$CHECKPOINT();	! This routine is really NOVALUE
	    END
	%ELSE
	    0
	%FI %;

EXTERNAL ROUTINE
    SOR$$KEY_SUB:	CAL_CTXREG,		! Process keys
    SOR$$TREE_INIT:	CAL_CTXREG,		! Allocate and initialize tree
    SOR$$TREE_INSERT:	JSB_INSERT,		! Insert record in sort tree
    SOR$$TREE_EXTRACT:	JSB_EXTRACT,		! Get a record from sort tree
    SOR$$WRK_ALQ:	CAL_CTXREG,		! Calculate work file allocation
%IF FUN_K_CHECKPOINT %THEN
    SOR$$CHECKPOINT:	CAL_CTXREG,		! Take a checkpoint
%FI
%IF NOT HOSTILE
%THEN
    SOR$$SPEC_KEY_SUB:	CAL_CTXREG,		! Process keys from spec file
    SOR$$SPEC_FILE:	CAL_CTXREG,		! Process specification text
    SOR$$OPEN:		CAL_CTXREG,		! Open input and output files
    COLL$INIT,					! Initialize collating sequence
    SOR$$DECM:		CAL_CTXREG,		! Initialize to DEC_MULTI
    SOR$$EBCDIC:	CAL_CTXREG,		! Initialize to EBCDIC
    COLL$BASE,					! Define the base collating sequence
    COLL$PAD,					! Specify pad character
    COLL$TIE_BREAK,				! indicate tie-breaking
    COLL$RESULT,				! Convert result to code
    STR$APPEND:		ADDRESSING_MODE(GENERAL),	! Append strings
    SOR$$COPY_FILE_NAME:CAL_CTXREG NOVALUE,
%FI
    SOR$$FREE_FILE_NAME:CAL_CTXREG NOVALUE,
    LIB$GET_VM:		ADDRESSING_MODE(GENERAL),	! Get virtual memory
    LIB$FREE_VM:	ADDRESSING_MODE(GENERAL),	! Free virtual memory
    LIB$SIGNAL:		ADDRESSING_MODE(GENERAL);	! Signal errors

ROUTINE COND_HAND
	(
	SIGVEC:	REF BLOCK[,BYTE],	! Signal vector
	MCHVEC:	REF BLOCK[,BYTE],	! Mechanism vector
	ENAVEC:	REF VECTOR		! Enable vector
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Condition handler for errors occurring during sort or merge.
!	This routine checks whether errors should be returned or signalled.
!	If errors are to be signalled, we resignal the error.
!	If error statuses are to be returned then
!	    If the error is only a warning or informational, just continue
!	    Otherwise, we unwind to the caller.
!
!	Before modifying this routine, consider how reserved opcode or operand
!	errors will be delivered (users frequently want to catch these).
!
! FORMAL PARAMETERS:
!
!	SIGVEC.ra.r		The signal vector
!	MCHVEC.ra.r		The mechanism vector
!	ENAVEC.ra.r		The enable vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	CTX:	REF CTX_BLOCK,		! Address of context area
	CAD:	REF VECTOR[1];		! Address of context longword

    BUILTIN
	NULLPARAMETER,
	AP,
	CALLG;

    BIND
	SIG_NAME = SIGVEC[CHF$L_SIG_NAME]: BLOCK[,BYTE];

    ! If we can't find the context area, resignal the error.
    !
    IF
	BEGIN
	!
	! ENAVEC[1] contains the address of a longword.
	! This longword holds the address of the user's context longword.
	! Thus,	..ENAVEC[1] is the address of the user's context longword,
	! And  ...ENAVEC[1] is the address of the context area.
	!
	IF NULLPARAMETER(3) THEN TRUE
	ELIF (CAD = .ENAVEC[1]) EQL 0 THEN TRUE
	ELIF (CAD = .CAD[0]) EQL 0 THEN TRUE
	ELIF (CTX = .CAD[0] AND NOT %B'1') EQL 0 THEN TRUE
	ELSE FALSE
	END
    THEN
	BEGIN
	SIG_NAME[STS$V_SEVERITY] = STS$K_SEVERE;
	RETURN SS$_RESIGNAL;		! No context, resignal
	END
    ELIF .SIG_NAME EQL SS$_UNWIND
    THEN
	BEGIN
	!
	! If we are unwinding, indicate that the only valid routine to call is
	! END_SORT, indicate that we are no longer active, and return.
	!
	CTX[COM_FLO_ABORT] = TRUE;
	CAD[0] = .CAD[0] AND NOT %B'1';
	RETURN SS$_RESIGNAL;
	END
    %IF SOR_K_END_AST
    %THEN
    ELIF
	.SIG_NAME EQL SOR$_END_SORT
    THEN
	BEGIN
	IF
	    .MCHVEC[CHF$L_MCH_DEPTH] EQL 0	! Did we signal this?
	THEN
	    RETURN SS$_RESIGNAL
	ELIF
	    BEGIN				! Request to unwind?
	    BIND SIG_VL = SIGVEC: REF VECTOR[,LONG];
	    (.SIGVEC[CHF$L_SIG_ARGS] GEQU 5) AND
	    (.SIG_VL[2] GTR 0) AND
	    (.SIG_VL[3] EQL CAD[0])
	    END
	THEN
	    BEGIN
	    !
	    ! Unwind to a call to SOR$END_SORT, and return an abort message.
	    !
	    LINKAGE
		LINK_R1 = CALL(REGISTER=1);
	    ROUTINE END_SORT(CTXADR: REF VECTOR[1]): LINK_R1 =
		BEGIN
		ESTABLISH_(0);			! No condition handler
		CTXADR[0] = .CTXADR[0] AND NOT %B'1';
		SOR$END_SORT(CTXADR[0]);	! End the sort/merge
		RETURN SOR$_END_SORT AND NOT STS$M_SEVERITY OR STS$K_SEVERE;
		END;
	    CTX[COM_FLO_ABORT] = TRUE;
	    MCHVEC[CHF$L_MCH_SAVR1] = CAD[0];	! Addr of context longword
	    RETURN $UNWIND(DEPADR=MCHVEC[CHF$L_MCH_DEPTH], NEWPC=END_SORT+2);
	    END
	ELSE
	    RETURN SS$_RESIGNAL;
	END
    %FI
    ELIF .SIG_NAME[STS$V_SEVERITY] GEQU STS$K_SEVERE
    THEN
	BEGIN
	CTX[COM_FLO_ABORT] = TRUE;		! May only call END_SORT
	IF .CTX[COM_SIGNAL]
	THEN
	    RETURN SS$_RESIGNAL;		! Signal errors
	MCHVEC[CHF$L_MCH_SAVR0] = .SIG_NAME;
	RETURN $UNWIND();			! Return error status to caller
	END
    ELSE
	BEGIN
	!
	! Update the worst error we've seen, and either resignal or continue.
	! If we resignal, make the worst error an informational,
	!	since the user will have already seen it.
	! If we continue, make the worst error the same as the signalled error,
	!	to make the user more aware of what he missed.
	!
	IF .CTX[COM_SIGNAL]
	THEN
	    BEGIN
	    IF .SIG_NAME[STS$V_FAC_NO] EQL SORT$_FACILITY
	    THEN
		CTX[COM_WORST] = SOR$_ENDDIAGS AND NOT STS$M_SEVERITY OR
		    STS$K_INFO;			! Just an informational
	    RETURN SS$_RESIGNAL;		! Signal errors
	    END
	ELSE
	    BEGIN
	    IF .SIG_NAME[STS$V_FAC_NO] EQL SORT$_FACILITY
	    THEN
		BEGIN
		BIND
		    SEV = UPLIT BYTE(2,0,3,1,4,4,4,4): VECTOR[,BYTE];
		IF .SEV[.SIG_NAME AND 7] GTRU .SEV[.CTX[COM_WORST] AND 7]
		THEN
		    CTX[COM_WORST] = .SIG_NAME;
		CTX[COM_WORST] = .CTX[COM_WORST] AND STS$M_SEVERITY
		    OR SOR$_ENDDIAGS AND NOT STS$M_SEVERITY;
		END;
	    RETURN SS$_CONTINUE;			! Ignore trivial errors
	    END;
	END;

    END;

GLOBAL ROUTINE SOR$$ERROR(ERR) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine signals an error diagnostic.
!
! FORMAL PARAMETERS:
!
!	Parameters passed to LIB$SIGNAL.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	System status (first parameter of signalled status), with the
!	INHIB_MSG bit set.
!
! SIDE EFFECTS:
!
!	The image may be exitted due to the error.
!
!--
    BEGIN
    BUILTIN
	AP,
	CALLG;
    CALLG(.AP, LIB$SIGNAL);
    RETURN .ERR OR STS$M_INHIB_MSG;
    END;

ROUTINE INI_CTX
	(
	CTXADR:	REF VECTOR[1]
	): JSB_INI_CTX NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine allocates and initializes the context area.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The process region may be expanded.
!
! ROUTINE VALUE:
!
!	Address of the storage.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK;

    LOCAL
	ADDR,
	STATUS;

    ! Note that we store the address of the context area in a temporary.
    ! This creates a "window of vulnerability" during which an asynchronous
    ! abort could seriously disrupt everything.
    !
    STATUS = LIB$GET_VM(%REF(CTX_K_SIZE*%UPVAL), ADDR);
    IF NOT .STATUS
    THEN
	RETURN SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS);

    ! Store the address of the context area in our global register
    !
    CTX = .ADDR;

    ! Verify that the allocated storage is aligned on a longword boundary
    !
    IF (CTX[BASE_] AND %B'11') NEQ 0
    THEN
	RETURN SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS);

    ! Zero-fill the storage before storing it's address
    !
    CH$FILL(0, CTX_K_SIZE*%UPVAL, CTX[BASE_]);

    ! Store the address of the context area, leaving the sync bit alone.
    !
    CTXADR[0] = .CTXADR[0] OR .CTX;

    ! Store the address of the context longword,
    ! So we can pass it to the callback routines.
    !
%IF NOT HOSTILE %THEN
    IF CTXADR[0] NEQ SOR_CONTEXT
    THEN
%FI
	CTX[COM_CTXADR] = CTXADR[0]; 

    END;

GLOBAL ROUTINE SOR$$ALLOCATE
	(
	SIZE
	):	CAL_CTXREG =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine allocates storage.
!
! FORMAL PARAMETERS:
!
!	SIZE.rl.v	Number of bytes to allocate
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The process region may be expanded.
!
! ROUTINE VALUE:
!
!	Address of the storage.
!
! SIDE EFFECTS:
!
!	NONE
!
! NOTES:
!
!	The storage allocated by this routine is cleared.
!	This routine should be used only for small pieces of memory.
!	For larger pieces of memory, LIB$GET_VM should be called directly.
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK;
    LOCAL
	ADDR,
	STATUS;
    STATUS = LIB$GET_VM(SIZE, ADDR);
    IF NOT .STATUS THEN SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS);
    CH$FILL(0, .SIZE, .ADDR);			! Zero-fill the storage
    RETURN .ADDR;				! Return the address
    END;

GLOBAL ROUTINE SOR$$DEALLOCATE
	(
	SIZE,
	ADDR:	REF VECTOR[1],
	NEWVAL
	):	CAL_CTXREG NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deallocates storage.
!
! FORMAL PARAMETERS:
!
!	SIZE.rl.v	Number of bytes to deallocate (by value)
!	ADDR.ra.r	Address of storage to deallocate (by reference)
!	NEWVAL.rl.v	New value to store at ADDR.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK;
    BUILTIN
	NULLPARAMETER;
    LOCAL
	VAL,
	STATUS;
    IF .SIZE EQL 0 OR .ADDR[0] EQL 0 THEN RETURN;
    VAL = 0;
    IF NOT NULLPARAMETER(3) THEN VAL = .NEWVAL;
    STATUS = LIB$FREE_VM(SIZE, ADDR[0]);
    ADDR[0] = .VAL;
    IF NOT .STATUS THEN SOR$$ERROR(
	SOR$_SHR_SYSERROR AND NOT STS$M_SEVERITY OR STS$K_ERROR, 0, .STATUS);
    END;

%IF NOT HOSTILE %THEN
ROUTINE CLOSE_FILE
	(
	FAB:	REF BLOCK[,BYTE],
	DDB:	REF DDB_BLOCK,
	ERROR
	):	CAL_CTXREG NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine closes a file.
!
! FORMAL PARAMETERS:
!
!	FAB	Pointer to the FAB
!	DDB	Pointer to the DDB
!	ERROR	Message to issue if the close fails.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    ! Copy the IFI (to reference the file),
    ! and the FOP (for user-specified options)
    !
    ! Zero the IFI in the DDB, so we know that this file is closed
    !
    FAB[FAB$W_IFI] = .DDB[DDB_IFI];
    FAB[FAB$L_FOP] = .DDB[DDB_FOP];
    IF NOT $CLOSE(FAB=FAB[BASE_])
    THEN
	SOR$$ERROR(.ERROR, 1, DDB[DDB_NAME],
	    .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
    DDB[DDB_IFI] = 0;

    END;
%FI

%IF NOT HOSTILE %THEN
GLOBAL ROUTINE SOR$PASS_FILES			! Finished
	(
	INP_DESC:	REF BLOCK[,BYTE],	! Input file name descriptor
	OUT_DESC:	REF BLOCK[,BYTE],	! Output file name descriptor
	ORG:		REF VECTOR[1,BYTE],	! File organization
	RFM:		REF VECTOR[1,BYTE],	! Record format
	BKS:		REF VECTOR[1,BYTE],	! Bucket size
	BLS:		REF VECTOR[1,WORD],	! Block size
	MRS:		REF VECTOR[1,WORD],	! Maximum record size
	ALQ:		REF VECTOR[1,LONG],	! Allocation quantity
	FOP:		REF VECTOR[1,LONG],	! File-processing options
	FSZ:		REF VECTOR[1,BYTE],	! VFC field size
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	;OUT_CTX
	): AND_RETURN_R1 =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine passes input file name(s), output file name, and output
!	file characteristics to the sort or merge.
!
! FORMAL PARAMETERS:
!
!	INP_DESC.ra.d	Input file descriptor
!	OUT_DESC.ra.d	Output file descriptor
!	ORG.rbu.r	File organization	(FAB$B_ORG)
!	RFM.rbu.r	Record format		(FAB$B_RFM)
!	BKS.rbu.r	Bucket size		(FAB$B_BKS)
!	BLS.rwu.r	Block size		(FAB$W_BLS)
!	MRS.rwu.r	Longest record length	(FAB$W_MRS)
!	ALQ.rlu.r	Allocation quantity	(FAB$L_ALQ)
!	FOP.rlu.r	File options		(FAB$L_FOP)
!	FSZ.rbu.r	VFC field size		(FAB$B_FSZ)
!	CONTEXT.ra.r	Longword pointing to work area
!
!	All parameters except INP_DESC are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	If present, the output file characteristics are saved.
!
!--
    BEGIN
    FIRSTPARAMETER_(INP_DESC);	! Required by PRESENT_ and NULL_ macros

    LOCAL
	DDB:	REF DDB_BLOCK,		! Pointer to FAB/RAB/NAM/XAB blocks
	STATUS;				! Status
    BUILTIN
	ACTUALCOUNT;

    CONTEXT_(CONTEXT);

    IF ACTUALCOUNT() NEQ 0 THEN
    IF .CTX[COM_FLO_NOINIT] THEN RETURN__(SOR$_SORT_ON);

    !+
    !
    ! Process the input file specification
    !
    !-
    IF NOT NULL_(INP_DESC)
    THEN
	BEGIN
	IF .CTX[COM_NUM_FILES] GEQ MAX_FILES THEN RETURN__(SOR$_INP_FILES);

	! Allocate DDB and link into list (at the end of the list)
	!
	DDB = SOR$$ALLOCATE(DDB_K_SIZE);
	DDB[DDB_FIL] = .CTX[COM_NUM_FILES];		! Numbers 0 on up
	BEGIN
	LOCAL
	    P:	REF DDB_BLOCK;
	P = CTX[COM_INP_DDB] - %FIELDEXPAND(DDB_NEXT,0);
	DECR I FROM .CTX[COM_NUM_FILES]-1 TO 0 DO P = .P[DDB_NEXT];
	P[DDB_NEXT] = DDB[BASE_];			! Link DDB into list
	CTX[COM_NUM_FILES] = .CTX[COM_NUM_FILES] + 1;	! One more file
	END;
	

	! Copy the input file name string to the DDB
	!
	SOR$$COPY_FILE_NAME(INP_DESC[BASE_], DDB[DDB_NAME]);
	END;


    !+
    !
    ! Process the output file specification
    !
    !-
    IF NOT NULL_(OUT_DESC)
    THEN
	BEGIN
	IF .CTX[COM_OUT_DDB] NEQ 0		! Output already specified?
	THEN
	    RETURN__(SOR$_DUP_OUTPUT);


	! Allocate the DDB for the output file.
	! Allocate space to save the ORG, RFM, et.al.
	! This is used in INIT_SORT or INIT_MERGE.
	!
	CTX[COM_OUT_DDB] = SOR$$ALLOCATE(DDB_K_SIZE);
	DDB = .CTX[COM_OUT_DDB];
	BEGIN
	MACRO
	    FETCH_(N,XXX) =
		IF NOT NULL_(XXX) THEN (P[0]=.P[0] OR 1^N; P[N] = .XXX[0]) %;
	LOCAL
	    P:	REF VECTOR;
	P = CTX[COM_PASS_FILES] = SOR$$ALLOCATE(%UPVAL+8*%UPVAL);
	FETCH_(1,ORG);
	FETCH_(2,RFM);
	FETCH_(3,BKS);
	FETCH_(4,BLS);
	FETCH_(5,MRS);
	FETCH_(6,ALQ);
	FETCH_(7,FOP);
	FETCH_(8,FSZ);
	END;


	! Copy the output file name string to the DDB
	!
	SOR$$COPY_FILE_NAME(OUT_DESC[BASE_], DDB[DDB_NAME]);

	END;

    OUT_CTX = CTX[BASE_];

    RETURN__(SS$_NORMAL);
    END;
%FI

!+
!
! Due to the similarity of SOR$BEGIN_SORT and SOR$BEGIN_MERGE,
! a macro is used to generate code for each.
!
!-
MACRO
    BEGIN_SORT_MERGE(SM) =
    FIRSTPARAMETER_(KEY_BUFFER);	! Required by PRESENT_ and NULL_ macros

    LITERAL
	USED_OPTIONS =
	    MASK_(
		OPT_NODUPS, OPT_NOSIGNAL, OPT_LOAD_FILL, OPT_STABLE
		%IF NOT HOSTILE %THEN , OPT_EBCDIC, OPT_MULTI %FI
		%IF %IDENTICAL(SM,MERGE) %THEN , OPT_SEQ_CHECK %FI
		);

    BUILTIN
	TESTBITSS,
	TESTBITSC,
	ACTUALCOUNT;

    LOCAL
	DOKEY_RTN,
	DOKEY_PRM,
	STATUS;

    ! Get the context area
    !
    CONTEXT_(CONTEXT);


    ! Determine whether to signal or return errors
    !
    IF (IF NULL_(OPTIONS) THEN TRUE ELSE NOT .OPTIONS[OPT_NOSIGNAL])
    THEN
	CTX[COM_SIGNAL] = TRUE;


    ! Check and update the flow-of-control flags
    !
    IF TESTBITSS(CTX[COM_FLO_NOINIT]) THEN RETURN__(SOR$_SORT_ON);
    %IF %IDENTICAL(SM,SORT)
    %THEN
	! If a sort with record interface on input,
	! RELEASE_REC may now be called.
	! Also, SORT_MERGE may be called.
	!
	IF .CTX[COM_NUM_FILES] EQL 0 THEN CTX[COM_FLO_RELEASE] = TRUE;
	CTX[COM_FLO_SORT] = TRUE;
    %FI
    %IF %IDENTICAL(SM,MERGE)
    %THEN
	! If a merge with record interface on output,
	! RETURN_REC may now be called.
	! Also, DO_MERGE (an archaic routine) may be called.
	!
	IF .CTX[COM_OUT_DDB] EQL 0 THEN CTX[COM_FLO_RETURN] = TRUE;
	CTX[COM_FLO_DOMERGE] = TRUE;
    %FI


    ! Get the options parameters
    !
    IF NOT NULL_(OPTIONS)
    THEN
	BEGIN
	IF (.OPTIONS[0,L_] AND NOT USED_OPTIONS) NEQ 0
	THEN
	    RETURN__(SOR$_UNDOPTION);		! Invalid options specified
	%IF %IDENTICAL(SM,MERGE)
	%THEN
	    IF .OPTIONS[OPT_SEQ_CHECK] THEN CTX[COM_SEQ_CHECK] = TRUE;
	%FI
	IF .OPTIONS[OPT_STABLE] THEN CTX[COM_STABLE] = TRUE;
	IF .OPTIONS[OPT_NODUPS] THEN CTX[COM_NODUPS] = TRUE;
	IF .OPTIONS[OPT_LOAD_FILL] THEN CTX[COM_LOAD_FILL] = TRUE;

	%IF NOT HOSTILE %THEN
	IF .OPTIONS[OPT_EBCDIC] OR .OPTIONS[OPT_MULTI]
	THEN
	    BEGIN
	    !
	    ! Simply note that we have a collating sequence, so that we won't
	    ! process other collating sequences in the specification text.
	    ! The collating sequence will be fully processed after we have an
	    ! opportunity to process the pad characater, if any.
	    !
	    IF .OPTIONS[OPT_EBCDIC] AND .OPTIONS[OPT_MULTI]
	    THEN
		RETURN__(SOR$_KEYAMBINC);
	    CTX[COM_OVR_COLSEQ] = TRUE;
	    END;
	%FI
	END;

    %IF %IDENTICAL(SM,SORT)
    %THEN

	! Determine the type of sort
	!
	IF NOT NULL_(SORT_TYPE)
	THEN
	    BEGIN
	    CTX[COM_SORT_TYPE] = .SORT_TYPE[0];
	    CTX[COM_OVR_PROC] = TRUE;
	    END;
	IF .CTX[COM_SORT_TYPE] EQL 0
	THEN
	    CTX[COM_SORT_TYPE] = TYP_K_RECORD	! Default to a record sort
	ELIF
	    .CTX[COM_SORT_TYPE] GTRU TYP_K_MAX	! Check for valid sort type
	THEN
	    RETURN__( SOR$$ERROR(SOR$_BAD_TYPE) );


	! Get the total file allocation, if specified.
	!
	IF NOT NULL_(FILE_ALLOC) THEN CTX[COM_FILE_ALLOC] = .FILE_ALLOC[0];

    
	! Get the number of work files, and check the value.
	! Note: we don't open the work files 'til needed.
	!
	CTX[COM_WRK_FILES] = DEF_WORK_FILES;
	IF NOT NULL_(WORK_FILES)
	THEN
	    BEGIN
	    CTX[COM_WRK_FILES] = .WORK_FILES[0];
	    IF .CTX[COM_WRK_FILES] NEQ 0
	    THEN
		IF .CTX[COM_WRK_FILES] LSSU MIN_WORK_FILES
		THEN 
		    BEGIN
		    CTX[COM_WRK_FILES] = MIN_WORK_FILES;
		    SOR$$ERROR(SOR$_BAD_MERGE);
		    END
		ELIF .CTX[COM_WRK_FILES] GTRU MAX_WORK_FILES
		THEN
		    BEGIN
		    CTX[COM_WRK_FILES] = MAX_WORK_FILES;
		    SOR$$ERROR(SOR$_BAD_MERGE);
		    END;
	    END;
    %FI


    %IF %IDENTICAL(SM,MERGE)
    %THEN
	CTX[COM_MERGE] = TRUE;


	! Set the type of sort to record so that SOR$$KEY_SUB doesn't screw up.
	!
	CTX[COM_SORT_TYPE] = TYP_K_RECORD;


	! Get the merge order.
	!
	CTX[COM_MRG_ORDER] = .CTX[COM_NUM_FILES];
	IF .CTX[COM_MRG_ORDER] EQL 0
	THEN
	    BEGIN
	    IF NOT NULL_(MERGE_ORDER)
	    THEN
		CTX[COM_MRG_ORDER] = .MERGE_ORDER[0];
	    IF .CTX[COM_MRG_ORDER] EQL 0 OR
	       .CTX[COM_MRG_ORDER] GTRU MAX_MERGE_ORDER
	    THEN
		RETURN__( SOR$$ERROR(SOR$_BAD_MERGE) );
	    END;
    %FI


    ! Get the LRL value if specified.
    !
    IF NOT NULL_(LRL)
    THEN
	BEGIN
	CTX[COM_LRL] = .LRL[0];
	%IF 1^%FIELDEXPAND(COM_LRL,2)-1 GTRU MAX_REFSIZE %THEN
	IF .CTX[COM_LRL] GTRU MAX_REFSIZE THEN RETURN__(SOR$_BAD_LRL);
	%FI
	END;


    ! Save the address of the equal-key routine
    !
    IF NOT NULL_(USER_EQUAL)
    THEN
	BEGIN
	CTX[COM_EQUAL] = .USER_EQUAL;
	IF TESTBITSC(CTX[COM_NODUPS]) THEN SOR$$ERROR(SOR$_NODUPEXC);
	IF TESTBITSC(CTX[COM_STABLE]) THEN SOR$$ERROR(SOR$_STABLEEXC);
	END
    ELIF .CTX[COM_NODUPS]
    THEN
	IF TESTBITSC(CTX[COM_STABLE]) THEN SOR$$ERROR(SOR$_STABLEEXC);


    ! Indicate whether the keys in the specification text should be ignored
    !
    IF NOT NULL_(USER_COMPARE) OR NOT NULL_(KEY_BUFFER)
    THEN
	CTX[COM_OVR_KEY] = TRUE;


    ! Process the specification file or specification text
    !
    %IF NOT HOSTILE
    %THEN
	IF .CTX[COM_SPC_DDB] NEQ 0 OR
	    .BLOCK[CTX[COM_SPC_TXT], DSC$W_LENGTH; ,BYTE] NEQ 0
	THEN
	    SOR$$SPEC_FILE();
    %FI

    %IF NOT HOSTILE %THEN
    IF NOT NULL_(OPTIONS) THEN
    IF .OPTIONS[OPT_EBCDIC] OR .OPTIONS[OPT_MULTI] OR
	.CTX[COM_PTAB] NEQ 0
    THEN
	BEGIN
	!
	! Now that we know the pad character, process EBCDIC/DEC_MULTI.
	!
	LOCAL
	    PAD_CHAR:	VECTOR[4,BYTE],
	    COLL_DESC:	VECTOR[2];

	IF .CTX[COM_WRK_SIZ] EQL 0
	THEN
	    BEGIN
	    CTX[COM_WRK_SIZ] = WRK_K_COLLATE;
	    STATUS = LIB$GET_VM(CTX[COM_WRK_SIZ], CTX[COM_WRK_ADR]);
	    IF NOT .STATUS THEN SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS);
	    CTX[COM_WRK_END] = .CTX[COM_WRK_ADR] + .CTX[COM_WRK_SIZ];
	    END;

	COLL_DESC[0] = .CTX[COM_WRK_END] - .CTX[COM_WRK_ADR];
	COLL_DESC[1] = .CTX[COM_WRK_ADR];
	STATUS = COLL$INIT(COLL_DESC[0]);
	IF NOT .STATUS THEN RETURN__(.STATUS);
	IF   .OPTIONS[OPT_MULTI]  THEN STATUS = SOR$$DECM  (COLL_DESC[0])
	ELIF .OPTIONS[OPT_EBCDIC] THEN STATUS = SOR$$EBCDIC(COLL_DESC[0])
	ELSE STATUS = COLL$BASE(COLL_DESC[0], .CTX[COM_PTAB]);
	IF NOT .STATUS THEN RETURN__(.STATUS);
	PAD_CHAR[0] = 1;
	PAD_CHAR[1] = 0;
	PAD_CHAR[2] = .CTX[COM_PAD];
	STATUS = COLL$PAD(COLL_DESC[0], PAD_CHAR[0]);
	IF NOT .STATUS THEN RETURN__(.STATUS);
	IF .CTX[COM_TIE_BREAK]
	THEN
	    BEGIN
	    STATUS = COLL$TIE_BREAK(COLL_DESC[0], TRUE);
	    IF NOT .STATUS THEN RETURN__(.STATUS);
	    END;
	STATUS = COLL$RESULT(COLL_DESC[0], COLL_DESC[0]);
	IF NOT .STATUS THEN RETURN__(.STATUS);
	CTX[COM_WRK_ADR] = .CTX[COM_WRK_ADR] + .COLL_DESC[0];
	CTX[COM_COLLATE] = .COLL_DESC[1];
	END;
    %FI


    ! If record interface on input, assume variable-length records,
    ! unless (see below) the OPT_FIXED option was requested.
    ! Also, check the LRL value, and sort process.
    !
    IF .CTX[COM_NUM_FILES] EQL 0
    THEN
	BEGIN
	CTX[COM_VAR] = TRUE;		! Records are variable-length
	IF .CTX[COM_SORT_TYPE] NEQ TYP_K_RECORD THEN RETURN__(SOR$_BAD_TYPE);
	IF .CTX[COM_LRL] EQL 0 THEN RETURN__(SOR$_LRL_MISS);	! LRL required
	END;


    !+
    !
    ! There is a data-flow problem with the fields COM_LRL (the longest input
    ! record length), COM_LRL_OUT (the longest output record length), and
    ! COM_MINVFC (the size of the VFC area that must be saved in the internal
    ! format nodes for record sorts).
    !
    ! COM_LRL is not known until after the input files are opened.
    ! COM_LRL_OUT is calculated by key processing (and depends on COM_LRL).
    ! COM_LRL_OUT is used in opening the output file.
    ! COM_MINVFC is calculated after opening the output file.
    ! COM_MINVFC is used by key processing.
    !
    ! Rather than split SOR$$OPEN and SOR$$KEY_SUB into two pieces each, and
    ! call the pieces in the appropriate order, SOR$$KEY_SUB is called from the
    ! middle of SOR$$OPEN.
    !
    ! The requirements on the routines are as follows:
    !	Before calling SOR$$KEY_SUB, SOR$$OPEN must set COM_LRL and must set
    !	    COM_MINVFC as large as may be needed.
    !	SOR$$KEY_SUB must set COM_LRL_OUT.
    !	Either:
    !	    After calling SOR$$KEY_SUB, SOR$$OPEN may decrease COM_MINVFC, but 
    !	    if it was non-zero for SOR$$KEY_SUB, the VFC area must still be
    !	    allocated (otherwise, the input routine will access violate).
    !   Or:
    !	    SOR$$KEY_SUB, when saving the VFC area, must first check whether
    !	    the storage is, indeed, allocated.
    !
    ! The effects of this method are as follows:
    !	The high-water mark on the amount of stack space used is higher.
    !	Some performance will be lost if the internal format records retain the
    !	    VFC fields even when they are not really needed.  This occurs if
    !	    the input files have VFC format, and the output file is overlaid,
    !	    and the output file does not have VFC format.  This should be rare.
    !-


    ! The user must have specified the keys by either:
    ! 1. Passing a user key comparison routine.
    ! 2. Passing the key buffer information, or
    ! 3. Using the specification file to specify the keys.
    !
    ! These are used in the above order.
    !
    ! We want to process the keys sometime after opening the input files,
    ! but before opening the input files.  Set up a routine and a parameter
    ! that SOR$$OPEN will call at the appropriate time.  This will:
    ! Build the comparison routine, and the input and output conversion
    ! routines, if needed.
    !
    DOKEY_RTN = SOR$$KEY_SUB;
    DOKEY_PRM = 0;
    IF NOT NULL_(USER_COMPARE)
    THEN
	BEGIN
	CTX[COM_COMPARE] = .USER_COMPARE;
	IF NOT NULL_(KEY_BUFFER) THEN SOR$$ERROR(SOR$_KEYAMBINC);
	END
    ELIF NOT NULL_(KEY_BUFFER)
    THEN
	BEGIN
	DOKEY_PRM = KEY_BUFFER[0];
	END
    %IF NOT HOSTILE %THEN
    ELIF
	.CTX[COM_RDT_SIZ] NEQ 0
    THEN
	BEGIN
	!
	! Use the keys as specified in the specification file
	! Note that the parameter to SOR$$SPEC_KEY_SUB will be ignored.
	!
	DOKEY_RTN = SOR$$SPEC_KEY_SUB;
	END
    %FI
    ELSE
	BEGIN
	!
	! Use the default key specification (SOR$$KEY_SUB can figure it out)
	!
	0;
	END;


    ! Open the input files and output file now.
    ! Since the longest output record length is needed before the output file
    ! is created, pass a routine and parameter that will calculate it.
    !
    ! The parameters to SOR$$OPEN are a routine and parameter that gets called
    ! after opening the input files, but before opening the output file.
    !
    %IF HOSTILE
    %THEN
	IF .CTX[COM_FILE_ALLOC] EQL 0 THEN CTX[COM_FILE_ALLOC] = DEF_FILE_ALLOC;
	STATUS = CAL_CTXREG(.DOKEY_RTN, .DOKEY_PRM );
    %ELSE
	STATUS = SOR$$OPEN( .DOKEY_RTN, .DOKEY_PRM );
    %FI
    IF NOT .STATUS THEN RETURN__(.STATUS);
    SOR$$DEALLOCATE(%UPVAL+8*%UPVAL, CTX[COM_PASS_FILES]);


    ! Allocate space for the record header buffer (VFC area)
    ! This is done here, rather than in SORT_MERGE, since SORT_MERGE need
    ! not be called for merges.
    !
    IF .CTX[COM_MAXVFC] NEQ 0
    THEN
	BEGIN
	CTX[COM_RHB_INP] = SOR$$ALLOCATE(.CTX[COM_MAXVFC]);
	CTX[COM_RHB_OUT] = SOR$$ALLOCATE(.CTX[COM_MAXVFC]);
	END;


    ! If the user specified fixed-length records, make them fixed-length
    ! The effect of this is that no length will be stored in the internal
    ! format nodes.
    !
    %IF (USED_OPTIONS AND MASK_(OPT_FIXED)) NEQ 0 %THEN
    %ERROR('This should be done before calling SOR$$KEY_SUB')
    IF NOT NULL_(OPTIONS) THEN
    IF .OPTIONS[OPT_FIXED] THEN
    IF .CTX[COM_VAR]
    THEN
	BEGIN
	!
	! If COM_VAR was set by SOR$$OPEN (variable length files), complain.
	! If COM_VAR was set because the record interface is being used on
	! input, just clear COM_VAR.
	!
	IF .CTX[COM_NUM_FILES] NEQ 0 THEN SOR$$ERROR(SOR$_VAR_FIX);
	CTX[COM_VAR] = FALSE;
	CTX[COM_SRL] = .CTX[COM_LRL];	! Performance only -- affects tree size
	END;
    %FI


    ! For a non-record sort, create an array containing addresses of the DDBs.
    !
    IF .CTX[COM_SORT_TYPE] NEQ TYP_K_RECORD
    THEN
	BEGIN
	LOCAL
	    P:	REF DDB_BLOCK,		! Pointer to DDB
	    V:	REF VECTOR;		! Pointer to array
	CTX[COM_INP_ARRAY] = V = SOR$$ALLOCATE(%UPVAL * .CTX[COM_NUM_FILES]);
	P = .CTX[COM_INP_DDB];
	DECR I FROM .CTX[COM_NUM_FILES]-1 TO 0 DO
	    BEGIN
	    V[.P[DDB_FIL]] = P[BASE_];
	    P = .P[DDB_NEXT];
	    END;
	END;

    %;

GLOBAL ROUTINE SOR$BEGIN_SORT
	(
	KEY_BUFFER:	REF VECTOR[1,WORD],	! Key description buffer
	LRL:		REF VECTOR[1,WORD],	! Longest record length
	OPTIONS:	REF BLOCK[1],		! Options
	FILE_ALLOC:	REF VECTOR[1,LONG],	! Input file(s) allocation
	USER_COMPARE,				! User comparison routine
	USER_EQUAL,				! User equal-key routine
	SORT_TYPE:	REF VECTOR[1,BYTE],	! Type of sort process
	WORK_FILES:	REF VECTOR[1,BYTE],	! Number of work files
	CONTEXT:	REF VECTOR[1,LONG]	! Context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes sort.
!	Input and output files are opened.
!	Key definitions are processed.
!	The replacement selection tree is initialized.
!
! FORMAL PARAMETERS:
!
!	KEY_BUFFER.raw		Key buffer address
!	LRL.rwu.r		Longest record length
!	FILE_ALLOC.rlu.r	Input file allocation
!	WORK_FILES.rbu.r	Number of work files
!	SORT_TYPE.rbu.r		Type of sort (record/tag/index/address)
!	USER_COMPARE.rzem.r	User-written comparison routine
!	OPTIONS.rlu.r		Option bits
!	USER_EQUAL.rzem.r	User-written equal-key routine
!	CONTEXT.ra.r		Longword pointing to work area
!
!	All parameters are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	The working set is extended and the virtual memory is allocated.
!
!--
    BEGIN

    ! Process the parameters
    !
    BEGIN_SORT_MERGE(SORT)


    ! Determine amount of memory available for the replacement selection tree,
    ! based on the working-set extent, and initialize the tree.
    !
    BEGIN
    LOCAL
	WSSIZE,
	WSLIMIT,
	MEM;
!   STATUS = $ADJWSL(PAGCNT=0, WSETLM=WSSIZE);
!   IF NOT .STATUS THEN RETURN__(SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS));
    STATUS = $ADJWSL(PAGCNT=%X'7FFFFFFF', WSETLM=WSLIMIT
	%IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
    IF NOT .STATUS THEN RETURN__(SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS));
    %IF TUN_K_PURGWS
    %THEN
	$PURGWS(INADR=UPLIT(0,%X'7FFFFFFF'));
    %FI
    !
    ! Call TREE_INIT, passing the number of pages it may use,
    ! and the expected number of input records.
    !
    ! Note that we effectively add only 1 to the average record length for
    ! variable-length records.  This has the effect of slightly increasing
    ! our estimate of the number of records.
    !
    STATUS = SOR$$TREE_INIT(
	MAX(.WSLIMIT - TUN_K_NONTREE, TUN_K_FALLBACK),
	.CTX[COM_FILE_ALLOC] * COM_K_BPERBLOCK * 2 /
	    (IF NOT .CTX[COM_VAR]
		THEN 2*.CTX[COM_LRL]
		ELSE .CTX[COM_LRL]+.CTX[COM_SRL] + 2));
    IF NOT .STATUS THEN RETURN__(.STATUS);
    END;


    RETURN__(SS$_NORMAL);
    END;

GLOBAL ROUTINE SOR$SORT_MERGE			! Finished
	(
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sorts the file.
!
!	For file interface, the input files are read and released to the sort.
!	For record interface, the records have already been released.
!	In either case, the replacement selection tree is flushed, and the
!	merge passes on the runs are done until a single merge will produce
!	a single run.  At this point, the following occurs:
!	For file interface, the output records are reformatted, and directed
!	to the output file.  For record interface, we return to the user, who
!	can call RETURN_REC to get the sorted records.
!
! FORMAL PARAMETERS:
!
!	CONTEXT.ra.r		Longword pointing to work area
!
!	All parameters are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The input files and output file are closed.
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    FIRSTPARAMETER_(CONTEXT);	! Required by PRESENT_ and NULL_ macros

    LOCAL
	DDB:	REF DDB_BLOCK,		! Pointer to DDB
	FAB:	$FAB_DECL,		! FAB (for closing files)
	RAB:	REF $RAB_DECL;		! Pointer to input or output RAB
    BUILTIN
	TESTBITCC;

    CONTEXT_(CONTEXT, SOR$_SORT_ON);

    IF TESTBITCC(CTX[COM_FLO_SORT]) THEN RETURN__(SOR$_SORT_ON);
    IF .CTX[COM_OUT_DDB] EQL 0 THEN CTX[COM_FLO_RETURN] = TRUE;

    %IF NOT HOSTILE %THEN

    ! Initialize FAB (used for closing files)
    !
    CH$FILL(0, FAB$C_BLN, FAB[BASE_]);
    FAB[FAB$B_BLN] = FAB$C_BLN;
    FAB[FAB$B_BID] = FAB$C_BID;


    ! Read all the input files
    !
    DDB = .CTX[COM_INP_DDB];			! Point to first DDB
    DECR I FROM .CTX[COM_NUM_FILES]-1 TO 0 DO
	BEGIN

	! Store address of the current DDB, and get a pointer to the RAB.
	!
	CTX[COM_INP_CURR] = DDB[BASE_];
	RAB = DDB[DDB_RAB+BASE_];


	! Clear the VFC area.
	! This area is cleared on a per-file basis, so that extra junk from
	! the previous file is not left around, and copied to the output file.
	! We must clear it, as the input conversion routine may reference it,
	! even if RAB$L_RHB doesn't.
	!
	CH$FILL(0, .CTX[COM_MAXVFC], .CTX[COM_RHB_INP]);


	! If we need the VFC area for internal nodes,
	! then set RAB$L_RHB to point to the VFC area.
	! Check to see whether the VFC area is solely for the use of the
	! output file; if so, don't point the RAB to it.
	!
	RAB[RAB$L_RHB] = .CTX[COM_RHB_INP];
	IF .CTX[COM_MINVFC] EQL 0 THEN RAB[RAB$L_RHB] = 0;


	! Get all the records from this file
	!
	BEGIN
	BUILTIN R0;
	WHILE TRUE DO
	    BEGIN
	    IF  BEGIN
		IF (R0 = $GET(RAB=RAB[BASE_])) THEN TRUE
		ELIF .R0 EQL RMS$_RTB
		THEN (RAB[RAB$W_RSZ] = .RAB[RAB$L_STV]; TRUE)
		ELSE FALSE
		END
	    THEN
		BEGIN
		LOCAL
		    D:	BLOCK[2];		! Descriptor
		MACRO
		    LENW = 0,0,16,0 %,
		    LENL = 0,0,32,0 %,
		    ADDR = 1,0,32,0 %;

		CTX[COM_INP_RECNUM] = .CTX[COM_INP_RECNUM] + 1;
		CHECKPOINT_COUNTDOWN();

		! Create a descriptor for the input record
		!
		D[LENL] = .RAB[RAB$W_RSZ];
		D[ADDR] = .RAB[RAB$L_RBF];
		IF
		    BEGIN
		    !
		    ! Check the length.
		    !
		    IF .D[LENW] GTRU .CTX[COM_LRL]
		    THEN
			BEGIN
			!
			! If too long, complain and shorten the record
			!
			R0 = SOR$$ERROR(SOR$_BAD_LRL, 1, .D[LENL],
			    SOR$_SHR_READERR, 1, DDB[DDB_NAME]);
			D[LENW] = .CTX[COM_LRL];
			TRUE
			END
		    ELSE
			.D[LENW] GEQU .CTX[COM_SRL]
		    END
		THEN
		    BEGIN
		    !
		    ! Release the record to the sort (also converts the record)
		    !
		    R0 = SOR$$TREE_INSERT(D[BASE_]);
		    END
		ELSE
		    BEGIN
		    !
		    ! If too short, complain and ignore the record.
		    !
		    ! By putting this code after the code to call TREE_INSERT,
		    ! a branch byte displacement after TREE_INSERT suffices.
		    !
		    R0 = SOR$$ERROR(SOR$_BAD_SRL, 1, .D[LENL],
			SOR$_SHR_READERR, 1, DDB[DDB_NAME]);
		    CTX[COM_OMI_RECNUM] = .CTX[COM_OMI_RECNUM] + 1;
		    END
		END
	    ELIF
		.R0 EQL RMS$_RSA		! Record Stream Active
	    THEN
		R0 = $WAIT(RAB=RAB[BASE_])	! Wait until not so active
	    ELIF
		.R0 EQL RMS$_RLK
	    THEN
		BEGIN
		BUILTIN
		    TESTBITSS;
		IF TESTBITSS(RAB[RAB$V_RRL]) THEN EXITLOOP;
		R0 = SOR$$ERROR(
		    SOR$_SHR_READERR AND NOT STS$M_SEVERITY OR STS$K_WARNING,
		    1, DDB[DDB_NAME], .RAB[RAB$L_STS], .RAB[RAB$L_STV],
		    RMS$_OK_RRL);
		END
	    ELSE
		EXITLOOP;			! Some other error

	    END;


	! Check for the expected status
	!
	IF .R0 NEQ RMS$_EOF
	THEN
	    R0 = SOR$$ERROR(SOR$_SHR_READERR, 1, DDB[DDB_NAME],
		    .RAB[RAB$L_STS], .RAB[RAB$L_STV]);
	END;


	! All records have been read from this file.  Close the input file now
	! (unless we are doing a tag sort, because we will reaccess the file).
	!
	IF .CTX[COM_SORT_TYPE] NEQ TYP_K_TAG
	THEN
	    CLOSE_FILE(FAB[BASE_], DDB[BASE_], SOR$_SHR_CLOSEIN)
	ELSE
	    BEGIN
	    !
	    ! We will access this file later by RFA.
	    ! Also, the VFC area (if any) will be needed.
	    !
	    DDB[DDB_RAB+RAB$B_RAC] = RAB$C_RFA;
	    DDB[DDB_RAB+RAB$L_RHB] = .CTX[COM_RHB_INP];
	    END;


	! Advance to the next file
	!
	DDB = .DDB[DDB_NEXT];
	END;

!+
!
! Now we've read all the input files.
!
!-

    ! Call another routine to get all the records from TREE_EXTRACT, and to
    ! output the records.  If the record interface is being used on output,
    ! this routine will do nothing.
    !
    MRG_OUTPUT();
    %FI

    RETURN__(SS$_NORMAL);
    END;

%IF NOT HOSTILE %THEN
ROUTINE MRG_OUTPUT:	CAL_CTXREG NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine merges into the output file.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK;
    LOCAL
	DDB:	REF DDB_BLOCK,		! Pointer to DDB
	RAB:	REF BLOCK[,BYTE],	! Pointer to RAB
	FAB:	$FAB_DECL;		! FAB (for closing files)


    ! Check for record interface on output, RETURN_REC will be used
    !
    IF (DDB = .CTX[COM_OUT_DDB]) NEQ 0
    THEN
	BEGIN
	LOCAL
	    D:	BLOCK[2];	! Output buffer descriptor
	MACRO
	    LENW = 0,0,16,0 %,
	    LENL = 0,0,32,0 %,
	    ADDR = 1,0,32,0 %;

	! Initialize FAB (used for closing files)
	!
	CH$FILL(0, FAB$C_BLN, FAB[BASE_]);
	FAB[FAB$B_BLN] = FAB$C_BLN;
	FAB[FAB$B_BID] = FAB$C_BID;


	! Get a pointer to the RAB
	!
	RAB = DDB[DDB_RAB+BASE_];


	! Set RAB$L_RHB to reference the VFC area
	!
	RAB[RAB$L_RHB] = .CTX[COM_RHB_OUT];


	! Allocate a record buffer area.
	! The length and address are stored in the USZ and UBF fields,
	! so that FREE_DDBS can release the memory.
	!
	RAB[RAB$W_USZ] = .CTX[COM_LRL_OUT];
	RAB[RAB$L_UBF] = SOR$$ALLOCATE(.RAB[RAB$W_USZ]);

	! Initialize the descriptor for the returned record buffer.
	! Put the record address into the RAB, so RMS knows where it is.
	! The record length is written into the RAB by SOR$$TREE_EXTRACT.
	!
	D[LENL] = .CTX[COM_LRL_OUT];
	D[ADDR] = RAB[RAB$L_RBF] = .RAB[RAB$L_UBF];


	! Get all the records from the sort, and write them to the output file.
	!
	BEGIN
	BUILTIN R0;
	WHILE TRUE DO
	    BEGIN

	    CHECKPOINT_COUNTDOWN();

	    ! Get the next record from the final merge pass.
	    !
	    R0 = SOR$$TREE_EXTRACT(D[BASE_], RAB[RAB$W_RSZ]);
	    IF NOT .R0 THEN EXITLOOP;


	    ! Output one record
	    !
	    WHILE TRUE DO
		BEGIN
		IF (R0 = $PUT(RAB=RAB[BASE_]))
		THEN
		    BEGIN
		    CTX[COM_OUT_RECNUM] = .CTX[COM_OUT_RECNUM] + 1;
		    EXITLOOP			! Don't try again
		    END
		ELIF
		    .R0 EQL RMS$_RSZ
		THEN
		    BEGIN
		    !
		    ! Complain about the length problem
		    ! See if we have a better guess at the correct length.
		    ! If not, drop this record from the sort.
		    ! If so, try using it.
		    !
		    R0 = SOR$$ERROR(SOR$_SHR_WRITEERR, 1, DDB[DDB_NAME],
			.RAB[RAB$L_STS], .RAB[RAB$L_STV]);
		    IF .RAB[RAB$W_RSZ] EQL .D[LENW]
		    THEN
			EXITLOOP		! Don't try again
		    ELIF .RAB[RAB$W_RSZ] LSSU .D[LENW]
		    THEN
			BEGIN
			!
			! Fill the record with the pad character.
			! Note that this would be unnecessary if TREE_EXTRACT
			! used COM_PAD.
			!
			BUILTIN MOVC5;
			MOVC5(%REF(0), .R0, CTX[COM_PAD],
			    %REF(.D[LENW] - .RAB[RAB$W_RSZ]),
			        (.D[ADDR] + .RAB[RAB$W_RSZ]); R0);
			END;
		    RAB[RAB$W_RSZ] = .D[LENW];
		    !
		    ! The $PUT had better work this time, because
		    ! D[LENW] = CTX[COM_LRL_OUT] = .OUTPUTFAB[FAB$W_MRS]
		    !
		    END				! And try again
		ELIF
		    .R0 EQL RMS$_RSA
		THEN
		    R0 = $WAIT(RAB=RAB[BASE_])	! And try again
		ELIF
		    .R0 EQL RMS$_SEQ
		THEN
		    BEGIN
		    R0 = SOR$$ERROR(SOR$_KEYED);
		    RAB[RAB$B_RAC] = RAB$C_KEY;	! And try again
		    END
		ELSE
		    BEGIN
		    R0 = SOR$$ERROR(SOR$_SHR_WRITEERR, 1, DDB[DDB_NAME],
			.RAB[RAB$L_STS], .RAB[RAB$L_STV]);
		    EXITLOOP;			! Don't try again
		    END;
		END;
	    END;


	! Check that we got the expected status
	!
	IF .R0 NEQ SS$_ENDOFFILE THEN SOR$$ERROR(.R0);
	END;


	! Close the output file
	!
	CLOSE_FILE(FAB[BASE_], DDB[BASE_], SOR$_SHR_CLOSEOUT);


	! If this was a tag sort, close the input files now.
	!
	IF .CTX[COM_SORT_TYPE] EQL TYP_K_TAG
	THEN
	    BEGIN

	    DDB = .CTX[COM_INP_DDB];
	    DECR I FROM .CTX[COM_NUM_FILES]-1 TO 0 DO
		BEGIN
		!
		! Close the input file
		!
		CLOSE_FILE(FAB[BASE_], DDB[BASE_], SOR$_SHR_CLOSEIN);

		! Advance to next DDB
		!
		DDB = .DDB[DDB_NEXT];
		END;
	    END;

	END;

    END;
%FI

GLOBAL ROUTINE SOR$RELEASE_REC			! Finished
	(
	DESC:		REF BLOCK[,BYTE],
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Pass a record to the sort.
!
! FORMAL PARAMETERS:
!
!	DESC.rab.d		Descriptor of the record
!	CONTEXT.ra.r		Longword pointing to work area
!
!	All parameters except DESC are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    FIRSTPARAMETER_(DESC);	! Required by PRESENT_ and NULL_ macros
    LOCAL
	STATUS;

    CONTEXT_(CONTEXT, SOR$_SORT_ON);


    ! Check that we are allowed to get here, and check for DESC present
    !
    IF NOT .CTX[COM_FLO_RELEASE] THEN RETURN__(SOR$_SORT_ON);
    IF NULL_(DESC) THEN RETURN__(SOR$_MISS_PARAM);


    CTX[COM_INP_RECNUM] = .CTX[COM_INP_RECNUM] + 1;
    CHECKPOINT_COUNTDOWN();


    IF .DESC[DSC$W_LENGTH] LSSU .CTX[COM_SRL]
    THEN
	BEGIN
	!
	! If the record is too short, complain and ignore it
	!
	CTX[COM_OMI_RECNUM] = .CTX[COM_OMI_RECNUM] + 1;
	RETURN__(SOR$$ERROR(SOR$_BAD_SRL));
	END
    ELIF .DESC[DSC$W_LENGTH] GTRU .CTX[COM_LRL]
    THEN
	BEGIN
	!
	! If the record is too long, complain and use a shorter record
	!
	LOCAL
	    D: VECTOR[2];
	D[0] = .CTX[COM_LRL];
	D[1] = .DESC[DSC$A_POINTER];
	SOR$$ERROR(SOR$_BAD_LRL, 1, .DESC[DSC$W_LENGTH]);
	SOR$$TREE_INSERT(D[0]);
	END
    ELSE
	BEGIN
	!
	! Insert the record into the sort tree (this also converts the record)
	!
	SOR$$TREE_INSERT(DESC[BASE_]);
	END;

    RETURN__(SS$_NORMAL);
    END;

GLOBAL ROUTINE SOR$RETURN_REC			! Finished
	(
	DESC:		REF BLOCK[,BYTE],	! Buffer descriptor
	SIZE:		REF VECTOR[1,WORD],	! Output length
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get a record returned from the sort.
!
! FORMAL PARAMETERS:
!
!	DESC.wab.d		Descriptor of the record
!	SIZE.waw.r		Word to recieve length of record
!	CONTEXT.ra.r		Longword pointing to work area
!
!	All parameters except DESC are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    FIRSTPARAMETER_(DESC);	! Required by PRESENT_ and NULL_ macros
    LOCAL
	STATUS;

    CONTEXT_(CONTEXT, SOR$_SORT_ON);


    ! Check that we are allowed to get here, and check for DESC present
    !
    IF NOT .CTX[COM_FLO_RETURN] THEN RETURN__(SOR$_SORT_ON);
    IF NULL_(DESC) THEN RETURN__(SOR$_MISS_PARAM);


    CHECKPOINT_COUNTDOWN();


    ! Call TREE_EXTRACT to get the record from the tree (this also converts
    ! the record to the output format).
    !
    STATUS = SOR$$TREE_EXTRACT(DESC[BASE_],
	(IF PRESENT_(SIZE) THEN SIZE[0] ELSE 0));


    ! If there are no more records, the user isn't supposed to call us again
    !
    IF .STATUS EQL SS$_ENDOFFILE		! Check for the end
    THEN
	BEGIN
	!
	! Note that further calls to RETURN_REC will also return SS$_ENDOFFILE
	!
	CTX[COM_FLO_ABORT] = FALSE;		! Can call other routines
	RETURN__(.STATUS);
	END
    ELSE
	RETURN__(SS$_NORMAL);

    END;

%IF NOT HOSTILE %THEN
ROUTINE FREE_DDBS				! Finished
	(
	DDB_PTR:	REF VECTOR[1,LONG],	! Address of pointer to DDBs
	CLOSEERR,				! Error message
	DELUBF					! Delete user buffer
	):	CAL_CTXREG NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Deallocate the storage associated with a list of DDBs.
!
!	NOTE:  The files are closed by this routine.
!
! FORMAL PARAMETERS:
!
!	DDB_PTR.ra.r	Address of pointer to a list of DDBs
!	CLOSEERR	Message to signal on close error
!	DELUBF		True to delete the user buffer for these DDBs
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE (signals errors)
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK;
    LOCAL
	FAB:	$FAB_DECL,
	DDB:	REF DDB_BLOCK,
	DDB_ADR:REF VECTOR[1],
	STATUS;


    ! Initialize a FAB
    !
    $FAB_INIT(FAB = FAB[BASE_]);


    ! Deallocate the user buffer if requested (and it is there)
    !
    DDB = .DDB_PTR[0];				! Pointer to first DDB
    IF DDB[BASE_] NEQ 0 AND .DELUBF
    THEN					! Deallocate the user buffer
	BEGIN
	WHILE (DDB = .DDB[DDB_NEXT]) NEQ 0 DO DDB[DDB_RAB+RAB$L_UBF] = 0;
	DDB = .DDB_PTR[0];			! Pointer to first DDB
	SOR$$DEALLOCATE(.DDB[DDB_RAB+RAB$W_USZ], DDB[DDB_RAB+RAB$L_UBF]);
	END;


    ! For each DDB linked into this list
    !
    DDB_ADR = DDB_PTR[0];
    WHILE (DDB = .DDB_ADR[0]) NEQ 0 DO
	BEGIN

	! Close the file
	!
	IF .DDB[DDB_IFI] NEQ 0
	THEN
	    CLOSE_FILE(FAB[BASE_], DDB[BASE_], .CLOSEERR);

	! Free the file name string
	!
	SOR$$FREE_FILE_NAME(DDB[DDB_NAME]);	! Free name string

	! Free the DDB
	!
	SOR$$DEALLOCATE(DDB_K_SIZE, DDB_ADR[0], .DDB[DDB_NEXT]);

	END;

    END;
%FI

ROUTINE AST_END_SORT
	(
	CTXADR:	REF VECTOR[1]
	): JSB_INI_CTX =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine aborts a sort while another sort routine is active.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    EXTERNAL REGISTER
	CTX =	COM_REG_CTX:	REF CTX_BLOCK;

    %IF NOT SOR_K_END_AST
    %THEN
	RETURN SOR$_SORT_ON
    %ELSE
	BEGIN
	EXTERNAL ROUTINE
	    LIB$AST_IN_PROG:	ADDRESSING_MODE(GENERAL),	! At AST?
	    SYS$CLRAST:		ADDRESSING_MODE(GENERAL);	! Clear AST
	LOCAL
	    STATUS;

	ROUTINE END_SORT_AST(CTXADR: REF VECTOR[1]): NOVALUE =
	    BEGIN
	    SYS$CLRAST();
	    !
	    ! Note that we should never return from this signal.
	    !
	    LIB$SIGNAL(SOR$_END_SORT, 1, CTXADR[0]);
	    END;
	
	IF NOT LIB$AST_IN_PROG()
	THEN
	    BEGIN
	    !
	    ! We were not called from an AST.
	    ! Just signal an abort request to the active sort/merge routine.
	    ! Note that we call LIB$SIGNAL directly so that when this signal
	    ! is caught by END_SORT's condition handler, the depth is zero.
	    ! Note that we should never return from this signal.
	    !
	    LIB$SIGNAL(SOR$_END_SORT, 1, CTXADR[0]);
	    END;

	! We were called from an AST routine.
	! Declare another AST routine so the current one can finish executing.
	!
	STATUS = $DCLAST(ASTADR=END_SORT_AST, ASTPRM=CTXADR[0]
	    %IF HOSTILE_ELAN %THEN , ELAN = .CTX[COM_CTXADR] %FI );
	IF NOT .STATUS THEN RETURN SOR$$ERROR(.STATUS);

	! Return an informational status indicating that, although the caller
	! requested us to abort, we have not yet done so.
	!
	RETURN SOR$_END_SORT AND NOT STS$M_SEVERITY OR STS$K_INFO;
	END

    %FI;

    END;

GLOBAL ROUTINE SOR$END_SORT
	(
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Indicate the end of the sort, and free all storage used by the sort.
!
! FORMAL PARAMETERS:
!
!	CONTEXT.ra.r		Longword pointing to work area
!
!	All parameters are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	The following data structures are deallocated.
!
!	The Common context area.
!	The DDBs.
!		For each DDB, the file name string.
!		The user buffer for the input DDBs.
!		The user buffer for the output DDB.
!	The WFBs.
!		For each WFB, the file name string.
!	The replacement selection tree.
!	The run description blocks.
!	The work file buffers.
!
!--
    BEGIN
    FIRSTPARAMETER_(CONTEXT);	! Required by PRESENT_ and NULL_ macros

    PSECT NODEFAULT = SOR$$END_PSECT_(1)(PIC,SHARE,NOWRITE,EXECUTE,
					ADDRESSING_MODE(LONG_RELATIVE));
    OWN END_0: VECTOR[0] PSECT(SOR$$END_PSECT_(1));
    PSECT NODEFAULT = SOR$$END_PSECT_(3)(PIC,SHARE,NOWRITE,EXECUTE,
					ADDRESSING_MODE(LONG_RELATIVE));
    OWN END_1: VECTOR[0] PSECT(SOR$$END_PSECT_(3));

    CONTEXT_(CONTEXT, SS$_NORMAL);

!+
!   Allow END_SORT to be called at any time.
!
!   IF NOT .CTX[COM_FLO_RETURN] THEN RETURN__(SOR$_SORT_ON);
!-

    ! Call the clean-up routines
    !
    BEGIN
    LOCAL
	P: REF VECTOR[1],
	Q: REF VECTOR[1];
    P = END_0;
    Q = END_1;
    WHILE P[0] LSSA Q[0] DO
	BEGIN
	LOCAL RTN, STATUS;
	RTN = .P[0] + P[0]; P = P[1];
	CAL_CTXREG(.RTN);
	END;
    END;


%(
    ! Unlock everything that got locked into the WS
    !
    BEGIN
    LOCAL
	P:	REF BLOCK;
    P = .CTX[COM_LOCKED];
    WHILE P[BASE_] NEQ 0 DO
	BEGIN
	P = .P[LCK_NEXT];
	END;
    END;
)%

    ! Deallocate the array of pointers to DDBs
    !
    SOR$$DEALLOCATE( %UPVAL * .CTX[COM_NUM_FILES], CTX[COM_INP_ARRAY]);


    ! Deallocate all the DDBs
    !
    %IF NOT HOSTILE
    %THEN
	FREE_DDBS(CTX[COM_INP_DDB], SOR$_SHR_CLOSEIN,  TRUE);
	FREE_DDBS(CTX[COM_OUT_DDB], SOR$_SHR_CLOSEOUT, TRUE);
	FREE_DDBS(CTX[COM_SPC_DDB], SOR$_SHR_CLOSEIN,  FALSE);
    %FI


    ! Deallocate space for the record header buffer (VFC area)
    !
    SOR$$DEALLOCATE(.CTX[COM_MAXVFC], CTX[COM_RHB_INP]);
    SOR$$DEALLOCATE(.CTX[COM_MAXVFC], CTX[COM_RHB_OUT]);


    ! Deallocate the "pass files" information
    !
    SOR$$DEALLOCATE(%UPVAL+8*%UPVAL, CTX[COM_PASS_FILES]);


    ! Deallocate the context area
    !
    CTX__[0] = .CTX__[0] AND NOT %B'1';		! No longer active
    SOR$$DEALLOCATE(CTX_K_SIZE*%UPVAL, CTX__[0]);


    ! Dump the amount of unfreed space if compiled with debugging
    !
    %IF %SWITCHES(DEBUG)
    %THEN
	BEGIN
	EXTERNAL ROUTINE LIB$STAT_VM: ADDRESSING_MODE(GENERAL);
	EXTERNAL ROUTINE SOR$$OUTPUT;
	MACRO
	    DESC_(A) = UPLIT(%CHARCOUNT(A), UPLIT BYTE(A)) %;
	LOCAL GETS, FREES, UNFREED;
	LIB$STAT_VM(%REF(1), GETS);
	LIB$STAT_VM(%REF(2), FREES);
	LIB$STAT_VM(%REF(3), UNFREED);
	SOR$$OUTPUT(DESC_(
	    '!XL unfreed bytes = !UL pages, !UL bytes (!UL GETs, !UL FREEs)'),
		.UNFREED, .UNFREED/COM_K_BPERPAGE, .UNFREED MOD COM_K_BPERPAGE,
		.GETS, .FREES);
	END;
    %FI

    RETURN SS$_NORMAL;
    END;

GLOBAL ROUTINE SOR$BEGIN_MERGE
	(
	KEY_BUFFER:	REF VECTOR[,WORD],	! Key description buffer
	LRL:		REF VECTOR[,WORD],	! Longest record length
	OPTIONS:	REF BLOCK[1],		! Options
	MERGE_ORDER:	REF VECTOR[,BYTE],	! Order of the merge
	USER_COMPARE,				! User comparison routine
	USER_EQUAL,				! User equal-key routine
	USER_INPUT,				! User input routine
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes and does a merge.
!
! FORMAL PARAMETERS:
!
!	MERGE_ORDER.rab		Order of the merge
!	KEY_BUFFER.raw		Key buffer address
!	LRL.rwu.r		Longest record length
!	OPTIONS.rlu.r		Option bits
!	USER_COMPARE,		User-written comparison routine
!	USER_INPUT		User-written input routine
!	USER_EQUAL,		User-written equal-key routine
!	CONTEXT.ra.r		Longword pointing to work area
!
!	All parameters are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	The work files are defined (not necessarily created), the working set
!	is extended and the virtual memory is extended.
!
!--
    BEGIN

    ! Process the parameters
    !
    BEGIN_SORT_MERGE(MERGE)


    ! Process the USER_INPUT parameter
    !
    IF NOT NULL_(USER_INPUT)
    THEN
	CTX[COM_MRG_INPUT] = .USER_INPUT;


    ! If no files were passed, the user must specify an input routine
    !
    IF .CTX[COM_NUM_FILES] EQL 0 AND .CTX[COM_MRG_INPUT] EQL 0
    THEN
	RETURN__(SOR$_MISS_PARAM);


    ! The merge will use TREE_EXTRACT to get records back from the streams.
    ! Set the number of runs to a non-zero value so that TREE_EXTRACT realizes
    ! it should not use the replacement selection tree.
    !
    CTX[COM_RUNS] = .CTX[COM_MRG_ORDER];


    ! Link all the files to the VFC area
    !
    BEGIN
    LOCAL
	DDB:	REF DDB_BLOCK;
    DDB = .CTX[COM_INP_DDB];			! Point to first DDB
    DECR I FROM .CTX[COM_NUM_FILES]-1 TO 0 DO
	BEGIN
	DDB[DDB_RAB+RAB$L_RHB] = .CTX[COM_RHB_INP];
	DDB = .DDB[DDB_NEXT];
	END;
    IF (DDB = .CTX[COM_OUT_DDB]) NEQ 0
    THEN
	DDB[DDB_RAB+RAB$L_RHB] = .CTX[COM_RHB_OUT];
    END;


    ! Call another routine to merge the sources into the output file.
    ! If the record interface is used on output, this routine does nothing.
    !
    %IF NOT HOSTILE
    %THEN
	MRG_OUTPUT();
    %FI

    RETURN__(SS$_NORMAL);
    END;

%IF NOT HOSTILE %THEN
GLOBAL ROUTINE SOR$SPEC_FILE
	(
	SPC_DESC:	REF BLOCK[,BYTE],	! Filename descriptor
	TXT_DESC:	REF BLOCK[,BYTE],	! Text descriptor
	CONTEXT:	REF VECTOR[1,LONG],	! Addr of context longword
	COLL_BLOCK:	REF BLOCK[,BYTE]	! Collate sequence description
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes the specification file.
!
! FORMAL PARAMETERS:
!
!	SPC_DESC.ra.d	Specification file descriptor
!	TXT_DESC.ra.d	Specificatoin text descriptor
!	CONTEXT.ra.r	Longword pointing to work area
!	COLL_BLOCK.ra.r	Collating sequence description
!
!	All parameters are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    FIRSTPARAMETER_(SPC_DESC);	! Required by PRESENT_ and NULL_ macros

    LOCAL
	STATUS;

    CONTEXT_(CONTEXT);

    IF .CTX[COM_FLO_NOINIT] THEN RETURN__(SOR$_SORT_ON);

    ! Check for spec file name present
    !
    IF NOT NULL_(SPC_DESC)
    THEN
	BEGIN
	LOCAL
	    DDB:	REF DDB_BLOCK,
	    P:		REF DDB_BLOCK;

	! Allocate DDB and link into list (at the end of the list)
	!
	DDB = SOR$$ALLOCATE(DDB_K_SIZE);
	P = CTX[COM_SPC_DDB];
	WHILE .P[DDB_NEXT] NEQ 0 DO P = .P[DDB_NEXT];
	P[DDB_NEXT] = DDB[BASE_];			! Link DDB into list
	
	! Copy the input file name string to the DDB
	!
	SOR$$COPY_FILE_NAME(SPC_DESC[BASE_], DDB[DDB_NAME]);
	END;


    BEGIN
    BIND
	TXT = CTX[COM_SPC_TXT]: BLOCK[,BYTE];
    TXT[DSC$B_CLASS] = DSC$K_CLASS_D;
    IF NOT NULL_(TXT_DESC)
    THEN
	BEGIN
	!
	! Append the text to the end of our dynamic string.
	!
	STATUS = STR$APPEND(TXT[BASE_], TXT_DESC[BASE_]);
	IF NOT .STATUS THEN RETURN__(SOR$$ERROR(SOR$_SHR_SYSERROR, 0, .STATUS));
	END;
    END;


    BEGIN
    IF NOT NULL_(COLL_BLOCK)
    THEN
	BEGIN
	!
	! Save the pad character and pointer to the 256-byte table
	!
	! Note that it is very tacky and inconsistent to NOT actually make
	! a copy of this table.  However, this interface is only known to
	! VAX COBOL, and the table they pass hangs around.
	!
	MACRO
	    HAS_(O,P,S,E) = (.COLL_BLOCK[COLL_W_LENGTH] GEQU O+S/%BPUNIT) %;
	IF HAS_(COLL_B_PAD)  THEN CTX[COM_PAD]  = .COLL_BLOCK[COLL_B_PAD];
	IF HAS_(COLL_A_PTAB) THEN CTX[COM_PTAB] = .COLL_BLOCK[COLL_A_PTAB];
	END;
    END;


    RETURN__(SS$_NORMAL);
    END;
%FI

GLOBAL ROUTINE SOR$STAT
	(
	CODE:		REF VECTOR[1,LONG],	! Addr of code
	RESULT:		REF VECTOR[1,LONG],	! Addr to store result
	CONTEXT:	REF VECTOR[1,LONG]	! Addr of context longword
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns a statistic about the sort/merge.
!
! FORMAL PARAMETERS:
!
!	CODE.lr.r	Code for requested statistic
!	RESULT.lw.r	Result area
!	CONTEXT.ra.r	Longword pointing to work area
!
!	All parameters except CODE and RESULT are optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    FIRSTPARAMETER_(CODE);	! Required by PRESENT_ and NULL_ macros

    UNDECLARE
	%QUOTE COM_FLO_ABORT;	! Don't mess with this bit!

    CONTEXT_(CONTEXT, SOR$_SORT_ON);

    IF NULL_(RESULT) OR NULL_(CODE) THEN RETURN SOR$_MISS_PARAM;

    RESULT[0] =
	(BIND
	INP = CTX[COM_INP_DDB]: REF DDB_BLOCK,
	OUT = CTX[COM_OUT_DDB]: REF DDB_BLOCK;
	CASE .CODE[0] FROM 0 TO STAT_K_MAX_STAT OF
	SET
	[STAT_K_IDENT]:		UPLIT(%ASCIC IDENT);	! Address of ASCIC string for version number
	[STAT_K_REC_INP]:	.CTX[COM_INP_RECNUM];	! Records Input
	[STAT_K_REC_SOR]:				! Records Sorted
	    .CTX[COM_INP_RECNUM] - .CTX[COM_OMI_RECNUM];
	[STAT_K_REC_OUT]:	.CTX[COM_OUT_RECNUM];	! Records Output
	[STAT_K_LRL_INP]:	.CTX[COM_LRL];		! LRL for Input
	[STAT_K_LRL_INT]:	.CTX[COM_LRL_INT];	! Internal LRL
	[STAT_K_LRL_OUT]:	.CTX[COM_LRL_OUT];	! LRL for Output
	[STAT_K_NODES]:		.CTX[COM_STAT_NODES];	! Nodes in sort tree
	[STAT_K_INI_RUNS]:				! Initial dispersion runs
	    (IF .CTX[COM_STAT_RUNS] NEQ 0
	    THEN .CTX[COM_STAT_RUNS] ELSE .CTX[COM_RUNS]);
	[STAT_K_MRG_ORDER]:	.CTX[COM_STAT_MERGE];	! Maximum merge order
	[STAT_K_MRG_PASSES]:	.CTX[COM_STAT_PASSES];	! Number of merge passes
	[STAT_K_WRK_ALQ]:	SOR$$WRK_ALQ();		! Work file allocation
	[STAT_K_MBC_INP]:					! MBC for Input
	    (IF .INP EQL 0 THEN 0 ELSE .INP[DDB_RAB+RAB$B_MBC]);
	[STAT_K_MBC_OUT]:					! MBC for Output
	    (IF .OUT EQL 0 THEN 0 ELSE .OUT[DDB_RAB+RAB$B_MBC]);
	[STAT_K_MBF_INP]:					! MBF for Input
	    (IF .INP EQL 0 THEN 0 ELSE .INP[DDB_RAB+RAB$B_MBF]);
	[STAT_K_MBF_OUT]:					! MBF for Output
	    (IF .OUT EQL 0 THEN 0 ELSE .OUT[DDB_RAB+RAB$B_MBF]);
	[INRANGE,OUTRANGE]:
	    RETURN SOR$_NYI;
	TES);

    RETURN SS$_NORMAL;
    END;

END
ELUDOM
