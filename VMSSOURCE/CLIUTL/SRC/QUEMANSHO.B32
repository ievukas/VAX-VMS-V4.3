MODULE QUEMANSHO(%TITLE	'SHOW QUEUE command'
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Queue management commands.
!
! ABSTRACT:
!	This module implements the SHOW QUEUE command.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 10-Nov-1982
!
! MODIFIED BY:
!
!	V03-013	JAK0225		J A Krycka		16-Aug-1984
!		Restrict display of DEFAULT, SEPARATE, and FORM attributes
!		to nongeneric printer and terminal queues.
!
!	V03-012	JAK0222		J A Krycka		06-Aug-1984
!		Fix bug in display of DEFAULT list introduced in JAK0220.
!
!	V03-011	JAK0220		J A Krycka		20-Jul-1984
!		Support display of /DEFAULT=FEED and [NO]FEED.
!
!	V03-010	PCG0003		Peter George		13-Mar-1984
!		Change default behavior of SHOW QUEUE/OUTPUT.
!
!	V03-009	PCG0002		Peter George		29-Feb-1984
!		Add support for /OUTPUT qualifier.
!		Write values of /GENERIC out separately.
!
!	V03-008	PCG0001		Peter George		17-Feb-1984
!		Fix bug in wrap code and always clear buffer after writing it.
!
!	V03-007	LMP0140		L. Mark Pilant,		24-Aug-1983
!		Add support for alphanumeric UICs.
!
!	V03-006	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Change names to track $QUIDEF, implement page setup.
!
!	V03-005	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0114		Martin L. Jack,	23-Jun-1983
!		Rewrite using $GETQUI.
!
!	V03-003	MLJ0113		Martin L. Jack,	26-May-1983
!		Changes for job controller baselevel.
!
!	V03-002	MLJ0112		Martin L. Jack,	29-Apr-1983
!		Track queue format changes.
!
!	V03-001	MLJ0109		Martin L. Jack,	13-Apr-1983
!		Support new job and queue states and track queue format changes.
!
!**

LIBRARY 'SYS$LIBRARY:STARLET';


FORWARD ROUTINE
	SHOWQUEUE:		NOVALUE,	! Main routine
	OPEN_OUTPUT:		NOVALUE,	! Open the output file
	CLOSE_OUTPUT:		NOVALUE,	! Close the output file
	FORMAT_CHARACTERISTICS:	NOVALUE,	! Format characteristics mask
	FORMAT_CPU_TIME:	NOVALUE,	! Format CPU time value
	FORMAT_DEFAULT:		NOVALUE,	! Format /DEFAULT value
	FORMAT_MARGINS:		NOVALUE,	! Format /MARGIN value
	FORMAT_PARAMETERS:	NOVALUE,	! Format /PARAMETERS value
	FORMAT_PROTECTION:	NOVALUE,	! Format /PROTECTION value
	FORMAT_SCHEDULE:	NOVALUE,	! Format /SCHEDULE value
	FORMAT_SEPARATE:	NOVALUE,	! Format /SEPARATE value
	FORMAT_WORKING_SET:	NOVALUE,	! Format working set value
	SHOW_CHARACTERISTICS:	NOVALUE,	! Display characteristics
	SHOW_FORMS:		NOVALUE,	! Display forms
	SHOW_QUEUES:		NOVALUE,	! Display queues
	SHOW_JOBS:		NOVALUE,	! Display jobs
	SHOW_FILES:		NOVALUE,	! Display files
	FAO:			NOVALUE,	! Format information into line
	EOL:			NOVALUE,	! Write line buffer
	CEOL:			NOVALUE,	! EOL if line nonempty
	PUT_OUTPUT:		NOVALUE,	! Write a record to the listing
	EXIT_HANDLER:		NOVALUE;	! Exit handler


EXTERNAL ROUTINE
	CLI$GET_VALUE:		ADDRESSING_MODE(GENERAL),
					! Get entity value
	CLI$PRESENT:		ADDRESSING_MODE(GENERAL);
					! Determine if entity is present


LITERAL
	TRUE=		1,
	FALSE=		0;


STRUCTURE
	BBLOCK[O,P,S,E;N]=
	    [N]
	    (BBLOCK + O)<P,S,E>;


PSECT
	CODE=		CODE,
	PLIT=		CODE,
	OWN=		DATA,
	GLOBAL=		DATA;


LITERAL
	LIST_DEFAULT=	80,
	LIST_SIZE=	132;


OWN
	FLAGS:			BBLOCK[8],
	LIST_DESC:		VECTOR[2],
	LIST_BUFFER:		VECTOR[LIST_SIZE,BYTE],
	P2_DESC:		BBLOCK[DSC$K_D_BLN],	! Descriptor for P2
	FAB: 			$FAB_DECL,
	NAM:			$NAM_DECL,
	RAB:			$RAB_DECL,
	OUTPUT_DESC:		BBLOCK[DSC$C_S_BLN],
	OUTPUT_BUFF:		BBLOCK[NAM$C_MAXRSS];


MACRO
	V_FILES=		0,0,1,0 %,
	V_FULL=			0,1,1,0 %,
	V_TRUNCATE=		0,2,1,0 %,
	B_LEFT_MARGIN=		4,0,8,0 %,
	B_RIGHT_MARGIN=		5,0,8,0 %,
	B_PENDING_LINES=	6,0,8,0 %,
	B_PENDING_SPACES=	7,0,8,0 %;


MACRO
	FAO_(A)=
	    FAO(UPLIT BYTE (%ASCIC A)
		%IF NOT %NULL(%REMAINING) %THEN , %FI %REMAINING) %,

	FAOL_(A)=
	    BEGIN
	    FAO(UPLIT BYTE (%ASCIC A)
		%IF NOT %NULL(%REMAINING) %THEN , %FI %REMAINING);
	    EOL();
	    END %,

	EOL_(A)=
	    EOL() %,

	CEOL_(A)=
	    CEOL() %;


$SHR_MSGDEF(QUEMAN, 251, GLOBAL,
		(openout, severe),
		(closeout, severe),
		(writeerr, severe));

BUILTIN
	EMUL,
	SKPC,
	TESTBITCS,
	TESTBITSC;

GLOBAL ROUTINE SHOWQUEUE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine implements the SHOW QUEUE command.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	Command qualifiers.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	EXIT_BLOCK:	VECTOR[5];		! Exit control block


! Open the output file and get its width.
!
OPEN_OUTPUT();


! Initialize the listing descriptor.
!
LIST_DESC[0] = .FLAGS[B_RIGHT_MARGIN];
LIST_DESC[1] = LIST_BUFFER;


! Process the command qualifiers.
!
FLAGS[V_FILES] = CLI$PRESENT($DESCRIPTOR('FILES'));
FLAGS[V_FULL] = CLI$PRESENT($DESCRIPTOR('FULL'));


! Get the P2 parameter.
!
P2_DESC[DSC$W_LENGTH] = 0;
P2_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
P2_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
P2_DESC[DSC$A_POINTER] = 0;
CLI$GET_VALUE($DESCRIPTOR('P2'), P2_DESC);


! Ensure that pending wildcarding is erased.
!
$GETQUIW(FUNC=QUI$_CANCEL_OPERATION);


! Establish an exit handler to cancel the open wildcarding on an abnormal exit.
!
EXIT_BLOCK[0] = 0;
EXIT_BLOCK[1] = EXIT_HANDLER;
EXIT_BLOCK[2] = 1;
EXIT_BLOCK[3] = EXIT_BLOCK[4];
EXIT_BLOCK[4] = 0;
$DCLEXH(DESBLK=EXIT_BLOCK);


! Display the defined characteristics if requested.
!
IF CLI$PRESENT($DESCRIPTOR('CHARACTERISTICS'))
THEN
    SHOW_CHARACTERISTICS()


! Display the defined forms if requested.
!
ELSE IF CLI$PRESENT($DESCRIPTOR('FORMS'))
THEN
    SHOW_FORMS()


! Display queues if requested.
!
ELSE
    SHOW_QUEUES();


! Close the output file.
!
CLOSE_OUTPUT();


! Cancel the exit handler.
!
$CANEXH(DESBLK=EXIT_BLOCK);
END;

ROUTINE OPEN_OUTPUT: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine opens the output file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	/OUTPUT qualifier.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	DEVBUFSIZ:	VOLATILE,
	DEVNAM:		BBLOCK[DSC$C_S_BLN],
	ITMLST:		BBLOCK[16],
	STATUS;


! Get the name of the output file.
!
IF CLI$PRESENT($DESCRIPTOR('OUTPUT'))
THEN
    BEGIN
    OUTPUT_DESC[DSC$W_LENGTH] = 0;
    OUTPUT_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    OUTPUT_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
    OUTPUT_DESC[DSC$A_POINTER] = 0;
    CLI$GET_VALUE($DESCRIPTOR('OUTPUT'), OUTPUT_DESC);
    END
ELSE
    BEGIN
    OUTPUT_DESC[DSC$W_LENGTH] = 11;
    OUTPUT_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    OUTPUT_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    OUTPUT_DESC[DSC$A_POINTER] = UPLIT BYTE (%ASCII 'SYS$OUTPUT:');
    END;


! Initialize the FAB and NAM blocks.
!
$FAB_INIT(FAB=FAB,
	FNS=.OUTPUT_DESC[DSC$W_LENGTH],
	FNA=.OUTPUT_DESC[DSC$A_POINTER],
	FOP=<OFP,SQO>,
	DNM='.LIS',
	RAT=CR,
	FAC=PUT,
	NAM=NAM);

$NAM_INIT(NAM=NAM,
	ESA=OUTPUT_BUFF,
	ESS=NAM$C_MAXRSS,
	RSA=OUTPUT_BUFF,
	RSS=NAM$C_MAXRSS);


! Open the output file and save the file name away.
!
STATUS = $CREATE(FAB=FAB);

IF .NAM[NAM$B_RSL] NEQ 0
THEN
    BEGIN
    OUTPUT_DESC[DSC$W_LENGTH] = .NAM[NAM$B_RSL];
    OUTPUT_DESC[DSC$A_POINTER] = OUTPUT_BUFF;
    END
ELSE IF .NAM[NAM$B_ESL] NEQ 0
THEN
    BEGIN
    OUTPUT_DESC[DSC$W_LENGTH] = .NAM[NAM$B_ESL];
    OUTPUT_DESC[DSC$A_POINTER] = OUTPUT_BUFF;
    END;

IF NOT .STATUS
THEN 
    SIGNAL_STOP(QUEMAN$_OPENOUT,1,OUTPUT_DESC,.STATUS,.FAB[FAB$L_STV]);


! Initialize the RAB and connect the record stream.
!
$RAB_INIT(RAB=RAB,
	RAC=SEQ,
	FAB=FAB);

STATUS = $CONNECT(RAB=RAB);
IF NOT .STATUS
THEN 
    SIGNAL_STOP(QUEMAN$_OPENOUT,1,OUTPUT_DESC,.STATUS,.RAB[RAB$L_STV]);


! Do a $GETDVI to get the width
!
DEVNAM[DSC$W_LENGTH] = .NAM[NAM$B_DEV];
DEVNAM[DSC$A_POINTER] = .NAM[NAM$L_DEV];
ITMLST[0,0,16,0] = %ALLOCATION(DEVBUFSIZ);
ITMLST[2,0,16,0] = DVI$_DEVBUFSIZ;
ITMLST[4,0,32,0] = DEVBUFSIZ;
ITMLST[8,0,32,0] = 0;
ITMLST[12,0,32,0] = 0;
FLAGS[B_RIGHT_MARGIN] = LIST_DEFAULT;
IF $GETDVIW(DEVNAM=DEVNAM, ITMLST=ITMLST)
THEN 
    FLAGS[B_RIGHT_MARGIN] = MINU(.DEVBUFSIZ, %ALLOCATION(LIST_BUFFER));

END;

ROUTINE CLOSE_OUTPUT: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine closes the output file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	Output FAB and RAB.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS;


! Disconnect the record stream.
!
IF NOT (STATUS = $DISCONNECT(RAB=RAB))
THEN 
    SIGNAL(QUEMAN$_CLOSEOUT,1,OUTPUT_DESC,.STATUS,.RAB[RAB$L_STV]);


! Close the file.
!
IF NOT (STATUS = $CLOSE(FAB=FAB))
THEN 
    SIGNAL(QUEMAN$_CLOSEOUT,1,OUTPUT_DESC,.STATUS,.FAB[FAB$L_STV]);

END;

ROUTINE FORMAT_CHARACTERISTICS(C): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats a characteristics mask.
!
! INPUT PARAMETERS:
!	C		- Pointer to 16-byte characteristics mask.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	C:		REF BITVECTOR;	! Pointer to characteristics vector
LOCAL
	UNDONE,				! Count of set bits left
	LPUNC,				! Leading punctuation
	TPUNC;				! Trailing punctuation


! Count the number of characteristics to display.
!
UNDONE = 0;
INCR I FROM 0 TO 127 DO IF .C[.I] THEN UNDONE = .UNDONE + 1;


IF .UNDONE NEQ 0
THEN
    BEGIN
    LPUNC = UPLIT BYTE (%ASCIC '/CHAR=(');
    INCR I FROM 0 TO 127 DO
	BEGIN
	IF .C[.I]
	THEN
	    BEGIN
	    TPUNC = %ASCIC ',';
	    UNDONE = .UNDONE - 1;
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!AC!UL!AC', .LPUNC, .I, TPUNC);
	    LPUNC = UPLIT BYTE (%ASCIC '');
	    END;
	IF .UNDONE EQL 0 THEN EXITLOOP;
	END;
    FLAGS[B_PENDING_SPACES] = 1;
    END;
END;

ROUTINE FORMAT_CPU_TIME(NAME,VALUE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats a CPU time parameter.
!
! INPUT PARAMETERS:
!	NAME		- Name of the CPU time parameter.
!	VALUE		- Value of the parameter.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
IF .VALUE EQL 0
THEN
    FAO_('/!AC=INFINITE', .NAME)
ELSE
    BEGIN
    LOCAL
	TIME_STRING:	BBLOCK[16],
	TIME_DESC:	VECTOR[2],
	DELTA:		VECTOR[2];


    ! Convert the time expressed in 10 ms units to a system delta-time value.
    !
    EMUL(%REF(-100000), VALUE, %REF(0), DELTA);


    ! Convert the system delta-time value to a string.
    !
    TIME_DESC[0] = %ALLOCATION(TIME_STRING);
    TIME_DESC[1] = TIME_STRING;
    $ASCTIM(TIMBUF=TIME_DESC, TIMADR=DELTA);


    ! Edit the string to make it more readable.  If the string specifies zero
    ! days or zero hundredths of seconds, remove these fields from the string
    ! since they are rarely nonzero.  Remove leading spaces from the string.
    ! Also, convert the space that separates days from hours to a hyphen to
    ! match the delta-time input syntax.
    !
    IF .TIME_STRING[0,0,32,0] EQL '   0' THEN TIME_STRING[3,0,8,0] = %C' ';
    IF .TIME_STRING[13,0,24,0] EQL '.00' THEN TIME_DESC[0] = 13;
    SKPC(%REF(%C' '), TIME_DESC[0], .TIME_DESC[1]; TIME_DESC[0], TIME_DESC[1]);
    TIME_STRING[4,0,8,0] = %C'-';
    FAO_('/!AC=!AS', .NAME, TIME_DESC);
    END;
FLAGS[B_PENDING_SPACES] = 1;
END;

ROUTINE FORMAT_DEFAULT(QUEUE_FLAGS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats the value of the /DEFAULT qualifier.
!
! INPUT PARAMETERS:
!	QUEUE_FLAGS	- Queue flags item.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QUEUE_FLAGS:	BBLOCK;		! Queue flags
LOCAL
	UNDONE:		BBLOCK[4],	! What's left to do
	LPUNC,
	TPUNC;
MACRO
	V_BURST=	0,0,1,0 %,
	V_FEED=		0,1,1,0 %,
	V_FLAG=		0,2,1,0 %,
	V_TRAILER=	0,3,1,0 %;


UNDONE = 0;
IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_BURST]
OR .QUEUE_FLAGS[QUI$V_QUEUE_FILE_BURST_ONE]
    THEN UNDONE[V_BURST] = TRUE;
IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_PAGINATE]
    THEN UNDONE[V_FEED] = TRUE;
IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_FLAG]
OR .QUEUE_FLAGS[QUI$V_QUEUE_FILE_FLAG_ONE]
    THEN UNDONE[V_FLAG] = TRUE;
IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_TRAILER]
OR .QUEUE_FLAGS[QUI$V_QUEUE_FILE_TRAILER_ONE]
    THEN UNDONE[V_TRAILER] = TRUE;


IF .UNDONE NEQ 0
THEN
    BEGIN
    LPUNC = UPLIT BYTE (%ASCIC '/DEFAULT=(');
    WHILE .UNDONE NEQ 0 DO
	BEGIN
	TPUNC = %ASCIC ',';


	IF TESTBITSC(UNDONE[V_BURST])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_BURST_ONE]
		THEN FAO_('!ACBURST=ONE!AC', .LPUNC, TPUNC)
		ELSE FAO_('!ACBURST!AC', .LPUNC, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_FEED])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_PAGINATE]
		THEN FAO_('!ACFEED!AC', .LPUNC, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_FLAG])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_FLAG_ONE]
		THEN FAO_('!ACFLAG=ONE!AC', .LPUNC, TPUNC)
		ELSE FAO_('!ACFLAG!AC', .LPUNC, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_TRAILER])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_FILE_TRAILER_ONE]
		THEN FAO_('!ACTRAILER=ONE!AC', .LPUNC, TPUNC)
		ELSE FAO_('!ACTRAILER!AC', .LPUNC, TPUNC);
	    END;


	LPUNC = UPLIT BYTE (%ASCIC '');
	END;
    FLAGS[B_PENDING_SPACES] = 1;
    END;
END;

ROUTINE FORMAT_MARGINS(BOTTOM,LEFT,RIGHT,TOP): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats the value of the /MARGIN qualifier.
!
! INPUT PARAMETERS:
!	BOTTOM		- Values of the four margins
!	LEFT		-
!	RIGHT		-
!	TOP		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	UNDONE:		BBLOCK[4],	! What's left to do
	LPUNC,
	TPUNC;
MACRO
	V_TOP=		0,0,1,0 %,
	V_BOTTOM=	0,1,1,0 %,
	V_LEFT=		0,2,1,0 %,
	V_RIGHT=	0,3,1,0 %;


UNDONE = 0;
IF .TOP NEQ 0
    THEN UNDONE[V_TOP] = TRUE;
IF .BOTTOM NEQ 0
    THEN UNDONE[V_BOTTOM] = TRUE;
IF .LEFT NEQ 0
    THEN UNDONE[V_LEFT] = TRUE;
IF .RIGHT NEQ 0
    THEN UNDONE[V_RIGHT] = TRUE;


IF .UNDONE NEQ 0
THEN
    BEGIN
    LPUNC = UPLIT BYTE (%ASCIC '/MARGIN=(');
    WHILE .UNDONE NEQ 0 DO
	BEGIN
	TPUNC = %ASCIC ',';


	IF TESTBITSC(UNDONE[V_TOP])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACTOP=!UL!AC', .LPUNC, .TOP, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_BOTTOM])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACBOTTOM=!UL!AC', .LPUNC, .BOTTOM, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_LEFT])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACLEFT=!UL!AC', .LPUNC, .LEFT, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_RIGHT])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACRIGHT=!UL!AC', .LPUNC, .RIGHT, TPUNC);
	    END;


	LPUNC = UPLIT BYTE (%ASCIC '');
	END;
    FLAGS[B_PENDING_SPACES] = 1;
    END;
END;

ROUTINE FORMAT_PARAMETERS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats the value of the /PARAMETERS qualifier.
!
! INPUT PARAMETERS:
!	Pairs of <length, address>.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	ACTUALPARAMETER;
LOCAL
	UNDONE,
	LPUNC,
	TPUNC;


UNDONE = 8;
DECR I FROM 15 TO 1 BY 2 DO
    BEGIN
    IF ACTUALPARAMETER(.I) NEQ 0 THEN EXITLOOP;
    UNDONE = .UNDONE - 1;
    END;


IF .UNDONE NEQ 0
THEN
    BEGIN
    LPUNC = UPLIT BYTE (%ASCIC '/PARAM=(');
    INCR I FROM 1 TO 15 BY 2 DO
	BEGIN
	TPUNC = %ASCIC ',';
	UNDONE = .UNDONE - 1;
	IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	FAO_('!AC"!AF"!AC',
	    .LPUNC,
	    ACTUALPARAMETER(.I), ACTUALPARAMETER(.I + 1),
	    TPUNC);
	LPUNC = UPLIT BYTE (%ASCIC '');
	IF .UNDONE EQL 0 THEN EXITLOOP;
	END;
    FLAGS[B_PENDING_SPACES] = 1;
    END;
END;

ROUTINE FORMAT_PROTECTION(VALUE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats a protection value.
!
! INPUT PARAMETERS:
!	VALUE		- Value of the parameter.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	LPUNC,
	TPUNC;
BIND
	SOGW = UPLIT('SOGW'): VECTOR[,BYTE],
	RWED = UPLIT('RWED'): VECTOR[,BYTE];


LPUNC = UPLIT BYTE (%ASCIC '/PROTECTION=(');
INCR I FROM 0 TO 3 DO
    BEGIN
    TPUNC = %ASCIC ',';
    IF .I EQL 3 THEN TPUNC = %ASCIC ')';
    IF .VALUE<.I*4, 4> NEQ %B'1111'
    THEN
	BEGIN
	LOCAL
	    T:		VECTOR[4,BYTE],
	    TL;

	TL = 0;
	INCR J FROM 0 TO 3 DO
	    BEGIN
	    IF NOT .VALUE<.I*4+.J, 1>
	    THEN
		BEGIN
		T[.TL] = .RWED[.J];
		TL = .TL + 1;
		END;
	    END;
	FAO_('!AC!AD:!AD!AC', .LPUNC, 1, SOGW[.I], .TL, T, TPUNC);		
	END
    ELSE
	FAO_('!AC!AD!AC', .LPUNC, 1, SOGW[.I], TPUNC);

    LPUNC = UPLIT BYTE (%ASCIC '');
    END;
FLAGS[B_PENDING_SPACES] = 1;
END;

ROUTINE FORMAT_SCHEDULE(QUEUE_FLAGS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats the value of the /SCHEDULE qualifier.
!
! INPUT PARAMETERS:
!	QUEUE_FLAGS		- Queue flags item
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QUEUE_FLAGS:	BBLOCK;		! Queue flags item
LOCAL
	UNDONE:		BBLOCK[4],	! What's left to do
	LPUNC,
	TPUNC;
MACRO
	V_SIZE=		0,0,1,0 %;


UNDONE = 0;
IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_JOB_SIZE_SCHED]
    THEN UNDONE[V_SIZE] = TRUE;


IF .UNDONE NEQ 0
THEN
    BEGIN
    LPUNC = UPLIT BYTE (%ASCIC '/SCHEDULE=(');
    WHILE .UNDONE NEQ 0 DO
	BEGIN
	TPUNC = %ASCIC ',';


	IF TESTBITSC(UNDONE[V_SIZE])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACNOSIZE!AC', .LPUNC, TPUNC);
	    END;


	LPUNC = UPLIT BYTE (%ASCIC '');
	END;
    FLAGS[B_PENDING_SPACES] = 1;
    END;
END;

ROUTINE FORMAT_SEPARATE(QUEUE_FLAGS,JOB_RESET_MODULES_LENGTH,JOB_RESET_MODULES): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats the value of the /SEPARATE qualifier.
!
! INPUT PARAMETERS:
!	QUEUE_FLAGS		- Queue flags item
!	JOB_RESET_MODULES_LENGTH - Descriptor for job reset modules item
!	JOB_RESET_MODULES	-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QUEUE_FLAGS:	BBLOCK;		! Queue flags item
LOCAL
	UNDONE:		BBLOCK[4],	! What's left to do
	LPUNC,
	TPUNC;
MACRO
	V_BURST=	0,0,1,0 %,
	V_FLAG=		0,1,1,0 %,
	V_RESET=	0,2,1,0 %,
	V_TRAILER=	0,3,1,0 %;


UNDONE = 0;
IF .QUEUE_FLAGS[QUI$V_QUEUE_JOB_BURST]
    THEN UNDONE[V_BURST] = TRUE;
IF .QUEUE_FLAGS[QUI$V_QUEUE_JOB_FLAG]
    THEN UNDONE[V_FLAG] = TRUE;
IF .JOB_RESET_MODULES_LENGTH NEQ 0
    THEN UNDONE[V_RESET] = TRUE;
IF .QUEUE_FLAGS[QUI$V_QUEUE_JOB_TRAILER]
    THEN UNDONE[V_TRAILER] = TRUE;


IF .UNDONE NEQ 0
THEN
    BEGIN
    LPUNC = UPLIT BYTE (%ASCIC '/SEPARATE=(');
    WHILE .UNDONE NEQ 0 DO
	BEGIN
	TPUNC = %ASCIC ',';


	IF TESTBITSC(UNDONE[V_BURST])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACBURST!AC', .LPUNC, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_FLAG])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACFLAG!AC', .LPUNC, TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_RESET])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACRESET=(!AF)!AC',
		.LPUNC,
		.JOB_RESET_MODULES_LENGTH, .JOB_RESET_MODULES,
		TPUNC);
	    END


	ELSE IF TESTBITSC(UNDONE[V_TRAILER])
	THEN
	    BEGIN
	    IF .UNDONE EQL 0 THEN TPUNC = %ASCIC ')';
	    FAO_('!ACTRAILER!AC', .LPUNC, TPUNC);
	    END;


	LPUNC = UPLIT BYTE (%ASCIC '');
	END;
    FLAGS[B_PENDING_SPACES] = 1;
    END;
END;

ROUTINE FORMAT_WORKING_SET(NAME,VALUE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats a working set parameter.
!
! INPUT PARAMETERS:
!	NAME		- Name of the working set parameter.
!	VALUE		- Value of the parameter.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
IF .VALUE EQL 0
    THEN FAO_('/!AC=NONE', .NAME)
    ELSE FAO_('/!AC=!UL', .NAME, .VALUE);
FLAGS[B_PENDING_SPACES] = 1;
END;

ROUTINE SHOW_CHARACTERISTICS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine displays the defined characteristics.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	ITMLST:				BBLOCK[52],
	CHARACTERISTIC_NAME:		VOLATILE VECTOR[31,BYTE],
	CHARACTERISTIC_NAME_LENGTH:	VOLATILE WORD,
	CHARACTERISTIC_NUMBER:		VOLATILE,
	STATUS,
	IOSB:				VECTOR[2],
	CHARACTERISTIC_PRINTED;


FLAGS[V_TRUNCATE] = TRUE;
CHARACTERISTIC_PRINTED = FALSE;


! Initialize the item list.
!
ITMLST[0,0,16,0] = .P2_DESC[DSC$W_LENGTH];
ITMLST[2,0,16,0] = QUI$_SEARCH_NAME;
ITMLST[4,0,32,0] = .P2_DESC[DSC$A_POINTER];
ITMLST[8,0,32,0] = 0;

ITMLST[12,0,16,0] = 4;
ITMLST[14,0,16,0] = QUI$_SEARCH_FLAGS;
ITMLST[16,0,32,0] = UPLIT(QUI$M_SEARCH_WILDCARD);
ITMLST[20,0,32,0] = 0;

ITMLST[24,0,16,0] = %ALLOCATION(CHARACTERISTIC_NAME);
ITMLST[26,0,16,0] = QUI$_CHARACTERISTIC_NAME;
ITMLST[28,0,32,0] = CHARACTERISTIC_NAME;
ITMLST[32,0,32,0] = CHARACTERISTIC_NAME_LENGTH;

ITMLST[36,0,16,0] = %ALLOCATION(CHARACTERISTIC_NUMBER);
ITMLST[38,0,16,0] = QUI$_CHARACTERISTIC_NUMBER;
ITMLST[40,0,32,0] = CHARACTERISTIC_NUMBER;
ITMLST[44,0,32,0] = 0;

ITMLST[48,0,32,0] = 0;


! Loop to get all characteristics.
!
WHILE TRUE DO
    BEGIN
    STATUS = $GETQUIW(
	FUNC=QUI$_DISPLAY_CHARACTERISTIC,
	ITMLST=ITMLST,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB;


    IF TESTBITCS(CHARACTERISTIC_PRINTED)
    THEN
	BEGIN
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL(.STATUS);
	    EXITLOOP;
	    END;
	FAOL_('Characteristic name                  Number');
	FAOL_('-------------------                  ------');
	END
    ELSE
	BEGIN
	IF NOT .STATUS THEN EXITLOOP;
	END;


    FAOL_('!31AF      !6UL',
	.CHARACTERISTIC_NAME_LENGTH, CHARACTERISTIC_NAME,
	.CHARACTERISTIC_NUMBER);
    END;


FLAGS[V_TRUNCATE] = FALSE;
END;

ROUTINE SHOW_FORMS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine displays the defined forms.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	ITMLST:				BBLOCK[184],
	FORM_DESCRIPTION:		VOLATILE VECTOR[255,BYTE],
	FORM_DESCRIPTION_LENGTH:	VOLATILE WORD,
	FORM_FLAGS:			VOLATILE BBLOCK[4],
	FORM_LENGTH:			VOLATILE,
	FORM_MARGIN_BOTTOM:		VOLATILE,
	FORM_MARGIN_LEFT:		VOLATILE,
	FORM_MARGIN_RIGHT:		VOLATILE,
	FORM_MARGIN_TOP:		VOLATILE,
	FORM_NAME:			VOLATILE VECTOR[31,BYTE],
	FORM_NAME_LENGTH:		VOLATILE WORD,
	FORM_NUMBER:			VOLATILE,
	FORM_SETUP_MODULES:		VOLATILE VECTOR[255,BYTE],
	FORM_SETUP_MODULES_LENGTH:	VOLATILE WORD,
	FORM_STOCK:			VOLATILE VECTOR[31,BYTE],
	FORM_STOCK_LENGTH:		VOLATILE WORD,
	FORM_WIDTH:			VOLATILE,
	PAGE_SETUP_MODULES:		VOLATILE VECTOR[255,BYTE],
	PAGE_SETUP_MODULES_LENGTH:	VOLATILE WORD,
	STATUS,
	IOSB:				VECTOR[2],
	FORM_PRINTED;


FORM_PRINTED = FALSE;


! Initialize the item list.
!
ITMLST[0,0,16,0] = .P2_DESC[DSC$W_LENGTH];
ITMLST[2,0,16,0] = QUI$_SEARCH_NAME;
ITMLST[4,0,32,0] = .P2_DESC[DSC$A_POINTER];
ITMLST[8,0,32,0] = 0;

ITMLST[12,0,16,0] = 4;
ITMLST[14,0,16,0] = QUI$_SEARCH_FLAGS;
ITMLST[16,0,32,0] = UPLIT(QUI$M_SEARCH_WILDCARD);
ITMLST[20,0,32,0] = 0;

ITMLST[24,0,16,0] = %ALLOCATION(FORM_NAME);
ITMLST[26,0,16,0] = QUI$_FORM_NAME;
ITMLST[28,0,32,0] = FORM_NAME;
ITMLST[32,0,32,0] = FORM_NAME_LENGTH;

ITMLST[36,0,16,0] = %ALLOCATION(FORM_NUMBER);
ITMLST[38,0,16,0] = QUI$_FORM_NUMBER;
ITMLST[40,0,32,0] = FORM_NUMBER;
ITMLST[44,0,32,0] = 0;

ITMLST[48,0,16,0] = %ALLOCATION(FORM_DESCRIPTION);
ITMLST[50,0,16,0] = QUI$_FORM_DESCRIPTION;
ITMLST[52,0,32,0] = FORM_DESCRIPTION;
ITMLST[56,0,32,0] = FORM_DESCRIPTION_LENGTH;

ITMLST[60,0,32,0] = 0;


IF .FLAGS[V_FULL]
THEN
    BEGIN
    ITMLST[60,0,16,0] = %ALLOCATION(FORM_FLAGS);
    ITMLST[62,0,16,0] = QUI$_FORM_FLAGS;
    ITMLST[64,0,32,0] = FORM_FLAGS;
    ITMLST[68,0,32,0] = 0;

    ITMLST[72,0,16,0] = %ALLOCATION(FORM_LENGTH);
    ITMLST[74,0,16,0] = QUI$_FORM_LENGTH;
    ITMLST[76,0,32,0] = FORM_LENGTH;
    ITMLST[80,0,32,0] = 0;

    ITMLST[84,0,16,0] = %ALLOCATION(FORM_MARGIN_BOTTOM);
    ITMLST[86,0,16,0] = QUI$_FORM_MARGIN_BOTTOM;
    ITMLST[88,0,32,0] = FORM_MARGIN_BOTTOM;
    ITMLST[92,0,32,0] = 0;

    ITMLST[96,0,16,0] = %ALLOCATION(FORM_MARGIN_LEFT);
    ITMLST[98,0,16,0] = QUI$_FORM_MARGIN_LEFT;
    ITMLST[100,0,32,0] = FORM_MARGIN_LEFT;
    ITMLST[104,0,32,0] = 0;

    ITMLST[108,0,16,0] = %ALLOCATION(FORM_MARGIN_RIGHT);
    ITMLST[110,0,16,0] = QUI$_FORM_MARGIN_RIGHT;
    ITMLST[112,0,32,0] = FORM_MARGIN_RIGHT;
    ITMLST[116,0,32,0] = 0;

    ITMLST[120,0,16,0] = %ALLOCATION(FORM_MARGIN_TOP);
    ITMLST[122,0,16,0] = QUI$_FORM_MARGIN_TOP;
    ITMLST[124,0,32,0] = FORM_MARGIN_TOP;
    ITMLST[128,0,32,0] = 0;

    ITMLST[132,0,16,0] = %ALLOCATION(FORM_SETUP_MODULES);
    ITMLST[134,0,16,0] = QUI$_FORM_SETUP_MODULES;
    ITMLST[136,0,32,0] = FORM_SETUP_MODULES;
    ITMLST[140,0,32,0] = FORM_SETUP_MODULES_LENGTH;

    ITMLST[144,0,16,0] = %ALLOCATION(FORM_STOCK);
    ITMLST[146,0,16,0] = QUI$_FORM_STOCK;
    ITMLST[148,0,32,0] = FORM_STOCK;
    ITMLST[152,0,32,0] = FORM_STOCK_LENGTH;

    ITMLST[156,0,16,0] = %ALLOCATION(FORM_WIDTH);
    ITMLST[158,0,16,0] = QUI$_FORM_WIDTH;
    ITMLST[160,0,32,0] = FORM_WIDTH;
    ITMLST[164,0,32,0] = 0;

    ITMLST[168,0,16,0] = %ALLOCATION(PAGE_SETUP_MODULES);
    ITMLST[170,0,16,0] = QUI$_PAGE_SETUP_MODULES;
    ITMLST[172,0,32,0] = PAGE_SETUP_MODULES;
    ITMLST[176,0,32,0] = PAGE_SETUP_MODULES_LENGTH;

    ITMLST[180,0,32,0] = 0;
    END;


! Loop to get all forms.
!
WHILE TRUE DO
    BEGIN
    STATUS = $GETQUIW(
	FUNC=QUI$_DISPLAY_FORM,
	ITMLST=ITMLST,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB;


    FLAGS[V_TRUNCATE] = TRUE;
    IF TESTBITCS(FORM_PRINTED)
    THEN
	BEGIN
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL(.STATUS);
	    EXITLOOP;
	    END;
	FAOL_('Form name                            Number   Description');
	FAOL_('---------                            ------   -----------');
	END
    ELSE
	BEGIN
	IF NOT .STATUS THEN EXITLOOP;
	END;


    FAOL_('!31AF   !9UL   !AF',
	.FORM_NAME_LENGTH, FORM_NAME,
	.FORM_NUMBER,
	.FORM_DESCRIPTION_LENGTH, FORM_DESCRIPTION);
    FLAGS[V_TRUNCATE] = FALSE;


    IF .FLAGS[V_FULL]
    THEN
	BEGIN
	FLAGS[B_LEFT_MARGIN] = 4;
	FLAGS[B_PENDING_SPACES] = 4;


	FAO_('/LENGTH=!UL', .FORM_LENGTH);
	FLAGS[B_PENDING_SPACES] = 1;


	FORMAT_MARGINS(
	    .FORM_MARGIN_BOTTOM,
	    .FORM_MARGIN_LEFT,
	    .FORM_MARGIN_RIGHT,
	    .FORM_MARGIN_TOP);


	IF .PAGE_SETUP_MODULES_LENGTH NEQ 0
	THEN
	    BEGIN
	    FAO_('/PAGE_SETUP=(!AF)',
		.PAGE_SETUP_MODULES_LENGTH, PAGE_SETUP_MODULES);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF .FORM_SETUP_MODULES_LENGTH NEQ 0
	THEN
	    BEGIN
	    FAO_('/SETUP=(!AF)',
		.FORM_SETUP_MODULES_LENGTH, FORM_SETUP_MODULES);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF .FORM_FLAGS[QUI$V_FORM_SHEET_FEED]
	THEN
	    BEGIN
	    FAO_('/SHEET_FEED');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	FAO_('/STOCK=!AF',
	    .FORM_STOCK_LENGTH, FORM_STOCK);
	FLAGS[B_PENDING_SPACES] = 1;


	IF .FORM_FLAGS[QUI$V_FORM_TRUNCATE]
	THEN
	    BEGIN
	    FAO_('/TRUNCATE');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	FAO_('/WIDTH=!UL', .FORM_WIDTH);
	FLAGS[B_PENDING_SPACES] = 1;


	IF .FORM_FLAGS[QUI$V_FORM_WRAP]
	THEN
	    BEGIN
	    FAO_('/WRAP');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	FLAGS[B_PENDING_SPACES] = 0;
	FLAGS[B_LEFT_MARGIN] = 0;
	CEOL_();
	END;
    END;
END;

ROUTINE SHOW_QUEUES: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine displays queues.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	ITMLST:				BBLOCK[304],
	ASSIGNED_QUEUE_NAME:		VOLATILE VECTOR[39,BYTE],
	ASSIGNED_QUEUE_NAME_LENGTH:	VOLATILE WORD,
	BASE_PRIORITY:			VOLATILE,
	CHARACTERISTICS:		VOLATILE BITVECTOR[128],
	CPU_DEFAULT:			VOLATILE,
	CPU_LIMIT:			VOLATILE,
	DEVICE_NAME:			VOLATILE VECTOR[31,BYTE],
	DEVICE_NAME_LENGTH:		VOLATILE WORD,
	FORM_NAME:			VOLATILE VECTOR[31,BYTE],
	FORM_NAME_LENGTH:		VOLATILE WORD,
	GENERIC_TARGET:			VOLATILE VECTOR[255,BYTE],
	GENERIC_TARGET_LENGTH:		VOLATILE WORD,
	JOB_LIMIT:			VOLATILE,
	JOB_RESET_MODULES:		VOLATILE VECTOR[255,BYTE],
	JOB_RESET_MODULES_LENGTH:	VOLATILE WORD,
	JOB_SIZE_MAXIMUM:		VOLATILE,
	JOB_SIZE_MINIMUM:		VOLATILE,
	LIBRARY_SPECIFICATION:		VOLATILE VECTOR[39,BYTE],
	LIBRARY_SPECIFICATION_LENGTH:	VOLATILE WORD,
	OWNER_UIC:			VOLATILE,
	PROCESSOR:			VOLATILE VECTOR[39,BYTE],
	PROCESSOR_LENGTH:		VOLATILE WORD,
	PROTECTION:			VOLATILE,
	QUEUE_FLAGS:			VOLATILE BBLOCK[4],
	QUEUE_NAME:			VOLATILE VECTOR[31,BYTE],
	QUEUE_NAME_LENGTH:		VOLATILE WORD,
	QUEUE_STATUS:			VOLATILE BBLOCK[4],
	SEARCH_FLAGS:			VOLATILE BBLOCK[4],
	SCSNODE_NAME:			VOLATILE VECTOR[6,BYTE],
	SCSNODE_NAME_LENGTH:		VOLATILE WORD,
	WSDEFAULT:			VOLATILE,
	WSEXTENT:			VOLATILE,
	WSQUOTA:			VOLATILE,
	STATUS,
	IOSB:				VECTOR[2],
	QUEUE_PRINTED,
	TYPE;


QUEUE_PRINTED = FALSE;


SEARCH_FLAGS = QUI$M_SEARCH_WILDCARD;
IF CLI$PRESENT($DESCRIPTOR('BATCH'))
    THEN SEARCH_FLAGS[QUI$V_SEARCH_BATCH] = TRUE;
IF CLI$PRESENT($DESCRIPTOR('DEVICE'))
    THEN SEARCH_FLAGS[QUI$V_SEARCH_SYMBIONT] = TRUE;


! Initialize item list.
!
ITMLST[0,0,16,0] = .P2_DESC[DSC$W_LENGTH];
ITMLST[2,0,16,0] = QUI$_SEARCH_NAME;
ITMLST[4,0,32,0] = .P2_DESC[DSC$A_POINTER];
ITMLST[8,0,32,0] = 0;

ITMLST[12,0,16,0] = %ALLOCATION(SEARCH_FLAGS);
ITMLST[14,0,16,0] = QUI$_SEARCH_FLAGS;
ITMLST[16,0,32,0] = SEARCH_FLAGS;
ITMLST[20,0,32,0] = 0;

ITMLST[24,0,16,0] = %ALLOCATION(ASSIGNED_QUEUE_NAME);
ITMLST[26,0,16,0] = QUI$_ASSIGNED_QUEUE_NAME;
ITMLST[28,0,32,0] = ASSIGNED_QUEUE_NAME;
ITMLST[32,0,32,0] = ASSIGNED_QUEUE_NAME_LENGTH;

ITMLST[36,0,16,0] = %ALLOCATION(DEVICE_NAME);
ITMLST[38,0,16,0] = QUI$_DEVICE_NAME;
ITMLST[40,0,32,0] = DEVICE_NAME;
ITMLST[44,0,32,0] = DEVICE_NAME_LENGTH;

ITMLST[48,0,16,0] = %ALLOCATION(PROCESSOR);
ITMLST[50,0,16,0] = QUI$_PROCESSOR;
ITMLST[52,0,32,0] = PROCESSOR;
ITMLST[56,0,32,0] = PROCESSOR_LENGTH;

ITMLST[60,0,16,0] = %ALLOCATION(QUEUE_FLAGS);
ITMLST[62,0,16,0] = QUI$_QUEUE_FLAGS;
ITMLST[64,0,32,0] = QUEUE_FLAGS;
ITMLST[68,0,32,0] = 0;

ITMLST[72,0,16,0] = %ALLOCATION(QUEUE_NAME);
ITMLST[74,0,16,0] = QUI$_QUEUE_NAME;
ITMLST[76,0,32,0] = QUEUE_NAME;
ITMLST[80,0,32,0] = QUEUE_NAME_LENGTH;

ITMLST[84,0,16,0] = %ALLOCATION(QUEUE_STATUS);
ITMLST[86,0,16,0] = QUI$_QUEUE_STATUS;
ITMLST[88,0,32,0] = QUEUE_STATUS;
ITMLST[92,0,32,0] = 0;

ITMLST[96,0,16,0] = %ALLOCATION(SCSNODE_NAME);
ITMLST[98,0,16,0] = QUI$_SCSNODE_NAME;
ITMLST[100,0,32,0] = SCSNODE_NAME;
ITMLST[104,0,32,0] = SCSNODE_NAME_LENGTH;

ITMLST[108,0,32,0] = 0;


IF .FLAGS[V_FULL]
THEN
    BEGIN
    ITMLST[108,0,16,0] = %ALLOCATION(BASE_PRIORITY);
    ITMLST[110,0,16,0] = QUI$_BASE_PRIORITY;
    ITMLST[112,0,32,0] = BASE_PRIORITY;
    ITMLST[116,0,32,0] = 0;

    ITMLST[120,0,16,0] = %ALLOCATION(CHARACTERISTICS);
    ITMLST[122,0,16,0] = QUI$_CHARACTERISTICS;
    ITMLST[124,0,32,0] = CHARACTERISTICS;
    ITMLST[128,0,32,0] = 0;

    ITMLST[132,0,16,0] = %ALLOCATION(CPU_DEFAULT);
    ITMLST[134,0,16,0] = QUI$_CPU_DEFAULT;
    ITMLST[136,0,32,0] = CPU_DEFAULT;
    ITMLST[140,0,32,0] = 0;

    ITMLST[144,0,16,0] = %ALLOCATION(CPU_LIMIT);
    ITMLST[146,0,16,0] = QUI$_CPU_LIMIT;
    ITMLST[148,0,32,0] = CPU_LIMIT;
    ITMLST[152,0,32,0] = 0;

    ITMLST[156,0,16,0] = %ALLOCATION(FORM_NAME);
    ITMLST[158,0,16,0] = QUI$_FORM_NAME;
    ITMLST[160,0,32,0] = FORM_NAME;
    ITMLST[164,0,32,0] = FORM_NAME_LENGTH;

    ITMLST[168,0,16,0] = %ALLOCATION(GENERIC_TARGET);
    ITMLST[170,0,16,0] = QUI$_GENERIC_TARGET;
    ITMLST[172,0,32,0] = GENERIC_TARGET;
    ITMLST[176,0,32,0] = GENERIC_TARGET_LENGTH;

    ITMLST[180,0,16,0] = %ALLOCATION(JOB_LIMIT);
    ITMLST[182,0,16,0] = QUI$_JOB_LIMIT;
    ITMLST[184,0,32,0] = JOB_LIMIT;
    ITMLST[188,0,32,0] = 0;

    ITMLST[192,0,16,0] = %ALLOCATION(JOB_RESET_MODULES);
    ITMLST[194,0,16,0] = QUI$_JOB_RESET_MODULES;
    ITMLST[196,0,32,0] = JOB_RESET_MODULES;
    ITMLST[200,0,32,0] = JOB_RESET_MODULES_LENGTH;

    ITMLST[204,0,16,0] = %ALLOCATION(JOB_SIZE_MAXIMUM);
    ITMLST[206,0,16,0] = QUI$_JOB_SIZE_MAXIMUM;
    ITMLST[208,0,32,0] = JOB_SIZE_MAXIMUM;
    ITMLST[212,0,32,0] = 0;

    ITMLST[216,0,16,0] = %ALLOCATION(JOB_SIZE_MINIMUM);
    ITMLST[218,0,16,0] = QUI$_JOB_SIZE_MINIMUM;
    ITMLST[220,0,32,0] = JOB_SIZE_MINIMUM;
    ITMLST[224,0,32,0] = 0;

    ITMLST[228,0,16,0] = %ALLOCATION(LIBRARY_SPECIFICATION);
    ITMLST[230,0,16,0] = QUI$_LIBRARY_SPECIFICATION;
    ITMLST[232,0,32,0] = LIBRARY_SPECIFICATION;
    ITMLST[236,0,32,0] = LIBRARY_SPECIFICATION_LENGTH;

    ITMLST[240,0,16,0] = %ALLOCATION(OWNER_UIC);
    ITMLST[242,0,16,0] = QUI$_OWNER_UIC;
    ITMLST[244,0,32,0] = OWNER_UIC;
    ITMLST[248,0,32,0] = 0;

    ITMLST[252,0,16,0] = %ALLOCATION(PROTECTION);
    ITMLST[254,0,16,0] = QUI$_PROTECTION;
    ITMLST[256,0,32,0] = PROTECTION;
    ITMLST[260,0,32,0] = 0;

    ITMLST[264,0,16,0] = %ALLOCATION(WSDEFAULT);
    ITMLST[266,0,16,0] = QUI$_WSDEFAULT;
    ITMLST[268,0,32,0] = WSDEFAULT;
    ITMLST[272,0,32,0] = 0;

    ITMLST[276,0,16,0] = %ALLOCATION(WSEXTENT);
    ITMLST[278,0,16,0] = QUI$_WSEXTENT;
    ITMLST[280,0,32,0] = WSEXTENT;
    ITMLST[284,0,32,0] = 0;

    ITMLST[288,0,16,0] = %ALLOCATION(WSQUOTA);
    ITMLST[290,0,16,0] = QUI$_WSQUOTA;
    ITMLST[292,0,32,0] = WSQUOTA;
    ITMLST[296,0,32,0] = 0;

    ITMLST[300,0,32,0] = 0;
    END;


! Loop to get all queues.
!
WHILE TRUE DO
    BEGIN
    STATUS = $GETQUIW(
	FUNC=QUI$_DISPLAY_QUEUE,
	ITMLST=ITMLST,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB;


    IF TESTBITCS(QUEUE_PRINTED)
    THEN
	BEGIN
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL(.STATUS);
	    EXITLOOP;
	    END;
	END
    ELSE
	BEGIN
	IF NOT .STATUS THEN EXITLOOP;
	END;


    IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
    THEN
	IF .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	THEN
	    TYPE = UPLIT BYTE (%ASCIC 'Generic batch')
	ELSE
	    TYPE = UPLIT BYTE (%ASCIC 'Batch')
    ELSE
	IF .ASSIGNED_QUEUE_NAME_LENGTH NEQ 0
	THEN
	    TYPE = UPLIT BYTE (%ASCIC 'Logical')
	ELSE
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	    THEN
		IF .PROCESSOR_LENGTH NEQ 0
		THEN
		    TYPE = UPLIT BYTE (%ASCIC 'Generic server')
		ELSE IF .QUEUE_FLAGS[QUI$V_QUEUE_TERMINAL]
		THEN
		    TYPE = UPLIT BYTE (%ASCIC 'Generic terminal')
		ELSE
		    TYPE = UPLIT BYTE (%ASCIC 'Generic printer')
	    ELSE
		IF .QUEUE_STATUS[QUI$V_QUEUE_SERVER]
		THEN
		    TYPE = UPLIT BYTE (%ASCIC 'Server')
		ELSE IF .QUEUE_FLAGS[QUI$V_QUEUE_TERMINAL]
		THEN
		    IF .QUEUE_STATUS[QUI$V_QUEUE_REMOTE]
		    THEN
			TYPE = UPLIT BYTE (%ASCIC 'Remote terminal')
		    ELSE
			TYPE = UPLIT BYTE (%ASCIC 'Terminal')
		ELSE
		    TYPE = UPLIT BYTE (%ASCIC 'Printer');


    FLAGS[V_TRUNCATE] = TRUE;
    FAO_('!AC queue !AF', .TYPE, .QUEUE_NAME_LENGTH, QUEUE_NAME);


    IF .QUEUE_STATUS[QUI$V_QUEUE_ALIGNING]
	THEN FAO_(', aligning');
    IF .QUEUE_STATUS[QUI$V_QUEUE_OPERATOR_REQUEST]
	THEN FAO_(', operator service');
    IF .QUEUE_STATUS[QUI$V_QUEUE_PAUSED]
	THEN FAO_(', paused');
    IF .QUEUE_STATUS[QUI$V_QUEUE_PAUSING]
	THEN FAO_(', pausing');
    IF .QUEUE_STATUS[QUI$V_QUEUE_RESETTING]
	THEN FAO_(', resetting');
    IF NOT .QUEUE_STATUS[QUI$V_QUEUE_ALIGNING]
    AND .QUEUE_STATUS[QUI$V_QUEUE_RESUMING]
	THEN FAO_(', resuming');
    IF .QUEUE_STATUS[QUI$V_QUEUE_STALLED]
	THEN FAO_(', stalled');
    IF .QUEUE_STATUS[QUI$V_QUEUE_STARTING]
	THEN FAO_(', starting');
    IF .QUEUE_STATUS[QUI$V_QUEUE_STOPPED]
    THEN
	IF .QUEUE_STATUS[QUI$V_QUEUE_IDLE]
	    THEN FAO_(', stopped')
	    ELSE FAO_(', stop pending');
    IF .QUEUE_STATUS[QUI$V_QUEUE_STOPPING]
	THEN FAO_(', stopping');
    IF .QUEUE_STATUS[QUI$V_QUEUE_UNAVAILABLE]
	THEN FAO_(', device unavailable');


    IF .ASSIGNED_QUEUE_NAME_LENGTH NEQ 0
    THEN
	FAO_(', assigned to !AF',
	    .ASSIGNED_QUEUE_NAME_LENGTH, ASSIGNED_QUEUE_NAME);


    IF .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
    AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
    THEN
	BEGIN
	IF .SCSNODE_NAME_LENGTH NEQ 0 OR .DEVICE_NAME_LENGTH NEQ 0
	THEN
	    FAO_(', on ');


	IF .SCSNODE_NAME_LENGTH NEQ 0
	THEN
	    FAO_('!AF::', .SCSNODE_NAME_LENGTH, SCSNODE_NAME);


	IF .DEVICE_NAME_LENGTH NEQ 0
	THEN
	    FAO_('!AF', .DEVICE_NAME_LENGTH, DEVICE_NAME);
	END;
    FLAGS[V_TRUNCATE] = FALSE;


    IF .FLAGS[V_FULL]
    THEN
	BEGIN
	EOL_();
	FLAGS[B_PENDING_SPACES] = 4;
	FLAGS[B_LEFT_MARGIN] = 4;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    BEGIN
	    FAO_('/BASE_PRIORITY=!UL', .BASE_PRIORITY);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    BEGIN
	    IF .JOB_SIZE_MINIMUM NEQ 0
	    THEN
		IF .JOB_SIZE_MAXIMUM NEQ 0
		THEN
		    BEGIN
		    FAO_('/BLOCK_LIMIT=(!UL,!UL)',
			.JOB_SIZE_MINIMUM, .JOB_SIZE_MAXIMUM);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END
		ELSE
		    BEGIN
		    FAO_('/BLOCK_LIMIT=(!UL,"")',
			.JOB_SIZE_MINIMUM);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END
	    ELSE
		IF .JOB_SIZE_MAXIMUM NEQ 0
		THEN
		    BEGIN
		    FAO_('/BLOCK_LIMIT=!UL',
			.JOB_SIZE_MAXIMUM);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    FORMAT_CHARACTERISTICS(CHARACTERISTICS);


	IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	THEN
	    BEGIN
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_CPU_DEFAULT]
	    THEN
		FORMAT_CPU_TIME(
		    UPLIT BYTE (%ASCIC 'CPUDEFAULT'),
		    .CPU_DEFAULT);


	    IF .QUEUE_FLAGS[QUI$V_QUEUE_CPU_LIMIT]
	    THEN
		FORMAT_CPU_TIME(
		    UPLIT BYTE (%ASCIC 'CPUMAXIMUM'),
		    .CPU_LIMIT);
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    FORMAT_DEFAULT(.QUEUE_FLAGS);


	IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	THEN
	    BEGIN
	    IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_SWAP]
	    THEN
		BEGIN
		FAO_('/DISABLE_SWAPPING');
		FLAGS[B_PENDING_SPACES] = 1;
		END;
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    BEGIN
	    IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC_SELECTION]
	    THEN
		BEGIN
		FAO_('/NOENABLE_GENERIC');
		FLAGS[B_PENDING_SPACES] = 1;
		END;
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    BEGIN
	    FAO_('/FORM=!AF', .FORM_NAME_LENGTH, FORM_NAME);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .GENERIC_TARGET_LENGTH NEQ 0
	THEN
	    BEGIN
	    LOCAL
		ITEM_LENGTH,
		ITEM_ADDRESS,
		REMAINING_LENGTH,
		REMAINING_ADDRESS;

	    FAO_('/GENERIC=(');
	    FLAGS[B_PENDING_SPACES] = 0;

	    ITEM_ADDRESS = REMAINING_ADDRESS = GENERIC_TARGET;
	    REMAINING_LENGTH = .GENERIC_TARGET_LENGTH;

	    WHILE ((REMAINING_ADDRESS = CH$FIND_CH(.REMAINING_LENGTH, 
			.REMAINING_ADDRESS, %C',')) NEQ 0)
	    DO BEGIN
		ITEM_LENGTH = .REMAINING_ADDRESS - .ITEM_ADDRESS;
		FAO_('!AF,', .ITEM_LENGTH, .ITEM_ADDRESS);
		REMAINING_LENGTH = .REMAINING_LENGTH - .ITEM_LENGTH - 1;
		ITEM_ADDRESS = REMAINING_ADDRESS = .REMAINING_ADDRESS + 1;
		END;

	    FAO_('!AF', .REMAINING_LENGTH, .ITEM_ADDRESS);
	    FAO_(')');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	THEN
	    BEGIN
	    FAO_('/JOB_LIMIT=!UL', .JOB_LIMIT);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	AND .LIBRARY_SPECIFICATION_LENGTH NEQ 0
	THEN
	    BEGIN
	    FAO_('/LIBRARY=!AF',
		.LIBRARY_SPECIFICATION_LENGTH, LIBRARY_SPECIFICATION);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF .QUEUE_STATUS[QUI$V_QUEUE_LOWERCASE]
	THEN
	    BEGIN
	    FAO_('Lowercase');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	FAO_('/OWNER=!%I', .OWNER_UIC);
	FLAGS[B_PENDING_SPACES] = 1;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND .PROCESSOR_LENGTH NEQ 0
	THEN
	    BEGIN
	    FAO_('/PROCESSOR=!AF',
		.PROCESSOR_LENGTH, PROCESSOR);
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	FORMAT_PROTECTION(.PROTECTION);


	IF .QUEUE_FLAGS[QUI$V_QUEUE_RETAIN_ALL]
	THEN
	    BEGIN
	    FAO_('/RETAIN');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF .QUEUE_FLAGS[QUI$V_QUEUE_RETAIN_ERROR]
	THEN
	    BEGIN
	    FAO_('/RETAIN=ERROR');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	FORMAT_SCHEDULE(.QUEUE_FLAGS);


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	AND .ASSIGNED_QUEUE_NAME_LENGTH EQL 0
	THEN
	    FORMAT_SEPARATE(.QUEUE_FLAGS,
		.JOB_RESET_MODULES_LENGTH, JOB_RESET_MODULES);


	IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	AND NOT .QUEUE_FLAGS[QUI$V_QUEUE_GENERIC]
	THEN
	    BEGIN
	    IF .QUEUE_FLAGS[QUI$V_QUEUE_WSDEFAULT]
	    THEN
		FORMAT_WORKING_SET(
		    UPLIT BYTE (%ASCIC 'WSDEFAULT'),
		    .WSDEFAULT);


	    IF .QUEUE_FLAGS[QUI$V_QUEUE_WSEXTENT]
	    THEN
		FORMAT_WORKING_SET(
		    UPLIT BYTE (%ASCIC 'WSEXTENT'),
		    .WSEXTENT);


	    IF .QUEUE_FLAGS[QUI$V_QUEUE_WSQUOTA]
	    THEN
		FORMAT_WORKING_SET(
		    UPLIT BYTE (%ASCIC 'WSQUOTA'),
		    .WSQUOTA);
	    END;


	FLAGS[B_PENDING_SPACES] = 0;
	FLAGS[B_LEFT_MARGIN] = 0;
	END;


    EOL_();
    FLAGS[B_PENDING_LINES] = 1;
    SHOW_JOBS(.QUEUE_FLAGS, .QUEUE_STATUS);
    FLAGS[B_PENDING_LINES] = 1;
    END;
END;

ROUTINE SHOW_JOBS(QUEUE_FLAGS,QUEUE_STATUS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine displays the jobs in a queue.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QUEUE_FLAGS:			BBLOCK,
	QUEUE_STATUS:			BBLOCK;
LOCAL
	ITMLST:				BBLOCK[448],
	AFTER_TIME:			VOLATILE VECTOR[2],
	CHARACTERISTICS:		VOLATILE BITVECTOR[128],
	CHECKPOINT_DATA:		VOLATILE VECTOR[255,BYTE],
	CHECKPOINT_DATA_LENGTH:		VOLATILE WORD,
	CLI:				VOLATILE VECTOR[39,BYTE],
	CLI_LENGTH:			VOLATILE WORD,
	COMPLETED_BLOCKS:		VOLATILE,
	CONDITION_VECTOR:		VOLATILE VECTOR[3],
	CPU_LIMIT:			VOLATILE,
	ENTRY_NUMBER:			VOLATILE,
	FORM_NAME:			VOLATILE VECTOR[31,BYTE],
	FORM_NAME_LENGTH:		VOLATILE WORD,
	INTERVENING_BLOCKS:		VOLATILE,
	INTERVENING_JOBS:		VOLATILE,
	JOB_COPIES:			VOLATILE,
	JOB_COPIES_DONE:		VOLATILE,
	JOB_FLAGS:			VOLATILE BBLOCK[4],
	JOB_NAME:			VOLATILE VECTOR[39,BYTE],
	JOB_NAME_LENGTH:		VOLATILE WORD,
	JOB_SIZE:			VOLATILE,
	JOB_STATUS:			VOLATILE BBLOCK[4],
	LOG_QUEUE:			VOLATILE VECTOR[39,BYTE],
	LOG_QUEUE_LENGTH:		VOLATILE WORD,
	LOG_SPECIFICATION:		VOLATILE VECTOR[255,BYTE],
	LOG_SPECIFICATION_LENGTH:	VOLATILE WORD,
	NOTE:				VOLATILE VECTOR[255,BYTE],
	NOTE_LENGTH:			VOLATILE WORD,
	OPERATOR_REQUEST:		VOLATILE VECTOR[255,BYTE],
	OPERATOR_REQUEST_LENGTH:	VOLATILE WORD,
	PARAMETER_1:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_1_LENGTH:		VOLATILE WORD,	
	PARAMETER_2:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_2_LENGTH:		VOLATILE WORD,	
	PARAMETER_3:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_3_LENGTH:		VOLATILE WORD,	
	PARAMETER_4:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_4_LENGTH:		VOLATILE WORD,	
	PARAMETER_5:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_5_LENGTH:		VOLATILE WORD,	
	PARAMETER_6:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_6_LENGTH:		VOLATILE WORD,	
	PARAMETER_7:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_7_LENGTH:		VOLATILE WORD,	
	PARAMETER_8:			VOLATILE VECTOR[255,BYTE],
	PARAMETER_8_LENGTH:		VOLATILE WORD,	
	PRIORITY:			VOLATILE,
	REFUSAL_REASON:			VOLATILE VECTOR[255,BYTE],
	REFUSAL_REASON_LENGTH:		VOLATILE WORD,
	SEARCH_FLAGS:			VOLATILE BBLOCK[4],
	SUBMISSION_TIME:		VOLATILE VECTOR[2],
	USERNAME:			VOLATILE VECTOR[12,BYTE],
	USERNAME_LENGTH:		VOLATILE WORD,
	WSDEFAULT:			VOLATILE,
	WSEXTENT:			VOLATILE,
	WSQUOTA:			VOLATILE,
	STATUS,
	IOSB:				VECTOR[2],
	JOB_PRINTED;


SEARCH_FLAGS = QUI$M_SEARCH_WILDCARD;
IF CLI$PRESENT($DESCRIPTOR('ALL'))
    THEN SEARCH_FLAGS[QUI$V_SEARCH_ALL_JOBS] = TRUE;
JOB_PRINTED = FALSE;


! Initialize the item list.
!
ITMLST[0,0,16,0] = %ALLOCATION(SEARCH_FLAGS);
ITMLST[2,0,16,0] = QUI$_SEARCH_FLAGS;
ITMLST[4,0,32,0] = SEARCH_FLAGS;
ITMLST[8,0,32,0] = 0;

ITMLST[12,0,16,0] = %ALLOCATION(AFTER_TIME);
ITMLST[14,0,16,0] = QUI$_AFTER_TIME;
ITMLST[16,0,32,0] = AFTER_TIME;
ITMLST[20,0,32,0] = 0;

ITMLST[24,0,16,0] = %ALLOCATION(COMPLETED_BLOCKS);
ITMLST[26,0,16,0] = QUI$_COMPLETED_BLOCKS;
ITMLST[28,0,32,0] = COMPLETED_BLOCKS;
ITMLST[32,0,32,0] = 0;

ITMLST[36,0,16,0] = %ALLOCATION(CONDITION_VECTOR);
ITMLST[38,0,16,0] = QUI$_CONDITION_VECTOR;
ITMLST[40,0,32,0] = CONDITION_VECTOR;
ITMLST[44,0,32,0] = 0;

ITMLST[48,0,16,0] = %ALLOCATION(ENTRY_NUMBER);
ITMLST[50,0,16,0] = QUI$_ENTRY_NUMBER;
ITMLST[52,0,32,0] = ENTRY_NUMBER;
ITMLST[56,0,32,0] = 0;

ITMLST[60,0,16,0] = %ALLOCATION(INTERVENING_BLOCKS);
ITMLST[62,0,16,0] = QUI$_INTERVENING_BLOCKS;
ITMLST[64,0,32,0] = INTERVENING_BLOCKS;
ITMLST[68,0,32,0] = 0;

ITMLST[72,0,16,0] = %ALLOCATION(INTERVENING_JOBS);
ITMLST[74,0,16,0] = QUI$_INTERVENING_JOBS;
ITMLST[76,0,32,0] = INTERVENING_JOBS;
ITMLST[80,0,32,0] = 0;

ITMLST[84,0,16,0] = %ALLOCATION(JOB_COPIES);
ITMLST[86,0,16,0] = QUI$_JOB_COPIES;
ITMLST[88,0,32,0] = JOB_COPIES;
ITMLST[92,0,32,0] = 0;

ITMLST[96,0,16,0] = %ALLOCATION(JOB_COPIES_DONE);
ITMLST[98,0,16,0] = QUI$_JOB_COPIES_DONE;
ITMLST[100,0,32,0] = JOB_COPIES_DONE;
ITMLST[104,0,32,0] = 0;

ITMLST[108,0,16,0] = %ALLOCATION(JOB_FLAGS);
ITMLST[110,0,16,0] = QUI$_JOB_FLAGS;
ITMLST[112,0,32,0] = JOB_FLAGS;
ITMLST[116,0,32,0] = 0;

ITMLST[120,0,16,0] = %ALLOCATION(JOB_NAME);
ITMLST[122,0,16,0] = QUI$_JOB_NAME;
ITMLST[124,0,32,0] = JOB_NAME;
ITMLST[128,0,32,0] = JOB_NAME_LENGTH;

ITMLST[132,0,16,0] = %ALLOCATION(JOB_SIZE);
ITMLST[134,0,16,0] = QUI$_JOB_SIZE;
ITMLST[136,0,32,0] = JOB_SIZE;
ITMLST[140,0,32,0] = 0;

ITMLST[144,0,16,0] = %ALLOCATION(JOB_STATUS);
ITMLST[146,0,16,0] = QUI$_JOB_STATUS;
ITMLST[148,0,32,0] = JOB_STATUS;
ITMLST[152,0,32,0] = 0;

ITMLST[156,0,16,0] = %ALLOCATION(REFUSAL_REASON);
ITMLST[158,0,16,0] = QUI$_REFUSAL_REASON;
ITMLST[160,0,32,0] = REFUSAL_REASON;
ITMLST[164,0,32,0] = REFUSAL_REASON_LENGTH;

ITMLST[168,0,16,0] = %ALLOCATION(USERNAME);
ITMLST[170,0,16,0] = QUI$_USERNAME;
ITMLST[172,0,32,0] = USERNAME;
ITMLST[176,0,32,0] = USERNAME_LENGTH;

ITMLST[180,0,32,0] = 0;


IF .FLAGS[V_FULL]
THEN
    BEGIN
    ITMLST[180,0,16,0] = %ALLOCATION(CHARACTERISTICS);
    ITMLST[182,0,16,0] = QUI$_CHARACTERISTICS;
    ITMLST[184,0,32,0] = CHARACTERISTICS;
    ITMLST[188,0,32,0] = 0;

    ITMLST[192,0,16,0] = %ALLOCATION(CHECKPOINT_DATA);
    ITMLST[194,0,16,0] = QUI$_CHECKPOINT_DATA;
    ITMLST[196,0,32,0] = CHECKPOINT_DATA;
    ITMLST[200,0,32,0] = CHECKPOINT_DATA_LENGTH;

    ITMLST[204,0,16,0] = %ALLOCATION(CLI);
    ITMLST[206,0,16,0] = QUI$_CLI;
    ITMLST[208,0,32,0] = CLI;
    ITMLST[212,0,32,0] = CLI_LENGTH;

    ITMLST[216,0,16,0] = %ALLOCATION(CPU_LIMIT);
    ITMLST[218,0,16,0] = QUI$_CPU_LIMIT;
    ITMLST[220,0,32,0] = CPU_LIMIT;
    ITMLST[224,0,32,0] = 0;

    ITMLST[228,0,16,0] = %ALLOCATION(FORM_NAME);
    ITMLST[230,0,16,0] = QUI$_FORM_NAME;
    ITMLST[232,0,32,0] = FORM_NAME;
    ITMLST[236,0,32,0] = FORM_NAME_LENGTH;

    ITMLST[240,0,16,0] = %ALLOCATION(LOG_QUEUE);
    ITMLST[242,0,16,0] = QUI$_LOG_QUEUE;
    ITMLST[244,0,32,0] = LOG_QUEUE;
    ITMLST[248,0,32,0] = LOG_QUEUE_LENGTH;

    ITMLST[252,0,16,0] = %ALLOCATION(LOG_SPECIFICATION);
    ITMLST[254,0,16,0] = QUI$_LOG_SPECIFICATION;
    ITMLST[256,0,32,0] = LOG_SPECIFICATION;
    ITMLST[260,0,32,0] = LOG_SPECIFICATION_LENGTH;

    ITMLST[264,0,16,0] = %ALLOCATION(NOTE);
    ITMLST[266,0,16,0] = QUI$_NOTE;
    ITMLST[268,0,32,0] = NOTE;
    ITMLST[272,0,32,0] = NOTE_LENGTH;

    ITMLST[276,0,16,0] = %ALLOCATION(OPERATOR_REQUEST);
    ITMLST[278,0,16,0] = QUI$_OPERATOR_REQUEST;
    ITMLST[280,0,32,0] = OPERATOR_REQUEST;
    ITMLST[284,0,32,0] = OPERATOR_REQUEST_LENGTH;

    ITMLST[288,0,16,0] = %ALLOCATION(PARAMETER_1);
    ITMLST[290,0,16,0] = QUI$_PARAMETER_1;
    ITMLST[292,0,32,0] = PARAMETER_1;
    ITMLST[296,0,32,0] = PARAMETER_1_LENGTH;

    ITMLST[300,0,16,0] = %ALLOCATION(PARAMETER_2);
    ITMLST[302,0,16,0] = QUI$_PARAMETER_2;
    ITMLST[304,0,32,0] = PARAMETER_2;
    ITMLST[308,0,32,0] = PARAMETER_2_LENGTH;

    ITMLST[312,0,16,0] = %ALLOCATION(PARAMETER_3);
    ITMLST[314,0,16,0] = QUI$_PARAMETER_3;
    ITMLST[316,0,32,0] = PARAMETER_3;
    ITMLST[320,0,32,0] = PARAMETER_3_LENGTH;

    ITMLST[324,0,16,0] = %ALLOCATION(PARAMETER_4);
    ITMLST[326,0,16,0] = QUI$_PARAMETER_4;
    ITMLST[328,0,32,0] = PARAMETER_4;
    ITMLST[332,0,32,0] = PARAMETER_4_LENGTH;

    ITMLST[336,0,16,0] = %ALLOCATION(PARAMETER_5);
    ITMLST[338,0,16,0] = QUI$_PARAMETER_5;
    ITMLST[340,0,32,0] = PARAMETER_5;
    ITMLST[344,0,32,0] = PARAMETER_5_LENGTH;

    ITMLST[348,0,16,0] = %ALLOCATION(PARAMETER_6);
    ITMLST[350,0,16,0] = QUI$_PARAMETER_6;
    ITMLST[352,0,32,0] = PARAMETER_6;
    ITMLST[356,0,32,0] = PARAMETER_6_LENGTH;

    ITMLST[360,0,16,0] = %ALLOCATION(PARAMETER_7);
    ITMLST[362,0,16,0] = QUI$_PARAMETER_7;
    ITMLST[364,0,32,0] = PARAMETER_7;
    ITMLST[368,0,32,0] = PARAMETER_7_LENGTH;

    ITMLST[372,0,16,0] = %ALLOCATION(PARAMETER_8);
    ITMLST[374,0,16,0] = QUI$_PARAMETER_8;
    ITMLST[376,0,32,0] = PARAMETER_8;
    ITMLST[380,0,32,0] = PARAMETER_8_LENGTH;

    ITMLST[384,0,16,0] = %ALLOCATION(PRIORITY);
    ITMLST[386,0,16,0] = QUI$_PRIORITY;
    ITMLST[388,0,32,0] = PRIORITY;
    ITMLST[392,0,32,0] = 0;

    ITMLST[396,0,16,0] = %ALLOCATION(SUBMISSION_TIME);
    ITMLST[398,0,16,0] = QUI$_SUBMISSION_TIME;
    ITMLST[400,0,32,0] = SUBMISSION_TIME;
    ITMLST[404,0,32,0] = 0;

    ITMLST[408,0,16,0] = %ALLOCATION(WSDEFAULT);
    ITMLST[410,0,16,0] = QUI$_WSDEFAULT;
    ITMLST[412,0,32,0] = WSDEFAULT;
    ITMLST[416,0,32,0] = 0;

    ITMLST[420,0,16,0] = %ALLOCATION(WSEXTENT);
    ITMLST[422,0,16,0] = QUI$_WSEXTENT;
    ITMLST[424,0,32,0] = WSEXTENT;
    ITMLST[428,0,32,0] = 0;

    ITMLST[432,0,16,0] = %ALLOCATION(WSQUOTA);
    ITMLST[434,0,16,0] = QUI$_WSQUOTA;
    ITMLST[436,0,32,0] = WSQUOTA;
    ITMLST[440,0,32,0] = 0;

    ITMLST[444,0,32,0] = 0;
    END;


! Loop to get all jobs.
!
WHILE TRUE DO
    BEGIN
    STATUS = $GETQUIW(
	FUNC=QUI$_DISPLAY_JOB,
	ITMLST=ITMLST,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB;
    IF NOT .STATUS THEN EXITLOOP;


    FLAGS[V_TRUNCATE] = TRUE;
    IF TESTBITCS(JOB_PRINTED)
    THEN
	BEGIN
	FAO_('  Jobname         Username     Entry');
	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH] THEN FAO_('  Blocks');
	FAOL_('  Status');

	FAO_('  -------         --------     -----');
	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH] THEN FAO_('  ------');
	FAOL_('  ------');
	END;


    IF .INTERVENING_JOBS NEQ 0
    THEN
	BEGIN
	FAO_('    (!UL intervening job!%S', .INTERVENING_JOBS);
	IF .INTERVENING_BLOCKS NEQ 0
	    THEN FAO_(' containing !UL block!%S', .INTERVENING_BLOCKS);
	FAOL_(')');
	END;


    IF NOT .JOB_STATUS[QUI$V_JOB_INACCESSIBLE]
    THEN
	BEGIN
	IF .JOB_NAME_LENGTH GTRU 15
	THEN
	    BEGIN
	    FAOL_('  !AF', .JOB_NAME_LENGTH, JOB_NAME);
	    FAO_('!17* ');
	    END
	ELSE
	    BEGIN
	    FAO_('  !15AF', .JOB_NAME_LENGTH, JOB_NAME);
	    END;

	FAO_(' !12AF', .USERNAME_LENGTH, USERNAME);
	END
    ELSE
	BEGIN
	FAO_('  no privilege!16* ')
	END;
    FAO_(' !5UL', .ENTRY_NUMBER);
    IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	THEN FAO_('  !6UL', .JOB_SIZE);


    IF .JOB_STATUS[QUI$V_JOB_ABORTING]
    THEN
	FAO_('  Aborting')


    ELSE IF .JOB_STATUS[QUI$V_JOB_EXECUTING]
    THEN
	BEGIN
	IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	THEN
	    FAO_('  Executing')
	ELSE IF .QUEUE_STATUS[QUI$V_QUEUE_SERVER]
	THEN
	    FAO_('  Processing')
	ELSE
	    BEGIN
	    FAO_('  Printing');
	    IF .JOB_COPIES GTRU 1
		THEN FAO_(' job copy !UL', .JOB_COPIES_DONE + 1);
	    END;
	END


    ELSE IF .JOB_STATUS[QUI$V_JOB_HOLDING]
    THEN
	FAO_('  Holding')


    ELSE IF .JOB_STATUS[QUI$V_JOB_REFUSED]
    THEN
	BEGIN
	FAO_('  Waiting');
	IF .REFUSAL_REASON_LENGTH NEQ 0
	THEN
	    BEGIN
	    IF .COMPLETED_BLOCKS NEQ 0
	    THEN
		BEGIN
		FAO_(' at block !UL', .COMPLETED_BLOCKS);
		COMPLETED_BLOCKS = 0;
		END;
	    EOL();
	    FAO_('    !AF', .REFUSAL_REASON_LENGTH, REFUSAL_REASON);
	    END;
	END


    ELSE IF .JOB_STATUS[QUI$V_JOB_RETAINED]
    THEN
	BEGIN
	FAO_('  Completed');
	IF .CONDITION_VECTOR[0] NEQ 0
	AND NOT .CONDITION_VECTOR[0]
	THEN
	    BEGIN
	    INCR I FROM 0 TO 2 DO
		BEGIN
		IF .CONDITION_VECTOR[.I] NEQ 0
		THEN
		    BEGIN
		    LOCAL
			MESSAGE_DESC:	VECTOR[2],
			MESSAGE:	VECTOR[132,BYTE];
			
		    MESSAGE_DESC[0] = %ALLOCATION(MESSAGE);
		    MESSAGE_DESC[1] = MESSAGE;
		    $GETMSG(
			MSGID=.CONDITION_VECTOR[.I],
			MSGLEN=MESSAGE_DESC,
			BUFADR=MESSAGE_DESC,
			FLAGS=%B'1111');
		    IF .I NEQ 0 THEN MESSAGE[0] = %C'-';
		    IF .COMPLETED_BLOCKS NEQ 0
		    THEN
			BEGIN
			FAO_(' at block !UL', .COMPLETED_BLOCKS);
			COMPLETED_BLOCKS = 0;
			END;
		    EOL_();
		    FAO_('    !AF',
			.MESSAGE_DESC[0], .MESSAGE_DESC[1]);
		    END;
		END;
	    END;
	END


    ELSE IF .JOB_STATUS[QUI$V_JOB_STARTING]
    THEN
	FAO_('  Starting')


    ELSE IF .JOB_STATUS[QUI$V_JOB_TIMED]
    THEN
	FAO_('  Holding until !17%D', AFTER_TIME)


    ELSE
	FAO_('  Pending');


    IF .COMPLETED_BLOCKS NEQ 0
    THEN
	FAO_(' at block !UL', .COMPLETED_BLOCKS);


    EOL_();
    FLAGS[V_TRUNCATE] = FALSE;


    IF NOT .JOB_STATUS[QUI$V_JOB_INACCESSIBLE]
    THEN
	BEGIN
	IF .FLAGS[V_FULL]
	THEN
	    BEGIN
	    FLAGS[B_LEFT_MARGIN] = 4;
	    FLAGS[B_PENDING_SPACES] = 4;


	    FAO_('Submitted !17%D', SUBMISSION_TIME);
	    FLAGS[B_PENDING_SPACES] = 1;


	    IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	    THEN
		BEGIN
		IF .JOB_FLAGS[QUI$V_JOB_FILE_BURST_EXP]
		THEN
		    BEGIN
		    IF .JOB_FLAGS[QUI$V_JOB_FILE_BURST]
			THEN FAO_('/BURST')
		    ELSE IF .JOB_FLAGS[QUI$V_JOB_FILE_BURST_ONE]
			THEN FAO_('/BURST=ONE')
			ELSE FAO_('/NOBURST');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;
		END;


	    FORMAT_CHARACTERISTICS(CHARACTERISTICS);


	    IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	    THEN
		BEGIN
		IF .CLI_LENGTH NEQ 0
		THEN
		    BEGIN
		    FAO_('/CLI=!AF', .CLI_LENGTH, CLI);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .JOB_FLAGS[QUI$V_JOB_CPU_LIMIT]
		THEN
		    FORMAT_CPU_TIME(
			UPLIT BYTE (%ASCIC 'CPU'),
			.CPU_LIMIT);


		IF NOT .JOB_FLAGS[QUI$V_JOB_LOG_DELETE]
		THEN
		    BEGIN
		    FAO_('/KEEP');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .JOB_FLAGS[QUI$V_JOB_LOG_NULL]
		THEN
		    BEGIN
		    FAO_('/NOLOG');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .LOG_SPECIFICATION_LENGTH NEQ 0
		THEN
		    BEGIN
		    FAO_('/LOG=!AF',
			.LOG_SPECIFICATION_LENGTH, LOG_SPECIFICATION);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;
		END
	    ELSE
		BEGIN
		IF .JOB_FLAGS[QUI$V_JOB_FILE_FLAG_EXP]
		THEN
		    BEGIN
		    IF .JOB_FLAGS[QUI$V_JOB_FILE_FLAG]
			THEN FAO_('/FLAG')
		    ELSE IF .JOB_FLAGS[QUI$V_JOB_FILE_FLAG_ONE]
			THEN FAO_('/FLAG=ONE')
			ELSE FAO_('/NOFLAG');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .JOB_FLAGS[QUI$V_JOB_FILE_PAGINATE_EXP]
		THEN
		    BEGIN
		    IF .JOB_FLAGS[QUI$V_JOB_FILE_PAGINATE]
			THEN FAO_('/FEED')
			ELSE FAO_('/NOFEED');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		FAO_('/FORM=!AF', .FORM_NAME_LENGTH, FORM_NAME);
		FLAGS[B_PENDING_SPACES] = 1;


		IF .JOB_COPIES GTRU 1
		THEN
		    BEGIN
		    FAO_('/JOB_COUNT=!UL', .JOB_COPIES);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .JOB_FLAGS[QUI$V_JOB_LOWERCASE]
		THEN
		    BEGIN
		    FAO_('/LOWER');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .NOTE_LENGTH NEQ 0
		THEN
		    BEGIN
		    FAO_('/NOTE="!AF"', .NOTE_LENGTH, NOTE);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;
		END;


	    IF .JOB_FLAGS[QUI$V_JOB_NOTIFY]
	    THEN
		BEGIN
		FAO_('/NOTIFY');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	    THEN
		BEGIN
		IF .OPERATOR_REQUEST_LENGTH NEQ 0
		THEN
		    BEGIN
		    FAO_('/OPERATOR="!AF"',
			.OPERATOR_REQUEST_LENGTH, OPERATOR_REQUEST);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;
		END;


	    FORMAT_PARAMETERS(
		.PARAMETER_1_LENGTH, PARAMETER_1,
		.PARAMETER_2_LENGTH, PARAMETER_2,
		.PARAMETER_3_LENGTH, PARAMETER_3,
		.PARAMETER_4_LENGTH, PARAMETER_4,
		.PARAMETER_5_LENGTH, PARAMETER_5,
		.PARAMETER_6_LENGTH, PARAMETER_6,
		.PARAMETER_7_LENGTH, PARAMETER_7,
		.PARAMETER_8_LENGTH, PARAMETER_8);


	    IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	    THEN
		BEGIN
		IF NOT .JOB_FLAGS[QUI$V_JOB_LOG_SPOOL]
		THEN
		    BEGIN
		    FAO_('/NOPRINT');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .LOG_QUEUE_LENGTH NEQ 0
		THEN
		    BEGIN
		    FAO_('/PRINT=!AF', .LOG_QUEUE_LENGTH, LOG_QUEUE);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;		    
		END;


	    FAO_('/PRIO=!UL', .PRIORITY);
	    FLAGS[B_PENDING_SPACES] = 1;


	    IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	    THEN
		BEGIN
		IF .JOB_FLAGS[QUI$V_JOB_RESTART]
		THEN
		    BEGIN
		    FAO_('/RESTART');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .CHECKPOINT_DATA_LENGTH NEQ 0
		THEN
		    BEGIN
		    FAO_('RESTART_VALUE="!AF"',
			.CHECKPOINT_DATA_LENGTH, CHECKPOINT_DATA);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .JOB_FLAGS[QUI$V_JOB_WSDEFAULT]
		THEN
		    FORMAT_WORKING_SET(
			UPLIT BYTE (%ASCIC 'WSDEFAULT'),
			.WSDEFAULT);


		IF .JOB_FLAGS[QUI$V_JOB_WSEXTENT]
		THEN
		    FORMAT_WORKING_SET(
			UPLIT BYTE (%ASCIC 'WSEXTENT'),
			.WSEXTENT);


		IF .JOB_FLAGS[QUI$V_JOB_WSQUOTA]
		THEN
		    FORMAT_WORKING_SET(
			UPLIT BYTE (%ASCIC 'WSQUOTA'),
			.WSQUOTA);
		END
	    ELSE
		BEGIN
		IF NOT .JOB_FLAGS[QUI$V_JOB_RESTART]
		THEN
		    BEGIN
		    FAO_('/NORESTART');
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


		IF .JOB_FLAGS[QUI$V_JOB_FILE_TRAILER_EXP]
		THEN
		    BEGIN
		    IF .JOB_FLAGS[QUI$V_JOB_FILE_TRAILER]
			THEN FAO_('/TRAILER')
		    ELSE IF .JOB_FLAGS[QUI$V_JOB_FILE_TRAILER_ONE]
			THEN FAO_('/TRAILER=ONE')
			ELSE FAO_('/NOTRAILER');
		    END;
		END;


	    FLAGS[B_PENDING_SPACES] = 0;
	    FLAGS[B_LEFT_MARGIN] = 0;
	    CEOL_();
	    END;


	IF .FLAGS[V_FULL] OR .FLAGS[V_FILES]
	THEN
	    SHOW_FILES(.QUEUE_FLAGS, .QUEUE_STATUS);
	END;


    IF .FLAGS[V_FULL] THEN FLAGS[B_PENDING_LINES] = 1;
    END;
END;

ROUTINE SHOW_FILES(QUEUE_FLAGS,QUEUE_STATUS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine displays the files contained in a job.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QUEUE_FLAGS:			BBLOCK,
	QUEUE_STATUS:			BBLOCK;
LOCAL
	ITMLST:				BBLOCK[112],
	FILE_COPIES:			VOLATILE,
	FILE_COPIES_DONE:		VOLATILE,
	FILE_FLAGS:			VOLATILE BBLOCK[4],
	FILE_SETUP_MODULES:		VOLATILE VECTOR[255,BYTE],
	FILE_SETUP_MODULES_LENGTH:	VOLATILE WORD,
	FILE_SPECIFICATION:		VOLATILE VECTOR[255,BYTE],
	FILE_SPECIFICATION_LENGTH:	VOLATILE WORD,
	FILE_STATUS:			VOLATILE BBLOCK[4],
	FIRST_PAGE:			VOLATILE,
	LAST_PAGE:			VOLATILE,
	STATUS,
	IOSB:				VECTOR[2];


! Initialize the item list.
!
ITMLST[0,0,16,0] = 4;
ITMLST[2,0,16,0] = QUI$_SEARCH_FLAGS;
ITMLST[4,0,32,0] = UPLIT(QUI$M_SEARCH_WILDCARD);
ITMLST[8,0,32,0] = 0;

ITMLST[12,0,16,0] = %ALLOCATION(FILE_COPIES);
ITMLST[14,0,16,0] = QUI$_FILE_COPIES;
ITMLST[16,0,32,0] = FILE_COPIES;
ITMLST[20,0,32,0] = 0;

ITMLST[24,0,16,0] = %ALLOCATION(FILE_COPIES_DONE);
ITMLST[26,0,16,0] = QUI$_FILE_COPIES_DONE;
ITMLST[28,0,32,0] = FILE_COPIES_DONE;
ITMLST[32,0,32,0] = 0;

ITMLST[36,0,16,0] = %ALLOCATION(FILE_SPECIFICATION);
ITMLST[38,0,16,0] = QUI$_FILE_SPECIFICATION;
ITMLST[40,0,32,0] = FILE_SPECIFICATION;
ITMLST[44,0,32,0] = FILE_SPECIFICATION_LENGTH;

ITMLST[48,0,16,0] = %ALLOCATION(FILE_STATUS);
ITMLST[50,0,16,0] = QUI$_FILE_STATUS;
ITMLST[52,0,32,0] = FILE_STATUS;
ITMLST[56,0,32,0] = 0;

ITMLST[60,0,32,0] = 0;

IF .FLAGS[V_FULL]
THEN
    BEGIN
    ITMLST[60,0,16,0] = %ALLOCATION(FILE_FLAGS);
    ITMLST[62,0,16,0] = QUI$_FILE_FLAGS;
    ITMLST[64,0,32,0] = FILE_FLAGS;
    ITMLST[68,0,32,0] = 0;

    ITMLST[72,0,16,0] = %ALLOCATION(FILE_SETUP_MODULES);
    ITMLST[74,0,16,0] = QUI$_FILE_SETUP_MODULES;
    ITMLST[76,0,32,0] = FILE_SETUP_MODULES;
    ITMLST[80,0,32,0] = FILE_SETUP_MODULES_LENGTH;

    ITMLST[84,0,16,0] = %ALLOCATION(FIRST_PAGE);
    ITMLST[86,0,16,0] = QUI$_FIRST_PAGE;
    ITMLST[88,0,32,0] = FIRST_PAGE;
    ITMLST[92,0,32,0] = 0;

    ITMLST[96,0,16,0] = %ALLOCATION(LAST_PAGE);
    ITMLST[98,0,16,0] = QUI$_LAST_PAGE;
    ITMLST[100,0,32,0] = LAST_PAGE;
    ITMLST[104,0,32,0] = 0;

    ITMLST[108,0,32,0] = 0;
    END;


! Loop to get all files.
!
WHILE TRUE DO
    BEGIN
    STATUS = $GETQUIW(
	FUNC=QUI$_DISPLAY_FILE,
	ITMLST=ITMLST,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB;
    IF NOT .STATUS THEN EXITLOOP;


    FLAGS[V_TRUNCATE] = TRUE;
    FAO_('!6* !AF',
	.FILE_SPECIFICATION_LENGTH, FILE_SPECIFICATION);


    FLAGS[B_PENDING_SPACES] = 1;
    FLAGS[B_LEFT_MARGIN] = 8;


    IF .FILE_STATUS[QUI$V_FILE_EXECUTING]
    THEN
	BEGIN
	IF .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	THEN
	    FAO_('(executing)')
	ELSE
	    BEGIN
	    IF .QUEUE_STATUS[QUI$V_QUEUE_SERVER]
		THEN FAO_('(processing')
		ELSE FAO_('(printing');
	    IF .FILE_COPIES GTRU 1
	    THEN FAO_(' copy !UL',
		.FILE_COPIES_DONE + 1);
	    FAO_(')');
	    END;
	FLAGS[B_PENDING_SPACES] = 1;
	END
    ELSE IF .FILE_STATUS[QUI$V_FILE_CHECKPOINTED]
    THEN
	BEGIN
	FAO_('(checkpointed)');
	FLAGS[B_PENDING_SPACES] = 1;
	END;


    FLAGS[V_TRUNCATE] = FALSE;


    IF .FLAGS[V_FULL]
    THEN
	BEGIN
	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	THEN
	    BEGIN
	    IF .FILE_FLAGS[QUI$V_FILE_BURST_EXP]
	    THEN
		BEGIN
		IF .FILE_FLAGS[QUI$V_FILE_BURST]
		    THEN FAO_('/BURST')
		    ELSE FAO_('/NOBURST');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FILE_COPIES GTRU 1
	    THEN
		BEGIN
		FAO_('/COPIES=!UL', .FILE_COPIES);
		FLAGS[B_PENDING_SPACES] = 1;
		END;
	    END;


	IF .FILE_FLAGS[QUI$V_FILE_DELETE]
	THEN
	    BEGIN
	    FAO_('/DELETE');
	    FLAGS[B_PENDING_SPACES] = 1;
	    END;


	IF NOT .QUEUE_FLAGS[QUI$V_QUEUE_BATCH]
	THEN
	    BEGIN
	    IF .FILE_FLAGS[QUI$V_FILE_PAGINATE_EXP]
	    THEN
		BEGIN
		IF .FILE_FLAGS[QUI$V_FILE_PAGINATE]
		    THEN FAO_('/FEED')
		    ELSE FAO_('/NOFEED');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FILE_FLAGS[QUI$V_FILE_FLAG_EXP]
	    THEN
		BEGIN
		IF .FILE_FLAGS[QUI$V_FILE_FLAG]
		    THEN FAO_('/FLAG')
		    ELSE FAO_('/NOFLAG');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FILE_FLAGS[QUI$V_FILE_PAGE_HEADER]
	    THEN
		BEGIN
		FAO_('/HEADER');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FIRST_PAGE NEQ 0
	    THEN
		IF .LAST_PAGE NEQ 0
		THEN
		    BEGIN
		    FAO_('/PAGES=(!UL,!UL)', .FIRST_PAGE, .LAST_PAGE);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END
		ELSE
		    BEGIN
		    FAO_('/PAGES=(!UL,"")', .FIRST_PAGE);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END
	    ELSE
		IF .LAST_PAGE NEQ 0
		THEN
		    BEGIN
		    FAO_('/PAGES=!UL', .LAST_PAGE);
		    FLAGS[B_PENDING_SPACES] = 1;
		    END;


	    IF .FILE_FLAGS[QUI$V_FILE_PASSALL]
	    THEN
		BEGIN
		FAO_('/PASSALL');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FILE_SETUP_MODULES_LENGTH NEQ 0
	    THEN
		BEGIN
		FAO_('/SETUP=(!AF)',
		    .FILE_SETUP_MODULES_LENGTH, FILE_SETUP_MODULES);
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FILE_FLAGS[QUI$V_FILE_DOUBLE_SPACE]
	    THEN
		BEGIN
		FAO_('/SPACE');
		FLAGS[B_PENDING_SPACES] = 1;
		END;


	    IF .FILE_FLAGS[QUI$V_FILE_TRAILER_EXP]
	    THEN
		BEGIN
		IF .FILE_FLAGS[QUI$V_FILE_TRAILER]
		    THEN FAO_('/TRAILER')
		    ELSE FAO_('/NOTRAILER');
		FLAGS[B_PENDING_SPACES] = 1;
		END;
	    END;
	END;


    FLAGS[B_LEFT_MARGIN] = 0;
    FLAGS[B_PENDING_SPACES] = 0;
    EOL_();
    END;
END;

ROUTINE FAO(CTRL,PARAM): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine interfaces to FAO to format information into the line.
!	Deferred blank lines and spaces are written before the requested
!	information, and unless truncation is in effect, if the requested
!	information does not fit on the current line, the information is placed
!	on the next line.
!
! INPUT PARAMETERS:
!	CTRL		- ASCIC control string
!	PARAM...	- Parameters required by the control string (if any)
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Information formatted into the line buffer.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	CTRL:			REF VECTOR[,BYTE];
LOCAL
	OUTLEN:			WORD,
	DESC:			VECTOR[2],
	STATUS;


WHILE .FLAGS[B_PENDING_LINES] NEQ 0 DO
    BEGIN
    EOL();
    FLAGS[B_PENDING_LINES] = .FLAGS[B_PENDING_LINES] - 1;
    END;


DESC[0] = .CTRL[0];
DESC[1] = CTRL[1];


IF
    BEGIN
    IF .FLAGS[B_PENDING_SPACES] GTRU .LIST_DESC[0]
    THEN
	TRUE
    ELSE
	BEGIN
	IF .FLAGS[B_PENDING_SPACES] NEQ 0
	THEN
	    BEGIN
	    LIST_DESC[0] = .LIST_DESC[0] - .FLAGS[B_PENDING_SPACES];
	    LIST_DESC[1] = CH$FILL(%C' ', .FLAGS[B_PENDING_SPACES], .LIST_DESC[1]);
	    END;


	STATUS = $FAOL(
	    CTRSTR=DESC,
	    OUTLEN=OUTLEN,
	    OUTBUF=LIST_DESC,
	    PRMLST=PARAM);
	.STATUS<0,16> EQL SS$_BUFFEROVF AND NOT .FLAGS[V_TRUNCATE]
	END
    END
THEN
    BEGIN
    EOL();
    LIST_DESC[0] = .LIST_DESC[0] - .FLAGS[B_LEFT_MARGIN];
    LIST_DESC[1] = CH$FILL(%C' ', .FLAGS[B_LEFT_MARGIN], .LIST_DESC[1]);
    $FAOL(CTRSTR=DESC, OUTLEN=OUTLEN, OUTBUF=LIST_DESC, PRMLST=PARAM);
    END;


FLAGS[B_PENDING_SPACES] = 0;
LIST_DESC[0] = .LIST_DESC[0] - .OUTLEN;
LIST_DESC[1] = .LIST_DESC[1] + .OUTLEN;
END;

ROUTINE EOL: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes the listing buffer to the listing file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	The listing is produced.
!
!--

BEGIN
LOCAL
	DESC:		VECTOR[2];	! Descriptor for line


DESC[0] = .FLAGS[B_RIGHT_MARGIN] - .LIST_DESC[0];
DESC[1] = LIST_BUFFER;
PUT_OUTPUT(DESC);
LIST_DESC[0] = .FLAGS[B_RIGHT_MARGIN];
LIST_DESC[1] = LIST_BUFFER;
CH$FILL(%C' ', .LIST_DESC[0], .LIST_DESC[1]);
END;

ROUTINE CEOL: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes the listing buffer to the listing file if the
!	listing buffer contains any text.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	The listing is produced.
!
!--

BEGIN
IF .LIST_DESC[0] NEQ .FLAGS[B_RIGHT_MARGIN] THEN EOL();
END;

ROUTINE PUT_OUTPUT (DESC) : NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes a record to the listing file.
!
! INPUT PARAMETERS:
!	DESC = The address of the string descriptor for the record to write.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	The listing is produced.
!
!--

BEGIN
MAP
	DESC:		REF BBLOCK;

LOCAL
	STATUS;


RAB[RAB$W_RSZ] = .DESC[DSC$W_LENGTH];
RAB[RAB$L_RBF] = .DESC[DSC$A_POINTER];

IF NOT (STATUS = $PUT(RAB=RAB))
THEN 
    SIGNAL_STOP(QUEMAN$_WRITEERR,1,OUTPUT_DESC,.STATUS,.RAB[RAB$L_STV]);

END;

ROUTINE EXIT_HANDLER: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is an exit handler that is established as long as the
!	process owns open wildcarding.  Its function is to cancel $GETQUI
!	wildcarding if an image exit should occur.
!
! INPUT PARAMETERS:
!	Standard exit handler parameters (not used).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
$GETQUI(FUNC=QUI$_CANCEL_OPERATION);
END;

END
ELUDOM
