MONMAIN: Procedure	Returns(Fixed Binary(31))
			Options(Ident('V04-000'), Main);

/*
/****************************************************************************
/*									    *
/*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
/*  ALL RIGHTS RESERVED.						    *
/* 									    *
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
/*  TRANSFERRED.							    *
/* 									    *
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
/*  CORPORATION.							    *
/* 									    *
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
/* 									    *
/*									    *
/****************************************************************************
/*/

/*
/*++
/* FACILITY:  VAX/VMS MONITOR Utility 
/*
/* ABSTRACT:  MAIN Routine, including command interface.
/*
/*
/* ENVIRONMENT:
/*
/*		Unprivileged user mode,
/*		except for certain collection routines which
/*		run in EXEC or KERNEL mode to access system
/*		data bases.
/*
/* AUTHOR:  Thomas L. Cafarella, April, 1981
/*

/*
/* MODIFIED BY:
/*
/*	V03-018	TLC1089		Thomas L. Cafarella	26-Jul-1984	11:00
/*		Accept a space character in time specification.
/*
/*	V03-017	TLC1087		Thomas L. Cafarella	25-Jul-1984	15:00
/*		Default to /ALL when summarizing.
/*
/*	V03-016	TLC1075		Thomas L. Cafarella	27-Jun-1984	15:00
/*		Add stickiness to /INPUT qualifier.
/*
/*	V03-015	TLC1073		Thomas L. Cafarella	02-May-1984	13:00
/*		Make MAX_INP_FILES limit bigger.
/*
/*	V03-014	PRS1012		Paul R. Senn		23-Mar-1984	14:00
/*		Add wildcard capability for MF summary.
/*
/*	V03-013	TLC1056		Thomas L. Cafarella	23-Mar-1984	13:00
/*		Exclude class which is disabled.
/*
/*	V03-012	PRS1011		Paul R. Senn		29-Feb-1984	14:00
/*		add /FLUSH_INTERVAL qualifier
/*
/*	V03-011	TLC1052		Thomas L. Cafarella	17-Feb-1984	11:00
/*		Add multi-file summary capability.
/*
/*	V03-010	PRS1002		Paul R. Senn		29-Dec-1983	16:00
/*		GLOBALDEF VALUE symbols must now be longwords; 
/*		Use %REPLACE rather than GLOBALDEF VALUE for any equated
/*		symbols which are not 4 bytes in length; 
/*
/*	V03-010	PRS1001		Paul R. Senn		27-Dec-1983	16:00
/*		Add ALL CLASSES Pseudo-class
/*
/*	V03-009	TLC1044		Thomas L. Cafarella	24-Aug-1983	13:00
/*		Eliminate CLI "NOCOMD" error for comment lines.
/*
/*	V03-008	SPC0007		Stephen P. Carney	24-Jun-1983	16:00
/*		Add EXECUTE subcommand.
/*
/*	V03-007	TLC1042		Thomas L. Cafarella	19-Jun-1983	15:00
/*		Add /ITEM qualifier for homogeneous classes.
/*
/*	V03-007	TLC1041		Thomas L. Cafarella	16-Jun-1983	15:00
/*		Ignore CLI error message when no command on line.
/*
/*	V03-007	TLC1038		Thomas L. Cafarella	14-Jun-1983	18:00
/*		Make default list of classes replace previous list.
/*
/*	V03-006	TLC1028		Thomas L. Cafarella	14-Apr-1983	16:00
/*		Add interactive user interface.
/*
/*	V03-005	TLC1019		Thomas L. Cafarella	18-Jun-1982	16:00
/*		Change CLI$_NEGATED symbol to CLI$_LOCNEG.
/*
/*	V03-004	TLC1012		Thomas L. Cafarella	30-Mar-1982	13:00
/*		Display user's comment string on screen line 5.
/*
/*	V03-004	TLC1011		Thomas L. Cafarella	29-Mar-1982	20:00
/*		Move system service names for SSERROR msg to static storage.
/*
/*	V03-003	TLC1009		Thomas L. Cafarella	29-Mar-1982	01:00
/*		Get current time when other times are converted.
/*
/*	V03-003	TLC1007		Thomas L. Cafarella	28-Mar-1982	19:00
/*		Add checks for maximum sizes of qualifier values.
/*
/*	V03-002	TLC1003		Thomas L. Cafarella	23-Mar-1982	13:00
/*		Fix up module headers.
/*
/*	V03-001	TLC1001		Thomas L. Cafarella	16-Mar-1982	13:00
/*		Add CTRL-W screen refresh support.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;				/* Monitor utility structure definitions */
%INCLUDE	$CHFDEF;			/* Condition handler facility definitions */
%INCLUDE	$STSDEF;			/* Status code definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		   SYSTEM SERVICE MACRO DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE NOT_SUCCESSFUL		BY '0'B;		/* Failing status bit */
%REPLACE YES			BY '1'B;		/* For general use */
%REPLACE NO			BY '0'B;		/* For general use */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),
							/* Routine to log synchronous errors */
SIGNAL_MON_ERR	ENTRY,					/* Routine to signal MONITOR errors */
DISPLAY_CLEANUP	ENTRY RETURNS(FIXED BINARY(31)),	/* Procedure clean up DISPLAY processing */
SS$_NORMAL	FIXED BINARY(31) GLOBALREF VALUE,	/* System normal return status */
RMS$_EOF	FIXED BINARY(31) GLOBALREF VALUE,	/* RMS end-of-file return status */
RMS$_NMF	FIXED BINARY(31) GLOBALREF VALUE,	/* RMS no-more-files message for wildcard parsing */
RMS$_FNF	FIXED BINARY(31) GLOBALREF VALUE,	/* RMS file-not-found message */
NORMAL		FIXED BINARY(31) GLOBALDEF;		/* MONITOR normal return status */

Declare
MNR$_ERREXEREA	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_ERRRECFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_UNEXPERR	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_ERRPARSE	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
CLI$_NOCOMD	FIXED BINARY(31) GLOBALREF VALUE;	/* CLI error message code */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		      GLOBAL STORAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
COMMAND_FILE		FILE             GLOBALREF;		/* Execute Command File */

Declare
CURR_ERRCODE		FIXED BINARY(31) GLOBALDEF INIT(0),	/* MONITOR error status code currently expected */
FIRST_MON_CMD		BIT(1) ALIGNED GLOBALDEF INIT('0'B),	/* YES => first MONITOR (DCL-level) cmd executing */
PROMPT			BIT(1) ALIGNED GLOBALDEF INIT('0'B),	/* YES => prompt user for another subcommand */
EXECUTE			BIT(1) ALIGNED GLOBALDEF INIT('0'B),	/* YES => read another command from the execute file */
DISPLAYING		BIT(1) ALIGNED GLOBALDEF INIT('0'B);	/* YES => terminal display output is active */

Declare
CDBPTR			POINTER GLOBALDEF,		/* Pointer to CDB (Class Descriptor Block) */
MRBPTR			POINTER GLOBALDEF,		/* Pointer to MRB (Monitor Request Block) */
DEF_MRBPTR		POINTER GLOBALDEF,		/* Pointer to "default" MRB (Monitor Request Block) */
TEMP_MRBPTR		POINTER GLOBALDEF,		/* Pointer to "temporary" MRB (Monitor Request Block) */
CURR_MRBPTR		POINTER GLOBALDEF,		/* Pointer to "current" MRB (Monitor Request Block) */
ACT_MRBPTR		POINTER GLOBALDEF,		/* Pointer to "active" MRB (Monitor Request Block) */
MCAPTR			POINTER GLOBALDEF,		/* Pointer to MCA (Monitor Communication Area) */
SPTR			POINTER GLOBALDEF;		/* Pointer to SYI (System Information Area) */

Declare
QUALPTR			POINTER GLOBALDEF,		/* Pointer to Qualifier Descriptors Block */
DEFPTR			POINTER GLOBALDEF;		/* Pointer to Qualifier Default Value Descriptors Block */

Declare
1 STAT_TABLE	GLOBALDEF,				/* Table of pointers to str descrs for statistic qualifiers */
  2 STAT_DESC 	(0:STATS-1) POINTER;

Declare
1 PROCD_TABLE	GLOBALDEF,				/* Table of pointers to str descrs for PROCESSES display qualifiers */
  2 PROCD_DESC 	(0:PROCDISPS-1) POINTER;


/*
/*	Counted strings for system service names used in the MNR$_SSERROR error message
/*/

Declare
  1 READEF_STR GLOBALDEF,					/* Counted string for $READEF */	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$READEF'),		/* String */

  1 CLREF_STR GLOBALDEF,					/* Counted string for $CLREF */	
	   2 L		FIXED BINARY(7) INIT(6),		/* Length */
	   2 S		CHAR(7) INIT('$CLREF'),			/* String */

  1 SCHDWK_STR GLOBALDEF,					/* Counted string for $SCHDWK */	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$SCHDWK'),		/* String */

  1 SETIMR_STR GLOBALDEF,					/* Counted string for $SETIMR */	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$SETIMR'),		/* String */

  1 DCLAST_STR GLOBALDEF,					/* Counted string for $DCLAST*/	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$DCLAST');		/* String */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CALL			FIXED BINARY(31),		/* Holds function value (return status) of called routines */ 
STATUS			BIT(1)	BASED(ADDR(CALL));	/* Low-order status bit for called routines */

/*
/*	Strings for command qualifiers and parameter. Descriptors
/*	for these strings are defined in the QUAL structure.
/*/

DECLARE

BEG_QUAL_S	CHAR(9)	INIT('BEGINNING'),			/* BEGINNING qualifier string */
END_QUAL_S	CHAR(6)	INIT('ENDING'),				/* ENDING qualifier string */
INT_QUAL_S	CHAR(8)	INIT('INTERVAL'),			/* INTERVAL qualifier string */
FLUSH_QUAL_S	CHAR(14) INIT('FLUSH_INTERVAL'),		/* FLUSH_INTERVAL qualifier string */
VIEW_QUAL_S	CHAR(12) INIT('VIEWING_TIME'),			/* VIEWING_TIME qualifier string */
INP_QUAL_S	CHAR(5)	INIT('INPUT'),				/* INPUT qualifier string */
DISP_QUAL_S	CHAR(7)	INIT('DISPLAY'),			/* DISPLAY qualifier string */
REC_QUAL_S	CHAR(6)	INIT('RECORD'),				/* RECORD qualifier string */
SUMM_QUAL_S	CHAR(7)	INIT('SUMMARY'),			/* SUMMARY qualifier string */
COMM_QUAL_S	CHAR(7)	INIT('COMMENT'),			/* COMMENT qualifier string */
BY_NODE_QUAL_S	CHAR(7)	INIT('BY_NODE'),			/* BY_NODE qualifier string */
CLASS_PARM_S	CHAR(10) INIT('CLASS_NAME');			/* CLASS_NAME parameter string */

/*
/*	Strings for class-name qualifiers. Descriptors for these strings are defined in
/*	the QUAL structure.
/*/

DECLARE

ALL_QUAL_S	CHAR(3)	INIT('ALL'),				/* ALL qualifier string */
CUR_QUAL_S	CHAR(7)	INIT('CURRENT'),			/* CURRENT qualifier string */
AVE_QUAL_S	CHAR(7)	INIT('AVERAGE'),			/* AVERAGE qualifier string */
MIN_QUAL_S	CHAR(7)	INIT('MINIMUM'),			/* MINIMUM qualifier string */
MAX_QUAL_S	CHAR(7)	INIT('MAXIMUM'),			/* MAXIMUM qualifier string */
TOPC_QUAL_S	CHAR(6)	INIT('TOPCPU'),				/* TOPCPU qualifier string */
TOPD_QUAL_S	CHAR(6)	INIT('TOPDIO'),				/* TOPDIO qualifier string */
TOPB_QUAL_S	CHAR(6)	INIT('TOPBIO'),				/* TOPBIO qualifier string */
TOPF_QUAL_S	CHAR(8)	INIT('TOPFAULT'),			/* TOPFAULT qualifier string */
CPU_QUAL_S	CHAR(3)	INIT('CPU'),				/* CPU qualifier string */
PCENT_QUAL_S	CHAR(7)	INIT('PERCENT'),			/* PERCENT qualifier string */
ITEM_QUAL_S	CHAR(4)	INIT('ITEM');				/* ITEM qualifier string */


/*
/*	Default file-spec values for qualifiers. Descriptors for these strings are
/*	defined in the DEF structure.
/*/

DECLARE

REC_DEF_S	CHAR(11) INIT('MONITOR.DAT'),			/* RECORD qualifier default value */
DISP_DEF_S	CHAR(11) INIT('SYS$OUTPUT:'),			/* DISPLAY qualifier default value */
SUMM_DEF_S	CHAR(11) INIT('MONITOR.SUM');			/* SUMMARY qualifier default value */



DECLARE

01 MRB_DEF, 						/* Default Monitor Request Block */

    02 beg	bit(64) aligned		init('0'B),	/* Beginning time of request in system time units */
    02 end	bit(64) aligned		init('0'B),	/* Ending time of request in system time units */
    02 int	fixed binary(31)	init(0),	/* Interval value in seconds */
    02 flush	fixed binary(31)	init(0),	/* Flush interval in seconds */
    02 vie	fixed binary(31)	init(0),	/* Viewing time for a screen in seconds */
    02 inp	pointer			init(null()),	/* Address of input file descr (0 if input not requested) */
    02 dis	pointer,				/* Address of display file descr (0 if display not requested) */
							/* (Initialized in MONITOR_INIT routine) */
    02 rec	pointer			init(null()),	/* Address of record file descr (0 if record not requested) */
    02 sum	pointer			init(null()),	/* Address of summary file descr (0 if summary not requested) */
    02 com	pointer			init(null()),	/* Address of comment string descriptor */
    02 clc	fixed binary(15),			/* Count of classes requested (needs no init) */
    02 clb	bit(128) aligned	init('0'B),	/* Bit string of requested classes */
    02 inf	fixed binary(7),			/* Count of input files specified (needs no init) */
    02 fla,						/* Flags for MRB */
	03 dis	bit(1)			init(NO),
	03 rec	bit(1)			init(NO),
	03 sum	bit(1)			init(NO),
	03 pbk	bit(1)			init(NO),
	03 ide	bit(1)			init(NO),
	03 dtf	bit(1)			init(NO),
	03 icr	bit(1)			init(NO),
	03 rcr	bit(1)			init(NO),
	03 dcr	bit(1)			init(NO),
	03 scr	bit(1)			init(NO),
	03 alc	bit(1)			init(NO),
	03 mfs	bit(1)			init(NO),
	03 byn	bit(1)			init(NO),
	03 scl	bit(1)			init(NO),
	03 fil	bit(2)			init('0'B);

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MONMAIN
/*
/*	This routine is the main Monitor routine, entered from DCL.
/*	It calls the CLE (Command Language Editor) to parse the
/*	MONITOR command line, and creates a Monitor Request Block (MRB)
/*	describing the request. The EXECUTE_REQUEST routine is then
/*	called to execute the request.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	The MONITOR command line.
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status.
/*
/*--
/*/

ON FINISH;						/* On finish, do nothing */
ON ANYCONDITION						/* On any condition signaled, */
    BEGIN;
    DECLARE MON_CODE	FIXED BINARY(31),		/* Monitor message code */
	    TEMP	FIXED BINARY(31),		/* Temporary scratch area */
	    ON_FILE	CHAR(100) VARYING,		/* Holds possible file name string */
	    MNR$_FACNO	FIXED BINARY(31) GLOBALREF VALUE, /* MONITOR facility number */
	    SIGNALED_ERR ENTRY (ANY VALUE, ANY VALUE, ANY VALUE, ANY); /* Rtn to set up PUTMSGVEC */

    CHF$ARGPTR = ONARGSLIST();				/* Get signal array pointer */
    STS$VALUE = CHF$SIG_NAME;				/* Get code for signaled condition */
    UNSPEC(TEMP) = STS$FAC_NO;				/* Convert facility no. to binary in TEMP */
    IF TEMP = MNR$_FACNO				/* If a MONITOR code, re-signal it */
	THEN CALL RESIGNAL();

    IF CURR_ERRCODE = MNR$_ERRPARSE & 			/* If expecting a CLU parsing error, */
       CHF$SIG_NAME = CLI$_NOCOMD			/* AND it's a "No Command on Line", */
	THEN CALL = NORMAL;				/*   then set up code so it's ignored */
	ELSE DO;					/* Otherwise */
	     IF CURR_ERRCODE = MNR$_ERREXEREA		/* Was it an execute command file read error? */
		 THEN DO;				
		     CLOSE FILE (COMMAND_FILE);		/*  Yes, close the execute command file */
		     EXECUTE = NO;			/*  Don't do any more input from the file */
		     END;				
	     IF CURR_ERRCODE = 0			/* See if an error is currently expected */
		 THEN MON_CODE = MNR$_UNEXPERR;		/* No, set "unexpected" code */
		 ELSE MON_CODE = CURR_ERRCODE;		/* Yes, set currently expected code */
	     CALL SIGNALED_ERR(MON_CODE,STS$VALUE,DIM(CHF$SIG_ARG,1),CHF$SIG_ARG); /* Log the error */
	     CALL = MON_CODE;				/* Set up code for MONITOR request termination */
	     END;

    CURR_ERRCODE = 0;					/* Reset to default MONITOR error code ("unexpected") */
    GO TO MON_REQ_TERM;					/* ... and go terminate (PL/I does an UNWIND) */
    END;

CALL = MONITOR_INIT();					/* Do image-wide initialization */
IF STATUS						/* Continue if status OK */
    THEN CALL = MONITOR_CMD();				/* Analyze and execute first (DCL-level) MONITOR cmd */

MON_REQ_TERM:						/* MONITOR request termination */

/*
/* 	We get to this point by one of three routes:
/*
/*		1) A MONITOR request has just terminated successfully or with an error status code; or
/*		2) A MONITOR request has just terminated with an error that was signaled; or
/*		3) The MONITOR_INIT call above terminated with an error status.
/*
/*	In all three cases we want to do the same thing. That is, to loop prompting for more subcommands
/*	as long as the PROMPT indicator is still set to YES. It can be set to NO by an EXIT subcommand,
/*	or as a result of the user's striking CTRL/Z (either in response to the MONITOR> prompt, or while
/*	a MONITOR request is running). In case 3 above, it will always be set to NO. For all cases, the
/*	variable CALL contains the status code of interest and, if an error, the PUTMSG vector (PUTMSGVEC)
/*	has been set up with error message information. STATUS is a synonym for the low-order bit of CALL.
/*
/*	If the EXECUTE indicator is set to YES then NEXT_EXECUTE_COMMAND will be called.  If EXECUTE is set
/*	to NO, then NEXT_COMMAND is called.  NEXT_EXECUTE_COMMAND will retrieve commands from a file intead
/*	of the terminal as done by EXECUTE_COMMAND.
/*/

IF STATUS = NOT_SUCCESSFUL				/* If bad status, */
    THEN DO;
	 IF DISPLAYING = YES				/* If display output is active, */
	     THEN STS$VALUE = DISPLAY_CLEANUP();	/*   then perform cleanup */
	 CALL SIGNAL_MON_ERR();				/* Signal MONITOR error */
	 END;

DO WHILE (PROMPT = YES);				/* Main loop to perform subcommands */
    IF EXECUTE = YES					/* Read from the execute command file? */
    	THEN CALL = NEXT_EXECUTE_COMMAND(); 		/* Yes, execute next subcommand line from the file */
    	ELSE CALL = NEXT_COMMAND();			/* No, Read from the terminal and execute next subcommand line */
    IF STATUS = NOT_SUCCESSFUL THEN DO;			/* If bad status, */
	IF DISPLAYING = YES				/* If display output is active, */
	    THEN STS$VALUE = DISPLAY_CLEANUP();		/*   then perform cleanup */
	CALL SIGNAL_MON_ERR();				/* Signal MONITOR error, using PUTMSGVEC */
	END;
END;							/* End of subcommand loop */


STS$VALUE = CALL;					/* Get MONITOR completion status */
STS$INHIB_MSG = YES;					/* Inhibit DCL print */
RETURN(STS$VALUE);					/* Return to DCL */

MONITOR_INIT: Procedure Returns(Fixed Binary(31));

/*
/* 	This routine performs general set-up, including
/* 	setting of the current MRB to default values.
/*/



PROMPT = NO;					/* Start out assuming no MONITOR> prompting */
EXECUTE = NO;					/* Start out assuming no EXECUTE file */
FIRST_MON_CMD = YES;				/* Indicate first MONITOR command (entered at DCL) */
NORMAL = SS$_NORMAL;				/* Use system's normal status */

/*
/*	Allocate the two blocks which contain string descriptors for
/*	command qualifiers and default qualifier values. Global
/*	pointers to the blocks are automatically established.
/*/

ALLOCATE QUALIFIER_DESC;
ALLOCATE DEF_DESC;


/*
/* 	Initialize string descriptors for command
/* 	qualifiers, command parameters, etc.
/*/

QUAL$L_BEG = LENGTH(BEG_QUAL_S);		/* Init length longword of descr */
QUAL$A_BEG = ADDR(BEG_QUAL_S);			/* Init address longword of descr */

QUAL$L_END = LENGTH(END_QUAL_S);		/* Init length longword of descr */
QUAL$A_END = ADDR(END_QUAL_S);			/* Init address longword of descr */

QUAL$L_INT = LENGTH(INT_QUAL_S);		/* Init length longword of descr */
QUAL$A_INT = ADDR(INT_QUAL_S);			/* Init address longword of descr */

QUAL$L_FLUSH = LENGTH(FLUSH_QUAL_S);		/* Init length longword of descr */
QUAL$A_FLUSH = ADDR(FLUSH_QUAL_S);		/* Init address longword of descr */

QUAL$L_VIEW = LENGTH(VIEW_QUAL_S);		/* Init length longword of descr */
QUAL$A_VIEW = ADDR(VIEW_QUAL_S);		/* Init address longword of descr */

QUAL$L_BY_NODE = LENGTH(BY_NODE_QUAL_S);	/* Init length longword of descr */
QUAL$A_BY_NODE = ADDR(BY_NODE_QUAL_S);		/* Init address longword of descr */

QUAL$L_INP = LENGTH(INP_QUAL_S);		/* Init length longword of descr */
QUAL$A_INP = ADDR(INP_QUAL_S);			/* Init address longword of descr */

QUAL$L_DISP = LENGTH(DISP_QUAL_S);		/* Init length longword of descr */
QUAL$A_DISP = ADDR(DISP_QUAL_S);		/* Init address longword of descr */

QUAL$L_REC = LENGTH(REC_QUAL_S);		/* Init length longword of descr */
QUAL$A_REC = ADDR(REC_QUAL_S);			/* Init address longword of descr */

QUAL$L_SUMM = LENGTH(SUMM_QUAL_S);		/* Init length longword of descr */
QUAL$A_SUMM = ADDR(SUMM_QUAL_S);		/* Init address longword of descr */

QUAL$L_COMM = LENGTH(COMM_QUAL_S);		/* Init length longword of descr */
QUAL$A_COMM = ADDR(COMM_QUAL_S);		/* Init address longword of descr */

QUAL$L_BY_NODE = LENGTH(BY_NODE_QUAL_S);	/* Init length longword of descr */
QUAL$A_BY_NODE = ADDR(BY_NODE_QUAL_S);		/* Init address longword of descr */

QUAL$L_CLASS = LENGTH(CLASS_PARM_S);		/* Init length longword of descr */
QUAL$A_CLASS = ADDR(CLASS_PARM_S);		/* Init address longword of descr */

QUAL$L_ALL = LENGTH(ALL_QUAL_S);		/* Init length longword of descr */
QUAL$A_ALL = ADDR(ALL_QUAL_S);			/* Init address longword of descr */

QUAL$L_CUR = LENGTH(CUR_QUAL_S);		/* Init length longword of descr */
QUAL$A_CUR = ADDR(CUR_QUAL_S);			/* Init address longword of descr */

QUAL$L_AVE = LENGTH(AVE_QUAL_S);		/* Init length longword of descr */
QUAL$A_AVE = ADDR(AVE_QUAL_S);			/* Init address longword of descr */

QUAL$L_MIN = LENGTH(MIN_QUAL_S);		/* Init length longword of descr */
QUAL$A_MIN = ADDR(MIN_QUAL_S);			/* Init address longword of descr */

QUAL$L_MAX = LENGTH(MAX_QUAL_S);		/* Init length longword of descr */
QUAL$A_MAX = ADDR(MAX_QUAL_S);			/* Init address longword of descr */

QUAL$L_TOPC = LENGTH(TOPC_QUAL_S);		/* Init length longword of descr */
QUAL$A_TOPC = ADDR(TOPC_QUAL_S);		/* Init address longword of descr */

QUAL$L_TOPD = LENGTH(TOPD_QUAL_S);		/* Init length longword of descr */
QUAL$A_TOPD = ADDR(TOPD_QUAL_S);		/* Init address longword of descr */

QUAL$L_TOPB = LENGTH(TOPB_QUAL_S);		/* Init length longword of descr */
QUAL$A_TOPB = ADDR(TOPB_QUAL_S);		/* Init address longword of descr */

QUAL$L_TOPF = LENGTH(TOPF_QUAL_S);		/* Init length longword of descr */
QUAL$A_TOPF = ADDR(TOPF_QUAL_S);		/* Init address longword of descr */

QUAL$L_CPU = LENGTH(CPU_QUAL_S);		/* Init length longword of descr */
QUAL$A_CPU = ADDR(CPU_QUAL_S);			/* Init address longword of descr */

QUAL$L_PCENT = LENGTH(PCENT_QUAL_S);		/* Init length longword of descr */
QUAL$A_PCENT = ADDR(PCENT_QUAL_S);		/* Init address longword of descr */

QUAL$L_ITEM = LENGTH(ITEM_QUAL_S);		/* Init length longword of descr */
QUAL$A_ITEM = ADDR(ITEM_QUAL_S);		/* Init address longword of descr */

DEF$L_REC = LENGTH(REC_DEF_S);			/* Init length longword of descr */
DEF$A_REC = ADDR(REC_DEF_S);			/* Init address longword of descr */

DEF$L_DISP = LENGTH(DISP_DEF_S);		/* Init length longword of descr */
DEF$A_DISP = ADDR(DISP_DEF_S);			/* Init address longword of descr */

DEF$L_SUMM = LENGTH(SUMM_DEF_S);		/* Init length longword of descr */
DEF$A_SUMM = ADDR(SUMM_DEF_S);			/* Init address longword of descr */


/*
/* 	Initialize STAT_TABLE descriptor pointers.
/*/

STAT_DESC(ALL_STAT) = ADDR(QUAL$L_ALL);		/* Init pointer to ALL descr */
STAT_DESC(CUR_STAT) = ADDR(QUAL$L_CUR);		/* Init pointer to CUR descr */
STAT_DESC(AVE_STAT) = ADDR(QUAL$L_AVE);		/* Init pointer to AVE descr */
STAT_DESC(MIN_STAT) = ADDR(QUAL$L_MIN);		/* Init pointer to MIN descr */
STAT_DESC(MAX_STAT) = ADDR(QUAL$L_MAX);		/* Init pointer to MAX descr */

/*
/* 	Initialize PROCD_TABLE descriptor pointers.
/*/

PROCD_DESC(REG_PROC) = NULL();			/* Indicate no qualifier for "regular" PROCESSES display */
PROCD_DESC(TOPC_PROC) = ADDR(QUAL$L_TOPC);	/* Init pointer to TOPC descr */
PROCD_DESC(TOPD_PROC) = ADDR(QUAL$L_TOPD);	/* Init pointer to TOPD descr */
PROCD_DESC(TOPB_PROC) = ADDR(QUAL$L_TOPB);	/* Init pointer to TOPB descr */
PROCD_DESC(TOPF_PROC) = ADDR(QUAL$L_TOPF);	/* Init pointer to TOPF descr */

MRB_DEF.DIS = ADDR(DEF$L_DISP);			/* Init default value of ptr to display file descr */
ALLOCATE MCA SET(MCAPTR);			/* Obtain Monitor Communication Area */
ALLOCATE SYS_INFO SET(SPTR);			/* Obtain System Information Area */

/*
/*	Allocate "temp", "current" and "active" MRBs. Another MRB (MRB_DEF),
/*	the "default" MRB, is allocated in the data section above. Each MRB fully describes
/*	a MONITOR request. The usage of the MRBs is analogous to that of SYSGEN PAR files.
/*	To wit, the "default" MRB never changes; it is moved to the "current" MRB whenever
/*	an INITIALIZE subcommand is issued; an implicit INITIALIZE occurs when the MONITOR
/*	image is invoked. The "current" MRB may be changed repeatedly with SET commands without
/*	actually executing a request; When a MONITOR request is executed (with a MONITOR
/*	subcommand, or a MONITOR DCL command), the "current" MRB is moved to the "active" MRB,
/*	the "active" MRB is updated in accordance with the MONITOR request, and the request
/*	is executed using the "active" MRB. The "temp" MRB is used to accumulate information
/*	resulting from a SET command. If the command contains no errors, "temp" is swapped
/*	with "current"; otherwise, "temp" is discarded. This is done to avoid defining a partial
/*	request when the SET command contains an error.
/*/

ALLOCATE MRB SET(TEMP_MRBPTR);			/* Allocate the "temp" MRB */
ALLOCATE MRB SET(CURR_MRBPTR);			/* Allocate the "current" MRB */
ALLOCATE MRB SET(ACT_MRBPTR);			/* Allocate the "active" MRB */
DEF_MRBPTR = ADDR(MRB_DEF);			/* Init pointer to "default" MRB */

CALL = INIT_CMD();				/* Do an INITIALIZE command ... i.e., move default */
						/* ... MRB to current MRB */

RETURN(CALL);					/* Return with status from INIT_CMD */
END MONITOR_INIT;

NEXT_COMMAND: Procedure Returns(Fixed Binary(31));	/* Routine to read the next subcommand & execute it */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	NEXT_COMMAND
/*
/*	This routine is called by the main routine to read the next subcommand and execute it.
/*	It returns a status code indicating the disposition of the command.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	PROMPT -- a bit indicating whether or not to prompt for a command.
/*	          It has always been set to YES before entry to NEXT_COMMAND.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	The next command is executed.
/*
/*	PROMPT  -- a bit indicating whether or not to prompt for another
/*	command. It is always set to YES before entry to NEXT_COMMAND, and
/*	can be set to NO by NEXT_COMMAND in any of the following situations:
/*
/*		1) The user issues the EXIT subcommand.
/*		2) The user strikes CTRL/Z in response to the MONITOR> prompt.
/*		3) The user strikes CTRL/Z while a MONITOR subcommand is running.
/*
/*	PUTMSGVEC -- a 20-longword vector which is loaded with error message
/*	             information by NEXT_COMMAND whenever an error status is
/*		     returned to the caller of NEXT_COMMAND.
/*
/* ROUTINE VALUE:
/*
/*	A status code indicating the disposition of the command. If an
/*	error status, then the PUTMSGVEC error message vector will have
/*	been set up.
/*
/* SIDE EFFECTS:
/*
/*	None
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 			 COMPILE TIME DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	MAX_EXEC_LINE		BY 256;			/* Max execute file line size */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  CLI$DCL_PARSE	EXTERNAL ENTRY(ANY, ANY)			/* Rtn to do DCL-like parsing of cmd line */
		RETURNS(FIXED BINARY(31)),
  CLI$DISPATCH	EXTERNAL ENTRY					/* Rtn to dispatch to latest parsed cmd */
		RETURNS(FIXED BINARY(31)),
  LIB$GET_INPUT	EXTERNAL ENTRY(ANY, ANY, FIXED BINARY(15))	/* Rtn to read a line from SYS$INPUT */
		OPTIONS(VARIABLE)
		RETURNS(FIXED BINARY(31)),
  STR$POSITION	EXTERNAL ENTRY(ANY, ANY, ANY)			/* Rtn to locate 1st occurance of a substring */
		OPTIONS(VARIABLE)
		RETURNS(FIXED BINARY(31)),
  STR$REPLACE	EXTERNAl ENTRY(ANY, ANY, ANY, ANY, ANY)		/* Rtn to replace a substring with another substring */
		RETURNS(FIXED BINARY(31));

Declare
MNR$_ERREXEREP	FIXED BINARY(31) GLOBALREF VALUE,		/* Error message code */
MNR$_ERRPROMPT	FIXED BINARY(31) GLOBALREF VALUE;		/* Error message code */

/*
/*	String descriptor for user prompt string
/*/

Declare

1 PROMPT_STR GLOBALREF,						/* User prompt string descriptor */
  2 L		FIXED BINARY(31),
  2 A		POINTER;

Declare
1 DYN_STRING	GLOBALREF,					/* Dynamic string descriptor */
  2 L		FIXED BINARY(15),				/* Length */
  2 TC		CHAR(2),					/* Type and Class */
  2 A		POINTER,					/* Address */
DYN_STRING_S	CHAR(DYN_STRING.L) BASED(DYN_STRING.A);		/* String */

Declare
1 CMD_LINE,							/* Static command line descriptor (for subcommands) */
  2 L		FIXED BINARY(31),				/* Length */
  2 A		POINTER,					/* Address */

1 REP_LINE,							/* Static command line descriptor (for subcommands) */
  2 L		FIXED BINARY(31),				/* Length */
  2 A		POINTER,					/* Address */

CMD_LINE_S	CHAR(MAX_EXEC_LINE) STATIC;			/* Command buffer to replace "@" with "EXECUTE " */


Declare
  MONSUB	CHAR(1)	GLOBALREF;				/* Command language definition tables ... */
								/* Note -- we simply need a global reference to the */
								/* tables. Their length is unknown and irrelevant */
Declare
  AT_SIGN_S	CHAR(1) STATIC INIT('@'),			/* "@" used to search command line */
  EXECUTE_S	CHAR(8) STATIC INIT('EXECUTE '),		/* "EXECUTE " used to replace the "@" in the command line */
  AT_SIGN_POS	FIXED BINARY(31);				/* Position of "@" in the command line */


FIRST_MON_CMD = NO;						/* First MONITOR cmd executes before NEXT_COMMAND rtn */
DYN_STRING.L = 0;						/* Init cmd line length to enter loop */

DO WHILE (DYN_STRING.L = 0);					/* Loop while user enters null lines */
CALL = LIB$GET_INPUT(DYN_STRING,PROMPT_STR,);			/* Read the next subcommand */
IF STATUS = NOT_SUCCESSFUL					/* If LIB$GET_INPUT call failed, */
    THEN DO;
	 PROMPT = NO;						/* Indicate no more prompting */
	 IF CALL = RMS$_EOF					/* If end-of-input, */
	     THEN RETURN(NORMAL);				/*   then return with normal status */
	     ELSE DO;
		  CALL MON_ERR(MNR$_ERRPROMPT,CALL);		/* Otherwise, log the error ... */
		  RETURN(MNR$_ERRPROMPT);			/* and return with status */
		  END;
	 END;
END;

CMD_LINE.L = DYN_STRING.L;					/* Copy the length of the command line */
CMD_LINE.A = ADDR(CMD_LINE_S);					/* Get the address of the new working buffer */
CMD_LINE_S = DYN_STRING_S;					/* Copy the command line into the buffer */
AT_SIGN_POS = STR$POSITION(CMD_LINE, DESCRIPTOR(AT_SIGN_S));	/* Locate a "@" in the command line */
IF AT_SIGN_POS > 0 						/* Was there one? */
    THEN DO;							/* Yes, prepare to replace the "@" with "EXECUTE " */
	REP_LINE.L = CMD_LINE.L + 7;				/* Add space for "EXECUTE " in  replacement desc */
	REP_LINE.A = CMD_LINE.A;				/* Get address of replacement string */
	CALL = STR$REPLACE (REP_LINE, CMD_LINE, AT_SIGN_POS,	/* Replace the "@" with "EXECITE " */
			    AT_SIGN_POS, DESCRIPTOR(EXECUTE_S));/*  (need REP_LINE to prevent trunc warning) */ 
	IF STATUS = NOT_SUCCESSFUL				/* If STR$REPLACE call failed, */
	    THEN DO;						
		CALL MON_ERR(MNR$_ERREXEREP,CALL);		/* Log the error ... */
		RETURN(MNR$_ERREXEREP);				/* and return with status */
		END;
	    ELSE CMD_LINE.L = REP_LINE.L;			/* STR$REPLACE succeeded, update length of descr */
	END;

CURR_ERRCODE = MNR$_ERRPARSE;					/* Set MONITOR code in case parsing error signaled */
CALL = CLI$DCL_PARSE(CMD_LINE,MONSUB);				/* Parse the subcommand */
CURR_ERRCODE = 0;						/* Reset to default MONITOR code */
IF STATUS = NOT_SUCCESSFUL					/* If parse failed, */
    THEN DO;
	 IF CALL = CLI$_NOCOMD					/* If "no command on line" */
	     THEN RETURN(NORMAL);				/*   then quietly ignore it */
	     ELSE DO;						/* Otherwise, */
		  CALL MON_ERR(MNR$_ERRPARSE,CALL);		/*   log the error ... */
		  RETURN(MNR$_ERRPARSE);			/*   ... and return with status */
		  END;
	 END;

CALL = CLI$DISPATCH();						/* Execute the parsed command */
								/* Note -- command subroutines return status */
								/*         values and log their own errors by */
								/*         calling MON_ERR */

CURR_ERRCODE = 0;						/* Reset to default MONITOR code in case subcommand changed it */
RETURN(CALL);							/* Return to caller with cmd subroutine's status */

END NEXT_COMMAND;


NEXT_EXECUTE_COMMAND: Procedure Returns(Fixed Binary(31));	/* Routine to read the next subcommand & execute it */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	NEXT_EXECUTE_COMMAND
/*
/*	This routine is called by the main routine to read the next subcommand from
/*	the execute command file and execute it.  It returns a status code indicating 
/*	the disposition of the command.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	COMMAND_FILE - file reference used to read the execute command file.
/*
/*	EXECUTE - a bit indicating whether or not commands are read from an execute
/*		  command file.  It has been set to YES before entry to NEXT_EXECUTE_COMMAND.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	The next command is executed.
/*
/*	EXECUTE - a bit indicating whether or not to read from the execute command file
/*	for another command.  It is always set to YES before entry to NEXT_EXECUTE_COMMAND, 
/*	and can be set to NO by NEXT_EXECUTE_COMMAND in any of the following situations:
/*
/*		1) Execute command file EOF is encountered.
/*		2) The user issues the EXIT subcommand.
/*		3) The user strikes CTRL/Z in response to the MONITOR> prompt.
/*		4) The user strikes CTRL/Z while a MONITOR subcommand is running.
/*		5) The file cannot be opened properly.
/*		6) An error occurs when trying to read the file.
/*
/*	PUTMSGVEC -- a 20-longword vector which is loaded with error message
/*	             information by NEXT_EXECUTE_COMMAND whenever an error status is
/*		     returned to the caller of NEXT_EXECUTE_COMMAND.
/*
/* ROUTINE VALUE:
/*
/*	A status code indicating the disposition of the command. If an error status, 
/*	then the PUTMSGVEC error message vector will have been set up.
/*
/*	MNR$_ERRPARSE	- error parsing command from the execute command file.
/*	MNR$_ERREXEREA	- error reading execute command file.
/*	SS$_NORMAL	- Success.
/*
/* SIDE EFFECTS:
/*
/*	None.
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 			 COMPILE TIME DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	MAX_EXEC_LINE		BY 256;			/* Max execute file line size */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 			 EXTERNAL STORAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
    CLI$DCL_PARSE	EXTERNAL ENTRY(ANY, ANY)		/* Rtn to do DCL-like parsing of cmd line */
			RETURNS(FIXED BINARY(31)),
    CLI$DISPATCH	EXTERNAL ENTRY				/* Rtn to dispatch to latest parsed cmd */
			RETURNS(FIXED BINARY(31)),
    CLI$GET_VALUE	ENTRY(ANY, ANY)				/* CLE routine to get qualifier values */
			RETURNS(FIXED BINARY(31)),
    STR$POSITION	EXTERNAL ENTRY(ANY, ANY, ANY)		/* Rtn to locate 1st occurance of a substring */
			OPTIONS(VARIABLE)
			RETURNS(FIXED BINARY(31)),
    STR$REPLACE		EXTERNAL ENTRY(ANY, ANY, ANY, ANY, ANY) /* Rtn to replace a substring with another substring */
			RETURNS(FIXED BINARY(31));


Declare
    COMMAND_FILE	FILE             GLOBALREF,		/* Execute Command File */
    MONSUB		CHAR(1)          GLOBALREF,		/* Command language definition tables ... */
								/* Note -- we simply need a global reference to the */
								/* tables. Their length is unknown and irrelevant */
    NORMAL		FIXED BINARY(31) GLOBALREF,		/* MONITOR normal return status */
    EXECUTE		BIT(1) ALIGNED   GLOBALREF;		/* YES => read another command from the execute file */

Declare
    MNR$_ERREXEREP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
    MNR$_ERREXEREA	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
    MNR$_ERRPARSE	FIXED BINARY(31) GLOBALREF VALUE;	/* Error message code */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 			 GLOBAL STORAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
    1 SUB_COMMAND	GLOBALDEF,
      2 L		FIXED BINARY(31),
      2 A		POINTER,
    COMMAND_RECORD	CHAR(MAX_EXEC_LINE) STATIC VARYING GLOBALDEF;	/* Buffer for a subcommand */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/


Declare
    1 REP_LINE,							/* Static command line descriptor (for subcommands) */
      2 L		FIXED BINARY(31),			/* Length */
      2 A		POINTER;				/* Address */

Declare
    AT_SIGN_S	CHAR(1) STATIC INIT('@'),			/* "@" used to search command line */
    EXECUTE_S	CHAR(8) STATIC INIT('EXECUTE '),		/* "EXECUTE " used to replace "@" */
    AT_SIGN_POS	FIXED BINARY(31),				/* Position of "@" in command line */
    TEMP_COMMAND_PTR	FIXED BINARY(31)			/* Alias for SUB_COMMAND.A computation */ 
			BASED(ADDR(SUB_COMMAND.A)); 


ON ENDFILE (COMMAND_FILE) GOTO COMMAND_EOF;			/* Set up the EOF condition */


CURR_ERRCODE = MNR$_ERREXEREA;					/* Set MONITOR code in case read error is signaled */
READ FILE (COMMAND_FILE) INTO (COMMAND_RECORD);			/* Read the next subcommand */
CURR_ERRCODE = 0;						/* Reset the error code, assume the condition was reported */

SUB_COMMAND.L = LENGTH(COMMAND_RECORD);				/* Set the length of the SUB_COMMAND descriptor */
SUB_COMMAND.A = ADDR(COMMAND_RECORD);				/* Set the address of the SUB_COMMAND descriptor */
TEMP_COMMAND_PTR = TEMP_COMMAND_PTR + 2;			/* Advance ptr beyond length word */
AT_SIGN_POS = STR$POSITION(SUB_COMMAND, DESCRIPTOR(AT_SIGN_S));	/* Locate "@" in command line */
IF AT_SIGN_POS > 0 						/* Was there a "@" ? */
    THEN DO;							/* Yes, prepare to replace "@" with "EXECUTE " */
	REP_LINE.L = SUB_COMMAND.L + 7;				/* Add space for "EXECUTE " in replacement string */
	REP_LINE.A = SUB_COMMAND.A;				/* Get address of subcommand buffer */
	CALL = STR$REPLACE (REP_LINE, SUB_COMMAND, AT_SIGN_POS,	/* Replace "@" with "EXECUTE " */
			    AT_SIGN_POS, DESCRIPTOR(EXECUTE_S));/*  (REP_LINE prevents truncation warning) */
	IF STATUS = NOT_SUCCESSFUL				/* If STR$REPLACE call failed, */
	    THEN DO;
		CALL MON_ERR(MNR$_ERREXEREP,CALL);		/* Log the error ... */
		RETURN(MNR$_ERREXEREP);				/* and return with status */
		END;
	    ELSE SUB_COMMAND.L = REP_LINE.L;			/* STR$REPACE succeded, upade command desc */
	END;

CURR_ERRCODE = MNR$_ERRPARSE;					/* Set MONITOR code in case parsing error signaled */
CALL = CLI$DCL_PARSE(SUB_COMMAND,MONSUB);			/* Parse the subcommand */
CURR_ERRCODE = 0;						/* Reset to default MONITOR code */
IF STATUS = NOT_SUCCESSFUL					/* If parse failed, */
    THEN DO;
	 IF CALL = CLI$_NOCOMD					/* If "no command on line" */
	     THEN RETURN(NORMAL);				/*   then quietly ignore it */
	     ELSE DO;						/* Otherwise, */
		  CALL MON_ERR(MNR$_ERRPARSE,CALL);		/*   log the error ... */
		  RETURN(MNR$_ERRPARSE);			/*   ... and return with status */
		  END;
	 END;

CALL = CLI$DISPATCH();						/* Execute the parsed command */
								/* Note -- command subroutines return status */
								/*         values and log their own errors by */
								/*         calling MON_ERR */
CURR_ERRCODE = 0;						/* Reset to default MONITOR code in case subcommand changed it */
RETURN(CALL);							/* Return to caller with cmd subroutine's status */


COMMAND_EOF:
    CLOSE FILE (COMMAND_FILE);					/* Close the file after EOF condition raised */
    EXECUTE = NO;						/* Indicate no more from the execute file */
    CURR_ERRCODE = 0;						/* Reset to default MONITOR code in case subcommand changed it */
    RETURN(NORMAL);						/* Return to caller with cmd subroutine's status */

END NEXT_EXECUTE_COMMAND;

END MONMAIN;

GET_QUALIFIERS: Procedure Returns(Fixed Binary(31));

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	GET_QUALIFIERS
/*
/*	Communicate with CLE to get qualifier settings and
/*	their values. Record all such info in the MRB (Monitor
/*	Request Block) pointed to by the current value of MRBPTR
/*	(it may be the "current" or the "active" MRB).
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;				/* Monitor utility structure definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		   SYSTEM SERVICE MACRO DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$GETTIM;			/* $GETTIM system service */
/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CLI$_PRESENT	FIXED BINARY(31) GLOBALREF VALUE,		/* CLI$PRESENT return status code for "explicitly present" */
CLI$_NEGATED	FIXED BINARY(31) GLOBALREF VALUE,		/* CLI$PRESENT return status code for "explicitly negated" */
NORMAL		FIXED BINARY(31) GLOBALREF,			/* MONITOR normal return status */
MRBPTR		POINTER		GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
M		POINTER		DEFINED(MRBPTR),		/* Short-hand synonym for MRBPTR */
DEF_MRBPTR	POINTER		GLOBALREF,			/* Pointer to "default" MRB (Monitor Request Block) */
MCAPTR		POINTER		GLOBALREF,			/* Pointer to MCA (Monitor Communication Area) */
MC		POINTER		DEFINED(MCAPTR),		/* Short-hand synonym for MCAPTR */
QUALPTR		POINTER		GLOBALREF,			/* Pointer to Qualifier Descriptors Block */
DEFPTR		POINTER		GLOBALREF,			/* Pointer to Qualifier Default Value Descriptors Block */
CURR_ERRCODE	FIXED BINARY(31) GLOBALREF;			/* MONITOR error status code currently expected */

Declare
INP_PTR_VOL	POINTER	GLOBALREF,				/* Pointer to volatile /INPUT file-spec */
DISP_PTR_VOL	POINTER	GLOBALREF,				/* Pointer to volatile /DISPLAY file-spec */
REC_PTR_VOL	POINTER	GLOBALREF,				/* Pointer to volatile /RECORD file-spec */
SUMM_PTR_VOL	POINTER	GLOBALREF,				/* Pointer to volatile /SUMMARY file-spec */
COMM_PTR_VOL	POINTER	GLOBALREF;				/* Pointer to volatile /COMMENT string */

Declare
INP_PTR_SWAP	BIT(1) ALIGNED GLOBALREF,			/* YES => swap INP_PTR_VOL and INP_PTR_PERM */
DISP_PTR_SWAP	BIT(1) ALIGNED GLOBALREF,			/* YES => swap DISP_PTR_VOL and DISP_PTR_PERM */
REC_PTR_SWAP	BIT(1) ALIGNED GLOBALREF,			/* YES => swap REC_PTR_VOL and REC_PTR_PERM */
SUMM_PTR_SWAP	BIT(1) ALIGNED GLOBALREF,			/* YES => swap SUMM_PTR_VOL and SUMM_PTR_PERM */
COMM_PTR_SWAP	BIT(1) ALIGNED GLOBALREF;			/* YES => swap COMM_PTR_VOL and COMM_PTR_PERM */

Declare
1 DYN_STRING	GLOBALREF,					/* Dynamic string descriptor */
  2 L		FIXED BINARY(15),				/* Length */
  2 TC		CHAR(2),					/* Type and Class */
  2 A		POINTER,					/* Address */

DYN_STRING_S	CHAR(DYN_STRING.L) BASED(DYN_STRING.A);		/* String */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL ROUTINE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CLI$GET_VALUE	ENTRY(ANY, ANY, FIXED BINARY(15))		/* CLE routine to get qualifier values */
		OPTIONS(VARIABLE) RETURNS(BIT(1)),
CLI$PRESENT	EXTERNAL ENTRY(ANY) RETURNS(FIXED BINARY(31)),	/* CLE routine to determine presence of qualifiers */
LIB$CVT_TIME	EXTERNAL ENTRY(ANY, BIT(64) ALIGNED)		/* RTL routine to convert to qword time val */
		RETURNS(BIT(1)),
STR$UPCASE	EXTERNAL ENTRY(ANY,ANY) RETURNS(BIT(1)),	/* RTL routine to upcase a string */
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE);	/* MONITOR MACRO-32 routine to log synchronous errors */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			     MESSAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MNR$_INVBTIMSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVETIMSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVINTSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVFLUSHSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVVIEWSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVINPFIL	FIXED BINARY(31) GLOBALREF VALUE;	/* Error message code */
/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		      GLOBAL STORAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
QUAL_SPECIFIED	BIT(1) ALIGNED GLOBALDEF INIT('0'B);	/* YES => at least 1 qualifier explicitly spec'd */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	SECONDS_TOK_SIZE	BY 7;		/* Size of token for seconds */
%REPLACE	TIME_TOK_SIZE		BY 40;		/* Size of token for time specs */
%REPLACE	FILE_SPEC_SIZE		BY 128;		/* Max file spec size */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
TEMP			FIXED BINARY(31),			/* Temporary "scratch" area */
CALL			FIXED BINARY(31),			/* Holds function value (return status) of called routines */ 
STATUS			BIT(1) BASED(ADDR(CALL));		/* Low-order status bit for called routines */

Declare
FILE_SPEC_PTR		POINTER,				/* Pointer to structure consisting of file-spec ... */
								/* ... string descriptor followed by string itself */
PARSED_SPEC_PTR		POINTER,				/* Pointer to structure consisting of file-spec ... */
								/* ... string descriptor followed by string itself */
COMM_STR_PTR		POINTER;				/* Pointer to structure consisting of comment ... */
								/* ... string descriptor followed by string itself */

Declare
1 FILE_SPEC	BASED(FILE_SPEC_PTR),				/* File-spec string descriptor and string */
    2 L		FIXED BINARY(31),				/* File-spec string length */
    2 A		POINTER,					/* File-spec string address */
    2 S		CHAR(FILE_SPEC_SIZE),				/* File-spec string */


1 PARSED_SPEC	BASED(PARSED_SPEC_PTR),				/* Parsed File-spec dynamic string descriptor and string */
    2 L		FIXED BINARY(15),				/* Length */
    2 T		FIXED BINARY(7),				/* Type */
    2 C		FIXED BINARY(7),				/* Class */
    2 A		POINTER,					/* Address */


1 DYN_SPEC	GLOBALDEF,					/* Dynamic File-spec string descriptor and string */
    2 L		FIXED BINARY(15),				/* Length */
    2 T		FIXED BINARY(7),				/* Type */
    2 C		FIXED BINARY(7),				/* Class */
    2 A		POINTER;					/* Address */


Declare
1 COMM_STR	BASED(COMM_STR_PTR),				/* Comment descriptor and string */
    2 L		FIXED BINARY(31),				/* Comment string length */
    2 A		POINTER,					/* Comment string address */
    2 S		CHAR(MNR_HDR$K_MAXCOMLEN);			/* Comment string */

Declare
  1 Q_VAL,							/* String descriptor for qualifier value */
    2 L			FIXED BINARY(31),			/* Length */
    2 A			POINTER,				/* Address */

  Q_VAL_TIME		CHAR(TIME_TOK_SIZE),			/* Qualifier value string for time values */
  Q_VAL_SECS		CHAR(SECONDS_TOK_SIZE+1),		/* Qualifier value string for seconds values */
  TS_LEN		FIXED BINARY(15);			/* Actual length of time spec */



QUAL_SPECIFIED = NO;							/* No qualifiers explicitly specified yet */

CALL = SYS$GETTIM(MC->MCA$Q_CURR_TIME);					/* Get current time from system */

Q_VAL.L = LENGTH(Q_VAL_TIME);						/* Set length field of descriptor */
Q_VAL.A = ADDR(Q_VAL_TIME);						/* Set address field of descriptor */

CALL = CLI$PRESENT(QUAL$L_BEG);						/* Get BEGINNING qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
  THEN
    DO;
    QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
    IF CLI$GET_VALUE(QUAL$L_BEG,Q_VAL,TS_LEN)				/* Get "BEGINNING" string and check status */
    THEN DO;								/* Value was specified */
	 Q_VAL.L = TS_LEN;						/* Pick up actual length */
	 IF Q_VAL.L > TIME_TOK_SIZE					/* Check for valid size for time spec */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVBTIMSP);				/* Log possible error */
		  RETURN(MNR$_INVBTIMSP);				/* ... and return with status */
		  END;
	 IF ^ STR$UPCASE(Q_VAL,Q_VAL)					/* Upcase and check status */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVBTIMSP);				/* Log possible error */
		  RETURN(MNR$_INVBTIMSP);				/* ... and return with status */
		  END;
	 IF ^ LIB$CVT_TIME(Q_VAL,M->MRB$Q_BEGINNING) 			/* Cvt to system time */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVBTIMSP);				/* Log possible error */
		  RETURN(MNR$_INVBTIMSP);				/* ... and return with status */
		  END;
	 END;

    ELSE								/* Value was defaulted */
	 M->MRB$Q_BEGINNING = DEF_MRBPTR->MRB$Q_BEGINNING;		/* Store the default value */
    END;

Q_VAL.L = LENGTH(Q_VAL_TIME);						/* Set length field of descriptor */

CALL = CLI$PRESENT(QUAL$L_END);						/* Get ENDING qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
  THEN
    DO;
    QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
    IF CLI$GET_VALUE(QUAL$L_END,Q_VAL,TS_LEN)				/* Get "ENDING" string and check status */
    THEN DO;								/* Value was specified */
	 Q_VAL.L = TS_LEN;						/* Pick up actual length */
	 IF Q_VAL.L > TIME_TOK_SIZE					/* Check for valid size for time spec */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVETIMSP);				/* Log possible error */
		  RETURN(MNR$_INVETIMSP);				/* ... and return with status */
		  END;
	 IF ^ STR$UPCASE(Q_VAL,Q_VAL)					/* Upcase and check status */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVETIMSP);				/* Log possible error */
		  RETURN(MNR$_INVETIMSP);				/* ... and return with status */
		  END;
	 IF ^ LIB$CVT_TIME(Q_VAL,M->MRB$Q_ENDING) 			/* Cvt to system time */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVETIMSP);				/* Log possible error */
		  RETURN(MNR$_INVETIMSP);				/* ... and return with status */
		  END;
	 END;

    ELSE								/* Value was defaulted */
	 M->MRB$Q_ENDING = DEF_MRBPTR->MRB$Q_ENDING;			/* Store the default value */
    END;

Q_VAL.L = LENGTH(Q_VAL_SECS);						/* Set length field of descriptor */
Q_VAL.A = ADDR(Q_VAL_SECS);						/* Set address field of descriptor */

CALL = CLI$PRESENT(QUAL$L_INT);						/* Get INTERVAL qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
  THEN
    DO;
    QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
    IF CLI$GET_VALUE(QUAL$L_INT,Q_VAL)					/* Get "INTERVAL" string and check status */
    THEN DO;								/* Value was specified */
             Q_VAL.L = INDEX(Q_VAL_SECS,' ') - 1;			/* Eliminate trailing blanks */
             IF Q_VAL.L <= 0						/* Check for valid size for "seconds" */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVINTSP);				/* Log possible error */
		  RETURN(MNR$_INVINTSP);				/* ... and return with status */
		  END;
	     CURR_ERRCODE = MNR$_INVINTSP;				/* Set MONITOR code in case conversion error signaled */
	     M->MRB$L_INTERVAL = BIN(SUBSTR(Q_VAL_SECS,1,Q_VAL.L),31);	/* Convert seconds to binary */
	     CURR_ERRCODE = 0;						/* Reset to default MONITOR code */
	     IF M->MRB$L_INTERVAL <= 0					/* Check for valid value */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVINTSP);				/* Log possible error */
		  RETURN(MNR$_INVINTSP);				/* ... and return with status */
		  END;
	 END;

    ELSE								/* Value was defaulted */
	 M->MRB$L_INTERVAL = DEF_MRBPTR->MRB$L_INTERVAL;		/* Store the default value */
    END;

Q_VAL.L = LENGTH(Q_VAL_SECS);						/* Set length field of descriptor */

CALL = CLI$PRESENT(QUAL$L_FLUSH);					/* Get FLUSH qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
  THEN
    DO;
    QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
    IF CLI$GET_VALUE(QUAL$L_FLUSH,Q_VAL)				/* Get "FLUSH" string and check status */
    THEN DO;								/* Value was specified */
             Q_VAL.L = INDEX(Q_VAL_SECS,' ') - 1;			/* Eliminate trailing blanks */
             IF Q_VAL.L <= 0						/* Check for valid size for "seconds" */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVFLUSHSP);				/* Log possible error */
		  RETURN(MNR$_INVFLUSHSP);				/* ... and return with status */
		  END;
	     CURR_ERRCODE = MNR$_INVFLUSHSP;				/* Set MONITOR code in case conversion error signaled */
	     M->MRB$L_FLUSH = BIN(SUBSTR(Q_VAL_SECS,1,Q_VAL.L),31);	/* Convert seconds to binary */
	     CURR_ERRCODE = 0;						/* Reset to default MONITOR code */
	     IF M->MRB$L_FLUSH <= 0					/* Check for valid value */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVFLUSHSP);				/* Log possible error */
		  RETURN(MNR$_INVFLUSHSP);				/* ... and return with status */
		  END;
	 END;

    ELSE								/* Value was defaulted */
	 M->MRB$L_FLUSH = DEF_MRBPTR->MRB$L_FLUSH;			/* Store the default value */
    END;

Q_VAL.L = LENGTH(Q_VAL_SECS);						/* Set length field of descriptor */

CALL = CLI$PRESENT(QUAL$L_VIEW);					/* Get VIEWING_TIME qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
  THEN
    DO;
    QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
    IF CLI$GET_VALUE(QUAL$L_VIEW,Q_VAL)					/* Get "VIEWING_TIME" string and check status */
    THEN DO;								/* Value was specified */
             Q_VAL.L = INDEX(Q_VAL_SECS,' ') - 1;			/* Eliminate trailing blanks */
             IF Q_VAL.L <= 0						/* Check for valid size for "seconds" */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVVIEWSP);				/* Log possible error */
		  RETURN(MNR$_INVVIEWSP);				/* ... and return with status */
		  END;
	     CURR_ERRCODE = MNR$_INVVIEWSP;				/* Set MONITOR code in case conversion error signaled */
	     M->MRB$L_VIEWING_TIME = BIN(SUBSTR(Q_VAL_SECS,1,Q_VAL.L),31); /* Convert seconds to binary */
	     CURR_ERRCODE = 0;						/* Reset to default MONITOR code */
	     IF M->MRB$L_VIEWING_TIME <= 0				/* Check for valid value */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVVIEWSP);				/* Log possible error */
		  RETURN(MNR$_INVVIEWSP);				/* ... and return with status */
		  END;
	 END;

    ELSE								/* Value was defaulted */
	 M->MRB$L_VIEWING_TIME = DEF_MRBPTR->MRB$L_VIEWING_TIME;	/* Store the default value */
    END;


CALL = CLI$PRESENT(QUAL$L_BY_NODE);					/* Get BY_NODE qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
  THEN
    DO;
    QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
    M->MRB$V_BY_NODE = YES;						/* Turn on flag in MRB */
    END;

IF CALL = CLI$_NEGATED							/* If explicitly negated, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$V_BY_NODE = NO;						/* Turn off flag in MRB */
	 END;

CALL = CLI$PRESENT(QUAL$L_INP);						/* Get INPUT qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$V_MFSUM = NO;						/* Set to NO for now (may change in BUILD_IFB_TABLE) */
	 CALL = BUILD_IFB_TABLE();					/* Build the table of Input File Blocks (IFBs) */
	 IF ^STATUS
	 THEN RETURN(CALL); 						/* return with error status, MON_ERR was already called...*/
	 END;
IF CALL = CLI$_NEGATED							/* If explicitly negated, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$V_MFSUM = NO;						/* Turn off Multi-File Summary indicator */
	 M->MRB$A_INPUT = NULL();					/* Indicate no input file */
	 END;

CALL = CLI$PRESENT(QUAL$L_DISP);					/* Get DISPLAY qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 IF DISP_PTR_VOL = NULL()					/* If no volatile file spec string area, */
	     THEN DO;
		  ALLOCATE FILE_SPEC;					/*   then get one */
		  DISP_PTR_VOL = FILE_SPEC_PTR;				/*   set up a ptr to it */
		  FILE_SPEC.L = LENGTH(FILE_SPEC.S);			/*   set length ... */
		  FILE_SPEC.A = ADDR(FILE_SPEC.S);			/*   and address in descriptor */
		  END;

	     ELSE DO;
		  FILE_SPEC_PTR = DISP_PTR_VOL;				/* Otherwise, simply point to existing one */
		  FILE_SPEC.L = FILE_SPEC_SIZE;				/* ... and re-init its length */
		  END;

	 IF CLI$GET_VALUE(QUAL$L_DISP,FILE_SPEC)			/* Qualifier value specified ? */
             THEN DO;
		  DISP_PTR_SWAP = YES;					/* Yes -- ind to SET_CMD a ptr swap is necessary */
		  TEMP = INDEX(FILE_SPEC.S,' ') - 1;			/* Find trailing blanks in value (string) */
		  IF TEMP >= 0 THEN FILE_SPEC.L = TEMP;			/* If found one, set new length */
		  M->MRB$A_DISPLAY = FILE_SPEC_PTR;			/* Store away pointer to value descr */
		  M->MRB$V_DISP_TO_FILE = YES;				/* Indicate filespec specified */
		  END;

	     ELSE DO;							/* No -- qualifier value defaulted */
		  M->MRB$A_DISPLAY = ADDR(DEF$L_DISP);			/* Store a default value descr */
		  M->MRB$V_DISP_TO_FILE = NO;				/* ... and default indicator */
		  END;

	 END;

IF CALL = CLI$_NEGATED							/* If explicitly negated, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$A_DISPLAY = NULL();					/* Indicate no display output */
	 M->MRB$V_DISP_TO_FILE = NO;					/* ...... */
	 END;

CALL = CLI$PRESENT(QUAL$L_REC);						/* Get RECORD qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 IF REC_PTR_VOL = NULL()					/* If no volatile file spec string area, */
	     THEN DO;
		  ALLOCATE FILE_SPEC;					/*   then get one */
		  REC_PTR_VOL = FILE_SPEC_PTR;				/*   set up a ptr to it */
		  FILE_SPEC.L = LENGTH(FILE_SPEC.S);			/*   set length ... */
		  FILE_SPEC.A = ADDR(FILE_SPEC.S);			/*   and address in descriptor */
		  END;

	     ELSE FILE_SPEC_PTR = REC_PTR_VOL;				/* Otherwise, simply point to existing one */

	 IF CLI$GET_VALUE(QUAL$L_REC,FILE_SPEC)				/* Qualifier value specified ? */
             THEN DO;
		  REC_PTR_SWAP = YES;					/* Yes -- ind to SET_CMD a ptr swap is necessary */
		  M->MRB$A_RECORD = FILE_SPEC_PTR;			/* Store away pointer to string descr */
		  END;

             ELSE M->MRB$A_RECORD = ADDR(DEF$L_REC);			/* No -- store a default value */

	 END;

IF CALL = CLI$_NEGATED							/* If explicitly negated, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$A_RECORD = NULL();					/* Indicate no record output */
	 END;

CALL = CLI$PRESENT(QUAL$L_SUMM);					/* Get SUMMARY qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 IF SUMM_PTR_VOL = NULL()					/* If no volatile file spec string area, */
	     THEN DO;
		  ALLOCATE FILE_SPEC;					/*   then get one */
		  SUMM_PTR_VOL = FILE_SPEC_PTR;				/*   set up a ptr to it */
		  FILE_SPEC.L = LENGTH(FILE_SPEC.S);			/*   set length ... */
		  FILE_SPEC.A = ADDR(FILE_SPEC.S);			/*   and address in descriptor */
		  END;

	     ELSE FILE_SPEC_PTR = SUMM_PTR_VOL;				/* Otherwise, simply point to existing one */

	 IF CLI$GET_VALUE(QUAL$L_SUMM,FILE_SPEC)			/* Qualifier value specified ? */
             THEN DO;
		  SUMM_PTR_SWAP = YES;					/* Yes -- ind to SET_CMD a ptr swap is necessary */
		  M->MRB$A_SUMMARY = FILE_SPEC_PTR;			/* Store away pointer to string descr */
		  END;

             ELSE M->MRB$A_SUMMARY = ADDR(DEF$L_SUMM);			/* No -- store a default value */

	 END;

IF CALL = CLI$_NEGATED							/* If explicitly negated, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$A_SUMMARY = NULL();					/* Indicate no summary output */
	 END;

CALL = CLI$PRESENT(QUAL$L_COMM);					/* Get COMMENT qualifier presence indicator */
IF CALL = CLI$_PRESENT							/* If explicitly present, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 IF COMM_PTR_VOL = NULL()					/* If no volatile comment string area, */
	     THEN DO;
		  ALLOCATE COMM_STR;					/*   then get one ... */
		  COMM_PTR_VOL = COMM_STR_PTR;				/*   and set up a ptr to it */
		  END;

	     ELSE COMM_STR_PTR = COMM_PTR_VOL;				/* Otherwise, simply point to existing one */

	 IF CLI$GET_VALUE(QUAL$L_COMM,DYN_STRING)			/* Qualifier value specified ? */
             THEN DO;
		  COMM_STR.S = DYN_STRING_S;				/* Yes -- move string out of dyn area */
		  COMM_STR.L = DYN_STRING.L;				/* ... and set up its length */
		  COMM_STR.A = ADDR(COMM_STR.S);			/* ... and address */
		  COMM_PTR_SWAP = YES;					/* Ind to SET_CMD a ptr swap is necessary */
		  M->MRB$A_COMMENT = COMM_STR_PTR;			/* Store away pointer to string descr */
		  END;

             ELSE M->MRB$A_COMMENT = NULL();				/* No -- store a default value */

	 END;

IF CALL = CLI$_NEGATED							/* If explicitly negated, */
    THEN DO;
	 QUAL_SPECIFIED = YES;						/* Indicate qualifier explicitly specified */
	 M->MRB$A_COMMENT = NULL();					/* Indicate no comment string */
	 END;

RETURN(NORMAL);								/* Return with status */

BUILD_IFB_TABLE: Procedure Returns(Fixed Binary(31));

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	BUILD_IFB_TABLE
/*
/*	This routine builds the IFB (Input File Block) TABLE.
/*	In addition, it sets up MRB$A_INPUT to point to the IFB TABLE, and
/*	sets up MRB$B_INP_FILES to be the number of input files described by
/*	the table.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	IFB_TABLE, MRB
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	IFB_TABLE built, MRB$A_INPUT and MRB$B_INP_FILES estblished.
/*
/* ROUTINE VALUE:
/*
/*	Normal, or bad status from LIB$FIND_FILE
/*
/* SIDE EFFECTS:
/*
/*	None
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		      GLOBAL STORAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MAX_INP_FILES		FIXED BINARY(31) GLOBALDEF VALUE INIT(125); /* Max no. of input files for multi-file summary */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),
							/* Routine to log synchronous errors */
DSC$K_DTYPE_T	FIXED BINARY(15) GLOBALREF VALUE,	/* String  descr. type */
DSC$K_CLASS_D	FIXED BINARY(15) GLOBALREF VALUE,	/* Dynamic descr. class */
SS$_NORMAL	FIXED BINARY(31) GLOBALREF VALUE,	/* System normal return status */
RMS$_EOF	FIXED BINARY(31) GLOBALREF VALUE,	/* RMS end-of-file return status */
RMS$_NMF	FIXED BINARY(31) GLOBALREF VALUE,	/* RMS no-more-files message for wildcard parsing */
RMS$_FNF	FIXED BINARY(31) GLOBALREF VALUE,	/* RMS file-not-found message */
MNR$_OPENIN	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_TOOMNYFILES FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
LIB$FIND_FILE	EXTERNAL ENTRY(ANY,ANY,ANY,ANY,ANY,ANY,ANY)	/* RTL routine to parse a wildcard spec*/
		OPTIONS(VARIABLE) RETURNS(FIXED BINARY(31)),
LIB$FIND_FILE_END EXTERNAL ENTRY(ANY),			/* RTL routine to end wildcard spec parse*/
LIB$SCOPY_DXDX  EXTERNAL ENTRY(ANY,ANY),		/* RTL string copy routine */
IFB_TAB_VOL	POINTER	GLOBALREF,			/* Pointer to volatile IFB_TABLE */
IFB_TAB_SWAP	BIT(1) ALIGNED GLOBALREF;		/* YES => swap IFB_TAB_VOL and IFB_TAB_PERM */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
USER_FLAGS	FIXED BINARY(31) INIT(2),			/* Flag indicating "stickiness desired" */
CONTEXT		FIXED BINARY(31),
CALL		FIXED BINARY(31),				/* Holds function value (return status) of called routines */ 
STATUS		BIT(1) BASED(ADDR(CALL)),			/* Low-order status bit for called routines */
FIND_FILE_CALL	FIXED BINARY(31),				/* Holds function value (return status) of LIB$FIND_FILE */ 
FIND_FILE_STAT	BIT(1) BASED(ADDR(FIND_FILE_CALL)),		/* Low-order status bit for LIB$FIND_FILE */
SPEC_LEN	FIXED BINARY(15),				/* Input filespec length */
I		FIXED BINARY(7),				/* Loop control */
VALUE_FOUND	BIT(1) ALIGNED,					/* YES => a value for the /INPUT qualifier found */
IFBPTR		POINTER,					/* Pointer to Input File Block (IFB) */
IFB_TAB_PTR	POINTER;					/* Pointer to IFB_TABLE */

Declare
1 IFB_TABLE	BASED(IFB_TAB_PTR),				/* Input File Block (IFB) Table */
  2 AN_IFB	(1:MAX_INP_FILES+1)  CHAR(IFB$K_SIZE);		/* A single IFB */

Declare
REC_DEF_S	CHAR(DEF$L_REC) BASED(DEF$A_REC);		/* String for default recording file spec */


IF IFB_TAB_VOL = NULL()						/* If no volatile IFB table, */
    THEN DO;
	 ALLOCATE IFB_TABLE;					/*   then get one */
	 IFB_TAB_VOL = IFB_TAB_PTR;				/*   set up a ptr to it */
	 DO I = 1 TO MAX_INP_FILES + 1;				/*   clear entire */
	 UNSPEC(AN_IFB(I)) = '0'B;				/*   array to */
	 END;							/*   zeroes */
	 END;

    ELSE IFB_TAB_PTR = IFB_TAB_VOL;				/* Otherwise, simply point to existing one */

/*
/*	NOTE -- at this point, the volatile pointer (IFB_TAB_VOL) and the base
/*		pointer (IFB_TAB_PTR) both point to the IFB_TABLE in use.
/*/
M->MRB$B_INP_FILES = 0;					/* Start off loop with no input files */
VALUE_FOUND = YES;					/* ... and assume a qualifier value (file spec) found */
CALL = SS$_NORMAL;					/* Init main loop status */
I = 1;							/* Init input file counter */
CONTEXT = 0;						/* init CONTEXT */
/*
/*	NOTE -- What follows are two loops - the outer loop does CLI$GET_VALUE calls, and the inner loop does 
/*	        LIB$FIND_FILE calls. The CLI$GET_VALUE loop is controlled by STATUS, which is the low bit of CALL, and
/*		also by VALUE_FOUND. CALL will always be SS$_NORMAL unless the LIB$FIND_FILE loop runs into trouble.
/*		CALL is what is ultimately returned by this procedure.
/*/
DO WHILE(STATUS & VALUE_FOUND);				/* Begin CLI$GET_VALUE loop */
   FIND_FILE_CALL = SS$_NORMAL;				/* init FIND_FILE status */
   DYN_SPEC.T = DSC$K_DTYPE_T;				/* Init  str. descr. type */
   DYN_SPEC.C = DSC$K_CLASS_D;				/* dynamic class */
   IF ^CLI$GET_VALUE(QUAL$L_INP,DYN_SPEC)		/* File spec specified ? */
   THEN DO;						/* no filespec specified with qualifier */
	IF M->MRB$B_INP_FILES = 0			/* If first time around */
	THEN CALL LIB$SCOPY_DXDX(DEF$L_REC,DYN_SPEC);	/* use default filespec */
	ELSE VALUE_FOUND = NO;				/* else indicate no more filespecs to skip LIB$FIND_FILE loop */
	END;
   DO WHILE(STATUS & FIND_FILE_STAT & VALUE_FOUND); 	/* Begin LIB$FIND_FILE loop */
      IFBPTR = ADDR(AN_IFB(I));				/* Address an IFB */
      IF IFB$A_INPUT = NULL()				/* If not pointing to a file-spec yet, */
      THEN DO;
	   ALLOCATE PARSED_SPEC;			/*   allocate space for result */
	   IFB$A_INPUT = PARSED_SPEC_PTR;		/*   set up a ptr to it */
	   PARSED_SPEC.T = DSC$K_DTYPE_T;		/*   str. descr. type */
	   PARSED_SPEC.C = DSC$K_CLASS_D;		/*   dynamic class */
	   PARSED_SPEC.A = NULL();			/*   make sure length, */
	   PARSED_SPEC.L = 0;				/*   and address are 0 */
	   END;
      ELSE PARSED_SPEC_PTR = IFB$A_INPUT;		/* Otherwise, simply point to existing one */
      FIND_FILE_CALL=LIB$FIND_FILE(DYN_SPEC,PARSED_SPEC,CONTEXT,DEF$L_REC,,,USER_FLAGS); /* Get the next full file spec */
      IF FIND_FILE_STAT						/* Did we get another valid filespec? */
	 THEN DO;
	      M->MRB$B_INP_FILES = M->MRB$B_INP_FILES + 1;	/* Yes -- count it */
	      IF I > MAX_INP_FILES				/* If we have exceeded the max. allowed # of input files */
		THEN DO;
		     CALL MON_ERR(MNR$_TOOMNYFILES);		/* then log the error */
		     CALL = MNR$_TOOMNYFILES;			/* set bad status to end both inner and outer loops */
		     END;
   		     ELSE I = I + 1;				/*...else increment file count and continue the loop */
	      END;
   END;								/* end of LIB$FIND_FILE loop */
   IF (^FIND_FILE_STAT & FIND_FILE_CALL ^= RMS$_NMF)		/* "no-more-files" is the only valid error from LIB$FIND_FILE */
	THEN DO;						/* ...any other status means trouble (such as file not found) */
	     CALL MON_ERR(MNR$_OPENIN,FIND_FILE_CALL,PARSED_SPEC);/* log error */
             CALL = MNR$_OPENIN;				/* set bad status to end both the inner and outer loop*/
	     END;
END;								/* End of CLI$GET_VALUE loop */
   CALL LIB$FIND_FILE_END(CONTEXT);				/* wipe out context of prev LIB$FIND_FILE calls */
IFB_TAB_SWAP = YES;						/* Ind to SET_CMD a ptr swap is necessary */
M->MRB$A_INPUT = IFB_TAB_PTR;					/* Store ptr to IFB table */
IF M->MRB$B_INP_FILES > 1  THEN M->MRB$V_MFSUM = YES;		/* If more than 1 file spec, indicate multi-file summary */

RETURN (CALL);							/* Return to caller */

END BUILD_IFB_TABLE;

END GET_QUALIFIERS;

GET_CLASSES: Procedure (AT_LEAST_ONE_CLASS) Returns(Fixed Binary(31));

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	GET_CLASSES
/*
/*	Communicate with CLE to get class_name keywords; then use keywords as
/*	input to LOOKUP_KEY and get back class numbers. Ultimate output is
/*	MRB$O_CLASSBITS, a bit string for which each bit number corresponds
/*	to class number. If a lookup error is found, bad status is returned
/*	to the issuer.
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
AT_LEAST_ONE_CLASS	BIT(1) ALIGNED,				/* YES => user requested at least one class */
CALL			FIXED BINARY(31),			/* Holds function value (return status) of called routines */ 
STATUS			BIT(1) BASED(ADDR(CALL)),		/* Low-order status bit for called routines */
CLASS_KEY		FIXED BINARY(31) STATIC,		/* Class keyword number */
								/* Note -- must be STATIC to get error msg */
TEMP			FIXED BINARY(31);			/* Scratch "register" */


%REPLACE	NOT_SUCCESSFUL		BY '0'B;		/* Failing severity code */
%REPLACE	CLASS_TOK_SIZE 		BY 20;			/* Size of token for class-name */
%REPLACE	OR_OP			BY '0111'B;		/* OR Boolean operation */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
CLI$GET_VALUE	ENTRY(ANY, ANY)					/* CLE routine to get qualifier values */
		RETURNS(BIT(1)),
LIB$LOOKUP_KEY	EXTERNAL ENTRY(ANY, ANY, FIXED BINARY(31))	/* RTL rtn to look up class-names in a table */
		RETURNS(BIT(1)),
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE);	/* MONITOR MACRO-32 routine to log synchronous errors */

Declare
I		FIXED BINARY(7),				/* Loop control */
MAX_CLASS_NO	FIXED BINARY(31) GLOBALREF VALUE,		/* Maximum defined class number */
ALL_CLSNO	FIXED BINARY(31) GLOBALREF VALUE,		/* ALL class Pseudo class number */
ALL_CLASS_FOUND	BIT(1),						/* Flag to indicate ALL class found on command line */
MNR$_INVCLSNM	FIXED BINARY(31) GLOBALREF VALUE,		/* Error message code */
NORMAL		FIXED BINARY(31) GLOBALREF,			/* MONITOR normal return status */
CDBPTR		POINTER		GLOBALREF,			/* Pointer to CDB (Class Descriptor Block) */
C		POINTER		DEFINED(CDBPTR),		/* Short-hand synonym for CDBPTR */
MRBPTR		POINTER		GLOBALREF,			/* Pointer to MRB (Monitor Request Block) */
M		POINTER		DEFINED(MRBPTR),		/* Short-hand synonym for MRBPTR */
QUALPTR		POINTER		GLOBALREF;			/* Pointer to Qualifier Descriptors Block */

Declare
1 CDBHEAD GLOBALREF,						/* Table of CDB's */
  2 CDBLOCK (0:127) CHAR(CDB$K_SIZE);

Declare
CLASSTABLE  	CHAR(1)		GLOBALREF;			/* Table of class names & numbers (dummy) */
								/* Note -- CLASSTABLE is declared here simply */
								/*   so its address can be referenced below */

Declare
REQUEST_CLASS_MASK	BIT(MAX_CLASS_NO+1),		/* Requested classes have bits on */
REQUEST_CLASS_VEC	(0:MAX_CLASS_NO) BIT(1) DEFINED(REQUEST_CLASS_MASK);
							/* Alias for REQUEST_CLASS_MASK, but bit-addressable */

Declare
01 CLASS_VAL STATIC,					/* String descr for value of CLASS_NAME qualifier */
							/* Note -- must be STATIC to get INVCLSNM msg */
    02 L		FIXED BINARY(31),		/* Length */
    02 A		POINTER,			/* Address */
    02 S		CHAR(CLASS_TOK_SIZE+1);		/* String */


CLASS_VAL.L = LENGTH(CLASS_VAL.S);			/* Init length longword of descr */
CLASS_VAL.A = ADDR(CLASS_VAL.S);			/* Init address longword of descr */

REQUEST_CLASS_MASK = '0'B;				/* Turn off all class bits initially */
ALL_CLASS_FOUND = NO;					/* Assume we won't find ALL pseudo-class on this command line */
DO WHILE(CLI$GET_VALUE(QUAL$L_CLASS,CLASS_VAL));	/* Loop once for each requested class */
    CLASS_VAL.L = INDEX(CLASS_VAL.S,' ') - 1;		/* Now strip off trailing blanks */
    IF CLASS_VAL.L < 0 THEN CLASS_VAL.L = CLASS_TOK_SIZE; /* If too long, replace with max token size */

    IF ^ LIB$LOOKUP_KEY(CLASS_VAL,CLASSTABLE,CLASS_KEY)	/* Get class keyword number */
	THEN DO;
	     CALL MON_ERR(MNR$_INVCLSNM,,CLASS_VAL); 	/* Log error if bad class name */
	     RETURN(MNR$_INVCLSNM);			/* ... and return with status */
	     END;
    CLASS_VAL.L = CLASS_TOK_SIZE + 1;			/* Restore string len for next loop */
    IF CLASS_KEY = ALL_CLSNO				/* If all classes  */
	THEN DO;
	     ALL_CLASS_FOUND = YES;			/* inidicate we found ALL on this command line */
	     M->MRB$V_ALL_CLASS = YES;			/* indicate its ALL class*/
	     	DO I = 0 TO MAX_CLASS_NO;		/* Loop once for each possible class */
             	REQUEST_CLASS_VEC(I) = YES;		/* Turn on bit for this class */
		CDBPTR = ADDR(CDBLOCK(I));		/* Get CDB addressability */
		IF C->CDB$V_DISABLE THEN REQUEST_CLASS_VEC(I) = NO; /* If this class disabled, then ignore it */
	    	END;
	     END;
        ELSE REQUEST_CLASS_VEC(CLASS_KEY) = YES;	/* Turn on bit for this class */
    CDBPTR = ADDR(CDBLOCK(CLASS_KEY));			/* Get CDB addressability */
    IF C->CDB$V_DISABLE					/* If this class disabled, */
	THEN REQUEST_CLASS_VEC(CLASS_KEY) = NO;		/*   then ignore it */
	ELSE DO;					/* Otherwise, */
	     CALL = GET_CLASS_QUALS(CLASS_KEY);		/* Process class qualifiers for this class */
	     IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* ... and check status */
	     END;
END;

IF INDEX(REQUEST_CLASS_MASK,'1'B) ^= 0			/* If any classes specified, */
    THEN DO;
	 AT_LEAST_ONE_CLASS = YES;			/* indicate got at least one */
	 IF ALL_CLASS_FOUND = NO			/* if we didn't find the ALL pseudo-class */
	 THEN  M->MRB$V_ALL_CLASS = NO;			/* ...make sure the ALL class flag is clear (this logic is necessary */
							/* for defaulting to work correctly in interactive mode) */
         M->MRB$O_CLASSBITS = REQUEST_CLASS_MASK;	/* ... move selected bits */
	 END;
    ELSE DO;						/* No classes specified, use MRB$O_CLASSBITS */
	 IF INDEX(M->MRB$O_CLASSBITS,'1'B) = 0			/* If no classes specified there, */
	     THEN AT_LEAST_ONE_CLASS = NO;			/*   then indicate so */
	     ELSE AT_LEAST_ONE_CLASS = YES;			/*   else indicate got one or more */
	 END;

RETURN(NORMAL);						/* Return to caller */


GET_CLASS_QUALS: Procedure (CLSNO) Returns (fixed binary(31));

Declare
CLI$PRESENT	ENTRY(ANY) RETURNS(BIT(1)),			/* CLE routine to determine presence of quals */
CLI$GET_VALUE	ENTRY(ANY, ANY, FIXED BINARY(15))		/* CLE routine to get qualifier values */
		RETURNS(BIT(1));

Declare
MNR$_QUALINV	FIXED BINARY(31) GLOBALREF VALUE,		/* Error message code */
MNR$_SQUALERR	FIXED BINARY(31) GLOBALREF VALUE,		/* Error message code */
MNR$_PDQUALERR	FIXED BINARY(31) GLOBALREF VALUE,		/* Error message code */
MNR$_INVITEMNM	FIXED BINARY(31) GLOBALREF VALUE;		/* Error message code */

Declare
MODES_CLSNO	FIXED BINARY(31) GLOBALREF VALUE;		/* MODES class number */

Declare
TEMP_CDBPTR		POINTER	;				/* tmp pointer for ALL class qualifier loop*/

Declare
1 CLASSTABLE  GLOBALREF,					/* Table of class names & numbers */
  2 VECTOR_CT	FIXED BINARY(31),				/* Count of longwords following in table */
  2 CL_DESCR (0:127),
    3 CL_PTR	POINTER,					/* Pointer to class cstring */
    3 CL_NO	FIXED BINARY(31);				/* Class number */

Declare
1 STAT_TABLE	GLOBALREF,					/* Table of pointers to str descrs for statistic qualifiers */
  2 STAT_DESC 	(0:STATS-1) POINTER;

Declare
1 PROCD_TABLE	GLOBALREF,					/* Table of ptrs to str descrs for PROCESSES display qualifiers */
  2 PROCD_DESC 	(0:PROCDISPS-1) POINTER;

Declare
I		FIXED BINARY(7),				/* Loop control */
J		FIXED BINARY(7),				/* Loop control */
QUAL_FOUND	BIT(1) ALIGNED,					/* NO => haven't seen a qualifier yet */
CLSNO		FIXED BINARY(31),				/* Class number */
QD		CHAR(8) BASED,					/* Dummy qualifier string descr */
CLSTR		CHAR(1) BASED;					/* Dummy first char of class cstring */

%REPLACE	ITEM_TOK_SIZE 		BY 25;			/* Size of token for item name */

Declare
REQUEST_ITEM_MASK	BIT(16),				/* Requested items have bits on */
REQUEST_ITEM_VEC	(0:15) BIT(1) DEFINED(REQUEST_ITEM_MASK);
								/* Alias for REQUEST_ITEM_MASK, but bit-addressable */

Declare
01 ITEM_VAL STATIC,						/* String descr for value of /ITEM qualifier */
								/* Note -- must be STATIC to get INVITEMNM msg */
    02 L		FIXED BINARY(31),			/* Length */
    02 A		POINTER,				/* Address */
    02 S		CHAR(ITEM_TOK_SIZE);			/* String */

Declare
IVAL_LEN		FIXED BINARY(15),			/* Actual length of item value string */
ITEM_LTAB		FIXED BINARY(31) BASED,			/* Dummy first longword of item lookup table */
ITEM_KEY		FIXED BINARY(31);			/* Item keyword number */
								/* Note -- must be STATIC to get error msg */



/*
/*	NOTE -- CDBPTR (and its synonym C) has been set up by caller.
/*/

/*
/*	Check for the presence of each of the statistics qualifiers
/*	(ALL, CUR, AVE, MIN, MAX). If specified for the non-standard
/*	class (PROCESSES), or if more than one specified, log error
/*	and return.
/*/

QUAL_FOUND = NO;						/* Indicate no statistics qualifiers found yet */

DO I = 0 TO STATS-1;						/* Loop for each stat qual for this class */

IF CLI$PRESENT(STAT_DESC(I)->QD)				/* If this stat qual is present, */
    THEN IF C->CDB$V_STD = NO					/* Check if non-standard class */
	     THEN DO;						/* Non-STD -- stat quals not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,STAT_DESC(I)->QD,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);						     /* ... and return with status */
		  END;
	     ELSE IF QUAL_FOUND = NO				/* STD class -- If we haven't seen a qual yet, */
		      THEN DO;
			   QUAL_FOUND = YES;			/* Indicate we found one this time */
			   IF CLSNO = ALL_CLSNO 		/* If ALL classes  */
		           THEN DO J = 1 TO MAX_CLASS_NO;	/* Loop once for each possible class */
				IF C->CDB$V_STD = YES		/* If this is a standard class */
			   	THEN DO;
				     TEMP_CDBPTR = ADDR(CDBLOCK(J));		/* ... Get CDB addressability */
				     TEMP_CDBPTR->CDB$B_ST = I;			/* ... and move in the requested stat code */
				     TEMP_CDBPTR->CDB$V_EXPLIC = YES;		/* ... also indicate explicit qualifier */
				     END;
				 END;				/* End ALL classes logic */
			   C->CDB$B_ST = I;     		/* Move in the requested stat code */
			   C->CDB$V_EXPLIC = YES;		/* Indicate a class qualifier explicitly specified */
			   END;
		      ELSE DO;					/* We've seen a stat qual for this class already */
			   CALL MON_ERR(MNR$_SQUALERR,,CL_PTR(CLSNO)->CLSTR); /* Log an error */
			   RETURN(MNR$_SQUALERR);			      /* Return with status */
			   END;
END;

/*
/*	Check for the presence of each of the PROCESSES display qualifiers
/*	(TOPCPU, TOPFAULT, TOPDIO, TOPBIO). If specified for a standard
/*	class, or if more than one specified, log error and return.
/*/

QUAL_FOUND = NO;						/* Indicate no PROCESSES qualifiers found yet */

DO I = 0 TO PROCDISPS-1;					/* Loop for each PROCESSES qualifier */

IF PROCD_DESC(I) ^= NULL() &					/* If this proc qual is defined ... */
   CLI$PRESENT(PROCD_DESC(I)->QD)				/* ... AND it is present, */
    THEN IF C->CDB$V_STD = YES					/* Check if standard class */
	     THEN DO;						/* STD class -- proc quals not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,PROCD_DESC(I)->QD,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);						     /* ... and return with status */
		  END;
	     ELSE IF QUAL_FOUND = NO				/* Non-STD class -- If we haven't seen a qual yet, */
		      THEN DO;
			   QUAL_FOUND = YES;			/* Indicate we found one this time */
			   C->CDB$B_ST = I;			/* ... and move in the requested display type */
			   END;
		      ELSE DO;					/* We've seen a proc qual for this class already */
			   CALL MON_ERR(MNR$_PDQUALERR,,CL_PTR(CLSNO)->CLSTR); /* Log an error */
			   RETURN(MNR$_PDQUALERR);			      /* Return with status */
			   END;
END;

/*
/*	Check for the presence of the /ITEM class qualifier. If present,
/*	call CLI$GET_VALUE in a loop to obtain the requested item keywords.
/*	Then call LIB$LOOKUP_KEY to get numerical bit values for the keywords
/*	and set the bits (in CDX$W_IBITS) corresponding to the bit values.
/*/

IF CLI$PRESENT(QUAL$L_ITEM)					/* If /ITEM qual is present, */
    THEN IF C->CDB$V_HOMOG = NO					/* Check if homogeneous class */
	     THEN DO;						/* Not homog -- /ITEM qual not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,QUAL$L_ITEM,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);						/* ... and return with status */
		  END;

	     ELSE DO;						/* Homog class -- loop picking up items */
		  ITEM_VAL.L = LENGTH(ITEM_VAL.S);		/* Init length longword of descr */
		  ITEM_VAL.A = ADDR(ITEM_VAL.S);		/* Init address longword of descr */
		  REQUEST_ITEM_MASK = '0'B;			/* Turn off all item bits initially */

		  DO WHILE(CLI$GET_VALUE(QUAL$L_ITEM,ITEM_VAL,IVAL_LEN)); /* Loop once for each requested item */
		      ITEM_VAL.L = IVAL_LEN;			/* Get actual string length */

		      IF ^ LIB$LOOKUP_KEY(ITEM_VAL,C->CDB$A_CDX->CDX$A_ILOOKTAB->ITEM_LTAB,ITEM_KEY)
			  THEN DO;				/* Get item keyword number */
			       CALL MON_ERR(MNR$_INVITEMNM,,ITEM_VAL); 	/* Log error if bad item name */
			       RETURN(MNR$_INVITEMNM);			/* ... and return with status */
			       END;

			  ELSE DO;				/* Found value for item keyword */
			       REQUEST_ITEM_VEC(ITEM_KEY) = YES; /* Turn on bit for this item */
			       ITEM_VAL.L = LENGTH(ITEM_VAL.S);	/* Restore string len for next loop */
			       END;

		  END;						/* End of DO WHILE loop */

		  IF INDEX(REQUEST_ITEM_MASK,'1'B) ^= 0		/* If any items specified, */
		      THEN C->CDB$A_CDX->CDX$W_IBITS = REQUEST_ITEM_MASK; /* ... move them into the CDX */

		  END;

/*
/*	The following Begin-End group sets the CDB$V_PERCENT and CDB$V_CPU bits to
/*	the proper states, depending on the specifications of the /[NO]PERCENT and
/*	/[NO]CPU qualifiers.
/*/

BEGIN;
Declare
CLI$PRESENT	EXTERNAL ENTRY(ANY) RETURNS(FIXED BINARY(31)),	/* CLE routine to determine presence of qualifiers */
CLI$_LOCNEG	FIXED BINARY(31)    GLOBALREF VALUE;		/* CLI$PRESENT return status code for "explicitly negated" */

/*
/*	Check for presence of /[NO]PERCENT qualifier
/*/

CALL = CLI$PRESENT(QUAL$L_PCENT);				/* Get "present" indicators for /PERCENT */
IF STATUS							/* If present, */
    THEN IF C->CDB$V_UNIFORM					/* If uniform (/PERCENT allowed for unif only) */
	     THEN C->CDB$V_PERCENT = YES;			/* ... then indicate percent stats */
	     ELSE DO;
		  CALL MON_ERR(MNR$_QUALINV,,QUAL$L_PCENT,CL_PTR(CLSNO)->CLSTR); /* ... otherwise, log an error */
		  RETURN(MNR$_QUALINV);					       /* ... and return with status */
		  END;
    ELSE IF CALL = CLI$_LOCNEG THEN C->CDB$V_PERCENT = NO;	/* IF /PERCENT explicitly negated, turn it off */

/*
/*	Now check for presence of /[NO]CPU qualifier
/*/

CALL = CLI$PRESENT(QUAL$L_CPU);					/* Get "present" indicators for /CPU */
IF STATUS							/* If present, */
    THEN IF CLSNO = MODES_CLSNO					/* If MODES class, */
	     THEN C->CDB$V_CPU = YES;				/* ... indicate CPU-specific display */
	     ELSE DO;						/* Otherwise, /CPU is not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,QUAL$L_CPU,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);					     /* ... and return with status */
		  END;
    ELSE IF CALL = CLI$_LOCNEG THEN C->CDB$V_CPU = NO;		/* IF /CPU explicitly negated, turn it off */

END;								/* Terminate Begin-End group */

RETURN(NORMAL);

END GET_CLASS_QUALS;

END GET_CLASSES;

MONITOR_CMD: Procedure Returns (Fixed Binary(31));		/* Routine to execute a MONITOR subcommand */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MONITOR_CMD
/*
/*	TBS
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  CALL			FIXED BINARY(31),			/* Holds function value (return status) of called routines */ 
  STATUS		BIT(1) BASED(ADDR(CALL)),		/* Low-order status bit for called routines */
  AT_LEAST_ONE_CLASS	BIT(1) ALIGNED,				/* YES => user requested at least one class */
  IFBPTR		POINTER;				/* Pointer to Input File Block (IFB) */


%REPLACE 		NOT_SUCCESSFUL		BY '0'B;	/* Failing severity code */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),	/* MONITOR MACRO-32 routine to log synchronous errors */
MOVE_CLASS_QUALS ENTRY (FIXED BINARY(7))			/* MACRO-32 routine to move class ... */
		 RETURNS(FIXED BINARY(31)),			/* ... qualifier values for all classes */
GET_CLASSES	ENTRY (BIT(1) ALIGNED) RETURNS(FIXED BINARY(31)), /* Routine to get info on all classes for this request */
GET_QUALIFIERS	ENTRY RETURNS(FIXED BINARY(31)),		/* Routine to store qualifier info for this request */
EXECUTE_REQUEST	ENTRY RETURNS(FIXED BINARY(31)),		/* Routine to execute a single MONITOR request */
MFSUM_REQUEST	ENTRY RETURNS(FIXED BINARY(31));		/* Routine to execute a single MONITOR request with a M.F. Summary*/

Declare
  MNR$_NOCLASSES FIXED BINARY(31) GLOBALREF VALUE,		/* Message code */
  CUR_TO_ACT	FIXED BINARY(31) GLOBALREF VALUE,		/* Code value for MOVE_CLASS_QUALS rtn */
  ALL_TO_ACT	FIXED BINARY(31) GLOBALREF VALUE,		/* Code value for MOVE_CLASS_QUALS rtn */
  MRBPTR	POINTER GLOBALREF,				/* Pointer to MRB (Monitor Request Block) */
  M		POINTER DEFINED(MRBPTR),			/* Short-hand synonym for MRBPTR */
  CURR_MRBPTR	POINTER GLOBALREF,				/* Pointer to "current" MRB (Monitor Request Block) */
  ACT_MRBPTR	POINTER GLOBALREF,				/* Pointer to "active" MRB (Monitor Request Block) */
  FIRST_MON_CMD	BIT(1) ALIGNED GLOBALREF,			/* YES => first MONITOR (DCL-level) cmd executing */
  QUAL_SPECIFIED BIT(1) ALIGNED GLOBALREF,			/* YES => at least 1 qualifier explicitly specified */
  PROMPT	BIT(1) ALIGNED GLOBALREF;			/* YES => prompt user for another subcommand */

CALL = MOVE_CLASS_QUALS(CUR_TO_ACT);				/* Move current class qual values to active */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  		/* Return if bad status */
ACT_MRBPTR->MRB = CURR_MRBPTR->MRB;				/* Move current MRB to active MRB */
MRBPTR = ACT_MRBPTR;						/* Make all MRB refs refer to "active" MRB */
CALL = GET_CLASSES(AT_LEAST_ONE_CLASS);				/* Get info on requested classes */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  		/* Return if bad status */
CALL = GET_QUALIFIERS();					/* Get the MONITOR command qualifiers */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  		/* Return if bad status */

IF AT_LEAST_ONE_CLASS						/* If at least one class requested, */
    THEN
	 IF M->MRB$V_MFSUM					/* If this is a multi-file summary request, */
	     THEN CALL = MFSUM_REQUEST();			/* Call special REQUEST routine for m.f. summary */
	     ELSE DO;						/* Regular MONITOR request */
		  IF M->MRB$A_INPUT ^= NULL()			/* If it's a playback, */
		      THEN DO;
			   IFBPTR = M->MRB$A_INPUT;		/* Make MRB$A_INPUT point to a */
			   M->MRB$A_INPUT = IFB$A_INPUT;	/* ... file descr instead of an IFB */
			   END;

		  IF M->MRB$A_SUMMARY ^= NULL()			/* If summary requested, */
		      THEN DO;
			   CALL = MOVE_CLASS_QUALS(ALL_TO_ACT);		  /* Force ALL stat value to active */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* Return if bad status */
			   END;

		  CALL = EXECUTE_REQUEST();			/* Execute the MONITOR request */
		  END;
    ELSE							/* Otherwise, no classes requested, */
	  IF FIRST_MON_CMD = YES & QUAL_SPECIFIED = NO		/* Check for bare MONITOR cmd at DCL */
	      THEN PROMPT = YES;				/* If so, user wants to go interactive */
	      ELSE DO;						/* MONITOR cmd issued without classes */
		   CALL MON_ERR(MNR$_NOCLASSES);		/* This is an error ... log it */
		   RETURN(MNR$_NOCLASSES);			/* ... and return */
		   END;
RETURN (CALL);							/* Return with status code */

END MONITOR_CMD;

SET_CMD: Procedure Returns (Fixed Binary(31));			/* Routine to execute a SET subcommand */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	SET_CMD
/*
/*	TBS
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/


%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

%REPLACE 		NOT_SUCCESSFUL		BY '0'B;	/* Failing severity code */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
INP_PTR_VOL	POINTER	GLOBALDEF	INIT(NULL()),		/* Pointer to volatile /INPUT file-spec */
DISP_PTR_VOL	POINTER	GLOBALDEF	INIT(NULL()),		/* Pointer to volatile /DISPLAY file-spec */
REC_PTR_VOL	POINTER	GLOBALDEF	INIT(NULL()),		/* Pointer to volatile /RECORD file-spec */
SUMM_PTR_VOL	POINTER	GLOBALDEF	INIT(NULL()),		/* Pointer to volatile /SUMMARY file-spec */
COMM_PTR_VOL	POINTER	GLOBALDEF	INIT(NULL()),		/* Pointer to volatile /COMMENT string */
IFB_TAB_VOL	POINTER	GLOBALDEF	INIT(NULL());		/* Pointer to volatile IFB_TABLE */

Declare
INP_PTR_SWAP	BIT(1) ALIGNED GLOBALDEF,			/* YES => swap INP_PTR_VOL and INP_PTR_PERM */
DISP_PTR_SWAP	BIT(1) ALIGNED GLOBALDEF,			/* YES => swap DISP_PTR_VOL and DISP_PTR_PERM */
REC_PTR_SWAP	BIT(1) ALIGNED GLOBALDEF,			/* YES => swap REC_PTR_VOL and REC_PTR_PERM */
SUMM_PTR_SWAP	BIT(1) ALIGNED GLOBALDEF,			/* YES => swap SUMM_PTR_VOL and SUMM_PTR_PERM */
COMM_PTR_SWAP	BIT(1) ALIGNED GLOBALDEF,			/* YES => swap COMM_PTR_VOL and COMM_PTR_PERM */
IFB_TAB_SWAP	BIT(1) ALIGNED GLOBALDEF;			/* YES => swap IFB_TAB_VOL and IFB_TAB_PERM */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MOVE_CLASS_QUALS ENTRY (FIXED BINARY(7))			/* MACRO-32 routine to move class ... */
		 RETURNS(FIXED BINARY(31)),			/* ... qualifier values for all classes */
GET_CLASSES	ENTRY (BIT(1) ALIGNED) RETURNS(FIXED BINARY(31)), /* Routine to get info on all classes for this request */
GET_QUALIFIERS	ENTRY RETURNS(FIXED BINARY(31));		/* Routine to store qualifier info for this request */

Declare
  CUR_TO_ACT	FIXED BINARY(31) GLOBALREF VALUE,		/* Code value for MOVE_CLASS_QUALS rtn */
  ACT_TO_CUR	FIXED BINARY(31) GLOBALREF VALUE,		/* Code value for MOVE_CLASS_QUALS rtn */
  MRBPTR	POINTER GLOBALREF,				/* Pointer to MRB (Monitor Request Block) */
  CURR_MRBPTR	POINTER GLOBALREF,				/* Pointer to "current" MRB (Monitor Request Block) */
  TEMP_MRBPTR	POINTER GLOBALREF;				/* Pointer to "temp" MRB (Monitor Request Block) */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
INP_PTR_PERM	POINTER	STATIC		INIT(NULL()),		/* Pointer to permanent /INPUT file-spec */
DISP_PTR_PERM	POINTER	STATIC		INIT(NULL()),		/* Pointer to permanent /DISPLAY file-spec */
REC_PTR_PERM	POINTER	STATIC		INIT(NULL()),		/* Pointer to permanent /RECORD file-spec */
SUMM_PTR_PERM	POINTER	STATIC		INIT(NULL()),		/* Pointer to permanent /SUMMARY file-spec */
COMM_PTR_PERM	POINTER	STATIC		INIT(NULL()),		/* Pointer to permanent /COMMENT string */
IFB_TAB_PERM	POINTER	STATIC		INIT(NULL());		/* Pointer to permanent IFB_TABLE */

Declare
  CALL			FIXED BINARY(31),			/* Holds function value (return status) of called routines */ 
  STATUS		BIT(1) BASED(ADDR(CALL)),		/* Low-order status bit for called routines */
  TEMP			POINTER,				/* Temporary "scratch" area */
  AT_LEAST_ONE_CLASS	BIT(1) ALIGNED;				/* YES => user requested at least one class */


INP_PTR_SWAP = NO;						/* Ind no swap needed for 2 ptrs to /INPUT file-spec */
DISP_PTR_SWAP = NO;						/* Ind no swap needed for 2 ptrs to /DISPLAY file-spec */
REC_PTR_SWAP = NO;						/* Ind no swap needed for 2 ptrs to /RECORD file-spec */
SUMM_PTR_SWAP = NO;						/* Ind no swap needed for 2 ptrs to /SUMMARY file-spec */
COMM_PTR_SWAP = NO;						/* Ind no swap needed for 2 ptrs to /COMMENT string */
IFB_TAB_SWAP = NO;						/* Ind no swap needed for 2 ptrs to IFB_TABLE */
TEMP_MRBPTR->MRB = CURR_MRBPTR->MRB;				/* Move "current" MRB to "temp" MRB */
MRBPTR = TEMP_MRBPTR;						/* Make all MRB refs refer to "temp" MRB */
CALL = GET_QUALIFIERS();					/* Get SET qualifiers */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  		/* Return if bad status */

CALL = MOVE_CLASS_QUALS(CUR_TO_ACT);				/* Move current class qual values to active */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  		/* Return if bad status */

CALL = GET_CLASSES(AT_LEAST_ONE_CLASS);				/* Get info on requested classes */

IF STATUS							/* If successful, */
    THEN DO;
	 TEMP = TEMP_MRBPTR;					/* Swap "current" and ... */
	 TEMP_MRBPTR = CURR_MRBPTR;				/* ... "temp" MRB pointers */
	 CURR_MRBPTR = TEMP;					/* .... */

	 IF INP_PTR_SWAP = YES					/* If pointer swap required, */
	     THEN DO;
		  TEMP = INP_PTR_VOL;				/* Swap volatile and ... */
		  INP_PTR_VOL = INP_PTR_PERM;			/* ... permanent /INPUT file-spec */
		  INP_PTR_PERM = TEMP;				/* ... pointers */
		  END;

	 IF DISP_PTR_SWAP = YES					/* If pointer swap required, */
	     THEN DO;
		  TEMP = DISP_PTR_VOL;				/* Swap volatile and ... */
		  DISP_PTR_VOL = DISP_PTR_PERM;			/* ... permanent /DISPLAY file-spec */
		  DISP_PTR_PERM = TEMP;				/* ... pointers */
		  END;

	 IF REC_PTR_SWAP = YES					/* If pointer swap required, */
	     THEN DO;
		  TEMP = REC_PTR_VOL;				/* Swap volatile and ... */
		  REC_PTR_VOL = REC_PTR_PERM;			/* ... permanent /RECORD file-spec */
		  REC_PTR_PERM = TEMP;				/* ... pointers */
		  END;

	 IF SUMM_PTR_SWAP = YES					/* If pointer swap required, */
	     THEN DO;
		  TEMP = SUMM_PTR_VOL;				/* Swap volatile and ... */
		  SUMM_PTR_VOL = SUMM_PTR_PERM;			/* ... permanent /SUMMARY file-spec */
		  SUMM_PTR_PERM = TEMP;				/* ... pointers */
		  END;

	 IF COMM_PTR_SWAP = YES					/* If pointer swap required, */
	     THEN DO;
		  TEMP = COMM_PTR_VOL;				/* Swap volatile and ... */
		  COMM_PTR_VOL = COMM_PTR_PERM;			/* ... permanent /COMMENT string */
		  COMM_PTR_PERM = TEMP;				/* ... pointers */
		  END;

	 IF IFB_TAB_SWAP = YES					/* If pointer swap required, */
	     THEN DO;
		  TEMP = IFB_TAB_VOL;				/* Swap volatile and ... */
		  IFB_TAB_VOL = IFB_TAB_PERM;			/* ... permanent IFB_TABLE */
		  IFB_TAB_PERM = TEMP;				/* ... pointers */
		  END;

	 CALL = MOVE_CLASS_QUALS(ACT_TO_CUR);			/* Move active class qual values back to current */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  	/* Return if bad status */

	 END;

RETURN (CALL);							/* Return with status code */

END SET_CMD;

INIT_CMD: Procedure Returns (Fixed Binary(31));			/* Routine to execute an INITIALIZE subcommand */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	INIT_CMD
/*
/*	TBS
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  CALL			FIXED BINARY(31);			/* Holds function value (return status) of called routines */ 


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
DEF_TO_CUR	FIXED BINARY(31) GLOBALREF VALUE;		/* Code value for MOVE_CLASS_QUALS rtn */

Declare
MOVE_CLASS_QUALS	ENTRY (FIXED BINARY(7))			/* MACRO-32 routine to move class ... */
			RETURNS(FIXED BINARY(31));		/* ... qualifier values for all classes */

Declare
  CURR_MRBPTR	POINTER GLOBALREF,				/* Pointer to "current" MRB (Monitor Request Block) */
  DEF_MRBPTR	POINTER GLOBALREF;				/* Pointer to "default" MRB (Monitor Request Block) */

CURR_MRBPTR->MRB = DEF_MRBPTR->MRB;				/* Move default MRB to current MRB */
CALL = MOVE_CLASS_QUALS(DEF_TO_CUR);				/* ... and default class qual values to current */

RETURN (CALL);							/* Return with status code from MOVE_CLASS_QUALS */

END INIT_CMD;

HELP_CMD: Procedure Returns (Fixed Binary(31));			/* Routine to execute a HELP subcommand */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	HELP_CMD
/*
/*	TBS
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/

%INCLUDE		$HLPDEF;				/* HELP flag definitions */
%REPLACE 		NOT_SUCCESSFUL		BY '0'B;	/* Failing severity code */
%REPLACE		MON_HELPLIB		BY 'MNRHELP';	/* Log name for MONITOR subcommand help library */
%REPLACE		HELP_PARM		BY 'HELP_KEYS';	/* Name of parameter for HELP command (rest of line) */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/
Declare
  CALL			FIXED BINARY(31),			/* Holds function value (return status) of called routines */ 
  STATUS		BIT(1) BASED(ADDR(CALL));		/* Low-order status bit for called routines */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CLI$GET_VALUE	ENTRY (CHAR(*), ANY)				/* CLE routine to get qualifier values */
		RETURNS(BIT(1)),
LBR$OUTPUT_HELP	ENTRY (ENTRY VALUE, ANY, ANY, CHAR(*), FIXED BINARY(31), ENTRY VALUE)
		OPTIONS(VARIABLE) RETURNS(FIXED BINARY(31)),	/* Rtn to output help info with prompting */
LIB$PUT_OUTPUT	ENTRY,						/* Routine to write a line to terminal */
LIB$GET_INPUT	ENTRY,						/* Routine to read terminal */
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),
								/* Routine to log synchronous errors */
MNR$_HELPERR	FIXED BINARY(31) GLOBALREF VALUE;		/* Error message code */

Declare
NORMAL		FIXED BINARY(31) GLOBALREF,			/* MONITOR normal return status */
CURR_ERRCODE	FIXED BINARY(31) GLOBALREF;			/* MONITOR error status code currently expected */

Declare
1 DYN_STRING	GLOBALREF,					/* Dynamic string descriptor */
  2 L		FIXED BINARY(15),				/* Length */
  2 TC		CHAR(2),					/* Type and Class */
  2 A		POINTER;					/* Address */



CURR_ERRCODE = MNR$_HELPERR;					/* Set MONITOR code for signaled errors */
IF ^ CLI$GET_VALUE(HELP_PARM,DYN_STRING)			/* Get all command line after "HELP" verb */
								/* ... then ship it off to LBR$OUTPUT_HELP */
    THEN DYN_STRING.L = 0;					/* If rest of line null, make string null */

CALL = LBR$OUTPUT_HELP(LIB$PUT_OUTPUT,,DYN_STRING,MON_HELPLIB,
			HLP$M_PROMPT+HLP$M_PROCESS+HLP$M_GROUP+HLP$M_SYSTEM+HLP$M_HELP,
			LIB$GET_INPUT);				/* Call standard HELP output routine */

IF STATUS = NOT_SUCCESSFUL					/* If failed, */
    THEN DO;
	 CALL MON_ERR(MNR$_HELPERR,CALL);			/* Log the error ... */
	 RETURN(MNR$_HELPERR);					/* ... and return with status */
	 END;

RETURN (NORMAL);						/* Return with success code */

END HELP_CMD;

EXIT_CMD: Procedure Returns (Fixed Binary(31));			/* Routine to execute an EXIT subcommand */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	EXIT_CMD
/*
/*	TBS
/*
/* INPUTS:
/*
/*	TBS
/*
/* IMPLICIT INPUTS:
/*
/*	TBS
/*
/* OUTPUTS:
/*
/*	TBS
/*
/* IMPLICIT OUTPUTS:
/*
/*	TBS
/*
/* ROUTINE VALUE:
/*
/*	TBS
/*
/* SIDE EFFECTS:
/*
/*	TBS
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/



/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  PROMPT	BIT(1) ALIGNED	GLOBALREF,			/* YES => prompt user for another subcommand */
  NORMAL	FIXED BINARY(31) GLOBALREF;			/* MONITOR normal return status */

PROMPT = NO;							/* Indicate no more prompting for subcommands */

RETURN (NORMAL);						/* Return with status code */

END EXIT_CMD;


EXECUTE_CMD: Procedure Returns (Fixed Binary(31));		/* Routine to execute a MONITOR command file */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	EXECUTE_CMD
/*
/*	This is the routine invoked by CLI$DISPATCH when the EXECUTE command is given to MONITOR
/*	at the interactive level.  EXECUTE_CMD opens the execute command file, sets the bit flag EXECUTE,
/*	and returns to the main interactive loop in MONMAIN (which in turn calls NEXT_EXECUTE_COMMAND).  
/*	If there is an error opening the file, the error is reported and control returns 
/*	to the interactive level.
/*
/* INPUTS:
/*
/*	Execute filename - this is the file that will be opened so NEXT_EXECUTE_COMMAND can read monitor
/*	    commands.  The filename is obtained by using CLI$GET_VALUE with the CLD label "EXEC_FILE".
/*
/* IMPLICIT INPUTS:
/*
/*	EXECUTE - a bet set to tell the main loop to call NEXT_EXECUTE_COMMAND instead of EXECUTE_COMMAND.
/*	    NEXET_EXECUTE_COMMAND reads MONITOR commands from the opened file instead of the terminal.
/*
/* OUTPUTS:
/*
/*	None.
/*
/* IMPLICIT OUTPUTS:
/*
/*	COMMAND_FILE - the file reference associated with the execute command file.  This is also used by
/*	    NEXT_EXECUTE_COMMAND to read the file.
/*
/* ROUTINE VALUE:
/*
/*	MNR$_ERREXECOM	- EXECUTE subcommand cannot be used in an execute command file.
/*	MNR$_ERREXEFIL	- CLI$GET_VALUE failed to return the execute file name.
/*	MNR$_ERREXEOPN	- Open failure using the execute file name.
/*	SS$_NORMAL	- Success.
/*
/* SIDE EFFECTS:
/*
/*	None.
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 REQUIRE FILE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

%REPLACE	FILE_SPEC_SIZE		BY 128;			/* Max file spec size */
%REPLACE 	NOT_SUCCESSFUL		BY '0'B;		/* Failing severity code */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     GLOBAL STORAGE DEFINITIONS				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
    COMMAND_FILE	FILE RECORD GLOBALDEF;			/* Execute command file */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			   EXTERNAL REFERENCES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
    CLI$GET_VALUE	ENTRY(ANY, ANY)				/* CLE routine to get qualifier values */
			RETURNS(FIXED BINARY(31)),
    MON_ERR		ENTRY (ANY VALUE, ANY, ANY)		/* Routine to log synchronous errors */
			OPTIONS(VARIABLE);
Declare
    CURR_ERRCODE	FIXED BINARY(31) GLOBALREF,		/* MONITOR error status code currently expected */
    EXECUTE		BIT(1) ALIGNED   GLOBALREF,		/* YES => read another command from the execute file */
    NORMAL		FIXED BINARY(31) GLOBALREF;		/* MONITOR normal return status */

Declare
    MNR$_ERREXECOM	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
    MNR$_ERREXEFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
    MNR$_ERREXEOPN	FIXED BINARY(31) GLOBALREF VALUE;	/* Error message code */


/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
    CALL		FIXED BINARY(31),			/* Holds function value (return status) of called routines */ 
    STATUS		BIT(1) BASED(ADDR(CALL));		/* Low-order status bit for called routines */

Declare
    1 EXEC_FILE_PARM,
      2 L		FIXED BINARY (31),
      2 A		POINTER,

    1 EXEC_FILE_VAL,
      2 L		FIXED BINARY (31),
      2 A		POINTER,

    EXEC_FILE_NAME	CHAR(9)  STATIC INIT('EXEC_FILE'),
    EXEC_FILE_STR	CHAR(FILE_SPEC_SIZE) STATIC INIT('MONITOR.MON');


ON UNDEFINEDFILE (COMMAND_FILE) GOTO OPEN_ERROR;		/* Set up the UNDEFINEDFILE condition */


IF EXECUTE = YES 						/* Make sure there is only 1 level of execute command file */
    THEN DO;
	CALL MON_ERR(MNR$_ERREXECOM);				/* Log the error... */
	RETURN(MNR$_ERREXECOM);					/* Return to processing the execute command file */
    END;

EXECUTE = YES;							/* Let everyone know command input is coming from a file */
EXEC_FILE_PARM.L = LENGTH(EXEC_FILE_NAME);			/* Set the length of the EXEC_FILE descriptor */
EXEC_FILE_PARM.A = ADDR(EXEC_FILE_NAME);			/* Set the address of the EXEC_FILE string */
EXEC_FILE_VAL.L =  LENGTH(EXEC_FILE_STR);			/* Set the length of the execute filename descriptor */
EXEC_FILE_VAL.A =  ADDR(EXEC_FILE_STR);				/* Set the address of the execute filename string */
CURR_ERRCODE = MNR$_ERREXEFIL;					/* Set MONITOR code for signaled errors */
CALL = CLI$GET_VALUE(EXEC_FILE_PARM,EXEC_FILE_VAL); 		/* Get EXECUTE file name */
IF STATUS = NOT_SUCCESSFUL					/* If failed, */
    THEN DO;
	EXECUTE = NO;						/* Error, no longer doing an EXECUTE subcommand */
	CALL MON_ERR(MNR$_ERREXEFIL,CALL);			/* Log the error ... */
	RETURN(MNR$_ERREXEFIL);					/* ... and return with status */
	END;

OPEN FILE(COMMAND_FILE) INPUT SEQUENTIAL TITLE(EXEC_FILE_STR)	/* Open the execute command file */
    ENVIRONMENT(DEFAULT_FILE_NAME('.MON'));			/*  with .MON for default file type */

CURR_ERRCODE = 0;						/* Set MONITOR code for signaled errors */
RETURN (NORMAL);						/* Return with success code */

OPEN_ERROR:
    EXECUTE = NO;						/* Indicate no more from the execute file */
    CURR_ERRCODE = 0;						/* Reset to default MONITOR code in case subcommand changed it */
    CALL MON_ERR(MNR$_ERREXEOPN);				/* Log the error ... */
    RETURN(MNR$_ERREXEOPN);					/* ... and return with status */

END EXECUTE_CMD;
