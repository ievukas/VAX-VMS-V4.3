	.IF	NDF,LIBSWITCH
	.TITLE	SHELL PROCESS DEFINITION
	.IFF
	.TITLE	SYS$USRVECTOR - USER ACCESSIBLE P1 CELLS
	.ENDC
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, CREATE PROCESS/SWAPPER DATA BASE
;
; ABSTRACT:	SHELL DEFINES THE SWAP IMAGE FOR THE INITIAL PROCESS
;		STARTED BY THE CREATE PROCESS SYSTEM SERVICE.
;
; ENVIRONMENT:
;
; AUTHOR: RICHARD I. HUSTVEDT, CREATION DATE: 30-NOV-76
;
; MODIFIED BY:
;
;	V03-039	RAS0319		Ron Schaefer		29-Jun-1984
;		Add queue header cells for logical name table name
;		translation cache.
;
;	V03-038	LJK0287		Lawrence J. Kenah	25-Jun-1984
;		Add three longword array to contain the counts of termination
;		handlers declared in each of the three outer access modes.
;		Add sequence number cell for process private logical name
;		directory.
;
;	V03-037	MSH0054		Michael S. Harvey	30-May-1984
;		Remove some obsolete symbols.
;
;	V03-036	LJK0282		Lawrence J. Kenah	9-May-1984
;		Add demand zero page after PIO page to accommodate long
;		directory names that straddle page boundary.
;
;	V03-035	TMK0001		Todd M. Katz		27-Apr-1984
;		Remove CTL$GL_LOGTBL which was required only under the old 
;		logical name design.
;
;	V03-034	LJK0272		Lawrence J. Kenah	10-Apr-1984
;		Add image activator context cells privileged vectors
;		and shareable image initialization.
;
;	V03-033	MHB0133		Mark Bramhall		 9-Apr-1984
;		Remove preset values for CTL$T_USERNAME and CTL$T_ACCOUNT.
;		Validate CLI information ordering.
;
;	V03-032	RAS0281		Ron Schaefer		28-Mar-1984
;		Add PIO$GB_DFNBC process-specific RMS parameter for
;		network block count transfer size.
;		Re-use the cell once used from RMS Compatibility.
;		Add CTL$GT_SPAWNCLI and CTL$GT_SPAWNTABLE as well.
;
;	V03-031	WMC0006		Wayne Cardoza		21-Mar-1984
;		Go back to 3 pages of kernel stack.
;		Add cells for default image I/O area.
;
;	V03-030	MSH0006		Michael S. Harvey	3-Feb-1984
;		Protect image header buffer page against USER WRITE.
;
;		Protect image activator scratch page from user by changing
;		its owner to EXEC.
;
;		Replace obsolete image rundown control flags with an image
;		list pointer for use by the debugger. This fixed cell pointer
;		allows the debugger to avoid linking against the executive.
;
;	V03-029	RSH0091		R. Scott Hanna		31-Jan-1984
;		Add dedicated P1 demand zero pages for the security auditing
;		Impure Data Table (IDT). Remove the old vector page pointer
;		to the IDT.
;
;	V03-028	LJK0258		Lawrence J. Kenah	18-Jan-1984
;		Correct problems introduced by LJK0257. In SHELINIT, only
;		reorder a number of pagesequal to the  pages in this module
;		that are NOT kernel stack pages. Convert a PIO page from
;		a page file page to demand zero.
;
;	V03-027	BLS0262		Benn Schreiber		16-Jan-1984
;		Correct .ADDRESS to be .LONG in P1 lookaside list links
;
;	V03-026	LJK0257		Lawrence J. Kenah	4-Jan-1984
;		A variety of changes.
;
;		    Add CTL$GQ_TERMCHAR and CREPRC_FLAGS to P1 vector page.
;
;		    Add UAF_FLAGS to CLI data page.
;
;		    Change PQB$C_MAXDIRLEN references to PQB$S_DDSTRING.
;
;		    Add second page for compatibility mode context.
;
;		    Reorder SHELL pages to achieve demand zero compaction.
;
;		    Add listhead and demand zero pages for P1 pool lookaside 
;		    list. 
;
;		    Move page file index and characteristics from PQB to PCB.
;
;	V03-025	WMC0005		Wayne Cardoza		02-Dec-1983
;		PHD$W_BAK, PHD$W_WSLX are now longwords.
;
;	V03-024	WMC0004		Wayne Cardoza		28-Nov-1983
;		Move the kstack expansion WSL slots.
;
;	V03-023	WMC0003		Wayne Cardoza		13-Oct-1983
;		Reserve space for 4 extra kstack pages.
;
;	V03-022	LJK0251		Lawrence J. Kenah	7-Sep-1983
;		Add CLI name counted string to CLI data page.
;
;	V03-021	LJK0246		Lawrence J. Kenah	24-Aug-1983
;		Add cell to P1 pointer page that records the size of the
;		user stack.
;
;	V03-020	WMC0002		Wayne Cardoza		22-Aug-1983
;		Temporarily increase kernel stack to 4 pages.
;
;	V03-019	LJK0239		Lawrence J. Kenah	1-Aug-1983
;		Increase size of exec stack to 16 pages.
;
;	V03-018	RAS0159		Ron Schaefer		22-Jul-1983
;		Add symbol PIO$S_EODSTR to specify the length of the
;		$EOD string for SYS$INPUT.
;
;	V03-017	LJK0208		Lawrence J. Kenah	26-May-1983
;		Add listheads for image control block lists to image
;		activator context page. Change name of image activator
;		work area.
;
;	V03-016	RSH0017		R. Scott Hanna		21-May-1983
;		Change CTL$GL_AUDITCHAN to CTL$GL_NSA_IDTPTR. This cell
;		contains a pointer to the security auditing impure data
;		table. The audit channel number is now in the IDT.
;
;	V03-015	PCA1016		Paul C. Anagnostopoulos 28-Apr-1983
;		Add CTL$AG_CLITABLE, two longwords which specify the
;		virtual address range into which the CLI table is mapped.
;
;	V03-014	GAS0122		Gerry Smith		14-Apr-1983
;		Add CTL$GQ_HELPFLAGS, two longwords of information on
;		current help settings.  Also double the size of the
;		supervisor stack, to 32 pages.
;
;	V03-013 RSH0012		R. Scott Hanna		13-Mar-1983
;		Add the cell CTL$GL_AUDITCHAN to store the security
;		audit trail journal channel number.
;
;	V03-012 RSH0002		R. Scott Hanna		9-Feb-1983
;		Add CTL$GL_RDIPTR to support rights database system
;		services.
;
;	V03-011	KBT0454		Keith B. Thompson	7-Jan-1983
;		Make directory cache 2 pages due to long directory names.
;
;	V03-010	JWH0138		Jeffrey W. Horn		29-Nov-1982
;		Fix problems related with movement within the
;		vector page introduced by JWH0118 and DMW4008.
;
;	V03-009	JWH0118		Jeffrey W. Horn		19-Nov-1982
;		Re-organize RMS Impure Areas.   Add cells needed to 
;		support P1 allocation routines.  Eliminate the
;		RMS Process IO segment and the Process	Allocation 
;		Region from SHELL, now created in PROCSTRT.
;
;	V03-008	DMW4008		DMWalp			12-Nov-1982
;		Add definations for new logical name structures.
;
;	V03-007	WMC0001		Wayne Cardoza		19-Oct-1982
;		Add support for specifying desired page file.
;
;	V03-006	JWH0001		Jeffrey W. Horn		27-Aug-1982
;		Add cells needed to support RMS Recovery Units.  
;		PIO$GL_RULOCK and PIO$GL_NXTIRBSEQ.
;
;	V03-005	CDS0001		C Saether		13-Aug-1982
;		Define CTL$GL_F11BXQP cell to dispatch to XQP.
;
;	V03-004	LJK47269	Lawrence J. Kenah	10-Aug-1982
;		Change protection on image activator scratch pages to 
;		UREW. Remove $PRDEF.
;
;	V03-004	KDM46395	Kathleen D. Morse	28-Jun-1982
;		Increment the PTWSLELCK byte array for the P1 system
;		service vector pages, which are WINDOW PTEs.
;
;	V03-002	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF.
;
;
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$DYNDEF			;DYNAMIC DATA STRUCTURE TYPE DEFINITIONS
	$FWADEF			;RMS FILE WORK AREA CONSTANTS
	$IAFDEF			;IMAGE ACTIVATOR FIXUP VECTOR OFFSETS
	$IMPDEF			;RMS INTERNAL STRUCTURE DEFINITION
	$IPLDEF			;DEFINE INTERRUPT LEVELS
	$JIBDEF			;JOB INFORMATION BLOCK DEFINITIONS
	$NSAIDTDEF		;SECURITY AUDITING IMPURE DATA TABLE OFFSETS
	$PCBDEF			;PROCESS CONTROL BLOCK DEFINITIONS
	$PFLDEF			;PAGE FILE DEFINITIONS
	$PFNDEF			;PFN DATA BASE DEFINITIONS
	$PHDDEF			;PROCESS HEADER DEFINITIONS
	$PQBDEF			;PROCESS QUOTA BLOCK DEFINITIONS
	$PRTDEF			;DEFINE PROTECTION CODES
	$PSLDEF			;DEFINE PSL FIELDS
	$PTEDEF			;PAGE TABLE ENTRY DEFINTIONS
	$SECDEF			;SECTION DEFINITIONS (GSTE/PSTE)
	$SGNDEF			;SYSGEN VALUE DEFINITIONS
	$VADEF			;DEFINE VIRTUAL ADDRESS FIELDS
	$WSLDEF			;WORKING SET LIST DEFINITIONS

;
; EQUATES:
;

PFILPGCNT=0				; INITIALIZE COUNT OF PAGE FILE PAGES
KSTACK=3				; THREE PAGES OF KERNEL STACK
KSTACK_EX=4				; KERNEL STACK EXPANSION PAGES
ESTACK=16				; SIXTEEN PAGES OF EXEC STACK
SSTACK=32				; THIRTY TWO PAGES OF SUPER STACK
IMGACTBUF=8				; EIGHT PAGES FOR IMAGE ACTIVATE BUFFER
					; FOUR FOR TOP LEVEL CALL, FOUR FOR
					; ONE RECURSIVE CALL.
KRP_COUNT=4				; SIZE IN PAGES OF P1 LOOKASIDE LIST

DBGPTCNT=1				; NUMBER OF DEBUG AREA PAGE TABLES

	.IF	NDF,LIBSWITCH		; IF EXECUTIVE, DEFINE THESE GLOBALLY
SWP$C_DBGPTCNT==DBGPTCNT
SWP$C_KSTACK==KSTACK
SWP$C_KSTACK_EX==KSTACK_EX
CTL$C_KRP_COUNT==KRP_COUNT
CTL$C_KRP_SIZE==512			; EACH KRP PACKET IS 512 BYTES LONG
	.ENDC

COMMON=4				; FOUR PAGES FOR USER COMMON
					; FOUR PAGES FOR DEC COMMON

;
; MACROS:
;

	.MACRO	WSL	SYM,TYPE	; MAKE VALID WS LIST ENTRY
	.LONG	SYM!WSL$M_VALID!WSL$C_'TYPE	; SET VALID BIT
	.ENDM	WSL

	.MACRO	CTL	SYM
	.IF	NDF,LIBSWITCH
CTL$'SYM==.-CTLVECPAG+VECTORS
	.IFF
CTL$'SYM=.-CTLVECPAG+VECTORS
	.ENDC
	.ENDM	CTL

	.MACRO	PHD	SYM
	.=PHD...+PHD$'SYM
	.ENDM	PHD


	.MACRO	PIO	SYM		; DEFINE PROCESS I/O SEGMENT SYMBOL
PIO$'SYM==PIOBASE+<.-PIO>		;
	.ENDM	PIO

	.MACRO	PIOL	SYM		; DEFINE PROCESS I/O LOCAL SYMBOL
PIOL'SYM=PIOBASE+<.-PIO>		;
	.ENDM	PIOL			;

	.MACRO	PIO2	SYM		; DEFINE PROCESS I/O LOCAL SYMBOL
PIO2'SYM=PIOTBL+<.-TBL>
	.ENDM	PIO2

;
; P1PTE - GENERATE PTES FOR CONTROL REGION PAGE TABLE
;

	.MACRO	P1PTE	NUM,ACCESS=NA,OWNER=K,STATE,SYM
	.IF	NB,SYM
	SYM=VA...
	.ENDC

	.REPT	NUM
	.=.-4
	.IF	IDN,<STATE>,<VALID>
	TMP...=<1@31>
	.IFF
	TMP...=0
	.ENDC

	.IF	IDN,<STATE>,<DZRO>
	PFILPGCNT=PFILPGCNT+1
	.ENDC

	.IF	IDN,<STATE>,<PFIL>
	TMP...=PTE$M_TYP1
	PFILPGCNT=PFILPGCNT+1
	.ENDC
	.LONG	PTE$C_'ACCESS!PTE$C_'OWNER'OWN!TMP...

	.=.-4
	VA...=VA...-^X200
	.ENDR
	.ENDM	P1PTE

	.PAGE

	.IF	DF,LIBSWITCH		; FOR USRVECTOR MODULE,
	.PSECT	$ABS$,ABS		; DO NOT GENERATE ANY STORAGE
	.=0
	.IFF				; ELSE,

	.PSECT	AEXENONPAGED
SWP$GL_SHELIO::				; I/O PAGE COUNT FOR SHELL
	.LONG	SWP$C_SHELLSIZ		;
;
;	WARNING: SWP$C_SHLP1PT MUST BE MANUALLY COMPUTED SINCE IT IS USED
;		 TO ALLOCATE THE SPACE FOR P1 PAGE TABLE ENTRIES.  IF UPDATES
;		 ARE MADE THAT INTRODUCE MORE P1 PAGE TABLE ENTRIES, THEN
;		 VERIFY THAT THEY STILL FIT IN THE NUMBER OF PAGES PROVIDED
;
SWP$C_SHLP1PT==2			; COUNT OF BASIC P1 PAGE TABLES FOR SHELL
	.PSECT	YYSHELLPAGED,PAGE	; SHELL AT END OF PAGEABLE EXEC
SHELL:					; BASE OF SHELL SWAP IMAGE
SWP$GL_SHELLBAS::			; 
	.PAGE
	.SBTTL	SHELL PROCESS HEADER
;
;	PROCESS HEADER FOR SHELL PROCESS
;

PHD...=.				; BASE OF PROCESS HEADER
	.BLKB	PHD$C_LENGTH		; RESERVE SPACE FOR HEADER

;
;	WORKING SET LIST
;
; PAGES DESCRIBED IN THE WORKING SET LIST MUST OCCUR IN THE SAME ORDER
; WITHIN THE PROCESS BODY.
;
	.ALIGN	LONG			; AT LONGWORD RESOLUTION
SWP$C_KSTACK_EX_WSL==<.-PHD...>@-2
	.BLKL	KSTACK_EX		; EXTRA SLOTS FOR KERNEL STACK EXPANSION
WSL...=.				; BASE OF WORKING SET LIST
SWP$C_KSTACK_WSL==<.-PHD...>@-2
	WSL	<<KSPINI-<1*512>>!WSL$M_WSLOCK>,PROCESS; KERNEL STACK PAGE 1
	WSL	<<KSPINI-<2*512>>!WSL$M_WSLOCK>,PROCESS; KERNEL STACK PAGE 2
	WSL	<<KSPINI-<3*512>>!WSL$M_WSLOCK>,PROCESS; KERNEL STACK PAGE 3
NOT_KSTACK_WSL=.			; REST OF WSL IS NOT KERNEL STACK
	WSL	<VECTORS!WSL$M_WSLOCK>,PROCESS	; VECTOR PAGE
DYNWSL=.				; START OF DYNAMIC WORKING SET
	WSL	<PIOBASE!WSL$M_MODIFY>,PROCESS	; PROCESS I/O SEGMENT BASE PAGE 1

FWSL...=.				; FREE WORKING SET LIST
NDYN=<FWSL...-DYNWSL>@-2		; NUMBER OF DYNAMIC ENTRIES IN SHELL
SHUFFLE_COUNT=<FWSL...-NOT_KSTACK_WSL>@-2 ; AMOUNT OF SHUFFLING BY SHELINIT
SWP$C_NDYN==NDYN			; GLOBAL NAME FOR NUMBER OF DYNAMIC PAGES
	.ALIGN	PAGE			; GET TO END OF PAGE
SAV...=.				;

TMP...=<DYNWSL-PHD...>@-2		; BASE OF FLUID WORKING SET LIST

	PHD	W_WSLOCK		; POINTER TO START OF LOCKED PAGES
	.WORD	TMP...			;

	PHD	W_WSDYN			; POINTER TO START OF DYNAMIC PAGES
	.WORD	TMP...			;

	PHD	W_WSLIST		;
	.WORD	<WSL...-PHD...>@-2	; START OF WORKING SET LIST
	PHD	W_WSNEXT		; NEXT WORKING SET ENTRY
	.WORD	<TMP...+NDYN-1>		;

	PHD	L_FREP1VA		; VA OF FIRST FREE PAGE IN P1 SPACE
	.LONG	VA...-512		;

	PHD	Q_PRIVMSK		; ENABLE ALL PRIVILEGES
	.LONG	-1,-1			;

	PHD	W_QUANT			; QUANTUM OF ONE SECOND
	.WORD	-100			;

	PHD	L_KSP			; STACK POINTERS
	.LONG	KSPINI			; KERNEL STACK POINTER
	.LONG	ESPINI			; EXECUTIVE STACK POINTER
	.LONG	SSPINI			; SUPER STACK POINTER
					; NO INITIAL USER STACK

	PHD	L_PC			; INITIAL PROGRAM COUNTER
	.LONG	EXE$PROCSTRT		; START PROCESS

	PHD	L_PSL			; PROGRAM STATUS LONGWORD
	.LONG	IPL$_ASTDEL@PSL$V_IPL	; MUST RUN AT ASTDEL
	PHD	L_P0BR			; P0 BASE REGISTER
	.LONG	0			; RELATIVE OFFSET

	PHD	L_P0LRASTL		; NO AST PENDING, POLR = 0
	.LONG	<4@PHD$V_ASTLVL>	;

	PHD	L_P1BR			; SVA OF P1 PAGE TABLE BASE
	.LONG	-<1@23>			; 

	PHD	L_P1LR			; P1 LENGTH REGISTER
	.LONG	<1@21>-P1PTLEN		; 

	PHD	L_FREPTECNT		; FREE PTE'S BETWEEN P0 AND P1 PT
	.LONG	-<1+<<1@31-VA...>@-9>>	; (NUMBER OF AVAILABLE LONGWORDS

	PHD	W_PRCLM			; SUB PROCESS LIMIT
	.WORD	4			; ALLOW FOUR

	PHD	W_WSFLUID		; GUARANTEED FLUID PAGE COUNT
	.WORD	10			; GUESS AT TEN FOR NOW (WAG)

	PHD	B_DFPFC			; DEFAULT PAGE FAULT CLUSTER
	.BYTE	16			;

	PHD	B_CPUMODE		; ACCESS MODE FIELD FOR CPU TIME LIMIT
	.BYTE	PSL$C_USER		;  EXPIRATION AST STARTS WITH USER MODE

	.=SAV...			; RESTORE LOCATION COUNTER
	.PAGE
	.SBTTL	SHELL PROCESS PAGE TABLES
;
;
;	SHELL PROCESS PAGE TABLES
;
;

P1PTBAS=.				;

	TMP=<SWP$C_SHLP1PT*512>		; ALLOCATE SPACE FOR PAGE TABLES
	.BLKB	TMP			; ALLOCATE SPACE FOR PAGE TABLES
SAV...=.				; REMEMBER BASE OF PAGE TABLES

	.IFTF				; ASSEMBLE FOLLOWING FOR BOTH
					; SHELL AND USRVECTOR MODULES:

;
;	INITIALIZE VIRTUAL ADDRESS BASE
;
	VA...=1@31			;

;	P1PTE	128*DBGPTCNT		; DEBUGGER CONTEXT AREA
	VA...=VA...-<DBGPTCNT*128*512>	; ACCOUNT FOR IT IN VA...
DBGAREA=VA...				; ADDRESS OF DEBUG AREA
	P1PTE	1,URKW,K,PFIL		; VECTOR PAGE
VECTORS=VA...				;

	.IFF				; ASSEMBLE REST ONLY FOR SHELL MODULE:

CTL$GL_VECTORS==VECTORS			; BASE OF VECTOR PAGE
	P1PTE	16			; PAGES FOR SYSTEM SERVICE VECTORS
P1SYSVECTORS==VA...
	P1PTE	SSTACK,URSW,S,DZRO,SSPINI	; SUPERVISOR STACK
	P1PTE	ESTACK,SREW,E,DZRO,ESPINI	; EXECUTIVE STACK
	P1PTE	KSTACK,SRKW,K,PFIL,KSPINI	; KERNEL STACK
CTL$GL_KSTKBAS==VA...			; MAXIMUM TOP OF KERNEL STACK
	P1PTE	KSTACK_EX,NA,K,PFIL		; EXPANSION FOR  KERNEL STACK
CTL$GL_KSTKBASEXP==VA...		; MAXIMUM TOP OF EXPANSION KERNEL STACK
CTL$GL_KSPINI==KSPINI			; INITIAL KERNEL STACK
	P1PTE	1			; NULL STOPPER PAGE
	P1PTE	KRP_COUNT,URKW,K,DZRO	; P1 LOOKASIDE LIST FOR KERNEL MODE
CTL$GL_KRP==VA...			; ADDRESS USED BY PROCSTRT TO FIND IT
	P1PTE	1,URSW,E,DZRO		; IMAGE HEADER BUFFER
MMG$IMGHDRBUF==VA...			; ADDRESS OF IMAGE HEADER BUFFER
	P1PTE	2,UREW,K,DZRO		; VECTORS FOR USER SYS SRV & ERR MSGS
CTL$A_DISPVEC==VA...			; ADR OF VECTOR PAGES FOR SYS SRV/ERRMSG
	P1PTE	4,UW,U,DZRO		; DEBUGGER CONTEXT
	P1PTE	IMGACTBUF,UREW,E,DZRO	; IMAGE ACTIVATOR SCRATCH PAGES (8)
IAC$AL_IMGACTBUF==VA...			; ADR OF IMAGE ACTIVATOR SCRATCH PAGES
CLIDATAEND=VA...
	P1PTE	12,URSW,S,DZRO		; COMMMAND INTERPRETER DATA PAGES
CLIDATAPAG=VA...			; BASE ADDRESS OF CLI DATA PAGE
	P1PTE	1,UREW,E,DZRO		; IMAGE ACTIVATOR CONTEXT
IMGACTCTX=VA...
	P1PTE	NSA$K_IDT_PAGES,KW,K,DZRO ; SECURITY AUDITING IMPURE DATA TABLE
NSA$T_IDT==VA...
	P1PTE	2			; UNUSED PAGES
;
;	THE FOLLOWING PAGE IS A USER-MODE WRITABLE CONTEXT PAGE
;	FOR MISC. USER-MODE PACKAGES THAT ARE MAINTAINED BY VMS.
;	(SEE DETAILED ALLOCATION OF PAGE BELOW)
;
	P1PTE	1,UW,K,DZRO		; GLOBAL USER-MODE OWN STORAGE PAGE
UWVECPAG=VA...
;
;	THE FOLLOWING PAGE IS A WRITABLE CONTEXT PAGE FOR
;	THE USE OF THE COMPATIBILITY MODE EMULATOR AND EXCEPTION
;
	P1PTE	2,UW,K,DZRO		; WRITABLE PAGES FOR COMPATIBILITY MODE
CTL$AG_CMEDATA==VA...			; 
;
;	THE FOLLOWING PAGES ARE FOR USE BY BASIC/BASIC-PLUS TO PROVIDE
;	THE "CORE COMMON" REQUIRED TO PASS DATA WHEN CHAINING FROM IMAGE
;	TO IMAGE.  AN IDENTICAL AREA, NEGATIVELY DISPLACED HAS BEEN ALLOCATED
;	FOR USERS AND CSS.
;
	P1PTE	COMMON,UW,K,DZRO	; DEC "CORE COMMON" PAGES
CTL$A_COMMON==VA...			; BASE ADDRESS
	P1PTE	COMMON,UW,K,DZRO	; USER "CORE COMMON" PAGES
	P1PTE	1,UREW,E,DZRO		; PROCESS IFB/IRB TABLES
PIOTBL=VA...
	P1PTE	2,UREW,E,DZRO		; RMS DIRECTORY CACHE PAGES
PIO$A_DIRCACHE==VA...
	P1PTE	1,UREW,E,DZRO		; RMS TRACEPOINT PAGE
PIO$A_TRACE==VA...
	P1PTE	1,UREW,E,DZRO		; EXTENSION TO RMS POINTER PAGE
	P1PTE	1,UREW,E,PFIL		; RMS POINTER PAGE
PIOBASE=VA...				;
USPINI=VA...				; USER STACK AREA

END...=.				; END OF CONTROL REGION

P1PTLEN=<1@31-VA...>@-9			; ENTRIES IN P1PT

SWP$C_SHLFPTE==<<.-P1PTBAS>@-2>	; FREE P1PT IN BASIC P1 PAGE TABLES
;
; RESTORE LOCATION POINTER
;
	.=SAV...			; FINISHED WITH PAGE TABLES
	PFILPGCNT=PFILPGCNT-KSTACK-1	; NO PAGE FILE FOR KERNEL STACK OR VECTORS
	SWP$C_SHELLPFIL==PFILPGCNT	; DEFINE GLOBAL VALUE FOR SHELL PAGE FILE
					; REQUIREMENT
	.PAGE
	.SBTTL	BODY OF SHELL PROCESS
;
;	BODY OF SHELL PROCESS
;
	.=SAV...			; POSITION TO END OF HEADER
;-------------------------------------------------------------------------
;
;	VECTOR PAGE
;		***** NOTE: The cells in this page must not move.  There are
;		*****	    facilities which locate cells via offsets from
;		*****	    the top of this page.  If you delete a cell
;		*****	    subsitute a .LONG 0 and comment it as SPARE.  If
;		*****	    you add a cell either replace a SPARE cell or
;		*****	    add it to the end.
;
;-------------------------------------------------------------------------
SWP$AL_PTRPAG==.-SHELL			; ADDRESS IN SWAPPER MAP

	.IFT				; IF USRVECTOR MODULE,
	.=VECTORS			; SHOW ACTUAL ADDRESSES IN LISTING

	.IFTF				; ASSEMBLE FOLLOWING FOR BOTH
					; SHELL AND USRVECTOR MODULES:

CTLVECPAG=.				; BASE OF VECTOR PAGE
	CTL	GW_NMIOCH		; NUMBER OF CHANNELS
	.WORD	0			; FILLED IN IN PROCSTRT
	
	CTL	GW_CHINDX		; MAXIMUM CHANNEL INDEX
	.WORD	0			; FILLED IN IN PROCSTRT

	CTL	GL_LNMHASH		; process Logical NaMe HASH table
	.LONG	0			;  pointer
	CTL	GL_LNMDIRECT		; process Logical NaMe DIRECTory
	.LONG	0			;  pointer

;
;	ARRAY OF STACK POINTERS
;
;	THE -1 ENTRY OF CTL$AL_STACK IS USED TO DETERMINE THE MAXIMUM
;	EXTENT OF THE KERNEL STACK.
;
	.LONG	CTL$GL_KSTKBAS		; MAXIMUM TOP OF KERNEL STACK
	CTL	AL_STACK		; STACK POINTER RESTART ARRAY
	.LONG	KSPINI			; KERNEL STACK POINTER
	.LONG	ESPINI			; EXEC STACK POINTER
	.LONG	SSPINI			; SUPERVISOR STACK POINTER
	.LONG	USPINI			; USER STACK POINTER

;
; LOGICAL NAME TABLE TRANSLATION CACHE QUEUE HEADER
;

	CTL	GQ_LNMTBLCACHE		; QUEUE HEADER FOR LOGICAL NAME TABLE
	.LONG	CTL$GQ_LNMTBLCACHE	;  TRANSLATION CACHE (FORWARD LINK)
	.LONG	CTL$GQ_LNMTBLCACHE	;  		     (BACK LINK)

;
; THE FOLLOWING THREE VECTORS MUST BE ADJACENT
;

	CTL	GL_CMSUPR		; SUPERVISOR CHANGE MODE DISPATCHER
	.LONG	0			; NULL

	CTL	GL_CMUSER		; USER CHANGE MODE DISPATCHER
	.LONG	0			; NULL

	CTL	GL_CMHANDLR		; COMPATIBILITY MODE HANDLER
	.LONG	0

	CTL	AQ_EXCVEC		; PRIMARY/SECONDARY EXCEPTION VECTORS
	.LONG	0			; KERNEL MODE PRIMARY
	.LONG	0			; KERNEL MODE SECONDARY
	.LONG	0			; EXEC MODE PRIMARY
	.LONG	0			; EXEC MODE SECONDARY
	.LONG	0			; SUPERVISOR MODE PRIMARY
	.LONG	0			; SUPERVISOR MODE SECONDARY
	.LONG	0			; USER MODE PRIMARY
	.LONG	0			; USER MODE SECONDARY

	CTL	GL_THEXEC		; EXECUTIVE TERMINATION HANDLER
	.LONG	0			; NULL

	CTL	GL_THSUPR		; SUPERVISOR TERMINATION HANDLER
	.LONG	0			; NULL

;	CTL	GL_THUSER		; USER TERMINATION HANDLER
	.LONG	0			; NULL

;	FORMER LOCATION OF COMPATIBILITY MODE CONTEXT
	CTL	GQ_COMMON		; CORE COMMON DESCRIPTOR
	.LONG	512*COMMON		; SIZE IN BYTES
	.LONG	CTL$A_COMMON		; AND ADDRESS

	CTL	GL_GETMSG		; PER-PROCESS VECTOR TO USER MESSAGE
	.LONG	0			; DISPATCHER

	CTL	AL_STACKLIM		; STACK LIMIT ARRAY (INDEXED BY MODE)
	.LONG	CTL$GL_KSTKBAS		; KERNEL STACK LO (TOP) LIMIT
	.LONG	KSPINI			; EXEC   STACK LO (TOP) LIMIT
	.LONG	ESPINI			; SUPER  STACK LO (TOP) LIMIT
	.LONG	0			; USER STACK (NOT CHECKED)

	CTL	GL_CTLBASVA		; BASE CONTROL REGION ADDRESS
	.LONG	0			; FILLED IN BY PROCSTRT

	CTL	GL_IMGHDRBF		; ADDRESS OF IMAGE ACTIVATOR'S IMAGE
					; HEADER BUFFER, IF IMAGE IS ACTIVE;
	.LONG	0			; 0 IF NO IMAGE ACTIVE

	CTL	GL_IMGLSTPTR		; ADDRESS OF ICB LIST (FOR DEBUGGER)
	.LONG	IAC$GL_IMAGE_LIST

	CTL	GL_PHD			; ADDRESS OF PHD WINDOW
	.LONG	0			; INIT BY INSWAP

	CTL	GQ_ALLOCREG		; HEAD OF PROCESS ALLOCATION REGION POOL
	.LONG	0,0			; 	(Filled in by PROCSTRT)

	CTL	GQ_MOUNTLST		; MOUNTED DEVICE LIST
	.LONG	CTL$GQ_MOUNTLST		; FORWARD LINK
	.LONG	CTL$GQ_MOUNTLST		; BACKWARD LINK ( LIST EMPTY )

;************************************************************************
; NOTE: The order of the accounting data between CTL$T_USERNAME and
;	CTL$T_REMOTEID should be preserved!
;************************************************************************

	CTL	T_USERNAME		; USERNAME
	.BLKB	JIB$S_USERNAME		;  Filled in by PROCSTRT

	CTL	T_ACCOUNT		; ACCOUNT NAME
	.BLKB	JIB$S_ACCOUNT		;  Filled in by PROCSTRT

ASSUME	<CTL$T_ACCOUNT - CTL$T_USERNAME> EQ <JIB$T_ACCOUNT - JIB$T_USERNAME>

	CTL	GQ_LOGIN		; SYSTEM TIME AT PROCESS CREATION
	.LONG	0,0			;

	CTL	GL_FINALSTS		; FINAL EXIT STATUS FOR PROCESS
	.LONG	0			; 

	CTL	GL_WSPEAK		; PEAK WORKING SET SIZE
	.LONG	0			;

	CTL	GL_VIRTPEAK		; PEAK VIRTUAL SIZE
	.LONG	0			;

	CTL	GL_VOLUMES		; COUNT OF VOLUMES MOUNTED
	.LONG	0			;

	CTL	GQ_ISTART		; IMAGE ACTIVATION TIME
	.LONG	0,0

	CTL	GL_ICPUTIM		; INITIAL IMAGE CPU TIME
	.LONG	0

	CTL	GL_IFAULTS		; INITIAL IMAGE FAULT COUNT
	.LONG	0

	CTL	GL_IFAULTIO		; INITIAL IMAGE FAULT I/O COUNT
	.LONG	0

	CTL	GL_IWSPEAK		; IMAGE WORKING SET PEAK
	.LONG	0

	CTL	GL_IPAGEFL		; IMAGE PAGE FILE PEAK USAGE
	.LONG	0

	CTL	GL_IDIOCNT		; INITIAL IMAGE DIRECT I/O COUNT
	.LONG	0

	CTL	GL_IBIOCNT		; INITIAL IMAGE BUFFERED I/O COUNT
	.LONG	0

	CTL	GL_IVOLUMES		; INITIAL IMAGE VOLUME MOUNT COUNT
	.LONG	0

	CTL	T_NODEADDR		; REMOTE NODE ADDRESS (BINARY)
	.BYTE	0				; BYTE COUNT BYTE
	.BLKB	6				; 6 BYTES MAX

	CTL	T_NODENAME		; REMOTE NODE NAME (ASCII)
	.BYTE	0				; BYTE COUNT BYTE
	.BLKB	6				; 6 CHARACTERS MAX

	CTL	T_REMOTEID		; REMOTE ID
	.BYTE	0				; BYTE COUNT BYTE
	.BLKB	16				; 16 CHARACTERS MAX

	.BLKB	1			; LONGWORD ALIGN SECTION

;********************************
; End of adjacent accounting data
;********************************

	CTL	GQ_PROCPRIV		; PROCESS PRIVILEGE MASK
	.LONG	-1,-1			;  ALL PRIVILEGES PERMITTED

	CTL	GL_USRCHMK		; PER-PROCESS VECTOR TO USER CHANGE MODE
	.LONG	0			; TO KERNEL HANDLER

	CTL	GL_USRCHME		; PER-PROCESS VECTOR TO USER CHANGE MODE
	.LONG	0			; TO EXECUTIVE HANDLER

	CTL	GL_POWERAST		; POWER FAIL AST ADDRESS
	.LONG	0			;
	CTL	GB_PWRMODE		; ACCESS MODE FOR POWER FAIL AST
	.BYTE	0			;

	CTL	GB_SSFILTER		; SYS SERV INHIBIT FILTER MASK
	.BYTE	0	
	.BLKB	2			; SPARE

	.PAGE

;
;	ARRAY OF FINAL EXCEPTION VECTORS - ONE PER MODE
;
;	THESE VECTORS ARE USED TO LOCATE AN EXCEPTION HANDLER WHEN ALL
;	OTHER METHODS FAIL.  PERMITS DEBUGGERS TO RECEIVE CONTROL EVEN
;	WHEN THE STACK IS CLOBBERED.
;
	CTL	AL_FINALEXC		; FINAL EXCEPTION HANDLER ARRAY
	.LONG	EXE$EXCPTN		; KERNEL MODE
	.LONG	EXE$EXCPTNE		; EXECUTIVE MODE
	.LONG	0			; SUPERVISOR MODE
	.LONG	0			; USER MODE
;
;	POINTER TO BASE OF CHANNELS
;
	CTL	GL_CCBBASE		; BASE OF I/O CHANNELS
	.LONG	0			; FILLED IN IN PROCSTRT
	CTL	GQ_DBGAREA		; DEBUG AREA
	.LONG	64*1024			; SIZE
	.LONG	DBGAREA			; ADDRESS
;
;  POINTER TO RMS IMAGE
;
	CTL	GL_RMSBASE
	.LONG	0			; POINT TO RMS IN SYSTEM SPACE
;
;	PROCESS PERMANENT MESSAGE SECTION POINTER AND DEFAULT DISPLAY FLAGS
;
	CTL	GL_PPMSG		; ADDRESS OF PROCESS PERM. MSG SECTION
	.QUAD	0			; STARTING/ENDING ADDRESS OF SECTION

	CTL	GB_MSGMASK		; DEFAULT MESSAGE DISPLAY FLAGS
	.BYTE	15			; DEFAULT: FAC,SEV,IDENT AND TEXT (ALL)

	CTL	GB_DEFLANG		; DEFAULT MESSAGE LANGUAGE
	.BYTE	0			; (CURRENTLY UNUSED)

	CTL	GW_PPMSGCHN		; CHANNEL TO PROCESS PERM. MESSAGE
	.WORD	0			; SECTION (MAPPED IN CTL$GL_PPMSG)

	CTL	GL_USRUNDWN		; PER-PROCESS VECTOR TO USER RUNDOWN
	.LONG	0			;  SERVICE

	CTL	GL_PCB			; ADDRESS OF PROCESS CONTROL BLOCK
	.LONG	0			; INIT BY PROCSTRT

	CTL	GL_RUF			; POINTER TO RECOVERY UNIT BLOCKS
	.LONG	0

	CTL	GL_SITESPEC		; SITE-SPECIFIC PER-PROCESS CELL
	.LONG	0

	CTL	GL_KNOWNFIL		; PROCESS KNOWN FILE LIST POINTER
	.LONG	0

	CTL	AL_IPASTVEC		; VECTOR OF IPAST ADDRESSES
	.LONG	0,0,0,0,0,0,0,0

	CTL	GL_CMCNTX		; ADDRESS OF AME CONTEXT PAGE
	.LONG	CTL$AL_CMCNTX

	CTL	GL_IAFLNKPTR		; ADDRESS OF IAF LIST (FOR DEBUGGER)
	.LONG	CTL$GL_IAFLINK

	CTL	GL_F11BXQP		; ADDRESS OF F11B XQP QUEUE AND
	.LONG	0			; DISPATCH VECTORS

	CTL	GQ_P0ALLOC		; HEADER OF P0 EXTENTION TO PROCESS
	.LONG	0,0			; ALLOCATION REGION

	CTL	GL_PRCALLCNT		; COUNT OF BYTES OF PROCESS ALLOCATION
	.LONG	0			; REGION USABLE BY IMAGE REQUESTS.

	CTL	GL_RDIPTR		; POINTER TO RIGHTS DATABASE IDENTIFIER (RDI) BLOCK
	.LONG	0

	CTL	GL_LNMDIRSEQ		; SEQUENCE NUMBER FOR CACHE OF LOGICAL
	.LONG	0			;  NAME TABLE TRANSLATIONS

	CTL	GQ_HELPFLAGS		; HELP FLAGS, ONE LONGWORD FOR USE 
	.LONG	0,0			; NOW, ONE FOR LATER

	CTL	GQ_TERMCHAR		; HOME FOR TERMINAL CHARACTERISTICS
	.LONG	0 , 0			; NEED A QUADWORD

	CTL		GL_KRPFL	; P1 POOL LOOKASIDE LIST FORWARD LINK
	.LONG		CTL$GL_KRPFL
	CTL		GL_KRPBL	; P1 POOL LOOKASIDE LIST BACKWARD LINK
	.LONG		CTL$GL_KRPFL

	CTL		GL_CREPRC_FLAGS	; $CREPRC FLAGS
	.LONG	0			; 

	CTL	GL_THCOUNT		; COUNT OF TERMINATION HANDLERS FOR
	.LONG	0			;  EXEC MODE,
	.LONG	0			;  SUPERVISOR MODE, AND
	.LONG	0			;  USER MODE

;******************************************************************************
;
;	END OF VECTOR PAGE
;
;******************************************************************************
CTLVECEND=.
	.IF GREATER	<CTLVECEND-CTLVECPAG>-512
	.ERROR		; *** VECTOR PAGE NOW LARGER THAN A PAGE ***
	.ENDC

	.IFF				; ASSEMBLE REST ONLY FOR SHELL MODULE:

	.PAGE
	.SBTTL	PROCESS I/O SEGMENT
;----------------------------------------------------------------------------
;
;	PROCESS I/O SEGMENT INITIAL CONTENT
;
;----------------------------------------------------------------------------

	.ALIGN	PAGE			; PAGE BOUNDARY
PIO:					; BASE OF PROCESS I/O SEGMENT

	PIO	GL_FMLH			; FREE MEMORY LIST HEAD
	.LONG	PIO$GL_FMLH,PIO$GL_FMLH	;	(Empty List)

	PIO	GL_IIOFSPLH		; FREE LIST HEADER FOR IMAGE I/O SEG
	.LONG	PIO$GL_IIOFSPLH		;
	.LONG	PIO$GL_IIOFSPLH		;

	PIO	GW_STATUS		; RMS OVERALL STATUS
	.WORD	0			;


PIO$S_EODSTR==16			; SIZE OF STRING + COUNT BYTE
	PIO	GT_ENDSTR		; END OF DATA STRING
	.BLKB	PIO$S_EODSTR		; (COUNTED STRING)

	PIO	GW_DFPROT		; DEFAULT FILE PROTECTION
	.WORD	^XFA00			; SYS:RWED, OWN:RWED, GROUP: RE, WORLD:N

	PIO	GB_DFMBC		; DEFAULT MULTI-BLOCK COUNT
	.BLKB	1

	PIO	GB_DFMBFSDK		; DEFAULT MULTI-BUFFER COUNT SEQ. DISK
	.BLKB	1

	PIO	GB_DFMBFSMT		; DEFAULT MULTI-BUFFER COUNT MAGTAPE
	.BLKB	1

	PIO	GB_DFMBFSUR		; DEFAULT MULTI-BUFFER COUNT UNIT REC.
	.BLKB	1

	PIO	GB_DFMBFREL		; DEFAULT MULTI-BUFFER COUNT RELATIVE
	.BLKB	1

	PIO	GB_DFMBFIDX		; DEFAULT MULTI-BUFFER COUNT INDEXED
	.BLKB	1

	PIO	GB_DFMBFHSH		; DEFAULT MULTI-BUFFER COUNT HASHED
	.BLKB	1

	PIO	GB_DFNBC		; Network block count transfer size
	.BLKB	1

	PIO	GB_RMSPROLOG		; Structure level for RMS files
	.BLKB	1

	PIO	GW_RMSEXTEND		; Extend quantity for RMS files
	.BLKW	1

	.ALIGN	LONG

	PIO	GL_DIRCACHE		; DIRECTORY CACHE LIST HEAD
	.LONG	PIO$GL_DIRCACHE		; EMPTY LIST
	.LONG	PIO$GL_DIRCACHE

	PIO	GL_DIRCFRLH		; FREE LIST FOR DIRECTORY CACHE NODES
	.LONG	0			;   (NOTE: SINGLY LINKED)

	PIO	GL_RULOCK		; List of locks held for Recovery Units
	.LONG	0			;   (Note: Singly Linked)

	PIO	GL_NXTIRBSEQ		; Next sequence number for IRB$L_IDENT
	.LONG	0

	.PAGE

	.ALIGN	QUAD

;
;	PROCESS I/O SEGMENT CONTEXT AREA
;
	PIO	GW_PIOIMPA		;
	.WORD	0			; FLAGS
	.WORD	PRT$C_UREW		; I/O BUFFER PROTECTION
	.LONG	0,0			; PIO SEGMENT, SET UP BY PROCSTRT

	PIOL	A1			; FREE PAGE LIST HEAD
	.LONG	PIOLA1,PIOLA1		; FREE LIST HEADER
	.BLKL	1			; SP SAVED LONGWORD
	.LONG	PIO2A10			; IFAB TABLE ADDRESS
	.LONG	PIO2A20			; IRAB TABLE ADDRESS
	.LONG	IMP$C_NPIOFILES		; # OF SLOTS PER TABLE

	.PAGE
;
;	IMAGE I/O SEGMENT CONTEXT AREA
;
	.ALIGN	QUAD

	PIO	GW_IIOIMPA		; IMAGE I/O IMPURE AREA
	.WORD	1			; FLAGS WITH IIO SEGMENT SET
	.WORD	PRT$C_UREW		; PROTECTION STO SET ON PAGES

	.LONG	0			; MUST BE INITIALIZED BY THE IMAGE
					; ACTIVATOR TO THE ADDRESS OF THE FIRST
					; PAGE IN THE IMAGE I/O SEGMENT.
					; (NOTE: THIS LONGWORD IS REFERENCED BY:
					; PIO$GW_IIOIMPA+IMP$L_IOSEGADDR)
	.LONG	0			; LENGTH OF IMAGE I/O SEGMENT IN BYTES
					; MUST BE INITIALIZED BY THE IMAGE ACTIVATOR.
					; (NOTE: THIS LONGWORD IS REFERENCED BY:
					; PIO$GW_IIOMPA+IMP$L_IOSEGLEN)

	PIOL	B1			;
	.LONG	PIOLB1,PIOLB1		; FREEPAGE LIST HEAD


	PIOL	B2			; 
	.BLKL	1			; SP SAVE LONGWORD

	.LONG	PIOLB10			; IFAB TABLE ADDRESS
	.LONG	PIOLB20			; IRAB TABLE ADDRESS
	.LONG	IMP$C_ENTPERSEG		; # OF SLOTS PER TABLE

	PIOL	B10			;
	.LONG	0			; LINK TO NEXT TABLE SEGMENT
	.BLKL	IMP$C_ENTPERSEG		; IFAB TABLE SLOTS

	PIOL	B20			; 
	.LONG	0			; LINK TO NEXT TABLE SEGMENT
	.BLKL	IMP$C_ENTPERSEG		; IRAB TABLE SLOTS

	PIO	AL_RMSEXH		; EXIT HANDLER CONTROL BLOCK
	.BLKL	2			;
	.LONG	1			; ARGUMENT COUNT
	.LONG	PIO$AL_RMSEXH+8		; STORE EXIT CODE OVER ARGUMENT COUNT

	PIO	GQ_IIODEFAULT		; DEFAULT IMAGE I/O AREA
	.LONG	0,0

	.ALIGN	LONG

;
;	DEFAULT DIRECTORY INFORMATION
;
	PIO	GT_DDSTRING		; DEFAULT DIRECTORY STRING

FIL$GT_DDSTRING==PIO$GT_DDSTRING	; FILE READ DEFAULT DIRECTORY STRING

; THE DEFAULT DIRECTORY STRING IN THE PROCESS QUOTA BLOCK MOVED FROM A
; CREATOR PROCESS TO A NEWLY CREATED PROCESS MUST BE AT LEAST AS LARGE
; AS THE LARGEST DIRECTORY STRING ALLOWED BY RMS.

	ASSUME	PQB$S_DDSTRING GE FWA$C_MAXDIRLEN

TEMP$...=.
	.ASCIC	\[SYSEXE]\		; DEFAULT DIRECTORY STRING

; ****************************** NOTE WELL ******************************
;
; THE DEFAULT DIRECTORY STRING MUST BE THE LAST ELEMENT TO APPEAR IN THE
; RMS CONTEXT AREA. IN FACT, IT HANGS OFF THE END OF THE PAGE. IF STORAGE
; WERE ALLOCATED, THE SHELL WOULD GROW IN SIZE BY ONE PAGE, AN UNNECESSARY
; WASTE OF SPACE. THE .BLKB DIRECTIVE HERE IS SYMBOLIC, TO EXPRESS THE SIZE
; OF THE DIRECTORY STRING IF SPACE WERE REALLY ALLOCATED.
;
;	.BLKB	PQB$S_DDSTRING-<.-TEMP$...>	; FILL TO MAXIMUM POSSIBLE SIZE
;
; ***************************** END OF NOTE *****************************
	.PAGE
	.SBTTL	INITIALZE SHELL WITH SYSGEN PARAMETERS
;++
; FUNCTIONAL DESCRIPTION:
;	SWP$SHELINIT IS CALLED BY THE SWAPPER FOLLOWING THE INSWAP OF A SHELL
;	PROCESS TO APPLY THE SYSGEN PARAMETERS AND CONFIGURE THE PROCESS
;	FOR THE PROPER WORKING SET SIZE AND VIRTUAL ADDRESS SPACE.
;	THIS CODE IS CONTAINED IN PAGES THAT ARE TO BECOME THE KERNEL
;	STACK FOR THE NEW PROCESS.
;
; CALLING SEQUENCE:
;	JSB	@#SWP$SHELINIT
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS
;	R9 - SWAPPER MAP POINTER
;	R10 - PTC$M_VALID!PTE$C_ERKW!PTE$M_MODIFY
;	R11 - SWAPPER END MAP POINTER
;
; OUTPUT PARAMETERS:
;	PHD AND CONTROL REGION FOR THE NEW PROCESS
;
;--

	.ALIGN	PAGE			; START OUT ON PAGE BOUNDARY

SWP$SHELINIT==.-SHELL			;
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER BASE ADDRESS
	MOVL	@#SWP$GL_SHELLSIZ,R0	; GET PAGES ALLOCATED FOR SHELL
	MOVAL	(R9)[R0],R11		; COMPUTE END ADDRESS IN MAP
	ASHL	#2,@#SWP$GL_SHELIO,R0	; GET I/O SIZE OF SHELL
	SUBL3	R9,R11,R1		; COMPUTE SIZE OF EXTENSION PAGES
	SUBL	R0,R1			; LESS I/O SIZE
	ROTL	#3,R1,R1		; CONVERT TO DOUBLE QUAD COUNT
	ROTL	#9,@#SWP$GL_SHELIO,R0	; COMPUTE ADDRESS AT END OF I/O TRANSFER
10$:	CLRQ	(R0)+			; CLEAR PAGES
	CLRQ	(R0)+			; NOT READ FROM SHELL
	SOBGTR	R1,10$			; 
	MOVL	R5,R2			; VA OF PHD
	JSB	@#MMG$SVAPTECHK		; GET SVA OF FIRST PHD PTE
	MOVL	(R9)+,(R3)+		; MAP PROCESS HEADER FIXED PAGE
	MOVZWL	@#SWP$GW_WSLPTE,R1	; GET COUNT OF ADDED PAGES FOR WSL+PST
	BEQL	30$			; BR IF NONE
	DECL	R1			; LESS FIXED HEADER PAGE
20$:	MOVL	-(R11),(R3)+		; MAP A WSL PAGE
	SOBGTR	R1,20$			; DO THEM ALL
30$:	MOVZWL	@#SWP$GW_EMPTPTE,R0	; GET COUNT OF EMPTY PAGES
	MOVAL	(R3)[R0],R3		; UPDATE MAP POINTER
	MOVZWL	@#SWP$GW_BAKPTE,R0	; GET COUNT OF BAK/WSL/VAL/LCK PTE
40$:	MOVL	-(R11),(R3)+		; MAP BAK/WSL/VAL/LCK PAGES
	SOBGTR	R0,40$			;
	INVALID				; INVALIDATE TRANSLATION BUFFER
;
;	ALL OF THE HEADER PAGES LESS PAGE TABLES HAVE NOW BEEN MAPPED
;
	MOVZWL	@#SWP$GW_IBALSETX,R8	; GET BALANCE SLOT INDEX
	MOVW	R8,PHD$W_PHVINDEX(R5)	; SET INTO PROCESS HEADER
	CVTWB	@#SGN$GW_DFPFC,PHD$B_DFPFC(R5)	; SET DEFAULT PAGE FAULT CLUSTER
	CLRL	R0			; COUNT MAXIMUM FREE SPACE TILL NOW
	MOVZWL	@#MMG$GW_MINPFIDX,R3	; START SCAN AT FIRST PAGE FILE
	MOVL	R3,R1			; SET DEFAULT PAGING FILE TO CHOOSE
	MOVL	@#MMG$GL_PAGSWPVC,R6	; GET ADDRESS OF PAGE FILES VECTOR
;
;	CHECK FOR SPECIFICATION OF A PAGE FILE
;	THIS IS TAKEN AS ADVICE ONLY, NORMAL ALGORITHM USED IF SELECTION IMPOSSIBLE
;
	MOVZWL	PCB$B_PGFLINDEX(R4),R2	; GET THE REQUESTED PAGE FILE INDEX
	BEQL	44$			; NONE SPECIFIED
	CMPL	R2,R1			; CHECK FOR LEGAL INDEX
	BLSSU	44$			; A SWAP FILE WAS SPECIFIED - GIVE UP
	CMPL	R2,@#MMG$GL_MAXPFIDX
	BGTRU	44$			; TOO HIGH - GIVE UP
	MOVL	(R6)[R2],R8		; GET PFL BLOCK ADDRESS
	BBC	#PFL$V_INITED,PFL$B_FLAGS(R8),44$ ; BRANCH IF NOT USABLE
	MOVL	R2,R1
	BRB	47$			; WE HAVE A GOOD SELECTION
44$:	MOVL	(R6)[R3],R2		; GET ADDRESS OF NEXT PAGE FILE BLOCK
	BISB	#PFL$M_INITED,PCB$W_PGFLCHAR(R4); ADD INITED TO THE REQUESTED FLAGS
	BISB3	PCB$W_PGFLCHAR(R4),PFL$B_FLAGS(R2),R8 ; OR THE FLAGS TOGETHER
	CMPB	R8,PFL$B_FLAGS(R2)	; DID THEY CHANGE
	BNEQ	46$			; YES - NO MATCH - TRY AGAIN
	CMPL	PFL$L_FREPAGCNT(R2),R0	; CHOOSE PAGING FILE WITH MOST FREE PAGES
	BLEQ	46$			; BRANCH IF WE HAVE BETTER CANDIDATE
	MOVL	PFL$L_FREPAGCNT(R2),R0	; SAVE NEW FREE PAGE COUNT
	MOVL	R3,R1			; SAVE NEW INDEX
46$:	AOBLEQ	@#MMG$GL_MAXPFIDX,R3,44$; LOOP THROUGH ALL PAGE FILES
47$:	MOVB	R1,PHD$B_PAGFIL(R5)	; SET PAGING FILE INDEX
	MOVB	@#SGN$GB_PGTBPFC,PHD$B_PGTBPFC(R5); SET SYSTEM DEFAULT PT CLUSTER
	MOVW	#SWP$C_KSTACK_WSL,PHD$W_WSLIST(R5); INIT POINTER TO LIST BASE
	MOVL	@#SGN$GL_PHDPAGCT,R7	; GET TOTAL COUNT OF HEADER PAGES
	MOVZWL	@#SWP$GW_WSLPTE,R6	; GET COUNT OF WSL HEADER PAGES
	ASHL	#9,R6,PHD$L_PSTBASOFF(R5)	; SET END AS BASE FOR PST
	ADDW	@#SWP$GW_EMPTPTE,R6	; ASSUMES NO OVERFLOW POSSIBLE
	ASHL	#7,R6,R6		; CONVERT TO LONGWORD COUNT
	MOVL	R6,PHD$L_WSLX(R5)	; SET BASE OFFSET TO WSLX AREA
	ADDL	@#SGN$GL_PTPAGCNT,R7	; ADD PAGE TABLES TO COUNT
	ADDL3	#1,R7,R0		; ROUND TO LONGWORD SIZE
	DIVL	#2,R0			; 
	ADDL	R0,R6			; ALLOCATE SPACE IN WHOLE LONGWORDS
	MOVL	R6,PHD$L_BAK(R5)	; SET BASE OF BACKING STORE VECTOR
	ADDL	R7,R6			; ALLOCATE SPACE FOR BACKING STORE VECTOR
	MULL	#4,R6			; CONVERT TO BYTE OFFSET
	MOVL	R6,PHD$L_PTWSLELCK(R5)	; SET BASE OF LOCKED COUNT VECTOR
	MOVL	@#SGN$GL_PTPAGCNT,R7	; GET COUNT OF PAGE TABLES
	MOVAB	(R6)[R7],PHD$L_PTWSLEVAL(R5)	; ALLOCATE AND SET BASE OF VAL CNT
	MOVAB	@PHD$L_PTWSLEVAL(R5)[R5],R0	; SET BASE FOR VALID COUNT VEC
	MNEGL	#1,R2				; MINUS ONE FOR BACKGROUND
	MOVAB	@PHD$L_PTWSLELCK(R5)[R5],R1	; AND BASE FOR LOCKED COUNT
50$:	MOVB	R2,(R0)+		; INIT BOTH COUNT VECTORS TO MINUS ONE
	MOVB	R2,(R1)+		; 
	SOBGTR	R7,50$			; FOR ALL PAGE TABLE SLOTS
	ADDB	#KSTACK+1,-2(R1)	; COUNT OF LOCK PAGES FOR SHELL
	ADDB	#KSTACK+3,-2(R0)	; COUNT OF VALID PAGES
	MOVL	@#SGN$GL_PHDAPCNT,R6	; GET ACTUAL HEADER SIZE
	MOVZBL	@#SWP$GB_SHLP1PT,R0	; NUMBER OF PERM PAGE TABLES
	MOVW	R0,PHD$W_PTCNTLCK(R5)	; COUNT OF PT CONTAINING LOCKED PAGES
	MOVW	R0,PHD$W_PTCNTVAL(R5)	; COUNT OF PT CONTAINING VALID PAGES
	MOVW	R0,PHD$W_PTCNTACT(R5)	; COUNT OF ACTIVE PAGE TABLES
	MOVW	R0,PHD$W_PTCNTMAX(R5)	; COUNT OF PT WITH NON-ZERO ENTRIES
	ADDL	R0,R6			; MAKE ROOM IN WSLIST FOR HDR+PGTBLS
	MOVZWL	PHD$W_WSDYN(R5),R7	; GET INDEX TO CURRENT DYNAMIC ENTRIES
	PUSHL	R7			; SAVE POINTER FOR LATER USE
	ADDW	R6,PHD$W_WSLOCK(R5)	; CORRECT LOCK WSL INDEX
	ADDW	R6,PHD$W_WSDYN(R5)	; AND DYNAMIC INDEX
	ADDW	R6,PHD$W_WSNEXT(R5)	; AND NEXT POINTER
	ADDL3	R6,R7,R1		; SET DESTINATION INDEX
	MOVZBL	#SWP$C_NDYN,R0		; SET COUNT OF DYNAMIC PAGES
60$:	MOVL	(R5)[R7],(R5)[R1]	; MOVE A DYNAMIC WORKING SET PAGE
	INCL	R1			; NEXT DESTINATION
	INCL	R7			; NEXT WSL ENTRY
	SOBGTR	R0,60$			; MOVE ALL DYNAMIC PAGES
	MOVL	#<WSL$M_VALID-		; WSL ENTRIES FOR HEADER ARE VALID
		!WSL$M_WSLOCK-		; LOCKED,
		!WSL$C_PPGTBL-		; PROCESS PAGE TABLE,
		!VA$M_SYSTEM>,R8	; AND SYSTEM SPACE
	MOVL	R5,R2			; SET PHD ADDRESS TO GET SVAPTE
	JSB	@#MMG$SVAPTECHK		; SVAPTE TO R3
	MOVL	R8,R0			; MAKE WORKING COPY
	MOVZWL	@#SWP$GW_WSLPTE,R1	; COUNT OF WSLPTE 
	MOVL	(SP)+,R2		; RESTORE WORKING SET INDEX TO LOCKED
	BSBW	FILLPHD			; SET UP FOR VALID PHD PAGES
	MOVZWL	@#SWP$GW_EMPTPTE,R1	; GET COUNT OF EMPTY PTE AGAIN
	MOVAL	(R3)[R1],R3		; ADVANCE SPT ADDRESS
	ASHL	#9,R1,R1		; CONVERT TO BYTE COUNT
	ADDL	R1,R0			; AND UPDATE CURRENT VA
	MOVZWL	@#SWP$GW_BAKPTE,R1	; GET COUNT OF REMAINING HEADER PAGES
	BSBW	FILLPHD			; SET UP FOR VALID PHD PAGES
	MOVL	@#SGN$GL_PTPAGCNT,R1	; GET COUNT OF PAGE TABLES
65$:	MOVL	#PTE$C_ERKW,-4(R3)[R1]	; SET A DEMAND ZERO PAGE FOR PAGE TABLES
	SOBGTR	R1,65$			; INIT ENTIRE PAGE TABLE AREA
	MOVZBL	@#SWP$GB_SHLP1PT,R1	; GET COUNT OF P1 PAGE TABLES
	MNEGL	R1,R6			; NEGATE COUNT
	DECL	R6			; LESS ONE MORE FOR DEBUGGER PAGE
	ADDL	@#SGN$GL_PTPAGCNT,R6	; PAGE OFFSET TO PAGE TABLE
	MOVAL	(R3)[R6],R3		; COMPUTE SVAPTE
	ASHL	#9,R6,R6		; CONVERT TO BYTE OFFSET
	ADDL	R6,R0			; ADD TO CURRENT BASE WSL
	PUSHR	#^M<R1,R3>		; SAVE KEY REGS
	SUBL	S^#SWP$C_SHLP1PT,R1	; LESS STANDARD P1 PAGE TABLES
	BLEQ	80$			; BR IF NO EXTENSIONS
70$:	MOVL	-(R11),(R3)+		; STORE A PTE FOR EXTENSION
	SOBGTR	R1,70$			; DO ALL EXTENSION PAGE TABLES
80$:	MOVL	S^#SWP$C_SHLP1PT,R1	; SET COUNT OF STANDARD
90$:	MOVL	(R9)+,(R3)+		; STORE PTE FOR STANDARD
	SOBGTR	R1,90$			; DO ALL STANDARD P1PT
	POPR	#^M<R1,R3>		; RESTORE KEY REGISTERS
	BSBW	FILLPHD			; SET UP FOR VALID PHD PAGES
	ROTL	#9,@#SGN$GL_PHDPAGCT,R0	; OFFSET FOR P0BR
	ADDL	R0,PHD$L_P0BR(R5)	; FORM P0BR BASE VALUE
	ROTL	#9,@#SGN$GL_PTPAGCNT,R1	; OFFSET TO P1BR
	ADDL	R0,R1			; 
	ADDL	R1,PHD$L_P1BR(R5)	; FORM P1BR BASE VALUE
	SUBL	R0,PHD$L_FREP1VA(R5)	; COMPUTE CORRECT FREP1VA
	SUBL	R0,R1			; EXTRACT PT SIZE TOTAL
	ASHL	#-9,R0,R0		; BACK TO PAGE COUNT
	SUBL	R0,PHD$L_P1LR(R5)	; NOW CORRECT P1 LENGTH REGISTER
	ASHL	#-2,R1,R1		; COUNT OF AVAILABLE PTES
	SUBL	R0,R1			; DIMINISH BY PHD WINDOW SIZE
	ADDL	R1,PHD$L_FREPTECNT(R5)	; AND FORM COUNT OF FREE PTES

; THE FOLLOWING SHUFFLE OF THE WORKING SET LIST REARRANGES ALL WORKING SET
; LIST ENTRIES THAT ARE NOT KERNEL STACK PAGES. THE SWAPPER MAP IS BEING
; REORDERED TO AGREE WITH THE WORKING SET LIST DEFINED IN THE SHELL.

	.REPEAT	SHUFFLE_COUNT		; COUNT FROM WSL TEMPLATE
	MOVL	(R9)+,(R11)+		; REARRANGE SWAP PAGE LIST 
	.ENDR

	CLRL	(R11)+			; SET STOPPER IN MAP
	ADDL3	#512,PHD$L_FREP1VA(R5),-	; SET ADDRESS OF WINDOW
		@#<SWP$AL_PTRPAG+-	; INTO POINTER PAGE
		<CTL$GL_PHD-CTL$GL_VECTORS>>	; THROUGH SWAPPER MAP
	BBSS	#PCB$V_PHDRES,PCB$L_STS(R4),100$; MARK PHD RESIDENT
100$:					; 
	MOVZWL	PHD$W_WSLIST(R5),R0	; GET INDEX TO WS BASE
	DECL	R0			;
	ADDW3	R0,@#SGN$GL_MAXWSCNT,R1			; CALC MAX AUTHORIZED
	MOVW	R1,PHD$W_WSAUTH(R5)			; SET MAX AUTHORIZED
	MOVW	R1,PHD$W_WSQUOTA(R5)			; AND QUOTA
	MOVW	R1,PHD$W_WSEXTENT(R5)			; AND EXTENT
	MOVW	R1,PHD$W_WSAUTHEXT(R5)			; AND AUTHORIZED EXTENT
	MOVW	@#SGN$GW_MINWSCNT,PHD$W_WSFLUID(R5)	; SET FLUID REQUIREMENT
	MOVW	@#SGN$GW_DFWSCNT,R1			; GET DEFUALT WS SIZE
	ADDW	R1,R0					; CALC LAST
	MOVW	R0,PHD$W_WSLAST(R5)			; SET LAST
	MOVW	R0,PHD$W_DFWSCNT(R5)			; AND DEFAULT COUNT
	MOVW	R1,PHD$W_WSSIZE(R5)			; SET WS SIZE
	ADDL	R5,PHD$L_P0BR(R5)	; BIAS P0 BASE REGISTER
	ADDL	R5,PHD$L_P1BR(R5)	; AND P1 BASE REGISTER ALSO
;
;	REMAP SYSTEM SERVICE VECTORS FOR THIS PROCESS
;
	MOVL	#P1SYSVECTORS,R2	; PUT THEM HERE
	JSB	@#MMG$SVAPTECHK		; GET ADDRESS OF PTE FOR VECTORS
	MOVL	@#MMG$GL_SPTBASE,R0	; SYSTEM PAGE TABLE
	MOVZBL	#SGN$C_SYSVECPGS,R1	; NUMBER OF PAGES
110$:	BISL3	#PTE$M_WINDOW,(R0)+,(R3)+
	SOBGTR	R1,110$
;
;	THE PAGE TABLE ARRAY FOR LOCKED WSLE'S MUST BE INCREMENTED ONE
;	FOR EACH WINDOW PTE.  THIS BALANCES THE LOGIC IN $CREPAG/$DELPAG
;	THAT PLACES THE PAGE TABLE PAGE IN THE LOCKED PORTION OF THE
;	WORKING SET FOR USER PFNMAPPED PAGES.
;
;	THIS LOGIC ASSUMES THAT THE VECTOR PAGES ALL LIVE IN THE SAME
;	PAGE TABLE PAGE.
;
	SUBL3	PHD$L_P0BR(R5),R3,R0	;BYTE OFFSET OF PTE
	ASHL	#-9,R0,R0		;BYTE INDEX OF CONTAINING PAGE TABLE
	ADDL	PHD$L_PTWSLELCK(R5),R0 ;COMPUTE THE ADDRESS OF THE LOCKED
	ADDL	R5,R0			; WORKING SET LIST PAGE TABLE BYTE
	ADDB	#SGN$C_SYSVECPGS,(R0)	; ARRAY AND INCR BY NUMBER OF VEC PAGES

;
;	FINISH UP INITIALIZATION, SET DATA NEEDED BY SWAPPER
;
	MNEGL	PCB$L_WSSWP(R4),PCB$L_WSSWP(R4)
					; INDICATE SHELL FINISHED TO SWAPPER
	CVTLW	PCB$L_SWAPSIZE(R4),PHD$W_SWAPSIZE(R5) ; SET INITIAL SWAP ALLOCATION

; CLEAR THE PCB FIELDS THAT WERE USED TO CARRY PAGE FILE AND SWAP FILE 
; INFORMATION TO THE NEW PROCESS. THESE FIELDS WILL BECOME THE COMMON EVENT
; FLAG CLUSTER POINTERS.

	ASSUME PCB$L_EFC3P EQ <PCB$L_EFC2P + 4>
	ASSUME PCB$W_PGFLCHAR EQ PCB$L_EFC2P
	ASSUME PCB$B_PGFLINDEX EQ <PCB$L_EFC2P + 2>
	ASSUME PCB$L_SWAPSIZE EQ <PCB$L_EFC2P + 4>

	CLRQ	PCB$L_EFC2P(R4)		; START WITH NO COMMON EF CLUSTERS

	RSB				; RETURN

	.PAGE
	.SBTTL	FILLPHD - SETUP A VALID PHD PTE
;
;	R0 - WORKING SET LIST ENTRY, ADDRESS AND FLAGS (UPDATED)
;	R1 - COUNT OF PAGES TO FILL (UPDATED)
;	R2 - WORKING SET LIST INDEX (UPDATED)
;	R3 - SVAPTE FOR PHD PAGE (UPDATED)
;	R4 - PCB ADDRESS
;	R5 - PHD ADDRESS
;	R7 - SCRATCH
;	R8 - SCRATCH
;	R10 - PFN$C_ERKW!PFN$M_MODIFY!PFN$M_VALID
;
FILLPHD:				; SETUP VALID PHD PTES
10$:	MOVL	R0,(R5)[R2]		; STORE WORKING SET LIST ENTRY
	BICL3	R10,(R3)+,R7		; GET PFN FROM SPT
	PUSHL	@#PFN$AB_STATE		; STACK ADDRESS BASE FOR PFN STATE
	MOVB	#<PFN$C_ACTIVE!PFN$M_MODIFY>,@(SP)+[R7]	; MARK PAGE ACTIVE
	PUSHL	@#PFN$AB_TYPE		; STACK ADDRESS BASE FOR PFN TYPE
	MOVB	#PFN$C_PPGTBL,@(SP)+[R7]; SET PAGE TYPE TO PAGE TABLE
	PUSHL	@#PFN$AL_BAK		; STACK ADDRESS BASE FOR PFN BAK
	MOVZBL	PHD$B_PAGFIL(R5),R8	; GET PAGE FILE NUMBER
	ROTL	#PFN$V_PGFLX,R8,@(SP)+[R7]	; SET BACKING STORE ADDRESS
	PUSHL	@#PFN$AL_PTE		; STACK ADDRESS OF PFN PTE BACK POINTER
	MOVAL	-4(R3),@(SP)+[R7]	; SET PTE BACK POINTER FOR PAGE
;
;  The following use of the PFN_REFERENCE macro must force absolute addressing
;  because of the peculiar method in which this code executes. In addition, 
;  this code is not a part of the nonpaged executive and cannot have its opcode
;  automatically fixed up by INIT.
;
	PUSHL	@#PFN$Ax_WSLX		; STACK BASE ADDRESS OF WSLX VECTOR
		PFN_REFERENCE	-
	MOVW	<R2,@(SP)+[R7]>,- 	; SET WSLX FOR PAGE
		LONG_OPCODE=MOVZWL,-
		IMAGE=SHELL,-
		MODE=@#			; FORCE POSITION INDEPENDENCE
	INCL	R2			; NEXT WORKING SET LIST ENTRY
	MOVAL	512(R0),R0		; NEXT VA
	SOBGTR	R1,10$			; FILL ALL REQUESTED PAGES
	RSB				; AND RETURN

	.ALIGN	PAGE			; PAGE ALIGN
SWP$C_SHELLSIZ=<.-SHELL>@-9		; SIZE OF SHELL PROCESS IN PAGES
	.IF GT	SWP$C_SHELLSIZ-8
	.ERROR	SWP$C_SHELLSIZ; Shell size changed, update swapper and FREELIM
	.ENDC

	.PAGE

;
;	Process IFI/ISI Tables
;

; The rest of this module merely defines global symbols and offsets into
; various P1 pages. No more storage is added to the SHELL module.

	.PSECT	$ABS$,ABS

	.=PIOTBL
TBL:
	PIO2	A10			; LINK TO NEXT TABLE SEGMENT 
	.BLKL	1			; INITIALLY ZERO
	.BLKL	IMP$C_NPIOFILES		; IFAB TABLE SLOTS

	PIO2	A20			; LINK TO NEXT TABLE SEGMENT 
	.BLKL	1			; INITIALLY ZERO
	.BLKL	IMP$C_NPIOFILES		; IRAB TABLE SLOTS

	.PAGE
	.SBTTL	COMMAND LANGUAGE INTERPRETER DATA AREA
;----------------------------------------------------------------------------
;		GENERIC COMMAND LANGUAGE INTERPRETER DATA
;----------------------------------------------------------------------------

	.=CLIDATAPAG			; SET BASE VALUE FOR REGION
CTL$AL_CLICALBK::			; CALL BACK VECTOR FOR CLI
	.BLKL	1			; 
	.BLKL	1			; ALLOW FOR EXPANSION
CTL$AG_CLIMAGE::
	.BLKL	2			; VA RANGE INTO WHICH CLI IS MAPPED
CTL$AG_CLITABLE::			; VA RANGE INTO WHICH CLI TABLE IS
	.BLKL	2			; MAPPED.

CTL$GL_UAF_FLAGS::
	.BLKL	1			; FLAGS FROM AUTHORIZATION RECORD

CTL$GT_CLINAME::			; CLI NAME (FILE NAME ONLY)
	.BLKB	PQB$S_CLI_NAME		; STORED AS COUNTED ASCII
CTL$GT_TABLENAME::			; CLI TABLE NAME (FULL FILE SPEC)
	.BLKB	PQB$S_CLI_TABLE		; STORED AS COUNTED ASCII
CTL$GT_SPAWNCLI::			; SPAWN CLI NAME (FILE NAME ONLY)
	.BLKB	PQB$S_SPAWN_CLI		; STORED AS COUNTED ASCII
CTL$GT_SPAWNTABLE::			; SPAWN CLI TABLE NAME (FULL FILE SPEC)
	.BLKB	PQB$S_SPAWN_TABLE	; STORED AS COUNTED ASCII

ASSUME <CTL$GT_TABLENAME -CTL$GT_CLINAME> EQ <PQB$T_CLI_TABLE  -PQB$T_CLI_NAME>
ASSUME <CTL$GT_SPAWNCLI  -CTL$GT_CLINAME> EQ <PQB$T_SPAWN_CLI  -PQB$T_CLI_NAME>
ASSUME <CTL$GT_SPAWNTABLE-CTL$GT_CLINAME> EQ <PQB$T_SPAWN_TABLE-PQB$T_CLI_NAME>

CTL$AG_CLIDATA::			; START OF DATA AREA
CTL$C_CLIDATASZ==CLIDATAEND-CTL$AG_CLIDATA	; SIZE OF DATA AREA

	.PAGE
	.SBTTL	COMPATIBILITY MODE EMULATOR CONTEXT PAGE
;----------------------------------------------------------------------------
;	COMPATIBILITY MODE EMULATOR CONTEXT PAGE
;----------------------------------------------------------------------------
	.=CTL$AG_CMEDATA		; POINT TO START OF AREA
CTL$AL_CMCNTX::				; COMPATIBILITY MODE REGISTER CONTEXT
	.BLKL	10			; SAVED BY EXCEPTION

	.PAGE
	.SBTTL	GLOBAL USER-MODE CONTEXT PAGE
;----------------------------------------------------------------------------
;	GLOBAL USER-MODE-ONLY CONTEXT PAGE
;
;	This page may ONLY be used by user-mode code, since the data
;	has absolutely no protection from errant user-mode programs.
;	Do NOT use this area for cells which cannot be wiped out by
;	any user-mode program at any time during image execution,
;	except when it only prevents that program from running.
;----------------------------------------------------------------------------
	.=UWVECPAG			; POINT TO START OF AREA

CTL$GL_DCLPRSOWN::			; ADDRESS OF DCL WRK AREA CREATED
	.BLKL	1			; BY DCL OR CLI$DCL_PARSE
CTL$GL_CLINTOWN::			; ADDRESS OF CONTEXT BLOCK USED BY
	.BLKL	1			; CLI$INTERFACE PACKAGE IN DCL/MCR

; THE REST OF THIS PAGE IS UNUSED

	.PAGE
	.SBTTL	IMAGE ACTIVATOR CONTEXT PAGE
;----------------------------------------------------------------------------
;	IMAGE ACTIVATOR CONTEXT PAGE
;
;	The following page contains image activator context that must
;	remain behind after an image is activated. The IAFLIST survives
;	across successive activations. The IAFEXE and IAFMERGE lists are
;	cleared when a new image activation is initiated. The FIXUP link
;	is cleared as soon as a given fixup pass completes.
;
;----------------------------------------------------------------------------
	.=IMGACTCTX			; Point to start of area

CTL$GL_IAFLINK::			; Listhead of linked list of fixup vectors 
	.BLKL	1			;  (containing shareable image lists)

CTL$GL_IAFLAST::			; Address of last fixup vector in list
	.BLKL	1			;  (used in normal and merged image activation)

CTL$GL_FIXUPLNK::			; Listhead of linked list of fixup 
	.BLKL	1			;  vectors used during fixup pass

CTL$GL_P1MERGE::			; Listhead of linked list of fixup vectors
	.BLKL	1			;  for images merged into P1 space

; The following data structure is an empty fixup vector that facilitates
; the fixup vector list manipulation. It is plugged into the fixup vector
; lists by PROCSTRT when a process is first created.

CTL$GL_IAFPERM::
	.BLKB	IAF$K_LENGTH

; The following label locates the link field in the just allocated structure.
; While an image is active, it locates the fixup vector for an executable image.
; It is cleared as part of the image activation initialization code path.

CTL$GL_IAFEXE == CTL$GL_IAFPERM + IAF$L_IAFLINK

IAC$GL_IMAGCTX::
	.BLKL	1			; Context that exists for life of image

IAC$GL_PROCCTX::
	.BLKL	1			; Context that exists beyond image exit

IAC$AL_VECADDR::
	.BLKL	4			; Array of altered opcode addresses

IAC$AL_VECOPCOD::
	.BLKB	4			; Array of saved opcodes

IAC$AW_VECRESET::
	.BLKW	4			; Array of offsets used to reset vectors

IAC$AW_VECSET::
	.BLKW	4			; Array of offsets used to locate vectors

; The following linked list contains image control blocks for all of the
; images currently mapped into a process' address space.

IAC$GL_IMAGE_LIST::
	.BLKL	2			; Room for forward and backward links

; The following linked list is used by the image activator to record work
; in progress. It is empty while an image is executing.

IAC$GL_WORK_LIST::
	.BLKL	2			; Room for forward and backward links

; The following list is a potential source of unused image control blocks.
; Although empty when a process is created, it grows to reflect the largest
; number of images activated at the same time.

IAC$GL_ICBFL::
	.BLKL	2			; Room for forward and backward links

; The following two cells locate the ICB for the main image and the ICB for 
; the image most recently merged into the address space.

IAC$GL_MAIN_ICB::
	.BLKL	1			; ICB of main image

IAC$GL_FIRST_ICB::
	.BLKL	1			; ICB of image just merged

IAC$GL_STACK_SIZE::
	.BLKL	1			; Amount by which to expand user stack
	.PAGE

	.IFT				; IF USRVECTOR MODULE:

;
; These symbols (SYS$...) specify which cells in the P1 pointer page may
; be used by any program, regardless of system version, without having
; to link with SYS.STB (and thus, make it system dependant).
;
; These symbols will remain constant forever and will continue to be supported
; from release to release.
;

	.MACRO	USRSYM	SYM,VALCHECK,CTLSYM
	.IF	B,CTLSYM
SYS$'SYM == CTL$'SYM
	.IF	NB,VALCHECK
	.IF	NE,CTL$'SYM'-^X'VALCHECK'
	.ERROR	; *** CTL$'SYM' MUST EQ ^X'VALCHECK' TO REMAIN COMPATIBLE WITH PREVIOUS RELEASES
	.ENDC
	.ENDC
	.IFF
SYS$'SYM == CTL$'CTLSYM
	.IF	NB,VALCHECK
	.IF	NE,CTL$'CTLSYM'-^X'VALCHECK'
	.ERROR	; *** CTL$'CTLSYM' MUST EQ ^X'VALCHECK' TO REMAIN COMPATIBLE WITH PREVIOUS RELEASES
	.ENDC
	.ENDC
	.ENDC
	.ENDM

	.DISABLE TRACEBACK

	USRSYM	GL_CMCNTX,7FFEFF88	; Address of 2 pages of AME storage
	USRSYM	GL_IAFLINK,7FFEFF8C,-	; Points to IMGACT fixup listhead
			GL_IAFLNKPTR
	USRSYM	GL_IMGLSTPTR,7FFEFE84	; Points to ICM list (for debugger)

	.ENDC				; END OF SHELL / USRVECTOR CONDITIONAL

	.END
