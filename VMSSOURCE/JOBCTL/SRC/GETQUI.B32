MODULE GETQUI	(%TITLE	'$GETQUI service'
		IDENT = 'V04-001'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Job controller.
!
! ABSTRACT:
!	This module contains the routines that implement the $GETQUI service.
!
! ENVIRONMENT:
!	VAX/VMS user and kernel mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 16-Feb-1982
!
! MODIFIED BY:
!
!	V04-001	JAK0236		J A Krycka	14-Sep-1984
!		Collect more diagnostic information.
!
!	V03-011	JAK0229		J A Krycka	24-Aug-1984
!		Collect additional diagnostic information.
!
!	V03-010	JAK0220		J A Krycka	18-Jul-1984
!		Add support for SJC$_PAGINATE and SJC$_NOPAGINATE item codes
!		for queue level operations.
!
!	V03-009	JAK0219		J A Krycka	17-Jul-1984
!		Track changes in JOBCTLDEF.REQ and add QUI$_RESERVED_xxx codes.
!
!	V03-008	KPL0001		P Lieberwirth	 9-Jul-1984
!		Protect QUI_DISPLAY_FILE against common form of corrupted queue
!		file by gracefully handling case where SJH is corrupt and has
!		a zero FILE_LIST pointer.  Note: Other changes made at this
!		time in other modules will reduce frequency of this corruption.
!
!	V03-007	JAK0213		J A Krycka	18-May-1984
!		Use newly created LCK$M_NODLCKBLK (no deadlock on blocking AST)
!		option on enqueue service calls that specify a blocking AST
!		routine that will immediately relinquish the lock.
!
!	V03-006	JAK0211		J A Krycka	14-May-1984
!		Continuation of V03-005.
!
!	V03-005	JAK0210		J A Krycka	10-May-1984
!		Conditionally set ROP record locking options.
!
!	V03-004	JAK0209		J A Krycka	09-May-1984
!		Log diagnostic information in DIAG_TRACE vector.
!
!	V03-003	GRR0004		Gregory R. Robert	27-Sep-1983
!		Synchronize AST level use of QUEUE_RAB with non-AST level.
!
!	V03-002	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Change field names, update for symbiont changes, implement
!		current batch job functions.
!
!	V03-001	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!**

REQUIRE 'SRC$:JOBCTLDEF';


FORWARD ROUTINE
	GETQUI_LOCK:			NOVALUE,
	GETQUI_UNLOCK:			NOVALUE,
	GETQUI_SYNCHRONIZE:		NOVALUE,
	GETQUI_RELEASE:			NOVALUE,
	UPDATE_GETQUI_LOCKS:		NOVALUE,
	UPDATE_GETQUI_DATA:		NOVALUE,
	GETQUI_BLOCKING_AST:		NOVALUE,
	WILD_SEARCH_NAME,
	RETURN_PARAMETERS:		NOVALUE,
	RETURN_RESULT,
	QUI_CANCEL_OPERATION,
	QUI_DISPLAY_CHARACTERISTIC,
	QUI_DISPLAY_FILE,
	QUI_DISPLAY_FORM,
	QUI_DISPLAY_JOB,
	QUI_DISPLAY_QUEUE,
	QUI_RESERVED_FUNC_1,
	QUI_RESERVED_FUNC_2,
	QUI_TRANSLATE_QUEUE,
	PROCESS_ONE_OPTION,
	PROCESS_GETQUI_ITEM_LIST,
	FIND_GQC,
	GETQUI_SERVICE,
	DELETE_GETQUI_CONTEXT:		NOVALUE,
	DELETE_OPEN_GETQUIS:		NOVALUE;


EXTERNAL ROUTINE
	ALLOCATE_MEMORY,
	CHECK_R_ACCESS,
	COMPLETE_SRB_OUTPUT_ITEM:	NOVALUE,
	CREATE_SRB:			NOVALUE,
	DEALLOCATE_MEMORY:		NOVALUE,
	FETCH_VARIABLE_DATA:		NOVALUE,
	FIND_PROCESS_DATA:		L_OUTPUT_3,
	LOCATE_SRB_OUTPUT_ITEM,
	LOCK_QUEUE_FILE:		NOVALUE,
	READ_RECORD,
	RELEASE_RECORD:			NOVALUE,
	SEND_SERVICE_RESPONSE_MESSAGE:	NOVALUE,
	SIGNAL_FILE_ERROR:		NOVALUE,
	SYMBIONT_COMPLETED_BLOCKS,
	UNLOCK_QUEUE_FILE:		NOVALUE,
	VALIDATE_OBJECT_NAME;


LINKAGE
	FMG$MATCH_NAME_LINKAGE =
	    JSB(REGISTER=2, REGISTER=3, REGISTER=4, REGISTER=5);


EXTERNAL ROUTINE
	FMG$MATCH_NAME: FMG$MATCH_NAME_LINKAGE ADDRESSING_MODE(GENERAL);


BIND
	VALUE_SEARCH_FLAGS =
	    VALUE_GETQUI_BASE + QUI$_SEARCH_FLAGS * ODSC_S_ENTRY:
	    BBLOCK,
	VALUE_SEARCH_NAME =
	    VALUE_GETQUI_BASE + QUI$_SEARCH_NAME * ODSC_S_ENTRY:
	    BBLOCK,
	VALUE_SEARCH_NUMBER =
	    VALUE_GETQUI_BASE + QUI$_SEARCH_NUMBER * ODSC_S_ENTRY;


MACRO
	GENERATE_TABLE[] =
	    UPLIT(GENERATE_TABLE_1(%REMAINING), BYTE(0)) %,

	GENERATE_TABLE_1[A,B,C,D,E,F]=
	    BYTE(A, B, C, D), WORD(E, F) %;


MACRO
	B_ITEM_CODE=		0,0,8,0 %,	! $GETQUI item code
	B_PARAMETER=		1,0,8,0 %,	! Parameter list offset to block
	B_CASE=			2,0,8,0 %,	! Case index for conversion
	V_PROTECTED=		3,0,1,0 %,	! Item is protected
	W_BYTE_OFFSET=		4,0,16,0 %,	! Byte offset of field
	W_SIZE=			6,0,16,0 %;	! Size of field


LITERAL
	K_COPY_ASCIC=		0,		! Copy ASCIC string
	K_COPY_FORM_NAME=	1,		! Copy form name
	K_COPY_QUEUE_NAME=	2,		! Copy queue name
	K_COPY_SDSC=		3,		! Copy short descriptor
	K_COPY_TRIMMED=		4,		! Copy trimmed value
	K_COPY_VALUE=		5,		! Copy value
	K_COPY_VARIABLE=	6,		! Copy variable field
	K_COMPLETED_BLOCKS=	7,		! COMPLETED_BLOCKS item
	K_FILE_FLAGS=		8,		! FILE_FLAGS item
	K_FILE_STATUS=		9,		! FILE_STATUS item
	K_FORM_FLAGS=		10,		! FORM_FLAGS item
	K_GENERIC_TARGET=	11,		! GENERIC_TARGET item
	K_INTERVENING_BLOCKS=	12,		! INTERVENING_BLOCKS item
	K_INTERVENING_JOBS=	13,		! INTERVENING_JOBS item
	K_JOB_FLAGS=		14,		! JOB_FLAGS item
	K_JOB_STATUS=		15,		! JOB_STATUS item
	K_QUEUE_FLAGS=		16,		! QUEUE_FLAGS item
	K_QUEUE_STATUS=		17,		! QUEUE_STATUS item

	K_REC_1=		5,		! Argument number
	K_REC_2=		7,		!     of block pointers
	K_REC_3=		9,		!

	K_ENTRY_SIZE=		8;		! Size of entry


MACRO
	GQC_LINK=		0,0,32,0 %,	! Link to next block
	GQC_PID=		4,0,32,0 %,	! PID of requestor
	GQC_FLAGS=		8,0,32,0 %,	! Flags
	GQC_WILDCARDS=		8,0,4,0 %,	! Wildcard operation in progress
	GQC_SCX_WILD=		8,0,1,0 %,	! Wildcard characteristic
	GQC_SFX_WILD=		8,1,1,0 %,	! Wildcard form
	GQC_SQX_WILD=		8,2,1,0 %,	! Wildcard queue
	GQC_FLG_WILD=		8,3,1,0 %,	! SEARCH_FLAG forces wildcard
	GQC_SCX_NO_ADV=		8,4,1,0 %,	! Inhibit advancing context
	GQC_SFX_NO_ADV=		8,5,1,0 %,	!     before a wildcard scan
	GQC_SQX_NO_ADV=		8,6,1,0 %,	!     since a list deletion has
	GQC_SJH_NO_ADV=		8,7,1,0 %,	!     already done so
	GQC_SCX_N=		12,0,32,0 %,	! Record number of SCX
	GQC_SCE_N=		16,0,32,0 %,	! Byte offset of SCE
	GQC_SFX_N=		20,0,32,0 %,	! Record number of SFX
	GQC_SFE_N=		24,0,32,0 %,	! Byte offset of SFE
	GQC_SQX_N=		28,0,32,0 %,	! Record number of SQX
	GQC_SQE_N=		32,0,32,0 %,	! Byte offset of SQE
	GQC_SMQ_N=		36,0,32,0 %,	! Record number of SMQ
	GQC_SJH_Q=		40,0,32,0 %,	! Queue type being searched
	GQC_SJH_N=		44,0,32,0 %,	! Record number of SJH
	GQC_SQR_N=		48,0,32,0 %,	! Record number of SQR
	GQC_INTERVENING_BLOCKS=	52,0,32,0 %,	! Intervening pending blocks
	GQC_INTERVENING_JOBS=	56,0,32,0 %;	! Intervening pending jobs


LITERAL
	GQC_K_LENGTH=		60,		! Length of structure
	GQC_K_NONE=		0,		! Queue search beginning
	GQC_K_CURRENT=		1,		! Searching current queue
	GQC_K_PENDING=		2,		! Searching pending queue
	GQC_K_TIMER=		3,		! Searching timer queue
	GQC_K_HOLD=		4,		! Searching hold queue
	GQC_K_DONE=		5;		! Queue search done


MACRO
	GQL_LINK=		0,0,32,0 %,	! Link to next
	GQL_RECNO=		4,0,32,0 %,	! Record number
	GQL_BOFF=		8,0,16,0 %,	! Byte offset
	GQL_REFCOUNT=		10,0,16,0 %,	! Reference count
	GQL_LKID=		12,0,32,0 %;	! Lock ID of lock


LITERAL
	GQL_K_LENGTH=		16;		! Size of GQL entry


BUILTIN
	LOCC,
	TESTBITCC;

ROUTINE GETQUI_LOCK(REC_N,REC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine locks a specified record against modification.
!
! INPUT PARAMETERS:
!	REC_N		- Record number of record.
!	REC		- Address of record.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PREV,				! Pointer to previous forward link
	GQL:		REF BBLOCK,	! Pointer to $GETQUI lock block
	RESNAM:		BBLOCK[6],	! Resource name
	DESC:		VECTOR[2],	! Descriptor for resource name
	LKSB:		BBLOCK[8],	! Lock status block
	STATUS;				! Status return
	

! Ensure that the record number constitutes a valid lock.
!
IF .REC_N LEQU SQH$K_RECNO
THEN
    RETURN;


! Construct the resource name from the record number and the byte offset.
!
RESNAM[0,0,32,0] = .REC_N;
RESNAM[4,0,16,0] = .REC<0,9>;


! Search the active $GETQUI lock block list for the specified resource.
!
PREV = GQL_ACTIVE_LIST;
WHILE ..PREV NEQ 0 DO
    BEGIN
    GQL = ..PREV;
    CASE CH$COMPARE(
	%ALLOCATION(RESNAM), GQL[GQL_RECNO],
	%ALLOCATION(RESNAM), RESNAM)
    FROM -1 TO 1 OF
	SET


	[-1]:
	    EXITLOOP;


	[0]:
	    BEGIN
	    GQL[GQL_REFCOUNT] = .GQL[GQL_REFCOUNT] + 1;
	    RETURN;
	    END;


	[+1]:
	    PREV = GQL[GQL_LINK];


	TES;
    END;


! If the lock block free list is empty, allocate a page of memory
! and transform it into free lock blocks.
!
IF .GQL_FREE_LIST EQL 0
THEN
    BEGIN
    GQL_FREE_LIST = ALLOCATE_MEMORY();
    DECRA P
    FROM .GQL_FREE_LIST+512-2*GQL_K_LENGTH TO .GQL_FREE_LIST BY GQL_K_LENGTH DO
	.P = .P + GQL_K_LENGTH;
    END;


! Remove a lock block from the free list and initialize it.
!
GQL = .GQL_FREE_LIST;
GQL_FREE_LIST = .GQL[GQL_LINK];
GQL[GQL_LINK] = ..PREV;
.PREV = .GQL;
GQL[GQL_RECNO] = .RESNAM[0,0,32,0];
GQL[GQL_BOFF] = .RESNAM[4,0,16,0];
GQL[GQL_REFCOUNT] = 1;


! Take a lock on the resource.
!
DESC[0] = %ALLOCATION(RESNAM);
DESC[1] = RESNAM;
STATUS = $ENQW(
    EFN=JBC$K_SYNC_EFN,
    LKMODE=LCK$K_PRMODE,
    LKSB=LKSB,
    RESNAM=DESC,
    FLAGS=LCK$M_NODLCKBLK,
    PARID=.(QUEUE_LOCK_LKSB[2]),
    ASTPRM=.GQL,
    BLKAST=GETQUI_BLOCKING_AST);
IF .STATUS THEN STATUS = .LKSB[0,0,16,0];
IF NOT .STATUS
THEN
    SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);    


! Save the lock ID.
!
GQL[GQL_LKID] = .LKSB[4,0,32,0];
END;

ROUTINE GETQUI_UNLOCK(REC_N,REC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine unlocks a specified record against modification.
!
! INPUT PARAMETERS:
!	REC_N		- Record number of record.
!	REC		- Address of record.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PREV,				! Pointer to previous forward link
	GQL:		REF BBLOCK,	! Pointer to $GETQUI lock block
	RESNAM:		BBLOCK[6],	! Resource name
	STATUS;				! Status return
	

! Ensure that the record number constitutes a valid lock.
!
IF .REC_N LEQU SQH$K_RECNO
THEN
    RETURN;


! Construct the resource name from the record number and the byte offset.
!
RESNAM[0,0,32,0] = .REC_N;
RESNAM[4,0,16,0] = .REC<0,9>;


! Search the active $GETQUI lock block list for the specified resource.
!
PREV = GQL_ACTIVE_LIST;
WHILE ..PREV NEQ 0 DO
    BEGIN
    GQL = ..PREV;
    CASE CH$COMPARE(
	%ALLOCATION(RESNAM), GQL[GQL_RECNO],
	%ALLOCATION(RESNAM), RESNAM)
    FROM -1 TO 1 OF
	SET


	[-1]:
	    EXITLOOP;


	[0]:
	    BEGIN
	    GQL[GQL_REFCOUNT] = .GQL[GQL_REFCOUNT] - 1;
	    IF .GQL[GQL_REFCOUNT] EQL 0
	    THEN
		BEGIN
		STATUS = $DEQ(LKID=.GQL[GQL_LKID]);
		IF NOT .STATUS
		THEN
		    SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);

		.PREV = .GQL[GQL_LINK];
		CH$COPY(4, GQL_FREE_LIST, 0, GQL_K_LENGTH, .GQL);
		GQL_FREE_LIST = .GQL;
		END;
	    RETURN;
	    END;


	[+1]:
	    PREV = GQL[GQL_LINK];


	TES;
    END;
END;

ROUTINE GETQUI_SYNCHRONIZE(REC_N,REC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine synchronizes modification to a specified record with other
!	job controllers in a cluster.
!
! INPUT PARAMETERS:
!	REC_N		- Record number of record.
!	REC		- Address of record.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PREV,				! Pointer to previous forward link
	GQL:		REF BBLOCK,	! Pointer to $GETQUI lock block
	RESNAM:		BBLOCK[6],	! Resource name
	DESC:		VECTOR[2],	! Descriptor for resource name
	LKSB:		BBLOCK[8],	! Lock status block
	STATUS;				! Status return
	

! Ensure that the record number constitutes a valid lock.
!
IF .REC_N LEQU SQH$K_RECNO
THEN
    RETURN;


! Construct the resource name from the record number and the byte offset.
!
RESNAM[0,0,32,0] = .REC_N;
RESNAM[4,0,16,0] = .REC<0,9>;


! Search the active $GETQUI lock block list for the specified resource.
!
PREV = GQL_ACTIVE_LIST;
WHILE ..PREV NEQ 0 DO
    BEGIN
    GQL = ..PREV;
    CASE CH$COMPARE(
	%ALLOCATION(RESNAM), GQL[GQL_RECNO],
	%ALLOCATION(RESNAM), RESNAM)
    FROM -1 TO 1 OF
	SET


	[-1]:
	    EXITLOOP;


	[0]:
	    BEGIN

	    ! Convert the existing lock to PW mode in order to deliver blocking
	    ! ASTs to each remote job controller that holds a PR lock.
	    !
	    LKSB[4,0,32,0] = .GQL[GQL_LKID];
	    STATUS = $ENQW(
		EFN=JBC$K_SYNC_EFN,
		LKMODE=LCK$K_PWMODE,
		LKSB=LKSB,
		FLAGS=LCK$M_CONVERT);
	    IF .STATUS THEN STATUS = .LKSB[0,0,16,0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);    


	    ! Convert the lock back to PR mode.
	    !
	    STATUS = $ENQW(
		EFN=JBC$K_SYNC_EFN,
		LKMODE=LCK$K_PRMODE,
		LKSB=LKSB,
		FLAGS=LCK$M_CONVERT);
	    IF .STATUS THEN STATUS = .LKSB[0,0,16,0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);    


	    RETURN;
	    END;


	[+1]:
	    PREV = GQL[GQL_LINK];


	TES;
    END;


! Take a lock in PW mode in order to deliver blocking ASTs to each remote job
! controller that holds a PR lock.
!
DESC[0] = %ALLOCATION(RESNAM);
DESC[1] = RESNAM;
STATUS = $ENQW(
    EFN=JBC$K_SYNC_EFN,
    LKMODE=LCK$K_PWMODE,
    LKSB=LKSB,
    RESNAM=DESC,
    PARID=.(QUEUE_LOCK_LKSB[2]));
IF .STATUS THEN STATUS = .LKSB[0,0,16,0];
IF NOT .STATUS
THEN
    SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);    


! Release the PW lock.
!
$DEQ(LKID=.LKSB[4,0,32,0]);
END;

ROUTINE GETQUI_RELEASE(REC_N,REC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine releases the lock on a specified record momentarily as part
!	of the synchronization with other job controllers in a cluster.
!
! INPUT PARAMETERS:
!	REC_N		- Record number of record.
!	REC		- Address of record.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PREV,				! Pointer to previous forward link
	GQL:		REF BBLOCK,	! Pointer to $GETQUI lock block
	RESNAM:		BBLOCK[6],	! Resource name
	DESC:		VECTOR[2],	! Descriptor for resource name
	LKSB:		BBLOCK[8],	! Lock status block
	STATUS;				! Status return
	

! Ensure that the record number constitutes a valid lock.
!
IF .REC_N LEQU SQH$K_RECNO
THEN
    RETURN;


! Construct the resource name from the record number and the byte offset.
!
RESNAM[0,0,32,0] = .REC_N;
RESNAM[4,0,16,0] = .REC<0,9>;


! Search the active $GETQUI lock block list for the specified resource.
!
PREV = GQL_ACTIVE_LIST;
WHILE ..PREV NEQ 0 DO
    BEGIN
    GQL = ..PREV;
    CASE CH$COMPARE(
	%ALLOCATION(RESNAM), GQL[GQL_RECNO],
	%ALLOCATION(RESNAM), RESNAM)
    FROM -1 TO 1 OF
	SET


	[-1]:
	    EXITLOOP;


	[0]:
	    BEGIN

	    ! Dequeue the existing lock in order to allow the job
	    ! controller doing the modification to acquire the PW lock.
	    !
	    STATUS = $DEQ(LKID=.GQL[GQL_LKID]);
	    IF NOT .STATUS
	    THEN
		SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);


	    ! Reacquire a PR lock on the resource.
	    !
	    DESC[0] = %ALLOCATION(RESNAM);
	    DESC[1] = RESNAM;
	    STATUS = $ENQW(
		EFN=JBC$K_SYNC_EFN,
		LKMODE=LCK$K_PRMODE,
		LKSB=LKSB,
		RESNAM=DESC,
		FLAGS=LCK$M_NODLCKBLK,
		PARID=.(QUEUE_LOCK_LKSB[2]),
		ASTPRM=.GQL,
		BLKAST=GETQUI_BLOCKING_AST);
	    IF .STATUS THEN STATUS = .LKSB[0,0,16,0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(JBC$_COMREMJBC OR STS$K_ERROR, 0, .STATUS);    


	    ! Save the new lock ID.
	    !
	    GQL[GQL_LKID] = .LKSB[4,0,32,0];
	    EXITLOOP;
	    END;


	[+1]:
	    PREV = GQL[GQL_LINK];


	TES;
    END;
END;

ROUTINE UPDATE_GETQUI_LOCKS(GQC_1,GQC_2): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine updates locks in the $GETQUI lock data base at completion
!	of a $GETQUI operation.
!
! INPUT PARAMETERS:
!	GQC_1		- Pointer to GQC image before operation.
!	GQC_2		- Pointer to GQC image after operation, or 0 if none.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC_1:		REF BBLOCK,	! Pointer to GQC
	GQC_2:		REF BBLOCK;	! Pointer to GQC


IF .GQC_2 EQL 0
THEN
    BEGIN

    ! No after image.  Unlock all locks held on account of the before image.
    !
    GETQUI_UNLOCK(.GQC_1[GQC_SCX_N], .GQC_1[GQC_SCE_N]);
    GETQUI_UNLOCK(.GQC_1[GQC_SFX_N], .GQC_1[GQC_SFE_N]);
    GETQUI_UNLOCK(.GQC_1[GQC_SQX_N], .GQC_1[GQC_SQE_N]);
    GETQUI_UNLOCK(.GQC_1[GQC_SJH_N], 0);
    END
ELSE
    BEGIN

    ! If the characteristic context has changed, unlock the before image record
    ! and lock the after image record.
    !
    IF .GQC_1[GQC_SCX_N] NEQ .GQC_2[GQC_SCX_N]
    OR .GQC_1[GQC_SCE_N] NEQ .GQC_2[GQC_SCE_N]
    THEN
	BEGIN
	GETQUI_UNLOCK(.GQC_1[GQC_SCX_N], .GQC_1[GQC_SCE_N]);
	GETQUI_LOCK  (.GQC_2[GQC_SCX_N], .GQC_2[GQC_SCE_N]);
	END;


    ! If the form context has changed, unlock the before image record and lock
    ! the after image record.
    !
    IF .GQC_1[GQC_SFX_N] NEQ .GQC_2[GQC_SFX_N]
    OR .GQC_1[GQC_SFE_N] NEQ .GQC_2[GQC_SFE_N]
    THEN
	BEGIN
	GETQUI_UNLOCK(.GQC_1[GQC_SFX_N], .GQC_1[GQC_SFE_N]);
	GETQUI_LOCK  (.GQC_2[GQC_SFX_N], .GQC_2[GQC_SFE_N]);
	END;


    ! If the queue context has changed, unlock the before image record and lock
    ! the after image record.
    !
    IF .GQC_1[GQC_SQX_N] NEQ .GQC_2[GQC_SQX_N]
    OR .GQC_1[GQC_SQE_N] NEQ .GQC_2[GQC_SQE_N]
    THEN
	BEGIN
	GETQUI_UNLOCK(.GQC_1[GQC_SQX_N], .GQC_1[GQC_SQE_N]);
	GETQUI_LOCK  (.GQC_2[GQC_SQX_N], .GQC_2[GQC_SQE_N]);
	END;


    ! If the job context has changed, unlock the before image record and lock
    ! the after image record.
    !
    IF .GQC_1[GQC_SJH_N] NEQ .GQC_2[GQC_SJH_N]
    THEN
	BEGIN
	GETQUI_UNLOCK(.GQC_1[GQC_SJH_N], 0);
	GETQUI_LOCK  (.GQC_2[GQC_SJH_N], 0);
	END;
    END;
END;

GLOBAL ROUTINE UPDATE_GETQUI_DATA(REC_N,REC,BLKAST): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine updates references in the $GETQUI lock data base to the
!	specified record.
!
! INPUT PARAMETERS:
!	REC_N		- Record number of record.
!	REC		- Pointer to record, possibly including byte offset.
!	BLKAST		- Present if this routine is being called in response
!			  to a blocking AST.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	REC:		REF BBLOCK;	! Pointer to record
LOCAL
	GQC:		REF BBLOCK,	! Pointer to GQC
	BOFF;				! Byte offset from record pointer
BUILTIN
	ACTUALCOUNT;


! Deliver the remote blocking ASTs.
!
BOFF = .REC<0,9>;
IF ACTUALCOUNT() LSSU 3 THEN GETQUI_SYNCHRONIZE(.REC_N, .BOFF);


! Loop over all $GETQUI context records.
!
GQC = .OPEN_GETQUI_LIST;
WHILE .GQC NEQ 0 DO
    BEGIN

    ! If the characteristic context is being deleted, advance that context.
    !
    IF .GQC[GQC_SCX_N] EQL .REC_N AND .GQC[GQC_SCE_N] EQL .BOFF
    THEN
	BEGIN
	GQC[GQC_SCX_NO_ADV] = TRUE;
	IF ACTUALCOUNT() GEQU 3 THEN GETQUI_RELEASE(.REC_N, .BOFF);
	END;


    ! If the form context is being deleted, advance that context.
    !
    IF .GQC[GQC_SFX_N] EQL .REC_N AND .GQC[GQC_SFE_N] EQL .BOFF
    THEN
	BEGIN
	GQC[GQC_SFX_NO_ADV] = TRUE;
	IF ACTUALCOUNT() GEQU 3 THEN GETQUI_RELEASE(.REC_N, .BOFF);
	END;


    ! If the queue context is being deleted, advance that context.
    !
    IF .GQC[GQC_SQX_N] EQL .REC_N AND .GQC[GQC_SQE_N] EQL .BOFF
    THEN
	BEGIN
	GETQUI_UNLOCK(.GQC[GQC_SJH_N], 0);
	GQC[GQC_SQX_NO_ADV] = TRUE;
	GQC[GQC_SJH_Q] = GQC_K_DONE;
	GQC[GQC_SJH_N] = 0;
	GQC[GQC_SQR_N] = 0;
	IF ACTUALCOUNT() GEQU 3 THEN GETQUI_RELEASE(.REC_N, .BOFF);
	END;


    ! If the job context is being deleted, advance that context.
    !
    IF .GQC[GQC_SJH_N] EQL .REC_N
    THEN
	BEGIN
	GETQUI_UNLOCK(.GQC[GQC_SJH_N], 0);
	GQC[GQC_SJH_N] = .REC[SYM$L_LINK];
	GQC[GQC_SJH_NO_ADV] = TRUE;
	GETQUI_LOCK  (.GQC[GQC_SJH_N], 0);
	GQC[GQC_SQR_N] = 0;
	END;


    GQC = .GQC[GQC_LINK];
    END;
END;

ROUTINE GETQUI_BLOCKING_AST(GQL): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is a blocking AST for the $GETQUI lock list.
!
! INPUT PARAMETERS:
!	GQL		- Pointer to GQL (passed as ASTPRM).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQL:		REF BBLOCK;	! Pointer to $GETQUI lock block


IF .QUEUE_FAB[FAB$W_IFI] NEQ 0
THEN
    BEGIN
    DIAG_TRACE[7] = .GQL[GQL_RECNO];	! ***** diagnostic info *****
    IF .GQL[GQL_BOFF] NEQ 0
    THEN
	BEGIN

	! The record is a characteristic, form, or queue record.  Update all
	! references to the record, which does not require reference to the
	! record itself.
	!
	UPDATE_GETQUI_DATA(.GQL[GQL_RECNO], .GQL[GQL_BOFF], 0);
	END
    ELSE
	BEGIN
	LOCAL
	    AST_QUEUE_RAB: BBLOCK[RAB$C_BLN], ! Temporary AST level RAB
	    REC:	REF BBLOCK;	! Pointer to queue record

	! Ensure RAB is idle and create a temporary copy of it.
	!
	IF NOT $WAIT(RAB=QUEUE_RAB)
	THEN
	    SIGNAL_FILE_ERROR(
		JBC$_READERR + STS$K_SEVERE,
		QUEUE_FAB, QUEUE_RAB);
	CH$MOVE (RAB$C_BLN, QUEUE_RAB, AST_QUEUE_RAB);


	! The record is a job record.  Allocate a (page-aligned) buffer for
	! the record, and read the record.
	!
	REC = ALLOCATE_MEMORY();
	AST_QUEUE_RAB[RAB$L_KBF] = GQL[GQL_RECNO];
	IF .FLAGS[FLAGS_V_QUEUE_SHARED]
	    THEN AST_QUEUE_RAB[RAB$L_ROP] = RAB$M_NLK OR RAB$M_RRL
	    ELSE AST_QUEUE_RAB[RAB$L_ROP] = 0;
	AST_QUEUE_RAB[RAB$L_UBF] = .REC;
	DIAG_COUNT[0] = .DIAG_COUNT[0] + 1;
	IF NOT $GET(RAB=AST_QUEUE_RAB)
	THEN
	    SIGNAL_FILE_ERROR(
		JBC$_READERR + STS$K_SEVERE,
		QUEUE_FAB, AST_QUEUE_RAB);


	! Update all references to the record.
	!
	UPDATE_GETQUI_DATA(.GQL[GQL_RECNO], .REC, 0);


	! Deallocate the record.
	!
	DEALLOCATE_MEMORY(.REC);
	END;
    END;
END;

ROUTINE WILD_SEARCH_NAME=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine determines if the search name contains wildcards.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	VALUE_SEARCH_NAME	- Descriptor for search name.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the search name exists and contains a wildcard character.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
IF .ITEM_PRESENT[QUI$_SEARCH_NAME]
THEN
    BEGIN
    IF LOCC(
	%REF(%C'*'),
	VALUE_SEARCH_NAME[SDSC_W_LENGTH], .VALUE_SEARCH_NAME[SDSC_A_POINTER])
    THEN
	RETURN TRUE;


    IF LOCC(
	%REF(%C'%'),
	VALUE_SEARCH_NAME[SDSC_W_LENGTH], .VALUE_SEARCH_NAME[SDSC_A_POINTER])
    THEN
	RETURN TRUE;
    END;


FALSE
END;

ROUTINE RETURN_PARAMETERS(SRB,SJH): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine returns the QUI$_PARAMETER_i items if required.
!
! INPUT PARAMETERS:
!	SRB		- Pointer to SRB.
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SRB:		REF BBLOCK,	! Pointer to SRB
	SJH:		REF BBLOCK;	! Pointer to SJH
LOCAL
	A:		REF BBLOCK,
	E,
	ITEM_CODE,
	BUFFER:		BBLOCK[1024];


FETCH_VARIABLE_DATA(
    SJH$S_PARAMETERS, SJH[SJH$T_PARAMETERS],
    %ALLOCATION(BUFFER), BUFFER);
A = BUFFER;
E = .A + .BBLOCK[SJH[SJH$T_PARAMETERS], FVDF_LENGTH];


INCR ITEM_CODE FROM QUI$_PARAMETER_1 TO QUI$_PARAMETER_8 DO
    BEGIN
    LOCAL
	I,
	L;


    IF .A LSSA .E
    THEN
	BEGIN
	L = .A[0,0,16,0];
	A = .A + 2;
	END
    ELSE
	L = 0;


    ! Create an output item descriptor in the SRB.
    !
    I = LOCATE_SRB_OUTPUT_ITEM(
	.SRB,
	.ITEM_CODE,
	VALUE_GETQUI_BASE + .ITEM_CODE * ODSC_S_ENTRY);
    IF .I NEQ 0
    THEN
	BEGIN
	CH$MOVE(.L, .A, .I);
	COMPLETE_SRB_OUTPUT_ITEM(.SRB, .L);
	END;


    A = .A + .L;
    END;
END;

ROUTINE RETURN_RESULT(GQC,TABLE,ACCESSIBLE,REC_N1,REC_1,REC_N2,REC_2,REC_N3,REC_3)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine converts the values in one or more queue records to the
!	SRB format and returns the response to the user.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!	TABLE		- Pointer to table describing possible outputs.
!	ACCESSIBLE	- True if caller has read access to protected fields.
!	REC_N1		- Record numbers and pointers to queue records.
!	REC_1		-
!	REC_N2		-
!	REC_2		-
!	REC_N3		-
!	REC_3		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	0, to inhibit central message response.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK,	! Pointer to $GETQUI context block
	REC_1:		REF BBLOCK,	! Pointer to block
	REC_2:		REF BBLOCK,	!     ...
	REC_3:		REF BBLOCK;	!     ...
LOCAL
	T:		REF BBLOCK,	! Cursor for table
	SRB:		BBLOCK[8192];	! Local SRB
BUILTIN
	ACTUALPARAMETER;


! Create an SRB to return the response.
!
CREATE_SRB(SRB);


! Loop over each table element.
!
T = .TABLE;
WHILE .T[B_ITEM_CODE] NEQ 0 DO
    BEGIN
    IF .ITEM_PRESENT[.T[B_ITEM_CODE]]
    THEN
	BEGIN
	LOCAL
	    I:		REF BBLOCK,	! Pointer to SRB storage area
	    F:		REF BBLOCK,	! Pointer to value in queue block
	    S;				! Size of value


	! Create an output item descriptor in the SRB.
	!
	I = LOCATE_SRB_OUTPUT_ITEM(
	    SRB,
	    .T[B_ITEM_CODE],
	    VALUE_GETQUI_BASE + .T[B_ITEM_CODE] * ODSC_S_ENTRY);


	! Get the input value pointer and size.
	!
	F = ACTUALPARAMETER(.T[B_PARAMETER]) + .T[W_BYTE_OFFSET];
	S = 0;


	! Dispatch to store the value in the SRB area and determine its
	! actual size.
	!
	IF NOT .T[V_PROTECTED] OR .ACCESSIBLE
	THEN
	    BEGIN
	    CASE .T[B_CASE] FROM K_COPY_ASCIC TO K_QUEUE_STATUS OF
		SET


		[K_COPY_ASCIC]:
		    BEGIN
		    !
		    ! Copy the counted ASCII value at F.
		    !
		    S = CH$RCHAR(.F);
		    CH$MOVE(.S, .F + 1, .I);
		    END;


		[K_COPY_FORM_NAME]:
		    BEGIN
		    !
		    ! Copy the name of the form pointed to by the longword
		    ! at F.
		    !
		    LOCAL
			SFM_N,
			SFM:		REF BBLOCK;


		    SFM_N = ..F;
		    IF .SFM_N NEQ 0
		    THEN
			BEGIN
			SFM = READ_RECORD(.SFM_N);
			S = CH$RCHAR(SFM[SFM$T_NAME]);
			CH$MOVE(.S, SFM[SFM$T_NAME] + 1, .I);
			RELEASE_RECORD(.SFM_N);
			END;
		    END;


		[K_COPY_QUEUE_NAME]:
		    BEGIN
		    !
		    ! Copy the name of the queue pointed to by the longword
		    ! at F.
		    !
		    LOCAL
			SMQ_N,
			SMQ:		REF BBLOCK;

		    
		    SMQ_N = ..F;
		    IF .SMQ_N NEQ 0
		    THEN
			BEGIN
			SMQ = READ_RECORD(.SMQ_N);
			S = CH$RCHAR(SMQ[SMQ$T_NAME]);
			CH$MOVE(.S, SMQ[SMQ$T_NAME] + 1, .I);
			RELEASE_RECORD(.SMQ_N);
			END;
		    END;


		[K_COPY_SDSC]:
		    BEGIN
		    !
		    ! Copy the value described by the short descriptor at F.
		    !
		    S = .F[SDSC_W_LENGTH];
		    CH$MOVE(.S, .F[SDSC_A_POINTER], .I);
		    END;


		[K_COPY_TRIMMED]:
		    BEGIN
		    !
		    ! Copy the value at F of length S, trimmed of trailing
		    ! spaces and null characters.
		    !
		    S = .T[W_SIZE];
		    WHILE .S NEQ 0 DO
			BEGIN
			IF CH$RCHAR(.F + .S - 1) NEQ %C' '
			AND CH$RCHAR(.F + .S - 1) NEQ 0
			    THEN EXITLOOP;
			S = .S - 1;
			END;
		    CH$MOVE(.S, .F, .I);
		    END;


		[K_COPY_VALUE]:
		    BEGIN
		    !
		    ! Copy the value at F of length S.
		    !
		    S = .T[W_SIZE];
		    CH$MOVE(.S, .F, .I);
		    END;


		[K_COPY_VARIABLE]:
		    BEGIN
		    !
		    ! Copy the variable data field at F of length S.
		    !
		    FETCH_VARIABLE_DATA(.T[W_SIZE], .F, 512, .I);
		    S = .F[FVDF_LENGTH];
		    END;


		[K_COMPLETED_BLOCKS]:
		    BEGIN
		    !
		    ! Generate the completed blocks item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK,
			SJH_N=	REC_N2,
			SJH=	REC_2:		REF BBLOCK;


		    .I = 0;
		    IF NOT .SMQ[SMQ$V_BATCH]
		    THEN
			.I = .SJH[SJH$L_COMPLETED_BLOCKS] + SYMBIONT_COMPLETED_BLOCKS(.SJH);
		    S = 4;
		    END;


		[K_FILE_FLAGS]:
		    BEGIN
		    !
		    ! Generate the file flags item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK,
			SJH_N=	REC_N2,
			SJH=	REC_2:		REF BBLOCK,
			SQR_N=	REC_N3,
			SQR=	REC_3:		REF BBLOCK;


		    .I = 0;
		    IF .SQR[SQR$V_FILE_BURST]
			THEN I[QUI$V_FILE_BURST] = TRUE;
		    IF .SQR[SQR$V_FILE_BURST_EXPLICIT]
			THEN I[QUI$V_FILE_BURST_EXP] = TRUE;
		    IF .SQR[SQR$V_DELETE_FILE]
			THEN I[QUI$V_FILE_DELETE] = TRUE;
		    IF .SQR[SQR$V_DOUBLE_SPACE]
			THEN I[QUI$V_FILE_DOUBLE_SPACE] = TRUE;
		    IF .SQR[SQR$V_FILE_FLAG]
			THEN I[QUI$V_FILE_FLAG] = TRUE;
		    IF .SQR[SQR$V_FILE_FLAG_EXPLICIT]
			THEN I[QUI$V_FILE_FLAG_EXP] = TRUE;
		    IF .SQR[SQR$V_FILE_TRAILER]
			THEN I[QUI$V_FILE_TRAILER] = TRUE;
		    IF .SQR[SQR$V_FILE_TRAILER_EXPLICIT]
			THEN I[QUI$V_FILE_TRAILER_EXP] = TRUE;
		    IF .SQR[SQR$V_PAGE_HEADER]
			THEN I[QUI$V_FILE_PAGE_HEADER] = TRUE;
		    IF .SQR[SQR$V_PAGINATE]
			THEN I[QUI$V_FILE_PAGINATE] = TRUE;
		    IF .SQR[SQR$V_PAGINATE_EXPLICIT]
			THEN I[QUI$V_FILE_PAGINATE_EXP] = TRUE;
		    IF .SQR[SQR$V_PASSALL]
			THEN I[QUI$V_FILE_PASSALL] = TRUE;
		    S = 4;
		    END;


		[K_FILE_STATUS]:
		    BEGIN
		    !
		    ! Generate the file status item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK,
			SJH_N=	REC_N2,
			SJH=	REC_2:		REF BBLOCK,
			SQR_N=	REC_N3,
			SQR=	REC_3:		REF BBLOCK;


		    .I = 0;
		    IF .SJH[SJH$L_CURRENT_FILE_CHKPT] EQL .SQR_N
			THEN I[QUI$V_FILE_CHECKPOINTED] = TRUE;
		    IF .SJH[SJH$V_EXECUTING]
		    AND .SJH[SJH$L_CURRENT_FILE_LINK] EQL .SQR_N
			THEN I[QUI$V_FILE_EXECUTING] = TRUE;
		    S = 4;
		    END;


		[K_FORM_FLAGS]:
		    BEGIN
		    !
		    ! Generate the form flags item.
		    !
		    BIND
			SFM_N=	REC_N1,
			SFM=	REC_1:		REF BBLOCK;


		    .I = 0;
		    IF .SFM[SFM$V_SHEET_FEED]
			THEN I[QUI$V_FORM_SHEET_FEED] = TRUE;
		    IF .SFM[SFM$V_TRUNCATE]
			THEN I[QUI$V_FORM_TRUNCATE] = TRUE;
		    IF .SFM[SFM$V_WRAP]
			THEN I[QUI$V_FORM_WRAP] = TRUE;
		    S = 4;
		    END;


		[K_GENERIC_TARGET]:
		    BEGIN
		    !
		    ! Copy the names of all queues pointed to by the generic
		    ! target record pointed to by the longword at F.
		    !
		    LOCAL
			AUX_N,
			AUX:		REF BBLOCK;

		    
		    AUX_N = ..F;
		    IF .AUX_N NEQ 0
		    THEN
			BEGIN
			AUX = READ_RECORD(.AUX_N);
			INCR J FROM 1 TO .VECTOR[AUX[SYM$T_DATA], 0] DO
			    BEGIN
			    LOCAL
				LS,
				SMQ_N,
				SMQ:		REF BBLOCK;

			    SMQ_N = .VECTOR[AUX[SYM$T_DATA], .J];
			    SMQ = READ_RECORD(.SMQ_N);
			    LS = CH$RCHAR(SMQ[SMQ$T_NAME]);
			    I = CH$MOVE(.LS, SMQ[SMQ$T_NAME] + 1, .I);
			    CH$WCHAR_A(%C',', I);
			    S = .S + .LS + 1;
			    RELEASE_RECORD(.SMQ_N);
			    END;
			S = .S - 1;
			RELEASE_RECORD(.AUX_N);
			END;
		    END;


		[K_INTERVENING_BLOCKS]:
		    BEGIN
		    !
		    ! Copy the number of intervening pending blocks.
		    !
		    .I = .GQC[GQC_INTERVENING_BLOCKS];
		    S = 4;
		    END;


		[K_INTERVENING_JOBS]:
		    BEGIN
		    !
		    ! Copy the number of intervening pending jobs.
		    !
		    .I = .GQC[GQC_INTERVENING_JOBS];
		    S = 4;
		    END;


		[K_JOB_FLAGS]:
		    BEGIN
		    !
		    ! Generate the job flags item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK,
			SJH_N=	REC_N2,
			SJH=	REC_2:		REF BBLOCK;


		    .I = 0;
		    IF .SJH[SJH$V_CPU_MAXIMUM]
			THEN I[QUI$V_JOB_CPU_LIMIT] = TRUE;
		    IF .SJH[SJH$V_FILE_BURST]
			THEN I[QUI$V_JOB_FILE_BURST] = TRUE;
		    IF .SJH[SJH$V_FILE_BURST_ONE]
			THEN I[QUI$V_JOB_FILE_BURST_ONE] = TRUE;
		    IF .SJH[SJH$V_FILE_BURST_EXPLICIT]
			THEN I[QUI$V_JOB_FILE_BURST_EXP] = TRUE;
		    IF .SJH[SJH$V_FILE_FLAG]
			THEN I[QUI$V_JOB_FILE_FLAG] = TRUE;
		    IF .SJH[SJH$V_FILE_FLAG_ONE]
			THEN I[QUI$V_JOB_FILE_FLAG_ONE] = TRUE;
		    IF .SJH[SJH$V_FILE_FLAG_EXPLICIT]
			THEN I[QUI$V_JOB_FILE_FLAG_EXP] = TRUE;
		    IF .SJH[SJH$V_FILE_TRAILER]
			THEN I[QUI$V_JOB_FILE_TRAILER] = TRUE;
		    IF .SJH[SJH$V_FILE_TRAILER_ONE]
			THEN I[QUI$V_JOB_FILE_TRAILER_ONE] = TRUE;
		    IF .SJH[SJH$V_FILE_TRAILER_EXPLICIT]
			THEN I[QUI$V_JOB_FILE_TRAILER_EXP] = TRUE;
		    IF .SJH[SJH$V_LOG_DELETE]
			THEN I[QUI$V_JOB_LOG_DELETE] = TRUE;
		    IF .SJH[SJH$V_LOG_NULL]
			THEN I[QUI$V_JOB_LOG_NULL] = TRUE;
		    IF .SJH[SJH$V_LOG_SPOOL]
			THEN I[QUI$V_JOB_LOG_SPOOL] = TRUE;
		    IF .SJH[SJH$V_LOWERCASE]
			THEN I[QUI$V_JOB_LOWERCASE] = TRUE;
		    IF .SJH[SJH$V_NOTIFY]
			THEN I[QUI$V_JOB_NOTIFY] = TRUE;
		    IF .SJH[SJH$V_PAGINATE]
			THEN I[QUI$V_JOB_FILE_PAGINATE] = TRUE;
		    IF .SJH[SJH$V_PAGINATE_EXPLICIT]
			THEN I[QUI$V_JOB_FILE_PAGINATE_EXP] = TRUE;
		    IF .SJH[SJH$V_RESTART]
			THEN I[QUI$V_JOB_RESTART] = TRUE;
		    IF .SJH[SJH$V_WSDEFAULT]
			THEN I[QUI$V_JOB_WSDEFAULT] = TRUE;
		    IF .SJH[SJH$V_WSEXTENT]
			THEN I[QUI$V_JOB_WSEXTENT] = TRUE;
		    IF .SJH[SJH$V_WSQUOTA]
			THEN I[QUI$V_JOB_WSQUOTA] = TRUE;
		    S = 4;
		    END;


		[K_JOB_STATUS]:
		    BEGIN
		    !
		    ! Generate the job status item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK,
			SJH_N=	REC_N2,
			SJH=	REC_2:		REF BBLOCK;


		    .I = 0;
		    IF .SJH[SJH$V_ABORTED] OR .SJH[SJH$V_ABORTING]
			THEN I[QUI$V_JOB_ABORTING] = TRUE;
		    IF .SJH[SJH$V_EXECUTING] AND NOT .SJH[SJH$V_FILE_STARTING]
			THEN I[QUI$V_JOB_EXECUTING] = TRUE;
		    IF .SJH[SJH$V_HOLDING]
			THEN I[QUI$V_JOB_HOLDING] = TRUE;
		    IF NOT .ACCESSIBLE
			THEN I[QUI$V_JOB_INACCESSIBLE] = TRUE;
		    IF .SJH[SJH$V_REFUSED]
			THEN I[QUI$V_JOB_REFUSED] = TRUE;
		    IF .SJH[SJH$V_REQUEUE]
			THEN I[QUI$V_JOB_REQUEUE] = TRUE;
		    IF .SJH[SJH$V_RESTARTING]
			THEN I[QUI$V_JOB_RESTARTING] = TRUE;
		    IF .SJH[SJH$V_RETAINED]
			THEN I[QUI$V_JOB_RETAINED] = TRUE;
		    IF .SJH[SJH$V_STARTING] OR .SJH[SJH$V_FILE_STARTING]
			THEN I[QUI$V_JOB_STARTING] = TRUE;
		    IF .GQC[GQC_SJH_Q] EQL GQC_K_TIMER
			THEN I[QUI$V_JOB_TIMED] = TRUE;
		    S = 4;
		    END;


		[K_QUEUE_FLAGS]:
		    BEGIN
		    !
		    ! Generate the queue flags item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK;


		    .I = 0;
		    IF .SMQ[SMQ$V_BATCH]
			THEN I[QUI$V_QUEUE_BATCH] = TRUE;
		    IF .SMQ[SMQ$V_CPU_DEFAULT]
			THEN I[QUI$V_QUEUE_CPU_DEFAULT] = TRUE;
		    IF .SMQ[SMQ$V_CPU_MAXIMUM]
			THEN I[QUI$V_QUEUE_CPU_LIMIT] = TRUE;
		    IF .SMQ[SMQ$V_FILE_BURST]
			THEN I[QUI$V_QUEUE_FILE_BURST] = TRUE;
		    IF .SMQ[SMQ$V_FILE_BURST_ONE]
			THEN I[QUI$V_QUEUE_FILE_BURST_ONE] = TRUE;
		    IF .SMQ[SMQ$V_FILE_FLAG]
			THEN I[QUI$V_QUEUE_FILE_FLAG] = TRUE;
		    IF .SMQ[SMQ$V_FILE_FLAG_ONE]
			THEN I[QUI$V_QUEUE_FILE_FLAG_ONE] = TRUE;
		    IF .SMQ[SMQ$V_FILE_TRAILER]
			THEN I[QUI$V_QUEUE_FILE_TRAILER] = TRUE;
		    IF .SMQ[SMQ$V_FILE_TRAILER_ONE]
			THEN I[QUI$V_QUEUE_FILE_TRAILER_ONE] = TRUE;
		    IF .SMQ[SMQ$V_GENERIC_QUEUE]
			THEN I[QUI$V_QUEUE_GENERIC] = TRUE;
		    IF .SMQ[SMQ$V_GENERIC_SELECTION]
			THEN I[QUI$V_QUEUE_GENERIC_SELECTION] = TRUE;
		    IF .SMQ[SMQ$V_JOB_BURST]
			THEN I[QUI$V_QUEUE_JOB_BURST] = TRUE;
		    IF .SMQ[SMQ$V_JOB_SIZE_SCHEDULING]
			THEN I[QUI$V_QUEUE_JOB_SIZE_SCHED] = TRUE;
		    IF .SMQ[SMQ$V_JOB_FLAG]
			THEN I[QUI$V_QUEUE_JOB_FLAG] = TRUE;
		    IF .SMQ[SMQ$V_JOB_TRAILER]
			THEN I[QUI$V_QUEUE_JOB_TRAILER] = TRUE;
		    IF .SMQ[SMQ$V_PAGINATE]
			THEN I[QUI$V_QUEUE_FILE_PAGINATE] = TRUE;
		    IF .SMQ[SMQ$V_RETAIN_ALL_JOBS]
			THEN I[QUI$V_QUEUE_RETAIN_ALL] = TRUE;
		    IF .SMQ[SMQ$V_RETAIN_ERROR_JOBS]
			THEN I[QUI$V_QUEUE_RETAIN_ERROR] = TRUE;
		    IF .SMQ[SMQ$V_SWAP]
			THEN I[QUI$V_QUEUE_SWAP] = TRUE;
		    IF .SMQ[SMQ$V_TERMINAL]
			THEN I[QUI$V_QUEUE_TERMINAL] = TRUE;
		    IF .SMQ[SMQ$V_WSDEFAULT]
			THEN I[QUI$V_QUEUE_WSDEFAULT] = TRUE;
		    IF .SMQ[SMQ$V_WSEXTENT]
			THEN I[QUI$V_QUEUE_WSEXTENT] = TRUE;
		    IF .SMQ[SMQ$V_WSQUOTA]
			THEN I[QUI$V_QUEUE_WSQUOTA] = TRUE;
		    S = 4;
		    END;


		[K_QUEUE_STATUS]:
		    BEGIN
		    !
		    ! Generate the queue status item.
		    !
		    BIND
			SMQ_N=	REC_N1,
			SMQ=	REC_1:		REF BBLOCK;


		    .I = 0;
		    IF .SMQ[SMQ$V_ALIGNING]
			THEN I[QUI$V_QUEUE_ALIGNING] = TRUE;
		    IF .SMQ[SMQ$B_CURRENT_JOB_COUNT] EQL 0
			THEN I[QUI$V_QUEUE_IDLE] = TRUE;
		    IF .SMQ[SMQ$V_LOWERCASE]
			THEN I[QUI$V_QUEUE_LOWERCASE] = TRUE;
		    IF .SMQ[SMQ$V_OPERATOR_REQUEST]
			THEN I[QUI$V_QUEUE_OPERATOR_REQUEST] = TRUE;
		    IF .SMQ[SMQ$V_PAUSED] AND NOT .SMQ[SMQ$V_ALIGNING] AND NOT .SMQ[SMQ$V_RESUMING]
			THEN I[QUI$V_QUEUE_PAUSED] = TRUE;
		    IF .SMQ[SMQ$V_PAUSING]
			THEN I[QUI$V_QUEUE_PAUSING] = TRUE;
		    IF .SMQ[SMQ$V_REMOTE]
			THEN I[QUI$V_QUEUE_REMOTE] = TRUE;
		    IF .SMQ[SMQ$V_RESETTING]
			THEN I[QUI$V_QUEUE_RESETTING] = TRUE;
		    IF .SMQ[SMQ$V_RESUMING] AND NOT .SMQ[SMQ$V_ALIGNING]
			THEN I[QUI$V_QUEUE_RESUMING] = TRUE;
		    IF .SMQ[SMQ$V_SERVER]
			THEN I[QUI$V_QUEUE_SERVER] = TRUE;
		    IF .SMQ[SMQ$V_STALLED]
			THEN I[QUI$V_QUEUE_STALLED] = TRUE;
		    IF .SMQ[SMQ$V_STARTING]
			THEN I[QUI$V_QUEUE_STARTING] = TRUE;
		    IF .SMQ[SMQ$V_STOPPED]
			THEN I[QUI$V_QUEUE_STOPPED] = TRUE;
		    IF .SMQ[SMQ$V_STOPPING]
			THEN I[QUI$V_QUEUE_STOPPING] = TRUE;
		    IF .SMQ[SMQ$V_UNAVAILABLE]
			THEN I[QUI$V_QUEUE_UNAVAILABLE] = TRUE;
		    S = 4;
		    END;


		TES;
	    END;


	! Finish the output item descriptor.
	!
	COMPLETE_SRB_OUTPUT_ITEM(SRB, .S);
	END;


    ! Advance to next table entry.
    !
    T = .T + K_ENTRY_SIZE;
    END;


! Special case storing the parameter items.
!
IF .BBLOCK[ITEM_PRESENT, 0, QUI$_PARAMETER_1, 8, 0] NEQ 0
THEN
    RETURN_PARAMETERS(SRB, .REC_2);


! Cancel the intervening counts.
!
GQC[GQC_INTERVENING_BLOCKS] = 0;
GQC[GQC_INTERVENING_JOBS] = 0;


! Send the response to the requestor and return zero to inhibit the central
! message response.
!
SEND_SERVICE_RESPONSE_MESSAGE(SRB, JBC$_NORMAL);
0
END;

ROUTINE QUI_CANCEL_OPERATION(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_CANCEL_OPERATION request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block


! Cancel the pending wildcard operations, if any.
!
GQC[GQC_WILDCARDS] = 0;


SS$_NORMAL
END;

ROUTINE QUI_DISPLAY_CHARACTERISTIC(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_DISPLAY_CHARACTERISTIC request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block
LOCAL
	SCE:		REF BBLOCK;	! Pointer to SCX entry
LITERAL
	K_SCE=		K_REC_1;
LABEL
	FIND_SELECTED;


! Ensure that a search name was specified.
!
IF NOT .ITEM_PRESENT[QUI$_SEARCH_NAME]
THEN
    RETURN JBC$_MISREQPAR;


! Set the characteristic wildcard bit.
!
GQC[GQC_SCX_WILD] = WILD_SEARCH_NAME();


! If this is the first call, advance to the first characteristic record.
!
IF .GQC[GQC_SCX_N] EQL SQH$K_RECNO
THEN
    BEGIN
    LOCAL
	SQH:		REF BBLOCK;	! Pointer to SQH

    SQH = READ_RECORD(SQH$K_RECNO);
    GQC[GQC_SCX_N] = .SQH[SQH$L_CHARACTERISTIC_LIST];
    GQC[GQC_SCE_N] = $BYTEOFFSET(SYM$T_DATA) - SCX$S_SCX;
    RELEASE_RECORD(SQH$K_RECNO);
    END;


FIND_SELECTED:  BEGIN


! Loop over characteristic index records.
!
WHILE TRUE DO
    BEGIN
    LOCAL
	SCX_N,			! Record number of SCX
	SCX:	REF BBLOCK;	! Pointer to SCX


    ! No more records -- return failure.
    !
    IF .GQC[GQC_SCX_N] EQL 0
    THEN
	BEGIN
	GQC[GQC_SCX_WILD] = FALSE;
	RETURN JBC$_NOSUCHCHAR;
	END;


    ! Read the characteristic index record.
    !
    SCX = READ_RECORD(SCX_N = .GQC[GQC_SCX_N]);


    ! Loop over characteristic entries.
    !
    WHILE TRUE DO
	BEGIN

	! Advance to next entry, and ensure that it is valid.
	!
	IF TESTBITCC(GQC[GQC_SCX_NO_ADV])
	    THEN GQC[GQC_SCE_N] = .GQC[GQC_SCE_N] + SCX$S_SCX;
	IF .GQC[GQC_SCE_N] GEQU $BYTEOFFSET(SYM$T_DATA) + SCX$S_SCX * SCX$K_ENTRIES
	    THEN EXITLOOP;
	SCE = .SCX + .GQC[GQC_SCE_N];
	IF CH$RCHAR(SCE[SCX$T_NAME]) EQL 0 THEN EXITLOOP;


	! Match this entry with the selector.
	!
	IF FMG$MATCH_NAME(
	    CH$RCHAR(SCE[SCX$T_NAME]),
	    SCE[SCX$T_NAME] + 1,
	    .VALUE_SEARCH_NAME[SDSC_W_LENGTH],
	    .VALUE_SEARCH_NAME[SDSC_A_POINTER])
	THEN
	    LEAVE FIND_SELECTED;
	END;


    ! Advance to next characteristic index record.
    !
    GQC[GQC_SCX_N] = .SCX[SYM$L_LINK];
    GQC[GQC_SCE_N] = $BYTEOFFSET(SYM$T_DATA) - SCX$S_SCX;
    RELEASE_RECORD(.SCX_N);
    END;


END; ! of block FIND_SELECTED


! Return information about the selected characteristic.
!
RETURN_RESULT(
    .GQC,
    GENERATE_TABLE(
	QUI$_CHARACTERISTIC_NAME,
		K_SCE,	K_COPY_ASCIC,		FALSE,	$BYTEOFFSET(SCX$T_NAME),		0,
	QUI$_CHARACTERISTIC_NUMBER,
		K_SCE,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SCX$B_NUMBER),		1),
    TRUE,
    0, .SCE)
END;

ROUTINE QUI_DISPLAY_FILE(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_DISPLAY_FILE request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block
LOCAL
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SQR_N,				! Record number of SQR
	SQR:		REF BBLOCK;	! Pointer to SQR
LITERAL
	K_SMQ=		K_REC_1,
	K_SJH=		K_REC_2,
	K_SQR=		K_REC_3;


! If the wildcard bit is clear, this request returns information about the
! current batch job.
!
IF NOT .VALUE_SEARCH_FLAGS[QUI$V_SEARCH_WILDCARD]
THEN
    BEGIN

    ! Locate the data for this job.
    !
    IF NOT FIND_PROCESS_DATA(
	PDE_K_BATCH, .MBX[ACM$L_PID], FALSE;
	, SMQ_N, SJH_N)
    THEN
	RETURN JBC$_NOSUCHFILE;


    SMQ = READ_RECORD(.SMQ_N);
    SJH = READ_RECORD(.SJH_N);
    SQR = READ_RECORD(SQR_N = .SJH[SJH$L_CURRENT_FILE_LINK]);
    END
ELSE
    BEGIN

    ! If no job context has been established or we have reached the end of the
    ! file list, return an error.
    !
    IF .GQC[GQC_SMQ_N] EQL 0
    OR .GQC[GQC_SJH_N] EQL 0
    OR .GQC[GQC_SQR_N] EQL 0
    THEN
	RETURN JBC$_NOSUCHFILE;


    ! Read the queue record and the job record, establish the first or next file
    ! record to be returned, and read the file record.
    !
    SMQ = READ_RECORD(SMQ_N = .GQC[GQC_SMQ_N]);
    SJH = READ_RECORD(SJH_N = .GQC[GQC_SJH_N]);
    IF .GQC[GQC_SQR_N] EQL SQH$K_RECNO
    THEN
	BEGIN
	SQR_N = .SJH[SJH$L_FILE_LIST];
	END
    ELSE
	BEGIN
	SQR = READ_RECORD(.GQC[GQC_SQR_N]);
	SQR_N = .SQR[SYM$L_LINK];
	RELEASE_RECORD(.GQC[GQC_SQR_N]);
	END;
    IF .SQR_N EQL 0 THEN RETURN JBC$_NOSUCHFILE;
    SQR = READ_RECORD(GQC[GQC_SQR_N] = .SQR_N);
    END;


! Return information about the selected file.
!
RETURN_RESULT(
    .GQC,
    GENERATE_TABLE(
	QUI$_FILE_COPIES,
		K_SQR,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SQR$B_FILE_COPIES),		1,
	QUI$_FILE_COPIES_CHKPT,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_FILE_COPIES_CHKPT),	1,
	QUI$_FILE_COPIES_DONE,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_FILE_COPIES_DONE),	1,
	QUI$_FILE_FLAGS,
		K_SQR,	K_FILE_FLAGS,		TRUE,	0,					0,
	QUI$_FILE_SETUP_MODULES,
		K_SQR,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SQR$T_FILE_SETUP_MODULES),	SQR$S_FILE_SETUP_MODULES,
	QUI$_FILE_SPECIFICATION,
		K_SQR,	K_COPY_ASCIC,		TRUE,	$BYTEOFFSET(SQR$T_FILE_SPECIFICATION),	0,
	QUI$_FILE_STATUS,
		K_SQR,	K_FILE_STATUS,		TRUE,	0,					0,
	QUI$_FIRST_PAGE,
		K_SQR,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SQR$L_FIRST_PAGE),		4,
	QUI$_LAST_PAGE,
		K_SQR,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SQR$L_LAST_PAGE),		4),
    CHECK_R_ACCESS(.SMQ, .SJH),
    .SMQ_N, .SMQ, .SJH_N, .SJH, .SQR_N, .SQR)
END;

ROUTINE QUI_DISPLAY_FORM(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_DISPLAY_FORM request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block
LOCAL
	SFM_N,				! Record number of SFM
	SFM:		REF BBLOCK;	! Pointer to SFM
LITERAL
	K_SFM=		K_REC_1;
LABEL
	FIND_SELECTED;


! Ensure that either a search name or number was specified.
!
IF NOT .ITEM_PRESENT[QUI$_SEARCH_NAME]
AND NOT .ITEM_PRESENT[QUI$_SEARCH_NUMBER]
THEN
    RETURN JBC$_MISREQPAR;


! Set the form wildcard bit.
!
GQC[GQC_SFX_WILD] = WILD_SEARCH_NAME();


! If this is the first call, advance to the first form index record.
!
IF .GQC[GQC_SFX_N] EQL SQH$K_RECNO
THEN
    BEGIN
    LOCAL
	SQH:		REF BBLOCK;	! Pointer to SQH

    SQH = READ_RECORD(SQH$K_RECNO);
    GQC[GQC_SFX_N] = .SQH[SQH$L_FORM_INDEX_LIST];
    GQC[GQC_SFE_N] = $BYTEOFFSET(SYM$T_DATA) - SFX$S_SFX;
    RELEASE_RECORD(SQH$K_RECNO);
    END;


FIND_SELECTED:  BEGIN


! Loop over form index records.
!
WHILE TRUE DO
    BEGIN
    LOCAL
	SFX_N,			! Record number of SFX
	SFX:	REF BBLOCK,	! Pointer to SFX
	SFE:	REF BBLOCK;	! Pointer to SFX entry


    ! No more records -- return failure.
    !
    IF .GQC[GQC_SFX_N] EQL 0
    THEN
	BEGIN
	GQC[GQC_SFX_WILD] = FALSE;
	RETURN JBC$_NOSUCHFORM;
	END;


    ! Read the form index record.
    !
    SFX = READ_RECORD(SFX_N = .GQC[GQC_SFX_N]);


    ! Loop over form entries.
    !
    WHILE TRUE DO
	BEGIN

	! Advance to next entry, and ensure that it is valid.
	!
	IF TESTBITCC(GQC[GQC_SFX_NO_ADV])
	    THEN GQC[GQC_SFE_N] = .GQC[GQC_SFE_N] + SFX$S_SFX;
	IF .GQC[GQC_SFE_N] GEQU $BYTEOFFSET(SYM$T_DATA) + SFX$S_SFX * SFX$K_ENTRIES
	    THEN EXITLOOP;
	SFE = .SFX + .GQC[GQC_SFE_N];
	IF CH$RCHAR(SFE[SFX$T_NAME]) EQL 0 THEN EXITLOOP;


	! Match this entry with the selector -- both the name and number
	! must match.
	!
	IF
	    BEGIN
	    IF .ITEM_PRESENT[QUI$_SEARCH_NAME]
	    THEN
		FMG$MATCH_NAME(
		    CH$RCHAR(SFE[SFX$T_NAME]),
		    SFE[SFX$T_NAME] + 1,
		    .VALUE_SEARCH_NAME[SDSC_W_LENGTH],
		    .VALUE_SEARCH_NAME[SDSC_A_POINTER])
	    ELSE
		TRUE
	    END
	AND
	    BEGIN
	    IF .ITEM_PRESENT[QUI$_SEARCH_NUMBER]
	    THEN
		.VALUE_SEARCH_NUMBER EQL .SFE[SFX$L_NUMBER]
	    ELSE
		TRUE
	    END
	THEN
	    BEGIN
	    SFM = READ_RECORD(SFM_N = .SFE[SFX$L_FORM_LINK]);
	    LEAVE FIND_SELECTED;
	    END;
	END;


    ! Advance to next form index record.
    !
    GQC[GQC_SFX_N] = .SFX[SYM$L_LINK];
    GQC[GQC_SFE_N] = $BYTEOFFSET(SYM$T_DATA) - SFX$S_SFX;
    RELEASE_RECORD(.SFX_N);
    END;


END; ! of block FIND_SELECTED


! Return information about the selected form.
!
RETURN_RESULT(
    .GQC,
    GENERATE_TABLE(
	QUI$_FORM_DESCRIPTION,
		K_SFM,	K_COPY_ASCIC,		FALSE,	$BYTEOFFSET(SFM$T_DESCRIPTION),		0,
	QUI$_FORM_FLAGS,
		K_SFM,	K_FORM_FLAGS,		FALSE,	0,					0,
	QUI$_FORM_LENGTH,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$B_LENGTH),		1,
	QUI$_FORM_MARGIN_BOTTOM,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$B_MARGIN_BOTTOM),	1,
	QUI$_FORM_MARGIN_LEFT,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$W_MARGIN_LEFT),		2,
	QUI$_FORM_MARGIN_RIGHT,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$W_MARGIN_RIGHT),	2,
	QUI$_FORM_MARGIN_TOP,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$B_MARGIN_TOP),		1,
	QUI$_FORM_NAME,
		K_SFM,	K_COPY_ASCIC,		FALSE,	$BYTEOFFSET(SFM$T_NAME),		0,
	QUI$_FORM_NUMBER,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$L_NUMBER),		4,
	QUI$_FORM_SETUP_MODULES,
		K_SFM,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SFM$T_FORM_SETUP_MODULES),	SFM$S_FORM_SETUP_MODULES,
	QUI$_FORM_STOCK,
		K_SFM,	K_COPY_ASCIC,		FALSE,	$BYTEOFFSET(SFM$T_STOCK),		0,
	QUI$_FORM_WIDTH,
		K_SFM,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SFM$W_WIDTH),		2,
	QUI$_PAGE_SETUP_MODULES,
		K_SFM,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SFM$T_PAGE_SETUP_MODULES),	SFM$S_PAGE_SETUP_MODULES),
    TRUE,
    .SFM_N, .SFM)
END;

ROUTINE QUI_DISPLAY_JOB(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_DISPLAY_JOB request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block
LOCAL
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK;	! Pointer to SJH
LITERAL
	K_SMQ=		K_REC_1,
	K_SJH=		K_REC_2;


! If the wildcard bit is clear, this request returns information about the
! current batch job.
!
IF NOT .VALUE_SEARCH_FLAGS[QUI$V_SEARCH_WILDCARD]
THEN
    BEGIN

    ! Locate the data for this job.
    !
    IF NOT FIND_PROCESS_DATA(
	PDE_K_BATCH, .MBX[ACM$L_PID], FALSE;
	, SMQ_N, SJH_N)
    THEN
	RETURN JBC$_NOSUCHJOB;


    SMQ = READ_RECORD(.SMQ_N);
    SJH = READ_RECORD(.SJH_N);
    END
ELSE
    BEGIN

    ! If no queue context has been established or we have reached the end of the
    ! job list, return an error.
    !
    IF .GQC[GQC_SMQ_N] EQL 0
    OR .GQC[GQC_SJH_Q] EQL GQC_K_DONE
    THEN
	RETURN JBC$_NOSUCHJOB;


    ! Read the queue record, establish the next job record to be returned,
    !and read the job record.
    !
    SMQ = READ_RECORD(SMQ_N = .GQC[GQC_SMQ_N]);
    SJH_N = 0;
    WHILE TRUE DO
	BEGIN
	IF .GQC[GQC_SJH_N] EQL 0
	THEN
	    BEGIN
	    GQC[GQC_SJH_Q] = .GQC[GQC_SJH_Q] + 1;
	    CASE .GQC[GQC_SJH_Q] FROM GQC_K_CURRENT TO GQC_K_HOLD OF
		SET


		[OUTRANGE]:
		    BEGIN
		    RETURN JBC$_NOSUCHJOB;
		    END;


		[GQC_K_CURRENT]:
		    BEGIN
		    GQC[GQC_SJH_N] = .SMQ[SMQ$L_CURRENT_LIST];
		    END;


		[GQC_K_PENDING]:
		    BEGIN
		    IF .SMQ[SMQ$W_PENDING_JOB_COUNT] NEQ 0
		    THEN
			BEGIN
			LOCAL
			    SQH:	REF BBLOCK;

			SQH = READ_RECORD(SQH$K_RECNO);
			IF .SMQ[SMQ$V_BATCH]
			    THEN GQC[GQC_SJH_N] = .SQH[SQH$L_PENDING_BATCH_LIST]
			    ELSE GQC[GQC_SJH_N] = .SQH[SQH$L_PENDING_PRINT_LIST];
			RELEASE_RECORD(SQH$K_RECNO);
			END;
		    END;


		[GQC_K_TIMER]:
		    BEGIN
		    GQC[GQC_INTERVENING_BLOCKS] = 0;
		    GQC[GQC_INTERVENING_JOBS] = 0;
		    IF .SMQ[SMQ$W_TIMER_JOB_COUNT] NEQ 0
		    THEN
			BEGIN
			LOCAL
			    SQH:	REF BBLOCK;

			SQH = READ_RECORD(SQH$K_RECNO);
			GQC[GQC_SJH_N] = .SQH[SQH$L_TIMER_LIST];
			RELEASE_RECORD(SQH$K_RECNO);
			END;
		    END;


		[GQC_K_HOLD]:
		    BEGIN
		    GQC[GQC_SJH_N] = .SMQ[SMQ$L_HOLD_LIST];
		    END;


		TES;
	    END
	ELSE
	    BEGIN
	    IF .SJH_N EQL 0 THEN SJH = READ_RECORD(SJH_N = .GQC[GQC_SJH_N]);
	    IF TESTBITCC(GQC[GQC_SJH_NO_ADV])
		THEN GQC[GQC_SJH_N] = .SJH[SYM$L_LINK];
	    RELEASE_RECORD(.SJH_N);
	    END;


	IF .GQC[GQC_SJH_N] NEQ 0
	THEN
	    BEGIN
	    SJH = READ_RECORD(SJH_N = .GQC[GQC_SJH_N]);
	    GQC[GQC_SQR_N] = SQH$K_RECNO;
	    IF
		BEGIN
		IF ONEOF_(.GQC[GQC_SJH_Q], BMSK_(GQC_K_PENDING, GQC_K_TIMER))
		AND .SJH[SJH$L_QUEUE_LINK] NEQ .SMQ_N
		THEN
		    FALSE

		ELSE IF NOT .VALUE_SEARCH_FLAGS[QUI$V_SEARCH_ALL_JOBS]
		AND CH$NEQ(12, SJH[SJH$T_USERNAME], 12, MBX[ACM$T_USERNAME])
		THEN
		    BEGIN
		    IF .GQC[GQC_SJH_Q] EQL GQC_K_PENDING
		    THEN
			BEGIN
			GQC[GQC_INTERVENING_JOBS] = .GQC[GQC_INTERVENING_JOBS] + 1;
			IF NOT .SMQ[SMQ$V_BATCH]
			    THEN GQC[GQC_INTERVENING_BLOCKS] = .GQC[GQC_INTERVENING_BLOCKS] + .SJH[SJH$L_JOB_SIZE];
			END;
		    FALSE
		    END

		ELSE
		    TRUE
		END
	    THEN
		EXITLOOP;
	    END;
	END;
    END;


! Return information about the selected job.
!
RETURN_RESULT(
    .GQC,
    GENERATE_TABLE(
	QUI$_ACCOUNT_NAME,
		K_SJH,	K_COPY_TRIMMED,		TRUE,	$BYTEOFFSET(SJH$T_ACCOUNT),		SJH$S_ACCOUNT,
	QUI$_AFTER_TIME,
		K_SJH,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SJH$Q_AFTER_TIME),		SJH$S_AFTER_TIME,
	QUI$_CHARACTERISTICS,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$T_CHARACTERISTICS),	SJH$S_CHARACTERISTICS,
	QUI$_CHECKPOINT_DATA,
		K_SJH,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SJH$T_CHECKPOINT),		SJH$S_CHECKPOINT,
	QUI$_CLI,
		K_SJH,	K_COPY_ASCIC,		TRUE,	$BYTEOFFSET(SJH$T_CLI),			0,
	QUI$_COMPLETED_BLOCKS,
		K_SJH,	K_COMPLETED_BLOCKS,	FALSE,	0,					0,
	QUI$_CONDITION_VECTOR,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$L_CONDITION_1),		SJH$S_CONDITION_VECTOR,
	QUI$_CPU_LIMIT,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$L_CPU_MAXIMUM),		4,
	QUI$_ENTRY_NUMBER,
		K_SJH,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SYM$L_ENTRY_NUMBER),	4,
	QUI$_FORM_NAME,
		K_SJH,	K_COPY_FORM_NAME,	TRUE,	$BYTEOFFSET(SJH$L_FORM_LINK),		0,
	QUI$_INTERVENING_BLOCKS,
		0,	K_INTERVENING_BLOCKS,	FALSE,	0,					0,
	QUI$_INTERVENING_JOBS,
		0,	K_INTERVENING_JOBS,	FALSE,	0,					0,
	QUI$_JOB_COPIES,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_JOB_COPIES),		1,
	QUI$_JOB_COPIES_CHKPT,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_JOB_COPIES_CHKPT),	1,
	QUI$_JOB_COPIES_DONE,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_JOB_COPIES_DONE),	1,
	QUI$_JOB_FLAGS,
		K_SJH,	K_JOB_FLAGS,		TRUE,	0,					0,
	QUI$_JOB_NAME,
		K_SJH,	K_COPY_ASCIC,		TRUE,	$BYTEOFFSET(SJH$T_NAME),		0,
	QUI$_JOB_SIZE,
		K_SJH,	K_COPY_VALUE,		FALSE,	$BYTEOFFSET(SJH$L_JOB_SIZE),		4,
	QUI$_JOB_STATUS,
		K_SJH,	K_JOB_STATUS,		FALSE,	0,					0,
	QUI$_LOG_QUEUE,
		K_SJH,	K_COPY_QUEUE_NAME,	TRUE,	$BYTEOFFSET(SJH$L_LOG_QUEUE_LINK),	0,
	QUI$_LOG_SPECIFICATION,
		K_SJH,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SJH$T_LOG_SPECIFICATION),	SJH$S_LOG_SPECIFICATION,
	QUI$_NOTE,
		K_SJH,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SJH$T_NOTE),		SJH$S_NOTE,
	QUI$_OPERATOR_REQUEST,
		K_SJH,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SJH$T_OPERATOR_REQUEST),	SJH$S_OPERATOR_REQUEST,
	QUI$_PRIORITY,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_PRIORITY),		1,
	QUI$_QUEUE_NAME,
		K_SJH,	K_COPY_QUEUE_NAME,	TRUE,	$BYTEOFFSET(SJH$L_QUEUE_LINK),		0,
	QUI$_REFUSAL_REASON,
		K_SJH,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SJH$T_REFUSAL_REASON),	SJH$S_REFUSAL_REASON,
	QUI$_REQUEUE_PRIORITY,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$B_REQUEUE_PRIORITY),	1,
	QUI$_REQUEUE_QUEUE_NAME,
		K_SJH,	K_COPY_QUEUE_NAME,	TRUE,	$BYTEOFFSET(SJH$L_REQUEUE_QUEUE_LINK),	0,
	QUI$_SUBMISSION_TIME,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$Q_TIME),		SJH$S_TIME,
	QUI$_UIC,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$L_UIC),			4,
	QUI$_USERNAME,
		K_SJH,	K_COPY_TRIMMED,		TRUE,	$BYTEOFFSET(SJH$T_USERNAME),		SJH$S_USERNAME,
	QUI$_WSDEFAULT,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$W_WSDEFAULT),		2,
	QUI$_WSEXTENT,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$W_WSEXTENT),		2,
	QUI$_WSQUOTA,
		K_SJH,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SJH$W_WSQUOTA),		2),
    CHECK_R_ACCESS(.SMQ, .SJH),
    .SMQ_N, .SMQ, .SJH_N, .SJH)
END;

ROUTINE QUI_DISPLAY_QUEUE(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_DISPLAY_QUEUE request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block
LOCAL
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LITERAL
	K_SMQ=		K_REC_1;
LABEL
	FIND_SELECTED;


! If the search name is omitted, this request returns information about the
! current batch job.
!
IF NOT .ITEM_PRESENT[QUI$_SEARCH_NAME]
THEN
    BEGIN
    GQC[GQC_SQX_WILD] = FALSE;


    ! Locate the data for this job.
    !
    IF NOT FIND_PROCESS_DATA(
	PDE_K_BATCH, .MBX[ACM$L_PID], FALSE;
	, SMQ_N)
    THEN
	RETURN JBC$_NOSUCHQUE;


    SMQ = READ_RECORD(.SMQ_N);
    END
ELSE
    BEGIN

    ! Set the queue wildcard bit.
    !
    GQC[GQC_SQX_WILD] = WILD_SEARCH_NAME();


    ! If this is the first call, advance to the first queue index record.
    !
    IF .GQC[GQC_SQX_N] EQL SQH$K_RECNO
    THEN
	BEGIN
	LOCAL
	    SQH:		REF BBLOCK;	! Pointer to SQH

	SQH = READ_RECORD(SQH$K_RECNO);
	GQC[GQC_SQX_N] = .SQH[SQH$L_QUEUE_INDEX_LIST];
	GQC[GQC_SQE_N] = $BYTEOFFSET(SYM$T_DATA) - SQX$S_SQX;
	RELEASE_RECORD(SQH$K_RECNO);
	END;


    FIND_SELECTED:  BEGIN


    ! Loop over queue index records.
    !
    WHILE TRUE DO
	BEGIN
	LOCAL
	    SQX_N,			! Record number of SQX
	    SQX:	REF BBLOCK,	! Pointer to SQX
	    SQE:	REF BBLOCK;	! Pointer to SQX entry


	! No more records -- return failure.
	!
	IF .GQC[GQC_SQX_N] EQL 0
	THEN
	    BEGIN
	    GQC[GQC_SQX_WILD] = FALSE;
	    GQC[GQC_SMQ_N] = 0;
	    RETURN JBC$_NOSUCHQUE;
	    END;


	! Read the queue index record.
	!
	SQX = READ_RECORD(SQX_N = .GQC[GQC_SQX_N]);


	! Loop over queue entries.
	!
	WHILE TRUE DO
	    BEGIN

	    ! Advance to next entry, and ensure that it is valid.
	    !
	    IF TESTBITCC(GQC[GQC_SQX_NO_ADV])
		THEN GQC[GQC_SQE_N] = .GQC[GQC_SQE_N] + SQX$S_SQX;
	    IF .GQC[GQC_SQE_N] GEQU $BYTEOFFSET(SYM$T_DATA) + SQX$S_SQX * SQX$K_ENTRIES
		THEN EXITLOOP;
	    SQE = .SQX + .GQC[GQC_SQE_N];
	    IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0 THEN EXITLOOP;


	    ! Match this entry with the selector.
	    !
	    IF
		FMG$MATCH_NAME(
		    CH$RCHAR(SQE[SQX$T_NAME]),
		    SQE[SQX$T_NAME] + 1,
		    .VALUE_SEARCH_NAME[SDSC_W_LENGTH],
		    .VALUE_SEARCH_NAME[SDSC_A_POINTER])
	    AND
		BEGIN
		IF .ITEM_PRESENT[QUI$_SEARCH_FLAGS]
		THEN
		    IF NOT .VALUE_SEARCH_FLAGS[QUI$V_SEARCH_BATCH]
		    AND NOT .VALUE_SEARCH_FLAGS[QUI$V_SEARCH_SYMBIONT]
		    THEN
			TRUE
		    ELSE
			(.VALUE_SEARCH_FLAGS[QUI$V_SEARCH_BATCH]
			    AND .SQE[SQX$V_BATCH]) OR
			(.VALUE_SEARCH_FLAGS[QUI$V_SEARCH_SYMBIONT]
			    AND NOT .SQE[SQX$V_BATCH])
		ELSE
		    TRUE
		END
	    THEN
		BEGIN
		GQC[GQC_SMQ_N] = SMQ_N = .SQE[SQX$L_QUEUE_LINK];
		GQC[GQC_SJH_Q] = GQC_K_NONE;
		GQC[GQC_SJH_N] = 0;
		SMQ = READ_RECORD(.SMQ_N);
		LEAVE FIND_SELECTED;
		END;
	    END;


	! Advance to next queue index record.
	!
	GQC[GQC_SQX_N] = .SQX[SYM$L_LINK];
	GQC[GQC_SQE_N] = $BYTEOFFSET(SYM$T_DATA) - SQX$S_SQX;
	RELEASE_RECORD(.SQX_N);
	END;


    END; ! of block FIND_SELECTED


    END;


! Return information about the selected queue.
!
RETURN_RESULT(
    .GQC,
    GENERATE_TABLE(
	QUI$_ASSIGNED_QUEUE_NAME,
		K_SMQ,	K_COPY_QUEUE_NAME,	TRUE,	$BYTEOFFSET(SMQ$L_ASSIGNED_QUEUE_LINK),	0,
	QUI$_BASE_PRIORITY,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$B_BASE_PRIORITY),	1,
	QUI$_CHARACTERISTICS,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$T_CHARACTERISTICS),	SMQ$S_CHARACTERISTICS,
	QUI$_CPU_DEFAULT,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$L_CPU_DEFAULT),		4,
	QUI$_CPU_LIMIT,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$L_CPU_MAXIMUM),		4,
	QUI$_DEVICE_NAME,
		K_SMQ,	K_COPY_ASCIC,		TRUE,	$BYTEOFFSET(SMQ$T_DEVICE_NAME),		0,
	QUI$_FORM_NAME,
		K_SMQ,	K_COPY_FORM_NAME,	TRUE,	$BYTEOFFSET(SMQ$L_FORM_LINK),		0,
	QUI$_GENERIC_TARGET,
		K_SMQ,	K_GENERIC_TARGET,	TRUE,	$BYTEOFFSET(SMQ$L_GENERIC_TARGET),	0,
	QUI$_JOB_LIMIT,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$B_JOB_LIMIT),		1,
	QUI$_JOB_RESET_MODULES,
		K_SMQ,	K_COPY_VARIABLE,	TRUE,	$BYTEOFFSET(SMQ$T_JOB_RESET_MODULES),	SMQ$S_JOB_RESET_MODULES,
	QUI$_JOB_SIZE_MAXIMUM,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$L_JOB_SIZE_MAXIMUM),	4,
	QUI$_JOB_SIZE_MINIMUM,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$L_JOB_SIZE_MINIMUM),	4,
	QUI$_LIBRARY_SPECIFICATION,
		K_SMQ,	K_COPY_ASCIC,		TRUE,	$BYTEOFFSET(SMQ$T_LIBRARY),		0,
	QUI$_OWNER_UIC,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$L_OWNER_UIC),		4,
	QUI$_PROCESSOR,
		K_SMQ,	K_COPY_ASCIC,		TRUE,	$BYTEOFFSET(SMQ$T_PROCESSOR),		0,
	QUI$_PROTECTION,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$W_PROTECTION),		2,
	QUI$_QUEUE_FLAGS,
		K_SMQ,	K_QUEUE_FLAGS,		TRUE,	0,					0,
	QUI$_QUEUE_NAME,
		K_SMQ,	K_COPY_ASCIC,		FALSE,	$BYTEOFFSET(SMQ$T_NAME),		0,
	QUI$_QUEUE_STATUS,
		K_SMQ,	K_QUEUE_STATUS,		TRUE,	0,					0,
	QUI$_SCSNODE_NAME,
		K_SMQ,	K_COPY_TRIMMED,		TRUE,	$BYTEOFFSET(SMQ$T_SYSID),		SMQ$S_SYSID,
	QUI$_WSDEFAULT,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$W_WSDEFAULT),		2,
	QUI$_WSEXTENT,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$W_WSEXTENT),		2,
	QUI$_WSQUOTA,
		K_SMQ,	K_COPY_VALUE,		TRUE,	$BYTEOFFSET(SMQ$W_WSQUOTA),		2),
    TRUE,
    .SMQ_N, .SMQ)
END;

ROUTINE QUI_RESERVED_FUNC_1=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_RESERVED_FUNC_1 request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SS$_NORMAL
END;

ROUTINE QUI_RESERVED_FUNC_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_RESERVED_FUNC_2 request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SS$_NORMAL
END;

ROUTINE QUI_TRANSLATE_QUEUE(GQC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the QUI$_TRANSLATE_QUEUE request.
!
! INPUT PARAMETERS:
!	GQC		- Pointer to $GETQUI context block.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block
LOCAL
	SDSC:		BBLOCK[SDSC_K_LENGTH];	! Short descriptor for queue name
LITERAL
	K_SDSC=		K_REC_1;


! Ensure that a search name was specified.
!
IF NOT .ITEM_PRESENT[QUI$_SEARCH_NAME]
THEN
    RETURN JBC$_MISREQPAR;


! Validate the search name.
!
IF NOT VALIDATE_OBJECT_NAME(
    .VALUE_SEARCH_NAME[SDSC_W_LENGTH], .VALUE_SEARCH_NAME[SDSC_A_POINTER],
    SDSC)
THEN
    RETURN JBC$_INVQUENAM;


! Return information about the selected queue.
!
RETURN_RESULT(
    .GQC,
    GENERATE_TABLE(
	QUI$_QUEUE_NAME,
		K_SDSC,	K_COPY_SDSC,		FALSE,	0,					0),
    TRUE,
    0, SDSC)
END;

ROUTINE PROCESS_ONE_OPTION(CODE,VALUE_SIZE,VALUE_ADDRESS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine validates and stores one parameter value for the $GETQUI
!	service.
!
! INPUT PARAMETERS:
!	CODE		- $GETQUI item code.
!	VALUE_SIZE	- Length of item value.
!	VALUE_ADDRESS	- Address of item value.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Values in the item list in internal storage.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	VALUE_ADDRESS:	REF BBLOCK;	! Pointer to parameter value


OWN
	REQUIRED_VALUE_SIZE:
	    VECTOR[MAX_GETQUI_ITEM+1,WORD,SIGNED] PSECT(CODE) PRESET(
		[QUI$_RESERVED_INPUT_1]=	4,
		[QUI$_RESERVED_INPUT_2]=	0,
		[QUI$_SEARCH_FLAGS]=		4,
		[QUI$_SEARCH_NAME]=		0,
		[QUI$_SEARCH_NUMBER]=		4);


LITERAL
	K_OUTPUT_ITEM=			1,
	K_STRING=			2,
	K_VALUE=			3;


OWN
	VALUE_STORAGE_CASE:
	    VECTOR[MAX_GETQUI_ITEM+1,BYTE] PSECT(CODE) PRESET(
		[QUI$_ACCOUNT_NAME]=		K_OUTPUT_ITEM,
		[QUI$_AFTER_TIME]=		K_OUTPUT_ITEM,
		[QUI$_ASSIGNED_QUEUE_NAME]=	K_OUTPUT_ITEM,
		[QUI$_BASE_PRIORITY]=		K_OUTPUT_ITEM,
		[QUI$_CHARACTERISTIC_NAME]=	K_OUTPUT_ITEM,
		[QUI$_CHARACTERISTIC_NUMBER]=	K_OUTPUT_ITEM,
		[QUI$_CHARACTERISTICS]=		K_OUTPUT_ITEM,
		[QUI$_CHECKPOINT_DATA]=		K_OUTPUT_ITEM,
		[QUI$_CLI]=			K_OUTPUT_ITEM,
		[QUI$_COMPLETED_BLOCKS]=	K_OUTPUT_ITEM,
		[QUI$_CONDITION_VECTOR]=	K_OUTPUT_ITEM,
		[QUI$_CPU_DEFAULT]=		K_OUTPUT_ITEM,
		[QUI$_CPU_LIMIT]=		K_OUTPUT_ITEM,
		[QUI$_DEVICE_NAME]=		K_OUTPUT_ITEM,
		[QUI$_ENTRY_NUMBER]=		K_OUTPUT_ITEM,
		[QUI$_FILE_COPIES]=		K_OUTPUT_ITEM,
		[QUI$_FILE_COPIES_CHKPT]=	K_OUTPUT_ITEM,
		[QUI$_FILE_COPIES_DONE]=	K_OUTPUT_ITEM,
		[QUI$_FILE_FLAGS]=		K_OUTPUT_ITEM,
		[QUI$_FILE_SETUP_MODULES]=	K_OUTPUT_ITEM,
		[QUI$_FILE_SPECIFICATION]=	K_OUTPUT_ITEM,
		[QUI$_FILE_STATUS]=		K_OUTPUT_ITEM,
		[QUI$_FIRST_PAGE]=		K_OUTPUT_ITEM,
		[QUI$_FORM_DESCRIPTION]=	K_OUTPUT_ITEM,
		[QUI$_FORM_FLAGS]=		K_OUTPUT_ITEM,
		[QUI$_FORM_LENGTH]=		K_OUTPUT_ITEM,
		[QUI$_FORM_MARGIN_BOTTOM]=	K_OUTPUT_ITEM,
		[QUI$_FORM_MARGIN_LEFT]=	K_OUTPUT_ITEM,
		[QUI$_FORM_MARGIN_RIGHT]=	K_OUTPUT_ITEM,
		[QUI$_FORM_MARGIN_TOP]=		K_OUTPUT_ITEM,
		[QUI$_FORM_NAME]=		K_OUTPUT_ITEM,
		[QUI$_FORM_NUMBER]=		K_OUTPUT_ITEM,
		[QUI$_FORM_SETUP_MODULES]=	K_OUTPUT_ITEM,
		[QUI$_FORM_STOCK]=		K_OUTPUT_ITEM,
		[QUI$_FORM_WIDTH]=		K_OUTPUT_ITEM,
		[QUI$_GENERIC_TARGET]=		K_OUTPUT_ITEM,
		[QUI$_INTERVENING_BLOCKS]=	K_OUTPUT_ITEM,
		[QUI$_INTERVENING_JOBS]=	K_OUTPUT_ITEM,
		[QUI$_JOB_COPIES]=		K_OUTPUT_ITEM,
		[QUI$_JOB_COPIES_CHKPT]=	K_OUTPUT_ITEM,
		[QUI$_JOB_COPIES_DONE]=		K_OUTPUT_ITEM,
		[QUI$_JOB_FLAGS]=		K_OUTPUT_ITEM,
		[QUI$_JOB_LIMIT]=		K_OUTPUT_ITEM,
		[QUI$_JOB_NAME]=		K_OUTPUT_ITEM,
		[QUI$_JOB_RESET_MODULES]=	K_OUTPUT_ITEM,
		[QUI$_JOB_SIZE]=		K_OUTPUT_ITEM,
		[QUI$_JOB_SIZE_MAXIMUM]=	K_OUTPUT_ITEM,
		[QUI$_JOB_SIZE_MINIMUM]=	K_OUTPUT_ITEM,
		[QUI$_JOB_STATUS]=		K_OUTPUT_ITEM,
		[QUI$_LAST_PAGE]=		K_OUTPUT_ITEM,
		[QUI$_LIBRARY_SPECIFICATION]=	K_OUTPUT_ITEM,
		[QUI$_LOG_QUEUE]=		K_OUTPUT_ITEM,
		[QUI$_LOG_SPECIFICATION]=	K_OUTPUT_ITEM,
		[QUI$_NOTE]=			K_OUTPUT_ITEM,
		[QUI$_OPERATOR_REQUEST]=	K_OUTPUT_ITEM,
		[QUI$_OWNER_UIC]=		K_OUTPUT_ITEM,
		[QUI$_PAGE_SETUP_MODULES]=	K_OUTPUT_ITEM,
		[QUI$_PARAMETER_1]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_2]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_3]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_4]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_5]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_6]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_7]=		K_OUTPUT_ITEM,
		[QUI$_PARAMETER_8]=		K_OUTPUT_ITEM,
		[QUI$_PRIORITY]=		K_OUTPUT_ITEM,
		[QUI$_PROCESSOR]=		K_OUTPUT_ITEM,
		[QUI$_PROTECTION]=		K_OUTPUT_ITEM,
		[QUI$_QUEUE_FLAGS]=		K_OUTPUT_ITEM,
		[QUI$_QUEUE_NAME]=		K_OUTPUT_ITEM,
		[QUI$_QUEUE_STATUS]=		K_OUTPUT_ITEM,
		[QUI$_REFUSAL_REASON]=		K_OUTPUT_ITEM,
		[QUI$_REQUEUE_PRIORITY]=	K_OUTPUT_ITEM,
		[QUI$_REQUEUE_QUEUE_NAME]=	K_OUTPUT_ITEM,
		[QUI$_RESERVED_INPUT_1]=	K_VALUE,
		[QUI$_RESERVED_INPUT_2]=	K_STRING,
		[QUI$_RESERVED_OUTPUT_1]=	K_OUTPUT_ITEM,
		[QUI$_RESERVED_OUTPUT_2]=	K_OUTPUT_ITEM,
		[QUI$_RESERVED_OUTPUT_3]=	K_OUTPUT_ITEM,
		[QUI$_RESERVED_OUTPUT_4]=	K_OUTPUT_ITEM,
		[QUI$_RESERVED_OUTPUT_5]=	K_OUTPUT_ITEM,
		[QUI$_RESERVED_OUTPUT_6]=	K_OUTPUT_ITEM,
		[QUI$_SCSNODE_NAME]=		K_OUTPUT_ITEM,
		[QUI$_SEARCH_FLAGS]=		K_VALUE,
		[QUI$_SEARCH_NAME]=		K_STRING,
		[QUI$_SEARCH_NUMBER]=		K_VALUE,
		[QUI$_SUBMISSION_TIME]=		K_OUTPUT_ITEM,
		[QUI$_UIC]=			K_OUTPUT_ITEM,
		[QUI$_USERNAME]=		K_OUTPUT_ITEM,
		[QUI$_WSDEFAULT]=		K_OUTPUT_ITEM,
		[QUI$_WSEXTENT]=		K_OUTPUT_ITEM,
		[QUI$_WSQUOTA]=			K_OUTPUT_ITEM);


LOCAL
	VALUE_STORAGE:	REF BBLOCK;	! Pointer to internal storage area


IF
    BEGIN
    IF .REQUIRED_VALUE_SIZE[.CODE] EQL 0
    THEN
	FALSE
    ELSE IF .REQUIRED_VALUE_SIZE[.CODE] LSS 0
    THEN
	.VALUE_SIZE GTRU - .REQUIRED_VALUE_SIZE[.CODE]
    ELSE
	.VALUE_SIZE NEQ .REQUIRED_VALUE_SIZE[.CODE]
    END
THEN
    RETURN JBC$_INVPARLEN;


VALUE_STORAGE = VALUE_GETQUI_BASE + .CODE * ODSC_S_ENTRY;


CASE .VALUE_STORAGE_CASE[.CODE] FROM K_OUTPUT_ITEM TO K_VALUE OF
    SET


    [K_OUTPUT_ITEM]:
	BEGIN
	VALUE_STORAGE[ODSC_W_LENGTH] = .VALUE_SIZE;
	VALUE_STORAGE[ODSC_A_POINTER] = .VALUE_ADDRESS[0,0,32,0];
	VALUE_STORAGE[ODSC_A_LENPOINTER] = .VALUE_ADDRESS[4,0,32,0];
	END;


    [K_STRING]:
	BEGIN
	IF .VALUE_SIZE EQL 0 THEN RETURN JBC$_INVPARLEN;
	VALUE_STORAGE[SDSC_W_LENGTH] = .VALUE_SIZE;
	VALUE_STORAGE[SDSC_A_POINTER] = .VALUE_ADDRESS;
	END;


    [K_VALUE]:
	CH$MOVE(.VALUE_SIZE, .VALUE_ADDRESS, .VALUE_STORAGE);


    TES;


ITEM_PRESENT[.CODE] = TRUE;
SS$_NORMAL
END;

ROUTINE PROCESS_GETQUI_ITEM_LIST=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the item list of a $GETQUI service into internal
!	data structures.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Values in the item list in internal storage.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	VALUE_CURSOR:	REF BBLOCK,	! Cursor over item list
	VALID_ITEMS:	REF BITVECTOR;	! Pointer to mask of valid item codes


MACRO
	BOOLEAN_VECTOR[]=
	    BITVECTOR[MAX_GETQUI_ITEM+1] PSECT(CODE) ALIGN(0)
	    PRESET(BOOLEAN_VECTOR_1(%REMAINING)) %,

	BOOLEAN_VECTOR_1[A]=
	    [A] = TRUE %;


OWN
	NO_BITS:
	    BITVECTOR[MAX_GETQUI_ITEM+1] PSECT(CODE) ALIGN(0) INITIAL(0),

	DISPLAY_CHARACTERISTIC_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_SEARCH_FLAGS,
		QUI$_SEARCH_NAME,
		QUI$_CHARACTERISTIC_NAME,
		QUI$_CHARACTERISTIC_NUMBER),

	DISPLAY_FILE_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_SEARCH_FLAGS,
		QUI$_FILE_COPIES,
		QUI$_FILE_COPIES_CHKPT,
		QUI$_FILE_COPIES_DONE,
		QUI$_FILE_FLAGS,
		QUI$_FILE_SETUP_MODULES,
		QUI$_FILE_SPECIFICATION,
		QUI$_FILE_STATUS,
		QUI$_FIRST_PAGE,
		QUI$_LAST_PAGE),

	DISPLAY_FORM_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_SEARCH_FLAGS,
		QUI$_SEARCH_NAME,
		QUI$_SEARCH_NUMBER,
		QUI$_FORM_DESCRIPTION,
		QUI$_FORM_FLAGS,
		QUI$_FORM_LENGTH,
		QUI$_FORM_MARGIN_BOTTOM,
		QUI$_FORM_MARGIN_LEFT,
		QUI$_FORM_MARGIN_RIGHT,
		QUI$_FORM_MARGIN_TOP,
		QUI$_FORM_NAME,
		QUI$_FORM_NUMBER,
		QUI$_FORM_SETUP_MODULES,
		QUI$_FORM_STOCK,
		QUI$_FORM_WIDTH,
		QUI$_PAGE_SETUP_MODULES),

	DISPLAY_JOB_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_SEARCH_FLAGS,
		QUI$_SEARCH_NAME,
		QUI$_SEARCH_NUMBER,
		QUI$_ACCOUNT_NAME,
		QUI$_AFTER_TIME,
		QUI$_CHARACTERISTICS,
		QUI$_CHECKPOINT_DATA,
		QUI$_CLI,
		QUI$_COMPLETED_BLOCKS,
		QUI$_CONDITION_VECTOR,
		QUI$_CPU_LIMIT,
		QUI$_ENTRY_NUMBER,
		QUI$_FORM_NAME,
		QUI$_INTERVENING_BLOCKS,
		QUI$_INTERVENING_JOBS,
		QUI$_JOB_COPIES,
		QUI$_JOB_COPIES_CHKPT,
		QUI$_JOB_COPIES_DONE,
		QUI$_JOB_FLAGS,
		QUI$_JOB_NAME,
		QUI$_JOB_SIZE,
		QUI$_JOB_STATUS,
		QUI$_LOG_QUEUE,
		QUI$_LOG_SPECIFICATION,
		QUI$_NOTE,
		QUI$_OPERATOR_REQUEST,
		QUI$_PARAMETER_1,
		QUI$_PARAMETER_2,
		QUI$_PARAMETER_3,
		QUI$_PARAMETER_4,
		QUI$_PARAMETER_5,
		QUI$_PARAMETER_6,
		QUI$_PARAMETER_7,
		QUI$_PARAMETER_8,
		QUI$_PRIORITY,
		QUI$_QUEUE_NAME,
		QUI$_REFUSAL_REASON,
		QUI$_REQUEUE_PRIORITY,
		QUI$_REQUEUE_QUEUE_NAME,
		QUI$_SUBMISSION_TIME,
		QUI$_UIC,
		QUI$_USERNAME,
		QUI$_WSDEFAULT,
		QUI$_WSEXTENT,
		QUI$_WSQUOTA),

	DISPLAY_QUEUE_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_SEARCH_FLAGS,
		QUI$_SEARCH_NAME,
		QUI$_ASSIGNED_QUEUE_NAME,
		QUI$_BASE_PRIORITY,
		QUI$_CHARACTERISTICS,
		QUI$_CPU_DEFAULT,
		QUI$_CPU_LIMIT,
		QUI$_DEVICE_NAME,
		QUI$_FORM_NAME,
		QUI$_GENERIC_TARGET,
		QUI$_JOB_LIMIT,
		QUI$_JOB_RESET_MODULES,
		QUI$_JOB_SIZE_MAXIMUM,
		QUI$_JOB_SIZE_MINIMUM,
		QUI$_LIBRARY_SPECIFICATION,
		QUI$_OWNER_UIC,
		QUI$_PROCESSOR,
		QUI$_PROTECTION,
		QUI$_QUEUE_FLAGS,
		QUI$_QUEUE_NAME,
		QUI$_QUEUE_STATUS,
		QUI$_SCSNODE_NAME,
		QUI$_WSDEFAULT,
		QUI$_WSEXTENT,
		QUI$_WSQUOTA),

	RESERVED_FUNC_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_RESERVED_INPUT_1,
		QUI$_RESERVED_INPUT_2,
		QUI$_RESERVED_OUTPUT_1,
		QUI$_RESERVED_OUTPUT_2,
		QUI$_RESERVED_OUTPUT_3,
		QUI$_RESERVED_OUTPUT_4,
		QUI$_RESERVED_OUTPUT_5,
		QUI$_RESERVED_OUTPUT_6),

	TRANSLATE_QUEUE_OPTIONS:
	    BOOLEAN_VECTOR(
		QUI$_SEARCH_NAME,
		QUI$_QUEUE_NAME),

	VALID_ITEM_TABLE:	VECTOR[MAX_GETQUI_FUNC+1] PSECT(CODE) PRESET(
		[QUI$_CANCEL_OPERATION]=	NO_BITS,
		[QUI$_DISPLAY_CHARACTERISTIC]=	DISPLAY_CHARACTERISTIC_OPTIONS,
		[QUI$_DISPLAY_FILE]=		DISPLAY_FILE_OPTIONS,
		[QUI$_DISPLAY_FORM]=		DISPLAY_FORM_OPTIONS,
		[QUI$_DISPLAY_JOB]=		DISPLAY_JOB_OPTIONS,
		[QUI$_DISPLAY_QUEUE]=		DISPLAY_QUEUE_OPTIONS,
		[QUI$_RESERVED_FUNC_1]=		RESERVED_FUNC_OPTIONS,
		[QUI$_RESERVED_FUNC_2]=		RESERVED_FUNC_OPTIONS,
		[QUI$_TRANSLATE_QUEUE]=		TRANSLATE_QUEUE_OPTIONS),

	INPUT_ITEM:
	    BOOLEAN_VECTOR(
		QUI$_RESERVED_INPUT_1,
		QUI$_RESERVED_INPUT_2,
		QUI$_SEARCH_FLAGS,
		QUI$_SEARCH_NAME,
		QUI$_SEARCH_NUMBER);


! Initialize to scan the item list.
!
CH$FILL(0, VALUE_STORAGE_END - VALUE_STORAGE_BASE, VALUE_STORAGE_BASE);
VALUE_CURSOR = MBX[ACM$T_ITMLST];
VALID_ITEMS = .VALID_ITEM_TABLE[.MBX[ACM$W_FUNC]];


! Loop over all elements of the item list.
!
WHILE .VALUE_CURSOR LSSA .MBX_END DO
    BEGIN
    LOCAL
	VALUE_SIZE,
	CODE,			! Item code
	STATUS;


    ! Fetch and validate the item code.
    !
    CODE = .VALUE_CURSOR[0,0,16,0];
    VALUE_CURSOR = .VALUE_CURSOR + 2;
    IF .CODE LSSU MIN_GETQUI_ITEM OR .CODE GTRU MAX_GETQUI_ITEM
	THEN RETURN JBC$_INVITMCOD;
    IF NOT .VALID_ITEMS[.CODE]
	THEN RETURN JBC$_INVITMCOD;
    ITEM_PRESENT[.CODE] = TRUE;


    ! Fetch and validate the item's parameter value.
    !
    VALUE_SIZE = .VALUE_CURSOR[0,0,16,0];
    VALUE_CURSOR = .VALUE_CURSOR + 2;
    STATUS = PROCESS_ONE_OPTION(.CODE, .VALUE_SIZE, .VALUE_CURSOR);
    IF NOT .STATUS THEN RETURN .STATUS;
    IF .INPUT_ITEM[.CODE]
	THEN VALUE_CURSOR = .VALUE_CURSOR + .VALUE_SIZE
	ELSE VALUE_CURSOR = .VALUE_CURSOR + 8;
    END;


SS$_NORMAL
END;

ROUTINE FIND_GQC(PID)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds the open $GETQUI context block for a specified
!	process.
!
! INPUT PARAMETERS:
!	PID		- Process ID.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Pointer to $GETQUI context block or 0.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PREV,				! Pointer to link to GQC
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block


! Locate the $GETQUI context block.
!
PREV = OPEN_GETQUI_LIST;
GQC = ..PREV;
WHILE .GQC NEQ 0 DO
    BEGIN
    IF .GQC[GQC_PID] EQL .PID
    THEN
	BEGIN
	.PREV = .GQC[GQC_LINK];
	EXITLOOP;
	END;
    PREV = .GQC;
    GQC = ..PREV;
    END;


.GQC
END;

GLOBAL ROUTINE GETQUI_SERVICE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the message type:
!		MSG$_GETQUI		get queue information
!	by dispatching to a request-specific routine.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
OWN
	PROCESSING_ROUTINE:		VECTOR[MAX_GETQUI_FUNC+1]
	    PSECT(CODE) PRESET(
		[QUI$_CANCEL_OPERATION]=	QUI_CANCEL_OPERATION,
		[QUI$_DISPLAY_CHARACTERISTIC]=	QUI_DISPLAY_CHARACTERISTIC,
		[QUI$_DISPLAY_FILE]=		QUI_DISPLAY_FILE,
		[QUI$_DISPLAY_FORM]=		QUI_DISPLAY_FORM,
		[QUI$_DISPLAY_JOB]=		QUI_DISPLAY_JOB,
		[QUI$_DISPLAY_QUEUE]=		QUI_DISPLAY_QUEUE,
		[QUI$_RESERVED_FUNC_1]=		QUI_RESERVED_FUNC_1,
		[QUI$_RESERVED_FUNC_2]=		QUI_RESERVED_FUNC_2,
		[QUI$_TRANSLATE_QUEUE]=		QUI_TRANSLATE_QUEUE);

LOCAL
	GQC:		REF BBLOCK,	! Pointer to $GETQUI context block
	SAVED_GQC:	BBLOCK[GQC_K_LENGTH], ! Saved GQC before operation
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Ensure that the function code is in range.
!
DIAG_TRACE[1] = .MBX[ACM$W_FUNC];	! ***** diagnostic info *****
IF .MBX[ACM$W_FUNC] LSSU MIN_GETQUI_FUNC
OR .MBX[ACM$W_FUNC] GTRU MAX_GETQUI_FUNC
THEN
    RETURN JBC$_INVFUNCOD;

GETQUI_COUNT[.MBX[ACM$W_FUNC]] = .GETQUI_COUNT[.MBX[ACM$W_FUNC]] + 1;


! Ensure that the queue file is open, and lock it.
!
IF .MBX[ACM$W_FUNC] NEQ QUI$_TRANSLATE_QUEUE
THEN
    BEGIN
    IF .QUEUE_FAB[FAB$W_IFI] EQL 0 THEN RETURN JBC$_JOBQUEDIS;
    LOCK_QUEUE_FILE();
    END;


! Process the item list.
!
STATUS_1 = PROCESS_GETQUI_ITEM_LIST();
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Locate the $GETQUI context block.
!
GQC = FIND_GQC(.MBX[ACM$L_PID]);


! If none found, allocate one.
!
IF .GQC EQL 0
THEN
    BEGIN
    GQC = ALLOCATE_MEMORY();
    GQC[GQC_PID] = .MBX[ACM$L_PID];
    GQC[GQC_SCX_N] = SQH$K_RECNO;
    GQC[GQC_SFX_N] = SQH$K_RECNO;
    GQC[GQC_SQX_N] = SQH$K_RECNO;
    END;


! Save the original context block.
!
CH$MOVE(GQC_K_LENGTH, .GQC, SAVED_GQC);


! Set the forced wildcard flag if required.
!
IF .ITEM_PRESENT[QUI$_SEARCH_FLAGS]
THEN
    GQC[GQC_FLG_WILD] = .VALUE_SEARCH_FLAGS[QUI$V_SEARCH_WILDCARD];


! Dispatch to execute the request.
!
STATUS_2 = (.PROCESSING_ROUTINE[.MBX[ACM$W_FUNC]])(.GQC);


! Link the $GETQUI context block to the open list or deallocate it.
!
IF .GQC[GQC_WILDCARDS] NEQ 0
THEN
    BEGIN
    UPDATE_GETQUI_LOCKS(SAVED_GQC, .GQC);
    GQC[GQC_LINK] = .OPEN_GETQUI_LIST;
    OPEN_GETQUI_LIST = .GQC;
    END
ELSE
    BEGIN
    UPDATE_GETQUI_LOCKS(SAVED_GQC, 0);
    DEALLOCATE_MEMORY(.GQC);
    END;


.STATUS_2
END;

GLOBAL ROUTINE DELETE_GETQUI_CONTEXT(PID): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes the $GETQUI context block for a process, if one
!	exists, when the process deletion message is received.
!
! INPUT PARAMETERS:
!	PID		- Process ID.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block


! Locate the $GETQUI context block.
!
GQC = FIND_GQC(.PID);
IF .GQC NEQ 0
THEN
    BEGIN
    UPDATE_GETQUI_LOCKS(.GQC, 0);
    DEALLOCATE_MEMORY(.GQC);
    END;
END;

GLOBAL ROUTINE DELETE_OPEN_GETQUIS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes all context associated with open $GETQUI operations
!	when the queue file is closed.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Delete active $GETQUI context blocks.
!
WHILE .OPEN_GETQUI_LIST NEQ 0 DO
    BEGIN
    LOCAL
	GQC:		REF BBLOCK;	! Pointer to $GETQUI context block


    GQC = .OPEN_GETQUI_LIST;
    OPEN_GETQUI_LIST = .GQC[GQC_LINK];
    DEALLOCATE_MEMORY(.GQC);
    END;


! Delete active $GETQUI lock blocks.
!
WHILE .GQL_ACTIVE_LIST NEQ 0 DO
    BEGIN
    LOCAL
	GQL:		REF BBLOCK;	! Pointer to $GETQUI lock block


    GQL = .GQL_ACTIVE_LIST;
    GQL_ACTIVE_LIST = .GQL[GQL_LINK];
    $DEQ(LKID=.GQL[GQL_LKID]);
    CH$COPY(4, GQL_FREE_LIST, 0, GQL_K_LENGTH, .GQL);
    GQL_FREE_LIST = .GQL;
    END;
END;

END
ELUDOM
