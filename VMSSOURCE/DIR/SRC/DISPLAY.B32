MODULE DISPLAY (
		 LANGUAGE (BLISS32),
		 IDENT = 'V04-000'
		 ) =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	DIRECTORY
!
! ABSTRACT:
!
!	This module contains all of the routines necessary to display the
!	information gathered about the selected files.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, unprivileged user mode utilities.
!
!--
!
! AUTHOR:	L. Mark Pilant		CREATION DATE:  4-Mar-1983
!
! MODIFIED BY:
!
!	V03-020	LMP0296		L. Mark Pilant,		6-Aug-1984  13:01
!		Access the file by "file-ID" during /FULL if the device is
!		a sequential device (i.e., a magtape).  This is to compensate
!		for a bug in the magtape ACP.
!
!	V03-019	LMP0282		L. Mark Pilant,		25-Jul-1984  9:58
!		Check the info needed flags, not the qualifier present flags,
!		when determining if information is needed about a file.
!
!	V03-018	LMP0227		L. Mark Pilant,		9-Apr-1984  11:20
!		Use FIB$L_ACL_STATUS to check the results of the READACL
!		operation.  Also, only read the ACL in 512 byte chunks, rather
!		than trying to read in the entire ACL.
!
!	V03-017	LMP0220		L. Mark Pilant,		24-Mar-1984  23:33
!		Remove references to journaling.
!
!	V03-016	LMP0212		L. Mark Pilant,		12-Mar-1984  15:01
!		Make sure that a new channel is allocated not only when
!		the device changes, but if no channel was previously assigned.
!
!	V03-015	LMP0211		L. Mark Pilant,		10-Mar-1984  12:49
!		Display all of the useful information obtained directly from
!		the disk ACP in the /FULL display.  Also correct a bug that
!		caused long file names to be truncated when the /SINCE
!		qualifier was the only qualifier given on the command line.
!
!	V03-014	LMP0187		L. Mark Pilant,		2-Feb-1984  17:29
!		Fix a bug that caused the first ACE to be dropped from the
!		ACL display during a full display.
!
!	V03-013	LMP0182		L. Mark Pilant,		11-Jan-1984  12:48
!		Only do selection when the /SELECT qualifier was given.
!
!	V03-012	LMP0176		L. Mark Pilant,		6-Dec-1983  9:08
!		Use the correct display width when formatting an ACE.
!
!	V03-011	LMP0171		L. Mark Pilant,		23-Nov-1983  10:08
!		Use the display width when formatting an ACE, not a fixed
!		value.  Also impliment the size selection item (this was
!		dropped on the floor).
!
!	V03-010	LMP0163		L. Mark Pilant,		10-Oct-1983  9:32
!		Correct a bug that caused an RMS IFI error when using any
!		of the common qualifiers (and RMS was gathering the info).
!
!	V03-009	LMP0160		L. Mark Pilant,		3-Oct-1983  15:10
!		Return the channel if the ACP QIO to get the file
!		information fails.
!
!	V03-008	LMP0157		L. Mark Pilant,		27-Sep-1983  10:57
!		Add support for a unique message file.
!
!	V03-007	LMP0155		L. Mark Pilant,		19-Sep-1983  11:33
!		Fix a bug that caused the RMS journaling names to be put
!		in the wrong place when obtained directly from the ACP.
!
!	V03-006	LMP0140		L. Mark Pilant,		24-Aug-1983  1:55
!		Remove temporary hack for identifiers.  Also, fix a bug
!		that caused second network access for network directories.
!
!	V03-005	DAS0001		David Solomon		29-Jul-1983
!		Journaling bit RUA is now ONLY_RU.
!
!	V03-004	LMP0119		L. Mark Pilant,		15-Jun-1983  11:58
!		Add support for identifiers.
!
!	V03-003	LMP0108		L. Mark Pilant,		28-Apr-1983  11:05
!		Don't double space when listing only the file name in 
!		one column.  Also, add support for RMS journaling.
!
!	V03-002	LMP0100		L. Mark Pilant,		14-Apr-1983  11:48
!		Misc fixups.  Also add $FORMAT_ACL system service.
!
!	V03-001	LMP0096		L. Mark Pilant,		29-Mar-1983  10:10
!		Correctly handle locked files.
!
!**

LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'SRC$:DIRECTDEF';

FORWARD ROUTINE
	DIR$GET_INFO,				! Get information about a file
	DIR$RMS_FILL,				! Get specific info from RMS
	DIR$ACP_FILL,				! Get specific info from the ACP
	DIR$SHOW_INFO,				! Display gathered information
	DIR$SHOW_FULL,				! Display all information
	DIR$SHOW_ACL,				! Display the file's ACL
	DIR$TOTAL,				! Display per directory totals
	DIR$GRAND_TOTAL,			! Display overall totals
	DIR$APPEND;				! Append text to current line

OWN
	PROT_TABLE	: VECTOR [16]		! Protection descr table
			  INITIAL (
				$DESCRIPTOR ('RWED'),
				$DESCRIPTOR ('WED'),
				$DESCRIPTOR ('RED'),
				$DESCRIPTOR ('ED'),
				$DESCRIPTOR ('RWD'),
				$DESCRIPTOR ('WD'),
				$DESCRIPTOR ('RD'),
				$DESCRIPTOR ('D'),
				$DESCRIPTOR ('RWE'),
				$DESCRIPTOR ('WE'),
				$DESCRIPTOR ('RE'),
				$DESCRIPTOR ('E'),
				$DESCRIPTOR ('RW'),
				$DESCRIPTOR ('W'),
				$DESCRIPTOR ('R'),
				$DESCRIPTOR ('')
				  );

EXTERNAL ROUTINE
	LIB$GET_VM		: ADDRESSING_MODE (GENERAL),
	LIB$QUAL_FILE_MATCH	: ADDRESSING_MODE (GENERAL);

EXTERNAL LITERAL
	LIB$_FILFAIMAT,

! DIRECTORY text messages

	DIR$_NEWDIRECT,
	DIR$_NOBRFILEID,
	DIR$_NOBRCREDAT,
	DIR$_NOBRREVDAT,
	DIR$_NOBREXPDAT,
	DIR$_NOBRBAKDAT,
	DIR$_FULLFILEID,
	DIR$_NOFUFILEID,
	DIR$_FULLSIZE,
	DIR$_FULLOWNERID,
	DIR$_FULLOWNERUIC,
	DIR$_NOFUCREDAT,
	DIR$_FULLCREDAT,
	DIR$_NOFUREVDAT,
	DIR$_FULLREVDAT,
	DIR$_NOFUEXPDAT,
	DIR$_FULLEXPDAT,
	DIR$_NOFUBAKDAT,
	DIR$_FULLBAKDAT,
	DIR$_FILEORG,
	DIR$_FILORGSEQ,
	DIR$_FILORGREL,
	DIR$_FILORGIDX,
	DIR$_IDXPROLOG,
	DIR$_IDXAREA,
	DIR$_FILORGUNK,
	DIR$_FILEATTR,
	DIR$_MAXBKTSIZ,
	DIR$_BUCKETSIZ,
	DIR$_GBLBUFCNT,
	DIR$_VERLIMIT,
	DIR$_NOVERLIMIT,
	DIR$_FILATRCTG,
	DIR$_FILATRCTB,
	DIR$_FILATRLCK,
	DIR$_FILATRNOBAK,
	DIR$_FILATRWRBAK,
	DIR$_FILATRRDCHK,
	DIR$_FILATRWRCHK,
	DIR$_FILATRBADACL,
	DIR$_FILATRDIR,
	DIR$_FILATRBADBLK,
	DIR$_FILATRNOCHRG,
	DIR$_FILATRERASE,
	DIR$_RECFORMAT,
	DIR$_RECFMTFIX,
	DIR$_RECFMTVAR,
	DIR$_RECFMTVFC,
	DIR$_RECFMTUDF,
	DIR$_RECFMTSTM,
	DIR$_RECFMTSTMLF,
	DIR$_RECFMTSTMCR,
	DIR$_RECFMTUNK,
	DIR$_MAXRECSIZ,
	DIR$_RECATTR,
	DIR$_NORECATTR,
	DIR$_CRCARCTL,
	DIR$_FTNCARCTL,
	DIR$_PRICARCTL,
	DIR$_NOCARCTL,
	DIR$_NOSPAN,
	DIR$_JNLENABLED,
	DIR$_NOJNLENB,
	DIR$_BIJNLNAME,
	DIR$_NOBIJNL,
	DIR$_AIJNLNAME,
	DIR$_NOAIJNL,
	DIR$_ATJNLNAME,
	DIR$_NOATJNL,
	DIR$_FILEPROT,
	DIR$_SYSPROT,
	DIR$_OWNPROT,
	DIR$_GRPPROT,
	DIR$_WORPROT,
	DIR$_FILEACL,
	DIR$_NOFILEACL,
	DIR$_TOTSIZALL,
	DIR$_TOTSIZ,
	DIR$_TOTNOSIZ,
	DIR$_GTOTSIZALL,
	DIR$_GTOTSIZALL1,
	DIR$_GTOTSIZ,
	DIR$_GTOTSIZ1,
	DIR$_GTOTNOSIZ,
	DIR$_GTOTNOSIZ1;

! Assumptions made about various RMS structure constants.

$ASSUME (FAB$C_SEQ EQL DIR_C_SEQUENTIAL*16);
$ASSUME (FAB$C_REL EQL DIR_C_RELATIVE*16);
$ASSUME (FAB$C_IDX EQL DIR_C_INDEXED*16);

$ASSUME (FAB$C_FIX EQL DIR_C_FIXED);
$ASSUME (FAB$C_VAR EQL DIR_C_VARIABLE);
$ASSUME (FAB$C_VFC EQL DIR_C_VFC);
$ASSUME (FAB$C_UDF EQL DIR_C_UNDEFINED);
$ASSUME (FAB$C_STM EQL DIR_C_STREAM);
$ASSUME (FAB$C_STMLF EQL DIR_C_STREAMLF);
$ASSUME (FAB$C_STMCR EQL DIR_C_STREAMCR);

GLOBAL ROUTINE DIR$GET_INFO (FILE_FAB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!	Get information about a file
!
! CALLING SEQUENCE:
!	DIR$GET_INFO (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: FAB address
!
! IMPLICIT INPUTS:
!	none
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	FILE_FAB	: REF $BBLOCK;		! FAB address

LOCAL
	FAB		: REF $BBLOCK,		! Address of the FAB
	NAM		: REF $BBLOCK,		! NAMe block address
	STATUS;					! Local routine return status

EXTERNAL ROUTINE
	DIR$FILE_ERROR;				! File error signaling routine

! Assume success.

STATUS = SS$_NORMAL;

! Set pointers to the necessary RMS data structures.

CH$MOVE (NAM$C_BLN, .FILE_FAB[FAB$L_NAM], INFO_NAM);	! Copy NAMe block
NAM = INFO_NAM;					! Set NAMe block address
FAB = .FILE_FAB;				! Assume from $SEARCHed FAB

! Check to see whether a legal file specification has been $SEARCHed.

IF NOT .(FAB[FAB$L_DEV])<$BITPOSITION (DEV$V_DIR), 1>
AND NOT .NAM[NAM$V_NODE]
THEN
    BEGIN
    FAB[FAB$L_STS] = SS$_NOTFILEDEV;
    FAB[FAB$L_STV] = 0;
    DIR$FILE_ERROR (DIR$_OPENIN, .FAB);
    RETURN 1;
    END;

IF .(FAB[FAB$L_DEV])<$BITPOSITION (DEV$V_FOR), 1>
THEN
    BEGIN
    FAB[FAB$L_STS] = SS$_DEVFOREIGN;
    FAB[FAB$L_STV] = 0;
    DIR$FILE_ERROR (DIR$_OPENIN, .FAB);
    RETURN 1;
    END;

! Fill some of the initial portions of the display block.

CH$FILL (0, DIR_C_LENGTH, .DISPLAY_BLOCK);
DISPLAY_BLOCK[DIR_W_FID_NUM] = .NAM[NAM$W_FID_NUM];
DISPLAY_BLOCK[DIR_W_FID_SEQ] = .NAM[NAM$W_FID_SEQ];
DISPLAY_BLOCK[DIR_W_FID_RVN] = .NAM[NAM$W_FID_RVN];
DISPLAY_BLOCK[DIR_B_FNS] = .NAM[NAM$B_RSL];
CH$MOVE (.NAM[NAM$B_RSL], .NAM[NAM$L_RSA], DISPLAY_BLOCK[DIR_T_FILENAME]);
CH$MOVE (NAM$C_DVI, NAM[NAM$T_DVI], DISPLAY_BLOCK[DIR_T_DVI]);
DISPLAY_BLOCK[DIR_B_NODE] = .NAM[NAM$B_NODE];
DISPLAY_BLOCK[DIR_B_DEV] = .NAM[NAM$B_DEV];
DISPLAY_BLOCK[DIR_B_DIR] = .NAM[NAM$B_DIR];
DISPLAY_BLOCK[DIR_B_VER] = .NAM[NAM$B_VER];
DISPLAY_BLOCK[DIR_V_SQD] = .(FAB[FAB$L_DEV])<$BITPOSITION (DEV$V_SQD), 1>;

! If it is not a network directory operation, it is necessary to change the
! FAB address for the following RMS/ACP operations.

IF NOT .NAM[NAM$V_NODE] THEN FAB = INFO_FAB;

! Get the requested information about the file and put it in the display
! block.

IF .QUAL_FLAGS[DIR_V_NEED_FHC] OR .QUAL_FLAGS[DIR_V_NEED_DAT]
OR .QUAL_FLAGS[DIR_V_NEED_PRO] OR .QUAL_FLAGS[DIR_V_NEED_SUM]
OR .QUAL_FLAGS[DIR_V_NEED_JNL] OR .QUAL_FLAGS[DIR_V_QUAL_ACL]
THEN
    BEGIN
    IF .NAM[NAM$V_NODE]
    THEN STATUS = DIR$RMS_FILL (.FAB, .NAM)
    ELSE STATUS = DIR$ACP_FILL (.FAB, .NAM);
    END;

DISPLAY_BLOCK[DIR_L_STATUS] = .STATUS;

! See if this file matches the criteria specified by the common command
! qualifiers.

FAB[FAB$W_IFI] = -1;				! Since XAB info is there
STATUS = LIB$QUAL_FILE_MATCH (CMN_QUAL_CTX, .FAB, 0, LINE_DESC);
FAB[FAB$W_IFI] = 0;				! Finished testing XAB info
IF .STATUS EQL LIB$_FILFAIMAT
THEN RETURN 1					! Return if not a candidate
ELSE IF .DISPLAY_BLOCK[DIR_L_STATUS]
     THEN DISPLAY_BLOCK[DIR_L_STATUS] = .STATUS;

! Now that all of the specified common qualifiers have been checked, check
! the file size if necessary.

IF .QUAL_FLAGS[DIR_V_SELE_SIZE]
AND .MIN_BLOCK GTR (IF .QUAL_FLAGS[DIR_V_SIZE_ALL] OR .QUAL_FLAGS[DIR_V_SIZE_ALLO]
		    THEN .DISPLAY_BLOCK[DIR_L_HIBLK]
		    ELSE .DISPLAY_BLOCK[DIR_L_EFBLK]) THEN RETURN 1;
IF .QUAL_FLAGS[DIR_V_SELE_SIZE]
AND .MAX_BLOCK LSS (IF .QUAL_FLAGS[DIR_V_SIZE_ALL] OR .QUAL_FLAGS[DIR_V_SIZE_ALLO]
		    THEN .DISPLAY_BLOCK[DIR_L_HIBLK]
		    ELSE .DISPLAY_BLOCK[DIR_L_EFBLK]) THEN RETURN 1;

! The file is indeed a candidate for being displayed.  Proceed to do it.

QUAL_FLAGS[DIR_V_FILE_FOUND] = 1;		! Note that something was found
IF .QUAL_FLAGS[DIR_V_QUAL_FULL]
THEN DIR$SHOW_FULL ()
ELSE DIR$SHOW_INFO ();

RETURN 1;

END;						! End of routine DIR$GET_INFO

ROUTINE DIR$RMS_FILL (FILE_FAB, FILE_NAM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine fills in the information requested from RMS.
!
! CALLING SEQUENCE:
!	DIR$RMS_FILL (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
!	ARG2: address of the NAMe block
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	The necessary information is collected and put into the display
!	information block.
!
!--

BEGIN

MAP
	FILE_FAB	: REF $BBLOCK,		! Address of the FAB
	FILE_NAM	: REF $BBLOCK;		! Address of the NAMe block

LOCAL
	STATUS;					! Routine exit status

! Set up for the RMS OPEN.

IF NOT .FILE_NAM[NAM$V_WILDCARD]
THEN STATUS = $SEARCH (FAB = .FILE_FAB)
ELSE STATUS = .FILE_FAB[FAB$L_STS];

! If the STS is success and the STV is in error, set the return status to the
! STV value.  This only happens on network directory operations, and is the
! method by which RMS/FAL returns back any errors that occurred while
! attempting to obtain the file attributes.

IF .FILE_FAB[FAB$L_STS] AND .FILE_FAB[FAB$L_STV] NEQ 0
THEN IF NOT .FILE_FAB[FAB$L_STV]
THEN STATUS = .FILE_FAB[FAB$L_STV];

IF .STATUS EQL RMS$_NOJ THEN STATUS = RMS$_NORMAL;

! Now fill the display block with the information gathered by RMS.

DISPLAY_BLOCK[DIR_V_CONTIG] = .FILE_FAB[FAB$V_CTG];
DISPLAY_BLOCK[DIR_V_CONTIGB] = .FILE_FAB[FAB$V_CBT];
DISPLAY_BLOCK[DIR_V_SQD] = .(FILE_FAB[FAB$L_DEV])<$BITPOSITION (DEV$V_SQD), 1>;
DISPLAY_BLOCK[DIR_L_HIBLK] = .FILE_FAB[FAB$L_ALQ];
DISPLAY_BLOCK[DIR_W_DEFEXT] = .FILE_FAB[FAB$W_DEQ];
DISPLAY_BLOCK[DIR_V_RTYPE] = .FILE_FAB[FAB$B_RFM];
DISPLAY_BLOCK[DIR_V_FILEORG] = .FILE_FAB[FAB$B_ORG] / 16;
IF (DISPLAY_BLOCK[DIR_B_VFCSIZE] = .FILE_FAB[FAB$B_FSZ]) EQL 0
THEN DISPLAY_BLOCK[DIR_B_VFCSIZE] = 2;
DISPLAY_BLOCK[DIR_B_RATTRIB] = .FILE_FAB[FAB$B_RAT];
DISPLAY_BLOCK[DIR_B_BKTSIZE] = .FILE_FAB[FAB$B_BKS];
DISPLAY_BLOCK[DIR_W_RSIZE] = .FILE_FAB[FAB$W_MRS];
DISPLAY_BLOCK[DIR_W_GBC] = .FILE_FAB[FAB$W_GBC];

DISPLAY_BLOCK[DIR_W_VERLIMIT] = .INFO_XABFHC[XAB$W_VERLIMIT];
IF (DISPLAY_BLOCK[DIR_L_EFBLK] = .INFO_XABFHC[XAB$L_EBK]) EQL 0
THEN DISPLAY_BLOCK[DIR_L_EFBLK] = .FILE_FAB[FAB$L_ALQ]
ELSE IF .INFO_XABFHC[XAB$W_FFB] EQL 0
THEN DISPLAY_BLOCK[DIR_L_EFBLK] = .DISPLAY_BLOCK[DIR_L_EFBLK] - 1;

DISPLAY_BLOCK[DIR_L_CDT0] = .INFO_XABDAT[XAB$L_CDT0];
DISPLAY_BLOCK[DIR_L_CDT4] = .INFO_XABDAT[XAB$L_CDT4];
DISPLAY_BLOCK[DIR_L_RDT0] = .INFO_XABDAT[XAB$L_RDT0];
DISPLAY_BLOCK[DIR_L_RDT4] = .INFO_XABDAT[XAB$L_RDT4];
DISPLAY_BLOCK[DIR_L_EDT0] = .INFO_XABDAT[XAB$L_EDT0];
DISPLAY_BLOCK[DIR_L_EDT4] = .INFO_XABDAT[XAB$L_EDT4];
DISPLAY_BLOCK[DIR_L_BDT0] = .INFO_XABDAT[XAB$L_BDT0];
DISPLAY_BLOCK[DIR_L_BDT4] = .INFO_XABDAT[XAB$L_BDT4];
DISPLAY_BLOCK[DIR_W_REVISION] = .INFO_XABDAT[XAB$W_RVN];

DISPLAY_BLOCK[DIR_L_FILEOWNER] = .INFO_XABPRO[XAB$L_UIC];
DISPLAY_BLOCK[DIR_W_FILEPROT] = .INFO_XABPRO[XAB$W_PRO];

DISPLAY_BLOCK[DIR_L_MRN] = .FILE_FAB[FAB$L_MRN];
DISPLAY_BLOCK[DIR_B_NOKEYS] = .INFO_XABSUM[XAB$B_NOK];
DISPLAY_BLOCK[DIR_W_PVN] = .INFO_XABSUM[XAB$W_PVN];
DISPLAY_BLOCK[DIR_B_NOAREAS] = .INFO_XABSUM[XAB$B_NOA];

RETURN .STATUS;

END;						! End of routine DIR$RMS_FILL

ROUTINE DIR$ACP_FILL (FILE_FAB, FILE_NAM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine gathers the requested information about the file from
!	the ACP.
!
! CALLING SEQUENCE:
!	DIR$ACP_FILL (ARG1, ARG2))
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
! 	ARG2: address of the NAMe block
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	The information display block if filled in with the necessary
!	information requested.
!
!--

BEGIN

MAP
	FILE_FAB	: REF $BBLOCK,		! Address of the FAB
	FILE_NAM	: REF $BBLOCK;		! Address of the NAMe block

LITERAL
	NUM_ATTR	= 20;			! Max number of ACP attributes

LOCAL
	DEVICE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Device name descriptor
	FILE_DESC	: $BBLOCK [DSC$C_S_BLN],	! File name descriptor
	FIB_DESC	: $BBLOCK [DSC$C_S_BLN],	! FIB descriptor
	FIB		: $BBLOCK [FIB$C_LENGTH],	! FIB Storage
	ATTRIBUTES	: BLOCKVECTOR [NUM_ATTR, 8, BYTE],	! Attribute descrs
	ACP_STATISTICS	: $BBLOCK [ATR$S_STATBLK],	! ACP statistics block
	AI_JNLACE	: $BBLOCK [ATR$S_FNDACETYP],	! AI journal ACE
	BI_JNLACE	: $BBLOCK [ATR$S_FNDACETYP],	! BI journal ACE
	AT_JNLACE	: $BBLOCK [ATR$S_FNDACETYP],	! AT journal ACE
	IOSTS		: VECTOR [4, WORD],	! I/O status block
	STATUS;					! Local routine exit status

! If necessary, first assign a channel to the device.

IF CH$NEQ (NAM$C_DVI, FILE_NAM[NAM$T_DVI], NAM$C_DVI, DEVICE_NAME, 0)
OR .CHANNEL EQL 0
THEN
    BEGIN
    IF .CHANNEL NEQ 0 THEN $DASSGN (CHAN = .CHANNEL);
    CH$MOVE (NAM$C_DVI, FILE_NAM[NAM$T_DVI], DEVICE_NAME);
    CH$FILL (0, DSC$C_S_BLN, DEVICE_DESC);
    DEVICE_DESC[DSC$W_LENGTH] = .DEVICE_NAME[0];
    DEVICE_DESC[DSC$A_POINTER] = DEVICE_NAME[1];
    STATUS = $ASSIGN (DEVNAM = DEVICE_DESC,
		      CHAN = CHANNEL);
    IF NOT .STATUS
    THEN
	BEGIN
	CH$FILL (0, NAM$C_DVI, DEVICE_NAME);
	CHANNEL = 0;
	RETURN .STATUS;
	END;
    END;

! Build the ACP attribute list for the needed information.

CH$FILL (0, NUM_ATTR*8, ATTRIBUTES);
ATTRIBUTES [0, ATR$W_TYPE] = ATR$C_RECATTR;
ATTRIBUTES [0, ATR$W_SIZE] = ATR$S_RECATTR;
ATTRIBUTES [0, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_R_RECATTR];
ATTRIBUTES [1, ATR$W_TYPE] = ATR$C_CREDATE;
ATTRIBUTES [1, ATR$W_SIZE] = ATR$S_CREDATE;
ATTRIBUTES [1, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_Q_CREDATE];
ATTRIBUTES [2, ATR$W_TYPE] = ATR$C_REVDATE;
ATTRIBUTES [2, ATR$W_SIZE] = ATR$S_REVDATE;
ATTRIBUTES [2, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_Q_REVDATE];
ATTRIBUTES [3, ATR$W_TYPE] = ATR$C_EXPDATE;
ATTRIBUTES [3, ATR$W_SIZE] = ATR$S_EXPDATE;
ATTRIBUTES [3, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_Q_EXPDATE];
ATTRIBUTES [4, ATR$W_TYPE] = ATR$C_BAKDATE;
ATTRIBUTES [4, ATR$W_SIZE] = ATR$S_BAKDATE;
ATTRIBUTES [4, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_Q_BAKDATE];
ATTRIBUTES [5, ATR$W_TYPE] = ATR$C_STATBLK;
ATTRIBUTES [5, ATR$W_SIZE] = ATR$S_STATBLK;
ATTRIBUTES [5, ATR$L_ADDR] = ACP_STATISTICS;
ATTRIBUTES [6, ATR$W_TYPE] = ATR$C_UIC;
ATTRIBUTES [6, ATR$W_SIZE] = ATR$S_UIC;
ATTRIBUTES [6, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_L_FILEOWNER];
ATTRIBUTES [7, ATR$W_TYPE] = ATR$C_FPRO;
ATTRIBUTES [7, ATR$W_SIZE] = ATR$S_FPRO;
ATTRIBUTES [7, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_W_FILEPROT];
ATTRIBUTES [8, ATR$W_TYPE] = ATR$C_UCHAR;
ATTRIBUTES [8, ATR$W_SIZE] = ATR$S_UCHAR;
ATTRIBUTES [8, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_L_FILECHAR];
ATTRIBUTES [9, ATR$W_TYPE] = ATR$C_ASCDATES;
ATTRIBUTES [9, ATR$W_SIZE] = 2;
ATTRIBUTES [9, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_W_REVISION];
ATTRIBUTES [10, ATR$W_TYPE] = ATR$C_JOURNAL;
ATTRIBUTES [10, ATR$W_SIZE] = ATR$S_JOURNAL;
ATTRIBUTES [10, ATR$L_ADDR] = DISPLAY_BLOCK[DIR_W_JOURNAL];
ATTRIBUTES [11, ATR$W_TYPE] = ATR$C_FNDACETYP;
ATTRIBUTES [11, ATR$W_SIZE] = ATR$S_FNDACETYP;
ATTRIBUTES [11, ATR$L_ADDR] = AI_JNLACE;
ATTRIBUTES [12, ATR$W_TYPE] = ATR$C_FNDACETYP;
ATTRIBUTES [12, ATR$W_SIZE] = ATR$S_FNDACETYP;
ATTRIBUTES [12, ATR$L_ADDR] = BI_JNLACE;
ATTRIBUTES [13, ATR$W_TYPE] = ATR$C_FNDACETYP;
ATTRIBUTES [13, ATR$W_SIZE] = ATR$S_FNDACETYP;
ATTRIBUTES [13, ATR$L_ADDR] = AT_JNLACE;
ATTRIBUTES [14, ATR$W_TYPE] = ATR$C_ACLLENGTH;
ATTRIBUTES [14, ATR$W_SIZE] = ATR$S_ACLLENGTH;
ATTRIBUTES [14, ATR$L_ADDR] = ACL_LENGTH;

! Set up for the ACE locate operation necessary to get the RMS journal
! information.

AI_JNLACE[ACE$B_SIZE] = 0;
AI_JNLACE[ACE$B_TYPE] = ACE$C_AIJNL;
BI_JNLACE[ACE$B_SIZE] = 0;
BI_JNLACE[ACE$B_TYPE] = ACE$C_BIJNL;
AT_JNLACE[ACE$B_SIZE] = 0;
AT_JNLACE[ACE$B_TYPE] = ACE$C_ATJNL;

! Issue the ACP QIO to get the needed information.

CH$FILL (0, FIB$C_LENGTH, FIB);
CH$FILL (0, DSC$C_S_BLN, FIB_DESC);
FIB_DESC[DSC$W_LENGTH] = FIB$C_LENGTH;
FIB_DESC[DSC$A_POINTER] = FIB;

IF .QUAL_FLAGS[DIR_V_QUAL_FULL]
AND NOT .DISPLAY_BLOCK[DIR_V_SQD]
THEN
    BEGIN
    FIB[FIB$W_DID_NUM] = .FILE_NAM[NAM$W_DID_NUM];
    FIB[FIB$W_DID_SEQ] = .FILE_NAM[NAM$W_DID_SEQ];
    FIB[FIB$W_DID_RVN] = .FILE_NAM[NAM$W_DID_RVN];
    CH$FILL (0, DSC$C_S_BLN, FILE_DESC);
    FILE_DESC[DSC$W_LENGTH] = .FILE_NAM[NAM$B_NAME] +
			      .FILE_NAM[NAM$B_TYPE] +
			      .FILE_NAM[NAM$B_VER];
    FILE_DESC[DSC$A_POINTER] = .FILE_NAM[NAM$L_NAME];
    END
ELSE
    BEGIN
    FIB[FIB$W_FID_NUM] = .FILE_NAM[NAM$W_FID_NUM];
    FIB[FIB$W_FID_SEQ] = .FILE_NAM[NAM$W_FID_SEQ];
    FIB[FIB$W_FID_RVN] = .FILE_NAM[NAM$W_FID_RVN];
    END;

STATUS = $QIOW (FUNC = IO$_ACCESS,
		CHAN = .CHANNEL,
		IOSB = IOSTS,
		P1 = FIB_DESC,
		P2 = (IF .QUAL_FLAGS[DIR_V_QUAL_FULL]
		      AND NOT .DISPLAY_BLOCK[DIR_V_SQD]
		      THEN FILE_DESC ELSE 0),
		P5 = ATTRIBUTES);
IF .STATUS THEN STATUS = .IOSTS[0];
IF NOT .STATUS
THEN
    BEGIN
    $DASSGN (CHAN = .CHANNEL);
    CHANNEL = 0;
    RETURN .STATUS;
    END;

! Fix up some of the information returned.

IF .DISPLAY_BLOCK[DIR_V_SQD]
THEN
    BEGIN
    DISPLAY_BLOCK[DIR_L_HIBLK] = ROT (.ACP_STATISTICS[SBK$L_FILESIZE], 16);
    DISPLAY_BLOCK[DIR_L_EFBLK] = .DISPLAY_BLOCK[DIR_L_HIBLK];
    END
ELSE
    BEGIN
    DISPLAY_BLOCK[DIR_L_HIBLK] = ROT (.DISPLAY_BLOCK[DIR_L_HIBLK], 16);
    IF (DISPLAY_BLOCK[DIR_L_EFBLK] = ROT (.DISPLAY_BLOCK[DIR_L_EFBLK], 16)) EQL 0
    THEN DISPLAY_BLOCK[DIR_L_EFBLK] = .DISPLAY_BLOCK[DIR_L_HIBLK]
    ELSE IF .DISPLAY_BLOCK[DIR_W_FFBYTE] EQL 0
	 THEN DISPLAY_BLOCK[DIR_L_EFBLK] = .DISPLAY_BLOCK[DIR_L_EFBLK] - 1;
    END;

IF .DISPLAY_BLOCK[DIR_W_RSIZE] EQL 0
THEN DISPLAY_BLOCK[DIR_W_RSIZE] = .DISPLAY_BLOCK[DIR_W_MAXREC];
DISPLAY_BLOCK[DIR_W_VERLIMIT] = .FIB[FIB$W_VERLIMIT];

! Check for any RMS journaling information in the file's ACL.

IF .AI_JNLACE[ACE$B_SIZE] NEQ 0
THEN
    BEGIN
    DISPLAY_BLOCK[DIR_B_AI_SIZE] = .AI_JNLACE[ACE$B_SIZE] -
				   $BYTEOFFSET (ACE$T_RMSJNLNAM);
    CH$MOVE (.DISPLAY_BLOCK[DIR_B_AI_SIZE], AI_JNLACE[ACE$T_RMSJNLNAM],
					    DISPLAY_BLOCK[DIR_T_AI_NAME]);
    END;
IF .BI_JNLACE[ACE$B_SIZE] NEQ 0
THEN
    BEGIN
    DISPLAY_BLOCK[DIR_B_BI_SIZE] = .BI_JNLACE[ACE$B_SIZE] -
				   $BYTEOFFSET (ACE$T_RMSJNLNAM);
    CH$MOVE (.DISPLAY_BLOCK[DIR_B_BI_SIZE], BI_JNLACE[ACE$T_RMSJNLNAM],
					    DISPLAY_BLOCK[DIR_T_BI_NAME]);
    END;
IF .AT_JNLACE[ACE$B_SIZE] NEQ 0
THEN
    BEGIN
    DISPLAY_BLOCK[DIR_B_AT_SIZE] = .AT_JNLACE[ACE$B_SIZE] -
				   $BYTEOFFSET (ACE$T_RMSJNLNAM);
    CH$MOVE (.DISPLAY_BLOCK[DIR_B_AT_SIZE], AT_JNLACE[ACE$T_RMSJNLNAM],
					    DISPLAY_BLOCK[DIR_T_AT_NAME]);
    END;

! Now copy the information obtained into the appropriate RMS data structures.
! This is necessary because the common qualifier package expects RMS data
! structures.  This is only done if one of the common qualifiers is given
! on the command line.

IF .QUAL_FLAGS[DIR_V_COMM_QUAL]
THEN
    BEGIN

! Fill in the FAB first.

    IF .DISPLAY_BLOCK[DIR_V_CONTIG] THEN FILE_FAB[FAB$V_CTG] = 1;
    IF .DISPLAY_BLOCK[DIR_V_CONTIGB] THEN FILE_FAB[FAB$V_CBT] = 1;
    IF .DISPLAY_BLOCK[DIR_V_READCHECK] THEN FILE_FAB[FAB$V_RCK] = 1;
    IF .DISPLAY_BLOCK[DIR_V_MARKDEL] THEN FILE_FAB[FAB$V_TMP] = 1;
    IF .DISPLAY_BLOCK[DIR_V_WRITCHECK] THEN FILE_FAB[FAB$V_WCK] = 1;

    FILE_FAB[FAB$L_ALQ] = .DISPLAY_BLOCK[DIR_L_HIBLK];
    FILE_FAB[FAB$B_BKS] = .DISPLAY_BLOCK[DIR_B_BKTSIZE];
    FILE_FAB[FAB$W_DEQ] = .DISPLAY_BLOCK[DIR_W_DEFEXT];
    FILE_FAB[FAB$B_FSZ] = .DISPLAY_BLOCK[DIR_B_VFCSIZE];
    FILE_FAB[FAB$W_GBC] = .DISPLAY_BLOCK[DIR_W_GBC];
    IF (FILE_FAB[FAB$W_MRS] = .DISPLAY_BLOCK[DIR_W_RSIZE]) EQL 0
    THEN FILE_FAB[FAB$W_MRS] = .DISPLAY_BLOCK[DIR_W_MAXREC];
    FILE_FAB[FAB$B_ORG] = .DISPLAY_BLOCK[DIR_V_FILEORG];
    FILE_FAB[FAB$B_RAT] = .DISPLAY_BLOCK[DIR_B_RATTRIB];
    FILE_FAB[FAB$B_RFM] = .DISPLAY_BLOCK[DIR_V_RTYPE];
    FILE_FAB[FAB$L_XAB] = .FIRST_XAB;

! Now fill in the DATe XAB.

    CH$MOVE (8, DISPLAY_BLOCK[DIR_Q_BAKDATE], INFO_XABDAT[XAB$Q_BDT]);
    CH$MOVE (8, DISPLAY_BLOCK[DIR_Q_CREDATE], INFO_XABDAT[XAB$Q_CDT]);
    CH$MOVE (8, DISPLAY_BLOCK[DIR_Q_EXPDATE], INFO_XABDAT[XAB$Q_EDT]);
    CH$MOVE (8, DISPLAY_BLOCK[DIR_Q_REVDATE], INFO_XABDAT[XAB$Q_RDT]);
    INFO_XABDAT[XAB$W_RVN] = .DISPLAY_BLOCK[DIR_W_REVISION];

! Now for the File Header Characteristics XAB.

    INFO_XABFHC[XAB$B_ATR] = .FILE_FAB[FAB$B_RAT];
    INFO_XABFHC[XAB$B_BKZ] = .FILE_FAB[FAB$B_BKS];
    INFO_XABFHC[XAB$W_DXQ] = .FILE_FAB[FAB$W_DEQ];
    INFO_XABFHC[XAB$L_EBK] = .DISPLAY_BLOCK[DIR_L_EFBLK];
    INFO_XABFHC[XAB$W_FFB] = .DISPLAY_BLOCK[DIR_W_FFBYTE];
    INFO_XABFHC[XAB$W_GBC] = .FILE_FAB[FAB$W_GBC];
    INFO_XABFHC[XAB$L_HBK] = .DISPLAY_BLOCK[DIR_L_HIBLK];
    INFO_XABFHC[XAB$B_HSZ] = .FILE_FAB[FAB$B_FSZ];
    INFO_XABFHC[XAB$W_MRZ] = .FILE_FAB[FAB$W_MRS];
    INFO_XABFHC[XAB$B_RFO] = .FILE_FAB[FAB$B_ORG];
    INFO_XABFHC[XAB$L_SBN] = .ACP_STATISTICS[SBK$L_STLBN];
    INFO_XABFHC[XAB$W_VERLIMIT] = .DISPLAY_BLOCK[DIR_W_VERLIMIT];

! Now for the RMS journaling XAB.

    IF (INFO_XABJNL[XAB$B_AIL] = .DISPLAY_BLOCK[DIR_B_AI_SIZE]) GTR 0
    THEN INFO_XABJNL[XAB$L_AIA] = DISPLAY_BLOCK[DIR_T_AI_NAME];
    IF (INFO_XABJNL[XAB$B_BIL] = .DISPLAY_BLOCK[DIR_B_BI_SIZE]) GTR 0
    THEN INFO_XABJNL[XAB$L_BIA] = DISPLAY_BLOCK[DIR_T_BI_NAME];
    IF (INFO_XABJNL[XAB$B_ATL] = .DISPLAY_BLOCK[DIR_B_AT_SIZE]) GTR 0
    THEN INFO_XABJNL[XAB$L_ATA] = DISPLAY_BLOCK[DIR_T_AT_NAME];

! And now...The PROtection XAB.

    INFO_XABPRO[XAB$W_PRO] = .DISPLAY_BLOCK[DIR_W_FILEPROT];
    INFO_XABPRO[XAB$L_UIC] = .DISPLAY_BLOCK[DIR_L_FILEOWNER];
    END;

! Finally, if this is a relative or indexed file, obtain the information from
! the file's prolog.

IF (.DISPLAY_BLOCK[DIR_V_FILEORG] EQL DIR_C_RELATIVE
    OR .DISPLAY_BLOCK[DIR_V_FILEORG] EQL DIR_C_INDEXED)
AND .QUAL_FLAGS[DIR_V_QUAL_FULL]
THEN
    BEGIN
    LOCAL	OLD_FAB_LNK,
		OLD_XAB_LNK;
    OLD_FAB_LNK = .FILE_FAB[FAB$L_XAB];
    OLD_XAB_LNK = .INFO_XABSUM[XAB$L_NXT];
    FILE_FAB[FAB$W_DEQ] = 0;			! Zero because RMS takes non-zero as input
    FILE_FAB[FAB$L_XAB] = INFO_XABSUM;
    INFO_XABSUM[XAB$L_NXT] = 0;
    IF $OPEN (FAB = .FILE_FAB)
    THEN
	BEGIN
	DISPLAY_BLOCK[DIR_L_MRN] = .FILE_FAB[FAB$L_MRN];
	DISPLAY_BLOCK[DIR_B_NOKEYS] = .INFO_XABSUM[XAB$B_NOK];
	DISPLAY_BLOCK[DIR_W_PVN] = .INFO_XABSUM[XAB$W_PVN];
	DISPLAY_BLOCK[DIR_B_NOAREAS] = .INFO_XABSUM[XAB$B_NOA];
	$CLOSE (FAB = .FILE_FAB);
	END;
    FILE_FAB[FAB$L_XAB] = .OLD_FAB_LNK;
    INFO_XABSUM[XAB$L_NXT] = .OLD_XAB_LNK;
    END;

RETURN .STATUS;

END;						! End of routine DIR$ACP_FILL

ROUTINE DIR$SHOW_INFO =

!++
!
! FUNCTIONAL DESCRIPTION:
!	Display gathered information
!
! CALLING SEQUENCE:
!	DIR$SHOW_INFO ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	HEADER_LEN,				! Length of file prefix
	FILENAME_LEN,				! Length of the file name
	NAME_LEN,				! File name length minus version
	SPACE_COUNT,				! Number of spaces to pad
	LOCAL_DESC	: $BBLOCK [DSC$C_S_BLN],	! Local text descriptor
	MARK_POSITION,				! Saved line position
	COLUMN_BEGIN;				! Beginning position of column

EXTERNAL ROUTINE
	DIR$OUTPUT;				! General output routine

! See if it is necessary and time to do the header & trailer information.

HEADER_LEN = .DISPLAY_BLOCK[DIR_B_NODE] +
	     .DISPLAY_BLOCK[DIR_B_DEV] +
	     .DISPLAY_BLOCK[DIR_B_DIR];
FILENAME_LEN = .DISPLAY_BLOCK[DIR_B_FNS] - .HEADER_LEN;
NAME_LEN = .DISPLAY_BLOCK[DIR_B_FNS] - .DISPLAY_BLOCK[DIR_B_VER];

IF CH$NEQ (.PREV_DIR_LEN, PREV_DIR, .HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME])
THEN
    BEGIN
    IF .LINE_DESC[DSC$W_LENGTH] GTR 0
    THEN
	BEGIN
	DIR$OUTPUT (0, LINE_DESC);
	COLUMN_INDEX = 0
	END;
    IF .PREV_DIR_LEN NEQ 0 THEN DIR$TOTAL ();
    PREV_DIR_LEN = .HEADER_LEN;
    CH$MOVE (.HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME], PREV_DIR);
    IF .QUAL_FLAGS[DIR_V_QUAL_HEAD]
    AND NOT .QUAL_FLAGS[DIR_V_QUAL_GRAN]
    THEN
	BEGIN
	WRITE (0, '');
	WRITE (DIR$_NEWDIRECT, 0, .PREV_DIR_LEN, PREV_DIR);
	IF NOT .QUAL_FLAGS[DIR_V_QUAL_TOTL] THEN WRITE (0, '');
	END;
    END;

! Check for another version of the same file.

IF .VERSION_COUNT GTR 0
THEN
    BEGIN
    IF CH$EQL (.PREV_FILE_LEN, PREV_FILE,
	       .NAME_LEN, DISPLAY_BLOCK[DIR_T_FILENAME], 0)
    THEN VERSION_INDEX = .VERSION_INDEX + 1
    ELSE
	BEGIN
	PREV_FILE_LEN = .NAME_LEN;
	CH$MOVE (.NAME_LEN, DISPLAY_BLOCK[DIR_T_FILENAME], PREV_FILE);
	VERSION_INDEX = 0;
	END;
    IF .VERSION_INDEX GEQ .VERSION_COUNT THEN RETURN 1;
    END;

! Update the running totals.

TOTAL_USED = .TOTAL_USED + .DISPLAY_BLOCK[DIR_L_EFBLK];
TOTAL_ALLOC = .TOTAL_ALLOC + .DISPLAY_BLOCK[DIR_L_HIBLK];
TOTAL_FILES = .TOTAL_FILES + 1;

IF .QUAL_FLAGS[DIR_V_QUAL_TOTL] OR .QUAL_FLAGS[DIR_V_QUAL_GRAN] THEN RETURN 1;

! Build the line using the requested informatation.

IF .COLUMN_INDEX GEQ .COLUMN_COUNT
THEN
    BEGIN
    IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN DIR$OUTPUT (0, LINE_DESC);
    COLUMN_INDEX = 0;
    END;
COLUMN_BEGIN = MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];

IF NOT .QUAL_FLAGS[DIR_V_QUAL_HEAD]
THEN APPEND (0, '!AD',  .HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME]);
APPEND (0, '!AD', .FILENAME_LEN, VECTOR [DISPLAY_BLOCK[DIR_T_FILENAME],
					.HEADER_LEN; ,BYTE]);
IF .LINE_DESC[DSC$W_LENGTH] GEQ .DISPLAY_WIDTH
THEN
    BEGIN
    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
    DIR$OUTPUT (0, LINE_DESC);
    COLUMN_BEGIN = MARK_POSITION = 0;
    COLUMN_INDEX = 0;
    IF NOT .QUAL_FLAGS[DIR_V_QUAL_HEAD]
    THEN APPEND (0, '!AD',  .HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME]);
    APPEND (0, '!AD', .FILENAME_LEN, VECTOR [DISPLAY_BLOCK[DIR_T_FILENAME],
					    .HEADER_LEN; ,BYTE]);
    END;

SPACE_COUNT = .FILENAME_WIDTH - .LINE_DESC[DSC$W_LENGTH] +
				.MARK_POSITION;
IF .SPACE_COUNT LEQ 0
THEN
    BEGIN
    IF .COLUMN_COUNT EQL 1
    THEN
	BEGIN
	DIR$OUTPUT (0, LINE_DESC);
	COLUMN_BEGIN = 0;
	IF .QUAL_FLAGS[DIR_V_QUAL_FID] OR .QUAL_FLAGS[DIR_V_QUAL_SIZE]
	OR .QUAL_FLAGS[DIR_V_QUAL_DATE] OR .QUAL_FLAGS[DIR_V_QUAL_OWNE]
	OR .QUAL_FLAGS[DIR_V_QUAL_PROT]
	THEN APPEND (0, '!#* ', .FILENAME_WIDTH);
	END
    ELSE
	BEGIN
	IF .QUAL_FLAGS[DIR_V_QUAL_BRIE]
	AND NOT .QUAL_FLAGS[DIR_V_QUAL_SIZE]
	AND NOT .QUAL_FLAGS[DIR_V_QUAL_DATE]
	AND NOT .QUAL_FLAGS[DIR_V_QUAL_OWNE]
	AND NOT .QUAL_FLAGS[DIR_V_QUAL_PROT]
	AND NOT .QUAL_FLAGS[DIR_V_QUAL_FID]
	THEN
	    BEGIN
	    COLUMN_INDEX = .COLUMN_INDEX +
			   ((.LINE_DESC[DSC$W_LENGTH] - .COLUMN_BEGIN) /
			   .COLUMN_WIDTH);
	    COLUMN_BEGIN = .COLUMN_BEGIN +
			   ((.LINE_DESC[DSC$W_LENGTH] - .COLUMN_BEGIN) /
			   .COLUMN_WIDTH) * .COLUMN_WIDTH;
	    END
	ELSE
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION + .FILENAME_WIDTH;
	    LINE_BUFFER[.LINE_DESC[DSC$W_LENGTH] - 1] = '|'
	    END;
	END;
    END
ELSE APPEND (0, '!#* ', .SPACE_COUNT);

! Check to see if an error occurred opening the file.

IF NOT .DISPLAY_BLOCK[DIR_L_STATUS]
THEN
    BEGIN
    CH$FILL (0, DSC$C_S_BLN, LOCAL_DESC);
    LOCAL_DESC[DSC$W_LENGTH] = 1024 - .LINE_DESC[DSC$W_LENGTH];
    LOCAL_DESC[DSC$A_POINTER] = LINE_BUFFER[.LINE_DESC[DSC$W_LENGTH]];
    $GETMSG (MSGID = .DISPLAY_BLOCK[DIR_L_STATUS],
	     MSGLEN = LOCAL_DESC,
	     BUFADR = LOCAL_DESC,
	     FLAGS = 1);
    LINE_DESC[DSC$W_LENGTH] = .LINE_DESC[DSC$W_LENGTH] + .LOCAL_DESC[DSC$W_LENGTH];
    IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
    THEN
	BEGIN
	LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN DIR$OUTPUT (0, LINE_DESC);
	LINE_DESC[DSC$W_LENGTH] = .LOCAL_DESC[DSC$A_POINTER] +
				  .LOCAL_DESC[DSC$W_LENGTH] -
				  LINE_BUFFER[.MARK_POSITION];
	CH$MOVE (.LINE_DESC[DSC$W_LENGTH], LINE_BUFFER[.MARK_POSITION],
					   LINE_BUFFER);
	END;
    DIR$OUTPUT (0, LINE_DESC);
    COLUMN_INDEX = 0;
    RETURN 1;
    END;

! No errors were encountered.  Fill the line with the requested information.

IF .QUAL_FLAGS[DIR_V_QUAL_FID]
THEN
    BEGIN
    IF .DISPLAY_BLOCK[DIR_W_FID_NUM] NEQ 0
    OR .DISPLAY_BLOCK[DIR_W_FID_SEQ] NEQ 0
    OR .DISPLAY_BLOCK[DIR_W_FID_RVN] NEQ 0
    THEN APPEND (0, '  !19<(!UW,!UW,!UW)!>', .DISPLAY_BLOCK[DIR_W_FID_NUM],
					     .DISPLAY_BLOCK[DIR_W_FID_SEQ],
					     .DISPLAY_BLOCK[DIR_W_FID_RVN])
    ELSE APPEND (DIR$_NOBRFILEID);
    END;

IF .QUAL_FLAGS[DIR_V_QUAL_SIZE]
THEN
    BEGIN
    IF .QUAL_FLAGS[DIR_V_SIZE_ALL]
    THEN APPEND (0, '  !#UL/!#<!UL!>', .SIZE_WIDTH,
				       .DISPLAY_BLOCK[DIR_L_EFBLK],
				       .SIZE_WIDTH,
				       .DISPLAY_BLOCK[DIR_L_HIBLK])
    ELSE APPEND (0, '  !#UL', .SIZE_WIDTH,
			      (IF .QUAL_FLAGS[DIR_V_SIZE_USED]
			      THEN .DISPLAY_BLOCK[DIR_L_EFBLK]
			      ELSE .DISPLAY_BLOCK[DIR_L_HIBLK]));
    END;

IF .QUAL_FLAGS[DIR_V_QUAL_DATE]
THEN
    BEGIN
    IF .QUAL_FLAGS[DIR_V_DATE_CRE]
    THEN IF .DISPLAY_BLOCK[DIR_L_CDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_CDT4] EQL 0
	 THEN APPEND (DIR$_NOBRCREDAT)
	 ELSE APPEND (0, '  !17%D', DISPLAY_BLOCK[DIR_L_CDT0]);
    IF .QUAL_FLAGS[DIR_V_DATE_MOD]
    THEN IF .DISPLAY_BLOCK[DIR_L_RDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_RDT4] EQL 0
	 THEN APPEND (DIR$_NOBRREVDAT)
	 ELSE APPEND (0, '  !17%D', DISPLAY_BLOCK[DIR_L_RDT0]);
    IF .QUAL_FLAGS[DIR_V_DATE_EXP]
    THEN IF .DISPLAY_BLOCK[DIR_L_EDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_EDT4] EQL 0
	 THEN APPEND (DIR$_NOBREXPDAT)
	 ELSE APPEND (0, '  !17%D', DISPLAY_BLOCK[DIR_L_EDT0]);
    IF .QUAL_FLAGS[DIR_V_DATE_BAK]
    THEN IF .DISPLAY_BLOCK[DIR_L_BDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_BDT4] EQL 0
	 THEN APPEND (DIR$_NOBRBAKDAT)
	 ELSE APPEND (0, '  !17%D', DISPLAY_BLOCK[DIR_L_BDT0]);
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];

IF .QUAL_FLAGS[DIR_V_QUAL_OWNE]
THEN IF .DISPLAY_BLOCK[DIR_B_NODE] EQL 0
     THEN APPEND (0, '  !#<!%I!>', .OWNER_WIDTH, .DISPLAY_BLOCK[DIR_L_FILEOWNER])
     ELSE APPEND (0, '  !#%U', .OWNER_WIDTH, .DISPLAY_BLOCK[DIR_L_FILEOWNER]);

IF .QUAL_FLAGS[DIR_V_QUAL_PROT]
THEN
    BEGIN
    APPEND (0, '  (');
    INCR J FROM 0 TO 3
    DO
	BEGIN
	DIR$APPEND (0, .PROT_TABLE[.(DISPLAY_BLOCK[DIR_W_FILEPROT])<.J*4,4>]);
	IF .J LSS 3 THEN APPEND (0, ',');
	END;
    APPEND (0, ')');
    END;

IF .QUAL_FLAGS[DIR_V_QUAL_ACL] AND .ACL_LENGTH GTR 0
THEN
    BEGIN
    IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN DIR$OUTPUT (0, LINE_DESC);
    DIR$SHOW_ACL ();
    END;

COLUMN_INDEX = .COLUMN_INDEX + 1;
SPACE_COUNT = .COLUMN_WIDTH - .LINE_DESC[DSC$W_LENGTH] + .COLUMN_BEGIN;
IF .COLUMN_COUNT GTR 1
AND .COLUMN_INDEX LSS .COLUMN_COUNT
THEN APPEND (0, '!#* ', .SPACE_COUNT);

RETURN 1;

END;						! End of routine DIR$SHOW_INFO

ROUTINE DIR$SHOW_FULL =

!++
!
! FUNCTIONAL DESCRIPTION:
!	Display all of the information
!
! CALLING SEQUENCE:
!	DIR$SHOW_FULL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

OWN
	JOURNAL_FLAG;				! Disable journaling

LOCAL
	HEADER_LEN,				! Length of file prefix
	FILENAME_LEN,				! Length of the file name
	NAME_LEN,				! Filename length minus version
	SPACE_COUNT,				! Number of spaces to pad
	LOCAL_DESC	: $BBLOCK [DSC$C_S_BLN],	! Local text descriptor
	MARK_POSITION;				! Saved line position

EXTERNAL ROUTINE
	DIR$OUTPUT;				! General output routine

! See if it is necessary and time to do the header & trailer information.

HEADER_LEN = .DISPLAY_BLOCK[DIR_B_NODE] +
	     .DISPLAY_BLOCK[DIR_B_DEV] +
	     .DISPLAY_BLOCK[DIR_B_DIR];
FILENAME_LEN = .DISPLAY_BLOCK[DIR_B_FNS] - .HEADER_LEN;
NAME_LEN = .DISPLAY_BLOCK[DIR_B_FNS] - .DISPLAY_BLOCK[DIR_B_VER];

IF CH$NEQ (.PREV_DIR_LEN, PREV_DIR, .HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME])
THEN
    BEGIN
    IF .LINE_DESC[DSC$W_LENGTH] GTR 0
    THEN
	BEGIN
	DIR$OUTPUT (0, LINE_DESC);
	COLUMN_INDEX = 0
	END;
    IF .PREV_DIR_LEN NEQ 0 THEN DIR$TOTAL ();
    PREV_DIR_LEN = .HEADER_LEN;
    CH$MOVE (.HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME], PREV_DIR);
    IF .QUAL_FLAGS[DIR_V_QUAL_HEAD]
    AND NOT .QUAL_FLAGS[DIR_V_QUAL_GRAN]
    THEN
	BEGIN
	WRITE (0, '');
	WRITE (DIR$_NEWDIRECT, 0, .PREV_DIR_LEN, PREV_DIR);
	END;
    END;

! Check for another version of the same file.

IF .VERSION_COUNT GTR 0
THEN
    BEGIN
    IF CH$EQL (.PREV_FILE_LEN, PREV_FILE,
	       .NAME_LEN, DISPLAY_BLOCK[DIR_T_FILENAME], 0)
    THEN VERSION_INDEX = .VERSION_INDEX + 1
    ELSE
	BEGIN
	PREV_FILE_LEN = .NAME_LEN;
	CH$MOVE (.NAME_LEN, DISPLAY_BLOCK[DIR_T_FILENAME], PREV_FILE);
	VERSION_INDEX = 0;
	END;
    IF .VERSION_INDEX GEQ .VERSION_COUNT THEN RETURN 1;
    END;

! Update the running totals.

TOTAL_USED = .TOTAL_USED + .DISPLAY_BLOCK[DIR_L_EFBLK];
TOTAL_ALLOC = .TOTAL_ALLOC + .DISPLAY_BLOCK[DIR_L_HIBLK];
TOTAL_FILES = .TOTAL_FILES + 1;

IF .QUAL_FLAGS[DIR_V_QUAL_TOTL] OR .QUAL_FLAGS[DIR_V_QUAL_GRAN] THEN RETURN 1;

WRITE (0, '');

CH$FILL (0, DSC$C_S_BLN, LINE_DESC);
LINE_DESC[DSC$W_LENGTH] = 0;
LINE_DESC[DSC$A_POINTER] = LINE_BUFFER;

IF NOT .QUAL_FLAGS[DIR_V_QUAL_HEAD]
THEN APPEND (0, '!AD', .HEADER_LEN, DISPLAY_BLOCK[DIR_T_FILENAME]);
APPEND (0, '!AD', .FILENAME_LEN, VECTOR [DISPLAY_BLOCK[DIR_T_FILENAME],
					.HEADER_LEN; ,BYTE]);
SPACE_COUNT = ((.LINE_DESC[DSC$W_LENGTH] / 20) + 1) * 20 - .LINE_DESC[DSC$W_LENGTH];
IF .SPACE_COUNT EQL 0 THEN SPACE_COUNT = 20;
APPEND (0, '!#* ', .SPACE_COUNT);
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];

! Check to see if an error occurred opening the file.

IF NOT .DISPLAY_BLOCK[DIR_L_STATUS]
THEN
    BEGIN
    CH$FILL (0, DSC$C_S_BLN, LOCAL_DESC);
    LOCAL_DESC[DSC$W_LENGTH] = 1024 - .LINE_DESC[DSC$W_LENGTH];
    LOCAL_DESC[DSC$A_POINTER] = LINE_BUFFER[.LINE_DESC[DSC$W_LENGTH]];
    $GETMSG (MSGID = .DISPLAY_BLOCK[DIR_L_STATUS],
	     MSGLEN = LOCAL_DESC,
	     BUFADR = LOCAL_DESC,
	     FLAGS = 1);
    LINE_DESC[DSC$W_LENGTH] = .LINE_DESC[DSC$W_LENGTH] + .LOCAL_DESC[DSC$W_LENGTH];
    IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
    THEN
	BEGIN
	LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	DIR$OUTPUT (0, LINE_DESC);
	CH$FILL (' ', 20, LINE_BUFFER);
	LOCAL_DESC[DSC$W_LENGTH] = 1024 - 20;
	LOCAL_DESC[DSC$A_POINTER] = LINE_BUFFER[20];
	$GETMSG (MSGID = .DISPLAY_BLOCK[DIR_L_STATUS],
		 MSGLEN = LOCAL_DESC,
		 BUFADR = LOCAL_DESC,
		 FLAGS = 1);
	LINE_DESC[DSC$W_LENGTH] = .LINE_DESC[DSC$W_LENGTH] + 20;
	END;
    DIR$OUTPUT (0, LINE_DESC);
    RETURN 1;
    END;

IF .MARK_POSITION + 28 GTR .DISPLAY_WIDTH
THEN
    BEGIN
    LINE_DESC[DSC$W_LENGTH] = .LINE_DESC[DSC$W_LENGTH] - .SPACE_COUNT;
    DIR$OUTPUT (0, LINE_DESC);
    END;
IF .LINE_DESC[DSC$W_LENGTH] LEQ 28
THEN SPACE_COUNT = 30 - .LINE_DESC[DSC$W_LENGTH]
ELSE SPACE_COUNT = 2;
IF .DISPLAY_BLOCK[DIR_W_FID_NUM] NEQ 0
OR .DISPLAY_BLOCK[DIR_W_FID_SEQ] NEQ 0
OR .DISPLAY_BLOCK[DIR_W_FID_RVN] NEQ 0
THEN APPEND (DIR$_FULLFILEID, 0, .SPACE_COUNT,
				 .DISPLAY_BLOCK[DIR_W_FID_NUM],
				 .DISPLAY_BLOCK[DIR_W_FID_SEQ],
				 .DISPLAY_BLOCK[DIR_W_FID_RVN])
ELSE APPEND (DIR$_NOFUFILEID, 0, .SPACE_COUNT);
DIR$OUTPUT (0, LINE_DESC);

APPEND (DIR$_FULLSIZE, 0, .DISPLAY_BLOCK[DIR_L_EFBLK],
			  .DISPLAY_BLOCK[DIR_L_HIBLK]);
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_B_NODE] EQL 0
THEN APPEND (DIR$_FULLOWNERID, 0, .DISPLAY_BLOCK[DIR_L_FILEOWNER])
ELSE APPEND (DIR$_FULLOWNERUIC, 0, .DISPLAY_BLOCK[DIR_L_FILEOWNER]);
IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
THEN
    BEGIN
    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
    DIR$OUTPUT (0, LINE_DESC);
    IF .DISPLAY_BLOCK[DIR_B_NODE] EQL 0
    THEN APPEND (DIR$_FULLOWNERID, 0, .DISPLAY_BLOCK[DIR_L_FILEOWNER])
    ELSE APPEND (DIR$_FULLOWNERUIC, 0, .DISPLAY_BLOCK[DIR_L_FILEOWNER]);
    END;
DIR$OUTPUT (0, LINE_DESC);
IF .DISPLAY_BLOCK[DIR_L_CDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_CDT4] EQL 0
THEN APPEND (DIR$_NOFUCREDAT)
ELSE APPEND (DIR$_FULLCREDAT, 0, DISPLAY_BLOCK[DIR_L_CDT0]);
IF .DISPLAY_BLOCK[DIR_L_RDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_RDT4] EQL 0
THEN APPEND (DIR$_NOFUREVDAT)
ELSE APPEND (DIR$_FULLREVDAT, 0, DISPLAY_BLOCK[DIR_L_RDT0],
				 .DISPLAY_BLOCK[DIR_W_REVISION]);
DIR$OUTPUT (0, LINE_DESC);

IF .DISPLAY_BLOCK[DIR_L_EDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_EDT4] EQL 0
THEN APPEND (DIR$_NOFUEXPDAT)
ELSE APPEND (DIR$_FULLEXPDAT, 0, DISPLAY_BLOCK[DIR_L_EDT0]);
IF .DISPLAY_BLOCK[DIR_L_BDT0] EQL 0 AND .DISPLAY_BLOCK[DIR_L_BDT4] EQL 0
THEN APPEND (DIR$_NOFUBAKDAT)
ELSE APPEND (DIR$_FULLBAKDAT, 0, DISPLAY_BLOCK[DIR_L_BDT0]);
DIR$OUTPUT (0, LINE_DESC);

APPEND (DIR$_FILEORG);
SELECTONEU .DISPLAY_BLOCK[DIR_V_FILEORG] OF
SET
    [DIR_C_SEQUENTIAL]:	APPEND (DIR$_FILORGSEQ);
    [DIR_C_RELATIVE]:	APPEND (DIR$_FILORGREL, 0, .DISPLAY_BLOCK[DIR_L_MRN]);
    [DIR_C_INDEXED]:	BEGIN
			APPEND (DIR$_FILORGIDX);
			IF .DISPLAY_BLOCK[DIR_B_NOKEYS] NEQ 0
			THEN
			    BEGIN
			    APPEND (DIR$_IDXPROLOG, 0, .DISPLAY_BLOCK[DIR_W_PVN],
						       .DISPLAY_BLOCK[DIR_B_NOKEYS]);
			    IF .DISPLAY_BLOCK[DIR_B_NOAREAS] GTRU 1
			    THEN
				BEGIN
				DIR$OUTPUT (0, LINE_DESC);
				APPEND (DIR$_IDXAREA, 0, .DISPLAY_BLOCK[DIR_B_NOAREAS]);
				END;
			    END;
			END;
    [OTHERWISE]:	APPEND (DIR$_FILORGUNK, 0, .DISPLAY_BLOCK[DIR_V_FILEORG]);
    TES;
DIR$OUTPUT (0, LINE_DESC);

APPEND (DIR$_FILEATTR, 0, .DISPLAY_BLOCK[DIR_L_HIBLK], .DISPLAY_BLOCK[DIR_W_DEFEXT]);
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_B_BKTSIZE] NEQ 0
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	IF .DISPLAY_BLOCK[DIR_V_FILEORG] EQL DIR_C_INDEXED
	THEN APPEND (DIR$_MAXBKTSIZ, 0, .DISPLAY_BLOCK[DIR_B_BKTSIZE])
	ELSE APPEND (DIR$_BUCKETSIZ, 0, .DISPLAY_BLOCK[DIR_B_BKTSIZE]);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
INCR J FROM 1 TO 2
DO
    BEGIN
    IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
    IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
    APPEND (DIR$_GBLBUFCNT, 0, .DISPLAY_BLOCK[DIR_W_GBC]);
    IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
    THEN
	BEGIN
	LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	DIR$OUTPUT (0, LINE_DESC);
	END
    ELSE EXITLOOP;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
INCR J FROM 1 TO 2
DO
    BEGIN
    IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
    IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
    IF .DISPLAY_BLOCK[DIR_W_VERLIMIT] EQL %X'7FFF'
    THEN APPEND (DIR$_NOVERLIMIT)
    ELSE APPEND (DIR$_VERLIMIT, 0, .DISPLAY_BLOCK[DIR_W_VERLIMIT]);
    IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
    THEN
	BEGIN
	LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	DIR$OUTPUT (0, LINE_DESC);
	END
    ELSE EXITLOOP;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_CONTIG]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRCTG);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_CONTIGB]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRCTB);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_LOCKED]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRLCK);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_NOBACKUP]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRNOBAK);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_WRITEBACK]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRWRBAK);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_READCHECK]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRRDCHK);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_WRITCHECK]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRWRCHK);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_BADACL]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRBADACL);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_DIRECTORY]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRDIR);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_BADBLOCK]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRBADBLK);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_NOCHARGE]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRNOCHRG);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
IF .DISPLAY_BLOCK[DIR_V_ERASE]
THEN
    BEGIN
    INCR J FROM 1 TO 2
    DO
	BEGIN
	IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN APPEND (0, ', ');
	IF .LINE_DESC[DSC$W_LENGTH] EQL 0 THEN APPEND (0, '!20* ');
	APPEND (DIR$_FILATRERASE);
	IF .LINE_DESC[DSC$W_LENGTH] GTR .DISPLAY_WIDTH
	THEN
	    BEGIN
	    LINE_DESC[DSC$W_LENGTH] = .MARK_POSITION;
	    DIR$OUTPUT (0, LINE_DESC);
	    END
	ELSE EXITLOOP;
	END;
    END;
IF .LINE_DESC[DSC$W_LENGTH] GTR 0 THEN DIR$OUTPUT (0, LINE_DESC);

APPEND (DIR$_RECFORMAT);
SELECTONEU .DISPLAY_BLOCK[DIR_V_RTYPE] OF SET
    [DIR_C_FIXED]:	APPEND (DIR$_RECFMTFIX, 0, .DISPLAY_BLOCK[DIR_W_RSIZE]);
    [DIR_C_VARIABLE]:	APPEND (DIR$_RECFMTVAR);
    [DIR_C_VFC]:	APPEND (DIR$_RECFMTVFC, 0, .DISPLAY_BLOCK[DIR_B_VFCSIZE]);
    [DIR_C_UNDEFINED]:	APPEND (DIR$_RECFMTUDF);
    [DIR_C_STREAM]:	APPEND (DIR$_RECFMTSTM);
    [DIR_C_STREAMLF]:	APPEND (DIR$_RECFMTSTMLF);
    [DIR_C_STREAMCR]:	APPEND (DIR$_RECFMTSTMCR);
    [OTHERWISE]:	APPEND (DIR$_RECFMTUNK, 0, .DISPLAY_BLOCK[DIR_V_RTYPE]);
    TES;
IF .DISPLAY_BLOCK[DIR_V_RTYPE] NEQ DIR_C_FIXED
AND .DISPLAY_BLOCK[DIR_W_RSIZE] NEQ 0
THEN APPEND (DIR$_MAXRECSIZ, 0, .DISPLAY_BLOCK[DIR_W_RSIZE]);
DIR$OUTPUT (0, LINE_DESC);

APPEND (DIR$_RECATTR);
IF .DISPLAY_BLOCK[DIR_B_RATTRIB] EQL 0
THEN APPEND (DIR$_NORECATTR)
ELSE
    BEGIN
    MARK_POSITION = .LINE_DESC[DSC$W_LENGTH];
    IF .DISPLAY_BLOCK[DIR_V_IMPLIEDCC] NEQ 0
    THEN APPEND (DIR$_CRCARCTL)
    ELSE IF .DISPLAY_BLOCK[DIR_V_FORTRANCC] NEQ 0
    THEN APPEND (DIR$_FTNCARCTL)
    ELSE IF .DISPLAY_BLOCK[DIR_V_PRINTCC] NEQ 0
    THEN APPEND (DIR$_PRICARCTL)
    ELSE APPEND (DIR$_NOCARCTL);
    IF .DISPLAY_BLOCK[DIR_V_NOSPAN] NEQ 0
    THEN
	BEGIN
	IF .MARK_POSITION NEQ .LINE_DESC[DSC$W_LENGTH] THEN APPEND (0, ', ');
	APPEND (DIR$_NOSPAN);
	END;
    END;
DIR$OUTPUT (0, LINE_DESC);

IF .JOURNAL_FLAG
THEN
    BEGIN
    APPEND (DIR$_JNLENABLED);
    IF .DISPLAY_BLOCK[DIR_W_JOURNAL] EQL 0
    THEN APPEND (DIR$_NOJNLENB)
    ELSE
	BEGIN
	IF .DISPLAY_BLOCK[DIR_V_AIJNL] THEN APPEND (0, 'AI,');
	IF .DISPLAY_BLOCK[DIR_V_BIJNL] THEN APPEND (0, 'BI,');
	IF .DISPLAY_BLOCK[DIR_V_ATJNL] THEN APPEND (0, 'AT,');
	IF .DISPLAY_BLOCK[DIR_V_RUJNL] THEN APPEND (0, 'RU,');
	IF .DISPLAY_BLOCK[DIR_V_ONLY_RU] THEN APPEND (0, 'ONLY_RU,');
	IF .DISPLAY_BLOCK[DIR_V_NEVER_RU] THEN APPEND (0, 'NEVER_RU,');
	LINE_DESC[DSC$W_LENGTH] = .LINE_DESC[DSC$W_LENGTH] - 1;
	END;
    DIR$OUTPUT (0, LINE_DESC);
    IF .DISPLAY_BLOCK[DIR_B_BI_SIZE] NEQ 0
    THEN WRITE (DIR$_BIJNLNAME, 0, DISPLAY_BLOCK[DIR_T_BI_JNLNAME])
    ELSE IF .DISPLAY_BLOCK[DIR_V_BIJNL]
	 THEN WRITE (DIR$_NOBIJNL);
    IF .DISPLAY_BLOCK[DIR_B_AI_SIZE] NEQ 0
    THEN WRITE (DIR$_AIJNLNAME, 0, DISPLAY_BLOCK[DIR_T_AI_JNLNAME])
    ELSE IF .DISPLAY_BLOCK[DIR_V_AIJNL]
	 THEN WRITE (DIR$_NOAIJNL);
    IF .DISPLAY_BLOCK[DIR_B_AT_SIZE] NEQ 0
    THEN WRITE (DIR$_ATJNLNAME, 0, DISPLAY_BLOCK[DIR_T_AT_JNLNAME])
    ELSE IF .DISPLAY_BLOCK[DIR_V_ATJNL]
	 THEN WRITE (DIR$_NOATJNL);
    END;

APPEND (DIR$_FILEPROT);
INCR J FROM 0 TO 3
DO
    BEGIN
    SELECTONE .J OF
    SET
	[0]:	APPEND (DIR$_SYSPROT);
	[1]:	APPEND (DIR$_OWNPROT);
	[2]:	APPEND (DIR$_GRPPROT);
	[3]:	APPEND (DIR$_WORPROT);
    TES;
    DIR$APPEND (0, .PROT_TABLE[.(DISPLAY_BLOCK[DIR_W_FILEPROT])<.J*4,4>]);
    END;
DIR$OUTPUT (0, LINE_DESC);

IF .ACL_LENGTH GTR 0
THEN DIR$SHOW_ACL ()
ELSE WRITE (DIR$_NOFILEACL);

RETURN 1;

END;						! End of routine DIR$SHOW_FULL

ROUTINE DIR$SHOW_ACL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to display the file's ACL.  The output
!	format differs depending on whether or not a full directory
!	listing is required.
!
! CALLING SEQUENCE:
!	DIR$SHOW_ACL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	ACL_BUFFER	: REF $BBLOCK,	! Address of ACL storage
	ACE_POINTER	: REF $BBLOCK,	! Pointer to binary ACE
	ACE_BINDESC	: $BBLOCK [8],	! Descriptor to binary ACE
	ACE_TXTDESC	: $BBLOCK [8],	! Descriptor to converted ACE
	ACE_TEXT	: $BBLOCK [3072],	! Converted ACE text storage
	ACL_FIBDESC	: $BBLOCK [8],	! FIB descriptor
	ACL_FIB		: $BBLOCK [FIB$C_LENGTH],	! File FIB
	ATR_DESC	: $BBLOCK [12],	! Attribute descriptor
	STATUS,				! Routine exit status
	IOSB		: VECTOR [4, WORD];	! I/O status block

EXTERNAL ROUTINE
	DIR$OUTPUT;				! General output routine

IF .DISPLAY_BLOCK[DIR_B_NODE] EQL 0
THEN
    BEGIN

! Allocate a block of storage for the file's ACL.

    STATUS = LIB$GET_VM (%REF (512), ACL_BUFFER);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (.STATUS);
	RETURN .STATUS;
	END;

! Set up the FIB to read the ACL.

    CH$FILL (0, FIB$C_LENGTH, ACL_FIB);
    ACL_FIBDESC[DSC$W_LENGTH] = FIB$C_LENGTH;
    ACL_FIBDESC[DSC$A_POINTER] = ACL_FIB;
    ACL_FIB[FIB$W_FID_NUM] = .DISPLAY_BLOCK[DIR_W_FID_NUM];
    ACL_FIB[FIB$W_FID_SEQ] = .DISPLAY_BLOCK[DIR_W_FID_SEQ];
    ACL_FIB[FIB$W_FID_RVN] = .DISPLAY_BLOCK[DIR_W_FID_RVN];
    WHILE 1
    DO
	BEGIN
	CH$FILL (0, .ACL_LENGTH, .ACL_BUFFER);
	ATR_DESC[ATR$W_SIZE] = 512;
	ATR_DESC[ATR$W_TYPE] = ATR$C_READACL;
	ATR_DESC[ATR$L_ADDR] = .ACL_BUFFER;
	ATR_DESC[8,0,32,0] = 0;

	STATUS = $QIOW (CHAN = .CHANNEL,
			FUNC = IO$_ACCESS,
			IOSB = IOSB,
			P1 = ACL_FIBDESC,
			P5 = ATR_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF .STATUS THEN STATUS = .ACL_FIB[FIB$L_ACL_STATUS];
	IF NOT .STATUS THEN EXITLOOP;
	ACE_POINTER = .ACL_BUFFER;
	CH$FILL (0, 8, ACE_BINDESC);
	CH$FILL (0, 8, ACE_TXTDESC);
	UNTIL .ACE_POINTER[ACE$B_SIZE] EQL 0
	   OR .ACE_POINTER GEQA ACL_BUFFER + .ACL_LENGTH
	DO
	    BEGIN
	    IF NOT .ACE_POINTER[ACE$V_HIDDEN]
	    THEN
		BEGIN
		ACE_BINDESC[DSC$W_LENGTH] = .ACE_POINTER[ACE$B_SIZE];
		ACE_BINDESC[DSC$A_POINTER] = .ACE_POINTER;
		ACE_TXTDESC[DSC$W_LENGTH] = 3072;
		ACE_TXTDESC[DSC$A_POINTER] = ACE_TEXT;
		STATUS = $FORMAT_ACL (ACLENT = ACE_BINDESC,
				      ACLLEN = ACE_TXTDESC[DSC$W_LENGTH],
				      ACLSTR = ACE_TXTDESC,
				      WIDTH = DISPLAY_WIDTH,
				      TRMDSC = $DESCRIPTOR (%CHAR (13), %CHAR(10)),
				      INDENT = %REF (IF .QUAL_FLAGS[DIR_V_QUAL_FULL]
						     THEN 20 ELSE 10));
		IF NOT .STATUS
		THEN
		    BEGIN
		    SIGNAL (.STATUS);
		    RETURN .STATUS;
		    END;
		IF .ACE_POINTER EQL .ACL_BUFFER AND .QUAL_FLAGS[DIR_V_QUAL_FULL]
		THEN
		    BEGIN
		    $GETMSG (MSGID = DIR$_FILEACL,
			     MSGLEN = %REF (0),		! Length is a throw-away
			     BUFADR = ACE_TXTDESC,
			     FLAGS = 1);
		    END;
		WRITE (0, '!AS', ACE_TXTDESC);
		END;
	    ACE_POINTER = .ACE_POINTER + .ACE_POINTER[ACE$B_SIZE];
	    END;
	END;
    END;

RETURN 1;

END;					! End of routine DIR$SHOW_ACL;

GLOBAL ROUTINE DIR$TOTAL =

!++
!
! FUNCTIONAL DESCRIPTION:
!	Display the per directory total
!
! CALLING SEQUENCE:
!	DIR$TOTAL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

EXTERNAL ROUTINE
	DIR$OUTPUT;				! General output routine

IF NOT .QUAL_FLAGS[DIR_V_QUAL_GRAN]
AND .QUAL_FLAGS[DIR_V_QUAL_TRAI]
THEN
    BEGIN
    WRITE (0, '');
    IF .QUAL_FLAGS[DIR_V_QUAL_SIZE] OR .QUAL_FLAGS[DIR_V_QUAL_FULL]
    THEN
	BEGIN
	IF .QUAL_FLAGS[DIR_V_SIZE_ALL] OR .QUAL_FLAGS[DIR_V_QUAL_FULL]
	THEN WRITE (DIR$_TOTSIZALL, 0, .TOTAL_FILES, .TOTAL_USED, .TOTAL_ALLOC)
	ELSE WRITE (DIR$_TOTSIZ, 0, .TOTAL_FILES, (IF .QUAL_FLAGS[DIR_V_SIZE_USED]
						   THEN .TOTAL_USED ELSE .TOTAL_ALLOC));
	END
    ELSE WRITE (DIR$_TOTNOSIZ, 0, .TOTAL_FILES);
    END;
GRAND_USED = .GRAND_USED + .TOTAL_USED;
GRAND_ALLOC = .GRAND_ALLOC + .TOTAL_ALLOC;
GRAND_FILES = .GRAND_FILES + .TOTAL_FILES;
GRAND_DIRS = .GRAND_DIRS + 1;
TOTAL_USED = TOTAL_ALLOC = TOTAL_FILES = 0;

RETURN 1;

END;						! End of routine DIR$TOTAL

GLOBAL ROUTINE DIR$GRAND_TOTAL =

!++
!
! FUNCTIONAL DESCRIPTION:
!	Display the overall totals
!
! CALLING SEQUENCE:
!	DIR$GRAND_TOTAL ()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

EXTERNAL ROUTINE
	DIR$OUTPUT;				! General output routine

IF NOT .QUAL_FLAGS[DIR_V_QUAL_TRAI] THEN RETURN 1;

WRITE (0, '');
IF .QUAL_FLAGS[DIR_V_QUAL_SIZE] OR .QUAL_FLAGS[DIR_V_QUAL_FULL]
THEN
    BEGIN
    IF .QUAL_FLAGS[DIR_V_SIZE_ALL] OR .QUAL_FLAGS[DIR_V_QUAL_FULL]
    THEN
	BEGIN
	IF .GRAND_DIRS NEQ 1
	THEN WRITE (DIR$_GTOTSIZALL, 0, .GRAND_DIRS, .GRAND_FILES,
					.GRAND_USED, .GRAND_ALLOC)
	ELSE WRITE (DIR$_GTOTSIZALL1, 0, .GRAND_DIRS, .GRAND_FILES,
					 .GRAND_USED, .GRAND_ALLOC);
	END
    ELSE
	BEGIN
	IF .GRAND_DIRS NEQ 1
	THEN WRITE (DIR$_GTOTSIZ, 0, .GRAND_DIRS, .GRAND_FILES,
				     (IF .QUAL_FLAGS[DIR_V_SIZE_USED]
				      THEN .GRAND_USED ELSE .GRAND_ALLOC))
	ELSE WRITE (DIR$_GTOTSIZ1, 0, .GRAND_DIRS, .GRAND_FILES,
				      (IF .QUAL_FLAGS[DIR_V_SIZE_USED]
				       THEN .GRAND_USED ELSE .GRAND_ALLOC));
	END;
    END
ELSE
    BEGIN
    IF .GRAND_DIRS NEQ 1
    THEN WRITE (DIR$_GTOTNOSIZ, 0, .GRAND_DIRS, .GRAND_FILES)
    ELSE WRITE (DIR$_GTOTNOSIZ1, 0, .GRAND_DIRS, .GRAND_FILES);
    END;

RETURN 1;

END;						! End of routine DIR$GRAND_TOTAL

GLOBAL ROUTINE DIR$APPEND (MESSAGE_CODE, CONTROL_STRING, ARGS) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine accepts, as input, an $FAO control string and any
!	arguments to be formatted by the control string.  The formatted
!	line is then appended to the current line.
!
! CALLING SEQUENCE:
!	DIR$APPEND (ARG1, ARG2, ..., ARGn)
!
! INPUT PARAMETERS:
!	ARG1: message code for the text to display
!	ARG2: address of the $FAO control string
!	ARG3 - ARGn: arguments to be formatted
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPTUS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	CONTROL_STRING	: REF $BBLOCK;		! Address of the control string

LOCAL
	FAO_CTL_STRING	: REF $BBLOCK,		! Addr of $FAO control string
	MESSAGE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Message text descr
	MESSAGE_TEXT	: VECTOR [256, BYTE],	! Message text
	LOCAL_DESC	: $BBLOCK [DSC$C_S_BLN];	! Local copy of line descriptor

! If there is a message code present, get the message text via a $GETMSG.
! Otherwise, use the descriptor supplied.

IF .MESSAGE_CODE NEQ 0
THEN
    BEGIN
    CH$FILL (0, DSC$C_S_BLN, MESSAGE_DESC);
    MESSAGE_DESC[DSC$W_LENGTH] = 256;
    MESSAGE_DESC[DSC$A_POINTER] = MESSAGE_TEXT;
    $GETMSG (MSGID = .MESSAGE_CODE,
	     MSGLEN = MESSAGE_DESC[DSC$W_LENGTH],
	     BUFADR = MESSAGE_DESC,
	     FLAGS = 1);
    FAO_CTL_STRING = MESSAGE_DESC;
    END
ELSE FAO_CTL_STRING = .CONTROL_STRING;

! Format the line.

CH$FILL (0, DSC$C_S_BLN, LOCAL_DESC);
LOCAL_DESC[DSC$W_LENGTH] = 1024 - .LINE_DESC[DSC$W_LENGTH];
LOCAL_DESC[DSC$A_POINTER] = LINE_BUFFER[.LINE_DESC[DSC$W_LENGTH]];

$FAOL (CTRSTR = .FAO_CTL_STRING,
       OUTLEN = LOCAL_DESC,
       OUTBUF = LOCAL_DESC,
       PRMLST = ARGS);

LINE_DESC[DSC$W_LENGTH] = .LINE_DESC[DSC$W_LENGTH] + .LOCAL_DESC[DSC$W_LENGTH];

RETURN 1;

END;						! End of routine DIR$APPEND

END
ELUDOM
