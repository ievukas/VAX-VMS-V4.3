	.TITLE	CNXMAN - Cluster Connection Manager
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: EXECUTIVE, CLUSTER MANAGEMENT
;
; ABSTRACT: 
;	This module creates and manages connections to the other systems
;	in the cluster.
;
; ENVIRONMENT: VAX/VMS
;
; AUTHOR: Steve Beckhardt,	 CREATION DATE: 17-Aug-1982
;
; MODIFIED BY:
;
;	V03-028	DWT0235		David W. Thiel		7-Aug-1984
;		Correct source of SCS message size for testing.
;
;	V03-027	DWT0228		David W. Thiel		24-Jul-1984
;		Modify send credits from 10 to 5.  Modify limit
;		on unacknowledged messages from 7 to 4.
;
;	V03-026	DWT0216		David W. Thiel		30-Apr-1984
;		Correct sequencing of events for "lasp gasp"
;		messages.
;
;	V03-025	DWT0206		David W. Thiel		07-Apr-1984
;		Add support for "Last Gasp" from a failing system.
;		Initialize CLUBPWF block in CLUB.
;
;	V03-024	DWT0202		David W. Thiel		25-Mar-1984
;		Remove all references to CNCT$V_QOURUM and
;		CNCT$V_TRANSITION.
;
;	V03-023	DWT0191		David W. Thiel		21-Mar-1984
;		Update to support new ACKMSG.  Reinstate improved
;		version number checking.
;
;	V03-022	DWT0176		David W. Thiel		23-Feb-1984
;		Initialize CLUB$W_QDVOTES to largest integer when
;		creating CLUB.  Maintain SB$L_CSB as a pointer to
;		the newest CSB for a system.
;
;	V03-021	DWT0163		David W. Thiel		19-Jan-1984
;		Correct CNX$DISC_* routines.  Support forced
;		disconnection in the general case.  Rename
;		CNX_ERROR to CNX$ERROR.
;
;	V03-020	DWT0148		David W. Thiel		13-Dec-1983
;		Store SYSGEN parameters LCKDIRWT and QDSKVOTES in
;		the local CSB.  Restructure code.  Use CNX$ALLOZMEM
;		to allocate and zero pool.  Correct disabling of
;		polling once a node is firmly discovered.
;
;	V03-019 DWT0142		David W. Thiel		07-Nov-1983
;		Use symbolic protocol level (CNCT$K_PROTOCOL).
;
;	V03-018	DWT0127		David W. Thiel		30-Aug-1983
;		Pull console message routines out into new module
;		CLUMESSAG.MAR.
;		Disable process polling after accepting a connection.
;		Check more carefully for a fatal disconnect.
;
;	V03-017	DWT0117		David W. Thiel		24-Aug-1983
;		Replace systemid with node name in all messages.
;		Change CONFIG_CHANGE to CNX$CONFIG_CHANGE.  Update
;		protocol version level to 6 to mark incompatibility
;		with previous versions.
;
;	V03-016	DWT0116		David W. Thiel		2-Aug-1983
;		Increment protocol level to mark incompatibility
;		with previous versions.
;
;	V03-015	DWT0109		David W. Thiel		16-Jul-1983
;		Use CNX$CHECK_QUORUM to hang on lose of quorum.
;		Tolerate repeating software incarnation numbers.
;		Correct cleanup after an ACCEPT fails.  Clean up
;		code a little bit.  Improve some messages.
;
;	V03-014	ROW0185		Ralph O. Weber		21-JUN-1983
;		Change CSB SEL queue to block transfer partners BTX queue, to 
;		support connection manager block transfers.  Remove CLUB 
;		references to SEL queue.
;
;	V03-013	DWT0105		David W. Thiel		16-Jun-1983
;		Fail message on any call to LONG_BREAK.
;		Refuse to open connection when LONG_BREAK is set.
;
;	V03-012	DWT0098		David W. Thiel		14-May-1983
;		If incompatibile connection manager's see each other,
;		BUGCHECK one of them.
;		Remove temporary configuration management code and
;		integrate use of CONMAN module.
;		Move CNX$DISPATCH to CONMAN.
;		Add CSB$L_SB as pointer to SB.
;		More initialization of local CSB.
;		Dynamically allocate CLUB structure.
;
;	V03-011	ROW0186		Ralph O. Weber		25-APR-1983
;		Bump protocol version number to indicate use of two level 
;		dispatching.  Add setup for CLUB$L_JNL_DISPT in CNX$INIT.  
;		Change LCK$GL_DIRSYSCSB to LCK$GL_DIRSYSCSID.  Change setup to 
;		put directory node CSID in there.  Add CNX$DISPATCH, the 
;		target of the first level input dispatcher for FAC_CNX 
;		messages.
;
;	V03-010	DWT0093		David W. Thiel		15-Apr-1983
;		Track changes in $CLUBDEF.
;
;	V03-009	DWT0090		David W. Thiel		31-Mar-1983
;		Add reconnection data to detect partitioned clusters.
;		Extend CSB and CLUB.
;		Change protocol version to 2.
;
;	V03-008	DWT0085		David W. Thiel		14-Mar-1983
;		Avoid attempt to output message during initialization.
;		Correct misuse of stack for connect data.
;
;	V03-007	DWT0084		David W. Thiel		12-Mar-1983
;		Correct bug that allows a reconnect to be sent to
;		a recently rebooted system.  Log CSB creations.
;
;	V03-006	SRB0070		Steve Beckhardt		10-Mar-1983
;		Added routine to send the job controller a message
;		when a system is removed from the cluster.  This is
;		a temporary change.
;
;	V03-005	DWT0083		David W. Thiel		10-Mar-1983
;		Replace HALTs with generic connection manager
;		BUG_CHECKs.  Create and use CLUster Block.  Change
;		SYSAP name.
;
;	V03-004	DWT0082		David W. Thiel		3-Mar-1983
;		Correct use of disconnect/reject status codes.
;
;	V03-003	DWT0070		David W. Thiel		21-Feb-1983
;		Major revision which includes:
;		Initialize automatically on being loaded.
;		Use SCA Process Poller to find new systems.
;		More state oriented structure.
;		Split out acknowledged message services as ACKMSG.
;
;	V03-002	SRB0064		Steve Beckhardt		21-Jan-1983
;		Removed cell LCK$GL_DIRSYSCSB as it now resides in the
;		EXEC (in module SYSCOMMON).
;	
;--


	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CDTDEF				; CDT Offsets
	$CLMDRSDEF			; Cluster disconnect/reject codes
	$CLSMSGDEF			; Cluster message definitions
	$CLUBDEF			; CLUster Block offsets
	$CNCTDEF			; CONNECT data offsets
	$CSBDEF				; CSB Offsets
	$DYNDEF				; Data structure type codes
	$FKBDEF				; Fork block offsets
	$IPLDEF				; IPL definitions
	$MSGDEF				; Mailbox message type codes
	$PBDEF				; PB Offsets
	$PDTDEF				; PDT Offsets
	$SBDEF				; SB Offsets
	$SCSCMGDEF			; SCS CONNECT Message definitions
	$TQEDEF				; TQE offsets

;
; MACROS:
;

	.MACRO	STATE_DISP	LIST
	BSBW	DISPATCH
	.IRP	ITEM,<LIST>
	STATE_ENTRY	ITEM
	.ENDR
	.BYTE	0			; Flag end
	.ENDM	STATE_DISP

	.MACRO	STATE_ENTRY	CODE,ADDR,?LABEL
	.BYTE	CSB$K_'CODE
	.SIGNED_WORD	ADDR-LABEL
LABEL:	.ENDM	STATE_ENTRY

;
; EQUATED SYMBOLS:
;

SEND_CREDITS = 5			; Connection send credits
;
;	The unacknowledged message limit is set to SEND_CREDITS-1
;	in order to force an explicit acknowledgement message to
;	be sent BEFORE SCS will ever consider sending an explicit
;	credit message.  This is done because the acknowledgement
;	message costs the same as the credit message and does
;	more (it completes sending threads).  This formula for
;	choosing an unacknowledged message limit is conservative
;	in that message buffers cached in the warm CDRP cache
;	instead of being deallocated cannot cause explicit SCS
;	credit messages.
;

;
; OWN STORAGE:
;

	.PSECT	$$$040,LONG		; R/W Data PSECT

PROC_NAME:				; SYSAP name
	.ASCII	"VMS$VAXcluster"
	.REPT	16-<.-PROC_NAME>
	.ASCII	" "
	.ENDR

;***********************************************************************
;
; NOTE:	The following assumptions are in effect for this entire module.
;
;************************************************************************

	ASSUME	IPL$_SYNCH  EQ  IPL$_SCS
	ASSUME	IPL$_SYNCH  EQ  IPL$_TIMER

	.DEFAULT	DISPLACEMENT,WORD

;++
;
; STATE-ORIENTED DESCRIPTION OF CONNECTION MANAGEMENT LAYER:
;
;
;	The connection manager is organized as a state machine.
;	Each connection has its own independent state machine.  Each
;	connection is represented by a Connection Status Block (CSB).
;	The state of a connection is defined by the contents of the
;	CSB$B_STATE field of the CSB.  The states are defined by
;	symbols of the format:  CSB$K_state where "state" is the
;	state name.
;
; STATES:
;
;    NEW
;	Brand new connection block created as the result of a
;	reference to a node id/software incarnation for which no
;	CSB existed.
;
;    CONNECT
;	Initial connect request to a newly discovered system in
;	progress.
;
;    ACCEPT
;	Initial connection from a newly discovered system being
;	accepted.
;
;    OPEN
;	Connection to a system exists and is available for use.
;	This is the "normal" state of a CSB.
;
;    DISCONNECT
;	Disconnect of an open connection in progress.
;
;    WAIT
;	Timeout in progress.  On conclusion of the timeout, an
;	attempt will be made to reconnect to the remote system.
;
;    RECONNECT
;	Connect in progress to a system to which a previous
;	connection broke.
;
;    REACCEPT
;	Accept in progress to a system to which a previous
;	connection broke.
;
;    DEAD
;	A new incarnation of the node has been seen.
;	No connection new connection to the incarnation specified
;	by the CSB is possible, for obvious reasons.
;
;    LOCAL
;	Special state only found for the local node.
;
;--

	.SBTTL	CNX$INIT - Initialize connection manager

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called during system booting to initialize
;	the connection manager.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$INIT
;	IPL is 31
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

	.PSECT	$$$002			; Initialization section

CNX$INIT::
	MOVZWL	#CLUB$K_LENGTH,R1	; Length of CLUB
	BSBW	CNX$ALLOZMEM		; Allocate and zero memory
	BLBC	R0,5$			; Branch if memory not available
	MOVL	R2,G^CLU$GL_CLUB	; Store for the world to see
	MOVAQ	CLUB$L_CSBQFL(R2), -	; Initialize CSB queue
		CLUB$L_CSBQFL(R2)
	MOVAQ	CLUB$L_CSBQFL(R2), -
		CLUB$L_CSBQBL(R2)
	MOVB	#DYN$C_CLU_CLUB, -	; Block subtype
		CLUB$B_SUBTYPE(R2)
	MOVAL	W^CJF$MIN_JOURNAL,CLUB$L_JNL_DISPT(R2) ; Init journal dispatch
	MOVW	#1,CLUB$W_FIRST_INDEX(R2)	; Next available CSID slot
	MCOMW	#0,CLUB$W_QDVOTES(R2)	; Initialize to maximum possible votes
	ASSUME	CLUBFKB$S_FORK_BLOCK GE FKB$K_LENGTH
	MOVAB	CLUB$B_FORK_BLOCK(R2),R0	; Address of fork block
	MOVB	#IPL$_SCS,FKB$B_FIPL(R0) ; Store IPL in fork block
	ASSUME	CLUBPWF$S_FORK_BLOCK GE FKB$K_LENGTH
	MOVAB	CLUB$B_CLUBPWF(R2),R0	; Power recovery fork block
	MOVB	#IPL$_SCS,FKB$B_FIPL(R0) ; Store IPL in fork block
	MOVAL	G^SCS$GA_LOCALSB,R1
	BSBW	CNX$CREATE_CSB		; Create CSB for local system
5$:	BLBC	R0,7$			; Branch on error
	MOVL	CSB$L_CLUB(R5),R1	; Get address of cluster block
	MOVL	R5,CLUB$L_LOCAL_CSB(R1)	; Local system CSB address
	MOVAB	CSB$B_CNCT(R5),R0	; Connect data template
	MOVB	CNCT$B_ECOLVL(R0), -	; Fill in protocol ECO level
		CSB$B_ECOLVL(R5)
	MOVB	CNCT$B_VERNUM(R0), -	; Fill in protocol version
		CSB$B_VERNUM(R5)
	MOVW	G^CLU$GW_VOTES, -	; Votes held by local system
		CSB$W_VOTES(R5)
	MOVW	G^CLU$GW_QUORUM, -	; Local system proposed quorum
		CSB$W_QUORUM(R5)
	MOVW	G^CLU$GW_QDSKVOTES, -	; Local system proposed quorum disk votes
		CSB$W_QDVOTES(R5)
	MOVW	G^CLU$GW_LCKDIRWT, -	; Lock manager directory system weight
		CSB$W_LCKDIRWT(R5)
	BISL2	#CSB$M_LOCAL, -		; Mark this the local CSB
		CSB$L_STATUS(R5)
	MOVB	#CSB$K_LOCAL, -		; Set state of local CSB
		CSB$B_STATE(R5)
;
; LISTEN for incoming CONNECTS.
;
	LISTEN	MSGADR = CNX$RCV_CNCT_MSG, -	; Listen for incoming CONNECTs
		LPRNAM = PROC_NAME, -
		PRINFO = (R0), -	; Use data in local CSB
		ERRADR = LISTEN_ERROR
	BLBC	R0,10$			; Branch on failure
	MOVZWL	#12+<256*4>,R1		; Length of cluster vector
	BSBW	CNX$ALLOZMEM		; Allocate and zero memory
7$:	BLBC	R0,10$			; Branch on failure
	MOVB	#DYN$C_CLU_CLUVEC,11(R2) ; Store sub-type
	MOVAB	12(R2),G^CLU$GL_CLUSVEC	; Store vector address
	MOVW	#256,G^CLU$GW_MAXINDEX	; Maximum cluster vector index+1

	MOVAB	W^CNX$NEWSYSTEM,R0	; Address of new system routine
	MOVAB	PROC_NAME,R2		; Address of process name
	JSB	G^SCS$POLL_PROC		; Poll for copies of self
	BLBC	R0,10$			; Branch on failure
	MOVL	G^CLU$GL_CLUB,R5	; Get address of cluster block
	MOVL	R1,CLUB$L_POLL_CTX(R5)	; Save context for later calls
					; R0 is odd -- enable polling
					; R1 is address of SPPB
	CLRL	R2			; All systems now and forever
	JSB	G^SCS$POLL_MODE		; Enable polling
	BSBW	CNX$CON_INIT		; Initialize configuration manager
10$:	RSB				; Return status

	.PSECT	$$$100,LONG
LISTEN_ERROR:
	DISCONNECT			; Clean up error
	RSB				;  and return

	.SBTTL	CNX$NEWSYSTEM - New system heard from

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when the SCA Process Poller detects
;	a possible new system.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$NEWSYSTEM
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R0 is context (nothing interesting)
;	R1 is address of process name
;	R2 is address of system ID
;	R3 is address of process information
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 odd = success
;		Disable polling on the system
;	R0 even = failure
;		Continue polling the system
;
; SIDE EFFECTS:
;
;	R1-R5 are destroyed
;
;--

	.PSECT	$$$100,LONG

CNX$NEWSYSTEM::
	MOVL	R2,R1			; Address of System ID
	CLRL	R2			; No buffer
	JSB	G^SCS$CONFIG_SYS	; Find SB
	BLBC	R0,30$			; Branch on not found
	BSBW	CNX$LOOKUP_CSB		; Find or allocate a CSB
	BLBC	R0,30$			; Branch on invalid system ID
	STATE_DISP	<<NEW,20$>,<CONNECT,30$>,<ACCEPT,30$>>
10$:	MOVL	#1,R0			; Disable polling
	RSB				; Return

20$:	BSBB	CNX$NEW_CSB		; Do initial connect to new CSB
30$:	CLRL	R0			; Continue polling
	RSB				; Unable to allocate memory

	.SBTTL	CNX$NEW_CSB - Connect to new system

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to do the initial connect to a
;	new system.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$NEW_CSB
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R5 is the CSB address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R4 are destroyed
;
;--

CNX$NEW_CSB::
	MOVB	#CSB$K_CONNECT,-	; Set state
		CSB$B_STATE(R5)
	BSBB	CNX$CONNECT		; Request connection
	RSB				; Unable to allocate memory

	.SBTTL	CNX$CONNECT - Connect to remote system

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to initiate a connection to the
;	connection manager on a remote system.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CONNECT
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R5 is address of initialized CSB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

CNX$CONNECT::
;
; Try to connect
; This thread may be suspended here
;
	BSBW	CNCT_DATA		; Set up connect data
	MOVL	CSB$L_SB(R5),R0		; Address of SB
	CONNECT	MSGADR = CNX$RCV_MSG,-	; Connect to system
		ERRADR = CNX$ERROR,-
		LPRNAM = PROC_NAME,-
		RPRNAM = PROC_NAME,-
		RSYSID = SB$B_SYSTEMID(R0),-
		INITCR = #SEND_CREDITS,-
		CONDAT = CSB$B_CNCT(R5),-
		AUXSTR = (R5)
	BLBS	R0,5$
	BSBW	CNX_STATUS_CHECK	; Check for bugcheck request
5$:
	STATE_DISP	<<CONNECT,100$>,<RECONNECT,200$>,<DEAD,300$>>
10$:	BLBC	R0,20$			; OK if connect failed
	MOVZWL	#<CLMDRS$M_DRS ! -	; Disconnect status
		CLMDRS$C_PROTOCOL>,R0
15$:	DISCONNECT			; Break anomalous connection
20$:	RSB				; Drop thread

90$:	MOVZWL	#<CLMDRS$M_DRS ! -	; Disconnect status
		  CLMDRS$M_FATAL ! -	; Bugcheck request
		CLMDRS$C_PROTOCOL>,R0
	BRB	15$

;
; Initial connect attempt completed
;
;	R2 is address of connection message
;	R3 is address of CDT
;	R4 is address of PDT
;	R5 is address of CSB
;
100$:	BLBC	R0,150$			; Connection error
	ASSUME	CNCT$B_VERNUM  EQ  CNCT$B_ECOLVL+1
	ASSUME	CSB$B_VERNUM  EQ CSB$B_ECOLVL+1
	MOVW	SCSCMG$B_SNDDAT+CNCT$B_ECOLVL(R2),- ; Store remote side's 
		CSB$B_ECOLVL(R5)	; protocol version number and ECO level
	MOVB	SCSCMG$B_SNDDAT+CNCT$B_ACKLIM(R2),- ; Store remote side's 
		CSB$B_REMACKLIM(R5)	; ACK limit
	BSBW	CNCT_CHECK		; Check connect data
	BLBC	R0,90$			; Bugcheck remote node
	ASSUME	CSB$L_PDT  EQ  CSB$L_CDT+4
	MOVQ	R3,CSB$L_CDT(R5)	; Store CDT and PDT address
	MOVB	#CSB$K_OPEN,-		; Mark connection open
		CSB$B_STATE(R5)
	PUSHL	R2			; Save connection message addr
	MOVL	CSB$L_SB(R5),R2		; Address of System Block
	MOVAB	SB$B_SYSTEMID(R2),R2	; Address of destination system ID
	MOVL	CSB$L_CLUB(R5),R1	; Address of cluster block
	MOVL	CLUB$L_POLL_CTX(R1),R1	; Address of SPPB
	CLRL	R0			; Disable polling
	JSB	G^SCS$POLL_MODE		; Disable polling this system
	POPR	#^M<R2>			; Restore connection message addr
	MOVAB	CNCT_MSG,R0		; Connect message address
	BSBW	CNX$CONFIG_CHANGE	; Note configuration change
	BSBW	CNX$RESEND_MSGS		; Initialize connection
	BSBW	CNX$CON_NEWSYS		; Inform configuration manager of new system
	RSB				; Return

150$:	; Come here on failure to make a connection.

	BSBW	CNX$DECREFCNT		; Deallocate CSB and return
	RSB

;
; Reconnect completed
;
200$:	BLBC	R0,220$
	ASSUME	CSB$L_PDT  EQ  CSB$L_CDT+4
	MOVQ	R3,CSB$L_CDT(R5)	; Store CDT and PDT address
	BSBW	RECNCT_CHECK		; Check data following reconnect
	BLBC	R0,280$			; Other node should crash
	BBS	#CSB$V_LONG_BREAK, -	; Disconnect if long break
		CSB$L_STATUS(R5),270$	;   has been seen
	MOVB	SCSCMG$B_SNDDAT+CNCT$B_ACKLIM(R2),- ; Store remote side's 
		CSB$B_REMACKLIM(R5)	; ACK limit
	MOVB	#CSB$K_OPEN,-		; Mark connection open
		CSB$B_STATE(R5)
	BSBW	CNX$CHECK_QUORUM	; Resume activity on if quorum
	MOVAB	RECNCT_MSG,R0		; Address of reconnect message
	BSBW	CNX$CONFIG_CHANGE	; Note configuration change
	MOVW	-			; Get last received sequence number
		SCSCMG$B_SNDDAT+CNCT$W_RCVDSEQNM(R2),R0 
	SUBW3	CSB$W_ACKRSEQNM(R5), -	; Is it .ge. last one?
		R0,R1
	BLSS	210$			; Branch if not and bugcheck
	MOVW	R0,CSB$W_ACKRSEQNM(R5)	; Store updated number
	BSBW	CNX$RESEND_MSGS		; Send pending message, initialize connection
	RSB

210$:	BUG_CHECK	CNXMGRERR,FATAL	; Invalid acknowledged sequence number

220$:	BBS	#CSB$V_LONG_BREAK, -	; Branch if long break has already
		CSB$L_STATUS(R5),240$	;  been seen
	CMPL	G^EXE$GL_ABSTIM, -	; Have we retried for long enough?
		CSB$L_TIMEOUT(R5)
	BLSSU	250$			; Not timeout out yet
	BSBW	LONG_BREAK		; Long break seen
240$:	MOVZWL	#10000,R4		; 10 sec = 10000 ms timeout
	BRB	260$

250$:	MOVZWL	#1000,R4		; 1 sec = 1000 ms
260$:	BSBW	CNX$WAIT		; Start timeout
	RSB

270$:	MOVZWL	#<CLMDRS$M_DRS ! -	; Disconnect status
		CLMDRS$C_PROTOCOL>,R0
	BRB	290$			; Branch to common code

280$:	MOVZWL	#< -			; Other node should withdraw
		    CLMDRS$M_DRS ! -
		    CLMDRS$C_REMOVED -
		>, R0
290$:	BSBW	CNX$DISCONNECT		; Break connection
	RSB

300$:	BSBW	10$			; Drop connection
	BSBW	DEAD_NODE		; Make node die
	RSB				; Return

	.SBTTL	CNX$RCV_CNCT_MSG - Receive CONNECT message

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by SCS when a incoming CONNECT occurs
;	for us.  First the list of CSBs is scanned to see if we had a
;	previous connection to that system.  If we did then if the
;	software incarnation is the same we have to resend any messages
;	that haven't been received.  If the software incarnation changed,
;	then we have to do a failover.  If we don't have a CSB for that
;	system then one is created.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCV_CNCT_MSG
;
; INPUT PARAMETERS:
;
;	R2	Address of connect request message
;	R3	Address of CDT
;	R4	Address of PDT
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Completion codes returned to remote system if connection
;	is rejected:
;
;	SS$_REJECT	Connection rejected.   R1 is in CLMDRS format.
;	SS$_INSFMEM	Unable to allocate memory
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;
;--

CNX$RCV_CNCT_MSG:
10$:	MOVL	CDT$L_PB(R3),R1		; Get address of path block
	MOVL	PB$L_SBLINK(R1),R1	; Get address of system block
	BSBW	CNX$LOOKUP_CSB		; Find CSB
	BLBC	R0,30$			; Branch on error
	STATE_DISP	<<NEW,200$>,<CONNECT,100$>,<RECONNECT,300$>,<WAIT,400$>>
	BUG_CHECK	CNXMGRERR,FATAL	; Unexpected connect received
;	MOVZWL	#<CLMDRS$M_DRS ! -	; Protocol error
;		CLMDRS$C_PROTOCOL ! -
;		CLMDRS$M_FATAL>,R0
;	BRB	50$

20$:	MOVZWL	#<CLMDRS$M_DRS ! -	; Protocol version error
		CLMDRS$C_VERSION>,R0
	BRB	50$

30$:	MOVZWL	#<CLMDRS$M_DRS ! -	; Nonfatal protocol error
		CLMDRS$C_PROTOCOL>,R0
	BRB	50$

40$:	MOVZWL	#<CLMDRS$M_DRS ! -	; Fatal protocol error
		  CLMDRS$M_FATAL ! -	
		CLMDRS$C_PROTOCOL>,R0
50$:	REJECT				; Reject the connection
	RSB

;
; Connect request from system to which we are connecting
; Compare system ids and allow the system with the lower id to CONNECT
; and the one with the higher id to ACCEPT.
;
100$:	PUSHR	#^M<R2,R3>		; Save R2 and R3 from CMPC3
	MOVL	CSB$L_SB(R5),R2		; Address of System Block
	CMPC3	#SB$S_SYSTEMID, -	; Compare system ids
		SB$B_SYSTEMID(R2), -
		G^SCS$GA_LOCALSB+SB$B_SYSTEMID
	POPR	#^M<R2,R3>		; Restore R2 and R3
	BGEQU	30$			; Remote is higher - reject
; 
; Connect request -- expected to be from a new system.
; If the connect request is not from a newly booting system, we assume
; that the local system has booted twice with the same incarnation
; number.  In this case, we reject the connection and hope that the other
; node will eventually see our attempts to connect and realize that this
; node has duplicated its incarnation number.
;
200$:	CMPB	SCSCMG$B_SNDDAT+CNCT$B_TYPE(R2),- ; Verify remote side is doing 
		#CNCT$K_INITIAL		; a new CONNECT
	BNEQ	30$			; It's not - don't allow a connect
	ASSUME	CNCT$B_VERNUM  EQ  CNCT$B_ECOLVL+1
	ASSUME	CSB$B_VERNUM  EQ CSB$B_ECOLVL+1
	MOVW	SCSCMG$B_SNDDAT+CNCT$B_ECOLVL(R2),- ; Store remote side's 
		CSB$B_ECOLVL(R5)	; protocol version number and ECO level
	MOVB	SCSCMG$B_SNDDAT+CNCT$B_ACKLIM(R2),- ; Store remote side's 
		CSB$B_REMACKLIM(R5)	; ACK limit
	BSBW	CNCT_CHECK		; Check connect data
	BLBC	R0,40$			; Branch to bugcheck remote node
	MOVB	#CSB$K_ACCEPT,-		; Set state
		CSB$B_STATE(R5)
	BSBB	CNX$ACCEPT		; Accept connection
	RSB

;
; Reconnect request from a system to which we are reconnecting
;
300$:	PUSHR	#^M<R2,R3>		; Save R2 and R3 from CMPC3
	MOVL	CSB$L_SB(R5),R2		; Address of System Block
	CMPC3	#SB$S_SYSTEMID, -	; Compare system ids
		SB$B_SYSTEMID(R2), -
		G^SCS$GA_LOCALSB+SB$B_SYSTEMID
	POPR	#^M<R2,R3>		; Restore R2 and R3
	BGEQU	30$			; Remote is higher - reject
;
; Connect request from a system that we are timing out
;
400$:	CMPB	SCSCMG$B_SNDDAT+CNCT$B_TYPE(R2),- ; Verify remote side is doing 
		#CNCT$K_RECONNECT	; a RECONNECT
	BNEQ	430$			; It's not -- handle special situation
	BSBW	RECNCT_CHECK		; Check data following reconnect
	BBS	#CSB$V_LONG_BREAK, -	; Reject if long break has been
		CSB$L_STATUS(R5),30$
	ASSUME	CNCT$B_VERNUM EQ CNCT$B_ECOLVL+1
	ASSUME	CSB$B_VERNUM EQ CSB$B_ECOLVL+1
	CMPW	SCSCMG$B_SNDDAT+CNCT$B_ECOLVL(R2),- ; Are we speaking the 
		CSB$B_ECOLVL(R5)	; same protocol as before?
	BNEQ	20$			; No -- fatal error
	MOVB	SCSCMG$B_SNDDAT+CNCT$B_ACKLIM(R2),- ; Store remote side's 
		CSB$B_REMACKLIM(R5)	; ACK limit
	MOVB	#CSB$K_REACCEPT,-	; Set state
		CSB$B_STATE(R5)
	MOVW	SCSCMG$B_SNDDAT+CNCT$W_RCVDSEQNM(R2),- ; Get last received 
		R0			; sequence number (of ours)
	SUBW3	CSB$W_ACKRSEQNM(R5),-	; Verify it's greater than or equal to
		R0,R1			; the last one
	BGEQ	420$			; It is
	BUG_CHECK	CNXMGRERR,FATAL	; *** Sequence number error

420$:	MOVW	R0,CSB$W_ACKRSEQNM(R5)	; It's ok - store it
	BSBW	DELETE_TQE		; Clean out TQE
	MOVB	#CNCT$K_RECONNECT, -	; Flag this as a reconnect
		CSB$B_CNCT+CNCT$B_TYPE(R5)
	BSBB	CNX$ACCEPT		; Accept connection
	RSB

;
; Get here is this node expected a re-connection and instead received
; an initial connect request.  This happens if the remote node has rebooted
; with a duplicated software incarnation number.  To recover from this
; situation, the software incarnation number in the CSB is modified and
; this routine is re-entered.  The old CSB will be marked "DEAD".
; A new CSB will be formed and the connect request accepted.
;
430$:	BSBW	DELETE_TQE		; Clean out TQE
	MOVAQ	CSB$Q_SWINCARN(R5),R0	; Address of stored software incarnation number
	MCOML	(R0),(R0)+		; Invalidate software incarnation number
	MCOML	(R0),(R0)		; so that a new CSB will be formed
	BRW	10$			; Re-enter this routine

	.SBTTL	CNX$ACCEPT - Accept connection from remote system

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to accept a connection from the
;	connection manager on a remote system.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$ACCEPT
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2 is address of connection message
;	R3 is address of CDT
;	R4 is address of PDT
;	R5 is address of initialized CSB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

CNX$ACCEPT::
;
; Try to accept
; This thread may be suspended here
;
	BSBW	CNCT_DATA		; Setup connect data
	ACCEPT	MSGADR = CNX$RCV_MSG,-
		ERRADR = CNX$ERROR,-
		INITCR = #SEND_CREDITS,-
		CONDAT = CSB$B_CNCT(R5),-
		AUXSTR = (R5)
	BLBS	R0,10$			; Branch on success
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	BSBB	20$			; Clean up failed success
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
10$:
	STATE_DISP	<<ACCEPT,100$>,<REACCEPT,200$>>
	BUG_CHECK	CNXMGRERR,FATAL	; Bugcheck

;
; Accept attempt failed.
; Clean up by rejecting a connection based on the listening CDT.
;
20$:	MOVL	R2,R3			; Address of listening CDT
	REJECT				; Reject the request
	RSB				; Terminate the thread

;
; Initial accept attempt completed
;
;	R3 is address of CDT
;	R4 is address of PDT
;	R5 is address of CSB
;
100$:	BLBC	R0,150$			; ACCEPT error
	ASSUME	CSB$L_PDT  EQ  CSB$L_CDT+4
	MOVQ	R3,CSB$L_CDT(R5)	; Store CDT and PDT address
	MOVL	CSB$L_SB(R5),R2		; Address of System Block
	MOVAB	SB$B_SYSTEMID(R2),R2	; Address of destination system ID
	MOVL	CSB$L_CLUB(R5),R1	; Address of CLUB
	MOVL	CLUB$L_POLL_CTX(R1),R1	; Address of SPPB
	CLRL	R0			; Disable polling
	JSB	G^SCS$POLL_MODE		; Disable polling this system
	MOVB	#CSB$K_OPEN,-		; Mark connection open
		CSB$B_STATE(R5)
	MOVAB	ACCPT_MSG,R0		; Address of accept message
	BSBW	CNX$CONFIG_CHANGE	; Note configuration change	
	BSBW	CNX$RESEND_MSGS		; Initialize for sending messages
	BSBW	CNX$CON_NEWSYS		; Inform configuration manager
	RSB

150$:	BSBW	CNX$DECREFCNT		; Deallocate CSB
	RSB

;
; Reaccept attempt completed
;
;	R3 is address of CDT
;	R4 is address of PDT
;	R5 is address of CSB
;
200$:	BLBC	R0,210$			; Branch on failure
	ASSUME	CSB$L_PDT  EQ  CSB$L_CDT+4
	MOVQ	R3,CSB$L_CDT(R5)	; Store CDT and PDT address
	BBS	#CSB$V_LONG_BREAK, -	; Branch if long break in connection
		CSB$L_STATUS(R5),220$
	MOVB	#CSB$K_OPEN,-		; Mark connection open
		CSB$B_STATE(R5)
	BSBW	CNX$CHECK_QUORUM	; Resume activity on if quorum
	MOVAB	REACCPT_MSG,R0		; Address of reaccept message
	BSBW	CNX$CONFIG_CHANGE	; Note configuration change
	BSBW	CNX$RESEND_MSGS		; Resend outstanding messages
	RSB

210$:	MOVZWL	#1000,R4		; Wait 1 sec = 1000 ms
	BSBW	CNX$WAIT		; Enter wait state
	RSB

220$:	MOVZWL	#<CLMDRS$M_DRS ! -
		CLMDRS$C_REMOVED>,R0
	BSBB	CNX$DISCONNECT		; Break connection
	RSB

	.SBTTL	CNX$DISC_BUGCHECK - Disconnect from Node and Request it to Bugcheck
	.SBTTL	CNX$DISC_REMOVE - Disconnect from Node Removed from Cluster
	.SBTTL	CNX$DISC_PROTOCOL - Disconnect from Node for protcol reasons
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	These routine are called to break a connection with a remote node and
;	return some informational status.
;
;	CNX$DISC_BUGCHECK: Request the remote node to bugcheck
;	CNX$DISK_REMOVE: Status indicates that the node was removed from the
;			cluster
;	CNX$DISC_PROTOCOL: Disconnect for protocol reasons, reconnect as convenient
;
; CALLING SEQUENCE:
;
;	JSB	CNX$DISC_BUGCHECK
;	JSB	CNX$DISC_REMOVE
;	JSB	CNX$DISC_PROTOCOL
;	IPL is at SCS fork level
;
; INPUT PARAMETERS:
;
;	R5:	Address of CSB of removed node
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0-R1 destroyed
;
;--

	.ENABLE	LSB

CNX$DISC_BUGCHECK::
	MOVZWL	#CLMDRS$M_DRS ! -	; Disconnect status
		 CLMDRS$M_FATAL ! -	; Fatal
		 CLMDRS$C_PROTOCOL, R0
	BRB	10$			; Join common code

CNX$DISC_REMOVE::
	MOVZWL	#CLMDRS$M_DRS ! -	; Disconnect status
		CLMDRS$C_REMOVED,R0
10$:	BSBB	DISC_STATUS		; Disconnect using status in R0
	BSBW	LONG_BREAK		; Mark a long break (may already be done)
	RSB				; Return to caller

CNX$DISC_PROTOCOL::
	MOVZWL	#CLMDRS$M_DRS ! -	; Disconnect status
		 CLMDRS$C_PROTOCOL, R0
DISC_STATUS:				; Disconnect status in R0
	PUSHR	#^M<R2,R3,R4,R5>	; Save non-volatile registers
	STATE_DISP	<<OPEN,100$>>	; Connection is currently open
	BRB	190$

100$:	BSBB	CNX$BREAK		; Break connection, status in R0
190$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB

	.DISABLE	LSB

	.SBTTL	CNX$ERROR - Connection error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by SCS when a connection breaks.
;	This routine calls CNX$CLEANUP to deal with outstanding
;	messages and then does a DISCONNECT.  A timeout is then
;	requested at the conclusion of which the connection will
;	be reattempted.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$ERROR (Called from SCS)
;	IPL is at SCS fork level (8)
;
; INPUT PARAMETERS:
;
;	R0	Contains error status (SS$_DISCONNECT or SS$_VCBROKEN)
;	R1	Additional status (disconnect reason or virtual circuit
;		broken reason)
;	R3	Address of CDT
;	R4	Address of PDT
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0-R5 destroyed
;
;--

CNX$ERROR::
	MOVL	CDT$L_AUXSTRUC(R3),R5	; CSB address
	PUSHR	#^M<R0,R1,R5>		; Save registers
	MOVZWL	#CLMDRS$M_DRS ! -	; Disconnect status
		CLMDRS$C_PROTOCOL,R0
	BSBB	CNX$BREAK		; Use common disconnect code
	POPR	#^M<R0,R1,R5>		; Restore registers
	BSBW	CNX_STATUS_CHECK	; Check for bugcheck request
	RSB

	.SBTTL	CNX$BREAK - Cleanup and Disconnect SCS Connection

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a connection breaks or when a
;	connection is to be broken.  It calls CNX$CLEANUP to deal
;	with outstanding messages and then does a DISCONNECT.
;	A timeout is then requested at the conclusion of which the
;	connection will be reattempted.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$BREAK
;	IPL is at IPL$_SYNCH = IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R0	Contains disconnect code
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0-R4 Destroyed.
;
;--

CNX$BREAK::
	PUSHL	R0			; Save disconnect status
	BBS	#CSB$V_LONG_BREAK, -	; Branch if long break
		CSB$L_STATUS(R5),20$
	MOVZWL	G^CLU$GW_RECNXINT,R0	; Max. retry in seconds
	ADDL3	R0,G^EXE$GL_ABSTIM, -	; Time at which to stop retries
		CSB$L_TIMEOUT(R5)
	MOVAB	CNXERROR_MSG,R0		; Address of message
	BSBW	CNX$CONFIG_CHANGE	; Note configuration change
20$:
	POPR	#^M<R0>			; Restore disconnect status
	ASSUME	CSB$L_PDT  EQ CSB$L_CDT+4
	MOVQ	CSB$L_CDT(R5),R3	; Fetch CDT and PDT addresses
	BSBB	CNX$DISCONNECT		; Disconnect, status in R0
	RSB

	.SBTTL	CNX$DISCONNECT - Disconnect from remote system

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to disconnect from the
;	connection manager on a remote system.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$DISCONNECT
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R0 is disconnect status
;	R5 is address of initialized CSB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

CNX$DISCONNECT::
	MOVB	#CSB$K_DISCONNECT, -	; Set disconnect state
		CSB$B_STATE(R5)
	PUSHL	R0			; Save status
	BSBW	CNX$CHECK_QUORUM	; Block activity if quorum lost
	BSBW	CNX$PRE_CLEANUP		; Cleanup outstanding messages
	POPR	#^M<R0>			; Restore status
;
; Try to disconnect
; This thread may be suspended here
;
	ASSUME	CSB$L_PDT  EQ CSB$L_CDT+4
	MOVQ	CSB$L_CDT(R5),R3	; Fetch CDT and PDT addresses
	DISCONNECT			; Status in R0, always succeeds
	STATE_DISP	<<DISCONNECT,100$>>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid state

;
; Soft disconnect attempt completed
;
100$:	BSBW	CNX$POST_CLEANUP	; Finish cleanup of outstanding messages
	ASSUME	CSB$L_PDT  EQ CSB$L_CDT+4
	CLRQ	CSB$L_CDT(R5)		; Clear CDT and PDT address in CSB
	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break yet
		CSB$L_STATUS(R5),110$
	BSBW	CNX$FAIL_MSG		; Fail outstanding messages
110$:	MOVZWL	#500,R4			; Delay 500 milli-seconds
	BSBB	CNX$WAIT
	RSB

	.SBTTL	CNX$WAIT - Initiate timeout

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to begin a timeout before trying
;	to reconnect to the connection manager on a remote system.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$WAIT
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R4 is the timeout period in milli-seconds
;	R5 is address of initialized CSB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R4 are destroyed
;
;--

CNX$WAIT::
	MOVB	#CSB$K_WAIT,-		; Set connection state WAITing
		CSB$B_STATE(R5)
	MOVZWL	#TQE$K_LENGTH,R1	; Size of timer queue entry
	JSB	G^EXE$ALONONPAGED	; Allocate one
	BLBC	R0,RETRY_CONNECT	; No memory, so forget timeout
	PUSHL	R5			; Save CSB address
	MOVW	R1,TQE$W_SIZE(R2)	; Store size
	MOVB	#DYN$C_TQE,TQE$B_TYPE(R2) ; Store type
	MOVL	R5,TQE$L_FR3(R2)	; Store CSB address as fork reg. R3
	CLRL	TQE$L_FR4(R2)		; Save zero as fork reg. R4
	MOVL	R2,CSB$L_TQE(R5)	; Save TQE address in CSB
	MOVL	R2,R5			; Move address of TQE
	MOVB	#TQE$C_SSSNGL,TQE$B_RQTYPE(R5) ; Store type of timer queue entry
	MOVAB	B^TIMEOUT,TQE$L_FPC(R5)	; Store address of timer fork process
	EMUL	R4,#10*1000,#0,R3	; Get milli-seconds and cvt to 100 ns. units
	MOVQ	G^EXE$GQ_SYSTIME,R0	; Get current time
	ADDL	R3,R0			; Add to current time
	ADWC	R4,R1
	JSB	G^EXE$INSTIMQ		; Insert in timer queue
	POPL	R5			; Restore CSB address
	RSB

;++
; Come here as a timer fork process to retry the CONNECT
; Inputs:
;	R3	CSB address
;	R5	TQE address
;
;--

TIMEOUT:
	MOVL	R5,R0			; Address of timer queue entry
	MOVL	R3,R5			; Address of CSB
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	CLRL	CSB$L_TQE(R5)		; Clear pointer to TQE
	CMPB	CSB$B_STATE(R5),-	; Are we in wait state?
		#CSB$K_WAIT
	BNEQ	10$			; No, just return
	BSBB	RETRY_CONNECT		; Do the rest in a subroutine so that
					; CONNECT can return here
10$:	MOVAL	G^EXE$AL_TQENOREPT,R5	; Use non-repeating timer queue entry
	RSB

;
; Must check for change to remote system that may have occurred during
; the timeout.  Unlike other situations, there is no connection to break
; to give notification of such an event.
;
RETRY_CONNECT:
	MOVL	CSB$L_SB(R5),R1		; Address of System Block
	BSBW	CNX$LOOKUP_CSB		; Find or allocate a CSB and
					;  as a side effect, handle old CSB
	BLBC	R0,20$			; Can't allocate CSB
	STATE_DISP	<<NEW,CNX$NEW_CSB>,<WAIT,100$>>
	BUG_CHECK	CNXMGRERR,FATAL

20$:	RSB

100$:	MOVB	#CSB$K_RECONNECT,-	; Change to RECONNECT state
		CSB$B_STATE(R5)
	MOVB	#CNCT$K_RECONNECT, -	; Flag this as a reconnect
		CSB$B_CNCT+CNCT$B_TYPE(R5)
	BSBW	CNX$CONNECT		; Request connection
	RSB				; Unable to allocate memory

	.SBTTL	CNCT_DATA - Setup Connect Data in CSB
;++
; FUNCTIONAL DESCRIPTION:
;
;	Set up the CSB$B_CNCT area in preparation for requesting
;	or accepting a connection.
;
; CALLING SEQUENCE:
;
;	BSBW	CNCT_DATA
;	IPL must be at IPL$_SCS 
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed.
;--

CNCT_DATA:
	MOVAB	CSB$B_CNCT(R5),R0	; Point to connect data area
	MOVL	CSB$L_CLUB(R5),R1	; Address of CLUB
	MOVW	CLUB$W_QUORUM(R1), -	; Cluster quorum
		CNCT$W_QUORUM(R0)
	MOVW	CLUB$W_VOTES(R1), -	; Cluster votes
		CNCT$W_VOTES(R0)
	MOVW	CLUB$W_NODES(R1), -	; Cluster nodes
		CNCT$W_NODES(R0)
	ASSUME	CSB$M_LONG_BREAK EQ CNCT$M_LONG_BREAK
	ASSUME	CSB$M_MEMBER EQ CNCT$M_MEMBER
	ASSUME	CSB$M_REMOVED EQ CNCT$M_REMOVED
	BICB3	#^C<CSB$M_LONG_BREAK ! -
		    CSB$M_MEMBER ! -
		    CSB$M_REMOVED>, -
		CSB$L_STATUS(R5), -	; Fill in status bits from CSB
		CNCT$B_CNXSTS(R0)
	ASSUME	CLUB$M_CLUSTER EQ CNCT$M_CLUSTER
	BICB3	#^C<CLUB$M_CLUSTER>, -
		CLUB$L_FLAGS(R1), -	; Fill in status bits from CLUB
		CNCT$B_CLSSTS(R0)
	MOVW	CSB$W_RCVDSEQNM(R5), -	; Last message received
		CNCT$W_RCVDSEQNM(R0)
	RSB

	.SBTTL	CNCT_CHECK - Verify Connect Data
;++
; FUNCTIONAL DESCRIPTION:
;
;	Evaluate received connect data vs. connect data
;	sent or about to be sent.
;
; CALLING SEQUENCE:
;
;	BSBW	CNCT_CHECK
;	IPL must be at IPL$_SCS 
;
; INPUT PARAMETERS:
;
;	R2	Address of received connect data message
;	R5	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	R0 is status
;		TRUE implies all is well, ACCEPT or proceed with connection
;		FALSE implies incompatibility, REJECT or break connection
;			requesting remote node to BUGCHECK
;
; SIDE EFFECTS:
;
;	This node will BUGCHECK if incompatible with the remote node and
;	it appears "best" that this node exit.
;
;	R1 is destroyed.
;--

CNCT_CHECK:
    	PUSHR	#^M<R2,R3,R4>		; Save registers
;
; First, check message size of remote system against size required by
; clusters.
;
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	MOVAB	CSB$B_CNCT(R5),R3	; Address of my connect data
	MOVAB	SCSCMG$B_SNDDAT(R2),R2	; Address of remote connect data

	CMPB	CSB$B_VERNUM(R5), -	; Compare remote version number to
		CNCT$B_VERNUM(R2)	;  local version number
	BGEQU	10$			; Branch if remote is >= local
;
; Get here is local node has high version number than remote node	
; If the versions are compatible, branch to 50$
; As of now, all different versions are incompatible.
; If the versions are incompatible, decide who should crash.
;
	BBS	#CNCT$V_CLUSTER, -	; Branch if remote node is a
		CNCT$B_CLSSTS(R2),70$	;   cluster member
	BRB	40$			; Branch to failure exit
;
; Get here if version are identical or if remote is a newer (higher)
; protocol than local.
; Check compatibility of message buffer sizes.
;
10$:	CMPW	G^SCS$GW_MAXMSG, -	; Is local system's maximium message
		#CLSMSG$K_MAXMSG	;   size big enough?
	BLSSU	90$			; Branch if too small
	MOVL	CSB$L_SB(R5),R0		; SB address of remote system
	CMPW	SB$W_MAXMSG(R0), -	; Compare against maximum cluster
		#CLSMSG$K_MAXMSG
	BGEQU	50$			; Branch if it is big enough
	BBS	#CNCT$V_CLUSTER, -	; Branch if remote node is
		CNCT$B_CLSSTS(R2),80$	;   a cluster member

40$:	CLRL	R0			; Form failure status
	BRB	60$			; Branch to common exit

50$:	MOVL	S^#SS$_NORMAL,R0	; Success status
60$:	POPR	#^M<R2,R3,R4>		; Restore registers
	RSB

;
; Get here when node must leave cluster
;
70$:	BUG_CHECK	CLUEXIT,FATAL	; Leave cluster because of incompatible
					; protocol levels

80$:	BUG_CHECK	CLUEXIT,FATAL	; Remote node is a cluster member with an
					; insufficient message buffer size.  This
					; node may never join, so die.

90$:	BUG_CHECK	CLUEXIT,FATAL	; Local node has too small value of SYSGEN
					; parameter SCSMAXMSG.

	.SBTTL	RECNCT_CHECK - Verify Reconnect Data
;++
; FUNCTIONAL DESCRIPTION:
;
;	Evaluate received reconnect data vs. connect data
;	sent or about to be sent.
;
; CALLING SEQUENCE:
;
;	BSBW	RECNCT_CHECK
;	IPL must be at IPL$_SCS 
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;	R2	Address of SCS connect message
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed.
;--

; Legend:
;	
;	C:	CLUB CLUSTER bit: this node is cluster member
;	c:	CNCT CLUSTER bit: other node is cluster member
;	Q:	CLUB QUORUM bit: cluster containing this node has quorum
;	q:	CNCT QUORUM bit: cluster containing other node has quorum
;	M:	CSB MEMBER bit: connection is to local cluster member
;	m:	CNCT MEMBER bit: connection is to local cluster member
;	L:	CSB LONG_BREAK bit: this node has seen long cnx break
;	l:	CNCT LONG_BREAK bit: other node has seen long cnx break
;	R:	CSB REMOVED bit: this node has removed other from cluster
;	r:	CNCT REMOVED bit: other node has removed this node from cluster
;
RECNCT_CHECK:
    	PUSHR	#^M<R2,R3>		; Save registers
	MOVL	CSB$L_CLUB(R5),R3	; Get CLUB address
	MOVAB	SCSCMG$B_SNDDAT(R2),R2	; Address of received connect data
;
; If other node has seen long break,  make sure this node counts it as a
; long break also.
;
	BBC	#CNCT$V_LONG_BREAK, -	; Branch if (NOT L) & (NOT l)
		CNCT$B_CNXSTS(R2),10$
	BSBB	LONG_BREAK		; Treat as though a long break
10$:	BBS	#CLUB$V_CLUSTER, -	; Branch if local node is cluster
		CLUB$L_FLAGS(R3),15$	;   member
	BBS	#CSB$V_LONG_BREAK, -	; Branch if long break and bugcheck
		CSB$L_STATUS(R5),80$	;  (NOT C) & L
	BRB	50$			; All seems well

15$:	BBC	#CNCT$V_REMOVED, -	; Branch if other has not removed us
		CNCT$B_CNXSTS(R2),20$	;
	CMPW	CNCT$W_VOTES(R2), -	; Does remote cluster have a quorum?
		CNCT$W_QUORUM(R2)
	BGEQU	70$			; Branch if r & q and bugcheck
20$:	BBC	#CSB$V_REMOVED, -	; Branch if we have not removed other
		CSB$L_STATUS(R5),30$	;
	CMPW	CLUB$W_VOTES(R3), -	; Does local cluster have a quorum?
		CLUB$W_QUORUM(R3)
	BGEQU	40$			; Branch if we have quorum --
					;  other should go: R & Q
30$:
;
; In the following two instructions, consider the case where
; one node has removed the other, but not vice-versa.  In these cases,
; it seems necessary that outgoing messages to the other node be blocked.
; In actuality, LONG_BREAK should inhibit outgoing messages from all
; parties except the connection manager.  The inhibited messages should
; be immediately returned with error status.
;
	BBC	#CSB$V_REMOVED, -	; Branch if we have not removed
		CSB$L_STATUS(R5),50$	;  other node
	BBC	#CNCT$V_REMOVED, -	; Branch if other node has not removed
		CNCT$B_CNXSTS(R2),50$	;  this node
;
; Each node has removed the other
; Neither node has quorum: R & r & (NOT Q) & (NOT q)
;
	CMPW	CNCT$W_VOTES(R2), -	; Compare available votes
		CLUB$W_VOTES(R3)
	BGTRU	70$			; Other has more votes, we crash
	BLSSU	40$			; This node has more votes
	CMPW	CNCT$W_NODES(R2), -	; Compare number of nodes in cluster
		CLUB$W_NODES(R3)
	BGTRU	70$			; Other has more nodes, crash
	BLSSU	40$			; Other nodes has more nodes
	PUSHR	#^M<R2,R3>
	MOVL	CSB$L_SB(R5),R2		; Remote System Block
	CMPC3	#SB$S_SYSTEMID, -	; Compare system ID's
		G^SCS$GA_LOCALSB+SB$B_SYSTEMID, -	;  local system ID
		SB$B_SYSTEMID(R2)	;   remote system ID
	POPR	#^M<R2,R3>
	BGTRU	70$
40$:	CLRL	R0			; Failure status means other
	BRB	60$			;  node should bugcheck

50$:	MOVL	#1,R0
60$:	POPR	#^M<R2,R3>		; Restore registers
	RSB

;
; Get here when node must leave cluster
;
70$:	BUG_CHECK	CLUEXIT,FATAL	; Leave cluster

;
; Get here when two nodes not part of a cluster regain a connection after
; a long break.
;
80$:	BUG_CHECK	CLUEXIT,FATAL	; Reboot to avoid inconsistency

	.SBTTL	LONG_BREAK - Long Break in Connection
;++
; FUNCTIONAL DESCRIPTION:
;
;	Connection has remained broken for a long time.
;	All un-acked messages have their fork process resumed with
;	a failure status.
;
; CALLING SEQUENCE:
;
;	BSBW	LONG_BREAK
;	IPL must be at IPL$_SCS 
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed.
;--

LONG_BREAK:
	BBSS	#CSB$V_LONG_BREAK, -	; Mark long break seen and
		CSB$L_STATUS(R5), 10$	;   return if already set
	MOVAB	FAILIO_MSG,R0		; Address of message
	BSBW	CNX$CONFIG_CHANGE	; Note configuration change
	BSBW	CNX$CON_BREAK		; Report long break
10$:	CMPB	CSB$B_STATE(R5), -	; Are we disconnecting?
		#CSB$K_DISCONNECT
	BEQL	20$			; Branch if yes
	BSBW	CNX$FAIL_MSG		; Complete outstanding messages
20$:	RSB	

	.SBTTL	CNX$DECREFCNT - Decrement CSB Reference Count

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine decrements a CSB reference count and deletes
;	the CSB when the reference count goes to 0.
;
; CALLING SEQUENCE:
;
;	BSBB	CNX$DECREFCNT
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;	R5:	Address of CSB, if not deleted
;	R5:	Contents of CSB$L_SYSQBL, if CSB deleted
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	R2-R4 preserved
;
;--

CNX$DECREFCNT::
	DECB	CSB$B_REF_CNT(R5)	; Decrement reference count
	BNEQ	20$			; Branch if non-zero
	BSBW	CNX$FAIL_MSG		; Fail any outstanding messages
	BSBB	DELETE_TQE		; Flush timer queue entry
	MOVAB	DEAD_MSG,R0		; Address of dead node message
	BSBW	CNX$CONFIG_CHANGE	; Report configuration change
	MOVL	CSB$L_SB(R5),R0		; SB address
	CMPL	R5,SB$L_CSB(R0)		; Is this CSB pointed to?
	BNEQ	10$
	CLRL	SB$L_CSB(R0)		; Invalidate back pointer
10$:	PUSHL	CSB$L_SYSQBL(R5)	; Backward link
	PUSHR	#^M<R2,R3>		; Save registers
	REMQUE	(R5),R0			; Unlink CSB
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	POPR	#^M<R2,R3,R5>		; Restore registers
20$:	RSB

	.SBTTL	DELETE_TQE - Delete a TQE linked to a CSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine deallocates a TQE linked to a CSB.
;
; CALLING SEQUENCE:
;
;	BSBB	DELETE_TQE
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	CSB$L_TQE is 0 or address of TQE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	R0 and R1 destroyed.
;
;--

DELETE_TQE:
	MOVL	CSB$L_TQE(R5),R0	; Get address of TQE
	BEQL	10$			; There isn't one
	PUSHR	#^M<R2,R3>		; Save registers
	REMQUE	(R0),R0			; Remove from timer queue
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	CLRL	CSB$L_TQE(R5)		; Clear pointer
	POPR	#^M<R2,R3>		; Restore registers
10$:	RSB

	.SBTTL	DEAD_NODE - Manage death of a node
;++
; FUNCTIONAL DESCRIPTION:
;
;	Called when a new incarnation of a system has been seen to
;	remove the last vestiges of knowledge of the old incarnation.
;	No connection to the system exists.  The CSB is deleted.
;
; CALLING SEQUENCE:
;
;	BSBB	DEAD_NODE
;
; INPUT PARAMETERS:
;
;	R5	Address of CSB
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	R0 and R1 are destroyed.  R5 is invalidated.
;
;--

DEAD_NODE:
	BSBB	LONG_BREAK		; Simulate connection broken for long time
	BSBB	DELETE_TQE		; Get rid of timer
	BSBB	CNX$DECREFCNT		; Get rid of CSB (eventually)
	RSB

	.SBTTL	CNX_STATUS_CHECK - Check SCS failure message
;++
; FUNCTIONAL DESCRIPTION:
;
;	Check SCS failure message and BUGCHECK if the remote node has requested
;	it.
;
; CALLING SEQUENCE:
;
;	JSB	CNX_STATUS_CHECK
;
; INPUT PARAMETERS:
;
;	R5 	CSB address
;	R0	SCS Reason code
;	R1	SYSAP reason (if R0=SS$_REJECT)
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

CNX_STATUS_CHECK:
	PUSHR	#^M<R0,R1>		; Save registers
	CMPW	R0,#SS$_REJECT		; Is this a connection request reject?
	BEQL	10$			; Branch if yes
	CMPW	R0,#SS$_DISCONNECT	; Is this a requested disconnect?
	BNEQ	20$			; Branch if no
10$:	BBC	#CLMDRS$V_DRS,R1,20$	; Branch if not a cluster disconnect code
	BBS	#CLMDRS$V_FATAL,R1,50$	; Branch if bugcheck requested
	CMPW	R0,#SS$_DISCONNECT	; Is this a requested disconnect?
	BNEQ	20$			; Branch if no
	CMPB	#CLMDRS$C_REMOVED,R1	; Is this node removed from cluster?
	BEQL	40$			; Branch if local node removed and exit
20$:	CMPW	R0,#SS$_VCBROKEN	; Is this a circuit failure?
	BNEQ	30$			; Branch if no
	CMPW	R1,#SS$_NOSUCHNODE	; Is this a result of a "last gasp"?
	BNEQ	30$			; Branch if no
	BSBW	LONG_BREAK		; Declare a long break
30$:	POPR	#^M<R0,R1>		; Restore registers
	RSB				; Return to caller

40$:	BUG_CHECK	CLUEXIT,FATAL	; This node removed from cluster

50$:	BUG_CHECK	CNXMGRERR,FATAL	; Bugcheck requested by disconnecting remote node


	.SBTTL	CNX$LOOKUP_CSB - Lookup a CSB given a SB address
;++
; FUNCTIONAL DESCRIPTION:
;
;	CNX$LOOKUP_CSB find a CSB with matching System ID and
;		software incarnation number given an SB address.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$LOOKUP_CSB
;
; INPUT PARAMETERS:
;
;	R1	Address of SB
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R5 is address of CSB
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 contains status
;
; SIDE EFFECTS:
;	R1 is destroyed
;
;--

CNX$LOOKUP_CSB::			; Lookup given SB address
	PUSHR	#^M<R2,R3,R4>		; Save registers
	MOVL	R1,R4			; SB address
	MOVL	SB$L_CSB(R4),R5		; Get CSB for this SB
	BEQL	30$			; Branch if no CSB for this SB

	; Check software incarnation.

	BBS	#CSB$V_LOCAL, -		; Skip if local system
		CSB$L_STATUS(R5),50$
	CMPC3	#CSB$S_SWINCARN,-	; Software incarnations match?	
		CSB$Q_SWINCARN(R5),-
		SB$Q_SWINCARN(R4)
	BEQL	50$			; Branch if yes and exit
	;
	; There is an existing CSB with a different software incarnation.
	; Get rid of it and fail over that node (perahps for the second time!)
	;
	STATE_DISP	<<NEW,40$>,<DEAD,30$>,<WAIT,20$>,<RECONNECT,10$>>
	BUG_CHECK	CNXMGRERR,FATAL	; Temporary Bugcheck

10$:	MOVB	#CSB$K_DEAD,-		; Set state=DEAD
		CSB$B_STATE(R5)
	BRB	30$			; Branch to allocate new block

20$:	MOVB	#CSB$K_DEAD,-		; Set state=DEAD
		CSB$B_STATE(R5)
	BSBB	DEAD_NODE		; Handle dead node
30$:	MOVL	R4,R1			; SB address
	BSBB	CNX$CREATE_CSB		; Create new CSB
	BRB	60$			; Return with status

40$:	MOVQ	SB$Q_SWINCARN(R4), -	; Update software incarnation and
		CSB$Q_SWINCARN(R5)	;   continue
50$:	MOVZWL	S^#SS$_NORMAL,R0	; Found CSB, in R5
60$:	POPR	#^M<R2,R3,R4>		; Restore nonvolatile registers
	RSB

	.SBTTL	CNX$CREATE_CSB - Create a new CSB given a SB address
;++
; FUNCTIONAL DESCRIPTION:
;
;	CNX$CREATE_CSB creates a CSB with matching System ID and
;		software incarnation number given an SB address.
;	It is assumed that no similar CSB already exists.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CREATE_CSB
;
; INPUT PARAMETERS:
;
;	R1	Address of SB
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R5 is address of CSB
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 contains status
;
; SIDE EFFECTS:
;	R1 is destroyed
;
;--

CNX$CREATE_CSB::			; Lookup given SB address
	PUSHR	#^M<R2,R3,R4,R6,R7>	; Save registers
	MOVL	R1,R7			; SB address
	MOVZWL	#CSB$K_LENGTH,R1	; Size of CSB
	BSBW	CNX$ALLOZMEM		; Allocate and zero memory
	BLBS	R0,10$			; Branch if successful
	BRW	50$			; Exit, status in R0

10$:	MOVL	R2,R6			; CSB address
	MOVL	R6,SB$L_CSB(R7)		; Update SB to point to newest CSB
	MOVB	#DYN$C_CLU_CSB,-	; Store subtype
		CSB$B_SUBTYPE(R6)
	MOVAL	CSB$L_SENTQFL(R6),-	; Initialize sent list
		CSB$L_SENTQBL(R6)
	CLRL	CSB$L_SENTQFL(R6)
	MOVAL	CSB$L_RESENDQFL(R6),-	; Initialize resend list
		CSB$L_RESENDQBL(R6)
	CLRL	CSB$L_RESENDQFL(R6)
	MOVL	#1,CSB$L_CURRCDRP(R6)	; Block critical section in SEND_MSG
	MOVAB	CSB$L_WARMCDRPQFL(R6),-	; Initialize warm CDRP queue
		CSB$L_WARMCDRPQFL(R6)
	MOVAB	CSB$L_WARMCDRPQFL(R6),-
		CSB$L_WARMCDRPQBL(R6)

	; Store remote side's software incarnation number and system id.
	; so that if this connection breaks and another is established, 
	; we can determine if it's the same system and software
	; incarnation at the other end.

	MOVQ	SB$Q_SWINCARN(R7),-	; Store software incarnation number
		CSB$Q_SWINCARN(R6)
	MOVB	#CSB$K_NEW,-		; Set state to NEW
		CSB$B_STATE(R6)		;
	MOVAL	CSB$L_PARTNERQFL(R6), -	; Initialize block transfer 
		CSB$L_PARTNERQFL(R6)	; partners queue.
	MOVAL	CSB$L_PARTNERQFL(R6), -
		CSB$L_PARTNERQBL(R6)
	MOVQ	G^EXE$GQ_SYSTIME, -	; Stamp reference time in CSB
		CSB$Q_REFTIME(R6)
	MOVL	G^CLU$GL_CLUB, -	; Address of CLUB
		CSB$L_CLUB(R6)
	MOVB	#1,CSB$B_REF_CNT(R6)	; Initialize reference count
	MOVL	R7,CSB$L_SB(R6)		; Address of SB
	MOVAB	CSB$B_CNCT(R6),R0	; Connect data block
	MOVB	I^#0,CNCT$B_ECOLVL(R0)	; ECO level, set for easy patching
	MOVB	#CNCT$K_PROTOCOL, -	; Protocol level
		CNCT$B_VERNUM(R0)
	MOVB	#CNCT$K_INITIAL, -	; Initial connect
		CNCT$B_TYPE(R0)
	MOVB	#SEND_CREDITS-1, -	; Unacknowledged message limit is
		CNCT$B_ACKLIM(R0)	;   send credits - 1.
	ASSUME	CLUB$L_CSBQFL EQ 0
	ASSUME	CSB$L_SYSQFL EQ 0
	MOVL	CSB$L_CLUB(R6),R5	; Get address of CSB queue header
20$:	MOVL	CSB$L_SYSQFL(R5),R5	; Get address of next CSB
	CMPL	R5,CSB$L_CLUB(R6)	; Reached end of list?
	BEQL	30$			; Yes
	MOVL	CSB$L_SB(R5),R0		; This CSB's SB address
	CMPC3	#SB$S_SYSTEMID, -	; Compare system IDs
		SB$B_SYSTEMID(R7), -
		SB$B_SYSTEMID(R0)
	BGTR	20$			; Branch if no match
30$:	INSQUE	CSB$L_SYSQFL(R6), -
		@CSB$L_SYSQBL(R5)
	MOVL	R6,R5			; Set up result register
	CMPL	R7,#SCS$GA_LOCALSB	; Is this the local SB?
	BEQL	40$			; Skip message output
					;  because we are at IPL 31!
	MOVAB	CSB_MSG,R0		; Address of new CSB message
	BSBW	CNX$CONFIG_CHANGE	; Log CSB creation
40$:	MOVZWL	S^#SS$_NORMAL,R0	; Found CSB, in R5
50$:	POPR	#^M<R2,R3,R4,R6,R7>	; Restore nonvolatile registers
	RSB

	.SBTTL	DISPATCH - Dispatch on CSB state
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine dispatches based upon the CSB state
;	using a table assembled in-line at the call site.
;	The STATE_DISP macro defines and builds the table.
;
; INPUT PARAMETERS:
;
;	(SP)	First byte of dispatch table
;	R5	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	All registers preserved.
;--

DISPATCH::
	PUSHR	#^M<R0,R1>		; Save R0 and R1
	MOVL	8(SP),R0		; Fetch table address
10$:	MOVZBL	(R0)+,R1		; Fetch state code
	BEQL	30$			; End of table
	CMPB	R1,CSB$B_STATE(R5)	; Match?
	BEQL	20$			; Branch on match
	ADDL2	#2,R0			; Bump over word offset
	BRB	10$

20$:	CVTWL	(R0)+,R1		; Fetch word offset
30$:	ADDL3	R0,R1,8(SP)		; Store return address
	POPR	#^M<R0,R1>		; Restore registers
	RSB


	.END
