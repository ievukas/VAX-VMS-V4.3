MODULE MAIL$SET( %TITLE 'VAX/VMS MAIL UTILITY SET COMMAND'
		IDENT = 'V04-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	SET command handling.
!
! AUTHOR:	Benn Schreiber,	5-Dec-1982
!
! MODIFIED BY:
!
!	V03-010	BLS0255		Benn Schreiber		28-Dec-1983
!		New global flags
!
!	V03-009	BLS0246		Benn Schreiber		 8-Nov-1983
!		Rework for new VMSMAIL.DAT handling, move new mail
!		count to VMSMAIL.
!
!	V03-008	BLS0229		Benn Schreiber		29-Jul-1983
!		Add SET NOMAIL_DIRECTORY command
!
!	V03-007	BLS0225		Benn Schreiber		17-Jun-1983
!		Minimize window of confusion in SET MAIL_DIRECTORY.  Enforce
!		restriction that personal name must start with alphabetic
!		character (informal personal name spec agreement with
!		RSX and ARPA-interface mail developers).
!
!	V03-006	BLS0222		Benn Schreiber		 7-May-1983
!		Disallow setting the wastebasket folder to MAIL or NEWMAIL
!
!	V03-005	BLS0220		Benn Schreiber		30-Apr-1983
!		Add SET MAIL_DIRECTORY,SET AUTO_PURGE
!
!	V03-004	BLS0217		Benn Schreiber		12-Apr-1983
!		Add SET COPY_SELF
!
!	V03-003	BLS0211		Benn Schreiber		13-Mar-1983
!		New commands for ISAM mail files
!
!	V03-002	BLS0202		Benn Schreiber		 5-Jan-1982
!		Check strings for illegal length/characters
!--

!
! Declarations
!
LIBRARY	'SYS$LIBRARY:LIB';
REQUIRE	'SRC$:MAILREQ';
LIBRARY 'LIB$:MAILDEF';

OWN
	COMMAND_DESC: DYN_DESC_DECL,
	DYN_DESC: DYN_DESC_DECL,
	DYN_DESC_2: DYN_DESC_DECL;

EXTERNAL
	MAIL$T_RD_RAB : $BBLOCK,		!MAIL file RAB
	MAIL$GL_FLAGS : $BBLOCK,		!Control flags
	MAIL$SD_MAIL : $BBLOCK,			!Descriptor of 'MAIL'
	MAIL$SD_NEWMAIL : $BBLOCK,		! and 'NEWMAIL'
	MAIL$SD_SETF1: $BBLOCK,			!Descriptor for set cmd prompt
	MAIL$SD_SETN1: $BBLOCK,
	MAIL$SD_USER: $BBLOCK,			!Descriptor for USER
	MAIL$Q_RD_DESC : $BBLOCK,		!Current mail file descriptor
	MAIL$T_UAF_BUFF : REF $BBLOCK,		!UAF buffer
	MAIL$Q_USERDEF : $BBLOCK,		!dev/dir for mail files
	MAIL$Q_MAILDEF : $BBLOCK,		! above + 'mail.mai'
	MAIL$Q_WASTEDESC : $BBLOCK,		!Descriptor for waste folder
	MAIL$Q_USERNAME: $BBLOCK,		!Descriptor for username
	MAIL$Q_FULLUSER: $BBLOCK,		! and for full name
	MAIL$T_SYSMAIRAB: $BBLOCK,		!RAB for VMSMAIL.DAT
	MAIL$L_MYUIC,				!UIC of person running MAIL
	MAIL$L_USRSYSBUF: REF $BBLOCK,		!User's vmsmail record
	MAIL$L_SYSMAIBUF: REF $BBLOCK;		!Pointer to buffer

EXTERNAL ROUTINE
	CLI$GET_VALUE: ADDRESSING_MODE(GENERAL),!Get value from CLI
	CLI$PRESENT: ADDRESSING_MODE(GENERAL),	!Test qualifier present
	LIB$CREATE_DIR,				!Create a directory
	LIB$RENAME_FILE,			!Rename files
	MAIL$GETLK_SYSMAI_REC,			!Read and lock VMSMAIL record
	MAIL$MOVE_WASTEBASKET,			!Move contents of wastebasketa
	MAIL$OPEN_IF,				!Open file if not open
	MAIL$UPCASE_Q,				!Cvt to upper case, honor quotes
	MAIL$UPDATE_INFO_REC,			!Update mail file info rec
	MAIL$UPDATE_SYSMAI_REC,			!Update VMSMAIL record
	STR$APPEND,				!Append a string
	STR$CONCAT: ADDRESSING_MODE(GENERAL),	!Concatenate strings
	STR$COPY_DX: ADDRESSING_MODE(GENERAL),	!Copy string
	STR$FREE1_DX: ADDRESSING_MODE(GENERAL),	!Free dynamic string
	MAIL$GET_USER,				!Get user uaf record
	MAIL$OPEN_FILE,				!Open a mail file
	MAIL$FORW_PRIV_CHECK,			!See if SYSNAM privilege
	UTIL$GETFILENAME,			!Get file spec from FAB
	UTIL$REPORT_IO_ERROR;			!Report I/O error
!
! Declare names for string descriptors
!
GLOBAL BIND
	MAIL$Q_MAIL_MAI = $DESCRIPTOR('MAIL.MAI') : $BBLOCK;

SD(
    'FILE',
    'LOG',
    'NOSEND',
    'NOREPLY',
    'SEND',
    'REPLY',
    'WASTENAME');
!
! Define shared messages
!
$SHR_MSGDEF(MAIL,126,LOCAL,
		(DIRNOTCRE,ERROR),
		(EXISTS,INFO),
		(RENAMED,INFO),
		(CREATED,INFO),
		(PARSEFAIL,ERROR),
		(SEARCHFAIL,ERROR),
		(WRITEERR,WARNING));
LITERAL
	PRO_SYS		= $BITPOSITION(XAB$V_SYS),
	PRO_OWN		= $BITPOSITION(XAB$V_OWN),
	PRO_GRP		= $BITPOSITION(XAB$V_GRP),
	PRO_WLD		= $BITPOSITION(XAB$V_WLD),
	
	DIR_PRO		= 			! Directory file protection
(				  		 XAB$M_NODEL) ^ PRO_SYS OR
(				  		 XAB$M_NODEL) ^ PRO_OWN OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_GRP OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_WLD;

GLOBAL ROUTINE MAIL$STRIP_QUOTES(OUT_DESC,IN_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine strips double qoutes (if any) from the input string
!
! INPUTS:
!
!	IN_DESC = address of string descriptor for input string
!	OUT_DESC = address of string descriptor for output string
!
!--
BEGIN
MAP
    IN_DESC : REF $BBLOCK,
    OUT_DESC : REF $BBLOCK;

LOCAL
    DESC_1 : $BBLOCK[DSC$C_S_BLN],
    CHAR : BYTE;

LITERAL
    DOUBLE_QUOTE = %ASCII '"';

DESC_1[DSC$W_LENGTH] = .IN_DESC[DSC$W_LENGTH];
DESC_1[DSC$B_CLASS] = 0;
DESC_1[DSC$B_DTYPE] = 0;
DESC_1[DSC$A_POINTER] = .IN_DESC[DSC$A_POINTER];

IF .DESC_1[DSC$W_LENGTH] GTRU 0
THEN BEGIN
    CHAR = CH$RCHAR(.DESC_1[DSC$A_POINTER]);
    IF .DESC_1[DSC$W_LENGTH] GTR 1
	AND (.CHAR EQL DOUBLE_QUOTE)
	AND (.CHAR EQL CH$RCHAR(.DESC_1[DSC$A_POINTER]+
				.DESC_1[DSC$W_LENGTH] - 1))
    THEN BEGIN
	DESC_1[DSC$W_LENGTH] = .DESC_1[DSC$W_LENGTH] - 2;
	DESC_1[DSC$A_POINTER] = .DESC_1[DSC$A_POINTER] + 1;
	END;
    END;

RETURN STR$COPY_DX(.OUT_DESC,DESC_1)
END;

ROUTINE CHECK_STRING(DESC,MAXLENGTH) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Check a string for too long or illegal characters
!
! INPUTS:
!
!	DESC = Addr of string descriptor for string
!	MAXLENGTH = Max length allowable for string
!
! ROUTINE VALUE:
!
!	true if all ok, else error
!--
BEGIN

MAP
    DESC : REF $BBLOCK;

LOCAL
    CHAR : BYTE,
    PTR;

!
! Check length of string
!
IF .DESC[DSC$W_LENGTH] GTRU .MAXLENGTH
THEN BEGIN
    SIGNAL(MAIL$_NAMTOOBIG,1,.DESC);
    RETURN MAIL$_NAMTOOBIG
    END;
!
! Check for characters with high bit on or illegal character (less than
! a space, and not a tab)
!
PTR = .DESC[DSC$A_POINTER];
INCRU I FROM 1 TO .DESC[DSC$W_LENGTH]
DO IF ((CHAR = CH$RCHAR_A(PTR)) AND %X'80') NEQ 0
    OR ((.CHAR LSSU %C' ') AND (.CHAR NEQ %C'	'))
THEN BEGIN
    SIGNAL(MAIL$_ILLCHAR,3,.CHAR,.DESC[DSC$W_LENGTH],.DESC[DSC$A_POINTER]);
    RETURN MAIL$_ILLCHAR
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SET_FORWARD (DELETE_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to modify the forwarding address of a user.
!
! INPUTS:
!
!	DELETE_FLAG Present if SET NOFORWARD.  Parameter absent if SET FORWARD
!	MAIL$Q_USERNAME	Descriptor of username string
!
! IMPLICIT INPUTS:
!
!	MAIL$T_SYSMAIRAB RAB for I/O on SYS$SYSTEM:VMSMAIL.DAT
!
! OUTPUTS:
!
!	SYS$SYSTEM:VMSMAIL.DAT is created if it does not exist.  The user
!	record is modified, or added if it does not exist.
!
!--
BEGIN

BUILTIN
    NULLPARAMETER;

LOCAL
    NAMBUF : $BBLOCK[NAM$C_MAXRSS],
    DIRBUF : $BBLOCK[NAM$C_MAXRSS],
    TMPBUF : $BBLOCK[VMD_C_LENGTH + 3*NAM$C_MAXRSS],
    PTR,
    PROXY_FLAG,
    STATUS;

PROXY_FLAG = 0;				! Assume for self
IF NULLPARAMETER(1)
THEN BEGIN
    CLI$GET_VALUE(MAIL$SD_SETF1,COMMAND_DESC);	!Get forwarding address
    MAIL$STRIP_QUOTES(COMMAND_DESC,COMMAND_DESC);
    MAIL$UPCASE_Q(COMMAND_DESC);
    END
ELSE STR$FREE1_DX(COMMAND_DESC);	! Ensure 0 forwarding address

IF_ERR(CHECK_STRING(COMMAND_DESC,NAM$C_MAXRSS);,
	RETURN .STATUS);

IF NOT CLI$PRESENT(MAIL$SD_USER)	! If not /USER=, then do self
    THEN CH$MOVE(VMD_C_LENGTH+.MAIL$L_USRSYSBUF[VMD_B_FWDLNG]
		+.MAIL$L_USRSYSBUF[VMD_B_FNMLNG]
		+.MAIL$L_USRSYSBUF[VMD_B_DIRLNG],
		.MAIL$L_USRSYSBUF,TMPBUF)
ELSE BEGIN
    !
    ! Ensure user has SYSNAM in process privilege mask
    !
    IF NOT MAIL$FORW_PRIV_CHECK()
	THEN RETURN TRUE;

    PROXY_FLAG = CLI$GET_VALUE(MAIL$SD_USER,DYN_DESC);
    CH$COPY(.DYN_DESC[DSC$W_LENGTH],	! Copy name from /USER=
	.DYN_DESC[DSC$A_POINTER],' ',
	VMD_C_USERNAME,TMPBUF[VMD_T_USERNAME]);
    MAIL$T_SYSMAIRAB[RAB$L_KBF] = TMPBUF;	! Set to read the record
    MAIL$T_SYSMAIRAB[RAB$L_UBF] = TMPBUF;
    MAIL$T_SYSMAIRAB[RAB$V_NLK] = FALSE;
    IF NOT $GET(RAB=MAIL$T_SYSMAIRAB)		! If it doesn't exist, zero record
	THEN CH$FILL(0,VMD_C_LENGTH+NAM$C_MAXRSS-$BYTEOFFSET(VMD_W_FLAGS),
			TMPBUF[VMD_W_FLAGS]);
    END;
!
! If trying to forward to self, then set no forwarding
!
CH$MOVE(.TMPBUF[VMD_B_FNMLNG],			!Save full user name
	TMPBUF[VMD_T_FWDNAM]+.TMPBUF[VMD_B_FWDLNG],NAMBUF);
CH$MOVE(.TMPBUF[VMD_B_DIRLNG],			!Save mail dir spec
	TMPBUF[VMD_T_FWDNAM]+.TMPBUF[VMD_B_FWDLNG]+.TMPBUF[VMD_B_FNMLNG],
	DIRBUF);
IF NOT .PROXY_FLAG
    AND CH$EQL(VMD_C_USERNAME,TMPBUF[VMD_T_USERNAME],
	.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],' ')
    THEN TMPBUF[VMD_B_FWDLNG] = 0
    ELSE BEGIN
	CH$MOVE(.COMMAND_DESC[DSC$W_LENGTH],
		.COMMAND_DESC[DSC$A_POINTER],
			TMPBUF[VMD_T_FWDNAM]);
	TMPBUF[VMD_B_FWDLNG] = .COMMAND_DESC[DSC$W_LENGTH];
	END;
PTR = CH$MOVE(.TMPBUF[VMD_B_FNMLNG],NAMBUF,	!Restore full user name
		TMPBUF[VMD_T_FWDNAM]+.TMPBUF[VMD_B_FWDLNG]);
CH$MOVE(.TMPBUF[VMD_B_DIRLNG],DIRBUF,.PTR);
MAIL$UPDATE_SYSMAI_REC(TMPBUF);			!Update the record

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SET_NOFORWARD =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to turn off forwarding for a user
!
!--

RETURN MAIL$CMD_SET_FORWARD(1);

GLOBAL ROUTINE MAIL$CMD_SET_SELF =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the SET COPY_SELF command, which sets the commands on
!	which an automatic copy is sent to the sender.
!
!--
BEGIN
LOCAL
    DESC : VECTOR[2,LONG],
    STATUS;


IF MAIL$GETLK_SYSMAI_REC(MAIL$Q_USERNAME,DESC)
    THEN CH$MOVE(.DESC[0],.DESC[1],.MAIL$L_USRSYSBUF);

IF CLI$PRESENT(SD_SEND)
    THEN MAIL$L_USRSYSBUF[VMD_V_SELFSEND] = 1
    ELSE IF CLI$PRESENT(SD_NOSEND)
	THEN MAIL$L_USRSYSBUF[VMD_V_SELFSEND] = 0;
IF CLI$PRESENT(SD_REPLY)
    THEN MAIL$L_USRSYSBUF[VMD_V_SELFREPLY] = 1
    ELSE IF CLI$PRESENT(SD_NOREPLY)
	THEN MAIL$L_USRSYSBUF[VMD_V_SELFREPLY] = 0;

RETURN MAIL$UPDATE_SYSMAI_REC(.MAIL$L_USRSYSBUF)
END;

GLOBAL ROUTINE MAIL$SET_NAME (FULL_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine updates the string MAIL$Q_FULLUSER with the username
!	from MAIL$Q_USERNAME and the full name passed in FULL_DESC
!
! INPUTS:
!
!	FULL_DESC = address of descriptor of full name (without quotes)
!
! OUTPUTS:
!
!	MAIL$Q_FULLUSER updated
!--
BEGIN

MAP
	FULL_DESC : REF $BBLOCK;

BIND
	SPACE_DESC = $DESCRIPTOR(' '),
	QUOTE_DESC = $DESCRIPTOR('"');

IF .FULL_DESC[DSC$W_LENGTH] NEQ 0
    THEN RETURN STR$CONCAT(MAIL$Q_FULLUSER,MAIL$Q_USERNAME,
			SPACE_DESC,QUOTE_DESC,.FULL_DESC,QUOTE_DESC)
    ELSE RETURN STR$COPY_DX(MAIL$Q_FULLUSER,MAIL$Q_USERNAME)
END;

ROUTINE ALPHA_CHAR (CHAR) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Tests the character.  Returns true if A-Z or a-z, or $ or _, else error
!--
BEGIN
MAP
    CHAR : BYTE;

IF ((.CHAR GEQU %C'A') AND (.CHAR LEQU %C'Z'))
    OR ((.CHAR GEQU %C'a') AND (.CHAR LEQU %C'z'))
    OR (.CHAR EQL %C'$') OR (.CHAR EQL %C'_')
    THEN RETURN TRUE
    ELSE RETURN FALSE
END;

ROUTINE SET_NAME (NAME_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Set the full username for the SET PERSONAL_NAME command
!
!--
BEGIN

MAP
    NAME_DESC : REF $BBLOCK;

LOCAL
    DESC : VECTOR[2,LONG],
    DIRBUF : $BBLOCK[NAM$C_MAXRSS],
    TMPBUF : $BBLOCK[VMD_C_LENGTH + 3*NAM$C_MAXRSS],
    PTR : REF VECTOR[,BYTE],
    STATUS;

MAIL$STRIP_QUOTES(.NAME_DESC,.NAME_DESC);

IF_ERR(CHECK_STRING(.NAME_DESC,127);,
	RETURN .STATUS);

IF .NAME_DESC[DSC$W_LENGTH] GTRU 0
THEN BEGIN
    PTR = .NAME_DESC[DSC$A_POINTER];
    IF NOT ALPHA_CHAR(.PTR[0])
	OR NOT CH$FAIL(CH$FIND_SUB(.NAME_DESC[DSC$W_LENGTH],
			.NAME_DESC[DSC$A_POINTER],2,UPLIT('  ')))
	THEN RETURN SIGNAL(MAIL$_ILLPERNAM,1,.NAME_DESC);
    END;
MAIL$SET_NAME(.NAME_DESC);		! Set new full name

MAIL$GETLK_SYSMAI_REC(MAIL$Q_USERNAME,DESC);
CH$MOVE(.DESC[0],.DESC[1],.MAIL$L_USRSYSBUF);
CH$MOVE(.MAIL$L_USRSYSBUF[VMD_B_DIRLNG],
	MAIL$L_USRSYSBUF[VMD_T_FWDNAM]+.MAIL$L_USRSYSBUF[VMD_B_FWDLNG]+
	.MAIL$L_USRSYSBUF[VMD_B_FNMLNG],DIRBUF);
PTR = MAIL$L_USRSYSBUF[VMD_T_FWDNAM] + .MAIL$L_USRSYSBUF[VMD_B_FWDLNG];
MAIL$L_USRSYSBUF[VMD_B_FNMLNG] = .NAME_DESC[DSC$W_LENGTH];
PTR = CH$MOVE(.NAME_DESC[DSC$W_LENGTH],.NAME_DESC[DSC$A_POINTER],PTR[0]);
CH$MOVE(.MAIL$L_USRSYSBUF[VMD_B_DIRLNG],DIRBUF,PTR[0]);

RETURN MAIL$UPDATE_SYSMAI_REC(.MAIL$L_USRSYSBUF)
END;

GLOBAL ROUTINE MAIL$CMD_SET_NAME =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the SET PERSONAL_NAME command
!--
BEGIN

CLI$GET_VALUE(MAIL$SD_SETN1,COMMAND_DESC);!Get full username
IF .COMMAND_DESC[DSC$W_LENGTH] EQL 0
    THEN RETURN TRUE;

RETURN SET_NAME(COMMAND_DESC)
END;

GLOBAL ROUTINE MAIL$CMD_CLEAR_NAME =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the SET NOPERSONAL_NAME command (clear the personal name)
!
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG];

DESC[0] = 0;
DESC[1] = DESC[0];		!Point to valid address
RETURN SET_NAME(DESC)
END;

GLOBAL ROUTINE MAIL$CMD_SET_AUTO =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Do the SET AUTO_PURGE command
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG];

IF_ERR(MAIL$GETLK_SYSMAI_REC(MAIL$Q_USERNAME,DESC);,
	RETURN TRUE);
CH$MOVE(.DESC[0],.DESC[1],.MAIL$L_USRSYSBUF);
MAIL$L_USRSYSBUF[VMD_V_NOAUTOPURGE] = 0;
RETURN MAIL$UPDATE_SYSMAI_REC(.MAIL$L_USRSYSBUF)
END;

GLOBAL ROUTINE MAIL$CMD_SET_NOAUTO =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Do the SET AUTO_PURGE command
!--
BEGIN
LOCAL
    DESC : VECTOR[2,LONG];

IF_ERR(MAIL$GETLK_SYSMAI_REC(MAIL$Q_USERNAME,DESC);,
	RETURN TRUE);
CH$MOVE(.DESC[0],.DESC[1],.MAIL$L_USRSYSBUF);

MAIL$L_USRSYSBUF[VMD_V_NOAUTOPURGE] = 1;

RETURN MAIL$UPDATE_SYSMAI_REC(.MAIL$L_USRSYSBUF)
END;

GLOBAL ROUTINE MAIL$CMD_SET_WASTE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the SET WASTEBASKET_FOLDER command
!--
BEGIN

LOCAL
    RECDESC : VECTOR[2,LONG],
    RECBUF : $BBLOCK[$BYTEOFFSET(MFR_T_DATA)+MFR_S_FILEKEY+1];

BIND
    RECORD_TYPE = RECBUF[MFR_Q_DATIM] : VECTOR[,LONG],
    WASTENAME = RECBUF[MFR_T_DATA] : VECTOR[,BYTE];

CLI$GET_VALUE(SD_WASTENAME,COMMAND_DESC);
IF .COMMAND_DESC[DSC$W_LENGTH] EQL 0
    THEN RETURN TRUE;

IF_ERR(MAIL$OPEN_IF();,
	RETURN TRUE);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN RETURN SIGNAL(MAIL$_NOTISAM);

IF CH$EQL(.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],
		.MAIL$SD_MAIL[DSC$W_LENGTH],.MAIL$SD_MAIL[DSC$A_POINTER])
    OR CH$EQL(.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],
		.MAIL$SD_NEWMAIL[DSC$W_LENGTH],.MAIL$SD_NEWMAIL[DSC$A_POINTER])
    THEN RETURN SIGNAL(MAIL$_ILLFOLNAM,1,COMMAND_DESC);

CH$FILL(0,$BYTEOFFSET(MFR_T_DATA),RECBUF);
RECORD_TYPE[0] = MFR_C_WASTENAME;
WASTENAME[0] = .COMMAND_DESC[DSC$W_LENGTH];
CH$MOVE(.COMMAND_DESC[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],
		WASTENAME[1]);

RECDESC[0] = $BYTEOFFSET(MFR_T_DATA) + .COMMAND_DESC[DSC$W_LENGTH] + 1;
RECDESC[1] = RECBUF;
IF MAIL$UPDATE_INFO_REC(MAIL$T_RD_RAB,RECDESC)
THEN BEGIN
    !
    ! Copy anything in old wastebasket folder to new wastebasket folder
    !
    MAIL$MOVE_WASTEBASKET(COMMAND_DESC);
    STR$COPY_DX(MAIL$Q_WASTEDESC,COMMAND_DESC);
    END;
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SET_FILE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	process the SET FILE command
!
!--
BEGIN
CLI$GET_VALUE(SD_FILE,COMMAND_DESC);

MAIL$OPEN_FILE(COMMAND_DESC);
RETURN TRUE
END;

ROUTINE RENAME_SUCCESS (OLD_SPEC,NEW_SPEC,LOG_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by LIB$RENAME_FILE on a successful RENAME
!--
BEGIN

MAP
    OLD_SPEC : REF $BBLOCK;

IF CH$EQL(.OLD_SPEC[DSC$W_LENGTH],.OLD_SPEC[DSC$A_POINTER],
		.MAIL$Q_RD_DESC[DSC$W_LENGTH],.MAIL$Q_RD_DESC[DSC$A_POINTER])
    THEN STR$COPY_DX(MAIL$Q_RD_DESC,.NEW_SPEC);

IF .LOG_FLAG
    THEN SIGNAL(MAIL$_RENAMED,2,.OLD_SPEC,.NEW_SPEC);

RETURN TRUE
END;

ROUTINE RENAME_ERROR (OLD_SPEC,NEW_SPEC,RMSSTS,RMSSTV,ERROR_SOURCE,LOG_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Error routine called by LIB$RENAME_FILE on an error
!--
BEGIN
MAP
    RMSSTS : REF VECTOR[,LONG],
    RMSSTV : REF VECTOR[,LONG];

CASE .ERROR_SOURCE FROM 0 TO 2
OF SET

[0] :					!Error searching for old_file
    IF .RMSSTS[0] EQL RMS$_FNF
	THEN RETURN TRUE
	ELSE SIGNAL(MAIL$_SEARCHFAIL,1,.OLD_SPEC,
				.RMSSTS[0],.RMSSTV[0]);

[1,2] :					!Error parsing new file
    SIGNAL(MAIL$_SEARCHFAIL,1,.NEW_SPEC,.RMSSTS[0],.RMSSTV[0]);
TES;

RETURN FALSE				!Force LIB$RENAME_FILE to terminate
END;

ROUTINE SET_NEW_DIR (SUB_DESC, FULL_DESC, LOG_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Rename MAIL.MAI into the new directory.  Then update
!	VMSMAIL.DAT to have the new subdirectory spec.  Then rename
!	the rest of the .MAI files
!
! Inputs:
!
!	SUB_DESC = address of descriptor of subdir ([.MAIL])
!	FULL_DESC = address of descriptor of full subdir name (d:[user.mail])
!	LOG_FLAG = true to /log, false otherwise
!
!--
BEGIN

MAP
    SUB_DESC : REF $BBLOCK,
    FULL_DESC : REF $BBLOCK;

LOCAL
    DESC : VECTOR[2,LONG];
!
! Rename MAIL.MAI;* to the new directory
!
STR$CONCAT(DYN_DESC,MAIL$Q_MAIL_MAI,$DESCRIPTOR(';*'));
IF_ERR(LIB$RENAME_FILE(DYN_DESC,.FULL_DESC,MAIL$Q_USERDEF,0,0,
				RENAME_SUCCESS,RENAME_ERROR,0,.LOG_FLAG);,
		RETURN TRUE);

!
!  Update record in VMSMAIL.  If an error occurs, rename MAIL.MAI;* to
! the old directory.
!
IF_ERR(MAIL$GETLK_SYSMAI_REC(MAIL$Q_USERNAME,DESC);,
	LIB$RENAME_FILE(DYN_DESC,MAIL$Q_USERDEF,.FULL_DESC,0,0,
			RENAME_SUCCESS,RENAME_ERROR,0,1); !always log
	RETURN TRUE);
CH$MOVE(.DESC[0],.DESC[1],.MAIL$L_USRSYSBUF);
CH$MOVE(.SUB_DESC[DSC$W_LENGTH],.SUB_DESC[DSC$A_POINTER],
	MAIL$L_USRSYSBUF[VMD_T_FWDNAM]+.MAIL$L_USRSYSBUF[VMD_B_FWDLNG]+
	.MAIL$L_USRSYSBUF[VMD_B_FNMLNG]);
MAIL$L_USRSYSBUF[VMD_B_DIRLNG] = .SUB_DESC[DSC$W_LENGTH];

IF_ERR(MAIL$UPDATE_SYSMAI_REC(.MAIL$L_USRSYSBUF);,
	LIB$RENAME_FILE(DYN_DESC,MAIL$Q_USERDEF,.FULL_DESC,0,0,
			RENAME_SUCCESS,RENAME_ERROR,0,1); !always log
	RETURN TRUE);

!
! Finally rename the rest of the mail files to the new directory
!
LIB$RENAME_FILE($DESCRIPTOR('*.MAI;*'),.FULL_DESC,MAIL$Q_USERDEF,0,0,
				RENAME_SUCCESS,RENAME_ERROR,0,.LOG_FLAG);
!
! Set up the strings containing the mail file directory spec and the
! default mail file spec.
!
STR$COPY_DX(MAIL$Q_USERDEF,.FULL_DESC);
STR$CONCAT(MAIL$Q_MAILDEF,.FULL_DESC,MAIL$Q_MAIL_MAI);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SET_DIR =
!++
! FUNCTIONAL DESCRIPTION:
!
!	The SET MAIL_DIRECTORY command specifies where MAIL should put
!	all its .MAI and .MSG files.
!
!--
BEGIN

BIND
    SUB_STRING = DYN_DESC[DSC$A_POINTER] : REF VECTOR[,BYTE];

LOCAL
    TMPBUF : VECTOR[NAM$C_MAXRSS,BYTE],
    PTR,
    STATUS,
    LOG_FLAG,
    DESC : VECTOR[2,LONG],
    END_CHAR : REF VECTOR[,BYTE];

IF_ERR(CLI$GET_VALUE(SD_FILE,COMMAND_DESC);,
	RETURN TRUE);

IF .COMMAND_DESC[DSC$W_LENGTH] EQL 0
    THEN RETURN TRUE;

IF_ERR(CHECK_STRING(COMMAND_DESC,NAM$C_MAXRSS);,
	RETURN TRUE);

LOG_FLAG = CLI$PRESENT(SD_LOG);
!
! Syntax check that the parameter is indeed a sub-directory name
!
STR$COPY_DX(DYN_DESC,COMMAND_DESC);
END_CHAR = SUB_STRING[.COMMAND_DESC[DSC$W_LENGTH]-1];
IF NOT CH$FAIL(CH$FIND_CH(.COMMAND_DESC[DSC$W_LENGTH],
				.COMMAND_DESC[DSC$A_POINTER],%C'-'))
    OR NOT CH$FAIL(CH$FIND_SUB(.COMMAND_DESC[DSC$W_LENGTH],
			.COMMAND_DESC[DSC$A_POINTER],2,UPLIT('..')))
    THEN RETURN SIGNAL(MAIL$_ILLSUBDIR,1,COMMAND_DESC);
IF ((.SUB_STRING[0] EQL %C'[')
    AND (.END_CHAR[0] NEQ %C']'))
    OR ((.SUB_STRING[0] EQL %C'<')
	AND (.END_CHAR[0] NEQ %C'>'))
    THEN RETURN SIGNAL(MAIL$_NOTSUBDIR,1,COMMAND_DESC);

IF (.SUB_STRING[0] EQL %C'[')
    THEN SUB_STRING[0] = %C'<';
IF (.END_CHAR[0] EQL %C']')
    THEN END_CHAR[0] = %C'>';
IF (.SUB_STRING[0] NEQ %C'<') OR (.SUB_STRING[1] NEQ %C'.')
    OR (.END_CHAR[0] NEQ %C'>')
    THEN RETURN SIGNAL(MAIL$_NOTSUBDIR,1,COMMAND_DESC);

IF_ERR(MAIL$GET_USER(MAIL$Q_USERNAME);,
	RETURN TRUE);

DESC[0] = .(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_COUNT>;
DESC[1] = (MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_STRING>;
STR$COPY_DX(DYN_DESC_2,DESC);
DESC[0] = .(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_COUNT>;
DESC[1] = (MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_STRING>;
STR$APPEND(DYN_DESC_2,DESC);

PTR = CH$MOVE(.DYN_DESC_2[DSC$W_LENGTH]-1,.DYN_DESC_2[DSC$A_POINTER],TMPBUF);
PTR = CH$MOVE(.DYN_DESC[DSC$W_LENGTH]-1,.DYN_DESC[DSC$A_POINTER]+1,.PTR);

DESC[0] = .PTR - TMPBUF;
DESC[1] = TMPBUF;
END_CHAR = .DYN_DESC_2[DSC$W_LENGTH] + .DYN_DESC_2[DSC$A_POINTER]-1;
IF .END_CHAR[0] EQL %C']'
THEN BEGIN
    END_CHAR = .DESC[0] + .DESC[1] - 1;
    END_CHAR[0] = %C']';
    END;
!
! First create the directory.  Then, rename MAIL.MAI into that directory.
! If that fails, give up.  If that succeeds, then update VMSMAIL.DAT to
! contain the subdirectory.  After that, rename the rest of the *.mai
! files to the new directory.  By doing it this way, the time that the
! mail.mai file and vmsmail.dat are out of synch is minimized.  Note
! that errors on the rename of the rest of the files are not dealt with
! in a meaningful way.
!
IF NOT (STATUS = LIB$CREATE_DIR(DESC,MAIL$L_MYUIC,%REF(-1),%REF(DIR_PRO)))
    THEN RETURN SIGNAL(MAIL$_DIRNOTCRE,1,DESC,.STATUS)
    ELSE SIGNAL((IF .STATUS EQL SS$_CREATED
		THEN MAIL$_CREATED
		ELSE MAIL$_EXISTS),1,DESC);

IF_ERR(SET_NEW_DIR(COMMAND_DESC,DESC,.LOG_FLAG);,
	RETURN .STATUS);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SET_NODIR =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Cancel any SET MAIL_DIRECTORY setting.  Cause the mail directory
!	to be SYS$LOGIN:
!
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG],
    LOGIN_DESC : VECTOR[2,LONG],
    LOG_FLAG;

!
! If no mail directory set, then there is nothing to do
!
IF .MAIL$L_USRSYSBUF[VMD_B_DIRLNG] EQL 0
    THEN RETURN TRUE;

LOG_FLAG = CLI$PRESENT(SD_LOG);

!
! Get uaf record and get descriptor for logindev:[logindir]
!
IF_ERR(MAIL$GET_USER(MAIL$Q_USERNAME);,
	RETURN TRUE);

DESC[0] = .(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_COUNT>;
DESC[1] = (MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_STRING>;
STR$COPY_DX(COMMAND_DESC,DESC);
DESC[0] = .(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_COUNT>;
DESC[1] = (MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_STRING>;
STR$APPEND(COMMAND_DESC,DESC);
DESC[0] = 0;
DESC[1] = DESC[0];

!
! Rename all the mail files to the login directory.  
! Note that if the login directory doesn't exist, this command won't create it.
!
SET_NEW_DIR(DESC,COMMAND_DESC,.LOG_FLAG);

RETURN TRUE
END;

END
ELUDOM
