	.title	pli$$bytesize
	.ident	/1-002/					; Edit WHM1002

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;

;++
; facility:
;
;	VAX/VMS PL1 runtime library
;
; abstract:
;
;	This module contains the pl1 runtime routine that determines the
;	byte size of an operand to be read, written or rewritten.
;
; author:
;	c. spitz 10-sep-79
;
; modified:
;
;
;	1-002	Bill Matthews	29-September-1982
;
;		Invoke macros $defdat and rtshare instead of $defopr and share.
;
;--

;
; external definitions
;

	$defdat				;define pl1 operand node data types

;
; local data
;

	rtshare				;sharable

	.page
;++
; pli$$bytesize -- determine byte size of an operand
;
; functional description:
;
;	This routine determines the size in bytes of an operand, based upon
;	the size field generated by the compiler and the operands data type.
;
; inputs:
;	(ap) - number of arguments (1)
;	4(ap) - word containing the size of the operand
;	6(ap) - word containing the data type of the operand
;
; outputs:
;	r0 - contains 1 or pli$_invdatyp&^c1
;	r1 - contains the length in bytes of the operand
;--


	.entry	pli$$bytesize,^m<r2,r3>
	movl	#1,r0			;assume success
	movzwl	4(ap),r2		;get size of operand
	movzwl	6(ap),r3		;get data type of operand
	case	type=b,r3, -		;case on the data type
		<10$, -			;undefined
		90$, -			;picture
		20$, -			;fixed binary 
		50$, -			;float binary
		80$, -			;fixed decimal
		110$, -			;float decimal
		10$, -			;complex fixed binary
		10$, -			;complex float binary
		10$, -			;complex fixed decimal
		10$, -			;complex float decimal
		90$, -			;character
		90$, -			;character varying
		10$, -			;bit
		10$, -			;bit varying
		100$, -			;bit aligned
		10$, -			;fixed 
		10$, -			;offset
		90$, -			;area
		10$, -			;file
		10$, -			;label
		10$, -			;entry
		10$, -			;format
		10$, -			;dope vector
		90$, -			;structure
		10$, -			;built in function
		10$, -			;condition
		10$, -			;generic
		90$>			;array
10$:    cmpl	#<dat_k_structure+64>,r3 ;bit sized structure?
	beql	100$			;if eql, yes, cont
	movl	#pli$_invdatyp,r0	;if invalid data type then set data
	bicl	#7,r0			;clr status
	bisl	#4,r0			;set fatal error
	ret				;type error and return
20$:	movl	#1,r1			;assume it fits in 1 byte
	bbc	#4,r2,40$		;if precision > 15 then
	movl	#4,r1			;set length of 4 bytes
30$:	ret				;return
40$:	bbc	#3,r2,30$		;if precision > 7  then
	movl	#2,r1			;set length of 2 bytes
	ret				;return
50$:	movl	#4,r1			;for float bin, assume single precision
	cmpl	r2,#53			;if precision > 53
	bleq	70$			;then
	movl	#16,r1			;set 16 bytes	
60$:	ret				;and return
70$:	cmpl	r2,#24			;if precision > 24
	bleq	60$			;then
	movl	#8,r1			;set 8 bytes
	ret				;and return
80$:	movzbl	r2,r2			;ignore scale
	ashl	#-1,r2,r2		;divide number of decimal digits by 2
	incl	r2			;add 1
	movl	r2,r1			;set result
	ret				;and return
90$:	movl	r2,r1			;set result
	ret				;return
100$:	addl	#7,r2			;add 7 to number of bits
	ashl	#-3,r2,r1		;divide by 8
	ret				;and return
110$:	movl	#4,r1			;for flt dec, assume single prec
	cmpl	r2,#7			;prec > 7?
	bgtr	130$			;if gtr, yes, cont
120$:	ret				;return
130$:	movl	#8,r1			;assume double prec
	cmpl	r2,#15			;prec > 15?
	bleq	120$			;if leq, no, it's double
	movl	#16,r1			;set quad prec
	ret				;return
140$:
	.end
