	.TITLE	VMSRT - VMS PROTOCOL WITH CTERM HOOKS
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
;
; FACILITY:
;
; 	SET HOST, aka RTPAD
;
; ABSTRACT:
;
; 	This module handles all of the VMS specific remote terminal
;	protocol. It also contains hooks for the CTERM protocol.
;
; ENVIRONMENT:	VMS user mode
;
;--
;
; AUTHOR: Jake VanNoy, CREATION DATE: 14-Jan-1982
; ORIGINAL AUTHOR: W M Cardoza
;
; MODIFIED BY:
;
;	V03-008	JLV0364		Jake VanNoy		11-JUL-1984
;		Add code to skip $SETIMR in ^Y routine if SETIMR
;		already pending.
;		Fix broken branch due to change in QUIT.
;
;	V03-007	MHB0135		Mark Bramhall		10-Apr-1984
;		Fix register conventions when calling VMS_INDREAD.
;
;	V03-006	JLV0331		Jake VanNoy		28-FEB-1984
;		Integrate trace facility into permanent code.
;		Add secondary status to REM-F-NETMBX failure to
;		show why link was blown away.
;
;	V03-005	JLV0325		Jake VanNoy		10-JAN-1984
;		Add terminator in fake IOSB generated by VMS_INDREAD.
;
;	V03-004	JLV0296		Jake VanNoy		28-JUL-1983
;		add OUTBANDABO channel.
;
;	V03-003	JLV0266		Jake VanNoy		26-MAY-1983
;		Restore code to prevent purge typeahead on "Username:"
;
;	V03-002	MHB0092		Mark Bramhall		 3-Mar-1983
;		Moved MAXMSG to $RTPADDEF.
;
;	V03-001	JLV0		Jake VanNoy		14-Jan-1983
;		Module created from VMS protocol code previously
;		held in RTPAD module. Hook for CTERM were included.
;
;**

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$DVIDEF
	$RDPDEF
	$RTPADDEF
	$TSADEF

;
; EQUATED SYMBOLS:
;
ASSEM_TRACE = 1			; INCLUDE TRACE CODE

AST$T_BUF = CTP$B_PRO_MSGTYPE ; ***

;
;	OP CODES
;
	OP_READ	= 1
	OP_WRITE = 2
	OP_SETMODE = 3
	OP_SENSEMODE = 4
	OP_CANCEL = 5
	OP_BRDCST = 6
	OP_PRMPT = ^X100

.PAGE
.PSECT	RTPAD,NOWRT

	.SBTTL VMSRT - START UP VMS TO VMS PROTOCOL
;++
; FUNCTIONAL DESCRIPTION:
;
;	PERFORMS INITIALIZATION FUNCTIONS FOR VMS TO VMS PROTOCOL
;
; CALLING SEQUENCE:
;
;	CALLS	#0,VMSRT
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	CHANNEL NUMBERS, ETC.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	SETS UP MAILBOX READS FOR LINK, UNSOLICITED TERMINAL INPUT
;	ENABLES ^C, ^Y  AST'S
;
;--
;

.ENTRY	VMSRT,	^M<R2,R3>

	TSTW	FINALACS		;
	BEQL	10$			; Branch if no access control string
	$PUTMSG_S MSGVEC = ACSIGNORE	; Warn him we are ignoring it
10$:
	;
	; Assume CTERM BIND ACCEPT message
	;
	MOVAB	CT_BIND_ACC_MSG,R0	; Address of buffer (BIND ACCEPT)
	MOVZWL	#CT_BIND_MSGLEN,R1	; Length of message

	BLBS	CTERM_FLAG,25$		; Branch if cterm
;
; *** WHAT USES THIS TERMUNIT GARBAGE??? NOTE CODE IS BUGGY...
;
	MOVAB	DEVNAM,R0		;ADDRESS OF COUNTED STRING
	MOVW	1(R0),TERMUNIT+2	;USE PART OF DEV NAME AS HIGH UNIT
	ADDL2	DEVNAMLEN,R0		;GET TO LAST CHAR (CONTROLLER)
	SUBB3	#^A/A/,(R0),R1		;GET CONTROLLER NUMBER
	MOVZBL	R1,R1
	ASHL	#4,R1,R1
	ADDW2	R1,TERMUNIT		;ADD CONTROLLER NUMBER TO UNIT
	;
	; VAX config (BIND) message
	;
	MOVAB	W^CHAR_BLOCK,R0		; Characteristics
	MOVAB	W^CONFIG_CHAR,R1	; CONFIG characteristics
	MOVQ	(R0)+,(R1)+		;  first 8 bytes
	MOVL	(R0)+,(R1)+		;  last four bytes

	MOVAB	CONFIG_MSG,R0		; Address of buffer
	MOVZWL	#CONFIG_MSGLEN,R1	; Length of message
	TSTB	PROTO_ECO		; Eco is 0 for 8 bytes of char
	BNEQ	25$			; Long form of charateristics?
	SUBL	#4,R1			; No, old form had 8 bytes of char
	;
	; Send BIND ACCEPT back to HOST
	;
25$:
	MOVAB	AST$T_BUF(R0),R2	; Address of message
	BSBW	WRITE_TO_NET_SYNC	; Write message to NET
	;
	; Read from NET mailbox
	;
	MOVAB	W^LINKMAIL,R0		; Address of data area
	$QIO_S	CHAN = MAILCHAN	-	; Link mailbox read
		FUNC = #IO$_READVBLK -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AST$T_BUF(R0) -
		P2 = #40
	ONERROR	QUIT			; Die if error
	;
	; Read from associated terminal mailbox
	;
	BLBS	CTERM_FLAG,30$		; Branch if CTERM
	CALLS	#0,W^UNSMSGDONE		; Call read routine
	BRB	40$			; Branch
30$:
	CALLS	#0,W^CTERM_UNSMSGDONE	; Call read routine
40$:

	;
	; Set up ^Y and assign channels needed for out of band processing
	;
	$QIO_S	CHAN = CNTRLCHAN -		;WE WILL ALWAYS HANDLE ^Y
		FUNC = #IO$_SETMODE!IO$M_CTRLYAST -
		P1 = CNTRLC_AST -
		P2 = #IO$M_CTRLYAST

	$ASSIGN_S -			;CHANNEL FOR INCLUDE OUT OF BAND AST'S
		DEVNAM = TTYDESC, -
		CHAN = OUTBANDINC

	$ASSIGN_S -			;CHANNEL FOR EXCLUDE OUT OF BAND AST'S
		DEVNAM = TTYDESC, -
		CHAN = OUTBANDEXC

	$ASSIGN_S -			;CHANNEL FOR ABORT OUT OF BAND AST'S
		DEVNAM = TTYDESC, -
		CHAN = OUTBANDABO

	BLBC	CTERM_FLAG,99$		; Branch if not CTERM
	$ASSIGN_S -
		DEVNAM = TTYDESC, -
		CHAN = CTRLO_CHAN	; ^O channel

	$QIOW_S	CHAN=CTRLO_CHAN,-
		FUNC=#IO$_SETMODE!IO$M_OUTBAND!IO$M_INCLUDE,-
		P1=  CTERM_CTRLO_AST,-
		P2=  #CTRLO_MASK

99$:
	BSBW	GETBUF			; Get a buffer for reading link
	MOVAB	LINKRECV,(R0)		; Insert state
	$QIO_S	CHAN = LINKCHAN -
		FUNC = #IO$_READVBLK -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AST$T_BUF(R0) -
		P2 = #MAXMSG
	ONERROR	QUIT			; 
;
; The following pice of code was formerly done before reads to net were done
; This caused disconects sent as a result of driver not found to be lost
;
	MOVW	TERMUNIT,INIT_MSG+4+RDP$W_UNIT+AST$T_BUF
	;
	; Check for CTERM protocol. Note that the VAX protocol now
	; sends what is interpretted as an unsolicted data message
	; which in turn starts up a process on the other end.
	; The CTERM protocol module first expects to read and respond
	; with INIT messages before proceeding to the unsolicted
	; data message.
	;
	BLBS	CTERM_FLAG,100$		; branch if VAX
	MOVAB	INIT_MSG,R0		; Assume VAX protocol
	MOVL	#INIT_MSGLEN,R1		; Length of message
	MOVAB	AST$T_BUF(R0),R2	; Address of buffer
	BSBW	WRITE_TO_NET_SYNC	; Write message to NET
100$:
	RET				; 
	.PAGE
	.SBTTL ASTHANDLER - DISPATCH AST'S
;++
; FUNCTIONAL DESCRIPTION:
;	
;	CALLS THE APPROPRIATE AST HANDLING ROUTINE
;
; CALLING SEQUENCE:
;
;	AST
;
; INPUT PARAMETERS:
;
;	THE AST PARAMETER IS A POINTER TO THE ADDRESS OF THE AST HANDLING 
;	ROUTINE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
ASTHANDLER::
	.WORD 	0
	MOVL 	4(AP),R0		; GET AST PARAMETER
	CALLS	#0,@(R0)		; CALL SERVICE ROUTINE
	RET
	.PAGE
	.SBTTL PROCMSG - PROCESS A LINK MESSAGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	ACT ON A QIO REQUEST PREVIOUSLY RECEIVED ON THE LINK
;
; CALLING SEQUENCE:
;
;	CALLS	#0,PROCMSG
;
; INPUT PARAMETERS:
;
;	R0 IS A POINTER TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	READQIO
;	WRITEQIO
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	READQIO
;	WRITEQIO
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A QIO TO THE TERMINAL MAY BE PERFORMED.
;
;--
;
PROCMSG:
	.WORD	^M<R2,R3,R4,R5,R6,R7>

; CTERM module calls CTERM_PROCMSG directly

	MOVZWL	AST$W_OPCODE(R0),R7	; Fetch internal opcode

	BISW2	AST$T_BUF+RDP$W_MOD(R0),-
		AST$T_BUF+RDP$W_OPCODE(R0)	;ADD OP MOD
	MOVL 	R0,R6
	;
	; Case instruction uses a byte, note that prompt flag
	; is in second byte.
	;
	CASEB	R7,#OP_READ,#OP_SENSEMODE
4$:	 .WORD	READMSG-4$
	 .WORD	WRITEMSG-4$
	 .WORD	SETMSG-4$
	 .WORD	SENSEMSG-4$
	RET
;
; A READ QIO REQUEST
READMSG:
	MOVAB	QIODONE,AST$L_STATE(R0)	;NEW STATE
	MOVZWL  AST$T_BUF+RDP$W_OPCODE(R0),R2

; *** Note that the following two instructions are obsolete in a roundabout
; sort of way. LOGINOUT is now smart enough (in V4) to not do a purge typeahead
; to a remote terminal. Connections to a V3.x system will then have the
; type ahead purged. 

	BICW	FIRST_READ, R2		; Don't purge type ahead on first read
	CLRW	FIRST_READ		;  but only on the first read...

	MOVZWL  AST$T_BUF+RDP$L_TT_BCNT(R0),R6
	CLRL   	R4
	CLRL   	R5
	BITW 	#OP_PRMPT,R7  
	BEQL	10$
	MOVAB  	AST$T_BUF+RDP$T_TT_TERM+1(R0),R4	;TERM MSG SIZE ADDR+1
	MOVZBL 	-1(R4),R5	;TERM MSG SIZE
	ADDL2  	R5,R4	;PROMPT SIZE ADDRESS
	MOVZWL 	(R4)+,R5
10$:
	MOVZBL  AST$T_BUF+RDP$T_TT_TERM(R0),RTERMDES	;TERMINATION CHARS
	BNEQ	30$
; USE DEFAULT
	CLRL   	R1
	BRB	40$
30$:
	MOVAB  RTERMDES,R1
40$:
	MOVAB   AST$T_BUF+RDP$T_TT_TERM+1(R0),RTERMDES+4
	MOVL    AST$T_BUF+RDP$L_REFID(R0),READQIO
	TSTB	INDFLAG
	BNEQ	100$			; Branch if reading from a file
45$:
	MOVL	R0,R3			; Save in case error later
;
; Test for read verify
;
	BBC	#IO$V_EXTEND,-
		AST$T_BUF+RDP$W_OPCODE(R0),46$	; Branch if not read verify
	
	ADDL	R4,4(R4)		; relocate address
	ADDL	R4,12(R4)		; relocate address
	ADDL	R4,20(R4)		; relocate address
46$:
	$QIO_S	CHAN = READCHAN -
		FUNC = R2 -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AST$T_BUF+RDP$T_TT_RDATA+2(R0) -
		P2 = R6 -
		P3 = AST$T_BUF+RDP$L_TT_TIMOUT(R0) -
		P4 = R1 -
		P5 = R4 -
		P6 = R5
	IF_NO_QUOTA	QUIT
	BLBS	R0,47$			; branch if ok
	BRW	QIO_ERR			; Handle error
47$:
	BRW	PROCMSG_EXIT
	
	;
	; Read from a file, not the terminal
	;

100$:
	PUSHL	R1			; Save
	MOVAB	AST$T_BUF+RDP$T_TT_RDATA+2(R0),R1 
					; Address for input
	MOVL	R6,R3			; Size for input
	BSBW	VMS_INDREAD		; Try the indirect file
	POPL	R1			; Save
	BRW	45$			; If routine returns here,
					; RMS got EOF, must read from TTY.

;
; A WRITE QIO REQUEST
WRITEMSG:
	MOVAB  	QIODONE,AST$L_STATE(R0)	;NEW STATE
	MOVZWL 	AST$T_BUF+RDP$W_OPCODE(R0),R2
	MOVZWL 	AST$T_BUF+RDP$L_TT_BCNT(R0),R3
	MOVL   	AST$T_BUF+RDP$L_REFID(R0),WRITEQIO
	$QIO_S	CHAN = WRITECHAN -
		FUNC = R2 -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AST$T_BUF+RDP$T_TT_WDATA(R0) -
		P2 = R3 -
		P4 = AST$T_BUF+RDP$L_TT_CARCON(R0)
	IF_NO_QUOTA	QUIT
	BRW	PROCMSG_EXIT
;
; A SET MODE QIO REQUEST
SETMSG:
	BITW	#IO$M_OUTBAND,AST$T_BUF+RDP$W_OPCODE(R0)
	BNEQ	49$
	BRW	60$
; HANDLE AN OUT OF BAND AST REQUEST
49$:	MOVL	R0,R7			;SAVE R0
	MOVAB	AST$T_BUF+RDP$B_TT_OUTBAND(R0),R3	;START OF DATA (MASKS)
	CMPB	(R3),#4			;FOR NOW, IT MUST BE A SINGLE LONGWORD
	BEQL	51$
	BRW	OUTBAND_ERR
51$:	CMPL	1(R3),INCMASK+4
	BEQL	53$			;DON'T BOTHER WITH THE QIO
	MOVL	1(R3),INCMASK+4		;GET THE INCLUDE MASK
	$QIOW_S	CHAN = OUTBANDINC -
		FUNC = #IO$_SETMODE!IO$M_OUTBAND!IO$M_INCLUDE -
		P1 = OUTBANDAST -
		P2 = #INCMASK
53$:	CMPB	5(R3),#4		;AGAIN, A SINGLE LONGWORD
	BEQL	55$
	BRW	OUTBAND_ERR
55$:	CMPL	6(R3),EXCMASK+4
	BEQL	58$			;DON'T BOTHER WITH THE QIO
	MOVL	6(R3),EXCMASK+4		;EXCLUDE MASK
	$QIOW_S	CHAN = OUTBANDEXC -
		FUNC = #IO$_SETMODE!IO$M_OUTBAND -
		P1 = OUTBANDAST -
		P2 = #EXCMASK
58$:	MOVL	R7,R0			;RESTORE R0
	CALLS	#0,QIODONE
	BRW	PROCMSG_EXIT
60$:	BITW  	#IO$M_HANGUP,AST$T_BUF+RDP$W_OPCODE(R0)  
	BEQL	70$
; HANGUP IS TREATED A PROGRAM EXIT
	QUIT	#SS$_NORMAL
70$:
	MOVAB  	QIODONE,AST$L_STATE(R0) 	;NEW STATE
	MOVZWL 	AST$T_BUF+RDP$W_OPCODE(R0),R2
	MOVL   	AST$T_BUF+RDP$L_REFID(R0),READQIO
	BITW 	#IO$M_CTRLCAST,AST$T_BUF+RDP$W_OPCODE(R0)  
	BNEQ	72$
	BRW	80$
; CONTROL-C ENABLE OR DISABLE
72$:	TSTL	AST$T_BUF+RDP$L_TT_ASTPRM(R0)
	BEQL	75$		;DISABLE
	TSTB	CNTRCFLAG	;IS THERE ALREADY ONE ENABLED?
	BEQL	74$
	BRW	90$		;YES
74$:	INCB	CNTRCFLAG
	$QIO_S	CHAN = CNTRLCHAN -	;ENABLE
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = CNTRLC_AST -
		P2 = #IO$M_CTRLCAST
	IF_NO_QUOTA	QUIT
	BRW	PROCMSG_EXIT
75$:	$QIO_S	CHAN = CNTRLCHAN -	;DISABLE
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0
	CLRB	CNTRCFLAG	;NO ^C'S ENABLED
	BRW	PROCMSG_EXIT
80$:	BITW 	#IO$M_CTRLYAST,AST$T_BUF+RDP$W_OPCODE(R0)  
	BEQL	100$
; CONTROL-Y ENABLE OR DISABLE
90$:	MOVQ	#SS$_NORMAL,AST$Q_IOSB(R0)		;PRETEND WE DID THE QIO
	$DCLAST_S ASTADR = ASTHANDLER -
		  ASTPRM = R0
	BRW	PROCMSG_EXIT
100$:
	MOVL	R0,R3			;WE NEED THE BUFFER ADDRESS LATER
	MOVL	#8,R4			;ASSUME SHORT FORM
	MOVQ	AST$T_BUF+RDP$Q_TT_CHAR(R0),CHARBUF
	TSTB	PROTO_ECO		;IS IT LEVEL 0
	BEQL	105$
	ADDL	#4,R4			;LONG FORM
	MOVL	AST$T_BUF+RDP$L_TT_CHAR2(R0),CHARBUF+8
105$:	$QIO_S	CHAN = READCHAN -
		FUNC = R2 -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -	  
		P1 = CHARBUF -
		P2 = R4 -
		P3 = AST$T_BUF+RDP$L_TT_SPEED(R0) -
		P4 = AST$T_BUF+RDP$L_TT_FILL(R0) -
		P5 = AST$T_BUF+RDP$L_TT_PARITY(R0)
; TAKE CARE OF NOT ALWAYS GETTING AST ON ERROR
	BLBS	R0,PROCMSG_EXIT		;NO ERROR

QIO_ERR:
	MOVW	R0,AST$Q_IOSB(R3)	;MAKE SURE STATUS IS IN IOSB
	$DCLAST_S ASTADR = ASTHANDLER -
		  ASTPRM = R3
	BRB	PROCMSG_EXIT
;
; A SENSE MODE QIO REQUEST
SENSEMSG:
	MOVL	R0,R3			;WE NEED THE BUFFER ADDRESS LATER
	MOVAB	QIODONE,AST$L_STATE(R0)	;NEW STATE
	MOVZWL	AST$T_BUF+RDP$W_OPCODE(R0),R2
	MOVL	AST$T_BUF+RDP$L_REFID(R0),READQIO
	CLRQ	AST$T_BUF+RDP$Q_TT_SCHAR(R0)
	CLRL	AST$T_BUF+RDP$Q_TT_SCHAR+8(R0)
	$QIO_S	CHAN = READCHAN -
		FUNC = R2 -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AST$T_BUF+RDP$Q_TT_SCHAR(R0) -
		P2 = #12
; TAKE CARE OF NOT ALWAYS GETTING AST ON ERROR
	BLBS	R0,PROCMSG_EXIT		;NO ERROR
	MOVW	R0,AST$Q_IOSB(R3)	;MAKE SURE STATUS IS IN IOSB
	$DCLAST_S ASTADR = ASTHANDLER -
		  ASTPRM = R3
	BRB	PROCMSG_EXIT

PROCMSG_EXIT:
	RET

OUTBAND_ERR:
	$PUTMSG_S MSGVEC = BADOUTBAND
	QUIT

	.PAGE
	.SBTTL LINKRECV - PROCESS A RECEIVED MESSAGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	PROCESS THE AST INDICATING THAT A MESSAGE WAS RECEIVED ON THE LINK
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,LINKRECV
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	WRITEQIO
;	READQIO
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	AN ENTRY MAY BE ADDED TO THE QUEUE OF PENDING READS OR WRITES.
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A NEW READ OF THE LINK IS INITIATED.  IF THERE IS A ERROR ON THIS QIO,
;	A $WAKE IS ISSUED TO CAUSE A PROGRAM EXIT.
;
;	A PREVIOUS I/O MAY BE CANCELED
;
;--
;
.IF DF ASSEM_TRACE
TRACE_RECV:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	MOVZWL	AST$Q_IOSB+2(R0),R1
	MOVAB	AST$T_BUF(R0),R2
	MOVAB	DBG$LINKRECV,R3		; Message received from net
	BSBW	DBG$TRACE_IO		; ... log input
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	BRB	TRACE_CONTINUE
.ENDC

LINKRECV_ERR:
	MOVZWL	AST$Q_IOSB(R0),R2		;SAVE ERROR STATUS
	CMPW	R2,#SS$_ABORT
	BNEQ	20$
	MOVL	R2,LINKERR		;SAVE ERROR
	$SETIMR_S DAYTIM = THREESEC -	;JUST IN CASE MAILBOX DOESN'T GET REASON
		  ASTADR = LINKGONE
10$:	RET				;LINK BROKE - LINK MBX WILL GET REASON
20$:	TSTB	W^WAKEFLAG		; has QUIT already happened
	BNEQ	10$			; if so, ignore error
	$PUTMSG_S MSGVEC = DECNETERR	;LINK ERROR
	QUIT	R2

LINKRECV::
	.WORD	^M<R2,R3,R7>
	BLBC	AST$Q_IOSB(R0),LINKRECV_ERR	;ERROR ON LINK READ ??

.IF DF ASSEM_TRACE
	BBC	#RTLOG$V_TRACE,-
		W^RTLOG_FLAGS,-
		TRACE_CONTINUE		; branch if not tracing
	BRW	TRACE_RECV		; branch if tracing
TRACE_CONTINUE:
.ENDC
	BLBC	CTERM_FLAG,20$
	BSBW	CTERM_LINKRECV
	BRW	100$
20$:
	MOVZWL	AST$T_BUF+RDP$W_OPCODE(R0),R1
	CLRL	R7
	MOVAB	TERMOPS,R2
	MOVZWL	(R2)+,R3		;COUNT
30$:	CMPW	R1,(R2)
	BNEQ	40$
	MOVZWL	2(R2),R7		;INTERNAL OP CODE
	BRB	50$
40$:	ADDL2	#4,R2			;SKIP
	SOBGTR	R3,30$
50$:
	MOVW	R7,AST$W_OPCODE(R0)	; Save for later
	CMPB	R7,#OP_BRDCST
	BNEQ	60$
	JSB	BROADCAST		;GO BROADCAST IT
	BRB	100$
60$:	CMPB	R7,#OP_CANCEL
	BNEQ	70$
	JSB	CANCELIO		;GO CANCEL IT
	BRB	100$
70$:	CMPB 	R7,#OP_WRITE  
	BNEQ	90$
; A WRITE QIO
	TSTL WRITEQIO
	BNEQ	80$
; NO WRITE IN PROGRESS
	CALLS 	#0,PROCMSG
	BRB	100$
80$:
	INSQUE  (R0),@WRITEQ+4	;QUEUE IT
	BRB	100$
90$:
; A READ OR SETMODE OR SENSEMODE
	TSTL READQIO 
	BNEQ	95$
; NO READ IN PROGRESS
	CALLS 	#0,PROCMSG
	BRB	100$
95$:
	INSQUE  (R0),@READQ+4	;QUEUE IT
100$:
	BSBW	GETBUF		;GET A BUFFER FOR READING LINK
	MOVAB	LINKRECV,(R0)
	$QIO_S	CHAN = LINKCHAN -	;READ LINK AGAIN
		FUNC = #IO$_READVBLK -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AST$T_BUF(R0) -
		P2 = #MAXMSG
	BLBS	R0,110$			;WAS THERE A LINK ERROR
	MOVL	R0,LINKERR		;SAVE ERROR
	$SETIMR_S DAYTIM = THREESEC -	;JUST IN CASE MAILBOX DOESN'T GET REASON
		  ASTADR = LINKGONE
110$:	RET
;
;
;
; CANCEL AN I/O
;
CANCELIO:
	MOVL	R0,R2
	$CANCEL_S CHAN = CNTRLCHAN	;DISABLE ^C ON A CANCEL
	CLRB	CNTRCFLAG		;NO CONTROL-C'S ENABLED
	MOVL	R2,R0
	CMPL 	AST$T_BUF+RDP$L_REFID(R0),READQIO
	BNEQ	20$
; CANCEL THE READ
	JSB	BUFFREE
	$CANCEL_S  CHAN = READCHAN
	RSB
20$:	CMPL 	AST$T_BUF+RDP$L_REFID(R0),WRITEQIO
	BNEQ	30$
; CANCEL THE WRITE
	JSB	BUFFREE
	$CANCEL_S  CHAN = WRITECHAN
	RSB
30$:
	MOVAB	READQ,R1	;GET QUEUE OF PENDING READS
31$:	MOVAB	(R1),R1
	CMPL	R1,#READQ
	BEQL	32$		;END OF QUEUE
	CMPL	AST$T_BUF+RDP$L_REFID(R1),-
		AST$T_BUF+RDP$L_REFID(R0)
	BNEQ	31$		;TRY THE NEXT ONE
	BRB	39$		;GO CANCEL IT
32$:	MOVAB	WRITEQ,R1	;GET QUEUE OF PENDING WRITES
33$:	MOVL	(R1),R1
	CMPL	R1,#WRITEQ
	BEQL	34$		;END OF QUEUE
	CMPL	AST$T_BUF+RDP$L_REFID(R1),-
		AST$T_BUF+RDP$L_REFID(R0)
	BNEQ	33$		;TRY THE NEXT ONE
	BRB	39$		;SAVE THE CANCEL - WRITE NOT DONE YET
34$:	JSB 	BUFFREE		;QIO ALREADY DONE - THROW OUT THE CANCEL
	RSB
39$:
	REMQUE	(R1),R1	;REMOVE THE ENTRY
	MOVL	AST$T_BUF+RDP$L_REFID(R1),CANMSG+RDP$L_REFID
	JSB	BUFFREE	;WE DON'T NEED THE CANCEL ANYMORE
	MOVL	R1,R0
	JSB	BUFFREE		;WE DON'T NEED THE QIO EITHER
	$QIO_S	CHAN = LINKCHAN -	;SEND THE CANCEL COMPLETE MSG
		FUNC = #IO$_WRITEVBLK -
		P1 = CANMSG -
		P2 = #RDP$K_HEADERLEN+8
	ONERROR	QUIT
	RSB
;
;
;
; BROADCAST TO THE TERMINAL
;
BROADCAST:
	MOVL 	AST$T_BUF+RDP$L_TT_BCNT(R0),BRDDESC	;COUNT
	MOVAB	AST$T_BUF+RDP$T_TT_WDATA(R0),BRDDESC+4	;ADDRESS
	CMPW	@BRDDESC+4,#^XA0D		;CHECK FOR CR-LF
	BNEQ	10$
	CLRW	@BRDDESC+4			;REMOVE IT - BRDCST ADDS ANOTHER ONE
10$:	MOVL	R0,R2
	$BRDCST_S MSGBUF = BRDDESC -
		  DEVNAM = TTYDESC
	MOVQ	R0,AST$T_BUF+RDP$Q_STATUS(R2)	;RETURN AN IOSB
	MOVAB	LNKWRTDONE,AST$L_STATE(R2)		;NEW STATE
	MOVW	#RDP$C_END,AST$T_BUF+RDP$W_OPCODE(R2)	;A STATUS MESSAGE
	CLRW	AST$T_BUF+RDP$W_MOD(R2)
	$QIO_S	CHAN = LINKCHAN -	;WRITE MESSAGE ON LINK
		FUNC = #IO$_WRITEVBLK -
		IOSB = AST$Q_IOSB(R2) -
		ASTADR = ASTHANDLER -
		ASTPRM = R2 -
		P1 = AST$T_BUF(R2) -
		P2 = #RDP$K_HEADERLEN+8
	ONERROR	QUIT
	RSB
	.PAGE
	.SBTTL QIODONE - PROCESS A COMPLETED TERMINAL QIO
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST INDICATING THAT A TERMINAL QIO HAS COMPLETED
;
; CALLING SEQUENCE:
;
;	CALLS	#0,QIODONE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A STATUS MESSAGE IS WRITTEN TO THE LINK.  IF THERE IS AN ERROR ON THIS
;	QIO, A $WAKE IS ISSUED TO CAUSE THE PROGRAM TO EXIT
;
;--
;
QIODONE::
	.WORD 	^M<R2,R3,R4,R5,R7>

	BLBC	CTERM_FLAG,10$
	BSBW	CTERM_QIODONE
	TSTL	R0			; Was a message returned?
	BNEQ	60$			; Branch if yes
	BRW	70$			; Exit if it not
10$:
	TSTL	AST$T_BUF+RDP$L_REFID(R0)		;CHECK FOR ZERO REF ID
	BNEQ	20$
	MOVZBL	#1,AST$Q_IOSB(R0)	;NO ERRORS
	CALLS	#0,LNKWRTDONE	;PRETEND WE SENT IT
	RET
20$:	
	MOVZWL	AST$W_OPCODE(R0),R7	; Fetch internal opcode
	CMPB 	R7,#OP_READ  
	BNEQ	30$
; IT WAS A READ SO WE NEED THE COUNT
	MOVZWL  AST$Q_IOSB+2(R0),R1 	;CHARACTERS BEFORE THE TERMINATOR
	ADDW2   AST$Q_IOSB+6(R0),R1	;TOTAL CHARACTERS
	MOVW	R1,AST$T_BUF+RDP$T_TT_RDATA(R0)	;SAVE IN LINK MESSAGE
	ADDW2   #2,R1			;SIZE OF READ DATA PLUS COUNT
	BRB	50$
30$:
	CMPB 	R7,#OP_WRITE
	BNEQ	40$
	CLRL	R1			;NO READ DATA
	BRB	50$
40$:
; SETMODE OR SENSEMODE
	CLRL	R1			;ASSUME NO DATA
	CMPB	R7,#OP_SETMODE
	BEQL	50$
	MOVL	#12,R1			;12 BYTES OF DATA
50$:	MOVW	#RDP$C_END,AST$T_BUF+RDP$W_OPCODE(R0)	;A STATUS MESSAGE
	CLRW	AST$T_BUF+RDP$W_MOD(R0)
	MOVQ	AST$Q_IOSB(R0),AST$T_BUF+RDP$Q_STATUS(R0)
	ADDW2	#RDP$T_TT_RDATA,R1
	MOVAB	AST$T_BUF(R0),R2		; SET ADDRESS OF WRITE MESSAGE
60$:
	BSBB	WRITE_TO_NETX
70$:
	RET

	.PAGE
	.SBTTL WRITE_TO_NET - WRITE TO LINK 
;
;
; INPUTS:	
;	R0 - AST BLOCK
;	R1 - length of message
;	R2 - address of message
;	R3 - AST routine to call (if called at WRITE_TO_NET)
;

WRITE_TO_NET_SYNC::	; R0,R1,R2 inputs

	PUSHL	R3			; Save R3
	CLRL	R3			; No AST
	PUSHL	R0			; Save block
	BSBB	WRITE_TO_NET		; Write to net
	$WAITFR_S EFN = #RT$C_LINKEFN	; Wait for completion
	ONERROR QUIT			; Failure?
	POPL	R0			; Restore AST block
	MOVZWL	AST$Q_IOSB(R0),R0	; Fetch status
	ONERROR QUIT			; Failure?
	POPL	R3			; Restore
	RSB				; Return

WRITE_TO_NETX::				; Standard completion routine
	MOVAB	LNKWRTDONE,AST$L_STATE(R0)	; New state
	MOVAB	ASTHANDLER,R3		; AST routine

WRITE_TO_NET::

.IF DF ASSEM_TRACE
	BBS	#RTLOG$V_TRACE,-
		W^RTLOG_FLAGS,TRACE_WRITE	; branch if tracing
TRACE_CONTINUE2:
.ENDC
	$QIO_S	CHAN = LINKCHAN	-	;WRITE MESSAGE ON LINK
		EFN  = #RT$C_LINKEFN,-
		FUNC = #IO$_WRITEVBLK -
		IOSB = AST$Q_IOSB(R0) -
		ASTADR = (R3) -
		ASTPRM = R0 -
		P1 = (R2) -
		P2 = R1
	ONERROR	QUIT
	RSB

.IF DF ASSEM_TRACE
TRACE_WRITE:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Trace code
	MOVAB	DBG$LINKWRITE,R3
	BSBW	DBG$TRACE_IO
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	BRB	TRACE_CONTINUE2
.ENDC
	.PAGE
	.SBTTL LNKWRTDONE - A WRITE TO THE LINK HAS COMPLETED
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST INDICATING THAT A WRITE HAS COMPLETED ON THE LINK 
;	BY FREEING THE BUFFER.
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,LNKWRTDONE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A BUFFER IS FREED
;	THE QUEUE OF PENDING QIO'S IS CHECKED
;
;--
;
LNKWRTDONE::
	.WORD	0
	BLBS	AST$Q_IOSB(R0),20$		;ERROR ON LINK WRITE ??
	MOVZWL	AST$Q_IOSB(R0),R2		;SAVE ERROR STATUS
	CMPW	R2,#SS$_ABORT
	BNEQ	10$
	RET				;LINK BROKE - LINK MBX WILL GET REASON
10$:	$PUTMSG_S MSGVEC = DECNETERR	;LINK ERROR
	QUIT	R2

	BLBC	CTERM_FLAG,20$
	BSBW	CTERM_LNKWRTDONE
	BRW	40$

20$:	MOVL	AST$T_BUF+RDP$L_REFID(R0),R3	;SAVE ID
	BSBW	BUFFREE		;RELEASE THE BUFFER
	CMPL	R3,READQIO	;WAS THIS A READ (OR SET MODE)
	BNEQ	30$		;NO
	CLRL	READQIO		;FORGET ABOUT THE PREVIOUS ONE
	REMQUE	@READQ,R0
	BVS	30$		;NO MORE
	CALLS	#0,PROCMSG	;GO PROCESS IT
	RET
30$:	CMPL	R3,WRITEQIO	;WAS THIS A WRITE
	BNEQ	40$		;NO
	CLRL	WRITEQIO	;FORGET ABOUT THE PREVIOUS ONE
	REMQUE	@WRITEQ,R0
	BVS	40$		;NO MORE
	CALLS	#0,PROCMSG	;GO PROCESS IT
40$:	RET
	.PAGE
	.SBTTL LNKMBXDONE - MESSAGE RECEIVED ON THE LINK MAILBOX
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST INDICATING THAT A MESSAGE WAS RECEIVED ON THE LINK 
;	MAILBOX
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,LNKMBXDONE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	THE PROGRAM CAN BE ABORTED.
;
;--
;
LNKMBXDONE:
	.WORD	^M<R2>
	;
	; First, check valid disconnects
	;
	MOVZWL	AST$T_BUF(R0),R2	; Fetch MSG code
	CMPW	R2,#MSG$_DISCON		; Disconnect?
	BEQL	10$			; Branch if yes
	CMPW	R2,#MSG$_EXIT		; Exit?
	BEQL	10$			; Branch if yes
	CMPW	R2,#MSG$_ABORT		; Log out - ignore it
	BNEQ	20$			; Not a valid shutdown message...
10$:	
	QUIT	#SS$_NORMAL		; Exit, no status message
	;
	; Either a serious error or something like a CONFIRM,
	; which isn't important.
	;
20$:	
	CMPW	R2,#MSG$_THIRDPARTY	; Third party disconnect?
	BNEQ	30$			; Branch if not
	QUIT	#SS$_THIRDPARTY		; Abort program
30$:
	CMPW	R2,#MSG$_PATHLOST	; Path lost?
	BNEQ	40$			; Branch if not
	QUIT	#SS$_PATHLOST		; Abort program
	;
	; Unimportant message, just requeue read
	;
40$:
	$QIO_S	CHAN = MAILCHAN	-	;LINK MAILBOX READ
		FUNC = #IO$_READVBLK -
		IOSB = LINKMAIL+AST$Q_IOSB -
		ASTADR = ASTHANDLER -
		ASTPRM = #LINKMAIL -
		P1 = LINKMAIL+AST$T_BUF -
		P2 = #40
	ONERROR QUIT
	RET
	.PAGE
	.SBTTL OUTBANDAST - OUT OF BAND CHARACTER AST RECEIVED
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLES THE AST RESULTING FROM AN OUT OF BAND CHARACTER
;
; CALLING SEQUENCE:
;
;	CALLS	#0,OUTBANDAST
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	AST PARAMETER - CHARACTER
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A MESSAGE SENT ON LINK
;
;--
;
OUTBANDAST:
	.WORD	0
	MOVB	4(AP),OUTBANDCHAR	;GET THE CHARACTER THAT CAUSED THE AST
	MOVW	#RDP$C_ATTN,OUTBANDMSG+RDP$W_OPCODE
	MOVW	#RDP$C_TT_OUTBAND,OUTBANDMSG+RDP$W_MOD
	MOVW	TERMUNIT,OUTBANDMSG+RDP$W_UNIT
	$QIO_S	CHAN = LINKCHAN -	;SEND ON LINK
		FUNC = #IO$_WRITEVBLK -
		P1 = OUTBANDMSG -
		P2 = #RDP$K_HEADERLEN+1
	ONERROR QUIT
	RET
	.PAGE
	.SBTTL LINKGONE - TIMER EXPIRED SO LINK IS GONE
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLES THE AST RESULTING FROM THE TIMER STARTED TO WAIT FOR THE 
;	  MAILBOX TO GET THE REASON WHY THE LINK IS GONE
;
; CALLING SEQUENCE:
;
;	CALLS	#0,LINKGONE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LAST LINK MAILBOX MESSAGE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A $WAKE WILL FORCE THE PROGRAM TO EXIT
;
;--
;
LINKGONE:
	.WORD	0
	MOVZWL	LINKMAIL+AST$T_BUF,MBXMSGTYP	;GET REASON FROM THE LAST MAILBOX MESSAGE
	$PUTMSG_S MSGVEC = MBXMSG		;OUTPUT MESSAGE TYPE
	QUIT
	.PAGE
	.SBTTL UNSDATMBX - MESSAGE IN TERMINAL MAILBOX
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLES THE AST RESULTING FROM UNSOLICITED TERMINAL DATA OR HANGUP
;
; CALLING SEQUENCE:
;
;	CALLS	#0,UNSDATMBX
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	UNSDAT
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A MESSAGE IS SENT ON THE LINK.  IF THIS QIO FAILS, A $WAKE FORCES THE
;	PROGRAM TO EXIT.
;
;--
;
UNSDATMBX: 
	.WORD	^M<R2,R3>

	MOVL	#RDP$K_HEADERLEN,R1	; Assume we send this much
	MOVAB	UNSDAT+AST$T_BUF,R2	; base address of RDP
	MOVZWL	RDP$K_HEADERLEN+2(R2),R3 ; Message code
	CMPW 	R3,#MSG$_TRMUNSOLIC	; Unsolicted data?
	BNEQ	10$			; Branch if not
	MOVW	#RDP$C_TT_UNSOL,-
		RDP$W_MOD(R2)		; Unsolicited data
	BRB	20$			; Back to common code
10$:
	CMPW 	R3,#MSG$_TRMBRDCST	; Broadcast message?
	BNEQ	18$			; branch if not

	MOVZWL	RDP$K_HEADERLEN+22(R2),R1 ; Length of broadcast
	ADDL2	#RDP$K_HEADERLEN+24,R1    ; Add rest + header
	MOVW	R1,RDP$K_HEADERLEN(R2)	  ; Save it in msg
	MOVW 	#RDP$C_TT_BRDCST, -
		RDP$W_MOD(R2)		; Broadcast
	BRB	20$
18$:
	CMPW 	R3,#MSG$_TRMHANGUP	; Hangup?
	BNEQ	UNSMSGDONE+2		; Ignore it
	MOVW 	#RDP$C_TT_HANGUP,-
		RDP$W_MOD(R2)		; Hangup
20$:
	MOVW	#RDP$C_ATTN,RDP$W_OPCODE(R2) ; message type
	MOVW	TERMUNIT,RDP$W_UNIT(R2)	; Term unit num *** ?

	MOVAB	W^UNSDAT,R0		; Address of AST block
	MOVAB	B^UNSMSGDONE,-
		AST$L_STATE(R0)		; Next state
	MOVAB	W^ASTHANDLER,R3		; Ast address
	BSBW	WRITE_TO_NET		; Write message
	RET

	.PAGE
	.SBTTL UNSMSGDONE - DO A NEW TERMINAL MAILBOX READ
;++
; FUNCTIONAL DESCRIPTION:
;
;	WHEN THE WRITE TO THE LINK COMPLETES,DO A NEW TERMINAL MAILBOX READ.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,UNSMSGDONE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	IF THE MAILBOX READ QIO FAILS, A $WAKE IS ISSUED TO CAUSE THE PROGRAM
;	TO EXIT
;
;--
;
UNSMSGDONE:
	.WORD	0
	MOVAB	UNSDATMBX,UNSDAT	;NEW STATE
	$QIO_S	CHAN = TERMMBXCHAN -	;SET UP UNSOLICITED DATA MBX READ
		FUNC = #IO$_READVBLK -
		IOSB = UNSDAT+AST$Q_IOSB -
		ASTADR = ASTHANDLER -
		ASTPRM = #UNSDAT -
		P1 = UNSDAT+AST$T_BUF+RDP$K_HEADERLEN+2 -
		P2 = #MAXMSG
	ONERROR	QUIT
	RET
	.PAGE
	.SBTTL CNTRLC_AST - CONTROL-C & CONTROL-Y
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST RESULTING FROM A CONTROL-C OR A CONTROL-Y
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,CNTRLC_AST
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	CNTRLYTIM
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	CNTRLYTIM
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A MESSAGE IS SENT ON THE LINK AND FOR ^Y THE AST IS REENABLED.
;	TWO QUICK (LESS THAN 3 SEC) ^Y'S WILL ABORT THIS PROGRAM.
;--
;
CNTRLC_AST::	.WORD	0
	MOVW	#RDP$C_ATTN,CNTRLCY+RDP$W_OPCODE
	CMPW	4(AP),#IO$M_CTRLCAST
	BNEQ	10$
	MOVW	#RDP$C_TT_CTRLC,CNTRLCY+RDP$W_MOD

	CLRB	CNTRCFLAG		; NO CONTROL-C ENABLES
	BRW	30$
10$:	CMPW	4(AP),#IO$M_CTRLYAST
	BEQL	20$
	QUIT	4(AP)			; PROBABLY A HANGUP
20$:	BSBW	CNTRLYTEST		; CHECK FOR RECENT ^Y
	$QIO_S	CHAN = CNTRLCHAN -	; RE-ENABLE IT
		FUNC = #IO$_SETMODE!IO$M_CTRLYAST -
		P1 = CNTRLC_AST -
		P2 = #IO$M_CTRLYAST

; WE WILL START TIMING WAITING FOR A SECOND ONE

	TSTB	CNTRLYTIM		; ONLY SET ONE TIMER AT A TIME
	BNEQ	25$			; SKIP IF TIMER ENABLED
	INCB	CNTRLYTIM		; INDICATE WE HAVE ONE ^Y
	$SETIMR_S DAYTIM = THREESEC -	; TIME THREE SECONDS
		  ASTADR = YTIMEDONE
25$:	MOVW	#RDP$C_TT_CTRLY,CNTRLCY+RDP$W_MOD
30$:
	MOVW	TERMUNIT,CNTRLCY+RDP$W_UNIT

	BLBC	CTERM_FLAG,40$		; Branch if VAX
	CALLG	(AP),W^CTERM_CTRL_CY	; Notify cterm module
	BRB	50$			; Exit

40$:	MOVAB	CNTRLCY_MSG,R0		; AST block 
	MOVL	#RDP$K_HEADERLEN,R1	; and length

	MOVAB	AST$T_BUF(R0),R2		; Address of message 
	CLRL	R3			; No ast
	BSBW	WRITE_TO_NET		; Write to net
50$:
	RET
;
;
; ^Y TIMER HAS EXPIRED
;
YTIMEDONE:
	.WORD	0
	CLRB	CNTRLYTIM	;NO RECENT ^Y
	RET
;
;
; ASK ABORT QUESTION IF THERE WAS A RECENT ^Y
;
CNTRLYTEST:
	TSTB	CNTRLYTIM
	BNEQ	10$
	RSB			;NO RECENT ^Y - CONTINUE
10$:	$GETMSG_S MSGID = #REM$_CNTRLY -
		MSGLEN = CNTRLYMSGBUF -
		BUFADR = CNTRLYMSGBUF -
		FLAGS = #1
	$FAO_S	CTRSTR = CNTRLYMSGBUF -
		OUTLEN = CNTRLYQUESLEN -
		OUTBUF = CNTRLYQUESBUF -
		P1 = #REMOTENODE
	$QIOW_S	CHAN = READCHAN -	;ASK ABOUT THE ^Y JUST TYPED
		EFN = #1 -
		FUNC = #IO$_READPROMPT!IO$M_CVTLOW -
		P1 = ANSBUF -
		P2 = #10 -
		P5 = #CNTRLYQUES -
		P6 = CNTRLYQUESLEN
	CMPB	ANSBUF,#^A/Y/		;DID HE SAY YES
	BEQL	20$
	RSB			;HE SAID NO - SO CONTINUE
; ABORT
20$:	QUIT	#SS$_NORMAL	;NO STATUS MESSAGE
	.PAGE
	.SBTTL VMS_INDREAD - READ INDIRECT COMMAND FILE
;++
; FUNCTIONAL DESCRIPTION:
;
;	READS FROM AN INDIRECT COMMAND FILE
;
; CALLING SEQUENCE:
;
;	JSB	VMS_INDREAD
;
; INPUT PARAMETERS:
;
;	R0 - AST Block
;	R1 - Address to put input data
;	R2 - QIO read modifiers (only IO$M_CVTLOW checked for)
;	R3 - Size of request in bytes
;
; IMPLICIT INPUTS:
;
;	SYSINRAB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	INDFLAG
;
; COMPLETION CODES:
;
; SIDE EFFECTS:
;
;	ON AN EOF, FURTHER READS FROM THE INDIRECT FILE ARE DISABLED.
;	THE PROGRAM WILL EXIT ON AN INDIRECT FILE READ.
;
;--
;
VMS_INDREAD::

	PUSHR	#^M<R0,R1,R6>
	MOVL	R1,SYSINRAB+RAB$L_UBF	; Data address
	MOVW	R3,SYSINRAB+RAB$W_USZ	; Requested size
	$GET	RAB = SYSINRAB		; Read a record
	CMPL	R0,#RMS$_NORMAL
	BNEQ	10$			; Problem
	POPR	#^M<R0,R1,R6>
	CLRQ	AST$Q_IOSB(R0)
	MOVZWL	SYSINRAB+RAB$W_RSZ,R1
	MOVW	SYSINRAB+RAB$W_RSZ,-
		AST$Q_IOSB+2(R0)	; Size of read
	ADDL	SYSINRAB+RAB$L_UBF,R1	; Find where to put terminator
	MOVB	#^X0D,(R1)	
	MOVB	#^X0D,AST$Q_IOSB+4(R0)	; Set <CR> as terminator
	MOVW	#1,AST$Q_IOSB+6(R0)	; Terminator size
	MOVW	#SS$_NORMAL,AST$Q_IOSB(R0)
	BITL	#IO$M_CVTLOW,R2
	BEQL	9$				;NO CASE CONVERSION
	MOVL	SYSINRAB+RAB$L_UBF,R6		;BUFFER ADDRESS
	MOVZWL	SYSINRAB+RAB$W_RSZ,R1		;CHARACTERS TO CHECK
5$:	CMPB	(R6),#^A/a/
	BLSS	8$				;NOT LOWER CASE
	CMPB	(R6),#^A/z/
	BGTR	8$				;NOT LOWER CASE
	SUBB	#^X20,(R6)			;MAKE IT UPPER CASE
8$:	INCL	R6				;NEXT
	SOBGTR	R1,5$
9$:	$DCLAST_S ASTADR = ASTHANDLER, -	;SIMULATE A COMPETION AST
		  ASTPRM = R0
	RET
10$:	CMPL	R0,#RMS$_EOF		;ARE WE JUST DONE WITH THE FILE
	BNEQ	20$			;REAL PROBLEM
	$CLOSE	FAB = SYSINFAB		;DON'T NEED IT
	CLRB	INDFLAG
	POPR	#^M<R0,R1,R6>
	RSB				;GO DO THE REAL QIO
20$:	QUIT
	.PAGE
	.SBTTL GETBUF - GET A BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	GET A FREE BUFFER OR ALLOCATE ONE IF THERE ARE NONE.
;
; CALLING SEQUENCE:
;
;	JSB 	GETBUF
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	BUFQUEUE
;
; OUTPUT PARAMETERS:
;
;	R0 POINTS TO THE BUFFER
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	MORE VIRTUAL MEMORY MAY BE ALLOCATED
;
;--
;
GETBUF::
	REMQUE	@BUFQUEUE,R0	;GET A BUFFER
	BVS	10$		; BRANCH IF NONE 
5$:
	RSB			; RETURN

; ALLOCATE A BUFFER

10$:	PUSHAB	BUFADR		;BUFFER ADDRESS WILL BE RETURNED HERE
	PUSHAB	BUFSIZE		;REQUESTED SIZE
	CALLS 	#2,G^LIB$GET_VM
	ONERROR	QUIT

.IF DF debug
	movab	gotvm,R0	; set message address
	bsbw	log_ascic	; log message
.endc
	MOVL	BUFADR,R0
	BRB	5$		; BRANCH TO EXIT

	.PAGE
	.SBTTL BUFFREE - FREE A BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	FREE A BUFFER.
;
; CALLING SEQUENCE:
;
;	JSB 	BUFFREE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO THE BUFFER
;
; IMPLICIT INPUTS:
;
;	BUFQUEUE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
BUFFREE:: 
	INSQUE 	(R0),BUFQUEUE		;PUT BUFFER IN FREE LIST
	RSB

.SBTTL	READ ONLY DATA

TERMOPS:   .WORD   <2$-1$>/4
1$:	   .WORD   IO$_READVBLK,OP_READ
	   .WORD   IO$_READLBLK,OP_READ
	   .WORD   IO$_READPBLK,OP_READ
	   .WORD   IO$_READPROMPT,OP_READ!OP_PRMPT
	   .WORD   IO$_TTYREADALL,OP_READ
	   .WORD   IO$_TTYREADPALL,OP_READ!OP_PRMPT
	   .WORD   IO$_WRITEVBLK,OP_WRITE
	   .WORD   IO$_WRITELBLK,OP_WRITE
	   .WORD   IO$_WRITEPBLK,OP_WRITE
	   .WORD   IO$_SETMODE,OP_SETMODE
	   .WORD   IO$_SETCHAR,OP_SETMODE
	   .WORD   IO$_SENSEMODE,OP_SENSEMODE
	   .WORD   IO$_SENSECHAR,OP_SENSEMODE
	   .WORD   IO$_ACPCONTROL,OP_CANCEL
	   .WORD   -1,OP_BRDCST
2$:

ACSIGNORE: .LONG  2,REM$_ACSIGN,0

BADOUTBAND: .LONG 2,REM$_BADOUTBAND,0

THREESEC:  .LONG  -10*1000*1000*3,-1		;THREE SECOND TIMER


	.SBTTL	READ WRITE DATA
	.PSECT	_RTPAD,LONG

CHARBUF:	.BLKB	12

OUTBANDINC::  .WORD  0		;OUT OF BAND (INCLUDE) AST CHANNEL
OUTBANDEXC::  .WORD  0		;OUT OF BAND (EXCLUDE) AST CHANNEL
OUTBANDABO::  .WORD  0		;OUT OF BAND (ABORT)   AST CHANNEL

CTRLO_CHAN:	.LONG	0	; CHANNEL FOR ^O OUT OF BANDS
CTRLO_MASK:	.LONG	0
		.LONG	1@<^A/O/-^A/@/>

RTERMDES:  .BLKL  2		;TERMINATOR CHARACTER DESCRIPTOR

BUFQUEUE:  .LONG  BUFQUEUE,BUFQUEUE	;EMPTY BUFFER QUEUE

BUFADR:	   .LONG  0		;THE ADDRESS OF AN ALLOCATED BUFFER GOES HERE

BUFSIZE:   .LONG  AST$T_BUF+MAXMSG	;BUFFER SIZE

LINKMAIL:	.LONG	LNKMBXDONE
		.BLKB	AST$T_BUF+40-4

.SBTTL	Protocol Message buffers

;
; BIND and configuration data message
;

CONFIG_MSG:	.BLKB	AST$T_BUF	;CONFIGURATION MESSAGE
CONFIG_MSG_ST:	.BYTE	1,1,1,0		; BIND,V1, ECO=1,customer ECO
		.WORD	7,4		; VMS, support mask
CONFIG_CHAR:
		.BLKL	3		; Characteristics buffer
CONFIG_MSGLEN = .-CONFIG_MSG_ST

;
; Unsolicited data message (init)
;

INIT_MSG:	.BLKB	AST$T_BUF
1$:		.WORD	RDP$C_ATTN
		.WORD	RDP$C_TT_UNSOL,0,0,0	; Fake unsolicited data
INIT_MSGLEN = .-1$

;
; CONTROL C or CONTROL Y (^C or ^Y) out of band message
;

CNTRLCY_MSG:	.BLKB	AST$T_BUF
CNTRLCY:	.BLKB  RDP$K_HEADERLEN	; LINK MESSAGE FOR CONTROL C OR Y
CNTRLCY_MSGLEN = .-CNTRLCY

UNSDAT::	.LONG  UNSDATMBX	; VMS AND CTERMRT ONLY???***
		.BLKB  AST$T_BUF+MAXMSG	; FOR UNSOLICITED DATA MAILBOX

;
; Out of band message
;

OUTBANDMSG: .BLKB  RDP$K_HEADERLEN
OUTBANDCHAR: .BYTE 0
;
; Cancel message 
;

CANMSG:	   .LONG  RDP$C_END,0
	   .WORD  0
	   .BLKQ  1
;
BRDDESC:   .BLKL  2		;DESCRIPTOR FOR BROADCASTS
;
MBXMSG:    	.LONG  4,REM$_NETMBX,1
MBXMSGTYP: 	.LONG  0
LINKERR:	.LONG	0
;
CNTRLYTIM: .BYTE  0		;RECENT ^Y INDICATOR
;
ANSBUF:    .BLKB  10		;RECEIVE ANSWER TO ^Y QUESTION
;
CNTRCFLAG:: .BYTE  0		;INDICATE CONTROL-C ENABLES

READQIO::  .LONG   0		;ID OF CURRENT READ REQUEST
;
WRITEQIO:: .LONG   0		;ID OF CURRENT WRITE REQUEST
;
READQ::	   .LONG   READQ,READQ	;QUEUE OF PENDING READS
;
WRITEQ::   .LONG   WRITEQ,WRITEQ	;QUEUE OF PENDING WRITES
;
REMOTENODE::	.BLKL	2		;REMOTE NODE NAME
;

;
INCMASK:   .BLKL  2		;OUT OF BAND INCLUDE MASK
EXCMASK:   .BLKL  2		;OUT OF BAND EXCLUDE MASK
;
FIRST_READ: .WORD IO$M_PURGE	; Don't purge type ahead (on the first read)
;
CNTRLYMSGBUF:
	.LONG	256,1$			;BUFFER TO HOLD CONTROL Y QUESTION (BEFORE FAO)
1$:	.BLKB	256
;
CNTRLYQUESLEN:
	.LONG	0			;FINAL LENGTH OF QUESTION
;
CNTRLYQUESBUF:
	.LONG	256,CNTRLYQUES		;BUFFER TO HOLD THE FINAL QUESTION
CNTRLYQUES:
	.BLKB	256

MAX_SENDSIZE::	.LONG	0		; Maximum network send size ***


.END	; of module VMSRT
