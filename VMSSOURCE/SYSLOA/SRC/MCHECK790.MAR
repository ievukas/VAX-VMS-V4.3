	.TITLE	MCHECK790 -- VENUS MACHINE CHECK
	.IDENT	'V04-004'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: SYSLOA790 - loadable CPU-dependent code
;
; ABSTRACT:
;	This module contains routines to handle VAX 11/790 specific
;	machine check errors.
;
; ENVIRONMENT:
;	IPL = 31	Mode = KERNEL
;
; AUTHOR:  Wayne Cardoza	CREATION DATE: 2-Oct-1982
;
; MODIFIED BY:
;
;	V04-004	WMC0020		Wayne Cardoza		13-Sep-1984
;		Make sure we never run with CRD interrupts disabled.
;
;	V04-003	WMC0019		Wayne Cardoza		12-Sep-1984
;		Fix position accounting in CRD log.
;
;	V04-002	TCM0002		Trudy C. Matthews	11-Sep-1984
;		Make CON$KEEPALIVE's reference to ERL$RELEASEMB absolute.
;
;	V04-001	WMC0018		Wayne Cardoza		05-Sep-1984
;		Add MSTAT2 to the CRD log.
;
;	V03-023	WMC0017		Wayne Cardoza		23-Aug-1984
;		Fix a bad index mode.
;
;	V03-022	WMC0016		Wayne Cardoza		14-Aug-1984
;		CP-IO BUF doesn't always have a cycle type.
;
;	V03-021	WMC0015		Wayne Cardoza		06-Aug-1984
;		And more changes.
;
;	V03-020	TCM0001		Trudy C. Matthews	31-Jul-1984
;		Add routine CON$KEEPALIVE, which is called periodically to
;		determine if the VENUS console software is still functioning.
;		Also, change the CRD interrupt vector from ^X64 in the SCB to
;		^X54.
;
;	V03-019	WMC0014		Wayne Cardoza		23-Jul-1984
;		Still more spec changes.
;
;	V03-018	WMC0013		Wayne Cardoza		12-Jul-1984
;		Many spec changes.
;
;	V03-017	WMC0012		Wayne Cardoza		15-May-1984
;		Space always reserved for SBIA error word.
;		Add PC-PSL to log message.
;
;	V03-016	WMC0011		Wayne Cardoza		30-Apr-1984
;		Add ADPDEF.
;
;	V03-015	WMC0010		Wayne Cardoza		16-Apr-1984
;		Ignore CP timeouts on BRVVR.
;
;	V03-014	RLRSBICONF	Robert L. Rappaport	22-Mar-1984
;		Test MMG$GL_SBICONF array elements for valid system
;		virtual address (high bit set) before using.  Also
;		correct bug introduced by CONFREGL fix.
;
;	V03-013	WMC0009		Wayne Cardoza		10-Mar-1984
;		Fix SBIA logging bugs.
;
;	V03-012	KPL0100		Peter Lieberwirth	26-Feb-1984
;		Use CONFREGL in lieu of CONFREG.
;
;	V03-011	WMC0008		Wayne Cardoza	29-Jan-1983
;		Clean up stack before bugcheck.
;
;	V03-010	WMC0007		Wayne Cardoza	01-Dec-1983
;		Turn CP-IO-BUF into NXM for EXE$MCHK_BUGCHK checks
;		MBOX doesn't always latch cycle type.
;
;	V03-009	WMC0006		Wayne Cardoza	20-Nov-1983
;		Fix transposed lines of code.
;
;	V03-008	TMK0001		Todd M. Katz		14-Nov-1983
;		Add a .TITLE so that the object file for this module
;		will be inserted into SYSLOA.OLB as MCHECK790 instead of
;		as .MAIN. 
;
;	V03-007	WMC0005		Wayne Cardoza	02-Nov-1983
;		Fix IOC$BROADCAST calls.
;		Get adaptor type from ABUS_TYPE.
;
;	V03-006	KDM0053		Kathleen D. Morse	11-Jul-1983
;		Replace cpu-specific IPR references with the cpu-specific
;		symbols, defined by $PR790DEF.
;
;	V03-005	WMC0004		Wayne Cardoza	06-Apr-1983
;		Changes to bad page handling.
;
;	V03-004	WMC0003		Wayne Cardoza	22-Mar-1983
;		Misc minor fixes.
;
;	V03-003	WMC0002		Wayne Cardoza	22-Feb-1983
;		Resource removed from service bit.
;		Spec changes in MSTAT1, MSTAT2, MDECC.
;
;	V03-002	WMC0001		Wayne Cardoza	10-Feb-1983
;		Add error logging routine for adapters.
;
;--

	.SBTTL	Declarations
;
; INCLUDE FILES:
;

;
; INCLUDED SYSTEM SYMBOL DEFINITIONS
;
	$ADPDEF
	$EMBDEF <MC,SE>
	$IPLDEF
	$PCBDEF
	$PFNDEF
	$PHDDEF
	$PRDEF
	$PR790DEF
	$PSLDEF
	$PTEDEF
	$RPBDEF
	$VADEF
	$MCF790DEF
	$MCHKDEF
	$MERGDEF
	$SBIADEF
	$CSWPDEF
	$PAMMDEF

;
; OWN STORAGE:
;

	.PSECT	MCHK$DATA,QUAD,WRT

EXE$MCHK_ERRCNT::			; Used to locate error counters
					; via SYS.MAP.

IBOX_OLD1:				; Time of most recent IBOX error
	.LONG	0
IBOX_OLD2:				; Second most recent
	.LONG	0
IBOX_TOTAL:				; Total errors
	.LONG	0
IBOX_THRESHOLD = 10			; Minimum time allowed for 3 IBOX errors 
					; (10 millisec units)

FBOX_OLD1:				; Time of most recent FBOX error
	.LONG	0
FBOX_OLD2:				; Second most recent
	.LONG	0
FBOX_TOTAL:				; Total errors
	.LONG	0
FBOX_THRESHOLD = 10			; Minimum time allowed for 3 FBOX errors 
					; (10 millisec units)

EBOX_OLD1:				; Time of most recent EBOX error
	.LONG	0
EBOX_OLD2:				; Second most recent
	.LONG	0
EBOX_TOTAL:				; Total errors
	.LONG	0
EBOX_THRESHOLD = 10			; Minimum time allowed for 3 EBOX errors 
					; (10 millisec units)

MBOX_FE_OLD:				; Time of most recent MBOX fatal error
	.LONG	0
MBOX_FE_PC:				; PC of most recent MBOX fatal error
	.LONG	0
MBOX_FE_TOTAL:				; Total errors
	.LONG	0
MBOX_FE_THRESHOLD = 2			; Minimum time allowed for 2 MBOX errors 
					; (10 millisec units)
MBOX_FE_PHY_ADR:			; Physical address of last MBOX address PE
	.LONG	0			; error

TB_OLD1:				; Time of last TB parity error.
	.LONG	0
TB_OLD2:				; Time of next-to-last TB error.
	.LONG	0
TB_TOTAL:				; Total errors
	.LONG	0
TB_THRESHOLD = 10			; Allowable time between TB errors
					; (in 10 millisecond units).

CSH_A_OLD1:				; Time of most recent A cache error
	.LONG	0
CSH_A_OLD2:				; Second most recent
	.LONG	0
CSH_B_OLD1:				; Time of most recent B cache error
	.LONG	0
CSH_B_OLD2:				; Second most recent
	.LONG	0
CACHE_TOTAL:				; Total errors
	.LONG	0
CACHE_THRESHOLD = 10			; Minimum time allowed for 3 cache errors 
					; (10 millisec units)

MBOX_1D_OLD1:				; Time of most recent MBOX 1D error
	.LONG	0
MBOX_1D_OLD2:				; Second most recent
	.LONG	0
MBOX_1D_TOTAL:				; Total errors
	.LONG	0
MBOX_1D_THRESHOLD = 10			; Minimum time allowed for 3 MBOX 1D errors 
					; (10 millisec units)

CRD_OLD1:				; Time of most recent single bit error
	.LONG	0
CRD_OLD2:				; Second most recent
	.LONG	0
CRD_TOTAL:				; Total errors
	.LONG	0
CRD_THRESHOLD = 100			; Minimum time allowed for 3 CRD errors 
					; (10 millisec units)

CRD_REENAB_TIME = 5 * 60		; 5 minute CRD disable time
CRD_TIMER:				; Time left to reenable CRD's
	.LONG	CRD_REENAB_TIME

EXE$AB_MEMERR::				; Memory error counters for adapter routines
	.BLKB	64			; One for each TR on each of 4 SBIA's

KEEPALIVE_TIME = 90			; 1 1/2 minute console keepalive check
KEEPALIVE_TIMER:			; Time left to check if console is alive
	.LONG	KEEPALIVE_TIME
TODR_VALUE:				; Check if console is updating this
	.LONG	0			; register

;
; This is a table that maps one bit for each opcode in the VAX
; instruction set.  If the corresponding bit is set, that opcode
; does only one read and may be safely restarted if a CP_IO BUF error occurs.
; The table does not take into account reads done for address calculations.
; These are assumed to not be relevant in deciding if I/O space was referenced.
; Queue, decimal, and string instructions are not assumed to be safe.
;
SBI_INST:
	.WORD	^B0011010000111111	;HALT,NOP,REI,RET,PROBER/W
	.WORD	^B1111111111111111	;BRANCHES
	.WORD	^B0000000000000000	;
	.WORD	^B1101000000001111	;BRW,CONVERTS,MOVES
	.WORD	^B0111111101010101	;FLOATING OPS
	.WORD	^B0000000101001101	;
	.WORD	^B0111111101010101	;
	.WORD	^B1100000101001111	;
	.WORD	^B1101010101010101	;ARITHMETIC BYTE 
	.WORD	^B1101111111110101	;CMPB,TSTB
	.WORD	^B1101010101010101	;ARITHMETIC WORD
	.WORD	^B1111111111110101	;CMPW,TSTW,BISPSW,BICPSW
	.WORD	^B1101010101010101	;ARITHMETIC LONG
	.WORD	^B1111111111110101	;CMPL,TSTL
	.WORD	^B1100111111111111	;BBS,BBC,BLBS,BLBC,CMPV,CMPZV
	.WORD	^B0000110011111101	;AOB,CVT

;
; LOCAL VARIABLES FOR MACHINE CHECK HANDLER
;

ABUS_CYCLE:				; Bit mask for ABUS related cycles
	.LONG	1@MCF790$C_ABUS + 1@MCF790$C_ABUS_WRT + 1@MCF790$C_ABUS_REFL

ASSUME MCF790$V_ABORTS EQ 1		; Make sure there is room for software
					; abort bit
MCHK_ABORT = 1				; Used by machine check handler to abort

ABORT_BITS:				; Local copy of abort bits
	.LONG	0

SBIA_ERR_SUM:				; Temp copy of SBIA summary register
	.LONG	0

CRD_LOG_SIZE = <2 * 4> + <16 * 3 * 4>	; Buffer size
CRD_BUFFER:				; Single bit error logging buffer
	.LONG	4 + <16*3*4>		; Size of buffer
CRD_FLAGS:				; Flags - 1 -> logging turned off
	.LONG	0
CRD_FIRST_ENTRY:			; Beginning of error entries
	.BLKL	16 * 3			; Room for 16 entries
CRD_BUF_END:

CRD_NEXT:				; Next CRD slot to be used
	.LONG	0


;
; warning messages
;
FBOX_MSG:
	.LONG	20$-10$
10$:	.ASCII	<13><10>-
	\%SYSTEM_W_FBOXOFF, FBOX turned off due to errors\-
	<13><10>
20$:
;
;
CACHE_MSG:
	.LONG	20$-10$
10$:	.ASCII	<13><10>-
	\%SYSTEM_W_CACHEOFF, half of cache turned off due to errors\-
	<13><10>
20$:

	.PSECT	MCHK$CODE,QUAD,RD,WRT
	.SBTTL	Machine check entry point

;++
; MCHECK790 -- VENUS MACHINE CHECK
;
; FUNCTIONAL DESCRIPTION:
;	All machine checks are vectored to this entry point.  
;
; FORMAT OF VENUS'S MACHINE CHECK LOGOUT STACK:
;	On entry to this machine check handler, the stack is set up as follows:
;
;		00(SP):	# bytes in machine check log on stack
;		  .
;		  .
;		 machine check frame (see MCF790DEF)
;		  .
;		  .
;
;
;	As soon as the machine check handler is invoked, it sets up the stack
;	as follows:
;	+-------------------------------+	:(SP)
;	|		.		|
;	|		.		|
;	|	saved R0 - R6, AP	|
;	|		.		|
;	|		.		|
;	+-------------------------------+
;	| pointer to PC/PSL of exception|
;	+-------------------------------+
;	|	recovery mask		|
;	+-------------------------------+
;	| # bytes pushed on logout stack| :(AP)	
;	+-------------------------------+
;	|  				|
;	|				|
;	|          machine		|
;	|           check		|
;	|	    frame		|
;	|				|
;	|				|
;	+-------------------------------+
;
;	AP will point to the beginning of the machine check log on the stack.
;	2 longwords are immediately pushed on top of the machine check log, and
;	are referenced as negative offsets from AP.  These two longwords are
;	input arguments to EXE$MCHK_BUGCHK, a routine that is called to check
;	for a user-declared machine check recovery block.  This routine is
;	called immediately before bugchecking, and expects the mask and the
;	pointer to the exception PC/PSL to be right on top of the machine check
;	log on the stack.
;--

	.ALIGN	LONG
EXE$MCHK::				; Machine check handler.
	PUSHL	#MCHK$M_MCK ! MCHK$M_LOG ; Mask signals machine check.
	PUSHAL	MCF790$L_PC+4(SP)	; Push pointer to exception PC/PSL.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,AP> ; Working registers.
	ADDL3	#<10*4>,SP,AP		; AP points to mchk log frame.
;
; Do misc initialization 
;

	BICL3	#^C<MCF790$M_ABORTS ! -	; Get all the hardware abort bits
		    MCF790$M_AUTO_SHUT>,-
		MCF790$L_EBCS(AP),W^ABORT_BITS 
	CLRB	MCF790$B_MCHK_CODE(AP)	; Just in case
;
; Look for one of the four basic error types
; BUGCHECK if we find two
;
; MBOX fatal errors
;
	BBC	#MCF790$V_MBOX_FE, MCF790$L_EBCS(AP), 10$
	MOVB	#MCF790$C_MBOX_FE, MCF790$B_MCHK_CODE(AP)
;
; FBOX errors
;
10$:	BBC	#MCF790$V_FBOX, MCF790$L_EHSR(AP), 20$
	TSTB	MCF790$B_MCHK_CODE(AP)	; Make sure this is the first match
	BNEQ	BAD_MCHK
	MOVB	#MCF790$C_FBOX, MCF790$B_MCHK_CODE(AP)
;
; EBOX errors
;
20$:	BITL	#MCF790$M_EDP_PE ! MCF790$M_USTK_PE !-
		MCF790$M_ECS_PE ! MCF790$M_EMCR_PE, -
		MCF790$L_EBCS(AP)
	BEQL	30$
	TSTB	MCF790$B_MCHK_CODE(AP)	; Make sure this is the first match
	BNEQ	BAD_MCHK
	MOVB	#MCF790$C_EBOX, MCF790$B_MCHK_CODE(AP)
;
; IBOX errors
;
30$:	BBC	#MCF790$V_IBOX_ERR, MCF790$L_EBCS(AP), 40$
	TSTB	MCF790$B_MCHK_CODE(AP)	; Make sure this is the first match
	BNEQ	BAD_MCHK
	MOVB	#MCF790$C_IBOX, MCF790$B_MCHK_CODE(AP)
;
; Call appropriate service routine
;
40$:	CASE	MCF790$B_MCHK_CODE(AP),- ; Use machine check code
		<CHECK_MBOX_1D,-	; Nothing so far
		F_ERR,-			; FBOX error
		E_ERR,-			; EBOX error
		I_ERR,-			; IBOX error
		M_ERR>,-		; MBOX fatal error
		TYPE=B
; fall thru to bad code
;
; Always bugcheck - may be bug in this handler
;
BAD_MCHK:
	BSBW	LOG_MCHECK		; log it
	BUG_CHECK BADMCKCOD,FATAL
;
M_ERR:	BSBW	MBOX_FE_SERV		; MBOX_FE service routine
	BRB	CHECK_MBOX_1D
;
F_ERR:	BSBW	FBOX_SERV		; FBOX service routine
	BRB	CHECK_MBOX_1D
;
E_ERR:	BSBW	EBOX_SERV		; EBOX service routine
	BRB	CHECK_MBOX_1D
;
I_ERR:	BSBW	IBOX_SERV		; IBOX service routine
;	BRB	CHECK_MBOX_1D
;
; fall thru to next stage of checking
;
; MBOX 1D interrupt indicated by MBOX_INTR without MBOX_FE
; TB problems are hard to spot - just check for the bits
;
CHECK_MBOX_1D:
	BBS	#MCF790$V_MBOX_FE, MCF790$L_EBCS(AP), MCHK_EXIT
	BITL	#MCF790$M_TB_TAG_PE ! MCF790$M_TB_A_PE ! -
		 MCF790$M_TB_B_PE ! MCF790$M_TB_VAL_PE, -
		MCF790$L_MSTAT1(AP)
	BNEQ	10$			; A TB problem
	BBC	#MCF790$V_MBOX_INT, MCF790$L_EBCS(AP), MCHK_EXIT
10$:	BBSS	#MCF790$V_MBOX_1D, MCF790$B_MCHK_CODE(AP), 20$
20$:	BSBW	MBOX_1D_SERV
;
; fall thru to common exit processing
;
MCHK_EXIT:
	TSTB	MCF790$B_MCHK_CODE(AP)
	BEQL	BAD_MCHK		; We couldn't figure it out
	BSBW	LOG_MCHECK		; Log it
;
; If any abort bits are set, we cannot resume the instruction
;
	TSTL	W^ABORT_BITS
	BNEQ	REFLECT_MCHK
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,AP>
	ADDL	#<2*4>,SP		; Get rid of recovery block check data
	ADDL	(SP)+,SP		; Get rid of the machine chack frame
	MTPR	#0,#PR790$_EHSR		; Clear the VMS entered flag
	REI				; At last - continue

	.SBTTL	Reflect machine check to user
;++
;	REFLECT MACHINE CHECK TO USER
;
; This code is entered if the machine check was fatal.  It determines
; if it was just fatal to the process which caused it (current process
; is in USER or SUPER mode), or if it was fatal to the entire system
; (current process is in EXEC or KERNEL mode).
;
; If current process is in USER or SUPER mode,
;	set up an exception on user's stack and REI to it
; If current process is in EXEC or KERNEL mode,
;	issue a fatal bugcheck.
;
; CALLING SEQUENCE:
;	BRB/W -- NOTHING EXTRA CAN BE ON THE STACK!!
;
; STACK CONTENTS:
;	00(SP): saved R0,R1,R2,R3,R4,R5,R6,AP
;	20(SP): 2 longword inputs for recovery block check
;	28(SP): (also AP) machine check log -- 1st longword is a byte count.
;--
REFLECT_MCHK:				; Reflect exception according
					; to current access mode.
	BBS	#PSL$V_CURMOD+1, -	; Branch if USER or SUPER.
		MCF790$L_PSL(AP),10$	;
	BRW	BUGCHECK_NOLOG		; EXEC or KERNEL; bugcheck.

10$:					; SUPER or USER; exception.
	MFPR	#PR$_KSP,R0		; Get kernel stack pointer.
	MOVQ	MCF790$L_PC(AP),-(R0)	; Push PC,PSL on kernel stack.
	MTPR	R0,#PR$_KSP		; Replace new kernel stack ptr.
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,AP> ; Restore registers.
	ADDL	#<2*4>,SP		; Pop inputs for recovery block check.
	ADDL	(SP)+,SP		; Pop mchk log from stack.
;
; Set up an exception stack for current process.
; The faulting PC,PSL pair are still on the interrupt stack.  Alter
; them to look as if an exception has occurred.
;
	MOVAB	G^EXE$MCHECK,(SP)	; Replace exception PC.
	EXTZV	#PSL$V_CURMOD, -	; Zero exception PSL, except
		#PSL$S_CURMOD, -	; for current access mode.
		4(SP),4(SP)
	ROTL	#PSL$V_PRVMOD, -	; Create a PSL of current mode
		4(SP),4(SP)		; kernel, correct previous
					; mode, and IPL 0.
	MTPR	#0,#PR790$_EHSR		; Clear "VMS entered" flag.
	REI				; Go to exception handler.

	.SBTTL	Bugcheck
;++
; If user has declared a recovery block, transfer control to it.
; Else issue a fatal bugcheck.
;
; CALLING SEQUENCE:
;	BRB/W -- NOTHING EXTRA CAN BE ON THE STACK!!!
;
; STACK CONTENTS ON ENTRY:
;	00(SP): saved R0,R1,R2,R3,R4,R5,R6,AP
;	20(SP): 2 longword inputs for recovery block check
;	28(SP): (also AP) machine check log
;--
BUGCHECK_POP:
	ADDL	#4,SP			; Clean off garbage on stack
BUGCHECK:
	BSBW	LOG_MCHECK		; Log it
BUGCHECK_NOLOG:				; Entry point if already logged
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,AP> ; Restore registers.
;
; A fatal bugcheck is now inevitable unless a user has declared a machine
; check recovery block.
;

	MTPR	#0,#PR790$_EHSR		; clear "VMS entered" flag
	JSB	G^EXE$MCHK_BUGCHK	; If return, no recovery block.
	BUG_CHECK -			; Issue fatal bugcheck.
		MACHINECHK,FATAL

	.SBTTL	IBOX errors
;++
; An IBOX error has been detected.
; These are all treated alike.
; This is cause for a bugcheck if they are too frequent.
;--

IBOX_SERV:
	INCL	W^IBOX_TOTAL		; Count the error
	MFPR	#PR790$_TODR,R0		; Current time - 10 millisec units
	SUBL3	W^IBOX_OLD2,R0,R2	; Time for three errors
	CMPL	R2,#IBOX_THRESHOLD	; Too quick
	BGTRU	10$			; No
	BRW	BUGCHECK_POP		; Clean off return address before BUGCHECK
10$:	MOVL	W^IBOX_OLD1, W^IBOX_OLD2 ; Save new times
	MOVL	R0,W^IBOX_OLD1
	RSB

	.SBTTL	MBOX fatal errors
;++
; A MBOX fatal error (FE set) has been detected.
; Error handling depends on the exact error which occurred.
;--

MBOX_FE_SERV:
	.ENABL	LSB

	INCL	W^MBOX_FE_TOTAL		; Count the error
;
; First make sure we have a single error, otherwise give up
;
	BBS	#MCF790$V_MUL_ERR, MCF790$L_MSTAT2(AP),35$
;
; Check for cache tag parity errors with the written bit set
;
	BBC	#MCF790$V_CSH_W, -	; cache not written
		MCF790$L_MSTAT2(AP),30$
	BBS	#MCF790$V_CSH_TAG_PE, -	; parity error
		MCF790$L_MSTAT2(AP),35$ 
;
; Was it a write to nonexistent memory.
; A repeated error is fatal.
;
; R3 must remain cycle type from this point on
;
30$:	EXTZV	#MCF790$V_CYCLE_TYP, -
		#MCF790$S_CYCLE_TYP, -
		MCF790$L_MSTAT1(AP),R3		; get cycle type
	BBC	#MCF790$V_NXM, -		; not NXM
		MCF790$L_MSTAT2(AP),40$
	BISL	#MCHK$M_NEXM,-4(AP)		; Add NXM to recovery mask
	CMPL	MCF790$L_PC(AP), W^MBOX_FE_PC	; same PC for two errors
	BEQL	35$				; yes - bugcheck
	MFPR	#PR790$_TODR,R0			; Current time - 10 millisec units
	SUBL3	W^MBOX_FE_OLD,R0,R2		; Time since last error
	CMPL	R2, #MBOX_FE_THRESHOLD
	BLSSU	35$				; Too quick - bugcheck
	MOVL	R0,W^MBOX_FE_OLD		; Save time of this error
	MOVL	MCF790$L_PC(AP), W^MBOX_FE_PC	; and the PC
	RSB

35$:	BRW	BUGCHECK_POP			; Clean off return address 
;
; Was it an error on instruction access to I/O space
; We can try to recover if it never made it out to the SBI
; This code will need work if SBI memory is ever supported.  It will not have
; physical addresses in the same range as its SBI.
;
; R3 = CYCLE TYPE
;
40$:	BBS	#MCF790$V_CP_IO_BUF, -		; Check for the error bit
		MCF790$L_MSTAT2(AP),45$
	BRW	130$
45$:	EXTZV	#MCF790$V_DEST_CP, -		; code for port being serviced
		#MCF790$S_DEST_CP, -
		MCF790$L_MSTAT1(AP), R0
	MOVL	MCF790$L_IVASAV(AP),R1		; assume it will be op-port
	CMPB	R0,#MCF790$C_OP_PORT
	BEQL	46$				; op-port  (most common case)
	MOVL	MCF790$L_ESASAV(AP),R1		; assume it will be EBOX
	CMPB	R0,#MCF790$C_EBOX_PORT
	BEQL	46$				; EBOX
	MOVL	MCF790$L_VIBASAV(AP),R1		; IBUF (very unlikely)
46$:	MOVL	G^MMG$GL_SPTBASE,R0		; SPT base
	BBSC	#31,R1,47$			; clear the system space bit
	MFPR	#PR$_P0BR,R0			; assume P0 space
	BBC	#30,R1,47$			; it was P0
	MFPR	#PR$_P1BR,R0			; get P1		
47$:	ASHL	#-9,R1,R1			; page number in right space
	MOVL	(R0)[R1],R0			; PTE
	EXTZV	#25-9,#2,R0,R0			; IOA number (25-26 in PA)
	CMPB	W^ABUS_TYPE[R0],#1
	BNEQ	35$				; not SBIA
	INSV	R0, #MCF790$V_AB_ADPT,-		; relative IOA number
		#MCF790$S_AB_ADPT, -		; needed for error logging
		MCF790$L_MSTAT1(AP)
	MOVL	W^ABUS_VA[R0],R1		; base address of SBIA
	BBC	#SBIA$V_BEL, -			; error if error lock not set
		SBIA$L_SUMRY(R1),35$ 
	BBS	#SBIA$V_CAE, -			; CAE - didn't make it to SBI
		SBIA$L_SUMRY(R1),70$ 
	CMPB	R3, #MCF790$C_CP_WRT		; all other reads bad
	BEQL	60$				; go check for OK write errors
;
; Check for read of BRRVR register in UBA.  If this machine check
; is the result of a BRRVR read, then just REI.  Someone will either loose
; a character from a terminal, or a device timeout will result.  This is
; better than a system crash.
;
	BBC	#SBIA$V_CTO,SBIA$L_SBIERR(R1),55$ ; not a timeout
	MOVL	G^IOC$GL_ADPLIST,R0	; point to ADP list
50$:	BEQL	55$			; done if nothing left on list
	CMPW	ADP$W_ADPTYPE(R0),#AT$_UBA ; is this ADP for a UBA?
	BNEQ	53$			; no, look at rest of list
	MOVL	#3,R4			; look at VA's of all 4 BRRVR registers
51$:	ADDL3	#9,ADP$L_UBASCB(R0)[R4],R2 ; calculate address of BRRVR from
					; the SCB vector address saved in ADP
; **** NOTE ****  The previous instruction assumes the currently used coding
; sequence for dispatching UBA interrupts in the module INIADP.MAR.  Any
; changes to that code my affect this routine.  The assumptions are that the
; virtual address of the UBA BRRVR register is at an offset of 10. bytes past
; the interrupt vector address (9 is added to the SCB vector value because
; the vector has bit 0 set to indicate handling the interrupt on the interrupt
; stack), that the PC of the instruction accessing BRRVR is 3 bytes past the
; interrupt vector entry, and that R4 and R5 have been pushed onto the stack.

	CMPL	(R2),MCF790$L_IVASAV(AP) ; same va as in machine check stack?
	BNEQ	52$			; branch if not BRRVR reference
	SUBL	#<9-3>,R2		; else back up to PC of instruction
					; in UB interrupt service that reads BRRVR
	CMPL	R2,MCF790$L_PC(AP)	; does it match PC in MCHECK stack?
	BNEQ	52$			; if so, came from UB interrupt service.
	CLRL	W^MBOX_FE_PC		; matching PC doesn't justify bugcheck
	BRB	70$			; go finish up
52$:	SOBGEQ	R4,51$			; loop through all 4
53$:	MOVL	ADP$L_LINK(R0),R0	; follow ADP list to end
	BRB	50$
55$:	BRB	120$				; full log & bugcheck (abort first)
;
60$:	BITL	#SBIA$M_ADP ! SBIA$M_RCP, -	; ADP or RCP also didn't reach SBI
		SBIA$L_SUMRY(R1)
	BEQL	120$
70$:	BISB	#MCF790$M_SBIA_ERR, -		; add SBIA error summary
		MCF790$B_MCHK_CODE(AP) 
	MOVL	SBIA$L_SUMRY(R1),W^SBIA_ERR_SUM	; save the error summary
	BISL	SBIA$L_SUMRY(R1),SBIA$L_SUMRY(R1) ; clear all the error locks
	BISL	#SBIA$M_CTO,SBIA$L_SBIERR(R1)	; and the CPU timeout bit
	MOVZBL	@MCF790$L_PC(AP),R2		; get the guilty instruction
	BBS	R2,W^SBI_INST,90$		; does instruction only do one read
	RSB					; no - eventually abort
90$:	CMPB	R3,#MCF790$C_CP_READ		; read cycle?
	BNEQ	100$
	BICL	#MCF790$M_IO_RD,W^ABORT_BITS	 ; clear IO read abort
	BRB	110$
100$:	BICL	#MCF790$M_MEM_WRT, W^ABORT_BITS	 ; clear write abort
;
; now make sure errors are not repeated
;
110$:	CMPL	MCF790$L_PC(AP),W^MBOX_FE_PC	; same PC for two errors
	BEQL	115$				; yes - bugcheck
	MFPR	#PR790$_TODR,R0			; Current time - 10 millisec units
	SUBL3	W^MBOX_FE_OLD,R0,R2		; Time since last error
	CMPL	R2, #MBOX_FE_THRESHOLD
	BLSSU	115$				; Too quick - bugcheck
	MOVL	R0,W^MBOX_FE_OLD		; Save time of this error
	MOVL	MCF790$L_PC(AP), W^MBOX_FE_PC	; and the PC
	RSB
;
115$:	BRW	BUGCHECK_POP			; Clean off return address 
;
120$:	BISL	#MCHK$M_NEXM,-4(AP)		; Add NXM to recovery mask
	BISB	#MCF790$M_SBIA, -		; log full SBIA
		MCF790$B_MCHK_CODE(AP) 		; eventually abort (bit set)
	RSB					; and bugcheck (assume kernel mode)
;
; Give up if there is no cycle type
;
130$:	CMPB	R3, #MCF790$C_NOP
	BEQL	115$
;
; if a cycle parameter RAM error, give up
;
	BITL	#MCF790$M_CPR_PE_A ! MCF790$M_CPR_PE_B,-
		MCF790$L_MSTAT1(AP)
	BNEQ	115$
;
; Look for an error writing an MBOX register
; MBOX confused, so no recovery
; R3 = CYCLE TYPE
;
150$:	CMPB	R3, #MCF790$C_WRITE_REG
	BEQL	115$				; yes - bugcheck

;
; Is it ABUS PE of some sort
;
	BITL	#MCF790$M_AB_DAT_PE ! -
		 MCF790$M_AB_CM_PE,-
		MCF790$L_MSTAT1(AP)
	BNEQ	115$				; ABUS so go bugcheck
;
; This is an unknown error type
; Either the hardware is very sick or this handler has a bug
;
160$:	BRW	BAD_MCHK

	.DSABL	LSB

	.SBTTL	FBOX errors
;++
; An FBOX error has been detected
; These are all treated alike
; This is cause for turning off the FBOX if they are too frequent
; A console message is printed if FBOX is turned off
;--
FBOX_SERV:
	INCL	W^FBOX_TOTAL		; Count the error
	MFPR	#PR790$_TODR,R0		; Current time - 10 millisec units
	SUBL3	W^FBOX_OLD2,R0,R2	; Time for three errors
	CMPL	R2,#FBOX_THRESHOLD	; Too quick
	BGTRU	10$			; No
	MTPR	#0,#PR790$_ACCS		; Turn FBOX off
	BISB	#MCF790$M_RSRC_REM,-	; Indicate resource removed
		MCF790$B_MCHK_CODE(AP)
	MOVL	W^FBOX_MSG,R1		; Mesage length
	MOVAB	W^FBOX_MSG+4,R2		; Message address
	MOVAB	G^OPA$UCB0,R5		; Send it to the console terminal
	JSB	G^IOC$BROADCAST
	RSB
10$:	MOVL	W^FBOX_OLD1, W^FBOX_OLD2 ; Save new times
	MOVL	R0,W^FBOX_OLD1
	RSB

	.SBTTL	EBOX errors
;++
; An EBOX error has been detected
; These are all treated alike.
; This is cause for a bugcheck if they are too frequent.
;--

EBOX_SERV:
;
; First see if the error is a result of an MBOX problem
;
	BBC	#MCF790$V_EDP_PE, MCF790$L_EBCS(AP), 10$
	BBS	#MCF790$V_MBOX_INT,-	; It was the MBOX - don't blame EBOX
		MCF790$L_EBCS(AP), 30$
10$:	INCL	W^EBOX_TOTAL		; Count the error
	MFPR	#PR790$_TODR,R0		; Current time - 10 millisec units
	SUBL3	W^EBOX_OLD2,R0,R2	; Time for three errors
	CMPL	R2,#EBOX_THRESHOLD	; Too quick
	BGTRU	20$			; No
	BRW	BUGCHECK_POP		; Clean off return address before BUGCHECK
20$:	MOVL	W^EBOX_OLD1,W^EBOX_OLD2	; Save new times
	MOVL	R0,W^EBOX_OLD1
30$:	RSB

	.SBTTL	Bad Data or Double Bit error
;++
; If possible a new copy of the page is paged in.
; A double bit error will cause the physical page to be put on the bad page list
; while a bad data error simply gets a new copy since it is not the array that 
; is at fault.
;--
BAD_MEM:
	BBC	#PSL$V_IS, MCF790$L_PSL(AP),1$
	BRW	BUGCHECK_POP		; Interrupt stack - must give up
1$:	CMPV	#PSL$V_IPL, #PSL$S_IPL, -
		MCF790$L_PSL(AP), #IPL$_ASTDEL ; Are we at a non-pageable priority?
	BGTR	12$			; Abort - recovery is useless
	ASHL	#-9, MCF790$L_MEAR(AP),R0 ; Get physical PFN of error
	CMPL	R0,G^MMG$GL_MAXPFN	; Is there PFN data base for page?
	BGTRU	12$			; Br if no PFN data base for page
	MOVL	G^PFN$AL_PTE,-(SP)
	MOVL	@(SP)+[R0],R3		; address of PTE
	BEQL	3$			; none - give up
	TSTL	(R3)	
	BLSS	5$			; Branch if page valid
3$:	BRW	RDSNONRES		; else fatal error
5$:	BBS	#PTE$V_WINDOW,(R3),12$	; BR if page is PFN-mapped
	BBC	#MCF790$V_DBL_BIT,-	; Is it a double bit error
		MCF790$L_MDECC(AP),7$	; If not, let page go to free list
	MOVL	G^PFN$AB_TYPE,-(SP)	; PFN type array address 
	BISB	#PFN$M_BADPAG,@(SP)+[R0] ; Mark page bad		
7$:	CLRL	R1			; Clear modify bit propagator
	BBCC	#PTE$V_MODIFY,(R3),10$	; Test (& clear) modify bit in PTE
	MOVZBL	#PFN$M_MODIFY,R1	; Set modify propagator
10$:	MOVL	G^PFN$AB_STATE,-(SP)	; Address of PFN state array 
	BISB	R1,@(SP)+[R0]		; Propagate modify bit to PFN database
 
	ASSUME	PFN$M_MODIFY EQ 128
 
	BGTR	15$			; Page not modified - he's OK
12$:	BISB	#MCHK_ABORT,W^ABORT_BITS ; Force an abort
	RSB
15$:	MOVL	G^PFN$AW_REFCNT,-(SP)	; Address of PFN refcnt array 
	CMPW	@(SP)+[R0],#1		; Check for I/O in progress, etc. 
	BGTRU	12$			; If so, don't try anything fancy
	MOVL	G^PFN$AB_TYPE,-(SP)	; Address of PFN type array  

;	In the future we may recover from hard ecc errors on global pages
;	as well, but for now we abort the image.

	ASSUME	PFN$C_SYSTEM EQ 1	; Check type of page
	ASSUME	PFN$C_PROCESS EQ 0

	CMPV	#PFN$V_PAGTYP, #PFN$S_PAGTYP, -
		@(SP)+[R0],#PFN$C_SYSTEM ; Check for system or global page
	BGTRU	12$			; Branch if page table or global page 
	BNEQ	30$			; Branch if page is process private
	MOVAB	G^MMG$AL_SYSPCB,R4	; System pages are kept track of in
	MOVL	PCB$L_PHD(R4),R5	; a working set list in the system pcb
	BRB	40$
					; Find the PHD and PCB for process page
30$:	SUBL3	G^SWP$GL_BALBASE,R3,R5	; Bytes past first balance set page
	DIVL	G^SWP$GL_BSLOTSZ,R5	; Process header index
	ASHL	#-9,R5,R5		; Divide by page size
	MULL	G^SWP$GL_BSLOTSZ,R5	; Convert process index
	ROTL	#9,R5,R5		; to process header address
	ADDL	G^SWP$GL_BALBASE,R5
	MOVL	PHD$L_PCB(R5),R4	; Get PCB
40$:	BBCC	#PTE$V_VALID,(R3),50$	; Clear valid bit from PTE
50$:	MTPR	#0,#PR$_TBIA		; Invalidate translation buffer 
	MOVL	G^PFN$AW_REFCNT,-(SP)	; Address of PFN refcnt array  
	DECW	@(SP)+[R0]		; Reduce reference count to 0
	BGEQ	60$			;
	JSB	G^MMG$REFCNTNEG		;
60$:	MOVL	G^PFN$Ax_WSLX,-(SP)	; Address of PFN WSLX array  
		PFN_REFERENCE	-
	MOVZWL	<@(SP)+[R0],R1>,-	; Get working-set list index for page 
		LONG_OPCODE=MOVL,-
		IMAGE=SYSLOA790.EXE
	JSB	G^MMG$DELWSLEX		; Delete it from the working set its in
	MOVL	G^PFN$AB_STATE,-(SP)	; PFN type array address 
	BISB	#PFN$M_DELCON,@(SP)+[R0] ; Delete contents
	JSB	G^MMG$RELPFN		; Put page on appropriate list

; At this point, the PTE for the bad page contains its mass storage
; address. This will cause a fresh copy of the page to be fetched when
; the process is resumed.

	RSB				; Log machine check and resume process

RDSNONRES:				;
	BSBW	LOG_MCHECK		; Go log it
	MTPR	#0,#PR790$_EHSR		; Clear the VMS entered flag 
	ADDL	#4,SP			; Clean off return address
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,AP>
	JSB	G^EXE$MCHK_BUGCHK	; Recovery block in effect?
	BUG_CHECK RDSNONRES,FATAL	; Read data substitute page nonresident

	.SBTTL MBOX 1D errors
;++
; An MBOX error was reported when IPL dropped below 1D
; these are not directly related to instruction execution
; From here we will dispatch to one of two subcategories
;	asynchronous CPU errors
;	DMA errors
; TB errors do not latch the cycle type, so a separate check is required
; for them
; 
; Cycle parameter RAM errors are occasionally reported here instead of as 
; MBOX FE
;--
MBOX_1D_SERV:
;
; First make sure we have a single error, otherwise give up
;
	BBS	#MCF790$V_MUL_ERR, MCF790$L_MSTAT2(AP),5$
;
; Now look for that errant CPR parity error
;
	BITL	#MCF790$M_CPR_PE_A ! MCF790$M_CPR_PE_B,-
		MCF790$L_MSTAT1(AP)
	BEQL	10$
5$:	BRW	BUGCHECK_POP		; Disaster - give up
;
; Finally, do the normal error processing
;
10$:	BITL	#MCF790$M_TB_TAG_PE ! -
		 MCF790$M_TB_A_PE ! -
		 MCF790$M_TB_B_PE ! -
		 MCF790$M_TB_VAL_PE, -
		MCF790$L_MSTAT1(AP)
	BNEQ	MBOX_1D_CPU		; A TB problem
	EXTZV	#MCF790$V_CYCLE_TYP, -
		#MCF790$S_CYCLE_TYP, -
		MCF790$L_MSTAT1(AP),R3	; get cycle type
	BBS	R3,W^ABUS_CYCLE,20$	; is it ABUS related
	BRB	MBOX_1D_CPU		; a CPU error
20$:	BRW	MBOX_1D_DMA		; a DMA error

	.SBTTL	MBOX 1D asynchronous CPU error
;++
; Handle an MBOX 1D error triggered by a CPU reference
; In general, these are non-fatal.  We bugcheck only if the error rate is 
; too high.
; Whenever bad data is written, we ignore the error until someone reads it.
; When bad data is consumed, the assumption is that it will be used (not 
; absolutely true, but not worth the effort for the slight chance that it won't 
; be used) and we treat this like the MBOX FE case.
;--
MBOX_1D_CPU:
	.ENABL	LSB
;
; First check for translation buffer problems
;
	BITL	#MCF790$M_TB_TAG_PE ! -
		 MCF790$M_TB_A_PE ! -
		 MCF790$M_TB_B_PE ! -
		 MCF790$M_TB_VAL_PE, -
		MCF790$L_MSTAT1(AP)
	BEQL	20$			; Not a TB problem
	INCL	W^TB_TOTAL		; Count the error
	MFPR	#PR790$_TODR,R0		; Current time - 10 millisec units
	SUBL3	W^TB_OLD2,R0,R2		; Time for three errors
	CMPL	R2,#TB_THRESHOLD	; Too quick
	BGTRU	10$			; No
	BRW	BUGCHECK_POP		; Clean off return address before BUGCHECK
10$:	MOVL	W^TB_OLD1, W^TB_OLD2	; Save new times
	MOVL	R0,W^TB_OLD1
	RSB
;
; Next cache errors.
; Cache errors are not counted if the bad data flag is set.  This is assumed
; to be the fault of some other hardware.  Some previous error reported this.
; 
20$:	BITL	#MCF790$M_CSH_TAG_W ! -
		 MCF790$M_CSH_TAG_PE, -
		MCF790$L_MSTAT2(AP)	; Is error in tag or written bit
	BNEQ	CACHE_ERR		; Yes - process cache error
	BBC	#MCF790$V_CSH_DAT_BW ! - ; Is it cache error
		MCF790$V_CSH_DAT_NBW,-
		MCF790$L_MSTAT1(AP),70$ ; No
30$:	BBC	#MCF790$V_BAD_DATA,-	; If BAD DATA error - not fault of cache
		MCF790$L_MDECC(AP), -	; or it has already been accounted for
		CACHE_ERR 
;
; Cache has bad data.  It either got it from memory or it was written into
; cache by CPU or IO.  In either case, the memory page is now useless.
;
	BRW	BAD_MEM			; Go try to recover
;
; Check for too many errors and turn off cache if necessary
;
CACHE_ERR:				; Entry point used for FE and others
	INCL	W^CACHE_TOTAL		; Count the error
	MFPR	#PR790$_TODR,R0		; Current time - 10 millisec units
	BBS	#MCF790$V_CSH_ERR,-	; It was cache B
		MCF790$L_MSTAT1(AP), 50$
	SUBL3	W^CSH_A_OLD2,R0,R2	; Time for three errors
	CMPL	R2,#CACHE_THRESHOLD	; Too quick
	BLSSU	60$
	MOVL	W^CSH_A_OLD1, W^CSH_A_OLD2 ; Save new times
	MOVL	R0, W^CSH_A_OLD1
	RSB

50$:	SUBL3	W^CSH_B_OLD2, R0,R2	; Time for three errors
	CMPL	R2,#CACHE_THRESHOLD	; Too quick
60$:	BLSSU	CACHE_OFF
	MOVL	W^CSH_B_OLD1, W^CSH_B_OLD2 ; Save new times
	MOVL	R0, W^CSH_B_OLD1
	RSB
;
; data address parity error
;
70$:	BBC	#MCF790$V_ADR_PE, -		; Something else
		MCF790$L_MDECC(AP),80$ 
	CMPL	MCF790$L_MEAR(AP),-		; same physical address
		W^MBOX_FE_PHY_ADR 
	BEQL	95$				; yes - bugcheck
	MFPR	#PR790$_TODR,R0			; Current time - 10 millisec units
	SUBL3	W^MBOX_FE_OLD,R0,R2		; Time since last error
	CMPL	R2, #MBOX_FE_THRESHOLD
	BLSSU	95$				; Too quick - bugcheck
	MOVL	R0,W^MBOX_FE_OLD		; Save time of this error
	MOVL	MCF790$L_PC(AP), W^MBOX_FE_PC	; Save PC
	MOVL	MCF790$L_MEAR(AP), W^MBOX_FE_PHY_ADR ; Save physical address
	RSB
;
; Double bit or bad data errors from memory.
; These errors are either in the context of the correct process or the BAD_MEM 
; routine will spot it
;
80$:	BITL	#MCF790$M_BAD_DATA ! -	; check error bits
		 MCF790$M_DBL_BIT, - 
		MCF790$L_MDECC(AP)
	BEQL	90$			; Nope - something else
	BRW	BAD_MEM			; Go try to recover
;
; ABUS bad data flag 
;
90$:	BBS	#MCF790$V_AB_BAD_DAT,-	; Go count misc errors
		MCF790$L_MSTAT2(AP),-
		MISC_MBOX_1D
95$:					; Fall through to misc
;
; misc MBOX errors
;
MISC_MBOX_1D:
	INCL	W^MBOX_1D_TOTAL		; Count the error
	MFPR	#PR790$_TODR,R0		; Current time - 10 millisec units
	SUBL3	W^MBOX_1D_OLD2,R0,R2	; Time for three errors
	CMPL	R2, #MBOX_1D_THRESHOLD	; Too quick
	BGTRU	100$			; No
	BRW	BUGCHECK_POP		; Clean off return address before BUGCHECK
100$:	MOVL	W^MBOX_1D_OLD1, W^MBOX_1D_OLD2 ; Save new times
	MOVL	R0, W^MBOX_1D_OLD1
	RSB
	.DSABL	LSB
;
; Handle turning off the correct half of cache
;
CACHE_OFF:
	MFPR	#PR790$_CSWP,R0		; Get current cache state
	BBS	#MCF790$V_CSH_ERR,-	; Which half is at fault
		MCF790$L_MSTAT1(AP),10$
	BISB	#CSWP$M_C1ENA ! CSWP$M_VAL,R0	; Cache 0 - leave 1 on
	BRB	20$
10$:	BISB	#CSWP$M_C0ENA ! CSWP$M_VAL,R0	; Cache 1 - leave 0 on
20$:	MTPR	R0,#PR790$_CSWP		; Disable it
	BISB	#MCF790$M_RSRC_REM,-	; Indicate resource removed
		MCF790$B_MCHK_CODE(AP)
	MOVL	W^CACHE_MSG,R1		; Mesage length
	MOVAB	W^CACHE_MSG+4,R2	; Message address
	MOVAB	G^OPA$UCB0,R5		; Send it to the console terminal
	JSB	G^IOC$BROADCAST
	RSB

	.SBTTL	MBOX 1D ABUS (DMA) errors
;++
; Handle an MBOX 1D error triggered by an ABUS reference.
; In general, these are non-fatal.  We bugcheck only if the error rate is
; too high.
; Whenever bad data is written, the error is ignored until someone reads it.
; Errors on reading are handled by device drivers.
;--
MBOX_1D_DMA:
;
;	Cycle type is in R3  -  This must not be destroyed
;
; All errors require logging the ABUS error summary register and unlocking the 
; adaptor.
;
	EXTZV	#MCF790$V_AB_ADPT,-	; relative IOA number
		#MCF790$S_AB_ADPT, -
		MCF790$L_MSTAT1(AP), R0
	CMPB	W^ABUS_TYPE[R0],#1
	BNEQ	50$			; not SBIA
	MOVL	W^ABUS_VA[R0],R1	; base address of SBIA
	BISB	#MCF790$M_SBIA_ERR, -	; add SBIA error summary
		MCF790$B_MCHK_CODE(AP) 
	MOVL	SBIA$L_SUMRY(R1),-	; Save the error summary
		W^SBIA_ERR_SUM 
	BISL	SBIA$L_SUMRY(R1), -	; Clear all the error locks
		SBIA$L_SUMRY(R1) 
	BISL	#SBIA$M_CTO, -		; and the CPU timeout bit
		SBIA$L_SBIERR(R0) 
;
; Check for cache errors.
; Cache errors are not counted if the bad data flag is set.  This is assumed
; to be the fault of some other hardware.  Some previous error reported this.
; 
20$:	BITL	#MCF790$M_CSH_TAG_W ! -
		  MCF790$M_CSH_TAG_PE, -
		MCF790$L_MSTAT2(AP)	; Is error in tag or written bit
	BNEQ	35$			; Yes - process cache error
	BBC	#MCF790$V_CSH_DAT_BW ! - ; Is it cache error
		MCF790$V_CSH_DAT_NBW,-
		MCF790$L_MSTAT1(AP),40$ ; No
30$:	BBC	#MCF790$V_BAD_DATA,-	; If BAD DATA error - not fault of cache
		MCF790$L_MDECC(AP),38$	; or it has already been accounted for
	RSB
35$:	BBC	#MCF790$V_CSH_W, -	; cache not written
		MCF790$L_MSTAT2(AP),38$
	BBS	#MCF790$V_CSH_TAG_PE, -	; parity error
		MCF790$L_MSTAT2(AP),50$ ; tag error with W bit set - bugcheck
38$:	BRW	CACHE_ERR 
;
; Check for MDECC errors.
; Simply log them except for a bugcheck on a data address parity error.  Here
; data probably went to a wrong location so crash fast.
; In the case of double bit errors in memory, the page will eventually go to 
; the bad page list.
; The device will also get an error on reads.
;
40$:	BBS	#MCF790$V_ADR_PE,-	; Address parity error - bugcheck
		MCF790$L_MDECC(AP),50$
	BITL	#MCF790$M_BAD_DATA ! -
		 MCF790$M_DBL_BIT, -
		 MCF790$L_MDECC(AP)
	BEQL	60$			; Try something else
	ASHL	#-9, MCF790$L_MEAR(AP),R0 ; Get physical PFN of error
	CMPL	R0,G^MMG$GL_MAXPFN	; Is there PFN data base for page?
	BGTRU	45$			; Br if no PFN data base for page
	BBC	#MCF790$V_DBL_BIT,-	; Is it a double bit error
		MCF790$L_MDECC(AP),45$	; If not, let page go to free list
	MOVL	G^PFN$AB_TYPE,-(SP)	; PFN type array address 
	BISB	#PFN$M_BADPAG,@(SP)+[R0] ; Mark page bad		
45$:	RSB				; Log it
;
50$:	BRW	BUGCHECK_POP		; Clean off return address before BUGCHECK
;
; Check for NXM
; Recovery from q write to memory is impossible and it doesn't seem to be
; worthwhile to try to distiguish it from a read since something is very
; wrong in any case.
;
60$:	BBS	#MCF790$V_NXM, -	; NXM
		MCF790$L_MSTAT2(AP),50$
;
; The only other error to really worry about is ABUS address PE or control PE
; All other errors return a device error.
;
90$:	BITL	#MCF790$M_AB_ADR_PE ! -
		 MCF790$M_AB_CM_PE, -
		MCF790$L_MSTAT1(AP)
	BNEQ	50$
	RSB				; Not address or control PE

	.SBTTL	SBI vectors & error handling
;++
; SBI alert, fault and error are handled here
; All interrupts cause a full SBIA log
; SBI fail is treated like power fail and is handled elsewhere.
;
; Stack on entry:
;	pointer to SBIA base address
;	PC,PSL pair
;--
	.ALIGN	LONG	
EXE$INT58::				; SBI ALERT
EXE$INT5C::				; SBI FAULT
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,AP>
	MOVL	@<8*4>(SP),R3		; SBIA base address
	ADDL3	#<9*4>,SP,R1		; Point to PC,PSL
SBI_RECOV:
	BSBW	LOGSBI			; Go log it
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,AP>
	ADDL	#4,SP			; Get rid of the base address
	REI
;
;
	.ALIGN	LONG
EXE$INT60::				; SBIA ERROR
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,AP>
	MOVL	@<8*4>(SP),R3		; SBIA base address
	ADDL3	#<9*4>,SP,R1		; Point to PC,PSL
	BBC	#SBIA$V_IME,-		; Is it an unrecoverable internal error
		SBIA$L_SUMRY(R3),SBI_RECOV ; No
	BSBW	LOGSBI			; Go log it
	BUG_CHECK SBIAERROR,FATAL

	.SBTTL	Logging routines for machine checks
;++
; LOG_MCHECK -- format inputs to LOGGER
;
;
; IMPLICIT INPUTS:
;	(AP): points to machine check log on stack
;
; OUTPUTS:
;	Error is formatted and logged in system error log.
;	If no error log buffer, return with error status in R0.
;	R0-R6 destroyed.
;--

LOG_MCHECK:
;
; Test if a machine check recovery block that specifies no error
; logging is in effect.
;
	MOVQ	-8(AP),R1		; Get PC-PSL pointer and mask in R1,R2
	JSB	G^EXE$MCHK_TEST		; Logging inhibited?
	BLBS	R0,20$			; Branch if YES - but go clear SBIA
					; Set up inputs to LOGGER.
	INCL	G^EXE$GL_MCHKERRS	; Bump machine check error count
	MOVL	#MCF790$L_PSL -		; Size of machine check frame
		+ EMB$B_MC_SUMCOD -	; Add space for log header.
		+ 4 ,R1			; SBIA summary
	JSB	G^ERL$ALLOCEMB		; Get error logging buffer.
	BLBC	R0, 20$			; Br if failed to get buffer.
	PUSHL	R2			; Save buffer addr on stack.
	MOVW	#EMB$K_MC, EMB$W_MC_ENTRY(R2) ; Set entry type.
	MOVC3	#MCF790$L_PSL,-		; transfer info to log
		MCF790$L_EHSR(AP),-     ; do not include the size word
		EMB$B_MC_SUMCOD(R2) 
	BBC	#MCF790$V_SBIA_ERR,-	; Should the SBIA error summary be added
		MCF790$B_MCHK_CODE(AP),15$
	MOVL	W^SBIA_ERR_SUM,(R3)	; Add summary at end of MOVC3 transfer
15$:	POPR	#^M<R2>			; Retreive buffer address.
	JSB	G^ERL$RELEASEMB		; Give buffer to logger.
;
; Now see if we need to log the SBIA data
;
20$:	BBC	#MCF790$V_SBIA,-	; Is the logging flag set
		MCF790$B_MCHK_CODE(AP),40$
	EXTZV	#MCF790$V_AB_ADPT,-	; relative IOA number
		#MCF790$S_AB_ADPT, -
		MCF790$L_MSTAT1(AP), R0
	MOVL	W^ABUS_VA[R0],R3	; base address of SBIA
	MOVQ	-8(AP),R1		; Get PC-PSL pointer and mask in R1,R2
	BRB	LOGSBI			; Go to the SBIA logger

40$:	RSB

	.SBTTL	Logging routines for use by adaptor error routines
;++
; MCHK$GL_LOG -- format inputs to LOGGER
;
; INPUTS:
;	R3: error type code
;	R4: length of frame
;	R5: address of frame
;
;
; OUTPUTS:
;	Error is formatted and logged in system error log.
;	If no error log buffer, return with error status in R0.
;	R0-R5 destroyed.
;--

MCHK$GL_LOG::
	ADDL3	#EMB$B_MC_SUMCOD,R4,R1	; Space for log header
	JSB	G^ERL$ALLOCEMB		; Get a buffer
	BLBC	R0,10$			; No space - give up
	PUSHL	R2			; Save address of buffer
	MOVW	R3,EMB$W_MC_ENTRY(R2)	; Rason code
	MOVC3	R4,(R5),EMB$B_MC_SUMCOD(R2) ; Move the frame
	MOVL	(SP)+,R2		; Get back the address
	JSB	G^ERL$RELEASEMB		; Give buffer to logger
10$:	RSB

	.SBTTL	SBIA logging
;++
; This routine is used to log SBIA (IOA) and SBI registers and related
; information.
;
; INPUTS:
;	R1 -> Address of PC, PSL
;	R3 -> Base adress of IOA registers
;--
LOGSBI:	MOVL	#MCHK$M_LOG,R2		; Mask to test if logging is enabled
	JSB	G^EXE$MCHK_TEST		; Enabled?
	BLBC	R0,10$			; yes
5$:	BRW	60$			; go clear errors
10$:	MOVL	R1,R5			; Save address of PC, PSL
;		   adapters   silo     registers      overhead
	LOG_SIZE =  <16*4> + <16*4>  +  <21*4>  +  EMB$B_MC_SUMCOD
	MOVL	#LOG_SIZE,R1		; Need this much for error log buffer
	JSB	G^ERL$ALLOCEMB		; Request it
	BLBC	R0,5$			; Can't get it - give up quietly
	MOVW	#EMB$K_SBIA, EMB$W_MC_ENTRY(R2) ; Entry type code
	ADDL3	 #LOG_SIZE,R2,R4	; Address of end of error log buffer
	MOVQ	(R5),-(R4)		; PC, PSL
	MOVL	G^EXE$GL_CONFREGL,R6	; Array of NEXUS device type codes
	MOVL	G^MMG$GL_SBICONF,R5	; Array of adapter VA's
	CLRL	R0			; Start with the first SBIA
15$:	CMPL	R3,ABUS_VA[R0]		; Is it this one?
	BEQL	20$
	AOBLSS	#4,R0,15$
	BUG_CHECK SBIAERROR,FATAL	; No match
20$:	MOVZBL	ABUS_INDEX[R0],R0	; Index in arrays for this SBIA
	ASHL	#2,R0,R0		; Get longword offset
	ADDL	R0,R6			; EXE$GL_CONFREGL
	ADDL	R0,R5			; MMG$GL_SBICONF
	MOVL	#15,R0			; Index of last possible item on SBI
30$:	CLRL	-(R4)			; Assume no adaptor here
	MOVL	(R5)[R0],R1		; Get VA of controller/adapter
	BGEQ	40$			; GEQ implies no valid system VA.
	TSTL	(R6)[R0]		; Test adapter type
	BEQL	40$			; If eql, no adaptor here
	MOVL	(R1),(R4)		; Store adaptor CSR0 on stack
40$:	SOBGEQ	R0,30$			; Loop thru all possible 16
	MOVL	#15,R0			; Set up count of times to read silo
50$:	MOVL	SBIA$L_SBISILO(R3),-(R4) ; Save information for error logger
	SOBGEQ	R0,50$			; Loop thru all 16
	MOVL	SBIA$L_TMOADDRS(R3),-(R4) ; SBI timeout address
	MOVL	SBIA$L_SBIERR(R3),-(R4)	; SBI error register
	MOVL	SBIA$L_MAINT(R3),-(R4)	; SBI maintenance register
	MOVL	SBIA$L_SILOCMP(R3),-(R4); SBI silo comparator
	MOVL	SBIA$L_SBISTS(R3),-(R4)	; SBI fault/status register
	MOVL	SBIA$L_CR(R3),-(R4)	; IOA_CF (configuration register)
	MOVL	SBIA$L_CSR(R3),-(R4)	; IOA_CS (control/status register)
	MOVL	SBIA$L_SUMRY(R3),-(R4)	; IOA_ES (error summary register)
	MOVL	SBIA$L_DIAGNOS(R3),-(R4); IOA_DC (diagnostic control register)
	MOVL	SBIA$L_DMAICA(R3),-(R4)	; DMAI cmd/address register
	MOVL	SBIA$L_DMAIID(R3),-(R4)	; DMAI ID register
	MOVL	SBIA$L_DMAACA(R3),-(R4)	; DMAA cmd/address register
	MOVL	SBIA$L_DMAAID(R3),-(R4)	; DMAA ID register
	MOVL	SBIA$L_DMABCA(R3),-(R4)	; DMAB cmd/address register
	MOVL	SBIA$L_DMABID(R3),-(R4)	; DMAB ID register
	MOVL	SBIA$L_DMACCA(R3),-(R4)	; DMAC cmd/address register
	MOVL	SBIA$L_DMACID(R3),-(R4)	; DMAC ID register
	MOVL	R3,-(R4)		; IOA base address
	MOVL	#LOG_SIZE-EMB$B_MC_SUMCOD,-(R4) ; Frame size
	JSB	G^ERL$RELEASEMB		; Give it to the error logger	
60$:	BISL	SBIA$L_SUMRY(R3),SBIA$L_SUMRY(R3) ; clear all the error locks
	BISL	#SBIA$M_CTO,SBIA$L_SBIERR(R3)	; and the CPU timeout bit
	BISL	#SBIA$M_FLTLA,SBIA$L_SBISTS(R3)	; and the fault latch
70$:	RSB

	.SBTTL	Single Bit (CRD) error handling
;++
; This routine logs single bit errors.
; 16 errors are accumulated before an error log entry is made.
; 3 errors in 1 second causes reporting to be turned off for 5 minutes
;
; Due to a hardware bug, we must never run with CRD interrupts turned off.
; Doing so can cause us to miss double-bit errors.  Instead, we will only
; disable logging of the errors.
;--
	.ALIGN 	LONG
EXE$INT54::
	BLBS	W^CRD_FLAGS,20$		; Is logging turned off
	PUSHR	#^M<R0,R1,R2>
	INCL	W^CRD_TOTAL		; Count the error
	MOVL	W^CRD_NEXT,R0		; Next slot in CRD log buffer
	BNEQ	10$			; Is it initialized
	MOVAB	W^CRD_FIRST_ENTRY,R0	; First slot in CRD log buffer
	MOVL	R0,W^CRD_NEXT 		; Initialize it
10$:	MTPR	#^X27,#PR790$_LSPA	; MDECC code to scratchpad address
	MFPR	#PR790$_RSPD,(R0)+	; Save MDECC
	MTPR	#^X2A,#PR790$_LSPA	; MEAR code to scratchpad address
	MFPR	#PR790$_RSPD,(R0)+	; Save MEAR
	MTPR	#^X26,#PR790$_LSPA	; MSTAT2 code to scratchpad address
	MFPR	#PR790$_RSPD,(R0)+	; Save MSTAT2
	MFPR	#PR790$_TODR,R1		; Current time - 10 millisecond units
	SUBL3	W^CRD_OLD2,R1,R2	; Time for three errors
	CMPL	R2,#CRD_THRESHOLD	; Too quick
	BLSSU	CRD_OFF			; Yes
	MOVL	W^CRD_OLD1,W^CRD_OLD2	; Save new times
	MOVL	R1,W^CRD_OLD1
	MOVAB	W^CRD_BUF_END,R1	; End of buffer
	CMPL	R0,R1			; Is buffer full?
	BGEQU	CRD_LOG			; Yes
	MOVL	R0,W^CRD_NEXT		; Next buffer slot
	POPR	#^M<R0,R1,R2>
20$:	REI
;
; Log the current buffer and clear it for reuse.
;
CRD_LOG:
	PUSHR	#^M<R3,R4,R5>
	MOVL	#MCHK$M_LOG,R2		; Mask to test if logging is enabled
	JSB	G^EXE$MCHK_TEST		; Enabled?
	BLBS	R0,10$			; No - just go clear buffer
	MOVL	#CRD_LOG_SIZE + EMB$B_MC_SUMCOD,R1 ; Error log buffer size
	JSB	G^ERL$ALLOCEMB		; Request it
	BLBC	R0,10$			; Can't get it - just clear the buffer
	MOVW	#EMB$K_CRD, EMB$W_MC_ENTRY ; Entry type code
	PUSHL	R2
	MOVC3	R1,W^CRD_BUFFER,-	; Move log to buffer
		EMB$B_MC_SUMCOD(R2)
	POPR	#^M<R2>
	JSB	G^ERL$RELEASEMB
10$:	MOVAB	W^CRD_FIRST_ENTRY,R0	; First slot in CRD log buffer
	MOVL	R0,W^CRD_NEXT		; Start here next time
	MOVC5	#0,(R0),#0,-		; Clear the buffer
		#CRD_BUF_END-CRD_FIRST_ENTRY,-
		(R0)
	POPR	#^M<R3,R4,R5>
	POPR	#^M<R0,R1,R2>
	REI
;
; Turn off CRD error reporting for 5 minutes
; Due to hardware bug, we will not turn off interrupts, only logging.
;
CRD_OFF:
;	MFPR	#PR790$_MERG,R0		; Get current error reporting state
;	BBSS	#MERG$V_INHCRD,R0,10$	; Turn off CRD reporting
;10$:	MTPR	R0,#PR790$_MERG
	MOVL	#1,W^CRD_FLAGS		; Indicate CRD reporting turned off
	BRB	CRD_LOG			; Go log it

	.SBTTL	CRD reenable timer routine
;++
; Routine called by system clock routine.
; If CRD reporting is disabled and the timer has expired, reporting is
; reenabled if allowed by the SYSGEN parameter.
;--
ECC$REENABLE::
	PUSHL	R0
	BLBC	W^CRD_FLAGS,20$		; Return if reporting is not disabled
	DECL	W^CRD_TIMER
	BGTR	20$			; Timer not expired yet	
	MOVL	#CRD_REENAB_TIME,-	; Reset the timer
		W^CRD_TIMER
	BBC	#EXE$V_CRDENABL,-	; Check SYSGEN parameter
		G^EXE$GL_FLAGS, 20$	; Br if CRD's not wanted
;
; Due to hardware bug, we did not turn off interrupts, only logging.
;
;	MFPR	#PR790$_MERG,R0		; Get current error reporting state
;	BBCC	#MERG$V_INHCRD,R0,10$	; Turn on CRD reporting
;10$:	MTPR	R0,#PR790$_MERG
	CLRL	W^CRD_FLAGS		; Indicate CRD reporting turned on
20$:	POPR	#^M<R0>
	DECL	W^KEEPALIVE_TIMER	; Decrement console keepalive timer.
	BLEQ	30$			; Branch if it has expired.
	RSB				; Else we're done.
30$:					; Fall into CON$KEEPALIVE...

	.SBTTL	CON$KEEPALIVE
;++
; CON$KEEPALIVE - DETERMINE IF VENUS CONSOLE SOFTWARE IS STILL FUNCTIONING
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED PERIODICALLY TO DETERMINE IF THE VENUS CONSOLE
;	SOFTWARE IS STILL FUNCTIONING.  IT READS THE TIME-OF-DAY PROCESSOR
;	REGISTER, WHICH IS MAINTAINED BY THE CONSOLE SOFTWARE.  IF IT IS
;	NOT BEING UPDATED, THEN THE CONSOLE IS REBOOTED.
;
; INPUTS:
;	R3	- ADDRESS OF CRB
;
; IMPLICIT INPUTS:
;	THIS ROUTINE IS EXECUTED ONCE EVERY 'KEEPALIVE_TIME' SECONDS.
;
; IMPLICIT OUTPUTS:
;	THE VENUS CONSOLE MAY BE RE-BOOTED.
;
;--

CON$KEEPALIVE:
	PUSHL	R0			; Save a register.
	MFPR	#PR790$_TODR,R0		; Read the TODR register.
	CMPL	R0,W^TODR_VALUE		; Has the value changed?
	BEQL	20$			; Branch if not.	
	MOVL	R0,W^TODR_VALUE		; Save most recent value.
10$:	MOVL	#KEEPALIVE_TIME, -	; Re-set the timer so we are called
		W^KEEPALIVE_TIMER	; again.
	POPL	R0			; Restore the register.
	RSB
20$:
;
; Reboot the console, and log that we did it.
;
	MTPR	#1,#PR790$_CRBT		; Reboot the console.
	PUSHR	#^M<R1,R2>		; Save some registers.
	MOVL	#EMB$C_HD_LENGTH+1,R1	; Allocate a header plus one byte.
	JSB	G^ERL$ALLOCEMB		; Allocate space in the errorlog buffer.
	BLBC	R0,20$			; Branch if unable to allocate.
	MOVW	#EMB$C_CRBT, -		; Set entry type = console reboot.
		EMB$W_HD_ENTRY(R2)	;
	CLRB	EMB$W_HD_ENTRY+1(R2)	; Set flag = reboot attempted.
	JSB	G^ERL$RELEASEMB		; Release the errorlog data.
	POPR	#^M<R1,R2>		; Restore the registers.
	BRB	10$			; Join common exit code.

	.END
