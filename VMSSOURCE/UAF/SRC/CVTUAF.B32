MODULE CVTUAF (	%TITLE	'Convert Authorization File'
		MAIN = MAIN,
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Convert User Authorization File
!
! ABSTRACT:	Converts a Release 3 compatible SYSUAF.DAT to Release 4 format.
!		The new SYSUAF.DAT offsets are assumed.  The old offsets have
!		been renamed to OAF$etc...
!
! ENVIRONMENT:	Release 3 to Release 4 conversion procedures
!
! AUTHOR:	Chris Hume, CREATION DATE: 22-May-1979
!
! MODIFIED BY:
!
!	V03-005	BLS0333		Benn Schreiber		19-JUL-1984
!		If already in v4 format, just copy and upgrade selected
!		quotas for all accounts (unless greater).
!
!	V03-004	BLS0284		Benn Schreiber		 8-MAR-1984
!		Add mulitple areas for better performance, set jtquota
!		to 1024 if it comes up 0.
!
!	V03-003	ACG0388		Andrew C. Goldstein,	15-Jan-1984  18:29
!		Make password date zero if password is null
!
!	V03-002	ACG0385		Andrew C. Goldstein,	11-Jan-1984  21:28
!		Fix conversion of CLITABLES string; move OAFDEF to LIB$;
!		last minute UAF changes
!
!	V03-001	ACG0385		Andrew C. Goldstein,	27-Dec-1983  17:30
!		Adapt for V3 to V4 conversion
!
!--

LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'LIB$:OAFDEF';

FORWARD ROUTINE
    ADJUST_RECORD_FIELDS : NOVALUE,
    COPY_ADJUST_SELECTED : NOVALUE;		!copy uaf, only adjust selected fields

MACRO
    RETURN_IF_ERROR[] =
	BEGIN
	LOCAL RMSERR;
	(IF NOT (RMSERR = %REMAINING) THEN RETURN .RMSERR)
	END
	%;

LITERAL
    TRUE = 1;

MACRO
	COPY_PADDED (NAME) =
		COPY_PADDED1 (%EXPLODE (NAME))
		%,

	COPY_PADDED1 (C1, C2, C3, C4, C5) =
		COPY_PADDED2 (%STRING ('OAF$S', %REMAINING),
			      %STRING ('OAF$', C5, %REMAINING),
			      %STRING ('UAF$S', %REMAINING),
			      %STRING ('UAF$', C5, %REMAINING))
		%,

	COPY_PADDED2 (OLENGTH, ONAME, NLENGTH, NNAME) =
		CH$COPY (%NAME (OLENGTH), OAFBUF[%NAME (ONAME)],
			 ' ',
			 %NAME (NLENGTH), UAFBUF[%NAME (NNAME)])
		%,

	COPY_COUNTED (NAME) =
		COPY_COUNTED1 (%EXPLODE (NAME))
		%,

	COPY_COUNTED1 (C1, C2, C3, C4, C5) =
		COPY_COUNTED2 (%STRING ('OAF$S', %REMAINING),
			      %STRING ('OAF$', C5, %REMAINING),
			      %STRING ('UAF$S', %REMAINING),
			      %STRING ('UAF$', C5, %REMAINING))
		%,

	COPY_COUNTED2 (OLENGTH, ONAME, NLENGTH, NNAME) =
		CH$COPY (.VECTOR [OAFBUF[%NAME (ONAME)], 0;, BYTE]+1, OAFBUF[%NAME (ONAME)],
			 ' ',
			 %NAME (NLENGTH), UAFBUF[%NAME (NNAME)])
		%,
	PADDED_TO_COUNTED (NAME) =
		PADDED_TO_COUNTED1 (%EXPLODE (NAME))
		%,

	PADDED_TO_COUNTED1 (C1, C2, C3, C4, C5) =
		PADDED_TO_COUNTED2 (%STRING ('OAF$S', %REMAINING),
			      %STRING ('OAF$', C5, %REMAINING),
			      %STRING ('UAF$S', %REMAINING),
			      %STRING ('UAF$', C5, %REMAINING))
		%,

	PADDED_TO_COUNTED2 (OLENGTH, ONAME, NLENGTH, NNAME) =
		BEGIN
		LOCAL COUNT, P : REF VECTOR [,BYTE];
		P = OAFBUF[%NAME (ONAME)] + %NAME (OLENGTH);
		UNTIL .P[-1] GTRU ' '
		OR .P LEQA OAFBUF[%NAME (ONAME)]
		DO P = .P - 1;
		COUNT = .P - OAFBUF[%NAME (ONAME)];
		VECTOR [UAFBUF[%NAME (NNAME)], 0; , BYTE] = .COUNT;
		CH$COPY (.COUNT, OAFBUF[%NAME (ONAME)],
			 ' ',
			 %NAME (NLENGTH)-1, UAFBUF[%NAME (NNAME)]+1)
		END
		%;

EXTERNAL ROUTINE
	LIB$PUT_OUTPUT	: ADDRESSING_MODE (GENERAL);

LITERAL
	PRIVS0	= NOT (1^ $BITPOSITION (PRV$V_GRPNAM)
		    OR 1^ $BITPOSITION (PRV$V_ALLSPOOL)
		    OR 1^ $BITPOSITION (PRV$V_NOACNT)
		    OR 1^ $BITPOSITION (PRV$V_PRMCEB)
		    OR 1^ $BITPOSITION (PRV$V_PRMMBX)
		    OR 1^ $BITPOSITION (PRV$V_EXQUOTA)
		    OR 1^ $BITPOSITION (PRV$V_BUGCHK)
		    OR 1^ $BITPOSITION (PRV$V_PRMGBL)
		    OR 1^ $BITPOSITION (PRV$V_SHMEM)
		    OR 1^ $BITPOSITION (PRV$V_GROUP)
		    OR 1^ $BITPOSITION (PRV$V_TMPMBX)
		    OR 1^ $BITPOSITION (PRV$V_NETMBX)),
	PRIVS1	= NOT (1^ $BITPOSITION (PRV$V_GRPPRV)),
	NEWPRIV0= - $FIELDMASK (PRV$V_SHARE),
	NEWPRIV1= -1;

BIND
    DAY180	= UPLIT (-%X'D25B0000', NOT %X'8D71'),
    DAY30	= UPLIT (-%X'F8648000', NOT %X'1792');

OWN
    UAFBUF: BLOCK [UAF$C_LENGTH, BYTE],
    OAFBUF: BLOCK [OAF$C_LENGTH, BYTE],
    OUTBUF: BLOCK [80, BYTE],
    OUTDSC: VECTOR [2] INITIAL (80, OUTBUF),

    UAFKEY3: $XABKEY (			! XAB for owner identifier key
	KREF = 3,
	POS0 = $BYTEOFFSET (UAF$Q_PARENT_ID),
	SIZ0 = UAF$S_PARENT_ID,
	DTP  = BN8,
	FLG  = (CHG, DUP, NUL),
	KNM  = UPLIT BYTE ('Owner Identifier                '),
	IAN  = 2,
	DAN  = 2,
	LAN  = 2
	),

    UAFKEY2: $XABKEY (			! XAB for extended identifier key
	KREF = 2,
	POS0 = $BYTEOFFSET (UAF$L_UIC),
	SIZ0 = 8,
	DTP  = BN8,
	FLG  = (CHG, DUP),
	KNM  = UPLIT BYTE ('Extended User Identifier        '),
	IAN  = 2,
	DAN  = 2,
	LAN  = 2,
	NXT  = UAFKEY3
	),

    UAFKEY1: $XABKEY (			! XAB for UIC key
	KREF = 1,			! alternate key
	POS0 = $BYTEOFFSET (UAF$L_UIC),
	SIZ0 = 4,
	DTP  = BN4,
	FLG  = (CHG, DUP),
	KNM  = UPLIT BYTE ('UIC                             '),
	IAN  = 2,
	DAN  = 2,
	LAN  = 2,
	NXT  = UAFKEY2
	),

    UAFKEY0: $XABKEY (			! XAB for USERNAME key
	KREF = 0,			! primary key
	POS0 = $BYTEOFFSET (UAF$T_USERNAME),
	SIZ0 = UAF$S_USERNAME,
	KNM  = UPLIT BYTE ('Username                        '),
	DAN  = 0,
	IAN  = 1,
	LAN  = 1,
	NXT  = UAFKEY1
	),


    UAFALL2 : $XABALL (
	AID = 2,
	AOP = CBT,
	ALQ = 12,
	BKZ = 3,
	DEQ = 18,
	NXT = UAFKEY0
	),
 
   UAFALL1: $XABALL (
	AID  = 1,
	AOP  = CBT,
	ALQ  = 3,
	BKZ  = 3,
	DEQ  = 3,
	NXT  = UAFALL2
	),

    UAFALL0: $XABALL (			! XAB for UAF allocation
	AID  = 0,
	AOP  = CBT,
	ALQ  = 16,
	BKZ  = 3,
	DEQ  = 12,
	NXT  = UAFALL1
	),
    UAFPRO: $XABPRO (			! XAB for file protection
	PRO  = (RWE, RWE, RWE,),	! deny world access
	NXT  = UAFALL0
	),

    UAFFAB: $FAB (			! FAB for work file
	FAC = PUT,			! access types
	FNM = 'NEWUAF',			! temporary file name
	DNM = '.DAT',
	SHR = NIL,
	ORG = IDX,			! indexed operations
	RFM = VAR,
	MRS = UAF$C_LENGTH,		! maximum record size
	XAB = UAFPRO			! file protection XAB
	),

    UAFRAB: $RAB (			! RAB for temporary file
	RBF = UAFBUF,
	FAB = UAFFAB
	),

    OAFKEY2: $XABKEY (			! XAB to read old UAF key
	KREF = 2
	),

    OAFKEY1: $XABKEY (			! XAB to read old UAF key
	KREF = 1,
	NXT  = OAFKEY2
	),

    OAFKEY0: $XABKEY (			! XAB to read old UAF key
	KREF = 0,
	NXT  = OAFKEY1
	),

    OAFFAB: $FAB (			! FAB for old UAF file
	FAC = GET,			! read only
	FNM = 'OLDUAF',
	DNM = '.DAT',
	XAB = OAFKEY0
	),

    OAFRAB: $RAB (			! RAB for old UAF
	RAC = SEQ,
	KRF = 0,			! key of reference
	UBF = OAFBUF,
	USZ = OAF$C_LENGTH,
	FAB = OAFFAB
	);

ROUTINE MAIN =
BEGIN

LOCAL
	RMSERR,
	LENGTH,
	NEW_FLAG,
	DATE		: VECTOR [2],
	USER_DATA	: REF VECTOR [,BYTE],
	USER_LENGTH;

$GETTIM (TIMADR = DATE);
!
! Open the old UAF for input
!
RETURN_IF_ERROR ($OPEN (FAB = OAFFAB));
RETURN_IF_ERROR ($CONNECT (RAB = OAFRAB));
!
! Validate the keys of the UAF, checking if it is a new format,
! and then for old format validity.
!
NEW_FLAG = 0;
IF  .OAFKEY0[XAB$W_POS0] EQL $BYTEOFFSET (UAF$T_USERNAME)
AND .OAFKEY0[XAB$B_SIZ0] EQL UAF$S_USERNAME
AND .OAFKEY1[XAB$W_POS0] EQL $BYTEOFFSET (UAF$L_UIC)
AND .OAFKEY1[XAB$B_SIZ0] EQL 4
AND .OAFKEY2[XAB$W_POS0] EQL $BYTEOFFSET (UAF$L_UIC)
AND .OAFKEY2[XAB$B_SIZ0] EQL 8
THEN
    BEGIN
    NEW_FLAG = 1;
!    LIB$PUT_OUTPUT ($DESCRIPTOR ('UAF is already converted'));
!    RETURN STS$M_INHIB_MSG;
    END
ELSE
    BEGIN
	IF  .OAFKEY0[XAB$W_POS0] NEQ $BYTEOFFSET (OAF$T_USERNAME)
	    OR  .OAFKEY0[XAB$B_SIZ0] NEQ OAF$S_USERNAME
	    OR  .OAFKEY1[XAB$W_POS0] NEQ $BYTEOFFSET (OAF$L_UIC)
	    OR  .OAFKEY1[XAB$B_SIZ0] NEQ 4
	    OR  .OAFKEY2[XAB$W_POS0] NEQ $BYTEOFFSET (OAF$W_MEM)
	    OR  .OAFKEY2[XAB$B_SIZ0] NEQ 2
	THEN
	    BEGIN
		LIB$PUT_OUTPUT ($DESCRIPTOR ('UAF has invalid format'));
		RETURN STS$M_INHIB_MSG;
		END;
	END;
!
! Create the new UAF.
!
IF .NEW_FLAG
THEN
    UAFALL0[XAB$L_ALQ] = .OAFFAB[FAB$L_ALQ]
ELSE
    UAFALL0[XAB$L_ALQ] = .OAFFAB[FAB$L_ALQ] / 2 + .OAFFAB[FAB$L_ALQ];
RETURN_IF_ERROR ($CREATE (FAB = UAFFAB));
RETURN_IF_ERROR ($CONNECT (RAB = UAFRAB));

!
! If uaf already in new format, simply copy and adjust the selected
! fields.
!
IF .NEW_FLAG
THEN
    RETURN (COPY_ADJUST_SELECTED(); TRUE);
!
! Only do the upgrade if an old format uaf
!
WHILE (RMSERR = $GET (RAB = OAFRAB))
DO
    BEGIN
    CH$FILL (0, UAF$C_LENGTH, UAFBUF);
    UAFBUF[UAF$B_RTYPE] =            UAF$C_USER_ID;
    UAFBUF[UAF$B_VERSION] =          UAF$C_VERSION1;

    UAFBUF[UAF$B_ENCRYPT] =          .OAFBUF[OAF$B_ENCRYPT];
    UAFBUF[UAF$L_FLAGS] =            .OAFBUF[OAF$B_FLAGS];
    UAFBUF[UAF$W_MAXDETACH] =        .OAFBUF[OAF$B_MAXDETACH];
    UAFBUF[UAF$W_MAXACCTJOBS] =      .OAFBUF[OAF$B_MAXGRPROC];
    UAFBUF[UAF$W_MAXJOBS] =          .OAFBUF[OAF$B_MAXPROC];
    UAFBUF[UAF$B_LOCAL_ACCESS_P] =   .OAFBUF[OAF$L_PDAYHOURS];
    UAFBUF[UAF$B_LOCAL_ACCESS_S] =   .OAFBUF[OAF$L_SDAYHOURS];
    UAFBUF[UAF$B_DIALUP_ACCESS_P] =  .OAFBUF[OAF$L_PDAYHOURS];
    UAFBUF[UAF$B_DIALUP_ACCESS_S] =  .OAFBUF[OAF$L_SDAYHOURS];
    UAFBUF[UAF$B_REMOTE_ACCESS_P] =  .OAFBUF[OAF$L_PDAYHOURS];
    UAFBUF[UAF$B_REMOTE_ACCESS_S] =  .OAFBUF[OAF$L_SDAYHOURS];
    UAFBUF[UAF$B_BATCH_ACCESS_P] =   .OAFBUF[OAF$L_PDAYHOURS];
    UAFBUF[UAF$B_BATCH_ACCESS_S] =   .OAFBUF[OAF$L_SDAYHOURS];
    UAFBUF[UAF$B_NETWORK_ACCESS_P] = .OAFBUF[OAF$L_PDAYHOURS];
    UAFBUF[UAF$B_NETWORK_ACCESS_S] = .OAFBUF[OAF$L_SDAYHOURS];
    UAFBUF[UAF$B_PRI] =              .OAFBUF[OAF$B_PRI];
    UAFBUF[UAF$B_PRIMEDAYS] =        .OAFBUF[OAF$B_PRIMEDAYS];
    UAFBUF[UAF$B_QUEPRI] =           .OAFBUF[OAF$B_QUEPRI];
    UAFBUF[UAF$W_ASTLM] =            .OAFBUF[OAF$W_ASTLM];
    UAFBUF[UAF$W_BIOLM] =            .OAFBUF[OAF$W_BIOLM];
    UAFBUF[UAF$L_DFWSCNT] =          .OAFBUF[OAF$W_DFWSCNT];
    UAFBUF[UAF$W_DIOLM] =            .OAFBUF[OAF$W_DIOLM];
    UAFBUF[UAF$W_ENQLM] =            .OAFBUF[OAF$W_ENQLM];
    UAFBUF[UAF$W_FILLM] =            .OAFBUF[OAF$W_FILLM];
    UAFBUF[UAF$W_PRCCNT] =           .OAFBUF[OAF$W_PRCCNT];
    UAFBUF[UAF$W_SALT] =             .OAFBUF[OAF$W_SALT];
    UAFBUF[UAF$W_SHRFILLM] =         .OAFBUF[OAF$W_SHRFILLM];
    UAFBUF[UAF$W_TQCNT] =            .OAFBUF[OAF$W_TQCNT];
    UAFBUF[UAF$L_WSEXTENT] =         .OAFBUF[OAF$W_WSEXTENT];
    UAFBUF[UAF$L_WSQUOTA] =          .OAFBUF[OAF$W_WSQUOTA];
    UAFBUF[UAF$L_BYTLM] =            .OAFBUF[OAF$L_BYTLM];
    IF .UAFBUF[UAF$L_BYTLM] EQL 0
    THEN
	UAFBUF[UAF$L_BYTLM] =        .OAFBUF[OAF$W_BYTLM];
    UAFBUF[UAF$L_CPUTIM] =           .OAFBUF[OAF$L_CPUTIM];
    UAFBUF[UAF$L_JTQUOTA] =          .OAFBUF[OAF$L_JTQUOTA];
    UAFBUF[UAF$L_PBYTLM] =           .OAFBUF[OAF$L_PBYTLM];
    UAFBUF[UAF$L_PGFLQUOTA] =        .OAFBUF[OAF$L_PGFLQUOTA];
    UAFBUF[UAF$L_PWD] =              .OAFBUF[OAF$L_PWD];
    UAFBUF[UAF$L_UIC] =              .OAFBUF[OAF$L_UIC];

    UAFBUF[UAF$V_DISACNT] = 0;

    IF .BITVECTOR [OAFBUF[OAF$B_PDAYFLAGS], $BITPOSITION (OAF$V_DISDIALUP)]
    THEN UAFBUF[UAF$B_DIALUP_ACCESS_P] = -1;
    IF .BITVECTOR [OAFBUF[OAF$B_SDAYFLAGS], $BITPOSITION (OAF$V_DISDIALUP)]
    THEN UAFBUF[UAF$B_DIALUP_ACCESS_S] = -1;
    IF .BITVECTOR [OAFBUF[OAF$B_PDAYFLAGS], $BITPOSITION (OAF$V_DISNETWORK)]
    THEN UAFBUF[UAF$B_REMOTE_ACCESS_P] = -1;
    IF .BITVECTOR [OAFBUF[OAF$B_SDAYFLAGS], $BITPOSITION (OAF$V_DISNETWORK)]
    THEN UAFBUF[UAF$B_REMOTE_ACCESS_S] = -1;

    IF .OAFBUF[OAF$V_DISACNT]
    THEN
	BEGIN
	UAFBUF[UAF$B_LOCAL_ACCESS_P] = -1;
	UAFBUF[UAF$B_LOCAL_ACCESS_S] = -1;
	UAFBUF[UAF$B_DIALUP_ACCESS_P] = -1;
	UAFBUF[UAF$B_DIALUP_ACCESS_S] = -1;
	UAFBUF[UAF$B_REMOTE_ACCESS_P] = -1;
	UAFBUF[UAF$B_REMOTE_ACCESS_S] = -1;
	END;

    IF (PRIVS0 AND .(OAFBUF[OAF$Q_PRIV]+0)) NEQ 0
    OR (PRIVS1 AND .(OAFBUF[OAF$Q_PRIV]+4)) NEQ 0
    THEN
	BEGIN
	UAFBUF[UAF$B_PWD_LENGTH] =       8;
	CH$MOVE (8, DAY30, UAFBUF[UAF$Q_PWD_LIFETIME]);
	END
    ELSE
	BEGIN
	UAFBUF[UAF$B_PWD_LENGTH] =       6;
	CH$MOVE (8, DAY180, UAFBUF[UAF$Q_PWD_LIFETIME]);
	END;

    IF (.(OAFBUF[OAF$Q_PWD]+0) OR .(OAFBUF[OAF$Q_PWD]+4)) NEQ 0
    THEN CH$MOVE (UAF$S_PWD_DATE, DATE, UAFBUF[UAF$Q_PWD_DATE]);
    CH$MOVE (UAF$S_PRIV, OAFBUF[OAF$Q_PRIV], UAFBUF[UAF$Q_PRIV]);
    CH$MOVE (UAF$S_PRIV, OAFBUF[OAF$Q_PRIV], UAFBUF[UAF$Q_DEF_PRIV]);
    CH$MOVE (UAF$S_PWD, OAFBUF[OAF$Q_PWD], UAFBUF[UAF$Q_PWD]);
    COPY_PADDED ('UAF$T_ACCOUNT');
    PADDED_TO_COUNTED ('UAF$T_CLITABLES');
    PADDED_TO_COUNTED ('UAF$T_DEFCLI');
    COPY_COUNTED ('UAF$T_DEFDEV');
    COPY_COUNTED ('UAF$T_DEFDIR');
    COPY_COUNTED ('UAF$T_LGICMD');
    PADDED_TO_COUNTED ('UAF$T_OWNER');
    COPY_PADDED ('UAF$T_USERNAME');

    IF  (   (NEWPRIV0 AND .(OAFBUF[OAF$Q_PRIV]+0)) NEQ 0
	 OR (NEWPRIV1 AND .(OAFBUF[OAF$Q_PRIV]+4)) NEQ 0)
    AND (   .(OAFBUF[OAF$Q_PRIV]+0) NEQ -1
	 OR .(OAFBUF[OAF$Q_PRIV]+4) NEQ -1)
    THEN
	BEGIN
	OUTDSC[0] = 80;
	$FAO ($DESCRIPTOR ('User !AD has undefined privileges set'),
	      OUTDSC[0],
	      OUTDSC[0],
	      OAF$S_USERNAME,
	      OAFBUF[OAF$T_USERNAME]
	      );
	LIB$PUT_OUTPUT (OUTDSC[0]);
	END;

    LENGTH = UAF$C_FIXED;
    IF .OAFBUF[OAF$W_USRDATOFF] NEQ 0
    THEN
	BEGIN
	USER_DATA = OAFBUF + .OAFBUF[OAF$W_USRDATOFF];
	IF USER_DATA+1 LEQA OAFBUF + .OAFRAB[RAB$W_RSZ]
	THEN
	    BEGIN
	    USER_LENGTH = .USER_DATA[0] + 1;
	    IF USER_DATA + .USER_LENGTH LEQA OAFBUF + .OAFRAB[RAB$W_RSZ]
	    AND .USER_LENGTH LEQU UAF$C_LENGTH - UAF$C_FIXED
	    THEN
		BEGIN
		CH$MOVE (.USER_LENGTH, .USER_DATA, UAFBUF + UAF$C_FIXED);
		LENGTH = .LENGTH + .USER_LENGTH;
		UAFBUF[UAF$W_USRDATOFF] = UAF$C_FIXED;
		END;
	    END;
	END;
    UAFRAB[RAB$W_RSZ] = .LENGTH;
    ADJUST_RECORD_FIELDS();		!Ensure values at least our minimums
    RETURN_IF_ERROR ($PUT (RAB = UAFRAB));
    END;
IF .RMSERR NEQ RMS$_EOF THEN RETURN .RMSERR;
RETURN_IF_ERROR ($CLOSE (FAB = UAFFAB));
$CLOSE (FAB = OAFFAB)
END;

ROUTINE ADJUST_RECORD_FIELDS : NOVALUE=
!++
! FUNCTIONAL DESCRIPTION:
!
!	Checks the currently converted record to ensure that
!	values are at least the minimums we want.
!
!--
BEGIN
IF .UAFBUF[UAF$W_ASTLM] LEQU 24
THEN
    UAFBUF[UAF$W_ASTLM] = 24;
IF .UAFBUF[UAF$W_BIOLM] LEQU 18
THEN
    UAFBUF[UAF$W_BIOLM] = 18;
IF .UAFBUF[UAF$W_DIOLM] LEQU 18
THEN
    UAFBUF[UAF$W_DIOLM] = 18;
IF .UAFBUF[UAF$L_JTQUOTA] LEQU 1024
THEN
    UAFBUF[UAF$L_JTQUOTA] = 1024;
IF .UAFBUF[UAF$W_ENQLM] LEQU 30
THEN
    UAFBUF[UAF$W_ENQLM] = 30;
IF .UAFBUF[UAF$L_BYTLM] LEQU 8192
THEN
    UAFBUF[UAF$L_BYTLM] = 8192;

RETURN;
END;

ROUTINE COPY_ADJUST_SELECTED : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine copies an already-converted uaf, and adjusts
!	fields as needed.
!--
BEGIN
LOCAL
    STATUS;

WHILE (STATUS = $GET(RAB=OAFRAB)) NEQ RMS$_EOF
DO
    BEGIN
    IF NOT .STATUS
    THEN
	RETURN SIGNAL(.STATUS);
    CH$MOVE(.OAFRAB[RAB$W_RSZ],OAFBUF,UAFBUF);
    UAFRAB[RAB$W_RSZ] = .OAFRAB[RAB$W_RSZ];
    ADJUST_RECORD_FIELDS();
    STATUS = $PUT(RAB=UAFRAB);
    IF NOT .STATUS
	THEN SIGNAL(.STATUS);
    END;
STATUS = $CLOSE(FAB=UAFFAB);
IF NOT .STATUS
THEN
    SIGNAL(.STATUS);
$CLOSE(FAB=OAFFAB);
RETURN;
END;
END
ELUDOM
