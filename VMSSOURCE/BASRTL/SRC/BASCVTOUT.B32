MODULE BAS$CVT_OUT (			! Convert single or double float to Basic E, F, or G
		IDENT = '1-054'		! File:BASCVTOUT.B32 Edit: STAN1054
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY: VAX-11 BASIC support
!
! ABSTRACT:
!
!	Convert a double or single precision floating point number to E, F, or
!	G format for VAX-11 BASIC.  These routines will support PRINT, PRINT USING,
!	NUM$, NUM1$, STR$, and FORMAT$.  For E and F format, if the input value
!	is single precision, a maximum of 6 significant digits are returned; for
!	a double precision value, a maximum of 16 significant digits are returned.
!
! ENVIRONMENT: User mode - AST reentrant.
!
! AUTHOR: Donald Petersen, CREATION DATE: 26-Jun-79
!
! MODIFIED BY:
!
!	DGP, 26-Jun-79 : VERSION 1
! 1-001	- original
! 1-003 - Change algorithm for determinig the number of significant digits
!	  we ask the kernel routine for.  DGP 16-Jul-79
! 1-004 - More work on Print Using.  DGP  23-Jul-79
! 1-005 - Add E formatting for Print Using.  DGP 27-Jul-79
! 1-006 - Change the conversion macros to JSB routines to save space. DGP 30-Jul-79
! 1-007 - Continuing development of E format.  DGP 31-Jul-79
! 1-008 - Add optional arg. to BAS$CVT_OUT_D_T for number of digits in F format
!	  before swiching to E.  DGP 07-Sep-79
! 1-009 - BAS$CVT_OUT_F_F does not set RT_RND when calling kernel conversion
!	  routine if V_FLT_DEC_PT is set in input flags.  DGP 10-Sep-79
! 1-010 - Load KERNEL_BLOCK [STRING_PTR] before checking for zero.  DGP
!	  21-Sep-79
! 1-011 - Accept currency, radix point, and digit separator symbols as
!	  parameters in order to allow the BASIC user to change them.  Can't
!	  do the translation here because the format interpreter needs the
!	  lengths of some of the symbols.  DGP 30-Oct-79
! 1-012 - Scale factor is only a byte.  DGP 25-Nov-79
! 1-013 - Fix bug in scaling in BAS$CVT_OUT_D_F.  DGP 06-Dec-79
! 1-014 - When calling the kernal conversion routine, bias 'right round' by
!	  the scale factor in BAS$CVT_OUT_D_F.  DGP 03-Mar-80
! 1-015 - Put the BUILTIN ACTUALCOUNT into the routines that need it, rather
!	  than at the module level, in anticipation of the next BLISS compiler,
!	  which will require it there.  While we are here, make some
!	  improvements in the source text.  Note that this edit changes
!	  no code.  JBS 27-Aug-1980
! 1-016 - FIX BAS$CVT_OUT_D_G, PLAIN_E_FORM_11 and PLAIN_F_FORM_11 to return status.  FM 1-OCT-80
! 1-017 - Fix the PRINT USING, '$$##.##', .01   REJ & FM 1-OCT-80
! 1-018 - Fix bug of some fraction numbers printing out as zero and correct
!	  error checking for E format with negative numbers. Corresponds
!	  to bug version 14C, 14D, and 14E.  DGP 23-Feb-81
! 1-019 - Add support for G floating and H floating.  PLL 21-Aug-81
! 1-020 - Add PLAIN_E_HFLOAT and FANCY_E_HFLOAT.  PLL 28-Aug-81
! 1-021 - Add F format for H floating.  PLL 8-Sep-81
! 1-022 - Fix a bug in fancy_e_hfloat (doesn't handle zero correctly). PLL 20-Oct-81
! 1-023 - Add PLAIN_E_GFLOAT.  PLL 22-Oct-81
! 1-024 - E format for h floating should round on the fifth digit. Also,
!	  fix PLAIN_F_FORM_11 and FANCY_F_FORM_11 so that NUM1$ of g or h
!	  floating can print out all 308 or 4932 digits.  PLL 23-Oct-81
! 1-025 - The last edit broke NUM1$ for double, so fix PLAIN_F and FANCY_F. PLL 
!	  26-Oct-81
! 1-026 - Add support for formatting characters <CD>, <%> and <0>.  PLL 25-Nov-81
! 1-027 - Collapse some routines into others, to cut down on the size of the
!	  module.  PLL 16-Dec-81
! 1-028 - BAS$CVT_OUT_x_F routines should not require all parameters.  PLL 8-Jan-82
! 1-029 - Fix typo in last edit.  PLL 8-Jan-1982
! 1-030 - Add support for packed decimal.  PLL 12-Jan-1982
! 1-031 - BAS$CVT_OUT_x_G routines should not assume an optional parameter 
!	  exists.  PLL 3-Feb-82
! 1-032 - Attempt to fix the case of packed decimal zero.  PLL 12-Feb-82
! 1-033 - BAS$CVT_P_T is no longer used so remove EXTERNAL declaration.  PLL 17-Feb-82
! 1-034 - Add nooptimize to list of switches.  This is temporary - the Bliss
!	  compiler used for VMS 3.0 optimizes away a line of code.  PLL 22-Feb-82
! 1-035 - Fix bug in PLAIN_E_FORM_11 - max digits is 5 for hfloat.  PLL 9-Mar-1982
! 1-036 - Fix bug in Print Using of numbers with trailing zeroes (ex. 100).
!	  Leading_str_desc length (used to calculate trailing zeroes) must be
!	  initialized to zero.  PLL 10-Mar-1982
! 1-037 - Negative numbers should not print a minus sign when <CD> was specified
!	  by the format string (Print Using).  PLL 10-Mar-1982
! 1-038 - OTSLNK.REQ should be required from RTLIN:.  PLL 16-Mar-82
! 1-039 - Fix length of zero_str_desc in Fancy_e_form_11.  It should never be
!	  negative.  Remove nooptimize.  PLL 22-Mar-1982
! 1-040 - The case ".##", .001 should round, not produce % .001 (PRINT
!	  USING).  PLL 17-Jun-1982
! 1-041 - Fix the case "#.##", .001.  (Last edit broke this.)  PLL 21-Jun-1982
! 1-042 - The case ".##", 0 should produce .00, not %0.  PLL 27-Jul-1982
! 1-043 - Fix the case "###", 0, which the last edit broke.  Two macros for
!	  zero are needed - one for the case of a fractional format, and one
!	  for formats with an integer part.  
!	  Also fix COMMON_F for NUM1$(0), which was producing ".0" instead of
!	  "0".  PLL 2-Sep-1982
! 1-044 - the macros introduced in edit 043 should set the entire value to
!	  zeros, not just the first byte.  MDL 1-Dec-1982
! 1-045 - fix the case "#.#### ", very small number.  We would end up passing
!	  a string descriptor with a negative length to STR$CONCAT when called
!	  from COMMON_F.  MDL 2-Dec-1982
! 1-046 - Local storage KERNEL_BLOCK should be initialized upon entry into 
!	  the COMMON_E, COMMON_F and COMMON_G routines; there are code paths 
!	  that can reference fields in it before it is set up, and would 
!	  therefore get garbage unless it is initialized.  MDL 7-Dec-1982
! 1-047 - change logic that checks to see if a number is effectively zero
!	  very slightly in order to fix bug of printing negative zero.
!	  MDL 8-Dec-1982
! 1-048 - change calculation for number of needed leading zeros slightly
!	  in FANCY_F_FORM_11 routine.  MDL 10-Dec-1982
! 1-049 - fix minor bug in edit 1-044; macro PUT_OUT_ZERO should zero out
!	  NO_INT_DIGITS + NO_FRAC_DIGITS, not just NO_FRAC_DIGITS.  Also,
!	  back out edit 1-048, it broke too many things.  MDL 10-Jan-1983
! 1-050 - add ANSI print support code. The only difference is in E-format
!	  numbers, where the significand is between 1 & 10 rather than 0 & 1.
!	  See PLAIN_E_FORM11 for details.  MDL 29-Mar-1983
! 1-051 - repair minor bug introduced in edit 1-050.  cannot assume that
!	  OTS$$AA_CUR_LUB is defined.  MDL 20-Apr-1983
! 1-052 - for PRINT USING, a currency field can end with <CD> as well as
!	  with a minus sign in order to print a negative number.
!	  MDL 27-Sep-1983
! 1-053 - correct formatting for DECIMAL numbers that occupy less places
!	  than reserved.  MDL 24-Feb-1984
! 1-054 - Remove informational errors. STAN 24-Jul-1984.
!--

!<BLF/PAGE>

!
! SWITCHES
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES
!

REQUIRE 'RTLIN:OTSLNK';

REQUIRE 'RTLML:OTSLUB';

LINKAGE
    JSB_E_FORMAT = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3,
	REGISTER = 4, REGISTER = 5, REGISTER = 6, REGISTER = 7, REGISTER = 8,
	REGISTER = 9, REGISTER = 10) : PRESERVE (11),

    JSB_F_FORMAT = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3,
	REGISTER = 4, REGISTER = 5, REGISTER = 6, REGISTER = 7, REGISTER = 8,
	REGISTER = 9, REGISTER = 10, REGISTER = 11),

    JSB_G_FORMAT = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3,
	REGISTER = 4, REGISTER = 5, REGISTER = 6) : PRESERVE (7, 8, 9, 10, 11);

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$CVT_OUT_F_E,				! Convert float to E format
    BAS$CVT_OUT_D_E,				! Convert double to E format
    BAS$CVT_OUT_F_F,				! Convert float to F format
    BAS$CVT_OUT_D_F,				! Convert double to F format
    BAS$CVT_OUT_D_G,				! Convert double to G format
    BAS$CVT_OUT_G_E,				! Convert gfloat to E format
    BAS$CVT_OUT_G_F,				! Convert gfloat to F format
    BAS$CVT_OUT_H_E,				! Convert hfloat to E format
    BAS$CVT_OUT_G_G,				! Convert gfloat to G format
    BAS$CVT_OUT_H_G,				! Convert hfloat to G format
    BAS$CVT_OUT_H_F,				! Convert hfloat to F format
    BAS$CVT_OUT_P_F,				! Convert packed to F format
    BAS$CVT_OUT_P_E,				! Convert packed to E format
    BAS$CVT_OUT_P_G,				! Convert packed to G format
    COMMON_E : JSB_E_FORMAT,			! E processing common to all
						!  data types
    COMMON_F : JSB_F_FORMAT,			! F processing common to all
						!  data types
    COMMON_G : JSB_G_FORMAT,			! G processing common to all
						!  data types
    FANCY_F_FORM_11 : JSB_FORMAT_A11 NOVALUE,	! F format for PRINT USING
    FANCY_E_FORM_11 : JSB_FORMAT_A11 NOVALUE,	! E format for PRINT USING
    PLAIN_E_FORM_11 : JSB_FORMAT_A6,		! E format for STR$, NUM$, and PRINT
    PLAIN_F_FORM_11 : JSB_FORMAT_A6;		! F format for STR$, NUM$, NUM1$, and PRINT

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';

LIBRARY 'RTLSTARLE';

!
! MACROS:
!

MACRO
    RT_RND =
 0, 0, 32, 0%,					! Value for right round
    OFFSET =
 4, 0, 32, 0%,					! Offset to first non-zero digit
    						! in string returned
    DEC_EXP =
 8, 0, 32, 1%,					! Decimal exponent
    SIGN =
 12, 0, 32, 1%,					! Sign of returned value
    STRING_ADDR =
 16, 0 , 32, 0%,				! String address
    SIG_DIGITS =
 20, 0 , 32, 0%,				! No. of significant digits
    CONV_FLAGS =
 24, 0, 32, 0%,					! Flags
    KERNEL_PTR =
 36, 0, 0, 0%;					! Addr of block for kernel routine

!<BLF/MACRO>

MACRO
    PUT_OUT_ZERO =
	BEGIN
	KERNEL_BLOCK [OFFSET] = 0;
	KERNEL_BLOCK [DEC_EXP] = 1;
	KERNEL_BLOCK [SIGN] = 0;
	KERNEL_BLOCK [SIG_DIGITS] = 1;
	NO_DIGITS = 1;
	(.KERNEL_BLOCK [STRING_ADDR])<0, 8> = %C'0';
	CH$FILL (%C'0', .NO_INT_DIGITS + .NO_FRAC_DIGITS, CH$PTR(.KERNEL_BLOCK [STRING_ADDR]) );
	END
    %;
MACRO
    PUT_OUT_ZERO_FRACT =
	BEGIN
	KERNEL_BLOCK [OFFSET] = 0;
	KERNEL_BLOCK [DEC_EXP] = 0;
	KERNEL_BLOCK [SIGN] = 0;
	KERNEL_BLOCK [SIG_DIGITS] = 1;
	NO_DIGITS = 1;
	(.KERNEL_BLOCK [STRING_ADDR])<0, 8> = %C'0';
	CH$FILL (%C'0', .NO_FRAC_DIGITS, CH$PTR(.KERNEL_BLOCK [STRING_ADDR]) );
	END
    %;

!<BLF/PAGE>


MACRO
    INITIALIZE_DESC =

	BIND
	    DOT = UPLIT (BYTE ('.')),
	    STAR = UPLIT ( REP K_RANGE OF BYTE ('*')),
	    MINUS = UPLIT (BYTE ('-')),
	    BLANK = UPLIT (BYTE (' ')),
	    E = UPLIT (BYTE ('E')),
	    BLANKS = UPLIT ( REP K_RANGE OF BYTE (' ')),
	    ZEROES = UPLIT ( REP K_RANGE OF BYTE ('0'));

	IF .E_D EQL 0
	THEN
	    BEGIN
	    M_D = MINUS;
	    D_D = DOT;
	    B_D = BLANK;
	    E_D = E;
	    END

    %;

!<BLF/NOMACRO>

BUILTIN
    CVTLP,					! Convert long to packed
    CVTPS,					! Convert packed to leading sign
    CMPP;					! Compare packed

!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (BAS);
!
! EQUATED SYMBOLS:
!

LITERAL
    V_RT_RND = 1^25,				! right round bit for kernel routine
    K_TMP_STR_LEN_G = 25,			! len. of gfloat string for kernel routine
    K_TMP_STR_LEN_H = 50,			! len. of hfloat string for kernel routine
    K_TMP_STR_LEN_D = 25,			! len. of double string for kernel output
    K_TMP_STR_LEN_F = 17,			! len. of float string for kernel output
    K_RANGE = 38,				! the exponent of the largest floating pt.
    						! number
    K_G_RANGE = 308,				! largest exp. for g floating
    K_H_RANGE = 4932,				! largest exp. for h floating
    K_P_RANGE = 4932,				! largest exp. for packed
    V_STRIP_SPACES = 1,				! bit flag - strip leading and trailing spaces
    V_TRAILING_SIGN = 2,			! bit flag - trailing sign
    V_COMMA = 4,				! bit flag - insert commas after every 3 digits
    V_CURRENCY = 8,				! bit flag - float the currency symbol
    V_STAR = 16,				! bit flag - asterisk fill to the left
    V_FLT_DEC_PT = 32,				! bit flag - float the decimal pt. in F format
    V_PERIOD = 64,				! bit flag - insert a period
    V_SUPPRESS_ZERO = 4096,			! bit flag - suppress zeroes
    V_LEADING_ZERO = 8192,			! bit flag - print leading zeroes
    V_CR_DR = 16384,				! bit flag - credit/debit
    V_ANSI_PRINT = 32768,			! bit flag - program is /ANSI
    K_NUM_F_SIG_DIG = 6,			! number of significant digits returned
    						! from a single precision conversion
    K_NUM_D_SIG_DIG = 16,			! number of significant digits returned
    						! from a double precision conversion
    K_NUM_G_SIG_DIG = 15,			! number of significant digits returned
						! from a g float conversion
    K_NUM_H_SIG_DIG = 33,			! number of significant digits returned
						! from an h float conversion
    K_NUM_P_SIG_DIG = 31,			! max number of significant digits
						! in a packed decimal number
    K_KERNEL_BLK_SZ = 36;			! size in bytes of kernel routine parameter block

BIND
    PACKED_ZERO = UPLIT BYTE (REP 15 OF (%X'00'),%X'0C');

!
! OWN STORAGE:
!

OWN
    DOT_DESC : INITIAL (%X'010E0001'),
    D_D : INITIAL (0),
    MINUS_DESC : INITIAL (%X'010E0001'),
    M_D : INITIAL (0),
    NULL_DESC : INITIAL (%X'010E0000'),
    N_D,
    BLANK_DESC : INITIAL (%X'010E0001'),
    B_D : INITIAL (0),
    E_DESC : INITIAL (%X'010E0001'),
    E_D : INITIAL (0);

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$STOP : NOVALUE,				! signal general errors
    BAS$$STOP : NOVALUE,			! signal errors and stop
    STR$CONCAT,					! String concatenate
    STR$FREE1_DX,				! dealloc dynamic string
    STR$DUPL_CHAR,				! create a string of chars
    OTS$$CVT_H_T_R8 : JSB_CVT_KERNEL,		! OTS kernel conversion routines
    OTS$$CVT_G_T_R8 : JSB_CVT_KERNEL,		! OTS kernel conversion routine
    OTS$$CVT_D_T_R8 : JSB_CVT_KERNEL;		! OTS kernel conversion routine

EXTERNAL LITERAL
    BAS$K_PRIUSIFOR : UNSIGNED (8),		! Print Using Format error
    OTS$_FATINTERR;				! Fatal internal RTL error


GLOBAL ROUTINE BAS$CVT_OUT_F_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a single precision number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 6 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rf.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	K_ARG_COUNT = 9;

    BUILTIN
	ACTUALCOUNT;

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LOCAL
	STATUS;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    STATUS = COMMON_E (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
	BAS_OUT_STR [0], 0, .CURRENCY, .DIGIT_SEP, .RADIX_PT,
	DSC$K_DTYPE_F);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_F_E


GLOBAL ROUTINE BAS$CVT_OUT_D_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a double precision number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 16 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[BAS_SCALE_FAC.rb.v]	Basic scale factor in a range of 0 to -6
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_POINT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_ARG_COUNT = 10;

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    STATUS = COMMON_E (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
	BAS_OUT_STR [0], .BAS_SCALE_FAC, .CURRENCY, .DIGIT_SEP, .RADIX_PT,
	DSC$K_DTYPE_D);

    RETURN .STATUS;
    END;					! End of BAS$CVT_OUT_D_E


GLOBAL ROUTINE BAS$CVT_OUT_F_F (		!
	VALUE,					!
	NO_INT_DIGITS,				!
	NO_FRAC_DIGITS,				!
	FLAGS,					!
	BAS_OUT_STR_LEN,			!
	BAS_OUT_STR,				!
	CURRENCY,				!
	DIGIT_SEP,				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a single precision number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 6 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rf.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		The value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    LITERAL
	K_ARG_COUNT = 9;

    IF ACTUALCOUNT () NEQ K_ARG_COUNT 
    THEN
	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS,
		BAS_OUT_STR_LEN [0], BAS_OUT_STR [0], 0, DSC$K_DTYPE_F, 9)
    ELSE
    	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
		BAS_OUT_STR [0], 0, DSC$K_DTYPE_F, 12, .CURRENCY, .DIGIT_SEP,
		 .RADIX_PT);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_F_F


GLOBAL ROUTINE BAS$CVT_OUT_D_F (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a double precision number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 16 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[BAS_SCALE_FAC.rb.v]	Basic scale factor from 0 to -6
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    LITERAL
	K_SCALE = 7,
	K_ARG_COUNT = 10;

    IF ACTUALCOUNT () LSS K_SCALE THEN BAS_SCALE_FAC = 0;

    IF ACTUALCOUNT () NEQ K_ARG_COUNT
    THEN
	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS,
		BAS_OUT_STR_LEN [0], BAS_OUT_STR [0], .BAS_SCALE_FAC, DSC$K_DTYPE_D,
		9)
    ELSE
    	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
		BAS_OUT_STR [0], .BAS_SCALE_FAC, DSC$K_DTYPE_D, 12, .CURRENCY,
		.DIGIT_SEP, .RADIX_PT);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_D_F


GLOBAL ROUTINE BAS$CVT_OUT_D_G (		!
	VALUE, 					!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	NUM_DIGITS				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a double precision number to either E or F format
!	depending on its value.  This routine supports PRINT, PRINT USING, NUM$,
!	and STR$.  If a number can be represented in six digits without any loss
!	of accuracy then it is returned in F format.  Otherwise, it is returned
!	in E format.  If the optional argument NUM_DIGITS is included, then the
!	number is returned in F format if it can be represented no less accur-
!	ately in NUM_DIGITS.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to convert
!	FLAGS.rlu.v		= 1, strip leading and trailing space
!	BAS_OUT_STR_LEN.ww.r	length of the string returned.  Useful if return
!				string is static.
!	BAS_OUT_STR.wt.dx	return string
!	[BAS_SCALE_FAC.rb.v]	the scale factor for double precision values.
!	[NUM_DIGITS.rl.v]	number of digits in F format.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_NUM_DIGITS = 6,			! Arg. position of number of digits
	K_SCALE = 5;				! Arg. position of scale factor

    LOCAL
	SIG_DIG;

    BUILTIN
	ACTUALCOUNT;
   
    LOCAL
	STATUS;

    IF ACTUALCOUNT () LSS K_SCALE
    THEN
	BEGIN
	BAS_SCALE_FAC = 0;
	SIG_DIG = K_NUM_F_SIG_DIG;
	END;
    
    IF ACTUALCOUNT () NEQ K_NUM_DIGITS
    THEN 
	SIG_DIG  = K_NUM_F_SIG_DIG
    ELSE 
	SIG_DIG = .NUM_DIGITS;

    STATUS = COMMON_G (.VALUE, .FLAGS, BAS_OUT_STR_LEN [0], BAS_OUT_STR [0],
	.BAS_SCALE_FAC, .SIG_DIG, DSC$K_DTYPE_D);

    RETURN .STATUS;

    END;					! end of BAS$CVT_OUT_D_G

GLOBAL ROUTINE BAS$CVT_OUT_G_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a G floating number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 15 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_POINT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_ARG_COUNT = 9;

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    STATUS = COMMON_E (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
	BAS_OUT_STR [0], 0, .CURRENCY, .DIGIT_SEP, .RADIX_PT, DSC$K_DTYPE_G);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_G_E



GLOBAL ROUTINE BAS$CVT_OUT_G_F (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a G floating number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 15 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    LITERAL
	K_ARG_COUNT = 9;

    IF ACTUALCOUNT () NEQ K_ARG_COUNT
    THEN
	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS,
		BAS_OUT_STR_LEN [0], BAS_OUT_STR [0], 0, DSC$K_DTYPE_G, 9)
    ELSE
    	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
		BAS_OUT_STR [0], 0, DSC$K_DTYPE_G, 12, .CURRENCY, .DIGIT_SEP,
		.RADIX_PT);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_G_F


GLOBAL ROUTINE BAS$CVT_OUT_H_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out an H floating number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 33 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_POINT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    LITERAL
	K_ARG_COUNT = 9;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    STATUS = COMMON_E (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
	BAS_OUT_STR [0], 0, .CURRENCY, .DIGIT_SEP, .RADIX_PT, DSC$K_DTYPE_H,
	ACTUALCOUNT ());

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_H_E

GLOBAL ROUTINE BAS$CVT_OUT_G_G (		!
	VALUE, 					!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	NUM_DIGITS				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a G floating number to either E or F format
!	depending on its value.  This routine supports PRINT, PRINT USING, NUM$,
!	and STR$.  If a number can be represented in six digits without any loss
!	of accuracy then it is returned in F format.  Otherwise, it is returned
!	in E format.  If the optional argument NUM_DIGITS is included, then the
!	number is returned in F format if it can be represented no less accur-
!	ately in NUM_DIGITS.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to convert
!	FLAGS.rlu.v		= 1, strip leading and trailing space
!	BAS_OUT_STR_LEN.ww.r	length of the string returned.  Useful if return
!				string is static.
!	BAS_OUT_STR.wt.dx	return string
!	[NUM_DIGITS.rl.v]	number of digits in F format.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_NUM_DIGITS = 5;			! Arg. position of number of digits

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS,
	SIG_DIG;

    IF ACTUALCOUNT () NEQ K_NUM_DIGITS 
    THEN 
	SIG_DIG = K_NUM_F_SIG_DIG
    ELSE
	SIG_DIG = .NUM_DIGITS;

    STATUS = COMMON_G (.VALUE, .FLAGS, BAS_OUT_STR_LEN [0], BAS_OUT_STR [0],
	0, .SIG_DIG, DSC$K_DTYPE_G);

    RETURN .STATUS;

    END;					!End of BAS$CVT_OUT_G_G

GLOBAL ROUTINE BAS$CVT_OUT_H_G (		!
	VALUE, 					!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
        NUM_DIGITS				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts an H floating number to either E or F format
!	depending on its value.  This routine supports PRINT, PRINT USING, NUM$,
!	and STR$.  If a number can be represented in six digits without any loss
!	of accuracy then it is returned in F format.  Otherwise, it is returned
!	in E format.  If the optional argument NUM_DIGITS is included, then the
!	number is returned in F format if it can be represented no less accur-
!	ately in NUM_DIGITS.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to convert
!	FLAGS.rlu.v		= 1, strip leading and trailing space
!	BAS_OUT_STR_LEN.ww.r	length of the string returned.  Useful if return
!				string is static.
!	BAS_OUT_STR.wt.dx	return string
!       [NUM_DIGITS.rl.v]       number of digits
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_NUM_DIGITS = 5,			! Arg. position of number of digits
	K_NUM_H_E_DIGS = 5;			! Only 5 digits in fraction for
						! h floating (6 for other data types)

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS,
	SIG_DIG;

    IF ACTUALCOUNT () NEQ K_NUM_DIGITS 
    THEN 
	SIG_DIG = K_NUM_F_SIG_DIG
    ELSE
	SIG_DIG = .NUM_DIGITS;

    STATUS = COMMON_G (.VALUE, .FLAGS, BAS_OUT_STR_LEN [0], BAS_OUT_STR [0],
	0, .SIG_DIG, DSC$K_DTYPE_H);

    RETURN .STATUS;

    END;					!End of BAS$CVT_OUT_H_G

GLOBAL ROUTINE BAS$CVT_OUT_H_F (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts an H floating number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 33 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    LITERAL
	K_ARG_COUNT = 9;

    IF ACTUALCOUNT () NEQ K_ARG_COUNT
    THEN
	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS,
		BAS_OUT_STR_LEN [0], BAS_OUT_STR [0], 0, DSC$K_DTYPE_H, 9)
    ELSE
    	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
		BAS_OUT_STR [0], 0, DSC$K_DTYPE_H, 12, .CURRENCY, .DIGIT_SEP,
		 .RADIX_PT);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_H_F

GLOBAL ROUTINE BAS$CVT_OUT_P_F (		!
	VALUE,					!
	NO_INT_DIGITS,				!
	NO_FRAC_DIGITS,				!
	FLAGS,					!
	BAS_OUT_STR_LEN,			!
	BAS_OUT_STR,				!
	CURRENCY,				!
	DIGIT_SEP,				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a packed decimal number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 31 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rt.dx		packed decimal string to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		The value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	STATUS;

    LITERAL
	K_ARG_COUNT = 9;

    IF ACTUALCOUNT () NEQ K_ARG_COUNT 
    THEN
	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS,
		BAS_OUT_STR_LEN [0], BAS_OUT_STR [0], 0, DSC$K_DTYPE_P, 9)
    ELSE
    	STATUS = COMMON_F (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
		BAS_OUT_STR [0], 0, DSC$K_DTYPE_P, 12, .CURRENCY, .DIGIT_SEP,
		 .RADIX_PT);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_P_F


GLOBAL ROUTINE BAS$CVT_OUT_P_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a packed decimal number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 6 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rt.dx		the packed decimal string to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	K_ARG_COUNT = 9;

    BUILTIN
	ACTUALCOUNT;

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LOCAL
	STATUS;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    STATUS = COMMON_E (.VALUE, .NO_INT_DIGITS, .NO_FRAC_DIGITS, .FLAGS, BAS_OUT_STR_LEN [0],
	BAS_OUT_STR [0], 0, .CURRENCY, .DIGIT_SEP, .RADIX_PT,
	DSC$K_DTYPE_P);

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_P_E


GLOBAL ROUTINE BAS$CVT_OUT_P_G (		!
	VALUE, 					!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	NUM_DIGITS				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a packed decimal number to F format.  (Packed decimal
!	will never print in E format since it is defined to work the same as text.
!	This routine supports PRINT, PRINT USING, NUM$, and STR$.  
!
! FORMAL PARAMETERS:
!
!	VALUE.rt.dx		the value to convert
!	FLAGS.rlu.v		= 1, strip leading and trailing space
!	BAS_OUT_STR_LEN.ww.r	length of the string returned.  Useful if return
!				string is static.
!	BAS_OUT_STR.wt.dx	return string
!	[NUM_DIGITS.rl.v]	number of digits in F format.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_NUM_DIGITS = 5;			! Arg. position of number of digits

    BUILTIN
	ACTUALCOUNT;
   
    LOCAL
	STATUS,
	DIGITS;

    IF ACTUALCOUNT () NEQ K_NUM_DIGITS
    THEN
	DIGITS = K_NUM_P_SIG_DIG
    ELSE
	DIGITS = .NUM_DIGITS;

    STATUS = COMMON_G (.VALUE, .FLAGS, BAS_OUT_STR_LEN [0], BAS_OUT_STR [0],
	0, .DIGITS, DSC$K_DTYPE_P);

    RETURN .STATUS;

    END;					! end of BAS$CVT_OUT_P_G

ROUTINE COMMON_E (				!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT,				!
	DATA_TYPE				!
    ): JSB_E_FORMAT =				!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  The number of significant digits returned depends on
!	the data type.
!
! FORMAL PARAMETERS:
!
!	VALUE.rz.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	BAS_SCALE_FAC.rb.v	Basic scale factor in a range of 0 to -6
!	CURRENCY.rt.dx		currency symbol
!	DIGIT_SEP.rt.dx		digit group separator
!	RADIX_POINT.rt.dx	radix point
!	DATA_TYPE.rl.v		data type of element 
!	
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LOCAL
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_H, BYTE],	! temp string for kernel conversion result
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into temp string
	NO_DIGITS,				! no. of actual significant digits returned
						! by the kernel conversion routine
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE]
			INITIAL (REP (K_KERNEL_BLK_SZ/4) OF (0)),
	SIG_DIG,
	RESULT;

    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;

    SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_P]:
		BEGIN
		MAP
	 	    VALUE : REF BLOCK [12,BYTE];
		RESULT = CMPP (VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
			%REF (15), PACKED_ZERO);
		END;
	    [OTHERWISE]:
		RESULT = .VALUE [0];
	TES;

    IF .RESULT EQL 0
    THEN
!+
! If a zero value should be suppressed, then complete processing here, without
! calling PLAIN_ or FANCY_ formatting routines.  All that needs to be output
! is a string of blanks.
!-
	BEGIN
	IF ((.FLAGS AND V_SUPPRESS_ZERO) EQL 0)
	THEN
	    PUT_OUT_ZERO
	ELSE
	    BEGIN
	    LOCAL BLANKS_STR_DESC : BLOCK [8, BYTE];

	    INITIALIZE_DESC;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    BLANKS_STR_DESC [DSC$A_POINTER] = BLANKS;
	    BLANKS_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS + .NO_FRAC_DIGITS
		+ (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 1 ELSE 0)
		+ (IF (.FLAGS AND V_CURRENCY) NEQ 0
		    THEN .CURRENCY [DSC$W_LENGTH] ELSE 0)
		+ (IF (.FLAGS AND V_COMMA) NEQ 0
		    THEN (.KERNEL_BLOCK [DEC_EXP]-1)/3 * .DIGIT_SEP [DSC$W_LENGTH]
		    ELSE 0)
		+ .RADIX_PT [DSC$W_LENGTH];
	    STR$CONCAT (BAS_OUT_STR [0], BLANKS_STR_DESC);
	    RETURN 1;
	    END;
	END

    ELSE
	BEGIN
!+
! Figure out the number of significant digits to ask for.  It is the minimum of
! the maximum that the data type can accurately hold or the total number of
! digits asked for subtracting one if the value is negative.
!-
	SELECTONE .DATA_TYPE OF
	    SET
		[DSC$K_DTYPE_F]:
		    SIG_DIG = K_NUM_F_SIG_DIG;
		[DSC$K_DTYPE_D]:
		    SIG_DIG = K_NUM_D_SIG_DIG;
		[DSC$K_DTYPE_P]:
		    SIG_DIG = K_NUM_P_SIG_DIG;
		[DSC$K_DTYPE_G]:
		    SIG_DIG = K_NUM_G_SIG_DIG;
		[DSC$K_DTYPE_H]:
		    SIG_DIG = K_NUM_H_SIG_DIG;
		[OTHERWISE]:
		    LIB$STOP (OTS$_FATINTERR);
	    TES;
	KERNEL_BLOCK [SIG_DIGITS] = MIN (.SIG_DIG,
	    .NO_INT_DIGITS + .NO_FRAC_DIGITS - (IF (.(VALUE [0])<15, 1> EQL 1) THEN 1 ELSE 0));
	KERNEL_BLOCK [CONV_FLAGS] = KERNEL_BLOCK [RT_RND] = 0;
	SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_F]:
		OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [DSC$K_DTYPE_D]:
		OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [DSC$K_DTYPE_P]:
		BEGIN
		!+
		! No kernel conversion routine so convert to text here and
		! set some parameters.
		!-
		MAP
		    VALUE : REF BLOCK [12, BYTE];
		LOCAL
		    ZERO_CTR : INITIAL (0),
		    INT_DIGITS;

		CVTPS (VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
			VALUE [DSC$W_LENGTH], TEMP_STRING);
		!+
		! Calculate the number of integer digits, excluding leading
		! zeroes.
		!-
		INT_DIGITS = .VALUE [DSC$W_LENGTH] + .VALUE [DSC$B_SCALE];
		INCR I FROM 1 TO .INT_DIGITS DO
		    IF .TEMP_STRING [.I] EQL %C'0' THEN ZERO_CTR = .ZERO_CTR + 1
		    ELSE EXITLOOP;
		KERNEL_BLOCK [DEC_EXP] = .INT_DIGITS - .ZERO_CTR;
		KERNEL_BLOCK [OFFSET] = 1 + .ZERO_CTR;
		IF .TEMP_STRING [0] EQL %C'-'
		THEN
		    BEGIN
		    KERNEL_BLOCK [SIGN] = -1;
		    KERNEL_BLOCK [SIG_DIGITS] = .KERNEL_BLOCK [SIG_DIGITS] -
			(IF (.FLAGS AND V_TRAILING_SIGN) EQL 0 THEN 1 ELSE 0);
		    END
		ELSE
		    KERNEL_BLOCK [SIGN] = 1;
		END;
	    [DSC$K_DTYPE_G]:
		OTS$$CVT_G_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [DSC$K_DTYPE_H]:
		OTS$$CVT_H_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [OTHERWISE]:
		LIB$STOP (OTS$_FATINTERR);
	TES;
!+
! Do some error checking.  Are there enough digits to return this number?
!-

	IF (.KERNEL_BLOCK [SIGN] LSS 0)
	THEN

	    IF (.NO_INT_DIGITS LSS 1) OR ((.NO_INT_DIGITS EQL 1) AND (.NO_FRAC_DIGITS LSS 1)) THEN RETURN 0;

!+
! Adjust for the scale factor.  The scale factor will be zero for data types
! other than double.
!-
	KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] + .BAS_SCALE_FAC [0]; 	
!+
! Check for the actual number of significant digits returned.
!-
    IF .DATA_TYPE EQL DSC$K_DTYPE_P
    THEN
	BEGIN
	MAP
	    VALUE: REF BLOCK [12,BYTE];
	TEMP_PTR = TEMP_STRING + .VALUE [DSC$W_LENGTH];
	END
    ELSE
	TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] + .KERNEL_BLOCK [SIG_DIGITS] - 1;

	WHILE .TEMP_PTR [0] EQL %C'0' DO
	    TEMP_PTR = .TEMP_PTR - 1;

	NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
	END;

    FANCY_E_FORM_11 (.NO_INT_DIGITS, .NO_FRAC_DIGITS, .NO_DIGITS, .FLAGS, KERNEL_BLOCK, .CURRENCY,
	.DIGIT_SEP, .RADIX_PT, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0], .DATA_TYPE);
    RETURN 1;
    END;					!End of COMMON_E


 ROUTINE COMMON_F (				!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	DATA_TYPE,				!
	ARG_COUNT,				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ): JSB_F_FORMAT = 				!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a number to explicit point unscaled
!	notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  The number of significant digits returned
! 	depends on the data type.
!
! FORMAL PARAMETERS:
!
!	VALUE.rz.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	BAS_SCALE_FAC.rb.v	Basic scale factor from 0 to -6
!	DATA_TYPE.rl.v		data type of element
!	ARG_COUNT.rl.v		number of arguments passed
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LOCAL
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_H, BYTE],	! string for kernel conversion to
						! return the result in
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into TEMP_STR
	NO_DIGITS,				! no. of actual, useful digits returned
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE]
			INITIAL (REP (K_KERNEL_BLK_SZ/4) OF (0)),
	LARGEST_EXP,
	SIG_DIG,
	RESULT;

    LITERAL
	K_ARG_COUNT = 12;

!+
! Convert this number and then check it to see if it is effectively
! zero after rounding to the number of places required.
!-
    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;
!+
! Set the number of significant digits to the minimum of the number of total
! digits requested (minus one if negative) and the number of accurate significant digits that 
! the data type can return.  This is done so that the kernel routine can do the
! rounding.
!-

  SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_P]:
		BEGIN
		    MAP
			VALUE : REF BLOCK [12,BYTE];
		    RESULT = CMPP (VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
			%REF(15), PACKED_ZERO)
		END;
	    [OTHERWISE]:
		RESULT = .VALUE [0];
	TES;

    IF .RESULT EQL 0
    THEN
!+
! If a zero value should be suppressed, then complete processing here, without
! calling PLAIN_ or FANCY_ formatting routines.  All that needs to be output
! is a string of blanks.
!-
	BEGIN
	IF ((.FLAGS AND V_SUPPRESS_ZERO) EQL 0)
	THEN
	    IF (.NO_INT_DIGITS GEQ 1)
	    THEN
	     	PUT_OUT_ZERO
	    ELSE
		!+
		! Kludge for NUM1$.  NUM1$ always passes 0 for no_int_digits
		! and no_frac_digits, but should print "0" not ".0" for
		! NUM1$(0).  So make sure 0 looks like an integer to the
		! formatting routine.
		!-
		BEGIN
		IF (.NO_INT_DIGITS EQL 0 AND .NO_FRAC_DIGITS EQL 0)
		THEN
		    PUT_OUT_ZERO
		ELSE
		    PUT_OUT_ZERO_FRACT
		END
	ELSE
	    BEGIN
	    LOCAL BLANKS_STR_DESC : BLOCK [8, BYTE];

	    INITIALIZE_DESC;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    BLANKS_STR_DESC [DSC$A_POINTER] = BLANKS;
	    BLANKS_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS + .NO_FRAC_DIGITS
		+ (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 1 ELSE 0)
		+ (IF (.FLAGS AND V_COMMA) NEQ 0
		    THEN (.KERNEL_BLOCK [DEC_EXP]-1)/3 * .DIGIT_SEP [DSC$W_LENGTH]
		    ELSE 0)
		+ (IF (.FLAGS AND V_PERIOD) NEQ 0 THEN .RADIX_PT [DSC$W_LENGTH]
		    ELSE 0);
	    STR$CONCAT (BAS_OUT_STR [0], BLANKS_STR_DESC);
	    RETURN 1;
	    END;
	END

    ELSE
	BEGIN
	SELECTONE .DATA_TYPE OF
	    SET
		[DSC$K_DTYPE_F]:
	    	    SIG_DIG = K_NUM_F_SIG_DIG;
		[DSC$K_DTYPE_D]:
		    SIG_DIG = K_NUM_D_SIG_DIG;
		[DSC$K_DTYPE_P]:
		    BEGIN
		    MAP
			VALUE : REF BLOCK [12,BYTE];

		    SIG_DIG = .VALUE [DSC$W_LENGTH] + .VALUE [DSC$B_SCALE];
		    END;
		[DSC$K_DTYPE_G]:
		    SIG_DIG = K_NUM_G_SIG_DIG;
		[DSC$K_DTYPE_H]:
		    SIG_DIG = K_NUM_H_SIG_DIG;
		[OTHERWISE]:
		    LIB$STOP (OTS$_FATINTERR);
	   TES;
	KERNEL_BLOCK [SIG_DIGITS] =
	(IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0) THEN MIN (.NO_INT_DIGITS + .NO_FRAC_DIGITS -
		BEGIN

		IF ((.(VALUE [0])<15, 1> EQL 1) AND ((.FLAGS AND V_TRAILING_SIGN) EQL 0)) THEN 1 ELSE 0

		END
	    , .SIG_DIG) ELSE .SIG_DIG);
!+
! Do not set the right round flag if this is a floating decimal point number.
!-
	KERNEL_BLOCK [CONV_FLAGS] = (IF (.FLAGS AND V_FLT_DEC_PT) EQL 0 THEN V_RT_RND ELSE 0);
!+
! The scale factor will be zero if this is not a double precision value.
!-
	KERNEL_BLOCK [RT_RND] =	.BAS_SCALE_FAC + .NO_FRAC_DIGITS;
	SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_F]:
	    	OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [DSC$K_DTYPE_D]:
		OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [DSC$K_DTYPE_P]:
		BEGIN
		!+
		! No kernel conversion routine so convert to text here and
		! set some parameters.
		!-
		MAP
		    VALUE : REF BLOCK [12, BYTE];
		LOCAL
		    ZERO_CTR : INITIAL (0),
		    INT_DIGITS;

		CVTPS (VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
			VALUE [DSC$W_LENGTH], TEMP_STRING);
		!+
		! Calculate the number of integer digits, excluding leading
		! zeroes.
		!-
		INT_DIGITS = .VALUE [DSC$W_LENGTH] + .VALUE [DSC$B_SCALE];
		INCR I FROM 1 TO .INT_DIGITS DO
		    IF .TEMP_STRING [.I] EQL %C'0' THEN ZERO_CTR = .ZERO_CTR + 1
		    ELSE EXITLOOP;
		KERNEL_BLOCK [DEC_EXP] = .INT_DIGITS - .ZERO_CTR;
		KERNEL_BLOCK [OFFSET] = 1 + .ZERO_CTR;
		!+
		! Set the significant digits to the actual number of digits.
		!-
		SIG_DIG = .KERNEL_BLOCK [DEC_EXP] + ABS(.VALUE [DSC$B_SCALE]);
		IF .TEMP_STRING [0] EQL %C'-'
		THEN
		    BEGIN
		    KERNEL_BLOCK [SIGN] = -1;
		    KERNEL_BLOCK [SIG_DIGITS] = .KERNEL_BLOCK [SIG_DIGITS] -
			(IF (.FLAGS AND V_TRAILING_SIGN) EQL 0 THEN 1 ELSE 0);
		    END
		ELSE
		    KERNEL_BLOCK [SIGN] = 1;
		END;
	    [DSC$K_DTYPE_G]:
		OTS$$CVT_G_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [DSC$K_DTYPE_H]:
		OTS$$CVT_H_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	    [OTHERWISE]:
		LIB$STOP (OTS$_FATINTERR);
	TES;
!+
! Adjust for the scale factor.  The scale factor will be zero if this is
! not a double precisio value.
!-
	KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] + .BAS_SCALE_FAC [0];
!+
! Check to see if this number is effectively zero
!-

	IF (((.KERNEL_BLOCK [DEC_EXP] LSS 0) AND (ABS (.KERNEL_BLOCK [DEC_EXP]) GEQ .NO_FRAC_DIGITS))	!
	    OR ((.KERNEL_BLOCK [DEC_EXP] EQL 0) AND (.NO_FRAC_DIGITS EQL 0)))	!
	    AND ((.FLAGS AND V_FLT_DEC_PT) EQL 0)	!
	   ! AND (.NO_INT_DIGITS GTR 0)
	THEN
!+
! If a zero value should be suppressed, then complete processing here, without
! calling PLAIN_ or FANCY_ formatting routines.  All that needs to be output
! is a string of blanks.
!-
	BEGIN
	IF ((.FLAGS AND V_SUPPRESS_ZERO) EQL 0)
	THEN
	    BEGIN
	    IF .NO_INT_DIGITS GEQ 1
	    THEN
		PUT_OUT_ZERO
	    ELSE
		!+
		! Kludge for NUM1$.  NUM1$ always passes 0 for no_int_digits
		! and no_frac_digits, but should print "0" not ".0" for
		! NUM1$(0).  So make sure 0 looks like an integer to the
		! formatting routine.
		!-
		BEGIN
		IF (.NO_INT_DIGITS EQL 0 AND .NO_FRAC_DIGITS EQL 0)
		THEN
		    PUT_OUT_ZERO
		ELSE
		    PUT_OUT_ZERO_FRACT
		END
	    END
	ELSE
	    BEGIN
	    LOCAL BLANKS_STR_DESC : BLOCK [8, BYTE];

	    INITIALIZE_DESC;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    BLANKS_STR_DESC [DSC$A_POINTER] = BLANKS;
	    BLANKS_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS + .NO_FRAC_DIGITS
		+ (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 1 ELSE 0)
		+ (IF (.FLAGS AND V_COMMA) NEQ 0
		    THEN (.KERNEL_BLOCK [DEC_EXP]-1)/3 * .DIGIT_SEP [DSC$W_LENGTH]
		    ELSE 0)
		+ (IF (.FLAGS AND V_PERIOD) NEQ 0 THEN .RADIX_PT [DSC$W_LENGTH]
		    ELSE 0);
	    STR$CONCAT (BAS_OUT_STR [0], BLANKS_STR_DESC);
	    RETURN 1;
	    END;
	END

	ELSE
!+
! PRINT USING specific error checking.  Not performed for floating dec. pt.
! Error checking.  If this is a negative number with '**' or '$$' then it must
! also have trailing minus or a trailing <CD>.
!-

	    IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0)
	    THEN

		!+
		! this IF statement reads: if the number is less than zero,
		! and this IS an asterisk or a currency field, and the field
		! DOESN'T end with either a minus sign or a <CD>, then it's
		! a print-using format error.
		!-
		IF (
		    (.KERNEL_BLOCK [SIGN] LSS 0) AND
		    (
		     (
		      (.FLAGS AND V_STAR) NEQ 0
		     ) OR
		     (
		      (.FLAGS AND V_CURRENCY) NEQ 0
		     )
		    ) AND
		    (
		     (.FLAGS AND V_TRAILING_SIGN) EQL 0		AND
		     (.FLAGS AND V_CR_DR) EQL 0
		    )
		   )
		THEN
		    BAS$$STOP (BAS$K_PRIUSIFOR);

	    BEGIN

!+
! Find the last non-zero byte
!-
	    TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] +
	    BEGIN

	    IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0)
	    THEN
		MIN (.SIG_DIG,
		    .KERNEL_BLOCK [DEC_EXP] + .NO_FRAC_DIGITS)
	    ELSE
		.SIG_DIG

	    END
	    - 1;

	    IF (.TEMP_PTR GTRA (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]))
	    THEN

		WHILE (.TEMP_PTR GEQA (.KERNEL_BLOCK [STRING_ADDR] + 
		       .KERNEL_BLOCK [OFFSET])) AND
		      .TEMP_PTR [0] EQL %C'0' 
		DO TEMP_PTR = .TEMP_PTR - 1;

	    NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
	    END;

	END;

!+
! Check to see if this is the floating decimal point situation.  The only other
! valid flag bit is V_STRIP_SPACES.  All other bits are ignored.
!-
    SELECTONE .DATA_TYPE OF
    SET
	[DSC$K_DTYPE_F]:
	    LARGEST_EXP = K_RANGE;
	[DSC$K_DTYPE_D]:
	    LARGEST_EXP = K_RANGE;
	[DSC$K_DTYPE_P]:
	    LARGEST_EXP = K_P_RANGE;
  	[DSC$K_DTYPE_G]:
	    LARGEST_EXP = K_G_RANGE;
	[DSC$K_DTYPE_H]:
	    LARGEST_EXP = K_H_RANGE;
	[OTHERWISE]:
	    LIB$STOP (OTS$_FATINTERR);
    TES;

    IF ((.FLAGS AND V_FLT_DEC_PT) NEQ 0)
    THEN
	PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK,
	    BAS_OUT_STR [0], BAS_OUT_STR_LEN [0], .LARGEST_EXP)
    ELSE
	BEGIN
!+
! This is a more conventional F format.  Try formatting the number as
! requested.
! Do some error checking to see if the number will fit into the field width
! provided.
! 1.) Are there enough integer digits
!	a.) Need 1 if negative number and no trailing sign
!	b.) Need length of currency symbol if floating currency symbol
!	c.) enough for the commas if required
!	d.) enough for the digits based on the exponent
!	e.) Need 1 for a zero if magnitude of number is less than 1.
! 2.) Are there enough fractional digits
!-

	LOCAL
	    INT_DIGITS_NEED;

	IF .ARG_COUNT NEQ K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);
						! consistency check
	INT_DIGITS_NEED =
	BEGIN

	IF ((.KERNEL_BLOCK [SIGN] LSS 0) AND (.FLAGS AND V_TRAILING_SIGN) EQL 0)
						! Negative numbers and trailing sign
	THEN
	    1
	ELSE
	    0

	END
	+
	BEGIN

	IF (.KERNEL_BLOCK [DEC_EXP] GTR 0) 
	THEN						    
            .KERNEL_BLOCK [DEC_EXP]
	ELSE
	    0

	END
	+
	BEGIN

	IF ((.FLAGS AND V_CURRENCY) NEQ 0)	! floating currency
	THEN
	    .CURRENCY [DSC$W_LENGTH]
	ELSE
	    0

	END
	+
	BEGIN

	IF (((.FLAGS AND V_COMMA) NEQ 0) AND (.KERNEL_BLOCK [DEC_EXP] GTR 0))	! number of commas needed
	THEN
	    (.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	ELSE
	    0

	END;
!+
! Check to see if enough integer and fraction digits have been reserved
!-

	IF (.INT_DIGITS_NEED GTR .NO_INT_DIGITS) OR ((.KERNEL_BLOCK [DEC_EXP] LSS 0) AND (ABS (.KERNEL_BLOCK
		[DEC_EXP]) GTR .NO_FRAC_DIGITS))
	THEN
	    RETURN 0;

	FANCY_F_FORM_11 (.NO_INT_DIGITS, .NO_FRAC_DIGITS, .NO_DIGITS, .FLAGS, KERNEL_BLOCK, .CURRENCY,
	    .DIGIT_SEP, .RADIX_PT, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0],
	    .LARGEST_EXP);
	END;
    
    RETURN 1;
    END;					!End of COMMON_F

ROUTINE COMMON_G (				!
	VALUE, 					!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	NUM_DIGITS,				!
	DATA_TYPE				!
    ): JSB_G_FORMAT = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a number to either E or F format
!	depending on its value.  This routine supports PRINT, PRINT USING, NUM$,
!	and STR$.  If a number can be represented in six digits without any loss
!	of accuracy then it is returned in F format.  Otherwise, it is returned
!	in E format.  If the optional argument NUM_DIGITS is included, then the
!	number is returned in F format if it can be represented no less accur-
!	ately in NUM_DIGITS.
!
! FORMAL PARAMETERS:
!
!	VALUE.rz.r		the value to convert
!	FLAGS.rlu.v		= 1, strip leading and trailing space
!	BAS_OUT_STR_LEN.ww.r	length of the string returned.  Useful if return
!				string is static.
!	BAS_OUT_STR.wt.dx	return string
!	BAS_SCALE_FAC.rb.v	the scale factor for double precision values.
!	NUM_DIGITS.rl.v		number of digits in F format.
!	DATA_TYPE.rl.v		data type of element to format
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LOCAL
	RANGE,					! maximum number of digits for F format
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_H, BYTE],	! temp string to pass to the kernel
						! conversion routine
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into string returned by
						! kernel conversion routine
	NO_DIGITS,				! actual length of string returned
						! by the kernel routine
	STATUS,					! return status
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE]
			INITIAL (REP (K_KERNEL_BLK_SZ/4) OF (0)),
	LARGEST_EXP,
	RESULT;

    !+
    ! Special case 0
    !-

    SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_P]:
		BEGIN
		MAP
		    VALUE : REF BLOCK [12,BYTE];
		RESULT = CMPP (VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
			%REF (15), PACKED_ZERO);
		END;
	    [OTHERWISE]:
		RESULT = .VALUE [0];
	TES;

    IF .RESULT EQL 0
    THEN
	BEGIN

	BIND
	    BLANK = UPLIT (BYTE (' ')),
	    ZERO = UPLIT (BYTE ('0'));

	LOCAL
	    ZERO_STR_DESC : BLOCK [8, BYTE];

!+
! Initialize the BLANK desc in case this is the very first PRINT.
!-
	B_D = BLANK;
	ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZERO_STR_DESC [DSC$W_LENGTH] = 1;
	ZERO_STR_DESC [DSC$A_POINTER] = ZERO;
	STATUS = STR$CONCAT (BAS_OUT_STR [0],
	    (IF .FLAGS AND V_STRIP_SPACES THEN NULL_DESC ELSE BLANK_DESC), ZERO_STR_DESC,
	    (IF .FLAGS AND V_STRIP_SPACES THEN NULL_DESC ELSE BLANK_DESC));
	BAS_OUT_STR_LEN [0] = (IF .FLAGS AND V_STRIP_SPACES THEN 1 ELSE 3);
	RETURN .STATUS;
	END;

    RANGE = .NUM_DIGITS; 
!+
! Load up the parameter block, stick the value in R0 and call the kernel
! conversion routine.
!-
    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;
    KERNEL_BLOCK [SIG_DIGITS] = .RANGE;
    KERNEL_BLOCK [CONV_FLAGS] = KERNEL_BLOCK [RT_RND] = 0;
    SELECTONE .DATA_TYPE OF
    SET
	[DSC$K_DTYPE_F]:
	    OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	[DSC$K_DTYPE_D]:
	    OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	[DSC$K_DTYPE_P]:
		BEGIN
		!+
		! No kernel conversion routine so convert to text here and
		! set some parameters.
		!-
		MAP
		    VALUE : REF BLOCK [12, BYTE];
		LOCAL
		    ZERO_CTR : INITIAL (0),
		    INT_DIGITS;

		CVTPS (VALUE [DSC$W_LENGTH], .VALUE [DSC$A_POINTER],
			VALUE [DSC$W_LENGTH], TEMP_STRING);
		!+
		! Calculate the number of integer digits, excluding leading
		! zeroes.
		!-
		INT_DIGITS = .VALUE [DSC$W_LENGTH] + .VALUE [DSC$B_SCALE];
		INCR I FROM 1 TO .INT_DIGITS DO
		    IF .TEMP_STRING [.I] EQL %C'0' THEN ZERO_CTR = .ZERO_CTR + 1
		    ELSE EXITLOOP;
		KERNEL_BLOCK [DEC_EXP] = .INT_DIGITS - .ZERO_CTR;
		KERNEL_BLOCK [OFFSET] = 1 + .ZERO_CTR;
		IF .TEMP_STRING [0] EQL %C'-'
		THEN
		    KERNEL_BLOCK [SIGN] = -1
		ELSE
		    KERNEL_BLOCK [SIGN] = 1;
		!+
		! Range should be set to the actual number of digits in the
		! number, since there is no limit on the print size of decimal.
		! Note that this means only f format will be used by PRINT, STR$
		! and NUM$.
		!-
		RANGE = .KERNEL_BLOCK [DEC_EXP] - .VALUE [DSC$B_SCALE];	
		END;
	[DSC$K_DTYPE_G]:
	    OTS$$CVT_G_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	[DSC$K_DTYPE_H]:
	    OTS$$CVT_H_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
	[OTHERWISE]:
	    LIB$STOP (OTS$_FATINTERR);
    TES;
!+
! Adjust for the scale factor, if any
!-
    KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] + .BAS_SCALE_FAC [0];
!+
! Find the last non-zero digit in order to know the actual length of the number
!-
    TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] + .RANGE - 1;

    WHILE .TEMP_PTR [0] EQL %C'0' DO
	TEMP_PTR = .TEMP_PTR - 1;

    NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
!+
! Now determine whether to do E format or F format.  Note 0 has been special
! cased.  Some rough decisions can be made based on the exponent of the value
! returned by the kernel conversion routine.  If the exponent is > 6 or < -6
! the number should be output in E format.  If the exponent is < 6 and > 0,
! then the number is output as F format.  For numbers where the exponent is
! > -6 and < 0, the actual value comes into play.  If the number can be represented
! no less accurately in 6 digits, then it is output in F format.  Otherwise,
! the number is output in E format with 6 significant digits.
! If NUM_DIGITS is specified, then substitute its value for 6 in the above
! discussion.
!-

    SELECTONE .KERNEL_BLOCK [DEC_EXP] OF
	SET

	[0 TO .RANGE] :
!+
! Unconditionally F format
!-
	    BEGIN
	    SELECTONE .DATA_TYPE OF
	    SET
	   	[DSC$K_DTYPE_F]:
		    LARGEST_EXP = K_RANGE;
		[DSC$K_DTYPE_D]:
		    LARGEST_EXP = K_RANGE;
		[DSC$K_DTYPE_P]:
		    LARGEST_EXP = K_P_RANGE;
		[DSC$K_DTYPE_G]:
		    LARGEST_EXP = K_G_RANGE;
		[DSC$K_DTYPE_H]:
		    LARGEST_EXP = K_H_RANGE;
		[OTHERWISE]:
		    LIB$STOP (OTS$_FATINTERR);
	    TES;
	    STATUS = PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK,
		 BAS_OUT_STR [0], BAS_OUT_STR_LEN [0], .LARGEST_EXP);
	    END;

	[-(.RANGE - 1) TO -1] :
!+
! May be either E or F format.  Have to check and see if any accuracy will
! be lost by displaying 6 digits in F format.  If accuracy will be lost,
! then use E format.
!-

	    IF ((.NO_DIGITS - .KERNEL_BLOCK [DEC_EXP]) LEQ .RANGE)
	    THEN
!+
! F format
!-
		BEGIN
		SELECTONE .DATA_TYPE OF
		SET
		    [DSC$K_DTYPE_F]:
			LARGEST_EXP = K_RANGE;
		    [DSC$K_DTYPE_D]:
			LARGEST_EXP = K_RANGE;
		    [DSC$K_DTYPE_P]:
			LARGEST_EXP = K_P_RANGE;
		    [DSC$K_DTYPE_G]:
			LARGEST_EXP = K_G_RANGE;
		    [DSC$K_DTYPE_H]:
			LARGEST_EXP = K_H_RANGE;
		    [OTHERWISE]:
			LIB$STOP (OTS$_FATINTERR);
		TES;
		STATUS = PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, BAS_OUT_STR [0],
		    BAS_OUT_STR_LEN [0], .LARGEST_EXP)
		END
	    ELSE
!+
! E format
!-
		STATUS = PLAIN_E_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, BAS_OUT_STR [0],
		    BAS_OUT_STR_LEN [0], .DATA_TYPE );

	[OTHERWISE] :
!+
! Unconditionally E format
!-
	    STATUS = PLAIN_E_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, 
		BAS_OUT_STR [0], BAS_OUT_STR_LEN [0], .DATA_TYPE)
	;
	TES;

    RETURN .STATUS;
    END;					!End of COMMON_G


ROUTINE PLAIN_F_FORM_11 (			! Plain old F formatting
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN,			!
	LARGEST_EXP				!
    ) : JSB_FORMAT_A6 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do plain old explicit point unscaled formatting.  Strip leading and
!	trailing spaces if necessary.
!
! FORMAL PARAMETERS:
!
!	NO_DIGITS.rlu.v		number of actual significant digits in value to
!				be formatted
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	block returned by kernel conversion routine
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	LARGEST_EXP.rlu.v	largest possible exponent for data type
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Returns STR$_TRU
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    
    LOCAL
	ZEROES_DESC : BLOCK [8, BYTE],		! if used must be known to whole module
	ZEROES_PTR,
	STATUS;

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    INITIALIZE_DESC;

!+
! The largest possible exponent for single and double floating point is 38.
! G and h floating, however, have largest exponents of 308 and 4932 respectively.
! NUM1$ must be able to print out all these characters but the user who doesn't
! want all these should not have to pay the performance penalty.  Therefore,
! fill characters (zero, star, blank) are initialized to size 38 and then 
! re-initialized here only if necessary.
!-

    IF (.LARGEST_EXP GTR K_RANGE) 
    THEN
	BEGIN
	LOCAL
	    ZERO : BYTE;

   	ZEROES_DESC [DSC$W_LENGTH] = .LARGEST_EXP;
	ZEROES_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZEROES_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	ZEROES_DESC [DSC$A_POINTER] = 0;	! STR$DUPL_CHAR will alloc space

	ZERO = %X'30';
	STR$DUPL_CHAR (ZEROES_DESC, LARGEST_EXP, ZERO);
						! create string of zeroes
	ZEROES_PTR = .ZEROES_DESC [DSC$A_POINTER];

	END
    ELSE
        ZEROES_PTR = ZEROES;			! use string of 38 zeroes


    IF (.KERNEL_BLOCK [DEC_EXP] GEQ 0)
    THEN
!+
! The number is greater than or equal to 1
!-

	IF (.KERNEL_BLOCK [DEC_EXP] GEQ .NO_DIGITS)
	THEN
	    BEGIN
!+
! This entire number consists only of integer part.  Put the number
! returned by the conversion routine and optionally some trailing
! zeroes into the return string.
!-

	    LOCAL
		ZERO_STR_DESC : BLOCK [8, BYTE],	! desc. for trailing zeroes
		INT_STR_DESC : BLOCK [8, BYTE];	! desc. for integer portion of number

	    INT_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	    ZERO_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS;
	    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    ZERO_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	    STATUS = STR$CONCAT (BAS_OUT_STR [0],
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0)
		THEN
		    MINUS_DESC
		ELSE

		    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    , INT_STR_DESC, ZERO_STR_DESC,
		BEGIN

		IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    );
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES)
	    THEN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    ELSE
		2

	    END
	    + .KERNEL_BLOCK [DEC_EXP];
	    END
	ELSE
	    BEGIN
!+
! This number has both integer and fractional portions.
!-

	    LOCAL
		INT_STR_DESC : BLOCK [8, BYTE],
		FRAC_STR_DESC : BLOCK [8, BYTE];

	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP];
	    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS - .KERNEL_BLOCK [DEC_EXP];
	    FRAC_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .KERNEL_BLOCK [DEC_EXP];
	    STATUS = STR$CONCAT (BAS_OUT_STR [0],
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0)
		THEN
		    MINUS_DESC
		ELSE

		    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    , INT_STR_DESC, DOT_DESC, FRAC_STR_DESC,
		BEGIN

		IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    );
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES)
	    THEN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    ELSE
		2

	    END
	    + .NO_DIGITS + 1;
	    END

    ELSE
	BEGIN
!+
! This is a purely fractional number which should be put out in F format
!-

	LOCAL
	    ZERO_STR_DESC : BLOCK [8, BYTE],	! desc. for leading zeroes
	    FRAC_STR_DESC : BLOCK [8, BYTE];	! desc. for fraction

	ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZERO_STR_DESC [DSC$W_LENGTH] = -.KERNEL_BLOCK [DEC_EXP];
	ZERO_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	STATUS = STR$CONCAT (BAS_OUT_STR [0],
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0)
	    THEN
		MINUS_DESC
	    ELSE

		IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
	, DOT_DESC, ZERO_STR_DESC, FRAC_STR_DESC,
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
	);
	BAS_OUT_STR_LEN [0] =
	BEGIN

	IF (.FLAGS AND V_STRIP_SPACES)
	THEN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	ELSE
	    2

	END
	! The exponent is subtracted 'cuz it is negative
	+ .NO_DIGITS - .KERNEL_BLOCK [DEC_EXP] + 1;
	END;

    IF (.LARGEST_EXP GTR K_RANGE)		! need to free space alloc
    THEN					! for zeroes
	STR$FREE1_DX (ZEROES_DESC);

    RETURN .STATUS;
    END;					! PLAIN_F_FORMAT

ROUTINE FANCY_F_FORM_11 (			!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN,			!
	LARGEST_EXP				!
    ) : JSB_FORMAT_A11 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do all of the Print Using formatting for F format.
!
! FORMAL PARAMETERS:
!
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	NO_DIGITS.rlu.v		number of significant digits in value
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	parameter block from kernel routine
!	CURRENCY.rt.dx		currency symbol
!	DIGIT_SEP.rt.dx		digit group separator
!	RADIX_PT.rt.dx		radix point
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	LARGEST_EXP.rlu.v	largest exponent possible for data type
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	RADIX_PT : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    LOCAL
	ZEROES_PTR,
	BLANKS_PTR,
	STAR_PTR,
	STAR_STR_DESC : BLOCK [8, BYTE],	! desc. for asterisks
	BLANKS_STR_DESC : BLOCK [8, BYTE],	! desc. for leading spaces
	ZERO_STR_DESC : BLOCK [8, BYTE],	! desc. for trailing zeroes
	INT_STR_DESC : BLOCK [8, BYTE],		! desc. for integer portion of number
	ZEROES_DESC : BLOCK [8, BYTE],		! place to create string of zeroes
	BLANKS_DESC : BLOCK [8, BYTE],		! place to create string of blanks
	STAR_DESC : BLOCK [8, BYTE],		! place to create string of stars
	LEADING_STR_DESC : BLOCK [8, BYTE],	! place to create leading zeroes
	LENGTH,					! length of leading blanks or 
						!  zeroes
	CR_DESC : BLOCK [8, BYTE],		! desc. for CR
	DR_DESC : BLOCK [8, BYTE],		! desc. for DR
	CR_STR,
	DR_STR;

    INITIALIZE_DESC;

    CR_STR = %ASCIZ'CR';
    DR_STR = %ASCIZ'DR';

    IF (.FLAGS AND V_CR_DR) NEQ 0 THEN
    BEGIN
	CR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	CR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	CR_DESC [DSC$W_LENGTH] = 2;
	CR_DESC [DSC$A_POINTER] = CR_STR;
	DR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	DR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	DR_DESC [DSC$W_LENGTH] = 2;
	DR_DESC [DSC$A_POINTER] = DR_STR;
    END;

!+
! The largest possible exponent for single and double floating point is
! 38.  G and h floating, however, have largest exponents of 308 and 4932
! respectively.  NUM1$ must be able to print out all these characters but
! the user who doesn't want all these characters should not have to pay the
! performance penalty.  Therefore, fill characters (zero, star, blank) are
! initialized to size 38 and then re-initialized here only if necessary.
!-

    IF (.LARGEST_EXP GTR K_RANGE)
    THEN
	BEGIN
	LOCAL 
	    ZERO : BYTE,
	    STAR : BYTE,
	    BLANK : BYTE;

  	ZEROES_DESC [DSC$W_LENGTH] = .LARGEST_EXP;
	ZEROES_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	ZEROES_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZEROES_DESC [DSC$A_POINTER] = 0;	! STR$DUPL_CHAR will alloc space

	ZERO = %X'30';
	STR$DUPL_CHAR (ZEROES_DESC, LARGEST_EXP, ZERO);
						! create string of zeroes
	ZEROES_PTR = .ZEROES_DESC [DSC$A_POINTER];

	BLANKS_DESC [DSC$W_LENGTH] = .LARGEST_EXP;
	BLANKS_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	BLANKS_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	BLANKS_DESC [DSC$A_POINTER] = 0;

	BLANK = %X'20';
	STR$DUPL_CHAR (BLANKS_DESC, LARGEST_EXP, BLANK);
						! create string of blanks
	BLANKS_PTR = .BLANKS_DESC [DSC$A_POINTER]; 
						
	STAR_DESC [DSC$W_LENGTH] = .LARGEST_EXP;
	STAR_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	STAR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	STAR_DESC [DSC$A_POINTER] = 0;

	STAR = %X'2A';
	STR$DUPL_CHAR (STAR_DESC, LARGEST_EXP, STAR);
						! create string of asterisks
	STAR_PTR = .STAR_DESC [DSC$A_POINTER];	
						
	END
    ELSE
	ZEROES_PTR = ZEROES;			! use string of 38 zeroes
	BLANKS_PTR = BLANKS;
	STAR_PTR = STAR;

    IF (.KERNEL_BLOCK [DEC_EXP] GTR 0)
    THEN
!+
! The number is greater than or equal to 1
!-

	IF (.KERNEL_BLOCK [DEC_EXP] GEQ .NO_DIGITS)
	THEN
	    BEGIN
!+
! This entire number consists only of integer part.  Put the number
! returned by the conversion routine and optionally some trailing
! zeroes into the return string.
!-
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    IF NOT ((.FLAGS AND V_COMMA) NEQ 0 AND
		    (.FLAGS AND V_LEADING_ZERO) NEQ 0)
	    THEN
		BEGIN
	        INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
		INT_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
		END;
	    ZERO_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS;
	    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    ZERO_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    LEADING_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    LEADING_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    LEADING_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	    LEADING_STR_DESC [DSC$W_LENGTH] = 0;		! this will be changed
								! later
!+
! Take advantage of the fact that negative numbers have to have trailing sign if
! the currency symbol is expected to float.
!-
	    LENGTH = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] - 	    
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) AND
		   (.FLAGS AND V_CR_DR) EQL 0
		THEN 1 
		ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_CURRENCY) NEQ 0) THEN .CURRENCY [DSC$W_LENGTH] ELSE 0

	    END
	    - 					! currency symbol
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	    ELSE
		0

	    END;				! commas

!+
! If leading zeroes should be printed, then replace the blanks descriptor
! with a leading zeroes descriptor.
!-

	    IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 
	    THEN
		LEADING_STR_DESC [DSC$W_LENGTH] = .LENGTH  
	    ELSE
		BLANKS_STR_DESC [DSC$W_LENGTH] = .LENGTH;  
	    
	    BLANKS_STR_DESC [DSC$A_POINTER] = .BLANKS_PTR;
	    STAR_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    STAR_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    STAR_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) AND
		   (.FLAGS AND V_CR_DR) EQL 0
		THEN 1 
		ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0) THEN (.KERNEL_BLOCK [DEC_EXP] - 1)/3 ELSE 0

	    END;				! commas
	    STAR_STR_DESC [DSC$A_POINTER] = .STAR_PTR;

	    IF ((.FLAGS AND V_COMMA) EQL 0)
	    THEN
		BEGIN
!+
! There are no commas in this number
!-

		IF (.FLAGS AND V_CURRENCY) NEQ 0 AND
		   (.FLAGS AND V_LEADING_ZERO) NEQ 0
		THEN
		    BEGIN
		    STR$CONCAT (BAS_OUT_STR [0], .CURRENCY,
			(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC
			ELSE IF (.KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR)
			EQL 0) THEN MINUS_DESC ELSE NULL_DESC),
			LEADING_STR_DESC, INT_STR_DESC, ZERO_STR_DESC)
		    END
		ELSE
		    BEGIN
		    STR$CONCAT (BAS_OUT_STR [0],
		    	(IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
		    	(IF (.FLAGS AND V_STAR) NEQ 0 
		    	THEN
			    NULL_DESC
		    	ELSE
!+
! Stars and leading zeroes are mutually exclusive.  If no star fill, then
! check if leading zeroes should be printed.
!-
			    (IF (.FLAGS AND V_LEADING_ZERO) NEQ 0
			    THEN NULL_DESC			! print leading zeroes
			    ELSE BLANKS_STR_DESC)),		! no leading zeroes
		        (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    	(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC 
			ELSE IF (.KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR)
			EQL 0) THEN MINUS_DESC ELSE NULL_DESC), 
			(IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN
			LEADING_STR_DESC ELSE NULL_DESC), INT_STR_DESC, ZERO_STR_DESC)
		    END
		END					! end of no commas
	    ELSE
!+
! There are commas in this number and we need to do some looping on the call to
! concatenate.  The processing got too complex to express in a single call.
!-
		BEGIN

		LOCAL
		    COUNTER,
		    FIRST_GROUP,
		    TEMP_INT_DESC : BLOCK [8, BYTE];
!+
! Concatenate the leading zeroes to the integer, if necessary, so commas will
! be inserted at the proper places.  The length and pointer fields of INT_STR_DESC
! were not intialized earlier so that we can fill them in here.
!-
		IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 
		THEN
		    BEGIN

		    TEMP_INT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
		    TEMP_INT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		    TEMP_INT_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP];
		    TEMP_INT_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] +
						   .KERNEL_BLOCK [OFFSET];
		    INT_STR_DESC [DSC$W_LENGTH] = 0;		
		    INT_STR_DESC [DSC$A_POINTER] = 0;
!+
! Adjust leading zeroes length if extra commas will be required.
!-
		    LEADING_STR_DESC [DSC$W_LENGTH] = .LEADING_STR_DESC [DSC$W_LENGTH] 
			- ((.LEADING_STR_DESC [DSC$W_LENGTH] - 1)/3 * .DIGIT_SEP [DSC$W_LENGTH]);
!*** 1-048    LEADING_STR_DESC [DSC$W_LENGTH] = .LEADING_STR_DESC [DSC$W_LENGTH] 
!*** 1-048- ((.LEADING_STR_DESC [DSC$W_LENGTH] - 1)/3 * .DIGIT_SEP [DSC$W_LENGTH]) - 1;
		    STR$CONCAT (INT_STR_DESC, LEADING_STR_DESC, TEMP_INT_DESC);
		    END;

		FIRST_GROUP = (((IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN .LEADING_STR_DESC [DSC$W_LENGTH]
		    ELSE 0) + .KERNEL_BLOCK [DEC_EXP] - 1) MOD 3) + 1;
		STR$CONCAT (BAS_OUT_STR [0],
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN NULL_DESC 
		    ELSE (IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN NULL_DESC
		    ELSE BLANKS_STR_DESC)),
		    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC 
		    ELSE IF (.KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0)
		    THEN MINUS_DESC ELSE NULL_DESC),
		    (INT_STR_DESC [DSC$W_LENGTH] = MIN (.FIRST_GROUP,
	   	    .LEADING_STR_DESC [DSC$W_LENGTH] + .NO_DIGITS); INT_STR_DESC));
		COUNTER = (IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN .LEADING_STR_DESC [DSC$W_LENGTH]
		    ELSE 0) + .NO_DIGITS - .INT_STR_DESC [DSC$W_LENGTH];
		INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [DSC$W_LENGTH];

		WHILE .COUNTER GTR 0 DO
		    BEGIN
		    INT_STR_DESC [DSC$W_LENGTH] = MIN (.COUNTER, 3);
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .DIGIT_SEP, INT_STR_DESC);
		    INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [
			DSC$W_LENGTH];
		    COUNTER = .COUNTER - .INT_STR_DESC [DSC$W_LENGTH];
		    END;			! WHILE loop

		ZERO_STR_DESC [DSC$W_LENGTH] = (.KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS) MOD 3;

		IF (.ZERO_STR_DESC [DSC$W_LENGTH] NEQ 0)
		THEN
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
			ZERO_STR_DESC);

		ZERO_STR_DESC [DSC$W_LENGTH] = 3;
		COUNTER = (.KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS)/3;

		WHILE (.COUNTER GTR 0) DO
		    BEGIN
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .DIGIT_SEP, ZERO_STR_DESC);
		    COUNTER = .COUNTER - 1;
		    END;			! WHILE loop

	    END;				! of comma processing

!+
! Common ending for comma and non-comma.
!-

	    ZERO_STR_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS;
	    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
		(IF (.FLAGS AND V_PERIOD) NEQ 0 THEN .RADIX_PT ELSE NULL_DESC), ZERO_STR_DESC,
		(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN  
		    IF (.KERNEL_BLOCK [SIGN] LSS 0)
		    THEN MINUS_DESC ELSE BLANK_DESC ELSE NULL_DESC),
		    (IF (.FLAGS AND V_CR_DR) NEQ 0
		    THEN (IF .KERNEL_BLOCK [SIGN] LSS 0 THEN CR_DESC ELSE DR_DESC)
		    ELSE NULL_DESC));

	    BAS_OUT_STR_LEN [0] = (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 1
	    ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
	    THEN 1 ELSE 0))
	    + .KERNEL_BLOCK [DEC_EXP] 
	    + (IF (.FLAGS AND V_COMMA) NEQ 0
	    THEN ((.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH])	! adjust for commas
	    ELSE 0)
	    + (IF (.FLAGS AND V_PERIOD) NEQ 0 THEN .RADIX_PT [DSC$W_LENGTH] ELSE 0)
	    + ZERO_STR_DESC [DSC$W_LENGTH];

	END
	ELSE
	    BEGIN
!+
! This number has both integer and fractional portions.
!-

	    LOCAL
		FRAC_STR_DESC : BLOCK [8, BYTE];

	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    IF NOT ((.FLAGS AND V_COMMA) NEQ 0 AND
	       (.FLAGS AND V_LEADING_ZERO) NEQ 0)
	    THEN
		BEGIN
	        INT_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP];
	        INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
		END;
	    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS - .KERNEL_BLOCK [DEC_EXP];
	    FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]
					    + .KERNEL_BLOCK [DEC_EXP];
	    ZERO_STR_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS - .FRAC_STR_DESC [DSC$W_LENGTH];
	    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    ZERO_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    LEADING_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    LEADING_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    LEADING_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	    LEADING_STR_DESC [DSC$W_LENGTH] = 0;			! to be changed
									! later
!+
! Take advantage of the fact that negative numbers have to have trailing sign if
! the currency symbol is expected to float.
!-
	    LENGTH = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) AND (.FLAGS AND V_CR_DR) EQL 0
		THEN 1 
		ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_CURRENCY) NEQ 0) THEN .CURRENCY [DSC$W_LENGTH] ELSE 0

	    END
	    - 					! currency symbol
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	    ELSE
		0

	    END;				! commas

!+
! If leading zeroes should be printed, then replace the blanks descriptor
! with a leading zeroes descriptor.
!-
	    IF (.FLAGS AND V_LEADING_ZERO) NEQ 0
	    THEN
	  	LEADING_STR_DESC [DSC$W_LENGTH] = .LENGTH 
	    ELSE
		BLANKS_STR_DESC [DSC$W_LENGTH] = .LENGTH;

	    BLANKS_STR_DESC [DSC$A_POINTER] = .BLANKS_PTR;
	    STAR_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    STAR_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    STAR_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
		THEN 1 
		ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	    ELSE
		0

	    END;				! commas
	    STAR_STR_DESC [DSC$A_POINTER] = .STAR_PTR;

	    IF ((.FLAGS AND V_COMMA) EQL 0)
	    THEN
		BEGIN
!+
! There are no commas required.
!-

		IF (.FLAGS AND V_CURRENCY) NEQ 0 AND
		   (.FLAGS AND V_LEADING_ZERO) NEQ 0
		THEN
		    BEGIN
		    STR$CONCAT (BAS_OUT_STR [0], .CURRENCY,
		        (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC
		        ELSE IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
			THEN MINUS_DESC ELSE NULL_DESC), LEADING_STR_DESC, 
			INT_STR_DESC)
		    END
		ELSE
		    BEGIN
		    STR$CONCAT (BAS_OUT_STR [0],
		        (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
			(IF (.FLAGS AND V_STAR) NEQ 0 THEN NULL_DESC ELSE 
			(IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN NULL_DESC ELSE
			BLANKS_STR_DESC)),
		        (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		        (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC 
			ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
			    THEN MINUS_DESC ELSE NULL_DESC)), 
			(IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN LEADING_STR_DESC
			ELSE NULL_DESC), INT_STR_DESC)
		    END
		END

	    ELSE
!+
! This number should have commas in it.  Do all of the fancy figuring and looping.
!-
		BEGIN

		LOCAL
		    COUNTER,
		    FIRST_GROUP,
		    TEMP_INT_DESC : BLOCK [8, BYTE];
!+
! Concatenate the leading zeroes to the integer, if necessary, so commas will
! be inserted at the proper places.  The length and pointer fields of INT_STR_DESC
! were not intialized earlier so that we can fill them in here.
!-
		IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 
		THEN
		    BEGIN

		    TEMP_INT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
		    TEMP_INT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		    TEMP_INT_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP];
		    TEMP_INT_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] +
						   .KERNEL_BLOCK [OFFSET];
		    INT_STR_DESC [DSC$W_LENGTH] = 0;		
		    INT_STR_DESC [DSC$A_POINTER] = 0;
!+
! Adjust leading zeroes length if extra commas will be required.
!-
		    LEADING_STR_DESC [DSC$W_LENGTH] = .LEADING_STR_DESC [DSC$W_LENGTH] 
			- ((.LEADING_STR_DESC [DSC$W_LENGTH] - 1)/3 * .DIGIT_SEP [DSC$W_LENGTH]);
!*** 1-048    LEADING_STR_DESC [DSC$W_LENGTH] = .LEADING_STR_DESC [DSC$W_LENGTH] 
!*** 1-048- ((.LEADING_STR_DESC [DSC$W_LENGTH] - 1)/3 * .DIGIT_SEP [DSC$W_LENGTH]) - 1;
		    STR$CONCAT (INT_STR_DESC, LEADING_STR_DESC, TEMP_INT_DESC);
		    END;

		FIRST_GROUP = (((IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN .LEADING_STR_DESC [DSC$W_LENGTH]
		    ELSE 0) + .KERNEL_BLOCK [DEC_EXP] - 1) MOD 3) + 1;
		STR$CONCAT (BAS_OUT_STR [0],
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN NULL_DESC ELSE (IF (.FLAGS
		    AND V_LEADING_ZERO) NEQ 0 THEN NULL_DESC ELSE BLANKS_STR_DESC)),
		    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE
		    IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
			THEN MINUS_DESC ELSE NULL_DESC),
		    (INT_STR_DESC [DSC$W_LENGTH] = MIN (.FIRST_GROUP,
			.LEADING_STR_DESC [DSC$W_LENGTH] + .NO_DIGITS); INT_STR_DESC));
		COUNTER = (IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN .LEADING_STR_DESC [DSC$W_LENGTH]
		    ELSE 0) + .KERNEL_BLOCK [DEC_EXP] - .INT_STR_DESC [DSC$W_LENGTH];
		INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [DSC$W_LENGTH];

		WHILE .COUNTER GTR 0 DO
		    BEGIN
		    INT_STR_DESC [DSC$W_LENGTH] = MIN (.COUNTER, 3);
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .DIGIT_SEP, INT_STR_DESC);
		    INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [
			DSC$W_LENGTH];
		    COUNTER = .COUNTER - .INT_STR_DESC [DSC$W_LENGTH];
		    END;			! WHILE loop


		END;

!+
! And now for a common ending for both parts (comma and non-comma).
!-
	    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .RADIX_PT, FRAC_STR_DESC, ZERO_STR_DESC,
		(IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
		THEN (IF (.KERNEL_BLOCK [SIGN] LSS 0)
		THEN MINUS_DESC ELSE BLANK_DESC) ELSE NULL_DESC),
		(IF (.FLAGS AND V_CR_DR) NEQ 0 THEN (IF .KERNEL_BLOCK [SIGN] LSS 0
		THEN CR_DESC ELSE DR_DESC) ELSE NULL_DESC));
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		1				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0)
		THEN 1 
		ELSE 0

		END

	    END
	    + .NO_INT_DIGITS + .NO_FRAC_DIGITS +
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]	! adjust for commas
	    ELSE
		0

	    END
	    + .RADIX_PT [DSC$W_LENGTH];		! decimal point
	    END

    ELSE
	BEGIN
!+
! This is a purely fractional number which should be put out in F format
!-

	LOCAL
	    FRAC_STR_DESC : BLOCK [8, BYTE];	! desc. for fraction

!+
! This is the number of zeroes to the right of the decimal point and to the left
! of the first non-zero digit.
!-
	ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZERO_STR_DESC [DSC$W_LENGTH] = -.KERNEL_BLOCK [DEC_EXP];
	ZERO_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
!+
! Put at most one zero to the left of the decimal point
!-
	INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
        INT_STR_DESC [DSC$W_LENGTH] = MIN (1,
	    .NO_INT_DIGITS - (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 0	! trailing sign
	    ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
	    THEN 1 ELSE 0)));
	INT_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	STAR_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	STAR_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	STAR_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .INT_STR_DESC [DSC$W_LENGTH] -
	BEGIN

	IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	THEN
	    0
	ELSE
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0)
	    THEN 1 
	    ELSE 0

	    END

	END;
	STAR_STR_DESC [DSC$A_POINTER] = .STAR_PTR;
	LEADING_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	LEADING_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	LEADING_STR_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	LEADING_STR_DESC [DSC$W_LENGTH] = 0;			! set later in routine
	BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	LENGTH = .NO_INT_DIGITS - .INT_STR_DESC [DSC$W_LENGTH] - (IF (.FLAGS AND
	    V_TRAILING_SIGN) NEQ 0 THEN 0 ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0
	    AND (.FLAGS AND V_CR_DR) EQL 0 THEN 1 ELSE 0)) - (IF (.FLAGS
	    AND V_CURRENCY) NEQ 0 THEN 1 ELSE 0);

!+
! If leading zeroes should be printed, then replace the blanks descriptor with
! a leading zeroes descriptor.
!-

	IF (.FLAGS AND V_LEADING_ZERO) NEQ 0
	THEN
	    LEADING_STR_DESC [DSC$W_LENGTH] = .LENGTH 
	ELSE
	    BLANKS_STR_DESC [DSC$W_LENGTH] = .LENGTH;
	BLANKS_STR_DESC [DSC$A_POINTER] = .BLANKS_PTR;
	FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	IF (.FLAGS AND V_CURRENCY) NEQ 0 AND
	   (.FLAGS AND V_LEADING_ZERO) NEQ 0
	THEN
	    BEGIN
	    STR$CONCAT (BAS_OUT_STR [0], .CURRENCY,
		(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC
		ELSE IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
		THEN MINUS_DESC ELSE NULL_DESC), LEADING_STR_DESC, 
		INT_STR_DESC, .RADIX_PT, ZERO_STR_DESC, FRAC_STR_DESC,
		(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN (IF .KERNEL_BLOCK [SIGN]
		LSS 0 THEN MINUS_DESC ELSE BLANK_DESC) ELSE NULL_DESC),
		(IF (.FLAGS AND V_CR_DR) NEQ 0 THEN (IF .KERNEL_BLOCK [SIGN] LSS 0
		THEN CR_DESC ELSE DR_DESC) ELSE NULL_DESC))
	    END
	ELSE
	    STR$CONCAT (BAS_OUT_STR [0],
	    	(IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
	    	(IF (.FLAGS AND V_STAR) NEQ 0 THEN NULL_DESC ELSE
	    	(IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN NULL_DESC ELSE
		BLANKS_STR_DESC)),
	     	(IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
	    	(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE 
		(IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
		    THEN MINUS_DESC ELSE NULL_DESC)), 
		(IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN LEADING_STR_DESC ELSE
		NULL_DESC), INT_STR_DESC, .RADIX_PT, ZERO_STR_DESC, FRAC_STR_DESC,
	    BEGIN

	    LOCAL
		TEMP_ZERO_DESC : BLOCK [8, BYTE];

	    TEMP_ZERO_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    TEMP_ZERO_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_ZERO_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS - .NO_DIGITS - .ZERO_STR_DESC [DSC$W_LENGTH];
	    TEMP_ZERO_DESC [DSC$A_POINTER] = .ZEROES_PTR;
	    TEMP_ZERO_DESC
	    END
	,
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0)
		THEN MINUS_DESC 
		ELSE BLANK_DESC

		END
	    ELSE
		NULL_DESC

	    END
	,
	    BEGIN
	    IF ((.FLAGS AND V_CR_DR) NEQ 0) THEN (IF .KERNEL_BLOCK [SIGN] LSS 0
	    THEN CR_DESC ELSE DR_DESC) ELSE NULL_DESC
	    END
	);
	BAS_OUT_STR_LEN [0] = (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 1	! trailing sign
	ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 AND (.FLAGS AND V_CR_DR) EQL 0
	THEN 1 ELSE 0)) + .NO_INT_DIGITS + .NO_FRAC_DIGITS + 
	    .RADIX_PT [DSC$W_LENGTH];
	END;

    IF (.LARGEST_EXP GTR K_RANGE)
    THEN
	BEGIN
	STR$FREE1_DX (ZEROES_DESC);
	STR$FREE1_DX (BLANKS_DESC);
	STR$FREE1_DX (STAR_DESC);
	END;

    END;					! Routine FANCY_F_FORMAT

ROUTINE FANCY_E_FORM_11 (			!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN,			!
	DATA_TYPE				!
    ) : JSB_FORMAT_A11 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do the formatting for Basic Print Using E format for h floating.
!
! FORMAL PARAMETERS:
!
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	NO_DIGITS.rlu.v		number of significant digits
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	parameter block for kernel routine
!	CURRENCY.rt.dx		currency symbol - currently unused
!	DIGIT_SEP.rt.dx		digit group separator - currently unused
!	RADIX_PT.rt.dx		radix point
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	DATA_TYPE.rlu.v		data type of the element to format
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	BLANK_STR_DESC : BLOCK [8, BYTE],	! leading blanks for zero
	INT_STR_DESC : BLOCK [8, BYTE],		! integer portion of number
	ZERO_STR_DESC : BLOCK [8, BYTE],	! trailing zeroes
	FRAC_STR_DESC : BLOCK [8, BYTE],	! fractional portion of number
	EXP_STR : VECTOR [5, BYTE],		! string for exponent
	EXP_STR_DESC : BLOCK [8, BYTE],		! Exponent
	LEADING_STR_DESC : BLOCK [8, BYTE];	! leading zeroes

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    BIND
	ZERO = UPLIT (BYTE ('0'));

    INITIALIZE_DESC;

    IF CH$EQL (1, (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]), 1, ZERO)
    THEN
!+
! Set up for zero.  A few parameters need to be tweaked and then the general al-
! gorithm should work fine.
!-
	BEGIN
	BLANK_STR_DESC [DSC$W_LENGTH] = MAX (.NO_INT_DIGITS - 1, 0);
	ZERO_STR_DESC [DSC$W_LENGTH] = 0;
	SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_G]:
		BEGIN
	    	EXP_STR = %ASCII'+000';
		EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
		END;
	    [DSC$K_DTYPE_H]:
		BEGIN
		EXP_STR = UPLIT BYTE (%ASCII'+0000');
		EXP_STR_DESC [DSC$A_POINTER] = .EXP_STR;	! extra level of indirection here
		END;
	    [OTHERWISE]:
		BEGIN
		EXP_STR = %ASCII'+00';
		EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
		END;
	TES;
	IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 
	THEN LEADING_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS;
	END
    ELSE
	BEGIN
	LEADING_STR_DESC [DSC$W_LENGTH] = 0;
	BLANK_STR_DESC [DSC$W_LENGTH] = 0;
	ZERO_STR_DESC [DSC$W_LENGTH] = MAX (.NO_INT_DIGITS - .NO_DIGITS -
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    END
	, 0);
	KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] - .NO_INT_DIGITS +
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	END;					! Add 1 for minus sign
	CVTLP (KERNEL_BLOCK [DEC_EXP], %REF (6), KERNEL_BLOCK [DEC_EXP]);
	SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_G]:
		BEGIN
		CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (3), EXP_STR);
		EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
		END;
	    [DSC$K_DTYPE_H]:
		BEGIN
		CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (4), EXP_STR);
		EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
		END;
	    [OTHERWISE]:
		BEGIN
		CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (2), EXP_STR);
		EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
		END;
	TES;
	END;

    LEADING_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    LEADING_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LEADING_STR_DESC [DSC$A_POINTER] = ZEROES;
    BLANK_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    BLANK_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    BLANK_STR_DESC [DSC$A_POINTER] = BLANKS;
    EXP_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    EXP_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_G]:
		EXP_STR_DESC [DSC$W_LENGTH] = 4;
	    [DSC$K_DTYPE_H]:
		EXP_STR_DESC [DSC$W_LENGTH] = 5;
	    [OTHERWISE]:
		EXP_STR_DESC [DSC$W_LENGTH] = 3;
	TES;
    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    INT_STR_DESC [DSC$W_LENGTH] = MIN (.NO_INT_DIGITS -
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	END
    , .NO_DIGITS);
    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN MINUS_DESC ELSE NULL_DESC

	END
    , (IF (.FLAGS AND V_LEADING_ZERO) NEQ 0 THEN LEADING_STR_DESC ELSE
    BLANK_STR_DESC), INT_STR_DESC, ZERO_STR_DESC);
    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    FRAC_STR_DESC [DSC$W_LENGTH] = MAX (.NO_DIGITS - .NO_INT_DIGITS +
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	END
    , 0);
    FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + 	!
    .KERNEL_BLOCK [OFFSET] + .INT_STR_DESC [DSC$W_LENGTH];
    ZERO_STR_DESC [DSC$W_LENGTH] = MAX (.NO_FRAC_DIGITS - .FRAC_STR_DESC [DSC$W_LENGTH], 0);
    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
	BEGIN

	IF ((.FLAGS AND V_PERIOD) NEQ 0) THEN .RADIX_PT ELSE NULL_DESC

	END
    , FRAC_STR_DESC, ZERO_STR_DESC, E_DESC, EXP_STR_DESC);
    BAS_OUT_STR_LEN [0] = .NO_INT_DIGITS + .NO_FRAC_DIGITS +
    BEGIN

    IF (.FLAGS AND V_PERIOD) THEN .RADIX_PT [DSC$W_LENGTH] ELSE 0

    END
    + (SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_G]:
		5;
	    [DSC$K_DTYPE_H]:
		6;
	    [OTHERWISE]:
		4;
	TES);					! add for exp length
    END;					! Routine FANCY_E_FORM_11

ROUTINE PLAIN_E_FORM_11 (			!
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN,			!
	DATA_TYPE				!
    ) : JSB_FORMAT_A6 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do plain old E formatting where the value returned is in the range from
!	0 to 1.  
!
! FORMAL PARAMETERS:
!
!	NO_DIGITS.rlu.v		number of significant digits in value
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	parameter block for kernel conversion routine
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	DATA_TYPE.rl.v		data type of the element to format
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Returns STR$_TRU
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    LOCAL
	EXP_STR : VECTOR [5, BYTE],		! string for exponent
	EXP_STR_DESC : BLOCK [8, BYTE],		! Exponent
	FRAC_STR_DESC : BLOCK [8, BYTE],	! Fraction
	STATUS;					! Status returned

    EXTERNAL
	OTS$$A_CUR_LUB;

    GLOBAL REGISTER
	CCB = K_CCB_REG : REF BLOCK [, BYTE];

    INITIALIZE_DESC;

!+
! NOTE:	E formatting varies depending on whether we are in ANSI mode or
!	not.  the flag indicating this should be set by the caller; in
!	ANSI mode, the significand is between 1 and 10 whereas in normal
!	mode it is between 0 and 1.  In ANSI mode therefore, the output
!	from the OTS conversion routines must be adjusted somewhat.
!-
    CCB = .OTS$$A_CUR_LUB;

    EXP_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    EXP_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    SELECTONE .DATA_TYPE OF
    SET
	[DSC$K_DTYPE_G]:
	    EXP_STR_DESC [DSC$W_LENGTH] = 4;
	[DSC$K_DTYPE_H]:
	    EXP_STR_DESC [DSC$W_LENGTH] = 5;
	[OTHERWISE]:
	    EXP_STR_DESC [DSC$W_LENGTH] = 3;
    TES;
    EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    IF .DATA_TYPE NEQ DSC$K_DTYPE_H
    THEN
	FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS
    ELSE
    	FRAC_STR_DESC [DSC$W_LENGTH] = MIN(.NO_DIGITS, 5);
    FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];

    !+
    ! kludge for ANSI.  decrement exponent.  significand is adjusted below.
    !-
    IF .CCB NEQ 0 
    THEN 
        IF .CCB [LUB$V_ANSI] EQL 1
	THEN KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] - 1;

    CVTLP (KERNEL_BLOCK [DEC_EXP], %REF (6), KERNEL_BLOCK [DEC_EXP]);
    SELECTONE .DATA_TYPE OF
    SET
	[DSC$K_DTYPE_G]:
	    CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (3), EXP_STR);
	[DSC$K_DTYPE_H]:
    	    CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (4), EXP_STR);
	[OTHERWISE]:
	    CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (2), EXP_STR);
    TES;

    IF ( IF .CCB NEQ 0  THEN .CCB [LUB$V_ANSI] EQL 1
			ELSE 0 )
    THEN
	BEGIN
	!+
	! ANSI.  concatenate:  blank || integer || decimal pt. || fraction !! E !! exponent
	!		       sign
	!
	! this is kludged together by taking the most sigificant digit of the
	! fraction and making it the integer digit of the significand, and
	! by decrementing the value of the exponent.
	!-

	!+
	! set up a local to be the integer portion of the significand
	!-
	LOCAL	TEMP_DESC:	BLOCK [8,BYTE];
    	TEMP_DESC [DSC$A_POINTER] = .FRAC_STR_DESC [DSC$A_POINTER];
        TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
        TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	TEMP_DESC [DSC$W_LENGTH] = 1;

	!+
	! adjust the fractional portion (significand).
	!-
	FRAC_STR_DESC [DSC$A_POINTER] = .FRAC_STR_DESC [DSC$A_POINTER] + 1;
	FRAC_STR_DESC [DSC$W_LENGTH] = .FRAC_STR_DESC [DSC$W_LENGTH] - 1;

	!+
	! adjust the exponent (done above)
	!-

	!+
	! assemble the number by calling STR$CONCAT
	!-
	STATUS = STR$CONCAT (BAS_OUT_STR [0],
	    BEGIN
	    IF (.KERNEL_BLOCK [SIGN] LSS 0)
	    THEN
	        MINUS_DESC
	    ELSE

	        IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
        ,TEMP_DESC, DOT_DESC, FRAC_STR_DESC, E_DESC, EXP_STR_DESC,
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
        );

	END
    ELSE
	BEGIN
	!+
	! not ANSI.  concatenate:  blank || decimal pt. || fraction !! E !! exponent
	!			   sign
	!-
	STATUS = STR$CONCAT (BAS_OUT_STR [0],
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0)
	    THEN
	        MINUS_DESC
	    ELSE

	        IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
        , DOT_DESC, FRAC_STR_DESC, E_DESC, EXP_STR_DESC,
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
        );
	END;

    BAS_OUT_STR_LEN [0] =
    BEGIN

    IF (.FLAGS AND V_STRIP_SPACES)
    THEN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

    ELSE
	2

    END
    + (IF .DATA_TYPE EQL DSC$K_DTYPE_H THEN MIN (.NO_DIGITS,5) ELSE .NO_DIGITS) 
    + (SELECTONE .DATA_TYPE OF
	SET
	    [DSC$K_DTYPE_G]:
		6;
	    [DSC$K_DTYPE_H]:
		7;
	    [OTHERWISE]:
		5;
	TES);					! add exponent length 
    RETURN .STATUS;
    END;					! Routine PLAIN_E_FORM_11
END						!End of module BAS$CVT_OUT

ELUDOM
