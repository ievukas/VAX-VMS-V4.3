%TITLE 'SMG$DISPLAY_OUTPUT - Output Virtual Displays'
MODULE SMG$DISPLAY_OUTPUT (
		IDENT = '1-072'	! File: SMGDISOUT.B32 Edit: PLL1072
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management
!
! ABSTRACT:
!	The procedures in this module output the information contained 
! in virtual displays, using the mappings to windows defined via their
! pastings to pasteboards.  Also include in this module are procedures
! to optimize decisions about what needs to be output, and how to output
! in the most optimal fashion.
!
!	The virtual displays and pasteboards are allocated/deallocated,
! pasted/unpasted, etc. by the procedures in SMG$DISPLAY_LINKS.  The
! contents of the virtual displays themselves are maintained by
! procedures in SMG$DISPLAY_CHANGE.  The routines in module
! SMG$DISPLAY_INPUT support input operations wiht respect to virtual
! displays.
!
!
!
! ENVIRONMENT:	User mode, Shared library routines.
!
! AUTHOR: R. Reichert, CREATION DATE: 27-Jan-1983
!
! MODIFIED BY:
!
! 1-001	- Original.  Skeleton for future code.  RKR 27-Jan-1983
! 1-002 - Further development.  RKR 11-Mar-1983
! 1-003 - Correct names of data structures and macros.  PLL 15-Mar-1983
! 1-004 - Add SMG$FLUSH_BUFFER, SMG$$FLUSH_BUFFER and SMG$CONTROL_MODE.
!	  Delete SMG$ENABLE_BUFFER and SMG$DISABLE_BUFFER.
!	  RKR 17-Mar-1983.
! 1-005 - Minor tweaks to comments.  RKR 18-Mar-1983.
! 1-006 - Change some names.  RKR 25-Mar-1983.
! 1-007 - Make FILL_WINDOW_BUFFER able to handle pastings that don't
!	  correspond exactly to the window buffer.  RKR 28-Mar-1983.
! 1-008 - More debugging of above.  RKR 29-Mar-1983.
! 1-009 - Add some code dealing with borders.  RKR 4-APR-1983.
! 1-010 - Add code for labeled borders.  RKR 7-APR-1983.
! 1-011 - Separate bits used for borders.  RKR 15-APR-1983.
! 1-012 - Move minimal update into its own module along with buffering 
!	  stuff. RKR 15-APR-1983.
! 1-013 - Update screen buffer when minimal update is enabled.
!	  Use symbolic names for mode bits.
!	  STAN 1-May-1983.
! 1-014 - Clear WCB text and attribute buffers at beginning of
!	  SMG$$FILL_WINDOW_BUFFER.  RKR 2-MAY-1983
! 1-015 - Fix double-dot bug in SMG$CONTROL_MODE.
!	  Remove call to SMG$$CONSTRUCT_BORDER_CHAR.
!	  STAN 2-May-1983.
! 1-016 - Flush output when batching ends.
!	  New status returns for SMG$END_DISPLAY_UPDATE.
!	  STAN 3-May-1983
! 1-017	  Complete overhaul of CHECK_FOR_OUTPUT_DCB, CHECK_FOR_OUTPUT_PBCB,
!	  and FILL_WINDOW_BUFFER.
!	  Remove some of the obsolete code resulting from prior edits.
!	  RKR 4-MAY-1983.
! 1-018	  Clean up loose ends from last edit.  Remove 
!	  SMG$$CONSTRUCT_BORDER_CHAR.   RKR 4-MAY-1983
! 1-019	  Speed up redrawing of window buffer by making use of
!	  PP_V_OCCLUDED bit.  RKR 6-MAY-1983.
! 1-020	  Admired edit 1-019.
!	  Set physical (pasteboard) cursor position to the position
!	  corresponding to the logical cursor position in the
!	  last virtual display that the user referenced.
!	  Thus physical cursor position has absolutely nothing
!	  to do with the order the displays are pasted in.
!	  STAN 8-May-1983
! 1-021	  Write SMG$$INVALIDATE_DISPLAY.
!	  STAN 9-May-1983
! 1-022	  Add optimized move for contiguous source and destination in
!	  SMG$$FILL_WINDOW_BUFFER and SMG$$CHECK_FOR_OUTPUT_DCB.
!	  RKR 9-MAY-1983.
! 1-023	  Force REPAINT_SCREEN to repaint the screen even though it did
!	  not think the screen changed.
!	  STAN 10-May-1983
! 1 -024  Fix Draw Border -- problem with border element overwriting
!	  cell that has video attributes.
!	  RKR 13-May-1983.
! 1 -025  Take advantage of sizes available in DCB, WCB and PP.  No
!	  longer need to multiply number of rows by number of cols.
!	  RKR 13-MAY-1983.
! 1 -026  Repackage inner-most subroutines to allow usage by input
!	  support routines.
!	  RKR 15-MAY-1983.
! 1-027	  Add SMG$BEGIN_PASTEBOARD_UPDATE and SMG$END_PASTEBOARD_UPDATE.
!	  STAN 16-May-1983.
! 1-028   Change logic of CHECK_FOR_OUTPUT_PBCB with respect to no
!	  pasting packets.
!	  RKR 18-MAY-1983.
! 1-029   Fix CHECK_FOR_OUTPUT_PBCB.  Check for no pasting packets is
!	  wrong.
!	  RKR 18-MAY-1983.
! 1-030	 Delete references to external DD_ structures and counts --
!	 no longer needed.
!	 Partial fix up of SMG$RING_BELL -- add display_id argument.
!	 RKR 20-MAY-1983.
! 1-031  Add logic to BEGIN_DISPLAY_UPDATE and END_DISPLAY_UPDATE to
!	 back up and restore DCBs.
!	 RKR 23-MAY-1983.
! 1-032  Fix RING_BELL.  TIMES by reference to STR$DUPL_CHAR.
!	 RKR 23-MAY-1983.
! 1-033  Add code to calc. what part of WCB buffers got changed and
!	 leave this info in PBCB for output routines to use.
!	 RKR 26-MAY-1983.
! 1-034  Allow RING_BELL to return SS$_NORMAL if no error occurs.
!	 STAN 27-May-1983
! 1-035	 Rename PBCB_B_COLS to PBCB_W_WIDTH.
!	 STAN 1-Jun-1983.
! 1-036  Add some bullet proofing to routine calls that don't check
!	 status.  Make SMG$$POINT_IN_RECT into SMG$$POINT_IN_RECT_R3.
!	 RKR 8-JUN-1983.
! 1-037  Make DRAW_BORDER affect the record of what area of the
!	 window control block buffer was modified.
!	 RKR 9-JUN-1983.
! 1-038  Make SMG$END_DISPLAY_UPDATE perform the pasting packet
!	 constant recalculations if DCB_V_PP_MISMATCH indicates that
!	 the SMG$DISPLAY_LINKS routine couldn't do it at the time the
!	 change occurred because the display was batched.
!	 RKR 17-JUN-1983.
! 1-039 In CHECK_FOR_OUTPUT_DCB rearrange inner loop to check for 
!	pasteboard batching and to use action code to decide whether
!	border needs to be (re)drawn.
!	In END_DISPLAY_UPDATE, pass action code to CHECK_FOR_OUTPUT_DCB.
!	RKR 20-JUN-1983.
! 1-040 Fix error introduced in last edit.  Advancement to next PP must
!	must be inside outer loop, but not inside inner loop.
!	RKR 21-JUN-1983
! 1-041 Speed up SMG$$MOVE_TEXT_TO_WINDOW_BUF by moving alternate 
!	character set logic into its own incr loop instead of checking 
!	for existance of alternate character set each time in main loop.
!	RKR 22-JUN-1983.
! 1-042 Further speed up of SMG$$MOVE_TEXT_TO_BUF.
!	RKR 22-JUN-1983.
! 1-043 Smarten up SMG$$END_DISPLAY_UPDATE to recognize situations where
!	it is necessary to redraw the affected pasteboard buffers from
!	the bottom out -- rather than just the display that had its
!	batching lifted.
!	RKR 24-JUN-1983.
! 1-044 Remove LIB$PUT_SCREEN from the EXTERNAL declaration so that SCRSHR
!	will not be pulled into the SMGSHR shareable image.  PLL 1-Jul-1983
! 1-045 Add logic to map the line characteristic vector during mapping
!	operations.
!	RKR 7-JUL-1983.
! 1-046 Add procedure SMG$FIND_CURSOR_DISPLAY.  Calcs. which virtual
!	display the current physical cursor is in (if any).
!	RKR 27-JUL-1983.
! 1-047 Rewrite SMG$$MOVE_TEXT_TO_WINDOW_BUF to accomodate double-wide
!	and double-wide/double-high.
!	Add optimization to SMG$$CHECK_FOR_OUTPUT_DCB to treat functions
!	that only change the cursor position as a special case.
!	RKR 31-Aug-1983.
! 1-048 STAN 31-Aug-1983. Round right rather tha left when pasting a
!	virtual display to an even boundary.
! 1-049 Fix border positioning for DWDH.
!	Fix places where "first_changed_row" and "last_changed_row"
!	incorrectly computed.  RKR 1-SEP-1983.
! 1-050 Further fixes in SMG$$MOVE_TEXT_TO_WINDOW_BUF wrt DWDH.
!	RKR 6-SEP-1983.
! 1-051 Fix SMG$$DRAW_BORDER to make border labels come out right
!	under DWDH situations.  RKR 7-SEP-1983.
! 1-052 Fix SMG$$DRAW_BORDER to pick up rendition bits for border
!	labels.  RKR 15-SEP-1983.
! 1-053 Allow CLEAR_SCREEN control mode. STAN 24-SEP-1983.
!	Check dummy arguments by name rather than by number.
! 1-054 Fix MOVE_TEXT_TO_WINDOW_BUFFER to remap border elements when
!	there is a transition from normal to DWDH or vice versa.
!	(STAN: Repaint clears line characteristics.)
!	RKR 11-OCT-1983.
! 1-055 Fix DRAW_BORDER for DHDW.  RKR 12-OCT-1983.
! 1-056 Replace critial loop by a SKPC in SMG$$MOVE_TEXT_TO_WINDOW_BUF.
!	RKR 9-NOV-1983.
! 1-057 Changes to SMG$$DRAW_BORDER and SMG$$MOVE_TEXT_TO_WINDOW_BUF
!       to not do special mapping for DW/DWDH if device doesn't
!	support this action.
!	RKR 10-NOV-1983.
! 1-058 Make SMG$$CHECK_FOR_OUTPUT_PBCB initialize WCB [WCB_A_CHAR_SET_BUF]
!       if one exists.  RKR 28-NOV-1983.
! 1-059 Make SMG$BEGIN_DISPLAY_UPDATE call SMG$$DUPL_VIRTUAL_DISPLAY
!	unconditionally.  SMG$$DUPL_VIRTUAL_DISPLAY now has the smarts to
!	decide whether a new DCB needs to be created or whether only current
!	context needs to be preserved in an already-existing backup DCB.
!	RKR 28-NOV-1983.
! 1-060 Introduce inner routine SMG$$BEGIN_PASTEBOARD_UPDATE_R1 and
!	SMG$$END_PASTEBOARD_UPDATE_R2.
!	RKR 2-DEC-1983.
! 1-061 Use new routine SMG$$UPDATE_PHYSICAL_CURSOR to fix physical cursor
!	position in cursor-positioning-only path through
!	SMG$$CHECK_FOR_OUTPUT_DCB.
!	RKR 15-DEC-1983.
! 1-062 Fix SMG$END_DISPLAY_UPDATE.  It was returning garbage if the batching
!	level was already 0.
!	RKR 16-DEC-1983.
! 1-063 Fix SIGNED/UNSIGNED problems in SMG$$POINT_IN_RECT_R3 and in
!	SMG$$OCCLUDE.  Change linkage to SMG$$POINT_IN_RECT_R3.
!	RKR 17-Jan-1984.
! 1-064 Fix SMG$$DRAW_BORDER for cases where virtual display is:
!	a). Wider than pasteboard and pasted at 0 or negative col  and
!	b). Higher than pasteboard and pasted at 0 or negative row
!	RKR 23-Jan-1984.
! 1-065 Make SMG$$DRAW_BORDER abandon attempt to draw border altogether if none
!	of the virtual display maps onto the visible part of the pasteboard.
!	RKR 24-Feb-1984.
! 1-066 Add routine SMG$GET_CHAR_AT_PHYSICAL_CURSOR.  RKR  28-FEB-1984.
! 1-067 Move INVALIDATE_DISPLAY to file SMGPRVINP.B32. STAN 7-Mar-1984.
! 1-068 Update header of CONTROL_MODE to mention the NOTABS bit and CLEAR_SCREEN.
!	STAN 14-Mar-1984.  Add public entry point SMG$INVALIDATE_DISPLAY.
! 1-069 If only one line of a DCB changed, tell that to output, instead
!	of erroneously telling output that the whole display changed.
!	STAN 5-May-1984.
! 1-070 Make horizontal borders knock down DHDW characteristic. STAN 17-Jun-1984.
! 1-071 Fix to SMG$CONTROL_MODE to allow notabs bit.  PLL 28-Jun-1984
! 1-072 Tighten up some consistency checks on the data structures.  It was
!	possible to get in an endless loop while walking the pasting packet
!	chain.  PLL 18-Jul-1984
!--

%SBTTL 'Declarations'
!
! SWITCHES:
!

!
! LINKAGES:
!
LINKAGE
    POINT_IN_RECT_LINK = JSB ( REGISTER = 0, REGISTER = 1, REGISTER = 2) :
			 NOPRESERVE ( 3)
			 NOTUSED (4,5,6,7,8,9,10,11);
!
! INCLUDE FILES
!

REQUIRE 'RTLIN:SMGPROLOG.REQ';		! defines psects, macros, tcb,
					!  wcb, & terminal symbols
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

! Public entry points:

    SMG$BEGIN_DISPLAY_UPDATE,		! Advance buffering level count for
					! a virtual display

    SMG$BEGIN_PASTEBOARD_UPDATE,	! Advance buffering level count for
					! a pasteboard

    SMG$CONTROL_MODE,			! Control operational modes


    SMG$END_DISPLAY_UPDATE,		! Decr. buffering level count
					! and flush to screen if it
					! reaches zero.

    SMG$END_PASTEBOARD_UPDATE,		! Decr. buffering level count
					! for a pasteboard, and flush to
					! screen if it reaches 0.

    SMG$FIND_CURSOR_DISPLAY,		! Find the display which
					! contains the current physical
					! cursor position (if any).

    SMG$GET_CHAR_AT_PHYSICAL_CURSOR,	! Return char at physical cursor
					! location

    SMG$INVALIDATE_DISPLAY,		! Mark contents of display as unknown.

    SMG$REPAINT_SCREEN,			! Repaint the entire screen the
					! way our internal database says
					! it should look.

    SMG$RING_BELL,			! Ring bell

! Private entry points:

    SMG$$BEGIN_PASTEBOARD_UPDATE_R1 : SMG$$BEGIN_PBD_UPDATE$LNK,
					! Inner BEGIN_PASTEBOARD_UPDATE

    SMG$$CHECK_FOR_OUTPUT_DCB,		! Check to see if a virtual
					! display needs to be flushed to
					! screen.

    SMG$$CHECK_FOR_OUTPUT_PBCB,		! Refresh everything on this
					! pasteboard -- triggered by
					! an unpaste.

    SMG$$DRAW_BORDER,			! Move border characters into
					! WCB text buffer.

    SMG$$END_PASTEBOARD_UPDATE_R2 : SMG$$END_PBD_UPDATE$LNK,
					! Inner END_PASTEBOARD_UPDATE

    SMG$$FILL_WINDOW_BUFFER,		! Fill the window buffer
					! associated with a pasteboard
					! with images of the virtual
					! displays that map into it.

    SMG$$MOVE_TEXT_TO_WINDOW_BUF,	! move text from DCB buffers to
					! WCB window buffers.

    SMG$$OCCLUDE,			! Check whether two rectangular
					! areas occlude each other.

    SMG$$POINT_IN_RECT_R3 : POINT_IN_RECT_LINK;	! Returns codes 
						! indicating where a 
						! given point is with
						! respect to a given 
						! rectangular area.


!
! EXTERNAL REFERENCES
!

EXTERNAL
    PBD_L_COUNT,	! No. of pasteboards we currently have

    PBD_A_PBCB : VECTOR [PBD_K_MAX_PB, LONG],
			! Table of addresses of PBCB's

    PBD_V_PB_AVAIL : BITVECTOR [PBD_K_MAX_PB];
			! Bit vector or pasteboard id numbers in use.

EXTERNAL LITERAL

    SMG$_BATSTIPRO,	! Success; but batching is still in progress.
    SMG$_BATWASOFF,	! Success; but batching was already off
    SMG$_BATWAS_ON,	! Success; but batching was already on
    SMG$_FATERRLIB,	! Fatal error in library procedure
    SMG$_INVARG,	! Invalid argument
    SMG$_INVCOL,	! Invalid column number
    SMG$_INVDIS_ID,	! Invalid virtual display id
    SMG$_INVPAS_ID,	! Invalid pasteboard id
    SMG$_INVROW;	! Invalid row number

EXTERNAL ROUTINE
    LIB$ESTABLISH,		! Used to establish a handler
    LIB$FREE_VM,		! Deallocate heap storage
    LIB$GET_VM,			! Allocate heap storage
    LIB$SFREE1_DD,		! Free a dynamic string
    LIB$SIG_TO_RET,		! Handler to turn signals into return
				! statuses.
    STR$DUPL_CHAR,		! Make a string of N copies of a byte.
    SMG$$DUPL_VIRTUAL_DISPLAY,	! Make a copy of a DCB with a new
				! display id.
    SMG$$FLUSH_BUFFER,		! Flush remaining buffered output
    SMG$$INVALIDATE_DISPLAY,	! Tell SMG that user has
				! written into this display on his own.
    SMG$$MIN_UPD,		! Minimal update output routine
    SMG$$OUTPUT,		! Output a string to a pasteboard device
    SMG$$RECALC_PP_FIELDS,	! Recalc. PP fields after batching level
				! lifted on a DCB
    SMG$$UPDATE_PHYSICAL_CURSOR;! Update physical cursor position

!<BLF/PAGE>

%SBTTL 'SMG$BEGIN_DISPLAY_UPDATE - Begin batch of updates to display'
GLOBAL ROUTINE SMG$BEGIN_DISPLAY_UPDATE ( DISPLAY_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Disable outputing this virtual display to the screen until the
!	matching call to SMG$END_DISPLAY_UPDATE is encountered.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$BEGIN_DISPLAY_UPDATE ( DISPLAY_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Display id of virtual display.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion, batching has been
!			initiated
!	SMG$_BATWAS_ON	Success, but note that batching was already on
!	SMG$_INVDIS_ID	Invalid Display Id
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	DCB : REF BLOCK [,BYTE];	! Addr of display control block

!+
! Check for right number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT ( 1, 1);

    $SMG$GET_DCB (.DISPLAY_ID, DCB);	! Get DCB address

!+
! Increment count of number of SMG$END_DISPLAY_UPDATE calls we need to
! see before we resume outputing from this virtual display.
! Let the user know what the previous state of batching was by
! our status return (in case he's interested).
!-
    DCB [DCB_L_BATCH_LEVEL] = .DCB [DCB_L_BATCH_LEVEL] + 1;

    IF .DCB [DCB_L_BATCH_LEVEL] EQL 1
    THEN
	BEGIN	! Begin of batching operation
	LOCAL
	    STATUS,			! Status of subroutine calls
	    PP : REF BLOCK [,BYTE];	! Addr of a pasting packet

	!+
	! Make a copy of current DCB and leave its address in the
	! backup pointer field of the current DCB.
	!-
	IF NOT (STATUS = SMG$$DUPL_VIRTUAL_DISPLAY (
				DCB,			 ! Addr of curr.
				DCB [DCB_A_BACKUP_DCB])) ! Where new
							 ! get stored.
        THEN
	    RETURN (.STATUS);

	!+
	! Walk chain of all pasteboards that we are pasted to and for
	! each encountered, in the affected pasting packet, set the
	! back pointer to the DCB to be the new DCB we've created.
	! This causes all mapping operations to reference the backed up
	! DCB as the source of images for the screen.  This is the
	! desired action since the current DCB is undergoing changes
	! which should not yet find their way to the screen -- its
	! batched.
	!-
	PP = .DCB [DCB_A_PP_NEXT];

	IF .PP EQL 0
	THEN
	    RETURN (SMG$_FATERRLIB);		! should never be 0
						! (points to self when empty)

	WHILE .PP NEQ DCB [DCB_A_PP_NEXT]	! While any remain
	DO
	    BEGIN
	    PP [PP_A_DCB_ADDR] = .DCB [DCB_A_BACKUP_DCB];
	    PP = .PP [PP_A_NEXT_DCB];	! Step to next packet
	    END;
	RETURN	SS$_NORMAL;

	END	! Begin of batching operation

    ELSE

	RETURN	SMG$_BATWAS_ON

    END;		! End of routine SMG$BEGIN_DISPLAY_UPDATE
!<BLF/PAGE>

%SBTTL 'SMG$BEGIN_PASTEBOARD_UPDATE - Begin batch of updates to pasteboard'
GLOBAL ROUTINE SMG$BEGIN_PASTEBOARD_UPDATE ( PBID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Disable outputing this pasteboard to the screen until the
!	matching call to SMG$END_PASTEBOARD_UPDATE is encountered.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$BEGIN_PASTEBOARD_UPDATE ( PBID.rl.r)
!
! FORMAL PARAMETERS:
!
!	PBID.rl.r		Pasteboard id.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion, batching has been
!			initiated
!	SMG$_BATWAS_ON	Success, but note that batching was already on
!	SMG$_INVPAS_ID	Invalid Pasteboard Id
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	PBCB : REF BLOCK [,BYTE];	! Addr of pasteboard control block

!+
! Check for right number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT ( 1, 1);

    $SMG$GET_PBCB (.PBID, PBCB);	! Get PBCB address

    RETURN (SMG$$BEGIN_PASTEBOARD_UPDATE_R1 (.PBCB)); ! Do work in inner routine

    END;		! End of routine SMG$BEGIN_PASTEBOARD_UPDATE
!<BLF/PAGE>

%SBTTL 'SMG$END_DISPLAY_UPDATE - End batch of updates to display'
GLOBAL ROUTINE SMG$END_DISPLAY_UPDATE ( DISPLAY_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Reduce the number of calls to SMG$END_DISPLAY_UPDATE that will
!	be needed before we resume outputing from this display.  If
!	this call makes this count go to zero, flush the display to
!	the screen.
!	If the level is already 0, we return a success status
!	informing caller that the batching level was already 0,
!	but we otherwise allow this.  This gives a user a guaranteed
!	method of ending batching.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$END_DISPLAY_UPDATE ( DISPLAY_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Display id of virtual display.
!
! IMPLICIT INPUTS:
!
!	DCB [DCB_L_BATCH_LEVEL]
!
! IMPLICIT OUTPUTS:
!
!	DCB [DCB_L_BATCH_LEVEL] gets decremented
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_BATSTIPRO	Success; but batching is still in progress.
!	SMG$_INVDIS_ID	Invalid Display Id
!	SMG$_BATWASOFF	Success; but batching was already off
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS,				! Status to return
	DCB : REF BLOCK [,BYTE];	! Addr of display control block

!+
! Check for right number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT ( 1, 1);

    $SMG$GET_DCB (.DISPLAY_ID, DCB);	! Get DCB address

!+
! If current count is greater than 1, simply reduce it by one and
! return to caller.  If it is one, reduce it to zero and cause the
! current contents of this window to be flushed to the screen (if need
! be).
!-
    IF .DCB [DCB_L_BATCH_LEVEL] GTR 1
    THEN
	BEGIN
	DCB [DCB_L_BATCH_LEVEL] = .DCB [DCB_L_BATCH_LEVEL] - 1;
	STATUS = SMG$_BATSTIPRO;	! Ok, but batching is still in 
	END				! progress

    ELSE

	BEGIN	! Level is currently 0 or 1
	LOCAL 
	    BATCH_STATUS;

	BATCH_STATUS = SS$_NORMAL;
	IF .DCB [DCB_L_BATCH_LEVEL] EQL 0
	THEN
	    RETURN ( SMG$_BATWASOFF)	! Ok, but batching was already off
	ELSE

	    BEGIN	! Reduction from 1 to 0
	    LOCAL
		PP : REF $PP_DECL;	! Addr of a pasting packet

	    DCB [DCB_L_BATCH_LEVEL] = 0;
	    !+
	    ! Walk chain of pastboards to which we are pasted.  For each
	    ! pasting packet involved, set the pointer in the pasting
	    ! packet back to the original DCB since it is now free of
	    ! batching and its contents can be mapped to the screen.
	    ! Note: We do not deallocate the backup DCB.  The assumption
	    ! is that if the caller batched this virtual display once,
	    ! he is likely to do it again.  This saves us having to
	    ! deallocate now only to have to do another
	    ! SMG$$DUPL_VIRTUAL_DISPLAY when he starts batching again.
	    !-
	    PP = .DCB [DCB_A_PP_NEXT];

	    IF .PP EQL 0
	    THEN
		RETURN (SMG$_FATERRLIB);	! should never be 0

	    WHILE .PP NEQ DCB [DCB_A_PP_NEXT]	! While any remain...
	    DO
		BEGIN
		PP [PP_A_DCB_ADDR] = .DCB;	! To orig. DCB
		PP = .PP [PP_A_NEXT_DCB];	! To next packet
		END;

	    !+
	    ! If DCB_V_PP_MISMATCH is set, a change has been made to
	    ! this DCB which requires the pasting packet constants to be
	    ! recalculated.  However, the DCB was "batched" at the time
	    ! the change took place, so we do the pasting packet update
	    ! now as part of the unbatching process.
	    !-
	    IF .DCB [DCB_V_PP_MISMATCH]
	    THEN
		BEGIN	! Unbatching clean up
		LOCAL
		    CURR_PP : REF $PP_DECL; ! Addr of a pasting packet

		IF NOT (STATUS = SMG$$RECALC_PP_FIELDS (.DCB))
		THEN
		    RETURN (.STATUS);

		DCB [DCB_V_PP_MISMATCH] = 0 ; ! Knock down flag

		!+
		! Since DCB_V_PP_MISMATCH was set, the change to the DCB
		! included dimensional changes.  This means we will have
		! to remap the whole pasteboard buffer from the bottom
		! outward -- for each pasteboard that we are pasted to.
		!-
		CURR_PP = .DCB [DCB_A_PP_NEXT];

		IF .CURR_PP EQL 0
		THEN
		    RETURN (SMG$_FATERRLIB);	! should never be 0

		WHILE .CURR_PP NEQ DCB [DCB_A_PP_NEXT]
		DO
		    BEGIN	! For all pasteboards
		    LOCAL
			PBCB : REF $PBCB_DECL;	! Addr of a pasteboard
						! control block

		    PBCB = .CURR_PP [PP_A_PBCB_ADDR];
		    IF NOT (STATUS = SMG$$CHECK_FOR_OUTPUT_PBCB (.PBCB))
		    THEN
			RETURN (.STATUS); ! Quit on first failure

		    CURR_PP = .CURR_PP [PP_A_NEXT_DCB]; ! To next packet
		    END;	! For all pasteboards

		RETURN (SS$_NORMAL);
		END	! Unbatching clean up

	    ELSE

		BEGIN	! No cleanup needed
		!+
		! Call SMG$$CHECK_FOR_OUTPUT_DCB to cause the contents 
		! of this virtual display to be	flushed to the screen.
		! If that fails, then return its status as our status.
		! If that succeeded then return our previously 
		! calculated status.
		!-
		STATUS = SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					    SMG$C_END_DISPLAY_UPDATE);
		IF .STATUS THEN STATUS=.BATCH_STATUS
		END;	! No cleanup needed
	    END;	! Reduction from 1 to 0
	END;	! Level is currently 0 or 1

    RETURN (.STATUS);
    END;		! End of routine SMG$END_DISPLAY_UPDATE
!<BLF/PAGE>

%SBTTL 'SMG$END_PASTEBOARD_UPDATE - End batch of updates to pasteboard'
GLOBAL ROUTINE SMG$END_PASTEBOARD_UPDATE ( PBID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Reduce the number of calls to SMG$END_PASTEBOARD_UPDATE that will
!	be needed before we resume outputing from this pasteboard.  If
!	this call makes this count go to zero, flush the pasteboard to
!	the screen.
!	If the level is already 0, we return a success status
!	informing caller that the batching level was already 0,
!	but we otherwise allow this.  This gives a user a guaranteed
!	method of ending batching.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$END_PASTEBOARD_UPDATE ( PBID.rl.r)
!
! FORMAL PARAMETERS:
!
!	PBID.rl.r		Pasteboard id.
!
! IMPLICIT INPUTS:
!
!	PBCB [PBCB_L_BATCH_LEVEL]
!
! IMPLICIT OUTPUTS:
!
!	PBCB [PBCB_L_BATCH_LEVEL] gets decremented
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_BATSTIPRO	Success; but batching is still in progress.
!	SMG$_INVPAS_ID	Invalid Pasteboard Id
!	SMG$_BATWASOFF	Success; but batching was already off
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS,				! Status to return
	PBCB : REF BLOCK [,BYTE];	! Addr of pasteboard control block

!+
! Check for right number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT ( 1, 1);

    $SMG$GET_PBCB (.PBID, PBCB);	! Get PBCB address

    RETURN (SMG$$END_PASTEBOARD_UPDATE_R2 (.PBCB)); ! Do work in inner routine

    END;		! End of routine SMG$END_PASTEBOARD_UPDATE
!<BLF/PAGE>

%SBTTL 'SMG$FIND_CURSOR_DISPLAY - Find which virtual display contains physical cursor'
GLOBAL ROUTINE SMG$FIND_CURSOR_DISPLAY (
						PASTEBOARD_ID,
						DISPLAY_ID
						     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines which virtual display contains the
!	current physical cursor on the screen.  The pasted virtual
!	displays are searched from the deepest pasted one to the
!	outer-most pasted one.  The outer-most virtual display that
!	encompasses the physical cursor is the one selected and its
!	display id is returned.
!
!	It is possible that no virtual display contains the cursor,
!	in which case a display id of zero (an invalid display id) is
!	returned.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$FIND_CURSOR_DISPLAY (
!					PASTEBOARD_ID.rl.r,
!					DISPLAY_ID.wl.r)
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	Address of a longword containing the
!				pasteboard_id for the device for which
!				the information is desired.
!
!	DISPLAY_ID.wl.r		Address of a longword to receive the
!				virtual display_id of the virtual
!				display which contains the cursor.
!				The outer-most pasted virtual display
!				that contains the cursor is selected.
!				If no virtual display can be found,
!				a display id of 0 ( an invalid display
!				id) is supplied.
!
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_INVPAS_ID	Invalid pasteboard id
!	SMG$_WRONUMARG	Wrong number of arguments
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	PBCB : REF $PBCB_DECL,	! Address of pasteboard control block

	WCB  : REF $WCB_DECL,	! Address of window control block

	PP;			! An address pointing at the PP queue
				! header in a pasting packet.  This
				! address is not the base of the
				! pasting packet.
!+
! Check for right number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT ( 2, 2);

!+
! Get address of pasteboard control block and the WCB that goes with it.
!-
    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB );
    WCB = .PBCB [PBCB_A_WCB];

!+
! Set up an answer of none in case search turns up nothing.
!-
    .DISPLAY_ID = 0;

!+
! Search all the pasting packets for this pasteboard, from the deepest-
! pasted one to the outer-most pasted one.  For each such pasting
! packet, see if the physical cursor position lies inside the
! mapping of the associated virtual display.  For each virtual display
! found, set up output parameter.  The last one found (if any) will be
! the one the caller sees.
!-
    PP = .PBCB [PBCB_A_PP_PREV]; ! Start with inner-most pasted one

    IF .PP EQL 0
    THEN
	RETURN (SMG$_FATERRLIB);	! should never be 0

    WHILE .PP NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! For all pasting packets
	LOCAL
	    PP_BASE : REF $PP_DECL;	! Base address of a pasting
					! packet

	PP_BASE = .PP - PP_PBCB_QUEUE_OFFSET;

	IF .PP_BASE [PP_W_ROWS_TO_MOVE] NEQ 0
	THEN
	    BEGIN	! Projects somewhere on visible pasteboard
	    LOCAL
		D_PROJ : BLOCK [8,BYTE]; ! Representation of virtual 
					 ! display's projection on
					 ! pasteboard.

	    D_PROJ [DCB_W_ROW_START] = .PP_BASE [PP_W_FIRST_WCB_ROW];

	    D_PROJ [DCB_W_NO_ROWS]   = .PP_BASE [PP_W_LAST_WCB_ROW] -
				       .PP_BASE [PP_W_FIRST_WCB_ROW] +1;

	    D_PROJ [DCB_W_COL_START] = .PP_BASE [PP_W_FIRST_WCB_COL];

	    D_PROJ [DCB_W_NO_COLS]   = .PP_BASE [PP_W_LAST_WCB_COL] -
				       .PP_BASE [PP_W_FIRST_WCB_COL] +1;

	    !+
	    ! Check to see if cursor lies within projection of this
	    ! virtual display.
	    !-
	    IF SMG$$POINT_IN_RECT_R3 (WCB [WCB_W_OLD_CUR_COL],
				      WCB [WCB_W_OLD_CUR_ROW],
				      D_PROJ) EQL 0
	    THEN
		.DISPLAY_ID = .PP_BASE [PP_A_DCB_ADDR]; !  Save candidate

	    END;	! Projects somewhere on visible pasteboard

	PP = .PP_BASE [PP_A_PREV_PBCB] ; ! To next outer pasting
	END;	! For all pasting packets

    RETURN (SS$_NORMAL);
    END;		! Routine SMG$FIND_CURSOR_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$CONTROL_MODE - Control overall mode of operation'
GLOBAL ROUTINE SMG$CONTROL_MODE (
				  PASTEBOARD_ID,
				  NEW_MODE_BITS,
				  OLD_MODE_BITS
				) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine allows the caller to interrogate various modes
!	of the overall operation of the SMG$ package, and to change
!	those modes.  Each pasteboard (hence device) has its own set
!	of mode settings.
!
!	The modes currently defined are:
!
!		1.  Use of buffers.  Under normal operation, the SMG$
!		package will output to the terminal as soon as it has
!		determined what needs to be written.  That is, no
!		internal buffering will be done.  This mode is the
!		default because it requires no follow-up effort on the
!		part of the user to periodically force the buffer to the
!		terminal.
!		However, greater efficiency of $QIO usage can be
!		achieved by enabling buffering.  In this mode, the SMG$
!		package buffers all of its output for efficient usage of
!		$QIO's.  The caller can at any time call 
!		SMG$FLUSH_BUFFER to force to the screen any output which
!	 	has been queued to the screen, but not yet actually 
!		output.  For example, in this mode, each input operation
!		initiated via the SMG$ facility will force a 
!		SMG$FLUSH_BUFFER call.
!
!		Default setting is to not provide buffering.
!
!		2.  Minimal screen update.  Unless explicitly told not
!		to, the SMG$ package will try to minimize the number
!		of characters actually sent to a terminal to increase 
!		overall system throughput.  It achieves this in part by
!		remembering what is currently on the screen and actually
!		outputing only the specific character sequences which 
!		will change the current contents of the screen into the
!		desired contents of the screen.  As a result of this 
!		action, the original sequence of changes may not be 
!		preserved.  Generally, the screen is repainted so 
!		rapidly the this difference is not noticable since the 
!		resultant screen appears the way it should.  In rare 
!		circumstances, perhaps while debugging a new 
!		application, the caller may which to change this 
!		behavior to strictly preserve the order of his output.
!
!		The default mode is to perform minimal screen update.
!		There is currently not much difference if you omit this
!		bit because it really doesn't make much sense to repaint
!		the entire screen when you change just one character,
!		but this may change in future releases.  For now,
!		you should always specify this bit.
!
!		3. CLEAR_SCREEN. If this bit is set, then when SMG exits
!		normally, it will clear the screen just before returning
!		control to DCL.
!
!		4. NOTABS.  If this bit is set, then SMG will never rely
!		on physical tabs even if the terminal supports them.
!		If not set, then SMG will feel free to use physical
!		tabs for the minimal update procedure.  Such use implicitly
!		assumes that your terminal's tab stops are set to the
!		DEC default locations.  Set this bit if you want to guarantee
!		that your product will run regardless of the tab settings
!		that the user has physically set on his terminal.
!
!	The three parameters are optional.  First, if OLD_MODE_BITS
!	is supplied, it is filled in with the current mode bit settings.
!	Secondly, if the NEW_MODE_BITS parameter is provided, its
!	contents are used to set the current mode(s) of operation.
!	
!	Hence this routine can typically be used in three way.
!	a).	To find out current settings:
!		SMG$CONTROL_MODE ( PASTEBOARD_ID, , OLD_MODE_BITS)
!
!	b).	To set the bits with no regard for their current setting:
!		SMG$CONTROL_MODE ( PASTEBOARD_ID, NEW_MODE_BITS)
!
!	c).	To write modular code, saving the current settings,
!		setting them to your desired setting, then restoring
!		original settings before exiting your procedure:
!		SMG$CONTROL_MODE ( PASTEBOARD_ID, 
!				   NEW_MODE_BITS, saved_mode_bits )
!		and before exiting,
!		SMG$CONTROL_MODE ( PASTEBOARD_ID, saved_mode_bits )
!
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$CONTROL_MODE ( PASTEBOARD_ID.rl.r,
!					      [NEW_MODE_BITS.rl.r],
!					      [OLD_MODE_BITS.wl.r] )
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	The id of the PASTEBOARD for which the
!				modes are being set or interrogated.
!
!       NEW_MODE_BITS.rl.r	[Optional].  If supplied, new mode 
!				settings to be employed.
!				A bit set to 1 forces that mode to be
!				employed.  A bit set to 0 inhibits that
!				mode of operation.
!				Bit SMG$K_BUF_ENABLED controls buffering.
!				This should normally be set to improve
!				performance.
!				Bit SMG$K_MINUPD controls minimal update and
!				should normally be set.
!				Bit SMG$K_CLEAR_SCREEN causes SMG to clear
!				the screen upon normal exit.
!				Bit SMG$K_NOTABS prevents SMG from relying
!				on physical tabs.
!				All remaining bits must be zero to allow
!				for expansion in the future.
!
!	OLD_MODE_BITS.wl.r	[Optional].  If supplied, will be filled
!				in with mode settings prior to this call.
!				A bit set to 1 indicates that the mode
!				was employed.  A bit set to 0 indicates
!				that the mode was inhibited.
!				Bit SMG$K_BUF_ENABLED controls buffering.
!				Bit SMG$K_MINUPD controls minimal update.
!				Bit SMG$K_CLEAR_SCREEN causes SMG to clear
!				the screen upon normal exit.
!				Bit SMG$K_NOTABS prevents use of physical tabs.
!				All remaining bits will be zero to allow
!				for expansion in the future.
!
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_INVARG	Invalid arguement.  Bits corresponding to
!			unsupported functions supplied in NEW_MODE_BITS
!	SMG$_INVPAS_ID	Invalid pasteboard id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--

    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	PBCB : REF BLOCK [,BYTE];	! Address of associated
					! pasteboard control block.

    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB) ; ! Get address of PBCB


!+
! If caller requested current settings, return them.
!-
    IF NOT NULLPARAMETER (OLD_MODE_BITS)
    THEN
	.OLD_MODE_BITS = .PBCB [PBCB_L_MODE_SETTINGS];

!+
! If caller provided new settings, process them.
!-
    IF NOT NULLPARAMETER (NEW_MODE_BITS)
    THEN
	BEGIN	! Caller provided new settings

	BIND	NEW_MODE = .NEW_MODE_BITS	: BITVECTOR[32];

	!+
	! First make sure that he didn't supply extraneous bits
	!-
	IF .(.NEW_MODE_BITS)<4,29> NEQ 0
	THEN
	    RETURN (SMG$_INVARG);	! Unsupported bits provided

	!+
	! If he's switching from buffered to non-buffered, flush out
	! current contents of buffers so we are caught up.
	!-
	IF .PBCB [PBCB_V_BUF_ENABLED]  AND 	! If currently enabled
	    NOT .NEW_MODE[SMG$K_BUF_ENABLED]	! and new disabled
	THEN
	    SMG$$FLUSH_BUFFER ( .PBCB );

	!+
	! If he's switching from no minimal update to minimal update,
	! then ensure that the screen buffer is up-to-date.
	!-
	IF NOT .PBCB [PBCB_V_MINUPD]  AND	! If currently disabled
	   .NEW_MODE[SMG$K_MINUPD]		! and new enabled
	THEN
	    BEGIN	! update screen buffer

	    BIND WCB = .PBCB [PBCB_A_WCB]	: BLOCK [,BYTE];

	    !+
	    ! Move the current text and attributes buffers
	    ! to the corresponding screen buffers.
	    !-

	    CH$MOVE(.WCB [WCB_L_BUFSIZE], .WCB [WCB_A_TEXT_BUF],
		    .WCB [WCB_A_SCR_TEXT_BUF]);

	    CH$MOVE(.WCB [WCB_L_BUFSIZE], .WCB [WCB_A_ATTR_BUF],
		    .WCB [WCB_A_SCR_ATTR_BUF]);

	    !+
	    ! Move the text line characteristics vector to the screen 
	    ! text line characteristics vector.
	    !-
	    CH$MOVE(.WCB [WCB_W_NO_ROWS] +1, .WCB [WCB_A_LINE_CHAR],
		    .WCB [WCB_A_SCR_LINE_CHAR]);

	    END;	! update screen buffer

	!+
	! Finally, reset modes based on callers wishes.
	!-
	PBCB [PBCB_L_MODE_SETTINGS] = ..NEW_MODE_BITS;

	END;	! Caller provided new settings

    RETURN (SS$_NORMAL);

    END;			! Routine SMG$CONTROL_MODE

%SBTTL 'SMG$INVALIDATE_DISPLAY - Mark display as being privately used'
GLOBAL ROUTINE SMG$INVALIDATE_DISPLAY ( DISPLAY_ID) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when ever a change has been completed
!	to a given virtual display and the user had previously
!	written into that display on his own, without using
!	SMG routines.
!
!	The virtual display must not be occluded.
!
!	Each pasteboard to which this display is pasted is isolated and
!	its window image must be redrawn.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$INVALIDATE_DISPLAY ( DISPLAY_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Display ID of virtual display.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

EXTERNAL ROUTINE

	SMG$$INVALIDATE_DISPLAY;

LOCAL

	STATUS;	! Status of subroutine calls

!+
! Check for right number of arguments.
!-

$SMG$VALIDATE_ARGCOUNT ( 1, 1);

!+
! Call the internal routine.
!-

RETURN	SMG$$INVALIDATE_DISPLAY(.DISPLAY_ID)

END;		! End of routine SMG$INVALIDATE_DISPLAY

%SBTTL 'SMG$GET_CHAR_AT_PHYSICAL_CURSOR - Get character at physical cursor'
GLOBAL ROUTINE SMG$GET_CHAR_AT_PHYSICAL_CURSOR (
                                               PASTEBOARD_ID,
                                               CHARACTER : REF VECTOR [,BYTE]
                                               ) =

!++
! FUNCTIONAL DESCRIPTION
!
! Returns the character that occupies the position on the screen corresponding
! to the current physical cursor position.
!
! Note:  If the SMG$ facility has not written to that location on the screen,
! then it doesn't know its contents.  A character encoded as X'FF' will be
! returned in that case.
!
! If character returned has a value less than X'20', then it is not an actual
! printable character, but an internal terminal-independent code of what should
! be displayed at that position, e.g. an element of the line-drawing character
! set.  Do not attempt to use this code for subsequent output operations.
!
!
! CALLING SEQUENCE
!
!	status.wlc.v = SMG$GET_CHAR_AT_PHYSICAL_CURSOR (
!				PASTEBOARD_ID.rl.r,
!				CHARACTER.wbu.r)
!
! FORMAL PARAMETERS
!
!	PASTEBOARD_ID.rl.r	Address of a longword containing the
!				pasteboard_id for which the information is
!				desired.
!
!	CHARACTER.wbu.r		Address of a byte to receive the result.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLCIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$NORMAL	Normal successful completion
!	SMG$_INVPAS_ID	Invalid pasteboard id
!	SMG$_WRONUMARG	Wrong number of arguments
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	PBCB : REF $PBCB_DECL,		! Address of pasteboard control block
	WCB  : REF $WCB_DECL,		! Address of window control block
	PTR  : REF VECTOR [,BYTE];	! Pointer to text buffer of what is
					! currently on the screen.

!+
! Check for right number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT (2, 2);

!+
! Get address of pasteboard control block and of window control block.
!-
    $SMG$GET_PBCB (.PASTEBOARD_ID, PBCB);
    WCB = .PBCB [PBCB_A_WCB];
    PTR = .WCB [WCB_A_SCR_TEXT_BUF];

!+
! Fetch character at position corresponding to current actual physical cursor
! position on the screen.
!-
    CHARACTER [0] = .PTR [
		       (.WCB [WCB_W_OLD_CUR_ROW] -1) * .WCB [WCB_W_NO_COLS] +
                       (.WCB [WCB_W_OLD_CUR_COL] -1) ];

    RETURN (SS$_NORMAL);
    END;	! Routine SMG$GET_CHAR_AT_PHYSICAL_CURSOR

%SBTTL 'SMG$REPAINT_SCREEN - Repaint current screen'
GLOBAL ROUTINE SMG$REPAINT_SCREEN (
				PASTEBOARD_ID
				  )=
!++
! FUNCTIONAL DESCRIPTION:
!
!       This procedure will repaint the current screen based on its
!       internal knowledge of what the screen should look like.
!       It is intended to be called when it is known or suspected that
!       some outside agent has disrupted the screen so that it no longer
!       matches the internal knowledge of what should be on the screen.
!	If pasteboard batching is in effect, the repaint occurs
!	from the screen image; otherwise it occurs from the text image.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$REPAINT_SCREEN ( PASTEBOARD_ID.rl.r )
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	Id of pasteboard associated with
!				physical screen to be repainted.
!
! IMPLICIT INPUTS:
!
!       Current internal representation of what should be on the screen.
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_INVPAS_ID	Invalid pasteboard control block
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	WCB	: REF BLOCK [,BYTE],	! Window control block
	PBCB	: REF BLOCK [,BYTE];	! Address of pasteboard control
					! block

    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB); ! Get address of pasteboard
					   ! control block.

    !+
    ! Get address of window control block.
    !-

    WCB = .PBCB [PBCB_A_WCB];

    !+
    ! Zero out the screen image, thereby forcing output to
    ! redraw the whole screen.
    !-

    ! **************** We have to add code here to make
    ! the repaint occur from the window buffer if batching is in effect.
    ! ****************************

    CH$FILL(0,.WCB [WCB_L_BUFSIZE],.WCB [WCB_A_SCR_TEXT_BUF]);

    !+
    ! Clear the line characteristics vector.
    !-

    CH$FILL(0,.WCB [WCB_W_NO_COLS]+1,.WCB [WCB_A_SCR_LINE_CHAR]);

!+
! Tell the output routines that we've changed the whole WCB buffer.
!-
    PBCB [PBCB_W_FIRST_CHANGED_ROW] = 1;
    PBCB [PBCB_W_LAST_CHANGED_ROW]  = .PBCB [PBCB_B_ROWS];
    PBCB [PBCB_W_FIRST_CHANGED_COL] = 1;
    PBCB [PBCB_W_LAST_CHANGED_COL]  = .PBCB [PBCB_W_WIDTH];

    RETURN (SMG$$MIN_UPD (.PBCB));
    END;		! End of procedure SMG$REPAINT_SCREEN
!<BLF/PAGE>

%SBTTL 'SMG$RING_BELL - Ring Bell'
GLOBAL ROUTINE SMG$RING_BELL ( 
				DISPLAY_ID,
				TIMES 
			     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine rings the bell, on each physical terminal to which
!	the given virtual display is pasted, the number of times
!	specified.  If TIMES omitted, 1 is used.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$RING_BELL (
!					DISPLAY_ID.rl.r,
!					[TIMES.rl.r] )
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	The display id of the virtual display.
!
!	TIMES.rl.r	Optional.  The number of times to ring the bell.
!			If not specified, the bell is sounded once.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	Statuses returned by SMG$$OUTPUT or
!	statuses or signal values returned by STR$DUPL_CHAR.
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    BUILTIN
	NULLPARAMETER ;

    BIND 
	BELL_CHAR = UPLIT (BYTE (BELL));

    LOCAL
	DCB : REF BLOCK [,BYTE],	! Address of display control
					! block

	PP  : REF BLOCK [,BYTE],	! Address of a pasting packet

	STATUS;				! Status to return to caller

    $SMG$VALIDATE_ARGCOUNT (1, 2);

    $SMG$GET_DCB (.DISPLAY_ID, DCB);	! Get addr of virtual display
					! control block.

    STATUS=SS$_NORMAL;

    IF NULLPARAMETER (TIMES)
    THEN
	BEGIN	! No arg supplied, output 1 bell
	!+
	! Chase the chain of pasteboards to which this virtual display
	! is pasted.  For each pasteboard located, output the bell.
	!-
	PP = .DCB [DCB_A_PP_NEXT];

	IF .PP EQL 0
	THEN
	    RETURN (SMG$_FATERRLIB);		! should never be 0

	WHILE .PP NEQ DCB [DCB_A_PP_NEXT]	! While any remain...
	DO
	    BEGIN
	    STATUS=SMG$$OUTPUT ( .PP [PP_A_PBCB_ADDR],
				  1,
				  BELL_CHAR);

	    PP = .PP [PP_A_NEXT_DCB];	! Step to next packet
	    END;
	END	! No arg supplied, output 1 bell

    ELSE

	BEGIN	! Multiple bells
	LOCAL
	    DESCR : BLOCK [8, BYTE] ;	! A local descriptor

	!+
	! Must build a string of TIMES bell characters.  Use dynamic
	! string.
	!-
	DESCR [DSC$W_LENGTH] = 0 ;
	DESCR [DSC$B_CLASS]  = DSC$K_CLASS_D ;
	DESCR [DSC$B_DTYPE]  = DSC$K_DTYPE_T ;
	DESCR [DSC$A_POINTER] = 0 ;

	LIB$ESTABLISH ( LIB$SIG_TO_RET ) ; ! Establish handler in case
					   ! STR$DUPL_CHAR signals out
					   ! from under us.

	IF NOT (STATUS = STR$DUPL_CHAR ( DESCR, .TIMES, BELL_CHAR))
	THEN
	    RETURN (.STATUS );

	!+
	! Chase the chain of pasteboards to which this virtual display
	! is pasted.  For each pasteboard located, output the bell(s).
	!-
	PP = .DCB [DCB_A_PP_NEXT];

	IF .PP EQL 0
	THEN
	    RETURN (SMG$_FATERRLIB);		! should never be 0
	
	WHILE .PP NEQ DCB [DCB_A_PP_NEXT]	! While any remain...
	DO
	    BEGIN
	    STATUS=SMG$$OUTPUT ( .PP [PP_A_PBCB_ADDR],
				  .DESCR [DSC$W_LENGTH],
				  .DESCR [DSC$A_POINTER]);

	    PP = .PP [PP_A_NEXT_DCB];	! Step to next packet
	    END;

	LIB$SFREE1_DD ( DESCR ) ;	! Return dynamic string
	END ;	! Multiple bells

    RETURN (.STATUS);
    END;				! End of routine SMG$RING_BELL
!<BLF/PAGE>

%SBTTL 'SMG$$BEGIN_PASTEBOARD_UPDATE_R1 - Begin batch of updates to pasteboard'
GLOBAL ROUTINE SMG$$BEGIN_PASTEBOARD_UPDATE_R1 (PBCB: REF $PBCB_DECL)
				: SMG$$BEGIN_PBD_UPDATE$LNK =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Inner routine to support BEGIN_PASTEBOARD_UPDATE action.
!	Disable outputing this pasteboard to the screen until the
!	matching call to SMG$$END_PASTEBOARD_UPDATE_R2 is encountered.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$BEGIN_PASTEBOARD_UPDATE_R1 ( PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r		Address of pasteboard control block
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion, batching has been
!			initiated
!	SMG$_BATWAS_ON	Success, but note that batching was already on
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

!+
! Increment count of number of SMG$$END_PASTEBOARD_UPDATE_R2 calls we need to
! see before we resume outputing from this pasteboard.
! Let the user know what the previous state of batching was by
! our status return (in case he's interested).
!-
    PBCB [PBCB_L_BATCH_LEVEL] = .PBCB [PBCB_L_BATCH_LEVEL] + 1;

    IF .PBCB [PBCB_L_BATCH_LEVEL] EQL 1
    THEN
	RETURN	SS$_NORMAL
    ELSE
	RETURN	SMG$_BATWAS_ON

    END;		! End of routine SMG$$BEGIN_PASTEBOARD_UPDATE_R1
!<BLF/PAGE>

%SBTTL 'SMG$$END_PASTEBOARD_UPDATE_R2 - End batch of updates to pasteboard'
GLOBAL ROUTINE SMG$$END_PASTEBOARD_UPDATE_R2 ( PBCB: REF $PBCB_DECL) 
			: SMG$$END_PBD_UPDATE$LNK =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Inner routine to support BEGIN_PASTEBOARD_UPDATE action.
!	Reduce the number of calls to SMG$$END_PASTEBOARD_UPDATE_R2 that will
!	be needed before we resume outputing from this pasteboard.  If
!	this call makes this count go to zero, flush the pasteboard to
!	the screen.
!	If the level is already 0, we return a success status
!	informing caller that the batching level was already 0,
!	but we otherwise allow this.  This gives a user a guaranteed
!	method of ending batching.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$END_PASTEBOARD_UPDATE_R2 ( PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r		Address of pasteboard control block
!
! IMPLICIT INPUTS:
!
!	PBCB [PBCB_L_BATCH_LEVEL]
!
! IMPLICIT OUTPUTS:
!
!	PBCB [PBCB_L_BATCH_LEVEL] gets decremented
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_BATSTIPRO	Success; but batching is still in progress.
!	SMG$_BATWASOFF	Success; but batching was already off
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS;				! Status to return

!+
! If current count is greater than 1, simply reduce it by one and
! return to caller.  If it is one, reduce it to zero and cause the
! current contents of this pasteboard to be flushed to the screen (if need
! be).
!-
    IF .PBCB [PBCB_L_BATCH_LEVEL] GTRU 1
    THEN
	BEGIN
	PBCB [PBCB_L_BATCH_LEVEL] = .PBCB [PBCB_L_BATCH_LEVEL] - 1;
	STATUS = SMG$_BATSTIPRO		! Ok, but batching is still in progress
	END
    ELSE
	BEGIN	! Being reduced to zero
	LOCAL BATCH_STATUS;
	BATCH_STATUS = SS$_NORMAL;
	IF .PBCB [PBCB_L_BATCH_LEVEL] EQL 0
	THEN
	    BATCH_STATUS = SMG$_BATWASOFF	! Ok, but batching was already off
	ELSE
	    PBCB [PBCB_L_BATCH_LEVEL] = 0;
	!+
	! Call SMG$$CHECK_FOR_OUTPUT_PBCB to cause the
	! contents of this pasteboard to be
	! flushed to the screen.
	! It may not actually get there if buffering is in effect.
	! If that fails, then return its status as our status.
	! If that succeeded then return our previously calculated status.
	!-
	STATUS = SMG$$CHECK_FOR_OUTPUT_PBCB (.PBCB);
	IF .STATUS THEN STATUS=.BATCH_STATUS
	END;	! Being reduced to zero

    RETURN	.STATUS
    END;		! End of routine SMG$$END_PASTEBOARD_UPDATE_R2
!<BLF/PAGE>

%SBTTL 'SMG$$CHECK_FOR_OUTPUT_DCB - Check to see if output needed'
GLOBAL ROUTINE SMG$$CHECK_FOR_OUTPUT_DCB (
					DCB : REF BLOCK [,BYTE],
					REQUEST_CODE,
					REQUEST_ARG
				     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when ever a change has been completed
!	to a given virtual display.  Changes consist of:
!		1. Altering the text in a virtual display
!		2. Altering the attributes of the text in a virtual
!		   display.
!		3. Altering the cursor position within a display.
!		4. A virtual display's buffering level going to zero.
!		5. A virtual display has just been pasted to a 
!		   pasteboard.
!	The criteria for outputing consist of:
!		1. Virtual display buffering level is zero
!		2. The virtual display is pasted to at least one
!		   pasteboard.
!
!	Each pasteboard to which this display is pasted is isolated and
!	its window image must be redrawn.
!	The new physical pasteboard cursor position gets set.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CHECK_FOR_OUTPUT_DCB ( 
!						DCB.rab.r 
!						[,REQEST_CODE.rl.v])
!
! FORMAL PARAMETERS:
!
!	DCB.rab.r	Address of virtual display control block for
!			affected display.
!
!	[REQUEST_CODE.rl.v] Optional.  If supplied, it is a code telling
!			the nature of the request that provoked this
!			call to SMG$$CHECK_FOR_OUTPUT_DCB.
!			Among other things, it tells us when it is
!			necessary to redraw borders.
!
!	[REQUEST_ARG.rl.v] Optional. If supplied, then it tells us the
!			unique line in the DCB that has changed.
!			If specified as 0, then the whole DCB has changed.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	WCB[WCB_W_CURR_CUR_ROW]		gets set to place corresponding
!					to logical cursor position in
!					this virtual display.
!
!	WCB[WCB_W_CURR_CUR_COL]		gets set to place corresponding
!					to logical cursor position in
!					this virtual display.
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    BUILTIN
	ACTUALCOUNT;

    LOCAL
	CURR_PP : REF BLOCK [,BYTE],	! Addr of pasting packet under
					! inspection

	STATUS;	! Status of subroutine calls

!+
! If current buffer level not equal to zero, this is not the time to
! flush this display to the screen.
!-
    IF .DCB [DCB_L_BATCH_LEVEL] NEQ 0
    THEN
	RETURN (SS$_NORMAL);

    CURR_PP = .DCB [DCB_A_PP_NEXT];	! Start of chain of pasting
					! packets to which this display
					! is pasted.
    IF .CURR_PP EQL 0
    THEN
	RETURN (SMG$_FATERRLIB);	! should never be 0

!+
! Deal with each pasteboard that this virtual display is pasted to...
!-
    WHILE .CURR_PP NEQ DCB [DCB_A_PP_NEXT]
    DO
	BEGIN	! Overall loop

	LOCAL
	    PBCB : REF BLOCK [,BYTE],	! Addr. of pasteboard control
	    WCB  : REF BLOCK [,BYTE];	! Addr. of window control block

	PBCB = .CURR_PP [PP_A_PBCB_ADDR]; ! Select pasteboard and WCB

	IF .PBCB [PBCB_L_BATCH_LEVEL] EQL 0
	THEN
	    BEGIN	! Force output
	    LOCAL
		OPT_FLAG;	! Flag

	    WCB  = .PBCB [PBCB_A_WCB]; ! whose window needs rebuilding.

	    !+
	    ! Set the cursor position in the pasteboard to correspond
	    ! to it's place on this virtual display.
	    !-
	    WCB [WCB_W_CURR_CUR_ROW] = .DCB [DCB_W_CURSOR_ROW]-1
				 + .CURR_PP [PP_W_ROW];

	    WCB [WCB_W_CURR_CUR_COL] = .DCB [DCB_W_CURSOR_COL]-1
				 + .CURR_PP [PP_W_COL];

	    !+
	    ! If REQUEST_CODE is present and it is a type that just
	    ! involves cursor motion, deal with it as a special case to
	    ! avoid remapping the virtual display since contents did
	    ! not change.
	    !-
	    OPT_FLAG = 0;
	    IF ACTUALCOUNT () GEQ 2	! REQUEST_CODE present
	    THEN
		BEGIN	! Try optimization
		IF .REQUEST_CODE EQL SMG$C_SET_CURSOR_ABS OR
		   .REQUEST_CODE EQL SMG$C_SET_CURSOR_REL
		THEN
		   OPT_FLAG = 1;
		END;	! Try optimization

 	    IF .OPT_FLAG
	    THEN
	        BEGIN	! Opt. possible
		!+
		! Force cursor to desired spot in optimal fashion
		!-
		SMG$$UPDATE_PHYSICAL_CURSOR ( .PBCB);
		END	! Opt. possible

	    ELSE

		BEGIN	! Remapping necessary
		!+
		! Check to see if we can get by with just redrawing the 
		! changed virtual display, or whether we need to redraw 
		! the changed one and all higher-pasted virtual 
		! displays.  We can do the former if this pasting has a
		! bit that says it is not occluded.
		!-
		IF NOT .CURR_PP [PP_V_OCCLUDED]
		THEN
		    BEGIN	! Redraw just this virtual display
		    IF NOT (STATUS = SMG$$MOVE_TEXT_TO_WINDOW_BUF (.CURR_PP))
		    THEN
			RETURN (.STATUS);

		    !+
		    ! If something actually got redrawn, tell the output
		    ! routines we've changed the whole virtual display.
		    ! If just one line has changed, however, then tell
		    ! the output routines which line changed.
		    !-
		    IF .CURR_PP [PP_W_ROWS_TO_MOVE] NEQ 0
		    THEN
			BEGIN
			PBCB [PBCB_W_FIRST_CHANGED_ROW] = 
				.CURR_PP [PP_W_FIRST_WCB_ROW];

			PBCB [PBCB_W_LAST_CHANGED_ROW]  = 
				.CURR_PP [PP_W_LAST_WCB_ROW];

			PBCB [PBCB_W_FIRST_CHANGED_COL] = 
				.CURR_PP [PP_W_FIRST_WCB_COL];

			PBCB [PBCB_W_LAST_CHANGED_COL]  = 
				.CURR_PP [PP_W_LAST_WCB_COL];
			END;

		    IF ACTUALCOUNT () GEQ 3 ! If REQUEST_ARG supplied
		    THEN
			IF .REQUEST_CODE EQL SMG$C_PUT_CHARS AND
			   .REQUEST_ARG  NEQ 0
			THEN
			    BEGIN	! Just one row changed
			    PBCB [PBCB_W_FIRST_CHANGED_ROW] = 
				.CURR_PP [PP_W_ROW]+.REQUEST_ARG-1;

			    PBCB [PBCB_W_LAST_CHANGED_ROW]  = 
				.CURR_PP [PP_W_ROW]+.REQUEST_ARG-1;

			    END;	! Just one row changed

		    !+
		    ! If REQUEST_CODE is present and it is of a type 
		    ! that could have added a border, we must redraw the
		    ! border at this time.
		    !-
		    IF ACTUALCOUNT () GEQ 2 ! If REQUEST_CODE supplied
		    THEN
			IF .REQUEST_CODE EQL SMG$C_LABEL_BORDER
			THEN
			    IF .DCB [DCB_V_BORDERED]
			    THEN
				IF NOT (STATUS = SMG$$DRAW_BORDER ( 
						.DCB, .CURR_PP, .WCB))
				THEN 
				    RETURN (.STATUS);

		    SMG$$MIN_UPD (.PBCB);

		    END		! Redraw just this virtual display

		ELSE

		    BEGIN	! Must redraw it and outer ones
		    !+
		    ! Go rebuild window buffers for this pasteboard 
		    ! starting with current pasting packet, and output.
		    !-
		    IF NOT (STATUS = SMG$$FILL_WINDOW_BUFFER ( .CURR_PP))
		    THEN
			RETURN (.STATUS);

		    END;	! Must redraw it and outer ones
		END;	! Remapping necessary
	    END;	! Force output

	CURR_PP = .CURR_PP [PP_A_NEXT_DCB];	! Walk the DCB side of
						! the chain from front
						! to back.
	END;	! Overall loop

    RETURN (SS$_NORMAL);
    END;		! End of routine SMG$$CHECK_FOR_OUTPUT_DCB
!<BLF/PAGE>

%SBTTL 'SMG$$CHECK_FOR_OUTPUT_PBCB - Check to see if output needed'
GLOBAL ROUTINE SMG$$CHECK_FOR_OUTPUT_PBCB (
					PBCB : REF BLOCK [,BYTE]
				     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when a change has been made to a 
!	particular pasteboard that requires the entire screen image to 
!	be recomposed, e.g. as a result of an UNPASTE operation.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CHECK_FOR_OUTPUT_PBCB ( PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r	Address of pasteboard control block for
!			affected display.
!
! IMPLICIT INPUTS:
!
!	PBCB [PBCB_L_BATCH_LEVEL]
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SMG$_BATWAS_ON	Ok, but batching was on so nothing happened
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	WCB : REF BLOCK [,BYTE],	! Address of window control
					! block
	STATUS;				! Status of subroutine calls

    WCB = .PBCB [PBCB_A_WCB];

!+
! Do nothing if batching is in effect.
!-

    IF .PBCB [PBCB_L_BATCH_LEVEL] NEQ 0
    THEN    RETURN SMG$_BATWAS_ON;

!+
! Clear text buffer to blanks and attribute buffer to zeroes before we
! start.  Clear alternate character set buffer to zeroes if it exists.
!-
    CH$FILL (%C' ', .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_TEXT_BUF]);

    CH$FILL (0,     .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_ATTR_BUF]);

    IF .WCB [WCB_A_CHAR_SET_BUF] NEQ 0
    THEN
	CH$FILL (0, .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_CHAR_SET_BUF]);

!+
! Clear text line characteristics vector to zero.
!-
    CH$FILL (0, .WCB [WCB_W_NO_ROWS] +1, .WCB [WCB_A_LINE_CHAR]);

!+
! Tell the output routines that we've changed the whole WCB buffer.
!-
    PBCB [PBCB_W_FIRST_CHANGED_ROW] = 1;
    PBCB [PBCB_W_LAST_CHANGED_ROW]  = .PBCB [PBCB_B_ROWS];
    PBCB [PBCB_W_FIRST_CHANGED_COL] = 1;
    PBCB [PBCB_W_LAST_CHANGED_COL]  = .PBCB [PBCB_W_WIDTH];

!+
! Go rebuild window buffers for this pasteboard and output.
! Pass SMG$$FILL_WINDOW_BUFFER the address of the first pasting packet
! if any exist, else just output now-blank screen.
!-
    IF .PBCB [PBCB_A_PP_NEXT] EQL PBCB [PBCB_A_PP_NEXT]
    THEN    
	BEGIN	! Nothing pasted -- output blanked buffer
	RETURN (SMG$$MIN_UPD (.PBCB));
	END	! Nothing pasted -- output blanked buffer

    ELSE    

	RETURN (SMG$$FILL_WINDOW_BUFFER ( 
			.PBCB [PBCB_A_PP_PREV] - PP_PBCB_QUEUE_OFFSET) );

    END;		! End of routine SMG$$CHECK_FOR_OUTPUT_PBCB
!<BLF/PAGE>

%SBTTL 'SMG$$DRAW_BORDER - Move border characters into buffer'
GLOBAL ROUTINE SMG$$DRAW_BORDER ( 
	DCB : REF BLOCK [,BYTE],	! Display control block address
	PP  : REF BLOCK [,BYTE],	! Pasting packet address
	WCB : REF BLOCK [,BYTE]		! Window control block address
				) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Draw the border characters into the text buffer of the WCB.
!	The cell in the text buffer has bits set to indicate which
!	elements of a border character will be needed in this cell
!	position.  When the first such bit is set in the text cell,
!	the corresponding cell in the attribute array is flag with
!	a bit which signals that the text array cell no longer contains
!	a printable character, but an encoding of the border character.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$DRAW_BORDER (	DCB.rab.r,
!						PP.rab.r,
!						WCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	DCB.rab.r		! Display control block address
!	PP.rab.r		! Pasting packet address
!	WCB.rab.r		! Window control block address
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

!+
! Macro $MARKIT checks a "text" character to see if it is already a 
! border element in which case it OR's in new border contribution.
! If it is not yet flagged as being a border element it stores the 
! border contribution and marks attribute byte to record this is a 
! border element.
!-
MACRO 
  $MARKIT ( OFFSET, ELEMENT ) =
    BEGIN
    IF .(PTRA [.OFFSET])<ATTR_V_BORD_ELEM, 1>
    THEN
	PTRT [.OFFSET] = .PTRT [.OFFSET] OR ELEMENT
    ELSE
	BEGIN
	PTRT [.OFFSET] = ELEMENT;
	PTRA [.OFFSET] = ATTR_M_BORD_ELEM ;
	END;
    END %;

!+
! Macro $CALC_LEFT_INDEX computes the byte offset into the WCB text and
! attribute buffers where a left border element needs to be placed for
! a double-wide line to make it come out in the correct column.
!-
MACRO
    $CALC_LEFT_INDEX =
    BEGIN
	SINDEX = (.WLN -1) * .WCB [WCB_W_NO_COLS] +
			 (.PP [PP_W_FIRST_WCB_COL] / 2) -1;
    END %;

!+
! Macro $CALC_RIGHT_INDEX computes the byte offset into the WCB text and
! attribute buffers where a right border element needs to be placed for
! a double-wide line to make it come out in the correct column.
!-
MACRO
    $CALC_RIGHT_INDEX =
    BEGIN
	SINDEX = (.WLN -1) * .WCB [WCB_W_NO_COLS] +
		((.PP [PP_W_FIRST_WCB_COL] + .PP [PP_W_MOVE_LENGTH] +1) / 2) -1;
    END %;

    LOCAL
	SPOS ,	
	! Position where the first (or only) border element will be 
	! written.  This is a displacement from the beginning of the 
	! window buffer.  Before using this position, we must always
	! check to see if it points into the confines of the buffer.  
	! This basically tells us if that portion of the border is 
	! visible considering how the virtual display is pasted to the 
	! pasteboard.

	LDES : REF BLOCK [,BYTE],	! Address of the dynamic string
					! descriptor in the DCB which
					! records the border label text
					! string.

	PTRT : REF VECTOR [,BYTE],	! pointer to top of WCB TEXT buf
	PTRA : REF VECTOR [,BYTE],	! pointer to top of WCB ATTR buf
	UPPER_ROW,	! Row number of top border
	LOWER_ROW,	! Row number of bottom border
	LEFT_COL,	! Col number of left border
	RIGHT_COL,	! Col number of right border
	WCB_LCV : REF VECTOR [,BYTE],	! Line control block
	PBCB : REF BLOCK [,BYTE];	! Addr. of pasteboard control
					! block


    PTRT = .WCB [WCB_A_TEXT_BUF];
    PTRA = .WCB [WCB_A_ATTR_BUF];
    PBCB = .PP [PP_A_PBCB_ADDR];
    WCB_LCV = .WCB [WCB_A_LINE_CHAR];

!+
! If no part of the virtual display projects to the visible part of the
! pasteboard, abandon attempt to draw border.  This is strictly speaking not
! the correct solution since it ignores the case where a virtual display is
! pasted such that it is not visible, but its border should be.  Trying to
! make this pathelogical case work will require some coordinated work on the
! part of SMG$$CALC_PASTE_TRANS.  (See corresponding note there.)
!-
    IF .PP [PP_W_ROWS_TO_MOVE] EQL 0  OR
       .PP [PP_W_MOVE_LENGTH]  EQL 0
    THEN
	RETURN (SS$_NORMAL);

!+
! Compute the row and column numbers where the borders fall.  Note these
! rows and columns may not map into buffer and need to be validated
! before use.
!-
    UPPER_ROW = .PP [PP_W_ROW] - 1;
    LOWER_ROW = MAX ( .PP [PP_W_ROW], 1) + .PP [PP_W_ROWS_TO_MOVE];
    LEFT_COL  = .PP [PP_W_COL] - 1;
    RIGHT_COL = MAX ( .PP [PP_W_COL], 1) + .PP [PP_W_MOVE_LENGTH];

!+
! If the line above where the virtual display is pasted exists in the
! window buffer, draw the the top border.
!-
    IF .UPPER_ROW GEQ 1
    THEN
	BEGIN	! Top border

	    !+
	    ! If WCB is special, blank it and force line to normal.
	    !-

	    IF (.WCB_LCV[.UPPER_ROW] NEQ 0) AND .PBCB[PBCB_V_WIDE]
	    THEN
		BEGIN	! Force line normal
		CH$FILL(%C' ',.WCB[WCB_W_NO_COLS],
			PTRT[ (.UPPER_ROW-1)*.WCB[WCB_W_NO_COLS] ]);
		CH$FILL(%C' ',.WCB[WCB_W_NO_COLS],
			PTRA[ (.UPPER_ROW-1)*.WCB[WCB_W_NO_COLS] ]);
		WCB_LCV[.UPPER_ROW]=0
		END;	! Force line normal

	SPOS = .PP [PP_W_TO_INDEX] - .WCB [WCB_W_NO_COLS] ;
	INCR I FROM 1 TO .PP [PP_W_MOVE_LENGTH]
	DO
	    BEGIN	! Top line loop
	    $MARKIT (SPOS, BORD_M_HORIZ );
	    (PTRT [.SPOS])<BORD_V_DOWN,1> = 0; ! Knock down "down" seg.
	    SPOS = .SPOS + 1;
	    END;	! Top line loop

	IF .UPPER_ROW LSS .PBCB [PBCB_W_FIRST_CHANGED_ROW]
	THEN
	    PBCB [PBCB_W_FIRST_CHANGED_ROW] = .UPPER_ROW;

	END;	! Top border

!+
! If the line below where the virtual display is pasted exists in the
! window buffer, draw the the bottom border.
!-
    IF .LOWER_ROW LEQ .WCB [WCB_W_NO_ROWS]
    THEN
	BEGIN	! Bottom border

	    !+
	    ! If WCB is special, blank it and force line to normal.
	    !-

	    IF (.WCB_LCV[.LOWER_ROW] NEQ 0) AND .PBCB[PBCB_V_WIDE]
	    THEN
		BEGIN	! Force line normal
		CH$FILL(%C' ',.WCB[WCB_W_NO_COLS],
			PTRT[ (.LOWER_ROW-1)*.WCB[WCB_W_NO_COLS] ]);
		CH$FILL(%C' ',.WCB[WCB_W_NO_COLS],
			PTRA[ (.LOWER_ROW-1)*.WCB[WCB_W_NO_COLS] ]);
		WCB_LCV[.LOWER_ROW]=0
		END;	! Force line normal

	SPOS = .PP [PP_W_TO_INDEX] + (.PP  [PP_W_ROWS_TO_MOVE] *
					   .WCB [WCB_W_NO_COLS] ) ;
	INCR I FROM 1 TO .PP [PP_W_MOVE_LENGTH]
	DO
	    BEGIN	! Bottom line loop
	    $MARKIT (SPOS, BORD_M_HORIZ );
	    (PTRT [.SPOS])<BORD_V_UP,1> = 0;   ! Knock down "up" seg.
	    SPOS = .SPOS + 1;
	    END;	! Bottom line loop

	IF .LOWER_ROW GTR .PBCB [PBCB_W_LAST_CHANGED_ROW]
	THEN
	    PBCB [PBCB_W_LAST_CHANGED_ROW] = .LOWER_ROW;

	END;	! Bottom border

!+
! If the column to the left of where the virtual display is pasted 
! exists in the window buffer, draw the left border.
!-
    IF .LEFT_COL GEQ 1
    THEN
	BEGIN	! Left border
	LOCAL
	    WLN,	! Line number in WCB buffers
	    LCV : REF VECTOR [,BYTE]; ! Addr of line characteristics
				      ! vector in WCB
	WLN = .PP [PP_W_FIRST_WCB_ROW];
	LCV = .WCB [WCB_A_LINE_CHAR];
	SPOS = .PP [PP_W_TO_INDEX] - 1;
	INCR I FROM 1 TO .PP [PP_W_ROWS_TO_MOVE]
	DO
	    BEGIN	! Left column loop
	    IF .LCV [.WLN] EQL 0 OR		! If normal or
	       (NOT .PBCB [PBCB_V_WIDE])	! DWDH not supported
	    THEN
		BEGIN	! Normal case
		$MARKIT (SPOS, BORD_M_VERT ) ;
		(PTRT [.SPOS])<BORD_V_RIGHT,1> = 0; ! Knock down "right" seg.
		END	! Normal case
	    ELSE
		BEGIN	! Double-wide or Double-wide/Double-high case
		LOCAL
		    SINDEX;	! Special index for DWDH 
		$CALC_LEFT_INDEX ;
		$MARKIT (SINDEX, BORD_M_VERT);
		(PTRT [.SINDEX])<BORD_V_RIGHT,1> = 0; ! Delete "right"
		END;	! Double-wide or Double-wide/Double-high case
	    SPOS = .SPOS + .WCB [WCB_W_NO_COLS] ;
	    WLN = .WLN + 1;
	    END;	! Left column loop

	IF .LEFT_COL LSS .PBCB [PBCB_W_FIRST_CHANGED_COL]
	THEN
	    PBCB [PBCB_W_FIRST_CHANGED_COL] = .LEFT_COL;

	END;	! Left border

!+
! If the column to the right of where the virtual display is pasted 
! exists in the window buffer, draw the right border.
!-
    IF .RIGHT_COL LEQ .WCB [WCB_W_NO_COLS]
    THEN
	BEGIN	! Right border
	LOCAL
	    WLN,	! Line number in WCB buffers
	    LCV : REF VECTOR [,BYTE]; ! Addr of line characteristics
				      ! vector in WCB
	WLN = .PP [PP_W_FIRST_WCB_ROW];
	LCV = .WCB [WCB_A_LINE_CHAR];
	SPOS = .PP [PP_W_TO_INDEX] + .PP [PP_W_MOVE_LENGTH];
	INCR I FROM 1 TO .PP [PP_W_ROWS_TO_MOVE]
	DO
	    BEGIN	! Right column loop
	    IF .LCV [.WLN] EQL 0 OR		! If normal or
	       (NOT .PBCB [PBCB_V_WIDE])	! DWDH not supported
	    THEN
		BEGIN	! Normal case
		$MARKIT (SPOS, BORD_M_VERT ) ;
		(PTRT [.SPOS])<BORD_V_LEFT,1> = 0; ! Knock down "left" seg.
		END	! Normal case
	    ELSE
		BEGIN	! Double-wide or Double-wide/Double-high case
		LOCAL
		    SINDEX;	! Special index for DWDH 
		$CALC_RIGHT_INDEX ;
		$MARKIT (SINDEX, BORD_M_VERT);
		(PTRT [.SINDEX])<BORD_V_LEFT,1> = 0; ! Delete "left"
		END;	! Double-wide or Double-wide/Double-high case
	    SPOS = .SPOS + .WCB [WCB_W_NO_COLS] ;
	    WLN = .WLN + 1;
	    END;	! Right column loop

	IF .RIGHT_COL GTR .PBCB [PBCB_W_LAST_CHANGED_COL]
	THEN
	    PBCB [PBCB_W_LAST_CHANGED_COL] = .RIGHT_COL;

	END;	! Right border

!+
! Handle upper left-hand corner if position exists in buffer.
!-
    IF .UPPER_ROW GEQ 1		AND	! Row exists
       .LEFT_COL  GEQ 1			! Col exists
    THEN
	BEGIN	! Upper left-hand corner
	SPOS = .PP [PP_W_TO_INDEX] - .WCB [WCB_W_NO_COLS] - 1;
	$MARKIT (SPOS, BORD_M_ULCORN ) ;
	END;	! Upper left-hand corner

!+
! Handle upper right-hand corner if position exists in buffer.
!-
    IF .UPPER_ROW GEQ 1		AND		! Row exists
       .RIGHT_COL LEQ .WCB [WCB_W_NO_COLS]	! Col exists
    THEN
	BEGIN	! Upper right-hand corner
	SPOS = .PP [PP_W_TO_INDEX] - .WCB [WCB_W_NO_COLS] +
		    .PP [PP_W_MOVE_LENGTH] ;
	$MARKIT (SPOS, BORD_M_URCORN ) ;
	END;	! Upper right-hand corner

!+
! Handle lower left-hand corner if position exists in buffer.
!-
    IF .LOWER_ROW LEQ .WCB [WCB_W_NO_ROWS]  AND	! Row exists
       .LEFT_COL  GEQ 1				! Col exists
    THEN
	BEGIN	! Lower left-hand corner
	SPOS = .PP [PP_W_TO_INDEX] + (.PP [PP_W_ROWS_TO_MOVE] *
					   .WCB [WCB_W_NO_COLS]) - 1;
	$MARKIT (SPOS, BORD_M_LLCORN ) ;
	END;	! Lower left-hand corner

!+
! Handle lower right-hand corner if position exists in buffer.
!-
    IF .LOWER_ROW LEQ .WCB [WCB_W_NO_ROWS]  AND	! Row exists
       .RIGHT_COL LEQ .WCB [WCB_W_NO_COLS]	! Col exists
    THEN
	BEGIN	! Lower right-hand corner
	SPOS = .PP [PP_W_TO_INDEX] + 
		    (.PP [PP_W_ROWS_TO_MOVE] * .WCB [WCB_W_NO_COLS]) +
		    .PP [PP_W_MOVE_LENGTH] ;
	$MARKIT (SPOS, BORD_M_LRCORN ) ;
	END;	! Lower right-hand corner

!+
! Check to see if this border is labeled and if so, move the label text
! into the approriate border area.
! All the fields in the PP accessed below have been previously computed
! at the time the virtual display was pasted to the pasteboard so
! that they need not be recomputed each time through here.  The lengths
! used in the various CH$MOVE's and CH$FILL's have been so computed
! that if no parts of the label fit, the lengths used are zero.
!-
    LDES = DCB [DCB_Q_LABEL_DESC];
    IF .LDES [DSC$W_LENGTH] NEQ 0		! If label exists...
    THEN
	BEGIN	! Overall border label processing
	CASE .DCB [DCB_B_LABEL_POS] FROM SMG$K_TOP TO SMG$K_RIGHT OF
	SET
	    [SMG$K_TOP]:
		BEGIN	! Label in top row
		!+
		! If row where label lands is not on the pasteboard, no
		! movement will be necessary.
		!-
		IF .UPPER_ROW GEQ 1	! If row above present...
		THEN
		    BEGIN	! Top present

		    CH$MOVE ( 
		       .PP [PP_W_LABEL_BYTES_TO_MOVE],	! Length
		       .LDES [DSC$A_POINTER] + .PP [PP_W_SRC_LABEL_OFF],  ! Source
		       PTRT [.PP [PP_W_DST_LABEL_OFF]]);  ! Dest

		    CH$FILL ( 
		       .DCB [DCB_B_LABEL_REND],	  	  ! Fill
		       .PP [PP_W_LABEL_BYTES_TO_MOVE],	  ! Number
		       PTRA [.PP [PP_W_DST_LABEL_OFF]]);  ! Dest

		    END;	! Top present
		END;	! Label in top row

	   [SMG$K_BOTTOM]:
		BEGIN	! Label in bottom row
		!+
		! If row where label lands is not on the pasteboard, no
		! movement will be necessary.
		!-
		IF .LOWER_ROW LEQ .WCB [WCB_W_NO_ROWS] ! If row below present...
		THEN
		    BEGIN	! Bottom present

		    CH$MOVE ( 
		       .PP [PP_W_LABEL_BYTES_TO_MOVE],	! Length
		       .LDES [DSC$A_POINTER] + .PP [PP_W_SRC_LABEL_OFF],  ! Source
		       PTRT [.PP [PP_W_DST_LABEL_OFF]]);  ! Dest

		    CH$FILL ( 
		       .DCB [DCB_B_LABEL_REND],	  	  ! Fill
		       .PP [PP_W_LABEL_BYTES_TO_MOVE],	  ! Number
		       PTRA [.PP [PP_W_DST_LABEL_OFF]]);  ! Dest

		    END;	! Bottom present
		END;	! Label in bottom row

	    [SMG$K_LEFT]:
		BEGIN	! Label in left column
		!+
		! If column where label lands is not on the pasteboard,
		! no movement will be necessary.
		!-
		IF .LEFT_COL GEQ 1	! If column to left present...
		THEN
		    BEGIN	! Left present
		    LOCAL
			WLN,			! Line # in WCB buffer
			LCV : REF VECTOR [,BYTE], ! Addr of line
						! characteristics vect.
						! in WCB
			I;	! Local index
		    WLN = (.PP [PP_W_DST_LABEL_OFF] / 
			   .WCB [WCB_W_NO_COLS]) + 1;
		    LCV = .WCB [WCB_A_LINE_CHAR];
		    SPOS = .PP [PP_W_DST_LABEL_OFF];
		    I = 0;
		    UNTIL .I EQL .PP [PP_W_LABEL_BYTES_TO_MOVE]
		    DO
			BEGIN	! Character by character movement
			IF .LCV [.WLN] EQL 0 OR		! If normal or
			   (NOT .PBCB [PBCB_V_WIDE])	! DWDH not supported
			THEN
			    BEGIN ! Normal case
			    PTRT [.SPOS] = .(.LDES [DSC$A_POINTER] + 
				       .PP [PP_W_SRC_LABEL_OFF] + .I);
			    PTRA [.SPOS] = .DCB [DCB_B_LABEL_REND];
			    END	  ! Normal case
			ELSE
			    BEGIN ! Special case
			    LOCAL
				SINDEX;
			    $CALC_LEFT_INDEX ;
			    PTRT [.SINDEX] = .(.LDES [DSC$A_POINTER] + 
				       .PP [PP_W_SRC_LABEL_OFF] + .I);
			    PTRA [.SINDEX] = .DCB [DCB_B_LABEL_REND];
			    END;  ! Special case

			SPOS = .SPOS + .WCB [WCB_W_NO_COLS];
			I = .I+1;
			WLN = .WLN + 1;
			END;	! Character by character movement
		    END;	! Left present
		END;	! Label in left column

	    [SMG$K_RIGHT]:
		BEGIN	! Label in right column
		!+
		! If column where label lands is not on the pasteboard,
		! no movement will be necessary.
		!-
		IF .RIGHT_COL LEQ .WCB [WCB_W_NO_COLS] ! If column to right present...
		THEN
		    BEGIN	! Right present
		    LOCAL
			WLN,			! Line # in WCB buffer
			LCV : REF VECTOR [,BYTE], ! Addr of line
						! characteristics vect.
						! in WCB
			I;	! Local index
		    I = 0;
		    WLN = (.PP [PP_W_DST_LABEL_OFF] / 
			   .WCB [WCB_W_NO_COLS]) + 1;
		    LCV = .WCB [WCB_A_LINE_CHAR];
		    SPOS = .PP [PP_W_DST_LABEL_OFF];
		    UNTIL .I EQL .PP [PP_W_LABEL_BYTES_TO_MOVE]
		    DO
			BEGIN	! Character by character movement
			IF .LCV [.WLN] EQL 0 OR		! If normal or
			   (NOT .PBCB [PBCB_V_WIDE])	! DWDH not supported
			THEN
			    BEGIN	! Normal case
			    PTRT [.SPOS] = .(.LDES [DSC$A_POINTER] + 
				       .PP [PP_W_SRC_LABEL_OFF] + .I);
			    PTRA [.SPOS] = .DCB [DCB_B_LABEL_REND];
			    END		! Normal case
			ELSE
			    BEGIN	! Special case
			    LOCAL
				SINDEX;
			    $CALC_RIGHT_INDEX ;
			    PTRT [.SINDEX] = .(.LDES [DSC$A_POINTER] + 
				       .PP [PP_W_SRC_LABEL_OFF] + .I);
			    PTRA [.SINDEX] = .DCB [DCB_B_LABEL_REND];
			    END;	! Special case
			SPOS = .SPOS + .WCB [WCB_W_NO_COLS];
			I = .I+1;
			WLN = .WLN + 1;
			END;	! Character by character movement
		    END;	! Right present
		END;	! Label in right column

	    [OUTRANGE]:
		RETURN (SMG$_FATERRLIB);
	TES;

	END;	! Overall border label processing
    RETURN (SS$_NORMAL);
    END;		! End of routine SMG$$DRAW_BORDER
!<BLF/PAGE>

%SBTTL 'SMG$$FILL_WINDOW_BUFFER - Fill window with virtual displays'
GLOBAL ROUTINE SMG$$FILL_WINDOW_BUFFER (
				 PP : REF BLOCK [,BYTE]
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure rebuilds the portions of the window buffer that
!	need to be changed because some virtual display has changed.
!	Rebuilding takes place from the given pasting packet down the
!	chain to the most-recently pasted pasting packet.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$FILL_WINDOW_BUFFER ( PP.rab.r)
!
! FORMAL PARAMETERS:
!
!
!	PP.rab.r		Address of pasting packet which 
!				determines the first display to be 
!				repainted.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS,				! Status of subr. calls
	PBCB : REF BLOCK [,BYTE],	! Address of pasteboard control
					! block

	WCB : REF BLOCK [,BYTE],	! Addr of current WCB

	CURR_PP : REF BLOCK [,BYTE];	! Addr of 2 longwords that form
					! queue header in PP currently
					! under inspection.

    PBCB = .PP   [PP_A_PBCB_ADDR];
    WCB  = .PBCB [PBCB_A_WCB];

!+
! Change packet address to address of queue header.
!-
    CURR_PP = .PP + PP_PBCB_QUEUE_OFFSET; ! Start with specified packet

!+
! Loop for all pasting packets starting with this one to the last-pasted
! one...
!-
    WHILE .CURR_PP NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! For all displays that need to be rewritten
	LOCAL
	    PP_BASE : REF BLOCK [,BYTE],	! Base address of the PP
	    DCB : REF BLOCK [,BYTE]; ! Current virtual display that 
				     ! needs to be repainted.

	PP_BASE = .CURR_PP - PP_PBCB_QUEUE_OFFSET;
				! Since the queue headers for this part
				! of the chain are not at relative 0 in
			        ! the pasting packet.
	DCB = .PP_BASE [PP_A_DCB_ADDR]; ! DCB addr of this pairing

	IF NOT (STATUS = SMG$$MOVE_TEXT_TO_WINDOW_BUF (.PP_BASE))
	THEN
	    RETURN (.STATUS);

	!+
	! If bordered, move the border characters into the text buffer
	! and set the bit in the attribute bytes to indicate a border
	! element.
	!-
	IF .DCB [DCB_V_BORDERED]
	THEN
	    IF NOT (STATUS = SMG$$DRAW_BORDER ( .DCB, .PP_BASE, .WCB)) 
	    THEN 
		RETURN (.STATUS);

	!+
	! Update changed area fields in the PBCB based on latest
	! contribution.
	!-
	IF .PP_BASE [PP_W_ROWS_TO_MOVE] NEQ 0
	THEN
	    BEGIN
	    IF .PP_BASE [PP_W_FIRST_WCB_ROW] LSS .PBCB [PBCB_W_FIRST_CHANGED_ROW]
	    THEN
		PBCB [PBCB_W_FIRST_CHANGED_ROW] = .PP_BASE [PP_W_FIRST_WCB_ROW];

	    IF .PP_BASE [PP_W_LAST_WCB_ROW] GTR .PBCB [PBCB_W_LAST_CHANGED_ROW]
	    THEN
		PBCB [PBCB_W_LAST_CHANGED_ROW] = .PP_BASE [PP_W_LAST_WCB_ROW];

	    IF .PP_BASE [PP_W_FIRST_WCB_COL] LSS .PBCB [PBCB_W_FIRST_CHANGED_COL]
	    THEN
		PBCB [PBCB_W_FIRST_CHANGED_COL] = .PP_BASE [PP_W_FIRST_WCB_COL];

	    IF .PP_BASE [PP_W_LAST_WCB_COL] GTR .PBCB [PBCB_W_LAST_CHANGED_COL]
	    THEN
		PBCB [PBCB_W_LAST_CHANGED_COL] = .PP_BASE [PP_W_LAST_WCB_COL];

	    END;

	!+
	! Walk this chain backwards, from the packet we	started with 
	! back to the head of the chain -- since the most recently 
	! pasted displays are at the head of the chain.
	!-
	CURR_PP = .PP_BASE [PP_A_PREV_PBCB]; 
	END;	! For all displays that need to be rewritten


    RETURN ( SMG$$MIN_UPD ( .PBCB ));	! Cause window buffer to be
					! output

    END;		! End of routine SMG$$FILL_WINDOW_BUFFER
!<BLF/PAGE>

%SBTTL 'SMG$$MOVE_TEXT_TO_WINDOW_BUF - Move text from display buf. to window buf.'
GLOBAL ROUTINE SMG$$MOVE_TEXT_TO_WINDOW_BUF (
				 PP : REF $PP_DECL
					    ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine moves text from the buffer located at 
!	.DCB [DCB_A_TEXT_BUF] into the window text buffer.  
!	Array of bytes at .DCB [ DCB_A_ATTR_BUF ] describe the 
!	rendition this text must assume and is moved into the
!	associated window attribute buffer.
!	Similarly, if the alternate character set buffer at
!	.DCB [DCB_A_CHAR_SET_BUF] exists, it must be mapped into the
!	window alternate character set buffer.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$MOVE_TEXT_TO_WINDOW_BUF ( PP.rab.r)
!
! FORMAL PARAMETERS:
!
!	PP.rab.r		Address of pasting packet.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	SKPC;

    LOCAL
	DCB  : REF BLOCK [,BYTE],	! Addr of virtual display
					! control block.
	PBCB : REF BLOCK [,BYTE],	! Addr of pasteboard control
					! block
	WCB  : REF BLOCK [,BYTE],	! Addr of window control block
	IN_LINE_CHAR  : REF VECTOR [,BYTE],	! Addr. of line char.
						! vector off DCB
	OUT_LINE_CHAR : REF VECTOR [,BYTE],	! Addr. of line char.
						! vector off WCB

	WCB_COLS,	! Extracted .WCB [WCB_W_NO_COLS]
	DCB_COLS,	! Extracted .DCB [DCB_W_NO_COLS]
	FROM_INDEX,	! Pointer into DCB buffers
	TO_INDEX,	! Pointer into WCB buffers for normal mapping
	SPEC_TO_INDEX,	! Pointer into WCB buffers for special mapping
	RE_BORDER : INITIAL (0);	! Flag to indicate that the
					! border elements need to be
					! remapped because some line
					! changed from normal to DWDH or
					! vice versa.

MACRO
    $MAP_LINE_NORMAL =
	CH$MOVE ( .PP [PP_W_MOVE_LENGTH],		! Length
		  .DCB [DCB_A_TEXT_BUF] + .FROM_INDEX,	! Source
		  .WCB [WCB_A_TEXT_BUF] + .TO_INDEX);	! Destination
    %,

    $MAP_LINE_SPECIAL =
	CH$MOVE ( (.PP [PP_W_MOVE_LENGTH]-1)/2,		  ! Length
		  .DCB [DCB_A_TEXT_BUF] + .FROM_INDEX,	  ! Source
		  .WCB [WCB_A_TEXT_BUF] + .SPEC_TO_INDEX); ! Destination
    %,

    $MAP_ATTR_NORMAL =
	CH$MOVE ( .PP [PP_W_MOVE_LENGTH],		! Length
		  .DCB [DCB_A_ATTR_BUF] + .FROM_INDEX,	! Source
		  .WCB [WCB_A_ATTR_BUF] + .TO_INDEX);	! Destination
    %,

    $MAP_ATTR_SPECIAL =
	CH$MOVE ( (.PP [PP_W_MOVE_LENGTH]-1)/2,		  ! Length
		  .DCB [DCB_A_ATTR_BUF] + .FROM_INDEX,	  ! Source
		  .WCB [WCB_A_ATTR_BUF] + .SPEC_TO_INDEX); ! Destination
    %,

    $MAP_ALT_CHAR_NORMAL =
	IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	THEN
	CH$MOVE ( .PP [PP_W_MOVE_LENGTH],		   ! Length
		  .DCB [DCB_A_CHAR_SET_BUF] + .FROM_INDEX, ! Source
		  .WCB [WCB_A_CHAR_SET_BUF] + .TO_INDEX);  ! Dest.
    %,

    $MAP_ALT_CHAR_SPECIAL =
	IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	THEN
	CH$MOVE ( (.PP [PP_W_MOVE_LENGTH]-1)/2,		        ! Length
		  .DCB [DCB_A_CHAR_SET_BUF] + .FROM_INDEX,      ! Source
		  .WCB [WCB_A_CHAR_SET_BUF] + .SPEC_TO_INDEX);  ! Dest.
    %,

    $CLEAR_TEXT_LINE =
	CH$FILL ( %C' ', 				! Fill char
		  .WCB [WCB_W_NO_COLS],			! # of bytes
		  .WCB [WCB_A_TEXT_BUF] + .WLP);	! Destination
    %,

    $CLEAR_ATTR_LINE =
	CH$FILL ( 0, 					! Fill char
		  .WCB [WCB_W_NO_COLS],			! # of bytes
		  .WCB [WCB_A_ATTR_BUF] + .WLP);	! Destination
    %,

    $MAP_ALL_NORMAL =
	BEGIN
	$MAP_LINE_NORMAL;
	$MAP_ATTR_NORMAL;
	$MAP_ALT_CHAR_NORMAL;
	END;
    %,

    $CLEAR_ALT_CHAR_LINE =
	IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	THEN
	CH$FILL ( 0,
		  .WCB [WCB_W_NO_COLS],
		  .WCB [WCB_A_CHAR_SET_BUF] + .WLP);
    %,

    $MAP_ALL_SPECIAL =
	BEGIN
	$MAP_LINE_SPECIAL;
	$MAP_ATTR_SPECIAL;
	$MAP_ALT_CHAR_SPECIAL;
	END;
    %,

    $CLEAR_ALL =
	BEGIN
	$CLEAR_TEXT_LINE;
	$CLEAR_ATTR_LINE;
	$CLEAR_ALT_CHAR_LINE;
	RE_BORDER = 1; ! Set flag to rebuild border
	END;
    %;

    DCB  = .PP [PP_A_DCB_ADDR];
    PBCB = .PP [PP_A_PBCB_ADDR];
    WCB  = .PBCB [PBCB_A_WCB];
    IN_LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    OUT_LINE_CHAR= .WCB [WCB_A_LINE_CHAR];
    WCB_COLS = .WCB [WCB_W_NO_COLS];
    DCB_COLS = .DCB [DCB_W_NO_COLS];

!+
! Before diverging on two copying paths, check to see if we are going
! to get involved with alternate character set buffers.  If one exists
! in the DCB but does not yet exist in the WCB, we have to allocate
! one for the WCB and initialize it.
!-
    IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0	AND
       .WCB [WCB_A_CHAR_SET_BUF] EQL 0
    THEN
	BEGIN	! Alloc. and init. window alternate char. set buffer
	LOCAL
	    STATUS;	! Status of LIB$GET_VM call

	IF NOT (STATUS = LIB$GET_VM ( WCB [WCB_L_BUFSIZE], 
				      WCB [WCB_A_CHAR_SET_BUF]))
	THEN
	    RETURN (.STATUS);

	CH$FILL ( 0, .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_CHAR_SET_BUF]);
	END;	! Alloc. and init. window alternate char. set buffer

!+
! At this point we need to decide whether we are dealing with either
! a virtual display or a window control block that includes either
! Double-Wide (DW) and/or Double-Wide/Double-High (DWDH) lines.
! We can tell whether either is non-standard by looking at the zeroth
! byte of its line characteristics vector.
! If we are dealing with either non-standard, we need to deal with them
! on a line by line basis.
! For each line to be mapped we implement the logic summarized in the
! following table:
!
!    DCB Line		WCB Line	Mapping 
!    Char. Vect		Char. Vector	Action
!    ----------		------------	------
!
!    Not DW or DWDH	Not DW or DWDH	Map normally
!    (i.e., normal)	(i.e., Normal)
!
!
!    Not DW or DWDH	DW or DWDH	If DW supported
!    (i.e., normal)			then
!					    Blank entire WCB text line
!					    map normally
!					else
!					    map normally
!
!
!    DW or DWDH		Not DW or DWDH	If DW supported
!			(i.e., normal)	then
!					    Blank entire WCB text line
!					    use special mapping
!					else
!					    map normally
!
!
!    DW or DWDH		DW or DWDH	If DW supported
!					then
!					    Use special mapping
!					else
!					    Map normally
!
!
!-
    FROM_INDEX = .PP [PP_W_FROM_INDEX];
    TO_INDEX   = .PP [PP_W_TO_INDEX];
    IF .IN_LINE_CHAR  [0] EQL 0 AND	! DCB normal
       .OUT_LINE_CHAR [0] EQL 0		! WCB normal
    THEN
	BEGIN	! Both are normal -- no special action needed
	!+
	! Check to see if we can do it with a single CH$MOVE or whether 
	! we must do it a row at a time.
	!-
	IF .PP [PP_V_CONTIG]
	THEN
	    BEGIN	! Can be done in single move

	    ! Move text
	    CH$MOVE ( .PP [PP_L_MOVE_SIZE],	       ! length
		  .DCB [DCB_A_TEXT_BUF] + .FROM_INDEX, ! source
		  .WCB [WCB_A_TEXT_BUF] + .TO_INDEX);  ! dest.

	    ! Move attributes
	    CH$MOVE ( .PP [PP_L_MOVE_SIZE],	        ! length
		  .DCB [DCB_A_ATTR_BUF] + .FROM_INDEX,  ! source
		  .WCB [WCB_A_ATTR_BUF] + .TO_INDEX);   ! dest.

	    ! Move alternate character set buffer pieces, if necessary
	    IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	    THEN
		BEGIN	! Map alternate character set
		CH$MOVE ( .PP [PP_L_MOVE_SIZE],		       ! Length
		      .DCB [DCB_A_CHAR_SET_BUF] + .FROM_INDEX, ! Source
		      .WCB [WCB_A_CHAR_SET_BUF] + .TO_INDEX);  ! Dest.
		END;	! Map alternate character set
	    END		! Can be done in single move

	ELSE

	    BEGIN	! Must be done row at a time

	    INCR R FROM 1 TO .PP [PP_W_ROWS_TO_MOVE]
	    DO
		BEGIN	! For all rows in this display
		$MAP_LINE_NORMAL;
		$MAP_ATTR_NORMAL;

		FROM_INDEX = .FROM_INDEX + .DCB_COLS;
		TO_INDEX   = .TO_INDEX   + .WCB_COLS;
		END;	! For all rows in this display

	    !+
	    ! Move alternate character set buffer pieces, if necessary
	    !
	    IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	    THEN
		BEGIN	! Map alternate character set buffer
		FROM_INDEX = .PP [PP_W_FROM_INDEX];
		TO_INDEX   = .PP [PP_W_TO_INDEX];

	        INCR R FROM 1 TO .PP [PP_W_ROWS_TO_MOVE]
		DO
		    BEGIN
		    $MAP_ALT_CHAR_NORMAL;

		    FROM_INDEX = .FROM_INDEX + .DCB_COLS;
		    TO_INDEX   = .TO_INDEX   + .WCB_COLS;
		    END;

		END;	! Map alternate character set buffer

	    END;	! Must be done row at a time
	END	! Both are normal -- no special action needed

    ELSE
	BEGIN	! One or the other contains special characteristics
	LOCAL
	    DLN,	! Virtual display line number
	    WLN,	! WCB line number
	    WLP;	! Byte offset corresponding to WLN

	!+
	! Must deal with this mapping on a row by row basis and on
	! each row inspect the line characteristics vector entry of
	! both the DCB line characteristics vector and the WCB line
	! characteristics vector in order to determine how to map this
	! particular line.
	!
	! Initialize the special index we will be using.
	!-
	SPEC_TO_INDEX = (.PP [PP_W_FIRST_WCB_ROW] -1) * 
			 .WCB [WCB_W_NO_COLS] +
			((.PP [PP_W_FIRST_WCB_COL] +2) / 2) -1;

	DLN = (.FROM_INDEX / .DCB_COLS) +1;
	WLN = .PP [PP_W_FIRST_WCB_ROW];
	WLP = (.WLN - 1) * .WCB_COLS;

	INCR R FROM 1 TO .PP [PP_W_ROWS_TO_MOVE]
	DO
	    BEGIN	! For each row
	    IF .IN_LINE_CHAR  [.DLN] EQL 0 AND	! DCB normal
	       .OUT_LINE_CHAR [.WLN] EQL 0	! WCB normal
	    THEN
		BEGIN	! Normal line
		$MAP_ALL_NORMAL;
		END	! Normal line
	    ELSE
		BEGIN	! Special line
		IF .IN_LINE_CHAR  [.DLN] EQL 0 AND	! DCB normal
		   .OUT_LINE_CHAR [.WLN] NEQ 0		! WCB special
		THEN
		    BEGIN	! WCB has special, DCB normal
		    IF .PBCB [PBCB_V_WIDE]	! If DW supported
		    THEN
			BEGIN ! Special mapping
			$CLEAR_ALL;
			$MAP_ALL_NORMAL ;
		    	END   ! Special mapping
		    ELSE
			BEGIN ! Normal mapping
			$MAP_ALL_NORMAL;
			END;  ! Normal mapping
		    END		! WCB has special, DCB normal
		ELSE
		    BEGIN
		    IF .IN_LINE_CHAR  [.DLN] NEQ 0 AND	! DCB special
		       .OUT_LINE_CHAR [.WLN] EQL 0	! WCB normal
		    THEN
			BEGIN	! DCB special, WCB normal
			IF .PBCB [PBCB_V_WIDE]	! If DW supported
			THEN
			    BEGIN	! Map special
			    $CLEAR_ALL;
			    $MAP_ALL_SPECIAL;
			    END		! Map special
			ELSE
			    BEGIN	! Map normal
			    $MAP_ALL_NORMAL;
			    END;	! Map normal
			END	! DCB special, WCB normal
		    ELSE
			BEGIN	! Both have special
			IF .PBCB [PBCB_V_WIDE]	! If DW supported
			THEN
			    BEGIN	! Map special
			    $MAP_ALL_SPECIAL;
			    END		! Map special
			ELSE
			    BEGIN	! Map normal
			    $MAP_ALL_NORMAL;
			    END;	! Map normal
			END;	! Both have special
		    END;
		END;	! Special line
	    !+
	    ! Advance indices for next row
	    !-
	    FROM_INDEX    = .FROM_INDEX    + .DCB_COLS;
	    TO_INDEX      = .TO_INDEX      + .WCB_COLS;
	    SPEC_TO_INDEX = .SPEC_TO_INDEX + .WCB_COLS;
	    DLN = .DLN + 1;
	    WLN = .WLN + 1;
	    WLP = .WLP + .WCB_COLS;
	    END;	! For each row

	END;	! One or the other contains special characteristics

!+
! If this device supports DW or DWDH then we must update WCB's line 
! characteristics vector based on the rows we just modified.
! All further actions are necessary only if DW or DWDH is supported by
! this device.
!-
    IF .PBCB [PBCB_V_WIDE]
    THEN
	BEGIN	! Special supported
	IF .PP [PP_W_ROWS_TO_MOVE] NEQ 0	! Something got mapped
	THEN
	    BEGIN
	    IF .PP [PP_W_ROW] GTR 0
	    THEN
		! Start movement from 1st display row
		CH$MOVE ( .PP [PP_W_ROWS_TO_MOVE],
			  IN_LINE_CHAR [1],
			  OUT_LINE_CHAR [ .PP [PP_W_ROW]])
	    ELSE
		! Start movement from nth display row
		CH$MOVE ( .PP [PP_W_ROWS_TO_MOVE],
			  IN_LINE_CHAR [.DCB [DCB_W_NO_ROWS] - 
				    .PP [PP_W_ROWS_TO_MOVE] +1],
			  OUT_LINE_CHAR [1]);

	    END;

	!+
	! If we are dealing with a bordered display and we have 
	! made the transition from a normal line to a DHDW line, or 
	! vice versa, it will be necessary to remap the border elements.
	!-
	IF .DCB [DCB_V_BORDERED]  AND
	   .RE_BORDER EQL 1
	THEN
	    BEGIN
	    LOCAL
		STATUS ; ! Status of subroutine call
	    IF NOT (STATUS = SMG$$DRAW_BORDER ( .DCB, .PP, .WCB))
	    THEN
		RETURN (.STATUS);
	    END;

	!+
	! Check through current WCB line characteristics vector.  If 
	! any of the elements is non-zero, set OUT_LINE_CHAR [0] to the 
	! 1st encountered non-zero value.
	!-
	IF .PP [PP_W_ROWS_TO_MOVE] GTR 0
	THEN
	    BEGIN	! Some mapping took place
	    LOCAL
		BYTES_REMAINING,		! Output from SKPC
		FOUND_BYTE : REF VECTOR [,BYTE]; ! Output from SKPC

	    OUT_LINE_CHAR [0] = 0;	! Assume none will be found
	    SKPC (%REF(0), WCB [WCB_W_NO_ROWS], OUT_LINE_CHAR [0];
		  BYTES_REMAINING, FOUND_BYTE);

	    IF .BYTES_REMAINING NEQ 0	! If non-zero found
	    THEN
		OUT_LINE_CHAR [0] = .FOUND_BYTE [0];
	    END;	! Some mapping took place
	END;	! Special supported


    RETURN (SS$_NORMAL);
    END;		! End of routine SMG$$MOVE_TEXT_TO_WINDOW_BUF
!<BLF/PAGE>

%SBTTL 'SMGOCCLUDE - Check for occlusion'
GLOBAL ROUTINE SMG$$OCCLUDE (	LOWER : REF VECTOR [,WORD,SIGNED],
				UPPER : REF VECTOR [,WORD,SIGNED],
				REWRITE : REF VECTOR [,WORD,SIGNED]
			   ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine inspects the relative positioning of two areas --
!	a LOWER area and an UPPER area.  It determines whether the
!	UPPER area occludes any portion of the LOWER area.  If occlusion
!	is found, a rectangular area which is the occluded part is
!	isolated and its coordinates are returned as the area which
!	must be rewritten.
!
! CALLING SEQUENCE:
!
!	CODE.wl.v = SMG$$OCCLUDE (
!				  LOWER.rw.r,
!				  UPPER.rw.r,
!				  REWRITE.waw.r
!				 )
!
! FORMAL PARAMETERS:
!
!	LOWER.raw.r	Descripion of a rectangular area represent
!			a "lower" area.!
!	UPPER.raw.r	Description of a rectangular area representing
!			an "upper" area.
!
!	REWRITE.waw.r	Description of a rectangular area which
!			represents the area of the lower which is
!			occluded by the upper ( if any).
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LITERAL
	ROW_START = 0,
	NUM_ROW   = 1,
	COL_START = 2,
	NUM_COL   = 3;

    LOCAL
	ANS,
	STATUS,
	LOWER_BOTTOM_ROW: SIGNED,
	LOWER_RIGHT_COL: SIGNED,
	UPPER_BOTTOM_ROW: SIGNED,
	UPPER_RIGHT_COL: SIGNED;

MACRO
	LOWER_ROW_START		= LOWER [ROW_START]%,
	LOWER_NO_ROW		= LOWER [NUM_ROW]%,
	LOWER_COL_START		= LOWER [COL_START]%,
	LOWER_NO_COL		= LOWER [NUM_COL]%,

	UPPER_ROW_START		= UPPER [ROW_START]%,
	UPPER_NO_ROW		= UPPER [NUM_ROW]%,
	UPPER_COL_START		= UPPER [COL_START]%,
	UPPER_NO_COL		= UPPER [NUM_COL]%,

	REWRITE_ROW_START	= REWRITE [ROW_START]%,
	REWRITE_NO_ROW		= REWRITE [NUM_ROW]%,
	REWRITE_COL_START	= REWRITE [COL_START]%,
	REWRITE_NO_COL		= REWRITE [NUM_COL]%;

!+
! Calculate the other bounds of the specified rectangles.
!-
    LOWER_BOTTOM_ROW = .LOWER_ROW_START + .LOWER_NO_ROW - 1;
    LOWER_RIGHT_COL =  .LOWER_COL_START + .LOWER_NO_COL - 1;
    UPPER_BOTTOM_ROW = .UPPER_ROW_START + .UPPER_NO_ROW - 1;
    UPPER_RIGHT_COL  = .UPPER_COL_START + .UPPER_NO_COL - 1;

!+
! Assume no occlusion occurs until it proves otherwise.
!-
    STATUS = 0;

!+
! Check for relative position of upper left-hand corner of UPPER
! rectangle with respect to LOWER rectangle.
!-
    ANS = SMG$$POINT_IN_RECT_R3 (UPPER_COL_START,	! X1
			         UPPER_ROW_START,	! Y1
			         .LOWER);

    CASE .ANS FROM 0 TO 10 OF
    SET
	[0]:BEGIN
	    REWRITE_ROW_START = .UPPER_ROW_START;
	    REWRITE_COL_START = .UPPER_COL_START;
	    !+
	    ! Check relative position of lower right-hand corner of
	    ! UPPER rectangle with respect to LOWER rectangle.
	    !-
	    ANS = SMG$$POINT_IN_RECT_R3 (UPPER_RIGHT_COL,	! X1
				         UPPER_BOTTOM_ROW,	! Y1
				         .LOWER);

	    CASE .ANS FROM 0 TO 6 OF
	    SET
		[0]:BEGIN
		    REWRITE_NO_ROW = .UPPER_NO_ROW;
		    REWRITE_NO_COL = .UPPER_NO_COL;
		    END;

		[2]:BEGIN
		    REWRITE_NO_ROW = .UPPER_NO_ROW;
		    REWRITE_NO_COL = .LOWER_RIGHT_COL -.UPPER_COL_START+1;
		    END;

		[4]:BEGIN
		    REWRITE_NO_ROW = .LOWER_BOTTOM_ROW -.UPPER_ROW_START+1;
		    REWRITE_NO_COL = .UPPER_NO_COL;
		    END;

		[6]:BEGIN
		    REWRITE_NO_ROW = .LOWER_BOTTOM_ROW -.UPPER_ROW_START+1;
		    REWRITE_NO_COL = .LOWER_RIGHT_COL - .UPPER_COL_START+1;
		    END;
		[1,3,5]: RETURN (SMG$_FATERRLIB);

	    TES;
	    END;

	[1]:BEGIN
	    REWRITE_ROW_START = .UPPER_ROW_START;
	    REWRITE_COL_START = .LOWER_COL_START;
	    !+
	    ! Check relative position of lower right-hand corner of
	    ! UPPER rectangle with respect to lower rectangle.
	    !-
	    ANS = SMG$$POINT_IN_RECT_R3 (UPPER_RIGHT_COL,	! X1
				         UPPER_BOTTOM_ROW,	! Y1
				         .LOWER);

	    CASE .ANS FROM 0 TO 6 OF
	    SET
		[0]:BEGIN
		    REWRITE_NO_ROW = .UPPER_NO_ROW;
		    REWRITE_NO_COL = .UPPER_RIGHT_COL - .LOWER_COL_START +1;
		    END;

		[1]:	RETURN (.STATUS);

		[2]:BEGIN
		    REWRITE_NO_ROW = .UPPER_NO_ROW;
		    REWRITE_NO_COL = .LOWER_NO_COL;
		    END;

		[4]:BEGIN
		    REWRITE_NO_ROW = .LOWER_BOTTOM_ROW -.UPPER_ROW_START+1;
		    REWRITE_NO_COL = .UPPER_RIGHT_COL -.LOWER_COL_START+1;
		    END;

		[5]:	RETURN (.STATUS);

		[6]:BEGIN
		    REWRITE_NO_ROW = .LOWER_BOTTOM_ROW -.UPPER_ROW_START+1;
		    REWRITE_NO_COL = .LOWER_NO_COL;
		    END;
		[3]: RETURN (SMG$_FATERRLIB);

	    TES;
	    END;

	[2]:    RETURN (.STATUS);

	[4]:	RETURN (.STATUS);

	[5]:	RETURN (.STATUS);

	[6]:	RETURN (.STATUS);

	[8]:BEGIN
	    REWRITE_ROW_START = .LOWER_ROW_START;
	    REWRITE_COL_START = .UPPER_COL_START;
	    !+
	    ! Check relative position of lower right-hand corner of
	    ! UPPER rectangle with respect to LOWER rectangle.
	    !-
	    ANS = SMG$$POINT_IN_RECT_R3 (UPPER_RIGHT_COL,	! X1
				         UPPER_BOTTOM_ROW,	! Y1
				         .LOWER);

	    CASE .ANS FROM 0 TO 10 OF
	    SET
		[0]:BEGIN
		    REWRITE_NO_ROW = .UPPER_BOTTOM_ROW -.LOWER_ROW_START+1;
		    REWRITE_NO_COL = .UPPER_NO_COL;
		    END;

		[2]:BEGIN
		    REWRITE_NO_ROW = .UPPER_BOTTOM_ROW -.LOWER_ROW_START+1;
		    REWRITE_NO_COL = .LOWER_RIGHT_COL - .UPPER_COL_START+1;
		    END;

		[4]:BEGIN
		    REWRITE_NO_ROW = .LOWER_NO_ROW;
		    REWRITE_NO_COL = .UPPER_NO_COL;
		    END;

		[6]:BEGIN
		    REWRITE_NO_ROW = .LOWER_NO_ROW;
		    REWRITE_NO_COL = .LOWER_RIGHT_COL -.UPPER_COL_START+1;
		    END;
		[8]:    RETURN (.STATUS);

		[10]:   RETURN (.STATUS);

		[1,3,5,7,9]: RETURN (SMG$_FATERRLIB);

	    TES;
	    END;

	[9]:BEGIN
	    REWRITE_ROW_START = .LOWER_ROW_START;
	    REWRITE_COL_START = .LOWER_COL_START;
	    !+
	    ! Check relative position of lower right-hand corner of
	    ! UPPER rectangle with respect to LOWER rectangle.
	    !-
	    ANS = SMG$$POINT_IN_RECT_R3 (UPPER_RIGHT_COL,	! X1
				         UPPER_BOTTOM_ROW,	! Y1
				         .LOWER);

	    CASE .ANS FROM 0 TO 10 OF
	    SET
		[0]:BEGIN
		    REWRITE_NO_ROW = .UPPER_BOTTOM_ROW -.LOWER_ROW_START+1;
		    REWRITE_NO_COL = .UPPER_RIGHT_COL -.LOWER_COL_START+1;
		    END;

		[1]:    RETURN (.STATUS);

		[2]:BEGIN
		    REWRITE_NO_ROW = .UPPER_BOTTOM_ROW -.LOWER_ROW_START+1;
		    REWRITE_NO_COL = .LOWER_NO_COL;
		    END;

		[4]:BEGIN
		    REWRITE_NO_ROW = .LOWER_NO_ROW;
		    REWRITE_NO_COL = .UPPER_RIGHT_COL -.LOWER_COL_START+1;
		    END;

		[5]:	RETURN (.STATUS);

		[6]:BEGIN
		    REWRITE_NO_ROW = .LOWER_NO_ROW;;
		    REWRITE_NO_COL = .LOWER_NO_COL;
		    END;

		[8]:	RETURN (.STATUS);

		[9]:	RETURN (.STATUS);

		[10]:   RETURN (.STATUS);

		[3,7]: RETURN (SMG$_FATERRLIB);

	    TES;
	    END;

	[10]:	RETURN (.STATUS);

	[3,7]: RETURN (SMG$_FATERRLIB);

    TES;

!+
! If we reach here, some occlusion has been detected and the output
! arguments have been calculated.  All that remains is to return the
! right status reporting existance of occlusion.
!-
    RETURN (1);

    END;		! End of routine SMG$$OCCLUDE
!<BLF/PAGE>

%SBTTL 'SMG$$POINT_IN_RECT_R3 - Point inside rectangle'
GLOBAL ROUTINE SMG$$POINT_IN_RECT_R3 (	! Point in rectangle
		X1 : REF VECTOR [,WORD,SIGNED], ! X coordinate of point
		Y1 : REF VECTOR [,WORD,SIGNED], ! Y coordinate of point
		RECT : REF VECTOR [,WORD,SIGNED]
				 ) : POINT_IN_RECT_LINK  =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns a code indicating the relative placement
! of a point with respect to a horizontally-oriented window (that is, 
! one of the sides of the rectangle is parallel to the x-axis.  
! (See diagram below).  
!
!	This is the inner-most function of the Cohen-Sutherland clipping
! algorithm.
!
!	These codes have two significant properties:
!
!	1.  If the CODE of two points are each zero, both points are
!	    within the window and no clipping needs to be done.
!
!	2.  If the logical AND of the CODEs of two points is non-zero,
!	    the points are both outside of the window and are so
!	    positioned that the line joining them does not intersect
!	    the window. (I.e., it is a line segment which need not
!	    be even partially displayed.
!
!
!		   |			   |
!       1001	   |	  1000		   |    1010
!		   |			   |
!  ----------------+-----------------------+------------ RECT [DCB_W_ROW_START]
!		   |			   |	     ^
!		   |	 Window		   |	     |
!		   |			   |	     | RECT [DCB_W_NO_ROWS]
!	0001	   |      0000		   |    0010 |
!		   |			   |	     V
!  ----------------+-----------------------+------------
!		   |			   |
!	0101	   |	  0100		   |    0110
!		   |			   |
!		   |<-RECT [DCB_W_NO_COLS]>|
!		   |			   |
!	RECT [DCB_W_COL_START]
!
!
! CALLING SEQUENCE:
!
!	CODE.wl.v = SMG$$POINT_IN_RECT_R3 (X1.rw.r, Y1.rw.r, RECT.rab.r)
!
! FORMAL PARAMETERS:
!
!	X1.rw.r		X coordinate of point
!	Y1.rw.r		Y coordinate of point
!	RECT.rab.r	Discription of the rectangular area.
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	One of the 9 codes indicated in the diagram above.
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LITERAL
	ROW_START = 0,
	NUM_ROW   = 1,
	COL_START = 2,
	NUM_COL   = 3;

    RETURN (
	(
	IF .X1[0] LSS .RECT [COL_START]
	THEN 	    		%B'0001'    ! to left
	ELSE 
	    BEGIN
	    IF .X1[0] GEQ (.RECT [COL_START] + .RECT [NUM_COL])
	    THEN		%B'0010'    ! to right
	    ELSE		0	    ! neither to right or left
	    END
	)
	+
	(
	IF .Y1[0] GEQ (.RECT [ROW_START] + .RECT [NUM_ROW])
	THEN 	    		%B'0100'    ! below bottom
	ELSE 
	    BEGIN
	    IF .Y1[0] LSS .RECT [ROW_START]
	    THEN 		%B'1000'    ! above top
	    ELSE 		0	    ! Neither above or below
	    END
	) ) ;


    END;		! End of routine SMG$$POINT_IN_RECT_R3
!<BLF/PAGE>

END			! End of module SMG$DISPLAY_OUTPUT

ELUDOM
