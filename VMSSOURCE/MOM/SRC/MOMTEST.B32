%TITLE 'MOM Loop Test Routines'
MODULE MOMTEST (
		LANGUAGE (BLISS32),
		ADDRESSING_MODE (NONEXTERNAL=GENERAL),
		ADDRESSING_MODE (EXTERNAL=GENERAL),
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
 
!++
! FACILITY:  DECnet-VAX Network Management Maintenance Operations Module (MOM)
!
! ABSTRACT:
!
!	This routine contains routines to process NCP LOOP NODE and LINE
!	command messages.
!
! ENVIRONMENT:  VAX/VMS Operating System
!
! AUTHOR:  Kathy Perko
!
! CREATION DATE:  9-Jan-1983
!
! MODIFIED BY:
!	V03-006	MKP0006		Kathy Perko		22-July-1984
!		Fix LOOP CIRCUIT on point-to-point circuits so that,
!		after getting the first invalid 0C message (to synchronize
!		with the target), to skip over all subsequent 0C messages.
!
!	V03-005	MKP0005		Kathy Perko		5-June-1984
!		Allow LOOP NODE to work if the node is specified by number.
!
!	V03-004	MKP0004		Kathy Perko		29-April-1984
!		When looping a circuit in the Ethernet, make sure the
!		HELP NI address is not alternated by MOM$MOPSNDRCV.  This
!		is because the loop message should be rebuilt to match
!		the NI address being alternated.  That must be done outside
!		MOM$MOPSNDRCV.
!
!	V03-003	MKP0003		Kathy Perko		22-Jan-1984
!		Fix LOOP NODE so it works with access control.
!		Add function code parameter to calls to MOM$INIT_CIB.
!
!	V03-002	MKP0002		Kathy Perko		6-Dec-1983
!		If mapping a loop error I don't recognize, return whatever
!		Network Management completion code the caller gave me, instead
!		of returning "Management Program Error".
!
!	V03-001	MKP0001		Kathy Perko		6-May-1983
!		Fix DMC loop circuit.  Fix loop line.
!
!--
 

%SBTTL 'Declarations'

!
! TABLE OF CONTENTS:
!
 
FORWARD ROUTINE
    mom$test 		: NOVALUE,
    mom$activeloop	: NOVALUE,
    mom_build_loop_bufs	: NOVALUE,
    mom$passiveloop	: NOVALUE,
    mom$loop_line	: NOVALUE,
    mom$nodetest	: NOVALUE,
    mom$initbuffer	: NOVALUE,
    mom$chkbuffer,
    mom$getbuffer,
    mom$freebuffer,
    mom_openlink	: NOVALUE,
    mom_bldloopnfb	: NOVALUE,
    mom_maplooperr	: NOVALUE,
    mom_siglooperr	: NOVALUE,
    mom$saveuser,
    mom$savepasswrd,
    mom$saveacct,
    mom$loophandler,
    mom$testhandler;
 
!
! INCLUDE FILES:
!

LIBRARY 'LIB$:MOMLIB.L32';
LIBRARY 'SHRLIB$:NMALIBRY.L32';
LIBRARY 'SHRLIB$:EVCDEF.L32';
LIBRARY 'SHRLIB$:NET.L32';
LIBRARY 'SYS$LIBRARY:LIB.L32';		! Network ACP control QIO interface

!
! EQUATED SYMBOLS:
!
 
LITERAL
    mbx_size = 40,
    nfb_bufsize = 110;
 
!
! OWN STORAGE:
!
 
OWN
    loop_chan,				! Loop link channel
    loop_mbxchan;			! Loop mailbox channel

OWN
    userdsc     : VECTOR [2],		! User id
    accountdsc  : VECTOR [2],		! Account
    passworddsc : VECTOR [2];		! Password

!
! NFB and P2 buffers and descriptors for loop QIO.
! 
OWN
    nfbdsc     : VECTOR [2],		! NFB for loop link
    mbx_buffer : VECTOR [40, BYTE],	! Mailbox buffer
    nfb_buffer : VECTOR [nfb_bufsize, BYTE], ! NFB buffer
    p2_buffer  : VECTOR [mom$k_p2_buf_len,  BYTE]; ! P2 QIO buffer

BIND
    mom$q_nfb_buf_dsc  = UPLIT (%ALLOCATION(nfb_buffer),  nfb_buffer)
		      : VECTOR [2],
    mom$q_p2bfdsc   = UPLIT (%ALLOCATION(p2_buffer),  p2_buffer)
		      : VECTOR [2];

!
! The following are for Phase 2 and Phase 3 differences.
! 
OWN
    version;
 
BIND
    object25dsc = $ASCID ('::"25=/',%CHAR(0,0,0),'                ','"')
		: VECTOR [2],
    object19dsc = $ASCID ('::"19=/',%CHAR(0,0,0),'                ','"')
		: VECTOR [2]; 
!
! The following data is used to manage buffers.  Default buffers may be
! used or the buffers may be allocated from virtual memory.
!
LITERAL
    mom$k_defbufsize = 130,
    mom$k_maxmsgsize = 128;

OWN
    mom$l_mop_chan,
    mom$l_assist_mop_chan,
    mom$l_vmbufsize  : LONG INITIAL (0),
    mom$l_vm_buf_adr : LONG INITIAL (0),
    mom$t_testrcvbuf : VECTOR [mom$k_defbufsize, BYTE];
 
!
! EXTERNAL REFERENCES:
!
 
$mom_externals;
 
EXTERNAL
    mom$gq_netnamdsc,
    mom$gq_dle_namdsc,
    mom$gq_psinamdsc,
    mom$npa_test,
    mom$npa_test_node_acc,
    mom$npa_cirloop;
 
EXTERNAL LITERAL
    mom$_alpbfovf,
    mom$_mirbfovf,
    mom$_ncbfail;
 
EXTERNAL ROUTINE
    nma$nparse,
    mom$bld_reply,
    mom$build_p2,
    mom$chk_mop_error,
    mom$debug_msg,
    mom$debug_qio,
    mom$error,
    mom$get_circuit_type,
    mom$get_node_id,
    mom$getsrvtimer,
    mom$init_CIB,
    mom$log_event,
    mom$netacp_qio,
    mom$mapqioerror,
    mom$mopopen,
    mom$mopsetsubstate,
    mom$mopsndrcv,
    lib$get_vm,
    lib$free_vm,
    lib$asn_wth_mbx : ADDRESSING_MODE (GENERAL);
 

%SBTTL 'mom$test  Loopback test'
GLOBAL ROUTINE mom$test : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!	This routine is called when MOM receives a NICE LOOP command.
!	The NICE message parsing is completed (it has already been parsed
!	through the circuit, line or node ID), and the routine to perform
!	the loop is called.
!
!--
 
BEGIN

MAP
    mom$gb_option_byte: bblock [1];

LOCAL
    nparse_table,
    loop_routine,
    status;
 
!
! Parse the remainder of the NICE command to get loop parameters.
!
SELECTONEU .mom$gb_entity_code OF
    SET
    [mom$c_node, mom$c_nodebyname]:
	BEGIN
	!
	! If there is access control in the LOOP NODE command, use a
	! different parsing table to get it from the NICE command.
	!
	IF .mom$gl_service_flags [mom$v_loop_w_access_ctl]
	THEN
	    nparse_table = mom$npa_test_node_acc
	ELSE
	    nparse_table = mom$npa_test;
	loop_routine = mom$nodetest;
	END;

    [mom$c_line]:
	BEGIN
	nparse_table = mom$npa_test;
	loop_routine = mom$loop_line;
	END;

    [mom$c_circuit]:
	BEGIN
	nparse_table = mom$npa_cirloop;
	loop_routine = mom$activeloop;
	END;
    TES;
!
! All parsing errors will be signalled by the action routines so, if control
! returns here, the parsing was successful.
!
nma$nparse (mom$ab_nparse_blk, .nparse_table);
(.loop_routine) (); 
END;				! End of MOM$TEST

%SBTTL 'mom$activeloop  Active loop'
GLOBAL ROUTINE mom$activeloop : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the active loop function as a result
!	a LOOP CIRCUIT command.
!
! IMPLICIT INPUTS:
!	MOM$L_MOP_CHAN = Channel number on which to issue loop MOP messages.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
!--
 
BEGIN

OWN
    msgs_looped;

LOCAL
    mom_recv_CIB: REF BBLOCK,
    mom_xmit_CIB: REF BBLOCK,
    loop_count : WORD,
    help_type,
    msgsize,
    rcvlen,
    retry,
    skip_invalid_MOP_msg,
    snddsc	: VECTOR [2],
    rcvdsc	: VECTOR [2],
    status;

!
! Enable condition handler to clean up after loop operation.
!
ENABLE mom$loophandler;
mom$get_circuit_type ();
mom$getsrvtimer ();
IF NOT .mom$gl_service_flags [mom$v_ni_circ] THEN
    !
    ! Assign a MOP channel for sending point to point or multipoint loop
    ! messages and make sure CIB isn't treated as if the circuit were an
    ! NI.
    !
    BEGIN
    mom$mopopen (mom$ab_cib [cib$l_chan]);
    mom$init_CIB (mom$ab_cib, nma$c_fnc_tes, 0, 0, 0);
    mom$ab_cib [cib$v_target_addr_fixed] = true;
    mom_xmit_CIB = mom_recv_CIB = mom$ab_cib;
    END
ELSE
    BEGIN
    !
    ! If the operation is LOOP with an assistant node (NI only) and there
    ! was no HELP type specified in the command, default HELP type to FULL.
    ! This means the looped message will go to the assisting node both on
    ! the way to and on the way back from the target node.
    !
    IF .mom$gl_service_flags [mom$v_loop_w_assist] AND
       NOT .mom$ab_service_data [svd$gk_pcno_lph, svd$v_msg_param] THEN
	mom$ab_service_data [svd$gk_pcno_lph, svd$l_param] = nma$c_loop_full;
    help_type = .mom$ab_service_data [svd$gk_pcno_lph, svd$l_param];
    !
    ! Set up to do QIOs to the target node.  First, get the target node's
    ! hardware address and/or node number.  Then, get a MOP I/O channel,
    ! and set up the association between the MOP I/O channel and an NI
    ! destination.
    !
    IF NOT .mom$ab_service_data [svd$gk_pcno_pha, svd$v_msg_param] THEN
	mom$get_node_id (svd$gk_pcno_lpn,
			 svd$gk_pcno_$lna,
			 svd$gk_pcno_$lnh);
    IF .help_type NEQ nma$c_loop_full THEN
	BEGIN
	mom$mopopen (mom$ab_cib [cib$l_chan]);
	mom$init_CIB (mom$ab_cib,
			nma$c_fnc_tes,
	    		svd$gk_pcno_pha,
			svd$gk_pcno_lpn,
	    		svd$gk_pcno_$lnh);
	END;
    !
    ! If loop assistance is specified in the NICE command, the loop message
    ! must be transmitted or received by a second node.  Set up this assistance
    ! channel the same way as the target channel (above).
    !
    If .help_type NEQ mom$k_no_loop_help THEN
	BEGIN
	mom$mopopen (mom$ab_loop_cib [cib$l_chan]);
	IF NOT .mom$ab_service_data [svd$gk_pcno_lpa, svd$v_msg_param] THEN
	    mom$get_node_id (svd$gk_pcno_lan,
			     svd$gk_pcno_$lnn,
			     svd$gk_pcno_$lah);
	mom$init_CIB (mom$ab_loop_cib,
			nma$c_fnc_tes,
			svd$gk_pcno_lpa,
			svd$gk_pcno_lan,
		    	svd$gk_pcno_$lnh);
	!
	! The loop message must be rebuilt to alternate with the receive
	! NI address, so tell MOM$MOPSNDRCV not alternate the receive NI
	! address.  That must be done from here (although it isn't done
	! correctly right now).
	!
	mom$ab_loop_cib [cib$v_target_addr_fixed] = true;
	END;

    SELECT .help_type of
	SET
	[mom$k_no_loop_help, nma$c_loop_recv]:
	    !
	    ! Set the loop messages to be transmitted to the target node.
	    !
	    mom_xmit_cib = mom$ab_cib;
	[nma$c_loop_full, nma$c_loop_xmit]:
	    !
	    ! Set the loop messages to be transmitted to the assisting node.
	    !
	    mom_xmit_cib = mom$ab_loop_cib;
	[nma$c_loop_full, nma$c_loop_recv]:
	    !
	    ! Set the looped messages to be received from the assisting node.
	    !
	    mom_recv_cib = mom$ab_loop_cib;
	[mom$k_no_loop_help, nma$c_loop_xmit]:
	    !
	    ! Set the loop messages to be received from the target node.
	    !
	    mom_recv_cib = mom$ab_cib;
	TES;
    END;
!
! Set the circuit substate to -LOOPING.
!
mom$mopsetsubstate (nma$c_linss_loo,
		     .mom_xmit_cib [cib$l_chan]);
mom_build_loop_bufs (snddsc, rcvdsc);
!
! Get the number of times to loop from the data base.
! If the parameter is not set in the data base then use default size.
!
loop_count = .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param];
!
! Loop the specified number of times.  For point to point circuits, 
! the target node's driver doesn't keep the MOP message that causes MOM to
! get start up.  Therefore, the target's MOM will send a bogus 0C MOP message
! to get this MOM to retransmit the loop message.  After receiving the first
! 0C message, skip over all others without retransmitting the loop message.
! This is in case the target is having trouble receiving the loop messae
! (buffer's too small, for example), and is retransmitting the 0C message.
! If this MOM doesn't wait for them, another MOM gets started up by the
! 0C message, and things start to ping-pong indefinitely.
!
retry = 2;
skip_invalid_MOP_msg = 0;
INCR i FROM 0 TO .loop_count - 1 DO
    BEGIN
    !
    ! Send and receive loop messages retrying on errors.
    !
    WHILE .retry GTR 0 DO
	BEGIN
	status = mom$mopsndrcv (.mom_xmit_cib, snddsc,
				.mom_recv_cib, rcvdsc,
				rcvlen,
				.skip_invalid_MOP_msg);
	!
	! If a message was received successfully then make sure that it matches
	! what was sent.  If it does, count one message successfully looped.
	!
	IF .status THEN
	    BEGIN
	    IF .rcvlen EQL 1 AND
	       .(.rcvdsc [1])<0,8> EQL %X'0C' THEN
		skip_invalid_MOP_msg = UPLIT (1, UPLIT BYTE (%X'0C'))
	    ELSE
		BEGIN
		status = mom$chkbuffer (.snddsc [0],
					.snddsc [1],
					.rcvlen,
					.rcvdsc [1],
					mom$c_loop_mop);
		IF .status THEN
		    EXITLOOP;
		END;
	    END
	ELSE
	    !
	    ! If the transmission of the loop message completed with any error
	    ! except a time out, quit trying right away.
	    !
	    BEGIN
	    IF .status NEQ ss$_timeout THEN
		EXITLOOP;
	    END;
	!
	! If an error was encountered then set up the error response message
	! and keep trying to send this one as long as the retry count allows.
	!
	retry = .retry - 1;
	mom$ab_msgblock [msb$b_code]  = nma$c_sts_lpr;
	END;
!
! If a loop message was not successfully sent and received even after 
! retries then stop trying to loop.
!
    IF NOT .status THEN
	BEGIN
	msgs_looped = .loop_count - .i;	! Set up of count of messages
	EXITLOOP;
	END;
    END;
!
! If all the loop messages were sent and receive successfully then
! return a success message.  If errors were encountered, return a
! message indicating the error and the number of messages not looped.
!
IF .status THEN
    BEGIN
    mom$ab_msgblock [msb$l_flags] = 0;
    mom$ab_msgblock [msb$b_code]  = nma$c_sts_suc;
    END
ELSE
    BEGIN
    mom$ab_msgblock [msb$l_flags] = .mom$ab_msgblock [msb$l_flags] OR
					msb$m_data_fld;
    mom$ab_msgblock [msb$a_data]     = UPLIT (2, msgs_looped);
    END;
!
! Build and signal the response message.
!
mom$bld_reply (mom$ab_msgblock, msgsize);
$signal_msg (mom$ab_nice_xmit_buf, .msgsize);

END;				! End of mom$activeloop

%SBTTL 'mom_build_loop_bufs    Build buffer containing loop message'
GLOBAL ROUTINE mom_build_loop_bufs (xmit_buffer_dsc,
				   recv_buffer_dsc) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to build a circuit loop message.  It gets a
!	buffer of the appropriate size and fills in the loop message.
!
! IMPLICIT INPUTS:
!	xmit_buffer_dsc - Address at which to return descriptor of completed
!		loop message to transmit.
!	recv_buffer_dsc - Address at which to return descriptor of completed
!		buffer.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!	Signal errors.
!
!--
 
BEGIN

OWN
    loop_size;

LOCAL
    loop_data	: BYTE,
    msgsize;

!
! Request buffers for loopback.
!
loop_size = .mom$ab_service_data [svd$gk_pcno_lpl, svd$l_param];
!
! If the circuit is an NI, the loop size doesn't include the headers.
! Add the maximum possible header size to the loop size.
!
IF .mom$gl_service_flags [mom$v_ni_circ] THEN
    loop_size = .loop_size + mom$k_max_loop_header;

IF NOT mom$getbuffer (loop_size, .xmit_buffer_dsc, .recv_buffer_dsc) THEN
    BEGIN
    mom$ab_msgblock [msb$l_flags]  = msb$m_det_fld or
				     msb$m_msg_fld or
				     msb$m_data_fld;
    mom$ab_msgblock [msb$b_code]   = nma$c_sts_pva;
    mom$ab_msgblock [msb$w_detail] = nma$c_pcno_lpl;
    mom$ab_msgblock [msb$l_text]   = mom$_alpbfovf;
    mom$ab_msgblock [msb$a_data]   = UPLIT (2, loop_size);

    mom$bld_reply (mom$ab_msgblock, msgsize);
    $signal_msg (mom$ab_nice_xmit_buf, .msgsize);
    END;
!
! Initialize the transmit buffer with the specified data.
!
loop_data = .mom$ab_service_data [svd$gk_pcno_lpd, svd$l_param];

mom$initbuffer (.xmit_buffer_dsc, .loop_data, mom$c_loop_mop);
END;				! End of mom_build_loop_bufs

%SBTTL 'mom$passiveloop  Passive loop'
GLOBAL ROUTINE mom$passiveloop (mop_msg_dsc) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the passive loopback function.
!	It provides the mirror function for the LOOP CIRCUIT command.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
!--
 
BEGIN

MAP
    mop_msg_dsc : ref vector;

LOCAL
    status;

!
! Enable condition handler to clean up after loop operation.
!
ENABLE mom$loophandler;
!
! Log the event indicating that a passive loopback operation was initiated.
!
mom$gw_evt_code = evc$c_nma_psl;	! Event code (passive loopback)
mom$gb_evt_popr = evc$c_nma_popr_ini;! Operation (initiated)
mom$log_event (0, 0);
mom$gb_evt_popr = evc$c_nma_popr_ter;! Operation (terminated)
!
! Set the circuit substate to -REFLECTING.
!
mom$mopsetsubstate (nma$c_linss_ref,
		     .mom$ab_cib [cib$l_chan]);
mom$ab_cib [cib$l_retry_cnt] = 1;
WHILE 1 DO
    BEGIN
    CH$WCHAR (mop$_fct_pld, .mop_msg_dsc [1]);

    status = mom$mopsndrcv (mom$ab_cib, .mop_msg_dsc,
			    mom$ab_cib, mom$gq_mop_rcv_buf_dsc,
			    mop_msg_dsc [0],
			    0);			! Don't skip any received msgs.
    mom$chk_mop_error (.status);

    IF .(.mop_msg_dsc [1])<0,8> NEQU mop$_fct_ald THEN
	EXITLOOP;

    END;

mom$error (nma$c_sts_suc);

END;				! End of mom$passiveloop

%SBTTL 'mom$loop_line  Loop PSI Line'
GLOBAL ROUTINE mom$loop_line : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!	This routine is called when MOM receives a LOOP LINE command from NCP.
!	Loop line can only be performed on PSI (LAPB) lines.  This routine
!	builds buffers and issues a QIOW to tell the PSIACP to perform the
!	loop line function.  It then takes the completion status of the QIO
!	and builds and sends a NICE response message to NCP.
!
! IMPLICIT INPUTS:
!	MOM$GQ_ENTITY_BUF_DSC	Contains descriptor of loop line ID.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!	Signal errors.
!
!--
 
BEGIN

$nfbdsc (mom_q_loop_line_nfb, loop, , pli
	,nam,		! Search key one = line name, oper1 = eql
	,,		! Null search key two

	,lpc		! Loop count
	,lpl		! Loop message length
	,lpd		! Loop message data type
	);
MAP
    mom_q_loop_line_nfb : VECTOR;

LOCAL
    status,
    p2_dsc:	VECTOR [2],
    p4_buf_dsc:	VECTOR [2],
    p4_buffer:	VECTOR [3],
    p3,
    iosb:	$iosb,
    database,
    loop_line_chan: WORD,
    nfb :	REF BBLOCK,
    msgsize;

!
! Build the loop line qio buffers.
!
mom$build_p2 (
	.mom$gq_entity_buf_dsc [0],		! Search key one length
	.mom$gq_entity_buf_dsc [1],		! Search key one address
	-1, 0,
	mom$q_p2bfdsc, p2_dsc);

p4_buffer [0] = .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param];
p4_buffer [1] = .mom$ab_service_data [svd$gk_pcno_lpl, svd$l_param];
p4_buffer [2] = .mom$ab_service_data [svd$gk_pcno_lpd, svd$l_param];
p4_buf_dsc [0] = 12;
p4_buf_dsc [1] = p4_buffer;

!
! Assign a channel directly to PSI rather than getting to PSI via NETACP,
! which is the normal route used for SET, SHOW etc QIOs issued by NML.
! In this case this isn't appropriate because NETACP can't afford to wait
! around for a loop function complete (or not, whichever the case may be).
! So, for loop line, MOM bypasses NETACP.
!
status = $ASSIGN (CHAN = loop_line_chan,
		  DEVNAM = mom$gq_psinamdsc);
IF NOT .status THEN
    BEGIN
    mom$ab_msgblock [msb$l_flags] = msb$m_msg_fld;
    mom$ab_msgblock [msb$b_code] = nma$c_sts_lco;
    mom$ab_msgblock [msb$l_text] = .status;
    END
ELSE
    BEGIN
    !
    ! Issue the loop line QIOW to PSIACP.
    !
    status = $QIOW (CHAN = .loop_line_chan,
		    FUNC = io$_acpcontrol,
		    IOSB = iosb,
		    P1 = mom_q_loop_line_nfb,
		    P2 = p2_dsc,
		    P3 = p3,
		    P4 = p4_buf_dsc);
    !
    ! If logging is turned on, dump the QIO status and buffers.
    !
    mom$debug_qio (dbg$c_acpqio,		! Log type code
		.status,		! QIO completion status
		iosb,			! I/O status block
		mom_q_loop_line_nfb,	! NFB buffer descriptor
		p2_dsc,			! P2 buffer descriptor
		p3,			! length of data in P4 buffer
		p4_buf_dsc);		! P4 buffer descriptor

    !
    ! Using the QIO completion status, set up the return status for
    ! the NICE response message to NCP.
    !
    nfb = .mom_q_loop_line_nfb [1];
    database = .nfb [nfb$b_database];
    IF mom$mapqioerror (.database, .status, iosb) THEN
	BEGIN
	mom$ab_msgblock [msb$l_flags] = 0;
	mom$ab_msgblock [msb$b_code] = nma$c_sts_suc;
	END;
    !
    ! Deassign the QIO channel to NW:
    !
    $DASSGN (CHAN = .loop_line_chan);
    END;
!
! Build and signal the NICE response message to NCP.
!
mom$bld_reply (mom$ab_msgblock, msgsize);
$signal_msg (mom$ab_nice_xmit_buf, .msgsize);
END;				! End of MOM$LOOPLINE

%SBTTL 'mom$nodetest  Node loopback test'
GLOBAL ROUTINE mom$nodetest : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens a link to the loopback mirror and
!	verifies the connect data to determine the maximum test message size.
!
!--
 
BEGIN
!
! Enable the condition handler to perform cleanup.
!
ENABLE mom$testhandler;
! 
! Build the NFB for the QIO IO$_ACPCONTROL
! 
$nfbdsc (nfbdsc,show,,ndi
	,nna,		! Search key 1 = node name, oper1 = eql
	,,		! Search key2 = wildcard, oper2 = eql
	,dty);
 
MAP
    nfbdsc	: VECTOR;
OWN
    bufsiz,				! Buffer size
    msgnotlooped : WORD;		! Number of messages not looped

LOCAL
    rcv_size,
    xmit_iosb : $IOSB,
    rcv_iosb  : $IOSB,
    ptr,
    rcvdsc    : VECTOR [2],
    snddsc    : VECTOR [2],
    status,
    p2nambuf  : VECTOR [mom$k_p2_buf_len,BYTE], ! Node name buffer for P2
						!	QIO argument
    p2dsc     : VECTOR [2],		! Descriptor P2 buffer
    nfb	      : REF BBLOCK,
    ent_len,
    ent_addr;
 
!
! Restructure node name for P2 argument in QIO.
!
nfb = .nfbdsc [1];
IF .mom$gb_entity_code EQL mom$c_nodebyname THEN
    BEGIN
    ent_len = .mom$gq_entity_buf_dsc [0];
    ent_addr = .mom$gq_entity_buf_dsc [1];
    nfb [nfb$l_srch_key] = nfb$c_ndi_nna;
    END
ELSE
    BEGIN
    ent_len = -2;
    ent_addr = ..mom$gq_entity_buf_dsc [1];
    nfb [nfb$l_srch_key] = nfb$c_ndi_add;
    END;
p2dsc [0] = mom$k_p2_buf_len;
p2dsc [1] = p2nambuf;
mom$build_p2 ( .ent_len,		! Length of node id
	    .ent_addr,			! Pointer to node id
	    -1, 0,
	    p2dsc,			! Descriptor of buffer
	    p2dsc);			! Descriptor of P2 parameter

!
! Determine which version of mirror will be used.
! 
status = mom$netacp_qio 
		(nfbdsc,		! NFB for QIO IO$_ACPCONTROL
		p2dsc,			! Descriptor P2 parameter
		0,
		mom$gq_acpqio_buf_dsc);	! The descriptor pointing to buffer
					! where information is returned
IF .status
    AND (.mom$ab_acpqio_buffer EQLU nma$c_nodty_pha) THEN
    BEGIN
    version = mom$c_loop_phase2;	! If both conditions then Phase 2
    bufsiz  = .mom$ab_service_data [svd$gk_pcno_lpl, svd$l_param] + 1;
    END
ELSE
    BEGIN
    version = mom$c_loop_phase3;    	! Else Phase 3 or later
    bufsiz  = .mom$ab_service_data [svd$gk_pcno_lpl, svd$l_param];
    END;
!
! Get buffers.
!
status = mom$getbuffer (bufsiz, snddsc, rcvdsc); ! Attempt to allocate it

IF NOT .status THEN
    BEGIN	
    mom_siglooperr (nma$c_sts_pva,
		    nma$c_pcno_lpl,
		    uplit (2, bufsiz),
		    mom$_alpbfovf,
		    msb$m_data_fld OR msb$m_msg_fld);
    END;
!
! Build the NFB from the data provided in the command message.
! 
mom_bldloopnfb ();
!
! Attempt to connect to the mirror.
!
mom_openlink ();
! 
! Initialize the transmit buffer according to the loop data type in
! MOM$AB_SERVICE_DATA [SVD$GK_PCNO_LPD, SVD$L_PARAM].
! 
mom$initbuffer (snddsc,
		.mom$ab_service_data [svd$gk_pcno_lpd, svd$l_param],
		.version);
! 
! Start looping the data
! 
INCR i FROM 0 TO .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param] - 1 DO
    BEGIN
    ! 
    ! Transmit loop data and wait for completion
    !
    status = $QIOW (CHAN = .loop_chan,
		    FUNC = io$_writevblk,
		    IOSB = xmit_iosb,
		    P1   = .snddsc [1],
		    P2   = .snddsc [0]);

    IF .status THEN status = .xmit_iosb [ios$w_status];
    !
    ! Check to see if we should log loop I/O
    !
    IF .status THEN
	mom$debug_msg (dbg$c_loopio,
		       .snddsc [1],
		       .snddsc [0],
		       $ASCID ('Test message transmitted'));
    !
    ! Map errors if there were any otherwise continue
    !
    mom_maplooperr (nma$c_sts_mld,
		    .status,
		    xmit_iosb,
		    .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param] - .i);
    !
    ! Post read to receive loop data back from mirror
    !
    status = $QIOW (CHAN = .loop_chan,
		    FUNC = io$_readvblk,
		    IOSB = rcv_iosb,
		    P1   = .rcvdsc [1],
		    P2   = .rcvdsc [0]);
 
    IF .status THEN status = .rcv_iosb [ios$w_status];

    rcv_size =.rcv_iosb [ios$w_count]; ! Set number of characters received
    !
    ! Check to see if we should log loop I/O
    !
    IF .status THEN
	mom$debug_msg (dbg$c_loopio,
		       .rcvdsc [1],
		       .rcvdsc [0],
		       $ASCID ('Test message received'));
    !
    ! Signal errors (if any).
    !
    mom_maplooperr (nma$c_sts_mld,
		    .status,
		    rcv_iosb,
		    .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param] - .i);
    !
    ! Check for errors on loopback.
    !
    IF NOT mom$chkbuffer (.snddsc [0],
			  .snddsc [1],
			  .rcv_size,
			  .rcvdsc [1],
			  .version) THEN
	BEGIN
	msgnotlooped = .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param] - .i; ! sET UP MESSAGES NOT LOOPED
	mom_siglooperr (nma$c_sts_blr,
			-1,
			UPLIT (2, msgnotlooped),
			0,
			msb$m_data_fld);
	END;	 
    END;				! End of INCR loop
 
!
! On successful loopback, disconnect link to mirror.
!
$QIOW (CHAN = .loop_chan,
	FUNC = io$_deaccess OR io$m_synch);
!
! Signal success.
!
mom$error (nma$c_sts_suc);
 
END;				! End of mom$nodetest

%SBTTL 'mom$initbuffer  Initialize loopback test buffer'
GLOBAL ROUTINE mom$initbuffer (bufdsc, data, type) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes a transmit buffer for active loop
!	functions based on the type of loopback (phase 2, phase 3, MOP)
!	and based on the type of data (ones, zeros, mixed).
!
! FORMAL PARAMETERS:
!
!	BUFDSC		Address of descriptor of buffer to be initialized.
!	DATA		Type of data to use.
!	TYPE		Loopback function type code.
!
!--
 
BEGIN
 
MAP
    bufdsc : REF VECTOR;

!
! Macro to add a "forward" header to an NI loop message.
!
MACRO
    $mom_forward_msg (msg_ptr,
			ni_addr_svd,
			node_addr_svd,
			node_name_svd,
			ni_hardw_svd) =
	BEGIN
	CH$WCHAR_A (mop$c_niloop_forward, msg_ptr);
	CH$WCHAR_A (0, msg_ptr);

    %IF NOT %NULL (ni_addr_svd)
    %THEN
	IF .mom$ab_service_data [ni_addr_svd, svd$v_msg_param] THEN
	    msg_ptr = CH$MOVE (6,
			    mom$ab_service_data [ni_addr_svd, svd$t_string],
			    .msg_ptr)
	ELSE
    %FI
	    BEGIN
	    mom$get_node_id (node_addr_svd,
				node_name_svd,
				ni_hardw_svd);
	    .msg_ptr = mom$k_ni_prefix;
	    msg_ptr = .msg_ptr + 4;
	    msg_ptr = CH$MOVE (2,
				mom$ab_service_data [node_addr_svd,
							 svd$l_param],
				.msg_ptr);
	    END;
	END
	%;

LOCAL
    loopdata : BYTE,
    ptr;

ptr = .bufdsc [1];
!
! Fill in the function code according to the type of loop operation.
!
SELECTONEU .type OF
    SET
    [mom$c_loop_phase2]:
	BEGIN
	CH$WCHAR_A (5, ptr);
	CH$WCHAR_A (0, ptr);
	END;

    [mom$c_loop_phase3]:
	CH$WCHAR_A (0, ptr);

    [mom$c_loop_mop]:
	BEGIN
	IF NOT .mom$gl_service_flags [mom$v_ni_circ] THEN
	    CH$WCHAR_A (mop$_fct_ald, ptr)
	ELSE
	    !
	    ! The circuit being looped is an NI.  The format if these loop
	    ! messages is completely different because the looping is done
	    ! by the NIs UNA device.
	    !
	    BEGIN
	    ptr = CH$FILL (0, 2, .ptr);		! Skip count
	    SELECT .mom$ab_service_data [svd$gk_pcno_lph, svd$l_param] OF
		SET
		[nma$c_loop_full,nma$c_loop_xmit]: 
		    !
		    ! The loop message will be sent to the assist NI
		    ! address first.  From there, it must be forwarded
		    ! to the target.  Add "forward" message header to
		    ! loop message so the assist node will send the
		    ! message on to the target node.
		    !
		    $mom_forward_msg (ptr, svd$gk_pcno_pha,
					svd$gk_pcno_lpn,
					svd$gk_pcno_$lna,
					svd$gk_pcno_$lnh);
		[nma$c_loop_full,nma$c_loop_recv]:
		    !
		    ! From the target node, the message must be forwarded to
		    ! the receive assist node.  Add the "forward" header to
		    ! accomplish this.
		    !
		    $mom_forward_msg (ptr, svd$gk_pcno_lpa,
					svd$gk_pcno_lan,
					svd$gk_pcno_$lnn,
					svd$gk_pcno_$lah);
		[ALWAYS]:
		    !
		    ! The message must be returned to this node.  Add a
		    ! "forward" header to the loop message which contains my
		    ! own NI address.
		    !
		    $mom_forward_msg (ptr,,
					svd$gk_pcno_iho,
					svd$gk_pcno_$hna,
					svd$gk_pcno_$hhw);
		TES;
	    !
	    ! Now add the "reply" message function and receipt number.
	    !
	    CH$WCHAR_A (mop$c_niloop_reply, ptr);
	    CH$WCHAR_A (0, ptr);
	    ptr = CH$FILL (0, 2, .ptr);		! Receipt number
	    END;
	END;
    TES;
!
! Select type of data to put in buffer.
!
SELECTONEU .data OF
    SET
    [nma$c_loop_mix]: loopdata = %B'01010101';
    [nma$c_loop_one]: loopdata = %X'FF';
    [nma$c_loop_zer]: loopdata = 0;
    TES;
!
! Initialize the buffer.
!
CH$FILL (.loopdata,
	 .bufdsc [0] - (.ptr - .bufdsc [1]),
	 .ptr);
 
END;				! End of mom$initbuffer

%SBTTL 'mom$chkbuffer  Check loopback test buffer'
GLOBAL ROUTINE mom$chkbuffer (sndlen, sndadr, rcvlen, rcvadr, type) =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	SNDLEN		Length of transmitted data.
!	SNDADR		Address of transmitted data.
!	RCVLEN		Length of received data.
!	RCVADR		Address of received data.
!	TYPE		Loopback function type code.
!
!--
 
BEGIN
 
LOCAL
    rcvptr,
    sndptr,
    skip_count,
    status;

rcvptr = .rcvadr;
sndptr = .sndadr + 1;

SELECTU .type OF
    SET
    [mom$c_loop_phase2
    ,mom$c_loop_phase3]:
	IF CH$RCHAR_A (rcvptr) NEQU 1 THEN
	    RETURN false;

    [mom$c_loop_phase2]:
	BEGIN
	CH$RCHAR_A (sndptr);
	CH$RCHAR_A (rcvptr);
	END;

    [mom$c_loop_mop]:
	BEGIN
	IF NOT .mom$gl_service_flags [mom$v_ni_circ] THEN
	    BEGIN
	    IF CH$RCHAR (.rcvptr) NEQU mop$_fct_ald
		       AND
	       CH$RCHAR (.rcvptr) NEQU mop$_fct_pld THEN
		RETURN false;
	    CH$RCHAR_A (rcvptr);
	    END
	ELSE
	    !
	    ! The message was looped on the NI, so the format is different.
	    !
	    BEGIN
	    skip_count = .(.rcvptr)<0,16> + 2;
	    rcvptr = .rcvptr + .skip_count;
	    IF CH$RCHAR (.rcvptr) NEQU mop$c_niloop_reply THEN
		RETURN false;
	    !
	    ! For now, ignore the receipt number.  So, skip the "reply"
	    ! function code and the receipt number;
	    !
	    rcvptr = .rcvptr + 4;
	    sndptr = .sndadr + .skip_count + 4;
	    END;
	END;
    TES;

IF CH$EQL ( .rcvlen - (.rcvptr - .rcvadr),
	    .rcvptr,
	    .sndlen - (.sndptr - .sndadr),
	    .sndptr) THEN
    RETURN true
ELSE
    RETURN false;
 
END;				! End of mom$chkbuffer

%SBTTL 'mom$getbuffer  Allocate send/receive buffers for loopback'
GLOBAL ROUTINE mom$getbuffer (reqsiz, rbfdsc, sbfdsc) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine will dynamically allocate buffers for loopback.
!
!	If there is not enough virtual memory then this routine will
!	return an error and set the maximum size into the descriptors.
!
! FORMAL PARAMETERS:
!
!	REQSIZ		Address of longword size of buffer to allocate.
!	RBFDSC		Address of receive buffer descriptor.
!	SBFDSC		Address of send buffer descriptor.
!
!--
BEGIN

MAP
    rbfdsc : REF VECTOR,
    sbfdsc : REF VECTOR;

LOCAL
    status;

mom$l_vmbufsize = 0;		! No buffer allocated
rbfdsc [1] = mom$t_testrcvbuf;
sbfdsc [1] = mom$ab_nice_xmit_buf;
!
! Determine if we need a buffer bigger then the default buffer.
!
IF ..reqsiz LEQU mom$k_maxmsgsize THEN
    BEGIN
    rbfdsc [0]  = ..reqsiz;
    sbfdsc [0]  = ..reqsiz;
    RETURN true
    END;

mom$l_vmbufsize = ..reqsiz * 2;	! Set up allocation size
!
! Attempt to get the necessary size buffer.
!
status = LIB$GET_VM (mom$l_vmbufsize, mom$l_vm_buf_adr);

IF .status THEN
    BEGIN
    rbfdsc [1] = .mom$l_vm_buf_adr;
    sbfdsc [1] = .mom$l_vm_buf_adr + (.mom$l_vmbufsize / 2);
    END
ELSE
    .reqsiz = mom$k_defbufsize;

rbfdsc [0]  = ..reqsiz;
sbfdsc [0]  = ..reqsiz;

RETURN .status

END;				! End of mom$getbuffer

%SBTTL 'mom$freebuffer  Deallocate buffers'
GLOBAL ROUTINE mom$freebuffer =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine deallocates buffers if any were allocated by the
!	MOM$GETBUFFER routine.
!
! IMPLICIT INPUTS:
!
!	MOM$L_VMBUFSIZE contains the size of the allocated buffers.
!	    If none were allocated then the value will be zero.
!
!--
BEGIN

LOCAL
    status;

IF .mom$l_vmbufsize NEQ 0 THEN
    status = LIB$FREE_VM (mom$l_vmbufsize, mom$l_vm_buf_adr);

mom$l_vmbufsize = 0;		! No buffer allocated

RETURN .status

END;				! End of mom$freebuffer

%SBTTL 'mom_openlink  Open a link to Mirror'
ROUTINE mom_openlink : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens a link to the loopback mirror and
!	verifies the connect data to determine the maximum test message size.
!
!--
 
BEGIN

OWN
    mbx_maxmsg : INITIAL (64), 		! Maximum mailbox message size
    mbx_bufquo : INITIAL (256);		! Maximum pool for mailbox messages

LOCAL
    mbxname      : VECTOR [10, BYTE],	! Buffer to build mailbox name
    mbxlst       : VECTOR [2],		! FAO list for mailbox name
    mbxdsc       : VECTOR [2],		! Descriptor of mailbox name buffer
    iosb         : $iosb,		! IO status block
    status,				! Return status
    ptr,				! General pointer
    ctr,				! General counter
    detail       : WORD,		! Error detail word
    flag,
    text,
    code         : BYTE,		! Error status code
    loop_descr : VECTOR [2],		! Loop message length descriptor
    mirror_descr : VECTOR [2];		! Mirror size descriptor
 
OWN
    chnchar : BBLOCK [dib$k_length]; ! Channel characteristics
 
!
! Establish a channel to looper object
!
status = LIB$ASN_WTH_MBX
		(
		mom$gq_netnamdsc, ! Device name
		mbx_maxmsg,	! Maximum mailbox message size
		mbx_bufquo,	! Maximum buffer quota for mailbox I/O
		loop_chan,	! I/O channel for mirror
		loop_mbxchan	! Mailbox channel for mirror
		);
!
! Map and signal any errors
!
mom_maplooperr (nma$c_sts_mcf, .status, 0, .mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param]);
 
status = $QIOW			! Create a logical link to mirror
	    (
	    CHAN = .loop_chan,	! Use network channel
	    FUNC = io$_access,	! ACP function
	    IOSB = iosb,	! Status here
	    P2   = nfbdsc	! This is the NFB descriptor
	    );
!
! Map and signal any errors
!
mom_maplooperr (nma$c_sts_mcf, .status, iosb,
		.mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param]);
 
status = $QIOW			! Read the connect data
	(
	CHAN = .loop_mbxchan,	! Channel for mailbox
	FUNC = io$_readvblk,
	IOSB = iosb,
	P1   = mbx_buffer,	! Read data into mailbox buffer
	P2   = mbx_size
	);
!
! Map and signal any errors
!
mom_maplooperr (nma$c_sts_mcf, .status, iosb,
		.mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param]);
!
! Validate the mailbox message and its returned optional data.
!
status = .(mbx_buffer)<0,16,0>;
ptr = mbx_buffer + 4;
 
IF .status NEQ msg$_confirm THEN	! It must be a connect confirm
    BEGIN
    flag = 0;
    code = nma$c_sts_mcf;		! Assume connect failure code
    text = 0;

    SELECTONE  .status OF
	SET
	[msg$_abort
	,msg$_exit]:
	    detail = nma$c_ncedtl_abo; ! Abort by object

	[msg$_discon]:
	    detail = nma$c_ncedtl_dis; ! Disconnect by object

	[msg$_netshut]:
	    detail = nma$c_ncedtl_nsd; ! Node shut down

	[msg$_nodeinacc
	,msg$_pathlost]:
	    detail = nma$c_ncedtl_die; ! Node or object failed

	[msg$_reject]:
	    detail = nma$c_ncedtl_rjc; ! Reject by object

	[msg$_thirdparty]:
	    detail = nma$c_ncedtl_abm; ! Abort by management

	[msg$_timeout]:
	    detail  = nma$c_ncedtl_nrs; ! No response from object

	[OTHERWISE]:
	    BEGIN
	    detail = -1;
	    flag = .flag OR msb$m_msg_fld;
	    text = .status;
	    END;

	TES;
    !
    ! Signal error
    !
    loop_descr [0] = 2;
    loop_descr [1] = mom$ab_service_data [svd$gk_pcno_lpc, svd$l_param];
    mom_siglooperr (.code, .detail, loop_descr, .text, .flag);

    END;
 
ctr = .iosb [ios$w_count] - 4;	! Play games to look at the data
ctr = .ctr - CH$RCHAR (.ptr) - 1;	! Skip over the device name
ptr = .ptr + CH$RCHAR (.ptr) + 1;	! Set pointer to optional data
 
!
! Verify optional data if Phase 3 mirror. (Ignore it if Phase 2.)
!
IF .version EQL mom$c_loop_phase3 THEN
    BEGIN 
    IF NOT (CH$RCHAR (.ptr) EQL 2)	! Verify optional data is 2 bytes long
    OR .(.ptr + 1)<0,16,0> LSS
	.mom$ab_service_data [svd$gk_pcno_lpl, svd$l_param] ! And mirror buffer size is greater
					           ! than requested loop size
    THEN
	BEGIN
	mirror_descr [0] = 2; ! Set up descriptor of mirror
	mirror_descr [1] = .ptr + 1; ! Maximum buffer size
	mom_siglooperr (nma$c_sts_pva,
		        nma$c_pcno_lpl,
		        mirror_descr,
		        mom$_mirbfovf,
		        msb$m_msg_fld); ! Signal error
	END;  
    END;

RETURN
 
END;

%SBTTL 'mom_bldloopnfb  Build a Network Control Block'
ROUTINE mom_bldloopnfb : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine builds the NFB for the loopback mirror
!	from information left around by the parse.
!
!--
 
BEGIN
 
MAP
    mom$gb_option_byte: BBLOCK [1];

LOCAL
    ptr,
    ctr,
    node_addr;

!
!	Initialize the NFB_BUFFER descriptor
!
nfbdsc [0] = nfb_bufsize;
nfbdsc [1] = nfb_buffer;
!
!	Obtain the node spec and strip trailing colons
!
IF .mom$gb_entity_code EQL mom$c_nodebyname THEN
    ptr = CH$MOVE (.mom$gq_entity_buf_dsc [0],
	       .mom$gq_entity_buf_dsc [1],
	       .nfbdsc [1])
ELSE
    BEGIN
    node_addr = .(.mom$gq_entity_buf_dsc [1])<0,16>;
    $FAOL (CTRSTR = $ASCID ('!UW'),
	   OUTLEN = ptr,
	   OUTBUF = nfbdsc,
	   PRMLST = node_addr);
    ptr = .ptr<0,16> + .nfbdsc [1];
    END;
!
!	Obtain the access control
!
IF .mom$gb_option_byte [nma$v_opt_acc] THEN	! Is there access control in
    BEGIN
    IF .userdsc [0] NEQ 0 THEN		! If not, use other access ctl
	BEGIN
	CH$WCHAR_A ('"', ptr);		! Put it in standard form
	ptr = CH$MOVE (	.userdsc [0],
			.userdsc [1],
			.ptr);
 
	IF .passworddsc NEQ 0 THEN	! A password??
	    BEGIN
	    CH$WCHAR_A (' ', ptr);
	    ptr = CH$MOVE (.passworddsc [0],
			   .passworddsc [1],
			   .ptr);
	    END;
 
	IF .accountdsc NEQ 0 THEN	! An account??
	    BEGIN
	    CH$WCHAR_A (' ', ptr);
	    ptr = CH$MOVE (	.accountdsc [0],
				.accountdsc [1],
				.ptr);
	    END;
 
	CH$WCHAR_A ('"', ptr);	! End the access control spec
	END;
    END;
!
!	Copy the object connect specification to the end
!
IF .version EQL mom$c_loop_phase3 THEN
    ptr = CH$MOVE ( .object25dsc [0],
		    .object25dsc [1],
		    .ptr)
ELSE
    ptr = CH$MOVE ( .object19dsc [0],
		    .object19dsc [1],
		    .ptr);
 
nfbdsc [0] = .ptr - .nfbdsc [1]; ! Save length of NFB
 
END;

%SBTTL 'mom_maplooperr     Map and signal MOM error'
ROUTINE	mom_maplooperr (code, status, iosb, loop) : NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
! This routine takes system service status and QIO IOSB status
! return codes and converts them to the proper detail codes for
! the network management status codes of NMA$C_STS_MLD and NMA$C_STS_MLD.
!
! The routine will also change the status to reflect the appropiate status
! if the system service or QIO IOSB status maps such a network management
! status code.(NMA$C_STS_PRI,NMA$C_STS_RES)
!
! FORMAL PARAMETERS:
!
!    code	The network management status code to use
!    status	The system service returned status code to map
!    iosb	The address of the IOSB,if there  is one
!		the IOS$W_STATUS status field is mapped if possible
!    loop	The number of times yet to loop
!
!--
BEGIN

MAP
    iosb   : REF $iosb,
    code   : BYTE,
    status : WORD,
    loop   : WORD;
 
LOCAL
    detail      : WORD,			! Detail word for MOM_SIGLOOPERR
    text,				! Error text for MOM_SIGLOOPERR
    flag,				! Optional flag for MOM_SIGLOOPERR
    count_descr : VECTOR [2]; 		! Descriptor for LOOP
 
!
! Check system status first if SS$_NORMAL check IOSB status if there is one.
! If status is normal return from routine.  Otherwise attempt to map status
! (either system service or IOSB status which ever fails first) into a 
! network management error detail or status code.
!
IF .status THEN
    IF .iosb NEQA 0 THEN status = .iosb [ios$w_status];
 
IF .status THEN
    RETURN success;
!
! At this point the system service or the I/O has failed and STATUS
! contains the system error code.
!
! Attempt to map into a network error detail code.
!
text = 0;				! Assume no optional text
flag = 0;				! Assume no optional flags 

SELECTONE .status OF
    SET
    [ss$_abort]:
	detail = nma$c_ncedtl_die;	! Node or object failed

    [ss$_nosuchnode]:
	detail = nma$c_ncedtl_una;	! Unrecognized node name

    [ss$_unreachable]:
	BEGIN
	detail = nma$c_ncedtl_unr;	! Node unreachable
	flag = msb$m_msg_fld;		! Map TEXT to system error
	text = .status;			! Pass system error code
	END;

    [ss$_invlogin]:
	detail = nma$c_ncedtl_acc;	! Access control rejected

    [ss$_nolinks,
     ss$_remrsrc]:
	BEGIN
	detail = nma$c_ncedtl_rsc;	! Network resources 
	flag = msb$m_msg_fld;		! Map TEXT to system error
	text = .status;			! Pass system error code
	END;

    [ss$_nosuchobj]:
	detail = nma$c_ncedtl_obj;	! Unrecognized object

    [ss$_thirdparty]:
	detail = nma$c_ncedtl_abm;	! Abort by management

    [ss$_timeout]:
	detail = nma$c_ncedtl_nrs;	! No response from object

    [ss$_ivdevnam]:
	BEGIN
	detail = nma$c_ncedtl_obj;	! Assume no such object
	text = mom$_ncbfail;		! Say error in NCB format
	END;

    [ss$_reject]:
	BEGIN
	!
	! SS$_REJECT "real" reason for reject is in second longword of IOSB
	! Therefore we must map each possible reason
	!
	SELECTONE .iosb [4,0,16,0] OF
	    SET
	    [net$c_dr_access,
	     net$c_dr_accnt]:
		detail = nma$c_ncedtl_acc; ! Access control rejected

	    [net$c_dr_exit]:
		detail = nma$c_ncedtl_die; ! Node or object failed

	    [net$c_dr_nobj]:
		detail = nma$c_ncedtl_obj; ! Unrecognized object

	    [net$c_dr_nocon]:
		detail = nma$c_ncedtl_bsy; ! Object too busy

	    [net$c_dr_nopath]:
		detail = nma$c_ncedtl_una; ! Unrecognized node name

	    [net$c_dr_normal]:
		detail = nma$c_ncedtl_rjc; ! Rejected by object

	    [net$c_dr_segsiz,
	     net$c_dr_rsu]:
		detail = nma$c_ncedtl_rsc; ! Network resource

	    [net$c_dr_shut]:
		detail = nma$c_ncedtl_nsd; ! Node shutdown

	    [net$c_dr_third]:
		detail = nma$c_ncedtl_abm; ! Abort by management

	    [OTHERWISE]:
		BEGIN
		detail = -1;		 ! No detail
		flag = .flag or msb$m_msg_fld;
		text = .status;
		END;

	    TES;
	END;

    [OTHERWISE]:
	BEGIN
	detail = -1;			! No detail
	flag = .flag OR msb$m_msg_fld;	! Map TEXT to system error
	text = .status;			! Pass system error code
	END;

    TES;
!
! Build the data descriptor of number of messages not looped for MOM_SIGLOOPERR
!
count_descr [0] = 2;
count_descr [1] = loop;
!
! Signal error
!
mom_siglooperr (.code, .detail, count_descr, .text, .flag);

END;				! End of MOM_MAPLOOPERR

%SBTTL 'mom_siglooperr      Signal looper errors'
ROUTINE	mom_siglooperr (code, detail, data, text, flag) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine builds the message segment block and actually signals 
!	the error.
!
! FORMAL PARAMETERS:
!
!	CODE		Code of the status to be signalled.
!	DETAIL		Detail to be signalled.
!	DATA		Address of the data descriptor.
!	TEXT		Code for optional detail error text.
!	FLAG		Mask for optional flags (used for MSB$M_MSG_FLD).
!
! IMPLICIT OUTPUTS:
!
!	This routine will build the message segment block in MOM$AB_MSGBLOCK
!	This routine calls MOM$BLD_REPLY which builds the message in
!	MOM$AB_NICE_XMIT_BUF.
!
!--
BEGIN

MAP
    code   : BYTE,
    detail : WORD,
    data   : REF VECTOR,
    text   : LONG,
    flag   : LONG;

LOCAL
    message_size;

!
! Build the message descriptor block in MOM$AB_MSGBLOCK
!
mom$ab_msgblock [msb$l_flags] = .flag OR
			        msb$m_det_fld OR
			        msb$m_data_fld;
mom$ab_msgblock [msb$b_code] = .code;     ! Status code
mom$ab_msgblock [msb$w_detail] = .detail; ! Detail code
mom$ab_msgblock [msb$a_data] = .data;     ! Count field
mom$ab_msgblock [msb$l_text] = .text;     ! Optional error text code
!
! Call MOM$BLD_REPLY to build the error message
!
mom$bld_reply (mom$ab_msgblock, message_size);
!
! Signal the message
!
 
$signal_msg (mom$ab_nice_xmit_buf, .message_size);
 
END;				! End of mom_siglooperr

%SBTTL 'mom$saveuser      NPARSE action routine'
GLOBAL ROUTINE	mom$saveuser	=

!++
! FUNCTIONAL DESCRIPTION:
!
! This routine builds the descriptor for the USER part of
! the access control string
!
! IMPLICIT INPUTS:
!	NPARSE block is pointed by AP and defined in NPARSE macro
!
! ROUTINE VALUE:
! COMPLETION CODE:
!	SUCCESS always returned
!
! SIDE EFFECTS:
!	A descriptor is built in USERDSC
!--
BEGIN

$npa_argdef;

userdsc [0] = .nparse_block [npa$l_fldcnt] - 1;
userdsc [1] = .nparse_block [npa$l_fldptr] + 1;

RETURN success

END;				! End of mom$saveuser

%SBTTL 'mom$savepasswrd      NPARSE action routine'
GLOBAL ROUTINE mom$savepasswrd =

!++
! FUNCTIONAL DESCRIPTION:
!
! This routine creates a descriptor for the password portion
! of the access control string and stores it in PASSWORDDSC
!
! IMPLICIT INPUTS:
!	NPARSE block is pointed to by AP and is defined in $NPA_ARGDEF macro
!
! COMPLETION CODE:
!	SUCCESS returned
!
! SIDE EFFECTS:
!	Descriptor built in PASSWORDDSC
!
!--
BEGIN

$npa_argdef;

passworddsc [0] = .nparse_block [npa$l_fldcnt] - 1;
passworddsc [1] = .nparse_block [npa$l_fldptr] + 1;

RETURN success
END;				! End of MOM$SAVEPASSWRD

%SBTTL 'mom$saveacct  NPARSE action routine'
GLOBAL ROUTINE mom$saveacct =

!++
! FUNCTIONAL DESCRIPTION:
!
! This routine builds a descriptor for the account portion of
! the access control string.
!
! IMPLICIT INPUTS:
!	NPARSE block is pointed by AP and defined in $NPA_ARGDEF macro
!
! ROUTINE VALUE:
! COMPLETION CODE:
!	SUCCESS returned
!
! SIDE EFFECTS:
!	A descriptor is built in ACCOUNTDSC
!--
BEGIN

$npa_argdef;

accountdsc [0] = .nparse_block [npa$l_fldcnt] - 1;
accountdsc [1] = .nparse_block [npa$l_fldptr] + 1;

RETURN success

END;				! End of MOM$SAVEACCT

%SBTTL 'mom$loophandler  Condition handler'
GLOBAL ROUTINE mom$loophandler (signal_vec, mechanism)	=
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is a condition handler that performs cleanup
!	at the end of loop operations.  Any buffers that were
!	allocated from virtual memory are deallocated.
!
! FORMAL PARAMETERS:
!
!	SIGNAL_VEC	Pointer to the signal vector.
!	MECHANISM	Pointer to the mechanism array.
!
!--
BEGIN

MAP
    signal_vec : REF BBLOCK,	! Signal vector argument
    mechanism  : REF BBLOCK;	! Mechanism vector array pointer

!
! If loop buffers were allocated, deallocate them.
!
mom$freebuffer ();
!
! If it was a LOOP with ASSIST command, deassign the assist channel here.
! The target channel will be deassigned in either MOM$AUTOHANDLER or 
! MOM$SERVICEHANDLER.
!
IF .mom$ab_loop_cib [cib$l_chan] NEQ 0 THEN
    $DASSGN (CHAN = .mom$ab_loop_cib [cib$l_chan]);

RETURN ss$_resignal;		! Always resignal error
  
END;				! End of MOM$LOOPHANDLER

%SBTTL 'mom$testhandler  Condition handler'
GLOBAL ROUTINE	mom$testhandler (signal_vec, mechanism)	=
 
!++
! FUNCTIONAL DESCRIPTION:
!	This routine is the condition handler to force a disconnect of
!	the mirror link on any errors
!
!	This routine also deallocates any buffers allocated.
!
! FORMAL PARAMETERS:
!	SIGNAL_VEC	Pointer to the signal vector.
!	MECHANISM	Pointer to then mechanism array.
!
! IMPLICIT INPUTS:
!	LOOP_CHAN	The channel that the connect to the mirror
!			is assumed to have been used.
!
!--
BEGIN

MAP
    signal_vec : REF BBLOCK,		! Signal vector argument
    mechanism  : REF BBLOCK;		! Mechanism vector array pointer

LOCAL
    status_code : BBLOCK [4];		! Status code
 
status_code = .signal_vec [chf$l_sig_name]; ! Save condition name
 
IF .status_code [sts$v_fac_no] EQLU mom$k_fac_code THEN
    BEGIN
    !
    ! Deassign the mirror channel.
    !
    $DASSGN (CHAN = .loop_chan);
    !
    ! If loop buffers were allocated, deallocate them.
    !
    mom$freebuffer ();

    END;

RETURN ss$_resignal;		! Always resignal error
  
END;				! End of MOM$TESTHANDLER

  
END
 
ELUDOM
