	.TITLE	PREPOST	- VAX/VMS Monitor Pre-post Collection Rtns
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:  VAX/VMS MONITOR Utility
;
; ABSTRACT:
;
;	The pre- and post- collection routines perform class-specific
;	data collection which does not conform to the scheme required
;	by the FETCH routine.
;
; ENVIRONMENT: Each routine is entered in EXEC mode. Some routines
;		 elevate to kernel mode and some additionally raise
;		 IPL to synchronize data base access with VMS.
;
; AUTHOR: Henry M. Levy		, CREATION DATE: 28-March-1977
;	  Thomas L. Cafarella
;
; MODIFIED BY:
;
;	V03-017	TLC1079		Thomas L. Cafarella	11-Jul-1984	11:00
;		Miscellaneous name and label changes.
;
;	V03-016	TLC1076		Thomas L. Cafarella	09-Jul-1984	15:00
;		Correct reporting of negative queue length for DISK class.
;
;	V03-015	TLC1072		Thomas L. Cafarella	17-Apr-1984	11:00
;		Add volume name to DISK display.
;
;	V03-014	PRS1017		Paul R. Senn		9-Apr-1984	15:00
;		Changes to STATES collection routine to support SYSTEM class
;
;	V03-013	TLC1056		Thomas L. Cafarella	22-Mar-1984	11:00
;		Disable journaling classes and exclude class which is disabled.
;
;	V03-012	TLC1055		Thomas L. Cafarella	11-Mar-1984	16:00
;		Pick up queue length from UCB for DISK class.
;
;	V03-011	PRS1010		Paul R. Senn		27-Feb-1984	 9:00
;		Add precollection routine for DLOCK class
;
;	V03-011	PRS1007		Paul R. Senn		17-FEB-1984	14:00
;		Add precollection routine for XQPCACHE class
;
;	V03-010	PRS1004		Paul R. Senn		11-JAN-1983	16:00
;		Misc. changes to POOL class
;
;	V03-009 SPC0008		Stephen P. Carney	07-Sep-1983	16:00
;		Fix SCS Class Kbyte overflow.
;
;	V03-008	TLC1045		Thomas L. Cafarella	25-Aug-1983	11:00
;		Always include node name in DISK display
;		for cluster systems.
;
;	V03-007 SPC0004		Stephen P. Carney	24-Jun-1983	16:00
;		Add SCS Class pre-collection routine.
;
;	V03-006	TLC1035		Thomas L. Cafarella	06-Jun-1983	15:00
;		Add homogeneous class type and DISK class.
;
;	V03-006	SPC0003		Stephen P. Carney	06-Jun-1983	15:00
;		Add JDEVICE Class pre-collection routine.
;
;	V03-005	TLC1032		Thomas L. Cafarella	27-May-1983	15:00
;		Add Blocking AST Rate to LOCK class.
;
;	V03-004	TLC1028		Thomas L. Cafarella	14-Apr-1983	16:00
;		Add interactive user interface.
;
;	V03-004	TLC1027		Thomas L. Cafarella	14-Apr-1983	16:00
;		Enhance file compatibility features.
;
;	V03-004 TLC1026		Thomas L. Cafarella	14-Apr-1983	16:00
;		Miscellaneous updates to JOURNALING, RU and FCP classes.
;
;	V03-003	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF.
;
;--


	.SBTTL	DECLARATIONS
	.PSECT	DSPDATA,QUAD,NOEXE
;
; INCLUDE FILES:
;

	$CDTDEF				; Define Connection Desc. Table offsets
	$DCDEF				; Define device class codes
	$DEVDEF				; Define device characteristics flags
	$DDBDEF				; Define Device Data Block offsets
	$IPLDEF				; Define Interrupt Processor Levels
	$IRPDEF				; Define Intermediate req. pkt. offsets
	$PBDEF				; Define Path Block offsets
	$PCBDEF				; Process control block definitions
	$PHDDEF				; Process header definitions
	$STATEDEF			; Process state definitions
	$PRDEF				; Define processor register numbers
	$SBDEF				; Define System Block offsets
	$UCBDEF				; Define Unit Control Block offsets
	$VCBDEF				; Define Volume Control Block offsets
	$CDBDEF				; Define Class Descriptor Block
	$MRBDEF				; Define Monitor Request Block
	$MBPDEF				; Define Monitor Buffer Pointers
	$MCADEF				; Define Monitor Communication Area
	$MONDEF				; Monitor Recording File Definitions

;
; MACROS:
;

;
; Local Macro Definitions
;

;
; ALLOC Macro - Dynamically allocate space on the stack.
;

	.MACRO	ALLOC	LENGTH,RSLDESC,RSLBUF
	SUBL	#<LENGTH+3>&<^C3>,SP
	.IF	NB,RSLBUF
	MOVL	SP,RSLBUF
	.ENDC
	PUSHL	SP
	PUSHL	#LENGTH
	MOVL	SP,RSLDESC
	.ENDM	ALLOC


;
; EQUATED SYMBOLS:
;

;
; SCS class symbols for collection buffer offset.
;

MNR_SCS$Q_NODENAME	= 00		; SCS counted ASCII node name
MNR_SCS$L_DGSENT	= 08		; SCS application datagrams sent
MNR_SCS$L_DGRCVD	= 12		; SCS application datagrams received
MNR_SCS$L_DGDISCARD	= 16		; SCS application datagrams discarded
MNR_SCS$L_MSGSENT	= 20		; SCS application messages sent
MNR_SCS$L_MSGRCVD	= 24		; SCS application messages received
MNR_SCS$L_SNDDATS	= 28		; SCS block send datas initiated
MNR_SCS$L_KBYTSENT	= 32		; SCS Kbytes sent via send datas
MNR_SCS$L_REQDATS	= 36		; SCS block request datas initiated
MNR_SCS$L_KBYTREQD	= 40		; SCS Kbytes received via request datas
MNR_SCS$L_KBYTMAPD	= 44		; SCS Kbytes mapped for block xfr
MNR_SCS$L_QCR_CNT	= 48		; SCS times conn. q'd for send credit
MNR_SCS$L_QBDT_CNT	= 52		; SCS times conn. q'd for buff descr

MNR_SCS$L_CBKBSENT	= 56		; SCS aux coll. buff. to cvt KB sent
MNR_SCS$L_CBKBREQD	= 60		; SCS aux coll. buff. to cvt KB request
MNR_SCS$L_CBKBMAPD	= 64		; SCS aux coll. buff. to cvt KB map

MNR_SCS$C_CBLENGTH	= 56		; Length of one collection
MNR_SCS$C_CBWORK	= 68		; Extra working space in coll. buff.



;
; OWN STORAGE:
;


FCPCALLS::	.BLKL	1		; total calls to FCP
FCPCACHE::	.BLKL	1		; FCP directory cache hits
FCPCPU::	.BLKL	1		; FCP CPU time used
FCPREAD::	.BLKL	1		; FCP disk reads
FCPWRITE::	.BLKL	1		; FCP disk writes
FCPFAULT::	.BLKL	1		; FCP page faults

;
; Space for accumulating statistics on the nonpaged pool.
; (do not change order)
;

HOLECNT::	.BLKL	1		; number of blocks in nonpaged pool
HOLESUM::	.BLKL	1		; total space in pool
BIGHOLE::	.BLKL	1		; largest hole in pool
SMALLCNT::	.BLKL	1		; number of holes < 32 bytes
SMALLHOLE::	.BLKL	1		; smallest hole in pool
IRPCNT::	.BLKL	1		; number of I/O (intermed) request packets
LRPCNT::	.BLKL	1		; number of large request packets
SRPCNT::	.BLKL	1		; number of small request packets
SRPINUSE::	.BLKL	1		; number of SRPs in use
IRPINUSE::	.BLKL	1		; number of IRPs in use
LRPINUSE::	.BLKL	1		; number of LRPs in use
DYNINUSE::	.BLKL	1		; size in bytes of variable part
					; of nonpaged pool currently in use
SYSFAULTS::	.BLKL	1		; count of system space page faults

;
; Data for the Lock class
;

ENQNEW::	.BLKL	1		; new ENQs
ENQCVT::	.BLKL	1		; converted ENQs
DEQ::		.BLKL	1		; DEQs
BLKAST::	.BLKL	1		; blocking ASTs

LOCKCNT::	.BLKL	1		; current number of locks in the system
RESCNT::	.BLKL	1		; current number of resources in the system

;
; Data for the DLock class
;

DLCKMSGS::	.BLKL	1		; Messages send to do Deadlock detection

;
; Data for the MODES class
;

CPU_BUSY:: 	.BLKL	1		; sum of the 6 mode counters
MPSTRTIM: 	.BLKQ	1		; save area for MP start time
BASE:		.LONG 0,0,0,0,0,0,0	; 7 Secondary base counter values

;
; Data for the STATES class (used by SYSTEM class)
;
PROC_COUNT::	.BLKL	1		; Sum of all processes
OTHER_STATES::	.BLKL	1		; Sum of processes in OTHER category
					; on system manager's screen.
SYSMGR_STATES:				; array of states shown on 
					; SYSTEM screen (all others are OTHER) 
		.BYTE	SCH$C_MWAIT	
		.BYTE	SCH$C_PFW	
		.BYTE	SCH$C_LEF	
		.BYTE	SCH$C_LEFO	
		.BYTE	SCH$C_HIB	
		.BYTE 	SCH$C_HIBO	
		.BYTE 	SCH$C_COM	
		.BYTE 	SCH$C_COMO	

SYSMGR_STATETOT = <. - SYSMGR_STATES>   ; Number of states on SYSTEM screen

;
; Data for the FILE_SYSTEM_CACHE class
;

FILHDR_TRIES::	.BLKL	1		; hits + misses on File Header cache
FID_TRIES::	.BLKL	1		; hits + misses on FID cache
DIRFCB_TRIES::	.BLKL	1		; hits + misses on Directory FCB cache
DIRDATA_TRIES::	.BLKL	1		; hits + misses on Directory Data cache
EXT_TRIES::	.BLKL	1		; hits + misses on Extent cache
QUO_TRIES::	.BLKL	1		; hits + misses on Quota cache
STORAGMAP_TRIES::	
		.BLKL	1		; hits + misses on Storage bitmap cache

;
; Data for the DISK class
;

BLANKS:		.ASCII	\    \		; used to collect a non-existent volnam

	.SBTTL	FCP_PRE - FCP Class Pre-collection Rtn
	.PSECT	$$MONCODE,NOWRT,EXE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine accumulates statistics from the File Control Primitive
;	data base and saves them in global variables so that they
;	may be fetched and processed by the standard FETCH
;	collection routine.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (unused by this rtn)
;
; IMPLICIT INPUTS:
;
;	PMS$GL_FCP2 - pointer to ten arrays of FCP data
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	FCPCALLS - contains total calls made to FCP
;	FCPCACHE - total FCP cache hits
;	FCPCPU - percent of CPU time used by FCP during the last
;		interval
;	FCPREAD - total FCP disk reads
;	FCPWRITE - total FCP disk writes
;	FCPFAULT - total FCP page faults
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	FCP_PRE, ^M<>

;
; Compute total calls to fcp
;

	MOVL	#5,R0			; sum first six counters
	CLRL	W^FCPCALLS		; clear counter
10$:
	ADDL	PMS$GL_FCP2[R0],W^FCPCALLS ; add in next counter
	SOBGEQ	R0,10$			; continue till done

;
; Compute disk reads and writes, cache hits, % CPU TIME and faults
;

	MOVL	#9,R0			; sum 10 entries in each array
	CLRQ	W^FCPREAD		; clear reads and writes
	CLRQ	W^FCPCACHE		; clear cache and cpu time
	CLRL	W^FCPFAULT		; clear page faults
20$:
	ADDL	PMS$GL_FCP2+<20*4>[R0],W^FCPREAD ; sum reads
	ADDL	PMS$GL_FCP2+<30*4>[R0],W^FCPWRITE ; sum writes
	ADDL	PMS$GL_FCP2+<40*4>[R0],W^FCPCACHE ; cache hits
	ADDL	PMS$GL_FCP2+<50*4>[R0],W^FCPCPU ; sum cpu tics used
	ADDL	PMS$GL_FCP2+<60*4>[R0],W^FCPFAULT ; sum page faults
	SOBGEQ	R0,20$
;
; Indicate to caller that FETCH collection IS required.
;

	MOVL	#YES,R1			; FETCH collection required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return

	.SBTTL	POOL_PRE - Pre-collection for Pool Statistics

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to accumulate statistics on behavior of SRP/IRP/LRP
;	lookaside lists and nonpaged dynamic memory pool.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (unused by this rtn).
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	LRPCNT, IRPCNT, SRPCNT, HOLECNT, BIGHOLE, SMALLHOLE,
;	SMALLCNT, SRPINUSE, IRPINUSE, LRPINUSE, DYNINUSE and HOLESUM 
;	are set by subroutine SCANPOOL
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	POOL_PRE, ^M<>

	$CMKRNL_S B^SCANPOOL		; get stats in kernel mode
	MOVL	#YES,R1			; indicate FETCH collection IS required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return

;++
; SCANPOOL - subroutine to update pool statistics
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SCANPOOL
;
; IMPLICIT INPUTS:
;
;	IOC$GL_SRPFL - address of SRP listhead
;	IOC$GL_IRPFL - address of IRP listhead
;	IOC$GL_LRPFL - address of LRP listhead
;	IOC$GL_SRPCNT - total number of SRP packets (used + available)
;	IOC$GL_IRPCNT - total number of IRP packets (used + available)
;	IOC$GL_LRPCNT - total number of LRP packets (used + available)
;	EXE$GL_NONPAGED - address of nonpaged pool listhead
;
; IMPLICIT OUTPUTS:
;
;	SRPCNT - number of SRP packets available
;	IRPCNT - number of IRP packets available
;	LRPCNT - number of LRP packets available 
;	SRPINUSE - Number of SRP packets in use
;	IRPINUSE - Number of IRP packets in use
;	LRPINUSE - Number of LRP packets in use
;	DYNINUSE - Size of variable nonpaged pool in use (in bytes)
;	HOLECNT - number of memory blocks in NONPAGED pool
;	BIGHOLE - largest memory block
;	SMALLHOLE - smallest memory block
;	SMALLCNT - number of 32 byte or smaller blocks
;	HOLESUM - total space in nonpaged pool
;
; SIDE EFFECTS:
;
;	must synchronize data base
;--

SCANPOOL:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; register save mask

;
; Initialize all variables possible at this level.
;

	CLRQ	R2			; clear holecnt, holesum
	CLRQ	R4			; clear for bighole, smallcnt
	MNEGL	#1,R6			; make smallest hole very large
	CLRL	R7			; clear for IRP counter
	CLRQ	R9			; clear for LRP, SRP counters

;
; Touch last word of sequence to make sure all code is resident.
;

	TSTL	W^120$			; make sure all code is resident

;
; Save address of nonpaged listhead and run at IPL
; contained there.
;

	MOVAL	EXE$GL_NONPAGED,R8	; get nonpaged pool listhead
5$:	DSBINT	(R8)+, R11		; set ipl for pool access

;
; Get the current total # of packets of each type and save on the stack
;

	PUSHL	IOC$GL_SRPCNT		; Save total SRPs
	PUSHL	IOC$GL_IRPCNT		; Save total IRPs
	PUSHL	IOC$GL_LRPCNT		; Save total LRPs

;
; Get the current total size of variable pool in bytes and save on stack
;
	BICL3	#^X1FF,G^MMG$GL_NPAGNEXT,R0	; Get current end of pool
	SUBL3	G^MMG$GL_NPAGEDYN,R0,-(SP)	; Compute pool size 
						; and save on the stack
;
; Run through the SRP list and count the packets remaining
;

	MOVAL	IOC$GL_SRPFL,R0		; get SRP listhead address
	MOVL	R0,R1			; copy header address

10$:	MOVL	(R1),R1			; get forward link
	CMPL	R1,R0			; point back to header?
	BEQL	20$			; done if so
	INCL	R10			; count one more packet
	BRB	10$			; loop back for more
20$:

;
; Run through the IRP list and count the packets remaining
;

	MOVAL	IOC$GL_IRPFL,R0		; get IRP listhead address
	MOVL	R0,R1			; copy header address

30$:	MOVL	(R1),R1			; get forward link
	CMPL	R1,R0			; point back to header?
	BEQL	40$			; done if so
	INCL	R7			; count one more packet
	BRB	30$			; loop back for more
40$:

;
; Run through the LRP list and count the packets remaining
;

	MOVAL	IOC$GL_LRPFL,R0		; get LRP listhead address
	MOVL	R0,R1			; copy header address

50$:	MOVL	(R1),R1			; get forward link
	CMPL	R1,R0			; point back to header?
	BEQL	60$			; done if so
	INCL	R9			; count one more packet
	BRB	50$			; loop back for more
60$:

;
; Now run through the nonpaged pool, count the blocks, and check the
; smallest and largest holes.
;

	MOVL	R8,R0			; get pool listhead address
70$:	MOVL	(R0),R0			; get address of next block
	BEQL	110$			; branch if zero, list done
	INCL	R2			; note one more block
	MOVL	4(R0),R1		; get size of block
	ADDL	R1,R3			; add in size of this block
	CMPL	R1,R6			; is this smallest found?
	BGEQU	80$			; branch if not
	MOVL	R1,R6			; else save it
80$:	CMPL	R1,R4			; is this largest found?
	BLEQU	90$			; branch if not
	MOVL	R1,R4			; else update largest
90$:	CMPL	R1,#32			; is this one of the small ones?
	BGTRU	100$			; branch if not
	INCL	R5			; note another small hole
100$:	BRB	70$			; go on to next block
110$:	ENBINT	R11			; enable interrupts
					; of non-paged pool in use
	ASSUME .-5$ LE 512		; must be on one page only
120$:	MOVQ	R2,W^HOLECNT		; save variables (HOLECNT and HOLESUM)
	MOVQ	R4,W^BIGHOLE		; ...
	MOVQ	R6,W^SMALLHOLE		; ...
	MOVQ	R9,W^LRPCNT		; ...
	SUBL3	R3,(SP)+,DYNINUSE	; Calculate and save dynamic mem in use
	SUBL3	R9,(SP)+,LRPINUSE	; Calculate and save LRPs in use
	SUBL3	R7,(SP)+,IRPINUSE	; Calculate and save IRPs in use
	SUBL3	R10,(SP)+,SRPINUSE	; Calculate and save SRPs in use
	RET

	.SBTTL	LOCK_PRE - Pre-collection for Lock Statistics

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to count the number of locks and resources in the system,
;	and to total LOCK counters for incoming, outgoing, and local.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	LCK$GL_IDTBL	Contains address of lock id table
;	LCK$GL_MAXID	Contains maximum lock id
;	LCK$GL_HASHTBL	Contains address of resource hash table
;	LCK$GL_HTBLCNT	Contains # entries in hash table (expresses as a
;			power of two)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	ENQNEW, ENQCVT, DEQ, BLKAST, LOCKCNT and RESCNT are set.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	None
;--

.ENTRY	LOCK_PRE, ^M<R2,R3,R4,R5>

;
; Initialize to count the number of locks
;

	MOVL	G^LCK$GL_IDTBL,R5	; Get address of lock id table
	MOVL	G^LCK$GL_MAXID,R4	; Get maximum lock id
	CLRL	R3			; Initialize counter of locks

;
; Count the number of locks
;

10$:	TSTL	(R5)+			; Is there a lock in this slot?
	BGEQ	20$			; No
	INCL	R3			; Yes, bump counter
20$:	SOBGEQ	R4,10$			; Repeat for all entries in table
	MOVL	R3,LOCKCNT		; Store final value

;
; Count the number of resources
;

	$CMKRNL_S	B^COUNT_RES	; Do it in kernel mode

;
; Total local, incoming and outgoing counters for
; ENQNEW, ENQCVT, DEQ and BLKAST.
;

	ADDL3	PMS$GL_ENQNEW_LOC,PMS$GL_ENQNEW_IN,R2
	ADDL3	PMS$GL_ENQNEW_OUT,R2,W^ENQNEW

	ADDL3	PMS$GL_ENQCVT_LOC,PMS$GL_ENQCVT_IN,R2
	ADDL3	PMS$GL_ENQCVT_OUT,R2,W^ENQCVT

	ADDL3	PMS$GL_DEQ_LOC,PMS$GL_DEQ_IN,R2
	ADDL3	PMS$GL_DEQ_OUT,R2,W^DEQ

	ADDL3	PMS$GL_BLK_LOC,PMS$GL_BLK_IN,R2
	ADDL3	PMS$GL_BLK_OUT,R2,W^BLKAST

	MOVL	#YES,R1			; Indicate FETCH collection IS required
	MOVL	#SS$_NORMAL,R0		; Success status
	RET

;++
; COUNT_RES - Routine to count resources
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S	COUNT_RES
;
; IMPLICIT INPUTS:
;
;	LCK$GL_HASHTBL	Contains address of resource hash table
;	LCK$GL_HTBLCNT	Contains # entries in hash table (expresses as a
;			power of two)
;
; IMPLICIT OUTPUTS:
;
;	RESCNT - Number of resources
;
; SIDE EFFECTS:
;
;	Must raise IPL to synchronize database access
;--

COUNT_RES:
	.WORD	^M<R2,R3,R4,R5>

;
; Initialize to count resources
;

	MOVL	G^LCK$GL_HASHTBL,R5	; Get address of hash table
	MOVL	G^LCK$GL_HTBLCNT,R0	; Get size of table as power of two
	ASHL	R0,#1,R4		; Convert to number of entries
	CLRL	R3			; Initialize resource counter

;
; Count resources
;

20$:	MOVAL	(R5)+,R0		; Get address of next list head
	SETIPL	50$			; Raise IPL (and lock pages in w.s.)
30$:	MOVL	(R0),R0			; Get next element in list
	BEQL	40$			; Reached end of list
	INCL	R3			; Bump counter
	BRB	30$			; Continue down list
40$:	SETIPL	#0			; Lower IPL
	SOBGTR	R4,20$			; Repeat for next list
	MOVL	R3,RESCNT		; Store final value
	RET

50$:	.LONG	IPL$_SYNCH
	ASSUME	.-20$  LE  512		; Make sure it doesn't exceed two pages


	.SBTTL	DLOCK_PRE - Pre-collection for Distributed Lock Statistics

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to get the number of SCS messages sent in the service
;	of deadlock detection.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	PMS$GL_DLCKMSGS_IN - Deadlock detection messages recieved
;	PMS$GL_DLCKMSGS_OUT - Deadlock detection messages sent
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	DLCKMSGS is set.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	None
;--

.ENTRY	DLOCK_PRE, ^M<>

	ADDL3	PMS$GL_DLCKMSGS_IN, -
		PMS$GL_DLCKMSGS_OUT, DLCKMSGS
	MOVL	#YES,R1			; Indicate FETCH collection IS required
	MOVL	#SS$_NORMAL,R0		; Success status
	RET

	.SBTTL	DECNET_PRE - Pre-collection for DECnet Statistics

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to calculate current size of LRP lookaside
;	list for inclusion in the DECNET class.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (unused by this rtn).
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	LRPCNT is set by subroutine SCANLRP.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	DECNET_PRE, ^M<>

	$CMKRNL_S B^SCANLRP		; scan LRP list in kernel mode
	MOVL	#YES,R1			; indicate FETCH collection IS required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return

;++
; SCANLRP - subroutine to calculate LRP count
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SCANLRP
;
; IMPLICIT INPUTS:
;
;	IOC$GL_LRPFL - address of LRP listhead
;	EXE$GL_NONPAGED - address of nonpaged pool listhead
;
; IMPLICIT OUTPUTS:
;
;	LRPCNT - number of packets in LRP list
;
; SIDE EFFECTS:
;
;	must synchronize data base
;--

SCANLRP:
	.WORD	^M<R2,R3>		; register save mask


	CLRL	R3			; clear LRP counter

;
; Touch last word of sequence to make sure all code is resident.
;

	TSTL	B^30$			; make sure all code is resident

;
; Save address of nonpaged listhead and run at IPL
; contained there.
;

	MOVAL	EXE$GL_NONPAGED,R2	; get nonpaged pool listhead
	DSBINT	(R2)+			; set ipl for pool access

;
; Run through the LRP list and count the packets remaining
;

	MOVAL	IOC$GL_LRPFL,R0		; get LRP listhead address
	MOVL	R0,R1			; copy header address

10$:	MOVL	(R1),R1			; get forward link
	CMPL	R1,R0			; point back to header?
	BEQL	20$			; done if so
	INCL	R3			; count one more packet
	BRB	10$			; loop back for more

20$:	ENBINT				; enable interrupts
30$:	MOVL	R3,W^LRPCNT		; save LRP count for FETCH rtn
	RET

	.SBTTL	PAGE_PRE - PAGE Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine simply grabs the system page fault
;	count and places it into a location accessible to
;	the FETCH rtn.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (unused by this rtn)
;
; IMPLICIT INPUTS:
;
;	MMG$GL_SYSPHD - system process header address
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	SYSFAULTS - contains accumulated total of system page faults
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	PAGE_PRE, ^M<>

	MOVL	MMG$GL_SYSPHD,R0	; get system header address
	MOVL	PHD$L_PAGEFLTS(R0),W^SYSFAULTS ; store system page fault count
					; for page display
;
; Indicate to caller that FETCH collection IS required.
;

	MOVL	#YES,R1			; FETCH collection required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return

	.SBTTL	STATES_PRE - STATES Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Loop through all PCBs and count the number of processes in
;	each scheduling state.  The counts are accumulated in the
;	collection buffer passed to this rtn by the FETCH rtn.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	CDBPTR - global variable, pointer to current CDB
;	SCH$GL_PCBVEC - contains address of PCB vector
;	SCH$GL_MAXPIX - maximum process index
;
; OUTPUTS:
;
;	Collection buffer filled with appropriate state count values.
;	OTHER_STATES and PROC_COUNT filled in for SYSTEM class.
;
; IMPLICIT OUTPUTS:
;
;	BARSIZE - global variable altered to indicate size of VT55
;		  bar for histogram display.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	STATES_PRE,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

;
; Reset counters in collection buffer to zero
;

	CLRL	R10			; clear counter for check of SYSTEM
					; class state list
	MOVL	#SYSMGR_STATETOT,R7	; store limit for state list to R7
	MOVL	CDBPTR,R6		; Get STATES CDB ptr
	MOVC5	#0,(SP),#0,CDB$W_BLKLEN(R6),@4(AP) ; zero collection buffer
	CLRL	PROC_COUNT		; Clear process count
	CLRL	OTHER_STATES		; Clear cnt of processes in misc states
	MOVL	SCH$GL_MAXPIX,R5	; get max number of processes

	MOVZBL	#15,W^BARSIZE		; shrink bar size for VT55
	MOVL	SCH$GL_PCBVEC,R0	; get address of PCB vector
	CLRL	R1			; clear counter
	MOVL	(R0)[R1],R2		; get address of null process PCB
	SUBL3	#4,4(AP),R3		; address to put data ( states start at one)
	MOVL	R2,R4			; copy null PCB for first time
	BRB	20$			; skip null check first time through
10$:
	MOVL	(R0)[R1],R4		; get next PCB address
	CMPL	R4,R2			; does this point to null PCB?
	BEQL	30$			; try next one if so
20$:	MOVZWL	PCB$W_STATE(R4),R4	; else get state number
	INCL	(R3)[R4]		; incr counter for that state
	INCL	PROC_COUNT		; increment total process count

;
; Check to see if the state this process is in is one of those specified
; in the SYSTEM class, and, if so, increment a counter (R10)
;

	MOVL	#1,R6			; init loop counter
	MOVAL	SYSMGR_STATES,R8	; start of SYSTEM class state list
25$:	MOVZBL	(R8)+,R9		; move state number to R9
	CMPL	R9,R4			; Compare it to the current state 
	BNEQ	27$			; branch if no match
	INCL	R10			; found a match , increment count
	BRB	30$			; Done with state check loop
27$:	AOBLEQ	R7,R6,25$ 		; continue until end of the list


30$:	AOBLEQ	R5,R1,10$		; continue until max index


;
; The total number of processes, minus the sum of processes in one of the
; states explicitly specified in the SYSTEM class, equals the number of
; processes in the OTHER category.
;

	SUBL3	R10,PROC_COUNT,OTHER_STATES

;
; Indicate to caller that FETCH collection is NOT required.
;

	MOVL	#NO,R1			; FETCH collection NOT required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return

	.SBTTL	MODES_PRE - MODES Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Fetch and store the 6 mode counters for each processor
;	(Interrupt, Kernel, Executive, Supervisor, User, Compat
;	mode tick counters). Also, compute and store null time
;	on each processor. Then adjust Primary Kernel and Secondary
;	Interrupt times to remove the idle ticks contained in
;	those counters.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	SCH$GL_PCBVEC  - contains address of PCB vector
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with 7 (or 14, if multiprocessor)
;	mode counter values. The values are fetched directly from
;	the system, with the exception of:
;
;		Primary Kernel
;		Primary Null
;		Secondary Interrupt
;		Secondary Null
;
;	These values are calculated as follows. Pick up Secondary
;	Null from MPS$GL_NULLCPU. Re-compute Secondary Interrupt
;	by subtracting Secondary Null from it. Compute Primary Null
;	by subtracting Secondary Null from NULL PHD CPUTIM. Finally,
;	re-compute Primary Kernel by subtracting Primary Null from it. 
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	None
;--

.ENTRY	MODES_PRE, ^M<R2,R3,R4>

	CLRL	R4			; assume no Secondary null time
	MOVL	4(AP),R2		; get pointer to coll buff (data portion)
	MOVAL	G^PMS$GL_KERNEL,R3	; get ptr to Primary mode counters

;
; Load collection buffer with Primary mode counters
;

10$:
	MOVL	<4*4>(R3),(R2)+		; Interrupt
	MOVQ	(R3),(R2)+		; Kernel, Exec
	MOVQ	<2*4>(R3),(R2)+		; Supervisor, User
	MOVL	<5*4>(R3),(R2)+		; Compat
	MOVL	@SCH$GL_PCBVEC,R1	; get null pcb address
	MOVL	PCB$L_PHD(R1),R1	; get null phd address
	MOVL	PHD$L_CPUTIM(R1),(R2)	; get idle time on Primary

;
; Load collection buffer with Secondary mode counters
;

	MOVL	SPTR,R1			; load SYI pointer
	CMPB	MNR_SYI$B_MPCPUS(R1),#1	; just one processor?
	BEQL	50$			; yes -- skip Secondary processing

	ADDL3	#<7*4>,4(AP),-(SP)	; push addr of Secondary coll buff
	PUSHL	#1			; push argument count
	MOVL	SP,R1			; save arg list address
	$CMKRNL_S  W^GETSEC,(R1)	; get secondary ctrs into coll buff

	MOVL	4(AP),R2		; re-instate collection buffer ptr
	MOVL	<13*4>(R2),R4		; save Secondary null for use below

;
; Establish new BASE counters if necessary
;

	BLBC	R0,30$			; br if no need to estab new base

;
; Get pointer to Secondary counters from PREVIOUS collection buffer
;

	MOVL	CDBPTR,R1		; get MODES CDB pointer
	MOVL	CDB$A_BUFFERS(R1),R2	; get buffer block pointer
	MOVL	MBP$A_BUFFERA(R2),R3	; assume buffer A is PREVIOUS
	BBS	#CDB$V_SWAPBUF,CDB$L_FLAGS(R1),20$ ; branch if so
	MOVL	MBP$A_BUFFERB(R2),R3	; else load buffer B ptr
20$:
	ADDL2	#<MNR_CLS$K_HSIZE+<7*4>>,R3 ; point to counters

	MOVAL	W^BASE,R2		; get ptr to base counters
	MOVQ	(R3)+,(R2)+		; establish new base
	MOVQ	(R3)+,(R2)+		; ....
	MOVQ	(R3)+,(R2)+		; ....
	MOVL	(R3),(R2)		; ....

;
; Add BASE counter values to collection buffer
;

30$:
	MOVAL	W^BASE,R3		; address of BASE counters
	ADDL3	#<7*4>,4(AP),R2		; compute addr of coll buff ctrs
	MOVL	#7,R1			; load number of counters
40$:
	ADDL2	(R3)+,(R2)+		; add BASE ctr value to coll buff
	SOBGTR	R1,40$			; loop for each counter

;
; Compute Primary Kernel time and Primary Null time
;

50$:
	MOVL	4(AP),R2		; re-instate collection buffer ptr
	SUBL2	R4,<6*4>(R2)		; compute null time on Primary
	SUBL2	<6*4>(R2),<1*4>(R2)	; subtract it from Primary kernel mode

	MOVL	#NO,R1			; indicate FETCH collection NOT required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return

;++
; GETSEC - Routine to get Secondary processor mode counters
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S  GETSEC,arglist_addr
;
; INPUTS:
;
;	4(AP) - address of Secondary portion of CURRENT collection buffer
;
; OUTPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	EXE$GL_MP      - contains address of multiprocessing code
;	MPS$AL_CPUTIME - contains address of Secondary mode counters
;	MPS$GL_NULLCPU - contains count of Secondary null ticks
;	MPS$GQ_MPSTRTIM - quadword time at which MP code loaded
;	MPSTRTIM -       MPS$GQ_MPSTRTIM value at previous interval
;	MCA$A_MPADDR -   EXE$GL_MP value at previous interval
;
; IMPLICIT OUTPUTS:
;
;	Secondary portion of CURRENT collection buffer is filled
;
; ROUTINE VALUE:
;
;	R0 = YES, if loading of new BASE counters is required.
;	R0 = NO,  if loading of new BASE counters is NOT required.
;
; SIDE EFFECTS:
;
;	Must raise IPL to synchronize database access
;--

GETSEC:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	CLRQ	R5			; clear Secondary mode counter regs
	CLRQ	R7			; ....
	CLRQ	R9			; ....
	CLRL	R11			; ....

;
; Pick up all data needed from MP data structures at IPL SYNCH
;

10$:	SETIPL	30$			; Raise IPL (and lock pages in w.s.)
	MOVL	G^EXE$GL_MP,R0		; get ptr to MP code
	BEQL	20$			; br if not there
	MOVL	MPS$GL_NULLCPU(R0),R11	; get Secondary null time
	MOVAB	MPS$AL_CPUTIME(R0),R4	; get ptr to Secondary mode counters

;
; Get Secondary mode counters
;

	MOVL	<4*4>(R4),R5		; Interrupt
	MOVQ	(R4),R6			; Kernel, Exec
	MOVQ	<2*4>(R4),R8		; Supervisor, User
	MOVL	<5*4>(R4),R10		; Compat

	MOVQ	MPS$GQ_MPSTRTIM(R0),R2	; get MP start time

20$:	SETIPL	#0			; lower IPL
	BRB	40$			; branch around data

30$:	.LONG	IPL$_SYNCH
	ASSUME	.-10$  LE  512		; Make sure it doesn't exceed two pages

;
; Move counter registers into CURRENT collection buffer
;

40$:
	SUBL2	R11,R5			; compute Secondary interrupt time
					; (by subtracting out null time)
	MOVL	4(AP),R4		; get addr of Secondary coll buff
	MOVQ	R5,(R4)+		; move in the counter values
	MOVQ	R7,(R4)+		; ....
	MOVQ	R9,(R4)+		; ....
	MOVL	R11,(R4)		; ....

;
; Determine if new BASE counters have to be established
;

	MOVL	MCAPTR,R1		; get MCA pointer
	TSTL	MCA$A_MPADDR(R1)	; was MP running at last interval?
	BEQL	60$			; no -- don't need new BASE
	MOVL	R0,MCA$A_MPADDR(R1)	; save MP addr for this interval
	BEQL	50$			; if 0 now, need new BASE
	CMPL	W^MPSTRTIM+4,R3		; has MP start time changed?
	BNEQU	50$			; yes -- need new BASE
	CMPL	W^MPSTRTIM,R2		; check the other half of time
	BEQLU	60$			; no change -- don't need new base
50$:
	MOVL	#YES,R0			; indicate new BASE ctr values needed
	BRB	70$			; go return
60$:
	MOVL	R0,MCA$A_MPADDR(R1)	; save MP addr for this interval
	MOVL	#NO,R0			; indicate new BASE values not needed
70$:
	MOVQ	R2,W^MPSTRTIM		; save new MP start time
	RET

	.SBTTL	PROC_PRE - PROCESSES Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Loop through all PCBs and collect information on each
;	process, as well as the process count. The info is stored
;	in the collection buffer passed to this rtn by the FETCH rtn.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each process.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	PROC_PRE, ^M<>

	$CMKRNL_S B^SCANPROCS,(AP)	; Scan all processes in kernel mode

;
; Indicate to caller that FETCH collection is NOT required.
;

	MOVL	#NO,R1			; FETCH collection NOT required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; Return

;++
; SCANPROCS - subroutine to scan processes in kernel mode
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SCANPROCS,(AP)
;
; IMPLICIT INPUTS:
;
;	SCH$GL_PCBVEC - contains address of PCB vector
;	SCH$GL_MAXPIX - maximum process index
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each process.
;
; SIDE EFFECTS:
;
;	Some of this routine is executed at IPL SYNCH to synchronize
;	the use of the PCB Vector and the PHD for each process.
;--

SCANPROCS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Register save mask

	ADDL3	#MNR_PRO$K_PSIZE,4(AP),R4 ; Point past the prefix to ...
					; ... beginning of data blocks
	CLRL	R5			; Clear process counter
	MOVL	SCH$GL_PCBVEC,R2	; Point to top of PCB vector
	MOVL	(R2),R0			; Get NULL PCB address
	MOVL	PCB$L_PID(R0),R7	; ... and its PID
	MOVL	R0,R6			; Remember NULL PCB address
	CLRL	R3			; Clear current pix
	BRB	30$			; Jump into loop to collect the NULL process

10$:
	SETIPL	80$			; Synchronize use of PCB vector
	MOVL	(R2)[R3],R0		; Get next PCB address
	MOVL	PCB$L_PID(R0),R7	; ... and its PID
	SETIPL	#0			; Back to IPL 0

	CMPL	R6,R0			; Is this an empty slot (= NULL PCB)?
	BNEQ	30$			; No -- go collect it
	BRW	70$			; Yes -- skip collection

30$:
	MOVL	PCB$L_PID(R0),	    MNR_PRO$L_IPID(R4)		; Move PCB items
	MOVL	PCB$L_UIC(R0),	    MNR_PRO$L_UIC(R4)		; ... into
	MOVW	PCB$W_STATE(R0),    MNR_PRO$W_STATE(R4)		; ... collection
	MOVB	PCB$B_PRI(R0),	    MNR_PRO$B_PRI(R4)		; ... buffer
	MOVQ	PCB$T_LNAME(R0),    MNR_PRO$O_LNAME(R4)		; 1st half of p name cstring
	MOVQ	PCB$T_LNAME+8(R0),  MNR_PRO$O_LNAME+8(R4)	; ... second half
	MOVW	PCB$W_GPGCNT(R0),   MNR_PRO$W_GPGCNT(R4)	;
	MOVW	PCB$W_PPGCNT(R0),   MNR_PRO$W_PPGCNT(R4)	;
	MOVL	PCB$L_EPID(R0),	    MNR_PRO$L_EPID(R4)		;
	MOVL	PCB$L_EFWM(R0),     MNR_PRO$L_EFWM(R4)		;

	SETIPL	80$			; Synchronize use of PCB vector
	MOVZWL	R7,R1			; Turn PID into PCB vector index
	MOVL	(R2)[R1],R1		; Get PCB address
	CMPL	PCB$L_PID(R1),R7	; Check to see if PID is still the same
	BEQLU	40$			; Continue if so
	SETIPL	#0			; Otherwise, return to IPL 0,
	BRB	70$			; ... and skip this process

40$:
	MOVL	PCB$L_STS(R0),R7	; Save status field while SYNCHed
	BBS	#PCB$V_RES,R7,50$	; If process resident, go after PHD info
	SETIPL	#0			; Otherwise, return to IPL 0,
	CLRQ	R8			; ... indicate no PHD statistics
	CLRQ	R10			; ...
	BRB	60$			; ... and continue

50$:
	MOVL	PCB$L_PHD(R0),R1	; Get PHD address
	MOVL	PHD$L_DIOCNT(R1),R8	; Get PHD stats while still at raised IPL
	MOVL	PHD$L_PAGEFLTS(R1),R9	; Use registers to avoid page faults
	MOVL	PHD$L_CPUTIM(R1),R10	; ...
	MOVL	PHD$L_BIOCNT(R1),R11	; ...
	SETIPL	#0			; Back to IPL 0

60$:
	MOVL	R7,MNR_PRO$L_STS(R4)	; Status field into collection buffer
	MOVL	R8,MNR_PRO$L_DIOCNT(R4)	; Four PHD fields into collection buffer
	MOVL	R9,MNR_PRO$L_PAGEFLTS(R4) ; ...
	MOVL	R10,MNR_PRO$L_CPUTIM(R4) ; ...
	MOVL	R11,MNR_PRO$L_BIOCNT(R4) ; ...

	INCL	R5			; Count this process
	ADDL2	#MNR_PRO$K_DSIZE,R4	; ... and point to next data block in buffer
					; NOTE -- OK to use the MNR_PRO$K_DSIZE
					; ... constant, since live collection

70$:
	ACBL	SCH$GL_MAXPIX,#1,R3,10$	; Loop once for each process in PCBVEC
	MOVL	4(AP),R1		; Point to prefix portion of coll buffer
	MOVL	R5,MNR_PRO$L_PCTREC(R1) ; Move # of procs this record into buffer
	MOVL	R5,MNR_PRO$L_PCTINT(R1) ; Move # of procs this interval into buffer
	RET				; Return to EXEC mode for exit

80$:	.LONG	IPL$_SYNCH
	ASSUME	.-10$  LE  512		; Make sure it doesn't exceed two pages

	.SBTTL	DISK_PRE - DISK Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Loop through entire device data base, colllecting info on
;	each disk device.The info is stored in the collection buffer
;	passed to this rtn by the FETCH rtn.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each disk.
;
; ROUTINE VALUE:
;
;	R0 = status from SCANDISKS routine
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	DISK_PRE, ^M<>

	$CMKRNL_S B^SCANDISKS,(AP)	; Scan all disk structs in kernel mode

;
; Indicate to caller that FETCH collection is NOT required.
;

	MOVL	#NO,R1			; FETCH collection NOT required
	RET				; Return with status from SCANDISKS

;++
;
; SCANDISKS - subroutine to scan disk data structures in kernel mode
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SCANDISKS,(AP)
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	SCH$LOCKR, SCH$UNLOCK - I/O Mutex lock and unlock routines.
;	IOC$SCAN_IODB         - Routine which scans the I/O data base
;				for the next device/unit.
;	SCH$GL_CURPCB	      - Current PCB.
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each disk.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or system service error status
;
; SIDE EFFECTS:
;
;	This routine holds the IO MUTEX and runs at ASTDEL IPL while
;	it is scanning the device data base.
;--

SCANDISKS:
	.WORD	^M<R2,R4,R6,R7,R8,R9,R10,R11> ; Register save mask

	ADDL3	#MNR_HOM$K_PSIZE,4(AP),R9 ; Point past the prefix to ...
					; ... beginning of data blocks
	CLRL	R8			; Clear disk counter
	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB for IOLOCKR call
	JSB	G^SCH$IOLOCKR		; Get mutex to lock I/O data base
					; NOTE -- now at IPL ASTDEL, so can
					; ... take page faults
;
; Call IOC$SCAN_IODB to get the next unit in the I/O data base.
; The unit is described by the DDB and UCB pointers in R11 and
; R10, respectively. To begin the scan, call SCAN_IODB with R11
; and R10 containing zero. It returns the first unit in the data
; base in the same registers. On subsequent calls, simply leave
; R11 and R10 alone, and SCAN_IODB will return the next unit.
; If an entire DDB is undesireable, clear R10 before calling
; and all units for that device will be skipped.
;

	CLRL	R11			; Indicate starting at beginning
	CLRL	R10			; ... of I/O data base
10$:
	JSB	G^IOC$SCAN_IODB		; Get the next unit
	BLBC	R0,100$			; Br if at end of data base

;
; Check the class of the device/unit just provided to see if we want it.
;

;
; Check entire controller (DDB) for disk class by examining the UCB.
; If the DDB class is not disk, then clear R10 and branch back to get next
; device/unit. If it is disk, simply continue.
;

	CMPB	#DC$_DISK,UCB$B_DEVCLASS(R10) ; Is the unit a disk?
	BEQL	20$			; Yes -- go check some more
	CLRL	R10			; No -- skip entire controller
	BRB	10$			; Go get next one

;
; Check for special class driver path UCB, and throw it out.
;

20$:
	BBS	#DEV$V_CDP,UCB$L_DEVCHAR2(R10),10$
					; Skip UCB if class driver path

;
; Check to see if disk is mounted, and throw out if not.
;

	BBC	#DEV$V_MNT,UCB$L_DEVCHAR(R10),10$
					; Skip UCB if not mounted

;
; R11/R10 now point to a disk DDB/UCB. Collect pertinent data.
;

	MOVB	DDB$L_ALLOCLS(R11),(R9)+ ; Collect allocation class
	MOVL	DDB$T_NAME(R11),(R9)+	; Collect the device name
	MOVW	UCB$W_UNIT(R10),(R9)+	; Collect the (binary) unit number

	MOVL	DDB$L_SB(R11),R0	; Get system block pointer
	BNEQU	30$			; Br if there is one
	CLRQ	(R9)+			; Else null node name
	BRB	40$
30$:
	MOVQ	SB$T_NODENAME(R0),(R9)+	; Collect the node name
40$:
	MOVL	UCB$L_VCB(R10),R0	; Get VCB pointer
	BNEQU	50$			; Br if there is one
	MOVL	BLANKS,(R9)+		; Else blank volume name
	MOVL	BLANKS,(R9)+		; ....
	MOVL	BLANKS,(R9)+		; ....
	BRB	60$
50$:
	MOVQ	VCB$T_VOLNAME(R0),(R9)+	; Collect the volume name
	MOVL	VCB$T_VOLNAME+8(R0),(R9)+ ; ....
60$:
	MOVL	UCB$L_OPCNT(R10),(R9)+	; Collect the operation count
	CVTWL	UCB$W_QLEN(R10),(R9)+	; Collect the queue length
	BGEQ	70$			; Br if pos or zero (as expected)
	CLRL	-4(R9)			; Clear it if negative
					; NOTE -- this is a transient condition,
					;   which clears itself on next coll'n
70$:

;
; ****JNL**** Start here.
; *** NOTE *** The following lines of code which collect the journaling
;              I/O operation count are temporarily commented out.
;

;
; Collect the journaling I/O operation count for this unit
;
;
;	CLRL	(R9)+			; Assume no journaling I/O
;	MOVL	UCB$L_VCB(R10),R0	; Get VCB pointer
;	BEQL	90$			; Br if no VCB
;	MOVL	VCB$L_JNLIOCNT(R0),-4(R9) ; Collect journaling I/O op count
;90$:
; ****JNL**** End here.
;

	INCL	R8			; Count this unit
	BRB	10$			; Go get next device/unit

;
; The entire I/O data base has been scanned. Relinquish the I/O Mutex
; and drop IPL back to 0.
;

100$:
	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB for IOUNLOCK call
	JSB	G^SCH$IOUNLOCK		; Relinquish lock on I/O data base
					; NOTE -- this rtn clobbers R0-R2
	SETIPL	#0			; Return to IPL 0

	MOVL	4(AP),R0		; Point to prefix part of coll buff
	MOVL	R8,MNR_HOM$L_ELTCT(R0)	; Save element count
	CLRL	MNR_HOM$L_RESERVED(R0)	; Clear reserved longword
	MOVL	#SS$_NORMAL,R0		; Success status
	RET				; Return with status

	.SBTTL	JDEVICE_PRE - JDEVICE Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Loop through entire device data base, colllecting info on
;	each journal device. The info is stored in the collection buffer
;	passed to this rtn by the FETCH rtn.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each disk.
;
; ROUTINE VALUE:
;
;	R0 = status from SCANJDEVICES routine
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	JDEVICE_PRE, ^M<>

	$CMKRNL_S B^SCANJDEVICES,(AP)	; Scan all jdevice structs in kernel mode

;
; Indicate to caller that FETCH collection is NOT required.
;

	MOVL	#NO,R1			; FETCH collection NOT required
	RET				; Return with status from SCANJDEVICES

;++
; SCANJDEVICES - subroutine to jdevice data structures in kernel mode
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SCANJDEVICES,(AP)
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	SCH$LOCKR, SCH$UNLOCK - I/O Mutex lock and unlock routines.
;	IOC$SCAN_IODB         - Routine which scans the I/O data base
;				for the next device/unit.
;	SCH$GL_CURPCB	      - Current PCB.
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each journal device.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or system service error status
;
; SIDE EFFECTS:
;
;	This routine holds the IO MUTEX and runs at ASTDEL IPL while
;	it is scanning the device data base. When scanning the various
;	journal device IRP queues, IPL is raised to FORK and lowered
;	for each queue.
;--

SCANJDEVICES:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Register save mask

;
; Lock a code segment of this routine in the working set
; in anticipation of elevating to fork IPL.
;

	ALLOC	8,R0,R3			; Get longword pair for $LKWSET
	MOVAL	55$,(R3)		; Load addr of first byte to be locked
	MOVAL	115$,4(R3)		; ... and last byte
	$LKWSET_S  INADR=(R3)		; Lock code into working set
	BLBS	R0,5$			; Continue if OK
	BRW	210$			; Else go exit if error
5$:
	ADDL3	#MNR_HOM$K_PSIZE,4(AP),R9 ; Point past the prefix to ...
					; ... beginning of data blocks
	CLRL	R8			; Clear jdevice counter
	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB for IOLOCKR call
	JSB	G^SCH$IOLOCKR		; Get mutex to lock I/O data base
					; NOTE -- now at IPL ASTDEL, so can
					; ... take page faults
;
; Call IOC$SCAN_IODB to get the next unit in the I/O data base.
; The unit is described by the DDB and UCB pointers in R11 and
; R10, respectively. To begin the scan, call SCAN_IODB with R11
; and R10 containing zero. It returns the first unit in the data
; base in the same registers. On subsequent calls, simply leave
; R11 and R10 alone, and SCAN_IODB will return the next unit.
; If an entire DDB is undesireable, clear R10 before calling
; and all units for that device will be skipped.
;

	CLRL	R11			; Indicate starting at beginning
	CLRL	R10			; ... of I/O data base
10$:	JSB	G^IOC$SCAN_IODB		; Get the next unit
	BLBS	R0,20$			; Branch if we got a unit
	BRW	200$			; Branch if at end of data base

;
; Check the class of the device/unit just provided to see if we want it.
;

;
; Check entire controller (DDB) for jdevice class by examining the UCB.
; If the DDB class is not jdevice, then clear R10 and branch back to get next
; device/unit. If it is jdevice, simply continue.
;

20$:	CMPB	#DC$_JOURNAL,-		; Is the unit a journal device?
		UCB$B_DEVCLASS(R10)	;
	BEQL	30$			; Yes, check if it is a template UCB
	CLRL	R10			; No, skip entire controller
	BRB	10$			; Get first unit on next controller

;
; Check if this is a template UCB (templates are always unit 0).
; Template UCBs will not be displayed since they are only used for
; cloning purposes and contain no useful information.
;

30$:	TSTW	UCB$W_UNIT(R10)		; Is this a template UCB?
	BEQL	10$			; Yes, get next UCB
					; No, treat it as a normal UCB

;
; R11/R10 now point to a relevant journal DDB/UCB.  Collect pertinent data.
;

	MOVL	DDB$L_SB(R11),R0	; Get system block pointer
	BEQL	40$			; Br if none
	CMPL	R0,#SCS$GA_LOCALSB	; Disk on the local system?
	BEQL	40$			; Yes -- skip node name
	MOVQ	SB$T_NODENAME(R0),(R9)+	; Collect the node name
	BRB	50$			; Get device name
40$:
	CLRQ	(R9)+			; Null node name
50$:
	MOVL	DDB$T_NAME(R11),(R9)+	; Collect the device name
	MOVW	UCB$W_UNIT(R10),(R9)+	; Collect the (binary) unit number
	MOVL	UCB$L_JNL_WRCNT(R10),-	; Collect the journal write count
		(R9)+	
	MOVL	UCB$L_JNL_BWCNT(R10),-	; Collect the journal buffer
		(R9)+			;  write count

55$:					; Beginning of locked section
	MOVZBL	UCB$B_FIPL(R10),R0	; Get fork IPL

;
; Sum the number of entries in the journal UCB's normal queue into R7.
;

	CLRL	R7			; Clear queue entry counter
	DSBINT	R0			; Elevate to fork IPL to access IRPs
	MOVAL	UCB$L_FQFL(R10),R5	; Get address of normal queue header
	CMPL	UCB$L_FQFL(R10),R5	; Is the queue empty?
	BEQL	70$			; Yes, go store count
	MOVL	R5,R6			; No, copy the queue header
60$:	INCL	R7			; Count this as a queue entry
	MOVL	IRP$L_IOQFL(R6),R6	; Point to next possible entry
	CMPL	IRP$L_IOQFL(R6),R5	; Is there another entry?
	BNEQ	60$			; Yes, go look for another entry
					; No, we're done 
70$:	ENBINT				; Back to IPL$_ASTDEL for coll buff ref
	MOVL	R7,(R9)+		; Collect the sum of the queue entries

;
; Sum the number of entries in the journal UCB's wait queue into R7.
;

	CLRL	R7			; Clear queue entry counter
	DSBINT	R0			; Elevate to fork IPL to access IRPs
	MOVAL	UCB$L_JNL_WQFL(R10),R5	; Get address of wait queue header
	CMPL	UCB$L_JNL_WQFL(R10),R5	; Is the queue empty?
	BEQL	90$			; Yes, go store count
	MOVL	R5,R6			; No, copy the queue header
80$:	INCL	R7			; Count this as a queue entry
	MOVL	IRP$L_IOQFL(R6),R6	; Point to next possible entry
	CMPL	IRP$L_IOQFL(R6),R5	; Is there another entry?
	BNEQ	80$			; Yes, go look for another entry
					; No, we're done 
90$:	ENBINT				; Back to IPL$_ASTDEL for coll buff ref
	MOVL	R7,(R9)+		; Collect the sum of the queue entries

;
; Sum the number of entries in the journal UCB's force queue into R7.
;

	CLRL	R7			; Clear queue entry counter
	DSBINT	R0			; Elevate to fork IPL to access IRPs
	MOVAL	UCB$L_JNL_FQFL(R10),R5	; Get address of force queue header
	CMPL	UCB$L_JNL_FQFL(R10),R5	; Is the queue empty?
	BEQL	110$			; Yes, go store count
	MOVL	R5,R6			; No, copy the queue header
100$:	INCL	R7			; Count this as a queue entry
	MOVL	IRP$L_IOQFL(R6),R6	; Point to next possible entry
	CMPL	IRP$L_IOQFL(R6),R5	; Is there another entry?
	BNEQ	100$			; Yes, go look for another entry
					; No, we're done
110$:	ENBINT				; Return to IPL$_ASTDEL
115$:					; End of locked section

	MOVL	R7,(R9)+		; Collect the sum of the queue entries
	MOVL	UCB$L_JNL_EXCNT(R10),-	; Collect the extend rate
		(R9)+			;
	INCL	R8			; Count this unit
	BRW	10$			; Go get next device/unit

;
; The entire I/O data base has been scanned.  Relinquish the I/O Mutex
; and drop IPL back to 0.
;

200$:	MOVL	G^SCH$GL_CURPCB,R4	; Get PCB for IOUNLOCK call
	JSB	G^SCH$IOUNLOCK		; Relinquish lock on I/O data base
					; NOTE -- this rtn clobbers R0-R2
	SETIPL	#0			; Return to IPL 0

	MOVL	4(AP),R0		; Point to prefix part of coll buff
	MOVL	R8,MNR_HOM$L_ELTCT(R0)	; Save element count
	CLRL	MNR_HOM$L_RESERVED(R0)	; Clear reserved longword
	$ULWSET_S  INADR=(R3)		; Unlock code from working set
210$:
	RET				; Return with status



	.SBTTL	SCS_PRE - SCS Class Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Loop through SCS data base, collecting info on each node.
;	The info is stored in the collection buffer passed to this 
;	rtn by the FETCH rtn.  System blocks for UDAs are discarded.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each node.
;
; ROUTINE VALUE:
;
;	R0 = status from SCANSCS routine
;	R1 = NO, since subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--

.ENTRY	SCS_PRE, ^M<>

	$CMKRNL_S B^SCANSCS,(AP)	; Scan all SCS structs in kernel mode

;
; Indicate to caller that FETCH collection is NOT required.
;

	MOVL	#NO,R1			; FETCH collection NOT required
	RET				; Return

;++
; SCANSCS - subroutine to SCS data structures in kernel mode
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SCANSCS,(AP)
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with data for each node.
;
; SIDE EFFECTS:
;
;	This routine runs at SCS IPL while it is scanning the SCS data base. 
;--

SCANSCS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Register save mask

;
; Lock the  entire collection buffer down, point R9 to the data portion of
; the collection buffer, and clear the node counter (R8).  If there are
; few nodes, locking down the entire collection buffer may not be necessary.
;

	ALLOC	8,R0,R11		; Get longword pair for $LKWSET
	MOVL	CDBPTR,R10		; Get SCS class pointer
	MOVZWL	CDB$W_BLKLEN(R10),R10	; Calculate the ending address of
	MULL2	#MAXELTS,R10		;  the entire homogenous buffer
	ADDL2	#MNR_HOM$K_PSIZE,R10	;  to be used in the second 
	ADDL2	4(AP),R10		;  longword of the $LKWSET pair
	MOVL	4(AP),(R11)		; Load addr of first byte to be locked
	MOVL	R10,4(R11)		; ... and last byte
	$LKWSET_S  INADR=(R11)		; Lock collection buffer into Wkset
	BLBS	R0,10$			; Continue if OK
	BRW	250$			; Else go exit if error
10$:	ADDL3	#MNR_HOM$K_PSIZE,-	; Point past the prefix to ...
    		4(AP),R9 		; ... beginning of data blocks
	CLRL	R8			; Clear SCS node counter


;++
; The collection buffer has been locked down, now sum all the counters in the
; CDT's for a given node (non-UDA system block) into the collection buffer.
;
; SCS$GQ_CONFIG                    SB:  System Block
;    |                             PB:  Path Block
;    ----------> +-----+           CDT: Connection Descriptor Table
;                | SB  |
;                |head |
;                +-----+
;                  ||
;                +-----+     +-----+            +-----+
;                | SB  |=====| PB  |=====  =====| PB  |
;                |     |     |     |            |     |
;                +-----+     +-----+            +-----+
;                  ||                              |
;                  ||                           +-----+
;                  ||                           | CDT |
;                                               |     |
;                  ||                           +-----+
;                  ||                              |
;                  ||                              
;                  ||                              |
;                +-----+                        +-----+
;                | SB  |                        | CDT |
;                |     |                        |     |
;                +-----+                        +-----+
;--

20$:	DSBINT	300$			; Raise to SCS IPL
	MOVAL	G^SCS$GQ_CONFIG,R10	; Get the address of the system blk hdr
30$:	MOVL	SB$L_FLINK(R10),R10	; Get the next system block
	CMPL	R10,#SCS$GQ_CONFIG	; All system blocks done?
	BNEQ	40$			; No, check if it is a UDA system block
	BRW	200$			; Yes, finish up call
40$:	TSTB	SB$T_SWTYPE(R10)	; Is it a UDA?
	BEQL	30$			; Yes, get next system block

;
; The system block was for a remote node.  Clear all of the SCS counters
;

50$:	MOVC5	#00, -			; Zero out the data area for this 
		MNR_SCS$L_DGSENT(R9), -	;  node in the collection buffer
		#00, -			; 
		#<MNR_SCS$C_CBWORK-MNR_SCS$L_DGSENT>, - ; 
		MNR_SCS$L_DGSENT(R9)	; 
	MOVAL	SB$L_PBFL(R10),R5	; Save address of path block listhead
	MOVL	SB$L_PBFL(R10),R6	; Get the address of 1st path block
60$:	CMPL	R6,R5			; Any more path blocks?
	BEQL	110$			; No, get next system block
70$:	MOVL	PB$L_CDTLST(R6),R7	; Yes, get 1st connection desc. table
	BEQL	100$			; If no more CDTs, get next path block

;
; Sum the values from this connection descriptor table into the collection
; buffer for this system block.
;

80$:	ADDL2	CDT$L_DGSENT(R7),-	; Sum # application DGs sent
		MNR_SCS$L_DGSENT(R9)	; 
					; 
	ADDL2	CDT$L_DGRCVD(R7),-	; Sum # application DGs received
		MNR_SCS$L_DGRCVD(R9)	; 
					; 
	ADDL2	CDT$L_DGDISCARD(R7),-	; Sum # application DGs discarded
		MNR_SCS$L_DGDISCARD(R9)	; 
					; 
	ADDL2	CDT$L_MSGSENT(R7),-	; Sum # application msgs sent
		MNR_SCS$L_MSGSENT(R9)	; 
					; 
	ADDL2	CDT$L_MSGRCVD(R7),-	; Sum # application msgs received
		MNR_SCS$L_MSGRCVD(R9)	; 
					; 
	ADDL2	CDT$L_SNDDATS(R7),-	; Sum # block send datas initiated
		MNR_SCS$L_SNDDATS(R9)	; 
					; 
	ADDL2	CDT$L_BYTSENT(R7),-	; Sum # bytes sent via send datas
		MNR_SCS$L_KBYTSENT(R9)	; 
	BCC	82$			; Byte count overflow longword?
	ADDL2	#^X00800000,-		; Yes, update Kbyte counter
		MNR_SCS$L_CBKBSENT(R9)	; 
					; 
82$:	ADDL2	CDT$L_REQDATS(R7),-	; Sum # block request datas initiated
		MNR_SCS$L_REQDATS(R9)	; 
					; 
	ADDL2	CDT$L_BYTREQD(R7),-	; Sum # bytes received via req datas
		MNR_SCS$L_KBYTREQD(R9)	; 
	BCC	84$			; Byte count overflow longword?
	ADDL2	#^X00800000,-		; Yes, update Kbyte counter
		MNR_SCS$L_CBKBREQD(R9)	; 
					; 
84$:	ADDL2	CDT$L_BYTMAPD(R7),-	; Sum # bytes mapped for block xfr
		MNR_SCS$L_KBYTMAPD(R9)	; 
	BCC	86$			; Byte count overflow longword?
	ADDL2	#^X00800000,-		; Yes, update Kbyte counter
		MNR_SCS$L_CBKBMAPD(R9)	; 
					; 
86$:	ADDW2	CDT$W_QCR_CNT(R7),-	; Sum # times conn. q'd for send credit
		MNR_SCS$L_QCR_CNT(R9)	; 
					; 
	ADDW2	CDT$W_QBDT_CNT(R7),-	; Sum # times conn. q'd for buff descr
		MNR_SCS$L_QBDT_CNT(R9)	; 
					; 
90$:	MOVL	CDT$L_CDTLST(R7),R7	; Get the next connection desc. table
	BNEQ	80$			; If another CDT, sum the CDT's counters

;
; All the CDTs have been summed for this path block.  Get the next path block.
;

100$:	MOVL	PB$L_FLINK(R6),R6	; No more, get next path block
	BRB	60$			; Check if all path blocks done

;
; There are no more path blocks for this system block, thus no more CDTs.
; The counters were summed into the collection buffer, so just the node
; name is left to be placed in the collection buffer.  The byte counts
; that were stored in the collection buffer are converted to Kbytes.
;

110$:	INCL	R8			; Increment node (system block) counter
	MOVQ	SB$T_NODENAME(R10),-	; Collect the node name
		MNR_SCS$Q_NODENAME(R9)	;  for this system block
	EXTZV	#10,#22,-		; Convert # bytes sent via send datas
		MNR_SCS$L_KBYTSENT(R9),-;  to Kbytes
		MNR_SCS$L_KBYTSENT(R9)	; 
	ADDL2	MNR_SCS$L_CBKBSENT(R9),-; Add in any Kbytes from 
		MNR_SCS$L_KBYTSENT(R9)	;  BYTSENT longword overflow
	EXTZV	#10,#22,-		; Convert # bytes sent via request
		MNR_SCS$L_KBYTREQD(R9),-;  datas to Kbytes
		MNR_SCS$L_KBYTREQD(R9)	; 
	ADDL2	MNR_SCS$L_CBKBREQD(R9),-; Add in any Kbytes from 
		MNR_SCS$L_KBYTREQD(R9)	;  BYTREQD longword overflow
	EXTZV	#10,#22,-		; Convert # bytes sent via mapped
		MNR_SCS$L_KBYTMAPD(R9),-;  transfer to Kbytes
		MNR_SCS$L_KBYTMAPD(R9)	; 
	ADDL2	MNR_SCS$L_CBKBMAPD(R9),-; Add in any Kbytes from 
		MNR_SCS$L_KBYTMAPD(R9)	;  BYTMAPD longword overflow
	ADDL2	#MNR_SCS$C_CBLENGTH,R9	; Point to coll. buff. space for next SB
	BRW	30$			; Look for the next system block

;
; The entire SCS data base has been scanned.  Drop IPL back to 0,
; unlock the collection buffer, and return.
;

200$:	ENBINT				; Back to IPL 0
	MOVL	4(AP),R0		; Point to prefix part of coll buff
	MOVL	R8,MNR_HOM$L_ELTCT(R0)	; Save element count
	CLRL	MNR_HOM$L_RESERVED(R0)	; Clear reserved longword
	$ULWSET_S  INADR=(R11)		; Unlock code from working set
250$:	RET				; Return

300$:	.LONG	IPL$_SCS
	ASSUME	.-20$  LE  512		; Make sure it doesn't exceed two pages


	.SBTTL	FSCACHE_PRE - File System Cache Pre-collection Rtn
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Store the total of hits + misses in the appropriate global locations
;	for each file system cache, later to be moved into the collection buffer
;	by the FETCH routine.
;
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	4(AP) - address of current collection buffer (data portion)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Global locations filled with (hits + misses) for each cache.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
;	R1 = YES, if subsequent FETCH collection is required.
;	R1 = NO,  if subsequent FETCH collection is NOT required.
;
; SIDE EFFECTS:
;
;	none
;--
.ENTRY	FSCACHE_PRE, ^M<>

	ADDL3	PMS$GL_FILHDR_HIT,PMS$GL_FILHDR_MISS,-
		FILHDR_TRIES		;save sum of hits + misses
	ADDL3	PMS$GL_FIDHIT,PMS$GL_FIDMISS,-
		FID_TRIES		;save sum of hits + misses
	ADDL3	PMS$GL_DIRHIT,PMS$GL_DIRMISS,-
		DIRFCB_TRIES		;save sum of hits + misses
	ADDL3	PMS$GL_DIRDATA_HIT,PMS$GL_DIRDATA_MISS,-
		DIRDATA_TRIES		;save sum of hits + misses
	ADDL3	PMS$GL_EXTHIT,PMS$GL_EXTMISS,-
		EXT_TRIES		;save sum of hits + misses
	ADDL3	PMS$GL_QUOHIT,PMS$GL_QUOMISS,-
		QUO_TRIES		;save sum of hits + misses
	ADDL3	PMS$GL_STORAGMAP_HIT,PMS$GL_STORAGMAP_MISS,-
		STORAGMAP_TRIES		;save sum of hits + misses
;
; Indicate to caller that FETCH collection IS required.
;
	MOVL	#YES,R1			; FETCH collection required
	MOVL	#SS$_NORMAL,R0		; success status
	RET				; return
.END
