MODULE RSTACCESS (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	June, 1980.
!
! MODULE FUNCTION
!	This module contains most of the Symbol Table Access routines (except
!	for the type routines in module RSTTYPES) that the language-specific
!	routines call to look up symbols in the Debug Symbol Table and to
!	extract symbol table information about those symbols.
!
! MODIFIED BY
!	Ping Sager
!	Rich Title
!	Vicki Holt
!	Walter Carrell III
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$ADDRESS_STRING,			! Returns ASCII encoding of an address
    DBG$BUILD_INVOC_RST,		! Build Invocation Number RST Entry
    DBG$GET_OUTER_REC_ADDRESS,		! Get the outer record's start address from the primary
					! pointed to by DBG$GL_CURRENT_PRIMARY
    DBG$GET_INNER_REC_ADDRESS,		! Get the inner record's start address from the primary
					! pointed to by DBG$GL_CURRENT_PRIMARY
    DBG$IS_IT_ENTRY,			! See if an address is an entry point
    DBG$RST_SHOWSCOPE:	NOVALUE,	! Handle the SHOW SCOPE command
    DBG$RST_TEMP_RELEASE: NOVALUE,	! Release all temporary RST entries
					!      which are not locked
    DBG$STA_ADDRESS_TO_REGDESCR,	! Converts an absolute address to a
					!      Register Descriptor (or zero)
    DBG$STA_GETSOURCEMOD,		! Get Module RST pointer to use for
					!      source line display
    DBG$STA_GETSYMBOL:	NOVALUE,	! Convert pathname to a symbol
    DBG$STA_GETSYMOFF,			! Convert address to symbol and offset
    DBG$STA_LINE_NUM_RST,		! Build a Line Number RST Entry
    DBG$STA_LOCK_SYMID:	NOVALUE,	! Lock an RST entry in RST memory
    DBG$STA_LOOKUP_GBL,			! Look up a symbol in the image's Global
					!      Symbol Table (the GST)
    DBG$STA_NOEVALBIT,			! See if the NOEVAL bit is set in a
					!      symbol's value spec.
    DBG$STA_NUMBERED_SCOPE: NOVALUE,	! Find "numbered" scope from PC in stack
    DBG$STA_RECORD_COMPONENT,		! Returns SYMID of N-th record component
    DBG$STA_RECORD_INDEX,		! Returns index of a record component
    DBG$STA_REGISTER_NAME,		! Generates print name for a register
    DBG$STA_SAME_DST_OBJECT,		! See if two SYMIDs refer to same DST
    DBG$STA_SETCONTEXT:	NOVALUE,	! Set up context for value evaluation
    DBG$STA_SETREGISTERS: NOVALUE,	! Set register values back in save areas
    DBG$STA_SYM_IS_LITERAL,		! See if symbol is a literal value
    DBG$STA_SYMKIND:	NOVALUE,	! Get a symbol's kind
    DBG$STA_SYMNAME:	NOVALUE,	! Get a symbol's name
    DBG$STA_SYMPARENT,			! Get parent SYMID for a data component
    DBG$STA_SYMPATHNAME: NOVALUE,	! Get a symbol's full pathname
    DBG$STA_SYMVALUE:	NOVALUE,	! Get a symbol's value or address
    DBG$STA_UNLOCK_SYMID: NOVALUE,	! Unlock an RST entry lock in RST memory
    DBG$STA_VALSPEC:	NOVALUE,	! Evaluate a DST Value Spec
    DBG$STA_VARIANT_SELECT,		! Return variant entry given tag value
    DBG$STA_VARIANT_VALUE,		! See if tag variable value matches a
					!      specified record variant
    DBG$TEST_ROUTINE_CALL,		! Routine to be called for testing stack machine routine calls
    DBG$TRANS_TO_REGNAME,		! Translates address of register
    ADD_TO_REF_COUNT:	NOVALUE,	! Increment or decrement RST entry ref-
					!      erence count
    CHECK_DUPLICATE,			! Check for duplicate RST Entry
    EVAL_MAT_SPEC:	NOVALUE,	! Evaluate a Materialization Spec
    FOLLOW_STATIC_LINK,			! Follow static links through call stack
					!      for up-level addressing
    GET_RECORD_ADDRESS,			! Get a record start address
    GET_REGISTER_SYMID,			! Returns SYMID or 0 for register name
    GET_REGISTER_VALUES: NOVALUE,	! Get register values from the current
					!      CALL frame
    SCOPE_RULE_COBOL,			! Select candidate symbol using COBOL
					!      scope rules
    SCOPE_RULE_NORMAL,			! Select candidate symbol using "normal"
					!      scope rules
    SCOPE_RULE_PLI,			! Select candidate symbol using PL/I
					!      scope rules
    SETCONTEXT_ERROR_HANDLER,		! Error handler for DBG$STA_SETCONTEXT
    STACK_MACHINE: NOVALUE,		! Value Spec stack machine interpreter
    VALSPEC_ERROR_HANDLER,		! Error handler for DBG$STA_VALSPEC
    VALSPEC_SCOPE_ERROR: NOVALUE,	! Value Spec scope error routine
    VALSPEC_ROUT_CALL:	NOVALUE,	! Do routine call on a compiler-supplied
					!      routine for Value Spec evaluation
    VALSPEC_ROUT_CALL_HANDLER;		! A handler to catch the abnormal
    					!      status for VALSPEC_ROUT_CALL

EXTERNAL ROUTINE
    DBG$COPY_MEMORY,			! Create a new copy of a memory block
    DBG$GET_DST_NAME,			! Get the ASCII name from a DST record
    DBG$GET_MEMORY,			! Get a permanent memory block
    DBG$GET_TEMPMEM,			! Get a "temporary" memory block
    DBG$HASH_FIND,			! Find a name in the RST hash table
    DBG$HASH_FIND_SETUP:NOVALUE,	! Set up calls on HASH_FIND routine
    DBG$HASH_INSERT:	NOVALUE,	! Insert an RST entry in hash table
    DBG$LINE_TO_PC_LOOKUP,		! Look up the PC for a given line number
    DBG$NCOPY_DESC,			! Copy a primary descriptor
    DBG$NEWLINE: NOVALUE,		! Flush current print line
    DBG$NGET_RADIX,			! Returns present radix
    DBG$NPATHDESC_TO_CS:NOVALUE,	! Generate pathname ASCII string from a
					!      pathname descriptor
    DBG$PC_TO_LINE_LOOKUP,		! Look up a line number given a PC addr
    DBG$PRIM_TO_VAL,			! Convert a primary to a value
    DBG$PRINT: NOVALUE,			! Print some ASCII text
    DBG$PRINT_CONTROL,			! Set up print controls
    DBG$REL_MEMORY:	NOVALUE,	! Release a memory block to memory pool
    DBG$RST_BUILD:	NOVALUE,	! Build the RST for a specified module
    DBG$RST_MOST_RECENT:NOVALUE,	! Mark a module as being the Most
					!      Recently Referenced module
    DBG$SEARCH_GLOBAL,			! Tries to symbolize virtual address by
    					!      searching global symbol chain
    DBG$SEARCH_SAT,			! Tries to symbolize virtual address by
					!      searching SAT.
    DBG$SEARCH_VAX_CALL_STACK,		! Tries to symbolize virtual address by
					!      searching through call stack.
    DBG$STA_SYMTYPE :   NOVALUE,	! Get TYPE of Data Item
    DBG$STA_TYP_ARRAY : NOVALUE,	! Return information about arrays
    DBG$STA_TYPEFCODE,			! Obtain fcode from SYMID
    DBG$SYMBOLIZE_REG,			! Finds symbols bound to specified register.
    SYS$FAO: ADDRESSING_MODE (ABSOLUTE);! System service for formatting output

EXTERNAL
    DBG$FINAL_HANDL,			! Call frame exception handler--used
    					!      searching for a numeric scope
    DBG$GB_MOD_PTR: REF VECTOR[,BYTE],	! Current mode setting
    DBG$GB_LANGUAGE: BYTE,		! The currently SET language code

    DBG$GB_NO_GLOBALS: BYTE,		! Number of global symbols in the GST
    DBG$GB_VERB: BYTE,			! Holds command verb
    DBG$GL_CMND_RADIX,			! Radix to use for EXAMINE
    DBG$GL_CURRENT_PRIMARY,		! Pointer to the primary being processed
    DBG$GV_CONTROL : DBG$CONTROL_FLAGS, ! DEBUG control bits
    DBG$RUNFRAME: BLOCK[,BYTE],		! The current user run frame
    DBG$PSEUDO_EXIT,			! Point to which CALL command CALL re-
					!      turns--used to find numeric scope
    DST$BEGIN_ADDR,			! Virtual address where the DST begins
    DST$END_ADDR,			! Virtual address of last byte of DST
    LRUM$MOST_RECENT,			! Pointer to the RST entry of the Most
					!      Recently Referenced module
    RST$REF_LIST: REF VECTOR[,LONG],	! Pointer to list of RST entries refer-
					!      enced by current Debug command
    RST$TEMP_LIST,			! Pointer to Temporary RST Entry List
    DBG$REG_VALUES: VECTOR[,LONG],	! Vector of user register values in the
					!      current context
    DBG$REG_VECTOR: VECTOR[,LONG],	! Vector of pointers to user register
					!      save locations in current context
    RST$SET_SCOPE,			! Set if called from DBG$RST_SETSCOPE
    RST$START_ADDR: REF RST$ENTRY,	! Pointer to first Module RST Entry
    SAT$START_ADDR,			! Address of first Static Address Table
					!      (SAT) entry on Program SAT chain
    SCOPE$LIST;				! Pointer to first Scope List entry

OWN
    DBG$REG_SCOPE: INITIAL(0),		! Numeric scope for context register
    DBG$REG_SYMID: INITIAL(0),		! SYMID used to set the current context
    DBG$SCOPE_NUMBER: INITIAL(0);	! Scope number for current context set
					!      by routine DBG$STA_SETCONTEXT


! Field definitions and declaration macro for the "candidate block" block-vector
! used by DBG$STA_GETSYMBOL and the SCOPE_RULE_xxx routines.
!
FIELD CAND_FLD_DEF =
    SET
    CAND_RSTPTR	= [ 0, L_ ],		! Pointer to symbol's RST entry
    CAND_PINDEX	= [ 1, L_ ]		! Pathname vector index + 1 for symbol
    TES;

LITERAL
    CAND_ENTSIZ	= 2;			! Longword size of a candidate entry

MACRO
    CAND_BLOCKVECTOR = BLOCKVECTOR[,CAND_ENTSIZ,LONG] FIELD(CAND_FLD_DEF) %;

LITERAL
    Outer = 1,					! Flag value for GET_RECORD_ADDRESS to return the outer record address
    Inner = 2;					! Flag value for GET_RECORD_ADDRESS to return the inner record address

!++
! This is a test DST used to test DBG$GET_OUTER_REC_ADDRESS
! and DBG$GET_INNER_REC_ADDRESS. To use it, you use the SUPER
! DEBUGGER to put the address of the test record in place of
! the address of the record you've asked for in DBG$STA_VALSPEC.
! Thus, fooling the debugger into using the test record.
!--
GLOBAL BIND
    DBG$TEST_DST = UPLIT BYTE (
	DST$K_VS_FOLLOWS,
	WORD( 11 ),
	DST$K_VS_ALLOC_DYN,
	DST$K_MS_BYTADDR,
	DST$K_MS_MECH_STK,
	0,
	DST$K_STK_PUSHIML,
	LONG(DBG$TEST_ROUTINE_CALL),
	DST$K_STK_RTNCALL,
	DST$K_STK_STOP);


GLOBAL ROUTINE DBG$ADDRESS_STRING (ADDRESS_DESC) =
!
! FUNCTION
!	This routine accepts an address descriptor and converts the contained
!	virtual address (within the address descriptor), ignoring offset, to a
!	counted ASCII string, the address of which is returned as the routine
!	value. If the address is in the Debugger's register save area, the
!	corresponding register name is returned in the counted string. Otherwise,
!	the address is returned as a numeric string in the proper radix. If a
!	register name is returned, it is preceded by the corresponding scope
!	number, for example, '2\%R5' for register R5 in the scope two call frames
!	down in the stack. For the top call frame, the scope number is zero. The
!	scope number is determined by the last call to DBG$STA_SETCONTEXT.
!
!	This routine gets the current scope number from the global symbol
!	DBG$REG_SCOPE which set up by DBG$STA_SETCONTEXT.  It also uses the
!	global symbols DBG$GB_VERB (which points to the current command being
!	processed) and DBG$GL_CMND_RADIX (the radix in effct for an EXAMINE\
!	command) to determine the appropriate radix to use.
!
! INPUTS
!	ADDRESS_DESC	- A longword containing the address of an address
!			  descriptor of a VAX virtual address.
!
! OUTPUTS
!	The address of a counted ASCII string representing the input address
!		  is returned as the routine value.
!

    BEGIN

    MAP
	ADDRESS_DESC: REF DBG$ADDRESS_DESC;  ! Pointer to input address descr.

    LOCAL
	RADIX,				! Radix to use for output
	CONTROL_DESC: BLOCK [8,BYTE],	! $FAO control block
	FAO_LENGTH: WORD,		! $FAO output length
	OUTPUT_DESC: BLOCK [8,BYTE],	! Output descriptor
	OUTPUT_BUFFER: REF VECTOR [,BYTE];  ! Output buffer



    ! Check to see if address can be resymbolized to a register.
    !
    IF DBG$TRANS_TO_REGNAME (.ADDRESS_DESC [DBG$L_ADDRESS_BYTE_ADDR], 
			     OUTPUT_BUFFER)
    THEN
	RETURN .OUTPUT_BUFFER;


    ! Register resymbolization not possible. Check to determine what radix to
    ! use and set up for FAO call.
    !
    IF .DBG$GB_VERB EQL DBG$K_EXAMINE_VERB
    THEN
    	BEGIN
	RADIX = .DBG$GL_CMND_RADIX;
    	IF .RADIX EQL DBG$K_DEFAULT
    	THEN
    	    RADIX = DBG$NGET_RADIX();
    	END
    ELSE
	RADIX = DBG$NGET_RADIX();

    CONTROL_DESC [DSC$A_POINTER] = (
	CASE .RADIX FROM DBG$K_DEFAULT TO DBG$K_HEX OF
	    SET


	    ! Octal radix.  Edit the address into ASCII octal.
	    !
	    [DBG$K_OCTAL]:
		BEGIN
		CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!OL');
		UPLIT BYTE ('!OL')
		END;


	    ! Hexadecimal radix.  Edit the address into hexadecimal.
	    !
	    [DBG$K_HEX]:
		BEGIN
		CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!XL');
		UPLIT BYTE ('!XL')
		END;


	    ! Use decimal radix for all other cases.  Edit the address into
	    ! decimal ASCII.
	    !
	    [INRANGE, OUTRANGE]:
		BEGIN
		CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!UL');
		UPLIT BYTE ('!UL')
		END;

	    TES);


    ! Get some storage for the string.
    !
    OUTPUT_BUFFER = DBG$GET_TEMPMEM(5);


    ! Call $FAO to do the formatting.
    !
    OUTPUT_DESC [DSC$W_LENGTH] = (5 * %UPVAL) - 2;
    OUTPUT_DESC [DSC$A_POINTER] = OUTPUT_BUFFER [2];
    IF NOT SYS$FAO (CONTROL_DESC,
	            FAO_LENGTH,
		    OUTPUT_DESC,
	            .ADDRESS_DESC [DBG$L_ADDRESS_BYTE_ADDR])
    THEN
	$DBG_ERROR('RSTACCESS\ADDRESS_STRING');


    ! The string is formatted, but we want to insert a leading '0' for HEX
    ! when the first character is A, B, C, D, E, or F.
    !
    IF .RADIX EQL DBG$K_HEX
    THEN
	BEGIN
	IF .OUTPUT_BUFFER [2] GTR '9'
	THEN
	    BEGIN
	    OUTPUT_BUFFER [1] = '0';
	    OUTPUT_BUFFER [0] = .FAO_LENGTH + 1;
	    RETURN OUTPUT_BUFFER [0];
	    END;

	END;


    ! Just return what $FAO formatted.
    !
    OUTPUT_BUFFER [1] = .FAO_LENGTH;
    RETURN OUTPUT_BUFFER [1];

    END;

GLOBAL ROUTINE DBG$BUILD_INVOC_RST(OLDRST, INVOCNUM) =
!
! FUNCTION
!	This routine builds an RST entry with an attached invocation number for
!	a specified symbol.  To do this, it accepts the symbol's RST entry as
!	input and creates a new copy of that RST entry.  The RST$V_INVOCNUM flag
!	is set in the new copy.  It then builds an Invocation Number RST Entry
!	to hold the actual invocation number.  The RST$L_SYMCHNPTR field in the
!	new symbol entry is set to point to the Invocation Number RST Entry.
!	Both new RST entries are added to the Temporary RST Entry List pointed
!	to by RST$TEMP_LIST.  The new symbol RST entry represents this specific
!	invocation of the new symbol, and its address is returned to the caller.
!
! INPUTS
!	OLDRST	- Pointer to the RST entry of the symbol to which an invocation
!		  number should be attached.
!
!	INVOCNUM - The desired invocation number.  This is assumed to be applied
!		  to the inner-most invocable entity (routine) in the scope in
!		  which the OLDRST symbol is declared.
!
! OUTPUTS
!	A pointer to the new symbol RST entry (which includes the invocation
!		  information) is returned as the routine value.
!

    BEGIN

    MAP
	OLDRST: REF RST$ENTRY;		! Pointer to the symbol RST entry

    OWN
	RST_SIZE_TBL:			! RST entry size look-up table indexed
		VECTOR[RST$K_KIND_MAXIMUM + 1, BYTE]	!      by entry kind
		PRESET(	[RST$K_INVALID]		= 0,
			[RST$K_NOTUNIQUE]	= 0,
			[RST$K_MODULE]		= 0,
			[RST$K_ROUTINE]		= RST$K_ROUTENTSIZ,
			[RST$K_BLOCK]		= RST$K_LEXENTSIZ,
			[RST$K_ENTRY]		= RST$K_EPTENTSIZ,
			[RST$K_LABEL]		= RST$K_LBLENTSIZ,
			[RST$K_LINE]		= RST$K_LINENTSIZ,
			[RST$K_DATA]		= RST$K_DATENTSIZ,
			[RST$K_TYPCOMP]		= RST$K_DATENTSIZ,
			[RST$K_TYPE]		= 0,
			[RST$K_VARIANT]		= 0,
			[RST$K_INVOCNUM]	= 0,
			[RST$K_OVERLOAD]	= 0);

    LOCAL
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	NEWRST: REF RST$ENTRY,		! Pointer to new copy of symbol RST
	SIZE;				! The size of this RST entry



    ! Determine the size and validity of the symbol RST entry.  We do not accept
    ! Module, Type, or Variant RST entries.
    !
    SIZE = 0;
    IF (.OLDRST[RST$B_KIND] GEQ RST$K_KIND_MINIMUM) AND
       (.OLDRST[RST$B_KIND] LEQ RST$K_KIND_MAXIMUM)
    THEN
	SIZE = .RST_SIZE_TBL[.OLDRST[RST$B_KIND]];

    IF .SIZE EQL 0 THEN $DBG_ERROR('RSTACCESS\DBG$BUILD_INVOC_RST');


    ! Copy the symbol's RST entry (the "old" RST entry) into a new memory
    ! block (the "new" RST entry).  Note that we copy the whole memory block
    ! so that any embedded DST entry is copied also.  Then fill in all fields
    ! in the new entry that must be different from those in the old entry.
    !
    NEWRST = DBG$COPY_MEMORY(.OLDRST);
    NEWRST[RST$L_HASH_BLINK] = 0;
    IF .OLDRST[RST$L_DSTPTR] EQL (.OLDRST + 4*.SIZE)
    THEN
	NEWRST[RST$L_DSTPTR] = .NEWRST + 4*.SIZE;

    NEWRST[RST$W_REFCOUNT] = 0;


    ! Put the new symbol entry on the Temporary RST Entry List.
    !
    NEWRST[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .NEWRST;


    ! Now build the Invocation Number RST Entry to go with the new symbol entry.
    ! Also put it on the Temporary RST Entry List.
    !
    INVPTR = DBG$GET_MEMORY(RST$K_INVENTSIZ);
    INVPTR[RST$L_UPSCOPEPTR] = .OLDRST;
    INVPTR[RST$B_KIND] = RST$K_INVOCNUM;
    INVPTR[RST$L_INVOCNUM] = .INVOCNUM;
    INVPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .INVPTR;


    ! Finally put a link in the symbol's new RST entry which points to the
    ! Invocation Number RST Entry.  Then return the address of the new entry.
    !
    NEWRST[RST$L_SYMCHNPTR] = .INVPTR;
    NEWRST[RST$V_INVOCNUM] = TRUE;
    RETURN .NEWRST;

    END;

GLOBAL ROUTINE DBG$GET_INNER_REC_ADDRESS( Primptr ) =
!
! FUNCTION
!	DBG$GET_INNER_REC_ADDRESS returns the address of the inner record
!	based on the primary pointer passed.
!	It's called from the stack machine when the value of a record's field 
!	depends on the contents of the record.
!
! INPUTS
!	Primptr - A pointer to a primary descriptor passed by value.
!
! OUTPUTS
!	The address of the inner record.
!
! SIDE EFFECTS
!	Errors may be signaled
!
    BEGIN

    RETURN GET_RECORD_ADDRESS( .Primptr, Inner );

    END;

GLOBAL ROUTINE DBG$GET_OUTER_REC_ADDRESS( Primptr ) =
!
! FUNCTION
!	DBG$GET_OUTER_REC_ADDRESS returns the address of the outer record
!	based on the primary pointer passed.
!	It's called from the stack machine when the value of a record's field 
!	depends on the contents of the record.
!
! INPUTS
!	Primptr - A pointer to a primary descriptor passed by value.
!
! OUTPUTS
!	The address of the outer record.
!
! SIDE EFFECTS
!	Errors may be signaled
!
    BEGIN

    RETURN GET_RECORD_ADDRESS( .Primptr, Outer );

    END;

GLOBAL ROUTINE DBG$IS_IT_ENTRY(ADDR) =
!
! FUNCTION
!	This routine decides whether a given virtual address in the user program
!	is the address of a CALL entry mask.  It returns TRUE if the given ad-
!	dress is the start address of a routine or entry point callable with the
!	CALLS and CALLG instructions.  It returns FALSE in all other cases.
!
!	This routine is called in the processing of breakpoints because if a
!	breakpoint is set on a CALL routine (as opposed to a JSB routine or an
!	ordinary code location), the BPT instruction must be placed two bytes
!	past the routine address so it falls on the first instruction instead
!	of the entry mask.
!
! INPUTS
!	ADDR	- The input address.  This routine will determine whether this
!		  address points to an entry mask or not.
!
! OUTPUTS
!	The routine returns TRUE if ADDR is the address of an entry mask, i.e.
!		  is the address of a CALLS or CALLG routine or entry point.
!		  The routine returns FALSE otherwise.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to Routine Begin DST Record
	GSTPTR: REF RST$ENTRY,		! Pointer to Global Symbol Table record
	MODRSTPTR: REF RST$ENTRY,	! Pointer to current Module RST Entry
	PROG_SATPTR: REF SAT$ENTRY,	! Pointer to Program SAT entry
	RSTPTR: REF RST$ENTRY,		! Pointer to current RST entry
	SATPTR: REF SAT$ENTRY;		! Pointer to SAT entry for a symbol



    ! Search through the Program Static Address Table.  Here we are looking for
    ! a module which covers the ADDR address.
    !
    PROG_SATPTR = .SAT$START_ADDR;
    WHILE .PROG_SATPTR NEQ 0 DO
	BEGIN


	! If the current Static Address Table entry is past the address we are
	! looking for (has a higher start address), we exit the search loop
	! without finding a suitable SAT entry.  This works because the Static
	! Address Table is sorted on the start address.
	!
	IF .PROG_SATPTR[SAT$L_START] GTRA .ADDR THEN EXITLOOP;


	! If ADDR is in the range of this SAT entry, we go to the corresponding
	! Module RST Entry and search that module's Static Address Table.
	!
	IF .PROG_SATPTR[SAT$L_END] GEQA .ADDR
	THEN
	    BEGIN


	    ! Loop through this module's SAT looking for a symbol whose address
	    ! matches the desired ADDR address.  If we find such a symbol, we
	    ! see if it is an entry point.
	    !
	    MODRSTPTR = .PROG_SATPTR[SAT$L_RSTPTR];
	    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
	    WHILE .SATPTR NEQ 0 DO
		BEGIN


		! If this SAT entry is past the desired address, exit this
		! loop--there is no symbol for the address in this module.
		! (Again, this Static Address Table is sorted on start address.)
		!
		IF .SATPTR[SAT$L_START] GTRA .ADDR THEN EXITLOOP;


		! If this SAT entry has exactly the start address we want, we
		! return TRUE if the corresponding symbol is a CALL routine,
		! an entry point, or "entry mask" data type.
		!
		IF .SATPTR[SAT$L_START] EQLA .ADDR
		THEN
		    BEGIN
		    RSTPTR = .SATPTR[SAT$L_RSTPTR];

    		    ! Check for a CALL routine.
    		    !
		    IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
		    THEN
			BEGIN
			DSTPTR = .RSTPTR[RST$L_DSTPTR];
			IF (.DSTPTR[DST$B_TYPE] EQL DST$K_RTNBEG) AND
			   (NOT .DSTPTR[DST$V_RTNBEG_NO_CALL])
			THEN
			    RETURN TRUE;

			END;

    		    ! Check for an entry point.
    		    !
		    IF .RSTPTR[RST$B_KIND] EQL RST$K_ENTRY THEN RETURN TRUE;

    		    ! Check for data of type ZEM (entry mask). This arises
    		    ! if routines are passed as parameters to other routines.
    		    ! This situation also arises when routine names are
    		    ! imported in PASCAL from environment files.
    		    !
    		    IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA
    		    THEN
    			BEGIN
    			DSTPTR = .RSTPTR[RST$L_DSTPTR];
    			IF .DSTPTR[DST$B_TYPE] EQL DSC$K_DTYPE_ZEM
    			THEN
    			    RETURN TRUE;
    			END;
		    END;


		! Loop for the next symbol SAT entry in this module.
		!
		SATPTR = .SATPTR[SAT$L_FLINK];
		END;

	    END;			! End of IF for ADDR in SAT entry range


	! Address not found in this module--loop for the next Program Static
	! Address Table entry.
	!
	PROG_SATPTR = .PROG_SATPTR[SAT$L_FLINK];
	END;


    ! A CALL routine or entry point symbol for the address could not be found
    ! anywhere in the Static Address Table or in any SET module.  We therefore
    ! have to search the Global Symbol Table to see if a symbol for the address
    ! is declared there.
    !
    GSTPTR = .RST$START_ADDR;
    WHILE TRUE DO
	BEGIN


	! Get a pointer to the next GST entry.  Exit loop if there are no more.
	!
	IF .GSTPTR EQL 0 THEN EXITLOOP;


    	! If this is a Routine or Entry GST Record for the exact address we
    	! are looking for, return TRUE -- the address is an entry point.
    	!
    	IF .GSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
    	THEN
    	    BEGIN
    	    IF .GSTPTR[RST$L_STARTADDR] EQLA .ADDR THEN RETURN TRUE;
    	    END;


    	! Get next GST entry by following the RST symbol chain pointer.
    	!
    	GSTPTR = .GSTPTR[RST$L_SYMCHNPTR];
	END;


    ! We did not find an entry or procedure definition for the address in the
    ! GST either.  It is thus not an entry point and we return FALSE.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$RST_SHOWSCOPE: NOVALUE =
!
! FUNCTION
!	This routine does most of the work of handling the SHOW SCOPE command.
!	It goes through the internal Scope List, and for each scope entry it
!	prints out the corresponding scope name.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	The SHOW SCOPE response (i.e., "scope: scope-list") is printed out.
!		  No value is returned.
!

    BEGIN

    LOCAL
	INVOCNUM,			! Invocation number for numeric scope
	MODRSTPTR,			! Return parameter not actually used
	PATHNAME,			! Pointer to Pathname Descriptor
	PATH_STRING,			! Pointer to pathname counted string
	RSTPTR,				! Pointer to scope RST entry
	SCOPE: REF SCOPE$ENTRY;		! Pointer to current scope list entry



    ! Print the initial "scope: " text.
    !
    DBG$PRINT(UPLIT BYTE(%ASCIC 'scope: '), 0);


    ! Loop through all the Scope List entries until we find the all-set-modules
    ! scope.  For each scope, print out the scope name.
    !
    SCOPE = .SCOPE$LIST;
    WHILE .SCOPE[SCOPE$L_STATE] NEQ SCOPE$K_SETMODS DO
	BEGIN


	! Print the comma between scope entries.
	!
	IF .SCOPE NEQ .SCOPE$LIST
	THEN
	    DBG$PRINT(UPLIT BYTE(%ASCIC ', '), 0);


	! Now do a CASE on the kind of Scope List entry this is.
	!
	CASE .SCOPE[SCOPE$L_STATE] FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
	    SET


	    ! Handle normal scopes as set with the SET SCOPE command.  Convert
	    ! the scope to a Pathname Descriptor; then convert that to a counted
	    ! ASCII string and print that string.
	    !
	    [SCOPE$K_NORMAL]:
		BEGIN
		DBG$STA_SYMPATHNAME(.SCOPE[SCOPE$L_RSTPTR], PATHNAME);
		DBG$NPATHDESC_TO_CS(.PATHNAME, PATH_STRING);
		DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .PATH_STRING);
		END;


	    ! Handle "numbered" scopes, i.e. scopes relative to the current top
	    ! of the call stack.  Here we first print the number itself and then
	    ! the actual scope this corresponds to at present.
	    !
	    [SCOPE$K_NUMBERED]:
		BEGIN
		DBG$PRINT(UPLIT BYTE(%ASCIC '!SL'), .SCOPE[SCOPE$L_MODPTR]);
		DBG$STA_NUMBERED_SCOPE(.SCOPE[SCOPE$L_MODPTR],
					MODRSTPTR, RSTPTR, INVOCNUM);
		IF .RSTPTR NEQ 0
		THEN
		    BEGIN
		    IF .INVOCNUM NEQ 0
		    THEN
			RSTPTR = DBG$BUILD_INVOC_RST(.RSTPTR, .INVOCNUM);

		    DBG$STA_SYMPATHNAME(.RSTPTR, PATHNAME);
		    DBG$NPATHDESC_TO_CS(.PATHNAME, PATH_STRING);
		    DBG$PRINT(UPLIT BYTE(%ASCIC ' [ = !AC ]'), .PATH_STRING);
		    END;

		END;


	    ! Handle the Global scope.  This is done by simply printing "\".
	    !
	    [SCOPE$K_GLOBAL]:
		DBG$PRINT(UPLIT BYTE(%ASCIC '\'), 0);


	    ! Handle the all SET modules scope.  Since we should never get here,
	    ! we just signal an error.
	    !
	    [SCOPE$K_SETMODS]:
		$DBG_ERROR('RSTACCESS\SHOWSCOPE');

	    TES;


	! Link on to the next Scope List entry and loop for the next scope.
	!
	SCOPE = .SCOPE[SCOPE$L_FLINK];
	END;


    ! We are all done.  Flush the output buffer and return.
    !
    DBG$NEWLINE();
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_TEMP_RELEASE: NOVALUE =
!
! FUNCTION
!	This routine releases all "temporary" RST entries back to the DEBUG
!	memory pool.  "Temporary" RST entries are RST entries which are created
!	dynamically during the execution of a DEBUG command.  These include
!	Data RST Entries for record components, RST entries for objects with
!	invocation numbers, Line Number RST Entries, and most Data Type RST
!	Entries.  RST entries which are created by the SET MODULE command or
!	during DEBUG initialization are not temporary RST entries.
!
!	When a temporary RST entry is created, it is not put on the module's
!	symbol chain or entered in the RST Hash Table.  Instead, it is added
!	to the singly linked list pointed to by RST$TEMP_LIST.  This routine
!	is called at the end of every command to go through that list and to
!	release every RST entry with a zero reference count to the DEBUG mem-
!	ory pool.  An entry with a non-zero reference count cannot be released
!	since something references that entry; the current location pseudo-
!	symbol may be bound to a Primary Descriptor which in turn points to
!	that RST entry, for example.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	OLDPTR: REF RST$ENTRY,		! Pointer to the previous RST entry in
					!      temporary RST entry list
	RSTPTR: REF RST$ENTRY;		! Pointer to the current RST entry in
					!      the temporary RST entry list



    ! Loop through the Temporary RST Entry List.  Release every entry with
    ! a zero reference count back to the memory pool.
    !
    OLDPTR = RST$TEMP_LIST;
    RSTPTR = .OLDPTR[RST$L_HASH_FLINK];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF .RSTPTR[RST$W_REFCOUNT] EQL 0
	THEN
	    BEGIN
	    OLDPTR[RST$L_HASH_FLINK] = .RSTPTR[RST$L_HASH_FLINK];
	    DBG$REL_MEMORY(.RSTPTR);
	    END

	ELSE
	    OLDPTR = .RSTPTR;

	RSTPTR = .OLDPTR[RST$L_HASH_FLINK];
	END;


    ! We are all done--return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_ADDRESS_TO_REGDESCR(ADDRESS) =
!
! FUNCTION
!	This routine determines if a given address is a register address and
!	returns a Register Descriptor if it is.  If the given address points
!	into the DBG$REG_VALUES vector, it is a register address.  The register
!	number so determined (plus a byte offset if any) and the scope number
!	of the currently set context are combined in a "Register Descriptor"
!	which is then returned to the caller.  (A Register Descriptor is always
!	non-zero.)  If the address is not a register, zero is returned to the
!	caller.
!
! INPUTS
!	ADDRESS	- The input address which should be checked for being a
!		  register address.
!
! OUTPUTS
!	If the given address is not a register address, zero is returned as the
!		  routine value.  If it is a register address, a Register
!		  Descriptor (which is always non-zero) is returned as the
!		  routine value.
!

    BEGIN

    LOCAL
	REGDESCR: DBG$REGDESCR;		! Register Descriptor that we build



    ! If the address is not a register address, return zero right away.
    !
    IF (.ADDRESS LSSA DBG$REG_VALUES[0]) OR
       (.ADDRESS GEQA DBG$REG_VALUES[17])
    THEN
	RETURN 0;


    ! The address is a register address.  Build a Register Descriptor and
    ! return it to the caller.
    !
    REGDESCR[DBG$V_REGD_SENTINEL] = %X'2D';
    REGDESCR[DBG$V_REGD_OFFSET] = (.ADDRESS - DBG$REG_VALUES[0]) AND 3;
    REGDESCR[DBG$B_REGD_REGNUM] = (.ADDRESS - DBG$REG_VALUES[0])/%UPVAL;
    REGDESCR[DBG$W_REGD_SCOPENUM] = .DBG$SCOPE_NUMBER;
    RETURN .REGDESCR;

    END;

GLOBAL ROUTINE DBG$STA_GETSOURCEMOD(MODNAMEPTR) =
!
! FUNCTION
!	This routine looks up what module should be used when displaying source
!	lines.  It accepts a pointer to a Counted ASCII module name and returns
!	a pointer to the corresponding Module RST Entry.  However, if the name
!	pointer is zero, it determines which module contains the current scope
!	(as defined by the Scope List) and returns a pointer to that module's
!	Module RST Entry.  If the module name does not exist or if no known
!	module contains the current scope, the routine returns a zero value.
!
!	This routine is called during the processing of the TYPE command to
!	determine which module to type source lines from.  It is also called
!	during the processing of the SET SOURCE/MODULE and CANCEL SOURCE/MODULE
!	commands to look up module names.  Only the TYPE command passes a zero
!	module name pointer; this happens when no module name is specified on
!	the command.
!
! INPUTS
!	MODNAMEPTR - A pointer to the Counted ASCII module name to be looked up.
!		  If the module of the current scope is to be looked up, this
!		  pointer should be zero.
!
! OUTPUTS
!	A pointer to the Module RST Entry of the module specified by MODNAMEPTR
!		  is returned as the routine value.  If the desired module could
!		  not be found (no such module name or current scope not in any
!		  known module), zero is returned as the value.
!

    BEGIN

    LOCAL
	INVOCNUM,			! Invocation number parameter
	MODRSTPTR: REF RST$ENTRY,	! Pointer to found Module RST Entry
	SCOPE,				! Scope pointer parameter
	SCOPEPTR: REF SCOPE$ENTRY;	! Pointer to current Scope List Entry



    ! If the MODNAMEPTR parameter is non-zero, we search the RST Hash Table for
    ! the Counted ASCII module name pointed to by MODNAMEPTR.
    !
    IF .MODNAMEPTR NEQ 0
    THEN
	BEGIN
	DBG$HASH_FIND_SETUP(.MODNAMEPTR);
	WHILE TRUE DO
	    BEGIN
	    MODRSTPTR = DBG$HASH_FIND(.MODNAMEPTR);
	    IF .MODRSTPTR EQL 0 THEN RETURN 0;
	    IF .MODRSTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN .MODRSTPTR;
	    END;

	END;


    ! MODNAMEPTR is zero.  We thus search the Scope List for the first scope
    ! with a known module and return a pointer to that Module RST Entry.
    !
    SCOPEPTR = .SCOPE$LIST;
    WHILE .SCOPEPTR NEQ 0 DO
	BEGIN
	CASE .SCOPEPTR[SCOPE$L_STATE] FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
	    SET


	    ! Normal scope--just return the scope's Module RST Entry pointer.
	    !
	    [SCOPE$K_NORMAL]:
		RETURN .SCOPEPTR[SCOPE$L_MODPTR];


	    ! Numbered scope--look up the corresponding lexical entity and
	    ! module in the call stack and return its Module RST Entry pointer.
	    ! If the module is not found, we continue the Scope List search.
	    !
	    [SCOPE$K_NUMBERED]:
		BEGIN
		DBG$STA_NUMBERED_SCOPE(.SCOPEPTR[SCOPE$L_MODPTR], MODRSTPTR,
							SCOPE, INVOCNUM);
		IF .MODRSTPTR NEQ 0 THEN RETURN .MODRSTPTR;
		END;


	    ! Global symbol scope--just ignore this entry and continue search.
	    !
	    [SCOPE$K_GLOBAL]:
		0;


	    ! All SET modules scope--ignore this entry and continue search.
	    !
	    [SCOPE$K_SETMODS]:
		0;

	    TES;


	! Link to the next Scope List Entry and loop.
	!
	SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
	END;


    ! No usable scope was found in the Scope List.  Return zero to the caller.
    !
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_GETSYMBOL(PATHNAME, SYMID, KIND,
    		OUT_SCOPE_STATE, OUT_SCOPE, ARRAY_FLAG,
    		TYPE_FLAG): NOVALUE =
!
! FUNCTION:
!	This routine accepts a pathname and returns the corresponding symbol.
!	The pathname, which is passed in internal format, consists of a symbolic
!	name (such as "X") or a symbolic name with pathname qualification (such
!	as "M\R\X").  It also includes any data record qualification which may
!	be present; thus "M\R\A.B.C" constitutes a pathname in this context.
!	This routine is the central routine one calls to search the Debug Symbol
!	Table (the DST) to find the symbol table entry corresponding to a given
!	symbolic name.  The search takes into account all scope rules dictated
!	by the language and the SET SCOPE and SET MODULE commands.
!
! INPUTS:
!	PATHNAME - The address of a pathname descriptor describing the symbolic
!		  name to be looked up in the DST.  A "pathname descriptor" is
!		  the internal data structure which describes an already parsed
!		  symbolic name including all pathname and data record qualifi-
!		  cation.
!
!	SYMID	- The address of a longword location where the "symbol identi-
!		  fier" should be returned.  The "symbol identifier" is a value
!		  which uniquely identifies the returned symbol.  This value is
!		  not directly understood outside the symbol table access rou-
!		  tines, but can be passed to various other symbol table access
!		  routines to extract information about the symbol.
!
!	KIND	- The address of a longword location where the "kind" of the
!		  SYMID symbol should be returned.  KIND specifies whether SYMID
!		  identifies a routine, a line, or a data item, etc.  See the
!		  OUTPUTS section below for more detail.
!
!	OUT_SCOPE_STATE - 	       If not zero, the caller wishes to have
!				       passed back to him the scope state
!				       (e.g., NORMAL, SETMODS, ...) in which
!				       the lookup succeeded.
!
!	OUT_SCOPE - 		 If not zero, the caller wishes to have passed
!				 back to him the scope in which the lookup
!				 of the symbol succeeded.
!
!	ARRAY_FLAG - 	Indicates that this symbol lookup was
!			called as part of processing a subscripted symbol.
!			This information is used in BASIC to disambiguate
!			symbol references. That is, in BASIC, you can have
!			2 symbols named X, one an array and one not, and
!			the language uses context to tell them apart.
!
!	TYPE_FLAG -	Indicates that it is OK to return a RSTPTR whose
!			kind is "TYPE".
!
! OUTPUTS:
!	SYMID	- A symbol identifier which uniquely identifies the symbol spec-
!		  ified by PATHNAME is returned to SYMID.  This symbol identi-
!		  fier can then be passed to any symbol table access routine
!		  which accepts a SYMID parameter.  If no unique symbol corre-
!		  sponding to PATHNAME can be found in the DST (given the scope
!		  rules in effect), a zero is returned to SYMID.
!
!	KIND	- The "kind" of the SYMID symbol is returned to KIND.  This is
!		  a small integer value with the following possible values:
!
!			RST$K_INVALID	-- No symbol was found (SYMID = 0)
!			RST$K_NOTUNIQUE	-- Symbol is not unique (SYMID = 0)
!			RST$K_ROUTINE	-- SYMID is a Routine
!			RST$K_BLOCK	-- SYMID is a Block
!			RST$K_ENTRY	-- SYMID is an Entry Point
!			RST$K_LABEL	-- SYMID is a Label
!			RST$K_LINE	-- SYMID is a Line
!			RST$K_DATA	-- SYMID is a Data Item
!			RST$K_TYPCOMP	-- SYMID is a Data Type Component
!
!	No value is returned by DBG$STA_GETSYMBOL.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to input pathname descriptor
	SYMID: REF VECTOR[1],		! Pointer to SYMID location
	KIND: REF VECTOR[1];		! Pointer to KIND location

    LITERAL
	MAX_STACK = 100;		! Maximum size of the symbol name stack

    FIELD STK_FLDS =			! Field definitions for SYMSTACK vector
	SET				!
	STK_RSTPTR	= [ 0, L_ ],	! RST pointer to current stack component
	STK_PINDEX	= [ 1, W0_ ],	! Pathname vector index + 1
	STK_TPINDEX	= [ 1, W1_ ]	! Next Type RST Entry ref table index
	TES;

    OWN
	CANDLST: REF VECTOR[,LONG]	! Pointer to RST entry candidate list
			INITIAL(0),	!      for the current scope
	MODU_SCOPE: SCOPE$ENTRY		! Scope list entry used for explicitly
		INITIAL(0, SCOPE$K_NORMAL, 0, 0),	! specified module scope
	NORM_SCOPE: SCOPE$ENTRY		! Scope list entry used for explicitly
		INITIAL(0, SCOPE$K_NORMAL, 0, 0),	! specified scopes
	NUMB_SCOPE: SCOPE$ENTRY		! Scope list entry used for numbered
		INITIAL (0, SCOPE$K_NUMBERED, 0, 0);	! scopes (i.e., n\X).

    LOCAL
    	ARR_FLAG,			! TRUE if symbol is subscripted
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to candidate block-vector
	DEFDEPTH,			! Definition depth of symbol in scope
	FIRST_MODPTR,			! Pointer to first module on scope list
	GOOD_CAND,			! CANDLST index of good candidate symbol
	HAVE_LINE_NUM,			! Flag set if pathname has a line number
	HAVE_NUM_SCOPE,			! Flag set if pathname has a numbered
					!      scope in first position ("0\I")
	HAVE_SCOPE,			! Flag set when we have scope to search
	IN_SCOPE,			! Flag set if symbol is in current scope
	J,				! Loop index for CANDBLK vector
	LINEEND,			! Line number end address
	LINE_LEX_PTR,			! Pointer to the inner-most lexical
					!      entity containing the line number
	LINE_NUM,			! Line number if pathname contains one
	LINE_NUM_IS_LAST,		! Flag set if there is a line number and
					!      it is last in the pathname
	LINE_NUM_LOC,			! Index of line number (if present) in
					!      pathname vector (1-based).
	LINESTART,			! Line number start address
	MODRSTPTR: REF RST$ENTRY,	! Pointer to Module RST Entry for the
					!      current scope being searched
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to RST entry symbol name as
					!      a counted ASCII string
	NCANDS,				! Number of candidate list entries
	NEWREFLIST,			! Temporary pointer to new RST Reference
					!      List memory block
	NEXTSETMOD: REF RST$ENTRY,	! Pointer to the next SET module after
					!      this one--used when searching all
					!      SET modules for a pathname match
	NUMBER,				! Used to convert line number to binary
	NUMSCP_INVOC_NUM,		! Invocation number of the current
					!      numbered scope
	OLDCAND,			! Pointer to candidate list about to be
					!      copied to a larger memory block
	PATH_NAME_PTR,			! Pointer to pathname counted ASCII
	PATH_START_LOC,			! Start location of scope in pathname
	PATHSTRING,			! Pointer to pathname counted ASCII
	PATHVEC: REF VECTOR[,LONG],	! Pointer to the pathname vector
	PINDEX,				! Index into pathname vector
	PNAME: REF VECTOR[,BYTE],	! Pointer to pathname component counted
					!      ASCII string
	REGISTER_SYMID: REF RST$ENTRY,	! SYMID for register name (such as %R5)
	REG_LINE_LEX_PTR,		! Same as LINE_LEX_PTR but for the scope
					!      in which registers are looked up
	REG_SCOPE,			! Set to TRUE if current scope is scope
					!      in which registers are looked up
	RNAME: REF VECTOR[,BYTE],	! Pointer to RST entry scope chain com-
					!      ponent's name as counted ASCII
	ROUTPTR: REF RST$ENTRY,		! Pointer to Routine RST Entry of rout-
					!      ine with invocation number
	RPTR: REF RST$ENTRY,		! Pointer to current RST entry in RSTPTR
					!      entry's up-scope chain
	RSTPTR: REF RST$ENTRY,		! Pointer to candidate RST entry
	SATPTR: REF SAT$ENTRY,		! Pointer to Static Address Table entry
	SCOPE: REF RST$ENTRY,		! Pointer to current scope's RST entry
	SCOPEPTR: REF SCOPE$ENTRY,	! Points to the current scope list entry
	SCOPE_START_PTR,		! Pointer to start of scope list actual-
					!      ly searched--used for registers
	SCOPE_STATE,			! The current state in our traversal of
					!      the scopes to be searched
	SCPTR: REF RST$ENTRY,		! Pointer used to follow current scope's
					!      up-scope chain
	SET_SCOPE,			! Set to TRUE if called by SET SCOPE
	STATUS,				! Status code returned by called routine
	STKPTR,				! Current SYMSTACK index
	STMT_NUM,			! Statement number within line number
	SYMSCOPE: REF RST$ENTRY,	! The actual scope of the current symbol
	SYMSTACK:			! Symbol name stack for name components
		BLOCKVECTOR[MAX_STACK, 2, LONG] FIELD(STK_FLDS), !
	TPINDEX,			! Index into a Type RST Entry's table of
					!      references to that type
	TPTR: REF VECTOR[,LONG],	! Pointer to the Type RST Entry refer-
					!      ence table
	VALID_LINE_FLAG;		! Flag set if line number is valid



    ! Note whether we were called by the SET scope command.
    !
    SET_SCOPE = .RST$SET_SCOPE;
    RST$SET_SCOPE = FALSE;


    ! Set up pointers to the pathname descriptor's pathname vector and the last
    ! name in the pathname vector.
    !
    PATHVEC = PATHNAME[PTH$A_PATHVECTOR];
    NAMEPTR = .PATHVEC[.PATHNAME[PTH$B_TOTCNT] - 1];


    ! See if there is any line number reference in the pathname.  If there is,
    ! extract the line and statement numbers and set the HAVE_LINE_NUM flag.
    !
    HAVE_LINE_NUM = FALSE;
    LINE_NUM_IS_LAST = FALSE;
    LINE_NUM_LOC = 0;
    VALID_LINE_FLAG = TRUE;
    INCR I FROM 1 TO .PATHNAME[PTH$B_TOTCNT] DO
	BEGIN
	PNAME = .PATHVEC[.I - 1];
	IF (.PNAME[0] GTR 6) AND
	   CH$EQL(6, PNAME[1], 6, UPLIT BYTE(%ASCII '%LINE '), 0)
	THEN
	    BEGIN
	    IF .PNAME[7] LSS '0' OR .PNAME[7] GTR '9' THEN VALID_LINE_FLAG = FALSE;
	    IF .HAVE_LINE_NUM THEN VALID_LINE_FLAG = FALSE;
	    HAVE_LINE_NUM = TRUE;
	    LINE_NUM_LOC = .I;


	    ! Loop over the line number ASCII to pick up the actual line number
	    ! and statement number.
	    !
	    LINE_NUM = -1;
	    NUMBER = 0;
	    INCR I FROM 7 TO .PNAME[0] DO
		BEGIN
		IF .PNAME[.I] EQL '.' AND .LINE_NUM EQL -1
		THEN
		    BEGIN
		    LINE_NUM = .NUMBER;
		    NUMBER = 0;
		    END

		ELSE IF (.PNAME[.I] GEQ '0') AND (.PNAME[.I] LEQ '9') AND
			(.NUMBER LEQ 1000000)
		THEN
		    NUMBER = 10*.NUMBER + (.PNAME[.I] - '0')

		ELSE
		    BEGIN
		    VALID_LINE_FLAG = FALSE;
		    EXITLOOP;
		    END;

		END;


	    ! Set LINE_NUM and STMT_NUM properly on loop exit.
	    !
	    IF .LINE_NUM EQL -1
	    THEN
		BEGIN
		LINE_NUM = .NUMBER;
		STMT_NUM = 0;
		END

	    ELSE
		STMT_NUM = .NUMBER;

	    END;

	END;				! End of line number INCR loop


    ! If we got a line number, make some additional validity checks on it.
    ! If the line number is not valid for any reason (including syntax errors),
    ! return the invalid symbol code to the caller.
    !
    IF .HAVE_LINE_NUM
    THEN
	BEGIN
	LINE_NUM_IS_LAST = .LINE_NUM_LOC EQL .PATHNAME[PTH$B_TOTCNT];
	IF (.LINE_NUM_LOC GTR .PATHNAME[PTH$B_PATHCNT])     OR
	   (.LINE_NUM_LOC LSS .PATHNAME[PTH$B_PATHCNT] - 1) OR
	   (.LINE_NUM_LOC EQL .PATHNAME[PTH$B_PATHCNT] AND NOT .LINE_NUM_IS_LAST)
	THEN
	    VALID_LINE_FLAG = FALSE;

	IF NOT .VALID_LINE_FLAG
	THEN
	    BEGIN
	    SYMID[0] = 0;
	    KIND[0] = RST$K_INVALID;
	    RETURN;
	    END;

	END;


    ! If we do not yet have a candidate list memory block, get one and initial-
    ! ize its first element to give the list size that will fit in the block.
    !
    NCANDS = 0;
    IF .CANDLST EQL 0
    THEN
	BEGIN
	CANDLST = DBG$GET_MEMORY(11);
	CANDLST[0] = 10;
	END;


    ! Set up the "scope pointer" to point to the list of scopes to be searched.
    ! If the symbol is of the form \X, we search the Global Symbol Table only,
    ! and if it is of the form n\X, we search the n-th "numbered scope" only.
    ! Otherwise, we use the normal scope list given by SCOPE$LIST.
    !
    SCOPEPTR = .SCOPE$LIST;
    HAVE_NUM_SCOPE = FALSE;
    PNAME = .PATHVEC[0];
    IF .PNAME[0] EQL 0
    THEN
	BEGIN
	IF .PATHNAME[PTH$B_LOCINVOC] EQL 0
	THEN
	    SCOPEPTR = UPLIT(0, SCOPE$K_GLOBAL, 0, 0)

	ELSE IF .PATHNAME[PTH$B_LOCINVOC] EQL 1
	THEN
	    BEGIN
	    HAVE_NUM_SCOPE = TRUE;
	    SCOPEPTR = NUMB_SCOPE;
	    SCOPEPTR[SCOPE$L_MODPTR] = .PATHNAME[PTH$L_INVOCNUM];
	    IF .PATHNAME[PTH$B_PATHCNT] LSS 2 THEN SCOPEPTR = 0;
	    END

	ELSE
	    $DBG_ERROR('RSTACCESS\GETSYMBOL');

	END


    ! If there is pathname qualification on the variable name other than the
    ! global scope or a numbered scope, we determine what scope is specified
    ! and set up a scope list entry for that scope.
    !
    ELSE IF (.PATHNAME[PTH$B_PATHCNT] GTR 1) AND (.LINE_NUM_LOC NEQ 1)
    THEN
	BEGIN
	PATH_START_LOC = .PATHNAME[PTH$B_PATHCNT] - 1;
	IF .LINE_NUM_LOC EQL .PATH_START_LOC
	THEN
	    PATH_START_LOC = .PATH_START_LOC - 1;


	! Loop over the RST Hash Table chain for this symbol name (i.e., for the
	! scope specified by the pathname).  For each such symbol, see if it
	! matches the rest of the pathname qualification.
	!
	MODU_SCOPE[SCOPE$L_RSTPTR] = 0;
	NORM_SCOPE[SCOPE$L_RSTPTR] = 0;
	PATH_NAME_PTR = .PATHVEC[.PATH_START_LOC - 1];
	DBG$HASH_FIND_SETUP(.PATH_NAME_PTR);
	WHILE TRUE DO
	    BEGIN


	    ! Get the next symbol from the hash chain.  Check for chain's end.
	    !
	    RSTPTR = DBG$HASH_FIND(.PATH_NAME_PTR);
	    IF .RSTPTR EQL 0 THEN EXITLOOP;


	    ! Scan the symbol's up-scope chain and see if it fully matches the
	    ! specified pathname qualification.  If so, this is the scope.
	    !
	    RPTR = .RSTPTR;
	    PINDEX = .PATH_START_LOC;
	    WHILE TRUE DO
		BEGIN
		IF .RSTPTR[RST$V_GLOBAL] THEN EXITLOOP;
		IF (.RSTPTR[RST$B_KIND] NEQ RST$K_MODULE)  AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK) AND
    		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPE)
		THEN
		    EXITLOOP;

		PNAME = .PATHVEC[.PINDEX - 1];
		RNAME = DBG$GET_DST_NAME(.RPTR[RST$L_DSTPTR]);
		IF CH$EQL(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0)
		THEN
		    BEGIN


		    ! If the pathname ended and everything matched so far, this
		    ! may be the desired scope.  Create a scope list entry for
		    ! it and check for uniqueness.
		    !
		    IF .PINDEX EQL 1
		    THEN
			BEGIN
			MODRSTPTR = .RSTPTR;
			WHILE .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
			    MODRSTPTR = .MODRSTPTR[RST$L_UPSCOPEPTR];

			SCOPEPTR = NORM_SCOPE;
			IF .RSTPTR EQL .MODRSTPTR THEN SCOPEPTR = MODU_SCOPE;
			IF .SCOPEPTR[SCOPE$L_RSTPTR] NEQ 0
			THEN
			    BEGIN
			    SYMID[0] = 0;
			    KIND[0] = RST$K_NOTUNIQUE;
			    RETURN;
			    END;

			SCOPEPTR[SCOPE$L_RSTPTR] = .RSTPTR;
			SCOPEPTR[SCOPE$L_MODPTR] = .MODRSTPTR;
			EXITLOOP;
			END;


		    ! Decrement the PATHVEC index and continue the search.
		    !
		    PINDEX = .PINDEX - 1;
		    END;


		! Link up-scope and continue the search.
		!
		IF .RPTR[RST$B_KIND] EQL RST$K_MODULE THEN EXITLOOP;
		RPTR = .RPTR[RST$L_UPSCOPEPTR];
		END;

	    END;			! End of WHILE loop over hash table


	! Depending on whether a normal scope or a module scope or both were
	! found to match the pathname, put the corresponding scope list entries
	! on the scope list.
	!
	SCOPEPTR = 0;
	MODU_SCOPE[SCOPE$L_FLINK] = 0;
	IF .NORM_SCOPE[SCOPE$L_RSTPTR] NEQ 0
	THEN
	    BEGIN
	    MODU_SCOPE[SCOPE$L_FLINK] = NORM_SCOPE;
	    SCOPEPTR = NORM_SCOPE;
	    END;

	IF .MODU_SCOPE[SCOPE$L_RSTPTR] NEQ 0 THEN SCOPEPTR = MODU_SCOPE;
	END;


    ! Set up NEXTSETMOD for a search through all SET modules.  Also save the
    ! scope-list start pointer so we can look up the symbol in that scope in
    ! case it happens to be register name.
    !
    NEXTSETMOD = .RST$START_ADDR;
    REG_SCOPE = FALSE;
    REG_LINE_LEX_PTR = 0;
    FIRST_MODPTR = 0;
    SCOPE_START_PTR = .SCOPEPTR;
    IF (.SCOPEPTR EQL MODU_SCOPE) AND (.MODU_SCOPE[SCOPE$L_FLINK] NEQ 0)
    THEN
	SCOPE_START_PTR = .MODU_SCOPE[SCOPE$L_FLINK];


    ! Loop through all the proper scopes, searching for a symbol which matches
    ! the specified pathname.
    !
    WHILE TRUE DO
	BEGIN


	! Loop through the scope selection code until we find a scope in which
	! to search for the specified pathname.
	!
	HAVE_SCOPE = FALSE;
	WHILE TRUE DO
	    BEGIN


	    ! If the scope list has no more entries, we have searched all scopes
	    ! on the list without finding the desired symbol.  This means that
	    ! the symbol is not in the RST so we return RST$K_INVALID as the
	    ! status.  However, we first call GET_REGISTER_SYMID to see if the
	    ! symbol could be a register name (e.g., "%R5").  If so, we return
	    ! the register SYMID built by GET_REGISTER_SYMID instead.
	    !
	    IF .SCOPEPTR EQL 0
	    THEN
		BEGIN


		! Determine whether this name could be a register name.
		!
		REGISTER_SYMID = GET_REGISTER_SYMID(.PATHNAME,
					.SCOPE_START_PTR, .REG_LINE_LEX_PTR);


		! If this is not a register name, return the invalid symbol
		! status to the caller.  Note that we also give the informa-
		! tional "no line nn" message here if a line number was speci-
		! fied which could not be found in the first scope.
		!
		IF .REGISTER_SYMID EQL 0
		THEN
		    BEGIN
		    IF .HAVE_LINE_NUM AND (.FIRST_MODPTR NEQ 0)
		    THEN
			DBG$LINE_TO_PC_LOOKUP(.LINE_NUM, .STMT_NUM,
				.FIRST_MODPTR, LINESTART, LINEEND, TRUE);

		    SYMID[0] = 0;
		    KIND[0] = RST$K_INVALID;
		    RETURN;
		    END;


		! This symbol is a register.  Return its SYMID and kind to the
		! caller.
		!
		SYMID[0] = .REGISTER_SYMID;
		KIND[0] = .REGISTER_SYMID[RST$B_KIND];


    		! Zero the output parameters saying what scope we found the
    		! symbol in - these are meaningless for registers.
    		!
    		IF .OUT_SCOPE_STATE NEQ 0
    		THEN
    		    .OUT_SCOPE_STATE = 0;
    		IF .OUT_SCOPE NEQ 0
    		THEN
    		    .OUT_SCOPE = 0;


		! Mark the register RST entry as being referenced by adding its
		! address to the RST Reference List (RST$REF_LIST).  This says
		! that the RST entry is referenced by the current Debug command.
		! Then return.
		!
		IF .RST$REF_LIST[1] EQL .RST$REF_LIST[0]
		THEN
		    BEGIN
		    RST$REF_LIST[0] = .RST$REF_LIST[0] + 20;
		    NEWREFLIST = DBG$GET_MEMORY(.RST$REF_LIST[0] + 2);
		    CH$MOVE(4*(.RST$REF_LIST[1] + 2), .RST$REF_LIST, .NEWREFLIST);
		    DBG$REL_MEMORY(.RST$REF_LIST);
		    RST$REF_LIST = .NEWREFLIST;
		    END;

		RST$REF_LIST[1] = .RST$REF_LIST[1] + 1;
		RST$REF_LIST[.RST$REF_LIST[1] + 1] = .RSTPTR;
		RETURN;
		END;


	    ! Set REG_SCOPE to TRUE if the current scope is the scope in which
	    ! a register would be looked up.
	    !
	    REG_SCOPE = .SCOPEPTR EQL .SCOPE_START_PTR;


	    ! Try to select a scope to search based on the current scope state.
	    !
	    SCOPE_STATE = .SCOPEPTR[SCOPE$L_STATE];
	    CASE .SCOPE_STATE FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
		SET


		! Search a normal, named scope as declared with a SET SCOPE
		! command.  We pick up the scope information directly from the
		! scope list entry.  Note that the scope's module must be SET;
		! otherwise the scope is not searched.
		!
		[SCOPE$K_NORMAL]:
		    BEGIN
		    SCOPE = .SCOPEPTR[SCOPE$L_RSTPTR];
		    MODRSTPTR = .SCOPEPTR[SCOPE$L_MODPTR];
		    IF .MODRSTPTR[RST$V_MODSET] THEN HAVE_SCOPE = TRUE;
		    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;


		! Search a "numbered scope", i.e. the scope where the PC is cur-
		! rently positioned N levels down in the CALL stack.  To do this
		! we look up the PC in the Static Address Table to find the con-
		! taining lexical entity.  If that succeeds (and the module is
		! SET), we use that scope.
		!
		[SCOPE$K_NUMBERED]:
		    BEGIN
		    DBG$STA_NUMBERED_SCOPE(.SCOPEPTR[SCOPE$L_MODPTR],
					MODRSTPTR, SCOPE, NUMSCP_INVOC_NUM);
		    IF .SCOPE NEQ 0 THEN HAVE_SCOPE = TRUE;
		    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;


		! Search the Global Symbol Table (GST) for the symbol.  We do
		! this only if the symbol is of the form "X" or "\X".  We do
		! the search right here, and if we find the symbol, we return
		! to the caller right away with the proper SYMID and KIND.
		!
		[SCOPE$K_GLOBAL]:
		    BEGIN
		    PNAME = .PATHVEC[0];
		    IF (.PATHNAME[PTH$B_TOTCNT] EQL .PATHNAME[PTH$B_PATHCNT])AND
		       ((.PATHNAME[PTH$B_TOTCNT] EQL 2 AND .PNAME[0] EQL 0) OR
			(.PATHNAME[PTH$B_TOTCNT] EQL 1))
		    THEN
			BEGIN
			RSTPTR = DBG$STA_LOOKUP_GBL(
					.PATHVEC[.PATHNAME[PTH$B_TOTCNT] - 1]);
			IF .RSTPTR NEQ 0
			THEN
			    BEGIN
			    SYMID[0] = .RSTPTR;
			    KIND[0] = .RSTPTR[RST$B_KIND];

    	    		    ! If the user requested the information then fill in the
    	    		    ! output parameters which say what scope we are looking in.
    	    		    !
    			    IF .OUT_SCOPE_STATE NEQ 0
    			    THEN
    				.OUT_SCOPE_STATE = SCOPE$K_GLOBAL;
    			    IF .OUT_SCOPE NEQ 0
    			    THEN
    				.OUT_SCOPE = 0;

			    RETURN;
			    END;

			END;

		    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;


		! Search all SET modules for the symbol.  Here we locate the
		! next SET module and use that as the current scope.  Note that
		! we accumulate candidate symbols over all SET modules before
		! selecting the candidate that best matches the name.
		!
		[SCOPE$K_SETMODS]:
		    BEGIN


		    ! The first time through, make NEXTSETMOD point to the first
		    ! SET module and set the number of candidates to zero.
		    !
		    IF .NEXTSETMOD EQL .RST$START_ADDR
		    THEN
			BEGIN
			WHILE .NEXTSETMOD NEQ 0 DO
			    BEGIN
			    IF .NEXTSETMOD[RST$V_MODSET] THEN EXITLOOP;
			    NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];
			    END;

			END;


		    ! Make MODRSTPTR and SCOPE point to the next SET module and
		    ! make NEXTSETMOD point to the SET module we will search the
		    ! next time around.  When NEXTSETMOD becomes zero, there is
		    ! no next time around.
		    !
		    MODRSTPTR = .NEXTSETMOD;
		    SCOPE = .MODRSTPTR;
		    WHILE .NEXTSETMOD NEQ 0 DO
			BEGIN
			NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];
			IF .NEXTSETMOD EQL 0 THEN EXITLOOP;
			IF .NEXTSETMOD[RST$V_MODSET] THEN EXITLOOP;
			END;

		    IF .MODRSTPTR NEQ 0 THEN HAVE_SCOPE = TRUE;
		    IF .NEXTSETMOD EQL 0 THEN SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;

		TES;


	    ! If we now have a scope to search, exit the scope-locating loop
	    ! and search that scope.  Otherwise, loop to locate another scope.
	    !
	    IF .HAVE_SCOPE THEN EXITLOOP;

	    END;			! End of WHILE loop to find a scope


	! We now have a scope to search.  Make sure the corresponding module's
	! symbol table is in the RST.
	!
	IF NOT .MODRSTPTR[RST$V_MOD_IN_RST] 
    	THEN 
    	    DBG$RST_BUILD(.MODRSTPTR, FALSE);


    	! If the user requested the information then fill in the
    	! output parameters which say what scope we are looking in.
    	!
    	IF .OUT_SCOPE_STATE NEQ 0
    	THEN
    	    .OUT_SCOPE_STATE = .SCOPE_STATE;
    	IF .OUT_SCOPE NEQ 0 
    	THEN
    	    .OUT_SCOPE = .SCOPE;


	! If there is a line number in the pathname, find the lexical entity
	! within this scope's module which contains that line number.  Note
	! that we search for the lowest level (innermost) lexical entity.
	!
	IF .HAVE_LINE_NUM
	THEN
	    BEGIN


	    ! If this is the first real scope on the scope list, save the
	    ! current Module RST Entry pointer in case we will need it for
	    ! the "no line nnn" informational message.
	    !
	    IF .FIRST_MODPTR EQL 0 THEN FIRST_MODPTR = .MODRSTPTR;


	    ! Look up the line and statement numbers in the scope's module.
	    !
	    STATUS = DBG$LINE_TO_PC_LOOKUP(.LINE_NUM, .STMT_NUM,
					.MODRSTPTR, LINESTART, LINEEND, FALSE);


	    ! Look up the lowest-level (innermost) lexical entity which contains
	    ! the line we just looked up.  We do this by searching the module's
	    ! Static Address Table.
	    !
	    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
	    IF NOT .STATUS THEN SATPTR = 0;
	    LINE_LEX_PTR = 0;
	    WHILE .SATPTR NEQ 0 DO
		BEGIN
		IF .SATPTR[SAT$L_START] GTR .LINESTART THEN EXITLOOP;
		RSTPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.SATPTR[SAT$L_END] GEQ .LINESTART) AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_BLOCK)
		THEN
		    BEGIN
		    IF .LINE_LEX_PTR EQL 0
		    THEN
			LINE_LEX_PTR = .RSTPTR

		    ELSE
			BEGIN
			RPTR = .RSTPTR;
			WHILE .RPTR[RST$B_KIND] NEQ RST$K_MODULE DO
			    BEGIN
			    IF .RPTR EQL .LINE_LEX_PTR
			    THEN
				BEGIN
				LINE_LEX_PTR = .RSTPTR;
				EXITLOOP;
				END;

			    RPTR = .RPTR[RST$L_UPSCOPEPTR];
			    END;

			END;

		    END;

		SATPTR = .SATPTR[SAT$L_FLINK];

		END;			! End of WHILE loop over the SAT


	    ! In case we have to look up a register in this scope, save the
	    ! value of the line number lexical entity pointer.
	    !
	    IF .REG_SCOPE THEN REG_LINE_LEX_PTR = .LINE_LEX_PTR;

	    END;			! End of line number lexical entity code


	! Set up the RST Hash Table search for this symbol and loop over all
	! hash table entries for the symbol's name.  For each RST entry we find,
	! we try to match the full pathname.  If this succeeds and the symbol is
	! in the current scope, the RST entry is added to a "candidate list".
	!
	DBG$HASH_FIND_SETUP(.NAMEPTR);
	WHILE TRUE DO
	    BEGIN


	    ! Get the next RST entry with the specified symbol name.  If the
	    ! desired symbol is a line number, we pick up the lexical entity
	    ! which contains the line instead.
	    !
	    IF .LINE_NUM_IS_LAST
	    THEN
		BEGIN
		RSTPTR = .LINE_LEX_PTR;
		LINE_LEX_PTR = 0;
		END


	    ! Otherwise, pick up the next RST Hash Table entry with the
	    ! specified symbol name.
	    !
	    ELSE
		RSTPTR = DBG$HASH_FIND(.NAMEPTR);


	    ! If the RST pointer is zero, we found no more symbols with the
	    ! right name so we exit the search loop for this scope.
	    !
	    IF .RSTPTR EQL 0 THEN EXITLOOP;


	    ! Loop through the RST entry's scope chain to match it to the speci-
	    ! fied pathname.  If the full pathname matches and the symbol is in
	    ! the current scope, we add the RST entry to the "candidate list".
	    !
	    STKPTR = 0;
	    RPTR = .RSTPTR;
	    PINDEX = .PATHNAME[PTH$B_TOTCNT];
	    WHILE TRUE DO
		BEGIN


		! If this is a global symbol or a module, do not even attempt to
		! match it to the pathname--exit the pathname matching loop now.
		!
		IF  .RSTPTR[RST$V_GLOBAL] OR 
    		   (.RSTPTR[RST$B_KIND] EQL RST$K_MODULE) OR
    		   ((NOT .TYPE_FLAG) AND (.RSTPTR[RST$B_KIND] EQL RST$K_TYPE))
		THEN
		    EXITLOOP;


		! Also, if we are called by DBG$RST_SETSCOPE, do not consider
		! the symbol unless it is a routine or lexical block.
		!
		IF .SET_SCOPE
		THEN
		    BEGIN
		    IF (.RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
		       (.RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK)
		    THEN
			EXITLOOP;

		    END;


		! Make a new SYMSTACK entry for this RST entry in the up-scope
		! chain.
		!
		STKPTR = .STKPTR + 1;
		IF .STKPTR GEQ MAX_STACK THEN EXITLOOP;
		SYMSTACK[.STKPTR, STK_RSTPTR] = .RPTR;
		SYMSTACK[.STKPTR, STK_PINDEX] = 0;
		SYMSTACK[.STKPTR, STK_TPINDEX] = 0;


		! If this pathname component is a line number or a scope number,
		! we skip over it in pathname matching.
		!
		IF (.HAVE_LINE_NUM AND (.PINDEX EQL .LINE_NUM_LOC)) OR
		   (.HAVE_NUM_SCOPE AND (.PINDEX EQL 1))
		THEN
		    PINDEX = .PINDEX - 1;


		! If the current pathname component matches the current scope
		! chain name, set PINDEX to point to the next pathname compo-
		! nent.  If PINDEX already pointed to the top component name,
		! the pathname matches and we make a candidate list entry.
		!
		PNAME = .PATHVEC[.PINDEX - 1];
		IF .PINDEX EQL 0 THEN PNAME = .PATHVEC[0];
		RNAME = DBG$GET_DST_NAME(.RPTR[RST$L_DSTPTR]);
		IF CH$EQL(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0) OR
		   (.PINDEX EQL 0)
		THEN
		    BEGIN


		    ! Record the fact that RPTR matches this Pathname component.
		    !
		    SYMSTACK[.STKPTR, STK_PINDEX] = .PINDEX;


		    ! If the last (top-level) pathname component just matched,
		    ! we see if the symbol is in the current scope.  If it is,
		    ! we add the symbol to the candidate list (CANDLST).
		    !
		    IF (.PINDEX LEQ .PATHNAME[PTH$B_PATHCNT]) AND
		       (.RPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		    THEN
			BEGIN


			! Determine what the scope of the current symbol is.
			!
			SYMSCOPE = .RSTPTR;
			IF .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE
			THEN
			    SYMSCOPE = .RSTPTR[RST$L_UPSCOPEPTR];

			IF .SYMSCOPE[RST$B_KIND] EQL RST$K_TYPE
			THEN
			    SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];


			! If we are searching all set modules, we claim that the
			! the symbol is declared at the module level so that all
			! symbols have the same definition depth.  Also, if we
			! are looking for a line number, we treat it as being
			! defined at the module level.
			!
			IF .SCOPE_STATE EQL SCOPE$K_SETMODS OR .LINE_NUM_IS_LAST
			THEN
			    BEGIN
			    WHILE .SYMSCOPE[RST$B_KIND] NEQ RST$K_MODULE DO
				SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];

			    END;


			! Determine whether the symbol is in the current scope.
			!
			SCPTR = .SCOPE;
			DEFDEPTH = 0;
			IN_SCOPE = TRUE;
			WHILE TRUE DO
			    BEGIN
			    IF .SCPTR EQL .SYMSCOPE THEN EXITLOOP;
			    IF .SCPTR[RST$B_KIND] EQL RST$K_MODULE
			    THEN
				BEGIN
				IN_SCOPE = FALSE;
				EXITLOOP;
				END;

			    SCPTR = .SCPTR[RST$L_UPSCOPEPTR];
			    DEFDEPTH = .DEFDEPTH + 1;
			    END;


			! If a line number is present in the pathname, make sure
			! this symbol has the line's lexical entity in its up-
			! scope chain.  Otherwise set IN_SCOPE to FALSE.
			!
			IF .HAVE_LINE_NUM AND .IN_SCOPE AND NOT .LINE_NUM_IS_LAST
			THEN
			    BEGIN
			    IN_SCOPE = FALSE;
			    SCPTR = .RSTPTR;
			    WHILE .SCPTR[RST$B_KIND] NEQ RST$K_MODULE DO
				BEGIN
				IF .SCPTR EQL .LINE_LEX_PTR
				THEN
				    BEGIN
				    IN_SCOPE = TRUE;
				    EXITLOOP;
				    END;

				SCPTR = .SCPTR[RST$L_UPSCOPEPTR];
				END;

			    END;


			! If the symbol is in the current scope, create a "can-
			! didate entry" for it.  Then enter that entry on the
			! "candidate list".
			!
			IF .IN_SCOPE
			THEN
			    BEGIN


			    ! Create the candidate entry for the symbol.
			    !
			    CANDBLK = DBG$GET_MEMORY(CAND_ENTSIZ*(.STKPTR+1));
			    J = 0;
			    INCR I FROM 1 TO .STKPTR DO
				BEGIN
				IF .SYMSTACK[.I, STK_TPINDEX] EQL 0
				THEN
				    BEGIN
				    CANDBLK[.J, CAND_RSTPTR] = .SYMSTACK[.I, STK_RSTPTR];
				    CANDBLK[.J, CAND_PINDEX] = .SYMSTACK[.I, STK_PINDEX];
				    J = .J + 1;
				    END;

				END;

			    CANDBLK[.J, CAND_RSTPTR] = 0;
			    CANDBLK[.J, CAND_PINDEX] = .DEFDEPTH;


			    ! Enter the candidate entry on the candidate list.
			    ! Note that we expand the candidate list memory
			    ! block if it is too small.
			    !
			    NCANDS = .NCANDS + 1;
			    IF .NCANDS GTR .CANDLST[0]
			    THEN
				BEGIN
				CANDLST[0] = .CANDLST[0] + 10;
				OLDCAND = .CANDLST;
				CANDLST = DBG$GET_MEMORY(.CANDLST[0] + 1);
				CH$MOVE(4*.NCANDS, .OLDCAND, .CANDLST);
				DBG$REL_MEMORY(.OLDCAND);
				END;

			    CANDLST[.NCANDS] = .CANDBLK;
			    END;


			! Now tear down SYMSTACK until we get to the bottom or
			! until we get to a TYPE entry whose type reference
			! table has not been exhausted.  If no such entry is
			! found, we exit the pathname match loop (with STKPTR =
			! 0) for this hash table symbol.
			!
			WHILE .STKPTR GTR 0 DO
			    BEGIN
			    IF .SYMSTACK[.STKPTR, STK_TPINDEX] NEQ 0
			    THEN
				BEGIN
				TPINDEX = .SYMSTACK[.STKPTR, STK_TPINDEX];
				RPTR = .SYMSTACK[.STKPTR, STK_RSTPTR];
				IF .TPINDEX LSS .RPTR[RST$W_TYPREFCNT] THEN EXITLOOP;
				END;

			    STKPTR = .STKPTR - 1;
			    END;

			IF .STKPTR EQL 0 THEN EXITLOOP;


			! If we found a type entry in SYMSTACK whose reference
			! table is not exhausted, we reset RPTR and PINDEX to
			! continue generating possible candidates from symbols
			! of this type.
			!
			SYMSTACK[.STKPTR, STK_TPINDEX] = .TPINDEX + 1;
			TPTR = .RPTR[RST$L_TYPREFTBL];
			RPTR = .TPTR[.TPINDEX];
			PINDEX = .SYMSTACK[.STKPTR, STK_PINDEX] + 1;

			END;		! End of .PINDEX LEQ ... THEN clause


		    ! We have more pathname components to match.  Decrement
		    ! PINDEX and stay in the pathname matching loop.
		    !
		    PINDEX = .PINDEX - 1;
		    IF .PINDEX LSS 0 THEN PINDEX = 0;

		    END;		! End of CH$EQL test's THEN clause


		! If the RST entry's up-scope chain has ended, we exit the path-
		! name matching loop.  Otherwise, we link up the up-scope chain
		! and continue pathname matching.
		!
		IF .RPTR[RST$B_KIND] EQL RST$K_MODULE THEN EXITLOOP;
		RPTR = .RPTR[RST$L_UPSCOPEPTR];


		! If the up-scope symbol is a Type RST Entry, we set up an entry
		! for it on SYMSTACK.  This stack entry will enable us to try
		! all possible symbols of this type as the up-scope continuation
		! of a type component (e.g., record or variant component).
		!
		IF .RPTR[RST$B_KIND] EQL RST$K_TYPE
		THEN
		    BEGIN
		    IF .RPTR[RST$L_TYPREFTBL] EQL 0 THEN EXITLOOP;
		    STKPTR = .STKPTR + 1;
		    IF .STKPTR GEQ MAX_STACK THEN EXITLOOP;
		    SYMSTACK[.STKPTR, STK_RSTPTR] = .RPTR;
		    SYMSTACK[.STKPTR, STK_PINDEX] = .PINDEX;
		    SYMSTACK[.STKPTR, STK_TPINDEX] = 1;
		    TPTR = .RPTR[RST$L_TYPREFTBL];
		    RPTR = .TPTR[0];
		    END;

		END;			! End of pathname matching WHILE loop

	    END;			! End of WHILE loop over hash table


	! We now have a list of candidate symbols which are in the current scope
	! and which may match the pathname.  Unless the list is empty, call a
	! language-specific routine to select the candidate symbol which best
	! matches the pathname.  Note that when we search all SET modules, we
	! do not call this selection routine until candidate symbols have been
	! accumulated from all SET modules.
	!
	IF (.NCANDS GTR 0) AND
	   (.SCOPE_STATE NEQ SCOPE$K_SETMODS OR .NEXTSETMOD EQL 0)
	THEN
	    BEGIN
	    CASE .DBG$GB_LANGUAGE FROM DBG$K_MACRO TO DBG$K_UNKNOWN OF
		SET


		! Handle languages with "normal" scope rules--data qualification
		! must be complete, or it is absent from the language.
		!
		[DBG$K_MACRO, DBG$K_FORTRAN,
		 DBG$K_BLISS, DBG$K_BASIC,
		 DBG$K_PASCAL, DBG$K_C,
		 INRANGE, OUTRANGE]:
		    GOOD_CAND = SCOPE_RULE_NORMAL(.PATHNAME, .NCANDS, 
    						  .CANDLST, .ARRAY_FLAG);


		! Handle COBOL scope rules--data qualification need not be
		! complete and is resolved by COBOL scope rules.
		!
		[DBG$K_COBOL]:
		    BEGIN
		    SCPTR = 0;
		    IF (.SCOPE_STATE EQL SCOPE$K_NORMAL) OR
		       (.SCOPE_STATE EQL SCOPE$K_NUMBERED)
		    THEN
			SCPTR = .SCOPE;

		    GOOD_CAND = SCOPE_RULE_COBOL(.PATHNAME,
						.NCANDS, .CANDLST, .SCPTR);
		    END;


		! Handle PL/I scope rules--data qualification need not be
		! complete and is resolved by PL/I rules.
		!
		[DBG$K_PLI]:
		    GOOD_CAND = SCOPE_RULE_PLI(.PATHNAME, .NCANDS, .CANDLST);

		TES;


	    ! If we found a valid and unique match for the pathname in this
	    ! scope, make CANDBLK point to that symbol and exit the scope
	    ! search loop.
	    !
	    IF .GOOD_CAND GTR 0
	    THEN
		BEGIN
		CANDBLK = .CANDLST[.GOOD_CAND];
		EXITLOOP;
		END;


	    ! We did not find a valid and unique symbol.  Release all candidate
	    ! blocks on the candidate list to the free memory pool.
	    !
	    INCR I FROM 1 TO .NCANDS DO DBG$REL_MEMORY(.CANDLST[.I]);
	    NCANDS = 0;


	    ! If the symbol turns out not be unique, return the not-unique
	    ! code to KIND and a zero to SYMID; then return to the caller.
	    ! Otherwise, loop to locate another scope to search.
	    !
	    IF .GOOD_CAND EQL -1
	    THEN
		BEGIN
		SYMID[0] = 0;
		KIND[0] = RST$K_NOTUNIQUE;
		RETURN;
		END;

	    END;

	END;				! End of WHILE loop over all scopes


    ! Now go through the symbol's candidate entry to create new Data RST Entries
    ! from any Type Component RST Entries.  These new RST entries represent this
    ! specific instance of data qualification.  These RST entries are put on the
    ! Temporary RST Entry List.
    !
    J = 0;
    WHILE TRUE DO
	BEGIN
	RPTR = .CANDBLK[.J, CAND_RSTPTR];
	IF .RPTR EQL 0 THEN EXITLOOP;
	IF .RPTR[RST$B_KIND] NEQ RST$K_TYPCOMP THEN EXITLOOP;
	RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
	RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	RST$TEMP_LIST = .RSTPTR;
	RSTPTR[RST$L_DSTPTR] = .RPTR[RST$L_DSTPTR];
	RSTPTR[RST$L_UPSCOPEPTR] = .RPTR[RST$L_UPSCOPEPTR];
	RSTPTR[RST$B_KIND] = RST$K_INVALID;
	RSTPTR[RST$L_TYPEPTR] = .RPTR[RST$L_TYPEPTR];
	CANDBLK[.J, CAND_RSTPTR] = .RSTPTR;
	J = .J + 1;
	END;


    ! Then make a second scan over the new Data RST Entries to fix up their
    ! up-scope pointers.
    !
    J = 0;
    WHILE TRUE DO
	BEGIN
	RSTPTR = .CANDBLK[.J, CAND_RSTPTR];
	IF .RSTPTR EQL 0 THEN EXITLOOP;
	IF .RSTPTR[RST$B_KIND] NEQ RST$K_INVALID THEN EXITLOOP;
	RSTPTR[RST$B_KIND] = RST$K_DATA;
	IF .CANDBLK[.J + 1, CAND_RSTPTR] NEQ 0
	THEN
	    RSTPTR[RST$L_UPSCOPEPTR] = .CANDBLK[.J + 1, CAND_RSTPTR];

	J = .J + 1;
	END;


    ! If the symbol is a line number, create the Line Number RST Entry for the
    ! symbol and make its address the symbol's SYMID.
    !
    IF .LINE_NUM_IS_LAST
    THEN
	BEGIN
	MODRSTPTR = .CANDBLK[0, CAND_RSTPTR];
	WHILE .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
	    MODRSTPTR = .MODRSTPTR[RST$L_UPSCOPEPTR];

	STATUS = DBG$LINE_TO_PC_LOOKUP(.LINE_NUM, .STMT_NUM,
					.MODRSTPTR, LINESTART, LINEEND, FALSE);
	CANDBLK[0, CAND_RSTPTR] = DBG$STA_LINE_NUM_RST(.CANDBLK[0, CAND_RSTPTR],
		.LINE_NUM, .STMT_NUM, .LINESTART, .LINEEND);
	END;


    ! Pick up the SYMID (RST pointer) of the symbol we found.
    !
    RSTPTR = .CANDBLK[0, CAND_RSTPTR];


    ! If there is an invocation number, check that the invocation number was
    ! applied to the inner-most routine in the up-scope chain.  If that looks
    ! good, create an Invocation Number RST Entry for the symbol.
    !
    IF (.PATHNAME[PTH$B_LOCINVOC] NEQ 0) AND (NOT .HAVE_NUM_SCOPE)
    THEN
	BEGIN


	! Find the inner-most routine containing the declaration of this symbol.
	! This is the routine to which the invocation number must apply.
	!
	ROUTPTR = .RSTPTR;
	WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	    BEGIN
	    IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE
	    THEN
		BEGIN
		DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
		SIGNAL(DBG$_MISINVNUM, 1, .PATHSTRING);
		END;

	    ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	    END;


	! Now make sure the invocation number was indeed appended to that
	! routine name in the pathname.
	!
	PNAME = .PATHVEC[.PATHNAME[PTH$B_LOCINVOC] - 1];
	RNAME = DBG$GET_DST_NAME(.ROUTPTR[RST$L_DSTPTR]);
	IF CH$NEQ(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0)
	THEN
	    BEGIN
	    DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
	    SIGNAL(DBG$_MISINVNUM, 1, .PATHSTRING);
	    END;


	! All looks good.  Create the Invocation Number RST Entry along with a
	! new copy of the symbol's RST entry if the number is non-zero.
	!
	IF .PATHNAME[PTH$L_INVOCNUM] NEQ 0
	THEN
	    RSTPTR = DBG$BUILD_INVOC_RST(.RSTPTR, .PATHNAME[PTH$L_INVOCNUM]);

	END


    ! If this symbol was specified with a numbered scope (i.e. 2\X) and the
    ! invocation number is non-zero, create an Invocation Number RST Entry
    ! for the symbol.
    !
    ELSE IF .HAVE_NUM_SCOPE AND (.NUMSCP_INVOC_NUM NEQ 0)
    THEN
	RSTPTR = DBG$BUILD_INVOC_RST(.RSTPTR, .NUMSCP_INVOC_NUM)


    ! And also, if the symbol was a simple symbol without any pathname qualifi-
    ! cation, do the proper up-level addressing (if any) in the scope we found
    ! it in to get the proper invocation number for the symbol.
    !
    ELSE IF (.PATHNAME[PTH$B_LOCINVOC] EQL 0) AND
	    (.PATHNAME[PTH$B_PATHCNT] EQL 1)
    THEN
	RSTPTR = FOLLOW_STATIC_LINK(.RSTPTR, .SCOPE);


    ! Now return the selected symbol's SYMID and KIND to the caller.
    !
    SYMID[0] = .RSTPTR;
    KIND[0] = .RSTPTR[RST$B_KIND];


    ! Release all candidate blocks on the candidate list to the memory pool.
    !
    INCR I FROM 1 TO .NCANDS DO DBG$REL_MEMORY(.CANDLST[.I]);


    ! Mark this symbol's RST entry as being referenced by adding its address
    ! to the RST Reference List (RST$REF_LIST).  This only says that the RST
    ! entry is referenced by the current Debug command.  Note that we expand
    ! the list memory block if it is about to overflow.
    !
    IF .RST$REF_LIST[1] EQL .RST$REF_LIST[0]
    THEN
	BEGIN
	RST$REF_LIST[0] = .RST$REF_LIST[0] + 20;
	NEWREFLIST = DBG$GET_MEMORY(.RST$REF_LIST[0] + 2);
	CH$MOVE(4*(.RST$REF_LIST[1] + 2), .RST$REF_LIST, .NEWREFLIST);
	DBG$REL_MEMORY(.RST$REF_LIST);
	RST$REF_LIST = .NEWREFLIST;
	END;

    RST$REF_LIST[1] = .RST$REF_LIST[1] + 1;
    RST$REF_LIST[.RST$REF_LIST[1] + 1] = .RSTPTR;


    ! Mark the symbol's module as being the Most Recently Referenced module.
    ! Then return.
    !
    IF .MODRSTPTR NEQ .LRUM$MOST_RECENT THEN DBG$RST_MOST_RECENT(.MODRSTPTR);
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_GETSYMOFF(ADDR, P_SYMID, P_BIT_OFFSET) =
!
! FUNCTION:
!	This routine accepts a address descriptor, and attempts to symbolize
!	it as a symbol name plus offset.
!	It always returns the best possible symbolization; if the address can
!	be symbolized by more than one symbol name with the same offset, then
!	the first is chosen to be the best.  
!
!	The routine accepts an optional print flag (the default being no print).
!	The best symbolization is returned in the form of symid and offset.  If
!	output is specified (as in the SYMBOLIZE command), then the following 
!	occurs:
!
!	1.  If the address is found to be an instruction address, then the 
!	    the routines it calls symbolize it as either a label (exact match
!	    only), or as a line number and byte offset from the start of the
!	    line.  This information is printed, along with the routine name plus
!	    byte offset from the beginning of the routine.
!
!	2.  If the address turns out to be a data address (that is, if it turns out
!	    not to be in any routine's instruction address range), this routine will
!	    see if it corresponds to any static data item.  If so, that data symbol
!	    and an offset from it will be printed, and the symid and offset will be 
!	    returned.  Symbolization will not be done to array elements or record
!	    components--only the outer level static data item will be returned as
!	    as the symbol.  If the address is a stack address, then the VAX call
!	    stack is searched for a match.  Or, if the address is a register
!	    address, then the module's symbol table is searched for those symbols
!	    bound to that register.  If no symbol is found at all, then the symid
!	    is set to zero, and the absolute virtual address is returned as the
!	    offset.  A message saying that no symbolization was possible is
!	    is displayed, and the routine returns false.
!
!	DBG$STA_GETSYMOFF is called to symbolize addresses only in certain cir-
!	cumstances.  One is when the user program has faulted somewhere (with an
!	access violation, for example) and the fault address must be symbolized
!	and displayed in an understandable form.  Another is when VAX machine
!	instructions are displayed symbolically (through E/I or STEP, for exam-
!	ple) and operands must be displayed in as symbolic a form as possible.
!    	DBG$STA_GETSYMOFF is always called during execution of the SYMBOLIZE 
!	command, and output is always done in that case.
!
! INPUTS:
!	ADDR		- The address of an address descriptor (byte and bit offset).
!
!	P_SYMID	        - The address of a longword location where the "symbol identi-
!		  	  fier" should be returned.  The "symbol identifier" is a value
!		  	  which uniquely identifies the returned symbol.  This value is
!		  	  not directly understood outside the symbol table access rou-
!		  	  tines, but can be passed to various other symbol table access
!		  	  routines to extract information about the symbol.
!
!	P_BIT_OFFSET	- The address of a longword location where the bit offset from
!		  	  the SYMID symbol should be returned.
!
!	An optional print flag may be specified.  The default is FALSE - no print.
!
! OUTPUTS:
!	SYMID	- A symbol identifier which uniquely identifies the symbol
!		  which best symbolizes ADDR is returned to SYMID.  This symbol
!		  identifier can then be passed to any symbol table access rou-
!		  tine which accepts a SYMID parameter.  If no suitable symbol
!		  can be found, a zero is returned to SYMID.
!
!	OFFSET	- The bit offset of ADDR relative to the SYMID symbol is
!		  returned to OFFSET.  If (SYMID) is zero, this
!		  offset is simply the original address descriptor.
!
!	The routine returns true if symbolization was possible; otherwise it 
!	returns false.
!

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;

    BIND
	SYMID  = .P_SYMID:  REF RST$ENTRY,
	BIT_OFFSET = .P_BIT_OFFSET;

    MAP
    	ADDR: REF DBG$ADDRESS_DESC;	! Pointer to address descriptor

    LOCAL
	PRINT_FLAG;			! Flag for print/no print.


    ! If the caller wants output, then the fourth parameter will be true.
    ! Otherwise, the fourth parameter will be false, or not at all.
    !
    IF ACTUALCOUNT() GEQ 4
    THEN
	PRINT_FLAG = ACTUALPARAMETER (4)
    ELSE
	PRINT_FLAG = FALSE;


    ! See if the address is a register address.
    !
    IF DBG$SYMBOLIZE_REG (.ADDR, SYMID, BIT_OFFSET, .PRINT_FLAG)
    THEN
	RETURN TRUE;


    ! See if the address is a static address.
    !
    IF DBG$SEARCH_SAT (.ADDR, SYMID, BIT_OFFSET, .PRINT_FLAG)
    THEN
    	BEGIN


    	! At this point, we have found a module, but there is no symid we could
    	! locate, so try global search to locate more info.
    	!
    	IF .SYMID EQL 0
    	THEN
    	    BEGIN
    	    IF .PRINT_FLAG THEN DBG$PRINT_CONTROL(DBG$K_PRT_RESET);
    	    IF DBG$SEARCH_GLOBAL (.ADDR, SYMID, BIT_OFFSET, .PRINT_FLAG)
            THEN
    	        RETURN TRUE

    	    ELSE
    		BEGIN
    		BIT_OFFSET = .ADDR;
    		RETURN FALSE;
    		END;

    	    END


    	! We have found a good symid in a given module, for SYMBOLIZE command,
    	! we print a bit more info for the symbol declared as global.  But we
    	! do not want the global symid.
    	!
    	ELSE
    	    BEGIN
    	    IF .PRINT_FLAG
    	    THEN
    		BEGIN
    		LOCAL
    		    TMP_SYMID, TMP_OFFSET;

    	        DBG$PRINT_CONTROL(DBG$K_PRT_RESET);
    	        DBG$SEARCH_GLOBAL (.ADDR, TMP_SYMID, TMP_OFFSET, .PRINT_FLAG);
    		END;

  	    RETURN TRUE;
    	    END;

    	END;


    ! See if the address is on the call stack.
    !
    IF DBG$SEARCH_VAX_CALL_STACK (.ADDR, SYMID, BIT_OFFSET, .PRINT_FLAG)
    THEN
	RETURN TRUE;


    ! Try once more!!!  See if the address is a global symbol.
    !
    IF DBG$SEARCH_GLOBAL (.ADDR, SYMID, BIT_OFFSET, .PRINT_FLAG)
    THEN
    	RETURN TRUE;


    ! The address was not found, and symbolization was thus impossible.
    !
    SYMID = 0;
    BIT_OFFSET = .ADDR;
    RETURN FALSE;
    END;

GLOBAL ROUTINE DBG$STA_LINE_NUM_RST(LEXPTR, LINE_NUM, STMT_NUM, LINESTART, LINEEND) =
!
! FUNCTION
!	This routine builds a Line Number RST Entry for a specified line and
!	links it into the RST.  In addition to the RST entry, a dummy Label DST
!	Record is built (in the same memory block) to contain the line's name
!	as Counted ASCII (e.g. "%LINE 25.3").  The RST entry is linked into the
!	Temporary RST Entry List pointed to by RST$TEMP_LIST.
!
! INPUTS
!	LEXPTR	- A pointer to the lexical entity RST entry to which the Line
!		  Number RST Entry should be attached via the up-scope pointer.
!
!	LINE_NUM - The line's line number.
!
!	STMT_NUM - The line's statement number.
!
!	LINESTART - The line's start address in virtual memory.
!
!	LINEEND	- The line's end address in virtual memory.
!
! OUTPUTS
!	A pointer to the line's Line Number RST Entry is returned as the
!		  routine's value.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to dummy Label DST Record
	J,				! Index into the TEXT array; number of
					!      characters in the line's name
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to DST record name vector
	NUMBER,				! Used to convert the statement and line
					!      numbers to ASCII
	RSTPTR: REF RST$ENTRY,		! Pointer to Line Number RST Entry
	TEXT: VECTOR[40,BYTE];		! Vector used to generate ASCII name



    ! Build the line number name as an ASCII string in the TEXT vector.  Note
    ! that the string is stored backward in this vector since we generate low-
    ! order numeric digits before high-order ones.
    !
    J = 0;
    IF .STMT_NUM NEQ 0
    THEN
	BEGIN
	NUMBER = .STMT_NUM;
	WHILE TRUE DO
	    BEGIN
	    TEXT[.J] = (.NUMBER MOD 10) + '0';
	    J = .J + 1;
	    NUMBER = .NUMBER/10;
	    IF .NUMBER EQL 0 THEN EXITLOOP;
	    END;

	TEXT[.J] = '.';
	J = .J + 1;
	END;

    NUMBER = .LINE_NUM;
    WHILE TRUE DO
	BEGIN
	TEXT[.J] = (.NUMBER MOD 10) + '0';
	J = .J + 1;
	NUMBER = .NUMBER/10;
	IF .NUMBER EQL 0 THEN EXITLOOP;
	END;

    J = .J + 6;
    TEXT[.J - 1] = '%';
    TEXT[.J - 2] = 'L';
    TEXT[.J - 3] = 'I';
    TEXT[.J - 4] = 'N';
    TEXT[.J - 5] = 'E';
    TEXT[.J - 6] = ' ';


    ! Allocate enough space for the Line Number RST Entry and for a Label DST
    ! record (which we will build in the same memory block).
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_LINENTSIZ + (.J + 11)/4);
    DSTPTR = .RSTPTR + 4*RST$K_LINENTSIZ;


    ! Construct the dummy Label DST record for the line number.
    !
    DSTPTR[DST$B_LENGTH] = 7 + .J;
    DSTPTR[DST$B_TYPE] = DST$K_LABEL;
    DSTPTR[DST$B_VFLAGS] = 0;
    DSTPTR[DST$L_VALUE] = .LINESTART;
    NAMEPTR = DSTPTR[DST$B_NAME];
    NAMEPTR[0] = .J;
    INCR I FROM 1 TO .J DO NAMEPTR[.I] = .TEXT[.J - .I];


    ! Then construct the Line Number RST Entry for the line.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .LEXPTR;
    RSTPTR[RST$B_KIND] = RST$K_LINE;
    RSTPTR[RST$L_STARTADDR] = .LINESTART;
    RSTPTR[RST$L_ENDADDR] = .LINEEND;


    ! Link the RST entry into the Temporary RST Entry List.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Return to the caller with the RST entry address as the routine value.
    !
    RETURN .RSTPTR;

    END;


GLOBAL ROUTINE DBG$STA_LOCK_SYMID(SYMID_LIST_PTR): NOVALUE =
!
! FUNCTION
!	This routine "locks" a list of SYMIDs in the RST so that the correspond-
!	ing RST entries cannot be released to the free memory pool.  SYMIDs are
!	locked this way only when they will be saved in a Primary Descriptor or
!	elsewhere accross Debug commands.  SYMIDs used to represent "." (current
!	location) or breakpoint locations are examples of SYMIDs which must be
!	locked accross commands.  A locked SYMID remains locked until it is ex-
!	plicitly unlocked by a call to DBG$STA_UNLOCK_SYMID.
!
!	The actual locking procedure involves incrementing the Reference Count
!	in the SYMID's RST entry and in most RST entries directly accessible
!	from this RST entry.  This includes all RST entries upscope from the
!	present entry and all Data Type RST Entries attached to the up-scope
!	chain.
!
! INPUTS
!	SYMID_LIST_PTR - A pointer to a linked list of Linked List Nodes, where
!		  each node contains a forward link and a SYMID value.  Each
!		  SYMID on the list is "locked" in the RST by incrementing the
!		  reference count of the corresponding RST entry.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LISTPTR: REF DBG$LINK_NODE;	! Pointer to current linked list node



    ! Loop through all the SYMIDs (i.e., RST pointers) on the linked list.
    ! For each SYMID on the list, call ADD_TO_REF_COUNT to increment the RST
    ! entry's reference count.
    !
    LISTPTR = .SYMID_LIST_PTR;
    WHILE .LISTPTR NEQ 0 DO
	BEGIN
	ADD_TO_REF_COUNT(.LISTPTR[DBG$L_LINK_NODE_VALUE], +1);
	LISTPTR = .LISTPTR[DBG$L_LINK_NODE_LINK];
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_LOOKUP_GBL(NAMEPTR) =
!
! FUNCTION
!	This routine looks up a symbol in the Global Symbol Table (the GST)
!	and only in the GST.  It accepts the symbol name as input, looks up
!	that symbol in the GST, and returns a pointer to an RST entry for the
!	global symbol.  If the symbol is not found in the GST, a value of zero 
!	is returned.
!
!	The whole RST and GST search is suppressed if the DBG$GB_NO_GLOBALS
!	flag is set.  In this case, the routine always returns zero.
!
! INPUTS
!	NAMEPTR - A pointed to the symbol name to be looked up in the GST.
!		  The name must be represented by a Counted ASCII string.
!
! OUTPUTS
!	A pointer to an RST entry for the global symbol is returned as the
!		  routine value.  If the symbol is not in the GST, zero is
!		  returned as the routine value.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to Counted ASCII symbol name


    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to current symbol's RST entry
					!      symbol is a routine entry point



    ! If the Global Symbol Table is suppressed, return zero right away.
    !
    IF .DBG$GB_NO_GLOBALS THEN RETURN 0;


    ! Search the RST Hash Table for a symbol with the desired name which is
    ! also marked as being global (meaning that it is derived from the GST).
    ! If we find such an RST entry, we return its address to the caller.
    !
    DBG$HASH_FIND_SETUP(.NAMEPTR);
    WHILE TRUE DO
	BEGIN
	RSTPTR = DBG$HASH_FIND(.NAMEPTR);
	IF .RSTPTR EQL 0 THEN EXITLOOP;
	IF .RSTPTR[RST$V_GLOBAL] THEN RETURN .RSTPTR;
	END;


    ! We did not find the symbol in the Global Symbol Table--just return zero.
    !
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_NOEVALBIT(SYMID) =
!
! FUNCTION
!	This routine determines whether the DST$V_MS_NOEVAL bit is set in the
!	Value Spec for a specified symbol.  This bit is used by PL/I to suppress
!	re-evaluation of Value Specs when such Value Specs can have side effects
!	(as is the case for certain kinds of BASED variables).  The side effects
!	are acceptable when such a symbol is initially examined, but not when
!	the symbol is reexamined via the dot pseudosymbol.  Thus, when dot is
!	bound to a symbol with the DST$V_MS_NOEVAL bit set in its Value Spec,
!	that Value Spec is not reevaluated.  The PL/I-specific code makes this
!	check, but this routine returns the value of the bit.
!
!	The DST$V_MS_NOEVAL bit can only occur in a Value Spec containing a
!	Materialization Spec.  If the Value Spec does not have that form, this
!	routine always returns FALSE--the bit is treated as not set.
!
! INPUTS
!	SYMID	- The SYMID of the symbol whose DST$V_MS_NOEVAL bit is to be
!		  interrogated.
!
! OUTPUTS
!	The routine returns TRUE if the DST$V_MS_NOEVAL bit is set in the
!		  symbol's value spec.  If the bit is not set or if the bit
!		  is not present at all in the symbol's value spec, FALSE
!		  is returned.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to symbol's DST record.
	MSPTR: REF DST$MATER_SPEC,	! Pointer to DST Materialization Spec
	VSPTR: REF DST$VAL_SPEC;	! Pointer to DST Value Spec



    ! Determine what kind of RST entry SYMID identifies and act accordingly.
    !
    CASE .SYMID[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	SET


	! For anything but Data and Type Component symbols, return FALSE.  These
	! symbols do not have value specs containing a DST$V_MS_NOEVAL bit.
	!
	[RST$K_ROUTINE, RST$K_BLOCK,
	 RST$K_ENTRY, RST$K_LABEL,
	 RST$K_LINE, RST$K_TYPE]:
	    RETURN FALSE;


	! For Data and Type Components, do nothing here--we handle them below.
	!
	[RST$K_DATA, RST$K_TYPCOMP]:
	    0;


	! For everything else (including Module), signal an internal error.
	!
	[INRANGE, OUTRANGE]:
	    $DBG_ERROR('RSTACCESS\NOEVALBIT');

	TES;


    ! For the items not yet handled (i.e., for data), we determine the type of
    ! DST record which holds the value specification and act accordingly.
    !
    DSTPTR = .SYMID[RST$L_DSTPTR];
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle the DST records which can conceivably have Materialization
	! Specs and thus the DST$V_MS_NOEVAL bit.  If the bit exists, return
	! its value; otherwise return FALSE.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
	 DST$K_RECBEG, DST$K_ENUMELT]:
	    BEGIN


	    ! Indirect through any Trailing Value Specs to get to the symbol's
	    ! Value Spec.  If this Value Spec cannot have a Materialization
	    ! Spec, return FALSE right away.
	    !
	    VSPTR = DSTPTR[DST$B_VFLAGS];
	    WHILE .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
		VSPTR = VSPTR[DST$A_VS_TVS_BASE] + .VSPTR[DST$L_VS_TVS_OFFSET];

	    IF .VSPTR[DST$B_VS_VFLAGS] NEQ DST$K_VS_FOLLOWS THEN RETURN FALSE;


	    ! If this is a Static or Dynamic DST$K_VS_FOLLOWS type Value Spec,
	    ! return the DST$V_MS_NOEVAL bit from the Materialization Spec.
	    !
	    IF (.VSPTR[DST$B_VS_ALLOC] EQL DST$K_VS_ALLOC_STAT) OR
	       (.VSPTR[DST$B_VS_ALLOC] EQL DST$K_VS_ALLOC_DYN)
	    THEN
		BEGIN
		MSPTR = VSPTR[DST$A_VS_MATSPEC];
		RETURN .MSPTR[DST$V_MS_NOEVAL];
		END;


	    ! Any other value in the DST$B_VS_ALLOC field is an error.
	    !
	    SIGNAL(DBG$_INVDSTREC);

	    END;


	! For all DST records which cannot have Materialization Specs in their
	! Value Specs, fall through to return FALSE at the end of the routine.
	!
	[INRANGE]:
	    0;

	TES;


    ! Return FALSE.  If we got here, there is no Materialization Spec.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$STA_NUMBERED_SCOPE(SCOPE_NUMBER, MODRSTPTR, SCOPE, 
    						INVOCNUM): NOVALUE =
!
! FUNCTION
!	This routine determines what scope corresponds to a given "numbered"
!	scope at this point in the user program's execution.  This scope is de-
!	termined by looking SCOPE_NUMBER levels down in the VAX CALL-stack and
!	picking up the PC value in that call frame.  The Program Static Address
!	Table (SAT) is searched for this PC value to find the containing module,
!	and after that the module's SAT is searched if the module is marked as
!	SET.  The module's RST is built if not already present.  The search is
!	successful if a Routine RST Entry or a Lexical Block RST Entry is found
!	whose address range contains the PC value.
!
! INPUTS
!	SCOPE_NUMBER - The number of the "numbered scope" to be located.  This
!		  number is zero for the current scope, i.e. the scope where
!		  the PC is located at present, and it is N for the scope which
!		  contains the PC N levels down in the VAX CALL-stack.
!
!	MODRSTPTR - The address of a longword location to receive a pointer to
!		  the Module RST Entry for the numbered scope.
!
!	SCOPE	- The address of a longword location to receive a pointer to the
!		  Routine or Lexical Block RST Entry which defines the numbered
!		  scope.
!
!	INVOCNUM - The address of a longword location to receive the correspond-
!		  ing invocation number.
!
! OUTPUTS
!	MODRSTPTR - A pointer to the numbered scope's Module RST Entry is
!		  returned to MODRSTPTR.  If the scope cannot be found, a
!		  zero is returned to MODRSTPTR.
!
!	SCOPE	- A pointer to the RST entry of the routine or lexical block
!		  which constitutes the numbered scope is returned to SCOPE.
!		  If the scope cannot be found, a zero is returned to SCOPE.
!
!	INVOCNUM - The invocation number of the scope is returned to INVOCNUM.
!
!	No value is returned.
!

    BEGIN

    MAP
	MODRSTPTR: REF VECTOR[1],	! Pointer to longword to receive the
					!      Module RST Entry pointer
	SCOPE: REF VECTOR[1],		! Pointer to longword to receive the
					!      numbered scope RST pointer
	INVOCNUM: REF VECTOR[1];	! Pointer to longword to receive the
					!      scope's invocation number

    LOCAL
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to stack CALL frames
	MODPTR: REF RST$ENTRY,		! Pointer to scope's Module RST Entry
	PCVAL,				! The CALL-frame Program Counter value
	REGPTR: REF VECTOR[,LONG],	! Pointer to an actual register value
	REGVEC: VECTOR[17,LONG],	! Vector of pointers to register save
					!      locations for current CALL frame
	ROUTPTR: REF RST$ENTRY,		! Pointer to RST entry for inner-most
					!       routine in up-scope chain
	RPTR: REF RST$ENTRY,		! Pointer used to search up-scope chain
	RSTPTR: REF RST$ENTRY,		! Pointer to numbered scope's RST entry
	RUNFRAME_PTR,			! Pointer to current entry in CALL com-
					!      mand runframe stack (needed by
					!      the GET_REGISTER_VALUES routine)
	SATPTR: REF SAT$ENTRY;		! Pointer to the current Static Address
					!      Table entry



    ! Return zeroes (no find) to MODRSTPTR and SCOPE initially.
    !
    MODRSTPTR[0] = 0;
    SCOPE[0] = 0;


    ! Pick up the current Program Counter value from the user's run frame.
    ! Then search through the CALL frames on the stack until the desired run
    ! frame (and thus PC value) is reached.  If the CALL stack ends before
    ! then, return with MODRSTPTR and SCOPE containing zeroes.
    !
    PCVAL = .DBG$RUNFRAME[DBG$L_USER_PC];
    IF .PCVAL EQL 0 THEN RETURN;
    FRAMEPTR = .DBG$RUNFRAME[DBG$L_USER_FP];
    RUNFRAME_PTR = .DBG$RUNFRAME[DBG$L_NEXT_LINK];
    INCR I FROM 1 TO .SCOPE_NUMBER DO
	BEGIN
	IF (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL) OR (.PCVAL EQL 0)
	THEN
	    RETURN;

	GET_REGISTER_VALUES(.FRAMEPTR, RUNFRAME_PTR, REGVEC);
	REGPTR = .REGVEC[15];
	PCVAL = .REGPTR[0];
	REGPTR = .REGVEC[13];
	FRAMEPTR = .REGPTR[0];
	END;


    ! Search the Program Static Address Table (SAT) for the module which con-
    ! tains the PC value we found.  If we don't find such a module, return
    ! with MODRSTPTR and SCOPE containing zeroes.
    !
    SATPTR = .SAT$START_ADDR;
    WHILE TRUE DO
	BEGIN
	IF .SATPTR EQL 0 THEN RETURN;
	IF .PCVAL GEQ .SATPTR[SAT$L_START] AND .PCVAL LEQ .SATPTR[SAT$L_END]
	THEN
	    EXITLOOP;

	SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! We found the module.  If the module is SET, search its SAT chain for the
    ! inner-most lexical entity containing the PC value.
    !
    MODPTR = .SATPTR[SAT$L_RSTPTR];
    IF NOT .MODPTR[RST$V_MODSET] THEN RETURN;
    IF NOT .MODPTR[RST$V_MOD_IN_RST] 
    THEN 
    	DBG$RST_BUILD(.MODPTR, FALSE);
    RSTPTR = 0;
    SATPTR = .MODPTR[RST$L_SAT_PTR];
    WHILE TRUE DO
	BEGIN
	IF .SATPTR EQL 0 THEN EXITLOOP;
	IF .SATPTR[SAT$L_START] GTR .PCVAL THEN EXITLOOP;
	IF .SATPTR[SAT$L_END] GEQ .PCVAL
	THEN
	    BEGIN
	    RPTR = .SATPTR[SAT$L_RSTPTR];


	    ! If this static item is not a routine or block, ignore it.
	    !
	    IF (.RPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
	       (.RPTR[RST$B_KIND] NEQ RST$K_BLOCK)
	    THEN
		0


	    ! It is a lexical entity.  If it is the first one we have found,
	    ! save its RST pointer in RSTPTR.
	    !
	    ELSE IF .RSTPTR EQL 0
	    THEN
		RSTPTR = .SATPTR[SAT$L_RSTPTR]


	    ! Otherwise, make sure it is the inner-most lexical entity so far.
	    ! If not, ignore it.
	    !
	    ELSE
		BEGIN
		WHILE .RPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		    BEGIN
		    IF .RPTR EQL .RSTPTR
		    THEN
			BEGIN
			RSTPTR = .SATPTR[SAT$L_RSTPTR];
			EXITLOOP;
			END;

		    RPTR = .RPTR[RST$L_UPSCOPEPTR];
		    END;

		END;

	    END;

	SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! If we did not find the containing lexical entity, return with MODRSTPTR
    ! and SCOPE containing zeroes.
    !
    IF .RSTPTR EQL 0 THEN RETURN;


    ! We found the scope successfully.  Return the proper RST pointers to
    ! MODRSTPTR and SCOPE.
    !
    MODRSTPTR[0] = .MODPTR;
    SCOPE[0] = .RSTPTR;


    ! Now search the CALL stack again to determine what the invocation number is
    ! for the routine which constitutes or immediately contains the scope.
    !
    INVOCNUM[0] = 0;
    ROUTPTR = .RSTPTR;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN;
	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;

    PCVAL = .DBG$RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$RUNFRAME[DBG$L_USER_FP];
    RUNFRAME_PTR = .DBG$RUNFRAME[DBG$L_NEXT_LINK];
    INCR I FROM 1 TO .SCOPE_NUMBER DO
	BEGIN
	IF (.PCVAL GEQ .ROUTPTR[RST$L_STARTADDR]) AND
	   (.PCVAL LEQ .ROUTPTR[RST$L_ENDADDR])
	THEN
	    INVOCNUM[0] = .INVOCNUM[0] + 1;

	GET_REGISTER_VALUES(.FRAMEPTR, RUNFRAME_PTR, REGVEC);
	REGPTR = .REGVEC[15];
	PCVAL = .REGPTR[0];
	REGPTR = .REGVEC[13];
	FRAMEPTR = .REGPTR[0];
	END;


    ! We are all done.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_RECORD_COMPONENT(RECSYMID, INDEX) =
!
! FUNCTION
!	This routine returns the SYMID of the N-th record component of a record
!	data object.  It accepts as input a pointer to a Data RST Entry of a
!	record ("structure") data object and an index ("N") into the list of
!	record components for the record.  This routine is used mainly to find
!	the logical successor or predecessor of a record component of a known
!	index into the record component list.  In other words, if the current
!	location is the N-th component of a record, its predecessor is the N-1
!	and its successor the N+1 component of the record.  This routine returns
!	a pointer to the Data RST Entry for such a component.
!
!	To accomplish this, the INDEX-th record component is looked up in the
!	component list in the record's Data Type RST Entry.  This gives a
!	pointer to the component's Type Component RST Entry.  A new Data Item
!	RST Entry is then build from the information in the Type Component
!	RST Entry.  This new entry is put on the Temporary RST Entry List and
!	its address is returned as the component SYMID.
!
! INPUTS
!	RECSYMID - The SYMID of the Record data object whose INDEX-th component
!		  is to be returned.
!
!	INDEX	- The index of the desired component into the record component
!		  list for RECSYMID.  The first component of a record has the
!		  INDEX value of 1.
!
! OUTPUTS
!	The SYMID of the INDEX-th component of RECSYMID is returned as the
!		  routine value.  If INDEX is out of range (no such component
!		  number), this routine returns zero.
!

    BEGIN

    MAP
	RECSYMID: REF RST$ENTRY;	! SYMID of record data object

    LOCAL
	FCODE,
	NEWRSTPTR: REF RST$ENTRY,	! Pointer to new Data Item RST Entry
	RSTPTR: REF RST$ENTRY,		! Pointer to Type Component RST Entry
	TYPCOMPLST: REF VECTOR[,LONG],	! Pointer to type component list
	TYPEPTR: REF RST$ENTRY;		! Pointer to record's Type RST Entry



    ! Check that RECSYMID points to the Data Item RST Entry for a Record object.
    ! If not, signal an internal DEBUG error.
    !
    IF .RECSYMID[RST$B_KIND] NEQ RST$K_DATA
    THEN
	$DBG_ERROR('RSTACCESS\RECORD_COMPONENT 10');

    DBG$STA_SYMTYPE(.RECSYMID,FCODE,TYPEPTR);
    IF .FCODE EQL RST$K_TYPE_ARRAY
    THEN
	BEGIN
	LOCAL DSCADDR,NDIMS,DIMVECPTR,BITSIZE;
	DBG$STA_TYP_ARRAY(.TYPEPTR,DSCADDR,TYPEPTR,NDIMS,DIMVECPTR,BITSIZE);
	END;

    IF .TYPEPTR[RST$B_FCODE] NEQ RST$K_TYPE_RECORD
    THEN
	$DBG_ERROR('RSTACCESS\RECORD_COMPONENT 20');


    ! If the INDEX value is out of range, return zero to the caller.  Otherwise,
    ! pick up a pointer to the INDEX-th Type Component RST Entry.
    !
    IF (.INDEX LEQ 0) OR (.INDEX GTR .TYPEPTR[RST$L_TYPCOMPCNT]) THEN RETURN 0;
    TYPCOMPLST = TYPEPTR[RST$A_TYPCOMPLST];
    RSTPTR = .TYPCOMPLST[.INDEX - 1];
    IF .RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP
    THEN
	$DBG_ERROR('RSTACCESS\RECORD_COMPONENT 30');


    ! Now construct a Data Item RST Entry from the Type Component RST Entry,
    ! make its up-scope pointer point to the RECSYMID Data Item RST Entry,
    ! and return the address (i.e., SYMID) of the new RST entry to the caller.
    ! Note that the new RST entry is put on the Temporary RST Entry List.
    !
    NEWRSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
    NEWRSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .NEWRSTPTR;
    NEWRSTPTR[RST$L_DSTPTR] = .RSTPTR[RST$L_DSTPTR];
    NEWRSTPTR[RST$L_UPSCOPEPTR] = .RECSYMID;
    NEWRSTPTR[RST$B_KIND] = RST$K_DATA;
    NEWRSTPTR[RST$L_TYPEPTR] = .RSTPTR[RST$L_TYPEPTR];
    RETURN .NEWRSTPTR;

    END;

GLOBAL ROUTINE DBG$STA_RECORD_INDEX(RECSYMID, COMPSYMID) =
!
! FUNCTION
!	This routine accepts the SYMID of a Record data object and the SYMID
!	of a component of that record and it returns the index of the component
!	in the record's component list.  Both the Record and Component SYMIDs
!	should point to Data Item RST Entries (kind is RST$K_DATA).  The re-
!	turned index starts at 1 so that the index of the first component of
!	the record is 1, the index of the second component is 2, and so forth.
!	This routine is used together with routine DBG$STA_RECORD_COMPONENT in
!	the processing of logical predecessors and successors.
!
!	If the COMPSYMID object is not a component of the RECSYMID object or if
!	the RECSYMID object is not of a Record type, an internal DEBUG error is
!	signalled.
!
!	The routine does it job by searching the Type Component List in the
!	Data Type RST Entry for the record type for a Type Component RST Entry
!	which has the same DST pointer as the COMPSYMID Data Item RST Entry.
!	When such an entry is found, its index in the list is returned.
!
! INPUTS
!	RECSYMID - The SYMID of a Record ("structure") data object.  Its kind
!		  must be RST$K_DATA.
!
!	COMPSYMID - The SYMID of a component of the RECSYMID record.  Its kind
!		  must also be RST$K_DATA.
!
! OUTPUTS
!	The index of the COMPSYMID data object in the record component list for
!		  the RECSYMID data record.  The first component has index 1.
!

    BEGIN

    MAP
	RECSYMID: REF RST$ENTRY,	! Pointer to Data RST Entry for record
	COMPSYMID: REF RST$ENTRY;	! Pointer to Data RST Entry for a com-
					!      ponent within the above record

    LOCAL
	FCODE,
	RSTPTR: REF RST$ENTRY,		! Pointer to Type Component RST Entry
	TYPCOMPLST: REF VECTOR[,LONG],	! Pointer to type component list in the
					!      Data Type RST Entry
	TYPEPTR: REF RST$ENTRY;		! Pointer to Type RST Entry for record



    ! Make sure RECSYMID points to a Data Item RST Entry for a record and that
    ! COMPSYMID points to a Data Item RST Entry.  Get a pointer to the Type RST
    ! Entry for the record type.
    !
    IF (.RECSYMID[RST$B_KIND] NEQ RST$K_DATA) OR
       (.COMPSYMID[RST$B_KIND] NEQ RST$K_DATA)
    THEN
	$DBG_ERROR('RSTACCESS\RECORD_INDEX 10');

    DBG$STA_SYMTYPE(.RECSYMID,FCODE,TYPEPTR);
    IF (.FCODE EQL RST$K_TYPE_ARRAY)
    THEN
	BEGIN
	LOCAL DSCADDR,NDIMS,DIMVECPTR,BITSIZE;
	DBG$STA_TYP_ARRAY(.TYPEPTR,DSCADDR,TYPEPTR,NDIMS,DIMVECPTR,BITSIZE);
	END;

    IF .TYPEPTR[RST$B_FCODE] NEQ RST$K_TYPE_RECORD
    THEN
	$DBG_ERROR('RSTACCESS\RECORD_INDEX 20');


    ! Now loop through the record components for the RECSYMID Record Data Type.
    ! For each component, we get an index and a pointer to the corresponding
    ! Type Component RST Entry.  If that Type Component RST Entry has the same
    ! DST pointer as COMPSYMID, we return that component's index.
    !
    TYPCOMPLST = TYPEPTR[RST$A_TYPCOMPLST];
    INCR INDEX FROM 1 TO .TYPEPTR[RST$L_TYPCOMPCNT] DO
	BEGIN
	RSTPTR = .TYPCOMPLST[.INDEX - 1];
	IF .RSTPTR[RST$L_DSTPTR] EQL .COMPSYMID[RST$L_DSTPTR] THEN RETURN .INDEX;
	END;


    ! We did not find COMPSYMID in the component list.  Signal an error.
    !
    $DBG_ERROR('RSTACCESS\RECORD_INDEX 30');
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_REGISTER_NAME(REGDESCR) =
!
! FUNCTION
!	This routine converts a Register Descriptor into a Counted ASCII name
!	for the corresponding register.  A Register Descriptor is produced
!	from an absolute address by routine DBG$STA_ADDRESS_TO_REGDESCR if
!	the address points into the DBG$REG_VALUES register save area set up
!	by DBG$STA_SETCONTEXT.  The Register Descriptor contains the register
!	number, a byte offset, and the scope number of the register described.
!	A register address is not a normal address, and should be printed as
!	a scope number or scope name followed by a register name.  This routine
!	builds such a register name as a Counted ASCII string (for example
!	"2\%R5") and returns a pointer to that string.
!
! INPUTS
!	REGDESCR - The Register Descriptor which describes the register name
!		  to be generated.
!
! OUTPUTS
!	A pointer to a Counted ASCII string containing the appropriate register
!		  name is returned as the routine value.
!

    BEGIN

    MAP
	REGDESCR: DBG$REGDESCR;		! Input Register Descriptor

    LOCAL
	INDEX,				! Character index within REGTABLE entry
	INVOCNUM,			! Invocation number for scope routine
	LENGTH,				! Current length of ASCII string
	MODRSTPTR,			! Module SYMID containing the scope
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to Counted ASCII string con-
					!      taining the built register name
	PATHDESC,			! Pointer to Pathname Descriptor for
					!      routine name of desired scope
	PATHSTRING: REF VECTOR[,BYTE],	! Pointer to Counted ASCII string for
					!      routine name of desired scope
	REGPTR: REF VECTOR[,BYTE],	! Pointer to register name in REGTABLE
	RSTPTR,				! Pointer to RST entry of scope routine
	SCOPENUM,			! Temporary value of scope number
	TEMPNUM,			! Temporary in computing scope number
	TEMPSTR: VECTOR[12,BYTE];	! Temporary buffer for scope number

    BIND
	REGTABLE = UPLIT ('R0  ', 'R1  ', 'R2  ', 'R3  ', ! Register name table
			  'R4  ', 'R5  ', 'R6  ', 'R7  ', !
			  'R8  ', 'R9  ', 'R10 ', 'R11 ', !
			  'AP  ', 'FP  ', 'SP  ', 'PC  ', !
			  'PSL '): VECTOR[,LONG];



    ! Check that we really have a valid Register Descriptor.
    !
    IF (.REGDESCR[DBG$V_REGD_SENTINEL] NEQ %X'2D') OR
       (.REGDESCR[DBG$B_REGD_REGNUM] GTR 16)
    THEN
	$DBG_ERROR('RSTACCESS\REGISTER_NAME');


    ! If the scope specified by the the Register Descriptor is in a set module,
    ! we should be able to symbolize the scope as a routine name.  We thus call
    ! NUMBERED_SCOPE to get a routine SYMID for the scope.  If this succeeds,
    ! we convert that SYMID to a name string (in Counted ASCII) and leave that
    ! name in a temporary memory block pointed to by NAMEPTR.
    !
    SCOPENUM = .REGDESCR[DBG$W_REGD_SCOPENUM];
    IF .DBG$GB_MOD_PTR[MODE_SYMBOLS]
    THEN
        DBG$STA_NUMBERED_SCOPE(.SCOPENUM, MODRSTPTR, RSTPTR, INVOCNUM)
    ELSE
    	MODRSTPTR = 0;

    IF .MODRSTPTR NEQ 0
    THEN
	BEGIN
	IF .INVOCNUM NEQ 0 THEN RSTPTR = DBG$BUILD_INVOC_RST(.RSTPTR, .INVOCNUM);
	DBG$STA_SYMPATHNAME(.RSTPTR, PATHDESC);
	DBG$NPATHDESC_TO_CS(.PATHDESC, PATHSTRING);
	LENGTH = .PATHSTRING[0];
	NAMEPTR = DBG$GET_TEMPMEM((.LENGTH + 8 + %UPVAL - 1)/%UPVAL);
	CH$MOVE(.LENGTH + 1, .PATHSTRING, .NAMEPTR);
	END


    ! No specific routine name can be found for this scope in the RST.  We
    ! therefore must represent the scope by a scope number.  We first get a
    ! temporary memory block and initialize an empty Counted ASCII string in
    ! it.  We then convert the register's scope number to a decimal Counted
    ! ASCII string.  This becomes the numeric scope which preceeds the actual
    ! register name (for example, the "2" in "2\%R5").
    !
    ELSE
	BEGIN
	NAMEPTR = DBG$GET_TEMPMEM(5);
	LENGTH = 0;
	WHILE TRUE DO
	    BEGIN
	    TEMPNUM = .SCOPENUM/10;
	    TEMPSTR[.LENGTH] = .SCOPENUM - .TEMPNUM*10 + '0';
	    LENGTH = .LENGTH + 1;
	    IF .TEMPNUM EQL 0 THEN EXITLOOP;
	    SCOPENUM = .TEMPNUM;
	    END;

	INCR I FROM 1 TO .LENGTH DO
	    NAMEPTR[.I] = .TEMPSTR[.LENGTH - .I];

	END;


    ! We now have the scope name as either a routine name or a scope number in
    ! the NAMEPTR buffer.  Next we fill in the "\%" that separates the scope
    ! name from the register name.
    !
    NAMEPTR[.LENGTH + 1] = '\';
    NAMEPTR[.LENGTH + 2] = '%';
    LENGTH = .LENGTH + 2;


    ! Now fill in the register name itself.  We look it up in REGTABLE, where
    ! each register name is given as four ASCII characters.  This code assumes
    ! that each register name in REGTABLES ends with at least one blank.
    !
    REGPTR = REGTABLE[.REGDESCR[DBG$B_REGD_REGNUM]];
    INDEX = 0;
    WHILE .REGPTR[.INDEX] NEQ ' ' DO
	BEGIN
	LENGTH = .LENGTH + 1;
	NAMEPTR[.LENGTH] = .REGPTR[.INDEX];
	INDEX = .INDEX + 1;
	END;


    ! Finally, fill in "+offset" if the offset is non-zero.  (The offset can
    ! only have values 1, 2, or 3 in this case.)
    !
    IF .REGDESCR[DBG$V_REGD_OFFSET] NEQ 0
    THEN
	BEGIN
	NAMEPTR[.LENGTH + 1] = '+';
	NAMEPTR[.LENGTH + 2] = .REGDESCR[DBG$V_REGD_OFFSET] + '0';
	LENGTH = .LENGTH + 2;
	END;


    ! Now return a pointer to the Counted ASCII register name string.
    !
    NAMEPTR[0] = .LENGTH;
    RETURN .NAMEPTR;

    END;

GLOBAL ROUTINE DBG$STA_SAME_DST_OBJECT(SYMID1, SYMID2) =
!
! FUNCTION
!	This routine determines whether two SYMIDs refer to the same DST object.
!	To do so, it checks that the corresponding RST entries have the same
!	kind and the same DST pointer.  (Data records and their types point to
!	the same DST record; hence the kind must be checked as well.)
!
! INPUTS
!	SYMID1	- The SYMID of the first of the two symbols to be compared.
!
!	SYMID2	- The SYMID of the second of the two symbols to be compared.
!
! OUTPUTS
!	The value TRUE is returned if both symbols are of the same kind and have
!		  the same SYMID.  The value FALSE is returned otherwise.
!

    BEGIN

    MAP
	SYMID1: REF RST$ENTRY,		! Pointer to first RST entry
	SYMID2: REF RST$ENTRY;		! Pointer to second RST entry



    ! Return the desired boolean value.
    !
    IF (.SYMID1[RST$B_KIND] EQL .SYMID2[RST$B_KIND]) AND
       (.SYMID1[RST$L_DSTPTR] EQL .SYMID2[RST$L_DSTPTR])
    THEN
	RETURN TRUE;

    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$STA_SETCONTEXT(SYMID): NOVALUE =
!
! FUNCTION
!	This routine sets up the context needed for subsequent DST value spec
!	evaluations.  This specifically means determining the VAX CALL frame
!	and associated register values which are to be used for evaluating value
!	specs and determining symbol addresses.  This routine must therefore
!	be called before routines DBG$STA_SYMTYPE, DBG$STA_SYMVALUE, and all
!	routines of the form DBG$STA_TYPE_xxx.  Failure to do so may cause in-
!	correct value computations.
!
!	The context is defined by an input SYMID.  The innermost invocable enti-
!	ty (i.e. routine) in the environment of the symbol's declaration is
!	looked up in the VAX CALL stack and the associated register set is loc-
!	ated.  If an invocation number is attached to the SYMID, that is taken
!	into account.  Context will not be established (and the previous context
!	will be deleted) if the input SYMID is zero or if the symbol's environ-
!	ment is not presently active.  If context is not established, subsequent
!	value specs may still be evaluated, but if they refer to any register
!	values or locations (i.e., to any context) an error will be signalled.
!
! INPUTS
!	SYMID	- The SYMID of the symbol whose environment of declaration is to
!		  be used to define the context of subsequent value spec.  SYMID
!		  must be of kind RST$K_DATA or RST$K_TYPCOMP.  If SYMID is zero
!		  no context is established.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to the input RST entry

    OWN
	SPVALUE: REF VECTOR[,LONG];	! Current CALL frame's SP value

    LOCAL
	CURRENT_REG: REF VECTOR[,LONG],	! Pointer to vector of current register
					!      values (at top of stack)
	ENDADDR,			! The routine's PC end address
	FRAME_FOUND_FLAG,		! Flag set to TRUE when a CALL frame for
					!      the desired routine is found
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to current VAX CALL frame
	INVOC_COUNT,			! Number of invocations of routine
					!      found so far in CALL stack
	INVOCNUM,			! The desired invocation number
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	J,				! CALL frame register-vector index
	PCVAL,				! Current CALL frame's PC value
	MODPTR: REF RST$ENTRY,		! Current Module
	REGMASK: BITVECTOR[16],		! Register save mask from the CALL frame
	REGPTR: REF VECTOR[,LONG],	! Pointer to a register's save location
	REGSAVELOC: REF VECTOR[,LONG],	! Pointer to CALL frame register save
					!      area for registers R0 - R11
	REGVEC: VECTOR[17, LONG],	! Vector of pointers to save areas for
					!      the current frame's registers
	ROUTPTR: REF RST$ENTRY,		! Pointer to Routine RST Entry of rout-
					!      ine to look for in CALL stack
	RSTPTR: REF RST$ENTRY,		! RST pointer from SAT entry
	RUNFRAME_PTR,			! Pointer to current entry in CALL com-
					!      mand runframe stack (needed by
					!      the GET_REGISTER_VALUES routine)
	SATPTR: REF SAT$ENTRY,		! Pointer to Static Address Table entry
					!      for possible nested routine
	SCOPE_IS_NUMERIC,		! Set to TRUE if context is a numeric
					!      scope, not an RST routine entry
	SCOPE_NUMBER,			! Scope number of the current context
	STARTADDR;			! The routine's PC start address

    ENABLE
	SETCONTEXT_ERROR_HANDLER;	! Set up error handler for this routine


    ! If the input SYMID is zero, clear the current context and return.
    !
    DBG$SCOPE_NUMBER = 0;
    IF .SYMID EQL 0
    THEN
	BEGIN
	CURRENT_REG = DBG$RUNFRAME[DBG$L_USER_REGS];
	DBG$REG_SYMID = 0;
	INCR I FROM 0 TO 16 DO
	    BEGIN
	    DBG$REG_VECTOR[.I] = 0;
	    DBG$REG_VALUES[.I] = .CURRENT_REG[.I];
	    END;

	RETURN;
	END;


    ! We have a non-zero SYMID.  Make sure SYMID is of a valid kind.
    !
    IF (.SYMID[RST$B_KIND] EQL RST$K_TYPE)  OR
       (.SYMID[RST$B_KIND] EQL RST$K_OVERLOAD)
    THEN
	$DBG_ERROR('RSTACCESS\SETCONTEXT');


    ! Set the current context to "not established".  We do this by zeroing all
    ! the register save location pointers in DBG$REG_VECTOR.  Also save the in-
    ! put SYMID for later use in error messages.
    !
    INCR I FROM 0 TO 16 DO DBG$REG_VECTOR[.I] = 0;
    DBG$REG_SYMID = .SYMID;


    ! Find the RST entry of the inner-most routine containing the declaration
    ! of the SYMID symbol.  If no such routine exists (because the symbol is
    ! declared at the module level) return with no context set.  If the con-
    ! text is a numeric scope (i.e., the context N levels down in the VAX call
    ! stack), we simply set the SCOPE_IS_NUMERIC flag and pick up the value of
    ! N from the module RST entry--this is how the context is set for register
    ! symbols in a specified numeric scope.
    !
    SCOPE_IS_NUMERIC = FALSE;
    ROUTPTR = .SYMID;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE
	THEN
	    BEGIN
	    IF NOT .ROUTPTR[RST$V_MODNUMSCP] THEN RETURN;
	    SCOPE_IS_NUMERIC = TRUE;
	    INVOCNUM = .ROUTPTR[RST$L_MODSCPNUM];
	    STARTADDR = 0;
	    ENDADDR = %X'FFFFFFFF';
	    EXITLOOP;
	    END;

	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;


    ! If this is a regular routine scope (i.e., it is not a numeric scope for
    ! a register reference), pick up the routine PC address range and determine
    ! what the corresponding invocation number is (default is zero).
    !
    IF NOT .SCOPE_IS_NUMERIC
    THEN
	BEGIN
	STARTADDR = .ROUTPTR[RST$L_STARTADDR];
	ENDADDR = .ROUTPTR[RST$L_ENDADDR];
	INVOCNUM = 0;
	IF .SYMID[RST$V_INVOCNUM]
	THEN
	    BEGIN
	    INVPTR = .SYMID[RST$L_SYMCHNPTR];
	    INVOCNUM = .INVPTR[RST$L_INVOCNUM];
	    END;

	END;


    ! Initialize the PC, the Frame Pointer, the scope number, and the register
    ! values to their current (top of stack) values.
    !
    PCVAL = .DBG$RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$RUNFRAME[DBG$L_USER_FP];
    SCOPE_NUMBER = 0;
    CURRENT_REG = DBG$RUNFRAME[DBG$L_USER_REGS];
    INCR I FROM 0 TO 16 DO
	REGVEC[.I] = CURRENT_REG[.I];


    ! Now search through the CALL frames on the VAX stack looking for the prop-
    ! er invocation of the ROUTPTR routine or for the specified numeric scope.
    ! Pick up all register save addresses in the stack along the way.
    !
    RUNFRAME_PTR = .DBG$RUNFRAME[DBG$L_NEXT_LINK];
    INVOC_COUNT = 0;
    WHILE TRUE DO
	BEGIN


	! If we got to the bottom of the stack without finding the desired
	! invocation, return with the context not set.
	!
	IF (.PCVAL EQL 0) OR (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL)
	THEN
	    RETURN;


	! If this is a CALL frame of the routine we are looking for, increment
	! the invocation count.  When that reaches the desired invocation number
	! we have found the desired CALL frame and exit the loop.
	!
	IF (.PCVAL GEQU .STARTADDR) AND (.PCVAL LEQU .ENDADDR)
	THEN
	    BEGIN


	    ! The PC from this CALL frame is in the address range of the routine
	    ! we are looking for.  However, to make sure the PC is not really in
	    ! a nested routine within the desired routine, we search the Module
	    ! SAT starting at the desired routine's SAT entry looking for nested
	    ! routines which cover the CALL frame's PC value.  If we find such a
	    ! routine, the CALL frame is not for the desired routine.
	    !
	    FRAME_FOUND_FLAG = TRUE;
	    SATPTR = 0;
	    IF NOT .SCOPE_IS_NUMERIC
	    THEN
		BEGIN
		SATPTR = .ROUTPTR[RST$L_RTNSATPTR];

                ! WARNING -- We can get into trouble here.  Previously, we have
                ! assumed that the SAT is always around.  This may not be the
		! case if this module has been canceled.  There are times when
		! the module could be canceled and then set again to make us
		! believe the the SAT is valid for this RST, but it is not!  To
		! correct the problem, when a module is canceled the field
		! RST$L_RTNSATPTR is set to ZERO for each routine.
		! So if the module for this RST has been canceled, SATPTR will
                ! be zero from the above statement. The problem is that this
		! assumes there are no nested routines that truly require the
		! correct context information.  This is, of course, WRONG.  A
		! way of saving and getting to the SAT information must be
		! found in the future.  B.A. Becker  MAY-1984
                !
		IF .SATPTR NEQ 0
                THEN
                    SATPTR = .SATPTR[SAT$L_FLINK];

		END;

	    WHILE TRUE DO
		BEGIN


		! If there are no more SAT entries in the chain or if they no
		! longer cover the PCVAL address, exit the SAT loop.
		!
		IF .SATPTR EQL 0 THEN EXITLOOP;
		IF .SATPTR[SAT$L_START] GTRU .PCVAL THEN EXITLOOP;


		! If this SAT entry is for a routine which covers the PCVAL
		! address, we clear FRAME_FOUND_FLAG because the PC is in this
		! nested routine instead of the routine we are looking for.
		!
		RSTPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.PCVAL GEQU .SATPTR[SAT$L_START]) AND
		   (.PCVAL LEQU .SATPTR[SAT$L_END])   AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    FRAME_FOUND_FLAG = FALSE;
		    EXITLOOP;
		    END;


		! Link on to the next SAT entry.
		!
		SATPTR = .SATPTR[SAT$L_FLINK];
		END;


	    ! If the CALL frame we found really is for the desired routine,
	    ! check the invocation count.  If this is the desired invocation,
	    ! exit the CALL stack loop.  Otherwise, increment the invocation
	    ! count and keep looping.
	    !
	    IF .FRAME_FOUND_FLAG
	    THEN
		BEGIN
		IF .INVOC_COUNT EQL .INVOCNUM THEN EXITLOOP;
		INVOC_COUNT = .INVOC_COUNT + 1;
		END;

	    END;


	! We have not found the desired frame yet.  Dig out the register save
	! locations in this CALL frame and save those addresses in REGVEC.
	!
	GET_REGISTER_VALUES(.FRAMEPTR, RUNFRAME_PTR, REGVEC);


	! Determine what the value of SP (the Stack Pointer) is for the current
	! CALL frame and save that in the OWN variable SPVALUE.  Then make the
	! save-location pointer in REGVEC point to SPVALUE.  (Since SP does not
	! have a true save-location, the OWN variable fakes one.)
	!
	REGPTR = .REGVEC[14];
	SPVALUE = .REGPTR[0];
	REGVEC[14] = SPVALUE;


	! Dig out the values of PC and FP for the current CALL frame.  Then
	! increment the scope number and loop for the next stack frame.
	!
	REGPTR = .REGVEC[15];
	PCVAL = .REGPTR[0];
	REGPTR = .REGVEC[13];
	FRAMEPTR = .REGPTR[0];
	SCOPE_NUMBER = .SCOPE_NUMBER + 1;
	END;


    ! We have found the CALL frame and thus the context we wanted.  Set the
    ! address of each register's save location in DBG$REG_VECTOR and the regis-
    ! ter's value in DBG$REG_VALUES.  This makes the context available to the
    ! value spec routines.  Then set the scope number in DBG$SCOPE_NUMBER and
    ! return to the caller.
    !
    INCR I FROM 0 TO 16 DO
	BEGIN
	REGPTR = .REGVEC[.I];
	DBG$REG_VECTOR[.I] = .REGPTR;
	IF .REGPTR NEQ 0 THEN DBG$REG_VALUES[.I] = .REGPTR[0];
	END;

    DBG$REG_VALUES[16] = (.DBG$REG_VALUES[16] AND %X'0000FFFF') OR
			(.DBG$RUNFRAME[DBG$L_USER_PSL] AND %X'FFFF0000');
    DBG$SCOPE_NUMBER = .SCOPE_NUMBER;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SETREGISTERS: NOVALUE =
!
! FUNCTION
!	This routine re-sets all register values in the current context (as
!	established by DBG$STA_SETCONTEXT) from the DBG$REG_VALUES vector.
!	This is done by copying each register's value from DBG$REG_VALUES to
!	the register save location in the VAX CALL stack (or in the Debugger's
!	save area for the top of stack register set).  The addresses of these
!	save locations is given by DBG$REG_VECTOR.  This routine must be called
!	at the end of each DEPOSIT command since this is the command which may
!	have changed the values of the registers in the current context.
!
!	As a side effect, this routine also clears the current context.  It is
!	thus necessary to call DBG$STA_SETCONTEXT again before evaluating more
!	value specs containing register references.
!
! INPUTS
!	DBG$REG_VECTOR and DBG$REG_VALUES are the implicit inputs.  There are
!	no input parameters.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	REGPTR: REF VECTOR[,LONG],	! Pointer to register save location
	PSWPTR: REF VECTOR[,WORD];	! Pointer to PSW save location



    ! Loop over the register set, re-setting all register values we can in the
    ! current context.  Note that SP (R14) cannot be explicitly restored.
    !
    DBG$REG_VECTOR[14] = 0;
    INCR I FROM 0 TO 15 DO
	BEGIN
	REGPTR = .DBG$REG_VECTOR[.I];
	IF .REGPTR NEQ 0 THEN REGPTR[0] = .DBG$REG_VALUES[.I];
	DBG$REG_VECTOR[.I] = 0;
	END;


    ! Also re-set the Processor Status Word (PSW) in its save location.
    ! Then return.
    !
    PSWPTR = .DBG$REG_VECTOR[16];
    IF .PSWPTR NEQ 0 THEN PSWPTR[0] = .DBG$REG_VALUES[16];
    DBG$REG_VECTOR[16] = 0;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYM_IS_LITERAL (SYMID) =
!
! FUNCTION
!	This routine accepts a symbol identifier and determines whether
!	the symbol represents a literal value. The same information can
!	be obtained by calling SYMVALUE, but that routine may have
!	side effects. This routine uses the same logic as SYMVALUE
!	and its subroutines VALSPEC and EVAL_MAT_SPEC, but does
!	not have the side effects associated with actually computing
!	the value.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose "value" is to be returned.
!
! OUTPUTS
!	The return value is one of:
!	TRUE	- The symbol does represent a literal
!	FALSE	- The symbol does not represent a literal
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
	BLITRLR: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
	BLIVALSPEC: BLOCK[8,BYTE]	! Value Spec buffer for Bliss special
		FIELD(DST$VS_HDR_FIELDS), !    cases DST record
	DSTPTR: REF DST$RECORD,		! Pointer to symbol's DST record
    	MSPTR: REF DST$MATER_SPEC,	! Pointer to a Materialization Spec
    	VSPTR: REF DST$VAL_SPEC;	! Pointer to a Value Spec



    ! If the input symid is zero, return "false" for "does not represent
    ! a literal". We need to check this here so we don't accvio later on
    ! in the routine.
    !
    IF .SYMID EQL 0 THEN RETURN FALSE;


    ! If the RST kind is not data, then the symbol is not a literal.
    !
    IF .SYMID[RST$B_KIND] NEQ RST$K_DATA
    THEN
    	RETURN FALSE;


    ! For RST records which are of kind data, obtain the DST record
    ! which holds the value specification and act accordingly.
    !
    DSTPTR = .SYMID[RST$L_DSTPTR];
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle all normal DST records, i.e. those of the standard format.
    	! Obtain a pointer to the Value Spec.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
	 DST$K_ENTRY, DST$K_RTNBEG, DST$K_BLKBEG,
	 DST$K_RECBEG, DST$K_ENUMELT]:
            VSPTR = DSTPTR[DST$B_VFLAGS];


	! Handle the Bliss Special Cases DST record.  Construct a Value Spec
	! from the VFLAGS and VALUE fields in the record (which are not adjacent
	! in this particular record).
	!
	[DST$K_BLI]:
	    BEGIN
	    BLIVALSPEC[DST$B_VS_VFLAGS] = .DSTPTR[DST$B_BLI_VFLAGS];
	    BLITRLR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	    BLIVALSPEC[DST$L_VS_VALUE] = .BLITRLR[DST$L_BLI_VALUE];
    	    VSPTR = BLIVALSPEC;

    	    ! See the corresponding hack in DBG$STA_SYMVALUE.
    	    !
	    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL
	    THEN
	   	VSPTR[DST$V_VS_VALKIND] = DST$K_VALKIND_ADDR;
	    END;


    	! BLISS fields. Return TRUE - these are literal values.
    	!
    	[DST$K_BLIFLD]:
    	    RETURN TRUE;

	! Any other DST record does not represent a literal.
	!
	[INRANGE]:
    	    RETURN FALSE;

	TES;


    ! If we fall through to here, VSPTR points to a Value Spec.
    ! If the value is given by a trailing Value Spec, we get to that Value
    ! Spec.  We loop in case the indirection is repeated.
    !
    WHILE .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
	VSPTR = VSPTR[DST$A_VS_TVS_BASE] + .VSPTR[DST$L_VS_TVS_OFFSET];


    ! If the Value Spec gives the offset to a descriptor (in the DST),
    ! or the Value Spec is a Bit Offset Value Spec, then it does not
    ! represent a literal.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_DSC
    OR .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_BITOFFS
    THEN
    	RETURN FALSE;


    ! If this is a Value-Spec-Follows value spec, a more complex value spec
    ! follows the VFLAGS field.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
    	BEGIN


    	! If the object is not statically allocated, then it is not a literal.
    	!
	IF .VSPTR[DST$B_VS_ALLOC] NEQ DST$K_VS_ALLOC_STAT
	THEN
	    RETURN FALSE;

    	! If we get here, the object is statically allocated.
    	! Obtain the Materialization Spec.
    	!
	MSPTR  = VSPTR[DST$A_VS_MATSPEC];


    	! If the Materialization Spec is of kind "R-Value", then
    	! it is a literal.
    	!
	IF .MSPTR[DST$B_MS_KIND] EQL DST$K_MS_RVAL
	THEN
	    RETURN TRUE

    	ELSE
            RETURN FALSE;
	END;


    ! If we fall through to here, we have an ordinary garden-variety
    ! Value Spec. If it is a literal, return true.
    !
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL
    THEN
    	RETURN TRUE

    ELSE
    	RETURN FALSE;
    END;

GLOBAL ROUTINE DBG$STA_SYMKIND(SYMID, KIND): NOVALUE =
!
! FUNCTION
!	This routine returns the "kind" of a specified symbol.  The symbol is
!	represented by a symbol identifier as produced by DBG$STA_GETSYMBOL or
!	DBG$STA_GETSYMOFF.  The returned "kind" is the same kind as originally
!	produced by those two routines.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose kind is to be returned.
!
!	KIND	- The address of a longword location where the symbol's kind
!		  code should be returned.
!
! OUTPUTS
!	KIND	- The "kind" of the SYMID symbol is returned to KIND.  This is
!		  a small integer with the following possible values:
!
!			RST$K_MODULE	-- SYMID is a Module
!			RST$K_ROUTINE	-- SYMID is a Routine
!			RST$K_BLOCK	-- SYMID is a Block
!			RST$K_ENTRY	-- SYMID is an Entry Point
!			RST$K_LABEL	-- SYMID is a Label
!			RST$K_LINE	-- SYMID is a Line
!			RST$K_DATA	-- SYMID is a Data Item
!			RST$K_TYPE	-- SYMID is a Data Type
!
!	No value is returned by DBG$STA_SYMKIND.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to the RST entry whose "kind"
					!      is to be returned.
	KIND: REF VECTOR[1];		! Pointer to the location where the
					!      kind is to be returned.



    ! Make sure SYMID points to a valid RST entry (or at least seems to).  Then
    ! copy the entry's kind to KIND and return.
    !
    IF .SYMID[RST$B_KIND] LEQ RST$K_KIND_MINIMUM OR
       .SYMID[RST$B_KIND] GTR RST$K_KIND_MAXIMUM
    THEN
	$DBG_ERROR('RSTACCESS\SYMKIND');

    KIND[0] = .SYMID[RST$B_KIND];
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMNAME(SYMID, NAMEPTR): NOVALUE =
!
! FUNCTION:
!	This routine accepts a symbol identifier and returns the corresponding
!	symbol's name without any qualification.  The symbol identifier is the
!	unique identifier produced by DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.
!	The returned symbol name is represented as a counted ASCII string.
!
!	Since this routine does not produce a completely qualified, unambiguous
!	name, it is primarily used to get the names of data record components.
!	Such component names are needed by language-specific routines when
!	printing the values of data records.
!
! INPUTS:
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose name is to be returned.
!
!	NAMEPTR	- The address of a longword location where a pointer to the
!		  symbol's name should be returned.
!
! OUTPUTS:
!	NAMEPTR	- A pointer to the counted ASCII string giving the symbol's
!		  bottom level, unqualified name is returned to NAMEPTR.
!
!	No value is returned by DBG$STA_SYMNAME.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to the RST entry whose name
					!      string is to be returned.
	NAMEPTR: REF VECTOR[1];		! Pointer to the location where the
					!      string address is to be returned.



    ! Make sure SYMID seems to point to a valid RST entry.  Copy the address
    ! of the name string to NAMEPTR by calling GET_DST_NAME.  Then return.
    !
    IF .SYMID[RST$B_KIND] LSS RST$K_KIND_MINIMUM OR
       .SYMID[RST$B_KIND] GTR RST$K_KIND_MAXIMUM
    THEN
	$DBG_ERROR('RSTACCESS\SYMNAME');

    NAMEPTR[0] = DBG$GET_DST_NAME(.SYMID[RST$L_DSTPTR]);
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMPARENT(SYMID) =
!
! FUNCTION
!	This routine returns the parent data item of a record (structure) compo-
!	nent.  Thus, if there is a data item A.B(2).C, then the parent of C is
!	B and the parent of B is A.  A does not have any parent.  This routine
!	should only be called when the data component has been looked up direct-
!	ly in the RST via DBG$STA_GETSYMBOL, as would be done in languages like
!	PL/I or Cobol where record qualification need not be explicitly stated.
!
! INPUTS
!	SYMID	- The SYMID returned by DBG$STA_GETSYMBOL for the data item
!		  whose parent data item is to be found.  This symbol must
!		  be of kind RST$K_DATA.
!
! OUTPUTS
!	The SYMID of the input symbol's parent symbol is returned as the routine
!		  value.  If the input symbol does not have a parent, i.e. if
!		  the input symbol is not a record component but a separate data
!		  item in its own right, zero is returned as the routine value.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the first up-scope symbol
					!      --this may be the parent symbol



    ! Make sure the input parameter is the SYMID of a Data Item RST Entry.
    !
    IF .SYMID[RST$B_KIND] NEQ RST$K_DATA
    THEN
	$DBG_ERROR('RSTACCESS\SYMPARENT');


    ! Get the first RST entry up-scope from the input symbol.  If this is a Data
    ! Item RST Entry, return its SYMID as the routine value.  Otherwise, return
    ! a zero as the routine value.
    !
    RSTPTR = .SYMID[RST$L_UPSCOPEPTR];
    IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA THEN RETURN .RSTPTR;
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_SYMPATHNAME(SYMID, PATHNAME): NOVALUE =
!
! FUNCTION
!	This routine accepts a symbol identifier and returns the corresponding
!	symbol's fully qualified pathname.  The symbol identifier is the unique
!	identifier produced by the DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF rou-
!	tine.  The returned pathname is represented in internal format by a
!	pathname descriptor which includes the symbol name with all possible
!	pathname qualification and all possible data record qualification.  This
!	does not include array subscripts, however.
!
!	This routine is called when a symbol's name is to be printed in a com-
!	pletely unambiguous form.  The returned pathname is not in a directly
!	printable form, but can relatively easily be converted to a character
!	string by language-specific routines.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose complete pathname is to be returned.
!
!	PATHNAME - The address of a longword location where a pointer to the
!		  symbol's pathname descriptor should be returned.
!
! OUTPUTS
!	PATHNAME - A full pathname descriptor for the SYMID symbol is generated
!		  and a pointer to that descriptor is returned to PATHNAME.  The
!		  descriptor will disappear after the processing of the current
!		  DEBUG command.
!
!	No value is returned by DBG$STA_SYMPATHNAME.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input RST entry
	PATHNAME: REF VECTOR[1];	! Pointer to returned pathname descr.

    LOCAL
	COMPCNT,			! Number of data components in pathname
	DATACNT,			! Number of Data RST Entries in chain
	INVOC_LOC,			! Location in NAMELIST where invocation
					!      number belongs (inner-most rout-
					!      ine in SYMID's environment)
	INVOCNUM,			! The invocation number itself
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	J,				! Pathname vector index
	LINE_END,			! Line end address (not actually used)
	LINE_LWRDS,			! Number of longwords needed for line
					!      number counted ASCII string
	LINE_NUM,			! The line number used to identify an
					!      anonymous lexical entity
	LINE_NUM_FOUND,			! Set to TRUE if a line number RST entry
					!      is in the symbol's up-scope chain
	LINE_NUM_LOC,			! Location in NAMELIST before which the
					!      line number should be inserted
	LINE_NUM_PTR: REF VECTOR[,BYTE],! Pointer to line number counted ASCII
	LINE_START,			! Line start address (not actually used)
	LINE_STRING: VECTOR[40,BYTE],	! Vector used to build ASCII line number
	LSI,				! Index of next location in LINE_STRING
	MODPTR,				! Module RST pointer (not actually used)
	NAMECNT,			! The number of pathname components
	NAMELIST: VECTOR[DBG$K_MAX_PATHNAME],	! Vector of pointers to names
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to current pathname component
					!      (as a Counted ASCII string)
	NO_NULL_NAME,			! Set to TRUE if no null lexical entity
					!      name is in up-scope chain
	NO_ROUTINE,			! Set to TRUE if inner-most routine has
					!      not yet been found up-scope
	PATHDESCR: REF PTH$PATHNAME,	! Pointer to Pathname Descriptor
	PATHVEC: REF VECTOR[,LONG],	! Pointer to pathname vector in descr.
	RSTPTR: REF RST$ENTRY,		! Pointer to current RST entry
	STATUS,				! Status code returned by called routine
	STMT_NUM;			! Statement number within line number



    ! Initialize some pointers and counters for the up-scope chain loop.
    !
    RSTPTR = .SYMID;
    NAMECNT = 0;
    DATACNT = 0;
    LINE_NUM_FOUND = FALSE;
    LINE_NUM_LOC = 1000000;
    NO_NULL_NAME = TRUE;
    NO_ROUTINE = TRUE;


    ! Go up the input symbol's up-scope chain to determine how many pathname
    ! components the symbol has.  We also determine how much data qualification
    ! there is and whether a line number needs to be supplied in the pathname.
    !
    WHILE TRUE DO
	BEGIN


	! Get the name of the pathname component.  Unless the name is null,
	! save a pointer to the name string in the NAMELIST vector.
	!
	NAMEPTR = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);
	IF .NAMEPTR[0] NEQ 0
	THEN
	    BEGIN
	    IF .NAMECNT GEQ DBG$K_MAX_PATHNAME THEN EXITLOOP;
	    NAMELIST[.NAMECNT] = .NAMEPTR;
	    NAMECNT = .NAMECNT + 1;
	    END;


	! If this is a global symbol, exit the up-scope loop right away.
	!
	IF .RSTPTR[RST$V_GLOBAL] THEN EXITLOOP;


	! Determine what kind of RST entry this is and act accordingly.
	!
	CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	    SET

	    [RST$K_MODULE]:
		EXITLOOP;

	    [RST$K_ROUTINE,
	     RST$K_BLOCK]:
		BEGIN
		IF .NO_ROUTINE AND (.NAMEPTR[0] NEQ 0) AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    NO_ROUTINE = FALSE;
		    INVOC_LOC = .NAMECNT - 1;
		    END;

		IF (.NAMEPTR[0] EQL 0) AND .NO_NULL_NAME
		THEN
		    BEGIN
		    LINE_NUM_LOC = .NAMECNT;
    		    MODPTR = .RSTPTR;
		    IF DBG$PC_TO_LINE_LOOKUP(.RSTPTR[RST$L_STARTADDR],
						LINE_NUM, STMT_NUM,
						LINE_START, LINE_END, MODPTR)
		    THEN NO_NULL_NAME = FALSE;
		    END;

		END;

	    [RST$K_ENTRY,
	     RST$K_OVERLOAD,
	     RST$K_LABEL]:
		0;

	    [RST$K_LINE]:
		LINE_NUM_FOUND = TRUE;

	    [RST$K_DATA,
	     RST$K_TYPE,
	     RST$K_TYPCOMP]:
		IF .NAMEPTR[0] NEQ 0 THEN DATACNT = .DATACNT + 1;

	    [INRANGE]:
		$DBG_ERROR('RSTACCESS\SYMPATHNAME');

	    TES;


	! Link to the next RST entry up-scope from this one.  Then loop.
	!
	RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
	END;


    ! Determine how many levels of data qualification (e.g., 2 for M\A.B.C)
    ! there is in the pathname.
    !
    IF .DATACNT EQL 0
    THEN
	COMPCNT = 0
    ELSE
	COMPCNT = .DATACNT - 1;


    ! If there already is a line number in the pathname, do not insert an extra
    ! line number due to a null lexical entity name.
    !
    IF .NO_NULL_NAME OR .LINE_NUM_FOUND THEN LINE_NUM_LOC = 1000000;


    ! If we do have to supply a line number in the pathname to identify an
    ! anonymous lexical entity, generate the line number counted ASCII string.
    !
    LINE_LWRDS = 0;
    IF .LINE_NUM_LOC NEQ 1000000
    THEN
	BEGIN
	LSI = 0;


	! If there is a statement number, convert that to ASCII decimal.
	!
	IF .STMT_NUM NEQ 0
	THEN
	    BEGIN
	    WHILE .STMT_NUM NEQ 0 DO
		BEGIN
		LINE_STRING[.LSI] = (.STMT_NUM MOD 10) + '0';
		LSI = .LSI + 1;
		STMT_NUM = .STMT_NUM/10;
		END;

	    LINE_STRING[.LSI] = '.';
	    LSI = .LSI + 1;
	    END;


	! Convert the main statement number to ASCII decimal.
	!
	WHILE .LINE_NUM NEQ 0 DO
	    BEGIN
	    LINE_STRING[.LSI] = (.LINE_NUM MOD 10) + '0';
	    LSI = .LSI + 1;
	    LINE_NUM = .LINE_NUM/10;
	    END;


	! Compute the number of longwords we will need for the line number.
	!
	LINE_LWRDS = (.LSI + 13)/4;
	END;


    ! Determine what the invocation number is.  If it turns out to be zero,
    ! we do not explicitly put it in the Pathname Descriptor.
    !
    INVOCNUM = 0;
    IF .SYMID[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SYMID[RST$L_SYMCHNPTR];
	INVOCNUM = .INVPTR[RST$L_INVOCNUM];
	END;

    IF .INVOCNUM EQL 0 THEN INVOC_LOC = 1000000;


    ! Allocate space for a Pathname Descriptor for the symbol.
    !
    PATHDESCR = DBG$GET_TEMPMEM(DBG$K_PATHDESCSIZE + .NAMECNT + .LINE_LWRDS);
    PATHVEC = PATHDESCR[PTH$A_PATHVECTOR];


    ! Fill in the Pathname Descriptor's header.
    !
    PATHDESCR[PTH$B_TOTCNT] = .NAMECNT;
    PATHDESCR[PTH$B_PATHCNT] = .NAMECNT - .COMPCNT;
    PATHDESCR[PTH$B_LOCINVOC] = 0;
    PATHDESCR[PTH$L_INVOCNUM] = 0;


    ! Fill in the pointers to the pathname component names.
    !
    J = 0;
    DECR I FROM .NAMECNT - 1 TO 0 DO
	BEGIN
	PATHVEC[.J] = .NAMELIST[.I];
	J = .J + 1;


	! If this is where the invocation number goes, mark that in the header.
	!
	IF .I EQL .INVOC_LOC
	THEN
	    BEGIN
	    PATHDESCR[PTH$B_LOCINVOC] = .J;
	    PATHDESCR[PTH$L_INVOCNUM] = .INVOCNUM;
	    END;


	! If this is where the extra line number goes, fill that in.
	!
	IF .J EQL .LINE_NUM_LOC
	THEN
	    BEGIN
	    LINE_NUM_PTR = PATHVEC[.NAMECNT + 1];
	    LINE_NUM_PTR[0] = .LSI + 6;
	    LINE_NUM_PTR[1] = '%';
	    LINE_NUM_PTR[2] = 'L';
	    LINE_NUM_PTR[3] = 'I';
	    LINE_NUM_PTR[4] = 'N';
	    LINE_NUM_PTR[5] = 'E';
	    LINE_NUM_PTR[6] = ' ';
	    INCR K FROM 1 TO .LSI DO
		LINE_NUM_PTR[.K + 6] = .LINE_STRING[.LSI - .K];

	    PATHVEC[.J] = .LINE_NUM_PTR;
	    J = .J + 1;
	    END;

	END;


    ! Finally return the address of the Pathname Descriptor to PATHNAME.  Then
    ! return.
    !
    PATHNAME[0] = .PATHDESCR;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMVALUE(SYMID, VALPTR, VALKIND): NOVALUE =
!
! FUNCTION
!	This routine accepts a symbol identifier and returns a pointer to the
!	corresponding symbol's value.  The symbol identifier is the unique
!	identifier produced by routine DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.
!
!	This routine requires a "context" to have been established by a call on
!	routine DBG$STA_SETCONTEXT if there are any register references in the
!	DST Value Spec which defines the symbol's value.  If such a reference
!	occurs and no context exists, an error is signalled.
!
!	The interpretation of the value stored at the returned address is up to
!	the language-specific routines in light of the symbol's data type.  The
!	data type specification must therefore include all length information.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose "value" is to be returned.
!
!	VALPTR	- The address of a three-longword vector to receive the value
!		  pointer and the corresponding stack frame pointer.
!
!	VALKIND	- The address of a longword location to receive the value kind.
!
! OUTPUTS
!	VALPTR	- A pointer to the desired value is returned to VALPTR.  The
!		  byte address of the value is returned to VALPTR[0] and the
!		  bit offset from that address is returned to VALPTR[1].  The
!		  corresponding stack Frame Pointer is returned to VALPTR[2].
!		  VALPTR[2] will contain zero if no frame pointer is applicable.
!
!	VALKIND	- The kind of the value pointed to by VALPTR is returned to
!		  VALKIND.  These are the possible values:
!
!			DBG$K_VAL_NOVALUE - The symbol has no value.
!			DBG$K_VAL_LITERAL - VALPTR points to a literal value.
!			DBG$K_VAL_ADDR    - VALPTR contains an address.
!			DBG$K_VAL_DESCR   - VALPTR contains the address of a
!					    descriptor.
!
!	No value is returned by DBG$STA_SYMVALUE.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input symbol's RST entry
	VALPTR: REF VECTOR[3],		! Pointer to caller's value vector
	VALKIND: REF VECTOR[1];		! Pointer to value kind parameter

    LOCAL
	BLITRLR: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
	BLIVALSPEC: BLOCK[8,BYTE]	! Value Spec buffer for Bliss special
		FIELD(DST$VS_HDR_FIELDS), !    cases DST record
	CH_TRLR_PTR: REF DST$CH_TRLR,	! Pointer to COBOL Hack DST trailer
	DSTPTR: REF DST$RECORD,		! Pointer to symbol's DST record
	VALLOC: REF VECTOR[,LONG];	! Value location from Stack Machine



    ! Initially zero out the returned value pointer and frame pointer.
    !
    VALPTR[0] = 0;
    VALPTR[1] = 0;
    VALPTR[2] = 0;


    ! Determine what kind of RST entry SYMID identifies and act accordingly.
    !
    CASE .SYMID[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	SET


	! For instruction addresses, return the start address in the RST entry.
	!
	[RST$K_ROUTINE, RST$K_BLOCK,
	 RST$K_ENTRY, RST$K_LABEL,
	 RST$K_LINE]:
	    BEGIN
	    VALPTR[0] = .SYMID[RST$L_STARTADDR];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    RETURN;
	    END;


	! For Types, return the No-Value code to VALKIND.
	!
	[RST$K_TYPE]:
	    BEGIN
	    VALKIND[0] = DBG$K_VAL_NOVALUE;
	    RETURN;
	    END;


	! For most other kinds (including Module) signal an internal error.
	!
	[INRANGE, OUTRANGE]:
	    $DBG_ERROR('RSTACCESS\SYMVALUE 10');


	! For Data and Type Components, do nothing here--we handle them below.
	!
	[RST$K_DATA, RST$K_TYPCOMP]:
	    0;

	TES;


    ! Obtain the DST record describing this object. If there are 
    ! continuation records then merge them into a single new DST record.
    !
    DSTPTR = .SYMID[RST$L_DSTPTR];


    ! For the items not yet handled (i.e., for data), we determine the type of
    ! DST record which holds the value specification and act accordingly.
    !
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle all normal DST records, i.e. those of the standard format.
	! Find the Value Spec and pass it to DBG$STA_VALSPEC for evaluation.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
	 DST$K_ENTRY, DST$K_RTNBEG, DST$K_BLKBEG,
	 DST$K_RECBEG, DST$K_ENUMELT]:
            BEGIN

            ! All these checks on the call to VALSPEC are here to allow the
            ! user to examine only registers after the completion of the user
            ! program.  e.g.  EX %R0 or EX 0\R1
            !
            LOCAL
                MODPTR : REF RST$ENTRY;

            MODPTR = .SYMID[RST$L_UPSCOPEPTR];
            IF (.DBG$GV_CONTROL[DBG$V_CONTROL_DONE]) AND
               (.SYMID[RST$V_REGISTER]) AND
               (.MODPTR NEQ 0) 
    	    THEN
    		IF (.MODPTR[RST$V_MODNUMSCP]) AND
                   (.MODPTR[RST$L_MODSCPNUM] EQL 0)
                THEN
	            DBG$STA_VALSPEC(DSTPTR[DST$B_VFLAGS], .VALPTR, .VALKIND, TRUE)
                ELSE
	            DBG$STA_VALSPEC(DSTPTR[DST$B_VFLAGS], .VALPTR, .VALKIND, FALSE)
    	    ELSE
	        DBG$STA_VALSPEC(DSTPTR[DST$B_VFLAGS], .VALPTR, .VALKIND, FALSE);
            END;


	! Handle the Label DST record.  Here we get the label address directly
	! from the DST$L_VALUE field--the DST$B_VFLAGS field is not provided.
	!
	[DST$K_LABEL]:
	    BEGIN
	    VALPTR[0] = .DSTPTR[DST$L_VALUE];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! Handle the Bliss Special Cases DST record.  Construct a Value Spec
	! from the VFLAGS and VALUE fields in the record (which are not adjacent
	! in this particular record) and call DSG$STA_VALSPEC with it.
	!
	[DST$K_BLI]:
	    BEGIN
            LOCAL
                MODPTR : REF RST$ENTRY,
		VSPTR: REF DST$VAL_SPEC;


	    BLIVALSPEC[DST$B_VS_VFLAGS] = .DSTPTR[DST$B_BLI_VFLAGS];
	    BLITRLR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	    BLIVALSPEC[DST$L_VS_VALUE] = .BLITRLR[DST$L_BLI_VALUE];


	    ! The following is a hack to support BLISS BINDs. The 
	    ! reason for this hack is that BIND statements in BLISS
	    ! can give rise to BLISS data whose DST type code is DST$K_BLI
	    ! (this means they are either blocks, blockvectors, vectors,
	    ! or bitvectors), and whose valkind is "literal". However,
	    ! we want to treat these data items as if their valkind
	    ! is "address". See the test TST$:BLIBIND.* for an example.
	    ! The reasons why valkind of "literal" doesn't work for these kinds 
	    ! of BLISS data are too complicated to explain here; they have to 
	    ! do with our handling of literals in general.
	    ! So, we change valkind "literal" to valkind "address" right
	    ! here, on the assumption that this only affects BLISS BINDs.
	    !
	    VSPTR = BLIVALSPEC[DST$B_VS_VFLAGS];
	    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL
	    THEN
	   	VSPTR[DST$V_VS_VALKIND] = DST$K_VALKIND_ADDR;


            ! All these checks on the call to VALSPEC are here to allow the
            ! user to examine only registers after the completion of the user
            ! program.  e.g.  EX %R0 or EX 0\R1
            !
            MODPTR = .SYMID[RST$L_UPSCOPEPTR];
            IF (.DBG$GV_CONTROL[DBG$V_CONTROL_DONE]) AND
               (.SYMID[RST$V_REGISTER]) AND
               (.MODPTR NEQ 0) 
    	    THEN
    		IF (.MODPTR[RST$V_MODNUMSCP]) AND
                   (.MODPTR[RST$L_MODSCPNUM] EQL 0)
                THEN
	            DBG$STA_VALSPEC(BLIVALSPEC, .VALPTR, .VALKIND, TRUE)
                ELSE
                    DBG$STA_VALSPEC(BLIVALSPEC, .VALPTR, .VALKIND, FALSE)
            ELSE
                DBG$STA_VALSPEC(BLIVALSPEC, .VALPTR, .VALKIND, FALSE);
	    END;


	! Handle the Bliss Field DST record.  Here we just return the address of
	! the number-of-components field in the DST record.
	!
	[DST$K_BLIFLD]:
	    BEGIN
	    VALPTR[0] = DSTPTR[DST$L_BLIFLD_COMPS];
	    VALKIND[0] = DBG$K_VAL_LITERAL;
	    END;


	! Handle the COBOL Hack DST Record.  Here we evaluate the Stack Machine
	! code in the DST record and return its value as the symbol address.
	!
	[DST$K_COB_HACK]:
	    BEGIN
	    CH_TRLR_PTR = DSTPTR[DST$A_COBHACK_TRLR] + .DSTPTR[DST$B_NAME];
	    STACK_MACHINE(CH_TRLR_PTR[DST$A_CH_STKRTN_ADDR], VALLOC, VALPTR[2]);
	    VALPTR[0] = .VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! Handle the PSECT DST record.  Here we pick the PSECT start address
	! directly from the DST record.
	!
	[DST$K_PSECT]:
	    BEGIN
	    VALPTR[0] = .DSTPTR[DST$L_PSECT_VALUE];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! Any other DST record causes an error to be signalled.
	!
	[INRANGE]:
	    $DBG_ERROR('RSTACCESS\SYMVALUE 20');

	TES;


    ! We have the value.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_UNLOCK_SYMID(SYMID_LIST_PTR): NOVALUE =
!
! FUNCTION
!	This routine "unlocks" a list of SYMIDs which have previously been
!	"locked" in the RST by routine DBG$STA_LOCK_SYMID.  SYMIDs are locked
!	in the RST when the corresponding RST entries must be preserved accross
!	Debug commands because they are referenced by "." (current location),
!	breakpoints, or the like.  They should then be "unlocked" when they are
!	no longer so referenced, i.e. when "." assumes a different value or the
!	breakpoint is cancelled.
!
!	The unlocking is effected by decrementing the Reference Count in the
!	SYMID's RST entry and all other RST entries whose reference counts were
!	incremented when the SYMID was originally locked.  This includes all
!	RST entries up-scope from the original RST entry.
!
! INPUTS
!	SYMID_LIST_PTR - A pointer to a linked list of Linked List Nodes, where
!		  each node contains a forward link and a SYMID value.  Each
!		  SYMID on the list is "unlocked" in the RST by decrementing the
!		  reference count of the corresponding RST entry.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LISTPTR: REF DBG$LINK_NODE;	! Pointer to current linked list node



    ! Loop through all the SYMIDs (i.e., RST pointers) on the linked list.
    ! For each SYMID on the list, call ADD_TO_REF_COUNT to decrement the RST
    ! entry's reference count.
    !
    LISTPTR = .SYMID_LIST_PTR;
    WHILE .LISTPTR NEQ 0 DO
	BEGIN
	ADD_TO_REF_COUNT(.LISTPTR[DBG$L_LINK_NODE_VALUE], -1);
	LISTPTR = .LISTPTR[DBG$L_LINK_NODE_LINK];
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_VALSPEC(VALSPEC, VALPTR, VALKIND, ACTUAL_REG_FLAG): NOVALUE =
!
! FUNCTION
!	This routine accepts the address of a DST Value Spec as input and pro-
!	duces the corresponding value as output.  It handles all the special
!	cases of value specs, including stack machine value specs, to compute
!	the proper output value.  It requires a "context" to have been estab-
!	lished by DBG$STA_SETCONTEXT if there are any register references in
!	the value spec.  If such a reference occurs and no context exists, an
!	error is signalled.
!
! INPUTS
!	VALSPEC	- A pointer to the DST Value Spec to be evaluated.
!
!	VALPTR	- The address of a three-longword vector to receive the value
!		  pointer and the corresponding stack frame pointer.
!
!	VALKIND	- The address of a longword location to receive the value kind.
!
!       ACTUAL_REG_FLAG - This is a flag indicating that the valspec that we are
!			  looking at is an actual register (e.g. %R5)
!
! OUTPUTS
!	VALPTR	- A pointer to the desired value is returned to VALPTR.  The
!		  byte address of the value is returned to VALPTR[0] and the
!		  bit offset from that address is returned to VALPTR[1].  The
!		  corresponding stack Frame Pointer is returned to VALPTR[2].
!		  VALPTR[2] will contain zero if no frame pointer is applicable.
!
!	VALKIND	- The kind of the value pointed to by VALPTR is returned to
!		  VALKIND.  These are the possible values:
!
!			DBG$K_VAL_LITERAL - VALPTR points to a literal value.
!			DBG$K_VAL_ADDR    - VALPTR contains an address.
!			DBG$K_VAL_DESCR   - VALPTR contains the address of a
!					    descriptor.
!

    BEGIN

    MAP
	VALSPEC: REF DST$VAL_SPEC,	! Pointer to DST Value Spec to evaluate
	VALPTR: REF VECTOR[3],		! Pointer to value return location
	VALKIND: REF VECTOR[1];		! Pointer to value kind return location

    LOCAL
    	REG_FLAG,
	REGNUM,				! Register number
	REGPTR: REF VECTOR[,LONG],	! Pointer to register save location
	VALUE: REF VECTOR[,LONG],	! Computed value
	VSPTR: REF DST$VAL_SPEC;	! Pointer to current DST Value Spec

    ENABLE
	VALSPEC_ERROR_HANDLER;		! Set up error handler for this routine

    BUILTIN
    	ACTUALCOUNT;


    ! Default fourth parameter to FALSE.
    !
    IF ACTUALCOUNT() GEQ 4
    THEN
    	REG_FLAG = .ACTUAL_REG_FLAG
    ELSE
    	REG_FLAG = FALSE;


    ! Initially zero the returned frame pointer value in VALPTR[2].  This
    ! value will be changed later if a register is used in the evaluation.
    !
    VALPTR[2] = 0;


    ! If the value is given by a trailing Value Spec, we get to that Value
    ! Spec.  We loop in case the indirection is repeated.
    !
    VSPTR = .VALSPEC;
    WHILE .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
	VSPTR = VSPTR[DST$A_VS_TVS_BASE] + .VSPTR[DST$L_VS_TVS_OFFSET];


    ! If the Value Spec gives the offset to a descriptor (in the DST), return
    ! the address of that descriptor to the caller.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	BEGIN
	VALPTR[0] = VSPTR[DST$A_VS_DSC_BASE] + .VSPTR[DST$L_VS_DSC_OFFS];
	VALPTR[1] = 0;
	VALKIND[0] = DBG$K_VAL_DESCR;
	RETURN;
	END;


    ! If this is a Bit Offset Value Spec, return that bit offset as a byte
    ! address plus bit offset to the caller.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_BITOFFS
    THEN
	BEGIN
	VALPTR[0] = .VSPTR[DST$L_VS_VALUE]/8;
	VALPTR[1] = .VSPTR[DST$L_VS_VALUE] AND 7;
	VALKIND[0] = DBG$K_VAL_ADDR;
	RETURN;
	END;


    ! If the VFLAGS field has the special code for "unallocated", then
    ! put the code for "unallocated" in the kind field and then 
    ! return. This is the case, for example, for PASCAL variables
    ! that are never referenced.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_UNALLOC
    THEN
	BEGIN
	VALPTR[0] = 0;
	VALPTR[1] = 0;
	VALKIND[0] = DBG$K_VAL_UNALLOC;
	RETURN;
	END;


    ! If this is a Value-Spec-Follows value spec, a more complex value spec
    ! follows the VFLAGS field.  Here we handle those kinds of value specs.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
	BEGIN


	! Sort out which particular kind of complex value specification follows.
	!
	CASE .VSPTR[DST$B_VS_ALLOC] FROM DST$K_VS_ALLOC_STAT TO DST$K_VS_ALLOC_DYN OF
	    SET


	    ! Handle statically or dynamically allocated objects without Binding
	    ! Specs.  Here we just evaluate the Materialization Spec.
	    !
	    [DST$K_VS_ALLOC_STAT,
	     DST$K_VS_ALLOC_DYN]:
		BEGIN
		EVAL_MAT_SPEC(VSPTR[DST$A_VS_MATSPEC], .VALPTR, .VALKIND);
		END;


	    ! Any other value in the DST$B_VS_ALLOC field is an error.
	    !
	    [INRANGE, OUTRANGE]:
		SIGNAL(DBG$_INVDSTREC);

	    TES;


	! We are done with the complex value spec.  Return to the caller.
	!
	RETURN;
	END;


    ! This is an ordinary garden variety Value Spec with a normal VFLAGS field
    ! and a normal VALUE field.  If this is a literal, return the address of the
    ! literal to the caller.
    !
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL
    THEN
	BEGIN
	VALPTR[0] = VSPTR[DST$L_VS_VALUE];
	VALPTR[1] = 0;
	VALKIND[0] = DBG$K_VAL_LITERAL;
	RETURN;
	END;


    ! If this is a register number, return the address of the corresponding
    ! register save area.  If the register is not available in this context,
    ! signal an error.  (Note that we allow register 16 to mean the PSL.)
    !
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_REG
    THEN
	BEGIN
	REGNUM = .VSPTR[DST$L_VS_VALUE];
	IF (.REGNUM LSS 0) OR (.REGNUM GTR 16) THEN SIGNAL(DBG$_INVDSTREC);
	IF .DBG$REG_VECTOR[.REGNUM] EQL 0 AND NOT .REG_FLAG
        THEN
            VALSPEC_SCOPE_ERROR();
	VALPTR[0] = DBG$REG_VALUES[.REGNUM];
	VALPTR[1] = 0;
	VALPTR[2] = .DBG$REG_VALUES[13];
	VALKIND[0] = DBG$K_VAL_ADDR;
	RETURN;
	END;


    ! This value spec requires the value to be computed.  The resulting value is
    ! either the address of some object or the address of a descriptor.
    !
    VALUE = .VSPTR[DST$L_VS_VALUE];
    IF .VSPTR[DST$V_VS_DISP]
    THEN
	BEGIN
	REGNUM = .VSPTR[DST$V_VS_REGNUM];
	IF .DBG$REG_VECTOR[.REGNUM] EQL 0 THEN VALSPEC_SCOPE_ERROR();
	VALUE = .VALUE + .DBG$REG_VALUES[.REGNUM];
	VALPTR[2] = .DBG$REG_VALUES[13];
	END;

    IF .VSPTR[DST$V_VS_INDIRECT] THEN VALUE = .VALUE[0];


    ! Return the computed value and its kind: address or descriptor address.
    !
    VALPTR[0] = .VALUE;
    VALPTR[1] = 0;
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_DESC
    THEN
	VALKIND[0] = DBG$K_VAL_DESCR

    ELSE
	VALKIND[0] = DBG$K_VAL_ADDR;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_VARIANT_SELECT(TAGVALUE, VARSYMID) =
!
! FUNCTION
!	This routine accepts a tag value, i.e. the value of the tag variable
!	in a record with variants (as in PASCAL or ADA), and a pointer to a
!	Variant Set RST Entry and it returns a pointer to the corresponding
!	variant in the Variant Set is selected by that tag value.  If no
!	variant is selected, meaning that the tag variable has an invalid
!	value, a value of zero is returned.  This is achieved by looping
!	over all the variants in the set and calling DBG$STA_VARIANT_VALUE
!	for each variant to determine if the tag value selects that variant.
!
! INPUTS
!	TAGVALUE - The value of the tag variable to be used to select a
!		  variant in the Variant Set.  This is treated as a longword
!		  integer value.
!
!	VARSYMID - A pointer to the Variant Set RST Entry for the Variant
!		  Set from which a specific variant is to be selected by
!		  TAGVALUE.
!
! OUTPUTS
!	An pointer to the variant entry (obtained from the list in the Variant Set
!	RST Entry) is returned as the routine value.    If no variant was selected
!	(invalid tag variable value), zero is returned.
!

    BEGIN

    MAP
	VARSYMID: REF RST$ENTRY;	! Pointer to Variant Set RST Entry

    LOCAL
	VARPTR: REF RST$VAR_ENTRY,	! Pointer to current RST Variant Entry
	VARSETTBL: REF VECTOR[,LONG];	! Pointer to Variant Set RST Entry's
					!      pointer table, where each entry
					!      points to an RST Variant Entry



    ! Check the Variant Set RST Entry pointer for validity.
    !
    IF .VARSYMID[RST$B_KIND] NEQ RST$K_VARIANT
    THEN
	$DBG_ERROR('RSTACCESS\VARIANT_INDEX');


    ! Search through the Variant Set RST Entry's table of variants.  For each
    ! variant, see if TAGVALUE falls into one of its tag value ranges, and if
    ! so, return the index of that variant.
    !
    VARSETTBL = VARSYMID[RST$A_VARSETTBL];
    INCR I FROM 0 TO .VARSYMID[RST$L_VARSETCNT] - 1 DO
	BEGIN
	VARPTR = .VARSETTBL[.I];
	IF DBG$STA_VARIANT_VALUE(.TAGVALUE, .VARPTR[RST$L_VAR_DSTPTR])
	THEN
	    RETURN .VARPTR;
	END;


    ! The tag value does not match the allowed tag values for any variant.
    ! We return a value of 0 to indicate that the tag value is invalid.
    !
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_VARIANT_VALUE(TAGVALUE, VARDSTPTR) =
!
! FUNCTION
!	This routine determines whether a given tag variable value selects a
!	specified record variant or not.  This is done by looping through all
!	the Tag Value Range Specifications in the variant's Variant Value DST
!	Record until a tag value or tag value range is found which equals or
!	includes the specified tag variable value.  If such a match is found,
!	this routine returns TRUE; otherwise it returns FALSE.
!
! INPUTS
!	TAGVALUE - The tag variable value.  This value, treated as a longword
!		  integer, is compared to all the tag value ranges in the
!		  Variant Value DST Record.
!
!	VARDSTPTR - A pointer to the Variant Value DST Record for the variant
!		  of interest.  The Tag Value Range Specifications against
!		  which TAGVALUE is checked is taken from this DST record.
!
! OUTPUTS
!	If TAGVALUE selects the VARDSTPTR variant, this routine returns TRUE
!		  as its value; otherwise FALSE is returned.
!

    BEGIN

    MAP
	VARDSTPTR: REF DST$RECORD;	! Pointer to Variant Value DST Record

    LOCAL
	HIGHBOUND,			! Upper bound given by the current Tag
					!      Value Range Specification
	LOWBOUND,			! Lower bound given by the current Tag
					!      Value Range Specification
	RANGESPEC: REF VECTOR[,BYTE],	! Pointer to DST Tag Value Range Spec
	VALKIND,			! Value kind returned by DBG$STA_VALSPEC
	VALPTR: VECTOR[3],		! Value pointer returned by STA_VALSPEC
	VALSPEC: REF DST$VAL_SPEC,	! Pointer to current DST Value Spec in
					!      the current Tag Value Range Spec
	VALUEPTR: REF VECTOR[1],	! Pointer to the actual tag value given
					!      by current Value Spec
	VS_LENGTH;			! Value Specification length (used to
					!      find address of next Value Spec)



    ! Check the Variant Value DST Record pointer for validity.
    !
    IF .VARDSTPTR[DST$B_TYPE] NEQ DST$K_VARVAL
    THEN
	$DBG_ERROR('RSTACCESS\VARIANT_VALUE');


    ! Loop through all the Tag Value Range Specs for this particular variant.
    ! If one of those values or value ranges matches the TAGVALUE parameter,
    ! then we return TRUE, meaning that the specified tag value selects this
    ! particular variant.
    !
    RANGESPEC = VARDSTPTR[DST$A_VARVAL_RNGSPEC];
    INCR I FROM 0 TO .VARDSTPTR[DST$W_VARVAL_COUNT] - 1 DO
	BEGIN


	! Pick up the first (and possibly only) value in the current Tag Value
	! Range Specification.  Then advance VALSPEC past that Value Spec.
	!
	VALSPEC = RANGESPEC[1];
	DBG$STA_VALSPEC(.VALSPEC, VALPTR, VALKIND);
	VALUEPTR = .VALPTR[0];
	LOWBOUND = .VALUEPTR[0];
	HIGHBOUND = .VALUEPTR[0];
	VS_LENGTH = 5;
	IF .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
	THEN
	    VS_LENGTH = .VALSPEC[DST$W_VS_LENGTH] + 3;

	VALSPEC = .VALSPEC + .VS_LENGTH;


	! If this Tag Value Range Specification actually specifies a range,
	! we just got the lower bound of that range.  Now pick up the upper
	! bound of the range.
	!
	IF .RANGESPEC[0] EQL DST$K_VARVAL_RANGE
	THEN
	    BEGIN
	    DBG$STA_VALSPEC(.VALSPEC, VALPTR, VALKIND);
	    VALUEPTR = .VALPTR[0];
	    HIGHBOUND = .VALUEPTR[0];
	    VS_LENGTH = 5;
	    IF .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
	    THEN
		VS_LENGTH = .VALSPEC[DST$W_VS_LENGTH] + 3;

	    VALSPEC = .VALSPEC + .VS_LENGTH;
	    END;


	! See if the specified tag variable value is in the value range speci-
	! fied by the current Tag Value Range Specification.  If so, return
	! TRUE.  Otherwise, advance the RANGESPEC pointer to the next Tag Value
	! Range Specification and loop.
	!
	IF (.TAGVALUE GEQ .LOWBOUND) AND (.TAGVALUE LEQ .HIGHBOUND)
	THEN
	    RETURN TRUE;

	RANGESPEC = .VALSPEC;
	END;				! End of loop over Tag Value Range Specs


    ! The specified TAGVALUE does not select this particular variant, so we
    ! return FALSE.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$TEST_ROUTINE_CALL( P1, P2, P3, P4 ) =
!
! FUNCTION
!	DBG$TEST_ROUTINE_CALL is a test routine to be called from
!	the stack machine or DSTs, to test if the call to the routine
!	is correct.
!
! INPUTS
!	P1 - First  parameter
!	P2 - Second parameter
!	P3 - Third  parameter
!	P4 - Fourth parameter
!
! OUTPUTS
!	none
!
! SIDE EFFECTS
!	none
!
    BEGIN

    RETURN P1

    END;

GLOBAL ROUTINE DBG$TRANS_TO_REGNAME (ADDRESS, NAME) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines if the input address corresponds to an address
!	in the context register save area. If it does, a counted string of the
!	register name is returned. This string includes the scope number.
!
! FORMAL PARAMETERS:
!
!	ADDRESS		- Address to be translated to a register name
!
!	NAME		- The address of a longword to contain the address
!			  of the resulting counted string.
!
! IMPLICIT INPUTS:
!
!	DBG$REG_VALUES  - Vector of context register save areas
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS		- Success. Input address mapped to register name.
!
!	STS$K_SEVERE		- Failure. Input address does not correspond to
!				  context register save area.
!
! SIDE EFFECTS:
!
!	NONE
!

    BEGIN
	
    LOCAL
	INDEX,				! Index into arrays
	REGNAME_TABLE: VECTOR [68,LONG],! Register name table
	CONTROL_DESC: BLOCK [8,BYTE],	! $FAO control descriptor
	FAO_LENGTH: WORD,		! $FAO output length
	OUTPUT_DESC: BLOCK [8,BYTE],	! Output descriptor for FAO
	OUTPUT_BUFFER: REF VECTOR [,BYTE]; ! Output buffer

    BIND
	FAO_STRING	= UPLIT BYTE ('!UL!AC!AC'),  ! $FAO directive string
	SEP_STRING	= UPLIT BYTE (%ASCIC '\%');  ! Separator string



    ! Fill in the register name table. Note that this MUST be done at runtime.
    !
    REGNAME_TABLE [0] =	UPLIT BYTE (%ASCIC 'R0');
    REGNAME_TABLE [1] =	UPLIT BYTE (%ASCIC 'R0+1');
    REGNAME_TABLE [2] =	UPLIT BYTE (%ASCIC 'R0+2');
    REGNAME_TABLE [3] =	UPLIT BYTE (%ASCIC 'R0+3');
    REGNAME_TABLE [4] =	UPLIT BYTE (%ASCIC 'R1');
    REGNAME_TABLE [5] =	UPLIT BYTE (%ASCIC 'R1+1');
    REGNAME_TABLE [6] =	UPLIT BYTE (%ASCIC 'R1+2');
    REGNAME_TABLE [7] =	UPLIT BYTE (%ASCIC 'R1+3');
    REGNAME_TABLE [8] =	UPLIT BYTE (%ASCIC 'R2');
    REGNAME_TABLE [9] =	UPLIT BYTE (%ASCIC 'R2+1');
    REGNAME_TABLE [10] = UPLIT BYTE (%ASCIC 'R2+2');
    REGNAME_TABLE [11] = UPLIT BYTE (%ASCIC 'R2+3');
    REGNAME_TABLE [12] = UPLIT BYTE (%ASCIC 'R3');
    REGNAME_TABLE [13] = UPLIT BYTE (%ASCIC 'R3+1');
    REGNAME_TABLE [14] = UPLIT BYTE (%ASCIC 'R3+2');
    REGNAME_TABLE [15] = UPLIT BYTE (%ASCIC 'R3+3');
    REGNAME_TABLE [16] = UPLIT BYTE (%ASCIC 'R4');
    REGNAME_TABLE [17] = UPLIT BYTE (%ASCIC 'R4+1');
    REGNAME_TABLE [18] = UPLIT BYTE (%ASCIC 'R4+2');
    REGNAME_TABLE [19] = UPLIT BYTE (%ASCIC 'R4+3');
    REGNAME_TABLE [20] = UPLIT BYTE (%ASCIC 'R5');
    REGNAME_TABLE [21] = UPLIT BYTE (%ASCIC 'R5+1');
    REGNAME_TABLE [22] = UPLIT BYTE (%ASCIC 'R5+2');
    REGNAME_TABLE [23] = UPLIT BYTE (%ASCIC 'R5+3');
    REGNAME_TABLE [24] = UPLIT BYTE (%ASCIC 'R6');
    REGNAME_TABLE [25] = UPLIT BYTE (%ASCIC 'R6+1');
    REGNAME_TABLE [26] = UPLIT BYTE (%ASCIC 'R6+2');
    REGNAME_TABLE [27] = UPLIT BYTE (%ASCIC 'R6+3');
    REGNAME_TABLE [28] = UPLIT BYTE (%ASCIC 'R7');
    REGNAME_TABLE [29] = UPLIT BYTE (%ASCIC 'R7+1');
    REGNAME_TABLE [30] = UPLIT BYTE (%ASCIC 'R7+2');
    REGNAME_TABLE [31] = UPLIT BYTE (%ASCIC 'R7+3');
    REGNAME_TABLE [32] = UPLIT BYTE (%ASCIC 'R8');
    REGNAME_TABLE [33] = UPLIT BYTE (%ASCIC 'R8+1');
    REGNAME_TABLE [34] = UPLIT BYTE (%ASCIC 'R8+2');
    REGNAME_TABLE [35] = UPLIT BYTE (%ASCIC 'R8+3');
    REGNAME_TABLE [36] = UPLIT BYTE (%ASCIC 'R9');
    REGNAME_TABLE [37] = UPLIT BYTE (%ASCIC 'R9+1');
    REGNAME_TABLE [38] = UPLIT BYTE (%ASCIC 'R9+2');
    REGNAME_TABLE [39] = UPLIT BYTE (%ASCIC 'R9+3');
    REGNAME_TABLE [40] = UPLIT BYTE (%ASCIC 'R10');
    REGNAME_TABLE [41] = UPLIT BYTE (%ASCIC 'R10+1');
    REGNAME_TABLE [42] = UPLIT BYTE (%ASCIC 'R10+2');
    REGNAME_TABLE [43] = UPLIT BYTE (%ASCIC 'R10+3');
    REGNAME_TABLE [44] = UPLIT BYTE (%ASCIC 'R11');
    REGNAME_TABLE [45] = UPLIT BYTE (%ASCIC 'R11+1');
    REGNAME_TABLE [46] = UPLIT BYTE (%ASCIC 'R11+2');
    REGNAME_TABLE [47] = UPLIT BYTE (%ASCIC 'R11+3');
    REGNAME_TABLE [48] = UPLIT BYTE (%ASCIC 'AP');
    REGNAME_TABLE [49] = UPLIT BYTE (%ASCIC 'AP+1');
    REGNAME_TABLE [50] = UPLIT BYTE (%ASCIC 'AP+2');
    REGNAME_TABLE [51] = UPLIT BYTE (%ASCIC 'AP+3');
    REGNAME_TABLE [52] = UPLIT BYTE (%ASCIC 'FP');
    REGNAME_TABLE [53] = UPLIT BYTE (%ASCIC 'FP+1');
    REGNAME_TABLE [54] = UPLIT BYTE (%ASCIC 'FP+2');
    REGNAME_TABLE [55] = UPLIT BYTE (%ASCIC 'FP+3');
    REGNAME_TABLE [56] = UPLIT BYTE (%ASCIC 'SP');
    REGNAME_TABLE [57] = UPLIT BYTE (%ASCIC 'SP+1');
    REGNAME_TABLE [58] = UPLIT BYTE (%ASCIC 'SP+2');
    REGNAME_TABLE [59] = UPLIT BYTE (%ASCIC 'SP+3');
    REGNAME_TABLE [60] = UPLIT BYTE (%ASCIC 'PC');
    REGNAME_TABLE [61] = UPLIT BYTE (%ASCIC 'PC+1');
    REGNAME_TABLE [62] = UPLIT BYTE (%ASCIC 'PC+2');
    REGNAME_TABLE [63] = UPLIT BYTE (%ASCIC 'PC+3');
    REGNAME_TABLE [64] = UPLIT BYTE (%ASCIC 'PSL');
    REGNAME_TABLE [65] = UPLIT BYTE (%ASCIC 'PSL+1');
    REGNAME_TABLE [66] = UPLIT BYTE (%ASCIC 'PSL+2');
    REGNAME_TABLE [67] = UPLIT BYTE (%ASCIC 'PSL+3');


    ! Check to see if the input address falls in the context register area.
    ! If so, we format the scope number and register name in a buffer which
    ! we then return to the caller.  We return with the status STS$K_SUCCESS.
    !
    IF (.ADDRESS GEQA DBG$REG_VALUES [0]) AND
       (.ADDRESS LSSA DBG$REG_VALUES [17])
    THEN
	BEGIN


	! Calculate the register index and get a temporary memory buffer for
	! ASCII register name.
	!
	INDEX = .ADDRESS - DBG$REG_VALUES [0];
	OUTPUT_BUFFER = DBG$GET_TEMPMEM(10);


	! Set up the FAO call
	!
	CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!UL!AC!AC');
	CONTROL_DESC [DSC$A_POINTER] = FAO_STRING;
	OUTPUT_DESC [DSC$W_LENGTH] = (10 * %UPVAL) - 1;
	OUTPUT_DESC [DSC$A_POINTER] = OUTPUT_BUFFER [1];
	

	! Format the scope number, the separator, and the register name.
	!
	IF NOT SYS$FAO (CONTROL_DESC,
		        FAO_LENGTH,
			OUTPUT_DESC,
		        .DBG$REG_SCOPE,
		        SEP_STRING,
		        .REGNAME_TABLE [.INDEX])
	THEN
	    $DBG_ERROR('RSTACCESS\TRANS_TO_REGNAME');


	! Copy the count into the first byte of the output buffer and return.
	!
	OUTPUT_BUFFER [0] = .FAO_LENGTH;
	.NAME = .OUTPUT_BUFFER;
	RETURN STS$K_SUCCESS;
	
	END


    ! The input address does not fall in the register save area.  Hence we
    ! return the status STS$K_SEVERE to indicate this.
    !
    ELSE
	RETURN STS$K_SEVERE;

    END;


ROUTINE ADD_TO_REF_COUNT(RSTPTR, INCREMENT): NOVALUE =
!
! FUNCTION
!	This routine increments or decrements the reference count field of a
!	specified RST entry and all entries reachable from that entry.  An RST
!	is "reachable" from a specified entry if it is up-scope from that entry,
!	if it is referenced by the RST$L_TYPEPTR field, or it is a record com-
!	ponent or enumeration type element of the specified Type RST Entry.
!
! INPUTS
!	RSTPTR	- A pointer to the RST entry whose reference count is to be
!		  incremented or decremented.
!
!	INCREMENT - The value to be added to the RST entry's reference count.
!		  Thus +1 increments the count and -1 decrements it.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! Pointer to the input RST entry

    LOCAL
	COMPLST: REF VECTOR[,LONG],	! Pointer to Type or Variant Entry
					!      component list
	INVOCPTR: REF RST$ENTRY,	! Pointer to invocation number RST entry
	VARPTR: REF RST$VAR_ENTRY,	! Pointer to a Variant Entry pointed to
					!      by a Variant-Set RST Entry
	VARSETTBL: REF VECTOR[,LONG];	! Pointer to list of variants in a
					!      Variant-Set RST Entry



    ! Determine what kind of RST entry this is and act accordingly.
    !
    CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	SET


	! Handle the Module RST Entry.  We increment the reference count in
	! case this is a "numbered scope" Module RST Entry--such entries are
	! created for register symbols and are on the Temporary RST Entry List.
	! Since a Module RST Entry terminates every up-scope chain, we return
	! here.  This stops any up-scope recursion.
	!
	[RST$K_MODULE]:
	    BEGIN
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    RETURN;
	    END;


	! Handle all lexical entity and instruction label RST entries.  Incre-
	! ment the RST entry's reference count and call ADD_TO_REF_COUNT recur-
	! sively to increment reference counts in the whole up-scope chain.
	!
	[RST$K_ROUTINE, RST$K_BLOCK,
	 RST$K_ENTRY, RST$K_LABEL,
	 RST$K_LINE, RST$K_OVERLOAD]:
	    BEGIN
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_UPSCOPEPTR], .INCREMENT);
	    END;


	! Handle the Data and Type Component RST Entries.  Increment the refer-
	! ence count and call this routine recursively for the up-scope pointer
	! and the type pointer (if non-zero).
	!
	[RST$K_DATA, RST$K_TYPCOMP]:
	    BEGIN
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_UPSCOPEPTR], .INCREMENT);
	    IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
	    THEN
		ADD_TO_REF_COUNT(.RSTPTR[RST$L_TYPEPTR], .INCREMENT);

	    END;


	! Handle the Data Type RST Entry.  Increment its reference count.  Then
	! call ADD_TO_REF_COUNT recursively to increment the reference counts of
	! the up-scope chain and all record components or enumeration elements.
	! Note that we use a mark bit to stop infinite recursion which would
	! otherwise occur for enumeration types and possibly in other cases.
	!
	[RST$K_TYPE]:
	    BEGIN
	    IF .RSTPTR[RST$V_MARKBIT] THEN RETURN;
	    RSTPTR[RST$V_MARKBIT] = TRUE;
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_UPSCOPEPTR], .INCREMENT);
	    COMPLST = RSTPTR[RST$A_TYPCOMPLST];
	    INCR I FROM 1 TO .RSTPTR[RST$L_TYPCOMPCNT] DO
		ADD_TO_REF_COUNT(.COMPLST[.I - 1], .INCREMENT);

	    RSTPTR[RST$V_MARKBIT] = FALSE;
	    END;


	! Handle the Variant-Set RST Entry.  Here we call ADD_TO_REF_COUNT re-
	! cursively to cover all record components of the parent type.
	!
	[RST$K_VARIANT]:
	    BEGIN
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_VARTAGPTR], .INCREMENT);
	    VARSETTBL = RSTPTR[RST$A_VARSETTBL];
	    INCR I FROM 1 TO .RSTPTR[RST$L_VARSETCNT] DO
		BEGIN
		VARPTR = .VARSETTBL[.I - 1];
		COMPLST = VARPTR[RST$A_VAR_COMPLST];
		INCR J FROM 1 TO .VARPTR[RST$L_VAR_COMPCNT] DO
		    ADD_TO_REF_COUNT(.COMPLST[.J - 1], .INCREMENT);

		END;

	    END;


	! Any other kind should never show up here.  If it does, error out.
	!
	[INRANGE, OUTRANGE]:
	    $DBG_ERROR('RSTACCESS\ADD_TO_REF_COUNT 10');

	TES;


    ! If there is an Invocation Number RST Entry following this one on the Sym-
    ! bol chain, increment its reference count also.
    !
    IF .RSTPTR[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVOCPTR = .RSTPTR[RST$L_SYMCHNPTR];
	IF .INVOCPTR[RST$B_KIND] NEQ RST$K_INVOCNUM
	THEN
	    $DBG_ERROR('RSTACCESS\ADD_TO_REF_COUNT 20');

	INVOCPTR[RST$W_REFCOUNT] = .INVOCPTR[RST$W_REFCOUNT] + .INCREMENT;
	END;


    ! We are all done--return.
    !
    RETURN;

    END;

ROUTINE CHECK_DUPLICATE(CANDLST, INDEX1, INDEX2, ARRAY_FLAG) =
!
! FUNCTION
!	This routine is called from the SCOPE_RULE_XXX routines to try
!	to resolve a potential ambiguity. That is, we have two candidate
!	RST entries which are in scope and appear to be equally good.
!	But before signalling "NOUNIQUE" we may want to do some further
!	checking.
!
!	One check is for these being static data having the same address.
!	In this case, the duplicate RST entries really refer to the same 
!	entity and we can pick one arbitrarily. This situation arises
!	with FORTRAN common blocks.
!
!	Another situation where this arises is in BLISS, where the compiler
!	will put out two DST records in the same scope in situations
!	of the form:
!
!	BEGIN
!    	LOCAL X;
!       ...
!    	    BEGIN
!    	    LOCAL X;
!    	    ...
!    	    END;
!       END;
!
!	Here there really is an ambiguity which the BLISS compiler should
!	resolve by putting out block-begin block-end records, but since
!	it doesn't, we arbitrarily resolve the ambiguity by picking the
!	last X. The same situation can arise with "MAP X".
!
!	Another situation where this arises, also in BLISS, is where the
!	same field definition occurs in many modules (perhaps because of
!	REQUIRE or LIBRARY). Instead of signalling "NOUNIQUE" on this,
!	we check for the field definitions having identical values,
!	and if so, just return one of the RST pointers arbitrarily.
!
! INPUTS
!	CANDBLK - A list of candidate blocks.
!
!	INDEX1	- Index into the candidate list for the first candidate.
!
!	INDEX2	- Index into the candidate list for the second candidate.
!
!	ARRAY_FLAG - If true, the symbol we are looking up was seen in a
!		     subscripted expression. This may be used to resolve
!		     possible ambiguities in BASIC, where it is legal to
!		     have two variables of the same name, one a scalar
!		     and one an array.
!
! OUTPUTS
!	Return value is one of:
!
!	-1 : Indicates that there really is an ambiguity
!
!	one of the input parameters : means that the ambiguity was resolved
!	and this one was chosen.
!
    BEGIN

    MAP
    	CANDLST: REF VECTOR[,LONG];

    LOCAL
    	ARR_FLAG,
	BLITRLR1: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
	BLITRLR2: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
    	CANDBLK1: REF CAND_BLOCKVECTOR,
    	CANDBLK2: REF CAND_BLOCKVECTOR,
    	COUNT1,				! Count of BLISS field values
    	COUNT2,				! Count of BLISS field values
    	DSTPTR1: REF DST$RECORD,	! Pointer to first DST record
    	DSTPTR2: REF DST$RECORD,	! Pointer to second DST record
    	FCODE1,				! fcode for first RST entry
    	FCODE2,				! fcode for second RST entry
    	PTR1,				! Pointer to BLISS field values
    	PTR2,				! Pointer to BLISS field values
	RSTPTR1: REF RST$ENTRY,		! Pointer to first RST entry
    	RSTPTR2: REF RST$ENTRY,		! Pointer to second RST entry
	TMPRSTPTR: REF RST$ENTRY,	! Pointer to scratch RST entry
    	TYPEID1,			! typeid for first RST entry
    	TYPEID2;			! typeid for second RST entry


    BUILTIN
    	ACTUALCOUNT;



    ! Set up the flag which says whether we are looking up a subscripted
    ! symbol.
    !
    IF ACTUALCOUNT() GTR 3
    THEN
    	ARR_FLAG = .ARRAY_FLAG

    ELSE
    	ARR_FLAG = FALSE;


    ! Obtain the RST entries for the two potentially duplicate symbols.
    !
    CANDBLK1 = .CANDLST[.INDEX1];
    CANDBLK2 = .CANDLST[.INDEX2];
    RSTPTR1 = .CANDBLK1[0, CAND_RSTPTR];
    RSTPTR2 = .CANDBLK2[0, CAND_RSTPTR];


    ! The first thing we check for is whether these are two data items
    ! with the same static address, or two literals or enumeration
    ! elements with the same value.
    !
    IF (.RSTPTR1[RST$B_KIND] EQL RST$K_DATA) AND
       (.RSTPTR2[RST$B_KIND] EQL RST$K_DATA)
    THEN
    	BEGIN
        DSTPTR1 = .RSTPTR1[RST$L_DSTPTR];
    	DSTPTR2 = .RSTPTR2[RST$L_DSTPTR];


	! Check for two static data items at the same address, or two
	! literals or enumeration elements with the same value.
	!
	IF (((.DSTPTR1[DST$B_TYPE] GEQ DSC$K_DTYPE_LOWEST) AND (.DSTPTR1[DST$B_TYPE] LEQ DSC$K_DTYPE_HIGHEST)) OR
	     (.DSTPTR1[DST$B_TYPE] EQL DST$K_SEPTYP) OR
	     (.DSTPTR1[DST$B_TYPE] EQL DST$K_ENUMELT) OR
    	     (.DSTPTR1[DST$B_TYPE] EQL DST$K_LBLORLIT))
			      AND
	    ((.DSTPTR1[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR) OR
	     (.DSTPTR1[DST$B_VFLAGS] EQL DST$K_VALKIND_LITERAL))
	THEN
	    BEGIN
	    IF (((.DSTPTR2[DST$B_TYPE] GEQ DSC$K_DTYPE_LOWEST) AND (.DSTPTR2[DST$B_TYPE] LEQ DSC$K_DTYPE_HIGHEST)) OR
	         (.DSTPTR2[DST$B_TYPE] EQL DST$K_SEPTYP) OR
		 (.DSTPTR2[DST$B_TYPE] EQL DST$K_ENUMELT) OR
    		 (.DSTPTR2[DST$B_TYPE] EQL DST$K_LBLORLIT)) 
			      AND
	        ((.DSTPTR2[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR) OR
		 (.DSTPTR2[DST$B_VFLAGS] EQL DST$K_VALKIND_LITERAL))
	    THEN
		BEGIN
		IF (.DSTPTR1[DST$B_TYPE] EQL .DSTPTR2[DST$B_TYPE]) AND
		   (.DSTPTR1[DST$B_VFLAGS] EQL .DSTPTR2[DST$B_VFLAGS]) AND
		   (.DSTPTR1[DST$L_VALUE] EQL .DSTPTR2[DST$L_VALUE])
		THEN
	            RETURN .INDEX1;
		END;
	    END;


	! Check for two BLISS data items at the same address.
	!
	IF (.DSTPTR1[DST$B_TYPE] EQL DST$K_BLI) AND
	   (.DSTPTR2[DST$B_TYPE] EQL DST$K_BLI)
	THEN
	    BEGIN
	    IF (.DSTPTR1[DST$B_BLI_SYM_TYPE] EQL .DSTPTR2[DST$B_BLI_SYM_TYPE]) AND
	       (.DSTPTR1[DST$B_BLI_VFLAGS] EQL DST$K_VALKIND_ADDR) AND
	       (.DSTPTR2[DST$B_BLI_VFLAGS] EQL DST$K_VALKIND_ADDR)
	    THEN
		BEGIN
		BLITRLR1 = DSTPTR1[DST$A_BLI_TRLR1] + .DSTPTR1[DST$B_BLI_LNG];
		BLITRLR2 = DSTPTR2[DST$A_BLI_TRLR1] + .DSTPTR2[DST$B_BLI_LNG];
	    	IF .BLITRLR1[DST$L_BLI_VALUE] EQL .BLITRLR2[DST$L_BLI_VALUE]
		THEN
		    RETURN .INDEX1;
		END;
	    END;
    	END;


    ! Check for two routines with the same address.
    !
    IF (.RSTPTR1[RST$B_KIND] EQL RST$K_ROUTINE) AND
       (.RSTPTR2[RST$B_KIND] EQL RST$K_ROUTINE)
    THEN
	BEGIN
    	IF .RSTPTR1[RST$L_STARTADDR] EQL .RSTPTR2[RST$L_STARTADDR]
    	THEN
    	    RETURN .INDEX1;

	END;


    ! Check for a routine and an entry mask which are at the same 
    ! address. This arises in PASCAL when we import a routine name
    ! from an environment file. We see a "routine" DST in the module
    ! where the routine is really declared. We see an "entry mask"
    ! DST in the module where it is imported. In this case we choose
    ! the routine DST.
    !
    IF (.RSTPTR1[RST$B_KIND] EQL RST$K_DATA) AND
       (.RSTPTR2[RST$B_KIND] EQL RST$K_ROUTINE)
    THEN
    	BEGIN
        DSTPTR1 = .RSTPTR1[RST$L_DSTPTR];
    	IF (.DSTPTR1[DST$B_TYPE] EQL DSC$K_DTYPE_ZEM) AND
    	   (.DSTPTR1[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    	THEN
    	    BEGIN
    	    IF .DSTPTR1[DST$L_VALUE] EQL .RSTPTR2[RST$L_STARTADDR]
    	    THEN
    		RETURN .INDEX2;
    	    END;
    	END;    		
    IF (.RSTPTR1[RST$B_KIND] EQL RST$K_ROUTINE) AND
       (.RSTPTR2[RST$B_KIND] EQL RST$K_DATA)
    THEN
    	BEGIN
        DSTPTR2 = .RSTPTR2[RST$L_DSTPTR];
    	IF (.DSTPTR2[DST$B_TYPE] EQL DSC$K_DTYPE_ZEM) AND
    	   (.DSTPTR2[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    	THEN
    	    BEGIN
    	    IF .DSTPTR2[DST$L_VALUE] EQL .RSTPTR1[RST$L_STARTADDR]
    	    THEN
    		RETURN .INDEX1;
    	    END;
    	END;    		


    ! Check for language BLISS.
    !
    TMPRSTPTR = .RSTPTR1[RST$L_UPSCOPEPTR];
    WHILE .TMPRSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
        TMPRSTPTR = .TMPRSTPTR[RST$L_UPSCOPEPTR];

    IF .TMPRSTPTR[RST$B_LANGUAGE] EQL DBG$K_BLISS 
    THEN 
    	BEGIN


    	! Check for duplicate data entries in BLISS.
    	!
        IF .RSTPTR1[RST$L_UPSCOPEPTR] EQL .RSTPTR2[RST$L_UPSCOPEPTR]
        THEN
	    BEGIN
    	    IF .RSTPTR1[RST$L_DSTPTR] GTR .RSTPTR2[RST$L_DSTPTR]
            THEN
    	        RETURN .INDEX1

    	    ELSE
    		RETURN .INDEX2;

	    END;


        ! Next, check for two occurences of the same BLISS field.
        !
    	IF (.RSTPTR1[RST$B_KIND] EQL RST$K_DATA) AND
    	   (.RSTPTR2[RST$B_KIND] EQL RST$K_DATA)
    	THEN
    	    BEGIN
    	    IF DBG$STA_TYPEFCODE(.RSTPTR1) EQL RST$K_TYPE_BLIFLD
    	    THEN
	        BEGIN
    	        IF DBG$STA_TYPEFCODE(.RSTPTR2) EQL RST$K_TYPE_BLIFLD
    	        THEN
    		    BEGIN
        	    DSTPTR1 = .RSTPTR1[RST$L_DSTPTR];
    		    DSTPTR2 = .RSTPTR2[RST$L_DSTPTR];
    		    COUNT1 = .DSTPTR1[DST$L_BLIFLD_COMPS];
    		    COUNT2 = .DSTPTR2[DST$L_BLIFLD_COMPS];
    		    IF .COUNT1 EQL .COUNT2
    		    THEN
    		        BEGIN
    		        PTR1 = 1 + DSTPTR1[DST$B_NAME] + .DSTPTR1[DST$B_NAME];
    		        PTR2 = 1 + DSTPTR2[DST$B_NAME] + .DSTPTR2[DST$B_NAME];
    		        IF CH$EQL(.COUNT1, .PTR1, .COUNT2, .PTR2, 0)
    		        THEN
    			    RETURN .INDEX1;
    			END;
    		    END;
    		END;
	    END;
    	END;


    ! Check for language BASIC.
    !
    IF (.TMPRSTPTR[RST$B_LANGUAGE] EQL DBG$K_BASIC) OR
       (.TMPRSTPTR[RST$B_LANGUAGE] EQL DBG$K_RPG) 
    THEN
	BEGIN
        IF (.RSTPTR1[RST$B_KIND] EQL RST$K_DATA) AND
           (.RSTPTR2[RST$B_KIND] EQL RST$K_DATA)
    	THEN
    	    BEGIN
    	    DBG$STA_SETCONTEXT(.RSTPTR1);
    	    DBG$STA_SYMTYPE(.RSTPTR1, FCODE1, TYPEID1);
    	    DBG$STA_SETCONTEXT(.RSTPTR2);
    	    DBG$STA_SYMTYPE(.RSTPTR2, FCODE2, TYPEID2);
    	    IF (.FCODE1 EQL RST$K_TYPE_ARRAY) AND
    	       (.FCODE2 NEQ RST$K_TYPE_ARRAY)
    	    THEN
		BEGIN
    		IF .ARR_FLAG THEN RETURN .INDEX1 ELSE RETURN .INDEX2;
		END;

    	    IF (.FCODE1 NEQ RST$K_TYPE_ARRAY) AND
    	       (.FCODE2 EQL RST$K_TYPE_ARRAY)
    	    THEN
		BEGIN
    		IF .ARR_FLAG THEN RETURN .INDEX2 ELSE RETURN .INDEX1;
		END;

    	    END;    

	END;


    ! If we fall through to here then we really have an ambiguity.
    ! We indicate this by returning a -1.
    !
    RETURN -1;

    END;

ROUTINE EVAL_MAT_SPEC(MSPTR, VALPTR, VALKIND): NOVALUE =
!
! FUNCTION
!	This routine evaluates a Materialization Spec.  Materialization Specs
!	are found inside certain kinds of Value Specs when more complex computa-
!	tions are needed to produce a symbol's value.  In particular, they are
!	used when a call on a compiler-provided run-time routine or an invoca-
!	tion of the DST stack machine is used to compute the value.
!
! INPUTS
!	MSPTR	- Pointer to the Materialization Spec to be evaluated.
!
!	VALPTR	- The address of a three-longword vector to receive the value
!		  pointer and the corresponding stack frame pointer.
!
!	VALKIND	- The address of a longword location to receive the value kind.
!
! OUTPUTS
!	VALPTR	- A pointer to the desired value is returned to VALPTR.  The
!		  byte address of the value is returned to VALPTR[0] and the
!		  bit offset from that address is returned to VALPTR[1].  The
!		  corresponding stack Frame Pointer is returned to VALPTR[2].
!		  VALPTR[2] will contain zero if no frame pointer is applicable.
!
!	VALKIND	- The kind of the value pointed to by VALPTR is returned to
!		  VALKIND.  These are the possible values:
!
!			DBG$K_VAL_LITERAL - VALPTR points to a literal value.
!			DBG$K_VAL_ADDR    - VALPTR contains an address.
!			DBG$K_VAL_DESCR   - VALPTR contains the address of a
!					    descriptor.
!
!	No value is returned by EVAL_MAT_SPEC.
!

    BEGIN

    MAP
	MSPTR: REF DST$MATER_SPEC,	! Pointer to the materialization spec
	VALPTR: REF VECTOR[3],		! Pointer to value pointer vector
	VALKIND: REF VECTOR[1];		! Pointer to value kind location

    LOCAL
	VALLOC: REF VECTOR[,LONG],	! Pointer to value as computed by the
					!      mechanism specified in the spec
	REGNUM;				! Register number



    ! Determine what kind of materialization spec we have.  Compute the value
    ! of each kind as appropriate.
    !
    CASE .MSPTR[DST$B_MS_MECH] FROM DST$K_MS_MECH_MIN TO DST$K_MS_MECH_MAX OF
	SET


	! Routine Call mechanism spec.  Call a run-time routine provided by the
	! compiler in the user image to compute the desired value.
	!
	[DST$K_MS_MECH_RTNCALL]:
	    BEGIN
	    VALPTR[2] = .DBG$REG_VALUES[13];
	    VALLOC = DBG$GET_TEMPMEM(4);
	    VALSPEC_ROUT_CALL(.VALLOC, .MSPTR[DST$L_MS_MECH_RTNADDR],
			      .MSPTR[DST$V_MS_DUMARG], TRUE);
	    END;


	! Routine Call mechanism spec.  Call a run-time routine provided by the
	! compiler in the user image to compute the desired value. This differs
	! from the above RTNCALL case only in that the FP is not passed into
	! the thunk. The last parameter to VALSPEC_ROUT_CALL is a flag indicating
	! this.
	!
	[DST$K_MS_MECH_RTN_NOFP]:
	    BEGIN
	    VALPTR[2] = .DBG$REG_VALUES[13];
	    VALLOC = DBG$GET_TEMPMEM(4);
	    VALSPEC_ROUT_CALL(.VALLOC, .MSPTR[DST$L_MS_MECH_RTNADDR],
			      .MSPTR[DST$V_MS_DUMARG], FALSE);
	    END;


	! Stack machine mechanism spec.  Use the DST "stack machine" to compute
	! the desired value.
	!
	[DST$K_MS_MECH_STK]:
	    STACK_MACHINE(MSPTR[DST$A_MS_MECH_SPEC], VALLOC, VALPTR[2]);


	! Any other value is an error.
	!
	[OUTRANGE]:
	    SIGNAL(DBG$_INVDSTREC);

	TES;


    ! We have now computed the value.  Return the value and the value kind to
    ! the caller.
    !
    CASE .MSPTR[DST$B_MS_KIND] FROM DST$K_MS_BYTADDR TO DST$K_MS_DSC OF
	SET


	! We have a byte address.
	!
	[DST$K_MS_BYTADDR]:
	    BEGIN
	    VALPTR[0] = .VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have a bit address, i.e. a byte address with a bit offset.
	!
	[DST$K_MS_BITADDR]:
	    BEGIN
	    VALPTR[0] = .VALLOC[0];
	    VALPTR[1] = .VALLOC[1];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have a bit offset.
	!
	[DST$K_MS_BITOFFS]:
	    BEGIN
	    VALPTR[0] = .VALLOC[0]/8;
	    VALPTR[1] = .VALLOC[0] AND 7;
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have an "R-value", i.e a literal or constant value.
	!
	[DST$K_MS_RVAL]:
	    BEGIN
	    VALPTR[0] = VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_LITERAL;
	    END;


	! We have a register number.  Convert it into a pointer into the regis-
	! ter value vector.
	!
	[DST$K_MS_REG]:
	    BEGIN
	    REGNUM = .VALLOC[0];
	    IF (.REGNUM LSS 0) OR (.REGNUM GTR 15) THEN SIGNAL(DBG$_INVDSTREC);
	    IF .DBG$REG_VECTOR[.REGNUM] EQL 0 THEN VALSPEC_SCOPE_ERROR();
	    VALPTR[0] = DBG$REG_VALUES[.REGNUM];
	    VALPTR[1] = 0;
	    VALPTR[2] = .DBG$REG_VALUES[13];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have a descriptor address.
	!
	[DST$K_MS_DSC]:
	    BEGIN
	    VALPTR[0] = VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_DESCR;
	    END;


	! Any other value is an error.
	!
	[INRANGE, OUTRANGE]:
	    SIGNAL(DBG$_INVDSTREC);

	TES;


    ! All done--now return.
    !
    RETURN;

    END;

ROUTINE FOLLOW_STATIC_LINK(RSTPTR, SCOPE_RSTPTR) =
!
! FUNCTION
!	This routine determines the proper invocation number for a data item
!	which has been looked up in a specific scope.  This is accomplished by
!	starting with the call frame of the routine defining the scope and then
!	following the Static Links (in the call stack) until we get to a frame
!	for the routine in which the data item is declared.  The invocation
!	number of that routine is computed along the way, and is returned as the
!	invocation number of the data item.
!
!	The Static Links take us from call frame to call frame as we go up-scope
!	from the scope routine to the declaring routine.  Static links are spec-
!	ified by Value Specs in Static Link DST records.  There can be one such
!	record per routine.  However, if no such record is specified (BLISS, for
!	example, does not use them), we take the first invocation we find in the
!	call stack (after the current call frame) for the up-scope routine.  The
!	Static Link DST record always gives the right final invocation number,
!	but the first-invocation-we-find method works equally well in all but a
!	few anomalous cases.
!
! INPUTS
!	RSTPTR	- Pointer to the RST entry of the object (normally a data item)
!		  whose invocation number is to be determined.
!
!	SCOPE_RSTPTR - Pointer to the RST entry which defines the scope in which
!		  the RSTPTR item is to be found.  This scope defines the invoc-
!		  ation of RSTPTR we want.  This routine assumes that the RSTPTR
!		  item is known to be in the scope defined by SCOPE_RSTPTR.
!
! OUTPUTS
!	A pointer to an RST entry for the RSTPTR object is returned as the
!		  routine value.  This RST entry will have the proper invocation
!		  number for the object.  The returned pointer is identical to
!		  RSTPTR if the invocation number is zero.  RSTPTR is also re-
!		  turned unchanged if it does not point to a data object.
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY,		! Pointer to RST entry for data object
					!      whose invocation number is to be
					!      determined
	SCOPE_RSTPTR: REF RST$ENTRY;	! Pointer to the RST entry which
					!      defines the scope in which
					!      the object is to be found

    OWN
	SPVALUE: REF VECTOR[,LONG];	! Current call frame's SP value

    LOCAL
	CURRENT_REG: REF VECTOR[,LONG],	! Pointer to vector of current register
					!      values (at top of stack)
	DSTPTR: REF DST$RECORD,		! Pointer to Static Link DST record
	FRAME_FOUND_FLAG,		! Set to TRUE when a call frame for a
					!      desired routine has been found
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to current VAX call frame
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	J,				! Call frame register-vector index
	PATHNAME,			! Pointer to data item Pathname Descr.
	PATHSTRING,			! Pointer to pathname counted ASCII
	PCVAL,				! Current call frame's PC value
	REGPTR: REF VECTOR[,LONG],	! Pointer to a register's save location
	REGSAVELOC: REF VECTOR[,LONG],	! Pointer to call frame register save
					!      area for registers R0 - R11
	REGVEC: VECTOR[17,LONG],	! Vector of pointers to save areas for
					!      the current frame's registers
	ROUTPTR: REF RST$ENTRY,		! Pointer to RST entry for routine which
					!      declares the RSTPTR data item
	ROUT_INVOC_COUNT,		! Invocation count of ROUTPTR routine
	RPTR: REF RST$ENTRY,		! Pointer to RST entry for possible
					!      nested routine
	RUNFRAME_PTR,			! Pointer to current entry in CALL com-
					!      mand runframe stack (needed by
					!      the GET_REGISTER_VALUES routine)
	SATPTR: REF SAT$ENTRY,		! Pointer to Static Address Table entry
	SAVEREGSYMID,			! Save area for DBG$REG_SYMID
	SAVEREGVAL: VECTOR[17,LONG],	! Save area for DBG$REG_VALUES
	SAVEREGVEC: VECTOR[17,LONG],	! Save area for DBG$REG_VECTOR
	SCOPE: REF RST$ENTRY,		! Pointer to scope RST entry
	SCOPE_INVOC_COUNT,		! Invocation count of SCOPE routine
	SCOPE_INVOC_NUM,		! Invocation number we are looking for
					!      of routine pointed to by SCOPE
	STATIC_LINK_FP,			! Frame Pointer value from Static Link
					!      DST record
	VALKIND,			! Value kind returned by DBG$STA_VALSPEC
	VALVECTOR: VECTOR[3,LONG];	! Value vector returned by VALSPEC rout-
					!      ine: byte address, bit offset,
					!      and frame pointer value.



    ! If RSTPTR does not point to a Data Item RST Entry, we return it unchanged
    ! since invocation numbers are only meaningful for data objects.
    !
    IF .RSTPTR[RST$B_KIND] NEQ RST$K_DATA THEN RETURN .RSTPTR;


    ! If the scope is anything other than a routine or a block in a routine,
    ! it cannot have an associated invocation number.  We thus return the input
    ! RST pointer without change.
    !
    IF .SCOPE_RSTPTR EQL 0 THEN RETURN .RSTPTR;
    IF (.SCOPE_RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
       (.SCOPE_RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK)
    THEN
	RETURN .RSTPTR;


    ! Get the invocation number associated with the scope RST entry.
    !
    SCOPE = .SCOPE_RSTPTR;
    SCOPE_INVOC_NUM = 0;
    IF .SCOPE[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SCOPE[RST$L_SYMCHNPTR];
	SCOPE_INVOC_NUM = .INVPTR[RST$L_INVOCNUM];
	SCOPE = .INVPTR[RST$L_UPSCOPEPTR];
	END;


    ! If SCOPE points to a lexical block, find the nearest up-scope routine.
    ! This is the routine to which the scope's invocation number applies.
    !
    WHILE .SCOPE[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .SCOPE[RST$B_KIND] EQL RST$K_MODULE THEN RETURN .RSTPTR;
	SCOPE = .SCOPE[RST$L_UPSCOPEPTR];
	END;


    ! Get a pointer to the RST entry for the innermost routine up-scope from
    ! the data object RST entry.  This is the routine which immediately contains
    ! the desired data object.
    !
    ROUTPTR = .RSTPTR;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN .RSTPTR;
	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;


    ! If that innermost routine is the desired scope, we build a new RST entry
    ! for the data item with the scope's invocation number and return that.
    !
    IF .ROUTPTR EQL .SCOPE
    THEN
	BEGIN
	IF .SCOPE_INVOC_NUM EQL 0 THEN RETURN .RSTPTR;
	RETURN DBG$BUILD_INVOC_RST(.RSTPTR, .SCOPE_INVOC_NUM);
	END;


    ! The innermost routine and the desired scope are different.  We must thus
    ! go through the VAX call stack to find the proper ROUTPTR frame to go with
    ! the SCOPE we are starting with.  This requires us to follow static links
    ! where present to do the up-level addressing correctly.
    !
    ! We start by initializing the current stack frame's Program Counter (PC),
    ! Frame Pointer (FP), and other register values.  We also initialize the
    ! pointer into the CALL command runframe-stack.
    !
    PCVAL = .DBG$RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$RUNFRAME[DBG$L_USER_FP];
    CURRENT_REG = DBG$RUNFRAME[DBG$L_USER_REGS];
    RUNFRAME_PTR = .DBG$RUNFRAME[DBG$L_NEXT_LINK];
    INCR I FROM 0 TO 16 DO REGVEC[.I] = CURRENT_REG[.I];


    ! Search through the VAX call stack looking for the SCOPE routine's call
    ! frame and then the ROUTPTR call frame up-scope from it.  Pick up all
    ! register save area addresses in the stack along the way.
    !
    ROUT_INVOC_COUNT = 0;
    SCOPE_INVOC_COUNT = 0;
    STATIC_LINK_FP = 0;
    WHILE TRUE DO
	BEGIN


	! If we got to the bottom of the stack without finding the desired
	! invocation of the ROUTPTR routine, report an error.
	!
	IF (.PCVAL EQL 0) OR (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL)
	THEN
	    BEGIN
	    DBG$STA_SYMPATHNAME(.RSTPTR, PATHNAME);
	    DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
	    SIGNAL(DBG$_PROFRANOT, 1, .PATHSTRING);
	    END;


	! Check to see if the current call frame is a frame for the routine
	! currently pointed to by SCOPE.  If so, find the static link (if any)
	! and make SCOPE point to the RST entry of the routine immediately
	! up-scope from the routine currently pointed to by SCOPE.
	!
	IF (.PCVAL GEQU .SCOPE[RST$L_STARTADDR]) AND
	   (.PCVAL LEQU .SCOPE[RST$L_ENDADDR])
	THEN
	    BEGIN


	    ! The current PC value is in the range of the SCOPE routine, so we
	    ! set FRAME_FOUND_FLAG.  However, this frame could actually be for
	    ! a nested routine within the SCOPE routine.  We check for that and
	    ! clear FRAME_FOUND_FLAG if that turns out to be the case.
	    !
	    FRAME_FOUND_FLAG = TRUE;
	    SATPTR = .SCOPE[RST$L_RTNSATPTR];

            ! WARNING -- We can get into trouble here.  Previously, we have
            ! assumed that the SAT is always around.  This may not be the
	    ! case if this module has been canceled.  There are times when
	    ! the module could be canceled and then set again to make us
	    ! believe the the SAT is valid for this RST, but it is not!  To
	    ! correct the problem, when a module is canceled the field
	    ! RST$L_RTNSATPTR is set to ZERO for each routine.
	    ! So if the module for this RST has been canceled, SATPTR will
            ! be zero from the above statement. The problem is that this
	    ! assumes there are no nested routines that truly require the
	    ! correct context information.  This is, of course, WRONG.  A
	    ! way of saving and getting to the SAT information must be
	    ! found in the future.  B.A. Becker  MAY-1984
            !
	    IF .SATPTR NEQ 0
            THEN
                SATPTR = .SATPTR[SAT$L_FLINK];

	    WHILE TRUE DO
		BEGIN
		IF .SATPTR EQL 0 THEN EXITLOOP;
		IF (.PCVAL LSSU .SATPTR[SAT$L_START]) THEN EXITLOOP;
		RPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.PCVAL LEQU .SATPTR[SAT$L_END]) AND
		   (.RPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    FRAME_FOUND_FLAG = FALSE;
		    EXITLOOP;
		    END;

		SATPTR = .SATPTR[SAT$L_FLINK];
		END;


	    ! If this call frame really is for the SCOPE routine, we see if it
	    ! is the invocation we are looking for.
	    !
	    IF .FRAME_FOUND_FLAG
	    THEN
		BEGIN


		! If this is the invocation we are looking for, determine which
		! invocation of the next routine up-scope from SCOPE to look
		! for next.
		!
		IF (.STATIC_LINK_FP EQL .FRAMEPTR) OR
		   (.SCOPE_INVOC_COUNT EQL .SCOPE_INVOC_NUM)
		THEN
		    BEGIN


		    ! This is the invocation of the SCOPE routine we want.  If
		    ! this frame is also a frame for the ROUTPTR routine, we
		    ! have found the call frame we want for the data item.  We
		    ! thus exit the loop searching through the call stack.
		    !
		    IF .SCOPE EQL .ROUTPTR THEN EXITLOOP;


		    ! If no Static Link DST record was specified, we want to
		    ! look for the first invocation in the stack of the routine
		    ! up-scope from the SCOPE routine.  We set SCOPE_INVOC_NUM
		    ! and SCOPE_INVOC_COUNT to make this happen.
		    !
		    IF .SCOPE[RST$L_STATIC_LINK] EQL 0
		    THEN
			BEGIN
			SCOPE_INVOC_NUM = 1;
			SCOPE_INVOC_COUNT = 0;
			STATIC_LINK_FP = 0;
			END


		    ! But if a Static Link DST record was specified for this
		    ! routine, we use the Value Spec in that DST record to pick
		    ! up the Static Link (in the form of a Frame Pointer).  We
		    ! disable looking for the first up-scope invocation.
		    !
		    ELSE
			BEGIN
			SCOPE_INVOC_NUM = 0;
			SCOPE_INVOC_COUNT = 0;


			! Save the current register values and pointers set up
			! by DBG$STA_SETCONTEXT.  Then substitute our own regis-
			! ter set in the arrays used in Value Spec evaluation.
			!
			SAVEREGSYMID = .DBG$REG_SYMID;
			DBG$REG_SYMID = .RSTPTR;
			INCR I FROM 0 TO 16 DO
			    BEGIN
			    SAVEREGVEC[.I] = .DBG$REG_VECTOR[.I];
			    SAVEREGVAL[.I] = .DBG$REG_VALUES[.I];
			    DBG$REG_VECTOR[.I] = .REGVEC[.I];
			    REGPTR = .REGVEC[.I];
			    IF .REGPTR NEQ 0 THEN DBG$REG_VALUES[.I] = .REGPTR[0];
			    END;


			! Evaluate the Static Link Value Spec.  This produces a
			! pointer to the desired up-scope call frame.
			!
			DSTPTR = .SCOPE[RST$L_STATIC_LINK];
			DBG$STA_VALSPEC(DSTPTR[DST$A_SL_VALSPEC],
						VALVECTOR, VALKIND);
			STATIC_LINK_FP = .VALVECTOR[0];


			! Restore the saved register values and pointers.
			!
			DBG$REG_SYMID = .SAVEREGSYMID;
			INCR I FROM 0 TO 16 DO
			    BEGIN
			    DBG$REG_VECTOR[.I] = .SAVEREGVEC[.I];
			    DBG$REG_VALUES[.I] = .SAVEREGVAL[.I];
			    END;

			END;		! End of Static Link evaluation


		    ! Follow the up-scope pointer from the SCOPE routine's RST
		    ! entry to the next routine up-scope.  Set SCOPE to point
		    ! to that routine's Routine RST Entry.
		    !
		    SCOPE = .SCOPE[RST$L_UPSCOPEPTR];
		    WHILE .SCOPE[RST$B_KIND] NEQ RST$K_ROUTINE DO
			BEGIN
			IF .SCOPE[RST$B_KIND] EQL RST$K_MODULE
			THEN
			    $DBG_ERROR('RSTACCESS\FOLLOW_STATIC_LINK');

			SCOPE = .SCOPE[RST$L_UPSCOPEPTR];
			END;

		    END;		! End of STATIC_LINK_FP IF-statement


		! We now know what routine and frame to look for next.  Incre-
		! ment the invocation count for the current SCOPE routine.
		!
		SCOPE_INVOC_COUNT = .SCOPE_INVOC_COUNT + 1;

		END;			! End of FRAME_FOUND_FLAG IF-statement

	    END;			! End of PCVAL in SCOPE IF-statement


	! Check to see if the current call frame is a frame for the ROUTPTR
	! routine (but not for a nested routine within the ROUTPTR routine).
	! If so, increment the ROUTPTR routine's invocation count.  This code
	! thus computes the data item's final invocation count.
	!
	IF (.PCVAL GEQU .ROUTPTR[RST$L_STARTADDR]) AND
	   (.PCVAL LEQU .ROUTPTR[RST$L_ENDADDR])
	THEN
	    BEGIN
	    FRAME_FOUND_FLAG = TRUE;
	    SATPTR = .ROUTPTR[RST$L_RTNSATPTR];

            ! WARNING -- We can get into trouble here.  Previously, we have
            ! assumed that the SAT is always around.  This may not be the
	    ! case if this module has been canceled.  There are times when
	    ! the module could be canceled and then set again to make us
	    ! believe the the SAT is valid for this RST, but it is not!  To
	    ! correct the problem, when a module is canceled the field
	    ! RST$L_RTNSATPTR is set to ZERO for each routine.
	    ! So if the module for this RST has been canceled, SATPTR will
            ! be zero from the above statement. The problem is that this
	    ! assumes there are no nested routines that truly require the
	    ! correct context information.  This is, of course, WRONG.  A
	    ! way of saving and getting to the SAT information must be
	    ! found in the future.  B.A. Becker  MAY-1984
            !
	    IF .SATPTR NEQ 0
            THEN
                SATPTR = .SATPTR[SAT$L_FLINK];

	    WHILE TRUE DO
		BEGIN
		IF .SATPTR EQL 0 THEN EXITLOOP;
		IF (.PCVAL LSSU .SATPTR[SAT$L_START]) THEN EXITLOOP;
		RPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.PCVAL LEQU .SATPTR[SAT$L_END]) AND
		   (.RPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    FRAME_FOUND_FLAG = FALSE;
		    EXITLOOP;
		    END;

		SATPTR = .SATPTR[SAT$L_FLINK];
		END;

	    IF .FRAME_FOUND_FLAG
	    THEN
		ROUT_INVOC_COUNT = .ROUT_INVOC_COUNT + 1;

	    END;


	! Pick up the addresses of the register save areas in this call frame.
	! Save those addresses in REGVEC.  This allows us to keep track of the
	! current register values as we go on to the next frame in the stack.
	!
	GET_REGISTER_VALUES(.FRAMEPTR, RUNFRAME_PTR, REGVEC);


	! Determine what the value of SP (the Stack Pointer) is for the current
	! CALL frame and save that in the OWN variable SPVALUE.  Then make the
	! save-location pointer in REGVEC point to SPVALUE.  (Since SP does not
	! have a true save-location, the OWN variable fakes one.)
	!
	REGPTR = .REGVEC[14];
	SPVALUE = .REGPTR[0];
	REGVEC[14] = SPVALUE;


	! Dig out the values of PC and FP for the current CALL frame.  Then
	! loop for the next stack frame.
	!
	REGPTR = .REGVEC[15];
	PCVAL = .REGPTR[0];
	REGPTR = .REGVEC[13];
	FRAMEPTR = .REGPTR[0];

	END;				! End of loop through the call stack


    ! We have now found the proper invocation number for the ROUTPTR routine.
    ! We thus build an RST entry for the data item with that invocation number
    ! (if necessary) and return a pointer to that RST entry.
    !
    IF .ROUT_INVOC_COUNT EQL 0 THEN RETURN .RSTPTR;
    RETURN DBG$BUILD_INVOC_RST(.RSTPTR, .ROUT_INVOC_COUNT);

    END;

ROUTINE GET_REGISTER_SYMID(PATHDESCR, SCOPEPTR, REG_LINE_LEX_PTR) =
!
! FUNCTION
!	This routine determines whether a given input symbol is a register
!	name or not, and if so returns that register's SYMID.  The input
!	symbol is identified by a Pathname Descriptor from which the symbol
!	name is extracted.  If the symbol name is a register name (R0 - R11,
!	AP, FP, SP, PC, or PSL) with or without a leading percent-sign, a
!	a Data RST Entry and a DST record are created for the register.  The
!	data type is set to longword integer (DSC$K_DTYPE_L) in the DST record
!	and the name is set to the register name with a leading percent-sign
!	("%R5" or "%SP", for example).
!
!	The RST entry's up-scope pointer is set as follows.  If the register is
!	located in a normal named scope (MOD\ROUT\%R5, for example), the regis-
!	ter RST entry's up-scope pointer is set to point to the RST entry for
!	that scope.  If the scope is a numeric scope (such as 0\%R5) which can
!	be converted to a named scope, the same thing is done.  However, if the
!	numeric scope cannot be converted to a named scope, meaning that no SET
!	module contains that scope, a dummy "numeric scope" Module RST Entry is
!	built to represent that scope.  This RST entry has the RST$V_MODNUMSCP
!	bit set which is later recognized by DBG$STA_SETCONTEXT as representing
!	an unnamed numeric scope.  The name of this "module" is set to be the
!	scope number in ASCII.  Finally, if the scope is the global scope (the
!	GST) or a named scope in a module which is not SET (or does not exist),
!	then the register RST entry is discarded and a zero SYMID is returned
!	(no such symbol).
!
!	The register RST entry and the numeric scope Module RST Entry (if any)
!	are both put on the Temporary RST Entry List.  The address of the regis-
!	ter RST entry is then returned as the register's SYMID.  If the input
!	symbol does not name a register or does not name a register in a SET
!	module, a zero is returned to indicate this.
!
! INPUTS
!	PATHDESCR - A pointer to the Pathname Descriptor for the input symbol.
!		  This descriptor thus identifies the symbol to be checked for
!		  being a register name.
!
!	SCOPEPTR - A pointer to a Scope List Entry for the scope in which the
!		  register is located.  If there is no such scope, SCOPEPTR
!		  is zero.
!
!	REG_LINE_LEX_PTR - If there is a line number in the symbol pathname,
!		  this parameter gives the SYMID of the lexical entity named
!		  by that line number.  If there is no line number, this value
!		  is zero.
!
! OUTPUTS
!	If the input symbol is a register name, an RST Entry is created for
!		  this register and its address is returned as the register's
!		  SYMID.  If the symbol is not a register, zero is returned.
!

    BEGIN

    MAP
	PATHDESCR: REF PTH$PATHNAME,	! Pointer to symbol Pathname Descriptor
	SCOPEPTR: REF SCOPE$ENTRY;	! Pointer to Scope List Entry

    BIND
	REGTBL = UPLIT ('R0  ', 'R1  ', 'R2  ', 'R3  ',	! Register name table
			'R4  ', 'R5  ', 'R6  ', 'R7  ',	!
			'R8  ', 'R9  ', 'R10 ', 'R11 ',	!
			'AP  ', 'FP  ', 'SP  ', 'PC  ',	!
			'PSL ', 'R12 ', 'R13 ', 'R14 ',	!
			'R15 '): VECTOR[,LONG];

    LOCAL
	DSTNAME: REF VECTOR[,BYTE],	! Pointer to DST record name field
	DSTPTR: REF DST$RECORD,		! Pointer to created register DST record
	LENGTH,				! The byte length of the symbol name
	MODPTR: REF RST$ENTRY,		! Pointer to Module RST Entry or to
					!      "numeric scope" Module RST Entry
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to the symbol's name string
	NEWVALUE,			! Temporary in decimal conversion
	NUMNAME: VECTOR[12, BYTE],	! Numeric scope name in Counted ASCII
	NUMTEMP: VECTOR[12, BYTE],	! Temporary used to compute NUMNAME
	NUMSCP_INVOC_NUM,		! The invocation number associated with
					!      a named numeric scope
	PATHSTRING,			! Pointer to pathname Counted ASCII
	PATHVEC: REF VECTOR[,LONG],	! Pointer to pathname vector
	PNAME: REF VECTOR[,BYTE],	! Pointer to Counted ASCII string
	REGNUM,				! The register number of the register
	RNAME: REF VECTOR[,BYTE],	! Pointer to Counted ASCII string
	RPTR: REF RST$ENTRY,		! Temporary RST entry pointer
	RSTPTR: REF RST$ENTRY,		! Pointer to created register RST entry
	SCOPE: REF RST$ENTRY,		! Pointer to RST entry for named scope
					!      corresponding to a numeric scope
	SCOPENTRY: SCOPE$ENTRY,		! Local copy of input Scope List Entry
	TEMPNAME: VECTOR[4, BYTE],	! Upcased copy of symbol name
	VALUE;				! The numeric scope number--used to con-
					!      vert that number to decimal ASCII



    ! Check that this Pathname Descriptor describes a symbol name without data
    ! qualification and that the symbol contains at least two characters (such
    ! as "R5") and at most four characters (such as "%R11").  If not, this is
    ! not a register reference and we return zero.
    !
    IF .PATHDESCR[PTH$B_PATHCNT] NEQ .PATHDESCR[PTH$B_TOTCNT] THEN RETURN 0;
    PATHVEC = PATHDESCR[PTH$A_PATHVECTOR];
    NAMEPTR = .PATHVEC[.PATHDESCR[PTH$B_PATHCNT] - 1];
    LENGTH = .NAMEPTR[0];
    IF .LENGTH LSS 2 OR .LENGTH GTR 4 THEN RETURN 0;
    NAMEPTR = NAMEPTR[1];


    ! If the symbol contains a leading percent-sign (as in "%R5"), strip it off.
    !
    IF .NAMEPTR[0] EQL '%'
    THEN
	BEGIN
	NAMEPTR = .NAMEPTR + 1;
	LENGTH = .LENGTH - 1;
	END;


    ! Copy the symbol name to a temporary buffer.  The temporary copy is
    ! upcased so that register names are recognized regardless of case.
    ! This is mainly important for language C.
    !
    INCR I FROM 0 TO .LENGTH - 1 DO
	BEGIN
	TEMPNAME[.I] = .NAMEPTR[.I];
	IF (.TEMPNAME[.I] GEQ 'a') AND (.TEMPNAME[.I] LEQ 'z')
	THEN
	    TEMPNAME[.I] = .TEMPNAME[.I] - 'a' + 'A';

	END;


    ! Loop through the list of valid register names to see if this symbol's
    ! name is a register name.
    !
    REGNUM = -1;
    INCR I FROM 0 TO 20 DO
	BEGIN
	IF CH$EQL(.LENGTH, TEMPNAME, 3, REGTBL[.I], ' ')
	THEN
	    BEGIN
	    REGNUM = .I;
	    EXITLOOP;
	    END;

	END;


    ! If the symbol name was not a register name, return zero--not a register.
    !
    IF .REGNUM LSS 0 THEN RETURN 0;


    ! It is a register name.  If REGNUM is larger than 16, the user requested
    ! R12, R13, R14, or R15, so we reset REGNUM to point to AP, FP, SP, or PC.
    !
    IF .REGNUM GTR 16 THEN REGNUM = .REGNUM - 5;


    ! Create a Data RST Entry for the register.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ + (11 + %UPVAL)/%UPVAL);
    DSTPTR = .RSTPTR + RST$K_DATENTSIZ*%UPVAL;
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$B_KIND] = RST$K_DATA;
    RSTPTR[RST$V_NONZLENGTH] = TRUE;
    RSTPTR[RST$V_REGISTER] = TRUE;


    ! Also create a DST record for the register.  This DST record makes
    ! the data type longword integer and contains the register name
    ! preceded by a percent-sign (e.g., "%R5").
    !
    DSTPTR[DST$B_LENGTH] = 8 + .LENGTH;
    DSTPTR[DST$B_TYPE] = DSC$K_DTYPE_L;
    DSTPTR[DST$V_VALKIND] = DST$K_VALKIND_REG;
    DSTPTR[DST$L_VALUE] = .REGNUM;
    DSTPTR[DST$B_NAME] = .LENGTH + 1;
    DSTNAME = DSTPTR[DST$B_NAME];
    DSTNAME[1] = '%';
    CH$MOVE(.LENGTH, REGTBL[.REGNUM], DSTNAME[2]);


    ! Link the new RST entry into the Temporary RST Entry List.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Make a local copy of the Scope List Entry.  Then see if the scope is a
    ! module scope (as opposed to a routine scope) and is not explicitly speci-
    ! fied as a pathname; this will commonly be the case in language MACRO.
    ! If so, we change the scope to numeric scope 0 by modifying the local
    ! Scope List Entry.  This causes the the current value of the specified
    ! register to be shown.
    !
    IF .SCOPEPTR EQL 0 THEN RETURN 0;
    CH$MOVE(SCOPE$K_ENTSIZE*%UPVAL, .SCOPEPTR, SCOPENTRY);
    IF (.SCOPENTRY[SCOPE$L_STATE] EQL SCOPE$K_NORMAL) AND
       (.PATHDESCR[PTH$B_TOTCNT] EQL 1)
    THEN
	BEGIN
	RPTR = .SCOPENTRY[SCOPE$L_RSTPTR];
	WHILE .RPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	    BEGIN
	    IF .RPTR[RST$B_KIND] EQL RST$K_MODULE
	    THEN
		BEGIN
		SCOPENTRY[SCOPE$L_STATE] = SCOPE$K_NUMBERED;
		SCOPENTRY[SCOPE$L_MODPTR] = 0;
		EXITLOOP;
		END;

	    RPTR = .RPTR[RST$L_UPSCOPEPTR];
	    END;

	END;


    ! Similarly, if the scope is the Global Scope (the GST) and is not expli-
    ! citly specified as a pathname, we change the scope to numeric scope 0.
    ! This situation is not particularly common, but most likely the user wants
    ! the current register value in this situation.
    !
    IF (.SCOPENTRY[SCOPE$L_STATE] EQL SCOPE$K_GLOBAL) AND
       (.PATHDESCR[PTH$B_TOTCNT] EQL 1)
    THEN
	BEGIN
	SCOPENTRY[SCOPE$L_STATE] = SCOPE$K_NUMBERED;
	SCOPENTRY[SCOPE$L_MODPTR] = 0;
	END;


    ! Now determine what scope this register RST entry should be put in.  This
    ! is determined by the kind of the local Scope List Entry.
    !
    CASE .SCOPENTRY[SCOPE$L_STATE] FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
	SET


	! Handle normal named scopes.  If the scope's module is not set, we
	! return zero (no such register).  Otherwise, we have a good scope and
	! simply put this scope up-scope from the register RST entry.  We then
	! return the address of the register RST entry as the register SYMID
	! unless a line number appeared in the pathname.
	!
	[SCOPE$K_NORMAL]:
	    BEGIN
	    MODPTR = .SCOPENTRY[SCOPE$L_MODPTR];
	    IF NOT .MODPTR[RST$V_MODSET] THEN RETURN 0;
	    RSTPTR[RST$L_UPSCOPEPTR] = .SCOPENTRY[SCOPE$L_RSTPTR];


	    ! If there is a line number in the pathname, then the line number
	    ! refers to the lexical entity pointed to by REG_LINE_LEX_PTR.  In
	    ! this case we make sure the scope we have contains that entity;
	    ! otherwise the pathname is in error and we return 0.  If the
	    ! pathname is okay, we attach the register SYMID to the lexical
	    ! entity specified by the line number.
	    !
	    IF .REG_LINE_LEX_PTR NEQ 0
	    THEN
		BEGIN
	        RPTR = .REG_LINE_LEX_PTR;
	        WHILE TRUE DO
		    BEGIN
		    IF .RPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN 0;
		    IF .RPTR EQL .RSTPTR[RST$L_UPSCOPEPTR]
		    THEN
			BEGIN
			RSTPTR[RST$L_UPSCOPEPTR] = .REG_LINE_LEX_PTR;
			EXITLOOP;
			END;

		    RPTR = .RPTR[RST$L_UPSCOPEPTR];
		    END;

		END;


	    ! Unless there was an invocation number in the pathname, return the
	    ! register SYMID now.
	    !
	    IF .PATHDESCR[PTH$B_LOCINVOC] EQL 0 THEN RETURN .RSTPTR;


	    ! There is an invocation number.  Find the inner-most routine con-
	    ! taining the declaration of this symbol.  This is the routine to
	    ! which the invocation number must apply.
	    !
	    RPTR = .RSTPTR;
	    WHILE .RPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
		BEGIN
		IF .RPTR[RST$B_KIND] EQL RST$K_MODULE
		THEN
		    BEGIN
		    DBG$NPATHDESC_TO_CS(.PATHDESCR, PATHSTRING);
		    SIGNAL(DBG$_MISINVNUM, 1, .PATHSTRING);
		    END;

		RPTR = .RPTR[RST$L_UPSCOPEPTR];
		END;


	    ! Now make sure the invocation number was indeed appended to that
	    ! routine name in the pathname.
	    !
	    PNAME = .PATHVEC[.PATHDESCR[PTH$B_LOCINVOC] - 1];
	    RNAME = DBG$GET_DST_NAME(.RPTR[RST$L_DSTPTR]);
	    IF CH$NEQ(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0)
	    THEN
		BEGIN
		DBG$NPATHDESC_TO_CS(.PATHDESCR, PATHSTRING);
		SIGNAL(DBG$_MISINVNUM, 1, .PATHSTRING);
		END;


	    ! All looks good.  Create the Invocation Number RST Entry along
	    ! with a new copy of the symbol's RST entry if the number is
	    ! non-zero.
	    !
	    IF .PATHDESCR[PTH$L_INVOCNUM] NEQ 0
	    THEN
		RSTPTR = DBG$BUILD_INVOC_RST(.RSTPTR, .PATHDESCR[PTH$L_INVOCNUM]);

	    RETURN .RSTPTR;

	    END;			! End of Normal scope code


	! Handle numeric scopes.  (A "numeric scope" is the scope a specified
	! number of call frames down in the VAX call stack; 2\%R5, for example,
	! refers to %R5 in the call frame two levels down in the stack.)  Here
	! we do one of two things: if we can find a named scope in a SET module
	! corresponding to the given numeric scope, we attach the register RST
	! entry to that scope; and if we cannot, we create a special "numeric
	! scope" Module RST Entry to represent the unnamed numeric scope.  In
	! either case, we return a non-zero register SYMID.
	!
	[SCOPE$K_NUMBERED]:
	    BEGIN


	    ! See if we can convert this numeric scope to a regular named scope
	    ! with a normal RST entry.  If so, we put that scope RST entry up-
	    ! scope from the register RST entry and return the register SYMID.
	    ! (Note that we build an Invocation Number RST Entry if necessary.)
	    !
	    DBG$STA_NUMBERED_SCOPE(.SCOPENTRY[SCOPE$L_MODPTR],
					MODPTR, SCOPE, NUMSCP_INVOC_NUM);
	    IF .SCOPE NEQ 0
	    THEN
		BEGIN
		RSTPTR[RST$L_UPSCOPEPTR] = .SCOPE;
		IF .NUMSCP_INVOC_NUM NEQ 0
		THEN
		    RSTPTR = DBG$BUILD_INVOC_RST(.RSTPTR, .NUMSCP_INVOC_NUM);

		RETURN .RSTPTR;
		END;


	    ! We have a numeric scope, but it does not correspond to any RST
	    ! entry in any SET module.  We therefore create a "numeric scope"
	    ! Module RST Entry to represent the numeric scope.  This entry has
	    ! the RST$V_MODNUMSCP bit set and will therefore be recognized as
	    ! representing a numbered stack frame by DBG$STA_SETCONTEXT.
	    !
	    ! First generate the name of this pseudo-module, namely the scope
	    ! number in Counted ASCII.  We get the scope number from the Scope
	    ! List Entry.
	    !
	    VALUE = .SCOPENTRY[SCOPE$L_MODPTR];
	    LENGTH = 0;
	    WHILE TRUE DO
		BEGIN
		NEWVALUE = .VALUE/10;
		NUMTEMP[.LENGTH] = .VALUE - .NEWVALUE*10 + '0';
		LENGTH = .LENGTH + 1;
		IF .NEWVALUE EQL 0 THEN EXITLOOP;
		VALUE = .NEWVALUE;
		END;

	    NUMTEMP[.LENGTH] = .LENGTH;
	    INCR I FROM 0 TO .LENGTH DO
		NUMNAME[.I] = .NUMTEMP[.LENGTH - .I];


	    ! Now allocate space for this "module" RST entry and the associated
	    ! Module Begin and Module End DST entries.  Then fill in the "nume-
	    ! ric scope" Module RST Entry, including the RST$V_MODNUMSCP flag.
	    !
	    MODPTR = DBG$GET_MEMORY(RST$K_MODENTSIZ + (DST$K_MODBEG_SIZE
			+ .LENGTH + DST$K_MODEND_SIZE + %UPVAL - 1)/%UPVAL);
	    DSTPTR = .MODPTR + RST$K_MODENTSIZ*%UPVAL;
	    MODPTR[RST$L_DSTPTR] = .DSTPTR;
	    MODPTR[RST$B_KIND] = RST$K_MODULE;
	    MODPTR[RST$B_LANGUAGE] = .DBG$GB_LANGUAGE;
	    MODPTR[RST$L_MODSCPNUM] = .SCOPENTRY[SCOPE$L_MODPTR];
	    MODPTR[RST$V_MODNUMSCP] = TRUE;
	    MODPTR[RST$V_MODSET] = TRUE;
	    MODPTR[RST$V_MOD_IN_RST] = TRUE;


	    ! Also fill in the dummy module's Module Begin and End DST records.
	    !
	    DSTPTR[DST$B_LENGTH] = DST$K_MODBEG_SIZE - 1 + .LENGTH;
	    DSTPTR[DST$B_TYPE] = DST$K_MODBEG;
	    DSTPTR[DST$L_MODBEG_LANGUAGE] = .MODPTR[RST$B_LANGUAGE];
	    CH$MOVE(.LENGTH + 1, NUMNAME[0], DSTPTR[DST$B_MODBEG_NAME]);
	    DSTPTR = .DSTPTR + DST$K_MODBEG_SIZE + .LENGTH;
	    DSTPTR[DST$B_LENGTH] = DST$K_MODEND_SIZE - 1;
	    DSTPTR[DST$B_TYPE] = DST$K_MODEND;


	    ! Put the dummy Module RST Entry on the Temporary RST Entry List.
	    ! Also put it up-scope from the register RST entry.  Then return
	    ! the address of the register RST entry as the register SYMID.
	    !
	    MODPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	    RST$TEMP_LIST = .MODPTR;
	    RSTPTR[RST$L_UPSCOPEPTR] = .MODPTR;
	    RETURN .RSTPTR;
	    END;


	! Any other scope (such as the global scope) cannot contain a register,
	! so we return zero to indicate that this is not a register.
	!
	[INRANGE, OUTRANGE]:
	    RETURN 0;

	TES;

    END;

ROUTINE GET_RECORD_ADDRESS( Primptr, Inner_outer_flag ) =
!
! FUNCTION
!	GET_RECORD_ADDRESS returns the address of the inner or outer record
!	based on the primary pointer and the flag passed.
!	It's called from the stack machine when the value of a record's field 
!	depends on the contents of the record.
!
! INPUTS
!	Primptr		 - A pointer to a primary descriptor passed by value.
!	Inner_outer_flag - A flag indicating whether the inner or outer record
!			   address should be returned.
!
! OUTPUTS
!	The address of the record.
!
! SIDE EFFECTS
!	Errors may be signaled
!
    BEGIN

    LOCAL
	Current_subnode : REF DBG$PRIM_NODE,				! Pointer to the current subnode
	Err_vec,							! Returned by DBG$NCOPY_DESC
	Local_current_primary,						! For DBG$GL_CURRENT_PRIMARY
	Local_primary : REF DBG$PRIMARY,				! Pointer to the copied primary
	Local_val_desc : REF DBG$VALDESC;				! Local value descriptor

    !++
    ! Check for a no Primary
    !--
    IF .Primptr EQLA 0
    THEN
    	$DBG_ERROR( 'RSTACCESS\GET_RECORD_ADDRESS - zero primary' );

    !++
    ! Make a copy of the current primary so we can mangle it
    !--
    IF NOT DBG$NCOPY_DESC( .Primptr, Local_primary, Err_vec, FALSE )
    THEN
	BEGIN
	EXTERNAL ROUTINE
	    LIB$SIGNAL : ADDRESSING_MODE(GENERAL);
	BUILTIN
	    CALLG;
	CALLG (.Err_vec, LIB$SIGNAL );
	END;

    !++
    ! Loop backwards on the primary.
    !	1. If we wrap around we know that we want just the first subnode
    !	   i.e.  A.B.C where A is the record whose address we want.
    !	2. If we find a TPTR we know we want it and its object.
    !	   i.e. Q.P^A.B.C where Q.P^ is what we want.
    !	3. If we want the inner most record we stop when we see a record
    !	   subnode.
    !--
    Current_subnode = .Local_primary[ DBG$L_PRIM_BLINK ];
    WHILE .Current_subnode NEQ Local_primary[ DBG$L_PRIM_FLINK ] DO
        BEGIN
	    SELECTONE .Current_subnode[ DBG$B_PNODE_FCODE ] OF
	    SET

	    [RST$K_TYPE_RECORD]:
		IF .Inner_outer_flag EQL Inner
		THEN
		    EXITLOOP;

	    [RST$K_TYPE_TPTR,
	     RST$K_TYPE_PTR]:
		BEGIN
		Current_subnode = .Current_subnode[ DBG$L_PNODE_FLINK ];
		EXITLOOP;
		END;

	    TES;

        Current_subnode = .Current_subnode[ DBG$L_PNODE_BLINK ];
        END;

    ! Go forward one if we wrapped around
    !
    IF .Current_subnode EQL Local_primary[ DBG$L_PRIM_FLINK ]
    THEN
	Current_subnode = .Current_subnode[ DBG$L_PNODE_FLINK ];

    ! Check that all is well
    !
    IF .Current_subnode[ DBG$B_PNODE_FCODE ] NEQ RST$K_TYPE_RECORD
    THEN
	$DBG_ERROR( 'RSTACCESS\GET_RECORD_ADDRESS - No record in Primary desc. Bad DST' );

    ! Trim off what we don't want
    !
    Local_primary[ DBG$L_PRIM_BLINK ] = .Current_subnode;
    Current_subnode[ DBG$L_PNODE_FLINK ] = Local_primary[ DBG$L_PRIM_FLINK ];

    ! Save DBG$GL_CURRENT_PRIMARY because DBG$PRIM_TO_VAL updates it
    !
    Local_current_primary = .DBG$GL_CURRENT_PRIMARY;

    ! Get the value
    !
    IF NOT DBG$PRIM_TO_VAL( .Local_primary, DBG$K_V_VALUE_DESC, Local_val_desc )
    THEN
        $DBG_ERROR( 'RSTACCESS\GET_RECORD_ADDRESS - DBG$PRIM_TO_VAL failed.  Bad DST' );

    ! Restore DBG$GL_CURRENT_PRIMARY because DBG$PRIM_TO_VAL updates it
    !
    DBG$GL_CURRENT_PRIMARY = .Local_current_primary;

    RETURN .Local_val_desc[ DBG$L_VALUE_POINTER ];

    END;

ROUTINE GET_REGISTER_VALUES(CURRENT_FP, RUNFRAME_PTR, REGVECTOR): NOVALUE =
!
! FUNCTION
!	This routine determines the register values associated with a given
!	CALL frame on the VAX call stack.  It accepts a PC value and a frame
!	pointer value and some other arguments as input, and produces a vector
!	of register save addresses as output.  By indirecting through those
!	save addresses, the actual register values associated with the given
!	CALL frame can be obtained.
!
!	In addition to getting the addresses of all registers saved in a normal
!	CALL frame, this routine understands how to get the register values
!	associated with the CALL frames generated by calls on exception hand-
!	lers (which have a return address pointing into system space) and by
!	DEBUG CALL commands (which have a return address pointing into DEBUG).
!	In the case of calls on exception handlers, some register values (in-
!	cluding the PC) must be gotten from the exception handler's signal and
!	mechanism arguments.  In the case of DEBUG CALL commands, all of the
!	register values of the next stack frame must be gotten from DEBUG's
!	stack of saved run-frames.
!
! INPUTS
!	CURRENT_FP - The address of the CALL frame from which the new set of
!		  register save locations is to be extracted.  This is thus
!		  the value of FP in the called routine.
!
!	RUNFRAME_PTR - The address of a longword which must be initialized to
!		  contain the value .DBG$RUNFRAME[DBG$L_NEXT_LINK] before this
!		  this routine is called in the course of looping through the
!		  CALL stack.
!
!	REGVECTOR - The address of a 17-longword vector to receive all register
!		  save addresses from the current CALL frame.
!
! OUTPUTS
!	RUNFRAME_PTR - The RUNFRAME_PTR location is updated to point to the
!		  next saved run-frame on the CALL command run-frame stack
!		  each time one such run-frame is accessed to get the register
!		  values of the routine which was active at the time of the
!		  CALL command.
!
!	REGVECTOR - The addresses at which registers 0 - 16 are saved for the
!		  given CALL frame are returned to longwords 0 - 16 of the
!		  REGVECTOR vector.  (Register 16 is the PSW in this context.)
!

    BEGIN

    MAP
	CURRENT_FP: REF BLOCK[,BYTE],	! The address of the current CALL frame
	RUNFRAME_PTR: REF VECTOR[1],	! Pointer to saved-runframe pointer
	REGVECTOR: REF VECTOR[,LONG];	! Pointer to the vector of register
					!      save location addresses

    OWN
	SPVALUE: REF VECTOR[,LONG];	! Current CALL frame's SP value

    LOCAL
	CALLER_PC,			! The PC of the caller of the current
					!      routine (the return address)
	J,				! Index value used for several purposes
	MECH_VECTOR: REF BLOCK[,BYTE],	! Pointer to Mechanism Argument Vector
	REGMASK: BITVECTOR[16],		! The register save mask bit vector
	REGSAVELOC: REF VECTOR[,LONG],	! Pointer to CALL frame register save
					!      area for registers R0 - R11
	REGPTR: REF VECTOR[,LONG],	! Pointer to a register's save location
	REGVEC: VECTOR[17, LONG],	! Vector of pointers to save areas for
	SAVED_REGVECTOR:		! Pointer to vector of saved registers
		REF VECTOR[,LONG],	!      in saved CALL command runframe
	SAVED_RUNFRAME:			! Pointer to saved runframe from the
		REF BLOCK[,BYTE],	!      DEBUG CALL command
	SIG_VECTOR: REF VECTOR[,LONG];	! Pointer to the Signal Argument Vector



    ! Get the return PC stored in the current CALL frame.
    !
    CALLER_PC = .CURRENT_FP[SF$L_SAVE_PC];


    ! Check to see if this is an exception handler.  (A handler is recognized
    ! by having a return PC of hex 80000014, which is where the VMS exception
    ! handling mechanism calls user handlers.)  If this is an exception hand-
    ! ler, we must get the register values of the signaller from the current
    ! call frame, from the signal arguments, and from the mechanism arguments,
    ! depending on the register.
    !
    IF .CALLER_PC EQL %X'80000014'
    THEN
	BEGIN


	! Extract the save addresses of AP and FP for this CALL frame.
	!
	REGVECTOR[12] = CURRENT_FP[SF$L_SAVE_AP];
	REGVECTOR[13] = CURRENT_FP[SF$L_SAVE_FP];


	! Extract the save locations of all other saved registers in this CALL
	! frame.
	!
	REGMASK = .CURRENT_FP[SF$W_SAVE_MASK];
	REGSAVELOC = CURRENT_FP[SF$L_SAVE_REGS];
	J = 0;
	INCR I FROM 0 TO 11 DO
	    BEGIN
	    IF .REGMASK[.I]
	    THEN
		BEGIN
		REGVECTOR[.I] = REGSAVELOC[.J];
		J = .J + 1;
		END;

	    END;


	! Set the stack pointer to point at the end of the saved registers.
	! Adjust it by the offset value.  Also pass the one longword of junk
	! the VMS signal mechanism puts on the stack (a JSB return address).
	!
	SPVALUE = REGSAVELOC[.J];
	SPVALUE = .SPVALUE + .CURRENT_FP[SF$V_STACKOFFS];
	SPVALUE = .SPVALUE + 4;


	! Get the pointer to the signal argument list and pick up the address
	! of the saved PC in the signal argument list.  We also pick up the
	! address of the saved PSL in the signal argument list.
	!
	SIG_VECTOR = .SPVALUE[1];
	J = .SIG_VECTOR[0];
	REGVECTOR[15] = SIG_VECTOR[.J - 1];
	REGVECTOR[16] = SIG_VECTOR[.J];


	! Get the pointer to the mechanism argument list and pick up the save
	! addresses of the signaller's values of R0 and R1.
	!
	MECH_VECTOR = .SPVALUE[2];
	REGVECTOR[0] = MECH_VECTOR[CHF$L_MCH_SAVR0];
	REGVECTOR[1] = MECH_VECTOR[CHF$L_MCH_SAVR1];


	! Finally compute the SP value by skipping past the exception handler
	! argument list, the list of signal arguments, one longword of trash,
	! and the list of mechanism arguments.
	!
	SPVALUE = SPVALUE[.SPVALUE[0] + 1];
	SPVALUE = SPVALUE[.SPVALUE[0] + 1];
	SPVALUE = .SPVALUE + 4;
	SPVALUE = SPVALUE[.SPVALUE[0] + 1];
	REGVECTOR[14] = SPVALUE;
	END


    ! Check to see if the current routine was called with a DEBUG CALL command.
    ! (A CALL command is recognized by the DBG$PSEUDO_EXIT return address.)
    ! If so, we must dig out all the register values as they were at the time
    ! of the CALL.  We dig out the save locations of these values from the run-
    ! frame at our current location on the saved-runframe stack.
    !
    ELSE IF .CALLER_PC EQL DBG$PSEUDO_EXIT
    THEN
	BEGIN
	SAVED_RUNFRAME = .RUNFRAME_PTR[0];
	SAVED_REGVECTOR = SAVED_RUNFRAME[DBG$L_USER_R0];
	INCR I FROM 0 TO 16 DO
	    REGVECTOR[.I] = SAVED_REGVECTOR[.I];

	RUNFRAME_PTR[0] = .SAVED_RUNFRAME[DBG$L_NEXT_LINK];
	END


    ! For any other case, we have a normal CALL frame on the stack and we can
    ! dig out the register values in the normal way.  That is done here.
    !
    ELSE
	BEGIN


	! Get the save locations of all registers of the set R0 - R11 that are
	! saved in this CALL frame.  Save those addresses in REGVECTOR.
	!
	REGMASK = .CURRENT_FP[SF$W_SAVE_MASK];
	REGSAVELOC = CURRENT_FP[SF$L_SAVE_REGS];
	J = 0;
	INCR I FROM 0 TO 11 DO
	    BEGIN
	    IF .REGMASK[.I]
	    THEN
		BEGIN
		REGVECTOR[.I] = REGSAVELOC[.J];
		J = .J + 1;
		END;

	    END;


	! If R0 or R1 is not saved, we zero the corresponding REGVECTOR cells
	! to indicate that those registers are not available at all--R0 and R1
	! are not preserved over subroutine calls.
	!
	IF NOT .REGMASK[0] THEN REGVECTOR[0] = 0;
	IF NOT .REGMASK[1] THEN REGVECTOR[1] = 0;


	! Get the addresses of the save locations for registers AP, FP, SP,
	! PC, and PSW.  Store those addresses in REGVECTOR.
	!
	REGVECTOR[12] = CURRENT_FP[SF$L_SAVE_AP];
	REGVECTOR[13] = CURRENT_FP[SF$L_SAVE_FP];
	REGVECTOR[14] = SPVALUE;
	REGVECTOR[15] = CURRENT_FP[SF$L_SAVE_PC];
	REGVECTOR[16] = CURRENT_FP[SF$W_SAVE_PSW];


	! Determine the value of SP (the Stack Pointer) by pointing it to the
	! end of the register save area, adjusting it by the offset value, and
	! pointing it past the CALLS argument list (if any).  Save the computed
	! SP value in SPVALUE.
	!
	SPVALUE = REGSAVELOC[.J];
	SPVALUE = .SPVALUE + .CURRENT_FP[SF$V_STACKOFFS];
	IF .CURRENT_FP[SF$V_CALLS] THEN SPVALUE = .SPVALUE + 4*(.SPVALUE[0] + 1);
	END;


    ! We are done getting the register values and can now return.
    !
    RETURN;

    END;

ROUTINE SCOPE_RULE_COBOL(PATHNAME, NCANDS, CANDLST, SCOPE) =
!
! FUNCTION
!	This routine selects the symbol from a specified list of candidate sym-
!	bols which best matches a specified pathname.  This routine assumes
!	COBOL scope rules when doing so.  This means that incomplete data quali-
!	fication is accepted, and that uniqueness is determined by these rules:
!
!	    (1)	By definition, the "lowest definition depth" is the
!		inner-most definition depth in the current scope at
!		which at least one candidate symbol is declared.
!
!	    (2)	If only one candidate symbol is defined at the lowest
!		definition depth, then that is the unique symbol we
!		want.
!
!	    (3)	Otherwise, the symbol is not unique.
!
!	An additional COBOL scope rule is that any candidate which is not marked
!	as "global" (i.e., does not have the RST$V_COBOLGBL bit set) may not be
!	declared outside the routine which contains the current scope.  In other
!	words, a COBOL symbol declared in one routine is not visible in any
!	nested routine unless it is specifically marked as being so visible.
!
!	The list of candidate symbols is produced by DBG$STA_GETSYMBOL, and each
!	candidate is guaranteed to be in the current scope being searched.  What
!	this routine must do is to determine which candidates have valid data
!	qualification, which candidate is defined at the lowest definition depth
!	(i.e., defined inner-most in the current scope), and whether that candi-
!	date is unique.  The routine then returns one of three things: an indi-
!	cation that no symbol was valid, an indication that the symbol is not
!	unique, or an index pointing to the one selected candidate symbol.
!
! INPUTS
!	PATHNAME - Pointer to the pathname descriptor for the symbol name to
!		  be looked up in the symbol table.
!
!	NCANDS	- The number of candidate symbols found by DBG$STA_GETSYMBOL.
!
!	CANDLST	- A vector of pointers to the "candidate blocks" for the candi-
!		  date symbols found by DBG$STA_GETSYMBOL.  Each of these candi-
!		  dates is in the scope currently searched.  The candidate block
!		  pointers are found in CANDLST[1] through CANDLST[.NCANDS].
!
!	SCOPE	- A pointer to the RST entry for the current scope in which the
!		  symbol is being looked up.  This normally points to a Routine
!		  RST Entry or a Lexical Block RST Entry.  (COBOL Sections and
!		  Paragraphs are represented as lexical blocks in DEBUG.)  If
!		  the current scope is the Global Scope (\) or All Set Modules,
!		  the SCOPE parameter is zero.
!
! OUTPUTS
!	The CANDLST index for the candidate block which best matches the path-
!		  name is returned as the routine's value.  If no candidate is
!		  acceptable, zero is returned, and if more than one candidate
!		  is acceptable (the symbol is not unique), -1 is returned.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to symbol pathname descriptor
	CANDLST: REF VECTOR[,LONG],	! Pointer to candidate vector
	SCOPE: REF RST$ENTRY;		! Pointer to current scope RST entry

    LABEL
	CHECK_THIS_CANDIDATE;		! Label of block we want to LEAVE

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to current "candidate block"
	COBOLGBL_FLAG,			! Flag set to TRUE if the COBOL Global
					!      Attribute applies to this item
	DATA_INDEX,			! Index into CANDBLK vector of Data Item
					!      RST Entry pointer (or zero)
	DATAQUAL_FLAG,			! Set to TRUE when we are in the data
					!      qualification part of a name
	DEFDEPTH,			! Definition depth of current candidate
	DSTPTR: REF DST$RECORD,		! Pointer to symbol DST record
	GOOD_CAND,			! CANDLST index of best candidate so far
	GOOD_DEFDEPTH,			! Definition depth of GOOD_CAND symbol
	J,				! Index for CANDBLK vector
	RSTPTR: REF RST$ENTRY,		! Pointer to current symbol RST entry
	SCPTR: REF RST$ENTRY,		! Pointer used to follow current scope's
					!      up-scope chain
	SYMSCOPE: REF RST$ENTRY;	! The actual scope of the current symbol



    ! Initially we do not have a good candidate.
    !
    GOOD_CAND = 0;
    GOOD_DEFDEPTH = 1000000;


    ! Loop over all the candidate blocks on the candidate list.  This loop
    ! searches for the best candidate symbol matching the pathname.
    !
    INCR I FROM 1 TO .NCANDS DO
	BEGIN


	! Set up a labelled block to check out the current candidate.  We can
	! LEAVE this block if we find that the candidate is not acceptable.
	!
	CHECK_THIS_CANDIDATE:
	    BEGIN
	    CANDBLK = .CANDLST[.I];


	    ! Loop over the candidate's up-scope chain--that is what the CANDBLK
	    ! vector gives us.  Reject any candidate whose data qualification in
	    ! the up-scope chain does not agree with that in the pathname.
	    !
	    DATA_INDEX = 0;
	    COBOLGBL_FLAG = FALSE;
	    DATAQUAL_FLAG = TRUE;
	    J = 0;
	    WHILE .CANDBLK[.J, CAND_RSTPTR] NEQ 0 DO
		BEGIN
		RSTPTR = .CANDBLK[.J, CAND_RSTPTR];


		! Clear DATAQUAL_FLAG if we have left the data qualification
		! part of the name.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] LSS .PATHNAME[PTH$B_PATHCNT]) AND
		   (.CANDBLK[.J, CAND_PINDEX] NEQ 0)
		THEN
		    DATAQUAL_FLAG = FALSE;

		IF (.RSTPTR[RST$B_KIND] NEQ RST$K_DATA) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    DATAQUAL_FLAG = FALSE;


		! After we leave the data qualification part going up-scope, we
		! do not accept Data Items or Type Components in the name.
		!
		IF (NOT .DATAQUAL_FLAG)                AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! If this is the main Data Item RST Entry in the CANDBLK up-
		! scope chain, save its index in DATA_INDEX.  Also set the
		! COBOL Global Attribute flag if the RST entry is so marked.
		!
		IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA
		THEN
		    BEGIN
		    DATA_INDEX = .J;
		    IF .RSTPTR[RST$V_COBOLGBL] THEN COBOLGBL_FLAG = TRUE;
		    END;


		! Increment the CANDBLK index and loop up-scope.
		!
		J = .J + 1;
		END;


	    ! Pick up the definition depth from the last CANDBLK cell.  Reject
	    ! this candidate if we already have a candidate with a smaller def-
	    ! inition depth (i.e., defined closer to the current scope).
	    !
	    RSTPTR = .CANDBLK[.DATA_INDEX, CAND_RSTPTR];
	    DEFDEPTH = .CANDBLK[.J, CAND_PINDEX];
	    IF .DEFDEPTH GTR .GOOD_DEFDEPTH THEN LEAVE CHECK_THIS_CANDIDATE;


	    ! Unless the COBOL "global" flag is set for this symbol, we see if
	    ! the symbol is declared in a routine outside the current scope.
	    ! If it is, we must reject the symbol.  In COBOL, a symbol is not
	    ! visible in nested routines unless marked as "global".  Note that
	    ! we skip this check if SCOPE is zero, meaning that the scope is
	    ! the GST or all SET modules.  We also skip the check for symbols
	    ! which are not data--these rules do not apply to routines, etc.
	    !
	    IF (NOT .COBOLGBL_FLAG) AND
	       (.SCOPE NEQ 0)       AND
	       (.RSTPTR[RST$B_KIND] EQL RST$K_DATA)
	    THEN
		BEGIN


		! Determine the scope in which the current symbol is declared.
		!
		SYMSCOPE = .RSTPTR;
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE
		THEN
		    SYMSCOPE = .RSTPTR[RST$L_UPSCOPEPTR];

		IF .SYMSCOPE[RST$B_KIND] EQL RST$K_TYPE
		THEN
		    SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];


		! See if there is a routine declaration between the current
		! scope and the environment in which the symbol is declared.
		! If so, reject this candidate--it is not visible from the
		! current scope.
		!
		SCPTR = .SCOPE;
		WHILE .SCPTR NEQ .SYMSCOPE DO
		    BEGIN
		    IF .SCPTR[RST$B_KIND] EQL RST$K_ROUTINE
		    THEN
			LEAVE CHECK_THIS_CANDIDATE;

		    IF .SCPTR[RST$B_KIND] EQL RST$K_MODULE
		    THEN
			$DBG_ERROR('RSTACCESS\SCOPE_RULE_COBOL');

		    SCPTR = .SCPTR[RST$L_UPSCOPEPTR];
		    END;

		END;


	    ! We have a good candidate here.  If we already have another candi-
	    ! date at the same definition depth, the symbol maybe is not unique.
    	    ! We call a routine which attempts to resolve the amiguity. If it 
    	    ! resolves the ambiguity, then it returns the appropriate index.
    	    ! It returns -1 if the reference really is amiguous. 
	    !
	    IF .DEFDEPTH EQL .GOOD_DEFDEPTH
	    THEN
		BEGIN
    		IF .GOOD_CAND EQL -1
    		THEN
    		    LEAVE CHECK_THIS_CANDIDATE;
    		GOOD_CAND = CHECK_DUPLICATE(.CANDLST, .I, .GOOD_CAND);
		LEAVE CHECK_THIS_CANDIDATE;
		END;


	    ! We have a good candidate which is unique (so far) at this defini-
	    ! tion depth.  Set GOOD_CAND accordingly.
	    !
	    GOOD_CAND = .I;
	    GOOD_DEFDEPTH = .DEFDEPTH;

	    END;			! End of the CHECK_THIS_CANDIDATE block

	END;				! End of INCR loop over candidate list


    ! Return the GOOD_CAND value.  This may be -1, 0, or a true CANDLST index.
    !
    RETURN .GOOD_CAND;

    END;

ROUTINE SCOPE_RULE_NORMAL(PATHNAME, NCANDS, CANDLST, ARRAY_FLAG) =
!
! FUNCTION
!	This routine selects the symbol from a specified list of candidate sym-
!	bols which best matches a specified pathname.  This routine assumes
!	"normal" scope rules when doing so; in particular, it assumes that data
!	qualification must be complete (A.C is not accepted for A.B.C) or is not
!	present in the language.  These rules suit languages like Pascal and
!	Fortran.
!
!	The list of candidate symbols is produced by DBG$STA_GETSYMBOL, and each
!	candidate is guaranteed to be in the current scope being searched.  What
!	this routine must do is to determine which candidates have valid data
!	qualification, which candidate is defined at the lowest definition depth
!	(i.e., defined inner-most in the current scope), and whether that candi-
!	date is unique.  The routine then returns one of three things: an indi-
!	cation that no symbol was valid, an indication that the symbol is not
!	unique, or an index pointing to the one selected candidate symbol.
!
! INPUTS
!	PATHNAME - Pointer to the pathname descriptor for the symbol name to
!		  be looked up in the symbol table.
!
!	NCANDS	- The number of candidate symbols found by DBG$STA_GETSYMBOL.
!
!	CANDLST	- A vector of pointers to the "candidate blocks" for the candi-
!		  date symbols found by DBG$STA_GETSYMBOL.  Each of these candi-
!		  dates is in the scope currently searched.  The candidate block
!		  pointers are found in CANDLST[1] through CANDLST[.NCANDS].
!
!	ARRAY_FLAG - If true, the symbol we are looking up was seen in a
!		     subscripted expression. This may be used to resolve
!		     possible ambiguities in BASIC, where it is legal to
!		     have two variables of the same name, one a scalar
!		     and one an array.
!
! OUTPUTS
!	The CANDLST index for the candidate block which best matches the path-
!		  name is returned as the routine's value.  If no candidate is
!		  acceptable, zero is returned, and if more than one candidate
!		  is acceptable (the symbol is not unique), -1 is returned.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to symbol pathname descriptor
	CANDLST: REF VECTOR[,LONG];	! Pointer to candidate vector

    LABEL
	CHECK_THIS_CANDIDATE;		! Label of block we want to LEAVE

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to current "candidate block"
	DEFDEPTH,			! Definition depth of current candidate
	DSTPTR: REF DST$RECORD,		! Pointer to symbol DST record
	GOOD_CAND,			! CANDLST index of best candidate so far
	GOOD_DEFDEPTH,			! Definition depth of GOOD_CAND symbol
	J,				! Index for CANDBLK vector
	RSTPTR: REF RST$ENTRY;		! Pointer to current symbol RST entry



    ! Initially we do not have a good candidate.
    !
    GOOD_CAND = 0;
    GOOD_DEFDEPTH = 1000000;


    ! Loop over all the candidate blocks on the candidate list.  This loop
    ! searches for the best candidate symbol matching the pathname.
    !
    INCR I FROM 1 TO .NCANDS DO
	BEGIN


	! Set up a labelled block to check out the current candidate.  We can
	! LEAVE this block if we find that the candidate is not acceptable.
	!
	CHECK_THIS_CANDIDATE:
	    BEGIN
	    CANDBLK = .CANDLST[.I];


	    ! Loop over the candidate's up-scope chain--that is what the CANDBLK
	    ! vector gives us.  Reject any candidate whose data qualification in
	    ! the up-scope chain does not agree with that in the pathname.
	    !
	    J = 0;
	    WHILE .CANDBLK[.J, CAND_RSTPTR] NEQ 0 DO
		BEGIN
		RSTPTR = .CANDBLK[.J, CAND_RSTPTR];


		! No item before a backslash and no item not explicitly given
		! in the Pathname Descriptor may be a Data Item or Type Compo-
		! nent.  This ensures complete data qualification when present.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] LSS .PATHNAME[PTH$B_PATHCNT] OR
		    .CANDBLK[.J, CAND_PINDEX] EQL 0)                       AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! No item immediately before the first dot (i.e., X in A\X or
		! A\X.B) may be a Type Component and, if there are record com-
		! ponents, that item must be a Data item.  Again, this ensures
		! that data qualification is complete.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] EQL .PATHNAME[PTH$B_PATHCNT]) AND
		   ((.RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP) OR
		    (.PATHNAME[PTH$B_TOTCNT] GTR .PATHNAME[PTH$B_PATHCNT] AND
		     .RSTPTR[RST$B_KIND] NEQ RST$K_DATA))
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! If this item is part of the data qualification, it must be a
		! Type Component.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] GTR .PATHNAME[PTH$B_PATHCNT]) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! Increment the CANDBLK index and loop up-scope.
		!
		J = .J + 1;
		END;


	    ! Pick up the definition depth from the last CANDBLK cell.  Reject
	    ! this candidate if we already have a candidate with a smaller def-
	    ! inition depth (i.e., defined closer to the current scope).
	    !
	    DEFDEPTH = .CANDBLK[.J, CAND_PINDEX];
	    IF .DEFDEPTH GTR .GOOD_DEFDEPTH THEN LEAVE CHECK_THIS_CANDIDATE;


	    ! We have a good candidate here.  If we already have another candi-
	    ! date at the same definition depth, the symbol maybe is not unique.
    	    ! We call a routine which attempts to resolve the amiguity. If it 
    	    ! resolves the ambiguity, then it returns the appropriate index.
    	    ! It returns -1 if the reference really is ambiguous. 
	    !
	    IF .DEFDEPTH EQL .GOOD_DEFDEPTH
	    THEN
		BEGIN
    		IF .GOOD_CAND EQL -1
    		THEN
    		    LEAVE CHECK_THIS_CANDIDATE;
    		GOOD_CAND = CHECK_DUPLICATE(.CANDLST, .I, 
    					    .GOOD_CAND, .ARRAY_FLAG);
		LEAVE CHECK_THIS_CANDIDATE;
		END;


	    ! We have a good candidate which is unique (so far) at this defini-
	    ! tion depth.  Set GOOD_CAND accordingly.
	    !
	    GOOD_CAND = .I;
	    GOOD_DEFDEPTH = .DEFDEPTH;

	    END;			! End of the CHECK_THIS_CANDIDATE block

	END;				! End of INCR loop over candidate list


    ! Return the GOOD_CAND value.  This may be -1, 0, or a true CANDLST index.
    !
    RETURN .GOOD_CAND;

    END;

ROUTINE SCOPE_RULE_PLI(PATHNAME, NCANDS, CANDLST) =
!
! FUNCTION
!	This routine selects the symbol from a specified list of candidate sym-
!	bols which best matches a specified pathname.  This routine assumes
!	PL/I scope rules when doing so.  This means that incomplete data quali-
!	fication is accepted, and that uniqueness is determined by these rules:
!
!	    (1)	By definition, the "lowest definition depth" is the
!		inner-most definition depth in the current scope at
!		which at least one candidate symbol is declared.
!
!	    (2)	If only one candidate symbol is defined at the lowest
!		definition depth, then that is the unique symbol we
!		want.
!
!	    (3)	If more than one symbol is defined at the lowest defi-
!		nition depth, but only one of them has complete data
!		qualification, then that is the unique symbol we want.
!
!	    (4)	Otherwise, the symbol is not unique.
!
!	The list of candidate symbols is produced by DBG$STA_GETSYMBOL, and each
!	candidate is guaranteed to be in the current scope being searched.  What
!	this routine must do is to determine which candidates have valid data
!	qualification, which candidate is defined at the lowest definition depth
!	(i.e., defined inner-most in the current scope), and whether that candi-
!	date is unique.  The routine then returns one of three things: an indi-
!	cation that no symbol was valid, an indication that the symbol is not
!	unique, or an index pointing to the one selected candidate symbol.
!
! INPUTS
!	PATHNAME - Pointer to the pathname descriptor for the symbol name to
!		  be looked up in the symbol table.
!
!	NCANDS	- The number of candidate symbols found by DBG$STA_GETSYMBOL.
!
!	CANDLST	- A vector of pointers to the "candidate blocks" for the candi-
!		  date symbols found by DBG$STA_GETSYMBOL.  Each of these candi-
!		  dates is in the scope currently searched.  The candidate block
!		  pointers are found in CANDLST[1] through CANDLST[.NCANDS].
!
! OUTPUTS
!	The CANDLST index for the candidate block which best matches the path-
!		  name is returned as the routine's value.  If no candidate is
!		  acceptable, zero is returned, and if more than one candidate
!		  is acceptable (the symbol is not unique), -1 is returned.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to symbol pathname descriptor
	CANDLST: REF VECTOR[,LONG];	! Pointer to candidate vector

    LABEL
	CHECK_THIS_CANDIDATE;		! Label of block we want to LEAVE

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to current "candidate block"
	COMPLETE_FLAG,			! Set to TRUE if current candidate's
					!      data qualification is complete
	DATAQUAL_FLAG,			! Set to TRUE when we are in the data
					!      qualification part of a name
	DEFDEPTH,			! Definition depth of current candidate
	DSTPTR: REF DST$RECORD,		! Pointer to symbol DST record
	GOOD_CAND,			! CANDLST index of best candidate so far
	GOOD_COMPLETE_FLAG,		! Complete-data-qualification flag for
					!      the GOOD_CAND symbol
	GOOD_DEFDEPTH,			! Definition depth of GOOD_CAND symbol
	J,				! Index for CANDBLK vector
	RSTPTR: REF RST$ENTRY;		! Pointer to current symbol RST entry



    ! Initially we do not have a good candidate.
    !
    GOOD_CAND = 0;
    GOOD_DEFDEPTH = 1000000;
    GOOD_COMPLETE_FLAG = FALSE;


    ! Loop over all the candidate blocks on the candidate list.  This loop
    ! searches for the best candidate symbol matching the pathname.
    !
    INCR I FROM 1 TO .NCANDS DO
	BEGIN


	! Set up a labelled block to check out the current candidate.  We can
	! LEAVE this block if we find that the candidate is not acceptable.
	!
	CHECK_THIS_CANDIDATE:
	    BEGIN
	    CANDBLK = .CANDLST[.I];
	    COMPLETE_FLAG = TRUE;


	    ! Loop over the candidate's up-scope chain--that is what the CANDBLK
	    ! vector gives us.  Reject any candidate whose data qualification in
	    ! the up-scope chain does not agree with that in the pathname.
	    !
	    DATAQUAL_FLAG = TRUE;
	    J = 0;
	    WHILE .CANDBLK[.J, CAND_RSTPTR] NEQ 0 DO
		BEGIN
		RSTPTR = .CANDBLK[.J, CAND_RSTPTR];


		! Clear DATAQUAL_FLAG if we have left the data qualification
		! part of the name.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] LSS .PATHNAME[PTH$B_PATHCNT]) AND
		   (.CANDBLK[.J, CAND_PINDEX] NEQ 0)
		THEN
		    DATAQUAL_FLAG = FALSE;


		! After we leave the data qualification part going up-scope, we
		! do not accept Data Items or Type Components in the name.
		!
		IF (NOT .DATAQUAL_FLAG)                AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! The last thing before the dot when there are things after the
		! dot must be a Data Item or Type Component.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] EQL .PATHNAME[PTH$B_PATHCNT]) AND
		   (.PATHNAME[PTH$B_TOTCNT] GTR .PATHNAME[PTH$B_PATHCNT])   AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_DATA)                     AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! After the dot, everything must be Type Components.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] GTR .PATHNAME[PTH$B_PATHCNT]) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! If we are in the data qualification part and PINDEX is zero,
		! we have an RST entry on the up-scope chain whose name is not
		! given in the Pathname Descriptor.  This means that data quali-
		! fication is not complete for this variable.
		!
		IF .DATAQUAL_FLAG AND (.CANDBLK[.J, CAND_PINDEX] EQL 0)
		THEN
		    COMPLETE_FLAG = FALSE;


		! Increment the CANDBLK index and loop up-scope.
		!
		J = .J + 1;
		END;


	    ! Pick up the definition depth from the last CANDBLK cell.  Reject
	    ! this candidate if we already have a candidate with a smaller def-
	    ! inition depth (i.e., defined closer to the current scope).
	    !
	    DEFDEPTH = .CANDBLK[.J, CAND_PINDEX];
	    IF .DEFDEPTH GTR .GOOD_DEFDEPTH THEN LEAVE CHECK_THIS_CANDIDATE;


	    ! We have a good candidate here.  If we already have another candi-
	    ! date at the same definition depth, the symbol maybe is not unique.
	    ! If only one of the two candidates has complete data qualification,
	    ! we accept that one candidate as being the one we want (so far).
    	    ! Otherwise, we call a routine which attempts to resolve the amiguity. If it 
    	    ! resolves the ambiguity, then it returns the appropriate index.
    	    ! It returns -1 if the reference really is amiguous. 
	    !
	    IF (.DEFDEPTH EQL .GOOD_DEFDEPTH) AND
	       (.GOOD_COMPLETE_FLAG OR NOT .COMPLETE_FLAG)
	    THEN
		BEGIN
    		IF (.COMPLETE_FLAG OR NOT .GOOD_COMPLETE_FLAG)
    		THEN
    		    BEGIN
    		    IF .GOOD_CAND EQL -1
    		    THEN
    			LEAVE CHECK_THIS_CANDIDATE;
    		    GOOD_CAND = CHECK_DUPLICATE(.CANDLST, .I, .GOOD_CAND);
    		    IF .GOOD_CAND EQL .I
    		    THEN
    			GOOD_COMPLETE_FLAG = .COMPLETE_FLAG;
    		    END;
		LEAVE CHECK_THIS_CANDIDATE;
		END;


	    ! We have a good candidate which is unique (so far) at this defini-
	    ! tion depth.  Set GOOD_CAND accordingly.
	    !
	    GOOD_CAND = .I;
	    GOOD_DEFDEPTH = .DEFDEPTH;
	    GOOD_COMPLETE_FLAG = .COMPLETE_FLAG;

	    END;			! End of the CHECK_THIS_CANDIDATE block

	END;				! End of INCR loop over candidate list


    ! Return the GOOD_CAND value.  This may be -1, 0, or a true CANDLST index.
    !
    RETURN .GOOD_CAND;

    END;

ROUTINE SETCONTEXT_ERROR_HANDLER (SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the DBG$STA_SETCONTEXT  routine.
!	It handles Access Violations which occur during the following of stack
!	call frames.  Since such access violations are not normally caused by
!	errors in Debug but rather by errors in the user program (e.g., by
!	clobbered FP), we give a special message for this kind of access
!	violation.
!	The message says that there is a bad frame pointer or call frame in
!	the stack.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector (not used here).
!
! OUTPUTS
!	For the SS$_ACCVIO error, the DBG$_BADFRAME informational message is
!	signaled, and the stack is unwound to leave DBG$STA_SETCONTEXT.
!	For all other errors, this routine just resignals.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];	! Pointer to the signal argument vector


    ! If this is anything other than an access violation, just resignal it.
    !
    IF .SIGARG[1] NEQ SS$_ACCVIO THEN RETURN SS$_RESIGNAL;


    ! It is an access violation.  Signal the informational and unwind.
    !
    SIGNAL (DBG$_BADFRAME);
    SETUNWIND ();
    RETURN 0;

    END;

ROUTINE STACK_MACHINE(STK_CODE_PTR, RESULT_PTR, FRAMEPTR): NOVALUE =
!
! FUNCTION
!	This routine evaluates "Stack Machine" code from a Materialization Spec
!	in a DST Value Spec.  It accepts as input a pointer to the Stack Machine
!	"routine" (i.e., the "code") to be evaluated.  That "routine" is then
!	evaluated on a stack built in a temporary memory block.  Upon return,
!	the address of the computed value in the temporary memory block is
!	returned as the result of the evaluation.
!
! INPUTS
!	STK_CODE_PTR - The address of the first byte of "Stack Machine" code.
!		  Evaluation of this "code" starts at this address and con-
!		  tinues until the DST$K_STK_STOP command is reached.
!
!	RESULT_PTR - The address of a longword location to receive the result
!		  pointer.
!
!	FRAMEPTR - The address of a longword location to receive the frame
!		  pointer associated with the result location.
!
! OUTPUTS
!	RESULT_PTR - A pointer to the result of evaluating the stack machine
!		  routine is returned to RESULT_PTR.
!
!	FRAMEPTR - The Frame Pointer (FP) value of the register set used in
!		  the stack machine computations is returned to FRAMEPTR if
!		  any register was used in the computations.  If no register
!		  value was used, zero is returned to FRAMEPTR.
!
!	No value is returned by routine STACK_MACHINE.
!

    BEGIN

    MAP 
	RESULT_PTR: REF VECTOR[1],	! Pointer to result location
	FRAMEPTR: REF VECTOR[1];	! Pointer to frame pointer location

    LITERAL
	STACK_SIZE 	= 256;

    LOCAL 
	CALL_RESULT,			! Result of embedded routine call
	STACK_PTR,			! Pointer to the top of stack.
	OVERFLOW_POINT,			! Pointer to stack upper limit.
	UNDERFLOW_POINT,		! Pointer to stack lower limit.
	INSTRUC : REF VECTOR [,BYTE];	! Pointer to the current stack instruct

    MACRO 
	TOP_CELL = 	(.STACK_PTR) %,
	SECOND_CELL = 	(.STACK_PTR + 4) %,
	PUSH(I) = 	STACK_PTR = .STACK_PTR - (I)*%UPVAL;
			IF .STACK_PTR LSSA .OVERFLOW_POINT 
			THEN
			    $DBG_ERROR('RSTACCESS\STACK_MACHINE 10') %,

	POP(I) = 	STACK_PTR = .STACK_PTR + (I)*%UPVAL;
			IF .STACK_PTR GTRA .UNDERFLOW_POINT
			THEN
			    $DBG_ERROR('RSTACCESS\STACK_MACHINE 20') %,

	PUSH_BYTE(I) = 	STACK_PTR = 
				.STACK_PTR -
					((I) + (IF (I) MOD %UPVAL NEQ 0 
					      THEN %UPVAL - ((I) MOD %UPVAL)
					      ELSE 0));
			IF .STACK_PTR LSSA .OVERFLOW_POINT 
			THEN
			    $DBG_ERROR('RSTACCESS\STACK_MACHINE 30') %,

	CHECK_CELLS(I) =IF .UNDERFLOW_POINT - .STACK_PTR LSS (I)*%UPVAL
			THEN
			    $DBG_ERROR('RSTACCESS\STACK_MACHINE 40') %;



    ! Initialize the stack and the pointer to the instruction stream.
    !
    OVERFLOW_POINT = DBG$GET_TEMPMEM(STACK_SIZE);
    UNDERFLOW_POINT = .OVERFLOW_POINT + 4*STACK_SIZE;
    STACK_PTR = .UNDERFLOW_POINT;
    INSTRUC = .STK_CODE_PTR;


    ! Initialize FRAMEPTR to zero--this will be changed if registers are used.
    !
    FRAMEPTR[0] = 0;


    ! Evaluate the Stack Machine "routine" by looping through its instructions
    ! until we reach the Stop command.
    !
    WHILE .INSTRUC[0] NEQ DST$K_STK_STOP DO
	BEGIN


	! Do a CASE on the current Stack Machine Op Code and execute each
	! op code as appropriate.
	!
	CASE .INSTRUC[0] FROM DST$K_STK_LOW TO DST$K_STK_HIGH OF
	    SET


	    ! Push the value of a register on the stack.
	    !
	    [DST$K_STK_PUSHR0,
	     DST$K_STK_PUSHR1,
	     DST$K_STK_PUSHR2,
	     DST$K_STK_PUSHR3,
	     DST$K_STK_PUSHR4,
	     DST$K_STK_PUSHR5,
	     DST$K_STK_PUSHR6,
	     DST$K_STK_PUSHR7,
	     DST$K_STK_PUSHR8,
	     DST$K_STK_PUSHR9,
	     DST$K_STK_PUSHR10,
	     DST$K_STK_PUSHR11,
	     DST$K_STK_PUSHRAP,
	     DST$K_STK_PUSHRFP,
	     DST$K_STK_PUSHRSP,
	     DST$K_STK_PUSHRPC]:	
		BEGIN
		LOCAL REGISTR;
		PUSH(1);
		REGISTR = 
			   (CASE .INSTRUC[0] 
				FROM DST$K_STK_PUSHR0 TO DST$K_STK_PUSHRPC OF
				SET
				[DST$K_STK_PUSHR0]: 0;
				[DST$K_STK_PUSHR1]: 1;
				[DST$K_STK_PUSHR2]: 2;
				[DST$K_STK_PUSHR3]: 3;
				[DST$K_STK_PUSHR4]: 4;
		 		[DST$K_STK_PUSHR5]: 5;
				[DST$K_STK_PUSHR6]: 6;
				[DST$K_STK_PUSHR7]: 7;
				[DST$K_STK_PUSHR8]: 8;
		 		[DST$K_STK_PUSHR9]: 9;
				[DST$K_STK_PUSHR10]: 10;
				[DST$K_STK_PUSHR11]: 11;
 				[DST$K_STK_PUSHRAP]: 12;
				[DST$K_STK_PUSHRFP]: 13;
				[DST$K_STK_PUSHRSP]: 14;
				[DST$K_STK_PUSHRPC]: 15;
				TES
			   );

		IF .DBG$REG_VECTOR[.REGISTR] NEQ 0
		THEN
		    BEGIN
		    TOP_CELL = .DBG$REG_VALUES[.REGISTR];
	 	    INSTRUC = .INSTRUC + 1;
		    END

		ELSE
		    VALSPEC_SCOPE_ERROR();

		FRAMEPTR[0] = .DBG$REG_VALUES[13];
		END;


	    ! PUSH IMMEDIATE 		1, 2, or 4 bytes following this opcode 
	    ! BYTE WORD OR LONG		are sign extended to 32 bits and PUSHed 
	    ! 				on the stack
	    !
	    [DST$K_STK_PUSHIMB]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,BYTE,SIGNED];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 2;
		END;

	    [DST$K_STK_PUSHIMW]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD, SIGNED];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 3;
		END;

	    [DST$K_STK_PUSHIML]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,LONG];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 5;
		END;


	    ! PUSH IMMEDIATE VARIABLE	The byte following the opcode is 
	    ! 				interpreted as an unsigned byte count.
	    ! 				A block of data, immediately following 
	    ! 				the count byte, is PUSHed on the stack. 
	    !
	    [DST$K_STK_PUSHIM_VAR]:	
		BEGIN
		PUSH_BYTE(.INSTRUC[1]);
		CH$MOVE( .INSTRUC[1], INSTRUC[2], TOP_CELL );
		INSTRUC = INSTRUC[2] + .INSTRUC[1];
		END;


	    ! PUSH IMMEDIATE UNSIGNED	1 or 2 bytes following this opcode 
	    ! BYTE OR WORD 		are zero extended to 32 bits and PUSHed 
	    ! 				on the stack
	    ! 
	    [DST$K_STK_PUSHIMBU]:	
		BEGIN
		PUSH(1);
		TOP_CELL = .INSTRUC[1];
		INSTRUC = .INSTRUC + 2;
		END;

	    [DST$K_STK_PUSHIMWU]:
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 3;
		END;


	    ! PUSH INDIRECT	The top stack cell is popped and 1, 2, or 4
	    ! BYTE WORD OR LONG bytes at the address given by the popped
	    !			stack cell are sign extended to 32 bits and
	    !			pushed on the stack.
	    ! 
	    [DST$K_STK_PUSHINB]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,BYTE, SIGNED];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;

	    [DST$K_STK_PUSHINW]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD,SIGNED];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;

	    [DST$K_STK_PUSHINL]:	
		BEGIN
		LOCAL OPERAND: REF VECTOR[,LONG];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! PUSH INDIRECT UNSIGNED	The top stack cell is popped and 1 or 2
	    ! BYTE OR WORD		bytes at the address given by the popped
	    !				stack cell are zero extended to 32 bits
	    !				and pushed on the stack.
	    ! 
	    [DST$K_STK_PUSHINBU]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,BYTE];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;

	    [DST$K_STK_PUSHINWU]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! ADD			The top two stack cells are added and 
	    ! 				replaced by a single cell containing 
	    ! 				their sum
	    ! 
	    [DST$K_STK_ADD]:	
		BEGIN
		CHECK_CELLS(2);	
		SECOND_CELL = .TOP_CELL + .SECOND_CELL;
		POP(1);
		INSTRUC = .INSTRUC + 1;
  		END;


	    ! SUBTRACT		The second stack cell is subtracted from 
	    ! 			the first stack cell. Both are popped. 
	    ! 			Their difference is PUSHed.
	    ! 
	    [DST$K_STK_SUB]:		
		BEGIN
		CHECK_CELLS(2);
		SECOND_CELL = .TOP_CELL - .SECOND_CELL;
		POP(1);
		INSTRUC = .INSTRUC + 1;
		END;


	    ! MULTIPLY		The top two stack cells are multiplied 
	    ! 			and replaced by a single cell containing 
	    ! 			their product
	    !
	    [DST$K_STK_MULT]:	
		BEGIN
		CHECK_CELLS(2);
		SECOND_CELL = (.TOP_CELL)*(.SECOND_CELL);
		POP(1);
		INSTRUC = .INSTRUC + 1;
		END;


	    ! DIVIDE			The top stack cell is divided by the 
	    ! 				secondstack cell. Both are popped. 
	    ! 				Their qoutient is PUSHed.
	    ! 
	    [DST$K_STK_DIV]:		
		BEGIN
		CHECK_CELLS(2);
		IF .(SECOND_CELL) EQL 0 
		THEN
		    $DBG_ERROR('RSTACCESS\STACK_MACHINE 50')

		ELSE 
		    BEGIN
	    	    SECOND_CELL = (.TOP_CELL)/(.SECOND_CELL);
		    POP(1);
	    	    INSTRUC = .INSTRUC + 1;
		    END
		END;


	    ! LOGICAL SHIFT	The top stack cell is interpreted as 
	    ! 			the number of bit positions to shift the 
	    ! 			second stack cell. Both are popped. 
	    ! 			The shifted second cell is PUSHed.
	    ! 
	    [DST$K_STK_LSH]:	
		BEGIN
		CHECK_CELLS(2);
		IF ABS( .TOP_CELL ) GEQ %BPVAL
		THEN 
		    BEGIN
		    POP(1);
		    TOP_CELL = 0;
		    INSTRUC = .INSTRUC + 1;
		    END
		ELSE 
		    BEGIN
		    IF .TOP_CELL GTR 0 
		    THEN 

			! Number of bit positions is positive, shift to the left.
			!
			BEGIN
			SECOND_CELL = (.SECOND_CELL)^(.TOP_CELL);
			POP(1);
	    		INSTRUC = .INSTRUC + 1;
			END
	 	    ELSE

			! Number of bit positions is negative, shift to the right.
			! This is a logical, rather than an arithmetic shift, so
			! we'll have to do some magic, rather than use the BLISS
			! shift operator.
			!
			BEGIN
			LOCAL POSITION, SIZ;
			POSITION = -.TOP_CELL;
			SIZ = %BPVAL - .POSITION;
			SECOND_CELL = .(SECOND_CELL)<.POSITION, .SIZ>;
			POP(1);
	    		INSTRUC = .INSTRUC + 1;
			END;
		    END
		END;


	    ! ROTATE		The top stack cell is interpreted as the
	    ! 			number of bit positions to rotate the 
	    ! 			second stack cell. Both are popped. 
	    ! 			The rotated second cell is PUSHed.
	    ! 
	    [DST$K_STK_ROT]:		
		BEGIN
		LOCAL BITS_TO_ROT;
		CHECK_CELLS(2);
		BITS_TO_ROT = .TOP_CELL MOD %BPVAL;
		IF .BITS_TO_ROT GTR 0 
		THEN 

		    ! Number of bit positions is positive, rotate to the left. 
		    !
		    BEGIN
		    LOCAL OPERAND, TARG_POS, SRC_POS, SIZ;
		    OPERAND = .(SECOND_CELL);

		    ! Move the low order bits of the source to the high order
		    ! bits of the target and the high order bits of the source to
		    ! the low order bits of the target.
		    !
		    !		 31                    0
		    !		+-----------------------+
		    !   source      |	     |		|
		    !		+-----------------------+
		    !		|.BITS_TO_ROT|     |
		    !			|	   |
		    !		      -------------
		    !		     |  |
		    !		     |   ----------
		    !		     |		   |
		    !		    \ /		  \ /
		    !		+-----------------------+
		    !   target      |	     |		|
		    !		+-----------------------+
				
		    TARG_POS = .BITS_TO_ROT;
		    SRC_POS  = 0;
		    SIZ = %BPVAL - TARG_POS;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;

		    ! Move the high order bits of the source to the low order
		    ! bits of the target.
		    !
		    TARG_POS = 0;
		    SRC_POS  = %BPVAL - .BITS_TO_ROT;
		    SIZ = .BITS_TO_ROT;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;
		    
		    ! Adjust the stack pointer,
		    !
		    POP(1);
	    	    INSTRUC = .INSTRUC + 1;
		    END

		 ELSE

		    ! Number of bit positions is negative, rotate to the right.
		    !
		    BEGIN
		    LOCAL OPERAND, TARG_POS, SRC_POS, SIZ;
		    OPERAND = .SECOND_CELL;

		    ! Move the high order bits of the source to the low order
		    ! bits of the target and the low order bits of the source to
		    ! the high order bits of the target.
		    !
		    !		 31                    0
		    !		+-----------------------+
		    !   source      |	  |   		|
		    !		+-----------------------+
		    !		       |  |-.BITS_TO_ROT|
		    !		       |	   |
		    !		      -------------
		    !		     | |
		    !		     |  -----------
		    !		     |		   |
		    !		    \ /		  \ /
		    !		+-----------------------+
		    !   target      |	     |		|
		    !		+-----------------------+
		    !
		    TARG_POS = %BPVAL - .BITS_TO_ROT;
		    SRC_POS  = 0;
		    SIZ 	 = .BITS_TO_ROT;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;


		    ! Move the high order bits of the source to the low order
		    ! bits of the target.
		    !
		    TARG_POS = 0;
		    SRC_POS  = .BITS_TO_ROT;
		    SIZ 	 = %BPVAL - .BITS_TO_ROT;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;
		    

		    ! Adjust the stack pointer,
		    !
		    POP(1);
	    	    INSTRUC = .INSTRUC + 1;
		    END;

		END;


	    ! COPY 			The top stack cell is PUSHed 
	    !
	    [DST$K_STK_COP]:	
		BEGIN
		PUSH(1);
		TOP_CELL = .SECOND_CELL;
		INSTRUC = .INSTRUC + 1;
		END;


	    ! EXCHANGE			The top two stack cells are exchanged
	    ! 
	    [DST$K_STK_EXCH]:
		BEGIN
		LOCAL WORK_CELL;
		WORK_CELL = .TOP_CELL;
		TOP_CELL = .SECOND_CELL;
		SECOND_CELL = .WORK_CELL;
		INSTRUC = .INSTRUC + 1;
		END;


	    ! STORE BYTE WORD OR LONG	
	    !			The byte following this operand is 
	    ! 			interpreted as a signed (for consistency
	    ! 			with something, see Grove) byte offset 
	    ! 			into the stack. The low order byte, word, 
	    ! 			or longword of the top stack cell is 
	    ! 			copied into the byte, word or longword 
	    ! 			at this location:
	    !
	    !	 			address of the second stack cell 
	    ! 					+
	    ! 				the specified byte offset.
	    !
	    ! 			(Keep in mind that the address of the 
	    ! 			third stack cell is the address of the
	    ! 			second stack cell plus four.)
	    ! 			The stack is popped.
	    !
	    [DST$K_STK_STO_B,
	     DST$K_STK_STO_W,	
	     DST$K_STK_STO_L]:
		BEGIN
		LOCAL TARGET, SIZ;
		TARGET = SECOND_CELL + .INSTRUC[1];
		SIZ = 
		    (CASE .INSTRUC[0] FROM DST$K_STK_STO_B TO DST$K_STK_STO_L OF
			SET
			[DST$K_STK_STO_B]: 1;
			[DST$K_STK_STO_W]: 2;
			[DST$K_STK_STO_L]: 4;
				TES);
		CH$MOVE(.SIZ, TOP_CELL, .TARGET);
		POP(1);
		INSTRUC = .INSTRUC + 2;
		END;


	    ! POP			The top stack cell is removed from the 
	    ! 				stack.
	    !
	    [DST$K_STK_POP]:	
		BEGIN
		POP(1);
		INSTRUC = .INSTRUC + 1;
		END;


	    ! RTNCALL			Call a compiler-supplied routine to
	    !				compute a value to be put on the stack.
	    !				We assume that the routine address is
	    !				already on top of the stack.  That ad-
	    !				dress is popped and the returned value
	    !				is pushed on the stack.
	    !
	    [DST$K_STK_RTNCALL]:
		BEGIN
		LOCAL
		    Temp_thunk_addr;
		Temp_thunk_addr = .TOP_CELL;					! Save the routine address, it will be popped
		CALL_RESULT = 0;
		POP(1);								! Pop off the thunk address
		VALSPEC_ROUT_CALL(CALL_RESULT, .Temp_thunk_addr, FALSE, TRUE,
    			         .STACK_PTR, .UNDERFLOW_POINT-.STACK_PTR);
		PUSH(1);							! Push for the call result
		TOP_CELL = .CALL_RESULT;
		FRAMEPTR[0] = .DBG$REG_VALUES[13];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! RTN_NOFP			Call a compiler-supplied routine to
	    !				compute a value to be put on the stack.
	    !				is pushed on the stack. Same as RTNCALL
	    !				except no FP is passed in to thunk.
	    !
	    [DST$K_STK_RTN_NOFP]:
		BEGIN
		LOCAL
		    Temp_thunk_addr;
		Temp_thunk_addr = .TOP_CELL;					! Save the routine address, it will be popped
		CALL_RESULT = 0;
		POP(1);								! Pop off the thunk address
		VALSPEC_ROUT_CALL(CALL_RESULT, .Temp_thunk_addr, FALSE, FALSE,
				 .STACK_PTR, .UNDERFLOW_POINT-.STACK_PTR);
		PUSH(1);							! Push for the call result
		TOP_CELL = .CALL_RESULT;
		FRAMEPTR[0] = .DBG$REG_VALUES[13];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! RTNCALL_ALT		Call a compiler-supplied routine to
	    !				compute a value to be put on the stack.
	    !				We assume that the routine address is
	    !				already on top of the stack.  That ad-
	    !				dress is popped and the returned value
	    !				(a quadword) is pushed on the stack.
	    !
	    [DST$K_STK_RTNCALL_ALT]:
		BEGIN
		LOCAL
		    Temp_thunk_addr,
		    CALL_RESULT : VECTOR[ 4 ];
		Temp_thunk_addr = .TOP_CELL;					! Save the routine address, it will be popped
		CALL_RESULT[0] = 0;
		CALL_RESULT[1] = 0;
		CALL_RESULT[2] = 0;
		CALL_RESULT[3] = 0;
		POP(1);								! Pop off the thunk address
		VALSPEC_ROUT_CALL(CALL_RESULT, .Temp_thunk_addr, TRUE, TRUE,
    				 .STACK_PTR, .UNDERFLOW_POINT-.STACK_PTR);
		PUSH( 4 );
		CH$MOVE( 16, CH$PTR( CALL_RESULT ), CH$PTR( .STACK_PTR ) );
		FRAMEPTR[0] = .DBG$REG_VALUES[13];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! PUSH_OUTER_REC		Push the start address of the outer most
	    !				record, described by the primary pointed
	    !				to by DBG$GL_CURRENT_PRIMARY.  Originally
	    !				implemented for use by languages which allow
	    !				Self-referential records, (PL/I, ADA)
	    !				
	    !				Self-referential records are those which
	    !				contain fields or structures whose actual
	    !				allocated length depends on some preceding
	    !				value within the record.  Thus, the address
	    !				of any fields following the field or structure
	    !				is not known at compile time, and therefore must
	    !				be calculated at run-time.
	    !
	    [DST$K_STK_PUSH_OUTER_REC]:
	    	BEGIN
		PUSH(1);
		TOP_CELL = DBG$GET_OUTER_REC_ADDRESS(.DBG$GL_CURRENT_PRIMARY);
		INSTRUC = .INSTRUC + 1;	
		END;


	    ! PUSH_INNER_REC		Push the start address of the inner most
	    !				record, described by the primary pointed
	    !				to by DBG$GL_CURRENT_PRIMARY.  Originally
	    !				implemented for use by languages which allow
	    !				Self-referential records, (PL/I, ADA)
	    !				
	    [DST$K_STK_PUSH_INNER_REC]:
	    	BEGIN
		PUSH(1);
		TOP_CELL = DBG$GET_INNER_REC_ADDRESS(.DBG$GL_CURRENT_PRIMARY);
		INSTRUC = .INSTRUC + 1;	
		END;


	    ! Any other op-code is an error.  Signal an internal bug.
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('RSTACCESS\STACK_MACHINE - Invalid stack machine opcode. Bad DST');

	    TES;

	END;				! End of WHILE loop over instructions


    ! Fill in the result address and return.
    !
    RESULT_PTR[0] = TOP_CELL;
    RETURN;

    END;

ROUTINE VALSPEC_ERROR_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the DBG$STA_VALSPEC routine.  It
!	handles Access Violations which occur during the evaluation of DST Value
!	Specs.  Since such access violations are not normally caused by errors
!	in Debug but rather by errors in the user program (e.g., by clobbered
!	registers), we give a special message for this kind of access violation.
!	The message says that the error occurred in the address computation for
!	some symbol and gives the symbol name.  The symbol name comes from the
!	SYMID last passed to DBG$STA_SETCONTEXT.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector (not used here).
!
! OUTPUTS
!	For the SS$_ACCVIO error, the DBG$_ACCADDCOM error is signalled instead.
!	For all other errors, this routine just resignals.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];	! Pointer to the signal argument vector

    LOCAL
	PATHDESCR,			! Pointer to pathname descriptor
	PATHSTRING;			! Pointer to pathname string for symbol



    ! If this is anything other than an access violation, just resignal it.
    !
    IF .SIGARG[1] NEQ SS$_ACCVIO THEN RETURN SS$_RESIGNAL;


    ! It is an access violation.  Determine the name of the last symbol passed
    ! to DBG$STA_SETCONTEXT to set up the register context and use that in the
    ! error message we substitute.
    !
    IF .DBG$REG_SYMID EQL 0
    THEN
	PATHSTRING = UPLIT BYTE(%ASCIC 'object')

    ELSE
	BEGIN
	DBG$STA_SYMPATHNAME(.DBG$REG_SYMID, PATHDESCR);
	DBG$NPATHDESC_TO_CS(.PATHDESCR, PATHSTRING);
	END;


    ! Signal the substitute error.  We never get control back from the signal.
    !
    SIGNAL(DBG$_ACCADDCOM, 1, .PATHSTRING);
    RETURN 0;

    END;

ROUTINE VALSPEC_SCOPE_ERROR: NOVALUE =
!
! FUNCTION
!	This routine is called during DST Value Spec evaluation if a register
!	is referenced which is not available in the current context as set by
!	routine DBG$STA_SETCONTEXT.  Use of such a register usually means that
!	a variable is being referenced whose scope is not currently active, i.e.
!	there is no CALL frame on the VAX stack for the routine in which the
!	symbol is declared.  This routine just sets up and signals the "Symbol
!	not in active scope" error message.
!
! INPUTS
!	DBG$REG_SYMID is an implicit input.  It gives the SYMID of the symbol
!	last used to establish context.  There are no input parameters.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	PATHNAME,			! Pointer to symbol's pathname descriptor
	PATHSTRING;			! Pointer to symbol's pathname string



    ! Use the SYMID passed to DBG$STA_SETCONTEXT last to format the symbol name
    ! for the error message.  If no such name exists, use the null string.
    !
    IF .DBG$REG_SYMID EQL 0
    THEN
	PATHSTRING = UPLIT(0)

    ELSE
	BEGIN
	DBG$STA_SYMPATHNAME(.DBG$REG_SYMID, PATHNAME);
	DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
	END;


    ! Signal the error--we do not return from the signal.
    !
    SIGNAL(DBG$_SYMNOTACT, 1, .PATHSTRING);

    END;

ROUTINE VALSPEC_ROUT_CALL(	VALBUFFER, 
				ROUT_ADDR,
				OCTAWORD_FLAG, 
				FP_FLAG,
				STACK_TOP, 
    				STACK_LENGTH) : NOVALUE =
!
! FUNCTION
!	This routine is called to handle calls on compiler-supplied routines
!	in the user's address-space during Value Spec evaluation.  Calls to
!	compiler-supplied Value Spec routines can be specified in Materializa-
!	tion Specs in Value Specs, both directly and via the DST Stack Machine.
!	The compiler-supplied routine is called as follows:
!
!		- The desired symbol's Frame Pointer value is passed to
!		  the routine in register R1.
!
!		- If OCTAWORD_FLAG is FALSE, a pointer to the vector of
!		  register values for the symbol's frame (as represented
!		  by DBG$REG_VALUES) is passed as a parameter in the argu-
!		  ment vector, and the routine returns the symbol's value
!		  in register R0.
!
!		- If OCTAWORD_FLAG is TRUE, a pointer to a 4-longword result
!		  buffer and a pointer to the vector of register values in
!		  the symbol's frame are passed as parameters in the argument
!		  vector.  The routine's result is returned directly to the
!		  result buffer in this case, and not through register R0.
!
!		- When STACK_TOP and STACK_LENGTH are passed they are passed
!		  as the 2nd and 3rd parameters if the OCTAWORD_FLAG is false
!		  and the 3rd and 4th parameters if the OCTAWORD_FLAG is true.
!
!	If the Frame Pointer (FP) is not available in the current context (as
!	set up by DBG$STA_SETCONTEXT), the "symbol not in active scope" error
!	is signalled.  Otherwise the compiler-supplied routine is called as
!	described above and its value returned.  The routine that called
!	VALSPEC_ROUT_CALL can then use the value as it sees fit.
!
! INPUTS
!	VALBUFFER - The address of a 1-longword or 4-longword buffer which is
!		  to receive the value returned by the called routine.  The
!		  size of the buffer depends on the value of OCTAWORD_FLAG.
!		  The buffer should be zeroed out by the caller.
!
!	ROUT_ADDR - The address of the routine to be called to get the value.
!
!	OCTAWORD_FLAG - A flag value set to TRUE if the called routine is
!		  expected to return a 4-longword value to VALBUFFER.  If
!		  this flag is FALSE, a single longword is expected to be
!		  returned to VALBUFFER.  If OCTAWORD_FLAG is TRUE, the called
!		  routine is expected to return its value to the address given
!		  by the first parameter;  otherwise, the value is returned in
!		  register R0.
!
!	FP_FLAG	  - If TRUE, indicates that FP is to be passed in to thunk.
!
!	STACK_TOP - Optional parameter.  Pointer to the top of the stack
!		  in the stack machine. Passed by value.
!
!	STACK_LENGTH - Optional parameter. The number of bytes on the stack
!		  in the stack machine. Passed by value.
!
! OUTPUTS
!	VALBUFFER - The value returned by the called compiler-supplied
!		  routine is returned to the buffer pointed to by
!		  VALBUFFER.
!
!	No routine value is returned.
!

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;

    MAP
	VALBUFFER: REF VECTOR[,LONG];	! Pointer to buffer to receive value

    ENABLE
    	VALSPEC_ROUT_CALL_HANDLER;	! Set up a handler for this routine


    ! Define the linkage by which we call the compiler-supplied routine.
    !
    LINKAGE
	ROUT_CALL_LINKAGE = CALL(REGISTER = 1, STANDARD);

    BIND ROUTINE
	ROUTINE_TO_CALL = (.ROUT_ADDR): ROUT_CALL_LINKAGE;

    !++
    ! 4 parameters not allowed
    !--
    IF ACTUALCOUNT() EQL 5
    THEN
	$DBG_ERROR('RSTACCESS\VALSPEC_ROUT_CALL');


    ! Make sure there is a current register set to take FP from.
    !
    IF .FP_FLAG
    THEN
        IF .DBG$REG_VECTOR[13] EQL 0 THEN VALSPEC_SCOPE_ERROR();


    ! Call the compiler-provided routine to compute the desired value.  If the
    ! octaword flag is set, we pass the buffer to receive the value (up to four
    ! longwords) as the first parameter.  Otherwise we get the value from R0.
    ! The frame pointer value is always passed in in register R1.
    !
    IF ACTUALCOUNT() EQL 4
    THEN
	IF .OCTAWORD_FLAG 
	THEN
	    ROUTINE_TO_CALL(.DBG$REG_VALUES[13], .VALBUFFER, DBG$REG_VALUES[0])
	ELSE
	    VALBUFFER[0] = ROUTINE_TO_CALL(.DBG$REG_VALUES[13], DBG$REG_VALUES[0])
    ELSE
	IF .OCTAWORD_FLAG 
	THEN
	    ROUTINE_TO_CALL(.DBG$REG_VALUES[13], .VALBUFFER, DBG$REG_VALUES[0], .STACK_TOP, .STACK_LENGTH)
	ELSE
	    VALBUFFER[0] = ROUTINE_TO_CALL(.DBG$REG_VALUES[13], DBG$REG_VALUES[0], .STACK_TOP, .STACK_LENGTH);
	
    RETURN;

    END;

ROUTINE VALSPEC_ROUT_CALL_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the VALSPEC_ROUT_CALL routine.  It
!	handles abnormal conditions which occur during the evaluation of 
!	PLI Base Variable, ie. Pointer to the base variable has not been set
!       up by the ALLOCATE in PLI before the program execution.  However we
!	do allow symbol is not active signal to go through this routine.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector (not used here).
!
! OUTPUTS
!	For the DBG$_SYMNOTACT error, this routine just resignal.
!	For all other errors, this routine signals DBG$_BASVARNOTSET.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];	! Pointer to the signal argument vector


    IF .SIGARG[1] EQL DBG$_SYMNOTACT OR
       .SIGARG[1] EQL SS$_UNWIND
    THEN 
    	RETURN SS$_RESIGNAL;

    SIGNAL(DBG$_BASVARNOTSET);
    RETURN 0;

    END;


END ELUDOM
