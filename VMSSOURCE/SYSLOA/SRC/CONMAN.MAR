	.TITLE	CONMAN - Cluster Configuration Manager
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: EXECUTIVE, CLUSTER MANAGEMENT
;
; ABSTRACT: 
;	This module creates and manages the cluster configuration.  It is
;	responsible for forming a cluster, adding nodes to a cluster, and
;	reconfiguring a cluster following a failure.
;
; ENVIRONMENT: VAX/VMS
;
; AUTHOR: David W. Thiel,	 CREATION DATE: 4-Apr-1983
;
; MODIFIED BY:
;
;	V03-022	DWT0225		David W. Thiel		11-Jul-1984
;		Change call to temporary name EXE$MNTVERSP2 to
;		real name EXE$CLUTRANIO.
;
;	V03-021	DWT0219		David W. Thiel		08-May-1984
;		Add synchronization between I/O and lock manager
;		clusters.
;
;	V03-020	DWT0213		David W. Thiel		17-Apr-1984
;		Always fork at least once when locking nodes to
;		begin a state transition.  Correct logic for
;		locking nodes when memory allocation fails.
;
;	V03-019	DWT0206		David W. Thiel		08-Apr-1984
;		Correct branch in CNX$RCVD_RECONFIG.
;		Tighten up timing on cluster formation to avoid
;		forming a paritioned cluster.  Add CNX$POWER_FAIL
;		entry point to receive control on power recovery.
;		Use CLUBFKB$V_FKB_BUSY instead of CLUB$V_FKB_BUSY.
;		Fix method of comparing quorum disk names from
;		various nodes.
;
;	V03-018	DWT0201		David W. Thiel		24-Mar-1984
;		Remove temporary code defining new symbols in the CLUB.
;
;	V03-017	DWT0194		David W. Thiel		23-Mar-1984
;		Change interface to disk quorum module to eliminate
;		window of ambiguity.  Rename CLUB$V_QF_SKIP_READ to
;		CLUB$V_QF_FAILED_NODE.  Update CSB$Q_REFTIME when a node
;		is added to or removed from the cluster.  Make sending
;		phase 1 messages a subroutine.  Make addition/deletion
;		of quorum disk from cluster a full two-phase transition.
;		Support requests for quorum change.  Remove propagation
;		of some bits to all nodes of cluster.
;
;	V03-016	DWT0187		David W. Thiel		5-Mar-1984
;		Correct and improve random number time-outs.
;
;	V03-015	DWT0181		David W. Thiel		27-Feb-1984
;		Correct MULL3 to be MULL2.
;
;	V03-014	DWT0173		David W. Thiel		27-Feb-1984
;		Start own reconfiguration attempts after some other
;		node tries and fails.  Raise interval to 0...20 seconds
;		when requesting cluster membership.  Correct use of
;		CLUB$W_QDVOTES to always minimize value and to propagate
;		when forming or adding nodes.  Add dummy entry
;		CNX$SHUTDOWN, update dummy CNX$CHANGE_QUORUM.
;
;	V03-013	DWT0161		David W. Thiel		03-Feb-1984
;		Modify use of CSB$B_NODEMAP to represent current
;		best estimate of global connection status.  Bit 0
;		is used for the quorum disk "connection".  This field
;		is maintained for use by the optimal sub-cluster
;		calculation.  Do optimal calculation on cluster
;		reconfigurations and cluster formation.  Always
;		copy CLUB$V_ACTIVE bit to CSB$V_ACTIVE bit in
;		CNX$DISK_CHANGE.  Correct blown register.
;
;	V03-012	DWT0147		David W. Thiel		19-Dec-1983
;		Add support for lock manager directory system vector.
;		Remove old lock manager directory system logic.
;		Add CLUB$W_MEMSEQ (cluster membership state sequence
;		number) and support for maintaining same.  Add use of
;		CLMPRO$L_FMERIT field and its propagation with phase
;		1 messages.  Use common routine CNX$QUORUM_CALC for
;		all quorum calculations.  Add support for a variable
;		number of votes for the quorum disk.  Remove filling
;		in several unused fields in the CLMSTS message.
;		Invoke fail-in table on all cluster membership
;		transitions.  Change name of CNX$BEGIN_FAILIN and
;		CNX$BEGIN_FAILOVER to CNX$MEMBERSHIP_CHANGE.
;		Use routines in new CONSUBS module.  Update TOPOLOGY
;		message logic.
;
;	V03-011	DWT0141		David W. Thiel		04-Nov-1983
;		Correct decision of who is to bugcheck when two
;		clusters meet.
;
;	V03-010	DWT0136		David W. Thiel		04-Oct-1983
;		Correct validation of transaction number in received
;		message to compare against the current transaction
;		rather than the maximum transaction number seen.
;		Use CLUB$V_LOST_CNX to mark situations where there
;		is a broken connection to a cluster member.
;
;	V03-009	DWT0132		David W. Thiel		23-Sep-1983
;		Correct misuse of register on an error path in
;		CNX$RCVD_DESC.  Improve state change messages to
;		be less repetitious.
;
;	V03-008	DWT0128		David W. Thiel		30-Aug-1983
;		Be less interested in received status when CLUB$V_INIT
;		flag has not yet been set -- avoid attempting to join
;		a cluster in this situation.
;		Enable writing quorum file when node is added to an
;		existing cluster.
;
;	V03-007	DWT0118		David W. Thiel		22-Aug-1983
;		Add quorum disk support.  Change CONFIG_CHANGE to
;		CNX$CONFIG_CHANGE.  Add logic to recover from a
;		failure while a cluster state transition is in
;		progress.  Add routines to process incoming QUORUM
;		and TOPOLOGY messages.
;
;	V03-006	DWT0116		David W. Thiel		1-Aug-1983
;		Change INIT_STD_RESP to CNX$INIT_STD_RESP and make
;		symbol gobal.  Change PROCESS_RESPONSE to
;		CNX$PROCESS_REPONSE and make symbol global.
;		Improve use of CLUB$L_TQE field.
;
;	V03-005 DWT0111		David W. Thiel		28-Jul-1983
;		Automatically raise quorum to be greater than half
;		of the sum of available votes.
;		Use real TQE for random timeouts.
;		Add CNX$CHANGE_QUORUM entry point.
;		Correct handling of status bits received from a
;		remote node.
;		Hang if no quorum using CNX$CHECK_QUORUM routine.
;
;	V03-004	DWT0109		David W. Thiel		25-Jun-1983
;		Select appropriate nodes when join message is received.
;		Defer setting directory system in joining node
;		until phase 2 message is received.
;
;	V03-003	DWT0108		David W. Thiel		23-Jun-1983
;		Fix broken BLBC instruction.  Fix logic for looking
;		up a node described in a message from a remote system.
;
;	V03-002	DWT0106		David W. Thiel		23-Jun-1983
;		Correct search for CSB when node description received.
;		Correct propagation of directory node when a node
;		joins the cluster.
;		Deallocate RSPID after use in DESCRIBE_NODE.
;		When a connection breaks, disable locks and forbid
;		additions of nodes to the cluster.
;		Correct discrepancy in protocol for reqeusting membership
;		in a cluster.
;
;	V03-001	DWT0103		David W. Thiel		27-May-1983
;		Fix blown register.
;
;--


	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CDRPDEF			; CDRP offsets
	$CDTDEF				; CDT Offsets
	$CLMDRSDEF			; Cluster disconnect/reject codes
	$CLSMSGDEF			; Cluster message definitions
	$CLUBDEF			; CLUster Block offsets
	$CSBDEF				; CSB Offsets
	$DYNDEF				; Data structure type codes
	$FKBDEF				; ForK Block offsets
	$IPLDEF				; IPL definitions
	$PCBDEF				; Process Control Block offsets
	$PDTDEF				; Port Definition Table offsets
	$SBDEF				; System Block offsets
	$SSDEF				; Status code definitions
	$TQEDEF				; TQE offsets

;
; OWN STORAGE:
;

	.PSECT	$$$040,LONG		; R/W Data PSECT

;***********************************************************************
;
; NOTE:	The following assumptions are in effect for this entire module.
;
;************************************************************************

	ASSUME	IPL$_SYNCH  EQ  IPL$_SCS
	ASSUME	IPL$_SYNCH  EQ  IPL$_TIMER

	.PSECT	$$$100,LONG

	.DEFAULT	DISPLACEMENT,WORD

	.SBTTL	CNX$CON_INIT - Initialization Call

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called at system initialization to start up the
;	configuration manager.  This call must be made AFTER the CLUB
;	is created and initialized.  IPL is 31.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CON_INIT
;	IPL is 31
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 contains status.
;
; SIDE EFFECTS:
;
;	R1 is destroyed.
;
;--

	.PSECT	$$$002,LONG		; Initialization Psect

CNX$CON_INIT::
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	BBSS	#CLUB$V_NO_FORM, -	; Set bit inhibiting cluster formation
		CLUB$L_FLAGS(R4),10$
10$:	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; Address of local CSB
	BISL2	#<CSB$M_STATUS_RCVD ! -	; Mark status received
		  CSB$M_QF_SAME>, -	; Mark quorum files matching
		CSB$L_STATUS(R3)	;   for local CSB
	MOVZWL	#FKB$K_LENGTH,R1	; Fork block length
	BSBW	CNX$ALLOZMEM		; Allocate and zero a block of memory
	BLBC	R0,20$			; Branch on error
	MOVL	R2,R5
	MOVB	#DYN$C_FRK, -		; Block type
		FKB$B_TYPE(R5)
	MOVB	#IPL$_SCS, -		; Fork IPL
		FKB$B_FIPL(R5)
	BSBW	INIT_CONTINUE		; Put synchronous return on stack
	MOVL	S^#SS$_NORMAL,R0	; Set success status
20$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB

	.PSECT	$$$100,LONG

INIT_CONTINUE:
	JSB	G^EXE$FORK		; Fork
;
; Get here soon after IPL is lowered to SCS (8) at system initialization
;
	BSBW	CNX$RANDOM_INIT		; Initialize random number generator
;
; Wait for SYSINIT to start up and declare us ready for think about forming a cluster
;
10$:	BSBW	CNX$SEND_ALL_STATUS	; Send status as necessary
	FORK_WAIT			; Wait a second
	BBC	#CLUB$V_INIT, -		; Branch if SYSINIT has not yet triggered us
		CLUB$L_FLAGS(R4),10$
	PUSHR	#^M<R4,R5>		; Save registers
	BSBW	SCAN			; Look for work to do
	POPR	#^M<R4,R5>		; Restore registers
;
; We must now delay an appropriate time before forming a cluster in order to allow
; the discovery of other nodes that are already cluster members before attempting
; to form our own cluster.  This time is the larger of:
;	a) SCS process poller interval + largest PDT polling sweep interval
;	b) Time to find quorum disk device and acquire a "connection" to the
;		quorum disk
; In fact, we ignore the latter at this time.
; We do the wait in two steps.  First we wait the process poller interval because
; this is known.  Then we wait a time which is the maximum of the polling sweep
; intervals of all ports that have been found during the earlier interval.
;
	MOVZWL	G^SCS$GW_PRCPOLINT,R3	; Process polling interval
20$:	FORK_WAIT			; Wait a second
	BBS	#CLUB$V_CLUSTER, -	; Branch if a cluster has been formed
		CLUB$L_FLAGS(R4),60$
	SOBGEQ	R3,20$			; Wait for interval to complete
	;
	; By now, all SCS ports should have been found.
	; Scan list of all PDT's computing the largest value of PDT$L_POLLSWEEP that
	; can be found.  This is the interval that we should now wait before
	; forming a cluster, i.e. it is the interval that may elapse before a
	; connection may be made to an existing cluster node.
	;
	CLRL	R3			; Accumulator for larger PDT$L_POLLSWEEP
	MOVAL	G^SCS$GL_PDT,R0		; Get address of PDT listhead
30$:	MOVL	(R0),R0			; Link to next PDT
	BEQL	50$			; Branch when all done
	CMPL	PDT$L_POLLSWEEP(R0),R3	; Is this value larger?
	BLEQU	40$			; Branch if no
	MOVL	PDT$L_POLLSWEEP(R0),R3	; Update largest seen yet
40$:	BRB	30$			; Continue iteration

50$:	FORK_WAIT			; Wait a second
	BBS	#CLUB$V_CLUSTER, -	; Branch if a cluster has been formed
		CLUB$L_FLAGS(R4),60$
	SOBGEQ	R3,50$			; Wait for interval to complete
	BBCC	#CLUB$V_NO_FORM, -	; Clear formation inhibit
		CLUB$L_FLAGS(R4),60$
60$:	MOVL	R5,R0			; Fork block address
	JSB	G^EXE$DEANONPAGED	; Deallocate fork block
	BRW	SCAN			; Look for work to do

	.SBTTL	CNX$POWER_FAIL - Power Fail Recovery Entry

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called during recovery from a power failre.
;	IPL is 31.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$POWER_FAIL
;	IPL is 31
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	All registers are preserved
;
;--

CNX$POWER_FAIL::
	PUSHR	#^M<R3,R4,R5>		; Save registers
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	MOVAB	CLUB$B_CLUBPWF(R4),R5	; Fork block address
	BBSS	#CLUBPWF$V_BUSY, -	; Branch if block is in use
		CLUBPWF$L_STATUS(R5),10$ ;   by a previous power recovery
	BSBB	20$			; Save synchronous return address
10$:	POPR	#^M<R3,R4,R5>		; Restore registers
	RSB				; Return to power fail notification code

20$:	JSB	G^EXE$FORK		; Fork to IPL SYNCH, SCS
;
; Continue here at IPL 8
;
	BBCC	#CLUBPWF$V_BUSY, -	; Clear busy bit, branch on error
		CLUBPWF$L_STATUS(R5),60$
	BBCC	#CLUB$V_QF_DYNVOTE, -	; Clear bit counting disk in dynamic quorum
		CLUB$L_FLAGS(R4),30$
30$:	BBSS	#CLUB$V_QF_FAILED_NODE, - ; Trigger quorum disk manager to reacquire disk
		CLUB$L_FLAGS(R4),40$
40$:	MOVL	CLUB$L_FLAGS(R4),R2	; Save flags
	BSBW	CNX$CHECK_QUORUM	; Check for out of quorum condition
	BICL2	CLUB$L_FLAGS(R4),R2	; Set flag in R2 if clear now and set earlier
	BBS	#CLUB$V_QUORUM,R2,50$	; Branch if quorum was just lost and mntver already
					;   triggered
	JSB	G^EXE$CLUTRANIO		; Throw disks into mount verification to ensure that
					;   all disk I/O is blocked, pending resolution of
					;   the status of the cluster
50$:	RSB

60$:	BUG_CHECK	CNXMGRERR,FATAL	; Multiple use of fork block


	.SBTTL	CNX$CON_NEWSYS - Connected to New System

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a connection to a new system is
;	made.  It will exchange status with the new system and consider
;	forming a cluster, joining the cluster of which the new system is
;	a member, or wait for the new system to join the cluster of which
;	this system is a member.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CON_NEWSYS
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R5: CSB of new system
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

CNX$CON_NEWSYS::
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	R5,R3			; Put CSB address in R3
	BBCS	#CSB$V_SEND_STATUS, -	; Need to send status
		CSB$L_STATUS(R3),10$
10$:	BSBW	START_TIMEOUT		; Start CLUB-based timer
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return

	.SBTTL	CNX$CON_BREAK - Connection has broken

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a connection to a system has broken and
;	attempts to reclose the connection have failed.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CON_BREAK
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R5: CSB of system to which the connection is lost
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

CNX$CON_BREAK::
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	R5,R3			; Put CSB address in R3
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	MOVAB	CLUB$B_CLUFCB(R4),R5	; Address of CLUFCB

	BBC	#CSB$V_MEMBER, -	; Branch if lost node is
		CSB$L_STATUS(R3),10$	;   not a cluster member
	BISL2	#CLUB$M_LOST_CNX, -	; Mark connection to member lost
		CLUB$L_FLAGS(R4)
	MNEGB	#1,G^LCK$GB_STALLREQS	; Stall lock requests
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID index value
	BBCC	R0, -			; Clear participation bit in
		CLUFCB$B_NODEMAP(R5),5$ ;  failover table for lost node
5$:	MOVL	CLUB$L_LOCAL_CSB(R4),R1	; Local node CSB address
	BBCC	R0,CSB$B_NODEMAP(R1),10$ ; Mark loss of connectivity from local node
10$:
	BBC	#CLUB$V_TRANSITION, -	; Branch if no state change in
		CLUB$L_FLAGS(R4), 60$	;   progress
	CMPL	CLUB$L_COORD(R4), -	; Is this node the coordinator
		CLUB$L_LOCAL_CSB(R4)
	BEQL	40$			; Branch if this node is the coordinator
;
; Here if transition is in progress and this node is not the coordinator
;
	CMPL	CLUB$L_COORD(R4),R3	; Is connection to coordinator lost?
	BNEQ	70$			; Branch if not coordinator connection
;
; The connection to the coordinator has been lost and this node is in the midst of
; a cluster state transition.  If a Phase 1 message has not yet been received, it is
; safe to back out the transition because we know that noone can have seen a Phase 2
; message.
;
	CMPB	CLUB$B_CUR_PHASE(R4), -	; Has Phase 1 been seen yet?
		#CLMCNX$K_PH1
	BLSSU	30$			; Branch if no Phase 1 yet
;
; This node has received a Phase 1 message.  If this node is not a member of a
; cluster, then bugcheck -- we can't cleanly resolve what might be happening.
;
	BBC	#CLUB$V_CLUSTER, -	; Branch if not a cluster member and
		CLUB$L_FLAGS(R4),20$	;   resolve the situation the easy way
	BSBB	ANALYZE_PHASE		; Make complex decision about what to do
	BRB	70$
;
; This node is not a member of a cluster, is in Phase 1 of a cluster state transition,
; and has lost the connection to the transition coordinator.  It is not trivial
; to resolve this situation.  Take the easy way out.
;
20$:	BUG_CHECK	CLUEXIT,FATAL	; Can't handle this failure case
;
30$:	BSBW	UNLOCK_ALL		; Unlock things
	BRB	70$

40$:
;
; Here if transition is in progress and this node is the coordinator
;
	CMPB	CLUB$B_CUR_PHASE(R4), -	; Has Phase 2 been sent yet?
		#CLMCNX$K_PH2
	BGEQU	50$			; Branch if phase 2 sent
	BBCS	#CLUB$V_UNLOCK, -	; No phase 2 sent -- request
		CLUB$L_FLAGS(R4), 50$	;   unlock
50$:
;
; Common exit routine
;
60$:	BSBW	SCAN			; Start CLUB-based timer
70$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return

	.SBTTL	ANALYZE_PHASE - Determine Transition Phase and Finish Transition

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when all of the following are true:
;	1)	The local node is a member of a cluster
;	2)	A cluster state transition is in progress
;	3)	The connection to the coordinator node has broken
;	4)	A Phase 1 message has been received
;
;	This routine must determine whether to commit or backout the transition.
;
; CALLING SEQUENCE:
;
;	JSB	ANALYZE_PHASE
;	IPL is IPL$_SCS
;	The caller is returned to synchronously, but the function performed
;	continues asynchronously and no notification is given to the caller
;	upon completion.
;
; INPUT PARAMETERS:
;
;	R3: CSB of system to which the connection is lost
;	R4: Address of CLUB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 through R5 are destroyed
;
; ALGORITHM:
;
;	The strategy here is to poll all remaining cluster members and
;	see whether they can resolve out dilemma.
;	If another member has:
;		Not yet seen Phase 1 ==> Undo the transition in progress
;		Already seen Phase 2 ==> Commit the transition in progress
;		Seen Phase 1 and has a coordinator connection ==> Restart poll
;		Seen Phase 1 and has no coordinator connection ==> Continue poll
;	If this completes without yield a definitive (Undo or Commit) result,
;	poll all nodes again.  If another member has:
;		Not yet seen Phase 1 ==> Undo the transition in progress
;		Already seen Phase 2 ==> Commit the transition in progress
;		Phase 1 and has a coordinator connection ==> inconsistent with above
;		Phase 1 and has no coordinator connection ==>
;			Obtain promise from node that it will never commit this
;    			transition
;			Continue poll
;	If this completes without yielding a definitive (Undo or Commit) result,
;	do not commit the transition.
;
;--

ANALYZE_PHASE:
	BICL2	#CLUB$M_BACKOUT, -	; Clear backout inhibit bit
		CLUB$L_FLAGS(R4)
10$:	BICL2	#CLUB$M_STS_PPHASE, -	; Clear polling phase flag (Phase A)
		CLUB$L_FLAGS(R4)
20$:	BICL2	#< -			; Clear poll result bits
		CLUB$M_STS_PH0 ! -	;   phase 0 seen
		CLUB$M_STS_PH1 ! -	;   phase 1 seen (good coordinator connection)
		CLUB$M_STS_PH1B ! -	;   phase 1 seen (broken coordinator connection)
		CLUB$M_STS_PH2>, -	;   phase 2 seen
		CLUB$L_FLAGS(R4)
	CLRW	CLUB$W_MSGCNT(R4)	; Initialize waiting count
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,70$			; Branch when done
	BBC	#CSB$V_MEMBER, -	; Branch if not a member
		CSB$L_STATUS(R3),30$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if permanent break
		CSB$L_STATUS(R3),30$	;   in connection
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),30$
	BSBW	CNX$ALLOC_WARMCDRP_CSB
	BLBC	R0,40$			; No memory available
	INCW	CLUB$W_MSGCNT(R4)	; Include in wait count
	BSBB	50$			; Interogate node
	BRW	CNX$SCAN_CSBS_FORK	; Release control mementarily

30$:	RSB				; Return and continue scan

40$:	BRW	CNX$SCAN_CSBS_RETRY	; Delay and resume scan
;
; Send status inquiry to one node
;
50$:	MOVZBL	#CLMCNX$K_FNC_TRNSTS,R0	; Facility specific message code
	BBC	#CLUB$V_STS_PPHASE, -	; Branch if status inquiry phase A
		CLUB$L_FLAGS(R4),60$
	BBSS	#CLMCNX$V_RP_TRNSTS_CMT+24, - ; Request commitment on PH1B status
		R0,60$			;   -- to go into message reply field
60$:	BSBW	INIT_STD_MSG		; Standard CDRP message initialization
	BSBW	CNX$SEND_MSG_CSB	; Send message
;
;	We are resumed here when the response message arrives.
;	Registers contain:
;		R0:	Status
;		R2:	Address of message buffer
;		R3:	Address of CSB
;		R4:	Address of PDT
;		R5:	Address of CDRP
;
	BSBW	CNX$PROCESS_RESPONSE	; Deallocate storage, get status
	BLBC	R0,70$			; Branch if NACK or connection broken
	ASSUME	CLMCNX$K_RP_TRNSTS_PH0+1 EQ CLMCNX$K_RP_TRNSTS_PH1B
	ASSUME	CLMCNX$K_RP_TRNSTS_PH1B+1 EQ CLMCNX$K_RP_TRNSTS_PH1
	ASSUME	CLMCNX$K_RP_TRNSTS_PH1+1 EQ CLMCNX$K_RP_TRNSTS_PH2
	ASSUME	CLUB$V_STS_PH0+1 EQ CLUB$V_STS_PH1B
	ASSUME	CLUB$V_STS_PH1B+1 EQ CLUB$V_STS_PH1
	ASSUME	CLUB$V_STS_PH1+1 EQ CLUB$V_STS_PH2
	MOVZBL	CLMCNX$B_REPLY(R2),R0
	SUBL2	#CLMCNX$K_RP_TRNSTS_PH0,R0 ; Base on zero
	CMPL	R0,#CLMCNX$K_RP_TRNSTS_PH2 ; Check range
	BGTRU	80$			; Out of range reply, die
	ADDL2	#CLUB$V_STS_PH0,R0	; Compute bit number in CLUB
	BBSS	R0,CLUB$L_FLAGS(R4),70$ ; Set status bit for this node
;
; terminate threads -- except for the last one
;
70$:	DECW	CLUB$W_MSGCNT(R4)
	BLSS	90$			; Branch when done
	RSB				; Terminate thread

80$:	BUG_CHECK	CNXMGRERR,FATAL	; Inconsistent message data received
;
; Get here after all available member nodes have been polled.
; Evaluate results of the poll and take appropriate action
;
90$:	MOVL	CLUB$L_FLAGS(R4),R0	; Get flag bits for easy handling
	BBC	#CLUB$V_STS_PH0,R0,100$	; Branch if Phase 0 not seen
	BBC	#CLUB$V_STS_PH2,R0,100$	; Branch if Phase 2 not seen
	BSBW	CNX$BUGCHECK_CLUSTER	; Phase 0 and Phase 2 were seen -- die!
	RSB

100$:	BBC	#CLUB$V_STS_PH0,R0,110$	; Branch if Phase 0 not seen
	BRW	UNLOCK_ALL		; Some node was in Phase 0 -- Bail out and return

110$:	BBC	#CLUB$V_STS_PH2,R0,130$ ; Branch if Phase 2 not seen
	BBS	#CLUB$V_BACKOUT,R0,120$	; Branch if we have commited to backing out
	BRW	DO_PHASE2		; Pretend a phase 2 message has arrived

120$:	BUG_CHECK	CLUEXIT,FATAL	; Saw phase 2 after commiting to backing out

130$:	BBSS	#CLUB$V_STS_PPHASE, -	; Set polling phase B and do it
		CLUB$L_FLAGS(R4),150$
;
; Polling phase A just completed
;
	BBC	#CLUB$V_STS_PH1,R0,140$	; Phase 1 with good connection not seen
	BRW	10$			; Repeat first polling phase
140$:	BRW	20$			; Perform second polling phase

150$:	BBC	#CLUB$V_STS_PH1,R0,160$	; Phase 1 with good connection not seen
	BUG_CHECK	CNXMGRERR,FATAL	; Consistency error -- node with good connection
					; seen during polling phase B

160$:	BRW	UNLOCK_ALL		; Second phase was unconclusive, back-out

	.SBTTL	CNX$DISK_CHANGE - Quorum Disk Connection State Change

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when the "connection" to the quorum disk has broken
;	or has been re-established.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$DISK_CHANGE
;	Kernel mode, IPL .le. IPL$_SCS = IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

CNX$DISK_CHANGE::
	DSBINT	#IPL$_SYNCH		; Save and raise IPL
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; Address of local CSB
	EXTZV	#CLUB$V_QF_ACTIVE,#1, -	; Extract quorum file active bit
		CLUB$L_FLAGS(R4),R0	;   from CLUB
	INSV	R0, -			; Insert quorum file active bit
		#CSB$V_QF_ACTIVE,#1, -	;   extracted from CLUB into the
		CSB$L_STATUS(R3)	;   local CSB
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,30$			; Branch when done
	BBSS	#CSB$V_SEND_STATUS, -	; Set status request bit
		CSB$L_STATUS(R3),20$
20$:	RSB

30$:	BSBW	CNX$CHECK_QUORUM	; Hang if necessary
	BSBW	SCAN			; Look for work to do
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	ENBINT				; Restore IPL
	RSB				; Return

	.SBTTL	CNX$CHANGE_QUORUM - Adjust quorum

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Request that the cluster quorum be updated to a
;	specified value.  This requires a full cluster state
;	transition to agree on a new value.  The value is
;	adjusted so as not to leave the cluster without a
;	quorum and so as not to risk paritioning given a
;	universe of the nodes currently in the cluster.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CHANGE_QUORUM
;	IPL is IPL$_SCS
;
;	The requestor can determine that the operator is complete by
;	polling the CLUB$V_ADJ_QUORUM bit in the CLUB$L_FLAGS word.
;	This bit is cleared after the quorum has been adjusted.
;
; INPUT PARAMETERS:
;
;	R1 is new quorum value
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 is success status.
;
; SIDE EFFECTS:
;
;	R1 is destroyed.
;
;--

CNX$CHANGE_QUORUM::
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	CLRL	R0			; Assume failure
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	BBS	#CLUB$V_TRANSITION, -	; Branch if a state change in progress
		CLUB$L_FLAGS(R4),20$
	BBSS	#CLUB$V_ADJ_QUORUM, -	; Set quorum update request bit
		CLUB$L_FLAGS(R4),20$	;   branch if already set
	MOVW	R1, -			; Store requested quorum value
		CLUB$W_ADJ_QUORUM(R4)
10$:	BSBW	SCAN			; Look for work to do
	MOVZWL	#SS$_NORMAL,R0		; Return success status
20$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return

	.SBTTL	CNX$SHUTDOWN - Request cluster shutdown

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This entry point is called to request a cluster shutdown.
;	While in shutdown mode:
;		No nodes may join cluster.
;		If quorum is lost, shutdown immediately.
;		When all systems reach shutdown state, shutdown this node.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$SHUTDOWN
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 is success status
;
; SIDE EFFECTS:
;
;	R1 is destroyed.
;
;--

CNX$SHUTDOWN::
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; Local system CSB address
	BBSS	#CLUB$V_SHUTDOWN, -	; Set shutdown mode in CLUB
		CLUB$L_FLAGS(R4),40$	;  and branch if already set
	BBSS	#CSB$V_SHUTDOWN, -	; Set shutdown mode in CSB
		CSB$L_STATUS(R3),20$
20$:	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,40$			; Branch when done
	BBSS	#CSB$V_SEND_STATUS, -	; Request that status be sent
		CSB$L_STATUS(R3),30$
30$:	RSB

40$:	BSBW	SCAN			; Look for things to do
	MOVZWL	#SS$_NORMAL,R0		; Return success status
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return

	.SBTTL	CNX$SEND_ALL_STATUS - Send Status to All Flagged Systems

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to send our status to all systems
;	for whom the send status flag is set.
;	The routine returns synchronously, status will eventually
;	get sent or the link will break and the status will never
;	be sent.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$SEND_ALL_STATUS
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R4 is address of CLUB
;
; COMPLETION CODES:
;
;	R0
;		Success (even):	Status will be sent or the link will break
;		Failure (odd): Status cannot be sent, probably because storage
;			cannot be allocated
;
; SIDE EFFECTS:
;
;	R1 is destroyed
;
;--

CNX$SEND_ALL_STATUS::
	PUSHR	#^M<R2,R3,R5>		; Save registers
	MOVL	#1,R5			; Init summary status
	BSBW	CNX$SCAN_CSBS		; Look for CSB needing status
	BLBC	R0, 20$			; Branch when done
	BBS	#CSB$V_LONG_BREAK, -	; Ignore nodes with permanently
		CSB$L_STATUS(R3),10$	;   connections
	BBC	#CSB$V_SEND_STATUS, -	; Branch if status not requested
		CSB$L_STATUS(R3),10$
	BSBB	SEND_STATUS		; Queue status message
	BLBS	R0,10$			; Branch on success
	MOVL	R0,R5			; Save status
10$:	RSB

20$:	MOVL	R5,R0			; Fetch status
	POPR	#^M<R2,R3,R5>		; Restore registers
	RSB				; Return

	.SBTTL	SEND_STATUS - Send Status to a System

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to send our status to a system.
;	The routine returns synchronously, status will eventually
;	get sent or the link will break and the status will never
;	be sent.
;
; CALLING SEQUENCE:
;
;	JSB	SEND_STATUS
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R3: CSB of new system
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0
;		Success (even):	Status will be sent or the link will break
;		Failure (odd): Status cannot be sent, probably because storage
;			cannot be allocated
;
; SIDE EFFECTS:
;
;	R1 is destroyed
;
;--

SEND_STATUS:
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	BBS	#CSB$V_LOCAL, -		; Skip if local system
		CSB$L_STATUS(R3),20$
	BBS	#CSB$V_LONG_BREAK, -	; Skip if long break
		CSB$L_STATUS(R3),20$
	BSBW	CNX$ALLOC_CDRP_ONLY
	BLBC	R0,30$			; No memory available
	MOVAB	B^BUILD_STS_MSG, -	; Address of routine to build
		CDRP$L_MSGBLD(R5)	;  status message
	BBCC	#CSB$V_SEND_STATUS, -	; Clear "send status" request
		CSB$L_STATUS(R3),10$
10$:	BSBW	CNX$SEND_FORGET		; Setup immediate return
	MOVL	R3,R5			; Address of CSB
	MOVAB	SNDSTS_MSG,R0		; Sending status message text
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
20$:	MOVL	S^#SS$_NORMAL,R0	; Return success
30$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return


	.SBTTL	BLD_STS_MSG - Build Status Message

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds a status message describing the local node and the
;	cluster of which it is a member.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_STS_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BUILD_STS_MSG:
	MOVB	#CLSMSG$K_FAC_CNX, -	; Facility identifier
		CLSMSG$B_FACILITY(R2)
	MOVB	#CLMCNX$K_FNC_STATUS, -	; Facility specific function code
		CLSMSG$B_FUNC(R2)
	MOVL	CSB$L_CLUB(R3),R1	; Address of CLUB
	CLRB	CLMSTS$B_FLAGS(R2)	; Clear flags bits
	BBC	#CLUB$V_CLUSTER, -	; Branch if bit not set
		CLUB$L_FLAGS(R1),10$
	BISB	#CLMSTS$M_CLUSTER, -	; Set bit in message
		CLMSTS$B_FLAGS(R2)
10$:	BBC	#CLUB$V_QF_ACTIVE, -	; Branch if bit not set
		CLUB$L_FLAGS(R1),20$
	BISB	#CLMSTS$M_QF_ACTIVE, -	; Set bit in message
		CLMSTS$B_FLAGS(R2)
20$:	BBC	#CLUB$V_SHUTDOWN, -	; Branch if bit not set
		CLUB$L_FLAGS(R1),30$
	BISB	#CLMSTS$M_SHUTDOWN, -	; Set bit in message
		CLMSTS$B_FLAGS(R2)
30$:	MOVW	CLUB$W_QUORUM(R1), -	; Cluster quorum
		CLMSTS$W_CQUORUM(R2)
	MOVW	CLUB$W_VOTES(R1), -	; Cluster votes
		CLMSTS$W_CVOTES(R2)
	MOVW	CLUB$W_NODES(R1), -	; Cluster nodes
		CLMSTS$W_NODES(R2)
	MOVL	CLUB$L_LOCAL_CSB(R1),R0	; Address of local CSB
	MOVW	CSB$W_QUORUM(R0), -	; Node quorum
		CLMSTS$W_NQUORUM(R2)
	MOVW	CSB$W_VOTES(R0), -	; Nodes votes
		CLMSTS$W_NVOTES(R2)
	MOVQ	CLUB$Q_FTIME(R1), -	; Cluster formation time
		CLMSTS$Q_FTIME(R2)
	MOVQ	CLUB$Q_LST_TIME(R1), -	; Time stamp of last transaction
		CLMSTS$Q_LST_TIME(R2)
	MOVW	CSB$W_QDVOTES(R0), -	; Quorum disk votes proposed by local
		CLMSTS$W_QDVOTES(R2)	;   node
	MOVW	CSB$W_LCKDIRWT(R0), -	; Lock manager directory system weight
		CLMSTS$W_LCKDIRWT(R2)
	MOVL	CLUB$L_MAX_XTN(R1), -	; Largest transaction code
		CLMSTS$L_MAX_XTN(R2)	;  seen
	MOVQ	CSB$Q_REFTIME(R0), -	; Put local reference time into message
		CLMSTS$Q_REFTIME(R2)
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC3	#CLMSTS$S_QDISK, -	; Quorum disk name
		CLUB$T_QDNAME(R1), -	; from SYSGEN parameter
		CLMSTS$B_QDISK(R2)
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB

	.SBTTL	CNX$RCVD_STATUS - Status Received from a System

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a status message is received.
;	Data from the message is copied in the CSB.  A cluster
;	transition may be initiated as a result of seeing the
;	message.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_STATUS
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_STATUS::
	MOVL	R3,R5			; Address of CSB
	MOVAB	RCVSTS_MSG,R0		; Sending status message text
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
	PUSHR	#^M<R2,R3>		; Save needed registers
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	BICL2	#<CSB$M_CLUSTER ! -	; Clear out received status bits in CSB
		  CSB$M_QF_ACTIVE ! -
		  CSB$M_SHUTDOWN>, -
		CSB$L_STATUS(R3)
	BBC	#CLMSTS$V_CLUSTER, -	; Branch if bit clear
		CLMSTS$B_FLAGS(R2),1$
	BBSS	#CSB$V_CLUSTER, -	; Set bit in CSB
		CSB$L_STATUS(R3),1$
1$:	BBC	#CLMSTS$V_QF_ACTIVE, -	; Branch if bit clear
		CLMSTS$B_FLAGS(R2),2$
	BBSS	#CSB$V_QF_ACTIVE, -	; Set bit in CSB
		CSB$L_STATUS(R3),2$
2$:	BBC	#CLMSTS$V_SHUTDOWN, -	; Branch if bit clear
		CLMSTS$B_FLAGS(R2),3$
	BBSS	#CSB$V_SHUTDOWN, -	; Set bit in CSB
		CSB$L_STATUS(R3),3$
3$:	BBSS	#CSB$V_STATUS_RCVD, -	; Add status received flag
		CSB$L_STATUS(R3),4$
4$:	BBS	#CSB$V_MEMBER, -	; Branch if remote node is a member
		CSB$L_STATUS(R3),5$	;   of the local cluster
	MOVW	CLMSTS$W_NQUORUM(R2), -	; Remote node's quorum
		CSB$W_QUORUM(R3)
	MOVW	CLMSTS$W_NVOTES(R2), -	; Remote node's votes
		CSB$W_VOTES(R3)
	MOVW	CLMSTS$W_NODES(R2), -	; Number of nodes in remote
		CSB$W_NODES(R3)		;   node's cluster
	MOVW	CLMSTS$W_QDVOTES(R2), -	; Proposed votes for quorum disk
		CSB$W_QDVOTES(R3)
	MOVW	CLMSTS$W_LCKDIRWT(R2), - ; Lock manager directory system weight
		CSB$W_LCKDIRWT(R3)
5$:	SUBL3	CLMSTS$L_MAX_XTN(R2), -	; Update largest transaction seen
		CLUB$L_MAX_XTN(R4),R0
	BGEQ	10$			; No update needed
	MOVL	CLMSTS$L_MAX_XTN(R2), -	; Update local information
		CLUB$L_MAX_XTN(R4)
10$:	MOVZBL	CLUB$T_QDNAME(R4),R0	; Is local name defined?
	BEQL	20$			; If equal, then can't be the same
	CMPB	R0,CLMSTS$B_QDISK(R2)	; Compare to received name length
	BNEQ	20$			; Branch if different
	PUSHR	#^M<R2,R3>		; Save registers
	CMPC3	R0,CLUB$T_QDNAME+1(R4), - ; Quorum disk names match?
		CLMSTS$B_QDISK+1(R2)
	POPR	#^M<R2,R3>		; Restore registers
	BNEQ	20$			; Branch if disk names differ
	BBSS	#CSB$V_QF_SAME, -	; Remember that disk names match
		CSB$L_STATUS(R3),20$	;   and branch if already known to match
	BBSS	#CSB$V_SEND_STATUS, -	; Just set same bit, send status so
		CSB$L_STATUS(R3),20$	;   remote node has same opportunity
20$:
	BBS	#CSB$V_MEMBER, -	; Branch if remote node is a
		CSB$L_STATUS(R3),30$	;   member of the local cluster
	MOVQ	CLMSTS$Q_REFTIME(R2), - ; Store reference time
		CSB$Q_REFTIME(R3)
30$:
;
; Dispatch on state of this node
;
	BBC	#CLUB$V_INIT, -		; Branch to exit if initialization
		CLUB$L_FLAGS(R4),300$	;   flag is not yet set
	BBC	#CSB$V_MEMBER, -	; Branch if remote node is not
		CSB$L_STATUS(R3),100$	; a member of the local cluster
;
; The local node is part of an existing cluster.
; Update quorum calculation to reflect any change seen by the remote node,
; for example a change in status of the quorum disk.
;
	BSBW	CNX$CHECK_QUORUM	; Perform dynamic quorum check
	BRB	300$			; Branch to common exit

100$:	BBC	#CLUB$V_CLUSTER, -	; Branch if local node is not
		CLUB$L_FLAGS(R4), 200$	; a cluster member
;
; Local node is a cluster member.
;
; If remote node is a member of another cluster, bugcheck one of the
; clusters.  It is illegal for two clusters ever to see each other.
;
	BBC	#CSB$V_CLUSTER, -	; Branch if remote node is not a
		CSB$L_STATUS(R3), 300$	; member of another cluster
	CMPL	CLUB$Q_FTIME+4(R4), -	; Compare high order foundation times
		CLMSTS$Q_FTIME+4(R2)
	BGTRU	110$			; We are younger, so we die
	BLSSU	120$			; Other is younger and should die
	CMPL	CLUB$Q_FTIME(R4), -	; Compare low order foundation times
		CLMSTS$Q_FTIME(R2)
	BGTRU	110$			; We are younger, so we die
	BLSSU	120$			; Other is younger and should die
	CMPL	CLUB$Q_LST_TIME+4(R4), -; Compare high order transition times
		CLMSTS$Q_LST_TIME+4(R2)
	BGTRU	110$			; We are younger, so we die
	BLSSU	120$			; Other is younger and should die
	CMPL	CLUB$Q_LST_TIME(R4), -	; Compare low order transition times
		CLMSTS$Q_LST_TIME(R2)
	BGTRU	110$			; We are younger, so we die
	BLSSU	120$			; Other is younger and should die
	PUSHR	#^M<R2,R3>		; Save registers
	MOVL	CLUB$L_LOCAL_CSB(R4),R2	; Local CSB address
	MOVL	CSB$L_SB(R2),R2		; SB for local system
	MOVL	CSB$L_SB(R3),R3		; SB for remote system
	CMPC3	#SB$S_SYSTEMID, -	; Compare system ID's
		SB$B_SYSTEMID(R2), -
		SB$B_SYSTEMID(R3)
	POPR	#^M<R2,R3>		; Restore registers
	BLSSU	120$			; Other should die
110$:
;
; Should put code in R0 to explain the bugcheck
;
	BSBW	CNX$BUGCHECK_CLUSTER	; Bring down local cluster
	BRB	300$			; Exit
;
; Get here if we believe that the other cluster should die.
; Send it status which may help it to realize this.
;
120$:	BBSS	#CSB$V_SEND_STATUS, -	; Request that status be sent
		CSB$L_STATUS(R3),130$
130$:	BRB	300$			; Branch to common exit
;
; Get here if local node is not part of a cluster
;
200$:	CMPB	CLUB$B_CUR_CODE(R4), -	; Is this node forming a cluster?
		#CLMCNX$K_XTN_FORM
	BNEQ	210$			; Branch if not
	BBC	#CLMSTS$V_CLUSTER, -	; Branch if remote node is not
		CLMSTS$B_FLAGS(R2),210$	;  a cluster member
	BBSS	#CLUB$V_UNLOCK, -	; Request failure/unlock to
		CLUB$L_FLAGS(R4),210$	;  abort cluster formation
210$:	BRB	300$			; Branch to common exit

;
; Common exit after receiving a status message.
; Deallocate message buffer, prepare to scan for work to do, and return
;
300$:	POPR	#^M<R2,R3>		; Restore registers
	BSBW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer
	BSBB	START_TIMEOUT		; Look for something to do
	RSB

	.SBTTL	CNX$RCVD_TRNSTS - Received Transition Status Request Message

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a transition status request message
;	is received.  A reply is sent indicating whether or not the specified
;	transition in in or prior to Phase 0, in or post to Phase 2, or in Phase
;	1 while this node does/doesn't have a connection to the coordinator.
;	The purpose of this message is to allow a node caught in Phase 1 when
;	its connection to the coordinator breaks to figure out what to do.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_TRNSTS
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_TRNSTS::
	PUSHL	R2			; Save address of message
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	POPR	#^M<R2>			; Restore address of message
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	SUBL3	CLMCNX$L_XTN_ID(R2), -	; Compare transition ID in message with
		CLUB$L_LST_XTN(R4),R0	;   last completed transition
	BGTR	90$			; Branch if inconsistent
	BEQL	20$			; Branch if same and return Phase 2
;
; Here if ID in message is greater than last completed ID
;
	SUBL3	CLMCNX$L_XTN_ID(R2), -	; Compare transition ID in message with
		CLUB$L_CUR_XTN(R4),R0	;   current transition
	BLSS	90$			; Branch if inconsistent
	BGTR	10$			; Branch if same and return Phase 0
;
; Here if ID in message matches current/last unsuccessful ID
;
	CMPB	CLUB$B_CUR_PHASE(R4), -	; Is phase UNLOCK?
		#CLMCNX$K_UNLOCK
	BEQL	10$			; Branch if UNLOCK and return Phase 0
	CMPB	CLUB$B_CUR_PHASE(R4), -	; Is phase before or after Phase 1?
		#CLMCNX$K_PH1
	BLSS	10$			; Branch if before phase 1 and return Phase 0
	BGTR	20$			; Branch if after phase 1 and return Phase 2
;
; Here if local system is in phase 1 of a transition
;
	MOVL	CLUB$L_COORD(R4),R1	; CSB of coordinator
	BBS	#CSB$V_LONG_BREAK, -	; Branch if broken and return Phase 1B
		CSB$L_STATUS(R1),30$
	PUSHL	#CLMCNX$K_RP_TRNSTS_PH1	; Return Phase 1
	BRB	40$			; Branch to common exit

10$:	PUSHL	#CLMCNX$K_RP_TRNSTS_PH0	; Return Phase 0
	BRB	40$			; Branch to common exit

20$:	PUSHL	#CLMCNX$K_RP_TRNSTS_PH2	; Return Phase 2
	BRB	40$			; Branch to common exit

30$:	PUSHL	#CLMCNX$K_RP_TRNSTS_PH1B ; Return Phase 1 (coodinator connection broken)
	BBC	#CLMCNX$V_RP_TRNSTS_CMT, - ; Branch if commitment not requested
		CLMCNX$B_REPLY(R2),40$
	BBSS	#CLUB$V_BACKOUT, -	; Set backout inhibit flag in CLUB
		CLUB$L_FLAGS(R4),40$
40$:	MOVZBL	#CLMCNX$K_FNC_DESC,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	MOVB	#1,CDRP$L_VAL3+2(R5)	; Store success in ACK field
	CVTLB	(SP)+,CDRP$L_VAL3+3(R5)	; Store reply data
	BRW	CNX$RESP_FORGET		; Send response message and forget it

90$:	BUG_CHECK	CNXMGRERR,FATAL	; Inconsistent state of message and this system

	.SBTTL	START_TIMEOUT - Start random CLUB-based timeout
	.SBTTL	START_LONG_TIMEOUT - Start long random CLUB-based timeout

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	If the CLUB fork block is free, start a timeout.
;	An immediate return is made to the caller.  When the
;	timout occurs, the thread jumps to SCAN.
;
; CALLING SEQUENCE:
;
;	JSB	START_TIMEOUT
;	JSB	START_LONG_TIMEOUT
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

START_LONG_TIMEOUT:
	MOVZWL	#20000,R0		; 2000...19999 ms timeout
	BRB	DO_TIMEOUT

START_TIMEOUT:
	MOVZWL	#5000,R0		; Range is 500..4999 milli-seconds

DO_TIMEOUT:
	PUSHL	R0			; Save timeout range
	BSBW	CNX$SEND_ALL_STATUS	; Send status as necessary
	DIVL3	#10,(SP),R3		; Make range max/10...max-1
	SUBL3	R3,(SP)+,R0		; Update random number range
	BSBW	CNX$RANDOM		; Generate a random number
	ADDL2	R0,R3			; Save timeout in R3
	BBS	#CLUB$V_TRANSITION, -	; Branch if activity in progress
		CLUB$L_FLAGS(R4),30$
	MOVAB	CLUB$B_FORK_BLOCK(R4),R5 ; Address of transition fork block
	BBS	#CLUBFKB$V_FKB_BUSY, -	; Branch if fork block in use
		CLUBFKB$L_STATUS(R5),30$
	TSTL	CLUB$L_TQE(R4)		; TQE in use?
	BNEQ	30$
	BBS	#CLUB$V_INIT, -		; Branch if initialization complete
		CLUB$L_FLAGS(R4),40$
30$:	RSB

40$:
;
; Do timeout, time in milli-seconds in R3
;
50$:	MOVZWL	#TQE$K_LENGTH,R1	; Size of timer queue entry
	JSB	G^EXE$ALONONPAGED	; Allocate one
	BSBW	CNX$RESOURCE_CHECK	; Watch out for totally exhausted resources
	BLBC	R0,70$			; Can't allocate memory
	MOVW	R1,TQE$W_SIZE(R2)	; Store size
	MOVB	#DYN$C_TQE,TQE$B_TYPE(R2) ; Store type
	MOVL	R4,TQE$L_FR4(R2)	; Store time delay and CLUB address
	MOVL	R2,CLUB$L_TQE(R4)	; Save TQE address in CLUB
	MOVL	R2,R5			; Move address of TQE
	MOVB	#TQE$C_SSSNGL,TQE$B_RQTYPE(R5) ; Store type of timer queue entry
	MOVAB	B^80$,TQE$L_FPC(R5)	; Store address of timer fork process
	EMUL	R3,#10*1000,#0,R2	; Get milli-seconds and cvt to 100 ns. units
	MOVQ	G^EXE$GQ_SYSTIME,R0	; Get current time
	ADDL	R2,R0			; Add to current time
	ADWC	R3,R1
	JSB	G^EXE$INSTIMQ		; Insert in timer queue
	RSB				; Return

70$:	BSBW	CNX$CLUB_WAIT		; Wait a second or so in the CLUB
	BRB	50$

; Come here as a timer fork process to proceed
; Inputs:
;	R4	CLUB address
;	R5	TQE address

80$:	MOVL	R5,R0			; Address of timer queue entry
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	CMPL	R5,CLUB$L_TQE(R4)	; Is this timeout wanted?
	BNEQ	90$			; Branch if not and drop it
	CLRL	CLUB$L_TQE(R4)		; Clear pointer to TQE
	BSBB	SCAN			; Set up return address, look for work
90$:	MOVAL	G^EXE$AL_TQENOREPT,R5	; Use non-repeating timer queue entry
	RSB

	.SBTTL	SCAN - Look for work to do

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called whenever it might be appropriate to
;	look for something to do.  These instances include timeouts
;	during initialization and after receiving status from nodes.
;
; CALLING SEQUENCE:
;
;	JSB	SCAN
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

SCAN:	BSBW	CNX$SEND_ALL_STATUS	; Send status as needed
	BLBC	R0,160$			; Exit if couldn't send status
	BBC	#CLUB$V_INIT, -		; Branch if SYSINIT initialization incomplete
		CLUB$L_FLAGS(R4),170$
	BBS	#CLUB$V_TRANSITION, -	; Branch if activity in progress
		CLUB$L_FLAGS(R4),170$	;   and drop thread
	MOVAB	CLUB$B_FORK_BLOCK(R4),R5 ; Address of transition fork block
	BBS	#CLUBFKB$V_FKB_BUSY, -	; Branch if fork block in use
		CLUBFKB$L_STATUS(R5),170$
	BBS	#CLUB$V_CLUSTER, -	; Branch if this node is cluster member
		CLUB$L_FLAGS(R4),200$
;
; Local node is not a member of a cluster.
; Investigate joining or forming a cluster.
;
	BSBW	CNX$INIT_CSBS		; Clear out locked, selected bits
	CLRQ	R1			; R1 is last CSB from a cluster node
					; R2 is number of cluster nodes seen
	BSBW	CNX$SCAN_CSBS		; Iterate over all known CSB's
	BLBC	R0,140$			; Branch when done
	BBS	#CSB$V_LONG_BREAK, -	; Branch to skip if there has been
		CSB$L_STATUS(R3), 130$	;  a long break
	BBC	#CSB$V_STATUS_RCVD, -	; Branch if status not received
		CSB$L_STATUS(R3), 130$
	BBS	#CSB$V_CLUSTER, -	; Branch if remote node is a cluster
		CSB$L_STATUS(R3), 110$	;  member
	BBCS	#CSB$V_SELECTED, -	; Mark node selected
		CSB$L_STATUS(R3),130$
	BRB	130$			; Join common exit

110$:	INCL	R2			; Count cluster member node
	TSTL	R1			; Seen a cluster node before?
	BEQL	120$			; Branch if no
;
; Could check that R3 and R1 represent CSB's from the same cluster
;
120$:	MOVL	R3,R1			; Update last seen cluster node
130$:	RSB

140$:	TSTL	R1			; Any cluster members seen?
	BNEQ	150$			; Branch if members seen
;
; Consider whether it is feasible to try to form a cluster
;
	BBS	#CLUB$V_NO_FORM, -	; Branch if cluster formation is
		CLUB$L_FLAGS(R4),160$
	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; Local CSB address
	TSTW	CSB$W_VOTES(R3)		; If local node has no votes, don't
	BEQL	160$			;   try to form cluster
	BSBW	CNX$QUORUM_CALC		; Compute votes, quorum, nodes
	CMPL	R0,R1			; Is there any possibility of a quorum?
	BLSSU	160$			; No quorum possible, go to common exit
	BITL	#^B11, -		; Has a foreign cluster been seen recently?
		CLUB$L_FOREIGN_CLUSTER(R4)
	BNEQ	160$			; Branch if yes and don't try to form a cluster
	BRB	FORM_CLUSTER		; Try to form a cluster

150$:	CMPW	R2,CSB$W_NODES(R1)	; Do we perhaps see all members?
	BLSSU	160$			; Nothing to do right now
	BRW	JOIN_CLUSTER		; Try to join a cluster

160$:	BRW	START_TIMEOUT		; Begin a timeout and then rescan

170$:	RSB				; Exit, dropping thread
;
; Here if a cluster member looking for something to do
;
200$:	BBC	#CLUB$V_LOST_CNX, -	; Branch if no cluster connection is broken
		CLUB$L_FLAGS(R4),220$
	BRW	RECONFIG_CLUSTER	; Need to do failover

220$:	MCOML	#0,R5			; Accumulate shutdown bits
	BSBW	CNX$SCAN_CSBS		; Iterate over all known CSB's
	BLBC	R0,240$			; Branch when done
	BBC	#CSB$V_MEMBER, -	; Branch if not a cluster member
		CSB$L_STATUS(R3), 230$
	MCOML	CSB$L_STATUS(R3),R0
	BICL2	R0,R5			; Accumulate AND of all shutdown bits
230$:	RSB

240$:	BBC	#CSB$V_SHUTDOWN,R5,250$	; Branch if not ready to shutdown
	BUG_CHECK	OPERATOR,FATAL	; Cluster-wide shutdown

250$:	BBS	#CLUB$V_ADJ_QUORUM, -	; Branch if quorum adjustment requested
		CLUB$L_FLAGS(R4),260$
	BBC	#CSB$V_QF_SAME,R5,270$	; Branch if not all members have same disk
	EXTZV	#CSB$V_QF_ACTIVE,#1, -	; Get AND of all member QF active bits
		R5,R0			;   into R0
	CMPZV	#CLUB$V_QF_VOTE,#1, -	; Compare to present state of quorum disk
		CLUB$L_FLAGS(R4),R0
	BEQL	270$			; Branch if present state is OK
260$:	BRW	ADJUST_QUORUM		; Attempt to adjust quorum/quorum disk
;
; Nothing to do right now, so drop thread
;
270$:	RSB

	.SBTTL	FORM_CLUSTER - Try to form a cluster

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine tries to form a new cluster.  It assumes that no
;	cluster is known to this node.
;
; CALLING SEQUENCE:
;
;	JSB	FORM_CLUSTER
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

FORM_CLUSTER:
	BSBW	INIT_TRANSITION		; Initialization for becoming coordinator
	TSTW	CSB$W_VOTES(R3)		; If local node has no votes, don't
	BEQL	50$			;   try to form cluster
	MOVB	#CLMCNX$K_XTN_FORM, -	; FORM transaction
		CLUB$B_CUR_CODE(R4)
	MOVQ	CLUB$Q_CUR_TIME(R4), -	; Define foundation time of cluster
		CLUB$Q_FTIME(R4)
	MOVC3	#CLUB$S_FSYSID, -	; Define founding system ID
		G^SCS$GA_LOCALSB+SB$B_SYSTEMID, -
		CLUB$B_FSYSID(R4)
	CLRL	R5			; No CSB for message
	MOVAB	TRYFORM_MSG,R0		; Trying to form cluster message
	BSBW	CNX$CONFIG_CHANGE	; Make status known
	BSBW	CNX$SCAN_CSBS		; Examine all CSBs
	BLBC	R0,20$			; Branch when done
	BBC	#CSB$V_STATUS_RCVD, -	; Ignore nodes that haven't sent
		CSB$L_STATUS(R3),10$	;   status
	BBS	#CSB$V_SEND_STATUS, -	; Ignore nodes that need status
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LONG_BREAK, -	; Ignore nodes with whom the connection
		CSB$L_STATUS(R3),10$	;   is broken
	TSTW	CSB$W_VOTES(R3)		; Ignore nodes with no votes
	BEQL	10$
	BBCS	#CSB$V_SELECTED, -	; Mark node selected
		CSB$L_STATUS(R3),10$
10$:	PUSHL	R3			; Save context register
	MOVC5	#0,(SP),#0, -		; Zero nodemap
		#CSB$S_NODEMAP, -
		CSB$B_NODEMAP(R3)
	POPR	#^M<R3>
	RSB

20$:
;
; Selected nodes are the possible population from which to form a
; cluster.
;
	BSBW	CNX$QUORUM_CALC		; Compute votes, quorum, nodes
	CMPL	R0,R1			; Is there any possibility of a quorum?
	BLSSU	50$			; No quorum possible
	BSBW	LOCK_NODES		; Attempt to lock selected nodes
;
; Have locked all possible nodes.
; Assign temporary CSID's to nodes.
;
	BSBW	CNX$SCAN_CSBS
	BLBC	R0,60$			; All done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),40$
	BSBW	CNX$ASSIGN_CSID		; Create a CSID for the selected node
	BLBS	R0,40$			; Branch on success
	BBCS	#CLUB$V_UNLOCK, -	; Request that everything be unlocked
		CLUB$L_FLAGS(R4), 40$
40$:	RSB				; Resume scan

50$:	BRW	UNLOCK_ALL		; Bail out of transaction

60$:	BSBW	CNX$CHECK_UNLOCK	; Check for unlock request
;
; Prepare to describe all candidate nodes to all other candidate nodes
;
FORM_DESCRIBE:
	CLRW	CLUB$W_MSGCNT(R4)	; Count of responses to wait for
	BSBW	CNX$SCAN_CSBS		; Scan all CSBs
	BLBC	R0,130$			; Branch if scan done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),10$
	MOVL	CLUB$L_LOCAL_CSB(R4),R1	; Local CSB address
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; Subject node CSID index
	BBSS	R0,CSB$B_NODEMAP(R1),5$	; Mark local node able to see node
5$:	BBS	#CSB$V_LONG_BREAK, -	; Branch if permanent break in
		CSB$L_STATUS(R3),10$	;   connection
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),10$
	BSBW	CNX$ALLOC_CDRP_ONLY	; Get a fork block
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,20$			; No memory available
	MOVL	R3,CDRP$L_VAL8(R5)	; Address of node to talk to
	MOVAQ	CLUB$L_CSBQFL(R4), -	; Address of CSB listhead
		CDRP$L_VAL7(R5)
	INCW	CLUB$W_MSGCNT(R4)	; Increment waiting count
	BSBB	40$			; Describe nodes
	BRW	CNX$SCAN_CSBS_FORK	; Fork and continue scan

10$:	RSB

20$:	BRW	CNX$SCAN_CSBS_RETRY	; Wait and resume scan

;
; Tell a node about all of the others
;
40$:	MOVL	@CDRP$L_VAL7(R5),R2	; Next CSB to describe
	MOVL	R2,CDRP$L_VAL7(R5)	;  and save it
	ASSUME	CLUB$L_CSBQFL EQ 0
	CMPL	R2,R4			; At end of list?
	BEQL	125$			; Branch if done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R2),40$
	BSBW	DESCRIBE_NODE		; Tell one node about another
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	BLBC	R0,120$			; Error sending message
	BLBC	R1,50$			; Branch if node is unknown
	MOVZWL	CSB$W_CSID_IDX(R2),R0	; CSID Index of described system
	BBSS	R0,CSB$B_NODEMAP(R3), -	; Mark node visible
		50$
50$:	BBC	#CLUB$V_UNLOCK, -	; Branch if no unlock request
		CLUB$L_FLAGS(R4),40$
; 
120$:	BBSS	#CLUB$V_UNLOCK, -	; Request that all be unlocked
		CLUB$L_FLAGS(R4),125$
125$:	MOVL	R5,R0			; Address of CDRP
	JSB	G^EXE$DEANONPAGED	; Deallocate CDRP

;
; terminate threads -- except for the last one
;
130$:	DECW	CLUB$W_MSGCNT(R4)
	BLSS	140$			; Branch when done
	RSB				; Terminate thread

140$:	BSBW	CNX$CHECK_UNLOCK	; Check unlock request

;
; Get here when all nodes have been described to all others
; Now have told every node about every other node and each node's
; CSB contains a map of nodes that can be seen
;
FORM_PROPOSE:
	BSBW	CNX$OPT_INIT		; Compute optimal cluster containing local node
	BLBC	R0,270$			; Can't perform computation (no pool?)
	BSBW	CNX$SCAN_CSBS		; Scan all CSBs
	BLBC	R0,260$			; Branch when scan is done
	BBC	#CSB$V_SELECTED, -	; Branch if CSB not selected
		CSB$L_STATUS(R3),250$
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID index of CSB
	BBS	R0, -			; Branch if node is in desired cluster
		CLUB$B_NODEMAP(R4),250$	;
	BBCC	#CSB$V_SELECTED, -	; Clear select bit
		CSB$L_STATUS(R3),250$
250$:	RSB				; Advance to next iteration

;
; Check for quorum
;
260$:	BSBW	CNX$QUORUM_CALC		; Compute quorum, votes, nodes
	CMPL	R0,R1			; Is there any possibility of a quorum?
	BGEQU	290$			; Have a quorum!
270$:	BRW	UNLOCK_ALL		; Bail out of transition

290$:	BSBW	CNX$DIRVEC_ADJ		; Create directory system vector
	BLBC	R0,270$			; Branch on failure
	MOVQ	G^EXE$GQ_SYSTIME, -	; Save current time as new
		CLUB$Q_NEWTIME(R4)
	MOVQ	CLUB$Q_NEWTIME(R4), -	; Save as reference time also
		CLUB$Q_NEWTIME_REF(R4)
;
; Propose cluster -- Send Phase 1 Messages
;
	MOVZBL	#CLMCNX$K_FNC_FORM, -	; Facility specific message code
		CLUB$L_CTX0(R4)
	MOVAB	W^BLD_FORM_MSG, -	; Address of routine to build
		CLUB$L_CTX1(R4)		;  status message
	BSBW	SEND_PH1		; Send phase 1 messages
;
; All nodes have seen Phase 1 and ACKed it.
; Now is the time to send Phase 2.
;
	BRW	SEND_PH2
;
; At the completion of sending Phase 2 messages, this location
; is executed as a thread.
;
FORM_FINISH:
	BRW	FORM_JOIN_FINISH	; Branch to common form/join phase 2 processing

	.SBTTL	RECONFIG_CLUSTER - Reconfigure a cluster following a node failure

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine tries to reconfigure a cluster following a connection failure.
;	This implements a fast and simple scheme that works only if a failure involves
;	all connections to a failed set of nodes.  A second scheme is necessary to
;	deal with the more complicated case of random connection failures.
;
; CALLING SEQUENCE:
;
;	JSB	RECONFIG_CLUSTER
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

RECONFIG_CLUSTER:
	BSBW	INIT_TRANSITION		; Initialization for becoming coordinator
	MOVB	#CLMCNX$K_XTN_RECONFIG, - ; RECONFIGure transaction
		CLUB$B_CUR_CODE(R4)
	CLRL	R5			; No CSB address
	MOVAB	RECONFIG_MSG,R0		; Initiating cluster reconfiguration message
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
	BSBW	CNX$SCAN_CSBS
	BLBC	R0,30$			; Branch when done
	BBC	#CSB$V_MEMBER, -	; Ignore nodes that are not members of
		CSB$L_STATUS(R3),10$	;   the local cluster
	BBS	#CSB$V_LONG_BREAK, -	; Ignore nodes with whom the connection
		CSB$L_STATUS(R3),10$	;   is irrevocably broken
	BBCS	#CSB$V_SELECTED, -	; Mark node selected
		CSB$L_STATUS(R3),10$
10$:	RSB

30$:
;
; Selected nodes are those proposed for the members of the reconfigured
; cluster.
;
	BSBW	LOCK_NODES		; Attempt to lock selected nodes

RECONFIG_LOCKED:
;
; Now, exchange topology messages with all member nodes
;
	CLRW	CLUB$W_MSGCNT(R4)	; Initialize waiting count
	MOVB	#CLMCNX$K_DATA, -	; Mark this as Phase 1
		CLUB$B_CUR_PHASE(R4)
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,90$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),40$
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),40$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if connection is
		CSB$L_STATUS(R3),40$	;   permanently broken
	BSBW	CNX$ALLOC_WARMCDRP_CSB
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,50$			; No memory available
	INCW	CLUB$W_MSGCNT(R4)	; Include in wait count
	BSBB	60$			; Describe nodes
	BRW	CNX$SCAN_CSBS_FORK	; Fork and continue scan

40$:	RSB				; Return and continue scan

50$:	BRW	CNX$SCAN_CSBS_RETRY	; Delay and resume scan

;
; Send topology message to one node
;
60$:	MOVZBL	#CLMCNX$K_FNC_TOPOLOGY,R0 ; Message code
	BSBW	INIT_STD_MSG		; Standard CDRP message initialization
	MOVAB	W^BLD_TOPOLOGY_MSG, -	; Address of routine to build
		CDRP$L_MSGBLD(R5)	;  topology message
	BSBW	CNX$SEND_MSG_CSB	; Send message
;
;	We are resumed here when the response message arrives.
;	Registers contain:
;		R0:	Status
;		R2:	Address of message buffer
;		R3:	Address of CSB
;		R4:	Address of PDT
;		R5:	Address of CDRP
;
	BLBC	R0,80$			; Branch on no data received
	PUSHR	#^M<R0,R2,R3,R4,R5>	; Save registers
	MOVC3	#CSB$S_NODEMAP, -	; Fill in connectivity in sending node's
		CLMTOP$B_NODEMAP(R2), -	;   CSB
		CSB$B_NODEMAP(R3)
	POPR	#^M<R0,R2,R3,R4,R5>	; Restore registers
80$:	BSBW	CNX$PROCESS_RESPONSE	; Deallocate storage
;
; terminate threads -- except for the last one
;
90$:	DECW	CLUB$W_MSGCNT(R4)
	BLSS	100$			; Branch when done
	RSB				; Terminate thread

100$:	BSBW	CNX$CHECK_UNLOCK	; Handle a pending unlock request

RECONFIG_PROPOSE:
;
; Get here when all nodes in the proposed new cluster have been locked.
; Compute and send Phase 1 proposal messages.
;
	BSBW	CNX$OPT_INIT		; Compute optimal subcluster
	BLBC	R0,25$			; Can't compute (no pool?)
	BSBW	CNX$SCAN_CSBS		; Scan all CSB's
	BLBC	R0,20$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),10$
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID index of CSB
	BBS	R0, -			; Node is in computed subcluster
		CLUB$B_NODEMAP(R4),10$	; 
	BBCC	#CSB$V_SELECTED, -	; De-select node not in computed cluster
		CSB$L_STATUS(R3),10$
10$:	RSB				; Return and resume scan

20$:
	BSBW	CNX$DIRVEC_ADJ		; Adjust size of lock manager directory vector
	BLBS	R0,30$			; Branch on success
25$:	BRW	UNLOCK_ALL

30$:	BSBW	CNX$QUORUM_CALC		; Calculate and store quorum related parameters
;
; Propose cluster -- Send Phase 1 Messages
;
	MOVZBL	#CLMCNX$K_FNC_RECONFIG, - ; Message code
		CLUB$L_CTX0(R4)
	MOVAB	W^BLD_RECONFIG_MSG, -	; Address of routine to build
		CLUB$L_CTX1(R4)		;  status message
	BSBW	SEND_PH1		; Send phase 1 messages
;
; All nodes have seen Phase 1 and ACKed it.
; Now is the time to send Phase 2.
;
	BRW	SEND_PH2
;
; At the completion of sending Phase 2 messages, this location
; is executed as a thread.
;
RECONFIG_FINISH:
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,30$			; Branch when scan is done
	BBC	#CSB$V_SELECTED, -	; Branch if node not selected
		CSB$L_STATUS(R3),20$
	MOVL	#CSB$S_NODEMAP-1,R0	; Byte count of nodemap
10$:	MCOMB	CLUB$B_NODEMAP(R4)[R0],R2
	BICB2	R2,CSB$B_NODEMAP(R3)[R0] ; CSB = CSB & CLUB
	SOBGEQ	R0,10$
20$:	RSB

30$:	BSBW	UPDATE_QUORUM		; Update quorum, votes, nodes
;
; Handle bookkeeping for removed nodes.
;
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,60$			; Branch when done
	BBS	#CSB$V_SELECTED, -	; Branch if CSB selected -
		CSB$L_STATUS(R3),40$	;   still a cluster member
	BBC	#CSB$V_MEMBER, -	; Branch if not a cluster member
		CSB$L_STATUS(R3),50$
	BSBW	REMOVE_NODE		; Mark the node out of the cluster
	BRB	50$			; Branch to common exit

40$:	BSBW	CNX$MARK_UNLOCKED	; Mark node unlocked
50$:	RSB				; Continue scan

60$:
;
; Recompute value of CLUB$V_LOST_CNX
;
	BBCC	#CLUB$V_LOST_CNX, -	; Clear bit prior to recomputing its
		CLUB$L_FLAGS(R4),70$
70$:	BSBW	CNX$SCAN_CSBS		; Iterate over CSBs
	BLBC	R0,220$			; Branch when scan is done
	BBC	#CSB$V_MEMBER, -	; Branch if node is not a cluster member
		CSB$L_STATUS(R3), 210$
	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break has happened
		CSB$L_STATUS(R3),210$
	BBSS	#CLUB$V_LOST_CNX, -	; Mark cluster connection lost
		CLUB$L_FLAGS(R4),210$
210$:	RSB

220$:	BSBW	CNX$DIRVEC_FILL		; Recompute lock manager directory vector
	INCW	CLUB$W_MEMSEQ(R4)	; Advance membership state sequence number
	BSBW	CNX$MEMBERSHIP_CHANGE	; Begin table processing to remove nodes
	BRW	UNLOCK_ALL		; Make sure everything is unlocked

	.SBTTL	JOIN_CLUSTER - Try to join a cluster

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by a newly booted node that decides to
;	request membership in a cluster.
;
; CALLING SEQUENCE:
;
;	JSB	JOIN_CLUSTER
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

JOIN_CLUSTER:
	CLRL	R5			; Will hold CSB address on return
	BSBW	CNX$SCAN_CSBS		; Examine all CSBs
	BLBC	R0,20$			; Branch when done
	BBC	#CSB$V_STATUS_RCVD, -	; Ignore nodes that haven't sent
		CSB$L_STATUS(R3),10$	;   status
	BBC	#CSB$V_CLUSTER, -	; Ignore non-cluster members
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LONG_BREAK, -	; Ignore nodes with whom the connection
		CSB$L_STATUS(R3),10$	;   is broken
	MOVL	R3,R5
	BRW	CNX$SCAN_CSBS_EXIT	; Return CSB address of cluster member

10$:	RSB

20$:	MOVL	R5,R3			; CSB address of node to apply to
	BEQL	50$			; No node to apply to at this time
	BBS	#CSB$V_SHUTDOWN, -	; Branch if node in shutdown mode
		CSB$L_STATUS(R3),50$
	BBS	#CSB$V_SEND_STATUS, -	; Branch if status not yet queued
		CSB$L_STATUS(R3),50$	;   for transmission
	BSBW	CNX$ALLOC_CDRP_ONLY	; Get a CDRP
	BLBC	R0,50$			; No memory available
	MOVL	CSB$L_CLUB(R3),R4	; CLUB address
	MOVB	#CLMCNX$K_XTN_JOIN, -	; Transition identifier
		CLUB$B_CUR_CODE(R4)
	MOVZBL	#CLMCNX$K_FNC_ENTER,R0	; Facility specific message code
	BSBW	INIT_STD_MSG		; Standard CDRP message initialization
	BSBW	CNX$SEND_FORGET		; Send message and forget it
	MOVL	R3,R5			; Address of CSB
	MOVAB	REQJOIN_MSG,R0		; Requesting cluster membership
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
50$:	BRW	START_LONG_TIMEOUT

	.SBTTL	CNX$RCVD_ENTER - Received a cluster membership request

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a cluster membership request is received.
;	If the request looks valid, the protocol for adding a node to a cluster
;	is executed.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_ENTER
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

CNX$RCVD_ENTER::
	BSBW	CNX$DEALL_MSG_BUF_CSB	; Deallocate the message buffer
	MOVL	R3,R5			; Address of CSB
	MOVAB	MEMREQ_MSG,R0		; Address of message block
	BSBW	CNX$CONFIG_CHANGE	; Received cluster membership request
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	BITL	#< -			; Check for:
		  CLUB$M_TRANSITION ! -	;   Transition in progress
		  CLUB$M_LOST_CNX ! -	;   Node addition inhibited
		  CLUB$M_SHUTDOWN>, -	;   Shutdown in progress
		CLUB$L_FLAGS(R4)
	BNEQ	20$			; Branch to ignore request
	BBC	#CLUB$V_CLUSTER, -	; Branch if this node is not a cluster
		CLUB$L_FLAGS(R4), 20$	;   member
	BITL	#< -			; Check for:
		  CSB$M_SEND_STATUS ! -	;   Requestor is out of date
		  CSB$M_MEMBER ! -	;   Requestor already a cluster member
		  CSB$M_LONG_BREAK ! -	;   Connection problem to requestor *** why?
		  CSB$M_REMOVED>, -	;   Requestor removed from cluster
		CSB$L_STATUS(R3)
	BNEQ	20$			; Branch to ignore request
	BBC	#CSB$V_STATUS_RCVD, -	; Branch if we don't have info on
		CSB$L_STATUS(R3), 20$	;   the requestor
	MOVL	R3,CLUB$L_CTX0(R4)	; Save joining node CSB address
;
; The following piece of code assumes that CNX$SCAN_CSBS returns CSBs in order of
; increasing system ID.
;
	MOVL	#1,R5			; Assume local node has lowest System ID
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,30$			; Must have found something
	BBC	#CSB$V_MEMBER, -	; Branch if CSB is not for a member
		CSB$L_STATUS(R3),20$
	BBS	#CSB$V_LOCAL, -		; Branch if not local CSB
		CSB$L_STATUS(R3),10$
	CLRL	R5			; Local node is not lowest system ID
10$:	BRW	CNX$SCAN_CSBS_EXIT

20$:	RSB

30$:	BLBC	R5,20$			; If this is not the right node, drop thread
;
; Here, the transition to add the node begins
;
	MOVB	#CLMCNX$K_XTN_JOIN, -	; JOIN transaction
		CLUB$B_CUR_CODE(R4)
	BSBW	INIT_TRANSITION		; Initialization for becoming coordinator
	MOVL	CLUB$L_CTX0(R4),R5	; CSB of joining node
	MOVAB	JOIN_MSG,R0		; Initiating addition of system to cluster
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0, 60$			; Branch when done
	BBC	#CSB$V_MEMBER, -	; Branch if not a cluster member
		CSB$L_STATUS(R3), 50$
	BBSS	#CSB$V_SELECTED, -	; Select member nodes
		CSB$L_STATUS(R3), 50$
50$:	RSB

60$:	MOVL	CLUB$L_CTX0(R4),R3	; CSB address of joining node
	BISL2	#CSB$M_SELECTED, -	; Mark joining node selected
		CSB$L_STATUS(R3)
	BSBW	CNX$QUORUM_CALC		; Calculate quorum related parameters
	CMPL	R0,R1			; Votes >= quorum?
	BGEQU	80$			; Branch if yes
	CMPW	CLUB$W_VOTES(R4), -	; Is there currently a quorum present?
		CLUB$W_QUORUM(R4)
	BLSSU	80$			; Branch if yes, don't undo quorum by adding node
70$:	BRW	UNLOCK_ALL		; Abort transition

80$:	BSBW	CNX$ASSIGN_CSID		; Assign a CSID
	BLBC	R0,70$			; Branch on failure

	BSBW	LOCK_NODES		; Attempt to lock selected nodes

JOIN_LOCKED:

	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	CLRW	CLUB$W_MSGCNT(R4)	; Count of responses to wait for
;
; Describe all member nodes to joining system
;
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,30$			; Branch when all systems described
	BBC	#CSB$V_SELECTED, -	; Branch if node not selected
		CSB$L_STATUS(R3),10$
	BBS	#CLUB$V_UNLOCK, -	; Branch if unlock requested
		CLUB$L_FLAGS(R4),15$	;   and abandon this transition
	BSBW	CNX$ALLOC_CDRP_ONLY	; Get a fork block
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,20$			; No memory available
	PUSHL	R3			; Save scan context
	MOVL	R3,R2			; CSB of node to describe
	MOVL	CLUB$L_CTX0(R4),R3	; Address of joining node CSB
	INCW	CLUB$W_MSGCNT(R4)	; Increment waiting count
	BSBB	60$			; Provide immediate return address
	POPR	#^M<R3>			; Restore scanning context
	BRW	CNX$SCAN_CSBS_FORK	; Fork and resume scan

10$:	RSB

15$:	BRW	CNX$SCAN_CSBS_EXIT	; Exit from iteration

20$:	BRW	CNX$SCAN_CSBS_RETRY	; Wait and resume scan

;
; Describe joining system to all member systems
;
30$:	BSBW	CNX$SCAN_CSBS		; Scan all CSBs
	BLBC	R0,130$			; Branch if scan done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),40$
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),40$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if connection permanently
		CSB$L_STATUS(R3),40$	;   broken
	BSBW	CNX$ALLOC_CDRP_ONLY	; Get a fork block
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,50$			; No memory available
	MOVL	CLUB$L_CTX0(R4),R2	; Address of joining node CSB
	INCW	CLUB$W_MSGCNT(R4)	; Increment waiting count
	BSBB	60$			; Describe nodes
	BRW	CNX$SCAN_CSBS_FORK	; Fork and resume scan

40$:	RSB

50$:	BRW	CNX$SCAN_CSBS_RETRY	; Wait and resume scan

60$:	BSBW	DESCRIBE_NODE		; Tell one node about another
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	BLBC	R0,70$			; Error sending message
	BLBS	R1,80$			; Branch if node is known
70$:	BBSS	#CLUB$V_UNLOCK, -	; Request that all be unlocked
		CLUB$L_FLAGS(R4),80$
80$:	MOVL	R5,R0
	JSB	G^EXE$DEANONPAGED
;
; terminate threads -- except for the last one
;
130$:	DECW	CLUB$W_MSGCNT(R4)
	BLSS	140$			; Branch when done
	RSB				; Terminate thread

140$:	BSBW	CNX$CHECK_UNLOCK	; Handle unlock request
;
; Now give the new node the information it needs to fill in its
; Cluster vector.  The occupied slots will be taken care of in
; the normal course of events.  The available slots are given
; the value of the last sequence number used in this sequence
; of instructions.
;
	MOVZWL	G^CLU$GW_MAXINDEX,R3	; Number of vector slots
	BRB	240$

200$:	BSBW	CNX$CLUB_WAIT		; Wait a second, saving only R3
210$:	MOVL	G^CLU$GL_CLUSVEC,R1	; Address of cluster vector
	TSTL	(R1)[R3]		; Contents of first slot
	BLSS	240$			; Found CSB -- slot in use
	BSBW	CNX$CLUB_FORK		; Release control
	BSBW	CNX$CHECK_UNLOCK	; Bail out if unlock has been requested
	BSBW	CNX$ALLOC_CDRP_ONLY	; Get a fork block
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,200$			; Branch if CDRP allocated
	PUSHL	R3			; Save scan context
	MOVL	CLUB$L_CTX0(R4),R3	; Address of joining node CSB
	MOVZBL	#CLMCNX$K_FNC_VEC,R0	; Cluster vector description
	BSBW	INIT_STD_MSG		; Standard message initialization
	MOVAB	W^BLD_VEC_MSG, -	; Vector message building routine
		CDRP$L_MSGBLD(R5)
	MOVL	(SP),CDRP$L_VAL8(R5)	; Store Cluster vector index
	BSBW	CNX$SEND_FORGET		; Queue message and forget it
	POPR	#^M<R3>			; Restore context for scanning
240$:	SOBGEQ	R3,210$			; Iterate over all slots
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
;
; Get here when all nodes have been described to all others
; Now have told every node about every other node and each node's
; CSB contains a map of nodes that can be seen
;
JOIN_PROPOSE:
	MOVC5	#0,(SP),#0, -		; Init map of nodes that are
		#CLUB$S_NODEMAP, -	;   totally connected
		CLUB$B_NODEMAP(R4)
	BSBW	CNX$SCAN_CSBS		; Scan all CSB's
	BLBC	R0,240$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),210$
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID index of CSB
	BBSS	R0,CLUB$B_NODEMAP(R4), - ; Node is part of proposed cluster
		210$
210$:	RSB				; Return and resume scan

240$:
	BSBW	CNX$DIRVEC_ADJ		; Adjust size of lock manager directory vector
	BLBS	R0,250$			; Branch on success
	BRW	UNLOCK_ALL		; Can't adjust vector size, abort
250$:
;
; Propose cluster -- Send Phase 1 Messages
;
	MOVZBL	#CLMCNX$K_FNC_JOIN, -	; Facility specific message code
		CLUB$L_CTX0(R4)
	MOVAB	W^BLD_JOIN_MSG, -	; Address of routine to build
		CLUB$L_CTX1(R4)		;  status message
	BSBW	SEND_PH1		; Send phase 1 messages
;
; All nodes have seen Phase 1 and ACKed it.
; Now is the time to send Phase 2.
;
	BRW	SEND_PH2
;
; At the completion of sending Phase 2 messages, this location
; is executed as a thread.
;
JOIN_FINISH:
FORM_JOIN_FINISH:
	MOVL	CLUB$L_LOCAL_CSB(R4),R2	; Local node CSB
	MOVC3	#CSB$S_NODEMAP, -	; Copy membership map from CLUB
		CLUB$B_NODEMAP(R4), -	;   to local node's CSB
		CSB$B_NODEMAP(R2)
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,20$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LOCAL, -		; Branch if local node
		CSB$L_STATUS(R3),10$
	PUSHR	#^M<R3,R4>		; Save registers
	MOVC3	#CSB$S_NODEMAP, -	; Copy membership map from CLUB
		CLUB$B_NODEMAP(R4), -	;   to selected node's CSB
		CSB$B_NODEMAP(R3)
	POPR	#^M<R3,R4>		; Restore registers
	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break
		CSB$L_STATUS(R3),10$
	MOVL	CLUB$L_LOCAL_CSB(R4),R2	; Get local CSB address
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; Remote node CSID index
	BBCC	R0,CSB$B_NODEMAP(R2),10$ ; Mark connection broken
10$:	RSB

20$:	BSBW	CNX$FIX_EPID		; Add node ID to EPIDs
	BSBW	UPDATE_QUORUM		; Update quorum, votes, nodes
	BSBW	CNX$SCAN_CSBS		; Iterate over CSBs
	BLBC	R0,60$			; Branch when scan is done
	BBC	#CSB$V_SELECTED, -	; Branch if CSB not selected
		CSB$L_STATUS(R3),40$
	BBS	#CSB$V_MEMBER, -	; Skip if node is already a member
		CSB$L_STATUS(R3),30$
	BSBW	ADD_NODE
	BBC	#CSB$V_LOCAL, -		; Branch if not local node
		CSB$L_STATUS(R3),30$	;   and skip outputting message
	MOVL	R3,R5			; Address of CSB
	MOVAB	ADDNODE_MSG,R0		; Node added to cluster message
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
30$:	BSBW	CNX$MARK_UNLOCKED	; Mark the CSB unlocked
	BRB	50$

40$:	BBS	#CSB$V_MEMBER, -	; Branch on error case of non-selected
		CSB$L_STATUS(R3),100$	;   member
50$:	RSB

60$:	BSBW	CNX$DIRVEC_FILL		; Update contents of lock manager directory vector
	INCW	CLUB$W_MEMSEQ(R4)	; Advance membership state sequence number
;
; Add local node to cluster
;
	BBSS	#CLUB$V_CLUSTER, -	; Mark node a cluster member and
		CLUB$L_FLAGS(R4),90$	;   branch if a member already
	BISL2	#CLUB$M_QUORUM, -	; New nodes assume a quorum
		CLUB$L_FLAGS(R4)
	BBCC	#CLUB$V_NO_FORM, -	; Clear formation inhibit bit
		CLUB$L_FLAGS(R4),90$
90$:	BSBW	CNX$MEMBERSHIP_CHANGE	; Do processing for adding a node
	BRW	UNLOCK_ALL		; Make sure all nodes are unlocked

100$:	BUG_CHECK	CNXMGRERR,FATAL	; Consistency check -- unselected node is member

	.SBTTL	ADJUST_QUORUM - Adjust Cluster Quorum and/or Quorum Disk Membership

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine adjusts the cluster quorum and/or changes quorum disk membership.
;	This is done in a synchronized manner using a 2 phase protocol.
;
; CALLING SEQUENCE:
;
;	JSB	ADJUST_QUORUM
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

ADJUST_QUORUM:
	BSBW	INIT_TRANSITION		; Initialization for becoming coordinator
	MOVB	#CLMCNX$K_XTN_QUORUM, - ; RECONFIGure transaction
		CLUB$B_CUR_CODE(R4)
	CLRL	R5			; No CSB address
	MOVAB	QUORUM_MSG,R0		; Initiating cluster reconfiguration message
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
	BSBW	CNX$SCAN_CSBS
	BLBC	R0,20$			; Branch when done
	BBC	#CSB$V_MEMBER, -	; Ignore nodes that are not members of
		CSB$L_STATUS(R3),10$	;   the local cluster
	BBCS	#CSB$V_SELECTED, -	; Mark node selected
		CSB$L_STATUS(R3),10$
10$:	RSB

20$:
;
; Selected nodes are all members of the cluster.
;
	BSBW	LOCK_NODES		; Attempt to lock selected nodes
;
; Get here when all nodes in the cluster have been locked.
; Compute and send Phase 1 proposal messages.
;
	BSBW	CNX$QUORUM_CALC		; Calculate and store quorum related parameters
					; R0 is computed number of votes
	BBC	#CLUB$V_ADJ_QUORUM, -	; Branch if no quorum adjustment requested
		CLUB$L_FLAGS(R4),60$
	MOVW	CLUB$W_ADJ_QUORUM(R4), - ; Copy proposed value to new cell
		CLUB$W_NEWQUORUM(R4)
	CMPW	CLUB$W_ADJ_QUORUM(R4),R0 ; Minimize value with number of votes
	BLSSU	30$			; Branch if new value would
	MOVW	R0,CLUB$W_NEWQUORUM(R4)	; Use current number of votes
30$:	ADDL2	#2,R0			; Compute (votes+2)/2
	DIVL2	#2,R0
	CMPW	CLUB$W_NEWQUORUM(R4),R0	; New quorum >= (votes+2)/2?
	BGEQU	40$			; Branch if yes
	MOVW	R0,CLUB$W_NEWQUORUM(R4)
40$:
60$:
;
; Propose cluster -- Send Phase 1 Messages
;
	MOVZBL	#CLMCNX$K_FNC_QUORUM, - ; Message code
		CLUB$L_CTX0(R4)
	MOVAB	W^BLD_QUORUM_MSG, -	; Address of routine to build
		CLUB$L_CTX1(R4)		;  status message
	BSBW	SEND_PH1		; Send phase 1 messages
;
; Phase 1 has been sent.  Nothing can stop us now short of our own
; failure.  Therefore, it is time to clear the bit requesting the
; quorum adjustment.  This node has done its best...
;
	BBCC	#CLUB$V_ADJ_QUORUM, -	; Clear quorum adjustment flag
		CLUB$L_FLAGS(R4),100$
100$:
;
; All nodes have seen Phase 1 and ACKed it.
; Now is the time to send Phase 2.
;
	BRW	SEND_PH2
;
; At the completion of sending Phase 2 messages, this location
; is executed as a thread.
;
QUORUM_FINISH:
	BSBW	UPDATE_QUORUM		; Update quorum, votes, nodes
;
; Reduce quorum in CSB's to prevent cluster quorum from ratcheting right
; back up with the next state transition
;
	BSBW	CNX$SCAN_CSBS		; Iterate over CSBs
	BLBC	R0,230$			; Branch when scan is done
	BBC	#CSB$V_MEMBER, -	; Branch if node is cluster member
		CSB$L_STATUS(R3), 220$
	CMPW	CSB$W_QUORUM(R3), -	; Compare sysgen parameter with current
		CLUB$W_QUORUM(R4)	;   cluster quorum
	BLEQU	210$			; Branch if less than cluster quorum
	MOVW	CLUB$W_QUORUM(R4), -	; Lower copy of sysgen parameter to match
		CSB$W_QUORUM(R3)	;   new, reduced cluster quorum
210$:	BSBW	CNX$MARK_UNLOCKED	; Mark node no longer locked
220$:	RSB				; Continue iteration

230$:	BRW	UNLOCK_ALL		; Make sure everything is unlocked

	.SBTTL	INIT_TRANSITION - Initialization for a transition

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is the common initialization code for all
;	transitions.  It is executed by any node which is attempting
;	to become the coordinator.
;
; CALLING SEQUENCE:
;
;	JSB	INIT_TRANSITION
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R3:	Address of local CSB
;	R4:	Address of CLUB
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R2,R5 are destroyed
;
;--

INIT_TRANSITION:
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	BISL2	#CLUB$M_TRANSITION, -	; Mark transition started
		CLUB$L_FLAGS(R4)
	CLRL	CLUB$L_TQE(R4)		; Abandon any timeout in progress
	MOVAB	CLUB$B_FORK_BLOCK(R4),R0 ; Address of transition fork block
	BBCC	#CLUBFKB$V_FKB_BUSY, -	; Branch if fork block is not
		CLUBFKB$L_STATUS(R0),10$ ;  busy and mark no busy
	REMQUE	CLUBFKB$B_FORK_BLOCK(R0),R0 ; Remove from queue
10$:	BICL2	#CLUB$M_UNLOCK, -	; Clear unlock request
		CLUB$L_FLAGS(R4)
20$:	INCL	CLUB$L_MAX_XTN(R4)	; Compute transaction ID
	BEQL	20$			; Disallow transition 0
	MOVL	CLUB$L_MAX_XTN(R4), -
		CLUB$L_CUR_XTN(R4)
	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; CSB for this node
	MOVL	CSB$L_CSID(R3), -	; CSID of coordinator
		CLUB$L_CUR_COORD(R4)
	MOVL	R3,CLUB$L_COORD(R4)	; Mark this node the coordinator
	MOVB	#CLMCNX$K_LOCK, -	; Set transaction phase
		CLUB$B_CUR_PHASE(R4)
	MOVQ	G^EXE$GQ_SYSTIME, -	; Current time is timestamp for
		CLUB$Q_CUR_TIME(R4)	;   this transition
	MOVW	CLUB$W_FIRST_INDEX(R4), - ; Initialize CSID allocation context
		CLUB$W_NEXT_CSID(R4)
	BSBW	CNX$INIT_CSBS		; Initialize CSBs for transition
	BBCS	#CSB$V_SELECTED, -	; Mark local node selected
		CSB$L_STATUS(R3),30$
30$:	RSB

	.SBTTL	BLD_FORM_MSG - Build Message Proposing a New Cluster
	.SBTTL	BLD_RECONFIG_MSG - Build Message Proposing a Reconfigured Cluster
	.SBTTL	BLD_JOIN_MSG - Build Message Proposing a New Node in a Cluster
	.SBTTL	BLD_QUORUM_MSG - Build Message Proposing a Quorum/Quorum Disk Chanage
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds a message proposing the formation, reconfiguration, or
;	addition of a node to a cluster.
;	It uses the standard message building routine to build the message header.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_FORM_MSG
;	JSB	BLD_RECONFIG_MSG
;	JSB	BLD_JOIN_MSG
;	JSB	BLD_QUORUM_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;		CDRP$L_VAL1(R5): Byte 0 contains facility code (negated for response)
;				 Byte 1 contains facility specific function code
;		CDRP$L_VAL2(R5): Transition ID (from CLUB$L_CUR_XTN)
;		CDRP$L_VAL3(R5): Byte 0 contains transition phase (from CLUB$B_CUR_PHASE)
;				 Byte 1 contains transition code (from CLUB$B_XTN_CODE)
;				 Byte 2 contains success/failure flag
;				 Byte 3 contains reply code
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BLD_FORM_MSG:
BLD_RECONFIG_MSG:
BLD_JOIN_MSG:
BLD_QUORUM_MSG:
	BSBW	BLD_STD_MSG		; Fill in standard fields
	PUSHR	#^M<R2,R3,R4,R5,R6>	; Save registers
	MOVL	CSB$L_CLUB(R3),R6	; Address of CLUB
	MOVW	CLUB$W_NEXT_CSID(R6), -	; Save CSID assignment context
		CLMPRO$W_NEXT_CSID(R2)
	MOVW	CLUB$W_NEWQUORUM(R6), -	; Cluster quorum
		CLMPRO$W_QUORUM(R2)
	MOVW	CLUB$W_MEMSEQ(R6), -	; Cluster membership state sequence
		CLMPRO$W_MEMSEQ(R2)	;   number
	MOVL	CLUB$L_FMERIT(R6), -	; Proposed cluster figure of merit
		CLMPRO$L_FMERIT(R2)
	MOVQ	CLUB$Q_FTIME(R6), -	; Cluster founding time
		CLMPRO$Q_FTIME(R2)
	MOVQ	G^EXE$GQ_SYSTIME, -	; Store current system time in
		CLMPRO$Q_CURTIME(R2)	;   the message
	MOVW	CLUB$W_NEWQDVOTES(R6), -	; Quorum disk votes
		CLMPRO$W_QDVOTES(R2)
	CLRB	CLMPRO$B_FLAGS(R2)	; Zero flags byte
	BBC	#CLUB$V_QF_NEWVOTE, -	; Branch if quorum disk not part of
		CLUB$L_FLAGS(R6),10$
	BISB	#CLMPRO$M_QF_VOTE, -	; Mark quorum disk present
		CLMPRO$B_FLAGS(R2)
10$:	MOVC3	#CLMPRO$S_FSYSID, -	; Cluster founding system
		CLUB$B_FSYSID(R6), -
		CLMPRO$B_FSYSID(R2)
	MOVL	(SP),R2			; Restore message buffer address
	MOVC3	#CLMPRO$S_NODEMAP, -	; Fill map of proposed systems
		CLUB$B_NODEMAP(R6), -
		CLMPRO$B_NODEMAP(R2)
	POPR	#^M<R2,R3,R4,R5,R6>	; Restore registers
	RSB

	.SBTTL	CNX$RCVD_FORM - Cluster formation proposal received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called cluster formation proposal message is received.
;	A response must be sent which ACKs or NAKs the request.  The
;	request is NAKd if this node does not have a connection to all proposed
;	member nodes.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_FORM
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_FORM::
	PUSHR	#^M<R2,R3,R5>		; Save needed registers
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVL	(SP),R2			; Restore message address
	BSBW	MSG_CHECK		; Validate message
	MOVW	CLMPRO$W_NEXT_CSID(R2), - ; Save CSID assignment context
		CLUB$W_NEXT_CSID(R4)
	MOVW	CLMPRO$W_QUORUM(R2), -	; Cluster quorum
		CLUB$W_NEWQUORUM(R4)
	MOVW	CLMPRO$W_MEMSEQ(R2), -	; Cluster membership state sequence
		CLUB$W_MEMSEQ(R4)	;   number
	MOVL	CLMPRO$L_FMERIT(R2), -	; Proposed cluster figure of merit
		CLUB$L_FMERIT(R4)
	MOVQ	CLMPRO$Q_FTIME(R2), -	; Cluster foundation time
		CLUB$Q_FTIME(R4)
	MOVQ	CLMPRO$Q_CURTIME(R2), -	; Save time from message
		CLUB$Q_NEWTIME(R4)
	MOVW	CLMPRO$W_QDVOTES(R2), -	; Quorum disk votes
		CLUB$W_NEWQDVOTES(R4)
	BICL	#CLUB$M_QF_NEWVOTE, -	; Assume no quorum disk membership
		CLUB$L_FLAGS(R4)
	BBC	#CLMPRO$V_QF_VOTE, -	; Branch if no quorum disk membership
		CLMPRO$B_FLAGS(R2),10$
	CLRL	R1			; Assume failure
	BBC	#CLUB$V_QF_ACTIVE, -	; Branch if disk not locally active
		CLUB$L_FLAGS(R4),50$	;   and reject proposal
	BBSS	#CLUB$V_QF_NEWVOTE, -	; Set quorum disk membership
		CLUB$L_FLAGS(R4),10$
10$:	PUSHR	#^M<R2,R3,R4>		; Save registers
	MOVC3	#CLUB$S_FSYSID, -	; Cluster founding system ID
		CLMPRO$B_FSYSID(R2), -
		CLUB$B_FSYSID(R4)
	POPR	#^M<R2,R3,R4>		; Restore registers
	PUSHR	#^M<R2,R3,R4>		; Save registers
	MOVC3	#CLUB$S_NODEMAP, -	; Save map of cluster nodes
		CLMPRO$B_NODEMAP(R2), -	;   in CLUB
		CLUB$B_NODEMAP(R4)
	POPR	#^M<R2,R3,R4>		; Restore registers
	MOVQ	G^EXE$GQ_SYSTIME, -	; Save current system time
		CLUB$Q_NEWTIME_REF(R4)	;   as a reference
	MOVL	#1,R1			; Anticipate success
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,50$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if node not selected
		CSB$L_STATUS(R3),40$
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID index
	BBCC	R0, -			; Branch if node is not in proposed
		CLMPRO$B_NODEMAP(R2), -	;   cluster
		30$
	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break seen
		CSB$L_STATUS(R3),40$
	CLRL	R1
	BRW	CNX$SCAN_CSBS_EXIT	; Exit from CSB scanning loop

30$:	BBSC	#CSB$V_SELECTED, -	; Clear selected bit
		CSB$L_STATUS(R3),40$
40$:	RSB

50$:	PUSHL	R1			; Save status
	SKPC	#0,#CLMPRO$S_NODEMAP, -	; Look for any missing nodes
		CLMPRO$B_NODEMAP(R2)
	BEQL	60$			; All nodes accounted for
	BBC	#CLUB$V_UNLOCK, -	; Branch if no unlock request
		CLUB$L_FLAGS(R4), 60$	;   pending
	CLRL	(SP)			; NAK request
60$:	BLBC	(SP),70$		; Branch on NAK pending
	BSBW	CNX$DIRVEC_ADJ		; Adjust size of lock manager directory vector
	BLBS	R0,70$			; Branch on success
	MOVL	R0,(SP)			; Make sure proposal is NAKed
70$:	POPR	#^M<R0,R2,R3,R5>	; Restore needed registers
	PUSHL	R0			; Save status
	MOVZBL	#CLMCNX$K_FNC_FORM,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	CVTLB	(SP)+,CDRP$L_VAL3+2(R5)	; Store success/failure flag
	BRW	CNX$RESP_FORGET		; Queue response message

	.SBTTL	CNX$RCVD_RECONFIG - Cluster Reconfiguration proposal received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a cluster reconfiguration proposal
;	message is received.
;	A response must be sent which ACKs or NAKs the request.  The
;	request is NAKd if this node does not have a connection to exactly
;	the set of member nodes of the proposed reconfigured cluster.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_RECONFIG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_RECONFIG::
	PUSHR	#^M<R2,R3,R5>		; Save needed registers
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVQ	(SP),R2			; Restore message address
	BSBW	MSG_CHECK		; Validate message
	BISL2	#CLUB$M_LOST_CNX, -	; Mark connection to member lost
		CLUB$L_FLAGS(R4)
	MNEGB	#1,G^LCK$GB_STALLREQS	; Stall lock requests
	MOVL	CLMPRO$L_FMERIT(R2), -	; Proposed cluster figure of merit
		CLUB$L_FMERIT(R4)
	MOVC3	#CLMPRO$S_NODEMAP, -	; Save map of cluster nodes
		CLMPRO$B_NODEMAP(R2), -	;   in CLUB
		CLUB$B_NODEMAP(R4)

	MOVL	#1,R1			; Status indicator
	MOVL	(SP),R2			; Message buffer address
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,20$			; Branch when iteration is complete
	BBC	#CSB$V_MEMBER, -	; Branch if node is not a cluster member
		CSB$L_STATUS(R3),10$
	BISL2	#CSB$M_SELECTED, -	; Select every member
		CSB$L_STATUS(R3)
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; System index
	BBCC	R0, -			; Branch if member not in proposed cluster
		CLMPRO$B_NODEMAP(R2),10$
	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break seen
		CSB$L_STATUS(R3),10$
	CLRL	R1			; Force failure of proposal
10$:	RSB

20$:	BLBC	R1,25$			; Branch on previous decision to reject
	MOVW	CLMPRO$W_QUORUM(R2), -	; Store quorum
		CLUB$W_NEWQUORUM(R4)
	MOVW	CLMPRO$W_QDVOTES(R2), -	; Store quorum disk votes
		CLUB$W_NEWQDVOTES(R4)
	BICL	#CLUB$M_QF_NEWVOTE, -	; Assume no quorum disk membership
		CLUB$L_FLAGS(R4)
	BBC	#CLMPRO$V_QF_VOTE, -	; Branch if no quorum disk membership
		CLMPRO$B_FLAGS(R2),23$
	BBC	#CLUB$V_QF_ACTIVE, -	; Branch if disk not locally active
		CLUB$L_FLAGS(R4),24$	;   and reject proposal
	BBSS	#CLUB$V_QF_NEWVOTE, -	; Set quorum disk membership
		CLUB$L_FLAGS(R4),23$
23$:	BRB	25$

24$:	CLRL	R1			; Reject proposal
25$:	PUSHL	R1			; Save status return
	SKPC	#0,#CLMPRO$S_NODEMAP, -	; Look for any missing nodes
		CLMPRO$B_NODEMAP(R2)
	BEQL	30$			; All nodes accounted for
	BUG_CHECK	CNXMGRERR,FATAL	; Some non-member node proposed as member

30$:	BLBC	(SP),70$		; Reject proposal as inconsistent with local data
	BBS	#CLUB$V_UNLOCK, -	; Branch if unlock request
		CLUB$L_FLAGS(R4),60$	;   is pending
	BSBW	CNX$OPT			; Try to compute better subcluster
	BLBC	R0,40$			; Branch on computation failure
	BLBS	R1,60$			; Branch if a better cluster was computed
40$:	BSBW	CNX$DIRVEC_ADJ		; Adjust size of lock manager directory vector
	BLBC	R0,60$			; Branch on failure
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,70$			; Branch when iteration done
	BBC	#CSB$V_MEMBER, -	; Branch if system is not a member
		CSB$L_STATUS(R3),50$
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; System ID index
	BBS	R0,CLUB$B_NODEMAP(R4),50$ ; Branch if system is in proposed cluster
	BBCC	#CSB$V_SELECTED, -	; Clear selected bit
		CSB$L_STATUS(R3),50$
50$:	RSB				; End of iteration step

60$:	CLRL	(SP)			; Failure -- reject proposal
70$:	POPR	#^M<R0,R2,R3,R5>	; Restore status and needed registers
	PUSHL	R0			; Save status
	MOVZBL	#CLMCNX$K_FNC_RECONFIG,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	CVTLB	(SP)+,CDRP$L_VAL3+2(R5)	; Store success/failure flag
	BRW	CNX$RESP_FORGET		; Queue response message

	.SBTTL	CNX$RCVD_JOIN - Cluster node addition proposal received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called cluster node aaddition proposal message is received.
;	A response must be sent which ACKs or NAKs the request.  The
;	request is NAKd if this node does not have a connection to all proposed
;	member nodes.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_JOIN
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_JOIN::
	PUSHL	#0			; Anticipate NAK
	PUSHR	#^M<R2,R3,R5>		; Save needed registers
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVL	(SP),R2			; Restore message address
	BSBW	MSG_CHECK		; Validate message
	BBC	#CLUB$V_LOST_CNX, -	; Branch if node addition not inhibited
		CLUB$L_FLAGS(R4),10$
	BRW	70$			; Helper branch when node addition inhibited
10$:	MOVW	CLMPRO$W_NEXT_CSID(R2), - ; Save CSID assignment context
		CLUB$W_NEXT_CSID(R4)
	MOVW	CLMPRO$W_MEMSEQ(R2), -	; Cluster membership state sequence
		CLUB$W_MEMSEQ(R4)	;   number
	BBS	#CLUB$V_CLUSTER, -	; Branch if node is already a cluster member
		CLUB$L_FLAGS(R4),30$
;
; Receiving node is not cluster member
;
	MOVQ	CLMPRO$Q_FTIME(R2), -	; Cluster foundation time
		CLUB$Q_FTIME(R4)
	MOVQ	CLMPRO$Q_CURTIME(R2), -	; Save time from message
		CLUB$Q_NEWTIME(R4)
	MOVQ	G^EXE$GQ_SYSTIME, -	; Save current system time
		CLUB$Q_NEWTIME_REF(R4)	;   as a reference
	MOVC3	#CLUB$S_FSYSID, -	; Cluster founding system ID
		CLMPRO$B_FSYSID(R2), -
		CLUB$B_FSYSID(R4)
30$:	MOVQ	(SP),R2			; Restore registers
	MOVL	CSB$L_CLUB(R3),R4
	MOVW	CLMPRO$W_QDVOTES(R2), -	; Quorum disk votes
		CLUB$W_NEWQDVOTES(R4)
	MOVW	CLMPRO$W_QUORUM(R2), -	; Cluster quorum
		CLUB$W_NEWQUORUM(R4)
	BICL	#CLUB$M_QF_NEWVOTE, -	; Assume no quorum disk membership
		CLUB$L_FLAGS(R4)
	BBC	#CLMPRO$V_QF_VOTE, -	; Branch if no quorum disk membership
		CLMPRO$B_FLAGS(R2),35$
	CLRL	R1			; Assume failure
	BBC	#CLUB$V_QF_ACTIVE, -	; Branch if disk not locally active
		CLUB$L_FLAGS(R4),60$	;   and reject proposal
	BBSS	#CLUB$V_QF_NEWVOTE, -	; Set quorum disk membership
		CLUB$L_FLAGS(R4),35$
35$:	MOVC3	#CLUB$S_NODEMAP, -	; Save map of cluster nodes
		CLMPRO$B_NODEMAP(R2), -	;   in CLUB
		CLUB$B_NODEMAP(R4)
	MOVL	(SP),R2			; Restore message address
	MOVL	#1,R1			; Anticipate success
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,60$			; Branch when done
	BITL	#CSB$M_SELECTED ! -	; Check for SELECTED or
		 CSB$M_MEMBER, -	;   MEMBER
		CSB$L_STATUS(R3)
	BEQL	50$			; Branch and ignore if neither
	BISL2	#CSB$M_SELECTED, -	; Mark the node selected
		CSB$L_STATUS(R3)
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID index
	BBCC	R0, -			; Branch if node is not in proposed
		CLMPRO$B_NODEMAP(R2), -	;   cluster
		40$
	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break seen
		CSB$L_STATUS(R3),50$
	CLRL	R1			; Flag failure
	BRW	CNX$SCAN_CSBS_EXIT	; Exit from CSB scanning loop

40$:	BUG_CHECK	CNXMGRERR,FATAL	; Consistency check

50$:	RSB

60$:	MOVL	R1,12(SP)		; Save status
	BLBC	R1,70$			; Branch if NAK required
	SKPC	#0,#CLMPRO$S_NODEMAP, -	; Look for any missing nodes
		CLMPRO$B_NODEMAP(R2)
	BNEQ	40$			; Some node(s) is not accounted for
70$:	BLBC	12(SP),80$		; Branch on NAK pending
	BSBW	CNX$DIRVEC_ADJ		; Adjust size of lock manager directory vector
	BLBS	R0,80$			; Branch on success
	MOVL	R0,12(SP)		; Make sure proposal is NAKed
80$:	POPR	#^M<R2,R3,R5>		; Restore needed registers
	MOVZBL	#CLMCNX$K_FNC_JOIN,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	CVTLB	(SP)+,CDRP$L_VAL3+2(R5)	; Store success/failure flag
	BRW	CNX$RESP_FORGET		; Queue response message

	.SBTTL	CNX$RCVD_QUORUM  - Quorum Update Message Received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a quorum update request message is received.
;	This is a Phase 1 message.  The validity of the message is checked and
;	the new quorum value is saved in a temporary location.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_QUORUM
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_QUORUM::
	PUSHR	#^M<R2,R3,R5>		; Save needed registers
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVQ	(SP),R2			; Restore message address and CSB address
	BSBW	MSG_CHECK		; Validate message
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,20$			; Branch when done
	BBC	#CSB$V_MEMBER, -	; Branch if not a member node
		CSB$L_STATUS(R3),10$
	BBSS	#CSB$V_SELECTED, -	; Select each menber
		CSB$L_STATUS(R3),10$
10$:	RSB

20$:	MOVQ	(SP),R2			; Restore message buffer address
	MOVW	CLMPRO$W_QUORUM(R2), -	; Temporarily save new quorum value
		CLUB$W_NEWQUORUM(R4)
	MOVW	CLMPRO$W_QDVOTES(R2), -	; Quorum disk votes
		CLUB$W_NEWQDVOTES(R4)
	BICL	#CLUB$M_QF_NEWVOTE, -	; Assume no quorum disk membership
		CLUB$L_FLAGS(R4)
	MOVL	#1,R1			; Assume that we will accept proposal
	BBC	#CLMPRO$V_QF_VOTE, -	; Branch if no quorum disk membership
		CLMPRO$B_FLAGS(R2),30$
	CLRL	R1			; Assume failure
	BBC	#CLUB$V_QF_ACTIVE, -	; Branch if disk not locally active
		CLUB$L_FLAGS(R4),30$	;   and reject proposal
	MOVL	#1,R1			; Accept proposal
	BBSS	#CLUB$V_QF_NEWVOTE, -	; Set quorum disk membership
		CLUB$L_FLAGS(R4),30$
30$:	POPR	#^M<R2,R3,R5>		; Restore needed registers
	PUSHL	R1			; Save status
	MOVZBL	#CLMCNX$K_FNC_QUORUM,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	CVTLB	(SP)+,CDRP$L_VAL3+2(R5)	; Store success flag
	BRW	CNX$RESP_FORGET		; Send response message and forget it

	.SBTTL	BLD_VEC_MSG - Build Message Describing Vector Slot

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds a message describing an empty cluster vector slot.
;	This is needed in order to guarantee consistent, cluster-wide assignment
;	of unique CSIDs.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_VEC_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;		CDRP$L_VAL1(R5): Byte 0 contains facility code (negated for response)
;				 Byte 1 contains facility specific function code
;		CDRP$L_VAL2(R5): Transition ID (from CLUB$L_CUR_XTN)
;		CDRP$L_VAL3(R5): Byte 0 contains transition phase (from CLUB$B_CUR_PHASE)
;				 Byte 1 contains transition code (from CLUB$B_XTN_CODE)
;				 Byte 2 contains success/failure flag
;				 Byte 3 contains reply code
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BLD_VEC_MSG:
	BSBW	BLD_STD_MSG		; Fill in standard fields
	MOVL	CDRP$L_VAL8(R5),R0	; Slot index
	CVTLW	R0,CLMVEC$W_INDEX(R2)	; Store slot index
	MOVL	G^CLU$GL_CLUSVEC,R1	; Address of cluster vector
	MOVL	(R1)[R0],R0		; Get contents of slot
	BLSS	10$			; Branch if slot in use
	CVTLW	R0,CLMVEC$W_SEQUENCE(R2) ; Last sequence number used
	BVS	10$			; Branch on overflow
	RSB

10$:	BUG_CHECK	CNXMGRERR,FATAL	; Consistency check

	.SBTTL	CNX$RCVD_VEC - Cluster vector slot information received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a cluster vector slot description
;	is received.
;	No response or immediate acknowledgement is sent.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_VEC
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_VEC::
	BSBW	MSG_CHECK		; Validate message
	MOVL	G^CLU$GL_CLUSVEC,R0	; Address of cluster vector
	MOVZWL	CLMVEC$W_INDEX(R2),R1	; Slot index
	CMPW	R1,G^CLU$GW_MAXINDEX	; Valid index?
	BGEQU	10$			; Invalid index
	MOVZWL	CLMVEC$W_SEQUENCE(R2), - ; Store last used sequence number
		(R0)[R1]
	BSBW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer
	RSB				; Return

10$:	BUG_CHECK	CNXMGRERR,FATAL	; Consistency check

	.SBTTL	DESCRIBE_NODE - Describe one node to another node

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine tells one node about another node.  It returns
;	asynchronously with information indicating that the first
;	node can or cannot see the second node.
;
; CALLING SEQUENCE:
;
;	JSB	DESCRIBE_NODE
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R5 is address of a CDRP
;	R3 is CSB address of node to talk to
;	R2 is CSB address of node to describe
;
; OUTPUT PARAMETERS:
;
;	R5 is address of a CDRP
;	R3 is CSB address of node talked to
;	R2 is CSB address of node described
;
; COMPLETION CODES:
;
;	R0 indicates that a response was received from
;		the node vs. connection failed
;	R1 is status received from the node.
;
; SIDE EFFECTS:
;
;	CDRP$L_VAL1-CDRP$L_VAL5 are used for this routine's context.
;
;--

DESCRIBE_NODE:
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	MOVL	R2,CDRP$L_VAL4(R5)	; Node to describe
	POPL	CDRP$L_VAL5(R5)		; Return address
	MOVZBL	#CLMCNX$K_FNC_DESC,R0	; Message code
	BSBW	INIT_STD_MSG		; Do standard message initialization
	MOVL	#1,CDRP$L_RSPID(R5)	; Indicate that response is needed
	MOVAB	B^BLD_DESC_MSG, -	; Address of routine to build
		CDRP$L_MSGBLD(R5)	;  status message
	BSBW	CNX$SEND_MSG_CSB	; Send message
;
;	We are resumed here when the response message arrives.
;	Registers contain:
;		R0:	Status
;		R2:	Address of message buffer
;		R3:	Address of CSB
;		R4:	Address of PDT
;		R5:	Address of CDRP
;
	BLBC	R0,10$			; Error sending message
	MOVZBL	CLMCNX$B_ACK(R2),-(SP)	; Response from remote node
	PUSHL	R0			; Save return status
	BSBW	CNX$DEALL_MSG_BUF_CSB	; Release message buffer
	DEALLOC_RSPID			; Deallocate response ID
	POPR	#^M<R0,R1>		; Restore status and return ACK/NAK
10$:	MOVL	CDRP$L_VAL4(R5),R2	; Address of described CSB
	JMP	@CDRP$L_VAL5(R5)	; Return address

	.SBTTL	BLD_DESC_MSG - Build Message describing a node

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds a message describing a node.  It uses the
;	standard message building routine to build the message header.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_DESC_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;		CDRP$L_VAL1(R5): Byte 0 contains facility code (negated for response)
;				 Byte 1 contains facility specific function code
;		CDRP$L_VAL2(R5): Transition ID (from CLUB$L_CUR_XTN)
;		CDRP$L_VAL3(R5): Byte 0 contains transition phase (from CLUB$B_CUR_PHASE)
;				 Byte 1 contains transition code (from CLUB$B_XTN_CODE)
;				 Byte 2 contains success/failure flag
;				 Byte 3 contains reply code
;		CDRP$L_VAL4(R5): Address of CSB to describe
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BLD_DESC_MSG:
	BSBW	BLD_STD_MSG		; Fill in standard fields
	MOVL	CDRP$L_VAL4(R5),R0	; Address of CSB to describe
	MOVL	CSB$L_SB(R0),R1		; Address of SB of described system
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#CLMNOD$S_SYSTEMID, -	; Fill in described system ID
		SB$B_SYSTEMID(R1), -
		CLMNOD$B_SYSTEMID(R2)
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVQ	SB$Q_SWINCARN(R1), -	; Fill in described system
		CLMNOD$Q_SWINCARN(R2)	;   software incarnation number
	MOVL	CSB$L_CSID(R0), -	; Described system CSID
		CLMNOD$L_CSID(R2)
	RSB

	.SBTTL	CNX$RCVD_DESC  - Node description received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a node description message is received.
;	A response must be sent which ACKs or NAKs the request.  The
;	request is NAKd if this node does not have a connection.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_DESC
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_DESC::
	PUSHR	#^M<R2,R3,R5>		; Save needed registers
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVL	(SP),R2			; Restore message address
	BSBW	MSG_CHECK		; Validate message
	CLRL	R5			; Result CSB address
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,5$			; Branch when done
	MOVL	CSB$L_SB(R3),R0		; Address of System Block
	PUSHR	#^M<R2,R3>		; Save message buffer and CSB address
	CMPC3	#SB$S_SYSTEMID, -	; Compare System IDs
		SB$B_SYSTEMID(R0), -	;   between SB and
		CLMNOD$B_SYSTEMID(R2)	;   incoming message
	POPR	#^M<R2,R3>		; Restore message buffer and CSB address
	BNEQ	2$			; No match
	PUSHR	#^M<R2,R3>		; Save message buffer and CSB address
	MOVL	CSB$L_SB(R3),R0		; Address of System Block
;
; Use SWINCARN out of SB because local node's CSB doesn't contain a valid
; SWINCARN -- it was created and intialized before SWINCARN for the local node
; became meaningful.
;
	CMPC3	#SB$S_SWINCARN, -	; Compare software incarnation number
		SB$Q_SWINCARN(R0), -	;   between CSB and
		CLMNOD$Q_SWINCARN(R2)	;   incoming message
	POPR	#^M<R2,R3>		; Restore message buffer and CSB address
	BNEQ	2$			; No match
	MOVL	R3,R5			; Store result
	BRW	CNX$SCAN_CSBS_EXIT	; Exit iteration with result

2$:	RSB				; Return and iterate

5$:	MOVL	R5,R3			; CSB address of described node
	BEQL	25$			; Described node not found
	BBS	#CSB$V_LOCAL,-		; Branch if local CSB
		CSB$L_STATUS(R3),10$
	BBC	#CSB$V_STATUS_RCVD, -	; Branch if no status received
		CSB$L_STATUS(R3),20$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if long break seen
		CSB$L_STATUS(R3),20$	;   and NAK request
10$:	BISL2	#CSB$M_SELECTED, -	; Mark node SELECTED
		CSB$L_STATUS(R3)
	MOVL	CLMNOD$L_CSID(R2), -	; Save node identification
		CSB$L_CSID(R3)		;   for described node
	MOVL	#1,R0			; ACK node description
	BRB	30$
;
; The described node is unknown or no valid connection exists.
; Return a NAK.
;
20$:	BICL2	#CSB$M_SELECTED, -	; Mark node deSELECTED
		CSB$L_STATUS(R3)
25$:	CLRL	R0			; NAK node description
30$:	POPR	#^M<R2,R3,R5>		; Restore needed registers
	PUSHL	R0			; Save status
	MOVZBL	#CLMCNX$K_FNC_DESC,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	CVTLB	(SP)+,CDRP$L_VAL3+2(R5)	; Store success/failure flag
	BRW	CNX$RESP_FORGET		; Send response message and forget it

	.SBTTL	BLD_TOPOLOGY_MSG - Build Message Describing Cluster Topology

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds a message describing the connectivity of the cluster
;	as known to the local node.  The description is optimistic in that some
;	connections that are reported as good may in fact be bad.  The oppositve
;	cannot occur.  Information about the quorum disk is not passed in this
;	message.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_TOPOLOGY_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;		CDRP$L_VAL1(R5): Byte 0 contains facility code (negated for response)
;				 Byte 1 contains facility specific function code
;		CDRP$L_VAL2(R5): Transition ID (from CLUB$L_CUR_XTN)
;		CDRP$L_VAL3(R5): Byte 0 contains transition phase (from CLUB$B_CUR_PHASE)
;				 Byte 1 contains transition code (from CLUB$B_XTN_CODE)
;				 Byte 2 contains success/failure flag
;				 Byte 3 contains reply code
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BLD_TOPOLOGY_MSG:
	BSBW	BLD_STD_MSG		; Fill in standard fields
	MOVL	CSB$L_CLUB(R3),R0	; Get CLUB address
	MOVL	CLUB$L_LOCAL_CSB(R0),R1	; Local CSB Address
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC3	#CLMTOP$S_NODEMAP, -	; Copy data into message buffer
		CSB$B_NODEMAP(R1), -
		CLMTOP$B_NODEMAP(R2)
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return and iterate

	.SBTTL	CNX$RCVD_TOPOLOGY  - Topology Request Message Received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a topology request message is received.
;	A response must be sent describes the connectivity seen by the
;	receiving node.  The message itself is used to update the receiving
;	nodes' understanding of the sending nodes' connectivity.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_TOPOLOGY
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_TOPOLOGY::
	PUSHR	#^M<R2,R3,R5>		; Save needed registers
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVQ	(SP),R2			; Restore message address and CSB address
	BSBW	MSG_CHECK		; Validate message
	MOVC3	#CSB$S_NODEMAP, -	; Fill in connectivity in sending node's
		CLMTOP$B_NODEMAP(R2), -	;   CSB
		CSB$B_NODEMAP(R3)
	POPR	#^M<R2,R3,R5>		; Restore needed registers
	MOVL	CSB$L_CLUB(R3),R4	; Fetch CLUB address
	MOVZBL	#CLMCNX$K_FNC_TOPOLOGY,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	MOVAB	B^BLD_TOPOLOGY_MSG, -	; Store message build routine
		CDRP$L_MSGBLD(R5)
	BRW	CNX$RESP_FORGET		; Send response message and forget it

	.SBTTL	SEND_PH1 - Send Phase 1 Messages

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Send a Phase 1 message to all locked and selected
;	nodes.  A response is required from every node.  If any response
;	is a NAK or any connection breaks, the transition is abandoned
;	without returning to the caller.
;
; CALLING SEQUENCE:
;
;	JSB	SEND_PH1
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R4 is address of CLUB
;		CLUB$B_CUR_CODE gives transaction type
;		CLUB$L_CTX0 contains R0 argument for INIT_STD_MSG
;		CLUB$L_CTX1 contains message build routine address
;
; OUTPUT PARAMETERS:
;
;	R4 is address of CLUB
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	CLUB$L_RET1 is destroyed.
;	R0-R3, R5 are destroyed.
;--

SEND_PH1:
	POPL	CLUB$L_RET1(R4)		; Save return address
	CLRW	CLUB$W_MSGCNT(R4)	; Initialize waiting count
	MOVB	#CLMCNX$K_PH1, -	; Mark this as Phase 1
		CLUB$B_CUR_PHASE(R4)
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,40$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if permanent break
		CSB$L_STATUS(R3),10$	;   in connection
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),10$
	BSBW	CNX$ALLOC_WARMCDRP_CSB
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,20$			; No memory available
	INCW	CLUB$W_MSGCNT(R4)	; Include in wait count
	BSBB	30$			; Describe nodes
	BRW	CNX$SCAN_CSBS_FORK	; Fork and resume scan

10$:	RSB				; Return and continue scan

20$:	BRW	CNX$SCAN_CSBS_RETRY	; Delay and resume scan

;
; Send proposal to one node
;
30$:	MOVL	CLUB$L_CTX0(R4),R0	; Facility specific message code
	BSBW	INIT_STD_MSG		; Standard CDRP message initialization
	MOVL	CLUB$L_CTX1(R4), -	; Address of routine to build
		CDRP$L_MSGBLD(R5)	;  status message
	BSBW	CNX$SEND_MSG_CSB	; Send message
;
;	We are resumed here when the response message arrives.
;	Registers contain:
;		R0:	Status
;		R2:	Address of message buffer
;		R3:	Address of CSB
;		R4:	Address of PDT
;		R5:	Address of CDRP
;
	BSBW	CNX$PROCESS_RESPONSE	; Deallocate storage, get status
	BLBS	R0,40$			; Branch if ACK
	BISL2	#CLUB$M_UNLOCK, -	; Request that all be unlocked
		CLUB$L_FLAGS(R4)
;
; terminate threads -- except for the last one
;
40$:	DECW	CLUB$W_MSGCNT(R4)
	BLSS	50$			; Branch when done
	RSB				; Terminate thread

50$:	BSBW	CNX$CHECK_UNLOCK	; Check unlock request bit
	JMP	@CLUB$L_RET1(R4)	; Return to caller

	.SBTTL	SEND_PH2 - Send a Phase 2 Notification

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Send a Phase 2 notification to all locked and selected
;	nodes.  All messages are sent in parallel.  Breaking
;	connections are ignored.
;
; CALLING SEQUENCE:
;
;	JSB	SEND_PH2
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	CLUB$B_CUR_CODE gives transaction type
;
; OUTPUT PARAMETERS:
;
;	R4 is address of CLUB
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;--

SEND_PH2:
	MOVB	#CLMCNX$K_PH2, -	; Set current phase
		CLUB$B_CUR_PHASE(R4)	;   into CLUB
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBS
	BLBC	R0,DO_PHASE2		; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if permanent break
		CSB$L_STATUS(R3),10$	;   in connection
	BSBW	CNX$ALLOC_CDRP_ONLY
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,20$			; No memory available
;
; Send Phase 2 to one node
;
	MOVZBL	#CLMCNX$K_FNC_PH2,R0	; Facility specific function code
	BSBW	INIT_STD_MSG		; Setup CDRP for sending message
	BSBW	CNX$SEND_FORGET		; Send message and forget it
	BRW	CNX$SCAN_CSBS_FORK	; Fork and resume scan

10$:	RSB				; Return and continue scan

20$:	BRW	CNX$SCAN_CSBS_RETRY	; Delay and resume scan

	.SBTTL	CNX$RCVD_PH2 - Phase 2 request received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a phase 2 request message is received.
;	The transition inprogress is committed.
;	No response or immediate acknowledgement is sent.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_PH2
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_PH2::
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	BBC	#CLUB$V_TRANSITION, -	; Branch if not locked and
		CLUB$L_FLAGS(R4),10$	;   bugcheck
	CMPL	CLMCNX$L_XTN_ID(R2), -	; Validate transaction ID
		CLUB$L_CUR_XTN(R4)
	BEQL	20$			; Branch on match
10$:	BUG_CHECK	CNXMGRERR,FATAL	; Do something more sophisticated later?

20$:	BSBW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer

;
; Perform general transition completion operations
;
DO_PHASE2:
	MOVL	CLUB$L_CUR_XTN(R4), -	; Copy current transaction info into
		CLUB$L_LST_XTN(R4)
	MOVL	CLUB$L_CUR_COORD(R4), -
		CLUB$L_LST_COORD(R4)
	MOVQ	CLUB$Q_CUR_TIME(R4), -
		CLUB$Q_LST_TIME(R4)
	MOVB	CLUB$B_CUR_CODE(R4), -
		CLUB$B_LST_CODE(R4)
	MOVB	CLUB$B_CUR_PHASE(R4), -
		CLUB$B_LST_PHASE(R4)
	MOVW	CLUB$W_NEXT_CSID(R4), -	; Update CSID allocation context
		CLUB$W_FIRST_INDEX(R4)
;
; Case on transaction type and branch to appropriate place
;
	DISPATCH	CLUB$B_CUR_CODE(R4),TYPE=B,PREFIX=CLMCNX$K_XTN_, -
		< -
		<FORM,FORM_FINISH>, -	; Cluster formation complete
		<JOIN,JOIN_FINISH>, -	; Joining cluster complete
		<RECONFIG,RECONFIG_FINISH>, -	; Failover complete
		<QUORUM,QUORUM_FINISH>, - ; Quorum adjustment complete
		>
	BUG_CHECK	CNXMGRERR,FATAL	; Invalid transaction code


	.SBTTL	LOCK_NODES - Obtain Coordinator Lock on Selected Nodes

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine tries to obtain the coordinator lock on the
;	selected nodes.
;	The attempt fails if any node rejects the request or
;	if the connection to a candidate node breaks.
;	An immediate return is made to the caller's caller.
;	If the locking operation is complete, a return is
;	made to the caller.
;	If the locking operation fails, the transition is aborted
;	and no return is made; rather control passes to the unlock
;	routine.
;
; CALLING SEQUENCE:
;
;	JSB	LOCK_NODES
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	CLUB$B_CUR_CODE gives transaction type
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	If CSB is locked, the CSB$M_LOCKED bit in CSB$L_STATUS is set
;	and the CSB$B_REF_CNT is incremented.
;	R0-R5 are destroyed
;
;--

LOCK_NODES:
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	POPL	CLUB$L_RET1(R4)		; Save return address
	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; Address of local CSB
	BSBW	CNX$MARK_LOCKED		; Mark local CSB locked first
	BSBW	CNX$CLUB_FORK		; Release control briefly
	MOVAL	CLUB$L_CSBQFL(R4),R3	; Point to head of CSB list
10$:	MOVL	CSB$L_SYSQFL(R3),R3	; Advance to next CSB
	CMPL	R3,R4			; Done yet?
	BEQL	90$			; Branch when done
20$:	BBS	#CLUB$V_UNLOCK, -	; Branch if unlock requested
		CLUB$L_FLAGS(R4),80$
	BBC	#CSB$V_SELECTED, -	; Ignore unselected nodes
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LOCKED, -	; Branch if already locked
		CSB$L_STATUS(R3),10$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if long break has been seen
		CSB$L_STATUS(R3),80$	;   and unlock everything
	BSBW	CNX$ALLOC_WARMCDRP_CSB
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBS	R0,30$			; Branch if memory available
	BSBW	CNX$CLUB_WAIT		; Wait a second, saving R3
	BRB	20$			; Restart scan

30$:	MOVZBL	#CLMCNX$K_FNC_LOCK,R0	; Facility specific function code
	BSBW	INIT_STD_MSG		; Standard CDRP initialization
	MOVAB	B^BLD_LOCK_MSG, -	; Message building routine
		CDRP$L_MSGBLD(R5)
	BSBW	CNX$SEND_MSG_CSB	; Send message
;
;	We are resumed here when the response message arrives.
;	Registers contain:
;		R0:	Status
;		R2:	Address of message buffer
;		R3:	Address of CSB
;		R4:	Address of PDT
;		R5:	Address of CDRP
;
	BSBW	CNX$PROCESS_RESPONSE	; Deallocate storage, fetch status
	BLBC	R0,80$			; Branch if ACK not received
;
; Setup data to lock node whose CSB is R3
;
	BSBW	CNX$MARK_LOCKED		; Mark CSB locked
	BRB	10$			; Continue with next CSB

80$:	BRW	UNLOCK_ALL		; Exit from transition

90$:	JMP	@CLUB$L_RET1(R4)	; Return to caller's caller

	.SBTTL	BLD_LOCK_MSG - Build Coordinator Lock Request Message

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds a message requesting the coordinator lock.
;	The standard message building routine is used to build the message
;	header.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_LOCK_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;		CDRP$L_VAL1(R5): Byte 0 contains facility code (negated for response)
;				 Byte 1 contains facility specific function code
;		CDRP$L_VAL2(R5): Transition ID (from CLUB$L_CUR_XTN)
;		CDRP$L_VAL3(R5): Byte 0 contains transition phase (from CLUB$B_CUR_PHASE)
;				 Byte 1 contains transition code (from CLUB$B_XTN_CODE)
;				 Byte 2 contains success/failure flag
;				 Byte 3 contains reply code
;		CDRP$L_VAL4(R5): Address of CSB to describe
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BLD_LOCK_MSG:
	BSBW	BLD_STD_MSG		; Fill in standard fields
	MOVL	CSB$L_CLUB(R3),R0	; Address of CLUB
	MOVQ	CLUB$Q_CUR_TIME(R0), -	; Fill in transition time-stamp
		CLMLCK$Q_XTN_TIME(R2)
	RSB

	.SBTTL	CNX$RCVD_LOCK - Lock request received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a lock request message is received.
;	A response must be sent which ACKs or NAKs the request.  The
;	request is NAKd if this node is already locked or in transition.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_LOCK
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_LOCK::
	PUSHL	R2			; Save needed register
	BSBW	CNX$INIT_CDRP		; Initialize the CDRP for the response
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	POPR	#^M<R2>			; Restore message address
	SUBL3	CLMCNX$L_XTN_ID(R2), -	; Update largest transaction seen -
		CLUB$L_MAX_XTN(R4),R0	;   status is only interesting result
	BGEQ	10$			; No update needed
	MOVL	CLMCNX$L_XTN_ID(R2), -	; Update local information
		CLUB$L_MAX_XTN(R4)
	BBC	#CLUB$V_INIT, -		; Branch if initialization not
		CLUB$L_FLAGS(R4),20$	;   complete and NAK request
	BBSS	#CLUB$V_TRANSITION, -	; Branch if busy and mark us busy
		CLUB$L_FLAGS(R4), 20$
	CLRL	CLUB$L_TQE(R4)		; Abandon any timeout in progress
	MOVAB	CLUB$B_FORK_BLOCK(R4),R0 ; Address of transition fork block
	BBCC	#CLUBFKB$V_FKB_BUSY, -	; Branch if fork block is not
		CLUBFKB$L_STATUS(R0),5$	;  busy and mark no busy
	REMQUE	CLUBFKB$B_FORK_BLOCK(R0),R0 ; Remove from queue
5$:
;
; Initialization for accepting lock request and beginning new transition
;
	BSBW	CNX$INIT_CSBS		; Initialize all CSBs for new transition
	BICL2	#CLUB$M_UNLOCK, -	; Clear unlock flag
		CLUB$L_FLAGS(R4)
	MOVL	CLUB$L_LOCAL_CSB(R4),R0	; Address of local CSB
	BISL2	#CSB$M_SELECTED, -	; Mark local node SELECTED
		CSB$L_STATUS(R0)
	BISL2	#CSB$M_SELECTED, -	; Mark coordinator SELECTED
		CSB$L_STATUS(R3)
	MOVL	CLMCNX$L_XTN_ID(R2), -	; Update local information about
		CLUB$L_CUR_XTN(R4)	;   transition
	MOVL	CSB$L_CSID(R3), -	; CSID of coordinator
		CLUB$L_CUR_COORD(R4)
	MOVB	CLMCNX$B_XTN_CODE(R2), - ; Transition type
		CLUB$B_CUR_CODE(R4)
	MOVB	CLMCNX$B_XTN_PHASE(R2), - ; Transition phase
		CLUB$B_CUR_PHASE(R4)
	MOVQ	CLMLCK$Q_XTN_TIME(R2), - ; Transition time-stamp
		CLUB$Q_CUR_TIME(R4)
	MOVL	R3,CLUB$L_COORD(R4)	; CSB of coordinator
	MOVW	CLUB$W_FIRST_INDEX(R4), - ; Initialize CSID allocation context
		CLUB$W_NEXT_CSID(R4)
	PUSHL	#1			; Accept request
	BRB	30$
;
; Transition number is invalid.
; Lock request will be rejected.
; Request that status be send to remote node.
;
10$:	BISL2	#CSB$M_SEND_STATUS, -	; Send status request
		CSB$L_STATUS(R3)
;
; Common reject point
;
20$:	PUSHL	#0			; Reject lock request
30$:	MOVZBL	#CLMCNX$K_FNC_LOCK,R0	; Facility specific function code
	BSBW	CNX$INIT_STD_RESP	; Init CDRP for standard response
	CVTLB	(SP)+,CDRP$L_VAL3+2(R5)	; Store success/failure flag
	BRW	CNX$RESP_FORGET		; Send response and forget it

	.SBTTL	CNX$CHECK_UNLOCK - Check UNLOCK flag

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Test the UNLOCK flag in the CLUB.  If it is clear, return to the caller.
;	If it is set, remove the caller's PC from the stack, and branch to UNLOCK_ALL.
;	This will eventually return to the caller's caller.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$CHECK_UNLOCK
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	The CLUB$M_UNLOCK bit CLUB$L_FLAGS is the primary input
;
; OUTPUT PARAMETERS:
;
;	R4 contains the address of the CLUB
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

CNX$CHECK_UNLOCK::
	MOVL	G^CLU$GL_CLUB,R4	; Get address of CLUB
	BBS	#CLUB$V_UNLOCK, -	; Branch if unlock is request and abort
		CLUB$L_FLAGS(R4),10$	;   this transition
	RSB

10$:	ADDL2	#4,SP			; Remove caller's PC
	BRB	UNLOCK_ALL		; Abort transition and return to caller's caller

	.SBTTL	UNLOCK_ALL - Release Coordinator Lock on All Nodes

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine releases the coordinator lock on all nodes.
;	A breaking link counts as a successful release of the lock.
;
; CALLING SEQUENCE:
;
;	JSB	UNLOCK_ALL
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	CLUB$B_CUR_CODE gives transaction type
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 are destroyed
;
;--

UNLOCK_ALL:
	BSBW	CNX$CHECK_QUORUM	; Adjust dynamic quorum flag, hang if no quorum
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	MOVL	CLUB$L_LOCAL_CSB(R4),R3	; Local CSB address
	BBS	#CSB$V_LOCKED, -	; Branch if still locked
		CSB$L_STATUS(R3),5$
	CMPL	R3,CLUB$L_COORD(R4)	; Is local system the coordinator?
	BNEQ	5$			; Branch if not coordinator
	CLRL	R5			; No CSB address for message
	MOVAB	COMPLETE_MSG,R0		; Cluster state transition complete message
	BSBW	CNX$CONFIG_CHANGE	; Make this state known
5$:
	MOVB	#CLMCNX$K_UNLOCK, -	; Set phase to UNLOCK
		CLUB$B_CUR_PHASE(R4)
	BSBW	CNX$SCAN_CSBS		; Iterate over all CSB's
	BLBC	R0,UNLOCK_NODE		; Branch when done
	BBS	#CSB$V_MEMBER, -	; Branch if a cluster member
		CSB$L_STATUS(R3),10$
	BBCS	#CSB$V_SEND_STATUS, -	; Request status for non-cluster nodes
		CSB$L_STATUS(R3), 10$	;   informing them of this nodes' new status
10$:	BBC	#CSB$V_LOCKED, -	; Branch if not locked
		CSB$L_STATUS(R3),40$
	CMPL	CLUB$L_LOCAL_CSB(R4), -	; Is local system the
		CLUB$L_COORD(R4)	;   coordinator?
	BNEQ	30$			; Branch if not coordinator
	BBS	#CSB$V_LOCAL, -		; Branch if local CSB
		CSB$L_STATUS(R3),20$
	BBS	#CSB$V_LONG_BREAK, -	; Branch if connection really
		CSB$L_STATUS(R3),30$	;   broken
	BSBW	CNX$ALLOC_CDRP_ONLY	; Get a CDRP
	BSBW	CNX$RESOURCE_CHECK	; Watch out for exhausted resources
	BLBC	R0,50$			; No memory available
	MOVZBL	#CLMCNX$K_FNC_UNLOCK,R0	; Facility specific function code
	BSBW	INIT_STD_MSG		; Init CDRP for standard message
	BSBW	CNX$SEND_FORGET		; Send message and forget it
	BRB	30$			; Branch to common exit

; Output ABORT message only once -- when processing local node
;
20$:	CLRL	R5			; No CSB address
	MOVAB	UNLOCK_MSG,R0		; Aborting transition message
	BSBW	CNX$CONFIG_CHANGE	; Make this state known

; Common exit
;
30$:	BSBW	CNX$MARK_UNLOCKED	; Mark CSB not locked.  If the CSB
					;   is deleted, R3 is previous list entry
	BRW	CNX$SCAN_CSBS_FORK	; Fork and then continue scan

40$:	RSB

50$:	BRW	CNX$SCAN_CSBS_RETRY	; Delay and then resume scan

	.SBTTL	CNX$RCVD_UNLOCK - Unlock request received

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when an unlock request message is received.
;	The node is unlocked. No response or immediate acknowledgement is sent.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$RCVD_UNLOCK
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R5 may be destroyed.
;--

CNX$RCVD_UNLOCK::
	BSBW	MSG_CHECK		; Validate message
	BSBW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer
;
; Right here, all nodes have been unlocked.
; May need to start up some activity here.
;
UNLOCK_NODE:
	CMPW	CLUB$W_VOTES(R4), -	; Is there a quorum?
		CLUB$W_QUORUM(R4)
	BGEQU	10$			; Branch if yes
	BBC	#CLUB$V_SHUTDOWN, -	; Branch if not in shutdown mode
		CLUB$L_FLAGS(R4),10$
	BUG_CHECK	OPERATOR,FATAL	; Finish cluster-wide shutdown

10$:	BBCC	#CLUB$V_ADJ_QUORUM, -	; Clear quorum adjustment flag
		CLUB$L_FLAGS(R4),20$
20$:	MOVB	#CLMCNX$K_IDLE, -	; Set phase to IDLE
		CLUB$B_CUR_PHASE(R4)
	BBCC	#CLUB$V_TRANSITION, -	; Clear transition flag
		CLUB$L_FLAGS(R4),30$
30$:	BSBW	CNX$CHECK_QUORUM	; Check dynamic quorum
	BRW	START_TIMEOUT		; Keep the home fires burning...

	.SBTTL	CNX$PROCESS_RESPONSE - Process simple response message

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Process a reponse message by deallocating the message buffer
;	and CDRP.
;	Return status indicating whether the connection broke, the
;	response was an ACK, or the response was an ACK.
;
; CALLING SEQUENCE:
;
;	JSB	CNX$PROCESS_RESPONSE
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R0:	Status
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;
; OUTPUT PARAMETERS:
;
;	R4:	Address of CLUB
;
; COMPLETION CODES:
;
;	R0:
;		1 (success) Response was ACK
;		0 (failure) Response was NAK
;		2 (failure) Connection broke
;
; SIDE EFFECTS:
;
;	R1, R2, and R5 are destroyed
;
;--

CNX$PROCESS_RESPONSE::
	BLBC	R0,10$			; Error sending message
	MOVZBL	CLMCNX$B_ACK(R2),-(SP)	; Save response
	BSBW	CNX$DEALL_WARMCDRP_CSB	; Recycle warm CDRP
	POPR	#^M<R0>			; Restore response ACK/NAK
	BRB	20$			; Branch to common exit
; 
10$:	PUSHL	R3			; Save CSB address
	MOVL	R5,R0			; Address of CDRP
	JSB	G^EXE$DEANONPAGED	; Deallocate CDRP
	POPR	#^M<R3>			; Restore CSB address
	MOVL	#2,R0			; Return status code
20$:	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	RSB				; Return to caller

	.SBTTL	INIT_STD_MSG - Common CDRP initialization for standard message
	.SBTTL	CNX$INIT_STD_RESP - Common CDRP initialization for standard response

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine initializes most of the CDRP fields used by the standard
;	message build routines.  Two entry points are provided -- one for
;	normal messages and one for responses.
;	These routines are provided for use in conjunction with the BLD_STD_MSG
;	message building routine.
;
; CALLING SEQUENCE:
;
;	JSB	INIT_STD_MSG
;	JSB	CNX$INIT_STD_RESP
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R0:	Message specified data
;		Byte 0: Facility specific function code
;		Byte 2: ACK byte data (INIT_STD_MSG only)
;		Byte 3: REPLY byte data (INIT_STD_MSG only)
;	R3:	Address of CSB
;	R4:	Address of CLUB
;		CLUB$L_CUR_XTN(R4): Current transition id
;		CLUB$B_CUR_PHASE(R4): Current transition phase
;		CLUB$B_CUR_CODE(R4): Current transition code
;	R5:	Address of CDRP
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

	.ENABLE	LSB

CNX$INIT_STD_RESP::
	MOVB	#<CLSMSG$K_FAC_CNX ! -	; Facility message code
    		  CLSMSG$M_RESPMSG>,R1	;   with response tag
	MOVZBL	R0,R0			; Ignore high order bits *** temp
	BRB	10$

INIT_STD_MSG:
	MOVB	#CLSMSG$K_FAC_CNX,R1	; Facility message code
10$:	CLRL	CDRP$L_VAL1(R5)		; Initialize other fields
	MOVB	R1,CDRP$L_VAL1+0(R5)	; Facility identification code
	MOVB	R0,CDRP$L_VAL1+1(R5)	; Facility specific code
	MOVL	CLUB$L_CUR_XTN(R4), -	; Current transition ID
		CDRP$L_VAL2(R5)
	MOVL	R0,CDRP$L_VAL3(R5)	; Store byte 2 of R0 as ack  field
					;   and byte 3 of R0 as reply field
	MOVB	CLUB$B_CUR_PHASE(R4), -	; Current transition phase
		CDRP$L_VAL3(R5)
	MOVB	CLUB$B_CUR_CODE(R4), -	; Current transition code
		CDRP$L_VAL3+1(R5)
	MOVAB	B^BLD_STD_MSG, -	; Standard message build routine
		CDRP$L_MSGBLD(R5)
	RSB

	.DISABLE	LSB

	.SBTTL	BLD_STD_MSG - Build Standard Message from CDRP

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is a common message build routine that fills in
;	the common message header from data in the CDRP.
;	There is no dependence upon the contents of the CLUB in building
;	the message.  This means that this routine is safe to use for
;	messages that are queued and forgotten and which can be sent
;	at a later time when the state of the world has changed.
;
; CALLING SEQUENCE:
;
;	JSB	BLD_STD_MSG
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Address of message buffer
;	R3:	Address of CSB
;	R4:	Address of PDT
;	R5:	Address of CDRP
;		CDRP$L_VAL1(R5): Byte 0 contains facility code (negated for response)
;				 Byte 1 contains facility specific function code
;		CDRP$L_VAL2(R5): Transition ID (from CLUB$L_CUR_XTN)
;		CDRP$L_VAL3(R5): Byte 0 contains transition phase (from CLUB$B_CUR_PHASE)
;				 Byte 1 contains transition code (from CLUB$B_XTN_CODE)
;				 Byte 2 contains success/failure flag
;				 Byte 3 contains reply code
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed
;
;--

BLD_STD_MSG:
	MOVB	CDRP$L_VAL1+0(R5), -	; Facility message / response code
		CLSMSG$B_FACILITY(R2)
	MOVB	CDRP$L_VAL1+1(R5), -	; Facility specific function code
		CLSMSG$B_FUNC(R2)
	ASSUME 	CLMCNX$B_XTN_PHASE EQ CLMCNX$L_XTN_ID+4
	ASSUME	CDRP$L_VAL3 EQ CDRP$L_VAL2+4
	ASSUME	CLMCNX$B_XTN_CODE EQ CLMCNX$B_XTN_PHASE+1
	ASSUME	CLMCNX$B_ACK EQ CLMCNX$B_XTN_CODE+1
	ASSUME	CLMCNX$B_REPLY EQ CLMCNX$B_ACK+1
	MOVQ	CDRP$L_VAL2(R5), -	; Standard information
		CLMCNX$L_XTN_ID(R2)
	RSB

	.SBTTL	MSG_CHECK - Standard incoming message verification

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to perform standard checks upon an
;	incoming message.  These checks may not be application to
;	messages intitiating or completing a transition.
;
; CALLING SEQUENCE:
;
;	JSB	MSG_CHECK
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R2:	Message address
;	R3:	CSB of sending system
;	R4:	PDT address
;	R5:	CDRP address (uninitialized)
;
; OUTPUT PARAMETERS:
;
;	R4:	Address of the CLUB
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0-R1 may be destroyed.
;--

MSG_CHECK:
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	CMPL	CLMCNX$L_XTN_ID(R2), -	; Check for inconsistency
		CLUB$L_CUR_XTN(R4)
	BNEQ	10$			; Bugcheck on inconsistency
	BBC	#CLUB$V_TRANSITION, -	; Branch on inconsistency
		CLUB$L_FLAGS(R4), 10$	;   and bugcheck
	MOVB	CLMCNX$B_XTN_PHASE(R2), - ; Save transition phase
		CLUB$B_CUR_PHASE(R4)
	RSB

10$:	BUG_CHECK	CNXMGRERR,FATAL	; Inconsistent message

	.SBTTL	UPDATE_QUORUM - Update Quorum Parameters in CLUB

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Update the CLUB$W_QUORUM, CLUB$W_VOTES, CLUB$W_QDVOTES, and
;	CLUB$W_NODES fields of the CLUB at the conclusion of a fully
;	synchronized state change.
;
; CALLING SEQUENCE:
;
;	JSB	UPDATE_QUORUM
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	CSB'S in list with CSB$M_SELECTED bit set
;	CLUB$W_NEWQUORUM is quorum
;	CLUB$W_NEWQDVOTES is votes assigned to quorum disk
;	CLUB$V_QF_NEWVOTE is quorum disk membership flag
;
; OUTPUT PARAMETERS:
;
;	R4 is address of CLUB
;	CLUB$W_QUORUM is new quorum
;	CLUB$W_VOTES is new number of votres present in the cluster
;	CLUB$W_NODES is number of nodes in cluster
;	CLUB$V_QF_VOTE indicates that the quorum disk is a member
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 and R1 are destroyed.
;--

UPDATE_QUORUM:
	PUSHR	#^M<R2,R3>		; Save registers
	MOVL	G^CLU$GL_CLUB,R4	; Address of CLUB
	MOVW	CLUB$W_NEWQUORUM(R4), -	; Update cluster quorum
		CLUB$W_QUORUM(R4)
	MOVW	CLUB$W_NEWQDVOTES(R4), - ; Update quorum disk votes
		CLUB$W_QDVOTES(R4)
	CLRW	CLUB$W_NODES(R4)	; Initialize count of nodes
	CLRW	CLUB$W_VOTES(R4)	; Initialize vote count
	BICL	#CLUB$M_QF_VOTE, -	; Assume no quorum disk membership
		CLUB$L_FLAGS(R4)
	BBC	#CLUB$V_QF_NEWVOTE, -	; Branch if no quorum disk membership
		CLUB$L_FLAGS(R4),10$
	ADDW	CLUB$W_NEWQDVOTES(R4), - ; Count quorum disk in votes
		CLUB$W_VOTES(R4)
	BBSS	#CLUB$V_QF_VOTE, -	; Mark quorum disk a member
		CLUB$L_FLAGS(R4),10$
10$:	BSBW	CNX$SCAN_CSBS		; Iterate over all CSBs
	BLBC	R0,30$			; Branch when done
	BBC	#CSB$V_SELECTED, -	; Branch if not selected
		CSB$L_STATUS(R3),20$
	INCW	CLUB$W_NODES(R4)	; Count this node
	ADDW	CSB$W_VOTES(R3), -	; Count votes for this node
		CLUB$W_VOTES(R4)
20$:	RSB

30$:	POPR	#^M<R2,R3>		; Restore registers
	RSB				; Return

	.SBTTL	ADD_NODE - Make node a cluster member
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Make the specified node a cluster member.
;
; CALLING SEQUENCE:
;
;	JSB	ADD_NODE
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R3:	CSB of the node to be added
;		CSB$L_CSID contains CSID for the node
;
; OUTPUT PARAMETERS:
;
;	R4:	Address of CLUB
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	The cluster vector is updated.
;	The CSB reference count is incremented.
;	R0-R1 are destroyed.
;
;--

ADD_NODE:
	INCB	CSB$B_REF_CNT(R3)	; Bump reference count to nail down CSB
	BISL2	#CSB$M_MEMBER, -	; Mark the node a cluster member
		CSB$L_STATUS(R3)
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID slot index
	BEQL	90$			; Branch if 0 -- invalid index
	CMPW	R0,G^CLU$GW_MAXINDEX	; Valid index
	BGEQU	90$			; Branch if invalid index
	MOVL	G^CLU$GL_CLUSVEC,R1	; Address of cluster vector
	TSTL	(R1)[R0]		; Is slot free?
	BLSS	90$			; Branch if slot in use
	MOVL	R3,(R1)[R0]		; Store CSB address in slot
	MOVL	CSB$L_CLUB(R3),R4	; Address of CLUB
	BBS	#CSB$V_CLUSTER, -	; Skip ref time update if remote
		CSB$L_STATUS(R3),5$	;   node is already a cluster member
	MOVQ	CLUB$Q_LST_TIME(R4), -	; Update reference time
		CSB$Q_REFTIME(R3)
5$:	BBC	#CSB$V_LOCAL, -		; Branch if not the local node
		CSB$L_STATUS(R3),10$
	MOVL	CSB$L_CSID(R3), -	; Store local CSID in CLUB
		CLUB$L_LOCAL_CSID(R4)
10$:	BBC	#CSB$V_LONG_BREAK, -	; Branch if no long break seen
		CSB$L_STATUS(R3),20$
	BBSS	#CLUB$V_LOST_CNX, -	; Mark cluster connection lost
		CLUB$L_FLAGS(R4),20$
20$:	RSB

90$:	BUG_CHECK	CNXMGRERR,FATAL	; Consistency check

	.SBTTL	REMOVE_NODE - Remove a node from the cluster
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Remove the specified node from the cluster
;
; CALLING SEQUENCE:
;
;	JSB	REMOVE_NODE
;	IPL is IPL$_SCS
;
; INPUT PARAMETERS:
;
;	R3:	CSB of the node to be removed
;
; OUTPUT PARAMETERS:
;
;	R3:	If CSB is deleted, the contents of back pointer cell.
;		If CSB is not deleted, R3 is preserved.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	The cluster vector is updated.
;	The CSB reference count is decremented.
;	R0-R2 are destroyed.
;
;--

REMOVE_NODE:
	PUSHR	#^M<R4,R5>		; Save register
	MOVL	R3,R5			; Address of CSB
	MOVAB	W^FAILOVER_MSG,R0	; Message for removing node from cluster
	BSBW	CNX$CONFIG_CHANGE	; Tell the world the node is gone
	BBCC	#CSB$V_MEMBER, -	; Mark the node not a cluster member
		CSB$L_STATUS(R3), 90$	; *** Is this right?
	BISL2	#CSB$M_REMOVED, -	; Mark the node removed
		CSB$L_STATUS(R3)
	MOVQ	CLUB$Q_LST_TIME(R4), -	; Update reference time
		CSB$Q_REFTIME(R3)
	MOVL	CSB$L_CLUB(R3),R4	; Fetch address of CLUB
;
; Tell quorum disk manager to skip a read cycle since a node has just been dropped
; from the cluster -- the removed node may still have a chance to write.
;
	BISL2	#CLUB$M_QF_FAILED_NODE, - ; Set bit requesting that a read cycle be
		CLUB$L_FLAGS(R4)	;   skipped
	BICL2	#CLUB$M_QF_DYNVOTE, -	; Stop dynamically counting the quorum disk
		CLUB$L_FLAGS(R4)	;   until remote node can sense us
	MOVZWL	CSB$W_CSID_IDX(R3),R0	; CSID slot index
	BEQL	90$			; Branch if 0 -- invalid index
	CMPW	R0,G^CLU$GW_MAXINDEX	; Valid index
	BGEQU	90$			; Branch if invalid index
	MOVL	G^CLU$GL_CLUSVEC,R1	; Address of cluster vector
	CMPL	(R1)[R0],R3		; Is slot consistent with CSB?
	BNEQ	90$			; Branch if things are inconsistent
	MOVZWL	CSB$W_CSID_SEQ(R3), -	; Store old sequence number for reuse
		(R1)[R0]
	MOVL	R3,R5			; Address of CSB
	BSBW	CNX$DISC_REMOVE		; Break connection to node that has been removed
	BSBW	SEND_JBCMSG		; Tell the job controller that the node is gone
	BSBW	CNX$DECREFCNT		; Decrement reference count, perhaps delete CSB
	MOVL	R5,R3			; Address of this/previous CSB
	POPR	#^M<R4,R5>		; Restore R4 and R5
	RSB

90$:	BUG_CHECK	CNXMGRERR,FATAL	; Consistency check


	.END
