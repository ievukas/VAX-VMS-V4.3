MODULE DBGNSHOW (IDENT = 'V04-000') =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
! MODULE FUNCTION
!	This module contains the ATN parse network and the command execution network
!	to support the SHOW ... command. The parse network constructs a command
!	execution tree consisting of a verb node as the head, and 0 or more noun
!	nodes and adverb nodes. The execution network uses the command execution
!	tree as input and performs the corresponding semantic actions.
!
! AUTHOR:	David Plummer, CREATION DATE:	3/31/80
!
! MODIFIED BY:
!
!	Richard Title	16-Sep-81
!	Sid Maxwell	 3-Dec-81
!	Ping Sager      19-Feb-82
!	V. Holt		14-May-82
!	Brad Becker	13-Sep-83
!
! REVISION HISTORY:
!
! 3.01	16-SEP-81	RT	Implemented SHOW SOURCE
! 3.02	 9-OCT-81	RT	Implemented SHOW MARGINS and SHOW MAX_SOURCE_FILES
! 3.03	21-Oct-81	RT	Implemented SHOW SEARCH
! 3.04	 3-Dec-81	SRM	Changed SHOW CALLS to check AT_FAULT instead
!				of AT_BREAK and AT_STEP_END
! 3B.0  19-Feb-82       PS      Implemented SHOW SYMBOL
!       06-May-82	RT	Implemented SHOW DEFINE
!       07-May-82	RT	Implemented SHOW SYMBOLS/DEFINED
!	07-May-82	RT	Implemented SHOW DEVELOPER
!	14-May-82	VJH	Added call to DBG$FLUSHBUF, eliminating need to
!				initialize local buffer pointers.
!	 7-Jun-82	VJH	Removed all references to DBG$FAO_PUT and
!				DBG$OUT_PUT, as these are now obsolete.  
!	04-Apr-83	RT	Removed all references to VJH, as she 
!				is now obsolete. (Just kidding, Vicki....)
!	04-Apr-83	RT	Made SHO SYM also show defined symbols
! 4.0	13-Sep-83	BAB	Implemented SHOW KEY
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
	DBG$NPARSE_SHOW,			! Parse network for SHOW command
	DBG$NPARSE_SHOW_KEY,			! Parse network for SHOW KEY command
	DBG$NEXECUTE_SHOW,			! Execution network for SHOW command
	DBG$NEXECUTE_SHOW_KEY,			! Execution network for SHOW KEY command
    	DBG$NSHOW_MARGINS : NOVALUE,		! Displays margin settings
    	DBG$NSHOW_MAX_SOURCE_FILES : NOVALUE,	! Displays max_source_file setting
	DBG$NSHOW_OUTPUT : NOVALUE,		! Displays output configuration of debugger
    	DBG$SHOW_RADIX: NOVALUE;		! Display radix settings

EXTERNAL ROUTINE
    DBG$EVENT_SHOW_CANCEL_SYNTAX,	! Syntax for SHOW|CANCEL BREAK|TRACE|WATCH
    DBG$EVENT_SHOW_CANCEL_SEMANTICS,	! Semantics for SHOW|CANCEL BREAK|TRACE|WATCH
    DBG$DUMP_DEFINE,			! Dump define symbol table
    DBG$FAO_OUT: NOVALUE,		!
    DBG$NGET_TRANS_RADIX,
    DBG$SCR_EXECUTE_SHODISP_CMD:NOVALUE,! Execute the SHOW DISPLAY command
    DBG$SCR_EXECUTE_SHOSEL_CMD: NOVALUE,! Execute the SHOW SELECT command
    DBG$SCR_EXECUTE_SHOWIND_CMD:NOVALUE,! Execute the SHOW WINDOW command
    DBG$SCR_PARSE_SHODISP_CMD: NOVALUE,	! Parse the SHOW DISPLAY command
    DBG$SCR_PARSE_SHOWIND_CMD: NOVALUE,	! Parse the SHOW WINDOW command
    DBG$SHOW_TYPE,			! Displays default and override types
    DBG$SHOW_MODE,			! Displays mode
    DBG$SHOW_MODULE,			! Outputs the module chain
    DBG$SHOW_SEARCH: NOVALUE,		! Displays search settings
    DBG$SHOW_DEFINE: NOVALUE,		! Displays define setting
    DBG$SHOW_STEP,			! Outputs user defined step settings
    DBG$NPARSE_SHOW_TASK: NOVALUE,	! Parse the SHOW TASK command
    DBG$NEXECUTE_SHOW_TASK: NOVALUE,	! Execute the SHOW TASK command
    DBG$RST_SHOWSCOPE,			! Outputs user set scopes
    DBG$TRACEBACK,			! Shows current runframe nesting
    DBG$NNEXT_WORD,			! Isolates next word of input for syntax errors
    DBG$NSYNTAX_ERROR,			! Outputs a syntax error
    DBG$NMAKE_ARG_VECT,			! Constructs a message argument vector
    DBG$NSAVE_DECIMAL_INTEGER,		! Converts input ASCII to integer
    DBG$NSAVE_STRING,			! Stores a string from input
    DBG$GET_TEMPMEM,			! Allocates listed dynamic storage
    DBG$PRINT: NOVALUE,			! Formatted ASCII output
    DBG$NEWLINE: NOVALUE,		! Flush the output buffer
    DBG$FLUSHBUF: NOVALUE,		! Initialize new print line
    DBG$LANGUAGE,			! Returns language setting
    DBG$SRC_SHOW_SOURCE: NOVALUE,	! Implements the SHOW SOURCE command
    DBG$NPARSE_SCOPE_LIST,		! Parses scope list
    DBG$STA_SHOWSYMBOL,			! Execute the SHOW SYMBOL command
    DBG$NMATCH,				! Counted string matching routine for parsing
    DBG$READ_KEY_INFO,			! Reads the key-name/state_name for SHOW KEY
    STR$COMPARE_EQL,			! Returns false if descriptors are equal
    SMG$LIST_KEY_DEFS,			! Returns all key definitions
    SMG$SET_DEFAULT_STATE;		! Returns the default key state

EXTERNAL
    DBG$RUNFRAME: BLOCK [,BYTE],	! User runframe
    DBG$GL_DEVELOPER: BITVECTOR,	! Set to different developer modes
    DBG$GB_KEYPAD_INPUT: BYTE,		! TRUE if keypad input is enabled
    DBG$GB_LANGUAGE: BYTE,		! Language index
    DBG$GB_RADIX: VECTOR[3, BYTE],	! Radix settings
    DBG$GL_LOGFAB: BLOCK [,BYTE],	! FAB for LOG file
    DBG$GL_KEY_TABLE_ID,
    DBG$GL_LOGNAM: REF $NAM_DECL,	! NAM block for LOG file
    DBG$GL_CONTEXT: BITVECTOR,		! Version 2 context vector
    DBG$GB_DEF_OUT: VECTOR [,BYTE], 	! Vector for output configuration
    DBG$SRC_LEFT_MARGIN,		! Margin 
    DBG$SRC_RIGHT_MARGIN,		! settings.
    DBG$SRC_MAX_FILES,			! Maximum number of open source
    					!      files (DBGSOURCE)
    DBG$SRC_TERM_WIDTH,			! The current terminal width
    DBG$GL_ORIG_COMMAND_PTR,		! Pointer to original command string
    DBG$GL_UPCASE_COMMAND_PTR: VECTOR[2];
    					! Pointers to start and end
    					!    of current command string


EXTERNAL LITERAL
    SMG$_NOMOREKEYS,
    SMG$_KEYNOTDEF;

LITERAL

    ! Legal adverb literals for SHOW SYMBOL qualifiers
    !
    SYMBOL_TYPE		= 1,
    SYMBOL_ADDRESS	= 2,
    SYMBOL_DIRECT	= 3,
    SYMBOL_RST		= 4,
    SYMBOL_DST		= 5,
    SYMBOL_DEFINED	= 6,


    ! Composite verb literals
    !
    ! Note - you may cause yourself problems if you try to renumber these,
    ! because some of these numbers must be the same as the corresponding
    ! EVENT$K_SHOW_XXX in DBGLIB.REQ.
    !
    MIN_SHOW			= 1,
    SHOW_BREAK			= 1,	! Also EVENT$K_SHOW_BREAK
    SHOW_CALLS			= 2,
    SHOW_CALLS_DIGIT		= 3,
    SHOW_LANGUAGE		= 4,
    SHOW_LOG			= 5,
    SHOW_MODE			= 6,
    SHOW_MODULE			= 7,
    SHOW_OUTPUT			= 8,
    SHOW_RADIX			= 28,
    SHOW_RADIX_OVERRIDE		= 29,
    SHOW_SCOPE			= 9,
    SHOW_STEP			= 10,
    SHOW_TRACE			= 11,	! Also EVENT$K_SHOW_TRACE
    SHOW_TYPE			= 12,
    SHOW_TYPE_OVERRIDE		= 13,
    SHOW_WATCH			= 14,	! Also EVENT$K_SHOW_WATCH
    SHOW_SOURCE			= 15,
    SHOW_MARGINS		= 16,
    SHOW_MAX_SOURCE_FILES	= 17,
    SHOW_SEARCH			= 18,
    SHOW_SYMBOL			= 19,
    SHOW_DEFINE			= 20,
    SHOW_SYMBOL_DEFINED		= 21,
    SHOW_DEVELOPER		= 22,
    SHOW_DISPLAY		= 23,
    SHOW_SELECT			= 24,
    SHOW_TERMINAL		= 25,
    SHOW_WINDOW			= 26,
    SHOW_KEY			= 27,
    SHOW_TASK			= 30,
    MAX_SHOW			= 30;

!
! MACROS
!
! The following macro is just an abbreviation for some error-reporting
! code that occurs repeatedly
!
MACRO report_error =
    BEGIN
    .message_vect = (
    	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	THEN
    	    dbg$nmake_arg_vect (dbg$_needmore)
    	ELSE
    	    dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
    RETURN sts$k_severe;
    END %;

!+
! Definition for the list of state names in the IF_STATE qualifier of the
! Define/key command.
!-

FIELD
    DBG$STATE_NAME_FIELDS =
        SET

        DBG$L_STATE_NAME_PTR		= [0, 0, 32, 0],	! Pointer to name descriptor
	DBG$L_STATE_NAME_LINK		= [1, 0, 32, 0]		! Pointer to next state name

	TES;

LITERAL
	DBG$K_STATE_NAME_SIZE		= 2;			! length in long words

MACRO
	DBG$STATE_NAME_NODE = BLOCK [DBG$K_STATE_NAME_SIZE] FIELD (DBG$STATE_NAME_FIELDS) %;

GLOBAL ROUTINE DBG$NPARSE_SHOW (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine comprises the ATN parse network for the SHOW command. The
!	network constructs a command execution tree consisting of a linked list
!	of verb, noun, and possibly adverb nodes which the exectuion network accepts
!	as input.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC -		Descriptor which points to the command input buffer
!
!	VERB_NODE -		The head node in the command execution tree
!
!	MESSAGE_VECT - 		The address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The command execution (parse) tree is constructed and linked to the verb
!	node.
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SEVERE (4) -	Parsing error encountered
!
!	STS$K_SUCCESS (1) - 	Successful parse and construction of the command
!				exectuion tree.
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to the Verb Node

    BIND
    	DBG$CS_ADDRESS  = UPLIT BYTE (%ASCIC 'ADDRESS'),
    	DBG$CS_ALL	= UPLIT BYTE (%ASCIC 'ALL'),
	DBG$CS_BREAK 	= UPLIT BYTE (%ASCIC 'BREAK'),
	DBG$CS_CALLS	= UPLIT BYTE (%ASCIC 'CALLS'),
    	DBG$CS_DEFINE	= UPLIT BYTE (%ASCIC 'DEFINE'),
    	DBG$CS_DEFINED	= UPLIT BYTE (%ASCIC 'DEFINED'),
    	DBG$CS_DEVELOPER= UPLIT BYTE (%ASCIC 'DEVELOPER'),
    	DBG$CS_DIRECT   = UPLIT BYTE (%ASCIC 'DIRECT'),
	DBG$CS_DISPLAY	= UPLIT BYTE (%ASCIC 'DISPLAY'),
    	DBG$CS_DST      = UPLIT BYTE (%ASCIC 'DST'),
    	DBG$CS_GLOBAL	= UPLIT BYTE (%ASCIC 'GLOBAL'),
    	DBG$CS_IN       = UPLIT BYTE (%ASCIC 'IN'),
    	DBG$CS_INPUT	= UPLIT BYTE (%ASCIC 'INPUT'),
    	DBG$CS_KEY	= UPLIT BYTE (%ASCIC 'KEY'),
	DBG$CS_LANGUAGE = UPLIT BYTE (%ASCIC 'LANGUAGE'),
    	DBG$CS_LOCAL	= UPLIT BYTE (%ASCIC 'LOCAL'),
	DBG$CS_LOG 	= UPLIT BYTE (%ASCIC 'LOG'),
    	DBG$CS_MARGINS	= UPLIT BYTE (%ASCIC 'MARGINS'),
    	DBG$CS_MAX_SOURCE_FILES =
    			  UPLIT BYTE (%ASCIC 'MAX_SOURCE_FILES'),
	DBG$CS_MODE	= UPLIT BYTE (%ASCIC 'MODE'),
	DBG$CS_MODULE 	= UPLIT BYTE (%ASCIC 'MODULE'), 
	DBG$CS_OUTPUT 	= UPLIT BYTE (%ASCIC 'OUTPUT'),
	DBG$CS_OVERRIDE	= UPLIT BYTE (%ASCIC 'OVERRIDE'),
    	DBG$CS_RADIX	= UPLIT BYTE (%ASCIC 'RADIX'),
    	DBG$CS_RST      = UPLIT BYTE (%ASCIC 'RST'),
	DBG$CS_SCOPE	= UPLIT BYTE (%ASCIC 'SCOPE'),
    	DBG$CS_SEARCH	= UPLIT BYTE (%ASCIC 'SEARCH'),
	DBG$CS_SELECT	= UPLIT BYTE (%ASCIC 'SELECT'),
    	DBG$CS_SOURCE	= UPLIT BYTE (%ASCIC 'SOURCE'),
	DBG$CS_STEP 	= UPLIT BYTE (%ASCIC 'STEP'),
    	DBG$CS_SYMBOL   = UPLIT BYTE (%ASCIC 'SYMBOL'),
    	DBG$CS_TASK	= UPLIT BYTE (%ASCIC 'TASK'),
	DBG$CS_TERMINAL	= UPLIT BYTE (%ASCIC 'TERMINAL'),
	DBG$CS_TRACE 	= UPLIT BYTE (%ASCIC 'TRACE'),
	DBG$CS_TYPE	= UPLIT BYTE (%ASCIC 'TYPE'),
	DBG$CS_WATCH 	= UPLIT BYTE (%ASCIC 'WATCH'),
	DBG$CS_WINDOW	= UPLIT BYTE (%ASCIC 'WINDOW'),
	DBG$CS_CR 	= UPLIT BYTE (1, DBG$K_CAR_RETURN),
    	DBG$CS_COMMA    = UPLIT BYTE (%ASCIC ','),
        DBG$CS_SLASH	= UPLIT BYTE (%ASCIC '/');

    LOCAL
    	ADVERB_NODE: REF DBG$ADVERB_NODE,!
	LINK,				! Link field to be filled in
    					!      with Adverb Node address
	NOUN_NODE: REF DBG$NOUN_NODE,
	TMP_BUF1: REF VECTOR[,BYTE],
	TMP_BUF2: REF VECTOR[,BYTE];



    ! Recognize keyword
    !
    SELECTONE TRUE OF
	    SET

	    [dbg$nmatch (.input_desc, dbg$cs_break, 1)] :
		BEGIN
		VERB_NODE [DBG$B_VERB_COMPOSITE] = EVENT$K_SHOW_BREAK;
		RETURN DBG$EVENT_SHOW_CANCEL_SYNTAX (.INPUT_DESC,
						     .VERB_NODE,
						     .MESSAGE_VECT
						    );
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_calls, 1)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_calls;

		! May have to accept an integer. In any case, we need a noun node.

		noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
		verb_node [dbg$l_verb_object_ptr] = .noun_node;


		! Start out with -1 for the value of the integer. If the input
		! line is not null, then we will try to obtain an integer.
		!
		IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		THEN
		    BEGIN
		    noun_node [dbg$l_noun_value] = -1;
		    END
		ELSE
		    BEGIN
		    IF NOT dbg$nsave_decimal_integer (.input_desc,
						      noun_node [dbg$l_noun_value],
						      .message_vect)
		    THEN
			RETURN sts$k_severe;
		    END;
		END;


	    ! Handle the SHOW DEFINE command.
	    !
    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DEFINE, 1)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_COMPOSITE] = SHOW_DEFINE;
    		END;


	    ! Handle the SHOW DEVELOPER command.
	    !
    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DEVELOPER, 9)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_COMPOSITE] = SHOW_DEVELOPER;
    		END;


	    ! Handle the SHOW DISPLAY command.
	    !
	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DISPLAY, 3)]:
		BEGIN
		VERB_NODE[DBG$B_VERB_COMPOSITE] = SHOW_DISPLAY;
		DBG$SCR_PARSE_SHODISP_CMD(.INPUT_DESC, .VERB_NODE);
		END;


    	    ! Handle the SHOW KEY command.
    	    !
    	    [dbg$nmatch (.input_desc, dbg$cs_key, 1)]:
                 BEGIN
                 RETURN dbg$nparse_show_key(.input_desc, .verb_node, .message_vect);
                 END;

	    ! Handle the SHOW LANGUAGE command.
	    !
	    [dbg$nmatch (.input_desc, dbg$cs_language, 2)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_language;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_log, 2)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_log;
		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_margins, 3)] :
    		BEGIN
    		verb_node [dbg$b_verb_composite] = show_margins;
    		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_max_source_files, 3)] :
    		BEGIN
    		verb_node [dbg$b_verb_composite] = show_max_source_files;
    		END;

	    [dbg$nmatch (.input_desc, dbg$cs_mode, 1)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_mode;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_module, 4)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_module;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_output, 1)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_output;
		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_radix, 1)]:
    		BEGIN
    		verb_node[dbg$b_verb_composite] = show_radix;
    		WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1) DO
    		    SELECTONE TRUE OF
    			SET

    			! SHOW RADIX/OVERRIDE. Change the verb composite to
    			! indicate this.
    			!
    		        [dbg$nmatch (.input_desc, dbg$cs_override, 1)]:
		    	    verb_node[dbg$b_verb_composite] = show_radix_override;

    			! Ignore /INPUT and /OUTPUT - we will show both on
    			! a SHOW RADIX command anyway.
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_input, 1)]:
    			    0;
    			[dbg$nmatch (.input_desc, dbg$cs_output, 2)]:
    			    0;
    			
    			! Any other condition is an error.
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_cr, 1)]:
    			    SIGNAL (dbg$_needmore);

    			[OTHERWISE]:
    			    BEGIN
    			    LOCAL
    				cs: REF VECTOR[,BYTE],
    				stg_desc: dbg$stg_desc;
    			    cs = dbg$nnext_word(.input_desc);
    			    stg_desc[dsc$b_class] = dsc$k_class_s;
    			    stg_desc[dsc$b_dtype] = dsc$k_dtype_t;
    			    stg_desc[dsc$w_length] = .cs[0];
    			    stg_desc[dsc$a_pointer] = cs[1];
    			    SIGNAL (dbg$_syntax, 1, stg_desc);
    		 	    END;
    			TES;
    		END;

	    [dbg$nmatch (.input_desc, dbg$cs_scope, 2)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_scope;
		END;


	    ! Handle the SHOW SEARCH command.
	    !
    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SEARCH, 2)] :
    		VERB_NODE [DBG$B_VERB_COMPOSITE] = SHOW_SEARCH;


	    ! Handle the SHOW SELECT command.
	    !
	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SELECT, 3)]:
		VERB_NODE[DBG$B_VERB_COMPOSITE] = SHOW_SELECT;


	    ! Handle the SHOW SOURCE command.
	    !
    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SOURCE, 2)] :
    		VERB_NODE[DBG$B_VERB_COMPOSITE] = SHOW_SOURCE;


	    [dbg$nmatch (.input_desc, dbg$cs_step, 1)] :
		BEGIN
		verb_node [dbg$b_verb_composite] = show_step;
		END;


    	    ! SHOW SYMBOL[/qulifier...] namespec[,namespec...] [IN scope[,scope...]]
    	    !
    	    [dbg$nmatch (.input_desc, dbg$cs_symbol, 2)]:  
    		BEGIN
    		LOCAL
    		    addr_flag,			! /ADDRESS
    		    data_list: ref vector[,long],! A link list of data 
    						! symbols (A,B,C)
    		    global_flag,		! (Only valid for defined
    						! symbols) - TRUE to show
    						! globally defined symbols
    						! (the default); false
    						! for /LOCAL symbols
    		    type_flag;			! /TYPE

    		! Initialize flags.
    		!
    		global_flag = TRUE;
    		addr_flag = FALSE;
    		type_flag = FALSE;


    		! Indicate that the command was SHOW SYMBOL.
    		!
    		verb_node [dbg$b_verb_composite] = show_symbol;


    		! Check to see if there is/are qualifier(s) for this command.
    		! If there is/are, then constructs adverb node(s) for it.
    		! /DST and /RST are valid, only if the flag is set to DEVELOPER.
    		!
    		link = verb_node [dbg$l_verb_adverb_ptr];
    		WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1) DO
    		    BEGIN


    		    ! Case on the qualifier.
    		    !
    		    SELECTONE TRUE OF
    			SET


    			! SHOW SYM/ADDRESS.  Construct an Adverb Node and link
			! it in.
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_address, 1)]:
    			    BEGIN
    			    addr_flag = TRUE;
    		            adverb_node = dbg$get_tempmem (dbg$k_adverb_node_size);
    		    	    .link = .adverb_node;
    			    link = adverb_node [dbg$l_adverb_link];
    			    adverb_node [dbg$b_adverb_literal] = symbol_address;
    			    END;


    			! SHOW SYM/DEFINED.  This qualifier restricts the
			! search to the defined symbols.
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_defined, 2)]:
    			    BEGIN
    			    verb_node [dbg$b_verb_composite] = show_symbol_defined;
    			    END;


    			! SHOW SYM/DIRECT.  Construct an Adverb Node and link it in.
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_direct, 2)]:
    			    BEGIN
    		            adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
    		    	    .link = .adverb_node;
    			    link = adverb_node [dbg$l_adverb_link];
    			    adverb_node [dbg$b_adverb_literal] = symbol_direct;
    			    END;


    			! SHOW SYM/DEFINE/GLOBAL
			!
    			[dbg$nmatch (.input_desc, dbg$cs_global, 1)]:
    			    BEGIN
    			    global_flag = TRUE;
    			    END;


    			! SHOW SYM/DEFINED/LOCAL
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_local, 1)]:
    			    BEGIN
    			    global_flag = FALSE;
    			    END;


    			! SHOW SYM/TYPE.  Construct an Adverb Node and link
			! it in.
    			!
    			[dbg$nmatch (.input_desc, dbg$cs_type, 1)]:
    			    BEGIN
    			    type_flag = TRUE;
    		            adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
    		    	    .link = .adverb_node;
    			    link = adverb_node [dbg$l_adverb_link];
    			    adverb_node [dbg$b_adverb_literal] = symbol_type;
    			    END;


    			! The remaining two are only allowed if developer 
    			! bit 0 is set.
    			!
    			[OTHERWISE]: 
    			    BEGIN
    			    IF .DBG$GL_DEVELOPER[0]
    			    THEN
    				BEGIN
    				SELECTONE TRUE OF
    				    SET

    				    ! SHOW SYM/RST.  Construct and Adverb Node
				    ! and link it in.
    				    !
    				    [dbg$nmatch (.input_desc, dbg$cs_rst, 3)]:
    					BEGIN
    					adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
    		    	    		.link = .adverb_node;
    					link = adverb_node [dbg$l_adverb_link];
    					adverb_node [dbg$b_adverb_literal] = symbol_rst;
    					END;

    				    ! SHOW SYM/DST.  Construct and Adverb Node
				    ! and link it in.
				    !
    				    [dbg$nmatch (.input_desc, dbg$cs_dst, 3)]:
    			    		BEGIN
    					adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
					.link = .adverb_node;
					link = adverb_node [dbg$l_adverb_link];
					adverb_node [dbg$b_adverb_literal] = symbol_dst;
					END;

				    ! Any other qualifier is an error.
				    !
				    [OTHERWISE]:
					BEGIN
					.message_vect = 
					(
					IF dbg$nmatch(.input_desc, dbg$cs_cr, 1)
					THEN
					    dbg$nmake_arg_vect(dbg$_needmore)
					ELSE
					    dbg$nsyntax_error(dbg$nnext_word(.input_desc))
					);

					RETURN sts$k_severe;
					END;

				    TES;

    			        END		! Checking for /RST, /DST

    			    ELSE
    				BEGIN
    			        .message_vect = 
    			        (
    			         IF dbg$nmatch(.input_desc, dbg$cs_cr, 1)
    			         THEN
    				    dbg$nmake_arg_vect(dbg$_needmore)
    			         ELSE
    				    dbg$nsyntax_error(dbg$nnext_word(.input_desc))
    			        );

    			        RETURN sts$k_severe;
    			        END;

    			    END;

    			TES;		! End of selecting qualifiers.

    		    END;		! End of While Slash Loop.


    		! Put a 0 in the last link field in verb_node's adverb_node_ptr
    		! field or adverb_node's link field.
    		!
    		.link = 0;


    		! If the command was SHOW SYMBOL/DEFINED, then
    		! there better not have been any qualifiers other than /GLOBAL
    		! or /LOCAL.
    		!
    		IF .verb_node [dbg$l_verb_adverb_ptr] NEQ 0
    		THEN
    		    IF .verb_node [dbg$b_verb_composite] EQL show_symbol_defined
    		    THEN
    			BEGIN
    			.message_vect = dbg$nmake_arg_vect (dbg$_incomqual);
    			RETURN sts$k_severe;
    			END;

    		! Construct the noun node for pointers to symbol name and 
    		! scope list.
    		! 
	        noun_node = dbg$get_tempmem(dbg$k_noun_node_size);
    		verb_node [dbg$l_verb_object_ptr] = .noun_node;
	        link = noun_node [dbg$l_noun_value];
    		WHILE TRUE DO
    		    BEGIN
    		    data_list = dbg$get_tempmem(3);
    		    .link = .data_list;
    		    link = data_list[0];


    		    ! For language C, we do some fancy footwork to
    		    ! make sure we preserve the original casing of
    		    ! the identifier (since casing is significant
    		    ! in C).
    		    !
    		    IF .dbg$gb_language EQL dbg$k_c
    		    THEN
    		 	BEGIN
    			MAP
    			    input_desc: REF dbg$stg_desc;
    			LOCAL
    			    length,
    			    new_pointer: REF VECTOR [,BYTE],
    					! Pointer to orig. command input
    			    pointer,	! Pointer into input string
    			    stg_desc: dbg$stg_desc, ! String descriptor
    			    temp_ptr;


    			! First check for no more input.
    			!
    			IF dbg$nmatch(.input_desc, dbg$cs_cr, 1)
    			THEN
    			    SIGNAL(dbg$_needmore);

    			pointer = .input_desc[dsc$a_pointer];
	    		IF (.pointer LSS .dbg$gl_upcase_command_ptr[0]) OR
	       		   (.pointer GTR .dbg$gl_upcase_command_ptr[1])
    	    		THEN
    			    $DBG_ERROR('DBGNSHOW\DBG$NPARSE_SHOW 10');

    			! If we might be looking at %LABEL then don't
    			! go back to original case.
    			!
    			length = .input_desc[dsc$w_length];
    		        IF CH$EQL(6, .pointer, 6, UPLIT BYTE('%LABEL'))
    			THEN
    			    new_pointer = .pointer
    			ELSE
    			    BEGIN

    			    ! We unfortunately have to allocate memory
    			    ! and copy strings in order to stuff a
    			    ! trailing carriage return at the end.
    			    !
	    		    new_pointer = dbg$get_tempmem((.length+3)/4);
    			    temp_ptr = (.pointer - .dbg$gl_upcase_command_ptr[0]) + 
    			                .dbg$gl_orig_command_ptr;
    			    CH$MOVE (.length, .temp_ptr, .new_pointer);
    			    new_pointer[.length-1] = dbg$k_car_return;
    			    END;

    			! Fill in the string descriptor.
    			!
    			stg_desc[dsc$b_class] = dsc$k_class_s;
    			stg_desc[dsc$b_dtype] = dsc$k_dtype_t;
    			stg_desc[dsc$w_length] = .length;
    			stg_desc[dsc$a_pointer] = .new_pointer;
    			stg_desc[dsc$l_pos] = 0;

    		        ! Pick up the symbol name.
    		        !
    		        IF NOT dbg$nsave_string( stg_desc, data_list[1],
    						.message_vect)
    		        THEN
    		            RETURN sts$k_severe;

    			! Update the input descriptor.
    			!
    			input_desc[dsc$w_length] = .input_desc[dsc$w_length] -
    			    (.length - .stg_desc[dsc$w_length]);
    			input_desc[dsc$a_pointer] = .input_desc[dsc$a_pointer] +
    			    (.length - .stg_desc[dsc$w_length]);
    			END

    		    ! All other languages besides C ...
    		    !
    		    ELSE

    		        ! Pick up the symbol name.
    		        !
    		        IF NOT dbg$nsave_string(.input_desc, data_list[1],
    						.message_vect)
    		        THEN
    		            RETURN sts$k_severe;


    		    ! For SHOW SYM/DEFINED, fill in the adjective field in the
    		    ! noun node with an encoding of the flags.
    		    !
    		    noun_node [dbg$l_adjective_ptr] = (.addr_flag * 4)+
    						      (.global_flag * 2) +
    						      (.type_flag);

    		    ! For ordinary SHOW SYMBOL, need to fix up %LABEL n and
    		    ! also pick up the IN clause.
    		    !
    		    IF .verb_node [dbg$b_verb_composite] NEQ show_symbol_defined
    		    THEN
    		        BEGIN

    		        ! Check data symbol for special case %label n.
    		        ! First pick up %LABEL, then pick up n.  Then concatenate
    		        ! two strings with 1 space in between.
    		        !
    		        tmp_buf1 = .data_list[1];
		        IF CH$FIND_CH(.tmp_buf1[0], tmp_buf1[1],
    					%C'\')
    			THEN
    			    SIGNAL(dbg$_pathnotacp, 1, tmp_buf1[0]);

    		        IF CH$EQL(.tmp_buf1[0], tmp_buf1[1], 6, UPLIT BYTE('%LABEL'))
    		        THEN
    		            BEGIN
    		            IF NOT dbg$nsave_string(.input_desc, data_list[1],
    					    		.message_vect)
    		            THEN
    			        RETURN sts$k_severe;

    		            tmp_buf2 = .data_list[1];
		   	    data_list[1] = dbg$get_tempmem
    			    	((.tmp_buf1[0] + .tmp_buf2[0] + 1) / 4 + 1);
    		            .data_list[1] = .tmp_buf1[0] + .tmp_buf2[0] + 1;
    		            CH$MOVE(.tmp_buf1[0], tmp_buf1[1], 
    			    	.data_list[1] + 1);
    		            CH$MOVE(1, UPLIT BYTE(' '),
    			    	.data_list[1] + .tmp_buf1[0] + 1);
    		            CH$MOVE(.tmp_buf2[0], tmp_buf2[1],
    			    	.data_list[1] + .tmp_buf1[0] + 2);

    			    END;

    			END;

		    IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    		    THEN
    			EXITLOOP;
    		    END;		! End of building the data list.

	        .link = 0;


	        ! See if there is keyword IN followed the symbol name.
    		! If it is, pick up the scope list.
    		!
    		IF .verb_node [dbg$b_verb_composite] NEQ show_symbol_defined
    		THEN
    		    BEGIN
    		    IF dbg$nmatch (.input_desc, dbg$cs_in, 2)
    		    THEN
    		        BEGIN
    		        IF NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)
    		        THEN
    			    BEGIN
    			    IF NOT dbg$nparse_scope_list(.input_desc, noun_node[dbg$l_noun_value2],
    					             .message_vect)
    		            THEN
    			        RETURN sts$k_severe;
    			    END

    		        ELSE
    			    BEGIN
    			    .message_vect = dbg$nmake_arg_vect(dbg$_needmore);
    			    RETURN sts$k_severe;
    			    END;
    			END;
    		    END;


    		! End of the command buffer. (we hope)
    		!
    		IF NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)
    		THEN
    		    BEGIN
    		    .message_vect = dbg$nsyntax_error(dbg$nnext_word(.input_desc));
    		    RETURN sts$k_severe;
    		    END;

    		END;			! End of SHOW SYMBOL Parsing.
    			

    	    ! Handle the SHOW TASK command.
    	    !
	    [IF NOT .DBG$GL_DEVELOPER[0] THEN FALSE ELSE
	     DBG$NMATCH (.INPUT_DESC, DBG$CS_TASK, 2)]:
    		BEGIN
    		VERB_NODE[DBG$B_VERB_COMPOSITE] = SHOW_TASK;
    		DBG$NPARSE_SHOW_TASK(.INPUT_DESC, .VERB_NODE);
    		END;


	    ! Handle the SHOW TERMINAL command.
	    !
	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_TERMINAL, 4)]:
		VERB_NODE[DBG$B_VERB_COMPOSITE] = SHOW_TERMINAL;


	    ! Handle the SHOW TRACE command.
	    !
	    [dbg$nmatch (.input_desc, dbg$cs_trace, 1)] :
		BEGIN
		VERB_NODE [DBG$B_VERB_COMPOSITE] = EVENT$K_SHOW_TRACE;
		RETURN DBG$EVENT_SHOW_CANCEL_SYNTAX (.INPUT_DESC,
						     .VERB_NODE,
						     .MESSAGE_VECT
						    );
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_type, 2)] :
		BEGIN


		! We may have SHOW TYPE or SHOW TYPE/OVERRIDE.
		! Check for slash
		!
		IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
		THEN
		    BEGIN

		    IF NOT dbg$nmatch (.input_desc, dbg$cs_override, 1)
		    THEN
			BEGIN
			.message_vect =
			(IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
			THEN
			    dbg$nmake_arg_vect (dbg$_needmore)
			ELSE
			    dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
			RETURN sts$k_severe;
			END;
		    verb_node [dbg$b_verb_composite] = show_type_override;
		    END
		ELSE
		    BEGIN
		    verb_node [dbg$b_verb_composite] = show_type;
		    END;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_watch, 1)] :
		BEGIN
		VERB_NODE [DBG$B_VERB_COMPOSITE] = EVENT$K_SHOW_WATCH;
		RETURN DBG$EVENT_SHOW_CANCEL_SYNTAX(
			.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT);
		END;


	    ! Handle the SHOW WINDOW command.
	    !
	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_WINDOW, 3)]:
		BEGIN
		VERB_NODE[DBG$B_VERB_COMPOSITE] = SHOW_WINDOW;
		DBG$SCR_PARSE_SHOWIND_CMD(.INPUT_DESC, .VERB_NODE);
		END;


	    ! Any other kind of SHOW command constitutes a syntax error.
	    !
	    [OTHERWISE] : ! Parsing error
		BEGIN
		IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		THEN
		    .message_vect = dbg$nmake_arg_vect (dbg$_needmore)
		ELSE
		    .message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
		RETURN sts$k_severe;
		END;

	    TES;

    RETURN STS$K_SUCCESS;

    END;

ROUTINE dbg$nparse_show_key (input_desc, verb_node, message_vect) =
!++
! Functional Description
!
!	This is the parse network for the SHOW KEY command.
!
! Routine Inputs
!
!	input_desc	-	A pointer to a string descriptor for the 
!				    remaining input.
!	verb_node	-	A pointer to the verb node for the SHOW
!				    KEY command, which will be the top-level
!				    node in the command execution tree.
!	message_vect	-	A pointer to an error message vector.
!
! Routine Outputs
!
!	A command execution tree is constructed starting at the verb
! 	node:
!
!	 ------      ------ 
!	| VERB | -> | NOUN |
!	 ------      ------ 
!           |			The DBG$B_VERB_COMPOSITE field contains a
!	 -------		value for the SHOW KEY command.
!	|ADVERB0|
!	 -------		The noun node has the following information:
!	    |
!	 -------		DBG$L_NOUN_VALUE - A pointer to a descriptor
!	|ADVERB1|			that contains the key-name.
!	 -------
!	    :
!	 -------
!	|ADVERB3|		The adverb nodes appear as follows:
!	 -------
!				DBG$L_ADVERB_VALUE - Value or location of data
!					for this qualifier.
!				DBG$L_ADVERB_LINK - Link to next Adverb-node.
!
!	The string descriptor is updated to point past the
!	input that has been parsed. A completion code is returned:
!
!	STS$K_SUCCESS - The input was successfully parsed.
!	STS$K_SEVERE -  There were errors during the parse. An error
!			message vector is constructed and returned
!			in message_vect.
!--
    BEGIN

    MAP
	input_desc		: REF BLOCK [,BYTE],	! String descriptor
        verb_node		: REF dbg$verb_node;

    BIND
	dbg$cs_all		= UPLIT BYTE (3, 'ALL'),
	dbg$cs_brief		= UPLIT BYTE (5, 'BRIEF'),
	dbg$cs_directory	= UPLIT BYTE (9, 'DIRECTORY'),
	dbg$cs_state		= UPLIT BYTE (5, 'STATE'),
	dbg$cs_nostate		= UPLIT BYTE (7, 'NOSTATE'),
	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
	dbg$cs_right_paren	= UPLIT BYTE (1, dbg$k_right_parenthesis),
	dbg$cs_comma		= UPLIT BYTE (1, dbg$k_comma),
	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
	dbg$cs_equal		= UPLIT BYTE (1, dbg$k_equal),
	dbg$cs_slash		= UPLIT BYTE (1, dbg$k_slash);

    LITERAL
	dbg$k_lowest_qualifier	= 0,	! These correspond to the adverb nodes
	dbg$k_directory		= 0,	! of the tree that is being constructed.
	dbg$k_all		= 1,
	dbg$k_brief		= 2,
	dbg$k_state		= 3,
	dbg$k_highest_qualifier = 3;

    LOCAL
        all_flag		: INITIAL(FALSE),	! True if /ALL
        dir_flag		: INITIAL(FALSE),	! True if /DIRECTORY
	define_kind		: INITIAL(0),		! Value of DELETE/KEY qualifier
    	noun_node       	: REF dbg$noun_node,	! Pointer to a noun node
    	new_noun_node   	: REF dbg$noun_node,	! Another pointer to a noun node
	adverb_node     	: REF dbg$adverb_node,	! Pointer to a noun node
	new_adverb_node 	: REF dbg$adverb_node,	! Another pointer to a adverb node
	state_name_node		: REF dbg$state_name_node,	! Pointer to a state-name node
	new_state_name_node	: REF dbg$state_name_node,	! Another pointer to a state-name node
    	ptr			: REF VECTOR[,BYTE],	! Points into input string
    	status,
        temp_key_desc		: REF dbg$stg_desc,	! String desc. for DELETE/KEY symbols
        define_key_value;				! Value for the qualifier


    ! Check whether we are on a system that allows keypad input.
    !
    IF NOT .dbg$gb_keypad_input
    THEN
        SIGNAL(dbg$_nokeydef);

    ! Fill in the fact that this is a SHOW KEY command in the verb node.
    ! And clear the noun link value.
    !
    verb_node [dbg$b_verb_composite] = show_key;
    verb_node [dbg$l_verb_object_ptr] = 0;

    ! Build adverb list with defaults.
    !

    new_adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);	! Get first node

    verb_node [dbg$l_verb_adverb_ptr] = .new_adverb_node;
    adverb_node = .new_adverb_node;

    adverb_node [dbg$b_adverb_literal] = dbg$k_lowest_qualifier;	! Initialize first node
    adverb_node [dbg$l_adverb_value]   = 0;
    adverb_node [dbg$l_adverb_link]    = 0;

    define_kind = dbg$k_lowest_qualifier + 1;
    WHILE .define_kind LEQ dbg$k_highest_qualifier DO		! Build rest of adverb list
	BEGIN
        new_adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
        adverb_node [dbg$l_adverb_link] = .new_adverb_node;
        adverb_node = .new_adverb_node;

        adverb_node [dbg$b_adverb_literal] = .define_kind;
        IF .define_kind EQL dbg$k_state
        THEN
            BEGIN
            ! For the adverb node that has state-name information, the default
            ! is set up so that the adverb node points to a state-name node that
            ! points to a descriptor that contains the state-name.
            !
            temp_key_desc = dbg$get_tempmem(2);
            temp_key_desc [dsc$w_length]  = 0;
            temp_key_desc [dsc$b_dtype]   = dsc$k_dtype_t;
            temp_key_desc [dsc$b_class]   = dsc$k_class_d;
            temp_key_desc [dsc$a_pointer] = 0;

            ! This routine returns the current state name.
            !
            smg$set_default_state(dbg$gl_key_table_id, 0, .temp_key_desc);

            state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
            state_name_node [dbg$l_state_name_link] = 0;
            adverb_node [dbg$l_adverb_value] = .state_name_node;
            END
        ELSE
            ! In all other cases, the default value is set to zero
            !
            adverb_node [dbg$l_adverb_value] = 0;

        define_kind = .define_kind + 1;
        END;
    adverb_node [dbg$l_adverb_link] = 0;

    WHILE (NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)) AND
          (.input_desc [dsc$w_length] GTR 0) DO

        BEGIN
        IF dbg$nmatch(.input_desc, dbg$cs_slash, 1)
        THEN
            BEGIN

            ! Find out what kind of qualifier it is
            !
            ! Initialize value

            define_key_value = 0;

            ! Set Define_key with qualifier code, and get value of define_key_value.

            SELECTONE TRUE  OF
                SET

                [dbg$nmatch(.input_desc, dbg$cs_all, 1)] :
                    BEGIN
                    ! Check if a key-name has already been found, this makes the
                    ! /ALL invalid.
                    !
                    IF .verb_node [dbg$l_verb_object_ptr] NEQ 0
                    THEN
                        SIGNAL(dbg$_conflict);
                    define_kind = dbg$k_all;
                    define_key_value = 1;
                    all_flag = TRUE;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_nostate, 3)] :
                    BEGIN
                    define_key_value = 0;
                    define_kind = dbg$k_state;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_state, 1)] :
                    BEGIN
		    define_key_value = 0;
                    define_kind = dbg$k_state;

                    temp_key_desc = dbg$get_tempmem(2);
                    temp_key_desc[dsc$w_length]  = 0;
                    temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                    temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                    temp_key_desc[dsc$a_pointer] = 0;

                    ! Look for =
		    !

		    IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
		    THEN
                        report_error;

		    ! Look for a left paren
		    !

		    IF dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
		    THEN
                        BEGIN

                        ! Pick up the first state name
		        !
                        status = dbg$read_key_info (.input_desc,
                                                    .temp_key_desc,
                                                    .message_vect);
		        IF NOT .status
		        THEN
		            RETURN sts$k_severe;

                        new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                        state_name_node = .new_state_name_node;
                        state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                        state_name_node [dbg$l_state_name_link] = 0;
                        define_key_value = .state_name_node;

                        WHILE dbg$nmatch (.input_desc, dbg$cs_comma, 1) DO
                            BEGIN
                            temp_key_desc = dbg$get_tempmem(2);
                            temp_key_desc[dsc$w_length]  = 0;
                            temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                            temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                      	    temp_key_desc[dsc$a_pointer] = 0;

                            ! Pick up the next state name
                            !
                            status = dbg$read_key_info (.input_desc,
                                                        .temp_key_desc,
                                                        .message_vect);
			    IF NOT .status
			    THEN
			        RETURN sts$k_severe;

                            new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                            state_name_node [dbg$l_state_name_link] = .new_state_name_node;
                            state_name_node = .new_state_name_node;
                            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                            state_name_node [dbg$l_state_name_link] = 0;

                            END;

                        ! Eat right paren
			!

			IF NOT dbg$nmatch (.input_desc, dbg$cs_right_paren, 1)
			THEN
                            report_error;

                        END

                    ELSE
                        BEGIN

                        ! Pick up the only state name
                        !

                        status = dbg$read_key_info (.input_desc,
                                                    .temp_key_desc,
                                                    .message_vect);
	                IF NOT .status
		        THEN
		            RETURN sts$k_severe;

                        new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                        state_name_node = .new_state_name_node;
                        state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                        state_name_node [dbg$l_state_name_link] = 0;
                        define_key_value = .state_name_node;

                        END;

                    END;

                [dbg$nmatch(.input_desc, dbg$cs_brief, 1)] :
                    BEGIN
                    define_key_value = 1;
                    define_kind = dbg$k_brief;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_directory, 1)] :
                    BEGIN
                    IF .verb_node [dbg$l_verb_object_ptr] NEQ 0
                    THEN
                        SIGNAL(dbg$_conflict);
                    dir_flag = TRUE;
                    define_key_value = 1;
                    define_kind = dbg$k_directory;
                    END;

                [OTHERWISE] :
                    report_error;
                TES;

            ! Process the qualifier

            IF .define_key_value NEQ 0
            THEN
                BEGIN
                adverb_node = .verb_node [dbg$l_verb_adverb_ptr];
                WHILE (.adverb_node [dbg$b_adverb_literal] NEQ .define_kind) DO
                    adverb_node = .adverb_node [dbg$l_adverb_link];
                adverb_node [dbg$l_adverb_value] = .define_key_value;

                ! If /STATE=xxxxx was specified, the link field is set to one.
                ! This is done to check for /STATE/DIR in the command,
                ! which is invalid.
                !

                IF .adverb_node [dbg$b_adverb_literal] EQL dbg$k_state
                THEN
                    adverb_node [dbg$l_adverb_link] = 1;
                END;

            END	! End of qualifier search code.

	ELSE

            ! Process key name 

            IF (.verb_node [dbg$l_verb_object_ptr] EQL 0) AND (NOT .all_flag) AND (NOT .dir_flag)
            THEN
		BEGIN

		! Get key name
                !

	        temp_key_desc = dbg$get_tempmem(2);
                temp_key_desc[dsc$w_length]  = 0;
                temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                temp_key_desc[dsc$a_pointer] = 0;
	        status = dbg$read_key_info (.input_desc,
                                            .temp_key_desc,
                                            .message_vect);
	        IF NOT .status
	        THEN
		    RETURN sts$k_severe;

	        ! Make noun node for key-name string
	        !

	        new_noun_node = dbg$get_tempmem(dbg$k_noun_node_size);

	        verb_node [dbg$l_verb_object_ptr] = .new_noun_node;
	        noun_node = .new_noun_node;
	        noun_node [dbg$l_noun_value] = .temp_key_desc;
                noun_node [dbg$l_adjective_ptr] = 0;
                noun_node [dbg$l_noun_link] = 0;
		END

            ELSE
                report_error;

	END;	! End While

    ! Check to see if key-name string or /ALL or /DIRECTORY has been entered.
    ! If not, return a message and error status.
    !

    IF (.verb_node [dbg$l_verb_object_ptr] EQL 0) AND (NOT .all_flag) AND (NOT .dir_flag)
    THEN
        BEGIN
        .message_vect = dbg$nmake_arg_vect(dbg$_needmore);
        RETURN sts$k_severe;
        END;

    RETURN sts$k_success;
    END;


GLOBAL ROUTINE DBG$NEXECUTE_SHOW (VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine accepts a command execution tree as input and performs the
!	semantic actions associated with the SHOW command. Version 2 debugger
!	routines and data structures are utilyzed during command execution.
!
! FORMAL PARAMETERS:
!
!	VERB_NODE -		The first node in the command execution tree
!
!	MESSAGE_VECT - 		The address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	Semantic actions corresponding to the input command are performed. That
!	is, various states of the debugger are displayed.
!
! ROUTINE VALUE:	unsigned longword integer completion code
!
! COMPLETION CODES:
!
!	STS$K_SEVERE (4) - 	The command could not be executed.
!
!	STS$K_SUCCESS (1) - 	The parsed command was executed.
!
! SIDE EFFECTS:
!
!	Output concerning the state of the debugger is displayed to the user.
!
!--

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to command Verb Node



    ! Transfer control to a subnetwork on the basis of the composite verb
    !
    CASE .VERB_NODE[DBG$B_VERB_COMPOSITE] FROM MIN_SHOW TO MAX_SHOW OF
	    SET

	    [show_break] :
		RETURN DBG$EVENT_SHOW_CANCEL_SEMANTICS (.VERB_NODE,
						        .MESSAGE_VECT
						       );

	    [show_calls] :
		BEGIN
		LOCAL
		    EXC_TYPE,		! Exception type (trap=1, fault=2)
		    NOUN_NODE : REF dbg$noun_node;

		noun_node = .verb_node [dbg$l_verb_object_ptr];

		! exception type is based on whether the last exception
		! was a fault, break or step-end
		!
		IF	.dbg$runframe [dbg$v_at_fault] OR
			.dbg$runframe [dbg$v_at_break] OR
			.dbg$runframe [dbg$v_at_step_end]
		THEN	exc_type = fault_exc
		ELSE	exc_type = trap_exc;

		dbg$traceback (.dbg$runframe [dbg$l_user_pc],
			       .dbg$runframe [dbg$l_user_fp],
			       .EXC_TYPE, .NOUN_NODE[DBG$L_NOUN_VALUE]);
		END;

    	    [show_define] :
    		BEGIN
    		dbg$show_define();
    		END;

    	    [show_developer] :
    		BEGIN
    		dbg$print ( 
    			UPLIT BYTE (%ASCIC 'Developer Longword (in hex): !XL'),
    			.dbg$gl_developer);
    		dbg$newline();
    		END;


	    ! Execute the SHOW DISPLAY command.
	    !
	    [SHOW_DISPLAY]:
		DBG$SCR_EXECUTE_SHODISP_CMD(.VERB_NODE);


    	    ! Execute the SHOW KEY command.
    	    !
    	    [show_key]:
    		BEGIN
                
    		LOCAL
    		    status;

                status = dbg$nexecute_show_key(.verb_node, .message_vect);
                IF NOT .status
                THEN
                    RETURN sts$k_severe;
                END;

	    ! Execute the SHOW LANGUAGE command.
	    !
	    [show_language] :
		BEGIN
		$fao_tt_out ('language: !AC', dbg$language (.dbg$gb_language));
		END;

	    [show_log] :
		BEGIN
		dbg$nshow_output (2);     ! 2 stands for "show log" parameter
		END;

    	    [show_margins] :
    		BEGIN
    		dbg$nshow_margins();
    		END;

    	    [show_max_source_files] :
    		BEGIN
    		dbg$nshow_max_source_files();
    		END;

	    [show_mode] :
		BEGIN
		dbg$show_mode ();
		END;

	    [show_module] :
		BEGIN
		dbg$show_module ();
		END;

	    [show_output] :
		BEGIN
		dbg$nshow_output (1);     ! 1 stands for "full rep"
		END;

    	    [show_radix] :
    		BEGIN
    		! Parameter EQL 0  =>  show the SET RADIX radix
    		dbg$show_radix(0);
    		END;

    	    [show_radix_override]:
    		BEGIN
    		! Parameter EQL 1  =>  show the SET RADIX/OVERRIDE radix
    		dbg$show_radix(1);
    		END;

	    [show_scope] :
		BEGIN
		dbg$rst_showscope ();
		END;

    	    [show_search] :
    		BEGIN
    		dbg$show_search ();
    		END;


	    ! Execute the SHOW SELECT command.
	    !
	    [SHOW_SELECT]:
		DBG$SCR_EXECUTE_SHOSEL_CMD(.VERB_NODE);


	    ! Execute the SHOW SOURCE command.
	    !
    	    [SHOW_SOURCE] :
    		DBG$SRC_SHOW_SOURCE();


	    [show_step] :
		BEGIN
		dbg$show_step ();
		END;

	    [show_symbol, show_symbol_defined]:
    		BEGIN
    		LOCAL
    		    addr_flag,
    		    flags,
    		    global_flag,
    		    type_flag,
		    noun_node: REF dbg$noun_node,
    		    name_list: REF VECTOR[,LONG],
    		    status;

    		! Recover the flags.
    		!
		noun_node = .verb_node [dbg$l_verb_object_ptr];
    		flags = .noun_node[dbg$l_adjective_ptr];
    		addr_flag = .flags/4;
    		global_flag = (.flags mod 4)/2;
    		type_flag = .flags mod 2;

    		! Show the non-defined symbols.
    		!
    		IF .verb_node[dbg$b_verb_composite] EQL show_symbol_defined
    		THEN
    		    BEGIN
    		    status = FALSE;
    		    addr_flag = TRUE;
    		    type_flag = TRUE;
    		    END

    		ELSE
    		    status = dbg$sta_showsymbol(.verb_node);


    		! Show the defined symbols as long as no IN clause was
    		! specified.
    		!
    		name_list = .noun_node[dbg$l_noun_value];
    		WHILE .name_list NEQ 0 do
    		    BEGIN
    		    status = .name_list[2] GTR 0;
    		    IF .noun_node[dbg$l_noun_value2] EQL 0
    		    THEN
    		        BEGIN
    		    	IF NOT dbg$dump_define( .name_list[1],
    					    .addr_flag,
    					    .global_flag,
    					    .type_flag,
    					    .status,
    					    .message_vect)
    		        THEN
    		            RETURN sts$k_severe;
    			END
    		    ELSE
    			BEGIN
    			IF NOT .status
    			THEN
    			    SIGNAL(dbg$_symnotfnd, 1, .name_list[1]);
    		    	END;

    		    name_list = .name_list[0];
    		    END;
    		END;


    	    ! Execute the SHOW TASK command.
    	    !
    	    [SHOW_TASK]:
    		BEGIN
    		DBG$NEXECUTE_SHOW_TASK(.VERB_NODE);
    		END;


	    ! Execute the SHOW TERMINAL command.
	    !
	    [SHOW_TERMINAL]:
		BEGIN
		DBG$PRINT(UPLIT BYTE(%ASCIC 'terminal width: !SL'),
						.DBG$SRC_TERM_WIDTH);
		DBG$NEWLINE();
		END;


	    ! Execute the SHOW TRACE command.
	    !
    	    [SHOW_TRACE]:
		RETURN DBG$EVENT_SHOW_CANCEL_SEMANTICS (.VERB_NODE,
							.MESSAGE_VECT);

	    [show_type] :
		BEGIN
		dbg$show_type (default);
		END;

	    [show_type_override] :
		BEGIN
		dbg$show_type (override);
		END;

	    [SHOW_WATCH] :
		RETURN DBG$EVENT_SHOW_CANCEL_SEMANTICS(.VERB_NODE,
							.MESSAGE_VECT);

	    ! Execute the SHOW WINDOW command.
	    !
	    [SHOW_WINDOW]:
		DBG$SCR_EXECUTE_SHOWIND_CMD(.VERB_NODE);


	    ! Any other SHOW command code is an internal DEBUG error.
	    !
	    [INRANGE, OUTRANGE] :
		$DBG_ERROR('DBGNSHOW\NEXECUTE_SHOW');

	    TES;

    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE dbg$nexecute_show_key (verb_node, message_vect) =
!++
! Functional Description
!
!	This routine performs the action associated with the SHOW KEY command.
!
! Routine Inputs
!
!	verb_node -	The head of a command execution tree. This is built
!			by the routine DBG$NPARSE_SHOW_KEY, and its structure
!			is described in the header of that routine.
!	message_vect -	An error message vector.
!
! Routine Outputs
!
!	Information about key definitions are output to the screen.
!
!	The routine value is one of:
!	sts$k_success -	Success code.
!	sts$k_severe -	Error. An error message vector is contructed.
!--
    BEGIN

    MAP 
    	verb_node : REF dbg$verb_node;

    LITERAL
        v_key_noecho	= 0,
        v_key_terminate	= 1,
        v_key_lockstate	= 2,
        v_key_setstate	= 4;

    LOCAL
    	noun_node		: REF dbg$noun_node,	! Points to a noun node
        adverb_node		: REF dbg$adverb_node,	! Points to an adverb node
        found,
	dir_flag,
        all_flag,
        brief_flag,
        show_status,
	attributes		: BITVECTOR [32],
        context			: INITIAL(0),
        temp_if_state_address	: REF dbg$state_name_node,
        if_state_desc_address	: REF dbg$state_name_node,
        desc_ptr		: REF dbg$stg_desc,

        key_name_desc		: dbg$stg_desc,
	if_state_name_desc	: dbg$stg_desc,
	equiv_name_desc		: dbg$stg_desc,
        state_name_desc		: dbg$stg_desc;


        ! Macro to initialize descriptors
        !
	MACRO
            initialize_desc (temp_desc) =
                BEGIN
                temp_desc [dsc$w_length] = 0;
                temp_desc [dsc$b_dtype]  = dsc$k_dtype_t;
                temp_desc [dsc$b_class]  = dsc$k_class_d;
                temp_desc [dsc$a_pointer]= 0;
                END %;

        !+
        !      We will set up the noun and verb pointers and proceed to walk
        ! down the adverb list with the knowledge that the qualifier information
        ! is in order.  After checking the qualifiers, a call is made to the
        ! routine SMG$GET_KEY_DEF to get the key information; if the /ALL
        ! qualifier exits then calls are made to SMG$LIST_KEY_DEFS to get all
        ! the key definitions in the table.  A call is also made for each
        ! state specified by the State qualifier.
        !      Then exit successfully, unless some error was found on the way.
        !-

        noun_node   = .verb_node [dbg$l_verb_object_ptr];
        adverb_node = .verb_node [dbg$l_verb_adverb_ptr];

        ! DIRECTORY qualifier

        dir_flag = .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! ALL qualifier

        all_flag = .adverb_node [dbg$l_adverb_value];
	IF (.dir_flag) AND (.all_flag)
        THEN
            SIGNAL(dbg$_conflict);
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! BRIEF qualifier

        brief_flag = .adverb_node [dbg$l_adverb_value];
	IF (.dir_flag) AND (.brief_flag)
        THEN
            SIGNAL(dbg$_conflict);
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! STATE qualifier (Note: if /STATE=xxxxx was specified the link field will be one)

        if_state_desc_address = .adverb_node [dbg$l_adverb_value];
	IF (.dir_flag) AND (.adverb_node [dbg$l_adverb_link] EQL 1)
        THEN
            SIGNAL(dbg$_conflict);
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! If the /DIRECTORY qualifier exists
        !
        
        IF .dir_flag
        THEN
            BEGIN
            if_state_desc_address = 0;
            temp_if_state_address = 0;
            END;

        WHILE .dir_flag DO	! i.e. while true do
            BEGIN
            initialize_desc (if_state_name_desc);

            ! Get a state name of some key.
            !
            show_status = smg$list_key_defs (dbg$gl_key_table_id,
                                             context,
                                             0,
                                             if_state_name_desc);
            IF NOT .show_status
            THEN
                IF .show_status EQL smg$_nomorekeys
                THEN
                    BEGIN
                    ! Output list of states, if no more new key definitions 
                    ! can be found.
                    !
                    WHILE .if_state_desc_address NEQ 0 DO
                         BEGIN
                         dbg$print (UPLIT BYTE (%ASCIC '!AS'),
                                    .if_state_desc_address [dbg$l_state_name_ptr]);
                         dbg$newline();
                         if_state_desc_address = .if_state_desc_address [dbg$l_state_name_link];
                         END;
                    RETURN sts$k_success;
                    END
                ELSE
                    SIGNAL(dbg$_shokeyerr);

            found = FALSE;
            WHILE .temp_if_state_address NEQ 0 DO
                BEGIN
                ! Look to see if a key has already been found with this state
                ! If so, advance the pointer to the next state-node, else, a
                ! key with this state has been found and a new node need not
                ! be added to the list of state names.
                !
                desc_ptr = .temp_if_state_address [dbg$l_state_name_ptr];
                IF 0 EQL str$compare_eql(.desc_ptr, if_state_name_desc)
                THEN
                    BEGIN
                    found = TRUE;
                    EXITLOOP;
                    END
                ELSE
                    temp_if_state_address = .temp_if_state_address [dbg$l_state_name_link];
                END;
            IF NOT .found
            THEN
                BEGIN
                ! If a key has not been found that has this state yet,
                ! add the state to a list for output.
                !
                temp_if_state_address = dbg$get_tempmem(dbg$k_state_name_size);
                temp_if_state_address [dbg$l_state_name_link] = .if_state_desc_address;
                if_state_desc_address = .temp_if_state_address;

                desc_ptr = dbg$get_tempmem(2);
                desc_ptr [dsc$w_length]  = .if_state_name_desc [dsc$w_length];
                desc_ptr [dsc$b_dtype]   = dsc$k_dtype_t;
                desc_ptr [dsc$b_class]   = dsc$k_class_d;
                desc_ptr [dsc$a_pointer] = .if_state_name_desc [dsc$a_pointer];
                
                temp_if_state_address [dbg$l_state_name_ptr] = .desc_ptr;
                END;
            END;

        ! If the /DIRECTORY qualifier does not exist
        !

        WHILE .if_state_desc_address NEQ 0 DO
            BEGIN
            ! Output the keys for each seperate state that is specified
            !
            dbg$newline();
            dbg$print(UPLIT BYTE (%ASCIC '!AS keypad definitions:'),
                      .if_state_desc_address [dbg$l_state_name_ptr]);
            dbg$newline();
            context = 0;
            WHILE TRUE DO
                BEGIN
                ! Look at each key that has been defined and determine whether
                ! it has the right state to be output in this list.
                !

                initialize_desc(key_name_desc);
                initialize_desc(if_state_name_desc);
                initialize_desc(state_name_desc);
                initialize_desc(equiv_name_desc);

                show_status = smg$list_key_defs (dbg$gl_key_table_id,
                                                 context,
                                                 key_name_desc,
                                                 if_state_name_desc,
                                                 attributes,
                                                 equiv_name_desc,
                                                 state_name_desc);
                IF NOT .show_status
                THEN
                    IF .show_status EQL smg$_nomorekeys
                    THEN
                        EXITLOOP
                    ELSE
                        SIGNAL(dbg$_shokeyerr);

                ! If all keys are to be output, or if just a key with this name,
                ! go into this condition.
                !
                IF (.all_flag) OR (0 EQL str$compare_eql(key_name_desc, .noun_node [dbg$l_noun_value]))
                THEN
                    ! If the state-names match, then this key is to be output.
                    !
                    IF 0 EQL str$compare_eql(if_state_name_desc, .if_state_desc_address [dbg$l_state_name_ptr])
                    THEN
                        BEGIN
                        ! Print out key information
                        !
                        dbg$print(UPLIT BYTE (%ASCIC '  !AS = "!AS"'), key_name_desc, equiv_name_desc);
                        IF NOT .brief_flag
                        THEN
                            BEGIN
                            IF .attributes [v_key_noecho]
                            THEN
                                dbg$print(UPLIT BYTE (%ASCIC '  (noecho'))
                            ELSE
                                dbg$print(UPLIT BYTE (%ASCIC '  (echo'));
                            IF .attributes [v_key_terminate]
                            THEN
                                dbg$print(UPLIT BYTE (%ASCIC ',terminate'))
                            ELSE
                                dbg$print(UPLIT BYTE (%ASCIC ',noterminate'));
                            IF .attributes [v_key_lockstate]
                            THEN
                                dbg$print(UPLIT BYTE (%ASCIC ',lock'))
                            ELSE
                                dbg$print(UPLIT BYTE (%ASCIC ',nolock'));
                            IF .attributes [v_key_setstate]
                            THEN
                                dbg$print(UPLIT BYTE (%ASCIC ',state=!AS)'), state_name_desc)
                            ELSE
                                dbg$print(UPLIT BYTE (%ASCIC ')'));
                            END;
                        dbg$newline();
                        END;
                END;
            ! Move the state-name-pointer ahead one
            !
            if_state_desc_address = .if_state_desc_address [dbg$l_state_name_link];
            END;

        RETURN sts$k_success;
        END;

GLOBAL ROUTINE DBG$NSHOW_MARGINS : NOVALUE =
!++
! FUNCTION
!
!	This routine implements the SHOW MARGINS command.
!
! INPUTS
!
!	The global variables DBG$SRC_LEFT_MARGIN and DBG$SRC_RIGHT_MARGIN.
!
! OUTPUTS
!
!	Margin settings are displayed at the terminal.
!
!--
    BEGIN

    ! Set up the output buffer
    !
    dbg$flushbuf();

    dbg$print (UPLIT BYTE(%ASCIC 'left margin: !UL , right margin: !UL'),
    		 .dbg$src_left_margin, .dbg$src_right_margin);
    dbg$newline();

    END; ! dbg$nshow_margins

GLOBAL ROUTINE DBG$NSHOW_MAX_SOURCE_FILES : NOVALUE =
!++
! FUNCTION
!
!	This routine implements the SHOW MAX_SOURCE_FILES command.
!
! INPUTS
!
!	The global variable DBG$SRC_MAX_SOURCE_FILES.
!
! OUTPUTS
!
!	The value is displayed at the terminal.
!
!--
    BEGIN

    ! Set up the output buffer
    !
    dbg$flushbuf();

    dbg$print (UPLIT BYTE(%ASCIC 'max_source_files: !UL'),
    		 .dbg$src_max_files);
    dbg$newline();

    END; ! dbg$nshow_max_source_files

GLOBAL ROUTINE DBG$NSHOW_OUTPUT (FULL_REP) : NOVALUE =
!
! FUNCTION
!	This routine prints the output for the SHOW OUTPUT and SHOW LOG
!	commands.  The output for the SHOW LOG command is a subset of the
!	output for the SHOW OUTPUT command, for which reason both commands
!	are handled in the same routine.
!
! INPUTS
!	FULL_REP - Equals 1 for a SHOW OUTPUT report and equals 2 for SHOW LOG.
!
! OUTPUTS
!	NONE
!

    BEGIN

    BIND
	DEFLOG_NAME = UPLIT BYTE ('DEBUG.LOG'),
	DEFLOG_SIZE = %CHARCOUNT ('DEBUG.LOG');

    LOCAL
	FNAME_LEN,			! Length of log file's file name
	FNAME_PTR;			! Pointer to log file's file name



    ! If a SHOW OUTPUT command was entered, we print the full representation of
    ! the output settings.  We start by printing the settings of the VERIFY,
    ! TERMINAL, and SCREEN_LOG switches.
    !
    IF .FULL_REP
    THEN
	BEGIN


	! Print the "verify" or "noverify" switch setting.
	!
	IF NOT .DBG$GB_DEF_OUT[OUT_VERIFY]
	THEN
	    DBG$PRINT(UPLIT BYTE(%ASCIC 'no'), 0);

	DBG$PRINT(UPLIT BYTE(%ASCIC 'verify, '), 0);


	! Print the "terminal" or "noterminal" switch setting.
	!
	IF NOT .DBG$GB_DEF_OUT[OUT_TERM]
	THEN
	    DBG$PRINT(UPLIT BYTE(%ASCIC 'no'), 0);

	DBG$PRINT(UPLIT BYTE(%ASCIC 'terminal, '), 0);


	! Print the "screen_log" or "noscreen_log" switch setting.
	!
	IF NOT .DBG$GB_DEF_OUT[OUT_SCREEN]
	THEN
	    DBG$PRINT(UPLIT BYTE(%ASCIC 'no'), 0);

	DBG$PRINT(UPLIT BYTE(%ASCIC 'screen_log, '), 0);
	END;


    ! Now print whether we are logging or not and print the name of the current
    ! log file.  If log file has been specified, we report the file name in the
    ! NAM block; otherwise, we use the default log-file file name.  Note that
    ! this output is done for both the SHOW LOG and SHOW OUTPUT commands.
    !
    IF .DBG$GL_LOGFAB[FAB$W_IFI] LEQ 0
    THEN
	BEGIN
	FNAME_PTR = DEFLOG_NAME;
	FNAME_LEN = DEFLOG_SIZE;
	END

    ELSE
	BEGIN
	FNAME_PTR = .DBG$GL_LOGNAM[NAM$L_RSA];
	FNAME_LEN = .DBG$GL_LOGNAM[NAM$B_RSL];
	END;

    IF NOT .DBG$GB_DEF_OUT[OUT_LOG]
    THEN
	DBG$PRINT(UPLIT BYTE(%ASCIC 'not '), 0);

    DBG$PRINT(UPLIT BYTE(%ASCIC 'logging to !AD'), .FNAME_LEN, .FNAME_PTR);


    ! Finally close out the print line and return.
    !
    DBG$NEWLINE();
    RETURN;

    END;

GLOBAL ROUTINE DBG$SHOW_RADIX(OVERRIDE_FLAG): NOVALUE =
!
! FUNCTION
!	Displays the radix that was set by SET RADIX or SET RADIX/OVERRIDE.
!
! INPUTS
!	OVERRIDE_FLAG - 1 if SHOW RADIX/OVERRIDE was specified
!
! OUTPUTS
!	The radix setting is written to the output stream.
!
    BEGIN
    LOCAL
    	RADIX;
    ROUTINE DISPLAY_RADIX (IN_RADIX) : NOVALUE =
    	BEGIN
    	LOCAL
    	    RADIX;
    	RADIX = DBG$NGET_TRANS_RADIX (.IN_RADIX);
        CASE .RADIX FROM DBG$K_DEFAULT TO DBG$K_HEX OF
    	    SET
    	    [DBG$K_BINARY]:
    	        DBG$PRINT (UPLIT BYTE( %ASCIC 'binary'));
    	    [DBG$K_OCTAL]:
    	        DBG$PRINT (UPLIT BYTE( %ASCIC 'octal'));
    	    [DBG$K_DECIMAL]:
    	        DBG$PRINT (UPLIT BYTE (%ASCIC 'decimal'));
    	    [DBG$K_HEX]:
    	        DBG$PRINT (UPLIT BYTE (%ASCIC 'hexadecimal'));
    	    [INRANGE, OUTRANGE]:
    	        $DBG_ERROR('DBGNSHOW\DBG$SHOW_RADIX');
    	    TES;
    	END;
    IF NOT .OVERRIDE_FLAG
    THEN
    	BEGIN
    	RADIX = .DBG$GB_RADIX[DBG$B_RADIX_INPUT];
    	DBG$PRINT(UPLIT BYTE(%ASCIC 'input radix : '));
    	DISPLAY_RADIX (.RADIX);
    	DBG$NEWLINE();
    	RADIX = .DBG$GB_RADIX[DBG$B_RADIX_OUTPUT_OVER];
    	IF .RADIX EQL DBG$K_DEFAULT
    	THEN
    	    RADIX = .DBG$GB_RADIX[DBG$B_RADIX_OUTPUT];
    	DBG$PRINT(UPLIT BYTE(%ASCIC 'output radix: '));
        DISPLAY_RADIX (.RADIX);
    	IF .DBG$GB_RADIX[DBG$B_RADIX_OUTPUT_OVER] NEQ DBG$K_DEFAULT
    	THEN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' (override)'));
    	DBG$NEWLINE();
    	END
    ELSE
    	BEGIN
    	DBG$PRINT(UPLIT BYTE(%ASCIC 'output override radix: '));
    	RADIX = .DBG$GB_RADIX[DBG$B_RADIX_OUTPUT_OVER];
    	IF .RADIX NEQ DBG$K_DEFAULT
    	THEN
    	    DISPLAY_RADIX(.RADIX)
    	ELSE
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'none'));
    	DBG$NEWLINE();
    	END;
    END;
END		! End of module
ELUDOM
