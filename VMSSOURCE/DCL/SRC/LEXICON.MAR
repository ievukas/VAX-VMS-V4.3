	.TITLE	LEXICON - LEXICAL FUNCTION PARSE AND EXECUTION ROUTINES
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; LEXICAL FUNCTION PARSE AND EXECUTION SUPPORT ROUTINES
;
; D. N. CUTLER 3-FEB-78
;
; MODIFIED BY:
;
;	V03-034	HWS0103		Harold Schultz	15-Aug-1984
;		When unable to find lexical function, undo search
;		optimization in function name before outputting
;		error message (Clear high bit in first character
;		of function name).
;
;	V03-033	PCG0024		Peter George	31-May-1984
;		Preclear XAB used by F$FILE to avoid RMS accvio.
;
;	V03-032	HWS0062		Harold Schultz	27-Apr-1984
;		In F$PARSE, return requested portion of file spec.
;		even if parse error. (undo PCG0018). Return null only
;		if no specific portion of file spec requested.
;		
;	V03-031	HWS0051		Harold Schultz	05-Apr-1984
;		When doing an F$PARSE, cleanup any remaining internal
;		RMS context.
;
;	V03-030	HWS0046		Harold Schultz	02-Apr-1984
;		Translate concealed logical names when checking if a
;		file is "known" with F$FILE.
;
;	V03-029	PCG0023		Peter George	02-Mar-1984
;		Clean up F$SEARCH if input is "".
;
;	V03-028	HWS0010		Harold Schultz	13-Feb-1984
;		Use PRC_V_CARRCNTL instead of contents of prompt string
;		to check for presence/absence of CR/LF
;		Enable a parameter list of parse types to be passed to
;		F$PARSE. Add new parse type NO_CONCEAL.
;		In F$PARSE, check validity of name of filespec field parameter
;		before performing the parse.
;
;	V03-027	PCG0022		Peter George	02-Feb-1984
;		Add SYNTAX_ONLY argument to F$PARSE.
;		Have F$ID return a null string on all system service errors.
;
;	V03-026	RAS0247		Ron Schaefer	27-Jan-1984
;		Fix F$PARSE/F$SEARCH to release RMS context correctly
;		when doing the null parse.
;
;	V03-025	PCG0021		Peter George	16-Jan-1984
;		Fix broken branch.
;
;	V03-024	PCG0020		Peter George	12-Jan-1984
;		Fix broken branch.
;
;	V03-023	PCG0019		Peter George	11-Jan-1984
;		Have F$PARSE do a syntax-only parse.
;		Add F$EDIT lowercase.
;
;	V03-022	PCG0018		Peter George	28-Nov-1983
;		Return a null string no matter what part of an
;		non-existent file is requested in F$PARSE.
;
;	V03-021	TMK0001		Todd M. Katz		12-Oct-1983
;		Translate logical names using LNM$DCL_LOGICAL instead of 
;		LNM$DEFAULT_SEARCH as the table name.
;
;	V03-020	PCG0017		Peter George	19-Sep-1983
;		Fix bug in GETJPI table expansion.
;
;	V03-019	PCG0016		Peter George	12-Sep-1983
;		Init NAM block ESS field in F$FILE.
;		Use $GETJPI definition of MODE.
;
;	V03-018	PCG0015		Peter George	17-Aug-1983
;		Change case of weekday strings.
;		Change the way that default protection is retrieved.
;		Specify that a NAM block is need for known file opens.
;		Have F$USER return new format UIC's.
;		Increase accuracy of F$GETJPI error reporting.
;		Add F$IDENTIFIER.
;
;	V03-017	PCG0014		Peter George	27-Jul-1983
;		Support both F$LOGICAL and F$TRNLNM.
;		Add LENGTH item to F$TRNLNM.
;
;	V03-016	PCG0013		Peter George	23-Jun-1983
;		Finish adding new arguments to F$CVTIME.
;		Use event flags more intelligently.
;		Use !%I FAO directive in FORMAT_UIC.
;		Add support for JNL ACP.
;		Skip blanks between lexical function name and open paren.
;		Make F$XLOGICAL F$LOGICAL.  Add TABLE item to F$LOGICAL.
;		Add "OTHER" process mode type.
;
;	V03-015	PCG0012		Peter George	13-Jun-1983
;		Fix bug in F$ENV("CAPTIVE").
;		Fix broken branch.
;		Signal P2 error for NOSUCHNODE in F$GETSYI.
;
;	V03-014	PCG0011		Peter George	01-Jun-1983
;		Add second and third arguments to F$CVTIME.
;		Add F$ENV("OUTPUT_RATE").
;
;	V03-013	PCG0010		Peter George	27-May-1983
;		Add STDTIM data type.
;		Make modifications to F$GETSYI.
;
;	V03-012	PCG0009		Peter George	30-Apr-1983
;		Add F$XLOGICAL.
;		Add F$ENV("CAPTIVE","INTERACTIVE").
;		Add second argument to F$VERIFY.
;		Add second argument to F$GETSYI.
;		Add HEXSTR data type.
;
;	V03-011	PCG0008		Peter George	30-Mar-1983
;		Add F$ENV("KEY_STATE","VERIFY_PROCEDURE","VERIFY_IMAGE").
;		Return standardized protection string everywhere.
;		Remove all references to PRC_V_GOTO.
;
;	V03-010	PCG0007		Peter George	03-Mar-1983
;		Move value conversion and editing routines to CONVERT.
;		Set UPD and DEL share options in F$FILE.
;		Add F$FILE ("KNOWN").
;
;	V03-009	KFH0003		Ken Henderson	 2 Mar 1983
;		Modified JPI_ITEM_CODE macro to conform to new
;		JPITABLE.MAR.
;
;	V03-008	KFH0002		Ken Henderson	25 Feb 1983
;		Changed GETSYI macro to SYI_ITEM_CODE to inherit
;		all 217 SYSBOOT parameters and other new GETSYI
;		item-codes. Also changed GETDVI macro to DVI_ITEM_CODE
;		to inherit all new GETDVI item-codes. Also added
;		the new PSECT DCL$ZDATA to contain all the tables.
;
;	V03-007	PCG0006		Peter George	15-Feb-1983
;		Cleanup some F$SEARCH code.
;		Change F$EDIT COMMENT to UNCOMMENT.
;		Change F$ENV FILENAME to PROCEDURE.
;		Remove F$ENV MESSAGE.
;		Change F$ENV MESSAGE_QUALIFIERS to MESSAGE.
;
;	V03-006	KFH0001		Ken Henderson	 10 Feb 1983
;		Changed GETJPI macro into JPI_ITEM_CODE
;		and added call to JPI_GENERATE_TABLE macro.
;
;	V03-005	PCG0005		Peter George	07-Jan-1983
;		Add F$ENVIRONMENT.
;
;	V03-004	PCG0004		Peter George	15-Dec-1982
;		Add AUTHPRI, PAGEFILLOC, SWPFILLOC F$GETJPI fields.
;		Do not report F$SEARCH errors.
;
;	V03-003	PCG0003		Peter George	14-Nov-1982
;		Fold DCL$REMBLANKS and DCL$UPCASE into DCL$EDIT.
;
;	V03-002	PCG0002		Peter George	07-Oct-1982
;		Add F$TYPE, F$EDIT, and F$ELEMENT.
;		Add DCL$UPCASE.  Tighten up bounds checking in
;		F$CVSI and F$CVUI.
;
;	V03-001	PHL0101		Peter H. Lipman	28-Jun-1982
;		Use the new services, $GETDVIW, $GETJPIW, $GETSYIW
;
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	IDFDEF				;DEFINE INDIRECT FRAME BLOCK
	EDITDEF				;DEFINE EDIT CODES
	$PPDDEF				;DEFINE LOGINOUT/DCL COMMUNICATION AREA
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$DIBDEF				;DEFINE DEVICE INFORMATION FIELDS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS BITS
	$DVIDEF				;DEFINE GETDVI INFORMATION FIELDS
	$JPIDEF				;DEFINE JOB/PROCESS INFORMATION ID'S
	$LNMDEF				;DEFINE LOGICAL NAME CODES
	$PSLDEF				;DEFINE PSL CODES
	$SYIDEF				;DEFINE GETSYI INFORMATION ID'S
	$FABDEF				;FAB DEFINITIONS
	$NAMDEF				;NAM DEFINITIONS
	$XABDEF				;XAB DEFINITIONS
	$XABALLDEF			;ALLOCATION XAB DEFINITIONS
	$XABDATDEF			;DATE/TIME XAB DEFINITIONS
 	$XABFHCDEF			;FILE HEADER XAB DEFINITIONS
	$XABPRODEF			;PROTECTION XAB DEFINITIONS
	$XABSUMDEF			;SUMMARY ISAM XAB DEFINITIONS
	$STSDEF				;STATUS DEFINITIONS

;
; DEFINE THIS SO SYSPARAM WILL BE CONDITIONALIZED CORRECTLY
;
	GETSYISW = 0

;
; FUNCTION ARGUMENT DEFINITIONS
;
 
MAX_ARGS = 16				;MAXIMUM NUMBER OF ARGUMENTS ALLOWED
NPARM=0					;NUMBER OF PARAMETERS
P1=4					;STACK OFFSET TO PARAMETER 1
P2=12					;STACK OFFSET TO PARAMETER 2
P3=20					;STACK OFFSET TO PARAMETER 3
P4=28					;STACK OFFSET TO PARAMETER 4
P5=36					;STACK OFFSET TO PARAMETER 5
P6=44					;STACK OFFSET TO PARAMETER 6
 
;
; DEFINE FORMAT OF LONGWORD DESCRIBING FUNCTION ARGUMENTS
;
;	BYTE 0:		NUMBER OF ARGUMENTS ALLOWED WITH FUNCTION
;	BYTES 1-3:	ARRAY OF 4 NIBBLES, EACH NIBBLE DESCRIBING AN ARGUMENT
;
;			BITS 0-1: TYPE OF VALUE ALLOWED
;					0 = BINARY
;					1 = STRING
;					2 = REFERENCE TO SYMBOL NAME
;					3 = EITHER STRING OR BINARY
;			BIT 2:	  TRUE IF ARGUMENT OPTIONAL, ELSE REQUIRED
;			BIT 3:	  UNUSED
;
;	IF THE NUMBER OF ARGUMENTS EXCEEDS 4, THEN ALL REMAINING ARGUMENTS
;	ARE TREATED AS "EITHER STRING OR BINARY".
;

ARG_V_TYPE	= 0			; STARTING POSITION OF TYPE FIELD
ARG_S_TYPE	= 2			; SIZE OF TYPE FIELD
ARG_C_BINARY	= 0			; BINARY
ARG_C_STRING	= 1			; STRING
ARG_C_SYMREF	= 2			; REFERENCE TO SYMBOL NAME
ARG_C_ANY	= 3			; EITHER STRING OR BINARY
ARG_V_OPTIONAL	= 2			; TRUE IF ARGUMENT OPTIONAL
ARG_V_KEYWORD   = 3			; TRUE IF KEYWORD ARGUMENT
ARG_C_ENTSIZE	= 8			; SIZE OF ENTRY (NAME PLUS ARGS)

;
; MACRO TO GENERATE LEXICAL FUNCTION DEFINITION TABLE
;
 
	.MACRO	FIRST4	NAME
	.NCHR	$ZZ$,NAME
	$XX$ = 128
	.IRPC	$YY$,NAME
	.BYTE	^A"$YY$"!$XX$
	$XX$ = 0
	.ENDR
	.REPT	4-$ZZ$
	.ASCII	" "
	.ENDR
	.ENDM	FIRST4

	.MACRO	FUNCARG	TYPE,PRESENCE=REQUIRED,FORMAT=VALUE
;	RETURNS $XX$ WITH NIBBLE DESCRIBING ARGUMENT
	$XX$ = -1
	.IIF IDN %EXTRACT(0,1,TYPE),<N>,	$XX$ = ARG_C_BINARY
	.IIF IDN %EXTRACT(0,1,TYPE),<S>,	$XX$ = ARG_C_STRING
	.IIF IDN %EXTRACT(0,1,TYPE),<R>,	$XX$ = ARG_C_SYMREF
	.IIF IDN %EXTRACT(0,1,TYPE),<A>,	$XX$ = ARG_C_ANY
	.IF LT	$XX$
	.ERROR	;INVALID ARGUMENT TYPE.  (STRING, NUMERIC, REFERENCE OR ANY)
	.ENDC
	.IIF IDN <PRESENCE><OPTIONAL>, $XX$ = $XX$ + <1@ARG_V_OPTIONAL>
	.IIF IDN <FORMAT><KEYWORD>, $XX$ = $XX$ + <1@ARG_V_KEYWORD>
	.ENDM	FUNCARG

	.MACRO	FUNCT	NAME,ARGTYPES,FLAGS
	FIRST4	%EXTRACT(0,4,NAME)
	NARGS = 0
	.IRP	$ZZ$,<ARGTYPES>
	NARGS = NARGS + 1
	.ENDR
	.IF IDN <FLAGS><VARIABLE>
	NARGS = MAX_ARGS
	.ENDC
	$ARGS$ = 0
	$BIT$ = 0
	.IRP	$YY$,<ARGTYPES>
	FUNCARG	$YY$
	$ARGS$ = $ARGS$ + <$XX$ @ $BIT$>
	$BIT$ = $BIT$ + 4
	.IIF GT	$BIT$-24, .ERROR ;TOO MANY EXPLICTLY DEFINED ARGUMENTS
	.ENDR
	.LONG	NARGS + <$ARGS$ @ 8>
	.ENDM	FUNCT

;
; LEXICAL FUNCTION DEFINITION TABLE
;
 
	.PSECT	DCL$ZDATA,BYTE,RD,NOWRT

LXFUNTABLE:
	FUNCT	CVSINTEGER,	<N,N,S>		;CONVERT SIGNED INTEGER
	FUNCT	CVUINTEGER,	<N,N,S>		;CONVERT UNSIGNED INTEGER
	FUNCT	CVTIME,		<<S,OPTIONAL>,-	;CONVERT TO COMPARABLE TIME STRING
				<S,OPTIONAL,KEYWORD>,-
				<S,OPTIONAL,KEYWORD>>
	FUNCT	DIRECTORY			;DEFAULT DIRECTORY STRING
	FUNCT	EDIT,		<S,-		;EDIT A STRING
				<S,REQUIRED,KEYWORD>>
	FUNCT	ELEMENT,	<N,S,S>		;FIND THE SPECIFIED ELEMENT
	FUNCT	ENVIRONMENT,	<<S,REQUIRED,KEYWORD>> ;GET DCL CONTEXT INFO
	FUNCT	EXTRACT,	<N,N,S>		;EXTRACT SUBSTRING FROM STRING
	FUNCT	FAO,		<S,ANY,ANY,-	;FAO SERVICE
				ANY,ANY,ANY>,VARIABLE 
	FUNCT	FILE_ATTRIBUTES,<S,-		;GET FILE ATTRIBUTES
				<S,REQUIRED,KEYWORD>>
	FUNCT	GETDVI,		<S,-		;GETDVI SYSTEM SERVICE
				<S,REQUIRED,KEYWORD>>
	FUNCT	GETJPI,		<S,-		;GETJPI SYSTEM SERVICE
				<S,REQUIRED,KEYWORD>>
	FUNCT	GETSYI,		<<S,REQUIRED,KEYWORD>,-	;GETSYI SYSTEM SERVICE
				<S,OPTIONAL,KEYWORD>>	;
	FUNCT	IDENTIFIER,	<ANY,-		;TRANSLATE IDENTIFIER
				<S,REQUIRED,KEYWORD>>
	FUNCT	INTEGER,	<ANY>		;CONVERT EXPRESSION TO INTEGER
	FUNCT	LENGTH,		<S>		;STRING LENGTH IN BINARY
	FUNCT	LOCATE,		<S,S>		;FIND OFFSET TO SUBSTRING
	FUNCT	LOGICAL,	<S>		;LOGICAL NAME TRANSLATION
	FUNCT	MESSAGE,	<N>		;GET MESSAGE STRING
	FUNCT	MODE				;KEYWORD DESCRIBING TYPE OF JOB
	FUNCT	PARSE,		<-		;PARSE A FILESPEC
				<S>,-		;	PRIMARY FILESPEC
				<S,OPTIONAL>,-	;   	DEFAULT FILESPEC
				<S,OPTIONAL>,-	;   	RELATED (STICKY) FILESPEC
				<S,OPTIONAL,KEYWORD>,-;	FILESPEC FIELD DESIRED
				<S,OPTIONAL,KEYWORD>>;	TYPE OF PARSE
	FUNCT	PID,		<REF>		;GET NEXT PROCESS ID STRING
	FUNCT	PRIVILEGE,	<<S,REQUIRED,KEYWORD>>	;TRUE IF PRIVS ARE SET/CLEAR
	FUNCT	PROCESS				;PROCESS NAME STRING
	FUNCT	SEARCH,		<S,<N,OPTIONAL>> 	;GET NEXT WILDCARD FILESPEC
	FUNCT	SETPRV,		<<S,REQUIRED,KEYWORD>>	;SETPRV SYSTEM SERVICE
	FUNCT	STRING,		<ANY>		;CONVERT EXPRESSION TO STRING
	FUNCT	TIME				;TIME OF DAY STRING
	FUNCT	TRNLNM,		<<S>,-		;LOGICAL NAME TRANSLATION
				<S,OPTIONAL>,-	;	TABLE NAME
				<N,OPTIONAL>,-	;	TRANSLATION NUMBER
				<S,OPTIONAL,KEYWORD>,- ;ACCESS MODE
				<S,OPTIONAL,KEYWORD>,- ;ATTRIBUTE
				<S,OPTIONAL,KEYWORD>>  ;ITEM
	FUNCT	TYPE		<REF>		;TYPE OF SYMBOL
	FUNCT	USER				;UIC STRING
	FUNCT	VERIFY,		<<N,OPTIONAL>,- ;VERIFY MODE IN BINARY, AND
				 <N,OPTIONAL>>	;OPTIONALLY CHANGE VERIFY MODE

LXFUNTABLEN=.-LXFUNTABLE		;LENGTH OF LEXICAL FUNCTION TABLE

;
; DEFINE THE DTYPES THAT LEXICON USES (SUBSET OF ALL POSSIBLE DTYPES)
;
	BIN = 0
	STR = 1
	HEX = 2
	PRV = 3
	BIT = 4
	HEXSTR = 5
	STDTIM = 6

;
; MACRO TO DEFINE VALID $GETJPI ITEMS WHICH MAY BE USED IN F$GETJPI
; THIS MACRO IS CALLED BY THE COMMONLY DEFINED MACRO: JPI_GENERATE_TABLE
;
	.MACRO	JPI_ITEM_CODE	BASE,-		; of EXE$GETJPI internal tables
				NAME,-		; of the item-code
				SOURCE,-	; of the data
				DTYPE,-		; data type and usage
				BITPOS,-	; of the 'bitval' bit
				BITSIZ,-	; of the 'bitval' bit
				OUTLEN,-	; of the data
				STRUCT		; structure containing the data

	.WORD	JPI$_'NAME

	$XX$ = BIN
	.IIF IDN <DTYPE><DECNUM>,	$XX$=BIN
	.IIF IDN <DTYPE><PADSTR>,	$XX$=STR
	.IIF IDN <DTYPE><CNTSTR>,	$XX$=STR
	.IIF IDN <DTYPE><HEXNUM>,	$XX$=HEX
	.IIF IDN <DTYPE><PRVMSK>,	$XX$=PRV
	.IIF IDN <DTYPE><STDUIC>,	$XX$=BIN
	.IIF IDN <DTYPE><STDTIM>,	$XX$=STR
	.IIF IDN <DTYPE><STRDSC>,	$XX$=STR
	.IIF IDN <DTYPE><BITVEC>,	$XX$=BIN
	.IIF IDN <DTYPE><BITVAL>,	$XX$=BIT
	.IIF IDN <DTYPE><PRTMSK>,	$XX$=BIN
	.IIF IDN <DTYPE><ACPTYP>,	$XX$=BIN
	.IIF IDN <DTYPE><HEXSTR>,	$XX$=HEXSTR

	.BYTE	$XX$
	.ASCIC	"NAME"
	.ENDM	JPI_ITEM_CODE

;
;*********************************************************
;
; DEFINE VALID $ ITEMS WHICH MAY BE USED IN F$GETJPI
;
;*********************************************************
;

GETJPI_TABLE:

; Each element of GETJPI_TABLE is:
;
	;---------------------;
	; .WORD   JPI$_'NAME  ;
	; .BYTE   DTYPE       ;
	; .ASCIC  "NAME"      ;
	;---------------------;

	JPI_GENERATE_TABLE

	.LONG	0

;
; MACRO TO DEFINE VALID $GETSYI ITEMS WHICH MAY BE USED IN F$GETSYI
; THIS MACRO IS CALLED BY THE COMMONLY DEFINED MACRO: SYI_GENERATE_TABLE
;
	.MACRO	SYI_ITEM_CODE	BASE,-		; of EXE$GETSYI internal tables
				NAME,-		; of the item-code
				SOURCE,-	; of the data
				DTYPE,-		; data type and usage
				BITPOS,-	; of FLD data items
				BITSIZ,-	; of FLD data items
				OUTLEN		; of the returned data

	.WORD	SYI$_'NAME

	$XX$ = BIN
;	.IIF IDN <DTYPE><DECNUM>,	$XX$=BIN
;	.IIF IDN <DTYPE><PADSTR>,	$XX$=STR
;	.IIF IDN <DTYPE><CNTSTR>,	$XX$=STR
;	.IIF IDN <DTYPE><HEXNUM>,	$XX$=HEX
;	.IIF IDN <DTYPE><PRVMSK>,	$XX$=PRV
;	.IIF IDN <DTYPE><STDUIC>,	$XX$=BIN
;	.IIF IDN <DTYPE><STDTIM>,	$XX$=STR
;	.IIF IDN <DTYPE><STRDSC>,	$XX$=STR
;	.IIF IDN <DTYPE><BITVEC>,	$XX$=BIN
;	.IIF IDN <DTYPE><BITVAL>,	$XX$=BIT
;	.IIF IDN <DTYPE><HEXSTR>,	$XX$=HEXSTR

;
; The above mapping is identical to GETJPI, but the GETSYI code can't
; yet handle DTYPEs other than HEX, BIN, STR, BIT, and HEXSTR
; so the following table is used in the meantime until everything is done.
;

	.IIF IDN <DTYPE><DECNUM>,	$XX$=BIN
	.IIF IDN <DTYPE><PADSTR>,	$XX$=STR
	.IIF IDN <DTYPE><CNTSTR>,	$XX$=STR
	.IIF IDN <DTYPE><HEXNUM>,	$XX$=HEX
	.IIF IDN <DTYPE><PRVMSK>,	$XX$=BIN
	.IIF IDN <DTYPE><STDUIC>,	$XX$=BIN
	.IIF IDN <DTYPE><STDTIM>,	$XX$=STDTIM
	.IIF IDN <DTYPE><STRDSC>,	$XX$=STR
	.IIF IDN <DTYPE><BITVEC>,	$XX$=BIN
	.IIF IDN <DTYPE><BITVAL>,	$XX$=BIT
	.IIF IDN <DTYPE><HEXSTR>,	$XX$=HEXSTR

	.BYTE	$XX$
	.ASCIC	"NAME"
	.ENDM	SYI_ITEM_CODE

;
;*********************************************************
;
; DEFINE VALID $GETSYI ITEMS WHICH MAY BE USED IN F$GETSYI
;
;*********************************************************
;

GETSYI_TABLE:

; Each element of GETSYI_TABLE is:
;
	;---------------------;
	; .WORD   SYI$_'NAME  ;
	; .BYTE   DTYPE       ;
	; .ASCIC  "NAME"      ;
	;---------------------;

	SYI_GENERATE_TABLE

	.LONG	0

;
; PRODUCE A TABLE OF ASCIC NAMES DESCRIBING EACH OF THE PROCESS STATES
;

	.MACRO	$DEFINI NAME,P1,P2
	.ENDM
	.MACRO	$DEFEND NAME,P1,P2
	.ENDM
	.MACRO	$EQU SYMBOL,VALUE
S = %LOCATE(<_>,SYMBOL)+1
L = %LENGTH(SYMBOL)-S
	.ASCIC	/%EXTRACT(S,L,SYMBOL)/
	.BLKB	8-<L+1>
	.ENDM	$EQU

STATE_TABLE:
	.ASCIC	'ILLEGAL'		; FOR ZERO CASE
	$STATEDEF			; TABLE OF PROCESS STATE NAMES

	.MDELETE	$DEFINI,$DEFEND,$EQU


;
; MACRO TO DEFINE VALID DATA ITEMS WHICH MAY BE USED IN F$FILE_ATTRIBUTES
;

	.MACRO	FILITEM	NAME,BLOCK,FIELD,SIZE,BITNUM,TYPE=BINARY
	$XX$ = 0
	.IIF IDN <BLOCK><FAB>,		$XX$=0
	.IIF IDN <BLOCK><NAM>,		$XX$=1
	.IIF IDN <BLOCK><XABALL>,	$XX$=2
	.IIF IDN <BLOCK><XABDAT>,	$XX$=3
	.IIF IDN <BLOCK><XABFHC>,	$XX$=4
	.IIF IDN <BLOCK><XABPRO>,	$XX$=5
	.IIF IDN <BLOCK><XABSUM>,	$XX$=6
	.BYTE	$XX$			; RMS BLOCK ID
	$XX$ = 0
	.IIF NB	<FIELD>,$XX$ = 'FIELD'
	.BYTE	$XX$			; OFFSET TO FIELD IN RMS BLOCK
	$XX$ = 0
	.IIF IDN <SIZE><BIT>,		$XX$=1
	.IIF IDN <SIZE><BYTE>,		$XX$=8
	.IIF IDN <SIZE><WORD>,		$XX$=16
	.IIF IDN <SIZE><LONG>,		$XX$=32
	.BYTE	$XX$			; SIZE OF FIELD
	$XX$ = 0
	.IIF NB <BITNUM>,$XX$ = 'BITNUM'
	.BYTE	$XX$			; BIT NUMBER
	$XX$ = 0
	.IIF IDN <TYPE><BINARY>,	$XX$=0
	.IIF IDN <TYPE><DATE>,		$XX$=1
	.IIF IDN <TYPE><ASCIC>,		$XX$=2
	.IIF IDN <TYPE><FILEID>,	$XX$=3
	.IIF IDN <TYPE><ORG>,		$XX$=4
	.IIF IDN <TYPE><RAT>,		$XX$=5
	.IIF IDN <TYPE><RFM>,		$XX$=6
	.IIF IDN <TYPE><UIC>,		$XX$=7
	.IIF IDN <TYPE><PROT>,		$XX$=8
	.IIF IDN <TYPE><EOF>,		$XX$=9
	.IIF IDN <TYPE><BOOLEAN>,	$XX$=10
	.IIF IDN <TYPE><KNOWN>,		$XX$=11		; F$FILE DEPENDS ON THIS BEING 11
	.BYTE	$XX$			; TYPE OF DATA ITEM
	.ASCIC	"NAME"			; ASCIC NAME OF DATA ITEM
	.ENDM	FILITEM

;
; DEFINE XAB BLOCK ID'S AND LENGTHS
;

XAB_INFO:
	.BYTE	XAB$C_ALL,XAB$C_ALLLEN
	.BYTE	XAB$C_DAT,XAB$C_DATLEN
	.BYTE	XAB$C_FHC,XAB$C_FHCLEN
	.BYTE	XAB$C_PRO,XAB$C_PROLEN
	.BYTE	XAB$C_SUM,XAB$C_SUMLEN

;
; DEFINE VALID DATA ITEMS WHICH MAY BE USED IN F$FILE_ATTRIBUTES
;

FILE_TABLE:
	FILITEM	ALQ,FAB,FAB$L_ALQ,SIZE=LONG	;ALLOCATION QUANTITY
	FILITEM	BKS,FAB,FAB$B_BKS,SIZE=BYTE	;BUCKET SIZE
	FILITEM	BLS,FAB,FAB$W_BLS,SIZE=WORD	;BLOCK SIZE
	FILITEM	DEQ,FAB,FAB$W_DEQ,SIZE=WORD	;DEFAULT EXTENSION QUANTITY
	FILITEM	FSZ,FAB,FAB$B_FSZ,SIZE=BYTE	;FIXED CONTROL AREA SIZE
	FILITEM	MRN,FAB,FAB$L_MRN,SIZE=LONG	;MAXIMUM RECORD NUMBER
	FILITEM	MRS,FAB,FAB$W_MRS,SIZE=WORD	;MAXIMUM RECORD SIZE
	FILITEM	ORG,FAB,FAB$B_ORG,SIZE=BYTE,TYPE=ORG	;FILE ORGANIZATION
	FILITEM	RAT,FAB,FAB$B_RAT,SIZE=BYTE,TYPE=RAT	;RECORD ATTRIBUTES
	FILITEM	RFM,FAB,FAB$B_RFM,SIZE=BYTE,TYPE=RFM	;RECORD FORMAT
	FILITEM	KNOWN,NAM,FAB$L_CTX,SIZE=LONG,TYPE=KNOWN;KNOWN FILE CHECK
	FILITEM	CTG,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_CTG,TYPE=BOOLEAN ;CONTIGUOUS
	FILITEM	CBT,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_CBT,TYPE=BOOLEAN ;CONTIGUOUS-BEST-TRY
	FILITEM	RCK,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_RCK,TYPE=BOOLEAN ;READ CHECK
	FILITEM	WCK,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_WCK,TYPE=BOOLEAN ;WRITE CHECK
	FILITEM	CDT,XABDAT,XAB$Q_CDT,TYPE=DATE	;CREATION DATE/TIME
	FILITEM	EDT,XABDAT,XAB$Q_EDT,TYPE=DATE	;EXPIRATION DATE/TIME
	FILITEM	RDT,XABDAT,XAB$Q_RDT,TYPE=DATE	;REVISION DATE/TIME
	FILITEM	BDT,XABDAT,XAB$Q_BDT,TYPE=DATE	;BACKUP DATE/TIME
	FILITEM	RVN,XABDAT,XAB$W_RVN,SIZE=WORD	;REVISION NUMBER
	FILITEM	UIC,XABPRO,XAB$W_MBM,SIZE=LONG,TYPE=UIC ;OWNER UIC STRING
	FILITEM	GRP,XABPRO,XAB$W_GRP,SIZE=WORD	;OWNER GROUP NUMBER
	FILITEM	MBM,XABPRO,XAB$W_MBM,SIZE=WORD	;OWNER MEMBER NUMBER
	FILITEM	PRO,XABPRO,XAB$W_PRO,SIZE=WORD,TYPE=PROT ;FILE PROTECTION BITMASK
	FILITEM	EOF,XABFHC,XAB$L_EBK,SIZE=LONG,TYPE=EOF	;END-OF-FILE BLOCK NUMBER
	FILITEM	NOA,XABSUM,XAB$B_NOA,SIZE=BYTE	;NUMBER OF AREAS
	FILITEM	NOK,XABSUM,XAB$B_NOK,SIZE=BYTE	;NUMBER OF KEYS
	FILITEM	PVN,XABSUM,XAB$W_PVN,SIZE=WORD	;PROLOGUE VERSION NUMBER
	FILITEM	DID,NAM,NAM$W_DID,TYPE=FILEID	;DIRECTORY ID NUMBER
	FILITEM	FID,NAM,NAM$W_FID,TYPE=FILEID	;FILE ID NUMBER
	FILITEM	DVI,NAM,NAM$T_DVI,TYPE=ASCIC	;DEVICE NAME STRING
	.QUAD	0

;
; MACRO TO DEFINE VALID F$PARSE FILESPEC FIELDS
;

	.MACRO	FILFLD	NAME,LENGTH,ADDRESS
	.ASCIC	"NAME"
	.BYTE	LENGTH			;OFFSET TO LENGTH BYTE IN NAM
	.BYTE	ADDRESS			;OFFSET TO ADDRESS LONGWORD IN NAM
	.ENDM

;
; DEFINE VALID FILESPEC FIELDS WHICH MAY BE RETURNED BY F$PARSE
;

PARSE_FIELDS:
	FILFLD	NODE,NAM$B_NODE,NAM$L_NODE
	FILFLD	DEVICE,NAM$B_DEV,NAM$L_DEV
	FILFLD	DIRECTORY,NAM$B_DIR,NAM$L_DIR
	FILFLD	NAME,NAM$B_NAME,NAM$L_NAME
	FILFLD	TYPE,NAM$B_TYPE,NAM$L_TYPE
	FILFLD	VERSION,NAM$B_VER,NAM$L_VER
	.BYTE	0

	.MACRO	PRSTYP	NAME,FIELD
	.ASCIC	"NAME"
	.BYTE	NAM$M_'FIELD'
	.ENDM

PARSE_TYPES:
	PRSTYP	SYNTAX_ONLY,SYNCHK
	PRSTYP	NO_CONCEAL,NOCONCEAL
	.BYTE	0

;
; MACRO TO DEFINE VALID $GETDVI ITEMS WHICH MAY BE USED IN F$GETDVI
; THIS MACRO IS CALLED BY THE COMMONLY DEFINED MACRO: DVI_GENERATE_TABLE
;
	.MACRO	DVI_ITEM_CODE	NAME,-		; of the item-code
				SPECIAL,-	; flag
				SOURCE,-	; of the data
				DTYPE,-		; data type and usage
				BITPOS,-	; of the 'bitval' bit
				OUTLEN,-	; of the returned data
				STRUCT,-	; structure containing the data
				DEVTYP		; flag

	;
	; SPLDEVNAM and EXISTS are special cases
	;
	.IF IDN <NAME><SPLDEVNAM>
	.WORD	DVI$_DEVNAM
	.IFF

	.IF IDN <NAME><EXISTS>
	.WORD	DVI$_DEVCHAR
	.IFF
	.WORD	DVI$_'NAME
	.ENDC

	.ENDC

	$XX$ = 0
	.IIF IDN <DTYPE><DECNUM>,	$XX$=0
	.IIF IDN <DTYPE><PADSTR>,	$XX$=1
	.IIF IDN <DTYPE><CNTSTR>,	$XX$=1
	.IIF IDN <DTYPE><HEXNUM>,	$XX$=4
	.IIF IDN <DTYPE><PRVMSK>,	$XX$=0
	.IIF IDN <DTYPE><STDUIC>,	$XX$=2
	.IIF IDN <DTYPE><STDTIM>,	$XX$=0
	.IIF IDN <DTYPE><STRDSC>,	$XX$=1
	.IIF IDN <DTYPE><BITVEC>,	$XX$=0
	.IIF IDN <DTYPE><BITVAL>,	$XX$=3
	.IIF IDN <DTYPE><PRTMSK>,	$XX$=5
	.IIF IDN <DTYPE><ACPTYP>,	$XX$=6
	.IIF IDN <DTYPE><HEXSTR>,	$XX$=7

	.BYTE	$XX$

	.IF IDN <NAME><EXISTS>
	.BYTE	DEV$V_EXISTS
	.IFF
	.BYTE	0
	.ENDC

	.ASCIC	"NAME"
	.ENDM	DVI_ITEM_CODE

DEV$V_EXISTS = -1

;
;*********************************************************
;
; DEFINE VALID $GETDVI ITEMS WHICH MAY BE USED IN F$GETDVI
;
;*********************************************************
;

GETDVI_TABLE:

; Each element of GETDVI_TABLE is:
;
	;-----------------------;
	; .WORD    DVI$_'NAME   ;
	; .BYTE    DTYPE        ;
	; .BYTE    DEV$V_EXISTS ;
	; .ASCIC   "NAME"       ;
	;-----------------------;

	DVI_GENERATE_TABLE

	;
	; These codes are special to LEXICON, they aren't 'real' item-codes
	;
	DVI_ITEM_CODE SPLDEVNAM, F, DEVNAM, PADSTR, 0, 4, UCB, ANY
	DVI_ITEM_CODE EXISTS, F, DEVCHAR, BITVAL, 0, 1, UCB, ANY

	.QUAD	0			; END = ZERO LENGTH NAME

;
; BUILD TABLE OF ACP TYPES
;
	$XX$ = 1
	.MACRO	ACP NAME
	ASSUME	DVI$C_ACP_'NAME EQ $XX$
	$XX$ = $XX$ + 1
	.ASCIC	"NAME"
	.BLKB	8 - <%LENGTH(NAME)+1>
	.ENDM	ACP

ACP_TABLE:
	.ASCIC	'ILLEGAL'
	ACP	F11V1
	ACP	F11V2
	ACP	MTA
	ACP	NET
	ACP	REM
	ACP	JNL
	.ASCIC	'ILLEGAL'

;
; MACRO TO DEFINE VALID F$EDIT ITEM NAMES
;
	.MACRO	EDIT	NAME
	.ASCIC	"NAME"
	.BYTE	EDIT_M_'NAME
	.ENDM

;
; DEFINE VALID F$EDIT ITEM NAMES
;
EDIT_TABLE:
	ASSUME	EDIT_V_UNCOMMENT EQ 0
	ASSUME	EDIT_V_COMPRESS EQ 1
	ASSUME	EDIT_V_COLLAPSE EQ 2
	ASSUME	EDIT_V_TRIM EQ 3
	ASSUME	EDIT_V_UPCASE EQ 4
	ASSUME	EDIT_V_LOWERCASE EQ 5
	ASSUME	EDIT_V_EOL EQ 6
	EDIT	UNCOMMENT
	EDIT	COMPRESS
	EDIT	COLLAPSE
	EDIT	TRIM
	EDIT	UPCASE
	EDIT	LOWERCASE
	.BYTE	0

;
; MACRO TO DEFINE VALID F$ENVIRONMENT ITEM NAMES
;
	$XX$ = 0
	.MACRO	ENVIRON	NAME
	.ASCIC	"NAME"
	.BYTE	$XX$
	$XX$ = $XX$ + 1
	.ENDM

;
; DEFINE VALID F$ENVIRONMENT ITEM NAMES
;
ENVIRON_TABLE:
	ENVIRON	CONTROL
	ENVIRON	NOCONTROL
	ENVIRON	DEFAULT
	ENVIRON	DEPTH
	ENVIRON	ON_SEVERITY
	ENVIRON	PROMPT
	ENVIRON	PROMPT_CONTROL
	ENVIRON	PROTECTION
	ENVIRON	MESSAGE
	ENVIRON	MAX_DEPTH
	ENVIRON	ON_CONTROL_Y
	ENVIRON	PROCEDURE
	ENVIRON	KEY_STATE
	ENVIRON	VERIFY_PROCEDURE
	ENVIRON	VERIFY_IMAGE
	ENVIRON	CAPTIVE
	ENVIRON INTERACTIVE
	ENVIRON	OUTPUT_RATE
	.BYTE	0

;
; MACRO TO DEFINE VALID F$TRNLNM ITEM NAMES
;
	.MACRO	LOGICAL	NAME,ITEM
	.ASCIC	"NAME"
	.WORD	LNM$_'ITEM
	$XX$ = 0
	.IIF IDN <ITEM><ATTRIBUTES>,$XX$ = LNM$V_'NAME
	.BYTE	$XX$
	.ENDM

;
; DEFINE VALID F$TRNLNM ITEM NAMES
;
LOGICAL_TABLE:
	LOGICAL	ACCESS_MODE,ACMODE
	LOGICAL	CONCEALED,ATTRIBUTES
	LOGICAL	CONFINE,ATTRIBUTES
	LOGICAL	CRELOG,ATTRIBUTES
	LOGICAL	LENGTH,LENGTH
	LOGICAL	MAX_INDEX,MAX_INDEX
	LOGICAL	NO_ALIAS,ATTRIBUTES
	LOGICAL	TABLE,ATTRIBUTES
	LOGICAL	TABLE_NAME,TABLE
	LOGICAL	TERMINAL,ATTRIBUTES
	LOGICAL	VALUE,STRING
	.BYTE	0

;
; MACRO TO DEFINE VALID F$TRNLNM ATTRIBUTE TYPES
;
	.MACRO	LOGATTR	NAME
	.ASCIC	"NAME"
	$XX$ = 0
	.IIF IDN <NAME><CASE_BLIND>,$XX$ = LNM$M_'NAME
	.LONG	$XX$
	.ENDM

;
; DEFINE VALID F$TRNLNM ATTRIBUTE TYPES
;
LOGATTR_TABLE:
	LOGATTR	CASE_BLIND
	LOGATTR	CASE_SENSITIVE
	.BYTE	0

;
; MACRO TO DEFINE VALID ACCESS MODES
;
	$XX$ = 0
	.MACRO	ACCESS	NAME
	.ASCIC	"NAME"
	.BYTE	$XX$
	$XX$ = $XX$ + 1
	.ENDM

;
; DEFINE VALID ACCESS MODES (MUST BE IN PSL$C_XXX ORDER)
;
ACCESS_TABLE:
	ACCESS	KERNEL
	ACCESS	EXECUTIVE
	ACCESS	SUPERVISOR
	ACCESS	USER
	.BYTE	0

;
; BUILD TABLE OF MESSAGE SEVERITIES
;
	.MACRO	SEVERITY NAME
	.ASCIC	"NAME"
	.BLKB	8 - <%LENGTH(NAME)+1>
	.ENDM	SEVERITY

SEVERITY_TABLE:
	ASSUME	STS$K_WARNING EQ 0
	SEVERITY	WARNING
	ASSUME	STS$K_ERROR EQ 2
	SEVERITY	ERROR
	ASSUME	STS$K_SEVERE EQ 4
	SEVERITY	SEVERE
	SEVERITY	NONE		;PLACE HOLDER FOR NEXT "NONE"
	SEVERITY	NONE

;
; MACRO TO DEFINE VALID F$CVTIME TYPE NAMES
;
	$XX$ = 0
	.MACRO	CVTTYPE	NAME
	.ASCIC	"NAME"
	.BYTE	$XX$
	$XX$ = $XX$ + 1
	.ENDM

;
; DEFINE VALID F$CVTIME TYPE NAMES
;
CVTIME_TYPES:
	CVTTYPE	COMPARISON
	CVTTYPE	ABSOLUTE
	CVTTYPE	DELTA
	.BYTE	0

;
; MACRO TO DEFINE VALID F$CVTIME ITEM NAMES
;
	.MACRO	CVTIME	NAME,CSTART,CCOUNT,ASTART,ACOUNT,DSTART,DCOUNT
	.ASCIC	"NAME"
	.BYTE	CSTART
	.BYTE	CCOUNT
	.BYTE	ASTART
	.BYTE	ACOUNT
	.BYTE	DSTART
	.BYTE	DCOUNT
	.ENDM

;
; DEFINE VALID F$CVTIME ITEM NAMES
; (0,0 MEANS UNSUPPORTED FOR DELTA TIMES, WEEKDAY FOR OTHERS)
;
CVTIME_ITEMS:
	CVTIME	DATETIME,0,7,0,7,0,5
	CVTIME	DATE,0,3,0,3,0,1
	CVTIME	TIME,3,4,3,4,1,4
	CVTIME	DAY,2,1,0,1,0,1
	CVTIME	MONTH,1,1,1,1,0,0
	CVTIME	YEAR,0,1,2,1,0,0
	CVTIME	HOUR,3,1,3,1,1,1
	CVTIME	MINUTE,4,1,4,1,2,1
	CVTIME	SECOND,5,1,5,1,3,1
	CVTIME	HUNDREDTH,6,1,6,1,4,1
	CVTIME	WEEKDAY,0,0,0,0,0,0
	.BYTE	0

MONTH_TABLE:
	.ASCII	'JAN-FEB-MAR-APR-MAY-JUN-JUL-AUG-SEP-OCT-NOV-DEC-'
MONTH_NO_TABLE:
	.ASCII	'010203040506070809101112??'

;
; BUILD TABLE OF WEEKDAYS
;
	.MACRO	DAY NAME
	.ASCIC	"NAME"
	.BLKB	10 - <%LENGTH(NAME)+1>
	.ENDM	DAY

WEEKDAY_TABLE:
	DAY	Monday
	DAY	Tuesday
	DAY	Wednesday
	DAY	Thursday
	DAY	Friday
	DAY	Saturday
	DAY	Sunday

;
; MACRO TO DEFINE VALID F$IDENTIFIER KEYWORDS
;
	$XX$ = 0
	.MACRO	IDENT	NAME
	.ASCIC	"NAME"
	.BYTE	$XX$
	$XX$ = $XX$ + 1
	.ENDM

;
; DEFINE VALID F$IDENTIFIER KEYWORDS
;
IDENT_TABLE:
	IDENT	NAME_TO_NUMBER
	IDENT	NUMBER_TO_NAME
	.BYTE	0

;
; MACRO TO DEFINE VALID PROCESS MODES
;
	$XX$ = 0
	.MACRO	PRCMODE	NAME
	.ASCIC	"NAME"
	.BYTE	$XX$
	$XX$ = $XX$ + 1
	.ENDM

;
; DEFINE VALID PROCESS MODES (MUST BE IN JPI$K_XXX ORDER)
;
MODE_TABLE:
	PRCMODE	OTHER
	PRCMODE NETWORK
	PRCMODE	BATCH
	PRCMODE INTERACTIVE
	.BYTE	0

BATCH:
	.ASCIC	'BATCH'			;BATCH JOB
INTERACTIVE:
	.ASCIC	'INTERACTIVE'		;INTERACTIVE JOB
NETWORK:
	.ASCIC	'NETWORK'		;NETWORK JOB
OTHER:
	.ASCIC	'OTHER'			;OTHER NON-INTERACTIVE JOB

;
; LIST MESSAGE FIELDS
;
TEXT:	.ASCIC	'TEXT'
IDENT:	.ASCIC	'IDENTIFICATION'
SEVERITY:
	.ASCIC	'SEVERITY'
FACILITY:
	.ASCIC	'FACILITY'


NOALL:	.ASCII	'NOALL'			;KEYWORD FOR [NO]ALL PRIVILEGES
FALSE:	.ASCIC	'FALSE'			;BOOLEAN FALSE VALUE
TRUE:	.ASCIC	'TRUE'			;BOOLEAN TRUE VALUE

STRING:	.ASCIC	'STRING'		;STRING SYMBOL
INTEGER:
	.ASCIC	'INTEGER'		;INTEGER SYMBOL

TABDEF:	.ASCIC	'LNM$DCL_LOGICAL'	;DEFAULT LOGICAL NAME TABLE
NLA0:	.ASCIC	'_NLA0:'		;NULL DEVICE

	.SBTTL	EVALUATE LEXICAL FUNCTION STRING

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

;---
; DCL$FUNCTION - EVALUATE A LEXICAL FUNCTION STRING
;
; THIS ROUTINE CAN BE CALLED TO EVALUATE A STRING WHICH CONTAINS
; A LEXICAL FUNCTION AND ITS ARGUMENTS, AND RETURNS ITS VALUE.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF FUNCTION/SYMBOL STRING
;	R3/R4 = DESCRIPTOR OF SCRATCH STORAGE
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF VALUE STRING (NULL IF ERROR)
;---
	.IF DF	SUPRESS_CODE		;NOBODY CALLS THIS AT THE MOMENT

DCL$FUNCTION::
	PUSHR	#^M<R3,R4,R5,R6,R7>	;SAVE REGISTERS
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE EXPANSION BUFFER POINTER
	PUSHL	WRK_L_CHARPTR(R10)	;SAVE INPUT BUFFER POINTER
	STATUS	BUFOVF			;ASSUME BUFFER OVERFLOW
	CMPL	R1,R3			;CHECK IF STRING TOO BIG FOR BUFFER
	BGEQ	90$			;SKIP IT IF ITS TOO LONG
	MOVL	R4,WRK_L_EXPANDPTR(R10)	;PUT EXPANSION IN FRONT OF BUFFER
	MOVAB	-2(R4)[R3],R0		;CALCULATE ENDING ADDRESS OF BUFFER
	SUBL	R1,R0			;SUBTRACT LENGTH OF INPUT STRING
	MOVL	R0,WRK_L_CHARPTR(R10)	;SET INPUT CHARACTER POINTER TO STRING
	MOVC	R1,(R2),1(R0)		;STORE INPUT STRING ON STACK
	CLRB	(R3)+			;TERMINATE INPUT STRING WITH EOL CHAR
	BSBW	DCL$GETOKEN		;GET FUNCTION NAME STRING
	MOVQ	R1,R6			;AND PASS TO DCL$LEXIF
	BSBB	DCL$LEXIF		;EVALUATE LEXICAL FUNCTION
90$:	POPL	WRK_L_CHARPTR(R10)	;RESTORE INPUT BUFFER POINTER
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	POPR	#^M<R3,R4,R5,R6,R7>	;RESTORE REGISTERS
	RSB

	.ENDC

	.SBTTL	LEXICAL FUNCTION DISPATCHER
;+
; DCL$LEXIF - LEXICAL FUNCTION DISPATCH ROUTINE
;
; THIS ROUTINE IS CALLED WHEN A STRING SUBSTITUTION IS SPECIFIED AND THE STRING
; IS CURRENTLY UNDEFINED.
;
; INPUTS:
;
;	R6 = LENGTH OF SYMBOL NAME.
;	R7 = ADDRESS OF SYMBOL NAME.
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	THE SYMBOL NAME IS MATCHED WITH THE LEXICAL FUNCTION TABLE. IF NO MATCH
;	OCCURS, THEN A NULL STRING IS RETURNED FOR SUBSTITUTION IN THE ORIGINAL
;	COMMAND LINE. IF A MATCH OCCURS, THEN THE APPROPRIATE LEXICAL FUNCTION
;	IS EVALUATED AND THE RESULTANT STRING IS RETURNED.
;
;	R1/R2 = A QUADWORD DESCRIBING THE FUNCTION RESULT
;		IF R2 NONZERO, THEN R1/R2 IS A STRING DESCRIPTOR
;		IF R2 ZERO, THEN R1 IS A BINARY LONGWORD VALUE.
;
;	INPUT AND EXPANSION POINTERS ARE UPDATED AS APPROPRIATE.
;-
 
DCL$LEXIF::				;LEXICAL FUNCTION DISPATCH
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9,AP> ; SAVE REGISTERS
	MOVL	SP,AP			;MARK STACK ADDRESS
	CMPL	#6,R6			;SPECIFIED NAME LONGER THAN 6 CHARACTERS?
	BGTRU	10$			;IF GTRU NO
	MOVL	#6,R6			;REDUCE LENGTH TO 6 CHARACTERS
10$:	CMPW	#^A/F$/,(R7)+		;POSSIBLY LEXICAL FUNCTION NAME?
	BNEQ	60$			;IF NEQ NO
	BSBW	DCL$SETNBLK		;CHECK CHARACTER AFTER FUNCTION NAME
	CMPB	#^A/(/,R0		;POSSIBLY LEXICAL FUNCTION?
	BNEQ	60$			;IF NEQ NO
	SUBL	#2,R6			;REDUCE LENGTH OF FUNCTION NAME
	BGTR	18$			;IF LEQ NOT LEXICAL FUNCTION NAME
60$:	CLRQ	R0			;FAILURE, NO SUCH FUNCTION, NULL VALUE
	MOVL	SP,R2			;INDICATE RESULT IS A STRING
	BRW	90$			;EXIT
70$:	STATUS	IVFNAM			;SET INVALID FUNCTION NAME STATUS
	BRB	85$
80$:	STATUS	ABFNAM			;SET AMBIGUOUS FUNCTION NAME STATUS
85$:	BICB	#^X80,(R7)		;UNDO MATCH OPTIMIZATION
	MOVAW	-(R7),WRK_L_MARKPTR(R10) ;SET STARTING ADDRESS OF FUNCTION NAME
	BRW	DCL$PARSERR

;
; SEARCH LEXICAL FUNCTION NAME TABLE FOR A MATCH
;
18$:	BSBW	DCL$MOVCHAR		;COPY ( CHARACTER
	BISB	#^X80,(R7)		;SET FORCE MATCH FLAG
	MATCHC	R6,(R7),#LXFUNTABLEN,LXFUNTABLE ;SEARCH FOR FUNCTION NAME MATCH
	BNEQ	70$			;BRANCH IF NO MATCH FOUND
	ADDL	R6,R2			;CALCULATE BYTES REMAINING INCLUDING SUBSTRING
	DIVL3	#ARG_C_ENTSIZE,R2,R8	;CALCULATE COMPLETE TABLE ENTRY NUMBER
	MATCHC	R6,(R7),#10,(R3)	;SCAN FOR DUPLICATE MATCH
	BEQL	80$			;IF EQL DUPLICATE MATCH FOUND
;
; DETERMINE THE FUNCTION INDEX (R8) AND RETRIEVE THE NUMBER OF ARGUMENTS
; THAT THE FUNCTION TAKES AS WELL AS THE ARGUMENT TYPES (NUMERIC OR STRING).
;
	SUBL3	R8,#LXFUNTABLEN/ARG_C_ENTSIZE,R8 ;CALCULATE REAL FUNCTION INDEX
	ASSUME	ARG_C_ENTSIZE EQ 8
	MOVAQ	LXFUNTABLE+4[R8],R7	;POINT TO ARGUMENT INFORMATION LONGWORD
	MOVL	(R7),R7			;SAVE IT IN REGISTER
;
; PARSE EACH FUNCTION ARGUMENT, STORING EITHER THE STRING DESCRIPTOR OR
; THE NUMERIC VALUE IN THE ARGUMENT DESCRIPTORS.  STRINGS ARE SAVED ON
; THE STACK IN ORDER TO MAKE FUNCTIONS RECURSIVE.
;
	MOVAB	-<MAX_ARGS*8+4>(SP),SP	;ALLOCATE ARGUMENT DESCRIPTORS + COUNT
	MOVC5	#0,(SP),#^XFF,#MAX_ARGS*8,4(SP) ;INIT ALL ARGS TO MISSING (-1)
	PUSHL	AP			;SAVE STARTING STACK ADDRESS IN -4(AP)
	MOVAB	4(SP),AP		;POINT TO START OF ARGUMENT LIST
	MOVL	AP,R5			;ADDRESS OF NEXT DESCRIPTOR TO FILL
	CLRL	(R5)+			;INITIALIZE # ARGUMENTS SPECIFIED

20$:	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS AND TABS
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	CMPB	NPARM(AP),R7		;ANY MORE ARGUMENTS TO PROCESS?
	BLSS	21$			;IF GEQ YES
	BRW	50$			;END OF ARGUMENTS
21$:	MOVL	#ARG_C_ANY,R6		;ASSUME EITHER BINARY OR STRING
	CMPB	NPARM(AP),#6		;BEYOND EXPLICITLY DEFINED ARGS?
	BGEQ	23$			;IF SO, ASSUME "ANY"
	ASHL	#2,NPARM(AP),R6		;CALCULATE OFFSET TO NIBBLE
	ADDL	#8,R6			;BIT POSITION OF NIBBLE IN R7
	EXTZV	R6,#8,R7,R6		;EXTRACT NIBBLE DESCRIBING ARGUMENT
					;AND NIBBLE DESCRIBING NEXT ARGUMENT
					;AS WELL, FOR END-OF-LIST CHECKS
;
; CHECK IF ARGUMENT MISSING
;
23$:	CMPB	R0,#^A','		;CHECK IF ARGUMENT NULL
	BEQL	28$			;BRANCH IF NULL
	CMPB	R0,#^A')'		;CHECK IF ARGUMENT NULL
	BEQL	28$			;BRANCH IF NULL
;
; PARSE ARGUMENT EXPRESSION
;
	CMPZV	#ARG_V_TYPE,#ARG_S_TYPE,R6,#ARG_C_SYMREF ;REFERENCE TO SYMBOL?
	BEQL	30$			;BRANCH IF SO
	BSBW	DCL$EXPRESS		;GET VALUE OF EXPRESSION
	BLBC	R0,22$			;BRANCH IF ERROR DETECTED
;
; VERIFY THAT THE EXPRESSION ARGUMENT WAS THE EXPECTED TYPE (STRING OR BINARY)
; IF IT WASN'T, THEN CONVERT THE EXPRESSION TO THE PROPER MODE, IF POSSIBLE.
;
	CMPZV	#ARG_V_TYPE,#ARG_S_TYPE,R6,#ARG_C_ANY ;ANY TYPE ALLOWED?
	BEQL	40$			;BRANCH IF SO
	TSTL	R2			;CHECK IF STRING OR BINARY LONGWORD
	ASSUME	ARG_C_BINARY EQ 0
	ASSUME	ARG_C_STRING EQ 1
	BLBS	R6,27$			;BRANCH IF EXPECTED STRING ARGUMENT
	BEQL	40$			;OK IF EXPECTED NUMERIC AND GOT IT
	JSB	DCL$CVT_BINARY		;CONVERT STRING TO BINARY
	BLBC	R0,22$			;BRANCH IF ERROR DETECTED
	BRB	40$
27$:	BNEQ	40$			;OK IF EXPECTED STRING AND GOT IT
	MOVL	R1,R0			;SET BINARY VALUE TO CONVERT
	JSB	DCL$CBTA_DEC		;CONVERT BINARY VALUE TO DECIMAL STRING
	BRB	40$			;USE CONVERTED STRING AS ARGUMENT
;
; AN ERROR HAS OCCURRED.  IF WE ARE IN A COMMENT, JUST STORE
; AN ARGUMENT OF NULL OR ZERO AND CONTINUE.
;
22$:	BBS	#WRK_V_COMMENT,WRK_W_FLAGS(R10),24$ ;SKIP IF IN COMMENT
	BRW	DCL$PARSERR		;OTHERWISE, REPORT THE ERROR
24$:	CLRQ	R1			;IF IN COMMENT, CONTINUE WITH A ZERO
	BRB	40$
;
; PROCESS AN EMPTY ARGUMENT.  IF ALLOWED, -1 WILL APPEAR IN THE QUADWORD
; TO INDICATE MISSING ARGUMENT.
;
28$:	BBS	#ARG_V_OPTIONAL,R6,43$	;BRANCH IF OPTIONAL VALUES ALLOWED
	BSBW	DCL$MOVCHAR		;MOVE DELIMITER TO EXPANSION BUFFER
29$:	BRW	95$			;AND REPORT MISSING ARGUMENT
;
; PARSE ARGUMENT TO BE STORED BY REFERENCE RATHER THAN BY VALUE
;
30$:	BSBW	DCL$GETOKEN		;GET ARGUMENT SYMBOL OR LITERAL
	CMPB	(R2),#^A'"'		;QUOTED STRING?
	BEQL	29$			;IF SO, ERROR - NOT BY REFERENCE
;
; STORE STRING ARGUMENT ON STACK TO PRESERVE IT OVER RECURSION
;
40$:	TSTL	R2			;STRING ARGUMENT?
	BEQL	42$			;IF NOT, JUST STORE LONGWORD
	BBC	#ARG_V_KEYWORD,R6,41$	;KEYWORD ARGUMENT?
	BSBW	DCL$SQUEEZE		;EDIT THE KEYWORD LIST
41$:	SUBL	R1,SP			;ALLOCATE SPACE FOR STRING ON STACK
	MOVL	R1,(R5)+		;SAVE STRING LENGTH
	MOVL	SP,(R5)+		;SAVE (COPIED) STRING ADDRESS
	PUSHL	R5			;SAVE REGISTERS
	MOVC	R1,(R2),4(SP)		;SAVE ARGUMENT STRING ON STACK
	POPL	R5			;RESTORE REGISTERS
	BRB	45$

42$:	MOVQ	R1,(R5)			;STORE VALUE IN QUADWORD
43$:	ADDL	#8,R5			;SKIP TO NEXT ARGUMENT DESCRIPTOR
45$:	INCL	NPARM(AP)		;INCREMENT # ARGUMENTS FOUND
	BSBW	DCL$SETNBLK		;SKIP TRAILING SPACES
	CMPB	NPARM(AP),R7		;LAST PARAMETER TO PROCESS?
	BEQL	50$			;IF EQL YES
	BSBW	DCL$MOVCHAR		;GET NEXT INPUT CHARACTER
	CMPB	#^A/,/,R0		;TRAILING COMMA?
	BNEQ	48$			;BRANCH IF NOT
	BRW	20$			;LOOP THRU ALL ARGUMENTS
48$:	CMPB	R7,#6			;VARIABLE # ARGUMENTS?
	BGTRU	55$			;BRANCH IF SO
	BBS	#4+ARG_V_OPTIONAL,R6,55$ ;OK IF NEXT ARGUMENT IS OPTIONAL
	BRB	95$			;ERROR IF REQUIRED ARGUMENT NOT PRESENT

50$:	BSBW	DCL$MOVCHAR		;GET NEXT INPUT CHARACTER
55$:	CMPB	#^A/)/,R0		;TRAILING RIGHT PARENTHESIS?
	BNEQ	100$			;IF NEQ NO
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
;
; CONSTRUCT A DESCRIPTOR OF SCRATCH BUFFER SPACE AND CALL THE APPROPRIATE
; LEXICAL FUNCTION ROUTINE TO OBTAIN THE RESULT STRING.
;
	MOVL	WRK_L_EXPANDPTR(R10),R3	;BUILD DESCRIPTOR OF SCRATCH AREA
	SUBL3	WRK_L_EXPANDPTR(R10),WRK_L_CHARPTR(R10),R2 ;SET UNUSED LENGTH
	BSBB	DISPATCH		;DISPATCH FUNCTION
;
; R1/R2 NOW DESCRIBE THE FUNCTION RESULT:
;	IF R2 NONZERO, R1/R2 ARE A STRING DESCRIPTOR
;	IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;
; RESULTANT STRING MIGHT NOW RESIDE ON THE STACK (E.G. AN EXTRACT
; OF AN ARGUMENT STORED ON THE STACK).  WE MUST COPY IT TO THE EXPANSION
; BUFFER BEFORE RETURNING IT TO THE CALLER.
;
	TSTL	R2			;CHARACTER STRING?
	BEQL	58$			;BRANCH IF NOT
	MOVL	R1,R6			;SAVE LENGTH OF STRING
	MOVC	R1,(R2),@WRK_L_EXPANDPTR(R10) ;COPY IT TO UNUSED EXPANSION AREA
	MOVL	R6,R1			;RETURN LENGTH OF RESULT STRING
	MOVL	WRK_L_EXPANDPTR(R10),R2	;AND ADDRESS OF RESULT STRING
58$:	MOVL	#1,R0			;SUCCESS
	MOVL	-(AP),SP		;REMOVE ALL TEMPORARIES FROM STACK
90$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9,AP> ; RESTORE REGISTERS
	RSB
 
;
; INVALID SYMBOL DELIMITER
;
95$:	MOVL	#CLI$_ARGREQ,R0		;SET ARGUMENT REQUIRED STATUS
	BRB	105$			; 
100$:	STATUS	SYMDEL			;SET INVALID SYMBOL DELIMITER STATUS
105$:	MOVL	WRK_L_CHARPTR(R10),WRK_L_EXPANDPTR(R10) ;SET ADDRESS OF NEXT CHARACTER IN BUFFER
	SUBL3	#1,WRK_L_EXPANDPTR(R10),WRK_L_MARKPTR(R10) ;SET ADDRESS OF INVALID DELIMITER
	TSTB	@WRK_L_CHARPTR(R10)	;AT END OF LINE?
	BNEQ	110$			;IF NEQ NO
	DECL	WRK_L_CHARPTR(R10)	;BACK UP TO END OF LINE
110$:	BRW	DCL$PARSERR		;

;
; DISPATCH TO PROPER LEXICAL FUNCTION ROUTINE
;
; ON INPUT TO ROUTINE:
;
;	R2/R3 = DESCRIPTOR OF SCRATCH AREA
;	R10 = ADDRESS OF PARSING WORK AREA (WRK)
;	R11 = ADDRESS OF PROCESS WORK AREA (PRC)
;
;	P1(AP) = DESCRIPTOR OF FIRST ARGUMENT VALUE
;	P2(AP) = DESCRIPTOR OF SECOND ARGUMENT VALUE
;	P3(AP) = DESCRIPTOR OF THIRD ARGUMENT VALUE
;	ETC. (UP TO MAX_ARGS)
;
; ON OUTPUT FROM ROUTINE:
;
;	R1/R2 = A QUADWORD DESCRIBING THE FUNCTION RESULT
;		IF R2 NONZERO, THEN R1/R2 IS A STRING DESCRIPTOR
;		IF R2 ZERO, THEN R1 IS A BINARY LONGWORD VALUE.
;
;	R3-R9 DESTROYED.
;
 
DISPATCH:
	CASE	R8,<-
		F$CVSINTEGER,-		;CONVERT SIGNED INTEGER
		F$CVUINTEGER,-		;CONVERT UNSIGNED INTEGER
		F$CVTIME,-		;CONVERT TO COMPARABLE DATE/TIME
		F$DIRECTORY,-		;DEFAULT DIRECTORY
		F$EDIT,-		;EDIT A STRING
		F$ELEMENT,-		;FIND A STRING ELEMENT
		F$ENVIRONMENT,-		;GET DCL INFORMATION
		F$EXTRACT,-		;EXTRACT SUBSTRING FROM STRING
		F$FAO,-			;FORMATTED ASCII OUTPUT
		F$FILE,-		;GET FILE ATTRIBUTES
		F$GETDVI,-		;GETDVI SYSTEM SERVICE
		F$GETJPI,-		;GETJPI SYSTEM SERVICE
		F$GETSYI,-		;GETSYI SYSTEM SERVICE
		F$IDENTIFIER,-		;CONVERT IDENTIFIER
		F$INTEGER,-		;CONVERT TO INTEGER
		F$LENGTH,-		;STRING LENGTH
		F$LOCATE,-		;LOCATE SUBSTRING
		F$LOGICAL,-		;LOGICAL NAME TRANSLATION
		F$MESSAGE,-		;GET MESSAGE
		F$MODE,-		;JOB MODE
		F$PARSE,-		;PARSE FILE SPECIFICATION
		F$PID,-			;GET NEXT PROCESS ID
		F$PRIVILEGE,-		;TRUE IF PRIVS SET/CLEAR
		F$PROCESS,-		;PROCESS NAME
		F$SEARCH,-		;SEARCH FOR NEXT WILDCARD FILESPEC
		F$SETPRV,-		;SETPRV SYSTEM SERVICE
		F$STRING,-		;CONVERT TO ASCII STRING
		F$TIME,-		;CURRENT TIME AND DATE
		F$TRNLNM,-		;LOGICAL NAME TRANSLATION
		F$TYPE,-		;TYPE OF SYMBOL
		F$USER,-		;USER IDENTIFICATION
		F$VERIFY,-		;VERIFY MODE
		>			;
	CLRL	R1			;RETURN NULL STRING
	RSB				;

	.SBTTL	CONVERT SIGNED AND UNSIGNED INTEGER FIELD
;+
; F$CVSINTEGER - CONVERT SIGNED INTEGER
; F$CVUINTEGER - CONVERT UNSIGNED INTEGER
;
; THIS LEXICAL FUNCTION RETURNS THE BINARY DATA EXTRACTED FROM AN ARBITRARY
; FIELD IN A STRING.
;
;	F$CVSINTEGER(POSITION, SIZE, STRING)
;	F$CVUINTEGER(POSITION, SIZE, STRING)
;
; INPUTS:
;
;	P1(AP) = STARTING BIT NUMBER
;	P2(AP) = NUMBER OF BITS
;	P3(AP) = DESCRIPTOR OF TEXT STRING.
;
; OUTPUTS:
;
;	R1 = CONVERTED BINARY LONGWORD
;	R2 = 0 TO INDICATE BINARY DATA TYPE
;-
 
	.ENABL	LSB
F$CVSINTEGER:				;CONVERT SIGNED INTEGER
	MOVL	#1,R5			;SET SIGNED CONVERSION INDICATOR
	BRB	10$			;
F$CVUINTEGER:				;CONVERT UNSIGNED INTEGER
	CLRL	R5			;SET UNSIGNED CONVERSION INDICATOR
10$:	CMPL	#32,P2(AP)		;SIZE VALUE GREATER THAN 1 LONGWORD?
	BLSSU	90$			;IF GEQU NO
	CLRL	R1			;ASSUME FIELD IS NOT DEFINED
	ADDL3	P2(AP),P1(AP),R3	;CALCULATE ENDING BIT POSITION
	MULL3	#8,P3(AP),R2		;CALCULATE SIZE OF STRING IN BITS
	CMPL	P1(AP),R2		;FIELD POSITION BEYOND END OF STRING?
	BGEQU	90$			;IF GEQU YES
	SUBL	R3,R2			;FIELD POSITION TOTALLY WITHIN STRING?
	BLSS	90$			;IF GEQ YES
	BLBS	R5,50$			;IF LBS SIGNED CONVERSION
	EXTZV	P1(AP),P2(AP),@P3+4(AP),R1 ;EXTRACT FIELD
	BRB	60$			;
50$:	EXTV	P1(AP),P2(AP),@P3+4(AP),R1 ;EXTRACT SIGNED FIELD
60$:	CLRL	R2			;MARK RESULT IS BINARY DATA
	RSB				;

90$:	MOVL	#CLI$_INVRANGE,R0	;SET INVALID RANGE MESSAGE
	BRW	ERROR			;SIGNAL ERROR
	.DSABL	LSB

	.SBTTL	CONVERT TO COMPARABLE DATE/TIME STRING
;+
; F$CVTIME - CONVERT TO COMPARABLE DATE/TIME STRING
;
; THIS FUNCTION CONVERTS A STANDARD VMS DATE/TIME STRING INTO A
; STRING OF THE FORM "YYYY-MM-DD HH:MM:SS.NN", WHICH CAN BE COMPARED
; TO ANOTHER STRING OF THE SAME FORM USING THE STRING COMPARISION
; OPERATORS.  IT CAN ALSO BE USED TO GENERATE A STANDARDIZED DATE/TIME
; STRING OR TO EXTRACT ITEMS FROM A STARDIZED DATE/TIME STRING.
;
;	F$CVTIME(TIME, ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF DATE/TIME STRING
;	P2(AP) = DESCRIPTOR OF TIME TYPE
;	P3(AP) = DESCRIPTOR OF ITEM KEYWORD
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF REQUESTED DATE/TIME STRING
;-
TIME_DELIMS:
	.ASCII	/:-. /

F$CVTIME:
;
; Build the result buffer descriptor.
;
	ADDL3	#24,R3,-(SP)			;BUILD TIME BUFFER DESCRIPTOR
	MOVL	R3,R9				;SAVE ADDR OF SECOND DESCR
	MOVL	R2,-(SP)			;
	CMPL	#24+23,(SP)			;TIME BUFFER LARGE ENOUGH?
	BLEQU	10$				;IF LEQU YES
	ADDL	#2*4,SP				;RESTORE THE STACK
	BRW	BUFOVF				;REPORT BUFFER OVERFLOW

;
; Get the type information.
;
10$:	CLRL	R8				;ASSUME NO TYPE SPECIFIED
	TSTL	P2(AP)				;WAS A TYPE SPECIFIED?
	BLSS	20$				;NO, THEN USE DEFAULT
	MOVAB	CVTIME_TYPES,R4			;GET ADDRESS OF ITEM TABLE
15$:	MOVZBL	(R4),R5				;GET LENGTH OF ITEM
	BEQL	16$				;BRANCH IF END OF TABLE
	CMPC5	P2(AP),@P2+4(AP),#0,R5,1(R4)	;DOES ITEM MATCH
	BEQL	17$				;BRANCH IF SO
	MOVAB	2(R4)[R5],R4			;SKIP TO NEXT TABLE ENTRY
	BRB	15$				;
16$:	ADDL	#2*4,SP				;RESTORE THE STACK
	STATUS	IVKEYW				;SET STATUS
	BRW	P2_ERROR			;REPORT KEYWORD ERROR
17$:	MOVZBL	1(R4)[R5],R8			;SET THE TYPE

;
; Call LIB$CVT_TIME or LIB$CVT_DTIME to get the time string.
;
20$:	MOVL	SP,R5				;GET ADDRESS OF BUFFER DESCR
	CLRQ	-(SP)				;ALLOC TIME QUADWORD
	CLRL	R3				;SET ADDRESS OF INPUT DESCR
	TSTL	P1(AP)				;WAS P1 SPECIFIED?
	BLSS	23$				;NO, THEN SKIP
	MOVQ	P1(AP),R1			;GET INPUT DESCRIPTOR
	BSBW	DCL$TRIM			;UPCASE AND TRIM IT
	MOVQ	R1,P1(AP)			;RETURN THE DESCRIPTOR
	BRB	25$				;
23$:	CLRQ	P1(AP)				;USE A NULL INPUT DESCRIPTOR
25$:	MOVAQ	P1(AP),R3			;GET INPUT DESCRIPTOR ADDR
	PUSHL	R5				;PUSH ADDRESS OF DESCRIPTOR TWICE
	PUSHL	R5				;
	PUSHAQ	-8(R5)				;PUSH TIME BUFFER ADDR
	PUSHL	R3				;PUSH INPUT DESCRIPTOR
	CMPL	R8,#2				;IS DELTA TIME REQUESTED?
	BEQL	27$				;YES, THEN BRANCH

	CALLS	#4,LIB$CVT_TIME			;PARSE THE TIME SPECIFICATION
	BLBS	R0,30$				;BRANCH IF SUCCESS
	ADDL	#16,SP				;RESTORE THE STACK
	STATUS	IVATIME				;SET ERROR STATUS
	BRW	P1_ERROR			;REPORT TIME SYNTAX ERROR

27$:	CALLS	#4,LIB$CVT_DTIME		;PARSE THE TIME SPECIFICATION
	BLBS	R0,30$				;BRANCH IF SUCCESS
	ADDL	#16,SP				;RESTORE THE STACK
	STATUS	IVDTIME				;SET ERROR STATUS
	BRW	P1_ERROR			;REPORT TIME SYNTAX ERROR

;
; Get the item information.
;
30$:	MOVAB	CVTIME_ITEMS,R4			;GET ADDRESS OF ITEM TABLE
	MOVZBL	(R4),R5				;GET LENGTH OF ITEM
	MOVAB	1(R4)[R5],R4			;GET ADDRESS OF DATA
	MOVZWL	(R4)[R8],-(SP)			;GET DEFAULT DATA
	TSTL	P3(AP)				;WAS AN ITEM SPECIFIED?
	BLSS	40$				;NO, THEN USE DEFAULT
	MOVAB	CVTIME_ITEMS,R4			;GET ADDRESS OF ITEM TABLE
35$:	MOVZBL	(R4),R5				;GET LENGTH OF ITEM
	BEQL	36$				;BRANCH IF END OF TABLE
	CMPC5	P3(AP),@P3+4(AP),#0,R5,1(R4)	;DOES ITEM MATCH
	BEQL	37$				;BRANCH IF SO
	MOVAB	7(R4)[R5],R4			;SKIP TO NEXT TABLE ENTRY
	BRB	35$				;
36$:	ADDL	#20,SP				;RESTORE THE STACK
	STATUS	IVKEYW				;SET STATUS
	BRW	P3_ERROR			;REPORT KEYWORD ERROR
37$:	MOVAB	1(R4)[R5],R4			;GET ADDRESS OF DATA
	MOVZWL	(R4)[R8],(SP)			;SET THE POSITION AND LENGTH
	BNEQ	40$				;IF NONZERO, THEN CONTINUE
	CMPL	R8,#2				;IS DELTA TIME REQUESTED?
	BEQL	36$				;YES, THEN ERROR
	BRW	90$				;NO, THEN RETURN WEEKDAY

;
; Return requested information.
;
40$:	MOVQ	12(SP),R6			;GET TIME STRING DESCRIPTOR
	TSTL	R8				;WAS "COMPARISON" SPECIFIED?
	BNEQ	60$				;NO, THEN BRANCH

;
; Convert to ASCII comparable time.
;
	CMPL	#23,R6				;IS DAY ONE DIGIT OR TWO?
	BEQL	50$				;BRANCH IF TWO
	MOVB	#^A'0',-(R7)			;INSERT A ZERO
	INCL	R6				;INCREASE TIME LENGTH
50$:	MOVAB	MONTH_TABLE,R4			;POINT TO MONTH TABLE
	CLRL	R0				;START WITH MONTH #0
51$:	CMPL	3(R7),(R4)+			;DOES MONTH MATCH?
	BEQL	52$				;BRANCH IF FOUND
	AOBLSS	#12,R0,51$			;LOOP UNTIL END OF TABLE
52$:	MOVL	R9,R3				;POINT TO SECOND DATE/TIME BUFFER
	MOVL	7(R7),(R3)+			;MOVE YEAR NUMBER
	MOVB	#^A'-',(R3)+			;MOVE DASH
	MOVW	MONTH_NO_TABLE[R0],(R3)+	;MOVE MONTH NUMBER
	MOVB	#^A'-',(R3)+			;MOVE DASH
	MOVW	(R7),(R3)+			;MOVE DAY NUMBER
	MOVQ	11(R7),(R3)+			;MOVE 12 CHARACTERS OF TIME STRING
	MOVL	19(R7),(R3)+			;
	MOVL	R9,R7				;RESET TIME POINTER
	DECL	R6				;DECREASE TIME LENGTH

;
; Extract requested field.
;
60$:	EXTZV	#8,#8,(SP),R5			;GET NUMBER OF DELIMS
	MOVZBL	(SP),R4				;GET STARTING DELIM #
	BEQL	67$				;BRANCH IF ZERO
65$:	DECL	R6				;DECR STRING SIZE
	LOCC	(R7)+,#4,TIME_DELIMS		;IS CHAR A DELIM?
	BEQL	65$				;NO, THEN SKIP IT
	SOBGTR	R4,65$				;COPY UNTIL NO MORE DELIMS
67$:	MOVL	R9,R2				;INIT RESULT DESCR
	CLRL	R3				;
70$:	MOVB	(R7)+,(R9)+			;COPY A CHARACTER
	INCL	R3				;INCR THE RESULT LENGTH
	DECL	R6				;DECR STRING SIZE
	BEQL	75$				;DONE IF ZERO
	LOCC	(R7),#4,TIME_DELIMS		;IS NEXT CHAR A DELIM?
	BEQL	70$				;NO, THEN MOVE NEXT CHAR
	SOBGTR	R5,70$				;COPY UNTIL NO MORE DELIMS
75$:	MOVL	R3,R1				;GET RESULT LENGTH
	ADDL	#20,SP				;RESTORE THE STACK
	RSB					;RETURN

;
; Return day of week.
;
90$:	EDIV	#600000000,4(SP),12(SP),R0	; GET MINUTES SINCE BASE TIME VALUE
	CLRL	16(SP)				;
	EDIV	#60*24,12(SP),12(SP),R0		; GET DAYS SINCE BASE TIME
	ADDL	#2,12(SP)			; ADJUST FOR BASE DAY BEING WED.
	CLRL	16(SP)				;
	EDIV	#7,12(SP),12(SP),R0		; GET DAY OF WEEK
	MOVAB	WEEKDAY_TABLE,R2		; GET WEEKDAY TABLE ADDR
	MULL	#10,R0				; GET WEEKDAY TABLE OFFSET
	MOVAB	(R2)[R0],R2			; GET ASCIC WEEKDAY
	MOVZBL	(R2)+,R1			; GET WEEKDAY DESCR
	ADDL	#20,SP				; RESTORE THE STACK
	RSB					; RETURN

	.SBTTL	RETURN DEFAULT DIRECTORY NAME STRING
;+
; F$DIRECTORY - RETURN DEFAULT DIRECTORY NAME STRING
;
; THIS LEXICAL FUNCTION RETURNS THE ADDRESS AND LENGTH OF THE CURRENT DEFAULT
; DIRECTORY STRING.
;
;	F$DIRECTORY()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF DEFAULT DIRECTORY STRING.
;	R2 = ADDRESS OF DEFAULT DIRECTORY STRING.
;-
 
F$DIRECTORY:				;RETURN DEFAULT DIRECTORY STRING
	MOVAB	@#PIO$GT_DDSTRING,R2	;GET ADDRESS OF DEFAULT DIRECTORY STRING
	MOVZBL	(R2)+,R1		;GET LENGTH OF DEFAULT DIRECTORY STRING
	RSB				;

	.SBTTL	EDIT A STRING
;+
; F$EDIT - EDIT A STRING
;
; THIS LEXICAL FUNCTION PERFORMS THE EDITS A STRING, AS DIRECTED BY AN 
; ITEM LIST.
;
;	F$EDIT (STRING, ITEM_LIST)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF TEXT STRING
;	P2(AP) = ITEM LIST
;
; OUTPUTS:
;
;	R1 = LENGTH OF EDITED STRING.
;	R2 = ADDRESS OF EDITED STRING.
;-
 
F$EDIT:
	MOVQ	P2(AP),R4		;GET DESCRIPTOR OF COMMA SEPARATED LIST
	CLRL	R8			;CLEAR THE FLAGS
10$:	MOVQ	R4,R2			;ASSUME NO COMMA IN LIST
	BISL	#EDIT_M_EOL,R8		;ASSUME END OF LIST
	LOCC	#^A',',R4,(R5)		;LOCATE END OF NEXT KEYWORD
	BEQL	20$			;BRANCH IF NOT FOUND, USE ENTIRE STRING
	BICL	#EDIT_M_EOL,R8		;NOT END OF LIST
	SUBL3	R0,R4,R2		;ISOLATE THE KEYWORD
	MOVAB	-(R0),R4		;CHOP THE KEYWORD OFF THE LIST
	MOVAB	1(R1),R5		;

20$:	MOVAB	EDIT_TABLE,R6		;GET ADDRESS OF TABLE
30$:	MOVZBL	(R6),R7			;GET LENGTH OF ITEM NAME
	BEQL	90$			;BRANCH IF END OF TABLE
	MOVQ	R2,-(SP)		;SAVE REGISTERS
	MOVQ	R4,-(SP)		;
	CMPC5	R2,(R3),#0,-		;DOES ITEM NAME MATCH?
		R7,1(R6) 		;
	BEQL	50$			;BRANCH IF ITEM FOUND
	MOVQ	(SP)+,R4		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVAB	2(R6)[R7],R6		;SKIP TO NEXT ENTRY IN TABLE
	BRB	30$			;LOOP UNTIL FOUND
50$:	MOVQ	(SP)+,R4		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	BISB	1(R6)[R7],R8		;SET OPTION BIT
	BBCC	#EDIT_V_EOL,R8,10$	;PROCESS NEXT KEYWORD IN LIST

60$:	MOVQ	P1(AP),R1		;GET DESCRIPTOR INPUT STRING
	MOVL	R8,R0			;GET EDITING FLAGS
	BSBW	DCL$EDIT		;EDIT THE STRING
	RSB

90$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	BRW	P2_ERROR

	.SBTTL	FIND A STRING ELEMENT
;+
; F$ELEMENT - FIND A STRING ELEMENT
;
; THIS LEXICAL FUNCTION EXTRACTS A SPECIFIED STRING ELEMENT FROM A STRING.
;
;	F$ELEMENT (NUMBER, DELIMITER, STRING)
;
; INPUTS:
;
;	P1(AP) = ELEMENT NUMBER (BASED AT ZERO)
;	P2(AP) = DESCRIPTOR OF SINGLE CHARACTER DELIMITER
;	P3(AP) = DESCRIPTOR OF TEXT STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EXTRACTED ELEMENT.
;	R2 = ADDRESS OF EXTRACTED ELEMENT.
;-
 
F$ELEMENT:
	MOVL	P1(AP),R3		;GET ELEMENT NUMBER
	TSTL	R3			;POSITIVE?
	BLSS	85$			;NO, THEN ERROR
	MOVQ	P2(AP),R4		;GET DELIMITER STRING
	MOVQ	P3(AP),R0		;GET TEXT STRING
	CMPL	#1,R4			;IS IT EXACTLY ONE CHAR?
	BNEQ	90$			;NO, THEN ERROR
	INCL	R0			;SET INITIAL LENGTH
	DECL	R1			;SET INITIAL POINTER

10$:	INCL	R1			;POINT PAST DELIMITER
	DECL	R0			;
	MOVL	R1,R2			;REMEMBER START OF ELEMENT
	LOCC	(R5),R0,(R1)		;LOCATE DELIMITER IN STRING
	BEQL	80$			;IF NOT FOUND, THEN RETURN DELIMITER
	SOBGEQ	R3,10$			;LOOP UNTIL WE FIND THE RIGHT ELEMENT
70$:	SUBL	R2,R1			;CALCULATE LENGTH OF ELEMENT
	RSB

80$:	TSTL	R3			;IF LAST ELEMENT
	BEQL	70$			;THEN RETURN IT
	MOVL	#1,R1			;RETURN DELIMITER
	MOVL	R5,R2			;
	RSB

85$:	MOVL	#CLI$_INVRANGE,R0	;ASSUME RANGE WILL BE INVALID
	BRW	ERROR			;SIGNAL ERROR

90$:	MOVL	#CLI$_STRTOOLNG,R0	;DELIMITER IS MORE THAN ONE CHAR
	BRW	P2_ERROR		;SIGNAL ERROR

	.SBTTL	GET DCL INFORMATION
;+
; F$ENVIRONMENT - GET DCL INFORMATION
;
; THIS LEXICAL FUNCTION RETRIEVES SPECIFIC INFORMATION ABOUT THE DCL PROCESS
; CONTEXT.
;
;	F$ENVIRONMENT (ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF ITEM
;
; OUTPUTS:
;
;	R1 = LENGTH OF REQUESTED INFORMATION
;	R2 = ADDRESS OF REQUESTED INFORMATION
;-
 
F$ENVIRONMENT:
	MOVAB	ENVIRON_TABLE,R6	;GET ADDRESS OF TABLE
	MOVQ	R2,-(SP)		;SAVE THE SCRATCH DESCR

10$:	MOVZBL	(R6),R7			;GET LENGTH OF ITEM NAME
	BEQL	20$			;BRANCH IF END OF TABLE
	CMPC5	P1(AP),@P1+4(AP),#0,-	;DOES ITEM NAME MATCH?
		R7,1(R6) 		;
	BEQL	90$			;BRANCH IF ITEM FOUND
	MOVAB	2(R6)[R7],R6		;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$			;LOOP UNTIL FOUND

20$:	MOVQ	(SP)+,R2		;RESTORE THE SCRATCH DESCR
	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	BRW	P1_ERROR

90$:	MOVQ	(SP)+,R2		;RESTORE THE SCRATCH DESCR
	CASE	1(R6)[R7],TYPE=B,<-	;CASE ON ITEM
		100$,-			;CONTROL
		110$,-			;NOCONTROL
		200$,-			;DEFAULT
		300$,-			;DEPTH
		400$,-			;ON_SEVERITY
		500$,-			;PROMPT
		600$,-			;PROMPT_CONTROL
		700$,-			;PROTECTION
		800$,-			;MESSAGE
		900$,-			;MAX_DEPTH
		1000$,-			;ON_CONTROL_Y
		1100$,-			;PROCEDURE
		1200$,-			;KEYPAD_STATE
		1300$,-			;VERIFY_PROCEDURE
		1400$,-			;VERIFY_IMAGE
		1500$,-			;CAPTIVE
		1600$,-			;INTERACTIVE
		1700$>			;OUTPUT_RATE

;
; RETURN [NO]CONTROL INFORMATION
;
100$:	MOVL	#1,R0			;TEST IF BIT IS SET
	BRB	120$			;SKIP
110$:	CLRL	R0			;TEST IF BIT IS CLEAR
120$:	CMPL	#3,R2			;IS RETURN BUFFER BIG ENOUGH?
	BGTRU	190$			;BRANCH IF NOT
	MOVL	R3,R6			;COPY ADDRESS OF SCRATCH SPACE
	CMPZV	#PRC_V_CTRLT,#1,-	;CHECK CTRL/T
		PRC_L_OUTOFBAND(R11),R0	;
	BNEQ	130$			;SKIP IF NOT EQUAL
	MOVB	#^A/T/,(R3)+		;INSERT T IN STRING
130$:	CMPZV	#PRC_V_CTRLY,#1,-	;CHECK CTRL/Y
		PRC_L_OUTOFBAND(R11),R0	;
	BNEQ	150$			;SKIP IF NOT EQUAL
	CMPL	R3,R6			;HAVE WE INSERTED ANYTHING YET?
	BEQL	140$			;NO, THEN SKIP
	MOVB	#^A/,/,(R3)+		;INSERT A COMMA
140$:	MOVB	#^A/Y/,(R3)+		;INSERT Y IN STRING
150$:	SUBL3	R6,R3,R1		;GET LENGTH OF RESULT
	MOVL	R6,R2			;GET ADDRESS OF RESULT
	RSB				;

190$:	STATUS	BUFOVF			;SIGNAL BUFFER OVERFLOW ERROR
	BRW	ERROR

;
; RETURN DEFAULT
;
200$:	MOVQ	R2,-(SP)		;PUSH SCRATCH AREA DESCRIPTOR
	MOVL	SP,R8			;POINT R8 AT IT
	BSBW	DCL$SHOWDEFINT		;GET DEFAULT DIRECTORY SPEC
	ADDL	#8,SP			;RESTORE THE STACK
	BSBW	DCL$TRIM		;REMOVE LEADING BLANKS
	RSB				;

;
; RETURN DEPTH
;
300$:	MOVL	PRC_L_INDEPTH(R11),R1	;GET COMMAND PROCEDURE DEPTH
	CLRL	R2			;RETURN IN INTEGER FORM
	RSB				;

;
; RETURN ON_SEVERITY
;
400$:	MOVZBL	PRC_W_ONLEVEL(R11),R0 	;GET SEVERITY NUMBER 
	BICB	#1,R0			;CLEAR THE CONTROL/Y BIT
	MOVAL	SEVERITY_TABLE[R0],R2	;GET ADDRESS OF ASCIC SEVERITY
	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF SEVERITY
	RSB				;

;
; RETURN PROMPT
;
500$:	MOVZBL	PRC_B_PROMPTLEN(R11),R1	;GET LENGTH OF PROMPT STRING
	SUBL	#3,R1			;REMOVE LENGTH OF CR/LF/_
	MOVAB	PRC_G_PROMPT(R11),R2	;GET ADDRESS OF PROMPT STRING
	RSB				;

;
; RETURN PROMPT_CONTROL
;
600$:	MOVL	#1,R1			;ASSUME CR/LF SPECIFIED
	BBS	#PRC_V_CARRCNTL,PRC_W_FLAGS(R11),610$  ;SKIP IF SPECIFIED
	CLRL	R1			;RETURN FALSE OTHERWISE
610$:	BRW	FORMAT_BOOLEAN		;RETURN THE VALUE

;
; RETURN PROTECTION
;
700$:	CLRL	-(SP)			;WHERE TO RETURN PROTECTION
	MOVL	SP,-(SP)		;NOTE WHERE PROTECTION IS TO BE PUT
	CLRL	-(SP)			;DON'T WANT TO SET PROTECTION
	CALLS	#2,@#SYS$SETDFPROT	;GET DEFAULT PROTECTION
	MOVL	(SP)+,R4		;COPY PROTECTION TO USEFUL REG
	BRW	FORMAT_PROT		;CONVERT INTO ASCII FORM

;
; RETURN MESSAGE QUALIFIERS
;
800$:	MOVZBL	#^A"/",R8		;STORE FIELD DELIMITER
	MOVL	R3,R6			;COPY ADDRESS OF SCRATCH SPACE
	MOVB	R8,(R3)+		;INSERT A LEADING SLASH IN STRING

	CMPL	#46,R2			;IS SCRATCH BUFFER BIG ENOUGH?
	BGTRU	190$			;NO, THEN ERROR
	MOVZBL	G^CTL$GB_MSGMASK,R9	;GET MESSAGE MASK

	MOVAB	FACILITY,R0		;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R0)+,R1		;GET LENGTH/ADDRESS OF STRING
	BBS	#3,R9,810$		;IS FACILITY SPECIFIED?
	MOVW	#^A/NO/,(R3)+		;INSERT NO IN STRING
810$:	MOVC3	R1,(R0),(R3)		;MOVE STRING INTO DESCRIPTOR
	MOVB	R8,(R3)+		;INSERT DELIMITER

	MOVAB	SEVERITY,R0		;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R0)+,R1		;GET LENGTH/ADDRESS OF STRING
	BBS	#2,R9,820$		;IS SEVERITY SPECIFIED?
	MOVW	#^A/NO/,(R3)+		;INSERT NO IN STRING
820$:	MOVC3	R1,(R0),(R3)		;MOVE STRING INTO DESCRIPTOR
	MOVB	R8,(R3)+		;INSERT DELIMITER

	MOVAB	IDENT,R0		;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R0)+,R1		;GET LENGTH/ADDRESS OF STRING
	BBS	#1,R9,830$		;IS SEVERITY SPECIFIED?
	MOVW	#^A/NO/,(R3)+		;INSERT NO IN STRING
830$:	MOVC3	R1,(R0),(R3)		;MOVE STRING INTO DESCRIPTOR
	MOVB	R8,(R3)+		;INSERT DELIMITER

	MOVAB	TEXT,R0			;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R0)+,R1		;GET LENGTH/ADDRESS OF STRING
	BBS	#0,R9,840$		;IS TEXT SPECIFIED?
	MOVW	#^A/NO/,(R3)+		;INSERT NO IN STRING
840$:	MOVC3	R1,(R0),(R3)		;MOVE STRING INTO DESCRIPTOR

	SUBL3	R6,R3,R1		;GET LENGTH OF RESULT
	MOVL	R6,R2			;GET ADDRESS OF RESULT
	RSB				;

;
; RETURN MAX_DEPTH
;
900$:	MOVL	#MAX_DEPTH,R1		;GET MAXIMUM DEPTH OF COMMAND PROCEDURES
	CLRL	R2			;RETURN AS INTEGER
	RSB				;

;
; RETURN ON_CONTROL_Y
;
1000$:	MOVL	#1,R1			;ASSUME HANDLER SPECIFIED
	TSTL	PRC_L_ONCTLY(R11)	;IS IT?
	BNEQ	1010$			;YES, THEN SKIP
	CLRL	R1			;NO, THEN RETURN FALSE
1010$:	BRW	FORMAT_BOOLEAN		;RETURN THE VALUE

;
; RETURN PROCEDURE
;
1100$:	MOVL	PRC_L_IDFLNK(R11),R0	;GET ADDRESS OF IDF BLOCK
	MOVL	IDF_L_FILENAME(R0),R2	;GET ADDRESS OF ASCIC FILENAME
	BEQL	1110$			;SKIP IF NONE
	MOVZBL	(R2)+,R1		;GET LENGTH/ADDRESS OF FILENAME
	RSB				;

1110$:	CLRL	R1			;RETURN NO FILENAME PRESENT
	MOVL	SP,R2			;INDICATE NULL STRING
	RSB				;

;
; RETURN KEYPAD_STATE
;
1200$:	MOVL	PRC_L_CURRKEY(R11),R2	;GET ADDRESS OF ASCIC STATE
	MOVZBL	(R2)+,R1		;GET LENGTH/ADDRESS OF STATE
	RSB				;

;
; RETURN VERIFY_PROCEDURE
;
1300$:	CLRL	R1			;ASSUME NOVERIFY
	BBC	#PRC_V_VERIFY,-		;BRANCH IF NOVERIFY
		PRC_W_FLAGS(R11),1320$	;
1310$:	INCL	R1			;SET TRUE
1320$:	BRW	FORMAT_BOOLEAN		;RETURN TRUE/FALSE

;
; RETURN VERIFY_IMAGE
;
1400$:	CLRL	R1			;ASSUME NOVERIFY
	BBC	#PRC_V_VERIMAGE,-	;BRANCH IF NOVERIFY
		PRC_B_FLAGS2(R11),1320$	;
	BRB	1310$			;SET TRUE

;
; RETURN CAPTIVE
;
1500$:	MOVAB	G^CTL$AG_CLIDATA,R0	;GET ADDRESS OF PPD
	CLRL	R1			;ASSUME NOT CAPTIVE
	BBC	#PPD$V_CAPTIVE,-	;BRANCH IF NOT CAPTIVE ACCOUNT
		PPD$W_FLAGS(R0),1320$	;
	BRB	1310$			;SET TRUE

;
; RETURN INTERACTIVE
;
1600$:	CLRL	R1			;ASSUME NOT INTERACTIVE
	BBS	#PRC_V_MODE,-		;BRANCH IF NOT INTERACTIVE
		PRC_W_FLAGS(R11),1320$	;
	BRB	1310$			;SET TRUE

;
; RETURN OUTPUT_RATE
;
1700$:	MOVQ	R2,-(SP)		;SET UP RETURN DESCR
	BBC	#PRC_V_MODE,-		;BRANCH IF INTERACTIVE
		PRC_W_FLAGS(R11),1710$	;
	MOVL	SP,R0			;GET ADDR OF OUTPUT DESCR
	$ASCTIM_S TIMBUF=(R0),-		;CONVERT BINARY DELTA TIME TO ASCII
		TIMLEN=(R0),-		;
		TIMADR=PRC_Q_FLUSHTIME(R11)
	BLBC	R0,1710$		;BR IF ERROR IN TIME
	MOVQ	(SP)+,R1		;GET THE RESULT
	RSB				;RETURN DELTA TIME
1710$:	MOVQ	(SP)+,R1		;RETURN NULL
	CLRL	R1			;
	RSB				;

	.SBTTL	EXTRACT SUBSTRING FROM STRING
;+
; F$EXTRACT - EXTRACT SUBSTRING FROM STRING
;
; THIS LEXICAL FUNCTION EXTRACTS A SUBSTRING FROM AN ARGUMENT STRING AND RETURNS
; ITS DESCRIPTOR.
;
;	F$EXTRACT(POSITION, SIZE, STRING)
;
; INPUTS:
;
;	P1(AP) = STARTING CHARACTER NUMBER (BASED AT ZERO)
;	P2(AP) = NUMBER OF CHARACTERS
;	P3(AP) = DESCRIPTOR OF TEXT STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EXTRACTED SUBSTRING.
;	R2 = ADDRESS OF EXTRACTED SUBSTRING.
;-
 
F$EXTRACT:
	CLRL	R1			;ASSUME NULL SUBSTRING
	CMPL	P1(AP),P3(AP)		;STARTING POSITION BEYOND END OF STRING
	BGEQU	10$			;IF GTRU YES
	MOVL	P2(AP),R1		;GET NUMBER OF CHARACTERS TO EXTRACT
	ADDL3	P1(AP),P3+4(AP),R2	;CALCULATE STARTING ADDRESS OF SUBSTRING
	SUBL	P1(AP),P3(AP)		;REDUCE APPARENT STRING LENGTH BY POSITION
	SUBL	R1,P3(AP)		;REDUCE STRING BY LENGTH OF SUBSTRING
	BGEQU	10$			;IF GEQU STRING LENGTH SUFFICIENT
	ADDL	P3(AP),R1		;CALCULATE ACTUAL LENGTH OF SUBSTRING
10$:	RSB

	.SBTTL	FAO SYSTEM SERVICE
;+
; F$FAO - FORMATTED ASCII OUTPUT
;
; THIS LEXICAL FUNCTION INVOKES THE $FAO SYSTEM SERVICE WITH
; EITHER STRINGS OR LONGWORDS AS ARGUMENTS, DEPENDING ON THE
; TYPE OF THE ARGUMENT.
;
; F$FAO(CTRSTR,ARG1,ARG2,...)
;
; INPUTS:
;
;	NPARM(AP) = NUMBER OF ARGUMENTS SPECIFIED
;	P1(AP) = FIRST ARGUMENT
;	P2(AP) = SECOND ARGUMENT
;	ETC.
;
; OUTPUTS:
;
;	R1/R2 = RESULTANT STRING FROM $FAO
;-

F$FAO:
	MOVQ	R2,-(SP)		;ADDRESS OF RESULT BUFFER DESCRIPTOR
	MOVL	SP,R2			;ADDRESS OF BUFFER DESCRIPTOR
	SUBL3	#1,NPARM(AP),R0		;GET NUMBER OF FAO ARGUMENTS
	MOVAQ	P2(AP)[R0],R1		;START AT LAST ARGUMENT + 1
10$:	TSTL	-4(R1)			;BINARY LONGWORD OR STRING DESCRIPTOR?
	BNEQ	15$			;BRANCH IF STRING
	SUBL	#8,R1			;SKIP TO NEXT ARGUMENT
	PUSHL	(R1)			;PUSH LONGWORD BINARY VALUE
	BRB	20$
15$:	PUSHAQ	-(R1)			;PUSH ADDRESS OF DESCRIPTOR
20$:	SOBGTR	R0,10$			;LOOP THRU ALL FAO ARGUMENTS
	PUSHL	SP			;ADDRESS OF PARAMETER LIST
	PUSHL	R2			;ADDRESS OF BUFFER DESCRIPTOR
	PUSHL	R2			;ADDRESS OF WORD TO RECEIVE LENGTH
	PUSHAQ	P1(AP)			;ADDRESS OF STRING DESCRIPTOR
	CALLS	#4,G^SYS$FAOL		;INVOKE FAO SERVICE
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVL	R2,SP			;POP FAO ARGUMENTS OFF STACK
	POPR	#^M<R1,R2>		;RETRIEVE DESCRIPTOR OF RESULT STRING
30$:	RSB

90$:	ADDL3	#8,R2,SP		;CLEAN STACK
	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	GET FILE ATTRIBUTES
;+
; F$FILE_ATTRIBUTES - GET FILE INFORMATION
;
; THIS LEXICAL FUNCTION RETURNS A SPECIFIED ATTRIBUTE FOR A FILE
; BY USING THE RMS OPEN SYSTEM SERVICE TO OBTAIN THE INFORMATION.
;
;	F$FILE_ATTRIBUTES(FILESPEC,ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF FILE SPECIFICATION
;	P2(AP) = DESCRIPTOR OF RMS ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$FILE:
	MOVQ	R2,-(SP)			;PUSH DESCRIPTOR OF SCRATCH SPACE
	MOVL	SP,R9				;SAVE ADDRESS OF DESCRIPTOR
	MOVAB	FILE_TABLE,R7			;GET ADDRESS OF TABLE
10$:	MOVZBL	5(R7),R8			;GET LENGTH OF ITEM NAME
	BEQL	15$				;BRANCH IF END OF TABLE
	CMPC5	P2(AP),@P2+4(AP),#0,-		;DOES ITEM NAME MATCH?
		R8,6(R7) 			;
	BEQL	20$				;BRANCH IF ITEM FOUND
	MOVAB	6(R7)[R8],R7			;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$				;LOOP UNTIL FOUND
15$:	STATUS	IVKEYW				;UNDEFINED ITEM NAME
	BRW	P2_ERROR			;
20$:	MOVAB	-FAB$C_BLN(SP),SP		;ALLOCATE FAB ON STACK
	MOVL	SP,R6				;GET ADDRESS OF FAB
	MOVC5	#0,(SP),#0,#FAB$C_BLN,(R6) 	;ZERO STORAGE
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,-	;INITIALIZE FAB
		FAB$B_BID(R6) 			;
	MOVZBL	(R7),R0				;GET BLOCK INDEX
	CMPL	R0,#1				;FAB OR NAM BLOCK?
	BLSSU	50$				;BRANCH IF FAB ONLY IS NEEDED
	BEQL	40$				;BRANCH IF NAM BLOCK IS ALSO NEEDED
	MOVZWL	XAB_INFO-4[R0],R2		;GET XAB BLOCK ID & LENGTH
	ASHL	#-8,R2,R1			;ISOLATE BLOCK LENGTH
	SUBL	R1,SP				;ALLOCATE SPACE FOR XAB ON STACK
	PUSHL	R2				;SAVE R2
	MOVC5	#0,(SP),#0,R1,4(SP)		;ZERO STORAGE
	POPL	R2				;RESTORE R2
	ASSUME	XAB$B_BLN EQ XAB$B_COD+1
	MOVW	R2,XAB$B_COD(SP)		;STORE XAB BLOCK ID/LENGTH
	MOVL	SP,FAB$L_XAB(R6)		;POINT TO XAB BLOCK
	BRB	50$				;
40$:	MOVAB	-NAM$C_BLN-NAM$C_MAXRSS(SP),SP	;ALLOCATE SPACE FOR NAM BLOCK
	MOVC5	#0,(SP),#0,#NAM$C_BLN,(SP)	;ZERO STORAGE
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,-	;INITIALIZE NAM
		NAM$B_BID(SP) 			;
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(SP)	;SET SIZE OF EXPANDED BUFFER
	MOVAB	NAM$C_BLN(SP),NAM$L_ESA(SP)	;SET ADDRESS OF RESULT BUFFER
	MOVL	SP,FAB$L_NAM(R6)		;POINT TO NAM BLOCK
50$:	CMPB	#11,4(R7)			;KNOWN FILE CHECK?
	BNEQ	55$				;NO, THEN SKIP
	SETBIT	NAM$V_NOCONCEAL,-		;TRANSLATE CONCEALED LOG. NAMES
		NAM$B_NOP(SP)
	SETBIT	FAB$V_KFO,FAB$L_FOP(R6)		;SET KNOWN FILE OPEN
55$:	MOVB	P1(AP),FAB$B_FNS(R6)		;SET PRIMARY FILESPEC
	MOVL	P1+4(AP),FAB$L_FNA(R6)		;
	MOVB	#FAB$M_GET,FAB$B_FAC(R6)	;READ-ONLY ACCESS
	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_UPD!-;ALLOW OTHERS
		FAB$M_DEL!FAB$M_UPI,FAB$B_SHR(R6);
	SETBIT	FAB$V_PPF,FAB$L_FOP(R6)		;USE PROCESS I/O SEGMENT 
	$OPEN	FAB=(R6)			;OPEN THE FILE TO GET REQUESTED INFO
	BLBC	R0,85$				;IF ERROR, RETURN NULL STRING
	$CLOSE	FAB=(R6)			;CLOSE THE FILE AGAIN
	MOVZBL	1(R7),R5			;GET OFFSET TO FIELD
	BEQL	60$				;BRANCH IF NONE
	ADDL	SP,R5				;POINT TO FIELD
	MOVZBL	2(R7),R4			;GET LENGTH OF FIELD
	BEQL	60$				;BRANCH IF NONE
	MOVZBL	3(R7),R0			;GET STARTING BIT NUMBER
	EXTZV	R0,R4,(R5),R1			;FETCH CONTENTS OF FIELD
60$:	PUSHAB	B^90$				;RETURN AFTER CASE
	BRB	GET_FILE_ITEM			;GET DATA ITEM

85$:	MOVL	FAB$L_STV(R6),R1		;GET SECONDARY STATUS FROM $OPEN
	BEQL	88$				;BRANCH IF NONE
	MOVL	R1,R0				;REPORT SECONDARY ACP STATUS, NOT RMS
88$:	MOVAB	8(R9),SP			;CLEANUP STACK
	BRW	P1_ERROR			;REPORT ERROR
	
90$:	MOVAB	8(R9),SP			;DEALLOCATE STORAGE ON STACK
	RSB					;

GET_FILE_ITEM:
	CASE	4(R7),TYPE=B,<-		;CASE ON TYPE OF FIELD
		100$,-			;BINARY
		200$,-			;DATE/TIME
		300$,-			;ASCIC STRING
		400$,-			;FILE ID STRING
		500$,-			;FILE ORGANIZATION
		600$,-			;RECORD ATTRIBUTES
		700$,-			;RECORD FORMAT
		800$,-			;OWNER UIC
		900$,-			;PROTECTION
		1000$,-			;EOF - # BLOCKS IN USE
		1100$,-			;BOOLEAN
		1200$>			;KNOWN FILE

;
; RETURN BINARY NUMBER
;
100$:	CLRL	R2			;INDICATE BINARY RESULT
	RSB
;
; RETURN DATE/TIME STRING
;
200$:	$ASCTIM_S (R9),(R9),(R5)	;CONVERT TO ASCII DATE/TIME STRING
	MOVQ	(R9),R1			;GET DESCRIPTOR OF STRING
	RSB
;
; RETURN ASCIC STRING
;
300$:	MOVZBL	(R5)+,R1		;GET LENGTH OF STRING
	CMPL	R1,(R9)			;ENOUGH ROOM FOR STRING?
	BGTRU	310$			;BRANCH IF NOT
	PUSHL	R1			;SAVE LENGTH OF STRING
	MOVC	R1,(R5),@4(R9)		;STORE INTO SCRATCH BUFFER
	POPL	R1			;RESTORE LENGTH OF STRING
	MOVL	4(R9),R2		;GET ADDRESS OF STRING
	RSB
310$:	STATUS	BUFOVF			;SIGNAL BUFFER OVERFLOW
	BRW	P2_ERROR
;
; RETURN FILE ID NUMBER
;
400$:	MOVL	R5,R4			;PASS ADDRESS OF FILE ID
	BRW	FORMAT_FILEID		;FORMAT INTO ASCII STRING
;
; RETURN FILE ORGANIZATION
;
	ASSUME	FAB$C_SEQ EQ 0		; ^X00
	ASSUME	FAB$C_REL EQ 16		; ^X10
	ASSUME	FAB$C_IDX EQ 32		; ^X20
505$:	.ASCII	'SEQ REL IDX'

500$:	ASHL	#-4,R1,R1		;GET UPPER NIBBLE AS INDEX
	MOVAL	505$[R1],R2		;SET ADDRESS OF STRING
	MOVL	#3,R1			;SET LENGTH OF STRING
	RSB
;
; RETURN RECORD ATTRIBUTES (RAT)
;
	ASSUME	FAB$M_FTN EQ 1
	ASSUME	FAB$M_CR EQ 2
	ASSUME	FAB$M_PRN EQ 4
605$:	.ASCIC	'FTN'
	.ASCIC	'CR'
	.BLKB	1			;PAD TO LONGWORD BOUNDARY
	.ASCIC  'PRN'
	.ASCIC	''			;USE NULL IF FFS FAILS

600$:	FFS	#0,#3,(R5),R1		;FIND FIRST BIT SET
	MOVAL	605$[R1],R2		;SET ADDRESS OF STRING
	MOVZBL	(R2)+,R1		;SET LENGTH OF STRING
	RSB
;
; RETURN RECORD FORMAT (RFM)
;
	ASSUME	FAB$C_UDF EQ 0
	ASSUME	FAB$C_FIX EQ 1
	ASSUME	FAB$C_VAR EQ 2
	ASSUME	FAB$C_VFC EQ 3
	ASSUME	FAB$C_STM EQ 4
	ASSUME	FAB$C_STMLF EQ 5
	ASSUME	FAB$C_STMCR EQ 6
705$:	.ASCII	'UDF FIX VAR VFC STM STMLF   STMCR   '
707$:	.BYTE	3,3,3,3,3,5,0,5
700$:	CMPL	#6,R1			;IS RFM ON 4 BYTE OFFSET?
	BNEQ	710$			;YES, SKIP
	MOVL	#7,R1			;NO, SET OFFSET
710$:	MOVAL	705$[R1],R2		;SET ADDRESS OF STRING
	MOVZBL	707$[R1],R1		;SET LENGTH OF STRING
	RSB
;
; RETURN OWNER UIC
;
800$:	MOVL	R1,R4			;PASS UIC LONGWORD
	BRW	FORMAT_UIC		;CONVERT INTO ASCII FORM

;
; RETURN FILE PROTECTION
;
900$:	MOVL	R1,R4			;PASS PROTECTION WORD
	BRW	FORMAT_PROT		;CONVERT INTO ASCII FORM

;
; RETURN # BLOCKS IN USE
;
1000$:	TSTW	XAB$W_FFB-XAB$L_EBK(R5)	;FIRST FREE BYTE = 0?
	BNEQ	1010$			;IF NOT, EBK = BLOCKS IN USE
	DECL	R1			;ELSE DON'T COUNT LAST BLOCK
1010$:	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB
;
; RETURN BOOLEAN TRUE/FALSE
;
1100$:	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

;
; RETURN BOOLEAN TRUE/FALSE
;
1200$:	CLRL	R1			;ASSUME NOT KNOWN
	TSTL	FAB$L_CTX(R6)		;IS IT?
	BEQL	1210$			;NO, THEN SKIP
	INCL	R1			;YES, THEN RETURN TRUE
1210$:	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

	.SBTTL	GETDVI SYSTEM SERVICE
;+
; F$GETDVI - GET DEVICE/VOLUME INFORMATION
;
; THIS LEXICAL FUNCTION INVOKES THE $GETDVI SYSTEM SERVICE TO
; OBTAIN ANY PIECE OF INFORMATION FROM A GIVEN DEVICE.
;
;	F$GETDVI(DEVNAM,ITEM)
;
; INPUTS:
;
;	R2/R3 = DECRIPTOR OF SCRATCH BUFFER
;
;	P1(AP) = DESCRIPTOR OF DEVICE NAME
;		
;	P2(AP) = DESCRIPTOR OF $DVI ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$GETDVI:
	CLRQ	-(SP)			;RESERVE IOSB, WILL BE 8(R5)
	MOVL	R2,-(SP)		;SAVE LENGTH OF SCRATCH BUFFER
	CLRL	-(SP)			;ALLOCATE A LONGWORD FOR DEVCHAR
	MOVL	SP,R5			;MAKE R5 POINT TO IT
	CLRL	-(SP)			;INDICATE BOTTOM OF ITEM LIST	
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE DEVCHAR LENGTH
	PUSHL	R5			;ADDRESS OF BUFFER TO RECEIVE DEVCHAR
	PUSHL	#<DVI$_DEVCHAR+1>@16+4	;SECONDARY DEVICE DEVCHAR ITEM CODE
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE ITEM LENGTH
	MOVQ	R2,-(SP)		;SAVE DESCRIPTOR OF SCRATCH ITEM BUFFER

;
; At this point, the stack looks like below:
;
		;------------------------;
; entry SP=>	;                        ;
		;------------------------;
		;                        ;
		;--- IOSB ---------------;
		;                        ;
		;------------------------;
; scratch len:	;    R2                  ;
		;------------------------;
; R5 =>		;    0 (holds DEVCHAR)   ;
		;------------------------;
; itmlst end:	;    0                   ;
		;------------------------;
		; addr of X (retlen)     ;
		;------------------------;
		;    R5                  ;
		;------------------------;
; X:		; DVI$_DEVCHAR+1 ; len=4 ;
		;------------------------;
		; addr of Y (retlen)     ;
		;------------------------;
		;    R3                  ;
		;------------------------;
; Y:		; DVI$_requested ; R2    ;
		;------------------------;
; SP =>		;                        ;
		;------------------------;

	MOVAB	GETDVI_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVL	R6,R7			;GET ADDRESS OF ENTRY
	ADDL	#4,R6			;GET ADDRESS OF ASCIC ITEM NAME
	MOVZBL	(R6),R8			;GET LENGTH OF ITEM NAME
	BEQL	80$			;BRANCH IF END OF TABLE
	CMPC5	P2(AP),@P2+4(AP),#0,-	;DOES ITEM NAME MATCH?
		R8,1(R6) 		;
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R8,R6			;SKIP TO NEXT ENTRY IN TABLE
	ADDL	#1,R6			;BE SURE TO COUNT THE COUNT
	BRB	10$			;LOOP UNTIL FOUND
20$:	MOVW	(R7),2(SP)		;SET ITEM CODE INTO LIST
30$:	MOVL	SP,R0			;GET ADDRESS OF ITEM LIST
	$GETDVIW_S DEVNAM=P1(AP),-	;GET INFORMATION ON SPECIFIED DEVICE
		ITMLST=(R0),-		;
		IOSB=8(R5),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVZWL	8(R5),R0		;GET STATUS FROM IOSB
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVL	R0,R4			;SAVE STATUS
	BBC	#DEV$V_SPL,(R5),50$	;SPOOLED DEVICE?
	CLRL	R6			;SET SPOOLED FLAG
	MOVW	#DVI$_DEVCHAR,14(SP)	;GET DEVCHAR OF PRIMARY DEVICE
	CMPW	#DVI$_DEVNAM,2(SP)	;ARE WE GETTING DEVICE NAME?
	BNEQ	40$			;NO, THEN NO SPECIAL PROCESSING
	CMPB	#9,4(R7)		;ARE WE GETTING SPOOLED DEVICE NAME?
	BNEQ	40$			;NO, THEN NO SPECIAL PROCESSING
	BRB	30$			;YES, THEN DON'T INCR ITEM CODE
40$:	MOVW	4(R5),(SP)		;RESET RESULT LENGTH
	INCW	2(SP)			;GET SECONDARY DEVICE DATA
	BRB	30$			;RETRY
50$:	CLRW	2(SP)			;CLEAR ITEM CODE, LEAVING RETLEN
	MOVQ	(SP)+,R1		;GET DESCRIPTOR OF STRING/LONGWORD
	ADDL3	#16,R5,SP		;RESTORE STACK
	BRB	GETDVI_VALUE		;GET VALUE
;
; NO SUCH ITEM NAME
;
80$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	ADDL3	#16,R5,SP		;CLEAN STACK
	BRW	P2_ERROR		;REPORT THE ERROR
;
; ERROR DETECTED BY GETDVI
;
90$:	ADDL3	#16,R5,SP		;CLEAN STACK
	CMPL	#SS$_IVDEVNAM,R0	;YES, IS NAME INVALID?
	BEQL	93$			;YES, THEN CHECK EXISTS BIT
	CMPL	#SS$_NOSUCHDEV,R0	;NO, THEN DOES DEVICE EXIST?
	BNEQ	95$			;NO, THEN DON'T CHECK BIT
93$:	CMPB	#DEV$V_EXISTS,3(R7)	;DO WE CARE IF IT EXISTS
	BNEQ	95$			;NO, THEN REPORT ERROR
	CLRL	R1			;YES, THEN RETURN FALSE
	BRW	FORMAT_BOOLEAN		;RETURN THE VALUE
95$:	BRW	P1_ERROR		;REPORT THE ERROR
;
; NORMAL PROCESSING FOR LONGWORDS, STRINGS AND HEX VALUES
;
GETDVI_VALUE:
	CASE	2(R7),TYPE=B,<-		;CASE ON TYPE OF FIELD
		100$,-			;BINARY
		200$,-			;ASCIC STRING
		300$,-			;OWNER UIC
		400$,-			;BOOLEAN
		500$,-			;HEX STRING
		600$,-			;PROTECTION MASK
		700$,-			;ACP TYPE
		800$>			;HEX STRING

;
; RETURN BINARY VALUE
;
100$:	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB

;
; RETURN ASCII STRING
;
200$:	CMPW	#DVI$_DEVNAM,2(R7)	;ARE WE GETTING DEVICE NAME?
	BNEQ	210$			;NO, THEN NO SPECIAL PROCESSING
	CMPB	#9,4(R7)		;ARE WE GETTING SPOOLED DEVICE NAME?
	BNEQ	210$			;NO, THEN NO SPECIAL PROCESSING
	TSTL	R6			;IS DEVICE SPOOLED?
	BEQL	210$			;YES, THEN USE FETCHED NAME
	CLRL	R1			;NO, THEN RETURN NULL STRING
210$:	RSB

;
; RETURN OWNER UIC
;
300$:	MOVL	(R2),R4			;PASS UIC LONGWORD
	BRW	FORMAT_UIC		;CONVERT INTO ASCII FORM

;
; RETURN BOOLEAN TRUE/FALSE
;
400$:	MOVZBL	(R2),R1			; FETCH THE RETURNED VALUE
	CMPB	#DEV$V_EXISTS,3(R7)	; ARE WE CHECKING FOR DEVICE EXISTS?
	BNEQ	410$			; NEQ MEANS WE AREN'T
	MOVL	#1,R1			; IT ALWAYS EXISTS (AT THIS POINT)
410$:	BRW	FORMAT_BOOLEAN		; RETURN "TRUE" OR "FALSE"


;
; RETURN HEX STRING
;
500$:	MOVL	(R2),R0			;PASS HEX LONGWORD AS ARGUMENT
	BEQL	210$			;IF ZERO, RETURN NULL STRING
	JMP	DCL$CBTA_HEX		;CONVERT HEX TO STRING AND EXIT

;
; RETURN PROTECTION STRING
;
600$:	MOVL	(R2),R4			;PASS PROTECTION MASK 
	BRW	FORMAT_PROT		;CONVERT INTO ASCII FORM

;
; RETURN ACP TYPE
;
700$:	MOVL	(R2),R0			;GET ACP TYPE NUMBER
	MOVAQ	ACP_TABLE[R0],R2	;GET ADDRESS OF ASCIC ACP TYPE
	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF ACP TYPE
	RSB

;
; RETURN HEX STRING
;
800$:	TSTL	R1			;IS LENGTH ZERO?
	BEQL	810$			;YES, RETURN NULL STRING
	JMP	DCL$CBTA_HEXSTR		;CONVERT HEX TO STRING AND EXIT
810$:	RSB				;

	.SBTTL	GETJPI SYSTEM SERVICE
;+
; F$GETJPI - GET JOB/PROCESS INFORMATION
;
; THIS LEXICAL FUNCTION INVOKES THE $GETJPI SYSTEM SERVICE TO
; OBTAIN ANY PIECE OF INFORMATION FROM A GIVEN PROCESS.
;
;	F$GETJPI(PID,ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF PID STRING OF DESIRED PROCESS,
;			NULL OR 0 FOR CURRENT PROCESS
;	P2(AP) = DESCRIPTOR OF $JPI ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$GETJPI:
	BSBW	DCL$MARK		;MARK POSITION IN EXPANSION BUFFER
	CLRQ	-(SP)			;RESERVE IOSB
	CLRQ	-(SP)			;CLEAR LENGTH AND ITEM ID OF LAST ITEM
					;AND ALLOCATE SPACE FOR PID LONGWORD
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE LENGTH
	MOVQ	R2,-(SP)		;SAVE DESCRIPTOR OF SCRATCH BUFFER
	MOVAB	GETJPI_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVL	(R6)+,R7		;GET JPI CODE(0:15),FLAGS(16:23),
					;   ITEM STRING LENGTH(24:31)
	BNEQ	15$			;SKIP IF NOT AT END OF TABLE
	BRW	80$			;ERROR IF END OF TABLE
15$:	MOVZBL	-1(R6),R8		;GET LENGTH OF ITEM NAME
	CMPC5	P2(AP),@P2+4(AP),#0,-	;DOES ITEM NAME MATCH?
		R8,(R6) 		;
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R8,R6			;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$			;LOOP UNTIL FOUND
20$:	MOVW	R7,2(SP)		;SET ITEM CODE INTO LIST
	MOVQ	P1(AP),R2		;GET DESCRIPTOR OF PID STRING
	MOVZBL	#PRC_K_HEX,R1		;SET RADIX FOR CONVERSION
	BSBW	DCL$CNVASCBIN		;CONVERT HEX STRING TO BINARY IN R1
	BNEQ	70$			;BRANCH IF CONVERSION ERROR
	MOVL	R1,16(SP)		;STORE PID LONGWORD
	MOVL	SP,R0			;GET ADDRESS OF ITEM LIST
	$GETJPIW_S PIDADR=16(R0),-	;GET INFORMATION ON SPECIFIED PROCESS
		ITMLST=(R0),-		;
		IOSB=20(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVZWL	20(SP),R0		;GET STATUS FROM IOSB
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	CLRW	2(SP)			;CLEAR ITEM CODE, LEAVING RETLEN
	POPR	#^M<R1,R2>		;GET DESCRIPTOR OF STRING/LONGWORD
	ADDL	#5*4,SP			;AND CLEAN STACK
	CMPW	R7,#JPI$_MODE		;ASKING FOR MODE?
	BNEQ	30$			;IF NOT, THEN SKIP
	BRW	STS_MODE		;IF SO, CHECK IF USER WANTED "MODE"
30$:	CMPW	R7,#JPI$_LOGINTIM	;ASKING FOR LOGIN TIME?
	BNEQ	40$			;IF NOT, THEN SKIP
	BRW	GETJPI_LOGINTIM		;IF SO, FORMAT AS DATE/TIME
40$:	CMPW	R7,#JPI$_STATE		;ASKING FOR STATE?
	BNEQ	50$			;IF NOT, THEN SKIP
	BRW	GETJPI_STATE		;IF SO, RETURN STATE KEYWORD
50$:	CMPW	R7,#JPI$_UIC		;ASKING FOR UIC?
	BNEQ	60$			;IF NOT, THEN SKIP
	BRW	GETJPI_UIC		;IF SO, FORMAT UIC SPECIALLY
60$:	EXTZV	#16,#8,R7,R7		;EXTRACT ITEM TYPE FIELD
	BRW	GETJPI_VALUE		;GET VALUE
;
; ERROR CONVERTING PID STRING TO A BINARY LONGWORD
;
70$:	STATUS	EXPSYN			;EXPRESSION SYNTAX ERROR
	ADDL	#7*4,SP			;CLEAN STACK
75$:	BRW	P1_ERROR		;REPORT ERROR
;
; NO SUCH ITEM NAME
;
80$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
;
; ERROR DETECTED BY GETJPI
;
90$:	ADDL	#7*4,SP			;CLEAN STACK
	CMPW	R0,#SS$_SUSPENDED	;SUSPENDED ERROR?
	BEQL	95$			;RETURN NULL/ZERO IF SUSPENDED
	CMPW	R0,#SS$_NONEXPR		;NONEXISTANT PROCESS?
	BEQL	75$			;REPORT P1 ERROR
	BRW	P2_ERROR		;REPORT ERROR
95$:	CLRL	R1			;RETURN NULL STRING
	RSB
;
; NORMAL PROCESSING FOR LONGWORDS, STRINGS AND HEX VALUES
;
GETJPI_VALUE:
	CASE	R7,TYPE=B,<-		;CASE ON ITEM TYPE
		10$,-			;BINARY
		20$,-			;STRING
		30$,-			;HEX LONGWORD STRING
		40$,-			;PRIVILEGE LIST
		60$,-			;BITVAL
		70$>			;HEX STRING
;
; RETURN BINARY VALUE
;
10$:	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
20$:	RSB

;
; RETURN HEX STRING
;
30$:	CLRL	R1			;ASSUME RETURNING NULL STRING
	MOVL	(R2),R0			;PASS LONGWORD PID AS ARGUMENT
	BEQL	20$			;IF ZERO, RETURN NULL STRING
	JMP	DCL$CBTA_HEX		;CONVERT PID TO STRING AND EXIT

;
; RETURN PRIVILEGE LIST
;
40$:	MOVQ	(R2),-(SP)		;PUSH PRIVILEGE MASK ON STACK
	MOVL	SP,R6			;GET ADDRESS OF MASK
	CLRL	R1			;START WITH PRIV #0
45$:	BBC	R1,(R6),50$		;SKIP IF PRIV IS NOT PRESENT
	BSBW	ADD_PRIV_STATE		;APPEND EACH KEYWORD TO STRING
50$:	AOBLSS	#64,R1,45$		;LOOP FOR EACH PRIV IN MASK
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF STRING
	MOVL	WRK_L_MARKPTR(R10),-	;RESTORE POSITION IN EXPANSION BUFFER
		WRK_L_EXPANDPTR(R10)
	TSTL	R1			;WERE NO PRIVS FOUND?
	BEQL	55$			;YES, THEN NO TRAILING COMMA
	DECL	R1			;REMOVE TRAILING COMMA
55$:	ADDL	#8,SP			;RESTORE STACK
	RSB

;
; RETURN BOOLEAN
;
60$:	MOVZBL	(R2),R1			;FETCH THE VALUE
	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

;
; RETURN HEX STRING
;
70$:	TSTL	R1			;IS LENGTH ZERO?
	BEQL	75$			;YES, RETURN NULL STRING
	JMP	DCL$CBTA_HEXSTR		;CONVERT HEX TO STRING AND EXIT
75$:	RSB				;

;
; SPECIAL PROCESSING FOR "LOGINTIM"
;
GETJPI_LOGINTIM:
	PUSHL	R2			;ADDRESS OF RESULT BUFFER
	PUSHL	#23			;RESULT BUFFER LENGTH
	MOVL	SP,R0
	$ASCTIM_S TIMBUF=(R0),-		;CONVERT QUADWORD TIME TO ASCII
		TIMADR=(R2)
	MOVQ	(SP)+,R1		;PICK UP RESULTANT STRING DESCRIPTOR
	RSB

;
; SPECIAL PROCESSING FOR "STATE"
;
GETJPI_STATE:
	MOVL	(R2),R0			;GET STATE NUMBER
	MOVAQ	STATE_TABLE[R0],R2	;GET ADDRESS OF ASCIC STATE NAME
	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF STATE NAME
	RSB

;
; SPECIAL PROCESSING FOR "UIC"
;
GETJPI_UIC:
	MOVL	(R2),R4			;GET UIC LONGWORD
	BSBW	FORMAT_UIC		;FORMAT UIC INTO ASCII STRING
	RSB

;
; WE JUST GOT JPI$_STS - CHECK IF USER WANTS "MODE"
;
STS_MODE:
	MOVL	(R2),R4			;GET MODE LONGWORD
	CLRL	R3			;SET LOOP INDEX
	MOVAB	MODE_TABLE,R2		;GET ADDRESS OF MODE TABLE
25$:	MOVZBL	(R2)+,R1		;GET LENGTH OF MODE
	BEQL	40$			;BRANCH IF END OF TABLE
	CMPL	R4,R3			;IS THIS THE ONE WE WANT?
	BEQL	40$			;YES, THEN RETURN THE STRING
	MOVAB	1(R1)[R2],R2		;SKIP TO NEXT TABLE ENTRY
	INCL	R3			;INCR LOOP INDEX
	BRB	25$			;
40$:	RSB				;

	.SBTTL	GETSYI SYSTEM SERVICE
;+
; F$GETSYI - GET SYSTEM INFORMATION
;
; THIS LEXICAL FUNCTION INVOKES THE $GETSYI SYSTEM SERVICE TO
; OBTAIN ANY PIECE OF INFORMATION FOR THE CURRENT SYSTEM.
;
;	F$GETSYI(ITEM,NODE)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF $SYI ITEM NAME
;	P2(AP) = DESCRIPTOR OF NODE NAME OF DESIRED SYSTEM,
;			NULL OR 0 FOR CURRENT SYSTEM
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$GETSYI:
	CLRQ	-(SP)			;RESERVE IOSB
	CLRQ	-(SP)			;RESERVE CSID AND CLEAR LENGTH AND ITEM ID OF LAST ITEM
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE LENGTH
	MOVQ	R2,-(SP)		;SAVE DESCRIPTOR OF SCRATCH BUFFER
	MOVAB	GETSYI_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVL	(R6)+,R7		;GET SYI CODE(0:15),TYPE(16:23),
					;   ITEM STRING LENGTH(24:31)
	BNEQ	15$			;BRANCH IF NOT END OF TABLE
	BRW	80$			;BRANCH IF END OF TABLE
15$:	MOVZBL	-1(R6),R8		;GET LENGTH OF ITEM NAME
	CMPC5	P1(AP),@P1+4(AP),#0,-	;DOES ITEM NAME MATCH?
		R8,(R6)			;
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R8,R6			;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$			;LOOP UNTIL FOUND
20$:	MOVW	R7,2(SP)		;SET ITEM CODE INTO LIST
	TSTL	P2(AP)			;P2 SPECIFIED?
	BLSS	25$			;BRANCH IF NOT
	MOVAQ	P2(AP),16(SP)		;GET ADDRESS OF NODE DESCRIPTOR
25$:	MOVL	SP,R0			;GET ADDRESS OF ITEM LIST
	$GETSYIW_S ITMLST=(R0),-	;GET INFORMATION
		NODENAME=@16(R0),-	;
		IOSB=20(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVZWL	20(SP),R0		;GET STATUS FROM IOSB
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	CLRW	2(SP)			;CLEAR ITEM CODE, LEAVING RETLEN
	POPR	#^M<R1,R2>		;GET DESCRIPTOR OF STRING/LONGWORD
	ADDL	#5*4,SP			;AND CLEAN STACK

	EXTZV	#16,#8,R7,R7		;GET ITEM TYPE

	CASE	R7,TYPE=B,<-		;CASE ON ITEM TYPE
		91$,-			;BINARY
		40$,-			;STRING
		30$,-			;HEX LONGWORD STRING
		91$,-			;PRIVILEGE LIST
		96$,-			;BITVAL
		30$,-			;HEX STRING
		100$>			;STDTIM

96$:	MOVZBL	(R2),R1			;FETCH THE VALUE
	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"
91$:	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
	BRB	40$			;
30$:	TSTL	R1			;IS LENGTH ZERO?
	BEQL	40$			;YES, RETURN NULL STRING
	JMP	DCL$CBTA_HEXSTR		;CONVERT HEX TO STRING AND EXIT
40$:	RSB				;RETURN

100$:	SUBL3	WRK_L_EXPANDPTR(R10),-	;CALCULATE SIZE OF BUFFER
		WRK_L_CHARPTR(R10),R0	;
	CMPL	R0,#23			;IS BUFFER LARGE ENOUGH?
	BLSSU	110$			;NO, THEN ERROR
	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF SCRATCH BUFFER
	PUSHL	R0			;
	MOVL	SP,R0			;GET ADDRESS OF BUFFER DESCRIPTOR
	$ASCTIM_S  TIMLEN=(R0),-	;CONVERT QUADWORD TIME TO ASCII
		TIMBUF=(R0),-		;
		TIMADR=(R2)		;
	MOVQ	(SP)+,R1		;
	RSB				;

110$:	BRW	BUFOVF			;SIGNAL BUFFER OVERFLOW ERROR

;
; NO SUCH ITEM NAME
;
80$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME

;
; ERROR DETECTED BY GETSYI
;
90$:	ADDL	#7*4,SP			;CLEAN STACK
	CMPL	#SS$_NOSUCHNODE,R0	;CHECK FOR NON-EXISTENT NODE
	BNEQ	92$			;NEQ MEANS IT WASN'T THAT ERROR
	CMPW	#SYI$_CLUSTER_MEMBER,R7	;ARE WE CHECKING FOR EXISTENCE?
	BNEQ	93$			;NEQ MEANS WE ARE NOT
	CLRL	R1			;SET 'FALSE'
	BRW	FORMAT_BOOLEAN		;RETURN "FALSE" TO THE USER
92$:	BRW	P1_ERROR		;REPORT ERROR
93$:	BRW	P2_ERROR		;REPORT ERROR

	.SBTTL	CONVERT IDENTIFIER
;+
; F$IDENTIFIER - CONVERT IDENTIFIER
;
; THIS FUNCTION CONVERTS IDENTIFIERS BETWEEN STRINGS AND NUMBERS.
;
;	F$IDENTIFIER (IDENTIFIER, DIRECTION)
;
; INPUTS:
;
;	P1(AP) = IDENTIFIER NAME OR NUMBER
;	P2(AP) = "NUMBER" OR "NAME"
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT IDENTIFIER
;-

F$IDENTIFIER:
	MOVAB	IDENT_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVZBL	(R6)+,R7		;GET LENGTH OF ITEM NAME
	BEQL	95$			;ERROR IF ZERO
	CMPC5	P2(AP),@P2+4(AP),#0,-	;DOES ITEM NAME MATCH?
		R7,(R6)			;
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R7,R6			;SKIP TO NEXT ENTRY IN TABLE
	INCL	R6			;
	BRB	10$			;LOOP UNTIL FOUND
20$:	TSTB	(R6)[R7]		;"NAME_TO_NUMBER"?
	BEQL	50$			;YES, THEN BRANCH

	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF SCRATCH BUFFER
	SUBL3	WRK_L_EXPANDPTR(R10),-	;
		WRK_L_CHARPTR(R10),-(SP);
	MOVL	SP,R0			;
	$IDTOASC_S  ID=P1(AP),-		;CONVERT NUMBER TO NAME
		NAMLEN=(R0),-		;
		NAMBUF=(R0)		;
	MOVQ	(SP)+,R1		;GET RESULT DESCRIPTOR
	BLBC	R0,90$			;BRANCH IF ERROR
	RSB				;RETURN

50$:	CLRL	-(SP)			;ALLOCATE A RETURN BUFFER
	MOVL	SP,R0			;
	$ASCTOID_S  NAME=P1(AP),-	;CONVERT NAME TO NUMBER
		ID=(R0)			;
	MOVL	(SP)+,R1		;GET RESULT
	CLRL	R2			;
	BLBC	R0,90$			;BRANCH IF ERROR
	RSB				;RETURN


90$:	CLRL	R1			;RETURN THE NULL STRING
	RSB				;
95$:	STATUS	IVKEYW			;REPORT KEYWORD ERROR
	BRW	P2_ERROR		;

	.SBTTL	CONVERT TO INTEGER
;+
; F$INTEGER - CONVERT TO INTEGER
;
; THIS FUNCTION CONVERTS ANY VALUE TO AN INTEGER
;
;	F$INTEGER(EXPRESSION)
;
; INPUTS:
;
;	P1(AP) = EXPRESSION RESULT
;
; OUTPUTS:
;
;	R1 = INTEGER
;	R2 = 0 (TO INDICATE RESULT IS BINARY RATHER THAN ASCII)
;-

F$INTEGER:
	MOVQ	P1(AP),R1		;GET EXPRESSION VALUE
	JSB	DCL$CVT_BINARY		;CONVERT STRING TO BINARY
	BLBC	R0,90$			;BRANCH IF ERROR
	RSB
90$:	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	RETURN LENGTH OF STRING
;+
; F$LENGTH - RETURN LENGTH OF STRING
;
; THIS LEXICAL FUNCTION RETURNS THE LENGTH OF ITS ARGUMENT AS A DECIMAL STRING.
;
;	F$LENGTH(STRING)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF STRING.
;
; OUTPUTS:
;
;	R1 = STRING LENGTH
;	R2 = 0 TO INDICATE RESULT IS BINARY
;-
 
F$LENGTH:				;RETURN LENGTH OF STRING
	MOVL	P1(AP),R1		;GET VALUE TO BE CONVERTED
	CLRL	R2			;INDICATE BINARY RESULT
	RSB

	.SBTTL	LOCATE SUBSTRING IN STRING
;+
; F$LOCATE - LOCATE SUBSTRING IN STRING
;
; THIS LEXICAL FUNCTION RETURNS THE STARTING POSITION OF A SUBSTRING IN ANOTHER
; STRING. IF THE SUBSTRING IS NOT CONTAINED IN THE SPECIFIED STRING, THEN THE
; LENGTH OF THE SPECIFIED STRING IS RETURNED.
;
;	F$LOCATE(SUBSTRING, STRING)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF SUBSTRING.
;	P2(AP) = DESCRIPTOR OF STRING TO BE SEARCHED.
;
; OUTPUTS:
;
;	R1 = NUMBER INDICATING POSITION WITHIN STRING
;	R2 = 0 TO INDICATE RESULT IS BINARY
;-
 
F$LOCATE:				;LOCATE SUBSTRING IN STRING
	MATCHC	P1(AP),@P1+4(AP),P2(AP),@P2+4(AP) ;SEARCH FOR SUBSTRING MATCH
	BNEQ	10$			;IF NEQ NO MATCH FOUND
	SUBL	P1(AP),R3		;CALCULATE STARTING ADDRESS OF SUBSTRING
10$:	SUBL3	P2+4(AP),R3,R1		;CALCULATE STARTING POSITION OF SUBSTRING
	CLRL	R2			;MARK RESULT IS BINARY
	RSB

	.SBTTL	LOGICAL NAME TRANSLATION
;+
; F$LOGICAL - LOGICAL NAME TRANSLATION
;
; THIS LEXICAL FUNCTION OBTAINS THE TRANSLATION FOR A SPECIFED LOGICAL NAME AND
; RETURN THE EQUIVALENCE NAME.
;
;	F$LOGICAL(LOGICAL_NAME)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF LOGICAL NAME STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EQUIVALENCE STRING.
;	R2 = ADDRESS OF EQUIVALENCE STRING.
;-
 
F$LOGICAL:				;LOGICAL NAME TRANSLATION
	MOVAB	P1(AP),R0		;GET ADDRESS OF LOGICAL NAME DESCRIPTOR
	MOVQ	R2,-(SP)		;SAVE EQUIVALENCE NAME DESCRIPTOR
	MOVQ	R2,-(SP)		;SET EQUIVALENCE NAME DESCRIPTOR
	MOVL	SP,R1			;SET ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S (R0),(R1),(R1)	;TRANSLATE LOGICAL NAME
	MOVQ	(SP)+,R1		;RETRIEVE EQUIVALENCE NAME PARAMETERS
	BLBC	R0,90$			;IF LBC TRANSLATION FAILURE
	CMPW	#SS$_NOTRAN,R0		;DID TRANSLATION ACTUALLY OCCUR?
	BEQL	10$			;IF EQL, THEN NO
	ADDL	#8,SP			;RESTORE STACK
	BRB	20$			;EXAMINE RESULT
;
; TRY AGAIN WITH UPCASED LOGICAL NAME STRING.
;
10$:	MOVQ	P1(AP),R1		;CREATE LOGICAL NAME DESCRIPTOR
	BSBW	DCL$UPCASE		;UPCASE THE LOGICAL NAME STRING
	MOVQ	R1,-(SP)		;PUT THE LOGICAL NAME DESC ON THE STACK
	MOVL	SP,R0			;SET ADDRESS OFF LOGICAL NAME DESCRIPTOR
	MOVAB	8(SP),R1		;SET ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S (R0),(R1),(R1)	;TRANSLATE LOGICAL NAME
	ADDL	#8,SP			;REMOVE THE LOGICAL NAME DESCRIPTOR
	MOVQ	(SP)+,R1		;RETRIEVE EQUIVALENCE NAME PARAMETERS
	BLBC	R0,90$			;IF LBC TRANSLATION FAILURE
	CMPW	#SS$_NOTRAN,R0		;DID TRANSLATION ACTUALLY OCCUR?
	BEQL	30$			;IF EQL, THEN NO
;
; STRIP ESCAPE SEQUENCE OFF EQUIVALENCE NAME STRING.
;
20$:	TSTL	R1			;ZERO LENGTH VALUE?
	BEQL	40$			;IF EQL YES
	CMPB	#27,(R2)		;FIRST CHARACTER ESCAPE?
	BNEQ	40$			;IF NEQ NO
	ADDL	#4,R2			;POINT PAST ESCAPE SEQUENCE
	SUBL	#4,R1			;REDUCE LENGTH OF EQUIVALENCE STRING
	BGEQ	40$			;IF GEQ OKAY
30$:	CLRL	R1			;SET TO RETURN NULL STRING
40$:	RSB				;
 
;
; LOGICAL NAME TRANSLATION FAILURE
;
 
90$:	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	LOGICAL NAME TRANSLATION
;+
; F$TRNLNM - LOGICAL NAME TRANSLATION
;
; THIS LEXICAL FUNCTION OBTAINS THE TRANSLATION FOR A SPECIFIED LOGICAL NAME AND
; RETURN THE EQUIVALENCE NAME OR THE REQUESTED ATTRIBUTE.
;
;	F$TRNLNM (NAME, TABLE, INDEX, MODE, ATTR, ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF LOGICAL NAME STRING.
;	P2(AP) = DESCRIPTOR OF NAME OF LOGICAL NAME TABLE TO SEARCH.
;	P3(AP) = INDEX OF THE DESIRED TRANSLATION.
;	P4(AP) = DESCRIPTOR OF ACCESS MODE OF TRANSLATION.
;	P5(AP) = DESCRIPTOR OF TYPE OF TRANSLATION.
;	P6(AP) = DESCRIPTOR OF REQUESTED ITEM.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EQUIVALENCE STRING.
;	R2 = ADDRESS OF EQUIVALENCE STRING.
;-
 
F$TRNLNM:					;LOGICAL NAME TRANSLATION

;++
; Item list created on stack:
;
;		;------------------------;
;	48(R9)	; Translation attributes ;
;		;------------------------;
;	44(R9)	;  Attribute bit number  ;
;		;------------------------;
;	40(R9)	;      Access mode	 ;
;		;------------------------;
;		;  Table name descriptor ;
;		;			 ;
;	32(R9)	;			 ;
;		;------------------------;
;	28(R9)	;   Translation index	 ;
;		;------------------------;
; 	24(R9)	;    End of item list    ;
;		;------------------------;
;	20(R9)	;        12(R9)          ;
;		;------------------------;
;	16(R9)	;  Scratch buffer descr  ;
;		;------------		 ;
; 	12(R9)	;lnm$_string!		 ;
;		;------------------------;
;	 8(R9)	;           0            ;
;		;------------------------;
;	 4(R9)	;        28(R9)          ;
;		;------------------------;
; 	  (R9)	; lnm$_index!     4      ;
;		;------------------------;
;--

;
; Allocate and initialize the item list.
;
	SUBL	#52,SP				;ALLOCATE ITEM LIST ON STACK
	MOVL	SP,R9				;SAVE THE ADDR OF THE LIST
	CMPL	R2,#8				;CHECK MIN SIZE OF RESULT BUFFER
	BLSSU	17$				;BRANCH IF TOO SMALL
	MOVL	#LNM$_INDEX@16+4,(R9)		;INIT THE ITEM LIST
	MOVAL	28(R9),4(R9)			;
	CLRL	8(R9)				;
	MOVQ	R2,12(R9)			;
	MOVW	#LNM$_STRING,14(R9)		;
	MOVAL	12(R9),20(R9)			;
	CLRQ	24(R9)				;
	MOVAB	TABDEF,R1			;
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,32(R9)			;
	MOVL	#PSL$C_USER,40(R9)		;
	CLRL	44(R9)				;
	MOVL	#LNM$M_CASE_BLIND,48(R9)	;

;
; Set the translation index.
;
	TSTL	P3(AP)				;WAS INDEX SPECIFIED?
	BLSS	10$				;NO, THEN USE DEFAULT
	MOVL	P3(AP),28(R9)			;SAVE SPECIFIED INDEX

;
; Set the item code.
;
10$:	TSTL	P6(AP)				;WAS AN ITEM SPECIFIED?
	BLSS	20$				;NO, THEN USE DEFAULT
	MOVAB	LOGICAL_TABLE,R4		;GET ADDRESS OF ITEM TABLE
15$:	MOVZBL	(R4),R5				;GET LENGTH OF ITEM NAME
	BEQL	16$				;BRANCH IF END OF TABLE
	CMPC5	P6(AP),@P6+4(AP),#0,R5,1(R4)	;DOES ITEM NAME MATCH
	BEQL	18$				;BRANCH IF ITEM FOUND
	MOVAB	4(R4)[R5],R4			;SKIP TO NEXT TABLE ENTRY
	BRB	15$				;
14$:	BRW	94$				;
16$:	BRW	96$				;
17$:	BRW	97$				;
18$:	MOVAB	1(R4)[R5],R0			;GET THE ADDR OF THE ITEM CODE
	MOVW	(R0),14(R9)			;SET THE ITEM CODE
	MOVZBL	3(R4)[R5],44(R9)		;SAVE THE ATTR LONGWORD BIT NUM

;
; Set the access mode.
;
20$:	TSTL	P4(AP)				;WAS AN ACCESS MODE SPECIFIED?
	BLSS	30$				;NO, THEN USE DEFAULT
	MOVAB	ACCESS_TABLE,R4			;GET ADDRESS OF ACCESS TABLE
25$:	MOVZBL	(R4),R5				;GET LENGTH OF ACCESS MODE
	BEQL	14$				;BRANCH IF END OF TABLE
	CMPC5	P4(AP),@P4+4(AP),#0,R5,1(R4)	;DOES ACCESS MODE MATCH
	BEQL	27$				;BRANCH IF ACCESS MODE FOUND
	MOVAB	2(R4)[R5],R4			;SKIP TO NEXT TABLE ENTRY
	BRB	25$				;
27$:	MOVZBL	1(R4)[R5],40(R9)		;SET THE ACCESS MODE

;
; Set the table name.
;
30$:	TSTL	P2(AP)				;WAS TABLE SPECIFIED?
	BLSS	40$				;NO, THEN USE DEFAULT
	MOVQ	P2(AP),32(R9)			;SET SPECIFIED TABLE NAME

;
; Set the tranlation attribute.
;	
40$:	TSTL	P5(AP)				;WAS AN ATTR SPECIFIED?
	BLSS	48$				;NO, THEN USE DEFAULT
	MOVAB	LOGATTR_TABLE,R4		;GET ADDRESS OF ATTR TABLE
45$:	MOVZBL	(R4),R5				;GET LENGTH OF ATTR NAME
	BEQL	95$				;BRANCH IF END OF TABLE
	CMPC5	P5(AP),@P5+4(AP),#0,R5,1(R4)	;DOES ATTR NAME MATCH
	BEQL	47$				;BRANCH IF ATTR FOUND
	MOVAB	5(R4)[R5],R4			;SKIP TO NEXT TABLE ENTRY
	BRB	45$				;
47$:	MOVAB	1(R4)[R5],R0			;GET ADDR OF ATTIBUTE CODE
	MOVL	(R0),48(R9)			;SET THE ATTRIBUTE
48$:	BRW	50$				;

;
; Signal all errors.
;
94$:	MOVAB	P4(AP),R2
	BRB	961$
95$:	MOVAB	P5(AP),R2
	BRB	961$
96$:	MOVAB	P6(AP),R2
961$:	STATUS	IVKEYW	
	MOVAB	52(R9),SP
	BRW	PN_ERROR

97$:	MOVAB	52(R9),SP
	BRW	BUFOVF	

90$:	CMPW	#SS$_BUFFEROVF,R0
	BEQL	97$		
	MOVAB	52(R9),SP	
	BRW	ERROR		

51$:	BRW	80$		

;
; Perform the translation.
;
50$:	$TRNLNM_S  ATTR=48(R9),-		;TRANSLATE THE LOGICAL NAME
		TABNAM=32(R9),-			;
		LOGNAM=P1(AP),-			;
		ACMODE=40(R9),-			;
		ITMLST=(R9)			;
	CMPW	#SS$_NOLOGNAM,R0		;DID TRANSLATION ACTUALLY OCCUR?
	BEQL	80$				;IF NEQ, THEN RETURN NULL STRING
	BLBC	R0,90$				;IF LBC, THEN ERROR

;
; Return requested information
;
60$:	CMPW	14(R9),#LNM$_STRING		;WAS TRANSLATION REQUESTED?
	BEQL	70$				;YES, THEN GO RETURN IT
	CMPW	14(R9),#LNM$_TABLE		;WAS TABLE NAME REQUESTED?
	BEQL	70$				;YES, THEN GO RETURN IT
	CMPW	14(R9),#LNM$_MAX_INDEX		;WAS INDEX REQUESTED?
	BEQL	69$				;YES, THEN GO RETURN IT
	CMPW	14(R9),#LNM$_LENGTH		;WAS LENGTH REQUESTED?
	BEQL	69$				;YES, THEN GO RETURN IT
	CMPW	14(R9),#LNM$_ACMODE		;WAS ACCESS MODE REQUESTED?
	BEQL	66$				;YES, THEN GO RETURN IT

;
; Return requested attribute.
;
	CLRL	R1				;ASSUME FALSE
	BBC	44(R9),@16(R9),65$		;BRANCH IF FALSE
	INCL	R1				;SET TRUE
65$:	MOVAB	52(R9),SP			;RESTORE THE STACK
	BRW	FORMAT_BOOLEAN			;RETURN BOOLEAN STRING

;
; Return access mode.
;
66$:	MOVAB	ACCESS_TABLE,R2			;GET ADDRESS OF ACCESS TABLE
	MOVZBL	@16(R9),R0			;GET ACCESS MODE CODE
	BRB	68$				;
67$:	MOVAB	1(R2)[R1],R2			;SKIP TO NEXT TABLE ENTRY
68$:	MOVZBL	(R2)+,R1			;GET LENGTH OF ACCESS MODE
	SOBGEQ	R0,67$				;
	BRB	85$				;RETURN THE SPECIFIED VALUE

;
; Return max index or length.
;
69$:	MOVL	@16(R9),R1			;GET THE INDEX
	CLRL	R2				;
	BRB	85$				;

;
; Strip escape sequence off and return equivalence name string.
;
70$:	CLRW	14(R9)				;REMOVE THE ITEM CODE
	MOVQ	12(R9),R1			;GET RESULT DESCRIPTOR
	TSTL	R1				;ZERO LENGTH VALUE?
	BEQL	85$				;IF EQL YES
	CMPB	#27,(R2)			;FIRST CHARACTER ESCAPE?
	BNEQ	85$				;IF NEQ NO
	ADDL	#4,R2				;POINT PAST ESCAPE SEQUENCE
	SUBL	#4,R1				;REDUCE LENGTH OF EQUIVALENCE STRING
	BGEQ	85$				;IF GEQ OKAY
80$:	CLRL	R1				;SET TO RETURN NULL STRING
	MOVL	SP,R2				;
85$:	MOVAB	52(R9),SP			;RESTORE THE STACK
	RSB					;

	.SBTTL	GET MESSAGE TEXT
;+
; F$MESSAGE - GET MESSAGE TEXT
;
; THIS LEXICAL FUNCTION OBTAINS THE MESSAGE TEXT ASSOCIATED WITH A MESSAGE CODE.
;
;	F$MESSAGE(CODE)
;
; INPUTS:
;
;	P1(AP) = MESSAGE CODE
;
; OUTPUTS:
;
;	R1 = LENGTH OF MESSAGE TEXT STRING.
;	R2 = ADDRESS OF MESSAGE TEXT STRING.
;-
 
F$MESSAGE:				;GET MESSAGE TEXT
	MOVQ	R2,-(SP)		;SET MESSAGE BUFFER DESCRIPTOR
	MOVL	SP,R0			;SET ADDRESS OF MESSAGE BUFFER DESCRIPTOR
	$GETMSG_S P1(AP),(R0),(R0),#15	;GET MESSAGE TEXT
	MOVQ	(SP)+,R1		;RETRIEVE MESSAGE TEXT PARAMETERS
	RSB

	.SBTTL	RETURN JOB MODE
;+
; F$MODE - RETURN JOB MODE
;
; THIS LEXICAL FUNCTION RETURNS A STRING THAT IS EITHER "INTERACTIVE" OR "BATCH"
; DEPENDENT ON THE JOB MODE.
;
;	F$MODE()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF JOB MODE DESCRIPTION STRING.
;	R2 = ADDRESS OF JOB MODE DESCRIPTION STRING.
;-
 
F$MODE:					;RETURN JOB MODE
	CLRQ	-(SP)			;RESERVE IOSB
	CLRQ	-(SP)			;MARK END OF LIST, NO RETLEN
	PUSHAB	-2*4(SP)		;SET BUFFER ADDRESS
	PUSHL	#JPI$_MODE@16+4		;REQUEST MODE, SET BUFFER LENGTH
	MOVL	SP,R0			;SET ADDRESS OF TIME LIST
	$GETJPIW_S ITMLST=(R0),-	;GET MODE LONGWORD
		IOSB=16(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,50$			;IF LBC SERVICE FAILURE
	MOVZWL	16(SP),R0		;GET STATUS FROM IOSB
	BLBC	R0,50$			;IF LBC SERVICE FAILURE

	CLRL	R3			;SET LOOP INDEX
	MOVAB	MODE_TABLE,R2		;GET ADDRESS OF MODE TABLE
25$:	MOVZBL	(R2)+,R1		;GET LENGTH OF MODE
	BEQL	40$			;BRANCH IF END OF TABLE
	CMPL	(SP),R3			;IS THIS THE ONE WE WANT?
	BEQL	40$			;YES, THEN RETURN THE STRING
	MOVAB	1(R1)[R2],R2		;SKIP TO NEXT TABLE ENTRY
	INCL	R3			;INCR LOOP INDEX
	BRB	25$			;

40$:	ADDL	#6*4,SP			;DEALLOCATE GETJPI ITEM LIST AND IOSB
	RSB

50$:	ADDL	#6*4,SP			;CLEAN STACK
	BRW	ERROR			;REPORT ERROR IN FUNCTION

	.SBTTL	PARSE A FILE SPECIFICATION
;+
; F$PARSE - PARSE A FILE SPECIFICATION
;
; THIS FUNCTION PERFORMS A $PARSE SYSTEM SERVICE RETURNING THE
; ENTIRE (OR OPTIONALLY ONLY PARTS OF THE) EXPANDED FILESPEC.
;
; INPUTS:
;
;	P1(AP) = PRIMARY FILESPEC
;	P2(AP) = DEFAULT FILESPEC
;	P3(AP) = RELATED FILESPEC (FOR TEMPORARY STICKYNESS)
;	P4(AP) = NAME OF A FILESPEC FIELD
;		IF NOT SPECIFIED, THE ENTIRE FILESPEC IS RETURNED.
;	P5(AP) = TYPE OF PARSE (ITEM LIST)
;
;	P2,P3,P4, AND P5 ARE ALL OPTIONAL (INDICATED BY A -1 IN THE FIRST LONGWORD)
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF EXPANDED FILE SPECIFICATION
;-

F$PARSE:
	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF SCRATCH BUFFER
	MOVL	SP,R9			;SAVE ADDRESS OF DESCRIPTOR
	MOVAB	-NAM$C_BLN-FAB$C_BLN-NAM$C_MAXRSS-NAM$C_BLN(SP),SP ;ALLOCATE STORAGE
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN+NAM$C_MAXRSS+NAM$C_BLN,(SP) ;ZERO STORAGE
	MOVL	SP,R7			;GET ADDRESS OF NAM
	MOVAB	NAM$C_BLN(R7),R6	;GET ADDRESS OF FAB
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R6) ;INITIALIZE FAB
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R7) ;INITIALIZE NAM
;
;	VALIDATE PARSE TYPE PARAMETER LIST, IF ANY
;
	TSTL	P5(AP)			;PARSE TYPE SPECIFIED?
	BLSS	18$			;IF NOT, SKIP BIT SETTING

	MOVL	R8,-(SP)		;SAVE R8,R10,R11
	MOVQ	R10,-(SP)		;
	MOVQ	P5(AP),R4		;R4/R5 = ITEM LIST DESCRIPTOR
	CLRB	R8			;ASSUME ONLY 1 ITEM IN LIST

5$:	MOVQ	R4,R2			;SETUP FOR TABLE CHECK IN CASE 1 ITEM
	LOCC	#^A/,/,R4,(R5)		;SEARCH ITEM LIST FOR A COMMA
	BEQL	6$			;CHECK TABLE NOW IF ONLY 1 ITEM IN LIST

	INCB	R8			;INDICATE AT LEAST ONE MORE ITEM IN LIST
	SUBL3	R0,R4,R2		;CALCULATE LENGTH OF THIS ITEM
	MOVAB	-(R0),R4		;STRIP CURRENT ITEM FROM LIST
	MOVAB	1(R1),R5		;

6$:	MOVAB	PARSE_TYPES,R10		;R10 = ADDR. OF PARSE TYPES TABLE
7$:	MOVZBL	(R10),R11		;R11 = LENGTH OF THIS PARSE TYPE
	BEQL	10$			;HAVE INVALID KEY WORD IF AT TABLE END

	MOVQ	R2,-(SP)		;SAVE ITEM LENGTH AND ADDR.
	CMPC5	R2,(R3),#0,-		;CHECK CURR. ITEM AGAINST TAB. ENTRY
		R11,1(R10)
	BEQL	12$			;IF MATCH, SET BIT IN NAM$B_NOP FLAG

	MOVQ	(SP)+,R2		;RESTORE ITEM LENG. AND ADDR.
	MOVAB	2(R10)[R11],R10		;R10 = ADDR. OF NEXT TABLE ENTRY
	BRB	7$			;CHECK ITEM AGAINST NEXT TABLE ENTRY

10$:	MOVQ	(SP)+,R10		;RESTORE WORK REGISTERS
	MOVL	(SP)+,R8		;
	STATUS	IVKEYW			;INVALID KEYWORD
	BRW	P5_ERROR		;GOTO ERROR HANDLER

12$:	MOVQ	(SP)+,R2		;HAVE MATCH. FIRST RESTORE ITEM REG.
	BISB	1(R10)[R11],NAM$B_NOP(R7)	;SET CORRESPONDING BIT
	BBSC	#0,R8,5$		;CHECK NEXT ITEM IN LIST(IF ANY LEFT)

	MOVQ	(SP)+,R10		;RESTORE REGISTERS
	MOVL	(SP)+,R8		;
;
;	VALIDATE NAME OF FILESPEC FIELD PARAMETER.
;
18$:	TSTL	P4(AP)			;FIELD SPECIFIED?
	BLSS	19$			;IF NOT, RETURN ENTIRE EXPANDED STRING
	MOVAB	PARSE_FIELDS,R4		;GET ADDRESS OF TABLE
300$:	MOVZBL	(R4),R5			;GET LENGTH OF ITEM NAME
	BEQL	350$			;BRANCH IF END OF TABLE
	CMPC5	P4(AP),@P4+4(AP),#0,-	;DOES ITEM NAME MATCH?
		R5,1(R4) 		;
	BEQL	380$			;BRANCH IF ITEM FOUND
	MOVAB	3(R4)[R5],R4		;SKIP TO NEXT ENTRY IN TABLE
	BRB	300$			;LOOP UNTIL FOUND
350$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	BRW	P4_ERROR
380$:	MOVZBL	(R3)+,R4		;GET OFFSET TO FIELD LENGTH
	MOVZBL	(R3)+,R5		;GET OFFSET TO FIELD ADDRESS
;
;	PARSE FILE SPEC.
;
19$:	MOVL	R7,FAB$L_NAM(R6)	;SET POINTER TO NAM BLOCK
	SETBIT	FAB$V_PPF,FAB$L_FOP(R6)	;USE PROCESS I/O SEGMENT (SINCE THERE
					;   MAY NOT BE ANY IMAGE I/O SEGMENT)
	MOVB	P1(AP),FAB$B_FNS(R6)	;STORE PRIMARY NAME STRING INTO FAB
	MOVL	P1+4(AP),FAB$L_FNA(R6)
	TSTL	P2(AP)			;P2 SPECIFIED?
	BLSS	20$			;BRANCH IF NOT
	MOVB	P2(AP),FAB$B_DNS(R6)	;STORE DEFAULT NAME STRING INTO FAB
	MOVL	P2+4(AP),FAB$L_DNA(R6)
20$:	TSTL	P3(AP)			;P3 SPECIFIED?
	BLSS	25$			;BRANCH IF NOT
	MOVAB	FAB$C_BLN+NAM$C_MAXRSS(R6),R0	;ADDRESS OF RELATED NAM
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R0) ;INITIALIZE RELATED NAM
	MOVB	P3(AP),NAM$B_RSL(R0)	;INITIALIZE RELATED FILESPEC
	MOVL	P3+4(AP),NAM$L_RSA(R0)
	MOVL	R0,NAM$L_RLF(R7)	;POINT TO RELATED NAM BLOCK
25$:	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R7)	;SET SIZE OF EXPANDED BUFFER
	MOVAB	FAB$C_BLN(R6),NAM$L_ESA(R7)	;SET ADDRESS OF RESULT BUFFER
	$PARSE	FAB=(R6)		;SETUP EXPANDED NAME STRING, NAM FIELDS
					;(SUCH AS FID,DID,DVI,ESL)
	BLBS	R0,28$			;BRANCH IF OK
	CLRB	NAM$B_ESL(R7)		;RETURN NULL ON ANY PARSE ERROR
28$:	MOVZBL	#NAM$B_ESL,R1		;ASSUME USING ENTIRE EXPANDED STRING
	MOVZBL	#NAM$L_ESA,R2
	TSTL	P4(AP)			;FIELD SPECIFIED?
	BLSS	40$			;IF NOT, RETURN ENTIRE EXPANDED STRING
	MOVQ	R4,R1			;GET OFFSET TO FIELD LENGTH, ADDRESS
40$:	MOVZBL	(R7)[R1],R1		;GET LENGTH OF EXPANDED STRING
	ADDL	R7,R2			;GET ADDRESS OF EXPANDED STRING ADDRESS
	CMPL	R1,(R9)			;ENOUGH ROOM FOR STRING?
	BGTRU	60$			;BRANCH IF NOT
	PUSHL	R1			;SAVE REGISTERS
	MOVC	R1,@(R2),@4(R9)		;COPY INTO SCRATCH BUFFER
	POPL	R3			;SAVE LENGTH OF EXPANDED STRING
	TSTL	NAM$L_WCC(R7)		;DID RMS SAVE ANY INTERNAL CONTEXT?
	BEQL	50$			;BRANCH IF NOT
	ASSUME	FAB$B_DNS EQ FAB$B_FNS+1
	CLRW	FAB$B_FNS(R6)		;SET PRIMARY/DEFAULT FILESPECS TO NULL
	SETBIT	NAM$V_SYNCHK,NAM$B_NOP(R7)  ;SET SYNTAX ONLY CHECK FLAG
	$PARSE	FAB=(R6)		;TERMINATE WILDCARD SEQUENCE TO GET RMS
					;TO DEALLOCATE INTERNAL CONTEXT STORAGE
50$:	MOVL	R3,R1			;GET LENGTH OF RESULTANT STRING
	MOVL	4(R9),R2		;SET ADDRESS OF STRING
	MOVAB	8(R9),SP		;DEALLOCATE STORAGE
	RSB

60$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW

	.SBTTL	GET NEXT PROCESS ID
;+
; F$PID - GET NEXT PROCESS ID
;
; THIS FUNCTION PERFORMS A WILDCARD GETJPI FUNCTION TO RETURN THE
; NEXT PROCESS PID IN SEQUENCE, GIVEN THE WILDCARD CONTEXT.
;
;	F$PID(CONTEXT_SYMBOL)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF SYMBOL NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF PID CONVERTED TO AN ASCII STRING
;-

F$PID:
	CLRQ	-(SP)			;RESERVE IOSB
	CLRQ	-(SP)			;CLEAR LAST ITEM AND RETLEN ADDRESS
	PUSHAB	-8(SP)			;ADDRESS TO RECEIVE PID
	PUSHL	#JPI$_PID@16+4		;SET ITEM CODE AND BUFLEN
	MNEGL	#1,-(SP)		;ASSUME CONTEXT LONGWORD OF -1 (BEGIN)
	MOVQ	P1(AP),R1		;GET DESCRIPTOR OF SYMBOL NAME
	BSBW	DCL$SEARCH		;FIND SYMBOL IN SYMBOL TABLE
	BLBC	R0,10$			;IF NOT FOUND, SEARCH FROM BEGINNING
	TSTL	R2			;STRING VALUE?
	BNEQ	10$			;IF SO, START SEARCH AT BEGINNING
	TSTL	R1			;TOP BIT MUST BE SET FOR VALID PID CTX
	BGEQ	10$			;IF NOT OK, START SEARCH AT BEGINNING
	MOVL	R1,(SP)			;STORE CONTEXT LONGWORD ON STACK
10$:	MOVL	SP,R0			;GET ADDRESS OF CONTEXT/ITEM LIST
	$GETJPIW_S PIDADR=(R0),-	;GET NEXT PID IN SEQUENCE
		ITMLST=4(R0),-		;
		IOSB=20(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,15$			;BRANCH IF ERROR
	MOVZWL	20(SP),R0		;FETCH STATUS FROM IOSB
	BLBS	R0,20$			;BRANCH IF NO ERROR
15$:	CMPW	R0,#SS$_NOPRIV		;NO PRIVILEGE TO GET INFO?
	BEQL	10$			;IF SO, TRY NEXT PROCESS
	CMPW	R0,#SS$_NOMOREPROC	;NO MORE PROCESSES?
	BNEQ	80$			;IF NOT, REPORT ERROR
	CLRQ	(SP)			;RETURN NULL PID ON THIS INVOCATION
20$:	POPL	R1			;GET NEW CONTEXT LONGWORD
	MOVQ	P1(AP),R3		;SET DESCRIPTOR OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVL	#SYM_K_BINARY,R0	;SET TYPE IS BINARY LONGWORD
	DISABLE				;DISABLE CONTROL/Y AST'S
	BSBW	DCL$ALLOCSYM		;REPLACE VALUE OF SYMBOL
	ENABLE				;RE-ENABLE CONTROL/Y AST'S
	POPL	R0			;GET PID OF NEXT PROCESS
	ADDL	#5*4,SP			;AND CLEAN STACK
	MOVL	SP,R2			;MARK VALUE IS A STRING
	MOVL	R0,R1			;END OF WILDCARD SEARCH?
	BEQL	30$			;IF SO, RETURN WITH A NULL STRING
	JSB	DCL$CBTA_HEX		;CONVERT PID TO STRING AND EXIT
30$:	RSB

80$:	ADDL	#7*4,SP			;CLEAN STACK
	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	CHECK IF SPECIFIED PRIVS ARE SET OR CLEAR
;+
; F$PRIVILEGE - CHECK IF SPECIFIED PRIVILEGES ARE SET OR CLEAR
;
; THIS LEXICAL FUNCTION CAN BE USED TO DETERMINE WHETHER THE CURRENT PROCESS
; HAS A GIVEN SET OF PRIVILEGES ON OR OFF, DEPENDING ON THE KEYWORDS GIVEN.
; THE ARGUMENT IS A COMMA SEPARATED LIST OF PRIVILEGE KEYWORDS ABOUT WHICH
; THE CALLER IS INTERESTED.  IF THE PREFIX "NO" APPEARS ON THE KEYWORD, THEN
; THE FUNCTION CHECKS IF THE PRIVILEGE IS OFF.  OTHERWISE, THE FUNCTION CHECKS
; THAT THE PRIVILEGE IS ON.  THE FINAL VALUE OF THE FUNCTION IS THE "AND" OF
; ALL OF THE PRIVILEGE CHECKS - THAT IS, IT RETURNS TRUE IF ALL THE PRIVILEGES
; ARE SET AS SPECIFIED.
;
;	F$PRIVILEGE(PRVSTATES)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF A COMMA SEPARATED LIST OF PRIVILEGE KEYWORDS.
;
; OUTPUTS:
;
;	R1/R2 = BOOLEAN TRUE OR FALSE STRING
;-

F$PRIVILEGE:
	MOVL	R3,R6			;GET ADDRESS OF SCRATCH QUADWORD
	$SETPRV_S PRVPRV=(R6),-		;GET CURRENT PERMANENT PRIVILEGES
		PRMFLG=#1		;
	MOVQ	P1(AP),R4		;GET DESCRIPTOR OF COMMA SEPARATED LIST
10$:	MOVQ	R4,R2			;ASSUME NO COMMA IN LIST
	LOCC	#^A',',R4,(R5)		;LOCATE END OF NEXT KEYWORD
	BEQL	20$			;BRANCH IF NOT FOUND, USE ENTIRE STRING
	SUBL3	R0,R4,R2		;ISOLATE NEXT KEYWORD
20$:	MOVAB	-(R0),R4		;CHOP KEYWORD OFF STRING
	MOVAB	1(R1),R5
	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF KEYWORD
	PUSHAL	-(SP)			;PUSH ADDRESS OF WORD TO GET BIT NUMBER
	PUSHAB	8(SP)			;PUSH ADDRESS OF DESCRIPTOR
	CALLS	#2,G^PRV$PRIVBIT	;LOOKUP KEYWORD AND GET PRIV. BIT #
	POPR	#^M<R1,R2,R3>		;CLEANUP STACK
	BLBC	R0,70$			;IF ERROR, SIGNAL IT
	CMPW	(R3),#^A'NO'		;IS KEYWORD NEGATED?
	BEQL	30$			;IF SO, CHECK IF PRIVILEGE OFF
	BBC	R1,(R6),50$		;BRANCH IF PRIVILEGE NOT ON
	BRB	40$
30$:	BBS	R1,(R6),50$		;BRANCH IF PRIVILEGE NOT OFF
40$:	TSTL	R4			;ANY MORE KEYWORDS LEFT?
	BGTR	10$			;IF NOT, LOOP UNTIL DONE
	MOVL	#1,R1			;RETURN SUCCESS
	BRB	60$

50$:	CLRL	R1			;RETURN FAILURE
60$:	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

70$:	CMPL	#PRV$_NOTUNQ,R0		;AMBIGUOUS KEYWORD?
	BNEQ	75$			;IF NOT, EXIT WITH INVALID KEYWORD
	STATUS	ABKEYW			;SET AMBIGUOUS KEYWORD ERROR
	BRB	80$
75$:	STATUS	IVKEYW			;SET INVALID KEYWORD
80$:	BRW	P1_ERROR		;REPORT ERROR

	.SBTTL	RETURN PROCESS NAME
;+
; F$PROCESS - RETURN PROCESS NAME
;
; THIS LEXICAL FUNCTION OBTAINS THE CURRENT PROCESS NAME AND RETURN A DESCRIPTOR
; FOR IT.
;
;	F$PROCESS()
;
; INPUTS:
;
;	R2 = LENGTH OF SCRATCH BUFFER.
;	R3 = ADDRESS OF SCRATCH BUFFER.
;
; OUTPUTS:
;
;	R1 = LENGTH OF PROCESS NAME.
;	R2 = ADDRESS OF PROCESS NAME.
;-
 
F$PROCESS:				;RETURN PROCESS NAME
	CMPL	#15,R2			;BUFFER BIG ENOUGH TO HOLD PROCESS NAME?
	BGTRU	20$			;BRANCH IF NOT
	CLRQ	-(SP)			;RESERVE IOSB
	CLRL	-(SP)			;CLEAR ITEM ID OF LAST ITEM
	PUSHAB	-12(SP)			;PUSH ADDRESS TO STORE LENGTH
	MOVQ	R2,-(SP)		;PUSH OUTPUT BUFFER DESCRIPTOR
	MOVW	#JPI$_PRCNAM,2(SP)	;SET PROCESS NAME IDENTIFICATION
	MOVL	SP,R0			;SET ADDRESS OF ITEM LIST
	$GETJPIW_S ITMLST=(R0),-	;GET PROCESS NAME
		IOSB=16(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,10$			;IF LBC SERVICE FAILURE
	MOVZWL	16(SP),R0		;GET STATUS FROM IOSB
10$:	MOVQ	(SP)+,R1		;RETRIEVE PROCESS NAME PARAMETERS
	MOVZWL	R1,R1			;CLEAR ITEM ID
	ADDL	#4*4,SP			;CLEAN OFF STACK
	BLBC	R0,30$			;BRANCH IF ERROR
	RSB				;
20$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW
30$:	BRW	ERROR			;REPORT ERROR IN R0

	.SBTTL	GET NEXT WILDCARD FILESPEC
;+
; F$SEARCH - GET NEXT WILDCARD FILESPEC
;
; THIS FUNCTION INVOKES THE $SEARCH SYSTEM SERVICE TO RETURN THE NEXT
; FILESPEC IN SEQUENCE, GIVEN THE WILDCARD CONTEXT.  IF THE EXPANDED
; NAME STRING IS NOT WILDCARD, THE EXPANDED NAME STRING IS CONVERTED
; INTO A RESULTANT NAME STRING.
;
;	F$SEARCH(ENM, STREAM_ID)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF EXPANDED NAME STRING
;	P2(AP) = OPTIONAL BINARY STREAM IDENTIFIER, DEFAULTS TO 0
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT FILESPEC
;-

F$SEARCH:
;
; SEARCH THE LIST OF SEARCH CONTEXT BLOCKS FOR THE REQUESTED STREAM.
; THE CONTEXT IS MATCHED BASED ON A USER SPECIFIED 32-BIT BINARY NUMBER.
;
; EACH CONTEXT BLOCK HAS THE FOLLOWING FORMAT:
;
;	LONGWORD POINTER TO NEXT BLOCK, 0 MEANS END OF LIST
;	LENGTH OF THIS BLOCK IN BYTES
;	FAB BLOCK   (FAB$L_CTX CONTAINS THE USER STREAM IDENTIFIER, P2)
;	NAM BLOCK
;	EXPANDED NAME STRING BUFFER
;	RESULTANT NAME STRING BUFFER
;	PRIMARY FILESPEC BUFFER
;
; ON OUTPUT FROM THIS PARAGRAPH:
;
;	R6 = ADDRESS OF CURRENT CONTEXT BLOCK, IF FOUND
;	R7 = ADDRESS OF PREVIOUS CONTEXT BLOCK IN LINKED LIST
;
	MOVL	PRC_L_STACKPT(R11),R0	;GET ADDRESS OF CURRENT INDIRECT FRAME
	MOVAB	IDF_L_SEARCHCTX(R0),R7	;GET ADDRESS OF LISTHEAD
10$:	MOVL	(R7),R6			;GET ADDRESS OF NEXT CONTEXT BLOCK
	BEQL	20$			;BRANCH IF CONTEXT NOT FOUND
	CMPL	P2(AP),FAB$L_CTX+8(R6)	;DOES THE STREAM IDENTIFIER MATCH?
	BEQL	15$			;BRANCH IF CONTEXT FOUND
	MOVL	R6,R7			;SKIP TO NEXT BLOCK IN LIST
	BRB	10$			;AND CONTINUE SEARCHING
;
; CONTEXT BLOCK FOUND IN LIST.  IF THE INPUT FILESPEC HAS CHANGED,
; THEN RESTART THIS STREAM WITH NEW FILESPEC.
;
15$:	MOVAB	8(R6),R5		;SET ADDRESS OF FAB
	MOVAB	FAB$C_BLN(R5),R4	;SET ADDRESS OF NAM
	MOVZBL	FAB$B_FNS(R5),R0	;GET SIZE OF PREVIOUS FILESPEC
	TSTL	P1(AP)			;NULL STRING?
	BEQL	17$			;YES, THEN CLEAN UP AND EXIT
	CMPC5	R0,@FAB$L_FNA(R5),#0,P1(AP),@P1+4(AP) ;SAME FILESPEC?
	BNEQ	28$			;IF NOT, RESTART SEARCH SEQUENCE
	BRW	30$			;ELSE, CONTINUE WHERE WE LEFT OFF
17$:	BRW	50$			;CLEAN UP AND EXIT

;
; THE CONTEXT WAS NOT FOUND AMONG THE EXISTING CONTEXT BLOCKS FOR THIS
; INDIRECT LEVEL.  CREATE A NEW CONTEXT BLOCK BY PARSING THE INPUT
; FILESPEC, P1, AND INSERTING THE CONTEXT BLOCK INTO THE LIST.
;
20$:	MOVZWL	#8+FAB$C_BLN+NAM$C_BLN+<3*NAM$C_MAXRSS>,R1 ;SET SIZE OF BLOCK
	BSBW	DCL$ALLDYNMEM		;ALLOCATE CONTEXT BLOCK
	BLBS	R0,25$			;BRANCH IF OK
	STATUS	SYMOVF			;SYMBOL TABLE OVERFLOW
	BRW	P1_ERROR		;REPORT ERROR
25$:	MOVL	R2,R6			;SAVE ADDRESS OF ALLOCATED BLOCK
	MOVL	(R7),(R6)		;INSERT INTO LINKED LIST
	MOVL	R6,(R7)
	MOVL	R1,4(R6)		;STORE SIZE IN NEWLY ALLOCATED BLOCK
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN,8(R6)	;ZERO REST OF BLOCK
	MOVAB	8(R6),R5		;SET ADDRESS OF FAB
	MOVAB	FAB$C_BLN(R5),R4	;SET ADDRESS OF NAM
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R5) ;INITIALIZE FAB
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R4) ;INITIALIZE NAM
	MOVL	R4,FAB$L_NAM(R5)	;SET POINTER TO NAM BLOCK
	SETBIT	FAB$V_PPF,FAB$L_FOP(R5)	;USE PROCESS I/O SEGMENT (SINCE THERE
					;   MAY NOT BE ANY IMAGE I/O SEGMENT)
	MOVL	P2(AP),FAB$L_CTX(R5)	;SAVE USER SEARCH STREAM IDENTIFIER
28$:	MOVB	P1(AP),FAB$B_FNS(R5)	;STORE PRIMARY NAME STRING INTO FAB
	MOVAB	NAM$C_BLN+<2*NAM$C_MAXRSS>(R4),FAB$L_FNA(R5)
	PUSHR	#^M<R4,R5>		;SAVE REGISTERS
	MOVC5	P1(AP),@P1+4(AP),#0,#NAM$C_MAXRSS,@FAB$L_FNA(R5)
	POPR	#^M<R4,R5>		;RESTORE REGISTERS
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R4) ;SET DESCRIPTOR OF ESA BUFFER
	MOVAB	NAM$C_BLN(R4),NAM$L_ESA(R4)
	MOVB	#NAM$C_MAXRSS,NAM$B_RSS(R4) ;SET DESCRIPTOR OF RESULT BUFFER
	MOVAB	NAM$C_BLN+NAM$C_MAXRSS(R4),- ;FOR $SEARCH (DONE HERE SINCE IT
		NAM$L_RSA(R4)		;DOESN'T CHANGE DURING ENTIRE SEQUENCE)
	$PARSE	FAB=(R5)		;SETUP EXPANDED NAME STRING, NAM FIELDS
	BLBC	R0,50$			;(SUCH AS FID,DID,DVI,ESL)

;
; SEARCH CONTEXT BLOCK IS NOW ASSOCIATED WITH THIS STREAM (IT WAS EITHER
; FOUND IN THE LIST, OR CREATED).  IF THE INPUT FILESPEC HAS CHANGED,
; THEN START OVER WITH NEW FILESPEC.  OTHERWISE, SEARCH FOR THE NEXT
; FILESPEC IN SEQUENCE.
;
30$:	$SEARCH	FAB=(R5)		;SEARCH FOR NEXT FILESPEC 
	BLBC	R0,50$			;BRANCH IF ERROR DETECTED
	MOVZBL	NAM$B_RSL(R4),R1	;GET LENGTH OF RESULTANT STRING
	MOVL	NAM$L_RSA(R4),R2	;GET ADDRESS OF RESULTANT STRING
	BBS	#NAM$V_WILDCARD,NAM$L_FNB(R4),40$ ;IF WILDCARD, LEAVE CONTEXT
	MOVQ	R1,-(SP)		;SAVE RESULTANT STRING
	BSBB	DELCTX			;DEALLOCATE THE CONTEXT BLOCK
	MOVQ	(SP)+,R1		;RESTORE RESULTANT STRING
40$:	RSB

;
; AN ERROR HAS BEEN DURING EITHER THE $PARSE OR $SEARCH FUNCTIONS.
; IN ANY CASE, TERMINATE THIS SEARCH SEQUENCE BY REMOVING THE CONTEXT
; BLOCK FROM THE LIST.  RETURN A NULL STRING.  DO NOT REPORT THE ERROR,
; BUT SET THE STATUS.
;
50$:	BSBB	DELCTX			;DEALLOCATE THE CONTEXT BLOCK
	CLRL	R1			;RETURN NULL STRING
	MOVL	SP,R2			;
	RSB				;

;
; DEALLOCATE THE CONTEXT BLOCK
;
;	R5 = ADDRESS OF FAB
;	R6 = POINTER TO CONTEXT BLOCK
;	R7 = POINTER TO PREVIOUS BLOCK IN LIST
;
;	R0-R3 DESTROYED.
;
DELCTX:	MOVB	NLA0,FAB$B_FNS(R5)	;SET NULL DEVICE NAME
	MOVAB	NLA0+1,FAB$L_FNA(R5)	;
	MOVL	FAB$L_NAM(R5),R0	;GET NAMBLK PTR
	BEQL	10$			;IF THERE IS ONE
	SETBIT	NAM$V_SYNCHK,NAM$B_NOP(R0) ;SET SYNTAX ONLY CHECK
10$:	$PARSE	FAB=(R5)		;TERMINATE SEARCH SEQUENCE
	MOVL	(R6),(R7)		;REMOVE FROM LINKED LIST
	MOVL	R6,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVL	4(R6),R1		;SET SIZE OF BLOCK TO DEALLOCATE
	BSBW	DCL$DEADYNMEM		;DEALLOCATE CONTEXT BLOCK
	RSB

	.SBTTL	SET/CLEAR SPECIFIED PRIVILEGES
;+
; F$SETPRV - SET OR CLEAR THE SPECIFIED LIST OF PRIVILEGES
;
; THIS FUNCTION SETS OR CLEARS (DEPENDING ON WHETHER A "NO" IS PREFIXED
; TO THE PRIVILEGE KEYWORD) THE SPECIFIED LIST OF PRIVILEGES IN THE PROCESS
; PERMANENT PRIVILEGE MASK.  THE PREVIOUS STATES OF THE LISTED PRIVILEGES
; ARE RETURNED AS THE VALUE OF THE FUNCTION.  NOTE THAT ONLY THE PREVIOUS
; STATES OF THE PRIVILEGES LISTED IN THE ARGUMENT ARE RETURNED, TO AVOID
; DEALING WITH STRINGS OF EXCESSIVE LENGTH.
;
;	F$SETPRV(PRVSTATES)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF A COMMA SEPARATED LIST OF PRIVILEGE KEYWORDS.
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF COMMA SEPARATED LIST OF KEYWORDS INDICATING
;		THE PREVIOUS STATES OF THESE PRIVILEGES.
;-

F$SETPRV:
	MOVAQ	-(SP),R6		;GET ADDRESS OF SCRATCH QUADWORD
	BSBW	DCL$MARK		;MARK POSITION IN EXPANSION BUFFER
	$SETPRV_S PRVPRV=(R6),-		;GET CURRENT PERMANENT PRIVILEGES
		  PRMFLG=#1
	MOVQ	P1(AP),R4		;GET DESCRIPTOR OF COMMA SEPARATED LIST
10$:	MOVQ	R4,R2			;ASSUME NO COMMA IN LIST
	LOCC	#^A',',R4,(R5)		;LOCATE END OF NEXT KEYWORD
	BEQL	20$			;BRANCH IF NOT FOUND, USE ENTIRE STRING
	SUBL3	R0,R4,R2		;ISOLATE NEXT KEYWORD
20$:	MOVAB	-(R0),R4		;CHOP KEYWORD OFF STRING
	MOVAB	1(R1),R5
	PUSHR	#^M<R2,R3>		;SAVE REGISTERS
	CMPC5	#3,W^NOALL+2,#0,R2,(R3)	;IS KEYWORD = "ALL"?
	BEQL	22$			;BRANCH IF SO
	CMPC5	#5,W^NOALL,#0,R2,(R3)	;IS KEYWORD = "NOALL"?
22$:	POPR	#^M<R2,R3>		;RESTORE REGISTERS
	BNEQ	30$			;BRANCH IF NOT
	CLRL	R1			;START WITH PRIVILEGE #0
25$:	BSBW	ADD_PRIV_STATE		;APPEND PRIVILEGE KEYWORD TO STRING
	AOBLSS	#64,R1,25$		;FOR EACH PRIVILEGE IN MASK
	BRB	40$
30$:	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF KEYWORD
	PUSHAL	-(SP)			;ADDRESS OF LONGWORD TO RECEIVE BIT #
	PUSHAB	8(SP)			;SET ADDRESS OF KEYWORD
	CALLS	#2,G^PRV$PRIVBIT	;LOOKUP KEYWORD
	POPR	#^M<R1,R2,R3>		;AND GET PRIVILEGE BIT NUMBER IN R1
	BLBC	R0,51$			;BRANCH IF ERROR DETECTED
	BSBB	ADD_PRIV_STATE		;APPEND PRIVILEGE KEYWORD TO STRING
40$:	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF KEYWORD
	PUSHL	R6			;SET ADDRESS OF PRIVILEGE MASK
	PUSHAB	4(SP)			;SET ADDRESS OF KEYWORD
	CALLS	#2+2,G^PRV$SETPRIV	;ENABLE/DISABLE SPECIFIED PRIVILEGE
51$:	BLBC	R0,50$			;BRANCH IF ERROR DETECTED
	TSTL	R4			;ANY MORE KEYWORDS?
	BGTR	10$			;IF SO, LOOP UNTIL DONE
	MNEGL	#1,-(SP)		;CREATE PRIVILEGE MASK WITH ALL
	MNEGL	#1,-(SP)		;THE PRIVILEGE BITS SET
	MOVL	SP,R2			;GET ADDRESS OF IT
	$SETPRV_S PRVADR=(R2),-		;DISABLE ALL PRIVILEGES
		  PRMFLG=#1,-		;
		  ENBFLG=#0		;
	$SETPRV_S PRVADR=(R6),-		;ENABLE NEW PRIVILEGES
		  PRMFLG=#1,-		;
		  ENBFLG=#1		;
	ADDL	#16,SP			;CLEANUP STACK
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF STRING
	MOVL	WRK_L_MARKPTR(R10),WRK_L_EXPANDPTR(R10)	;RESTORE POSITION IN EXPANSION BUFFER
	DECL	R1			;DO NOT RETURN TRAILING COMMA
	RSB
	
50$:	CMPL	#PRV$_NOTUNQ,R0		;AMBIGUOUS KEYWORD?
	BNEQ	55$			;IF NOT, EXIT WITH INVALID KEYWORD
	STATUS	ABKEYW			;SET AMBIGUOUS KEYWORD ERROR
	BRB	80$
55$:	STATUS	IVKEYW			;SET INVALID KEYWORD
80$:	ADDL	#8,SP			;CLEANUP STACK
	BRW	P1_ERROR		;REPORT ERROR

	.SBTTL	APPEND PRIVILEGE STATE TO STRING
;---
; ADD_PRIV_STATE - APPEND PRIVILEGE STATE (IN KEYWORD FORM) TO STRING.
;
; THIS ROUTINE APPENDS THE PRIVILEGE KEYWORD ASSOCIATED WITH A GIVEN
; PRIVILEGE BIT AND MASK TO THE CURRENT STRING BEING ASSEMBLED IN THE
; EXPANSION BUFFER.  IF THE PRIVILEGE BIT NUMBER DOES NOT CORRESPOND
; TO A KEYWORD, NOTHING IS APPENDED TO THE STRING AND NO ERROR IS RETURNED.
;
; INPUTS:
;
;	R1 = PRIVILEGE BIT NUMBER
;	R6 = ADDRESS OF PRIVILEGE MASK
;
; OUTPUTS:
;
;	THE KEYWORD (NEGATED IF THE PRIVILEGE IS OFF) IS APPENDED TO THE
;	STRING.
;
;	R0 DESTROYED.
;---

ADD_PRIV_STATE:
	PUSHL	R1			;SAVE PRIVILEGE BIT NUMBER
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE CURRENT POSITION IN BUFFER
	BBS	R1,(R6),30$		;BRANCH IF PRIVILEGE WAS PREVIOUSLY SET
	MOVZBL	#^A'N',R0		;INSERT AN "N" INTO THE BUFFER
	BSBW	DCL$PUTCHAR
	MOVZBL	#^A'O',R0		;INSERT AN "O" INTO THE BUFFER
	BSBW	DCL$PUTCHAR
30$:	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF EXPANSION BUFFER
	SUBL3	(SP),WRK_L_CHARPTR(R10),-(SP) ;SCRATCH AREA LEFT
	PUSHL	SP			;ADDRESS OF WORD TO GET RETLEN
	PUSHAB	4(SP)			;ADDRESS OF BUFFER DESCRIPTOR
	PUSHL	R1			;SET PRIVILEGE BIT NUMBER
	CALLS	#3,G^PRV$KEYWORD	;GET KEYWORD ASSOCIATED WITH BIT NUMBER
	ADDL3	(SP)+,(SP)+,R1		;POINT TO STRING END+1
	BLBC	R0,50$			;IF NO SUCH PRIVILEGE, APPEND NOTHING
	ADDL	#4,SP			;THROW AWAY SAVED EXPANSION POINTER
	MOVL	R1,WRK_L_EXPANDPTR(R10)	;INSERT INTO EXPANSION BUFFER
	MOVZBL	#^A',',R0		;INSERT AN "," INTO THE BUFFER
	BSBW	DCL$PUTCHAR
90$:	POPL	R1			;RESTORE PRIVILEGE BIT NUMBER
	RSB

50$:	POPL	WRK_L_EXPANDPTR(R10)	;BACKUP POSITION IN BUFFER
	BRB	90$			;AND EXIT WITHOUT APPENDING ANYTHING

	.SBTTL	CONVERT EXPRESSION TO ASCII STRING
;+
; F$STRING - CONVERT TO ASCII STRING
;
; THIS FUNCTION CONVERTS ANY EXPRESSION INTO AN ASCII STRING.  IF THE
; EXPRESSION IS A BINARY VALUE, IT IS CONVERTED INTO DECIMAL ASCII.
;
;	F$STRING(EXPRESSION)
;
; INPUTS:
;
;	P1(AP) = EXPRESSION VALUE
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF VALUE STRING
;-

F$STRING:
	MOVQ	P1(AP),R1		;GET EXPRESSION VALUE
	JSB	DCL$CVT_STRING		;CONVERT TO ASCII STRING
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	RSB
90$:	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	RETURN CURRENT TIME AND DATE
;+
; F$TIME - RETURN CURRENT TIME AND DATE
;
; THIS LEXICAL FUNCTION OBTAINS THE CURRENT TIME AND DATE AND RETURNS A STRING
; DESCRIPTOR FOR IT.
;
;	F$TIME()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF TIME AND DATE STRING.
;	R2 = ADDRESS OF TIME AND DATE STRING.
;-
 
F$TIME:					;RETURN TIME AND DATE
	MOVQ	R2,-(SP)		;BUILD TIME BUFFER DESCRIPTOR
	CMPL	#23,(SP)		;TIME BUFFER LARGE ENOUGH?
	BGTRU	50$			;IF GTRU NO
	MOVL	SP,R0			;SET ADDRESS OF TIME BUFFER DESCRIPTOR
	$ASCTIM_S (R0),(R0)		;GET CURRENT TIME
	MOVQ	(SP)+,R1		;RETRIEVE TIME BUFFER PARAMETERS
	BLBC	R0,60$			;IF LBC CONVERSION FAILURE
	RSB				;

50$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW
60$:	BRW	ERROR			;REPORT SYSTEM SERVICE ERROR

	.SBTTL	GET SYMBOL TYPE
;+
; F$TYPE - GET SYMBOL TYPE
;
; THIS FUNCTION RETURNS NULL, "INTEGER", OR "STRING" CHARACTER STRINGS
; DEPENDING ON WHETHER THE SPECIFIED SYMBOL IS UNDEFINED, EQUATED TO A
; NUMERIC STRING OR AN INTEGER, OR EQUATED TO A NON-NUMERIC STRING.
;
;	F$TYPE (SYMBOL)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF SYMBOL NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING DESCRIBING THE SYMBOL TYPE
;-

F$TYPE:
	MOVQ	R2,-(SP)		;SAVE BUFFER DESCRIPTOR
	MOVQ	P1(AP),R1		;GET DESCRIPTOR OF SYMBOL NAME
	BSBW	DCL$SEARCH		;FIND SYMBOL IN SYMBOL TABLE
	BLBC	R0,20$			;IF NOT FOUND, RETURN NULL
	TSTL	R2			;STRING DESCRIPTOR?
	BEQL	10$			;NO, THEN BRANCH
	TSTL	R1			;NULL STRING?
	BEQL	5$			;YES, THEN BRANCH
	CMPL	R1,(SP)			;BUFFER LARGE ENOUGH?
	BGTRU	90$			;IF GTRU NO
	MOVL	R1,(SP)			;COPY SYMBOL LENGTH
	MOVC3	R1,(R2),@4(SP)		;COPY THE SYMBOL VALUE
	MOVQ	(SP),R2			;MOVE THE DESCRIPTOR INTO R2/R3
	MOVL	#PRC_K_DEC,R1		;SET CONVERSION RADIX
	BSBW	DCL$CNVASCBIN		;CONVERT THE STRING TO DECIMAL
	BEQL	10$			;IF SUCCESSFUL, THEN INTEGER
5$:	MOVAB	STRING,R2		;IF NOT, THEN RETURN 'STRING'
	MOVZBL	(R2)+,R1		;
	BRB	20$			;
10$:	MOVAB	INTEGER,R2		;RETURN 'INTEGER'
	MOVZBL	(R2)+,R1		;
20$:	ADDL	#8,SP			;RESTORE THE STACK
	RSB

90$:	ADDL	#8,SP			;RESTORE THE STACK
	BRW	BUFOVF			;REPORT BUFFER OVERFLOW

	.SBTTL	RETURN USER IDENTIFICATION CODE
;+
; F$USER - RETURN USER IDENTIFICATION CODE
;
; THIS LEXICAL FUNCTION FUNCTION CONVERTS THE USER IDENTIFICATION CODE TO AN
; ASCII STRING AND RETURNS A DESCRIPTOR FOR IT.
;
;	F$USER()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF USER IDENTIFICATION CODE.
;	R2 = ADDRESS OF USER IDENTIFICATION CODE.
;-
 
F$USER:					;RETURN USER IDENTIFICATION CODE
	CLRQ	-(SP)			;RESERVE IOSB
	CLRQ	-(SP)			;CLEAR LAST ITEM AND LENGTH ADDRESS
	PUSHAB	-8(SP)			;PUSH ADDRESS TO STORE USER IDENTIFICATION
	PUSHL	#JPI$_UIC@16+4		;SET PARAMETER ID AND LENGTH
	MOVL	SP,R0			;SET ADDRESS OF TIME LIST
	$GETJPIW_S ITMLST=(R0),-	;GET USER IDENTIFICATION CODE
		IOSB=16(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,20$			;IF LBC SERVICE FAILURE
	MOVZWL	16(SP),R0		;GET STATUS FROM IOSB
	BLBC	R0,20$			;IF LBC SERVICE FAILURE
	MOVL	(SP),R4			;GET UIC
	BSBW	FORMAT_UIC		;FORMAT THE UIC
	ADDL	#6*4,SP			;REMOVE ITEM LIST AND IOSB FROM STACK
	RSB				;

20$:	ADDL	#6*4,SP			;REMOVE ITEM LIST AND IOSB FROM STACK
	BRB	ERROR			;

	.SBTTL	RETURN VERIFY MODE
;+
; F$VERIFY - RETURN VERIFY MODE
;
; THIS LEXICAL FUNCTION RETURNS A BOOLEAN VARIABLE THAT DESCRIBES THE CURRENT
; STATE OF THE VERIFY MODE AND, IN ADDITION, WILL SET OR CLEAR VERIFICATION
; IF A NON-NULL ARGUMENT IS SPECIFIED.
;
;	F$VERIFY([NEW_VERIFY_MODE [, NEW_IMAGE_VERIFY_MODE]])
;
; INPUTS:
;
;	P1(AP) = OPTIONAL NEW VERIFY MODE (1 TO SET, 0 TO CLEAR)
;		(-1 IF UNSPECIFIED)
;	P2(AP) = OPTIONAL NEW IMAGE VERIFY MODE (1 TO SET, 0 TO CLEAR)
;		(-1 IF UNSPECIFIED)
;
; OUTPUTS:
;
;	R1 = BOOLEAN RESULT
;	R2 = 0 TO INDICATE RESULT IS BINARY
;-
 
F$VERIFY:				;RETURN VERIFY MODE
	MOVL	#1,R8			;ASSUME VERIFY IS CURRENTLY ON
	BBS	#PRC_V_VERIFY,PRC_W_FLAGS(R11),10$ ;BR IF ON
	CLRL	R8			;MARK VERIFY TURNED OFF
10$:	TSTL	P1(AP)			;A NON-NULL ARGUMENT?
	BLSS	90$			;NOPE, IT'S NULL, NO CHANGES
	CLRBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11) ;TURN OFF VERIFICATION
	BLBC	P1(AP),20$		;LEAVE VERIFY OFF IF LBC
	SETBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11) ;ELSE TURN ON VERIFICATION
20$:	MOVL	P2(AP),R6		;A NON-NULL ARGUMENT?
	BGEQ	30$			;BRANCH IF NON-NULL
	MOVL	P1(AP),R6		;ELSE USE FIRST ARGUMENT
30$:	BSBW	DCL$SETVERIFY_IMAGE	;SET IMAGE VERIFICATION
90$:	MOVL	R8,R1			;RETURN BOOLEAN RESULT
	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB				;

	.SBTTL	ERROR RETURNS
 
;
; BUFFER OVERFLOW
;
 
BUFOVF:	STATUS	BUFOVF			;SET BUFFER OVERFLOW STATUS
ERROR:	BSBW	DCL$MARK		;SET FOR NO SEGMENT DISPLAY
	BRB	DCL$PARSERR

;
; SIGNAL ERROR WITH AN ARGUMENT AS THE ERROR SEGMENT
;

P1_ERROR:
	MOVAB	P1(AP),R2		;USE P1 AS ERROR SEGMENT
	BRB	PN_ERROR
P2_ERROR:
	MOVAB	P2(AP),R2		;USE P2 AS ERROR SEGMENT
	BRB	PN_ERROR
P3_ERROR:
	MOVAB	P3(AP),R2		;USE P3 AS ERROR SEGMENT
	BRB	PN_ERROR
P4_ERROR:
	MOVAB	P4(AP),R2		;USE P4 AS ERROR SEGMENT
	BRB	PN_ERROR
P5_ERROR:
	MOVAB	P5(AP),R2		;USE P5 AS ERROR SEGMENT
	BRB	PN_ERROR
P6_ERROR:
	MOVAB	P6(AP),R2		;USE P6 AS ERROR SEGMENT

PN_ERROR:
	CLRL	R1			;PRESET TO RETURN NULL STRING
	BBS	#WRK_V_COMMENT,WRK_W_FLAGS(R10),30$ ;RETURN NULL IF IN COMMENT
	MOVL	4(R2),WRK_L_MARKPTR(R10) ;SET START OF ERROR SEGMENT
	ADDL3	(R2),4(R2),WRK_L_EXPANDPTR(R10) ;SET END OF ERROR SEGMENT
	BRB	DCL$PARSERR		;REPORT ERROR
30$:	RSB				;RETURN WITH FUNCTION=NULL/ZERO

;
; ERROR EXIT FROM LEXICAL FUNCTION STRING EXPANSION
;
 
DCL$PARSERR::				;
	BSBW	DCL$ERRORMSG		;OUTPUT ERROR MESSAGE
	PUSHL	R0			;SAVE FINAL STATUS
	JSB	DCL$FLUSH		;FLUSH COMMAND
	POPL	R0			;RETRIEVE FINAL STATUS
	JSB	DCL$SET_STATUS		;SET COMMAND STATUS
	JMP	DCL$RESTART		;

	.SBTTL	CONVERT UIC TO ASCII STRING
;+
; FORMAT_UIC - CONVERT BINARY UIC TO ASCII STRING
;
; CONVERTS A BINARY UIC LONGWORD INTO AN ASCII STRING
;
; INPUTS:
;
;	R4 = UIC LONGWORD
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING
;
;-

UIC:	.ASCIC	'!%I'

FORMAT_UIC:
	MOVAB	UIC,R1			;GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		;CREATE DESCRIPTOR OF FAO STRING
	MOVQ	R0,-(SP)		;PUSH ONTO STACK
	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF SCRATCH BUFFER
	SUBL3	WRK_L_EXPANDPTR(R10),-	;
		WRK_L_CHARPTR(R10),-(SP);
	MOVL	SP,R0			;
	$FAO_S	CTRSTR=8(R0),-		;FORMAT INTO ASCII STRING
		OUTBUF=(R0),-		;ADDRESS OF RESULT BUFFER
		OUTLEN=(R0),-		;WORD TO RECEIVE RESULT LENGTH
		P1=R4			;UIC NUMBER
	POPR	#^M<R1,R2,R3,R4>	;GET DESCRIPTOR OF STRING
					;AND CLEAN STACK
	RSB

	.SBTTL	CONVERT PROTECTION MASK TO ASCII STRING
;+
; FORMAT_PROT - CONVERT BINARY PROTECTION MASK TO ASCII STRING
;
; CONVERTS A BINARY PROTECTION MASK WORD INTO AN ASCII STRING
;
; INPUTS:
;
;	R4 = PROTECTION WORD
;	R10 = BASE ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING
;
; REGISTER USAGE:
;
;	R0,R1,R2,R3,R7,R8
;-

NULL:	.BYTE	0
EQUAL:	.ASCIC	/=/
ACCESS:	.ASCII	/RWED/
PROTECTMSG:
	.ASCII	/SYSTEM!AC!AD, OWNER!AC!AD, GROUP!AC!AD, WORLD!AC!AD/
PROTECTEND:

FORMAT_PROT:
	MOVL	SP,R3			;START A SCRATCH AREA ON THE STACK
	SUBL	#4*12,SP		;ALLOCATE FAO ARGUMENT DESCRIPTORS
					;AND ASCIC ADDRESS DESCRIPTORS

	MOVZBL	#12,R8			;SET OUTER LOOP INDEX
10$:	CLRL	-(SP)			;ALLOCATE SPACE FOR FAO ARG BUFFER
	CLRQ	-(R3)			;ZERO FAO ARG DESCRIPTOR
	MOVAB	NULL,-(R3)		;INIT ASCIC POINTER, ASSUME NO ACCESS
	EXTZV	R8,#4,R4,R1		;EXTRACT ONE PROTECTION FIELD
	MCOML	R1,R2			;COMPLEMENT IT
	BITL	#^XF,R2			;ALL ACCESS DENIED?
	BEQL	40$			;IF EQL, YES
	MOVAB	EQUAL,(R3)		;SET POINTER TO ASCIC =
	CLRL	R7			;CLEAR INNER LOOP INDEX
	MOVAB	(SP),8(R3)		;PUT ADDR OF BUFFER IN DESCRIPTOR
	CLRL	4(R3)			;CLEAR BUFFER LENGTH

20$:	BBS	R7,R1,30$		;IF SET, ACCESS DENIED
	MOVB	ACCESS[R7],@4(R3)[SP]	;MOVE ACCESS CHARACTER INTO BUFFER
	INCL	4(R3)			;INCREMENT BUFFER LENGTH
30$:	AOBLSS	#4,R7,20$		;CHECKED ALL FOUR BITS?

40$:	ACBB	#0,#-4,R8,10$		;CHECKED ALL FOUR MODES?

	PUSHAB	PROTECTMSG		;PUSH DESCRIPTOR FOR CONTROL STRING 
	PUSHL	#PROTECTEND-PROTECTMSG
	PUSHL	WRK_L_EXPANDPTR(R10)	;PUSH DESCRIPTOR TO RECEIVE FAO OUTPUT
	PUSHL	#PROTECTEND-PROTECTMSG+4
	MOVL	SP,R0			;SAVE POINTER TO TOP OF STACK
	$FAOL_S	CTRSTR=8(R0),-		;GENERATE FORMATTED ASCII STRING
		OUTBUF=(R0),-
		OUTLEN=(R0),-
		PRMLST=(R3)

	MOVQ	(SP),R1			;MOVE OUTPUT DESCRIPTOR INTO R1/R2
	ADDL	#20*4,SP		;RESTORE STACK
	RSB	

	.SBTTL	CONVERT FILE ID TO ASCII STRING
;+
; FORMAT_FILEID - CONVERT FILE ID TO ASCII STRING
;
; INPUTS:
;
;	R4 = ADDRESS OF 3-WORD FILE ID
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING
;-

FILEID:	.ASCIC	'(!UW,!UW,!UB)'

FORMAT_FILEID:
	MOVAB	FILEID,R1		;GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		;CREATE DESCRIPTOR OF FAO STRING
	MOVQ	R0,-(SP)		;PUSH ONTO STACK
	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF SCRATCH BUFFER
	SUBL3	WRK_L_EXPANDPTR(R10),WRK_L_CHARPTR(R10),-(SP)
	MOVL	SP,R0
	$FAO_S	CTRSTR=8(R0),-		;FORMAT INTO ASCII STRING
		OUTBUF=(R0),-		;ADDRESS OF RESULT BUFFER
		OUTLEN=(R0),-		;WORD TO RECEIVE RESULT LENGTH
		P1=(R4),-		;FILE NUMBER
		P2=2(R4),-		;SEQUENCE NUMBER
		P3=4(R4)		;RELATIVE VOLUME NUMBER
	POPR	#^M<R1,R2,R3,R4>	;GET DESCRIPTOR OF STRING
					;AND CLEAN STACK
	RSB

	.SBTTL	CONVERT BINARY TO BOOLEAN STRING
;+
; FORMAT_BOOLEAN - CONVERT BINARY TO ASCII BOOLEAN STRING
;
; INPUTS:
;
;	R1 = STATUS (ONLY BOTTOM BIT CHECKED)
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING (TRUE OR FALSE)
;-

FORMAT_BOOLEAN:
	MOVAB	FALSE,R2		;ASSUME FALSE
	BLBC	R1,10$			;BRANCH IF FALSE
	MOVAB	TRUE,R2			;SET TRUE
10$:	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF BOOLEAN STRING
	RSB

	.END
