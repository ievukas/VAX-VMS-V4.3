%TITLE 'COB$ACCEPT - VAX COBOL ACCEPT Statement'
MODULE COB$ACCEPT (			!
		   IDENT = '1-018'	! File: COBACCEPT.B32 EDIT:LGB1018
				   ) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  COBOL SUPPORT
!
! ABSTRACT:
!
!	Supports the COBOL ACCEPT statement.
!
!	Contains COB$$OPEN_IN  to open an RMS file for input.
!
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: Rich Reichert, CREATION DATE: 16-JULY-79
!
! MODIFIED BY:
!
! 1-001	- Original.  RKR 16-JULY-79
! 1-002 - Make COB$$OPEN_IN stop instead of signal on open error.
!	  RKR 4-SEPT-79
! 1-003 - Make COB$$READ_RMS signal COB$_EOFON_ACC if an EOF is
!	  encountered during reading.
!	  Do string copy into caller's buffer via CH$COPY instead of
!	  STR$COPY to avoid dependency on STR$ routines.
!	  RKR 14-SEPT-79
! 1-004 - Identify file name on bad RMS  status other than EOF.
!	  RKR 25-SEPT-79
! 1-005 - Change name of symbolic LIBRARY file. RKR 1-OCT-79
! 1-006 - Make module name match entry point.  RKR 20-OCT-79
! 1-007 - Change references to LIB$_INVARG to COB$_INVARG.
! 1-008 - Make sensitive to names in REQUIRE file.  RKR 21-OCT-79
! 1-009 - Improve errors signaled.  RKR 21-OCT-79
!	  Cosmetic changes.  RKR 21-OCT-79
! 1-010	- Imperative clean-ups, also try SYS$ logicals.
!	  PDG 00-FEB-81
! 1-011	- Fix call to $TRNLOG to test for SS$_NORMAL
!		(since SS$_NOTRAN is a success status).
!	  Add COB$ACCEPT_EOF to allow ACCEPT ... AT END imp-statement.
!	  Allow MAX(COB$K_ACC_SIZE, .STRING[DSC$W_LENGTH]) bytes for ACCEPT.
!	  PDG 24-Jul-1981
! 1-012 - Updated copyright date.  LB 9-Aug-81
! 1-013	- Removed COB$ACCEPT_EOF.  This functionality is provided by a flag
!	  passed to COB$ACCEPT.
! 1-014 - Add code in COB$ACCEPT to check the STV2 field in the RAB to
!	  determine if the terminator is an escape sequence, and if so,
!	  to return the escape sequence in the user's buffer.  This was
!	  done in response to an SPR regarding incompatibilities between
!	  COBOL-74 and VAX-11 COBOL.  LEB  16-FEB-82
! 1-015 - Version 3 ACCEPT with screen enhancements.	LGB 15-AUG-83
! 1-016 - Code converted from QIO calls to RMS.		LGB 20-JAN-84
! 1-017 - Reset RAB[RAB$V_ETO] bit in COB$ACCEPT.
!	  Added code to COB$$ILLEGAL_TERM and COB$$DELETE_KEY to handle
!	  a Control Z situation.
!	  Added a condition to the IF statement in COB$$ILLEGAL_TERM that
!	  handles bell ringing for an illegal terminator.
!	  Put an RMS workaround in routine COB$$PARTIAL_SEQ. LGB 11-JUL-84
! 1-018 - Bug fix to COB$ACCEPT - reverse IF stmt within the CH$COPY stmt.
!							     LBG 10-SEP-84
!--

!
! PROLOGUE FILE
!
REQUIRE 'RTLIN:COBPROLOG' ;			! Switches, Psects, Include
						! files
!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	COB$ACCEPT,				! Perform ACCEPT
	COB$ACC_SCR,				! Perform ACCEPT with screen enhancements
	COB$$ACC_SCR_FILE,			! Dealing with files not terminals, 
						! RMS call is different
	COB$$OPEN_IN		:  NOVALUE,	! Open for input
	COB$$RMS_GET		:  NOVALUE,	! Perform an RMS $GET call
	COB$$RMS_PUT_BYTE	:  NOVALUE,	! Perform a one byte RMS $PUT
	COB$$RMS_PUT_BUFFER	:  NOVALUE,	! Perform a buffer RMS $PUT
	COB$$CONTROL_Z		:  NOVALUE,	! Handle Control Z
	COB$$PARTIAL_SEQ	:  NOVALUE,	! Put entire escape seq in buffer
	COB$$DELETE_KEY		:  NOVALUE,	! Delete Key processing
	COB$$ILLEGAL_TERM	:  NOVALUE,	! Look for valid terminator
	COB$$CLEAN_UP		:  NOVALUE,	! Clean up before return to COBOL
	COB$$RPG_CLEAN_UP	:  NOVALUE,	! Clean up before return to RPG
	COB$$FORMAT_FOUR ;			! Format four CONTROL KEY routine
!
! EQUATED SYMBOLS:
!
LITERAL
	NUM_UNITS = COB$K_UNIT_MAX - COB$K_UNIT_MIN + 1 ;
						! Number of units
LITERAL
	DISP      = 0,				! Code for Display
	DNA       = 1,				! Code for Display no Advancing
	POS       = 2,				! Code for Positioning
	POS_DNA   = 3,				! Code for Positioning no Advancing
	ACC_ADV   = 4,				! Code for Accept (COBOL V3)
	ACC_DNA   = 5,				! Code for Accept no Adv (COBOL V3)
	FLAG_MASK = 15,				! Mask for first four bits of
						! parameter FLAGS (0-3)
	V_BELL    = 16,				! Bit flag for terminal bell
	V_CONV    = 32,				! Bit flag for conversion
	V_DEC_PT  = 64,				! Bit flag for 'Decimal Point
						! is Comma'
	V_NO_SIGN = 128,			! Bit flag yes/no include sign
	V_PROTECT = 256,			! Bit flag for protection
	V_NO_ECHO = 512,			! Bit flag for no-echo
	V_ADV     = 1024,			! Bit flag for advancing(1)/
						! no advancing (0)
	V_COB_RPG = 2048,			! Bit flag for VAX COBOL /
						! VAX RPG
	DEL_KEY	  = %X'7F',			! Delete key
	CZ	  = %X'1A',			! Control Z
	CARR_RET  = 0,				! Parameters for routine
	LINE_FD   = 1,				! COB$$RMS_PUT_BYTE
	RING_BELL = 2,				
	RMS_HEADER = 14 ;			! RMS uses up 14 bytes of
!						! the buffer for header info
! GUARDS:
!
!   Since the code assumes that COB$K_UNIT_MIN equals 0, and COB_TABLE
!	has only 7 items in it, we safeguard this module.
!
%IF COB$K_UNIT_MIN NEQ 0 %THEN %ERROR('Unexpected COB$K_UNIT_MIN value') %FI
%IF COB$K_UNIT_MAX GTR 6 %THEN %ERROR('Unexpected COB$K_UNIT_MAX value') %FI

GLOBAL
    ACC_SCR	 :  INITIAL (0) ;		! Flag for COB$ACCEPT
OWN
    XABTRM	:  $XABTRM_DECL,		! RMS XABTRM Control Block
    XAB_ITMLST	:  $ITMLST_DECL (ITEMS=2),	! Item list for XABTRM

    !+
    !   Terminator mask.
    !   Leave Control C, Y, S, and Q for VMS.
    !   Control I is Tab.  Control M is Carriage Return.
    !   ENTER key has the same value as <CR> i.e. Control M.
    !   Escape key is a terminator for a VMS V4 system.
    !   Delete key is processed via routine COB$$DELETE_KEY.
    !-

    MASK_VECTOR :  BITVECTOR [160]		! 20 bytes by 8 bits
			PRESET ( [TAB] = 1,
				 [CR ] = 1,
				 [26 ] = 1,	! Control z
				 [01 ] = 1,	! Control a
				 [02 ] = 1,	! Control b
				 [04 ] = 1,	! Control d
				 [05 ] = 1,	! Control e
				 [06 ] = 1,	! Control f
				 [07 ] = 1,	! Control g
				 [08 ] = 1,	! Control h
				 [10 ] = 1,	! Control j
				 [11 ] = 1,	! Control k
				 [12 ] = 1,	! Control l
				 [14 ] = 1,	! Control n
				 [15 ] = 1,	! Control o
				 [16 ] = 1,	! Control p
				 [18 ] = 1,	! Control r
				 [20 ] = 1,	! Control t
				 [21 ] = 1,	! Control u
				 [22 ] = 1,	! Control v
				 [23 ] = 1,	! Control w
				 [24 ] = 1,	! Control x
				 [27 ] = 1,	! Escape key for Arrow & PF Keys
						! and Alternate Keypad Mode
				 [127] = 1,	! Delete key
				 [143] = 1,	! SS3 for Professional Keys
				 [155] = 1	! CSI for Professional Keys
				) ;
!
!
!   MACROS:
!
MACRO  COB$$B_STV0_TERM = 12,0,8,0  %;		! Location of terminator if it
						! is not an escape sequence
MACRO  COB$$B_STV2_LEN  = 14,0,8,0  %;		! Length of escape sequence

MACRO
    $VERIFY_TERMINATOR =
    !+
    !  If parameter KEY not sent (.KEY = 0) then CR, TAB, CONTROL Z,
    !  and DELETE KEY are the only legal terminators.
    !
    !  If parameter KEY not 0 then CR, TAB, CONTROL Z, DELETE KEY, PF,
    !  ARROW and SPECIAL FUNCTION PROFESSIONAL Keys are legal terminators.
    !  Copy terminator to KEY parameter if valid.
    !  Flag LEGAL set to 1 if terminator is valid.
    !-
	    BEGIN

	    IF .TERM_SIZE EQL 1
	    THEN
		BEGIN
		TERM_PTR = RAB [COB$$B_STV0_TERM] ;
 		SELECTONE .RAB [COB$$B_STV0_TERM] OF
		    SET
			[ CR,	 			! Carriage Return
			  TAB ] :			! Tab

			    BEGIN
			    IF .KEY NEQ 0
			    THEN
				CH$MOVE ( 1, .TERM_PTR, .KEY [DSC$A_POINTER] ) ;
			    LEGAL = 1 ;
			    END ;

			[ CZ ] :			! Control z

			    BEGIN
			    !+
			    !  CONTROL Z hit along with data
			    !-
			    IF (.FLAGS AND V_COB_RPG) NEQ 0
			    THEN
				BEGIN			! Control Z is illegal
				LEGAL = 0 ;		! for VAX RPG
				TERM_SIZE = 0 ;
				END
			    ELSE			! Special meaning for
				BEGIN			! VAX COBOL
				COB$$CLEAN_UP ( .PARAMETERS, .FLAGS ) ;
				COB$$CONTROL_Z ( .UNIT, .KEY ) ;
				RETURN 0 ;
				END ;
			    END ;

			[ DEL_KEY ] :			! Delete key

			    BEGIN
			    COB$$DELETE_KEY ( .PARAMETERS, .UNIT, .FLAGS ) ;
			    NO_BELL = 1 ;		! Special processing for
			    END ;			! the DELETE KEY.

			[OTHERWISE] :			! Error - key not a
							! legal terminator
			    BEGIN
			    LEGAL = 0 ;
			    TERM_SIZE = 0 ;
			    END ;
		    TES ;
 		END

	    ELSE
		IF .CHARS_READ EQL 0  AND  .RAB [RAB$L_STS] EQL RMS$_EOF
		THEN
		    !+
		    !  CONTROL Z hit alone
		    !-
		    BEGIN
		    IF (.FLAGS AND V_COB_RPG) NEQ 0
		    THEN
			BEGIN			! Control Z is illegal
			LEGAL = 0 ;		! for VAX RPG
			TERM_SIZE = 0 ;
			END
		    ELSE			! Special meaning for
			BEGIN			! VAX COBOL
			COB$$CLEAN_UP ( .PARAMETERS, .FLAGS ) ;
			COB$$CONTROL_Z ( .UNIT, .KEY ) ;
			RETURN 0 ;
			END ;
		    END
		ELSE
		    !+
		    !  Escape Sequence as Terminator.
		    !- 
		    IF .KEY NEQ 0
		    THEN
			!+
			!  COB$$CONTROL_KEY converts terminator sequences to COBOL
			!  defined sequences and fills in KEY parameter if terminator
			!  is legal.
			!- 
			BEGIN
			IF NOT ( COB$$CONTROL_KEY (TERM_PTR, .TERM_SIZE, .KEY) )
			THEN
			    BEGIN
			    LEGAL = 0 ;
			    TERM_SIZE = 0 ;
			    END
			ELSE
			    LEGAL = 1 ;
			END
		    ELSE
		    !+
		    !  KEY parameter not passed.  Escape sequences are not
		    !  legal terminators.
		    !-
		    BEGIN
		    LEGAL = 0 ;
		    TERM_SIZE = 0 ;
		    END ;
	    END ;				! End $VERIFY_TERMINATOR macro
    % ;

MACRO
    $ERROR_REPROMPT =
    !+
    !  Ring terminal bell to signal a CONVERSION  error was been made during
    !  data input, restore cursor to original position and perform another 
    !  $GET to look for valid data.
    !-

    BEGIN					! Begin $ERROR_REPROMPT macro

    LOCAL
	PUT_TOTAL	:  INITIAL (0),		! # of chars to $PUT
	INDEX		:  INITIAL (0),		! Pointer to RESTORE_CURSOR
	RESTORE_CURSOR	:  VECTOR [5000, BYTE];	! Holds sequence for restoring
						! cursor position.
    COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;

    !+
    !  If NO ECHO was set no need to do any erasing of input data
    !-

    IF .YES_NO_ECHO EQL 0
    THEN
	BEGIN    

	IF (.PUT_FLAG NEQ 0) AND (.YES_PROTECT  EQL  0)
	THEN

	!+
	!  If no protection set and attributes were turned on - turn them off.
	!  If protection was set, leave the FIELD on the screen.  OFF_BUF holds
	!  escape sequence to turn off attributes.  OFF_LEN - length of that
	!  sequence.
	!-

	    BEGIN
	    CH$MOVE ( .OFF_LEN, OFF_BUF [0], RESTORE_CURSOR [0] ) ;
	    PUT_TOTAL = .OFF_LEN ;			! Total for $PUT so far
	    END ;

	!+
	!  Sequence for reprompting - Backspace, Space, Backspace for each input
	!  character.
	!-

	INDEX = .PUT_TOTAL ;			! PUT_TOTAL = 0 or .OFF_LEN
	INCR P FROM .PUT_TOTAL TO (.PUT_TOTAL+(.CHARS_READ-1)) DO
	    BEGIN
	    RESTORE_CURSOR [.INDEX]   = BS ;		! Backspace
	    RESTORE_CURSOR [.INDEX+1] = BLANK ;		! Space
	    RESTORE_CURSOR [.INDEX+2] = BS ;		! Backspace
	    INDEX = .INDEX + 3 ;
	    END ;
	PUT_TOTAL = .PUT_TOTAL + (.CHARS_READ*3) ;	! Total for $PUT so far

	IF (.PUT_FLAG NEQ 0) AND (.YES_PROTECT  EQL  0)
	THEN

	!+
	!  If no protection set and attributes used - turn them on again.
	!  (after deleting all characters from screen).  ON_BUF holds escape
	!  sequence to turn on attributes.  ON_LEN - length of that sequence.
	!-

	    BEGIN
	    CH$MOVE ( .ON_LEN, ON_BUF [0], RESTORE_CURSOR [.PUT_TOTAL] ) ;
	    PUT_TOTAL = .PUT_TOTAL + .ON_LEN ;		! Total for $PUT
	    END ;

	END ;

    !+
    !  Max for $PUT buffer is 1024 (can be increased by changing the max on
    !  a SYSGEN parameter).  If user input 500 characters the total sequence
    !  for reprompting would be 1500 bytes plus possible sequences for turning
    !  attributes off and on again, therefore perform a $PUT in sets of 1024
    !  until the whole buffer RESTORE_CURSOR has been written to terminal.
    !-

    BEGIN
	LOCAL
	    P_TOT,					! Length of $PUT.
	    LAST_WRITE : INITIAL (0) ;			! = 1 for final $PUT -
							! $PUT less than 1024 bytes
    WHILE .LAST_WRITE EQL 0 DO
	BEGIN
	IF .PUT_TOTAL GTR (COB$K_ACC_SIZE - RMS_HEADER)	!  COB$K_ACC_SIZE = 1024
	THEN
	    BEGIN					! Need multiple $PUTs.
	    P_TOT = COB$K_ACC_SIZE - RMS_HEADER ;	! # to Write to screen this time.
	    PUT_TOTAL = .PUT_TOTAL - .P_TOT ;		! # still to Write.
	    END
	ELSE
	    BEGIN					! Final $PUT
	    P_TOT = .PUT_TOTAL ;
	    LAST_WRITE = 1 ;
	    END ;
	END;

	!+
	!  Clear screen of invalid input
	!-

	COB$$RMS_PUT_BUFFER ( RESTORE_CURSOR [0], .P_TOT, .FLAGS ) ;
    END ;

    !+
    !  Perform another $GET - looking for valid input
    !-

    RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
    COB$$RMS_GET ( .RAB, .FUNC_VAL, .ACC_SIZE, .PUT_HERE [DSC$A_POINTER] ) ;

    REPROMPT_DONE = 1 ;				! Signal that REPROMPT has been
						! done.
    END ;					! End of $ERROR_REPROMPT macro
  % ;

MACRO
    $BIND_PARAMETERS =
    !+
    !  Put data used by many of the subroutines in a vector of data.
    !  BIND all the separate names that can be used to identify the
    !  various elements of the vector.
    !-
    BIND
	PUT_HERE      = PARAMETERS [0]  :  BLOCK [,BYTE],  ! Buffer to hold input	
	NEXT_CHAR     = PARAMETERS [3]  :  VECTOR [,BYTE], ! Buffer used for 
							   ! PROTECTION check
	ACC_SIZE      = PARAMETERS [6]  :  WORD,	   ! Length for RMS $GET
	CHARS_READ    = PARAMETERS [7],		! Number of input characters
	FUNC_VAL      = PARAMETERS [8],		! QIO Function Modifiers used
						! in the item list for RMS $GET
	TERM_SIZE     = PARAMETERS [9],		! Size of terminator
	TERM_LOC      = PARAMETERS [10],	! Location of terminator
	TERM_PTR      = PARAMETERS [11],	! Pointer to terminator in buffer
	TERM_IN_NEXT  = PARAMETERS [12],	! = 1 if terminator in NEXT_CHAR
	TERM_FROM_DEL = PARAMETERS [13],	! Flag from COB$$DELETE_KEY to
						! COB$$ILLEGAL_TERM
	LEGAL	      = PARAMETERS [14],	! = 0 if illegal terminator hit
	YES_PROTECT   = PARAMETERS [15],	! = 1 if PROTECTED requested
	YES_DEFAULT   = PARAMETERS [16],	! = 1 if DEFAULT used as input
	PUT_FLAG      = PARAMETERS [17],	! Flag for turning on attributes
	OFF_BUF	      = PARAMETERS [18]  :  VECTOR [,BYTE], ! Holds esc seq to 
							    ! turn off attributes
	OFF_LEN	      = PARAMETERS [21] ;	! Length of esc seq in OFF_BUF
    % ;
!
!   The following tables convert the UNIT number into a logical name.
!
MACRO
    DESC_(A) = UPLIT BYTE(%ASCIC A) - BASE %;
BIND
    BASE = UPLIT(REP 0 OF (0)),
    COB_TABLE = UPLIT(
	DESC_('COB$INPUT'),
	DESC_('COB$OUTPUT'),
	DESC_('COB$CONSOLE'),
	DESC_('COB$CARDREADER'),
	DESC_('COB$PAPERTAPEREADER'),
	DESC_('COB$LINEPRINTER'),
	DESC_('COB$PAPERTAPEPUNCH')):	VECTOR[NUM_UNITS],
    SYS_TABLE = UPLIT(
	DESC_('SYS$INPUT'),
	DESC_('SYS$OUTPUT'),
	DESC_('SYS$ERROR'),
	DESC_('SYS$INPUT'),
	DESC_('SYS$INPUT'),
	DESC_('SYS$OUTPUT'),
	DESC_('SYS$OUTPUT')):		VECTOR[NUM_UNITS];

!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE

	COB$$CONTROL_KEY,			! Translate terminator
	COB$$ACC_CONVERT,			! Conversion routine
	COB$$OPEN_OUT	:  NOVALUE, 		! Open for output
	LIB$STOP : NOVALUE,			! Signals fatal error
	LIB$GET_VM,				! Get virtual memory
	LIB$FREE_VM,				! Free virtual memory
	STR$GET1_DX,				! Allocate a string
	STR$DUPL_CHAR,				! Duplicate character n times
	STR$FREE1_DX,				! Deallocate a string
	STR$COPY_R,				! Copy a string by ref
	COB$$SETUP_TERM_TYPE,			! Setup terminal type
	COB$$SET_ATTRIBUTES_ONLY ;		! Set bold, reverse, blink,
						! underline
EXTERNAL LITERAL
	COB$_ERRDURACC,				! Error during DISPLAY
	COB$_FAIGET_VM,				! Failure to get VM
	COB$_EOFON_ACC,				! EOF on ACCEPT
	COB$_INVDEFVAL,				! DEFAULT value too large 
	COB$_INVARG ;				! Invalid Argument(s)

EXTERNAL
	COB$$AL_WRITE_RAB	:  VECTOR,	    ! Address of RAB
	COB$$AW_WRITE_IFI	:  VECTOR [,WORD],  ! Internal file identifiers
	COB$$AB_USPCODE		:  VECTOR [,BYTE],  ! Prefix and Post upspacing
	COB$$AB_PREV		:  VECTOR [,BYTE],  ! History of previous call
	COB$ACC_TERM_TYPE,			    ! Terminal type for ACCEPT
	COB$TERM_TYPE;				    ! Terminal type for DISPLAY

%SBTTL 'COB$ACCEPT - Version 1 ACCEPT Statement'
GLOBAL ROUTINE COB$ACCEPT (UNIT, STRING) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Reads a record from specified unit and delivers record to
!	caller's string.
!
! FORMAL PARAMETERS:
!
!	UNIT.rbu.va	Byte integer unit number designating the unit from
!			which the string is to be read, followed by byte
!			flag indicating whether routine should (false) abort,
!			or (true) return status on RMS$_EOF.
!
!	STRING.wt.ds	The address of a fixed-string descriptor to
!			receive the string read.
!
! IMPLICIT INPUTS:
!
!	Status of whether the file in question is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status of the file just used.
!
! ROUTINE VALUE:
!
!	If .UNIT[1] is false:
!	    Unspecified.
!
!	If .UNIT[1] is true:
!	    Either true or false, indicating success or EOF, respectively.
!
! SIDE EFFECTS:
!
!	Reads a record from the designated unit.
!
!--

    BEGIN
    MAP
	UNIT:	VECTOR[,BYTE],
	STRING:	REF BLOCK[8, BYTE];

    LOCAL
	RAB:	REF $RAB_DECL,
	STATUS,
	DESCR:	BLOCK [8, BYTE],
	TERM_SIZE,
	BUFFER:	VECTOR [COB$K_ACC_SIZE, BYTE];

    IF .UNIT[0] GTRU COB$K_UNIT_MAX
    THEN
	LIB$STOP(COB$_INVARG);

    ! If this file is not open, open it.
    ! 0 as second parameter to COB$$OPEN_IN signifies that VAX COBOL is used.
    !
    IF .COB$$AL_WRITE_RAB[.UNIT[0]] EQL 0
    THEN 
	COB$$OPEN_IN(.UNIT[0], 0);

    !  Perform a Linefeed when a Version 1 ACCEPT statement follows a
    !  Version 3 ACCEPT statement with advancing.
    !
    IF .COB$$AB_PREV [0] EQL ACC_ADV
    THEN COB$$RMS_PUT_BYTE ( LINE_FD, 0 ) ;

    ! Read a record into our buffer or caller's buffer, whichever is larger.
    !
    RAB = .COB$$AL_WRITE_RAB[.UNIT[0]];
    IF .STRING[DSC$W_LENGTH] GTRU COB$K_ACC_SIZE
    THEN
	BEGIN
	RAB[RAB$W_USZ] = .STRING[DSC$W_LENGTH];
	RAB[RAB$L_UBF] = .STRING[DSC$A_POINTER];
	END
    ELSE
	BEGIN
	RAB[RAB$W_USZ] = COB$K_ACC_SIZE;
	RAB[RAB$L_UBF] = BUFFER;
	END;

    !+
    !  Turn off RAB [RAB$V_ETO] just in case a 'screen enhancement ACCEPT'
    !  was performed before this one.  COB$$RMS_GET set RAB [RAB$V_ETO]
    !  to signal to RMS to expect an 'extented terminal' $GET.  Here we
    !  only want a simple $GET with no bells and whistles.  If RAB [RAB$V_ETO]	
    !  is not turned off unwanted behavior will result.
    !-

    RAB [RAB$V_ETO] = 0 ;

    ! Read the record.
    !
    WHILE $GET(RAB = .RAB) EQL RMS$_RSA DO $WAIT(RAB = .RAB);


    IF NOT .RAB[RAB$L_STS]
    THEN
	LIB$STOP(
	    (IF .RAB[RAB$L_STS] EQL RMS$_EOF
		THEN
		    IF .UNIT[1]
		    THEN RETURN 0
		    ELSE COB$_EOFON_ACC
		ELSE COB$_ERRDURACC),
	    1, .RAB+RAB$C_BLN, .RAB[RAB$L_STS], .RAB[RAB$L_STV]);

!+
! Check if the terminator size is greater than 1.  If it is,
! this indicates that the terminator string is an escape sequence.
! Return the entire escape sequence in the user's buffer.
!-

    TERM_SIZE = .RAB[RAB$W_STV2];			! Get terminator size

    CH$COPY( (IF .TERM_SIZE GTR 1
	      THEN .RAB[RAB$W_RSZ] + .TERM_SIZE
	      ELSE .RAB[RAB$W_RSZ] ),
	 .RAB[RAB$L_UBF], %C' ', .STRING[DSC$W_LENGTH], .STRING[DSC$A_POINTER]);

    !+
    !  VAX COBOL Version 1 / Version 3 interaction.
    !  Interaction with COB$ACC_SCR - Perform a Carriage Return if necessary
    !  and signal that this is an ACCEPT with advancing.
    !-

    IF .ACC_SCR 
    THEN
	COB$$RMS_PUT_BYTE ( CARR_RET, 0 ) ;
    COB$$AB_PREV[0] = ACC_ADV ;

    RETURN 1;
    END;						! End COB$ACCEPT

%SBTTL 'COB$ACC_SCR - ACCEPT with screen enhancements'
GLOBAL ROUTINE COB$ACC_SCR ( UNIT	  :  VECTOR [2,BYTE],
			     STRING_DEST  :  REF $STR$DESCRIPTOR,
			     FLAGS,
			     DEFAULT	  :  REF $STR$DESCRIPTOR,
			     SIZE,
			     KEY	  :  REF $STR$DESCRIPTOR,
			     LENGTH
			   ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Performs COBOL ACCEPT statement with screen enhancements.
!	Reads a record from a specified UNIT and deposits record in
!	STRING_DEST.
!	A call to COB$POS_ACCEPT is made by the VAX COBOL Compiler
!	prior to the call to COB$ACC_SCR to set cursor position and
!	perform any screen or line erasing.
!
! CALLING SEQUENCE:
!
!	RETURN_STATUS.wlc.v = COB$ACC_SCR ( UNIT.rbu.va, STRING_DEST.mt.ds,
!					    [FLAGS.rlu.v], [DEFAULT.rt.dx],
!					    [SIZE.rlu.v], [KEY.wt.ds],
!					    [LENGTH.wlu.r] )
! FORMAL PARAMETERS:
!
!	UNIT.rbu.va	Array of two unsigned byte integers.
!			The first byte is the unit number designating the
!			device from which the string is to be read.
!			The second byte indicates whether the routine should
!			abort or return to the calling program.
!			  Byte 2 = 0  -  routine will abort on control z
!					 and reprompt on conversion errors.
!				 = 1  -  ( AT END )
!					 routine will return to calling program
!					 on control z and reprompt on conversion
!					 errors.
!				 = 2  -  ( ON EXCEPTION )
!					 routine will return to calling program 
!					 on control z and conversion errors.
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
!	FLAGS.rlu.v	Screen enhancement flag;
!
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blink
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 to allow space for sign in PROTECTED
!					  ACCEPT, 1 no allowance for sign
!				bit 8  -  protect
!				bit 9  -  no-echo
!				bit 10 -  0 advancing, 1 no advancing
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!
!	DEFAULT.rt.dx	Default source moved to destination descriptor
!			(STRING_DEST) in the event of null input.
!
!	SIZE.rlu.v	Size of protected field.  Only applicable if the
!			protected flag is set.
!
!	KEY.wt.ds	Destination of the receiving field of the control key
!
!	LENGTH.wlu.r	Destination of the number of characters read
!
! IMPLICIT INPUTS:
!
!	Status of whether the input file is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status of file
!
! ROUTINE VALUE:
!
!	If .UNIT[1] is false :  Unspecified.
!	If .UNIT[1] is true  :  Either true or false, indicating success or
!				EOF, respectively.
!
! SIDE EFFECTS:
!
!	Reads a record from a designated uint.
!
!--

    BEGIN

    LOCAL
	!+
	!  Note; other declarations are in the macro $BIND_PARAMETERS.
	!-
	RAB		:  REF $RAB_DECL,
	PUT_SIZE	:  WORD,		! ACC_SIZE plus 5 (for escape
						! sequences)
	ON_BUF		:  VECTOR [20,BYTE],	! Holds escape seq to turn on
						! terminal attributes 
	ON_LEN		:  INITIAL (0),		! Length of ON_BUF
	FUNC_VAL_2,				! QIO Function Modifiers used
						! in the item list for RMS $GET
	PROT_OK		:  INITIAL (0),		! = 1 if no Protection errors 
	CONV_OK		:  INITIAL (0),		! = 1 if no Conversion errors
	REPROMPT_DONE	:  INITIAL (0),		! = 1 if reprompt performed in
						! response to a Conversion error
	YES_CONV	:  INITIAL (0),		! = 1 if Conversion requested
	YES_NO_ECHO 	:  INITIAL (0),		! = 1 if No-Echo requested
	YES_SIGN	:  INITIAL (1),		! = 1 if no allowance for sign
						! given. NOTE - initialized to 1
	P_DATA_TYPE	:  INITIAL (0),		! PP99 or 99PP data types
	ZEROES,					! %X'0' filler
	BLANKS,					! %C' ' filler
	PARAMETERS	:  VECTOR [22]		! Buffer to hold data to be
			   INITIAL (REP 22 OF (0)) ; ! passed to subroutines
   BUILTIN
	NULLPARAMETER ;

    LITERAL
	F_PROT_SIZE = 13,			! # of chars allowed for input
	D_PROT_SIZE = 22 ;			! when PROTECTED is requested 
!+						! for floating and double fl.
!  Bind PARAMETERS to other names.
!-
    $BIND_PARAMETERS ;

!+
!  Fillers - used by STR$DUPL_CHAR, therefore they cannot be literals
!-
    ZEROES = %X'0' ;
    BLANKS = %C' ' ; 

!+
!  Put ACCEPTed data from RMS $GET in this buffer.
!-

    PUT_HERE [DSC$W_LENGTH]  = 0 ;
    PUT_HERE [DSC$B_DTYPE]   = DSC$K_DTYPE_NL ;
    PUT_HERE [DSC$B_CLASS]   = DSC$K_CLASS_D ;
    PUT_HERE [DSC$A_POINTER] = 0 ;

!+
!  Determine if PROTECTION has been requested.
!  If so, set the size of the field by either the value of the SIZE parameter
!  or the length field of the STRING_DEST descriptor.  
!  If no PROTECTION requested, use COB$K_ACC_SIZE (1024 - same as
!  V1 Accept).
!  Also make adjustments if both PROTECTION and CONVERSION are requested -
!  add room for sign and a decimal point, in some cases look at DSC$B_DIGITS
!  instead of DSC$W_LENGTH.
!  'P' data types need special handling.
!  Use STR$GET1_DX to allocate space for dynamic string PUT_HERE.
!-

    IF ( .FLAGS AND V_CONV ) NEQ 0 THEN YES_CONV = 1 ; 	   !  Avoid BLISS
    IF ( .FLAGS AND V_NO_SIGN ) NEQ 0 THEN YES_SIGN = 0 ;  !  optimization problems

    IF ( .FLAGS AND V_PROTECT ) NEQ 0
    THEN
	BEGIN						! Begin Protect Size
	YES_PROTECT = 1 ;
	IF .SIZE NEQ 0
	THEN ACC_SIZE = .SIZE				! Use SIZE
	ELSE
	    BEGIN					! Begin no SIZE param
		LOCAL
		    pp99  :  initial (0) ;		! Scale for PP99 data
							! type

	    pp99 = .string_dest [dsc$b_digits] + .string_dest [dsc$b_scale] ;
	    ACC_SIZE = .STRING_DEST [DSC$W_LENGTH] ;	! Use STRING_DEST

!+
!  Special case "P" data types (each "P" specifies an assumed scaling position).
!  NOTE:  All code pertaining to the "P" data type is in lowercase.  Since "P"
!  data types are such an off the wall issue, leaving this code in lowercase is
!  the best way to avoid "P" code interfering with "normal" data types.
!-
	    if ((.string_dest [dsc$b_class] eql dsc$k_class_sd )
	        and  ((.pp99 lss 0)			! P Picture of PP99
		or (.string_dest[dsc$b_scale] gtr 0)))	! P Picture of 99PP.
	    then
		begin					! begin P data types
		p_data_type = 1 ;
		if .pp99 lss 0				! P Picture of PP99
		then
		    acc_size = abs (.string_dest[dsc$b_scale])
		else
		    acc_size = .pp99 ;

		if .yes_conv
		then
		    begin
		    !+
		    !  Allow space for a decimal point for PP99 but not 99pp.
		    !-
		    if .pp99 lss 0
		    then
			acc_size = .acc_size + 1 ;	! decimal point for pp99
	
		    !+
		    !  Because we are reading the digits and scale fields,
		    !  all numeric data types will need an extra space for
		    !  the sign - except Numeric Unsigned.
		    !-
			
		    if .string_dest [dsc$b_dtype] neq dsc$k_dtype_nu
		    then
		        acc_size = .acc_size + 1 ;
		    !+
		    !  Additional check for VAX_11 COBOL COMP and COMP3
		    !  data types - if YES_SIGN = 0 then do not include
		    !  space for sign.
		    !-
		    if (((.string_dest [dsc$b_dtype] eql dsc$k_dtype_w  ) or
	        	 (.string_dest [dsc$b_dtype] eql dsc$k_dtype_wu ) or
	        	 (.string_dest [dsc$b_dtype] eql dsc$k_dtype_l  ) or
	        	 (.string_dest [dsc$b_dtype] eql dsc$k_dtype_lu ) or
	        	 (.string_dest [dsc$b_dtype] eql dsc$k_dtype_q  ) or
	        	 (.string_dest [dsc$b_dtype] eql dsc$k_dtype_qu ) or
			 (.string_dest [dsc$b_dtype] eql dsc$k_dtype_p ))
							 and .yes_sign eql 0 )
		    then
		        acc_size = .acc_size - 1 ;
		    end ;
	 	end	 				! end P data types

	    else
		!+
		!  Non P data type
		!-
		begin					! Begin non P data type
	        IF .YES_CONV    			! Adjust ACC_SIZE
	        THEN
	            !+
	    	    !  Make room for overpunch sign.
		    !  Packed data type - check to see if sign should be
		    !  included. 
		    !-
		    BEGIN
		    IF ((.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_NRO ) OR
		        (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_NLO ) OR
		        (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_P  AND 
							.YES_SIGN ))
		    THEN
			ACC_SIZE = .ACC_SIZE + 1 ;

		     !+
		     ! COMP - look at digits field plus one for sign, only if
		     ! conversion is requested.
		     ! VAX_COBOL always sends an SD descriptor for W, L, Q when
		     ! Conversion is used.
		     ! Check to see if sign should be included.
		     !-

		    IF (.STRING_DEST [DSC$B_CLASS] EQL DSC$K_CLASS_SD )
		    THEN
			IF (((.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_W  ) OR
	        	     (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_WU ) OR
	        	     (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_L  ) OR
	        	     (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_LU ) OR
	        	     (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_Q  ) OR
	        	     (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_QU ))
							 AND .YES_SIGN )
	    		THEN
			    ACC_SIZE = .STRING_DEST [DSC$B_DIGITS] + 1 ;

		    !+
		    ! Floating pt - 13 for Floating, 22 for Double Floating.
		    !-

		    IF (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_F )
		    THEN
			ACC_SIZE = F_PROT_SIZE ;
		    IF (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_D )
	    	    THEN
			ACC_SIZE = D_PROT_SIZE ;

		    !+
		    !  Make room for decimal point
		    !-

		    IF (.STRING_DEST [DSC$B_CLASS] EQL DSC$K_CLASS_SD )
		    THEN
			ACC_SIZE = .ACC_SIZE + 1 ;
	    	    END ;
		end ;					! End non P data type
	    END ;					! End no SIZE param
	END						! End Protect Size
    ELSE
	ACC_SIZE = COB$K_ACC_SIZE - RMS_HEADER ;	! 1024 - 14 is same
							! limit as a DISPLAY
!+
!  Allocate enough room in PUT_HERE to hold the terminator escape sequences.
!  Most sequences are 4 bytes or less.  (PUT_SIZE is 5 more than ACC_SIZE.)
!  Note: PUT_SIZE used, not ACC_SIZE.
!-

    PUT_SIZE = .ACC_SIZE ;
    IF .ACC_SIZE LSS 920 THEN PUT_SIZE = .ACC_SIZE + 5 ;
	
    IF NOT ( STR$GET1_DX ( %REF (.PUT_SIZE ), PUT_HERE ))
    THEN LIB$STOP ( COB$_ERRDURACC ) ;

!+
!  Check first byte of UNIT param.
!  If this file is not open, open it.  (Note: only first byte of UNIT is
!					      sent to COB$$OPEN_IN)
!-

    IF .UNIT[0] GTRU COB$K_UNIT_MAX
    THEN
	LIB$STOP ( COB$_INVARG ) ;

    IF .COB$$AL_WRITE_RAB [ .UNIT[0] ] EQL 0
    THEN 
	!+
	!  Second parameter tells COB$$OPEN_IN whether VAX COBOL (0)
	!  or VAX RPG (1) is the caller.
	!-
	COB$$OPEN_IN ( .UNIT[0],
			IF ( .FLAGS AND V_COB_RPG ) NEQ 0
			THEN 1
			ELSE 0 ) ;

    RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;

!+
!  Find out if the device is a terminal.
!-

    BEGIN
	LOCAL
	    STATUS,
	    NAM_DSC  :  REF BLOCK [8,BYTE] ;

    NAM_DSC = .RAB + RAB$C_BLN ;

    IF .COB$ACC_TERM_TYPE EQL 0
    THEN
	IF NOT ( COB$$SETUP_TERM_TYPE ( .NAM_DSC [DSC$A_POINTER], 
				        .NAM_DSC [DSC$W_LENGTH], 
			                COB$ACC_TERM_TYPE ) )
	THEN LIB$STOP ( COB$_ERRDURACC ) ;

    IF .COB$ACC_TERM_TYPE EQL UNKNOWN
    THEN
	!+
	!  If terminal is UNKNOWN then it can be assumed we are working 
	!  with files rather than terminals.  Pull out of this routine
	!  and go to COB$$ACC_SCR_FILE which uses a slightly different
	!  variation of the RMS $GET Service.
	!-
	BEGIN
	STATUS = COB$$ACC_SCR_FILE ( .UNIT, .STRING_DEST, .FLAGS, .DEFAULT,
					.LENGTH, .ACC_SIZE, PUT_HERE, .YES_CONV,
					.YES_PROTECT, .YES_SIGN ) ;
	!+
	!  Free local string PUT_HERE
	!-
	IF NOT ( STR$FREE1_DX ( PUT_HERE ))
	THEN LIB$STOP ( COB$_ERRDURACC ) ;

	IF (NOT .STATUS)
	THEN
	    RETURN 0
	ELSE
	    RETURN 1 ;
	END ;

    END ;

    !+
    !  Flag to COB$ACCEPT that COB$ACC_SCR has been called.  COB$ACCEPT will
    !  have to perform a Carriage Return.
    !-

    ACC_SCR = 1 ;

    BEGIN						!  Begin $GET

!+
!  VAX COBOL Version 1 / Version 3 Interaction.
!  Advancing philosophy : <LF>   $GET   <CR>
!  <LF> based on previous call.
!  <CR> based on current ACCEPT using FLAGS bit 10.
!  If previous call requires advancing then perform a linefeed.  DISPLAY (DISP)
!  and ACCEPT (ACC_ADV) with advancing.  POS = call to module COB$POS_ERASE
!  remembers what previous call was, if advancing then POS, if no advancing
!  then POS_DNA 
!-

    IF (.COB$$AB_PREV[0] EQL DISP
	OR  .COB$$AB_PREV[0] EQL POS
	OR  .COB$$AB_PREV[0] EQL ACC_ADV )
    THEN
	!+
	!  Echo linefeed to terminal
	!-
	COB$$RMS_PUT_BYTE ( LINE_FD, .FLAGS ) ;

!+
!  Did user request any terminal attributes (bold, blink, underline, reverse) ?
!  If so, call COB$$SET_ATTRIBUTES_ONLY to get escape sequence to turn
!  attributes on and off.
!  PUT_FLAG - first four bits (0-3) of FLAGS parameter.
!-

    PUT_FLAG = .FLAGS  AND  FLAG_MASK ;

    IF .PUT_FLAG NEQ 0
    THEN
	IF NOT ( COB$$SET_ATTRIBUTES_ONLY ( .COB$ACC_TERM_TYPE, .PUT_FLAG,
					    ON_BUF [0], ON_LEN,
					    OFF_BUF [0], OFF_LEN ) )
	THEN LIB$STOP ( COB$_ERRDURACC ) ;

!+
!  If requested, add sequence to ON_BUF to ring terminal bell.
!-

    IF ( .FLAGS AND V_BELL ) NEQ 0
    THEN
	BEGIN
	ON_BUF [ .ON_LEN ] = BELL ;
	ON_LEN = .ON_LEN + 1 ;
	END ;

!+
!  Check parameters to see if the CONTROL KEY FORMAT 4 ACCEPT has been 
!  requested.  If so, pull out of this routine and call COB$$FORMAT_FOUR
!  which uses a different Terminator Mask and does not need all the 
!  enhancements in COB$ACC_SCR.
!-

	IF NOT NULLPARAMETER (KEY)
	THEN
	    BEGIN
		LOCAL
		    KEY_LEN ;
		
	    KEY_LEN = .KEY [DSC$W_LENGTH] ;	
	    STR$DUPL_CHAR ( .KEY, KEY_LEN, BLANKS ) ;
	    	
	    !+
	    !  If these parameters are not present then we are dealing with
	    !  a Format Four ACCEPT rather than a Format Three ACCEPT.
	    !-

	    IF (NULLPARAMETER (LENGTH)  AND
		NULLPARAMETER (SIZE)    AND
		NULLPARAMETER (DEFAULT) AND
		NULLPARAMETER (STRING_DEST) )
	    THEN
		IF NOT ( COB$$FORMAT_FOUR ( .UNIT, .FLAGS, .KEY ))
		THEN RETURN 0
		ELSE RETURN 1 ;
	    END ;

!+
!  Determine FUNC_VAL - QIO Function Modifiers used by RMS $GET Service.
!  Check FLAGS parameter to see if NO-ECHO was requested (bit 9), if so
!  set TRM$M_TM_NOECHO to suppress echoing of input characters to the terminal.
!  Set TRM$M_TM_ESCAPE to allow Escape Sequences to act as terminators (Arrow
!  keys, PF keys, and the Professional editing and top row function keys).
!  Set TRM$M_TM_NOFILTR to have the DELETE KEY handled by COB$$DELETE_KEY.
!  Set TRM$M_TM_TRMNOECHO to suppress echoing of the termination character
!  (COB$$AB_PREV handles advancing / no advancing).
!-

    IF ( .FLAGS AND V_NO_ECHO ) NEQ 0
    THEN
	BEGIN
	FUNC_VAL = TRM$M_TM_ESCAPE + TRM$M_TM_NOFILTR + TRM$M_TM_TRMNOECHO 
						      + TRM$M_TM_NOECHO ;
	YES_NO_ECHO = 1 ;
	END
    ELSE
	FUNC_VAL = TRM$M_TM_ESCAPE + TRM$M_TM_NOFILTR + TRM$M_TM_TRMNOECHO ;

!+
!  Main Loop of routine.
!  PROT_OK = 1 -> there was no Protection error  "plus" 
!  CONV_OK = 1 -> there was no Conversion error  "equal"  SUCCESS -> pull out
!  of loop.  Otherwise continue accepting data until there are no errors.
!  If error, reprompt user for more input via macro $ERROR_REPROMPT.
!-

    WHILE (.PROT_OK EQL 0)  OR  (.CONV_OK EQL 0) DO
	BEGIN						! Begin loop
	    LOCAL
		TERM_SEEN  :  INITIAL (0) ;		! Flag for PROTECT check

	IF .REPROMPT_DONE EQL 0
	THEN
	    BEGIN					! Begin no reprompt

	    !+
	    !  If PROTECTION requested, put a Protected Field on the screen.
	    !  $PUT ACC_SIZE blanks to screen with attributes requested
	    !  by user turned on.  (Escape sequences geared to VT100
	    !  terminals)  Can only set a one line field as a max, therefore
	    !  FIELD_BUF holds up to 300 characters.
	    !-

	    IF .COB$ACC_TERM_TYPE EQL VT100
 	    THEN
		BEGIN					! Begin VT100
	        IF .YES_PROTECT
		THEN
		    BEGIN				! Begin Field
		    LOCAL
			FIELD_BUF	:  VECTOR [300, BYTE],
			FIELD_LEN ;			! size of FIELD_BUF

		    !+
		    !  Buffer FIELD_BUF to write Protected Field contains
		    !		- escape sequence to turn attributes on,
		    ! 		- number of blanks to write to screen and 
		    !		- backspaces (same # as blanks) to put cursor
		    !		  back to original position.
		    !-
	
		    CH$MOVE ( .ON_LEN, ON_BUF [0], FIELD_BUF [0] ) ;
		    FIELD_LEN = .ON_LEN ;
		    CH$FILL ( BLANK, .ACC_SIZE, FIELD_BUF [.FIELD_LEN] ) ;
		    FIELD_LEN = .FIELD_LEN + .ACC_SIZE ;
		    CH$FILL ( BS, .ACC_SIZE, FIELD_BUF [.FIELD_LEN] ) ;
		    FIELD_LEN = .FIELD_LEN + .ACC_SIZE ;

		    !+
		    !  If size of FIELD_BUF is greater than the size of the
		    !  maximum allowed for a $PUT buffer, issue an error 
		    !  message.  Issuing multiple $PUTs at this point does
		    !  not help as the cursor is unable to get back to the
		    !  starting position and ends up in the wrong line.
		    !_

		    IF .FIELD_LEN GTR (COB$K_ACC_SIZE - RMS_HEADER) ! 1024 -14
		    THEN
			LIB$STOP ( COB$_ERRDURACC ) ;

		    !+
		    !  $PUT to write Protected Field to terminal
		    !-

		    COB$$RMS_PUT_BUFFER ( FIELD_BUF [0], .FIELD_LEN, .FLAGS ) ;

		    END ;				! End Field
		END ;					! End VT100

!*****
!*****	RMS $GET Service
!*****

	    !+
	    !  RMS $PUT to turn on terminal attributes (blink,bold,underline,reverse).
	    !  RMS $GET to accept input.  Do not perform the $PUT if PROTECTED
	    !  is requested as the FIELD_BUF $PUT has already turned attributes
	    !  on.
	    !  Note :  TRM$_PROMPT not used because of buffer size limitations.
	    !    TRM$_MODIFIERS uses all of specified buffer for accepting input,
	    !    TRM$_PROMPT uses same buffer for both the prompt string and the
	    !    accepted data, therefore some space for accepting data is lost. 
	    !-

	    IF .ON_LEN NEQ 0 AND .YES_PROTECT NEQ 1	! If requested, turn
	    THEN					! attributes on
		COB$$RMS_PUT_BUFFER ( ON_BUF [0], .ON_LEN, .FLAGS ) ;

	    !+	
	    !  RMS $GET to accept input from terminal.
	    !-

	    RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
	    COB$$RMS_GET ( .RAB, .FUNC_VAL, .ACC_SIZE,
						.PUT_HERE [DSC$A_POINTER] ) ;

	    END						!  End of no reprompt
	ELSE
	    REPROMPT_DONE = 0 ;				! re-set flag

	!+
	!  Get number of characters read and terminator size from the fields
	!  of the RAB.  Pass this info along to other routines.
	!  RAB fields -
	!	rab [rab$l_sts]	       = status
	!	rab [rab$l_rsz]	       = x	no. of chars read
	!	rab [cob$$b_stv0_term] = d 	<cr> terminator seen
	!	rab [cob$$b_stv2_len]  = 1 	size of terminator
	!  Save this information before COB$$PARTIAL_SEQ does any more $GETs.
	!-

	CHARS_READ = .RAB [RAB$W_RSZ] ;			! Number of chars read
	TERM_SIZE  = .RAB [COB$$B_STV2_LEN] ;		! Size and location of
	TERM_LOC   = .RAB [COB$$B_STV0_TERM] ;		! terminator - other
							! routines may update
							! these
	!+
	!  Check for partial sequence error - not enough room in input buffer
	!  to hold entire escape sequence when a Protected ACCEPT is performed.
	!  If necessary, call COB$$PARTIAL_SEQ to read remainder of sequence.
	!-

	IF .RAB [RAB$L_STS] EQL RMS$_PES
	THEN
	    BEGIN
	    TERM_SEEN = 1 ;				! Set flag here as
	    COB$$PARTIAL_SEQ ( PARAMETERS, .UNIT ) ;	! COB$$PARTIAL_SEQ may
	    END ;					! change status value

	!+
	!  If terminator was the DELETE KEY call COB$$DELETE_KEY.
	!-

	IF .RAB [COB$$B_STV0_TERM] EQL DEL_KEY 
	THEN
	    COB$$DELETE_KEY ( PARAMETERS, .UNIT, .FLAGS ) ;

!*******
!******* PROTECTED
!*******

	!+
	!  Was terminator seen on PROTECTED READ?    
	!
	!  Looking for terminator to make sure that user hasn't tried to go
	!  beyond the bounds of a PROTECTED READ.
	!
	!  Two ways for a protected read to complete -
	!	1. terminator typed before buffer filled ( no further check necessary)
	!	2. buffer fill ( no terminator seen)
	!		- do a one character read to make sure terminator is
	!			typed, not another character.
	!
	!  The following RAB fields look like this if buffer filled
	!		rab [rab$l_sts]	       = status
	!		rab [rab$l_rsz]        = x	no. of chars read (acc_size)
	!		rab [cob$$b_stv0_term] = 0	no terminator seen
	!		rab [cob$$b_stv2_len]  = 0	size of terminator
	!_

	IF (.YES_PROTECT )				! Was PROTECTION requested?
		AND  ( .CHARS_READ NEQ 0 ) 		! AND is it needed 
	THEN
	IF .RAB [RAB$L_STS] EQL RMS$_TNS		! RMS$_TNS = Terminator 
				AND .TERM_SEEN EQL 0	! Not Seen
	    THEN
		BEGIN					! Begin protect check $GET
		!+
		!  After initial $GET is performed it is necessary to perform a
		!  $GET of length 1 to make sure that there are no characters 
		!  typed by the user that exceed the maximum allowed.
		!  (Do not echo character to terminal.)
		!  If the $GET of one character results in a terminator, there
		!  is no problem.
		!  If the $GET of one character results in an attempt to type
		!  extra characters, there is an error.
		!
		!  If VAX RPG is the caller, always return control to the
		!  calling program on an error.
		!-

		LOCAL
		    NO_CHAR    :  INITIAL (0),		! =1 no Protection error
		    HAVE_TERM  :  INITIAL (0) ;		! =1 terminator seen

		WHILE .HAVE_TERM NEQ 1 DO
		    BEGIN				! Begin HAVE_TERM loop

		    NO_CHAR = 0 ;
		    FUNC_VAL_2 = TRM$M_TM_ESCAPE + TRM$M_TM_NOFILTR 
					+ TRM$M_TM_TRMNOECHO + TRM$M_TM_NOECHO ;

		    RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
		    COB$$RMS_GET ( .RAB, .FUNC_VAL_2, 1, NEXT_CHAR ) ;

		    !+
		    !  If user did not attempt to enter more data, set TERM_SIZE
		    !  and TERM_IN_NEXT before possible call to COB$$PARTIAL_SEQ.
		    !  If not enough room in $GET buffer to hold entire escape
		    !  sequence then call COB$$PARTIAL_SEQ to read remainder
		    !  of sequence.
		    !-
	
		    IF .RAB [RAB$W_RSZ] EQL 0		 ! No more data entered.
		    THEN
			BEGIN
			NO_CHAR = 1 ;			 ! Move terminator into
			NEXT_CHAR [0] = .RAB [COB$$B_STV0_TERM] ; ! NEXT_CHAR
			END ;
		    TERM_SIZE = .RAB [COB$$B_STV2_LEN] ; ! Terminator size.
		    TERM_LOC  = .RAB [COB$$B_STV0_TERM]; ! Terminator location.
		    TERM_IN_NEXT = 1 ;			 ! Terminator on NEXT_CHAR
		    IF .RAB [RAB$L_STS] EQL RMS$_PES
		    THEN
			COB$$PARTIAL_SEQ ( PARAMETERS, .UNIT ) ;

		    !+
		    !  Terminators are the only acceptable input at this point.
		    !  If NO_CHAR = 1 then there is no Protection error.
		    !-

		    IF .NO_CHAR
		    THEN
			BEGIN				! Begin TERM accepted
			PROT_OK      = 1 ;		! $GET successful
			HAVE_TERM    = 1 ;

!******
!****** DELETE KEY
!******
	        	!+
			!  Was termintor the DELETE KEY ?  If so, call
	        	!  COB$$DELETE_KEY to erase the last character
			!  read and to continue reading for input.
	        	!-

		        IF .RAB [COB$$B_STV0_TERM] EQL DEL_KEY 
			THEN
			    BEGIN
			    COB$$DELETE_KEY ( PARAMETERS, .UNIT, .FLAGS ) ;
			    !+
			    !  Check to see if we fell out of COB$$DELETE_KEY
			    !  without a valid terminator.  If so, keep
			    !  looking for it.
			    !-
			    IF .TERM_SIZE EQL 0
			    THEN
				BEGIN
				HAVE_TERM = 0 ;		! Loop again
				PROT_OK = 0 ;
				END
			    ELSE
				BEGIN
				HAVE_TERM = 1 ;
				TERM_IN_NEXT = 0 ;	! Note - COB$$DELETE_KEY put
				END ;			! the terminator in
			   				! PUT_HERE.
			    END ;

			END				! End TERM accepted
		    ELSE

!*******
!******* PROTECTION ERROR
!*******

		    !+			
		    !  PROTECTION error :
		    !  User tried to input too many characters,
		    !	  - sound terminal bell,
		    !	  - leave cursor where it is (No reprompt or backspace).
		    !-

			BEGIN
			COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;
			PROT_OK = 0 ;			! Signal Protection error
			HAVE_TERM = 0 ;
			END
	
		    END ;				! End HAVE_TERM loop
		END					! End protect check $GET
	    ELSE
		!+
		! Protection requested but terminator already seen,
		! no need for 1 character Read.
		!-
		PROT_OK = 1
	ELSE
	    !+
	    ! Protection not requested, no need for 1 character Read.
	    !-
	    PROT_OK = 1 ;

!*******
!******* CONTROL KEY
!*******

    IF .PROT_OK
    THEN
	!+
	! No sense going thru Control Key code if there was a protection error.
	!-
	BEGIN						! Begin Control Key

	    IF .TERM_IN_NEXT				! Locate terminator,
	    THEN					! which buffer is it in.
		TERM_PTR = NEXT_CHAR[0]
	    ELSE
		TERM_PTR = .PUT_HERE[DSC$A_POINTER] + .CHARS_READ ;

	    !+
	    !  If parameter KEY not sent (.KEY = 0) then CR, TAB, CONTROL Z,
	    !  and DELETE KEY are the only legal terminators.
	    !
	    !  If parameter KEY not 0 then CR, TAB, CONTROL Z, DELETE KEY, PF,
	    !  ARROW and SPECIAL FUNCTION PROFESSIONAL Keys are legal 
	    !  terminators.  Copy terminator to KEY parameter.
	    !
	    !  Special treatment needed for CONTROL Z under RMS.  There is a
	    !  difference between ^Z being typed alone and with data.
	    !  When ^Z is typed with data the ^Z is stored in 
	    !  RAB[RAB$_STV0_TERM], but when ^Z is typed alone the status
	    !  RMS$_EOF is returned from the $Get Service.
	    !-

	    IF .TERM_SIZE EQL 1				! One byte terminator
	    THEN
		BEGIN
		TERM_PTR = RAB [COB$$B_STV0_TERM] ;
		SELECTONE .RAB [COB$$B_STV0_TERM] OF
		    SET
			[ CR,	 			! Carriage Return
			  TAB ] :			! Tab
			    !+
			    !  These keys are legal, do nothing if KEY = 0.
			    !-
			    IF NOT NULLPARAMETER (KEY)
			    THEN
				CH$MOVE ( 1, .TERM_PTR, .KEY [DSC$A_POINTER] ) ;

			[ CZ ] :			! Control z

			    !+
			    !  CONTROL Z hit along with data  ( terminator in
			    !  RAB [COB$$B_STV0_TERM] )
			    !-

			    BEGIN
			    IF (.FLAGS AND V_COB_RPG) NEQ 0
			    THEN		
				BEGIN
				!+
				! VAX RPG - Control Z is an illegal terminator.
				!-
				LEGAL = 0 ;
				COB$$ILLEGAL_TERM ( PARAMETERS, .UNIT, .FLAGS,
									.KEY ) ;
				END
			    ELSE
				BEGIN
				!+
				! VAX COBOL - Control Z has special meaning.
				!-
				COB$$CLEAN_UP ( PARAMETERS, .FLAGS ) ;
				COB$$CONTROL_Z ( .UNIT, .KEY ) ;
				RETURN 0 ;
				END ;
			    END ;

			[ DEL_KEY ] :			! Delete key

			    BEGIN
			    COB$$DELETE_KEY ( PARAMETERS, .UNIT, .FLAGS ) ;
			    END ;

			[OTHERWISE] :			! Error - key not a
							! terminator
				BEGIN
				LEGAL = 0 ;
				COB$$ILLEGAL_TERM ( PARAMETERS, .UNIT, .FLAGS,
									.KEY ) ;
				END ;
		    TES ;
 		END

	    ELSE
		IF .CHARS_READ EQL 0  AND  .RAB [RAB$L_STS] EQL RMS$_EOF
		THEN
		    BEGIN
		    !+
		    !  CONTROL Z hit alone - terminator not placed in 
		    !  RAB [COB$$B_STV0_TERM], but signaled via RAB [RAB$L_STS].
		    !-
		    IF (.FLAGS AND V_COB_RPG) NEQ 0
		    THEN		
			BEGIN
			LEGAL = 0 ;			! VAX RPG - Control Z
			COB$$ILLEGAL_TERM ( PARAMETERS, .UNIT, .FLAGS, .KEY ) ;
			END
		    ELSE
			BEGIN				! VAX COBOL
			COB$$CLEAN_UP ( PARAMETERS, .FLAGS ) ;
			COB$$CONTROL_Z ( .UNIT, .KEY ) ;
			RETURN 0 ;
			END ;
		    END
		ELSE
		    BEGIN

		    !+
		    !  Escape Sequence as Terminator.  .TERM_SIZE greater
		    !  than 1 and RMS_$EOF not signaled.
		    !- 

		    IF NOT NULLPARAMETER (KEY)
		    THEN
		        !+
		        !  COB$$CONTROL_KEY converts terminator sequences to 
		        !  COBOL defined sequences and fills in KEY parameter
		        !  if terminator is legal.
		        !- 
		        BEGIN
		        IF NOT ( COB$$CONTROL_KEY (TERM_PTR, .TERM_SIZE, .KEY) )
		        THEN
		    	    BEGIN
			    LEGAL = 0 ;			! Illegal escape sequence
	    		    COB$$ILLEGAL_TERM ( PARAMETERS, .UNIT, .FLAGS,
									.KEY ) ;
			    END ;
		        END
		    ELSE
		        !+
		        !  Terminator of size greater than 1 is illegal when KEY is
		        !  not used.
		        !-
		        BEGIN
		        LEGAL = 0 ;
		        COB$$ILLEGAL_TERM ( PARAMETERS, .UNIT, .FLAGS, .KEY ) ;
		        END ;
		    END ;
	END ;						! End Control Key

!*******
!******* NULL INPUT
!*******

	!+
	!  Null input
	!  RAB fields look like this for null input
	!		rab [rab$l_sts]	       = 1 	status
	!		rab [rab$l_rsz]        = 0 	no. of chars read
	!		rab [cob$$b_stv0_term] = d 	<cr> terminator seen
	!		rab [cob$$b_stv2_len]  = 1 	size of terminator
	!
	!  Check for DEFAULT parameter - if present prepare to put it through
	!  Conversion routines by placing DEFAULT in PUT_HERE.
	!-

	IF ( .CHARS_READ EQL 0 ) AND (( .FLAGS AND V_COB_RPG ) NEQ 0 )
	THEN
	   !+
	   !  In case of null input for RPG, simply return (no DEFAULT).
	   !  But perform any necessary clean up first.
	   !-
	    BEGIN
	    COB$$RPG_CLEAN_UP ( .FLAGS ) ;
	    RETURN 1 ;
	    END ;

	IF ( .CHARS_READ EQL 0 )
	THEN
	    IF NOT NULLPARAMETER (DEFAULT)  AND  (.YES_DEFAULT EQL 0)
	    THEN
		BEGIN					! Begin DEFAULT
		
		CHARS_READ = .DEFAULT [DSC$W_LENGTH];
		YES_DEFAULT = 1 ;

		!+
		!  Protection check for DEFAULT excluding the Floating
		!  Point data types ( these will be handled in routine 
		!  COB$$VERIFY_FL_RANGE ).
		!-

		IF (.YES_PROTECT AND
			    ( .STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_F AND
			      .STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_D ))
		THEN
		    !+
		    !  If the length of DEFAULT is greater than the expected 
		    !  input size ACC_SIZE, then there is a Protection error.
		    !  This should be caught at compile time by VAX COBOL and
		    !  a fatal error message issued, however there is one case
		    !  that the compiler cannot catch, therefore issue a fatal
		    !  run time error here.
		    !-
		    IF (.DEFAULT [DSC$W_LENGTH] GTR .ACC_SIZE)
		    THEN
			LIB$STOP ( COB$_INVDEFVAL )
		    ELSE
			PROT_OK = 1			! No PROTECT error
		ELSE
		    PROT_OK = 1 ;			! No PROTECT error

		END ;					! End DEFAULT

!*******
!******* CONVERSION
!******* ALL RMS $GETs COMPLETED EXCEPT POSSIBLE REPROMPT ON A CONVERSION ERROR.
!*******

!+
!  If conversion requested, call routine COB$$ACC_CONVERT
!-

	IF ( .PROT_OK ) 				! If protection error,
	THEN						! don't go thru conversion
	    IF ( .YES_CONV )
	    THEN
		CONV_OK = COB$$ACC_CONVERT ( .STRING_DEST, .FLAGS,
						.DEFAULT, PUT_HERE, .CHARS_READ,
						.YES_DEFAULT, .YES_SIGN )
	    ELSE
		BEGIN
		    LOCAL
			COPY_NUM ;
		!+
		!  No conversion requested - copy input data to STRING_DEST.
		!  Use STR$COPY_R because it BLANK fills.
		!-

		    IF .CHARS_READ LSS .STRING_DEST[DSC$W_LENGTH]
		    THEN
			COPY_NUM = .CHARS_READ
		    ELSE
			COPY_NUM = .STRING_DEST[DSC$W_LENGTH] ;

		    STR$COPY_R ( .STRING_DEST, COPY_NUM,
					(IF .YES_DEFAULT
					THEN .DEFAULT [DSC$A_POINTER]
					ELSE .PUT_HERE [DSC$A_POINTER] )) ;


		    CONV_OK = 1 ;			! set CONV_OK to success
		END;

	    !+
	    !  Conversion completed - was it successful ?
	    !-

	    IF .CONV_OK EQL 0
	    THEN
	    !+
	    !  CONVERSION error.  Read UNIT parameter to determine what
	    !  to do.
	    !
	    !	  Byte 2 of	  		Conversion
	    !	    UNIT			  error
	    !
	    !        0		  		  reprompt
	    !	     1 ( at end ) 		  reprompt
	    !	     2 ( on exception ) 	  return
	    !-
	    BEGIN					! Begin conversion error
		IF ( .FLAGS AND V_COB_RPG ) NEQ 0
		THEN
		    !+
		    !  VAX RPG - return on a Conversion Error, ring bell
		    !  and clean up before exiting.
		    !-
		    BEGIN
		    COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;
		    COB$$RPG_CLEAN_UP ( .FLAGS ) ;
		    RETURN 0 ;
		    END ;

		IF .UNIT [1] EQL 2
		THEN
		    BEGIN
		    !+
		    !  Clean up before returning control to VAX COBOL.
		    !-
		    COB$$CLEAN_UP ( PARAMETERS, .FLAGS ) ;
		    RETURN 0 ;
		    END
		ELSE
		    !+
		    !  Reprompt
		    !	  - sound terminal bell,
		    !	  - clear screen of all typed characters,
		    !	  - reset cursor to original line/column position
		    !-
		    BEGIN
		    IF ((.FLAGS AND V_NO_ECHO) NEQ 0 )  OR  (.YES_DEFAULT )
		    THEN
			BEGIN				! No re-positioning
			COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;  ! necessary
			END
		    ELSE
			BEGIN
			$ERROR_REPROMPT ;		! Re-position
			END ;
		    CONV_OK = 0 ;			! Signal Conversion error
		    YES_DEFAULT = 0 ;
		    END ;
	    END						! End conversion error

	ELSE
	    !+
	    !  Conversion not done either because Protection failed (PROT_OK=0)
	    !  or there was no data to convert
	    !-
	    CONV_OK = 1 ;

    END ;						! End loop

	!+
	!  RMS $GET complete - fill in optional LENGTH parameter with the
	!  number of characters read.
	!-

	IF NOT NULLPARAMETER (LENGTH)
	THEN
	    .LENGTH = .CHARS_READ ;

!*******
!******* CLEAN UP
!*******

!+
!  Call COB$$CLEAN_UP to perform (if needed) cursor positioning,
!  turn off terminal attributes, and advancing.
!-

    COB$$CLEAN_UP ( PARAMETERS, .FLAGS ) ;

    END;						!  End $GET

!+
!  Free local strings PUT_HERE
!-

    IF NOT ( STR$FREE1_DX ( PUT_HERE ))
    THEN LIB$STOP ( COB$_ERRDURACC ) ;


    RETURN 1;
    END;					! end of routine COB$ACC_SCR

%SBTTL 'COB$ACC_SCR_FILE - Screen enhancements for files'
ROUTINE COB$$ACC_SCR_FILE ( UNIT	 :  VECTOR [2,BYTE],
			    STRING_DEST  :  REF $STR$DESCRIPTOR,
			    FLAGS,
			    DEFAULT	 :  REF $STR$DESCRIPTOR,
			    LENGTH,
			    ACC_SIZE,
			    PUT_HERE     :  REF BLOCK [8, BYTE],
						! Contains input characters
			    YES_CONV,		! =1 if conversion requested
			    YES_PROTECT,	! =1 if protection requested
			    YES_SIGN		! =1 if sign should be included
			   ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles the VAX COBOL Version 3 ACCEPT statement
!	with Screen Enhancements when a file (not a terminal) is used
!	for input.  A non terminal $GET service does not contain all the
!	features of a terminal $GET service, so this routine is a scaled
!	down version of COB$ACC_SCR.  Note that the fields RAB [RAB$V_ETO]
!	and RAB [RAB$L_XAB] are not set.
!
! FORMAL PARAMETERS:
!
!	UNIT.rbu.va	Array of two unsigned byte integers.
!			The first byte is the unit number designating the
!			device from which the string is to be read.
!			The second byte indicates whether the routine should
!			abort or return to the calling program.
!			  Byte 2 = 0  -  routine will abort on control z
!					 and reprompt on conversion errors.
!				 = 1  -  ( AT END )
!					 routine will return to calling program
!					 on control z and reprompt on conversion
!					 errors.
!				 = 2  -  ( ON EXCEPTION )
!					 routine will return to calling program 
!					 on control z and conversion errors.
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
!	FLAGS.rlu.v	Screen enhancement flag;
!
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blink
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 to allow space for sign in PROTECTED
!					  ACCEPT, 1 no allowance for sign
!				bit 8  -  protect
!				bit 9  -  no-echo
!				bit 10 -  0 advancing, 1 no advancing
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!
!	DEFAULT.rt.dx	Default source moved to destination descriptor
!			(STRING_DEST) in the event of null input.
!
!	LENGTH.wlu.r	Destination of the number of characters read.
!
!	ACC_SIZE.rlu.v	# of characters to RMS $GET.
!
!	PUT_HERE.rt.dx	Buffer to hold input characters.
!
!	YES_CONV.rlu.v	Flag = 1 if Conversion requested by user.
!
!	YES_PROTECT.rlu.v  Flag = 1 if Protection requested by user.
!
!	YES_SIGN.rlu.v	Flag = 1 if sign should be included in COMP or COMP3
!			data type.
!
! IMPLICIT INPUTS:
!
!	Status of whether the input file is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status of file
!
! ROUTINE VALUE:
!
!	If .UNIT[1] is false :  Unspecified.
!	If .UNIT[1] is true  :  Either true or false, indicating success or
!				EOF, respectively.
!
! SIDE EFFECTS:
!
!	Reads a record from a designated uint.
!
!--

    BEGIN

    LOCAL
	RAB		:  REF $RAB_DECL,
	CR_BUF		:  VECTOR [1,BYTE],
	CHARS_READ	:  INITIAL (0),		! Number of characters read
	CONV_OK		:  INITIAL (0),		! = 1 if no conversion errors
	YES_DEFAULT	:  INITIAL (0) ;	! = 1 if DEFAULT was used as input
 
    BUILTIN
	NULLPARAMETER ;

    !+
    !  RMS $PUT - If previous call requires advancing, $PUT a linefeed to
    !  SYS$OUTPUT.  Open SYS$OUTPUT if necessary.
    !-

    IF (.COB$$AB_PREV[0] EQL DISP
	OR .COB$$AB_PREV[0] EQL POS
	OR .COB$$AB_PREV[0] EQL ACC_ADV )
    THEN
	COB$$RMS_PUT_BYTE ( LINE_FD, .FLAGS ) ;

    !+
    !  RMS $GET to accept input from a file.
    !-

    RAB = .COB$$AL_WRITE_RAB [.UNIT[0]] ;
    RAB [RAB$W_USZ] = .ACC_SIZE ;
    RAB [RAB$L_UBF] = .PUT_HERE [DSC$A_POINTER] ;
    !+
    !  Turn off RAB [RAB$V_ETO] just in case a 'screen enhancement ACCEPT'
    !  was performed before this one.
    !-
    RAB [RAB$V_ETO] = 0 ;

    WHILE $GET (RAB = .RAB) EQL RMS$_RSA DO $WAIT (RAB = .RAB) ;

    IF NOT .RAB [RAB$L_STS] AND NULLPARAMETER (DEFAULT)
    THEN
	LIB$STOP (( IF .RAB[RAB$L_STS] EQL RMS$_EOF
		    THEN
			!+
			!  If ON EXCEPTION or AT END, return to user program. 
			!-
			IF .UNIT [1] EQL 1 OR .UNIT [1] EQL 2
			THEN 
			    RETURN 0
			ELSE
			    COB$_EOFON_ACC
		    ELSE
			   COB$_ERRDURACC),
		 1, .RAB + RAB$C_BLN, .RAB [RAB$L_STS], .RAB [RAB$L_STV] ) ;

    !+
    !  Put number of characters read from $GET in CHARS_READ.
    !  Pass this info along to COB$$ACC_CONVERT.
    !-

    CHARS_READ = .RAB [RAB$W_RSZ] ;			! Number of chars read

!*******
!******* NULL INPUT
!*******

    !+
    !  Null input.
    !  Check for DEFAULT parameter - if present prepare to put it through
    !  Conversion routines by placing DEFAULT in PUT_HERE.
    !-

    IF ( .CHARS_READ EQL 0 ) AND (( .FLAGS AND V_COB_RPG ) NEQ 0 )
    THEN
	!+
	!  In case of null input for RPG, simply return (no DEFAULT),
	!  after setting advancing flag.
	!-
	BEGIN
	IF (.FLAGS AND V_ADV) NEQ 0
	THEN
	    COB$$AB_PREV[0] = ACC_DNA
	ELSE
	    COB$$AB_PREV[0] = ACC_ADV ;
	RETURN 1 ;
	END ;

    !+
    !  There can be no PROTECTION check on input when dealing with files as
    !  RMS will only read ACC_SIZE characters or less.  If .ACC_SIZE were 4
    !  but the record contained "abcdef", only "abcd" will be pulled from the
    !  record.  RMS ignores the remaining characters "ef" and goes on to the
    !  next record.  However it is possible to perform a PROTECTION check
    !  when the DEFAULT value is used.
    !-

    IF ( .CHARS_READ EQL 0 )
    THEN
	BEGIN
	IF (.DEFAULT NEQ 0) AND (.YES_DEFAULT EQL 0)
	THEN
	    BEGIN				! Begin YES Default
	    	
	    CHARS_READ = .DEFAULT [DSC$W_LENGTH];
	    YES_DEFAULT = 1 ;

	    !+
	    !  Protection check for DEFAULT excluding the Floating
	    !  Point data types ( these will be handled in 
	    !  COB$$VERIFY_FL_RANGE.
	    !-

	    IF (.YES_PROTECT AND
		      ( .STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_F AND
	    		.STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_D ))
	    THEN				! Check protection
		IF (.DEFAULT [DSC$W_LENGTH] GTR .ACC_SIZE)
		THEN
		    !+
		    !  If the length of DEFAULT is greater than the
		    !  expected input size ACC_SIZE, then there is a
		    !  Protection error.
		    !-
		    LIB$STOP ( COB$_INVDEFVAL ) ;

	    END ;				! End YES Default
	END ;

!*******
!******* CONVERSION
!*******

   !+
   !  If conversion requested, call routine COB$$ACC_CONVERT
   !-

    IF ( .YES_CONV )
    THEN
	CONV_OK = COB$$ACC_CONVERT ( .STRING_DEST, .FLAGS,
					.DEFAULT, .PUT_HERE, .CHARS_READ,
						.YES_DEFAULT, .YES_SIGN )
    ELSE
	BEGIN
	    LOCAL
		COPY_NUM ;

	!+
	!  No conversion requested - copy input data to STRING_DEST.
	!  Use STR$COPY_R because it BLANK fills.
	!-

	IF .CHARS_READ LSS .STRING_DEST[DSC$W_LENGTH]
	THEN
	    COPY_NUM = .CHARS_READ
	ELSE
	    COPY_NUM = .STRING_DEST[DSC$W_LENGTH] ;

	STR$COPY_R ( .STRING_DEST, COPY_NUM,
					(IF .YES_DEFAULT
					THEN .DEFAULT [DSC$A_POINTER]
					ELSE .PUT_HERE [DSC$A_POINTER] )) ;

	CONV_OK = 1 ;				! set CONV_OK to success
	END;

    !+
    !  Conversion completed - was it successful ?
    !-

    IF .CONV_OK  EQL 0
    THEN
	!+
	!  CONVERSION error.  Read UNIT parameter to determine what
	!  to do.  There is no Reprompting done with Files as input.
	!
	!	  Byte 2 of	  		Conversion
	!	    UNIT			  error
	!
	!	     0		  		  COB$_ERRDURACC
	!	     1 ( at end ) 		  COB$_ERRDURACC
	!	     2 ( on exception ) 	  Return
	!-

	BEGIN					! Begin conversion error
	IF ( .FLAGS AND V_COB_RPG ) NEQ 0
	THEN
	    !+
	    !  VAX RPG - return on a Conversion Error, ring bell
	    !  and clean up first.
	    !-
	    BEGIN
	    COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;
	    COB$$RPG_CLEAN_UP ( .FLAGS );
	    RETURN 0 ;
	    END ;

	IF .UNIT [1] EQL 2
	THEN
	    RETURN 0
	ELSE

	    !+
	    !  When dealing with a file, it was decided to return a fatal
	    !  error message rather then REPROMPT.  This lets the user know
	    !  where the problem in the file is so that the input file can
	    !  be corrected before running the program again.  Otherwise, the
	    !  the user might run out of data by the end of the program or the
	    !  reprompting process may lead to further conversion errors.
	    !-

	    LIB$STOP ( COB$_ERRDURACC ) ;
	END ;					! End conversion error

    !+
    !  Fill in optional LENGTH parameter with the number of
    !  characters read if no error.
    !-

    IF .LENGTH NEQ 0
    THEN
	.LENGTH = .CHARS_READ ;

!*******
!******* CLEAN UP
!*******

    !+
    !  Determine if ADVANCING is requested.
    !  If bit 10 = 0 advancing.  If bit 10 = 1 no advancing.
    !  Set COB$$AB_PREV[0] - also depending on bit 10, to flag to next COBOL
    !  statement that advancing/no advancing is required following this
    !  ACCEPT statement.  Echo carriage return to screen if advancing is
    !  called for.
    !-
    
    IF (.FLAGS AND V_ADV) NEQ 0
    THEN
	COB$$AB_PREV[0] = ACC_DNA			! No Advancing
    ELSE
	COB$$RMS_PUT_BYTE ( CARR_RET, .FLAGS ) ;	! Advance via a carriage
							! return
    RETURN 1;
    END;					! End of COB$$ACC_SCR_FILE

%SBTTL 'COB$$OPEN_IN - Open for INPUT'
GLOBAL ROUTINE COB$$OPEN_IN (UNIT, RPG): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Open a file for reading, given its unit number.
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			from which the string is to be read.
!
!	RPG.rl.v	= 1 if RPG is calling this routine
!			= 0 if COBOL is calling this routine
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    LITERAL
	MAX_BUF =	MAX(LNM$C_NAMLENGTH, NAM$C_MAXRSS);
    LOCAL
	FAB:		$FAB_DECL,
	NAM:		$NAM_DECL,
	RAB:		REF $RAB_DECL,
	FILE_NAME:	BLOCK[8, BYTE],		! Descriptor for the file name
	TRANSLATE:	BLOCK[8, BYTE],
	P:		REF VECTOR[,BYTE],
	RSLBUF:		VECTOR[MAX_BUF,BYTE],
	STATUS;


    ! Determine whether the COB$xxx name is defined.
    ! If so, use it.  If not, use the corresponding SYS$xxx name.
    !
    TRANSLATE[DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    TRANSLATE[DSC$B_CLASS]   = DSC$K_CLASS_S;
    TRANSLATE[DSC$W_LENGTH]  = MAX_BUF;
    TRANSLATE[DSC$A_POINTER] = RSLBUF;

    !+
    !  If VAX RPG is calling this routine, bypass COB_TABLE.
    !-

    IF .RPG
    THEN
	BEGIN					! Use the SYS$xxx logical
	P = .SYS_TABLE[.UNIT] + BASE;
	FILE_NAME[DSC$W_LENGTH] = .P[0];
	FILE_NAME[DSC$A_POINTER] = P[1];
	END
    ELSE
	BEGIN					! Use the COB$xxx logical
	P = .COB_TABLE[.UNIT] + BASE;
	FILE_NAME[DSC$B_DTYPE]   = DSC$K_DTYPE_T;	
	FILE_NAME[DSC$B_CLASS]   = DSC$K_CLASS_S;
	FILE_NAME[DSC$W_LENGTH]  = .P[0];
	FILE_NAME[DSC$A_POINTER] = P[1];
	IF $TRNLOG(LOGNAM = FILE_NAME, RSLBUF = TRANSLATE) NEQ SS$_NORMAL
	THEN
	    BEGIN				! Use the SYS$xxx logical
	    P = .SYS_TABLE[.UNIT] + BASE;
	    FILE_NAME[DSC$W_LENGTH] = .P[0];
	    FILE_NAME[DSC$A_POINTER] = P[1];
	    END;
	END ;

    $FAB_INIT(
	FAB = FAB,
	NAM = NAM,
	FAC = <GET,PUT>,
	FNA = .FILE_NAME[DSC$A_POINTER],
	FNS = .FILE_NAME[DSC$W_LENGTH],
	FOP = SQO);

    $NAM_INIT(
	NAM = NAM,
	ESA = RSLBUF,
	ESS = NAM$C_MAXRSS,
	RSA = RSLBUF,
	RSS = NAM$C_MAXRSS);

    STATUS = $OPEN(FAB = FAB);
    IF (TRANSLATE[DSC$W_LENGTH] = .NAM[NAM$B_RSL]) EQL 0 THEN
    IF (TRANSLATE[DSC$W_LENGTH] = .NAM[NAM$B_ESL]) EQL 0
    THEN
	BEGIN
	TRANSLATE[DSC$W_LENGTH] = .FAB[FAB$B_FNS];
	TRANSLATE[DSC$A_POINTER]= .FAB[FAB$L_FNA];
	END;


    IF NOT .STATUS
    THEN
	LIB$STOP(COB$_ERRDURACC, 1, TRANSLATE, .FAB[FAB$L_STS], .FAB[FAB$L_STV]);


    IF NOT (STATUS = LIB$GET_VM(%REF(RAB$C_BLN + 8 + .NAM[NAM$B_RSL]), RAB))
    THEN
	LIB$STOP(COB$_FAIGET_VM, 0, .STATUS);


    ! Save a descriptor for the resultant file name string,
    ! and the string itself, after the RAB
    !
    BEGIN
    LOCAL
	Q: REF BLOCK[,BYTE];
    Q = .RAB + RAB$C_BLN;
    Q[DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    Q[DSC$B_CLASS]   = DSC$K_CLASS_S;
    Q[DSC$W_LENGTH]  = .TRANSLATE[DSC$W_LENGTH];
    Q[DSC$A_POINTER] = .RAB+RAB$C_BLN+8;
    CH$MOVE( .Q[DSC$W_LENGTH], .TRANSLATE[DSC$A_POINTER], .RAB+RAB$C_BLN+8 );
    END;

    !+
    ! Initiate terminal XABTRM and include it in the RAB.
    !-

    $XABTRM_INIT ( XAB	      = XABTRM,
		   ITMLST     = XAB_ITMLST,
		   ITMLST_LEN = %ALLOCATION (XAB_ITMLST)-4 ) ;	! $ITMLST_DECL
								! adds extra 4
    $RAB_INIT(
	RAB = .RAB,
	FAB = FAB,
	XAB = XABTRM);

    IF NOT $CONNECT(RAB = .RAB)
    THEN
	LIB$STOP(COB$_ERRDURACC, 1, .RAB+RAB$C_BLN, .RAB[RAB$L_STS], .RAB[RAB$L_STV]);

    COB$$AL_WRITE_RAB[.UNIT] = .RAB;
    COB$$AW_WRITE_IFI[.UNIT] = .FAB[FAB$W_IFI];

    END;					!  End of COB$$OPEN_IN

%SBTTL 'COB$$RMS_GET - Perform an RMS $GET Service'
ROUTINE COB$$RMS_GET ( RAB	:  REF $RAB_DECL,
		       FUNC_VAL,
		       LENGTH,
		       BUFFER
		     )  :  NOVALUE  =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN

    $ITMLST_INIT (ITMLST = XAB_ITMLST,			! Item list for $GET
		   (ITMCOD = TRM$_MODIFIERS,
		    BUFSIZ = 0,
		    BUFADR = .FUNC_VAL),
		   (ITMCOD = TRM$_TERM,
		    BUFSIZ = 20,
		    BUFADR = MASK_VECTOR) ) ;

    RAB [RAB$W_USZ] = .LENGTH ;
    RAB [RAB$L_UBF] = .BUFFER ;
    RAB [RAB$V_ETO] = 1 ;				! Extended Terminal $GET
    RAB [RAB$L_XAB] = XABTRM ;
    WHILE $GET (RAB = .RAB) EQL RMS$_RSA DO $WAIT (RAB = .RAB) ;

    IF NOT .RAB [RAB$L_STS]
    THEN
	!+
	!  These are special case status that will be handled later.
	!-
	IF (.RAB [RAB$L_STS] NEQ RMS$_BES AND		! Bad Escape Sequence
	    .RAB [RAB$L_STS] NEQ RMS$_EOF AND		! End Of File
	    .RAB [RAB$L_STS] NEQ RMS$_PES AND		! Partial Escape Seq
	    .RAB [RAB$L_STS] NEQ RMS$_RTB AND		! Record Too Big
	    .RAB [RAB$L_STS] NEQ RMS$_TNS )		! Terminator Not Seen
	THEN
	    LIB$STOP (COB$_ERRDURACC, 1, .RAB + RAB$C_BLN, .RAB [RAB$L_STS],
							 .RAB [RAB$L_STV] ) ;
    END ;						

%SBTTL 'COB$$RMS_PUT_BYTE - Perform an RMS $PUT Service'
ROUTINE COB$$RMS_PUT_BYTE ( WHICH, FLAGS )  :  NOVALUE  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes a one byte buffer to the terminal. Either a
!	Carriage Return, Linefeed or Ring the Terminal Bell, depending
!	on the value of WHICH.
!
! FORMAL PARAMETERS:
!
!	WHICH.rl.v	if 0, write Linefeed to terminal
!			if 1, write Carriage Return to terminal
!			if 2, ring terminal bell
!	
!	FLAGS.rlu.v	Screen enhancement flag
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	RAB    :  REF $RAB_DECL,
	CR_BUF :  VECTOR [1,BYTE] ;

    IF .COB$ACC_TERM_TYPE NEQ UNKNOWN
    THEN
	BEGIN

	SELECTONE .WHICH OF
	    SET
		[0] :	CR_BUF [0] = CR ;		! Carriage Return

		[1] :	CR_BUF [0] = LF ;		! Linefeed

		[2] :	CR_BUF [0] = BELL ;		! Bell
	    TES ;

	COB$$AB_USPCODE [0] = 0 ;
	COB$$AB_USPCODE [1] = 0 ;

	IF .COB$$AL_WRITE_RAB [1] EQL 0
	THEN
	    BEGIN
	    !+
	    !  Open SYS$OUTPUT.  Second parameter tells COB$$OPEN_OUT whether
	    !  VAX COBOL (0) or VAX RPG (1) is the caller.
	    !  VMS V4 defines SYS$INPUT as read only, therefore any $PUTs must
	    !  be made through SYS$OUTPUT.  When a terminal is the input device 
	    !  for an ACCEPT it is also the OUTPUT device, and must be OPENed
	    !  for both.
	    !-
	    COB$$OPEN_OUT ( 1, 
			    IF ( .FLAGS AND V_COB_RPG ) NEQ 0
		    	    THEN 1
		    	    ELSE 0 ) ;
	    END ;
	RAB = .COB$$AL_WRITE_RAB [1] ;
	RAB [RAB$L_RBF] = CR_BUF [0] ;
	RAB [RAB$W_RSZ] = 1 ;
	WHILE $PUT (RAB = .RAB) EQL RMS$_RSA DO $WAIT (RAB = .RAB) ;

	IF NOT .RAB [RAB$L_STS]
	THEN
	    LIB$STOP ( COB$_ERRDURACC, 1, .RAB + RAB$C_BLN,
			.RAB [RAB$L_STS], .RAB [RAB$L_STV] ) ;
	END ;
    END ;					! End of COB$$RMS_PUT_BYTE

%SBTTL 'COB$$RMS_PUT_BUFFER - Perform RMS $PUT Service'
ROUTINE COB$$RMS_PUT_BUFFER ( BUFFER,	
			      LENGTH,
			      FLAGS )  :  NOVALUE  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes buffer of more than one byte to the terminal.
!
! FORMAL PARAMETERS:
!
!	BUFFER.rt.r	Holds sequence to write to screen
!
!	LENGHT.rlu.v	Length of BUFFER
!	
!	FLAGS.rlu.v	Screen enhancement flag
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	RAB    :  REF $RAB_DECL ;

    IF .COB$ACC_TERM_TYPE NEQ UNKNOWN
    THEN
	BEGIN

	COB$$AB_USPCODE [0] = 0 ;
	COB$$AB_USPCODE [1] = 0 ;

	IF .COB$$AL_WRITE_RAB [1] EQL 0
	THEN
	    BEGIN
	    !+
	    !  Open SYS$OUTPUT.  Second parameter tells COB$$OPEN_OUT whether
	    !  VAX COBOL (0) or VAX RPG (1) is the caller.
	    !-
	    COB$$OPEN_OUT ( 1, 
			    IF ( .FLAGS AND V_COB_RPG ) NEQ 0
		    	    THEN 1
		    	    ELSE 0 ) ;
	    END ;
	RAB = .COB$$AL_WRITE_RAB [1] ;
	RAB [RAB$L_RBF] = .BUFFER ;
	RAB [RAB$W_RSZ] = .LENGTH ;
	WHILE $PUT (RAB = .RAB) EQL RMS$_RSA DO $WAIT (RAB = .RAB) ;

	IF NOT .RAB [RAB$L_STS]
	THEN
	    LIB$STOP ( COB$_ERRDURACC, 1, .RAB + RAB$C_BLN,
			.RAB [RAB$L_STS], .RAB [RAB$L_STV] ) ;
	END ;
    END ;					! End of COB$$RMS_PUT_BUFFER

%SBTTL 'COB$$CONTROL_Z - Handle ^Z'
ROUTINE COB$$CONTROL_Z ( UNIT		:  VECTOR [2, BYTE],
			 KEY		:  REF $STR$DESCRIPTOR 
			)  :  NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read UNIT parameter to determine what to do when a Control Z was typed.
!
! FORMAL PARAMETERS:
!
!	UNIT.rbu.va	Array of two unsigned byte integers.
!			The first byte is the unit number designating the
!			device from which the string is to be read.
!			The second byte indicates whether the routine should
!			abort or return to the calling program.
!
!	KEY.wt.ds	Destination of the receiving field of the control key.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!--
	BEGIN
	    LOCAL
		TERM_PTR,				! Points to terminator
		CZ_PTR ;				! Needed for CH$MOVE

	 !+
	 !  CONTROL Z - read UNIT parameter to determine what to do.
	 !
	 !	  Byte 2 of	  	Ctrl z
	 !	    UNIT
	 !
	 !           0		  	abort
	 !	     1 ( at end ) 	return
	 !	     2 ( on exception ) return
	 !-

		IF .UNIT [1]  EQL  0
		THEN
		    LIB$STOP ( COB$_EOFON_ACC )		! Abort
		ELSE
		    BEGIN
		    IF .KEY NEQ 0
		    THEN
			BEGIN
			!+
			!  Pass CONTROL Z back to user program via KEY,
			!  if requested
			!-
			CZ_PTR = CZ ;			! CZ is literal %X'1A'
			TERM_PTR = CZ_PTR ;
			CH$MOVE ( 1, .TERM_PTR, .KEY [DSC$A_POINTER] ) ;
			END ;
		    END ;
	END ;					! End routine COB$$CONTROL_Z

%SBTTL 'COB$$PARTIAL_SEQ - Partial Escape Sequence'
ROUTINE COB$$PARTIAL_SEQ ( PARAMETERS : REF VECTOR,
			   UNIT	      : VECTOR [2,BYTE] )  :  NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	The entire Escape sequence did not fit in the initial $GET's buffer.
!	Perform 1 character Reads until the full sequence is in PUT_HERE or
!	NEXT_CHAR.
!
! FORMAL PARAMETERS:
!
!	PARAMETERS.mlu.ra  Contains data for this routine.
!
!	UNIT.rbu.va	   Array of two unsigned byte integers.
!			   The first byte is the unit number designating the
!			   device from which the string is to be read.
!			   The second byte indicates whether the routine should
!			   abort or return to the calling program.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	RAB		:  REF $RAB_DECL,	
	FUNC_VAL_2,				! QIO Function Modifiers for
						! item list of RMS $GET.
	TERM_CHAR	:  BYTE,		! $GET input buffer.
	PH		:  REF VECTOR [1100,BYTE],  ! Address of PUT_HERE
	PH_PTR,					! Pointer to PUT_HERE.
	NC_PTR,					! Pointer to NEXT_CHAR.
	END_OF_TERM	:  INITIAL (0) ;	! =1 whole Seq in buffer.

	!+
	!  Bind PARAMETERS to other names.
	!-

	$BIND_PARAMETERS ;
	PH = .PUT_HERE [DSC$A_POINTER] ;

	!+
 	!  PH_PTR and NC_PTR point to next free space in buffer
	!  PUT_HERE or NEXT_CHAR.
	!-

	PH_PTR = .CHARS_READ + .TERM_SIZE ;
	NC_PTR = 1 ;

	!+
	!  Read one character at a time until the entire escape sequence has
	!  been read.
	!-

	WHILE .END_OF_TERM EQL 0 DO
	    BEGIN					! Begin loop

	    FUNC_VAL_2 = TRM$M_TM_ESCAPE + TRM$M_TM_NOFILTR + TRM$M_TM_TRMNOECHO
							  + TRM$M_TM_NOECHO ;

	    RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
	    COB$$RMS_GET ( .RAB, .FUNC_VAL_2, 1, TERM_CHAR ) ;

	    !+
	    !  Deposit sequence character in appropriate buffer.
	    !-

	    IF .TERM_IN_NEXT EQL 0
	    THEN
		BEGIN
		!+
		!  This is a workaround for an RMS bug that did not
		!  make it into the final code freeze for V4.0.
		!  The next three lines can be pulled when the RMS fix
		!  is made.  (see NEXT_CHAR below)
		!-
		IF .TERM_SIZE EQL 1			! Put first character
		THEN					! of terminator seq
		    PH [.PH_PTR - 1] = %X'1B' ;		! into PUT_HERE

		PH [.PH_PTR] = .TERM_CHAR ;		! Put character just
		PH_PTR = .PH_PTR + 1 ;			! read in PUT_HERE 
		TERM_IN_NEXT = 0 ;
		END
	    ELSE
		BEGIN
		!+
		!  This is a workaround for an RMS bug that did not
		!  make it into the final code freeze for V4.0.
		!  The next three lines can be pulled when the RMS fix
		!  is made.
		!-
		IF .TERM_SIZE EQL 1			! Put first character
		THEN					! of terminator seq
		    NEXT_CHAR [0] = %X'1B' ;		! into NEXT_CHAR.

		NEXT_CHAR [.NC_PTR] = .TERM_CHAR ;	! Put character just
		NC_PTR = .NC_PTR + 1 ;			! read in NEXT_CHAR
		END ;

	    TERM_SIZE = .TERM_SIZE + 1 ;		! Total Terminator size

	    !+
	    !  Ugly - but it's the only way to check for the end of an
	    !  escape sequence.  All known KEY escape sequences end in
	    !  one of these characters and none of these characters fall
	    !  in the middle of an escape sequence.  This will have to be
	    !  updated if new escape sequences surface.
	    !-

	    IF ((.TERM_CHAR GEQ %C'A'  AND  .TERM_CHAR LEQ  %C'M')  OR
	        (.TERM_CHAR GEQ %C'P'  AND  .TERM_CHAR LEQ  %C'S')  OR
	        (.TERM_CHAR GEQ %C'l'  AND  .TERM_CHAR LEQ  %C'y')  OR
	        (.TERM_CHAR EQL %X'7E'))
	    THEN 
		BEGIN
		END_OF_TERM = 1 ;			! Signal completion
		!+
		!  Have to get rid of a possible status RMS$_TNS, Terminator
		!  Not Seen.  Assume success if we have reached this point.
		!  It is not advisable to overwrite data in the RAB but there
		!  is not way to avoid it in this case.
		!-
		RAB [RAB$L_STS] = RMS$_SUC ;
		END ;

	   END ;					! End loop
    END ;						! End COB$$PARTIAL_SEQ

%SBTTL 'COB$$DELETE_KEY - Delete Key processing'
ROUTINE COB$$DELETE_KEY ( PARAMETERS : REF VECTOR,
			  UNIT	     : VECTOR [2,BYTE],
			  FLAGS				 )  :  NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Delete Key processing.
!
! FORMAL PARAMETERS:
!
!	PARAMETERS.mlu.ra  Contains data for this routine.

!	UNIT.rbu.va	   Array of two unsigned byte integers.
!			   The first byte is the unit number designating the
!			   device from which the string is to be read.
!			   The second byte indicates whether the routine should
!			   abort or return to the calling program.
!
!	FLAGS.rlu.v	   Screen enhancement flag.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

	LOCAL
	    RAB	   :  REF $RAB_DECL,
	    DELETE_BUF :  VECTOR [3, BYTE],
	    CHARS_OK   :  INITIAL (0),			! Characters not deleted
	    REST_LEN,					! Length yet to be ACCEPTed
							! after DELETE KEY was hit
	    REST_PTR ;					! Where to put rest of
							! chars on next $GET 
!+
!  Delete Key processing.  Delete one character at a time.  Delete previous
!  character typed by backspacing, writing a space to  delete (overwrite)
!  character, and backspacing again to put cursor in position to continue
!  ACCEPTing data.
!  Hitting the DELETE KEY terminated the previous $GET, therefore perform
!  another $GET to read the rest of the data expected.
!
!  Bind PARAMETERS to other names.
!-

    $BIND_PARAMETERS ;

    IF ( .FLAGS AND V_NO_ECHO ) NEQ 0
    THEN
	!+
	!  If characters were not echoed to terminal there is no need
	!  to move cursor.
	!-
	BEGIN
	DELETE_BUF [0] = NULL ;				! null
	DELETE_BUF [1] = NULL ;
	DELETE_BUF [2] = NULL ;
	END
    ELSE
	BEGIN
	DELETE_BUF [0] = BS ;				! Backspace
	DELETE_BUF [1] = BLANK ;			! Space
	DELETE_BUF [2] = BS ;				! Backspace
	END	;

	WHILE .TERM_LOC EQL DEL_KEY DO
	    BEGIN					! Begin Delete Loop

	    CHARS_READ = (.CHARS_READ - 1) ;	! Decr # of valid input chars
	    CHARS_OK   = .CHARS_READ ;		! Save for left border check
							
	    IF .CHARS_READ LSS 0
	    THEN CHARS_READ = 0 ;

	    !+
	    !  Calculations for $GET
	    !-
	    REST_LEN   = .ACC_SIZE - .CHARS_READ ;
	    REST_PTR   = .PUT_HERE [DSC$A_POINTER] + .CHARS_READ ;

	    !+
	    !  Check for too many deletes, do not delete more characters
	    !  then were input.  Ring bell to signal attempt to go beyond
	    !  left border.
	    !-
	    IF .CHARS_OK LSS 0 
	    THEN
		BEGIN
		COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;
		END
	    ELSE
		!+
		!  $PUT to Delete one character.
		!-
		COB$$RMS_PUT_BUFFER ( DELETE_BUF [0], 3, .FLAGS ) ;

	    !+
	    !  Continue to Read input
	    !-

	    RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
	    COB$$RMS_GET ( .RAB, .FUNC_VAL, .REST_LEN, .REST_PTR ) ;

	    !+
	    !  Reset CHARS_READ - Update # of input chars read.
	    !  Reset TERM_SIZE and TERM_LOC - New terminator ( Note: this could
	    !					 	be the DELETE KEY again)
	    !-

	    CHARS_READ = .CHARS_READ + .RAB [RAB$W_RSZ] ;
	    TERM_SIZE  = .RAB [COB$$B_STV2_LEN] ;
	    TERM_LOC   = .RAB [COB$$B_STV0_TERM]; ! Terminator location.

	    !+
	    ! Check for partial sequence error
	    !-

	    IF .RAB [RAB$L_STS] EQL RMS$_PES
	    THEN
		COB$$PARTIAL_SEQ ( .PARAMETERS, .UNIT ) ;

	    END ;					! End Delete Loop

!+
!  Did the latest $GET come across a terminator ?
!  If so, set flag used by COB$$ILLEGAL_TERM to signal that the terminator
!  was encountered in this routine.
!-

    IF .TERM_SIZE NEQ 0 OR .RAB [RAB$L_STS] EQL RMS$_EOF
    THEN
	TERM_FROM_DEL = 1 ;

    END	;						! End COB$$DELETE_KEY

%SBTTL 'COB$$ILLEGAL_TERM - Illegal Terminator'
ROUTINE COB$$ILLEGAL_TERM ( PARAMETERS : REF VECTOR,
			    UNIT       : VECTOR [2,BYTE],
			    FLAGS,
			    KEY	       : REF $STR$DESCRIPTOR )  :  NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Terminator from previous $GET was illegal - ring terminal bell to
!	signal this.  Perform another $GET of length 1 to look for another
!	terminator.  Verify this new terminator.
!
! FORMAL PARAMETERS:
!
!	PARAMETERS.mlu.ra  Contains data for this routine.
!
!	UNIT.rbu.va	   Array of two unsigned byte integers.
!			   The first byte is the unit number designating the
!			   device from which the string is to be read.
!			   The second byte indicates whether the routine should
!			   abort or return to the calling program.
!
!	FLAGS.rlu.v	   Screen enhancement flag.
!
!	KEY.wt.ds	   Destination of the receiving field of the control key.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
	LOCAL
	    RAB	:  REF $RAB_DECL,
	    FUNC_VAL_2,					! QIO Function Modifiers
	    NO_BELL		:  INITIAL (0),		! =0 ring bell, =1 don't
	    LOOK_FOR_TERM	:  INITIAL (0),		! =1 buffer full, $GET
							! only for a terminator
	    REST_LEN,					! Length yet to be input
	    REST_PTR ;					! Where to put rest of
							! input data
!+
!  Bind PARAMETERS to other names.
!-

    $BIND_PARAMETERS ;

!+
!  Note :  If COB$$DELETE_KEY was called before this routine some
!  special handling is necessary.
!	  It is possible a previous call to COB$$DELETE_KEY would have
!	  filled the input buffer without coming across a terminator.
!	  When the input buffer is full - look for terminator only.
!	
!	  It is also possible that COB$$DELETE_KEY came across a terminator,
!	  therefore it is only necessary to verify the terminator not
!	  perform another $GET.  This is flagged by TERM_FROM_DEL = 1.
!-

    WHILE .LEGAL EQL 0 DO
	BEGIN						! Begin Term Loop
	IF .NO_BELL EQL 0 AND .TERM_FROM_DEL EQL 0	! NO_BELL is set in
	THEN						! $VERIFY_TERMINATOR
	    !+
	    !  Ring bell to signal illegal terminator.
	    !  Don't ring bell if processing the Delete key, or if the
	    !  terminator has come from COB$$DELETE_KEY (wait for
	    !  $VERIFY_TERMINATOR to check terminator).
	    !-
	    BEGIN
	    COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;
	    END
	ELSE						! Reset - next time
	    NO_BELL = 0 ; 				! ring bell
	!+
	!  Is there still data yet to be input ?
	!-

	IF .TERM_FROM_DEL EQL 0
	THEN
	    BEGIN					! Begin TERM_FROM_DEL=0

	    IF .ACC_SIZE GTR .CHARS_READ
	    THEN
		BEGIN

		!+
		!  Calculations for $GET.
		!-
		REST_LEN   = .ACC_SIZE - .CHARS_READ ;
		REST_PTR   = .PUT_HERE [DSC$A_POINTER] + .CHARS_READ ;

		!+
		!  NEVER do a Read of 0 length, this causes an infinite loop
		!  of bell ringing.
		!-
		IF .REST_LEN EQL 0 THEN REST_LEN = 1 ;

		RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
		COB$$RMS_GET ( .RAB, .FUNC_VAL, .REST_LEN, .REST_PTR ) ;

		!+
		!  Update CHARS_READ, TERM_SIZE and TERM_LOC.
		!-
	
		CHARS_READ = .CHARS_READ + .RAB [RAB$W_RSZ] ;
		TERM_SIZE  = .RAB [COB$$B_STV2_LEN] ;
		TERM_LOC   = .RAB [COB$$B_STV0_TERM] ;
		
		END ;

	    !+
	    !  $GET buffer filled but no terminator seen - TERM_SIZE = 0
	    !  Do 1 character reads until you hit a terminator that
	    !  you can then attempt to verify.
	    !  Also trap an End of File ^Z here and do not perform 
	    !  another $GET, $VERIFY_TERMINATOR will take care of the ^Z.
	    !  .LOOK_FOR_TERM EQL 1 case -> came into this routine with
	    !  $GET buffer filled but illegal terminator, therefore
	    !  we are looking only for a terminator. 
	    !-
		
	    IF .ACC_SIZE EQL .CHARS_READ
	    THEN LOOK_FOR_TERM = 1 ;
	    WHILE (.TERM_SIZE EQL 0 AND .RAB [RAB$L_STS] NEQ RMS$_EOF)
		   OR (.LOOK_FOR_TERM EQL 1 ) DO

		BEGIN					! Begin 1 char $GET
		REST_PTR   = .PUT_HERE [DSC$A_POINTER] + .CHARS_READ ;

		FUNC_VAL_2 = TRM$M_TM_ESCAPE + TRM$M_TM_NOFILTR 
					+ TRM$M_TM_TRMNOECHO + TRM$M_TM_NOECHO ;

		RAB = .COB$$AL_WRITE_RAB [ .UNIT[0] ] ;
		COB$$RMS_GET ( .RAB, .FUNC_VAL_2, 1, .REST_PTR ) ;

		!+
		!  Set TERM_SIZE and TERM_IN_NEXT before possible
		!  call to COB$$PARTIAL_SEQ.
		!  If user attempts to input data other than a
		!  terminator - error.
		!-
	
		IF .RAB [RAB$W_RSZ] NEQ 0
		THEN
		    BEGIN
		    COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;	! Error.
		    TERM_SIZE = 0 ;
		    END
		ELSE					! Terminator seen.
		    IF .RAB [RAB$L_STS] EQL RMS$_EOF
		    THEN
			!+
			!  NOTE:  When Control Z is typed in as the only
			!  input to a $GET it is not recorded in
			!  RAB [COB$$B_STV2_LEN] therefore, pull out of 
			!  loop and let $VERIFY_TERMINATOR handle the ^Z,
			!  but first you have to load the ^Z in 
			!  RAB [COB$$B_STV2_LEN]  as this is where
			!  $VERIFY_TERMINATOR looks for it.
			!-
			BEGIN
			TERM_SIZE = 1 ;
			RAB [COB$$B_STV0_TERM] = CZ ;
			LOOK_FOR_TERM = 0 ;		! Set to get out of loop
			END
		    ELSE
			BEGIN
			LOOK_FOR_TERM = 0 ;		! Set to get out of loop
			TERM_SIZE = .RAB [COB$$B_STV2_LEN] ;
			TERM_LOC  = .RAB [COB$$B_STV0_TERM] ;
			END ;
		END ;					! End 1 char $GET

	    !+
	    ! Check for partial sequence error
	    !-

	    IF .RAB [RAB$L_STS] EQL RMS$_PES
	    THEN
		COB$$PARTIAL_SEQ ( .PARAMETERS, .UNIT ) ;

	    END ;					! End TERM_FROM_DEL=0

	!+
	!  Now have a Terminator in PUT_HERE.  Reset flags.  Call
	!  macro to verify Terminator.
	!-

	TERM_PTR = .PUT_HERE [DSC$A_POINTER] + .CHARS_READ ;
	TERM_FROM_DEL = 0 ;
	TERM_IN_NEXT = 0 ;
	$VERIFY_TERMINATOR ;

	END ;						! End Term Loop

    END ;						! End COB$$ILLEGAL_TERM

%SBTTL 'COB$$CLEAN_UP - Clean up for VAX COBOL'
ROUTINE COB$$CLEAN_UP ( PARAMETERS : REF VECTOR,
			FLAGS
		       )  :  NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform clean up before returning control to VAX COBOL.
!	Position cursor after FIELD of POTECTED ACCEPT, $PUT to turn
!	attributes off, and determine if ADVANCING is needed.
!
! FORMAL PARAMETERS:
!
!	PARAMETERS.mlu.ra  Contains data for this routine.
!
!	FLAGS.rlu.v	   Screen enhancement flag.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
	LOCAL
	    RAB	 :  REF $RAB_DECL ;

    !+
    !  Bind PARAMETERS to other names.
    !-

    $BIND_PARAMETERS ;

    !+
    !  Position cursor after FIELD of POTECTED Read.
    !  This code is necessary if the # of characters input is less than
    !  the # of characters expected.  Move cursor the difference of the 
    !  two numbers.
    !  If DEFAULT has been used move cursor the whole length of the expected
    !  size.
    !-

    IF .YES_PROTECT
    THEN
	BEGIN
	    LOCAL
		MOVE_CURSOR  :  INITIAL (0),		!  Flag
		MOVE_NUM ;				!  # of positions to
							!  move cursor
	IF .YES_DEFAULT NEQ 0
	THEN
	    BEGIN
	    MOVE_NUM = .ACC_SIZE ;			!  DEFAULT used
	    MOVE_CURSOR = 1 ;
	    END
	ELSE
	    IF .CHARS_READ LSS .ACC_SIZE		!  # of chars input is
	    THEN					!  less than expected
		BEGIN
		MOVE_NUM = .ACC_SIZE - .CHARS_READ ;
		MOVE_CURSOR = 1 ;
		END ;
	
	IF .MOVE_CURSOR NEQ 0
	THEN
	    BEGIN
		LOCAL
		    SPACE_BUF : VECTOR [200,BYTE] ;

	    CH$FILL ( BLANK, .MOVE_NUM, SPACE_BUF [0] ) ; ! # of spaces to move
	    COB$$RMS_PUT_BUFFER ( SPACE_BUF [0], .MOVE_NUM, .FLAGS ) ;	! cursor
	    END ;
    END ;

    !+
    !  $PUT to turn attributes off.
    !  If no attributes were turned on, there is no need to turn them off.
    !  OFF_BUF holds escape sequence to turn attributes off.  OFF_LEN holds
    !  the length of that sequence.
    !-    
	
    IF .PUT_FLAG NEQ 0
    THEN
	COB$$RMS_PUT_BUFFER ( OFF_BUF [0], .OFF_LEN, .FLAGS ) ;

    !+
    !  Determine if ADVANCING is requested.
    !  If bit 10 = 0 advancing.  If bit 10 = 1 no advancing.
    !  Set COB$$AB_PREV[0] - also depending on bit 10, to flag to next COBOL
    !  statement that advancing/no advancing is required following this
    !  ACCEPT statement.
    !-

    IF (.FLAGS AND V_ADV) NEQ 0
    THEN
	COB$$AB_PREV[0] = ACC_DNA			! Signal Do Not Advance
    ELSE
	!+
	!  Echo carriage return to screen if advancing is called for.
	!-
	BEGIN
	COB$$RMS_PUT_BYTE ( CARR_RET, .FLAGS ) ;
	COB$$AB_PREV[0] = ACC_ADV ;			! Signal ADVance
	END ;
    END ;						! End of COB$$CLEAN_UP

%SBTTL 'COB$$RPG_CLEAN_UP - Clean up for VAX RPG'
ROUTINE COB$$RPG_CLEAN_UP ( FLAGS )  :  NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform clean up before returning control to VAX RPG.
!
! FORMAL PARAMETERS:
!
!	FLAGS.rlu.v	Screen enhancement flag.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    !+
    !  Determine if ADVANCING is requested.
    !  If bit 10 = 0 advancing.  If bit 10 = 1 no advancing.
    !  Set COB$$AB_PREV[0] - also depending on bit 10, to flag to next COBOL
    !  statement that advancing/no advancing is required following this
    !  ACCEPT statement.
    !-

    IF (.FLAGS AND V_ADV) NEQ 0
    THEN
	COB$$AB_PREV[0] = ACC_DNA			! Signal Do Not Advance
    ELSE
	BEGIN
	!+
	!  Echo carriage return to screen if advancing is called for.
	!-
	COB$$RMS_PUT_BYTE ( CARR_RET, .FLAGS ) ;
	COB$$AB_PREV[0] = ACC_ADV ;			! Signal ADVance
	END;

    END ;					      ! End of COB$$RPG_CLEAN_UP

%SBTTL 'COB$$FORMAT_FOUR - Format Four'
ROUTINE COB$$FORMAT_FOUR  ( UNIT	:  VECTOR [2,BYTE],
			    FLAGS,
			    KEY		:  REF $STR$DESCRIPTOR
			  )  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles VAX COBOL ACCEPT Statement FORMAT FOUR,
!	Control Key.
!
! FORMAL PARAMETERS:
!
!	UNIT.rbu.va	Array of two unsigned byte integers.
!			The first byte is the unit number designating the
!			device from which the string is to be read.
!			The second byte indicates whether the routine should
!			abort or return to the calling program.
!			  Byte 2 = 0  -  routine will abort on control z
!					 and reprompt on conversion errors.
!				 = 1  -  ( AT END )
!					 routine will return to calling program
!					 on control z and reprompt on conversion
!					 errors.
!				 = 2  -  ( ON EXCEPTION )
!					 routine will return to calling program 
!					 on control z and conversion errors.
!
!	FLAGS.rlu.v	Screen enhancement flag;
!
!	KEY.wt.ds	Destination of the receiving field of the control key.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	RAB		:  REF $RAB_DECL,
	FUNC_VAL,				! Read QIO Function Modifiers
						! used in item list by RMS
	TERM_PTR,				! Pointer to terminator in buffer
	NEXT_CHAR	:  VECTOR [10,BYTE],	! Buffer to hold terminator sequence
	LEGAL		:  INITIAL (0),		! = 0 if illegal terminator hit
	TMASK		:  VECTOR [2] ;		! Longform terminator mask

!+
!  Terminator mask - EVERY key is treated as a terminator.  Each key pressed
!  is checked for validity as a terminator.
!  Valid terminators are Carriage Return, Tab, Control Z, Arrow keys, 
!  PF keys, and the PROFESSIONAL Editing and Top Row Function keys.
!-

    TMASK [0] = 32 ;
    TMASK [1] = UPLIT (-1, -1, -1, -1, -1, -1, -1, -1 ) ;

!+
!  Ring the terminal bell if user requests.
!-

    IF ( .FLAGS AND V_BELL ) NEQ 0
    THEN
	COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;

!+
!  Determine FUNC_VAL - QIO Function Modifiers used by RMS $GET Service.
!  Set TRM$M_TM_NOECHO to suppress echoing of input characters to the terminal.
!  Set TRM$M_TM_ESCAPE to allow Escape sequences to act as terminators (Arrow
!  keys and PF keys and the Professional editing and top row function keys).
!  Set TRM$M_TM_NOFILTR to allow this routine to handle the DELETE KEY. (not a
!  valid terminator).
!  Set TRM$M_TM_TRMNOECHO to suppress echoing of the termination character
!  (COB$$AB_PREV handles advancing / no advancing).
!-

    FUNC_VAL = TRM$M_TM_ESCAPE + TRM$M_TM_NOFILTR + TRM$M_TM_TRMNOECHO 
						  + TRM$M_TM_NOECHO ;

    $ITMLST_INIT (ITMLST = XAB_ITMLST,			! Item list for $GET
		   (ITMCOD = TRM$_MODIFIERS,
		    BUFSIZ = 0,
		    BUFADR = .FUNC_VAL),
		   (ITMCOD = TRM$_TERM,
		    BUFSIZ = 32,			! 32 bytes in TMASK
		    BUFADR = .TMASK[1]) ) ;
!+
!  RMS $GET - expect only terminators.  NOTE:  This $GET call is not the
!  same as the call in routine COB$$RMS_GET.
!-

    WHILE .LEGAL EQL 0 DO
	BEGIN						! Begin Loop

	RAB = .COB$$AL_WRITE_RAB [.UNIT[0]] ;
	RAB [RAB$W_USZ] = 10 ;
	RAB [RAB$L_UBF] = NEXT_CHAR ;
	RAB [RAB$V_ETO] = 1 ;
	RAB [RAB$L_XAB] = XABTRM ;
	WHILE $GET (RAB = .RAB) EQL RMS$_RSA DO $WAIT (RAB = .RAB) ;

	IF NOT .RAB [RAB$L_STS]
	THEN
	    !+
	    !  These are special case status that will be handled later.
	    !  (See note below for explanation of missing RMS$_TNS)
	    !-
	    IF (.RAB [RAB$L_STS] NEQ RMS$_BES AND
	    .RAB [RAB$L_STS] NEQ RMS$_EOF AND
	    .RAB [RAB$L_STS] NEQ RMS$_PES AND
	    .RAB [RAB$L_STS] NEQ RMS$_RTB )
	    THEN
	        LIB$STOP (COB$_ERRDURACC, 1, .RAB + RAB$C_BLN, .RAB [RAB$L_STS],
							 .RAB [RAB$L_STV] ) ;
!+
!  NOTE:  No need for call to COB$$PARTIAL_SEQ as buffer of 10 bytes
!	  is more than sufficient to hold complete escape sequences.
!	  Most key escape sequences are between 1-4 bytes long.
!	  Status RMS$_TNS, terminator not seen, would signal a need to
!	  call routine COB$$PARTIAL_SEQ.
!-
	TERM_PTR = NEXT_CHAR[0] ;

	!+
	!  Check for legal terminator, then copy it to KEY.
	!-

	    IF .RAB [COB$$B_STV2_LEN] EQL 1		! Terminator is one byte
	    THEN
		BEGIN
		TERM_PTR = RAB [COB$$B_STV0_TERM] ;
		SELECTONE .RAB [COB$$B_STV0_TERM] OF
		    SET
			[ CR,	 			! Carriage Return
			  TAB ] :			! Tab

			    BEGIN
			    CH$MOVE ( 1, .TERM_PTR, .KEY [DSC$A_POINTER] ) ;
			    LEGAL = 1 ;
			    END ;

			[OTHERWISE] :			! Error - key not a
							! terminator
			    BEGIN
			    COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;
			    LEGAL = 0 ;
			    END ;
		    TES ;
 		END

	    ELSE
		IF .RAB [RAB$L_STS] EQL RMS$_EOF
		THEN
		    !+
		    !  CONTROL Z  - the status RMS$_EOF is returned
		    !  from the $Get Service.  ^Z is not stored in 
		    !  RAB[RAB$_STV0_TERM].
		    !-

		    BEGIN
		    IF .UNIT [1]  EQL  0
		    THEN
			LIB$STOP ( COB$_EOFON_ACC )	 ! Abort
		    ELSE
			COB$$CONTROL_Z ( .UNIT, .KEY ) ; ! Return to calling
			RETURN 0 ;			 ! program.
		    END
		ELSE
		    !+
		    !  Escape Sequence as Terminator.  COB$$CONTROL_KEY converts
		    !  terminator sequences to COBOL defined sequences and fills
		    !  in KEY parameter if terminator is legal.
		    !- 

		    BEGIN
		    IF NOT ( COB$$CONTROL_KEY (TERM_PTR, .RAB [COB$$B_STV2_LEN],
									 .KEY) )
		    THEN
			BEGIN				! Error, illegal escape
			COB$$RMS_PUT_BYTE ( RING_BELL, .FLAGS ) ;    ! sequence.
			LEGAL = 0 ;
			END
		    ELSE
			LEGAL = 1 ;
		    END ;
	END ;							! End Loop

    !+
    !  VAX COBOL Version 1 / Version 3 interaction.
    !  Determine if ADVANCING is requested.
    !  If bit 10 = 0 advancing.  If bit 10 = 1 no advancing.
    !  Set COB$$AB_PREV[0] - also depending on bit 10, to flag to next COBOL
    !  statement that advancing/no advancing is required following this
    !  ACCEPT statement.
    !-

    IF (.FLAGS AND V_ADV) NEQ 0
    THEN
	COB$$AB_PREV[0] = ACC_DNA			! Signal- Do Not Advance
    ELSE
	!+
	!  Echo carriage return to screen if advancing is called for.
	!-
	BEGIN
	COB$$RMS_PUT_BYTE ( CARR_RET, .FLAGS ) ;
	COB$$AB_PREV[0] = ACC_ADV ;			! Signal- ADVance
	END ;

    RETURN 1 ;
    END ;					! End of routine COB$$FORMAT_FOUR

    END						! End of module COB$ACCEPT
    ELUDOM
