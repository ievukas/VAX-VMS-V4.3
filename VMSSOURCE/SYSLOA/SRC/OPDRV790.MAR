	.TITLE	OPDRV790 - VAX/VMS 11/790 CONSOLE TERMINAL DRIVER
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS I/O SUBSYSTEM
;
; ABSTRACT:
;
;
; AUTHOR: Benn Schreiber, Trudy Matthews
;
; MODIFIED BY:
;
;	V03-011	TCM0009		Trudy C. Matthews	20-Aug-1984
;		Fix input interrupt dispatching through the dispatch table.
;
;	V03-010	TCM0008		Trudy C. Matthews	31-Jul-1984
;		Move routine CON$KEEPALIVE to module MCHECK790.
;
;	V03-009	TCM0007		Trudy C. Matthews	24-Jul-1984
;		Fix some undefined symbols in TCM0006.
;
;	V03-008	TCM0006		Trudy C. Matthews	19-Jul-1984
;		Add routine CON$KEEPALIVE, which is called periodically to
;		determine if the VENUS console software is still functioning.
;		Update the CON$C_xxx console function code definitions.
;		Add TXDB$C_xxx and RXDB$C_xxx definitions for EMM and logical
;		console lines.
;
;	V03-007	WHM0001		Bill Matthews		09-Jul-1984
;		Add routines CON$PUTCHAR, CON$GETCHAR, and CON$INIT_CTY to do
;		non-interrupt driven I/O to the console terminal.
;
;	V03-006	TCM0005		Trudy C. Matthews	20-Jun-1984
;		Add a first pass at handling venus environmental monitor
;		alerts.
;
;	V03-005	TCM0004		Trudy C. Matthews	04-Jun-1984
;		Track changes in the console interface protocol: we can not
;		read or write TXCS unless the "READY" bit is set; also, the
;		"write enable" bit position has changed.  Add routine
;		CON$RELEASECTY.
;
;	V03-004	TCM0003		Trudy C. Matthews	09-Apr-1984
;		Add dummy entry point for CON$RELEASECTY.  The full routine
;		will be added later.
;
;	V03-003	TCM0002		Trudy C. Matthews	13-Dec-1983
;		Add support for the "write enable bit" for line enable mask
;		in VENUS' TXCS in routines CON$SENDCONSCMD and CON$OWNCTY.
;		Modify interface to CON$OWNCTY: it now returns the values
;		that should be restored to TXCS and RXCS when the caller
;		is done with "exclusive" use of the console terminal.
;
;	V03-002	MIR0084		Michael I. Rosenblum	03-Aug-1983
;		Change references to TT_CARRIER and TT_DTR to
;		DZ.  Remove STOP2 entry point and all references to 
;		STOP2.
;
;	V03-001	TCM0001		Trudy C. Matthews	25-Mar-1983
;		Modify CON$OWNCTY to work with 11/790 console interface.
;
;-

;
; SYMBOL DEFINITIONS
;
 
	$CONDEF				;CONSOLE DEFINITIONS
	$CRBDEF				;DEFINE CRB
	$DCDEF				;DEFINE DEVICE CLASSES
	$DDBDEF				;DEFINE DDB
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				;DRIVER PROLOGUE TABLE
	$DYNDEF				;STRUCTURE TYPE CODE DEFINITIONS
	$EMBDEF <HD>			;DEFINE ERRORLOG ENTRY FORMATS
	$IDBDEF				;DEFINE IDB
	$IPLDEF				;DEFINE IPL LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PR790DEF			;DEFINE 11/790 PROCESSOR REGISTERS
	$TTDEF				;DEFINE TERMINAL CHARACTERISTICS
	$UCBDEF				;DEFINE UCB
	$TTYDEFS			;TTY UCB extension(must FOLLOW $UCBDEF)
	$TTYMODEM			;TTY modem definitions
	$TTYMACS			;TTY macro definitions
	$VECDEF				;DEFINE CRB VECTOR
	$WCBDEF				;Define WCB
;
; TXCS REGISTER DEFINITIONS
;
	$DEFINI	TXCS

$DEF	TXS		.BLKL	1	;TXCS REGISTER

	_VIELD	TXS,0,<-		;DEFINE FIELDS TXS_M_XXX
		<,6>,-			;MBZ BITS
		<IE,,M>,-		;INTERRUPT ENABLE BIT
		<RDY,,M>,-		;READY BIT
		<ID,4,M>,-		;ID FIELD
		<,3>,-			;MBZ BITS
		<WRTENA,,M>,-		;ENABLE WRITE TO TXCS MASK FIELD
		<TEM,8,M>,-		;TRANSMITTER ENABLE MASK
		>
	.=TXS
	_VIELD	TXS,0,<-		;TRANSMITTER ENABLE MASK BITS
		<,16>,-			;SKIP TO TRANSMIT ENABLE MASK FIELD
		<CONSTERM,,M>,-		;CONSOLE TERMINAL
		<REMPORT,,M>,-		;REMOTE SERVICES PORT
		<EMM,,M>,-		;ENVIRONMENTAL MONITOR
		<LOGCONS,,M>,-		;LOGICAL CONSOLE
		>
	$DEFEND	TXCS

;
; DEFINE CONSTANTS FOR TXDB DATA:
;
; THE FOLLOWING VALUES CAN BE SENT ON THE EMM LINE.
;
TXDB$C_EMM_STATUS = 0			;REQUEST FOR EMM STATUS
TXDB$C_EMM_ENV = 1			;REQUEST FOR SYSTEM ENVIRONMENT INFO
TXDB$C_EMM_MARGIN = 16			;COMMAND TO SET MARGIN REGULATORS
TXDB$C_EMM_CANCEL = 17			;CANCEL EMM REQUESTS ON INTERFACE
;
; THE FOLLOWING VALUES CAN BE SENT ON THE LOGICAL CONSOLE LINE.
;
TXDB$C_LOG_EXWARM = ^X10		; EXAMINE WARMSTART FLAG
TXDB$C_LOG_EXCOLD = ^X11		; EXAMINE COLDSTART FLAG
TXDB$C_LOG_EXUCODE = ^X12		; EXAMINE MICROCODE VERSION LEVEL
TXDB$C_LOG_SNDDIAG = ^X20		; SEND DIAGNOSTIC COMMAND STRING
TXDB$C_LOG_REQERL = ^X30		; REQUEST ERRORLOG DATA
TXDB$C_LOG_INVSNP1 = ^X31		; INVALIDATE ERRORLOG SNAPSHOT 1
TXDB$C_LOG_INVSNP2 = ^X32		; INVALIDATE ERRORLOG SNAPSHOT 2
TXDB$C_LOG_CANCEL = ^X70		; CANCEL CURRENT AND QUEUED REQUESTS

;
; RXCS REGISTER DEFINITIONS
;
	$DEFINI	RXCS

$DEF	RXS	.BLKL	1		;RXCS REGISTER
	_VIELD	RXS,0,<-
		<,6>,-			;MBZ BITS
		<IE,,M>,-		;INTERRUPT ENABLE BIT
		<DONE,,M>,-		;DONE BIT
		<,8>,-			;MBZ BITS
		<DTR,8,M>,-		;LOGICAL DTR BITS
		>
	.=RXS
	_VIELD	RXS,0,<-		;LOGICAL DTR BITS
		<,16>,-			;SKIP TO THE LOGICAL DTR FIELD
		<CONSTERM,,M>,-		;CONSOLE TERMINAL
		<REMPORT,,M>,-		;REMOTE SERVICES PORT
		<EMM,,M>,-		;ENVIRONMENTAL MONITOR
		<LOGCONS,,M>,-		;LOGICAL CONSOLE
		>
	$DEFEND	RXCS
;
; CONSOLE RXDB REGISTER
;
	$DEFINI	RXDB

$DEF	RXD		.BLKL	1	;RXDB RECEIVER DATA REGISTER
	_VIELD	RXD,0,<-
		<DATA,8>,-		;8 BITS OF DATA
		<ID,4>,-		;4 BITS OF ID
		<,4>,-			;SKIP 4 BITS OF MBZ
		<CARRIER,8>,-		;LOGICAL CARRIER
		>
	$DEFEND	RXDB
;
; DEFINE DATA VALUES THAT CAN BE RECIEVED ON THE EMM AND LOGICAL CONSOLE
; LINES.
;
; THE FOLLOWING RXDB VALUES MAY BE RECEIVED ON THE LOGICAL CONSOLE LINE:
;
RXDB$C_LOG_WRMFLG = 16			;RETURNING VALUE FOR WARMSTART FLAG
RXDB$C_LOG_CLDFLG = 17			;RETURNING VALUE FOR COLDSTART FLAG
RXDB$C_LOG_UCODE = 18			;RETURNING MICROCODE VERSION
RXDB$C_LOG_CMDCMP = 32			;CONSOLE COMMAND STRING COMPLETE
RXDB$C_LOG_CMDERR = 130			;CONSOLE COMMAND STRING ERROR
RXDB$C_LOG_SNAP = 48			;SNAPFILE STATUS RETURNED
RXDB$C_LOG_REBOOT = 64			;CONSOLE REBOOT SUCCESSFUL

	.SBTTL	  CONSOLE RECEIVE DISPATCH VECTOR

	.PSECT	SYSLOA,LONG

;
; THE INTERRUPT ROUTINE ADDRESSES FOR EACH OF THE DEVICES THAT SHARE THE
; RXCS/RXDB REGISTER ARE LOADED INTO THIS TABLE BY THE UNIT INITIALIZATION
; ROUTINE FOR EACH DEVICE.  CON$INITIAL SETS THE CELLS FOR THE CONSOLE
; TERMINAL, THE ENVIRONMENTAL MONITOR, THE UNUSED VECTORS, AND THE CARRIER
; CHANGE INTERRUPT TYPE.
;
CON$INPDISTAB:
	.LONG	0			;ID 0 - CONSOLE TERMINAL
	.LONG	0			;ID 1 - REMOTE SERVICE PORT
	.LONG	0			;ID 2 - ENVIRONMENTAL MONITOR
	.LONG	0			;ID 3 - LOGICAL CONSOLE
	.LONG	0[11]			;IDS 4-14 - UNUSED, RESERVED TO DIGITAL
	.LONG	0			;ID 15 - CARRIER CHANGE NOTIFICATION

	.SBTTL	CONSOLE CONTROLLER INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE CONTROLLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE CONTROLLER.
;
; INPUTS:
;
;	R5 = IDB ADDRESS
;	R6 = DDB ADDRESS
;	R8 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED, EXCEPT R0, R1.
;--
CON$INITIAL::				;INITIALIZE CONSOLE INTERFACE
	TSTL	CRB$L_AUXSTRUC(R8)	;HAVE WE PASSED THIS WAY BEFORE?
	BNEQ	30$			;BRANCH IF SO

	MOVAB	W^CON$INPDISTAB,R0	;POINT TO THE CONSOLE DISPATCH TABLE
	MOVL	R0,CRB$L_AUXSTRUC(R8)	;SET POINTER IN CRB
	MOVAB	W^INT_CONSOLINP,(R0)	;STORE CONSOLE INTERRUPT ROUTINE
	MOVL	(R0)+,(R0)+		;SAME ROUTINE FOR REMOTE SERVICES PORT
	MOVAB	W^INT_EMMINP,(R0)+	;STORE EMM INTERRUPT RTN
	MOVAB	W^INT_LOGINP,(R0)+	;STORE LOGICAL CONSOLE INTERRUPT RTN
	MOVL	#11,R1			;SET NUMBER OF VECTORS TO INITIALIZE
10$:	MOVAB	W^INT_IGNOREINP,(R0)+	;STORE INGORE INTERRUPT ROUTINE
	SOBGTR	R1,10$			;DO ALL
	MOVAB	W^INT_CARCHANGE,(R0)	;STORE CARRIER CHANGE INTERRUPT ADDR

	MFPR	#PR$_RXDB,R0		;READ CURRENT RECEIVER STATUS
	ASHL	#<-RXD_V_CARRIER>,R0,R0	;POSITION CARRIER BYTE TO LOW BYTE
	MOVB	R0,CRB$B_DZ_CARRIER(R8)	;SAVE INITIAL STATUS
	CLRB	IDB$B_TT_ENABLE(R5)	;CLEAR TRANSMIT ENABLE MASK
	MOVB	#<RXS_M_EMM!RXS_M_LOGCONS>@<-RXS_V_DTR>,-
		CRB$B_DZ_DTR(R8)	;SETUP INITIAL LOGICAL DTR
	MOVZBL	CRB$B_DZ_DTR(R8),R0	;GET LOGICAL DTR
	ASHL	#RXS_V_DTR,R0,R0	;POSITION IN REGISTER
	BISL2	#RXS_M_IE,R0		;SET INTERRUPT ENABLE
	MTPR	R0,#PR$_RXCS		;ENABLE THE LINES
30$:
CON_RETURN:
	RSB

	.SBTTL	CONSOLE UNIT INITIALIZATION
;++
; CON$INITLINE - INITIALIZE CONSOLE UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE UNITS.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	REGISTERS R4,R5 PRESERVED
;--
CON$INITLINE::
	BBSS	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),2$ ;ENSURE DEVICE IS MODEM
2$:	BBSS	#TT$V_MODEM,UCB$L_TT_DECHAR(R5),4$
4$:	MOVL	G^TTY$GL_DPT,R1		;ADDRESS OF CLASS DPT
	MOVZWL	DPT$W_VECTOR(R1),R0	;LOCATE CLASS DRIVER VECTOR TABLE
	ADDL	R0,R1			;RELOCATE BASE ADDRESS
	MOVL	R1,UCB$L_TT_CLASS(R5)	;SET TERMINAL CLASS DRIVER VECTOR
	MOVL	CLASS_GETNXT(R1),UCB$L_TT_GETNXT(R5)
	MOVL	CLASS_PUTNXT(R1),UCB$L_TT_PUTNXT(R5)
	MOVL	UCB$L_DDB(R5),R0	;GET DDB ADDRESS
	MOVL	CLASS_DDT(R1),DDB$L_DDT(R0)
	MOVL	CLASS_DDT(R1),UCB$L_DDT(R5) ;SET DDT ADDRESS IN UCB

	MOVAB	G^OP$DPT,R0		;GET ADDRESS OF CONSOLE DPT
	MOVZWL	DPT$W_VECTOR(R0),R1	;OFFSET TO CONSOLE PORT VECTOR DISPATCH TABLE
	ADDL3	R1,R0,UCB$L_TT_PORT(R5)	;SET ADDRESS IN UCB

	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET ONLINE
	ASHL	UCB$W_UNIT(R5),#1,R0	;BUILD UNIT'S BIT MASK
	MOVW	R0,UCB$W_TT_UNITBIT(R5)	;SAVE IT IN UCB
	TSTW	UCB$W_REFC(R5)		;REFCOUNT 0?
	BNEQ	20$			;IF NEQ THEN NO SET UP

	MOVL	UCB$L_TT_CLASS(R5),R0	;ADDRESS OF CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R0)	;INITIALIZE THE UCB FOR CONSOLE TERM.

20$:	CLRB	UCB$B_TT_DS_RCV(R5)	;CLEAR RECEIVE STATUS
	MFPR	#PR$_RXDB,R0		;READ CURRENT STATUS
	ASHL	#<-RXS_V_DTR>,R0,R0	;POSITION CARRIER BYTE
	BITB	R0,UCB$W_TT_UNITBIT(R5)	;CARRIER UP FOR THIS LINE?
	BEQL	25$			;BRANCH IF NOT
	MOVB	#<TT$M_DS_CARRIER!TT$M_DS_DSR!TT$M_DS_CTS!TT$M_DS_RING>,-
			UCB$B_TT_DS_RCV(R5) ;YES, SET IT AND BITS ALWAYS SET
25$:	MOVZBL	#MODEM$C_INIT,R1	;SET TO INIT MODEM PROTOCOL
	TSTW	UCB$W_REFC(R5)		;ANY CHANNELS ATTACHED?
	BEQL	30$			;IF EQL NO
	MOVZBL	#MODEM$C_SHUTDWN,R1	;FORCE MODEM HANGUP
30$:	MOVL	UCB$L_TT_CLASS(R5),R0	;ADDRESS CLASS VECTOR TABLE
	PUSHL	R2			;SAVE R2 OVER DS_TRAN
	JSB	@CLASS_DS_TRAN(R0)	;INVOKE DATA SET TRANSITION
	POPL	R2			;RESTORE R2
40$:	BBC	#UCB$V_POWER,UCB$W_STS(R5),50$ ;DID WE DETECT A POWERFAIL?
	MOVL	UCB$L_TT_CLASS(R5),R0	;YES, GET CLASS VECTOR TABLE ADDRESS
	JMP	@CLASS_POWERFAIL(R0)	;AND GO TO THE POWERFAIL CODE
50$:
CON$SET_LINE::
CON$SET_MODEM::
CON$NULL::
CON$INIT_CTY::
	RSB

	.SBTTL	CON$DISCONNECT DISCONNECT LINE
;++
; CON$DISCONNECT - SHUT OFF UNIT
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS USED WHEN FOR SOME REASON THE UNIT MUST BE DISCONNECTED
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4 ARE USED
;--

CON$DISCONNECT::
	PUSHR	#^M<R0,R1,R2>
	MOVL	#MODEM$C_SHUTDWN,R1	;SET MODEM SHUTDOWN
	MOVL	UCB$L_TT_CLASS(R5),R0	;ACCESS CLASS VECTOR TABLE
	JSB	@CLASS_DS_TRAN(R0)	;INVOKE MODEM TRANSITION ROUTINE
	POPR	#^M<R0,R1,R2>		;RESTORE REGISTERS
	RSB

	.SBTTL	OUTPUT MODEM CONTROL
;++
; CON$DS_SET - SET OUTPUT MODEM SIGNALS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE OUTPUT MODEM SIGNALS FOR THE SPECIFIED UNIT
;
; INPUTS:
;
;	R2 = LOW BYTE - SIGNALS TO ACTIVATE
;	     HIGH BYTE - SIGNALS TO DEACTIVATE
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R0-R3 ARE USED.
;--
CON$DS_SET::
	BISB2	R2,UCB$B_TT_DS_TX(R5)	;SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		;ACCESS SIGNALS TO RESET
	BICB2	R2,UCB$B_TT_DS_TX(R5)	;RESET THEM
	MOVL	UCB$L_CRB(R5),R3	;GET CRB ADDRESS
	EXTZV	#TT$V_DS_DTR,#1,UCB$B_TT_DS_TX(R5),R1 ;GET CURRENT DTR FOR LINE
	ASHL	UCB$W_UNIT(R5),R1,R1	;SHIFT TO RELATIVE LINE POSITION
	BICB2	UCB$W_TT_UNITBIT(R5),CRB$B_DZ_DTR(R3) ;RESET CURRENT DTR FOR LINE
	BISB2	R1,CRB$B_DZ_DTR(R3)	;SET IT IF NEED BE
	MOVZBL	CRB$B_DZ_DTR(R3),R0	;GET NEW DTR BITS
	ASHL	#RXS_V_DTR,R0,R0	;SHIFT INTO POSITION
	BISL2	#RXS_M_IE,R0		;SET INTERRUPT ENABLE ALWAYS
	MTPR	R0,#PR$_RXCS		;SET NEW DTR SIGNALS
	RSB

	.SBTTL CONSOLE RECEIVER INTERRUPT DISPATCHER
;++
; CON$INTINP - CONSOLE INTERRUPT ON INPUT READY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AS A RESULT OF A RECEIVER INTERRUPT ON THE
; CONSOLE INTERFACE. THE INTERRUPT CAN BE GENERATED BY THE CONSOLE
; TERMINAL, REMOTE SERVICES PORT, ENVIRONMENTAL MONITOR, OR THE
; 11/790 LOGICAL CONSOLE.
;
; CONSOLE TERMINAL:
; REMOTE SERVICES PORT:
;			ALL RECEIVED DATA CHARACTERS ARE CONSIDERED
;			UNSOLICITED AND RESULT IN AN ENTRY INTO THE
;			TERMINAL DRIVER COMMON CHARACTER BUFFERING
;			ROUTINE "@UCB$L_TT_PUTNXT(R5)".
;
; ENVIRONMENTAL MONITOR:
;
;			INTERRUPT CAN EITHER BE AN ALERT FOR TEMPERATURE
;			OR BLOWER, OR A PERIODIC SAMPLING.
;
; LOGICAL CONSOLE:
;
;			TEST FOR NOTIFICATION THAT THE CONSOLE WAS REBOOTED
;			SUCCESSFULLY; IF SO, LOG THE EVENT.  THERE IS
;			CURRENTLY NO OTHER FULL DRIVER SUPPORT FOR THE LOGICAL
;			CONSOLE LINE.
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
	.ENABLE	LOCAL_BLOCK

CON$INTINP::
	MFPR	#PR$_RXDB,R3		;MOVE DATA FROM INTERFACE
;
; GET THE ASSOCIATED UCB
;
	MOVL	@(SP)+,R4		;GET IDB ADDRESS
	ASHL	#-8,R3,R2		;GET LINE NUMBER
	BICW	#^C<^XF>,R2		;
;
; SEE IF A UCB IS ASSOCIATED WITH THE LINE.  CURRENTLY, THE LOCAL CONSOLE
; UCB IS ALWAYS PRESENT, AND SYSGEN SUPPORTS ADDING A UCB FOR THE REMOTE
; CONSOLE, ENVIRONMENTAL MONITOR (EMM), AND LOGICAL CONSOLE LINES.  HOWEVER,
; THERE IS CURRENTLY NO USER-REQUESTED TRANSFER SUPPORT FOR THE EMM OR
; LOGICAL CONSOLE IN OPDRV790.  BUT WE MUST DISPATCH THE EMM AND LOGICAL
; CONSOLE INTERRUPTS TO ROUTINES THAT CHECK FOR CERTAIN UNSOLICITED MESSAGES,
; SUCH AS ENVIRONMENTAL ALERT CONDITIONS AND "CONSOLE REBOOT SUCCESSFUL"
; MESSAGES.
;
	BITW	#^XE,R2			;IS IT A DEVICE INTERRUPT?
					; (IDS 0-1 MAY HAVE A UCB ASSOCIATED)
	BNEQ	7$			;IF NEQ NO. SKIP UCB TEST
5$:	MOVL	IDB$L_UCBLST(R4)[R2],R5	;GET THE UCB ADDRESS
	BEQL	30$			;NO UCB - DISMISS INTERRUPT
7$:	MOVAL	W^CON$INPDISTAB[R2],R0	;GET ADDRESS TO VECTOR TO
	JMP	@(R0)			;DISPATCH TO PROCESS INTERRUPT
;
;CONSOLE TERMINAL INTERRUPT
;
INT_CONSOLINP:
	MOVZBL	R3,R3			;ZERO TOP 3 BYTES
	JSB	@UCB$L_TT_PUTNXT(R5)	;BUFFER THE CHARACTER
	BEQL	30$			;IF EQL THEN NO CHARACTER TO OUTPUT
20$:	BSBW	CON$STARTIO		;OUTPUT THE CHARACTER
30$:	BRW	DISMIS			;GO

	.DISABLE LOCAL_BLOCK

	.SBTTL	ENVIRONMENTAL MONITOR INPUT INTERRUPT
;++
; FUNCTIONAL DESCRIPTION:
;
; THE CONSOLE INTERRUPTS ON THIS LINE TO WARN OF ENVIRONMENTAL CONDITIONS
; SUCH AS TEMPERATURE OR VOLTAGE OUT OF ACCEPTABLE RANGES.  LOG THE
; WARNING AND SEND A MESSAGE TO THE CONSOLE TERMINAL.
;
; INPUTS:
;	R3	- CONTENTS OF PR$_RXDB REGISTER
;--

;
; LOCAL DATA USED FOR EMM ALERT MESSAGES.
;
EMM_MESSAGE:
	.ASCII	<13><10><10><7><7><7>-
\%SYSTEM, Environmental Alert - Environmental Monitor has detected \-
<13><10>-
\an alert condition.  Please check the error log.\-
<13><10>

SHUTDOWN_MESSAGE:
	.ASCII	-
\Total system power shutdown pending if condition is not corrected.\<13><10>

SHUTDOWN_MSGLEN:
	.WORD	SHUTDOWN_MSGLEN - SHUTDOWN_MESSAGE
EMM_MSGLEN:
	.WORD	SHUTDOWN_MESSAGE - EMM_MESSAGE
EMM_BUFFER:				; LENGTH OF ALERT MESSAGES IS 2 BYTES
	.WORD	0
EMM_IGNORECNT:				; HOW MANY BYTES TO IGNORE
	.BYTE	0

;
; EMM FLAGS BYTE AND THE FLAG BIT DEFINITIONS
;
EMM_FLAGS:				; TO HELP KEEP TRACK OF WHERE WE ARE IN
	.BYTE	0			; THE PROTOCOL
EMM_IN_PROGRESS = 0
EMM_V_SHUTDOWN = 1
EMM_V_IGNOREINP = 2
EMM_V_BYTECOUNT = 3
;
; DEFINE FORMAT OF FIRST BYTE OF EMM ALERT MESSAGE:
;
;	<07>	- WHEN SET, THIS IS AN EMM ALERT CONDITION, AS OPPOSED TO
;		  DATA RETURNED IN RESPONSE TO A REQUEST
;	<06>	- WHEN SET, THIS IS AN AUTOMATIC SHUTDOWN CONDITION.  IF THE
;		  CONDITION IS NOT CLEARED IN A SMALL NUMBER OF MINUTES (1-2),
;		  THE CPU WILL BE POWERED DOWN.
;	<05>	- RESERVED FOR FUTURE USE.  NOT GUARANTEED TO BE ZERO.
;	<04:00>	- IDENTIFIES WHICH ALERT CONDITION IS BEING SIGNALLED
;
EMM_V_ALERT = 7
EMM_V_ASD = 6
EMM_V_CONDITION = 0
EMM_S_CONDITION = 5
;
; DISPATCH HERE FOR INPUT INTERRUPT FROM EMM
;
INT_EMMINP:
	BBS	#EMM_V_IGNOREINP, -	; BRANCH IF WE ARE IGNORING THIS
		EMM_FLAGS, -		; MESSAGE
		EMM_IGNORE_DATA
	BBSS	#EMM_IN_PROGRESS, -	; BRANCH IF THIS IS NOT THE FIRST BYTE
		EMM_FLAGS, -		; OF AN EMM MESSAGE
		EMM_LAST_BYTE
;
; HANDLE THE FIRST BYTE OF AN ENVIRONMENTAL MONITOR ALERT MESSAGE
;
EMM_FIRST_BYTE:
	BBC	#EMM_V_ALERT,R3,-	; DON'T HANDLE RESPONSES TO EMM REQUESTS
		EMM_RESPONSE		; YET
	CLRW	EMM_BUFFER		; ZERO THE BUFFER
	BBC	#EMM_V_ASD,R3,10$	; BRANCH IF NOT AUTOMATIC SHUTDOWN
					; CONDITION
	BBSS	#EMM_V_SHUTDOWN,-	; FLAG AN AUTOMATIC SHUTDOWN SO IT
		EMM_FLAGS,10$		; CAN BE REPORTED TO THE CONSOLE TERM
10$:	MOVB	R3,EMM_BUFFER		; BUFFER THIS BYTE OF DATA
	BRB	DISMIS_EMM		; DISMISS THIS INTERRUPT
;
; HANDLE LAST BYTE OF AN EMM MESSAGE HERE.  WRITE AN ERRORLOG ENTRY AND
; BROADCAST A WARNING TO THE CONSOLE TERMINAL.
;
EMM_LAST_BYTE:
	MOVB	R3,EMM_BUFFER+1		; PUT THE DATA IN 2ND BYTE OF THE BUFFER
	MOVL	#EMB$C_HD_LENGTH+2,R1	; SIZE OF ERRORLOG BUFFER TO ALLOCATE
	JSB	G^ERL$ALLOCEMB		; ALLOCATE ERRORLOG BUFFER
	BLBC	R0,BROADCAST		; BRANCH IF NO BUFFER AVAILABLE
	MOVW	#EMB$C_EMM,EMB$W_HD_ENTRY(R2)
					; SET THE ERRORLOG TYPE
	MOVW	EMM_BUFFER,EMB$C_HD_LENGTH(R2)
					; MOVE THE DATA INTO THE ERRORLOG BUFFER
	JSB	G^ERL$RELEASEMB		; RELEASE THE ERRORLOG DATA
BROADCAST:
	MOVZWL	EMM_MSGLEN,R1		; LENGTH OF THE MESSAGE
	BBCC	#EMM_V_SHUTDOWN, -	; BRANCH IF THIS IS NOT AN AUTOMATIC
		EMM_FLAGS,10$		; SHUTDOWN CONDITION
	ADDW	SHUTDOWN_MSGLEN,R1	; ADD SHUTDOWN MESSAGE TO BROADCAST
10$:	MOVAB	EMM_MESSAGE,R2		; ADDRESS OF MESSAGE
	MOVAB	G^OPA$UCB0,R5		; SEND IT TO THE CONSOLE TERMINAL
	JSB	G^IOC$BROADCAST		; BROADCAST THE MESSAGE
EMM_ALERT_DONE:
	BBCC	#EMM_IN_PROGRESS,-	; FINISHED WITH THIS EMM MESSAGE
		EMM_FLAGS,DISMIS_EMM
DISMIS_EMM:
	BRW	DISMIS
;
; WE GET HERE ONLY IF WE'RE FAIRLY MIXED UP: WE DON'T SUPPORT REQUESTING DATA
; FROM THE EMM BUT THE EMM LINE IS GIVING US A RESPONSE TO A DATA REQUEST.
; READ THE BYTECOUNT AND IGNORE THAT MANY BYTES OF DATA FROM THE EMM LINE.
;
EMM_RESPONSE:
	BBSS	#EMM_V_IGNOREINP, -	; SIGNAL WE'RE GETTING AN EMM RESPONSE
		EMM_FLAGS,10$
10$:	BBSS	#EMM_V_BYTECOUNT, -	; SIGNAL THE NEXT BYTE SHOULD BE THE
		EMM_FLAGS,20$		; MESSAGE BYTE COUNT
20$:	BRB	DISMIS_EMM

EMM_IGNORE_DATA:
	BBCC	#EMM_V_BYTECOUNT, -	; BRANCH IF THIS IS NOT THE BYTECOUNT
		EMM_FLAGS,10$		; BYTE
	MOVB	R3,EMM_IGNORECNT	; SAVE NUMBER OF BYTES TO IGNORE
	BRB	DISMIS_EMM		; THAT'S IT FOR THIS BYTE
10$:
	DECB	EMM_IGNORECNT		; COUNT DOWN ONE MORE BYTE
	BNEQ	DISMIS_EMM		; BRANCH IF STILL MORE TO IGNORE
	BBCC	#EMM_V_IGNOREINP, -	; CLEAR THE "IGNORE EMM DATA" FLAG
		EMM_FLAGS,20$		;
20$:	BRB	DISMIS_EMM		; THAT'S IT

	.SBTTL	LOGICAL CONSOLE INPUT INTERRUPTS
;++
;INT_LOGINP - HANDLE LOGICAL CONSOLE INPUT INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
; ONLY ONE TYPE OF LOGICAL CONSOLE INTERRUPT-LEVEL INPUT IS CURRENTLY HANDLED:
; AN UNSOLICITED MESSAGE SIGNALLING THAT THE CONSOLE WAS RE-BOOTED SUCCESSFULLY.
; THE CONSOLE CAN BE RE-BOOTED BY THE ROUTINE CON$KEEPALIVE IF IT DETECTS THAT
; THE CONSOLE HAS DIED.  CON$KEEPALIVE WILL WRITE A MESSAGE TO THE SYSTEM
; ERRORLOG NOTING THAT IT HAS ATTEMPTED TO RE-BOOT THE CONSOLE.  IF THE
; REBOOT IS SUCCESSFUL, THIS ROUTINE WILL WRITE ANOTHER MESSAGE TO THE
; ERRORLOG SIGNALLING THE SUCCESSFUL REBOOT.
;
; INPUTS:
;	R3	- CONTENTS OF PR$_RXDB REGISTER
;--
INT_LOGINP:
	CMPB	R3,#RXDB$C_LOG_REBOOT	; Console reboot message?
	BNEQ	DISMIS_LOG		; Branch if not.
	MOVL	#EMB$C_HD_LENGTH+1,R1	; Allocate a header plus one byte.
	JSB	G^ERL$ALLOCEMB		; Allocate space in the errorlog buffer.
	BLBC	R0,DISMIS_LOG		; Branch if unable to allocate.
	MOVW	#EMB$C_CRBT, -		; Set entry type = console reboot.
		EMB$W_HD_ENTRY(R2)	;
	MOVB	#1,EMB$W_HD_ENTRY+1(R2)	; Set flag = reboot successful.
	JSB	ERL$RELEASEMB		; Release the errorlog data.
DISMIS_LOG:	
	BRW	DISMIS

	.SBTTL	START I/O ON CONSOLE INTERFACE
;++
;CON$STARTIO - START I/O ON CONSOLE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO OUTPUT A CHARACTER TO THE CONSOLE INTERFACE.
; THE DATA IS QUEUED AND SUBSEQUENTLY OUTPUT ON THE NEXT READY INTERRUPT.
;
; A RETURN TO THE CALLER IS DONE TO ENTER A "WAIT FOR INTERRUPT" STATE.
;
; INPUTS:
;
;	R3 = DATA TO OUTPUT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4,R5 ARE PRESERVED.
;--

	.ENABLE	LOCAL_BLOCK
CON$STARTIO::
	BGEQ	20$			;BRANCH IF SINGLE CHARACTER
	BISW2	#TTY$M_TANK_BURST,-	;FLAG BURST MODE ACTIVE
			UCB$W_TT_HOLD(R5)
START_TERM_IO:
10$:	MOVL	UCB$L_CRB(R5),R1	;GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R1 ;GET IDB ADDRESS
	BISB2	UCB$W_TT_UNITBIT(R5),IDB$B_TT_ENABLE(R1) ;CREATE NEW XMT ENABLE MSK
	MOVZBL	IDB$B_TT_ENABLE(R1),R1	;GET ENABLE MASK FOR THIS DEVICE
	ASHL	#TXS_V_TEM,R1,R1	;POSITION TO FIELD
	BISL2	#TXS_M_IE!TXS_M_WRTENA,R1 ;SET INTERRUPT ENABLE
	BISB2	#UCB$M_INT,UCB$W_STS(R5);FLAG INTERRUPT EXPECTED

	DSBINT	#^X14			;MAKE FOLLOWING TEST AND SET ATOMIC
15$:	MFPR	#PR$_TXCS,R0		;READ TRANSMIT STATUS
	BBC	#TXS_V_RDY,R0,15$	;WAIT 'TIL WE HAVE A VALID COPY
	MTPR	R1,#PR$_TXCS		;ENABLE THIS DEVICE
	ENBINT
	RSB				;RETURN WITH INTERRUPT EXPECTED

20$:	MOVB	R3,UCB$W_TT_HOLD(R5)	;SAVE OUTPUT CHARACTER
	BISW2	#TTY$M_TANK_HOLD,-	;SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BRB	10$			;GO ENABLE INTERRUPT
	.DISABLE LOCAL_BLOCK

	.SBTTL	CARRIER CHANGE SENT BY CONSOLE
;++
; FUNCTIONAL DESCRIPTION:
;
; DISPATCH TO HERE IF THE CONSOLE IS TELLING US ABOUT A CHANGE IN
; CARRIER STATUS
;
;--

INT_CARCHANGE:
	MOVL	IDB$L_UCBLST(R4),R5	;GET ADDRESS OF CONSOLE UCB
	MOVL	UCB$L_CRB(R5),R4	;GET CRB ADDRESS IN R4
	ASHL	#-16,R3,R3		;POSITION CARRIER BITS FROM RXDB REG
	XORB3	CRB$B_DZ_CARRIER(R4),R3,R2 ;FIND CHANGED BITS
	MOVB	R3,CRB$B_DZ_CARRIER(R4)	;SAVE STATE OF LOGICAL CARRIER
;
; PROCESS LINES WITH CARRIER CHANGE
;
20$:	FFS	#0,#8,R2,R1		;FIND A LINE
	BEQL	50$			;IF EQL NO MORE
	BBC	R1,R2,30$		;CLEAR BIT
30$:	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R5 ;GET IDB ADDRESS
	MOVL	IDB$L_UCBLST(R5)[R1],R5	;GET CORRESPONDING UCB ADDR FOR UNIT
	BEQL	20$			;BRANCH IF NO UCB
	BSBB	REPORT_CARCHANGE	;REPORT THE CARRIER CHANGE
	BRB	20$			;CONTINUE SCANNING
50$:
BR_DISMIS:
	BRW	DISMIS			;DISMISS THE INTERRUPT
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE REPORTS A CHANGE IN CARRIER STATUS TO THE TERMINAL
; CLASS DRIVER
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R4 = CRB ADDRESS
;
; OUTPUTS:
;
;	DATASET TRANSITION REPORTED TO CLASS DRIVER
;
;	REGISTERS R0,R1,R2 DESTROYED, ALL OTHERS PRESERVED
;--
REPORT_CARCHANGE:
	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),20$ ; BRANCH IF NOT TERMINAL
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),20$ ;BRANCH IF NOT MODEM
	EXTZV	R1,#1,CRB$B_DZ_CARRIER(R4),R0 ;GET CARRIER BIT FOR THIS LINE
	INSV	R0,#TT$V_DS_CARRIER,#1,-;SET/CLEAR IN UCB
			UCB$B_TT_DS_RCV(R5)
	BISB3	#<TT$M_DS_DSR!TT$M_DS_CTS!TT$M_DS_RING>,-
			R1,UCB$B_TT_DS_RCV(R5) ;SET BITS WHICH ARE ALWAYS SET
	MOVZBL	UCB$B_TT_DS_RCV(R5),R2	;GET CURRENT RCV MODEM STATUS
	MOVZBL	#MODEM$C_DATASET,R1	;SIGNAL DATASET TRANSITION
	MOVL	UCB$L_TT_CLASS(R5),R0	;GET CLASS VECTOR TABLE
	PUSHR	#^M<R1,R2,R3,R4>	;SAVE VOLATILE REGISTERS
	JSB	@CLASS_DS_TRAN(R0)	;SIGNAL DATASET TRANSITION
	POPR	#^M<R1,R2,R3,R4>	;RESTORE REGISTERS
20$:	RSB				;RETURN TO CALLER

	.SBTTL	CONSOLE TRANSMITTER INTERRUPT SERVICE
;++
; CON$INTOUT - CONSOLE TRANSMITTER INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CONSOLE UNIT READY INTERRUPT OCCURS.
;
; THE INTERRUPT STATE OF THE UNIT IS CHECKED FOR EXPECTED INTERRUPT.
; IF NO INTERRUPT IS EXPECTED, THE INTERRUPT IS DISMISSED. IF AN INTERRUPT
; IS EXPECTED THEN THE DRIVER IS ENTERED. IN THE CASE OF THE CONSOLE TERMINAL,
; A SPECIFIC ROUTINE IS ENTERED TO GET THE NEXT CHARACTER AVAILABLE TO OUTPUT
; ON THE UNIT.
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
CON$INTOUT::				;
	MOVL	@(SP)+,R0		;GET ADDRESS OF IDB
;
; Note that R0 contains the address of the IDB throughout this routine.
;
	MFPR	#PR$_TXCS,R3		;READ STATUS REGISTER
	ASHL	#-8,R3,R3		;EXTRACT ID FIELD
	BICL2	#^C<^XF>,R3		;CLEAR UNINTERESTING BITS
	MOVL	IDB$L_UCBLST(R0)[R3],R5	;GET ADDRESS OF UCB
	BEQL	DISMIS			;BRANCH IF NO UCB
	CASE	R3,-			;DISPATCH TO PROCESS
		<INTOUT_TERM,INTOUT_TERM>,-
		TYPE=B
INT_IGNOREINP:
DISMIS:					;
	MOVQ	(SP)+,R0		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;
;
; DEVICE IS A TERMINAL, EITHER THE CONSOLE OR THE REMOTE SERVICES PORT
;
INTOUT_TERM:
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	;ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	CON_BURST		;YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-			;DISPATCH
		CON_PREMPT,-			;SEND PREMPT CHARACTER
		CON_STOP,-			;STOP OUTPUT
		CON_CHAR,-			;CHAR IN TANK
		CON_BURST,-			;BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5) ;CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	;GET THE NEXT CHARACTER
	CASEB	UCB$B_TT_OUTYPE(R5),#-1,#1 ;OPTIMIZE FOR THE SINGLE CHARACTER 
					;BY SETTING THE LIMIT TO 1
40$:	.WORD	CON_START_BURST-40$	;BURST SPECIFIED
	.WORD	CON_RESET_IE-40$	;NONE
;
; OUTPUT A CHARACTER TO THE CONSOLE
;
20$:	MOVZBL	R3,R3			;ENSURE ALL ZEROES
	MTPR	R3,#PR$_TXDB		;OUTPUT CHARACTER
	BRB	DISMIS
;
; DISABLE OUTPUT ON THIS LINE
;
50$:
CON_RESET_IE:
	BBS	#UCB$V_INT,-		;IF INT EXP, THEN DON'T RESET,
		UCB$W_STS(R5),DISMIS	; COULD HAVE BEEN SET DURING CALLBACK
	BICB2	UCB$W_TT_UNITBIT(R5),IDB$B_TT_ENABLE(R0) ;CLEAR THIS DEVICE
	MOVZBL	IDB$B_TT_ENABLE(R0),R1	;GET NEW ENABLE MASK BITS
	ASHL	#TXS_V_TEM,R1,R1	;POSITION
	BISL2	#TXS_M_IE!TXS_M_WRTENA,R1 ;SET INTERRUPT ENABLE
	MTPR	R1,#PR$_TXCS		;TELL CONSOLE
	BRB	DISMIS

CON_START_BURST:
	BISW	#TTY$M_TANK_BURST,-	;SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
;
;  CONTINUE BURST OUTPUT
;
CON_BURST:
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3	;OUTPUT NEXT BYTE
	MTPR	R3,#PR$_TXDB
	INCL	UCB$L_TT_OUTADR(R5)	;UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	;UPDATE COUNT
	BNEQ	10$			;NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	;RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
10$:	BRW	DISMIS
;
; OUTPUT SINGLE CHARACTER
;
CON_CHAR:
	MOVZBL	UCB$W_TT_HOLD(R5),R3	;OUTPUT CHAR IN TANK
	MTPR	R3,#PR$_TXDB
	BICW	#TTY$M_TANK_HOLD,-	;SHOW TANK EMPTY
		UCB$W_TT_HOLD(R5)	
	BRW	DISMIS
;
; STOP THE OUTPUT
;
CON_STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		;RESET OUTPUT ACTIVE
	BRB	CON_RESET_IE		;DISABLE INTERRUPT THIS DEVICE
;
; SEND XON OR XOFF CHARACTER
;
CON_PREMPT:
	BICW	#TTY$M_TANK_PREMPT,-		;RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	MTPR	UCB$B_TT_PREMPT(R5),#PR$_TXDB	;OUTPUT THE CHARACTER
	BRW	DISMIS				;AND DISMISS THE INTERRUPT

.SBTTL	CONSOLE PORT ACTION ROUTINES
;++
; CON$XOFF -	SEND XOFF
; CON$XON -	SEND XON
; CON$STOP -	STOP OUTPUT
; CON$ABORT -	ABORT CURRENT OUTPUT
; CON$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
CON$XOFF::
CON$XON::
	BISW	#TTY$M_TANK_PREMPT,UCB$W_TT_HOLD(R5) ;SCHEDULE XOFF/XON
	MOVB	R3,UCB$B_TT_PREMPT(R5)	;SAVE THE CHARACTER IN THE PREMPT SLOT
	BBS	#UCB$V_INT,UCB$W_STS(R5),10$ ;IF OUTPUT ACTIVE, THEN DONE

	BSBW	START_TERM_IO		;ENABLE OUTPUT INTERRUPTS
10$:	RSB

CON$STOP::
	BISW	#TTY$M_TANK_STOP,-	;SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	RSB

CON$ABORT::
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),- ;RESET BURST ACTIVE
		10$
10$:
	TIMSET	1			;SET A TIMEOUT
					;IN CASE OUTPUT ACTIVE
	RSB

CON$RESUME::
	PUSHL	R1			;SAVE A REGISTER
	BICW	#TTY$M_TANK_STOP-
		,UCB$W_TT_HOLD(R5)	;RESET STOP CONDITION
	BBC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),20$ ;BRANCH IF NO BURST IN PROGRESS
	MOVZWL	UCB$W_TT_OUTLEN(R5),R1	;NUMBER OF BURST CHARS
	TIMSET	R1,R1			;SET THE TIMER
	BRB	30$

20$:	TIMSET	2			;CHAR IN TANK OR OTHER TIMEOUT
30$:	BBS	#UCB$V_INT,UCB$W_STS(R5),40$ ;SKIP IF OUTPUT ON
	BSBW	START_TERM_IO		;ENABLE OUTPUT INTERRUPT
40$:
	POPL	R1
	RSB

	.SBTTL	CON$SENDCONSCMD - Send command to 11/790 console
;++
; Functional Description:
;	CON$SENDCONSCMD is used to send a command to the "logical" console,
;	such as "Examine warm start flag" or "Reboot CPU".  It is also
;	used by code at IPL 31 to read data in console memory
;	(as opposed to using the logical console QIO interface).
;
; Inputs:
;	R0 = code for console command (see TXDB$C_LOG_xxx definitions)
;	R2 = # of bytes of data expected (if 0 then just send command)
;	R3 = address of buffer to store data in (only if R2 is non-zero)
;
; Outputs:
;	Data is stored in the buffer.
;	All registers preserved.
;--

CON$SENDCONSCMD::
	PUSHR	#^M<R0,R1,R2,R3>	; Save working registers.
;
; Enable transmit/receive on logical console line.
;
	CLRQ	-(SP)			; Save RXCS and TXCS on stack.
	MFPR	#PR$_RXCS,4(SP)		; Save receive status register.
20$:	MFPR	#PR$_TXCS,(SP)		; Save transmit status register.
	BBC	#TXS_V_RDY,(SP),20$	; Make sure we have a valid copy.
	BICL	#^C<TXS_M_TEM!TXS_M_IE>,- ; Only save writable fields of TXCS
		(SP)			; (transmit enable mask and int enable).
	BISL	#TXS_M_WRTENA,(SP)	; Set "write enable" in saved TXCS.
30$:	MTPR	#TXS_M_LOGCONS!TXS_M_WRTENA, - ; Disable all console lines except
		#PR$_TXCS 		; logical console; also disable interrupts.
	MTPR	#0,#PR$_RXCS		; Disable interrupts in RXCS.
;
; Send command to logical console.
;
40$:	MFPR	#PR$_TXCS,R1		; Get transmit status.
	BBC	#TXS_V_RDY,R1,40$	; Loop until ready bit is set.
	CMPZV	#TXS_V_ID,#TXS_S_ID,R1,#3 ; ID = logical console data?
	BNEQ	30$			; If not, try again.
	CMPB	R0,#CON$C_BOOTCPU	; Console function = boot CPU?
	BEQL	90$			; Branch if so.
	MTPR	R0,#PR$_TXDB		; Else send request code to console.
;
; Get returned data (if any is expected).
;
	TSTL	R2			; Any return data expected?
	BEQL	60$			; None; we're all through.
50$:	MFPR	#PR$_RXCS,R1		; Get receiver status.
	BBC	#RXS_V_DONE,R1,50$	; Loop until done bit is set.
	MFPR	#PR$_RXDB,R1		; Get received data.
	CMPZV	#RXD_V_ID,#RXD_S_ID,R1,#3 ; ID = logical console data?
	BNEQ	50$			; If not, throw data away and try again.
;	CMPB	R1,R0			; Code = requested data?
;	BNEQ	CONSOLE_ERROR		; No recovery from protocol error.
	MOVB	R1,(R3)+		; Put data byte in user's buffer.
	SOBGTR	R2,50$			; Branch back to get another byte.

;
; Restore console IPRs and registers, and return.
;
60$:	MFPR	#PR$_TXCS,R1		; Read transmit status.
	BBC	#TXS_V_RDY,R1,60$	; Wait for ready.
	MTPR	(SP)+,#PR$_TXCS		; Restore previous state of TXCS.
	MTPR	(SP)+,#PR$_RXCS		; Restore previous state of RXCS.
	POPR	#^M<R0,R1,R2,R3>	; Restore registers.
	RSB

;
; Come here to reboot CPU.
;
90$:	MTPR	R0,#PR$_TXDB		; Send reboot command.
	HALT				; Halt to let reboot occur.

	.SBTTL	"ALLOCATE" CONSOLE TERMINAL

;++
; CON$OWNCTY - "ALLOCATE" CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED WHEN PERFORMING NON-INTERRUPT DRIVEN
;	I/O TO THE CONSOLE TERMINAL.  IT DISABLES INTERRUPTS AND DOES ANY
;	CPU-SPECIFIC INITIALIZATION OF THE CONSOLE TERMINAL REGISTERS.
;	THE CONSOLE TERMINAL IS RESTORED TO ITS PREVIOUS STATE BY CALLING
;	CON$RELEASECTY.
;
;	THIS ROUTINE SHOULD BE CALLED AT OR ABOVE IPL 20.
;
;	*** NOTE ***	THE CALLER IS RESPONSIBLE FOR RESTORING THE STATE
;			OF THE CONSOLE TERMINAL STATUS REGISTERS (RXCS AND
;			TXCS) BY CALLING CON$RELEASECTY WITH THE VALUES
;			RETURNED BY THIS ROUTINE.
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;
;	R0:	VALUE TO BE RESTORED TO TXCS WHEN CALLING CON$RELEASECTY
;	R1:	VALUE TO BE RESTORED TO RXCS WHEN CALLING CON$RELEASECTY
;
;	PR$_RXCS AND PR$_TXCS ARE SET UP SO THAT NON-INTERRUPT I/O CAN BE
;	PERFORMED TO THE CONSOLE TERMINAL.
;
;	11/780, 11/750, AND 11/730:
;		CONSOLE INTERRUPTS ARE DISABLED
;
;	11/790:
;		CONSOLE TRANSMIT AND RECEIVE MASKS ARE SET UP SO THAT ONLY
;		I/O TO THE CONSOLE TERMINAL IS PERMITTED.  INTERRUPTS ARE
;		DISABLED.
;--
CON$OWNCTY::
10$:	MFPR	#PR$_TXCS,R0		; GET VALUE TO BE RESTORED TO TXCS.
	BBC	#TXS_V_RDY,R0,10$	; WAIT FOR VALID COPY
	BICL	#^C<TXS_M_TEM!TXS_M_IE>,- ; ONLY SAVE WRITABLE FIELDS OF TXCS
		R0			; (TRANSMIT ENABLE MASK AND INT ENABLE).
	BISL	#TXS_M_WRTENA,R0	; SET WRITE ENABLE BIT FOR MASK.
	MTPR	#TXS_M_CONSTERM!TXS_M_WRTENA,-	; ENABLE LOCAL TERM OUTPUT AND
		#PR$_TXCS		; DISABLE TRANSMIT INTERRUPTS.
	MTPR	#RXS_M_CONSTERM,#PR$_RXCS ; ENABLE LOCAL TERM INPUT AND DISABLE
					; RECEIVE INTERRUPTS.
	RSB

	.SBTTL	RELEASE CONSOLE TERMINAL
;++
; CON$RELEASECTY - RELEASE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO RELEASE THE CONSOLE TERMINAL AFTER
;	ALLOCATING IT WITH ROUTINE CON$OWNCTY.  IT RESTORES THE STATE OF THE
;	CONSOLE TERMINAL INTERFACE REGISTERS.
;
;	THIS ROUTINE SHOULD BE CALLED AT OR ABOVE IPL 20.
;
; INPUTS:
;	R0:	VALUE RETURNED BY CON$OWNCTY TO BE RESTORED TO TXCS
;	R1:	VALUE RETURNED BY CON$OWNCTY TO BE RESTORED TO RXCS
;
; OUTPUTS:
;	NONE.
;
;--
CON$RELEASECTY::
	PUSHL	R2			; SAVE A REGISTER.
10$:	MFPR	#PR$_TXCS,R2		; READ TRANSMIT STATUS.
	BBC	#TXS_V_RDY,R2,10$	; WAIT TIL INTERFACE IS READY.
	MTPR	R0,#PR$_TXCS		; RESTORE TXCS TO PREVIOUS STATE.
	MTPR	R1,#PR$_RXCS		; RESTORE RXCS TO PREVIOUS STATE.
	MOVL	(SP)+,R2		; RESTORE THE REGISTER.
	RSB

	.SBTTL	CON$GETCHAR - GET A CHARACTER FROM THE CONSOLE TERMINAL
;++
; CON$GETCHAR - GET A CHARACTER FROM THE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO DO NON-INTERRUPT DRIVEN I/O
;	DIRECTLY TO THE CONSOLE TERMINAL
;
; INPUTS:
;	None
;
; OUTPUTS:
;	R0 contains the character.
;
;--
	control_s = 19			; control s (xoff)
	control_q = 17			; control q (xon)

CON$GETCHAR::
10$:	mfpr	#pr$_rxcs,r0		;receiver ready?
	bbc	#rxs_v_done,r0,10$	;if clr, receiver not ready
	mfpr	#pr$_rxdb,r0		;read input character
	rsb				;return

	.SBTTL	CON$PUTCHAR - PUT A CHARACTER TO THE CONSOLE TERMINAL
;++
; CON$PUTCHAR - PUT A CHARACTER TO THE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO DO NON-INTERRUPT DRIVEN I/O
;	DIRECTLY TO THE CONSOLE TERMINAL
;
; INPUTS:
;	R0 - Character to be output
;
; OUTPUTS:
;	Character written to the console terminal.
;
;--
CON$PUTCHAR::
	pushl	r1			;save a register
10$:	mfpr	#pr$_rxcs,r1		;receiver ready?
	bbc	#rxs_v_done,r1,30$	;if clr, receiver not ready
	mfpr	#pr$_rxdb,r1		;read input character.
	cmpzv	#0,#7,r1,#control_s	;control-s?
	bneq	30$			;if neq no
20$:	mfpr	#pr$_rxcs,r1		;receiver ready?
	bbc	#rxs_v_done,r1,20$	;if clr, receiver not ready
	mfpr	#pr$_rxdb,r1		;read input character
	cmpzv	#0,#7,r1,#control_q	;is it a control-q?
	bneq	20$			;no, wait for another character.
30$:	mfpr	#pr$_txcs,r1		;transmitter done?
	bbc	#txs_v_rdy,r1,30$	;if clr, transmitter not done
	mtpr	r0,#pr$_txdb		;write output character
	popl	r1			;restore a register
	rsb				;return

	.END
