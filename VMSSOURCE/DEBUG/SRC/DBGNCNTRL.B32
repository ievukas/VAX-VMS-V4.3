MODULE DBGNCNTRL (IDENT = 'V04-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
! MODULE FUNCTION
!	This module contains DEBUG's top level parsing and execution routines.
!	Routine DBG$NCONTROL is called after an input line has been collected
!	from the user's terminal, or a record has been read from an indirect
!	command file or DO action buffer. Other routines in this module break
!	an input line into single commands, verify these commands if appropri-
!	ate, and allocate and deallocate temporary DEBUG memory (i.e., memory
!	that is automatically reclaimed at the end of each command).  End of
!	command clean-up routines are also included.
!
!	Routine DBG$NCONTROL invokes the top level parsing and command execu-
!	tion networks as needed.  Commands are parsed and executed one at a
!	time.  Detection of errors in the parsing phase cause the command in
!	question to not be executed.
!
!
! AUTHOR:	David Plummer, CREATION DATE:	4/15/80
!
! MODIFIED BY:
!
!	R. Title, Feb 1982,	Filled in CIS$A_WHILE_CLAUSE field from
!				within DBG$NGET_CMD; this was in order to
!				implement the WHILE command.    
!	R. Title, Apr 1982,	Fixed a bug in DBG$NSAVE_FILESP that was 
!				preventing logical name translation from
!				occuring (a semicolon was always being 
!				appended to the filename).
!	R. Title, Jan 1983	Changed DBG$NGET_CMD so that when language
!				is set to C, the comment character is
!				/*  and not  !
!	R. Title, Sep 1983	Fixed DBG$NGET_CMD to treat a line of tabs
!				the same as a line of blanks.
!	B. Becker, Oct 1983	Fixed up the uppercasing so that when an Ada
!				tick is found DBG$NGET_CMD will continue to
!				uppercase the line.  Also created another
!				routine to do the uppercasing work.
!
REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$NCONTROL: NOVALUE,		! Controls parsing and command execution
    ADD_TO_BUFLIST: NOVALUE,
    DBG$NGET_CMD,			! Chops input string into command strings
    DBG$NKILL_CMD,			! Kills a command and frees up dynamic
					!      memory
    DBG$NEND_OF_INPUT,			! End of parse line clean-up
    DBG$NSAVE_FILESP,			! Saves a filespec in a dynamic buffer
    DBG$NVERIFY_OUT: NOVALUE,		! VERIFIES indirect command file commands
    DBG$NCHANGE_TO_NEW: NOVALUE,	! Aids transition to new debugger
    DBG$NSAVE_BREAK_BUFFER: NOVALUE,	! Save a break action buffer
    GET_C_CMD_STRING,			! Uppercases a 'C' command string
    GET_ADA_CMD_STRING,			! Uppercases a Ada command string
    GET_NORMAL_CMD_STRING;		! Uppercases a normal command string

EXTERNAL ROUTINE
    DBG$EXPAND_DEFINE_NAME,		! Expands a DEFINE name
    DBG$FAO_OUT: NOVALUE,		! ???
    DBG$NINITIALIZE: NOVALUE,		! Sets language specific context
    DBG$NMATCH,				! Matches counted string to input
    DBG$NOUT_INFO,			! Outputs an informational message
    DBG$NSYNTAX_ERROR,			! Formats a syntax error
    DBG$END_OF_LINE: NOVALUE,		! Version 2 end of line clean-up
    DBG$END_OF_CMD: NOVALUE,		! Version 2 end of command clean-up
    DBG$NOUT_ARG_VECT: NOVALUE,		! Outputs a message vector
    DBG$NMAKE_ARG_VECT,			! Constructs an argument vector
    DBG$NNEXT_WORD,			! Isolates next word of input
    DBG$NCIS_REMOVE,			! Removes a link from the cis
    DBG$GET_MEMORY,			! Allocates a dynamic memory block
    DBG$GET_TEMPMEM,			! Allocates a temporary memory block
    DBG$REL_MEMORY,			! Release permanent memory
    DBG$NPARSE_CMD,			! The DEBUG command parser
    DBG$NEXECUTE_CMD;			! The DEBUG command executor

EXTERNAL
    DBG$GB_LANGUAGE: BYTE,		! Current language setting
    DBG$GL_GBLTYP,			! Override type
    DBG$GW_GBLLNGTH: WORD,		! Override length
    DBG$GL_DFLTTYP,			! Default type
    DBG$GW_DFLTLENG: WORD,		! Default length
    DBG$GL_CISHEAD: REF CIS$LINK,	! Head of cis
    DBG$GB_DEF_OUT: VECTOR[,BYTE],	! Output control vecter in old debugger
    DBG$GL_ORIG_COMMAND_PTR,		! Pointer to original command string
    DBG$GL_UPCASE_COMMAND_PTR: VECTOR[2];
    					! Pointers to start and end
    					!    of current command string

GLOBAL
    DBG$GL_ORIG_COMMAND_PTR,		! Pointer to original command string
    DBG$GL_UPCASE_COMMAND_PTR:		! Pointer to upcased command string
			VECTOR[2, LONG];!

OWN
    MESSAGE_POINTER,			! Holds address of message argument vector
    CMD_STG_DESC: BLOCK[12,BYTE],	! Command input string descriptor. Note
					!      the extra longword to contain
					!      the original DSC$A_POINTER.
    CMD_VERB_PTR,			! Start of executable parse tree
    SAVE_INPUT_DESC: REF DBG$STG_DESC, 	! Pointer to parse string descriptor
					!      used in gathering filespecs.
    START_VERIFY_POINTER;		! Pointer to the start of the input to
					!      be verified

MACRO
	INITIAL_PTR = 8, 0, 32, 0 %;	! Pointer to start of dynamic buffer

GLOBAL ROUTINE DBG$NCONTROL(PARSE_STG_DESC): NOVALUE =
!
! FUNCTION
!	Routine DBG$NCONTROL oversees command parsing and execution. Only commands
!	that are parsed without detection of errors are executed. Routines are invoked
!	for end of command and input processing.
!
! FORMAL PARAMETERS:
!	PARSE_STG_DESC - A VAX standrd descriptor of the input string.
!
! IMPLICIT INPUTS:
!
!	CMD_VERB_PTR - Pointer to the verb node (head node) of the
!		  executable command tree.
!
!	MESSAGE_POINTER - Pointer to message argument vector.
!
!

    BEGIN

    MAP
	PARSE_STG_DESC : REF BLOCK [,BYTE];

    LOCAL
	STATUS;			! Retains return code


    ! Try to get another command from the present input buffer. Check for comments.
    !
    status = dbg$nget_cmd (.parse_stg_desc, cmd_stg_desc, message_pointer);

    CASE .status FROM sts$k_warning TO sts$k_severe
        OF
	SET

	[sts$k_warning] :		! No more input from present buffer
	    BEGIN
	    IF NOT dbg$nend_of_input (message_pointer)
	    THEN
		dbg$nout_arg_vect (.message_pointer);
	    END;

	[sts$k_success] :	! Parse and execute command
	    BEGIN

	    dbg$ninitialize ();

	    IF dbg$nparse_cmd (cmd_stg_desc, cmd_verb_ptr, message_pointer)
	    THEN
		BEGIN
		dbg$nverify_out (.parse_stg_desc [dsc$a_pointer]);
			
		IF NOT dbg$nexecute_cmd (cmd_verb_ptr, message_pointer)
		THEN
		    BEGIN
		    dbg$nout_arg_vect (.message_pointer);
		    IF NOT dbg$nkill_cmd (message_pointer)
		    THEN
			dbg$nout_arg_vect (.message_pointer);
		    END;
		END
	    ELSE
		BEGIN	! Kill command - bad parse
		dbg$nout_arg_vect (.message_pointer);
		IF NOT dbg$nkill_cmd (message_pointer)
		THEN
		    dbg$nout_arg_vect (.message_pointer);
		END;
	    END;

	[sts$k_error] :	! Not parsable. Just verify the comment.
	    BEGIN
	    dbg$nverify_out (.parse_stg_desc [dsc$a_pointer]);
	    IF NOT dbg$nend_of_input (message_pointer)
	    THEN
		dbg$nout_arg_vect (.message_pointer);
	    END;

	[sts$k_severe] :	! Error in input
	    BEGIN
	    dbg$nout_arg_vect (.message_pointer);
	    IF NOT dbg$nkill_cmd (message_pointer)
	    THEN
		 dbg$nout_arg_vect (.message_pointer);
	    END;

	[INRANGE,OUTRANGE] :
	    BEGIN
	    0;
	    END;

	TES;


    ! Perform end of command clean-up.  This involves resetting data structures
    ! shared between the old debugger and the new.  It also involves releasing
    ! all temporary memory allocated during the processing of the command and
    ! releasing all unreferenced RST entries on the Temporary RST Entry List.
    !
    DBG$END_OF_CMD();
    RETURN;

    END;

ROUTINE ADD_TO_BUFLIST (BUFFER) : NOVALUE =
!
! FUNCTION
!	This routine builds a list of buffers to be freed at the end of 
!	processing a line of input.
!
!	The top link in the CIS list represents the current line of input.
!	There is a field CIS$A_BUFLIST which points to a linked list
!	of buffers to be freed up.
!
!	+---------+
!	|  CIS	  |
!	|  ...	  |
!	|---------|	+------- +	    +--------+
!	| BUFLIST |---->|        |--------->|	    |--->...
!	+---------+     | bufptr |->buffer  | bufptr |->buffer
!			+------- +	    +--------+
!
!	These bufffers get created as we expand symbols that were defined
!	with DEFINE/COMMAND (we need to allocate new buffers to hold the
!	expanded command). This happens in DBG$NGET_CMD. These buffers
!	are freed in DBG$NCIS_REMOVE.
!
! INPUTS
!	BUFFER - address of a buffer. This address is to be added to the list.
!	DBG$GL_CISHEAD - (implicit input) - current top CIS link
!
! OUTPUTS
!	The BUFLIST associated with DBG$GL_CISHEAD is added to.
!
    BEGIN
    LOCAL
    	NEWLINK: REF VECTOR[];
    NEWLINK = DBG$GET_MEMORY(2);
    NEWLINK[0] = .DBG$GL_CISHEAD[CIS$A_BUFLIST];
    NEWLINK[1] = .BUFFER;
    DBG$GL_CISHEAD[CIS$A_BUFLIST] = .NEWLINK;
    END;

ROUTINE DBG$NGET_CMD ( INPUT_DESC, CMD_DESC, MESSAGE_VECT, P_EXPAND_FLAG) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine seperates the input line into one or more DEBUG commands. <cr>
!	<ff>, and the null character (00) imply end of input line. Semi-colon (;)
!	implies end of command.
!
!	This routine takes care of stripping the comments off the end of
!	a DEBUG command. For all languages except C, the comment character is 
!	'!'. In C, '!' is an operator, so the pair of characters '/*' is
!	the comment indicator (as in the language).  Since there are slight
!	differences in the way a line is to be Uppercased and striped of comments
!	we case on the language a call a specific routine to do these jobs.
!
! FORMAL PARAMETERS:
!
!	input_desc -		a VAX standard descriptor of the entire input line
!
!	cmd_desc -		upon exit from this routine, a VAX standard descriptor
!				of a single potential DEBUG command
!
!	message_vect		- the address of a longword to contain the address 
!				  of a message argument vector
!	p_expand_flag -		optional fourth parameter which says whether to
!				expand defined names.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_warning (0)	- the input line was found to be exhausted
!
!	sts$k_success (1)	- the comd_desc was updated to refer to a potential
!				  DEBUG command
!
!	sts$k_error (2)		- the input descriptor was found to contain nothing
!				  but a comment (! in first position)
!
!	sts$k_severe (4)	- error in input line
!
! SIDE EFFECTS:
!
!	All lower case alphabetic characters are converted to upper case, except
!	for strings enclosed withing single or double quote marks. A check
!	is made for unprintable characters in the input line (error message generated
!	and failure return).
!
!--

    BEGIN

    LOCAL
	CHAR_COUNT,				! Keeps count of characters
	CHAR_STRING 	: REF VECTOR [,BYTE],	! Vector of 1 byte characters
    	CIS_DESC	: REF CIS$LINK,		! Current command input stream.
	CMD_STRING 	: REF VECTOR [, BYTE],	! Counted string with the expansion of
						! the first token, if it has been
						! defined with DEFINE/COMMAND
    	EXPAND_FLAG,				! Says whether or not to expand
    						!    defined names.
        STATUS,					! status of calls
	QUOTE_CHAR,				! Contains quote char
	QUOTE_FLAG;				! Signifies quoted string

    MAP
	INPUT_DESC 	: REF dbg$stg_desc,
	CMD_DESC 	: REF BLOCK [,BYTE];	! We don't REF to dbg$stg_desc
						! because of the extra longword for
						! the initial dsc$a_pointer
    BUILTIN
    	ACTUALCOUNT;


    ! Set the flag saying whether we want to expand defined names. The case
    ! where we do not want to is when we are called from DBG$NSAVE_BREAK_BUFFER
    ! to pick up the rest of a command.
    !
    IF ACTUALCOUNT() LSS 4
    THEN
    	EXPAND_FLAG = TRUE
    ELSE
    	EXPAND_FLAG = .P_EXPAND_FLAG;


    ! Initialize the command descriptor
    !
    cmd_desc [dsc$b_dtype] = dsc$k_dtype_t;
    cmd_desc [dsc$b_class] = dsc$k_class_s;
    cmd_desc [dsc$w_length] = 0;
    cmd_desc [dsc$a_pointer] = 0;
    cmd_desc [initial_ptr] = 0;


    ! Find a significant character
    !
    char_string = .input_desc [dsc$a_pointer];
    char_count = 0;
    WHILE .input_desc [dsc$w_length] GTR 0 DO
    	BEGIN
	IF .char_string [.char_count] NEQ dbg$k_car_return
				AND
	   .char_string [.char_count] NEQ dbg$k_line_feed
				AND
	   .char_string [.char_count] NEQ dbg$k_null
				AND
	   .char_string [.char_count] NEQ dbg$k_semicolon
				AND
	   .char_string [.char_count] NEQ dbg$k_blank
    				AND
    	   .char_string [.char_count] NEQ dbg$k_tab
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    char_count = .char_count + 1;
	    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
	    END;
 	END;

    ! Return warning if there was no significant input on the line.
    !
    IF .input_desc [dsc$w_length] EQL 0
    THEN
	RETURN sts$k_warning;


    ! Set up the start verify pointer. This is done before stripping
    ! non-significant input to preserve the indentation.
    !
    start_verify_pointer = .input_desc [dsc$a_pointer];


    ! Update pointer to rest of string
    !
    input_desc [dsc$a_pointer] = char_string [.char_count];


    ! The next thing we do is check for the first token in the command line
    ! being a symbol defined with DEFINE/COMMAND.
    !
    IF .EXPAND_FLAG
    THEN
    	BEGIN
        IF DBG$EXPAND_DEFINE_NAME (.INPUT_DESC, DEFINE_COMMAND, CMD_STRING)
        THEN
	    BEGIN
	    LOCAL
	        BUFPTR,			! A pointer into the command buffer
	        LENGTH,			! The length of the new command buffer
	        NEW_BUFFER;			! Will point to the new command buffer.


	    ! We need to allocate a new command buffer to hold the expanded
	    ! token concatenated with the rest of the command.
	    !
	    LENGTH = .INPUT_DESC [DSC$W_LENGTH] + .CMD_STRING [0];
	    NEW_BUFFER = DBG$GET_MEMORY((.LENGTH+3)/4);


    	    ! Copy the concatenated strings into the new buffer.
    	    !
	    BUFPTR = CH$MOVE (.CMD_STRING [0], CMD_STRING [1], .NEW_BUFFER);
	    BUFPTR = CH$MOVE (.INPUT_DESC[DSC$W_LENGTH], .INPUT_DESC[DSC$A_POINTER], .BUFPTR);


	    ! Fill in the input descriptor to point to the new buffer.
	    !
	    INPUT_DESC[DSC$A_POINTER] = .NEW_BUFFER;
	    INPUT_DESC[DSC$W_LENGTH] = .INPUT_DESC[DSC$W_LENGTH]+.CMD_STRING[0];


    	    ! We need to remember to free up the space occupied by NEW_BUFFER
    	    ! when we are done processing this CIS link. So, we
    	    ! put NEW_BUFFER onto the linked list of all the buffers allocated
    	    ! in this fashion. These will get freed up in CIS_REMOVE.
    	    !
    	    ADD_TO_BUFLIST (.NEW_BUFFER);


    	    ! Now re-do the code where we find a significant character
            !
            char_string = .input_desc [dsc$a_pointer];
    	    char_count = 0;
    	    WHILE .input_desc [dsc$w_length] GTR 0 DO
    		BEGIN
	    	IF .char_string [.char_count] NEQ dbg$k_car_return
				AND
	       	   .char_string [.char_count] NEQ dbg$k_line_feed
				AND
	           .char_string [.char_count] NEQ dbg$k_null
				AND
	           .char_string [.char_count] NEQ dbg$k_semicolon
				AND
	           .char_string [.char_count] NEQ dbg$k_blank
    				AND
    	           .char_string [.char_count] NEQ dbg$k_tab
	    	THEN
	            EXITLOOP
	    	ELSE
		    BEGIN
	 	    char_count = .char_count + 1;
		    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
		    END;
	        END;

    	    ! Again, if we have no significant input on the line then
    	    ! return warning.
    	    !
    	    IF .input_desc [dsc$w_length] EQL 0
    	    THEN
	        RETURN sts$k_warning;

    	    ! Set up the start verify pointer
    	    !
    	    start_verify_pointer = .input_desc [dsc$a_pointer];

    	    ! Update pointer to rest of string
    	    !
    	    input_desc [dsc$a_pointer] = char_string [.char_count];
    	    END;
    	END;


    ! Now case on the language and get the command and uppercase the characters.
    !
    CASE .dbg$gb_language FROM dbg$k_min_language TO dbg$k_max_language OF
        SET

        [dbg$k_macro, dbg$k_fortran, dbg$k_bliss,
         dbg$k_cobol, dbg$k_basic, dbg$k_pli,
         dbg$k_pascal, dbg$k_rpg, dbg$k_unknown,
         INRANGE, OUTRANGE]:
            status = get_normal_cmd_string(.input_desc, .cmd_desc, .cis_desc, .message_vect);

        [dbg$k_c]:
            status = get_c_cmd_string(.input_desc, .cmd_desc, .cis_desc, .message_vect);

        [dbg$k_ada]:
            status = get_ada_cmd_string(.input_desc, .cmd_desc, .cis_desc, .message_vect);

        TES;

    ! If an error occured return with status.
    !
    IF NOT .status
    THEN
	RETURN .status;

    ! Delete all leading end of command signifiers from the input string
    !
    char_string = .input_desc [dsc$a_pointer];

    WHILE .input_desc [dsc$w_length] GTR 0
    DO
	BEGIN

	    IF .char_string [0] NEQ dbg$k_car_return
			    AND
	       .char_string [0] NEQ dbg$k_line_feed
			    AND
	       .char_string [0] NEQ dbg$k_null
			    AND
	       .char_string [0] NEQ dbg$k_semicolon
	    THEN
	    	EXITLOOP;

	    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
	    input_desc [dsc$a_pointer] = char_string [1];
	    char_string = .input_desc [dsc$a_pointer];

	END;


    ! Save a pointer to the new input descriptor so that dbg$nsave_filespec
    ! can use it.
    !
    save_input_desc = .input_desc;

    RETURN sts$k_success;
    END;			!End of dbg$nget_cmd

GLOBAL ROUTINE DBG$NKILL_CMD (MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Invocation ot this routine takes place when an invalid debug command is
!	encountered during parsing.
!
! FORMAL PARAMETERS:
!
!	message_vect	- the address of a longword to contain the address of a
!			  message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On error return, a message argument vector is constructed
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1) - success
!
!	sts$k_severe  (4) - failure. message returned.
!
! SIDE EFFECTS:
!
!	The present input buffer is discarded
!
!--

    BEGIN

    ! Simply blow away the rest of the input line
    !
    IF NOT dbg$nend_of_input (.message_vect)
    THEN
	RETURN sts$k_severe;

    RETURN sts$k_success;

    END;			! End of dbg$n_kill_cmd


GLOBAL ROUTINE DBG$NEND_OF_INPUT (MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is invoked when the present input line is exhausted.
!
! FORMAL PARAMETERS:
!
!	message_vect	- the address of a longword to contain the address of a
!			  message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On error return, a message argument vector is returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1)	- success. input removed
!
!	sts$k_severe  (4)	- failure. message argument vector returned.
!
! SIDE EFFECTS:
!
!	A link is removed from the head of the command input stream.
!
!--

    BEGIN

    ! Remove a node from the cis
    !
    IF NOT dbg$ncis_remove (FALSE, .message_vect)
    THEN
	RETURN sts$k_severe;

    RETURN sts$k_success;

    END;			! End of dbg$nend_of_input

GLOBAL ROUTINE DBG$NSAVE_FILESP (INPUT_DESC, FILE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gathers a file spec from the command line. Since filespecs
!	may be in the form a.b;12, the version number will not be contained in the
!	command descriptor string as dbg$nget_command regards a ';' as end of command.
!	Consequently, look-ahead must be performed on the entire input line string
!	to locate the version number of a file spec. Quoted filespec strings are
!	also allowed as this construction is necessary to specify filespecs that
!	contain disk specifiers or sub-directories.
!
!	A filespec is returned in the form of a counted string, the storage for which
!	is allocated from non-listed storage.
!
! FORMAL PARAMETERS:
!
!	input_desc -		the present command VAX standard string descriptor
!
!	file	-		the address of a longword to contain the filespec
!
!	message_vect -		the address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	save_input_desc -	VAX standard string descriptor of the rest of the
!				complete input line.
!
! IMPLICIT OUTPUTS:
!
!	A counted string representing the filspec on success, or a message argument
!	vector on failure.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1) -	filespec collected.
!
!	sts$k_severe  (4) -	the filespec was not collected. message vector returned.
!
! SIDE EFFECTS:
!
!	Both the command descriptor and the line input descriptor may be updated.
!	The command descriptor (input_desc) is always updated to reflect exhaused
!	input. That is, the filespec is taken to be everything left in the command
!	string. The input line descriptor (save_input_desc) will be updated to
!	point past an explicit version number string.
!
!--
    BEGIN

    FORWARD ROUTINE
	NEXT_CHAR,				! Returns the next character from input
    	LOOKAHEAD_CHAR,				! Returns next char but does not
    						!    advance pointer.
	FILENAME,				! Extracts a file spec name
	FILETYPE,				! Extracts a file spec type
	VERSION_NUMBER,				! Extracts a file spec version number
	QUOTED_FILESPEC;			! Extracts a quoted filespec

    LOCAL
	NEXT_PTR,				! Pointer to position in filespec
	FILESPEC 	: REF VECTOR [,BYTE],	! Contains the file spec
	NAME 		: REF VECTOR [,BYTE],	! Contains the file name
	TYPE 		: REF VECTOR [,BYTE],	! Contains the file type
	VERSION 	: REF VECTOR [,BYTE],	! Contains the file version number
	QUOTED_STRING;				! Pointer to a quoted file spec

    OWN
	ERROR_VECTOR,				! Pointer to message argument vector
	CHAR 		: BYTE,			! Character of input buffer. This
						! variable is 'own'ed to make it a 
						! 'local global'.
	ERROR_STG_DESC	: dbg$stg_desc,		! For error reporting
	CMD_DESC 	: REF dbg$stg_desc;	! Descriptor for command input

    BIND
	ONE_QUOTE = UPLIT BYTE (dbg$k_quote),	! For error reporting
	TWO_QUOTE = UPLIT BYTE (dbg$k_dblquote); ! For error reporting

    !
    !
    !
    !
    !

    ROUTINE NEXT_CHAR =

    !++
    !	This routine returns the next character of input. This character
    !	may come from the command descriptor or the input line descriptor strings.
    !--

   	BEGIN

	! Take the character from the command input descriptor or the line
	! input descriptor.
  	!
	IF .cmd_desc [dsc$w_length] GTR 0
	THEN
	    BEGIN

		! Take the char from the command input buffer
		!
		cmd_desc [dsc$w_length] = .cmd_desc [dsc$w_length] - 1;
		char = .(.cmd_desc [dsc$a_pointer]) <0, 8, 0>;
		cmd_desc [dsc$a_pointer] = .cmd_desc [dsc$a_pointer] + 1;


		! Map a <cr> into a semicolon
		!
		IF .char EQL dbg$k_car_return
		THEN
		    char = dbg$k_semicolon;
	    END

	ELSE
            BEGIN

		! Take the character from the line input buffer.
		! Check for exhausted input.
		!
		IF .save_input_desc [dsc$w_length] LEQ 0
		THEN
		    RETURN sts$k_error;


		! We map a <cr> from the cmd buffer to a semicolon. Make sure
		! that we do not return the semicolon twice.
		!
		IF .char EQL dbg$k_semicolon
			AND
		   .(.save_input_desc [dsc$a_pointer]) <0, 8, 0> EQL dbg$k_semicolon
		THEN
		    BEGIN
			char = 0;
			save_input_desc [dsc$w_length] = .save_input_desc [dsc$w_length] - 1;
			save_input_desc [dsc$a_pointer] = .save_input_desc [dsc$a_pointer] + 1;
			RETURN next_char ();
		    END;

		save_input_desc [dsc$w_length] = .save_input_desc [dsc$w_length] - 1;
		char = .(.save_input_desc [dsc$a_pointer]) <0, 8, 0>;
		save_input_desc [dsc$a_pointer] = .save_input_desc [dsc$a_pointer] + 1;
	    END;

	RETURN sts$k_success;

	END;		! End of next_chars

    !
    !
    !
    !
    !

    ROUTINE LOOKAHEAD_CHAR =
    !++
    ! This routine is like NEXT_CHAR in that it returns the next character,
    ! but it does not advance the pointer. It can this be used for lookahead.
    !--
    	BEGIN

    	! Take the character from the command input descriptor or the line
    	! input descriptor.
    	!
    	IF .cmd_desc [dsc$w_length] GTR 0
    	THEN
    	    BEGIN
    	    char = .(.cmd_desc [dsc$a_pointer]) <0, 8, 0>;
    	    ! Map a <cr> into a semicolon
    	    IF .char EQL dbg$k_car_return 
    	    THEN
    		char = dbg$k_semicolon;
    	    END
    	ELSE
    	    BEGIN
    	    ! Take the character from the line input buffer.
    	    ! Check for exhausted input.
    	    IF .save_input_desc [dsc$w_length] LEQ 0
    	    THEN
    		RETURN sts$k_error;
    	    
	    ! We map a <cr> from the cmd buffer to a semicolon. Make sure
	    ! that we do not return the semicolon twice.
	    !
	    IF .char EQL dbg$k_semicolon
		AND
	       .(.save_input_desc [dsc$a_pointer]) <0, 8, 0> EQL dbg$k_semicolon
	    THEN
		BEGIN
		char = 0;
		RETURN lookahead_char();
		END;

	    char = .(.save_input_desc [dsc$a_pointer]) <0, 8, 0>;
	    END;

    	RETURN sts$k_success;
    	END; ! lookahead_char
    !
    !
    !
    !
    !

    ROUTINE FILENAME =

    !++
    !	This routine collects the filespec file name string. That is, all characters
    !	up to a '.' or end of line.
    !--

    	BEGIN

    	LOCAL
	    NAME_BUF : REF VECTOR [,BYTE],	! Contains the filename string
	    I;					! Counter

 	! The filename cannot be longer than the command input buffer. Get storage
 	! to hold the name string.
	!
    	name_buf = dbg$get_tempmem (( .cmd_desc [dsc$w_length] / %UPVAL ) + 1);


	! Take characters up to a dot, semicolon, or blank
	!
	name_buf [0] = 0;
	i = 1;

	WHILE .char NEQ dbg$k_dot
		  AND
	      .char NEQ dbg$k_semicolon
	DO
	    BEGIN
	   	name_buf [0] = .i;
	       	name_buf [.i] = .char;
	        i = .i + 1;
    		
    		! Check for left paren or blank. This could be the case
    		! @FOO(param1,param2,...)   or  @FOO param1, param2, ...
    		!
    		lookahead_char();
    		IF .char EQL dbg$k_left_parenthesis OR .char EQL dbg$k_blank
    		THEN
    		    EXITLOOP;

		next_char ();
            END;

	RETURN name_buf [0]

	END;		! End of filename

    !
    !
    !
    !
    !

    ROUTINE FILETYPE =

    !++
    !	This routine collects the filespec file type string. The file type
    !	consists of all characters between '.' and ';'.
    !--

	BEGIN

	LOCAL
	    TYPE_BUF : REF VECTOR [,BYTE],	! Buffer for file type
	    I;					! Counter

	! The file name cannot be longer than the command buffer. Get storage.
	!
    	type_buf = dbg$get_tempmem (( .cmd_desc [dsc$w_length] / %UPVAL) + 1);


	! Take chars up to a semicolon, left paren, or blank. 
	!
	type_buf [0] = 0;
	i = 1;

	WHILE .char NEQ dbg$k_semicolon
	DO
	    BEGIN
		type_buf [0] = .i;
		type_buf [.i] = .char;
		i = .i + 1;

    		! Check for left paren or blank. This could be
    		! @FOO.COM(param1,param2...) or @FOO.COM param1, param2, ...
    		!
    		lookahead_char();
    		IF .char EQL dbg$k_left_parenthesis OR .char EQL dbg$k_blank
    		THEN
    		    EXITLOOP;

		next_char ();
	    END;

	RETURN type_buf [0];

	END;		! End of filetype

    !
    !
    !
    !
    !

    ROUTINE VERSION_NUMBER =

    !++
    !	This routine collects a filespec version number string. That is, all numeric
    !	characters following a ';' are taken to be the version number characters.
    !--

	BEGIN

	LOCAL
	    VERSION_BUF : REF VECTOR [,BYTE],	! Holds the version string
	    I,					! Counter
	    FLAG;				! Indicates end of input

    	! Allocate storage to hold the string.
	! The version number can be no longer than the save input buffer ( the rest
	! of the parse line buffer), plus one for the count and one for the
    	! semicolon. 
    	!
    	version_buf = dbg$get_tempmem
    			((.save_input_desc [dsc$w_length]+5) / %UPVAL);


	! The first character will always be a semicolon. Store this character.
	!
	version_buf [1] = .char;
	version_buf [0] = 1;


	! Aquire the version number chars. Take characters as long as they are alphanumeric
	!
 	i = 2;
	flag = false;
	next_char ();

	WHILE .char GEQ '0'
		  AND
	      .char LEQ '9'
	DO
	    BEGIN
		version_buf [0] = .i;
		version_buf [.i] = .char;
		i = .i + 1;


		! Check for exhausted input
		!
		IF NOT next_char ()
		THEN
		    BEGIN
			flag = true;
			EXITLOOP;
		    END;

	    END;

    	! If no numerics were read, a version number was not present. In
    	! that case, remove the semicolon from the buffer.
    	!
    	IF .version_buf[0] EQL 1
    	THEN
    	    version_buf[0] = 0;

	! Return the last character to the input buffer, if it is not a semicolon
	!
	IF NOT .flag
		AND
	       .char NEQ dbg$k_semicolon
	THEN
	    BEGIN
		save_input_desc [dsc$w_length] = .save_input_desc [dsc$w_length] + 1;
		save_input_desc [dsc$a_pointer] = .save_input_desc [dsc$a_pointer] - 1;
		(.save_input_desc [dsc$a_pointer]) <0, 8, 0> = .char;
	    END;

	RETURN version_buf [0];

	END;		! End of version_number

    !
    !
    !
    !
    !

    ROUTINE QUOTED_FILESPEC =

    !++
    !	This routine collects a quoted filespec string. That is, all characters
    !	coming between ' and ' or " and " are taken to be filespec string characters.
    !	If a termnal ' or " is not encountered, an error message is produced.
    !--

	BEGIN

	LOCAL
	    I,					    ! Counter
	    QUOTE_CHAR 	      : BYTE,		    ! Holds ' or " for error message
	    TEMP_FILESPEC_BUF : REF VECTOR [,BYTE], ! TEMP buffer for filespec
	    FILESPEC_BUF      : REF VECTOR [,BYTE]; ! Buffer for spec string			

	! The first non-blank character must be a quote or we report failure.
	!
	IF .char NEQ dbg$k_quote
		 AND
	   .char NEQ dbg$k_dblquote
	THEN
	    RETURN sts$k_error;
	
	quote_char = .char;

	
	! We must allocate non-listed storage to contain the quoted filespec
	! since we don't want it to disappear at the end of command clean-up.
 	! First we must allocate listed storage to hold the filespec while we
	! get the characters since the maximum possible length of the buffer
	! is the length of the command buffer + the length of the input buffer.
	! Allocating a non-listed buffer of this size would be a waste.
	!
    	temp_filespec_buf = dbg$get_tempmem (((.cmd_desc [dsc$w_length] + 
    		.save_input_desc [dsc$w_length]) / %UPVAL) + 1);
	temp_filespec_buf [0] = 0;
	next_char ();


	! Get characters until encountering a second quote. If no second quote
	! is found, produce an error message.
	!
	i = 1;

	WHILE .char NEQ dbg$k_quote
		    AND
	      .char NEQ dbg$k_dblquote
	DO
	    BEGIN
		temp_filespec_buf [0] = .i;
		temp_filespec_buf [.i] = .char;
		i = .i + 1;

		IF NOT next_char ()
		THEN
		    BEGIN	! No terminating quote mark - error
			
			! Don't print the last char which may be a spurious <cr> or semicolon
			!
			temp_filespec_buf [0] =
						( IF .temp_filespec_buf [0] GTR 0
						  THEN
							.temp_filespec_buf [0] - 1
						  ELSE
							0);

			error_stg_desc [dsc$a_pointer] = temp_filespec_buf [1];
			error_stg_desc [dsc$w_length] = .temp_filespec_buf [0];

			.error_vector = dbg$nmake_arg_vect (dbg$_noend, 3, error_stg_desc,
							    1, (IF .quote_char EQL dbg$k_quote
							       THEN one_quote
							       ELSE two_quote));

			RETURN sts$k_severe;
							    
		    END;
	    END;


	! Now allocate the semi-permanant dynamic buffer and copy the chars
	! from the temporary buffer.
	!

    	filespec_buf = dbg$get_memory((.temp_filespec_buf [0] / %UPVAL) + 1);
	filespec_buf [0] = .temp_filespec_buf [0];
	ch$move (.filespec_buf [0], temp_filespec_buf [1], filespec_buf [1]);

	RETURN filespec_buf [0];

	END;		! End of quoted_filespec


    
    ! Start of executable code for dbg$nsave_filesp
    !
    cmd_desc = .input_desc;
    error_vector = .message_vect;


    ! Obtain the first non-blank character
    !
    next_char ();
    WHILE .char EQL dbg$k_blank
    DO
	next_char ();


    ! Check for a quoted file spec
    !
    IF ( quoted_string = quoted_filespec () ) NEQ sts$k_error	! sts$k_error means
								! no quotes
    THEN

	! Check for an error
	!
	IF .quoted_string EQL sts$k_severe
	THEN
	    RETURN sts$k_severe
	ELSE
	    BEGIN
		.file = .quoted_string;
		RETURN sts$k_success;
	    END;


    ! File spec wasn't quoted. Get the file name.
    !
    IF ( name = filename () ) EQL sts$k_severe
    THEN
	RETURN sts$k_severe;


    ! Get the file type
    !
    IF ( type = filetype () ) EQL sts$k_severe
    THEN
	RETURN sts$k_severe;


    ! Get the version number
    !
    IF ( version = version_number () ) EQL sts$k_severe
    THEN
	RETURN sts$k_severe;


    ! Now put the filespec together
    !
    filespec = dbg$get_memory(
    	((.name [0] + .type[0] + .version[0]) / %UPVAL) + 1); 
    next_ptr = ch$move (.name [0], name [1], filespec[1]);
    next_ptr = ch$move (.type [0], type [1], .next_ptr);
    ch$move (.version [0], version [1], .next_ptr);
    filespec [0] = .name [0] + .type [0] + .version [0];

    .file = filespec [0];

    RETURN sts$k_success;

    END;		! End of dbg$nsave_filesp


GLOBAL ROUTINE DBG$NVERIFY_OUT (END_VERIFY_POINTER) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	The function of this routine is to verify commands read from an indirect
!	command file. That is, the command or comment in question is displayed
!	at the user's terminal.
!
! FORMAL PARAMETERS:
!
!	end_verify_pointer -		pointer to the last character of the input
!					to be verified
!
! IMPLICIT INPUTS:
!
!	start_verify_pointer -		pointer to the first character of the input string
!					to be verified
!
!	dbg$gb_def_out [out_verify] -	if this byte of dbg$gb_out_verify is set
!					to a non-zero value (1), then a SET OUTPUT VERIFY
!					command is in effect and the VERIFY should
!					take place
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	The character string lying between the start and end pointers (usually a
!	single command or comment) is displayed at the user's terminal, if appropriate.
!
!--

    BEGIN

    LOCAL
	PREV_LINK 	: REF cis$link,
	OK_TO_VERIFY;

    ! Get address of previous link in cis
    !
    prev_link = .dbg$gl_cishead [cis$a_next_link];


    ! Check the type of the cis node
    !
    CASE .dbg$gl_cishead [cis$b_input_type] FROM cis_dbg$input TO cis_if 
	OF
	SET

	[cis_dbg$input] :
	    BEGIN
		ok_to_verify = false;
	    END;

	[cis_rab] :
	    BEGIN
		IF .prev_link [cis$b_input_type] NEQ cis_inpbuf
		THEN
		    ok_to_verify = true
		ELSE
		    BEGIN
			LOCAL
			    pre_prev : REF cis$link;

			pre_prev = .prev_link [cis$a_next_link];
			IF .pre_prev [cis$b_input_type] NEQ cis_dbg$input
			THEN
			    ok_to_verify = true
			ELSE
			    ok_to_verify = false;
		    END;
	    END;

	[cis_inpbuf] :
	    BEGIN
		IF .prev_link [cis$b_input_type] EQL cis_dbg$input
		THEN
		    ok_to_verify = false
		ELSE
		    ok_to_verify = true;
	    END;

	[cis_acbuf] :
	    BEGIN
		ok_to_verify = true;
	    END;

    	[cis_while] :
    		ok_to_verify = true;

    	[cis_repeat] :
    		ok_to_verify = true;

    	[cis_if] :
    		ok_to_verify = true;

    	TES;


    ! Delete leading semicolons
    !
    WHILE .(.start_verify_pointer) <0, 8, 0> EQL dbg$k_semicolon
    DO
	start_verify_pointer = .start_verify_pointer + 1;


    ! Now check whether the command should be verified
    !
    IF .dbg$gb_def_out [out_verify]
		AND
       .ok_to_verify
    THEN
	$fao_tt_out (' !AD', .end_verify_pointer - .start_verify_pointer, .start_verify_pointer);

    RETURN

    END;		! End of dbg$nverify_out


GLOBAL ROUTINE DBG$NCHANGE_TO_NEW : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Performs actions associated with switching from old debugger to new 
!	debugger. These include initializing data structures, etc.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	dbg$gw_gbllngth - override length
!
!	dbg$gl_gbltyp   - override type
!
!	dbg$gw_dfltleng - default length
!
!	dbg$gl_dflttyp  - default type
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	The state of the world is changed to the way the new debugger expects it.
!
!--
    BEGIN

    ! The old debugger doesn't care about default and override lengths unless
    ! the d/o type is asci. However, the new debugger does.
    !
    dbg$gw_dfltleng =
	( CASE .dbg$gl_dflttyp FROM dsc$k_dtype_bu TO dsc$k_dtype_l
	    OF
	    SET

	    [dsc$k_dtype_bu, dsc$k_dtype_b] : 1; 	! One byte

	    [dsc$k_dtype_wu, dsc$k_dtype_w] : 2;	! Two bytes

	    [dsc$k_dtype_lu, dsc$k_dtype_l] : 4;	! Four bytes

	    [INRANGE, OUTRANGE] : .dbg$gw_dfltleng;	! No change
	    
	    TES);

    IF .dbg$gl_gbltyp NEQ -1
    THEN
	dbg$gw_gbllngth =
		( CASE .dbg$gl_gbltyp FROM dsc$k_dtype_bu TO dsc$k_dtype_l
		    OF
		    SET

		    [dsc$k_dtype_bu, dsc$k_dtype_b] : 1;

		    [dsc$k_dtype_wu, dsc$k_dtype_w] : 2;
	
		    [dsc$k_dtype_lu, dsc$k_dtype_l] : 4;

		    [INRANGE, OUTRANGE] : .dbg$gw_gbllngth;

		    TES);

    RETURN;

    END;	! End of dbg$nchange_to_new

GLOBAL ROUTINE DBG$NSAVE_BREAK_BUFFER(INPUT_DESC, BUFFER) : NOVALUE =
!
! FUNCTION
!	This routine is essentially like DBG$EXTRACT_STR()
!	except that the bounding characters are "(" and ")" instead
!	of "'", and nesting of parentheses is allowed.  This routine
!	is called when the opening parenthesis of a list of breakpoint
!	actions is encountered.  The breakpoint actions are collected
!	but not lexically or semantically scanned.  Storage is reserved 
!	for the new string, and a pointer to this storage is returned.
!
!	This routine is also used to collect the action clause for
!	the commands IF, WHILE, and DO. Here, we collect a string as
!	in the processing for SET BREAK DO. Since we may have input after
!	the string is collected, this routine also copies over the rest
!	of the command line from save_input_desc to cmd_stg_desc. 
!
!	Another use for this routine is in commands like
!	SET DISPLAY X DO (EXAMINE Y)
!	Here also you can have input after the break buffer, since there
!	may be a comma list of displays.
!
!	A further complication for this routine but not for
!	exact_string, is that we can't just go blindly charging on
!	looking for matching parenthesis.  i.e. we can't get 
!	fooled by:
!
!		DBG>SET BREAK x DO (D/AS .=')'; etc)
!
!	We resolve this problem by NOT paying any attention to characters
!	inside quoted strings within the DO action string.
!
! INPUTS
!	INPUT_DESC - A longword containing the address of an ASCII string
!		  descriptor describing the present input command.
!
!	BUFFER - The address of a longword to contain the address of the
!		  stored action buffer. This action buffer is stored as
!		  a counted string with a word count at the beginning.
!		  (I.e., an ASCIW string).
!
! OUTPUTS
!	BUFFER	- The address of the saved DEBUG command list action buffer
!		  is returned to the BUFFER longword.
!

    BEGIN

    MAP
	INPUT_DESC: REF DBG$STG_DESC,	! The input string descriptor
	BUFFER: REF VECTOR[1,LONG];	! Pointer to buffer address return loc.

    LOCAL
	DELIMITER,			! Current delimiter character
	ERROR_LENGTH,			! Used for error messages
	ERROR_PTR,			! Used for error messages
	NEW_POINTER,			! Temporary pointer
	USE_COUNT,			! Number of characters used from input
	PARSE_STG_DESC: REF DBG$STG_DESC,! Parse input string descriptor
	POINTER: REF VECTOR[,WORD],	! Holds address of dynamic storage for
					!      action string when collected
	PAREN_COUNT,			! Count of paren levels
    	PTR: REF VECTOR[,BYTE],
	CHAR,				! Holds a single character
	COUNT,				! Character count
	INPUT_PTR,			! Current pointer to input string
	IN_STRING,			! 0 => we are not currently within an
					!      embedded quoted string.  Other-
					!      wise we are, and .in_string is
					!      the string delimiter (' or ").
    	LEN,
	TEMP_PTR: BLOCK[8,BYTE];	! String descriptor for embedded quote strings



    ! The present input descriptor describes the input command lineup to the first
    ! semicolon in the entire input line. Since we may have semicolons embedded
    ! in a break action sequence, we must construct a buffer which contains the
    ! present command line plus the rest of the input line. The remaining input
    ! line is described by save_input_desc. Later, we must update the save_input_string
    ! to reflect any input that we have used.
    !
    ! Obtain storage for the descriptor.
    !
    PARSE_STG_DESC = DBG$GET_TEMPMEM (2);


    ! Allocate a new buffer to hold all the input.
    !
    PARSE_STG_DESC [DSC$A_POINTER] = DBG$GET_TEMPMEM(((.INPUT_DESC [DSC$W_LENGTH] + 
    	    .SAVE_INPUT_DESC [DSC$W_LENGTH] ) / %UPVAL) + 1);


    ! Copy the portion of the string from INPUT_DESC into the new descriptor.
    ! One complication is that for C, we want to copy from the original
    ! input buffer, not the upcased one.
    !
    INPUT_PTR = .INPUT_DESC[DSC$A_POINTER];
    IF .DBG$GB_LANGUAGE EQL DBG$K_C
    THEN
	BEGIN
	IF (.INPUT_PTR LSS .DBG$GL_UPCASE_COMMAND_PTR[0]) OR
	   (.INPUT_PTR GTR .DBG$GL_UPCASE_COMMAND_PTR[1])
    	THEN
    	    $DBG_ERROR('DBGNCNTRL\DBG$NSAVE_BREAK_BUFFER 10');

	INPUT_PTR = (.INPUT_PTR - .DBG$GL_UPCASE_COMMAND_PTR[0]) + 
		     .DBG$GL_ORIG_COMMAND_PTR;
	END;
    NEW_POINTER = CH$MOVE (.INPUT_DESC [DSC$W_LENGTH], .INPUT_PTR,
		           .PARSE_STG_DESC [DSC$A_POINTER]);


    ! There is a <CR> at the end of the input descriptor.  Change this to a
    ! semicolon.
    !
    CH$WCHAR (';', .NEW_POINTER - 1);


    ! Now copy the rest of the input line.
    !
    CH$MOVE (.SAVE_INPUT_DESC [DSC$W_LENGTH], .SAVE_INPUT_DESC [DSC$A_POINTER],
	     .NEW_POINTER);


    ! Set the count.
    !
    PARSE_STG_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] + .SAVE_INPUT_DESC [DSC$W_LENGTH];		


    ! Set the variables used for error reporting.
    !
    ERROR_LENGTH = .PARSE_STG_DESC [DSC$W_LENGTH] - 1;
    ERROR_PTR = .PARSE_STG_DESC [DSC$A_POINTER];


    ! Do the real work.
    !
    INPUT_PTR = CH$PTR (.PARSE_STG_DESC [DSC$A_POINTER]);
    COUNT = 0;
    IN_STRING = 0;
    TEMP_PTR[DSC$A_POINTER] = 0;
    PAREN_COUNT = 1;
    WHILE TRUE DO
	BEGIN


	! Pick up the next character and see if we
	! have run off the end of the string.
	!
	CHAR = CH$RCHAR (.INPUT_PTR);
	IF .CHAR EQL 0
	THEN
	    BEGIN


 	    ! The string we complain about not begin delimited
	    ! is either the supposed break action string, or
	    ! a non-terminated embedded quoted string.
	    !
	    IF .TEMP_PTR[DSC$A_POINTER] NEQ 0
	    THEN
		BEGIN


		! We didn't find the ending ')' for the break
		! action string because an embedded ascii 
		! string was not properly terminated.
		!
		PARSE_STG_DESC[DSC$A_POINTER] = .TEMP_PTR[DSC$A_POINTER];
		PARSE_STG_DESC[DSC$W_LENGTH] = .TEMP_PTR[DSC$W_LENGTH];
		DELIMITER = .IN_STRING;
		END

	    ELSE
		BEGIN

		! The action string itself was not terminated.
		!
		PARSE_STG_DESC [DSC$W_LENGTH] = .ERROR_LENGTH;
		PARSE_STG_DESC [DSC$A_POINTER] = .ERROR_PTR;
		DELIMITER = %C')';
		END;


	    ! Truncate the string to 10 characters unless it is already
	    ! smaller than that.
	    !				
	    IF .PARSE_STG_DESC[DSC$W_LENGTH] GTR 10
	    THEN
		PARSE_STG_DESC[DSC$W_LENGTH] = 10;

	    SIGNAL(DBG$_NOEND, 3, .PARSE_STG_DESC, 1, DELIMITER);
	    END;


	! If we are not already in an embedded quoted string, then this may be
	! the beginning of one.  If we are, then this may be the end of it.
	!
	IF .CHAR EQL %C'''' OR .CHAR EQL %C'"'
	THEN
	    BEGIN


	    ! IN_STRING tells not only whether or not we are in a quoted
	    ! string, but what that string is delimited by.
	    !
	    IF .IN_STRING EQL 0
	    THEN
		BEGIN


		! Now we are within a string.  Save the delimiter so we can
		! find the end of it.
		!
		IN_STRING = .CHAR;


		! Also save a string descriptor for this string as we may need
		! it for later error processing.  This string descriptor
		! includes the supposed delimiting character.
		!
		TEMP_PTR[DSC$A_POINTER] = .INPUT_PTR;
		TEMP_PTR[DSC$W_LENGTH] = .ERROR_LENGTH - .COUNT;
		END

	    ELSE
		BEGIN


		! See if this quote ends the string we were already in.
		!
		IF .IN_STRING EQL .CHAR
		THEN
		    BEGIN
		    IN_STRING = 0;
		    TEMP_PTR[DSC$A_POINTER] = 0;
		    END;

		END;

	    END

	ELSE
	    BEGIN


	    ! If we are already in an embedded string, and there is no chance
	    ! that it is ending, then we don't care what the current character
	    ! is.  Otherwise we have to look for parenthesis.
	    !
	    IF .IN_STRING EQL 0
	    THEN
		BEGIN


	    	! We are not in an embedded string.  Now we sort out the
		! parenthesis matching.
		!	
	        IF .CHAR EQL %C')'
		THEN
		    BEGIN
	
		
		    ! Found a closing parenthesis. See whether this one matches
		    ! the opening breakpoint action parenthesis, and if it
		    ! does, then exit from this loop, and thus from the macro.
		    !
		    PAREN_COUNT = .PAREN_COUNT - 1;
		    IF .PAREN_COUNT LEQ 0 THEN EXITLOOP;
		    END

		ELSE IF .CHAR EQL %C'('
		THEN
		    PAREN_COUNT = .PAREN_COUNT + 1;

		END;

	    END;


	! Increment the character counter, update the pointer so that we are
	! looking at the next character, and loop back to do so.
	!
	COUNT = .COUNT + 1;
	INPUT_PTR = CH$PLUS (.INPUT_PTR, 1);
	PARSE_STG_DESC [DSC$W_LENGTH] = .PARSE_STG_DESC [DSC$W_LENGTH] - 1;

	END;				! End of loop


    ! The breakpoint action string has been isolated.  We now allocate a buffer
    ! in dynamic memory for it.  The number of bytes we need to allocate is the
    ! action string size + 3 because we need 2 more bytes to hold the count 
    ! and one byte to hold a trailing zero. We then apply the standard formula
    ! num_longwords = (num_bytes+3)/%UPVAL
    !
    POINTER = DBG$GET_MEMORY(((.COUNT + 3) + 3)/%UPVAL);


    ! Copy the action string from the input buffer, and then overwrite the
    ! character before the string begins so that is becomes a counted string
    ! action buffer.  We also ensure that there is a 0 character at the end
    ! of the buffer to ensure proper termination of parsing it when the break
    ! happens.
    !
    POINTER[0] = .COUNT + 1;	! "+ 1" is for trailing zero
    PTR = CH$MOVE(.COUNT, .PARSE_STG_DESC[DSC$A_POINTER], POINTER[1]);
    PTR[0] = 0;			! Add trailing zero


    ! Now update the parse string descriptor to address the character after
    ! the closing parenthesis.
    !
    PARSE_STG_DESC[DSC$A_POINTER] = CH$PLUS(.INPUT_PTR, 1);
    PARSE_STG_DESC[DSC$W_LENGTH] = .PARSE_STG_DESC[DSC$W_LENGTH] - 1;

    
    ! Now comes the time to figure out what we have and have not eaten so
    ! that the SAVE_INPUT_DESC may be updated properly.  We must also update
    ! the original input descriptor.  Check to see if there is still more
    ! stuff from INPUT_DESC.
    !
    ! If the INPUT_DESC buffer has not been used completely, we set up the
    ! INPUT_DESC string descriptor to point to what remains.
    !
    IF .PARSE_STG_DESC[DSC$A_POINTER] LSSA .NEW_POINTER
    THEN
	BEGIN
        INPUT_DESC[DSC$A_POINTER] = .INPUT_DESC[DSC$A_POINTER] +
			     .INPUT_DESC[DSC$W_LENGTH] - 
			     (.NEW_POINTER - .PARSE_STG_DESC[DSC$A_POINTER]);
	INPUT_DESC[DSC$W_LENGTH] = .NEW_POINTER - .PARSE_STG_DESC[DSC$A_POINTER];
	END


    ! Otherwise, the INPUT_DESC buffer has been exhausted and we are into the
    ! SAVE_INPUT_DESC buffer.  Update it and show exhaustion of the INPUT_DESC
    ! buffer.
    !
    ELSE
	BEGIN


	! Show INPUT_DESC to be empty and update SAVE_INPUT_DESC.
	!
	INPUT_DESC[DSC$A_POINTER] = 0;
	INPUT_DESC[DSC$W_LENGTH] = 0;
	SAVE_INPUT_DESC[DSC$A_POINTER] = .SAVE_INPUT_DESC[DSC$A_POINTER] +
			.PARSE_STG_DESC[DSC$A_POINTER] - .NEW_POINTER;
	SAVE_INPUT_DESC [DSC$W_LENGTH] = .SAVE_INPUT_DESC[DSC$W_LENGTH] -
			(.PARSE_STG_DESC[DSC$A_POINTER] - .NEW_POINTER);


    	! We may need to move more of the command buffer into INPUT_DESC.
    	! For example, in "IF TRUE THEN (E X;E Y) ELSE (E Z)" then the
    	! "ELSE (E Z)" now sits in the SAVE_INPUT_DESC buffer and we
    	! must move it into INPUT_DESC so that the parsing of the IF command
    	! can be continued. Similarly with 
    	! "SET DISP X DO (E X;E Y), Y DO (E Z)"
    	! We call DBG$NGET_CMD to do this for us.
    	! On the other hand, if a semicolon followed the command buffer, as in
    	! "IF TRUE THEN (EX X;EX Y);E Z"
    	! then we do not want to charge ahead and collect the "E Z". 
    	! So we check for semicolon.
    	!
    	LEN = .SAVE_INPUT_DESC[DSC$W_LENGTH];  
  	PTR = .SAVE_INPUT_DESC[DSC$A_POINTER];
    	WHILE (.PTR[0] EQL DBG$K_BLANK) AND (.LEN NEQ 0) DO
    	    BEGIN
    	    PTR = .PTR + 1;
    	    LEN = .LEN - 1;
    	    END;
    	IF (.PTR[0] NEQ DBG$K_SEMICOLON) AND (.LEN NEQ 0)
    	THEN
    	    DBG$NGET_CMD(.SAVE_INPUT_DESC, .INPUT_DESC, MESSAGE_POINTER, FALSE);

	END;


    ! Return a pointer to the saved-away action buffer.
    !
    BUFFER[0] = .POINTER;
    END;

ROUTINE GET_C_CMD_STRING(INPUT_DESC, CMD_DESC, CIS_DESC, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets the first command from the input line.  Also,
!	uppercases the line except for what is in quotes.  This routine
!	takes care of stripping the comments off the end of a DEBUG
!	command. For the language C, the comment characters are '/*'.
!
! FORMAL PARAMETERS:
!
!	input_desc -		a VAX standard descriptor of the input line
!
!	cmd_desc -		a descriptor that will hold the next command
!				line.
!	cis_desc -		a descriptor for the current command input
!				stream.  Just another copy of the above in
!				case the command is a WHILE-DO.
!	message_vect -		the address of a longword to contain the address
!				of a message argument vector.
!
! ROUTINE VALUE:
!
!	A status of the routine.
!
!--

    BEGIN

    MAP
	INPUT_DESC	: REF dbg$stg_desc,	! Command line
	CIS_DESC	: REF CIS$LINK,		! Current command input stream
	CMD_DESC	: REF BLOCK [,BYTE];	! We don't REF to dbg$stg_desc
						! because of the extra longword
						! for the initial dsc$a_pointer
    LOCAL
        CHAR_COUNT,
        CHAR_STRING	: REF VECTOR [,BYTE],	! Vector of characters
	QUOTE_FLAG,
	QUOTE_CHAR;


    char_string = .input_desc[dsc$a_pointer];
    char_count = 0;

    ! Check for a comment line. For C the comment character is '/*',
    ! but we also treat a beginning-of-line '!' as a comment line.
    ! The reason for this is so that the output of DEBUG log files
    ! can still be used as DEBUG input even if language is set to C.
    !
    IF .char_string [.char_count] EQL '!'
    OR (.char_string [.char_count] EQL '/'
    AND .char_string [.char_count+1] EQL '*')
    THEN
	BEGIN
	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] +
	       			     .input_desc [dsc$w_length];
	input_desc [dsc$w_length] = 0;
	RETURN sts$k_error;
	END;


    ! Before proceeding, we fill in the CIS$A_WHILE_CLAUSE field
    ! to point to the beginning of the command. This is in case the command
    ! is a WHILE; then we are able to iterate by backing up to the 
    ! beginning of the command.
    ! The following code relies on the fact that INPUT_DESC is superimposed
    ! on the top link pointed to by DBG$GL_CISHEAD.
    !
    cis_desc = .input_desc;
    cis_desc [cis$a_while_clause] = .input_desc [dsc$a_pointer];
    cis_desc [cis$w_while_length] = .input_desc [dsc$w_length];


    ! Now count the characters in the command
    !
    char_string = .input_desc [dsc$a_pointer];
    char_count = 0;
    quote_flag = false;
    WHILE .input_desc [dsc$w_length] GTR 0
    DO
	BEGIN
	    IF .char_string [.char_count] EQL dbg$k_car_return
				OR
	       .char_string [.char_count] EQL dbg$k_line_feed
				OR
	       .char_string [.char_count] EQL dbg$k_null
				OR
	       ((NOT .quote_flag) AND .char_string [.char_count] EQL ';')
				OR
    	       ((NOT .quote_flag) AND .char_string [.char_count] EQL '/'
    				  AND .char_string [.char_count+1] EQL '*')
	    THEN
		EXITLOOP
	    ELSE
		BEGIN
		    IF .char_string [.char_count] EQL dbg$k_quote
					OR
		       .char_string [.char_count] EQL dbg$k_dblquote
		    THEN
			BEGIN
			IF NOT .quote_flag
			THEN
			    BEGIN
			    quote_char = .char_string [.char_count];
			    quote_flag = true;
			    END
			ELSE
			    BEGIN
			    IF .char_string [.char_count] EQL .quote_char
			    THEN
				quote_flag = false;
			    END;
			END;

		    char_count = .char_count + 1;
		    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
		END;
	END; 


    ! Now try to get storage for the command string
    !
    cmd_desc [dsc$a_pointer] = dbg$get_tempmem((.char_count / %UPVAL) + 1);


    ! Save away pointers both to the original input string, and to
    ! the copied string in cmd_desc. These are used later as follows:
    ! In the language C, a lower case name represents a distinct object
    ! from its upper-case counterpart. Since we upper-case commands in
    ! cmd_desc, we will need to go back to the original input_desc to
    ! get at the original version of the name. For this, we need these
    ! two pointers.
    !
    ! The pointer to the upcased string is actually a vector containing
    ! pointers to the beginning and the end of the string.
    !
    dbg$gl_orig_command_ptr = .input_desc[dsc$a_pointer];
    dbg$gl_upcase_command_ptr[0] = .cmd_desc[dsc$a_pointer];
    dbg$gl_upcase_command_ptr[1] = .cmd_desc[dsc$a_pointer] + .char_count - 1;

    ! Fill the command buffer
    !
    ch$move ( .char_count, .input_desc [dsc$a_pointer], .cmd_desc [dsc$a_pointer]);


    ! Update the input descriptor pointer. Check for a comment to skip.
    ! The comment character is '/*' in C.
    !
    IF .char_string [.char_count] EQL '/'
       AND .char_string [.char_count+1] EQL '*'
    THEN
	BEGIN
    	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] +
    				     .input_desc[dsc$w_length] + 
    				     .char_count;
	input_desc [dsc$w_length] = 0;
	END
    ELSE
	input_desc [dsc$a_pointer] = char_string [.char_count];
    

    ! Update the command descriptor
    !
    cmd_desc [initial_ptr] = .cmd_desc [dsc$a_pointer];
    cmd_desc [dsc$w_length] = .char_count;
    char_string = .cmd_desc [dsc$a_pointer];


    ! Now check for bad chars and translate to upper case
    !
    char_count = 0;
    quote_flag = false;
    WHILE .char_count LSS .cmd_desc [dsc$w_length]
    DO
	BEGIN
	    IF .char_string [.char_count] EQL dbg$k_tab
	    THEN
		char_string [.char_count] = dbg$k_blank;  ! Convert tab to space

	    IF .char_string [.char_count] LSS dbg$k_blank
	    THEN
		BEGIN
		.message_vect = dbg$nmake_arg_vect (dbg$_invchar);
		RETURN sts$k_severe;
		END
	    ELSE
		BEGIN
		    IF .char_string [.char_count] EQL dbg$k_quote
					OR
		       .char_string [.char_count] EQL dbg$k_dblquote
		    THEN
			BEGIN
			IF NOT .quote_flag
			THEN
			    BEGIN
			    quote_char = .char_string [.char_count];
			    quote_flag = true;
			    END
			ELSE
			    BEGIN
			    IF .char_string [.char_count] EQL .quote_char
			    THEN
				quote_flag = false;
			    END;
			END;

		IF .char_string [.char_count] GEQ 'a'
				AND
		   .char_string [.char_count] LEQ 'z'
				AND
		   NOT .quote_flag
		THEN
		    char_string [.char_count] = .char_string [.char_count] 
						- dbg$k_lcbias;
		END;
	   
	    char_count = .char_count + 1;

	END;


    ! Termanate the command with a <cr>
    !
    char_string [.char_count] = dbg$k_car_return;
    cmd_desc [dsc$w_length] = .cmd_desc [dsc$w_length] + 1;

    RETURN sts$k_success;
    END;

ROUTINE GET_ADA_CMD_STRING(INPUT_DESC, CMD_DESC, CIS_DESC, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets the first command from the input line.  Also,
!	uppercases the line except for what is in quotes.  This routine
!	takes care of stripping the comments off the end of a DEBUG
!	command. For Ada the comment character is '!'. There is also
!	special code for the Ada tick operator that looks a lot
!	like a single quote. And picking up a quoted quote is different.
!	(e.g. ''' is the character single quote.
!
! FORMAL PARAMETERS:
!
!	input_desc -		a VAX standard descriptor of the input line
!
!	cmd_desc -		a descriptor that will hold the next command
!				line.
!	cis_desc -		a descriptor for the current command input
!				stream.  Just another copy of the above in
!				case the command is a WHILE-DO.
!	message_vect -		the address of a longword to contain the address
!				of a message argument vector.
!
! ROUTINE VALUE:
!
!	A status of the routine.
!
!--

    BEGIN

    MAP
	INPUT_DESC	: REF dbg$stg_desc,	! Command line
	CIS_DESC	: REF CIS$LINK,		! Current command input stream
	CMD_DESC	: REF BLOCK [,BYTE];	! We don't REF to dbg$stg_desc
						! because of the extra longword
						! for the initial dsc$a_pointer
    LOCAL
        CHAR_COUNT,
        CHAR_STRING	: REF VECTOR [,BYTE],	! Vector of characters
	QUOTE_FLAG,
	QUOTE_CHAR;


    char_string = .input_desc[dsc$a_pointer];
    char_count = 0;

    ! Check for a comment line. For all languages except C, the comment
    ! character is '!'.
    !
    IF .char_string [.char_count] EQL '!'
    THEN
	BEGIN
	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] +
	       			     .input_desc [dsc$w_length];
	input_desc [dsc$w_length] = 0;
	RETURN sts$k_error;
	END;


    ! Before proceeding, we fill in the CIS$A_WHILE_CLAUSE field
    ! to point to the beginning of the command. This is in case the command
    ! is a WHILE; then we are able to iterate by backing up to the 
    ! beginning of the command.
    ! The following code relies on the fact that INPUT_DESC is superimposed
    ! on the top link pointed to by DBG$GL_CISHEAD.
    !
    cis_desc = .input_desc;
    cis_desc [cis$a_while_clause] = .input_desc [dsc$a_pointer];
    cis_desc [cis$w_while_length] = .input_desc [dsc$w_length];


    ! Now count the characters in the command
    !
    char_string = .input_desc [dsc$a_pointer];
    char_count = 0;
    quote_flag = false;
    WHILE .char_count LSS .input_desc [dsc$w_length]
    DO
	BEGIN
	    IF .char_string [.char_count] EQL dbg$k_car_return
				OR
	       .char_string [.char_count] EQL dbg$k_line_feed
				OR
	       .char_string [.char_count] EQL dbg$k_null
				OR
	       ((NOT .quote_flag) AND .char_string [.char_count] EQL ';')
				OR
   	       ((NOT .quote_flag) AND .char_string [.char_count] EQL '!')
	    THEN
		EXITLOOP
	    ELSE
		BEGIN
		    IF .char_string [.char_count] EQL dbg$k_quote
					OR
		       .char_string [.char_count] EQL dbg$k_dblquote
		    THEN
			BEGIN
			IF NOT .quote_flag
			THEN
                            ! Make sure this is not a tick operator.  This is
                            ! nasty stuff... (e.g. '(';') => TICK, but '(';')' => QUOTE)
                            !
                            IF (.char_string [.char_count] EQL dbg$k_quote) AND
                               (.char_count LEQ .input_desc [dsc$w_length] - 2) AND
                               (.char_string [.char_count + 2] EQL dbg$k_quote)
                            THEN
                                BEGIN
                                IF (.char_string [.char_count + 1] NEQ dbg$k_left_parenthesis)
                                THEN
                                    BEGIN
                                    quote_char = .char_string [.char_count];
                                    quote_flag = true;
                                    END
                                ELSE
                                    IF (.char_count LEQ .input_desc [dsc$w_length] - 4) AND
                                       (.char_string [.char_count + 4] NEQ dbg$k_quote)
                                    THEN
                                        BEGIN
                                        quote_char = .char_string [.char_count];
                                        quote_flag = true;
                                        END
                                    ELSE
                                        IF (.char_count LEQ .input_desc [dsc$w_length] - 6) AND
                                           (.char_string [.char_count + 6] EQL dbg$k_quote)
                                        THEN
                                            BEGIN
                                            quote_char = .char_string [.char_count];
                                            quote_flag = true;
                                            END;
                                END
                        ELSE
			    BEGIN
			    IF .char_string [.char_count] EQL .quote_char
			    THEN
				quote_flag = false;
			    END;
			END;

		    char_count = .char_count + 1;
		END;
	END; 

    ! Make sure the length is correct.
    !
    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - .char_count;

    ! Now try to get storage for the command string
    !
    cmd_desc [dsc$a_pointer] = dbg$get_tempmem((.char_count / %UPVAL) + 1);


    ! Save away pointers both to the original input string, and to
    ! the copied string in cmd_desc. These are used later as follows:
    ! In the language C, a lower case name represents a distinct object
    ! from its upper-case counterpart. Since we upper-case commands in
    ! cmd_desc, we will need to go back to the original input_desc to
    ! get at the original version of the name. For this, we need these
    ! two pointers.
    !
    ! The pointer to the upcased string is actually a vector containing
    ! pointers to the beginning and the end of the string.
    !
    dbg$gl_orig_command_ptr = .input_desc[dsc$a_pointer];
    dbg$gl_upcase_command_ptr[0] = .cmd_desc[dsc$a_pointer];
    dbg$gl_upcase_command_ptr[1] = .cmd_desc[dsc$a_pointer] + .char_count - 1;

    ! Fill the command buffer
    !
    ch$move ( .char_count, .input_desc [dsc$a_pointer], .cmd_desc [dsc$a_pointer]);


    ! Update the input descriptor pointer. Check for a comment to skip.
    ! The comment character is '!' in all languages except C.
    !
    IF .char_string [.char_count] EQL '!'
    THEN
	BEGIN
    	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] +
    				     .input_desc[dsc$w_length] + 
    				     .char_count;
	input_desc [dsc$w_length] = 0;
	END
    ELSE
	input_desc [dsc$a_pointer] = char_string [.char_count];
    

    ! Update the command descriptor
    !
    cmd_desc [initial_ptr] = .cmd_desc [dsc$a_pointer];
    cmd_desc [dsc$w_length] = .char_count;
    char_string = .cmd_desc [dsc$a_pointer];


    ! Now check for bad chars and translate to upper case
    !
    char_count = 0;
    quote_flag = false;
    WHILE .char_count LSS .cmd_desc [dsc$w_length]
    DO
	BEGIN
	    IF .char_string [.char_count] EQL dbg$k_tab
	    THEN
		char_string [.char_count] = dbg$k_blank;  ! Convert tab to space

	    IF .char_string [.char_count] LSS dbg$k_blank
	    THEN
		BEGIN
		.message_vect = dbg$nmake_arg_vect (dbg$_invchar);
		RETURN sts$k_severe;
		END
	    ELSE
		BEGIN
		    IF .char_string [.char_count] EQL dbg$k_quote
					OR
		       .char_string [.char_count] EQL dbg$k_dblquote
		    THEN
			BEGIN
			IF NOT .quote_flag
			THEN
                            ! Make sure this is not a tick operator.  This is
                            ! nasty stuff... (e.g. '(';') => TICK, but '(';')' => QUOTE)
                            !
                            IF (.char_string [.char_count] EQL dbg$k_quote) AND
                               (.char_count LEQ .cmd_desc [dsc$w_length] - 2) AND
                               (.char_string [.char_count + 2] EQL dbg$k_quote)
                            THEN
                                BEGIN
                                IF (.char_string [.char_count + 1] NEQ dbg$k_left_parenthesis)
                                THEN
                                    BEGIN
                                    quote_char = .char_string [.char_count];
                                    quote_flag = true;
                                    END
                                ELSE
                                    IF (.char_count LEQ .cmd_desc [dsc$w_length] - 4) AND
                                       (.char_string [.char_count + 4] NEQ dbg$k_quote)
                                    THEN
                                        BEGIN
                                        quote_char = .char_string [.char_count];
                                        quote_flag = true;
                                        END
                                    ELSE
                                        IF (.char_count LEQ .cmd_desc [dsc$w_length] - 6) AND
                                           (.char_string [.char_count + 6] EQL dbg$k_quote)
                                        THEN
                                            BEGIN
                                            quote_char = .char_string [.char_count];
                                            quote_flag = true;
                                            END;
                                END
			ELSE
			    BEGIN
			    IF .char_string [.char_count] EQL .quote_char
			    THEN
				quote_flag = false;
			    END;
			END;

		IF .char_string [.char_count] GEQ 'a'
				AND
		   .char_string [.char_count] LEQ 'z'
				AND
		   NOT .quote_flag
		THEN
		    char_string [.char_count] = .char_string [.char_count] 
						- dbg$k_lcbias;
		END;
	   
	    char_count = .char_count + 1;

	END;


    ! Termanate the command with a <cr>
    !
    char_string [.char_count] = dbg$k_car_return;
    cmd_desc [dsc$w_length] = .cmd_desc [dsc$w_length] + 1;

    RETURN sts$k_success;
    END;

ROUTINE GET_NORMAL_CMD_STRING(INPUT_DESC, CMD_DESC, CIS_DESC, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets the first command from the input line.  Also,
!	uppercases the line except for what is in quotes.  This routine
!	takes care of stripping the comments off the end of a DEBUG
!	command. For all languages except C, the comment character is 
!	'!'. 
!
! FORMAL PARAMETERS:
!
!	input_desc -		a VAX standard descriptor of the input line
!
!	cmd_desc -		a descriptor that will hold the next command
!				line.
!	cis_desc -		a descriptor for the current command input
!				stream.  Just another copy of the above in
!				case the command is a WHILE-DO.
!	message_vect -		the address of a longword to contain the address
!				of a message argument vector.
!
! ROUTINE VALUE:
!
!	A status of the routine.
!
!--

    BEGIN

    MAP
	INPUT_DESC	: REF dbg$stg_desc,	! Command line
	CIS_DESC	: REF CIS$LINK,		! Current command input stream
	CMD_DESC	: REF BLOCK [,BYTE];	! We don't REF to dbg$stg_desc
						! because of the extra longword
						! for the initial dsc$a_pointer
    LOCAL
        CHAR_COUNT,
        CHAR_STRING	: REF VECTOR [,BYTE],	! Vector of characters
	QUOTE_FLAG,
	QUOTE_CHAR;


    char_string = .input_desc[dsc$a_pointer];
    char_count = 0;

    ! Check for a comment line. For all languages except C, the comment
    ! character is '!'.
    !
    IF .char_string [.char_count] EQL '!'
    THEN
	BEGIN
	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] +
	       			     .input_desc [dsc$w_length];
	input_desc [dsc$w_length] = 0;
	RETURN sts$k_error;
	END;


    ! Before proceeding, we fill in the CIS$A_WHILE_CLAUSE field
    ! to point to the beginning of the command. This is in case the command
    ! is a WHILE; then we are able to iterate by backing up to the 
    ! beginning of the command.
    ! The following code relies on the fact that INPUT_DESC is superimposed
    ! on the top link pointed to by DBG$GL_CISHEAD.
    !
    cis_desc = .input_desc;
    cis_desc [cis$a_while_clause] = .input_desc [dsc$a_pointer];
    cis_desc [cis$w_while_length] = .input_desc [dsc$w_length];


    ! Now count the characters in the command
    !
    char_string = .input_desc [dsc$a_pointer];
    char_count = 0;
    quote_flag = false;
    WHILE .input_desc [dsc$w_length] GTR 0
    DO
	BEGIN
	    IF .char_string [.char_count] EQL dbg$k_car_return
				OR
	       .char_string [.char_count] EQL dbg$k_line_feed
				OR
	       .char_string [.char_count] EQL dbg$k_null
				OR
	       ((NOT .quote_flag) AND .char_string [.char_count] EQL ';')
				OR
   	       ((NOT .quote_flag) AND .char_string [.char_count] EQL '!')
	    THEN
		EXITLOOP
	    ELSE
		BEGIN
		    IF .char_string [.char_count] EQL dbg$k_quote
					OR
		       .char_string [.char_count] EQL dbg$k_dblquote
		    THEN
			BEGIN
			IF NOT .quote_flag
			THEN
			    BEGIN
			    quote_char = .char_string [.char_count];
			    quote_flag = true;
			    END
			ELSE
			    BEGIN
			    IF .char_string [.char_count] EQL .quote_char
			    THEN
				quote_flag = false;
			    END;
			END;

		    char_count = .char_count + 1;
		    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
		END;
	END; 


    ! Now try to get storage for the command string
    !
    cmd_desc [dsc$a_pointer] = dbg$get_tempmem((.char_count / %UPVAL) + 1);


    ! Save away pointers both to the original input string, and to
    ! the copied string in cmd_desc. These are used later as follows:
    ! In the language C, a lower case name represents a distinct object
    ! from its upper-case counterpart. Since we upper-case commands in
    ! cmd_desc, we will need to go back to the original input_desc to
    ! get at the original version of the name. For this, we need these
    ! two pointers.
    !
    ! The pointer to the upcased string is actually a vector containing
    ! pointers to the beginning and the end of the string.
    !
    dbg$gl_orig_command_ptr = .input_desc[dsc$a_pointer];
    dbg$gl_upcase_command_ptr[0] = .cmd_desc[dsc$a_pointer];
    dbg$gl_upcase_command_ptr[1] = .cmd_desc[dsc$a_pointer] + .char_count - 1;

    ! Fill the command buffer
    !
    ch$move ( .char_count, .input_desc [dsc$a_pointer], .cmd_desc [dsc$a_pointer]);


    ! Update the input descriptor pointer. Check for a comment to skip.
    ! The comment character is '!' in all languages except C.
    !
    IF .char_string [.char_count] EQL '!'
    THEN
	BEGIN
    	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] +
    				     .input_desc[dsc$w_length] + 
    				     .char_count;
	input_desc [dsc$w_length] = 0;
	END
    ELSE
	input_desc [dsc$a_pointer] = char_string [.char_count];
    

    ! Update the command descriptor
    !
    cmd_desc [initial_ptr] = .cmd_desc [dsc$a_pointer];
    cmd_desc [dsc$w_length] = .char_count;
    char_string = .cmd_desc [dsc$a_pointer];


    ! Now check for bad chars and translate to upper case
    !
    char_count = 0;
    quote_flag = false;
    WHILE .char_count LSS .cmd_desc [dsc$w_length]
    DO
	BEGIN
	    IF .char_string [.char_count] EQL dbg$k_tab
	    THEN
		char_string [.char_count] = dbg$k_blank;  ! Convert tab to space

	    IF .char_string [.char_count] LSS dbg$k_blank
	    THEN
		BEGIN
		.message_vect = dbg$nmake_arg_vect (dbg$_invchar);
		RETURN sts$k_severe;
		END
	    ELSE
		BEGIN
		    IF .char_string [.char_count] EQL dbg$k_quote
					OR
		       .char_string [.char_count] EQL dbg$k_dblquote
		    THEN
			BEGIN
			IF NOT .quote_flag
			THEN
			    BEGIN
			    quote_char = .char_string [.char_count];
			    quote_flag = true;
			    END
			ELSE
			    BEGIN
			    IF .char_string [.char_count] EQL .quote_char
			    THEN
				quote_flag = false;
			    END;
			END;

		IF .char_string [.char_count] GEQ 'a'
				AND
		   .char_string [.char_count] LEQ 'z'
				AND
		   NOT .quote_flag
		THEN
		    char_string [.char_count] = .char_string [.char_count] 
						- dbg$k_lcbias;
		END;
	   
	    char_count = .char_count + 1;

	END;


    ! Termanate the command with a <cr>
    !
    char_string [.char_count] = dbg$k_car_return;
    cmd_desc [dsc$w_length] = .cmd_desc [dsc$w_length] + 1;

    RETURN sts$k_success;
    END;

END ELUDOM
