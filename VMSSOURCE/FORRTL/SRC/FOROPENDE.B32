MODULE FOR$$OPEN_DEFLT (%TITLE 'FORTRAN default open'
		IDENT = '1-098'		! File: FOROPENDE.B32  Edit: LEB1098
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: FORTRAN Support Library - not user callable
!
! ABSTRACT:
!
!	This module contains a routine to perform default file
!	opening for FORTRAN programs.
!
! ENVIRONMENT: User access mode; mixture of AST level or not.
!
! AUTHOR:	Thomas N. Hastings, CREATION DATE: 6-Mar-77; Version 0
!
! MODIFIED BY:
!
!	Thomas N. Hastings, 15-Mar-77: Version 0
! [Previous edit history removed.  SBL 5-Oct-1982]
! 1-078 - Add support for DEFAULTFILE=string.  JAW 30-Jun-1981
! 1-079 - Increase default value of RECL for unformatted variable-length
!	  records from 126 to 2046, to improve performance when
!	  RECORDTYPE='SEGMENTED'.  JAW 17-Jul-1981
! 1-080 - Fix logic error in record type check made when user does not
!	  specify record type for an old file.  (Allowed both FIXED and
!	  SEGMENTED to be set simultaneously.)  JAW 25-Aug-1981
! 1-081 - Change algorithm for determining the length of a list-directed
!	  output record: use RECL if specified, else 80/81 depending on
!	  carriage control.  JAW 26-Aug-1981
! 1-082 - Add test for blocksize less than recordsize (made only if open
!	  or create fails and device is mag tape).  If so, signal
!	  INCRECLEN since RMS does not give a useful message in this
!	  case.  JAW 28-Aug-1981
! 1-083 - Save and restore the STS and STV around the $PARSE we do if we
!	  get an unexpected error.  SBL 28-Sep-1981
! 1-084 - Signal FOR$K_OPEFAI if RMS$_WLK and not readonly.  DGP 03-Dec-1981
! 1-085 - Set the MRS in the FAB for indexed files.  DGP 21-Dec-1981
! 1-086 - Allow existing file to be SEGMENTED only if it has RFM=VAR.  
!	  Correct 1-082 and 1-084 so that only RMS$_CRE errors check for
!	  INCRECLEN.  SBL 13-Jan-1982
! 1-087 - Complete 1-085.  It was much too simplistic and caused existing ISAM
!	  files to not be able to opened.  DGP 22-Feb-1982
! 1-088 - Unfortunately, 1-087 did not allow existing ISAM files with an MRS
!	  smaller than the default buffer size to be opened unless the
!	  RECL was explicitly specified.  Fix it.  SBL 16-Apr-1982
! 1-089 - For devices other than disks and terminals, reduce the default
!	  recordsize to less than the blocksize, if necessary.  Use blocksize
!	  as recordsize on existing files, if no MRS or LRL.  SBL 30-Sep-1982
! 1-090 - Make default unformmated RECL 2044 instead of 2046.  This allows
!	  default disk files to be copied to tape.  SBL 8-Nov-1982
! 1-091 - Reflect change that OTS$$ data structures are now FOR$$.  SBL 8-Nov-1982
! 1-092 - Restore some INCOPECLO checks that were mistakenly deleted 
!	  in an earlier edit.  Use new macro to call FOR$$SIGNAL_STO.  
!	  Move FAB and NAM to heap at end of RAB.  Add support for stream
!	  recordtypes.  Raise bucketsize limit to 63.  Use carriagecontrol
!	  specified/defaulted if PPF.  Don't decrement recordlength by 4
!	  unless SEGMENTED.  SBL 29-Mar-1983
! 1-093 - Add RFA cacheing for BACKSPACE.  SBL 2-June-1983
! 1-094 - Restrict stream recordtypes to sequential org only.  SBL 28-Jul-1983
! 1-095 - Use LNM$C_NAMLENGTH for maximum size of equivalence string in call
!	  to $TRNLOG.  DG 8-Nov-1983
! 1-096 - Add stack location of TEMP_FNS to store the temporary filespec
!	  for ASSIGN.  Also change back use of LNM$C_NAMLENGTH to be
!	  NAM$C_MAXRSS.  LEB 2-Feb-1984
! 1-097 - Free KEY_XABs when an open fails. STAN 27-Feb-1984.
! 1-098 - Disassociate the NAM block during the $PARSE to clear up a
!	  problem associated with floating memory.  LEB 21-Mar-1984
!--


!
! PROLOGUE FILE:
!

REQUIRE 'RTLIN:FORPROLOG';			! FORTRAN definitions

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    FOR$$OPEN_DEFLT : CALL_CCB NOVALUE,		! default OPEN
    FOR$$OPEN_PROC : CALL_CCB NOVALUE;		! common OPEN procedure

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    FOR$$ERR_OPECLO,				! OPEN/CLOSE condition handler
    FOR$$SIGNAL_STO : NOVALUE,			! Convert small FORTRAN err #
    						! to 32-bit VAX error # and SIGNAL_STOP
    FOR$$SIG_NO_LUB : NOVALUE,			! same as FOR$$SIGNAL_STO except no LUB setup
    						! so must pass LUN explicitly.
    FOR$$CB_PUSH : JSB_CB_PUSH NOVALUE,		! push current LUB/ISB/RAB, if any, and allocate LUB/ISB/RAB
    						! for this logical unit
    FOR$$CB_POP : JSB_CB_POP NOVALUE,		! Pop I/O system back to previous LUB or indicate
    						! no I/O statement is currently being processed.
    FOR$$GET_VM,				! Allocate virtual memory
    FOR$$FREE_VM : NOVALUE,			! Free virtual memory
    FOR$$SIG_FATINT : NOVALUE,			! Signal_stop internal error
    FOR$$DECL_EXITH : NOVALUE;			! Declare the exit handler

EXTERNAL
    FOR$$L_XIT_LOCK;				! True if exit handler already declared


GLOBAL ROUTINE FOR$$OPEN_DEFLT (		! Default OPEN
	ACCESS_VAL, 				! Access = OPEN$K_ACC_{SEQ, DIR}
	TYPE_VAL, 				! TYPE = OPEN$K_ACC_{NEW,OLD}
	FORM_VAL)				! FORM = OPEN$K_FOR_{UNF, FOR, UNS}
    : CALL_CCB NOVALUE =

!++
! ABSTRACT:
!
!	Perform default OPEN for an I/O statement for the indicated
!	logical unit. The possible parameters are a restricted
!	subset of explicit OPEN, plus FORM = 'UNSPECIFIED' (for
!	ENDFILE only). The keywords for default OPEN are:
!	ACCESS, TYPE, and FORM.
!
! FORMAL PARAMETERS:
!
!	LUB_ADR.mlu.ra		adr of LUB/ISB/RAB control block
!	ACCESS_VAL.rlu.v	Value = OPEN$K_ACC_{SEQ,DIR}
!				to indicate ACCESS = 'SEQUENTIAL'
!				or 'DIRECT'.
!	TYPE_VAL.rlu.v		Value = OPEN$K_TYPE_{NEW, OLD} TO
!				indicate TYPE = 'NEW' or 'OLD'
!	FORM_VAL.rlu.v		Value = OPEN$K_FORM_{UNF, FOR, UNS}
!				to indicate FORM = 'UNFORMATTED',
!				'FORMATTED', or 'UNSPECIFIED
!				(ENDFILE only).
!
! IMPLICIT INPUTS:
!
!	LUB$V_READ_ONLY		1 if 'READONLY' specified in CALL FDBSET
!	LUB$V_DIRECT		1 if specified on previous DEFINEFILE
!	LUB$V_OLD_FILE		1 if specified on previous CALL FDBSET
!	LUB$V_UNFORMAT		1 if specified on previous DEFINEFILE
!	LUB$W_LUN		FORTRAN logical unit number
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_DIRECT		1 if ACCESS = 'DIRECT' or DEFINEFILE
!	LUB$V_OLD_FILE		1 if TYPE = 'OLD' or CALL FDBSET 'OLD'
!	LUB$V_FORMATTED		1 if FORM = 'FORMATTED'
!	LUB$V_UNFORMAT		1 if FORM = 'UNFORMATTED' or DEFINEFILE
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	See FOR$$OPEN_PROC for SIGNAL_STOPs.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF $FOR$CCB_DECL;

    LOCAL
	OPEN : VECTOR [OPEN$K_KEY_MAX + 1];	! OPEN parameter array

    !+
    ! Clear OPEN parameter array
    !-

    CH$FILL (0, (OPEN$K_KEY_MAX + 1)*%UPVAL, OPEN);

    !+
    ! Setup count, ACCESS, TYPE, and FORM parameter values
    !-

    OPEN [OPEN$K_ACCESS] = .ACCESS_VAL;
    OPEN [OPEN$K_TYPE] = .TYPE_VAL;
    OPEN [OPEN$K_FORM] = .FORM_VAL;

    !+
    ! Perform the OPEN - call common procedure with a pointer
    ! to the OPEN parameter VECTOR of longword values.
    !-

    FOR$$OPEN_PROC (OPEN);
    RETURN;
    END;					! End of FOR$OPEN_DEFLT routine


GLOBAL ROUTINE FOR$$OPEN_PROC (			! Do an OPEN
	OPEN_ADR)				! Address of OPEN parameter vector
    : CALL_CCB NOVALUE =

!++
! ABSTRACT:
!
!	This routine performs the OPEN for FOR$OPEN and FOR$$OPEN_DEFLT.
!	The OPEN parameters have been picked up and placed in a
!	longword array. The index is parameter specific. The parameters
!	are processed in a logical order which minimizes the
!	distance between parameters which depend on each other.
!	Each parameter sets an appropriate part of the LUB/ISB/RAB
!	control block or the FAB control block.  If the FAB
!	has not been allocated, it is allocated.
!	Whenever the FAB, RAB, LUB, or ISB
!	are allocated they are initially set to 0. Thus, default values
!	are often indicated by zero in these structures.
!
! FORMAL PARAMETERS:
!
!	LUB_ADR.mlu.ra		Adr. of LUB/ISB/RAB control block
!	OPEN_ADR.mlu.ra		Adr. of OPEN parameter array of
!				longwords. Index is of form:
!				OPEN$K_name. A longword value of 0
!				indiates an omitted keyword.
!
! IMPLICIT INPUTS:
!
!	LUB$V_READ_ONLY		1 if 'READONLY' specified in CALL FDBSET
!	LUB$V_DIRECT		1 if specified on previous DEFINEFILE
!	LUB$V_OLD_FILE		1 if specified on previous CALL FDBSET
!	LUB$V_UNFORMAT		1 if specified on previous DEFINEFILE
!	LUB$W_LUN		FORTRAN logical unit number
!	LUB$W_RBUF_SIZE		Size in bytes of record buffer to be allocated
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_READ_ONLY		1 if 'READONLY' present or CALL FDBSET
!	LUB$V_DIRECT		1 if ACCESS = 'DIRECT' or DEFINEFILE
!	LUB$V_OLD_FILE		1 if TYPE = 'OLD' or CALL FDBSET 'OLD'
!	LUB$V_SCRATCH		1 if TYPE = 'SCRATCH'
!	LUB$V_PRINT		1 if DISPOSE = 'PRINT'
!	LUB$V_FIXED		1 if RECORDTYPE = 'FIXED'
!	LUB$V_FORMATTED		1 if FORM = 'FORMATTED' or ommitted
!	LUB$V_UNFORMAT		1 if FORM = 'UNFORMATTED'
!				or DEFINEFILE
!	LUB$A_ASSOC_VAR		adr. of n if ASSOCIATEVARIABLE = n is present
!				in OPEN or DEFINEFILE
!	LUB$V_ASS_VAR_L		1 if n is longword
!	LUB$W_IFI		RMS internal file id. Needed in case
!				FORTRAN CLOSE done.
!	LUB$W_RBUF_SIZE		Size in bytes of record buffer allocated.
!	LUB$L_LOG_RECNO		1
!	LUB$W_R_MARGIN		List directed output line width
!	LUB$B_ORGAN		Organization, either LUB$K_ORG_SEQUE
!				or LUB$K_ORG_RELAT.
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNAL_STOPs the following errors:
!	FOR$_FILNOTFOU	(29 = 'FILE NOT FOUND')
!	FOR$_OPEFAI	(30 = 'OPEN FAILURE')
!	FOR$_INCRECLEN	(37 = 'INCONSISTENT RECORD LENGTH')
!	FOR$_INSVIRMEM	(41 = 'INSUFFICIENT VIRTUAL MEMORY)
!	FOR$_NO_SUCDEV	(42 = 'NO SUCH DEVICE')
!	FOR$_FILNAMSPE	(43 = 'FILE NAME SPECIFICATION ERROR')
!	FOR$_RECSPEERR	(44 = 'RECORD SPECIFICATION ERROR')
!	FOR$_KEYVALERR	(45 = 'KEYWORD VALUE ERROR IN OPEN STATEMENT')
!	FOR$_INCOPECLO	(46 = 'INCONSISTENT OPEN/CLOSE ARGUMENTS')
!	FOR$_INVARGFOR	(47 = 'INVALID ARGUMENT TO FORTRAN I/O LIBRARY')
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF $FOR$CCB_DECL;

    MAP
	OPEN_ADR : REF VECTOR [OPEN$K_KEY_MAX + 1];

    LOCAL
	V_DEFAULT_SIZE,
	OPEN_STATUS,				! RMS status returned on $OPEN or $CREATE
	T_DFLT_FILE_NAM : VECTOR [10, BYTE],	! 10-byte  default filename string
						! Form: FORnnn.DAT
	ORIG_RAT: BYTE,				! Original FAB$B_RAT
	XAB_BLOCK : BLOCK [XAB$C_FHCLEN, BYTE],	! allocate local FHC XAB BLOCK
	KEY_XAB : REF BLOCK [OPEN$K_XAB_SIZE, BYTE],	! ISAM key XAB
	TEMP_FNS: VECTOR [NAM$C_MAXRSS, BYTE],	! Temp filespec for ASSIGN
	RES_OR_EXP_NAME : VECTOR [NAM$C_MAXRSS, BYTE];	! Storage for resultant or expanded name string

    BIND
	FAB = CCB: REF $FOR$FAB_CCB_STRUCT,	! FAB is after RAB in CCB
	NAM = CCB: REF $FOR$NAM_CCB_STRUCT,	! NAM is after FAB in CCB
	A_SYS$INPUT = UPLIT BYTE('SYS$INPUT:'),
	A_SYS$OUTPUT = UPLIT BYTE('SYS$OUTPUT:');

    BUILTIN
	TESTBITSC;

    LITERAL
	L_SYS$INPUT = %CHARCOUNT ('SYS$INPUT:'),
	L_SYS$OUTPUT = %CHARCOUNT ('SYS$OUTPUT:');

    !+
    ! See if ASSIGN or FDBSET has already allocated us a FAB.  If so,
    ! copy it to our local FAB and deallocate it.  Copy the filename too
    ! if it's there.
    !-

    IF .CCB [LUB$A_FAB] NEQA 0
    THEN
	BEGIN
	LOCAL
	    HEAP_FAB: REF BLOCK [, BYTE];
	HEAP_FAB = .CCB [LUB$A_FAB];
	CH$MOVE (.HEAP_FAB [FAB$B_BLN], .HEAP_FAB, FAB [0,0,0,0]);
	FOR$$FREE_VM (.HEAP_FAB [FAB$B_BLN], .HEAP_FAB);
	CCB [LUB$A_FAB] = 0;
	IF .FAB [FAB$B_FNS] NEQU 0
	THEN
	    BEGIN
	    CH$MOVE (.FAB [FAB$B_FNS], .FAB [FAB$L_FNA], TEMP_FNS);
	    FOR$$FREE_VM (.FAB [FAB$B_FNS], .FAB [FAB$L_FNA]);
	    FAB [FAB$L_FNA] = TEMP_FNS;
	    END;
	END;

    !+
    ! Initialize NAM and FHC XAB_BLOCK.
    !-

    FAB [FAB$L_NAM] = NAM [0,0,0,0];
    NAM [NAM$L_RSA] = NAM [NAM$L_ESA] = RES_OR_EXP_NAME;
    NAM [NAM$B_RSS] = NAM [NAM$B_ESS] = NAM$C_MAXRSS;
    $XABFHC_INIT (XAB = XAB_BLOCK);
    FAB [FAB$L_XAB] = XAB_BLOCK;
    KEY_XAB = XAB_BLOCK;	! First XAB in chain

    !+
    ! Set deferred write bit in the FAB for speed improvement in
    ! relative files.
    !-

    FAB [FAB$V_DFW] = 1;

!

    !+
    ! NAME
    ! Setup RMS default filename string (FAB$L_DNA, FAB$B_DNS) and
    ! file name string (FAB$L_FNA) depending on the type of statement
    ! that caused the LUN to be opened.
    !
    !	statement	file name string	default file name string
    !
    !	READ		FOR$READ:		FORREAD.DAT
    !	ACCEPT		FOR$ACCEPT:		FORACCEPT.DAT
    !	TYPE		FOR$TYPE:		FORTYPE.DAT
    !	PRINT		FOR$PRINT:		FORPRINT.DAT
    !	other		FORnnn:			FORnnn.DAT
    !
    ! Get the logical unit number from LUB$W_LUN instead of
    ! OPEN[OPEN$K_UNIT] since default open doesn't set up UNIT.
    ! LUN has been checked for being in legal range by CB_PUSH.
    ! Set the string length and address in the FAB.
    !-

    BEGIN

    LOCAL
	A_DEF_LOGNAM,				! Address of default logical name
	L_DEF_LOGNAM;				! Length of default logical name

    A_DEF_LOGNAM = 0;				! No default yet

    CASE .CCB [LUB$W_LUN] FROM LUB$K_DLUN_MIN TO LUB$K_DLUN_MAX OF
	SET

	[LUB$K_LUN_READ] : 			! READ statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORREAD.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORREAD.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$READ:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$READ:');
	    A_DEF_LOGNAM = A_SYS$INPUT;
	    L_DEF_LOGNAM = L_SYS$INPUT;
	    END;

	[LUB$K_LUN_ACCE] : 			! ACCEPT statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORACCEPT.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORACCEPT.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$ACCEPT:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$ACCEPT:');
	    A_DEF_LOGNAM = A_SYS$INPUT;
	    L_DEF_LOGNAM = L_SYS$INPUT;
	    END;

	[LUB$K_LUN_TYPE] : 			! TYPE statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORTYPE.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORTYPE.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$TYPE:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$TYPE:');
	    A_DEF_LOGNAM = A_SYS$OUTPUT;
	    L_DEF_LOGNAM = L_SYS$OUTPUT;
	    END;

	[LUB$K_LUN_PRIN] : 			! PRINT statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORPRINT.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORPRINT.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$PRINT:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$PRINT:');
	    A_DEF_LOGNAM = A_SYS$OUTPUT;
	    L_DEF_LOGNAM = L_SYS$OUTPUT;
	    END;

	[OUTRANGE] : 				! Some other statement (OPEN or default OPEN)
	    BEGIN
            IF .OPEN_ADR [OPEN$K_NAME] EQLA 0 OR
               .OPEN_ADR [OPEN$K_DEFAULTF] EQLA 0
            THEN
                BEGIN
                T_DFLT_FILE_NAM [0] = %C'F';
                T_DFLT_FILE_NAM [1] = %C'O';
                T_DFLT_FILE_NAM [2] = %C'R';
                T_DFLT_FILE_NAM [3] = ((.CCB [LUB$W_LUN]/100) MOD 10) + %C'0';
                T_DFLT_FILE_NAM [4] = ((.CCB [LUB$W_LUN]/10) MOD 10) + %C'0';
                T_DFLT_FILE_NAM [5] = ((.CCB [LUB$W_LUN]) MOD 10) + %C'0';
                T_DFLT_FILE_NAM [6] = %C'.';
                T_DFLT_FILE_NAM [7] = %C'D';
                T_DFLT_FILE_NAM [8] = %C'A';
                T_DFLT_FILE_NAM [9] = %C'T';
                END;

	    !+
	    ! DEFAULTFILE
	    ! Set up default file name string to be used in RMS $OPEN
	    !-

            IF .OPEN_ADR [OPEN$K_DEFAULTF] NEQA 0
            THEN
                BEGIN
                LOCAL
                    NAM_DSC : REF BLOCK [8, BYTE];
                NAM_DSC = .OPEN_ADR [OPEN$K_DEFAULTF];
                IF .NAM_DSC [DSC$W_LENGTH] GTRU 255 THEN $FOR$$SIGNAL_STO (FOR$K_FILNAMSPE);
                FAB [FAB$B_DNS] = .NAM_DSC [DSC$W_LENGTH];
                FAB [FAB$L_DNA] = .NAM_DSC [DSC$A_POINTER];
                END
            ELSE

	    !+
	    ! Default file name not specified in OPEN or this is default OPEN.
	    !-

                BEGIN
                FAB [FAB$B_DNS] = %CHARCOUNT ('FORnnn.DAT');
                FAB [FAB$L_DNA] = T_DFLT_FILE_NAM;
                END;

	    !+
	    ! FILE
	    ! Setup file name string to be used in RMS $OPEN
	    !-

	    IF .OPEN_ADR [OPEN$K_NAME] NEQA 0
	    THEN
		BEGIN

		!+
		! file name specified in OPEN
		! Set length and address in FAB
		!-

		LOCAL
		    NAM_DSC : REF BLOCK [8, BYTE];	! File name descriptor

		NAM_DSC = .OPEN_ADR [OPEN$K_NAME];	! Get descriptor

		IF .NAM_DSC [DSC$W_LENGTH] GTRU 255 THEN $FOR$$SIGNAL_STO (FOR$K_FILNAMSPE);

		FAB [FAB$B_FNS] = .NAM_DSC [DSC$W_LENGTH];
		FAB [FAB$L_FNA] = .NAM_DSC [DSC$A_POINTER];
		END
	    ELSE

	    !+
	    ! File name not specified in OPEN or this is default OPEN.

	    ! If name not already setup (CALL ASSIGN), use all but last 4 characters of default filename string,
	    ! i.e., all characters but .DAT
	    ! Thus filename string is a string with no punctuation so it can be a logical name
	    !-

		IF .FAB [FAB$L_FNA] EQLA 0
		THEN
		    BEGIN
		    FAB [FAB$B_FNS] = %CHARCOUNT ('FORnnn');
		    FAB [FAB$L_FNA] = T_DFLT_FILE_NAM;

		    !+
		    ! If this is unit 5 or 6, set up default logical
		    ! name to use if translation of FOR005 or FOR006
		    ! fails.
		    !-

		    IF .CCB [LUB$W_LUN] EQL 5
		    THEN
			BEGIN
			A_DEF_LOGNAM = A_SYS$INPUT;
			L_DEF_LOGNAM = L_SYS$INPUT;
			END
		    ELSE

			IF .CCB [LUB$W_LUN] EQL 6
			THEN
			    BEGIN
			    A_DEF_LOGNAM = A_SYS$OUTPUT;
			    L_DEF_LOGNAM = L_SYS$OUTPUT;
			    END;

		    END;

	    END;				! End OUTRANGE expression
	TES;

    !+
    ! If we have an implicit logical name assignment possible
    ! (unit<0 or unit=5 or unit=6) then attempt translation of
    ! the logical name.  If it fails, then substitute the default
    ! logical name SYS$INPUT: or SYS$OUTPUT: appropriately.
    !-

    IF .A_DEF_LOGNAM NEQ 0
    THEN
	BEGIN

	LOCAL
	    LOGNAM_DSC : DSC$DESCRIPTOR,	! Logical name descriptor
	    RESULT_DSC : DSC$DESCRIPTOR;	! Translation result descriptor

	LOGNAM_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
	LOGNAM_DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	RESULT_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
	RESULT_DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	RESULT_DSC [DSC$W_LENGTH] = NAM$C_MAXRSS;	! Scratch string
	RESULT_DSC [DSC$A_POINTER] = RES_OR_EXP_NAME;
	LOGNAM_DSC [DSC$A_POINTER] = .FAB [FAB$L_FNA];
	LOGNAM_DSC [DSC$W_LENGTH] = .FAB [FAB$B_FNS];

	IF .CCB [LUB$W_LUN] LSS 0
	THEN

	!+
	! Don't translate trailing colon.
	!-

	    LOGNAM_DSC [DSC$W_LENGTH] = .LOGNAM_DSC [DSC$W_LENGTH] - 1;

	!+
	! Attempt to translate the logical name, putting the result in
	! RES_OR_EXP_NAME.  We don't care what it translated to, just
	! the fact that it does translate.  If it does not, then substitute
	! the default logical name for the file name.
	!-

	IF $TRNLOG (LOGNAM = LOGNAM_DSC, RSLBUF = RESULT_DSC) EQLU SS$_NOTRAN
	THEN
	    BEGIN
	    FAB [FAB$L_FNA] = .A_DEF_LOGNAM;
	    FAB [FAB$B_FNS] = .L_DEF_LOGNAM;
	    END;

	END;

    END;

    !+
    ! Set the filename in the LUB in case an error occurs.
    !-

    CCB [LUB$A_RSN] = .FAB [FAB$L_FNA];
    CCB [LUB$B_RSL] = .FAB [FAB$B_FNS];
!<BLF/PAGE>

    !+
    ! Do a $PARSE on the file to see if the file is a network file.  If
    ! so, we will set FAB$V_SQO and not enable RFA cacheing.  Otherwise,
    ! we'll leave SQO clear so that RFA cacheing can be allowed.
    !-

    FAB [FAB$L_NAM] = 0;
    IF $PARSE (FAB = FAB [0,0,0,0])
    THEN
	BEGIN
	BIND
	    FAB_DEV = FAB [FAB$L_DEV]: BLOCK [4, BYTE];
	IF .FAB_DEV [DEV$V_NET]
	THEN
	    FAB [FAB$V_SQO] = 1;
	END;
    FAB [FAB$L_STS] = 0;	! Hide error, if any
    FAB [FAB$L_NAM] = NAM [0,0,0,0];

    !+
    ! READONLY
    ! Set functions which may be done subsequently (FAB$B_FAC).
    ! If not READONLY, permit GET, PUT, TRUNCATE (via TPT), UPDATE and DELETE.
    ! If READONLY, set LUB$V_READ_ONLY bit and use RMS default functions
    ! which can be done subsequently, namely just GETs.
    !-

    IF .OPEN_ADR [OPEN$K_READONLY]
    THEN
	BEGIN
	CCB [LUB$V_READ_ONLY] = 1;
	END
    ELSE

	IF (.FAB [FAB$B_FAC] EQLU 0)
	THEN
	    FAB [FAB$B_FAC] = FAB$M_GET + FAB$M_PUT + FAB$M_TRN + FAB$M_DEL + FAB$M_UPD;

    !+
    ! ACCESS
    !-

    !+
    ! If LUB$L_LOG_RECNO is zero, then this is not a default open of
    ! a direct access file, so set the record number to 1.  Otherwise,
    ! leave it alone because it has already been set by FOR$$IO_BEG.
    !-
    IF .CCB [LUB$L_LOG_RECNO] EQL 0
    THEN
	CCB [LUB$L_LOG_RECNO] = 1;

    FAB [FAB$V_NEF] = 1;			! inhibit EOF positioning on MT

    CASE .OPEN_ADR [OPEN$K_ACCESS] FROM 0 TO OPEN$K_ACC_KEY OF
	SET

	[OPEN$K_ACC_DIR] : 			! ACCESS = 'DIRECT'
	    BEGIN
	    CCB [LUB$V_DIRECT] = 1;
	    FAB [FAB$V_SQO] = 0;		! May have been set earlier
	    CCB [RAB$B_RAC] = RAB$C_KEY;
	    CCB [RAB$L_KBF] = CCB [LUB$L_LOG_RECNO];
	    CCB [RAB$B_KSZ] = 0;
	    CCB [RAB$V_UIF] = 1;		! Update on $PUT
	    END;

	[0, OPEN$K_ACC_SEQ] : 			! omitted or ACCESS = 'SEQUENTIAL'
	    BEGIN
	    CCB [LUB$V_SEQUENTIA] = 1;
	    CCB [RAB$B_RAC] = RAB$C_SEQ;
	    END;

	[OPEN$K_ACC_APP] : 			! ACCESS = 'APPEND'
	    BEGIN
	    IF .CCB [LUB$V_READ_ONLY]
	    THEN
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);
	    CCB [RAB$V_EOF] = 1;
	    CCB [LUB$V_APPEND] = 1;
	    FAB [FAB$V_NEF] = 0;		! don't inhibit EOF positioning on MT
	    CCB [RAB$B_RAC] = RAB$C_SEQ;
	    END;

	[OPEN$K_ACC_KEY] : 			! ACCESS = 'KEYED'
	    BEGIN
	    FAB [FAB$V_SQO] = 0;		! May have been set earlier
	    CCB [RAB$B_RAC] = RAB$C_KEY;
	    CCB [RAB$B_KRF] = 0;
	    CCB [LUB$V_KEYED] = 1;		! So we know later
	    END;

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! TYPE
    !-

    CASE .OPEN_ADR [OPEN$K_TYPE] FROM 0 TO OPEN$K_TYP_UNK OF
	SET

	[OPEN$K_TYP_OLD] : 			! TYPE = 'OLD'
	    CCB [LUB$V_OLD_FILE] = 1;

	[0, OPEN$K_TYP_NEW] : 			! omitted or TYPE = 'NEW'
	    BEGIN
	    IF NOT .CCB [LUB$V_OLD_FILE]	! Could have been set by FDBSET
	    THEN
		IF .CCB [LUB$V_READ_ONLY] OR 
		   .CCB [LUB$V_APPEND] 
		THEN 
		    $FOR$$SIGNAL_STO (FOR$K_INCOPECLO);
	    END;

	[OPEN$K_TYP_SCR] : 			! TYPE = 'SCRATCH'
	    BEGIN
	    CCB [LUB$V_SCRATCH] = 1;
	    FAB [FAB$V_TMD] = 1;
	    IF .CCB [LUB$V_READ_ONLY] OR 
	       .CCB [LUB$V_APPEND] 
	    THEN 
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);
	    END;

	[OPEN$K_TYP_UNK] : 			! TYPE = 'UNKNOWN'
	    BEGIN
	    FAB [FAB$V_CIF] = 1;
	    IF .CCB [LUB$V_READ_ONLY]
	    THEN 
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);
	    END;

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! DISPOSE
    !	Set bits in LUB to indicate DISPOSE parameters.  Do not allow
    !	deletion of READONLY or SCRATCH files, printing or submitting of
    !	SCRATCH files, or saving of SCRATCH files.       
    !-

    SELECT .OPEN_ADR [OPEN$K_DISPOSE] OF
	SET

	[0] :
	;					! ommitted, do nothing

	[OPEN$K_DIS_SAV] : 			! DISPOSE = 'SAVE'

	    IF .CCB [LUB$V_SCRATCH] THEN $FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	[OPEN$K_DIS_DEL, OPEN$K_DIS_PRDE, OPEN$K_DIS_SUDE] :
	    ! DISPOSE = 'DELETE', 'PRINT/DELETE', 'SUBMIT/DELETE'
	    BEGIN
	    IF .CCB [LUB$V_READ_ONLY] 
	    THEN 
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);
	    CCB [LUB$V_DELETE] = 1;
	    END;

	[OPEN$K_DIS_PRI, OPEN$K_DIS_PRDE] :
	    ! DISPOSE = 'PRINT', 'PRINT/DELETE'
	    BEGIN

	    IF .CCB [LUB$V_SCRATCH] THEN $FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    CCB [LUB$V_PRINT] = 1;
	    END;

	[OPEN$K_DIS_SUB, OPEN$K_DIS_SUDE] :
	    ! DISPOSE = 'SUBMIT', 'SUBMIT/DELETE'
	    BEGIN

	    IF .CCB [LUB$V_SCRATCH]
	    THEN
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO)
	    ELSE
		CCB [LUB$V_SUBMIT] = 1;

	    END;

	[OTHERWISE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! FORM
    !-

    CASE .OPEN_ADR [OPEN$K_FORM] FROM OPEN$K_FOR_UNS TO OPEN$K_FOR_UNF OF
	SET

	[OPEN$K_FOR_UNS] :
	;					! unspecified, used by default OPEN only

	[0] : 					! omitted

	    IF .CCB [LUB$V_DIRECT] OR .CCB [LUB$V_KEYED]
	    THEN
		CCB [LUB$V_UNFORMAT] = 1
	    ELSE
		CCB [LUB$V_FORMATTED] = 1;

	[OPEN$K_FOR_FOR] : 			! FORM = 'FORMATTED''
	    CCB [LUB$V_FORMATTED] = 1;

	[OPEN$K_FOR_UNF] : 			! FORM = 'UNFORMATTED'
	    CCB [LUB$V_UNFORMAT] = 1;

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! RECORDTYPE
    !-

    CASE .OPEN_ADR [OPEN$K_RECORDTY] FROM 0 TO OPEN$K_REC_STMLF OF
	SET

	[0] : 					! omitted

	    !+
	    ! Do nothing right now.  We have insufficient information
	    ! to determine the recordtype.  Wait until the organization
	    ! has been determined.
	    !-

	;

	[OPEN$K_REC_FIX] : 			! RECORDTYPE = 'FIXED'
	    BEGIN
	    CCB [LUB$V_FIXED] = 1;
	    FAB [FAB$B_RFM] = FAB$C_FIX;
	    END;

	[OPEN$K_REC_VAR] : 			! RECORDTYPE = 'VARIABLE'
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_VAR;
	    END;

	[OPEN$K_REC_SEGM] : 			! RECORDTYPE = 'SEGMENTED'
	    BEGIN

	    IF .CCB [LUB$V_DIRECT] OR .CCB [LUB$V_KEYED] OR .CCB [LUB$V_FORMATTED]
	    THEN
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_RFM] = FAB$C_VAR;
	    CCB [LUB$V_SEGMENTED] = 1;
	    END;

	[OPEN$K_REC_STM] :			! RECORDTYPE = 'STREAM'
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_STM;
	    END;

	[OPEN$K_REC_STMCR] :			! RECORDTYPE = 'STREAM_CR'
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_STMCR;
	    END;

	[OPEN$K_REC_STMLF] :			! RECORDTYPE = 'STREAM_LF'
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_STMLF;
	    END;

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! CARRIAGECONTROL
    !-

    CASE .OPEN_ADR [OPEN$K_CARRIAGE] FROM 0 TO OPEN$K_CAR_NON OF
	SET

	[0] : 					! omitted

	    IF .CCB [LUB$V_FORMATTED] THEN FAB [FAB$V_FTN] = 1;

	[OPEN$K_CAR_FOR] : 			! CARRIAGECONTROL = 'FORTRAN'
	    FAB [FAB$V_FTN] = 1;

	[OPEN$K_CAR_LIS] : 			! CARRIAGECONTROL = 'LIST'
	    FAB [FAB$V_CR] = 1;

	[OPEN$K_CAR_NON] :
	;					! CARRIAGECONTROL = 'NONE', do nothing

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

	!+
	! Store FAB$B_RAT so we can "restore" it if we find we've
	! opened a process-permanent file.
	!-

	ORIG_RAT = .FAB [FAB$B_RAT];

!<BLF/PAGE>

!

    !+
    ! ORGANIZATION
    !-

    CCB [LUB$V_NOTSEQORG] = 1;			! Assume not sequential organization

    CASE .OPEN_ADR [OPEN$K_ORGANIZA] FROM 0 TO OPEN$K_ORG_IDX OF
	SET

	[0, OPEN$K_ORG_SEQ] : 			! omitted or ORGANIZATION = ;SEQUENTIAL'
	    BEGIN

	    IF .CCB [LUB$V_DIRECT] AND .FAB [FAB$B_RFM] EQLU FAB$C_VAR THEN $FOR$$SIGNAL_STO (FOR$K_INCOPECLO)

	    ;

	    IF .CCB [LUB$V_KEYED] AND .OPEN_ADR [OPEN$K_ORGANIZA] NEQ 0
	    THEN
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_ORG] = FAB$C_SEQ;
	    CCB [LUB$V_NOTSEQORG] = 0;		! So ENDFILE will know its sequential
	    END;

	[OPEN$K_ORG_REL] : 			! ORGANIZATION = 'RELATIVE'
	    BEGIN

	    IF .CCB [LUB$V_SEGMENTED] OR .CCB [LUB$V_KEYED] THEN $FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_ORG] = FAB$C_REL;
	    END;

	[OPEN$K_ORG_IDX] : 			! ORGANIZATION = 'INDEXED'
	    BEGIN

	    IF .CCB [LUB$V_DIRECT] OR .CCB [LUB$V_APPEND] OR .CCB [LUB$V_SEGMENTED]
	    THEN
		$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_ORG] = FAB$C_IDX;
	    END;

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

    !+
    ! Verify that user didn't ask for a non-sequential stream file.
    !-

    IF .CCB [LUB$V_NOTSEQORG] AND 
       ONE_OF (.FAB [FAB$B_RFM], FAB$C_STM, FAB$C_STMCR, FAB$C_STMLF)
    THEN
	$FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

    !+
    ! RECORDTYPE continued
    ! We now have enough information to determine the initial recordtype
    ! if it was omitted.
    !-

    IF .OPEN_ADR [OPEN$K_RECORDTY] EQL 0
    THEN

	IF .FAB [FAB$B_ORG] EQL FAB$C_REL OR .FAB [FAB$B_ORG] EQL FAB$C_IDX OR .CCB [LUB$V_DIRECT] OR .CCB [
		LUB$V_KEYED]
	THEN
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_FIX;
	    CCB [LUB$V_FIXED] = 1;
	    END
	ELSE
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_VAR;

	    IF .CCB [LUB$V_UNFORMAT] THEN CCB [LUB$V_SEGMENTED] = 1;

	    END;

    !+
    ! SHARED
    ! If SHARED, indicate user provided record interlock (UPI) (for SEQUENTIAL ORG only)
    ! If not SHARED, RMS defaults is read, sharing only if READONLY, else no sharing.
    !-

    IF .OPEN_ADR [OPEN$K_SHARED]
    THEN
	BEGIN
	FAB [FAB$B_SHR] = FAB$M_SHRGET + FAB$M_SHRPUT + FAB$M_SHRUPD + FAB$M_SHRDEL;

	IF NOT .CCB [LUB$V_NOTSEQORG]		! Sequential only, set UPI
	THEN
	    FAB [FAB$V_UPI] = 1;

	END;

!<BLF/PAGE>

!

    !+
    ! KEY
    !-

    IF .OPEN_ADR [OPEN$K_KEY] NEQU 0
    THEN
	BEGIN

	LOCAL
	    KEY_DEFN : REF BLOCK [12, BYTE],	! Key definition
	    KEY_NUM,				! Number of current key
	    KEY_COUNT,				! Total number of keys defined
	    XAB_ADDR;				! Address of newly allocated KEY XAB

	IF .FAB [FAB$B_ORG] NEQU FAB$C_IDX THEN $FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	KEY_DEFN = .OPEN_ADR [OPEN$K_KEY];
	KEY_COUNT = .KEY_DEFN [OPEN$W_INFO];
	KEY_DEFN = .KEY_DEFN + %UPVAL;

	IF .KEY_COUNT MOD 3 NEQ 0 THEN $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);

	KEY_COUNT = .KEY_COUNT/3;

	!+
	! Loop through key definitions, and set up the key XABs.
	!-

	INCR KEY_NUM FROM 0 TO .KEY_COUNT - 1 DO
	    BEGIN
	    XAB_ADDR = FOR$$GET_VM (OPEN$K_XAB_SIZE);
	    KEY_XAB [XAB$L_NXT] = .XAB_ADDR;
	    KEY_XAB = .XAB_ADDR;

	    !+
	    ! Fill in KEY XAB fields
	    !-

	    CH$FILL (0, OPEN$K_XAB_SIZE, .KEY_XAB);
	    KEY_XAB [XAB$B_COD] = XAB$C_KEY;
	    KEY_XAB [XAB$B_BLN] = XAB$C_KEYLEN;

	    !+
	    ! Calculate key position and width
	    !-

	    IF .KEY_DEFN [OPEN$L_KEY_LO] LEQ 0 OR
	       .KEY_DEFN [OPEN$L_KEY_LO] GTR 32767 OR
	       .KEY_DEFN [OPEN$L_KEY_HI] GTR 32767 OR
	       .KEY_DEFN [OPEN$L_KEY_HI] LSS .KEY_DEFN [OPEN$L_KEY_LO]
	    THEN
		$FOR$$SIGNAL_STO (FOR$K_INVKEYSPE);

	    KEY_XAB [XAB$W_POS0] = .KEY_DEFN [OPEN$L_KEY_LO] - 1;
	    KEY_XAB [XAB$B_SIZ0] =
	    BEGIN

	    LOCAL
		SIZE;

	    SIZE = .KEY_DEFN [OPEN$L_KEY_HI] - .KEY_DEFN [OPEN$L_KEY_LO] + 1;

	    IF .SIZE GTR 255 THEN $FOR$$SIGNAL_STO (FOR$K_INVKEYSPE);

	    .SIZE
	    END;
	    KEY_XAB [OPEN$W_POS0] = .KEY_XAB [XAB$W_POS0];
	    KEY_XAB [OPEN$B_SIZ0] = .KEY_XAB [XAB$B_SIZ0];
	    KEY_XAB [XAB$B_DTP] = (SELECTONE .KEY_DEFN [OPEN$B_DTYPE] OF
		SET
		[0, DSC$K_DTYPE_T] : XAB$C_STG;
		[DSC$K_DTYPE_WU] : XAB$C_BN2;
		[DSC$K_DTYPE_W] : XAB$C_IN2;
		[DSC$K_DTYPE_LU] : IF .KEY_XAB [XAB$B_SIZ0] EQL 4 THEN XAB$C_BN4 ELSE XAB$C_BN2;
		[DSC$K_DTYPE_L] : IF .KEY_XAB [XAB$B_SIZ0] EQL 4 THEN XAB$C_IN4 ELSE XAB$C_IN2;
		[OTHERWISE] :
		    BEGIN
		    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
		    END;
		TES);
	    KEY_XAB [OPEN$B_KTYPE] = .KEY_XAB [XAB$B_DTP];

	    IF .KEY_NUM NEQ 0
	    THEN
		BEGIN
		KEY_XAB [XAB$V_CHG] = 1;
		KEY_XAB [XAB$V_DUP] = 1;
		END;

	    KEY_XAB [XAB$B_REF] = .KEY_NUM;
	    KEY_DEFN = .KEY_DEFN + (3*%UPVAL);	! Go to next definition
	    END;

	END;

    !+
    !  BLANK
    !     If user specifies BLANK='NULL' then set LUB$V_NULLBLNK
    !     else leave it alone.
    !-

    CASE .OPEN_ADR [OPEN$K_BLANK] FROM 0 TO OPEN$K_BLK_NUL OF
	SET

	[0, OPEN$K_BLK_ZER] :
	;					! Do nothing, ZERO is the default

	[OPEN$K_BLK_NUL] :
	    CCB [LUB$V_NULLBLNK] = 1;

	[OUTRANGE] :
	    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! RECORDSIZE
    !  Set maximum record size (FAB$W_MRS) if fixed, relative, or indexed.
    !  Set V_DEFAULT_SIZE if omitted.  Set LUB$W_RBUF_SIZE to record size.
    ! Default is 128 for unformatted fixed length, 2044 for unformatted
    ! variable length (4 bytes for RMS control info to make total 2048),
    ! and 133 for formatted (line printer width) or unspecified (ENDFILE
    ! default OPEN).
    !-

    V_DEFAULT_SIZE = 0;				! assume user specifies

    SELECTONEU .OPEN_ADR [OPEN$K_RECORDSI] OF
	SET

	[0] :

	    !+
	    !  If this is a fixed length or relative file, and
	    !  is not known to exist, RECORDSIZE must be given, else
	    !  error FOR$_INCRECLEN.
	    !-

	    IF .CCB [LUB$W_RBUF_SIZE] EQLU 0
	    THEN
		BEGIN

		IF NOT .CCB [LUB$V_OLD_FILE] AND (.CCB [LUB$V_FIXED]
		  OR .FAB [FAB$B_ORG] EQL FAB$C_REL)
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECLEN);

		CCB [LUB$W_RBUF_SIZE] = (
		    IF .CCB [LUB$V_UNFORMAT] 	! unformatted
		    THEN
			IF .CCB [LUB$V_FIXED]
			THEN
			    128			!    fixed
			ELSE
			    2044		!    variable
		    ELSE			! formatted or unspecified (ENDFILE default open)
			133);
		V_DEFAULT_SIZE = 1;		! user took the default
		END;

	[1 TO 32767] :
	    BEGIN

	    LOCAL
		T;

	    T = .OPEN_ADR [OPEN$K_RECORDSI]*(IF .CCB [LUB$V_UNFORMAT] THEN %UPVAL ELSE 1)	!
	    + (IF .CCB [LUB$V_SEGMENTED] THEN 2 ELSE 0);

	    IF .T GTRU 32767 THEN $FOR$$SIGNAL_STO (FOR$K_INCRECLEN);

	    CCB [LUB$W_RBUF_SIZE] = .T;
	    END;

	[OTHERWISE] :
	    $FOR$$SIGNAL_STO (FOR$K_INCRECLEN);
	TES;

    IF .CCB [LUB$V_FIXED]
      OR (.FAB [FAB$B_ORG] EQLU FAB$C_REL)
      OR (.FAB [FAB$B_ORG] EQLU FAB$C_IDX)
    THEN FAB [FAB$W_MRS] = .CCB [LUB$W_RBUF_SIZE];

!<BLF/PAGE>

!

    !+
    ! INITIALSIZE
    ! Only set if specified in explicit OPEN, since may be set by FDBSET on default OPEN.
    !-

    IF .OPEN_ADR [OPEN$K_INITIALS] NEQ 0
    THEN
	BEGIN
	FAB [FAB$L_ALQ] = ABS (.OPEN_ADR [OPEN$K_INITIALS]);
	FAB [FAB$V_CBT] = 1;
	END;

    !+
    ! EXTENDSIZE
    ! Only set if specified explicitly in explicit OPEN, since FDBSET could set on default open.
    !-

    IF .OPEN_ADR [OPEN$K_EXTENDSI] NEQU 0
    THEN

	IF ABS (.OPEN_ADR [OPEN$K_EXTENDSI]) LSSU 1^16
	THEN
	    FAB [FAB$W_DEQ] = ABS (.OPEN_ADR [OPEN$K_EXTENDSI])
	ELSE
	    $FOR$$SIGNAL_STO (FOR$K_KEYVALERR);

    !+
    ! NOSPANBLOCKS
    !-

    FAB [FAB$V_BLK] = .OPEN_ADR [OPEN$K_NOSPANBL];

    !+
    ! MAXREC
    ! Only set if explicitly passed by OPEN statement, since
    ! DEFINE FILE could have pre-set it if this is default open.
    !-

    IF .OPEN_ADR [OPEN$K_MAXREC] NEQU 0 THEN CCB [LUB$L_REC_MAX] = .OPEN_ADR [OPEN$K_MAXREC];

    FAB [FAB$L_MRN] = .CCB [LUB$L_REC_MAX];
!<BLF/PAGE>

!

    !+
    ! BLOCKSIZE
    ! Set BLOCKSIZE (used for magtape only), multi-block count (sequential org only)
    ! and bucket size (relative/indexed only).
    !-

    SELECTONEU .OPEN_ADR [OPEN$K_BLOCKSIZ] OF
	SET

	[0] :
	;					! Use process/system defaults

	[1 TO 65535] :
	    BEGIN
	    FAB [FAB$W_BLS] = .OPEN_ADR [OPEN$K_BLOCKSIZ];
	    CCB [RAB$B_MBC] = (.OPEN_ADR [OPEN$K_BLOCKSIZ] + 511)/512;
	    FAB [FAB$B_BKS] = .CCB [RAB$B_MBC];
	    IF .FAB [FAB$B_BKS] GTRU 63	! RMS limit
	    THEN
		FAB [FAB$B_BKS] = 63; 
	    END;

	[OTHERWISE] :
	    $FOR$$SIGNAL_STO (FOR$K_KEYVALERR);
	TES;

!<BLF/PAGE>

!

    !+
    ! BUFFERCOUNT
    ! Only set if explicitly passed by OPEN statement since FDBSET could
    ! have pre-set it if this is a default open.
    !-

    SELECTONEU .OPEN_ADR [OPEN$K_BUFFERCO] OF
	SET

	[0] :
	;

	[1 TO 127] :
	    CCB [RAB$B_MBF] = .OPEN_ADR [OPEN$K_BUFFERCO];

	[OTHERWISE] :
	    $FOR$$SIGNAL_STO (FOR$K_KEYVALERR);
	TES;

    !+
    ! ASSOCIATEVARIABLE
    !-

    IF .OPEN_ADR [OPEN$K_ASSOCIAT] NEQA 0
    THEN
	BEGIN
	CCB [LUB$A_ASSOC_VAR] = .OPEN_ADR [OPEN$K_ASSOCIAT];

	IF .OPEN_ADR [OPEN$K_ASSOC_L] THEN CCB [LUB$V_ASS_VAR_L] = 1

	END;


!

    !+
    ! USEROPEN
    !
    ! If a USEROPEN procedure address was specified then call the procedure
    ! to do the $OPEN and $CONNECT; it will return an RMS status code as
    ! procedure value.  Otherwise do the $OPEN and $CONNECT ourselves.
    ! Set useropen flag, just as a debugging aid in case we get a dump with an SPR.
    !-

    IF .OPEN_ADR [OPEN$K_USEROPEN] NEQA 0
    THEN
	BEGIN

	LOCAL
	    LOG_UNIT;				! Logical unit number

	LOG_UNIT = .CCB [LUB$W_LUN];		! Get the unit number
	CCB [LUB$V_USEROPEN] = 1;		! so we know the user opened the file!
	OPEN_STATUS = (.OPEN_ADR [OPEN$K_USEROPEN]) (FAB [0,0,0,0], 
	    .CCB, LOG_UNIT);
	END
    ELSE
	BEGIN					! not USEROPEN

	!+
	! If old file is explicitly wanted, do an $OPEN. Otherwise
	! (NEW, SCRATCH, UNKNOWN, default = NEW) do a $CREATE.
	! UNKNOWN has set RMS FAB$V_CIF to do an OPEN if file
	! exists rather than a $CREATE.  If file already existed
	! on $CREATE (TYPE='UNKNOWN'), set LUB$V_OLD_FILE
	! as flag that file already existed for error checking below.
	!-

	OPEN_STATUS = (
	    IF .CCB [LUB$V_OLD_FILE] 
	    THEN 
		$OPEN (FAB = FAB [0,0,0,0]) 
	    ELSE 
		$CREATE (FAB = FAB [0,0,0,0]));

	!+
	! If no error in open/create, do $CONNECT (pointer to FAB already set in RAB).
	!-

	IF .OPEN_STATUS	THEN OPEN_STATUS = $CONNECT (RAB = .CCB);

	END;

!<BLF/PAGE>

!

    !+
    ! Zero the XAB pointer in the FAB so we don't accidentally use it later.
    !-

    FAB [FAB$L_XAB] = 0;

    !+
    ! TYPE = 'UNKNOWN' has set RMS FAB$V_CIF to do an open if file exitsts
    ! rather than a create.  If file already existed on $CREATE (TYPE='UNKNOWN'),
    ! set LUB$V_OLD_FILE as flag that file already existed for error checking below.
    !-

    IF .FAB [FAB$V_CIF] AND .FAB [FAB$L_STS] NEQU RMS$_CREATED THEN CCB [LUB$V_OLD_FILE] = 1;

    !+
    ! If CALL ASSIGN allocated space for the filename, deallocate it.
    !-

    IF TESTBITSC (CCB [LUB$V_VIRT_RSN])
    THEN
	FOR$$FREE_VM (.CCB [LUB$B_RSL], .CCB [LUB$A_RSN]);

    !+
    ! If we have an expanded name string (or even better, a resultant name string),
    ! point the LUB to it instead of the user supplied name.  This will be
    ! the file name used for error messages from now on.
    !-

    IF .NAM [NAM$B_RSL] NEQ 0
    THEN
	BEGIN
	CCB [LUB$A_RSN] = .NAM [NAM$L_RSA];
	CCB [LUB$B_RSL] = .NAM [NAM$B_RSL];
	END
    ELSE

	IF .NAM [NAM$B_ESL] NEQ 0
	THEN
	    BEGIN
	    CCB [LUB$A_RSN] = .NAM [NAM$L_ESA];
	    CCB [LUB$B_RSL] = .NAM [NAM$B_ESL];
	    END;


!<BLF/PAGE>

!

    !+
    ! If OPEN or CREATE error, SIGNAL_STOP one of:
    ! FOR$_FILNOTFOU (29='FILE NOT FOUND') or
    ! FOR$_OPEFAI (30='OPEN FAILURE')
    ! FOR$_INCRECLEN (37='INCONSISTENT RECORD LENGTH')
    ! FOR$_NO_SUCDEV (42='NO SUCH DEVICE')
    ! FOR$_FILNAMSPE (43='FILE NAME SPECIFICATION ERROR)
    ! FOR$_INVKEYSPE (49='INVALID KEY SPECIFICATION')
    ! Note: OPEN_STATUS can be anything for USEROPEN, so use status in FAB.
    !-

    IF NOT .OPEN_STATUS
    THEN
	$FOR$$SIGNAL_STO (

	    (SELECTONEU .FAB [FAB$L_STS] OF
		SET

		[RMS$_FNF] :
		    FOR$K_FILNOTFOU;		! FILE NOT FOUND

		[RMS$_DEV] :
		    FOR$K_NO_SUCDEV;		! NO SUCH DEVICE

		[RMS$_FNM, RMS$_NOD, RMS$_TYP, RMS$_VER, RMS$_SYN] :
		    FOR$K_FILNAMSPE;		! FILE NAME SPECIFICATION ERROR

		[RMS$_POS, RMS$_SIZ, RMS$_NPK] :
		    FOR$K_INVKEYSPE;		! INVALID KEY SPECIFICATION

		[RMS$_CRE]:

		    !+
		    ! Check for the special case of a mag tape file with
		    ! blocksize less than recordsize (+ 4 if variable).
		    ! If so, signal INCRECLEN, since RMS does not give a
		    ! useful message in this case; otherwise OPEFAI.
		    !-

		    BEGIN
		    LOCAL
			OLD_STS,	! Previous FAB$L_STS
			OLD_STV;	! Previous STV
		    OLD_STS = .FAB [FAB$L_STS];
		    OLD_STV = .FAB [FAB$L_STV];
		    IF $PARSE (FAB = FAB [0,0,0,0])	! Get device characteristics
		    
		    THEN
			BEGIN
			FAB [FAB$L_STS] = .OLD_STS;
			FAB [FAB$L_STV] = .OLD_STV;
			IF .BLOCK [FAB [FAB$L_DEV], DEV$V_SQD; 1, LONG] AND .FAB [FAB$W_BLS] NEQ 0
						! If mag tape,
			THEN
			    IF .FAB [FAB$W_BLS] LSSU .CCB [LUB$W_RBUF_SIZE]
				+ (IF NOT .CCB [LUB$V_FIXED] THEN 4 ELSE 0)
			    THEN
				FOR$K_INCRECLEN	! INCONSISTENT RECORD LENGTH
			    ELSE
				FOR$K_OPEFAI	! OPEN FAILURE
			ELSE
			    FOR$K_OPEFAI
			END
		    ELSE
			FOR$K_OPEFAI
		    END;

		[OTHERWISE]:
		    FOR$K_OPEFAI;

		TES));

!<BLF/PAGE>

!

    !+
    ! If the file we just opened was an existing file, perform a couple of
    ! consistency checks.
    !-

    IF .CCB [LUB$V_OLD_FILE]
    THEN
	BEGIN

	!+
	! Organization check:
	! If user program did not specify organization with this OPEN,
	! use the attributes from the file.  If the user program did specify,
	! check that it agrees with the file.
	!-

	IF .OPEN_ADR [OPEN$K_ORGANIZA] NEQ 0
	THEN
	    BEGIN

	    LOCAL
		T;

	    T = (CASE .OPEN_ADR [OPEN$K_ORGANIZA] FROM OPEN$K_ORG_SEQ TO OPEN$K_ORG_IDX OF
		SET
		[OPEN$K_ORG_SEQ] : FAB$C_SEQ;
		[OPEN$K_ORG_REL] : FAB$C_REL;
		[OPEN$K_ORG_IDX] : FAB$C_IDX;
		[OUTRANGE] :
		    BEGIN
		    $FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
		    END;
		TES);

	    IF .T NEQ .FAB [FAB$B_ORG] THEN $FOR$$SIGNAL_STO (FOR$K_INCFILORG);

	    END;

	!+
	! If ACCESS='KEYED' was specified and the file is not indexed,
	! signal an error.
	!-

	IF (.CCB [LUB$V_KEYED] AND .FAB [FAB$B_ORG] NEQ FAB$C_IDX) OR (.CCB [LUB$V_DIRECT] AND .FAB [
		FAB$B_ORG] EQL FAB$C_IDX)
	THEN
	    $FOR$$SIGNAL_STO (FOR$K_INCFILORG);

!+
! If the file does not have sequential organization, then set LUB bit.
!-

	IF (.FAB [FAB$B_ORG] NEQ FAB$C_SEQ) THEN CCB [LUB$V_NOTSEQORG] = 1;

!<BLF/PAGE>

!

	!+
	! Record type check:
	! If user-program did not specified record-type in this OPEN,
	! use the file attributes. If user-program did specify
	! this OPEN, check that it agrees with the file.
	!-

	CASE .OPEN_ADR [OPEN$K_RECORDTY] FROM 0 TO OPEN$K_REC_STMLF OF
	    SET

	    [0] : 				! User did not specify
		BEGIN
		CCB [LUB$V_FIXED] = 0;		! Clear previously set bits
		CCB [LUB$V_SEGMENTED] = 0;

		IF .FAB [FAB$B_RFM] EQL FAB$C_FIX
		THEN
		    CCB [LUB$V_FIXED] = 1	! Fixed
		ELSE
		    BEGIN			! Variable
		    IF .CCB [LUB$V_DIRECT] AND NOT .CCB [LUB$V_NOTSEQORG]
		    THEN
			$FOR$$SIGNAL_STO (FOR$K_INCRECTYP);
		    IF NOT .CCB [LUB$V_NOTSEQORG] AND .CCB [LUB$V_UNFORMAT] AND
			NOT .CCB [LUB$V_DIRECT] AND (.FAB [FAB$B_RFM] EQL FAB$C_VAR)
		    THEN
			CCB [LUB$V_SEGMENTED] = 1;
		    END;
		END;

	    [OPEN$K_REC_FIX] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_FIX THEN $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_VAR] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_VAR AND .FAB [FAB$B_RFM] NEQU FAB$C_VFC
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_SEGM] :

		IF (.FAB [FAB$B_RFM] NEQU FAB$C_VAR) OR .CCB [LUB$V_NOTSEQORG]
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_STM] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_STM
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_STMCR] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_STMCR
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_STMLF] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_STMLF
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OUTRANGE] :
		$FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	    TES;

	!+
	! Set maximum record number from file.
	!-

	IF .CCB [LUB$L_REC_MAX] EQL 0
	THEN
	    CCB [LUB$L_REC_MAX] = .FAB [FAB$L_MRN]
	ELSE

	    IF .FAB [FAB$L_MRN] NEQ 0 THEN CCB [LUB$L_REC_MAX] = MIN (.CCB [LUB$L_REC_MAX], .FAB [FAB$L_MRN])

	;
!<BLF/PAGE>

!

	!+
	! Record size check:
	!	If user specified a record size (with DEFINE FILE or RECORDSIZE
	!	OPEN keyword, and MRS was required by RMS (fixed or relative),
	!	or organization indexed and MRS is non-zero, then they must agree.
	!	The recordsize the OTS will use is then computed in a reasonable
	!	manner.
	!-

	!+
	! If not a disk or terminal, use the blocksize as the maximum recordsize
	! (if not there already).
	!-
	IF (NOT .BLOCK [FAB [FAB$L_DEV], DEV$V_RND;4, BYTE]) AND
	   (NOT .BLOCK [FAB [FAB$L_DEV], DEV$V_TRM;4, BYTE])
	THEN
	    IF .FAB [FAB$W_MRS] EQL 0
	    THEN
		FAB [FAB$W_MRS] = .FAB [FAB$W_BLS];

	IF NOT .V_DEFAULT_SIZE AND (.CCB [LUB$V_FIXED]
	  OR .FAB [FAB$B_ORG] EQL FAB$C_REL)
	THEN

	    IF .CCB [LUB$W_RBUF_SIZE] NEQU .FAB [FAB$W_MRS] THEN $FOR$$SIGNAL_STO (FOR$K_INCRECLEN);

	IF (.CCB [LUB$V_FIXED]
	  OR .FAB [FAB$B_ORG] EQL FAB$C_REL)
	THEN
	    CCB [LUB$W_RBUF_SIZE] = .FAB [FAB$W_MRS]
	ELSE
	    CCB [LUB$W_RBUF_SIZE] = MAXU (.CCB [LUB$W_RBUF_SIZE], .FAB [FAB$W_MRS], .XAB_BLOCK [XAB$W_LRL]);

	IF (.FAB [FAB$B_ORG] EQLU FAB$C_IDX) AND (NOT .CCB [LUB$V_FIXED])
	THEN
!+
! For variable indexed files, determine if the MRS is zero.  If it is, this is an ISAM file
! created prior to FORTRAN V3 and should not be checked for buffer size agreement.
! If no explicit RECL was specified, use the bucketsize to compute the buffersize.
!-
	    IF .FAB [FAB$W_MRS] EQLU 0
	    THEN
		BEGIN
		IF .V_DEFAULT_SIZE
		THEN
		    CCB [LUB$W_RBUF_SIZE] = .FAB [FAB$B_BKS] * 512;
		END
	    ELSE
!+
! This is a new ISAM file.  Check to be sure that the buffer size requested does
! not exceed the Max Recordsize specified when the file was created.  Set the
! buffer size to the MRS to allow the records to grow.
!-
		IF NOT .V_DEFAULT_SIZE AND 
		       (.CCB [LUB$W_RBUF_SIZE] GTRU .FAB [FAB$W_MRS])
		THEN
		    $FOR$$SIGNAL_STO (FOR$K_INCRECLEN)
		ELSE
		    CCB [LUB$W_RBUF_SIZE] = .FAB [FAB$W_MRS];
	!+
	! Key definition check.  If file is ORGANIZATION='INDEXED' and
	! user specified a KEY definition, make sure it agrees with
	! what the file actually has.  Key sizes must match, and key
	! datatypes must
	! match.  If not, signal error FOR$_INVKEYSPE.
	! Make sure that we don't interfere with key XAB's that a
	! USEROPEN might have defined.
	!-

	IF .FAB [FAB$B_ORG] EQL FAB$C_IDX
	THEN
	    BEGIN	! Indexed file

	    LOCAL
		XAB_STATUS,		! Status while freeing XABs
		KEY_COUNT;		! Count of OPEN defined keys

	    BEGIN

	    LOCAL
		KEY_DEFN : REF BLOCK [12, BYTE];

	    KEY_DEFN = .OPEN_ADR [OPEN$K_KEY];

	    IF .KEY_DEFN NEQ 0 THEN KEY_COUNT = .KEY_DEFN [OPEN$W_INFO] ELSE KEY_COUNT = 0;

	    END;

	    XAB_STATUS=SS$_NORMAL;
	    KEY_XAB = .XAB_BLOCK [XAB$L_NXT];

	    WHILE .KEY_XAB NEQU 0 AND .KEY_COUNT GTR 0 DO
		BEGIN	! Go through XABs

		IF (.KEY_XAB [XAB$B_COD] EQL XAB$C_KEY)
		THEN
		    BEGIN

		    IF (.KEY_XAB [XAB$W_POS0] NEQ .KEY_XAB [OPEN$W_POS0]) OR (.KEY_XAB [XAB$B_SIZ0] NEQ
			.KEY_XAB [OPEN$B_SIZ0])
		    THEN
			XAB_STATUS = FOR$K_INVKEYSPE;

		    IF .KEY_XAB [OPEN$B_KTYPE] NEQ .KEY_XAB [XAB$B_DTP]
		    THEN
			XAB_STATUS = FOR$K_INVKEYSPE;

		    BEGIN

		    LOCAL
			NEXT;			! Address of next XAB in link

		    NEXT = .KEY_XAB [XAB$L_NXT];
		    FOR$$FREE_VM (OPEN$K_XAB_SIZE, .KEY_XAB);
		    KEY_XAB = .NEXT;
		    END;
		    KEY_COUNT = .KEY_COUNT - 3;
		    END;

		END;	! Go through XABs

	    !+
	    ! If we had discovered any error while freeing the XAB's
	    ! we report it now.  If we had reported it when we found it,
	    ! we would have been left with some XABs laying around
	    ! whose memory had not been deallocated.
	    !-

	    IF NOT .XAB_STATUS
	    THEN
		$FOR$$SIGNAL_STO (.XAB_STATUS);

	    END;	! Indexed file

	END					! End of old file processing
    ELSE
!<BLF/PAGE>

!

    !+
    ! Else (file was created)
    !	Make sure V_APPEND is off so BACKSPACE will work.
    !-

	BEGIN
	CCB [LUB$V_APPEND] = 0;
	END;

    !+
    ! If this is not a disk or terminal, and if RECL was not specified,
    ! then reduce the default recordsize to fit within the blocksize.
    !-

    IF .V_DEFAULT_SIZE
    THEN
	IF (NOT .BLOCK [FAB [FAB$L_DEV], DEV$V_RND;4, BYTE]) AND
	   (NOT .BLOCK [FAB [FAB$L_DEV], DEV$V_TRM;4, BYTE]) AND
	   (.FAB [FAB$W_BLS] NEQ 0)
	THEN
	    BEGIN
	    LOCAL
		NEW_RECL: WORD;
	    NEW_RECL = .FAB [FAB$W_BLS];
	    IF .CCB [LUB$V_SEGMENTED]
	    THEN
		NEW_RECL = .NEW_RECL - 4;	! Compensate for length
	    IF .NEW_RECL LSSU .CCB [LUB$W_RBUF_SIZE]
	    THEN
		CCB [LUB$W_RBUF_SIZE] = .NEW_RECL;
	    END;

    !+
    ! If this is a process-permanent file, ignore the carriage-control
    ! attributes RMS returned in the FAB and use the ones we set
    ! originally.  RMS will properly convert our writes anyway.
    !-

    IF .NAM [NAM$V_PPF]
    THEN
	FAB [FAB$B_RAT] = .ORIG_RAT;

    !+
    ! Set up the list-directed output record size as RECL, if specified,
    ! else 81 (80 if not FORTRAN carriage control).
    !-

    CCB [LUB$W_R_MARGIN] = (IF NOT .V_DEFAULT_SIZE THEN .CCB [LUB$W_RBUF_SIZE] ELSE
	(IF .FAB [FAB$V_FTN] THEN 81 ELSE 80));

    !+
    ! Set bits in the LUB to indicate the file's carriage control
    ! characteristics.  This information is used by INQUIRE.
    !-

    IF .FAB [FAB$V_FTN]
    THEN
	CCB [LUB$V_FTN] = 1;
    IF .FAB [FAB$V_CR]
    THEN
	CCB [LUB$V_CR] = 1;
    IF .FAB [FAB$V_PRN]
    THEN
	CCB [LUB$V_PRN] = 1;

    !+
    ! Allocate record buffer dynamically from LUB$W_RBUF_SIZE setting in bytes.
    ! Set LUB$A_RBUF_ADR to address of buffer allocated.
    !-

    CCB [LUB$A_RBUF_ADR] = FOR$$GET_VM (.CCB [LUB$W_RBUF_SIZE]);

    !+
    ! Allocate dynamic storage for the file name so the name can be
    ! used later on for error diagnostics.  Point the LUB to the new
    ! location.  (The size is already correct!)
    ! Indicate that the string name is now stored in virtual memory so
    ! it will be deallocated!
    !-

    BEGIN

    LOCAL
	T;

    T = FOR$$GET_VM (.CCB [LUB$B_RSL]);
    CH$MOVE (.CCB [LUB$B_RSL], .CCB [LUB$A_RSN], .T);
    CCB [LUB$A_RSN] = .T;
    NAM [NAM$L_RSA] = .T;
    NAM [NAM$L_ESA] = .T;
    NAM [NAM$B_ESL] = .CCB [LUB$B_RSL];
    CCB [LUB$V_VIRT_RSN] = 1;
    END;

    !+
    ! Store a code in the LUB indicating the type of organization.
    !-

    SELECTONE (.FAB [FAB$B_ORG]) OF
	SET

	[FAB$C_SEQ] :
	    CCB [LUB$B_ORGAN] = LUB$K_ORG_SEQUE;

	[FAB$C_REL] :
	    CCB [LUB$B_ORGAN] = LUB$K_ORG_RELAT;

	[FAB$C_IDX] :
	    BEGIN

	    IF .CCB [LUB$V_SEGMENTED] THEN $FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    CCB [LUB$B_ORGAN] = LUB$K_ORG_INDEX;
	    END;

	[OTHERWISE] :
	    $FOR$$SIGNAL_STO (FOR$K_INCFILORG);
	TES;

    !+
    ! Set RAB fields that seldom change: UBF and USZ
    !-

    CCB [RAB$L_UBF] = .CCB [LUB$A_RBUF_ADR];
    CCB [RAB$W_USZ] = .CCB [LUB$W_RBUF_SIZE];
    CCB [LUB$A_UBF] = .CCB [LUB$A_RBUF_ADR];

    !+
    ! If the file is a sequential organization, sequential access,
    ! disk file which is not a PPF, enable RFA cacheing for BACKSPACE.
    !-

    IF NOT .CCB [LUB$V_NOTSEQORG] AND
       NOT .CCB [LUB$V_DIRECT] AND
       NOT .CCB [LUB$V_FIXED] AND
       NOT .NAM [NAM$V_PPF] AND
       NOT .FAB [FAB$V_SQO]
    THEN
	BEGIN
	BIND
	    FAB_DEV = FAB [FAB$L_DEV]: BLOCK [4, BYTE];
	IF .FAB_DEV [DEV$V_RND]	! Random-access device?
	THEN
	    BEGIN
	    LOCAL
		RCE: REF RCE_R_RCE_STRUCT,
		OLD_RCE: REF RCE_R_RCE_STRUCT;

	    !+
	    ! Allocate space for the RFA cache entries.
	    !-

	    RCE = FOR$$GET_VM (
		(RCE_K_CACHE_SIZE * RCE_S_RCE_STRUCT));

	    !+
	    ! Create a circularly linked list of entries and zero the
	    ! LOG_RECNO field of each entry.
	    !-

	    CCB [LUB$A_RFA_CACHE_BEG] = .RCE;	! First allocated byte
	    CCB [LUB$A_RFA_CACHE_PTR] = .RCE;	! Current entry
	    OLD_RCE = .RCE + (RCE_K_CACHE_SIZE - 1) * RCE_S_RCE_STRUCT;
	    DECRU I FROM RCE_K_CACHE_SIZE TO 1 DO
		BEGIN
		OLD_RCE [RCE_A_NEXT] = .RCE;
		RCE [RCE_A_PREV] = .OLD_RCE;
		RCE [RCE_L_LOG_RECNO] = 0;
		OLD_RCE = .RCE;
		RCE = .RCE + RCE_S_RCE_STRUCT;
		END;

	    CCB [LUB$V_RFA_CACHE_ENABLE] = 1;
	    END;
	END;

!+
! Indicate that the file is now FORTRAN opened.
!-
    CCB [LUB$B_LANGUAGE] = LUB$K_LANG_FOR;
    CCB [LUB$V_OPENED] = 1;
!+
! Make sure that the FORTRAN exit handler will be called when the image
! exits to purge the file's I/O buffers and close it, if necessary.
!-

    IF ( NOT .FOR$$L_XIT_LOCK) THEN FOR$$DECL_EXITH ();

    RETURN;					! Return from OPEN_PROC routine
    END;					! End of OPEN_PROC routine

END						! End of FOR$$OPEN_DEFLT module

ELUDOM
