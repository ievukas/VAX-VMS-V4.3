$ ! 'F$VERIFY(0)
$ !
$ !	This command procedure may be entered in one of two ways:
$ !
$ !		1) Invoked from STARTUP.UP2
$ !		2) As the startup procedure during reboot
$ !
$ !	In order to eliminate error messages incurred by re-executing
$ !	the initialization parts of the startup procedure, STARTUP.UP2
$ !	specifies an input parameter, while the reboot does not.
$ !
$ !		P1 - "CONTINUE", a label in this command procedure
$ !		     where the upgrade should continue if coming
$ !		     directly from STARTUP.UP2 without a reboot
$ !
$ SET NOON
$	SAY = "WRITE SYS$OUTPUT"
$	SAY ""
$	SAY "Continuing with VAX/VMS V4.0 Upgrade Procedure."
$	SAY ""
$	SAY "	Upgrade Phase 3			''F$TIME()'"
$	SAY ""
$	VERSION = "040"
$	T1 = F$SETPRV("CMKRNL,SYSPRV,LOG_IO,VOLPRO,BYPASS")
$	SET PROTECTION=(S:RWED,G:RWED,O:RWED,W:RE)/DEFAULT
$	SET DEFAULT SYS$SYSTEM
$	SET UIC [1,4]
$	SET MESSAGE /FACILITY/SEVERITY/TEXT/IDENTIFICATION
$	SET ON
$	ON ERROR THEN GOTO 7000
$	ON CONTROL_Y THEN GOTO 7000
$	SET NOON
$ P1:="''P1'"	! Make sure P1 is defined
$ IF P1 .NES. "" THEN GOTO 'P1
$ @SYS$SYSTEM:STARTUP UPGRADE
$ !
$ ! Install only those protected shareable images that will be used.
$ !
$ RUN SYS$SYSTEM:INSTALL
SYS$SHARE:DISMNTSHR	/OPEN /SHARED /PROTECT /HEADER /NOPURGE
SYS$SHARE:MOUNTSHR	/OPEN /SHARED /PROTECT /HEADER
SYS$SHARE:SECURESHR	/OPEN /SHARED /PROTECT /HEADER
$	DEFDIR = "SYSUPD.VMS''VERSION'"
$	SET CONTROL=T
$	SET ON
$ !
$ ! Determine old and new top-level system directories.
$ !
$	OPEN /READ DATAF UPGRADE.KIT
$	READ DATAF OLD_ROOT_DOT	!Kit device...ignore
$	READ DATAF OLD_ROOT_DOT
$	READ DATAF NEW_ROOT
$	READ DATAF YEAR
$	READ DATAF UPGRADE_FROM
$	READ DATAF L
$	T1 = F$LENGTH(L)
$	KIT_RL02 = F$LOC("A",L) .NE. T1
$	KIT_RC25 = F$LOC("B",L) .NE. T1
$	KIT_DOTLR = F$LOC("C",L) .NE. T1
$	KIT_ISTLR = F$LOC("D",L) .NE. T1
$	KIT_DOCROOT = F$LOC("E",L) .NE. T1
$	KIT_CROOT = F$LOC("F",L) .NE. T1
$	READ DATAF SYSVER
$	READ DATAF LIB_DISK
$	CLOSE DATAF
$	OLD_ROOT = OLD_ROOT_DOT - "."
$	DOT_OLD_ROOT = "." + OLD_ROOT
$	CLROOT = OLD_ROOT_DOT
$	IF KIT_CROOT THEN CLROOT = "V4COMMON."
$	TARGET = F$TRNLNM("SYS$SYSDEVICE")
$	TARGET_TOPSYS_DOT = NEW_ROOT + "."
$ !
$ ! Determine type of cpu
$ !
$	CPUTYPE = F$GETSYI("CPU")
$	IF (CPUTYPE .GT. 0) .AND. (CPUTYPE .LE. 3) THEN GOTO GOT_CPUTYPE
$	SAY "Invalid cpu type ''CPUTYPE'."
$	GOTO 7000
$GOT_CPUTYPE:
$	SET DEFAULT 'TARGET'['OLD_ROOT_DOT''DEFDIR']
$	ON ERROR THEN GOTO 7000
$	SAY ""
$	SET NOON
$ !	@DIRCLENUP 'TARGET' 1
$	STOP JOB_CONTROL
$	STOP OPCOM
$	STOP ERRFMT
$	SET DEFAULT 'TARGET'['CLROOT''DEFDIR']
$	SET ON
$CONTINUE:
$	VALID_SAVESETS = "REQ,LIB,OPT,ALL"
$	VALID_UPGRADES = "IGNORE,KEEP,OVER,UNDER"
$ !
$ ! Now make another pass through the VMSKITBLD data file,
$ ! to merge in those VMS files not deleted by the upgrade.
$ !
$	SAY ""
$	SAY "Now merging VMS-distributed files that are commonly editted"
$	SAY "by system managers with new VMS files."
$	SEARCH /OUTPUT='TARGET'['CLROOT''DEFDIR']VMSUNDER.DAT -
		'TARGET'['CLROOT''DEFDIR']VMSKITBLD.V3N UPG=UNDER,UPG=OVER,OP=SET
$	FILENAME:='TARGET'['CLROOT''DEFDIR']VMSUNDER.DAT
$60:
$	OPEN/READ DATAF 'FILENAME
$	IF $STATUS THEN GOTO 65
$	SAY "Unable to open data parameter file",FILENAME,"."
$	GOTO 7000
$65:
$	CONDIT = 1+8+64+256	! Use UETP, HELP, DECnet, and Coding Examples
$	ON ERROR THEN GOTO 7000
$	SET DEFAULT 'TARGET'['CLROOT''DEFDIR']
$ !
$ ! This loop is executed to move all V3 files that may have been
$ ! editted by the customer into the SYSF tree.  Some files must be
$ ! placed UNDER the existing versions in the SYSF tree, while others
$ ! must be placed OVER the existing versions.
$ !
$	PREV_NAME = ""
$	OVER_UNDER = "OVER,UNDER,"
$RECORD_LOOP2:
$	READ/END_OF_FILE=4000 DATAF RECORD
$	IF F$EXTRACT(0,1,RECORD) .EQS. "$" THEN GOTO RECORD_LOOP2
$	IF F$EXTRACT(0,1,RECORD) .EQS. "!" THEN GOTO RECORD_LOOP2
$ !
$ ! Get the upgrade field from the current record.  (This time only
$ ! the files labelled UPGRADE=UNDER and UPGRADE=OVER are of interest.)
$ !
$GET_UPGRADE2:
$	UPGRADE = ""
$	L = F$LOCATE("UPG=",RECORD) + 4
$	UPGRADE = F$EXTRACT(L,132,RECORD)
$	L = F$LOCATE(",",UPGRADE)
$	UPGRADE = F$EXTRACT(0,L,UPGRADE)
$	IF F$LOCATE(UPGRADE,VALID_UPGRADES) .NE. F$LENGTH(VALID_UPGRADES) -
	THEN GOTO GET_CONDITIONAL2
$	SAY "Bad upgrade field specified in record *''RECORD'*"
$	GOTO 7000
$ !
$ ! Get the CONDITIONAL field from the current record.
$ !
$GET_CONDITIONAL2:
$	CONDITIONAL = ""
$	L = F$LOCATE("COND=",RECORD) + 5
$	IF L .GE. F$LENGTH(RECORD) THEN GOTO GET_NAME2
$	CONDITIONAL = F$EXTRACT(L,132,RECORD)
$	IF CONDITIONAL .EQS. "" THEN GOTO GET_NAME2
$	L = F$LOCATE(",",CONDITIONAL)
$	CONDITIONAL = F$EXTRACT(0,L,CONDITIONAL)
$	IF (CONDITIONAL .AND. CONDIT) .EQ. 0 THEN GOTO RECORD_LOOP2
$ !
$ ! Get the name from the current record.  (The name is always the first field
$ ! in the record, and doesn't have a keyword associated with it.)
$ !
$GET_NAME2:
$	L = F$LOCATE(",",RECORD)
$	NAME = F$EXTRACT(0,L,RECORD)
$ !
$ ! Get the operation specified by the current record.
$ !
$GET_OPERATION2:
$	L = F$LOCATE("OP=",RECORD) + 3
$	OPERATION = F$EXTRACT(L,132,RECORD)
$	IF OPERATION .EQS. "" THEN GOTO NORMAL2
$	L = F$LOCATE(",",OPERATION)
$	OPERATION = F$EXTRACT(0,L,OPERATION)
$	IF (OPERATION .EQS. "BUILD") .OR. (OPERATION .EQS. "COPY") .OR. -
	(OPERATION .EQS. "CONTIG") -
	THEN GOTO NORMAL2
$	IF (OPERATION .EQS. "SET") THEN GOTO SET2
$	GOTO RECORD_LOOP2
$
$NORMAL2:
$	IF UPGRADE .EQS. "" THEN GOTO RECORD_LOOP2
$	IF F$LOC("''UPGRADE',",OVER_UNDER) .EQ. F$LEN(OVER_UNDER) -
	THEN GOTO RECORD_LOOP2
$	IF F$SEARCH(NAME) .EQS. "" THEN GOTO RECORD_LOOP2
$	SET NOON
$	PURGE 'TARGET'['CLROOT''SETDIR']'NAME'
$	@'TARGET'['CLROOT''DEFDIR']MOVE 'TARGET'['CLROOT''SETDIR']'NAME';* -
			'TARGET'['NEW_ROOT'.'SETDIR'] MOVE 'UPGRADE'
$	SET ON
$	GOTO RECORD_LOOP2
$
$SET2:
$	SET DEFAULT 'TARGET'['CLROOT''NAME']
$	SETDIR = NAME
$	IF NAME .NES. PREV_NAME THEN -
		SAY "Now working on files in [''CLROOT'''NAME']."
$	PREV_NAME = NAME
$	GOTO RECORD_LOOP2
$
$4000:
$	CLOSE DATAF
$	DELETE 'TARGET'['CLROOT''DEFDIR']VMSUNDER.DAT;*
$
$	SET NOON
$	OLD_SYSEXE = "''TARGET'[''OLD_ROOT_DOT'SYSEXE]"
$	OLD_SYSUAF = OLD_SYSEXE
$	IF KIT_CROOT THEN OLD_SYSUAF = TARGET + "[V4COMMON.SYSEXE]"
$	SAY ""
$	SAY "Removing entries for page, swap, dump, and authorization files"
$	SAY "from the ''SYSVER' directory tree."
$	IF F$SEARCH("''OLD_SYSEXE'PAGEFILE.SYS") .NES. "" -
		THEN SET FILE /REMOVE 'OLD_SYSEXE'PAGEFILE.SYS;0
$	IF F$SEARCH("''OLD_SYSEXE'SWAPFILE.SYS") .NES. "" -
		THEN SET FILE /REMOVE 'OLD_SYSEXE'SWAPFILE.SYS;0
$	IF F$SEARCH("''OLD_SYSUAF'SYSUAF.DAT") .NES. "" -
		THEN SET FILE /REMOVE 'OLD_SYSUAF'SYSUAF.DAT;0
$	IF F$SEARCH("''OLD_SYSUAF'NETUAF.DAT") .NES. "" -
		THEN SET FILE /REMOVE 'OLD_SYSUAF'NETUAF.DAT;0
$	IF F$SEARCH("''OLD_SYSUAF'RIGHTSLIST.DAT") .NES. "" -
		THEN SET FILE /REMOVE 'OLD_SYSUAF'RIGHTSLIST.DAT;0
$	IF F$SEARCH("''OLD_SYSEXE'SYSDUMP.DMP") .NES. "" -
		THEN SET FILE /REMOVE 'OLD_SYSEXE'SYSDUMP.DMP;0
$	SAY ""
$	SAY "Deleting old accounting data files, operator logs and everything in [SYSERR]"
$	DELETE 'TARGET'['OLD_ROOT_DOT'SYSMGR]ACCOUNTNG.DAT;*,OPERATOR.LOG;*
$	DELETE 'TARGET'['OLD_ROOT_DOT'SYSERR]*.*;*
$	SET DEFAULT 'TARGET'['NEW_ROOT'.SYSEXE]
$	SAY ""
$	SAY "Moving all remaining files from old directory tree ([''CLROOT']) to new directory tree."
$	UMOVE = "@" + TARGET + "[" + CLROOT + DEFDIR + "]MOVE"
$	TOLDDOT = TARGET + "[" + CLROOT
$	TNEWDOT = TARGET + "[" + NEW_ROOT + "."
$	DOT_CLROOT = "." + F$ELEM(0,".",CLROOT)
$	UMOVE 'TOLDDOT'SYSMSG]*.*;* 'TNEWDOT'SYSMSG] MOVE NULL
$	UMOVE 'TOLDDOT'SYSTEST]*.*;* 'TNEWDOT'SYSTEST] MOVE NULL
$	UMOVE 'TOLDDOT'SYSMAINT]*.*;* 'TNEWDOT'SYSMAINT] MOVE NULL
$	UMOVE 'TOLDDOT'SYSHLP.EXAMPLES]*.*;* 'TNEWDOT'SYSHLP.EXAMPLES] MOVE NULL
$	SET FILE /NODIRECTORY 'TOLDDOT'SYSHLP]EXAMPLES.DIR;1
$	DELETE 'TOLDDOT'SYSHLP]EXAMPLES.DIR;1
$	UMOVE	'TOLDDOT'SYSHLP]*.*;* 'TNEWDOT'SYSHLP] MOVE NULL
$	TEMP = TARGET + "[000000" + DOT_CLROOT + "]SYSCBI.DIR;1"
$	IF F$SEARCH(TEMP) .EQS. "" THEN GOTO NO_SYSCBI
$	UMOVE	'TOLDDOT'SYSCBI]*.*;* 'TNEWDOT'SYSCBI] MOVE NULL
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_CLROOT']SYSCBI.DIR;1
$	DELETE 'TARGET'[000000'DOT_CLROOT']SYSCBI.DIR;1
$NO_SYSCBI:
$	UMOVE 'TOLDDOT'SYSEXE]*.*;* 'TNEWDOT'SYSEXE] MOVE NULL
$	UMOVE 'TOLDDOT'SYSLIB]*.*;* 'TNEWDOT'SYSLIB] MOVE NULL
$	UMOVE 'TOLDDOT'SYSMGR]*.*;* 'TNEWDOT'SYSMGR] MOVE NULL
$	UMOVE 'TOLDDOT'SYSUPD]*.*;* 'TNEWDOT'SYSUPD] MOVE NULL
$	IF F$SEARCH("''TARGET'['OLD_ROOT_DOT'SYSEXE]VAXVMSSYS.PAR") .NES. "" THEN -
			DELETE 'TARGET'['OLD_ROOT_DOT'SYSEXE]VAXVMSSYS.PAR;*
$	SET NOON
$	SAY ""
$	SAY "Deleting old directory tree ([''CLROOT']) system directories."
$	TEMP = CLROOT - "."
$	TEMP = TARGET + "[000000." + TEMP + "]"
$	IF F$SEARCH("''TEMP'001001.DIR;1") .NES. "" THEN -
		SET FILE /REMOVE 'TEMP'001001.DIR;1
$	IF F$SEARCH("''TEMP'001002.DIR;1") .NES. "" THEN -
		SET FILE /REMOVE 'TEMP'001002.DIR;1
$	IF F$SEARCH("''TEMP'001054.DIR;1") .NES. "" THEN -
		SET FILE /REMOVE 'TEMP'001054.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSTEST.DIR;1
$	DELETE 'TEMP'SYSTEST.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSMAINT.DIR;1
$	DELETE 'TEMP'SYSMAINT.DIR;1
$	IF F$SEARCH("''TARGET'[000000]SYSMAINT.DIR") .NES. "" -
		THEN SET FILE /REMOVE 'TARGET'[000000]SYSMAINT.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSMGR.DIR;1
$	DELETE 'TEMP'SYSMGR.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSHLP.DIR;1
$	DELETE 'TEMP'SYSHLP.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSUPD.DIR;1
$	DELETE 'TEMP'SYSUPD.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSMSG.DIR;1
$	DELETE 'TEMP'SYSMSG.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSERR.DIR;1
$	DELETE 'TEMP'SYSERR.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSEXE.DIR;1
$	DELETE 'TEMP'SYSEXE.DIR;1
$	SET FILE /NODIRECTORY 'TEMP'SYSLIB.DIR;1
$	DELETE 'TEMP'SYSLIB.DIR;1
$ !
$ ! Re-set the sysgen parameter that causes the time/date to be requested
$ ! at boot-time.
$ !
$	RUN SYS$SYSTEM:SYSGEN
USE CURRENT
SET /STARTUP SYS$SYSTEM:STARTUP.UP4
SET SETTIME 0
SET VAXCLUSTER 0
WRITE CURRENT
$ @SYS$SYSTEM:STARTUP.UP4 CONTINUE
$	!
$	! On error, exit from the upgrade procedure here.
$	!
$7000:
$	SAY ""
$	SAY "Upgrade to VAX/VMS Version 4.0 incomplete."
$	SAY ""
$	SAY "Error exit from upgrade procedure."
$	SAY "Restart upgrade from last boot of system."
$	SAY ""
$	IF (F$LOGICAL("DATAF") .NES. "") THEN CLOSE DATAF
$	EXIT
