.TITLE	TECOIO	COMPATIBILITY MODE I/O MODULE FOR VAX-11 TECO
.NLIST	TTM
.LIST	TOC,MEB,BEX
.DSABL	REG,GBL,LC
.SBTTL	COMPATIBILITY MODE I/O MODULE FOR VAX-11 TECO

; LAST EDIT ON 27-JUL-83 BY MARK BRAMHALL

.IDENT	/V39.00/

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

.SBTTL	GENERAL PDP-11 DEFINITIONS

; GENERAL REGISTER DEFINITIONS

R0	=	%0
R1	=	%1
R2	=	%2
R3	=	%3
R4	=	%4
R5	=	%5
SP	=	%6
PC	=	%7

.SBTTL	GENERAL MACROS

.MACRO	UNORG
.ENDM	UNORG

.MACRO	ORG	SECT,OFFSET
.MACRO	UNORG
.LIST	BEX
.PSECT	SECT
.ENDM	UNORG
	TMPORG	SECT,<OFFSET>
.ENDM	ORG

.MACRO	DEFORG	SECT
	ORG	SECT
.DSABL	CRF
.IIF	NE	.-SECT,	.ERROR	;DEFORG NOT AT BEGINNING OF SECT
.GLOBL	SECT
.ENABL	CRF
.ENDM	DEFORG

.MACRO	TMPORG	SECT,OFFSET
.LIST	BEX
.PSECT	SECT
.DSABL	CRF
.IF	NDF	SECT
.ENABL	CRF
SECT:
.DSABL	CRF
.ENDC
.ENABL	CRF
.IF	NB	<OFFSET>
.	=	OFFSET+SECT
.ENDC
.ENDM	TMPORG

.MACRO	.DSECT	START,CREF
.IIF	B	<CREF>,	.DSABL	CRF
.IIF	DF	L$$IST,	.DSABL	CRF
.PSECT	..ABS.,RW,D,LCL,ABS,OVR
.IF	NDF	..ABS.
..ABS.:
.ENDC
.	=	0!..ABS.
.IIF	DF	L$$IST,	.ENABL	CRF
.IIF	B	<CREF>,	.ENABL	CRF
.IF	NB	<START>
.	=	START!..ABS.
.ENDC
.ENDM	.DSECT

.MACRO	.BSECT	START,CREF
.IF	IDN	<START>,<HIGH>
.DSECT	400,<CREF>
.IFF
.DSECT	1,<CREF>
.ENDC
.ENDM	.BSECT

.MACRO	.EQUATE	SYMBOL,VALUE,CREF
.DSECT	<VALUE>,<CREF>
.LIST
SYMBOL:
.NLIST
.IIF	B	<CREF>,	.DSABL	CRF
.IIF	DF	L$$IST,	.DSABL	CRF
	UNORG
.IIF	DF	L$$IST,	.ENABL	CRF
.IIF	B	<CREF>,	.ENABL	CRF
.ENDM	.EQUATE

.MACRO	.BLKW0	AMT=1,VALUE=0
.NLIST
.REPT	AMT
	.WORD	VALUE
.ENDR
.LIST
.ENDM	.BLKW0

.MACRO	.BLKB0	AMT=1,VALUE=0
.NLIST
.REPT	AMT
	.BYTE	VALUE
.ENDR
.LIST
.ENDM	.BLKB0

.MACRO	GLOBAL	LIST
.GLOBL	LIST
.ENDM	GLOBAL

.MACRO	CALL	SUBR,REG=PC,LIST
	 JSR	REG,SUBR
.IF	NB	<LIST>
	  .WORD	LIST
.ENDC
.ENDM	CALL

.MACRO	CALLR	SUBR
	 JMP	SUBR
.ENDM	CALLR

.MACRO	CALLX	SUBR,REG=PC,LIST
	CALL	@#SUBR,REG,<LIST>
.DSABL	CRF
.GLOBL	SUBR
.ENABL	CRF
.ENDM	CALLX

.MACRO	CALLRX	SUBR
	CALLR	@#SUBR
.DSABL	CRF
.GLOBL	SUBR
.ENABL	CRF
.ENDM	CALLRX

.MACRO	JMPX	TAG
	 JMP	@#TAG
.DSABL	CRF
.GLOBL	TAG
.ENABL	CRF
.ENDM	JMPX

.MACRO	RETURN	REG=PC
	 RTS	REG
.ENDM	RETURN

.MACRO	.ASSUME	ARG1,COND,ARG2
.IF	COND	<ARG1>-<ARG2>
.IFF
.ERROR	ARG1 ;"COND ARG2" FAILS
.ENDC
.ENDM	.ASSUME

.MACRO	.BR	ARG
.IF	NE	.-<ARG>
.ERROR	;ROUTINE "ARG" MISPLACED
.ENDC
.ENDM	.BR

.MACRO	.CALLR	ARG
.IF	NE	.-<ARG>
.ERROR	;SUBROUTINE "ARG" MISPLACED
.ENDC
.ENDM	.CALLR

.SBTTL	SPECIFIC MACROS

.MACRO	.LONG	ADDR=0
	 .WORD	ADDR,0
.ENDM	.LONG

.MACRO	ENTRY	TAG
.SBTTL	TECOIO ROUTINE "TAG"
TAG::
.ENDM	ENTRY

.MACRO	CTLOFG
	 MOV	IO$CCO,CTLOFG
.ENDM	CTLOFG

.MACRO	NATIVE	TYPE,RETURN
.IF	IDN	<TYPE>,<INPUT>
.IF	NB	<RETURN>
	 TRAP	200
.IFF
	 TRAP
.ENDC
.MEXIT
.ENDC
.IF	IDN	<TYPE>,<OUTPUT>
	 IOT
.MEXIT
.ENDC
.IF	IDN	<TYPE>,<WAIT>
	 BPT
.MEXIT
.ENDC
.IF	NB	<RETURN>
	 EMT	$'TYPE!200
.IFF
	 EMT	$'TYPE
.ENDC
.DSABL	CRF
.GLOBL	$'TYPE
.ENABL	CRF
.ENDM	NATIVE

.SBTTL	DEFINITIONS

STKSIZ	==	512.	;SP STACK SIZE

PATSIZ	==	512.	;PATCH AREA SIZE

TTOBFL	==	512.	;TERMINAL OUTPUT BUFFER LENGTH

ERRBFL	==	256.	;ERROR MESSAGE BUFFER LENGTH

PDLSIZ	==	130.	;PDL SIZE
SCHSIZ	==	130.	;SEARCH BUFFER SIZE
FILSIZ	==	256.	;FILENAME BUFFER SIZE
TAGSIZ	==	130.	;TAG BUFFER SIZE

SIZERB	==	512.	;EXPAND MEMORY IN 1 PAGE CHUNKS

.SBTTL	INITIALIZE TECOIO'S .PSECTS

.PSECT	TECOIO,RO,I,LCL,REL,CON
	DEFORG	TECOIO

.PSECT	SCREEN,RO,I,GBL,REL,OVR
	DEFORG	SCREEN

.PSECT	CRTRUB,RO,I,GBL,REL,OVR
	DEFORG	CRTRUB

.PSECT	TECORW,RW,D,LCL,REL,CON
	DEFORG	TECORW

.SBTTL	"ET" (EDIT TYPEOUT) BITS

.BSECT

ET$BIN::.BLKB	.	;    +1., OUTPUT IN BINARY (IMAGE) MODE
ET$CRT::.BLKB	.	;    +2., DO SCOPE TYPE RUBOUT AND CONTROL/U
ET$LC::	.BLKB	.	;    +4., ACCEPT LOWER CASE INPUT
ET$NCH::.BLKB	.	;    +8., NO ECHO DURING INPUT FOR CTRL/T
ET$CCO::.BLKB	.	;   +16., CANCEL CONTROL/O ON OUTPUT
ET$CKE::.BLKB	.	;   +32., RETURN -1 IF ERROR/NO INPUT ON CTRL/T
ET$DET::.BLKB	.	;   +64., DETACH AND DETACHED FLAG
ET$XIT::.BLKB	.	;  +128., "NO PROMPT YET" FLAG
ET$TRU::.BLKB	.	;  +256., TRUNCATE LONG OUTPUT LINES
ET$IAS::.BLKB	.	;  +512., INTERACTIVE SCOPE AVAILABLE FOR "WATCH"
ET$RFS::.BLKB	.	; +1024., REFRESH SCOPE AVAILABLE FOR "WATCH"
	.BLKB	.	; +2048., RESERVED BY TECO-8
ET$8BT::.BLKB	.	; +4096., TERMINAL IS AN 8-BIT TERMINAL
ET$GRV::.BLKB	.	; +8192., ACCEPT "`" AS ESCAPE DURING COMMAND INPUT
	.BLKB	.	;+16384., UNUSED
ET$CC::	.BLKB	.	;-32768., ALLOW PROGRAM TO TRAP CONTROL/C

.SBTTL	"ED" (EDIT MODE) BITS

.BSECT

ED$CTL::.BLKB	.	;    +1., DON'T ALLOW "^" AS MEANING CONTROL CHARACTER
ED$YNK::.BLKB	.	;    +2., ALLOW YANKS, ETC. TO CLOBBER TEXT BUFFER
ED$EXP::.BLKB	.	;    +4., DON'T ALLOW ARBITRARY EXPANSION(S)
	.BLKB	.	;    +8., RESERVED BY TECO-8
ED$SRH::.BLKB	.	;   +16., DON'T RESET "DOT" ON SEARCH FAILURE
ED$IMD::.BLKB	.	;   +32., ALLOW IMMEDIATE MODE COMMANDS
ED$INC::.BLKB	.	;   +64., ONLY MOVE "DOT" BY ONE ON ITERATIVE SEARCH FAILURES
ED$WCH::.BLKB	.	;  +128., DON'T DO AUTOMATIC "W" COMMAND BEFORE PROMPT
	.BLKB	.	;  +256., UNUSED
	.BLKB	.	;  +512., UNUSED
	.BLKB	.	; +1024., UNUSED
	.BLKB	.	; +2048., UNUSED
	.BLKB	.	; +4096., UNUSED
	.BLKB	.	; +8192., UNUSED
	.BLKB	.	;+16384., UNUSED
	.BLKB	.	;-32768., UNUSED

.SBTTL	STATIC READ/WRITE AREA DEFINITIONS

	ORG	TECORW

TECORW:	.BLKB	STKSIZ		;SP STACK SPACE
SPSET::				;SP STACK RESET VALUE

PATCH::	.BLKB	PATSIZ		;PATCH AREA

TTOBUF::.BLKB	TTOBFL		;TERMINAL OUTPUT BUFFER

INPNOR::.LONG	0		;POINTER TO NORMAL INPUT FAB; ELSE 0
INPALT::.LONG	0		;POINTER TO ALTERNATE INPUT FAB; ELSE 0

OUPNOR::.LONG	0		;POINTER TO NORMAL OUTPUT FAB; ELSE 0
OUPALT::.LONG	0		;POINTER TO ALTERNATE OUTPUT FAB; ELSE 0

CMDPRM::.LONG	0		;POINTER TO INDIRECT COMMAND FILE FAB; ELSE 0

ERRCOD::.WORD	0		;LAST ERROR CODE (RAD50)

ERRBUF::.BLKB	ERRBFL		;ERROR MESSAGE BUFFER

TTOPTR::.LONG	TTOBUF		;CURRENT TERMINAL OUTPUT BUFFER POINTER

TTOINT::.WORD	-1		;TERMINAL OUTPUT BUFFER INTERLOCK FLAG

TTOMOD::.WORD	0		;CURRENT TERMINAL OUTPUT BUFFER MODE

CTLOFG::.WORD	0		;CANCEL CONTROL/O FLAG

IO$BIN::.BLKW			;HOW TO DO BINARY OUTPUT (***FILLED IN***)

IO$CCO::.BLKW			;HOW TO CANCEL CONTROL/O (***FILLED IN***)

XITSTS::.WORD	0		;EXIT STATUS CODE (0=>EG, 1=>EX, ELSE ERROR)

; ***** START OF REQUIRED GROUPING *****

PDLSRT::.BLKB	PDLSIZ		;PDL AREA
SCHSRT::.BLKB0	SCHSIZ-1	;SEARCH BUFFER AREA
	.BYTE	-1
FILSRT::.BLKB0	FILSIZ-1	;FILENAME BUFFER AREA
	.BYTE	-1
TAGSRT::.BLKB0	TAGSIZ-1	;TAG BUFFER AREA
	.BYTE	-1

; ***** END OF REQUIRED GROUPING *****

R5SET::	.BLKB	100.*512.	;START OF "TECO"S R5 AREA

	ORG	TECOIO

ENTRY	ALLERR			;AN ERROR OCCURED IN TECO
	MOV	R0,ERRCOD	;SAVE THE ERROR CODE
	BIC	#ET$CC!ET$CKE!ET$CCO!ET$NCH!ET$BIN,ETYPE(R5) ;CLEAR SOME IN "ET"
	CALL	@(SP)+		;NOW CO-ROUTINE RETURN
	TSTB	ETYPE(R5)	;ANY PROMPT YET?
	BMI	10$		;NO, WE MUST EXIT
.ASSUME	ET$XIT	EQ	200
	NATIVE	ALLER,RETURN	;YES, FINISH UP IN NATIVE MODE & RETURN

10$:	CALLX	CRLFNO		;CANCEL ^O AND RESTORE CARRIAGE
	INC	XITSTS		;SET UP FOR EXIT STATUS OF > 1

.ENABL	LSB

ENTRY	TEXIT			;EXIT FROM TECO
	INC	XITSTS		;SET EXIT STATUS TO 1 FOR NORMAL EXIT
	CLRB	@FILBUF(R5)	;ENSURE THE FILNAME BUFFER IS NULL
10$:	MOV	TECOSP(R5),SP	;RESET THE SP STACK
	CLR	R0		;SET CALLING ARGUMENT TO TURN OFF SCROLLING
	MOV	#10000.,NWATCH(R5) ; AND ENSURE ITS NOT THE DEFAULT ARGUMENT
	CALL	WATCH		;  THEN GO DO IT
20$:	MOV	TECOSP(R5),SP	;RESET THE SP STACK AGAIN
	NATIVE	TEXIT		; AND EXIT FROM TECO
	BR	20$		;  THEN KEEP TRYING TO EXIT...

ENTRY	GEXIT			;EXIT AND GO -OR- SPECIAL FUNCTIONS
	TST	NFLG(R5)	;SPECIAL FUNCTION CALL?
	BPL	10$		;NO, EXIT OR EXIT-AND-GO
	NATIVE	GEXIT,RETURN	;GO PROCESS THE SPECIAL FUNCTION & RETURN

.DSABL	LSB

GLOBAL	<ETYPE,FILBUF,TECOSP,NWATCH,NFLG>

ENTRY	NOCTLO			;CANCEL CONTROL/O EFFECT
	CMP	INDIR(R5),#1	;IS INDIRECT FILE IN "FUNNY" STATE?
	BNE	10$		;NO
	CLR	INDIR(R5)	;YES, SO REALLY "CLOSE" IT
10$:	CTLOFG			;SET TO CANCEL CONTROL/O EFFECT
ENTRY	STOPON			;STOP INDICATOR ON
SCRLOD::RETURN			;EXIT

ENTRY	XITNOW			;STOP SPECIAL TECO TERMINAL HACKS
	NATIVE	XITNW,RETURN	;STOP SPECIAL TECO TERMINAL HACKS & RETURN

ENTRY	DATE			;GET DATE
	NATIVE	DATE,RETURN	;GET DATE & RETURN

ENTRY	TIME			;GET TIME
	NATIVE	TIME,RETURN	;GET TIME & RETURN

ENTRY	SWITCH			;GET SWITCH REGISTER VALUE
	CLR	R0		;FAKE SWITCH REGISTER AS A ZERO
	RETURN			; AND EXIT

GLOBAL	<INDIR>

ENTRY	FLAGRW			;CATCH TECO FLAG CHANGES/READS
	TST	R2		;IS IT THE "EJ" CALL?
	BNE	10$		;NOPE
	NATIVE	EJFLG,RETURN	;YEP, SO PROCESS IT & RETURN

10$:	CMP	R2,#ETYPE	;IS IT THE "ET" FLAG?
	BNE	50$		;NOPE
	CMP	R3,#-1		;YEP, SETTING IT (-1)??
	BNE	50$		;NO, READING "ET"
	BIT	R0,#ET$CCO	;CANCELING CONTROL/O?
	BEQ	20$		;NOPE
	CTLOFG			;YES, SO SIGNAL A CONTROL/O CANCEL
20$:	MOV	ETYPE(R5),-(SP)	;GET CURRENT "ET" FLAG BITS
	XOR	R0,(SP)		; AND FIND THE CHANGED BITS
	BIT	#ET$TRU,(SP)	;IS TRUNCATE LINES CHANGING?
	BEQ	30$		;NOPE
	NATIVE	TRULN		;YEP, LET SOMEONE KNOW ABOUT IT
30$:	BIT	#ET$8BT,(SP)+	;IS 8-BIT TERMINAL CHANGING?
	BEQ	40$		;NOPE
	NATIVE	EIGHT		;YEP, LET SOMEONE KNOW ABOUT IT
40$:	BIC	#ET$RFS!ET$IAS!ET$DET,R0 ;ENSURE THE NEW "ET"
	BIT	#ET$IAS,ETYPE(R5) ; WILL
	BEQ	50$		;  BE
	BIS	#ET$IAS,R0	;   CORRECT
50$:	RETURN			;NOW EXIT

.ENABL	LSB

ENTRY	TLISTN			;GET A CTRL/T CHARACTER
	MOV	ETYPE(R5),R0	;GET "ET" FLAGS AND ISOLATE
	BIC	#^C<ET$CC!ET$CKE!ET$NCH>,R0 ; CTRL/C, INPUT CHECK, & NO ECHO
	INC	R0		;ENSURE NON-ZERO FOR SINGLE CHAR MODE
.ASSUME	ET$CC!ET$CKE!ET$NCH&1 EQ 0
	BR	10$		;NOW CONTINUE

ENTRY	LISTEN			;GET A COMMAND CHARACTER
	TST	R0		;SINGLE CHARACTER MODE?
	BEQ	10$		;NOPE, LEAVE A ZERO AS A FLAG
	MOV	#2!1,R0		;YEP, SET MAIN PROMPT & SINGLE CHAR MODE FLAGS
.ASSUME	ET$CC!ET$CKE!ET$NCH&2 EQ 0
10$:	NATIVE	INPUT,RETURN	;GO GET SOME TERMINAL INPUT & RETURN

.DSABL	LSB

GLOBAL	<ETYPE>

ENTRY	GETFLS			;GET FILES
	NATIVE	GETFL,RETURN	;GET FILES & RETURN

ENTRY	INPSAV			;SAVE CURRENT INPUT STATUS
	NATIVE	INPSV,RETURN	;SAVE CURRENT INPUT STATUS & RETURN

ENTRY	OUTSAV			;SAVE CURRENT OUTPUT STATUS
	NATIVE	OUTSV,RETURN	;SAVE CURRENT OUTPUT STATUS & RETURN

ENTRY	BACKUP			;PAGE BACKWARDS
	NATIVE	BAKUP,RETURN	;PAGE BACKWARDS & RETURN

ENTRY	GETBUF			;GET A BUFFER FULL
	NATIVE	GETBF,RETURN	;GET A BUFFER FULL & RETURN

ENTRY	PUTBUF			;PUT OUT A BUFFER FULL
	NATIVE	PUTBF,RETURN	;PUT OUT A BUFFER FULL & RETURN

ENTRY	CLSOUT			;CLOSE THE OUTPUT FILE (AND DO "EB")
	NATIVE	CLSOF,RETURN	;CLOSE THE OUTPUT FILE (AND DO "EB") & RETURN

ENTRY	CLSFIL			;CLOSE INPUT/OUTPUT FILES (DO "EB")
	NATIVE	CLSFL,RETURN	;CLOSE INPUT/OUTPUT FILES (DO "EB") & RETURN

ENTRY	KILFIL			;STOP AN OUTPUT FILE
	NATIVE	KILFL,RETURN	;STOP AN OUTPUT FILE & RETURN

ENTRY	SIZER			;GET ADDITIONAL MEMORY IF POSSIBLE
	NATIVE	SIZER,RETURN	;GET ADDITIONAL MEMORY IF POSSIBLE & RETURN

ENTRY	DELLIN			;PROCESS CONTROL/U ECHO
	NATIVE	DELLN,RETURN	;PROCESS CONTROL/U ECHO & RETURN

ENTRY	DELCHR			;PROCESS DELETE ECHO
	NATIVE	DELCH,RETURN	;PROCESS DELETE ECHO & RETURN

.ENABL	LSB

ENTRY	TYPEF			;TYPE WITH CASE FLAGGING (R0=CHAR)
	CALL	120$,R1		;SAVE R1, CHECK MODE(S), ETC.
10$:	TST	EUFLAG(R5)	;ARE WE CASE FLAGGING?
	BMI	50$		;NOPE (<0)
	BEQ	20$		;WE'RE FLAGGING LOWER CASE (=0)
	CMPB	R0,#'@		;WE'RE FLAGGING UPPER CASE (>0)
	BLO	50$		;NOT UPPER CASE
	CMPB	R0,#'_		;REALLY UPPER CASE?
	BLOS	30$		;YES, SO GO FLAG IT
	BR	50$		;NO, DO NORMAL OUTPUT

20$:	CMPB	R0,#'@+40	;FLAG LOWER CASE (=0), IS IT LOWER CASE?
	BLT	50$		;NOT LOWER CASE
30$:	CALL	210$,R4,<''>	;OUTPUT CASE FLAG PREFIX
	BR	140$		; THEN THE CHARACTER

ENTRY	TYPEB			;TYPE RINGING BELLS (R0=CHAR)
	CALL	120$,R1		;SAVE R1, CHECK MODE(S), ETC.
40$:	CMPB	R0,#007		;IS IT A BELL?
	BEQ	140$		;YES, OUTPUT A BELL AS IS
50$:	MOVB	R0,R0		;SPECIAL "NEGATIVE" CHARACTER?
	BMI	90$		;YES, GO CHECK IT OUT
	CMPB	R0,#040		;REGULAR CHARACTER?
	BHIS	140$		;YES, OUT IT GOES AS IS
	CMPB	R0,#015		;IS IT <CR>?
	BHI	70$		;IT'S HIGHER THAN <CR>
	CMPB	R0,#007		;IS IT BELL?
	BHI	140$		;IT'S HIGHER THAN BELL
	BLO	80$		;IT'S LOWER THAN BELL
	CALL	140$		;IT'S BELL, SO RING THE BELL
60$:	CALL	210$,R4,<'^>	;OUTPUT CONTROL CHARACTER PREFIX
	BR	140$		; THEN THE CONTROL CHARACTER

70$:	CMPB	R0,#033		;IS IT ESCAPE?
	BNE	60$		;NO
	MOV	#'$,R0		;CHANGE AN ESCAPE INTO A "$"
	BR	140$		; THEN GO OUTPUT IT

80$:	TSTB	R0		;IS IT A NULL?
	BNE	60$		;NO, OUTPUT AS A CONTROL CHARACTER
	BR	140$		;YES, OUTPUT A NULL AS IS

GLOBAL	<EUFLAG>

90$:	MOV	#'<*400+'>,-(SP) ;SET TRAILING/LEADING FOR COMPOSE SEQUENCE
	ASL	R0		;CHANGE 177600-177777 INTO 177400-177776
	MOV	CNV8BT+400(R0),-(SP) ;GET THE CONVERSION CHARACTER PAIR
	BPL	110$		;IT IS A COMPOSE SEQUENCE PAIR
	BIC	#100000,(SP)	;IT IS A HEX PAIR, REMOVE THE HEX FLAG
	MOV	#'[*400+'],2(SP) ;SET TRAILING/LEADING FOR HEX PAIR
100$:	MOVB	3(SP),R0	;GET THE LEADING CHARACTER
	CALL	140$		; AND GO OUTPUT IT
	MOV	(SP)+,R0	;GET THE CHARACTER PAIR
	CALL	140$		; AND GO OUTPUT THE FIRST OF THE PAIR
	SWAB	R0		;SWITCH FOR THE SECOND OF THE PAIR
	CALL	140$		; AND GO OUTPUT IT
	MOVB	(SP)+,R0	;GET THE TRAILING CHARACTER
	BR	140$		; AND GO OUTPUT IT...

110$:	BIT	#ET$8BT,ETYPE(R5) ;IS THIS AN 8-BIT TERMINAL?
	BEQ	100$		;NOPE, USE COMPOSE SEQUENCE NOTATION
	CMP	(SP)+,(SP)+	;YEP, POP THE STACKED ITEMS
	ASR	R0		;FIX THE CHARACTER BACK UP
	BR	140$		; AND GO OUTPUT IT AS IS

GLOBAL	<CNV8BT,ETYPE>

TYPEBF::MOV	R1,-(SP)	;SAVE R1
	MOV	R0,-(SP)	; AND R0
	MOV	#250$,-(SP)	;SET A RETURN TO RESTORE REGISTERS LATER
	MOV	#40$,-(SP)	;STACK NON-BINARY MODE RETURN ADDRESS
	BR	130$		;NOW JOIN COMMON CODE

120$:	;MOV	R1,-(SP)	;SAVE R1 (SAVED BY THE 'JSR R1,')
	MOV	R0,-(SP)	; AND R0
	MOV	#240$,-(SP)	;SET A RETURN TO RESTORE REGISTERS LATER
	MOV	R1,-(SP)	;STACK THE NON-BINARY MODE RETURN ADDRESS
130$:	CLR	R1		;GUESS AT NORMAL MODE
	BIT	#ET$BIN,ETYPE(R5) ;REALLY BINARY OUTPUT MODE?
	BEQ	190$		;NOPE, RETURN TO CALLER
	MOV	IO$BIN,R1	;YEP, SO SET BINARY OUTPUT MODE
	TST	(SP)+		; AND JUNK THE RETURN TO OUR CALLER
140$:	BIS	CTLOFG,R1	;.OR. CONTROL/O CANCEL INTO OUTPUT MODE
	CLR	CTLOFG		; THEN CLEAR OUT THE FLAG
	BIC	#ET$CCO,ETYPE(R5) ;  AND SAY WE DID IT
150$:	CMP	TTOPTR,#TTOBUF	;IS THE TERMINAL OUTPUT BUFFER EMPTY?
	BEQ	180$		;YES, ALWAYS O.K. TO BUFFER, ETC.
	CMP	R1,TTOMOD	;ARE WE NOW IN CORRECT MODE?
	BEQ	160$		;TOTALLY CORRECT
	MOV	R1,-(SP)	;ELSE COPY THE DESIRED MODE
	BIS	IO$CCO,(SP)	; AND .OR. IN A CANCEL OF CONTROL/O
	CMP	(SP)+,TTOMOD	;IS THE MODE NOW CORRECT?
	BNE	170$		;NOPE, MUST BE REALLY CHANGING MODES
160$:	CMP	TTOPTR,#TTOBUF+TTOBFL ;ANY ROOM TO BUFFER A CHARACTER?
	BLO	180$		;ROOM LEFT, JUST GO BUFFER THE CHARACTER
170$:	TST	TTOINT		;IS OUTPUT CURRENTLY IN PROGRESS?
	BPL	200$		;YES, WE MUST WAIT FOR IT TO FINISH
	NATIVE	OUTPUT		;NO, START IT GOING SO WE CAN (RE-)USE BUFFER
180$:	INC	TTOINT		;INTERLOCK THE TERMINAL OUTPUT BUFFER
	BIS	R1,TTOMOD	;SET THE OUTPUT BUFFER MODE
	MOVB	R0,@TTOPTR	;STORE THE CHARACTER IN THE OUTPUT BUFFER
	INC	TTOPTR		; THEN BUMP THE BUFFER POINTER
	DEC	TTOINT		;  AND TAKE AWAY THE BUFFER INTERLOCK
190$:	RETURN			;EXIT

200$:	NATIVE	WAIT		;GO WAIT FOR TERMINAL OUTPUT TO FINISH
	BR	150$		; THEN TRY, TRY AGAIN...

210$:	MOV	R0,-(SP)	;SAVE THE REAL CHARACTER
	MOV	(R4)+,R0	;NOW GET THE PREFIX CHARACTER
	CALL	140$		; AND GO OUTPUT IT
	MOV	(SP)+,R0	;RESTORE THE REAL CHARACTER
	BIC	#40,R0		;ENSURE IT IS NOT LOWER CASE
	BIS	#100,R0		; AND THAT IT IS A NORMAL GRAPHIC
	RETURN	R4		;  THEN RETURN

GLOBAL	<ETYPE>

ENTRY	PRINTF			;PRINT WITH CASE FLAGGING (R3=PTR; R4=CNT)
	CALL	SAVREG,R4	;SAVE REGISTERS
	MOV	#10$,R2		;SET THE OUTPUT ROUTINE ADDRESS
	BR	220$		;NOW CONTINUE

ENTRY	PRINTB			;PRINT RINGING BELLS (R3=PTR; R4=CNT)
	CALL	SAVREG,R4	;SAVE REGISTERS
	MOV	#40$,R2		;SET THE OUTPUT ROUTINE ADDRESS
220$:	CLR	R1		;GUESS AT NORMAL MODE OUTPUT
	BIT	#ET$BIN,ETYPE(R5) ;GOOD GUESS?
	BEQ	230$		;YES
	MOV	#140$,R2	;NO, SET FOR BINARY MODE OUTPUT
	MOV	IO$BIN,R1	; IN BOTH PLACES
	BR	230$		;  THEN CONTINUE

ENTRY	PRINT			;PRINT (R3=PTR; R4=CNT)
	CALL	SAVREG,R4	;SAVE REGISTERS
	CLR	R1		;ALWAYS SAY NORMAL MODE OUTPUT
	MOV	#50$,R2		;SET THE OUTPUT ROUTINE ADDRESS
230$:	DEC	R4		;MORE TO GO?
	BMI	190$		;NOPE
	MOVB	(R3)+,R0	;YEP, GET A CHARACTER
	CALL	(R2)		; AND GO OUTPUT IT
	BR	230$		;  THEN LOOP...

ENTRY	TYPE			;TYPE (R0=CHAR)
	MOV	R1,-(SP)	;SAVE R1
	MOV	R0,-(SP)	; AND R0
	CLR	R1		;ALWAYS SAY NORMAL MODE OUTPUT
	CALL	50$		;NOW GO OUTPUT THE CHARACTER
240$:	TST	(PC)+		;SET C=0 FOR STARTING OUTPUT RIGHT NOW
250$:	SEC			;SET C=1 FOR STARTING OUTPUT LATER ON
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R1	; AND R1
	BCS	190$		;DON'T START THE OUTPUT YET
	BR	TYPEBC		;ELSE EXIT STARTING THE OUTPUT

.DSABL	LSB

GLOBAL	<ETYPE>

.SBTTL	INITIAL STARTUP

TECOST::TST	R4		;ANY TERMINAL INFORMATION TO LOOK AT?
	BEQ	10$		;NOPE, SO DON'T, EVERYTHING IS SETUP
	CALL	CRTRUB		;YEP, GO SET SCOPE TYPE, ETC.
	ADD	R4,TXSTOR(R5)	;SKIP "WATCH" R/W SIZE BEFORE STARTING TEXT
	SUB	R4,ZMAX(R5)	; AND TAKE "WATCH" R/W SIZE AWAY FROM IT
10$:	JMPX	TECO		;NOW START US UP...

.SBTTL	REGISTER SAVE/RESTORE SUBROUTINE

SAVREG::;MOV	R4,-(SP)	;R4 WAS SAVED BY THE 'JSR R4'
	MOV	R3,-(SP)	;SAVE R3
	MOV	R2,-(SP)	; AND R2
	MOV	R1,-(SP)	;  AND R1
	MOV	R0,-(SP)	;   AND R0
	MOV	R4,-(SP)	;STACK THE RETURN ADDRESS
	MOV	5*2(SP),R4	;THEN RESTORE R4 TO ITS REAL VALUE
	CALL	@(SP)+		; AND EXIT (CO-ROUTINE WISE)
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R1	; AND R1
	MOV	(SP)+,R2	;  AND R2
	MOV	(SP)+,R3	;   AND R3
	MOV	(SP)+,R4	;    AND R4
TYPEBC::TST	TTOINT		;IS THE TERMINAL OUTPUT BUFFER BUSY?
	BPL	10$		;BUSY, JUST EXIT (C=0 FROM 'TST')
	CMP	TTOPTR,#TTOBUF	;IDLE, IS ANYTHING REALLY BUFFERED THERE?
	BEQ	10$		;NOPE, EXIT (C=0 SINCE 'BEQ'=>'BHIS'='BCC')
	NATIVE	OUTPUT		;YEP, START THAT TERMINAL OUTPUT GOING
	;CLC			;C=0 ('BHI'=>'BHIS'='BCC')
10$:	RETURN			;FINAL EXIT

R0OFF	==	1*2		;OFFSET TO SAVED R0

GLOBAL	<TXSTOR,ZMAX>

.SBTTL	SET UP FOR SCOPE CHARACTER/LINE DELETION

	ORG	CRTRUB

CRTRUB:	BR	CRTSET		;BRANCH TO THE SET UP ROUTINE

.IIF	NE	.-CRTRUB-2, .ERROR ;ERASE CHARACTER INCORRECTLY LOCATED
CRTERC::.BLKW			;ERASE CHARACTER SEQUENCE POINTERS POINTER

.IIF	NE	.-CRTRUB-4, .ERROR ;CURSOR UP INCORRECTLY LOCATED
CRTCUP::.BLKW			;CURSOR UP SEQUENCE POINTERS POINTER

.IIF	NE	.-CRTRUB-6, .ERROR ;<CR><ERASE LINE> INCORRECTLY LOCATED
CRTERL::.BLKW			;<CR><ERASE LINE> SEQUENCE POINTERS POINTER

CRTSET:	CLR	R4		;SAY NO "WATCH" READ/WRITE REGION DESIRED
	RETURN			;NO SCOPE SUPPORT, JUST EXIT

.SBTTL	SCOPE "WATCH" ROUTINE

	ORG	SCREEN

ENTRY	WATCH			;SCOPE "WATCH"
SCREEN:	RETURN			;SIMPLE RETURN

.END

