%TITLE 'NML SET parameter module'
MODULE NML$SET (
		LANGUAGE (BLISS32),
		ADDRESSING_MODE (NONEXTERNAL=GENERAL),
		ADDRESSING_MODE (EXTERNAL=GENERAL),
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  DECnet-VAX Network Management Listener
!
! ABSTRACT:
!
!	These routines provide the operations necessary to perform all
!	NCP SET entity commands.
!
! ENVIRONMENT:  VAX/VMS Operating System
!
! AUTHOR:  Distributed Systems Software Engineering
!
! CREATION DATE:  30-DEC-1979
!
! MODIFIED BY:
!
!	V03-011	MKP0017		Kathy Perko	13-Aug-1984
!		For entities that have at least one required field,
!		don't do a SET ALL if the entity isn't in the permanent
!		database.
!
!	V03-010	MKP0016		Kathy Perko	25-Mar-1984
!		Fix SET LOGGING bug so events are added correctly.
!
!	V03-009	MKP0015		Kathy Perko	3-Feb-1984
!		Add X25-Access Module support.
!
!	V03-008	MKP0014		Kathy Perko	4-Aug-1983
!		Make changes to give the node permanent database multiple
!		ISAM keys.  This speeds up accessint it.
!
!	V03-007	MKP0013		Kathy Perko	26-April-1983
!		Add SET MODULE CONFIGURATOR ALL commands.
!
!	V03-006	MKP0012		Kathy Perko	23-Nov_1982
!		Add module as a source for events.
!
!	V03-005	MKP0011		Kathy Perko	27-Oct-1982
!		Enlarge NFB buffer used for SETs.
!
!	V03-004	MKP0010		Kathy Perko	14-Sept-1982
!		For logging to the executor node, the sink node address is
!		stored in the permanent database as zero.  This allows the
!		logging permanent database to be transportable without logging
!		events to the old executor.
!
!	V03-003	MKP0009		Kathy Perko	10-Sept-1982
!		Put in fix so SET X25-PROTOCOL KNOWN GROUPS ALL works.
!
!	V03-002	MKP0008		Kathy Perko	23-June-1982
!		Add support to handle X25-Protocol "active network" concept.
!		Also, change qualifier handling to use the qualifier's
!		Parameter Semantic Table (PST) entry address, instead of
!		the qualifier's Network Management parameter code.
!		Add X25 and X29 Server and Trace modules.
!
!	V03-001	MKP0007		Kathy Perko	28-April-1982
!		Make changes to add second search key to QIO interface
!		to NETACP.
!
!	V02-005	MKP0006		Kathy Perko	07-Feb-1982
!		Repair previous fix to reinstate SET KNOWN LOGGING ALL.
!
!	V02-004	MKP0005		Kathy Perko	31-Jan-1982
!		For SET KNOWN LOGGING commands, change NML so it will do the
!		update if the sink has an entry in either the ESI or the
!		EFI volatile database.
!
!	V02-004	MKP0004		Kathy Perko	17-Nov-1981
!		Add circuits to logging event sources, and fix buffer
!		overflow problem correctly (if not filters defined for
!		a sink, error returned was buffer overflow).
!
!	V02-003	MKP0003		Kathy Perko	16-Nov-1981
!		Undo the previous fix.  It's wrong.
!
!	V02-002	MKP0002		Kathy Perko	17-Sept-1981
!		Fix SET KNOWN LOGGING ALL so that buffer overflow
!		is not returned if no logging is defined for a sink.
!
! 	V02-001	MKP0001		Kathy Perko	21-July-1981
!		Add Circuit entity.
!--


%SBTTL 'Declarations'

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    NML$SETENTITY	: NOVALUE,
    NML$SETKNOLOG	: NOVALUE,
    NML$SETLOGGING	: NOVALUE,
    NML_SETLOGGING	: NOVALUE,
    NML_SETLOGALL	: NOVALUE,
    NML_ADDALLFIL,
    NML_SETENTITY,
    NML$SETLINE		: NOVALUE,
    NML$SETEXECUTOR	: NOVALUE,
    NML$SETKNOWN	: NOVALUE,
    NML$SETKNONODES	: NOVALUE,
    NML_SETKNOWN	: NOVALUE,
    NML_SETKNOWNALL	: NOVALUE,
    NML_SETEXE		: NOVALUE,
    NML_SETEXEALL	: NOVALUE,
    NML$SET_NI_CONFIG	: NOVALUE;

!
! INCLUDE FILES:
!

LIBRARY 'LIB$:NMLLIB.L32';
LIBRARY 'SHRLIB$:NMALIBRY.L32';
LIBRARY 'SHRLIB$:NET.L32';
LIBRARY 'SYS$LIBRARY:STARLET.L32';

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!

!
! Buffers and descriptors.
!
OWN
    NML$T_PRMBUFFER  : VECTOR [NML$K_QIOBFLEN, BYTE], ! Parameter (scratch) buffer
    NML$T_NFBBUFFER  : VECTOR [NML$K_NFBBFLEN, BYTE], ! NFB QIO buffer
    NML$T_P2BUFFER   : VECTOR [NML$K_P2BUFLEN,  BYTE], ! P2 QIO buffer
    NML$T_ENTBUFFER  : VECTOR [NML$K_ENTBUFLEN, BYTE]; ! Entity buffer

BIND
    NML$Q_PRMBFDSC  = UPLIT (NML$K_QIOBFLEN, NML$T_PRMBUFFER)
		      : DESCRIPTOR,
    NML$Q_NFBBFDSC   = UPLIT (%ALLOCATION(NML$T_NFBBUFFER),  NML$T_NFBBUFFER)
		      : DESCRIPTOR,
    NML$Q_P2BFDSC   = UPLIT (%ALLOCATION(NML$T_P2BUFFER),  NML$T_P2BUFFER)
		      : DESCRIPTOR;
OWN
    NML$Q_ENTBFDSC : DESCRIPTOR
		     INITIAL (0, NML$T_ENTBUFFER);

!
! EXTERNAL REFERENCES:
!

$NML_EXTDEF;

EXTERNAL LITERAL
    NML$_BADEVTUPD,
    NML$_NOSNKNOD;

EXTERNAL ROUTINE
    NML$MATCHRECORD,
    NMA$SEARCHFLD,
    NML$ADDEVENTS,
    NML$ADDFILTERS,
    NML$BLDALLDES,
    NML$BLDP2,
    NML$BLD_REPLY,
    NML$BLDSETQBF,
    NML$CALL_NI_CONFIG,
    NML$GETEXEID,
    NML$GETINFTABS,
    NML$GET_ENTITY_IDS,
    NML$GETNXTEVT,
    NML$GETNXTSNK,
    NML$GETEXEADR,
    NML$GETRECOWNER,
    NML$GETTABLE,
    NML$NETQIO,
    NML$READ_KNOWN_NODE_REC,
    NML$READRECORD,
    NML$SAVEVENTS,
    NML$SEND;

%SBTTL 'NML$SETENTITY  Set volatile database parameters'
GLOBAL ROUTINE NML$SETENTITY (ENTITY, ENTITY_LEN, ENTITY_ADR,
				QUAL_PST, QUAL_LEN, QUAL_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the specified parameters to the volatile data base
!	entry for the specified component.  The purpose of this routine is
!	to allow the same code (NML_CLEARENTITY, etc.) to be used for both
!	singular and plural entity operations.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	ENTITY_LEN	Byte count of entity id string.
!	ENTITY_ADR	Address of entity id string.
!	QUAL_PST	Qualifier's Parameter Semantic Table address
!	QUAL_LEN	Qualifier length
!	QUAL_ADR	Qualifier address
!
! SIDE EFFECTS:
!
!	A NICE response message is built and transmitted.
!
!--

    BEGIN

    LOCAL
	MSGSIZE;

!
! X25 Server and Trace, and X29 Server databases have only one entry.  So
! always do a wildcard zero of these databases.
!
IF .ENTITY EQL NML$C_X25_SERV OR
   .ENTITY EQL NML$C_X29_SERV OR
   .ENTITY EQL NML$C_TRACE THEN
    ENTITY_LEN = -1;
    
!
! Call the routine to process the entity.
!
    NML_SETENTITY (.ENTITY, .ENTITY_LEN, .ENTITY_ADR,
			.QUAL_PST, .QUAL_LEN, .QUAL_ADR);
!
! Build and signal the response message.
!
    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
    NML$SEND (NML$AB_SNDBUFFER, .MSGSIZE);

    END;				! End of NML$SETENTITY

%SBTTL 'NML$SETKNOLOG  Set parameters for known logging'
GLOBAL ROUTINE NML$SETKNOLOG (ENTITY, DUM1, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Add parameters to KNOWN entries in the logging volatile data base.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	DUM1		Not used.
!	DUM2		Not used.
!
!--

BEGIN

!
! NFBs used to find out if NETACP already has entries in its database for
! each sink type.
!
    $NFBDSC	(ESINFB,	! NFB descriptor label.
		SHOW,		! Function code
		,		! No flags
		ESI,		! ACP Data base ID
		SNK,,		! Search key one ID = Sink type, oper1 = eql
		,		! Search key two ID = wildcard, oper2 = eql
		);

LOCAL
    STATUS,
    P3,
    DUMDSC:	REF DESCRIPTOR,
    NFBDSC:	REF DESCRIPTOR,
    P2DSC : DESCRIPTOR,
    BLKDSC: DESCRIPTOR,
    SRCPTR,
    PTR;
!
! KNOWN LOGGING ALL is defined by whatever is set in the permanent data base.
!
! KNOWN LOGGING is defined by sink node. In otherwords:
! 	SET KNOWN LOG  updates the executor node logging.  This means updating
! the sink (ESI) and filter (EFI) volatile database entries which already
! exist for the executor.  Note that the ESI database applies to the
! executor node only.
!	SET KNOWN LOGGING SINK NODE updates logging for the specified sink
! node.  This means updating the filter (EFI) volatile database entries which
! already exist for that node.
!
INCR SNK FROM NMA$C_SNK_CON TO NMA$C_SNK_MON DO
    BEGIN
    !
    ! If processing a SET KNOWN LOGGING ALL command, the logging set in the
    ! permanent database determines what gets set in the volatile database.
    ! 
    IF .NML$GL_PRS_FLGS [NML$V_PRS_ALL]
    THEN
	NML_SETLOGALL (.SNK)
    ELSE    
	!
	! Determine if there are any entries in the volatile database for this
	! sink node and sink (console, file, monitor).
	!
	BEGIN
	STATUS = 0;
	!
	! If the sink node is the executor node, check to see if there's
	! anything in the sink database.
	!
	IF .NML$GL_PRS_FLGS [NML$V_PRS_EXESNK] THEN
	    BEGIN
	    NML$BLDP2 (0, .SNK, -1, 0, NML$Q_P2BFDSC, P2DSC);
	    STATUS = NML$NETQIO (ESINFB, P2DSC, P3, NML$GQ_QIOBFDSC);
	    END;
	!
	! If the sink node isn't the executor node, or there isn't anything in
	! the ESI database for the exec, check the filter (EFI) database for
	! this sink.
	!
	IF NOT .STATUS THEN
	    BEGIN
	    NML$GETINFTABS (NML$C_LOGGING, NML$C_EVENTS, NFBDSC, DUMDSC, 0);
	    NML$BLDP2 (0, .NML$GW_EVTSNKADR, -1, 0, NML$Q_P2BFDSC, P2DSC);
	    !
	    ! Get events set for specified sink node.  Then search through the
	    ! source block of events to see if any of the events are specified
	    ! for the sink currently being processed.
	    !
	    IF NML$NETQIO (.NFBDSC, P2DSC, P3, NML$GQ_QIOBFDSC) THEN
		BEGIN
		PTR = .NML$GQ_QIOBFDSC [DSC$A_POINTER];
		BLKDSC [DSC$W_LENGTH] = .(.PTR)<0,16>;
		BLKDSC [DSC$A_POINTER] = .PTR + 2;
		SRCPTR = 0;
		!
		! If any of the events are for the sink I am currently
		! working on, then do the SET for that sink.
		!
		STATUS = NML$GETNXTSNK (BLKDSC, .SNK, SRCPTR);
		END;
	    END;
	IF .STATUS THEN
	    !
	    ! Either the EFI or the ESI volatile database already has an entry
	    ! for this sink (File, console, or monitor).  So do the update.
	    !
	    NML$SETLOGGING (.ENTITY, .SNK, 0);
	END;
    END;

END;				! End of NML$SETKNOLOG

%SBTTL 'NML$SETLOGGING  Set logging parameters'
GLOBAL ROUTINE NML$SETLOGGING (ENTITY, SNK, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Add parameters to the volatile data base entry for the specified
!	logging entity.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	SNK		Logging sink type.
!	DUM2		Not used.
!
! IMPLICIT INPUTS:
!
!	NML$GL_PRS_FLGS	Message parsing flags.
!	NML$GW_EVTSNKADR Sink node address.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! 	A NICE response message is built and transmitted.
!
!--

    BEGIN

    LOCAL
	MSG_SIZE;			! Message size
!
! Check the parsing flags to see if this is a SET ALL function.
!
    IF .NML$GL_PRS_FLGS [NML$V_PRS_ALL]
    THEN
	NML_SETLOGALL (.SNK)
    ELSE
	BEGIN
!
! Decide if the parameter group is for filters (EFI) or sinks (ESI).
!
	IF .NML$GL_PRS_FLGS [NML$V_PRS_ESIPG]
	THEN
	    NML_SETENTITY (NML$C_SINK, 1, SNK, 0, 0, 0)
	ELSE
	    NML_SETLOGGING (.SNK, .NML$GW_EVTSNKADR);

	END;
!
! Add entity id (sink type code) to entity buffer.
!
    NML$Q_ENTBFDSC [DSC$W_LENGTH] = 1;
    NML$Q_ENTBFDSC [DSC$A_POINTER] = NML$T_ENTBUFFER;
    NML$T_ENTBUFFER<0,8> = .SNK;
!
! Add entity descriptor to message information.
!
    NML$AB_MSGBLOCK [MSB$V_ENTD_FLD] = 1;
    NML$AB_MSGBLOCK [MSB$A_ENTITY] = NML$Q_ENTBFDSC;
!
! Build and send the message.
!
    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSG_SIZE);
    NML$SEND (NML$AB_SNDBUFFER, .MSG_SIZE); ! Send message

    END;				! End of NML$SETLOGGING

%SBTTL 'NML_SETLOGGING  Set logging parameters'
ROUTINE NML_SETLOGGING (SNK, SNKADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs common SET functions for both singular
!	and plural logging volatile data base operations.
!
! FORMAL PARAMETERS:
!
!	SNK		Logging sink type.
!	SNKADR		Sink node address.
!
!--

    BEGIN

    MAP
	SNKADR : WORD;

    LOCAL
	DB,				! Database ID
	SRCHKEY1,			! Search key one ID
	SRCHKEY2,			! Search key two ID
	DUMDSC : REF DESCRIPTOR,	! Dummy descriptor for table
	EVTADR,				! Address of event parameter
	EVTLEN,				! Length of event parameter
	NFBDSC : REF DESCRIPTOR,
	P3,				! Byte count of data returned by NETACP.
	P2DSC  : DESCRIPTOR,
	QBFDSC : DESCRIPTOR,
	RECDSC : DESCRIPTOR,
	STATUS,
	TABDES : REF DESCRIPTOR,
	UPDFLG;				! Data base update flag

    RECDSC [DSC$W_LENGTH] = 0;		! Initial descriptor
    RECDSC [DSC$A_POINTER] = .NML$GQ_RECBFDSC [DSC$A_POINTER];

    NML$GETINFTABS (NML$C_LOGGING, NML$C_EVENTS, NFBDSC, DUMDSC, 0);
    NML$BLDP2 (0, .SNKADR, -1, 0, NML$Q_P2BFDSC, P2DSC);

    STATUS = NML$NETQIO (.NFBDSC, P2DSC, P3, NML$GQ_QIOBFDSC);

    IF NOT .STATUS AND (.STATUS NEQ NML$_STS_CMP)
    THEN
	RETURN;

    IF .STATUS
    THEN
	BEGIN

	EVTLEN = .(.NML$GQ_QIOBFDSC [DSC$A_POINTER])<0,16>;
	EVTADR = .NML$GQ_QIOBFDSC [DSC$A_POINTER] + 2;

	END
    ELSE
	!
	! There is no entry for this sink in NETACPs filter (EFI) database.
	! Create a null permanent data base entry to which the filter info
	! from the NICE command will be added.
	!
	BEGIN
	EVTLEN = 0;
	EVTADR = 0;
	END;

    IF NOT NML$SAVEVENTS (.NML$GQ_RECBFDSC [DSC$W_LENGTH],
			  .EVTLEN,
			  .EVTADR,
			  RECDSC)
    THEN
	RETURN;
!
! Add event to record.  If this fails then just return.  The error message
! information will already be set up in the message block.
!
    IF NOT NML$ADDEVENTS (TRUE, RECDSC, .SNK, .SNKADR, UPDFLG)
    THEN
	RETURN;

    IF NOT .UPDFLG
    THEN
	BEGIN

	NML$AB_MSGBLOCK [MSB$L_FLAGS] = MSB$M_MSG_FLD;
	NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_MPR;
	NML$AB_MSGBLOCK [MSB$L_TEXT]  = NML$_BADEVTUPD;
	RETURN;

	END;
!
! If event field was added successfully, then update the volatile data base.
!
    DB = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$B_DATABASE];
    SRCHKEY1 = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$L_SRCH_ID1];
    SRCHKEY2 = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$L_SRCH_ID2];
    TABDES = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$A_ALLTAB]; ! Table for SET
!
! Build the QIO buffer.
!
    NML$BLDALLDES (RECDSC, .TABDES);
    NML$BLDSETQBF (NFB$C_FC_SET, .DB, 
			.SRCHKEY1, 0, SNKADR,
			.SRCHKEY2, -1, 0,
			NML$Q_NFBBFDSC, NFBDSC,
			NML$Q_P2BFDSC, P2DSC,
			NML$GQ_QIOBFDSC, QBFDSC);
!
! Set the event information into the volatile data base.
!
    IF NML$NETQIO (NFBDSC, P2DSC, 0, QBFDSC)
    THEN
	BEGIN

	NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
	NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_SUC;

	END;

    RETURN;

    END;				! End of NML_SETLOGGING

%SBTTL 'NML_SETLOGALL  Set all logging parameters'
ROUTINE NML_SETLOGALL (SNK) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets all permanent parameters for the specified
!	logging sink type into the volatile data base.
!
!--

BEGIN

LOCAL
    DB,				! Database ID
    SRCHKEY1,			! Search key one ID
    SRCHKEY2,			! Search key two ID
    SINK_NODE_PTR,		! Pointer to sink node address in NICE message.
    SINK_NODE_ADD,		! Sink node address from NICE message.
    SINK_NODE_LEN,		! Length of sink node address (2).
    FID,			! File id code
    KEY,
    OWNER,			! Search key
    NFBDSC : DESCRIPTOR,	! NFB buffer descriptor
    P2DSC  : DESCRIPTOR,	! QIO P2 buffer descriptor
    QBFDSC : DESCRIPTOR,	! QIO P4 buffer descriptor
    RECDSC : DESCRIPTOR,	! Record descriptor
    SETDSC : DESCRIPTOR,	! Event parameter descriptor
    STATUS,
    TABDES : REF DESCRIPTOR,	! Table for SET ALL
    EXEC_ADDRESS;		! Address of executor node.
!
! Get entity information.
!
DB     = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$B_DATABASE];
SRCHKEY1= .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$L_SRCH_ID1];
SRCHKEY2= .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$L_SRCH_ID2];
FID    = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$B_FILEID];
OWNER  = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$W_KEY];
TABDES = .NML$AB_ENTITYDATA [NML$C_LOGGING, EIT$A_ALLTAB];
!
! The logging database is broken up into two databases -
!	- the Filter database (EFI) uses event filters to determine whether
!	  or not a locally generated event is being logged and what sink
!	  node to send it to for logging. 
!	- the Sink database (ESI) is used by the sink node receiving the event
!	  to determine if the sink type (file, console, monitor) is logging
!	  events (sink state = on).
!
! First, set the Sink database
!
IF NOT NML_SETENTITY (NML$C_SINK, 1, SNK, 0, 0, 0) THEN
    RETURN;
!
! Now set the Filter database parameters. 
! At this point, it is assumed that the logging permanent data base file
! is open.
!
STATUS = NML$_STS_SUC;			! Initialize status
KEY = 0;				! Start at beginning of file
NML$GETEXEADR (EXEC_ADDRESS);
!
! Search through the logging file for entries in the Filter database.
! There is one entry for each sink node.  From each sink node's entry,
! extract all the event filters for the sink type currently being set.
! Then issue a QIO to NETACP to set the events for the sink node and
! sink in the volatile database.
!
WHILE NML$MATCHRECORD (.FID,
			NML$GQ_RECBFDSC,
			KEY,
			.OWNER,
			0, 0,	! No entity length or id.
			0, 0, 0,	! No qualifier
			RECDSC) DO
    BEGIN
    !
    ! Get the record owner.  In the case of the logging filter database,
    ! this is the sink node address.
    !
    SINK_NODE_PTR = 0;
    STATUS = NMA$SEARCHFLD (RECDSC, .OWNER, SINK_NODE_LEN, SINK_NODE_PTR);
    !
    ! If no sink node address was found in the record then something is
    ! wrong with this record in the file.
    !
    IF NOT .STATUS THEN
	BEGIN
	NML$AB_MSGBLOCK [MSB$L_FLAGS]  = MSB$M_DET_FLD OR MSB$M_MSG_FLD;
	NML$AB_MSGBLOCK [MSB$B_CODE]   = NMA$C_STS_FCO;
	NML$AB_MSGBLOCK [MSB$W_DETAIL] = NMA$C_FOPDTL_PDB;
	NML$AB_MSGBLOCK [MSB$L_TEXT]   = NML$_NOSNKNOD;
	RETURN;
	END;
    !
    ! Find event parameter in record.  If it is not found then skip this
    ! record.
    !
    SETDSC [DSC$A_POINTER] = 0;
    STATUS = NMA$SEARCHFLD (RECDSC,
			    NMA$C_PCLO_EVE,
			    SETDSC [0,0,32,0],
			    SETDSC [DSC$A_POINTER]);
    IF .STATUS THEN
	!
	! Build QIO buffer to tell NETACP what filters to put into the logging
	! database for this sink node.
	!
	BEGIN
	!
	! If the sink node address in the permanent database record is zero,
	! then the sink node is the executor.  Find out the executor's real
	! address, and use that to specify the sink node to NETACP.
	!
	SINK_NODE_ADD = .(.SINK_NODE_PTR)<0,16>;
	IF .SINK_NODE_ADD EQL 0 THEN
	    SINK_NODE_ADD = .EXEC_ADDRESS;
	IF NML_ADDALLFIL (RECDSC, SETDSC, .SNK, .SINK_NODE_ADD) THEN
	    BEGIN
            NML$BLDALLDES (RECDSC, .TABDES); ! Build parameter descriptors
	    NML$BLDSETQBF (NFB$C_FC_SET, .DB, 
			   .SRCHKEY1, 0, SINK_NODE_ADD,
			   .SRCHKEY2, -1, 0,
			   NML$Q_NFBBFDSC, NFBDSC,
			   NML$Q_P2BFDSC, P2DSC,
			   NML$GQ_QIOBFDSC, QBFDSC);
	    !
	    ! Add the parameters to volatile data base entry.
	    !
            STATUS = NML$NETQIO (NFBDSC, P2DSC, 0, QBFDSC);
	    IF NOT .STATUS THEN
		EXITLOOP;
	    END;
	END
    ELSE
	STATUS = NML$_STS_SUC;		! Reset return status

    KEY = .KEY + 1;			! Increment record key
    END;
!
! If the operation was successful then set up the successful response 
! message.
!
IF .STATUS THEN
    BEGIN
    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
    NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_SUC;
    END;

END;				! End of NML_SETLOGALL

%SBTTL 'NML_ADDALLFIL  Add all logging filters'
ROUTINE NML_ADDALLFIL (RECDSC, SETDSC, SNK, SNKADR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds all permanent filters to the volatile filters
!	for the specified sink type and sink node.
!
! FORMAL PARAMETERS:
!
!	RECDSC		Descriptor of permanent data base record.
!	SETDSC		Descriptor of existing event parameter.
!	SNK		Logging sink type.
!	SNKADR		Sink node address.
!
! IMPLICIT INPUTS:
!
!	NML$GB_EVTMSKTYP .
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	RECDSC : REF DESCRIPTOR,
	SETDSC : REF DESCRIPTOR,
	SNKADR : WORD;

    LOCAL
	DUMDSC : REF DESCRIPTOR,
	ENTDSC : DESCRIPTOR,
	EVEDSC : DESCRIPTOR,
	EVTPTR : REF BBLOCK,
	NFBDSC : REF DESCRIPTOR,
	P2DSC  : DESCRIPTOR,
	SRCPTR : REF BBLOCK,
	STATUS;

!
! If there is an entry in the volatile data base then update it with the
! permanent data base information.  If no entry exists then create one.
!
    !
    ! Get the sink's entry in the volatile data base, if there is one.
    !
    NML$GETINFTABS (NML$C_LOGGING, NML$C_EVENTS, NFBDSC, DUMDSC, 0);
    NML$BLDP2 (0, .SNKADR, -1, 0, NML$Q_P2BFDSC, P2DSC);
    STATUS = NML$NETQIO (.NFBDSC, P2DSC, 0, NML$GQ_QIOBFDSC);

    IF .STATUS
    THEN
	BEGIN
	!
	! Convert the volatile data base information into permanent data
	! base format.  The filters from the permanent data base will be
	! added to this.
	!
	EVEDSC [DSC$W_LENGTH] = .(.NML$GQ_QIOBFDSC [DSC$A_POINTER])<0,16>;
	EVEDSC [DSC$A_POINTER] = NML$T_PRMBUFFER;

	CH$MOVE (.EVEDSC [DSC$W_LENGTH],
		 .NML$GQ_QIOBFDSC [DSC$A_POINTER] + 2,
		 NML$T_PRMBUFFER);
	END
    ELSE
	BEGIN

	IF .STATUS EQL NML$_STS_CMP
	THEN
	    BEGIN
	    !
	    ! Since there was no entry for the sink in the volatile data base,
	    ! create a null permanent data base entry to which the filters
	    ! from the permanent data base will be added.
	    !
	    EVEDSC [DSC$W_LENGTH] = 0;
	    EVEDSC [DSC$A_POINTER] = NML$T_PRMBUFFER;

	    END
	ELSE
	    RETURN .STATUS;

	END;
!
! Now go through the permenent data base record for this sink node and
! add the sink's filters to the volatile data base filters (which are now
! in permanent data base format).
!
    STATUS = NML$_STS_PMS;
    SRCPTR = 0;
    WHILE NML$GETNXTSNK (.SETDSC, .SNK, SRCPTR) DO
	BEGIN
	STATUS = NML$_STS_SUC;		! At least one new filter was found for
					! sink.
!
! Each event source type is handled differently.
!
	SELECTONEU .SRCPTR [SRC$B_SRCTYPE] OF
	    SET

	    [NMA$C_ENT_CIR, NMA$C_ENT_LIN,	! Circuit, Line or
	     NMA$C_ENT_MOD]:			!	Module source
		BEGIN
		ENTDSC [DSC$W_LENGTH] = .SRCPTR [SRC$B_IDLENGTH];
		ENTDSC [DSC$A_POINTER] = SRCPTR [SRC$T_ID];
		END;

	    [NMA$C_ENT_NOD]:		! Node source
		BEGIN
		ENTDSC [DSC$W_LENGTH] = 0;
		ENTDSC [DSC$A_POINTER] = .SRCPTR [SRC$W_NODADR];
		END;

	    [OTHERWISE]:		! Null source
		BEGIN
		ENTDSC [DSC$W_LENGTH] = 0;
		ENTDSC [DSC$A_POINTER] = 0;
		END;
	    TES;

	NML$GB_EVTMSKTYP = 0;		! Set to add individual filters
	EVTPTR = 0;
	WHILE NML$GETNXTEVT (.SRCPTR, EVTPTR) DO
	    BEGIN
!
! Add all the SET filters.
!
	    STATUS = NML$ADDFILTERS (1,
				     NML$Q_PRMBFDSC,
				     .SNK,
				     .SRCPTR [SRC$B_SRCTYPE],
				     ENTDSC,
				     .EVTPTR [EVT$W_CLASS],
				     8,
				     EVTPTR [EVT$Q_LOGMSK],
				     EVEDSC);
!
! If that was successful then add all the CLEAR filters.
!
	    IF .STATUS
	    THEN
		STATUS = NML$ADDFILTERS (0,
					 NML$Q_PRMBFDSC,
					 .SNK,
					 .SRCPTR [SRC$B_SRCTYPE],
					 ENTDSC,
					 .EVTPTR [EVT$W_CLASS],
					 8,
					 EVTPTR [EVT$Q_FILTERMSK],
					 EVEDSC);
	    IF NOT .STATUS
	    THEN
		BEGIN

		NML$AB_MSGBLOCK [MSB$L_FLAGS] = MSB$M_MSG_FLD;
		NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_MPR;
		NML$AB_MSGBLOCK [MSB$L_TEXT]  = NML$_BADEVTUPD;
		RETURN .STATUS;

		END;
	    END;
	END;
!
! If the permanent data base filter record contained at least one event
! filter for the sink,
! store the modified filters in the temporary data base record.  If there
! were no filters for the sink, no update will be done to the volatile
! data base.
!
    IF .STATUS THEN
	STATUS = NML$SAVEVENTS (.NML$GQ_RECBFDSC [DSC$W_LENGTH],
			    .EVEDSC [DSC$W_LENGTH],
			    .EVEDSC [DSC$A_POINTER],
			    .RECDSC);
    RETURN .STATUS
    END;				! End of NML_ADDALLFIL

%SBTTL 'NML_SETENTITY  Set volatile database parameters'
ROUTINE NML_SETENTITY (ENTITY, ENTITY_LEN, ENTITY_ADR,
			QUAL_PST, QUAL_LEN, QUAL_ADR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the specified parameters to the volatile data base
!	entry for the specified component.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	ENTITY_LEN	Byte count of entity id string.
!	ENTITY_ADR	Address of entity id string.
!	QUAL_PST	Qualifier's Parameter Semantic Table entry address.
!	QUAL_LEN	Byte count of qualifier id string
!	QUAL_ADR	Address of qualifier id string
!	
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The translated status of the SET QIO is returned.
!--

BEGIN

LOCAL
    db,					! Database ID 
    srchkey1,				! Search key one ID
    srchkey2,				! Search key two ID
    detail : WORD,			! NICE error detail code
    fid,				! File id code
    key,
    owner,				! Search key
    nfbdsc : DESCRIPTOR,		! NFB buffer descriptor
    p2dsc  : DESCRIPTOR,		! QIO P2 buffer descriptor
    qbfdsc : DESCRIPTOR,		! QIO P4 buffer descriptor
    recdsc : DESCRIPTOR,		! Record descriptor
    status,
    dummy,
    tabdes : REF DESCRIPTOR;

status = nml$_sts_suc;
!
! Get entity information.
!
db      = .nml$ab_entitydata [.entity, eit$b_database];! Database ID
srchkey1 = .nml$ab_entitydata [.entity, eit$l_srch_id1]; ! Search key one
srchkey2 = .nml$ab_entitydata [.entity, eit$l_srch_id2]; ! Search key two
detail  = .nml$ab_entitydata [.entity, eit$w_detail]; ! NICE error detail
fid     = .nml$ab_entitydata [.entity, eit$b_fileid]; ! File id code
owner   = .nml$ab_entitydata [.entity, eit$w_key];    ! Search key
tabdes  = .nml$ab_entitydata [.entity, eit$a_alltab]; ! Table for SET ALL
!
! If no parameters were specified in the NICE message then all parameters
! from the permanent data base should be used.
!
IF .nml$gl_prs_flgs [nml$v_prs_all] THEN
    BEGIN
    !
    ! Find a permanent data base entry for this entity.  If one is not
    ! found then create a descriptor for a null record.
    !
    IF .fid NEQ nma$c_opn_node THEN
	BEGIN
	key = 0;
	IF NOT nml$matchrecord (.fid,
			    nml$gq_recbfdsc,
			    key,
			    .owner, .entity_len, .entity_adr,
			    .qual_pst, .qual_len, .qual_adr,
			    recdsc) THEN
	    BEGIN
	    !
	    ! If no data base record was found for a logging sink then
	    ! just return.  This check avoids extraneous error messages
	    ! as the result of the NCP SET KNOWN LOGGING ALL command.
	    !
	    IF .entity EQLU nml$c_sink THEN
		RETURN nml$_sts_suc;
	    !
	    ! NICE does not differentiate between
	    !		SET entity abc
	    !		   and
	    !		SET entity abc ALL
	    ! However, some entities require at least one other parameter
	    ! (objects must have a number).  So, for entities with are not in
	    ! the perm database, assume that it's simply a SET command unless
	    ! the entity has a required parameter.
	    !
	    IF .entity EQLU nml$c_object THEN
		status = nml$_sts_cmp;
	    recdsc [dsc$w_length]  = 0;
	    recdsc [dsc$a_pointer] = .nml$gq_recbfdsc [dsc$a_pointer] +
						nml$k_perm_keys_len;
	    END;
	!
	! If entity is X25-Protocol network, no entity ID was supplied with the
	! NICE command.  So, get the network name from the permanent data
	! base record, and set it up as the entity ID for the QIO.
	!
	IF .entity EQLU nml$c_prot_net THEN
	    status = nma$searchfld (recdsc, .owner, entity_len, entity_adr);
	END
    ELSE
	!
	! The ISAM key structure for the node permanent database is different
	! so it will be faster (it can be much bigger than the others).
	!
	BEGIN
	IF NOT nml$readrecord (.fid, owner, entity_len, 
			    nml$gq_recbfdsc, recdsc, dummy) THEN
	    status = nml$_sts_cmp;
	END;
    !
    ! Using the SET ALL parameter list (in NMLDAT) for this entity, build
    ! the a parameter descriptor list in the form generated by the NPARSE
    ! tables.
    !
    IF .status THEN
	nml$bldalldes (recdsc, .tabdes); ! Build descriptors
    END;

IF .status EQL nml$_sts_cmp THEN
    BEGIN
    nml$ab_msgblock [msb$l_flags]  = msb$m_det_fld;
    nml$ab_msgblock [msb$w_detail] = .detail;
    nml$ab_msgblock [msb$b_code] = nma$c_sts_cmp;
    RETURN nml$_sts_cmp;
    END;
IF .status THEN
    BEGIN
    !
    ! Add the parameters to volatile data base entry.
    !
    nml$bldsetqbf (nfb$c_fc_set, .db, 
		   .srchkey1, .entity_len, .entity_adr,
		   .srchkey2, .qual_len, .qual_adr,
		   nml$q_nfbbfdsc, nfbdsc,
		   nml$q_p2bfdsc, p2dsc,
		   nml$gq_qiobfdsc, qbfdsc);
    status = nml$netqio (nfbdsc, p2dsc, 0, qbfdsc);
    IF .status THEN
	BEGIN
	nml$ab_msgblock [msb$l_flags] = 0;
	nml$ab_msgblock [msb$b_code] = nma$c_sts_suc;
	END;
    END;
RETURN .status
END;				! End of NML_SETENTITY

%SBTTL 'NML$SETLINE  Set volatile line parameters'
GLOBAL ROUTINE NML$SETLINE (ENTITY, LEN, ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the specified parameters to the volatile data base
!	entry for the specified line.  This routine will eventually provide
!	support for wildcards in the line id.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	LEN		Byte of line id string.
!	ADR		Address of line id string.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
!
! Call normal entity routine to handle line parameters.
!
    NML$SETENTITY (.ENTITY, .LEN, .ADR);

    END;				! End of NML$SETLINE

%SBTTL 'NML$SETEXECUTOR  Set executor parameters'
GLOBAL ROUTINE NML$SETEXECUTOR (ENTITY, DUM1, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the specified parameters to the volatile data base
!	entry for the executor node.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity code.
!	DUM1		Not used.
!	DUM2		Not used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
!
! If no parameters were specified in the NICE message then all parameters
! from the permanent data base should be used.
!
    IF .NML$GL_PRS_FLGS [NML$V_PRS_ALL]
    THEN
	NML_SETEXEALL ()
    ELSE
	NML_SETEXE ();

    END;				! End of NML$SETEXECUTOR

%SBTTL 'NML$SETKNOWN  Set volatile entity parameters'
GLOBAL ROUTINE NML$SETKNOWN (ENTITY, ENTITY_LEN, ENTITY_ADR,
				DUM3, DUM4, DUM5) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets the specified parameters for each of the components
!	of the given entity type.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	ENTITY_LEN	Byte count of entity id string.
!	ENTITY_ADR	Address of entity id string.
!	DUM3 - DUM5	Not used.
!
!--

BEGIN
!
! If this no parameters specified then add all permanent data base information
! to volatile data base.
!
IF .NML$GL_PRS_FLGS [NML$V_PRS_ALL]
THEN
	NML_SETKNOWNALL (.ENTITY, .ENTITY_LEN, .ENTITY_ADR)
ELSE
	NML_SETKNOWN (.ENTITY);

END;				! End of NML$SETKNOWN


%SBTTL 'NML$SETKNONODES  Set volatile node parameters'
GLOBAL ROUTINE NML$SETKNONODES (ENTITY, DUM1, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets the specified parameters for each of the nodes.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	DUM1		Not used.
!	DUM2		Not used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
!
! If this no parameters specified then add all permanent data base information
! to volatile data base.
!
    IF .NML$GL_PRS_FLGS [NML$V_PRS_ALL]
    THEN
	BEGIN
	NML_SETEXEALL ();
	NML_SETKNOWNALL (NML$C_NODE);
	NML_SETKNOWNALL (NML$C_LOOPNODE);

	END
    ELSE
	BEGIN
	NML_SETEXE ();
	NML_SETKNOWN (NML$C_NODE);

	END;

    END;				! End of NML$SETKNONODES


%SBTTL 'NML_SETKNOWN  Set volatile entity parameters'
ROUTINE NML_SETKNOWN (ENTITY) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets the specified parameters for each of the components
!	of the given entity type.
!
! INPUTS:
!
!	ENTITY		Entity type code.
!
!--

BEGIN

LOCAL
    BUFEND,
    DB,				! Database ID
    SRCHKEY1,			! Search key one ID
    SRCHKEY2,			! Search key two ID
    ENTITYADD,
    ENTITYLEN,
    LISDSC   : DESCRIPTOR,
    MSGSIZE,
    ENTIDPTR,
    PTR,
    NFBDSC   : DESCRIPTOR,		! NFB buffer descriptor
    P2DSC    : DESCRIPTOR,		! QIO P2 buffer descriptor
    QBFDSC   : DESCRIPTOR,		! QIO P2 buffer descriptor
    STATUS,
    STRTFLG;
!
! Build QIO buffer.
!
DB      = .NML$AB_ENTITYDATA [.ENTITY, EIT$B_DATABASE]; ! Database ID
SRCHKEY1 = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_SRCH_ID1];  ! Search key one
SRCHKEY2 = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_SRCH_ID2];  ! Search key two
!
! Process every entry in the data base.
!
! The NICE protocol specifies that, for multiple entity changes, one NICE
! response message must be returned to NCP for each entity changed.  Each
! message must contain the ID of the entity changed.  Therefore, the following
! loop issues one QIO to the ACP to get a bufferfull of entity IDs, and then
! issues one QIO for each entity in the buffer to perform the set.  This
! process continues until the ACP returns end-of-file to the request for more
! entity IDs.
!
STRTFLG = FALSE;
WHILE NML$GET_ENTITY_IDS (.ENTITY, NMA$C_ENT_KNO, 0, .STRTFLG, LISDSC) DO
    BEGIN

    STRTFLG = TRUE;

    BUFEND = .LISDSC [DSC$A_POINTER] + .LISDSC [DSC$W_LENGTH];
    PTR = .LISDSC [DSC$A_POINTER];

    WHILE .PTR LSSA .BUFEND DO
	BEGIN

	ENTIDPTR = NML$T_ENTBUFFER;
	NML$Q_ENTBFDSC [DSC$W_LENGTH] = NML$K_ENTBUFLEN;
	!
	! Entity IDs for the ACP are different from those used by NICE.  The
	! most common cause of this is that the ACP uses a word for the entity
	! string length, and NICE uses a byte.  The following code sets up the
	! two ID forms: the NICE entity ID for the response to NCP
	!		the ACP entity ID to be used in the P2 buffer of the
	!			clear QIO.
	!
	SELECTONEU .ENTITY OF
	    SET
	    [NML$C_NODE]:
		BEGIN

		PTR = .PTR + 4; ! Skip loopnode flag.
		ENTITYADD = .PTR;	! Point to node address
		ENTIDPTR = CH$MOVE (2, .PTR, .ENTIDPTR);
		PTR = .PTR + 4;

		ENTITYLEN = .(.PTR)<0,8>; ! Get name length
		PTR = .PTR + 2;
		CH$WCHAR_A (.ENTITYLEN, ENTIDPTR);
		ENTIDPTR = CH$MOVE (.ENTITYLEN, .PTR, .ENTIDPTR);
		PTR = .PTR + .ENTITYLEN;
		ENTITYLEN = 2;	! Get length of node address
		END;

	    !
	    ! The entity ID for the following modules is the string
	    ! identifying the module (e.g. 'X25-PROTOCOL') followed by the
	    ! parameter id, parameter type, and string for the qualifier
	    ! being set.
	    !
	    [NML$C_X25_ACCESS,
	    NML$C_PROT_NET,
	    NML$C_PROT_DTE,
	    NML$C_PROT_GRP,
	    NML$C_X25_SERV_DEST,
	    NML$C_TRACEPNT,
	    NML$C_X29_SERV_DEST]:
		BEGIN
		SELECTONEU .ENTITY OF
		    SET
		    [NML$C_X25_ACCESS]:
			$MOVE_ASCIC ('X25-ACCESS', ENTIDPTR);
	    	    [NML$C_PROT_NET, NML$C_PROT_DTE, NML$C_PROT_GRP]:
			$MOVE_ASCIC ('X25-PROTOCOL', ENTIDPTR);
		    [NML$C_X25_SERV_DEST]:
			$MOVE_ASCIC ('X25-SERVER', ENTIDPTR);
	    	    [NML$C_TRACEPNT]:
			$MOVE_ASCIC ('X25-TRACE', ENTIDPTR);
		    [NML$C_X29_SERV_DEST]:
			$MOVE_ASCIC ('X29-SERVER', ENTIDPTR);
		    TES;
		ENTIDPTR = CH$MOVE (2,
				NML$AB_ENTITYDATA [.ENTITY, EIT$W_DETAIL],
				.ENTIDPTR);
		CH$WCHAR_A (NMA$M_PTY_ASC, ENTIDPTR);
		END;

	    TES;

	IF .ENTITY NEQ NML$C_NODE THEN
		BEGIN
		ENTITYLEN = .(.PTR)<0,16>;
		PTR = .PTR + 2;
		ENTITYADD = .PTR;
		CH$WCHAR_A (.ENTITYLEN, ENTIDPTR);
		ENTIDPTR = CH$MOVE (.ENTITYLEN,
				.ENTITYADD,
				.ENTIDPTR);
		PTR = .PTR + .ENTITYLEN;
		END;

	NML$Q_ENTBFDSC [DSC$W_LENGTH] = .ENTIDPTR - NML$T_ENTBUFFER;
	!
	! Add the parameters to volatile data base entry.
	!
	NML$BLDSETQBF (NFB$C_FC_SET, .DB, 
			.SRCHKEY1, .ENTITYLEN, .ENTITYADD,
			.SRCHKEY2, -1, 0,
			NML$Q_NFBBFDSC, NFBDSC,
			NML$Q_P2BFDSC, P2DSC,
			NML$GQ_QIOBFDSC, QBFDSC);

	IF NML$NETQIO (NFBDSC, P2DSC, 0, QBFDSC)
	THEN
	    BEGIN

	    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
	    NML$AB_MSGBLOCK [MSB$B_CODE] = NMA$C_STS_SUC;

	    END;
	!
	! Add the entity identification to the message.
	!
	NML$AB_MSGBLOCK [MSB$V_ENTD_FLD] = 1;
	NML$AB_MSGBLOCK [MSB$A_ENTITY] = NML$Q_ENTBFDSC;
	!
	! Build and send the response message.
	!
	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	NML$SEND (NML$AB_SNDBUFFER, .MSGSIZE);
	END;
    END;

END;				! End of NML_SETKNOWN


%SBTTL 'NML_SETKNOWNALL  Set volatile database parameters'
ROUTINE NML_SETKNOWNALL (ENTITY, ENTITY_LEN, ENTITY_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets all permanent parameters for the specified
!	entity type into the volatile data base.
!
! INPUTS:
!
!	ENTITY		Entity type code.
!	ENTITY_LEN	Byte count of entity id string.
!	ENTITY_ADR	Address of entity id string.
!
!--

BEGIN

LOCAL
    bufend,
    db,					! Database ID
    srchkey1,				! Search key one ID
    srchkey2,				! Search key two ID
    entityadd,
    entitylen,
    fid,				! File id code
    fldadr,
    fldsize,
    key,
    qual_len,
    qual_adr,
    msgsize,
    owner,				! Search key
    nfbdsc   : DESCRIPTOR,		! NFB buffer descriptor
    p2dsc    : DESCRIPTOR,		! QIO P2 buffer descriptor
    qbfdsc   : DESCRIPTOR,		! QIO P2 buffer descriptor
    recdsc : DESCRIPTOR,		! Record descriptor
    status,
    rewind_flag,			! Used for node database only.  Set at
					!	at the beginning of an operation.
    tabdes : REF DESCRIPTOR;		! Table for SET ALL

!
! Get entity information.
!
db      = .nml$ab_entitydata [.entity, eit$b_database]; ! Database ID
srchkey1 = .nml$ab_entitydata [.entity, eit$l_srch_id1];! Search key one
srchkey2 = .nml$ab_entitydata [.entity, eit$l_srch_id2];! Search key two
fid     = .nml$ab_entitydata [.entity, eit$b_fileid]; 	! File id code
owner   = .nml$ab_entitydata [.entity, eit$w_key];	! Search key
tabdes  = .nml$ab_entitydata [.entity, eit$a_alltab];	! Table for SET ALL

key = 0;
status = nml$_sts_suc;
rewind_flag = true;
!
! Keep looking for records in the permanent database which match the entity
! being SET.  For each one found, build QIO buffers containing all the
! parameters in the permanent data base record, and issue the SET to the ACP.
! Note that the entity information passed to NML$MATCHRECORD is normally
! zeros.  It is non zero for commands such as
!	SET X25-PROTOCOL GROUP XYZ ALL
! which, although it is a single entity, has one record for each DTE assigned
! to the group.  Therefore, it is a multiple QIO operation.
!
WHILE .status DO
    BEGIN
    !
    ! The structure of the node permanent database is different from the
    ! others because it can be much bigger and therefore needs to be faster.
    !
    IF .fid NEQ nma$c_opn_node THEN
	status = nml$matchrecord (.fid, nml$gq_recbfdsc, key,
				.owner, .entity_len, .entity_adr,
				0, 0, 0,
				recdsc)
    ELSE
	BEGIN
	status = nml$read_known_node_rec (.entity, nml$gq_recbfdsc,
					recdsc, .rewind_flag);
	rewind_flag = false;
	END;
    IF .status THEN
	BEGIN
	nml$ab_msgblock [msb$b_code] = 0; ! Reset status code
	!
	! Get entity id.
	!
	entityadd = 0;
	status = nma$searchfld (recdsc, .owner, entitylen, entityadd);
	!
	! Get entity id for SET QIO and id string for response message.
	!
	SELECTONEU .entity OF
	    SET
	    [nml$c_loopnode]:
		BEGIN
		!
		! Id for loop node is node name.
		!
		entityadd = 0;
		status = nma$searchfld (recdsc, nma$c_pcno_nna,
					entitylen, entityadd);
		END;

	    [nml$c_prot_grp]:
		!
		! Get the DTE ID from the Group record just read.  The DTE
		! is the second search key ID for the SET QIO.
		!
		BEGIN
		qual_adr = 0;		! Search from beginning of record.
		status = nma$searchfld (recdsc, nma$c_pcxp_gdt,
					qual_len, qual_adr);
		END;
	    TES;
	END;
    IF .status THEN
	BEGIN
	!
	! Build QIO buffer.
	!
	nml$bldalldes (recdsc, .tabdes); ! Build parameter descriptors
	nml$bldsetqbf (nfb$c_fc_set, .db, 
			.srchkey1, .entitylen, .entityadd,
			.srchkey2, .qual_len, .qual_adr,
			nml$q_nfbbfdsc, nfbdsc,
			nml$q_p2bfdsc, p2dsc,
			nml$gq_qiobfdsc, qbfdsc);
	!
	! Add the parameters to volatile data base entry.
	!
	IF nml$netqio (nfbdsc, p2dsc, 0, qbfdsc) THEN
	    BEGIN
	    nml$ab_msgblock [msb$l_flags] = 0;
	    nml$ab_msgblock [msb$b_code] = nma$c_sts_suc;
	    END;
	!
	! Add the entity identification to the response message.
	!
	nml$q_entbfdsc [dsc$w_length] = nml$k_entbuflen;
	nml$getrecowner (recdsc,
			.entity,
			nml$q_entbfdsc, 
			nml$q_entbfdsc [dsc$w_length]);

	nml$ab_msgblock [msb$v_entd_fld] = 1;
	nml$ab_msgblock [msb$a_entity] = nml$q_entbfdsc;
	!
	! Build and send the response message.
	!
	nml$bld_reply (nml$ab_msgblock, msgsize);
	nml$send (nml$ab_sndbuffer, .msgsize);
	END;
    key = .key + 1;			! Increment record key
    END;

END;				! End of NML_SETKNOWNALL

%SBTTL 'NML_SETEXE  Set executor parameters'
ROUTINE NML_SETEXE : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the specified parameters to the volatile data base
!	entry for the executor node.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	DB,				! Database ID
	SRCHKEY1,			! Search key one ID
	SRCHKEY2,			! Search key two ID
	ENTITYADD,
	ENTITYLEN,
	MSGSIZE,
	NODADDR,
	NFBDSC   : DESCRIPTOR,		! NFB buffer descriptor
	P2DSC    : DESCRIPTOR,		! QIO P2 buffer descriptor
	QBFDSC   : DESCRIPTOR;		! QIO P2 buffer descriptor

!
! Add the entity identification to the message.
!
NML$GETEXEID (NML$Q_ENTBFDSC, NML$Q_ENTBFDSC [DSC$W_LENGTH]);
NML$AB_MSGBLOCK [MSB$V_ENTD_FLD] = 1;
NML$AB_MSGBLOCK [MSB$A_ENTITY] = NML$Q_ENTBFDSC;

!
! If executor specific parameters, use the local node database,
! otherwise, use the node database.
!
SRCHKEY2 = NFB$C_WILDCARD;
IF .NML$GL_PRS_FLGS [NML$V_PRS_EXEPG]
    THEN
	BEGIN

	DB = NFB$C_DB_LNI; 
	SRCHKEY1 = NFB$C_WILDCARD;
	ENTITYLEN = -1;				! No id necessary for
	ENTITYADD = 0;				!  executor parameters

	END
    ELSE
	BEGIN

	DB = NFB$C_DB_NDI;
	SRCHKEY1 = NFB$C_NDI_ADD;
	NODADDR = 0;				! Zero node address
	ENTITYLEN = 2;
	ENTITYADD = NODADDR;

	END;

  NML$BLDSETQBF (NFB$C_FC_SET, .DB, 
		.SRCHKEY1, .ENTITYLEN, .ENTITYADD,
		.SRCHKEY2, -1, 0,
		NML$Q_NFBBFDSC, NFBDSC,
		NML$Q_P2BFDSC,  P2DSC,
		NML$GQ_QIOBFDSC, QBFDSC);
!
! Add the parameters to volatile data base entry.
!
IF NML$NETQIO (NFBDSC, P2DSC, 0, QBFDSC) THEN
    BEGIN
    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
    NML$AB_MSGBLOCK [MSB$B_CODE] = NMA$C_STS_SUC;
    END;
!
! Build and signal the response message.
!
NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
NML$SEND (NML$AB_SNDBUFFER, .MSGSIZE);

END;				! End of NML_SETEXE

%SBTTL 'NML_SETEXEALL  Set all executor parameters'
ROUTINE NML_SETEXEALL : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets all executor parameters from the permanent data base
!	into the volatile data base.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	This routine assumes the node data base file is open.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

LOCAL
    exeadr,
    fid,
    key,
    msgsize,
    nfbdsc   : DESCRIPTOR,		! NFB buffer descriptor
    p2dsc    : DESCRIPTOR,		! QIO P2 buffer descriptor
    qbfdsc   : DESCRIPTOR,		! QIO P2 buffer descriptor
    recdsc   : DESCRIPTOR,
    dummy,
    status;
!
! Read executor node record.  If one does not exist then create a
! descriptor for a null record.
!
key = .nml$ab_entitydata [nml$c_executor, eit$w_key];
IF NOT nml$readrecord (nma$c_opn_node,
			key,
			UPLIT (nmn$c_typ_key_len,
				UPLIT (nml$c_executor)),
			nml$gq_recbfdsc,
			recdsc,
			dummy) THEN
    BEGIN
    recdsc [dsc$w_length]  = 0;
    recdsc [dsc$a_pointer] = .nml$gq_recbfdsc [dsc$a_pointer] +
				nmn$c_node_keys_len;
    END;
!
! Build a parameter descriptor for each parameter that is set in the record
! and set it in the volatile data base.
!
nml$bldalldes (recdsc,
	   .nml$ab_entitydata [nml$c_executor, eit$a_alltab]);
nml$bldsetqbf (nfb$c_fc_set, nfb$c_db_lni, 
		nfb$c_wildcard, -1, 0,
		nfb$c_wildcard, -1, 0,
		nml$q_nfbbfdsc, nfbdsc,
		nml$q_p2bfdsc, p2dsc,
		nml$gq_qiobfdsc, qbfdsc);
status = nml$netqio (nfbdsc, p2dsc, 0, qbfdsc);
!
! If the first operation was successful then repeat the operation for the
! parameters that the executor has in common with remote nodes.  Otherwise
! send an error response message.
!
IF .status THEN
    BEGIN
    nml$bldalldes (recdsc, .nml$ab_entitydata [nml$c_node, eit$a_alltab]);
    exeadr = 0;
    nml$bldsetqbf (nfb$c_fc_set, nfb$c_db_ndi, 
			nfb$c_ndi_add, 0, exeadr,
			nfb$c_wildcard, -1, 0,
			nml$q_nfbbfdsc, nfbdsc,
			nml$q_p2bfdsc, p2dsc,
			nml$gq_qiobfdsc, qbfdsc);

    IF nml$netqio (nfbdsc, p2dsc, 0, qbfdsc) THEN
	BEGIN
	nml$ab_msgblock [msb$l_flags] = 0;
	nml$ab_msgblock [msb$b_code] = nma$c_sts_suc; ! Successful
	END;
    END;
!
! Add the executor entity descriptor to the message.
!
nml$q_entbfdsc [dsc$w_length] = nml$k_entbuflen;
nml$getrecowner (recdsc,
		     nml$c_executor,
		     nml$q_entbfdsc, 
		     nml$q_entbfdsc [dsc$w_length]);

nml$ab_msgblock [msb$v_entd_fld] = 1;
nml$ab_msgblock [msb$a_entity] = nml$q_entbfdsc;
!
! Build and send the response message.
!
nml$bld_reply (nml$ab_msgblock, msgsize);
nml$send (nml$ab_sndbuffer, .msgsize);

END;				! End of NML_SETEXEALL

%SBTTL 'NML$SET_NI_CONFIG  Set Configurator Module volatile database parameters'
GLOBAL ROUTINE NML$SET_NI_CONFIG (ENTITY, ENTITY_LEN, ENTITY_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the permanent database for the Configurator
!	Module and builds NICE SET messages to set up the config volatile
!	database.  It forwards these messages to the Configurator
!	Module for processing.
!
! INPUTS:
!
!	ENTITY		Entity type code.
!	ENTITY_LEN	Byte count of entity id string.
!	ENTITY_ADR	Address of entity id string.
!
!--

BEGIN

LOCAL
	FID,				! File id code
	KEY,
	OWNER,				! Search key
	FLDSIZE,
	FLDADR,
	CPT_INDEX,
	PST_INDEX,
	RECDSC : DESCRIPTOR,		! Record descriptor
	STATUS,
	TABDES : REF DESCRIPTOR,	! Table for SET ALL
	PTR;
!
! If it's not a SET ALL command, simply forward the set command to the
! Configurator module for processing.
!
IF NOT .NML$GL_PRS_FLGS [NML$V_PRS_ALL] THEN
    BEGIN
    NML$CALL_NI_CONFIG ();
    RETURN;
    END;
!
! It's a SET ALL command.  Prepare to access the permanent database.
! Get entity information from Entity Table.
!
FID     = .NML$AB_ENTITYDATA [.ENTITY, EIT$B_FILEID]; ! File id code
OWNER   = .NML$AB_ENTITYDATA [.ENTITY, EIT$W_KEY];    ! Search key
TABDES  = .NML$AB_ENTITYDATA [.ENTITY, EIT$A_ALLTAB];

KEY = 0;
!
! For each circuit record in the permanent database, forward one SET command
! to the Configurator Module.
!
WHILE NML$MATCHRECORD (.FID, NML$GQ_RECBFDSC, KEY,
			.OWNER, .ENTITY_LEN, .ENTITY_ADR,
			0, 0, 0,
			RECDSC) DO
    !
    ! Build NICE message to forward to the Configurator Module.  Since
    ! I am processing a SET MODULE CONFIGURATOR ... ALL command, the
    ! function code, option byte, and entity ID (CONFIGURATOR) are already
    ! in the buffer.
    !
    BEGIN
    PTR = NML$AB_RCVBUFFER + 15;
    INCR I FROM 0 TO .TABDES [DSC$W_LENGTH] - 1 DO
	BEGIN

	BIND
	    TABLE = TABDES [DSC$A_POINTER] : REF BLOCK;

	FLDADR = 0;
	!
	! If the parameter in the SET ALL table is in the permanent database
	! record, add it to the NICE SET command.
	!
	IF NMA$SEARCHFLD (RECDSC,
			  .TABLE [.I, 0, 16, 0],
			  FLDSIZE,
			  FLDADR) THEN
	    BEGIN
	    !
	    ! Add the NICE parameter ID
	    !
	    PTR = CH$MOVE (2, TABLE [.I, 0, 16, 0], .PTR);
	    !
	    ! If it's a string, add the string length.  The PST table indicates
	    ! if it's a string.
	    !
	    CPT_INDEX = .TABLE [.I, 16, 16, 0];
	    PST_INDEX = .NML$AB_CPTABLE [.CPT_INDEX, CPT$W_PSTINDEX];
	    IF .NML$AB_PRMSEM [.PST_INDEX, PST$B_FORMAT] EQL NML$K_STRING THEN
	        CH$WCHAR_A (.FLDSIZE, PTR);
	    !
	    ! Add the parameter value to the SET command.
	    !
	    PTR = CH$MOVE (.FLDSIZE, .FLDADR, .PTR);
	    END;
	END;			      
    !
    ! Send the SET command to the Configurator Module.  It will put the
    ! circuit into it's database, and return a response, which
    ! NML$CALL_NI_CONFIG will then forward to NCP.
    !
    NML$GL_RCVDATLEN = .PTR - NML$AB_RCVBUFFER;
    NML$CALL_NI_CONFIG ();
    !
    ! If it's a SET ALL for one circuit, quit here.
    !
    IF .NML$GB_ENTITY_FORMAT NEQ (NMA$C_ENT_KNO AND %X'FF') THEN    
	EXITLOOP;
    KEY = .KEY + 1;			! Increment record key
    END;

END;				! End of NML$SET_NI_CONFIG

END					! End of module

ELUDOM
