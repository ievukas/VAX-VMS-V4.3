	.TITLE	MCRINIT - COMMAND INTERPRETER INITIALIZATION
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; TIM HALVORSEN, MAY 1981
;
; COMMAND LANGUAGE INTERPRETER INITIALIZATION
;
; MODIFIED BY:
;
;	V3.0007	MAJ0008		Melanie Johnson	17-Feb-1983
;		Remove the use of the imbedded indirect for processing
;		the login command files and use ICM instead.
;
;	V3.0006	MAJ0007		Melanie Johnson	24-Jan-1983
;		Initialize PRC_L_PBKPTR(R11) and if in a subprocess,
;		PBK$W_FLAGS in the passback structure.
;
;	V3.0005	MAJ0006		Melanie Johnson	14-Jan-1983
;		Only allocate storage for the passback structure if MCR
;		is in a subprocess created by the AME.  When determining
;		the name of the AME's receiving mailbox, delete the first colon
;		in the process name and all characters following it before
;		forming the logical name of the mailbox.  Turn off command
;		line verification.
;
;	V3.0004	MAJ0005		Melanie Johnson		11-Nov-1982
;		If MCR is in subprocess which has been created by the
;		AME, determine the main-process AME's receiving mailbox name
;		and assign a channel to that mailbox for future passbacks.
;
;	V3.0003	MAJ0004		Melanie Johnson	30-Sep-1982
;		If MCR is in a subprocess and a supervisor mode SYS$ERROR
;		has been found, check to see if that SYS$ERROR is equated to
;		a mailbox before deciding to reject being spawned because
;		DCL was the spawner.  (Don't reject being spawned by the AME.)
;		This is the source fix for ECO1 for V3.2.
;
;	V3.0002	MAJ0003		Melanie Johnson		08-Apr-1982
;		Fix stack-cleaning bug created by MAJ0002.
;
;	V3.0001	MAJ0002		Melanie Johnson	31-Mar-1982
;		Disallow DCL to spawn an MCR subprocess.
;
;	V2.001	MAJ0001		Melanie Johnson		28-Aug-81
;		Initialize <FILSPC> and <FILERR>
;---

;
; MACRO LIBRARY CALLS
;
 
	$$CLITABDEF			; DEFINE COMMAND TABLE STRUCTURES
	$PPDDEF				; PROCESS PERMANENT DATA AREA
	DEFCMDWRK			; DEFINE COMMAND WORK AREA OFFSETS
	PRDDEF				; RMS DATA STORAGE DEFINITIONS
	DEFSYMTBL			; DEFINE SYMBOL ENTRY OFFSETS
	IDFDEF				; INDIRECT PROCEDURE FRAME
	$FABDEF				; FILE ACCESS BLOCK
	$RABDEF				; RECORD ACCESS BLOCK
	$PSLDEF				; PROCESSOR STATUS FIELDS
	$CLIMSGDEF			; CLI MESSAGE CODES
	$LOGDEF				; LOGICAL NAME TABLE CODES
	$PBKDEF				; DEFINE PASSBACK STRUCTURE

	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
;
; LOCAL DATA
;
	OWNRNAMSIZ = 16
	MBXNAMSIZ = 28
	
;
; NAME OF SCRATCH FILE USED TO PROCESS INITIALIZATION PROCEDURES
; (LOGIN COMMAND FILES)
;

INITNAM:
	.ASCIC	/SYS$SCRATCH:XXMCRINIT.CMD/

;
; THE .ENABLE QUIET COMMAND WILL BE USED TO EXECUTE THE LOGIN COMMAND FILE(S)
; SILENTLY
;

QUIET:	.ASCIC	/.ENABLE QUIET/

;
; This string will be used to set the indirect error handling level to level 2
;

NOERR:	.ASCIC	/.SETN <ERRCTL> 2/

;
; Use the .ONERR indirect command to keep ICM from bombing when there's no
; LOGIN.CMD
;

ONERR:	.ASCIC	/.ONERR /

;
; NAME OF SYS$ERROR
;

SYS$ERROR:
	.ASCIC	'SYS$ERROR'

;
; TABLE OF RESERVED SYMBOLS
;
RESERVED:				;
	.BYTE	1			;MAXIMUM LENGTH OF SEVERITY LEVEL
	.ASCIC	'$SEVERITY'		;ERROR SEVERITY LEVEL SYMBOL
	.BYTE	PRC_L_SEVERITY		;OFFSET TO SEVERITY VALUE ADDRESS
	.BYTE	10			;MAXIMUM LENGTH OF STATUS VALUE
	.ASCIC	'$STATUS'		;STATUS VALUE SYMBOL
	.BYTE	PRC_L_STATUS		;OFFSET TO STATUS VALUE ADDRESS
	.BYTE	0			; --- END OF TABLE

	.SBTTL	COMMAND INTERPRETER START UP
;+
; MCR$STARTUP - COMMAND INTERPRETER START UP
;
; THIS ENTRY POINT IS JUMPED TO AT THE CONCLUSION OF LOGGING A USER ONTO
; THE SYSTEM. ALL INPUT AND OUTPUT FILES ARE OPEN AND THE COMMAND LANGUAGE
; INDEPENDENT DATA AREA HAS BEEN INITIALIZED.
;-
 
	.PSECT	MCR$$BASE,BYTE,RD,NOWRT

	MOVL	G^CTL$AL_STACK+8,SP	;RELOAD SUPERVISOR STACK POINTER
	CLRL	FP			;INDICATE NO PREVIOUS FRAME
	CALLG	(SP),W^MCR$STARTUP	;SETUP INITIAL CALL FRAME
	$EXIT_S

	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$STARTUP::				;COMMAND INTERPRETER START UP
	.WORD	^M<>			;ENTRY MASK
	CLRL	-(SP)			;SETUP DUMMY PSL (@PRC_L_SAVAP=PRVPSL)
	CALLG	(SP),B^10$		;CREATE DUMMY FP AFTER DUMMY AP
	RET
10$:	.WORD	0
	MOVAB	W^MCR$CONDHAND,(FP)	;ESTABLISH CONDITION HANDLER
	MOVAB	W^MCR$UTLSERV+2,G^CTL$AL_CLICALBK ; SET CALL BACK VECTOR
	MOVAB	G^CTL$AG_CLIDATA,R10	;GET ADDRESS OF PPD
;
; INITIALIZE CLI PROCESS WORK AREA
;
	MOVL	PPD$Q_CLIREG+4(R10),R11	;GET ADDRESS OF CLI PRIVATE STORAGE
	MOVC5	#0,(SP),#0,PPD$Q_CLIREG(R10),(R11) ;ZERO ALL STORAGE
	MOVQ	AP,PRC_L_SAVAP(R11)	;SAVE INITIAL ARGUMENT AND FRAME POINTERS
	MOVW	PPD$W_INPCHAN(R10),PRC_W_INPCHAN(R11)	;COPY INPUT CHANNEL
	BBC	#PPD$V_MODE,PPD$W_FLAGS(R10),20$	;COPY JOB MODE
	BISW	#PRC_M_MODE!PRC_M_VERIFY,PRC_W_FLAGS(R11) ;AND TURN VERIFY ON
20$:	BBC	#PPD$V_NOCTLY,PPD$W_FLAGS(R10),25$	;COPY NOCONTROLY MODE
	SETBIT	PRC_V_NOCTLY,PRC_W_FLAGS(R11)
25$:	MOVAB	G^MCR$AL_TAB_VEC,PRC_L_TAB_VEC(R11)	;ADDRESS OF DATABASE
;
; FOR BATCH JOBS, SETUP TO EXIT ON ERRORS.  FOR INTERACTIVE JOBS, DO
; AN IMPLIED "SET NOON".
;
	MOVW	#2@8!8,PRC_W_ONLEVEL(R11) ;IF INTERACTIVE, "SET NOON"
;
; INITIALIZE CLI SYMBOL TABLE
;
	MOVAB	PRC_Q_GLOBAL(R11),R0	;GET ADDRESS OF GLOBAL TABLE LISTHEAD
	MOVL	R0,(R0)			;INIT GLOBAL SYMBOL TABLE EMPTY
	MOVL	(R0)+,(R0)+
	ASSUME	PRC_Q_LABEL EQ PRC_Q_GLOBAL+8
	MOVL	R0,(R0)			;INIT LABEL TABLE EMPTY
	MOVL	(R0)+,(R0)+
	ASSUME	PRC_Q_LOCAL EQ PRC_Q_LABEL+8
	MOVL	R0,(R0)			;INIT CURRENT LOCAL SYMBOL TABLE EMPTY
	MOVL	(R0)+,(R0)+
	MOVQ	PPD$Q_CLISYMTBL(R10),R0	;GET LENGTH/ADDRESS OF REGION
	MOVL	R1,PRC_Q_ALLOCREG(R11)	;INIT LISTHEAD OF ALLOCATION REGION
	CLRL	(R1)+			;CLEAR LINK TO NEXT FREE BLOCK
	MOVL	R0,(R1)			;SET LENGTH OF THIS FREE BLOCK
;
; INITIALIZE <FILSPC> AND <FILERR> SYMBOLS
;
	CLRL	PRC_L_FILSPC(R11)	; CLEAR <FILSPC>
	MOVZBL	#^A/1/,PRC_L_FILERR(R11) ; SET <FILERR> TO 1=SUCCESS
;
; CREATE RESERVED SYMBOLS $STATUS AND $SEVERITY
;
	MOVAB	RESERVED,R6		; GET ADDRESS OF RESERVED SYMBOLS
40$:	MOVZBL	(R6)+,R1		; GET MAXIMUM LENGTH OF VALUE STRING
	BEQL	50$			; IF EQL END OF TABLE
	MOVL	R6,R2			; SET ANY ADDRESS FOR SYMBOL VALUE
	MOVZBL	(R6)+,R3		; CONSTRUCT DESCRIPTOR OF SYMBOL NAME
	MOVL	R6,R4
	ADDL	R3,R6			; ADJUST TO ADDRESS OFFSET
	MOVAB	PRC_Q_GLOBAL(R11),R5	; GET ADDRESS OF SYMBOL TABLE LISTHEAD
	BSBW	MCR$ALLOCSYM		; ALLOCATE AND INSERT SYMBOL
	MOVB	#SYM_K_PERM,SYM_B_TYPE(R1) ; MARK SYMBOL PERMANENT
	MOVZBL	SYM_T_SYMBOL(R1),R0	; GET LENGTH OF SYMBOL NAME
	MOVAB	SYM_T_SYMBOL+1(R1)[R0],R0 ; GET ADDRESS OF SYMBOL VALUE
	CLRB	(R0)+			; CLEAR LENGTH OF SYMBOL VALUE
	MOVZBL	(R6)+,R1		; GET OFFSET TO ADDRESS OF SYMBOL VALUE
	ADDL	R11,R1			; CALCULATE ADDRESS TO STORE VALUE ADDRESS
	MOVL	R0,(R1)			; SET ADDRESS OF SYMBOL VALUE
	BRB	40$
;
; FOR BATCH JOBS, CREATE SYMBOLS P1 THRU P8 AS THE JOB PARAMETERS
;
50$:	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),70$ ;BRANCH IF NOT BATCH JOB
	MOVAB	-64(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
	PUSHL	#64
	PUSHL	#^A'P0'			;PUSH PROTOTYPE LOGICAL/SYMBOL NAME
	PUSHL	SP			;AND CONSTRUCT DESCRIPTOR OF IT
	PUSHL	#2
	MOVL	SP,R6			;GET ADDRESS OF DESCRIPTOR
	MOVL	#8,R7			;LOOP 8 TIMES
60$:	MOVL	#64,12(R6)		;RESET LENGTH OF BUFFER
	INCB	9(R6)			;INCREMENT SYMBOL NAME
	$TRNLOG_S LOGNAM=(R6),-		;TRANSLATE LOGICAL NAME P#
		RSLBUF=12(R6),-		;INTO BUFFER ON STACK
		RSLLEN=12(R6),-
		DSBMSK=#3		;DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPL	R0,#SS$_NORMAL		;SUCCESS?
	BEQL	65$			;IF NOT,
	CLRL	12(R6)			;SET THE SYMBOL TO NULL STRING
65$:	MOVQ	12(R6),R1		;GET DESCRIPTOR OF SYMBOL VALUE
	MOVQ	(R6),R3			;GET DESCRIPTOR OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	BSBW	MCR$ALLOCSYM		;DEFINE SYMBOL IN SYMBOL TABLE
	SOBGTR	R7,60$			;LOOP UNTIL ALL SYMBOLS DONE
	MOVAB	8+4+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
;
; INITIALIZE PROCESS RMS DATA AREA
;
70$:	MOVAB	PRC_C_LENGTH(R11),R8	;SET ADDRESS OF RMS STRUCTURES (PRD)
	MOVAB	PRD_G_FAB(R8),PRC_L_INDFAB(R11)	;ADDRESS OF GENERAL PURPOSE FAB
	ASSUME	PRD_G_FAB EQ 0		;ASSUME FAB AT START OF STRUCTURE
	MOVAB	PRD_G_INPRAB(R8),R9	;SET ADDRESS OF INPUT RAB
	MOVAB	PRD_G_OUTRAB(R8),R7	;SET ADDRESS OF OUTPUT RAB
	ASSUME	FAB$B_BID EQ 0
	ASSUME	FAB$B_BLN EQ 1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,PRD_G_FAB(R8)	;SET FAB ID/LENGTH
	MOVAB	PRD_G_NAM(R8),FAB$L_NAM(R8) ;SET ADDRESS OF NAM BLOCK
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,PRD_G_NAM(R8)	;SET NAM ID/LENGTH
	MOVW	#RAB$C_BID+<RAB$C_BLN@8>,RAB$B_BID(R9)	;SET RAB ID/LENGTH
	MOVW	PPD$W_INPISI(R10),RAB$W_ISI(R9)		;SET INPUT ISI
	MOVW	RAB$B_BID(R9),RAB$B_BID(R7)		;SET RAB ID/LENGTH
	MOVW	PPD$W_OUTISI(R10),RAB$W_ISI(R7)		;SET OUTPUT ISI
	MOVL	R8,RAB$L_FAB(R9)			;SET ADDRESS OF FAB
	MOVL	R8,RAB$L_FAB(R7)			;SET ADDRESS OF FAB
; SET PPF DIRECT ACCESS, SO THAT RMS USER-MODE EOF CHECKING IS NOT DONE
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R9)	;ENABLE DIRECT ACCESS
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R7)	;TO INPUT STREAMS
	ASSUME	RAB$W_ISI EQ RAB$B_BLN+1
	MOVL	RAB$B_BID(R9),PRD_G_ALTINPRAB(R8)	;SET RAB ID/LENGTH/ISI
	MOVL	RAB$B_BID(R7),PRD_G_ALTOUTRAB(R8)	;SET RAB ID/LENGTH/ISI
; STORE DEVICE CHARACTERISTICS IN THE RAB$L_CTX FIELD SO THAT RAB IS ENOUGH
	MOVL	PPD$L_INPDEV(R10),RAB$L_CTX(R9)	; INPUT DEVICE CHARACTERISTICS
	MOVL	PPD$L_OUTDEV(R10),RAB$L_CTX(R7)	; OUTPUT DEVICE CHARACTERISTICS
; LIMIT ALLOCATION OF BLOCKS/BUFFERS ON PPF STREAM (PIOSEG SPACE IS LIMITED)
	MOVB	#1,RAB$B_MBC(R9)	;ONLY ALLOCATE 1 BLOCK/BUFFER
	MOVB	#-1,RAB$B_MBF(R9)	;ONLY ALLOCATE 1 BUFFER/STREAM
	ASSUME	RAB$B_MBC EQ RAB$B_MBF+1
	MOVW	RAB$B_MBF(R9),RAB$B_MBF(R7)	; SET MBC/MBF FOR ALL RABS
	MOVW	RAB$B_MBF(R9),PRD_G_ALTINPRAB+RAB$B_MBF(R8)
	MOVW	RAB$B_MBF(R9),PRD_G_ALTOUTRAB+RAB$B_MBF(R8)
; SET READ-WITH-PROMPT ON ALL RABS USED TO READ INPUT COMMANDS
	SETBIT	RAB$V_PMT,PRD_G_ALTINPRAB+RAB$L_ROP(R8) ;SET READ WITH PROMPT
	SETBIT	RAB$V_PMT,PRD_G_INPRAB+RAB$L_ROP(R8)    ;SET READ WITH PROMPT
; USE SAME RAB FOR BOTH INPUT AND OUTPUT IF THEY BOTH POINT TO THE SAME STREAM
; (THIS IS FOR CODE SEGMENTS WHICH DECIDE IF THEY ARE THE SAME BY COMPARING
; THE INPUT AND OUTPUT RAB ADDRESSES RATHER THAN THEIR ISI'S)
	CMPW	RAB$W_ISI(R7),RAB$W_ISI(R9) ;ARE INPUT AND OUTPUT THE SAME?
	BNEQ	75$			;BRANCH IF NOT
	MOVL	R9,R7			;USE INPUT RAB FOR OUTPUT
; STORE FAB/RAB ADDRESSES IN PRC AREA FOR EASY ACCESS
75$:	MOVL	R7,PRC_L_ERRRAB(R11)	;SET ADDRESS OF ERROR RAB
	MOVL	R7,PRC_L_OUTRAB(R11)	;SET ADDRESS OF OUTPUT RAB
	MOVL	R9,PRC_L_INPRAB(R11)	;SET ADDRESS OF INPUT RAB
	MOVL	R7,PRC_L_INDOUTRAB(R11)	;SET ADDRESS OF INDIRECT OUTPUT RAB
	MOVL	R9,PRC_L_INDINPRAB(R11)	;SET ADDRESS OF INDIRECT INPUT RAB

; INITIALIZE INDIRECT FRAME STACK & LEVEL 0 FRAME

	MOVAB	PRC_C_LENGTH+PRD_C_XLENGTH(R11),- ;SET LIMIT OF INDIRECT FRAMES
		PRC_L_STACKLM(R11)
	ADDL3	PPD$Q_CLIREG(R10),PPD$Q_CLIREG+4(R10),R0 ;GET END+1 OF REGION
	MOVAB	-IDF_K_LENGTH(R0),R9	;ADDRESS OF LEVEL 0 FRAME
	MOVL	R9,PRC_L_STACKPT(R11)	;SET INDIRECT FRAME STACK POINTER
	MOVL	R9,PRC_L_IDFLNK(R11)	;SET LINK POINTER
	CLRL	IDF_L_LNK(R9)		;TERMINATE LIST
	MOVW	PPD$W_OUTIFI(R10),PRC_W_ERRIFI(R11) ;SAVE ERROR IFI
	MOVW	PPD$W_OUTIFI(R10),IDF_W_OUTIFI(R9) ;SAVE OUTPUT IFI
	MOVW	PPD$W_INPIFI(R10),IDF_W_INPIFI(R9) ;SAVE INPUT IFI
	MOVW	RAB$W_ISI(R7),IDF_W_OUTISI(R9)	;SAVE OUTPUT ISI
	MOVL	PPD$L_OUTDEV(R10),IDF_L_OUTRABCTX(R9) ;SAVE OUTPUT DEVCHAR
	MOVL	PPD$L_INPDEV(R10),IDF_L_INPRABCTX(R9) ;SAVE INPUT DEVCHAR
	MOVC	#16,PPD$T_OUTDVI(R10),IDF_T_OUTDVI(R9) ;COPY OUTPUT DEVICE NAME
	MOVC	#PPD$C_DVIFID,PPD$T_INPDVI(R10),- ;COPY INPUT DEVICE NAME/IDS
		IDF_T_INPDVI(R9)

;
; MAKE SURE COMMAND TABLES HAVE A VALID STRUCTURE LEVEL NUMBER
;
	MOVL	PRC_L_TAB_VEC(R11),R0	; GET ADDRESS OF SYNTAX TABLES
	CMPB	VEC_B_STRLVL(R0),#6	; STRUCTURE 6 TABLES?
	BEQLU	80$			; BRANCH IF STR LEVEL 6 (OK)
;
; ILLEGAL OR UNRECOGNIZED TABLE STRUCTURE LEVEL
;
	MOVL	#CLI$_BADSTRLVL,R0	;ERROR MESSAGE CODE
	BRW	INITIAL_ERROR		;ABORT

;
; CHECK TO SEE IF THIS PROCESS IS A SUBPROCESS WHICH WAS CREATED BY THE DCL
; SPAWN COMMAND AND ABORT IF IT IS. (DON'T LET DCL SPAWN AN MCR SUBPROCESS.)
; IF THIS IS A SUBPROCESS CREATED BY THE AME, DON'T ABORT.
;
80$:	CLRL	PRC_L_PBKPTR(R11)	;ASSUME NOT A SUBPROCESS - NO PASSBACKS
	CLRQ	-(SP)			;CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		;SET BUFFER ADDRESS
	PUSHL	#JPI$_OWNER@16+4	;REQUEST PARENT PID, SET BUFFER LENGTH
	MOVL	SP,R0
	$GETJPI_S ITMLST=(R0)		;GET PID OF PARENT PROCESS
	POPL	PRC_L_OWNRPID(R11)	;GET PID
	ADDL	#3*4,SP			;CLEANUP STACK
	BLBS	R0,90$			;IF OK, CONTINUE
89$:	BRW	INITIAL_ERROR		;ERROR, ABORT
90$:	TSTL	PRC_L_OWNRPID(R11)	;IS THIS A SUBPROCESS?
	BNEQ	100$			;IF NEQ, IT IS - MIGHT NEED TO ABORT
	BRW	140$			;NOT A SUBPROCESS, NO NEED TO ABORT
100$:	MOVAB	-64(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZBL	#64,-(SP)
	MOVL	SP,R6			;POINT TO BUFFER DESCRIPTOR
	SUBL	#4,SP			;ALLOCATE SCRATCH LONGWORD FOR ACMODE
	MOVAB	SYS$ERROR,R2		;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R2)+,R1		;CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R1,-(SP)		;PUSH DESCRIPTOR OF SYS$ERROR
	$TRNLOG_S LOGNAM=-12(R6),-	;TRANSLATE SYS$ERROR
		RSLBUF=(R6),-
		RSLLEN=(R6),-
		DSBMSK=#3,-		;ONLY SEARCH PROCESS LOGNAME TABLE
		ACMODE=-4(R6)
	CMPL	R0,#SS$_NOTRAN		;WAS THERE A SYS$ERROR?
	BEQL	120$			;IF EQL, NO
	CMPB	-4(R6),#PSL$C_SUPER	;SUPERVISOR MODE SYS$ERROR?
	BNEQ	120$			;IF NOT, THEN NO CONTEXT WAS PASSED
	CMPL	@4(R6),#^A'_MBA'	;IS SYS$ERROR EQUATED TO A MAILBOX?
	BNEQ	120$			;IF NEQ, NO - NOT SPAWNED BY DCL
	MOVL	SP,R0			;GET ADDRESS OF 'SYS$ERROR' DESCRIPTOR
	$DELLOG_S LOGNAM=(R0),-		;DELETE SUPERVISOR MODE SYS$ERROR
		TBLFLG=#LOG$C_PROCESS,-	;LEAVING EXECUTIVE MODE SYS$ERROR
		ACMODE=#PSL$C_SUPER	;(WHICH IS EQUIVALENT TO SYS$OUTPUT)
	MOVAB	8+4+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
	STATUS	NOSPAWN			;WE WERE SPAWNED BY DCL - DISALLOW THAT
110$:	BRW	INITIAL_ERROR		;ABORT SUBPROCESS

120$:	MOVAB	8+4+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
;
; ASSUME THE AME HAS SPAWNED THIS SUBPROCESS.  DETERMINE THE NAME OF OUR
; MAIN-PROCESS AME'S RECEIVING MAILBOX AND ASSIGN A CHANNEL TO THAT MAILBOX
; FOR FUTURE USE IN PASSBACKS.
;
	MOVAB	-OWNRNAMSIZ(SP),SP	;ALLOCATE A BUFFER FOR OWNER NAME
	MOVL	SP,PRC_Q_OWNRNAM+4(R11) ;SAVE THE ADDRESS OF THIS BUFFER
	MOVL	SP,R2			;COPY ADDRESS OF LOCATION FOR OWNER NAME STRING
	CLRL	-(SP)			;SET END OF ITEMLIST FOR GETJPI
	MOVAL	PRC_Q_OWNRNAM(R11),-(SP) ;ADDRESS INTO WHICH TO PUT LENGTH OF OWNER NAME
	MOVL	R2,-(SP)		;ADDRESS AT WHICH TO PUT OWNER NAME STRING
	MOVW	#JPI$_PRCNAM,-(SP)	;ITEM CODE - REQUEST PROCESS NAME
	MOVW	#OWNRNAMSIZ,-(SP)	;LENGTH OF OWNER NAME BUFFER
	MOVL	SP,R3			;ITMLST DESCRIPTOR SET UP ON STACK
	$GETJPI_S  PIDADR=PRC_L_OWNRPID(R11),ITMLST=(R3) ;ASK FOR OUR OWNER'S NAME
	ADDL	#4*4,SP			;CLEAN STACK
	BLBC	R0,110$			;IF ERROR, ABORT
	MOVAB	-MBXNAMSIZ(SP),SP	;ALLOCATE SCRATCH BUFFER
	MOVL	SP,R3			;COPY ADDRESS OF SCRATCH BUFFER
	PUSHL	R3			;SAVE ADDRESS OF SCRATCH BUFFER
	MOVQ	PRC_Q_OWNRNAM(R11),R1	;GET OWNER NAME DESCRIPTOR
	CMPB	R1,#6			;PROC. NAME LONGER THAN 6 CHARACTERS?
	BLEQ	130$			;IF LEQ, NO
	MOVL	#6,R1			;ONLY USE 6 CHARACTERS TO FORM MBX NAME
130$:	LOCC	#^A/:/,R1,(R2)		;SEARCH FOR A COLON IN THE PROCESS NAME
	SUBL	R2,R1			;TRUNCATE COLON IF FOUND AND FOLLOWING CHARACTERS
	ADDL3	#4,R1,(R3)+		;COMPUTE SIZE OF MAILBOX NAME
	MOVAL	4(R3),(R3)+		;ADDRESS OF MAILBOX NAME
	MOVL	#^A/RCVD/,(R3)+		;PREFIX OF MAILBOX NAME
	MOVC	R1,(R2),(R3)		;OWNER PROCESS NAME IS SUFFIX OF MBX NAME
	POPL	R3			;RESTORE POINTER TO BEGIN. OF MBX NAME
	$ASSIGN_S  DEVNAM=(R3),CHAN=PRC_W_MBXCHAN(R11) ;ASSIGN A CHANNEL TO THE MBX
	MOVAB	MBXNAMSIZ(SP),SP	;DEALLOCATE SCRATCH STORAGE
	BLBC	R0,160$			;IF ERROR, ABORT
;
; ALLOCATE THE PASSBACK STRUCTURE STORAGE AREA
;
;
	MOVAB	-PBK$C_PBKSTRSIZ(SP),SP	;ALLOCATE PBK STRUCTURE ON STACK
	MOVL	SP,PRC_L_PBKPTR(R11)	;SAVE A POINTER TO PBK FOR FUTURE PASSBACKS
	CLRW	PBK$W_FLAGS(SP)		;INITIALIZE PASSBACK FLAGS WORD
;
; TURN OFF COMMAND LINE VERIFICATION - WHEN WE'RE AN ICM SUBPROCESS, ICM
; WILL HANDLE THE ECHOING, IF DESIRED
;
	CLRBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11) ;DON'T ECHO COMMAND LINES
135$:	BRW	230$			;BYPASS LOGIN COMMAND FILE PROCESSING
;
; Translate the names of the login command files (initialization procedures)
; and send them to ICM for execution.  To do this all in one pass, build a
; temporary indirect command file, SYS$SCRATCH:XXMCRINIT.CMD, to contain
; invocations of each of the login command files and a self-delete command
; to cleanup that file after it has been processed by ICM.   ICM will be
; invoked after all initialization has been completed.
;
; Note: R8 still contains the address of the process FAB.
;	R10 still contains CLI$AG_CLIDATA (address of PPD structure)
;
140$:	MOVZBL	PPD$B_NPROCS(R10),R10	;GET NUMBER OF NAMES TO TRANSLATE
	BEQL	135$			;IF EQL, NOTHING TO TRANSLATE
150$:	MOVB	INITNAM,FAB$B_FNS(R8)	;GET SIZE OF SCRATCH INIT CMD FILE NAME
	MOVAB	INITNAM+1,FAB$L_FNA(R8)	;GET ADDR OF SCRATCH INIT CMD FILE NAME
	MOVB	#FAB$M_CR,FAB$B_RAT(R8)	;RECORD ATTRIBUTE - CARRIAGE RETURN
	MOVB	#FAB$M_PUT,FAB$B_FAC(R8) ;FILE ACCESS WILL AWAYS BE PUT
	MOVL	#FAB$M_NAM,FAB$L_FOP(R8) ;FILE OPTIONS - USE A NAME BLOCK
	MOVB	#FAB$C_VAR,FAB$B_RFM(R8) ;USE VARIABLE LENGTH RECORD FORMAT
	CLRW	FAB$W_IFI(R8)		;CLEAR INTERNAL FILE INDEX
	MOVAB	-64(SP),SP		;ALLOCATE A RESULTANT STRING BUFFER
	MOVL	FAB$L_NAM(R8),R1	;GET NAME BLOCK ADDRESS
	MOVL	SP,NAM$L_RSA(R1)	;PUT RESULTANT STRING BUFFER ADDR IN NAME BLOCK
	MOVB	#64,NAM$B_RSS(R1)	;PUT SIZE OF RESULTANT BUFFER IN NAME BLOCK
	$CREATE	FAB=(R8)		;CREATE THE SCRATCH INITIALIZATION FILE
	BLBS	R0,170$			;BRANCH IF NO ERROR
;********this should be changed to report this error without aborting the process
160$:	BRW	INITIAL_ERROR		;ABORT - ERROR
170$:	ASSUME	PRD_G_FAB EQ 0
	MOVAB	PRD_G_ALTOUTRAB(R8),R9	;GET ADDRESS OF AVAILABLE RAB
	MOVL	FAB$L_DEV(R8),RAB$L_CTX(R9) ;COPY DEVICE CHARACTERISTICS
	CLRW	RAB$W_ISI(R9)		;CLEAR INTERNAL STREAM INDEX
	MOVL	R8,RAB$L_FAB(R9)	;LINK FAB TO RAB
	$CONNECT RAB=(R9)		;CONNECT TO THE OPEN SCRATCH FILE
	BLBC	R0,160$			;BRANCH IF ERROR
	MOVAB	-64(SP),SP		;ALLOCATE BUFFER FOR TRANSLATING LOGICALS
	MOVL	SP,R6			;SAVE ADDRESS OF BUFFER
	MOVL	R6,RAB$L_RBF(R9)	;PREPARE TO OUTPUT PROCEDURE NAMES TO FILE
;
; Shhh... The login command files should execute silently, so put a
; .ENABLE QUIET command into the scratch file
;
	MOVAB	QUIET,R1		;ADDRESS OF STRING TO BE WRITTEN TO FILE
	BSBW	WRITE_LINE		;WRITE THIS TEXT INTO THE FILE

;
; Write a command into the scratch file to set the indirect error handling
; level to 2.  Add .ONERR directives to the scratch file to prevent ICM from
; dying if any of the login command files named do not exist.
;
	MOVAB	NOERR,R1		;ADDRESS OF ".SETN <ERRCTL> 2"
	BSBW	WRITE_LINE		;WRITE THIS TEXT INTO THE FILE
;
; Translate the logical names of the initialization procedures (login command
; files), PROC0 through PROC(PPD$B_NPROCS).
;
	MOVB	#^A/@/,(R6)		;MAKE EACH TRANSLATE NAME INTO CMD FILE CALL
	PUSHAB	1(R6)			;BUFF ADDR-SKIP BYTE CONTAINING THE "@"
	MOVZBL	#64,-(SP)		;BUFF SIZE - DESCRIP. FOR TRANSLATED LOGICAL
	MOVQ	#^A/PROC0/,-(SP)	;1ST PROCEDURE LOGICAL NAME TO TRANSLATE
	PUSHL	SP			;CONSTRUCT DESCRIPTOR FOR PROCEDURE NAME
	PUSHL	#5			;PROCEDURE LOGICAL NAME SIZE
	MOVL	SP,R7			;SAVE ADDRESS OF DESCRIPTOR
180$:	MOVL	R6,R3			;COPY OUTPUT BUFFER POINTER
	MOVB	#^A/./,(R3)+		;WRITE A LABELLED .ONERR STATEMENT TO FILE
	MOVB	12(R7),(R3)+		;USE THE PROCEDURE NO. AS A LABEL # CNTR
	MOVW	#^A/: /,(R3)+		;FINISH LABEL
	MOVZBL	ONERR,R0		;LENGTH OF ONERR COMMAND
	ADDW3	#5,R0,RAB$W_RSZ(R9)	;ONERR TEXT + 5 CHARACTERS FOR 2 LABELS
	MOVC	R0,ONERR+1,(R3)		;COPY ONERR TEXT TO OUTPUT BUFFER
	INCB	12(R7)			;INCREMENT PROCEDURE AND LABEL COUNTER
	MOVB	12(R7),(R3)		;LABEL TO TRAP TO ON AN INDIRECT ERROR
	$PUT	RAB=(R9)		;WRITE THE LABELLED ONERR COMMAND TO FILE
	MOVB	#^A/@/,(R6)		;INITIALIZE FOR PROCEDURE CALL
	MOVZBL	#64,16(R7)		;RESET LENGTH OF BUFFER
	$TRNLOG_S LOGNAM=(R7),-		;TRANSLATE LOGICAL NAME PROC#
		RSLBUF=16(R7),-		;INTO BUFFER ON STACK
		RSLLEN=16(R7),-
		DSBMSK=#3		;DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPW	R0,#SS$_NOTRAN		;NO TRANSLATION?
	BEQL	190$			;IF SO, SKIP THIS ONE
	ADDW3	#1,16(R7),RAB$W_RSZ(R9)	;ADD 1 BYTE TO STRING SIZE FOR THE "@"
	$PUT	RAB=(R9)		;WRITE PROCEDURE CALL INTO SCRATCH CMD FILE
	BLBC	R0,200$			;BRANCH IF ERROR
190$:	SOBGTR	R10,180$		;LOOP TO TRANSLATE ALL THE LOGICAL NAMES
	MOVB	#^A/./,(R6)+		;PREPARE LAST LABEL FOR SCRATCH FILE
	MOVB	12(R7),(R6)+		;LABEL NUMBER
	MOVW	#^A/: /,(R6)+		;LABEL DELIMITER
;
; Add a DELETE command to the scratch file so that it will self-delete
;
	MOVQ	#^A/DELETE  /,(R6)+	;PUT DELETE COMMAND INTO OUTPUT BUFFER
	MOVZBL	INITNAM,R1		;GET SIZE OF SCRATCH FILE NAME
	MOVC	R1,INITNAM+1,-1(R6)	;MERGE THE FILE NAME INTO THE INPUT BUFFER
	MOVW	#^A/;*/,(R3)		;APPEND WILDCARD VERSION TO DELETE ALL
	MOVZBW	INITNAM,RAB$W_RSZ(R9)	;USE SIZE OF FILE NAME FOR OUTPUT BUFFER SIZE
	ADDW	#13,RAB$W_RSZ(R9)	;ADD 7 ("DELETE ") + 2 (";*") + 4 (LABEL) CHAR'S
	$PUT	RAB=(R9)		;PUT DELETE COMMAND IN SCRATCH FILE TO DELETE ITSELF
200$:	BLBC	R0,INITIAL_ERROR	;BRANCH IF ERROR
	$CLOSE	FAB=(R8)		;SCRATCH COMMAND FILE IS READY TO SEND TO ICM
	MOVAB	<6*4>+<2*64>(SP),SP	;DEALLOCATE SCRATCH STORAGE INCLUDING 2 BUFFERS

;
;********Disabling Imbedded Indirect*************************************
;
; STACK INITIALIZATION PROCEDURES PROC1 THRU PROC(PPD$B_NPROCS)
;
;	MOVAB	-64(SP),SP		;ALLOCATE BUFFER ON STACK
;	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
;	MOVZBL	#64,-(SP)
;	MOVQ	#^A'PROC0',-(SP)	;PUSH PROTOTYPE PROCEDURE NAME
;	PUSHL	SP			;AND CONSTRUCT DESCRIPTOR OF IT
;	PUSHL	#5
;	MOVL	SP,R6			;GET ADDRESS OF DESCRIPTOR
;	MOVZBL	PPD$B_NPROCS(R10),R7	;GET NUMBER OF INITIAL PROCEDURES
;	ADDB	R7,12(R6)		;SET TO LAST PROCEDURE NAME
;80$:	MOVZBL	#64,16(R6)		;RESET LENGTH OF BUFFER
;	$TRNLOG_S LOGNAM=(R6),-		;TRANSLATE LOGICAL NAME PROC#
;		RSLBUF=16(R6),-		;INTO BUFFER ON STACK
;		RSLLEN=16(R6),-
;		DSBMSK=#3		;DON'T LOOK IN GROUP OR SYSTEM TABLES
;	CMPW	R0,#SS$_NOTRAN		;NO TRANSLATION?
;	BEQL	85$			;IF SO, SKIP THIS ONE
;	MOVQ	16(R6),R2		;GET DESCRIPTOR OF PROCEDURE NAME
;	CLRL	R4			;SPECIFY PRIMARY OUTPUT FILE
;	MOVL	#1,R1			;SUPPRESS RMS ERROR MESSAGES
;	BSBW	MCR$PUSHPROC		;PUSH PROCEDURE ONTO INDIRECT STACK
;					;IGNORE ANY ERRORS (LIKE FNF, ETC.)
;85$:	DECB	12(R6)			;DECREMENT PROCEDURE NUMBER
;	SOBGTR	R7,80$			;LOOP UNTIL ALL SYMBOLS DONE
;	MOVAB	8+8+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
;
;***********************************************************************

;
; RUNDOWN LOGINOUT IMAGE, THUS DELETING ALL USER-MODE LOGICAL NAMES
;

230$:	$RUNDWN_S #PSL$C_USER		;RUNDOWN LOGIN IMAGE

;
; INITIALIZE COMMAND PARSING WORK AREA AND PROCESS FIRST COMMAND
;
	BSBW	MCR$ENBCONTRLY		;ENABLE CONTROL Y AST'S
	MOVZBL	#^A/0/,PRC_L_CLIWRK0(R11) ; SET INITIAL STRING LENGTH TO 0
	MOVW	#4,PRC_B_EXMDEPWID(R11)	;SET EXAMINE MODE TO HEX,WIDTH TO 4
	$DCLCMH_S W^MCR$CHANGE_MODE	; SET CHANGE MODE TO SUPER HANDLER
;
; If this is not a subprocess, set up to execute the login command files
; first
;
	TSTL	PRC_L_OWNRPID(R11)	;IS THIS A SUBPROCESS?
	BNEQ	250$			;IF SO, DON'T INVOKE LOGIN COMMAND FILES
	MOVAB	G^CTL$AG_CLIDATA,R10	;GET ADDRESS OF PPD AGAIN
	TSTL	PPD$B_NPROCS(R10)	;WERE THERE ANY LOGIN COMMAND FILES?
	BEQL	250$			;IF EQL, NO
	MOVAB	WRK_K_LENGTH-16(FP),SP	;ALLOCATE WRK (COMMAND IMPURE AREA)
	MOVAB	WRK_G_INPBUF(FP),R0	;GET ADDRESS OF COMMAND INPUT BUFFER
	MOVAB	-1(R0),WRK_L_CHARPTR(FP) ;INITIALIZE BUFFER PTR FOR 1ST GETCHAR
	MOVB	#^A/@/,(R0)+		;FORCE THE COMMAND: @SYS$SCRATCH:XXMCRINIT
	MOVZBL	INITNAM,R1		;GET LENGTH OF SCRATCH FILE NAME
	MOVC	R1,INITNAM+1,(R0)	;COPY SCRATCH FILE NAME TO INPUT BUFFER
	CLRB	(R3)			;SET EOL INDICATOR
	BRW	MCR$CMDSTART		;PROCESS COMMAND W/O FORCING RE-INPUT

250$:	BRW	MCR$RESTART		;START COMMAND INTERPRETATION


INITIAL_ERROR:
	MOVAB	WRK_K_LENGTH-16(FP),SP	;ALLOCATE WRK TO SIGNAL MESSAGE
	MOVW	#WRK_M_COMMAND,WRK_W_FLAGS(FP)	;CLEAR FLAGS, SET WRK_V_COMMAND
					;TO MARK NO ERROR TEXT SEGMENT
	BSBW	MCR$ERRORMSG		;ISSUE ERROR MESSAGE
	BRW	MCR$ABORT		;AND EXIT PROCESS



;---
;
;	THIS ROUTINE COPIES ONE LINE OF TEXT TO AN OUTPUT BUFFER
;	AND WRITES IT TO THE FILE:  SYS$SCRATCH:XXMCRINIT.CMD
;
; INPUTS:
;
;	R1 = ADDRESS OF STRING TO COPY TO THE OUTPUT BUFFER
;	R6 = ADDRESS OF OUTPUT BUFFER
;	R9 = ADDRESS OF RAB FOR SYS$SCRATCH:XXMCRINIT.CMD
;
; OUTPUTS:
;
;	THE ASCIC TEXT AT ADDRESS IN R1 IS WRITTEN TO SYS$SCRATCH:XXMCRINIT.CMD
;---

WRITE_LINE:
	MOVZBL	(R1),R0			;GET LENGTH OF COMMAND
	MOVW	R0,RAB$W_RSZ(R9)	;SET IT AS OUTPUT BUFFER LENGTH
	MOVC	R0,1(R1),(R6)		;COPY THE COMMAND INTO THE OUTPUT BUFFER
	$PUT	RAB=(R9)		;WRITE THE COMMAND INTO THE SCRATCH FILE
	RSB

	.SBTTL	CLI$GET_PRC, GET ADDRESS OF PRC STRUCTURE
;---
;
;	THIS ROUTINE IS CALLED TO GET THE ADDRESS OF THE CLI
;	OWN STORAGE AREA (PRC).
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;---

CLI$GET_PRC::
	MOVAB	G^CTL$AG_CLIDATA,R11	;GET ADDRESS OF PPD
	MOVL	PPD$L_PRC(R11),R11	;SET ADDRESS OF CLI OWN STORAGE
	RSB
 
	.END	MCR$STARTUP
