MODULE RWATTR (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  F11ACP Structure Level 2
!
! ABSTRACT:
!
!	This module contains the code and tables to process the read
!	and write attributes functions.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines. This routine must be executed
!	in kernel mode.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  6-Jan-1977  21:05
!
! MODIFIED BY:
!
!	V03-042	CDS0011		Christian D. Saether	30-Aug-1984
!		Change biasing of refcnt on primary_fcb during fid_to_spec
!		so that err_cleanup can fix if it necessary.  Also change
!		test for removing bias at end of routine.
!
!	V03-041	LMP0303		L. Mark Pilant,		21-Aug-1984  9:41
!		Fix a bug that caused memory to get overwritten when doing
!		a FID to file spec with long directory names.
!
!	V03-040	CDS0010		Christian D. Saether	16-Aug-1984
!		Set CLF_MARKFCBSTALE flag when modifying protected
!		attributes.
!
!	V03-039	CDS0009		Christian D. Saether	7-Aug-1984
!		Clean out directory index when turning off directory
!		flag in the header.
!
!	V03-038	LMP0295		L. Mark Pilant,		6-Aug-1984  16:52
!		Correctly return the binary version number for files with
!		long names.
!
!	V03-037	LMP0285		L. Mark Pilant,		26-Jul-1984  12:26
!		Fix a bug that caused a "?" to be added to the name if it
!		was 39 characters long.
!
!	V03-036	ACG0439		Andrew C. Goldstein,	20-Jul-1984  16:03
!		Make BYPASS priv allow change owner operations
!
!	V03-035	ACG0437		Andrew C. Goldstein,	13-Jul-1984  15:11
!		Add FCB arg to CHANGE_OWNER; remove ERR_EXIT calls from
!		CHANGE_OWNER and CHANGE_CLASS.
!
!	V03-034	LMP0259		L. Mark Pilant,		25-Jun-1984  11:39
!		If the user requests the matching ACE to be returned,
!		clear out the unused portion of the ACE.
!
!	V03-033	CDS0008		Christian D. Saether	15-May-1984
!		CDS0007 was not quite right.  Fix it.
!
!	V03-032	CDS0007		Christian D. Saether	11-May-1984
!		Don't bugcheck if there is no primary_fcb in fid_to_spec.
!
!	V03-031	CDS0006		Christian D. Saether	 3-May-1984
!		Bump refcnt in fcb when letting go of serialization
!		lock in fid_to_spec.
!
!	V03-030	CDS0005		Christian D. Saether	19-Apr-1984
!		Use REFCNT instead of ACNT where appropriate.
!		Use LOCK_COUNT routine to determine if file is accessed
!		anywhere in possible cluster.
!		Remove check for erroneous acl status.
!
!	V03-029	LMPBUILD	L. Mark Pilant,		16-Apr-1984  14:12
!		Initialize STATUS to be SS$_NORMAL in WRITE_ATTRIBUTE.
!
!	V03-028	ACG0415		Andrew C. Goldstein,	9-Apr-1984  11:02
!		Add call to rebuild file ACL after modifying; fix
!		access mode ATR probing; maximize the access mode protection
!		against mode of the caller; correct all error exits to
!		go through the cleanup code; support extended file name
!		in ident area.
!
!	V03-027	LMP0221		L. Mark Pilant,		1-Apr-1984  15:42
!		Support an ORB within an FCB.
!
!	V03-026	ACG0412		Andrew C. Goldstein,	22-Mar-1984  18:28
!		Implement agent access mode support; add access mode to
!		protection check call. Also make rest of global storage based.
!
!	V03-025	ACG0410		Andrew C. Goldstein,	22-Mar-1984  13:45
!		Add support for access mode attribute to probe buffers;
!		also check for file open in CHANGE_CLASS
!
!	V03-024	ACG0405		Andrew C. Goldstein,	16-Mar-1984  15:15
!		Fix handling of file headers in CHANGE_OWNER;
!		also pull obsolete handling of exception vectors and
!		obsolete access mask attribute.
!
!	V03-023	LMP0203		L. Mark Pilant,		9-Mar-1984  16:18
!		Add support for FIB$V_PROPAGATE.
!
!	V03-022	CDS0004		Christian D. Saether	29-Feb-1984
!		Serialize correctly tracking up through backlinks
!		in the FID_TO_SPEC routine.
!		Replace FLUSH_FID with TOSS_CACHE_DATA.
!
!	V03-021	LMP0195		L. Mark Pilant,		27-Feb-1984  14:38
!		Modify the way ownership changes to allow use of the
!		requestor's rights list.  Also, tie off classification
!		changes.
!
!	V03-020	CDS0003		Christian D. Saether	19-Dec-1983
!		Use BIND_COMMON macro to reduce external
!		COMMON declarations.
!
!	V03-019	CDS0002		Christian D. Saether	14-Oct-1983
!		NO_LCKCHK is now a byte instead of a word.
!
!	V03-018	CDS0001		Christian D. Saether	27-Sep-1983
!		Set flag to disable lock basis checking for now
!		when reading headers for back links.
!
!	V03-017	LMP0149		L. Mark Pilant,		8-Sep-1983  13:26
!		Correct a logic problem that caused problems during the
!		protection check of a write attribute operation.  Also,
!		fix up the directory spec returned for implicitly spooled
!		files.
!
!	V03-016	LMP0141		L. Mark Pilant,		24-Aug-1983  3:10
!		Return '?' for a zero back-link only if a non-zero link was
!		previously seen.
!
!	V03-015	LMP0131		L. Mark Pilant,		2-Aug-1983  11:06
!		Check for a minimum attribute length when writing the
!		reserved area of the file header.
!
!	V03-014	LMP0129		L. Mark Pilant,		25-Jul-1983  11:51
!		Return the correct directory name for files in the MFD.
!
!	V03-013	LMP0120		L. Mark Pilant,		22-Jun-1983  8:41
!		Correct the sizes used for the ACL attributes.
!
!	V03-012	ACG0338		Andrew C. Goldstein,	1-Jun-1983  17:21
!		Fix attribute control table change
!
!	V03-011	LMP0113		L. Mark Pilant,		10-May-1983  13:38
!		Add support for FID to file-spec translation.
!
!	V03-010	LMP0110		L. Mark Pilant,		3-May-1983  12:46
!		Add support for access allowed, privs used, and ACE used
!		to gain access.
!
!	V03-009	STJ3096		Steven T. Jeffreys,	29-Apr-1983
!		Make FH2$M_NOCHARGE a protected file characteristic.
!
!	V03-008	LMP0105		L. Mark Pilant,		26-Apr-1983  16:18
!		Add table entries for several new attributes.  Also, fix a
!		problem with issuing read type ACL attributes during a write
!		attribute operation.
!
!	V03-007	ACG0329		Andrew C. Goldstein,	12-Apr-1983  13:59
!		Fold long UIC's into [377,377] for 16 bit UIC
!
!	V03-006	STJ3078		Steven T. Jeffreys,	26-Mar-1983
!		Add support for the HIGHWATER mark.
!
!	V03-005	LMP0088		L. Mark Pilant,		16-Mar-1983  15:18
!		Add support for reading a single ACE and reading and writing
!		the reserved area in the file header.
!
!	V03-004	ACG0306		Andrew C. Goldstein,	13-Dec-1982  14:36
!		Get rid of obsolete file structure names
!
!	V03-003	LMP0054		L. Mark Pilant,		25-Oct-1982  17:05
!		Add a new attribute to return the ACL length.
!
!	V03-002	LMP0045		L. Mark Pilant,		21-Sep-1982  13:10
!		Call the ACL dispatcher in kernel mode when writing attributes.
!
!	V03-001	LMP0036		L. Mark Pilant,		29-Jun-1982  16:25
!		Add support for Access Control Lists.
!
!	V02-013	ACG43657	Andrew C. Goldstein,	17-Feb-1982  19:14
!		Fix bug in rereading primary header after changing file owner
!		of a multi-header file
!
!	V02-012	ACG0253		Andrew C. Goldstein,	18-Jan-1982  16:30
!		Add dummy HDR1 accessibility attribute
!
!	V02-011	ACG0241		Andrew C. Goldstein,	11-Dec-1981  22:32
!		Force RMS directory cache flush when directory bit is cleared
!
!	V02-010	ACG0232		Andrew C. Goldstein,	4-Dec-1981  16:43
!		Protect HIBLK during write attributes operation
!
!	V02-009	ACG0229		Andrew C. Goldstein,	1-Dec-1981  0:38
!		Add full counts and I/O counters to stat block
!
!	V02-008	ACG0221		Andrew C. Goldstein,	30-Oct-1981  18:04
!		Add attribute for journal control flags
!
!	V02-007	ACG0196		Andrew C. Goldstein,	5-Mar-1981  16:32
!		Fix file header length checks
!
!	V02-006	ACG0190		Andrew C. Goldstein,	16-Feb-1981  11:25
!		Remove old security mask field
!
!	V02-005	ACG0167		Andrew C. Goldstein,	16-Apr-1980  19:27
!		Previous revision history moved to F11B.REV
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:FCPDEF.B32';


FORWARD ROUTINE
	READ_ATTRIB	: L_NORM,	! read attributes
	FID_TO_SPEC	: L_NORM NOVALUE, ! convert FID to file-spec
	READ_HANDLER	: NOVALUE,	! read attributes condition handler
	WRITE_ATTRIB	: L_NORM NOVALUE, ! write attributes
	CONVERT_DATE	: L_NORM NOVALUE, ! convert string date to 64 bit
	CHANGE_OWNER	: L_NORM,	! change file owner UIC
	CHANGE_CLASS	: L_NORM;	! Change file classification

!++
!
! Attribute control table. The table is indexed by attribute number.
! Each entry is a quadword.
!
!--

! Macros and literals to access the table entries.
!

MACRO
					! flags byte
	ATC_READ_ONLY	= 0,0,1,0%,	! read only attribute
	ATC_PROTECTED	= 0,1,1,0%,	! writable by file owner only
	ATC_LOCKED	= 0,2,1,0%,	! subject to file access locks
	ATC_LOCATION	= 1,0,8,0%,	! location code
	ATC_OFFSET	= 2,0,8,0%,	! location offset
	ATC_ACTION	= 3,0,8,0%,	! action routine
	ATC_DATA_SIZE	= 4,0,16,0%,	! size of data area holding attribute
	ATC_MAX_SIZE	= 6,0,16,0%;	! max attribute size


! Masks for the flags.
!

LITERAL
	M_READ_ONLY	= 1,
	M_PROTECTED	= 2,
	M_LOCKED	= 4;


! Attribute location codes.
!

LITERAL
	ATC_ZERO	= 0,		! zero - no location
	ATC_FCB		= 1,		! in file control block
	ATC_HEADER	= 2,		! file header header area
	ATC_IDENT	= 3,		! file header ident area
	ATC_MAP		= 4,		! file header map area
	ATC_ACL		= 5,		! file header Access Control List area
	ATC_RESERVED	= 6,		! file header reserved area
	ATC_ACPGBL	= 7,		! ACP global storage
	ATC_FID2NAME	= 8,		! Convert FID to file spec

	ATC_LASTATC	= 8;		! last location code

! ACP global storage index codes.

LITERAL
	GBL_PRV		= 0,		! Privileges used to gain access
	GBL_ACE		= 1,		! ACE used to gain access

	GBL_LASTGBL	= 1;		! Last index code


! Attribute processing action routines.
!

LITERAL
	ACT_NOP		= 0,		! ignore attribute
	ACT_ILLEGAL	= 1,		! illegal attribute code
	ACT_COPY	= 2,		! simple copy
	ACT_STATBLK	= 3,		! build statistics block
	ACT_ZERO	= 4,		! zero valued attribute
	ACT_BLOCKSIZE	= 5,		! medium block size
	ACT_R50_NAME	= 6,		! RAD-50 file name, type, version
	ACT_R50_TYPE	= 7,		! RAD-50 file type & version
	ACT_R50_VER	= 8,		! binary version number
	ACT_UIC2	= 9,		! 2 byte file owner, protection, char
	ACT_FPRO	= 10,		! file protection + characteristics
	ACT_DATE	= 11,		! ASCII date
	ACT_DATES	= 12,		! revision count, ASCII dates
	ACT_UIC4	= 13,		! 4 byte file owner UIC
	ACT_BLANK	= 14,		! blank values attribute
	ACT_ACL		= 15,		! Access Control List
	ACT_RESERVED	= 16,		! Reserved area
	ACT_CLASS	= 17,		! Classification mask
	ACT_ACMODE	= 18,		! buffer access mode
	ACT_ACLEVEL	= 19,		! access mode protection of file
	ACT_FILENAME	= 20,		! internal file name

	ACT_LASTACT	= 20;		! highest action routine code


! Macro to build table entry.
!

MACRO
	ATTRIBUTE (CODE, FLAGS, LOC, OFF1, OFF2, OFF3, OFF4, SIZE, DATA, ACTION) =
		BYTE	(FLAGS,
			 LOC,
			 $BYTEOFFSET (OFF1, OFF2, OFF3, OFF4),
			 ACTION),
		WORD	(DATA,
			 SIZE)
		%;

MACRO
	NULL_FIELD	= 0,0,0,0%;


! The attribute control table itself.
!

BIND
	ATC	= UPLIT (

ATTRIBUTE (0,			M_PROTECTED, ATC_HEADER,   FH2$L_FILEOWNER,  5,  6, ACT_UIC2),
ATTRIBUTE (0,			M_PROTECTED, ATC_HEADER,   FH2$W_FILEPROT,   3,  2, ACT_FPRO),
ATTRIBUTE (ATR$C_UCHAR,		M_LOCKED,    ATC_HEADER,   FH2$L_FILECHAR,   4,  4, ACT_COPY),
ATTRIBUTE (ATR$C_RECATTR,	M_LOCKED,    ATC_HEADER,   FH2$W_RECATTR,   32, 32, ACT_COPY),
ATTRIBUTE (ATR$C_FILNAM,	0,	     ATC_IDENT,    FI2$T_FILENAME,  10, 20, ACT_R50_NAME),
ATTRIBUTE (ATR$C_FILTYP,	0,	     ATC_IDENT,    FI2$T_FILENAME,   4, 20, ACT_R50_TYPE),
ATTRIBUTE (ATR$C_FILVER,	0,	     ATC_IDENT,    FI2$T_FILENAME,   2, 20, ACT_R50_VER),
ATTRIBUTE (ATR$C_EXPDAT,	M_PROTECTED, ATC_IDENT,    FI2$Q_EXPDATE,    7,  8, ACT_DATE),
ATTRIBUTE (ATR$C_STATBLK,	M_READ_ONLY, ATC_FCB,      NULL_FIELD,      32,  0, ACT_STATBLK),
ATTRIBUTE (ATR$C_HEADER,	M_READ_ONLY, ATC_HEADER,   NULL_FIELD,     512,  0, ACT_COPY),
ATTRIBUTE (ATR$C_BLOCKSIZE,	0,	     ATC_ZERO,     NULL_FIELD,       2,  0, ACT_BLOCKSIZE),
ATTRIBUTE (ATR$C_USERLABEL,	0,	     ATC_ZERO,     NULL_FIELD,      80, 80, ACT_ZERO),
ATTRIBUTE (ATR$C_ASCDATES,	M_PROTECTED, ATC_IDENT,    NULL_FIELD,      35, 46, ACT_DATES),
ATTRIBUTE (ATR$C_ALCONTROL,	0,	     ATC_ZERO,     NULL_FIELD,      14,  0, ACT_NOP),
ATTRIBUTE (ATR$C_ENDLBLAST,	0,	     ATC_ZERO,     NULL_FIELD,       1,  0, ACT_NOP),
ATTRIBUTE (ATR$C_ASCNAME,	0,	     ATC_IDENT,    NULL_FIELD,      86, 20, ACT_FILENAME),
ATTRIBUTE (ATR$C_CREDATE,	M_PROTECTED, ATC_IDENT,    FI2$Q_CREDATE,    8,  8, ACT_COPY),
ATTRIBUTE (ATR$C_REVDATE,	M_PROTECTED, ATC_IDENT,    FI2$Q_REVDATE,    8,  8, ACT_COPY),
ATTRIBUTE (ATR$C_EXPDATE,	M_PROTECTED, ATC_IDENT,    FI2$Q_EXPDATE,    8,  8, ACT_COPY),
ATTRIBUTE (ATR$C_BAKDATE,	M_PROTECTED, ATC_IDENT,    FI2$Q_BAKDATE,    8,  8, ACT_COPY),
ATTRIBUTE (ATR$C_UIC,		M_PROTECTED, ATC_HEADER,   FH2$L_FILEOWNER,  4,  4, ACT_UIC4),
ATTRIBUTE (ATR$C_FPRO,		M_PROTECTED, ATC_HEADER,   FH2$W_FILEPROT,   2,  2, ACT_COPY),
ATTRIBUTE (ATR$C_RPRO,		M_PROTECTED, ATC_HEADER,   FH2$W_RECPROT,    2,  2, ACT_COPY),
ATTRIBUTE (ATR$C_ACLEVEL,	M_PROTECTED, ATC_HEADER,   FH2$B_ACC_MODE,   1,  1, ACT_ACLEVEL),
ATTRIBUTE (ATR$C_SEMASK,	M_PROTECTED, ATC_HEADER,   NULL_FIELD,       8,  8, ACT_ZERO),
ATTRIBUTE (ATR$C_UIC_RO,	M_READ_ONLY, ATC_HEADER,   FH2$L_FILEOWNER,  4,  4, ACT_COPY),
ATTRIBUTE (ATR$C_DIRSEQ,	M_READ_ONLY, ATC_FCB,      FCB$W_DIRSEQ,     2,  0, ACT_COPY),
ATTRIBUTE (ATR$C_BACKLINK,	M_PROTECTED, ATC_HEADER,   FH2$W_BACKLINK,   6,  6, ACT_COPY),
ATTRIBUTE (ATR$C_JOURNAL,	M_PROTECTED, ATC_HEADER,   FH2$W_JOURNAL,    2,  2, ACT_COPY),
ATTRIBUTE (ATR$C_HDR1_ACC,	M_PROTECTED, ATC_ZERO,     NULL_FIELD,       1,  0, ACT_BLANK),
ATTRIBUTE (ATR$C_ADDACLENT,	M_LOCKED,    ATC_ACL,      NULL_FIELD,     512,  0, ACT_ACL),
ATTRIBUTE (ATR$C_DELACLENT,	M_LOCKED,    ATC_ACL,      NULL_FIELD,     255,  0, ACT_ACL),
ATTRIBUTE (ATR$C_MODACLENT,	M_LOCKED,    ATC_ACL,      NULL_FIELD,     255,  0, ACT_ACL),
ATTRIBUTE (ATR$C_FNDACLENT,	M_READ_ONLY, ATC_ACL,      NULL_FIELD,     255,  0, ACT_ACL),
ATTRIBUTE (ATR$C_FNDACETYP,	M_READ_ONLY, ATC_ACL,      NULL_FIELD,     255,  0, ACT_ACL),
ATTRIBUTE (ATR$C_DELETEACL,	M_LOCKED,    ATC_ACL,      NULL_FIELD,     255,  0, ACT_ACL),
ATTRIBUTE (ATR$C_READACL,	M_READ_ONLY, ATC_ACL,      NULL_FIELD,     512,  0, ACT_ACL),
ATTRIBUTE (ATR$C_ACLLENGTH,	M_READ_ONLY, ATC_ACL,      NULL_FIELD,       4,  0, ACT_ACL),
ATTRIBUTE (ATR$C_READACE,	M_READ_ONLY, ATC_ACL,      NULL_FIELD,     255,  0, ACT_ACL),
ATTRIBUTE (ATR$C_RESERVED,	M_PROTECTED, ATC_RESERVED, NULL_FIELD,     380,  0, ACT_RESERVED),
ATTRIBUTE (ATR$C_HIGHWATER,	M_READ_ONLY, ATC_HEADER,   FH2$L_HIGHWATER,  4,  4, ACT_COPY),
ATTRIBUTE (ATR$C_ACCESS_MASK,	M_READ_ONLY, ATC_ZERO,     NULL_FIELD,       0,  0, ACT_ILLEGAL),
ATTRIBUTE (ATR$C_PRIVS_USED,	M_READ_ONLY, ATC_ACPGBL,   GBL_PRV,0,0,0,    4,  0, ACT_COPY),
ATTRIBUTE (ATR$C_MATCHING_ACE,	M_READ_ONLY, ATC_ACPGBL,   GBL_ACE,0,0,0,  255,  0, ACT_COPY),
ATTRIBUTE (ATR$C_ACCESS_MODE,	M_READ_ONLY, ATC_ZERO,     NULL_FIELD,       1,  0, ACT_ACMODE),
ATTRIBUTE (ATR$C_FILE_SPEC,	M_READ_ONLY, ATC_FID2NAME, NULL_FIELD,     512,  0, ACT_COPY),
ATTRIBUTE (ATR$C_CLASS_MASK,	M_PROTECTED OR
				M_LOCKED,    ATC_HEADER,   FH2$R_CLASS_PROT,20, 20, ACT_CLASS),
ATTRIBUTE (ATR$C_BUFFER_OFFSET,	0,	     ATC_ZERO,     NULL_FIELD,       0,  0, ACT_NOP)

		) : BBLOCKVECTOR [,8];

LITERAL
	MAX_CODE	= ATR$C_MAX_CODE;	! highest attribute code


!
! Protected bits in the file characteristics longword. These may not be
! modified by write attributes calls.
!
LITERAL
	PROTECTED_CHAR	=  FH2$M_CONTIG
			OR FH2$M_SPOOL
			OR FH2$M_BADBLOCK
			OR FH2$M_NOCHARGE
			OR FH2$M_MARKDEL;

GLOBAL ROUTINE READ_ATTRIB (HEADER, ABD) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the read attributes function. The
!	requested attributes are assembled into the buffer packet.
!
! CALLING SEQUENCE:
!	READ_ATTRIB (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of file header
!	ARG2: address of buffer descriptors
!
! IMPLICIT INPUTS:
!	IO_PACKET: I/O packet for this operation
!	PRIMARY_FCB: FCB of file
!
! OUTPUT PARAMETERS:
!	ARG2: address of buffer descriptors
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1 if successful
!	0 if error
!
! SIDE EFFECTS:
!	attribute data written into buffer packet
!
!--

BEGIN

MAP
	HEADER		: REF BBLOCK,	! file header arg
	ABD		: REF BBLOCKVECTOR [,ABD$C_LENGTH];
					! buffer descriptor arg

LOCAL
	LOCAL_HEADER	: REF BBLOCK,	! local copy of the header address
	ACCESS_MODE,			! access mode to set for attribute buffer
	STATUS;				! routine exit status

BIND_COMMON;

EXTERNAL ROUTINE
	PMS_START_SUB	: L_NORM,	! start subfunction metering
	PMS_END_SUB	: L_NORM,	! end subfunction metering
	GET_TIME	: L_NORM,	! convert 64 bit time to ASCII
	MAKE_NAMEBLOCK	: L_NORM,	! convert file string into RAD-50
	ACL_DISPATCH	: L_NORM;	! ACL action dispatcher


ENABLE READ_HANDLER;

! Start metering for this subfunction.
!

PMS_START_SUB (PMS_RWATT);

STATUS = 1;				! assume success
LOCAL_HEADER = .HEADER;			! Copy header address

! Set the buffered read bit in the I/O packet to indicate to IO_DONE that
! the attribute buffers are valid.
!

IO_PACKET[IRP$V_FUNC] = 1;
ACCESS_MODE = .IO_PACKET[IRP$V_MODE];

! Scan the buffer packet, picking up each entry. The first byte of the
! text is the attribute code, and must be overwritten with the access
! mode of the request for the I/O completion processing.
!

INCR I FROM ABD$C_ATTRIB TO .IO_PACKET[IRP$W_BCNT]-1 DO
    BEGIN

    LITERAL
	ATB_LENGTH	= FI2$S_FILENAME+FI2$S_FILENAMEXT; ! length of temp attribute buffer

    LOCAL
	P,				! pointer to attribute text
	T,				! temporary pointer
	COUNT,				! attribute size desired
	ADDRESS		: REF BBLOCK,	! address of attribute
	CODE,				! attribute code
	MAX_COUNT,			! max size of attribute
	ACTION		: BYTE,		! code of action routine
	NAME_BLOCK	: BBLOCK [NMB$C_LENGTH], ! buffer for file name block
	ATT_BUFFER	: BBLOCK [ATB_LENGTH];	! buffer to build reformatted attribute text

    P = .ABD[.I, ABD$W_TEXT] + ABD[.I, ABD$W_TEXT];
    COUNT = .ABD[.I, ABD$W_COUNT];
    CODE = .(.P)<0,8> - 1;
    (.P)<0,8> = .ACCESS_MODE;
    P = .P + 1;

! Check the attribute code for legality, and then check the requested
! size against the limit. If an error exit is made, first truncate the
! descriptor count to inhibit return of the unprocessed descriptors.
!

    IF .CODE GTR MAX_CODE - 1
    THEN
	BEGIN
	IO_PACKET[IRP$W_BCNT] = .I;
	(ERR_STATUS (SS$_BADATTRIB); STATUS = 0; EXITLOOP);
	END;

    MAX_COUNT = .ATC[.CODE, ATC_MAX_SIZE];
    IF .COUNT GTR .MAX_COUNT
    THEN
	BEGIN
	IO_PACKET[IRP$W_BCNT] = .I;
	(ERR_STATUS (SS$_BADATTRIB); STATUS = 0; EXITLOOP);
	END;


! Get the action routine code first.
!

    ACTION = .ATC[.CODE, ATC_ACTION];

! Compute the address of the attribute.
!
    
    ADDRESS =
	(
	CASE .ATC[.CODE, ATC_LOCATION] FROM 0 TO ATC_LASTATC OF
	    SET
	    [ATC_ZERO]:		ATT_BUFFER;
	    [ATC_FCB]:		.PRIMARY_FCB;
	    [ATC_HEADER]:	BEGIN
				IF .ATC[.CODE, ATC_OFFSET]
				 + .ATC[.CODE, ATC_DATA_SIZE] GTRU
				   .LOCAL_HEADER[FH2$B_IDOFFSET]*2
				THEN ACTION = ACT_ZERO;
				.LOCAL_HEADER
				END;
	    [ATC_IDENT]:	BEGIN
				IF .ATC[.CODE, ATC_OFFSET]
				 + .ATC[.CODE, ATC_DATA_SIZE] GTRU
				   .LOCAL_HEADER[FH2$B_MPOFFSET]*2
				 - .LOCAL_HEADER[FH2$B_IDOFFSET]*2
				THEN ACTION = ACT_ZERO;
				.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_IDOFFSET]*2
				END;
	    [ATC_MAP]:		.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_MPOFFSET]*2;
	    [ATC_ACL]:		.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_ACOFFSET]*2;
	    [ATC_RESERVED]:	.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_RSOFFSET]*2;
	    [ATC_ACPGBL]:	(CASE .ATC[.CODE, ATC_OFFSET] FROM 0 TO GBL_LASTGBL OF
				    SET
				    [GBL_PRV]:	PRIVS_USED;
				    [GBL_ACE]:	BEGIN
						CH$FILL (0, ATR$S_READACE - .MATCHING_ACE[ACE$B_SIZE],
							    MATCHING_ACE + .MATCHING_ACE[ACE$B_SIZE]);
						MATCHING_ACE
						END;
				    TES) - .ATC[.CODE, ATC_OFFSET];
	    [ATC_FID2NAME]:	BEGIN
				FID_TO_SPEC (.LOCAL_HEADER);
				LOCAL_HEADER = .FILE_HEADER;
				FILE_SPEC_LEN
				END;
	    TES
	)
	+ .ATC[.CODE, ATC_OFFSET];
    
    
! Finally execute the action routine.
!
    
    CASE .ACTION FROM 0 TO ACT_LASTACT OF
	SET
    
	[ACT_NOP]:	COUNT = 0;
    
	[ACT_ILLEGAL]:	BEGIN
			IO_PACKET[IRP$W_BCNT] = .I;
			(ERR_STATUS (SS$_BADATTRIB); STATUS = 0; EXITLOOP);
			END;
    
	[ACT_COPY,
	 ACT_ACLEVEL,
	 ACT_UIC4]:	0;

	[ACT_CLASS]:	BEGIN
			CH$FILL (0, .COUNT, .P);
			IF .HEADER[FH2$B_IDOFFSET]*2 LEQU FH2$C_LENGTH
			THEN COUNT = 0;
			END;
    
	[ACT_STATBLK]:	BEGIN
			ATT_BUFFER[SBK$L_STLBN] = ROT (.ADDRESS[FCB$L_STLBN], 16);
			ATT_BUFFER[SBK$L_FILESIZE] = ROT (.ADDRESS[FCB$L_FILESIZE], 16);
			ATT_BUFFER[SBK$B_ACNT]  = .ADDRESS[FCB$W_ACNT];
			ATT_BUFFER[SBK$B_LCNT]  = .ADDRESS[FCB$W_LCNT];
			ATT_BUFFER[SBK$L_FCB] = .ADDRESS;
			(ATT_BUFFER[SBK$L_FCB]+4)<0,16> = 0; ! unused field
			ATT_BUFFER[SBK$W_ACNT] = .ADDRESS[FCB$W_ACNT];
			ATT_BUFFER[SBK$W_LCNT] = .ADDRESS[FCB$W_LCNT];
			ATT_BUFFER[SBK$W_WCNT] = .ADDRESS[FCB$W_WCNT];
			ATT_BUFFER[SBK$W_TCNT] = .ADDRESS[FCB$W_TCNT];
			ATT_BUFFER[SBK$L_READS] = 0;
			ATT_BUFFER[SBK$L_WRITES] = 0;
			IF .CURRENT_WINDOW NEQ 0
			THEN
			    BEGIN
			    ATT_BUFFER[SBK$L_READS] = .CURRENT_WINDOW[WCB$L_READS];
			    ATT_BUFFER[SBK$L_WRITES] = .CURRENT_WINDOW[WCB$L_WRITES];
			    END;
			ADDRESS = ATT_BUFFER;
			END;
    
	[ACT_BLOCKSIZE]: ADDRESS = UPLIT (512);

	[ACT_ZERO]:	BEGIN
			CH$FILL (0, .COUNT, .P);
			COUNT = 0;
			END;

	[ACT_BLANK]:	BEGIN
			ADDRESS = UPLIT BYTE (' ');
			END;

	[ACT_UIC2]:	BEGIN
			MAP ATT_BUFFER : VECTOR [,BYTE];
			ATT_BUFFER[0] = .(.ADDRESS)<0,8>;
			ATT_BUFFER[1] = .(.ADDRESS)<16,8>;
			IF .(.ADDRESS)<8,8> NEQ 0
			OR .(.ADDRESS)<24,8> NEQ 0
			THEN
			    BEGIN
			    ATT_BUFFER[0] = -1;
			    ATT_BUFFER[1] = -1;
			    END;
			(ATT_BUFFER[2])<0,16> = .LOCAL_HEADER[FH2$W_FILEPROT];
			ATT_BUFFER[4] = .LOCAL_HEADER[FH2$L_FILECHAR];
			ADDRESS = ATT_BUFFER;
			END;

	[ACT_FPRO]:	BEGIN
			MAP ATT_BUFFER : VECTOR [,BYTE];
			(ATT_BUFFER[0])<0,16> = .(.ADDRESS)<0,16>;
			ATT_BUFFER[2] = .LOCAL_HEADER[FH2$L_FILECHAR];
			ADDRESS = ATT_BUFFER;
			END;

	[ACT_FILENAME]:	BEGIN
			T = ATT_BUFFER;
			CH$COPY (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ' ',
				 FI2$S_FILENAME+FI2$S_FILENAMEXT, ATT_BUFFER);
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN CH$MOVE (FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT],
				      ATT_BUFFER + FI2$S_FILENAME);
			MAKE_NAMEBLOCK (FI2$S_FILENAME, ATT_BUFFER, NAME_BLOCK);
			ADDRESS = .T;
			END;

	[ACT_R50_NAME]:	BEGIN
			T = NAME_BLOCK[NMB$W_NAME];
			CH$COPY (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ' ',
				 FI2$S_FILENAME+FI2$S_FILENAMEXT, ATT_BUFFER);
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN
			    BEGIN
			    CH$MOVE (FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT],
				     ATT_BUFFER + FI2$S_FILENAME);
			    MAKE_NAMEBLOCK (FI2$S_FILENAME+FI2$S_FILENAMEXT,
					    ATT_BUFFER, NAME_BLOCK);
			    END
			ELSE MAKE_NAMEBLOCK (FI2$S_FILENAME, ATT_BUFFER, NAME_BLOCK);
			ADDRESS = .T;
			END;

	[ACT_R50_TYPE]:	BEGIN
			T = NAME_BLOCK[NMB$W_TYPE];
			CH$COPY (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ' ',
				 FI2$S_FILENAME+FI2$S_FILENAMEXT, ATT_BUFFER);
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN
			    BEGIN
			    CH$MOVE (FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT],
				     ATT_BUFFER + FI2$S_FILENAME);
			    MAKE_NAMEBLOCK (FI2$S_FILENAME+FI2$S_FILENAMEXT,
					    ATT_BUFFER, NAME_BLOCK);
			    END
			ELSE MAKE_NAMEBLOCK (FI2$S_FILENAME, ATT_BUFFER, NAME_BLOCK);
			ADDRESS = .T;
			END;

	[ACT_R50_VER]:	BEGIN
			T = NAME_BLOCK[NMB$W_VERSION];
			CH$COPY (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ' ',
				 FI2$S_FILENAME+FI2$S_FILENAMEXT, ATT_BUFFER);
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN
			    BEGIN
			    CH$MOVE (FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT],
				     ATT_BUFFER + FI2$S_FILENAME);
			    MAKE_NAMEBLOCK (FI2$S_FILENAME+FI2$S_FILENAMEXT,
					    ATT_BUFFER, NAME_BLOCK);
			    END
			ELSE MAKE_NAMEBLOCK (FI2$S_FILENAME, ATT_BUFFER, NAME_BLOCK);
			ADDRESS = .T;
			END;

	[ACT_DATE]:	BEGIN
			GET_TIME (ATT_BUFFER, .ADDRESS);
			ADDRESS = ATT_BUFFER;
			END;

	[ACT_DATES]:	BEGIN
			ATT_BUFFER<0,16> = .ADDRESS[FI2$W_REVISION];
			GET_TIME (ATT_BUFFER+02, ADDRESS[FI2$Q_REVDATE]);
			GET_TIME (ATT_BUFFER+15, ADDRESS[FI2$Q_CREDATE]);
			GET_TIME (ATT_BUFFER+28, ADDRESS[FI2$Q_EXPDATE]);
			ADDRESS = ATT_BUFFER;
			END;

	[ACT_ACL]:	BEGIN
			IF .CODE + 1 EQL ATR$C_ADDACLENT
			OR .CODE + 1 EQL ATR$C_DELACLENT
			OR .CODE + 1 EQL ATR$C_MODACLENT
			OR .CODE + 1 EQL ATR$C_DELETEACL
			THEN STATUS = 1
			ELSE STATUS = ACL_DISPATCH (.CODE, .ADDRESS, .COUNT, .P);
			IF NOT .STATUS
			THEN (CURRENT_FIB[FIB$L_ACL_STATUS] = .STATUS; STATUS = 1);
			COUNT = 0;
			END;

	[ACT_RESERVED]:	BEGIN
			CH$FILL (0, .COUNT, .P);
			IF ((.P)<0,16> = $BYTEOFFSET (FH2$W_CHECKSUM) -
					 .LOCAL_HEADER[FH2$B_RSOFFSET] * 2) GTR 0
			THEN CH$COPY (.(.P)<0,16>, .ADDRESS, 0, .COUNT, .P + 2);
			COUNT = 0;
			END;

	[ACT_ACMODE]:	BEGIN
			(.P-1)<0,8> = .IO_PACKET[IRP$V_MODE];
			ACCESS_MODE = MAXU (.IO_PACKET[IRP$V_MODE], .(.P)<0,8>);
			COUNT = 0;
			END;

	TES;
	CH$MOVE (.COUNT, .ADDRESS, .P); ! finally copy the attribute



    END;				! end of loop

! Stop metering of this subfunction
!

PMS_END_SUB ();

RETURN .STATUS;

END;					! end of routine READ_ATTRIB

GLOBAL ROUTINE FID_TO_SPEC (HEADER) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts the specified file-ID (contained in the header
!	supplied) to a full file specification.  Because the RMS limit of
!	256 bytes is NOT enforced, it is actually possible to get a file
!	spec string of 444 bytes.
!
!	If a file pointed to by the backlink does not exist, translation
!	stops, and a question mark is inserted in place of the directory
!	name.
!
! CALLING SEQUENCE:
!	FID_TO_SPEC (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the file header
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	HEADER		: REF BBLOCK;		! Address of the header

LINKAGE
	L_CVT_DEVNAM	= JSB (REGISTER = 0,	! Buffer length
			       REGISTER = 1,	! Buffer address
			       REGISTER = 4,	! Cluster node conversion flag
			       REGISTER = 5;	! UCB address
			       REGISTER = 1);	! Length of converted name

LITERAL
	NODE_LEN	= 15,			! Maximum cluster node name length
	DEVNAME_LEN	= 15,			! Maximum device name length
	UNIT_LEN	= 5,			! Maximum unit number length
	FILENAME_LEN	= 39,			! Maximun file name length
	FILETYPE_LEN	= 39,			! Maximum file type length
	FILEVER_LEN	= 5,			! Maximum version length

! The maximum number of directory levels to traverse is calculated from the
! available storage (for FULL_FILE_SPEC).

	MAX_DIR_LEVEL	= (1022 - (NODE_LEN + DEVNAME_LEN + UNIT_LEN +
				   FILENAME_LEN + FILETYPE_LEN + FILEVER_LEN + 1)) /
			  (FILENAME_LEN + 1),

! Determine the maximum sizes of the various portions of a file specification.

	FULLDEV_LEN	= NODE_LEN + 1 +	! Full device spec length
			  DEVNAME_LEN + UNIT_LEN + 1,
	FULLDIR_LEN	= 1 + (FILENAME_LEN + 1) * (MAX_DIR_LEVEL + 1),	! Max dir spec length
	FULLFILE_LEN	= FILENAME_LEN + 1 +	! Max file name length
			  FILETYPE_LEN + 1 +	!   including type & version
			  FILEVER_LEN,
	FULLSPEC_LEN	= 2 + FULLDEV_LEN +	! Maximum file spec length
			  FULLDIR_LEN +		! Includes word size prefix
			  FULLFILE_LEN;

LOCAL
	DEVICE_LEN,				! Length of the device name
	DIR_HEADER	: REF BBLOCK,		! Current directory file header
	IDENT_AREA	: REF BBLOCK,		! Address of header ident area
	DIR_ID		: BBLOCK [FID$C_LENGTH],	! Directory FID
	END_NAME;				! End of the directory/file name

BIND_COMMON;

EXTERNAL ROUTINE
	READ_HEADER	: L_NORM,		! Read & validate file header
	SERIAL_FILE	: L_NORM,		! Synchronization locking
	RELEASE_SERIAL_LOCK : L_NORM NOVALUE,	! Release synchronization lock
	IOC$CVT_DEVNAM	: L_CVT_DEVNAM ADDRESSING_MODE (GENERAL);

BIND
	DEVICE_NAME	= FULL_FILE_SPEC	: VECTOR [,BYTE],	! Device name spec
	DIR_NAME	= FULL_FILE_SPEC[FULLDEV_LEN + 1]	: VECTOR [,BYTE],	! Directory name storage
	FILE_NAME	= FULL_FILE_SPEC[FULLDEV_LEN + 1 +	! File name storage
					 FULLDIR_LEN]	: VECTOR [,BYTE];

! Initialize all of the necessary storage.

CH$FILL (0, FULLSPEC_LEN, FULL_FILE_SPEC);
CH$MOVE (FID$C_LENGTH, HEADER[FH2$W_BACKLINK], DIR_ID);
FILE_SPEC_LEN[0] = 0;

! Save the file name from the current file header as the real file name.

IDENT_AREA = .HEADER + .HEADER[FH2$B_IDOFFSET]*2;
CH$MOVE (FI2$S_FILENAME, IDENT_AREA[FI2$T_FILENAME], FILE_NAME[1]);
IF .HEADER[FH2$B_MPOFFSET] - .HEADER[FH2$B_IDOFFSET]
GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
THEN CH$MOVE (FI2$S_FILENAMEXT, IDENT_AREA[FI2$T_FILENAMEXT],
				FILE_NAME[FI2$S_FILENAME + 1]);
INCR J FROM 0 TO FI2$S_FILENAME + FI2$S_FILENAMEXT
DO
    BEGIN
    IF .FILE_NAME[.J + 1] EQL ' ' THEN EXITLOOP;
    FILE_NAME[0] = .FILE_NAME[0] + 1;
    END;

! Loop through all of the directories back to the MFD, saving the directory
! names.
! Before doing so, release the current primary lock index.  This must be
! done because tracking back up through the directories for this file
! would cause synchronization deadlocks with other processes coming down
! through the directories on an access to this same file.
!

IF .PRIM_LCKINDX NEQ 0
    AND .PRIM_LCKINDX NEQ .DIR_LCKINDX
THEN
    BEGIN
    IF .PRIMARY_FCB NEQ 0
    THEN
	BEGIN
	CLEANUP_FLAGS [CLF_PFCB_REF_UP] = 1;
	PRIMARY_FCB [FCB$W_REFCNT] = .PRIMARY_FCB [FCB$W_REFCNT] + 1;
	END;

    RELEASE_SERIAL_LOCK (.PRIM_LCKINDX);
    END;

DECR J FROM MAX_DIR_LEVEL TO 0
DO
    BEGIN
    LOCAL
	TMPINDX;

    IF .DIR_ID[FID$W_NUM] EQL 0 AND .DIR_ID[FID$B_NMX] EQL 0
    THEN
	BEGIN
	IF .J NEQ MAX_DIR_LEVEL
	THEN
	    BEGIN
	    DIR_NAME[.J * (FILENAME_LEN + 1)] = 1;
	    DIR_NAME[.J * (FILENAME_LEN + 1) + 1] = '?';
	    END;
	EXITLOOP;
	END;

    IF .DIR_ID[FID$W_NUM] EQL FID$C_MFD AND .DIR_ID[FID$B_NMX] EQL 0
    AND .J NEQ MAX_DIR_LEVEL THEN EXITLOOP;

! Synchronize on the desired file prior to the read_header call.
! If this is actually the directory we may have already accessed,
! then clear tmpindx so that we do not attempt to release it at
! the end of this loop.
!

    STSFLGS [STS_HAD_LOCK] = 0;
    TMPINDX = SERIAL_FILE (DIR_ID);

    IF .STSFLGS [STS_HAD_LOCK]
    THEN
	TMPINDX = 0;

    DIR_HEADER = READ_HEADER (DIR_ID, 0);

    IF .DIR_HEADER EQL 0
    THEN
	BEGIN
	DIR_NAME[.J * (FILENAME_LEN + 1)] = 1;
	DIR_NAME[.J * (FILENAME_LEN + 1) + 1] = '?';
	EXITLOOP;
	END;
    IDENT_AREA = .DIR_HEADER + .DIR_HEADER[FH2$B_IDOFFSET]*2;
    CH$MOVE (FI2$S_FILENAME, IDENT_AREA[FI2$T_FILENAME],
			     DIR_NAME[.J * (FILENAME_LEN + 1) + 1]);
    IF .HEADER[FH2$B_MPOFFSET] - .HEADER[FH2$B_IDOFFSET]
    GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
    THEN CH$MOVE (FILENAME_LEN - FI2$S_FILENAME, IDENT_AREA[FI2$T_FILENAMEXT],
						 DIR_NAME[.J * (FILENAME_LEN + 1) +
							  FI2$S_FILENAME + 1]);
    INCR K FROM 1 TO FILENAME_LEN
    DO
	BEGIN
	IF .DIR_NAME[.J * (FILENAME_LEN + 1) + .K] EQL '.' THEN EXITLOOP;
	DIR_NAME[.J * (FILENAME_LEN + 1)] = .DIR_NAME[.J * (FILENAME_LEN + 1)] + 1;
	END;

! If all the way back up to the mfd, stop.  Release the temporary lock
! on the directory just looked at before exiting the loop.
!

    IF .DIR_ID[FID$W_NUM] EQL FID$C_MFD AND .DIR_ID[FID$B_NMX] EQL 0
    THEN
	BEGIN
	IF .TMPINDX NEQ 0
	THEN
	    RELEASE_SERIAL_LOCK (.TMPINDX);

	EXITLOOP;
	END;

! Save the backlink from this one to go around the loop again.
! Once the temporary serialization lock is released, the buffer
! may be recycled to another process.
!

    CH$MOVE (FID$C_LENGTH, DIR_HEADER[FH2$W_BACKLINK], DIR_ID);

    IF .TMPINDX NEQ 0
    THEN
	RELEASE_SERIAL_LOCK (.TMPINDX);

    END;

! Get the device name.

IOC$CVT_DEVNAM (FULLDEV_LEN, DEVICE_NAME, 0, .IO_PACKET[IRP$L_UCB]; DEVICE_LEN);
FILE_SPEC_LEN[0] = .FILE_SPEC_LEN[0] + .DEVICE_LEN;

! Start building the directory specification.

FULL_FILE_SPEC[.FILE_SPEC_LEN[0]] = '[';
FILE_SPEC_LEN[0] = .FILE_SPEC_LEN[0] + 1;

INCR J FROM 0 TO MAX_DIR_LEVEL
DO
    BEGIN
    IF (END_NAME = .DIR_NAME[.J * (FILENAME_LEN + 1)]) NEQ 0
    THEN
	BEGIN
	CH$COPY (.END_NAME, DIR_NAME[.J * (FILENAME_LEN + 1) + 1],
		 '.',
		 .END_NAME + 1, FULL_FILE_SPEC[.FILE_SPEC_LEN[0]]);
	FILE_SPEC_LEN[0] = .FILE_SPEC_LEN[0] + .END_NAME + 1;
	END;
    END;

! Tie off the directory specification.

IF .FULL_FILE_SPEC[.FILE_SPEC_LEN[0] - 1] EQL '['
THEN FILE_SPEC_LEN[0] = .FILE_SPEC_LEN[0] + 1;

FULL_FILE_SPEC[.FILE_SPEC_LEN[0] - 1] = ']';

! Now add in the file name.

END_NAME = .FILE_NAME[0];
CH$MOVE (.END_NAME, FILE_NAME[1], FULL_FILE_SPEC[.FILE_SPEC_LEN[0]]);
FILE_SPEC_LEN[0] = .FILE_SPEC_LEN[0] + .END_NAME;

! Reacquire the primary header serialization lock.
! Turn everybody back to the primary file header.

IF .PRIM_LCKINDX NEQ 0
THEN
    BEGIN
    PRIM_LCKINDX = SERIAL_FILE (IF .PRIMARY_FCB NEQ 0
				THEN PRIMARY_FCB [FCB$W_FID]
				ELSE CURRENT_FIB [FIB$W_FID]);

    IF TESTBITSC (CLEANUP_FLAGS [CLF_PFCB_REF_UP])
    THEN
	PRIMARY_FCB [FCB$W_REFCNT] = .PRIMARY_FCB [FCB$W_REFCNT] - 1;

    READ_HEADER (CURRENT_FIB[FIB$W_FID], .PRIMARY_FCB);
    END;

RETURN;

END;						! End of routine FID_TO_SPEC

ROUTINE READ_HANDLER (SIG_ARGS, MECH_ARGS) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is a condition handler for READ_ATTRIB. It catches
!	error exits from MAKE_NAMEBLOCK (due to garbage in the file header
!	name string) and causes them to be ignored.
!
! CALLING SEQUENCE:
!	READ_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal array
!	ARG2: address of mechanism array
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	stack unwound to return to call site in READ_ATTRIB
!
!--

BEGIN

MAP
	SIG_ARGS		: REF BBLOCK,	! signal array arg
	MECH_ARGS	: REF BBLOCK;	! mechanism array arg


! Check the signal code. The only permissible ones are SS$_UNWIND, which
! is ignored, and SS$_CMODUSER. The error status is the 16 bit CHMU code.
!

IF .SIG_ARGS[CHF$L_SIG_NAME] EQL SS$_UNWIND THEN RETURN;
IF .SIG_ARGS[CHF$L_SIG_NAME] NEQ SS$_CMODUSER
THEN BUG_CHECK (UNXSIGNAL, FATAL, 'Unexpected signal name in ACP');

$UNWIND (DEPADR = MECH_ARGS[CHF$L_MCH_DEPTH]);

RETURN;

END;					! end of routine READ_HANDLER

GLOBAL ROUTINE WRITE_ATTRIB (HEADER, ABD, CONTROL_ACCESS) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the write attributes function. The
!	requested attributes are taken from the buffer packet.
!
! CALLING SEQUENCE:
!	READ_ATTRIB (ARG1, ARG2, ARG3)
!
! INPUT PARAMETERS:
!	ARG1: address of file header
!	ARG2: address of buffer descriptors
!	ARG3: 1 = check for control access to the file
!	      0 = no control access check
!
! IMPLICIT INPUTS:
!	IO_PACKET: I/O packet for this operation
!	PRIMARY_FCB: FCB of file
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	attribute data written into appropriate places
!
!--

BEGIN

MAP
	HEADER		: REF BBLOCK,	! file header arg
	ABD		: REF BBLOCKVECTOR [,ABD$C_LENGTH];
					! buffer descriptor arg

LOCAL
	LOCAL_HEADER	: REF BBLOCK,	! Local copy of the header address
	CTL_ACC_GRANTED,		! Flag indicating control access granted
	ACL_MODIFIED,			! flag indicating ACL has been modified
	SAVE_HIBLK,			! saved copy of file's HIBLK
	SAVE_CHAR	: BBLOCK [4],	! initial state of protected attributes
	STATUS;				! routine exit status

BIND_COMMON;

EXTERNAL ROUTINE
	PMS_START_SUB	: L_NORM,	! start subfunction metering
	PMS_END_SUB	: L_NORM,	! end subfunction metering
	CHECKSUM	: L_NORM,	! Checksum the header
	MARK_DIRTY	: L_NORM,	! mark buffer for write-back
	UPDATE_DIRSEQ	: L_NORM,	! update UCB directory sequence count
	KILL_BUFFERS	: L_NORM,	! flush a file from the buffer cache
	KILL_DINDX	: L_NORM NOVALUE, ! kill directory index
	MAKE_NAMEBLOCK	: L_NORM,	! convert file string to RAD-50 name block
	MAKE_STRING	: L_NORM,	! convert name block into file string
	READ_HEADER	: L_NORM,	! read a file header
	ACL_DISPATCH	: L_NORM,	! ACL action dispatcher
	ACL_BUILDACL	: L_NORM,	! rebuild ACL in file header
	CHECK_PROTECT	: L_NORM;	! Protection checking routine


! Start metering for this subfunction.
!

PMS_START_SUB (PMS_RWATT);

LOCAL_HEADER = .HEADER;
CTL_ACC_GRANTED = 0;
ACL_MODIFIED = 0;
STATUS = SS$_NORMAL;				! Assume success

! Set the appropriate cleanup flags and save the initial state of the
! protected file characteristics.
!

CHECKSUM (.LOCAL_HEADER);
MARK_DIRTY (.LOCAL_HEADER);
CLEANUP_FLAGS[CLF_FIXFCB] = 1;

SAVE_CHAR = .LOCAL_HEADER[FH2$L_FILECHAR];
SAVE_HIBLK = .BBLOCK [LOCAL_HEADER[FH2$W_RECATTR], FAT$L_HIBLK];


! Scan the buffer packet, picking up each entry. The first byte of the
! text is the attribute code.
!

INCR I FROM ABD$C_ATTRIB TO .IO_PACKET[IRP$W_BCNT]-1 DO
    BEGIN

    LOCAL
	P,				! pointer to attribute text
	T,				! temporary pointer
	COUNT,				! attribute size desired
	ADDRESS		: REF BBLOCK,	! address of attribute
	CODE,				! attribute code
	MAX_COUNT,			! max size of attribute
	ACTION		: BYTE,		! code of action routine
	ATT_BUFFER	: BBLOCK [44];	! attribute copy buffer

    P = .ABD[.I, ABD$W_TEXT] + ABD[.I, ABD$W_TEXT];
    COUNT = .ABD[.I, ABD$W_COUNT];
    CODE = .(.P)<0,8> - 1;
    P = .P + 1;

! Check the attribute code for legality, and then check the requested
! size against the limit.
!

    IF .CODE GTR MAX_CODE - 1
    THEN (STATUS = SS$_BADATTRIB; EXITLOOP);

    MAX_COUNT = .ATC[.CODE, ATC_MAX_SIZE];
    IF .COUNT GTR .MAX_COUNT
    THEN (STATUS = SS$_BADATTRIB; EXITLOOP);

    IF .ATC[.CODE, ATC_PROTECTED]
    THEN
	BEGIN

! Most of the protected fields will affect the protection checking, so
! mark other fcbs as stale to cause them to reconstruct their fcbs from
! the header.
!

	CLEANUP_FLAGS [CLF_MARKFCBSTALE] = 1;

	IF .CONTROL_ACCESS AND NOT .CTL_ACC_GRANTED
	THEN
	    BEGIN

! Restore protected field in case the protection check fails.
!

	    BBLOCK [LOCAL_HEADER[FH2$W_RECATTR], FAT$L_HIBLK] = .SAVE_HIBLK;
	    CHECK_PROTECT (WRATT_ACCESS, .LOCAL_HEADER, .PRIMARY_FCB,
			   MAXU (.IO_PACKET[IRP$V_MODE], .CURRENT_FIB[FIB$B_AGENT_MODE]));

! Control access is allowed.  Note this for future use, to avoid additional
! (unneeded) protection checks.
!

	    CTL_ACC_GRANTED = 1;
	    END;
	END;


! Compute the action routine code.
!

    ACTION = .ATC[.CODE, ATC_ACTION];
    IF .ATC[.CODE, ATC_READ_ONLY] AND .ACTION NEQ ACT_ACL
    THEN ACTION = ACT_NOP;

! Compute the address of the attribute.
!
    
    ADDRESS =
	(
	CASE .ATC[.CODE, ATC_LOCATION] FROM 0 TO ATC_LASTATC OF
	    SET
	    [ATC_ZERO,
	     ATC_ACPGBL,
	     ATC_FID2NAME]:	ATT_BUFFER;
	    [ATC_FCB]:		.PRIMARY_FCB;
	    [ATC_HEADER]:	BEGIN
				IF .ATC[.CODE, ATC_OFFSET]
				 + .ATC[.CODE, ATC_DATA_SIZE] GTRU
				   .LOCAL_HEADER[FH2$B_IDOFFSET]*2
				THEN ACTION = ACT_ZERO;
				.LOCAL_HEADER
				END;
	    [ATC_IDENT]:	BEGIN
				IF .ATC[.CODE, ATC_OFFSET]
				 + .ATC[.CODE, ATC_DATA_SIZE] GTRU
				   .LOCAL_HEADER[FH2$B_MPOFFSET]*2
				 - .LOCAL_HEADER[FH2$B_IDOFFSET]*2
				THEN ACTION = ACT_ZERO;
				.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_IDOFFSET]*2
				END;
	    [ATC_MAP]:		.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_MPOFFSET]*2;
	    [ATC_ACL]:		.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_ACOFFSET]*2;
	    [ATC_RESERVED]:	.LOCAL_HEADER + .LOCAL_HEADER[FH2$B_RSOFFSET]*2;
	    TES
	)
	+ .ATC[.CODE, ATC_OFFSET];
    
    
! Finally execute the action routine.
!
    
    CASE .ACTION FROM 0 TO ACT_LASTACT OF
	SET
    
	[ACT_NOP,
	 ACT_BLOCKSIZE,
	 ACT_ZERO,
	 ACT_BLANK,
	 ACT_ACMODE,
	 ACT_STATBLK]:	0;
    
	[ACT_ILLEGAL]:	(STATUS = SS$_BADATTRIB; EXITLOOP);

	[ACT_UIC2]:	BEGIN
			LOCAL UIC;
			UIC = ..ADDRESS;
			UIC<0,16> = .(.P)<0,8>;
			IF .COUNT GEQ 2
			THEN UIC<16,16> = .(.P+1)<0,8>;
			STATUS = CHANGE_OWNER (.UIC, .PRIMARY_FCB, .LOCAL_HEADER);
			IF NOT .STATUS THEN EXITLOOP;
			LOCAL_HEADER = .FILE_HEADER;
			IF .COUNT GEQ 3
			THEN (LOCAL_HEADER[FH2$W_FILEPROT])<0,8> = .(.P+2)<0,8>;
			IF .COUNT GEQ 4
			THEN (LOCAL_HEADER[FH2$W_FILEPROT])<8,8> = .(.P+3)<0,8>;
			IF .COUNT GEQ 5
			THEN (LOCAL_HEADER[FH2$L_FILECHAR])<0,8> = .(.P+4)<0,8>;
			CLEANUP_FLAGS [CLF_MARKFCBSTALE] = 1;
			END;

	[ACT_UIC4]:	BEGIN
			LOCAL UIC;
			UIC = ..ADDRESS;
			CH$MOVE (.COUNT, .P, UIC);
			STATUS = CHANGE_OWNER (.UIC, .PRIMARY_FCB, .LOCAL_HEADER);
			LOCAL_HEADER = .FILE_HEADER;
			IF NOT .STATUS THEN EXITLOOP;
			CLEANUP_FLAGS [CLF_MARKFCBSTALE] = 1;
			END;

	[ACT_CLASS]:	BEGIN
			LOCAL	CLASS_BLOCK	: BBLOCK [ATR$S_CLASS_MASK];
			CH$COPY (.COUNT, .P, 0, ATR$S_CLASS_MASK, CLASS_BLOCK);
			STATUS = CHANGE_CLASS (.LOCAL_HEADER, CLASS_BLOCK);
			IF NOT .STATUS THEN EXITLOOP;
			CLEANUP_FLAGS [CLF_MARKFCBSTALE] = 1;
			END;

	[ACT_FPRO]:	BEGIN
			(LOCAL_HEADER[FH2$W_FILEPROT])<0,8> = .(.P+0)<0,8>;
			IF .COUNT GEQ 2
			THEN (LOCAL_HEADER[FH2$W_FILEPROT])<8,8> = .(.P+1)<0,8>;
			IF .COUNT GEQ 3
			THEN (LOCAL_HEADER[FH2$L_FILECHAR])<0,8> = .(.P+2)<0,8>;
			CLEANUP_FLAGS [CLF_MARKFCBSTALE] = 1;
			END;

	[ACT_ACLEVEL]:	BEGIN
			LOCAL MODE;
			(.ADDRESS)<0,8> = .(.P)<0,8>;
			MODE = NOT MAXU (.IO_PACKET[IRP$V_MODE], .CURRENT_FIB[FIB$B_AGENT_MODE]) AND 3;
			INCR J FROM 0 TO 3
			DO
			    BEGIN
			    IF .(.ADDRESS)<.J*2,2> GTRU .MODE
			    THEN (.ADDRESS)<.J*2,2> = .MODE;
			    END;
			END;

	[ACT_FILENAME]:	BEGIN
			CH$COPY (.COUNT, .P, ' ',
			FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME]);
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN CH$COPY (MAX (.COUNT-FI2$S_FILENAME, 0), .P+FI2$S_FILENAME, ' ',
			FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT]);
			END;

	[ACT_R50_NAME]:	BEGIN
			T = ATT_BUFFER[NMB$W_NAME];
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN CH$FILL (' ', FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT]);
			MAKE_NAMEBLOCK (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ATT_BUFFER);
			CH$MOVE (.COUNT, .P, .T);
			CH$FILL (' ', FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME]);
			MAKE_STRING (ATT_BUFFER, ADDRESS[FI2$T_FILENAME]);
			END;

	[ACT_R50_TYPE]:	BEGIN
			T = ATT_BUFFER[NMB$W_TYPE];
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN CH$FILL (' ', FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT]);
			MAKE_NAMEBLOCK (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ATT_BUFFER);
			CH$MOVE (.COUNT, .P, .T);
			CH$FILL (' ', FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME]);
			MAKE_STRING (ATT_BUFFER, ADDRESS[FI2$T_FILENAME]);
			END;

	[ACT_R50_VER]:	BEGIN
			T = ATT_BUFFER[NMB$W_VERSION];
			IF .LOCAL_HEADER[FH2$B_MPOFFSET] - .LOCAL_HEADER[FH2$B_IDOFFSET]
			GEQU ($BYTEOFFSET (FI2$T_FILENAMEXT) + FI2$S_FILENAMEXT) / 2
			THEN CH$FILL (' ', FI2$S_FILENAMEXT, ADDRESS[FI2$T_FILENAMEXT]);
			MAKE_NAMEBLOCK (FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME], ATT_BUFFER);
			CH$MOVE (.COUNT, .P, .T);
			CH$FILL (' ', FI2$S_FILENAME, ADDRESS[FI2$T_FILENAME]);
			MAKE_STRING (ATT_BUFFER, ADDRESS[FI2$T_FILENAME]);
			END;

	[ACT_DATE]:	BEGIN
			CH$COPY (.COUNT, .P, '0', 13, ATT_BUFFER);
			CONVERT_DATE (ATT_BUFFER, .ADDRESS);
			END;

	[ACT_DATES]:	BEGIN
			CH$COPY (.COUNT, .P, '0', 44, ATT_BUFFER);
			ADDRESS[FI2$W_REVISION] = .ATT_BUFFER;
			CONVERT_DATE (ATT_BUFFER+02, ADDRESS[FI2$Q_REVDATE]);
			CONVERT_DATE (ATT_BUFFER+15, ADDRESS[FI2$Q_CREDATE]);
			CONVERT_DATE (ATT_BUFFER+28, ADDRESS[FI2$Q_EXPDATE]);
			END;

	[ACT_COPY]:	CH$MOVE (.COUNT, .P, .ADDRESS);
    
	[ACT_ACL]:	BEGIN
			IF .CURRENT_FIB[FIB$L_ACL_STATUS]
			THEN
			    BEGIN
			    CHECKSUM (.LOCAL_HEADER);
			    MARK_DIRTY (.LOCAL_HEADER);
			    ACL_MODIFIED = 1;
			    STATUS = KERNEL_CALL (ACL_DISPATCH, .CODE,
						  .ADDRESS, .COUNT, .P);
			    LOCAL_HEADER = .FILE_HEADER;
			    IF NOT .STATUS
			    THEN LOCAL_FIB[FIB$L_ACL_STATUS] = .STATUS;
			    END;
			STATUS = 1;
			CLEANUP_FLAGS [CLF_MARKFCBSTALE] = 1;
			END;

	[ACT_RESERVED]:	BEGIN
			LOCAL	MAP_END,
				ACL_END	: REF BBLOCK,
				RESERVED_LENGTH;

			IF .COUNT LSS 2 THEN (STATUS = SS$_BADATTRIB; EXITLOOP);

! Determine where the maximum length possible for the reserved area.
!

			MAP_END = .LOCAL_HEADER + .LOCAL_HEADER[FH2$B_MPOFFSET]*2 +
				  .LOCAL_HEADER[FH2$B_MAP_INUSE]*2;
			ACL_END = .LOCAL_HEADER + .LOCAL_HEADER[FH2$B_ACOFFSET]*2;
			UNTIL .ACL_END GEQ .LOCAL_HEADER + .LOCAL_HEADER[FH2$B_RSOFFSET]*2
			DO
			    BEGIN
			    IF .ACL_END[ACE$B_SIZE] EQL 0 THEN EXITLOOP;
			    ACL_END = .ACL_END + .ACL_END[ACE$B_SIZE];
			    END;
			RESERVED_LENGTH = LOCAL_HEADER[FH2$W_CHECKSUM] -
					  (IF .LOCAL_HEADER[FH2$B_ACOFFSET] NEQ
					      .LOCAL_HEADER[FH2$B_RSOFFSET]
					   THEN .ACL_END ELSE .MAP_END);

			CH$FILL (0, $BYTEOFFSET (FH2$W_CHECKSUM) -
				    .RESERVED_LENGTH,
				    LOCAL_HEADER[FH2$W_CHECKSUM] - .RESERVED_LENGTH);
			P = .P + 2;		! Skip over size
			COUNT = .COUNT - 2;
			IF .COUNT GTR .RESERVED_LENGTH THEN (STATUS = SS$_HEADERFULL; EXITLOOP);
			ADDRESS = (LOCAL_HEADER[FH2$W_CHECKSUM] - .COUNT) AND NOT 1;
			IF .LOCAL_HEADER[FH2$B_ACOFFSET] EQL .LOCAL_HEADER[FH2$B_RSOFFSET]
			AND .LOCAL_HEADER[FH2$B_ACOFFSET] NEQ .LOCAL_HEADER[FH2$B_MPOFFSET] + .LOCAL_HEADER[FH2$B_MAP_INUSE]
			THEN LOCAL_HEADER[FH2$B_ACOFFSET] =
			     LOCAL_HEADER[FH2$B_RSOFFSET] = (.ADDRESS - .LOCAL_HEADER) / 2
			ELSE LOCAL_HEADER[FH2$B_RSOFFSET] = (.ADDRESS - .LOCAL_HEADER) / 2;
			CH$MOVE (.COUNT, .P, .ADDRESS);
			END;

	TES;

    END;				! end of loop

! If the directory bit was turned off by this operation, we must purge
! the RMS directory caches and the directory block cache on this volume.
!

IF .SAVE_CHAR[FCH$V_DIRECTORY]
AND NOT .LOCAL_HEADER[FH2$V_DIRECTORY]
THEN
    BEGIN
    UPDATE_DIRSEQ ();
    KILL_BUFFERS (1, .LB_BASIS [.PRIM_LCKINDX]);

    IF .PRIMARY_FCB [FCB$L_DIRINDX] NEQ 0
    THEN
	KILL_DINDX (.PRIMARY_FCB);

    END;

! Restore the state of the protected file characteristics bits.
!

LOCAL_HEADER[FH2$L_FILECHAR] = (.HEADER[FH2$L_FILECHAR] AND NOT PROTECTED_CHAR)
			       OR (.SAVE_CHAR AND PROTECTED_CHAR);
BBLOCK [LOCAL_HEADER[FH2$W_RECATTR], FAT$L_HIBLK] = .SAVE_HIBLK;

! Rebuild the header's ACL if necessary. Otherwise just checksum it.
!

IF .ACL_MODIFIED
THEN
    ACL_BUILDACL (.PRIMARY_FCB)
ELSE
    BEGIN
    CHECKSUM (.LOCAL_HEADER);
    MARK_DIRTY (.LOCAL_HEADER);
    END;

! Stop metering of this subfunction
!

PMS_END_SUB ();

IF NOT .STATUS THEN ERR_EXIT (.STATUS);

END;					! end of routine WRITE_ATTRIB

ROUTINE CONVERT_DATE (STRING, TIME_BLOCK) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a files-11 structure level 1 ASCII date/time
!	string into 64 bit binary format.
!
!
! CALLING SEQUENCE:
!	CONVERT_DATE (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of date/time string
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	ARG2: address of quadword buffer
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LITERAL
	DATLEN		= 20;		! length of date/time string

LOCAL
	DATDESC		: VECTOR [2],	! string descriptor for date string
	DATBUF		: VECTOR [DATLEN, BYTE];
					! buffer to build expanded string


! Copy the given string into the buffer, inserting the date punctuation
! as appropriate. Then convert with the system service.
!

(DATBUF+00)<0,16> = .(.STRING);
(DATBUF+02)<0,8>  = '-';
(DATBUF+03)<0,24> = .(.STRING+2);
(DATBUF+06)<0,24> = '-19';
(DATBUF+09)<0,16> = .(.STRING+5);
(DATBUF+11)<0,8>  = ' ';
(DATBUF+12)<0,16> = .(.STRING+7);
(DATBUF+14)<0,8>  = ':';
(DATBUF+15)<0,16> = .(.STRING+9);
(DATBUF+17)<0,8>  = ':';
(DATBUF+18)<0,16> = .(.STRING+11);
DATDESC[0] = DATLEN;
DATDESC[1] = DATBUF;
$BINTIM (TIMBUF = DATDESC, TIMADR = .TIME_BLOCK);

END;					! end of routine CONVERT_DATE

GLOBAL ROUTINE CHANGE_OWNER (UIC, ORG_FCB, ORG_HEADER) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes the owner UIC of a file. It check for privilege
!	and then chains through all the headers of the file, changing the
!	owner UIC, crediting the blocks to the old owner and charging them
!	to the new owner, if necessary.
!
! CALLING SEQUENCE:
!	CHANGE_OWNER (ARG1, ARG2, ARG3)
!
! INPUT PARAMETERS:
!	ARG1: new UIC
!	ARG2: address of file's FCB
!	ARG3: address of file header or 0 if it must be read
!
! IMPLICIT INPUTS:
!	CLEANUP_FLAGS: cleanup action and status flags
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	file headers read and written, quota file entries modified, FCB modified
!
!--

BEGIN

LINKAGE
	L_SEARCH_RIGHT	= JSB (REGISTER = 2, REGISTER = 4;
			       REGISTER = 1, REGISTER = 5);

MAP
	ORG_FCB		: REF BBLOCK;	! FCB of file

LOCAL
	ORG_FILE_OWNER,			! Original file owner
	HEADER		: REF BBLOCK,	! pointer to current file header
	FCB		: REF BBLOCK,	! FCB of current header, if any
	ARB		: REF BBLOCK,	! Access rights block address
	RIGHTS_DESC	: REF BBLOCK,	! Rights list descr address
	ID_FOUND	: REF BBLOCK,	! Addr of matching ID
	RIGHTS_SEG	: REF BBLOCK,	! Addr of rights segment that has ID
	STATUS_1,			! Indicates file owner resource
	STATUS_2,			! Indicates target UIC resource
	SIZE;				! size of file section

BIND_COMMON;

EXTERNAL ROUTINE
	EXE$SEARCH_RIGHT	: L_SEARCH_RIGHT ADDRESSING_MODE (GENERAL),
					! Search rights list for identifier
	CHARGE_QUOTA	: L_NORM,	! charge blocks to user's quota
	CHECKSUM	: L_NORM,	! compute file header checksum
	MARK_DIRTY	: L_NORM,	! mark buffer for write-back
	NEXT_HEADER	: L_NORM,	! read next extension header
	READ_HEADER	: L_NORM;	! read a file header


! Set up local pointers. Then check privilege. If the new UIC is the same
! as the old UIC, this whole thing is a NOP (and does not require privilege).
!

FCB = .ORG_FCB;
ORG_FILE_OWNER = .FCB[FCB$L_FILEOWNER];

IF .ORG_FILE_OWNER EQL .UIC THEN RETURN 1;

! If the UIC is not the same, it is necessary to determine whether or not
! the requesting process is able to change the owner of the file.  In order
! for the the owner to be changed, the requesting process must be: 1) running
! with SYSPRV, 2) be running with GRPPRV and the group of the file owner,
! the requesting process, and the target UIC must match, and 3) have resource
! rights to the file owner's UIC and the target UIC.

ARB = .IO_PACKET[IRP$L_ARB];
RIGHTS_DESC = ARB[ARB$L_RIGHTSLIST];

! Determine whether or not the accessor has resource rights to the file's
! owner UIC.

STATUS_1 = 1;				! Assume resource rights to owner UIC
IF .ARB[ARB$L_UIC] NEQ .ORG_FILE_OWNER
THEN IF EXE$SEARCH_RIGHT (.ORG_FILE_OWNER, .RIGHTS_DESC;
			  ID_FOUND, RIGHTS_SEG)
     THEN (IF NOT .ID_FOUND[KGB$V_RESOURCE]
	   THEN STATUS_1 = 0)
     ELSE STATUS_1 = 0;

! Determine whether or not the accessor has resource rights to the target UIC.

STATUS_2 = 1;				! Assume resource rights to target UIC
IF .ARB[ARB$L_UIC] NEQ .UIC
THEN IF EXE$SEARCH_RIGHT (.UIC, .RIGHTS_DESC; ID_FOUND, RIGHTS_SEG)
     THEN (IF NOT .ID_FOUND[KGB$V_RESOURCE]
	   THEN STATUS_2 = 0)
     ELSE STATUS_2 = 0;

! Now, check the results of the above tests.  If either fails, a check is
! made to see if SYSPRV or GRPPRV apply.

$ASSUME ($BITPOSITION (UIC$V_GROUP), EQL, 16)
$ASSUME ($FIELDWIDTH (UIC$V_GROUP), EQL, 14)
$ASSUME ($BITPOSITION (UIC$V_FORMAT), EQL, 30)
$ASSUME ($FIELDWIDTH (UIC$V_FORMAT), EQL, 2)

IF NOT .STATUS_1 OR NOT .STATUS_2
THEN
    BEGIN
    IF NOT .BBLOCK[LOCAL_ARB[ARB$Q_PRIV], PRV$V_SYSPRV]
    AND NOT .BBLOCK[LOCAL_ARB[ARB$Q_PRIV], PRV$V_BYPASS]
    AND NOT (.BBLOCK[LOCAL_ARB[ARB$Q_PRIV], PRV$V_GRPPRV] AND
	     (.(ARB[ARB$L_UIC])<16,16> EQL .FCB[FCB$W_UICGROUP] AND
	      .(ARB[ARB$L_UIC])<16,16> EQL .UIC<16,16> AND
	      .BBLOCK [ARB[ARB$L_UIC], UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT))
    THEN RETURN SS$_NOPRIV;
    END;

! Credit the original owner and charge the new owner for the blocks allocated
! to the file. Loop through the FCB chain to count up the number of headers.

SIZE = .FCB[FCB$L_FILESIZE];
IF NOT .CLEANUP_FLAGS[CLF_HDRNOTCHG]
THEN
    BEGIN
    DO
	BEGIN
	SIZE = .SIZE + 1;
	FCB = .FCB[FCB$L_EXFCB];
	END
    UNTIL .FCB EQL 0;
    FCB = .ORG_FCB;
    END;

IF .SIZE GTRU 0
THEN
    BEGIN
    CHARGE_QUOTA (.UIC, .SIZE, BITLIST (QUOTA_CHECK, QUOTA_CHARGE));
    CHARGE_QUOTA (.ORG_FILE_OWNER, -.SIZE, BITLIST (QUOTA_CHARGE));
    END;

! Now loop, changing the owner UIC of a header and writing it. Note that no
! provision is made for error recovery. This is because the previous ownerships
! of the headers of a multi-header file could be different, and therefore
! cannot be saved in finite space. Thus a failure here could leave the
! file half changed.

HEADER = .ORG_HEADER;
IF .HEADER EQL 0
THEN HEADER = READ_HEADER (0, .FCB);

DO
    BEGIN
    HEADER[FH2$L_FILEOWNER] = .UIC;
    CHECKSUM (.HEADER);
    MARK_DIRTY (.HEADER);
    HEADER = NEXT_HEADER (.HEADER, .FCB);
    FCB = .FCB[FCB$L_EXFCB];
    END
UNTIL .HEADER EQL 0;

! If we chained to extension headers, reread the primary for further use.
!

IF .FCB NEQ .ORG_FCB
THEN
    BEGIN
    HEADER = READ_HEADER (0, .ORG_FCB);
    END;

! Mark the new owner in the FCB.

ORG_FCB[FCB$L_FILEOWNER] = .UIC;

RETURN 1;

END;					! end of routine CHANGE_OWNER

ROUTINE CHANGE_CLASS (HEADER, CLASS_BLOCK) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes the classification of the file.  It checks to
!	make sure that the new classification is a subset of the old (unless
!	UPGRADE or DOWNGRADE privileges are used), and that the new
!	classification is within the bounds of the requestors authorization.
!
! CALLING SEQUENCE:
!	CHANGE_CLASS (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of file header
!	ARG2: new classification block
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Primary file header modified and FCB updated with new classification.
!
!--

BEGIN

MAP
	HEADER		: REF BBLOCK,	! file header arg
	CLASS_BLOCK	: REF BBLOCK;	! Address of new classification block

LINKAGE
	L_CHECKCLASS	= JSB (REGISTER = 2, REGISTER = 3,
			       REGISTER = 4, REGISTER = 5, REGISTER = 6;
			       REGISTER = 1)
			: NOTUSED (7, 8, 9, 10,11);

LOCAL
	STATUS,				! result of protection check
	PHD		: REF BBLOCK,	! PHD address
	FCB		: REF BBLOCK;	! FCB of current header, if any

BIND_COMMON;

EXTERNAL
	CTL$GL_PHD	: ADDRESSING_MODE (GENERAL);	! PHD pointer

EXTERNAL ROUTINE
	LOCK_COUNT	: L_NORM,	! determine if other locks exist
	EXE$CHECKCLASS	: L_CHECKCLASS ADDRESSING_MODE (GENERAL);
					! Classification checking routine


! Check to make sure that the file is not open. Changing the classification
! of an open file (either upwards or downwards) creates a storage channel.
!

FCB = .PRIMARY_FCB;
IF .FCB[FCB$W_REFCNT] NEQ 0
    OR LOCK_COUNT (.FCB [FCB$L_ACCLKID]) NEQ 1
THEN RETURN SS$_ACCONFLICT;

! Check to see if there is a classification block in the file header.
!

IF .HEADER[FH2$B_IDOFFSET]
   LEQU ($BYTEOFFSET (FH2$R_CLASS_PROT) + FH2$S_CLASS_PROT) / 2
THEN RETURN 1;

! There is.  Check the old versus the new classification.
!

STATUS = EXE$CHECKCLASS (LOCAL_ARB[ARB$Q_PRIV], CHP$M_WRITE,
			 HEADER[FH2$R_CLASS_PROT], .CLASS_BLOCK, .CLASS_BLOCK);

! Now insure that the new classification is within the accessor's authorized
! bounds.
!

PHD = .CTL$GL_PHD;

IF .STATUS THEN
STATUS = EXE$CHECKCLASS (LOCAL_ARB[ARB$Q_PRIV], CHP$M_READ OR CHP$M_WRITE,
			 .CLASS_BLOCK, PHD[PHD$R_MIN_CLASS],
			 PHD[PHD$R_MAX_CLASS]);

! Finally check the new classification against the limits of the volume.
!

IF .STATUS THEN
STATUS = EXE$CHECKCLASS (LOCAL_ARB[ARB$Q_PRIV], CHP$M_READ OR CHP$M_WRITE,
			 .CLASS_BLOCK, CURRENT_VCB[VCB$R_MIN_CLASS],
			 CURRENT_VCB[VCB$R_MAX_CLASS]);

! BYPASS privilege overrides any protection failures.
!

IF NOT .STATUS
AND NOT .BBLOCK [LOCAL_ARB[ARB$Q_PRIV], PRV$V_BYPASS]
THEN RETURN SS$_NOPRIV;

! The classification check has passed.  Save the new classification in the
! file header.
!

CH$MOVE (FH2$S_CLASS_PROT, .CLASS_BLOCK, HEADER[FH2$R_CLASS_PROT]);

! Now move the new classification block to the FCB.
!

CH$MOVE (FH2$S_CLASS_PROT, .CLASS_BLOCK, FCB[FCB$R_MIN_CLASS_PROT]);
CH$MOVE (FH2$S_CLASS_PROT, .CLASS_BLOCK, FCB[FCB$R_MAX_CLASS_PROT]);

1
END;					! end of routine CHANGE_CLASS

END
ELUDOM
