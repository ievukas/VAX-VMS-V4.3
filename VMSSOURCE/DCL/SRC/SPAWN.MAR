
	.TITLE	SPAWN - MULTI-PROCESSING COMMANDS
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; AUTHOR:
;
;	Tim Halvorsen, May 1981
;
; MODIFIED BY:
;
;	V03-025	SSA0029		Stan Amway		 6-Aug-1984
;		Propogate WS default correctly. GETJPI item code was
;		JPI$_WSSIZE, should be JPI$_DFWSCNT.
;
;	V03-024	HWS0097		Harold Schultz		01-Aug-1984
;		Change max. DCL command string length from 132 to
;		WRK_C_INPBUFSIZ. Change max. logical name translation
;		size from 63 to LNM$C_NAMLENGTH.
;
;	V03-023	HWS0088		Harold Schultz		21-Jul-1984
;		Fix output mailbox read operation to correctly handle
;		an empty mailbox. Fixes problem where subprocesses
;		finish but never wake up parent, while running up huge
;		buffered I/O counts.
;
;	V03-022	HWS0064		Harold Schultz		02-May-1984
;		When attaching to another process, or spawning a new
;		new process, don't arm own attach mailbox attention
;		AST until just ready to hibernate. (This is to close
;		a window where a newly attached process tries to attach
;		back to the old current process before it has a chance
;		to marked itself detached.)
;		Unconceal output stream logical name.
;
;	V03-021	HWS0044		Harold Schultz		30-Mar-1984
;		Add SPAWN/TABLE to allow propagation of table name.
;		Use table search in cli name verification.
;		Allow ATTACH to attach to any other process in its
;		job, removing the the restrictions of having the input
;		streams be the same for both processes and that the
;		input device be a terminal.
;		When spawning a process, indicate to $CREPRC that a
;		CLI is being specified. (if none entered via /CLI, the
;		default cli is specified)
;		Make WRITE_AST use DCL$SPAWNOUT instead of DCL$MSGOUT.
;		Remove $CHIPDEF
;
;	V03-020	HWS0017		Harold Schultz		21-Feb-1984
;		Always signal subprocess errors - do not set inhibit bit.
;		Use $BRKTHRUW instead of $BRDCST.
;		Change /CLI specification to cli name instead of cli file spec.
;
;	V03-019	HWS0002		Harold Schultz		03-Feb-1984
;		Do not propagate the protection mask from a private
;		logical name table to a sub-process.
;		Fix logical name hash table processing to process
;		first bucket in table.
;
;	V03-018	PCG0017		Peter Georg		12-Oct-1983
;		Do not set final status if image count has changed.
;		Check for associated mbx when doing an attach.
;
;	V03-017	PCG0016		Peter George		22-Sep-1983
;		Fix bug in null input file processing.
;
;	V03-016	PCG0015		Peter George		15-Sep-1983
;		Slap colon at the end of PPD$T_INPDVI before using.
;
;	V03-015	PCG0014		Peter George		16-Aug-1983
;		Correctly supply address of IOSB to IO$M_TT_PROCESS QIO.
;		Be a little more intelligent about when to perform the QIO.
;
;	V03-014	PCG0013		Peter George		27-Jun-1983
;		Add /CLI qualifier.
;		Use event flags more consistently.
;		Remove code to propagate old format logical name tables.
;		Specify STSFLG argument to $CREPRC.
;		Do an IO$M_TT_PROCESS set mode QIO whenever an interactive
;		process comes back to life.
;		Remove CTRL/C and out-of-band AST warning message.
;
;	V03-013	PCG0012		Peter George		27-Jun-1983
;		Change MOVW in logical name code to MOVL.
;
;	V03-012	PCG0011		Peter George		15-Jun-1983
;		Add SPAWN/NOKEYPAD.
;
;	V03-011	PCG0010		Peter George		27-May-1983
;		Use DCL$FORMMSG for logical name message.
;
;	V03-010	RAS0157		Ron Schaefer		27-May-1983
;		Add support for new logical names to be passed thru
;		to the subprocess.
;
;	V03-009	PCG0009		Peter George		27-May-1983
;		Fix bug in SPAWN CTRL/Y processing.
;		Use DCL$FORMMSG.
;
;	V03-008	PCG0008		Peter George		20-Apr-1983
;		Add prompt string and keypad state to context that is
;		passed through to the subprocess.
;		Make spawn work in command procedures.
;
;	V03-007	PCG0005		Peter George		30-Mar-1983
;		Have SPAWN/NOTIFY use SPWN_T_PROCESS.
;		Fix bug in ATTACH_AST that allows illegal attaches.
;		Correctly signal process creation errors.
;		Process parsed input/output devices as PPF devices.
;
;	V03-006	PCG0005		Peter George		29-Mar-1983
;		Sort out CTX_C_KEY* symbols.
;
;	V03-005	PCG0004		Peter George		01-Mar-1983
;		Call DCL$GETNVAL.  Propagate keypad symbols to subprocess.
;
;	V03-004	PCG0003		Peter George		01-Feb-1983
;		Clean up code, fix bugs.
;		Add /SYMBOLS, /LOGICAL_NAMES, /NOTIFY.
;
;	V03-003	PCG0002		Peter George		14-Jan-1983
;		Fix SPWN deallocation problem.
;
;	V03-002	PCG0001		Peter George		18-Nov-1982
;		Store size of allocated TMBX structure in that structure.
;
;	V03-001	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $IODEF, $PSLDEF and $SSDEF.
;
;---

;
; MACRO LIBRARY CALLS
;
	$PRCDEF				;DEFINE CREPRC FLAGS
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE TOKEN DESCRIPTORS
	SYMDEF				;DEFINE SYMBOL TABLE ENTRY
	SPWNDEF				;DEFINE SPAWN LOCAL STORAGE
	CTXDEF				;DEFINE PROCESS CONTEXT MESSAGES
	TMBXDEF				;DEFINE TERMINATION MAILBOX STRUCTURE
	$BRKDEF				;DEFINE BREAKTHRU CLASSES
	$PPDDEF				;DEFINE PPD FIELDS
	$DIBDEF				;DEFINE GETDEV INFO BUFFER
	$JPIDEF				;DEFINE GETJPI ITEM CODES
	$DVIDEF				;DEFINE GETDVI ITEM CODES
	$SYIDEF				;DEFINE GETSYI ITEM CODES
	$PQLDEF				;DEFINE PROCESS QUOTA TYPE CODES
	$PSLDEF				;DEFINE PROGRAM STATUS LONGWORD FIELDS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$LOGDEF				;DEFINE LOGICAL NAME ENTRY
	$LNMDEF				;DEFINE LOGICAL NAME ATTRIBUTES
	$LNMSTRDEF			;DEFINE LOGICAL NAME STRUCTURES
	$ACCDEF				;TERMINATION RECORD FORMAT
	$CLIMSGDEF			;CLI MESSAGE CODES
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$FABDEF				;DEFINE FAB FIELDS
	$NAMDEF				;DEFINE NAM FIELDS
	$TT2DEF				;DEFINE DEVDEPEND2 FIELDS
	$DCDEF				;DEFINE DVI DEVICE CLASSES
	$$CLITABDEF			;DEFINE MAX PROMPT SIZE

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

ATTMBX_MAXMSG = 16			; MAXIMUM SIZE OF ATTACH REQUEST MESSAGE

LOGINOUT:
	.ASCIC	'SYS$SYSTEM:LOGINOUT'	; IMAGE TO INITIALIZE DCL

PRCNAM_NAME:
	.ASCIC	'!AS_!UL'		; FAO STRING FOR DEFAULT PROCESS NAME
ATTACH_NAME:
	.ASCIC	'DCL$ATTACH_!XL'	; FAO STRING FOR ATTACH LOGNAME
OUTPUT_NAME:
	.ASCIC	'DCL$OUTPUT_!XL'	; FAO STRING FOR OUTPUT LOGNAME

SYS$INPUT:
	.ASCIC	'SYS$INPUT'		; DEFAULT INPUT STREAM
SYS$OUTPUT:
	.ASCIC	'SYS$OUTPUT'		; DEFAULT OUTPUT STREAM
SYS$SYSTEM:
	.ASCIC	'SYS$SYSTEM:'		; DEVICE SPEC. FOR CLI SPECIFICATION
NL:
	.ASCIC	'_NL:'			; NULL DEVICE
COM:
	.ASCIC	'.COM'			; DEFAULT INPUT FILE TYPE
LOG:
	.ASCIC	'.LOG'			; DEFAULT OUTPUT FILE TYPE

CLI_NAME:				; KNOWN CLI NAME TABLE.
	.ASCIC	'DCL'			; CLI NAME FOR DCL
	.ASCIC	'MCR'			; CLI NAME FOR MCR
	.ASCIC	'SHELL'			; CLI NAME FOR SHELL
	.BYTE	0			; END OF TABLE MARKER

NOTIFY_MSG:
	.ASCIC	'Subprocess !AC has completed'
	NOTIFY_LEN = 28+15+1

	.SBTTL	SPAWN COMMAND
;+
; DCL$SPAWN - SPAWN COMMAND
;
; THIS ROUTINE IS CALLED TO EXECUTE THE DCL SPAWN COMMAND.  THE SPAWN
; COMMAND CREATES A "CLONED" SUBPROCESS WITH THE FOLLOWING CONTEXT COPIED
; FROM THE PARENT TO THE SUBPROCESS:
;
;	1) ALL CLI SYMBOLS
;	2) ALL PROCESS LOGICAL NAMES
;	3) DEFAULT DISK AND DIRECTORY
;	5) CURRENT PROCESS PRIVILEGES
;	6) CURRENT COMMAND VERIFICATION STATE
;	7) CURRENT "ON CONTROL" (OUT-OF-BAND) STATE
;	8) CURRENT PROMPT STRING
;	9) CURRENT KEYPAD STATE
;
; NO PROCESS PERMANENT OPEN FILES ARE COPIED, NOR IS ANY IMAGE OR PROCEDURE
; CONTEXT.  THE SUBPROCESS IS SET TO PROCEDURE LEVEL 0.  LOGIN.COM IS NOT
; EXECUTED, BOTH BECAUSE THE CONTEXT IS COPIED SEPARATELY AND TO CAUSE THE
; SUBPROCESS TO INITIALIZE QUICKLY.  THE PARENT IS LEFT IN HIBERNATION STATE
; UNTIL THE SUBPROCESS TERMINATES OR TRANSFERS CONTROL BACK TO THE PARENT VIA
; THE ATTACH COMMAND.
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
;	R2-R9 DESTROYED.
;-
 
DCL$SPAWN::
;
; ALLOCATE SOME SPACE FOR SPAWN STORAGE
;
	MOVZWL	#SPWN_C_LENGTH,R1	; LENGTH OF STORAGE TO ALLOCATE
	BSBW	DCL$ALLDYNMEM		; ALLOCATE STORAGE
	BLBS	R0,10$			; BRANCH IF OK
	RSB				; IF ERROR DETECTED, REPORT IT
10$:	MOVL	R2,R6			; POINT TO SPWN STORAGE
	MOVC5	#0,(R1),#0,#SPWN_C_LENGTH,(R6)	; ZERO THE BLOCK
					; (WITHOUT DESTROYING R1)
	MOVW	R1,SPWN_W_SIZE(R6)	; STORE SIZE OF BLOCK
	BISW	#SPWN_M_LOG!SPWN_M_WAIT!-	; ASSUME /LOG, /WAIT
		SPWN_M_CLISYM!SPWN_M_LOGNAM!-	; COPY CLI SYMBOLS & LOGNAMES
		SPWN_M_KEYPAD,SPWN_W_FLAGS(R6)
	BICW	#SPWN_M_CLI!SPWN_M_TABLE,-	; ASSUME /NOCLI AND /NOTABLE
		SPWN_W_FLAGS(R6)
	MOVW	DCL$CRLF,SPWN_W_PMPTCTRL(R6)	; ASSUME /CONTROL
	MNEGB	#1,SPWN_B_EFN(R6)	; DO NOT SET EVENT FLAG ON TERMINATION

;
; PROCESS THE VERB QUALIFIERS ON THE COMMAND LINE
;
40$:	BSBW	DCL$GETDVAL		; GET NEXT TOKEN
	BLBC	R0,43$			; IF EOL, END OF PROCESSING
	CMPL	R5,#PTR_K_COMDQUAL	; VERB QUALIFIER?
	BEQL	42$			; BRANCH IF SO
	CMPL	R5,#PTR_K_PARAMETR	; PARAMETER (COMMAND STRING)?
	BNEQ	40$			; IF NOT, IGNORE IT
	MOVQ	R1,SPWN_Q_CMDSTR(R6)	; SAVE DESCRIPTOR OF COMMAND STRING
	BRB	40$
43$:	BRW	80$			; END OF COMMAND PARSING
42$:	BSBW	DCL$GETNVAL		; GET QUALIFIER NUMBER
	CMPB	R1,#CLI$K_SPAW_WAIT	; /WAIT?
	BEQL	49$
	CMPB	R1,#CLI$K_SPAW_LOG	; /LOG?
	BEQL	47$
	CMPB	R1,#CLI$K_SPAW_SYMB	; /SYMBOLS?
	BEQL	50$
	CMPB	R1,#CLI$K_SPAW_LOGI	; /LOGICAL_NAMES?
	BEQL	51$
	CMPB	R1,#CLI$K_SPAW_NOTI	; /NOTIFY?
	BEQL	52$
	CMPB	R1,#CLI$K_SPAW_CARR	; /CARRIAGE_CONTROL?
	BEQL	531$
	CMPB	R1,#CLI$K_SPAW_KEYP	; /KEYPAD?
	BEQL	532$
	BRW	60$			; CHECK OTHER QUALIFIER POSSIBILITIES

49$:	SETBIT	SPWN_V_WAIT,SPWN_W_FLAGS(R6)	; ASSUME /WAIT
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,40$ ; IGNORE IF NOT /NOWAIT
	CLRBIT	SPWN_V_WAIT,SPWN_W_FLAGS(R6)	; CLEAR WAIT FLAG
	BRB	40$
47$:	SETBIT	SPWN_V_LOG,SPWN_W_FLAGS(R6)	; ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,40$ ; IGNORE IF NOT /NOLOG
	CLRBIT	SPWN_V_LOG,SPWN_W_FLAGS(R6)	; CLEAR LOG MESSAGE FLAG
	BRB	40$
50$:	SETBIT	SPWN_V_CLISYM,SPWN_W_FLAGS(R6)	; ASSUME /SYMBOLS
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,40$ ; IGNORE IF NOT /NOSYMBOLS
	CLRBIT	SPWN_V_CLISYM,SPWN_W_FLAGS(R6)	; CLEAR CLISYM FLAG
	BRB	40$
51$:	SETBIT	SPWN_V_LOGNAM,SPWN_W_FLAGS(R6)	; ASSUME /LOGICAL_NAMES
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,41$ ; IGNORE IF NOT /NOLOGICAL_NAMES
	CLRBIT	SPWN_V_LOGNAM,SPWN_W_FLAGS(R6)	; CLEAR LOGNAM FLAG
	BRB	41$
52$:	SETBIT	SPWN_V_NOTIFY,SPWN_W_FLAGS(R6)	; ASSUME /NOTIFY
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,41$ ; IGNORE IF NOT /NONOTIFY
	CLRBIT	SPWN_V_NOTIFY,SPWN_W_FLAGS(R6)	; CLEAR NOTIFY FLAG
	BRB	41$
531$:	MOVW	DCL$CRLF,SPWN_W_PMPTCTRL(R6)	; ASSUME /CONTROL
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,41$ ; IGNORE IF NOT /NOCONTROL
	CLRW	SPWN_W_PMPTCTRL(R6)		; SET /NOCONTROL
	BRB	41$
532$:	SETBIT	SPWN_V_KEYPAD,SPWN_W_FLAGS(R6)	; ASSUME /KEYPAD
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,41$ ; IGNORE IF NOT /NOKEYPAD
	CLRBIT	SPWN_V_KEYPAD,SPWN_W_FLAGS(R6)	; CLEAR KEYPAD FLAG
	BRB	41$

60$:	CMPB	R1,#CLI$K_SPAW_INPU	; /INPUT?
	BEQL	45$
	CMPB	R1,#CLI$K_SPAW_OUTP	; /OUTPUT?
	BEQL	46$
	CMPB	R1,#CLI$K_SPAW_PROC	; /PROCESS_NAME?
	BEQL	48$
	CMPB	R1,#CLI$K_SPAW_CLI	; /CLI?
	BEQL	481$
	CMPB	R1,#CLI$K_SPAW_TABL	; /TABLE?
	BEQL	485$
	CMPB	R1,#CLI$K_SPAW_PROM	; /PROMPT?
	BEQL	53$
41$:	BRW	40$			; IF NONE OF THE ABOVE QUALS, IGNORE IT

45$:	CLRBIT	SPWN_V_INPUT,SPWN_W_FLAGS(R6)	; ASSUME NO VALUE PRESENT
	CMPB	R4,#PTR_K_COLON			; IS A VALUE PRESENT?
	BNEQ	41$				; IF NOT, USE DEFAULT
	SETBIT	SPWN_V_INPUT,SPWN_W_FLAGS(R6)	; INDICATE VALUE PRESENT
	BSBW	DCL$GETDVAL			; GET /INPUT VALUE
	MOVQ	R1,SPWN_Q_INPUT(R6)		; USE EXPLICIT INPUT STREAM
	BRB	41$
46$:	CLRBIT	SPWN_V_OUTPUT,SPWN_W_FLAGS(R6)	; ASSUME NO VALUE PRESENT
	CMPB	R4,#PTR_K_COLON			; IS A VALUE PRESENT?
	BNEQ	41$				; IF NOT, USE DEFAULT
	SETBIT	SPWN_V_OUTPUT,SPWN_W_FLAGS(R6)	; INDICATE VALUE PRESENT
	BSBW	DCL$GETDVAL			; GET /OUTPUT VALUE
	MOVQ	R1,SPWN_Q_OUTPUT(R6)		; USE EXPLICIT OUTPUT STREAM
	BRB	41$
48$:	CMPB	R4,#PTR_K_COLON			; IS A VALUE PRESENT?
	BNEQ	41$				; IF NOT, USE DEFAULT
	BSBW	DCL$GETDVAL			; GET VALUE
	MOVQ	R1,SPWN_Q_PRCNAM(R6)		; USE EXPLICIT PROCESS NAME
	SETBIT	SPWN_V_PRCNAM,SPWN_W_FLAGS(R6)	; SET PROCESS NAME SPECIFIED
	BNEQ	41$
481$:	CLRBIT	SPWN_V_CLI,SPWN_W_FLAGS(R6)	; ASSUME /NOCLI
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,41$  ; FLAG OK AS IS IF /NOCLI
	SETBIT	SPWN_V_CLI,SPWN_W_FLAGS(R6)	; SET /CLI PRESENT FLAG
	BSBW	DCL$GETDVAL			; GET /CLI VALUE
	MOVQ	R1,SPWN_Q_CLI(R6)		; SAVE DESCRIPTOR OF CLI NAME
	BRB	41$
485$:	CLRBIT	SPWN_V_TABLE,SPWN_W_FLAGS(R6)	; ASSUME /NOTABLE
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,41$  ; FLAG OK AS IS IF /NOTABLE
	SETBIT	SPWN_V_TABLE,SPWN_W_FLAGS(R6)	; SET /TABLE PRESENT FLAG
	BSBW	DCL$GETDVAL			; GET /TABLE VALUE
	MOVQ	R1,SPWN_Q_TABLE(R6)		; SAVE DESCRIPTOR OF TABLE NAME
	BRB	41$
53$:	CLRBIT 	SPWN_V_PROMPT,SPWN_W_FLAGS(R6)	; ASSUME /NOPROMPT
	BLBS	R3,533$				; BRANCH IF SO
	SETBIT 	SPWN_V_PROMPT,SPWN_W_FLAGS(R6)	; SET /PROMPT
	MOVB	#DCL$C_PROMPTLEN,-		; ASSUME NO VALUE SPECIFIED
		SPWN_B_PROMPTLEN(R6)		;
	PUSHL	R4				; SAVE THE TERMINATOR
	MOVC3	#DCL$C_PROMPTLEN,DCL$CRLF,-	; GET PROMPT STRING
		SPWN_W_PMPTCTRL(R6)		;
	POPL	R4				; RESTORE THE TERMINATOR
	CMPB	R4,#PTR_K_COLON			; IS A VALUE PRESENT?
	BNEQ	533$				; USE DEFAULT PROMPT
	BSBW	DCL$GETDVAL			; GET VALUE
	ADDB3	#3,R1,SPWN_B_PROMPTLEN(R6)	; GET PROMPT LENGTH
	MOVC3	#ENT_K_MAX_PROMPT,(R2),-	; GET PROMPT STRING
		SPWN_G_PROMPT(R6)		;
533$:	BRW	40$

;
; THE PARSING IS COMPLETE, AND ALL OPTIONS ARE SET INTO THE SPWN
; BLOCK.  NOW PERFORM THE SPAWN OPERATION.
;
80$:	BSBB	DCL$SPAWN2		; PERFORM THE SPAWN OPERATION
	BLBC	R0, 90$			; TEST FOR FAILURE OF SPAWN ITSELF
	MOVL	R1, R0			; GET SUBPROCESS TERMINATION STATUS
90$:	RSB

	.SBTTL	SPAWN A SUBPROCESS
;---
;
; THIS ROUTINE IS CALLED TO PERFORM THE ACTUAL CREATION OF THE SUBPROCESS.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN PARAMETER BLOCK
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = FINAL STATUS FROM COMPLETED SUBPROCESS
;	SPWN_L_PID(R6) = PID OF SUBPROCESS (IF NOWAIT FLAG SPECIFIED)
;---

DCL$SPAWN2::
	PUSHR	#^M<R2,R3,R4,R5,R7,R8>		; SAVE REGISTERS

;
; CONTROL/Y AST'S ARE DISABLED THROUGHOUT THIS COMMAND, TO ENSURE THAT
; MAILBOXES WHICH ARE CREATED HERE ARE CORRECTLY DELETED, ETC.  AS A
; RESULT, WE MUST PERIODICALLY CHECK THE HANGUP FLAG IN CASE A HANGUP
; IS DETECTED WHILE WE ARE OPERATING.
;
	MOVL	PRC_L_OUTOFBAND(R11),-		; SAVE OUT-OF-BAND ENABLE MASK
		SPWN_L_OUTOFBAND(R6)		;
	CLRL	R1				; DISABLE ALL OUT-OF-BAND AST'S
	BSBW	DCL$RESETOOB			;

;
; PRE-CLEAR THE TERMINATION EVENT FLAG, IF ONE IS SPECIFIED.
;
	TSTB	SPWN_B_EFN(R6)			; EVENT FLAG SPECIFIED?
	BLSS	2$				; BRANCH IF NONE
	$CLREF_S EFN=SPWN_B_EFN(R6)		; PRE-CLEAR IT

;
; SAVE THE PREVIOUS ACCESS MODE, FOR PROBING RETURN STATUS AND DELIVERING
; TERMINATION ASTS.
;
2$:	MOVPSL	R0				; GET CURRENT PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,-	; EXTRACT PREVIOUS ACMODE
		R0,R0 				;
	MOVB	R0,SPWN_B_ACMODE(R6)		; SAVE THE ACCESS MODE

;
; ALLOCATE SOME SCRATCH STORAGE ON THE STACK (1 - 1/2 PAGES)
;
	MOVAB	-768(SP),SP			; ALLOCATE SCRATCH BUFFER ON STACK
	PUSHL	SP				; CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZWL	#768,-(SP)			;
	MOVL	SP,R8				; AND POINT TO IT

;
; FIND A TERMINATION MAILBOX SLOT AND INITIALIZE IT FOR THIS SUBPROCESS.
;
	ASSUME	TMBX_L_LINK EQ 0		;
	MOVAB	PRC_L_TMBX(R11),R7		; GET ADDRESS OF TMBX BLOCK LIST HEAD
10$:	MOVL	TMBX_L_LINK(R7),R7		; GET NEXT BLOCK IN LIST
	BNEQ	20$				; BRANCH IF NOT END OF LIST
	BSBW	CREATE_TMBX			; CREATE NEW MBX IF END OF LIST
	BLBS	R0,20$				; CONTINUE IF NO ERROR
	BRW	230$				; EXIT IF ERROR
20$:	CMPB	TMBX_B_REFS(R7),#TMBX_C_MAXREFS	; DOES MBX HAVE ANY OPEN SLOTS?
	BEQL	10$				; NO, LOOK AT NEXT MBX IN LIST
	INCB	TMBX_B_REFS(R7)			; YES, GRAB ONE, INCR REFERENCE COUNT
	MOVW	TMBX_W_UNIT(R7),SPWN_W_UNIT(R6)	; COPY THE UNIT NUMBER
;
; CHECK FOR KNOWN CLI'S  TO WHICH TO PASS CONTEXT IF /CLI
; WAS SPECIFIED.
;
	MOVQ	R8,-(SP)			; SAVE WORK REGISTERS
	BBC	#SPWN_V_CLI,SPWN_W_FLAGS(R6),50$  ; BRANCH IF NO CLI WAS SPECIFED
	MOVQ	SPWN_Q_CLI(R6),R2		; GET CLI DESCRIPTOR
	MOVAB	CLI_NAME,R8			; GET TABLE ADDR. OF KNOWN CLI'S

21$:	MOVZBL	(R8),R9				; EXTRACT LENGTH
	BEQL	40$				; IF EQ, SPECIFIED CLI NOT KNOWN

	MOVQ	R2,-(SP)			; SAVE DESCRIPTOR
	CMPC5	R2,(R3),#0,-			; COMPARE TO THIS TABLE ENTRY
		R9,1(R8)
	BEQL	45$				; IF EQ, THIS CLI IS KNOWN

	MOVQ	(SP)+,R2			; RESTORE DESCRIPTOR
	MOVAB	1(R8)[R9],R8			; SET UP TO CHECK NEXT ENTRY
	BRB	21$				; CHECK NEXT TABLE ENTRY

40$:	SETBIT	SPWN_V_NOCTX,SPWN_W_FLAGS(R6)	; DON'T SEND CONTEXT TO FOR THIS CLI
	BRB	50$
45$:	MOVQ	(SP)+,R2			; RESTORE STACK
;
; PROPAGATE EITHER THE SPECIFIED CLI AND TABLE NAMES OR THE DEFAULT NAMES TO
; THE SPAWN CLI AND TABLE SPECIFICATION TABLES.
;
50$:	MOVZWL	SPWN_Q_CLI(R6),R8		; GET LENGTH OF CLI NAME, IF SPEC.
	MOVZWL	SPWN_Q_TABLE(R6),R9		; GET LENGTH OF TABLE NAME, IF SPECIFIED
	BBC	#SPWN_V_TABLE,SPWN_W_FLAGS(R6),218$  ; SKIP IF NO TABLE SPECIFIED
	BBC	#SPWN_V_CLI,SPWN_W_FLAGS(R6),216$   ; SKIP IF NO CLI SPECIFIED
;
; BOTH CLI AND NAME WERE SPECIFIED
;
	MOVB	R8,G^CTL$GT_SPAWNCLI		; SET SIZE FIELD
	MOVC	R8,@SPWN_Q_CLI+4(R6),-		; MOVE CLI SPECIFICATION
		G^CTL$GT_SPAWNCLI+1
214$:	MOVB	R9,G^CTL$GT_SPAWNTABLE		; SET LENGTH OF TABLE NAME
	MOVC	R9,@SPWN_Q_TABLE+4(R6),-	; COPY TABLE NAME
		G^CTL$GT_SPAWNTABLE+1
	BRB	228$
;
; JUST TABLE NAME SPECIFIED
;
216$:	MOVZBL	G^CTL$GT_CLINAME,R8		; GET LENGTH OF CLI NAME
	INCL	R8				; INCLUDE LENGTH BYTE
	MOVC	R8,G^CTL$GT_CLINAME,-		; GET DEFAULT CLI NAME
		G^CTL$GT_SPAWNCLI
	BRB	214$				; NOW TRANSER TABLE NAME
;
;	NO TABLE NAME SPECIFIED. CHECK IF CLI NAME SPECIFIED
;
218$:	BBC	#SPWN_V_CLI,SPWN_W_FLAGS(R6),220$  ; SKIP IF CLI NOT SPECIFIED
	CLRB	G^CTL$GT_SPAWNTABLE		; ZERO TABLE SPECIFICATION
	MOVB	R8,G^CTL$GT_SPAWNCLI		; SET SIZE FIELD
	MOVC	R8,@SPWN_Q_CLI+4(R6),-		; MOVE CLI SPECIFICATION
		G^CTL$GT_SPAWNCLI+1
	BRB	228$
;
;	NEITHER CLI OR TABLE SPECIFIED. JUST COPY DEFAULTS
;
220$:	MOVZBL	G^CTL$GT_CLINAME,R8		; GET LENGTH OF CLI NAME
	INCL	R8				; INCLUDE LENGTH BYTE
	MOVC	R8,G^CTL$GT_CLINAME,-		; COPY CLI NAME
		G^CTL$GT_SPAWNCLI
	MOVZBL	G^CTL$GT_TABLENAME,R8		; GET LENGTH OF TABLE NAME
	INCL	R8				; INCLUDE LENGTH BYTE
	MOVC	R8,G^CTL$GT_TABLENAME,-		; COPY TABLE NAME
		G^CTL$GT_SPAWNTABLE
228$:	MOVQ	(SP)+,R8			; RESTORE WORK REG.
;
; CREATE A COMMUNICATIONS MAILBOX TO COPY THE CONTEXT TO THE SUBPROCESS
;
	BBS	#SPWN_V_NOCTX,SPWN_W_FLAGS(R6),22$; BRANCH IF UNKNOWN CLI WAS SPECIFIED
	$CREMBX_S CHAN=SPWN_W_CHAN(R6),-	; CREATE COMMUNICATIONS MAILBOX
		MAXMSG=#CTX_C_MAXLEN		;
230$:	BLBC	R0,95$				; BRANCH ON ERROR

;
; GET THE NAME OF THAT MAILBOX USING $GETDVI.
;
	CLRL	-(SP)				; CREATE GETDVI ITEM LIST
	PUSHAB	SPWN_Q_MBXNAM(R6)		; ADDRESS OF WORD TO RECEIVE LENGTH
	MOVQ	(R8),-(SP)			; SET DESCRIPTOR OF BUFFER
	MOVW	#DVI$_DEVNAM,2(SP)		; REQUEST COMPLETE DEVICE NAME
	MOVL	SP,R0				;
	$GETDVIW_S  CHAN=SPWN_W_CHAN(R6),- 	; GET MAILBOX DEVICE NAME
		IOSB=SPWN_Q_IOSB(R6),-		;
		EFN=#EXE$C_SYSEFN,-		;
		ITMLST=(R0)			;
	ADDL	#4*4,SP				; POP GETDVI ITEM LIST
	BLBC	R0,95$				; BRANCH IF ERROR DETECTED
	MOVZWL	SPWN_Q_IOSB(R6),R0		; GET IOSB STATUS
	BLBC	R0,95$				; BRANCH IF ERROR DETECTED

;
; SAVE THE NAME OF THE COMMUNICATIONS MAILBOX IN THE SPWN BLOCK.
; DEALLOCATE SPACE FOR THE MAILBOX NAME FROM THE SCRATCH STORAGE.
;
	MOVL	4(R8),SPWN_Q_MBXNAM+4(R6)	; SET ADDRESS OF BUFFER
	SUBW	SPWN_Q_MBXNAM(R6),(R8)		; MARK DEVICE NAME NO LONGER SCRATCH
	ADDL	SPWN_Q_MBXNAM(R6),4(R8)		;

;
; CREATE AN ATTACH MAILBOX TO HANDLE RE-ATTACH REQUESTS TO THIS PROCESS.
;
22$:	BSBW	CREATE_ATTMBX			; CREATE OUR ATTACH MAILBOX
	BLBS	R0,25$				; BRANCH IF SUCCESS
95$:	BRW	SPAWN_EXIT			; BRANCH IF ERROR DETECTED

;
; IF /NOTIFY WAS SPECIFIED, CHECK THAT IT IS ALLOWED.
;
25$:	BBC	#SPWN_V_NOTIFY,-		; SKIP IF /NONOTIFY
		SPWN_W_FLAGS(R6),30$		;
	MOVL	#CLI$_NOTIFY,R0			; ASSUME NOTIFY NOT ALLOWED
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),95$; NOT ALLOWED IN BATCH JOBS
	BBS	#SPWN_V_WAIT,-			; NOT ALLOWED IN /WAIT JOBS
		SPWN_W_FLAGS(R6),95$		;

;
; CHECK THAT COMMAND STRING IS NOT TOO LONG.
;
30$:	MOVL	#CLI$_BUFOVF,R0			; ASSUME COMMAND BUFFER OVERFLOW
	CMPW	SPWN_Q_CMDSTR(R6),#WRK_C_INPBUFSIZ  ; COMMAND STRING TOO LONG?
	BGTRU	95$				; BRANCH IF SO

;
; CHECK THAT PROMPT STRING IS NOT TOO LONG.
;
	MOVL	#CLI$_STRTOOLNG,R0		; ASSUME PROMPT IS TOO LONG
	CMPB	SPWN_B_PROMPTLEN(R6),-		; PROMPT STRING TOO LONG?
		#ENT_K_MAX_PROMPT+3		; 
	BGTRU	95$				; BRANCH IF SO

;
; PROCESS THE INPUT AND OUTPUT STREAMS.
;
	BSBW	VERIFY_INPUT			; VERIFY INPUT STREAM
	BLBC	R0,95$				; BRANCH IF ERROR
	BSBW	VERIFY_OUTPUT			; VERIFY OUTPUT STREAM
	BLBC	R0,95$				; BRANCH IF ERROR

;
; DETERMINE BASE PRIORITY FOR NEW SUBPROCESS FROM CURRENT BASE PRIORITY
;
	CLRQ	-(SP)				; CREATE GETJPI ITEM LIST
	PUSHAL	SPWN_L_PRIB(R6)			; SET BUFFER ADDRESS
	PUSHL	#JPI$_PRIB@16+4			; REQUEST CURRENT BASE PRIORITY

;
; DETERMINE CURRENT IMAGE COUNT (FOR USE BY TERMINATION AST)
;
	CLRL	-(SP)				; NO RETLEN ADDRESS
	PUSHAL	SPWN_L_IMAGCNT(R6)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_IMAGECOUNT@16+4		; REQUEST CURRENT IMAGE COUNT

;
; DETERMINE CURRENT VALUES OF NON-DEDUCTIBLE QUOTAS, AND CREATE A QUOTA
; LIST WHICH WILL BE USED TO SET THE QUOTAS OF THE SUBPROCESS.
;
	MOVAB	SPWN_G_QUOTAS(R6),R3		; GET ADDRESS OF SPACE FOR LIST
	CLRL	-(SP)				; NO RETLEN ADDRESS
	MOVB	#PQL$_ASTLM,(R3)+		; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+				; SET BUFFER ADDRESS
	PUSHL	#JPI$_ASTLM@16+4		; REQUEST CURRENT ASTLM
	CLRL	-(SP)				; NO RETLEN ADDRESS
	MOVB	#PQL$_BIOLM,(R3)+		; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+				; SET BUFFER ADDRESS
	PUSHL	#JPI$_BIOLM@16+4		; REQUEST CURRENT BIOLM
	CLRL	-(SP)				; NO RETLEN ADDRESS
	MOVB	#PQL$_DIOLM,(R3)+		; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+				; SET BUFFER ADDRESS
	PUSHL	#JPI$_DIOLM@16+4		; REQUEST CURRENT DIOLM
	CLRL	-(SP)				; NO RETLEN ADDRESS
	MOVB	#PQL$_WSDEFAULT,(R3)+		; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+				; SET BUFFER ADDRESS
	PUSHL	#JPI$_DFWSCNT@16+4		; REQUEST CURRENT WSDEFAULT
	CLRL	-(SP)				; NO RETLEN ADDRESS
	MOVB	#PQL$_WSQUOTA,(R3)+		; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+				; SET BUFFER ADDRESS
	PUSHL	#JPI$_WSQUOTA@16+4		; REQUEST CURRENT WSQUOTA
	CLRL	-(SP)				; NO RETLEN ADDRESS
	MOVB	#PQL$_WSEXTENT,(R3)+		; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+				; SET BUFFER ADDRESS
	PUSHL	#JPI$_WSEXTENT@16+4		; REQUEST CURRENT WSEXTENT
	MOVB	#PQL$_LISTEND,(R3)+		; TERMINATE PQL LIST
	MOVL	SP,R0				; GET ADDRESS OF ITEM LIST
	$GETJPIW_S  ITMLST=(R0),-		; GET CURRENT QUOTA VALUES
		IOSB=SPWN_Q_IOSB(R6),-		;
		EFN=#EXE$C_SYSEFN		;
	ADDL	#8*12+4,SP			; POP ITEM LIST

;
; INSERT THE CURRENT SPWN BLOCK INTO THE LINKED LIST OF PENDING SUBPROCESSES,
; SO THAT IN CASE THE SUBPROCESS DIES WHILE WE ARE ATTEMPTING TO FEED IT
; CONTEXT, THE SUBPROCESS TERMINATION AST ROUTINE CAN DO SOMETHING ABOUT IT.
;
	SETBIT	SPWN_V_ACTIVE,SPWN_W_FLAGS(R6)	; MARK BLOCK CURRENTLY "ACTIVE"
	MOVL	PRC_L_SPWN(R11),SPWN_L_LINK(R6) ; INSERT INTO LINKED LIST
	MOVL	R6,PRC_L_SPWN(R11)		; PASS ADDRESS OF SPWN TO TERMINATION
						; AST, SO WE CAN FIND OUT IF IT DIES

;
; CONSTRUCT THE PROCESS NAME OF THE FORM <USERNAME>_1.  THE TRAILING
; NUMBER WILL BE INCREMENTED UNTIL WE FIND A UNIQUE PROCESS NAME.
;
	BBS	#SPWN_V_PRCNAM,-		; BRANCH IF /PROCESS GIVEN
		SPWN_W_FLAGS(R6),SPAWN_PROCESS 	;
	MOVL	#1,R4				; START WITH POSTFIX #1

CONSTRUCT_PRCNAM: 
	MOVAB	SPWN_Q_PRCNAM(R6),R3		; GET ADDRESS OF DESCRIPTOR SPACE
	CLRL	-(SP)				; MARK END OF JPI LIST
	PUSHL	R3				; ADDRESS TO STORE RETURN LENGTH
	MOVQ	(R8),-(SP)			; DESCRIPTOR OF STRING BUFFER
	MOVW	#JPI$_USERNAME,2(SP)		; SET PARAMETER ID TO RETRIEVE
	MOVL	SP,R0				; SET ADDRESS OF ITEM LIST
	$GETJPIW_S  ITMLST=(R0),-		; GET USERNAME STRING
		IOSB=SPWN_Q_IOSB(R6),-		;
		EFN=#EXE$C_SYSEFN		;
	ADDL	#4*4,SP				; REMOVE ITEM LIST FROM STACK
	MOVL	4(R8),4(R3)			; SET ADDRESS OF BUFFER
	LOCC	#^A' ',(R3),@4(R3)		; FIND END OF NAME
	SUBL	R0,(R3)				; TRUNCATE TO FIRST SPACE (IF ANY)
	ADDL3	(R3),4(R8),-(SP)		; COMPUTE SPACE LEFT AFTER PRCNAM
	SUBL3	(R3),(R8),-(SP)			;
	MOVAB	PRCNAM_NAME,R1			; GET ADDRESS OF FAO STRING
	MOVZBL	(R1)+,R0			; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R0,-(SP)			; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0				; GET ADDRESS OF DESCRIPTOR
	$FAO_S	CTRSTR=(R0),-			; CONSTRUCT MAILBOX DEVICE NAME
		OUTBUF=8(R0),-			;
		OUTLEN=8(R0),-			;
		P1=R3,-				; ADDRESS OF USERNAME DESCRIPTOR
		P2=R4				; PROCESS NUMBER
	ADDL	#8,SP				; POP FAO CONTROL STRING DESCRIPTOR
	MOVQ	(SP)+,(R3)			; SET PROCESS NAME DESCRIPTOR

;
; CREATE THE SUBPROCESS
;
SPAWN_PROCESS:
	MOVAB	LOGINOUT,R1			; CONSTRUCT DESCRIPTOR OF IMAGE NAME
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,SPWN_Q_CLI(R6)		; SAVE DEFAULT CLI NAME
5$:	MOVL	#PRC$M_CLISPEC,R1		; ASSUME NON-INTERACTIVE (ALSO
						;   UNCONDITIONALLY INDICATE THAT
						;   CLI IS SPECIFIED.
	BBS	#SPWN_V_MODE,SPWN_W_FLAGS(R6),6$; BRANCH IF SO
	BISL	#PRC$M_INTER,R1			; SET INTERACTIVE BIT
6$:	$CREPRC_S IMAGE=SPWN_Q_CLI(R6),-	; CREATE THE PROCESS
		INPUT=SPWN_Q_INPUT(R6),-	; SPECIFY INPUT
		OUTPUT=SPWN_Q_OUTPUT(R6),-	; SPECIFY OUTPUT
		ERROR=SPWN_Q_MBXNAM(R6),-	; ERROR = COMM. MAILBOX NAME
		PRCNAM=SPWN_Q_PRCNAM(R6),-	; PROCESS NAME (USERNAME_1)
		BASPRI=SPWN_L_PRIB(R6),-	; PROPAGATE BASE PRIORITY
		QUOTA=SPWN_G_QUOTAS(R6),-	; PROPAGATE NON-DEDUCTIBLE QUOTAS
		MBXUNT=SPWN_W_UNIT(R6),-	; TERMINATION MAILBOX
		PIDADR=SPWN_L_SUBPID(R6),-	; RECEIVE PID HERE
		STSFLG=R1			; SET/CLEAR INTERACTIVE BIT
	CMPW	R0,#SS$_DUPLNAM			; PROCESS NAME ALREADY EXIST?
	BNEQ	10$				; IF NOT, PROCESS AS ANY OTHER ERROR
	BBS	#SPWN_V_PRCNAM,-		; BRANCH IF /PROCESS GIVEN
		SPWN_W_FLAGS(R6),10$ 		;
	ACBL	#255,#1,R4,CONSTRUCT_PRCNAM 	; INCREMENT NUMBER AFTER PROCESS NAME
10$:	BLBS	R0,15$				; IF ERROR CREATING PROCESS, REPORT IT
	BRW	SPAWN_EXIT			; CLEANUP AND EXIT WITH STATUS

;
; SAVE PROCESS NAME IN SPAWN BLOCK FOR USE BY /NOTIFY.
;
15$:	MOVB	SPWN_Q_PRCNAM(R6),-		; GET LENGTH OF PROCESS NAME
		SPWN_T_PROCESS(R6)		;
	MOVC3	SPWN_Q_PRCNAM(R6),-		; COPY THE NAME
		@SPWN_Q_PRCNAM+4(R6),-		;
		SPWN_T_PROCESS+1(R6)		;

;
; WRITE /LOG MESSAGE INDICATING PROCESS WAS CREATED
;
	BBC	#SPWN_V_LOG,-			; BRANCH IF /NOLOG SPECIFIED
		SPWN_W_FLAGS(R6),20$ 		;
	PUSHAB	SPWN_Q_PRCNAM(R6)		; ADDRESS OF PROCESS NAME
	MOVL	#1,R1				; SET NUMBER OF ARGS
	MOVL	#CLI$_SPAWNED,R0		; MESSAGE CODE
	BSBW	DCL$FORMMSG			; OUTPUT MESSAGE

;
; IF /WAIT /LOG THEN WRITE MESSAGE INDICATING SUBPROCESS ATTACHED.
; DO THIS BEFORE WE WRITE THE CONTEXT, WHILE WE STILL HAVE CONTROL OVER 
; THE TERMINAL.
;
20$:	BBC	#SPWN_V_WAIT,-			; SKIP IF /NOWAIT
		SPWN_W_FLAGS(R6),30$ 		;
	BBC	#SPWN_V_LOG,-			; SKIP IF /NOLOG SPECIFIED
		SPWN_W_FLAGS(R6),30$ 		;
	PUSHAB	SPWN_Q_PRCNAM(R6)		; ADDRESS OF PROCESS NAME
	MOVL	#1,R1				; SET NUMBER OF ARGS
	MOVL	#CLI$_ATTACHED,R0		; MESSAGE CODE
	BSBW	DCL$FORMMSG			; OUTPUT MESSAGE

;
; WRITE CONTEXT TO SUBPROCESS VIA MAILBOX.  IF AN ERROR OCCURS AT THIS POINT,
; WE MUST DELETE THE PROCESS TO AVOID HAVING IT HANG AROUND FOR NOTHING.
;
30$:	BBS	#SPWN_V_NOCTX,SPWN_W_FLAGS(R6),35$; BRANCH IF UNKNOWN CLI WAS SPECIFIED
	BSBW	WRITE_CONTEXT			; WRITE CONTEXT TO SUBPROCESS
	BLBS	R0,35$				; BRANCH IF OK
	PUSHL	R0				; SAVE WRITE STATUS
	$DELPRC_S PIDADR=SPWN_L_SUBPID(R6)	; DELETE THE SUBPROCESS
	CMPL	SPWN_L_STATUS(R6),#1		; GET TERMINATION STATUS
	BLEQU	32$				; USE IT IF SIGNIFICANT
	MOVL	SPWN_L_STATUS(R6),(SP)		;  (NEQ TO 0 OR 1)
32$:	POPL	R0				; RESTORE STATUS CODE
	BRB	60$				; SIGNAL THE ORIGINAL ERROR, OR THE
						; SUBPROCESS ABNORMAL STATUS (IF ANY)

;
; CLEANUP CONTEXT MAILBOX, TO ELIMINATE POOL USAGE AS SOON AS POSSIBLE.
;
35$:	$DASSGN_S CHAN=SPWN_W_CHAN(R6)		; CLEANUP MAILBOX (THUS, POOL USAGE)
	CLRW	SPWN_W_CHAN(R6)			; INDICATE CHANNEL WAS "REMOVED"
	MOVL	#1,R0				; IGNORE STATUS FROM DEASSIGN
						; WHILE WAITING FOR RE-ATTACH

;
; CREATE /NOWAIT SUBPROCESS.
;
	MOVL	#1,R1				; SET NORMAL TERMINATION STATUS
	BBS	#SPWN_V_WAIT,-			; BRANCH IF /NOWAIT
		SPWN_W_FLAGS(R6),9000$	;
	BRW	SPAWN_EXIT
9000$:
;
; CREATE /WAIT SUBPROCESS.  MARK THIS (PARENT) PROCESS DETACHED FROM TERMINAL.
;
	BBC	#SPWN_V_ACTIVE,- 		; BRANCH IF INACTIVE (SUBPROCESS
		SPWN_W_FLAGS(R6),60$		;     ALREADY TERMINATED)
	SETBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)	; MARK PROCESS DETACHED

;
; WAIT FOR SUBPROCESS TO RETURN CONTROL HERE (VIA ATTACH OR TERMINATION)
;
50$:	BSBW	CHECK_FOR_HANGUP		; CHECK FOR HANGUP AST
	MOVAQ	-(SP),R0			; ALLOCATE A TEMP. IOSB
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,-  ; SET ATTENTION AST ON MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-	;
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=(R0),-			;
		P1=ATTACH_AST,-			; ADDRESS OF AST ROUTINE
		P2=R11				; PASS ADDRESS OF CLI STORAGE
	ADDL	#8,SP				; CLEAN UP STACK
	$HIBER_S				; HIBERNATE WAITING FOR WAKEUP
	BBC	#SPWN_V_ACTIVE,-		; BRANCH IF SUBPROCESS INACTIVE
		SPWN_W_FLAGS(R6),55$  		; (SUBPROCESS HAS BEEN TERMINATED)
	BBS	#PRC_V_DETACHED,-		; BRANCH IF PARENT STILL DETACHED
		PRC_W_FLAGS(R11),50$ 		;
55$:	CLRBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)	; MARK PROCESS ATTACHED TO TERMINAL

;
; WE HAVE RETURNED FROM THE SUBPROCESS EITHER VIA A RE-ATTACH REQUEST TO 
; THIS PROCESS OR VIA SUBPROCESS TERMINATION.  IF /LOG WAS SPECIFIED, THEN
; OUTPUT THE RETURNED MESSAGE.
;
60$:	BBC	#SPWN_V_LOG,-			; BRANCH IF /NOLOG SPECIFIED
		SPWN_W_FLAGS(R6),70$ 		;
	PUSHL	R0				; SAVE FINAL STATUS
	BSBW	RETURNED_MESSAGE		; WRITE MESSAGE SAYING WE HAVE RETURNED
	POPL	R0				; RESTORE FINAL STATUS

;
; IF WE ARE IN AN INTERACTIVE PROCESS, THEN TELL THE TERMINAL DRIVER THAT
; WE NOW OWN THE TERMINAL.
;
70$:	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),80$; SKIP IF NOT INTERACTIVE
	PUSHL	R0				; SAVE FINAL STATUS
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_TT_PROCESS,- ; ASSUME TERMINAL OWNERSHIP
		CHAN=PRC_W_INPCHAN(R11),-	;
		IOSB=SPWN_Q_IOSB(R6),-		;
		EFN=#EXE$C_SYSEFN		;
	POPL	R0				; RESTORE FINAL STATUS

;
; IF THIS IS A RE-ATTACH THEN SKIP DATA STRUCTURE AND MAILBOX DELETIONS AND
; SET NORMAL TERMINATION STATUS.  OTHERWISE, SET THE RETURNED TERMINATION STATUS.
;
80$:	MOVL	#1,R1				; SET NORMAL TERMINATION STATUS
	BBS	#SPWN_V_ACTIVE,-		; BRANCH IF CONTROL RETURNED
		SPWN_W_FLAGS(R6),RESTORE_CONTEXT;    VIA A RE-ATTACH
	MOVL	SPWN_L_STATUS(R6),R1		; GET TERMINATION STATUS

;
; THE SPAWN COMMAND IS ESSENTIALLY COMPLETE.  WE HAVE RETURNED CONTROL HERE
; DUE TO SUBPROCESS TERMINATION.  THERFORE, CLEANUP MISC. DATA STRUCTURES AND 
; MAILBOXES AND REPORT ANY ERRORS WHICH WERE DETECTED.
;
; IF SUBPROCESS WAS SUCCESSFULLY SPAWNED AND TERMINATED, THEN TMBX WAS
; DELETED BY THE TERMINATION AST.  IF NOT, TRY TO DEASSIGN THE MAILBOX AND 
; DELETE THE DATA STRUCTURE HERE.
;
SPAWN_EXIT:
	MOVQ	R0,-(SP)			; SAVE ERROR AND TERMINATION STATUS
	BLBS	R0,10$				; BRANCH IF SUCCESSFUL SPAWN
	BBC	#SPWN_V_ACTIVE,-		; DID SUBPROCESS TERMINATE?
		SPWN_W_FLAGS(R6),10$		; IF SO, TERMINATION MBX TAKEN CARE OF
	DECB	TMBX_B_REFS(R7)			; DECR REFERENCE COUNT TO MAILBOX
	BNEQ	10$				; BRANCH IF STILL OUTSTANDING USES
	BSBW	DELETE_TMBX			; DELETE TERMINATION MAILBOX AND TMBX

;
; IN ALL CASES, DELETE THE ATTACH MAILBOX AND DEASSIGN THE CONTEXT MAILBOX 
; CHANNEL.
;
10$:	BSBW	DELETE_ATTMBX			; DELETE THE ATTACH MAILBOX
	$DASSGN_S CHAN=SPWN_W_CHAN(R6)		; DEASSIGN CONTEXT MAILBOX CHANNEL
	CLRW	SPWN_W_CHAN(R6)			; INDICATE CHANNEL WAS "REMOVED"

;
; IF /WAIT, THEN DEALLOCATE THE SPWN BLOCK.
;
	BBC	#SPWN_V_WAIT,-			; BRANCH IF /NOWAIT
		SPWN_W_FLAGS(R6),20$		;
	BSBW	DEALLOC_SPWN			; REMOVE INACTIVE SPWN BLOCKS
20$:	MOVQ	(SP)+,R0			; RESTORE ERROR AND TERMINATION STATUS

;
; IN ALL CASES, RESTORE THE PROCESS STATE -
;	STACK, EVENT FLAGS, CONTROL KEY AST'S, SPAWN STATUS, TERMINATION STATUS,
;	AND SAVED REGISTERS.
;
RESTORE_CONTEXT:
	MOVAB	768+8(SP),SP			; POP SCRATCH STORAGE OFF STACK
	MOVQ	R0,-(SP)			; SAVE ERROR AND TERMINATION STATUS
	MOVL	SPWN_L_OUTOFBAND(R6),R1		; RESTORE OUT-OF-BAND ENABLE MASK
	BSBW	DCL$RESETOOB			; RESTORE AST'S
	POPR	#^M<R0,R1,R2,R3,R4,R5,R7,R8>	; RESTORE REGISTERS

;
; IF A HANGUP IS PENDING, THEN ABORT PROCESS
;
	BBC	#PRC_V_HANGUP,-			; IF SET, HANG-UP PENDING
		PRC_W_FLAGS(R11),20$		;
	ADDL 	#8,SP				; POP TWO PC'S OFF THE STACK
	BRW	DCL$ABORT			; LOG THE PROCESS OUT
20$:	RSB					; EXIT

	.SBTTL	PROCESS SPAWN INPUT STREAM
;---
;
; THIS ROUTINE IS CALLED TO PROCESS THE SPAWN INPUT STREAM.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPAWN BLOCK
;	R8 = DESCRIPTOR OF SCRATCH AREA
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

VERIFY_INPUT:
;
; DETERMINE IF AN AUTOMATIC LOGOUT SHOULD OCCUR AFTER EXECUTION OF THE
; COMMAND STRING.  IF ONLY THE COMMAND STRING WAS SPECIFIED, THEN LOGOUT
; AFTER IT IS EXECUTED.  IF BOTH THE COMMAND STRING AND /INPUT WERE SPECIFIED, 
; THEN CAUSE THE COMMAND STRING TO BE EXECUTED FIRST, FOLLOWED BY THE /INPUT 
; STREAM.  
;
	BBS	#SPWN_V_INPUT,-			; IF INPUT SPECIFIED,
		SPWN_W_FLAGS(R6),10$		; KEEP AUTOLOGUT FLAG OFF
	MOVZBL	SYS$INPUT,SPWN_Q_INPUT(R6)	; USE "SYS$INPUT"
	MOVAB	SYS$INPUT+1,SPWN_Q_INPUT+4(R6)	;
	TSTW	SPWN_Q_CMDSTR(R6)		; ANY COMMAND STRING SPECIFIED?
	BEQL	10$				; NO, DO NOT SET IMPLIED LOGOUT
	SETBIT	SPWN_V_AUTOLOGO,-		; YES, SET IMPLIED LOGOUT FLAG
		SPWN_W_FLAGS(R6) 		;

;
; CHECK THAT INPUT FILE SPECIFICATION IS NOT TOO LONG. 
;
10$:	MOVL	#CLI$_INVFILSPE,R0		; ASSUME INVALID FILE SPEC
	CMPW	SPWN_Q_INPUT(R6),-		; NAME TOO LONG?
		#NAM$C_MAXRSS			;
	BGTRU	25$				; IF SO, EXIT WITH ERROR

; 
; ALLOCATE FAB AND NAM BLOCKS AND THEN $PARSE THE INPUT FILE SPECIFICATION.
;
	MOVAB	-FAB$C_BLN-NAM$C_BLN(SP),SP	; ALLOCATE FAB AND NAM BLOCKS
	MOVC5	#0,(SP),#0,-			; ZERO FAB AND NAM
		#FAB$C_BLN+NAM$C_BLN,(SP)	;
	MOVL	SP,R4				; GET BASE OF FAB
	MOVAB	FAB$C_BLN(R4),R5		; GET BASE OF NAM

	ASSUME	FAB$B_BLN EQ FAB$B_BID+1	; INIT FAB
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,-	; SET FAB ID
		FAB$B_BID(R4)			;
	SETBIT	FAB$V_PPF,FAB$L_FOP(R4)		; USE PROCESS I/O SEGMENT
	MOVB	SPWN_Q_INPUT(R6),FAB$B_FNS(R4)	; SPECIFY FILE NAME
	MOVL	SPWN_Q_INPUT+4(R6),FAB$L_FNA(R4);
	MOVB	COM,FAB$B_DNS(R4)		; SPECIFY DEFAULT FILE TYPE
	MOVAB	COM+1,FAB$L_DNA(R4)		;
	MOVL	R5,FAB$L_NAM(R4)		; SPECIFY NAM BLOCK ADDRESS

	ASSUME	NAM$B_BLN EQ NAM$B_BID+1	; INIT NAM
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,-	; SET NAM ID
		NAM$B_BID(R5)			;
	MOVB	#NAM$M_NOCONCEAL,NAM$B_NOP(R5)	; GET PAST DOUBLE UNDERSCORES
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R5)	; SPECIFY RESULT BUFFER
	MOVL	4(R8),NAM$L_ESA(R5)		;

	$PARSE	FAB=(R4)			; PARSE THE FILE SPEC
	BLBS	R0,30$				; CONTINUE IF SUCCESSFUL

20$:	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; DEALLOCATE FAB AND NAM
25$:	BRW	95$				; EXIT WITH ERROR

;
; PROCESS NON-PPF INPUT HERE.  IF NOT RECORD-ORIENTED, THEN USE EXPANDED
; STRING AS INPUT, DO A $SEARCH FOR THE FILE, AND SET SILENT LOGOUT FLAG.  
; IF RECORD-ORIENTED THEN USE DEV FIELD AS INPUT.
;
30$:	BBS	#NAM$V_PPF,NAM$L_FNB(R5),50$	; BRANCH IF PPF FILE
	MOVZBL	NAM$B_ESL(R5),R0		; GET LENGTH OF RESULT STRING
	SUBL	R0,(R8)				; PERMANENTLY REMOVE RESULT 
	ADDL	R0,4(R8)			;    FROM SCRATCH AREA
	BBC	#DEV$V_REC,FAB$L_DEV(R4),40$	; BRANCH IF NOT REC-ORIENTED
	MOVZBL	NAM$B_DEV(R5),SPWN_Q_INPUT(R6)	; USE DEVICE AS INPUT
	MOVL	NAM$L_DEV(R5),SPWN_Q_INPUT+4(R6); 	
	BRW	56$				; PROCESS AS PPF DEVICE

;
; INPUT IS A NON-PPF NON-RECORD-ORIENTED DEVICE.  $SEARCH FOR THE FILE.
; IF FOUND, THEN USE THE ESS AS SYS$INPUT.  ALSO, MARK THE PROCESS AS
; NON-INTERACTIVE.
;
40$:	$SEARCH	FAB=(R4)			; SEARCH FOR THE SPECIFIED FILE
	BLBC	R0,20$				; BRANCH IF NOT FOUND
	MOVZBL	NAM$B_ESL(R5),SPWN_Q_INPUT(R6)	; USE ESS AS INPUT FILE SPEC
	MOVL	NAM$L_ESA(R5),SPWN_Q_INPUT+4(R6);
	SETBIT	SPWN_V_MODE,SPWN_W_FLAGS(R6) 	; SET NON-INTERACTIVE SUBPROCESS
45$:	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; DEALLOCATE FAB AND NAM
	BRW	90$				; DONE WITH PARSING

;
; INPUT IS PPF.  IF FROM A RECORD-ORIENTED DEVICE, DO $GETDVI TO GET 
; THE DEVICE NAME.  OTHERWISE, 1) IF EXPLICITLY SPECIFIED THEN RETURN AN
; ERROR, 2) IF INTERACTIVE PROCESS THEN USE THE TERMINAL AS INPUT, 3) IF
; NON-INTERACTIVE PROCESS THEN USE NL: AS INPUT.
;
50$:	BBC	#SPWN_V_INPUT,SPWN_W_FLAGS(R6),52$ ; SKIP IF IMPLICIT INPUT
	MOVL	#CLI$_SPWNIO,R0  		; ASSUME ILLEGAL INPUT FILE
	BBC	#DEV$V_REC,FAB$L_DEV(R4),20$	; ERROR IF NOT REC-ORIENTED

;
; PROCESS LEGAL NON-RECORD-ORIENTED PPF INPUT.
;
52$:	BBS	#DEV$V_REC,FAB$L_DEV(R4),56$	; BRANCH IF REC-ORIENTED
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),53$; BRANCH IF NOT INTERACTIVE
	MOVL	#CTL$AG_CLIDATA+PPD$T_INPDVI,R1	; GET ADDRESS OF ASCIC DEVICE NAME
	MOVZBL	(R1)+,R5			; GET LENGTH OF DEVICE
	MOVQ	R4,-(SP)			; SAVE R4/R5
	MOVC3	R5,(R1),@4(R8)			; COPY STRING TO SCRATCH AREA
	MOVB	#^A':',(R3)			; ADD COLON TO END OF STRING
	MOVQ	(SP)+,R4			; RESTORE R4/R5
	INCL	R5				; ADD LENGTH OF A COLON
	MOVL	R5,SPWN_Q_INPUT(R6)		; SAVE DEVICE DESCRIPTOR
	MOVL	4(R8),SPWN_Q_INPUT+4(R6)	;
	SUBW	R5,(R8)				; PERMANENTLY REMOVE DEVICE
	ADDL	R5,4(R8)			;    FROM SCRATCH AREA
	MOVL	@#CTL$AG_CLIDATA+PPD$L_INPDEV,-	; GET INPUT DEVICE CHARS
		FAB$L_DEV(R4)			;
	BBS	#DEV$V_REC,FAB$L_DEV(R4),58$	; BRANCH IF REC-ORIENTED
53$:	MOVZBL	NL,SPWN_Q_INPUT(R6)		; SET INPUT TO NL:
	MOVAB	NL+1,SPWN_Q_INPUT+4(R6)		;
	CLRL	FAB$L_DEV(R4)			; CLEAR DEVICE CHARACTERISTICS
	BRB	58$				;

;
; PROCESS REC-ORIENTED PPF INPUT.
;
56$:	MOVQ	SPWN_Q_INPUT(R6),R2		; COPY DESCRIPTOR OF DEVICE NAME
	MOVQ	(R8),R4				; COPY DESCRIPTOR OF SCRATCH AREA
	BSBW	GET_DEVICE			; GET DEVICE NAME
	MOVQ	R4,SPWN_Q_INPUT(R6)		; SAVE EQUIVALENCE STRING
	SUBW	R4,(R8)				; PERMANENTLY REMOVE RESULT
	ADDL	R4,4(R8)			;    FROM SCRATCH AREA

;
; GET TERMINAL CHARACTERISTICS.  DO NOT SPAWN THE SUBPROCESS IF THE TERMINAL 
; HAS AN ASSOCIATED MAILBOX.  
;
58$:	MOVL	FAB$L_DEV(SP),R0		; GET DEVICE CHARACTERISTICS
	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; DEALLOCATE FAB AND NAM
	BBS	#DEV$V_TRM,R0,59$		; SKIP IF INPUT IS NOT A TERMINAL
	SETBIT	SPWN_V_MODE,SPWN_W_FLAGS(R6) 	; SET NON-INTERACTIVE SUBPROCESS
	BRB	90$				; ALL DONE
59$:	MOVAQ	SPWN_Q_INPUT(R6),R1		; GET ADDRESS OF INPUT STRING
	BSBW	CHECK_TRMMBX			; CHECK FOR MAILBOX
	BLBC	R0,95$				; BRANCH IF IT EXISTS

;
; CHECK THAT INPUT FILE SPEC IS NOT TOO LONG FOR $CREPRC TO HANDLE.
;
90$:	MOVL	#CLI$_INVFILSPE,R0		; ASSUME SPEC IS TOO LONG
	CMPW	#LNM$C_NAMLENGTH,SPWN_Q_INPUT(R6)	; IS IT REALLY?
	BLSSU	95$				; YES, THEN ERROR

;
; RETURN WITH STATUS
;
	MOVL	#1,R0				; SET NORMAL STATUS
95$:	RSB					; EXIT WITH STATUS

	.SBTTL	CHECK FOR ASSOCIATED TERMINAL MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO CHECK FOR AN ASSOCIATED TERMINAL MAILBOX.
; SUBPROCESS IS NOT SPAWNED OR ATTACHED IF THE TERMINAL HAS AN ASSOCIATED 
; MAILBOX.  
;
; INPUTS:
;
;	R1	ADDRESS OF DESCRIPTOR OF TERMINAL DEVICE NAME
;
; OUTPUTS:
;
;	R0 	STATUS CODE
;---

CHECK_TRMMBX:
	MOVQ	R2,-(SP)			; SAVE REGISTERS
	CLRQ	-(SP)				; ALLOCATE AN IOSB
	MOVAL	-(SP),R2			; ALLOCATE LONGWORD FOR CHANNEL NUMBER
	SUBL	#12,SP				; ALLOCATE DEVICE CHARACTERISTICS BUFFER
	MOVL	SP,R3				; SAVE BUFFER ADDRESS
	$ASSIGN_S  DEVNAM=(R1),-		; GET A CHANNEL TO THE TERMINAL
		CHAN=(R2)			;
	BLBC	R0,90$				; BRANCH IF ERROR

	$QIOW_S	FUNC=#IO$_SENSEMODE,- 		; GET TERMINAL CHARACTERISTICS
		CHAN=(R2),-			;
		IOSB=4(R2),-			;
		EFN=#EXE$C_SYSEFN,-		;
		P1=(R3),-			;
		P2=#12				;
	BLBC	R0,90$				; BRANCH IF ERROR
	MOVZWL	4(R2),R0			; GET IOSB STATUS
	BLBC	R0,90$				; BRANCH IF ERROR

	$DASSGN_S CHAN=(R2) 			; DEASSIGN TERMINAL CHANNEL
	BLBC	R0,90$				; BRANCH IF ERROR

	MOVL	#CLI$_TRMMBX,R0			; ASSUME ASSOCIATED TERMINAL MBX
	BBS	#TT2$V_DCL_MAILBX,8(R3),90$	; EXIT WITH ERROR IF TRUE
	MOVL	#1,R0				; SET SUCCESS

90$:	ADDL	#8+4+12,SP			; RESTORE STACK
	MOVQ	(SP)+,R2			; RESTORE REGISTERS
	RSB					;

	.SBTTL	PROCESS SPAWN OUTPUT STREAM
;---
;
; THIS ROUTINE IS CALLED TO PROCESS THE SPAWN OUTPUT STREAM.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPAWN BLOCK
;	R8 = DESCRIPTOR OF SCRATCH AREA
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

VERIFY_OUTPUT:
;
; IF OUTPUT FILE SPECIFICATION NOT SPECIFIED, THEN USE CURRENT SYS$OUTPUT
;
	BBS	#SPWN_V_OUTPUT,-		; IF OUTPUT SPECIFIED,
		SPWN_W_FLAGS(R6),10$		; THEN USE IT
	MOVZBL	SYS$OUTPUT,SPWN_Q_OUTPUT(R6)	; ELSE USE "SYS$OUTPUT"
	MOVAB	SYS$OUTPUT+1,SPWN_Q_OUTPUT+4(R6);

;
; CHECK THAT OUTPUT FILE SPECIFICATION IS NOT TOO LONG. 
;
10$:	MOVL	#CLI$_INVFILSPE,R0		; ASSUME INVALID FILE SPEC
	CMPW	SPWN_Q_OUTPUT(R6),#NAM$C_MAXRSS	; NAME TOO LONG?
	BGTRU	25$				; IF SO, EXIT WITH ERROR

;
; ALLOCATE FAB AND NAM BLOCKS AND THEN $PARSE THE OUTPUT FILE SPECIFICATION.
;
	MOVAB	-FAB$C_BLN-NAM$C_BLN(SP),SP	; ALLOCATE FAB AND NAM BLOCKS
	MOVC5	#0,(SP),#0,-			; ZERO FAB AND NAM
		#FAB$C_BLN+NAM$C_BLN,(SP)	;
	MOVL	SP,R4				; GET BASE OF FAB
	MOVAB	FAB$C_BLN(R4),R5		; GET BASE OF NAM

	ASSUME	FAB$B_BLN EQ FAB$B_BID+1	; INIT FAB
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,-	; SET FAB ID
		FAB$B_BID(R4)			;
	SETBIT	FAB$V_PPF,FAB$L_FOP(R4)		; USE PROCESS I/O SEGMENT
	MOVB	SPWN_Q_OUTPUT(R6),FAB$B_FNS(R4)	; SPECIFY FILE NAME
	MOVL	SPWN_Q_OUTPUT+4(R6),FAB$L_FNA(R4);
	MOVB	LOG,FAB$B_DNS(R4)		; SPECIFY DEFAULT FILE TYPE
	MOVAB	LOG+1,FAB$L_DNA(R4)		;
	MOVL	R5,FAB$L_NAM(R4)		; SPECIFY NAM BLOCK ADDRESS

	ASSUME	NAM$B_BLN EQ NAM$B_BID+1	; INIT NAM
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,-	; SET NAM ID
		NAM$B_BID(R5)			;
	MOVB	#NAM$M_NOCONCEAL,NAM$B_NOP(R5)	; GET PAST DOUBLE UNDERSCORES
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R5)	; SPECIFY RESULT BUFFER
	MOVL	4(R8),NAM$L_ESA(R5)		;
	$PARSE	FAB=(R4)			; PARSE THE FILE SPEC
	BLBS	R0,30$				; CONTINUE IF SUCCESSFUL

20$:	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; DEALLOCATE FAB AND NAM
25$:	BRW	95$				; EXIT WITH ERROR

;
; PROCESS NON-PPF OUTPUT HERE.  IF NOT RECORD-ORIENTED, THEN USE EXPANDED
; STRING AS OUTPUT.  IF RECORD-ORIENTED THEN USE DEV FIELD AS OUTPUT.
;
30$:	BBS	#NAM$V_PPF,NAM$L_FNB(R5),50$	; BRANCH IF PPF FILE
	MOVZBL	NAM$B_ESL(R5),R0		; GET LENGTH OF RESULT STRING
	SUBL	R0,(R8)				; PERMANENTLY REMOVE RESULT 
	ADDL	R0,4(R8)			;    FROM SCRATCH AREA
	BBC	#DEV$V_REC,FAB$L_DEV(R4),40$	; BRANCH IF NOT REC-ORIENTED
	MOVZBL	NAM$B_DEV(R5),SPWN_Q_OUTPUT(R6)	; USE DEVICE AS OUTPUT
	MOVL	NAM$L_DEV(R5),SPWN_Q_OUTPUT+4(R6); 	
	BRB	56$				; PROCESS AS PPF DEVICE

;
; OUTPUT IS A NON-PPF NON-RECORD-ORIENTED DEVICE.  USE THE ESS AS OUTPUT.
;
40$:	MOVZBL	NAM$B_ESL(R5),SPWN_Q_OUTPUT(R6)	; USE ESS AS OUTPUT FILE SPEC
	MOVL	NAM$L_ESA(R5),SPWN_Q_OUTPUT+4(R6);
	BRB	90$				; DONE WITH PARSING

;
; OUTPUT IS PPF.  IF FROM A RECORD-ORIENTED DEVICE, DO $GETDVI TO GET 
; THE DEVICE NAME.  OTHERWISE, IF EXPLICITLY SPECIFIED THEN RETURN AN
; ERROR ELSE CREATE A MAILBOX THAT WILL CAUSES WRITES TO GO TO THE PARENT'S
; OUTPUT STREAM.
;
50$:	BBC	#SPWN_V_OUTPUT,SPWN_W_FLAGS(R6),51$ ; SKIP IF IMPLICIT OUTPUT
	MOVL	#CLI$_SPWNIO,R0  		; ASSUME ILLEGAL OUTPUT FILE
	BBC	#DEV$V_REC,FAB$L_DEV(R4),20$	; ERROR IF NOT REC-ORIENTED
	BRB	52$

;
; IF AT CTRL/Y LEVEL, THEN DON'T USE SYS$OUTPUT.  USE THE OUTPUT STREAM
; SPECIFIED AT PROCESS CREATION TIME.
;
51$:	BBC	#PRC_V_YLEVEL,-			; IF CTRL/Y LEVEL,
		PRC_W_FLAGS(R11),52$		; THEN SPECIAL CASE SYS$OUTPUT
	MOVL	PRC_L_OUTRABCTX(R11),-		; GET DEVICE CHARACTERISTICS
		FAB$L_DEV(R4)			;
	MOVAB	PRC_T_OUTDVI(R11),R1		; GET DEVICE NAME DESCRIPTOR
	MOVZBL	(R1)+,R0			; 
	MOVQ	R0,SPWN_Q_OUTPUT(R6)		; SAVE DEVICE NAME DESCRIPTOR

;
; PROCESS LEGAL NON-RECORD-ORIENTED OUTPUT.
;
52$:	BBS	#DEV$V_REC,FAB$L_DEV(R4),56$	; ERROR IF NOT REC-ORIENTED
	BSBW	CREATE_OUTMBX			; CREATE OUTPUT MAILBOX
	BRB	91$				; DO NOT SET OUTPUT BIT

;
; PROCESS RECORD-ORIENTED OUTPUT.
;
56$:	MOVQ	SPWN_Q_OUTPUT(R6),R2		; COPY DESCRIPTOR OF DEVICE NAME
	MOVQ	(R8),R4				; COPY DESCRIPTOR OF SCRATCH AREA
	BSBW	GET_DEVICE			; GET DEVICE NAME
	MOVQ	R4,SPWN_Q_OUTPUT(R6)		; SAVE EQUIVALENCE STRING
	SUBW	R4,(R8)				; PERMANENTLY REMOVE RESULT
	ADDL	R4,4(R8)			;    FROM SCRATCH AREA

;
; CHECK THAT OUTPUT FILE SPEC IS NOT TOO LONG FOR $CREPRC TO HANDLE.
;
90$:	SETBIT	SPWN_V_OUTPUT,SPWN_W_FLAGS(R6)	; SET NO MAILBOX IN USE
91$:	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; DEALLOCATE FAB AND NAM
	MOVL	#CLI$_INVFILSPE,R0		; ASSUME SPEC IS TOO LONG
	CMPW	#LNM$C_NAMLENGTH,SPWN_Q_OUTPUT(R6)	; IS IT REALLY?
	BLSSU	95$				; YES, THEN ERROR

;
; EXIT WITH STATUS
;
	MOVL	#1,R0				; SET NORMAL STATUS
95$:	RSB					; EXIT WITH STATUS

	.SBTTL	ATTACH COMMAND
;+
; DCL$ATTACH - ATTACH COMMAND
;
; THIS ROUTINE IS CALLED TO EXECUTE THE DCL ATTACH COMMAND.  THE ATTACH
; COMMAND TRANSFERS EXCLUSIVE CONTROL OF THE TERMINAL FROM THIS PROCESS
; TO ANOTHER PROCESS BY MUTUAL COOPERATION.  A MESSAGE IS SENT TO THE
; "DESTINATION" PROCESS'S ATTACH REQUEST MAILBOX ASKING IF IT WANTS TO
; HAVE CONTROL OF THE TERMINAL.  THE DESTINATION PROCESS RESPONDS WITH
; A YES/NO REPLY DEPENDING ON ITS STATE.  IF IT RESPONDS WITH YES, THEN
; WE MARK OURSELVES DETACHED, AND WAIT FOR A RE-ATTACH REQUEST.
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;-
 
DCL$ATTACH::
;
; GET THE PROCESS NAME OR PID FROM THE COMMAND LINE
;
	CLRL	R6			; MARK NO PROCESS NAME SUPPLIED YET
	CLRL	R8			; MARK NO PID SUPPLIED YET
40$:	BSBW	DCL$GETDVAL		; GET NEXT TOKEN
	BLBC	R0,50$			; BRANCH IF END OF LINE
	CMPL	R5,#PTR_K_COMDQUAL	; VERB QUALIFIER?
	BEQL	42$			; BRANCH IF SO
	CMPL	R5,#PTR_K_PARAMETR	; PARAMETER (PROCESS NAME)?
	BNEQ	40$			; IF NOT, IGNORE IT
	MOVQ	R1,R6			; SAVE DESCRIPTOR OF PROCESS NAME
	BRB	40$
42$:	BSBW	DCL$GETNVAL		; GET QUALIFIER NUMBER
	CMPB	R1,#CLI$K_ATTA_IDEN	; /IDENTIFICATION?
	BNEQ	40$			; IF NOT, IGNORE IT
	CMPB	R4,#PTR_K_COLON		; IS A VALUE PRESENT?
	BNEQ	40$			; IF NOT, USE DEFAULT
	BSBW	DCL$GETDVAL		; GET /IDENT VALUE
	MOVQ	R1,R2			; PASS DESCRIPTOR OF VALUE STRING
	MOVZBL	#PRC_K_HEX,R1		; DEFAULT RADIX = HEX
	BSBW	DCL$CNVASCBIN		; CONVERT TO BINARY
	BNEQ	45$			; BRANCH IF CONVERSION ERROR
	MOVL	R1,R8			; SAVE PID AWAY
	BRB	40$
45$:	STATUS	EXPSYN			; EXPRESSION SYNTAX ERROR
	RSB
50$:	BSBB	DCL$ATTACH2		; PERFORM ACTUAL ATTACH OPERATION
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	BSBW	RETURNED_MESSAGE	; WRITE MESSAGE SAYING WE HAVE RETURNED
	MOVL	#1,R0			; INDICATE SUCCESS
90$:	RSB				; RETURN WITH STATUS

	.SBTTL	PERFORM ATTACH OPERATION
;---
;
; ALTERNATE ENTRY POINT, USED BY ATTACH CLI CALLBACK.  NO USE OF THE
; WRK AREA MUST BE MADE AFTER THIS POINT, SINCE CLI CALLBACKS OPERATE
; WITHOUT ANY SUCH AREA.
;
; INPUTS:
;
;	R6/R7 = DESCRIPTOR OF PROCESS NAME
;	R8 = PID OF DESTINATION PROCESS
;	R11 = ADDRESS OF PRC AREA
;
;	EITHER THE PID OR PROCESS NAME MUST BE SPECIFIED.
;
; OUTPUTS:
;
;	R0 = FINAL STATUS
;
;---

DCL$ATTACH2::
;
; CONTROL/Y AST'S ARE DISABLED THROUGHOUT THIS COMMAND, TO ENSURE THAT
; MAILBOXES WHICH ARE CREATED HERE ARE CORRECTLY DELETED, ETC.  AS A
; RESULT, WE MUST PERIODICALLY CHECK THE HANGUP FLAG IN CASE A HANGUP
; IS DETECTED WHILE WE ARE OPERATING.
;
	PUSHL	PRC_L_OUTOFBAND(R11)	; SAVE OUT-OF-BAND ENABLE MASK
	CLRL	R1			; DISABLE ALL OUT-OF-BAND AST'S
	BSBW	DCL$RESETOOB

;
; LOOKUP THE DESTINATION PROCESS, AND IF PRESENT, GET THE PID AND MPID
;
	CLRQ	-(SP)			; ALLOCATE AN IOSB
	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4		; REQUEST PID, SET BUFFER LENGTH
	CLRL	-(SP)			; SETUP MPID REQUEST ITEM
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_MASTER_PID@16+4	; REQUEST MPID, SET BUFFER LENGTH
	PUSHR	#^M<R6,R7,R8>		; PUSH PROCESS NAME DESCRIPTOR, PID
	MOVL	SP,R0			;
	$GETJPIW_S  ITMLST=12(R0),-	; GET PID OF THE PROCESS
		IOSB=40(R0),-		;
		EFN=#EXE$C_SYSEFN,-	;
		PRCNAM=(R0),-		;
		PIDADR=8(R0)		;
	ADDL	#3*4,SP			; POP PRCNAM DESCRIPTOR, PID
	POPL	R3			; GET THE DESTINATION MPID
	ADDL	#2*4,SP			; POINT TO RETURNED DESTINATION PID
	POPL	R2			; GET THE DESTINATION PID
	ADDL	#3*4,SP			; POP ITEM LIST
	BLBC	R0,49$			; BRANCH IF ERROR
	MOVZWL	(SP),R0			; GET IOSB STATUS
	BLBS	R0,55$			; BRANCH IF PROCESS FOUND
49$:	ADDL	#8,SP			; POP THE IOSB
	BRW	95$			; REPORT ERROR

;
; MAKE SURE WE AREN'T TRYING TO ATTACH TO OURSELVES
;
55$:	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4		; REQUEST OUR PID, SET BUFFER LENGTH
	CLRL	-(SP)			; SETUP MPID REQUEST ITEM
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_MASTER_PID@16+4	; REQUEST OUR MPID, SET BUFFER LENGTH
	MOVL	SP,R0			;
	$GETJPIW_S  ITMLST=(R0),-	; GET PID OF THIS PROCESS
		IOSB=28(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	POPL	R4			; GET OUR MPID
	ADDL	#2*4,SP			; POINT TO OUR RETURNED PID
	POPL	R1			; GET OUR PID
	ADDL	#3*4,SP			; CLEANUP STACK
	MOVL	#CLI$_REFUSED,R0	; ASSUME AN ERROR
	CMPL	R1,R2			; TRYING TO ATTACH TO OURSELF?
	BEQL	49$			; IF SO, REJECT THE OPERATION
	CMPL	R3,R4			; TRYING TO ATTACH TO A PROCESS OUTSIDE
					;     OF OUR JOB?
	BNEQ	49$			; IF SO, REJECT THE OPERATION
	ADDL	#8,SP			; POP THE IOSB

;
; CREATE ATTACH$PID LOGICAL NAME FOR DESTINATION ATTACH MAILBOX
;
	SUBL	#30,SP			; ALLOCATE ROOM FOR NAME
	PUSHL	SP			; CREATE DESCRIPTOR FOR NAME
	PUSHL	#30			;
	MOVAB	ATTACH_NAME,R1		; GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R0,-(SP)		; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0
	$FAO_S	CTRSTR=(R0),-		; CONSTRUCT LOGICAL NAME
		OUTBUF=8(R0),-
		OUTLEN=8(R0),-
		P1=R2			; FROM PID FOR THIS PROCESS
	ADDL	#8,SP			; POP FAO STRING DESCRIPTOR

;
; GET SYS$INPUT TRANSLATION (TERMINAL DEVICE NAME).
; IF WE ARE AT CTRL/Y LEVEL, USE PROCESS PERMANENT SYS$INPUT INSTEAD.
;
60$:	MOVZWL	#ATTMBX_MAXMSG,R4		; SET SIZE OF SCRATCH BUFFER
	SUBL	R4,SP				; ALLOCATE SCRATCH BUFFER FOR STRING
	MOVL	SP,R5				; CREATE DESCRIPTOR OF BUFFER
	MOVQ	R2,-(SP)			; SAVE R2/R3
	BBC	#PRC_V_YLEVEL,-			; IF CTRL/Y LEVEL,
		PRC_W_FLAGS(R11),62$		; THEN SPECIAL CASE SYS$OUTPUT
	MOVL	#CTL$AG_CLIDATA+PPD$T_INPDVI,R3	; GET ADDRESS OF ASCIC DEVICE NAME
	BRB	64$				; SKIP SYS$INPUT PROCESSING
62$:	MOVAB	SYS$INPUT,R3			; CREATE SYS$INPUT DESCRIPTOR
64$:	MOVZBL	(R3)+,R2			;
	BSBW	GET_DEVICE			; GET INPUT DEVICE NAME
	BLBC	R0,651$				; BRANCH IF ERROR
;
; CHECK IF WE ARE A TERMINAL
;
	CLRQ	-(SP)				; ALLOCATE AN IOSB
	MOVQ	R2,-(SP)			; PUSH DEVICE DESCRIPTOR ON STACK
	MOVL	SP,R1				; GET ADDR. OF DESCRIPTOR
	CLRQ	-(SP)				; CREATE AN ITEM LIST
	PUSHAB	-2*4(SP)			; SET BUFFER ADDR.
	PUSHL	#DVI$_DEVCLASS@16+4		; REQUEST DEVICE CLASS
	MOVL	SP,R0				;
	$GETDVIW_S  DEVNAM=(R1),-		; GET INPUT DEVICE CLASS
		IOSB=8(R1),-
		EFN=#EXE$C_SYSEFN,-
		ITMLST=(R0)
	MOVL	(SP),R1				; GET DEVICE CLASS
	ADDL	#4*8,SP				; POP GETDVI ARGS. OFF THE STACK
	BLBC	R0,651$				; REFUSE ATTACH IF ERROR
	CLRL	R0				; ASSUME IT IS A TERMINAL
	CMPL	R1,#DC$_TERM			; IS INPUT DEVICE A TERMINAL?
	BEQL	641$				; BR IF YES. FLAG OK AS IS
	INCL	R0				; INDICATE NOT A TERMINAL
641$:	MOVQ	(SP)+,R2			; RESTORE R2/R3

;
; CHECK FOR AN ASSOCIATED TERMINAL MAILBOX.
;
	MOVQ	R4,-(SP)			; PUSH SYS$INPUT TRANSLATION
	MOVL	SP,R1				; GET ADDRESS OF INPUT STRING
	BLBS	R0,66$				; DON'T CHECK FOR MAILBOX IF
						;     NOT A TERMINAL
	BSBW	CHECK_TRMMBX			; CHECK FOR MAILBOX
	BLBS	R0,66$				; BRANCH IF SUCCESS

65$:	BRW	90$				; 
651$:	MOVL	#CLI$_REFUSED,R0		; SET STATUS
	BRW	90$				; 

;
; CREATE ATTACH MAILBOX FOR THIS PROCESS TO RECEIVE RE-ATTACH REQUESTS.
; IT IS DONE NOW, SO THAT ANY ERRORS DETECTED WILL CAUSE THE ENTIRE
; OPERATION TO FAIL, RATHER THAN SENDING THE ATTACH REQUEST TO THE
; OTHER PROCESS, AND THEN FINDING OUT WE CAN'T CREATE THE RE-ATTACH
; MAILBOX.
;
66$:	BSBW	CREATE_ATTMBX		; CREATE ATTACH MAILBOX
	BLBC	R0,65$			; BRANCH IF ERROR DETECTED

;
; ASSIGN CHANNEL TO ATTACH MAILBOX
;
67$:	MOVAL	-(SP),R0			; ADDRESS OF LOGICAL NAME DESCRIPTOR
	$ASSIGN_S DEVNAM=4+8+ATTMBX_MAXMSG(R0),-; ASSIGN CHANNEL TO MAILBOX
		CHAN=(R0)			;
	POPL	R2				; GET CHANNEL OF MAILBOX
	BLBC	R0,691$				; BRANCH IF ERROR

;
; SEND REQUEST TO DESTINATION ATTACH REQUEST MAILBOX AND GET REPLY
;
68$:	BSBW	CHECK_FOR_HANGUP	; CHECK FOR HANGUP AST
	MOVAQ	-(SP),R4		; ALLOCATE IOSB FOR I/O REQUESTS
	$QIOW_S FUNC=#IO$_WRITEVBLK,-	; WRITE TO MAILBOX
		CHAN=R2,-		;
		EFN=#EXE$C_SYSEFN,-	;
		IOSB=(R4),-		;
		P1=@12(R4),P2=8(R4)	; RECORD = SYS$INPUT TRANSLATION
	BLBC	R0,69$			; BRANCH IF ERROR
	MOVZWL	(R4),R0			; GET FINAL STATUS FROM IOSB
	BLBC	R0,69$			; BRANCH IF ERROR
	MOVAQ	-(SP),R3		; ALLOCATE RECORD BUFFER
	MOVL	R11,4(R3)		; GET PRC AREA ADDRS.
	$QIOW_S	FUNC=#IO$_READVBLK,-	; READ RESPONSE FROM MAILBOX
		CHAN=R2,-		;
		EFN=#EXE$C_SYSEFN,-	;
		IOSB=(R4),-		;
		ASTADR=READ_AST,-
		ASTPRM=R3,-
		P1=(R3),P2=#4		; TO LONGWORD BUFFER
	POPL	R3			; POP RECORD BUFFER
	BLBC	R0,69$			; BRANCH IF ERROR
	MOVZWL	(R4),R0			; GET FINAL STATUS FROM IOSB
69$:	ADDL	#12,SP			; POP THE IOSB
691$:	BLBC	R0,80$			; BRANCH IF ERROR
	$DASSGN_S CHAN=R2		; DEASSIGN CHANNEL TO ATTACH MAILBOX

;
; IF DESTINATION PROCESS SAYS NO TO ATTACH REQUEST, REPORT IT TO THE USER
;
	BLBC	R3,85$			; BRANCH IF DESTINATION PROCESS SAYS NO


;
; WAIT FOR PROCESS TO RETURN CONTROL HERE (FROM ATTACH OR TERMINATION).
; IF WE ARE IN AN INTERACTIVE PROCESS, THEN TELL THE TERMINAL DRIVER THAT
; WE NOW OWN THE TERMINAL.
;
;
70$:	BSBW	CHECK_FOR_HANGUP	; CHECK FOR HANGUP AST
	MOVAQ	-(SP),R0		; CREATE A TEMP. IOSB
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,-  ; SET ATTN. AST ON MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-;
		EFN=#EXE$C_SYSEFN,-	;
		IOSB=(R0),-		;
		P1=ATTACH_AST,-		; ADDRESS OF AST ROUTINE
		P2=R11			; PASS ADDRESS OF CLI STORAGE
	ADDL	#8,SP			; CLEAN UP STACK
	$HIBER_S			; HIBERNATE WAITING FOR WAKEUP
	BBS	#PRC_V_DETACHED,-	; BRANCH IF STILL DETACHED
		PRC_W_FLAGS(R11),70$ 	;
	BBS	#PRC_V_MODE,-		; SKIP IF NOT INTERACTIVE
		PRC_W_FLAGS(R11),90$	;
	CLRQ	-(SP)			; ALLOCATE AN IOSB
	MOVL	SP,R0			; GET ADDRESS OF IOSB
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_TT_PROCESS,- ; ASSUME TERMINAL OWNERSHIP
		CHAN=PRC_W_INPCHAN(R11),-
		IOSB=(R0),-
		EFN=#EXE$C_SYSEFN
	ADDL	#8,SP			; RESTORE THE STACK
	MOVL	#1,R0			; SET SUCCESSFUL
	BRB	90$			; AND EXIT

;
; CLEANUP FROM ERROR DETECTED WHILE HAVING CHANNEL OPEN TO ATTACH MAILBOX
;
80$:	$DASSGN_S CHAN=R2		; DEASSIGN CHANNEL TO ATTACH MAILBOX
85$:	MOVL	#CLI$_REFUSED,R0	; ATTACH REQUEST REFUSED

;
; RESTORE PROCESS CONTEXT
;
90$:	ADDL	#8+ATTMBX_MAXMSG+8+30,SP; CLEAN STACK
95$:	MOVL	R0,R6				; SAVE FINAL STATUS CODE
	BSBW	DEALLOC_SPWN			; REMOVE INACTIVE SPWN BLOCKS
	BSBW	DELETE_ATTMBX			; DELETE OUR ATTACH MAILBOX
	POPL	R1				; RESTORE OUT-OF-BAND ENABLE MASK
	BSBW	DCL$RESETOOB			; RESTORE AST'S
	MOVL	R6,R0				; RESTORE EXIT STATUS
	RSB					; EXIT

	.SBTTL	CREATE ATTACH REQUEST MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO CREATE AN ATTACH REQUEST MAILBOX FOR
; THIS PROCESS TO RECEIVE ATTACH REQUESTS FROM OTHER PROCESSES.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

CREATE_ATTMBX:
	PUSHL	R2			; SAVE REGISTERS
	CLRQ	-(SP)			; ALLOCATE AN IOSB
;
; CREATE ATTACH MAILBOX AND LOGICAL NAME, SHOULD ANY OTHER PROCESS DESIRE
; TO RE-ATTACH TO THIS PROCESS LATER ON.
;
	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4		; REQUEST OUR PID, SET BUFFER LENGTH
	MOVL	SP,R0			;
	$GETJPIW_S  ITMLST=(R0),-	; GET PID OF THIS PROCESS
		IOSB=16(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	POPL	R2			; GET OUR PID
	ADDL	#3*4,SP			; CLEANUP STACK
	SUBL	#30,SP			; ALLOCATE ROOM FOR NAME
	PUSHL	SP			; CREATE DESCRIPTOR FOR NAME
	PUSHL	#30
	MOVAB	ATTACH_NAME,R1		; GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R0,-(SP)		; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0
	$FAO_S	CTRSTR=(R0),-		; CONSTRUCT LOGICAL NAME
		OUTBUF=8(R0),-
		OUTLEN=8(R0),-
		P1=R2			; FROM PID FOR THIS PROCESS
	ADDL	#8,SP			; POP FAO STRING DESCRIPTOR
	MOVL	SP,R0			; ADDRESS OF LOGICAL NAME DESCRIPTOR
	$CREMBX_S CHAN=PRC_W_ATTMBX(R11),-	; CREATE ATTACH MAILBOX
		BUFQUO=#ATTMBX_MAXMSG,-		; ONLY NEEDS TO HOLD 1 MESSAGE
		PROMSK=#^B1111111100001111,-	; ONLY GIVE OWNER R/W ACCESS
		LOGNAM=(R0)			;
	ADDL	#30+8,SP			; CLEANUP STACK
90$:	ADDL	#8,SP				; POP THE IOSB
	POPL	R2				; RESTORE REGISTERS
	RSB

	.SBTTL	DELETE ATTACH REQUEST MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO DELETE THE ATTACH REQUEST MAILBOX
; FOR THIS PROCESS.  THIS IS DONE AFTER WE COME BACK FROM DETACHED
; STATE, SINCE AFTER THAT POINT, WE CAN NO LONGER ACCEPT ATTACH REQUESTS.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

DELETE_ATTMBX:
	$DASSGN_S CHAN=PRC_W_ATTMBX(R11) ;DELETE ATTACH MAILBOX
	CLRW	PRC_W_ATTMBX(R11)	;MARK CHANNEL NO LONGER VALID
	RSB

	.SBTTL	CREATE TERMINATION MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO CREATE A TERMINATION MAILBOX FOR
; THIS PROCESS TO RECEIVE TERMINATION MESSAGE FROM UP TO FOUR OF ITS
; SPAWNED SUBPROCESSES.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN DATA STRUCTURE
;	R8 = ADDRESS OF SCRATCH STORAGE
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R7 = ADDRESS OF TMBX BLOCK
;---

CREATE_TMBX:

;
; ALLOCATE A NEW TMBX BLOCK AND LINK IT INTO THE LIST.
;
	MOVZWL	#TMBX_C_LENGTH,R1		; LENGTH OF STORAGE TO ALLOCATE
	BSBW	DCL$ALLDYNMEM			; ALLOCATE STORAGE
	BLBC	R0,90$				; BRANCH ON ERROR
	MOVL	R2,R7				; SET ADDRESS OF TMBX BLOCK
	MOVW	R1,TMBX_W_SIZE(R7)		; STORE SIZE OF BLOCK
	CLRB	TMBX_B_REFS(R7)			; SET REFERENCE COUNT TO ZERO
	MOVL	R11,TMBX_L_PRC(R7)		; STORE BASE OF PROCESS WORK AREA
	MOVL	PRC_L_TMBX(R11),-		; INSERT BLOCK INTO LINKED LIST
		TMBX_L_LINK(R7)			;
	MOVL	R7,PRC_L_TMBX(R11)		;

;
; CREATE A TRMINATION MAILBOX THAT CAN HOLD AS MANY MESSAGES AS ALLOWED 
; BROTHERS AND ENABLE THE TERMINATION AST.
;
	$CREMBX_S CHAN=TMBX_W_CHANNEL(R7),-	; CREATE A TERMINATION MAILBOX
		BUFQUO=#TMBX_C_MAXREFS*ACC$C_TERMLEN
	BLBC	R0,95$				; BRANCH ON ERROR
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,- ; SET ATTENTION AST ON MAILBOX
		CHAN=TMBX_W_CHANNEL(R7),-	;
		IOSB=SPWN_Q_IOSB(R6),-		;
		EFN=#EXE$C_SYSEFN,-		;
		P1=W^TERMINATION_AST,-		; ADDRESS OF AST ROUTINE
		P2=R7				; PASS TMBX BLOCK ADDRESS
	BLBC	R0,95$				; BRANCH IF ERROR
	MOVZWL	SPWN_Q_IOSB(R6),R0		; GET IOSB STATUS
	BLBC	R0,95$				; BRANCH IF ERROR

;
; GET UNIT NUMBER OF TERMINATION MAILBOX
;
	$GETCHN_S CHAN=TMBX_W_CHANNEL(R7),-	 ; GET MAILBOX INFORMATION
		PRIBUF=(R8)
	BLBC	R0,95$				 ; BRANCH ON ERROR
	MOVW	DIB$W_UNIT+8(R8),TMBX_W_UNIT(R7) ; SAVE MAILBOX UNIT NUMBER
90$:	RSB					 ; RETURN WITH STATUS

;
; DELETE TERMINATION MAILBOX AND TMBX DATA STRUCTURE AND THEN 
; RETURN WITH STATUS
;
95$:	PUSHL	R0				; SAVE STATUS
	BSBW	DELETE_TMBX			; DELETE ALLOCATED TMBX
	POPL	R0				; RESTORE STATUS
	RSB					; RETURN WITH STATUS

	.SBTTL	DELETE TERMINATION MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO DELETE A TERMINATION MAILBOX AND ITS ASSOCIATED
; TMBX DATA STRUCTURE.
;
; INPUTS:
;
;	R7 = ADDRESS OF TMBX DATA STRUCTURE
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

DELETE_TMBX:
	$DASSGN_S CHAN=TMBX_W_CHANNEL(R7)	; DELETE TERMINATION MAILBOX
	MOVL	TMBX_L_LINK(R7),PRC_L_TMBX(R11) ; REMOVE BLOCK FROM LIST
	MOVL	R7,R0				; SET ADDRESS OF BLOCK
	MOVZWL	TMBX_W_SIZE(R7),R1		; GET SIZE OF BLOCK
	BSBW	DCL$DEADYNMEM			; DEALLOCATE BLOCK
	RSB					;


	.SBTTL	DEALLOCATE SPWN BLOCKS
;---
;
; THIS ROUTINE IS CALLED TO DEALLOCATE THE SPWN BLOCKS OF TERMINATED 
; SUBPROCESSES.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

DEALLOC_SPWN:
	MOVAL	PRC_L_SPWN(R11),R0		; GET ADDR OF FIRST SPWN BLOCK
	ASSUME	SPWN_L_LINK EQ 0		;
10$:	MOVL	R0,R1				; SAVE ADDR OF PREVIOUS SPWN BLOCK
	MOVL	SPWN_L_LINK(R0),R0		; GET NEXT SPWN BLOCK
	BEQL	90$				; BRANCH IF DONE
	BBS	#SPWN_V_ACTIVE,-		; BRANCH IF STILL IN USE
		SPWN_W_FLAGS(R0),10$		;
	MOVL	SPWN_L_LINK(R0),-		; REMOVE BLOCK FROM LIST
		SPWN_L_LINK(R1) 		;
	MOVZWL	SPWN_W_SIZE(R0),R1		; SET LENGTH OF BLOCK
	BSBW	DCL$DEADYNMEM			; DEALLOCATE BLOCK
90$:	RSB

	.SBTTL	WRITE RETURNED MESSAGE
;---
;
; THIS ROUTINE WRITES A MESSAGE INDICATING THAT TERMINAL CONTROL
; HAS RETURNED TO THIS PROCESS.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;---

RETURNED_MESSAGE:
;
; OUTPUT MESSAGE SAYING THAT CONTROL OF THE TERMINAL HAS RETURNED
; TO THIS PROCESS
;
	SUBL	#16,SP			;ALLOCATE SCRATCH BUFFER FOR PRCNAM
	PUSHL	SP			;CREATE DESCRIPTOR OF BUFFER
	PUSHL	#16
	MOVL	SP,R0
	CLRL	-(SP)			;MARK END OF JPI LIST
	PUSHL	R0			;ADDRESS TO STORE RETURN LENGTH
	MOVQ	(R0),-(SP)		;DESCRIPTOR OF STRING BUFFER
	MOVW	#JPI$_PRCNAM,2(SP)	;SET PARAMETER ID TO RETRIEVE
	CLRQ	-(SP)			;ALLOCATE AN IOSB
	MOVL	SP,R0			;
	$GETJPIW_S  ITMLST=8(R0),-	;GET CURRENT PROCESS NAME
		IOSB=(R0),-		;
		EFN=#EXE$C_SYSEFN	;
	ADDL	#6*4,SP			;POP ITEM LIST AND IOSB
	PUSHL	SP			;ADDRESS OF PROCESS NAME
	MOVL	#1,R1			;SET NUMBER OF ARGS
	MOVL	#CLI$_RETURNED,R0	;MESSAGE CODE
	BSBW	DCL$FORMMSG		;OUTPUT MESSAGE
	ADDL	#8+16,SP		;CLEAN STACK
	RSB


	.SBTTL	WRITE CONTEXT TO SUBPROCESS
;---
;
; THIS ROUTINE WRITES THE PROCESS CONTEXT RECORDS TO THE SUBPROCESS
; INITIALIZATION ROUTINE VIA THE CONTEXT MAILBOX.  EACH RECORD HAS
; A TYPE FIELD WHICH DISTINGUISHES THE DIFFERENT TYPES OF INFORMATION
; WHICH CAN BE PASSED FROM PARENT TO SUBPROCESS.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN STORAGE
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

WRITE_CONTEXT:
	PUSHR	#^M<R2,R3,R4,R5,R7>	; SAVE REGISTERS

;
; CONSTRUCT THE HEADER CONTEXT RECORD, WHICH CONTAINS SUCH THINGS AS PROCESS
; PRIVILEGES, ETC.
;
	MOVAB	-CTX_C_MAXLEN(SP),SP		; ALLOCATE BUFFER FOR CONTEXT RECORDS
	MOVL	SP,R7				; SAVE ADDRESS OF BUFFER
	MOVZWL	#CTX_C_HEADER,CTX_W_TYPE(R7)	; SET TYPE OF RECORD
	CLRQ	-(SP)				; SET END OF ITEM LIST, RETLEN ADDRESS
	PUSHAQ	CTX_Q_PROCPRIV(R7)		; SET ADDRESS OF BUFFER
	PUSHL	#JPI$_PROCPRIV@16!8		; SET GETJPI ITEM CODE AND LENGTH
	MOVL	SP,R0				; ADDRESS OF ITEM LIST
	$GETJPIW_S  ITMLST=(R0),-		; GET INFORMATION
		IOSB=SPWN_Q_IOSB(R6),-		;
		EFN=#EXE$C_SYSEFN		;
	ADDL	#4*4,SP				; POP GETJPI ITEM LIST
	CLRB	CTX_B_FLAGS(R7)			; CLEAR THE FLAGS BYTE

	BBC	#SPWN_V_WAIT,SPWN_W_FLAGS(R6),5$ 	; BRANCH IF NOT SET
	SETBIT	CTX_V_WAIT,CTX_B_FLAGS(R7)		;

5$:	BBC	#SPWN_V_AUTOLOGO,SPWN_W_FLAGS(R6),15$ 	; BRANCH IF NOT SET
	SETBIT	CTX_V_AUTOLOGO,CTX_B_FLAGS(R7)		;

15$:	BBC	#SPWN_V_MODE,SPWN_W_FLAGS(R6),16$ 	; BRANCH IF NOT SET
	SETBIT	CTX_V_MODE,CTX_B_FLAGS(R7)		;

16$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),161$ 	; COPY VERIFICATION FLAG
	SETBIT	CTX_V_VERIFY,CTX_B_FLAGS(R7)		;

161$:	BBC	#PRC_V_VERIMAGE,PRC_B_FLAGS2(R11),162$ 	; COPY IMAGE VERIFICATION FLAG
	SETBIT	CTX_V_VERIMAGE,CTX_B_FLAGS(R7)		;

162$:	BBS	#SPWN_V_PROMPT,SPWN_W_FLAGS(R6),17$	; BRANCH IF EXPLICIT PROMTP
	MOVZBL	PRC_B_PROMPTLEN(R11),R0		; GET PROMPT LENGTH
	MOVB	R0,CTX_B_PROMPTLEN(R7)		;
	MOVC3	R0,PRC_W_PMPTCTRL(R11),-	; GET PROMPT STRING
		CTX_W_PMPTCTRL(R7)		;
	BRB	18$				;
17$:	MOVZBL	SPWN_B_PROMPTLEN(R6),R0		; GET PROMPT LENGTH
	MOVB	R0,CTX_B_PROMPTLEN(R7)		;
	MOVC3	R0,SPWN_W_PMPTCTRL(R6),-	; GET PROMPT STRING
		CTX_W_PMPTCTRL(R7)		;

18$:	MOVL	SPWN_L_OUTOFBAND(R6),-		; GET OUT-OF-BAND AST MASK
		CTX_L_OUTOFBAND(R7)		;

	MOVL	#CTX_C_HDRLEN,R3		; COMPUTE SIZE OF RECORD
	BSBW	WRITE_MAILBOX			; WRITE THE RECORD TO THE MAILBOX
	BLBC	R0,19$				; BRANCH IF ERROR DETECTED

;
; WRITE THE COMMAND STRING RECORD TO THE MAILBOX
;
	TSTW	SPWN_Q_CMDSTR(R6)		; ANY COMMAND STRING?
	BEQL	20$				; BRANCH IF NOT
	CMPW	SPWN_Q_CMDSTR(R6),-		; CHECK IF BIGGER THAN OUR BUFFER
		#CTX_C_MAXLEN-CTX_T_CMDSTR 	;
	BLEQU	10$				; BRANCH IF OK
	MOVZWL	#CTX_C_MAXLEN-CTX_T_CMDSTR,-	; ELSE, TRUNCATE STRING
		SPWN_Q_CMDSTR(R6) 		;
10$:	MOVW	#CTX_C_CMDSTR,CTX_W_TYPE(R7) 	; SET TYPE OF RECORD
	MOVC	SPWN_Q_CMDSTR(R6),-		;
		@SPWN_Q_CMDSTR+4(R6),-		;
		CTX_T_CMDSTR(R7)		;
	SUBL	R7,R3				; COMPUTE LENGTH OF RECORD
	BSBW	WRITE_MAILBOX			; WRITE THE RECORD TO THE MAILBOX
19$:	BLBS	R0,20$				; BRANCH IF SUCCESS
	BRW	90$

;
; WRITE THE PROCESS LOGICAL NAMES TO THE MAILBOX
;
20$:	BBS	#SPWN_V_LOGNAM,SPWN_W_FLAGS(R6),30$ ; BRANCH IF REQUESTED
	BRW	40$

;
; FIRST WRITE ALL OF THE TABLE NAMES
;
30$:	MOVW	#CTX_C_LNMTABLE,CTX_W_TYPE(R7)	; SET LOGICAL NAME TABLE
	MOVL	G^CTL$GL_LNMDIRECT,R5		; GET PROCESS DIRECTORY
	MOVL	LNMB$L_TABLE(R5),R5		; GET IT'S TABLE
	MOVL	LNMTH$L_CHILD(R5),R0		; GET FIRST TABLE
31$:	MOVL	R0,R5				; GET NEXT TABLE
	MOVL	LNMTH$L_NAME(R5),R4		; GET POINTER TO LNMB
	BBS	#LNMB$V_CONFINE,LNMB$B_FLAGS(R4),33$ ; SKIP SUBTREE IF CONFINED
	CMPB	LNMB$B_ACMODE(R4),#PSL$C_EXEC	; PRIV MODE TABLE?
	BLEQU	32$				; DON'T COPY IF SO.
	MOVB	LNMB$B_ACMODE(R4),CTX_B_ACMODE(R7)	; COPY ACMODE
	BICB3	#LNMB$M_TABLE,-
		LNMB$B_FLAGS(R4),CTX_B_TFLAGS(R7)	; COPY NAME FLAGS
	MOVL	LNMTH$L_BYTESLM(R5),CTX_L_QUOTA(R7)	; COPY QUOTA
	MOVAL	CTX_T_LNMTABLE(R7),R3		; PTR TO BUFFER
	MOVAL	LNMB$T_NAME(R4),R1		; PTR TO NAME
	MOVZBL	(R1),R0				; LENGTH OF NAME
	INCL	R0				; INCLUDE THE COUNT
	PUSHR	#^M<R4,R5>			; SAVE REGS
	MOVC3	R0,(R1),(R3)			; COPY NAME
	POPR	#^M<R4,R5>			; RESTORE REGS
	MOVL	LNMTH$L_PARENT(R5),R1		; PTR TO PARENT
	MOVL	LNMTH$L_NAME(R1),R1		; PTR TO PARENT'S LNMB
	MOVAL	LNMB$T_NAME(R1),R1		; PTR TO NAME
	MOVZBL	(R1),R0				; LENGTH OF TABLE NAME
	INCL	R0				; INCLUDE THE COUNT
	PUSHR	#^M<R4,R5>			; SAVE REGS
	MOVC3	R0,(R1),(R3)			; COPY TABLE NAME
	POPR	#^M<R4,R5>			; RESTORE REGS
	SUBL2	R7,R3				; COMPUTE SIZE OF CONTEXT RECORD
	SUBW3	#CTX_W_ENTSIZE,R3,CTX_W_ENTSIZE(R7) ; SET SIZE OF ENTRY
	BSBW	WRITE_MAILBOX			; WRITE THE RECORD TO THE MAILBOX
	BLBC	R0,92$				; QUIT ON ERROR
32$:	MOVL	LNMTH$L_CHILD(R5),R0		; GET CHILD TABLE PTR
	BNEQ	310$				; AND PASS IT.
33$:	MOVL	LNMTH$L_SIBLING(R5),R0		; SIBLING TABLE?
	BNEQ	310$				; AND PASS IT.	
	MOVL	LNMTH$L_PARENT(R5),R5		; GET SIBLING OF PARENT TABLE
	MOVL	LNMTH$L_SIBLING(R5),R0		; AND PASS IT
	BNEQ	310$

;
; NOW THAT THE TABLES EXIST, WRITE ALL OF THE LOGICAL NAMES
;
	MOVL	#CTX_C_LNMNAME,CTX_W_TYPE(R7)	; SET LOGICAL NAME TYPE
	MOVL	G^CTL$GL_LNMHASH,R4		; GET POINTER TO HASH TABLE
	MCOML	LNMHSH$L_MASK(R4),R4		; GET SIZE MASK
	INCL	R4				; CONVERT TO SIZE
34$:	BRW	38$				; LOOP

92$:	BRW	90$				;HELPER BRANCH
310$:	BRW	31$				;HELPER BRANCH	

35$:	MOVL	(R5),R5				; GET NEXT LINK IN CHAIN
	BEQL	34$				; GO TO NEXT CHAIN IF NONE
	BBS	#LNMB$V_CONFINE,LNMB$B_FLAGS(R5),35$ ; SKIP NAME IF CONFINED
	BBS	#LNMB$V_TABLE,LNMB$B_FLAGS(R5),35$ ; SKIP NAME IF TABLE
	CMPB	LNMB$B_ACMODE(R5),#PSL$C_EXEC	; PRIV MODE TABLE?
	BLEQU	35$				; DON'T COPY IF SO.
	MOVB	LNMB$B_ACMODE(R5),CTX_B_ACMODE(R7)	; COPY ACMODE
	MOVB	LNMB$B_FLAGS(R5),CTX_B_NFLAGS(R7)	; COPY NAME FLAGS
	MOVAL	CTX_T_LNMNAME(R7),R3		; PTR TO BUFFER
	MOVL	LNMB$L_TABLE(R5),R1		; PTR TO TABLE
	MOVL	LNMTH$L_NAME(R1),R1		; PTR TO TABLE'S LNMB
	MOVZBL	LNMB$T_NAME(R1),R0		; LENGTH OF TABLE NAME
	INCL	R0				; INCLUDE THE COUNT
	PUSHR	#^M<R4,R5>			; SAVE REGS
	MOVC3	R0,LNMB$T_NAME(R1),(R3)		; COPY NAME
	POPR	#^M<R4,R5>			; RESTORE REGS
	MOVAB	LNMB$T_NAME(R5),R0		; PTR TO NAME
	CLRL	R2				; COUNT # OF XLATIONS
	BRB	351$				; TRY NEXT ENTRY
350$:	BBS	#LNMX$V_XEND,LNMX$B_FLAGS(R0),352$ ; BR IF END OF LIST
	INCL	R2				; COUNT THIS XLATION
	MOVAB	LNMX$T_XLATION(R0),R0		; POINT TO STRING
351$:	MOVZBL	(R0)+,R1			; GET LENGTH OF THIS STRING
	ADDL2	R1,R0				; SKIP OVER IT
	BRB	350$				; TRY NEXT ENTRY
352$:	MOVB	R2,CTX_B_TRANCNT(R7)		; SAVE COUNT
	MOVAB	LNMB$T_NAME(R5),R1		; ADDR OF NAME AGAIN
	INCL	R0				; COUNT TERMINATION BYTE
	SUBL2	R1,R0				; COMPUTE SIZE NEEDED
	MOVAB	CTX_C_MAXLEN(R7),R2		; GET END ADDR OF CTX
	SUBL2	R3,R2				; BUFFER SPACE REMAINING
	CMPL	R0,R2				; NAME ALL FIT?
	BGTRU	36$				; NOPE
	PUSHR	#^M<R4,R5>			; SAVE REGS
	MOVC3	R0,(R1),(R3)			; COPY NAME AND XLATIONS
	POPR	#^M<R4,R5>			; RESTORE REGS
	SUBL2	R7,R3				; COMPUTE SIZE OF CONTEXT RECORD
	SUBW3	#CTX_W_ENTSIZE,R3,CTX_W_ENTSIZE(R7) ; SET SIZE OF ENTRY
	BSBW	WRITE_MAILBOX			; WRITE THE RECORD TO THE MAILBOX
	BLBC	R0,49$				; QUIT ON ERROR
	BRB	37$				; ONTO THE NEXT NAME
;
; DEAL WITH RECORDS TOO LONG FOR ONE MAILBOX MESSAGE
; (FOR NOW, ISSUE THE "SYMBOL TOO LONG" ERROR.
;

36$:	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),37$ ;BRANCH IF /NOLOG SPECIFIED
	PUSHAB	1(R1)				; PUSH DESCRIPTOR OF THE
	MOVZBL	(R1),-(SP)			;  LOGICAL NAME
	PUSHL	SP				; ADDRESS OF THE DESCRIPTOR
	MOVL	#1,R1				; SET NUMBER OF ARGS
	MOVL	#CLI$_SYMTOOLNG,R0		; MESSAGE CODE
	BSBW	DCL$FORMMSG			; OUTPUT MESSAGE
	ADDL	#4*2,SP				; CLEAN STACK
37$:	BRW	35$				; PROCESS NEXT SYMBOL

38$:	MOVL	G^CTL$GL_LNMHASH,R5		; GET ADDR OF HASHTABLE
	MOVAL	LNMHSH$C_BUCKET-4(R5)[R4],R5	; GET ADDR OF BUCKET
	SOBGEQ	R4,37$				; LOOP OVER ALL CHAINS

;
; WRITE THE DCL GLOBAL SYMBOLS TO THE MAILBOX
;
40$:	BBC	#SPWN_V_CLISYM,SPWN_W_FLAGS(R6),45$ ; BRANCH IF NOT REQUESTED
	MOVAB	PRC_Q_GLOBAL(R11),R4		; GET ADDRESS OF GLOBAL LISTHEAD
	MOVB	#CTX_C_GLOBAL,CTX_B_SYMTAB(R7) 	; SET WHICH SYMBOL TABLE
	BSBW	WRITE_SYMBOLS			; WRITE ALL GLOBAL SYMBOLS
	MOVAB	PRC_Q_LOCAL(R11),R4		; GET ADDRESS OF LOCAL LISTHEAD
	MOVB	#CTX_C_LOCAL,CTX_B_SYMTAB(R7) 	; SET WHICH SYMBOL TABLE
	BSBW	WRITE_SYMBOLS			; WRITE ALL LOCAL SYMBOLS

;
; WRITE THE KEYPAD STATE TO THE MAILBOX
;
45$:	BBC	#SPWN_V_KEYPAD,SPWN_W_FLAGS(R6),50$ ; BRANCH IF NOT REQUESTED
	MOVAB	PRC_Q_KEYPAD(R11),R4		; GET ADDRESS OF KEYPAD LISTHEAD
	MOVB	#CTX_C_KEYTABL,CTX_B_SYMTAB(R7) ; SET WHICH SYMBOL TABLE
	BSBW	WRITE_SYMBOLS			; WRITE ALL KEYPAD SYMBOLS
	MOVW	#CTX_C_KEYSTATE,CTX_W_TYPE(R7) 	; SET TYPE OF RECORD
	MOVL	PRC_L_LASTKEY(R11),R2		; GET ADDR OF ASCIC KEY STATE
	MOVZBL	(R2)+,R1			; GET DESCRIPTOR
	MOVB	R1,CTX_B_KEYLENGTH(R7)		; COPY THE LENGTH
	MOVC	R1,(R2),CTX_T_KEYSTATE(R7)	; COPY THE STRING
	SUBL	R7,R3				; COMPUTE LENGTH OF RECORD
	BSBW	WRITE_MAILBOX			; WRITE THE RECORD TO THE MAILBOX
49$:	BLBC	R0,90$				; BRANCH IF ERROR DETECTED

;
; WRITE AN END-OF-FILE TO THE MAILBOX AND WAIT FOR COMPLETION, SO THAT
; WE DON'T DELETE THE MAILBOX BEFORE THE SUBPROCESS EVEN GETS A CHANCE
; TO ASSIGN A CHANNEL TO IT.
;
50$:	$QIOW_S FUNC=#IO$_WRITEOF,-	; WRITE AN EOF TO MAILBOX
		CHAN=SPWN_W_CHAN(R6),-	;
		IOSB=SPWN_Q_IOSB(R6),-	;
		EFN=#EXE$C_SYSEFN	;
	BLBC	R0,90$			; BRANCH IF ERROR
	MOVZWL	SPWN_Q_IOSB(R6),R0	; GET IOSB STATUS
90$:	MOVAB	CTX_C_MAXLEN(SP),SP	; DEALLOCATE RECORD BUFFER
	POPR	#^M<R2,R3,R4,R5,R7>	; RESTORE REGISTERS
	RSB

	.SBTTL	WRITE RECORD TO CONTEXT MAILBOX
;---
;
; WRITE A RECORD TO THE MAILBOX WITHOUT WAITING FOR A READER
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN STORAGE
;	R7 = ADDRESS OF RECORD TO BE OUTPUT
;	R3 = LENGTH OF RECORD TO BE OUTPUT
;
; OUTPUTS:
;
;	R0 = FINAL STATUS
;---

WRITE_MAILBOX:
	BSBW	CHECK_FOR_HANGUP		; CHECK FOR HANGUP AST
	$QIOW_S	FUNC=#IO$_WRITEVBLK!IO$M_NOW,-	; WRITE TO MAILBOX WITHOUT WAITING
		CHAN=SPWN_W_CHAN(R6),-		;
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=SPWN_Q_IOSB(R6),-		;
		P1=(R7),P2=R3			; ADDRESS/LENGTH OF BUFFER
	BLBC	R0,90$				; BRANCH IF ERROR DETECTED
	MOVZWL	SPWN_Q_IOSB(R6),R0		; GET FINAL STATUS
90$:	RSB

	.SBTTL	WRITE ALL SYMBOLS IN A SYMBOL TABLE
;---
;
;	WRITE ALL THE SYMBOL RECORDS TO THE MAILBOX FROM A
;	SPECIFIED SYMBOL TABLE.
;
; INPUTS:
;
;	CTX_B_SYMTAB(R7) = TYPE OF SYMBOL TABLE
;	R4 = ADDRESS OF SYMBOL TABLE LISTHEAD
;	R6 = ADDRESS OF SPWN STORAGE
;	R7 = ADDRESS OF CONTEXT RECORD BUFFER
;
; OUTPUTS:
;
;	R0-R5 DESTROYED.
;---

WRITE_SYMBOLS:
	MOVW	#CTX_C_CLISYM,CTX_W_TYPE(R7) ; SET TYPE OF RECORD
	MOVL	R4,R5			; SAVE FOR END-OF-LIST CHECK
45$:	MOVL	(R4),R4			; GET NEXT SYMBOL ENTRY IN LIST
	CMPL	R4,R5			; END OF LIST?
	BEQL	50$			; BRANCH IF SO
	ASSUME	SYM_K_STRING EQ CTX_C_STRING
	ASSUME	SYM_K_PERM EQ CTX_C_PERM
	ASSUME	SYM_K_BINARY EQ CTX_C_BINARY
	ASSUME 	SYM_K_KEYPAD EQ CTX_C_KEYPAD
	MOVB	SYM_B_TYPE(R4),CTX_B_SYMTYPE(R7) ; COPY SYMBOL TYPE CODE
	MOVB	SYM_B_NONUNIQUE(R4),CTX_B_NONUNIQUE(R7) ; COPY UNIQUENESS POINT
	MOVZBL	SYM_T_SYMBOL(R4),R0	; GET LENGTH OF SYMBOL NAME
	CMPB	SYM_B_TYPE(R4),#SYM_K_BINARY ; BINARY VALUE?
	BNEQ	47$			; BRANCH IF NOT
	ADDL	#4+1,R0			; COMPUTE LENGTH OF ASCIC NAME + VALUE
	BRB	48$
47$:	MOVAB	SYM_T_SYMBOL+1(R4)[R0],R1 ; ADDRESS OF WORD-COUNTED VALUE STRING
	MOVZWL	(R1),R1			; GET LENGTH OF VALUE STRING
	MOVAB	3(R1)[R0],R0		; COMPUTE LENGTH OF ASCIC NAME + VALUE
48$:	CMPW	R0,#<CTX_C_MAXLEN-CTX_T_SYMBOL>	; WILL SYMBOL VALUE FIT?
	BGTRU	60$			; IF LARGER, THEN NO
	PUSHR	#^M<R4,R5>		; SAVE REGISTERS
	MOVC	R0,SYM_T_SYMBOL(R4),CTX_T_SYMBOL(R7) ; MOVE NAME + VALUE
	POPR	#^M<R4,R5>		; RESTORE REGISTERS
	SUBL	R7,R3			; COMPUTE SIZE OF RECORD
	SUBW3	#CTX_W_ENTSIZE,R3,CTX_W_ENTSIZE(R7) ; SET SIZE OF ENTRY
	BSBB	WRITE_MAILBOX		; WRITE RECORD TO MAILBOX
	BRB	45$			; LOOP UNTIL TABLE EXHAUSTED
50$:	RSB

;
; WE HAVE ENCOUNTERED AN OVERSIZED SYMBOL.  ISSUE A WARNING MESSAGE SAYING
; THAT WE ARE IGNORING IT AND THEN PROCEED.
;
60$:	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),45$ ;BRANCH IF /NOLOG SPECIFIED
	MOVAB	SYM_T_SYMBOL+1(R4),-(SP); PUSH DESCRIPTOR OF THE
	MOVZBL	SYM_T_SYMBOL(R4),-(SP)	;  SYMBOL NAME
	PUSHL	SP			; ADDRESS OF THE DESCRIPTOR
	MOVL	#1,R1			; SET NUMBER OF ARGS
	MOVL	#CLI$_SYMTOOLNG,R0	; MESSAGE CODE
	BSBW	DCL$FORMMSG		; OUTPUT MESSAGE
	ADDL	#4*2,SP			; CLEAN STACK
	BRW	45$			; PROCESS NEXT SYMBOL


	.SBTTL	CHECK FOR PENDING HANGUP AST
;---
;
; THIS ROUTINE IS CALLED TO CHECK IF A HANGUP AST HAS COME IN SINCE
; WE STARTED THE COMMAND EXECUTION.  IF SO, THE PROCESS IS TERMINATED.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

CHECK_FOR_HANGUP:
	BBC	#PRC_V_HANGUP,PRC_W_FLAGS(R11),90$ ; BRANCH IF NO HANGUP PENDING
	BRW	DCL$RESTART		; ABORT PROCESS
90$:	RSB

	.SBTTL	GET DEVICE NAME
;---
;
; THIS ROUTINE CALLS THE $GETDVI SYSTEM SERVICE TO GET THE CANNONICAL NAME OF 
; A SPECIFIED DEVICE.  IT PLACES THE DEVICE NAME IN THE SPECIFIED BUFFER AND 
; PROPAGATES THE STATUS RETURNED BY $GETDVI TO THE CALLER.
;
; INPUTS:
;
;	R2/R3 = DESCRIPTOR OF DEVICE NAME
;	R4/R5 = DESCRIPTOR OF RETURN BUFFER
;
; OUTPUTS:
;
;	R0 = STATUS RETURNED BY $GETDVI
;
;---

GET_DEVICE:
	CLRQ	-(SP)			; ALLOCATE AN IOSB
	MOVQ	R2,-(SP)		; PUSH DEVICE DESCRIPTOR ON STACK
	MOVL	SP,R1			; GET ADDRESS OF DESCIPTOR
	CLRL	-(SP)			; CREATE GETDVI ITEM LIST
	PUSHAB	-12(SP)			; RETURN LENGTH ON STACK
	MOVQ	R4,-(SP)		; PUSH BUFFER DESCRIPTOR ON STACK
	MOVW	#DVI$_DEVNAM,2(SP)	; REQUEST COMPLETE DEVICE NAME
	MOVL	SP,R0			; GET ADDRESS OF ITEM LIST
	$GETDVIW_S  DEVNAM=(R1),- 	; GET TERMINAL DEVICE NAME
		IOSB=8(R1),-		;
		EFN=#EXE$C_SYSEFN,-	;
		ITMLST=(R0)		;
	MOVZWL	(SP),R4			; GET LENGTH OF RESULT
	ADDL	#6*4,SP			; RESTORE STACK
	BLBC	R0,90$			; BRANCH IF ERROR
	MOVZWL	(SP),R0			; GET IOSB STATUS
90$:	ADDL	#8,SP			; POP THE IOSB
	RSB

	.SBTTL	CREATE OUTPUT MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO CREATE AN OUTPUT MAILBOX FOR THIS PROCESS TO 
; RECEIVE WRITE REQUESTS FROM ITS SPAWNED SUBPROCESSES.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN DATA STRUCTURE
;	R8 = ADDRESS OF SCRATCH AREA
;	R11 = ADDRESS OF PRC DATA STRUCTURE
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

CREATE_OUTMBX:

;
; GET PID OF PARENT.
;
	CLRQ	-(SP)				; CREATE GETJPI ITEM LIST
	PUSHAB	-8(SP)				; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4			; REQUEST OUR PID, SET BUFFER LENGTH
	MOVL	SP,R0				; GET ADDR OF ITEM LIST
	$GETJPIW_S  ITMLST=(R0),-		; GET PID OF THIS PROCESS
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=SPWN_Q_IOSB(R6)		;
	POPL	R0				; GET OUR PID
	ADDL	#3*4,SP				; CLEANUP STACK

;
; CREATE MAILBOX LOGICAL NAME.
;
	MOVQ	(R8),-(SP)			; PUSH LOG NAME DESCRIPTOR
	MOVAB	OUTPUT_NAME,R2			; GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R2)+,R1			; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R1,-(SP)			; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R1				; GET ADDR OF ARGS
	$FAO_S	CTRSTR=(R1),-			; CONSTRUCT LOGICAL NAME
		OUTBUF=8(R1),-			;
		OUTLEN=8(R1),-			;
		P1=R0				; FROM PID FOR THIS PROCESS
	ADDL	#8,SP				; POP THE FAO DESCRIPTOR
	MOVQ	(SP)+,SPWN_Q_OUTPUT(R6)		; GET LOGICAL NAME DESC
	SUBL	SPWN_Q_OUTPUT(R6),(R8)		; PERMANENTLY REMOVE FROM SCRATCH
	ADDL	SPWN_Q_OUTPUT(R6),4(R8)		; PERMANENTLY REMOVE FROM SCRATCH
	BLBS	R0,20$				; BRANCH IF SUCCESSFUL
	BRW	91$				; BRANCH IF ERROR DETECTED
10$:	BRW	90$				; EXIT SUCCESSFULLY

;
; CHECK FOR ALREADY EXISTING MAILBOX.
;
20$:	INCW	PRC_W_OUTMBXREF(R11)		; INCR THE MAILBOX REF COUNT
	CMPW	PRC_W_OUTMBXREF(R11),#1		; DOES MAILBOX ALREADY EXIST?
	BNEQ	10$				; YES, THEN SKIP MBX CREATION

;
; GET MAXIMUM MESSAGE SIZE.
;
25$:	CLRQ	-(SP)				; CREATE THE ITEM LIST
	PUSHAB	-8(SP)				; SET THE BUFFER ADDRESS
	PUSHL	#SYI$_MAXBUF@16+4		; SET THE ITEM CODE AND BUFFER SIZE
	MOVL	SP,R0				; GET ADDRESS OF ITEM LIST
	$GETSYIW_S  ITMLST=(R0),-		; GET MAX BUF SIZE
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=SPWN_Q_IOSB(R6)		;
	POPL	R1				; GET THE MAXMSG SIZE
	ADDL	#3*4,SP				; POP ITEM LIST
	BLBC	R0,95$				; RETURN IF ERROR
	MOVZWL	SPWN_Q_IOSB(R6),R0		; GET IOSB STATUS
	BLBC	R0,95$				; RETURN IF ERROR
	MOVW	R1,PRC_W_OUTMBXSIZ(R11)		; SAVE THE MAXMSG SIZE

;
; CREATE THE OUTPUT MAILBOX.
;
	$CREMBX_S CHAN=PRC_W_OUTMBXCHN(R11),-	; CREATE A WRITE MAILBOX
		MAXMSG=R1,-			;
		BUFQUO=R1,-			;
		LOGNAM=SPWN_Q_OUTPUT(R6)	;
	BLBC	R0,95$				; BRANCH ON ERROR

;
; SET WRITE ATTENTION AST ON THE MAILBOX.
;
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,- ; SET ATTENTION AST ON MAILBOX
		CHAN=PRC_W_OUTMBXCHN(R11),-	;
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=SPWN_Q_IOSB(R6),-		;
		P1=W^WRITE_AST,-		; ADDRESS OF AST ROUTINE
		P2=R11				; PASS PRC BLOCK ADDRESS
	BLBC	R0,95$				; BRANCH IF ERROR
	MOVZWL	SPWN_Q_IOSB(R6),R0		; GET IOSB STATUS
	BLBC	R0,95$				; BRANCH IF ERROR
90$:	STATUS	NORMAL				; SET NORMAL STATUS
91$:	RSB					; RETURN 

;
; DELETE WRITE MAILBOX AND RETURN WITH STATUS
;
95$:	PUSHL	R0				; SAVE STATUS
	BSBW	DELETE_OUTMBX			; DELETE ALLOCATED MAILBOX
	POPL	R0				; RESTORE STATUS
	BRB	91$				; EXIT

	.SBTTL	DELETE WRITE MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO DELETE A WRITE MAILBOX.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

DELETE_OUTMBX:
	DECW	PRC_W_OUTMBXREF(R11)		; DECR THE MAILBOX REF COUNT
	BNEQ	90$				; SKIP IF NON-ZERO
	$DASSGN_S CHAN=PRC_W_OUTMBXCHN(R11)	; DELETE OUTPUT MAILBOX
	CLRW	PRC_W_OUTMBXCHN(R11)		; CLEAR MAILBOX CHANNEL NUMBER
90$:	RSB					;

	.SBTTL	WRITE REQUEST AST FROM A SUBPROCESS
;---
;
; THIS AST ROUTINE HANDLES A WRITE REQUEST FROM A SUBPROCESS
; THROUGH THE WRITE MAILBOX ASSOCIATED WITH THIS PROCESS.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

WRITE_AST:
	.WORD	^M<R2,R3,R4,R5,R6,R11>

	MOVL	4(AP),R11			; GET ADDRESS OF CLI PROCESS WORK AREA

;
; IF HANGUP AST IS PENDING, THEN WAKE UP SO THAT WE CAN TERMINATE.
;
	BBS	#PRC_V_HANGUP,PRC_W_FLAGS(R11),80$ ; WAKE UP IF HANGUP PENDING

;
; RE-ENABLE WRITE ATTENTION AST.
;
	CLRQ	-(SP)				; ALLOCATE AN IOSB
	MOVL	SP,R4				;
	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,-; RE-ENABLE AST
		CHAN=PRC_W_OUTMBXCHN(R11),-	;
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=(R4),-			;
		P1=WRITE_AST,-			; ADDRESS OF AST ROUTINE
		P2=R11				; ADDRESS OF PRC DATA STRUCTURE

;
; ALLOCATE A RECORD BUFFER AND IOSB.
;
	MOVZWL	PRC_W_OUTMBXSIZ(R11),R5		; GET SIZE OF RECORD BUFFER
	SUBL	R5,SP				; ALLOCATE RECORD BUFFER
	MOVL	SP,R2				; GET THE BUFFER ADDRESS

;
; GET RECORD TO BE WRITTEN FROM THE MAILBOX.  IF THERE IS MORE THAN
; ONE MESSAGE IN THE MAILBOX, LOOP UNTIL WE'VE READ AND WRITTEN THEM ALL.
;
10$:	$QIOW_S	FUNC=#IO$_READVBLK!IO$M_NOW,-	; READ THE ATTACH MAILBOX
		CHAN=PRC_W_OUTMBXCHN(R11),-	;
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=(R4),-			;
		P1=(R2),-			; ADDRESS OF BUFFER
		P2=R5				; SIZE OF BUFFER
	BLBC	R0,30$				; BRANCH IF DSW ERROR
	BLBC	(R4),20$			; BRANCH IF I/O ERROR
	CVTWL	2(R4),R1			; GET LENGTH OF MESSAGE
	BSBW	DCL$SPAWNOUT			; WRITE THE MESSAGE
	BRB	10$				; LOOP UNTIL MAILBOX CLEANED OUT

20$:	CMPW	(R4),#SS$_ENDOFFILE		; WAS ERROR EOF?
	BNEQ	10$				; NO, DISREGARD AND READ AGAIN
	TSTL	4(R4)				; WAS PID SPECIFIED?
	BNEQ	10$				; YES, THEN KEEP READING TO EMPTY
	STATUS	NORMAL				; SET NORMAL STATUS
30$:	RET					; RETURN

80$:	$WAKE_S					; WAKE UP CURRENT PROCESS
	RET

	.SBTTL	READ AST FROM READING ATTACH REQUEST RESPONSE
;---
;
; THIS AST ROUTINE IS CALLED UPON THE COMPLETION OF READING THE
; ATTACH REQUEST RESPONSE. IT HANDLES THE PROCESSING OF THE
; DETACHED FLAG. IT IS DOWN AT AST LEVEL TO INSURE SYNCHRONIZATION
; BETWEEN THE CURRENT PROCESS AND THE PROCESS TO BE ATTACHED.
; THE ADDRESS OF A QUAD WORD IS PASSED AS THE AST PARAMETER. THE QUAD WORD
; CONTAINS THE INPUT BUFFER FROM THE READ COMMAND (1ST LONG WORD) AND
; THE ADDRESS OF THE PRC TABLE AREA (2ND LONG WORD).
;
; INPUTS:
;
;	4(SP) = AST PARAMETER
;
; OUTPUTS:
;
;	PRC_V_DETACHED BIT IN PRC_W_FLAGS SET IF INPUT BUFFER = 1
;	CLEARED OTHERWISE
;
;---

READ_AST:
	.WORD	^M<R2,R11>

	MOVL	4(AP),R2		; GET ADDR OF QUAD WORD BUFFER
	MOVL	4(R2),R11		; GET ADDR. OF CLI PROCESS WORK AREA
	BLBC	(R2),10$		; DON'T SET DETACHED BIT IF ATTACH REFUSED
	SETBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)  ; MARK CURRENT PROC. DETACHED

10$:	RET

	.SBTTL	ATTACH REQUEST AST FROM ANOTHER PROCESS
;---
;
; THIS AST ROUTINE HANDLES AN ATTACH REQUEST FROM ANOTHER PROCESS
; THROUGH THE ATTACH MAILBOX ASSOCIATED WITH THIS PROCESS.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

ATTACH_AST:
	.WORD	^M<R2,R3,R4,R5,R6,R11>

	MOVL	4(AP),R11		; GET ADDRESS OF CLI PROCESS WORK AREA
	MOVAB	-ATTMBX_MAXMSG(SP),R6	; ALLOCATE RECORD BUFFER
	MOVL	R6,SP			; REMOVE IT FROM THE STACK

;
; IF HANGUP AST IS PENDING, THEN WAKEUP PROCESS SO WE CAN TERMINATE
;
	BBS	#PRC_V_HANGUP,PRC_W_FLAGS(R11),80$ ; WAKE UP IF HANGUP PENDING

;
; GET THE ATTACH REQUEST MESSAGE FROM THE MAILBOX.  IF THERE IS MORE THAN
; ONE MESSAGE IN THE MAILBOX, ONLY HONOR THE LAST ONE.
;
	CLRL	R3			; ASSUME NO MESSAGE READ
	CLRQ	-(SP)			; ALLOCATE AN IOSB
	MOVL	SP,R2			; POINT TO IT

10$:	$QIOW_S	FUNC=#IO$_READVBLK!IO$M_NOW,-	; READ THE ATTACH MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-
		EFN=#EXE$C_SYSEFN,-
		IOSB=(R2),-
		P1=(R6),P2=#ATTMBX_MAXMSG
	BLBC	R0,20$			; BRANCH IF ERROR
	BLBC	(R2),20$		; BRANCH IF ERROR (EOF)
	CVTWL	2(R2),R3		; SAVE LENGTH OF LAST MESSAGE
	BRB	10$			; LOOP UNTIL MAILBOX CLEANED OUT
20$:	TSTL	R3			; ANY MESSAGE READ?
	BEQL	90$			; IF NOT, IGNORE ATTENTION AST
	CLRL	R4			; ASSUME THE ANSWER IS "NO"
	BBC	#PRC_V_DETACHED,PRC_W_FLAGS(R11),30$ ; IF NOT DETACHED, SAY NO
	INCL	R4			; ELSE, RESPOND WITH YES
30$:	MOVL	SP,R2			; RESTORE ADDRESS OF IOSB
	MOVL	R4,(R6)			; MOVE RECORD INTO RECORD BUFFER
	$QIOW_S	FUNC=#IO$_WRITEVBLK,-	; WRITE YES/NO RESPONSE TO MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-;
		EFN=#EXE$C_SYSEFN,-	;
		IOSB=(R2),-		;
		P1=(R6),P2=#4		; ONLY A LONGWORD
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	BLBC	(R2),90$		; BRANCH IF ERROR DETECTED
	BLBC	R4,90$			; IF ANSWER WAS NO, THEN EXIT
	CLRBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11) ; MARK NO LONGER DETACHED
80$:	$WAKE_S				; WAKE UP CURRENT PROCESS
90$:	RET

	.SBTTL	SUBPROCESS TERMINATION AST ROUTINE
;---
;
; THIS AST IS CALLED WHEN A MESSAGE IS WRITTEN INTO THE TERMINATION
; MAILBOX, INDICATING THAT A SUBPROCESS HAS GONE AWAY.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF TMBX AREA
;
; OUTPUTS:
;
;	NONE
;---

LGI$_FACILITY = 211			; LOGINOUT FACILITY CODE

TERMINATION_AST:
	.WORD	^M<R2,R3,R5,R6,R7,R8,R11>

;
; GET THE ADDRESS OF THE TMBX DATA STRUCTURE FROM THE AST ARGUMENT LIST.
; LOOK IN IT FOR THE ADDRESS OF THE PRC DATA STRUCTURE AND THE TERMINATION
; MAILBOX CHANNEL NUMBER.
;
	MOVL	4(AP),R7			; GET ADDRESS OF TMBX BLOCK
	MOVL	TMBX_L_PRC(R7),R11		; GET ADDRESS OF CLI PROCESS WORK AREA

;
; READ THE TERMINATION MAILBOX.  IF NO MESSAGES ARE LEFT, THEN WE ARE READY TO
; RESET OR DELETE THE MAILBOX AND RETURN FROM THE AST.
;
	MOVAB	-8-ACC$C_TERMLEN(SP),SP		; ALLOCATE BUFFER SPACE FOR
10$:	MOVL	SP,R8				;    THE IOSB + RECORD BUFFER
	$QIOW_S	FUNC=#IO$_READVBLK!IO$M_NOW,- 	; READ THE TERMINATION MAILBOX
		CHAN=TMBX_W_CHANNEL(R7),-	;
		EFN=#EXE$C_SYSEFN,-		;
		IOSB=(R8),-			;
		P1=8(R8),-			;
		P2=#ACC$C_TERMLEN		;
	BLBC	R0,15$				; BRANCH IF ERROR
	BLBS	(R8),20$			; BRANCH IF MESSAGE READ
15$:	BRW	200$				; MAILBOX CLEANED OUT - DONE

;
; SEARCH THE LIST OF OUTSTANDING SUBPROCESS CONTEXT BLOCKS LOOKING FOR
; A MATCH WITH THE SUBPROCESS WHICH JUST TERMINATED.
;
	ASSUME	SPWN_L_LINK EQ 0		;
20$:	MOVAB	PRC_L_SPWN(R11),R5		; GET ADDRESS OF SPWN BLOCK LISTHEAD
25$:	MOVL	SPWN_L_LINK(R5),R6		; GET ADDRESS OF NEXT ENTRY IN LIST
	BEQL	10$				; IF NOT IN LIST, IGNORE MESSAGE
	CMPL	ACC$L_PID+8(R8),-		; DOES PID MATCH?
		SPWN_L_SUBPID(R6) 		;
	BEQL	30$				; BRANCH IF SO
	MOVL	R6,R5				; SKIP TO NEXT ENTRY IN LIST
	BRB	25$				; KEEP LOOPING

;
; THE PROCESS WHICH JUST TERMINATED HAS BEEN FOUND IN THE LIST OF
; CURRENTLY ACTIVE SPAWNED PROCESSES.  TAKE ANY TERMINATION ACTIONS WHICH 
; ARE APPROPRIATE.
;
; SET THE TERMINATION STATUS IN THE SPWN BLOCK.
;
30$:	MOVL	ACC$L_FINALSTS+8(R8),-		; SAVE THE TERMINATION STATUS
		SPWN_L_STATUS(R6) 		;
	BNEQ	50$				; BRANCH IF STATUS IS NON-ZERO
	MOVL	#1,SPWN_L_STATUS(R6)		; IF "NO STATUS", RETURN SUCCESS

;
; GET CURRENT IMAGE COUNT.  IF NOT THE SAME AS THE IMAGE COUNT AT THE TIME
; OF SUBPROCESS CREATION, THEN DO NOT EVEN CONSIDER QUEUEING A TERMINATION,
; SETTING A TERMINATION EVENT FLAG, OR SETTING TERMINATION STATUS.
;
50$:	CLRQ	-(SP)				; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)			; SET BUFFER ADDRESS
	PUSHL	#JPI$_IMAGECOUNT@16+4		; REQUEST IMAGE COUNT, SET BUFFER LENGTH
	MOVL	SP,R0				; SET ADDRESS OF ITEM LIST
	$GETJPIW_S  ITMLST=(R0),-		; GET PROCESS IMAGE COUNT
		IOSB=(R8),-			;
		EFN=#EXE$C_SYSEFN		;
	POPL	R1				; GET THE CURRENT IMAGE COUNT
	ADDL	#3*4,SP				; CLEANUP STACK
	CMPL	R1,SPWN_L_IMAGCNT(R6)		; SAME IMAGE AS ISSUED SPAWN?
	BNEQ	80$				; NO, THEN DO NOT QUEUE AST OR SET EF

;
; IF USER REQUESTED THAT THE TERMINATION STATUS BE RETURNED, THEN TRY TO RETURN
; IT NOW.
	MOVL	SPWN_L_STSADR(R6),R0		; SHOULD STATUS BE RETURNED TO CALLER?
	BEQL	60$				; BRANCH IF NOT
	IFNOWRT	#4,@SPWN_L_STSADR(R6),60$,-	; SKIP IF NOT WRITABLE
		SPWN_B_ACMODE(R6) 		;
	MOVL	SPWN_L_STATUS(R6),-		; RETURN STATUS TO CALLER
		@SPWN_L_STSADR(R6) 		;

;
; IF A TERMINATION AST WAS REQUESTED, THEN QUEUE IT UP NOW.
;
60$:	TSTL	SPWN_L_ASTADR(R6)		; AST ROUTINE REQUESTED?
	BEQL	70$				; BRANCH IF NOT
	$DCLAST_S ASTADR=@SPWN_L_ASTADR(R6),- 	; QUEUE THE AST
		ASTPRM=SPWN_L_ASTPRM(R6),-	;
		ACMODE=SPWN_B_ACMODE(R6)	;

;
; IF A TERMINATION EF WAS REQUESTED, THEN SET IT NOW.
;
70$:	TSTB	SPWN_B_EFN(R6)			; EVENT FLAG REQUESTED?
	BLSS	80$				; BRANCH IF NOT
	$SETEF_S EFN=SPWN_B_EFN(R6)		; SET THE EVENT FLAG

;
; PREVENT THE PARENT FROM HANGING TRYING TO SEND ADDITIONAL MESSAGES TO THE 
; CONTEXT MAILBOX BY CANCELING AND DEASSIGNING THE CHANNEL TO THAT MAILBOX.
;
80$:	$CANCEL_S CHAN=SPWN_W_CHAN(R6)		; STOP ANY CURRENT WRITES TO MAILBOX
	$DASSGN_S CHAN=SPWN_W_CHAN(R6)		; PREVENT FURTHER WRITES TO MAILBOX
	CLRW	SPWN_W_CHAN(R6)			; INDICATE CHANNEL WAS "REMOVED"

;
; IF /NOTIFY SPECIFIED, THEN BROADCAST NOTIFICATION MESSAGE.
;
90$:	BBC	#SPWN_V_NOTIFY,-		; SKIP IF NOT /NOTIFY
		SPWN_W_FLAGS(R6),95$		;
	BSBW	NOTIFY_MESSAGE			; BROADCAST NOTIFICATON MESSAGE
	
;
; DECREMENT TERMINATION MAILBOX REFERENCE COUNT.
;
95$:	DECB	TMBX_B_REFS(R7)			; DECREMENT REFERENCE COUNT TO MAILBOX

;
; DELETE THE WRITE MAILBOX IF ALL THROUGH WITH IT.
;
	BBS	#SPWN_V_OUTPUT,-		; SKIP IF NO MAILBOX
		SPWN_W_FLAGS(R6),97$ 		;
	BSBW	DELETE_OUTMBX			; UPDATE OUTPUT MBX USAGE

;
; IF SUBPROCESS WAS CREATED /WAIT, THEN ASSUME THAT THE SUBPROCESS THAT JUST 
; DIED WAS ATTACHED TO THE TERMINAL AND IS NOW LOGGING ITSELF OUT.  ALSO, 
; ASSUME THAT THE PARENT PROCESS WAS DETACHED FROM THE TERMINAL AND SHOULD 
; NOW BE AWAKENED TO RECEIVE CONTROL.  
;
; NOTE THAT THESE ASSUMPTIONS ARE NOT VALID IN THE CASE OF AN "ATTACHED" 
; COUSIN DELETING ITS "DETACHED" COUSIN.
;
; ALSO MARK THE SUBPROCESS INACTIVE SO THAT THE PARENT WILL DELETE THIS
; SPWN BLOCK.
;
97$:	BBC	#SPWN_V_WAIT,-			; SKIP IF /NOWAIT
		SPWN_W_FLAGS(R6),100$  		;
	CLRBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11) ; MARK NO LONGER DETACHED
	CLRBIT	SPWN_V_ACTIVE,SPWN_W_FLAGS(R6)	; MARK SUBPROCESS INACTIVE
	$WAKE_S					; WAKE UP CURRENT PROCESS
	BRW	10$				; GET NEXT MESSAGE FROM MAILBOX
	
;
; IF THE SUBPROCESS WAS CREATED /NOWAIT, THEN REMOVE THE SPWN BLOCK FROM THE
; LIST OF OUTSTANDING PROCESSES, AND DEALLOCATE IT.  
;
100$:	ASSUME	SPWN_L_LINK EQ 0		;
	MOVL	(R6),(R5)			; REMOVE FROM LINKED LIST NOW THAT
						; THE PROCESS IS NO LONGER ACTIVE
	MOVL	R6,R0				; SET ADDRESS OF BLOCK
	MOVZWL	SPWN_W_SIZE(R6),R1		; SET LENGTH OF BLOCK
	BSBW	DCL$DEADYNMEM			; DEALLOCATE SPWN BLOCK
	BRW	10$				; LOOP UNTIL MAILBOX CLEANED OUT

;
; IF REF COUNT FOR THIS MAILBOX IS NOW ZERO, THEN DEASSIGN IT AND REMOVE
; THE TMBX BLOCK FROM THE LINKED LIST.  OTHERWISE, RE-ENABLE WRITE ATTENTION 
; AST ON THE MAILBOX.
;
200$:	TSTB	TMBX_B_REFS(R7)			; TEST REFERENCE COUNT TO MAILBOX
	BNEQ	210$				; BRANCH IF STILL OUTSTANDING USES
	BSBW	DELETE_TMBX			; DELETE TERMINATION MAILBOX AND TMBX
	BRB	220$				; DO NOT BOTHER RESETING THE AST
210$:	$QIOW_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,-; RESET ATTENTION AST ON MAILBOX
		CHAN=TMBX_W_CHANNEL(R7),-	;
		IOSB=(R8),-			;
		EFN=#EXE$C_SYSEFN,-		;
		P1=TERMINATION_AST,-		; ADDRESS OF AST ROUTINE
		P2=R7				; PASS ADDRESS OF TMBX BLOCK
220$:	RET					;


	.SBTTL	BROADCAST NOTIFICATION MESSAGE
;---
;
; THIS ROUTINE BROADCASTS A MESSAGE INDICATING THAT A /NOWAIT SUBPROCESS HAS
; TERMINATED.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;---

NOTIFY_MESSAGE:
	SUBL	#NOTIFY_LEN,SP			; ALLOCATE BUFFER ON THE STACK
	MOVL	SP,-(SP)			; BUILD BUFFER DESCRIPTOR
	MOVL	#NOTIFY_LEN,-(SP)		;
	MOVL	SP,R3				; SAVE ADDRESS OF DESCRIPTOR
	MOVAB	SPWN_T_PROCESS(R6),R2		; GET PROCESS NAME
	MOVAB	NOTIFY_MSG,R1			; GET ADDRESS OF ASCIC MSG
	MOVZBL	(R1)+,R0			; GET LENGTH OF MSG
	MOVQ	R0,-(SP)			; PUSH DESCRIPTOR ON STACK
	MOVL	SP,R1				; SAVE ADDRESS OF DESCRIPTOR
	$FAO_S	CTRSTR=(R1),-			; NOTIFICATION MESSAGE
		OUTLEN=(R3),-			; ADDR OF RESULT LENGTH
		OUTBUF=(R3),-			; ADDR OF BUFFER DESC
		P1=R2				; ASCIC SUBPROCESS NAME ADDR
	MOVL	#CTL$AG_CLIDATA+PPD$T_INPDVI,R1	; GET ADDRESS OF ASCIC DEVICE NAME
	MOVZBL	(R1)+,R0			; GET LENGTH OF DEVICE
	MOVQ	R0,(SP)				; PUT DESCRIPTOR ON STACK
	MOVL	SP,R2				; SAVE ADDRESS OF DESCRIPTOR
	CLRQ	-(SP)				; ALLOCATE AN IOSB
	MOVL	(SP),R0				;

	$BRKTHRUW_S	MSGBUF=(R3),-		; BROADCAST THE MESSAGE
			SENDTO=(R2),-		;
			SNDTYP=#BRK$C_DEVICE,-	;
			REQID=#BRK$C_DCL,-	;
			EFN=#31,-		;
			IOSB=(R0)		;

	ADDL	#8+8+8+NOTIFY_LEN,SP		; RESTORE STACK
	RSB

	.END
