MODULE RIGHTSMAN (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000',
		ADDRESSING_MODE (EXTERNAL=GENERAL, nonexternal=general)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	System Management Utility Program
!
! ABSTRACT:
!
!	This program allows the system manager to maintain the rights
!	data base.  The data base is a single ISAM file which is used
!	to record the names, encoding, and holders of all identifiers
!	in the system.
!
! ENVIRONMENT:
!
! AUTHOR:	Larry Yetto , CREATION DATE: 22-MAR-1984 
!
! MODIFIED BY:
!
!	V03-005	JRL0018		John R. Lawson, Jr.	02-Jul-1984 15:26
!		ADD/IDENTIFIER FOOBAR /VALUE:UIC=[*,*] is O.K., but
!		ADD/IDENTIFIER FOOBAR /VALUE:UIC=[*,27] isn't.
!
!	V03-004	JRL0002		John R. Lawson, Jr.	14-Jun-1984 15:38
!		Replace all messages with calls to LIB$SIGNAL and place
!		those messages in a .MSG file
!
!	V03-003	LY0495		Larry Yetto		11-JUN-1984 13:01
!		Correct noise error message being reported by ADD/ID/USER=*
!		caused by improperly initialized flag.
!
!	V03-002	LY0479		Larry Yetto		27-APR-1984 08:28
!		Do not delete the user identifier during a REMOVE command
!		unless there are no longer any UAF records with
!		this UIC
!		Base Level QAR #182  -  Fix accvio in rename/ident
!
!	V03-001	LY0476		Larry Yetto		 9-APR-1984 10:29
!		Fix endless loop in SHOW/ID/USER=*
!
!
!--


!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    UAF$ADD_GRP_IDENT 		: NOVALUE ,
    UAF$ADD_IDENT 		: NOVALUE ,
    UAF$ADD_IDENT_RECBUF ,
    UAF$BUILD_HOLDER ,
    UAF$CREATE_RDB		: NOVALUE ,
    UAF$DISPLAY_IDENT 		: NOVALUE ,
    UAF$DISPLAY_IDENT_RECBUF ,
    UAF$DISPLAY_RIGHTS 		: NOVALUE ,
    UAF$DISPLAY_RIGHTS_RECBUF ,
    UAF$FIND_UIC ,
    UAF$GRANT_IDENT		: NOVALUE ,
    UAF$RECORD_FOUND ,
    UAF$LIST_IDENT		: NOVALUE ,
    UAF$LIST_RIGHTS		: NOVALUE ,
    UAF$MODIFY_IDENT		: NOVALUE ,
    UAF$REMOVE_GRP_IDENT	: NOVALUE ,
    UAF$REMOVE_IDENT		: NOVALUE ,
    UAF$REMOVE_IDENT_RECBUF ,
    UAF$RENAME_IDENT		: NOVALUE ,
    UAF$REVOKE_IDENT		: NOVALUE ,
    UAF$SHOW_IDENT		: NOVALUE ,
    UAF$SHOW_RIGHTS		: NOVALUE ,
    UAF$WRITE_HOLDERS ,
    UAF$WRITE_IDENT ,
    UAF$WRITE_RIGHTS ;

EXTERNAL ROUTINE
    CLI$PRESENT ,
    CLI$GET_VALUE ,
    FAOOUT ,
    FMT_SYS_MSG ,
    GETVAL ,
    PARSE_UIC ,
    PARSE_WILD ,
    PARSE_WILD_UIC ,
    WILD_USER ;

!
! INCLUDE FILES:
!
LIBRARY 'SYS$LIBRARY:LIB.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';


!
! Field, structure, and Macro definitions
!
FIELD
    DESCR_FIELDS = 			! Define the fields for a DESCRIPTOR
	SET
	LENGTH  = [DSC$W_LENGTH],
	DTYPE   = [DSC$B_DTYPE],
	CLASS   = [DSC$B_CLASS],
	POINTER = [DSC$A_POINTER]
	TES;


!++
! Structure for all MDL defined blocks.
!
!--
!

MACRO
    STRINGDESC =
	$BBLOCK [DSC$K_S_BLN] FIELD (DESCR_FIELDS)%;

MACRO
    STATDESC =
	$BBLOCK [DSC$K_S_BLN] FIELD (DESCR_FIELDS)
                  PRESET ( [LENGTH]  = 0,
	                   [DTYPE]   = DSC$K_DTYPE_T,
	                   [CLASS]   = DSC$K_CLASS_S,
	                   [POINTER] = 0)%;

MACRO
    DYNAMICDESC =
	$BBLOCK [DSC$K_D_BLN] FIELD (DESCR_FIELDS)
                  PRESET ( [LENGTH]  = 0,
	                   [DTYPE]   = 0,
	                   [CLASS]   = DSC$K_CLASS_D,
	                   [POINTER] = 0)%;

!
! Macro to create string descriptor for command parameters and
!	qualifiers
!
MACRO
    QUALSTR_DESC (STRING) =
	$BBLOCK [DSC$K_S_BLN] FIELD (DESCR_FIELDS)
                  PRESET ( [LENGTH]  = (%CHARCOUNT(STRING)),
                           [DTYPE]   = DSC$K_DTYPE_T,
                           [CLASS]   = DSC$K_CLASS_S,
                           [POINTER] = (UPLIT BYTE (%STRING(STRING))))%;

MACRO
    CSTRING[] = (UPLIT BYTE (%CHARCOUNT (%STRING (%REMAINING)),
		%STRING (%REMAINING)))% ;

!
! Macros to check for success or failure from RMS
!
MACRO
    RMSBAD (STRING) = (NOT (RMSERR = STRING)) %,
    RMSOK (STRING) = (RMSERR = STRING) % ;

MACRO
!
! Macros to set up and write an FAO string.
!
    
FAOMAC (FAOMSG)[] =
	BEGIN
	FAODSC[DSC$W_LENGTH] = . (FAOMSG)<0,8>;
	FAODSC[DSC$A_POINTER] = (FAOMSG) + 1;
	$FAO (FAODSC, RABPTR[RAB$W_RSZ], DISDSC $COMMA (%REMAINING)
			%REMAINING);
	$PUT (RAB = .RABPTR);
	END %,

    $COMMA[] =, %,

    OUTPUT_NULL =
	BEGIN
	RABPTR[RAB$W_RSZ] = 0;
	$PUT (RAB = .RABPTR);
	END % ;

LITERAL
    FALSE		= 0 ,
    TRUE 		= 1 ,
    BYTE_LENGTH		= 8 ,
    WORD_LENGTH		= 16 ,
    LONGWORD_LENGTH	= 32 ;

external literal

   CLI$_NEGATED,
   DISBUFLEN;

!
!	External messages
!
external routine

   LIB$SIGNAL;

external literal

   UAF$_BADSPC,		UAF$_GRANTERR,		UAF$_GRANTMSG,
   UAF$_IDOUTRNG,	UAF$_LSTERR,		UAF$_LSTMSG1,
   UAF$_NOGRPWILD,	UAF$_NOIDNAME,		UAF$_NOTIDFMT,
   UAF$_NOTUICFMT,   	UAF$_RDBADDERR,		UAF$_RDBADDERRU,
   UAF$_RDBADDERRV,	UAF$_RDBADDMSG,		UAF$_RDBADDMSGU,
   UAF$_RDBCREERR,	UAF$_RDBCREMSG,		UAF$_RDBMDFYERR,
   UAF$_RDBMDFYMSG,	UAF$_RDBREMERR,		UAF$_RDBREMMSG,
   UAF$_RDBREMMSGU,	UAF$_REVOKEERR,		UAF$_REVOKEMSG,
   UAF$_RLSTMSG,	UAF$_SHOWERR,		UAF$_UICERR,
   UAF$_WLDNOTALWD;

!
! External variables
!
EXTERNAL

    DISBUF		: VECTOR [,BYTE], 	! Display buffer
    DISDSC		: BLOCK [,BYTE],
    FAODSC		: BLOCK [, BYTE],	! gen'l purpose fao string desc
    FOUND_MATCH		: LONG ,
    GRP_WILD		: LONG ,
    MEM_WILD		: LONG ,
    OUTRAB		: $RAB_DECL ,
    RABPTR		: REF BLOCK [, BYTE], 	! RAB for output
    RECBUF		: $BBLOCK ,
    RIGHTSLIST_MODIFIED	: BYTE ,
    RDB_EXISTS		: LONG ,
    RMSERR		: LONG ,
    STR_WILD		: LONG ,
    TOKENDSC		: $BBLOCK ,
    TOKENLEN		: WORD ,
    TOKENPTR		: LONG ,
    UIC_FLAG		: LONG ;


!
! Global storage
!
GLOBAL
    RDB_HEADER_FLAG	: BYTE ,
    RDB_LIST_FLAG	: BYTE ,
    ATTRIBUTES		: LONG ,
    HOLDER		: $BBLOCK[8] INITIAL ( REP 2 OF (0)) ,
    IDENT		: $BBLOCK[4] INITIAL (0) ;

!
! Module wide OWN storage
!
OWN
    SHOW_ID_FULL	: BYTE ,
    STATUS		: LONG ,

    RLSTNAM		: $NAM (),		! needed for the DLT option

    RLSTPRO		: $XABPRO (
			PRO = (RWD,RWD,RW)
			),

    RLSTFAB		: $FAB (		! FAB for UAF listing file
			FAC = PUT,
			RAT = CR,
			FNM = 'RIGHTSLIST.LIS',
			SHR = NIL,
			ORG = SEQ,
			RFM = VAR,
			MRS = DISBUFLEN,
			NAM = RLSTNAM,
			XAB = RLSTPRO
			),

    RLSTRAB		: $RAB (		! RAB for RIGHTLIST listing file
			RAC = SEQ,
			RBF = DISBUF,
			FAB = RLSTFAB
			) ;


!
! Parameter and qualifier string descriptors
!
OWN
    SD_ATTRIBRESOURCE	: QUALSTR_DESC ('ATTRIBUTES.RESOURCE'),
    SD_BRIEF		: QUALSTR_DESC ('BRIEF'),
    SD_FULL		: QUALSTR_DESC ('FULL'),
    SD_HOLDER		: QUALSTR_DESC ('HOLDER'),
    SD_NAME		: QUALSTR_DESC ('NAME'),
    SD_SYSTEM_ID	: QUALSTR_DESC ('SYSTEM_ID'),
    SD_TOKEN1		: QUALSTR_DESC ('TOKEN1'),
    SD_TOKEN2		: QUALSTR_DESC ('TOKEN2'),
    SD_USER		: QUALSTR_DESC ('USER'),
    SD_VALUE		: QUALSTR_DESC ('VALUE'),
    SD_VALUEIDENTIFIER	: QUALSTR_DESC ('VALUE.IDENTIFIER'),
    SD_VALUEUIC		: QUALSTR_DESC ('VALUE.UIC');


%SBTTL ' UAF$ADD_GRP_IDENT - Add rights group identifier '

GLOBAL ROUTINE UAF$ADD_GRP_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Add an identifier for the uic group if it doesn't already
!	exist.  Use the account name for the name of the identifier.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	Rights data base is modified
!--


LOCAL
    BLANK	: BYTE INITIAL (%C' ') ,
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    RESULT_ID	: $BBLOCK [4];

RESULT_ID = 0 ;
IDENT = 0 ;

!
! Get the identifier name from the UAF record account field.
!
CH$COPY ( UAF$S_ACCOUNT, RECBUF[UAF$T_ACCOUNT], %C' ',
          KGB$S_NAME,  NAME_BUFF );
NAME_DESC[LENGTH]  = MIN ( UAF$S_ACCOUNT,
                           KGB$S_NAME,
                           (CH$FIND_CH (KGB$S_NAME, NAME_BUFF, %C' ') - NAME_BUFF) ) ;
NAME_DESC[POINTER] = NAME_BUFF ;

!
! Build the identifier from the UAF record and then wild card
! the member number
!
UAF$FIND_UIC () ;
IDENT [UIC$V_MEMBER] = UIC$K_WILD_MEMBER ;

!
! If the account field is blank then do not try to create
! an identifier.
!
IF CH$NEQ ( 1, BLANK, .NAME_DESC[LENGTH], .NAME_DESC[POINTER], %C' ')
    THEN
	!
	! The account is non blank so check if the ID name or
	! value is already in use.
	!
	IF NOT ( $ASCTOID ( NAME = NAME_DESC ) OR
                 $IDTOASC ( ID   = .IDENT ))
	    THEN
		BEGIN
		!
		! The identifier is not in use.
		! Perform the actual service to add the identifier
		!
		STATUS = $ADD_IDENT ( NAME   = NAME_DESC,
		                      ID     = .IDENT,
		                      ATTRIB = .ATTRIBUTES,
		                      RESID  = RESULT_ID ) ;

		IF NOT .STATUS
		    THEN
			BEGIN
			IF .IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
			    THEN LIB$SIGNAL(UAF$_RDBADDERRU, 3, NAME_DESC,
			        .IDENT[UIC$V_GROUP], .IDENT[UIC$V_MEMBER], 
				.STATUS)
			    ELSE LIB$SIGNAL(UAF$_RDBADDERRV, 2, NAME_DESC, 
				.IDENT, .STATUS);
			END
		    ELSE 
			BEGIN
			RIGHTSLIST_MODIFIED = TRUE ;
			IF .RESULT_ID[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
			    THEN LIB$SIGNAL(UAF$_RDBADDMSGU, 3, NAME_DESC,
			                .RESULT_ID[UIC$V_GROUP],
			                .RESULT_ID[UIC$V_MEMBER])
			    ELSE LIB$SIGNAL(UAF$_RDBADDMSG, 2, NAME_DESC, 
					.RESULT_ID);
			END ;
		END ;
END ;					! End of UAF$ADD_GRP_IDENT


%SBTTL ' UAF$ADD_IDENT  -  Add rights identifier '

GLOBAL ROUTINE UAF$ADD_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will add an identifier to the rights data base.
!	It is invoked via the ADD/IDENT command.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	Command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	Rights data base is modified
!
!--


LOCAL
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    RESULT_ID	: $BBLOCK [4];

RESULT_ID = 0 ;
IDENT = 0 ;

!
! Set the resource attribute if /RESOURCE was specified.
! This is done first since it is required whether or not
! P1 or /USER is specified.
!
IF CLI$PRESENT (SD_ATTRIBRESOURCE)
    THEN ATTRIBUTES = KGB$M_RESOURCE
    ELSE ATTRIBUTES = 0 ;

!
! We will now get the id name parameter from
! the command line.  If the parameter is missing
! then the /USER qualifier must be present
!
IF CLI$PRESENT ( SD_TOKEN1 )
    THEN
	BEGIN
	CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC ) ;

	CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  NAME_BUFF );
	NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
	NAME_DESC[POINTER] = NAME_BUFF ;

	!
	! If the /VALUE qualifier was specified then get it's value
	! 
	IF NOT CLI$PRESENT ( SD_VALUE )
	    THEN 
		BEGIN
		IDENT [UIC$V_FORMAT]  = 0 ;
		IDENT [UIC$V_ID_CODE] = 0 ;
		END
	    ELSE
		BEGIN
		!
		! /VALUE is there now determine what keyword was used
		! and interpret the data as appropriate.
		! First check for IDENTIFIER:
		IF CLI$GET_VALUE ( SD_VALUEIDENTIFIER, TOKENDSC )
		    THEN
			BEGIN
			LOCAL
			    TMP_IDENT : LONG INITIAL (0) ;
	
			STATUS = GETVAL ( TMP_IDENT, LONGWORD_LENGTH );
			IF NOT .STATUS
			    THEN RETURN ;
			IDENT [UIC$V_FORMAT]  = UIC$K_ID_FORMAT ;
			IDENT [UIC$V_ID_CODE] = .TMP_IDENT ;
			IF (.IDENT LSSU %X'80008000') OR
                           (.IDENT GTRU UIC$K_LAST_ID)
			    THEN
				BEGIN
				LIB$SIGNAL(UAF$_IDOUTRNG);
				RETURN ;
				END ;
		    	END
		    ELSE 
			BEGIN
			!
			! Now check for UIC
			! These two keywords are synonyms
			!
			IF CLI$PRESENT (SD_VALUEUIC)
			    THEN IF NOT PARSE_WILD (SD_VALUEUIC, TRUE ) 
				THEN RETURN ;
			IF .UIC_FLAG
			    THEN
				BEGIN
				IF .GRP_WILD and not .MEM_WILD
				    THEN
					BEGIN
					!
					! Wild cards are not allowed for group numbers
					!
					LIB$SIGNAL(UAF$_NOGRPWILD);
					RETURN ;
					END ;
				!
				! The UIC format was used,  parse it to fine the
				! group and member number.
				! Wild card group and member numbers are allowed
				!
				IF NOT PARSE_UIC ( IDENT[UIC$V_GROUP],
	                                           IDENT[UIC$V_MEMBER],
				                   TRUE )
				    THEN
					BEGIN
					LIB$SIGNAL(UAF$_UICERR, 2, .TOKENLEN, 
							.TOKENPTR);
					RETURN ;
					END ;
				IDENT[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
				END
			    ELSE
				BEGIN
				!
				! A user name was specified.  Get the UAF record
				! for this user and pull the UIC out.
				!
				IF .STR_WILD
				    THEN
					BEGIN
					!
					! Wild cards are not allowed for user specs
					!
					LIB$SIGNAL(UAF$_WLDNOTALWD);
					RETURN ;
					END ;
				FOUND_MATCH = FALSE ;
				IF RMSBAD ( WILD_USER (UAF$FIND_UIC))
				    THEN
					BEGIN
					IF .RMSERR EQL RMS$_RNF
					    THEN LIB$SIGNAL(UAF$_BADSPC)
					    ELSE LIB$SIGNAL(UAF$_RDBADDERR, 1, 
					                 NAME_DESC, .RMSERR);
					RETURN ;
					END ;
				END ;
	
			END;
		END ;

	!
	! Perform the actual service to add the identifier
	!
	STATUS = $ADD_IDENT ( NAME   = NAME_DESC,
	                      ID     = .IDENT,
	                      ATTRIB = .ATTRIBUTES,
	                      RESID  = RESULT_ID ) ;
	
	IF NOT .STATUS
	    THEN
		BEGIN
		IF .IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
		    THEN LIB$SIGNAL(UAF$_RDBADDERRU, 3, NAME_DESC,
		                       	.IDENT[UIC$V_GROUP], 
					.IDENT[UIC$V_MEMBER], .STATUS)
		    ELSE LIB$SIGNAL(UAF$_RDBADDERRV, 2, NAME_DESC, .IDENT, 
					.STATUS);
		END
	    ELSE 
		BEGIN
		RIGHTSLIST_MODIFIED = TRUE ;
		IF .RESULT_ID[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
		    THEN LIB$SIGNAL(UAF$_RDBADDMSGU, 3, NAME_DESC,
		                .RESULT_ID[UIC$V_GROUP],
				.RESULT_ID[UIC$V_MEMBER] )
		    ELSE LIB$SIGNAL(UAF$_RDBADDMSG, 2, NAME_DESC, .RESULT_ID);
		END ;
	END
    ELSE
	BEGIN
	IF CLI$PRESENT (SD_USER)
	    THEN
		BEGIN
		IF NOT PARSE_WILD (SD_USER, TRUE ) 
		    THEN RETURN ;
		END
	    ELSE
		BEGIN
		LIB$SIGNAL(UAF$_NOIDNAME);
		RETURN ;
		END ;
	FOUND_MATCH = FALSE ;
	IF RMSBAD ( WILD_USER (UAF$ADD_IDENT_RECBUF))
	    THEN
		BEGIN
		IF .RMSERR EQL RMS$_RNF
		    THEN LIB$SIGNAL(UAF$_BADSPC)
		    ELSE LIB$SIGNAL(UAF$_RDBADDERR, 1, NAME_DESC, .RMSERR);
		RETURN ;
		END ;
	END ;

RETURN

END ;					! End of UAF$ADD_IDENT


%SBTTL ' UAF$ADD_IDENT_RECBUF  -  Add rights identifier '

GLOBAL ROUTINE UAF$ADD_IDENT_RECBUF =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine add identifiers to the rights data base for
!	a user and his group.  The rouyine uses a UAF record as input
!	to determine what identifiers need to be added.
!
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	Always true
!
! SIDE EFFECTS:
!
!	Rights data base is modified
!--


LOCAL
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    RESULT_ID	: $BBLOCK [4];

RESULT_ID = 0 ;
IDENT = 0 ;
FOUND_MATCH = TRUE;

!
! Get the identifier name from the UAF record username field.
!
CH$COPY ( UAF$S_USERNAME, RECBUF[UAF$T_USERNAME], %C' ',
          KGB$S_NAME,  NAME_BUFF );
NAME_DESC[LENGTH]  = MIN ( UAF$S_USERNAME,
                           KGB$S_NAME,
                           (CH$FIND_CH (KGB$S_NAME, NAME_BUFF, %C' ') - NAME_BUFF) ) ;
NAME_DESC[POINTER] = NAME_BUFF ;

!
! Build the identifier from the UAF record 
!
UAF$FIND_UIC () ;

!
! Perform the actual service to add the identifier
!
STATUS = $ADD_IDENT ( NAME   = NAME_DESC,
                      ID     = .IDENT,
                      ATTRIB = .ATTRIBUTES,
                      RESID  = RESULT_ID ) ;

IF NOT .STATUS
    THEN
	BEGIN
	IF .IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
	    THEN LIB$SIGNAL(UAF$_RDBADDERRU, 3, NAME_DESC,
	                       	.IDENT[UIC$V_GROUP], .IDENT[UIC$V_MEMBER],
				.STATUS)
	    ELSE LIB$SIGNAL(UAF$_RDBADDERRV, 2, NAME_DESC, .IDENT, .STATUS);
	END
    ELSE 
	BEGIN
	RIGHTSLIST_MODIFIED = TRUE ;
	IF .RESULT_ID[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
	    THEN LIB$SIGNAL(UAF$_RDBADDMSGU, 3, NAME_DESC,
	                  .RESULT_ID[UIC$V_GROUP], .RESULT_ID[UIC$V_MEMBER])
	    ELSE LIB$SIGNAL(UAF$_RDBADDMSG, 2, NAME_DESC, .RESULT_ID);
	END ;

!
! We will now check for the presence of the group identifier
! and create it if it doesn't exist.
!
UAF$ADD_GRP_IDENT () ;

RETURN TRUE ;

END ;					! End of UAF$ADD_IDENT_RECBUF


%SBTTL ' UAF$BUILD_HOLDER -  Build a holder quadword from UAF record'

GLOBAL ROUTINE UAF$BUILD_HOLDER=
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to build a quadword holder from
!	a UAF record
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	HOLDER is initialized
!
! ROUTINE VALUE:
!
!	Always true
!
! SIDE EFFECTS:
!
!	none
!--


BIND HOLDER_VEC = HOLDER : VECTOR [2,LONG] ;

FOUND_MATCH = TRUE;

HOLDER[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
HOLDER[UIC$V_GROUP]  = .RECBUF [UAF$W_GRP] ;
HOLDER[UIC$V_MEMBER] = .RECBUF [UAF$W_MEM] ;

HOLDER_VEC[1] = 0 ;

RETURN TRUE ;

END ;					! End of UAF$BUILD_HOLDER


%SBTTL ' UAF$CREATE_RDB  -  Create a new RIGHTSLIST'

GLOBAL ROUTINE UAF$CREATE_RDB : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to create a new rights data base.  It
!	is invoked via the CREATE/RIGHTS command. It does not, however,
!	create the file if it already exists.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A new rights data base id created and initialized
!
!--


LOCAL
    I			: BYTE,
    SYSTEM_ID		: VECTOR [2,LONG],
    SYSTEM_ID_PTR	: LONG ;

!
! If a system ID was specified then get the first two numeric
! values.  If more than two exist then ignore the extra,  If less
! than two exist fill in with zeros
!
SYSTEM_ID_PTR = 0 ;
SYSTEM_ID[0] = 0 ;
SYSTEM_ID[1] = 0 ;
I = 0 ;
WHILE (CLI$GET_VALUE ( SD_SYSTEM_ID, TOKENDSC )) AND
      (.I LEQ 1) DO
    BEGIN
    STATUS = GETVAL ( SYSTEM_ID [.I] , LONGWORD_LENGTH );
    IF NOT .STATUS
	THEN RETURN ;
    I = .I + 1 ;
    SYSTEM_ID_PTR = SYSTEM_ID ;
    END ;

!
! Now call the service to create the file
!

STATUS = $CREATE_RDB(sysid=.SYSTEM_ID_PTR);
if not .STATUS then
   LIB$SIGNAL(UAF$_RDBCREERR, 0, .STATUS)
else
   begin
	RIGHTSLIST_MODIFIED = TRUE;
	RDB_EXISTS = TRUE;
	LIB$SIGNAL(UAF$_RDBCREMSG);
   end;

return;

end;					! End of UAF$CREATE_RDB


%SBTTL ' UAF$DISPLAY_IDENT  -  Display rights identifiers '

GLOBAL ROUTINE UAF$DISPLAY_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is the common routine used by the SHOW/IDENT and LIST/IDENT
!	command.  It will interogate the rights data base and output the
!	desird information
!
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RABPTR must point to the output RAB
!	RDB_LIST_FLAG = 1 => list operation
!	              = 0 => show operation
!	SHOW_ID_FULL  = 1 => show/list full
!	                0 => show/list brief
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


LOCAL
    WILD_CARD	: LONG ,
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;

IDENT = 0 ;

!
! We will now get the id name parameter from
! the command line.  If it isn't present then we
! MUST have either the /VALUE or /OWNER qualifier present.
!

IF NOT CLI$PRESENT ( SD_TOKEN1 )
    THEN
	IF NOT  (CLI$PRESENT ( SD_VALUE ) OR
	         CLI$PRESENT ( SD_USER ))
	    THEN 
		BEGIN
		LIB$SIGNAL(UAF$_NOIDNAME);
		RETURN ;
		END ;

IF .RDB_LIST_FLAG
    THEN LIB$SIGNAL(UAF$_LSTMSG1);
RDB_HEADER_FLAG = TRUE ;

IF CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC )
    THEN
	BEGIN

	CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  NAME_BUFF );
	NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
	NAME_DESC[POINTER] = NAME_BUFF ;

	!
	! Check for a wild card
	!
	IF CH$EQL ( .NAME_DESC[LENGTH], .NAME_DESC[POINTER], 
	            1, UPLIT(BYTE('*')), %C' ')
	    THEN
		BEGIN
		IDENT = UIC$K_MATCH_ALL ; ! Wild card specified by ID value of -1
		WILD_CARD = TRUE ;
		END
	    ELSE
		BEGIN
		!
		! Get the IDENT from the ascii string
		!
		STATUS = $ASCTOID ( NAME = NAME_DESC,
		                    ID   = IDENT ) ;
		IF NOT .STATUS
		    THEN
			BEGIN
			    IF .RDB_LIST_FLAG
				THEN 
				    BEGIN
				    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
				    RLSTFAB [FAB$V_DLT] = TRUE ;
				    END
				ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
			RETURN ;
			END ;
		WILD_CARD = FALSE ;
		END ;

	STATUS = UAF$WRITE_IDENT ( .IDENT, .SHOW_ID_FULL, .WILD_CARD ) ;
	IF NOT .STATUS
	    THEN IF .RDB_LIST_FLAG
		THEN 
		    BEGIN
		    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
		    RLSTFAB [FAB$V_DLT] = TRUE ;
		    RETURN ;
		    END
		ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
	END ;

!
! If the /VALUE qualifier was specified then get it's value
! First check fo IDENTIFIER:
!
IF CLI$GET_VALUE ( SD_VALUEIDENTIFIER, TOKENDSC )
    THEN
	BEGIN
	LOCAL
	    TMP_IDENT : LONG INITIAL (0) ;

	STATUS = GETVAL ( TMP_IDENT, LONGWORD_LENGTH );
	IF NOT .STATUS
	    THEN RETURN ;
	IDENT [UIC$V_FORMAT]  = UIC$K_ID_FORMAT ;
	IDENT [UIC$V_ID_CODE] = .TMP_IDENT ;
	STATUS = UAF$WRITE_IDENT ( .IDENT, .SHOW_ID_FULL, FALSE ) ;
	IF NOT .STATUS
	    THEN IF .RDB_LIST_FLAG
		THEN 
		    BEGIN
		    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
		    RLSTFAB [FAB$V_DLT] = TRUE ;
		    RETURN ;
		    END
		ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
	    END
ELSE IF CLI$PRESENT (SD_VALUEUIC)
    THEN 
	BEGIN
	!
	! Now check for UIC
	!
	IF NOT PARSE_WILD (SD_VALUEUIC, TRUE ) 
	    THEN RETURN ;
	IF .UIC_FLAG
	    THEN
		BEGIN
		!
		! The UIC format was used,  parse it to fine the
		! group and member number.
		! Wild card group and member numbers are allowed
		!
		IF NOT PARSE_UIC ( IDENT[UIC$V_GROUP],
				   IDENT[UIC$V_MEMBER],
				   TRUE )
		    THEN
			BEGIN
			LIB$SIGNAL(UAF$_UICERR, 2, .TOKENLEN, .TOKENPTR);
			RETURN ;
			END ;
		WILD_CARD = FALSE ;
		IDENT[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
		END
	    ELSE
		BEGIN
		!
		! A user name was specified.  Get the UAF record
		! for this user and pull the UIC out.
		!
		WILD_CARD = .STR_WILD ;
		IF .STR_WILD
		    THEN IDENT = UIC$K_MATCH_ALL
		    ELSE
			BEGIN
			FOUND_MATCH = FALSE ;
			IF RMSBAD ( WILD_USER (UAF$FIND_UIC))
			    THEN
				BEGIN
				IF .RMSERR EQL RMS$_RNF
				    THEN LIB$SIGNAL(UAF$_BADSPC)
				    ELSE IF .RDB_LIST_FLAG
					THEN LIB$SIGNAL(UAF$_LSTERR, 0, 
							.STATUS)
					ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, 
							.STATUS);
				RETURN ;
				END ;
			END ;
		END ;
	STATUS = UAF$WRITE_IDENT ( .IDENT, .SHOW_ID_FULL, .WILD_CARD ) ;
	IF NOT .STATUS
	    THEN IF .RDB_LIST_FLAG
		THEN 
		    BEGIN
		    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
		    RLSTFAB [FAB$V_DLT] = TRUE ;
		    RETURN ;
		    END
		ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
	END;
IF CLI$PRESENT (SD_USER) 
    THEN IF PARSE_WILD (SD_USER, TRUE ) 
	THEN
	    BEGIN
	    FOUND_MATCH = FALSE ;
	    IF RMSBAD ( WILD_USER (UAF$DISPLAY_IDENT_RECBUF))
		THEN
		    BEGIN
		    IF .RMSERR EQL RMS$_RNF
			THEN LIB$SIGNAL(UAF$_BADSPC)
			ELSE IF .RDB_LIST_FLAG
			    THEN 
			       BEGIN
			       LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
			       RLSTFAB [FAB$V_DLT] = TRUE ;
			       RETURN ;
			       END
			    ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
		    END ;
	    END;

IF .RDB_LIST_FLAG
    THEN LIB$SIGNAL(UAF$_RLSTMSG);

RETURN

END ;					! End of UAF$DISPLAY_IDENT


%SBTTL ' UAF$DISPLAY_IDENT_RECBUF - Display identifier from RDB'

GLOBAL ROUTINE UAF$DISPLAY_IDENT_RECBUF =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the identifier which corresponds to the UIC in the current
!	record in RECBUF
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!	RABPTR must point to the output RAB
!	SHOW_ID_FULL  = 1 => show/list full
!	                0 => show/list brief
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	status or write operation
!
! SIDE EFFECTS:
!
!	none
!--


LOCAL
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;

IDENT = 0 ;
FOUND_MATCH = TRUE;

!
! First see if the identifier is there and get it's name.
! If it doesn't exist then just return
!
UAF$FIND_UIC () ;			! Form an IDENT from the UIC in RECBUF
NAME_DESC[POINTER] = NAME_BUFF ;
NAME_DESC[LENGTH]  = KGB$S_NAME ;
STATUS = $IDTOASC ( ID     = .IDENT,
                    NAMLEN = NAME_DESC[LENGTH],
                    NAMBUF = NAME_DESC ) ;
IF NOT .STATUS
    THEN RETURN TRUE ;

!
! Now call the display routine
!
STATUS = UAF$WRITE_IDENT ( .IDENT, .SHOW_ID_FULL, FALSE ) ;

RETURN .STATUS ;

END ;					! End of UAF$DISPLAY_IDENT_RECBUF


%SBTTL ' UAF$DISPLAY_RIGHTS - Display rights held by user'

GLOBAL ROUTINE UAF$DISPLAY_RIGHTS : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is the common routine used by the SHOW/RIGHTS and LIST/RIGHTS
!	command.  It will interogate the rights data base and output the
!	desird information
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RABPTR must point to the output RAB
!	RDB_LIST_FLAG = 1 => list operation
!	              = 0 => show operation
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


BIND
    HOLDER_VEC		= HOLDER : VECTOR [2,LONG] ;

!
! If the user id parameter is not present then the /OWNER
! qualifier must be.
!
IF NOT (CLI$PRESENT ( SD_TOKEN1 ) OR
        CLI$PRESENT ( SD_USER ))
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_NOIDNAME);
	RLSTFAB [FAB$V_DLT] = TRUE ;
	RETURN ;
	END ;

IF .RDB_LIST_FLAG
    THEN LIB$SIGNAL(UAF$_LSTMSG1);
RDB_HEADER_FLAG = TRUE ;


IF CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC )
    THEN
	BEGIN
	HOLDER_VEC[1] = 0 ;

	!
	! Convert the ID from ASCII to a longword format
	!
	STATUS = $ASCTOID ( NAME   = TOKENDSC,
	                    ID     = HOLDER_VEC[0],
	                    ATTRIB = 0 ) ;

	IF NOT .STATUS
	    THEN
		BEGIN
		IF .RDB_LIST_FLAG
		    THEN
		 	BEGIN
			LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
		 	RLSTFAB [FAB$V_DLT] = TRUE ;
			END
		    ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
		RETURN ;
		END ;


	STATUS = UAF$WRITE_RIGHTS ( HOLDER ) ;
	IF NOT .STATUS
	    THEN IF .RDB_LIST_FLAG
		THEN 
		    BEGIN
		    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
		    RLSTFAB [FAB$V_DLT] = TRUE ;
		    RETURN ;
		    END
		ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
	END ;

IF CLI$PRESENT (SD_USER)
    THEN
	BEGIN
	IF NOT (STATUS =  PARSE_WILD (SD_USER, TRUE ))
	    THEN IF .RDB_LIST_FLAG
		THEN 
		    BEGIN
		    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
		    RLSTFAB [FAB$V_DLT] = TRUE ;
		    RETURN ;
		    END
		ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
	
	FOUND_MATCH = FALSE ;
	IF RMSBAD ( WILD_USER (UAF$DISPLAY_RIGHTS_RECBUF))
	    THEN
		BEGIN
		IF .RMSERR EQL RMS$_RNF
		    THEN LIB$SIGNAL(UAF$_BADSPC)
		    ELSE IF .RDB_LIST_FLAG
			THEN
			    BEGIN
			    LIB$SIGNAL(UAF$_LSTERR, 0, .STATUS);
			    RLSTFAB [FAB$V_DLT] = TRUE ;
			    RETURN ;
			    END
			ELSE LIB$SIGNAL(UAF$_SHOWERR, 0, .STATUS);
		END ;
	END ;

IF .RDB_LIST_FLAG
    THEN LIB$SIGNAL(UAF$_RLSTMSG);
RETURN ;

END ;					!End of UAF$DISPLAY_RIGHTS


%SBTTL ' UAF$DISPLAY_RIGHTS_RECBUF - Display ids held'

GLOBAL ROUTINE UAF$DISPLAY_RIGHTS_RECBUF =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the identifiers which are held by the identifier
!	which corresponds to the UIC in the current
!	record in RECBUF
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!	RABPTR must point to the output RAB
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


BIND
    HOLDER_VEC = HOLDER : VECTOR [2,LONG ] ;

FOUND_MATCH = TRUE;

!
! First see if the identifier is there and get it's name.
! If it doesn't exist then just return
!
UAF$BUILD_HOLDER() ;			! build a holder from the UIC in RECBUF

STATUS = $IDTOASC ( ID     = .HOLDER_VEC[0] ) ;
IF NOT .STATUS
    THEN RETURN TRUE ;

!
! Now call the display routine
!
STATUS = UAF$WRITE_RIGHTS ( HOLDER ) ;

RETURN .STATUS ;

END ;					! End of UAF$DISPLAY_RIGHTS_RECBUF


%SBTTL ' UAF$FIND_UIC  -  get uic from UAF record'

GLOBAL ROUTINE UAF$FIND_UIC =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Build an identifier fron the UIC in the current UAF record
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	IDENT is initialized
!
! ROUTINE VALUE:
!
!	Always true
!
! SIDE EFFECTS:
!
!	none
!--

FOUND_MATCH = TRUE;

IDENT[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
IDENT[UIC$V_GROUP]  = .RECBUF [UAF$W_GRP] ;
IDENT[UIC$V_MEMBER] = .RECBUF [UAF$W_MEM] ;

RETURN TRUE ;

END ;					! End of UAF$FIND_UIC


%SBTTL ' UAF$GRANT_IDENT  -  Add RDB holder record '

GLOBAL ROUTINE UAF$GRANT_IDENT: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Add a holder record to the rights data base for the specified
!	identifier.  This routine is invoked via the GRANT/IDENT command.
!
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	Command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	rights data base is modified
!
!--


LOCAL
    ID_NAME_DESC	: STATDESC,
    ID_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    USER_NAME_DESC	: STATDESC,
    USER_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;

BIND 
    HOLDER_VEC = HOLDER : VECTOR [2,LONG] ;

!
! First we will get the identifier name.
! This is a required parameter so it is guaranteed present
! We will use the rights data base to translate the name
!
CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC ) ;

CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  ID_NAME_BUFF );
ID_NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
ID_NAME_DESC[POINTER] = ID_NAME_BUFF ;

!
! The user id parameter is required so we are guaranteed
! that it is present.  We will get the parameter before finishing
! up with the ID name so that we have it in case we must signal an
! error
!
PARSE_WILD( SD_TOKEN2, TRUE ) ;
CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  USER_NAME_BUFF );
USER_NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
USER_NAME_DESC[POINTER] = USER_NAME_BUFF ;
HOLDER_VEC[1] = 0 ;

!
! Now finish up with the ID name 
! Convert the ID from ASCII to a longword format
!
STATUS = $ASCTOID ( NAME   = ID_NAME_DESC,
                    ID     = IDENT,
                    ATTRIB = 0 ) ;
IF NOT .STATUS
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_GRANTERR, 2, ID_NAME_DESC, USER_NAME_DESC, .STATUS);
	RETURN ;
	END ;

IF .IDENT[UIC$V_FORMAT] NEQ UIC$K_ID_FORMAT
   THEN
	BEGIN
	LIB$SIGNAL(UAF$_NOTIDFMT);
	RETURN ;
	END ;

IF (.IDENT LSSU UIC$K_FIRST_ID) OR
   (.IDENT GTRU UIC$K_LAST_ID)
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_IDOUTRNG);
	RETURN ;
	END ;

!
! Now finish parsing the user ID entered
! We will use the rights data base to translate the name
! unless it was given in UIC format.  If it is a UIC then
! we will build a holder and make sure that it is in the rights
! data base.
!
!
IF .UIC_FLAG
    THEN
	BEGIN
	LOCAL
	    TEMP_NAME_DESC	: STATDESC,
	    TEMP_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;
	IF NOT PARSE_UIC ( HOLDER[UIC$V_GROUP], 
	                   HOLDER[UIC$V_MEMBER], 
	                   TRUE )
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_UICERR, 2, .TOKENLEN, .TOKENPTR);
		RETURN ;
		END ;
	HOLDER[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
	!
	! Make sure that the holder exists and get it's ASCII name
	!
	TEMP_NAME_DESC[LENGTH]  = KGB$S_NAME ;
	TEMP_NAME_DESC[POINTER] = TEMP_NAME_BUFF ;
	STATUS = $IDTOASC ( ID     = .HOLDER_VEC[0],
	                    NAMLEN = TEMP_NAME_DESC[LENGTH], 
	                    NAMBUF = TEMP_NAME_DESC ) ;
	IF NOT .STATUS
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_GRANTERR, 2, ID_NAME_DESC, USER_NAME_DESC, .STATUS);
		RETURN ;
		END
	    ELSE
		BEGIN
		CH$COPY (.TEMP_NAME_DESC[LENGTH], .TEMP_NAME_DESC[POINTER],
		         %C' ', .USER_NAME_DESC[LENGTH], .USER_NAME_DESC[POINTER] ) ;
		USER_NAME_DESC[LENGTH] = .TEMP_NAME_DESC[LENGTH] ;
		END ;
	END
    ELSE
	BEGIN
	IF .STR_WILD
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_WLDNOTALWD);
		RETURN ;
		END ;

	!
	! Convert the user ID from ASCII to a longword format
	!
	STATUS = $ASCTOID ( NAME   = USER_NAME_DESC,
	                    ID     = HOLDER_VEC[0],
	                    ATTRIB = 0 ) ;
	IF NOT .STATUS
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_GRANTERR, 2, ID_NAME_DESC, USER_NAME_DESC, .STATUS);
		RETURN ;
		END ;
	
	IF .HOLDER[UIC$V_FORMAT] NEQ UIC$K_UIC_FORMAT
	   THEN
		BEGIN
		LIB$SIGNAL(UAF$_NOTUICFMT);
		RETURN ;
		END ;

	END ;


!
! Set the resource attribute if /RESOURCE was specified.
!
IF CLI$PRESENT (SD_ATTRIBRESOURCE)
    THEN ATTRIBUTES = KGB$M_RESOURCE
    ELSE ATTRIBUTES = 0 ;

!
! Now call the service to perform the addition
!
STATUS = $ADD_HOLDER ( ID     = .IDENT,
                       HOLDER = HOLDER ,
                       ATTRIB = .ATTRIBUTES ) ;

IF NOT .STATUS
    THEN LIB$SIGNAL(UAF$_GRANTERR, 2, ID_NAME_DESC, USER_NAME_DESC, .STATUS)
    ELSE 
	BEGIN
	RIGHTSLIST_MODIFIED = TRUE ;
	LIB$SIGNAL(UAF$_GRANTMSG, 2, ID_NAME_DESC, USER_NAME_DESC);
	END ;

RETURN ;

END ;					!End of UAF$GRANT_IDENT


%SBTTL ' UAF$RECORD_FOUND - Flag that the group is not empty'

GLOBAL ROUTINE UAF$RECORD_FOUND =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Flag that a particular group is not empty.  This is used to
!	determine if a group identifier should be removed.
!
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	FOUND_MATCH flag is set TRUE
!
! ROUTINE VALUE:
!
!	Always false so that the WILD_USER loop will be exited after first match
!
! SIDE EFFECTS:
!
!	none
!--


FOUND_MATCH = TRUE;

RETURN FALSE ;

END ;					! End of UAF$RECORD_FOUND


%SBTTL ' UAF$LIST_IDENT  -  Display rights identifiers '

GLOBAL ROUTINE UAF$LIST_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write all identifiers to a listing file.  This routine is invoked
!	via the LIST/IDENT command
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A listing file is created
!
!--


!
! Create the listing file
!
RLSTFAB [FAB$V_DLT] = FALSE ;
IF RMSBAD ($CREATE (FAB = RLSTFAB))
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_LSTERR, 0, .RMSERR);
	RETURN ;
	END ;

IF RMSBAD ( $CONNECT ( RAB = RLSTRAB))
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_LSTERR, 0, .RMSERR);
	RETURN ;
	END ;

!
! Set the correct RAB for the output and flag a list operation
!
RABPTR = RLSTRAB ;
RDB_LIST_FLAG = TRUE ;

!
! Set the type of display.
!
IF CLI$PRESENT (SD_BRIEF) OR (NOT CLI$PRESENT (SD_FULL))
    THEN SHOW_ID_FULL = FALSE
    ELSE SHOW_ID_FULL = TRUE ;

!
! Now call the common routine for show or list
!
UAF$DISPLAY_IDENT () ;

$DISCONNECT ( RAB = RLSTRAB ) ;
$CLOSE ( FAB = RLSTFAB ) ;

RETURN

END ;					! End of UAF$LIST_IDENT


%SBTTL ' UAF$LIST_RIGHTS - Display rights held by user'

GLOBAL ROUTINE UAF$LIST_RIGHTS : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write all identifiers held by a specified identifier
!	to a listing file.  This routine is invoked
!	via the LIST/RIGHTS command
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A listing file is created
!
!--


!
! Create the listing file
!
RLSTFAB [FAB$V_DLT] = FALSE ;
IF RMSBAD ($CREATE (FAB = RLSTFAB))
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_LSTERR, 0, .RMSERR);
	RETURN ;
	END ;

IF RMSBAD ( $CONNECT ( RAB = RLSTRAB))
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_LSTERR, 0, .RMSERR);
	RETURN ;
	END ;

!
! Select the output RAB and flag a list operation
!
RABPTR = RLSTRAB ;
RDB_LIST_FLAG = TRUE ;

!
! Call common routine to perform show or list
!
UAF$DISPLAY_RIGHTS () ;

$DISCONNECT ( RAB = RLSTRAB ) ;
$CLOSE ( FAB = RLSTFAB ) ;

RETURN ;

END ;					!End of UAF$LIST_RIGHTS


%SBTTL ' UAF$MODIFY_IDENT  -  Modify RDB record'

GLOBAL ROUTINE UAF$MODIFY_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Modify a rights data base record.  This routine is invoked
!	via the MODIFY/IDENT command.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	Rights data base is modified.
!
!--


LOCAL
    NAME_DESC		: STATDESC,
    NAME_BUFF		: VECTOR [ KGB$S_NAME, BYTE ] ,
    NEW_VALUE		: $BBLOCK [4],
    NEW_NAME_DESC	: STATDESC,
    NEW_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    NEW_NAME_PTR	: LONG ,
    OLD_IDENT		: $BBLOCK [4],
    CLR_ATTRIBUTES	: LONG INITIAL (0) ,
    SET_ATTRIBUTES	: LONG INITIAL (0) ;


!
! First we will get the identifier name.
! This is a required parameter so it is guaranteed present
!
CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC ) ;

CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  NAME_BUFF );
NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
NAME_DESC[POINTER] = NAME_BUFF ;

!
! Convert the ID from ASCII to a longword format
!
STATUS = $ASCTOID ( NAME   = NAME_DESC,
                    ID     = OLD_IDENT,
                    ATTRIB = 0 ) ;
IF NOT .STATUS
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, .STATUS);
	RETURN ;
	END ;

!
! Now find out what to do with the status attribute.
! If it is explicitly negated in the command line then
! clear it.  If it is present but not negated then set it.
! If it is not specified then do nothing
!
STATUS = CLI$PRESENT ( SD_ATTRIBRESOURCE ) ;
IF .STATUS EQL CLI$_NEGATED
    THEN CLR_ATTRIBUTES = KGB$M_RESOURCE
ELSE IF .STATUS
    THEN SET_ATTRIBUTES = KGB$M_RESOURCE ;


!
! Now get the new name if one was specified
!
IF CLI$GET_VALUE ( SD_NAME, TOKENDSC )
    THEN
	BEGIN
	NEW_NAME_PTR = NEW_NAME_DESC ;
	CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  NEW_NAME_BUFF );
	NEW_NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
	NEW_NAME_DESC[POINTER] = NEW_NAME_BUFF ;
	END
    ELSE NEW_NAME_PTR = 0 ;

!
! If a new ID was given then get it's value
!
IF NOT CLI$PRESENT ( SD_VALUE )
    THEN
	!
	! No new identifier value was specified
	!
	NEW_VALUE = 0

    ELSE
	BEGIN
	!
	! /VALUE is there now determine what keyword was used
	! and interpret the data as appropriate.
	! First check for IDENTIFIER:
	IF CLI$GET_VALUE ( SD_VALUEIDENTIFIER, TOKENDSC )
	    THEN
		BEGIN
		LOCAL
		    TMP_IDENT : LONG INITIAL (0) ;

		STATUS = GETVAL ( TMP_IDENT, LONGWORD_LENGTH );
		IF NOT .STATUS
		    THEN
			BEGIN
			LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, .STATUS);
			RETURN ;
			END ;
		NEW_VALUE [UIC$V_FORMAT]  = UIC$K_ID_FORMAT ;
		NEW_VALUE [UIC$V_ID_CODE] = .TMP_IDENT ;
		IF (.NEW_VALUE LSSU %X'80008000') OR
		   (.NEW_VALUE GTRU UIC$K_LAST_ID)
		    THEN
			BEGIN
			LIB$SIGNAL(UAF$_IDOUTRNG);
			RETURN ;
			END ;
		    END
	    ELSE 
		BEGIN
		!
		! Now check for UIC
		! These two keywords are synonyms
		!
		IF CLI$PRESENT (SD_VALUEUIC)
		    THEN IF NOT PARSE_WILD (SD_VALUEUIC, TRUE ) 
			THEN
			    BEGIN
			    LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, .STATUS);
			    RETURN ;
			    END ;
		IF .UIC_FLAG
		    THEN
			BEGIN
			IF .GRP_WILD AND NOT .MEM_WILD
			    THEN
				BEGIN
				!
				! Wild cards are not allowed for group numbers
				!
				LIB$SIGNAL(UAF$_NOGRPWILD);
				RETURN ;
				END ;
			!
			! The UIC format was used,  parse it to fine the
			! group and member number.
			! Wild card group and member numbers are allowed
			!
			IF NOT PARSE_UIC ( NEW_VALUE[UIC$V_GROUP],
					   NEW_VALUE[UIC$V_MEMBER],
					   TRUE )
			    THEN
				BEGIN
				LIB$SIGNAL(UAF$_UICERR, 2, .TOKENLEN, 
						.TOKENPTR);
				RETURN ;
				END ;
			NEW_VALUE[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
			END
		    ELSE
			BEGIN
			!
			! A user name was specified.  Get the UAF record
			! for this user and pull the UIC out.
			!
			IF .STR_WILD
			    THEN
				BEGIN
				!
				! Wild cards are not allowed for user specs
				!
				LIB$SIGNAL(UAF$_WLDNOTALWD);
				RETURN ;
				END ;
			FOUND_MATCH = FALSE ;
			IF RMSBAD ( WILD_USER (UAF$FIND_UIC))
			    THEN
				BEGIN
				IF .RMSERR EQL RMS$_RNF
				    THEN LIB$SIGNAL(UAF$_BADSPC)
				    ELSE LIB$SIGNAL(UAF$_RDBMDFYERR, 1, 
							NAME_DESC, .RMSERR) ;
				RETURN ;
				END ;
			!
			! UAF$FIND_UIC fills in IDENT
			!
			NEW_VALUE = .IDENT ;
			END ;

		END;

	END ;

!
! Finally find out if /HOLDER was specified.  If it was
! then get the owners UAF record and pull the UIC out of it.
! ALSO, if the qualifier was specified we will call the $MOD_HOLDER
! service instead of the $MOD_IDENT service
!
IF CLI$PRESENT ( SD_HOLDER )
    THEN
	BEGIN
	IF NOT PARSE_WILD (SD_HOLDER, FALSE ) 
	    THEN RETURN ;
	IF .UIC_FLAG
	    THEN
		BEGIN
		IF .GRP_WILD AND NOT .MEM_WILD
		    THEN
			BEGIN
			!
			! Wild cards are not allowed for group numbers
			!
			LIB$SIGNAL(UAF$_NOGRPWILD);
			RETURN ;
			END ;
		!
		! The UIC format was used,  parse it to fine the
		! group and member number.
		! Wild card group and member numbers are allowed
		!
		IF NOT PARSE_UIC ( IDENT[UIC$V_GROUP],
		                   IDENT[UIC$V_MEMBER],
		                   TRUE )
		    THEN
			BEGIN
			LIB$SIGNAL(UAF$_UICERR, 2, .TOKENLEN, .TOKENPTR);
			RETURN ;
			END ;
		IDENT[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
		END
	    ELSE
		BEGIN
		!
		! A user name was specified.  Get the UAF record
		! for this user and pull the UIC out.
		!
		IF .STR_WILD
		    THEN
			BEGIN
			!
			! Wild cards are not allowed for user specs
			!
			LIB$SIGNAL(UAF$_WLDNOTALWD);
			RETURN ;
			END ;
		FOUND_MATCH = FALSE ;
		IF RMSBAD ( WILD_USER (UAF$BUILD_HOLDER))
		    THEN
			BEGIN
			IF .RMSERR EQL RMS$_RNF
			    THEN LIB$SIGNAL(UAF$_BADSPC)
			    ELSE LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, 
						.RMSERR);
			RETURN ;
			END ;
		END ;
	STATUS = $MOD_HOLDER ( ID         = .IDENT,
	                       HOLDER     = HOLDER,
                               SET_ATTRIB = .SET_ATTRIBUTES,
                               CLR_ATTRIB = .CLR_ATTRIBUTES ) ;
	END
    ELSE
	STATUS = $MOD_IDENT ( ID         = .OLD_IDENT,
                              SET_ATTRIB = .SET_ATTRIBUTES,
                              CLR_ATTRIB = .CLR_ATTRIBUTES,
	                      NEW_NAME   = .NEW_NAME_PTR,
	                      NEW_VALUE  = .NEW_VALUE ) ;

IF NOT .STATUS
    THEN LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, .STATUS)
    ELSE
	BEGIN
	RIGHTSLIST_MODIFIED = TRUE ;
	LIB$SIGNAL(UAF$_RDBMDFYMSG, 1, NAME_DESC);
	END ;

RETURN ;
END ;					! End of UAF$MODIFY_IDENT


%SBTTL ' UAF$REMOVE_GRP_IDENT - Remove group identifier from RDB'

GLOBAL ROUTINE UAF$REMOVE_GRP_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to remove a group identifier from the rights data
!	base if there is no longer any in that group in the UAF.  
!
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain the UAF record which was just deleted.
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	rights data base is modified
!
!--


BIND
    UICMEMWLD	= CSTRING ('[!OW,*]') ;

LITERAL
    STR_BUFFLEN	= 20 ;

LOCAL
    FAO_DESC	: STATDESC ,
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    STR_DESC	: STATDESC ,
    STR_BUFF	: VECTOR [STR_BUFFLEN, BYTE ] ,
    WILD_IDENT	: $BBLOCK [4] ;

!
! Get the uic from the recbuf and build an identifier with it
! Also build a wild card member version.
!
UAF$FIND_UIC ();
WILD_IDENT[UIC$V_FORMAT] = .IDENT[UIC$V_FORMAT] ;
WILD_IDENT[UIC$V_GROUP]  = .IDENT[UIC$V_GROUP] ;
WILD_IDENT[UIC$V_MEMBER] = UIC$K_WILD_MEMBER ;

!
! Before we go any further see if the identifier even exists and get
! it's name
!
NAME_DESC[LENGTH]  = KGB$S_NAME ;
NAME_DESC[POINTER] = NAME_BUFF ;
IF NOT ( $IDTOASC ( ID     = .WILD_IDENT,
                    NAMLEN = NAME_DESC[LENGTH] ,
                    NAMBUF = NAME_DESC ) )
    THEN RETURN ;

!
! Now build an ascii UIC string that we can pass to PARSE_WILD_UIC
! After using this routine to parse the string we can use the standard
! method of reading the UAF (ie. WILD_USER )
!
FAO_DESC[LENGTH]  = .UICMEMWLD<0,8> ;
FAO_DESC[POINTER] = UICMEMWLD + 1 ;
STR_DESC[LENGTH]  = STR_BUFFLEN ;
STR_DESC[POINTER] = STR_BUFF ;
$FAO ( FAO_DESC, STR_DESC[LENGTH], STR_DESC, .WILD_IDENT[UIC$V_GROUP] ) ;

!
! Now set a global flag stating that the group is empty.  If WILD_USER
! finds any records it will call UAF$RECORD_FOUND which will change
! the state of the group empty flag and return a failure to WILD_USER.
! The failure code will cause WILD_USER to exit it's loop there by 
! stopping as soon as a single record is found.
!
PARSE_WILD_UIC ( .STR_DESC[LENGTH], .STR_DESC[POINTER] ) ;
FOUND_MATCH = FALSE ;
STATUS = WILD_USER ( UAF$RECORD_FOUND ) ;
IF RMSBAD ( .STATUS )
    THEN IF (.RMSERR NEQ RMS$_RNF) AND
            (.RMSERR NEQ FALSE )
	THEN LIB$SIGNAL(UAF$_RDBREMERR, 1, NAME_DESC, .RMSERR);

!
! Now if the flag is still set to false
! we can remove the identifier .
!
IF NOT .FOUND_MATCH
    THEN
	BEGIN

	STATUS = $REM_IDENT ( ID = .WILD_IDENT ) ;

	IF NOT .STATUS
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_RDBREMERR, 1, NAME_DESC, .STATUS);
		RETURN ;
		END
	    ELSE 
		BEGIN
		RIGHTSLIST_MODIFIED = TRUE ;
		IF .WILD_IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
		    THEN LIB$SIGNAL(UAF$_RDBREMMSGU, 3, NAME_DESC,
		                  .WILD_IDENT[UIC$V_GROUP],
		                  .WILD_IDENT[UIC$V_MEMBER])
		    ELSE LIB$SIGNAL(UAF$_RDBREMMSG, 2, NAME_DESC, .WILD_IDENT);
		END ;
	END ;

RETURN ;

END ;					! End of UAF$REMOVE_GRP_IDENT


%SBTTL ' UAF$REMOVE_IDENT - Remove identifier from RDB'

GLOBAL ROUTINE UAF$REMOVE_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to remove an identifier from the rights
!	data base.  It is invoked via the REMOVE/IDENT command.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	rights data base is modified
!
!--


!
! Get the ID name.  This is a required parameter so we are guaranteed
! that it will be present
!
CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC ) ;

!
! Convert the ID from ASCII to a longword format
!
STATUS = $ASCTOID ( NAME   = TOKENDSC,
                    ID     = IDENT,
                    ATTRIB = 0 ) ;

IF .STATUS
    THEN
	!
	! Now remove the entry
	!
	STATUS = $REM_IDENT ( ID = .IDENT ) ;

IF NOT .STATUS
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_RDBREMERR, 1, TOKENDSC, .STATUS);
	RETURN ;
	END
    ELSE 
	BEGIN
	RIGHTSLIST_MODIFIED = TRUE ;
	IF .IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
	    THEN LIB$SIGNAL(UAF$_RDBREMMSGU, 3, TOKENDSC,
	                  .IDENT[UIC$V_GROUP], .IDENT[UIC$V_MEMBER])
	    ELSE LIB$SIGNAL(UAF$_RDBREMMSG, 2, TOKENDSC, .IDENT);
	END ;

RETURN ;

END ;					! End of UAF$REMOVE_IDENT


%SBTTL ' UAF$REMOVE_IDENT_RECBUF - Remove identifier from RDB'

GLOBAL ROUTINE UAF$REMOVE_IDENT_RECBUF =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to remove an identifier from the rights data
!	base.  The identifier to be removed is determined by the UIC of
!	the UAF record in RECBUF
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RECBUF must contain a valid UAF record
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	Always true
!
! SIDE EFFECTS:
!
!	rights data base is modified
!--



BIND
    UICSTRING	= CSTRING ('[!OW,!OW]') ;

LITERAL
    STR_BUFFLEN	= 20 ;

LOCAL
    FAO_DESC	: STATDESC ,
    NAME_DESC	: STATDESC,
    NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    STR_DESC	: STATDESC ,
    STR_BUFF	: VECTOR [STR_BUFFLEN, BYTE ] ;

!
! Get the uic from the recbuf
!
UAF$FIND_UIC ();

!
! Before we go any further see if the identifier even exists and get
! it's name.  If it doesn't exist, skip right to the Group identifier
!
NAME_DESC[LENGTH]  = KGB$S_NAME ;
NAME_DESC[POINTER] = NAME_BUFF ;
IF ( $IDTOASC ( ID     = .IDENT,
                NAMLEN = NAME_DESC[LENGTH] ,
                NAMBUF = NAME_DESC ) )
    THEN
	BEGIN
	!
	! Now build an ascii UIC string that we can pass to PARSE_WILD_UIC
	! After using this routine to parse the string we can use the standard
	! method of reading the UAF (ie. WILD_USER )
	!
	FAO_DESC[LENGTH]  = .UICSTRING<0,8> ;
	FAO_DESC[POINTER] = UICSTRING + 1 ;
	STR_DESC[LENGTH]  = STR_BUFFLEN ;
	STR_DESC[POINTER] = STR_BUFF ;
	$FAO ( FAO_DESC, STR_DESC[LENGTH], STR_DESC, 
	      .IDENT[UIC$V_GROUP], .IDENT[UIC$V_MEMBER] ) ;
	
	!
	! Now set a global flag stating that the record was not found.  If WILD_USER
	! finds any records it will call UAF$RECORD_FOUND which will change
	! the state of the flag and return a failure to WILD_USER.
	! The failure code will cause WILD_USER to exit it's loop there by 
	! stopping as soon as a single record is found.
	!
	PARSE_WILD_UIC ( .STR_DESC[LENGTH], .STR_DESC[POINTER] ) ;
	FOUND_MATCH = FALSE ;
	STATUS = WILD_USER ( UAF$RECORD_FOUND ) ;
	IF RMSBAD ( .STATUS )
	    THEN IF (.RMSERR NEQ RMS$_RNF) AND
		    (.RMSERR NEQ FALSE )
		THEN LIB$SIGNAL(UAF$_RDBREMERR, 1, NAME_DESC, .RMSERR);
	
	!
	! Now if the found_match flag is still set to false
	! we can remove the identifier .
	!
	IF NOT .FOUND_MATCH
	    THEN
		BEGIN
	
		STATUS = $REM_IDENT ( ID = .IDENT ) ;
	
		IF NOT .STATUS
		    THEN
			BEGIN
			LIB$SIGNAL(UAF$_RDBREMERR, 1, NAME_DESC, .STATUS);
			RETURN TRUE ;
			END
		    ELSE 
			BEGIN
			RIGHTSLIST_MODIFIED = TRUE ;
			IF .IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
			    THEN LIB$SIGNAL(UAF$_RDBREMMSGU, 3, NAME_DESC,
					.IDENT[UIC$V_GROUP],
					.IDENT[UIC$V_MEMBER])
			    ELSE LIB$SIGNAL(UAF$_RDBREMMSG, 2, NAME_DESC, 
					.IDENT);
			END ;
		END ;
	END ;

!
! Scan the UAF and see if there is anyone left in this group.
! If no then delete the group's identifier.
!
UAF$REMOVE_GRP_IDENT () ;

RETURN TRUE ;

END ;					! End of UAF$REMOVE_IDENT_RECBUF


%SBTTL ' UAF$RENAME_IDENT  -  Modify RDB record'

GLOBAL ROUTINE UAF$RENAME_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to change the name of an identifier in the
!	rights data base.  It is invoked via the RENAME/IDENT command.
!	This routine performs the same function as the MODIFY/IDENT/NAME
!	command
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	rights data base is modified
!
!--


LOCAL
    NAME_DESC		: STATDESC,
    NAME_BUFF		: VECTOR [ KGB$S_NAME, BYTE ] ,
    NEW_NAME_DESC	: STATDESC,
    NEW_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;

IDENT = 0 ;

!
! First we will get the identifier name.
! This is a required parameter so it is guaranteed present
!
CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC ) ;

CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  NAME_BUFF );
NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
NAME_DESC[POINTER] = NAME_BUFF ;

!
! Convert the ID from ASCII to a longword format
!
STATUS = $ASCTOID ( NAME   = NAME_DESC,
                    ID     = IDENT,
                    ATTRIB = 0 ) ;
IF NOT .STATUS
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, .STATUS);
	RETURN ;
	END ;

!
! Now get the new name 
!

CLI$GET_VALUE ( SD_TOKEN2, TOKENDSC ) ;
CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  NEW_NAME_BUFF );
NEW_NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
NEW_NAME_DESC[POINTER] = NEW_NAME_BUFF ;

STATUS = $MOD_IDENT ( ID         = .IDENT,
		      NEW_NAME   = NEW_NAME_DESC ) ;

IF NOT .STATUS
    THEN LIB$SIGNAL(UAF$_RDBMDFYERR, 1, NAME_DESC, .STATUS)
    ELSE
	BEGIN
	RIGHTSLIST_MODIFIED = TRUE ;
	LIB$SIGNAL(UAF$_RDBMDFYMSG, 1, NAME_DESC);
	END ;

RETURN ;
END ;					! End of UAF$RENAME_IDENT



%SBTTL ' UAF$REVOKE_IDENT  -  Delete RDB holder record '

GLOBAL ROUTINE UAF$REVOKE_IDENT: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Remove a holder record from the rights data base for the specified
!	identifier.  This routine is invoked via the REVOKE/IDENT command.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	rights data base is modified
!
!--


BIND 
    HOLDER_VEC = HOLDER : VECTOR [2,LONG] ;

LOCAL
    ID_NAME_DESC	: STATDESC,
    ID_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ,
    USER_NAME_DESC	: STATDESC,
    USER_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;


!
! First we will get the identifier name.
! This is a required parameter so it is guaranteed present
! We will use the rights data base to translate the name
!
CLI$GET_VALUE ( SD_TOKEN1, TOKENDSC ) ;

CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  ID_NAME_BUFF );
ID_NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
ID_NAME_DESC[POINTER] = ID_NAME_BUFF ;

!
! The user id parameter is required so we are guaranteed
! that it is present.  We will get the parameter before finishing
! up with the ID name so that we have it in case we must signal an
! error
!
PARSE_WILD( SD_TOKEN2, TRUE ) ;
CH$COPY ( .TOKENLEN, .TOKENPTR, %C' ', KGB$S_NAME,  USER_NAME_BUFF );
USER_NAME_DESC[LENGTH]  = MIN ( .TOKENLEN , KGB$S_NAME ) ;
USER_NAME_DESC[POINTER] = USER_NAME_BUFF ;
HOLDER_VEC[1] = 0 ;

!
! Now finish up with the ID name 
! Convert the ID from ASCII to a longword format
!
STATUS = $ASCTOID ( NAME   = ID_NAME_DESC,
                    ID     = IDENT,
                    ATTRIB = 0 ) ;
IF NOT .STATUS
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_REVOKEERR, 2, ID_NAME_DESC, USER_NAME_DESC, .STATUS);
	RETURN ;
	END ;

IF .IDENT[UIC$V_FORMAT] NEQ UIC$K_ID_FORMAT
   THEN
	BEGIN
	LIB$SIGNAL(UAF$_NOTIDFMT);
	RETURN ;
	END ;

IF (.IDENT LSSU UIC$K_FIRST_ID) OR
   (.IDENT GTRU UIC$K_LAST_ID)
    THEN
	BEGIN
	LIB$SIGNAL(UAF$_IDOUTRNG);
	RETURN ;
	END ;

!
! Now finish parsing the user ID entered
! We will use the rights data base to translate the name
! unless it was given in UIC format.  If it is a UIC then
! we will build a holder and make sure that it is in the rights
! data base.
!
!
IF .UIC_FLAG
    THEN
	BEGIN
	LOCAL
	    TEMP_NAME_DESC	: STATDESC,
	    TEMP_NAME_BUFF	: VECTOR [ KGB$S_NAME, BYTE ] ;
	IF NOT PARSE_UIC ( HOLDER[UIC$V_GROUP], 
	                   HOLDER[UIC$V_MEMBER], 
	                   TRUE )
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_UICERR, 2, .TOKENLEN, .TOKENPTR);
		RETURN ;
		END ;
	HOLDER[UIC$V_FORMAT] = UIC$K_UIC_FORMAT ;
	!
	! Make sure that the holder exists
	!
	TEMP_NAME_DESC[LENGTH]  = KGB$S_NAME ;
	TEMP_NAME_DESC[POINTER] = TEMP_NAME_BUFF ;
	STATUS = $IDTOASC ( ID     = .HOLDER_VEC[0],
	                    NAMLEN = TEMP_NAME_DESC[LENGTH], 
	                    NAMBUF = TEMP_NAME_DESC ) ;
	IF NOT .STATUS
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_REVOKEERR, 2, ID_NAME_DESC, USER_NAME_DESC, 
				.STATUS);
		RETURN ;
		END
	    ELSE
		BEGIN
		CH$COPY (.TEMP_NAME_DESC[LENGTH], .TEMP_NAME_DESC[POINTER],
		         %C' ', .USER_NAME_DESC[LENGTH], .USER_NAME_DESC[POINTER] ) ;
		USER_NAME_DESC[LENGTH] = .TEMP_NAME_DESC[LENGTH] ;
		END ;
	END
    ELSE
	BEGIN
	IF .STR_WILD
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_WLDNOTALWD);
		RETURN ;
		END ;

	!
	! Convert the user ID from ASCII to a longword format
	!
	STATUS = $ASCTOID ( NAME   = USER_NAME_DESC,
	                    ID     = HOLDER_VEC[0],
	                    ATTRIB = 0 ) ;
	IF NOT .STATUS
	    THEN
		BEGIN
		LIB$SIGNAL(UAF$_REVOKEERR, 2, ID_NAME_DESC, USER_NAME_DESC, 
				.STATUS);
		RETURN ;
		END ;
	
	IF .HOLDER[UIC$V_FORMAT] NEQ UIC$K_UIC_FORMAT
	   THEN
		BEGIN
		LIB$SIGNAL(UAF$_NOTUICFMT);
		RETURN ;
		END ;

	END ;


!
! Now call the service to perform the addition
!
STATUS = $REM_HOLDER ( ID     = .IDENT,
                       HOLDER = HOLDER ) ;

IF NOT .STATUS
    THEN LIB$SIGNAL(UAF$_REVOKEERR, 2, ID_NAME_DESC, USER_NAME_DESC, .STATUS)
    ELSE
	BEGIN
	RIGHTSLIST_MODIFIED = TRUE ;
	LIB$SIGNAL(UAF$_REVOKEMSG, 2, ID_NAME_DESC, USER_NAME_DESC);
	END ;

RETURN ;

END ;					!End of UAF$REVOKE_IDENT


%SBTTL ' UAF$SHOW_IDENT  -  Display rights identifiers '

GLOBAL ROUTINE UAF$SHOW_IDENT : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write all identifiers to SYS$OUTPUT.  This routine is invoked
!	via the SHOW/IDENT command
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


!
! Set the correct RAB for the output and flag a show operation
!
RABPTR = OUTRAB ;
RDB_LIST_FLAG = FALSE ;

!
! Set the type of display.  This is the same no matter
! what parameters or qualifiers are used
!
IF CLI$PRESENT (SD_FULL) OR (NOT CLI$PRESENT (SD_BRIEF))
    THEN SHOW_ID_FULL = TRUE
    ELSE SHOW_ID_FULL = FALSE ;

!
! Now call the common routine for show or list
!
UAF$DISPLAY_IDENT () ;

RETURN

END ;					! End of UAF$SHOW_IDENT


%SBTTL ' UAF$SHOW_RIGHTS - Display rights held by user'

GLOBAL ROUTINE UAF$SHOW_RIGHTS : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write all identifiers held by a specified identifier
!	to SYS$OUTPUT.  This routine is invoked
!	via the SHOW/RIGHTS command
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	command line
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


!
! Select the output RAB and flag a show operation
!
RABPTR = OUTRAB ;
RDB_LIST_FLAG = FALSE ;

!
! Call common routine to perform show or list
!
UAF$DISPLAY_RIGHTS () ;

RETURN ;

END ;					!End of UAF$SHOW_RIGHTS


%SBTTL ' UAF$WRITE_HOLDERS - Display holders of specified ident'

ROUTINE UAF$WRITE_HOLDERS ( IDENT ) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write all holders of the specified identifier to the output
!	file.
!
! INPUTS:
!
!	IDENT	value of identifier to find holders of
!
! IMPLICIT INPUTS:
!
!	RABPTR must point to the output RAB
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	status of rights data base and write operations
!
! SIDE EFFECTS:
!
!	The output file is written to
!
!--


$ASSUME (KGB$S_NAME, EQL, 32 ) ; ! If length changes HOLDERLINE must also be fixed

LITERAL
    ATTRIB_BUFFLEN	= 15 ;

BIND
    HOLDERHEAD		= CSTRING ('    !32AF !AS') ,
    HOLDERLINE 		= CSTRING ('    !32AF !AS') ,
    HOLDER_VEC		= HOLDER : VECTOR [2,LONG] ;

LOCAL
    CONTINUE		: BYTE ,
    CONTEXT		: LONG INITIAL (0) ,
    ATTRIB_DESC		: STATDESC,
    ATTRIB_BUFF		: VECTOR [ ATTRIB_BUFFLEN, BYTE ] ,
    NAME_DESC		: STATDESC,
    NAME_BUFF		: VECTOR [ KGB$S_NAME, BYTE ] ,
    SD_ATTRIBUTES	: QUALSTR_DESC ('Attributes'),
    SD_HOLDER		: QUALSTR_DESC ('Holder'),
    SD_RESOURCE		: QUALSTR_DESC ('RESOURCE'),
    SD_NORESOURCE	: QUALSTR_DESC ('NORESOURCE') ;

STATUS = $FIND_HOLDER ( ID      = .IDENT,
                        HOLDER  = HOLDER,
                        ATTRIB  = ATTRIBUTES,
                        CONTXT  = CONTEXT ) ;
IF NOT .STATUS
    THEN
	BEGIN
	$FINISH_RDB ( CONTXT = CONTEXT ) ;
	IF .STATUS EQL SS$_NOSUCHID
	    THEN RETURN SS$_NORMAL
	    ELSE RETURN .STATUS ;
	END
    ELSE
	BEGIN
	!
	! Print a header
	!
	FAOMAC ( HOLDERHEAD,
	         .SD_HOLDER[LENGTH], .SD_HOLDER[POINTER],
	         SD_ATTRIBUTES ) ;
	END ;


!
! Loop until we find all the identifiers held by this guy
!
CONTINUE = TRUE ;
DO
    BEGIN
    !
    ! Init the name descriptor
    ! and find the ASCII name of the identifier
    !
    NAME_DESC[POINTER] = NAME_BUFF ;
    NAME_DESC[LENGTH]  = KGB$S_NAME ;
    CH$FILL ( %C' ', .NAME_DESC[LENGTH], .NAME_DESC[POINTER] ) ;
    STATUS = $IDTOASC ( ID     = .HOLDER_VEC[0],
                        NAMLEN = NAME_DESC[LENGTH],
                        NAMBUF = NAME_DESC ) ;

    !
    ! Build the attribute string
    !
    CH$FILL ( %C' ', ATTRIB_BUFFLEN, ATTRIB_BUFF ) ;
    ATTRIB_DESC[LENGTH]  = 0 ;
    ATTRIB_DESC[POINTER] = ATTRIB_BUFF ;
    IF ( .ATTRIBUTES AND KGB$M_RESOURCE )
	THEN
	    BEGIN
	    CH$MOVE ( .SD_RESOURCE[LENGTH], .SD_RESOURCE[POINTER],
	              ATTRIB_BUFF[.ATTRIB_DESC[LENGTH]] ) ;
	    ATTRIB_DESC[LENGTH] = 
	      .ATTRIB_DESC[LENGTH] + .SD_RESOURCE[LENGTH] + 1 ;
	    END
	ELSE
	    BEGIN
	    CH$MOVE ( .SD_NORESOURCE[LENGTH], .SD_NORESOURCE[POINTER],
	              ATTRIB_BUFF[.ATTRIB_DESC[LENGTH]] ) ;
	    ATTRIB_DESC[LENGTH] = 
	      .ATTRIB_DESC[LENGTH] + .SD_NORESOURCE[LENGTH] + 1 ;
	    END ;

    !
    ! Output the line
    !
    FAOMAC ( HOLDERLINE, 
             .NAME_DESC[LENGTH], .NAME_DESC[POINTER],	! Identifier name
             ATTRIB_DESC ) ;				! Attributes

    STATUS = $FIND_HOLDER ( ID      = .IDENT,
                            HOLDER  = HOLDER,
                            ATTRIB  = ATTRIBUTES,
                            CONTXT  = CONTEXT ) ;
    IF NOT .STATUS
	THEN 
	    BEGIN
	    CONTINUE = FALSE ;
	    IF .STATUS EQL SS$_NOSUCHID
		THEN STATUS = SS$_NORMAL ;
	    END ;
		
    END
WHILE .CONTINUE;

$FINISH_RDB ( CONTXT = CONTEXT ) ;

RETURN .STATUS ;

END ;					! End of UAF$WRITE_HOLDERS


%SBTTL ' UAF$WRITE_IDENT - Display identifiers'

ROUTINE UAF$WRITE_IDENT ( START_IDENT, FULLFLAG, WILD_CARD ) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write specified identifier(s) to the oupput file
!
! INPUTS:
!
!	START_IDENT	value of identifier to be displayed or
!			-1 if all identifiers are to be displayed.
!	FULLFLAG	flag specifying if a full or brief listing
!			should be created
!	WILD_CARD	This is a wild card display
!
! IMPLICIT INPUTS:
!
!	RDB_HEADER_FLAG = true if header is to be output else false
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	status of RDB and write operations
!
! SIDE EFFECTS:
!
!	The output file is written to
!
!--


$ASSUME (KGB$S_NAME, EQL, 32 ) ; ! If length changes IDENTLINE must also be fixed

LITERAL
    ATTRIB_BUFFLEN	= 15 ;

BIND
    IDENTHEAD		= CSTRING ('  !32AF !15AF !AS') ,
    IDENTLINE 		= CSTRING ('  !32AF %X!XL      !AS') ,
    IDENTLINEU		= CSTRING ('  !32AF [!OW,!OW] !AS') ;

LOCAL
    CONTEXT		: LONG INITIAL (0) ,
    ATTRIB_DESC		: STATDESC,
    ATTRIB_BUFF		: VECTOR [ ATTRIB_BUFFLEN, BYTE ] ,
    NAME_DESC		: STATDESC,
    NAME_BUFF		: VECTOR [ KGB$S_NAME, BYTE ] ,
    RESULT_ID		: $BBLOCK [4] ,
    SD_ATTRIBUTES	: QUALSTR_DESC ('Attributes'),
    SD_NAME		: QUALSTR_DESC ('Name'),
    SD_RESOURCE		: QUALSTR_DESC ('RESOURCE'),
    SD_NORESOURCE	: QUALSTR_DESC ('NORESOURCE') ,
    SD_VALUE		: QUALSTR_DESC ('Value') ;

RESULT_ID = 0 ;
IDENT = 0 ;

NAME_DESC[POINTER] = NAME_BUFF ;
NAME_DESC[LENGTH]  = KGB$S_NAME ;
STATUS = $IDTOASC ( ID      = .START_IDENT,
                    NAMLEN  = NAME_DESC[LENGTH] ,
                    NAMBUF  = NAME_DESC ,
                    RESID   = RESULT_ID ,
                    ATTRIB  = ATTRIBUTES ,
                    CONTXT  = CONTEXT ) ;
IF NOT .STATUS
    THEN
	BEGIN
	$FINISH_RDB ( CONTXT = CONTEXT ) ;
	RETURN .STATUS ;
	END
    ELSE IF .RDB_HEADER_FLAG
	THEN
	    BEGIN
	    !
	    ! Print a header
	    !
	    FAOMAC ( IDENTHEAD,
		     .SD_NAME[LENGTH], .SD_NAME[POINTER],
		     .SD_VALUE[LENGTH], .SD_VALUE[POINTER],
		     SD_ATTRIBUTES ) ;
	    RDB_HEADER_FLAG = FALSE ;
	    END ;


!
! Loop until we find all the identifiers 
!
DO
    BEGIN

    !
    ! Build the attribute string
    !
    CH$FILL ( %C' ', ATTRIB_BUFFLEN, ATTRIB_BUFF ) ;
    ATTRIB_DESC[LENGTH]  = 0 ;
    ATTRIB_DESC[POINTER] = ATTRIB_BUFF ;
    IF ( .ATTRIBUTES AND KGB$M_RESOURCE )
	THEN
	    BEGIN
	    CH$MOVE ( .SD_RESOURCE[LENGTH], .SD_RESOURCE[POINTER],
	              ATTRIB_BUFF[.ATTRIB_DESC[LENGTH]] ) ;
	    ATTRIB_DESC[LENGTH] = 
	      .ATTRIB_DESC[LENGTH] + .SD_RESOURCE[LENGTH] + 1 ;
	    END
	ELSE
	    BEGIN
	    CH$MOVE ( .SD_NORESOURCE[LENGTH], .SD_NORESOURCE[POINTER],
	              ATTRIB_BUFF[.ATTRIB_DESC[LENGTH]] ) ;
	    ATTRIB_DESC[LENGTH] = 
	      .ATTRIB_DESC[LENGTH] + .SD_NORESOURCE[LENGTH] + 1 ;
	    END ;

    !
    ! Output the line
    !
    IF .RESULT_ID[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
	THEN
	    FAOMAC ( IDENTLINEU, 
	             .NAME_DESC[LENGTH],
	             .NAME_DESC[POINTER],	! Identifier name
	             .RESULT_ID[UIC$V_GROUP],	! Group number
	             .RESULT_ID[UIC$V_MEMBER],	! member number
	             ATTRIB_DESC )		! Attributes
	ELSE
	    FAOMAC ( IDENTLINE, 
	             .NAME_DESC[LENGTH],
	             .NAME_DESC[POINTER],	! Identifier name
	             .RESULT_ID,		! Identifier value
	             ATTRIB_DESC ) ;		! Attributes
    !
    ! If this is a show /FULL then list this guys holders
    !
    IF .FULLFLAG
	THEN
	    BEGIN
	    STATUS = UAF$WRITE_HOLDERS ( .RESULT_ID ) ;
	    IF NOT .STATUS
		THEN
		    BEGIN
		    $FINISH_RDB ( CONTXT = CONTEXT ) ;
		    RETURN .STATUS ;
		    END ;
	    END ;


    NAME_DESC[LENGTH]  = KGB$S_NAME ;
    STATUS = $IDTOASC ( ID      = .START_IDENT,
                        NAMLEN  = NAME_DESC[LENGTH] ,
                        NAMBUF  = NAME_DESC ,
                        RESID   = RESULT_ID ,
                        ATTRIB  = ATTRIBUTES ,
                        CONTXT  = CONTEXT ) ;
    IF (NOT .STATUS) AND
       (.STATUS NEQ SS$_NOSUCHID )
        THEN
	    BEGIN
	    $FINISH_RDB ( CONTXT = CONTEXT ) ;
	    RETURN .STATUS ;
	    END ;
    END
!
! Only continue looping if we are dealing with a wild card
!
WHILE ( .STATUS ) AND ( .WILD_CARD ) ;

$FINISH_RDB ( CONTXT = CONTEXT ) ;

RETURN TRUE ;

END ;					! End of UAF$WRITE_IDENT


%SBTTL ' UAF$WRITE_RIGHTS - Display rights held by user'

GLOBAL ROUTINE UAF$WRITE_RIGHTS ( HOLDER_ADDR ) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display all identifiers held by the specified identifier
!
! INPUTS:
!
!	HOLDER	address of a quadword holder constructed from the id
!		value of the identifier.
!
! IMPLICIT INPUTS:
!
!	RDB_HEADER_FLAG = true if a header is to be output, else false.
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	The output file is written to
!
!--


$ASSUME (KGB$S_NAME, EQL, 32 ) ; ! If length changes RIGHTSLINE must also be fixed

LITERAL
    ATTRIB_BUFFLEN	= 15 ;

BIND
    RIGHTSHEAD1		= CSTRING ('!34AF !15AF !AS') ,
    RIGHTSHEAD2		= CSTRING ('Identifiers held by !AS : ') ,
    RIGHTSLINE 		= CSTRING ('  !32AF %X!XL      !AS') ,
    RIGHTSLINEU		= CSTRING ('  !32AF [!OW,!OW] !AS') ;

LOCAL
    CONTINUE		: BYTE ,
    CONTEXT		: LONG INITIAL (0) ,
    ATTRIB_DESC		: STATDESC,
    ATTRIB_BUFF		: VECTOR [ ATTRIB_BUFFLEN, BYTE ] ,
    NAME_DESC		: STATDESC,
    NAME_BUFF		: VECTOR [ KGB$S_NAME, BYTE ] ,
    SD_ATTRIBUTES	: QUALSTR_DESC ('Attributes'),
    SD_NAME		: QUALSTR_DESC ('Identifier'),
    SD_RESOURCE		: QUALSTR_DESC ('RESOURCE'),
    SD_NORESOURCE	: QUALSTR_DESC ('NORESOURCE') ,
    SD_VALUE		: QUALSTR_DESC ('Value') ;

STATUS = $FIND_HELD ( HOLDER  = .HOLDER_ADDR,
                      ID      = IDENT,
                      ATTRIB  = ATTRIBUTES,
                      CONTXT  = CONTEXT ) ;
IF NOT .STATUS
    THEN
	BEGIN
	$FINISH_RDB ( CONTXT = CONTEXT ) ;
	IF .STATUS EQL SS$_NOSUCHID
	    THEN STATUS = SS$_NORMAL ;
	RETURN .STATUS ;
	END

    ELSE
	BEGIN
	!
	! Init the name descriptor
	! and find the ASCII name of the holder
	!
	NAME_DESC[POINTER] = NAME_BUFF ;
	NAME_DESC[LENGTH]  = KGB$S_NAME ;
	CH$FILL ( %C' ', .NAME_DESC[LENGTH], .NAME_DESC[POINTER] ) ;
	STATUS = $IDTOASC ( ID     = ..HOLDER_ADDR,
	                    NAMLEN = NAME_DESC[LENGTH],
	                    NAMBUF = NAME_DESC ) ;
	!
	! Print a header
	!
	IF .RDB_HEADER_FLAG
	    THEN
		BEGIN
		FAOMAC ( RIGHTSHEAD1,
			 .SD_NAME[LENGTH], .SD_NAME[POINTER],
			 .SD_VALUE[LENGTH], .SD_VALUE[POINTER],
			 SD_ATTRIBUTES ) ;
		RDB_HEADER_FLAG = FALSE ;
		END ;
	IF .STR_WILD OR .MEM_WILD OR .GRP_WILD THEN
	    FAOMAC ( RIGHTSHEAD2, NAME_DESC ) ;
	END ;


!
! Loop until we find all the identifiers held by this guy
!
CONTINUE = TRUE ;
DO
    BEGIN
    !
    ! Init the name descriptor
    ! and find the ASCII name of the identifier
    !
    NAME_DESC[POINTER] = NAME_BUFF ;
    NAME_DESC[LENGTH]  = KGB$S_NAME ;
    CH$FILL ( %C' ', .NAME_DESC[LENGTH], .NAME_DESC[POINTER] ) ;
    STATUS = $IDTOASC ( ID     = .IDENT,
                        NAMLEN = NAME_DESC[LENGTH],
                        NAMBUF = NAME_DESC ) ;

    !
    ! Build the attribute string
    !
    CH$FILL ( %C' ', ATTRIB_BUFFLEN, ATTRIB_BUFF ) ;
    ATTRIB_DESC[LENGTH]  = 0 ;
    ATTRIB_DESC[POINTER] = ATTRIB_BUFF ;
    IF ( .ATTRIBUTES AND KGB$M_RESOURCE )
	THEN
	    BEGIN
	    CH$MOVE ( .SD_RESOURCE[LENGTH], .SD_RESOURCE[POINTER],
	              ATTRIB_BUFF[.ATTRIB_DESC[LENGTH]] ) ;
	    ATTRIB_DESC[LENGTH] = 
	      .ATTRIB_DESC[LENGTH] + .SD_RESOURCE[LENGTH] + 1 ;
	    END
	ELSE
	    BEGIN
	    CH$MOVE ( .SD_NORESOURCE[LENGTH], .SD_NORESOURCE[POINTER],
	              ATTRIB_BUFF[.ATTRIB_DESC[LENGTH]] ) ;
	    ATTRIB_DESC[LENGTH] = 
	      .ATTRIB_DESC[LENGTH] + .SD_NORESOURCE[LENGTH] + 1 ;
	    END ;

    !
    ! Output the line
    !
    IF .IDENT[UIC$V_FORMAT] EQL UIC$K_UIC_FORMAT
	THEN
	    FAOMAC ( RIGHTSLINE, 
	             .NAME_DESC[LENGTH],
	             .NAME_DESC[POINTER],	! Identifier name
	             .IDENT[UIC$V_GROUP],	! Group number
	             .IDENT[UIC$V_MEMBER],	! Member number
	             ATTRIB_DESC ) 		! Attributes
	ELSE
	    FAOMAC ( RIGHTSLINE, 
	             .NAME_DESC[LENGTH],
	             .NAME_DESC[POINTER],	! Identifier name
	             .IDENT,			! Identifier value
	             ATTRIB_DESC ) ;		! Attributes

    STATUS = $FIND_HELD ( HOLDER  = .HOLDER_ADDR,
                          ID      = IDENT,
                          ATTRIB  = ATTRIBUTES,
                          CONTXT  = CONTEXT ) ;
    IF NOT .STATUS
	THEN
	    BEGIN
	    CONTINUE = FALSE ;
	    IF .STATUS EQL SS$_NOSUCHID
		THEN STATUS = SS$_NORMAL ;
	    END ;
    END
WHILE .CONTINUE ;

$FINISH_RDB ( CONTXT = CONTEXT ) ;

RETURN .STATUS ;

END ;					! End of UAF$WRITE_RIGHTS

END					! End of module
ELUDOM
