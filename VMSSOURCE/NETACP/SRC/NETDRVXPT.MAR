	.TITLE	NETDRVXPT - NETDRIVER Transport (Routing) Layer
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS NETDRIVER
;
; ABSTRACT:
;
;	This module implements the DECnet Transport packet switching function.
;
; AUTHOR:
;
;	A.ELDRIDGE	1-May-82
;
; MODIFIED BY:
;
;	V03-039	RNG0039		Rod Gamache	24-Mar-1984
;		Enable check of ACP activity timer. Disable all transmit
;		operations if the NETACP process has stalled.
;
;	V03-038	PRB0318		Paul Beck	8-Mar-1984  18:19
;		Add TEST_ADJ to return true/false indication of whether a
;		node address represents a node which is one hop distant.
;
;	V03-037	RNG0037		Rod Gamache		02-Mar-1984
;		Disable check of ACP activity timer.
;
;	V03-036	ADE0001		Alan D. Eldridge	14-Feb-1984
;		Remove all trace of the "DLE" support.
;		Add count of entries added to AQB work queue.
;
;	V03-035	RNG0035		Rod Gamache	27-Jan-1984
;		Fix problem with Transport not resetting the CXB type
;		when system resources are being depleted.
;
;	V03-034	RNG0034		Rod Gamache	14-Nov-1983
;		Fix problem in connecting a Phase IV endnode to a
;		Phase III node, don't build a Phase IV route header
;		on packets transmitted.
;		Fix PSI problem that crashes system when the system
;		resources (CXBs) are being depleted.
;
;	V03-033	RNG0033		Rod Gamache	11-Jul-1983
;		Add support for cluster group address.
;
;	V03-032	TMH0032		Tim Halvorsen	08-Jun-1983
;		Fix erroneous check which prevented reception of Phase II
;		route headers (currently only known to be sent by DECnet-2020).
;		Fix case where garbaged message which looks like a data msg
;		is received on a point-to-point circuit which hasn't yet been
;		node inited.  We were assuming that the ADJ was valid and
;		crashing when referencing the ADJ block.
;
;	V03-031	RNG0031		Rod Gamache	01-Jun-1983
;		Fix solicit to PH3N, which was preventing any logical links
;		to an adjacent PH3N node.
;
;	V03-030	TMH0030		Tim Halvorsen	26-May-1983
;		Fix setting of Intra-NI flag.  We were always setting
;		the flag, even in the route-thru case, which told endnodes
;		that nodes were on the NI, even when they weren't,
;		and causing connectivity problems.
;		Replace code which sets the Intra-NI flag 0/1 by figuring
;		out who the source and destination are.  The replaced code
;		uses a simple test of input=output LPD to clear the intra-NI
;		flag and assumes that all other nodes originate their NI
;		packets with the flag set.  (This code was written in the
;		previous modification, but left commented out).
;
;	V03-029	RNG0029		Rod Gamache	05-May-1983
;		Only enter node addresses into the CACHE which are
;		received with the Inta-Ethernet bit set. Remove all
;		settings of the Intra-Ethernet bit (NEW CODE WRITTEN,
;		BUT ACTUAL REMOVAL IS DEFERRED). Fix route through code
;		on endnodes to simply return the packet, rather than
;		generate a Packet Format Error.
;
;	V03-028	RNG0028		Rod Gamache	02-May-1983
;		Fix the RTS code for sending to Phase III nodes from other
;		areas. Clean up reception of Broadcast Endnode Hellos.
;
;	V03-027	RNG0027		Rod Gamache	30-Apr-1983
;		Don't send messages from other areas to Phase III endnodes.
;		Check BIT6 in route header flags byte (must be zero).
;		Update LISTENER TIMER on hello message only if it is a
;		Broadcast Circuit.
;		Don't send message to Endnode if the destination address is
;		not the Endnode's.
;
;	V03-026	RNG0026		Rod Gamache	20-Apr-1983
;		Do not send the area number in hello messages to Phase
;		III nodes. Fix sending hello messages on endnodes.
;
;	V03-025	RNG0025		Rod Gamache	01-Apr-1983
;		Only check HIORD when delivering a packet to the ECL
;		layer or when converting the packet to short format.
;		Only set the Intra-NI flag header bit when: the message
;		is received from the sender and the output ADJ is the
;		destination and the input LPD and output LPD are the
;		same BC circuit. Also only set when the Input and Output
;		areas are the same as our own (multi-area NIs).
;		Do not allow messages from other areas to be sent to
;		Phase III routers.
;
;	V03-024	RNG0024		Rod Gamache	14-Mar-1983
;		Start building the XPT pad bytes for datalinks that
;		require padding.
;		Do not use AOA vector if we are an isolated area router.
;		Make the reachability code a general subroutine.
;		Conform to change in RHEL and EHEL Hello Timer field.
;
;	V03-023	RNG0023		Rod Gamache	10-Mar-1983
;		Make XPT pad byte count inclusive of the byte count
;		byte.
;
;	V03-022	TMH0022		Tim Halvorsen	14-Feb-1983
;		Get datalink buffer size from cell in the LPD rather
;		than computing it from RCB value.  This allows different
;		datalinks to have different buffer sizes because of their
;		different size Transport route headers.
;		If NSP requests a transmit to a specific LPD, and gives
;		a remote node address (not a loopback address) as well,
;		then lookup the correct ADJ and use that, rather than
;		sending the message to an arbitrary BC adjacency.
;		Add code to parse the variable length pad field at front
;		of received messages.
;
;	V03-021	TMH0021		Tim Halvorsen	21-Jan-1983
;		Fix route-thru not to destroy the address of the LPD we
;		initially received the packet on, so that any errors in
;		return-to-sender are logged with a consistent LPD address.
;		Change all checks for endnodes to use $DISPATCH macro to
;		include Phase III endnode case.
;		Fix support of loop nodes over broadcast circuits on which
;		our node is the designated router. Also fix loop nodes on
;		endnodes which have the LPD set to loopback.
;
;	V03-020	RNG0020		Rod Gamache	18-Jan-1983
;		Cleanup the cache timeout handling to work properly in all
;		cases.
;
;	V03-019	TMH0019		Tim Halvorsen	18-Jan-1983
;		Fix bug in endnode solicit, so that messages destined
;		for ourself don't go to the designated router.
;		Exclude RTS messages from addition to the endnode cache,
;		since in an RTS message, the source address isn't really
;		valid.
;
;	V03-018	RNG0018		Rod Gamache	11-Jan-1983
;		Move cache handling routine to Route Header processing
;		routine. Fix Endnode problem for connecting to node 0
;		when the only circuit is turned off. Use symbols for
;		computing number of nodes to scan in a 1 second interval.
;		Add code to deallocate the LPD CACHE table.
;
;	V03-017	RNG0017		Rod Gamache	06-Jan-1983
;		Fix cache table handling and fix RTS code for route-thru
;		case.
;
;	V03-016	RNG0016		Rod Gamache	30-Nov-1982
;		Fix MOP LOOPBACK to not build a route header.
;		Add the ENDNODE CACHE to ENDNODE support.
;		Do not decrement IRPCNT when queuing CRD message
;		to NETACP, so that LPD activity is stopped until
;		the CRD message is received and processed by NETACP.
;
;	V03-015	RNG0015		Rod Gamache	29-Nov-1982
;		Fix massive bugs in LOOPBACK code.
;
;	V03-014	RNG0014		Rod Gamache	07-Oct-1982
;		Add support for Phase IV area routing.
;		Fix bug in processing of Phase II route headers,
;		which caused the source address in the CXB to be
;		left zero, causing replies to be sent to the wrong
;		node.
;		Fix two bugs which prevented STATE SHUT from working.
;		Use new long format data message header. Add return
;		to sender path for NSP.
;
;	V03-013	RNG0013		Rod Gamache	24-Sep-1982
;		Add support for Phase IV endnodes.
;
;	V03-012	TMH0012		Tim Halvorsen	14-Sep-1982
;		Fix CRC16 checks to avoid CRC instruction if the message
;		length is 0-2, and signal an error immediately (short
;		message size).
;		Don't pre-allocate IRPs up to the "maximum buffers"
;		limit, but instead only allocate IRPs when you need
;		them.
;		On each timer tick, dynamically reduce the size of
;		the IRP_FREE list, so that the list slowly reacts
;		to reduced traffic through the node, and always converges
;		to the optimum number of IRPs needed.
;		Add support for journalling Transport I/O.
;
;	V03-011 RNG0004		Rod N. Gamache	08-Sep-1982
;		Fix sending of Phase II NOP messages, to not skip the 6
;		bytes of header.
;
;	V03-010	RNG0003		Rod N. Gamache	02-Sep-1982
;		Fix all error returns to NETACP to return the packet
;		size. Set up ADJ pointer in WQE before checking the
;		CRC on X.25 circuits.
;
;	V03-009	RNG0002		Rod N. Gamache	20-Aug-1982
;		If we are the designated router on a Broadcast Circuit,
;		then send a "Broadcast Endnode Hello" message when the
;		"Broadcast Router Hello" message is sent.
;
;	V03-008	RNG0001		Rod N. Gamache	13-Jul-1982
;		Add Phase IV support to transport.
;
;--

;
;  EXTERNAL SYMBOLS
;
	$ADJDEF			; Adjacency control block definitions
	$AQBDEF			; ACP Queue Block
	$CADEF			; Conditionally turn on performance monitoring
	$CXBDEF			; Network receive block definitions
	$DYNDEF			; Block type definitions
	$FKBDEF			; Fork Block Definitions
	$IPLDEF			; Define interrupt priority levels
	$IRPDEF			; I/O Request Packet
	$VADEF			; Virtual address symbols
	$XMDEF			; DMC-11 Driver symbols

	$NETSYMDEF		; Miscellaneous symbols
	$NETMSGDEF		; ACP receive buffer symbols
	$NETUPDDEF		; LPD 'update' function codes
	$NSPMSGDEF		; NSP and TR message definitions
	
	$CXBEXTDEF		; NETDRIVER extensions to the CXB

	$LPDDEF			; Logical Path Descriptor
	$RCBDEF			; Routining Control Block
	$WQEDEF			; Work Queue Element	


;
; LOCAL SYMBOLS
;
	RETRY_TIMER	= 4	; Error retry time on hello msg transmission
				;  or listener timeout notification failure
	HELLO_MSG_SIZE	= 34+2	; Size of worst case hello msg + 2 spare bytes
				;    Fixed size of BC router hello msg is 27
				;    Fixed size of BC endnode hello msg is 34
				;    Fixed size of non-BC hello msg is 6
	XPT_C_CACHETIMER = 10	; Check cache timeout every 10 seconds
	XPT_C_CACHETIMEOUT = 70	; Purge cache entry after 70 seconds of inactivity
	MAX_NODES	= 1024	; Node data base has 1024 nodes maximum
	NODES_PER_PASS	= 256	; Nodes to process per pass (1 second interval)
	NODE_SHIFT	= 0	; Shift value for nodes per pass (initial value)
	;
	; Compute real node shift value. 
	; Calculate NODE_SHIFT as LOG base 2 of NODES_PER_PASS
	;	
	TEMP = NODES_PER_PASS	; Initialize temporary value
	.REPT	10		; Repeat for 2**10 (1024) max value
	.IIF LT TEMP-2, .MEXIT	; Exit if all done
	TEMP=TEMP@-1		; Else, shift again
	NODE_SHIFT=NODE_SHIFT+1	; Compute log
	.ENDR			; Go again
	

	IRP$Q_STATION = IRP$Q_NT_PRVMSK

	JNX$$$ = 1		; Enables journalling

;
; MACROS
;
.MACRO	INCPMS	PMS_CELL		; Increment PMS cell
					;
	.IF DF	CA$_MEASURE		;
	.IF NE	CA$_MEASURE		; Conditional assembly
		INCL G^PMS$GL_'PMS_CELL'; Bump the counter
	.ENDC				;
	.ENDC				;
.ENDM	INCPMS				; 


	.PSECT	$$$115_DRIVER,LONG,EXE,RD,WRT	; Goto code PSECT

;
; Define polynomial table for calculating CRC16 on X.25 datagrams.
;
CRC16:	.LONG	^X00000000
	.LONG	^X0000CC01
	.LONG	^X0000D801
	.LONG	^X00001400
	.LONG	^X0000F001
	.LONG	^X00003C00
	.LONG	^X00002800
	.LONG	^X0000E401
	.LONG	^X0000A001
	.LONG	^X00006C00
	.LONG	^X00007800
	.LONG	^X0000B401
	.LONG	^X00005000
	.LONG	^X00009C01
	.LONG	^X00008801
	.LONG	^X00004400


	.SBTTL	TR$UPDATE	- Initiate receive sequence on data link

;+
;  TR$UPDATE  -	Update according to datalink state transition
;
;
;  For R0 = NETUPD$_DLL_ON
;
;  Allocate and initialize a "receive" IRP for a particular LPD and introduce
;  it into the network pool.  This operation happens once each time an LPD
;  becomes available for network traffic. If we are an endnode, allocate the
;  endnode cache table for the LPD.
;
;
;  For R0 = NETUPD$_REACT_RCV
;
;  A suspended receive IRP may be reactivated.  This interface is used to
;  restart the receiver which was stalled due to a receive buffer needing
;  to be passed to NETACP while the XM$V_STS_BUFFAIL bit was set in the IRP.
;  NETACP attaches the receive buffer to IRP$L_SVAPTE before calling this
;  routine.
;
;
;  For R0 = NETUPD$_SEND_HELLO
;
;  The NETACP wishes to inform other uses of the establishment of 2-way
;  communication on a broadcast circuit. The TRANSPORT layer with send out
;  a HELLO message immediately instead of waiting for the HELLO TIMER.
;
;  For R0 = NETUPD$_TEST_ADJ 
;
;  The NETACP wants to know if a node specified by a node address can be found
;  in the endnode cache (i.e. is it one hop distant?).
;
;
;  INPUTS:	R5	NETDRIVER UCB pointer
;		R4,R3	Scratch
;		R2	RCB pointer
;		R1	LPD pointer
;		R0	Dispatch code (scratch)
;
;  OUTPUTS:	R5	Preserved
;		R4,R3	Garbage
;		R2,R1	Preserved
;		R0	LBS if successful, else LBC
;
;-
TR$UPDATE::					; Update LPD
	$DISPATCH R0,TYPE=W,-			; Dispatch on fuction request
	<-
		<NETUPD$_DLL_ON	 INIT_RCV>,-	; Datalink starting
		<NETUPD$_REACT_RCV REACT_RCV>,-	; Reactivate a receiver
		<NETUPD$_SEND_HELLO SEND_HELLO>,-; Send a hello msg
		<NETUPD$_GET_ADJ GET_OUT_ADJ>,-	; Get ADJ address for output
		<NETUPD$_TEST_ADJ TEST_ADJ>,-	; Test if node is 1 hop away
	>
	CLRL	R0				; All others - indicate error
	RSB					; Return to caller

TEST_ADJ:
	PUSHR	#^M<R1,R3,R6,R7,R8,R9>		; Save registers
	CMPB	RCB$B_ETY(R2),#ADJ$C_PTY_PH4N	; Is this an endnode?
	BNEQ	10$				; If NEQ, bug (shouldn't be called)
	CLRL	R3				; No LPD wanted here
	BSBW	TR$GET_ADJ			; Get the output ADJ
	BLBC	R0,10$				; If LBC, not even reachable
	TSTL	R9				; paranoia check
	BEQL	10$				; If no ADJ, not reachable
	;
	;   R8 -> LPD, R9 -> ADJ for the path to this node.
	;   
	;   Non-broadcast circuits: we can compare the node address with the
	;   address in the ADJ to see if we're one hop away.
	;
	;   Broadcast circuits: Search the cache for the node address.
	;
	MOVL	#1,R0				; Assume node is adjacent
	TSTL	R8				; Make sure we have LPD
	BEQL	10$				; If EQL, not adjacent
	BBS	#LPD$V_BC,LPD$W_STS(R8),5$	; If BS, it's a broadcast ckt
	CMPW	R4,ADJ$W_PNA(R9)		; If not, does address match?
	BEQL	20$				; If EQL, node is adjacent
	BRB	10$				; Else, yes: adjacent node
5$:	BSBW	SCAN_CACHE			; Search cache for this LPD
	BRB	20$				; If LBS, found in cache
10$:	CLRL	R0				; Not in cache	
20$:	POPR	#^M<R1,R3,R6,R7,R8,R9>		; Restore registers
	RSB

			.ENABL	LSB

GET_OUT_ADJ:					; Find the output adjacency
	PUSHR	#^M<R1,R6,R7>			; Save registers
	BSBW	TR$GET_ADJ			; Get the output ADJ
	POPR	#^M<R1,R6,R7>			; Restore registers
	RSB					; Return to caller with status

SEND_HELLO:					; Force sending a hello msg
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9>	; Save registers
	MOVL	R1,R8				; Copy LPD address
	SUBL	#FKB$C_LENGTH,SP		; Create context block on stack
	MOVL	SP,R5				; Point to fork block
	BSBW	TALKER				; Send hello message
	ADDL	#FKB$C_LENGTH,SP		; Reset stack pointer
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	BRW	100$				; Exit with status

REACT_RCV:					; Reactivate stalled receiver
	PUSHR	#^M<R1,R2,R5>			; Save regs
						;
	MOVL	LPD$L_RCV_IRP(R1),R5		; Get IRP
	CLRL	LPD$L_RCV_IRP(R1)		; No longer attached to LPD
	;
	;
	;   Say "success" and "zero bytes transferred" in IOST1.  These 
	;   conditions will cause the buffer and IRP to be sent back to the 
	;   datalink driver without signalling any further errors and without 
	;   re-interpreting the buffer contents.
	;
	;
	ASSUME	IRP$L_IOST2  EQ  4+IRP$L_IOST1
	MOVQ	S^#SS$_NORMAL,IRP$L_IOST1(R5)	; Enter "success" and "no bytes
						; transferred".  Zero IOST2
	MOVL	IRP$L_SVAPTE(R5),R1		; Get CXB address
	MOVL	R1,IRP$L_IOSB(R5)		; Reset the CXB address here
	BEQL	1$				; Br if none
	MOVB	#DYN$C_CXB,CXB$B_TYPE(R1)	; Else, reset the buffer type
1$:	JSB	@IRP$L_PID(R5)			; Recycle the buffer
						;
	POPR	#^M<R1,R2,R5>			; Restore regs
	BRW	100$				; Take common exit


INIT_RCV:					; Queue receive to data link
	BBC	#LPD$V_BC,LPD$W_STS(R1),3$	; Br if not a broadcast circuit
	CMPB	#ADJ$C_PTY_PH4N,RCB$B_ETY(R2)	; Are we a real Endnode?
	BNEQ	3$				; Br if not
	CMPB	LPD$B_PTH_INX(R1),#LPD$C_LOC_INX; Is this for the "Local" LPD?
	BEQL	3$				; Br if yes - no CACHE needed
	TSTL	LPD$L_CACHE(R1)			; Is the CACHE already allocated?
	BNEQ	3$				; Br if yes - all set
	;
	;	Allocate the ENDNODE CACHE. The size of each entry is 4 bytes.
	;	The number of entries will be the maximum number of entries +
	;	some extra for the DRT and others attempting to connect.
	;
	MOVQ	R1,-(SP)			; Save registers
	MOVZWL	RCB$W_MAX_LNK(R2),R1		; Get number of entries needed
	MULL	#4,R1				; Calculate 4 bytes per entry
	ADDL	#<4*4>+12,R1			; Make room for some extra
						;  entries plus struct header
	JSB	G^EXE$ALONONPAGED		; Try to allocate the CACHE
	MOVL	R2,R3				; Save CACHE address (if good)
	MOVL	R1,R4				; Save CACHE size
	MOVQ	(SP)+,R1			; Restore registers
	BLBC	R0,209$				; Br if error
	;
	;	Initialize the CACHE. Set the structure type, size and
	;	zero the rest of the entries. The cache is as follows:
	;
	;   +---------------+
	;   |               |	4 bytes unused
	;   |               |
	;   +---------------+
	;   |	   Time	    |	2 bytes for time to update cache.
	;   +---------------+
	;   |     Number    |	2 bytes for number of entries in the Endnode
	;   |       of	    |	Cache.
	;   |     Entries   |
	;   +---------------+
	;   |               |	2 bytes for size of structure
	;   +---------------+
	;   |               |	2 bytes for type of structure
	;   +---------------+
	;   |		    |	LPD$L_CACHE points here.
	;   .    body of    .	Each entry contains 2 bytes of address in
	;   .     cache     .   low word, followed by 2 bytes of time last
	;   .		    .	used.
	;   .		    .
	;   |		    |
	;   +---------------+
	;	
	;
	PUSHR	#^M<R1,R2,R3,R4,R5>		; Save registers
	MOVC5	#0,(R3),#0,R4,(R3)		; Zero the structure
	POPR	#^M<R1,R2,R3,R4,R5>		; Restore registers
	SUBL3	#12,R4,R0			; Get size of CACHE - header
	DIVL	#4,R0				; Calculate number of entries
	CLRL	(R3)+				; Skip first longword
	MOVW	#XPT_C_CACHETIMER,(R3)+		; Initialize CACHE timer period
	MOVW	R0,(R3)+			; Set # of entries in cache
	MOVW	R4,(R3)+			; Set size of structure
	MOVW	#DYN$C_NET,(R3)+		; 
	MOVL	R3,LPD$L_CACHE(R1)		; Save address of CACHE table
	;
	;	Queue initial receive to datalink
	;
3$:	MOVAB	W^TR$RCV_BIO_DATA,R5		; Setup IRP return address 
	BBS	#LPD$V_RBF,LPD$W_STS(R1),10$	; If BS then reads are buffered
	MOVAB	W^TR$RCV_DIO_DATA,R5		; Setup IRP return address
5$:	BSBB	INIT_CXB_FREE			; Init Free CXB queue
209$:	BLBC	R0,200$				; If LBC then report error
10$:	;
	;
	;   Common IRP setup
	;
	;
	MOVZWL	#SS$_DEVACTIVE,R0		; Assume error
	ASSUME	LPD$V_ACTIVE  EQ  0		;
	BLBS	LPD$W_STS(R1),200$		; Br if already active
	BSBW	TR$ALLOC_IRP			; Allocate the IRP
	BLBC	R0,200$				; Br on error
	INCW	RCB$W_TRANS(R2)			; Account for IRP
	MOVAB	IRP$L_PID(R3),R4		; Setup ptr to build IRP

	ASSUME	IRP$L_AST	EQ  4+IRP$L_PID
	ASSUME	IRP$L_ASTPRM	EQ  4+IRP$L_AST
	ASSUME	IRP$L_WIND	EQ  4+IRP$L_ASTPRM
	ASSUME	IRP$L_UCB	EQ  4+IRP$L_WIND
	ASSUME	LPD$L_UCB	EQ  4+LPD$L_WIND

	MOVL	R5,(R4)+			; Move return address into PID
	MOVZWL	LPD$W_PTH(R1),(R4)+		; Enter LPD i.d. into AST
	MOVL	R2,(R4)+			; Enter RCB ptrs into ASTPRM
	MOVQ	LPD$L_WIND(R1),(R4)+		; Enter WIND and UCB ptrs

	ASSUME	IRP$W_FUNC	EQ  4+IRP$L_UCB
	ASSUME	IRP$B_EFN	EQ  2+IRP$W_FUNC
	ASSUME	IRP$B_PRI	EQ  1+IRP$B_EFN
	ASSUME	IRP$L_IOSB	EQ  1+IRP$B_PRI
	ASSUME	IRP$W_CHAN	EQ  4+IRP$L_IOSB

	CLRQ	(R4)+				; Clear FUNC,EFN,PRI,IOSB
	MNEGW	LPD$W_CHAN(R1),(R4)+		; Enter CHAN
	;
	;
	;   If the LPD does direct I/O on receives, remove the buffer from the
	;   RCB CXB free queue and attach it to the IRP.  For buffered I/O
	;   receiver's, no buffer is allocated since that is a datalink
	;   function -- due to possible buffer size requirements, only those
	;   buffers allocated by the datalink receiver are ever returned to the
	;   datalink via the IRP (e.g., during BUFFAIL).
	;
	;
	ASSUME	IRP$W_STS	EQ  2+IRP$W_CHAN
	ASSUME	IRP$L_SVAPTE	EQ  2+IRP$W_STS
	ASSUME	IRP$W_BOFF	EQ  4+IRP$L_SVAPTE
	ASSUME	IRP$W_BCNT	EQ  2+IRP$W_BOFF

	MOVW	#IRP$M_FUNC!IRP$M_BUFIO,(R4)+	; Setup STS for read functions
	BBS	#LPD$V_RBF,LPD$W_STS(R1),30$	; If BS then reads are buffered
	BICW	#IRP$M_BUFIO,-2(R4)		; Setup for direct I/O
	REMQUE	@RCB$Q_CXB_FREE(R2),R0		; Get CXB
	BVC	20$				; If VC then got one
	BUG_CHECK  NETNOSTATE,FATAL		; Queue should have been
						; non-empty at this point
20$:	MOVL	R0,IRP$L_IOSB(R3)		;
30$:	CLRQ	(R4)+				; Clear SVAPTE, BOFF, W_BCNT
	MOVW	#^X<3FFF>,-2(R4)		; Setup W_BCNT

	ASSUME	IRP$L_BCNT	EQ  0+IRP$W_BCNT
	ASSUME	IRP$L_IOST1	EQ  6+IRP$L_BCNT
	ASSUME	IRP$L_IOST2	EQ  4+IRP$L_IOST1

	CLRL	(R4)+				; Clear high word of L_BCNT
						; and next reserved word
	MOVQ	S^#SS$_NORMAL,(R4)+		; Enter "success" and "no bytes
						; xferred into IOST1 -- this is
						; the standard method for
						; admitting IRP's into the
						; receive cycle. 
	INCB	LPD$B_IRPCNT(R1)		; Account for IRP to be queued
	BISW	#LPD$M_ACTIVE,LPD$W_STS(R1)	; Mark LPD active
50$:	BSBW	POST				; Start the cycle by sending
						; the IRP thru IOPOST
100$:	MOVL	#1,R0				; Indicate success
200$:	RSB
			.DSABL LSB


INIT_CXB_FREE:				; Init free CXB queue
	;
	;
	;   If the CXB lookaside list used for circuits using Direct I/O
	;   reads is empty then allocate a single CXB and insert it on the
	;   queue.
	;
	;
	PUSHR	#^M<R1,R2,R3>		; Save regs
					;
	MOVL	#1,R0			; Assume queue is non-empty
	MOVAB	RCB$Q_CXB_FREE(R2),R3	; Get queue header address
	CMPL	R3,(R3)			; Any free CXB's ?
	BNEQ	10$			; If NEQ then yes
	CLRL	R0			; Assume ACP not "up" yet
	TSTB	RCB$B_STI(R2)		;&symbol  Can we trust the buffer size
	BEQL	10$			; If EQL then no
	MOVZWL	RCB$W_TOTBUFSIZ(R2),R1	; Get buffer size assuming 6 byte
					; route header
	ADDL	#TR$C_MAXHDR-6,R1	; Adjust to account for largest
					; possible route header (NI)
	ADDW	#2,R1			; Add 2 extra bytes just in case this
					; is a X.25 DLM datalink
	BSBW	TR$ALLOCATE		; Allocate a CXB
	BLBC	R0,10$			; If LBC then allocation failure
	INSQUE	(R2),@(R3)+		; Insert CXB on the queue
					;
10$:	POPR	#^M<R1,R2,R3>		; Restore regs
	RSB				; Return status in R0


	.SBTTL	TR$KILL_LOC_LPD	- Attempt to shutdown Local LPD

;+
;  TR$KILL_LOC_LPD - Attemp to shutdown Local LPD
;
;
;  This routine is called when the network is shutting down.  It checks to
;  see if the "local LPD" has run-down.  If so, it notifies the NETACP and
;  deactivates the local LPD.
;
;
;  INPUTS:	R2	RCB address
;
;  OUTPUTS:	R3	Garbage
;		R2	Preserved
;		R1	Garbage
;		R0	Low bit set if the local LPD is deactivated
;			Low bit clear otherwise
;
;		All other registers are unchanged.
;
;-
TR$KILL_LOC_LPD::			; Deactivate local LPD
	PUSHR	#^M<R4,R5,R6,R7,R8>	; Save regs
					;
	CLRW	RCB$W_MAX_PKT(R2)	; Force IRP queue to empty
	BSBW	TR$ADJUST_IRP		; Purge it 
	CLRL	R0			; Assume we must wait
	TSTW	RCB$W_CUR_PKT(R2)	; Empty yet?
	BNEQ	30$			; If not, postpone shutdown
					;
	REMQUE	@RCB$Q_LOC_RCV(R2),R5	; Get Local receive IRP
	BVS	30$			; If VS then its not there
10$:	REMQUE	@RCB$Q_CXB_FREE(R2),R0	; Get free CXB
	BVS	20$			; If VS then none
	JSB	G^COM$DRVDEALMEM	; Deallocate it
	BRB	10$			; Loop

20$:	ASSUME	IRP$L_IOST2  EQ 4+IRP$L_IOST1

	CLRQ	IRP$L_IOST1(R5)		; Clear all status bits -- low bit
					; clear in IOST1 signals I/O error
	CLRL	IRP$L_IOSB(R5)		; No buffer to deallocate
	MOVL	#LPD$C_LOC_INX,R8	; Get "local" LPD index
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get the "local" LPD address
	BSBW	TR_RTRN_IRP		; Shut down the LPD
	MOVL	#1,R0			; Indicate success
					;
30$:	POPR	#^M<R4,R5,R6,R7,R8>	; Restore regs
	RSB				; Return status in R0


	.SBTTL	TR$TIMER	- Process Transport layer clock tick

;+
;  TR$TIMER  -	Process Transport layer clock tick
;
;
;  This routine is called at IPL$_NET every time the network clock ticks.  The
;  action here is to process the "Talker" and "Listener" timers on each LPD.
;
;
;  INPUTS:	R2	RCB address
;
;  OUTPUTS:	R3	Garbage
;		R2	Preserved
;		R1	Garbage
;		R0	Garbage
;
;		All other registers are unchanged.
;
;-
TR$TIMER::					; Called each network clock tick
	PUSHR	#^M<R2,R4,R5,R6,R7,R8,R9,R10>	; Save regs
	;
	;   Check to make sure NETACP is still active before doing any more work
	;   Skip check on Endnodes.
	;
	$DISPATCH RCB$B_ETY(R2),TYPE=B,- 	; CASE on LOCAL node type
	<-					;
		<ADJ$C_PTY_PH4N 3$>,-		; Phase IV endnode
		<ADJ$C_PTY_PH3N	3$>,-		; Phase III endnode
	>
	;
	;   All others, except endnodes check ACP activity timer.
	;
	TSTB	RCB$B_ACT_TIMER(R2)		; Is timer already stopped?
	BEQL	1$				; Br if yes
	DECB	RCB$B_ACT_TIMER(R2)		; Else, decrement timer
	BGTR	3$				; Br if okay
1$:	BRW	120$				; Else, clear active bit
						;  and leave now
3$:	;
	;   On each tick, we reduce the IRP free packet list by 1 IRP,
	;   so that the list dynamically (and slowly) reacts to reduced
	;   traffic needs, and converges to an optimum size.
	;
	SETBIT	#RCB$V_ACT,RCB$B_STATUS(R2)	; Make sure everyone knows
						;  NETACP is still active.
	CMPB	RCB$W_CUR_PKT(R2),#10		; Don't let list get too small
	BLEQU	5$				; Skip if list is getting small
	REMQUE	@RCB$Q_IRP_FREE(R2),R0		; See if there is a free IRP
	BVS	5$				; Skip if none
	JSB	G^COM$DRVDEALMEM		; Deallocate the IRP
	DECW	RCB$W_CUR_PKT(R2)		; and adjust packet count
	DECW	RCB$W_TRANS(R2)			; Here too
5$:	;
	;   Scan all LPDs for talker and listener
	;
	SUBL	#FKB$C_LENGTH,SP		; Create context block on stack
						; for the "TALKER" routine
	MOVZBL	RCB$B_MAX_LPD(R2),R9		; Get number of LPDs
	BEQL	30$				; If EQL then none
	ASSUME	LPD$C_LOC_INX EQ 1
	MOVZBL	#LPD$C_LOC_INX,R7		; Initialize index
	BRB	20$				; Start at LOCAL+1
10$:	MOVL	@RCB$L_PTR_LPD(R2)[R7],R8	; Get LPD address
	BGEQ	20$				; Branch if slot not used
	MOVL	LPD$L_CACHE(R8),R0		; Get the CACHE table for this
						;  LPD
	BEQL	15$				; Br if none
	;
	;   Handle CACHE timer
	;
	DECW	-8(R0)				; Is it time to check the cache?
	BGTR	15$				; Br if not - skip cache work
	MOVW	#XPT_C_CACHETIMER,-8(R0)	; Else, reset cache timer
	MOVZWL	-6(R0),R5			; Get # of entries in cache
	SUBL3	#XPT_C_CACHETIMEOUT,-		; Get Absolute system time
		G^EXE$GL_ABSTIM,R1		;  minus cache timeout period
13$:	TSTW	(R0)+				; Skip node address
	CMPW	R1,(R0)+			; Is current time > entrytime +
						;  cache timeout period
	BLEQU	14$				; Br if not, entry still valid
	CLRL	-4(R0)				; Else, flush the cache entry
14$:	SOBGTR	R5,13$				;
	
15$:	BBC	#LPD$V_RUN,LPD$W_STS(R8),20$	; If BC then no need to talk
	;
	;
	;   Process talker timer
	;
	;	The talker timer cell is located in the LPD data base.
	;
	DECW	LPD$W_TIM_TLK(R8)		; Tick the talk timer
	BGTR	20$				; Not expired if GTR
	MOVW	#RETRY_TIMER,LPD$W_TIM_TLK(R8)	; Set for retry
						; if TALKER resource failure
	MOVL	SP,R5				; Setup fork block address
	PUSHR	#^M<R2,R7,R8,R9>		; Save vulnerable regs
	BSBW	TALKER				; Send a "hello" message
	POPR	#^M<R2,R7,R8,R9>		; Restore regs
20$:	AOBLEQ	R9,R7,10$			; Loop for each cell

30$:	ADDL	#FKB$C_LENGTH,SP		; Restore the stack
	;
	;
	;   Process listener timer
	;
	;	The listener timer cell is located in the ADJ data base.
	;	We will only process a maximum of 256 ADJs in a one second
	;	time interval.
	;
	MOVZWL	RCB$W_MAX_ADJ(R2),R1		; Get number of adjacencies
	BEQL	100$				; If EQL then none
	MOVZBL	RCB$B_LSN_ADJ(R2),R7		; Get current index multiplier
						;  for processing this time
	ASHL	#NODE_SHIFT,R7,R7		; Get index of where to start
	BNEQ	35$				; Br if non-zero - okay
	ASSUME	LPD$C_LOC_INX EQ 1
	INCL	R7				; Else, start at "Local"
35$:	;
	;   Calculate where to finish processing in this time interval.
	;
	ADDL3	#NODES_PER_PASS,R7,R3		; Assume current maximum
						;   is current + NODES_PER_PASS
	CMPL	R3,R1				; Is current maximum greater
						;   than the absolute maximum?
	BLEQU	37$				; Br if no - okay
	MOVL	R1,R3				; Else, set maximum to MAX_ADJ
37$:	;
	;   Update multiplier for next time thru.
	;
	ADDL	#NODES_PER_PASS-1,R1		; Calculate maximum index
	ASHL	#-NODE_SHIFT,R1,R8		;  to use for this pass
	INCB	RCB$B_LSN_ADJ(R2)		; Update next time path
	CMPB	RCB$B_LSN_ADJ(R2),R8		; Modulo NODES_PER_PASS
	BLSSU	50$				;	...
	CLRB	RCB$B_LSN_ADJ(R2)		;	...
	BRB	50$				; Start at LOCAL+1
40$:	MOVL	@RCB$L_PTR_ADJ(R2)[R7],R9	; Get ADJ address
	BBC	#ADJ$V_LSN,ADJ$B_STS(R9),50$	; Br if listen timer not ticking
	SUBW	R8,ADJ$W_TIM_LSN(R9)		; Tick the listener timer
	BGTRU	50$				; Not expired if NEQ
	;
	;   Listener timer has expired - queue WQE to AQB to signal event
	;
	MOVW	#RETRY_TIMER,ADJ$W_TIM_LSN(R9)	; Retry if LISTENER
						; resource failure
	BSBB	LISTENER			; Listener has timed out

50$:	AOBLEQ	R3,R7,40$			; Loop for each cell
						;
100$:	POPR	#^M<R2,R4,R5,R6,R7,R8,R9,R10>	; Restore regs
	RSB

	;
	;   NETACP is no longer active, it must have stalled.
	;
120$:	CLRBIT	#RCB$V_ACT,RCB$B_STATUS(R2)	; Clear the ACP active bit
	BRB	100$				; Return

LISTENER:					; Listener timer has expired
	MOVQ	R2,-(SP)			; Save regs
						;
	ASSUME	IRP$C_LENGTH  GE  WQE$C_LENGTH	;
	MOVZBL	#IRP$C_LENGTH,R1		; Setup buffer size
	BSBW	TR$ALLOCATE			; Get the buffer
	BLBC	R0,50$				; If LBC then didn't get one
	MOVL	R2,R5				; Copy buffer for subr call
	MOVL	(SP),R2				; Restore RCB address
	MOVW	ADJ$W_LPD(R9),WQE$W_REQIDT(R5)	; Return ADJ's LPD index
	MOVW	R7,WQE$W_ADJ_INX(R5)		; Save ADJ index
	MOVB	#NETMSG$C_LSN,WQE$B_EVT(R5)	; Setup "listner" event
	BSBW	TR$GIVE_TO_ACP			; Pass it to the ACP
						;
50$:	MOVQ	(SP)+,R2			; Restore regs
EXIT:	RSB					; Done

TALKER:						; Talker timer has expired
	;
	;
	;   Fork block on stack (ptr in R5) provides context for the next call.
	;   The call to SOL_NW must be done with:
	;
	;
	;   INPUTS:	R8	LPD address
	;		R7,R6	Scratch
	;		R5	Fork block address
	;			The FPC,FR3,FR4 fields are all scratch
	;		R4	Scratch
	;		R3	IRP address
	;		R2	RCB address
	;		R1,R0	Scratch
	;
	;   OUTPUTS:	R0	Status
	;		R1,R4,R6,R7,R9 are destroyed.
	;
	CLRL	R9				; No adjacency required
	BSBW	SOL_NW				; Get permission to xmit
						; -- don't wait if no resources
	BLBC	R0,EXIT				; If LBC, permission denied 
	ASSUME	TR4$C_BCE_MID2 EQ 0
	ASSUME	TR4$C_BCR_MID2 EQ 0
	CLRL	IRP$Q_STATION+4(R3)		; Clear high portion of address
	MOVL	R2,R4				; Save RCB address
	MOVL	LPD$L_RTR_LIST(R8),R1		; Get ROUTER LIST
	BEQL	5$				; Br if none
	MOVZBL	(R1),R1				; Else, get size of router list
5$:	ADDL	#CXB$C_OVERHEAD-		; Add in CXB size
		+HELLO_MSG_SIZE,R1		;  plus fixed size of hello msg
						; (this is worst case msg size)
	BSBW	TR$ALLOCATE			; Allocate the buffer
	BLBC	R0,EXIT				; If LBC then failed
	MOVL	R2,R6				; Setup CXB address
	MOVAB	CXB$C_HEADER(R6),R1		; Setup message ptr
	MOVL	R1,R7				; Make a copy
	;
	;   If the circuit is a broadcast circuit, then the PTYPE in the
	;   'main' ADJ is always unknown. Therefore on broadcast circuits
	;   we will have to build either the Broadcast Hello message for
	;   routers or endnodes. Otherwise, for non-broadcast circuits we
	;   will build the hello message based upon the ADJ$B_PTYPE field.
	;
	BBS	#LPD$V_BC,LPD$W_STS(R8),20$	; Br if broadcast circuit, we
						;  will use LPD$B_ETY for case
	MOVZBL	LPD$B_PTH_INX(R8),R0		; Get the ADJ index (same as
						;   LPD index)
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R0	; Get ADJ address
	$DISPATCH ADJ$B_PTYPE(R0),TYPE=B,- 	; CASE on ADJ's node type
	<-					;
		<ADJ$C_PTY_AREA	10$>,-		; Phase IV level 2 router
		<ADJ$C_PTY_PH4	10$>,-		; Phase IV router
		<ADJ$C_PTY_PH4N 10$>,-		; Phase IV endnode
		<ADJ$C_PTY_PH3	15$>,-		; Phase III router
		<ADJ$C_PTY_PH3N	15$>,-		; Phase III endnode
	>
	;
	;   Build a Phase II NOP message
	;
	MOVB	#TR3$C_MSG_NOP2,(R7)+		; Enter Phase II msg header
	BRW	50$				; Continue in common
10$:	;
	;	Build a Phase IV non-broadcast hello message
	;
	MOVW	RCB$W_ADDR(R4),R0		; Get local node address
	BRB	17$				; Continue in common code
	;
	;   Build a Phase III hello message
	;
15$:	EXTZV	#TR4$V_ADDR_DEST,-		; Get the local node address
		#TR4$S_ADDR_DEST,RCB$W_ADDR(R4),R0 ;..without area number
17$:	MOVB	#TR3$C_MSG_HELLO,(R7)+		; Enter msg type
	MOVW	R0,(R7)+			; Enter local node address
	MOVB	#2,(R7)+			; Enter count of next field
	MOVW	#^X<AAAA>,(R7)+			; Enter alternating 1's and 0's
	BRW	50$				; Done
20$:	;
	;   Build a Phase IV Broadcast hello message
	;
	CMPB	#ADJ$C_PTY_PH4N,LPD$B_ETY(R8)	; Are we an endnode?
	BEQL	40$				; Br if yes
	;
	;   Build a Phase IV Broadcast router hello message
	; 
	MOVB	#TR4$C_MSG_BCRHEL,(R7)+		; Enter msg type
	MOVW	#TR4$C_VER_LOWW,(R7)+		; Enter XPORT version number
	MOVB	#TR4$C_VER_HIB,(R7)+		;	...
	MOVL	#TR4$C_HIORD,(R7)+		; Enter HIORD portion of addres
	MOVW	RCB$W_ADDR(R4),(R7)+		; Enter local node address
	MOVB	#TR4$C_RTR_LVL1,(R7)+		; Assume level 1 router
	CMPB	LPD$B_ETY(R8),#ADJ$C_PTY_AREA	; Are we a level 2 router?
	BNEQ	30$				; Br if not
	MOVB	#TR4$C_RTR_LVL2,-1(R7)		; Enter level 2 router type
30$:	MOVW	LPD$W_BUFSIZ(R8),(R7)+		; Enter datalink buffer size
	MOVB	LPD$B_BCPRI(R8),(R7)+		; Enter router's priority
	CLRB	(R7)+				; RESERVED (AREA)
	MOVW	LPD$W_INT_TLK(R8),(R7)+		; Enter hello timer

	MOVB	LPD$W_INT_TLK(R8),(R7)+		; && Put hello in reserved
						; && until all are updated
	MOVL	LPD$L_RTR_LIST(R8),R0		; Get R/S list
	ADDB3	#8,(R0),(R7)+			; Store length of NI-LIST
	CLRQ	(R7)+				; RESERVED logical NI name
	MOVB	(R0),-1(R7)			; Store length of R/S list
	PUSHR	#^M<R1,R2,R3,R4,R5,R6>		; Save registers
	MOVZBL	(R0)+,R6			; Get length of R/S list
	MOVC	R6,(R0),(R7)			; Move the R/S list
	ADDL	R6,R7				; Account for bytes moved
	POPR	#^M<R1,R2,R3,R4,R5,R6>		; Restore registers
	MOVL	#TR4$C_BCR_MID1,-		; Set destination address
		 IRP$Q_STATION(R3)		;  assume we have to send
						;  to "All Routers"
	;
	;   If we are the designated router on a Broadcast Circuit,
	;   then we will send the "Hello" message to "All Endnodes"
	;   after we have sent it to "All Routers".
	;
	BBC	#LPD$V_XEND,LPD$W_STS(R8),50$	; Br if we have not already
						;  sent the "Hello" message
						;  to "All Routers".
	MOVL	#TR4$C_BCE_MID1,-		; Else, Set destination address
		 IRP$Q_STATION(R3)		;  to "All Endnodes"
	BRB	50$				; Done
	;
	;   Build a Broadcast end node hello message
	;
40$:	MOVB	#TR4$C_MSG_BCEHEL,(R7)+		; Enter msg type
	MOVW	#TR4$C_VER_LOWW,(R7)+		; Enter XPORT version number
	MOVB	#TR4$C_VER_HIB,(R7)+		;	...
	MOVL	#TR4$C_HIORD,(R7)+		; Enter HIORD portion of addres
	MOVW	RCB$W_ADDR(R4),(R7)+		; Enter local node address
	MOVB	#TR4$C_END_NODE,(R7)+		; Enter endnode type
	MOVW	LPD$W_BUFSIZ(R8),(R7)+		; Enter datalink buffer size
	CLRB	(R7)+				; RESERVED (AREA)
	CLRQ	(R7)+				; Verification seed
	MOVL	#TR4$C_HIORD,(R7)+		; Store designated router's
						;  HIORD portion of address
	MOVZWL	LPD$W_DRT(R8),R0		; Get inx of designated router
	BEQL	45$				; Br if none
	MOVL	@RCB$L_PTR_ADJ(R4)[R0],R0	; Get address of ADJ
	MOVZWL	ADJ$W_PNA(R0),R0		; Get designated router address
45$:	MOVW	R0,(R7)+			; Set designated router address
	MOVW	LPD$W_INT_TLK(R8),(R7)+		; Enter hello timer

	MOVB	LPD$W_INT_TLK(R8),(R7)+		; && Put hello in reserved
						; && until all are updated
	MOVB	#2,(R7)+			; Enter count of next field
	MOVW	#^X<AAAA>,(R7)+			; Enter bit pattern
	MOVL	#TR4$C_BCR_MID1,-		; Set destination address
		 IRP$Q_STATION(R3)		;   to "All Routers"


50$:	SUBL	R1,R7				; Setup message size
	MOVAB	W^TR$RTRN_XMT_TLK,IRP$L_PID(R3)	; Setup end-action address
	MOVAB	B^60$,R2  			; Setup null end-action routine
	CLRL	R4				; No "quick solicit" wanted
	MOVZBL	#1,R0				; Return success
60$:	RSB					; Return with status in R0


	.SBTTL	TR$SOLICIT	- Process ECL request to xmit into the network

;+
;  TR$SOLICIT	- Process ECL request to xmit into the network
;
;
;  An ECL (e.g. NSP) is requesting to xmit into the network.  The appropriate
;  logical path (LPD) is found, either because it was explicitly specified or
;  because the specified destination node address maps to it.
;
;  If the resources for transmission (input packet limiter queue slot, square
;  root packet limit queue slot, IRP) are not immediately available, the
;  request block is entered onto a wait queue.
;
;
;  INPUTS:	R5	Fork block address
;			The FPC,FR3,FR4 fields are all scratch and must not
;			be modified by the caller until it is reactivated by
;			either  TR$DENY  or  TR$GRANTED.
;		R4	Destination node address 
;			Zero if Transport is to use the LPD index as ADJ index
;		R3	I.D. of LPD to xmit over 
;			Zero if Transport is to choose the LPD 
;		R2	RCB address
;		R1,R0	Scratch
;
;		(SP)	Return address of caller
;	       4(SP)	Return address of caller's caller
;
;
;  OUTPUTS:	See parameters returned when reactivating process from
;		routines TR$GRANT or TR$DENY
;
;-
TR$SOLICIT::				; Process ECL request to xmit
	;
	;
	;   Setup the fork block and pop the stack to simplify the code
	;   in case the requestor needs to be suspended.
	;
	;
	POPL	FKB$L_FPC(R5)		; Save return addr, pop stack
					;
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Save req used for LPD address
	BSBB	SOL_WAIT		; Process request, okay to wait
	POPR	#^M<R6,R7,R8,R9,R10>	; Restore reg
					;
	RSB				; Done

SOL_NW:					; Solicit - do not wait
	;
	;
	;   Setup the IRP for eventual xmission.  
	;
	;
	POPL	FKB$L_FPC(R5)		; Setup return address
	MOVZWL	LPD$W_PTH(R8),FKB$L_FR3(R5) ; Save LPD i.d.
	TSTB	LPD$B_XMT_IPL(R8)	; Does "input-packet-limiter" allow it
	BLEQ	30$			; If LEQ then no, DENY request
	CMPB	LPD$B_IRPCNT(R8),-	; Does "square-root-limiter" allow it
		LPD$B_XMT_SRL(R8)	; 
	BGTR	TR$DENY			; If GTR then no, DENY request
20$:	REMQUE	@RCB$Q_IRP_FREE(R2),R3	; Get a free IRP
	BVC	40$			; If VC then got one
	BSBW	TR$ADJUST_IRP		; Adjust IRP count if possible
	BLBS	R0,20$			; Br if any new IRPs were allocated
30$:	BRB	TR$DENY			; Else, deny permission to xmit
					;
40$:	DECB	LPD$B_XMT_IPL(R8)	; Consume "input-packet-limit" slot
	INCB	LPD$B_IRPCNT(R8)	; Account for IRP to be queued
	BRB	TR$GRANT		; Grant permission to xmit

SOL_WAIT:				; Process request, okay to wait
	BSBW	TR$GET_ADJ		; Get AJD and LPD for output
	BLBC	R0,TR$DENY		; Br if no path to node
	TSTW	R4			; Zero destination?
	BEQL	50$			; Br if yes, okay to send
	;
	;   If we are endnode, and we are connected to another endnode,
	;   then make sure the endnode's address is the same as the
	;   destination address.  If not, deny the request.  This ensures
	;   that the remote endnode only receives packets destined for him.
	;
	$DISPATCH ADJ$B_PTYPE(R9),TYPE=B,-
	<-
		<ADJ$C_PTY_PH4N 20$>,-	; Phase IV endnode
		<ADJ$C_PTY_PH3N	10$>,-	; Phase III endnode
	>
	BRB	50$			; Otherwise continue
10$:	EXTZV	#TR4$V_ADDR_DEST,-	; For Phase III nodes,
		#TR4$S_ADDR_DEST,R4,R0	; compare only the node addr, not area
	CMPW	R0,ADJ$W_PNA(R9)	; Is the destination node correct?
	BNEQ	TR$DENY			; Br if no, deny request
	BRB	50$
20$:	CMPW	R4,ADJ$W_PNA(R9)	; Is the destination node correct?
	BNEQ	TR$DENY			; Br if no, deny request
50$:	MOVZWL	LPD$W_PTH(R8),FKB$L_FR3(R5) ; Save LPD i.d.
	MOVL	R7,FKB$L_FR4(R5)	; Save ADJ index if we have to FORK
					;

QUICK_SOL:				; Quick solicit entry
	;
	;   Make sure the NETACP is still active before actually granting
	;   permission to transmit.
	;
	BBC	#RCB$V_ACT,-		; If ACP is not active, then return
		RCB$B_STATUS(R2),TR$DENY;   failure to caller
	;
	;
	;   Need "request" slot, room on output queue, and IRP to proceed
	;
	;
	TSTB	LPD$B_XMT_IPL(R8)	; Does "input-packet-limiter" allow it?
	BLEQ	70$			; If LEQ then no
	CMPB	LPD$B_IRPCNT(R8),-	; Does "square-root-limiter" allow it?
		LPD$B_XMT_SRL(R8)	;
	BGTR	70$			; If GTR then no
	DECB	LPD$B_XMT_IPL(R8)	; Consume request slot
	INCB	LPD$B_IRPCNT(R8)	; Account for IRP to be queued
60$:	REMQUE	@RCB$Q_IRP_FREE(R2),R3	; Get a free IRP
	BVC	TR$GRANT		; If VC then got one
	BSBW	TR$ADJUST_IRP		; Adjust IRP count if possible
	BLBS	R0,60$			; If LBS, IRPs were allocated
					;
	INSQUE	(R5),@RCB$Q_IRP_WAIT+4(R2)  ; Wait for IRP
	RSB

70$:	INSQUE	(R5),@LPD$Q_REQ_WAIT+4(R8)  ; Wait for spot on datalink queue
	RSB


	.SBTTL	TR$DENY		- Deny solicitor permission to transmit
	.SBTTL	TR$GRANT	- Grant solicitor permission to transmit

;+
;  TR$DENY   -  Reactivate solicitor, denying permission to transmit
;  TR$GRANT  -  Reactivate solicitor, granting permission to transmit
;
;
;  The R5 fork process cannot be suspended beyond this point.
;
;
;  INPUTS:	R10	Scratch
;		R9	ADJ address
;			Or ZERO if called by TALKER routine
;		R8	LPD address
;		R7,R6	Scratch
;		R5	Fork block address
;		R4	Scratch
;		R3	If TR$GRANT  - IRP address 
;			If TR$DENY   - Scratch
;		R2	RCB address
;		R1,R0	Scratch
;
;
;  OUTPUTS:	R7-R0	Garbage
;
;		All other registers are preserved.
;
;-
TR$DENY:				; Deny permisson to xmit
	CLRB	R0			; Indicate request denied
	PUSHL	R2			; Save RCB address
	JSB	@FKB$L_FPC(R5)		; Tell requestor
	POPL	R2			; Restore RCB address
	RSB				; Done

TR$GRANT:				; Grant permission to xmit
	;
	;   Call requestor back with:
	;
	;	R10	Scratch
	;	R9	ADJ address or zero
	;	R8	LPD address
	;	R7,R6	Scratch
	;	R5	Fork block address
	;	R4	Scratch
	;	R3	IRP address only if R0 has low bit set, else scratch
	;	R2	RCB address
	;	R1	Scratch
	;	R0	Low bit set if permission granted
	;		Low bit clear if permission denied
	;
	;
	ASSUME	IRP$L_AST	EQ  4+IRP$L_PID
	ASSUME	IRP$L_ASTPRM	EQ  4+IRP$L_AST

	MOVAB	IRP$L_PID(R3),R0	; Setup R4 for IRP builder
	MOVAB	W^TR$RTRN_XMT_ECL,(R0)+	; Setup end-action address
	MOVZBL	LPD$B_PTH_INX(R8),(R0)+	; Enter LPD index 
	MOVL	R2,(R0)+		; Enter RCB address
	MOVB	#1,R0			; Indicate "okay to xmit"
	JSB	@FKB$L_FPC(R5)		; Reactivate solicitor
	;
	;
	;    On return, the CXB and registers are setup as follows:
	;
	;
	;   +---------------+
	;   |   standard    |	11 bytes long.  CXB$L_FLINK and CXB$L_BLINK may
	;   |     VMS	    |	be used by the Transport layer.  CXB$W_SIZE 
	;   | buffer header |	must be correct.  CXB$B_TYPE must be DYN$C_CXB.
	;   +---------------+
	;   |		    |	Starts with CXB$B_CODE (byte 11) and continues
	;   |      ECL	    |	to CXB$C_LENGTH.  This area is read-only to
	;   |   pure area   |	Transport and below.  It cannot even be
	;   |               |	saved/restored.
	;   +---------------+
	;   |    Datalink   |	Starts at CXB$C_LENGTH and is at least 
	;   |     Layer	    |	CXB$C_DLL bytes long.  Used by the datalink for
	;   |  impure area  |	protocol header or state information.
	;   +---------------+
	;   |		    |	
	;   .    body of    .	Must be quadword aligned and starting no sooner
	;   .    message    .   than CXB$C_LENGTH + CXB$C_DLL (= CXB$C_HEADER)
	;   .		    .	The first 6 bytes contain: RTFLG,DSTNOD,SRCNOD
	;   .		    .	FORWARD, in that order.
	;   |		    |
	;   +---------------+
	;   |    Datalink   |	Used by the datalink layer for protocol (e.g.,
	;   |     Layer     |	checksum) or state information.  Must be at
	;   |  impure area  |	least CXB$C_TRAILER in length.
	;   +---------------+
	;
	;
	;	R9	ADJ address or zero
	;	R8	LPD address
	;	R7	Size of message
	;	R6	CXB address
	;	R5	Garbage
	;	R4	0 if "quick solicit" not requested
	;		Else, pointer to request block (XWB fork block) with
	;		FRK$L_FPC  pointing to the "quick solicit" routine
	;	R3	IRP address -- unmodified from call
	;	R2	Address of End-action routine to call on I/O competion
	;	R1	Ptr to 1st byte in standard Phase III route-header
	;	R0	Low bit set   -	if message is to be xmitted
	;		Low bit clear -	if no message to xmit.  In this case
	;				R7-R4,R2,R1 contain garbage.
	;
	;
	BLBC	R0,60$			; If LBC then xmit aborted
	MOVL	R2,IRP$L_SAVD_RTN(R3)	; Save ptr to End-action routine
	CLRW	CXB$W_R_ADJ(R6)		; No receive adjacency
	CLRW	CXB$W_R_PATH(R6)	; No receive LPD 
	MOVL	IRP$L_ASTPRM(R3),R2	; Recover RCB address

	MOVAB	IRP$L_WIND(R3),R0	; Setup R0 for building IRP
	MOVL	R4,R5			; "Quick solicit" requested ?
	BNEQ	50$			; If NEQ then yes
	BRW	FINISH_XMT_HDR		; Finish building HDR & IRP, xmit it.
					;
50$:	PUSHL	R5			; Remember block's address
	PUSHL	R2			; Remember RCB address
	BSBW	FINISH_XMT_HDR		; Finish building HDR & IRP, xmit it.
	POPR	#^M<R2,R5>		; Setup R2,R5 (R8 points to LPD)
					;
	BRW	QUICK_SOL		; Perform "quick solicit"
60$:	;
	;
	;   User didn't want to xmit after all.  Return resources.
	;
	;
	MOVL	R3,R5			; Setup IRP address
	CLRL	IRP$L_IOSB(R5)		; No buffer to deallocate
	MOVL	#1,IRP$L_IOST1(R5)	; Avoid false I/O failure detection
	MOVL	IRP$L_ASTPRM(R5),R2	; Recover RCB address
	INCB	LPD$B_XMT_IPL(R8)	; Return "request" slot
	BSBW	TR_RTRN_IRP		; Recycle unused the IRP
	RSB				; Done

	.SBTTL	TR$TEST_REACH	- Check if node is reachable
;+
;  TR$TEST_REACH  -  Check if node is reachable
;
;
;  INPUTS:	R0	Remote/Local node address
;		R2	RCB address
;
;  OUTPUTS:	R0	True if there is a path to node available
;			False if no path available to node
;
;		All registers are preserved.
;-
TR$TEST_REACH::
	PUSHR	#^M<R1,R3,R4,R5,R6,R7,R8,R9>	; Save registers
	MOVL	R0,R4				; Pass node address
	CLRL	R3				; No specific circuit
	BSBB	TR$GET_ADJ			; Get the output ADJ
	POPR	#^M<R1,R3,R4,R5,R6,R7,R8,R9>	; Restore registers
	RSB					; Return to caller

	.SBTTL	TR$GET_ADJ	- Get output ADJ and LPD

;+
;  TR$GET_ADJ			Get output ADJ and LPD
;
;
;  INPUTS:	R4	Remote/Local node address or zero
;		R3	LPD index or zero
;		R2	RCB address
;
;
;  OUTPUTS:	R9	ADJ address (zero if none)
;		R8	LPD address (zero if none)
;		R0	True if path available to node, false if unreachable
;
;		R7-R6,R1    are destroyed.
;		R5-R2 	    are preserved.
;-
	.ENABL	LSB
TR$GET_ADJ::				; Get the output ADJ and LPD
	;
	;   Determine the LPD address from the path i.d. in the low byte of
	;   R3.  If the path i.d. is zero then determine output LPD from the
	;   destination node address.
	;
	;	CASES:		LPD	NODE
	;			---	----
	;		NORMAL:	R3 = 0, R4 = Destination node address or zero
	;		NORMAL: R3 <>0, R4 = Remote node address
	;		LOOP:	R3 <>0, R4 = Local node address
	;
	MOVZBL	R3,R7			; Assume we need the LPD index
					;  as the ADJ index 
	BNEQ	10$			; Br if LOOP case - R3 is non-zero
	BRW	130$			; Else, NORMAL case

10$:	TSTW	R4			; Is the node address given?
	BNEQ	20$			; Br if yes - LOOP NODE case
	BRW	240$			; Else, use LPD as ADJ

20$:	CMPW	R4,RCB$W_ADDR(R2)	; Is this intended for loopback?
	BEQL	50$			; If so, then LOOP NODE request
	;
	;   Forced-LPD normal case - we are going to transmit a message
	;   to a specific remote node, over a specific LPD.
	;
	$DISPATCH RCB$B_ETY(R2),TYPE=B,- ; If we are an endnode, use DRT
	<-				;
		<ADJ$C_PTY_PH3N 120$>,-	; Phase III endnode
		<ADJ$C_PTY_PH4N 120$>,-	; Phase IV endnode
	>
	
	;
	;   First we MUST find the output ADJ based on the node address given
	;   the destination node address supplied in R4.
	;
	;   Determine the output LPD from the output adjacency.
	;
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the "Area" portion of the
		#TR4$S_ADDR_AREA,-	;  node address
		R4,R1			;
	EXTZV	#TR4$V_ADDR_DEST,-	; Get only the destination
		#TR4$S_ADDR_DEST,-	;  portion of the node address
		R4,R7			;
	TSTB	R1			; Is this for area 0?
	BEQL	30$			; Br if yes - our "logical" area
	CMPB	R1,RCB$B_HOMEAREA(R2)	; Is this request for our "Area"?
	BNEQ	40$			; Br if no, deny request
30$:	CMPW	R7,RCB$W_MAX_ADDR(R2)	; Is the node within bounds?
	BGTRU	40$			; If GTRU then no
	MOVZWL	@RCB$L_PTR_OA(R2)[R7],R7; Get ADJ index
	BEQL	40$			; Br if not there, deny request
	BRW	240$			; Else, continue processing
40$:	BRW	NOT_REACH		; Else, node unreachable

50$:	;
	;   LOOP NODE case - we are going to transmit a message to
	;   a remote node over the LPD, but with the destination address
	;   set to ourself so it will be looped back.
	;
	$DISPATCH RCB$B_ETY(R2),TYPE=B,- ; Br if we are an endnode
	<-				;
		<ADJ$C_PTY_PH3N 120$>,-	; Phase III endnode
		<ADJ$C_PTY_PH4N 120$>,-	; Phase IV endnode
	>
	;
	;  For the LOOP case, we will first try the DRT for the LPD that
	;  was passed down from the requesting process. If the LPD is a
	;  BC and the DRT is not set then we must scan the entire BRA
	;  ADJ list to find the first remote TRANSPORT which can do the loop
	;  for us. Else, for non-BC circuits, we will use the DRT value as
	;  given.
	;
	;  Also, if the DRT is set and we are the DRT for the LPD, then we
	;  will have to scan the BRA list for a remote transport to talk to.
	;
	;  Inputs:
	;		R7 = LPD index (zero extended)
	;		R4 = Node address
	;		R3 = LPD index
	;
	MOVL	@RCB$L_PTR_LPD(R2)[R7],R8 ; Get LPD address
	BGEQ	100$			; If GEQ then slot not in use
	ASSUME	LPD$V_ACTIVE  EQ  0
	BLBC	LPD$W_STS(R8),100$	; If LBC, circuit is inactive
	;
	;	We must now check to see if the DRT is ourself and if so,
	;	then we must try to find someone else to loop with. If we
	;	cannot find someone else to loop with, then we must try using
	;	the "main" LPD and hope we are in loopback.
	;
	MOVZWL	LPD$W_DRT(R8),R0	; Get the designated router ADJ index
	MOVL	@RCB$L_PTR_ADJ(R2)[R0],R0 ; Get ADJ address
	CMPW	ADJ$W_PNA(R0),RCB$W_ADDR(R2) ; Are we the "Designated Router"?
	BEQL	70$			; Br if yes, try to find someone else
	CMPW	LPD$W_DRT(R8),R7	; Is the DRT set?
					; (i.e. Not equal to "main" LPD)
	BNEQ	60$			; Br if yes - use DRT
	BBS	#LPD$V_BC,LPD$W_STS(R8),70$ ; Else, scan BRAs if NI
60$:	MOVZWL	LPD$W_DRT(R8),R7	; Get ADJ index for output ADJ
	BRW	240$			; Go get ADJ and LPD addresses

70$:	MOVZWL	RCB$W_MAX_RTG(R2),R6	; Get number of routing "destinations"
	BEQL	90$			; Br if none - try "main" LPD
	MOVZBL	RCB$B_MAX_LPD(R2),R7	; Initialize ADJ index
	BRB	80$			; Start at first ADJ
75$:	MOVL	@RCB$L_PTR_ADJ(R2)[R7],R9 ; Get next ADJ address
	BBC	#ADJ$V_RUN,-		; Br if ADJ not in run state
		ADJ$B_STS(R9),80$	;
	CMPB	R3,ADJ$B_LPD_INX(R9)	; LPD match?
	BEQL	110$			; Br if YES
80$:	AOBLEQ	R6,R7,75$		; Br if more
90$:	MOVZBL	LPD$B_PTH_INX(R8),R7	; If all else fails, use "main" ADJ
	BRW	240$			; Get ADJ and LPD addresses

100$:	BRW	NOT_REACH		; DENY - if no remote transport
	;
	;   Found remote transport to loop with, get LPD address
	;
110$:	BRW	260$			; Get LPD address and continue

120$:	;
	;   For LOOP Endnodes we will ALWAYS use LPD$W_DRT for output
	;
	MOVL	@RCB$L_PTR_LPD(R2)[R7],R8 ; Get LPD address
	BGEQ	160$			; If GEQ then slot not in use
	ASSUME	LPD$V_ACTIVE  EQ  0
	BLBC	LPD$W_STS(R8),160$	; If LBC, circuit is inactive

	MOVZWL	LPD$W_DRT(R8),R7	; Get ADJ index for output ADJ
	BRW	240$			; Continue in common path

	;
	;
	;   NORMAL transmit request
	;
	;
130$:	EXTZV	#TR4$V_ADDR_AREA,-	; Get the "Area" portion of the
		#TR4$S_ADDR_AREA,-	;  node address
		R4,R1			;
	ASSUME	TR4$V_ADDR_DEST EQ 0
	EXTZV	#TR4$V_ADDR_DEST,-	; Get only the destination
		#TR4$S_ADDR_DEST,-	;  portion of the node address
		R4,R7			;
	$DISPATCH RCB$B_ETY(R2),TYPE=B,-  ; Dispatch on Our Node type
	<-
		<ADJ$C_PTY_PH4N	 SOL_PH4N>,-	; Phase IV endnode
		<ADJ$C_PTY_AREA	 SOL_AREA>,-	; Phase IV Level 2 router
	>

					; All other - including Level 1 Router
SOL_PH4:				; Phase IV Level 1 Router request
	;
	;   First we MUST find the output ADJ based on the node address given
	;   the destination node address supplied in R4.
	;
	;   Determine the output LPD from the output adjacency.
	;
	TSTB	R1			; Is this for area 0?
	BEQL	140$			; Br if yes - our "logical" area
	CMPB	R1,RCB$B_HOMEAREA(R2)	; Is this request for our "Area"?
	BEQL	140$			; Br if yes
	MOVZWL	RCB$W_LVL2(R2),R7	; Else, get the nearest Level 2 router
	BNEQ	240$			; Br if okay - we have one
	BRW	NOT_REACH		; Else, node unreachable

140$:	CMPW	R7,RCB$W_MAX_ADDR(R2)	; Is the node within bounds?
	BGTRU	160$			; If GTRU then no
	MOVZWL	@RCB$L_PTR_OA(R2)[R7],R7; Get ADJ index
	BNEQ	240$			; Br if okay
160$:	BRW	NOT_REACH		; Else, node unreachable

SOL_PH4N:				; Process Phase IV endnode request
	;
	;   For Endnodes, we will first scan the CACHE to see if the
	;   destination node is directly adjacent, and if so send it direct.
	;   Otherwise we will ALWAYS use RCB$W_DRT for output (ignoring R4).
	;
	;   Note that RCB$W_DRT is always guaranteed to be either the ADJ
	;   index of the "designated" router or the ADJ index of the LPD's
	;   "main" adjacency.
	;
	;	Try the CACHE first! The CACHE is pointed to by the LPD,
	;	we find the LPD to scan from RCB$W_DRT.
	;
	MOVZBL	#LPD$C_LOC_INX,R7	; Assume we use the "local" LPD
	CMPW	R4,RCB$W_ADDR(R2)	; Is destination node address ourself?
	BEQL	240$			; Br if yes - use "local" LPD
	MOVZWL	RCB$W_DRT(R2),R7	; Get ADJ index for output ADJ
	BEQL	160$			; Br if none available - DENY
	MOVL	@RCB$L_PTR_ADJ(R2)[R7],R9 ; Get ADJ address
	MOVZBL	ADJ$B_LPD_INX(R9),R8	; Get LPD index for this adjacency
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	BGEQ	160$			; If GEQ then slot not in use - DENY
	BSBW	SCAN_CACHE		; Scan the cache for this LPD
	;
	;	If LBC, scan failed.
	;	We already started with DRT, so we already have R9 -> ADJ.
	;
	BLBC	R0,300$			; Continue in common path
	;
	;	If LBS, scan successful. We must use "main" ADJ, since the
	;	"main" ADJ will always have the RUN bit turned off.
	;
200$:	MOVZBL	LPD$B_PTH_INX(R8),R7	; Pick up "main" ADJ index
	MOVL	@RCB$L_PTR_ADJ(R2)[R7],R9 ; Get ADJ address
	BRB	300$			; Continue in common path
	
SOL_AREA:				; Solicit request for Level 2 Router
	BBS	#RCB$V_LVL2,-		; If we are not allowed to do
		RCB$B_STATUS(R2),220$	; Level 2 routing,
	BRW	SOL_PH4			; Then act like a Level 1 router
220$:	;
	;   First we MUST find the output ADJ based on the node address given
	;   the destination node address supplied in R4.
	;
	;   Determine the output LPD from the output adjacency.
	;
	TSTB	R1			; Is this for area 0?
	BEQL	140$			; Br if yes - our "logical" area
	CMPB	R1,RCB$B_HOMEAREA(R2)	; Are we in the same area?
	BEQL	140$			; Br if yes - same as Level 1 Router
	CMPB	R1,RCB$B_MAX_AREA(R2)	; Is the destination area in range?
	BGTRU	NOT_REACH		; Br if not - node unreachable
	MOVZWL	@RCB$L_PTR_AOA(R2)[R1],R7 ; Get the next area ADJ index
	BEQL	NOT_REACH		; Br if not known - node unreachable

240$:	;
	; At this point:
	;
	;		R7 = Adj index
	;		R3 = LPD index or zero
	;
	MOVL	@RCB$L_PTR_ADJ(R2)[R7],R9 ; Get ADJ address
260$:	;
	; At this point:
	;
	;		R9 = Adj address
	;		R7 = Adj index
	;		R3 = LPD index or zero
	;
	MOVZBL	R3,R8			; Get path index, 0 => select it via ADJ
	BNEQ	280$			; If NEQ then use it
	MOVZBL	ADJ$B_LPD_INX(R9),R8	; Use LPD index for this adjacency
280$:	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	BGEQ	NOT_REACH		; If GEQ then slot not in use
	ASSUME	LPD$V_ACTIVE  EQ  0	;
300$:	BLBC	LPD$W_STS(R8),NOT_REACH	; If LBC, circuit is inactive
	MOVL	#1,R0			; Success
	RSB				; Return with success

NOT_REACH:
	CLRQ	R8			; Clear ADJ and LPD address
	CLRL	R0			; No path available to node
	RSB

	.DSABL	LSB

;
;	Scan the on-NI cache for this LPD. Return success/failure in R0.
;	Inputs: R4 = node address to look for, R8 = addr of LPD.
;
SCAN_CACHE:
	MOVL	LPD$L_CACHE(R8),R0	; Get the CACHE table for this LPD
	BEQL	20$			; Br if none
	MOVZWL	-6(R0),R1		; Get number of entries in CACHE
	;
	;	Scan CACHE
	;
10$:	CMPW	(R0)+,R4		; Node address in cache?
	BEQL	30$			; Br if found
	TSTW	(R0)+			; Skip timer cell
	SOBGTR	R1,10$			; Keep looking
20$:	CLRL	R0			; Failure: node not in cache.
	RSB
30$:	MOVL	#1,R0			; Success: found node in cache.
	RSB


	.SBTTL  TR$RCV_DIO_DATA - Rcv Direct I/O from datalink layer

;+
;  TR$RCV_DIO_DATA - Receive Direct I/O from datalink layer
;
;
;  The IRP is being returned by the data link driver after a receive operation.
;  Statistics are taken and the packet is routed to its destination.
;
;  The action is to remove the buffer from the IRP and to requeue the IRP to 
;  the same device for another receive.  The route-header in the message is 
;  parsed to determine the circuit over which the message is to be forwarded.  
;  A transmit IRP is allocated in order to shuttle the buffer to the device.  
;
;
;  INPUTS:	R5	"Internal" IRP address
;		R4-R0	Scratch
;
;		IPL	IPL$_IOPOST  or  NET$C_IPL
;
;  OUTPUTS:	R5-R0	Garbage
;
;		IPL	Same as entry
;
;-	
TR$RCV_DIO_DATA::			; Rcv Direct I/O data from datalink
	DSBINT	#NET$C_IPL		; Raise IPL
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Save regs
					;
	MOVL	IRP$L_ASTPRM(R5),R2	; Get RCB
	MOVZBL	IRP$L_AST(R5),R8	; Get index of IRP's LPD
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	MOVZWL	RCB$W_TOTBUFSIZ(R2),R1	; Get total buffer size assuming
					; 6 byte route header
	ADDL	#TR$C_MAXHDR-6,R1	; Adjust to account for largest
					; possible route header (NI)
	ADDW	#2,R1			; Add 2 bytes for CRC16 just in case
					; this is an X.25 DLM datalink
	SUBW3	#CXB$C_OVERHEAD,-	; Reset byte count
		R1,IRP$W_BCNT(R5)	; 
	;
	;
	;   Detach the CXB from the IRP.  Setup the BUFFAIL flag in CXB$B_R_FLG
	;   according to whether or not there is a spare CXB in the free queue.
	;
	;
	MOVL	IRP$L_IOSB(R5),R6	; Get buffer (CXB) address
	CLRL	IRP$L_IOSB(R5)		; Erase former CXB pointer
	CLRB	CXB$B_R_FLG(R6)		; Init CXB flags
30$:	CMPL	RCB$Q_CXB_FREE(R2),-	; Any CXB's on free queue ?
		@RCB$Q_CXB_FREE(R2)	; 
	BNEQ	100$			; If NEQ then yes
	BSBW	TR$ALLOCATE		; Else allocate one
	MOVL	R2,R1			; Copy buffer address
	MOVL	IRP$L_ASTPRM(R5),R2	; Recover RCB address
	BLBC	R0,40$			; If LBC then allocation failure
	INSQUE	(R1),@RCB$Q_CXB_FREE(R2); Insert it on the queue
	BRB	100$			; Continue
40$:	INCB	CXB$B_R_FLG(R6)		; Set BUFFAIL status in CXB
100$:	;
	;
	;   Process the message and then requeue the Rcv IRP.  Upon return
	;   from RCV_DIO_BIO, only the following register contents are valid:
	;
	;	
	;	R6  =  CXB pointer (0 if no CXB)
	;	R5  =  IRP pointer (0 if IRP has disappeared -- in which case
	;			      the CXB has been deallocated as well)
	;	R2  =  RCB address
	;
	;
	BSBW	RCV_DIO_BIO		; Goto common code
	MOVL	R5,R3			; Copy IRP address
	BEQL	200$			; If EQL none
	MOVL	R6,IRP$L_IOSB(R3)	; Store CXB address
	BNEQ	150$			; If NEQ then CXB was still there
	MOVL	IRP$L_ASTPRM(R3),R2	; Get RCB address
	REMQUE	@RCB$Q_CXB_FREE(R2),R6	; Get the CXB stored there
	BVC	140$			; If VC then got one
	BUG_CHECK  NETNOSTATE,FATAL	; CXB should have been there
140$:	MOVL	R6,IRP$L_IOSB(R3)	; Store CXB address
150$:	MOVAB	CXB$C_HEADER(R6),(R6)	; Setup message address (used for 
					; common processing with buffered I/O)
	;
	;
	;   Finish setting up IRP and requeue it to the datalink
	;
	;
	MOVL	(R6),R4			; Get msg address
	MOVL	G^MMG$GL_SPTBASE,R6	; Get system page table base
	EXTZV	S^#VA$V_VPN,-		; Get Virtual page frame number
		S^#VA$S_VPN,R4,R1	;
	MOVAL	(R6)[R1],-		; Enter SVAPTE
		IRP$L_SVAPTE(R3)	;
	BICW3	#^C<VA$M_BYTE>,R4,-	; Enter page offset of msg
		IRP$W_BOFF(R3)		;
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	JSB	G^EXE$ALTQUEPKT		; Requeue the receive
200$:	;
	;
	;   Done.  The IRP has been requeued.  Return empty-handed to the EXEC
	;
	;
	POPR	#^M<R6,R7,R8,R9,R10>	; Restore regs
	ENBINT				; Restore IPL
	RSB				; Return to Exec


	.SBTTL	TR$RCV_BIO_DATA - Rcv Buffered I/O from datalink layer

;+
;  TR$RCV_BIO_DATA - Receive Buffered I/O from datalink layer
;
;
;  The IRP is being returned by the data link driver after a receive operation.
;  Statistics are taken and the packet is routed to its destination.
;
;  The action is to remove the buffer from the IRP and to requeue the IRP to 
;  the same device for another receive.  The route-header in the message is 
;  parsed to determine the circuit over which the message is to be forwarded.  
;  A transmit IRP is allocated in order to shuttle the buffer to the device.  
;
;
;  INPUTS:	R5	"Internal" IRP address
;		R4-R0	Scratch
;
;		IPL	IPL$_IOPOST  or  NET$C_IPL
;
;  OUTPUTS:	R5-R0	Garbage
;
;		IPL	Same as entry
;
;-	
TR$RCV_BIO_DATA::			; Rcv Buffered I/O data from datalink
	DSBINT	#NET$C_IPL		; Raise IPL
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Save regs
					;
	MOVZBL	IRP$L_AST(R5),R8	; Get address of IRP's LPD
	MOVL	IRP$L_ASTPRM(R5),R2	; Get RCB address
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	MOVL	IRP$L_SVAPTE(R5),R6	; Get buffer (CXB) address
	BEQL	20$			;
	CLRB	CXB$B_R_FLG(R6)		; Assume CXB is available
	BBC	#XM$V_STS_BUFFAIL,-	; If BS then DLL receive has
		IRP$L_IOST2(R5),20$	; run out of receive buffers
	INCB	CXB$B_R_FLG(R6)		; Mark CXB as unavailable
20$:	;
	;
	;   Process the message and then requeue the Rcv IRP.  Upon return
	;   from RCV_DIO_BIO, only the following register contents are valid:
	;
	;	
	;	R6  =  CXB pointer (0 if no CXB)
	;	R5  =  IRP pointer (0 if IRP has disappeared -- in which case
	;			      the CXB has been deallocated as well)
	;	R2  =  RCB address
	;
	;
	BSBW	RCV_DIO_BIO		; Goto common code
	MOVL	R5,R3			; Copy IRP address
	BEQL	200$			; If EQL none
	MOVL	R6,IRP$L_SVAPTE(R3)	; Send CXB back with IRP (0 if no CXB)
	MOVW	#^X<3FFF>,IRP$W_BCNT(R3); Reset Byte count
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	BNEQ	70$			; If NEQ then "real" datalink
	BSBW	TR$LOC_DLL_RCV		; Else, "Local LPD"
	BRB	200$			; Continue
70$:	JSB	G^EXE$ALTQUEPKT		; Requeue the receive
200$:	;
	;
	;   Done.  The IRP has been requeued.  Return empty-handed to the EXEC
	;
	;
	POPR	#^M<R6,R7,R8,R9,R10>	; Restore regs
	ENBINT				; Restore IPL
	RSB				; Return to Exec


	.SBTTL	RCV_DIO_BIO	- Common Receive IRP processing

;+
;  RCV_DIO_BIO	- Common Receive IRP processing
;
;  Finish processing of the received buffer. Determine size of message
;  and check for success of the read request.
;
;  INPUTS:	R10,R9	Scratch
;		R8	LPD ptr
;		R6	Message buffer pointer
;		R5	"Internal" IRP address
;		R3-R4	Scratch
;		R2	RCB ptr
;		R0-R1	Scratch
;
;  OUTPUTS:	R8,R7	Garbage
;		R6	Address of buffer to deallocate
;			0 if no buffer is to be deallocated
;		R5-R0	Garbage
;
;-
RCV_DIO_BIO:				; Common buffered/direct receive code
	MOVW	S^#IO$_READLBLK,-	; Reset I/O function code
		IRP$W_FUNC(R5)		;
	CLRL	IRP$L_SVAPTE(R5)	; Indicate no buffer attached
	BLBC	IRP$L_IOST1(R5),50$	; Br if I/O was unsuccessful
	;
	;
	;   Process the received message 
	;
	;
	MOVZWL	IRP$L_IOST1+2(R5),R7	; Get transfer size
	BEQL	40$			; If EQL, no message

	BLBC	CXB$B_R_FLG(R6),20$	; If BC then datalink doesn't need the
					; buffer back (i.e., no BUFFAIL)
	TSTL	IRP$L_UCB(R5)		; Is there a UCB ?
	BEQL	20$			; If EQL no, the "Local LPD"
	INCPMS	RCVBUFFL		; Update the PMS counter
	BSBB	20$			; Dispatch on message type
	TSTL	R6			; Was buffer consumed?
	BNEQ	40$			; If not, then return IRP/CXB to caller
	MOVL	R5,LPD$L_RCV_IRP(R8)	; Save the IRP address  -- its
					; presence also serves as a flag
	CLRL	R5			; Don't requeue this IRP to datalink
	BRB	40$			; Exit
	;
	;   Normal case.  Datalink is not starved for receive buffers.
	;

20$:	MOVW	IRP$Q_STATION+4(R5),-	; Get source node address
		CXB$W_R_SRCNOD(R6)	;  save it in the CXB
	PUSHL	R5			; Save IRP address
	CLRL	R5			; Make sure DISP doesn't use IRP
	BSBB	DISP_RCV_MSG		; Dispatch rcv'd message
	POPL	R5			; Recover IRP address, fix stack
					;
40$:	RSB				;


50$:	;
	;
	;   The Datalink has gone inactive.  Requeue the IRP to the ACP to 
	;   inform it of this event and dellocate the I/O buffer.
	;
	;
	MOVL	R6,IRP$L_IOSB(R5)	; Setup CXB address for deallocation
	BSBW	TR_RTRN_IRP		; LPD is shutting down, return IRP
	CLRL	R6			; Indicate the CXB was consumed
	RSB				; Done


	.SBTTL	DISP_RCV_MSG	Dispatch rcv'd message

;+
;  DISP_RCV_MSG	- Dispatch rcv'd message
;
;  Process the received message by dispatching to the appropriate action 
;  routine.  The most frequent case is a message with a Phase III route-header.
;
;  All ECL message type codes are currently constrained to have their low two
;  bits clear so that they may be distinguished from Transport message headers.
;  The first byte of the received message should be one of the following:
;
;
;	<0000 1000>	Phase II NOP
;	<0101 1000>	Phase II Start
;
;	<0100 xx10>	Phase II route header
;	<000x x010>	Phase III route header
;	<000x x010>	Phase IV non-broadcast circuit route header
;	<00xx 0x10>	Phase IV broadcast circuit route header
;	
;	<0000 0001>	Phase III init
;	<0000 0011>	Phase III verification
;	<0000 0101>	Phase III hello message
;	<0000 0111>	Phase III routing message
;	<0000 1001>	Phase IV Level 2 routing message
;	<0000 1011>	Phase IV broadcast circuit Router Hello message
;	<0000 1101>	Phase IV broadcast circuit Endnode Hello message
;
;  All ECL message type codes are currently contrained to have their low
;  two bit clear so that they may be distinguished from Transport message
;  headers.
;
;
;  INPUTS:	R10,R9	Scratch
;		R8	LPD ptr
;		R7	Total bytes in message
;		R6	Message buffer pointer
;		R3-R5	Scratch
;		R2	RCB ptr
;		R0-R1	Scratch
;
;  OUTPUTS:	R8,R7	Garbage
;		R6	Address of buffer to deallocate
;			0 if no buffer is to be deallocated
;		R5-R0	Garbage
;
;-
DISP_RCV_MSG:				; Dispatch rcv'd message
	MOVB	#DYN$C_CXB,CXB$B_TYPE(R6) ; Store standard buffer type
	MOVL	(R6),R1			; Get msg address
	MOVW	LPD$W_PTH(R8),-		; Setup receive path i.d.
		CXB$W_R_PATH(R6)	;
	MOVW	RCB$W_ADDR(R2),-	; Setup default destination node
		CXB$W_R_DSTNOD(R6) 	; (assume non-route-thru)
	MOVZBW	LPD$B_PTH_INX(R8),-	; Store LPD index as ADJ index
		CXB$W_R_ADJ(R6)		; (in case we need to send to ACP)
	;
	; For the X.25 circuits we will calculate the CRC16 on the
	; data portion of the message and check to make sure the data
	; is valid.
	;
	BBC	#LPD$V_X25,LPD$W_STS(R8),9$ ; Br if not X.25 path
	SUBL	#2,R7			; Remove CRC from size
	BLEQ	3$			; If received size = 0-2, report error
	MOVQ	R1,-(SP)		; Save registers
	CRC	CRC16,#0,R7,2(R1)	; Calculate CRC16 on data
	MOVQ	(SP)+,R1		; Restore registers
	CMPW	R0,(R1)+		; Does the CRC match?
	BEQL	5$			; Br if okay
3$:	BRW	PFE			; Else, treat as Format Error

5$:	MOVL	R1,(R6)			; Reset message pointer

9$:	;
	;   Strip off leading pad bytes
	;
	BBCC	#7,(R1),10$		; Br if not padded
	MOVZBL	(R1),R0			; Pick up pad length
	ADDL	R0,R1			; Point to first byte of message
	MOVL	R1,(R6)			; Reset message pointer
	SUBL	R0,R7			; Adjust message length
	BLEQ	3$			; Br if bad message
10$:	;
	;   Find the adjacency using the source address of the message.
	;
	BBC	#LPD$V_BC,-		; Br if NOT a Broadcast circuit
		 LPD$W_STS(R8),40$ 	;
	;
	;	Get address of the "Designated OA", DRT.
	;
	CMPB	#ADJ$C_PTY_PH4N,-	; Are we an Endnode?
		LPD$B_ETY(R8)		; ..checked on LPD
	BNEQ	15$			; Br if NOT
	MOVZWL	LPD$W_DRT(R8),R4	; Get designated output adjacency index
	MOVL	@RCB$L_PTR_ADJ(R2)[R4],R9 ; Get ADJ address
	BRB	60$			; Continue in common code
15$:	;
	;	For Broadcast Circuit, we will first try the OA vector
	;	to look for a match in the ADJ database. If we find a
	;	match then we've got the ADJ, else we will assume this
	;	message came from a Broadcast Router and scan the BRA
	;	portion of the ADJ vector.
	;
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the area number
		#TR4$S_ADDR_AREA,CXB$W_R_SRCNOD(R6),R3
	BEQL	18$			; If area = 0, assume our area
	CMPB	R3,RCB$B_HOMEAREA(R2)	; Our area?
	BNEQ	23$			; If not, then skip OA optimization
18$:	EXTZV	#TR4$V_ADDR_DEST,-	; Get node number within area
		#TR4$S_ADDR_DEST,CXB$W_R_SRCNOD(R6),R3
	CMPW	R3,RCB$W_MAX_ADDR(R2)	; Is address in range?
	BLEQU	20$			; Br if yes
	BRW	RANGE			; Else, address out of range
20$:	MOVZWL	@RCB$L_PTR_OA(R2)[R3],R4 ; Get ADJ index
	BEQL	23$			; Br if new adjacency
	MOVL	@RCB$L_PTR_ADJ(R2)[R4],R9 ; Get ADJ address
	CMPW	CXB$W_R_SRCNOD(R6),-	; Does the node address match?
		ADJ$W_PNA(R9)
	BNEQ	23$			; Br if not
	CMPB	ADJ$B_LPD_INX(R9),-	; Is this the right LPD?
		LPD$B_PTH_INX(R8)	;
	BEQL	60$			; Br if yes
	;
	;	Now try scan of entire ADJ database for the node
	;
23$:	MOVZWL	CXB$W_R_SRCNOD(R6),R3	; Get full source node address
	MOVZBL	RCB$B_MAX_LPD(R2),R4	; Get number of LPD's in system
	MOVZWL	RCB$W_MAX_ADJ(R2),R5	; Get number of routing "destinations"
	BNEQ	30$			; Start at BRA's, if any
	BRB	35$			; Else, skip it
25$:	MOVL	@RCB$L_PTR_ADJ(R2)[R4],R9 ; Get next ADJ
	CMPW	R3,ADJ$W_PNA(R9)	; Does the node address match?
	BNEQ	30$			; Br if no - skip to next ADJ
	CMPB	ADJ$B_LPD_INX(R9),-	; Is this the right LPD?
		LPD$B_PTH_INX(R8)	;
	BEQL	60$			; Br if yes
30$:	AOBLEQ	R5,R4,25$		; Loop if more BRA ADJ's
	;
	;     If scan fails, then use the "main" ADJ (where RUN flag is off)
	;
35$:	MOVZBL	LPD$B_PTH_INX(R8),R4	; Use the "main" ADJ
	MOVL	@RCB$L_PTR_ADJ(R2)[R4],R9 ; Get ADJ address
	BRB	60$			; Skip reset of listener timer

	;
	;  For non-Broadcast Circuit, use ADJ index in the LPD
	;
40$:	MOVZBL	LPD$B_PTH_INX(R8),R4	; Get the ADJ index (same as LPD index)
	MOVL	@RCB$L_PTR_ADJ(R2)[R4],R9 ; Get the ADJ address
	BBC	#ADJ$V_RUN,-		; If ADJ isn't up,
		ADJ$B_STS(R9),60$	; skip reset of listener timer
	MOVW	ADJ$W_INT_LSN(R9),-	; Reset "listen" interval
		ADJ$W_TIM_LSN(R9) 	; 

	;
	;   Save the source ADJ index in the CXB
	;
60$:	MOVW	R4,CXB$W_R_ADJ(R6)	; Save the source adjacency index
	;
	;   Journal the received message.
	;
	.IF	DF,JNX$$$

	MNEGB	#1,R0			; Set journal type = Received msg
	BSBW	TR_FILL_JNX		; Store journal record

	.ENDC

	;
	;   Parse the message and dispatch.
	;
	;   On input, R9 always points to an ADJ block.  If ADJ$V_RUN=0,
	;   then the message was received on an ADJ which hasn't yet been
	;   initialized.
	;

	MOVZBL	(R1)+,R5		; Get message type flag
	ASSUME	TR3$V_MSG_CTL  EQ  0
	BLBS	R5,80$			; If LBS then control msg
	BBC	#TR3$V_MSG_RTH,R5,75$	; If BC then NOT a route header
	CMPB	ADJ$B_PTYPE(R9),-	; If Phase II connection,
		#ADJ$C_PTY_PH2		; then skip VER check (since VER is
	BEQL	74$			; the same bit as RTFLG_PH2)
					; Else, for non-PH2 circuits,
	BBS	#TR4$V_RTFLG_VER,R5,90$	; If version bit set, ignore msg
74$:	BRW	TR_RTHDR		; Else, must be a route header
	;
	;   The message doesn't have a router header.  Assume Phase II
	;
75$:	CMPB	R5,#TR3$C_MSG_NOP2	; NOP message ?
	BEQL	90$			; If EQL yes, ignore it
	CMPB	R5,#TR3$C_MSG_STR2	; Is it a Start message ?
	BEQL	85$			; EQL => UNKNOWN MESSAGE
	;
	;   It's a Phase II data message.  Since the message didn't
	;   have any route header, we must store the source node from
	;   the adjacency for this circuit.
	;
	BBC	#ADJ$V_RUN,-		; If the ADJ is not known,
		ADJ$B_STS(R9),77$	; then leave node address  = 0
	MOVW	ADJ$W_PNA(R9),-		; Save source node address
		CXB$W_R_SRCNOD(R6)
77$:	MOVL	(R6),R1			; Point to first msg byte
	BRW	TR_ECL			; Pass to ECL layer

	;
	;   NOTE - All offsets to the "Hello" message are off by 1 byte -
	;	   from MOVZBL (R1)+... above.
	;
80$:					; Transport layer control msg
	CMPB	#TR3$C_MSG_HELLO,R5	; "Hello" msg ?
	BEQL	90$			; If EQL yes, ignore it
	CMPB	#TR4$C_MSG_BCEHEL,R5	; Phase IV BC Endnode "Hello" msg?
	BEQL	100$			; Br if yes
	CMPB	#TR4$C_MSG_BCRHEL,R5	; Phase IV BC router "Hello" msg?
	BEQL	ADJ_UP			; Br if yes
85$:	BRW	UNK			; Else message type unknown
90$:	RSB				; Done

	;
	;   Process a broadcast endnode "Hello" msg, reset "listener" timer.
	;
100$:	BBC	#ADJ$V_RUN,-		; If the ADJ is not known,
		ADJ$B_STS(R9),ADJ_UP	; report "new adjacency" to NETACP
	CMPL	R7,#30			; Is message big enough?
	BLEQ	PFE_BR			; Br if not, error
	CMPB	ADJ$B_PTYPE(R9),-	; Has the node type changed?
		#ADJ$C_PTY_PH4N
	BNEQ	ADJ_UP			; Br if yes, adjacency up
	CMPW	10(R1),ADJ$W_BUFSIZ(R9)	; Is BLKSIZ still okay?
	BNEQ	ADJ_UP			; Br if not, adjacency up
	MOVW	ADJ$W_INT_LSN(R9),-	; Else, Reset "listen" timer
		ADJ$W_TIM_LSN(R9)
	BRB	90$			; And ignore the msg
ADJ_UP:					; Adjacency UP event
	;
	;   Adjacency up processing, if we receive a Router's Broadcast
	;   Hello message, then let the NETACP reset the "listener" timer.
	;
	MOVB	#NETMSG$C_ADJ,R0	; Set up event code
	BRW	TO_ACP			; Pass it to the ACP

PFE_BR:	BRW	PFE			; Packet format error

	.SBTTL	TR_RTHDR	- Process rcv'd msg's route header

;+
;
;  TR_RTHDR	- Process received message's route header
;
;
;  INPUTS:	R10	Scratch
;		R9	ADJ address (RUN flag may be "off")
;		R8	LPD address
;		R7	Message size
;		R6	CXB address
;		R5	Contents of first byte in message
;		R4,R3	Scratch
;		R2	RCB address
;		R1	Ptr to second byte in message
;		R0	Scratch
;
;  OUTPUTS:	R6	0 if CXB was consumed, else preserved
;
;
;-
TR_RTHDR:				; Process rcv'd msg's route-header
	BBC	#TR3$V_RTFLG_PH2,R5,20$	; If BC then Phase III route-header
	;
	;
	;   Process Phase II header
	;
	;
	BBC	#ADJ$V_RUN,ADJ$B_STS(R9),10$ ; Br if "main" ADJ
	MOVW	ADJ$W_PNA(R9),-		; Save source node address
		CXB$W_R_SRCNOD(R6)
10$:	MOVZBL	(R1)+,R0		; Get size of dest. node name
	ADDL	R0,R1			; Advance to src node name
	SUBW	R0,R7			; Subtract from total
	MOVZBL	(R1)+,R0		; Get size of src node name
	SUBW	R0,R7			; Subtract from total
	ADDL	R0,R1			; Advance pointer
	SUBW	#3,R7			; Account for count field and
					; msg type bytes
	BLEQ	PFE_BR			; If LEQ, report Packet Format Error
	BRW	100$			; Else, continue in common
20$:	;
	;
	;   Process Phase III or Phase IV route header
	;
	;
	BBS	#TR4$V_RTFLG_LNG,-	; Is this a Phase IV long packet?
		R5,50$			; If so, parse as such
	;
	;	Process only Phase III and Phase IV non-broadcast route hdr
	;
	SUBW	#6,R7			; Account for message header
	BLEQ	PFE_BR			; Br if packet format error
	MOVZWL	(R1)+,R0		; Get destination node address
	MOVZWL	(R1)+,R4		; Get the source node address
	ASSUME	ADJ$C_PTY_PH3 EQ 0
	ASSUME  ADJ$C_PTY_PH3N EQ 1
	CMPB	ADJ$B_PTYPE(R9),-	; Is this a Phase III node's msg?
		#ADJ$C_PTY_PH3N		;
	BGTRU	30$			; Br if not
	INSV	RCB$B_HOMEAREA(R2),-	; Else, fill in the Area of the dst
		#TR4$V_ADDR_AREA,-	;  node address with our "homearea"
		#TR4$S_ADDR_AREA,R0	;
	MOVW	R0,-4(R1)		; Reset the dst node address in msg
	CMPZV	#TR4$V_ADDR_AREA,-	; Is the source "area"
		#TR4$S_ADDR_AREA,R4,#0	;   zero?
	BNEQ	30$			; Br if no - leave it alone
	INSV	RCB$B_HOMEAREA(R2),-	; Else, fill in the Area of the source
		#TR4$V_ADDR_AREA,-	;  node address with our "homearea"
		#TR4$S_ADDR_AREA,R4	;
	MOVW	R4,-2(R1)		; Stuff it back into the message
30$:	MOVW	R4,CXB$W_R_SRCNOD(R6)	; Save the source node address
	CMPW	RCB$W_ADDR(R2),R0	; Is this for the local node?
	BEQL	80$			; If EQL then its for ECL
	CMPW	RCB$W_ALIAS(R2),R0	; Is this for our alias?
	BEQL	80$			; If EQL then its for ECL
	TSTW	R0			; We boot with address 0
					;& is this extra check really needed?
	BEQL	80$			; If EQL then its for ECL
	MOVAB	1(R1),R4		; Point to start of data
40$:	BRW	TR_RTHRU		; Else, its a route-thru packet

	;
	;   Process a Phase IV Broadcast Circuit header (long format)
	;
50$:	SUBW	#21,R7			; Account for message header
	BLEQ	PFE_BR			; If LEQ, report Packet Format Error
	ADDL	#6,R1			; Skip S-AREA and S-SUBAREA and HIORD
	MOVZWL	(R1)+,R0		; Get Destination address
	ADDL	#6,R1			; Skip S-AREA and S-SUBAREA and HIORD
	;
	;  If this is an Endnode circuit, then update the endnode cache
	;
	CMPB	#ADJ$C_PTY_PH4N,-	; Are we an endnode?
		LPD$B_ETY(R8)		; ..on this LPD (only PH4 can have BCs)
	BNEQ	55$			; Br if not
	BBC	#LPD$V_BC,-		; Br if NOT a Broadcast Circuit
		LPD$W_STS(R8),55$	;& ..this check may be redundant!
	BBS	#TR4$V_RTFLG_RTS,R5,55$ ; Br if this is an RTS packet,
					; then the source address is invalid
	BSBW	UPDATE_CACHE		; Else, update the cache entry
55$:	MOVW	(R1)+,CXB$W_R_SRCNOD(R6); Enter the source node address
	INCL	R1			; Skip over NEXT LEVEL 2 ROUTER
	CMPW	RCB$W_ADDR(R2),R0	; Is this for the local node?
	BEQL	60$			; Br if yes - okay
	CMPW	RCB$W_ALIAS(R2),R0	; Is this for the local alias?
	BEQL	60$			; Br if yes - okay
	MOVAB	3(R1),R4		; Assume route thru message, preset
					; R4 to point past the header
	TSTW	R0			; We boot with address 0
					;& is this extra check really needed?
	BNEQ	40$			; Br if no - route the packet thru
	CMPL	#TR4$C_HIORD,-7(R1)	; Does source HIORD match?
	BNEQ	PFE			; Br if not - format error
	CMPL	#TR4$C_HIORD,-15(R1)	; Does destination HIORD match?
	BNEQ	PFE			; Br if not - format error
60$:	TSTW	(R1)+			; Skip VISIT and S-CLASS
80$:	INCL	R1			; Skip Protocol Type
100$:	ASSUME	TR4$V_RTFLG_RTS EQ TR3$V_RTFLG_RTS
	BBC	#TR3$V_RTFLG_RTS,R5,110$; Br if not return-to-sender packet
	BISB	#2,CXB$B_R_FLG(R6)	; Else, indicate a RTS packet
110$:					; Fall thru to TR_ECL


	.SBTTL	TR_ECL    	- Pass Rcv'd Packet to ECL

;+
;  TR_ECL	- Pass Packet to End Communications Layer
;
;  INPUTS:	R10,R9	Scratch
;		R8	LPD address associated with receiving datalink
;		R7	Size of ECL message 
;		R6	Received CXB address
;		R5-R3	Scratch
;		R2	RCB address
;		R1	Points to first byte in ECL message
;		R0	Scratch
;
;		CXB$W_R_SRCNOD	Source node address
;		CXB$W_R_DSTNOD	Destination node (the ECL) address
;		CXB$B_R_FLG	Low bit clear if CXB can be consumed
;				Low bit set if CXB must be returned
;		
;
;  OUTPUTS:	R8,R7	Garbage
;		R6	0 if CXB was consumed
;			Else, CXB address
;		R5-R0	Garbage
;
;
;-
TR_ECL:					; Pass rcv'd packet to ECL
	BUMP	L,LPD$L_CNT_APR(R8)	; Update 'arriving pkts rcvd'
	INCPMS	ARRLOCPK		; ... and the PMS database too
	MOVW	R7,CXB$W_R_BCNT(R6)	; Setup ECL message size
	MOVL	R2,CXB$L_R_RCB(R6)	; Setup RCB pointer
					;& perhaps CXB...RCB is not needed
	MOVL	R1,CXB$L_R_MSG(R6)	; Point to ECL message
	CMPZV	#TR4$V_ADDR_AREA,-	; If the source area number = 0,
		#TR4$S_ADDR_AREA,-
		CXB$W_R_SRCNOD(R6),#0
	BNEQ	10$
	INSV	RCB$B_HOMEAREA(R2),-	; then insert our home area
		#TR4$V_ADDR_AREA,-	; to ensure that NSP matches node
		#TR4$S_ADDR_AREA,-	; numbers correctly
		CXB$W_R_SRCNOD(R6)
10$:	;
	;
	;   Call the ECL layer with the following:
	;
	;	R8	Scratch
	;	R7	Size of ECL message 
	;	R6	Received CXB address
	;	R5-R3	Scratch
	;	R2	RCB address
	;	R1	Points to first byte in ECL message
	;	R0	Scratch
	;
	;	CXB$L_R_RCB	RCB address		(copy of R2)
	;	CXB$L_R_MSG	Points to ECL message	(copy of R1)
	;	CXB$W_R_BCNT	Size of ECL message	(copy of R7)
	;	CXB$W_R_SRCNOD	Source node address
	;	CXB$W_R_DSTNOD	Destination node (the ECL) address
	;	CXB$B_R_FLG	Low bit clear if CXB can be consumed
	;			Low bit set if CXB must be returned
	;			Second bit clear if no return-to-sender packet
	;			Second bit set if packet returned-to-sender
	;	CXB$W_R_PATH	I.D. of receiving LPD
	;
	;
	;   On return here:
	;
	;	R8,R7	Garbage
	;	R6	0 if CXB was consumed.  Else, CXB address with the 
	;		CXB$W_SIZE and CXB$B_TYPE fields unmodified.
	;	R5-R0	Garbage
	;
	;		
	BRW	NET$UNSOL_INTR		; Pass message to ECL layer



	.SBTTL	Packet Errors	- Process miscellaneous packet errors

;+
;
;  The packet (CXB) could not be routed thru.  Update the appropriate 
;  statistics.  Pass the packet to the ACP to report the event if necessary.
;
;
;  INPUTS:	R10	Scratch
;		R9	ADJ address or zero
;		R8	Applicable LPD address
;		R7	Message size
;		R6	CXB address
;		R5	Scratch
;		R2	RCB address
;		R0	Scratch
;
;  OUTPUTS:	R6	0 if CXB was consumed
;			Else unchanged
;		R5	Garbage
;		R0	Garbage
;
;		All other registers are preserved
;
;-
PFE:	BUMP	B,RCB$B_CNT_PFE(R2)	; Update packet format errors
	MOVB	#NETMSG$C_PFE,R0	; Setup event code
	BRB	TO_ACP			; Give it to the ACP
					;
OPL:	BUMP	B,RCB$B_CNT_OPL(R2)	; Update oversized packet loss
	MOVB	#NETMSG$C_OPL,R0	; Setup event code
	BRB	TO_ACP			; Pass the buffer to the ACP
					;
AGED:	BUMP	B,RCB$B_CNT_APL(R2)	; Update aged packet loss
	MOVB	#NETMSG$C_APL,R0	; Setup event code
	BRB	TO_ACP			; Pass it to the ACP
					;
REACH:	BUMP	W,RCB$W_CNT_NUL(R2)	; Update node unreachable loss
	MOVB	#NETMSG$C_NUL,R0	; Setup event code
	BRB	TO_ACP			; Pass it to the ACP
					;
RANGE:	BUMP	B,RCB$B_CNT_NOL(R2)	; Update node address out of range loss
	MOVB	#NETMSG$C_NOL,R0	; Setup event code
	BRB	TO_ACP			; Pass it to the ACP
					;
UNK:					; Unknown message type
	MOVB	#NETMSG$C_UNK,R0	; Set up event code

;
;  Send an indication to NETACP that there is a problem on this datalink.
;  This is done by transforming the CXB into what looks like NETACP's WQE
;  block (assuming that the fields don't overlap), and queueing it to the
;  AQB.  It is important that the block type remains DYN$C_CXB since
;  NETACP dispatches on block type.
;
;
;  INPUTS:	R0 = NETMSG$C_xxx code
;		R7 = Message size
;		R6 = CXB address
;
;
TO_ACP:	MOVW	R7,WQE$L_PM2+2(R6)	; Setup size of msg
	MOVZWL	CXB$W_R_ADJ(R6),R5	; Get ADJ index for source node
	SUBW3	R6,(R6),WQE$L_PM2(R6)	; Setup offset to msg
	MOVB	R0,WQE$B_EVT(R6)	; Setup event code
	MOVW	R5,WQE$W_ADJ_INX(R6)	; Store ADJ index in WQE
	MOVL	R6,R5			; Get buffer address
	CLRL	R6			; Flag it as gone
	BSBW	TR$QUE_WQE_AQB		; Queue it to the AQB
	RSB

	.SBTTL	TR_RTHRU	- Process packet for route-thru

;+
;  TR_RTHRU	- Process packet for route-thru
;
;  INPUTS:	R10	Scratch
;		R9	ADJ address of receiving adjacency
;		R8	LPD address of receiving datalink
;		R7	message size (excluding header)
;		R6	CXB address
;		R5	Contents of first byte in message
;		R4	Ptr to message past the header
;		R3	Scratch
;		R2	RCB address
;		R1	Ptr to messages's VISIT field in route-header
;		R0	Destination node address
;
;  IMPLICIT INPUTS:
;
;		CXB$W_R_SRCNOD = Node address of source of message
;
;  OUTPUTS:	R8,R7	Garbage
;		R6	0 if CXB was consumed.  
;			Else CXB address
;		R5-R0	Garbage
;
;		
;-
TR_RTHRU:				; Process packet for route-thru
	;
	;
	;   Route-thru packet
	;
	;
	BBC	#RCB$V_ACT,-		; If ACP is not active, then return
		RCB$B_STATUS(R2),2$	;   packet to sender
	$DISPATCH LPD$B_ETY(R8),TYPE=B,- ; Return packet if we are an Endnode
	<-
		<ADJ$C_PTY_PH3N 2$>,-	; Phase III endnode
		<ADJ$C_PTY_PH4N 2$>,-	; Phase IV endnode
	>
	BUMP	L,LPD$L_CNT_TPR(R8)	; Bump 'transit packets rcvd'
	INCPMS	ARRTRAPK		; ... and the PMS database too
	PUSHL	R8			; Save LPD that we received packet on
	BSBW	ROUTE			; Re-route the packet
	POPL	R8			; Restore receiving LPD address
	TSTL	R6			; Was packet consumed?
	BEQL	5$			; If EQL then yes
2$:	;
	;   Return Packet to Sender
	;
	;   If the packet was not sent we must return the packet to
	;   the sender, but only if the sender has requested it.
	;
	;   Swap the source and destination node addresses, repair the 
	;   VISITs field, reset R0 and R8, and route the packet to its source.
	;
	;   The request return to sender is different for Phase IV Broadcast
	;   packet headers - so we will parse that separately.
	;
	BBS	#TR4$V_RTFLG_LNG,R5,10$ ; Br if Phase IV long format
	BBCC	#TR3$V_RTFLG_RQR,R5,5$ ; Br if return not requested
	BBSS	#TR3$V_RTFLG_RTS,R5,5$ ; If BS then already being returned
	MOVL	(R6),R1			; Get message address
	MOVB	R5,(R1)+		; Reset control flags
	MOVW	R0,R3			; Save output node address
	MOVZWL	CXB$W_R_SRCNOD(R6),R0	; Get node address of orignal src node
	MOVW	R3,CXB$W_R_SRCNOD(R6)	; Set new src node address
	ROTL	#16,(R1),(R1)+		; Swap src, dst node addresses
	DECB	(R1)			; Repair VISITs field
	ADDL3	#1,R1,R4		; R4 points to start of data
	BSBB	ROUTE			; Route the packet to its sender
5$:	RSB				; Done
	;
	;   Phase IV long packet format - return to sender
	;
10$:	BBCC	#TR4$V_RTFLG_RQR,R5,20$ ; Br if return not requested
	BBSS	#TR4$V_RTFLG_RTS,R5,20$	; If BS, then already being returned
	MOVL	(R6),R1			; Get message address
	MOVB	R5,(R1)			; Reset control flags
	MOVW	R0,R3			; Save output node address
	MOVZWL	CXB$W_R_SRCNOD(R6),R0	; Get node address of orignal src node
	MOVW	R3,CXB$W_R_SRCNOD(R6)	; Set new src node address
	MOVW	7(R1),-(SP)		; Save old destination node address
	MOVW	15(R1),7(R1)		; Set new destination node address
	MOVW	(SP)+,15(R1)		; Set new source node address
	ADDL	#18,R1			; Point to VISITs field of message
	DECB	(R1)			; Repair VISITs field
	ADDL3	#3,R1,R4		; R4 points to start of data
	BSBB	ROUTE			; Route the packet to its sender
20$:	RSB				; Done


CHECK_RQR:				; Check if return requested
	ASSUME	TR3$V_RTFLG_RQR EQ TR4$V_RTFLG_RQR
	ASSUME	TR3$V_RTFLG_RTS EQ TR4$V_RTFLG_RTS
	BBC	#TR3$V_RTFLG_RQR,R5,20$ ; Br if return not requested
	BBS	#TR3$V_RTFLG_RTS,R5,20$ ; If BS then already being returned
	ADDL	#4,SP			; Return to callers caller
20$:	RSB


ROUTE:	BLBC	CXB$B_R_FLG(R6),10$	; If LBC, okay to forward packet
	BRW	100$			; Else, can't take packet - error
	;
	;
	;   Process the VISIT field to prevent infinite packet looping
	;
	;
10$:	INCB	(R1)			; Bump the VISIT field
	CMPB	RCB$B_MAX_VISIT(R2),(R1); Within VISIT range ?
	BGTRU	20$			; If GTRU then no violation
	ASSUME	TR3$V_RTFLG_RTS EQ TR4$V_RTFLG_RTS
	BBC	#TR3$V_RTFLG_RTS,R5,15$	; If BC then packet is not being 
					;  returned to its original sender
	MULB3	#2,RCB$B_MAX_VISIT(R2),-(SP) ; Else allow twice MAX_VISITS
	CMPB	(R1),(SP)+		; 
	BLSS	20$			; If LSS then let it return to sender
15$:	BRW	110$			; Else, report AGED Packet Loss

20$:	;
	;
	;    Determine the output adjacency for the packet
	;
	;
	EXTZV	#TR4$V_ADDR_AREA,-	; Get the destination node "AREA"
		#TR4$S_ADDR_AREA,R0,R10	;
	EXTZV	#TR4$V_ADDR_DEST,-	; Get only the destination
		#TR4$S_ADDR_DEST,-	;  portion of the node address
		R0,R3			;
	;
	;	We must find the output adjacency based on the type of node
	;	we are and what the destination node "area" is.
	;
	$DISPATCH RCB$B_ETY(R2),TYPE=B,- ; Dispatch on our node type
	<-
		<ADJ$C_PTY_AREA	30$>,-	; Phase IV level 2 router
		<ADJ$C_PTY_PH4	40$>,-	; Phase IV level 1 router
	>
	BRB	50$			; All others
	;
	;   Phase IV Level 2 router.
	;
30$:	BBC	#RCB$V_LVL2,-		; If we are not allowed to do Level 2
		RCB$B_STATUS(R2),40$	; routing, then do Level 1 routing
	CMPB	R10,RCB$B_MAX_AREA(R2)	; Area within range?
	BGTRU	120$			; Br if no
	TSTB	R10			; Is this for our "logical" area 0?
	BEQL	50$			; Br if yes
	CMPB	R10,RCB$B_HOMEAREA(R2)	; Is this in our area?
	BEQL	50$			; Br if yes - just like Level 1 message
	MOVZWL	@RCB$L_PTR_AOA(R2)[R10],R3 ; Else, get "area" output adjacency
	BRB	60$			; Finish in common code
	;
	;   Phase IV level 1 router
	;	
40$:	CMPB	R10,RCB$B_HOMEAREA(R2)	; Is this in our area?
	BEQL	50$			; Br if yes
	MOVZWL	RCB$W_LVL2(R2),R3	; Else, get our nearest level 2 router
	BRB	60$			; Finish in common code
	;
	;   All destinations for our area
	;
50$:	CMPW	R3,RCB$W_MAX_ADDR(R2)	; Within range?
	BGTRU	120$			; If GTRU then out of range
	MOVZWL	@RCB$L_PTR_OA(R2)[R3],R3; Get the output adjacency index
					; Don't clobber R9 yet in case EQL
	;
	;   Common proccessing
	;
	;	Inputs:
	;		R3 = ADJ index
	;
60$:	BEQL	130$			; If EQL then unreachable
	MOVL	@RCB$L_PTR_ADJ(R2)[R3],R9 ; Get ADJ address
	BBC	#ADJ$V_RUN,-		; Br if adjacency is not up
		 ADJ$B_STS(R9),130$	;
	MOVZBL	ADJ$B_LPD_INX(R9),R3	; Get LPD index for this adjacency
	BEQL	130$			; Br if no output path
	MOVL	R8,R10			; Save receiving LPD address
	MOVL	@RCB$L_PTR_LPD(R2)[R3],R8 ; Get LPD address
	CMPB	 LPD$B_IRPCNT(R8),-	; Does "square-root-limiter" allow it?
		 LPD$B_XMT_SRL(R8)	;
	BGTR	100$			; If GTR then queue is full
	CMPW	R7,ADJ$W_BUFSIZ(R9)	; Is the message too big for partner?
	BGTRU	140$			; If GTRU then oversized
	PUSHL	R0			; Save destination node address
80$:	REMQUE	@RCB$Q_IRP_FREE(R2),R3	; Get an IRP
	BVC	200$			; If VC then got one
	BSBW	TR$ADJUST_IRP		; Replenish the IRP queue
	BLBS	R0,80$			; If LBS then there's an IRP
	POPL	R0			; Restore destination node address
100$:	BUMP	W,LPD$W_CNT_TCL(R8)	; Update resource error packet loss
	INCPMS	TRCNGLOS		; ... and the PMS database too
	RSB

110$:	BSBW	CHECK_RQR		; Check if return requested
	BRW	AGED			; Packet VISITs field violation
120$:	BSBW	CHECK_RQR		; Check if return requested
	BRW	RANGE			; Destination address to large
130$:	BSBW	CHECK_RQR		; Check if return requested
	BRW	REACH			; Destination address unreachable
140$:	MOVL	R10,R8			; Reset address of receiving LPD
	BSBW	CHECK_RQR		; Check if return requested
	BRW	OPL			; Packet too large to be forwarded

150$:	MOVZBL	@(R6),R5		; Get the flags byte again
160$:	INSQUE	(R3),RCB$Q_IRP_FREE(R2)	; Put back the IRP
	MOVL	R10,R8			; Reset address of receive LPD
	BSBW	CHECK_RQR		; Return packet if requested
	RSB				; Else, just drop it

200$:	POPL	R0			; Restore destination node address
	;
	;   We will prevent any route-thru traffic to Phase III nodes,
	;   if the source node is outside of our area. This is to prevent
	;   some implementions of DECnet from re-cycling the line on suspected
	;   packet format errors. There are no known implementations of Phase
	;   III DECnet that can handle the area field anyway.
	;
	$DISPATCH ADJ$B_PTYPE(R9),TYPE=B,-
	<-
		<ADJ$C_PTY_PH3N 210$>,-	; Phase III endnode
		<ADJ$C_PTY_PH3  210$>,-	; Phase III router
	>
	BRB	220$			; Else, okay
210$:	EXTZV	#TR4$V_ADDR_AREA,-	; Get the source id "area" address
		#TR4$S_ADDR_AREA,-	;
		CXB$W_R_SRCNOD(R6),R5	;
	CMPB	R5,RCB$B_HOMEAREA(R2)	; Is this our "homearea"?
	BNEQ	150$			; Br if not, not reachable to endnode
	MOVZBL	@(R6),R5		; Pick up flags byte again

220$:	BBC	#TR4$V_RTFLG_LNG,R5,270$ ; Br if NOT Phase IV long format header
	BBS	#LPD$V_BC,LPD$W_STS(R8),230$ ; Br if output is a broadcast circuit
	;
	; We are converting the long format to short format, clear INI and
	; long format flags, and check HIORD.
	;
	BICB	#TR4$M_RTFLG_INI!-	; Make sure the Intra-NI and
		 TR4$M_RTFLG_LNG,R5	;  long format flags are clear
	CMPL	#TR4$C_HIORD,-7(R1)	; Does source HIORD match?
	BNEQ	160$			; Br if not, packet format error
	CMPL	#TR4$C_HIORD,-15(R1)	; Does destination HIORD match?
	BNEQ	160$			; Br if not, packet format error
	BRB	240$			; Continue

230$:	;
	;   Check to make sure the OUTPUT LPD = the INPUT LPD, if not
	;   the same, then clear the Intra-Ethernet bit.  The Intra-NI
	;   flag has already been set by the originating node if it
	;   sent the packet over an Ethernet circuit, so all we have
	;   to do in the route-thru case is make sure we clear the flag
	;   when it leaves the Ethernet.
	;
	CMPW	CXB$W_R_PATH(R6),-	; Is the output LPD = input LPD?
		LPD$W_PTH(R8)
	BEQL	240$			; Br if yes, okay
	CLRBIT	#TR4$V_RTFLG_INI,R5	; Else, clear the Intra-Ethernet bit
240$:	;
	;   Build a standard Phase III type route header from the
	;   Phase IV long format header.
	;
	MOVB	(R1),-(R4)		; Backbuild the header - visits field
	MOVW	CXB$W_R_SRCNOD(R6),-(R4);   Store source node address
	MOVW	R0,-(R4)		;   Store destination node address
	MOVB	R5,-(R4)		;   Store route msg flag byte
	MOVL	R4,(R6)			; Reset start of message ptr
	;
	;   Done building header, adjust message size and ship it.
	;
270$:	MOVL	(R6),R1			; Point to start of message
	ADDW	#6,R7			; Account for header
	INCB	LPD$B_IRPCNT(R8)	; Account for IRP to be queued
	;
	;
	;   Build the IRP, attach the buffer, queue to communications driver
	;
	;
	ASSUME	IRP$L_AST     EQ  4+IRP$L_PID
	ASSUME	IRP$L_ASTPRM  EQ  4+IRP$L_AST

	MOVAB	IRP$L_PID(R3),R0	; Point to PID field
	MOVAB	W^TR$RTRN_XMT_RTH,(R0)+	; Setup return address
	MOVZWL	LPD$W_PTH(R8),(R0)+	; LPD i.d. into AST field
	MOVL	R2,(R0)+		; RCB address into ASTPRM

	ASSUME	IRP$L_WIND EQ 4+IRP$L_ASTPRM
					; Fall thru


	.SBTTL	FINISH_XMT_HDR	- Finish building HDR and transmit it

;+
;  FINISH_XMT_HDR   - Finish building HDR and transmit it
;
;  This routine will build a new Route Header based upon the output path.
;
;     The CXB is setup as follows:
;
;
;	+---------------+
;	|   standard    |	11 bytes long.  CXB$L_FLINK and CXB$L_BLINK may
;	|     VMS       |	be used by the Transport layer.  CXB$W_SIZE 
;	| buffer header |	must be correct.  CXB$B_TYPE must be DYN$C_CXB.
;	+---------------+
;	|               |	Starts with CXB$B_CODE (byte 11) and continues
;	|      ECL      |	to CXB$C_LENGTH.  This area is read-only to
;	|   pure area   |	Transport and below.  It cannot even be
;	|               |	saved/restored.
;	+---------------+
;	|    Datalink   |	Starts at CXB$C_LENGTH and is at least 
;	|     Layer     |	CXB$C_DLL bytes long.  Used by the datalink for
;	|  impure area  |	protocol header or state information.
;	+---------------+
;	|               |	
;	.    body of    .	Must be quadword aligned and starting no sooner
;	.    message    .	than CXB$C_LENGTH + CXB$C_DLL (= CXB$C_HEADER)
;	.               .	The first 6 bytes contain: RTFLG,DSTNOD,SRCNOD
;	.               .	  FORWARD, in that order.
;	|               |
;	+---------------+
;	|    Datalink   |	Used by the datalink layer for protocol (e.g.,
;	|     Layer     |	checksum) or state information.  Must be at
;	|  impure area  |	least CXB$C_TRAILER in length.
;	+---------------+
;
;
;  INPUTS:	R10	Scratch
;		R9	ADJ address
;			Zero if called by TALKER
;		R8	LPD address
;		R7	Total number of bytes in message
;		R6	Pointer to buffer containing message (CXB)
;		R5,R4	Scratch
;		R3	IRP address
;		R2	RCB address
;		R1	Pointer to start of message
;		R0	Address of IRP$L_WIND(R3)
;
;  OUTPUTS:	R8	Preserved
;		R7	Garbage
;		R6	0
;		R5-R0	Garbage
;
;-
FINISH_XMT_HDR:				; Finish building HDR and xmt it.
	TSTL	R9			; Did we have an ADJ?
	BEQL	5$			; If EQL then no - no header
	;
	;   We will make a special check here, to see if we are an
	;   Endnode. This is because on a BC circuit the "main" ADJ has a
	;   PTYPE of "unknown" which prevents the building of a route
	;   header.
	;
	BBC	#LPD$V_BC,LPD$W_STS(R8),3$ ; Br if NOT a broadcast-circuit
	$DISPATCH RCB$B_ETY(R2),TYPE=B,-
	<-
		<ADJ$C_PTY_PH4N, 10$>,-	; Phase IV endnode
	>
3$:	;
	; Build the appropriate header type - based on output adjacency
	; node type.
	;
	$DISPATCH ADJ$B_PTYPE(R9),TYPE=B,-
	<-
		<ADJ$C_PTY_AREA	10$>,-	; Phase IV level 2 router
		<ADJ$C_PTY_PH4	10$>,-	; Phase IV router
		<ADJ$C_PTY_PH4N 10$>,-	; Phase IV endnode
		<ADJ$C_PTY_PH3	20$>,-	; Phase III router
		<ADJ$C_PTY_PH3N	20$>,-	; Phase III endnode
	>
	;
	; All others including Phase II
	;
4$:	SUBL	#TR3$C_HSZ_DATA,R7	; Adjust msg size
	ADDL	#TR3$C_HSZ_DATA,R1	; Skip over Transport header
5$:	BRW	40$			; Join common code
	;
	;   Phase IV Router/Endnode
	;
	;	Build a new header if the output LPD is a broadcast-circuit
	;
10$:	BBC	#LPD$V_BC,LPD$W_STS(R8),30$ ; Br if NOT a broadcast circuit
	;
	;    Build a Phase IV broadcast circuit header
	;
	ASSUME	TR4$V_RTFLG_RTS  EQ  TR3$V_RTFLG_RTS
	ASSUME  TR4$V_RTFLG_RQR  EQ  TR3$V_RTFLG_RQR
	MOVB	(R1),R10		; Get the flags byte
	;
	;   If the output LPD is a Broadcast Circuit Endnode, then
	;   set the Intra-NI flag in the RTFLG byte of the message.
	;   It will be cleared by routers if they route this packet
	;   off the Ethernet.
	;
	TSTB	5(R1)			; Is this packet originating from here?
	BNEQ	12$			; If so,
	SETBIT	#TR4$V_RTFLG_INI,R10	; Set the Intra-NI flag
12$:	SETBIT	#TR4$V_RTFLG_LNG,R10	; Set the long format flag
	MOVB	5(R1),-(SP)		; Get visits byte
	MOVB	(R1),R2			; Get route header flags byte
	MOVW	3(R1),R4		; Get source node address 
	MOVW	1(R1),-(SP)		; Get destination address
	SUBL3	#<TR4$C_HSZ_DATA-TR3$C_HSZ_DATA>,R1,R5 ; Point to header area
	MOVL	R5,R1			; Set new start of data
	ADDL	#<TR4$C_HSZ_DATA-TR3$C_HSZ_DATA>,R7 ; Adjust msg size
	MOVB	R10,(R5)+		; Enter Transports message type
	CLRW	(R5)+			; RESERVED D-AREA, D-SUBAREA
	MOVL	#TR4$C_HIORD,(R5)+	; Store destination HIORD
	MOVW	(SP)+,R10		; Get destination node address
	MOVW	R10,(R5)+		; Store destination address
	CLRW	(R5)+			; RESERVED S-AREA, D-SUBAREA
	MOVL	#TR4$C_HIORD,(R5)+	; Store source HIORD
	MOVW	R4,(R5)+		; Store source node address
	CLRL	(R5)+			; Clear NL2, VISIT-CT, SERVICE CLASS
					;  and PROTOCOL TYPE
	MOVB	(SP)+,-3(R5)		; Store VISITs count
	MOVW	R10,IRP$Q_STATION+4(R3)	; Store destination node address in IRP
	BBC	#ADJ$V_RUN,-		; Br if adjacency is not up (ie this is
		 ADJ$B_STS(R9),35$	;  the "main" ADJ)
	BRB	30$			; Join common code
	;
	;   Phase III header
	;	
	;	For Phase III node, we must reset the "homearea" field of
	;	the destination id, and also for the source id.
	;
20$:	;   Phase III endnodes
	;   Phase III routers
	;
	;	***** The following is a requirement of the architecture *****
	;
	;	There are no known DECnet implementations which can handle
	;	node addresses from other areas. Therefore, for Phase III
	;	nodes we will always reset the area field of the source
	;	node address. There are checks in the route-thru code to
	;	prevent route through nodes from sending to Phase III nodes
	;	from other areas.
	;
	INSV	#0,#TR4$V_ADDR_AREA,-	; Reset "area" of source id
		#TR4$S_ADDR_AREA,3(R1)	;
	INSV	#0,#TR4$V_ADDR_AREA,-	; Reset "area" of destination id
		#TR4$S_ADDR_AREA,1(R1)	;
30$:	MOVW	ADJ$W_PNA(R9),-		; Set destination address
		IRP$Q_STATION+4(R3)	;    in IRP
35$:	MOVL	#TR4$C_HIORD,-		;	...
		IRP$Q_STATION(R3)	;	...
	;
	; Pad the message if required
	;
40$:	MOVL	R1,R5			; Copy start of message pointer
	BBC	#LPD$V_ALIGNW,-		; Br if no word alignment needed
		LPD$W_STS(R8),47$	;
	BICL	#1,R1			; Else, backup message to word boundary
47$:	BBC	#LPD$V_ALIGNQ,-		; Br if no quadword alignment needed
		LPD$W_STS(R8),49$	;
	BICL	#7,R1			; Else, backup message to quadword
					;  boundary
49$:	SUBL	R1,R5			; Calculate size of rounding
	BEQL	50$			; Branch if no pad required
	ADDL	R5,R7			; Increase size of transfer
	SETBIT	#7,R5			; Set high bit to indicate pad count
	MOVB	R5,(R1)			; Store pad "indicator"
50$:

	;
	; Finish building the IRP and transmit it
	;
	;  INPUTS:	R10	Scratch
	;		R9	ADJ address or zero
	;		R8	LPD address
	;		R7	Total number of bytes in message
	;		R6	Pointer to buffer containing message (CXB)
	;		R5,R4	Scratch
	;		R3	IRP address
	;		R2	Scratch
	;		R1	Pointer to start of data
	;		R0	Address of IRP$L_WIND(R3)
	;
	;
	;   Journal the message to be transmitted
	;

	.IF	DF,JNX$$$

	PUSHL	R0			; Save registers
	MOVL	IRP$L_ASTPRM(R3),R2	; Get RCB address
	CLRL	R0			; Set journal type = Start transmit
	BSBW	TR_FILL_JNX		; Store journal record
	POPL	R0			; Restore registers

	.ENDC

	;
	; For X.25 circuits we will have to calculate a CRC16 on the data
	; portion of the message.
	;
	BBC	#LPD$V_X25,LPD$W_STS(R8),100$ ; Skip if not X.25 datalink
	PUSHR	#^M<R0,R1,R3>		; Save regs
	CRC	CRC16,#0,R7,(R1)	; Calculate CRC16 on data
	MOVL	R0,R2			; Save CRC
	POPR	#^M<R0,R1,R3>		; Restore regs
	MOVW	R2,-(R1)		; Save CRC in datagram
	ADDW	#2,R7			; Account

100$:	MOVL	R1,(R6)			; Save address of start of data

	ASSUME	IRP$L_WIND  EQ  4+IRP$L_ASTPRM
	ASSUME	IRP$L_UCB   EQ  4+IRP$L_WIND
	ASSUME	LPD$L_UCB   EQ  4+LPD$L_WIND

	MOVQ	LPD$L_WIND(R8),(R0)+	; Fill WIND,UCB fields

	ASSUME	IRP$W_FUNC  EQ  4+IRP$L_UCB
	ASSUME	IRP$B_EFN   EQ  2+IRP$W_FUNC
	ASSUME	IRP$B_PRI   EQ  1+IRP$B_EFN
	ASSUME	IRP$L_IOSB  EQ  1+IRP$B_PRI

	MOVL	S^#IO$_WRITELBLK,(R0)+	; Fill FUNC, clear EFN and PRI
	MOVB	#31,-1(R0)		; Use lowest priority
	MOVL	R6,(R0)+		; Buffer address into IOSB

	ASSUME	IRP$W_CHAN   EQ  4+IRP$L_IOSB
	ASSUME	IRP$W_STS    EQ  2+IRP$W_CHAN
	ASSUME	IRP$L_SVAPTE EQ  2+IRP$W_STS
	ASSUME	IRP$W_BOFF   EQ  4+IRP$L_SVAPTE

	MNEGW	LPD$W_CHAN(R8),(R0)+	; Enter CHAN
	BBC	#LPD$V_XBF,-		; If BC the xmitter I/O is direct
		 LPD$W_STS(R8),120$	;
	;
	;
	;   Xmitter I/O is buffered
	;
	;
	MOVW	#IRP$M_BUFIO,(R0)+	; Enter STS field
	MOVL	R6,(R0)+		; Setup buffer ptr in SVAPTE
	CLRW	(R0)+			; Clear BOFF
	BRB	140$			; Continue
120$:	;
	;
	;   Xmitter I/O is direct
	;
	;
	CLRW	(R0)+			; Clear STS
	MOVL	(R6),R4			; Get msg address
	MOVL	G^MMG$GL_SPTBASE,R6	; Get system page table base
	EXTZV	S^#VA$V_VPN,-		; Get Virtual page frame number
		S^#VA$S_VPN,R4,R1	;
	MOVAL	(R6)[R1],(R0)+		; Enter SVAPTE
	BICW3	#^C<VA$M_BYTE>,R4,(R0)+	; Enter page offset of msg in BOFF
140$:	;
	;
	;   Complete the IRP and queue it to the device
	;
	;
	ASSUME	IRP$W_BCNT   EQ  2+IRP$W_BOFF
	ASSUME	IRP$L_BCNT   EQ  0+IRP$W_BCNT

	MOVZWL	R7,(R0)			; Enter BCNT
	CLRL	R6			; Prevent buffer deallocation
	MOVL	IRP$L_UCB(R3),R5	; Get comm driver UCB
	BEQL	150$			; If EQL then this is Local LPD
	JMP	G^EXE$ALTQUEPKT		; Queue the packet to "real" datalink
150$:	BRW	TR$LOC_DLL_XMT		; Queue the packet to "local" datalink


	.SBTTL	UPDATE_CACHE	- Update the BC cache table

;+
;  UPDATE_CACHE	- Update the BC cache table
;
;  INPUTS:	R10	Scratch
;		R9	ADJ address
;		R8	LPD address associated with receiving datalink
;		R7	Size of ECL message 
;		R6	Received CXB address
;		R5	Contents of first byte in message
;		R4,R3	Scratch
;		R2	RCB address
;		R1	Ptr to source node address in message
;		R0	Destination node address
;
;		CXB$W_R_SRCNOD	"Last Hop" node address
;		
;
;  OUTPUTS:	
;		R3,R4,R10	Garbage
;		All other registers are preserved.
;
;
;-
UPDATE_CACHE:					; Update the LPD's cache table
	;
	;
	;	First we will check the source node address
	;	against the PNA for the DRT. If they match, then
	;	it must be the "Designated Router" (DRT) who sent the
	;	message, since the "Main Adjacency" would have a node
	;	address of -1. We will then set the ADJ to point to the
	;	DRT, else we will scan the CACHE table for the received
	;	LPD, treating this like a Non-BC circuit and use the ADJ
	;	index of the LPD.
	;	
	;   CACHE TABLE HANDLING:
	;
	;	If the DRT is not a real BRA, then we will scan the LPD
	;	CACHE table to try and find the entry. If the entry was not
	;	found then it will be inserted at the first available slot,
	;	as long as the Intra-NI bit is set or the source of the packet
	;	was the same as the last hop.
	;
	MOVZWL	(R1),R3			; Get the source node address
	CMPW	R3,ADJ$W_PNA(R9)	; Do the node addresses match?
	BEQL	100$			; Br if YES - must have come from
					;  the "Designated Router", skip it
	MOVL	LPD$L_CACHE(R8),R10	; Else, get the CACHE table for LPD
	BEQL	100$			; Br if none available - leave now
	MOVZWL	-6(R10),R4		; Get number of entries in CACHE
	;
	;	Scan CACHE
	;
10$:	CMPW	(R10)+,R3		; Node address in cache?
	BEQL	60$			; Br if yes
	TSTW	(R10)+			; Skip timer cell
	SOBGTR	R4,10$			; Loop if more
	;
	;	CACHE scan failed, find empty cell and enter new Node
	;	address into the CACHE. If an empty cell is not found,
	;	then throw the oldest entry away!
	;
	;	Make sure the Intra-NI bit is set before entering in CACHE.
	;
	BBC	#TR4$V_RTFLG_INI,R5,100$ ; Br if Intra-NI packet, insert entry
	MOVL	LPD$L_CACHE(R8),R10	; Get the CACHE table for LPD, again
	MOVZWL	-6(R10),R4		; Get size of CACHE table
	MOVL	R10,R3			; Make a copy of the oldest entry
					; ..assume first is oldest
30$:	TSTL	(R10)			; Empty entry?
	BEQL	50$			; Br if yes
	CMPW	2(R10),2(R3)		; Is this the new oldest?
	BGTR	40$			; Br if not
	MOVL	R10,R3			; Else, set new oldest
40$:	TSTL	(R10)+			; Skip to next
	SOBGTR	R4,30$			; Loop if more
	MOVL	R3,R10			; Else, purge the oldest entry
50$:	;
	;	Enter new Node Address into CACHE table.
	;
	MOVW	(R1),(R10)+		; Enter new node address
60$:	MOVW	G^EXE$GL_ABSTIM,(R10)+	; Enter current time
100$:	RSB				; Return to caller


	.SBTTL	TR$RTRN_XMT_RTH	- End-action routine for route-thru IRP's
	.SBTTL	TR$RTRN_XMT_ECL	- End-action routine for "ECL" IRP's
	.SBTTL	TR$RTRN_XMT_TLK	- End-action routine for "TALKER" IRP's

;+
;  TR$RTRN_XMT_RTH - Transmit I/O end-action routine for route-thru IRP's
;  TR$RTRN_XMT_ECL - Transmit I/O end-action routine for "ECL" IRP's
;  TR$RTRN_XMT_TLK - Transmit I/O end-action routine for "TALKER" IRP's
;
;
;  End-action after Xmt IRP is returned due to I/O completion.  In general,
;  each routine returns the "input packet limiter" resource, and the hello
;  timer is reset if the transmit was successful.
;
;
;  INPUTS:	R5	IRP ptr
;		R4-R0	Scratch
;
;		IPL	4
;
;  OUTPUTS:	R5-R0	Garbage
;
;		IPL	4
;
;-
			.ENABL	LSB
TR$RTRN_XMT_TLK::			; HELLO message I/O completion
	DSBINT	#NET$C_IPL		; Raise to driver IPL
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Save regs

	MOVL	IRP$L_ASTPRM(R5),R2	; Get RCB address
	MOVZBL	IRP$L_AST(R5),R8	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	INCB	LPD$B_XMT_IPL(R8)	; Return "input-packet-limiter" slot
	;
	;   For Broadcast Circuits, we will check to see if we are the
	;   "Designated Router" and if so, setup to send the "Broadcast
	;   Endnode Hello" message (in addition to the "Router Hello" we
	;   just sent).
	;
	BLBC	IRP$L_IOST1(R5),10$	; If error, exit, but don't reset timer
	BBC	#LPD$V_BC,LPD$W_STS(R8),259$ ; Br if not a BC
	BBSC	#LPD$V_XEND,LPD$W_STS(R8),259$ ; Br if we have already sent
					;  the "Broadcast Endnode Hello" msg
	MOVZWL	LPD$W_DRT(R8),R1	; Get designated router ADJ index
	MOVL	@RCB$L_PTR_ADJ(R2)[R1],R1 ; Get ADJ address
	CMPW	ADJ$W_PNA(R1),-		; Are we the Designated Router?
		RCB$W_ADDR(R2)		;
	BNEQ	259$			; Br if not - reset timer
	CLRW	LPD$W_TIM_TLK(R8)	; Else, force hello msg next time
	BISW	#LPD$M_XEND,LPD$W_STS(R8) ; Send the "Broadcast Endnode" hello
10$:	BRB	30$			; Don't reset timer
259$:	BRW	25$			; Reset the "hello" timer

TR$RTRN_XMT_RTH::			; Route-thru I/O completion
	DSBINT	#NET$C_IPL		; Raise to driver IPL
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Save regs
					;
	MOVL	IRP$L_ASTPRM(R5),R2	; Get RCB address
	MOVZBL	IRP$L_AST(R5),R8	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	BLBC	IRP$L_IOST1(R5),30$	; If LBC then I/O error
	BUMP	L,LPD$L_CNT_TPS(R8)	; Update 'transit packets sent'
	BRB	20$			; Continue in common

TR$RTRN_XMT_ECL::			; ECL xmt I/O completion
	DSBINT	#NET$C_IPL		; Raise IPL
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Save regs
					;
	MOVL	IRP$L_ASTPRM(R5),R2	; Get RCB pointer
	MOVZBL	IRP$L_AST(R5),R8	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address

	.IF	DF,JNX$$$

	MOVL	#8,R7			; Set length of IOSB
	MOVAB	IRP$L_IOST1(R5),R1	; Journal the IOSB quadword
	MOVB	#1,R0			; Set journal type = Transmit complete
	BSBW	TR_FILL_JNX		; Store journal record

	.ENDC

	INCB	LPD$B_XMT_IPL(R8)	; Return "input-packet-limiter" slot
	MOVL	IRP$L_IOSB(R5),R0	; Get buffer
	CLRL	IRP$L_IOSB(R5)		; Detach it from the IRP
	;
	;
	;   Deliver end-action status to the ECL issuing the transmit.  It
	;   is the responsibility of the ECL routine to consume the R0
	;   buffer -- deallocate it, requeue it, etc.  Attaching R0 to 
	;   IRP$L_IOSB will cause it to be deallocate on return (see the code
	;   in TR_RTRN_IRP).
	;
	;
	;   Call with:	R5	IRP address
	;		R4,R3	Scratch
	;		R2	RCB address
	;		R1	Scratch
	;		R0	CXB address
	;		
	;		CXB$L_ENDACTION(R0) has been repaired
	;
	;   On return from ECL:
	;
	;		R4,R3,R1,R0	may be garbage.
	;
	;		All other registers must be unchanged.
	;
	;
	JSB	@IRP$L_SAVD_RTN(R5)	; Deliver status to ECL layer
	BLBC	IRP$L_IOST1(R5),30$	; If LBC then I/O was not successful
	BUMP	L,LPD$L_CNT_DPS(R8)	; Bump 'departing pkts sent'
	INCPMS	DEPLOCPK		; ... and the PMS database too
20$:	BBS	#LPD$V_BC,-		; If this is a broadcast circuit,
		LPD$W_STS(R8),30$	; then never reset talker (so that
					; Router Hellos are sent regularly)
25$:	MOVW	LPD$W_INT_TLK(R8),-	; Reset talker interval
		LPD$W_TIM_TLK(R8)	;
30$:	BSBB	TR_RTRN_IRP		; Return IRP to the Xmit pool
					;
	POPR	#^M<R6,R7,R8,R9,R10>	; Restore reg
	ENBINT				; Restore IPL
	RSB				; Return to Exec

			.DSABL	LSB



	.SBTTL	TR_RTRN_IRP	- Recycle IRP Xmit IRP pool

;+
;  TR_RTRN_IRP	- Recycle (Rcv or Xmt) IRP to transmit IRP pool
;
;
;  If the low bit is clear in IRP$L_IOST1 and the LPD is still marked "active"
;  then an "LPD-down" event is generated.
;
;  Otherwise, the used resources are returned.  If a fork process is awaiting 
;  any of these resources,  its wait state is advanced and may be reactivated.
;
;
;  INPUTS:	R8	LPD pointer
;		R5	IRP pointer
;		R2	RCB pointer
;
;		IRP$L_IOST1(R5) low bit set if I/O was succesful
;		IRP$L_IOSB(R5)  points to CXB to be deallocated, zero if none
;
;  OUTPUTS:	R8-R6	Garbage
;		R5	Zero
;		R4-R0  	Garbage
;
;-
TR_RTRN_IRP:				; Return IRP to Xmit pool
	MOVL	R5,R3			; Copy the IRP address
	;
	;
	;   Deallocate the attached CXB, if any
	;
	;
	MOVL	IRP$L_IOSB(R5),R0	; Get the CXB
	BEQL	10$			; If EQL then none
	CLRL	IRP$L_IOSB(R5)		; Nullify CXB pointer
	JSB	G^COM$DRVDEALMEM	; Deallocate the CXB
10$:	;
	;
	;   If LBS in IOST1 then I/O was successful, branch to recycle the IRP.
	;   Otherwise, the I/O failed -- assume the datalink is down, clear
	;   the LPD$V_ACTIVE bit:
	;
	;	If it was set the generate an "LPD-down" event.  This event
	;	consumes the IRP since it is queue to the ACP to signal the
	;	event.  
	;
	;	If it was already clear, then the "LPD-down" event was already
	;	generated.  Recycle this IRP to the Xmit pool, even if it is
	;	a Rcv IRP.
	;
	;
	;	NOTE:	There is only one RCV IRP ever queued to a datalink.
	;		Because of this, because the "LPD-down" event is
	;		generated only once, and because all failed I/O packets
	;		-- Rcv and Xmt -- sent here, it makes no difference
	;		which type of IRP is used to signal the "LPD-down"
	;		event and which are used to return the xmitter
	;		resources.
	;
	;
	;
	BLBS	IRP$L_IOST1(R5),15$	; If LBC then I/O was successful
	BBSC	#LPD$V_ACTIVE,-		; If BS then "LPD-down" event has
		 LPD$W_STS(R8),-	; not yet been processed.
		 TR_LPD_DOWN		; Signal "LPD-down"
15$:	DECB	LPD$B_IRPCNT(R8)	; Return the queue space
	BEQL	100$			; If EQL then report "circuit rundown"
	;
	;
	;   Account for IRP being returned and advance a single waiting
	;   solicitor if possible.  Both the "input-packet-limiter" and
	;   the "square-root-limit" restrictions must be checked before
	;   reactivating a solicitor since these limits may have been
	;   changed asynchronously be NETACP while this IRP was being 
	;   processed by the datalink.
	;
	;
	CMPB	LPD$B_IRPCNT(R8),-	; Does "square-root-limiter" allow
		LPD$B_XMT_SRL(R8)	; another I/O ?
	BGTR	30$			; If GTR then no
	TSTB	LPD$B_XMT_IPL(R8)	; Does "input-packet-limiter" allow it?
	BLEQ	30$			; If LEQ then no
	REMQUE	@LPD$Q_REQ_WAIT(R8),R0	; Get the waiting process
	BVS	30$			; If VS then none
	DECB	LPD$B_XMT_IPL(R8)	; Consume "input-packet-limiter" slot
	INCB	LPD$B_IRPCNT(R8)	; Account for IRP to be queued
	INSQUE	(R0),@RCB$Q_IRP_WAIT+4(R2)	; Move to IRP wait state
30$:	;
	;
	;   Reactivate a solicitor waiting for an IRP if possible.  If none
	;   are waiting, return the IRP -- shrinking the IRP free queue if
	;   necessary.
	;
	;
	REMQUE	@RCB$Q_IRP_WAIT(R2),R5	; Get oldest waiting process
	BVC	50$			; If VC then got one
	INSQUE	(R3),RCB$Q_IRP_FREE(R2)	; Queue the IRP
	CMPW	RCB$W_CUR_PKT(R2),-	; Does IRP pool needs reducing?
		RCB$W_MAX_PKT(R2)	;
	BLEQU	60$			; If EQL, no
	BSBW	TR$ADJUST_IRP		; Adjust Xmit IRP pool
	BRB	60$			; Continue
					;
50$:	MOVZBL	FKB$L_FR3(R5),R8	; Get LPD index
	MOVL	@RCB$L_PTR_LPD(R2)[R8],R8 ; Get LPD address
	MOVZWL	FKB$L_FR4(R5),R9	; Get ADJ index
	MOVL	@RCB$L_PTR_ADJ(R2)[R9],R9 ; Get ADJ address

	BSBW	TR$GRANT		; Restart solicitor
60$:	;
	;
	;   Done
	;
	;
	CLRL	R5			; Nullify IRP pointer
	RSB				; Done


100$:	;
	;
	;   Report that the LPD has been "run-down"
	;
	;
	DECW	RCB$W_CUR_PKT(R2)	; Account for xmit IRP going away
	INCB	LPD$B_IRPCNT(R8)	; Prevent LPD activity until CRD
					; successfully makes it to NETACP
	MOVB	#NETMSG$C_CRD,R0	; Setup event code for NETACP
	BSBW	TR$QUE_IRP_AQB		; Queue IRP to NETACP
	RSB				;



	.SBTTL	TR_LPD_DOWN	- Process "LPD down" event

;+
;  TR_LPD_DOWN     - Process "LPD down" event
;
;
;  The LPD is marked inactive.  All suspended fork processes waiting to 
;  transmit over the datalink are reactivate with their request to xmit
;  denied.
;
;
;  INPUTS:	R8	LPD address 
;		R5	IRP address
;		R2	RCB address
;
;  OUTPUTS:	R5	Zero
;		R0	Destroyed
;
;		All other registers are unchanged.
;
;-
TR_LPD_DOWN:				; Process "LPD down" event
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R9> ; Save regs
					;
	DECB	LPD$B_IRPCNT(R8)	; Account for IRP being returned

	;
	;   Deallocate the LPD CACHE, if present.
	;
	PUSHL	R2			; Save RCB address
	MOVL	LPD$L_CACHE(R8),R0	; Get CACHE address
	BEQL	10$			; Br if none
	SUBL	#12,R0			; Get start address of CACHE
	CLRL	LPD$L_CACHE(R8)		; Zero CACHE pointer
	JSB	G^EXE$DEANONPAGED	; Deallocate the pool
10$:	POPL	R2			; Restore RCB address 

	;
	;
	;   Reactivate all solicitors associated with this LPD and which are
	;   waiting for an IRP, denying each of them permission to transmit.
	;
	;
	MOVAB	RCB$Q_IRP_WAIT(R2),R7	; Get listhead
	MOVL	R7,R5			; Make copy
30$:	MOVL	R5,R6			; Advance last fork block ptr
40$:	MOVL	(R6),R5			; Get next fork block
	CMPL	R5,R7			; Listhead?
	BEQL	50$			; If EQL then done
	CMPB	FKB$L_FR3(R5),-		; Associated with this LPD?
		LPD$B_PTH_INX(R8)	; 
	BNEQ	30$			; If NEQ then no
	REMQUE	(R5),R5			; Deque it
	INCB	LPD$B_XMT_IPL(R8)	; Return request slot
	BSBW	TR$DENY			; Reactivate with failure
	BRB	40$			; Loop
50$:	;
	;
	;   Reactivate all solicitors waiting for room on the datalink queues,
	;   denying each permission to transmit.
	;
	;
	REMQUE	@LPD$Q_REQ_WAIT(R8),R5	; Get next fork block
	BVS	60$			; If VS then none
	BSBW	TR$DENY			; Reactivate with failure
	BRB	50$			; Loop
					;
60$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R9> ; Restore regs
	MOVB	#NETMSG$C_IRP,R0	; Setup the event
	BSBB	TR$QUE_IRP_AQB		; Signal the ACP, clear R5
	RSB				; Done


	.SBTTL	TR$GIVE_TO_ACP	- ECL entry to queue a buffer to the ACP
	.SBTTL	TR$QUE_WQE_AQB	- Queue WQE to AQB
	.SBTTL	TR$QUE_IRP_AQB	- Queue "LPD down" IRP to AQB 

;+
;  TR$GIVE_TO_ACP	- ECL entry to queue a buffer to the ACP
;  TR$QUE_WQE_AQB	- Queue WQE to AQB
;  TR$QUE_IRP_AQB	- Queue IRP to AQB - RCB$W_TRANS was already inc'd
;
;
;  Setup the common fields in the WQE and queue it to the AQB.
;
;  The action here is to fork before queueing the IRP since SCH$WAKE may
;  have to be called.  SCH$WAKE assumes it is called at IPL$_SYNC
;
;  In the case of TR$QUE_IRP_AQB, the IRP has already been accounted for,
;  neither the TRANSaction count nor the AQB_CNT will have to be incremented.
;
;
;  INPUTS:	R9	ADJ address or zero (only if TR$QUE_AWQE_AQB)
;		R8	LPD address
;		R5	WQE address - block to be queued to NETACP
;		R2	RCB address
; 		R1	Not used
;		R0	If TR$QUE_IRP_AQB then the NETMSG$... event code
;			Else, not looked at
;
;
;  OUTPUTS:	R5	0
;
;		All other registers are preserved.
;
;-
			.ENABL	LSB

TR$QUE_WQE_AQB:					; Queue WQE (i.e., CXB) to AQB
	CMPB	#NET$C_MAX_WQE,-		; Can we insert more entries
		 RCB$B_AQB_CNT(R2)		;   on AQB?
	BLSS	50$				; Br if no, deallocate WQE
	INCB	RCB$B_AQB_CNT(R2)		; Increment count of new entries
						;  inserted on AQB
	MOVW	LPD$W_PTH(R8),WQE$W_REQIDT(R5)	; Remember datalink i.d.
	INCW	RCB$W_TRANS(R2)			; Count new transaction
	BRB	15$				; Continue, don't convert block
						; structure type
						;
TR$GIVE_TO_ACP::				; ECL entry pass block to ACP
	INCW	RCB$W_TRANS(R2)			; Else, count new transaction
	BRB	10$				; Continue
						;
TR$QUE_IRP_AQB:					; Queue IRP (as WQE) to AQB
	CLRW	WQE$W_ADJ_INX(R5)		; No ADJ index available
	MOVAB	IRP$L_IOST1(R5),WQE$L_PM2(R5)	; Store ptr to IOSB image 
	MOVB	R0,WQE$B_EVT(R5)		; Setup the event
	MOVW	LPD$W_PTH(R8),WQE$W_REQIDT(R5)	; Remember datalink i.d.
10$:	MOVB	S^#DYN$C_NET,WQE$B_TYPE(R5)	; Convert the IRP to a WQE
						;
15$:	PUSHR	#^M<R0,R1,R2,R3,R4>		; Save regs
						;
	MOVL	RCB$L_AQB(R2),WQE$L_PM2+4(R5)	; Save AQB address
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5)	; Setup fork IPL
	MOVQ	FKB$L_FR3(R5),R3		; Prevent EXE$FORK from 
						; destroying these fields
	BSBB	30$				; Create fork process
	CLRL	R5				; Prevent access to this block
						;
	POPR	#^M<R0,R1,R2,R3,R4>		; Restore regs
	RSB					; Done



30$:	JSB	G^EXE$FORK			; Create fork process
						;
	DSBINT	#IPL$_SYNCH			; We're back. Sync with SCH$WAKE
	MOVL	WQE$L_PM2+4(R5),R4		; Get AQB address
	INSQUE	(R5),@AQB$L_ACPQBL(R4)		; Inert IRP at end of queue
	BNEQ	40$				; Br unless first
	MOVL	AQB$L_ACPPID(R4),R1		; Get PID
	JSB	G^SCH$WAKE			; Wake the ACP
40$:	ENBINT					; Restore IPL
						;
	RSB					; Done

	;
	;   Too many entries on AQB queue
	;
50$:	MOVL	R5,R0				; Copy WQE address
	JSB	G^COM$DRVDEALMEM		; Deallocate it
	RSB					; Return to caller
			.DSABL	LSB


	.SBTTL	TR$LOC_DLL_XMT  - "Local" datalink driver transmit
	.SBTTL	TR$LOC_DLL_RCV  - "Local" datalink driver receive

;+
;  TR$LOC_DLL_XMT  - "Local" datalink driver transmit
;  TR$LOC_DLL_RCV  - "Local" datalink driver receive
;
;
;  This routine simulates a datalink driver.  It is used to allow the Transport
;  layer to handle IRPs for ECL-ECL communication in a manner consistent with
;  the remainder of the Datalink layer.  Both the transmitter and the receiver
;  appear to "buffered" (as opposed to "direct") I/O.
;
;  It appears as a line constantly in "loopback".  The receive IRP is made to
;  point to the buffer carried by the transmit IRP.  In order to get away with
;  this, the XM$V_STS_BUFFAIL bit must be set in the receive's IRP$L_IOST2
;  field -- this prevents it the buffer from being consumed and is still 
;  attached to the IRP when it is requeued for another receive operation.
;
;
;	NOTE:	Sharing the buffer this way only works if the receive is
;		completed before its corresponding transmit.  Also, it can 
;		only work if the buffer is never sent to NETACP -- this
;		restriction is enforced by the fact that the "local"
;		datalink is only used to carry ECL messages.
;
;
;  The pertinent IRP fields are as follows:
;
;  On input to this routine:
;
;			Rcv's			  Xmt's
;			-----			  -----
;	IRP$L_SVAPTE	Garbage			  Buffer pointer
;	IRP$W_BCNT	Garbage			  Message size
;	IRP$L_IOST1	Garbage			  Garbage
;	IRP$L_IOST2	Garbage			  Garbage
;
;  When sent to I/O completion:
;
;	IRP$L_SVAPTE	Buffer pointer	    	  Buffer pointer
;	IRP$W_BCNT	Message size	    	  Message size
;	IRP$L_IOST1	SS$_NORMAL in low word 	  SS$_NORMAL in low word
;			IRP$W_BCNT in high word	  IRP$W_BCNT in high word
;	IRP$L_IOST2	XM$M_STS_ACTIVE!-	  XM$M_STS_ACTIVE
;			XM$M_STS_BUFFAIL
;
;
;  INPUTS:	R3		IRP address
;
;  OUTPUTS:	R5-R0		Garbage
;
;-
TR$LOC_DLL_XMT:					; "Local" datalink driver xmt'r
	MOVL	R3,R1				; Copy IRP address
	MOVL	IRP$L_ASTPRM(R1),R2		; Get RCB
	REMQUE	@RCB$Q_LOC_RCV(R2),R3		; Get a waiting receive
	BVC	XFER				; If VC then got one
	INSQUE	(R1),@RCB$Q_LOC_XMT+4(R2)	; Else queue the IRP
	RSB

TR$LOC_DLL_RCV:					; "Local datalink driver rcv'r
	CLRL	IRP$L_SVAPTE(R3)		; Erase former buffer ptr
	MOVL	IRP$L_ASTPRM(R3),R2		; Get RCB
	REMQUE	@RCB$Q_LOC_XMT(R2),R1		; Get a waiting transmit
	BVC	XFER				; If VC then got one
	INSQUE	(R3),@RCB$Q_LOC_RCV+4(R2)	; Else queue the IRP
	RSB

XFER:	;
	;
	;   Setup IRP's for I/O completion.  Let the RCV IRP temporarily
	;   share the XMT IRP's CXB in order to deliver the received message
	;   to the ECL layer.
	;
	;
	MOVL	IRP$L_SVAPTE(R1),-		; Setup Rcvr buffer ptr
		IRP$L_SVAPTE(R3)		;
	MOVW	IRP$W_BCNT(R1),IRP$W_BCNT(R3)	; Setup size of message
	MOVW	S^#SS$_NORMAL,IRP$L_IOST1(R1)	; Setup I/O status
	MOVW	IRP$W_BCNT(R1),IRP$L_IOST1+2(R1); Setup xfer size
	MOVL	IRP$L_IOST1(R1),IRP$L_IOST1(R3)	; Copy XMT status to RCV IRP
	MOVZWL	#XM$M_STS_ACTIVE,IRP$L_IOST2(R1); Setup Xmtter device status
	MOVZWL	#XM$M_STS_BUFFAIL!-		; Set Rcvr device status
		 XM$M_STS_ACTIVE,IRP$L_IOST2(R3); - BUFFAIL is crucial since
						;   rcvr doesn't own the CXB
	;
	;
	;   The order here is crucial.  The RCV must be posed before the XMT
	;   so that the XMT end-action routine doesn't deallocate the buffer
	;   before the RCV'r has had a chance to look at it.  Note that the
	;   BUFFAIL flag is set so that the RCV'r cannot take the buffer.
	;
	;
	BSBB	POST				; Post the RCV IRP
	MOVL	R1,R3				; Get the XMT IRP for posting
POST:	CMPB	S^#DYN$C_IRP,IRP$B_TYPE(R3)	; IRP ?
	BNEQ	70$				; If not, bug
	MOVAB	G^IOC$GL_PSBL,R0		; Get I/O post back ptr address
	INSQUE	(R3),@(R0)+			; Queue the IRP
	SOFTINT	#IPL$_IOPOST			; ALWAYS Post an interrupt due 
						; to an obscure system bug
60$:	RSB					; Done

70$:	BUG_CHECK NETNOSTATE,FATAL		; Bugcheck 


	.SBTTL	TR$ADJUST_IRP	- Adjust the number of IRPs in the pool

;+
;  TR$ADJUST_IRP	- Adjust the number of IRPs in the pool
; 
;
;  The number of free IRPs are adjusted in whatever direction necessary to 
;  bring  RCB$W_CUR_PKT  closer to  RCB$W_MAX_PKT.
;
;
;  INPUTS:	R2	RCB pointer
;
;  OUTPUTS:	R0	Low bit clear if free queue is empty.
;			Low bit set otherwise.
;
;
;		All other registers are preserved.
;
;-
TR$ADJUST_IRP:				; Adjust IRP pool
	PUSHL	R3			; Save reg
					;
10$:	CMPW	RCB$W_CUR_PKT(R2),-	; See what adjustments are needed
		RCB$W_MAX_PKT(R2)	;
	BEQL	50$			; Br if none
	BGTRU	30$			; Br if decrease is needed
	BSBB	TR$ALLOC_IRP		; Get an IRP if possible
	BLBC	R0,50$			; Br on failure
	INSQUE	(R3),@RCB$Q_IRP_FREE(R2); Insert the IRP onto the free list
	INCW	RCB$W_CUR_PKT(R2)	; Account for IRP
	INCW	RCB$W_TRANS(R2)		; Here, too
	BRB	50$			; Only allocate 1 at a time

30$:	REMQUE	@RCB$Q_IRP_FREE(R2),R0	; Get IRP if any
	BVS	50$			; If VS then none
	DECW	RCB$W_CUR_PKT(R2)	; Account for the IRP
	DECW	RCB$W_TRANS(R2)		; Account for it here, too
	JSB	G^COM$DRVDEALMEM	; Deallocate it
	BRB	10$			; Try again
50$:	;
	;   Return a flag to the caller indicating if the queue is empty
	;
	CLRB	R0			; Indicate empty
	CMPL	RCB$Q_IRP_FREE(R2),-	; Is queue empty?
		@RCB$Q_IRP_FREE(R2)	;
	BEQL	60$			; If EQL, its empty
	INCB	R0			; Indicate non-empty
					;
60$:	POPL	R3			; Restore reg
	RSB


	.SBTTL	TR$ALLOC_IRP	- Allocate IRP

;+
;  TR$ALLOC_IRP	- Allocate IRP
;
;
;  An IRP is allocated and its header is initialized.
;
;
;  INPUTS:	None
;
;  OUTPUTS:	R3	IRP pointer if successful
;		R0	Status code
;
;		All other registers are preserved
;-
TR$ALLOC_IRP:				; Allocate Transport IRP
	MOVQ	R1,-(SP)		; Save regs
	MOVZBL	#IRP$C_LENGTH,R1	; Setup IRP size
	JSB	G^EXE$ALONONPAGED	; Get the block
	BLBC	R0,10$			; Br on error
	MOVL	R2,R3			; Copy block address
	;
	;
	;&  zero the entire IRP for now to catch access violations
	;&  eventually, only the IRP$L_IOSB field (buffer ptr) will
	;&  need to be zeroed
	;
	;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	MOVC5	#0,(SP),#0,#IRP$C_LENGTH,(R3)
	POPR	#^M<R0,R1,R2,R3,R4,R5>

	ADDL	#IRP$W_SIZE,R2		; Advance to size field

	ASSUME	IRP$B_TYPE  EQ  2+IRP$W_SIZE
	ASSUME	IRP$B_RMOD  EQ  1+IRP$B_TYPE

	MOVW	R1,(R2)+		; Enter size for deallocation
	MOVB	S^#DYN$C_IRP,(R2)+	; Enter buffer type
	MOVB	#NET$C_IPL,(R2)		; Enter driver IPL
10$:	MOVQ	(SP)+,R1		; Restore regs
	RSB				; Return 


	.SBTTL	TR$ALLOCATE	- Allocate and initialize buffer
;+
;  TR$ALLOCATE	- Allocate and initialize buffer
;
;
;  A buffer is allocated and initialized
;
;
;  INPUTS:	R1	Size of buffer
;
;  OUTPUTS:	R2	Ptr to buffer if successful
; 		R1	Garbage
;		R0	Status
;-
TR$ALLOCATE:				; Allocate memory block
	PUSHL	R3			; Save reg
					;
	JSB	G^EXE$ALONONPAGED	; Get buffer
	BLBC	R0,50$			; Br on error
	MOVW	R1,FKB$W_SIZE(R2)	; Setup size
	MOVB	S^#DYN$C_CXB,-		; Setup type
		FKB$B_TYPE(R2) 		; 
					;
50$:	POPL	R3			; Restore reg
	RSB


	.SBTTL	TR_FILL_JNX	- Conditionally fill journal record.

	.IF DF JNX$$$
;+
;  TR_FILL_JNX - If journalling is enabled, fill journal record.
;
; Inputs:
;
;	R0 = Journal record type
;	R1 = Address of message
;	R2 = RCB address
;	R7 = Size of message
;	R8 = LPD address
;
; Outputs:
;
;	No registers are destroyed.
;-

	JNL_REC_SIZ = 64

TR_FILL_JNX:
	PUSHL	R5			; Save reg
	MOVL	RCB$L_PTR_JNX(R2),R5 	; Get the journal buffer
	BEQL	100$			; If EQL then no buffer
	CMPW	#JNL_REC_SIZ,6(R5)	; Enough space left?
	BGEQU	100$			; If GEQU then yes
	BSBB	200$			; Record data
100$:	POPL	R5			; Restore reg
	RSB

200$:	PUSHR	#^M<R0,R1,R2,R3,R4>	; Save regs
	SUBW	#JNL_REC_SIZ,6(R5)	; Acquire space to be used
	MOVL	(R5),R4			; Get output pointer
	ADDL	#JNL_REC_SIZ,(R5)	; Bump output pointer
	MOVQ	G^EXE$GQ_SYSTIME,(R4)+	; Enter timestamp
	MOVB	R0,(R4)+		; Enter record type
	MOVB	LPD$B_PTH_INX(R8),(R4)+	; Enter line i.d.
	MOVW	R7,(R4)+		; Enter total message size
	MOVC5	R7,(R1),-		;
		#0,#JNL_REC_SIZ-12,(R4)	; Enter begining of message
	POPR	#^M<R0,R1,R2,R3,R4>	; Restore regs
	RSB				; Return to caller

	.ENDC



	.PSECT	$$$116_DRIVER,LONG,EXE,RD,WRT	; Make sure we're at the end
						; of the driver


NET$END::
	HALT


.END

