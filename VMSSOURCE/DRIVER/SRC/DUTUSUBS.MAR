	.TITLE	DUTUSUBS DISK/TAPE CLASS DRIVER SUBROUTINES
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
;
; FACILITY:
;
;	MSCP Disk and Tape Class Drivers
;
; ABSTRACT:
;
;	This module contains subroutines used by both the MSCP disk and tape 
;	class drivers.
;
; ENVIRONMENT:
;
;	This module is linked into both the DUDRIVER and the TUDRIVER.  The 
;	routines herein are called by those drivers as needed.  See individual 
;	routine descriptions for interface details.
;
;--
;
; AUTHOR: Ralph O. Weber, 	CREATION DATE: 7-AUG-1983
;
; MODIFIED BY:
;
;	V04-001	ROW0416		Ralph O. Weber		14-SEP-1984
;		Make DUTU$NEW_UNIT ignore requests to create a unit 4095.  
;		This will prevent creating units for sprious messages from the 
;		HSC.
;
;	V03-039	ROW0412		Ralph O. Weber		21-AUG-1984
;		Change bugcheck issued when more than three paths are found 
;		for a single device for INCONSTATE to IVDSKCONFG, invalid disk 
;		configuration.  This is a temporary measure to make the error 
;		condition more clear and is expected to be fixed better in a 
;		future version.
;
;	V03-038	ROW0404		Ralph O. Weber		23-JUL-1984
;		Fix race condition between 2P device configuration and unit 
;		failover.  This eliminates attempts to failover units which 
;		are not fully dual-path configured.
;
;	V03-037	ROW0401		Ralph O. Weber		21-JUL-1984
;		Change DUTU$CREATE_CDDB so that attempts to have two CDDBs for 
;		the same system-id on the same device class (disk or tape) 
;		result in the second CDDB and all related structures being 
;		deallocated back to pool and no second connect attempt taking 
;		place.  This eliminates exteranous paths to a device in the 
;		event that SYSGEN or a user of SYSGEN attempts to "connect" 
;		multiple times to the same remote server.
;
;		Clear the DEV$V_AVL bit in all CDP UCBs.  This prevents 
;		allocating of or assigning a channel to such devices.  Thus, 
;		the devices become even more completely unusable which is the 
;		desired goal.
;
;	V03-036	ROW0400		Ralph O. Weber		21-JUL-1984
;		Enhance DUTU$FAILOVER_UCB so that changes to the I/O database 
;		which must be done with write access to the I/O database mutex 
;		are done in a separate fork thread.  This fork thread uses a 
;		separate fork block which is part of the CDDB which the 
;		unit(s) are failing away from.  This eliminates the need to 
;		have write access to the I/O database mutex before calling 
;		DUTU$FAILOVER_UCB and prevents stalling I/O requests due to 
;		lack of access to the mutex.  Since such requests can no 
;		longer stall, it is no longer possible to get a deadlock when, 
;		for example, a process holding the mutex must perform a page 
;		fault read in order to complete and release the mutex.
;
;	V03-035	ROW0395		Ralph O. Weber		20-JUL-1984
;		Setup use of DAP CDRP by DUTU$POLL_FOR_UNITS.  Also build 
;		correct coordination of DAP CDRP usage between 
;		DUTU$POLL_FOR_UNITS and DUTU$DODAP.
;
;	V03-034	ROW0390		Ralph O. Weber		20-JUL-1984
;		Fix DUTU$GET_DEVNAM so that the controller letter is the one 
;		choosen by SYSGEN.  Previously, "A" was used, regardless of 
;		what was correct.
;
;	V03-033	ROW0388		Ralph O. Weber		 8-JUL-1984
;		Add adjustment of wait counter for status of newly used 
;		connection to DUTU$FAILOVER_UCB.  This function formerly was 
;		performed by DU_END_MNTVER, but some race conditions exist 
;		which require that the adjustment be made after every 
;		successful failover.
;
;	V03-032	ROW0387		Ralph O. Weber		 7-JUL-1984
;		Add DUTU$RECONN_LOOKUP, the broken connection processing 
;		action routine for both the RSPID-wait lookup SCS service and 
;		the RDT lookup SCS serivce.  Add DUTU$DRAIN_CDDB_CDRPQ, the 
;		routine which removes all entries in the CDDBs active CDRP 
;		queue and places them in the restart queue.
;
;	V03-031	ROW0380		Ralph O. Weber		22-JUN-1984
;		Add error recovery for case where DUTU$NEW_UNIT call in 
;		DUTU$POLL_FOR_UNITS cannot allocate memory for new UCB.  Error 
;		recovery is to restart pool from the beginning.
;
;	V03-030	ROW0364		Ralph O. Weber		17-MAY-1984
;		Hack DUTU$POST_CDRP to adjust wait count when IO$_PACKACK is 
;		posted with UCB$V_MSCP_PKACK set, or when IO$_SETCHAR or 
;		IO$_SETMODE are posted with UCB$V_TU_SEQNOP set.  This is an 
;		outragous hack, but it cannot be done correctly until after
;		FT 2 ships.
;
;	V03-029	ROW0362		Ralph O. Weber		 7-MAY-1984
;		Fix stack usage bug in DUTU$LOG_IVCMD.  We were pushing more 
;		onto the stack than we were poping off.
;
;	V03-028	ROW0361		Ralph O. Weber		 5-MAY-1984
;		Add DUTU$DODAP, the common disk/tape class driver routine for 
;		sending Determine Access Path commands.  This version of the 
;		DAP thread is designed not to have multiple thread forking on 
;		one CDRP.
;
;	V03-027	ROW0360		Ralph O. Weber		 5-MAY-1984
;		Add testing of UCB$V_MSCP_PKACK to DUTU$CHECK_RWAITCNT.
;
;	V03-026	LMP0235		L. Mark Pilant,		17-Apr-1984  13:59
;		Add a template ORB that is hooked up to the template UCB
;		just prior to creating a new UCB and ORB from the templates.
;
;	V03-026	ROW0344		Ralph O. Weber		11-APR-1984
;		> Change DISKCLASS and some INCONSTATE bugchecks to MSCPCLASS.
;		> Correct method for obtaining I/O database access in 
;		  DUTU$FIND_DDB to prevent race condition believed responsible 
;		  for multiple DDBs per controller letter.
;		> Correct fork thread handling bugs in DUTU$RESTORE_CREDIT.
;
;	V03-025	ROW0339		Ralph O. Weber		 8-APR-1984
;		Add generalized "invalid command" processing support.  
;		Specifically, add DUTU$LOG_IVCMD.
;
;	V03-024	ROW0338		Ralph O. Weber		 7-APR-1984
;		Add support for DO_ACTION macro in the form of two subroutines, 
;		DUTU$INTR_ACTION_XFER and DUTU$INTR_ACTION_N.
;
;	V03-023	ROW0337		Ralph O. Weber		 7-APR-1984
;		Alter LINK_NEW_UCB to account for disappearance of 
;		UCB$L_CANLINK.
;
;	V03-022	ROW0335		Ralph O. Weber		 4-APR-1984
;		Add DUTU$UNITINIT, a unit initialization routine which deletes 
;		the bogus UCBs created by SYSGEN and still keeps useful UCBs 
;		after a power failure.
;
;	V03-021	ROW0334		Ralph O. Weber		 3-APR-1984
;		Add initialization of UCB$L_MAXBCNT based upon value found in 
;		PDT$L_MAXBCNT to LINK_NEW_UCB and LINK_2P_UCB.
;
;	V03-020	ROW0333		Ralph O. Weber		30-MAR-1984
;		Correct DUTU$RESET_MSCP_MSG to handle the possibility that 
;		RECYCL_MSG_BUF may discover a broken connection.  This is done 
;		by transfering to DUTU$KILL_THIS_THREAD whenever and error is 
;		encountered.
;
;	V03-019	ROW0331		Ralph O. Weber		26-MAR-1984
;		Move all major CANCEL support routines to DUTUSUBS.  Also add 
;		some sanity checks in DUTU$INSERT_RSTARTQ and DUTU$POST_CDRP.
;
;	V03-018	ROW0329		Ralph O. Weber		22-MAR-1984
;		Eliminate toggling of UCB$V_FLOVR in DUTU$FAILOVER_UCB.  The 
;		information is no longer used else where in the class drivers.
;		Also all failover if destination path is CDDB$V_RECONNECT or 
;		CDDB$V_RSTRTWAIT.  Because of some connection failure 
;		scenarios, it is important to allow a failover back to a 
;		previously tested path when that path is still reconnecting 
;		but has a working connection.
;
;	V03-017	ROW0327		Ralph O. Weber		21-MAR-1984
;		Change DUTU$SETUP_CDP_UCB so that it never declares a class 
;		driver UCB to be a CDP UCB.
;
;	V03-016	ROW0325		Ralph O. Weber		19-MAR-1984
;		Remove references to UCB$L_MVIOQFL and UCB$L_MVIOQBL.  This 
;		queue header is no longer used.  Also change system device 
;		unit number check in DUTU$POLL_FOR_UNITS to use UCB$W_MSCPUNIT 
;		instead of UCB$W_UNIT.
;
;	V03-015	ROW0312		Ralph O. Weber		26-FEB-1984
;		Change DUTU$GET_DEVTYPE to return a device type equivalent to 
;		the device name choosen by DUTU$GET_DEVNAM when UCB$L_MEDIA_ID 
;		is zero.
;
;	V03-014	ROW0309		Ralph O. Weber		23-FEB-1984
;		Get CDDB address setup for call to DUTU$SETUP_CDP_UCB in 
;		LINK_NEW_UCB.  On that same page, stop using R2 as the UCB 
;		base address.  Use R5 instead.  R2 gets corrupted by 
;		DUTU$SETUP_CDP_UCB.
;
;	V03-013	ROW0304		Ralph O. Weber		12-FEB-1984
;		Fix three bug discovered while testing the new mount verifica-
;		tion oriented failover:
;		- Do not allow failover to a CDDB with CDDB$V_RSTRTWAIT set.
;		- Copy new CRB address into a failed-over UCB.
;		- If IOC$LINK_UCB reports a duplicate unit number in 
;		  LINK_NEW_UNIT, deallocate the working UCB.  Clearly, two 
;		  threads got started for the same unit and the current one 
;		  got there last.  This change also requires that all 
;		  operations which "link" the working UCB to the rest of the 
;		  I/O database MUST occur after the call to IOC$LINK_UCB.
;
;	V03-012	ROW0300		Ralph O. Weber		 9-FEB-1984
;		Add toggling of UCB$V_MSCP_FLOVR to TUTU$FAILOVER_UCB.
;
;	V03-011	ROW0298		Ralph O. Weber		 9-FEB-1984
;		Setup use of CDRP$W_ENDMSGSIZ to hold the size of an incomming 
;		sequenced message.  This replaces use of CDRP$L_IOST2+2 whose 
;		use causes valuable input information to be overwritten.
;
;	V03-010	ROW0297		Ralph O. Weber		 7-FEB-1984
;		Add test for UCB$V_TU_SEQNOP as reason to bump wait count in 
;		DUTU$CHECK_RWAITCNT.
;
;	V03-009	ROW0295		Ralph O. Weber		 6-FEB-1984
;		Add DUTU$CHECK_RWAITCNT, a routine which validates 
;		UCB$W_RWAITCNT and bug checks if it is wrong.
;
;	V03-008	ROW0293		Ralph O. Weber		 4-FEB-1984
;		Setup use of INIT_MSCP_MSG in DUTU$POLL_FOR_UNITS.  Remove 
;		references to the unused CDDB$L_CONNQFL and CDDB$L_CONNQBL.
;
;	V03-007	ROW0286		Ralph O. Weber		22-JAN-1984
;		Add the following routines:
;		> DUTU$TEST_CANCEL_CDRP which tests a CDRP and determines 
;		  whether or not it should be canceled.
;		> DUTU$KILL_THIS_THREAD which temporarily terminates a 
;		  thread caught by an inopportune connection failure.
;		> DUTU$INSERT_RESTARTQ which handles first pass inserting 
;		  CDRPs into the restart queue during connection failure 
;		  processing.
;
;	V03-006	ROW0284		Ralph O. Weber		19-JAN-1984
;		Change handling of CDDB$L_ORIGUCB to guarantee that it is the 
;		system device UCB and to hand craft a mount verification style 
;		IO$_PACKACK IRP which brings the unit online.  It might be 
;		argued that this code belongs only in the disk class driver.  
;		However, with the plans to permit booting from a MSCP tape 
;		disucssed recently over lunch, it seems unwise to prohibit 
;		tapes from performing this function.
;
;	V03-005	ROW0279		Ralph O. Weber		14-JAN-1984
;		Make changes necessary to support use of mount verification 
;		after a connection failure to bring previously online units 
;		back online.  This involves eliminating DUTU$FAILOVER which is 
;		no longer used, testing CDDB$M_NOCONN as a failover preventer 
;		in DUTU$FAILOVER_UCB, setting CDDB$M_NOCONN in DUTU$BUILD_CDDB,
;		and setting CDRP$M_PERM in CDDB_INIT_PRM_CDRP.  Add the 
;		following routines; DUTU$TERMINATE_PENDING, DUTU$POST_CDRP, 
;		DUTU$DEALLOC_ALL, DUTU$DEALLOC_RSPID_MSG, DUTU$INIT_MSCP_MSG, 
;		DUTU$INIT_MSCP_MSG_UNIT, DUTU$RESET_MSCP_MSG, and
;		DUTU$RESTORE_CREDIT.  Change DUTU$FAILOVER_UCB to move entries 
;		in the restart queue and to accept the UCB address in R3.
;
;	V03-004	ROW0269		Ralph O. Weber		28-DEC-1983
;		Add DUTU$CREATE_CDDB, a common routine to create, initialize, 	
;		and link a CDDB.
;
;	V03-003	ROW0262		Ralph O. Weber		24-NOV-1983
;		Move all UCB lookup and creation to DUTUSUBS.  Cleanup 
;		ATTN_MSG processing in DU$IDR.  Implement usage of $DUTUDEF, 
;		all device independent UCB fields, and the IOC$GL_DU_CDDB 
;		listhead.  This includes addition of the following new 
;		routines to this module:
;		 > DUTU$POOL_FOR_UNITS - to poll a server for available units.
;		 > DUTU$NEW_UNIT - to process unit available attention or get 
;		   unit status end messages and create new UCBs where 
;		   necessary.
;		 > DUTU$SETUP_DUAL_PATH - to check for and where appropriate 
;		   setup dual path linkage to a device.
;		 > DUTU$LOOKUP_UCB - to locate a UCB on a given CDDB chain 
;		   with a given MSCP unit number.
;		 > DUTU$INIT_CONN_UCB - to initialize connection dependent 
;		   fields in a UCB.
;		 > DUTU$FIND_DDB - to locate or create a desired DDB
;		 > DUTU$GET_DEVTYPE - to determine VMS device type from MSCP 
;		   media identification.
;		 > DUTU$GET_DEVNAM - to build a VMS DDCn: device name from 
;		   MSCP unit number and MSCP media identification.
;		 > DUTU$SETUP_CDP_UCB - to locate and setup local/remote dual 
;		   pathed UCBs.
;		 > DUTU$SEND_DUPLICATE_UNIT - to send a duplicate unit number 
;		   message to the operator.
;		 > DUTU$FILL_MSCP_MSG - zero fill an incoming MSCP message.
;
;	V03-002	ROW0261		Ralph O. Weber		22-NOV-1983
;		Build common versions of DUMP_COMMAND (DUTU$DUMP_COMMAND) and 
;		DUMP_ENDMESSAGE (DUTU$DUMP_ENDMESSAGE) so that those routines 
;		may be removed from the class drivers.  Add the 
;		DUTU$SEND_MSCP_MSG routine.
;
;	V03-001	ROW0231		Ralph O. Weber		 1-OCT-1983
;		Split failover for a single UCB out of DUTU$FAILOVER into a 
;		seperate routine DUTU$FAILOVER_UCB.  This will allow the 
;		PACKACK operation to failover a single UCB while attempting to 
;		find a path that works to a device.  Also create an 
;		independent routine DUTU$SEVER_CDDB to sever CDDB linkages.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CDDBDEF			;Define CDDB offsets
	$CDRPDEF			;Define CDRP offsets
	$CDTDEF				;Define CDT offsets
	$CRBDEF				;Define CRB offsets
	$DCDEF				;Define device classes & types
	$DDBDEF				;Define DDB offsets
	$DDTDEF				;Define DDT offsets
	$DEVDEF				;Define DEVICE CHARACTERISTICS bits
	$DYNDEF				;Define DYN symbols
	$EMBLTDEF			;Define EMB Log Message Types
	$FKBDEF				;Define FKB offsets
	$IODEF				;Define I/O function codes
	$IPLDEF				;Define IPL levels
	$IRPDEF				;Define IRP offsets
	$MSCPDEF			;Define MSCP packet offsets
	$MSGDEF				;Define system message types
	$MTXDEF				;Define MUTEX offsets
	$PBDEF				;Define Path Block offsets
	$PCBDEF				;Define PCB offsets
	$PDTDEF				;Define PDT offsets
	$PRDEF				;Define processor register numbers
	$RCTDEF				;Define RCT offsets
	$SBDEF				;Define System Block offsets
	$SSDEF				;Define System Status values
	$UCBDEF				;Define UCB offsets
	$VCBDEF				;Define VCB offsets
	$VECDEF				;Define VEC offsets

	$DUTUDEF			;Define common class driver CDDB
					; extensions and other common symbols


;
; PSECT DEFINITIONS TO LOCATE THE DATA REGION
;
	.PSECT	$$$220_DUTU_DATA_00 RD,WRT,EXE,LONG

DUTU$DATA::				;Locate base of data region

;
; MODULE PSECT
;
	.PSECT	$$$115_DRIVER LONG

;
; MACROS:
;

;++
; SWITCH
;
; Functional description:
;
;	The contents of two data items of the specified length (B,W,L,Q)
;	are exchanged.
;
; Inputs:
;
;	A1	1st argument data item (cannot be R0 or R1)
;	A2	2nd argument data item (cannot be R0 or R1)
;
; Implicit inputs:
;
;	None.
;
; Outputs:
;
;	A1 and A2 are switched.
;
; Implicit outputs:
;
;	R0 is destroyed.  R1 is destroyed if length = Q.
;
;	All other registers are preserved.
;--
	.MACRO	SWITCH a1, a2, length=L
	MOV'length'	a1, R0
	MOV'length'	a2, a1
	MOV'length'	R0, a2
	.ENDM	SWITCH

;
; EQUATED SYMBOLS:
;
	.PAGE
	.SBTTL	IRP - CDRP Consistancy Check


; The following set of ASSUME statements will all be true as long as
;	the IRP and CDRP definitions remain consistent.

	ASSUME	CDRP$L_IOQFL-CDRP$L_IOQFL	EQ	IRP$L_IOQFL
	ASSUME	CDRP$L_IOQBL-CDRP$L_IOQFL	EQ	IRP$L_IOQBL
	ASSUME	CDRP$W_IRP_SIZE-CDRP$L_IOQFL	EQ	IRP$W_SIZE
	ASSUME	CDRP$B_IRP_TYPE-CDRP$L_IOQFL	EQ	IRP$B_TYPE
	ASSUME	CDRP$B_RMOD-CDRP$L_IOQFL	EQ	IRP$B_RMOD
	ASSUME	CDRP$L_PID-CDRP$L_IOQFL		EQ	IRP$L_PID
	ASSUME	CDRP$L_AST-CDRP$L_IOQFL		EQ	IRP$L_AST
	ASSUME	CDRP$L_ASTPRM-CDRP$L_IOQFL	EQ	IRP$L_ASTPRM
	ASSUME	CDRP$L_WIND-CDRP$L_IOQFL	EQ	IRP$L_WIND
	ASSUME	CDRP$L_UCB-CDRP$L_IOQFL		EQ	IRP$L_UCB
	ASSUME	CDRP$W_FUNC-CDRP$L_IOQFL	EQ	IRP$W_FUNC
	ASSUME	CDRP$B_EFN-CDRP$L_IOQFL		EQ	IRP$B_EFN
	ASSUME	CDRP$B_PRI-CDRP$L_IOQFL		EQ	IRP$B_PRI
	ASSUME	CDRP$L_IOSB-CDRP$L_IOQFL	EQ	IRP$L_IOSB
	ASSUME	CDRP$W_CHAN-CDRP$L_IOQFL	EQ	IRP$W_CHAN
	ASSUME	CDRP$W_STS-CDRP$L_IOQFL		EQ	IRP$W_STS
	ASSUME	CDRP$L_SVAPTE-CDRP$L_IOQFL	EQ	IRP$L_SVAPTE
	ASSUME	CDRP$W_BOFF-CDRP$L_IOQFL	EQ	IRP$W_BOFF
	ASSUME	CDRP$L_BCNT-CDRP$L_IOQFL	EQ	IRP$L_BCNT
	ASSUME	CDRP$W_BCNT-CDRP$L_IOQFL	EQ	IRP$W_BCNT
	ASSUME	CDRP$L_IOST1-CDRP$L_IOQFL	EQ	IRP$L_IOST1
	ASSUME	CDRP$L_MEDIA-CDRP$L_IOQFL	EQ	IRP$L_MEDIA
	ASSUME	CDRP$L_IOST2-CDRP$L_IOQFL	EQ	IRP$L_IOST2
	ASSUME	CDRP$L_TT_TERM-CDRP$L_IOQFL	EQ	IRP$L_TT_TERM
	ASSUME	CDRP$B_CARCON-CDRP$L_IOQFL	EQ	IRP$B_CARCON
	ASSUME	CDRP$Q_NT_PRVMSK-CDRP$L_IOQFL	EQ	IRP$Q_NT_PRVMSK
	ASSUME	CDRP$L_ABCNT-CDRP$L_IOQFL	EQ	IRP$L_ABCNT
	ASSUME	CDRP$W_ABCNT-CDRP$L_IOQFL	EQ	IRP$W_ABCNT
	ASSUME	CDRP$L_OBCNT-CDRP$L_IOQFL	EQ	IRP$L_OBCNT
	ASSUME	CDRP$W_OBCNT-CDRP$L_IOQFL	EQ	IRP$W_OBCNT
	ASSUME	CDRP$L_SEGVBN-CDRP$L_IOQFL	EQ	IRP$L_SEGVBN
	ASSUME	CDRP$L_JNL_SEQNO-CDRP$L_IOQFL	EQ	IRP$L_JNL_SEQNO
	ASSUME	CDRP$L_DIAGBUF-CDRP$L_IOQFL	EQ	IRP$L_DIAGBUF
	ASSUME	CDRP$L_SEQNUM-CDRP$L_IOQFL	EQ	IRP$L_SEQNUM
	ASSUME	CDRP$L_EXTEND-CDRP$L_IOQFL	EQ	IRP$L_EXTEND
	ASSUME	CDRP$L_ARB-CDRP$L_IOQFL		EQ	IRP$L_ARB

	.SBTTL	----- INITIALIZATION/REINITIALIZATION ROUTINES -----
	.SBTTL	DUTU$CREATE_CDDB - Create and initialize a CDDB
;++
;
; DUTU$CREATE_CDDB - Create and initialize a CDDB
;
; Functional Description:
;
;	This routine allocates pool for a disk or tape class driver CDDB, 
;	initializes that CDDB, and links it into the appropriate CDDB chain.
;	Some initialization of the CRB and DDB, previously created by SYSGEN 
;	or one of its kin, is also performed.
;
; Inputs:
;
;	R5	UCB address
;
; Implicit Inputs:
;
;	UCB$L_CRB(R5)		CRB address
;	UCB$L_DDB(R5)		DDB address
;	UCB$Q_UNIT_ID(R5)	system ID of remote system housing the server 
;				to which the class driver will connect 
;	UCB$L_STS(R5)		if UCB$V_VALID is clear, this UCB does not 
;				represent a real device and should be discarded 
;				when it is no longer needed
;
; Outputs:
;
;	R5	CDDB address
;
;	R0 through R5 are destroyed.
;	All other registers are preserved.
;
; Implicit Outputs:
;
;	The CDDB is completely initialized and ready for use by the class 
;	driver.  If UCB$V_VALID in UCB$L_STS is set CDDB$L_ORIGUCB contains 
;	the address of the UCB.  Otherwise, CDDB$L_ORIGUCB is zero and the UCB 
;	has been deallocated.  See the preamble for DUTU$POLL_FOR_UNITS for a 
;	discussion of boot device processing and CDDB$L_ORIGUCB.
;
;	DDB initialization:
;	The DDB is initialized to have no UCBs chained to it.  It is 
;	initialized to not be on any CDDB chain.
;
;	CRB initialization:
;	The CRB is threaded onto the TIMELINK chain with an infinite timeout 
;	interval.  CRB$L_AUXSTRUC is initialized to point to the CDDB.
;--

DUTU$CREATE_CDDB::

	POPL	UCB$L_DPC(R5)			; Save caller's return addr.
10$:	MOVZWL	#CDDB$K_DUTULENGTH, R1		; Get size of a CDDB.
	JSB	G^EXE$ALONONPAGED		; Attempt to allocate space.
	BLBS	R0, 20$				; Branch if allocation worked.
	FORK_WAIT				; Else, wait awhile and
	BRB	10$				; try again.

20$:	; R1 - size of allocated block
	; R2 - address of allocated block
	; R5 - UCB address
	PUSHR	#^M<R1,R2,R5>			; Save registers.
	MOVC5	#0, (SP), #0, R1, (R2)		; Zero entire block.
	POPR	#^M<R3,R4,R5>			; Restore saved registers.

	WAIT_FOR_IODB				; Get write access to the I/O
						; database.
	PUSHL	UCB$L_DPC(R5)			; Now that waiting is over,
						; restore caller's return addr.

	; R3 - size of allocated block
	; R4 - address of allocated block
	; R5 - UCB address
	MOVW	R3, CDDB$W_SIZE(R4)		; Setup CDDB size.
	ASSUME	CDDB$B_SUBTYPE  EQ  CDDB$B_TYPE+1
	MOVW	#<DYN$C_CLASSDRV -		; Set type and subtype fields
		 !<DYN$C_CD_CDDB@8>>, -		; with the CLASSDRV major type 
		CDDB$B_TYPE(R4)			; and CDDB subtype.
	MOVL	R5, R3				; Move UCB address.
	MOVL	R4, R5				; Move CDDB address.

	; R3 - UCB address
	; R5 - CDDB address
	ASSUME	CDDB$B_SYSTEMID+6  EQ  CDDB$W_STATUS
	MOVQ	UCB$Q_UNIT_ID(R3), -		; Record SYSTEM ID.
		CDDB$B_SYSTEMID(R5)
	MOVW	#<CDDB$M_INITING -		; Initialize CDDB status.
		 !CDDB$M_NOCONN>, -
		CDDB$W_STATUS(R5)

	; Set initial controller flages to be used on first Set Controller
	; Characteristics command.  The flags set are:
	;    - enable ATTENTION messages
	;    - enable miscellaneous error log messages
	;    - enable this host's error log messages
	MOVW	#<MSCP$M_CF_ATTN -
		 !MSCP$M_CF_MISC -
		 !MSCP$M_CF_THIS>, -
		CDDB$W_CNTRLFLGS(R5)

	MOVAB	CDDB$L_CDRPQFL(R5), -		; Initialize Queue listheads.
		CDDB$L_CDRPQFL(R5)
	MOVAB	CDDB$L_CDRPQFL(R5), -		;	"	"	"
		CDDB$L_CDRPQBL(R5)
	MOVAB	CDDB$L_RSTRTQFL(R5), -		;	"	"	"
		CDDB$L_RSTRTQFL(R5)
	MOVAB	CDDB$L_RSTRTQFL(R5), -		;	"	"	"
		CDDB$L_RSTRTQBL(R5)
	MOVAB	CDDB$L_CANCLQFL(R5), -		;	"	"	"
		CDDB$L_CANCLQFL(R5)
	MOVAB	CDDB$L_CANCLQFL(R5), -		;	"	"	"
		CDDB$L_CANCLQBL(R5)

	ASSUME	FKB$B_TYPE EQ <FKB$W_SIZE + 2>	; Initialize failover fork
	ASSUME	FKB$B_FIPL EQ <FKB$W_SIZE + 3>	; block contained in CDDB.
	MOVL	#<<IPL$_SCS@24> ! <DYN$C_FRK@16> -
		  ! FKB$K_LENGTH>, -
		<FKB$W_SIZE+CDDB$A_2PFKB>(R5)

	MOVAB	CDDB$A_PRMCDRP(R5), R2		; Locate permanent CDRP.
	BSBW	CDDB_INIT_PRM_CDRP		; Initialize it.
	MOVAB	CDDB$A_DAPCDRP(R5), R2		; Locate DAP CDRP.
	BSBW	CDDB_INIT_PRM_CDRP		; Initialize it.
	MOVL	R2, CDDB$L_DAPCDRP(R5)		; Save DAP CDRP address.

	MOVL	UCB$L_CRB(R3), CDDB$L_CRB(R5)	; Save CRB address.

; DDB initialization (and possibly UCB deallocation)

	MOVL	UCB$L_DDB(R3), R4		; Get DDB address.
	MOVL	R4, CDDB$L_DDB(R5)		; Save it in CDDB.
	CLRL	DDB$L_CONLINK(R4)		; Remove DDB from any CDDB 
						; chain.

	BBS	#UCB$V_VALID, -			; If UCB is valid, then this 
		UCB$L_STS(R3), 45$		; is the boot device.
	CLRL	DDB$L_UCB(R4)			; If UCB is not for the boot 
	MOVL	R3, R0				; device, then
	BSBW	DEANONPAGED			; unlink UCB from DDB
	BRB	50$				; and deallocate the UCB.

43$:	BUG_CHECK INCONSTATE, FATAL		; Non-system disk ORIGUCB.

45$:	CMPL	#SYS$GL_BOOTUCB, R3		; Is UCB for the boot device?
	BNEQ	43$				; If not, its a fatal error.
	MOVL	R3, CDDB$L_ORIGUCB(R5)		; Save boot device UCB addr.

; Link the new CDDB on the list of all CDDBs attended by this class driver.

	; The new CDDB is linked at the end of a chain of CDDBs for this 
	; device type (disk or tape).  While searching for the end of that 
	; chain, the system-id of the new CDDB is compared to the system-id 
	; of each currently known CDDB.  The new system-id should be unique.  
	; Otherwise, the class driver will make a second connection to a 
	; remote server with which it is already engaged in transactions.
	; When a match is found, the CDDB, the DDB, CRB, and IDB to which it 
	; points will all be unlinked (as appropriate) and deallocated.  All 
	; knowledge of the attempt to form two similar connections to the same 
	; server will be vaporized.

50$:	SUBL3	#CDDB$L_CDDBLINK, -		; Initialize previous CDDB addr.
		W^<DUTU$DATA + DUTU$L_CDDB_LISTHEAD>, -
		R0

53$:	MOVL	R0, R1				; Save previous CDDB address.
	MOVL	CDDB$L_CDDBLINK(R1), R0		; Link to next CDDB.
	BEQL	59$				; Branch if no more CDDBs.
	ASSUME	CDDB$S_SYSTEMID EQ 6
	CMPL	CDDB$B_SYSTEMID(R0), -		; Is new system-id different
		CDDB$B_SYSTEMID(R5)		; from one's already in use?
	BNEQ	53$				; Branch if different.
	CMPW	CDDB$B_SYSTEMID+4(R0), -
		CDDB$B_SYSTEMID+4(R5)
	BNEQ	53$				; Branch if different.
	BRB	DUPLICATE_SYSTEMID		; Branch if duplicate system-id.
59$:	MOVL	R5, CDDB$L_CDDBLINK(R1)		; Link new CDDB on end of list.

; CRB initialization

	MOVL	CDDB$L_CRB(R5), R3		; Get CRB address.
	CLRL	CRB$L_TOUTROUT(R3)		; Insure access violation 
						; untill a valid timeout 
						; routine is established.
	MNEGL	#1, CRB$L_DUETIME(R3)		; Set infinite due time.
	JSB	G^IOC$THREADCRB			; Thread CRB on TIMELINK chain.
	MOVL	R5, CRB$L_AUXSTRUC(R3)		; Now CDDB is aux structure.

	RSB					; Return to caller.

; Vaporize CDDB with duplicate system-id.

DUPLICATE_SYSTEMID:

	MOVL	CDDB$L_DDB(R5), R0		; Get DDB address.
	TSTL	DDB$L_UCB(R0)			; Check for UCBs.  None should
	BNEQ	OH_NO				; be found because this cannot
	TSTL	DDB$L_2P_UCB(R0)		; be the system disk CDDB.
	BNEQ	OH_NO
	ADDL3	#<SB$L_DDB - DDB$L_LINK>, -	; Get starting DDB chain 
		DDB$L_SB(R0), R1		; address.
10$:	MOVL	DDB$L_LINK(R1), R1		; Link to next DDB.
	BEQL	20$				; Branch if no more DDBs.
	CMPL	DDB$L_LINK(R1), R0		; Find DDB which points to 
	BNEQ	10$				; about to vaporize DDB.
	MOVL	DDB$L_LINK(R0), DDB$L_LINK(R1)	; Unlink vaporizing DDB.
20$:	BSBB	DEANONPAGED			; Deallocate DDB.
	MOVL	CDDB$L_CRB(R5), R4		; Get CRB address.
	MOVL	CRB$L_INTD+VEC$L_IDB(R4), R0	; Get IDB address.
	BSBB	DEANONPAGED			; Deallocate IDB.
	MOVL	R4, R0				; Setup CRB.
	BSBB	DEANONPAGED			; Deallocate CRB.
	TSTL	(SP)+				; Pop caller's return address.
	MOVL	R5, R0				; Setup CDDB.
DEANONPAGED:
	JMP	G^EXE$DEANONPAGED		; Deallocate it and terminate
						; this fork thread.

OH_NO:	BUG_CHECK MSCPCLASS, FATAL		; Found duplicate system-id on
						; a CDDB with units already 
						; associated.
	.PAGE
;++
;
; CDDB_INIT_PRM_CDRP - Initialize a CDRP permanently attached to a CDDB
;
; Functional Description:
;
;	This routine initializes one of the CDRPs permanently attached to a 
;	CDDB.  Because the CDRP is included in the CDDB allocation, it is 
;	zeroed when the CDDB is zeroed.  Therefore, only interesting, non- 
;	zero fields are initialized here.
;
; Inputs:
;
;	R2 - CDRP address
;	R5 - CDDB address
;
; Outputs:
;
;	R0 & R1 destroyed.
;	All other registers are preserved.
;--

CDDB_INIT_PRM_CDRP:

	ASSUME	CDDB$K_DUTULENGTH LT 32758
	SUBL3	R2, R5, R1			; Compute offset from CDRP 
						; base to CDDB base.
	MOVW	R1, CDRP$W_CDRPSIZE(R2)		; Store offset in CDRP size.
	ASSUME	CDRP$B_FIPL EQ CDRP$B_CD_TYPE+1
	MOVW	#<DYN$C_CDRP + <IPL$_SCS@8>>, -	; Initialize type and fork
		CDRP$B_CD_TYPE(R2)		; IPL.
	CLRL	CDRP$L_RWCPTR(R2)		; Clear pointer to RWAITCNT.
	MOVL	#CDRP$M_PERM, -			; Flag this a perm. IRP/CDRP.
		CDRP$L_DUTUFLAGS(R2)
	RSB

	.SBTTL	DUTU$POLL_FOR_UNITS - Poll a server for its available units
;++
;
; DUTU$POLL_FOR_UNITS - Poll a server for its available units
;
; Functional Description:
;
;	This routine polls a MSCP server to determin what units it has 
;	available.  This is done by sending GET UNIT STATUS commands with the 
;	NEXT UNIT modifier until all known units have been reported.  
;	Functional units which are not represented in the I/O data base have a 
;	UCB added.
;
; Special Processing for the Boot Device:
;
;	When the class driver is controlling the boot device, DUTU$CREATE_CDDB 
;	detects a UCB which is valid (UCB$V_VALID set in UCB$L_STS).  When 
;	this is the case, the UCB address is copied to CDDB$L_ORIGUCB.  In all 
;	other cases, CDDB$L_ORIGUCB is left zero and the UCB passed to the 
;	driver's controller initialization routine is deallocated.
;
;	While polling for units, this routine should find the boot device.  It 
;	will match the unit number to the unit number in the UCB pointed to by 
;	CDDB$L_ORIGUCB and when a match occurs it will begin special boot 
;	device processing.  After the special boot device processing is 
;	initiated for the first time, CDDB$L_ORIGUCB will be cleared.  This 
;	makes the special handling of the boot device a once per system boot 
;	occurence.
;
;	This processing differs from other poll units processing in two ways.  
;	The original UCB -- handed the class driver during controller 
;	initialization -- is used, not a newly created UCB.  Also, a special, 
;	limited form of mount verification (controlled completely by this 
;	routine and its subroutines) is performed.  This limited mount 
;	verification only performs a PACKACK function.  (As opposed to regular 
;	mount verification which performs both a PACKACK and a volume 
;	validation operation).  There is no memory stored volume information 
;	against which to validate the boot volume.  Also, system requirements 
;	at this stage of the booting process are limited to the boot device 
;	being accessible to the boot procedures (i.e. ONLINE).
;
;	N.B. this method works equally well for disks or tapes.  Although 
;	booting from tapes is not supported, its not prohibited by this code.
;
; Inputs:
;
;	R3	CDDB address
;	R4	PDT address
;	R5	address of the DAP CDRP
;
; Implicit Inputs:
;
;	CDDB$L_ORIGUCB(R3)	boot device UCB address, if first init. or
;				boot device by class driver; otherwise zero
;	CDRP$L_RSPID(R5)	a valid RSPID
;	CDRP$L_MSG_BUF(R5)	address of a valid SCS message buffer
;	CDRP$W_SIZE(R5)		offset to the CDDB
;	CDDB$W_STATUS(R3)	CDDB$V_DAPBSY set
;
;	The normal class driver MSCP operation timeout mechanism must be
;	enabled. 
;
; Outputs:
;
;	R3	CDDB address (same as input)
;	R4	PDT address  (same as input)
;	R5	CDRP address (same as input)
;
;	R0 through R5 are destroyed.
;	All other registers are preserved.
;--

	.ENABLE LSB

DUTU$POLL_FOR_UNITS::

	POPL	CDDB$L_SAVED_PC(R3)	; Save caller's return in CDDB field.
	BISW	#CDDB$M_POLLING, -	; Set bit indicating polling in 
		CDDB$W_STATUS(R3)	; progress.
	; Clearing CDRP$L_MEDIA causes the search for units to begin with 
	; unit 1.  MSCP dictates that unit 0 is the last unit to be polled.
	CLRL	CDRP$L_MEDIA(R5)
	ALLOC_RSPID			; Allocate a response-id.
	ALLOC_MSG_BUF			; Allocate a message buffer.
	BLBC	R0, 139$		; Branch if connection broken already.

POLL_LOOP:

	INIT_MSCP_MSG			; Initialize buffer for MSCP message.

	INCW	CDRP$L_MEDIA(R5)	; Proceed with next unit.
	MOVW	CDRP$L_MEDIA(R5), -	; Put next unit number in MSCP
		MSCP$W_UNIT(R2)		; command.

	MOVB	#MSCP$K_OP_GTUNT, -	; Command is GET UNIT STATUS.
		MSCP$B_OPCODE(R2)
	MOVW	#MSCP$M_MD_NXUNT, -	; Modifier is NEXT UNIT.
		MSCP$W_MODIFIER(R2)

	SEND_MSCP_MSG DRIVER		; Returns with END PACKET addr. in R2.

	MOVZWL	MSCP$W_UNIT(R2), -	; Save unit number located.
		CDRP$L_MEDIA(R5)

	; Check for having located the original UCB, possibly the system 
	; device, presented to the driver's controller initialization routine.

	MOVL	CDDB$L_ORIGUCB(R3), R0	; Get original UCB address.
	BEQL	30$			; Branch if no such UCB exists.
	CMPW	MSCP$W_UNIT(R2), -	; Does UCB unit match end-message
		UCB$W_MSCPUNIT(R0)	; unit number?
	BEQL	135$			; If match, go to special case code.

30$:	; Check end-message -- determine whether or not we want the unit it 
	; describes in our I/O data base.  We want the unit if the status is 
	; one of SUCC, AVLBL, DRIVE, or OFFLN (NOVOL).

	ASSUME	MSCP$V_ST_MASK EQ 0
	BICW3	#^cMSCP$M_ST_MASK, -	; Extract major MSCP status.
		MSCP$W_STATUS(R2), R0
	DISPATCH R0, type=W, prefix=MSCP$K_ST_, < -
		<SUCC,40$>, -
		<AVLBL,40$>, -
		<DRIVE,40$>, -
		<OFFLN,35$> -
		>
	BRB	90$			; If none of the above, ignore message.
135$:	BRB	DO_ORIG_UCB		; Branch assist.
139$:	BRB	POLL_CONN_BROKE		; Branch assist.

35$:	; For offline devices, accept only those who have no volume mounted or 
	; are disabled via the RUN/STOP switch, subcode NOVOL
	BBC	#MSCP$V_SC_NOVOL, -	; Is the subcode NOVOL?
		MSCP$W_STATUS(R2), 90$	; Branch if not NOVOL.

40$:	MOVZWL	CDRP$W_ENDMSGSIZ(R5), R1; Restore MSCP message size.
	BSBW	DUTU$NEW_UNIT		; Make sure a UCB exists for this unit.
	TSTL	R2			; Does UCB exist?
	BEQL	RESTART_POLL		; Branch if UCB does not exist.

FINISH_ORIGUCB:
	MOVL	CDRP$L_MSG_BUF(R5), R0	; Get message buffer address.
	ASSUME	MSCP$K_ST_SUCC EQ 0	; If the unit found was online,
	BITW	#MSCP$M_ST_MASK, -	; the unit flags are valid.
		MSCP$W_STATUS(R0)
	BNEQ	60$			; Branch if unit not online.
	MOVW	MSCP$W_UNT_FLGS(R0), -	; If online, copy unit flags to UCB.
		UCB$W_UNIT_FLAGS(R2)

60$:	; Insure that permanent CDRP and DAP CDRP have a UCB address.
	MOVL	R2, CDDB$L_PRMUCB(R3)	; Set permanent CDRP UCB address.
	MOVL	R2, CDDB$L_DAPUCB(R3)	; Set DAP CDRP UCB address.

90$:	TSTW	CDRP$L_MEDIA(R5)	; Was unit found zero?
	BEQL	95$			; If zero, all done:  exit.
	RECYCH_MSG_BUF			; Recycle message buffer.
	BLBC	R0, POLL_CONN_BROKE	; Branch if connection is broken.
	RECYCL_RSPID			; Recycle response-id.
	BRW	POLL_LOOP		; Loop till unit zero found.

95$:	BSBW	DUTU$DEALLOC_ALL	; Release all CDRP resources.
	BICW	#CDDB$M_POLLING, -	; Indicate that polling no longer is
		CDDB$W_STATUS(R3)	; in progress.
	JMP	@CDDB$L_SAVED_PC(R3)	; Return to original caller.

; The connection has broken during a polling operation.  Release CDRP 
; resources and abort the polling thread.

POLL_CONN_BROKE:
	BRW	DUTU$DEALLOC_ALL	; Release all CDRP resources and
					; terminate the polling fork thread.

; At this point, something went wrong trying to build a UCB for a unit 
; discovered in the polling process.  Most likely, there was not enough 
; non-paged pool to accomidate the UCB.  The process of polling for units
; will be restarted from the beginning.  Hopefully, by the time we return
; to the unit which could not be configured, some non-paged pool will be 
; available to configure it.  Otherwise, this is an infinite loop.

RESTART_POLL:
	RECYCL_MSG_BUF			; Recycle MSCP message buffer.
	RECYCL_RSPID			; Recycle the response ID.
	CLRL	CDRP$L_MEDIA(R5)	; Restart polling at unit 1.
	BRW	POLL_LOOP		; Restart loop.
	.PAGE
;
; HAND PROCESS BOOT DEVICE UCB
;
;	Boot device UCB fields are initialized from the get unit status 
;	packet.  A limited form of mount verification processing -- involving 
;	only a IO$_PACKACK -- is begun.  Finally, the UCB is properly linked 
;	into the I/O database.
;
; Inputs:
;	R0	UCB address
;	R2	MSCP message buffer address
;	R3	CDDB address
;	R4	PDT address
;	R5	CDRP address
;
; Outputs:
;
;	R0 & R1	scratch
;	R2	UCB address
;	R3	CDDB address (unchanged)
;	R4	PDT address (unchanged)
;	R5	CDRP address (unchanged)
;

DO_ORIG_UCB:
	PUSHR	#^M<R0,R3,R4,R5>	; Save registers.
	MOVZWL	CDRP$W_ENDMSGSIZ(R5), R1; Restore length of MSCP message.
	BSBW	DUTU$FILL_MSCP_MSG	; Zero fill the MSCP message.
	MOVL	MSCP$L_MEDIA_ID(R2), -	; Copy MSCP media identification.
		UCB$L_MEDIA_ID(R0)
	MOVW	MSCP$W_UNIT(R2), -	; Copy MSCP unit number.
		UCB$W_MSCPUNIT(R0)
	MOVL	R0, R5			; Setup UCB address.
	JSB	G^IOC$SEVER_UCB		; Unlink UCB.
	CREATE_FORK -			; Create a fork thread to relink
		LINK_NEW_UCB, -		; the original UCB.
		frkblk = (R5), -
		mask = <^M<>>
	MOVL	(SP), R5		; Restore UCB address.
	BBS	#UCB$V_MSCP_INITING, -	; Branch if UCB still initing;
		UCB$W_STS(R5), 388$	; it should not be!!!

	MOVL	UCB$L_DDT(R5), R0	; Get DDT address.
	CMPL	#IOC$RETURN, -		; Does this driver do mount 
		DDT$L_MNTVER(R0)	; verification?
	BEQL	320$			; If not, skip simulated mnt. ver.
	MOVZWL	#IRP$K_LENGTH, R1	; Get IRP size.
	JSB	G^EXE$ALONONPAGED	; Allocate one.
	BLBC	R0, 399$		; Branch if error.
	PUSHR	#^M<R1,R2,R5>		; Save valuable registers.
	MOVC5	#0, (SP), #0, R1, (R2)	; Zero the entire packet.
	POPR	#^M<R2,R3,R5>		; Restore saved registers.
	MOVW	R2, IRP$W_SIZE(R3)	; Set packet size.
	MOVB	#DYN$C_IRP, -		; Set packet type.
		IRP$B_TYPE(R3)
	ASSUME	IO$_PHYSICAL GE IO$_PACKACK
	MOVW	#IO$_PACKACK, -		; Set function code.
		IRP$W_FUNC(R3)
	MOVW	#<IRP$M_PHYSIO -	; Set IRP status flags.
		 !IRP$M_MVIRP>, IRP$W_STS(R3)
	BBSS	#UCB$V_MSCP_MNTVERIP, -	; Mark the UCB mount ver. in
		UCB$W_DEVSTS(R5), 310$	; progress, and bump wait
	INCW	UCB$W_RWAITCNT(R5)	; if that's needed.
310$:	MOVL	R5, IRP$L_UCB(R3)	; Set UCB address in IRP.
	MOVAB	B^END_ORIG_UCB_IO, -	; Set completion routine in IRP.
		IRP$L_PID(R3)
	JSB	G^IOC$INITIATE		; Begin the request.

320$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers.
	CLRL	CDDB$L_ORIGUCB(R3)	; Indicate no more original UCB.
	BRW	FINISH_ORIGUCB		; Rejoin polling loop.

388$:	BUG_CHECK MSCPCLASS, FATAL	; Boot UCB initialization waited for
					; something.  This should never happen.

399$:	BUG_CHECK MSCPCLASS, FATAL	; Could not allocate IRP for boot 
					; device PACKACK.  We could recover 
					; from this, but it should never happen.

	.DISABLE LSB
	.PAGE
;
; I/O POST ROUTINE FOR ORIG_UCB IO$_PACKACK
;
;	If the packack was successful, completion of mount verification is 
;	simulated.  Otherwise, the packack is resubmitted.
;
; Inputs:
;
;	R5	IRP address
;	IPL	IPL$_IOPOST
;
; Outputs:
;
;	R0 - R5 destroyed.
;	All other registers and IPL preserved.
;

END_ORIG_UCB_IO:

	BLBC	IRP$L_IOST1(R5), 90$		; Branch if PACKACK error.
	MOVL	R5, R0				; Copy IRP address.
	MOVL	IRP$L_UCB(R0), R5		; Get UCB address.
	BSBW	DEANONPAGED			; Deallocate IRP.
	DSBINT	UCB$B_FIPL(R5)			; Raise to fork IPL.
	CLRL	R3				; Signal end mount ver.
	MOVL	UCB$L_DDT(R5), R0		; Get DDT address.
	JSB	@DDT$L_MNTVER(R0)		; Call end mount ver. rout.
	ENBINT					; Restore IPL.
	RSB					; Return to our caller.

90$:	MOVL	R5, R3				; Copy IRP address.
	MOVAB	IRP$L_FQFL(R3), R5		; Setup CDRP for wait.
	FORK_WAIT				; Wait a while.
	MOVL	IRP$L_UCB(R3), R5		; Get UCB address.
	JMP	G^IOC$INITIATE			; Try PACKACK again.

	.SBTTL	DUTU$UNITINIT - Class driver unit initialization routine
;++
;
; DUTU$UNITINIT - Class driver unit initialization routine
;
; Functional Description:
;
;	The operating system calls this routine after calling the controller 
;	initialization routine:
;
;		at system startup
;		during driver loading
;		during recovery from a power failure
;
;	For the class drivers, the primary purpose of this routine is deletion 
;	of unnecessary UCBs created by SYSGEN.  For the purposes of determining 
;	whether or not to delete a UCB that UCB can be in one of three states 
;	upon entry to this routine:
;
;	    1.	The UCB can be online (i.e. UCB$V_ONLINE is set in UCB$W_STS). 
;		In this case, the UCB should not be deleted.  The UCB is 
;		either the system disk UCB, supplied at startup, or it is a 
;		UCB built during normal system operation by the class driver 
;		and this call was caused by a power failure.
;
;	    2.	The UCB can be offline after a power failure (i.e. 
;		UCB$V_ONLINE is clear and UCB$V_POWER is set in UCB$W_STS).  
;		Again, the UCB should not be deleted.  This call is the result 
;		of a power failure and the UCB is one of the CDP UCBs for a 
;		local device which has been found to be accessible via a class 
;		driver path.
;
;	    3.	The UCB can be offline with no power failure having occured 
;		(i.e. both UCB$V_ONLINE and UCB$V_POWER are clear in UCB$W_STS).
;		This UCB should be removed from the DDB chain and deleted.  It 
;		is a bogus UCB supplied by SYSGEN.
;
;	N.B. These tests depend heavily on two facts:
;
;	    a.	The DPT_STORE initialization macros do NOT set UCB$V_ONLINE.
;
;	    b.	The class driver controller initialization does set 
;		UCB$V_ONLINE in any UCB that potentially represents the system 
;		device.
;
;	To make life simpler and to keep SDA device desplays from looking 
;	"funny," this routine always clears UCB$V_POWER.  No other part of the 
;	class drivers test, reset, or care about this bit, but leaving it on 
;	eternally after a power failure will look wierd.
;
; Inputs:
;
;	R5	UCB address
;
; Outputs:
;
;	R0 and R1 are destroyed.
;	All other registers are preserved.
;--

DUTU$UNITINIT::

	BBSC	#UCB$V_POWER, UCB$W_STS(R5), -	; Clear the power failure bit
		90$				; and branch if it was set.
	BBS	#UCB$V_ONLINE, UCB$W_STS(R5), -	; Branch if the online bit
		90$				; is set.

	ASSUME	UCB$V_DELETEUCB GE 16
	BISB	#<UCB$M_DELETEUCB @ -16>, -	; Else, set the delete this
		UCB$L_STS+2(R5)			; UCB bit.
	JSB	G^IOC$DELETE_UCB		; Then, delete this UCB.

90$:	RSB					; Return to caller.

	.SBTTL	DUTU$FAILOVER_UCB - Failover a single UCB
;+
;  DUTU$FAILOVER_UCB - Failover a single UCB
;
;  Functional Description:
;
;	If conditions permit, the UCB whose address is in R5 has its primary 
;	path switched to its secondary path and vise versa.  The secondary 
;	path CDDB must exist and have all of the following bits clear for
;	failover to proceed:
;
;		CDDB$W_STATUS bit	meaning (when clear)
;
;		CDDB$V_SNGLSTRM		not in single stream mode
;		CDDB$V_INITING		not initializing
;		CDDB$V_RESYNCH		not resynchronizing
;		CDDB$V_POLLING		not polling for units
;		CDDB$V_NOCONN		has a good connection
;
;	The failover attempt is also prohibited whenever the UCB to be failed 
;	over has incomplete cancel operations.
;
;  Inputs:
;
;	R3	Address of UCB to be failed-over
;
;  Implicit Inputs:
;
;	UCB$L_CDDB(R3)		Address of current primary CDDB
;	UCB$L_2P_CDDB(R3)	Address of current secondary CDDB
;	UCB$L_DDB(R3)		Address of current primary DDB
;	UCB$L_2P_DDB(R3)	Address of current secondary DDB
;	UCB$L_LINK(R3)		Address of next UCB in primary DDB chain
;	UCB$L_2P_LINK(R3)	Address of next UCB in secondary DDB chain
;	UCB$L_CDDB_LINK(R3)	Address of next UCB in CDDB chain
;	UCB$W_MSCPUNIT(R3)	MSCP unit number for UCB
;	UCB$W_UNIT(R3)		Unit number for UCB
;	UCB$W_DEVSTS(R3)	UCB$V_MSCP_WAITBMP set if current (old) 
;				connection is performing a reconnect
;
;  Outputs:
;
;	R0	SS$_NORMAL ==> failover succesfully performed
;		SS$_MEDOFL ==> failover could not be performed
;
;	All other registers preserved
;
;  Implicit Outputs:
;
;	UCB unlinked from primary path, primary and secondary paths switched,
;	and UCB linked into former secondary path which is no primary.  UCB 
;	fields altered by this operation:
;
;	UCB$L_CDDB(R3)		Address of new primary CDDB
;	UCB$L_2P_CDDB(R3)	Address of new secondary CDDB
;	UCB$L_DDB(R3)		Address of new primary DDB
;	UCB$L_2P_DDB(R3)	Address of new secondary DDB
;	UCB$L_LINK(R3)		Address of next UCB in primary DDB chain
;	UCB$L_2P_LINK(R3)	Address of next UCB in CDDB chain
;	UCB$L_CRB(R3)		Address of CRB for new primary CDDB
;	UCB$W_RWAITCNT(R3)	bumped if new CDDB has CDDB$V_RECONNECT set:
;				decremented if new CDDB has CDDB$V_RECONNECT 
;				clear and UCB$V_MSCP_WAITBMP is set
;	UCB$W_DEVSTS(R3)	UCB$V_WAITBMP is made to match CDDB$V_RECONNECT
;				in the new CDDB
;
;	Then the original primary CDDB is restart queue scanned for CDRPs with 
;	CDRP$L_UCB matching the input UCB.  Each CDRP located is placed -- 
;	in the order found -- at the head of the UCB's I/O queue.
;
; Side Effects:
;
;	Because the I/O database DDB chains are updated to reflect a 
;	successful failover operation in a separate fork thread, that change 
;	may not appear immediately after this routine is called.  However, all 
;	changes required to successfully access the device have been made upon 
;	exit from this routine and I/O request processing can proceed 
;	immediately.  The I/O database will be updated as soon as the separate 
;	fork thread detects that the I/O database mutex is unowned.
;-

DUTU$FAILOVER_UCB::

	PUSHR	#^M<R1,R2,R3,R4,R5>		; Save registers.
	BBC	#DEV$V_2P, -			; Branch if device not dual-
		UCB$L_DEVCHAR2(R3), 90$		; path configured.
	MOVL	R3, R5				; Setup UCB address.
	MOVL	UCB$L_2P_CDDB(R5), R3		; Get secondary CDDB.
	BEQL	90$				; Branch if no secondary CDDB.
	BITW	#<CDDB$M_SNGLSTRM -		; Is secondary CDDB ready for
		 !CDDB$M_INITING -		; failover?
		 !CDDB$M_RESYNCH -
		 !CDDB$M_POLLING -
		 !CDDB$M_NOCONN>, -
		CDDB$W_STATUS(R3)
	BNEQ	90$				; Branch if sec. CDDB not ready.
	CLRL	R4				; Signal test UCB only.
	BSBW	DUTU$CHECK_NOCANCEL		; Check for active cancels.
	BLBS	R0, 100$			; Branch if no active cancels.
90$:	MOVZWL	#SS$_MEDOFL, R0			; Else, indicate failure.
	BRW	580$				; Branch to routine exit.


100$:	BSBW	DUTU$SEVER_CDDB			; Unlink UCB from failed CDDB
						; UCBs chain.
	SWITCH	UCB$L_CDDB(R5), -		; Switch primary and secondary
		UCB$L_2P_CDDB(R5)		; CDDB pointers.
	BSBW	DUTU$INIT_CONN_UCB		; Adjust connection dependent
						; UCB fields.
	; Adjust UCB$V_MSCP_WAITBMP and UCB$W_RWAITCNT to reflect any change 
	; in connection state between the former and the current connection.  
	; The following table describes the needed adjustment:
	;
	; WAITBMP  RWAITCNT	RECONNECT	WAITBMP  RWAITCNT  RWAITCNT
	;   old      old	new CDDB	  new	   new	  adjustment
	;
	;    0	       0	    0		   0	    0	       0
	;    0	       0	    1		   1	   +1	      +1
	;    1	      +1	    0		   0	    0	      -1
	;    1	      +1	    1		   1	   +1	       0
	;
	; Start by assuming new CDDB$V_RECONNECT is set and backout the 
	; adjustments if it is not.

	BBSS	#UCB$V_MSCP_WAITBMP, -		; Assume that a reconnect is in
		UCB$W_DEVSTS(R5), 125$		; progress and alter wait count
	INCW	UCB$W_RWAITCNT(R5)		; & bumped bit accordingly.
125$:	BBS	#CDDB$V_RECONNECT, -		; If reconnect in progress,
		CDDB$W_STATUS(R3), 130$		; skip wait count re adjustment.
	DECW	UCB$W_RWAITCNT(R5)		; Else, decrement bumped count
	ASSUME	UCB$V_MSCP_WAITBMP GE 8		; and clear wait count bumped
	BICB	#<UCB$M_MSCP_WAITBMP @ -8>, -	; bit.
		UCB$W_DEVSTS+1(R5)

130$:	MOVL	CDDB$L_CRB(R3), UCB$L_CRB(R5)	; Setup new CRB address in UCB.
	BSBW	DUTU$LINK_UCB2CDDB		; Link UCB into new CDDB chain.

	ASSUME	UCB$V_MSCP_FLOVR GE 8		; Switch UCB failed-over flag 
	XORB	#<UCB$M_MSCP_FLOVR @ -8>, -	; state.
		UCB$W_DEVSTS+1(R5)
	BBS	#CDDB$V_2PBSY, -		; Branch if I/O database update
		CDDB$W_STATUS(R3), 140$		; fork thread is already active.
	CREATE_FORK   DUTU$FAILOVER_IODB -	; Else, make the fork thread
		frkblk = CDDB$A_2PFKB(R3)	; active.

140$:	ADDL3	#CDDB$L_RSTRTQFL, -		; Get address of failed CDDB
		UCB$L_2P_CDDB(R5), R1		; restart queue header.
	ASSUME	CDRP$L_FQFL EQ 0		; Now form "previous" entry
	MOVL	R1, R0				; address for queue scan.
	MOVAL	UCB$L_IOQFL(R5), R2		; Init prev. entry for INSQUE.
150$:	MOVL	CDRP$L_FQFL(R0), R0		; Link to next restart CDRP.
	CMPL	R0, R1				; Is this the end?
	BEQL	570$				; Branch if this is the end.
	CMPL	CDRP$L_UCB(R0), R5		; Is this CDRP for this UCB?
	BNEQ	150$				; Branch if not our CDRP.
	REMQUE	(R0), R0			; Else, de-queue the CDRP.
	INSQUE	CDRP$L_IOQFL(R0), (R2)		; Add IRP to UCB I/O queue.
	MOVAL	CDRP$L_IOQFL(R0), R2		; Make this IRP predecessor
						; to the next.
	BRB	150$				; Go look for another CDRP.

570$:	MOVL	#SS$_NORMAL, R0			; Indicate success.
580$:	POPR	#^M<R1,R2,R3,R4,R5>		; Restore saved registers.
	RSB					; Exit.
	.PAGE
	.SBTTL	DUTU$FAILOVER_IODB - Update DDB I/O database after a failover
;++
;
; DUTU$FAILOVER_IODB - Update DDB I/O database after a failover
;
; Functional Description:
;
;	Since changes in the DDB - UCB chains in the I/O database must wait 
;	until the I/O database mutex is unowned and since such changes are not 
;	required for performing I/O requests by the class drivers, that I/O 
;	database update is performed (and maybe postponed) in this fork 
;	routine.  This routine uses a one-per-CDDB fork block.  Therefore, it 
;	cannot failover just one UCB.  It must scan all UCBs chained to the 
;	CDDB and failover all UCBs requiring such action.
;
;	After write access to the I/O database mutex is assured, all UCBs on 
;	the input CDDB requiring DDB-failover are so altered.  The failover is 
;	accomplished by unlinking the UCB from both the primary and the 
;	secondary DDB chains, switching primary and secondary DDBs, and 
;	relinking the UCB into the two (switched) chains.
;
; Inputs:
;
;	R3	CDDB address
;	R5	Failover (2P) fork block address
;
; Outputs:
;
;	R0 - R5 are destroyed.
;	All other registers are preserved.
;
; Special Notes:
;
;	This routine is coded so as not to assume that any UCB with the 
;	UCB$V_MSCP_FLOVR flag set must have its DDB chains switched.  
;	Currently, the two-path-per-device restriction plus the coding which 
;	sets UCB$V_MSCP_FLOVR in DUTU$FAILOVER_UCB do guarantee this to be the 
;	case.  However, may future plans indicate that such guarantees may not 
;	always be possible.  Therefore, this routine is coded is a cautious 
;	manner.
;--

	ASSUME	CDDB$V_2PBSY GE 8

DUTU$FAILOVER_IODB:

	BISB	#<CDDB$M_2PBSY @ -8>, -	; Set fork block busy flag.
		CDDB$W_STATUS+1(R3)
	WAIT_FOR_IODB			; Obtain I/O database write access.
	MOVAB	<CDDB$L_UCBCHAIN -	; Initialize "previous" UCB address.
		-UCB$L_CDDB_LINK>(R3), R5
	PUSHAB	B^999$			; Setup bug-trap for forking FIND_DDB.

10$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Link to next UCB.
	BEQL	90$			; Exit if no more UCBs to process.
	BBCC	#UCB$V_MSCP_FLOVR, -	; Branch if UCB not failed-over and
		UCB$W_DEVSTS(R5), 10$	; clear failed-over bit.
	MOVL	CDDB$L_DDB(R3), R4	; Setup starting DDB for DUTU$FIND_DDB.
	ADDL3	#DDB$T_NAME, -		; Setup device name address string for
		UCB$L_DDB(R5), R3	; DUTU$FIND_DDB.
	BSBW	DUTU$FIND_DDB		; Find right DDB on this CDDB for UCB.
	CMPL	R4, UCB$L_DDB(R5)	; Is correct DDB already primary?
	BEQL	10$			; Branch if correct DDB already setup.
	CMPL	R4, UCB$L_2P_DDB(R5)	; Is found DDB the secondary DDB?
	BNEQ	998$			; If not, something is very wrong.
	JSB	G^IOC$SEVER_UCB		; Unlink UCB from primary DDB chain.
	BSBW	DUTU$SEVER_SEC_UCB	; Unlink UCB from secondary DDB chain.
	SWITCH	UCB$L_DDB(R5), -	; Switch primary and secondary DDBs.
		UCB$L_2P_DDB(R5)
	MOVL	R5, R2			; Copy UCB address for relinking.
	JSB	G^IOC$LINK_UCB		; Relink to primary DDB chain.
	BLBC	R0, 997$		; Branch if relinking error.
	BSBW	DUTU$LINK_SEC_UCB	; Relink to secondary DDB chain.
	BLBC	R0, 997$		; Branch if relinking error.
	MOVL	UCB$L_CDDB(R5), R3	; Guarantee a correct CDDB address.
	BRB	10$			; Loop till no more UCBs to process.

90$:	TSTL	(SP)+			; Remove DUTU$FIND_DDB bug-trap.
	BICB	#<CDDB$M_2PBSY @ -8>, -	; Clear fork block busy flag.
		CDDB$W_STATUS+1(R3)
	RSB				; End fork thread.

; A duplicate unit number has been discovered during the primary or secondary 
; DDB relinking attempt.

997$:	BUG_CHECK INCONSTATE, FATAL

; The DDB found by DUTU$FIND_DDB is neither the primary nor the secondary DDB 
; for this UCB.  In this case, something is totally confused because there 
; should only be two CDDBs per UCB.  If more than two paths are allow for a 
; single device, some other action would be required at this point.

998$:	BUG_CHECK MSCPCLASS, FATAL

; DUTU$FIND_DDB has forked.  This should never happen.  FIND_DDB forks because 
; the I/O database in not available for write access or because it cannot 
; allocate pool for an new DDB.  However, this routine already has write 
; access to the I/O database mutex and the DDB which FIND_DDB is "looking" for 
; should already exist.  Therefore, DUTU$FIND_DDB forking is a very fatal 
; error.  Also note: that the MOVL used to restore the CDDB address just 
; before the BRB 10$ would be invalid should the DUTU$FIND_DDB actually fork.

999$:	BUG_CHECK MSCPCLASS, FATAL

	.SBTTL	----- NEW UNIT ROUTINES -----
	.SBTTL	DUTU$NEW_UNIT - Process a possible new unit
;++
;
; DUTU$NEW_UNIT - Process a possible new unit
;
; Functional Description:
;
;	This routine processes a unit available attention or get unit status 
;	end message.  If the I/O database does not reflect the presence of the 
;	unit described in the MSCP message, the new unit is added to the I/O 
;	database in whatever manner is appropriate.  The only condition which 
;	will prohibit adding the new unit is insufficient non-paged pool to 
;	accomidate the UCB.  When this occurs, the message is ignored.
;
;	First a check is made to determine whether the unit is already known 
;	to the I/O database.  The unit can be either on a primary or a 
;	secondary path.  If the unit belongs on a secondary path, the routine 
;	which checks for a previous secondary path condition will 
;	automatically place the unit on the secondary path.
;
;	If no primary or secondary UCB can be located, a new UCB is allocated.
;	If this allocation fails, control is immediately returned to the 
;	caller and no further attempt is made to represent the new unit in the 
;	I/O database.  
;
;	Upon successful allocation and setup by IOC$COPY_UCB, this routine 
;	fills in a few more fields in the new UCB.  The most important fields 
;	are those which are copies of the information in the MSCP message.  
;	This is the last opportunity in the UCB creation process to reference 
;	the MSCP message.  Once all the useful information has been copied 
;	from the MSCP message to the new UCB, a fork thread is started to 
;	complete initialization of the UCB and link it into the I/O database.
;
;	Whether or not it has been completely setup, the new UCB address is 
;	returned in R2.
;
; Inputs:
;
;	R1	size of the MSCP message
;	R2	base address of the MSCP message
;	R3	CDDB address
;
;
; Implicit Inputs:
;
;	Template UCB 		in .PSECT $$$200_TEMPLATE_UCB_01
;	Template ORB 		in .PSECT $$$200_TEMPLATE_ORB_01
;	DUTU$L_CDDB_LISTHEAD	location containing the system virtual address 
;				of the CDDB listhead for this device class
;
; Outputs:
;
;	R2	UCB address for unit represented in the MSCP message (either 
;		new or already existing)
;
;	R0 through R2 destroyed.
;	All other registers preserved.
;
; WARNINGS:
;
;	The UCB address returned by this routine may or may not be correctly 
;	linked into the I/O database.  The linking operation is performed in a 
;	seperate fork thread (which uses the UCB as a fork block).  This fork 
;	thread can become stalled due to lack of memory needed for creation of 
;	a DDB, due to lack of write access to the I/O database, or possibly 
;	some other reason.  The only thing which is certain is that at some 
;	time (now or in the future) the new unit will be represented by the 
;	UCB whose address is returned in R2.
;
; FORKING CONSIDERATIONS:
;
;	The UCB is currently used as a fork block by the class drivers in 
;	three different instances:
;
;	   1.	Creation of the CDDB when the controller initialization 
;		routine is called.
;	   2.	For the fork thread which links a new UCB into the I/O 
;		database.
;	   3.	For the fork thread which links the secondary path threads to 
;		a UCB which has been determined to represent a dual-pathed 
;		device.
;
;	Athough it is not obvious, these three uses cannot be competing to use 
;	the same UCB as a fork block concurrently.  Usage 1 occurs only when 
;	no connection to the MSCP server exists.  At that time, no MSCP 
;	messages can be received.  Therefore, usage 1 precludes usages 2 and 
;	3.  While the fork block is in type 2 usage, the UCB is unknown to the 
;	I/O database.  Therefore, it cannot be detected and put into use by a 
;	type 3 fork thread.  Thus usages 2 and 3 are mutually exclusive.
;
;	There is a race condition (which the LINK_NEW_UCB fork thread must 
;	detect).  This race results from a stalled new UCB thread preventing 
;	detection of a dual path condition.  Before actually linking a new UCB 
;	into the I/O database but after all possible stall conditions have 
;	been delt with, the new UCB fork thread must make one last attempt to 
;	dualpath link the new UCB.
;--

;
; Locate the template UCB and ORB
;

	.SAVE
	.PSECT	$$$200_TEMPLATE_UCB_00 RD,WRT,EXE,LONG
DUTU$TEMPLATE_UCB::

	.PSECT	$$$200_TEMPLATE_ORB_00 RD,WRT,EXE,LONG
DUTU$TEMPLATE_ORB::

	.RESTORE


DUTU$NEW_UNIT::

	CMPW	#4095, MSCP$W_UNIT(R2)	; KLUDGE ALERT:  Is the unit to be
	BEQL	19$			; created 4095?  If so, don't.
	BSBW	DUTU$LOOKUP_UCB		; Do we already know of this unit?
	BNEQ	15$			; Branch if unit already known.
	BSBW	DUTU$SETUP_DUAL_PATH	; Is this unit, or should this unit
					; be, dual pathed?
	TSTL	R0			; Was unit dual pathed?
	BEQL	30$			; Branch if unit not dual pathed.
15$:	MOVL	R0, R2			; Copy address of previous UCB.
	RSB				; Return to caller with address of 
					; previously existant UCB in R2.

18$:	MOVQ	(SP)+, R4		; Restore saved registers.
19$:	CLRL	R2			; Indicate new UCB cannot be created.
	RSB				; Exit without creating new UCB.

30$:	BSBW	DUTU$FILL_MSCP_MSG	; Zero extend the MSCP message.
	MOVQ	R4, -(SP)		; Save a couple of registers.
	MOVL	R2, R4			; Copy MSCP message address.
	MOVAB	W^DUTU$TEMPLATE_UCB, R5	; Get template UCB address.
	MOVAB	W^DUTU$TEMPLATE_ORB, -	; Set template ORB address.
		UCB$L_ORB(R5)
	JSB	G^IOC$COPY_UCB		; Make new UCB from template.
	BLBC	R0, 18$			; Branch if new UCB not created.

					; Compensate for unwanted IOC$COPY_UCB
					; initialization:
	MOVW	UCB$W_RWAITCNT(R5), -	; - Restore RWAITCNT.
		UCB$W_RWAITCNT(R2)
	MOVW	UCB$W_REFC(R5), -	; - Restore reference count.
		UCB$W_REFC(R2)
	MOVW	UCB$W_DEVSTS(R5), -	; - Restore device dependent status.
		UCB$W_DEVSTS(R2)

	ASSUME	UCB$L_MAXBLOCK EQ -	; Since no I/O will go to this "disk"
		UCB$L_RECORD		; before the first PACKACK, zero the
	CLRL	UCB$L_MAXBLOCK(R2)	; maximum block number (for tapes this 
					; harmlessly zeros the frame number).

					; Initialize fields required by the
					; final UCB setup fork thread:
	MOVL	MSCP$L_MEDIA_ID(R4), -	;  - MSCP media identification.
		UCB$L_MEDIA_ID(R2)
	MOVW	MSCP$W_UNIT(R4), -	;  - MSCP unit number.
		UCB$W_MSCPUNIT(R2)

	CREATE_FORK -			; Start a fork thread to complete
		LINK_NEW_UCB, -		; setup and linking of the new UCB
		frkblk = (R2), -	; into the I/O database.
		mask = <^M<R2,R3>>

	MOVQ	(SP)+, R4		; Restore saved R4 and R5.
	RSB				; Return to caller with new UCB 
					; address in R2.
	.PAGE
;++
;
; LINK_NEW_UCB
;
; Functional Description:
;
;	Acting in the context of an independent fork thread and using the UCB 
;	as a fork block this routine completes initialization of a new UCB and 
;	establishes the primary path linkage for that UCB.
;
;	The various backpointer fields in the UCB are filled in.  Previously 
;	uninitialized queue headers are initialized.  Where appropriate, state 
;	bits are altered.  If possible, a device type is determined.  The name 
;	of the device (DDCn form) is established.
;
;	A suitable DDB is located or created.  Then write access to the I/O 
;	database is obtained.  Either one or both of these operations may 
;	cause the thread to fork.
;
;	After completing those operations which can fork, a final check for 
;	a dual path device is made.  This eliminates a possible race between 
;	two new UCB creations for what is truely a dual pathed device.  If a 
;	dual path condition is found, the already existing I/O database is 
;	altered to reflect the dual path device and the UCB used as a fork 
;	block for this thread (and the thread itself) are discarded.
;
;	If the dual path lookup fails, the new UCB is linked into the I/O and 
;	class driver databases and some connection dependent fields are 
;	initialized to reflect the current connection to the actual device.
;
; Inputs:
;
;	R3	CDDB address
;	R5	UCB address (also used as a fork block)
;	fork context at IPL$_SCS
;
; Implicit Inputs:
;
;	UCB$W_MSCPUNIT(R5)	MSCP unit number for device
;	UCB$L_MEDIA_ID(R5)	MSCP media identification for device
;
; Outputs: None.
;
; Implicit Outputs:
;
;    Backpointers:
;	UCB$L_CRB(R5)		CRB address
;	UCB$L_DDT(R5)		DDT address
;
;    I/O Database and Class Driver Linkages:
;	UCB$W_UNIT(R5)		I/O database unit number
;	UCB$L_DDB(R5)		DDB address
;	UCB$L_LINK(R5)		Link to next UCB in DDB chain
;	UCB$L_CDDB(R5)		CDDB address
;	UCB$L_CDDB_LINK(R5)	Link to next UCB in CDDB chain
;
;    Connection Dependent:
;	UCB$L_CDT(R5)		CDT address
;	UCB$L_PDT(R5)		PDT address
;
;    Other:
;	UCB$W_DEVSTS(R5)	UCB$M_MSCP_INITING cleared
;	UCB$L_MAXBCNT(R5)	copied from PDT$L_MAXBCNT(pdt)
;
;	if CDDB is not initializing or reconnecting:
;	  UCB$W_DEVSTS(R5)	UCB$M_MSCP_WAITBMP cleared
;	  UCB$W_RWAITCNT(R5)	decremented
;
; WARNINGS:
;
;	The CDDB$L_DDB in this CDDB must point to at least one valid DDB for 
;	the devices which are (could be) accessed via that CDDB.  The major 
;	implication here is that we can never discard the DU or TU DDB handed 
;	us by SYSGEN, et. al. when calling the driver at its controller 
;	initialization entry point.
;--

LINK_NEW_UCB:

	; Guarantee sufficient space for device name formation.
	ASSUME	DDB$S_NAME EQ 16
	.IF	DEFINED UCB$L_CANLINK
	ASSUME	UCB$L_CDT     EQ <UCB$L_CDDB_LINK+4>
	ASSUME	UCB$L_CANLINK EQ <UCB$L_CDDB_LINK+8>
	ASSUME	UCB$Q_UNIT_ID EQ <UCB$L_CDDB_LINK+12>
	.IF_FALSE
	ASSUME	UCB$L_CDT     EQ <UCB$L_CDDB_LINK+4>
	ASSUME	UCB$S_UNIT_ID EQ 8
	ASSUME	UCB$Q_UNIT_ID EQ <UCB$L_CDDB_LINK+8>
	.ENDC
	MOVL	R3, UCB$L_CDDB(R5)		; Save CDDB address.
	MOVL	CDDB$L_DDB(R3), R4		; Get beginning DDB for scan.
	MOVAB	UCB$L_CDDB_LINK(R5), R3		; Begin device name setup.
	BSBW	DUTU$GET_DEVNAM			; Determine device name & unit.
	BSBW	DUTU$FIND_DDB			; Lookup that device name.
	MOVL	R4, UCB$L_DDB(R5)		; Save DDB address.
	CLRQ	UCB$L_CDDB_LINK(R5)		; Cleanup after name builder.
	CLRQ	UCB$L_CDDB_LINK+8(R5)

	WAIT_FOR_IODB				; Obtain write access to the
						; I/O database.

	; The following hack allows DUTU$SETUP_DUAL_PATH to be used for this
	; last chance dual path lookup.  It depends DUTU$LOOKUP_UCB using only 
	; the MSCP$W_UNIT field of a MSCP message.
	MOVL	#MSCP$W_UNIT+2, R1		; Fake MSCP message size.
	MOVAB	<UCB$W_MSCPUNIT -		; Fake MSCP message address.
		-MSCP$W_UNIT>(R5), R2
	MOVL	UCB$L_CDDB(R5), R3		; Get CDDB address too.
	BSBW	DUTU$SETUP_DUAL_PATH		; Make last chance check for
	TSTL	R0				; a dual pathed device.
	BNEQ	700$				; Branch if dual path found.

	MOVL	R5, R3				; Copy UCB address.
	BSBW	DUTU$GET_DEVTYPE		; Determine device type.
	MOVL	UCB$L_CDDB(R5), R3		; Restore CDDB address.
	MOVL	DDB$L_DDT(R4), UCB$L_DDT(R5)	; Setup DDT address.
	MOVL	CDDB$L_CRB(R3), UCB$L_CRB(R5)	; Setup CRB address.

	BSBW	DUTU$INIT_CONN_UCB		; Initialize connection
						; dependent fields.
	MOVL	UCB$L_PDT(R5), R0		; Get PDT address.
	MOVL	PDT$L_MAXBCNT(R0), -		; Copy maximum bytes per
		UCB$L_MAXBCNT(R5)		; count to UCB.

	; N.B. all actions which alter the condition of this UCB with respect 
	; to the remainder of the I/O database MUST occur following the call 
	; to IOC$LINK_UCB below.  This results from the possibility that 
	; IOC$LINK_UCB will determine that this UCB is a duplicate, afterwhich 
	; this UCB will be deallocated.

	MOVL	R5, R2				; Copy UCB address.
	JSB	G^IOC$LINK_UCB			; Link UCB to primary DDB.
	BLBC	R0, 700$			; If UCB is duplicate, quit.
	BSBW	DUTU$LINK_UCB2CDDB		; Link UCB into CDDB chain.

	MOVL	UCB$L_CDDB(R5), R3		; Restore CDDB address.
	BSBW	DUTU$SETUP_CDP_UCB		; If needed, setup local
						; UCB to class driver UCB
						; dual path.

	BITW	#<CDDB$M_INITING -		; Is init or reconnect "still"
		 !CDDB$M_RECONNECT>, -		; in progress?
		CDDB$W_STATUS(R3)		; If so somebody else will fix
	BNEQ	90$				; RWAITCNT and we can skip it.
	BICW	#UCB$M_MSCP_WAITBMP, -		; Else, indicate RWAITCNT no 
		UCB$W_DEVSTS(R5)		; longer bumped.
	DECW	UCB$W_RWAITCNT(R5)		; Decrement wait count.
	BNEQ	888$				; It had better be zero.

90$:	BICW	#UCB$M_MSCP_INITING, -		; Clear the "initing" flag.
		UCB$W_DEVSTS(R5)

	RSB					; dade, dade, dade; that's all 
						; folks.

700$:	MOVL	R5, R0				; Found dual path or dup. UCB: 
	BRW	DEANONPAGED			; deallocate this UCB and 
						; discontinue fork thread.

888$:	BUG_CHECK MSCPCLASS, FATAL		; RWAITCNT not zero at end of
						; new UCB setup.

	.SBTTL	DUTU$LOOKUP_UCB - Locate a given MSCP unit on given CDDB chain
;++
;
; DUTU$LOOKUP_UCB - Locate a given MSCP unit on given CDDB chain
;
; Functional Description:
;
;	The chain of UCBs linked to the CDDB whose address is input to this 
;	routine is scanned for a UCB containing a MSCP unit number matching 
;	the one in the input MSCP message.  If such a match is found, the 
;	address of the UCB is returned in R0.  Otherwise, R0 is returned as 
;	zero.
;
; Inputs:
;
;	R1	size of the MSCP message
;	R2	base address of the MSCP message
;	R3	CDDB address
;
; Outputs:
;
;	R0	address of the UCB with matching MSCP unit number, or zero
;
;	condition-code
;	  EQL ==> no match found [R0 EQL 0]
;	  NEQ ==> match found [R0 NEQ 0]
;
;	All registers except R0 are preserved
;--

DUTU$LOOKUP_UCB::

	CMPW	R1, #MSCP$W_UNIT+2		; Is message big enough to 
	BLSSU	90$				; contain a unit; branch if not.

	MOVAB	<CDDB$L_UCBCHAIN -		; Initialize previous UCB
		-UCB$L_CDDB_LINK>(R3), R0	; address.

10$:	MOVL	UCB$L_CDDB_LINK(R0), R0		; Link to next UCB.
	BEQL	90$				; Branch if no more UCBs.
	CMPW	UCB$W_MSCPUNIT(R0), -		; Is the MSCP unit number
		MSCP$W_UNIT(R2)			; right?
	BLSSU	10$				; If wrong, loop if still worth
	BGTRU	90$				; looking; else, exit w/ error.

	TSTL	R0				; If good, set condition code
	RSB					; and return.

90$:	CLRL	R0				; Signal UCB not found.
	RSB					; Return.

	.SBTTL	DUTU$SETUP_DUAL_PATH - Reflect dual path access in I/O database
;++
;
; DUTU$SETUP_DUAL_PATH - Reflect dual path access in I/O database
;
; Functional Description:
;
;	All UCBs linked to all CDDBs chained to the listhead given in R0 
;	(except the CDDB whose address is given in R3) is scanned for a UCB 
;	whose allocation class matches that of the CDDB pointed to by R3 and 
;	whose MSCP unit number matches the one in the input MSCP message.  If 
;	such UCB is found and has not already been dual path chained, the UCB 
;	will be dual path chained to input CDDB and its related I/O database.  
;	If the UCB is already chained to the input CDDB, no action is taken.  
;	If the UCB is already chained to some other CDDB, an "Inconsistant I/O 
;	database" bugcheck is generated.  If a UCB is found, its address is 
;	returned in R0.  Otherwise, R0 is returned as zero.
;
; Inputs:
;
;	R1	size of the MSCP message
;	R2	base address of the MSCP message
;	R3	CDDB address
;
; Implicit Inputs:
;
;	DUTU$L_CDDB_LISTHEAD	location containing the system virtual address 
;				of the CDDB listhead for this device class
; Outputs:
;
;	R0	address of the dual path UCB, or zero
;
;	All registers except R0 are preserved
;
; WARNINGS:
;
;	This routine does not scan the local node I/O database.  Therefore, 
;	only dual path devices which have both paths served by the disk or 
;	tape class driver will be found by this routine.  This feature is not 
;	needed until the MSCP server becomes capable of issuing access path 
;	attention messages.
;
;	The dual path nature of the device may not be reflected in the I/O 
;	database immediately upon exit from this routine.  That operation is 
;	performed in a fork thread which can become stalled due to lack of 
;	non-paged pool or inablilty to obtain write access to the I/O 
;	database.  When this routine exits, however, the fork thread has been 
;	established and it will complete at some future time.
;
;--

DUTU$SETUP_DUAL_PATH::

	MOVQ	R3, -(SP)			; Save a few registers.
	CMPW	R1, #MSCP$W_UNIT+2		; Is message big enough to 
	BLSSU	900$				; contain a unit; branch if not.

	MOVL	R3, R4				; Copy input CDDB address.
	SUBL3	#CDDB$L_CDDBLINK, -		; Initialize previous CDDB addr.
		W^<DUTU$DATA + DUTU$L_CDDB_LISTHEAD>, -
		R3	

10$:	MOVL	CDDB$L_CDDBLINK(R3), R3		; Link to next CDDB.
	BEQL	900$				; Branch if no more CDDBs.
	CMPL	R3, R4				; Is it the input CDDB?
	BEQL	10$				; Branch if input CDDB.
	MOVL	CDDB$L_ALLOCLS(R3), R0		; Can this CDDB dual path?
	BEQL	10$				; Branch if it can't dual path.
	CMPL	R0, CDDB$L_ALLOCLS(R4)		; Is it the right alloc. class?
	BNEQ	10$				; Branch if wrong alloc. class.
	BSBB	DUTU$LOOKUP_UCB			; Check for right UCB.
	BEQL	10$				; Branch if none found.

	MOVL	UCB$L_2P_CDDB(R0), R3		; Get secondary CDDB from UCB.
	BNEQ	930$				; Branch if UCB already 
						; dual pathed.
	MOVL	R4, UCB$L_2P_CDDB(R0)		; Else, setup input CDDB as 
	CREATE_FORK -				; the dual path CDDB and start
		LINK_2P_UCB, -			; fork thread to dual path
		frkblk = (R0), -		; link the UCB into the I/O
		mask = <^M<R0,R1,R2,R5>>	; database.
75$:	MOVQ	(SP)+, R3			; Restore saved registers.
	RSB					; Return to caller.

900$:	CLRL	R0				; Signal no UCB found.
	BRB	75$				; Then exit.

930$:	CMPL	R3, R4				; Is previous dual path CDDB
	BEQL	75$				; input CDDB?  Branch if yes.

	BUG_CHECK IVDSKCONFG, FATAL		; Else, bug check.
	.PAGE
;++
;
; LINK_2P_UCB - Fork thread to dual path link a UCB
;
; Functional Description:
;
;	Acting in the context of an independent fork thread and using the UCB 
;	as a fork block this routine establishes the dual path links for a 
;	UCB.  A suitable DDB is located or created.  Write access is obtained 
;	for the I/O database.  Finally, the UCB is dual path linked to the 
;	suitable DDB.
;
;	This routine potentially modifies UCB$L_MAXBCNT, the field giving the 
;	maximum number of bytes allowed in a single transfer.  The current 
;	value in that field -- which was established when the primary path was 
;	discovered -- is minimized with the PDT$L_MAXBCNT field in the PDT for 
;	the secondary path.  The effect is to generally use the minimum value 
;	accepted among the two paths on which the device is known.  A 
;	potential problem exists if the secondary path MAXBCNT value is 
;	smaller than the primary path value.  Some of the in progress 
;	transfers may exceed the secondary path MAXBCNT.  Should control be 
;	failed over to the secondary path before these transfers complete, 
;	those transfers could not be performed.  However, this risk is deemed 
;	minimal and will be addressed by a nonfatal bugcheck in the 
;	appropriate port driver (at the most).
;
; Inputs:
;
;	R5	UCB address (also used as a fork block)
;	fork context at IPL$_SCS
;
; Implicit Inputs:
;
;	UCB$L_2P_CDDB(R5) address of the CDDB for the secondary CDDB.  
;
; Outputs: None.
;
; Implicit Outputs:
;
;	UCB$L_2P_DDB(R5)  altered to point to the secondary path DDB
;	UCB$L_2P_LINK(R5) altered to link the UCB into the secondary chain of 
;			  UCBs for the DDB
;	DEV$M_2P set in UCB$L_DEVCHAR2(R5)
;	UCB$L_MAXBCNT(R5)	minimized with PDT$L_MAXBCNT(pdt)
;
; WARNINGS:
;
;	The CDDB$L_DDB in this CDDB must point to at least one valid DDB for 
;	the devices which are (could be) accessed via that CDDB.  The major 
;	implication here is that we can never discard the DU or TU DDB handed 
;	us by SYSGEN, et. al. when calling the driver at its controller 
;	initialization entry point.
;--

LINK_2P_UCB:

	ADDL3	#DDB$T_NAME, UCB$L_DDB(R5), R3	; Get address of DDC name.
	MOVL	UCB$L_2P_CDDB(R5), R0		; Get sec. CDDB address.
	MOVL	CDDB$L_DDB(R0), R4		; Get beginning DDB address.
	BSBB	DUTU$FIND_DDB			; Locate or make secondary DDB.
	MOVL	R4, UCB$L_2P_DDB(R5)		; Save secnodary DDB address.

	WAIT_FOR_IODB				; Obtain write access to the
						; I/O database.

	MOVL	UCB$L_2P_CDDB(R5), R0		; Get secondary CDDB address.
	MOVL	CDDB$L_PDT(R0), R0		; Get secondary PDT address.
	CMPL	PDT$L_MAXBCNT(R0), -		; Is secondary PDT bytes per
		UCB$L_MAXBCNT(R5)		; xfer smaller than UCB value?
	BGEQU	20$				; Branch if secondary larger.
	MOVL	PDT$L_MAXBCNT(R0), -		; If smaller, make secondary
		UCB$L_MAXBCNT(R5)		; bytes per xfer the UCB value.

20$:	MOVL	R5, R2				; Copy UCB address for linking.
	BSBW	DUTU$LINK_SEC_UCB		; Make secondary DDB links.
	BLBC	R0, 9999$			; Branch if error while linking.
	BISL	#DEV$M_2P, UCB$L_DEVCHAR2(R5)	; Flag device as dual pathed.
	RSB					; End fork thread.

9999$:	BUG_CHECK INCONSTATE, FATAL		; Signal inconsistant I/O db.

	.SBTTL	DUTU$FIND_DDB - Find or create a DDB with the right DEVNAM
;++
;
; DUTU$FIND_DDB - Find or create a DDB with the right DEVNAM
;
; Functional Description:
;
;	Starting with a given DDB, this routine searches a chain of DDBs 
;	attempting to find a requested DEVNAM (DDC - device DD, controller C).
;	If the requested DEVNAM is found, the corresponding DDB address is 
;	returned.  If the requested DEVNAM is not found, a DDB is created with 
;	attributes appropriate to the chain of DDBs being searched.  The 
;	created DDB is given the requested DEVNAM and both its primary and 
;	secondary UCB chains are initialized to be empty.  The newly created 
;	DDB is linked to the end of the DDB and CDDB chains which begin in the 
;	input DDB.  Finally, the address of the created DDB is returned.
;
; Inputs:
;
;	R3	address of the requested DEVNAM (a counted ASCII string)
;	R4	address of the beginning DDB for the search
;	R5	UCB address (used solely as a fork block)
;
; Outputs:
;
;	R4	DDB address
;	R5	UCB address (unchanged)
;
;	All other registers are destroyed.
;
; WARNINGS:
;
;	Under some circumstances, this routine will fork using the UCB as a 
;	fork block.  Control will be returned to the caller's caller.  Upon 
;	entry, 4(SP) must be the return address for the caller's caller.
;--

DUTU$FIND_DDB::

	POPL	UCB$L_DPC(R5)			; Save caller's address.

5$:	WAIT_FOR_IODB				; Obtain write access to the
						; I/O database.

	PUSHR	#^M<R3,R4,R6,R7>		; Save some registers.
	MOVL	R3, R6				; Copy DEVNAM address.
	MOVZBL	(R6)+, R7			; Get size of DEVNAM.
	BRB	15$				; Jump into search loop.

10$:	MOVL	DDB$L_CONLINK(R4), R4		; Link to next DDB.
	BEQL	70$				; Branch if no more DDBs.
15$:	CMPB	R7, DDB$T_NAME(R4)		; Is DDB DEVNAM the right size?
	BNEQ	10$				; No, go try next DDB.
	CMPC3	R7, (R6), DDB$T_NAME+1(R4)	; Does the name match?
	BNEQ	10$				; No, go try another DDB.

	POPR	#^M<R0,R1,R6,R7>		; DEVNAM match found, restore
	JMP	@UCB$L_DPC(R5)			; saved registers, discard 
						; saved R3 & R4, and return.

						; No DEVNAM match found:
70$:	POPR	#^M<R3,R4,R6,R7>		; Restore saved registers.
	MOVZBL	#DDB$K_LENGTH, R1		; Get size of a DDB so that
	JSB	G^EXE$ALONONPAGED		; a DDB can be allocated.
	BLBC	R0, 98$				; Branch on allocation error.
	PUSHR	#^M<R2,R5>			; Save interesting registers.
	MOVQ	R3, -(SP)			; Save input DEVNAM & DDB addrs.
	MOVC3	#DDB$K_LENGTH, (R4), (R2)	; Copy original DDB into
						; newly created DDB.
	POPL	R3				; Restore requested DEVNAM addr.
	MOVZBL	(R3)+, R4			; Get size of req. DEVNAM.
	ADDL3	#DDB$T_NAME+1, 4(SP), R2	; Locate DEVNAM in new DDB.
	MOVC3	R4, (R3), (R2)			; Insert requested DEVNAM.
	POPR	#^M<R3,R4,R5>			; Rest. old/new DDB & UCB addrs.

	CLRL	DDB$L_CONLINK(R4)		; New DDB will end CDDB chain.
	ASSUME	DDB$L_UCB EQ <DDB$L_LINK+4>	; New DDB will also end DDB 
	CLRQ	DDB$L_LINK(R4)			; chain.  Null primary UCB link.
	CLRL	DDB$L_2P_UCB(R4)		; Null secondary UCB link.

	MOVL	R3, R0				; Init for DDB chain scan.
83$:	TSTL	DDB$L_LINK(R0)			; End of DDB chain?
	BEQL	84$				; Branch if end of chain.
	MOVL	DDB$L_LINK(R0), R0		; Else, link to next DDB.
	BRB	83$				; and loop.
84$:	MOVL	R4, DDB$L_LINK(R0)		; Put new DDB on end of chain.

87$:	TSTL	DDB$L_CONLINK(R3)		; End of CDDB chain?
	BEQL	88$				; Branch if end of chain.
	MOVL	DDB$L_CONLINK(R3), R3		; Else, link to next DDB on 
	BRB	87$				; CDDB chain and loop.
88$:	MOVL	R4, DDB$L_CONLINK(R3)		; Put new DDB on end of chain.

	JMP	@UCB$L_DPC(R5)			; Return to caller.

						; Memory allocation failure.
98$:	FORK_WAIT				; Wait a little while using
	BRW	5$				; the UCB as a fork block;
						; then try looking for the DDB 
						; again.  Someone else may 
						; have created the DDB while 
						; we were waiting.

	.SBTTL	DUTU$LINK_SEC_UCB - Link UCB to secondary DDB chain
;+
;  DUTU$LINK_SEC_UCB - Link UCB to secondary DDB chain
;
;  Functional Description:
;
;	Search secondary UCB list pointed to by DDB referenced in input UCB and 
;	link input UCB into list in ascending unit number order.
;
;  Inputs:
;
;	R2	Address of UCB to be linked
;
;  Implicit Inputs:
;
;	UCB$L_2P_DDB(R2) Address of DDB on which UCB will be hung as a 
;		secondary UCB
;	UCB$W_UNIT(R2) Unit number for UCB
;
;      I/O database available for write access
;
;  Outputs:
;
;	R0	SS$_NORMAL ==> Link operation successful
;		SS$_OPINCOMPL ==> Link operation failed due to presence of UCB 
;			with same unit number
;	R1	Address of UCB following this one in the list
;	R2	Address of this UCB
;	R3	Address of UCB preceding this one in the list
;
;  Implicit Outputs:
;
;	UCB linked in to secondary UCBs chain.
;
;	All non-output registers preserved.
;-

DUTU$LINK_SEC_UCB::

	SUBL3	#<UCB$L_2P_LINK-DDB$L_2P_UCB>, -
		UCB$L_2P_DDB(R2), R1	; Get address of first UCB link.
20$:	MOVL	R1, R3			; Save address of previous UCB.
	MOVL	UCB$L_2P_LINK(R3), R1	; Get address of next UCB.
	BEQL	50$			; 0 ==> end-of-list reached; go insert.
	CMPW	UCB$W_UNIT(R2), UCB$W_UNIT(R1) ; Compare unit numbers.
	BGTRU	20$			; If new GT list, continue search.
	BEQL	90$			; If new EQ list, declare error.
50$:	MOVL	R1, UCB$L_2P_LINK(R2)	; Else, link UCB.  Forward link new UCB.
	MOVL	R2, UCB$L_2P_LINK(R3)	; Forward link previous UCB.
	MOVZWL	#SS$_NORMAL, R0		; Set successful link status
	RSB				; and return

90$:	MOVZWL	#SS$_OPINCOMPL, R0	; Set link failed status.
	RSB				; and return.

	.SBTTL	DUTU$LINK_UCB2CDDB - Link a UCB into a CDDB chain

;++
; DUTU$LINK_UCB2CDDB - Link a UCB into a CDDB chain
;
; Functional Description:
;
;	This routine links the UCB pointed to by R5 into the chain of UCB 
;	hanging off the CDDB pointed to by UCB$L_CDDB(R5).  The chain is 
;	maintained in ascending MSCP unit number order.
;
; Input Parameters:
;
;	R5	UCB address
;	IPL	IPL$_SCS
;
; Implicit Inputs:
;
;	UCB$L_CDDB(R5)		address of the CDDB anchoring the chain of
;				UCBs on which the UCB should be hung
;
; Output Parameters:
;
;	IPL	IPL$_SCS
;	R0-R1 destroyed.
;	All other registers preserved.
;
; Implicit Outputs:
;
;	UCB linked into CDDB units chain.
;
; Completion Codes:
;	NONE
;
; Side Effects:
;	NONE
;
;--

DUTU$LINK_UCB2CDDB::

	ADDL3	#<CDDB$L_UCBCHAIN -		; Initialize previous UCB
		 -UCB$L_CDDB_LINK>, -		; address.
		UCB$L_CDDB(R5), R0

10$:	MOVL	R0, R1				; Save previous UCB address.
	MOVL	UCB$L_CDDB_LINK(R1), R0		; Link to next UCB.
	BEQL	80$				; Branch if no more UCBs.
	CMPW	UCB$W_MSCPUNIT(R5), -		; Is this MSCP unit no. bigger
		UCB$W_MSCPUNIT(R0)		; than no. in this chain UCB?
	BGTRU	10$				; Branch if bigger.

80$:	MOVL	R0, UCB$L_CDDB_LINK(R5)		; Point new UCB to next UCB.
	MOVL	R5, UCB$L_CDDB_LINK(R1)		; Point previous UCB at new UCB.
	RSB

	.SBTTL	DUTU$SEVER_SEC_UCB - Unlink a secondary UCB
;+
;  DUTU$SEVER_SEC_UCB - Unlink a secondary UCB
;
; Functional Description:
;
;	Remove UCB pointed to by R5 from UCB secondary list pointed to by DDB
; 	referenced in UCB.
;
;  Inputs:
;
;      R5	Address of UCB to be unlinked
;
;  Implicit Inputs:
;
;	UCB$L_2P_DDB(R5) Address of DDB on which UCB is hung as a secondary UCB
;
;	I/O database available for write access
;
;  Outputs: None.
;
;  Implicit Outputs:
;
;	UCB unlinked from secondary UCBs chain.
;
;	R0 - R1 are destroyed.
;
;-

DUTU$SEVER_SEC_UCB::

	SUBL3	#<UCB$L_2P_LINK-DDB$L_2P_UCB>, -
		UCB$L_2P_DDB(R5), R0	; Get address of first UCB link.
10$:	MOVL	R0, R1			; Save address of last UCB.
	MOVL	UCB$L_2P_LINK(R1), R0	; Get address of next UCB.
	CMPL	R0,R5			; Do the UCB addresses match?
	BNEQ	10$			; Branch and loop if no match.
	MOVL	UCB$L_2P_LINK(R5), -	; Else, remove UCB from UCB list.
		UCB$L_2P_LINK(R1)
	RSB

	.SBTTL	DUTU$SEVER_CDDB - Sever UCB from CDDB chain

;++
; DUTU$SEVER_CDDB - Sever UCB from CDDB chain
;
; Functional Description:
;
;	This routine severs the UCB pointed to by R5 from the chain of UCB 
;	hanging off the CDDB pointed to by UCB$L_CDDB(R5).  The chain is 
;	maintained in ascending MSCP unit number order.
;
; Input Parameters:
;
;	R5	UCB address
;	IPL	IPL$_SCS
;
; Implicit Inputs:
;
;	UCB$L_CDDB(R5)		address of the CDDB anchoring the chain of
;				UCBs from which the UCB should be unlinked
;
; Output Parameters:
;
;	IPL	IPL$_SCS
;	R0-R1 destroyed.
;	All other registers preserved.
;
; Implicit Outputs:
;
;	UCB unlinked from CDDB units chain.
;
; Completion Codes:
;	NONE
;
; Side Effects:
;	NONE
;
;--

DUTU$SEVER_CDDB::

	ADDL3	#<CDDB$L_UCBCHAIN -		; Initialize previous UCB
		 -UCB$L_CDDB_LINK>, -		; address.
		UCB$L_CDDB(R5), R0

10$:	MOVL	R0, R1				; Save previous UCB address.
	MOVL	UCB$L_CDDB_LINK(R1), R0		; Link to next UCB.
	CMPL	R0, R5				; Is this the severed UCB?
	BNEQ	10$				; Branch if not found right UCB.

80$:	MOVL	UCB$L_CDDB_LINK(R5), -		; Make previous UCB point to
		UCB$L_CDDB_LINK(R1)		; UCB after severed UCB.
	RSB

	.SBTTL	Default device name and device type tables
;++
;
;	Below the default device name and default device type tables are 
;	built.  DUTU$GET_DEVNAM uses the default device name table to provide 
;	a device name whenever the MSCP media id does not provide one.  
;	DUTU$GET_DEVTYPE uses the default device type table to provide a 
;	device type whenever the MSCP media id cannot be translated into a 
;	device type.  The tables provide for generation of a different device 
;	name and device type for each MSCP controller model.
;--

;++
; MACRO DEF_DD_DT
;
; Functional Description:
;
;	This macro defines the tables used to "force" a device name and device 
;	type whenever the MSCP media identifier is invalid.  For 
;	DUTU$GET_DEVNAM, entries are placed in the word entry table pointed to 
;	by DUTU$AW_DEF_DEVNAM.  For DUTU$GET_DEVTYPE, entries are placed in 
;	byte entry table pointed to by DUTU$AB_DEF_DEVTYPE.  This macro 
;	automatically constructs patch space in both tables.
;--
	.MACRO	DEF_DD_DT LIST
	.MACRO	DEF_ONE ctrlmdl, dd, dt
	ASSUME	%LENGTH(dd) EQ 2
	.PSECT	$$$220_DEF_DEVNAM_TABLE RD,WRT,EXE,LONG
	.=<MSCP$K_CM_'ctrlmdl'*2>
	.ASCII	/dd/
	.IIF	GT .-$$BIGDD, $$BIGDD=.
	.PSECT	$$$220_DEF_DEVTYPE_TABLE RD,WRT,EXE,LONG
	.=MSCP$K_CM_'ctrlmdl'
	.BYTE	DT$_'dt'
	.IIF	GT .-$$BIGDT, $$BIGDT=.
	.ENDM	DEF_ONE
	.SAVE
	.PSECT	$$$220_DEF_DEVNAM_TABLE RD,WRT,EXE,LONG
DUTU$AW_DEF_DEVNAM::
$$BIGDD=.
	.PSECT	$$$220_DEF_DEVTYPE_TABLE RD,WRT,EXE,LONG
DUTU$AB_DEF_DEVTYPE::
$$BIGDT=.
	.IRP	ITEM, <LIST>
	DEF_ONE	ITEM
	.ENDR
	.PSECT	$$$220_DEF_DEVNAM_TABLE RD,WRT,EXE,LONG
.=$$BIGDD
	.WORD	0, 0, 0, 0
	.PSECT	$$$220_DEF_DEVTYPE_TABLE RD,WRT,EXE,LONG
.=$$BIGDT
	.BYTE	0, 0, 0, 0
	.RESTORE
	.ENDM	DEF_DD_DT
	.PAGE
; Build the tables

	DEF_DD_DT < -
		< HSC50, <DJ>, RA60 >, -
		< UDA50, <DJ>, RA60 >, -
		< RC25,  <DA>, RCF25 >, -
		< EMULA, <DY>, RX02 >, -
		< TU81,  <MU>, TU81 >, -
		< UDA52, <DJ>, RA60 >, -
		< RDRX,  <DU>, RD51 >, -
		>

	.SBTTL	DUTU$GET_DEVNAM - Form new unit device name, DDCn
;++
;
; DUTU$GET_DEVNAM - Form new unit device name, DDCn
;
; Functional Description:
;
;	Using the MSCP media identification, UCB$L_MEDIA_ID, and MSCP unit 
;	number, UCB$W_MSCPUNIT, fields this routine builds a VMS device name 
;	of the DDCn form.  The "DDC" is stored as a counted ASCII string based 
;	at the address input in R3.  The "n" is stored as an unsigned integer 
;	at UCB$W_UNIT in the input UCB.
;
; Inputs:
;
;	R3	base address for DDC counted ASCII string
;	R4	A prototype DDB address (used to determine default controller 
;		letter)
;	R5	UCB address
;
; Implicit Inputs:
;
;	UCB$L_CDDB(R5)		CDDB address
;	UCB$L_MEDIA_ID(R5)	MSCP media identification
;	UCB$W_MSCPUNIT(R5)	MSCP unit number
;
;	For emulated devices the MSCP unit number is assumed to have one of 
;	the following two forms:
;
;	15    14      12 11       8 7       4 3       0 	with 
;	+----+----------+----------+---------+---------+	MSCP$M_EU_CTYPE
;	!SHAD! EU_DESIG ! EU_CTYPE ! EU_SUBC ! EU_SUBU !	equals
;	+----+----------+----------+---------+---------+	MSCP$K_EMD_OLD
;
;	15    14      12 11       8 7                 0 	with 
;	+----+----------+----------+-------------------+	MSCP$M_EU_CTYPE
;	!SHAD! EU_DESIG ! EU_CTYPE !       EU_NO       !	not equal to
;	+----+----------+----------+-------------------+	MSCP$K_EMD_OLD
;
;	SHAD is MSCP$[V,S,M]_SHADOW and is one if the unit is a shadow unit 
;		number.
;	EU_DESIG is MSCP$[V,S,M]_EU_DESIG and is a number representing the 
;		controller letter used for the device on the node having 
;		direct access (i.e. not MSCP served access) to the device.
;	EU_CTYPE is MSCP$[V,S,M]_EU_CTYPE and is a constant representing the 
;		type of controller use to access the device on the node having 
;		direct access to the device.  The current choices for 
;		MSCP$M_EU_CTYPE are MSCP$K_EMD_OLD, MSCP$K_EMD_UDA, 
;		MSCP$K_EMD_HSC, MSCP$K_EMD_AZT (for AZTEC), and 
;		MSCP$K_EMD_RDRX.
;	EU_NO is MSCP$[V,S,M]_EU_NO and is the served unit number for all 
;		values of MSCP$M_EU_CTYPE except MSCK$K_EMD_OLD.
;	EU_SUBC is MSCP$[V,S,M]_EU_SUBC and is a constant giving a 
;		subcontroller type when MSCP$M_EU_CTYPE is MSCK$K_EMD_OLD.  
;		The current choices for MSCP$M_EU_SUBC are MSCP$K_EMS_RP, 
;		MSCP$K_EMS_RM, MSCP$K_EMS_RK, MSCP$K_EMS_RL, MSCP$K_EMS_RX, 
;		and MSCP$K_EMS_CNSL.
;	EU_SUBU is MSCP$[V,S,M]_EU_SUBU and is the served unit number when 
;		MSCP$M_EU_CTYPE is MSCK$K_EMD_OLD.
;
; Outputs:
;
;	R0 through R2 are destroyed.
;	All other registers are preserved.
;
; Implicit outputs:
;
;	(R3)			DDC counted ASCII string
;	UCB$W_MSCPUNIT(R5)	VMS unit number
;
;	The DD portion of "DDC" is taken from D0 and D1 in the MSCP media 
;	identifier (see the MSCP specification if this does not make sense).  
;	The "C" portion of "DDC" is S whenever MSCP$V_SHADOW is set 
;	(regardless of serving mechanism).  Otherwise, the "C" portion is A 
;	for non-emulated devices and the appropriate MSCP$M_EU_DESIG letter 
;	for emulated devices.  The unit number is UCB$W_MSCPUNIT .and.
;	^C<MSCP$M_SHADOW> for non-emulated devices, UCB$W_MSCPUNIT .and. 
;	MSCP$M_EU_NO for emulated devices with MSCP$M_EU_CTYPE not equal to 
;	MSCP$K_EMD_OLD, or UCB$W_MSCPUNIT .and. MSCP$M_EU_SUBU for emulated 
;	devices with MSCP$M_EU_CTYPE equals MSCP$K_EMD_OLD.
;
;	Note: this routine never uses MSCP$M_EU_DESIG, or MSCP$M_EU_SUBC.  The 
;	media identifier is used instead.
;--

DUTU$GET_DEVNAM:

	MOVL	UCB$L_CDDB(R5), R2		; Get CDDB address.
	MOVB	#3, (R3)			; Setup string byte count.
	MOVZBL	CDDB$B_CNTRLMDL(R2), R0		; Get MSCP server ctrl. model.
	MOVW	W^DUTU$AW_DEF_DEVNAM[R0], 1(R3)	; Set default "DD" value.

	EXTZV	#MSCP$V_MTYP_D0, -		; Pickup first character of
		#MSCP$S_MTYP_D0, -		; perfered device mnemonic.
		UCB$L_MEDIA_ID(R5), R0
	BEQL	30$				; Branch if no first char.
	ADDB3	#^a/A/-1, R0, 1(R3)		; Store first character.
	EXTZV	#MSCP$V_MTYP_D1, -		; Pickup second character of
		#MSCP$S_MTYP_D1, -		; perfered device mnemonic.
		UCB$L_MEDIA_ID(R5), R0
	BEQL	30$				; Branch if no second char.
	ADDB3	#^a/A/-1, R0, 2(R3)		; Store second character.

30$:	MOVZBL	DDB$T_NAME(R4), R0		; Get offset to controller let.
	MOVB	DDB$T_NAME(R4)[R0], 3(R3)	; Setup default C.
	BBC	#MSCP$V_SHADOW, -		; Branch if not a shadow
		UCB$W_MSCPUNIT(R5), 35$		; unit.
	MOVB	#^a/S/, 3(R3)			; Else, set C to be "S",
	BRB	50$				; and look no farther.
35$:	CMPB	#MSCP$K_CM_EMULA, -		; Is this the emulator?
		CDDB$B_CNTRLMDL(R2)
	BNEQ	50$				; Branch if not emulator.
	EXTZV	#MSCP$V_EU_DESIG, -		; For emulator, get C
		#MSCP$S_EU_DESIG, -		; from encoded MSCP unit 
		UCB$W_MSCPUNIT(R5), R0		; number.
	BEQL	50$				; Branch if no encoded C.
	ADDB3	#^a/A/-1, R0, 3(R3)		; Else, set encoded C.

50$:	BICW3	#MSCP$M_SHADOW, -		; Get least restrictive 
		UCB$W_MSCPUNIT(R5), R0		; possible unit number.
	CMPB	#MSCP$K_CM_EMULA, -		; Is this the emulator?
		CDDB$B_CNTRLMDL(R2)
	BNEQ	59$				; Branch if not emulator.
	BICW	#<MSCP$M_EU_DESIG -		; Otherwise, clear never
		 !MSCP$M_EU_CTYPE>, R0		; used unit number fields.
	ASSUME	MSCP$K_EMD_OLD EQ 0		; Next, determine whether
	BITW	#MSCP$M_EU_CTYPE, -		; whether or not EU_NO is
		UCB$W_MSCPUNIT(R5)		; correct.
	BNEQ	59$				; Branch if EU_NO is right.
	BICW	#MSCP$M_EU_SUBC, R0		; Else, clear EU_SUBC too.
59$:	MOVW	R0, UCB$W_UNIT(R5)		; Establish VMS unit number.

	RSB					; Return to caller.

	.SBTTL	DUTU$GET_DEVTYPE - Translate media-id to a device type
;++
;
; DUTU$GET_DEVTYPE - Translate media-id to a device type
;
; Functional Description:
;
;	This routine converts the MSCP media identifier stored in the input 
;	UCB into a VMS device type which is stored in the input UCB.
;
; Inputs:
;
;	R3	UCB address
;
; Implicit Inputs:
;
;	UCB$L_MEDIA_ID(R3)	MSCP media identifier value to be converted
;	UCB$L_CDDB(R3)		CDDB address
;	CDDB$B_CNTRLMDL(cddb)	MSCP controller model
;
;	MSCP media identifier to VMS device type conversion table in .PSECT 
;	$$$220_DEVTYPE_TABLE_01
;
; Outputs:
;
;	UCB$B_DEVTYPE(R3)	VMS device type
;
;	R0 is destroyed.
;	All other registers are preserved.
; --



;
; Locate conversion table
;
	.SAVE
	.PSECT	$$$220_DEVTYPE_TABLE_00 RD,WRT,EXE,LONG
DUTU$DEVTYPE_TABLE::
;
; Add some patch space to the conversion table
;
	.PSECT	$$$220_DEVTYPE_TABLE_02 RD,WRT,EXE,BYTE
	.REPEAT	5
	.LONG	0
	.BYTE	0
	.ENDR

	.RESTORE
	.PAGE
DUTU$GET_DEVTYPE::

	MOVAB	W^DUTU$DEVTYPE_TABLE, R0	; Get conversion table address.
	CLRB	UCB$B_DEVTYPE(R3)		; Assume lookup failure.
	BRB	15$				; Jump into table lookup loop.

10$:	INCL	R0				; Skip unused DEVTYPE value.
	TSTL	(R0)				; Check for end of table.
	BEQL	90$				; Branch if end of table.
15$:	CMPL	UCB$L_MEDIA_ID(R3), (R0)+	; Is this media-id in the table?
	BNEQ	10$				; Branch if not right id.
	MOVB	(R0), UCB$B_DEVTYPE(R3)		; Store that DEVTYPE.
	RSB					; Return.	

; Didn't find media match: use default.

90$:	MOVL	UCB$L_CDDB(R3), R0		; Get CDDB address.
	MOVZBL	CDDB$B_CNTRLMDL(R0), R0		; Get controller model.
	MOVB	W^DUTU$AB_DEF_DEVTYPE[R0], -	; Setup default device type.
		UCB$B_DEVTYPE(R3)
	RSB					; Return.

	.SBTTL	DUTU$INIT_CONN_UCB - Initialize connection dependent UCB fields
;++
;
; DUTU$INIT_CONN_UCB - Initialize connection dependent UCB fields
;
; Functional description:
;
;	This routine initializes those UCB fields which vary with connection.
;	It is called whenever the connection currently in use for a given UCB 
;	changes.
;
; Inputs:
;
;	R5	UCB address
;	R3	CDDB address for "current" connection
;
; Implicit Inputs:
;
;	CDDB$L_CDT(R3)	CDT address for "current connection
;	CDDB$L_PDT(R3)	PDT address for "current connection
;
; Outputs:
;
;	All registers preserved.
;
; Implicit Outputs:
;
;	UCB$L_CDT(R5)	CDT address for "current connection
;	UCB$L_PDT(R5)	PDT address for "current connection
;--

DUTU$INIT_CONN_UCB::

	MOVL	CDDB$L_CDT(R3), UCB$L_CDT(R5)	; Plant CDT address in UCB.
	MOVL	CDDB$L_PDT(R3), UCB$L_PDT(R5)	; Plant PDT address in UCB.

	RSB

	.SBTTL	DUTU$SETUP_CDP_UCB - Setup remote/local dual pathed device
;++
;
; DUTU$SETUP_CDP_UCB - Setup remote/local dual pathed device
;
; Functional Description:
;
;	This routine scans the local I/O database for a possible local path to 
;	a MSCP accessed device.  If such a local path is found, both the MSCP 
;	path UCB is altered to point to the local UCB and marked offline.  The 
;	local UCB is also altered to point to the MSCP path UCB.
;
; Inputs:
;
;	R3	CDDB address
;	R5	address of a MSCP UCB
;
; Implicit Inputs:
;
;	UCB$L_DDB(R5)	DDB address for the MSCP device
;	I/O database locked for scan access
;
; Outputs:
;
;	R0 - R2 destroyed.
;	All other preserved.
;
; Implicit Outputs:
;
;	If a local UCB is found:
;
;	UCB$L_2P_ALTUCB(R5)		is set to point to the local UCB
;	UCB$M_2P and UCB$M_CDP in UCB$L_DEVCHAR2(R5) are set
;	UCB$L_2P_DDB(R5)		is set to point to the local DDB
;	UCB$M_ONLINE in UCB$L_STS(R5)	is cleared
;	UCB$L_2P_ALTUCB(local-UCB)	is set to point to the MSCP UCB
;	UCB$M_2P in UCB$L_DEVCHAR2(local-UCB) is set
;	UCB$L_2P_DDB(local-UCB)		is set to point to the MSCP DDB
;
; Notes:
;
;	This routine has been coded with a seperate local UCB lookup 
;	subroutine in the hope that the routine can eventually be replaced 
;	with a call to an exeuctive routine.
;--

DUTU$SETUP_CDP_UCB:

	CMPB	#MSCP$K_CM_EMULA, -	; Only disks served by the MSCP server
		CDDB$B_CNTRLMDL(R3)	; can possibly have a local UCB.  The
	BNEQ	99$			; local UCB does not count if the it
					; represents UQPORT access to a device,
					; since such devices are already 
					; serviced by the class driver.

	PUSHR	#^M<R3,R4,R6,R7,R8>	; Save some registers.
	MOVL	UCB$L_DDB(R5), R0	; Get DDB address.
	MOVL	DDB$L_ALLOCLS(R0), R8	; Get allocation class.
	BEQL	90$			; Branch if allocation class not unique.
	MOVAB	DDB$T_NAME(R0), R7	; Get "DDC" address.
	MOVZWL	UCB$W_UNIT(R5), R6	; Get unit number.
	BSBB	LOOKUP_LOCAL_UCB	; Attempt to find a local UCB.
	TSTL	R0			; Was a local UCB found?
	BEQL	90$			; Branch if no local UCB found.
	BBS	#DEV$V_MSCP, -		; Branch if the local UCB found
		UCB$L_DEVCHAR2(R0), 90$	; is a class driver UCB.

	MOVL	R5, UCB$L_2P_ALTUCB(R0)	; Else point UCB's at each other.
	MOVL	R0, UCB$L_2P_ALTUCB(R5)
	BISL	#<DEV$M_CDP -		; Mark the MSCP UCB to show that there
		 !DEV$M_2P>, -		; is a local path to the device and
		UCB$L_DEVCHAR2(R5)	; it represents a dual pathed device.
	BISL	#DEV$M_2P, -		; Mark the local UCB to show that it
		UCB$L_DEVCHAR2(R0)	; represents a dual pathed device.
	MOVL	UCB$L_DDB(R0), -	; Setup alternate path DDB pointer
		UCB$L_2P_DDB(R5)	; in MSCP UCB.
	MOVL	UCB$L_DDB(R5), -	; Setup alternate path DDB pointer
		UCB$L_2P_DDB(R0)	; in local UCB.
	BICL	#UCB$M_ONLINE, -	; Mark the MSCP served UCB as being
		UCB$L_STS(R5)		; unusable.
	ASSUME	DEV$V_AVL GE 16		; Also make allocation and channel
	BICB	#<DEV$M_AVL @ -16>, -	; assignments impossible on the
		UCB$L_DEVCHAR+2(R5)	; MSCP server UCB.

90$:	POPR	#^M<R3,R4,R6,R7,R8>	; Restore registers.

99$:	RSB
	.PAGE
;++
; LOOKUP_LOCAL_UCB - Search for a local UCB
;
; Functional Description:
;
;	This routine searches the local I/O database for a UCB whose 
;	allocation class, and unit name, DDCn form, match those input.
;
; Inputs:
;
;	R6	desired unit number
;	R7	address of desired DDC counted ASCII string
;	R8	desired allocation class (presumable not zero)
;
; Outputs:
;
;	R0	address of a UCB meeting the criteria (or zero)
;
;	R0 through R4 are destroyed.
;	All other registers are preserved.
;
; Notes:
;
;	Hopefully, the fullness of time will allow this routine to be
;	replaced by a similar routine in the executive.
;--

LOOKUP_LOCAL_UCB:

	ASSUME	DDB$L_LINK EQ 0
	MOVAL	G^IOC$GL_DEVLIST, R4	; Get initial DDB address.

10$:	MOVL	DDB$L_LINK(R4), R4	; Get next DDB.
	BEQL	90$			; Branch if no more DDBs.
	CMPL	R8, DDB$L_ALLOCLS(R4)	; Right allocation class?
	BNEQ	10$			; Branch if wrong allocation class.
	CMPB	(R7), DDB$T_NAME(R4)	; Right "DDC" string size?
	BNEQ	10$			; Branch if wrong "DDC" string size.
	MOVZBL	(R7), R1		; Get "DDC" string size.
	CMPC3	R1, 1(R7), -		; Right "DDC" name?
		DDB$T_NAME+1(R4)
	BNEQ	10$			; Branch if wrong "DDC" name.

	MOVAB	<DDB$L_UCB -		; Initialize UCB address.
		-UCB$L_LINK>(R4), R0

20$:	MOVL	UCB$L_LINK(R0), R0	; Get next UCB address.
	BEQL	90$			; Branch if no more UCBs.
	CMPW	R6, UCB$W_UNIT(R0)	; Is this the right unit?
	BGTRU	20$			; Branch if more units to check.
	BNEQ	90$			; Branch if not right unit.
	RSB				; Return if unit found.

90$:	CLRL	R0			; Indicate no UCB found.
	RSB				; Exit

	.SBTTL	----- CANCEL ROUTINES -----
	.SBTTL	Cancel-CDRP Definitions
;++
;
;	The special IRP/CDRP pair (the cancel-CDRP) allocated to represent a 
;	cancel request is used only by the class driver.  It should never be 
;	seen by any of the standard VMS I/O processing routines.  Therefore, 
;	several IRP fields in the cancel-CDRP are resued to represent elements 
;	of the cancel request.
;
;	Canceled IRP/CDRP pairs requiring an ABORT command also have a field 
;	reused.  It is the I/O queue forward link.  These IRP/CDRPs will be 
;	returned to the control of cancel processing before that field is need 
;	for another purpose.
;
;	These field redefinitions are accomplished below.  These definitions 
;	apply only to the cancel routines which follow.
;--

; Define CDDB cancel queue links

ASSUME CDRP$L_IOQBL EQ <CDRP$L_IOQFL + 4>
ASSUME IRP$L_IOQBL EQ <IRP$L_IOQFL + 4>
CDRP$L_CANIOQFL = CDRP$L_IOQFL
CDRP$L_CANIOQBL = CDRP$L_IOQBL
IRP$L_CANIOQFL = IRP$L_IOQFL
IRP$L_CANIOQBL = IRP$L_IOQBL

; Define send an ABORT command queue header.

ASSUME CDRP$L_OBCNT EQ <CDRP$L_ABCNT + 4>
ASSUME IRP$L_OBCNT EQ <IRP$L_ABCNT + 4>
CDRP$L_SNDABTQFL = CDRP$L_ABCNT
CDRP$L_SNDABTQBL = CDRP$L_OBCNT
IRP$L_SNDABTQFL = IRP$L_ABCNT
IRP$L_SNDABTQBL = IRP$L_OBCNT

; Define ABORT sent queue header.

ASSUME CDRP$L_IOST2 EQ <CDRP$L_IOST1 + 4>
ASSUME IRP$L_IOST2 EQ <IRP$L_IOST1 + 4>
CDRP$L_ABTDQFL = CDRP$L_IOST1
CDRP$L_ABTDQBL = CDRP$L_IOST2
IRP$L_ABTDQFL = IRP$L_IOST1
IRP$L_ABTDQBL = IRP$L_IOST2

; Define place to save RSPID of canceled MSCP command.
CDRP$L_CAN_RSPID = CDRP$L_SEQNUM
IRP$L_CAN_RSPID = IRP$L_SEQNUM

; Define CANIO CDRP backpointer (for canceled IRP/CDRPs only).
CDRP$L_CANIOCDRP = CDRP$L_IOQFL
IRP$L_CANIOCDRP = IRP$L_IOQFL

	.SBTTL	DUTU$CANCEL - Cancel I/O Routine for class drivers
;++
;
; DUTU$CANCEL - Cancel I/O Routine for class drivers
;
; Functional Description:
;
;	This is the driver cancel I/O routine for the disk and tape class 
;	drivers.  It is called directly from the $CANCEL system service (due 
;	to the vector information in the class driver DDT.
;
;	Cancel processing interacts with other significant class driver 
;	operations including; device failover, reconnection processing, and 
;	host initiated bad block replacement (for disks only).  Generally 
;	speaking, these interactions are deliniated in this routine and the 
;	routines which follow it.  However, the bad block replacement code is 
;	in DUHIRT (due to the limited nature of its relivance).
;
;	The multi-threaded nature of the class drivers significantly 
;	complicates processing for the cancel function.  The requests to be 
;	canceled must be located in any one of several different places.  
;	Several different requests can be currently active.  Several requests 
;	can be stalled waiting for resources.
;
;	As requests to be canceled are located they will either have an 
;	associated MSCP request pending in the remote server, or for any one 
;	of several reasons, they will not have associated MSCP server 
;	requests.  When an associated MSCP server request exists, an MSCP 
;	ABORT command must be sent to the remote server.  Otherwise, the 
;	request can be completed immediately.
;
;	Before actually processing the cancel request, a check is maded to 
;	determine whether or not a similar cancel request is still being 
;	processed.  If a similar request is found, the routine exits without 
;	performing any processing; the cancel request is redundant and can be 
;	ignored.  Otherwise, further cancel processing is performed.
;
;	Next a IRP/CDRP pair is allocated to represent the cancel request.  
;	Several fields in the IRP/CDRP are initialized, including the 
;	CDRP$V_CANIO flag in CDRP$L_DUTUFLAGS which marks this IRP/CDRP as a 
;	special IRP/CDRP representing a pending cancel request.  Henceforth, 
;	this special IRP/CDRP will be refered to as the cancel-CDRP.  The 
;	cancel-CDRP is linked to the CDDB cancel queue (CDDB$L_CANCLQFL) so 
;	that it can be located easily.  Failure to allocate a cancel-CDRP 
;	results in immediate return to the $CANCEL system service without 
;	having accomplished anything.
;
;	Now, all the little nooks and crannies in which class driver I/O 
;	requests can be stashed are searched for IRP/CDRPs which need to be 
;	canceled.  All IRP/CDRP pairs located are tested against the cancel 
;	criteria.  An attempt is made to locate IRP/CDRPs holding no SCS 
;	resources first, IRP/CDRPs waiting for some SCS resources next, and 
;	IRP/CDRPs with assoicated MSCP requests last.
;
;	Those IRP/CDRPs which do not have an associated MSCP request are 
;	immediately sent to I/O post processing.  Those IRP/CDRPs which do 
;	have associated MSCP requests are marked as canceled (the CDRP$V_CAND 
;	bit is set in CDDB$L_DUTUFLAGS) and queued to the send an ABORT 
;	message queue hanging off of the cancel-CDRP (CDRP$L_SNDABTQFL).
;
;	N.B. no MSCP ABORT commands are sent until ALL IRP/CDRPs meeting the 
;	cancel criteria are located and processed.
;
;	At this point, it is possible to adjust the wait counter based upon 
;	the required adjustment factor accumulated as the IRP/CDRPs lookup and 
;	processing performed above.  After adjusting the wait count, activity 
;	on the device -- which was stalled due to an elevated wait count -- is 
;	resumed.
;
;	Since all the IRP/CDRP pairs meeting the cancel criteria have been 
;	located, it now is possible to issue the needed MSCP ABORT commands 
;	in an asynchronous fork thread and return to the $CANCEL system 
;	service.
;
;	Interactions with other class driver operations:
;
;	The major complication with other operations has to do with reforming 
;	broken connections to the MSCP server.  Four distinct situations might 
;	arise:
;
;	    o	the $CANCEL system service might be invoked during the middle 
;		of a reconnection attempt.  In this case, cancelable requests 
;		will be found on the restart queue (CDDB$L_RSTRTQFL) and 
;		terminated immediately, as they do not have an associated MSCP 
;		request.  A single cancelable request may be found to have an 
;		associated MSCP request, as a result of single step mode.  It 
;		must have an ABORT command sent to the remote MSCP server.
;
;	    o	the connection might fail during the lookup of IRP/CDRPs 
;		requiring cancelation (i.e. before the ABORT commands can be 
;		sent).  This condition is recognized by a failure to allocate 
;		a message buffer to send the ABORT.  All the IRP/CDRPs to be 
;		canceled have already been located and removed from normal 
;		class driver work and SCS resource wait queues.  Therefore, 
;		they will not be automatically restarted; they only need to be 
;		queued for I/O post processing.  Then, the cancel operation 
;		can simply be terminated.
;
;	    o	the connection might fail while and ABORT command is 
;		outstanding.  This condition is detected by DUTU$INSERT_RESTRTQ
;		when it tries to insert a cancel-CDRP on the restart queue.
;		Instead of queueing the cancel-CDRP, all remaining IRP/CDRPs 
;		to be canceled are queued for I/O post processing and the 
;		cancel operation is terminated.
;
;	    o	the connection might fail after all the ABORT have completed 
;		but before all the canceled I/O requests have terminated.  
;		This is handled by reconnection processing.  At an appropriate 
;		time, all canceled IRP/CDRPs are queued for I/O post 
;		processing and the cancel operation is terminated.
;
;	There also is an interaction with device failover.  Because the 
;	presence of incomplete cancel operations signals incomplete but soon 
;	to be completed activity on a device and because it is not convenient 
;	to move that activity to a new path, device failover is not permitted 
;	when incomplete cancel operations are detected for the device.
;
;	The final, and perhaps most important, interaction with other class 
;	driver operations occurs in MSCP end-packet processing.  The common 
;	MSCP end-packet processing routine tests the CDRP$V_CAND bit 
;	associated with each incomming MSCP end-packet.  If this bit is set, 
;	DUTU$END_CAND_REQ is called, to test for possible completion of the 
;	pending cancel operation.
;
; Inputs:
;
;	R2	Channel index number on which cancel is to be performed
;	R4	Process PCB address
;	R5	Device UCB address
;
;	IPL	UCB$B_FIPL
;
; Outputs:
;
;	R0 through R3 are destroyed.
;	All other registers are preserved.
;--

DUTU$CANCEL::

	BSBW	DUTU$CHECK_NOCANCEL	; Check for similar cancel request.
	BLBS	R0, 10$			; Branch if no similar cancel request
					; is in progress.
9$:	RSB				; Else, exit doing nothing.

10$:	BSBW	DUTU$BUILD_CANIO_CDRP	; Build cancel-CDRP.
	BLBC	R0, 9$			; Branch if CDRP build failed.

	MOVL	R5, R3			; Move UCB address.
	MOVAB	IRP$L_FQFL(R1), R5	; Get cancel-CDRP address.


;
; Search for IRP/CDRP pairs meeting the cancel criteria.
;

	; Search through the restart queue for IRP/CDRPs to cancel.

	ADDL3	#CDDB$L_RSTRTQFL, -	; Get restart queue header address.
		UCB$L_CDDB(R3), R1
	MOVL	R1, R2			; Copy header address.

110$:	MOVL	CDRP$L_FQFL(R2), R2	; Link to next restart CDRP.
	CMPL	R2,R1			; End of queue?
	BEQL	130$			; Branch if end of restart queue.
	IFNOCANCEL cdrp=(R2), then=110$	; Branch if don't cancel this CDRP.
	REMQUE	(R2), R0		; Dequeue CDRP & get address in R0.
	POST_CDRP status=SS$_CANCEL	; Insert packet in IOPOST queue.
	BRB	110$

130$:	; Cancel all requests waiting for (or using) the HIRT.

	.WEAK	DU$CANCEL_FROM_HIRT
	MOVAB	G^DU$CANCEL_FROM_HIRT, R0  ; Get HIRT cancel routine address.
	BEQL	150$			   ; Branch if no HIRT routine to call.
	JSB	(R0)			   ; Else, call cancel from HIRT.

150$:	; Search the RDT wait queue and the RDT itself.

	MOVL	CDRP$L_CDT(R5), R3	; Get CDT address for SCS searches.
	MOVL	R5, R1			; Copy CANIO CDRP addr. for SCS search.

	SCAN_RSPID_WAIT	-		; Scan RDT wait queue.
		action = DUTU$CANCEL_RDTWAIT
	SCAN_RDT -			; Scan RDT.
		action = DUTU$CANCEL_RDT
	MOVL	R1, R5			; Restore CANIO CDRP address to R5.

;
; Update wait count, and if necessary, unstall UCB.
;

	MOVW	CDRP$W_DUTUCNTR(R5), R0	; Get number of decrements to do.
	BEQL	200$			; Branch if no decrements required.
	MOVQ	R4, -(SP)		; Save registers of interest.
	MOVL	CDRP$L_UCB(R5), R5	; Get UCB to unstall.
	SUBW	R0, UCB$W_RWAITCNT(R5)	; Decrement wait count.
	JSB	G^SCS$UNSTALLUCB	; Start up any stalled requests.
	MOVQ	(SP)+, R4		; Restore registers.
	
;
; If MSCP ABORT commands are required, start a fork thread to send them.
; Otherwise, simply end the cancel request now.
; In any case, return to the $CANCEL system service.
;

200$:	MOVAB	CDRP$L_SNDABTQFL(R5), R0; Get send-abort queue header.
	CMPL	R0, (R0)		; Test for an empty queue.
	BNEQ	250$			; Branch if queue not empty.
	PUSHL	CDRP$L_UCB(R5)		; Else, save UCB address.
	BSBW	DUTU$END_CANCEL		; End cancel operation now.
	POPL	R5			; Restore UCB address.
	RSB				; Return to cancel system service.

250$:	CREATE_FORK -			; Create fork thread to
		SEND_ABORTS, -		; send the needed ABORT commands.
		frkblk = (R5), -
		mask = <^M<R4>>

	MOVL	CDRP$L_UCB(R5), R5	; Restore UCB address in R5.
	RSB				; Return to $CANCEL system service.

	.SBTTL	SEND_ABORTS - Send ABORT commands for active MSCP requests
;++
;
; SEND_ABORTS - Send ABORT commands for active MSCP requests
;
; Functional Description:
;
;	This independent fork thread sends MSCP ABORT commands for every CDRP 
;	on a cancel-CDRP SNDABT queue.  The cancel-CDRP is used as a fork 
;	block for these operations.  Each CDRP queued to CDRP$L_SNDABTQFL is 
;	removed from that queue and queued to CDRP$L_ABTDQBL, the ABORT sent 
;	queue.  Then an MSCP ABORT command is sent to the remote server.
;	This proceeds until CDRP$L_SNDABTQFL is empty.
;
; Inputs:
;
;	R4	PDT address
;	R5	cancel-CDRP address
;
; Outputs:
;
;	R0 through R5 destroyed.
;	All other registers preserved.
;--

SEND_ABORTS:

	MOVL	CDRP$L_UCB(R5), R3		; Get UCB address.
	MOVL	UCB$L_PDT(R3), R4		; Get PDT address.

10$:	REMQUE	@CDRP$L_SNDABTQFL(R5), R1	; Get CDRP to abort.
	BVS	90$				; Branch if no more CDRPs.

	INSQUE	(R1), @CDRP$L_ABTDQBL(R5)	; Queue "aborted" CDRP.

	MOVL	CDRP$L_RSPID(R1), -		; Save RSPID to abort.
		CDRP$L_CAN_RSPID(R5)

	ALLOC_RSPID				; Allocate RSPID for ABORT cmd.
	ALLOC_MSG_BUF				; Allocate a message buffer too.
	BLBC	R0, 900$			; Branch if connection broke.
	INIT_MSCP_MSG ucb=(R3)			; Initialize ABORT message.
	MOVB	#MSCP$K_OP_ABORT, -		; Set ABORT MSCP opcode.
		MSCP$B_OPCODE(R2)
	MOVL	CDRP$L_CAN_RSPID(R5), -		; Set RSPID to abort.
		MSCP$L_OUT_REF(R2)
	SEND_MSCP_MSG				; Send ABORT command.
	BSBW	DUTU$DEALLOC_RSPID_MSG		; Deallocate RSPID & msg. buf.

	BRB	10$				; Repeat until no more CDRPs 
						; to be canceled.

90$:	; All needed ABORT commands have been sent.

	CLRQ	CDRP$L_FQFL(R5)			; Signal cancel-CDRP not queued.
	RSB					; Terminate fork thread.

900$:	; Connention to the remote server broke.  Complete this cancel
	; operation now.  No more abort commands need be sent.

	BRW	DUTU$END_CANCEL			; Complete cancel operation 
						; and terminate fork thread.

	.SBTTL	DUTU$CHECK_NOCANCEL - Check for no similar cancel requests
;++
;
; DUTU$CHECK_NOCANCEL - Check for no similar cancel requests
;
; Functional Description:
;
;	This routine scans the CDDB in-progress cancel operations queue for 
;	the primary CDDB of the input device looking for cancel operations 
;	similar to that described by the other input registers.  If a no 
;	similar cancel operation is found, success status is returned.  If as 
;	many as one similar cancel operation is found, failure status is 
;	returned.  The input criteria may describe an entire cancel operation 
;	or just the relivant UCB.
;
; Inputs:
;
;	R2	Channel index for cancel operation
;	R4	PCB address (or zero if PID and channel index tests are not to 
;			be done)
;	R5	UCB address
;
; Implicit inputs:
;
;	UCB$L_CDDB(R5)	CDDB address
;
; Outputs:
;
;	R0	LBS ==> no similar cancel operation found
;		LBC ==> similar cancel operation found
;	R1	is destroyed.
;	All other registers are preserved.
;--

DUTU$CHECK_NOCANCEL:

	ASSUME	IRP$L_CANIOQFL EQ IRP$L_IOQFL
	ASSUME	IRP$L_IOQFL EQ 0

	ADDL3	#CDDB$L_CANCLQFL, -		; Get CDDB cancel queue header
		UCB$L_CDDB(R5), R0		; address.
	MOVL	R0, R1				; Copy that address.

10$:	MOVL	IRP$L_CANIOQFL(R0), R0		; Link to next CANIO CDRP.
	CMPL	R0, R1				; Is this end of queue.
	BEQL	100$				; Branch if end of queue.
	CMPL	R5, IRP$L_UCB(R0)		; Is this the right UCB?
	BNEQ	10$				; Branch if wrong UCB.
	TSTL	R4				; Are full tests needed?
	BEQL	90$				; Branch if full tests unneeded.
	CMPL	PCB$L_PID(R4), IRP$L_PID(R0)	; Is this the right PID?
	BNEQ	10$				; Branch if wrong PID.
	CMPW	R2, IRP$W_CHAN(R0)		; Is this the right channel?
	BNEQ	10$				; Branch if wrong channel index.

90$:	; Oops.  Found a similar cancel request.
	CLRL	R0				; Signal similar request found.
	RSB					; Return error.

100$:	; Goodie.  No similar request found.
	MOVL	#1, R0				; Signal no request found.
	RSB					; Return success.

	.SBTTL	DUTU$BUILD_CANIO_CDRP - Allocate & Initialize a cancel-CDRP
;++
;
; DUTU$BUILD_CANIO_CDRP - Allocate & Initialize a cancel-CDRP
;
; Functional Description:
;
;	This routine allocates space for and initializes a cancel-CDRP, the 
;	IRP/CDRP which represents a cancel operation in progress.  In addition,
;	this routine links the new cancel-CDRP to the CDDB queue of active 
;	cancel-CDRPs.
;
;	If the cancel-CDRP cannot be allocated, an error status is returned in 
;	R0.  Otherwise, a success status is returned.
;
; Inputs:
;
;	R2	Channel index number on which cancel is to be performed
;	R4	Process PCB address
;	R5	Device UCB address
;
; Outputs:
;
;	R0	SS$_NORMAL cancel-CDRP built without incident
;		SS$_INSFMEM insufficient non-paged pool to build cancel-CDRP
;	R1	IRP base address of cancel-CDRP (i.e. R1 + IRP$L_FQFL = 
;		cancel-CDRP base address)
;
;	All other registers are preserved.
;--

DUTU$BUILD_CANIO_CDRP:

	PUSHR	#^M<R2,R3,R4,R5>	; Save registers.
	MOVZBL	#IRP$C_LENGTH, R1	; Get size of an IRP/CDRP.
	JSB	G^EXE$ALONONPAGED	; Allocate an IRP/CDRP.
	BLBC	R0, 900$		; Branch if allocation failed.
	MOVQ	R1, -(SP)		; Save allocation size and address.
	MOVC5	#0, (SP), #0, R1, (R2)	; Zero entire allocated region.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore allocation information
					; and input registers.
	
	MOVW	R0, IRP$W_SIZE(R1)	; Store allocation size.
	ASSUME	IRP$B_RMOD EQ <IRP$B_TYPE + 1>
	MOVZBW	#DYN$C_IRP, -		; Store IRP type and mode.
		IRP$B_TYPE(R1)
	MOVL	PCB$L_PID(R4), -	; Save canceling process' PID.
		IRP$L_PID(R1)
	MOVL	R5, IRP$L_UCB(R1)	; Save UCB of cancel target device.
	MOVW	R2, IRP$W_CHAN(R1)	; Save cancel channel index.

	MOVAB	IRP$L_SNDABTQFL(R1), -	; Initialize the send an ABORT queue.
		IRP$L_SNDABTQFL(R1)
	MOVAB	IRP$L_SNDABTQFL(R1), -
		IRP$L_SNDABTQBL(R1)
	MOVAB	IRP$L_ABTDQFL(R1), -	; Initialize the ABORT sent queue.
		IRP$L_ABTDQFL(R1)
	MOVAB	IRP$L_ABTDQFL(R1), -
		IRP$L_ABTDQBL(R1)

	ASSUME	IRP$B_CD_TYPE EQ IRP$W_CDRPSIZE+2
	ASSUME	IRP$B_FIPL    EQ IRP$W_CDRPSIZE+3
	MOVL	#< <IPL$_SCS@24> -	; Initialize CDRP size, type and fork
		 ! <DYN$C_CDRP@16> -	; IPL fields.
		 ! <CDRP$L_IOQFL&^xFFFF> >, -
		IRP$W_CDRPSIZE(R1)
	MOVL	UCB$L_CDT(R5), -	; Setup CDT address.
		IRP$L_CDT(R1)
	MOVAB	UCB$W_RWAITCNT(R5), -	; Point CDRP to wait counter.
		IRP$L_RWCPTR(R1)
	MOVL	#CDRP$M_CANIO, -	; Mark this as a cancel-CDRP.
		IRP$L_DUTUFLAGS(R1)

	MOVL	UCB$L_CDDB(R5), R0	; Locate the cancel CDDB.
	INSQUE	IRP$L_CANIOQFL(R1), -	; Insert cancel-CDRP onto CDDB
		@CDDB$L_CANCLQBL(R0)	; queue of cancel-CDRPs.

	MOVL	#SS$_NORMAL, R0		; Setup success status.
	RSB				; Return.

900$:	POPR	#^M<R2,R3,R4,R5>	; Error exit -- restore registers.
	RSB				; Return.

	.SBTTL	DUTU$CANCEL_RDTWAIT - Cancel a thread on the RDT wait queue
;++
;
; DUTU$CANCEL_RDTWAIT - Cancel a thread on the RDT wait queue
;
; Functional Description:
;
;	This is the action routine for SCAN_RSPID_WAIT, the SCS service which 
;	scans the RDT wait queue for entries belonging to a given connection.  
;	After determining that a request presented for processing by this 
;	routine meets the cancel criteria, this routine performs those 
;	operations necessary to cancel the request.
;
;	Since a RSPID is a required SCS resource for all MSCP activities, 
;	requests stuck on the RDT wait queue (i.e. requests in a RSPID wait 
;	state), cannot have active MSCP requests outstanding to the server.  
;	Therefore, this routine need only count the need to adjust the wait 
;	count, remove the CDRP from the RDT wait queue, and queue the CDRP 
;	for I/O post processing.
;
; Inputs:
;
;	R1	cancel-CDRP address
;	R5	address of a CDRP belonging to the connection on which the 
;		cancel request was made
;
; Outputs:
;
;	R0, R2, and R5 are destroyed.
;	All other registers are preserved.
;--

DUTU$CANCEL_RDTWAIT:

	MOVL	R5, R2			; Copy waiting CDRP address.
	MOVL	R1, R5			; Copy cancel-CDRP address.

	IFNOCANCEL cdrp=(R2), then=10$	; Branch if CDRP shouldn't be canceled.
	INCW	CDRP$W_DUTUCNTR(R5)	; Account for wait counter bump due
					; to RDT wait state.
	REMQUE	(R2), R0		; Remove CDRP from wait queue and
	POST_CDRP status=SS$_CANCEL	; queue it for I/O post processing.

10$:	RSB				; Return to RDT wait queue scan.

	.SBTTL	DUTU$CANCEL_RDT - Cancel a thread holding a RSPID
;++
;
; DUTU$CANCEL_RDT - Cancel a thread holding a RSPID
;
; Functional Description:
;
;	This is the action routine for SCAN_RDT, the SCS service which 
;	Response-id Descriptor Table (RDT) for entries belonging to a given 
;	connection.  After determining that a request presented for processing 
;	by this routine meets the cancel criteria, this routine performs those 
;	operations necessary to cancel the request.
;
;	Class driver function threads found in the RDT may or may not 
;	currently have MSCP transactions in progress.  Before canceling are 
;	thread found in the RDT, the presence or absence of an active MSCP 
;	transaction must be determined.  This is done by searching the CDDB 
;	queue of threads with active transactions for the CDRP presented for 
;	processing.  
;
;	If the CDRP is not found in the CDDB queue, it does not have an active 
;	MSCP transaction.  Therefore, it can be canceled by counting the need 
;	to adjust the wait count, removing the CDRP from the whatever wait 
;	queue it is on, and queuing the CDRP for I/O post processing.
;
;	If the CDRP is found in the CDDB queue, it does have an active MSCP 
;	transaction and that transaction must eventually have an MSCP ABORT 
;	command issued against it.  This is done by removing the CDRP from the 
;	CDDB queue and queueing it to the send-abort queue linked to the 
;	cancel-CDRP.  Entries are placed in the send-abort queue in request 
;	sequence number order.  This causes the MSCP ABORT requests to be 
;	issued in the same order as the MSCP commands which they abort were 
;	issued.  This is necessary for proper tape class driver operation.
;
; Inputs:
;
;	R1	cancel-CDRP address
;	R5	address of a CDRP belonging to the connection on which the 
;		cancel request was made
;
; Outputs:
;
;	R0, R2, and R5 are destroyed.
;	All other registers are preserved.
;--

DUTU$CANCEL_RDT:

	MOVL	R5, R2			; Copy RDT CDRP address.
	MOVL	R1, R5			; Copy cancel-CDRP address.
	IFNOCANCEL cdrp=(R2), then=90$	; Branch if CDRP shouldn't be canceled.

	MOVL	CDRP$L_UCB(R5), R1	; Get UCB address.
	MOVL	UCB$L_CDDB(R1), R1	; Get CDDB address.
	ASSUME	CDDB$L_CDRPQFL EQ 0
	ASSUME	CDRP$L_FQFL    EQ 0
	MOVL	R1, R0			; Initialize "previous" CDRP address.

10$:	MOVL	CDRP$L_FQFL(R0), R0	; Link to next CDRP.
	CMPL	R0, R1			; Reached end of CDDB queue yet?
	BEQL	50$			; Branch if reached end of queue.
	CMPL	R0, R2			; Found CDRP to be canceled?
	BNEQ	10$			; Branch if CDRP not found.

	; The CDRP to be canceled has an active MSCP transaction.

	REMQUE	(R2), R2		; Remove CDRP from CDDB queue.
	BISL	#CDRP$M_CAND, -		; Flag CDRP as "canceled."
		CDRP$L_DUTUFLAGS(R2)
	MOVL	R5, CDRP$L_CANIOCDRP(R2); Set back pointer to cancel-CDRP.
	MOVAB	CDRP$L_SNDABTQFL(R5), R1; Get header for send-abort queue.
	MOVL	R1, R0			; Initialize "previous" CDRP address.

30$:	MOVL	CDRP$L_FQFL(R0), R0	; Link to next CDRP.
	CMPL	R0, R1			; Reached end of send-abort queue yet?
	BEQL	35$			; Branch if reached end of queue.
	CMPL	CDRP$L_SEQNUM(R2), -	; Is canceled-CDRP seqnum less than
		CDRP$L_SEQNUM(R0)	; current send-abort seqnum?
	BGEQU	30$			; If not, loop until it is.

35$:	INSQUE	(R2), @CDRP$L_FQBL(R0)	; Insert canceled-CDRP before current
					; send-abort queue entry.

	BRB	80$			; Join common exit code.

50$:	; The CDRP to be canceled does not have an active MSCP transaction.

	INCW	CDRP$W_DUTUCNTR(R5)	; Account for wait counter bump due
					; to RDT wait state.
	REMQUE	(R2), R0		; Remove CDRP from wait queue and
	POST_CDRP status=SS$_CANCEL	; queue it for I/O post processing.

80$:	MOVL	R5, R1			; Restore cancel-CDRP address.
90$:	RSB				; Return to RDT scan.

	.SBTTL	DUTU$TEST_CANCEL_DONE - Test for completed cancel operation
;++
;
; DUTU$TEST_CANCEL_DONE - Test for completed cancel operation
;
; Functional Description:
;
;	This routine is called by MSCP end message processing whenever an MSCP 
;	end message is associated with a CDRP which has the CDRP$M_CAND bit 
;	set in CDRP$L_DUTUFLAGS.  The presence of that flag indicates that a 
;	cancel-CDRP is waiting for canceled requests to complete.
;
;	It is assumed that the input CDRP has been removed from whatever queue 
;	it was on when the MSCP message was received.
;
;	This routine determines whether or not all canceled requests for the 
;	cancel-CDRP associated with the input CDRP (which represents one of 
;	those canceled requests) have completed.  If they all have completed, 
;	the cancel operation is ended.  Otherwise, no action is taken.
;
; Inputs:
;
;	R5	CDRP address (for a canceled request)
;
; Outputs:
;
;	All registers are preserved.
;--

DUTU$TEST_CANCEL_DONE::

	MOVQ	R4, -(SP)			; Save some registers.
	MOVL	CDRP$L_CANIOCDRP(R5), R5	; Get cancel-CDRP address.

	MOVAB	CDRP$L_SNDABTQFL(R5), R4	; Get send-abort queue header.
	CMPL	R4, (R4)			; Is send-abort queue empty?
	BNEQ	80$				; Branch if queue not empty.
	MOVAB	CDRP$L_ABTDQFL(R5), R4		; Get abort-sent queue header.
	CMPL	R4, (R4)			; Is abort-sent queue empty.
	BNEQ	80$				; Branch if queue not empty.

	BSBB	DUTU$END_CANCEL			; Cancel operation is finished.

80$:	MOVQ	(SP)+, R4			; Restore saved registers.
	RSB					; Return.

	.SBTTL	DUTU$DISCONNECT_CANCEL - Do disconnect cleanup for cancels
;++
;
; DUTU$DISCONNECT_CANCEL - Do disconnect cleanup for cancel requests
;
; Functional Description:
;
;	This routine is called to perform those cancel functions required 
;	whenever a connection breaks.  For each cancel-CDRP on the CDDB cancel 
;	opeations queue, this routine performs one of two cleanup tasks:
;
;	   o	If the cancel-CDRP has its fork block queued somewhere, it is 
;		simply removed from the CDDB cancel operations queue.  Some 
;		other portion of the broken connection cleanup will discover 
;		the cancel-CDRP in whatever queue its fork block is hung.  The 
;		cancel-CDRP will then be delivered to DUTU$INSERT_RESTRTQ 
;		which will complete the needed cancel cleanup.  This cleanup 
;		is done in this way because this routine cannot know the 
;		proper connection-dependent cleanup required by the 
;		cancel-CDRP as a result of its in progress SCS activities.  
;		N.B. proper operation of this test depends upon SEND_ABORTS 
;		clearing the cancel-CDRP fork block queue links when it is 
;		done sending the needed MSCP ABORT commands.
;
;	    o	If the cancel-CDRP fork block is not queue anywhere, the 
;		cancel-CDRP is dequeued from the CDDB cancel operations queue 
;		and the cancel operation it represents is ended now.  All 
;		CDRPs linked to the cancel-CDRP (awaiting completion of cancel 
;		processing) are immediately queued for I/O post processing.
;
; Inputs:
;
;	R3	CDDB address
;
; Outputs:
;
;	R0 and R5 are destroyed.
;	All other registers are preserved.
;--

DUTU$DISCONNECT_CANCEL::

10$:	REMQUE	@CDDB$L_CANCLQFL(R3), R5	; Get a cancel-CDRP.
	BVS	90$				; Branch if no cancel-CDRPs.

	ASSUME	IRP$L_CANIOQFL EQ IRP$L_IOQFL
	ASSUME	IRP$L_IOQFL EQ 0
	BISL3	IRP$L_FQFL(R5), -		; Is CDRP fork block queue?
		IRP$L_FQBL(R5), R0		; If so, skip further 
	BNEQ	10$				; processing.

	MOVAB	IRP$L_FQFL(R5), R5		; Else, cleanup cancel
	BSBB	DUTU$CLEANUP_CANCEL		; operation.
	BRB	10$				; Loop till no more CDRPs.

90$:	RSB					; Return.

	.SBTTL	DUTU$END_CANCEL - Finish a cancel operation
	.SBTTL	DUTU$CLEANUP_CANCEL - Cleanup a cancel operation
;++
;
; DUTU$END_CANCEL - Finish a cancel operation
; DUTU$CLEANUP_CANCEL - Cleanup a cancel operation
;
; Functional Description:
;
;	These routines are called end an in progress cancel operation.  Both 
;	routines guarantee that all canceled requests not previously posted 
;	for I/O post processing (or otherwise disposed of) are queued for I/O 
;	post processing.  Both routines deallocate the cancel-CDRP.
;
;	DUTU$END_CANCEL removes the cancel-CDRP from the CDDB cancel 
;	operations queue.  DUTU$CLEANUP_CANCEL does not.
;
; Inputs:
;
;	R5	cancel-CDRP address
;
; Implicit Inputs:
;
;	CDRP$L_SNDABTQFL(R5)	send-abort queue header
;	CDRP$L_ABTDQFL(R5)	abort-sent queue header
;	CDRP$L_CANIOQFL(R5)	CDDB cancel operations queue links
;
; Outputs:
;
;	All registers preserved.
;	CDRP pointed to by R5 is deallocated.
;--

DUTU$END_CANCEL:

	REMQUE	CDRP$L_CANIOQFL(R5), -	; Remove cancel-CDRP from CDDB cancel
		-(SP)			; operations queue.
	TSTL	(SP)+			; Cleanup stack.

DUTU$CLEANUP_CANCEL:

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.

	; First drain any CDRP's that didn't even get there ABORT's sent.

20$:	REMQUE	@CDRP$L_SNDABTQFL(R5), R0 ; Get next canceled IRP/CDRP.
	BVS	40$			; Branch if no more IRPs/CDRPs.
	POST_CDRP status=SS$_CANCEL	; Insert packet onto IOPOST queue.
	BRB	20$			; Loop back until empty.

	; Then drain CDRP's which did not terminate after an ABORT.

40$:	REMQUE	@CDRP$L_ABTDQFL(R5), R0	; Get next canceled IRP/CDRP.
	BVS	60$			; Branch if no more IRPs/CDRPs.
	POST_CDRP status=SS$_CANCEL	; Insert packet onto IOPOST queue.
	BRB	40$			; Loop back until empty.

60$:	; Deallocate cancel-CDRP.

	MOVAB	CDRP$L_IOQFL(R5), R0	; Point to IRP portion.
	JSB	G^COM$DRVDEALMEM	; Deallocate IRP.

	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	RSB

	.SBTTL	DUTU$TEST_CANCEL_CDRP - Should a CDRP be canceled
;++
;
; DUTU$TEST_CANCEL_CDRP - Should a CDRP be canceled
;
; Functional Description:
;
;	This routine tests one input CDRP against an input cancel CDRP to 
;	determine whether or not the former should be canceled.  The CDRP 
;	should be canceled if and only if the following fields match in both 
;	CDRPs:
;
;		CDRP$L_PID		requesting process PID
;		CDRP$W_CHAN		requesting process channel
;		CDRP$L_UCB		device UCB address
;
;	NOTE: virtual requests are canceled in the same manner as other 
;	requests.  This differs from the approach used by other disk drivers.
;
; Inputs:
;
;	R2	test CDRP address
;	R5	cancel CDRP address
;
; Outputs:
;
;	R0	success implies test CDRP should be canceled
;		failure implies test CDRP should not be canceled.
;--

DUTU$TEST_CANCEL_CDRP::

	CLRL	R0				; Assume no cancel.
	CMPL	CDRP$L_UCB(R2), CDRP$L_UCB(R5)	; Do devices match?
	BNEQ	90$				; Branch if no match.
	CMPL	CDRP$L_PID(R2), CDRP$L_PID(R5)	; Do PIDs match?
	BNEQ	90$				; Branch if no match.
	CMPW	CDRP$W_CHAN(R2), CDRP$W_CHAN(R5); Do channels match?
	BNEQ	90$				; Branch if no match.
	INCL	R0				; All match, so cancel it.
90$:	RSB

	.SBTTL	----- GENERAL SUPPORT ROUTINES -----
	.SBTTL	DUTU$RESET_MSCP_MSG - Reset MSCP command packet
;++
;
; DUTU$RESET_MSCP_MSG - Reset MSCP command packet
;
; Functional Description:
;
;	This routine causes a previously used MSCP command packet (or end 
;	message) to be completely recycled and readied for use in the sending 
;	of another MSCP command.  It is intended for use by those functions 
;	which require more than one MSCP command to properly complete.  Any 
;	failure of the message buffer operation is taken as an indication of a
;	broken connection and control is transfered to DUTU$KILL_THIS_THREAD.
;
;	This routine is the power behind the RESET_MSCP_MSG macro.
;
; Inputs:
;
;	R3	UCB address
;	R5	CDRP address
;
; Outputs:
;
;	R0 & R1	destroyed
;	R2	reset MSCP command packet address
;	All other registers preserved.
;--

DUTU$RESET_MSCP_MSG::

	POPL	CDRP$L_IOQBL(R5)		; Save caller's return address.
	RECYCL_RSPID				; Recycle the RSPID.
	RECYCL_MSG_BUF				; Recycle the MSCP packet.
	BLBC	R0, 99$				; Branch if connection broken.
	PUSHL	CDRP$L_IOQBL(R5)		; Restore return address.
	BRB	DUTU$INIT_MSCP_MSG_UNIT		; Initialize MSCP packet.

99$:	; RECYCL_MSG_BUF detected a broken connection.  
	; Therefore, kill this execution thread.

	TSTL	(SP)+				; Forget return address.
	BRW	DUTU$KILL_THIS_THREAD		; Then kill this thread.

	.SBTTL	DUTU$INIT_MSCP_MSG_UNIT - Initialize a MSCP message w/ unit number
	.SBTTL	DUTU$INIT_MSCP_MSG - Initialize a MSCP message
;++
;
; DUTU$INIT_MSCP_MSG_UNIT - Initialize a MSCP message w/ unit number
; DUTU$INIT_MSCP_MSG - Initialize a MSCP message
;
; Functional Description:
;
;	These routines initialize an SCS message buffer for use in transmitting 
;	a MSCP command packet.  The primary purpose of this initialization is 
;	to insure that all reserved fields are zero.  In addition, the command 
;	reference number is loaded with the RSPID.  DUTU$INIT_MSCP_MSG_UNIT 
;	also loads the unit number from UCB$W_MSCPUNIT.
;
;	These routines are the power behind the INIT_MSCP_MSG macro.
;
; Inputs:
;
;	R3	a UCB address (DUTU$INIT_MSCP_MSG_UNIT only)
;	R5	a CDRP address
;
; Implicit Inputs:
;
;	CDRP$L_MSG_BUF(R5)	SCS message buffer address
;	CDRP$L_RSPID(R5)	SCS RSPID
;	UCB$W_MSCPUNIT(R3)	unit number (DUTU$INIT_MSCP_MSG_UNIT only)
;
; Outputs:
;
;	R0 & R1	destroyed
;	R2	message buffer address
;	All other registers are preserved.
;
; Implicit Outputs:
;
;	MSCP$K_MXCMDLEN bytes of message buffer are zeroed.
;
;	MSCP$L_CMD_RED(R2)	<== CDRP$L_RSPID(R5)
;
;		(DUTU$INIT_MSCP_MSG_UNIT only)
;	MSCP$W_UNIT(R2)		<== UCB$W_MSCPUNIT(R3)
;
; Special notes:
;
;	These routines are somewhat inefficient and therefore are not suitable 
;	for code paths requiring speedy execution.
;--

	.ENABLE LSB

DUTU$INIT_MSCP_MSG::
	CLRL	R1				; Signal no unit number present.
	BRB	10$				; Join common code.

DUTU$INIT_MSCP_MSG_UNIT::
	MOVZWL	UCB$W_MSCPUNIT(R3), R1		; Get unit number.

10$:	MOVL	CDRP$L_MSG_BUF(R5), R2		; Get message buffer address.

	MOVL	R2, R0				; Copy message buffer address.
	.REPEAT	MSCP$K_MXCMDLEN / 8
	CLRQ	(R0)+				; Zero entire message buffer.
	.ENDR
	.IIF	NE MSCP$K_MXCMDLEN & 4, CLRL (R0)+
	.IIF	NE MSCP$K_MXCMDLEN & 2, CLRW (R0)+
	.IIF	NE MSCP$K_MXCMDLEN & 1, CLRB (R0)+

	MOVL	CDRP$L_RSPID(R5), -		; Setup command reference 
		MSCP$L_CMD_REF(R2)		; number from RSPID.
	
	MOVW	R1, MSCP$W_UNIT(R2)		; Setup unit number or zero.

	RSB					; Return to caller.
	.DISABLE LSB

	.SBTTL	DUTU$SEND_DRIVER_MSG - Send driver internal message to MSCP server
	.SBTTL	DUTU$SEND_MSCP_MSG - Send command message to MSCP server
;++
;
; DUTU$SEND_DRIVER_MSG - Send driver internal message to MSCP server
; DUTU$SEND_MSCP_MSG - Send command message to MSCP server
;
; Functional Description:
;
;	These routines cause the MSCP message packet pointed to by the CDRP 
;	whose address is stored in R5 to be transmitted to the MSCP server 
;	at the other end of the connection whose PDT address is in R4.  For 
;	accounting purposes, the CDRP is queued to the active transfers queue 
;	of the CDDB whose address is in UCB$L_CDDB(R3) [DUTU$SEND_DRIVER_MSG 
;	uses the permanent CDDB associated with the input CDRP].
;
;	Control is returned to the instruction following the call to this 
;	routine when the corresponding MSCP end message has been received.
;
;  Inputs:
;
;	R3 UCB address (DUTU$SEND_MSCP_MSG only)
;	R4 PDT address
;	R5 CDRP address
;	IPL is IPL$_SCS
;
; Outputs:
;
;	R3 - R5 preserved, all other registers destroyed
;	IPL is IPL$_SCS
;--

	.ENABLE LSB

DUTU$SEND_DRIVER_MSG::

	PERMCDRP_TO_CDDB -		; Locate interesting CDDB.
		cdrp=R5, cddb=R1
	BRB	100$			; Join common code.

DUTU$SEND_MSCP_MSG::

	; The same macro which defines inline versions of SEND_MSCP_MSG
	; is used here to produce the body of this routine.

	SEND_MSCP_MSG ROUTINE 100$

	.DISABLE LSB

	.SBTTL	DUTU$INTR_ACTION_XFER - Interpret transfer action table
	.SBTTL	DUTU$INTR_ACTION_N - Interpret non-transfer action table
;++
;
; DUTU$INTR_ACTION_XFER - Interpret transfer action table
; DUTU$INTR_ACTION_N - Interpret non-transfer action table
;
; Functional Description:
;
;	These routines interpret an action table.  Based upon the comparison 
;	of a MSCP$W_STATUS value to entries in the action table, the contents 
;	of R0 (as status code) are set and control is transfered to a 
;	specified location.
;
;	An action table is formed an processed using the following sequence of 
;	macro statements:
;
;		DO_ACTION {TRANSFER | NONTRANSFER}
;		ACTION_ENTRY mscp_code_1,ss_code_1,destination_1
;		ACTION_ENTRY mscp_code_2,ss_code_2,destination_2
;		ACTION_ENTRY mscp_code_3,ss_code_3,destination_3
;		      .		.	     .		 .
;		      .		.	     .		 .
;		      .		.	     .		 .
;		ACTION_ENTRY mscp_code_n,ss_code_n,destination_n
;		ACTION_ENTRY END
;
;	These routines compare the MSCP end-packet status code found at 
;	MSCP$W_STATUS(R2) to each mscp_code_x in the action table.  Whenever a 
;	match is found, ss_code_x is loaded into R0 and control is transfered 
;	to destination_x.  If the DO_ACTION parameter is NONTRANSFER, the 
;	DUTU$INTR_ACTION_N entry point is used and the resulting R0 will have 
;	ss_code_x in the low-order word with the high-order word zero.  If the 
;	DO_ACTION parameter is TRANSFER, the DUTU$INTR_ACTION_XFER entry point 
;	is used and the resulting R0 will have ss_code_x in the high-order 
;	word with the low-order word zero.  This later form is use for 
;	conveniently forming the final IOSB status field for a transfer 
;	command, which is of the form:
;
;		|---------------------+---------------------|
;		|   BCNT (low-order)  !	       status	    |
;		|---------------------+---------------------|
;		|		      !  BCNT (high-order)  |
;		|---------------------+---------------------|
;
;	The byte count, BCNT, to be returned is loaded into R1.  Then a 
;	quadword shift is performed moving status into the low-order R0 and
;	moving BCNT into the position shown above.
;
;	Whenever an input MSCP end-packet status cannot be located in the 
;	action table, control is returned to the first instruction following 
;	the action table and the contents of R0 and R1 are indeteminant.
;
; Inputs:
;
;	R2	MSCP end-packet address
;	(SP)	action table base address
;
; Implicit Inputs:
;
;	MSCP$W_STATUS(R2)	MSCP end-packet status
;
; Outputs:
;
;	R0	SS$_xxx status value from action table; in low-order R0 for 
;		DUTU$INTR_ACTION_N, DO_ACTION NONTRANSFER; in high-order R0 
;		for DUTU$INTR_ACTION_XFER, DO_ACTION TRANSFER
;	R1	Corrupted
;
;	All other registers preserved.
;
; Implicit Outputs:
;
;	None.
;
; Side Effects:
;
;	Control is transfered to the destination specified in the selected 
;	action table entry.
;--

DUTU$INTR_ACTION_XFER::

	MOVB	#16, R1				; Set transfer shift count.
	BRB	INTR_ACTION_COMMON		; Join common code.

DUTU$INTR_ACTION_N::

	CLRB	R1				; Set non-transfer shift count.

INTR_ACTION_COMMON:

	SUBL3	#ATE_ENTRY_LEN, (SP)+, R0	; Get initial action tbl. addr.
	MOVB	R1, -(SP)			; Save shift count.

	ASSUME	MSCP$S_ST_MASK LE 7
	ASSUME	MSCP$V_ST_MASK EQ 0
	BICB3	#^cMSCP$M_ST_MASK, -		; Get MSCP end-packet status
		MSCP$W_STATUS(R2), R1		; value.

10$:	ADDL	#ATE_ENTRY_LEN, R0		; Move to next action entry.
	TSTW	ATE_OFFSET(R0)			; Is this end of action table?
	BEQL	90$				; Branch if end of table.
	CMPB	ATE_MSCPCODE(R0), R1		; Compare MSCP status.
	BNEQ	10$				; Loop if wrong MSCP status.

	CVTWL	ATE_OFFSET(R0), R1		; Get destination displacement
	ASSUME	ATE_OFFSET EQ 0			; from the action table.
	ADDL	R0, R1				; Convert to absolute address.
	MOVZWL	ATE_SSCODE(R0), R0		; Get SS$_xxx code from table.
	ROTL	(SP)+, R0, R0			; Shift it by shift count.
	JMP	(R1)				; Go to specified destination.

90$:	; MSCP status not found in action table.
	CLRB	(SP)+				; Pop shift count from stack.
	JMP	2(R0)				; Continue after end of action 
						; table.

	.SBTTL	DUTU$RESTORE_CREDIT - Restore allocated message credit
;++
;
; DUTU$RESTORE_CREDIT - Restore allocated message credit
;
; Functional Description:
;
;	An SCS message buffer has been allocated, but its use is no longer 
;	needed.  However, the buffer cannot simple be deallocated, because to 
;	do so would result in permanently loosing a send credit to the MSCP 
;	server.  Therefore, a NOP MSCP command must be sent to the MSCP server.
;	This will cause it to restore the allocated (and now used) send 
;	credit.
;
;	To accomplish its goals, this routine plays fast an loose with the 
;	port driver.  A send message request is queued, but before the 
;	response can be received, the RSPID for the request is deallocated.  
;	This is guaranteed by this routine no breaking IPL$_SCS synchronization 
;	from the time the request is queued until the time the RSPID is 
;	deallocated and the CDRP is dequeued from the CDDB active requests 
;	queue (work queue).  Because the RSPID is no longer allocated when the 
;	response message for the NOP command is received, the class driver IDR 
;	routine will discard the response message, which is exactly the 
;	desired effect.
;
; Inputs:
;
;	R3	UCB address
;	R4	PDT address
;	R5	CDRP address
;
; Implicit Inputs:
;
;	CDRP$L_MSG_BUF(R5)	message buffer address
;	CDRP$L_RSPID(R5)	RSPID
;	UCB$W_MSCPUNIT(R3)	unit number
;
; Outputs:
;
;	All registers preserved.
;
; Implicit Outputs:
;
;	CDRP$L_MSG_BUF(R5)	message buffer address - deallocated
;	CDRP$L_RSPID(R5)	RSPID - deallocated
;--

DUTU$RESTORE_CREDIT::

	PUSHR	#^M<R0,R1,R2,R3>		; Save registers.
	MOVQ	R4, -(SP)			; Save PDT and CDRP.
	INIT_MSCP_MSG ucb=(R3)			; Ready packet to send NOP.
	MOVB	#MSCP$K_OP_GTUNT, -		; Use Get Unit Status function
		MSCP$B_OPCODE(R2)		; as NOP.
	PUSHAB	B^10$				; Set inline caller's caller.
	SEND_MSCP_MSG				; Send NOP command.
	RSB					; If ever get here, kill this
						; fork thread.

10$:	; Control is returned synchronously returned here as soon as the NOP 
	; message is sent.  The fork thread is evaporated by deallocating its 
	; RSPID and removing the CDRP from the class driver work queue.
	MOVQ	(SP)+, R4			; Restore PDT and CDRP.
	DEALLOC_RSPID				; Quick, deallocate RSPID.
	REMQUE	(R5), R5			; Remove CDRP from work queue.
	POPR	#^M<R0,R1,R2,R3>		; Restore other registers.
	RSB					; Return to caller.

	.SBTTL	DUTU$INSERT_RESTARTQ - Insert outstanding CDRP in restart queue
;++
;
; DUTU$INSERT_RESTARTQ - Insert outstanding CDRP in restart queue
;
; Functional Description:
;
;	This routine is presented with outstanding I/O requests (represented 
;	by CDRPs) whenever a connection-failure cleanup is required.  For each 
;	request, this routine determines the appropriate cleanup action and 
;	performs that action.  
;
;	In all cases the RSPID and message buffer are deallocated.  N.B. 
;	mapping resources are not deallocated.  This action is postponed until 
;	after the connection is formally broken, to prevent an "insane" server 
;	from incorrectly overwriting memory due to reallocation of mapping 
;	resources.
;
;	The various cleanup processing cases are as follows:
;
;	    1.	Ordinary IRP/CDRP     -	insert the CDRP in the restart queue 
;					in sequence number order.
;
;	    2.	CDDB Permanent 	      -	no action other than deallocating SCS 
;		IRP/CDRP		resources
;
;	    3.	HIRT Permanent	      -	find CDRP which incurrect the 
;		IRP/CDRP		replacement request, process it with a 
;					recursive call to this routine, copy 
;					HIRT permanent IRP/CDRP mapping 
;					resource information to a CDDB 
;					permanent CDRP, and unlock the HIRT.
;
;	    4.	Cancel Operation      -	complete the cancel operation, posting
;		IRP/CDRP		all effected IRP/CDRPs because the
;					connection failure has done what the
;					ABORT command had (so far) failed to do.
;
;	    5.	Mount Verification    -	Same as 1.  However, after the mapping 
;		IRP/CDRP		resources are deallocated, these 
;					IRP/CDRPs will be queued for post 
;					processing with a status SS$_MEDOFL.
;
; Inputs:
;
;	R3	CDDB address
;	R4	PDT address
;	R5	CDRP address
;
; Implicit inputs:
;
;	T.B.S.
;
; Outputs:
;
;	R0 through R2 and R5 are destroyed.
;	All other registers are preserved.
;
; Implicit outputs:
;
;	See functional description.
;--

DUTU$INSERT_RESTARTQ::

	CMPB	#DYN$C_CDRP, -		; Guarantee that a CDRP is being
		CDRP$B_CD_TYPE(R5)	; processed.
	BNEQ	999$			; If not, bug check.

	BSBW	DUTU$DEALLOC_RSPID_MSG	; Always deallocate RSPID & msg. buf.

	BBS	#CDRP$V_PERM, -		; Is this a permanent CDRP?
		CDRP$L_DUTUFLAGS(R5), -	; Branch if permanent CDRP.
		200$
	BBS	#CDRP$V_HIRT, -		; Is this a HIRT permanent CDRP?
		CDRP$L_DUTUFLAGS(R5), -	; Branch if HIRT permanent CDRP.
		300$
	BBS	#CDRP$V_CANIO, -	; Is this a CancelIO CDRP?
		CDRP$L_DUTUFLAGS(R5), -	; Branch if CancelIO CDRP.
		400$

	MOVAB	CDDB$L_RSTRTQFL(R3), R0	; Get restart queue list head.
	MOVL	R0, R1			; Copy that address.

10$:	MOVL	(R1), R1		; Get next restart CDRP.
	CMPL	R1, R0			; Returned to the listhead yet?
	BEQL	40$			; Branch if returned to listhead.
	CMPL	CDRP$L_SEQNUM(R5), -	; Is seqnum of CDRP of interest less
		CDRP$L_SEQNUM(R1)	; than seqnum of current list entry?
	BGEQU	10$			; If not, go back to try next list
					; entry.  Else fall thru and insert
					; CDRP of interest before the
					; current entry.
40$:	INSQUE	(R5),@CDRP$L_FQBL(R1)	; Insert before current entry.

200$:	RSB				; Return to caller.

300$:	.WEAK	DU$RSTRTQ_HIRT_CDRP	; This is not present in tape class 
					; drivers.
	BRW	DU$RSTRTQ_HIRT_CDRP	; Process HIRT permanent CDRP and
					; return to caller.

400$:	BRW	DUTU$CLEANUP_CANCEL	; For CancelIO, cleanup cancel and
					; return to caller.

999$:	BUG_CHECK MSCPCLASS, FATAL	; Attempt to insert non-CDRP in the
					; CDDB restart queue.

	.SBTTL	DUTU$RECONN_LOOKUP - Reconnection SCS Lookup Action Routine
;++
;
; DUTU$RECONN_LOOKUP - Reconnection SCS Lookup Action Routine
;
; Functional Description:
;
;	During broken connection cleanup, this is the SCS action routine for 
;	both SCAN_RSPID_WAIT and SCAN_RDT.  SCAN_RSPID_WAIT is the SCS service 
;	which scans the RDT wait queue for entries belonging to a given 
;	connection.  SCAN_RDT is the SCS service which scans the Response-id 
;	Descriptor Table (RDT) for entries belonging to a given connection.  
;	For connection cleanup, the operations performed in both cases are 
;	very similar.  For those cases where, some cleanup operation is not 
;	appropriate for one or the other situtation, which type of scan is in 
;	progress is determined from R1 (as setup by the caller of the scan SCS 
;	service).
;
;	CDRPs which have already been canceled are ignored by this routine.  
;	They will be properly processed when the request which canceled them 
;	is cleaned up.  In all other cases, the CDRP is removed from whatever 
;	wait queue it is on.  All CDRPs presented to this routine are assumed 
;	to be waiting for resources.  For connection permanent CDRPs, no other 
;	processing is required.  In particular, connection permanent CDRPs are 
;	never placed on the restart queue.  This is inappropriate because the 
;	need for whatever function the connection permanent CDRP was performing 
;	disappeared with the broken connection.  Also, since all connection 
;	permanent CDRPs are easily located, they need not be queued anywhere 
;	to allow easy location when the time comes to release their resources. 
;	Connection permanent CDRPs never point to a wait reasons counter, so 
;	that processing is not necessary either.
;
;	All other CDRPs are tested for a wait reasons counter pointer.  If one 
;	is present, the wait reasons counter is decremented.  CDRPs on the 
;	RSPID-wait queue, are obviously waiting for resources.  Otherwise, the 
;	fact that all possibly active requests have been cleaned up before 
;	this routine is called guarantees that CDRPs presented to this routine 
;	are waiting for resources.  Note: this routine helps perpetuate that 
;	guarantee by exiting via DUTU$DRAIN_CDDB_CDRPQ, which cleans up all 
;	active requests.  Therefore, the cleanup of the CDRP presented to this 
;	routine will reduce the number for reasons activity is waiting and the 
;	wait reasons counter should be (and is) reduced to reflect this.
;
;	If appropriate, the CDRP is inserted into the restart queue.  Finally, 
;	DUTU$DRAIN_CDDB_CDRPQ is called to cleanup and requests made active by 
;	the resources released during the cleanup of this CDRP.
;
; Inputs:
;
;	R1	LBC ==> SCAN_RSPID_WAIT
;		LBS ==> SCAN_RDT
;	R3	CDT address
;	R4	PDT address
;	R5	CDRP address
;
; Implicit Inputs:
;
;	CDT$L_AUXSTRUC(R3)	CDDB address
;
; Outputs:
;
;	R0, R2, and R5 are destroyed.
;	All other registers are preserved.
;
; Side Effects:
;
;	The CDRP presented to this routine is readied for retry (or reuse)
;	after the a new connection to the remote MSCP server is formed.
;--

DUTU$RECONN_LOOKUP::

	ASSUME	CDRP$V_CAND EQ 0		; Branch if this is a
	BLBS	CDRP$L_DUTUFLAGS(R5), 50$	; canceled CDRP.
	REMQUE	(R5), R5			; Remove CDRP from queue.
	BBS	#CDRP$V_PERM, -			; Branch if this is a
		CDRP$L_DUTUFLAGS(R5), 50$	; permanent CDRP.
	MOVL	CDRP$L_RWCPTR(R5), R0		; Get wait counter pointer.
	BEQL	10$				; Branch if no pointer present.
	DECL	(R0)				; Else, decrement wait counter.
10$:	PUSHR	#^M<R1,R3>			; Save registers.
	MOVL	CDT$L_AUXSTRUC(R3), R3		; Get CDDB address.
	BSBB	DUTU$INSERT_RESTARTQ		; Setup CDRP restart.
	POPR	#^M<R1,R3>			; Restore registers.
50$:	BLBC	R1, RECONN_EXIT			; If SCAN_RSPID_WAIT, exit now.
;------	BRB	DUTU$DRAIN_CDDB_CDRPQ		; Else, empty active CDRPs queue
						; and return to caller.

	.SBTTL	DUTU$DRAIN_CDDB_CDRPQ - Drain Active CDRPs Queue
;++
;
; DUTU$DRAIN_CDDB_CDRPQ - Drain Active CDRPs Queue
;
; Functional Description:
;
;	All CDRPs found on the active CDRPs queue, CDDB$L_CDRPQFL, are 
;	processed and placed on the restart queue, CDDB$L_RSTRTQFL, as 
;	appropriate.
;
; Inputs:
;
;	R3	CDT address
;
; Implicit Inputs:
;
;	CDT$L_AUXSTRUC(R3)	CDDB address
;
; Outputs:
;
;	All registers preserved.
;
; Side Effects:
;
;	Any CDRP found on the active queue is processed by DUTU$INSERT_RESTARTQ.
;--

DUTU$DRAIN_CDDB_CDRPQ::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save registers.
	MOVL	CDT$L_AUXSTRUC(R3), R3		; Get CDDB address.

10$:	REMQUE	@CDDB$L_CDRPQFL(R3), R5		; Get an active CDRP.
	BVS	20$				; Branch if no active CDRPs.
	BSBB	DUTU$INSERT_RESTARTQ		; Insert active CDRP in the
	BRB	10$				; restart queue and loop.

20$:	POPR	#^M<R0,R1,R2,R3,R4,R5>		; Restore registers.

RECONN_EXIT:
	RSB					; Return.

	.SBTTL	DUTU$TERMINATE_PENDING - Fail pending requests with SS$_VOLINV
;++
;
; DUTU$TERMINATE_PENDING - Fail pending requests with SS$_VOLINV
;
; Functional Description:
;
;	This routine locates at queues for I/O post processing all I/O 
;	pending requests on the input UCB.  All requests are completed 
;	with a SS$_VOLINV, "volume is not software enabled" status.
;
;	The active requests queue is not scanned by this routine.  Either 
;	there should be not requests in this queue (i.e. there is no good 
;	connection for the requests to be processed on), or the active 
;	requests will eventually be finished, successfully or otherwise by the 
;	MSCP server.
;
; Inputs:
;
;	R5	UCB address
;
; Implicit inputs:
;
;	UCB$L_CDDB(R5)		CDDB address
;	UCB$L_IOQFL(R5)		header for pending I/O request queue
;	CDDB$L_RSTRTQFL(cddb)	header for queue of I/O requests awaiting
;				SCS connection reestablishment
;
; Outputs:
;
;	R0 through R2 are destroyed.
;	All other registers are preserved.
;
; Implicit outputs:
;
;	None.
;--

DUTU$TERMINATE_PENDING::

	ADDL3	#CDDB$L_RSTRTQFL, -		; Get address of restart Qhead.
		UCB$L_CDDB(R5), R1
	ASSUME	CDRP$L_FQFL EQ 0
	MOVL	R1, R0				; Init "previous" CDRP pointer.

10$:	MOVL	CDRP$L_FQFL(R0), R0		; Link to next CDRP.
11$:	CMPL	R0, R1				; All restart CDRPs tested?
	BEQL	50$				; Branch if all CDRPs done.
	CMPL	CDRP$L_UCB(R0), R5		; Is this CDRP for right UCB?
	BNEQ	10$				; Branch if not right UCB.
	PUSHL	CDRP$L_FQFL(R0)			; Right UCB, save next CDRP 
	REMQUE	(R0), R0			; address and dequeue this CDRP.
	POST_CDRP status=SS$_VOLINV		; Then, post this CDRP.
	POPL	R0				; Restore next CDRP address.
	BRB	11$				; Loop till no more CDRPs.

50$:	REMQUE	@UCB$L_IOQFL(R5), R0		; Get next pending IRP.
	BVS	80$				; Branch if no more IRPs.
	POST_IRP status=SS$_VOLINV		; Post IRP.
	BRB	50$				; Loop till no more IRPs.

80$:	RSB					; Return.

	.SBTTL	DUTU$DEALLOC_ALL - Deallocate all SCS resources
	.SBTTL	DUTU$DEALLOC_RSPID_MSG - Deallocate SCS RSPID and msg. buf.
;++
;
; DUTU$DEALLOC_ALL - Deallocate all SCS resources
; DUTU$DEALLOC_RSPID_MSG - Deallocate SCS RSPID and message buffer
;
; Functional Description:
;
;	These routines deallocate various combinations of SCS resources.
;
;	These routines are the power behind the DEALLOCATE macro.
;
; Inputs:
;
;	R4	PDT address
;	R5	CDRP address
;
; Outputs:
;
;	R0 - R2 are destroyed.
;	All other registers are preserved.
;--

DUTU$DEALLOC_ALL::

	TSTL	CDRP$L_LBUFH_AD(R5)		; Are map resources allocated?
	BEQL	10$				; Branch if not allocated.
	UNMAP					; Else, deallocate them.
	CLRL	CDRP$L_LBUFH_AD(R5)		; Signal no map stuff allocated.
10$:

DUTU$DEALLOC_RSPID_MSG::

	TSTL	CDRP$L_MSG_BUF(R5)		; Is msg. buffer allocated?
	BEQL	20$				; Branch if not allocated.
	DEALLOC_MSG_BUF				; Else, deallocate it.
20$:

	TSTL	CDRP$L_RSPID(R5)		; Is RSPID allocated?
	BEQL	30$				; Branch if not allocated.
	DEALLOC_RSPID				; Else, deallocate it.
30$:

	RSB					; Return.

	.SBTTL	DUTU$POST_CDRP - Queue CDRP for post processing
;++
;
; DUTU$POST_CDRP - Queue CDRP for post processing
;
; Functional Description:
;
;	The input CDRP is queued to I/O post processing with the input final 
;	I/O status.  All SCS resources held by the CDRP are appropriately 
;	released.
;
; Inputs:
;
;	R0	CDRP address
;	R1	final I/O status
;
; Outputs:
;
;	R0 & R1 are destroyed.
;	all other registers are preserved.
;--

DUTU$POST_CDRP::

	CMPB	#DYN$C_CDRP, -			; Guarantee that a CDRP is being
		CDRP$B_CD_TYPE(R0)		; processed.
	BNEQ	999$				; If not, bug check.

	PUSHR	#^M<R2,R3,R4,R5>		; Save registers.
	MOVL	R0, R5				; Move CDRP address.
	MOVL	CDRP$L_UCB(R5), R0		; Get UCB address.
	MOVL	UCB$L_PDT(R0), R4		; Get PDT address.

	MOVL	R1, CDRP$L_IOST1(R5)		; Set final I/O status.
	CLRL	CDRP$L_IOST2(R5)		; Clear second status longword.

	TSTL	CDRP$L_MSG_BUF(R5)		; Is message buf. allocated?
	BEQL	10$				; Branch if not allocated.
	BSBW	DUTU$RESTORE_CREDIT		; Else, restore send credit.

10$:	BSBB	DUTU$DEALLOC_ALL		; Insure that all SCS 
						; resources are deallocated.

	MOVL	CDRP$L_UCB(R5), R3		; Get UCB address.
	CMPZV	#IO$V_FCODE, #IO$S_FCODE, -	; Branch if this was not a
		CDRP$W_FUNC(R5), #IO$_PACKACK	; PACKACK function.
	BNEQ	14$
	BBCC	#UCB$V_MSCP_PKACK, -		; Clear packack flag and
		UCB$W_DEVSTS(R3), 14$		; branch if it was clear.
	DECW	UCB$W_RWAITCNT(R3)		; Else, decrement wait count.

14$:	CMPZV	#IO$V_FCODE, #IO$S_FCODE, -	; Branch if this was not a
		CDRP$W_FUNC(R5), #IO$_SETCHAR	; SETCHAR function.
	BNEQ	17$
	CMPZV	#IO$V_FCODE, #IO$S_FCODE, -	; Branch if this was not a
		CDRP$W_FUNC(R5), #IO$_SETMODE	; SETMODE function.
	BNEQ	17$
	BBCC	#UCB$V_TU_SEQNOP, -		; Clear seq. NOP flag and
		UCB$W_DEVSTS(R3), 17$		; branch if it was clear.
	DECW	UCB$W_RWAITCNT(R3)		; Else, decrement wait count.

17$:	PUSHL	R5				; Save CDRP address.
	MOVL	R3, R5				; Copy UCB address.
	JSB	G^SCS$UNSTALLUCB		; Possibly unstall the UCB.
	POPL	R5				; Restore CDRP address.

	BBC	#IRP$V_BUFIO, -			; Is this a direct I/O request?
		CDRP$W_STS(R5), 20$		; Branch if direct I/O.
	BICW	#IRP$M_FUNC, CDRP$W_STS(R5)	; Else, clear buffered read bit.

20$:	MOVAB	G^IOC$GL_PSBL, R0		; Get I/O post queue tail ptr.
	INSQUE	CDRP$L_IOQFL(R5), @(R0)		; Insert CDRP on post queue.
	SOFTINT	#IPL$_IOPOST			; Request post processing serv.

	POPR	#^M<R2,R3,R4,R5>		; Restore registers.
	RSB					; Return.

999$:	BUG_CHECK MSCPCLASS, FATAL		; Attempt to insert non-CDRP in
						; the I/O post processing queue.

	.SBTTL	DUTU$KILL_THIS_THREAD - Fix thread caught by async. conn. failure
;++
;
; DUTU$KILL_THIS_THREAD - Fix thread caught by asynchronous connection failure
;
; Functional Description:
;
;	This is an internal routine that is either jumped (BRW) to or called 
;	(BSBW).
;
;	It is jumped to by a thread that has suffered an allocation failure 
;	indicating that its CONNECTION has failed.  This should only happen 
;	when the CONNECTION fails asynchronously with respect to the class 
;	driver and the cause of the CONNECTION failure (e.g. power failure) 
;	interrupts this very driver thread in mid execution.
;
;	This code is called when the class driver determines that the 
;	intelligent controller is acting in an "insane" manner and that the 
;	class driver therefore should bring down the CONNECTION and 
;	re-synchronize (i.e. re-CONNECT) with the controller.
;
;	In either case, the CDRP is placed at the tail of the connection 
;	outstanding requests queue, CDDB$L_CDRPQBL.  This queue holds all 
;	those CDRP's with outstanding requests in the controller plus those 
;	CDRP's of "killed" driver threads.  What all these CDRP's have in 
;	common is that they are NOT on any resource wait queues.  After 
;	queueing the CDRP, this routine does an RSB which returns to either to 
;	caller's caller if entry was made via a BRW or to caller if entry was 
;	made via a BSBW.
;
; Inputs:
;
;	R3	UCB address
;	R5	CDRP address
;
; Implicit Inputs:
;
;	UCB$L_CDDB(R3)		CDDB address
;	CDDB$L_CDRPQBL(cddb)	outstanding request queue backlink
;
; Outputs:
;
;	R1 is destroyed.
;	All other registers are preserved.
;--

DUTU$KILL_THIS_THREAD::

	MOVL	UCB$L_CDDB(R3), R1		; Get CDDB address
	INSQUE	(R5), @CDDB$L_CDRPQBL(R1)	; Insert CDRP onto tail of queue
						; of CDRP's sent to the port.
	RSB					; Return to caller or 
						; caller's caller.

	.SBTTL	DUTU$CHECK_RWAITCNT - Validate UCB$W_RWAITCNT
;++
;
; DUTU$CHECK_RWAITCNT - Validate UCB$W_RWAITCNT
;
; Functional Description:
;
;	This routine compares UCB$W_RWAITCNT against a computed value based 
;	upon information available as to the reasons that RWAITCNT might be 
;	bumped.  If the two values compare, control is returned to the caller.
;	If they do not compare, an INCONSTATE bug check is generated.
;
;	This routine does not test for SCS wait states as possible 
;	incrementers of UCB$W_RWAITCNT.  Therefore, it MUST NOT be called when 
;	a possibility exists for a thread to be in an SCS wait state.
;
; Inputs:
;
;	R5	UCB address
;
; Outputs:
;
;	All registers preserved.
;--

DUTU$CHECK_RWAITCNT::

	MOVQ	R0, -(SP)			; Save corrupted registers.
	CLRL	R0				; Init accumulator.

	BBC	#UCB$V_MSCP_WAITBMP, -		; Check for wait count 
		UCB$W_DEVSTS(R5), 10$		; explicitly bumped.
	INCL	R0				; If so, bump accumulator.

10$:	BBC	#UCB$V_MSCP_MNTVERIP, -		; Check for wait count bumped
		UCB$W_DEVSTS(R5), 12$		; by mount verification.
	INCL	R0				; If so, bump accumulator.

12$:	BBC	#UCB$V_MSCP_PKACK, -		; Check for wait count bumped
		UCB$W_DEVSTS(R5), 20$		; by packack in progress.
	INCL	R0				; If so, bump accumulator.

20$:	.WEAK	DU$TEST_HIRT_RWAITCNT
	MOVAB	G^DU$TEST_HIRT_RWAITCNT, R1	; Get routine address for HIRT
	BEQL	30$				; check and branch if none.
	JSB	(R1)				; Else, perform HIRT check.

30$:	CMPB	#DC$_TAPE, UCB$B_DEVCLASS(R5)	; Is this a tape?
	BNEQ	40$				; Branch if not a tape.
	BBC	#UCB$V_TU_SEQNOP, -		; Is a sequential NOP in 
		UCB$W_DEVSTS(R5), 40$		; progress:  branch if no.
	INCL	R0				; Else, bump accumulator.

40$:	CMPW	R0, UCB$W_RWAITCNT(R5)		; Check for correct RWAITCNT.
	BNEQ	99$				; Branch if no match.

	MOVQ	(SP)+, R0			; Restore registers.
	RSB					; Return.

99$:	BUG_CHECK MSCPCLASS, FATAL		; RWAITCNT test failed.

	.SBTTL	DUTU$LOG_IVCMD - Error log an invalid MSCP command
;++
;
; DUTU$LOG_IVCMD - Error log an invalid MSCP command
;
; Functional Description:
;
;	Called via the IVCMD_BEGIN macro in response to receipt of an "invalid 
;	command" MSCP end-packet status, this routine produces an error log 
;	entry containing both the entire MSCP end-packet and the MSCP command 
;	which produced that end-packet.  
;
;	Saving every command packet sent out for possible insertion in the 
;	error log in the unlikely event of an "invalid command" error is 
;	highly inefficient.  Therefore, in the rare cases where an "invalid 
;	command" error is reported, the class driver must "retrace its steps" 
;	to produce a replicate of the MSCP command which caused the error.
;	This is accomplished by producing a co-routine execution thread in 
;	which the class driver executes most (if not all) the same instructions 
;	it executed to build the original MSCP command packet.  The only 
;	instructions which cannot be executed in this co-routine thread are 
;	those instructions which might attempt to suspend the fork execution 
;	thread (e.g. allocating mapping resources).  The invalid command 
;	co-routine thread cannot break IPL synchronization.  Then, just before 
;	the duplicate command packet would be sent to the MSCP server, control 
;	is returned to this routine, which places the information in the error 
;	log.
;
;	Three macros are provided for class drivers to use in handling 
;	"invalid command" errors:
;
;	IVCMD_BEGIN	begin processing an invalid command and start the 
;			the co-routine thread
;
;	IF_IVCMD	branch if within an invalid command co-routine thread
;
;	IVCMD_END	end an invalid command co-routine thread, make the 
;			error log entry, and return to normal processing
;	
;	For a class driver, the invalid command processing style might look 
;	something like this:
;
;	START_func:
;		; Setup packet for command func.
;		IF_IVCMD then=func_IVCMD_END
;		SEND_MSCP_MSG
;		DO_ACTION	xxxxx
;		   .
;		ACTION_ENTRY	ICMD, SS$_CNTRLERR, func_IVCMD
;		   .
;		ACTION_ENTRY	END_TABLE
;		   .
;	func_IVCMD:
;		IVCMD_BEGIN
;		BRB	START_func
;	func_IVCMD_END:
;		IVCMD_END
;		BRW	FUNCTION_EXIT
;
;	Note:  all invalid command processing occurs out-of-line with respect 
;	to the main execution thread.  Invalid command processing is not the 
;	normal case and rightfully should be processed outside the mainline 
;	code path.  IF_IVCMD contains a single, highly-optimized instruction.
;
;	Somtimes it will be necessary to repeat the start I/O dispatch off of 
;	IRP$W_FUNC in order to put the correct MSCP opcode and modifiers into
;	the duplicate MSCP packet.  For this purpose, both class drivers 
;	define a label of the form xx_BEGIN_IVCMD (where xx is either DU or TU, 
;	as appropriate).  This label has the implicit guarantee that nowhere 
;	between it and the beginning of the function specific start I/O 
;	routine are there any instructions which cannot be executed in an 
;	"invalid command" co-routine thread.
;
; Discription of Macros:
;
; IVCMD_BEGIN
;
; Parameters: None.
;
; Inputs:
;
;	R0	SS$_ status code for the IOSB after the error is logged
;	R1	scratch
;	R2	MSCP end-packet address
;	R3	UCB address
;	R4	PDT address
;	R5	CDRP address
;
; Outputs (beginning of the co-routine thread):
;
;	R0	scratch
;	R1	scratch
;	R2	Duplicate MSCP command packet address (for forming the MSCP 
;		command which caused the error)
;	R3	UCB address (same as input to IVCMD_BEGIN)
;	R4	PDT address (same as input to IVCMD_BEGIN)
;	R5	CDRP address (same as input to IVCMD_BEGIN)
;
; IF_IVCMD
;
; Parameters:
;
;	then	label to receive control when execution is within an invalid 
;		command co-routine thread
;
; Inputs:
;
;	R5	CDRP address (same as input/output to IVCMD_BEGIN)
;
; Outputs: None.
;
; IVCMD_END
;
; Parameters: None.
;
; Inputs:
;
;	R0	scratch
;	R1	scratch
;	R2	Duplicate MSCP command pkt. address (as output from IVCMD_BEGIN)
;	R3	UCB address (same as input/output to IVCMD_BEGIN)
;	R4	PDT address (same as input/output to IVCMD_BEGIN)
;	R5	CDRP address (same as input/output to IVCMD_BEGIN)
;
; Outputs:
;
;	R0	SS$_ status code for the IOSB (same as input to IVCMD_BEGIN)
;	R1	LBC ==> CDRP$V_ERLIP clear when IVCMD_BEGIN called
;		LBS ==> CDRP$V_ERLIP set when IVCMD_BEGIN called
;	R2	MSCP end-packet address (same as input to IVCMD_BEGIN)
;	R3	UCB address (same as input to IVCMD_BEGIN)
;	R4	PDT address (same as input to IVCMD_BEGIN)
;	R5	CDRP address (same as input to IVCMD_BEGIN)
;
; Implicit Outputs:
;
;	CDRP$L_DUTUFLAGS(R5)	CDRP$V_ERLIP set
;
; Side Effects:
;
;	While the invalid command co-routine thread is executing, a relatively 
;	complex stack structure exists below the stack section used within the 
;	co-routine thread itself.  As much as anything else, this complex 
;	stack structure prohibits the co-routine thread from being fork-
;	suspended or from breaking IPL synchronization.  Generally speaking, 
;	the stack structure looks like this:
;
;	|---------------------------------------------------------------|
;	|								|
;	\    stack space for use by invalid command co-routine thread	\
;	|								|
;	|---------------------------------------------------------------|
;	|		return address used by IVCMD_END		| :(SP)
;	|---------------------------------------------------------------|
;	|  zero (used to determine that control was correctly returned) |
;	|---------------------------------------------------------------|
;	|								| :(R7)`
;	\		invalid command MSCP end packet			\
;	|								|
;	|---------------------------------------------------------------|
;	|								| :(R2)
;	\	      invalid command MSCP command packet		\
;	|								|
;	|---------------------------------------------------------------|
;	|								|
;	\	    other stacklocals used by DUTU$LOG_IVCMD		\
;	|								|
;	|---------------------------------------------------------------|
;	|	       saved SS$_ status value (saved R0)		|
;	|---------------------------------------------------------------|
;	|     saved CDRP$V_ERLIP value in low bit (returned in R1)	|
;	|---------------------------------------------------------------|
;	|	    saved MSCP end-packet address (saved R2)		|
;	|---------------------------------------------------------------|
;	|		  saved UCB address (saved R3)			|
;	|---------------------------------------------------------------|
;	|		  saved PDT address (saved R4)			|
;	|---------------------------------------------------------------|
;	|		  saved CDRP address (saved R5)			|
;	|---------------------------------------------------------------|
;	|			   saved R7				|
;	|---------------------------------------------------------------|
;	|   saved return address from IVCMD_BEGIN and later IVCMD_END	|
;	|---------------------------------------------------------------|
;	   ' R7 is not an explicit input/output for any of the invalid
;	     command processing logic.  It is mentioned here simply as
;	     a point of information.
;--

	; Define the stack offsets for which R7 will act as base.
	;
	; N.B. these offsets assume the following initialization sequence:
	;
	; entry:
	;
	;	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R7>
	;	MOVAB	-IVCMD_WORK(SP), SP
	;	MOVL	SP, R7
	;

	IVCMD_ENDSIZ = MSCP$K_MXCMDLEN + 12

	$OFFSET	0, POSITIVE, <-			; Define R7 based offsets:
		<IVCMD_ENDMSG, IVCMD_ENDSIZ>, -		; End message buffer
		<IVCMD_ORGMSG, MSCP$K_MXCMDLEN>, -	; Original message buf.
		<IVCMD_MSGLEN, 0>, -		; Size of both message buffers.
		<IVCMD_ALIGN, <<<IVCMD_MSGLEN+3>&^c3>-IVCMD_MSGLEN>>, -
		-
		- ; Add local working storage after this line.
		-
		<IVCMD_WORK, 0>, -		; Total stacklocal size.
		-				; Saved registers etc.:
		<SVSTATUS>, -			; R0, SS$_ status code
		<SVERLIP>, -			; R1, saved ERLIP flag
		<MSCP_BUF>, -			; R2, MSCP message buffer.
		<SVUCB>, -			; R3, UCB address.
		<SVPDT>, -			; R4, PDT address.
		<SVCDRP>, -			; R5, CDRP address.
		<SVR7>, -			; R7, who knows or cares.
		<SVRET> -			; Return address.
		>

DUTU$LOG_IVCMD::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R7>	; Save registers.
	MOVAB	-IVCMD_WORK(SP), SP		; Make stacklocal space.
	MOVL	SP, R7				; Setup stacklocal pointer.

	MOVC3	#IVCMD_ENDSIZ, (R2), -		; Copy the MSCP end-packet to
		IVCMD_ENDMSG(R7)		; the error log work area.
	ASSUME	SVCDRP EQ <SVPDT + 4>
	MOVQ	SVPDT(R7), R4			; Restore PDT and CDRP addrs.
	MOVL	SVUCB(R7), R3			; Restore UCB address.

	EXTZV	#CDRP$V_ERLIP, #1, -		; Save the ERLIP bit.
		CDRP$L_DUTUFLAGS(R5), SVERLIP(R7)
	MOVAB	IVCMD_ORGMSG(R7), -		; Initialize the duplicate
		CDRP$L_MSG_BUF(R5)		; MSCP command pkt. address.
	INIT_MSCP_MSG ucb=(R3)			; Initialize the pkt. itself.
						; R2 now has dup. pkt. addr.
	MOVL	MSCP_BUF(R7), -			; Restore correct MSCP end
		CDRP$L_MSG_BUF(R5)		; packet address in CDRP.
	ASSUME	CDRP$V_IVCMD EQ 8
	BISB	#<CDRP$M_IVCMD @ -8>, -		; Signal that an invalid 
		CDRP$L_DUTUFLAGS+1(R5)		; command co-routine is active.

	; The JSB which follows initiates the co-routine thread.
	; IVCMD_END will return control to the instruction following the JSB.
	; The zero longword pushed onto the stack is used below to determine 
	; whether control was returned via IVCMD_END or a RSB.

	CLRL	-(SP)				; Push signal longword.
	JSB	@SVRET(R7)			; Begin co-routine thread.

	; The following test attempts to insure that the co-routine thread 
	; started by the JSB above has properly returned here via IVCMD_END.  
	; With luck, this test allows timely detection of a bug in the class 
	; driver, so that we can drop our cookies on the floor neatly.

	POPL	R0				; Get final return address.
	BEQL	999$				; Branch if signal lw. poped.
	MOVL	R0, SVRET(R7)			; Save final return address.
	ASSUME	CDRP$V_IVCMD EQ 8
	BICB	#<CDRP$M_IVCMD @ -8>, -		; Clear the invalid command
		CDRP$L_DUTUFLAGS+1(R5)		; co-routine is active flag.

	; Make invalid command error log entry.

	MOVZBL	#EMB$C_IVCMD, R0		; Signal type of logged message.
	MOVZBL	#IVCMD_MSGLEN, R1		; Pass message length.
	MOVAB	IVCMD_ENDMSG(R7), R2		; Pass message base address.
	JSB	G^ERL$LOGMESSAGE		; Call to error log message.

	MOVAB	IVCMD_WORK+4(SP), SP		; Pop stacklocal zero longword.
	POPR	#^M<R0,R1,R2,R3,R4,R5,R7>	; Restore registers & outputs.
	RSB					; Return.

999$:	BUG_CHECK MSCPCLASS, FATAL		; Control was not returned 
						; from the invalid_command
						; co-routine via a IVCMD_END.

	.SBTTL	DUTU$DODAP - Do Determine Access Paths Processing
;++
;
; DUTU$DODAP - Do Determine Access Paths Processing
;
; Functional Description:
;
;	This routine supervises the sending of Determine Access Path (DAP) 
;	commands for the purpose of discovering the current topology of the 
;	MSCP units (either disks or tapes) accesible to this processor.  These 
;	commands make us aware of alternate (not currently accessible) paths 
;	to mounted units.
;
; Inputs:
;
;	R1	CDDB address
;
; Outputs:
;
;	Registers R0 through R5 are modified.
;--

; Number of passes through DODAP before each DAP processing thread is started.

DAP_COUNT = 10

DUTU$DODAP::

	BBSS	#CDDB$V_DAPBSY, -		; Branch if DAP CDRP is in
		CDDB$W_STATUS(R1), 90$		; use and set in use flag.
	DECB	CDDB$B_DAPCOUNT(R1)		; Count number of passes through
	BGEQ	80$				; here before going again.	
	MOVB	#DAP_COUNT, -			; Refresh passes counter.
		CDDB$B_DAPCOUNT(R1)

	MOVL	CDDB$L_DAPCDRP(R1), R5		; Get DAP CDRP address.
	MOVL	CDDB$L_PDT(R1), R4		; Get PDT address.
	MOVAB	<CDDB$L_UCBCHAIN -		; Setup "previous" UCB address 
		-UCB$L_CDDB_LINK>(R1), R3	; in R3.
	ALLOC_RSPID				; Allocate a RSPID.

10$:	MOVL	UCB$L_CDDB_LINK(R3), R3		; Link to next UCB.
	BEQL	50$				; Branch if no more UCBs.
	BBC	#UCB$V_VALID, -			; If this UCB is not VALID (or
		UCB$L_STS(R3), 10$		; MSCP online), then skip it.
	MOVL	R3, CDRP$L_UCB(R5)		; Put UCB in DAP CDRP.
	ALLOC_MSG_BUF				; Allocate a message buffer.
	BLBC	R0, 50$				; Branch if connection failure.
	INIT_MSCP_MSG ucb=(R3)			; Initialize MSCP packet.
	MOVB	#MSCP$K_OP_DTACP, -		; Set DAP opcode.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG				; Send message to MSCP server.
	DEALLOC_MSG_BUF				; Deallocate response message.
	RECYCL_RSPID				; Recycle RSPID for reuse.
	BRB	10$				; Loop through all UCBs.

50$:	DEALLOC_RSPID				; Deallocate DAP RSPID.
	PERMCDRP_TO_CDDB cdrp=R5, cddb=R1	; Get CDDB address.
80$:	ASSUME	CDDB$V_DAPBSY GE 8
	BICB	#<CDDB$M_DAPBSY @ -8>, -	; Clear DAP CDRP in use flag.
		CDDB$W_STATUS+1(R1)
90$:	RSB					; Kill this fork thread.

	.SBTTL	DUTU$SEND_DUPLICATE_UNIT - Send duplicate unit message to operator

;++
;
; DUTU$SEND_DUPLICATE_UNIT - Send duplicate unit message to operator
;
; Functional Description:
;
;	A message indicating the detection of a duplicate MSCP unit number
;	is sent to OPCOM.
;
; Inputs:
;
;	R3	address of the UCB for which a MSCP server detected a 
;		duplicate unit number
;
; Outputs:
;
;	All registers preserved.
;--

DUTU$SEND_DUPLICATE_UNIT::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save registers.
	MOVL	R3, R5				; Jockey UCB addr. to right reg.
	MOVZBL	#MSG$_DUPUNITNO, R4		; Get message number.
	MOVAB	G^SYS$GL_OPRMBX, R3		; Get OPCOM's mailbox address.
	JSB	G^EXE$SNDEVMSG			; Send the message.
	POPR	#^M<R0,R1,R2,R3,R4,R5>		; Restore registers.
	RSB

	.SBTTL	"Register" Dump Routines
	.SBTTL	o DUTU$DUMP_COMMAND - Copy MSCP command to diagnostic buffer

;++
;
; DUTU$DUMP_COMMAND - Copy MSCP command to diagnostic buffer
;
; Functional Description:
;
;	Copy the contents of the MSCP Command to the diagnostic buffer whose 
;	address is pointed to by CDRP$L_DIAGBUF(R5).  This is the MSCP message 
;	which will be sent to the remote server.
;
; Inputs:
;	R5 CDRP address
;--

DUTU$DUMP_COMMAND::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVL	@CDRP$L_DIAGBUF(R5), R0	; Get diagnostic buffer address.
	MOVC3	#MSCP$K_MXCMDLEN, -	; Copy the entire command to the
		CDRP$L_MSG_BUF(R5), -	;  diagnostic buffer.
		20(R0)
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	RSB				; Return.
	.PAGE
	.SBTTL	o DUTU$DUMP_ENDMESSAGE - Copy MSCP end message to diagnostic buffer

;++
;
; DUTU$DUMP_ENDMESSAGE - Copy MSCP end message to diagnostic buffer
;
; Functional Description:
;
;	Copy the contents of the MSCP end message to the diagnostic buffer 
;	whose address is pointed to by CDRP$L_DIAGBUF(R5).  This is the MSCP 
;	end message returned to the class driver by the remote server.
;
; Inputs:
;
;	R1 END Message length
;	R2 END Message address
;	R5 CDRP address
;--

DUTU$DUMP_ENDMESSAGE::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVL	@CDRP$L_DIAGBUF(R5), R0	; Get diagnostic buffer address.
	MOVQ	G^EXE$GQ_SYSTIME, 8(R0)	; Save ending time.
	CLRL	16(R0)			; Clear retry counts.
	MOVC5	R1, (R2), #0, -		; Copy end message to diagnostic
		#MSCP$K_LEN, -		;  buffer zero filling for short
		MSCP$K_MXCMDLEN+20(R0)	;  end messages.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	RSB				; Return.

	.SBTTL	DUTU$FILL_MSCP_MSG - Zero fill a partial MSCP message
;++
;
; DUTU$FILL_MSCP_MSG - Zero fill a partial MSCP message
;
; Functional Description:
;
;	This routine zero fills an incomplete MSCP message.
;
; Inputs:
;
;	R1	size of MSCP message
;	R2	base address of MSCP message
;
; Outputs:
;
;	All registers preserved.
;--

DUTU$FILL_MSCP_MSG::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save registers.
	SUBL3	R1, #MSCP$K_LEN, R0		; Compute fill size.
	BLEQ	90$				; Branch if nothing to fill.
	MOVC5	#0, (SP), #0, R0, (R2)[R1]	; Zero fill the message.
90$:	POPR	#^M<R0,R1,R2,R3,R4,R5>		; Restore registers.
	RSB					; Return
	
	.END
