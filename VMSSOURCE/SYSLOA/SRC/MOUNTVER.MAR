	.TITLE	MOUNTVER - Mount Verification routines
	.IDENT	'V04-002'
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; Facility:
;
;	Executive I/O system.
;
; Abstract:
;
;	This module contains most of the code necessary to implement
;	mount verification.  Support routines not in this module are
;	contained in other modules in the EXEC, notably IOSUBNPAG.
;
; Environment:
;
;	This code executes in KERNEL mode, at device IPL
;	or higher, and the code must therefore be resident.
;
; Author:
;
;	Steven T. Jeffreys
;
; Creation date:
;
;	June 10, 1981
;
; Update history:
;
;	V04-002	ROW0415		Ralph O. Weber		10-SEP-1984
;		Fix no-quorum branch destination after PAUSE to go to the 
;		TIME_DELAY subroutine call.
;
;	V04-001	ROW0414		Ralph O. Weber		 6-SEP-1984
;		Rework handling of MVTIMEOUT checking after PAUSE so that 
;		/FOREIGN volumes -- which get into mount verification during 
;		cluster state transitions -- will time out mount verification.
;
;	V03-022	ROW0410		Ralph O. Weber		 6-AUG-1984
;		Setup use of UCB$V_CLUTRAN to guarantee that mount 
;		verification always runs for all disks after a VAXcluster 
;		state transition.
;
;	V03-021	ROW0407		Ralph O. Weber		25-JUL-1984
;		Add $GETDVI escape vector place holder, EXE$MNTVER_DVI_ASSIST. 
;		Also move EXE$MNTVERSP2 back to RSB; EXE$CLUTRANIO is 
;		correctly used by the connection manager now.
;
;	V03-020	ROW0403		Ralph O. Weber		22-JUL-1984
;		Change volume name checking so that if either the volume label 
;		or the volume lock name is correct the volume is considered to 
;		be correct.  This volume name checking technique is designed 
;		to handle the cases where the volume is write locked or 
;		becomes write locked such that the volume lock name cannot be 
;		written into the SCB.
;
;	V03-019	ROW0385		Ralph O. Weber		 7-JUL-1984
;		- Add GET_VCB, a generalized routine which gets the VCB 
;		  address when possible and signals its legal absence.
;		- Add EXE$CLUTRANIO symbol which will eventually replace 
;		  EXE$MNTVERSP2.
;		- Add symbol for EXE$UPDGNERNUM, the update a shadow set 
;		  generation number routine.
;		- Change UCB$V_SUPMVMSG processing to clear that bit if a 
;		  message which cannot be suppressed is ever broadcast.
;		- Change GET_BUFFER and FREE_BUFFER to save the address of the 
;		  IRP currently using the mount verification work buffer.
;		- Change volume validation algorithm to check volume lock name 
;		  stored in the SCB instead of the volume name stored in the 
;		  home block.  This prevents incorrect failures in a 
;		  VAXcluster where SET VOLUME /LABEL= has be used.
;
;	V03-018	ROW0372		Ralph O. Weber		30-MAY-1984
;		Correct setting of UCB$V_MNTVERIP and UCB$V_MNTVERPND bits in 
;		EXE$MNTVERSP2 to have them set in UCB$L_STS not UCB$L_DEVCHAR2.
;
;	V03-017	ROW0366		Ralph O. Weber		18-MAY-1984
;		Cause QUORUM_LOOP to REMQUE the quorum disk IRP before passing 
;		it off to the driver for processing.  This is useful because 
;		the driver will eventually insert the IRP on some queue and 
;		failing to remove it first causes queue tangles.
;
;	V03-016	WMC0004		Wayne Cardoza		15-May-1984
;		Class driver wants QUORLOST bit off after call.
;
;	V03-015	WMC0003		Wayne Cardoza		11-May-1984
;		More VCB fixes.
;
;	V03-014	WMC0002		Wayne Cardoza		10-May-1984
;		Fix problem for mount verification of disk without VCB.
;
;	V03-013	WMC0001		Wayne Cardoza		02-May-1984
;		Add support for loss of quorum stalling of I/O.
;
;	V03-012	ROW0343		Ralph O. Weber		10-APR-1984
;		Setup usage of UCB$V_SUPMVMSG to actually supress "normal" 
;		mount verification messages.
;
;	V03-011	ROW0330		Ralph O. Weber		24-MAR-1984
;		Add EXE$MNTVERSP1 and EXE$MNTVERSP2, two spare mount 
;		verification entry points.  Also move EXE$MNTVERSHDOL to a 
;		place where its future implementation is less likely to break 
;		branch displacements.
;
;	V03-010	ROW0326		Ralph O. Weber		20-MAR-1984
;		Add testing of SCB$Q_MOUNTTIME against VCB$Q_MOUNTTIME to 
;		enhance wrong volume detection.  Eliminate mount verification 
;		timeout for system disk.
;
;	V03-009	ROW0321		Ralph O. Weber		 4-MAR-1984
;		Fix incorrect usage of self-relative queues while waiting for
;		mount verification work page.  Change to using absolute queues.
;
;	V03-008	ROW0314		Ralph O. Weber		28-FEB-1984
;		Setup definition and use of MVMSL structure for the list of 
;		messages and other information relivant for using the 
;		SEND_MESSAGE routine.
;
;	V03-007	ROW0311		Ralph O. Weber		26-FEB-1984
;		> Change handling of work page based upon use of new mount 
;		  verification private work page instead of blackhole page.
;		> Setup no mount verification processing of any internal IRP.
;		> Fix bug in failure to allocate a mount verification IRP 
;		  error path.
;		> Eliminate unneeded code in INIT_IRP and SEND_MESSAGE.
;
;	V03-006	ROW0308		Ralph O. Weber		21-FEB-1984
;		Fix message handling to be position independent.
;
;	V03-005	ROW0292		Ralph O. Weber		 4-FEB-1984
;		o Make changes necessary to move this module to SYSLOAxxx.  
;		  Make all address references position independent.
;		o Restore TIME_DELAY routine, but have it FORK_WAIT using the 
;		  CDRP portion of the internal IRP.  Fix GET_BUFFER and 
;		  FREE_BUFFER to fork on the CDRP as well.  This makes mount 
;		  verfication compatible with the class drivers which fork on 
;		  the UCB at random times.
;		o Add replace START_IO label with EXE$MNTVERSIO thus making 
;		  that routine accessible to in-driver mount verification
;		  routines.
;		o Define EXE$MNTVERSHDOL as a NOP routine, for now.
;
;	V03-004	TCM0001		Trudy C. Matthews	09-Jun-1983
;		Set up register R4 before calling IOC$CVT_DEVNAM to get
;		node$ddcu name if a remote device and ddcu if a local device.
;
;	V03-003	ROW0177		Ralph O. Weber		 5-APR-1983
;		Remove routine TIME_DELAY and convert all its callers to use 
;		the fork-and-wait executive service, FORK_WAIT.
;
;	V03-001	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $PRDEF.
;
;--

	.PAGE
	.SBTTL	Declarations
;
; Macro definitions
;
	$CADEF				; Define conditional assembly symbols
	$CDDBDEF			; Class driver data block
	$CDRPDEF			; Define Class Driver Req. Pkt. fields
	$CLUBDEF			; Cluster block
	$CLUDCBDEF			; Quorum disk control block
	$DCDEF				; Device classes
	$DDBDEF				; Define Device Data Block fields
	$DDTDEF				; Define Driver Dispatch Table fields
	$DEVDEF				; Define device characteristics bits
	$DYNDEF				; Define block type symbols
	$FKBDEF				; Define Fork Block fields
	$HM1DEF				; Define ODS-1 home block fields
	$HM2DEF				; Define ODS-2 home block fields
	$IODEF				; Define I/O function codes
	$IRPDEF				; Define I/O Request Packet fields
	$MSGDEF				; Define system message type codes
	$MVMSLDEF			; Define MV message list symbols
	$PRDEF				; Define processor registers
	$PTEDEF				; Define Page Table Entry fields
	$SCBDEF				; Define Storage Control Block offsets
	$SSDEF				; Define system status codes
	$UCBDEF				; Define Unit Control Block fields
	$VCBDEF				; Define Volume Control Block fields

;+
; BUILD_TABLE
;
;	This macro builds entries in a table of mount verification messages.  
;	The table is used to coordinate messages broadcast to OPA0 with 
;	messages sent to OPCOM.  It existance allows both kinds of messages to 
;	be referenced by a single value, the table index value.
;
;	This table is also used by mount verification routines in various 
;	drivers.  The driver-specific mount verification routines are passed 
;	the base address of the table.  From this they can determine the 
;	address of the SEND_MESSAGE routine, and by scanning the table, they 
;	can determine the table index to supply to SEND_MESSAGE.
;
; Parameters:
;
;	index	symbol to be assigned the index value for a given message
;	opcom	OPCOM message number for a given message
;	text	OPA0 broadcast text for a given message
;	flags	bits giving special properties of a given message
;		the allowable flags are:
;		  MVMSL$M_NOSUFFIX	OPA0 broadcast should not include 
;					  "Mount verification in progress."
;		  MVMSL$M_SUPRESS	message sending can be supressed by 
;					   UCB$V_SUPMVMSG
;--

	.MACRO	BUILD_TABLE index, opcom, text, flags=0, ?l1
	.IIF	NDF TABLE_INDEX, TABLE_INDEX=0
	.ENABLE LSB
	.SAVE
	.PSECT	WMOUNTVERMSG
l1:	.ASCIC	text
	.RESTORE
	.WORD	opcom
	.WORD	flags
	.ADDRESS l1-EXE$AB_MVMSLBAS
	.DISABLE LSB
	index = TABLE_INDEX
	TABLE_INDEX = TABLE_INDEX + 1
	.ENDM	BUILD_TABLE
;
; Own storage (read only)
;

	.PSECT	WIONONPAGED LONG

; The following is the MVMSL passed to driver specific mount verification
; support routines.

	ASSUME	MVMSL$L_SNDMSGOFF EQ -4
	ASSUME	MVMSL$W_MSG_CODE  EQ  0
	ASSUME	MVMSL$W_FLAGS	  EQ  2
	ASSUME	MVMSL$L_TEXTOFF	  EQ  4
	ASSUME	MVMSL$K_LENGTH	  EQ  8

	.ADDRESS SEND_MESSAGE - EXE$AB_MVMSLBAS	; Offset to SEND_MESSAGE
EXE$AB_MVMSLBAS::
	BUILD_TABLE	index=OFFLINE, opcom=MSG$_DEVOFFLINX, -
			flags=MVMSL$M_SUPRESS, -
			text=<" is offline.">

	BUILD_TABLE	index=WRONGVOL, opcom=MSG$_WRONGVOL, -
			text=<" contains the wrong volume.">

	BUILD_TABLE	index=WRITELOCK, opcom=MSG$_DEVWRTLCK, -
			text=<" has been write-locked.">

	BUILD_TABLE	index=MVCOMPLETE, opcom=MSG$_MVCOMPLETE, -
			flags=<MVMSL$M_NOSUFFIX ! MVMSL$M_SUPRESS>, -
			text=<" has completed mount verification.">

	BUILD_TABLE	index=MVABORTED, opcom=MSG$_MVABORTED, -
			flags=MVMSL$M_NOSUFFIX, -
			text=<" has aborted mount verification.">
;
; The following message text is part of every message, and does not
; require an entry in the message table.
;

	.PSECT	WMOUNTVERMSG
PREFIX:	.ASCIC	"%SYSTEM-I-MOUNTVER, "  
SUFFIX:	.ASCIC	"  Mount verification in progress."

;
; The following literal is used as carriage control
; in the message sent to the operator's console.  
;
CAR_CTRL	= ^X0A0D		; <cr><lf> characters
CAR_CTRL_SIZE	= 2			; Size in bytes
	.PAGE
	.SBTTL	EXE$MOUNTVER - initial entry point
;++
; EXE$MOUNTVER
;
; Functional description:
;
;	Mount verification is the mechanism whereby Files-11 volumes are
;	are brought back online after a catastrophic (but hopefully transient)
;	hardware problem has rendered the volume unusable.
;
;	This is the main routine, and initial entry point of the
;	mount verification code.  For a detailed discussion of
;	the implementation, please see the section entitled "Design Notes".
;
; Input:
;
;	R0,R1	 = I/O status
;	R2	 = scratch
;	R3	 = IRP address
;	R4	 = scratch
;	R5	 = UCB address
;	0(SP)	 = return address of caller
;       4(SP)	 = return address of caller's caller
;
; Output:
;
;	None.
;
; Side Effects:
;
;	Providing that whatever external event has caused a given
;	volume to undergo mount verification has been corrected,
;	normal I/O activity will resume on the device.  Otherwise,
;	the volume will do no useful work until mount verification
;	is complete, and will appear to be hung.
;
; Design Notes:
;
;	Mount verification (MV for short) is only done for FILES-11
;	disk volumes.  Tapes are already covered by the magnetic
;	tape ACP, and handling foreign disk volumes would open a
;	security hole that would be difficult to close.
;
;	There are two error conditions that can cause a volume to
;	undergo mount verification.  The first arises when a volume
;	is somehow hardware writelocked sometime after it was mount
;	write-enabled.  (The writelock recovery mechanism is covered
;	in detail in the funtional description of the WRITLCK_HNDLR
;	routine, and will not be covered here.)
;
;	The second, and more serious, situation is the result of the 
;	volume being declared software invalid.  The volume-valid
;	bit in the volume's UCB is cleared by the driver when it
;	detects a situation that warrants such action, such as the
;	device issuing an ONLINE interrupt.  This implies that the
;	volume has been spun down, and then spun back up, so the
;	contents of the drive may not be the same.  It is MV's task
;	to notify the operator of the situation, and to verify that
;	the volume (if any) now in the drive is the same one that
;	was there originally.
;
;	What follows is a series of one-liners and short paragraphs
;	that are meant to explain various design decisions, and
;	to explain obscure parts of the code.  There is no particular
;	order to the notes.
;
;	The cell EXE$GL_SVAPTE maps the MV work page into S0 space,
;	and is set up by INIT at system boot time.  MV used to use
;	the blackhole page for its I/O operations.  However, the 
;	read-modify-write operations performed by shadow set state
;	change processing prohibit this.  Permanent provision of a 
;	512 byte buffer for MV is preferable to dynamic allocation 
;	of the space because a pileup of MV requests might make 
;	allocation of the needed space impossible.
;
;	Broadcasting a message directly to the operator's console
;	is done to ensure that someone is notified of MV being in
;	progess.  OPCOM cannot be relied on since it may not be
;	present, or the very nature of the problem may prevent it
;	from operating (eg.  OPCOM is swapped out, and the system
;	disk is undergoing MV).
;
;	The code is optimized for size over speed, since the code
;	is infrequently executed, but must be resident.
;
;	Once MV starts, normal I/O activity on the device ceases until
;	MV completes or the volume is dismounted.  Unfortunately, there
;	is a deadlock problem with the ACP, because to dismount a volume
;	an ACP I/O request must be done to the volume, and that can't
;	happen since we're in MV, so the ACP hangs waiting for the I/O
;	to complete.  Worse, requests will pile up at the ACP, and
;	other processes will be hung by the hung ACP.  The situation
;	clears itself up nicely when MV completes.
;
;	MV consists of the code in this module, support routines in
;	other modules, and a driver-dependent piece of code that
;	is pointed to by the driver's DDT.  The covention is that
;	if R3 is nonzero, the routine should assume that R3 points
;	to an IRP and requeue the IRP.  If R3 is zero, dequeue the
;	first IRP and resume normal I/O activity.  The cell in the
;	DDT is DDT$L_MNTVER, and it defaults to IOC$MNTVER.
;
;	MV is entered by the common I/O completion routine, IOC$REQCOM.
;	This may be different for DISK_CLASS drivers.
;--
	.PAGE
	.PSECT	WIONONPAGED
	.ENABL LSB

EXE$MOUNTVER::				; Initial entry point
;
; See if an IRP was supplied.  If not, skip all the checks and I/O cleanup.
;
	TSTL	R3
	BEQL	35$
;
; Determine if mount verification is possible and necessary.
;
	;
	; Ignore all internal IRPs (including MV IRPs).
	;
	TSTL	IRP$L_PID(R3)		; Is this an internal IRP?
	BLSS	10$			; Branch to exit if internal IRP.
	;
	; The device must be file oriented, and contain a mounted
	; volume that is not mounted /FOREIGN.  In addition, the volume
	; must have a VCB with the 
	; The one time this is not true is if this is a cluster that is out
	; out of quorum.  In this case, we must go into mount verification in 
	; order to stall all I/O
	;
	BBC	#DEV$V_FOD,-		; Branch if device not file oriented
		UCB$L_DEVCHAR(R5),10$	;
	BBS	#DEV$V_SQD,-		; Is this a sequential device?
		UCB$L_DEVCHAR(R5),10$	;
	BSBW	QUORUM			; Is it out-of-quorum cluster
	BLBS	R4,20$			; Yes
	BBSC	#UCB$V_CLUTRAN, -	; Branch if here due to a VAXcluster
		UCB$L_STS(R5), 20$	; state transition (and clear flag).
	BBC	#DEV$V_MNT,-		; Branch if device not mounted
		UCB$L_DEVCHAR(R5),10$	;
	BBS	#DEV$V_FOR,-		; Is this a foreign device?
		UCB$L_DEVCHAR(R5),10$	;
	;
	; Check the VCB$V_MOUNTVER bit to ensure the volume
	; is a candidate for mount verification.
	;
	MOVL	UCB$L_VCB(R5),R4	; Get the VCB address
	BEQL	10$			; Exit if none
	BBC	#VCB$V_MOUNTVER,-	; Exit if bit not set
		VCB$B_STATUS2(R4),10$	;
	;
	; If the medium is offline, or the volume is
	; invalid, the error can be recovered from.
	;
	CMPW	#SS$_MEDOFL,R0		; Is the media (disk volume) offline?
	BEQL	20$			; Branch if true
	CMPW	#SS$_VOLINV,R0		; Is the volume invalid?
	BEQL	20$			; Branch if true
	;
	; If the volume has been writelocked, make sure that it was
	; an accidental writelock.  If the software writelock bit is
	; on, then the volume was mounted with the volume write protected.
	; If the bit is not set, then the volume has been mounted for
	; read/write access, and has since been (accidentally) write protected.
	;
	CMPW	#SS$_WRITLCK,R0		; Is the device writelocked?
	BNEQ	10$			; Branch if not
	BBS	#DEV$V_SWL,-		; Branch if software writelocked
		UCB$L_DEVCHAR(R5),10$	;
	BRW	WRITLCK_HNDLR		; Recover from accidental writelock
10$:	RSB				; Mount verifcation is not called for - exit
;
; The error can be recovered from.
;
20$:	BBCC	#IRP$V_MVIRP,-		; Clear the MV bit in the IRP.
		IRP$W_STS(R3),30$	;
30$:	BSBW	CLEANUP_IO		; Clean up the I/O operation
	;
	; Perform any driver-specific initialization for mount verification.
	; R5 points to the device UCB, and R3 points to the IRP.
	;
	BSBW	DRIVER_CODE
35$:	TSTL	(SP)+			; Discard the return address
;
; This entry point is used to start mount verification without having an error 
; IRP
;
MNTVER_NOIRP:
	BBSS	#UCB$V_MNTVERIP,-	; Set mount verification in progress
		UCB$W_STS(R5),10$	; (return to caller's caller if already set)
;
; Inform interested parties that the device needs attention.
;
	MOVL	#OFFLINE,R4		; Set message code
	BSBW	SEND_MESSAGE		; Send message
;
; Allocate an IRP.  If non exists, exit.
;
	MOVZWL	#IRP$K_LENGTH,R1	; Set IRP size
	JSB	G^EXE$ALONONPAGED	; Allocate an IRP
	MOVL	R2,R3			; Copy IRP address
	BLBS	R0,40$			; Branch if success
	CLRL	R3			; Signal the no IRP was allocated.
	BRW	ERROR_EXIT		; Exit if no IRP available
;
; Calculate the maximum time for which we will
; continue to attempt mount verification.  Store
; the value in the IRP.
;
40$:	MOVZWL	G^IOC$GW_MVTIMEOUT,R0	; Get delta time
	ADDL3	G^EXE$GL_ABSTIM,R0,-	; Add site-specific delta time to current time
		IRP$L_ASTPRM(R3)	; Fall through...
		
;
; Decide whether or not this is a cluster that is out of quorum.
; From this point on the meaning of R4 is:
;	0 -> normal mount verification
;	1 -> out of quorum
;	-1-> out of quorum and pack-ack completed
;
	BSBW	QUORUM			; Get indicator in R4

	.DSABL	LSB

BUILD_PACKACK_IRP:
	BSBW	INIT_IRP		; Set request-independent fields in the IRP
	;
	; Determine if the device supports a PACKACK function.
	; If it does, then issue a PACKACK request, else attempt
	; to read the volume's home block.
	;
	BBSS	#UCB$V_VALID,-		; Set volume valid
		UCB$W_STS(R5),10$	;
10$:	MOVL	UCB$L_DDT(R5),R1	; Get address of DDT
	MOVL	DDT$L_FDT(R1),R1	; Get address of FDT masks
	BBC	#IO$_PACKACK,(R1),-	; Branch if PACKACK not supported
		30$			;
	;
	; Set the request dependent fields in the IRP and start the I/O.
	;
20$:	ASSUME	IO$_PHYSICAL GE IO$_PACKACK
	MOVW	#<IRP$M_PHYSIO	! -	; Set physical I/O function
		  IRP$M_MVIRP>,-	; Mark this a mount verification IRP
		IRP$W_STS(R3)		;
	MOVW	#<IO$_PACKACK ! IO$M_INHERLOG>,-
		IRP$W_FUNC(R3)		; Set function code, inhibit error logging
	BSBW	EXE$MNTVERSIO		; Start I/O request
;
; When the PACKACK I/O is done, control returns here.
;
	BSBW	QUORUM			; Is it out-of-quorum cluster
	BLBC	IRP$L_MEDIA(R3),-	; If failure, try again
		PAUSE			;
30$:	MNEGL	R4,R4			; Indicate pack-ack succeeded
	BNEQ	QUORUM_LOOP		; No quorum
	BSBW	GET_VCB			; Check for legally absent VCB.
	BEQL	39$			; Branch if VCB legally absent.
	BRW	BUILD_RDHOME_IRP	; Otherwise, go check the volume.
39$:	BRW	NORMAL_EXIT		; Branch assist.

PAUSE:	;
	; If out-of-quorum, skip all checks and just wait a while.  Else, 
	; check for MVTIMEOUT expired on this request or VCB$V_MOUNTVER 
	; clear (indicate abort mount verification).  If mount verification 
	; still ok, wait.  Else, abort.
	;
	BLBS	R4, 15$			; If no quorum, skip checks.
	BSBW	GET_VCB			; Get VCB address.
	CMPL	G^EXE$GL_ABSTIM, -	; Have we run out of time?
		IRP$L_ASTPRM(R3)
	BLSSU	10$			; Branch if we still have time.
	TSTL	R0			; Out of time.  Is there a VCB?
	BEQL	20$			; Branch if no VCB to update.
	BICB	#<1@VCB$V_MOUNTVER>, -	; Else, disable mount verification.
		VCB$B_STATUS2(R0)
	BRB	20$			; Then abort.
10$:	TSTL	R0			; Still have time.  Is there a VCB?
	BEQL	15$			; Branch if no VCB to check.
	BBC	#VCB$V_MOUNTVER, -	; Abort MV if MV is now disabled.
		VCB$B_STATUS2(R0), 20$
15$:	BSBW	TIME_DELAY		; Pause for a bit
	BLBS	R4,QUORUM_LOOP		; We are waiting for quorum
	BRB	BUILD_PACKACK_IRP	; Retry the packack
20$:	BRW	ERROR_EXIT		; Exit
;
; Check for quorum IRP and issue it if found.
; Wait a while longer if still no quorum
;
QUORUM_LOOP:
	MOVL	G^CLU$GL_CLUB,R1
	MOVL	CLUB$L_CLUDCB(R1),R1	; Get quorum disk control block
	BEQL	20$			; None
	MOVL	CLUDCB$L_IRP(R1),R1	; Quorum IRP
	BEQL	20$			; None
	MOVAB	UCB$L_IOQFL(R5),R0	; IO queue
	MOVL	R0,R2
10$:	MOVL	(R2),R2			; Next IRP
	CMPL	R0,R2
	BEQL	20$			; End of queue
	CMPL	R2,R1			; Is this the quorum IRP
	BNEQ	10$			; Not an interesting IRP
	REMQUE	(R2),R2			; Dequeue the quorum IRP
	BBC	#DEV$V_MSCP,UCB$L_DEVCHAR2(R5),15$ ; Standard disk
	BBSS	#IRP$V_MVIRP,-		; Let the I/O go through
		IRP$W_STS(R2),12$	; pretend it is MV IRP
12$:	PUSHR	#^M<R3,R4,R5>
	MOVL	R2,R3			; Quorum IRP
	JSB	G^IOC$INITIATE		; Go start the I/O
	POPR	#^M<R3,R4,R5>
	BRB	20$			; Continue
;
15$:	BISL	#UCB$M_MNTVERPND,UCB$L_STS(R5) ; Get control back after I/O
	MOVL	R3,R0			; Mount verification IRP
	JSB	G^COM$DRVDEALMEM	; Free it
	MOVL	R2,R3			; Quorum IRP
	JMP	G^IOC$INITIATE		; Go do I/O 
;
20$:	MOVL	G^CLU$GL_CLUB,R2
	BBS	#CLUB$V_QUORUM,CLUB$L_FLAGS(R2),30$ ; At last we have quorum
	TSTL	R4
	BLSS	25$			; Go wait some more
	BRW	BUILD_PACKACK_IRP	; Pack-ack not done yet
25$:	BRW	PAUSE
30$:	CLRL	R4			; Indicate we now have quorum
	BSBW	GET_VCB			; Check for legally absent VCB.
	BEQL	NORMAL_EXIT		; Branch if VCB is legally absent.
					; Else, test volume validity.

;
; Validate that the correct volume is still in the drive.
;
;	The validation is performed in two steps.  First the home block is 
;	read and checked against fields stored in the VCB.  If that test 
;	succeeds, the storage control block is read and checked against fields 
;	stored in the VCB.  If either test fails, wrong volume mount 
;	verification is entered.
;
BUILD_RDHOME_IRP:

	BSBW	GET_BUFFER		; Obtain ownership of MV work buffer.

	; Read and validate the home block.

	BSBW	INIT_IRP		; Initialize IRP.
	MOVL	UCB$L_VCB(R5), R0	; Get VCB address.
	BNEQ	10$
	BRW	FREE_BUF_ERRXIT		; Branch if no VCB address.
10$:	MOVL	VCB$L_HOMELBN(R0), R0	; Get home block LBN.
	BSBW	INIT_IRP_READ		; Setup IRP for home block read.
	BSBW	EXE$MNTVERSIO		; Do the read.
	BSBW	QUORUM			; Is it out-of-quorum cluster
	BLBC	R4,20$			; Yes
	CLRL	R0			; Error status
	BRB	VALIDATE_FAILED		; WE don't want to succeed without quorum
20$:
	BLBC	IRP$L_MEDIA(R3), -	; Branch if error occured on the read.
		VALIDATE_FAILED
	BSBW	VALIDATE_HOME		; Validate the home block.
	BLBC	R0, VALIDATE_FAILED	; Branch if home blk. validation failed.

	; Read and validate the storage control block.

	BSBW	INIT_IRP		; Initialize IRP.
	MOVL	UCB$L_VCB(R5), R0	; Get VCB address.
	BEQL	FREE_BUF_ERRXIT		; Branch if no VCB address.
	SUBL3	#1, -			; Get storage control block LBN.
		VCB$L_SBMAPLBN(R0), R0
	BSBW	INIT_IRP_READ		; Setup IRP for home block read.
	BSBW	EXE$MNTVERSIO		; Do the read.
	BSBW	QUORUM			; Is it out-of-quorum cluster
	BLBC	R4,30$			; Yes
	CLRL	R0			; Error status
	BRB	VALIDATE_FAILED		; WE don't want to succeed without quorum
30$:
	BLBC	IRP$L_MEDIA(R3), -	; Branch if error occured on the read.
		VALIDATE_FAILED
	BSBW	VALIDATE_SCB		; Validate the storage block.
	BLBC	R0, VALIDATE_FAILED	; Branch if SCB validation failed.

	; Mount verification has succeeded.
	; Release the MV work buffer, inform the world that this volume has 
	; returned to the living, and drop through to a normal exit.

	BSBW	FREE_BUFFER		; Release MV work buffer.
	MOVL	#MVCOMPLETE, R4		; Set success message code.
	BSBW	SEND_MESSAGE		; Signal the world.

;
; This is the common exit path for mount verification.
; Return all resources, clear MNTVERIP, and resume normal
; I/O activity for the device.
;
NORMAL_EXIT:
	MOVL	R3,R0			; Copy IRP address
	BEQL	10$			; Branch if no IRP was allocated.
	JSB	G^COM$DRVDEALMEM	; Deallocate the IRP
10$:	BICL	#<UCB$M_MNTVERIP ! -	; Clear MNTVERIP and WRONGVOL
		  UCB$M_WRONGVOL ! -	; and SUPMVMSG
		  UCB$M_SUPMVMSG>, -	;
		UCB$L_STS(R5)		;
	CLRL	R3			; Clear pointer to IRP
	BSBW	DRIVER_CODE		; Do driver-specific clean-up
	RSB				; Exit
;
; Attempt to recover from an error encountered while reading
; the home block or while validating the volume.
;
VALIDATE_FAILED:
	BSBB	FREE_BUFFER		; Release MV work buffer.
	CMPW	#SS$_INCVOLLABEL,R0	; Is this the correct volume?
	BEQL	20$			; Branch if not
	BBSC	#UCB$V_WRONGVOL,-	; Clear WRONGVOL bit
		UCB$W_STS(R5),10$	;
10$:	BRW	PAUSE			; Retry mount verification
	;
	; The wrong volume is in the drive.  If this is the first time
	; for this volume, inform all interested parties of the event.
	;
20$:	BBSS	#UCB$V_WRONGVOL,-	; Branch if not the first time
		UCB$W_STS(R5),10$	;
	PUSHL	R4			; Save quorum indicator
	MOVL	#WRONGVOL,R4		; Set message code
	BSBW	SEND_MESSAGE		; Send message to console
	POPL	R4
	BRB	10$			; Try again
;
; This is the error exit path for mount verification.
; Since the operation never completed, clear volume valid
; to prevent the volume from being used.
;
FREE_BUF_ERRXIT:
	BSBB	FREE_BUFFER		; Free MV work buffer, then error exit.
ERROR_EXIT:
	MOVL	#MVABORTED,R4		; Set message code
	BSBW	SEND_MESSAGE		; Send message to console
	BBCC	#UCB$V_VALID,-		; Clear volume valid and join common code
		UCB$W_STS(R5),-		;
		NORMAL_EXIT		;
	BRB	NORMAL_EXIT		; Branch to common exit code

	.PAGE
	.SBTTL	GET_BUFFER - allocate an I/O buffer
;++
; GET_BUFFER
;
; Functional description:
;
;	This routine will attempt to allocate the MV work page
;	for to the caller.  If the page is not busy, the page is
;	marked busy and control returns to the caller.  If the page
;	is busy, the caller's context is folded up into the CDRP
;	attached to the input internal IRP and the CDRP is put on 
;	the blakhole page wait queue.  When the wait queue entry is
;	processed, input context is restored and control is return
;	to the caller, who now owns the MV work page.
;
; Input:
;
;	R3	= Mount verification IRP address (CDRP used as fork block)
;	R5	= Device UCB address
;	(SP)	= Return address for caller
;      4(SP)	= Return address for caller's caller
;
; Output:
;
;	R3..R5	are preserved.
;++

; Define cells used to control access to MV work page.

	.ALIGN	LONG
EXE$AL_WRKWQFL: .LONG 0			; Work page wait queue.
EXE$AL_WRKWQBL: .LONG 0
EXE$AL_BSYIRP: .LONG 0			; Current buffer owner IRP.
EXE$AB_MVWORK: .BYTE 0			; Byte of storage belonging to the 
					; MV work buffer owner.

GET_BUFFER:

	TSTL	B^EXE$AL_BSYIRP		; Is the work buffer currently owned?
	BNEQ	10$			; Branch if work buffer is owned.
	MOVL	R3, B^EXE$AL_BSYIRP	; Else, setup address of current owner.
	RSB				; Return to caller
	;
	; The page is busy. Put the caller in the wait queue.
	;
10$:	MOVAB	IRP$L_FQFL(R3), R5	; Get CDRP for use as fork block.
	MOVQ	R3, CDRP$L_FR3(R5)	; Save R3 and R4.
	POPL	CDRP$L_FPC(R5)		; Save return address.
	TSTL	B^EXE$AL_WRKWQFL	; Is work page wait queue initialized?
	BNEQ	20$			; Branch if queue initialized.
	MOVAL	B^EXE$AL_WRKWQFL, -	; Else, initalize queue header.
		B^EXE$AL_WRKWQFL
	MOVAL	B^EXE$AL_WRKWQFL, -
		B^EXE$AL_WRKWQBL
20$:	INSQUE	(R5), @B^EXE$AL_WRKWQBL ; Put CDRP on the work page wait queue.
	RSB				; Return to caller's caller.
	.PAGE
	.SBTTL	FREE_BUFFER - release an I/O buffer
;++
; FREE_BUFFER
;
; Functional description:
;
;	This routine is called by the current owner of the MV work page
;	to make the page available.  If the MV work page wait queue is
;	not empty, a fork process will be created for the waiting device,
;	and the MV work page will be given to that process.
; 
; Input:
;
;	None.
;
; Output:
;
;	R0, R3...R5 are preserved.
;--

FREE_BUFFER:				; Release an I/O buffer
	;
	; Remove first entry from wait queue.  If empty, then return.
	;
	TSTL	B^EXE$AL_WRKWQFL	; Is work page wait queue initialized?
	BEQL	10$			; Branch if Q not init'ed (ie. unused).
	REMQUE	@B^EXE$AL_WRKWQFL, R1	; Remove first entry from wait queue.
	BVC	20$			; Branch if somebody was waiting.
10$:	CLRL	B^EXE$AL_BSYIRP		; Mark the MV work page as unowned.
	RSB				; Return to caller.
	;
	; Restore the waiting fork process's context
	; and call it at its return address.
	;
20$:	PUSHR	#^M<R0,R3,R4,R5>	; Save current fork context and R0.
	MOVL	R1, R5			; Copy fork block address.
	MOVQ	CDRP$L_FR3(R5), R3	; Restore saved R3 and R4.
	MOVL	IRP$L_UCB(R3), R5	; Restore UCB address.
	MOVL	R3, B^EXE$AL_BSYIRP	; Save address of work page owner.
	ASSUME	IRP$L_FPC EQ <IRP$L_FQFL + CDRP$L_FPC>
	JSB	@IRP$L_FPC(R3)		; Call waiting fork process.
	POPR	#^M<R0,R3,R4,R5>	; Restore input context.
	RSB				; Return.
	.PAGE
	.SBTTL	TIME_DELAY - Put mount verification into a wait state
;+
; TIME_DELAY
;
; Functional description:
;
;	This routine will put the specified mount verification 
;	request into a wait state for a short while.  This is 
;	accomplished by performing a FORK_WAIT using the CDRP
;	in the IRP/CDRP pair of the input internal IRP.
;
; Input:
;
;	R3 = internal irp address
;	R5 = device ucb address
;
; Output:
;
;	R3..R5	are preserved
;-

TIME_DELAY:				; Pause for a moment
	POPL	IRP$L_SAVD_RTN(R3)	; Save caller's return address.
	MOVB	UCB$B_FIPL(R5), -	; Copy fork IPL to CDRP at tail of
		IRP$B_FIPL(R3)		; IRP.
	MOVAB	IRP$L_FQFL(R3), R5	; Get CDRP address.
	FORK_WAIT			; Wait with CDRP as fork block.
	MOVL	IRP$L_UCB(R3), R5	; Restore UCB address.
	JMP	@IRP$L_SAVD_RTN(R3)	; Return to original caller.
	.PAGE
	.SBTTL	INIT_IRP - set request independent fields of the IRP
;++
; INIT_IRP
;
; Functional description:
;
;	Zero an IRP and then set certain request-independent
;	fields to their initial values.
;
; Input:
;
;	R3	= IRP address
;	R5	= UCB address
;
; Output:
;
;	R0,R1,R2  are overwritten
;	R4	preserved
;	R3	= IRP address
;	R5  	= UCB address
;--

INIT_IRP:				; Set request-independent fields of IRP
;
; Zero the IRP.
;
	PUSHL	IRP$L_ASTPRM(R3)	; Save the MV timeout time
	PUSHR	#^M<R3,R4,R5>		; Save IRP and UCB address from MOVC5
	MOVC5	#0,(R0),#0,#IRP$K_LENGTH,(R3)	; Zero the IRP
	POPR	#^M<R3,R4,R5>		; Restore IRP and UCB address
	POPL	IRP$L_ASTPRM(R3)	; Restore the MV timeout time
;
; Set the request-independent fields of the IRP.
;
	;
	; Set the size, type and access mode fields.
	;
	ASSUME	IRP$W_SIZE  EQ 8
	ASSUME	IRP$B_TYPE  EQ 10
	ASSUME	IRP$B_RMOD  EQ 11
	MOVL	#<<DYN$C_IRP@16>!IRP$K_LENGTH>, IRP$W_SIZE(R3)
	;
	; Set the UCB address.  All other fields remain zero for now.
	;
	MOVL	R5,IRP$L_UCB(R3)	; Set UCB address
	RSB
	.PAGE
	.SBTTL	INIT_IRP_READ - setup IRP for a one block read
;++
; INIT_IRP_READ
;
; Functional description:
;
;	Setup IRP fields required for a read operation.  Assume a one
;	block read of the LBN specified in R0.
;
; Input:
;
;	R0	LBN to read
;	R3	IRP address
;	R5	UCB address
;
; Output:
;
;	R0 ... R2 overwritten
;	All other registers preserved.
;--

INIT_IRP_READ:

	MOVW	#<IO$_READPBLK -	; Set function:	read block
		 !IO$M_INHERLOG>, -	;		w/o error logging
		IRP$W_FUNC(R3)
	ASSUME	IO$_READPBLK LE IO$_PHYSICAL
	BISW	#<IRP$M_FUNC -		; Set req. status:	read function
		 !IRP$M_MVIRP>, -	;			MV request
		IRP$W_STS(R3)
	MOVL	G^EXE$GL_SVAPTE, -	; Set transfer SVAPTE for MV work
		IRP$L_SVAPTE(R3)	; page.
	MOVZWL	#512, IRP$L_BCNT(R3)	; Set transfer byte count of 1 block.
	JMP	G^IOC$CVTLOGPHY		; Convert LBN (in R0) to PBN, and
					; return to caller.
	.PAGE
	.SBTTL	VALIDATE_HOME
;++
; VALIDATE_HOME
;
;	This routine will check to see if the home block that was just
;	read contains valid data, and if so it will check to see if the
;	home block belongs to same volume as the one described in the
;	VCB for this device.  If both checks succeed, return success.
;	If either check fails, return failure.
;
; Input:
;
;	R3	= IRP address
;	R5	= UCB address
;
; Output:
;
;	R0		LBS ==> volume is correct
;			LBC ==> some type of error
;	EXE$AB_MVWORK	is zero if the volume label comparison failed
;			and one if it succeeded
;
;	R3, R4 and R5 are preserved.
;
; Side effects:
;
;	If the volume now physicaly mounted in the device is not
;	the same volume as the one described in the VCB, then the
;	interested parties will be informed, and the mount verification
;	will be restarted.
;--

VALIDATE_HOME:

	PUSHL	R4			; Save quorum indicator
	BSBB	GET_BUF_ADDR		; Get virtual address of MV buffer.

	;
	; Compare the volume serial number and volume name in the VCB
	; with those stored on the stack.  If they are identical, then
	; this is the correct volume.  The following assumptions must
	; be true if we are to avoid special-casing ODS-1 and ODS-2 volumes.
	;
	ASSUME	HM2$L_SERIALNUM EQ HM1$L_SERIALNUM
	ASSUME	HM2$T_VOLNAME	EQ HM1$T_VOLNAME2
	;
	MOVL	UCB$L_VCB(R5), R0	; Get VCB address.
	BEQL	VALIDATE_EXIT		; Branch if no VCB address.
	CMPL	HM2$L_SERIALNUM(R4), -	; Check the volume serial number.
		VCB$L_SERIALNUM(R0)
	BNEQ	VALIDATE_ERROR		; Branch if serial nos. not equal.
	CLRB	W^EXE$AB_MVWORK		; Assume label comparison will fail.
	PUSHR	#^M<R3,R4,R5>		; Save registers.
	CMPC3	#VCB$S_VOLNAME, -	; Check the volume name.
		HM2$T_VOLNAME(R4), -
		VCB$T_VOLNAME(R0)
	POPR	#^M<R3,R4,R5>		; Restore registers.
	BNEQ	10$			; Branch if not the same volume.
	INCB	W^EXE$AB_MVWORK		; Else, set same volume flag.
10$:	BSBB	CHECKSUM		; Test home block checksum, and
	BRB	VALIDATE_EXIT

VALIDATE_ERROR:

	; A difference has been detected between the block in the MV work 
	; buffer (either the home block or the storage control block) and the 
	; VCB.  If the block checksum agrees with the caculated checksum, then 
	; the volume is incorrect.  If the checksums do not agree, then the 
	; preceived difference may be due to a corrupted disk block.  In such 
	; cases the read must be retried.

	BSBB	CHECKSUM		; Checksum the MV work buffer.
	BLBC	R0, VALIDATE_EXIT	; Branch if checksums differ.
	MOVZWL	#SS$_INCVOLLABEL, R0	; Else, set incorrect volume status.

VALIDATE_EXIT:
	POPL	R4
	RSB				; Return.
	.PAGE
	.SBTTL	VALIDATE_SCB
;++
; VALIDATE_SCB
;
;	This routine verifies the checksum of the storage control block in 
;	the MV work buffer.  If the checksum is ok, the mount time in the SCB 
;	is compared to the equivalent value in the VCB.  If the volume label 
;	tested in VALIDATE_HOME did not match, the volume-lock-names in the 
;	VCB and SCB are also compared.  If all tested values are equal, 
;	success is returned.  Otherwise, SS$_INCVOLLABEL is returned.
;
; Input:
;
;	R5		UCB address
;	EXE$AB_MVWORK	is zero if the volume label comparison in 
;			VALIDATE_VOLUME failed and one if it succeeded
;
; Output:
;
;	R0	LBS ==> volume is correct
;		LBC ==> some type of error
;
;	R1 and R2 are overwritten.
;	All other registers are preserved.
;--

VALIDATE_SCB:
	PUSHL	R4			; Save quorum indicator
	BSBB	GET_BUF_ADDR		; Get the MV work buffer VA.
	MOVL	UCB$L_VCB(R5), R0	; Get VCB address.
	BEQL	VALIDATE_EXIT		; Branch if no VCB.
	CMPL	SCB$Q_MOUNTTIME(R4), -	; Compare mount times in the SCB
		VCB$Q_MOUNTTIME(R0)	; and in the VCB.
	BNEQ	VALIDATE_ERROR		; Take error exit if times don't
	CMPL	SCB$Q_MOUNTTIME+4(R4), -; match.
		VCB$Q_MOUNTTIME+4(R0)
	BNEQ	VALIDATE_ERROR
	BLBS	W^EXE$AB_MVWORK, 50$	; Branch if VALIDATE_VOLUME succeeded.
	PUSHR	#^M<R3,R4,R5>		; Save registers.
	CMPC3	#VCB$S_VOLCKNAM, -	; Check the volume-lock-name.
		SCB$T_VOLOCKNAME(R4), -
		VCB$T_VOLCKNAM(R0)
	POPR	#^M<R3,R4,R5>		; Restore registers.
	BNEQ	VALIDATE_ERROR		; Branch if not the same volume.
50$:	BSBB	CHECKSUM		; Test SCB checksum, and
	POPL	R4
	RSB
	.PAGE
	.SBTTL	CHECKSUM - compute FILES-11 structure block checksum
;++
; CHECKSUM
;
; Functional description:
;
;	This routine computes the FILES-11 structure block checksum and 
;	compares it to the checksum stored in the FILES-11 structure block.  
;	If the checksums match, a success status is returned.
;
; Input:
;
;	R4	= FILES-11 structure block buffer address
;
; Ouput:
;
;	R0	= status value
;	R3 and R5 are preserved
;--

CHECKSUM:				; Compute FILES-11 block checksum

	; Note: the FILES-11 structure block checksum is stored in the last 
	; word of the structure.  After the checksum loop completes, R4 points 
	; to the stored checksum and R1 contains the computed checksum.  The 
	; following assumptions must be true for this technique to work.

	ASSUME	HM2$W_CHECKSUM2 EQ HM1$W_CHECKSUM2
	ASSUME	HM2$W_CHECKSUM2/2 EQ 255

	CLRQ	R0			; Assume failure; clear total
	MOVZBL	#255,R2			; Set loop counter
10$:	ADDW2	(R4)+,R1		; Sum adjacent words
	SOBGTR	R2,10$			; Branch if more to go
	CMPW	R1,(R4)			; Compare checksums
	BNEQ	13$			; Branch if not equal
	INCL	R0			; Set success status
13$:	RSB				; Return
	.PAGE
	.SBTTL	GET_BUF_ADDR
;++
; GET_BUF_ADDR
;
;	This routine returns the virtual address of the MV work buffer in R4.
;
; Input:
;
;	None.
;
;
; Output:
;
;	R4	system virtual address of the MV work buffer
;
;	All other registers are preserved.
;--

GET_BUF_ADDR:

	SUBL3	G^MMG$GL_SPTBASE, -	; Calculate byte offset to MV work
		G^EXE$GL_SVAPTE, R4	; SPTE.
	ASHL	#9-2, R4, R4		; Shift offset making VA minus 80000000.
	BBSS	#PTE$V_VALID, R4, 10$	; Fix the 80000000 part.
10$:	RSB				; Return.
	.PAGE
	.SBTTL	EXE$MNTVERSIO
;++
; EXE$MNTVERSIO
;
; Functional description:
;
;	This routine is called to initiate an I/O to a device.  The
;	request is packed in an 'internal' IRP.  This means that the
;	PID field of the IRP contains the address of a routine to be
;	called by IOPOST to finish processing the I/O request.  Note
;	that the PID field will be set to the address of a generic
;	post-processor, which will in turn branch to the actual post
;	processing routine.
;
; Input:
;
;	R0,R1,R2,R4 are scratch registers
;	R3	= IRP address
;	R5	= UCB address
;	 (SP)	= address of action routine to post-process the I/O
;
; Output:
;
;	None.
;--

EXE$MNTVERSIO::				; Start an internal I/O request

	MOVAB	B^END_IO,IRP$L_PID(R3)	; Set I/O post address
	POPL	IRP$L_AST(R3)		; Set action routine address
					; Note that the stack is now clean.
	;
	; Begin optional I/O performance measurement.
	;
	.IF	DF	CA$_MEASURE_IOT
	JSB	G^PMS$START_RQ		; Start I/O request measurement
	.ENDC

	JMP	G^IOC$INITIATE		; Start the I/O immediately
	.PAGE
	.SBTTL	END_IO
;++
; END_IO
;
; Functional description:
;
;	This routine performs some common I/O post-processing
;	before dispatching to the specific post-processing routine,
;	whose address is stored in IRP$L_AST(R3).  This routine is
;	called by IOPOST, at IPL 4, so it is necessary to get into
;	the proper driver fork context before continuing.
;
; Input:
;
;	R5	= IRP address
;	IPL	= IPL$_POST
;
; Output:
;
;	R5	= UCB address
;	R3	= IRP address
;
;--

END_IO:					; End of I/O request
	;
	; Complete I/O performance measurement.
	;
	.IF	DF	CA$_MEASURE_IOT
	JSB	G^PMS$END_RQ		; Gather performance data
	.ENDC
	;
	MOVL	R5,R3			; Copy IRP addres
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	DSBINT	UCB$B_FIPL(R5)		; Raise IPL to driver FORK level
	JSB	@IRP$L_AST(R3)		; Dispatch to post processing routine
	ENBINT				; Restore IPL
	RSB				; Return
	.PAGE
	.SBTTL	CLEANUP_IO
;++
; CLEANUP_IO
;
; Functional description:
;
;	This routine is called to perform any necessary cleanup on the
;	I/O request that has come into the main entry point of mount
;	verification.
;
; Input:
;
;	R0,R1	= Status of the I/O operation
;	R3	= IRP address
;	R5	= UCB address
;
; Output:
;
;	All registers are preserved.
;--

CLEANUP_IO:				; Finish processing an I/O packet
	;
	; If I/O performance measurement is enabled, call the proper routine
	; to gather the performance data.  Note that the performance routine
	; assumes that IRP$L_MEDIA and IRP$L_MEDIA+4 contain the I/O status.
	; However, these longwords currently contain some information that will
	; be needed to later restart the request.  Therefore, the contents of
	; IRP$L_MEDIA and IRP$L_MEDIA+4 must be saved and later restored.
	;
	.IF	DF	CA$_MEASURE_IOT
	MOVQ	IRP$L_MEDIA(R3),-(SP)	; Save info from IRP
	MOVQ	R0,IRP$L_MEDIA(R3)	; Set I/O status
	JSB	G^PMS$END_IO		; Take performance measurement
	MOVQ	(SP)+,IRP$L_MEDIA(R3)	; Restore info to IRP
	.ENDC
	RSB				; Return
	.PAGE
	.SBTTL	DRIVER_CODE - Driver specific code
;++
; DRIVER_CODE
;
; Functional description:
;
;	This routine will call the driver specific routine that is necessary
;	to begin and end mount verification.  The address of the routine is
;	stored in the cell DDT$L_MNTVER.  If a driver does not specify the
;	contents of DDT$L_MNTVER, it defaults to the address of IOC$MNTVER.
;
; Input:
;
;	R3	= IRP address or 0
;	R5	= UCB address
;
; Output:
;
;	None.
;
; Side effects:
;
;	Driver specific, but the contents of R0,R1,R2 and R4 may be overwritten.
;--

DRIVER_CODE:				; Call driver specific code
	MOVL	UCB$L_DDT(R5),R0	; Get DDT address
	JMP	@DDT$L_MNTVER(R0)	; Branch to driver specified routine
	.PAGE
	.SBTTL	WRITLCK_HNDLR
;++
; WRITLCK_HNDLR
;
; Functional description:
;
;	This routine will allow the file system to recover from the
;	accidental hardware writelocking of a FILES-11 volume.  The
;	method used is to mark the current IRP as a mount verification
;	IRP, and try the request over again.  If the request then
;	succeeds, nothing more need be done.  If the request fails again,
;	keep trying until it succeeds.  If this is the first time this
;	request has failed (the MVIRP bit will be clear), then inform
;	all interested parties that the device has been writelocked.
;
;	Note that writelock recovery is not interlocked by the MVNVERIP
;	bit.  This will allow recovery of a device offline error to supersede
;	writelock recovery.  If this were not done, it would be possible to
;	become deadlocked by an offline error occurring after a writelock
;	error.
;
; Input:
;
;	R0,R1	= I/O status
;	R3	= IRP address
;	R5	= UCB address
;
; Output:
;
;	None.
;--

WRITLCK_HNDLR:				; Recover from accidental writelock
	TSTL	(SP)+			; Remove return address from stack
	BSBB	CLEANUP_IO		; Clean up current I/O operation
	;
	; To prevent the error log to become saturated with entries
	; due the repeated failure of this request, inhibit error logging
	; for this operation.  Note that if error logging had previously
	; been enabled, then the error log will already contain an entry
	; for this request.
	;
	BBSS	#IO$V_INHERLOG,-	; Inhibit error logging
		IRP$W_FUNC(R3),10$	;
	;
	; If mount verification is already in progress, then
	; requeue this request to the device and try again later.
	;
10$:	BBC	#UCB$V_MNTVERIP,-	; Branch if mount verification not in progress
		UCB$W_STS(R5),20$	;
	BSBB	DRIVER_CODE		; Requeue the IRP to the driver
	RSB				; Return to caller's caller
	;
	; Mark this IRP as a mount verification IRP.  If it already is,
	; then retry the I/O immediately.
	;
20$:	BBSS	#IRP$V_MVIRP,-		; Branch if already set and set the bit
		IRP$W_STS(R3),30$	;
;
; This is the first time this IRP has come through.  Inform all
; interested parties that the device has been writelocked.
;
	MOVZBL	#WRITELOCK,R4	; Set message type code
	BSBB	SEND_MESSAGE		; Send message to interested parties
;
; Try the I/O over again.
;
30$:	BSBW	TIME_DELAY		; Pause for a bit
	JMP	G^IOC$INITIATE		; Retry the I/O
	.PAGE
	.SBTTL	SEND_MESSAGE
;++
; SEND_MESSAGE
;
; Functional description:
;
;	This routine is used to inform all interested parties of a mount
;	verification related event.  A message is sent to OPCOM, which will
;	in turn send the message to all operators enabled to receive DEVICE
;	or DISK messages.
;
;	Since there is a possibility that OPCOM will not be able to relay
;	the message to the operator, also send a message that is targeted
;	explicitly at the operator's console.
;
; Input:
;
;	R4	= MV message list index for message
;	R5	= UCB address
;
; Output:
;
;	None.  Contents of R0 .. R2 are destroyed
;
;--

SAVED_R1 =	0			;.
SAVED_R2 =	4			; .
SAVED_R3 =	8			;  . Offsets to saved registers
SAVED_R4 =	12			; .
SAVED_R5 =	16			;.
DEVNAM_SIZE	= 20			; Allow 20 character device names
POOL_OVERHEAD	= 2+IRP$W_SIZE		; Allow for listhead and size fields
MSG_OVERHEAD	= POOL_OVERHEAD + DEVNAM_SIZE + <2 * CAR_CTRL_SIZE>
MSG_START	= POOL_OVERHEAD		; First usuable byte in pool

SEND_MESSAGE:				; Send message to interested parties
;
; Send message to OPCOM.
;
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	BSBW	GET_MSG_ID		; Put address of message Id in R4
	BBC	#MVMSL$V_SUPRESS, -	; Branch if MVMSL does not indicate 
		MVMSL$W_FLAGS(R4), 15$	; that this message is supressable.
	BBC	#UCB$V_SUPMVMSG, -	; Branch if UCB does not indicate that
		UCB$L_STS(R5), 17$	; normal MV messages are supressed.
	BRW	90$			; Else, supress this message.
15$:	ASSUME	UCB$V_SUPMVMSG GE 16
	BICB	#<UCB$M_SUPMVMSG@-16>, -; For must print messages, clear the
		UCB$L_STS+2(R5)		; supress mount verification msgs. bit.
17$:	MOVZWL	MVMSL$W_MSG_CODE(R4),R4	; Get the OPCOM message number.
	MOVAB	G^SYS$GL_OPRMBX,R3	; Get operator mailbox UCB address
	JSB	G^EXE$SNDEVMSG		; Mail message to OPCOM; ignore failure
;
; Send message to _OPA0:.
;
	;
	; Calculate the total message size and allocate a block
	; of nonpaged pool in which to build the message.
	; SIZE = prefix_size + message_size + suffix_size + pool_header_size + device_name_size
	;
	BSBW	GET_MSG_ID		; Get message description and id.
	MOVZBL	(R1), R1		; Setup allocation size accumulator.
	ADDB	W^PREFIX, R1		; Add prefix size to message size.
	ADDB	W^SUFFIX, R1		; Add suffix size to accumulated size.
	ADDB	#MSG_OVERHEAD, R1	; Add message overhead to acc. size.
	JSB	G^EXE$ALONONPAGED	; Allocate the necessary pool
	BLBC	R0, 90$			; If no pool available, give up.
	;
	; Build the message in the pool just allocated.
	; The entire message consists of the prefix, followed by
	; the formatted device name, followed by the message text,
	; followed by the sufix.
	;
	; R1 = actual pool size
	; R2 = address of pool
	;
	MOVW	R1,IRP$W_SIZE(R2)	; Save size of pool in the block itself
	MOVL	R2,SAVED_R2(SP)		; Save address of pool
	MOVAB	MSG_START(R2),R3	; Get address of message buffer.
	MOVW	#CAR_CTRL,(R3)+		; Insert leading <cr><lf>
	MOVAB	W^PREFIX,R1		; Get address of prefix ASCIC string
	BSBB	COPY_ASCIC		; Copy string to buffer (R5 destroyed)
	MOVL	SAVED_R5(SP),R5		; Restore R5
	MOVL	#DEVNAM_SIZE,R0		; Set device name size
	MOVL	R3,R1			; Set buffer address
	PUSHL	R4			; Save R4
	MNEGL	#1,R4			; Signal get node+devnam for remote devs
	JSB	G^IOC$CVT_DEVNAM	; Format the device name (R1 = result length)
	POPL	R4			; Restore R4
	ADDL	R1,R3			; Point to next byte in msg buffer
	BSBB	GET_MSG_ID		; R4 = address of message identifier
	BSBB	COPY_ASCIC		; Copy message text to buffer.
	BSBB	GET_MSG_ID		; Get message text descriptor
	BBS	#MVMSL$V_NOSUFFIX, -	; Branch if suffix not requested.
		MVMSL$W_FLAGS(R4), 30$
	MOVAB	W^SUFFIX,R1		; Get address of suffix ASCIC string
	BSBB	COPY_ASCIC		; Copy suffix to the buffer
30$:	MOVW	#CAR_CTRL, (R3)+	; Insert trailing <CR><LF>.
	;
	; Send the message to _OPA0:
	;
	MOVL	SAVED_R2(SP),R4		; Restore pool address
	MOVAB	MSG_START(R4),R2	; Get start of message address
	SUBL3	R2,R3,R1		; Calculate the length of the message
	MOVAB	G^OPA$UCB0,R5		; Get console terminal UCB address
	JSB	G^IOC$BROADCAST		; Send the message
	MOVL	R4,R0			; Copy pool address
	JSB	G^COM$DRVDEALMEM	; Deallocate the pool
	MOVZWL	#SS$_NORMAL,R0		; Set success status
90$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore R1 ... R5.
	RSB				; Return

;+
; This is a local subroutine to index into the message
; identifier table and return the address of the correct
; entry in R4.  Note that the stack depth has changed due
; to the return address on the stack.
;-
GET_MSG_ID:				; Return address of message identifier
	MOVL	4+SAVED_R4(SP),R4	; Get the table index number
	MOVAB	W^EXE$AB_MVMSLBAS, R1	; Get base of message info table.
	ASSUME	MVMSL$K_LENGTH EQ 8
	MOVAQ	(R1)[R4], R4		; Get address of entry for message id.
	ADDL	MVMSL$L_TEXTOFF(R4), R1	; Get base of counted string address.
	RSB				; Return


;+
; This routine is a spcial case of COPY_STRING.  On input, R1 is
; assumed to contain the address of an ASCIC string.  Execution
; drops through to COPY_STRING, and will return from there to the caller.
;-
COPY_ASCIC:				; Special case of COPY_STRING
	MOVZBL	(R1)+,R0		; Get length of string and advance the pointer

;+
; This routine is used to copy a string to a buffer.
;
; Input:
;
;	R0 = string length
;	R1 = string address
;	R3 = buffer address
;
; Output:
;
;	R3 = address of next byte in the buffer.
;	     (This is a fortuitous side-effect of the MOVC3 instruction.)
;-
COPY_STRING:				; Copy a string to a buffer
	MOVC3	R0,(R1),(R3)		; Go to it!
	RSB				; Return
	.PAGE
	.SBTTL	EXE$UPDGNERNUM - update shadow set generation number
	.SBTTL	EXE$MNTVERSHDOL - bring a shadow set member online
	.SBTTL	EXE$MNTVERSP1 - spare mount verification entry point
	.SBTTL	EXE$MNTVERSP2 - spare mount verification entry point
	.SBTTL	EXE$MNTVER_DVI_ASSIST - $GETDVI escape transfer vector
;++
; EXE$UPDGNERNUM - update shadow set generation number
; EXE$MNTVERSHDOL - bring a shadow set member online
; EXE$MNTVERSP1 - spare mount verification entry point
; EXE$MNTVERSP2 - spare mount verification entry point
; EXE$MNTVER_DVI_ASSIST - $GETDVI escape transfer vector
;
; Functional description:
;
;	These mount verification entry points do not yet have any code written 
;	for them.  There are defined here to hold their places for possibly /
;	probable implementation during the life-time of Version 4.
;--

EXE$UPDGNERNUM::
EXE$MNTVERSHDOL::
EXE$MNTVERSP1::
EXE$MNTVERSP2::

	RSB

EXE$MNTVER_DVI_ASSIST::

	JMP	(R0)

	.SBTTL	EXE$CLUTRANIO - VAXcluster State Change I/O Blocking
;++
; EXE$CLUTRANIO - VAXcluster State Change I/O Blocking
;
; Functional description:
;
;	This routine is used to place all MSCP or cluster accessible disks into
;	mount verification.  The intended use is to ensure that no I/O is
;	issued when a cluster may be out of quorum.
;
; Input:
;
;	None
;
; Output:
;
;	None.  Contents of all registers preserved.
;
;--

EXE$CLUTRANIO::
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6>
;
; First look at all local devices.
; If the UCB is not busy, it is marked busy and mount verifiction is started.
; If busy, volume valid is cleared and the mount verification pending bit is 
; set.
;
	MOVL	G^IOC$GL_DEVLIST,R6	; Start of DDB list
10$:	MOVL	DDB$L_UCB(R6),R5	; Get a UCB
	BEQL	50$			; None
	CMPB	UCB$B_DEVCLASS(R5),#DC$_DISK
	BNEQ	50$			; Not a disk
	BBC	#DEV$V_FOD,UCB$L_DEVCHAR(R5),50$ ; Not file oriented
	BBS	#DEV$V_MSCP,UCB$L_DEVCHAR2(R5),50$ ; Not interested in MSCP now
20$:	TSTL	UCB$L_VCB(R5)		; Check the VCB - consistency check only
	BEQL	40$			; Next UCB if none
	BBS	#UCB$V_MNTVERIP,UCB$W_STS(R5),40$ ; Already have it
	BBC	#DEV$V_CLU,UCB$L_DEVCHAR2(R5),40$ ; Not cluster accessible
	BBSS	#UCB$V_SUPMVMSG,UCB$L_STS(R5),25$ ; No messages
25$:	BBC	#UCB$V_BSY,UCB$W_STS(R5),30$ ; UCB not busy
	BICW	#UCB$M_VALID,UCB$W_STS(R5) ; Clear vol-valid to stop I/Os
	BISL	#<UCB$M_MNTVERIP -	; Pending when I/O completes
		 !UCB$M_MNTVERPND -	; initiate mount verification for
		 !UCB$M_CLUTRAN>, -	; for a VAXcluster state transition.
		UCB$L_STS(R5)
	BRB	40$
30$:	BISW	#UCB$M_BSY,UCB$W_STS(R5); Make UCB busy to stall I/O
	JSB	MNTVER_NOIRP		; Put it in mount verification
40$:	MOVL	UCB$L_LINK(R5),R5	; Next UCB
	BNEQ	20$			; Go look at it
50$:	MOVL	DDB$L_LINK(R6),R6	; next DDB
	BNEQ	10$			; Go look at it
;
; Now handle the MSCP disks.  It is only necessary to set the CDDB bit to 
; indicate out-of-quorum and then call the revalidate routine.
;
	MOVL	G^IOC$GL_DU_CDDB,R3	; Get start of CDDB list
	BEQL	90$			; None
70$:	BISW	#CDDB$M_QUORLOST,-	; Indicate a quorum lost request
		CDDB$W_STATUS(R3)
	PUSHR	#^M<R3,R7,R8,R9,R10,R11>
	MOVL	CDDB$L_DDB(R3),R0	; Get DDB
	MOVL	DDB$L_DDT(R0),R0	; Get DDT
	JSB	@DDT$L_UNSOLINT(R0)	; Call the revalidate routine
	POPR	#^M<R3,R7,R8,R9,R10,R11>
	BICW	#CDDB$M_QUORLOST,-	; Back to usual state
		CDDB$W_STATUS(R3)
	MOVL	CDDB$L_CDDBLINK(R3),R3	; Get next CDDB
	BNEQ	70$			; Go process it
90$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6>
	RSB


	.SBTTL	QUORUM
;++
; QUORUM
;
; Functional description:
;
;	This routine is used to determine if we are in a cluster that is
;	out of quorum.
;
; Input:
;
;	None
;
; Output:
;
;	R4  0 -> not an out of quorum cluster
;	    1 -> out of quorum cluster
;
;--

QUORUM:	CLRL	R4			; Assume no cluster
	MOVL	G^CLU$GL_CLUB,R2
	BEQL	50$			; No CLUB, so no cluster
	BBC	#CLUB$V_CLUSTER,CLUB$L_FLAGS(R2),50$ ; Not a cluster member
	BBS	#CLUB$V_QUORUM,CLUB$L_FLAGS(R2),50$ ; Not out of quorum
	MOVL	#1,R4			; Indicate no quorum
50$:	RSB


	.SBTTL	GET_VCB - Obtain VCB address
;++
;
; GET_VCB - Obtain VCB address
;
; Functional Description:
;
;	Because mount verification is used for more than just fixing mistaken 
;	hardware changes, there are several conditions in which mount 
;	verification can be entered legally without there being a  FILES-11 
;	VCB.  Such cases are:
;
;	  1. The volume being processed is mounted /FOREIGN.
;
;	  2. The volume being processed is the system disk and it has not yet 
;	     been properly mounted.
;
;	  3. The volume being processed is the quorum disk and it has not yet 
;	     been properly mounted.
;
;	This routine returns control if a VCB is present or legally absent.  
;	The condition code is NEQ if the VCB is present or EQL if it is 
;	legally absent.  Otherwise, mount verification is aborted.
;
; Inputs:
;
;	R3	MVIRP address
;	R5	UCB address
;
; Outputs:
;
;	Condition codes:
;
;	NEQ	VCB is present
;	EQL	VCB is legally absent
;
;	R0	VCB address
;
;	All other registers are preserved.
;--

GET_VCB:

	BBS	#DEV$V_FOR, -		; Branch if /FOREIGN disk.
		UCB$L_DEVCHAR(R5), 60$

	MOVL	UCB$L_VCB(R5), R0	; Get VCB address.
	BNEQ	70$			; Branch if VCB is present.

	CMPL	#SYS$GL_BOOTUCB, R5	; Is this the system disk?
	BEQL	60$			; Branch if system disk.

	MOVL	G^CLU$GL_CLUB, R0	; Get CLUB address.
	BEQL	80$			; Branch if no CLUB.
	MOVL	CLUB$L_CLUDCB(R0), R0	; Get quorum disk control block addr.
	BEQL	80$			; Branch if no CLUDCB.
	CMPL	CLUDCB$L_UCB(R0), R5	; Is this the quorum disk?
	BNEQ	80$			; Branch if not the quorum disk.

60$:	CLRL	R0			; Indicate VCB legally absent.
70$:	RSB				; Return to caller.

					; VCB not present when it should be.
80$:	TSTL	(SP)+			; Pop return address from stack.
	BRW	ERROR_EXIT		; Abort mount verification.


	.END
