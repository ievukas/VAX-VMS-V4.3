	$BEGIN	RM0JOURNL,000,RM$RMS_JOURNAL,<RMS Journaling Manager>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; Facility:	RMS-32
;
; Abstract:
;		This module provides an interface between RMS and the
;		Common Journaling Facility.
;
; Environment:
;		VAX/VMS Operating System
;
; Author:	Jeffrey W. Horn,		Creation Date:	17-Mar-1982
;
; Modified By:
;
;	V03-044	JWT0162		Jim Teague		 8-Mar-1984
;		Disable RM$RTVJNL for now.
;
;	V03-043	JWT0160		Jim Teague		29-Feb-1984
;		Remove calls to RM$DEALLEFN.
;
;	V03-042	DAS0014		David Solomon		08-Feb-1984
;		Specify ACE$M_NOPROPAGATE for RMSJNLID ACE (they should never
;		be propagated, as they are meaningful to only one file). Fix bug
;		that journal name ACEs were not being marked hidden/protected.
;
;	V03-041	DAS0013		David Solomon		21-Dec-1983
;		Support BRO access for journaling.
;
;	V03-040	JWT0141		Jim Teague		11-Nov-1983
;		Change IFB$V_RUM to IFB$V_ONLY_RU
;
;	V03-039	KPL0015		Peter Lieberwirth	27-Oct-1983
;		Fix bug introduced in V03-038.  Symptom was breaking relative
;		file extend journaling.
;
;	V03-038	KPL0014		Peter Lieberwirth	20-Oct-1983
;		If doing AI or BI recovery, avoid allocating IRAB JNLBDB
;		and buffer in CONJNL.  This is due to interactions with
;		setting IFB BIO and a recovery process being the only type
;		of process permitted to journal a file open for mixed
;		block and record access (BRO).  Symptom is an FTL$_DEALLER
;		bugcheck because a JNLBDB gets allocated and dropped when
;		another is allocated in RM$WRITE.  (Bugcheck happens on
;		close.)
;
;	V03-037	KPL0013		Peter Lieberwirth	11-Oct-1983
;		Deallocate EFNs after finishing with them.  Improper use
;		of EFNs is causing hangs in asynch situations.  Fix problem
;		with non-page aligned ALDJNLBUF allocations.
;
;	V03-036	DAS0012		David Solomon		27-Sep-1983
;		Preserve R3 in RM$WRTJNL (ISAM assumed it was preserved).
;		Corrected some comments.
;
;	V03-035	DAS0011		David Solomon		08-Sep-1983
;		Correct overzealous fix to RM$DSCJNL in V03-034. Fix test in
;		RM$MAPJNL that decides whether or not this is an open entry.
;		Return RMS$_JNF if no journal name specified, vs RMS$_NOJ.
;
;	V03-034	DAS0010		David Solomon		25-Aug-1983
;		Fix accvio when no journal name is specified. Set up R10 before
;		call to RM$RETJNLBDB (also caused an accvio). Use correct ACE
;		field name for RMS journal names. Replace source.
;
;	V03-033 LJA0090		Laurie J. Anderson	18-Aug-1983
;		1) Fix the writing of the journal entries to not stuff in
;		   the version number as VER1 but rather as the constant
;		   MAXVER so that when the versions are increased (as I 
;		   just did) the new version number is filled in.
;		2) Fill in a new (RJR version V04-000 field - for AT journals
;		   the FAB/RAB user CTX field, so that it is written to
;		   the journal for the users discretion.
;		3) Now that the FAB is available when filling in the RJR
;		   use the completion status from it, rather than just 
;		   stuff success.
;
;	V03-032	KPL0012		Peter Lieberwirth	30-Jul-1983
;		Allocate a bigger JNLBDB Buffer id AI journaling a relative
;		file.  The larger buffer will be used for the prolog if
;		the file is created.
;
;	V03-031	KPL0011		Peter Lieberwirth	24-Jul-1983
;		Fill in file-oriented AT journal record during MAPJNL
;		call.  Data from IFAB is used to fill in some create/open/close
;		AT fields.  RM$AT_JOURNAL_RECORD fills in some RJR RAB data.
;		RM$AT_COM_RAB added to fill AT record in with initial user
;		search and operation input.
;
;		Also, fix error paths and block-IO success status path in
;		RM$CONJNL.
;
;		Also, use RM$ALDJNLBUF and RM$RETJNLBDB to allocate and
;		deallocate journaling-specific BDB/Buffers.  Can't just use
;		ALDBUF etc... because then the BDB will be linked into the
;		IFABs BDB list - and could get used for file IO.  Also,
;		now the file-related AT BDB/Buffer can remain allocated for
;		the duration of the file open - previously it was deallocated
;		at common create/open exit because all BDBs on the IFAB
;		list were deallocated at that time.
;		
;		Add some commentary about RMS Journaling
;
;	V03-030	KPL0010		Peter Lieberwirth	 1-Jul-1983
;		Fix FORCE_JNL to always return status.
;
;	V03-029	KPL0009		Peter Lieberwirth	16-Jun-1983
;		Fix some bugs.  Add routine to write AT journal records for
;		record operations.  Clean up RM$MAPJNL to let it write AT
;		file operation records.  Remove COP and CQE in favor of CJF.
;		Move misc IFAB jnl flags to JNLFLG2.
;
;	V03-028 TSK0052		Tamar Krichevsky	 5-jun-1983
;		Fix bugs introduced by V03-26.  Move module to RM$RMS_JOURNAL
;		psect.  Fix broken branches to RM$MAPERR.
;
;	V03-027	KPL0008		Peter Lieberwirth	30-May-1983
;		Fix bugs introduced in V03-026 and earlier.
;
;	V03-026	KPL0007		Peter Lieberwirth	26-May-1983
;		Support new more robust RJR format.  Fix typos in KPL0001.
;		Turn on sequential file journaling.  Rework RJB/BDB allocation.
;
;	V03-025 TSK0050		Tamar Krichevsky	25-May-1983
;		Modify RM$CONJNL to allocate the proper size journal buffer
;		for sequential files.  Currently, the user specified bucket
;		size is used to determine the buffer's length.  For sequential
;		files, the buffer must be large enough to contain any one
;		record from the file.
;		Cleanup calculation of overhead for journal buffer.
;		
;	V03-024	DAS0009		David Solomon		11-May-1983
;		Fix WRTACC check in RM$ASSJNL (BBC to BBS). Add missing "#"
;		in front of two literals that were causing accvio's.  Fix
;		error path on failure to assign channel to RU journal.  Clear
;		pointer to RJB upon its deallocation.  Don't allocate IRAB
;		AT journal buffer if not AT journaling.  Fix ALLOC_MJB to
;		acquire space from same page as IFAB.  Do better job at
;		calculating required size of MJB.
;
;	V03-023	KPL0006		Peter Lieberwirth	 2-May-1983
;		Turn on $WRITEJNL call.  Add $WRMODDEF.  Fix bug on
;		error path into RM$DEAJNL.
;
;	V03-022	KPL0005		Peter Lieberwirth	 1-May-1983
;		Delete obsolete MJB definitions.
;
;	V03-021	KPL0004		Peter Lieberwirth	 1-May-1983
;		Fix another problem with $WRITEJNL call.
;
;	V03-020	KPL0003		Peter Lieberwirth	 1-May-1983
;		Fix call to $WRITEJNL.
;
;	V03-019	KPL0002		Peter Lieberwirth	30-Apr-1983
;		Add omitted macro definition.  Flesh out WRITE_MJB
;		routine.
;
;	V03-018	KPL0001		Peter Lieberwirth	29-Apr-1983
;		Allocate miscellaneous journaling buffers for IFB and IRB
;		where necessary.  Generalize cleanup so these always get
;		deallocated.  Add stub RM$WRITE_MJB routine.
;
;	V03-017	JWH0221		Jeffrey W. Horn		26-Apr-1983
;		If in recovery allow BRO access.  Also temporarily, enable 
;		both AI and BI journaling durring recovery.
;
;	V03-016	JWH0205		Jeffrey W. Horn		11-Apr-1983
;		Implement journal id ACE.  Also add protected and hidden
;		bits to all ACEs.
;
;	V03-015	DAS0008		David Solomon		01-Apr-1983
;		Save R2 in RM$WRTJNL (for ISAM).
;
;	V03-014	RAS0135		Ron Schaefer		17-Mar-1983
;		More corrections to RAS0132 for registers and RJR$_ names.
;
;	V03-013	RAS0135		Ron Schaefer		17-Mar-1983
;		Corrections to RAS0132 for registers and RJR$_ names.
;
;	V03-012	RAS0132		Ron Schaefer		16-Mar-1983
;		Merge $RMSRDEF into $RJRDEF and revise the interface
;		for RM$WRTJNL for easier use from ISAM.
;
;	V03-011	JWH0185		Jeffrey W. Horn		11-Feb-1983
;		Set WRFLG$V_BI on RU journal entries.
;		Use the perm FWA to provide journal entry security and
;		to fill in the mapping entries.
;		If file is opened UFO then disable journaling for this open.
;
;	V03-010	JWH0180		Jeffrey W. Horn		03-Feb-1983
;		Change references to RJR$C_MAPLEN from byte to word.
;
;	V03-009	JWH0173		Jeffrey W. Horn		24-Jan-1983
;		Clean up status code returns.
;		Use BKS instead of MRS to allocate journal BDB.
;		Allow ISAM journaling.
;
;	V03-008	JWH0167		Jeffrey W. Horn		10-Jan-1983
;		Implement IFB recovery option byte.
;		Fill in file organization in mapping entry.
;
;	V03-007	JWH0155		Jeffrey W. Horn		 3-Dec-1982
;		Seperate journal names into three seperate ACEs.
;		Prevent journaling on Sequential and Indexed files.
;		For block io, do not create journal BDB and buffer.
;
;	V03-006	JWH0154		Jeffrey W. Horn		13-Dec-1982
;		Define ACE$C_JNLNAMS (temporary).
;
;	V03-005	JWH0132		Jeffrey W. Horn		22-Nov-1982
;		Write journal entries with the WRFLG$M_LOCK attribute.
;
;	V03-004	JWH0128		Jeffrey W. Horn		15-Nov-1982
;		Change SS$_NOCJF code to SS$_IVSSRQ.
;
;	V03-003	JWH0116		Jeffrey W. Horn		28-Oct-1982
;		If in RCP then don't perfom any journaling execpt AT.
;		Remove CALLS to CJF services and replace with macros.
;		Change logic in FRCJNL which checks for an active RU to
;		reflect changes in RUF.
;
;	V03-002	JWH0108		Jeffrey W. Horn		23-Sep-1982
;		Remove redefinitions of ACL ACP attributes.
;		Fix problem with setting size for RJB deallocation.
;		Clean up status code returns.
;		Redefine journal names (FWA$T_xxJNLN) as .ASCIC
;		strings.
;		Implement new RMS journaling record (RJR).
;		Use RM$GETBLK and RM$RETBLK instead of RM$GETSPC and
;		RM$RETSPC when allocating and deallocting the RJB.
;
;	V03-001	JWH0107		Jeffrey W. Horn		23-Sep-1982
;		Redefine ACL ACP attributes to ATR$C_USERLABEL which is a
;		no-op.  Add a .WEAK for CJF$GETJNL.  Clean up status code
;		returns.
;
;--

	.SBTTL	DECLARATIONS


;
; Include FIles:
;

;
; Macros:
;

	$ACEDEF
	$ATRDEF
	$BDBDEF
	$CJFDEF
	$DVIDEF
	$FABDEF
	$RABDEF
	$FIBDEF
	$FWADEF
	$IFBDEF
	$IODEF
	$IMPDEF
	$IRBDEF
	$PCBDEF
	$PSLDEF
	$RJBDEF
	$RJRDEF
	$RMSDEF
	$RUCBDEF
	$SSDEF
	$STSDEF
	$WRFLGDEF
	$MJBDEF
	$WRMODDEF

;
; Equated Symbols:
;

;
; Own Storage:
;

FACILITY:	.WORD	RMS$_FACILITY
MODE:		.WORD	PSL$C_EXEC

	.SUBTITLE Introduction to RMS Journaling
;++
;	RMS Journaling Manager
;
; This module contains routines used to journal RMS operations.  Other modules
; containing journaling routines (not necessarily an inclusive list) are: 
;
;	RM3JOURNL.B32, RM1JOURNL.MAR, RM0CRECOM.MAR, RM0BUFMGR.MAR,
;	RM0EXTEND.MAR, and RM2CREATE.MAR
;
; The data structures are defined in:
;
;	RMSINTSTR.MDL and the format of the RMS Journaling Record (RJR) is
; described in RMSFILSTR.SDL.
;
; The general flow of journaling control is as follows:
;
; 1. When a file marked for journaling is accessed, connections are made
;    to the journals specified in the file's header in RM$ASSJNL.  Certain
;    data structures are allocated at this time also.
;
; 1a. If the file is being created, the data structures are allocated earlier,
;    and the JNLXAB is interrogated for journal names.  If no journal names
;    are specified in the XAB, CJF is asked for default journal names.  This
;    is done in RM$GETJNL.
;
; 2. RM$MAPJNL is called to write entries to the journals at OPEN/CREATE/CLOSE
;    time.  These entries contain the full filename and other information.
;    These entries are used when the journal must be interrogated for file
;    names, and to associate a filename with a journal ID.
;
;	A journal ID is a unique identifier associated with a journaled file
;	(it is kept in the file header in a hidden, protected, access control
;	entry).  It is used in most RMS journaling records so that the full
;	filename need not be kept in all entries.  It is also used as a
;	short-hand identifier to search a journal for RMS entries without
;	having to fully specify the filename as originally journaled.
;
;
; 3. RM$CONJNL is called at connect time to allocate record-oriented RMS
;    journaling structures.  These include buffers and buffer descriptors.
;    These structures are deallocated at disconnect time in RM$DSCJNL.
;    RM$DSCJNL also forces to the journal any audit-trail journal entries
;    written to CJF but not yet necessarily forced to the actual journal
;    (IE the entries may still be in a CJF buffer.)
;
; 4. During the course of RMS record operations journal entries describing
;    file accesses and modifications are written to the appropriate journals.
;
;	ISAM AI and BI operations are journaled by writing copies of the
;	modified buckets to the journal.  The buffers used for these entries
;	are as follows:
;
;		AI - the buffer used is the actual data bucket that is written
;		     to the file
;
;		BI - the buffer used is an extra one allocated at the same time
;		     the data buffer is allocated
;
;		Both buffers are pointed to by the BDB.
;
;	ISAM AI and BI operations are journaled at the bucket-level because
;	there was no way found to journal on a record basis and ensure that
;	RFAs would be restored upon recovery.
;
;	ISAM recovery unit operations are journaled by writing information
;	describing the modified record to the journal.  The ISAM code treats
;	record operations in recovery units in a special fashion:
;
;		$DELETEs do not delete the record - the record is merely
;		marked for deletion.
;
;		$UPDATEs never shrink the size of the record - extra space
;		corresponding to the original size of the record is kept
;		and described by special fields in the record itself.
;
;		The reason for never deleting space in ISAM RUs is to ensure
;		there will always be space in the bucket if the record
;		must be rolled back in.  We don't want to invent more
;		special case ISAM bucket split code.  The RFA basis of the
;		journal entry also precludes too much bucket entropy before
;		recovery.
;
;	Sequential and Relative file journaling is done on a record basis.
;	A record journaling buffer is allocated at CONNECT time, and this
;	buffer is used to build the record used to describe the change needed
;	to undo or redo the operation.
;
;	Audit-trail journaling is done on a file and record level.  A special
;	BDB and Buffer is allocated off the IFAB to contain file related
;	audit-trail information.  A journaling buffer descriptor/buffer
;	is allocated off the IRAB to collect and format record-related
;	audit trail information.
;
;	In order to ensure ISAM AI recovery, $EXTENDs must be journaled.
;	A special extend buffer descriptor/buffer is allocated off the
;	IFAB - the journaling record to describe the extend is built in
;	and written from this buffer.  Sequential and Relative AI extends
;	are journaled in the same fashion.
;
; 5. RMS Journaling Data Structures
;
;	RJB	- The RJB is allocated by ASSJNL or CRECOM, and contains
;		the channels assigned to various journals.  Flags indicating
;		connections to journals are also present.
;
;	IFB JNLFLG - This byte is a copy of the file header byte which
;		indiates what types of journaling the file is marked for.
;
;	IFB JNLFLG2 - This byte contains miscellaneous run-time IFAB related
;		journaling indicators.
;
;	IFB$L_JNLBDB - This field points to a BDB and buffer that is used for
;		file related AT journaling.
;
;	IFB$L_ATJNLBUF - This field points into the buffer pointed to indirectly
;		by IFB$L_JNLBDB.  This field points directly to the RJR within
;		the buffer.
;
;	RJR - RMS Journaling Record.  The format of the RMS data written to
;		the journal.  It is comprised of a common overhead, and several
;		different formats following the common overhead that are used
;		for different journaling functions.
;
;		Currently implemented:  FILE, RECORD, BLOCK, BUCKET, EXTEND,
;		AT_RECORD.
;
;	MJB - Miscellaneous Journaling Block  This is used to describe
;		miscellaneous journaling records and the information needed
;		to describe the WRITEJNL request.  The MJB is written by
;		RM$WRITE_MJB and is forced to the journal by RM$FORCE_MJB.
;
;		MJBs are currently used for AT and Extend entries.
;
;	IRB$L_ATJNLBUF - points to an MJB/Buffer used to write record level AT
;		entries.
;
;	Why MJBs and BDBs?  Good question.  The BDB related design is good for
;	writing buffers containing actual file data to the journals.  The
;	MJB is used when descriptive entries not directly related to file
;	data are written.  BDB/Buffer fits into the IO system concept and
;	ISAM AI and BI benefits from the overlap.  MJB/Buffer fits into
;	the CJF design better.  The MJB describes the WRITEJNL inputs,
;	basically.  The only counter-intuitive setup currently is writing
;	file-level descriptive entries via BDB and not MJB.  The reason for this
;	is that MAPJNL was originally set up this way.
;
;--

	.SBTTL	RM$GETJNL - Get Journal Name

;++
; RM$GETJNL - Get Journal Name
;
; 	This subroutines gets the journal names to use from either CJF
;	or the process-based default journal names.  It then proceeds to
;	set up the attributes for the file creation.
;
;
; Calling sequence:
;
;	BSBW	RM$GETJNL
;
; Input Parameters:
;
;	R9	-	IFAB address
;	R10	-	FWA address
;
; Implicit Inputs:
;
;	IFB$B_JNLFLG -	File's Journaling Flags
;	FWA$L_UIC    -	File's Owner UIC
;	FWA$Q_xxJNL, FWA$T_xxJNLN - may be preset by XAB processing to contain
;				   some journal names.
;
; Output Parameters:
;
;	R1-R4		Destroyed
;
; Implicit Outputs:
;
;	FWA$Q_xxJNL, FWA$Q_xxJNLN - Set to journal name(s).
;
; Completion Codes:
;
;	JNF - If no journal name found for a particular IFB$B_JNLFLG bit,
;		STV will contain CJF status from $GETJNL.
;
; Side Effects:
;	None.
;
;--

RM$GETJNL::
	MOVL	#1,-(SP)				; anticipate success
	BBC	#IFB$V_BI,IFB$B_JNLFLG(R9),10$		; branch if no BI bit
	MOVAB	FWA$Q_BIJNL(R10),R2			; fwa bi descr
	MOVAB	FWA$T_BIACE(R10),R3			; fwa bi buffer
	MOVL	#CJF$_BI,R4				; journal type code
	BSBW	GET_JNL					; get journal name
	BLBS	R0,10$					; get out on error
	MOVL	R0,(SP)					; remember error code

10$:	BBC	#IFB$V_AI,IFB$B_JNLFLG(R9),20$		; branch if no AI bit
	MOVAB	FWA$Q_AIJNL(R10),R2			; fwa AI descr
	MOVAB	FWA$T_AIACE(R10),R3			; fwa AI buffer
	MOVL	#CJF$_AI,R4				; journal type code
	BSBW	GET_JNL					; get journal name
	BLBS	R0,20$					; get out on error
	MOVL	R0,(SP)					; remember error code

20$:	BBC	#IFB$V_AT,IFB$B_JNLFLG(R9),30$		; branch if no AT bit
	MOVAB	FWA$Q_ATJNL(R10),R2			; fwa AT descr
	MOVAB	FWA$T_ATACE(R10),R3			; fwa AT buffer
	MOVL	#CJF$_AT,R4				; journal type code
	BSBW	GET_JNL					; get journal name
	BLBS	R0,30$					; continue on success
	MOVL	R0,(SP)					; remember error code

30$:	MOVL	<FWA$T_FIBBUF+FIB$W_FID>(R10),FWA$T_FID(R10) ; put fid in id ace
	MOVW	<FWA$T_FIBBUF+FIB$W_FID+4>(R10),<FWA$T_FID+4>(R10)
	$GETTIM_S TIMADR=FWA$Q_ID_DATE(R10)		; get current time
	MOVL	#<<<ACE$M_PROTECTED + ACE$M_HIDDEN + ACE$M_NOPROPAGATE> -
		@ <ACE$W_FLAGS*8>> + -
		  <ACE$C_JNLID @ <ACE$B_TYPE*8>> + -
		  FWA$S_IDACE>, FWA$T_IDACE(R10)
	MOVW	#FWA$S_IDACE,(R5)+			; set attribute len
	MOVW	#ATR$C_ADDACLENT,(R5)+			; set attribute type
	MOVAL	FWA$T_IDACE(R10),(R5)+			; set attribute address
	RMSSUC

50$:	MOVL	(SP)+,R0				; get status code
	BLBC	R0,60$					; skip if error
	RSB

60$:	CLRB	IFB$B_JNLFLG(R9)			; turn off journaling
	RMSERR	JNF,R1					; journal not found
	JMP	RM$MAPERR				; go map the error and return

	.SBTTL	GET_JNL - Common Get Journal name routine

;++
; GET_JNL - Common Get Journal name routine
;
; If XAB processing did not get a particular journal name, then ask
; CJF for one.
;
; Calling sequence:
;
;	BSBW	GET_JNL
;
; Input Parameters:
;
;	R2	-	Pointer to FWA$Q_xxJNL	(fwa journal name descriptor)
;	R3	-	Pointer to FWA$T_xxJNLN (fwa journal name buffer)
;	R4	-	CJF$_xx for the journal type
;	R5	-	Address of first free slot at end of ACP attribute list
;
; Implicit Inputs:
;
;	FWA$L_UIC	File Ownership UIC.
;	FWA$Q_DEVICE	Descriptor of Device name
;	FWA$L_ATR_LIST	Atribute list for create
;
; Output Parameters:
;	R5		New free ACP attribute list free slot.
;
; Implicit Outputs:
;
;	FWA$Q_xxJNL, FWA$T_xxJNLN - filled in
;	FWA$T_ATR_LIST - May have journal name attributes added.
;
; Completion Codes:
;	Any CJF from $GETJNL.
;
; Side Effects:
;	None.
;--

GET_JNL:

;
; If no journal name from XAB processing, ask CJF for one
;
	MOVL	#1,-(SP)				; assume success
	TSTB	(R2)					; name length zero?
	BNEQ	20$					; no branch
	MOVZWL	#FWA$S_BIJNLN,(R2)			; set up descriptor
	MOVAL	ACE$T_RMSJNLNAM(R3),4(R2)
	TSTL	FWA$L_UIC(R10)				; file uic specified?
	BNEQ	10$					; branch if so
	MOVL	@#CTL$GL_PCB,R1				; get PCB address
	MOVL	PCB$L_UIC(R1),FWA$L_UIC(R10)		; get UIC from PCB

10$:	$GETJNL_S	-				; call CJF
   		DEVNAM = FWA$Q_DEVICE(R10), -
		UIC    = FWA$L_UIC(R10), -
		JNLTYP = R4, -
		JNLNAM = (R2), -
		RSLLEN = (R2)

	MOVL	R0,(SP)					; save return code

;
; Construct ACE to store journal name and add to attribute list
;
	ASSUME 	ACE$C_BIJNL EQ CJF$_BI
	ASSUME	ACE$C_AIJNL EQ <ACE$C_BIJNL + 1>
	ASSUME	ACE$C_ATJNL EQ <ACE$C_AIJNL + 1>

20$:	ADDB3	#ACE$T_RMSJNLNAM,(R2),(R3)		; fill in ACE size
	MOVB	R4,ACE$B_TYPE(R3)			; move type into ACE
	MOVW	#ACE$M_HIDDEN!ACE$M_PROTECTED,-		; move flags into ACE
		ACE$W_FLAGS(R3)
	MOVZBW	(R3),(R5)+				; move atr len into list
	MOVW	#ATR$C_ADDACLENT,(R5)+			; move atr type into list
	MOVL	R3,(R5)+				; move atr addr into list
	MOVL	(SP)+,R0				; restore code
	RSB

	.SBTTL	RM$RTVJNL - Retrieve Journaling Info
;++
; RM$RTVJNL - Retrieve Journaling Info
;
;	This subroutine adds the neccessary ACP attributes to retrieve
;	both the journal selection bits and the journal names used for a file.
;
; Calling Sequence:
;
;	BSBW	RM$RTVJNL
;
; Input Parameters
;	R5	Address of End of attribute list
;	R9	IFAB address
;	R10	FWA Address
;	R11	Impure Area Address
;
; Implicit Imputs:
;	None.
;
; Ouput Parameters:
;
;	R1	Destroyed
;	R5	Updated to new end of attribute list
;
; Implicit Outputs:
;
;	FWA ACP attribute list has attributes filled in to retrieve journaling
;	bits and journal names.
;
; Completion Codes:
;	None.
;
; Side Effects:
;	None.
;
;--

RM$RTVJNL::

;**JNL** begin temporary code to tie off journaling
	RSB
;**JNL** end temporary code to tie off journaling

;
; Construct ACEs to get journal names and add ACP attribute
;
	MOVAL	FWA$T_BIACE(R10),R1			; get start of ACE
	MOVW	#<<ACE$C_BIJNL@<ACE$B_TYPE*8>>+FWA$S_BIACE>,(R1) ; move in ACE Type, Len
	MOVW	#FWA$S_BIACE,(R5)+			; move atr len into list
	MOVW	#ATR$C_FNDACLTYP,(R5)+			; move atr type into list
	MOVL	R1,(R5)+				; move atr addr into list

	MOVAL	FWA$T_AIACE(R10),R1			; get start of ACE
	MOVW	#<<ACE$C_AIJNL@<ACE$B_TYPE*8>>+FWA$S_AIACE>,(R1) ; move in ACE Type, Len
	MOVW	#FWA$S_AIACE,(R5)+			; move atr len into list
	MOVW	#ATR$C_FNDACLTYP,(R5)+			; move atr type into list
	MOVL	R1,(R5)+				; move atr addr into list
	
	MOVAL	FWA$T_ATACE(R10),R1			; get start of ACE
	MOVW	#<<ACE$C_ATJNL@<ACE$B_TYPE*8>>+FWA$S_ATACE>,(R1) ; move in ACE Type, Len
	MOVW	#FWA$S_ATACE,(R5)+			; move atr len into list
	MOVW	#ATR$C_FNDACLTYP,(R5)+			; move atr type into list
	MOVL	R1,(R5)+				; move atr addr into list

	MOVAL	FWA$T_IDACE(R10),R1			; get start of ACE
	MOVL	#<<ACE$C_JNLID@<ACE$B_TYPE*8>>+FWA$S_IDACE>,(R1) ; set up ACE
	MOVW	#FWA$S_IDACE,(R5)+			; move atr len into list
	MOVW	#ATR$C_FNDACLTYP,(R5)+			; move atr type into list
	MOVL	R1,(R5)+				; move atr addr into list

;
; Add journal control bit attributes to list
;
	MOVW	#1,(R5)+				; move atr len into list
	MOVW	#ATR$C_JOURNAL,(R5)+			; move atr type into list
	MOVAB	IFB$B_JNLFLG(R9),(R5)+			; move atr addr into list

;
; Make sure we have the file's UIC in the FWA
;
	MOVW	#4,(R5)+				; move atr len into list
	MOVW	#ATR$C_UIC_RO,(R5)+			; move atr type into list
	MOVAL	FWA$L_UIC(R10),(R5)+			; move atr addr into list

	RSB

	.SBTTL	RM$ASSJNL - Open Journaling for a file

;++
; RM$ASSJNL - Open Journaling for a file
;
; 	This subroutine builds the necessary data structures for journaling
;	onto the IFAB and opens the journals needed for the file.
;
; Calling sequence:
;
;	BSBW	RM$ASSJNL
;
; Input Parameters:
;
;	R8	FAB Address
;	R9	IFAB Address
;	R10	FWA Address
;	R11	Impure Area Address
;
; Implicit Inputs:
;
;	IFB$B_JNLFLG
;
; Output Parameters:
;
;	R1 - R5	Destroyed
;
; Implicit Outputs:
;
;	IFB$L_RJB	Address of allocated and initialized RJB
;	IFB$B_JNLFLG2	Files Journaling Flags:
;		IFB$V_JNL	Set to indicate journaling initialized for this
;				file.
;
; Completion Codes:
;
;	Any RMS, particularly, DME.
;	NOJ, Journal device for file not available, CJF status in
;		STV from $ASSJNL.
;	JNS, Journaling not supported for operation
;
; Side Effects:
;	None.
;
;--

ERRJNS:	RMSERR	JNS
	RSB

UFO:	CLRB	IFB$B_JNLFLG(R9)			; turn off journaling
ASS_DONE:
	RMSSUC
	RSB

RM$ASSJNL::
	BBSS	#IFB$V_DONE_ASS_JNL,IFB$B_JNLFLG2(R9),ASS_DONE ; already thru
							; here during $CREATE.
	BBS	#FAB$V_UFO,FAB$L_FOP(R8),UFO		; branch if UFO
	BBC	#IFB$V_BIO,IFB$B_FAC(R9),10$		; branch if not BIO
	BITB	#<IFB$M_RU!IFB$M_ONLY_RU>,IFB$B_JNLFLG(R9)	; don't allow RU BIO
	BNEQ	ERRJNS

;
; Next, if the process in which we're executing is a RECOVERY process we
; may not want to journal.  Specifically, if the file we're starting to
; access is one RMS Recovery is recovering, we don't want to
;
;	a. recovery unit journal
;	b. AI or BI journal if we're doing AI recovery
;
; Note: BI recovery must be journaled.  If BI recovery is not journaled,
; the file can be in states never represented by any state representable
; by the RMS journal entries in the journal.  This can happen when a file
; is BI journaled, modified, rolled-back, modified again, and later rolled
; back to a time when first modified.  This is because 'old' record images
; are put in BI journals.  Therefore, a record may get put in the file that
; never shows up in the journal.  Therefore if its backed out by Recovery,
; and recovery is not journaled - that record will never be seen again.
; This problem does not occur with AI journaling because the journal contains
; 'new' record images.
;

10$:	MOVL	@#CTL$GL_PCB,R1				; get PCB address for test
	BBC	#PCB$V_RECOVER,PCB$L_STS(R1),20$	; skip rest if not
							;  in RECOVER
	TSTB	IFB$B_RECVRFLGS(R9)			; may be in RECOVER, but
							;  not recovering this
							;  file
	BEQL	20$					; branch if not in recovery

	BICB	#<IFB$M_RU!IFB$M_ONLY_RU>,IFB$B_JNLFLG(R9)	; clear RU journaling
	BBC	#IFB$V_AI_RECVR,IFB$B_RECVRFLGS(R9),20$	; skip next if not AI
	BICB	#<IFB$M_AI!IFB$M_BI>,IFB$B_JNLFLG(R9)	; clear AI, BI if AI

20$:	BBS	#IFB$V_WRTACC,(R9),50$			; branch if writing
	BICB	#<IFB$M_AI!IFB$M_BI!IFB$M_RU!IFB$M_ONLY_RU>,IFB$B_JNLFLG(R9)
							; clear AI,BI,RU
	BRB	3000$					; branch to AT test.

50$:							;
60$:	BBC	#IFB$V_ONLY_RU,IFB$B_JNLFLG(R9),1000$	; branch if ONLY_RU
	SSB	#IFB$V_RU,IFB$B_JNLFLG(R9)		; set RU bit

1000$:	BBC	#IFB$V_BI,IFB$B_JNLFLG(R9),2000$	; branch if no BI
	MOVAQ	FWA$Q_BIJNL(R10),R3			; BI descriptor
	MOVAB	FWA$T_BIACE(R10),R4			; BI name
	MOVL	#CJF$_BI,R5				; indicate BI
	BSBW	OPEN_JNL				; go open channel
	BLBC	R0,5000$				; get out on error

2000$:	BBC	#IFB$V_AI,IFB$B_JNLFLG(R9),3000$	; branch if no AI
	MOVZWL	#<MJB$C_BLN+RJR$C_EXTLEN>,R2		; size of MJB for extend
	JSB	RM$ALLOC_MJB				; get the MJB
	BLBC	R0,5000$				; get out on error
	MOVL	R1,IFB$L_EXTJNLBUF(R9)			; set up pointer
	MOVAQ	FWA$Q_AIJNL(R10),R3			; AI descriptor
	MOVAB	FWA$T_AIACE(R10),R4			; AI name
	MOVL	#CJF$_AI,R5				; indicate AI
	BSBW	OPEN_JNL				; go open channel
	BLBC	R0,5000$				; get out on error

3000$:	BBC	#IFB$V_AT,IFB$B_JNLFLG(R9),4000$	; branch if no AT
	MOVAQ	FWA$Q_ATJNL(R10),R3			; AT descriptor
	MOVAB	FWA$T_ATACE(R10),R4			; AT name
	MOVL	#CJF$_AT,R5				; indicate AT
	BSBW	OPEN_JNL				; go open channel
	BLBC	R0,5000$				; get out on error

4000$:	BBC	#IFB$V_RU,IFB$B_JNLFLG(R9),6000$	; branch if no RU
	MOVL	#CJF$_RU,R5				; indicate RU
	BSBW	OPEN_JNL				; go open channel
	BLBC	R0,5000$				; return on success
	MOVL	@#CTL$GL_RUF,R1				; already in RU?
	BEQL	6000$					; branch if not
	BBC	#RUCB$V_ACTIVE,RUCB$B_CTRL(R1),7000$
	BBCS	#IFB$V_RUP,IFB$B_JNLFLG2(R9),7000$	; set RU in prog
							; NOTE: Should never
							; fall through

5000$:	CLRB	IFB$B_JNLFLG(R9)			; on error clr flgs
	EXTZV	#STS$V_FAC_NO,#STS$S_FAC_NO,R0,R1	; get error facility
	CMPL	#RMS$_FACILITY,R1			; is error from RMS?
	BEQL	7000$					; don't map if so
	MOVL	R0,R2					; save CJF status
	JSB	RM$MAPERR				; fill in STV
	CMPL	#CJF$_NONAME,R2				; was error no jnl name?
	BNEQ	5010$					; no, use NOJ error
	RMSERR	JNF					; yes, use JNF error
	BRB	5020$					;  and continue
5010$:	RMSERR	NOJ					; use NOJ error
5020$:	RSB						; return

6000$:	RMSSUC						; yes, indicate success

7000$:	RSB

	.SBTTL	OPEN_JNL - Common open journal channel

;++
; OPEN_JNL - Common open journal channel
;
; This routine opens a channel on the specified journal.  It also alocates
; an RJB if needed.
;
; Calling sequence:
;
;	BSBW	OPEN_JNL
;
; Input Parameters:
;
;	R3	Address of Journal Name Descriptor (FWA$Q_xxJNL) (AI,BI,AT only)
;	R4	Address of Journal Name ACE (FWA$T_xxACE) (AI,BI,AT only)
;	R5	Journal Type (CJF$_xx)
;	R9	IFAB address
;	R10	FWA address
;	R11	Impure area address
;
; Implicit Inputs:
;
;	IFB$L_RJB	RJB address
;	IFB$B_JNLFLG	File's journaling flags
;	FWA$Q_DEVICE	Device File resides on.
;	FWA$Q_xxJNL, FWA$T_xxJNLN
;			Journal Names for file
;	FWA$L_UIC	File Owner
;	FWA$L_PRO	File Protection
;
; Output Parameters:
;
;	R1-R5		Destroyed
;
; Implicit Outputs:
;
;	IFB$L_RJB	Address of allocated RJB
;	IFB$B_JNLFLG2	Files Journaling flags
;		IFB$V_JNL	Set to indicate journaling initialized.
;	RJB$W_FLAGS	A bit is set for each channel opened.
;	RJB$Q_CHAN	One word is filled in with a channel number.
;
; Completion Codes:
;
;	Any RMS, particualrly, DME,
;	Any CJF status value from $ASSJNL.
;
;
; Side Effects:
;
;	If journaling not previosly initialized on this file, allocates an RJB
;	for it.
;
;--

OPEN_JNL:
	BSBW	RM$ALLOC_RJB_BDB		; get journaling BDB/Buffer
	BLBS	R0,10$				; continue if success
	BRW	50$				; out on error
10$:	MOVL	IFB$L_RJB(R9),R2		; get RJB address
	CMPL	R5,#CJF$_RU			; Opening RU?
	BEQL	20$				; yes, branch
	CLRL	(R3)				; set up descriptor
	SUBB3	#ACE$T_RMSJNLNAM,(R4),(R3)	; get length of journal name
	BGTR	15$				; length is >0
	MOVL	#CJF$_NONAME,R0			; journal not specified
	BRB	40$				; error exit
15$:	MOVAL	ACE$T_RMSJNLNAM(R4),4(R3)	; fill in address of string

	$ASSJNL_S	-			; assign journal chan
		CHAN = RJB$Q_CHAN-2(R2)[R5], -
		JNLTYP = R5, -
		JNLNAM = (R3), -
		ACMODE = MODE, -
		PROT   = FWA$W_PRO(R10), -
		OBJUIC = FWA$L_UIC(R10), -
		FACCOD = FACILITY

	BRB	30$

20$:	$ASSJNL_S	-			; open RU chan
		CHAN = RJB$Q_CHAN(R2), -
		JNLTYP = R5, -
		DEVNAM = FWA$Q_DEVICE(R10), -
		ACMODE = MODE, -
		PROT   = FWA$W_PRO(R10), -
		OBJUIC = FWA$L_UIC(R10), -
		FACCOD = FACILITY

30$:	BLBC	R0,40$				; return on error

	DECL	R5				; one less than type
	SSB	R5,RJB$W_FLAGS(R2)		; turn on bit for chan
	RSB					; return to caller

;
; Error Exit
;
40$:	PUSHR	#^M<R0>				; save R0
	JSB	RM$DEAJNL			; deallocate RJB
	POPR	#^M<R0>				; restore R0

50$:	RSB

	.SBTTL	RM$CONJNL - Connect Journal BDB

;++
; RM$CONJNL - Connect Journal BDB
;
; This routine, called from $CONNECT, builds the necessary data
; structures onto the IRAB for journaling record processing
; operations
;
; Calling sequence:
;
;	BSBW	RM$CONJNL
;
; Input Parameters:
;
;	R9	Address of IRAB
;	R10	Address of IFAB
;	R11	Address of Impure area
;
; Implicit Inputs:
;
;	None.
;
; Output Parameters:
;
;	R1 - R3,R5	Destroyed
;	R4		Address of BDB for journaling I/O.
;
; Implicit Outputs:
;
;	IRB$L_JNLBDB	Address of BDB for journaling I/O.
;
; Completion Codes:
;	Any valid RMS, particualarly DME.
;
; Side Effects:
;	A buffer and BDB are allocated, the BDB is marked perm.
;
;--

RM$CONJNL::

;
; Determine whether or not we need to allocate a journal BDB and buffer. We
; only need one if connecting for record access. For block I/O access, simply
; exit (the journal BDB and buffer will be allocated on the first $WRITE).
;

	BBS	#IFB$V_BIO,-		; if we're open for BIO, exit
		IFB$B_FAC(R10),10$	;
	BBC	#IFB$V_BRO,-		; if not opening BRO, we're ok
		IFB$B_FAC(R10),20$	;  (must be open for record access)
	BBC	#RAB$V_BIO,-		; if connecting for record access,
		RAB$L_ROP(R8),20$	;  we're ok
10$:	BRW	80$			; exit

;
; If the file is sequential, determine the largest probable record size to be
; journaled.  A record can be no larger than the maximum record length.  If 
; the MRS was not given, then look at the the longest record length or the
; multiblock count.  If none of these values were specified, then punt.
;

	ASSUME	IFB$C_SEQ EQ 0

20$:	TSTB	IFB$B_ORGCASE(R10)			; is the file sequential?
	BNEQ	50$					; no, use BKS for buffer length

	MOVZWL	IFB$W_MRS(R10),R5			; use the max rec. size
	BNEQ	60$					; use it if present

	MOVZWL  IFB$W_LRL(R10),R5			; use the LRL for the buffer size
	BNEQ	60$					; finish buffer size calulation

	MOVZBL	RAB$B_MBC(R8),R5			; use the MBC for buffer length
	BEQL    30$					; no, buffer will be 1 page
	BLSS	ERRMBC					; MBC must be > 0
	BRB	55$

30$:	MOVZWL  #512,R5					; buff. will be 1 page
    	BRB	60$

;
; file is not sequential.  Use the bucket size as the buffer length.
;

50$:	MOVZBL	IFB$B_BKS(R10),R5			; get bucket size
55$:	ASHL	#9,R5,R5				; convert to bytes

60$:	ADDL2	#RJR$C_RECLEN, R5			; give some overhead
	ADDL2	#511,R5					; round up to a
	BICL2	#511,R5					; page boundary

	JSB	RM$ALDJNLBUF				; get BDB and buffer
	BLBC	R0,90$					; get out on error
	PUSHR	#^M<R1,R2,R3,R4,R5>			; save regs zeroed by MOVC5
	MOVL	BDB$L_ADDR(R4),R1			; get RJR address
	MOVC5	#0,(R1),#0,#RJR$C_HDRLEN,(R1)		; zero the RJR overhead
	POPR	#^M<R1,R2,R3,R4,R5>			; restore regs zeroed by MOVC5
	MOVL	R4,IRB$L_JNLBDB(R9)			; save BDB addr

	ASSUME	RJR$C_EXTLEN	GT	RJR$C_BLKLEN
	ASSUME	RJR$C_EXTLEN	GT	RJR$C_AT_RECLEN 

	BBC	#IFB$V_AT,IFB$B_JNLFLG(R10),80$		; skip if not AT
	MOVZWL	#<MJB$C_BLN+RJR$C_EXTLEN>,R2		; length of structure
	CMPB	IFB$B_ORGCASE(R10),#IFB$C_IDX		; indexed file?
	BNEQ	70$					; if NEQ no
	ADDL	#256,R2					; add in max key size
70$:	BSBW	RM$ALLOC_MJB				; allocate MJB
	BLBC	R0,90$					; branch if error
	MOVL	R1,IRB$L_ATJNLBUF(R9)			; init pointer
80$:	RMSSUC						; indicate success	
90$:	RSB	

ERRMBC:
	RMSERR	MBC
    	RSB

	.SBTTL	RM$MAPJNL - Write Mapping Entry

;++
; RM$MAPJNL - Write Mapping Entry
; RM$MAPJNL_RU - Write RU Mapping Entry
;
; This routine writes a mapping entry into all currently open
; journals for a particular file
;
; Calling sequence:
;
;	BSBW	RM$MAPJNL
;	BSBW	RM$MAPJNL_RU
;
; Input Parameters:
;
;	R8	FAB address (used by COMMON_FILE_AT to write CTX field into RJR)
;	R9	IFAB address
;	R11	Impure area address
;	AP	r0 status till now (I know its a hack, but..) only used for AT
;
; Implicit Inputs:
;
;	IFB$L_RJB	RJB address
;	IFB$L_FWA_PTR	FWA pointer and current contents of FWA
;	RJB$V_OPEN	Set to indicate an open entry; cleared if set.
;	RJB$W_FLAGS	RMS journal channel flags - these will be used
;			as variable inputs (saved and restored by caller)
;			to allow AT write at a different time from AI, BI, RU.
;
; Output Parameters:
;
;	R1 - R5		Destroyed
;
; Implicit Outputs:
;
;	RJB$V_OPEN	Cleared if set
;
; Completion Codes:
;
;	Any RMS, particularly DME,
;	CJF -	CJF error, CJF status in STV
;
; Side Effects:
;	May have switched to EXEC AST level.
;
;--

;
; Alternate Entry Point for RU handler
;

RM$MAPJNL_RU::
	PUSHL	#1					; indicate RU MAPJNL
	BRB	MAPJNL

;
; Entry point for AI, BI, AT
;
RM$MAPJNL::
	CLRL	-(SP)					; indicate not RU MAPJNL


MAPJNL:	MOVQ	R6,-(SP)				; save R6, R7
	MOVL	R10,-(SP)				; save R10

;
; Get RJR buffer address.
;
	BSBW	RM$ALLOC_RJB_BDB			; get a journal BDB
							; if this is CLOSE
	BLBS	R0,10$					; continue if OK
	BRW	80$					; out on error
10$:	MOVL	IFB$L_JNLBDB(R9),R10			; first get BDB address
	MOVL	BDB$L_ADDR(R10),R6			; get RJR address

;
; Fill in file name in entry
;
	MOVL	IFB$L_FWA_PTR(R9),R10			; get FWA address
	MOVAL	RJR$T_FILENAME(R6),R3			; get name buff addr

	ASSUME	RJR$S_FILENAME EQ 256

;
; Set buffer size to 255 because the GETFILNAM code builds a NAM block, etc...
; and can only cope with a size that fits in a byte.
;
	MOVZWL	#<RJR$S_FILENAME-1>,R4			; set size of buffer
	JSB	RM$GETFILNAM				; go get file name
	MOVB	R4,RJR$B_FNS(R6)			; put length in entry

; Fill in header
;
	MOVL	IFB$L_JNLBDB(R9),R4			; retrieve jnl BDB addr
	MOVW	#RJR$C_FILNAMLEN,BDB$W_NUMB(R4)		; set entry size
	MOVL	IFB$L_RJB(R9),R7			; get RJB address
	MOVB	#RJR$C_MAPPING,RJR$B_ENTRY_TYPE(R6)	; fill in file type
	MOVB	IFB$B_ORGCASE(R9),RJR$B_ORG(R6)		; fill in org
	TSTL	^X0C(SP)				; RU call?
	BNEQ	70$					; branch if so

	ASSUME	FAB$C_SEQ@-4	EQ	RJR$C_SEQ
	ASSUME	FAB$C_REL@-4	EQ	RJR$C_REL
	ASSUME	FAB$C_IDX@-4	EQ	RJR$C_IDX

	BBCC	#RJB$V_OPEN,RJB$W_FLAGS(R7),20$		; branch if not $OPEN
	MOVB	#RJR$_OPEN,RJR$B_OPER(R6)		; fill in operation
	BRB	30$

20$:	MOVB	#RJR$_CLOSE,RJR$B_OPER(R6)		; fill in operation

; Write indivdual mapping entries
;

30$:	MOVL	IFB$L_JNLBDB(R9),R4			; restore BDB addr
	MOVQ	R3,-(SP)				; make type and BDB args
	RMSSUC						; success if no jnling
	BBC	#RJB$V_BI,RJB$W_FLAGS(R7),40$		; branch if no BI
	MOVZBL	#CJF$_BI,(SP)				; set BI
	BSBW	RM$WRTJNL				; write the record
	BLBC	R0,60$					; get out on error

40$:	BBC	#RJB$V_AI,RJB$W_FLAGS(R7),50$		; branch if no AI
	MOVZBL	#CJF$_AI,(SP)				; set AI
	BSBW	RM$WRTJNL				; write the record
	BLBC	R0,60$					; get out on error

50$:	BBC	#RJB$V_AT,RJB$W_FLAGS(R7),60$		; branch if no AT
	MOVZBL	#CJF$_AT,(SP)				; set AT
	MOVL	R6,IFB$L_ATJNLBUF(R9)			; shortcut RJR addr.
	BSBW	COMMON_FILE_AT				; fill in fields
	BSBB	RM$WRTJNL				; write the record
	MOVL	IFB$L_ATJNLBUF(R9),R2			; get RJR address
	ASSUME	RJR$L_AT_STV	EQ	RJR$L_AT_STS+4
	CLRQ	RJR$L_AT_STS(R2)			; init status

60$:	ADDL2	#8,SP					; clear arglist
	BRB	80$					; exit

;+
; RU mapping entry.
;-

70$:	MOVB	#RJR$_OPEN,RJR$B_OPER(R6)		; fill in operation
	PUSHL	R4					; BDB addr
	PUSHL	#CJF$_RU				; Set RU
	BSBB	RM$WRTJNL_OBJ				; write the record
	ADDL2	#8,SP					; delete arglist

80$:	MOVL	(SP)+,R10				; restore FWA addr
	MOVQ	(SP)+,R6				; restore R6,R7
	TSTL	(SP)+					; clear off call code
	RSB

	.SBTTL	RM$WRTJNL - Write Journal Entry
	.SBTTL	RM$WRTJNL_OBJ - Write Journal Entry with OBJECT_ID Flag

;++
; RM$WRTJNL - Write Journal Entry
; RM$WRTJNL_OBJ - Write Journal Entry with OBJECT_ID Flag
;
; This routine fills in the mapping enry sequence number into the
; journaling buffer and then writes it out for either a fab or rab
; operation.
;
; Calling sequence:
;
;	BSBW	RM$WRTJNL
;	BSBW	RM$WRTJNL_OBJ
;
; Input Parameters:
;
;	4(SP)	Type of journal to be written (CJF$_xx)
;	8(SP)	Address of journaling BDB
;	R4	Address of BDB of Related buffer
;	R9	Address of IFB or IRB (depending on call)
;	R10	Address of IFB if IRAB call
;	R11	Address of impure area
;
; Implicit Inputs:
;
;	IFB$L_RJB	Address of RJB
;	RJB$Q_CHAN	One word is used as channel for QIO
;
; Output Parameters:
;
;	R1		Destroyed
;
; Implicit Outputs:
;
;	BDB$T_JNLSEQ	One longword contains new high water mark
;
; Completion Codes:
;
;	CJF	-	CJF error, CJF status in STV
;
; Side Effects:
;	May have switched to EXEC AST level.
;
;--

RBDB=8		; stack offset to related BDB address
JTYP=28		; stack offset to journal type code
JBDB=32		; stack offset to journal BDB

;
; Alternate Entry Point to write entry with OBJECT_ID flag.
;
RM$WRTJNL_OBJ::
	PUSHR	#^M<R2,R3,R4,R5,R6,R7>			; save regs
	MOVL	#WRFLG$M_OBJECT_ID,R3			; set P6 flags
	BRB	WRTJNL

RM$WRTJNL::
	PUSHR	#^M<R2,R3,R4,R5,R6,R7>			; save regs
	MOVL	#WRFLG$M_LOCK,R3			; set P6 flags 
WRTJNL:	MOVL	JTYP(SP),R2				; get typ code
	CMPB	IRB$B_BID(R9),#IRB$C_BID		; IRB operation?
	BEQL	10$					; branch if yes

;
; IFAB operation
;
	MOVL	IFB$L_FWA_PTR(R9),R4			; get FWA address
	MOVL	IFB$L_RJB(R9),R6			; get RJB address
	BBS	#IFB$V_RUP,IFB$B_JNLFLG2(R9),15$	; branch if RUP
	BRB	20$

;
; IRAB operation
;
10$:	MOVL	IFB$L_FWA_PTR(R10),R4
	MOVL	IFB$L_RJB(R10),R6
	BBC	#IFB$V_RUP,IFB$B_JNLFLG2(R10),20$	; branch if no RUP

;
; IFB, IRB rejoin here if RU in progress.
;
15$:	SSB	#WRFLG$V_RUALSO,R3			; set RUALSO in P6 flags
	CMPL	R2,#CJF$_RU				; see if RU write
	BNEQ	20$					; branch if not
	SSB	#WRFLG$V_BI,R3				; set RU/BI in P6 flags

;
; IFB, IRB rejoin here in no RU in progress
;
20$:	MOVL	JBDB(SP),R5				; get jBDB address
	SSB	#BDB$V_IOP,BDB$B_FLGS(R5)		; indicate IO in prog
	MOVL	BDB$L_ADDR(R5),R1			; get buff address
	MOVB	#RJR$C_MAXVER,RJR$B_VERSION(R1)		; set journal rec ver #
	PUSHR	#^M<R1,R2,R3,R4,R5>
	MOVC3	#FWA$S_JNLID,FWA$T_JNLID(R4),RJR$T_JNLID(R1) ; copy journal id
	POPR	#^M<R1,R2,R3,R4,R5>
	MOVZWL	BDB$W_NUMB(R5),R7			; get record length
	JSB	RM$SETEFN				; get EFN
	POPR	#^M<R0>
	$QIO_S -					; issue QIO
		EFN	=	R0, -
    		CHAN	=	RJB$Q_CHAN-2(R6)[R2], -
    		FUNC	=	#IO$_WRITEVBLK, -
    		IOSB	=	BDB$L_IOSB(R5), -
    		ASTADR	=	RM$STALLAST, -
    		ASTPRM	=	R9, -			; IRB/IFB
    		P1	=	(R1), -			; buffer address
    		P2	=	R7, -			; size of transfer
		P6	=	R3			; journal type
	BLBC	R0,30$					; get out on error

	JSB	RM$STALL				; wait for completion
	MOVL	BDB$L_IOSB(R5),R0			; retrieve status
	MOVL	JTYP(SP),R2				; get typ code
	MOVL	RBDB(SP),R4				; get related BDB addr
	MOVL	BDB$L_IOSB+4(R5),BDB$T_JNLSEQ-4(R4)[R2] ; retrieve seq #
30$:	CSB	#BDB$V_IOP,BDB$B_FLGS(R5)		; clear IO in prog
	POPR	#^M<R2,R3,R4,R5,R6,R7>			; restore regs
	BLBS	R0,40$					; get out on success
	JSB	RM$MAPERR				; fill in STV
	RMSERR	CJF					; force CJF error
40$:	RSB						; return to caller

	.SBTTL	RM$FRCJNL - Force All Journal Entries for a buffer
;++
; FORCE_JNL - Force Journal Entries
;
; This routine performs a force operation to all open journals
; at the high water mark for a buffer.
;
; Calling sequence:
;
;	BSBW	RM$FRCJNL
;
; Input Parameters:
;
;	R4	Address of BDB of Related buffer or
;		Zero to flush all Entries.
;	R9	IFAB or IRAB address
;	R10	IFAB address if IFAB operation
;	R11	Address of Impure Area
;
; Implicit Inputs:
;
;	IFB$L_RJB	Address of RJB
;
; Output Parameters:
;
;	R1 - R3, R5	Destroyed
;
; Implicit Outputs:
;	None.
;
; Completion Codes:
;
;	CJF - CJF error, Status from QIO in STV
;
; Side Effects:
;	May have switched to EXEC AST level.
;--

RM$FRCJNL::
	MOVL	#1,-(SP)				; anticipate success
	CMPB	IRB$B_BID(R9),#IRB$C_BID		; IRB operation?
	BEQL	10$					; branch if yes
	MOVL	IFB$L_RJB(R9),R5			; get RJB address
	BRB	15$
10$:	MOVL	IFB$L_RJB(R10),R5

15$:	BBC	#RJB$V_BI,RJB$W_FLAGS(R5),20$		; branch if no BI
	MOVL	#CJF$_BI,R2				; indicate BI
	BSBW	FORCE_JNL				; go do force
	BLBS	R0,20$					; skip on success
	MOVL	R0,(SP)					; save error code

20$:	BBC	#RJB$V_AI,RJB$W_FLAGS(R5),30$		; branch if no AI
	MOVL	#CJF$_AI,R2				; indicate AI
	BSBW	FORCE_JNL				; go do force
	BLBS	R0,30$					; skip on success
	MOVL	R0,(SP)					; save error code

30$:	BBC	#RJB$V_AT,RJB$W_FLAGS(R5),40$		; branch if no AT
	MOVL	#CJF$_AT,R2				; indicate AT
	BSBW	FORCE_JNL				; go do force
	BLBS	R0,40$					; skip on success
	MOVL	R0,(SP)					; save error code

40$:	BBC	#RJB$V_RU,RJB$W_FLAGS(R5),50$		; branch if no RU
	MOVL	@#CTL$GL_RUF,R1				; RU in prog?
	BEQL	50$					; branch if not
	BBC	#RUCB$V_ACTIVE,RUCB$B_CTRL(R1),50$
	MOVL	#CJF$_RU,R2				; indicate RU
	BSBW	FORCE_JNL				; go do force
	BLBS	R0,50$					; skip on success
	MOVL	R0,(SP)					; save error code

50$:	MOVL	(SP)+,R0				; get worst status
	BLBC	R0,60$					; get out on success
	RSB
60$:	JSB	RM$MAPERR				; fill in STV
	RMSERR	CJF					; force CJF error
	RSB

	.SBTTL	FORCE_JNL - Force Journal Entries

;++
; FORCE_JNL - Force Journal Entries
;
; This routine performs a force operation to the specified journal
; at the high water mark for a buffer.
;
; Calling sequence:
;
;	BSBW	RM$FRCJNL
;
; Input Parameters:
;
;	R2	Type of journal to be forced (CJF$_xx)
;	R4	Address of BDB of Related buffer or
;		Zero to flush all entries.
;	R5	Adddress of RJB
;	R9	IFAB or IRAB address
;	R10	IFAB address if IFAB operation
;	R11	Address of Impure Area
;
; Implicit Inputs:
;
;	IFB$L_RJB	Address of RJB
;	RJB$Q_CHAN	One word is used as channel for QIO
;	BDB$T_JNLSEQ	One longword contains high water mark for force
;
; Output Parameters:
;
;	R0 - R3		Destroyed
;
; Implicit Outputs:
;	None.
;
; Completion Codes:
;
;	Any QIO status value,
;	Any IOSB status vaule from a journaling QIO.
;
; Side Effects:
;	May have switched to EXEC AST level.
;--

FORCE_JNL:
	MOVL	#1,R0					; anticipate success
	MOVL	R4,R3					; see if buffer present
	BEQL	10$					; branch if not
	MOVL	BDB$T_JNLSEQ-4(R4)[R2],R3		; get high water mark
	BEQL	20$					; if zero, bdb has not
							; been used as part of a
							; journaling operation.
10$:	JSB	RM$SETEFN				; get EFN
	POPR	#^M<R0>
	$QIO_S -					; issue QIO
		EFN	=	R0, -
    		CHAN	=	RJB$Q_CHAN-2(R5)[R2], -
    		FUNC	=	#IO$_FORCE, -
    		IOSB	=	IRB$L_IOS(R9), -
		ASTADR	=	RM$STALLAST, -
    		ASTPRM	=	R9, -
    		P2	=	R3			; high water mark
	BLBC	R0,20$					; get out on error
	JSB	RM$STALL				; wait for completion
	MOVL	IRB$L_IOS(R9),R0			; retrieve status

20$:	RSB						; return to caller

	.SBTTL	RM$DSCJNL - Disconnect IRAB Journal Structures

;++
; RM$DSCJNL - Disconnect IRAB Journal Structures
;
; This routine deallocates the data structures for journaling record
; processing operations from the IRAB. 
;
; Calling sequence:
;
;	BSBW	RM$DSCJNL
;
; Input Parameters:
;
;	R9	Address of IRAB
;	R11	Address of Impure area
;
; Implicit Inputs:
;
;	IRB$L_JNLBDB	Address of journaling BDB
;
; Output Parameters:
;	R0 - R5		Destroyed
;
; Implicit Outputs:
;	None.
;
; Completion Codes:
;	None.
;
; Side Effects:
;	None.
;
;--

RM$DSCJNL::

	MOVL	IRB$L_JNLBDB(R9),R4		; get journal BDB address
	BEQL	10$				; skip if none
	JSB	RM$RETJNLBDB			; deallocate it
	CLRL	IRB$L_JNLBDB(R9)		; clear pointer
10$:						; 
	MOVL	IRB$L_ATJNLBUF(R9),R4		; get AT MJB address
	BEQL	20$				; branch if none
	MOVL	R4,R5				; copy MJB address for FORCE call
	BSBW	RM$FORCE_MJB			; force the IRB AT journaling records
						; Note, errors eaten!
	JSB	RM$RETBLK1			; give it up
	CLRL	IRB$L_ATJNLBUF(R9)		; clear pointer
20$:	RSB

	.SBTTL	RM$DEAJNL - Close journaling on file

;++
; RM$DEAJNL - Close journaling on file
;
; This routine deassigns the journal channels open for the file and
; deallocates the journaling data structures from the IFAB.
;
; Calling sequence:
;
;	BSBW	RM$DEAJNL
;
; Input Parameters:
;
;	R9	Address of IFAB
;	R11	Impure area address
;
; Implicit Inputs:
;
;	IRB$L_RJB	Address of RJB
;
; Output Parameters:
;
;	R1 - R5		Destroyed
;
; Implicit Outputs:
;	None.
;
; Completion Codes:
;	CJF	- CJF Operation Error, CJF status from $DEASJNL in STV
;
; Side Effects:
;	None.
;
;--

RM$DEAJNL::

	MOVL	#1,-(SP)				; assume success
	MOVL	IFB$L_JNLBDB(R9),R4			; jnl BDB/Buffer address
	BEQL	2$					; skip if none
	PUSHL	R10					; save R10
	MOVL	R9,R10					; R10 must be IFAB
	JSB	RM$RETJNLBDB				; deallocate BDB/Buffer
	MOVL	(SP)+,R10				; restore R10
	CLRL	IFB$L_JNLBDB(R9)			; clear pointer
2$:	CLRL	IFB$L_ATJNLBUF(R9)			; clear shortcut pointer
							; to AT RJR
	MOVL	IFB$L_EXTJNLBUF(R9),R4			; get extend MJB address
	BEQL	5$					; branch if none
	JSB	RM$RETBLK1				; give it up
	CLRL	IFB$L_EXTJNLBUF(R9)			; clear pointer
5$:	MOVL	IFB$L_RJB(R9),R4			; get RJB address
	BNEQ	7$					; skip if none
	BRW	45$					; get out
7$:	BBCC	#RJB$V_BI,RJB$W_FLAGS(R4),10$		; branch if no BI
	$DEASJNL_S -
		CHAN = RJB$W_BICHAN(R4)

	BLBS	R0,10$					; continue on success
	MOVL	R0,(SP)					; save error code

10$:	BBCC	#RJB$V_AI,RJB$W_FLAGS(R4),20$		; branch if no AI
	$DEASJNL_S -					; deassign channel
		CHAN = RJB$W_AICHAN(R4)
	BLBS	R0,20$					; continue on success
	MOVL	R0,(SP)					; save error code

20$:	BBCC	#RJB$V_AT,RJB$W_FLAGS(R4),30$		; branch if no AT
	$DEASJNL_S -					; deassign channel
		CHAN = RJB$W_ATCHAN(R4)
	BLBS	R0,30$					; continue on success
	MOVL	R0,(SP)					; save error code

30$:	BBCC	#RJB$V_RU,RJB$W_FLAGS(R4),40$		; branch if no RU
	$DEASJNL_S -					; deassign channel
		CHAN = RJB$W_RUCHAN(R4)
	BLBS	R0,40$					; continue on success
	MOVL	R0,(SP)					; save error code

40$:	CLRW	RJB$W_FLAGS(R4)				; clear open flags
	MOVL	R9,R3					; deallocate RJB
	JSB	RM$RETBLK				;
	CLRL	IFB$L_RJB(R9)				; evaporate pointer
45$:	MOVL	(SP)+,R0				; get true error code
	BLBC	R0,50$					; get out on error
	RSB

50$:	JSB	RM$MAPERR				; set STV
	RMSERR	CJF					; force CJF error
	RSB						; return to caller

	.SBTTL	RM$ALLOC_MJB - Alloc and init MJB

;++
;
; RM$ALLOC_MJB - allocate and initalize a miscellaneous journaling buffer
;
;	The MJB is used for audit trail entries and AI extend descriptions.
;
; Calling Sequence:
;
;	BSBW	RM$ALLOC_MJB
;
; Input Parameters:
;
;	R10	IFAB address
;	R2	mjb size in bytes
;
; Output Parameters:
;
;	R0	status
;	R1	MJB address
;
; Side Effects, Implicit Inputs, Implicit Outputs:
;
;	None.
;
;--

RM$ALLOC_MJB::

	ASSUME	<IRB$C_BID&1>	EQ	0
	ASSUME	<IFB$C_BID&1>	EQ	1
	ASSUME	IFB$B_BID	EQ	IRB$B_BID

	MOVL	R9,R1				; assume ifab addr in r1
	BLBS	IFB$B_BID(R9),5$		; branch if structure is ifab
	MOVL	IRB$L_IFAB_LNK(R9),R1		; get ifab address from irab
5$:
	ADDL2	#7,R2				; round request up
	BICL2	#7,R2				; ...
	ASHL	#-2,R2,R2			; change bytes to longwords
	JSB	RM$GETBLK			; alloc an MJB on IFB page
	BLBC	R0,10$				; get out on error
	MOVB	#MJB$C_BID,MJB$B_BID(R1)	; identify MJB as MJB
	MOVAL	MJB$T_RJR(R1),MJB$L_POINTER(R1) ; init descriptor
	PUSHR	#^M<R1,R2,R3,R4,R5>		; save MOVC5 regs 
	MOVAL	MJB$T_RJR(R1),R1		; get RJR address
	MOVC5	#0,(R1),#0,#RJR$C_HDRLEN,(R1)	; zero the RJR overhead
	POPR	#^M<R1,R2,R3,R4,R5>		; restore MOVC5 regs
	RMSSUC
10$:	RSB					; return to caller

	.SBTTL	RM$WRITE_MJB - Write Miscellaneous Journaling Buffer

;++
;
; RM$WRITE_MJB
;
; This routine is used to write a journaling record described by a
; miscellaneous journaling buffer.
;
; Calling Sequence:
;
;	BSBW	RM$WRITE_MJB
;
; Input Parameters:
;
;	R9	- IFAB or IRAB address
;	R5	- address of MJB
;
; Implicit Inputs:
;
;	MJB fields:
;
;		JNL	- CJF$_AI, BI, AT, or RU for journal channel to use
;		FLAGS	- various
;		DESC	- descriptor of embedded RJR to write
;
; Output Parameters:
;
;	R0	- status
;	R6	- destroyed
;
; Implicit Outputs:
;
;	MJB IOSB has status of operation.
;
; Side Effects:
;
;	None.
;
;--

RM$WRITE_MJB::

	PUSHR	#^M<R2,R3,R4>			; save work registers
	MOVL	R9,R4				; get potential IFAB address

	ASSUME	IFB$B_BID	EQ	IRB$B_BID

	CMPB	IFB$B_BID(R4),#IFB$C_BID	; file or record operation?
	BEQL	5$				; branch if IFAB
	MOVL	IRB$L_IFAB_LNK(R9),R4		; get IFAB address

5$:	MOVL	IFB$L_RJB(R4),R6		; get pointer to RJB
	BEQL	35$				; branch if none

	BBC	#MJB$V_INIT,MJB$W_FLAGS(R5),35$ ; skip if RJR in MJB is useless

	CLRL	R3				; initialize MODIFIER flags
	BBC	#MJB$V_FORCE,MJB$W_FLAGS(R5),10$; skip if not write-thru to jnl
	MOVB	#WRMOD$M_FORCE,R3		; indicate write-thru to jnl
	
10$:	MOVZBL	MJB$B_JNL(R5),R2		; get JNL type for channel calculation
	MOVL	R9,R4				; initialize astparm to IRAB address
	BBC	#MJB$V_FILE,MJB$W_FLAGS(R5),20$ ; branch if assumption OK
	MOVL	R10,R4				; otherwise astprm is IFAB address

20$:	JSB	RM$SETEFN			; get an EFN to wait on
	POPR	#^M<R0>				; and stick it in R0

	$WRITEJNL_S -
		CHAN	= RJB$Q_CHAN-2(R6)[R2], -	; channel of journal
		WRTBUF	= MJB$Q_DESC(R5), -		; RJR descriptor
		MODIF	= R3,-				; modifier flags
		EFN	= R0,-				; event flag to wait on
		IOSB	= IRB$L_IOS(R9),-		; status of operation
		ASTADR	= RM$STALLAST,-			; back to RM$STALLAST
		ASTPRM	= R4				; IFAB or IRAB

	BLBC	R0,50$				; go away on error
	BBS	#MJB$V_SYNCH_SHARE,MJB$W_FLAGS(R5),40$	; branch if SFSB lock
						; can't be given up
	JSB	RM$STALL			; wait for completion
30$:	MOVQ	IRB$L_IOS(R9),MJB$Q_IOSB(R5)	; save status and seq no in MJB
	BLBC	R0,50$				; go away on error
35$:	
	POPR	#^M<R2,R3,R4>			; restore registers
	RMSSUC					; indicate success
	RSB					; return to caller

40$:	JSB	RM$STALL_LOCK			; wait, keeping file lock (used for
						; extend)
	BRB	30$				; go check status

50$:	
	POPR	#^M<R2,R3,R4>			; restore work registers
	RMSERR	CJF,R1				; default error status
	JMP	RM$MAPERR			; map error code and return
						; to caller

	.SUBTITLE RM$FORCE_MJB - Force MJB Entries
;++
; RM$FORCE_MJB
;
;	This routine is called at disconnect to force the journal entries
;	described by the high water mark in the MJB.  (Currently only used
;	for AT record operations.
;
; Inputs:
;	r5	MJB address
;
; Implicit Inputs:
;	contents of the MJB, including MJB$B_JNL and the sequence number
;	in the IOSB.
;
;	rjb has the channel assigned to the AT journal
;
; Outputs:
;	r0 - success or failure
;
; Side Effects:
;
;	AT record journal entries flushed.
;
;--

RM$FORCE_MJB::

	RMSSUC					; default to success
	PUSHR	#^M<R2,R3,R4,R5>		; save work registers
	MOVL	IFB$L_RJB(R10),R4		; get RJB address
	BEQL	40$				; get out if none
	MOVZBL	MJB$B_JNL(R5),R2		; get JNL identifier
	JSB	RM$SETEFN			; allocate an event flag
	POPR	#^M<R0>				; get EF in R0

	$FORCEJNL_S -
		CHAN	= RJB$Q_CHAN-2(R4)[R2], -	; channel of journal
		SEQNO	= MJB$Q_IOSB+4(R5), -		; sequence number
		EFN	= R0, -				; event flag
		IOSB	= IRB$L_IOS(R9), -		; use IOSB in IRB
		ASTADR	= RM$STALLAST, -		; usual AST address
		ASTPRM = R9				; IRAB operation

	BLBC	R0,50$				; out on error
	JSB	RM$STALL			; wait for completion
	MOVQ	IRB$L_IOS(R9),MJB$Q_IOSB(R5)	; grab status for fun
	BLBC	R0,50$				; out on error
40$:	POPR	#^M<R2,R3,R4,R5>		; restore work registers
	RSB					; return to caller

50$:	RMSERR	CJF,R1				; cjf error
	JSB	RM$MAPERR			; map the error code
	BRB	40$				; return to caller

	.SUBTITLE RM$ALLOC_RJB_BDB - Allocate RJB, Journal BDB
;++
; RM$ALLOC_RJB_BDB
;
;	This routine allocates an RJB and JNL BDB for use by RMS journaling.
;
; Inputs:
;	R9	IFAB
;
; Outputs:
;	R0	status
;	IFB$L_JNLBDB	address of JNL BDB
;	IFB$L_RJB	address of RJB
;
; Side Effects:
;	None.
;
;--

RM$ALLOC_RJB_BDB::

	PUSHR	#^M<R3,R4,R5>			; save work registers
	TSTL	IFB$L_RJB(R9)			; RJB present?
	BNEQ	10$				; branch if yes
	MOVL	R9,R1				; allocate RJB
	MOVL	#RJB$C_BLN/4,R2			; size of RJB
	JSB	RM$GETBLK			; get it
	BLBC	R0,30$				; get out on error
	MOVL	R1,IFB$L_RJB(R9)		; save RJB address
	MOVB	#RJB$C_BID,RJB$B_BID(R1)	; initialize RJB
	SSB	#IFB$V_JNL,IFB$B_JNLFLG2(R9)	; indicate RJB present
10$:	TSTL	IFB$L_JNLBDB(R9)		; JNLBDB already allocated?
	BNEQ	20$				; branch if so

;
; If AI journaling a relative file - allocate a bigger buffer, on large enough
; to contain prolog (512 bytes).
;
	BBC	#IFB$V_AI,IFB$B_JNLFLG(R9),15$	; skip if not AI journaling
	CMPB	#IFB$C_REL,IFB$B_ORGCASE(R9)	; is it relative file?
	BNEQ	15$				; branch if not relative

	ASSUME	<RJR$C_BLKLEN+512> GT RJR$C_FILNAMLEN

	MOVZWL	#<RJR$C_BLKLEN+512>,R5		; size of buffer
	BRB	16$				; join common code
15$:						;
	MOVZWL	#RJR$C_FILNAMLEN,R5		; size of buffer to allocate
16$:	MOVL	R10,-(SP)			; save R10, ALDJNLBUF needs R10=IFB
	MOVL	R9,R10				; copy IFB address
	ADDL2	#511,R5				; round to page boundary
	BICL2	#511,R5				; ...
	JSB	RM$ALDJNLBUF			; allocate jnl BDB and buffer
	MOVL	(SP)+,R10			; restore R10
	BLBC	R0,40$				; get out on error
	MOVL	R4,IFB$L_JNLBDB(R9)		; save address of JNLBDB
	PUSHR	#^M<R1,R2,R3,R4,R5>		; save regs zeroed by MOVC5
	MOVL	BDB$L_ADDR(R4),R1		; get RJR address
	MOVC5	#0,(R1),#0,#RJR$C_HDRLEN,(R1)	; zero the RJR overhead
	POPR	#^M<R1,R2,R3,R4,R5>		; restore regs zeroed by MOVC5

20$:	RMSSUC					; success
30$:	POPR	#^M<R3,R4,R5>			; restore registers
	RSB					; to caller
40$:						; deallocate the RJB
	MOVL	R0,-(SP)			; save error code
	MOVL	R9,R3				; address of block holding space
	MOVL	IFB$L_RJB(R9),R4		; address of RJB
	JSB	RM$RETBLK			; return space and to caller	
	MOVL	(SP)+,R0			; restore error code
	POPR	#^M<R3,R4,R5>			; restore registers
	RSB					; to caller

	.SUBTITLE RM$AT_JNL_RECORD - Write AT Entry for Records

;++
; RM$AT_JNL_RECORD
;
;	This routine is responsible for writing any AT journaling record
;	required to describe a record operation.  This routine's primary
;	task is to make sure the RJR overhead is filled in properly, and
;	the correct MJB inputs are set.  RM$WRITE_MJB is then called to
;	actually perform the CJF write service.
;
; Calling Sequence:
;
;	BSBW	RM$AT_JNL_RECORD
;
;	This routine is called only by RM$EXRMS.
;
; Input Parameters:
;
;	R0	operation status to this point
;	R8	user's RAB
;	R9	IRAB
;	R10	IFAB
;
; Implicit Inputs:
;
;	IRB$L_ATJNLBUF	- pointer to MJB containing RJR
;	RJR$B_OPER 	- must be filled in by caller
;
; Output Parameters:
;
;	r0	operation status
;	r1	destroyed
;
; Implicit Outputs:
;
;	None.	(for now)
;
; Side Effects:
;
;	RJR written to CJF
;
;--

RM$AT_JNL_RECORD::

	TSTL	R9			; any structure address?
	BNEQ	2$			; if no, must be structureless exit
1$:	RSB				; nothing to do

	ASSUME	IFB$B_BID	EQ	IRB$B_BID

2$:	CMPB	IFB$B_BID(R9),#IRB$C_BID ; is this an IRAB?
	BNEQ	1$			; if neq no, forget it

	BBC	#IFB$V_AT,IFB$B_JNLFLG(R10),1$ ; skip if not AT journaling
	PUSHR	#^M<R4,R5>		; save work registers
	MOVL	IRB$L_ATJNLBUF(R9),R5	; get MJB address
	BEQL	70$			; skip if none	

;
; Fill in required MJB fields
;
	MOVB	#CJF$_AT,MJB$B_JNL(R5)	; indicate we're audit trail journaling
	CLRW	MJB$W_FLAGS(R5)		; nothing special for WRITEJNL call
	MOVZWL	#RJR$C_AT_RECLEN,MJB$Q_DESC(R5) ; set up record length

	MOVAL	MJB$T_RJR(R5),R4	; get RJR address in R4
	TSTL	RJR$B_OPER(R4)			; any op specified?
	BEQL	70$				; skip if none
	BBCS	#MJB$V_INIT,MJB$W_FLAGS(R5),90$ ; skip filling in RJR if already
						; done
10$:						; RJR overhead filled in
	MOVL	R0,RJR$L_AT_STS(R4)		; get status
	SSB	#16,RJR$L_AT_STS(R4)		; make it an RMS status
	MOVL	RAB$L_STV(R8),RJR$L_AT_STV(R4)	; and get STV also
;
; Pull user's request from RAB into journal record.  Must probe structures.
; All relevant data that was available at the beginning of the operation
; is already in the journal record.  It was put there by RM$AT_COM_RAB.
;
20$:	TSTL	R8				; user structure?
	BEQL	60$				; branch if no RAB
	IFNORD	#RAB$C_BLN,(R8),60$		; skip rest if not readable
	CMPB	(R8),#RAB$C_BID			; is it a RAB?
	BNEQ	60$				; branch if no RAB

;
; We found a readable RAB, now fill AT entry in with the RAB contents.
;
	MOVL	RAB$L_RFA0(R8),RJR$L_AT_RFA0(R4);  1st part of RFA
	MOVW	RAB$W_RFA4(R8),RJR$W_AT_RFA4(R4);  2nd part of RFA

60$:	MOVZBL	RJR$B_AT_KSZ(R4),R1		; get key size
	ADDL2	R1,MJB$Q_DESC(R5) 		; account for key size
	BSBW	RM$WRITE_MJB			; write the AT record

	ASSUME	RJR$L_AT_STV	EQ	RJR$L_AT_STS+4

	CLRQ	RJR$L_AT_STS(R4)		; init status for next time
	CLRB	RJR$B_OPER(R4)			; and operation

;
; Now zero search KEY so it doesn't linger in the buffer.
;
	MOVZBL	RJR$B_AT_KSZ(R4),R1		; get key size for clear
	BEQL	70$				; skip if none
	PUSHR	#^M<R0,R1,R2,R3>		; save MOVC3 registers
	MOVC5	#0,RJR$T_AT_KEY(R4),#0,R1,-	; zero out KEY for next time
		RJR$T_AT_KEY(R4)		;
	POPR	#^M<R0,R1,R2,R3>		; restore MOVC3 registers

70$:	POPR	#^M<R4,R5>			; restore work registers
80$:	RSB				; return to caller

90$:					; fill in RJR overhead

	ASSUME RJR$B_ENTRY_TYPE EQ <RJR$B_VERSION+1>

	MOVW	#<<RJR$C_AT_RECORD@8>+RJR$C_MAXVER>,-
		RJR$B_VERSION(R4) 		; version, type
	MOVB	IFB$B_ORGCASE(R10),RJR$B_ORG(R4); file organization
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; save registers MOVC3 destroys
	MOVL	IFB$L_FWA_PTR(R10),R5		; get FWA address
	MOVC3	#FWA$S_JNLID,FWA$T_JNLID(R5),RJR$T_JNLID(R4) ; journal id
	POPR	#^M<R0,R1,R2,R3,R4,R5>		; restore MOVC3 registers
	BRW	10$				; join common code

	.SUBTITLE COMMON_FILE_AT - Get common AT file data
;++
; COMMON_FILE_AT
;
;	This routine is used to fill in the AT journal entry with data from the
;	IFAB at MAPJNL time.
;
; Inputs:
;
;	r8	FAB
;	r9	IFAB
;
; Outputs:
;
;	AT journal record fields filled in.
;
; Side Effects:
;
;	Currently, the STS/STV is forced to success due to difficulties
;	in acquiring the info when the journal entry must be written.
;	(IE,, can't do it at exit RMS like record operations because
;	data structures must be deallocated at release time. Better
;	solution is to make file AT info hendled by an MJB also, and write
;	and deallocate the file MJB at exit RMS.)
;--

COMMON_FILE_AT:

	PUSHR	#^M<R2>			; save work register
	MOVL	IFB$L_ATJNLBUF(R9),R2	; get address of journal record (RJR)

	MOVB	IFB$B_FAC(R9),RJR$B_FAC(R2) ; fill in specified file access
	MOVB	IFB$B_SHR(R9),RJR$B_SHR(R2) ; fill in specified file sharing
	MOVL	IFB$L_HBK(R9),RJR$L_ALLOC(R2) ; fill in high allocation
	MOVL	FAB$L_STS(R8),RJR$L_AT_STS(R2)	; status
	MOVL	FAB$L_STV(R8),RJR$L_AT_STV(R2)	; STV
	MOVL	FAB$L_CTX(R8),RJR$L_AT_CTX(R2)	; User definable CTX field

10$:	POPR	#^M<R2>			; restore work register
	RSB				; to RM$MAPJNL

	.SUBTITLE RM$AT_COM_RAB - Get common AT record data
;++
; AT_COM_RAB
;
;	This routine scarfs up and puts in the RMS journaling record the
;	common RAB data at the beginning of an operation.
;
; Inputs:
;
;	R1	rjr operation id
;	R8	RAB (the sucker is assumed to be probed.)
;	R9	irab
;	R10	ifab
;	
; Outputs:
;
;	Some AT record RJR fields filled in.
;
;--

RM$AT_COM_RAB::

	PUSHR	#^M<R4>				; save work register
	MOVL	IRB$L_ATJNLBUF(R9),R4		; get MJB address
	BEQL	60$				; skip if none	

	MOVAL	MJB$T_RJR(R4),R4		; get RJR address in R4

	MOVL	RAB$L_ROP(R8),RJR$L_AT_ROP(R4)	; user's ROP
	MOVB	RAB$B_KRF(R8),RJR$B_AT_KRF(R4)	; user's key of reference
	MOVB	RAB$B_RAC(R8),RJR$B_AT_RAC(R4)	; user's record access
	MOVB	R1,RJR$B_OPER(R4)		; operation code
	MOVL	RAB$L_CTX(R8),RJR$L_AT_CTX(R4)	; User context field

;
; Probe key buffer before getting key.
;
	CMPB	RAB$B_RAC(R8),#RAB$C_KEY	; keyed access?
	BNEQ	60$				; if not, no key size
	MOVB	RAB$B_KSZ(R8),RJR$B_AT_KSZ(R4)	; user's key size
	BEQL	60$				; if zero, no key
	IFNORD	RJR$B_AT_KSZ(R4),RAB$L_KBF(R8),60$ ; skip if can't get keybuffer

;
; Copy search key into journal record
;
	PUSHR	#^M<R1,R2,R3,R4,R5>		; save MOVC3 registers
	MOVC3	RJR$B_AT_KSZ(R4),-		; move KEY_SIZE number of chars
		@RAB$L_KBF(R8),-		;   from rab keybuffer
		RJR$T_AT_KEY(R4)		;   to journal record
	POPR	#^M<R1,R2,R3,R4,R5>		; restore MOVC3 egisters

60$:	POPR	#^M<R4>				; restore work register
70$:	RSB					; to caller

	.END
