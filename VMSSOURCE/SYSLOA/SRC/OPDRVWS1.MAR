	.TITLE	OPDRVWS1 - VAX/VMS QVSS CONSOLE TERMINAL DRIVER
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS I/O SUBSYSTEM
;
; ABSTRACT:
;
; AUTHOR: Bill Matthews
;
; OPDRIVER AUTHOR: Trudy Matthews, Benn Schreiber
;
; MODIFIED BY:
;	V03-001	WHM0001		Bill Matthews		01-Aug-1984
;		Initialize the saved scan map. Save r0 across call to remap.
;		Initialize the permanent terminal device characteristics.
;-

;
; SYMBOL DEFINITIONS
;
 
	$ADPDEF				; DEFINE ADAPTER CONTROL BLOCK
	$CRBDEF				; DEFINE CRB
	$CONDEF				; DEFINE CONSOLE FUNCTION CODES
	$DCDEF				; DEFINE DEVICE CLASSES
	$DDBDEF				; DEFINE DDB
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				; DEFINE DPT
	$DYNDEF				; STRUCTURE TYPE CODE DEFINITIONS
	$IDBDEF				; DEFINE IDB
	$IOUV1DEF			; DEFINE MICROVAX I I/O SPACE
	$IPLDEF				; DEFINE IPL LEVELS
	$IRPDEF				; DEFINE IRP OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE MORE TERMINAL CHARACTERISTICS
	$UCBDEF				; DEFINE UCB
	$TTYDEFS			; TTY UCB extension (must FOLLOW $UCBDEF)
	$TTYMACS			; TTY macro definitions
	$VADEF				; DEFINE VIRTUAL ADDRESS CONSTANTS
	$VECDEF				; DEFINE CRB VECTOR
	$WCBDEF				; Define WCB
	$CINDEF				; Connect to interrupt offsets
	$RBMDEF				; real time bitmap offsets
	$PTEDEF				; DEFINE PTE


CRB$L_SCAN_MAP = CRB$L_TIMELINK		; ADDRESS OF SCAN MAP SAVE AREA
CRB$L_VIDEO_BASE = CRB$L_TOUTROUT	; VIRT ADDR OF BASE OF VIDEO MEMORY
CRB$L_OPFLAGS = CRB$L_AUXSTRUC		; HANDSHAKE FLAGS BETWEEN OPDRVWS1 AND
					; VCDRIVER
;	CRB$L_OPFLAGS DEFINITIONS

	$VIELD	OP,0,<-
		<REINIT,,M>-		; First 24 scan lines must be reinited
		<REMAP,,M>-		; First 24 scan lines not on screen
		<OPACTIVE,,M>-		; OPDRVWS1 is using the first 24 scan lines
		<VCACTIVE,,M>-		; VCDRIVER has been initialized
		>

	.PAGE

; 	UCB$W_QV_KEYSTATE DEFINITIONS

	$VIELD	KEY,0,<-		
		<APPKEYPAD,,M>-
		<HOLD,,M>-
		<LOCK,,M>-
		<SHIFT,,M>-
		<CTRL,,M>-
		<BUTTOG,,M>-		; MOUSE BUTTON SAMPLE TOGGLE
		>

;	MAIN QVSS CSR BIT DEFINITIONS

	$VIELD	QVCSR,0,<-		; 
		<MODE19,1,M>-		; (R)	15 OR 19 INCH MONITOR (1=19)
		<,1>-			; 	SPARE
		<ENA_VIDEO,1,M>-	; (RW)	ENABLE VIDEO
		<CURS_FNC,1,M>-		; (RW)	CURSOR (1=OR, 0=AND)
		<,2>-			; (RW)	DIAG FUNCTIONS
		<ENA_INT,1,M>-		; (RW)	ENABLE INTERRUPT
		<,1>-			; (R)	DIAG
		<BUTA,1,M>-		; (R)	MOUSE BUTTON A (RIGHT)
		<BUTB,1,M>-		; (R)	MOUSE BUTTON B (MIDDLE)
		<BUTC,1,M>-		; (R)	MOUSE BUTTON C (LEFT)
		<MEMBANK,4,M>-		; (R)	VIDEO MEMORY BASE SELECT
		>


	.PAGE

	.SBTTL	REGISTER DEFINITIONS

;	VIDEO RAM LAYOUT (0-3FFFF)

QVSVIDEO_SIZE 	== ^X3F700			; SIZE OF VIDEO RAM AREA
QVSCTLBLOCK	== ^X3F700			; QVSS SYSTEM CONTROL BLOCK (QVB)
QVSUCODE	== ^X3F7E0			; UVAX I QVSS CONSOLE AREA
QVSCAN_MAP 	== ^X3F800			; BASE OF SCAN MAP 
QVSCUR_RAM 	== ^X3FFE0			; CURSOR RAM REGION
SCAN_MAP	== QVSCAN_MAP
 
;	QVSS CONTROL CSRS

QVCSR_CTL	== 0			; CONTROL CSR
QVCSR_CURPOS 	== 2			; CURSOR POSITION (OUTPUT)
QVCSR_MOUSE 	== 4			; MOUSE INPUT (INPUT)
QVCSR_SPARE 	== 6

QVCSR_CRTADDR 	== 8			; CRT CONTROLLER (ADDRESS SELECT)
QVCSR_CRTDATA 	== 10			; CRT CONTROLLER (DATA PORT)
QVCSR_INTDATA 	== 12			; INTERRUPT CONTROLLER (DATA VALUES)
QVCSR_INTCTL 	== 14			; INTERRUPT CONTROLLER (CONTROL FIELD)
QVCSR_URTBUFA 	== 38			; UART DATA BUFFER
QVCSR_URTSTATA 	== 34			; UART STATUS
QVCSR_URTMODEA 	== 32
QVCSR_URTCMDA 	== 36
QVCSR_URTINT 	== 42

QVCSR_OFFSET	== ^O17200		; OFFSET OF QVSS CSR IN I/O SPACE
QVCSR_PA	== IOUV1$AL_QB0SP+QVCSR_OFFSET; QVSS CSR PHY ADDR
QVCSR_PFN	== QVCSR_PA/512		; QVSS CSR PFN
QVCSR_BOFF	== QVCSR_PA - <QVCSR_PFN*512>; QVSS CSR BYTE OFFSET IN PAGE

;
; OUTPUT INTERRUPT QUEUE
;
 
	.PSECT	SYSLOA,LONG


	.SBTTL	CONSOLE CONTROLLER INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE CONTROLLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE CONTROLLER.
;
; INPUTS:
;
;	R4 = CSR ADDRESS
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;--
CON$INITIAL::					; INITIALIZE CONSOLE INTERFACE

	MOVAL	QVSS$KEY-112,QVSS$KEYTABLE	; INITIALIZE THE KEYBOARD TRANSLATION TABLE

	PUSHL	R2				; SAVE R2
	MOVL	G^IOC$GL_ADPLIST,R2		; GET ADP ADDRESS
	ADDL3	ADP$L_VECTOR(R2),#^O60,R2	; GET ADDR OF VECTOR TABLE ENTRY
	MOVAB	G^OPA$CRB+CRB$L_INTD+VEC$Q_DISPATCH+1,(R2); CONNECT THE VECTOR
;
; 	SET UP INTERRUPTS
;
	MOVB	#0,QVCSR_INTCTL(R4)		; RESET INTERRUPT CONTROLLER
	MOVB	#^X40,QVCSR_INTCTL(R4)		; RESET IRR
	MOVB	#^X80,QVCSR_INTCTL(R4)		; SPECIFY INDIVIDUAL VECTORS
	MOVB	#^XC0,QVCSR_INTCTL(R4)		; PRESET AUTOCLEAR DATA
	MOVB	#^XFF,QVCSR_INTDATA(R4)		; ALL ARE AUTO CLEAR

;	VECTOR SPECIFIC

	MOVB	#^XE0,QVCSR_INTCTL(R4)		; PRESET VECTOR ADDRESS (ONE)
	MOVB	#^O60,QVCSR_INTDATA(R4)		; USE SPECIAL VECTOR
	MOVB	#^X28,QVCSR_INTCTL(R4)		; ENABLE TX/RX INTERRUPT
	MOVB	#^XA1,QVCSR_INTCTL(R4)		; ARM THE INTERRUPT CONTROLER CHIP


;
; SET UP UART
;

	MOVW	#^X19,QVCSR_URTCMDA(R4)		; RESET MODE POINTER, ENABLE RCV, DISABLE TX
	MOVW	#^X17,QVCSR_URTMODEA(R4)	; SET MODE 1 ,NOPARITY, 8 BIT 
	MOVW	#^X07,QVCSR_URTMODEA(R4)	; SET MODE 2 , 1 STOP BIT
	MOVW	#^X99,QVCSR_URTSTATA(R4)	; 4800 BAUD XMIT, RCV
	MOVW	#^X02,QVCSR_URTINT(R4)		; ENABLE REC INTERRUPTS

	BISW	#<QVCSR$M_ENA_VIDEO!QVCSR$M_ENA_INT>,-; ENABLE VIDEO
		QVCSR_CTL(R4)			; INTERRUPTS AND CURSOR=AND
	POPL	R2				; RESTORE R2
	RSB

	.SBTTL	CONSOLE UNIT INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE UNITS.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;--
CON$INITLINE::
	PUSHL	R0			; SAVE R0
	MOVAL	G^OPA$VECTOR,R0		; GET THE VECTOR ADDRESS
	CLASS_UNIT_INIT			; AND INIT THIS UNIT
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS OF CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R0)	; INITIALIZE THE UCB FOR CONSOLE TERMINAL
30$:	BBC	#UCB$V_POWER,UCB$W_STS(R5),40$; DID WE DETECT A POWER FAIL
	MOVL	UCB$L_TT_CLASS(R5),R0	; GET THE CLASS VECTOR TABLE ADDRESS
	JSB	@CLASS_POWERFAIL(R0)	; AND GOTO THE POWERFAIL CODE

40$:	POPL	R0			; RESTORE R0

	MOVB	#TT$_UNKNOWN,UCB$B_DEVTYPE(R5); SET UNKNOWN TERMINAL TYPE
	BISL	#TT$M_SCOPE,UCB$L_DEVDEPEND(R5); QVSS IS SCOPE
	BISL	#TT2$M_EDITING,UCB$L_DEVDEPND2(R5); ENABLE LINE EDITING
	BICL	#<TT2$M_ANSICRT!TT2$M_DECCRT>,-; THIS DRIVER DOES NOT
		UCB$L_DEVDEPND2(R5)	; EMULATE VT100'S
	MOVQ	UCB$L_DEVDEPEND(R5),UCB$L_TT_DECHAR(R5); MAKE PERMANENT

CON$SET_LINE::
CON$DS_SET::
CON$SET_MODEM::
CON$NULL::
	RSB				;
CON$DISCONNECT::			; CALLED ON LAST DEASSIGN
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAL	G^OPA$CRB,R3		; GET CRB ADDRESS
	BBC	#OP$V_VCACTIVE,CRB$L_OPFLAGS(R3),20$;BC IF VCDRIVER NOT INITED
	BBC	#EXE$V_OPA0,G^EXE$GL_WSFLAGS,10$;  ALL DONE WITH OPA0? IF BC YES
	TSTL	CRB$L_SCAN_MAP(R3)	; SCAN MAP SAVE AREA ALREADY ALLOCATED?
	BNEQ	10$			; IF NEQ YES ALL DONE
	MOVZWL	#24*10*2,R1		; ALLOCATE SAVE AREA FOR 24 X 10 SCAN LINE MAP ENTRIES
	JSB	G^EXE$ALONONPAGED	; GET THE MEMORY
	BLBC	R0,10$			; BRANCH IF ERROR
	MOVL	R2,CRB$L_SCAN_MAP(R3)	; SAVE SCAN MAP SAVE AREA ADDRESS
	ADDL3	#QVSCAN_MAP,CRB$L_VIDEO_BASE(R3),R1; COMPUTE ADDRESS OF SCAN MAP
	MOVC3	#24*10*2,(R1),(R2)	; INIT SCAN MAP
	MOVAL	G^OPA$CRB,R3		; GET CRB ADDRESS
10$:	BICL	#OP$M_OPACTIVE,CRB$L_OPFLAGS(R3); CLEAR OPACTIVE FLAG
20$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				; RETURN

	.SBTTL CONSOLE RECIEVER INTERRUPT DISPATCHER
;++
; CON$INTINP - CONSOLE INTERRUPT ON INPUT READY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AS A RESULT OF A RECEIVER INTERRUPT ON THE
; QVSS KEBOARD.
;
; QVSS TERMINAL:	ALL RECEIVED DATA CHARACTERS ARE CONSIDERED
;			UNSOLICITED AND RESULT IN AN ENTRY INTO THE
;			TERMINAL DRIVER COMMON CHARACTER BUFFERING
;			ROUTINE "@UCB$L_TT_PUTNXT(R5)".
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
CON$INTINP::
	
	MOVL	@(SP)+,R4		; GET IDB ADDRESS
	MOVL	IDB$L_CSR(R4),R0	; GET CSR ADDRESS
;
; GET THE ASSOCIATED UCB
;
5$:	MOVL	IDB$L_UCBLST(R4),R5	; GET UCB 0 ADDRESS
	BISW	#UCB$M_INTTYPE,UCB$W_STS(R5); SET RECEIVER INTERRUPT
;
	MOVZBL	QVCSR_URTBUFA(R0),R0	; GET INPUT DATA FROM LK201
	BSBW	QVSS$KEYDECODE		; DECODE THE KEYBOARD CHARACTER
;
; CONSOLE TERMINAL INTERRUPT
;
10$:	MOVZBL	R0,R3			; ZERO TOP 3 BYTES
	BEQL	30$			; DON'T PASS NULLS THRU
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BEQL	30$			; IF EQL THEN NO CHARACTER TO OUTPUT
20$:	BSBB	CON$STARTIO		; OUTPUT THE CHARACTER
30$:	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;


	.SBTTL	START I/O ON CONSOLE INTERFACE
;++
; CON$STARTIO - START I/O ON CONSOLE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO OUTPUT A CHARACTER TO THE CONSOLE INTERFACE.
; IF THE INTERFACE IS READY THE DATA IS OUTPUT DIRECTLY. IF THE INTERFACE
; IS NOT READY THEN THE DATA IS QUEUED AND SUBSEQUENTLY OUTPUT ON THE
; NEXT READY INTERRUPT.
;
; IN EITHER CASE, A RETURN TO THE CALLER IS DONE TO ENTER A "WAIT FOR
; INTERRUPT" STATE.
;
; INPUTS:
;
;	R3 = DATA TO OUTPUT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4,R5 ARE PRESERVED.
;--

CON$STARTIO::				;

10$:	BLSS	20$			; BRANCH IF BURST MODE
	MOVZBL	R3,R0			; GET CHARACTER TO OUTPUT
	BSBW	CON$PUTCHAR		; OUTPUT CHARACTER
	BRB	30$			; CHECK FOR MORE TO OUTPUT

20$:
;
; TAKE CHARACTER OUT OF BURST BUFFER AND TRY TO OUTPUT IT IMMEDIATELY
;
	MOVZBL	@UCB$L_TT_OUTADR(R5),R0	; OUTPUT NEXT BYTE
	BSBW	CON$PUTCHAR		; OUTPUT CHARACTER
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	20$			; NOT LAST CHARACTER
30$:	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BNEQ	10$			; IF NEQ MORE CHARACTERS TO OUTPUT
	RSB				; EXIT


	.SBTTL	CONSOLE TRANSMITTER INTERRUPT SERVICE
;++
; CON$INTOUT - CONSOLE TRANSMITTER INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS A NOP FOR QVSS.
;--
CON$INTOUT::				;
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;

.PAGE
.SBTTL	CONSOLE PORT ACTION ROUTINES
;++
; CON$XOFF -	SEND XOFF
; CON$XON -	SEND XON
; CON$STOP -	STOP OUTPUT
; CON$STOP2 -	ALTERNATE STOP
; CON$ABORT -	ABORT CURRENT OUTPUT
; CON$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--

CON$XOFF::
CON$XON::
CON$STOP::
CON$ABORT::
CON$RESUME::
	RSB


	.SBTTL	SEND COMMAND TO CONSOLE

;++
; CON$SENDCONSCMD - SEND CPU-DEPENDENT COMMAND TO CONSOLE
;
; FUNCTIONAL DESCRIPTION:
;
;	INITIATE FUNCTION ON CONSOLE
;
; INPUTS:
;
;	R0 = CONSOLE FUNCTION TO PERFORM:
;		CON$C_BOOTCPU = SEND REBOOT SIGNAL TO CONSOLE AND THEN HALT
;		CON$C_CLRWARM = CLEAR CONSOLE WARMSTART FLAG
;		CON$C_CLRCOLD = CLEAR CONSOLE COLDSTART FLAG
;	R2 = NUMBER OF BYTES OF DATA TO BE RETURNED (= 0 IF NO DATA EXPECTED)
;		(CURRENTLY ONLY IMPLEMENTED IN 11/790 VERSION OF THIS ROUTINE)
;	R3 = ADDRESS OF BUFFER TO HOLD RETURNED DATA (ONLY IF R2 IS NON-ZERO)
;		(CURRENTLY IMPLEMENTED ONLY IN 11/790 VERSION OF THIS ROUTINE)
;
; OUTPUTS:
;
;	CONSOLE STATE MODIFIED
;	R1 DESTROYED
;--

CON$SENDCONSCMD::
	BISW	#^XF00,R0		; SELECT MISCELLANEOUS CONSOLE COMM.
10$:	MFPR	#PR$_TXCS,R1		; GET TRANSMITTER STATUS
	BBC	#7,R1,10$		; WAIT FOR CONSOLE READY
	CMPB	R0,#CON$C_BOOTCPU	; REBOOT CPU?
	BEQL	30$			; IF SO BRANCH TO HALT AFTER COMMAND
	MTPR	R0,#PR$_TXDB		; OTHERWISE ASSERT COMMAND
20$:	MFPR	#PR$_TXCS,R1		; GET TRANSMITTER STATUS
	BBC	#7,R1,20$		; WAIT FOR CONSOLE DONE
	RSB				; RETURN

30$:	MTPR	R0,#PR$_TXDB		; SEND REBOOT COMMAND TO CONSOLE
	HALT

	.SBTTL	"ALLOCATE" CONSOLE TERMINAL

;++
; CON$OWNCTY - "ALLOCATE" CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED WHEN PERFORMING NON-INTERRUPT DRIVEN
;	I/O TO THE CONSOLE TERMINAL.  IT DISABLES INTERRUPTS AND DOES ANY
;	CPU-SPECIFIC INITIALIZATION OF THE CONSOLE TERMINAL REGISTERS.
;	CON$RELEASECTY SHOULD BE CALLED TO RESTORE THE STATE OF THE CONSOLE
;	TERMINAL INTERFACE REGISTERS.
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;
;	R0:	VALUE TO BE RESTORED TO OPACTIVE FLAG WHEN RELEASING CONSOLE TTY
;	R1:	VALUE TO BE RESTORED TO INTERRUPT CSR WHEN RELEASING CONSOLE TTY
;
;	QVSS IS SET UP SO THAT NON-INTERRUPT I/O CAN BE
;	PERFORMED TO THE CONSOLE TERMINAL.
;
;--
CON$OWNCTY::
	MOVL	G^OPA$IDB+IDB$L_CSR,R0		;GET CSR ADDRESS
	MOVW	QVCSR_CTL(R0),R1		;SAVE INTERRUPT STATE
	BICW	#QVCSR$M_ENA_INT,QVCSR_CTL(R0)	;DISABLE INTERRUPTS
	EXTZV	#OP$V_OPACTIVE,#1,G^OPA$CRB+CRB$L_OPFLAGS,R0;SAVE OPACTIVE FLAG
	RSB

	.SBTTL	RELEASE CONSOLE TERMINAL

;++
; CON$RELEASECTY - RELEASE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO RELINQUISH EXCLUSIVE USE OF THE
;	CONSOLE TERMINAL OBTAINED BY CALLING CON$OWNCTY.  IT RESTORES THE
;	STATE OF THE CONSOLE.
;
; INPUTS:
;	R0:	VALUE RETURNED BY CON$OWNCTY TO BE RESTORED TO OPACTIVE FLAG
;	R1:	VALUE RETURNED BY CON$OWNCTY TO BE RESTORED TO INTERRUPT CSR
;
; OUTPUTS:
;	QVSS AND OPACTIVE FLAG ARE RESTORED TO THEIR ORIGINAL STATE.
;
;--
CON$RELEASECTY::
	INSV	R0,#OP$V_OPACTIVE,#1,G^OPA$CRB+CRB$L_OPFLAGS; RESTORE OPACTIVE FLAG
	MOVL	G^OPA$IDB+IDB$L_CSR,R0		;GET CSR ADDRESS
	MOVW	R1,QVCSR_CTL(R0)		;RESTORE INTERRUPT STATE
	RSB

	.PAGE
	.SBTTL	- GET A CHARACTER FROM THE CONSOLE TERMINAL
;++
; CON$GETCHAR - GET A CHARACTER FROM THE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO DO NON-INTERRUPT DRIVEN I/O
;	DIRECTLY TO THE CONSOLE TERMINAL
;
; INPUTS:
;	None
;
; OUTPUTS:
;	R0 contains the character.
;
;--
	control_s = 19			; control s (xoff)
	control_q = 17			; control q (xon)
	qvuart$m_rxrdy = 1		; receiver ready bit

CON$GETCHAR::
5$:	movl	g^opa$idb+idb$l_csr,r0	;get qvss csr address
10$:	bitw	#qvuart$m_rxrdy,qvcsr_urtstata(r0);receiver ready?
	beql	10$			;if eql not ready
	movzbl	qvcsr_urtbufa(r0),r0	;get character scan code
	bsbw	qvss$keydecode		;decode the lk201 input data
	tstl	r0			;need more input?
	beql	5$			;if eql yes
	rsb				;return

	.PAGE
	.SBTTL	- PUT A CHARACTER OUT ON THE CONSOLE TERMINAL
;++
; CON$PUTCHAR - PUT A CHARACTER TO THE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO DO NON-INTERRUPT DRIVEN I/O
;	DIRECTLY TO THE CONSOLE TERMINAL
;
; INPUTS:
;	R0 - Character to be output
;
; OUTPUTS:
;	Character written to the console terminal.
;
;--
	.enabl	lsb
CON$PUTCHAR::
	pushr	#^m<r1,r2,r3,r4,r5>	;save registers
	moval	g^opa$crb,r3		;get crb address
	bbs	#op$v_opactive,crb$l_opflags(r3),1$;continue if we have control of the qvss
	bbs	#exe$v_opa0,g^exe$gl_wsflags,1$;output to opa0 enabled? bs yes
	brw	80$			;return
1$:	pushl	r0			;save r0
	bbcc	#op$v_reinit,crb$l_opflags(r3),2$;reinit the scan lines?
	movc5	#0,(sp),#0,#24*128*10,@crb$l_video_base(r3); init memory
	moval	g^opa$crb,r3		;get crb address
2$:	bbcc	#op$v_remap,crb$l_opflags(r3),3$;remap scan lines to screen?
	bsbw	remap			;remap scan lines to the screen
3$:	popl	r0			;restore r0
	movl	crb$l_video_base(r3),r3	;get va of video memory
	movl	g^opa$idb+idb$l_csr,r4	;get va of qvss csr
	bsbw	qvss$putchar		;output the character
80$:	popr	#^m<r1,r2,r3,r4,r5>	;restore registers
	rsb				;
	.dsabl	lsb
	.PAGE
	.SBTTL	- INITIALIZE CONSOLE TERMINAL FOR NON-INTERRUPT DRIVEN I/O
;++
; CON$INIT_CTY - INITIALIZE QVSS FOR NON-INTERRUPT DRIVEN I/O
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MUST BE CALLED FROM INIT BEFORE ANY CONSOLE TERMINAL I/O
;	CAN OCCUR.
;
; INPUTS:
;
; OUTPUTS:
;	VIDEO MEMORY MAPPED.
;	I/O SPACE THAT CONATINS THE CSRS FOR QVSS MAPPED.
;
;--
CON$INIT_CTY::				; INITIALIZE QVSS CONTROLLER

	;
	; SAVE REGISTERS
	;
	PUSHR	#^M<R1,R2,R3,R4>

	;
	; INITIALIZE THE KEYBOARD TRANSLATION TABLE
	;
	MOVAL	QVSS$KEY-112,QVSS$KEYTABLE

	;
	; Initialize OPDRVWS1 state flags
	;
	MOVAL	G^OPA$CRB,R3		; GET THE CRB ADDRESS
	MOVL	#OP$M_OPACTIVE,CRB$L_OPFLAGS(R3); OPACTIVE,NOREINIT,NOREMAP,NOVCACTIVE

	;
	; GET VIRTUAL ADDRESS OF CSR IN R4
	;
	MOVL	G^BOO$GL_SPTFREL,R2	; GET A FREE SPT
	INCL	G^BOO$GL_SPTFREL	;
	MOVL	G^MMG$GL_SPTBASE,R1	; GET VA OF SYSTEM SPT BASE
	MOVAL	(R1)[R2],R1		; GET VA OF SPT PTE
	ASHL	#9,R2,R2		; MAKE VA
	BISL	#VA$M_SYSTEM,R2		; SET SYSTEM SPACE BIT
	ADDL3	#QVCSR_BOFF,R2,R4	; CALC CSR VIRTUAL ADDRESS
	MOVL	R4,G^OPA$IDB+IDB$L_CSR	; SAVE IN IDB
	MOVL	#<PTE$M_VALID!PTE$C_KW!QVCSR_PFN>,(R1); MAP PA OF CSR TO SYS VA

	;
	; Map Video Memory
	;
	CLRL	R1			; 
	BICW3	#^C<QVCSR$M_MEMBANK>,(R4),R1; GET BASE QVSS MEMORY BANK
	ASHL	#-QVCSR$V_MEMBANK,R1,R1	; MAKE IT ZERO BASE
	MULL2	#^X40000,R1		; COMPUTE 256K BANK
	ASHL	#-9,R1,R0		; AND ISOLATE PFN
	MOVZWL	#512,R1			; # OF PAGES
	BSBB	MAP_PAGES		; MAP VIDEO RAM
	BLBC	R0,100$			; NO SPTS THEN EXIT
	MOVL	R2,CRB$L_VIDEO_BASE(R3)	; SAVE STARTING VA OF BITMAP
	BSBB	REMAP			; MAP THE SCREEN
	MOVZWL	#SS$_NORMAL,R0		; INDICATE SUCCESS
100$:	POPR	#^M<R1,R2,R3,R4>
	RSB

	.PAGE
	.SBTTL	REMAP - MAP VIDEO RAM TO THE SCREEN
;++
; REMAP
;
; Map the first 24 scan lines to the screen.
;
; Inputs:
;	
;	R3 - CRB Address for OPA0
;
; Outputs:
;	R0,R1,R2 destroyed
;
; Implicit Outputs:
;	Scan lines map video ram to the screen.
;
; Side Effects:
;	None.
;
;--
REMAP:

;	INIT THE SCAN MAP AND MAP SCREEN FULL OF LINES

	ADDL3	#QVSCAN_MAP,CRB$L_VIDEO_BASE(R3),R2; COMPUTE ADDRESS OF SCAN MAP

	TSTL	CRB$L_SCAN_MAP(R3)	; SCAN MAP SAVE AREA?
	BEQL	5$			; IF EQL NO
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC3	#24*10*2,(R2),@CRB$L_SCAN_MAP(R3); SAVE SCAN MAP
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	
5$:	CLRL	R0
	MOVL	#24*10,R1		; NUMBER OF SCAN MAPS
10$:	MOVW	R0,(R2)+	
	INCL	R0
	SOBGTR	R1,10$
	RSB

	.PAGE
	.SBTTL	MAP_PAGES - MAP PHYSICALLY-CONTIGUOUS PAGES
;++
; MAP_PAGES
;
; Map to system virtual address space N physically-contiguous pages.
;
; Inputs:
;	R1 = N = number of physically-contiguous pages
;	R0 = Starting PFN
;
; Outputs:
;	R0 = status: SUCCESS, INSFMEM, INSFSPTS
;	R1 = preserved
;	R2 = system virtual address of N pages of memory if success
;	all other registers preserved
;
; Implicit Outputs:
;	None.
;
; Side Effects:
;	IOC$ALLOSPT called - so SPTs are allocated
;
;--
MAP_PAGES:
	PUSHR	#^M<R1,R3,R4,R5>	; save work registers
					;  r1 = input used as loop counter
					;  r3 = address of SPT
					;  r4 = index into PFN database
					;  r5 = temp storage
	MOVL	R0,R5			; Save starting PFN
	JSB	G^IOC$ALLOSPT		; allocate N SPTs to map VAs
	BLBC	R0,30$			; if LBC, no system page table slots
;
; IOC$ALLOSPT returns:
;	R1 = preserved, R2 = SVPN (index into SPT), R3 = address of SPT
;
; The main loop indexes backwards through the system page table entries
; and backwards through the PFN database.  It goes backwards so that the
; last system virtual address calculated can be returned to the caller.
;
;					;  r0 = index into SPT
	ADDL3	R1,R2,R0		; start at last SPT and go backwards
	ADDL3	R5,R1,R4		; start PFNs at end in loop
10$:					; set up system page-table entry
	DECL	R0			; back up SVPN index
	DECL	R4			; back up PFN index
	MOVL	R4,(R3)[R0]		; fill PFN in SPT
	BISL2	#<PTE$C_UW!PTE$M_VALID>,(R3)[R0] ; user mode access, valid
;
; Invalidate system virtual address
;
	ASHL	#9,R0,R2		; turn SVPN into VA
	BISL2	#<1@31>,R2		; make VA a system VA
	INVALID	R2			; and clear translation buffer
	SOBGTR	R1,10$			; loop N times

	MOVZWL	#SS$_NORMAL,R0		; indicates success (R2 has system VA)
15$:	POPR	#^M<R1,R3,R4,R5>	; restore work registers
	RSB				;
30$:	MOVZWL	#SS$_INSFSPTS,R0	; no SPTs left
	BRB	15$			; return

CON_END:
	.END
