! 
! ****************************************************************************
! *									    *
! *  Copyright (c) 1982, 1983		                                    *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.			    *
! * 									    *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.							    *
! * 									    *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.							    *
! * 									    *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.		    *
! *									    *
! ****************************************************************************
! *********************************************************************************************************************************
!  Created 15-SEP-1984 22:43:59  by  VAX-11 SDL V2.0       Source: 15-SEP-1984 22:43:25 _$255$DUA28:[CJFV4.SRC]JNLDEFINT.SDL;1     
! *********************************************************************************************************************************
 
 
!*** MODULE $CJFFLGDEF ***
! ++
! 
!  CJFFLG - Flags that can be returned from SENSEMODE
! 
! --
literal CJFFLG$M_TAPE = 1;
literal CJFFLG$M_SPOOL = 2;
literal CJFFLG$S_CJFFLGDEF = 1;
macro CJFFLG$V_TAPE = 0,0,1,0 %;        !  this is a tape based journal 
macro CJFFLG$V_SPOOL = 0,1,1,0 %;       !  the tape is being spooled at present 
 
!*** MODULE $JNLBTXDEF ***
! ++
! 
!  JNLBTX -	Journal block transfer 
! 		This structure is used to define the offsets in the
! 		buffer allocated by CNX for our use with a block transfer.
! 
! --
literal JNLBTX$K_LENGTH = 24;           !  Structure size
literal JNLBTX$C_LENGTH = 24;           !  Structure size
literal JNLBTX$S_JNLBTXDEF = 24;
macro JNLBTX$L_JNLBXSTS = 0,0,32,0 %;   !  Address if BXIP for this request
macro JNLBTX$L_RMBLK = 4,0,32,0 %;      !  Address of Remaster block
macro JNLBTX$L_REQCSB = 8,0,32,0 %;     !  Address of requestor's CSB
macro JNLBTX$L_SPARE1 = 12,0,32,0 %;    !  Spare longword 
macro JNLBTX$L_SPARE2 = 16,0,32,0 %;    !  Spare longword 
macro JNLBTX$L_SPARE3 = 20,0,32,0 %;    !  Spare longword 
 
!*** MODULE $JNLDMTDEF ***
! ++
! 
!  JNLDMT - codes for the parameters passed with dismount journal
!            medium. These codes are used to identify the parameters
!            to the Journal ACP, when passed in the complex buffer.
! 
! --
literal JNLDMT$C_DNAM = 1;              !  device name parameter code 
literal JNLDMT$C_DGRPN = 2;             !  group name parameter code 
literal JNLDMT$C_FLAGS = 3;             !  flags value parameter code 
 
!*** MODULE $IOSTSDEF ***
! ++
! 
!  IO status masks. These masks are in the third byte of IRP$L_IOSTS1
!  and are used during a write operation to indicate
!  the properties of the part (chunk) of the entry being written at the time,
!  and the status of the IO request at certain times.
!  The driver is the only one to use this I/O status field.
! 
! --
literal IOSTS$M_FSTCH = 1;
literal IOSTS$M_MULCH = 2;
literal IOSTS$M_SEQNOVF = 4;
literal IOSTS$M_WAITFIO = 8;
literal IOSTS$M_REMOTE = 16;
literal IOSTS$M_RESUB = 32;
literal IOSTS$S_IOSTSDEF = 1;
macro IOSTS$V_FSTCH = 0,0,1,0 %;        !  First entry 
macro IOSTS$V_MULCH = 0,1,1,0 %;        !  Multiple entries 
macro IOSTS$V_SEQNOVF = 0,2,1,0 %;      !  sequence number overflow 
macro IOSTS$V_WAITFIO = 0,3,1,0 %;      !  this IRP is waiting for buffer 
macro IOSTS$V_REMOTE = 0,4,1,0 %;       !  This is an internal IRP and the 
macro IOSTS$V_RESUB = 0,5,1,0 %;        !  this request has not 
!   been resubmitted yet if set
!  operation was started from a remote node
!   write to complete.
 
!*** MODULE $JNLMSGDEF ***
! ++
! 
!  JNLMSG - JNLACP - Driver Cluster Message Definitions
! 
! --
literal JNLMSG$K_HDRLEN = 20;           !  header length 
literal JNLMSG$C_HDRLEN = 20;           !  header length 
literal JNLMSG$C_WRTBUFINF = 1;         !  Write buffer information
literal JNLMSG$C_ALLDEV = 2;            !  Add allocated device to ADL
literal JNLMSG$C_DEALLDEV = 3;          !  Delete allocated device from ADL
literal JNLMSG$C_MNTDEV = 4;            !  Add mounted device to ADL
literal JNLMSG$C_DMNTDEV = 5;           !  Delete mounted device from ADL
literal JNLMSG$C_CRESLVDS = 6;          !  Create slave data structures
literal JNLMSG$S_JNLMSGDEF = 20;
macro JNLMSG$L_FLINK = 0,0,32,0 %;      !  forward link
macro JNLMSG$L_BLINK = 4,0,32,0 %;      !  backward link
macro JNLMSG$W_SIZE = 8,0,16,0 %;       !  size of structure 
macro JNLMSG$B_TYPE = 10,0,8,0 %;       !  structure type
macro JNLMSG$B_SUBTYPE = 11,0,8,0 %;    !  structure sub-type
macro JNLMSG$B_MSG_TYPE = 12,0,8,0 %;   !  message type
macro JNLMSG$L_CSID = 16,0,32,0 %;      !  originator's CSID
! 
!  MESSAGE DEPENDENT EXTENSIONS
! 
!  MESSAGE 1 - Write buffer information
! 
literal JNLMSG$K_MSG1_LEN = 34;         !  Size of fixed part MSG1
literal JNLMSG$C_MSG1_LEN = 34;         !  Size of fixed part MSG1
literal JNLMSG$S_JNLMSGDEF1 = 34;
macro JNLMSG$L_JNL_SEQN = 20,0,32,0 %;  !  Highest jnl seq # written to disk
macro JNLMSG$L_LSEQNO = 24,0,32,0 %;    !  Lowest local seq # outstanding
macro JNLMSG$W_SEQN_TCNT = 28,0,16,0 %; !  total # writes in CWQ for which jnl seq # have been
!   assigned (1 seq # per follows)
macro JNLMSG$W_SEQN_CCNT = 30,0,16,0 %; !  current count of writes in CWQ for which jnl seq # have been
!   assigned (1 seq # per follows)
literal JNLMSG$M_NEWVER = 1;
literal JNLMSG$M_PARTIAL = 2;
literal JNLMSG$K_SEQENTLEN = 8;         !  length of sequence 
literal JNLMSG$C_SEQENTLEN = 8;         !  number information
literal JNLMSG$S_JNLMSGDEF1_SEQN = 8;
! 
!  there is one of these JNLMSGDEF1_SEQN pieces per entry in the CWQ for
!  which a journal seq # has been assigned, in the message
! 
macro JNLMSG$L_SEQ_NUM = 0,0,32,0 %;    !  Entry journal sequence number
macro JNLMSG$L_FLAGS = 4,0,32,0 %;      !  flags longword 
macro JNLMSG$V_NEWVER = 4,0,1,0 %;      !  Last write on a new version request
macro JNLMSG$V_PARTIAL = 4,1,1,0 %;     !  Only part of the entry saved
! 
!  MESSAGE DEPENDENT EXTENSIONS
! 
!  MESSAGE 2, 3, 4, 5, - Update the ADL
! 
literal JNLMSG$K_MSG2_LEN = 44;         !  Size of fixed part MSG2
literal JNLMSG$C_MSG2_LEN = 44;         !  Size of fixed part MSG2
literal JNLMSG$S_JNLMSGDEF2 = 44;
macro JNLMSG$W_STATUS = 20,0,16,0 %;    !  status of device
macro JNLMSG$W_ITMLSTLEN = 22,0,16,0 %; !  Item list length (mount only)
macro JNLMSG$W_ITMLSTOFF = 24,0,16,0 %; !  Offset to item list (mount only)
macro JNLMSG$W_DEVNUM = 26,0,16,0 %;    !  # of dev names which follow 
macro JNLMSG$B_NAMELEN = 28,0,8,0 %;    !  device name length 
macro JNLMSG$B_DEVNAM = 29,0,0,0 %;
literal JNLMSG$S_DEVNAM = 15;           !  device name (ASCII) 
! 
!  MESSAGE DEPENDENT EXTENSIONS
! 
!  MESSAGE 6 - Create slave data structures
!  Each one byte item code in the message is followed by a longword which
!  is either the value or the offset to the information indicated.
! 
literal JNLMSG$C_BLDUCB = 1;            !  Build UCB - item value = journal type
literal JNLMSG$C_UCBDATA = 2;           !  offset to slave UCB data
literal JNLMSG$C_JNLNAM = 3;            !  offset to ASCIC journal name
literal JNLMSG$C_BLDJNLRM = 4;          !  Build a remaster block - no item
literal JNLMSG$C_RMFLGS = 5;            !  JNLRM flags
literal JNLMSG$C_ACPNAM = 6;            !  offset to ASCIC ACP name
literal JNLMSG$C_TAPGRP = 7;            !  offset to ASCIC tape group name
literal JNLMSG$C_DSKINF = 8;            !  offset to ASCIC disk name
literal JNLMSG$C_BLDADL = 9;            !  Build an ADL - no item
literal JNLMSG$C_BLDRUL = 10;           !  Build an RUL - no item
literal JNLMSG$C_MAXDSICOD = 11;        !  Maximum value
literal JNLMSG$C_IENTLEN = 5;           !  Size of item entry
literal JNLMSG$S_JNLMSGDEF6 = 5;
macro JNLMSG$B_ITEMCODE = 0,0,8,0 %;    !  Item code
macro JNLMSG$L_ITEM = 1,0,32,0 %;       !  item information (value or offset)
literal JNLMSG$C_UCBDATALEN = 43;       !  Size of entry
literal JNLMSG$S_JNLMSGDEF6_UCBDATA = 43;
macro JNLMSG$L_OWNUIC = 0,0,32,0 %;     !  Owner UIC
macro JNLMSG$L_MCSID = 4,0,32,0 %;      !  Master CSID
macro JNLMSG$L_DEVCHAR = 8,0,32,0 %;    !  Device characteristics
macro JNLMSG$L_DEVCHAR2 = 12,0,32,0 %;  !  Device characteristics 2
macro JNLMSG$L_JNL_SEQNO = 16,0,32,0 %; !  Journal sequence number
macro JNLMSG$L_JNL_QUOT = 20,0,32,0 %;  !  Quota for RU journals
macro JNLMSG$L_JNL_MASK = 24,0,32,0 %;  !  Mask for AT journals
macro JNLMSG$W_VPROT = 28,0,16,0 %;     !  protection
macro JNLMSG$W_JNL_PROT = 30,0,16,0 %;  !  protection
macro JNLMSG$W_JNL_ID = 32,0,16,0 %;    !  Journal ID
macro JNLMSG$W_JNL_MXENT = 34,0,16,0 %; !  Maximum entry size
macro JNLMSG$W_JNL_MUNIT = 36,0,16,0 %; !  Master unit number
macro JNLMSG$W_DEVSTS = 38,0,16,0 %;    !  Device status
macro JNLMSG$W_STS = 40,0,16,0 %;       !  bits that need duplication on slave
macro JNLMSG$B_AMOD = 42,0,8,0 %;       !  Access mode
 
!*** MODULE $JNLMSGDATADEF ***
! ++
! 
!  JNLMSGDATA - 
! 
! --
literal JNLMSGDATA$C_LENGTH = 32;
literal JNLMSGDATA$K_LENGTH = 32;
literal JNLMSGDATA$S_JNLMSGDATA = 32;
macro JNLMSGDATA$L_FLINK = 0,0,32,0 %;  !  Forward link
macro JNLMSGDATA$L_BLINK = 4,0,32,0 %;  !  Backward link
macro JNLMSGDATA$W_SIZE = 8,0,16,0 %;   !  structure size 
macro JNLMSGDATA$B_TYPE = 10,0,8,0 %;   !  structure type code 
macro JNLMSGDATA$B_SUBTYPE = 11,0,8,0 %; !  structure sub type field
macro JNLMSGDATA$L_VAL1 = 12,0,32,0 %;  !  misc longword of data
macro JNLMSGDATA$L_VAL2 = 16,0,32,0 %;  !  misc longword of data
macro JNLMSGDATA$L_VAL3 = 20,0,32,0 %;  !  misc longword of data
macro JNLMSGDATA$L_VAL4 = 24,0,32,0 %;  !  misc longword of data
macro JNLMSGDATA$L_VAL5 = 28,0,32,0 %;  !  misc longword of data
 
!*** MODULE $WBLDEF ***
! ++
! 
!  WBL - Wait Block List
! 
!  When a thread is being rescheduled all its state is saved in a WBL
! 
! --
literal WBL$K_LENGTH = 72;              !  length structure 
literal WBL$C_LENGTH = 72;              !  length structure 
literal WBL$S_WBLDEF = 72;
macro WBL$L_WBLQFL = 0,0,32,0 %;        !  forward q link 
macro WBL$L_WBLQBL = 4,0,32,0 %;        !  backward q link 
macro WBL$W_SIZE = 8,0,16,0 %;          !  size of structure 
macro WBL$L_STATUS = 12,0,32,0 %;       !  status 
macro WBL$L_ASTBLK = 16,0,32,0 %;       !  address AST Block for rescheduling 
macro WBL$L_IRP = 20,0,32,0 %;          !  IRP address 
macro WBL$W_USTSIZE = 24,0,16,0 %;      !  user stack save block size 
macro WBL$L_UST = 28,0,32,0 %;          !  address user stack save block 
macro WBL$L_USTADDR = 32,0,32,0 %;      !  original start address user stack 
macro WBL$W_KSTSIZE = 36,0,16,0 %;      !  kernel stack save block size 
macro WBL$L_KST = 40,0,32,0 %;          !  address kernel stack save block 
macro WBL$L_KSTADDR = 44,0,32,0 %;      !  original start address kernel stack 
macro WBL$W_OWNSIZE = 48,0,16,0 %;      !  own save block size 
macro WBL$L_OWN = 52,0,32,0 %;          !  address own space save block 
macro WBL$W_GBLSIZE = 60,0,16,0 %;      !  global save block size 
macro WBL$L_GBL = 64,0,32,0 %;          !  address global space save block 
 
!*** MODULE $OPCHDRDEF ***
! ++
! 
!  OPCHDR - OPCOM message header
! 
!  This structure defines the fields in the common OPCOM message
!  header. This data structure is defined in [SYS.SRC]SYSSNDMSG.MAR
!  in the commentary at the top. If this data structure ever changes in that
!  source module, then we need to change it here also.
! 
! --
literal OPCHDR$K_LENGTH = 38;           !  length structure 
literal OPCHDR$C_LENGTH = 38;           !  length structure 
literal OPCHDR$S_OPCHDRDEF = 38;
macro OPCHDR$W_TYPE = 0,0,16,0 %;       !  message type 
macro OPCHDR$W_RMBX = 2,0,16,0 %;       !  reply mailbox channel number 
macro OPCHDR$Q_PRIV = 4,0,0,0 %;
literal OPCHDR$S_PRIV = 8;              !  sender's privilege mask 
macro OPCHDR$L_UIC = 12,0,32,0 %;       !  sender's UIC 
macro OPCHDR$B_USRNAM = 16,0,0,0 %;
literal OPCHDR$S_USRNAM = 12;           !  sender's USERNAME, 12 bytes blank filled 
macro OPCHDR$B_ACCNT = 28,0,0,0 %;
literal OPCHDR$S_ACCNT = 8;             !  sender's ACCOUNT, 8 bytes blank filled 
macro OPCHDR$B_BPRIO = 36,0,8,0 %;      !  sender's base priority 
 
!*** MODULE $ABEDEF ***
! ++
! 
!  ABE - AI-BI List element
! 
!  For each AI or BI journal written to from inside an RU, the journal
!  name is in the AI-List or BI-list (for AI and BI journals resp)
!  This structure is the slot in the list, as used for one journal
! 
! --
literal ABE$M_PURGED = 1;
literal ABE$K_LENGTH = 22;              !  length structure 
literal ABE$C_LENGTH = 22;              !  length structure 
literal ABE$S_ABEDEF = 22;
macro ABE$T_JNLNAME = 0,0,8,0 %;        !  length name 
macro ABE$B_NAME = 1,0,0,0 %;
literal ABE$S_NAME = 18;                !  journal name 
macro ABE$W_STATUS = 19,0,16,0 %;       !  status 
macro ABE$V_PURGED = 19,0,1,0 %;        !  slot not used 
 
!*** MODULE $ABLDEF ***
! ++
! 
!  ABL - AI-BI List
! 
!  For each AI or BI journal written to from inside an RU, the journal
!  name is in the AI-List or BI-list (for AI and BI journals resp)
! 
! --
literal ABL$K_FIXED_LEN = 12;           !  length structure 
literal ABL$C_FIXED_LEN = 12;           !  length structure 
literal ABL$S_ABLDEF = 12;
macro ABL$L_NEXT = 0,0,32,0 %;          !  next ABL 
macro ABL$W_SLOTS = 4,0,16,0 %;         !  number of slots in list 
macro ABL$W_JNLS = 6,0,16,0 %;          !  number of journals in list 
macro ABL$W_SIZE = 8,0,16,0 %;          !  size structure 
macro ABL$B_STRUCT = 10,0,8,0 %;        !  structure type
macro ABL$B_TYPE = 10,0,8,0 %;          !  data type field
macro ABL$B_SUBTYPE = 11,0,8,0 %;       !  CJF subtype field
 
!*** MODULE $ADBDEF ***
! ++
! 
!  ADB - Allocated Device Block
! 
!  For each disk or tape device allocated by a Journal ACP, the
!  ADL off the UCB for the ACP Control Journal contains a ADB
!  (Allocated Device Block). The ADB contains the device name
!  and some control information
! 
! --
literal ADB$M_MNTALLOC = 1;
literal ADB$M_MOUNTED = 2;
literal ADB$M_PURGED = 4;
literal ADB$K_LENGTH = 28;              !  length structure 
literal ADB$C_LENGTH = 28;              !  length structure 
literal ADB$S_ADBDEF = 28;
macro ADB$L_LINK = 0,0,32,0 %;          !  link to next ADB in same volume set 
macro ADB$W_STATUS = 4,0,16,0 %;        !  status of device and this ADB 
macro ADB$V_MNTALLOC = 4,0,1,0 %;       !  allocated during MOUNT 
macro ADB$V_MOUNTED = 4,1,1,0 %;        !  device is mounted 
macro ADB$V_PURGED = 4,2,1,0 %;         !  this ADB is available 
macro ADB$B_NAMELEN = 12,0,8,0 %;       !  device name length 
macro ADB$B_DEVNAM = 13,0,0,0 %;
literal ADB$S_DEVNAM = 15;              !  device name (ASCII) 
 
!*** MODULE $ADLDEF ***
! ++
! 
!  ADL - Allocated Device List
! 
!  For each disk or tape device allocated by a Journal ACP, the
!  ADL off the UCB for the ACP Control Journal contains a ADB
!  (Allocated Device Block).
! 
! --
literal ADL$K_FIXED_LEN = 24;           !  length fixed portion 
literal ADL$C_FIXED_LEN = 24;           !  length fixed portion 
literal ADL$K_START_ADB = 24;           !  Start of list. 
literal ADL$C_START_ADB = 24;           !  Start of list. 
literal ADL$S_ADLDEF = 24;
macro ADL$L_LINK = 0,0,32,0 %;          !  link to next ADL for this ACP (only 
!   for first ADL, not for extensions)
macro ADL$L_UCB = 4,0,32,0 %;           !  backpointer to UCB 
macro ADL$W_SIZE = 8,0,16,0 %;          !  size of list (ADL+ADBs in this ADL) 
macro ADL$B_TYPE = 10,0,8,0 %;          !  data structure type 
macro ADL$B_SUBTYPE = 11,0,8,0 %;       !  CJF subtype field
macro ADL$L_EXTEND = 12,0,32,0 %;       !  next ADL extension 
macro ADL$W_DEVCNT = 16,0,16,0 %;       !  device count: ! of devices allocated 
!   in this ADL
macro ADL$W_ADBCNT = 18,0,16,0 %;       !  number of ADBs in this ADL 
macro ADL$W_FSTADB = 20,0,16,0 %;       !  offset first ADB, from this location 
 
!*** MODULE $BCBDEF ***
! ++
! 
!  BCB - Buffer Control Block
! 
!          For each mounted journal there are two buffers pointed to by the
!          BCB which is pointed to by the journal UCB. The BCB always describes
!          the characteristics and status of these buffers
! 
! --
literal BCB$M_CUR = 1;
literal BCB$M_IOPR = 1;
literal BCB$M_WRPR = 2;
literal BCB$M_WRPEN = 4;
literal BCB$M_REPR = 8;
literal BCB$M_REAPEN = 16;
literal BCB$M_EXTPR = 32;
literal BCB$M_EXTPEN = 64;
literal BCB$M_RECLE = 128;
literal BCB$M_SETPEN = 256;
literal BCB$M_NWVPR = 512;
literal BCB$K_LENGTH = 80;              !  length of structure 
literal BCB$C_LENGTH = 80;              !  length of structure 
literal BCB$S_BCBDEF = 80;
macro BCB$L_ADDR1 = 0,0,32,0 %;         !  address of buffer 1 
macro BCB$L_ADDR2 = 4,0,32,0 %;         !  address of buffer 2 
macro BCB$W_SIZE = 8,0,16,0 %;          !  structure size 
macro BCB$B_TYPE = 10,0,8,0 %;          !  structure type code 
macro BCB$B_SUBTYPE = 11,0,8,0 %;       !  subtype field for CJF
macro BCB$B_STS = 12,0,8,0 %;           !  status code 
macro BCB$V_CUR = 12,0,1,0 %;           !  current buffer indicator 
macro BCB$L_UCB = 16,0,32,0 %;          !  UCB address of journal 
macro BCB$W_BSIZ1 = 20,0,16,0 %;        !  size of buffer 1 in bytes 
macro BCB$W_BSIZ2 = 22,0,16,0 %;        !  size of buffer 2 in bytes 
macro BCB$W_STS1 = 24,0,16,0 %;         !  status of buffer 1 
macro BCB$V_IOPR = 24,0,1,0 %;          !  I/O in progress bit 
macro BCB$V_WRPR = 24,1,1,0 %;          !  write in progress bit 
macro BCB$V_WRPEN = 24,2,1,0 %;         !  write pending bit 
macro BCB$V_REPR = 24,3,1,0 %;          !  read in progress bit 
macro BCB$V_REAPEN = 24,4,1,0 %;        !  read pending bit 
macro BCB$V_EXTPR = 24,5,1,0 %;         !  extend in progress 
macro BCB$V_EXTPEN = 24,6,1,0 %;        !  extend pending 
macro BCB$V_RECLE = 24,7,1,0 %;         !  buffer read and cleared bit 
macro BCB$V_SETPEN = 24,8,1,0 %;        !  "set-buffer-to-next-one" pending 
macro BCB$V_NWVPR = 24,9,1,0 %;         !  create new version in progress 
macro BCB$W_STS2 = 26,0,16,0 %;         !  status of buffer 2 
macro BCB$W_WRCNT1 = 28,0,16,0 %;       !  write count for first buffer 
macro BCB$W_WRCNT2 = 30,0,16,0 %;       !  write count for second buffer 
macro BCB$W_RDCNT1 = 32,0,16,0 %;       !  read count for first buffer 
macro BCB$W_RDCNT2 = 34,0,16,0 %;       !  read count for second buffer 
macro BCB$W_OFFS1 = 36,0,16,0 %;        !  offset first free byte in buffer 1 
macro BCB$W_OFFS2 = 38,0,16,0 %;        !  offset first free byte in buffer 2 
macro BCB$L_VBN1 = 40,0,32,0 %;         !  first VBN buffer 1 
macro BCB$L_VBN2 = 44,0,32,0 %;         !  first VBN buffer 2 
macro BCB$L_PRVVBN = 48,0,32,0 %;       !  VBN bucket in which previous chunk is 
macro BCB$L_PRVEVBN = 52,0,32,0 %;      !  VBN bucket in which previous entry is 
macro BCB$W_PRVOFF = 56,0,16,0 %;       !  offset of previous chunk written 
macro BCB$W_PRVEOFF = 58,0,16,0 %;      !  offset of previous entry written 
macro BCB$L_LOWSN = 60,0,32,0 %;        !  lowest seq.no in current buffer 
macro BCB$L_HISN = 64,0,32,0 %;         !  highest seq.no of any entry written 
!  into the buffers
macro BCB$L_CRCTBL = 68,0,32,0 %;       !  address of CRC table 
macro BCB$L_HISN_CMPL = 72,0,32,0 %;    !  High sequence number completely in a buffer
macro BCB$L_HISN_WRT = 76,0,32,0 %;     !  High sequence number written
!    to secondary storage
 
!*** MODULE $JNLACBMDEF ***
! ++
! 
!  JNLACBM - Journal access bit map
! 
! 	This bit map will contain a single bit for each node in
! 	the cluster.  When ever a slave node assigns his first
! 	journal to the journal or deassigns his last journal channel
! 	the node bit will be adjusted.  This bit map will be indexed
! 	via the node index portion of the node's CSID
! --
literal JNLACBM$K_LENGTH = 14;          !  Size of JNLACBM header
literal JNLACBM$S_JNLACBMDEF = 14;
macro JNLACBM$L_FLINK = 0,0,32,0 %;     !  Forward link
macro JNLACBM$L_BLINK = 4,0,32,0 %;     !  Backward link
macro JNLACBM$W_SIZE = 8,0,16,0 %;      !  structure size 
macro JNLACBM$B_TYPE = 10,0,8,0 %;      !  structure type code 
macro JNLACBM$B_SUBTYPE = 11,0,8,0 %;   !  structure sub type field
macro JNLACBM$W_MAPSIZE = 12,0,16,0 %;  !  Bit map size
macro JNLACBM$X_BITMAP = 14,0,0,0 %;    !  Bit map start
 
!*** MODULE $JNLBUFDEF ***
! ++
! 
!  JNLBUF - Buffer of which there are two for each journal
! 
!  The BCB pointed to by the journal UCB points to the two buffers
! 
! --
literal JNLBUF$M_USER = 1;
literal JNLBUF$M_CONTR = 2;
literal JNLBUF$M_UPDATE = 1;
literal JNLBUF$K_HDRLEN = 40;           !  length header 
literal JNLBUF$C_HDRLEN = 40;           !  length header 
literal JNLBUF$K_STDAT = 40;            !  first longword of data 
literal JNLBUF$C_STDAT = 40;            !  first longword of data 
literal JNLBUF$S_JNLBUFDEF = 40;
macro JNLBUF$W_LEN = 0,0,16,0 %;        !  total length of buffer header minus 
!   length of this word (RMS seq. record)
macro JNLBUF$W_LEN2 = 2,0,16,0 %;       !  second word of length (only for tape) 
macro JNLBUF$B_TYPE = 4,0,8,0 %;        !  record type to indicate control entry 
macro JNLBUF$V_USER = 4,0,1,0 %;        !  user entry 
macro JNLBUF$V_CONTR = 4,1,1,0 %;       !  control entry 
macro JNLBUF$B_BUFHDR = 5,0,8,0 %;      !  buffer header length 
macro JNLBUF$W_BUFSIZ = 8,0,16,0 %;     !  buffer size : this MUST be 1st word 
!         in 3rd longword
macro JNLBUF$B_STRUCT = 10,0,8,0 %;     !  data structure type value : this MUST 
!         be 3rd byte in 3rd longword
macro JNLBUF$B_DTYPE = 10,0,8,0 %;      !  data type field
macro JNLBUF$B_ENTTYP = 11,0,8,0 %;     !  entry type 
macro JNLBUF$B_SUBTYPE = 11,0,8,0 %;    !  data subtype field
macro JNLBUF$L_VBN = 12,0,32,0 %;       !  journal block number (of 1st. bl in bucket) 
macro JNLBUF$W_LSTENO = 16,0,16,0 %;    !  last entry/chunk in bucket - offset 
macro JNLBUF$L_JNLID = 20,0,32,0 %;     !  journal ID 
macro JNLBUF$L_LOWSN = 24,0,32,0 %;     !  lowest sequence number of all entries 
!   in this bucket
macro JNLBUF$L_HISN = 28,0,32,0 %;      !  highest sequence number of all entries 
!   in this bucket
macro JNLBUF$W_CDPTR = 32,0,16,0 %;     !  current data pointer (! of data bytes 
!   written for BI,AI,AT and next byte
!   to write for RU jnl)
macro JNLBUF$W_STS = 34,0,16,0 %;       !  buffer status 
macro JNLBUF$V_UPDATE = 34,0,1,0 %;     !  this buffer has been updated 
macro JNLBUF$L_CHKSUM = 36,0,32,0 %;    !  CRC of bucket 
 
!*** MODULE $JNLBXSTSDEF ***
! ++
! 
!  JNLBXSTS -	Journal block transfer in procress queue entry
! 		This structure is used to keep track of all pertenant
! 		information concerning an IRP that has been initiated
! 		on the local node via a block transfer request from 
! 		some other node.  If the connection between the two
! 		nodes breaks before the local node has sent the response
! 		then the the message may be retransmitted and we must be
! 		able to deal with that.  Hopefully this structure will
! 		contain all the information we will need.
! 
! --
literal JNLBXSTS$M_READCMPL = 1;
literal JNLBXSTS$M_READINP = 2;
literal JNLBXSTS$M_WRITECMPL = 4;
literal JNLBXSTS$M_WRITEINP = 8;
literal JNLBXSTS$M_RESPSENT = 16;
literal JNLBXSTS$M_FNCTCMPL = 32;
literal JNLBXSTS$M_CNXBRK = 64;
literal JNLBXSTS$K_LENGTH = 44;         !  Structure size
literal JNLBXSTS$C_LENGTH = 44;         !  Structure size
literal JNLBXSTS$S_JNLBXSTSDEF = 44;
macro JNLBXSTS$L_FLINK = 0,0,32,0 %;    !  Forward link 
macro JNLBXSTS$L_BLINK = 4,0,32,0 %;    !  Backward link 
macro JNLBXSTS$W_SIZE = 8,0,16,0 %;     !  size data structure
macro JNLBXSTS$B_TYPE = 10,0,8,0 %;     !  type of structure
macro JNLBXSTS$B_SUBTYPE = 11,0,8,0 %;  !  subtype of structure
macro JNLBXSTS$L_STS = 12,0,32,0 %;     !  block Xfer status
macro JNLBXSTS$V_READCMPL = 12,0,1,0 %; !  The block read is complete
macro JNLBXSTS$V_READINP = 12,1,1,0 %;  !  The block read is in progress
macro JNLBXSTS$V_WRITECMPL = 12,2,1,0 %; !  The block write is complete
macro JNLBXSTS$V_WRITEINP = 12,3,1,0 %; !  The block write is in progress
macro JNLBXSTS$V_RESPSENT = 12,4,1,0 %; !  The response has been sent
macro JNLBXSTS$V_FNCTCMPL = 12,5,1,0 %; !  The function is complete (no response sent)
macro JNLBXSTS$V_CNXBRK = 12,6,1,0 %;   !  The connection has broken
macro JNLBXSTS$L_REQ_CSID = 16,0,32,0 %; !  CSID of node which originated
!   the message (requestor)
macro JNLBXSTS$W_REQ_CSID_SEQ = 16,0,16,0 %; !  CSID sequence number
macro JNLBXSTS$W_REQ_CSID_IDX = 18,0,16,0 %; !  CSID node index
macro JNLBXSTS$L_BTXSEQNO = 20,0,32,0 %; !  Block transfer sequence #
macro JNLBXSTS$L_CURR_IRP = 24,0,32,0 %; !  Address of the current IRP
macro JNLBXSTS$L_RTX_IRP = 28,0,32,0 %; !  Address of IRP from last retransmit
macro JNLBXSTS$L_SPARE1 = 32,0,32,0 %;
macro JNLBXSTS$L_SPARE2 = 36,0,32,0 %;
macro JNLBXSTS$L_SPARE3 = 40,0,32,0 %;
 
!*** MODULE $JNLCWQDEF ***
! ++
! 
!  JNLCWQ -	Journal cluster write queue entry
! 		This structure is used to keep track of all
! 		writes that have been sent from a slave to the master
! 		node but have not yet been written to secondary storage.
! 		During fail over of a node this information is necessary
! 		to resubmit the write's for the user.  Once we have
! 		told the user that the write is complete we must make
! 		sure that it makes it out to the file unless the node
! 		it was issued from crashes
! 
! --
literal JNLCWQ$M_RESUB = 1;
literal JNLCWQ$C_FIXED_LEN = 96;        !  Fixed size
literal JNLCWQ$K_FIXED_LEN = 96;        !  Fixed size
literal JNLCWQ$S_JNLCWQDEF = 96;
macro JNLCWQ$L_FLINK = 0,0,32,0 %;      !  Forward link 
macro JNLCWQ$L_BLINK = 4,0,32,0 %;      !  Backward link 
macro JNLCWQ$W_SIZE = 8,0,16,0 %;       !  size data structure
macro JNLCWQ$B_TYPE = 10,0,8,0 %;       !  type of structure
macro JNLCWQ$B_SUBTYPE = 11,0,8,0 %;    !  subtype of structure
macro JNLCWQ$L_UCB = 12,0,32,0 %;       !  Back pointer to the UCB
macro JNLCWQ$L_FOVRSTAT = 16,0,32,0 %;  !  fail-over status
macro JNLCWQ$V_RESUB = 16,0,1,0 %;      !  this entry must be resubmitted if set
macro JNLCWQ$L_SEND_CSID = 20,0,32,0 %; !  CSID of node we originally
!   sent the message to
macro JNLCWQ$W_SEND_CSID_SEQ = 20,0,16,0 %; !  CSID sequence number
macro JNLCWQ$W_SEND_CSID_IDX = 22,0,16,0 %; !  CSID node index
macro JNLCWQ$W_SEND_UNIT = 24,0,16,0 %; !  Unit number of original
!   master journal device
macro JNLCWQ$W_IOFUNC = 26,0,16,0 %;    !  Original I/O function
macro JNLCWQ$L_IRP = 28,0,32,0 %;       !  Address of the IRP.  We may
!   still have to post it at failover
macro JNLCWQ$L_SEQNO = 32,0,32,0 %;     !  Entry's sequence # (0 in not ACK'd)
macro JNLCWQ$L_LSEQNO = 36,0,32,0 %;    !  Entry's local sequence #
macro JNLCWQ$L_BEGIN_OFFSET = 40,0,32,0 %; !  Beginning offset of remaining
!   portion of a partial write
macro JNLCWQ$W_BYTCNT_REM = 44,0,16,0 %; !  Bytes remaining for partial write
macro JNLCWQ$W_BYTCNT_ORG = 46,0,16,0 %; !  Original count of bytes in message
macro JNLCWQ$O_RUID = 48,0,0,0 %;
literal JNLCWQ$S_RUID = 16;             !  Recovery unit ID.
macro JNLCWQ$L_WRUFLAGS = 64,0,32,0 %;  !  Write RU flags.
macro JNLCWQ$L_WRMASK = 68,0,32,0 %;    !  Write mask
macro JNLCWQ$L_IRPESTATUS = 72,0,32,0 %; !  status field kept in IRPE
macro JNLCWQ$L_ASID = 76,0,32,0 %;      !  Assign ID for the channel
macro JNLCWQ$W_FACCOD = 80,0,16,0 %;    !  Channel facility code
macro JNLCWQ$B_IOSTS = 82,0,8,0 %;      !  I/O status (used only for writes)
macro JNLCWQ$B_WRATR = 83,0,8,0 %;      !  Write attributes
macro JNLCWQ$L_EPID = 84,0,32,0 %;      !  Process EPID
macro JNLCWQ$Q_ARB_PRIV = 88,0,0,0 %;
literal JNLCWQ$S_ARB_PRIV = 8;          !  Priv mask from ARB
macro JNLCWQ$T_MSGBUF = 96,0,0,0 %;     !  Base of journal entry in a message
 
!*** MODULE $JNLDBDEF ***
! ++
! 
!  JNLDB - off of each CDT is hung a data block that serves as
!           a queue listhead for remote IRP's waiting on a response
!           for a connection, a queue listhead for the slave UCB's
!           that access the master node via that CDT, and a pointer
!           to a buffer that contains entries written to the master
!           (via the CDT) but whose QIOs have not yet been ACK'd
!           by the master. This structure is used for master
!           failover recovery.
! --
literal JNLDB$K_LENGTH = 28;
literal JNLDB$C_LENGTH = 28;
literal JNLDB$S_JNLDBDEF = 28;
macro JNLDB$L_IRPQFL = 0,0,32,0 %;      !  IRP queue forward link 
macro JNLDB$L_IRPQBL = 4,0,32,0 %;      !  IRP queue backward link 
macro JNLDB$W_SIZE = 8,0,16,0 %;        !  size data structure
macro JNLDB$B_TYPE = 10,0,8,0 %;        !  type of structure
macro JNLDB$B_SUBTYPE = 11,0,8,0 %;     !  subtype of structure
macro JNLDB$L_UCBQFL = 12,0,32,0 %;     !  UCB queue forward link 
macro JNLDB$L_UCBQBL = 16,0,32,0 %;     !  UCB queue backward link 
macro JNLDB$L_BUFFER = 20,0,32,0 %;     !  Pointer to write buffer 
 
!*** MODULE $JNLLOGDEF ***
! ++
! 
!  JNLLOG - Journal error log function bits
! 
!  This structure defines the bits indicating to SYE the error
!  being logged
! 
! --
literal JNLLOG$M_RUEXT = 1;
literal JNLLOG$M_RUNEXT = 2;
literal JNLLOG$M_SLVCRFAIL = 4;
literal JNLLOG$S_JNLLOGDEF = 1;
macro JNLLOG$V_RUEXT = 0,0,1,0 %;       !  RU journal extended 
macro JNLLOG$V_RUNEXT = 0,1,1,0 %;      !  RU journal could not be extended 
macro JNLLOG$V_SLVCRFAIL = 0,2,1,0 %;   !  Failure on slave node while
!   attempting a create
 
!*** MODULE $JNLRCDEF ***
! ++
! 
!  JNLRC - Journaling Read Context
! 
!  The JNLRC holds the information necessary for read failover.
! 
! --
literal JNLRC$M_READDIR = 1;
literal JNLRC$K_LENGTH = 40;            !  length fixed part
literal JNLRC$C_LENGTH = 40;            !  length fixed part
literal JNLRC$S_JNLRCDEF = 40;
macro JNLRC$W_SIZE = 8,0,16,0 %;        !  size of structure 
macro JNLRC$B_TYPE = 10,0,8,0 %;        !  data structure type
macro JNLRC$B_SUBTYPE = 11,0,8,0 %;     !  CJF subtype
macro JNLRC$L_SEQNO = 12,0,32,0 %;      !  seq # previous entry
macro JNLRC$O_RUID = 16,0,0,0 %;
literal JNLRC$S_RUID = 16;              !  Recovery unit ID (RU only)
macro JNLRC$Q_DATTIM = 16,0,0,0 %;
literal JNLRC$S_DATTIM = 8;             !  date/time prev. entry (NONRU ONLY)
macro JNLRC$L_CSID = 24,0,32,0 %;       !  CSID portion of RUID,
macro JNLRC$W_CSID_SEQ = 24,0,16,0 %;   !  CSID sequence number
macro JNLRC$W_CSID_IDX = 26,0,16,0 %;   !  CSID node index
macro JNLRC$L_RUID_LW4 = 28,0,32,0 %;   !  Forth longword of RUID
macro JNLRC$B_FLAGS = 32,0,8,0 %;       !  Flags
macro JNLRC$V_READDIR = 32,0,1,0 %;     !  Read direction
macro JNLRC$L_FLTRS = 36,0,32,0 %;      !  Offset to filters
 
!*** MODULE $JNLRMDEF ***
! ++
! 
!  JNLRM - Journaling Remaster Block
! 
!  The JNLRM is used by the CSP to construct a JSB for remastering a journal.
! 
! --
literal JNLRM$M_DSKJNL = 1;
literal JNLRM$M_TAPJNL = 2;
literal JNLRM$M_TMPFIL = 4;
literal JNLRM$M_DIFACP = 8;
literal JNLRM$K_LENGTH = 24;            !  length fixed part
literal JNLRM$C_LENGTH = 24;            !  length fixed part
literal JNLRM$K_DSKJNLLST = 24;         !  start info for disk jnls
literal JNLRM$C_DSKJNLLST = 24;         !  - dev names, ver #'s
literal JNLRM$K_TAPJNLLEN = 28;         !  length for tape journal
literal JNLRM$C_TAPJNLLEN = 28;         !  length for tape journals
literal JNLRM$S_JNLRMDEF = 28;
macro JNLRM$W_SIZE = 8,0,16,0 %;        !  size of structure 
macro JNLRM$B_TYPE = 10,0,8,0 %;        !  data structure type
macro JNLRM$B_SUBTYPE = 11,0,8,0 %;     !  subtype for CJF data structure
macro JNLRM$W_FLAGS = 12,0,16,0 %;      !  flags word 
macro JNLRM$V_DSKJNL = 12,0,1,0 %;      !  Disk journal
macro JNLRM$V_TAPJNL = 12,1,1,0 %;      !  Tape journal
macro JNLRM$V_TMPFIL = 12,2,1,0 %;      !  Temp file
macro JNLRM$V_DIFACP = 12,3,1,0 %;      !  Different ACP
macro JNLRM$B_COPIES = 14,0,8,0 %;      !  number of copies
macro JNLRM$L_CONBLK = 16,0,32,0 %;     !  address of the 1st connect block
macro JNLRM$W_ACPNAMOFF = 20,0,16,0 %;  !  offset to ACP name
macro JNLRM$W_ACPNAMLEN = 22,0,16,0 %;  !  ACP name length
macro JNLRM$W_TAPGRPOFF = 24,0,16,0 %;  !  offset to tape group name
macro JNLRM$W_TAPGRPLEN = 26,0,16,0 %;  !  tape group name length
literal JNLRM$K_DSKENTLEN = 8;          !  length of disk journal
literal JNLRM$C_DSKENTLEN = 8;          !  information
literal JNLRM$S_JNLRM1DEF = 8;
macro JNLRM$W_DEVNAMOFF = 0,0,16,0 %;   !  offset to device name
macro JNLRM$W_DEVNAMLEN = 2,0,16,0 %;   !  device name length
macro JNLRM$W_FILVEROFF = 4,0,16,0 %;   !  offset to file version
macro JNLRM$W_FILVERLEN = 6,0,16,0 %;   !  file version length
 
!*** MODULE $JNLSFTDEF ***
! +
!  JNLSFT -- Spool File Table
! 
!         The JNLSFT describes the physical storage medium for the journal spool
!         file. Spool files are used for tape groups only.
!         The JNLSFTs for a given tape group are linked together in a list.
!         The first JNLSFT is pointed to by each JMT for each tape in the group.
! 
! -
literal JNLSFT$K_ACPQB = 12;            !  label for ACP queue block 
literal JNLSFT$C_ACPQB = 12;            !  label for ACP queue block 
literal JNLSFT$M_HEAD_SFT = 1;
literal JNLSFT$M_ACTIVE = 2;
literal JNLSFT$K_LENGTH = 84;           !  length 
literal JNLSFT$C_LENGTH = 84;           !  length 
!   spool file. (spool file is used as
!   tape, but we must keep track of VBN)
literal JNLSFT$S_JNLSFTDEF = 84;
macro JNLSFT$L_FORJNLLNK = 0,0,32,0 %;  !  Forward link for JMT's for this journal 
macro JNLSFT$L_BACJNLLNK = 4,0,32,0 %;  !  Backward link for JMT's for this journal 
macro JNLSFT$W_SIZE = 8,0,16,0 %;       !  size of JNLSFT 
macro JNLSFT$B_TYPE = 10,0,8,0 %;       !  structure type of JNLSFT 
macro JNLSFT$B_SUBTYPE = 11,0,8,0 %;    !  structure subtype of JNLSFT 
macro JNLSFT$L_FORACPLNK = 12,0,32,0 %; !  Forward link to next JMT for this ACP 
macro JNLSFT$L_BACACPLNK = 16,0,32,0 %; !  Backward link to next JMT for this ACP 
macro JNLSFT$L_JMT = 20,0,32,0 %;       !  First JMT in list of JMTs for group 
!   for which this is a spool file
macro JNLSFT$B_SPL_COP = 24,0,8,0 %;    !  number of spool files in list 
macro JNLSFT$W_MAX_JNLS = 28,0,16,0 %;  !  max ! of journals for this spool file 
macro JNLSFT$W_COPY_NUM = 30,0,16,0 %;  !  number of spool file (zero relative) 
macro JNLSFT$W_WRCNT = 32,0,16,0 %;     !  write count 
macro JNLSFT$W_RDCNT = 34,0,16,0 %;     !  read count 
macro JNLSFT$L_STATUS = 36,0,32,0 %;    !  journal media status 
macro JNLSFT$V_HEAD_SFT = 36,0,1,0 %;   !  first JNLSFT (copy) for this group 
macro JNLSFT$V_ACTIVE = 36,1,1,0 %;     !  spool file not empty: being used 
macro JNLSFT$L_BASEVBN = 40,0,32,0 %;   !  Base VBN: to be substracted from bucket 
!   VBN to get VBN of block in file
macro JNLSFT$L_SPL_WCB = 44,0,32,0 %;   !  pointer to journal spool file WCB 
macro JNLSFT$L_SPL_UCB = 48,0,32,0 %;   !  pointer to journal spool file UCB 
macro JNLSFT$L_SPL_MXVBN = 52,0,32,0 %; !  max VBN in journal disk spool file 
macro JNLSFT$L_SPL_STVBN = 56,0,32,0 %; !  first VBN in journal disk spool file 
macro JNLSFT$W_SPL_NUM = 60,0,16,0 %;   !  journal spool file file ID number 
macro JNLSFT$W_SPL_SEQ = 62,0,16,0 %;   !  journal spool file file ID sequence number 
macro JNLSFT$W_SPL_RVN = 64,0,16,0 %;   !  journal spool file file ID rel vol num 
macro JNLSFT$B_VOLLAB = 68,0,0,0 %;
literal JNLSFT$S_VOLLAB = 12;           !  volume label disk on which file is 
macro JNLSFT$L_SPL_VBN = 80,0,32,0 %;   !  next VBN for next bucket to write to 
 
!*** MODULE $JMTDEF ***
! +
!  JMT -- Journal Merge Table
! 
!         The JMT describes the physical storage medium for the journal copy.
!         The JMT is pointed to by each VCB.  When multiple journals are
!         kept on the same storage medium (ie multiple journals on one
!         tape), there exists one JMT for the tape, and many VCB's may
!         point to it.
! 
!  All bits marked (*) are set in the head JMT (first in list) only
!   in the current version.
! 
! -
literal JMT$K_ACPQB = 12;               !  label for ACP queue block 
literal JMT$C_ACPQB = 12;               !  label for ACP queue block 
literal JMT$M_REPR = 1;
literal JMT$M_EOTPR = 2;
literal JMT$S_JMTDEF = 48;
macro JMT$L_FORJNLLNK = 0,0,32,0 %;     !  Forward link for JMT's for this journal 
macro JMT$L_BACJNLLNK = 4,0,32,0 %;     !  Backward link for JMT's for this journal 
macro JMT$W_SIZE = 8,0,16,0 %;          !  size of JMT 
macro JMT$B_TYPE = 10,0,8,0 %;          !  structure type of JMT 
macro JMT$B_SUBTYPE = 11,0,8,0 %;       !  structure subtype of JMT 
macro JMT$L_FORACPLNK = 12,0,32,0 %;    !  Forward link to next JMT for this ACP 
macro JMT$L_BACACPLNK = 16,0,32,0 %;    !  Backward link to next JMT for this ACP 
macro JMT$B_ACP_PRI = 20,0,8,0 %;       !  ACP's priority (priority for I/O) 
macro JMT$L_ACP_ARB = 24,0,32,0 %;      !  pointer to ACP access rights block 
macro JMT$L_AQB = 28,0,32,0 %;          !  address of AQB for owner ACP 
macro JMT$W_MAX_JNLS = 32,0,16,0 %;     !  max ! of journals for this JMT 
macro JMT$W_COPY_NUM = 36,0,16,0 %;     !  copy number (zero relative) 
macro JMT$W_JNLIDCTR = 38,0,16,0 %;     !  journal ID counter 
macro JMT$W_WRCNT = 40,0,16,0 %;        !  write count 
macro JMT$W_RDCNT = 42,0,16,0 %;        !  read count 
macro JMT$B_SPOOLING = 44,0,8,0 %;      !  spool byte: if any of these bits is 
!   set, spooling must be done.
macro JMT$V_REPR = 44,0,1,0 %;          !  read in progress 
macro JMT$V_EOTPR = 44,1,1,0 %;         !  EOT processing going on (*) 
literal JMT$M_SPLBYTE = 255;
literal JMT$M_WRPR = 256;
literal JMT$M_NOWRJNL = 512;
literal JMT$M_HEAD_JMT = 1024;
literal JMT$M_SPOOLED = 2048;
literal JMT$M_SPOOLSYNC = 4096;
literal JMT$M_STARTSP = 8192;
literal JMT$M_STOPSP = 16384;
literal JMT$M_CANCELIO = 32768;
literal JMT$M_DMT = 65536;
literal JMT$M_AVL = 131072;
literal JMT$M_SYNCHCAN = 262144;
literal JMT$M_REPEN = 524288;
literal JMT$M_INFPEN = 1048576;
literal JMT$M_NOWRTP = 2097152;
literal JMT$K_LENGTH = 178;             !  length label 
literal JMT$C_LENGTH = 178;             !  length label 
literal JMT$S_JMTDEF1 = 178;
macro JMT$L_STATUS = 44,0,32,0 %;       !  journal media status 
macro JMT$V_SPLBYTE = 44,0,8,0 %;
literal JMT$S_SPLBYTE = 8;              !  spool byte 
macro JMT$V_WRPR = 44,8,1,0 %;          !  write in progress (currently unused) 
macro JMT$V_NOWRJNL = 44,9,1,0 %;       !  cannot write to journal now (not 
macro JMT$V_HEAD_JMT = 44,10,1,0 %;     !  first JMT (copy) for this journal 
macro JMT$V_SPOOLED = 44,11,1,0 %;      !  device is spooled (*) 
macro JMT$V_SPOOLSYNC = 44,12,1,0 %;    !  all io to journal file (incl spool 
macro JMT$V_STARTSP = 44,13,1,0 %;      !  start spooling (*) 
macro JMT$V_STOPSP = 44,14,1,0 %;       !  stop spooling (*) 
macro JMT$V_CANCELIO = 44,15,1,0 %;     !  cancel IO to tape (*) 
macro JMT$V_DMT = 44,16,1,0 %;          !  this copy is marked for dismount 
macro JMT$V_AVL = 44,17,1,0 %;          !  this copy is available 
macro JMT$V_SYNCHCAN = 44,18,1,0 %;     !  synchronize with CANCELIO on tape (*) 
macro JMT$V_REPEN = 44,19,1,0 %;        !  read pending 
macro JMT$V_INFPEN = 44,20,1,0 %;       !  inform ACP pending (*) 
macro JMT$V_NOWRTP = 44,21,1,0 %;       !  do not write to tape: ACP stops driver 
!      file) must wait: switching back or
!      forth between tape and spool file
!      (*)
!      even spool file)
macro JMT$L_JMTSFT = 48,0,32,0 %;       !  the JMT or SFT on which an error 
!   ocurred (*)
macro JMT$L_SPARE1 = 52,0,32,0 %;
macro JMT$L_SPARE2 = 56,0,32,0 %;
macro JMT$L_SPARE3 = 60,0,32,0 %;
macro JMT$L_SPARE4 = 64,0,32,0 %;
macro JMT$L_OWNUIC = 68,0,32,0 %;       !  owner UIC 
macro JMT$W_PROT = 72,0,16,0 %;         !  protection mask 
macro JMT$L_BASEVBN = 76,0,32,0 %;      !  base VBN first bucket (add to file VBN to get bucket VBN) 
macro JMT$L_FIL_WCB = 80,0,32,0 %;      !  pointer to journal file WCB 
macro JMT$L_FIL_UCB = 84,0,32,0 %;      !  pointer to journal file UCB 
macro JMT$L_FIL_MXVBN = 88,0,32,0 %;    !  max VBN in journal disk file 
macro JMT$L_FIL_STVBN = 92,0,32,0 %;    !  first VBN in journal disk file 
macro JMT$L_FIL_LTVBN = 96,0,32,0 %;    !  last VBN for this file 
macro JMT$W_FIL_NUM = 100,0,16,0 %;     !  journal file file ID number 
macro JMT$W_FIL_SEQ = 102,0,16,0 %;     !  journal file file ID sequence number 
macro JMT$W_FIL_RVN = 104,0,16,0 %;     !  journal file file ID rel vol num 
macro JMT$T_VOLLAB = 108,0,0,0 %;
literal JMT$S_VOLLAB = 13;              !  volume label disk/tape on which file is 
macro JMT$T_GRPNAM = 122,0,0,0 %;
literal JMT$S_GRPNAM = 13;              !  group name 
macro JMT$L_GTB = 136,0,32,0 %;         !  address of corresponding GTB in ACP 
!         virtual memory
macro JMT$L_JFTE = 140,0,32,0 %;        !  address of corresponding JFTE in ACP 
!         virtual memory
macro JMT$L_SFT = 144,0,32,0 %;         !  first SFT (spool file table) 
macro JMT$L_SPL_VBN = 148,0,32,0 %;     !  next VBN for next bucket to write to 
!   spool file. (spool file is used as
!   tape, but we must keep track of VBN)
macro JMT$W_VCB_COUNT = 152,0,16,0 %;   !  number of VCB's pointing to JMT 
!     (not including VCB_CNTRL)
macro JMT$L_VCB_CNTRL = 156,0,32,0 %;   !  address of control VCB (tape only) 
macro JMT$L_WQFL = 160,0,32,0 %;        !  wait Q forward link 
macro JMT$L_WQBL = 164,0,32,0 %;        !  wait Q backward link 
macro JMT$L_VCL = 168,0,32,0 %;         !  list of addresses associated VCB's 
macro JMT$T_FILVER = 172,0,0,0 %;
literal JMT$S_FILVER = 6;               !  file version number
 
!*** MODULE $NDLDEF ***
! ++
! 
!  NDL - Name table Device List
! 
!  This structure has a fixed header size but the tail end is a variable
!  length depending on how many name table device names are in it.
! 
! --
literal NDL$K_FIXEDLEN = 16;            !  fixed size length 
literal NDL$C_FIXEDLEN = 16;            !  fixed size length 
literal NDL$S_NDLDEF = 16;
macro NDL$L_NDLQFL = 0,0,32,0 %;        !  forward q link 
macro NDL$L_NDLQBL = 4,0,32,0 %;        !  backward q link 
macro NDL$W_SIZE = 8,0,16,0 %;          !  size of structure 
macro NDL$B_TYPE = 10,0,8,0 %;          !  structure type for NDL 
macro NDL$B_SUBTYPE = 11,0,8,0 %;       !  structure subtype
macro NDL$B_COUNT = 12,0,8,0 %;         !  count 
 
!*** MODULE $RUEDEF ***
! ++
! 
!  RUE - Recovery Unit list Element
!  The Recovery Unit list contains one of these elements per recovery
!  unit active on the RU journal. The RUEs follow the RUL, which is pointed
!  to by the RU-journal's UCB. When the journal device is created a fixed
!  size list is allocated: for the RUL and a number of RUEs. When the list needs
!  to be extended, it is replaced by a longer one.
! 
! --
literal RUE$K_LENGTH = 48;              !  length of RUE 
literal RUE$C_LENGTH = 48;              !  length of RUE 
literal RUE$M_PURGED = 1;
literal RUE$M_ROLL_BACK = 2;
literal RUE$M_ROLL_FORW = 4;
literal RUE$M_NOT_FLSHD = 8;
literal RUE$M_OVER_QUOTA = 16;
literal RUE$M_PHASE1 = 32;
literal RUE$M_PHASE2 = 64;
literal RUE$M_ABORT = 128;
literal RUE$M_P2$AB$2 = 256;
literal RUE$M_RESIDUAL = 512;
literal RUE$M_COMPLETED = 1024;
literal RUE$M_CLEANUP = 2048;
literal RUE$M_FROZEN = 4096;
literal RUE$M_RUSYNCEX = 8192;
literal RUE$M_RUSYNCWR = 16384;
literal RUE$M_NOFAC = 32768;
literal RUE$M_NOOBJ = 65536;
literal RUE$S_RUEDEF = 48;
macro RUE$Q_RUID = 0,0,0,0 %;
literal RUE$S_RUID = 16;                !  RU ID 
macro RUE$L_RUID_LW1 = 0,0,32,0 %;      !  First longword of RUID
macro RUE$L_RUID_LW2 = 4,0,32,0 %;      !  second longword of RUID
macro RUE$L_CSID = 8,0,32,0 %;          !  CSID portion of RUID,
macro RUE$W_CSID_SEQ = 8,0,16,0 %;      !  CSID sequence number
macro RUE$W_CSID_IDX = 10,0,16,0 %;     !  CSID node index
macro RUE$L_RUID_LW4 = 12,0,32,0 %;     !  Forth longword of RUID
macro RUE$L_LSTVBN = 16,0,32,0 %;       !  VBN of bucket with last entry written 
macro RUE$W_LSTOFF = 20,0,16,0 %;       !  offset of last entry written 
macro RUE$W_JNLCNT = 22,0,16,0 %;       !  count of journals touched by RU 
macro RUE$L_INDEX = 24,0,32,0 %;        !  unique index for this RUE 
macro RUE$L_SEQNO = 28,0,32,0 %;        !  sequence number last entry written 
macro RUE$L_FSTEVBN = 32,0,32,0 %;      !  VBN of first entry written 
macro RUE$L_FSTVBN = 36,0,32,0 %;       !  VBN of first roll forw. entry written 
macro RUE$L_QUOTA = 40,0,32,0 %;        !  remaining number of bytes allowed to write 
macro RUE$L_STATUS = 44,0,32,0 %;       !  status 
macro RUE$V_PURGED = 44,0,1,0 %;        !  entry is free indicator 
macro RUE$V_ROLL_BACK = 44,1,1,0 %;     !  there is at least one roll back entry 
macro RUE$V_ROLL_FORW = 44,2,1,0 %;     !  there is at least one roll forward entry 
macro RUE$V_NOT_FLSHD = 44,3,1,0 %;     !  there is at least one entry not flushed 
macro RUE$V_OVER_QUOTA = 44,4,1,0 %;    !  quota exceeded 
macro RUE$V_PHASE1 = 44,5,1,0 %;        !  phase1 done 
macro RUE$V_PHASE2 = 44,6,1,0 %;        !  phase2 done 
macro RUE$V_ABORT = 44,7,1,0 %;         !  abort done 
macro RUE$V_P2$AB$2 = 44,8,1,0 %;       !  phase2 or abort entry to be encountered 2* 
macro RUE$V_RESIDUAL = 44,9,1,0 %;      !  this is a residual RU in journal 
macro RUE$V_COMPLETED = 44,10,1,0 %;    !  RU has been completed (rolled forward) 
macro RUE$V_CLEANUP = 44,11,1,0 %;      !  vestigial entry for RU can be ignored 
macro RUE$V_FROZEN = 44,12,1,0 %;       !  frozen RU 
macro RUE$V_RUSYNCEX = 44,13,1,0 %;     !  RUSYNC entry expected
macro RUE$V_RUSYNCWR = 44,14,1,0 %;     !  RUSYNC entry written
macro RUE$V_NOFAC = 44,15,1,0 %;        !  Frozen due to missing facility
macro RUE$V_NOOBJ = 44,16,1,0 %;        !  Frozen due to missing object
!   before RU deletion
 
!*** MODULE $RULDEF ***
! ++
! 
!  RUL - Recovery Unit List
! 
!  This data structure forms the header of the list with the recovery
!  units that are currently active on the RU-journal for which this
!  list is used. The UCB of a RU journal points to the RUL for it.
! 
! --
literal RUL$K_FIXED_LEN = 12;           !  length of RUL fixed portion 
literal RUL$C_FIXED_LEN = 12;           !  length of RUL fixed portion 
literal RUL$S_RULDEF = 12;
macro RUL$W_NUM_RUES = 0,0,16,0 %;      !  number of RUEs in the list 
macro RUL$W_SIZE = 8,0,16,0 %;          !  size of total list (RUL+all RUEs) 
macro RUL$B_TYPE = 10,0,8,0 %;          !  data structure type 
macro RUL$B_SUBTYPE = 11,0,8,0 %;       !  data structure subtype 
 
!*** MODULE $VCLDEF ***
! +
!  VCL - VCB List
! 
!  The VCL contains the VCB addresses of VCBs of journals that have been
!  created for a given tape group. The JMT of the head-JMT for that group
!  points to this VCL.
! 
! -
literal VCL$K_FIXED_LEN = 12;
literal VCL$C_FIXED_LEN = 12;
literal VCL$S_VCLDEF = 12;
macro VCL$L_JMT = 0,0,32,0 %;           !  JMT back pointer 
macro VCL$W_NUM_VLES = 4,0,16,0 %;      !  number of VLEs in VCL 
macro VCL$W_COUNT = 6,0,16,0 %;         !  number of VCB addresses in VCL 
macro VCL$W_SIZE = 8,0,16,0 %;          !  size of structure 
macro VCL$B_TYPE = 10,0,8,0 %;          !  type of data structure 
macro VCL$B_SUBTYPE = 11,0,8,0 %;       !  subtype of data structure 
 
!*** MODULE $VLEDEF ***
! +
!  VLE - VCB List element
! 
!  The VCL contains the VCB addresses of VCBs of journals that have been
!  created for a given tape group. The JMT of the head-JMT for that group
!  points to this VCL. The VCL contains VLEs, each of which, when in use,
!  points to a VCB.
! 
! -
literal VLE$M_PURGED = 1;
literal VLE$K_LENGTH = 8;
literal VLE$C_LENGTH = 8;
literal VLE$S_VLEDEF = 8;
macro VLE$W_STATUS = 0,0,16,0 %;        !  status 
macro VLE$V_PURGED = 0,0,1,0 %;
macro VLE$L_VCB = 4,0,32,0 %;           !  VCB address 
