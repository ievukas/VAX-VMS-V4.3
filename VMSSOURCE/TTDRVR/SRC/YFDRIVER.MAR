	.TITLE	YFDRIVER - Port Driver for DHU/DHV
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	DHU/DHV ASYNC PORT DRIVER
;
; AUTHOR:
;
;	RICK SPITZ/ANDREW PALKA
;
; Revision history:
;
;	V03-004	LMP0275		L. Mark Pilant,		12-Jul-1984  21:05
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-003 EMD0097		Ellen M. Dusseault	30-Apr-1984
;		Fix a few bugs - device timeout problem and test the
;		abort flag first to see if it is necessary to clear it.
;		Also add DEV$M_NNM characteristic to DEVCHAR2 so that
;		these devices will have the prefix "node$".
;
;	V03-002	TMH0002		Tim Halvorsen		14-Apr-1984
;		Fix references to UCB$L_OWNUIC and UCB$W_VPROT to use ORB.
;
;	V03-001	EMD0070		Ellen M. Dusseault		30-MAR-1984
;		Modify to make code more efficient.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; EXTERNAL DEFINITIONS:
;
	$PRDEF
	$ACBDEF				; DEFINE ACB
	$CRBDEF				; DEFINE CRB
	$DCDEF				; DEFINE ADAPTER TYPES
	$DDBDEF				; DEFINE DDB
	$DEVDEF				; DEFINE DEVICE TYPES
	$DYNDEF				; DEFINE DYNAMIC STRUCTURE TYPES
	$IDBDEF				; DEFINE IDB OFFSETS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IRPDEF				; DEFINE IRP
	$ORBDEF				; DEFINE OBJECT RIGHTS BLOCK
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL TYPES
	$TT2DEF				; DEFINE EXTENDED CHARACTERISTICS
	$TQEDEF				; DEFINE TIMER QUEUE OFFSETS
	$UCBDEF				; DEFINE UCB
	$UBADEF				; DEFINE UBA
	$VECDEF				; DEFINE VECTOR FOR CRB
	$TTYMACS			; DEFINE TERMINAL DRIVER MACROS
	$TTYDEFS			; DEFINE TERMINAL DRIVER SYMBOLS
	$TTYMODEM			; DEFINE MODEM DEFINITIONS



;
; LOCAL STORAGE
;
	.PSECT	$$$105_PROLOGUE

;
; Driver prologue table:
;

;
; Note. The DPT says that this driver has a UBA adapter type.
; In fact it will work with a Q-bus VAX, either mapped or unmapped
;
YF$DPT::				; DRIVER START
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=YF$END,-		; End and offset to INIT's vectors
		UCBSIZE=UCB$C_TT_LENGTH+4,- ; SIZE OF UCB
		FLAGS=DPT$M_NOUNLOAD,-	; NO UNLOAD ALLOWED
		ADAPTER=UBA,-		; ADAPTER TYPE
		MAXUNITS=16,-		; Number of units to create
		DEFUNITS=16,-		; Number of units to create
		NAME=YFDRIVER,-		; NAME OF DRIVER
		VECTOR=PORT_VECTOR,-	; PORT DRIVER VECTOR TABLE
		DELIVER=YF$DELIVER	; Unit delivery routine
	DPT_STORE INIT
	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-; CHARACTERISTICS
			DEV$M_REC!-	;
			DEV$M_AVL!-	;
			DEV$M_IDV!-	;
			DEV$M_ODV!-	;
			DEV$M_TRM!-	;
			DEV$M_CCL>
    	DPT_STORE UCB,UCB$L_DEVCHAR2,L,- ; DEVICE CHARACTERISTICS
   			<DEV$M_NNM>	 ; PREFIX WITH "NODE$"
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM;
	DPT_STORE UCB,UCB$B_TT_DETYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_TT_DESIZE,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_TT_DECHAR,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_TT_DECHA1,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_DESPEE,@B,TTY$GB_DEFSPEED; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_DESPEE+1,@B,TTY$GB_RSPEED; DEFAULT RSPEED
	DPT_STORE UCB,UCB$B_TT_DEPARI,@B,TTY$GB_PARITY	; DEFAULT PARITY
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_DEVDEPND2,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_SPEED,@B,TTY$GB_DEFSPEED	; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_SPEED+1,@B,TTY$GB_RSPEED	; DEFAULT RSPEED
	DPT_STORE UCB,UCB$B_DIPL,B,21			; DEVICE IPL
	DPT_STORE UCB,UCB$L_TT_WFLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_WBLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_RTIMOU,L,0		; Zero read timed out disp.
	DPT_STORE ORB,ORB$B_FLAGS,B,-			; Protection block flags
			   <ORB$M_PROT_16>		; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,@W,TTY$GW_PROT 	; Default allocation protection
	DPT_STORE ORB,ORB$L_OWNER,@L,TTY$GL_OWNUIC	; Default owner UIC
	DPT_STORE DDB,DDB$L_DDT,D,YF$DDT
	DPT_STORE REINIT
	DPT_STORE CRB,CRB$L_INTD+4,D,YF$INTINP	; RECEIVER INTERRUPT
	DPT_STORE CRB,CRB$L_INTD2+4,D,YF$INTOUT	; TRANSMITTER INTERRUPT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,YF$INITIAL  ; CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,YF$INITLINE; UNIT INIT

	DPT_STORE END

	DDTAB	DEVNAM = YF,-	; DUMMY DHU PORT DRIVER DISPATCH TABLE
		START  = 0,-
		FUNCTB = 0
	.PSECT	$$$115_DRIVER,LONG

;
; THE ASSOCIATED CLASS DRIVER USES THIS TABLE TO COMMAND THE PORT DRIVER.
; THE ADDRESS OF THIS TABLE IS CONTAINED IN THE TERMINAL UCB EXTENSION AREA.
; THE OFFSET DEFINITONS ARE DEFINED BY TTYDEFS.
;
YF$L_SIL_ERROR::
	.LONG	0			; Indicates Silo not empty at interrupt
YF$L_ERROR::
	.LONG	0			; Indicates DMA count non zero at
					; interrupt
YF$L_DMAXMT_ERROR::
	.LONG	0			; Indicates DMA error bit set by DHU
YF$L_INACT_ERROR::
	.LONG	0			; Indicates UCB$M_INT clear at interrupt
PORT_VECTOR:			

;
; DHU/DHV SPECIFIC DISPATCH TABLE
;
	$VECINI	YF,YF$NULL
	$VEC	STARTIO,YF$STARTIO		; START NEW OUTPUT
	$VEC	SET_LINE,YF$SET_LINE		; SET NEW SPEED/PARITY
	$VEC	DS_SET,YF$DS_SET		; SET OUTPUT MODEM SIGNALS
	$VEC	XON,YF$XON			; SEND XON SEQUENCE
	$VEC	XOFF,YF$XOFF			; SEND XOFF SEQUENCE
	$VEC	STOP,YF$STOP			; STOP OUTPUT
	$VEC	ABORT,YF$ABORT			; ABORT OUTPUT IN PROGRESS
	$VEC	RESUME,YF$RESUME		; RESUME STOPPED OUTPUT
	$VEC	MAINT,YF$MAINT			; INVOKE MAINTENANCE FUNCTION
	$VEC	FORKRET,YF$FORK			; PORT FORK CALLBACK
	$VECEND

;
YF$NULL:					; NULL PORT ROUTINE
	RSB

	.PAGE
	.SBTTL	REGISTER DEFINITIONS
 

DHUCSR	=	0				; Base CSR
DHURBF	=	2				; Received data fifo
DHUTXC	=	2				; DHV single char register
DHUTCR	=	2				; DHU timer control
DHULPR	=	4				; Line parameters
DHUTXF	=	6				; Transmit FIFO
DHUTFS	=	6				; Transmit FIFO size
DHUSTT	=	7				; Modem status
DHULCT	=	8				; Line control
DHUTBF1	=	10				; low bits of address
DHUTBF2	=	12				; High bits of address
DHUTCT	=	14				; Byte count

;
; CSR BIT DEFINITIONS ( CSR ) ( READ/WRITE )
; (NOTE: THIS REGISTER MUST ONLY BE READ IN RESPONSE TO A TRANSMIT INTERRUPT.
;	TO LOAD AN INDIRECT REGISTER, ONLY WRITE OPERATIONS MAY BE USED.
;	READ-MODIFY-WRITE OPERATIONS MUST NEVER BE USED)
       
	$VIELD	DHUCSR,0,<-
		<IADDR,4,M>,-	; INDIRECT REGISTER ADDRESS
		<,1,>,-		; DON'T USE THIS BIT
		<CLEAR,1,M>,-	; MASTER RESET
		<RCVINT,1,M>,-	; RECEIVER INTERRUPT ENABLE
		<,1,>,-		; DON'T USE THIS BIT
		<LINE,4,M>,-	; LINE NUMBER (0 - 15)
		<DMAERR,1,M>,-  ; DMA error
		<DIGFAL,1,M>,-  ; Diagnostic failed
		<SNDINT,1,M>,-	; TRANSMIT INTERRUPT ENABLE
		<SNDRDY,1,M>-	; TRANSMITTER READY
		> 
;
; RECEIVER BUFFER ( CSR+2 ) ( READ ONLY )
;
	$VIELD	DHURCV,0,<-
		<BUF,8,M>,-	; RECEIVER DATA
		<LINE,4,M>,-	; LINE NUMBER (0 - 7)
		<PARERR,1,M>,-	; PARITY ERROR
		<FRAMER,1,M>,-	; FRAME ERROR
		<OVERRUN,1,M>,-	; OVERRUN ERROR
		<VALID,1,M>-	; DATA VALID
		> 
;
; LINE PARAMETER REGISTER ( CSR+4 , Indirect register)
;
 
	$VIELD	DHULPR,0,<-
		<,1,>,-		; DON'T USE THIS BIT
		<DIAG1,1,M>,-	; Diagnostics control
		<DIAG2,1,M>,-	; Diagnostics control
		<SIZE,2,M>,-	; CHARACTER SIZE
		<PARITY,1,M>,-	; PARITY ENABLE
		<ODD,1,M>,-	; ODD PARITY
		<STOP,1,M>,-	; NUMBER STOP BITS
		<RSPEED,4,M>,-	; RECEIVER LINE SPEED
		<TSPEED,4,M>,-	; TRANSMITTER LINE SPEED (BOTH RVC/TX FOR LINES 2-7)
		>
;
; LINE CONTROL INDIRECT REGISTER (CSR + 8, Indirect register)
;

	$VIELD	DHULCT,0,<-
		<ABORT,1,M>,-	; Output abort
		<OAUTO,1,M>,-	; AUTO XON/OFF 
		<RCV,1,M>,-	; RECEIVER ENABLE
		<BREAK,1,M>,-	; SEND BREAK
		<IAUTO,1,M>,-	; Incoming Auto flow enable
		<SNDOFF,1,M>,-	; Send XOFF
		<MAINT,2,M>,-	; Maintenance
		<MODEM,1,M>,-	; Modem control line
		<DTR,1,M>,-	; Data terminal ready
		<,2,>,-
		<RTS,1,M>,-	; Request to send
		>
;
; Status register
	$VIELD	DHUSTT,0,<-
		<,3,>,-
		<CTS,1,M>,-
		<DCD,1,M>,-
		<RI,1,M>,-
		<,1,>,-
		<DSR,1,M>,-
		>

; Constant value for Base CSR
; Enables both receive and transmit interrrupts

DHUCSR$C_BASE =	<DHUCSR$M_RCVINT!DHUCSR$M_SNDINT>
;
; MACRO USED TO ACCESS INDIRECT REGISTERS
;

	.MACRO	SETIND	REG
	.IF	B,	REG
	MOVL	UCB$L_CRB(R5),R0			; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0		; GET CSR ADDRESS
	BISW3	#<DHUCSR$C_BASE>,-
				UCB$W_UNIT(R5),DHUCSR(R0); SELECT INDIRECT FIELD
	.IFF
	BISW3	#<DHUCSR$C_BASE>,-
				UCB$W_UNIT(R5),DHUCSR(REG); SELECT INDIRECT FIELD
	.ENDC	
	.ENDM	SETIND

;
; Extra field in UCB
; This field could be removed if 2 spare bits can be found in the UCB for
; the use of the port driver. (This would save 4 bytes from the declared length
; of the UCB)

UCB$B_DHUFLG	= UCB$C_TT_LENGTH	; Allocate at end of previous ucb

	$VIELD	UCB,0,<-
		<MAP,1,M>,-	; Map registers available if 1
		<DHU,1,M>,-	; DHU if 1, DHV if 0
    		<XOFF,1,M>,-	; XOFF if 1, XON if 0
		>

;	OUTPUT DELAY MACRO
;	TO RELEASE THE UNIBUS

	.MACRO	DELAY
	.REPEAT	3
	NOP
	.ENDR
	.ENDM

	.page
	.sbttl	SPEED CONVERSION TABLES

;
; macro to generate table of acceptable speeds for DHU/DHV
;
	.MACRO	SPDCONV	BAUD
.=yf$vms_speeds+tt$c_'baud'
	.byte dhuspd$c_'baud'
.=yf$dhu_speeds+dhuspd$c_'baud'
	.byte tt$c_'baud'
	.ENDM

;
; speed values recognized by the DHU/DHV
;
DHUSPD$C_BAUD_50=0
DHUSPD$C_BAUD_75=1
DHUSPD$C_BAUD_110=2
DHUSPD$C_BAUD_134=3
DHUSPD$C_BAUD_150=4
DHUSPD$C_BAUD_300=5
DHUSPD$C_BAUD_600=6
DHUSPD$C_BAUD_1200=7
DHUSPD$C_BAUD_1800=8
DHUSPD$C_BAUD_2000=9
DHUSPD$C_BAUD_2400=10
DHUSPD$C_BAUD_4800=11
DHUSPD$C_BAUD_7200=12
DHUSPD$C_BAUD_9600=13
DHUSPD$C_BAUD_19200=14
DHUSPD$C_BAUD_38400=15

; Allocate and initialize table of speed values
YF$VMS_SPEEDS:
	.REPEAT	16
	.BYTE	-1			; Initial to illegal value
	.ENDR
YF$DHU_SPEEDS:
	.REPEAT 16
	.BYTE   0			;  Initial to zero
	.ENDR	

; Now build up the table of acceptable speed values

	SPDCONV	BAUD_75
	SPDCONV	BAUD_110
	SPDCONV	BAUD_134
	SPDCONV	BAUD_150
	SPDCONV	BAUD_300
	SPDCONV	BAUD_600
	SPDCONV	BAUD_1200
	SPDCONV	BAUD_1800
	SPDCONV	BAUD_2000
	SPDCONV	BAUD_2400
	SPDCONV	BAUD_4800
	SPDCONV	BAUD_9600
	SPDCONV	BAUD_19200
	.page
	.SBTTL	CONTROLLER INITIALIZATION 



;++
; YF$DELIVER - Unit delivery routine
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AT SYSTEM STARTUP
;
; It checks the device to see if the specified unit number exists.
; This is necessary as the DHV has 8 lines, while the DHU has 16
;
; INPUTS:
;
;	R4 = ADDRESS OF THE CONTROLLER CSR
;	R5 = Unit number
;
; OUTPUTS:
;
;	R0 = 1 if unit exists
;	   = 0 if unit does not exist
;
; IMPLICIT INPUTS:
;
;
;--
YF$DELIVER::
	CMPL	R5,#16
	BGEQ	10$			; exit if unit too large
	MOVW	(R4),R0			; Read base CSR
	BBS	#DHUCSR$V_CLEAR,R0,10$	; controller bad
	BBS	#DHUCSR$V_DIGFAL,R0,10$	; controller bad
;
; Note. If controller has not passed self test then we cannot rely on
; the value read from DHUSTT

	MOVB	DHUSTT(R4),R0		; get status byte
	BLBS	R0,5$			; low bit indicates DHU
	CMPL	R5,#8			; DHV has only 8 lines
	BGEQ	10$
5$:	
	MOVL	#1,R0			; unit exists
	BRB	20$
10$:
	CLRL	R0			; unit does not exist
20$:
	RSB
	.page
	.SBTTL	CONTROLLER INITIALIZATION 



;++
; YF$INITIAL - INITIALIZE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AT SYSTEM STARTUP AND POWER RECOVERY.
;
; INPUTS:
;
;	R4 = ADDRESS OF THE UNIT CSR
;	R5 = IDB OF UNIT
;	R8 = ADDRESS OF THE UNIT CRB
;
; OUTPUTS:
;
;	R2 is destroyed.
;
; IMPLICIT INPUTS:
;
;	IPL = IPL$_POWER
;
;--
YF$INITIAL::				; INITIALIZE DHU UNIT
;
; SET UP CONTROLLER
;
	CLASS_CTRL_INIT YF$DPT,PORT_VECTOR; RELOCATE THE NECESSARY TABLES
25$:
;
; Note. The DHV takes about 2 seconds to initialise
; and the DHU up to 5
; so we assume that initialization has taken place
; We could start the initialization and then do a 'skip self test'
; operation to bring the self test time down to a few milliseconds,
; however we would not then know if the board was good or not.
;

	BITW	#DHUCSR$M_CLEAR,(R4)
	BNEQ	26$				; dont do reset if still there
	MOVW	#DHUCSR$M_CLEAR,(R4)		; CONTROLLER RESET
26$:
;
;	WAIT TILL CONTROLLER INITIALIZATION IS COMPLETE
;
;	5 second wait here !!!
;
	TIMEWAIT	#500000,#DHUCSR$M_CLEAR,(R4),W,.FALSE.


	BLBC	R0,YF$CTRL_ERROR
	BITW	#DHUCSR$M_DIGFAL,(R4)
	BEQL	90$
	MOVW	#0,R0			; failed self test, dont use
	BRB	YF$CTRL_ERROR
90$:
	MOVW	#DHUCSR$C_BASE,(R4)	; set up base csr value


100$:
	MOVB	#DT$_DHV,CRB$B_TT_TYPE(R8)	; CONTROLLER IS DHV
	MOVB	DHUSTT(R4),R0			; test for DHU or DHV
	BLBC	R0,110$				; DHV does not have silo timeout
	MOVB	G^TTY$GB_SILOTIME,DHUTCR(R4)	; INIT INPUT SILO TIMEOUT VALUE
	MOVB	#DT$_DHU,CRB$B_TT_TYPE(R8)	; CONTROLLER IS DHU
110$:
	MOVL	#SS$_NORMAL,R0
	RSB

YF$CTRL_ERROR:
	RSB
	
	.PAGE
	.SBTTL	UNIT INITIALIZATION

; YF$INITLINE - UNIT INITIALIZATION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS A SIMPLE UNIT INITIALIZATION.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R4,R5 ARE PRESERVED.
;--

YF$INITLINE::				
	MOVAL	YF$VEC,R0		; GET THE DISPATCH TABLE ADDRESS
	CLASS_UNIT_INIT
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5); SET ONLINE

	ASHL	UCB$W_UNIT(R5),#1,R3	; BUILD UNIT'S BIT MASK
	MOVW	R3,UCB$W_TT_UNITBIT(R5)	; SAVE IT
    	MOVB	G^TTY$GB_PARITY,UCB$B_TT_PARITY(R5)
    					; STORE TERMINAL'S PARITY VALUE IN UCB
	BISW	#TTY$M_PC_DMAAVL!TTY$M_PC_XOFAVL,-; SHOW DMA FEATURE AVAILABLE FOR USE
		UCB$W_TT_PRTCTL(R5)	; IN PORT LEVEL

	MOVL	UCB$L_TT_CLASS(R5),R1	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R1)	; INIT UCB FIELDS

;
; Perform check to see if device is good
;
	PUSHR	#^M<R4,R5>
	MOVL	UCB$L_CRB(R5),R4			; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4		; GET CSR ADDRESS
	MOVZWL	UCB$W_UNIT(R5),R5
	JSB	YF$DELIVER			; test this device is ok
	POPR	#^M<R4,R5>
	BLBS	R0,11$
;
; DHU is in a bad way, set device offline
;
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5); SET OFFLINE
11$:
; Test to see the type of configuration
;
	CLRB	UCB$B_DHUFLG(R5)
	SETIND
	BISB	#UCB$M_DHU,UCB$B_DHUFLG(R5); Assume DHU
	MOVB	DHUSTT(R0),R0		; test if DHU or DHV
	BLBS	R0,12$	
;
; Note. The DHV always interrupts at BR4
; This becomes IPL 20 on a VAX
;
	MOVB	#20,UCB$B_DIPL(R5)
	BICB	#UCB$M_DHU,UCB$B_DHUFLG(R5); Actually its a DHV

12$:
;
; Find out what kind of machine the device is connected to.
; This tells us what kind of mapping registers we have
;
	CPUDISP	<-
		YF_INITMAP,-		; 11/780
		YF_INITMAP,-		; 11/750
		YF_INITMAP,-		; 11/730
		YF_INITMAP,-		; 11/790
		YF_INITNULL,-		; unknown
		YF_INITNULL,-		; unknown
		YF_NOMAP,-		; Seahorse
		YF_INITMAP-		; Mayflower
		>	
; Unknown processor type
YF_INITNULL:
;
; prevent DMA being used, because we do not understand how the adapter
; works.
;
	BICW	#TTY$M_PC_DMAAVL,-; SHOW DMA FEATURE NOT AVAILABLE FOR USE
		UCB$W_TT_PRTCTL(R5)	; IN PORT LEVEL

	BRB	INIT_CONTINUE
; These processors have map registers for DMA operation
YF_INITMAP:

	BISB	#UCB$M_MAP,UCB$B_DHUFLG(R5)
	BRB	INIT_CONTINUE

; These processors do not have map registers

YF_NOMAP:
; No bits set

INIT_CONTINUE:
;
;SET MODE CODE NEEDS TO TOGGLE THESE BITS

	JSB	YF$SET_LINE		; INIT SPEED/PARITY

;
; ENABLE LINE RECEIVER , TRANSMITTER AND MODEM INTERRUPTS
;

	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),20$	; TEST ONLINE
	SETIND	R4
	CLRB	DHUTBF2+1(R4)			; assume transmitter should
						; be disabled
	BISW	#DHULCT$M_ABORT,DHULCT(R4)	; assume abort to be set

	BBS	#UCB$V_TT_DSBL,UCB$B_TT_MAINT(R5),20$	; Test if disabled

	BISW	#DHULCT$M_RCV!DHULCT$M_MODEM,DHULCT(R4)	; enable receiver and modem
	BICW	#DHULCT$M_ABORT,DHULCT(R4)	; clear abort bit
	MOVB	#^X80,DHUTBF2+1(R4)		; enable transmitter
20$:
;
; INIT RECEIVER MODEM STATUS FOR DHU
;
	
	MOVB	DHUSTT(R4),R0
;
; Unfortunately the DHU/DHV dont put the modem bits where we want them
; To get the correct bits we have to move RI,DCD,CTS up one place, while not
; changing DSR. spare bits have to be ignored.
	ADDL	R0,R0			; (This shifts DSR out of bottom byte)
	BICB	#^C<TT$M_DS_RING!TT$M_DS_CTS!TT$M_DS_CARRIER>,R0
	MOVB	R0,UCB$B_TT_DS_RCV(R5)	; UPDATE CURRENT INPUT MODEM SIGNALS
	BBC	#DHUSTT$V_DSR+1,R0,25$
	BBSS	#TT$V_DS_DSR,UCB$B_TT_DS_RCV(R5),25$
25$:
	MOVZBL	#MODEM$C_INIT,R1	; ASSUME INIT MODEM PROTOCOL
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_DS_TRAN(R0)	; INVOKE TO INIT MODEM PROTOCOL
30$:
	BBC	#UCB$V_POWER,UCB$W_STS(R5),40$; DID WE DETECT A POWER FAIL
	MOVL	UCB$L_TT_CLASS(R5),R0	; GET THE CLASS VECTOR TABLE ADDRESS
	JMP	@CLASS_POWERFAIL(R0)	; AND GOTO THE POWERFAIL CODE

40$:	RSB
;
; ERROR DETECTED DURING INITIALIZATION
;

YF$UNIT_ERROR:
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5)	; UNIT NOT ON LINE
	RSB

	.PAGE
	.SBTTL	MAINTENANCE ROUTINES
;++
; YF$MAINT - MAINTENANCE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
; THIS ROUTINE PERFORMS MAINTENANCE FUNCTIONS FOR THE DHU
; (LOOPBACK IS ONLY ALLOWED ON LINES 0 AND 1)
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	UCB$B_TT_MAINT = FUNCTION TO BE PERFORMED
;
; OUTPUTS:
;	R0-R4 SCRATCH
;--

YF$MAINT:
	BITB	#IO$M_LOOP@-7,-			; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	5$				; NO
	MOVZWL	#^X02,R2			; SPECIFY LOOPBACK CODE
	BRB	10$
5$:
	BITB	#IO$M_UNLOOP@-7,-		; RESET LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	15$				; NO
	MOVZWL	#^X00,R2			; SPECIFY UNLOOP CODE
10$:
	SETIND
	MOVW	DHULCT(R0),R1
	INSV	R2,#DHULCT$V_MAINT,#2,R1	; SET MAINT FIELD
	MOVW	R1,DHULCT(R0)			; Update
	MOVZBL	#1,R0				; INDICATE SUCCESS
	RSB
50$:
	CLRL	R0
	RSB

15$:
	BITB	#IO$M_AUTXOF_ENA@-7,-
		UCB$B_TT_MAINT(R5)		;AUTOXON ENABLED
	BEQL	17$				; NO THEN MAYBE DISABLE
	BISW	#TTY$M_PC_XOFAVL,-
		UCB$W_TT_PRTCTL(R5)		; SET THE BIT AVAILABLE

17$:	BITB	#IO$M_AUTXOF_DIS@-7,-
		UCB$B_TT_MAINT(R5)		;AUTOXON disabled
	BEQL	19$				; no then don't disable it
	BICW	#TTY$M_PC_XOFAVL,-
		UCB$W_TT_PRTCTL(R5)

19$:
	BITB	#IO$M_LINE_OFF@-7,-		; LINE OFF
		UCB$B_TT_MAINT(R5)
	BEQL	30$				; NO
	SETIND
	BICW	#DHULCT$M_RCV!DHULCT$M_MODEM,DHULCT(R0)	; Disable Receive and modem
	BISW	#DHULCT$M_ABORT,DHULCT(R0)	; Abort any current activity
	CLRB	DHUTBF2+1(R0)			; Disable Transmit
	BRB	40$
30$:
	BITB	#IO$M_LINE_ON@-7,-		; LINE ON
		UCB$B_TT_MAINT(R5)
	BEQL	50$				; NO
	SETIND
	BISW	#DHULCT$M_RCV!DHULCT$M_MODEM,DHULCT(R0)	; Enable Receive and modem
	BICW	#DHULCT$M_ABORT,DHULCT(R0)
	MOVB	#^X80,DHUTBF2+1(R0)		; Enable Transmit
40$:	MOVZBL	#1,R0
	RSB


	.PAGE
	.SBTTL	OUTPUT MODEM CONTROL
;++
; YF$DS_SET - SET OUTPUT MODEM SIGNALS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE OUTPUT MODEM SIGNALS FOR THE SPECIFIED UNIT
;
; INPUTS:
;
;	R2 = LOW BYTE - SIGNALS TO ACTIVATE
;	     HIGH BYTE- SIGNALS TO DEACTIVATE
;	
;	R5 = UCB ADDRESS
;	
; OUTPUTS:
;
;	R0-R3 ARE USED.
;--
YF$DS_SET:
;
; Check that the DHU/DHV modem control signals have the standard values
;
	BISB	R2,UCB$B_TT_DS_TX(R5)	; SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		; ACCESS SIGNALS TO RESET
	BICB	R2,UCB$B_TT_DS_TX(R5)	; RESET THEM
	SETIND
	BICB3	#^C<<DHULCT$M_DTR!DHULCT$M_RTS>/256>,UCB$B_TT_DS_TX(R5),-(SP);
;
; The DHU/DHV is set to report modem change events in the receive fifo
; (Unless the line is disabled)
;
	BBS	#UCB$V_TT_DSBL,UCB$B_TT_MAINT(R5),10$	; Test if disabled
	BISB	#<DHULCT$M_MODEM/256>,(SP)
10$:
	MOVB	(SP)+,DHULCT+1(R0)		; OUTPUT NEW VALUE

	RSB


	.PAGE
	.SBTTL	RECEIVER INTERRUPT SERVICE
;++
; YF$INTINP - DHU RECEIVER READY INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CHARACTER IS AVAILABLE IN THE UNIT'S
; SILO. THE CHARACTER IS EXTRACTED AND IS PASSED TO THE ASSOCIATED
; CLASS DRIVER. IF THE CLASS DRIVER RETURNS CHARACTERS(S) THEN NEW
; OUTPUT IT INITIATED (NORMALLY ECHO).
;
; INPUTS:
;
;	00(SP) = ADDRESS OF IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED WHEN THE SILO IS EMPTY.
;
;--
YF$INTINP::				; DHU/DHV INPUT INTERRUPTS
;
; GET THE CSR ADDRESS
;
	MOVL	@(SP)+,R4		; GET THE IDB ADDRESS
	PUSHL	R4			; SAVE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE CHARACTER FROM THE INTERFACE
;
25$:	MOVW	DHURBF(R0),R3		; Get the silo entry
	BGEQ	45$			; Silo empty (== BRW 100$)
	ASHL	#-8, R3, R2		; shift the line number 
	BICL	#^C<15>, R2		; use mask to obtain line number
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB FOR THAT LINE
	BEQL	25$			; IF EQL THEN NOT THERE
	BITW	#<DHURCV$M_PARERR>!-
		<DHURCV$M_OVERRUN>!-
		<DHURCV$M_FRAMER>,R3	;ERRORS OR MODEM TRANSITION ?
		
	BNEQ	50$			;YES,PROCESS THEM
27$:
	MOVZBL	R3,R3			; CLEAR THE HIGH BYTES OF CHARACTER
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BLEQ	40$			; NONE OR STRING OUTPUT
	TIMSET	#1,R1,LOCKOUTPUT	; SET TIMEOUT AND INTERRUPT BIT 
	SETIND	R0
	BBS	#UCB$V_DHU,UCB$B_DHUFLG(R5),28$
	BISW3	#^X8000,R3,DHUTXC(R0)	; DHV single char output
	BRB	30$
28$:
	MOVB	R3,DHUTXF(R0)		; DHU fifo output
30$:	MOVL	(SP),R4			; GET IDB ADDRESS
	BRB	25$			; CONTINUE
40$:
	BEQL	30$			; NO CHARACTER
	JSB	BURST_OUTPUT		; START BURST
	BRB	30$

45$:
    	BRB	100$
;
50$:
;
; PROCESS PARITY, FRAME OVERRUN ERROR OR MODEM TRANSITION
;
;
; The DHU indicates modem transition by setting all the
; error bits
	BBC	#DHURCV$V_PARERR,R3,60$
	BBC	#DHURCV$V_OVERRUN,R3,60$
	BBS	#DHURCV$V_FRAMER,R3,200$; Modem transition if all set
60$:
	MOVL	UCB$L_TT_CLASS(R5),R2	; GET CLASS DISPATCH
	JSB	@CLASS_READERROR(R2)	; SIGNAL ERROR
	BNEQ	27$			; CHRRACTER TO ECHO
70$:
	BRB	30$

100$:	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI
;
; Modem transition routine
;
200$:
; If lsb set then it is a self test code
; We currently ignore self test codes, although these could be used
; for error logging purposes

	BLBS	R3,30$
;
; Unfortunately the DHU and DHV dont put the modem bits where we want them
; To get the correct bits we have to move RI,DCD,CTS up one place, while not
; changing DSR. spare bits have to be ignored.
	ADDL	R3,R3			; (This shifts DSR out of bottom byte)
	BICB	#^C<TT$M_DS_RING!TT$M_DS_CTS!TT$M_DS_CARRIER>,R3
	BBC	#DHUSTT$V_DSR+1,R3,210$
	BBSS	#TT$V_DS_DSR,R3,210$
210$:
	MOVB	R3,UCB$B_TT_DS_RCV(R5)	; UPDATE CURRENT INPUT MODEM SIGNALS
	MOVB	R3, R2			; PASS CURRENT INPUT MODEM SIGNALS IN R2
	MOVZBL	#MODEM$C_DATASET,R1	; TRANSITION TYPE IS DATASET 
	PUSHL	R0			; SAVE CSR ADDRESS
	MOVL	UCB$L_TT_CLASS(R5),R4	; GET CLASS DISPATCH
	JSB	@CLASS_DS_TRAN(R4)	; INVOKE TRANSITION ROUTINE
	POPL	R0			; RESTORE CSR ADDRESS
	BRW	30$
	

	.PAGE
	.SBTTL	 START I/O ROUTINE
;++
; YF$STARTIO - START I/O OPERATION ON DHU
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED FROM THE DEVICE INDEPENDENT TERMINAL STARTIO
; ROUTINE TO ENABLE OUTPUT INTERRUPTS ON AN IDLE DHU UNIT.
;
; INPUTS:
;
;	R3 =	CHARACTER	AND	CC = PLUS
;		ADDRESS		AND	CC = NEGATIVE
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
	.ENABLE	LSB
YF$STARTIO::				; START I/O ON UNIT
	BLSS	BURST_OUTPUT
	BRW	90$

BURST_OUTPUT:
	SETIND
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; GET LENGTH
	BBC	#TTY$V_PC_DMAENA,-	; USE SILO IF DMA NOT ENABLED ON THIS LINE
		UCB$W_TT_PRTCTL(R5),SILO_OUTPUT
	CMPW	R2,G^TTY$GW_DMASIZE	; LARGE ENOUGH FOR DMA
	BLSS	SILO_OUTPUT
10$:	BRW	DMA_START		; YES SO DO DMA

SILO_OUTPUT:
	BBC	#UCB$V_DHU,UCB$B_DHUFLG(R5),200$	; DHV has single char output
	MOVZBL	DHUTFS(R0),R1			; get number of slots
	CMPW	R2,R1			; BURST LARGER THAN SILO?
	BLEQU	50$			; NO
	MOVZBL	R1,R2			; SLOTS AVAILABLE IS MAXIMUM
50$:
	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET ADDRESS
	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; AND COUNT
	BEQL	60$			; ALL DONE, NO NEED FOR BURST
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
60$:
	BLBC	R2,70$			; EVEN TRANSFER
	MOVB	(R3)+,DHUTXF(R0)	; OUTPUT ODD BYTE
	DECL	R2			; UPDATE COUNT
	BEQL	80$			; DONE
70$:
	ASHL	#-1,R2,R2		; CONVERT TO WORD COUNT
75$:
	MOVW	(R3)+,DHUTXF(R0)
	DELAY				; TO RELEASE THE UNIBUS
	SOBGTR	R2,75$			; LOOP TILL DONE

80$:	RSB				; RETURN TO CALLER

90$:
	BEQL	100$			; SKIP IF NONE
	SETIND	
	BBS	#UCB$V_DHU,UCB$B_DHUFLG(R5),95$
;
; DHV single character output
;
	BISW3	#^X8000,R3,DHUTXC(R0)
	BRB	100$
;
; DHU fifo output
;
95$:
	MOVB	R3,DHUTXF(R0)
100$:
	RSB
;
; DHV 'silo' output, uses single character mode
;
200$:
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3	; GET character
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; AND COUNT
	BEQL	260$			; ALL DONE, NO NEED FOR BURST
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
260$:
	BISW3	#^X8000,R3,DHUTXC(R0)	; output the character
	RSB

	.DISABLE	LSB

	.PAGE
	.SBTTL	PORT DMA ROUTINES
;++
; DMA_START	-	INITIATE DMA OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE CALLED BY THE PORT INPUT INTERRUPT, OUTPUT
; INTERRUPT, AND STARTIO TO INITIATE NEW DMA OUTPUT.
; THEY HANDLE ALLOCATION AND LOADING OF MAP REGISTERS
; TO HANDLE DMA OUTPUT. MAP REGISTERS ARE ALLOCATED IN PAIRS
; TO ALLOW OUTPUT BURSTS UP TO 512 BYTES. TRANSFERS LARGER THAN
; THAT ARE DONE IN SEGMENTS. IF INSUFFICIENT MAPS ARE AVAILABLE,
; THE TRANSFER IS DONE SILO MODE.
;
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;
;	R0 PRESERVED
;	R1,R2,R3,R4 DESTROYED
;--
DMA_START:
	BISW	#TTY$M_TANK_DMA,-	; SHOW DMA MODE ACTIVE
		UCB$W_TT_HOLD(R5)
	BBCC	#TTY$V_TP_ABORT,-	; RESET ANY OLD ABORT REQUESTS
		UCB$B_TP_STAT(R5),3$
	BICW	#DHULCT$M_ABORT, DHULCT(R0)
;
; If there are no mapping registers for the device then don't allocate them
;
3$:	BBC	#UCB$V_MAP, UCB$B_DHUFLG(R5),DMA_CONTINUE
;	CHECK IF UNIT HAS PERMANENT MAP REGISTERS
	
	BBC	#TTY$V_PC_PRMMAP,-	; SKIP IF NOT AUTHORIZED FOR PERM MAPS
		UCB$W_TT_PRTCTL(R5),5$
	BBS	#TTY$V_PC_MAPAVL,-	; SKIP FORK IF MAPS ALLOCATED ALREADY
		UCB$W_TT_PRTCTL(R5),DMA_CONTINUE
5$:
	BISB	#TTY$M_TP_ALLOC,-	; SHOW ALLOC FORK ACTIVE
		UCB$B_TP_STAT(R5)
	MOVL	UCB$L_TT_CLASS(R5),R1	; GET CLASS VECTOR ADDRESS
	JSB	@CLASS_FORK(R1)		; FORK TO FIPL FOR MAP
					; REGISTER ALLOCATION
	RSB				; RETURN TO CALLER WITH
					; "INT" LEFT ON TO INTERLOCK
					; OUTPUT. FORK ROUTINE WILL
					; RESUME AT DMA_ALLOC.
DMA_ALLOC:


5$:
	MOVZBL	#2,R3			; REQUEST 2 MAP REGISTERS
	JSB	G^IOC$ALOUBAMAPN	; 

	SETIPL	UCB$B_DIPL(R5)		; INTERLOCK TO DEVICE IPL
	BISW	#TTY$M_PC_MAPAVL,-	; SHOW MAP ALLOCATED
		UCB$W_TT_PRTCTL(R5)
	BICB	#TTY$M_TP_ALLOC,-	; SHOW ALLOC FORK DONE
		UCB$B_TP_STAT(R5)
	BLBS	R0,20$			; SUCCESS

	MOVL	UCB$L_CRB(R5),R0	; GET CRB OF UNIT
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0; GET CSR
	BICW	#TTY$M_TANK_DMA,-	; RESET DMA MODE
		UCB$W_TT_HOLD(R5)
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; RESTORE OUTPUT LENGTH
	BRW	SILO_OUTPUT		; USE SILO FOR OUTPUT

20$:
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R0),-
		UCB$L_TP_MAP(R5)	; SAVE  MAP FIELD IN UCB


DMA_CONTINUE:
	BBS	#TTY$V_TP_ABORT,-	; BRANCH IF DMA TO BE ABORTED
		UCB$B_TP_STAT(R5),2$

	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET ADDRESS OF NEXT STRING
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; LENGTH OF OUTPUT
	BNEQ	4$			; SKIP IF MORE TO DO
2$:	BRW	DMA_DONE		; BRANCH IF TRANSFER IS DONE
4$:
	PUSHL	R0			; SAVE INPUT VOLITAL REGISTER "CSR"

;
; If there are no mapping registers for the device then
; start dma directly
;
	BBC	#UCB$V_MAP, UCB$B_DHUFLG(R5),DMA_NOMAP
	BRW	DMA_MAP
.page
DMA_NOMAP:
;
; Special code to work with an unmapped DHU/DHV
; (I.e. Seahorse configuration)
;
; this code examines the DMA buffer to find the maximum physically
; contiguous area, and starts a DMA on that part.
;
; It assumes that the buffer is in non-paged pool
; (I.e. that it is in system address space and that the PTE
; will always contain the PFN for the page)
;
; Find physical address of first page
;
	MOVL	UCB$L_TT_OUTADR(R5),R3
	BICL3	#^X80000000,R3,R4	; CALC SVAPTE OF BUFFER
	ASHL	#-9,R4,R4		; ISOLATE PAGE
	MOVL	G^MMG$GL_SPTBASE,R0	; GETS SVAPTE OF BUFFER
	MOVAL	(R0)[R4],R4		; INTO R4
	BICL	#^C^X1FF,R3		; COMPUTE BYTE OFFSET IN PAGE
;
; calculate length of DMA in this page
;
	SUBL3	R3,#512,R1
;
; See if this is longer than buffer
;
	CMPW	R1,UCB$W_TT_OUTLEN(R5)
	BLEQ	10$
	MOVW	UCB$W_TT_OUTLEN(R5),R1	; use actual buffer length
10$:
	SUBW	R1,UCB$W_TT_OUTLEN(R5)
;
; Get the PFN for the first page
;
	MOVL	(R4)+,R2

; calculate physical address from PTE
; (assuming that it fits into a 22-bit address)

	EXTZV	#0,#21,R2,R2		; get PFN only
	INSV	R2,#9,#13,R3
;
; Loop through remaining pages to see if they are contiguous with this one
;
20$:
	TSTW	UCB$W_TT_OUTLEN(R5)
	BEQL	50$			; No more DMA
	INCL	R2			; get expected PTE
	CMPZV	#0,#21,(R4),R2		; test next PTE
	BNEQ	50$			; not contiguous
	TSTL	(R4)+			; step to next PTE
;
; concatenate this page to previous DMA
;
	CMPW	UCB$W_TT_OUTLEN(R5),#512
	BLEQ	40$			; partial page

	ADDL	#512,R1			; whole page gets added
	SUBW	#512,UCB$W_TT_OUTLEN(R5)
	BRB	20$

; partial page gets added, to complete the DMA
40$:
	ADDW	UCB$W_TT_OUTLEN(R5),R1
	CLRW	UCB$W_TT_OUTLEN(R5)
50$:
;
; Start up the DMA
;
	ADDL	R1,UCB$L_TT_OUTADR(R5)	; step to next DMA address
	POPL	R0			; RESTORE CSR ADDRESS
	SETIND	R0
	MOVW	R1,DHUTCT(R0)		; load the count
	MOVW	R3,DHUTBF1(R0)		; load low address
	EXTZV	#16,#6,R3,R3		; get high address
	BISB3	#^X80,R3,DHUTBF2(R0)	; load high address and start
	RSB
.page
;
; Code to do mapped DMA transfers
;
DMA_MAP:
	CMPL	R2,#512			; NEXT BURST TOO LONG FOR MAPS?
	BLEQ	5$			; NO
	MOVZWL	#512,R2


5$:	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE CHARACTER POINTER FOR NEXT TIME
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT FOR NEXT TIME

    	BBS	#UCB$V_XOFF,UCB$B_DHUFLG(R5),6$	; IF XOFF, DON'T SET TIMER   	
	TIMSET	R2,R1,LOCKOUTPUT	;RECOMPUTE TIMEOUT VALUE FOR THIS
					;PORTION OF THE DMA BURST


;		R3 - STRING ADDRESS
;		R2 - LENGTH
;		R5 - UCB

6$:	PUSHR	#^M<R2,R5>
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_ADP(R0),R1	; CONFIG REGISTER
	EXTZV	#VEC$V_MAPREG,#VEC$S_MAPREG,-
		UCB$L_TP_MAP(R5),R0	; GET STARTING MAP REGISTER
	MOVAL	UBA$L_MAP(R1)[R0],R1	; GET 1ST MAP REGISTER ADDRESS
	
	BICL3	#^X80000000,R3,R4	; CALC SVAPTE OF BUFFER
	ASHL	#-9,R4,R4		; ISOLATE PAGE
	MOVL	G^MMG$GL_SPTBASE,R5	; GETS SVAPTE OF BUFFER
	MOVAL	(R5)[R4],R4		; INTO R4
	BICL	#^C^X1FF,R3		; COMPUTE BYTE OFFSET IN PAGE

;	LOAD MAP REGISTERS
;		R0 - MAP REGISTER NUMBER
;		R1 - ADDRESS OF FIRST MAP REGISTER
;		R2 - BUFFER LENGTH
;		R3 - BYTE OFFSET IN PAGE
;		R4 - SVAPTE OF BUFFER

	MOVZBL	#2,R2
10$:	MOVL	(R4)+,R5		; GET CONTENTS OF NEXT PTE

;	THIS CODE ASSUMES THAT DMA IS FROM NONPAGED POOL

	INSV	#^X400,#21,#11,R5	; SET VALID BIT, DATA PATH 0
	MOVL	R5,(R1)+		; LOAD INTO MAP REGISTER
	SOBGTR	R2,10$
		
	POPR	#^M<R2,R5>		; RESTORE LENGTH,WRITE BUFFER, UCB

;
; Note that the following code works with 22 bit Qbus addresses
; As well as with 18 bit Unibus addresses

	INSV	R0,#9,#13,R3		; COMPUTE UNIBUS ADDRESS
	SETIND
	MOVW	R2,DHUTCT(R0)		; Load count
	MOVW	R3,DHUTBF1(R0)		; Load low bits
	EXTZV	#16,#6,R3,R3		; get high bits
	BISB3	#^X80,R3,DHUTBF2(R0)	; load high bits and initiate DMA
	POPL	R0			; RESTORE CSR ADDRESS
	RSB				; RETURN TO CALLER
					; FORK DISPATCHER, ISR, OR STARTIO

DMA_DONE:				; DMA COMPLETION


	BBS	#TTY$V_PC_PRMMAP,-	; SKIP FORK IF MAPS PERMANENT
		UCB$W_TT_PRTCTL(R5),DMA_POST
	BISB	#TTY$M_TP_DLLOC,-	; SHOW DEALLOC FORK ACTIVE
		UCB$B_TP_STAT(R5)
	MOVL	UCB$L_TT_CLASS(R5),R1	; GET CLASS VECTOR ADDRESS
	JSB	@CLASS_FORK(R1)		; SCHEDULE FORK TO FIPL FOR MAP
					; REGISTER DEALLOCATION
	RSB				; RETURN TO CALLER, FORK WILL RESUME
					; AT DMA_DEALLOC

DMA_DEALLOC:
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	UCB$L_TP_MAP(R5),-
		CRB$L_INTD+VEC$W_MAPREG(R0); RESTORE MAP FIELD IN CRB
	BEQL	5$			; SKIP IF NONE
	JSB	G^IOC$RELMAPREG		; RELEASE MAP REGISTERS

5$:	SETIPL	UCB$B_DIPL(R5)		; INTERLOCK TO DEVICE IPL
	BICW	#TTY$M_PC_MAPAVL,-	; SHOW MAP ALLOCATED
		UCB$W_TT_PRTCTL(R5)
	BICB	#TTY$M_TP_DLLOC,- 	; SHOW DEALLOC FORK DONE
		UCB$B_TP_STAT(R5)			

DMA_POST:
	BICB	#TTY$M_TP_ABORT,- 	; RESET ABORT REQUEST
		UCB$B_TP_STAT(R5)			
	BICW	#TTY$M_TANK_DMA,-	; RESET DMA MODE
		UCB$W_TT_HOLD(R5)

;	CALL GETNEXT TO CONTINUE PROCESSING
;
	BICB	#UCB$M_TIM!UCB$M_INT,-	;CLEAR TIMEOUT AND INT EXPECTED
		UCB$W_STS(R5)		
	JSB	@UCB$L_TT_GETNXT(R5)	; GET NEXT BURST
	BRW	YF$STARTIO		; AND PROCEED
YF$FORK:				; 
	SAVIPL				; SAVE CURRENT IPL ON THE STACK
	PUSHAL	20$			; BUILD RETURN ADDRESS ON STACK
	BBC	#TTY$V_TP_ALLOC,-	; SKIP IF NOT ALLOCATE FORK
		UCB$B_TP_STAT(R5),10$
	BRW	DMA_ALLOC		; RESUME AT ALLOCATE CODE THREAD
10$:
	BBC	#TTY$V_TP_DLLOC,-	; CHECK FOR DEALLOCATE
		UCB$B_TP_STAT(R5),20$
	BRW	DMA_DEALLOC
20$:
	ENBINT				; RESTORE SAVED FORK IPL FROM STACK

	RSB

	.PAGE
	.SBTTL	PORT ROUTINES  STOP,RESUME,XON,XOFF
;++
; YF$XOFF -	SEND XOFF
; YF$XON -	SEND XON
; YF$STOP -	STOP OUTPUT
; YF$ABORT -	ABORT CURRENT OUTPUT
; YF$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
;
; SCHEDULE XOFF OR XON TO BE SEND
;
; INPUTS:
;
;	R3 - CONTAINS THE CHARACTER TO SEND AS FLOW CONTROL.
;
;
; To send an XON we just clear the Force XOFF bit
YF$XON:
;
; Forget any stored 'XOFF' character
	BICW	#TTY$M_TANK_PREMPT,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	SETIND
;
; Clearing this bit will make the device send an XON asap
;
	BICW	#DHULCT$M_SNDOFF,DHULCT(R0)
	CMPB	R3,#^X11		; Is it XOFF ?
	BNEQ	YF$PREEMPT
	RSB
;
; To send an XOFF we just set the Force XOFF bit,
;
YF$XOFF:
	SETIND
	CMPB	R3,#^X13		; Is it XOFF ?
	BNEQ	YF$PREEMPT		; Not XOFF, have to do it the hard way
	BISW	#DHULCT$M_SNDOFF,DHULCT(R0)
	RSB
;
; we have to send a character here (other than normal XON/XOFF),
; so see if the device is idle
;
YF$PREEMPT:
	BBSS	#UCB$V_INT,UCB$W_STS(R5),30$	; Branch if active
	TSTB	DHUTBF2+1(R0)
	BGEQ	10$				; XOFFED, don't set timer
	TIMSET	#1,R1,LOCKOUTPUT
;
; If this is a DHV then we send the char by single character,
; else by fifo
;
10$:
	BBS	#UCB$V_DHU,UCB$B_DHUFLG(R5),20$
	BISW3	#^X8000,R3,DHUTXC(R0)
	BRB	90$
20$:
	MOVB	R3,DHUTXF(R0)	
	BRB	90$
;
; Transmission is in progress, save the character till
; the transmission completes
30$:
	BISW	#TTY$M_TANK_PREMPT,-	; Set the flag
		UCB$W_TT_HOLD(R5)
	MOVB	R3,UCB$B_TT_PREMPT(R5)	; Save the character

90$:
	RSB

;
; STOP PORT OUTPUT
;
YF$STOP:
	PUSHL	R0
	SETIND
	CLRB	DHUTBF2+1(R0)
;
; Note. We dont reset UCB$M_INT for the DHU,DHV in case the
; device finishes transmitting
;
    	BISB	#UCB$M_XOFF,UCB$B_DHUFLG(R5)	; set to indicate xoff
	BICB	#UCB$M_TIM,UCB$W_STS(R5)	; Reset timer
	POPR	#^M<R0>
	RSB
;
; ABORT ANY CURRENT PORT OUTPUT ACTIVITY
;
YF$ABORT:
	PUSHL	R0
	BBC	#UCB$V_INT,UCB$W_STS(R5),15$		; SKIP IF NOT BUSY.
	BISB	#TTY$M_TP_ABORT,UCB$B_TP_STAT(R5)	; REQUEST DMA ABORT
	SETIND
	BISW	#DHULCT$M_ABORT,DHULCT(R0)
15$:
	POPR	#^M<R0>
	RSB
;
; RESUME PREVIOUSLY STOPPED PORT OUTPUT
;
YF$RESUME:
	PUSHR	#^M<R0,R1,R2,R3>
	SETIND
	MOVB	#^X80,DHUTBF2+1(R0)			; ENABLE TRANSMIT
    	BICB	#UCB$M_XOFF, UCB$B_DHUFLG(R5)		; clear to indicate xon
	BBS	#UCB$V_INT,UCB$W_STS(R5),50$		; Recalculate timeout
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),40$	; NO BURST IN PROGRESS
							; (RESET ANYWAY. WILL BE
							; SET IF NEEDED BY BURST_OUTPUT)
	MOVZWL	UCB$W_TT_OUTLEN(R5),R1			; GET NUMBER CHARACTERS
	TIMSET	R1,R1,LOCKOUTPUT			; COMPUTE TIMEOUT AND
							; SET INTERUPT EXPECTED
	JSB	BURST_OUTPUT				; RESTART OUTPUT
40$:
	POPR	#^M<R0,R1,R2,R3>
	RSB

50$:
;
; reset timeout for the DHU/DHV
;
; We use the number of characters that the DHU has got left to send
; plus the number in the remaining part of the buffer
; Note that the byte count may not be updated by the DHU/DHV
; so we will over estimate the timeout value
; We have to add 64 because these characters may be in the Transmit fifo
	MOVZWL	#64,R1
	ADDW	DHUTCT(R0),R1
	ADDW	UCB$W_TT_OUTLEN(R5),R1
	TIMSET	R1,R1,LOCKOUTPUT			; COMPUTE TIMEOUT AND
							; SET INTERUPT EXPTECTEDD
	BRB	40$

	.PAGE
	.SBTTL	OUTPUT INTERRUPT SERVICE
;++
; YF$INTOUT - DHU OUTPUT INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE DHU FINDS A LINE ENABLED
; AND AN EMPTY UART. THE CORRESPONDING UCB IS FOUND AND 
; ANY OUTSTANDING PORT OUTPUT IS DONE. WHEN ALL OUTSTANDING PORT
; OUTPUT IS COMPLETED, THE CLASS DRIVER IS CALLED TO RETURN THE NEXT
; CHARACTER OR STRING TO BE OUTPUT. IF NO MORE OUTPUT IS FOUND, THEN
; THE LINE IS DISABLED.
;
; INPUTS:
;
;	SP(00) = ADDRESS OF THE IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 SAVED ON THE STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED.
;
;--
YF_OUT_EXIT:				; EXIT OUTPUT INTERRUPT
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				; DISMISS INTERRUPT

YF$INTOUT::				; DHU OUTPUT INTERRUPT SERVICE

YF_OUT_LOOP:
	MOVL	@(SP),R4		; GET THE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE LINE INFO FROM THE CSR
;

	MOVW	(R0),R2			; GET THE CSR VALUE
	BGEQ	YF_OUT_EXIT
	ASHL	#-8,R2,R1		; Get the line number
	BICL	#^C<15>,R1
	MOVL	IDB$L_UCBLST(R4)[R1],R5	; GET THE UCB ADDRESS
	BEQL	YF_OUT_LOOP		; IF EQL THEN DISMISS 
;
;	CHECK FOR BURST OR DMA ACTIVE ON LINE
;
	SETIND	R0
    	BITW	#DHULCT$M_ABORT, DHULCT(R0)	; CHECK TO SEE IF ABORT IS SET
    	BEQL	5$				; EQUAL, ABORT NOT SET
    	BICW	#DHULCT$M_ABORT, DHULCT(R0)	; CLEAR ABORT 
5$:	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	YF_SILO			; YES, CONTINUE SILO OUTPUT
	BITW	#TTY$M_TANK_PREMPT,-	; Preempt required ?
		UCB$W_TT_HOLD(R5)
	BNEQ	40$			; == BRW YF_PREEMPT
9$:
	BITW	#TTY$M_TANK_DMA,-	; DMA ACTIVE?
		UCB$W_TT_HOLD(R5)
	BNEQ	45$		; YES, PROCESS IT. (== BRW YF_DMA_INTERRUPT)
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
10$:	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BLSS	YF_START_BURST		; BURST SPECIFIED
	BEQL	YF_OUT_LOOP		; NONE
;
; OUTPUT A CHARACTER TO THE DHU/DHV
;
20$:
	BBS	#UCB$V_DHU,UCB$B_DHUFLG(R5),30$
;
; Single char output to DHV
;
	BISW3	#^X8000,R3,DHUTXC(R0)
	BRW	YF_OUT_LOOP
;
; Fifo output to DHU
;
30$:
	MOVB	R3,DHUTXF(R0)
35$:
	BRW	YF_OUT_LOOP
40$:
	BRW	YF_PREEMPT
45$:
	BRW	YF_DMA_INTERRUPT


	.PAGE
	
YF_START_BURST:
	JSB	BURST_OUTPUT		; START OUTPUT SILO OR DMA
	BRW	YF_OUT_LOOP
;
;  CONTINUE SILO OUTPUT
;
YF_SILO:
;
; Note. THE DHV does not have SILO output
;
	BBC	#UCB$V_DHU,UCB$B_DHUFLG(R5),5$
	CMPB	DHUTFS(R0),#64		; ANY SILO OUTPUT IN PROGRESS ?
	BNEQ	15$			; YES THEN LET IT COMPLETE
	BRB 	20$			; OTHERWISE CONTINUE SILO OUTPUT
;
; DHV single char mode
;
5$:
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3
	BISW3	#^X8000,R3,DHUTXC(R0)
	INCL	UCB$L_TT_OUTADR(R5)
	DECW	UCB$W_TT_OUTLEN(R5)
	BNEQ	10$			; NOT DONE 
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
	
10$:	BRW	YF_OUT_LOOP

15$:
	INCL	YF$L_SIL_ERROR		; INCREMENT ERROR COUNTER
	BRB	10$			; == BRW YF_OUT_LOOP
;
; DHU silo output
;
20$:
	MOVZBL	DHUTFS(R0),R1		; number of slots

	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; GET CURRENT LENGTH
	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET CURRENT ADDRESS
	CMPW	R2,R1			; BURST LARGER THAN SILO?
	BLEQU	50$			; NO
	MOVZBL	R1,R2			; MAXIMUM
50$:
	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; AND COUNT
	BNEQ	60$			; NOT DONE 
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
60$:	TSTL	R2			; ANY ROOM AT ALL
	BEQL	80$			; NO THEN EXIT

	BLBC	R2,70$			; EVEN TRANSFER
	MOVB	(R3)+,DHUTXF(R0)	; OUTPUT ODD BYTE
	DECL	R2			; UPDATE COUNT
	BEQL	80$			; DONE
70$:
	ASHL	#-1,R2,R2		; CONVERT TO WORD COUNT
75$:
	MOVW	(R3)+,DHUTXF(R0)
	DELAY				; TO RELEASE THE UNIBUS
	SOBGTR	R2,75$			; LOOP TILL DONE

80$:	BRW	YF_OUT_LOOP

YF_PREEMPT:
	BICW	#TTY$M_TANK_PREMPT, UCB$W_TT_HOLD(R5)	   ; CLEAR PREEMPT BIT
	MOVZBL	UCB$B_TT_PREMPT(R5),R3	; GET CHARACTER
	BBS	#UCB$V_DHU,UCB$B_DHUFLG(R5),10$
;
; DHV single character
	BISW3	#^X8000,R3,DHUTXC(R0)
	BRB	20$
;
; DHU FIFO output
;
10$:
	MOVB	R3,DHUTXF(R0)	
20$:
	BRW	YF_OUT_LOOP

YF_DMA_INTERRUPT:
;
; CHECK TO MAKE SURE NO DATA IS PENDING BEFORE ASKING FOR MORE
;
	PUSHAL	YF_OUT_LOOP		; BUILD RETURN ADDRESS ON STACK
	BBC	#DHUCSR$V_DMAERR,R2,5$	; CHECK FOR A DMA ERROR
	INCL	YF$L_DMAXMT_ERROR	; ERROR OCCURED INCREMENT COUNTS
5$:
	BITB	#TTY$M_TP_ALLOC!TTY$M_TP_DLLOC,- ;CHECK FOR FORKS ACTIVE
		UCB$B_TP_STAT(R5)	; AND IGNORE IF SO
	BNEQ	20$
	BBS	#TTY$V_TP_ABORT, UCB$B_TP_STAT(R5),-
		10$			; ABORT ACTIVE DMA
	TSTB	DHUTBF2(R0)		; ANY DMA IN PROGRESS ?
	BLSS	30$			; YES, then let it complete
	TSTW	DHUTCT(R0)		; TEST DMA BYTE COUNT 
	BEQL	10$			; DMA BYTE COUNT DONE
	INCL	YF$L_ERROR		;
	BRB 	20$			; NO THEN CONTINUE
10$:
	CLRW	DHUTCT(R0)		; CLEAR DMA BYTE COUNT (ABORT WAS CLEARED)
	BRW	DMA_CONTINUE		; OTHERWISE, CONTINUE THE DMA

					; IF THIS INTERRUPT WAS THE RESULT
					; OF AN ABORT, THIS WILL BE HANDLED
					; BY DMA_CONTINUE
20$:
	RSB				


30$:
	INCL	YF$L_SIL_ERROR
	ADDL	#4, SP			; Pop off return address
	BRW	YF_OUT_LOOP

	.PAGE
	.SBTTL	SET SPEED, PARITY PARAMETERS

;++
; YF$SET_LINE - RESET SPEED, PARITY
;
; FUNCTIONAL DESCRIPTION:
;
; INPUTS:
;
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;
;	R4 USED
;--

YF$SET_LINE:
	PUSHR	#^M<R2,R3>
	MOVL	UCB$L_CRB(R5),R4	; ADDRESS CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; GET THE CSR ADDRESS VIA CRB
	SETIND
	MOVZWL	DHULCT(R0),R2			; Fetch the line control reg
	
;
; The DHU/DHV have automatic detection of received XON/XOFF and also
; automatic generation of XON/XOFF options
;
	BBC	#TTY$V_PC_XOFAVL,UCB$W_TT_PRTCTL(R5),4$; AUTOXON XOFF AVAILABLE ON THIS LINE
						; YES THEN IS
;
; Assume that both modes are required
;
	BISW	#<DHULCT$M_OAUTO ! DHULCT$M_IAUTO>,-
			R2; Assume AUTOXOFF 
;
; Disable detection of received XON/XOFF if not allowed
;
	BBS	#TTY$V_PC_XOFENA,UCB$W_TT_PRTCTL(R5),2$; AUTOXON XOFF ENABLED
	BICW	#DHULCT$M_OAUTO,R2		; NO THEN CLEAR THE AUTOXOFF ENABLE
2$:
;
; Disable sending of XON/XOFF is hostsync is not set
; (The DHU/DHV can send XON/XOFF automatically if the receive fifo fills up)
;
	BBS	#TT$V_HOSTSYNC,UCB$L_DEVDEPEND(R5),4$; Host sync specified ?
	BICW	#DHULCT$M_IAUTO,R2		; No, then clear enable flag	

4$:	BICW	#DHULCT$M_MODEM,R2
    	BBC	#TT$V_MODEM, UCB$L_DEVDEPEND(R5), 6$ 
    	BISW	#DHULCT$M_MODEM,R2

;
; move updated register back into device
;
6$:	MOVW	R2,DHULCT(R0)
	CLRL	-(SP)				; RESET A TEMPORARY LOCATION
;
;	SET UP LINE SPEED AND PARITY
;

	TSTB	UCB$W_TT_SPEED+1(R5)	; RECEIVE SPEED SPECIFIED?
	BNEQ	8$			; YES
	MOVB	UCB$W_TT_SPEED(R5),-	; NO, SO USE TRANSMITTER SPEED
		UCB$W_TT_SPEED+1(R5)
8$:
	MOVZBL	UCB$W_TT_SPEED(R5),R3		; Get TRANSMIT SPEED
	MOVB	YF$VMS_SPEEDS[R3],R3
	BLSS	10$				; Illegal speed
	INSV	R3,#DHULPR$V_TSPEED,#4,(SP)	; SET TRANSMIT SPEED
	MOVZBL	UCB$W_TT_SPEED+1(R5),R3
	MOVB	YF$VMS_SPEEDS[R3],R3
	BLSS	10$				; Illegal speed
	INSV	R3,#DHULPR$V_RSPEED,#4,(SP)	; SET RECEIVE SPEED
	BRB	20$		; set current speed
	
10$:
;
; This code restores the speed to its previous value
; It is entered when an illegal speed combination is detected.

	MOVW	DHULPR(R0),R3		; get line parameters
	MOVW	R3,(SP)			; use previous speed as new
	CLRB	(SP)
	EXTZV	#DHULPR$V_TSPEED,#4,R3,R3	; extract speed
	MOVB	YF$DHU_SPEEDS[R3],UCB$W_TT_SPEED(R5); convert to VMS value

	MOVW	DHULPR(R0),R3			; get line parameters
	EXTZV	#DHULPR$V_RSPEED,#4,R3,R3	; extract speed
	MOVB	YF$DHU_SPEEDS[R3],UCB$W_TT_SPEED+1(R5); convert to VMS value

; insert other parameters in the new LPR value
;
20$:

	EXTV	#UCB$V_TT_LEN,#2,UCB$B_TT_PARITY(R5),R3		; GET CHAR SIZE
	INSV	R3,#DHULPR$V_SIZE,#2,(SP)			; SET IT

	EXTV	#UCB$V_TT_PARTY,#2,UCB$B_TT_PARITY(R5),R3	; GET PARITY/ODD
	INSV	R3,#DHULPR$V_PARITY,#2,(SP)
	XORL	#DHULPR$M_ODD,(SP)				; Correct sense

	EXTV	#UCB$V_TT_STOP,#1,UCB$B_TT_PARITY(R5),R3	; GET STOP
	INSV	R3,#DHULPR$V_STOP,#1,(SP)

	CMPW	(SP),DHULPR(R0)			; Any modifications to be made?
	BEQL	30$				; EQL, no then return 
	CVTLW	(SP),DHULPR(R0)			; INSERT AS LINE PARAMETER
30$:	ADDL	#4, SP				; Restore stack 
	POPR	#^M<R2,R3>			; Restore registers
	RSB



YF$END:					; end of driver
	.END
