MODULE setfile	(
		IDENT = 'V04-000',
    		ADDRESSING_MODE(EXTERNAL=GENERAL,
    				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
! FACILITY:	Set File Command
!
! ABSTRACT:
!
!	This module processes the Set File command.
!
! ENVIRONMENT:
!
!	Vax native, privileged user mode
!
!--
!
! AUTHOR:	Gerry Smith	 	CREATION DATE: 04-Aug-1981
!
! MODIFIED BY: 
!
!	V03-023 AEW0005		Anne E. Warner		24-Jul-1984
!		Make /EXPIRATION_DATE and /GLOBAL_BUFFERS check if 
!		the qualifier is present before trying to get any values
!		associated with it.  This is needed because these qualifiers
!		are now negatable.
!
!	V03-022	BLS0303		Benn Schreiber		12-APR-1984
!		Parse null string after parse in /enter code.
!
!	V03-021 AEW0004		Anne E. Warner		10-Apr-1984
!		Fix SET FILE/PROTECTION so that it handles wildcarding.
!
!	V03-020	MCN0156		Maria del C. Nasr	08-Mar-1984
!		If the user specifies /VERSION=0, then it should default
!		to the maximum value: 32767.  Also, the maximum value is
!		32767, and not 65535.
!
!       V03-019 AEW0003         Anne E. Warner          28-Feb-1984
!               Add support for search lists.
!               -  remove related name block from RMS definitions.
!               -  add argument to LIB$FILE_SCAN
!
!	V03-018	LMP0191		L. Mark Pilant,		10-Feb-1984  16:27
!		Validate the value of the /OWNER qualifier.
!
!	V03-017	DAS0002		David Solomon		6-Feb-1984
!		Specify ACE$M_NOPROPAGATE for RMSJNLID ACE. Disable /JOURNAL.
!
!       V03-016 AEW0002         Anne Warner             15-Dec-1983
!               Add /PROTECTION qualifier with keywords /CONFIRM and
!               /LOG.
!
!	V03-015 JWT0139		Jim Teague		09-Nov-1983
!		Change the name of two of the RU fields; ensure that
!		we don't leave the file set with conflicting RU
!		attributes.
!
!       V03-014 AEW0001         Anne Warner             08-Nov-1983
!               Add /UNLOCK qualifier with keywords /CONFIRM and
!               /LOG.
!
!	V03-013	DAS0001		David Solomon		29-Jul-1983
!		Fold /AI_JOURNAL, /BI_JOURNAL, and /AT_JOURNAL into keywords
!		on the /JOURNAL qualifier. /JOURNAL keyword RUM is now
!		ONLY_RU. Add NEVER_RU keyword; a few journaling-related fixes.
!
!	V03-012	GAS0147		Gerry Smith		27-Jun-1983
!		Change the file attribute modification so that it is
!		done thru a IO$_MODIFY instead of simply during the 
!		IO$_DEACCESS.  This is necessary for the case of
!		the version limit, since it cannot be changed on file
!		deaccess.
!
!	V03-011	GAS0141		Gerry Smith		17-Jun-1983
!		Signal all common qualifiers more completely, so that
!		the specified file can be found.
!
!	V03-010	KPL0002		Peter Lieberwirth	30-May-1983
!		Change JSB$S_JNLNAM to CJF$C_MXJNLNAML.
!
!	V03-009	KPL0001		Peter Lieberwirth	20-Apr-1983
!		Set journal names via new qualifiers AI_JOURNAL, BI_JOURNAL,
!		and AT_JOURNAL.  When marking the file for journaling,
!		write an RMSJNLID ACE.
!
!	V03-008	GAS0118		Gerry Smith		12-Apr-1983
!		Add the common qualifiers.
!
!	V03-007	GAS0112		Gerry Smith		30-Mar-1983
!		Convert to the new CLI interface, as well as a new 
!		command dispatcher.
!
!	V03-006	TMK0001		Todd M. Katz		28-Feb-1983
!		If someone requested AI journalling on a file to be turned
!		off (/JOURNAL=NOAI) then turn it off. Currently, AI Journalling
!		will always be enabled whenever it is explicitely refered to
!		(/JOURNAL=AI or /JOURNAL=NOAI), and there is no way to disable 
!		it.
!
!	V03-005	GAS0091		Gerry Smith		19-Oct-1982
!		Change input request for new CLD syntax.
!
!	V03-004	GAS0083		Gerry Smith		15-Jul-1982
!		Modify logic for RU journal option, to agree with
!		new definition.  The RUJNL bit used to have the opposite
!		sense of all other journal bits.  It now has the same sense.
!		
!	V03-003	GAS0071		Gerry Smith		 8-Apr-1982
!		If the writer count for a file is non-zero, don't allow
!		modification.  If /END is attempted on INDEXF.SYS, don't
!		allow it.
!
!	V03-002	GAS0068		Gerry Smith		31-Mar-1982
!		If a truncate is attempted on an indexed file, signal
!		an error.
!
!	V03-001	GAS0064		Gerry Smith		19-Mar-1982
!		Change check of qualifiers to include /GLOBAL_BUFFERS.
!
!	V03-005	GAS0050		Gerry Smith		22-Feb-1982
!		Only access the file header for something besides
!		/ENTER or /REMOVE.  Make the error messages for /ENTER
!		and /REMOVE more meaningful.  Change the /ENTER check for
!		same devices to use the DVI fields of the NAM blocks.
!
!	V03-004	GAS0047		Gerry Smith		15-Feb-1982
!		For SET FILE/ENTER, parse the new file name here, after
!		the old file name is available, so that stickiness can
!		be applied.
!
!	V03-003	GAS0038		Gerry Smith		 2-Feb-1982
!		Add /GLOBAL_BUFFERS, the global buffer count for a 
!		file.  Also, if the file is ODS1, then move the record
!		attributes to the location occupied in an ODS2 file.
!		This allows the BIND in routine SET_ATTRIBUTES to apply
!		to both kinds of file headers.
!
!	V03-002 GAS0026		Gerry Smith		18-Dec-1981
!		Use shared message file, and lower fatal messages to
!		simple error messages.
!
!	V03-001	GAS0024		Gerry Smith		14-Dec-1981
!		Fix /LOG logic for /ENTER and /REMOVE
!
!	V03-001 MSH0001		Maryann Hinden		02-Dec-1981
!		Change references to FIB$C_SIZE to FIB$C_LENGTH.
!
!	V03-001	GAS0021		Gerry Smith		30-Nov-1981
!		Fix /VERSION, making FIB larger
!
!	V03-001	GAS0018		Gerry Smith		16-Nov-1981
!		Split SET FILE into separate modules
!
!	V03-001	GAS0011		Gerry Smith		22-Sep-1981
!		Fix wildcarding for /ENTER.  Add /END_OF_FILE
!
!	V03-002	GAS0012		Gerry Smith		30-Sep-1981
!		Add /LOG and /CONFIRM
!
!**

LIBRARY	'SYS$LIBRARY:LIB';
LIBRARY 'SYS$LIBRARY:CLIMAC.L32';       ! CLI macros


FORWARD ROUTINE
    set$file : NOVALUE,			! Main routine for file
    get_quals,				! Get qualifiers
    set_attributes,			! Routine to set file attributes
    					! Common routines:
    unlock_action,                      ! Called to control each UNLOCK action
    check_privilege : NOVALUE,		! Routine to check for privilege
    search_error,			! Where to go if file search fails
    file_error,				! Where to go if file error occur,
    setpro_action,			! Called to control each file PROTECTION
    prot_log_results,			! Called when user requests a log for PROTECTION
    expand_prot,			! Converts binary protection to ascii
    parse_class;			! Parses the protection of one user class

EXTERNAL ROUTINE
    parse_uic,				! Convert a UIC
    cli$present,			! Get qualifiers
    cli$get_value,			! Get values of qualifiers
    lib$cvt_dtb,			! Convert ASCII to numerical
    lib$cvt_time,			! Convert time to internal
    lib$file_scan,			! Routine to find next file
    lib$qual_file_parse,		! Parse common qualifiers
    lib$qual_file_match,		! Check for common qualifiers
    lib$confirm_act,			! Confirm action with user
    lib$get_command,			! Talk to SYS$COMMAND
    lib$unlock_file,			! Unlocks files
    sys$fao,				! Expands formatted messages
    sys$setprv,				! Set privileges for protection
    lib$set_file_prot;			! Set file protection
    
!
! Literal data definitions
!
LITERAL
    true = 1,
    false = 0;

MACRO
!
! Macro definitions for fields in access control entries needed by RMS
! Journaling
!
    id_ace$s_size = 32 %,		! size in bytes of rmsjnlid ACE
    id_ace$t_label = 4,0,0,0 %,		! volume label in rmsjnlid ACE
    id_ace$w_num = 16,0,16,0 %,		! fid num in rmsjnlid ACE
    id_ace$w_seq = 18,0,16,0 %,		! fid seq in rmsjnlid ACE
    id_ace$w_rvn = 20,0,16,0 %,		! fid rvn in rmsjnlid ACE
    id_ace$q_time = 24,0,32,0 %,	! time in rmsjnlid ACE
    ace$t_jnlnam = 4,0,0,0 %,		! journal name string in jnl ACE
!
! A) Macro to describe a string
! B) Macro to generate a quadword string descriptor
! C) Macro to generate the address of a string descriptor

    PRIMDESC (str) = %CHARCOUNT (str), UPLIT (%ASCII str)%,
    INITDESC (str) = $BBLOCK [DSC$C_S_BLN] INITIAL (PRIMDESC (str))%,
    ADDRDESC (str) = UPLIT (PRIMDESC (str))%;



!
! Define the data that is used by SET FILE
!
GLOBAL
    setfile$flags : BITVECTOR[32] INITIAL(0),	! Qualifier bits word
    setfile$dflags : BITVECTOR[32] INITIAL(0),	! DATA_CHECK options word
    setfile$jflags : BITVECTOR[32] INITIAL(0),	! JOURNAL options word
    setfile$mflags : BITVECTOR[32] INITIAL(0),	! Miscellaneous flags word
    setpro_prot    : WORD          INITIAL(0),	! Contains /PROTECTION value
    setpro_mask	   : WORD          INITIAL(0),	! Contains /PROTECTION mask
    global_prot    : WORD,			! Command wide protection
    global_mask    : WORD,			! Command wide mask for protection
    exp_value      : $BBLOCK[8],		! Expiration date
    exte_value,					! Extension quantity
    gbuf_value,					! Global buffer value
    uic_value,					! Owner uic
    group,					! Group number
    member,					! Member number
    vrsn_value,					! Version limit
    rename_buf : VECTOR[nam$c_maxrss,BYTE],	! Name buffer for /ENTER
    file_name : VECTOR[2],			! ENTER/REMOVE descriptor 
    ai_jnl_name : VECTOR[cjf$c_mxjnlnaml,BYTE],	! AI journal name
    at_jnl_name : VECTOR[cjf$c_mxjnlnaml,BYTE],	! AT journal name
    bi_jnl_name : VECTOR[cjf$c_mxjnlnaml,BYTE],	! BI journal name
    ai_jnl_desc : $BBLOCK[dsc$c_s_bln]		! AI_JOURNAL descriptor
	PRESET( [dsc$a_pointer] = ai_jnl_name ),
    at_jnl_desc : $BBLOCK[dsc$c_s_bln]		! AT_JOURNAL descriptor
	PRESET( [dsc$a_pointer] = at_jnl_name ),
    bi_jnl_desc : $BBLOCK[dsc$c_s_bln]		! BI_JOURNAL descriptor
	PRESET( [dsc$a_pointer] = bi_jnl_name ),
    worst_error : $BBLOCK[4] INITIAL(ss$_normal),! Worst error reported
    conf_desc : $BBLOCK[dsc$c_s_bln], 	        ! Descriptor for /LOG/CONFIRM

    oldpriv		: $BBLOCK[8],	! Permanent priv's stored here
    newpriv		: $BBLOCK[8]	! Mask describing system priv
		PRESET ([prv$v_sysprv]=true), ! Initialize this bit
!
! RMS storage
!
    file_result : VECTOR[nam$c_maxrss,BYTE],	! Resultant name string
    file_expanded : VECTOR[nam$c_maxrss,BYTE],	! Expanded name string
    file_nam : $NAM(				! File name block
    	ESA = file_expanded,
    	ESS = nam$c_maxrss,
    	RSA = file_result,			! File name after open
    	RSS = nam$c_maxrss),
    file_fab : $FAB(				! FAB for file
    	NAM = file_nam);			! Specify name block

!
! Declare the context block used by the common qualifiers
!
OWN
    context;

!
! Declare the qualifier flag bits used by SET FILE
!
LITERAL
    $EQULST(QUAL_,,1,1,
	(backup,),
	(nobackup,),
	(confirm,),
	(data,),
	(eof,),
	(erase,),
	(noerase,),
	(expi,),
	(exte,),
	(gbuf,),
	(journal,),
	(log,),
	(nodi,),
	(owner,),
	(parent,),
	(protection,),
	(trunc,),
	(unlock,),
	(vrsn,),
	(enter,),
	(remove,),
	(quit,),
	(quit_mod,),
	(quit_rem,),
	(quit_ent,),
	(quit_protect),
	(quit_unlock,));

!
! Declare the DATA_CHECK option bits
!
LITERAL
    $EQULST
	(DATA_,,1,1,
	(read,),				! DATA_CHECK = READ
	(write,),				! DATA_CHECK = WRITE
	(noread,),				! DATA_CHECK = NOREAD
	(nowrite,));				! DATA_CHECK = NOWRITE

!
! Declare the JOURNAL option bits
!
LITERAL
    $EQULST
	(JRNL_,,1,1,
	(ai,),
	(specified_ai,),
	(at,),
	(specified_at,),
	(bi,),
	(specified_bi,),
	(ru,),
	(specified_ru,),
	(only_ru,),
	(specified_only_ru,),
	(never_ru,),
	(specified_never_ru,),
	(ai_name,),
	(at_name,),
	(bi_name,),
	);

!
! Declare the miscellaneous flags
!
LITERAL
    $EQULST
	(MISC_,,1,1,
	(mark_file,),
	(already_rmsjnlid,));

!
! Declare the error messages
!
!  Definitions in [CLIUTL.SRC]SET.MSG
!
EXTERNAL LITERAL
    lib$_quiconact,			! Quit asking for confirmation
    lib$_negans,			! Negative response to confirmation
    lib$_quipro,			! Quit processing
    lib$_filfaimat,			! Common qualifier match failed
    cli$_ivprot,			! Invalid protection
    cli$_negated,			! Value explicitly negated
    cli$_absent,			! Value not present and no defaul
    set$_operreq,			! OPER required
    set$_closeerr,			! Could not close file
    set$_entered,			! File entered in a directory
    set$_enterr,			! Error entering file
    set$_modified,			! File/directory modified
    set$_nonode,			! Node specification not allowed
    set$_notdir,			! Not a directory
    set$_notlocked, 			! File not locked
    set$_notods2,			! Not an ODS2 structure
    set$_opendir,			! Could not open parent directory
    set$_pronotchg,			! Error message - "Protection not changed"
    set$_proerr,			! Error in changing the protection
    set$_protected,                     ! Informational log message for protection
    set$_readerr,			! Error reading the file
    set$_remerr,			! Could not remove file
    set$_removed,			! Directory entry removed
    set$_unlockerr,                     ! Could not lock file
    set$_writeerr,			! Error modifying file
    set$_unlocked;			! File unlocked
!
! Define messages from the shared message facility
!
$SHR_MSGDEF (set, 119, global,
	    (badlogic,	severe),	! Fatal internal software error
	    (badvalue,	error),		! Invalid keyword value
	    (valerr,	error),		! Value out of range
	    (syntax,	error),		! Syntax problem
	    (confqual, 	error),		! Conflicting qualifiers
	    (delver, 	error),		! Explicit version number required
	    (notrunc,	error),		! Truncation not allowed
	    (openin, 	error),		! Error opening a file
	    (searchfail, error));	! Error searching for a file

GLOBAL ROUTINE set$file : NOVALUE =

!++
!
! Functional description
!
!	This is the main control module.  It calls LIB$FILE_SCAN to perform
!	the necessary functions on the file(s) specified in the call to SET.
!
! Calling sequence
!
!	CALL set$file()
!
! Input parameters
!	none
!
! Output parameters
!	none
!
! Implicit outputs
!	none
!
! Routine value
!	none
!
! Side effects
!	none
!
!--

BEGIN

LOCAL
    desc : $BBLOCK[dsc$c_s_bln],
    scan_context,                     ! Sticky context argument for FILE$SCAN
    status;

!
! Check to make sure that the image is running with correct privilege.
!
check_privilege();

!
! Get the common qualifiers
!
status = lib$qual_file_parse(%REF(lib$m_cqf_exclude OR
    				  lib$m_cqf_before OR
    				  lib$m_cqf_since OR
    				  lib$m_cqf_created OR
    				  lib$m_cqf_modified OR
    				  lib$m_cqf_byowner),
    			     context);
IF NOT .status
THEN (SIGNAL(.status); RETURN);

!
! Now to get all the command qualifiers.  
!
IF NOT get_quals()
THEN RETURN;

!
! Check to make sure that conflicting qualifiers were not specified.  If 
! they were, signal an error and stop.
!

IF .setfile$flags[qual_data]
THEN
    IF .setfile$dflags[data_read] AND .setfile$dflags[data_noread]
    OR .setfile$dflags[data_write] AND .setfile$dflags[data_nowrite]
    THEN SIGNAL_STOP(set$_confqual);

IF .setfile$flags[qual_journal]
THEN
    IF ( .setfile$jflags[jrnl_ru] AND .setfile$jflags[jrnl_only_ru] )
    OR ( .setfile$jflags[jrnl_ru] AND .setfile$jflags[jrnl_never_ru] )
    OR ( .setfile$jflags[jrnl_only_ru] AND .setfile$jflags[jrnl_never_ru] )
    THEN SIGNAL_STOP(set$_confqual);

!
! Next, for each file specified, find the file and perform the operations
! requested.
!
scan_context = 0;                       ! Argument must be zero for file scan
$init_dyndesc(desc);			! Make a dynamic descriptor
WHILE cli$get_value(%ASCID 'FILE', desc) 
AND NOT .setfile$flags[qual_quit] DO
    BEGIN
    file_fab[fab$b_fns] = .desc[dsc$w_length];
    file_fab[fab$l_fna] = .desc[dsc$a_pointer];
    lib$file_scan(			! For each file found,
	file_fab,			! Use this fab
	set_attributes,			! Go here if file found
	search_error,                   ! Go here if error
        scan_context)			
    END;

RETURN;
END;					! End of routine set$file

ROUTINE get_quals =
!++
!
! This routine gets all the qualifiers and values.
!
!__
BEGIN

LOCAL
    status,
    desc : $BBLOCK[dsc$c_s_bln];

$init_dyndesc(desc);			! Make a dynamic descriptor

!
! /[NO]BACKUP
!
status = cli$present(%ASCID 'BACKUP');
IF .status 
THEN setfile$flags[qual_backup] = 1
ELSE IF .status EQL cli$_negated 
THEN setfile$flags[qual_nobackup] = 1;

!
! /CONFIRM
!
IF cli$present(%ASCID 'CONFIRM')
THEN setfile$flags[qual_confirm] = 1;

!
! /DATA_CHECK
!
IF cli$present(%ASCID 'DATA_CHECK')
THEN
    BEGIN
    setfile$flags[qual_data] = 1;
    IF NOT cli$get_value(%ASCID 'DATA_CHECK', desc)
    THEN setfile$dflags[data_write] = 1
    ELSE INCR i FROM 0 TO 1 DO
	BEGIN
	IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		  .desc[dsc$w_length], UPLIT(BYTE('WRITE')))
	THEN setfile$dflags[data_write] = 1
	ELSE IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		       .desc[dsc$w_length], UPLIT(BYTE('READ')))
	THEN setfile$dflags[data_read] = 1
	ELSE
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	IF NOT cli$get_value(%ASCID 'DATA_CHECK', desc)
	THEN EXITLOOP
	END;
    END;

!
! /ENTER
!
IF cli$get_value(%ASCID 'ENTER', desc)
THEN
    BEGIN
    setfile$flags[qual_enter] = 1;
    CH$MOVE(.desc[dsc$w_length], 
    	    .desc[dsc$a_pointer], 
    	    rename_buf);
    file_name[0] = .desc[dsc$w_length];
    file_name[1] = .desc[dsc$a_pointer];
    $init_dyndesc(desc);
    END;

!
! /END_OF_FILE
!
IF cli$present(%ASCID 'END_OF_FILE')
THEN setfile$flags[qual_eof] = 1;

!
! /[NO]ERASE_ON_DELETE
!
status = cli$present(%ASCID 'ERASE_ON_DELETE');
IF .status
THEN setfile$flags[qual_erase] = 1
ELSE IF .status EQL cli$_negated
THEN setfile$flags[qual_noerase] = 1;

!
! /EXPIRATION_DATE
!
IF cli$present(%ASCID 'EXPIRATION_DATE')
THEN
    IF cli$get_value(%ASCID 'EXPIRATION_DATE', desc)
    THEN
        BEGIN
        setfile$flags[qual_expi] = 1;
        IF NOT lib$cvt_time(desc, exp_value)
        THEN
            BEGIN
            SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
        END;

!
! /EXTENSION
!
IF cli$present(%ASCID 'EXTENSION')
THEN
    BEGIN
    setfile$flags[qual_exte] = 1;
    exte_value = 5;
    IF cli$get_value(%ASCID 'EXTENSION', desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   exte_value)
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	IF .exte_value LSS 0
	OR .exte_value GTR 65535
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc, set$_valerr);
	    RETURN false;
	    END;
	END;
    END;

!
! /GLOBAL_BUFFERS
!
IF cli$present(%ASCID 'GLOBAL_BUFFERS')
THEN
    IF cli$get_value(%ASCID 'GLOBAL_BUFFERS', desc)
    THEN
        BEGIN
        setfile$flags[qual_gbuf] = 1;
        IF NOT lib$cvt_dtb(.desc[dsc$w_length],
    	  	           .desc[dsc$a_pointer],
    		           gbuf_value)
        THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
        IF .gbuf_value GTR 65535
        OR .gbuf_value LSS 0
        THEN
  	    BEGIN
    	    SIGNAL(set$_syntax, 1, desc, set$_valerr);
	    RETURN false;
	    END;
        END;

!
! /JOURNAL
!
begin				!**JNL**
global set$gl_journaling;	!**JNL**
if .set$gl_journaling		!**JNL**
then				!**JNL**
IF cli$present(%ASCID 'JOURNAL')
THEN
    BEGIN
    setfile$flags[qual_journal] = 1;

    !
    ! /JOURNAL=AI=ai_journal_name
    !
    status = cli$present( %ASCID 'JOURNAL.AI', desc );
    IF .status NEQU cli$_absent
    THEN
	BEGIN
	setfile$jflags[jrnl_specified_ai] = 1;
	IF .status
	THEN
	    setfile$jflags[jrnl_ai] = 1
	ELSE if .status EQLU cli$_negated
	THEN
	    setfile$jflags[jrnl_ai] = 0;
	IF cli$get_value( %ASCID 'JOURNAL.AI', desc )
	THEN
	    BEGIN
	    IF .desc[dsc$w_length] GTRU cjf$c_mxjnlnaml
	    THEN
		SIGNAL( set$_badvalue, 1, desc );
	    setfile$jflags[jrnl_ai_name] = 1;
	    ai_jnl_desc[dsc$w_length] = .desc[dsc$w_length];
	    CH$MOVE( .desc[dsc$w_length], .desc[dsc$a_pointer], ai_jnl_name );
	    END;
	END;

    !
    ! /JOURNAL=AT=at_journal_name
    !
    status = cli$present( %ASCID 'JOURNAL.AT', desc );
    IF .status NEQU cli$_absent
    THEN
	BEGIN
	setfile$jflags[jrnl_specified_at] = 1;
	IF .status
	THEN
	    setfile$jflags[jrnl_at] = 1
	ELSE if .status EQLU cli$_negated
	THEN
	    setfile$jflags[jrnl_at] = 0;
	IF cli$get_value( %ASCID 'JOURNAL.AT', desc )
	THEN
	    BEGIN
	    IF .desc[dsc$w_length] GTRU cjf$c_mxjnlnaml
	    THEN
		SIGNAL( set$_badvalue, 1, desc );
	    setfile$jflags[jrnl_at_name] = 1;
	    at_jnl_desc[dsc$w_length] = .desc[dsc$w_length];
	    CH$MOVE( .desc[dsc$w_length], .desc[dsc$a_pointer], at_jnl_name );
	    END;
	END;

    !
    ! /JOURNAL=BI=bi_journal_name
    !
    status = cli$present( %ASCID 'JOURNAL.BI', desc );
    IF .status NEQU cli$_absent
    THEN
	BEGIN
	setfile$jflags[jrnl_specified_bi] = 1;
	IF .status
	THEN
	    setfile$jflags[jrnl_bi] = 1
	ELSE if .status EQLU cli$_negated
	THEN
	    setfile$jflags[jrnl_bi] = 0;
	IF cli$get_value( %ASCID 'JOURNAL.BI', desc )
	THEN
	    BEGIN
	    IF .desc[dsc$w_length] GTRU cjf$c_mxjnlnaml
	    THEN
		SIGNAL( set$_badvalue, 1, desc );
	    setfile$jflags[jrnl_bi_name] = 1;
	    bi_jnl_desc[dsc$w_length] = .desc[dsc$w_length];
	    CH$MOVE( .desc[dsc$w_length], .desc[dsc$a_pointer], bi_jnl_name );
	    END;
	END;

    !
    ! /JOURNAL=RU
    !
    status = cli$present( %ASCID 'JOURNAL.RU', desc );
    IF .status NEQU cli$_absent
    THEN
	BEGIN
	setfile$jflags[jrnl_specified_ru] = 1;
	IF .status
	THEN
	    setfile$jflags[jrnl_ru] = 1
	ELSE if .status EQLU cli$_negated
	THEN
	    setfile$jflags[jrnl_ru] = 0;
	END;

    !
    ! /JOURNAL=NEVER_RU
    !
    status = cli$present( %ASCID 'JOURNAL.NEVER_RU', desc );
    IF .status NEQU cli$_absent
    THEN
	BEGIN
	setfile$jflags[jrnl_specified_never_ru] = 1;
	IF .status
	THEN
	    setfile$jflags[jrnl_never_ru] = 1
	ELSE if .status EQLU cli$_negated
	THEN
	    setfile$jflags[jrnl_never_ru] = 0;
	END;

    !
    ! /JOURNAL=ONLY_RU
    !
    status = cli$present( %ASCID 'JOURNAL.ONLY_RU', desc );
    IF .status NEQU cli$_absent
    THEN
	BEGIN
	setfile$jflags[jrnl_specified_only_ru] = 1;
	IF .status
	THEN
	    setfile$jflags[jrnl_only_ru] = 1
	ELSE if .status EQLU cli$_negated
	THEN
	    setfile$jflags[jrnl_only_ru] = 0;
	END;

    END;
end;	!**JNL**

!
! /LOG
!
setfile$flags[qual_log] = cli$present(%ASCID 'LOG');

!
! /NODIRECTORY
!
IF cli$present(%ASCID 'NODIRECTORY')
THEN setfile$flags[qual_nodi] = 1;

!
! /OWNER_UIC
!
IF cli$present(%ASCID 'OWNER_UIC')
THEN
    BEGIN
    setfile$flags[qual_owner] = 1;
    IF NOT cli$get_value(%ASCID 'OWNER_UIC', desc)
    THEN
	BEGIN
	LOCAL
	    iosb : VECTOR[4,WORD];
	status = $GETJPIW(ITMLST = UPLIT(WORD(4,jpi$_uic),
				         uic_value,
				 	 0,
				 	 0),
			   IOSB = iosb);
	IF .status
	THEN status = .iosb[0];
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL(.status);
	    RETURN false;
	    END;
	END
    ELSE
	BEGIN
	IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		  .desc[dsc$w_length], UPLIT(BYTE('PARENT')))
	THEN setfile$flags[qual_parent] = 1
	ELSE IF NOT (status = parse_uic(desc, uic_value))
	     THEN
		 BEGIN
		 SIGNAL(.status);
		 RETURN false;
		 END;
	END;
    END;
!
! /PROTECTION
!
IF cli$present(%ASCID 'PROTECTION')
THEN 
BEGIN
LOCAL
      prot_desc : $BBLOCK[dsc$c_s_bln];	! Protection descriptor

  setfile$flags[qual_protection] = 1;

!
! 	Parse the /PROTECTION= value 
!
  $init_dyndesc(prot_desc);		! Make a dynamic descriptor

  IF cli$present(%ASCID 'PROTECTION.SYSTEM')
  THEN
      BEGIN
      setpro_mask = .setpro_mask OR %X'000F';
      IF cli$get_value(%ASCID 'PROTECTION.SYSTEM',prot_desc)
      THEN setpro_prot = parse_class(prot_desc);
      END;
  IF cli$present(%ASCID 'PROTECTION.OWNER')
  THEN
      BEGIN
      setpro_mask = .setpro_mask OR %X'00F0';
      IF cli$get_value(%ASCID 'PROTECTION.OWNER',prot_desc)
      THEN setpro_prot = .setpro_prot OR parse_class(prot_desc)^4;
      END;
  IF cli$present(%ASCID 'PROTECTION.GROUP')
  THEN
      BEGIN
      setpro_mask = .setpro_mask OR %X'0F00';
      IF cli$get_value(%ASCID 'PROTECTION.GROUP',prot_desc)
      THEN setpro_prot = .setpro_prot OR parse_class(prot_desc)^8;
      END;
  IF cli$present(%ASCID 'PROTECTION.WORLD')
  THEN
      BEGIN
      setpro_mask = .setpro_mask OR %X'F000';
      IF cli$get_value(%ASCID 'PROTECTION.WORLD',prot_desc)
      THEN setpro_prot = .setpro_prot OR parse_class(prot_desc)^12;
      END;

!
! Complement the protection value since at this point, a bit set true 
! indicates that we want to ALLOW access, while the system convention
! is that a bit set true indicates that we want to DENY access.
!
  IF .setpro_mask NEQ 0			! If any protections specified
  THEN setpro_prot = NOT .setpro_prot;	! then get the complement

!
! Now save the command level protection in the protection
! area. If the user did not supply a command level protection then 
! the global_mask will have a value of zero. 

  global_mask = .setpro_mask;
  global_prot = .setpro_prot;
END;
!
! /REMOVE
!
IF cli$present(%ASCID 'REMOVE')
THEN setfile$flags[qual_remove] = 1;

!
! /TRUNCATE
!
IF cli$present(%ASCID 'TRUNCATE')
THEN setfile$flags[qual_trunc] = 1;

!
! /UNLOCK
!
IF cli$present(%ASCID 'UNLOCK')
THEN setfile$flags[qual_unlock] = 1;

!
! /VERSION_LIMIT 
!
IF cli$present(%ASCID 'VERSION_LIMIT')
THEN
    BEGIN
    setfile$flags[qual_vrsn] = 1;		! Show that /VERSION specified
    vrsn_value = 32767;				! Set to the default
    IF cli$get_value(%ASCID 'VERSION_LIMIT', desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   vrsn_value)
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;

	IF .vrsn_value EQL 0
	THEN
	    vrsn_value = 32767;

	IF .vrsn_value LSS 0
	  OR .vrsn_value GTR 32767
	THEN
	    (SIGNAL(set$_valerr); RETURN false);
    	END;
    END;

RETURN true;
END;

ROUTINE parse_null_string (fab) : NOVALUE =
!++
!
! This routine parses the null string on the specified FAB to
! force RMS to clear all internal saved context.
!
!--
BEGIN
MAP
    fab : REF $BBLOCK;

LOCAL
    nam : REF $BBLOCK;

nam = .fab[fab$l_nam];
nam[nam$v_svctx] = 0;
nam[nam$v_synchk] = 1;
nam[nam$b_esl] = 0;
nam[nam$b_ess] = 0;
nam[nam$b_rsl] = 0;
nam[nam$b_rss] = 0;
nam[nam$l_esa] = 0;
nam[nam$l_rsa] = 0;
nam[nam$l_rlf] = 0;
fab[fab$b_fns] = 0;
fab[fab$b_dns] = 0;
$parse(fab=.fab);
RETURN;
END;

ROUTINE set_attributes (fab) =
!++
!
! This is the routine that actually accesses the file, and sets the
! specified attributes.  If an error occurs while attempting to set
! the attributes, a message telling the user is issued, and any other
! files are processed.
!
!--
BEGIN

MAP
    fab : REF $BBLOCK;			! Define the fab



LOCAL
    atr : BLOCKVECTOR[13,8,BYTE],	! Attribute control block
    ptr,				! Pointer to attribute block
    status,				! Status return
    channel : WORD,			! Channel number
    desc : $BBLOCK[dsc$c_s_bln],		! General descriptor
    fib : $BBLOCK[fib$c_length],		! A FIB for the QIO 
    header : $BBLOCK[512],		! The file header
    item_list : $ITMLST_DECL (ITEMS=1),	! Item list for GETDVI volume label
    ai_jnl_ace : $BBLOCK[4+cjf$c_mxjnlnaml],	! ACE to contain AI journal name
    at_jnl_ace : $BBLOCK[4+cjf$c_mxjnlnaml],	! ACE to contain AT journal name
    bi_jnl_ace : $BBLOCK[4+cjf$c_mxjnlnaml],	! ACE to contain BI journal name
    label_buffer : VECTOR[12,BYTE],		! Buffer for volume label
    iosb : VECTOR[4,WORD];		! I/O status block

BIND
    recattr = header[fh2$w_recattr] : $BBLOCK[atr$s_recattr],

    nam = .fab[fab$l_nam] : $BBLOCK;	! Define the name block

OWN
    rmsjnlid_ace : $BBLOCK[id_ace$s_size],	! ACE to contain RMS jnl ident
    old_did_num : WORD,				! Old directory id
    old_did_seq : WORD,
    old_did_rvn : WORD;

!
! If no more processing is to be performed, then simply return.  This handles
! the case of wildcards which do not return for each file to the routine
! that called lib$file_scan.
!
IF .setfile$flags[qual_quit]
THEN RETURN true;

!
! See if the common specified common qualifiers match this one.
!
conf_desc[dsc$a_pointer] = .nam[nam$l_rsa];	! Get the resultant name
conf_desc[dsc$w_length] = .nam[nam$b_rsl];	! of this file

status = lib$qual_file_match(context,		! Call the common qualifier routine
    			     0,
    			     conf_desc,
    			     0,
    			     0,
    			     0);
IF NOT .status				! If the status is false, check
THEN					! if it is the "correct" false
    BEGIN				! errors that says 
    IF .status NEQ lib$_filfaimat	! "file didn't match qualifiers" 
    THEN SIGNAL(set$_openin,		! Else signal it
    		1,
    		conf_desc,
    		.status);
    RETURN true;			! and DON'T process this file
    END;


!
! Assign a channel to the file's device
!
desc[dsc$w_length] = .nam[nam$b_dev];	! Set up the descriptor
desc[dsc$a_pointer] = .nam[nam$l_dev];	! to point to the device name
IF NOT (status = $ASSIGN(
    			DEVNAM = desc,
    			CHAN = channel))
THEN 
    BEGIN
    file_error( set$_openin,
		.status, .fab);		! Tell user why the assign failed
    RETURN true;			! And continue with other files
    END;

!
! Access the file, reading the file's header
!
desc[dsc$w_length] = fib$c_length;	! Re-use descriptor to point to FIB
desc[dsc$a_pointer] = fib;

CH$FILL(0,fib$c_length,fib);		! Zero out the FIB

fib[fib$l_acctl] = fib$m_write OR	! Set up the FIB
    		   fib$m_noread OR
    		   fib$m_nowrite;

fib[fib$w_fid_num] = .nam[nam$w_fid_num];	! Put in the file id
fib[fib$w_fid_seq] = .nam[nam$w_fid_seq];
fib[fib$w_fid_rvn] = .nam[nam$w_fid_rvn];


!
! Unless some option was specified that requires the file header, don't
! bother to get it.
!
IF (.setfile$flags[qual_backup] OR
    .setfile$flags[qual_nobackup] OR
    .setfile$flags[qual_data] OR
    .setfile$flags[qual_eof] OR
    .setfile$flags[qual_erase] OR
    .setfile$flags[qual_noerase] OR
    .setfile$flags[qual_expi] OR
    .setfile$flags[qual_exte] OR
    .setfile$flags[qual_gbuf] OR
    .setfile$flags[qual_journal] OR
    .setfile$flags[qual_nodi] OR
    .setfile$flags[qual_owner] OR
    .setfile$flags[qual_trunc] OR
    .setfile$flags[qual_vrsn])
AND 
    BEGIN
    IF .setfile$flags[qual_quit_mod]
    OR NOT .setfile$flags[qual_confirm]
    THEN true
    ELSE
	BEGIN
	status = lib$confirm_act(%ASCID 'Modify file !AS? [N] : ',
				 %REF(conf_desc));
	IF NOT .status
	THEN
	    BEGIN
	    IF .status EQL lib$_quipro
	    THEN (setfile$flags[qual_quit] = 1; RETURN true)
	    ELSE IF .status EQL lib$_quiconact
	    THEN (setfile$flags[qual_quit_mod] = 1; status = 1)
	    ELSE IF .status NEQ lib$_negans
	    THEN SIGNAL(set$_writeerr, 1, conf_desc, .status);
	    END;
        .status
	END
    END
THEN
BEGIN

atr[0,atr$w_type] = atr$c_header;		! Get the file header
atr[0,atr$w_size] = atr$s_header;
atr[0,atr$l_addr] = header;
atr[1,atr$w_type] = atr$c_fndacetyp;		! Look for an rmsjnlid ACE
atr[1,atr$w_size] = id_ace$s_size;
atr[1,atr$l_addr] = rmsjnlid_ace;
atr[2,0,0,32,0] = 0;

rmsjnlid_ace[ace$b_size] = id_ace$s_size;
rmsjnlid_ace[ace$b_type] = ace$c_jnlid;
rmsjnlid_ace[ace$w_flags] = ace$m_hidden OR ace$m_protected;

status = $QIOW(	CHAN = .channel,
		FUNC = IO$_ACCESS OR IO$M_ACCESS,
		IOSB = iosb,
		P1 = desc,
		P5 = atr);
IF .status THEN status = .iosb[0];
IF NOT .status 
THEN file_error(set$_readerr,.status,.fab)
ELSE
    BEGIN
!
! Check to see whether this is an ODS1 or an ODS2 file.  If ODS1,
! copy the record attributes into the ODS2 location.
!
    IF .header[fh2$b_struclev] EQL 1
    THEN CH$MOVE(fat$c_length, header[fh1$w_recattr], header[fh2$w_recattr]);

!
! See if an rmsjnlid ACE already exists.  Don't create a new one later, since
! one is good enough.
!
    IF .rmsjnlid_ace[ace$b_type] NEQ 0
    THEN
	setfile$mflags[misc_already_rmsjnlid] = 1;

!
! Initialize the pointer to the attribute control block.  The block
! will be built as we go, and the pointer shows where the next attribute
! should go in the block.
!
    ptr = 0;

!
! Change the file characteristics
!
    status = 0;			! Show that nothing has changed

    IF .setfile$flags[qual_backup]		! /BACKUP
    THEN
	BEGIN
	header[fh2$v_nobackup] = 0;
	status = 1;
	END;
    IF .setfile$flags[qual_nobackup]		! /NOBACKUP
    THEN
	BEGIN
	header[fh2$v_nobackup] = 1;
	status = 1;
	END;

    IF .setfile$flags[qual_erase]		! /ERASE
    THEN
	BEGIN
	IF .header[fh2$b_struclev] EQL 1 	! If not ODS2
	THEN SIGNAL(set$_notods2,		! tell the user
		    1,
		    $DESCRIPTOR('/ERASE'))
	ELSE
	    BEGIN
	    header[fh2$v_erase] = 1;
	    status = 1;
	    END;
	END;
    IF .setfile$flags[qual_noerase]		! /NOERASE
    THEN
	BEGIN
	IF .header[fh2$b_struclev] EQL 1 	! If not ODS2
	THEN SIGNAL(set$_notods2,		! tell the user
		    1,
		    $DESCRIPTOR('/NOERASE'))
	ELSE
	    BEGIN
	    header[fh2$v_erase] = 0;
	    status = 1;
	    END;
	END;

    IF .setfile$flags[qual_data]		! /DATA_CHECK
    THEN
        BEGIN
        IF .setfile$dflags[data_read] THEN header[fh2$v_readcheck] = 1;
        IF .setfile$dflags[data_noread] THEN header[fh2$v_readcheck] = 0;
        IF .setfile$dflags[data_write] THEN header[fh2$v_writcheck]= 1;
        IF .setfile$dflags[data_nowrite] THEN header[fh2$v_writcheck] =0;
	status = 1;
        END;

    IF .setfile$flags[qual_nodi]		! /NODIRECTORY
    THEN
	BEGIN
	IF .header[fh2$b_struclev] EQL 1	! If not ODS2
	THEN SIGNAL (set$_notods2,		! tell the user
		     1,
		     $DESCRIPTOR('/NODIRECTORY'))
	ELSE
	    BEGIN
	    header[fh2$v_directory] = 0;
	    status = 1;
	    END;
	END;

!
! If something in the file characteristics was changed, show it.
!
    IF .status
    THEN
    	BEGIN
	atr[.ptr,atr$w_type] = atr$c_uchar;
	atr[.ptr,atr$w_size] = atr$s_uchar;
	atr[.ptr,atr$l_addr] = header[fh2$l_filechar];
	ptr = .ptr + 1;
	status = 0;			! Reset the change indicator
	END;

!
! Modify the record attributes
!

    IF .setfile$flags[qual_exte]		! /EXTENSION
    THEN 
	BEGIN
	recattr[fat$w_defext] = .exte_value;
	status = 1;
	END;
!
! IF /END_OF_FILE was specified, set the eof_block equal to the
! highest block allocated, and the first free byte in that block
! to 512, indicating that the entire allocated space is used.
!
    IF .setfile$flags[qual_eof]
    THEN
	BEGIN
    	IF  .nam[nam$w_fid_num] EQL 1			! If INDEXF.SYS
	AND .nam[nam$w_fid_seq] EQL 1
	AND .nam[nam$b_fid_nmx] EQL 0
	THEN SIGNAL (set$_writeerr,			! Signal an error
		     1,					! modifying it
		     conf_desc,				! because of an
		     ss$_acconflict)
	ELSE
	    BEGIN
	    recattr[fat$l_efblk] = .recattr[fat$l_hiblk];
	    recattr[fat$w_ffbyte] = 512;
	    status = 1;
	    END;
	END;
!
! If /GLOBAL_BUFFERS was specified, set the global buffer count to
! the value specified.
!
    IF .setfile$flags[qual_gbuf]
    THEN
	BEGIN
	recattr[fat$w_gbc] = .gbuf_value;
	status = 1;
	END;
!
! If something in the user attributes was changed, show it.
!
    IF .status
    THEN
	BEGIN
	atr[.ptr,atr$w_type] = atr$c_recattr;
	atr[.ptr,atr$w_size] = atr$s_recattr;
	atr[.ptr,atr$l_addr] = header[fh2$w_recattr];
	ptr = .ptr + 1;
	END;

!
! Expiration date
!
    IF .setfile$flags[qual_expi]
    THEN
	BEGIN
	CH$MOVE(8,exp_value,header[fi2$q_expdate]);
	atr[.ptr,atr$w_type] = atr$c_expdate;
	atr[.ptr,atr$w_size] = atr$s_expdate;
	atr[.ptr,atr$l_addr] = header[fi2$q_expdate];
	ptr = .ptr + 1;
	END;

!
! Owner UIC
!
    IF .setfile$flags[qual_owner]
    THEN
	BEGIN
!
! If the qualifier OWNER=PARENT was specified, then the UIC of the owner 
! directory must be found.  Rather than accessing the directory every time, a 
! test is made to determine if the directory's UIC has already been found.  If 
! so, then the current value of UIC_VALUE is used.  Otherwise, a new value is 
! found.
!
	IF .setfile$flags[qual_parent]
	THEN
	    BEGIN
	    IF NOT ((.nam[nam$w_did_num] EQL .old_did_num) AND
		    (.nam[nam$w_did_seq] EQL .old_did_seq) AND
		    (.nam[nam$w_did_rvn] EQL .old_did_rvn))
	    THEN
		BEGIN
		LOCAL
		    temp_atr : BLOCKVECTOR[2,8,BYTE],
		    temp_desc : $BBLOCK[dsc$c_s_bln],
		    temp_fib : $BBLOCK[fib$c_extdata],
		    temp_chan;

		temp_desc[dsc$w_length] = .nam[nam$b_dev];
		temp_desc[dsc$a_pointer] = .nam[nam$l_dev];
		IF NOT (status = $ASSIGN(DEVNAM = temp_desc,
					 CHAN =temp_chan))
		THEN
		    BEGIN
		    $DASSGN(CHAN = .channel);
		    SIGNAL(set$_opendir, 1, conf_desc, .status);
		    RETURN true;
		    END;

		CH$FILL(0, fib$c_extdata, temp_fib);

		temp_fib[fib$l_acctl] = fib$m_noread OR fib$m_nowrite;
		temp_fib[fib$w_fid_num] = .nam[nam$w_did_num];
		temp_fib[fib$w_fid_seq] = .nam[nam$w_did_seq];
		temp_fib[fib$w_fid_rvn] = .nam[nam$w_did_rvn];

		temp_atr[0,atr$w_type] = atr$c_uic;
		temp_atr[0,atr$w_size] = atr$s_uic;
		temp_atr[0,atr$l_addr] = uic_value;
		temp_atr[1,0,0,32,0] = 0;

		temp_desc[dsc$w_length] = fib$c_extdata;
		temp_desc[dsc$a_pointer] = temp_fib;

		status = $QIOW( CHAN = .temp_chan,
				FUNC = IO$_ACCESS,
				IOSB = iosb,
				P1 = temp_desc,
				p5 = temp_atr);
		IF .status THEN status = .iosb[0];
		IF NOT .status 
		THEN SIGNAL_STOP(set$_opendir, 1, conf_desc, .status);
		$DASSGN (CHAN = .temp_chan);
		END;
	    END;
		
	header[fh2$l_fileowner] = .uic_value;
	atr[.ptr,atr$w_type] = atr$c_uic;
	atr[.ptr,atr$w_size] = atr$s_uic;
	atr[.ptr,atr$l_addr] = header[fh2$l_fileowner];
	ptr = .ptr + 1;
	END;

!
! If /TRUNCATE was specified, find the block containing the EOF.  If
! the EOF occurred somewhere in that block, then truncate to the next
! block.
!
    IF .setfile$flags[qual_trunc] THEN
	BEGIN
	IF .recattr[fat$v_fileorg] EQL fat$c_indexed
	THEN
	    SIGNAL(set$_writeerr, 1, conf_desc, set$_notrunc)
	ELSE
	    BEGIN
	    fib[fib$v_trunc] = 1;
	    fib[fib$l_exvbn] = .recattr[fat$w_efblkh]^16
				 + .recattr[fat$w_efblkl];
	    IF .recattr[fat$w_ffbyte] GTR 0
	    THEN fib[fib$l_exvbn] = .fib[fib$l_exvbn] + 1;
	    END;
	END;
!
! Set the version limit for a particular file
!
    IF .setfile$flags[qual_vrsn]
    THEN
	BEGIN
	fib[fib$w_did_num] = .nam[nam$w_did_num];	! Specify the directory
	fib[fib$w_did_seq] = .nam[nam$w_did_seq];
	fib[fib$w_did_rvn] = .nam[nam$w_did_rvn];

	fib[fib$v_findfid] = true;			! Set the findfid bit

	fib[fib$w_verlimit] = .vrsn_value;		! And the version limit
	END;

!
! If any journaling was requested, make those modifications
!

    status = 0;					! Flag: journaling info changed.

    IF .setfile$flags[qual_journal]		! /JOURNAL
    THEN
	BEGIN
	IF .header[fh2$b_struclev] EQL 1	! If not ODS2
	THEN SIGNAL(set$_notods2,		! tell the user
		    1,
		    $DESCRIPTOR('/JOURNAL'))
	ELSE
	    BEGIN
	    !
	    ! If any of the RU journal bits are going to be set,
	    !    clear the existing header RU bits to avoid conflicts
	    !
	    IF (.setfile$jflags[jrnl_only_ru] OR .setfile$jflags[jrnl_never_ru]
		  		OR .setfile$jflags[jrnl_ru])
	    THEN
		BEGIN
		header[fh2$v_rujnl] = 0;
		header[fh2$v_only_ru] = 0;
		header[fh2$v_never_ru] = 0;
		END;

	    IF .setfile$jflags[jrnl_specified_ru]
					! RU
	    THEN
		BEGIN
		header[fh2$v_rujnl] = .setfile$jflags[jrnl_ru];
		setfile$mflags[misc_mark_file] = 1;
		status = 1;
		END
	    ELSE IF .setfile$jflags[jrnl_specified_only_ru]
					! RU only
	    THEN
	    	BEGIN
	    	header[fh2$v_only_ru] = .setfile$jflags[jrnl_only_ru];
		setfile$mflags[misc_mark_file] = 1;
	    	status = 1;
	    	END
	    ELSE IF .setfile$jflags[jrnl_specified_never_ru]
					! RU never
	    THEN
	    	BEGIN
	    	header[fh2$v_never_ru] = .setfile$jflags[jrnl_never_ru];
		setfile$mflags[misc_mark_file] = 1;
	    	status = 1;
	    	END;

	    IF .setfile$jflags[jrnl_specified_ai]
					! AI journaling
	    THEN
	    	BEGIN
	    	header[fh2$v_aijnl] = .setfile$jflags[jrnl_ai];
		setfile$mflags[misc_mark_file] = 1;
	    	status = 1;
	    	END;
	    IF .setfile$jflags[jrnl_specified_at]
					! AT journaling
	    THEN
	    	BEGIN
	    	header[fh2$v_atjnl] = .setfile$jflags[jrnl_at];
		setfile$mflags[misc_mark_file] = 1;
	    	status = 1;
	    	END;
	    IF .setfile$jflags[jrnl_specified_bi]
					! BI journaling
	    THEN
	    	BEGIN
	    	header[fh2$v_bijnl] = .setfile$jflags[jrnl_bi];
		setfile$mflags[misc_mark_file] = 1;
	    	status = 1;
	    	END;
	    END;
	END;

!
! If there were any journal bits set, show it.
!

    IF (.status EQL 1) 
    THEN
	BEGIN
	atr[.ptr,atr$w_type] = atr$c_journal;
	atr[.ptr,atr$w_size] = atr$s_journal;
	atr[.ptr,atr$l_addr] = header[fh2$w_journal];
	ptr = .ptr + 1;
	END;

!
! If an rmsjnlid ACE needs to be added, add it here.
!
! (Only one rmsjnlid ace is needed for journaled file.)
!
    IF .setfile$mflags[misc_mark_file] AND NOT .setfile$mflags[misc_already_rmsjnlid]
    THEN
	BEGIN
	!
	! Build JNLID ACE: volume name + file ID + current date/time.
	!
	rmsjnlid_ace[ace$b_size] = id_ace$s_size;
	rmsjnlid_ace[ace$b_type] = ace$c_jnlid;
	rmsjnlid_ace[ace$w_flags] =
		ace$m_hidden OR ace$m_protected OR ace$m_nopropagate;

	$ITMLST_INIT (ITMLST = item_list, (ITMCOD = dvi$_volnam,
		BUFADR = label_buffer, BUFSIZ = 12));

	status = $GETDVI(EFN = 1, CHAN = .channel, ITMLST = item_list,
				IOSB = iosb);
	IF .status
	THEN
	    $WAITFR(EFN = 1)
	ELSE
	    SIGNAL( set$_badlogic, 0, .status, 0 );
	IF NOT .iosb[0]
	THEN
	    SIGNAL( set$_badlogic, 0, .iosb[0], 0 );

	CH$MOVE(12, label_buffer, rmsjnlid_ace[id_ace$t_label]);

	rmsjnlid_ace[id_ace$w_num] = .nam[nam$w_fid_num];
	rmsjnlid_ace[id_ace$w_seq] = .nam[nam$w_fid_seq];
	rmsjnlid_ace[id_ace$w_rvn] = .nam[nam$w_fid_rvn];

	$GETTIM( TIMADR = rmsjnlid_ace[id_ace$q_time] );

	atr[.ptr,atr$w_type] = atr$c_addaclent;
	atr[.ptr,atr$w_size] = id_ace$s_size;
	atr[.ptr,atr$l_addr] = rmsjnlid_ace;
	ptr = .ptr + 1;
	END;


!
! Record journals to use in access control list.
!

!
! AI Journal Name
!

    IF .setfile$jflags[jrnl_ai_name]
    THEN
	BEGIN
	atr[.ptr,atr$w_type] = atr$c_addaclent;
	atr[.ptr,atr$w_size] = 4 + .ai_jnl_desc[dsc$w_length];
	atr[.ptr,atr$l_addr] = ai_jnl_ace;
	ptr = .ptr + 1;

	ai_jnl_ace[ace$b_size] = 4 + .ai_jnl_desc[dsc$w_length];
	ai_jnl_ace[ace$b_type] = ace$c_aijnl;
	ai_jnl_ace[ace$w_flags] = ace$m_hidden OR ace$m_protected;

	CH$MOVE (.ai_jnl_desc[dsc$w_length],
		 .ai_jnl_desc[dsc$a_pointer],
		 ai_jnl_ace[ace$t_jnlnam]);
	END;

!
! AT Journal Name
!

    IF .setfile$jflags[jrnl_at_name]
    THEN
	BEGIN
	atr[.ptr,atr$w_type] = atr$c_addaclent;
	atr[.ptr,atr$w_size] = 4 + .at_jnl_desc[dsc$w_length];
	atr[.ptr,atr$l_addr] = at_jnl_ace;
	ptr = .ptr + 1;

	at_jnl_ace[ace$b_size] = 4 + .at_jnl_desc[dsc$w_length];
	at_jnl_ace[ace$b_type] = ace$c_atjnl;
	at_jnl_ace[ace$w_flags] = ace$m_hidden OR ace$m_protected;

	CH$MOVE (.at_jnl_desc[dsc$w_length],
		 .at_jnl_desc[dsc$a_pointer],
		 at_jnl_ace[ace$t_jnlnam]);
	END;

!
! BI Journal Name
!

    IF .setfile$jflags[jrnl_bi_name]
    THEN
	BEGIN
	atr[.ptr,atr$w_type] = atr$c_addaclent;
	atr[.ptr,atr$w_size] = 4 + .bi_jnl_desc[dsc$w_length];
	atr[.ptr,atr$l_addr] = bi_jnl_ace;
	ptr = .ptr + 1;

	bi_jnl_ace[ace$b_size] = 4 + .bi_jnl_desc[dsc$w_length];
	bi_jnl_ace[ace$b_type] = ace$c_bijnl;
	bi_jnl_ace[ace$w_flags] = ace$m_hidden OR ace$m_protected;

	CH$MOVE (.bi_jnl_desc[dsc$w_length],
		 .bi_jnl_desc[dsc$a_pointer],
		 bi_jnl_ace[ace$t_jnlnam]);
	END;


!
! Write the modifications out to the file header, and close the file.
!

    fib[fib$l_aclctx] = 0;		! Make sure RMS journaling ACEs go first.
    atr[.ptr,0,0,32,0] = 0;		! Put a zero at end of attribute list

    IF (   .ptr NEQ 0  			! If an attribute was changed
	OR .setfile$flags[qual_trunc] 	! Or the file should be truncated
	OR .setfile$flags[qual_vrsn])	! Or the version_limit set
    THEN
    	BEGIN
	LOCAL	RES_DESC : $BBLOCK [8],
		RES_BUF : $BBLOCK [512],
		RES_LEN;
	CH$FILL (0, 8, RES_DESC);
	RES_DESC[DSC$W_LENGTH] = 512;
	RES_DESC[DSC$A_POINTER] = RES_BUF;
	status = $QIOW( CHAN = .channel,	! Make the modifications
			FUNC = IO$_MODIFY,
			IOSB = iosb,
			P1 = desc,
			P3 = RES_LEN,
			P4 = RES_DESC,
			P5 = atr);
	IF .status THEN status = .iosb[0];
	IF NOT .status
	THEN file_error(set$_writeerr,.status,.fab)	! If the modify failed, tell user
	ELSE
	    IF .setfile$flags[qual_log]		! If /LOG, tell user
	    THEN SIGNAL(set$_modified,1,conf_desc);
    	END;

!
! Now to close the file.  Don't bother to check the status, since the
! modifications got made correctly.
!
    $QIOW( CHAN = .channel,			! Deaccess the file
	   FUNC = IO$_DEACCESS,
	   IOSB = iosb,
	   P1 = desc);
    END;
END;

!
! If /REMOVE or /ENTER was specified, process it
!
IF (.setfile$flags[qual_remove] OR .setfile$flags[qual_enter])
THEN
    BEGIN

!
! Set up the FIB appropriately
!

    fib[fib$w_did_num] = .nam[nam$w_did_num];	! Put in the directory ID
    fib[fib$w_did_seq] = .nam[nam$w_did_seq];
    fib[fib$w_did_rvn] = .nam[nam$w_did_rvn];

!
! If /REMOVE was specified, remove the directory entry 
!
    IF .setfile$flags[qual_remove]
    THEN
	BEGIN
!
! Check to see if an explicit or wild version number was specified.
! If not, exit with an error.
!
	IF NOT (.nam[nam$v_exp_ver] OR
		.nam[nam$v_wild_ver])
	THEN SIGNAL(set$_remerr,
			 1,
			 conf_desc,
			 set$_delver)
!
! If /CONFIRM was set by the user, then interrogate him to see
! if the directory entry is to be removed.
!
	ELSE
	IF
	    BEGIN
	    IF .setfile$flags[qual_quit_rem]
	    OR NOT .setfile$flags[qual_confirm]
	    THEN true
	    ELSE
		BEGIN
		status = lib$confirm_act(%ASCID 'Remove directory entry for !AS? [N]: ',
					 %REF(conf_desc));
		IF NOT .status
		THEN
		    BEGIN
		    IF .status EQL lib$_quipro
		    THEN (setfile$flags[qual_quit] = 1; RETURN true)
		    ELSE IF .status EQL lib$_quiconact
		    THEN (setfile$flags[qual_quit_rem] = 1; status = 1)
	    	    ELSE IF .status NEQ lib$_negans
		    THEN SIGNAL(set$_writeerr, 1, conf_desc, .status);
		    END;
		.status
		END
	    END
	THEN
	    BEGIN

	    fib[fib$w_fid_num] = 0;			! Clear the File ID
	    fib[fib$w_fid_seq] = 0;
	    fib[fib$w_fid_rvn] = 0;


    !
    ! Isolate the file portion of the resultant file string
    !
	    file_name[0] = .nam[nam$b_name]
			   + .nam[nam$b_type]
			   + .nam[nam$b_ver];
	    file_name[1] = .nam[nam$l_name];

    !
    ! Issue the QIO to remove the directory entry
    !
	    status = $QIOW( CHAN = .channel,
			    FUNC = IO$_DELETE,
			    IOSB = iosb,
			    P1 = desc,
			    P2 = file_name);
	    IF .status THEN status = .iosb[0];
	    IF NOT .status
	    THEN SIGNAL(set$_writeerr,		! Error writing
			1,
			file_name,			! to this file
			.status)			! for this reason
	    ELSE
		IF .setfile$flags[qual_log]		! If /LOG, tell user
		THEN SIGNAL(set$_removed,1,conf_desc);
	    END;
    	END
!
! IF /ENTER, enter the name in the directory
!
    ELSE
	BEGIN
	LOCAL
	    new_name : VECTOR[2],		! Place to put new filespec
	    new_fab : $BBLOCK[fab$c_bln],	! Temp output fab
	    new_nam : $BBLOCK[nam$c_bln],	! Temp output name block
	    new_nam2 : $BBLOCK[nam$c_bln],	!  another temp nam block
	    new_desc : $BBLOCK[dsc$c_s_bln],	! Descriptor for new name
	    new_nam_exp : VECTOR[nam$c_maxrss,BYTE], ! Expanded string
	    new_nam_exp2 : VECTOR[nam$c_maxrss,BYTE];! Expanded string2
!
! Initialize the fab and name block, using the original file name block
! as the related file.
!
	$FAB_INIT ( FAB = new_fab,
		    NAM = new_nam,
		    FNA = .file_name[1],
		    FNS = .file_name[0]);
	$NAM_INIT ( NAM = new_nam,
		    RLF = nam,
		    ESA = new_nam_exp,
		    ESS = nam$c_maxrss);
!
! If the original file specification had a wildcard version number, then
! use one here.
!
	IF (.nam[nam$v_wild_ver])
	THEN
	    BEGIN
	    new_fab[fab$l_dna] = UPLIT(';*');
	    new_fab[fab$b_dns] = %CHARCOUNT(';*');
	    END
	ELSE
	    BEGIN
	    new_fab[fab$l_dna] = 0;
	    new_fab[fab$b_dns] = 0;
	    END;
!
! Parse once, with the OFP bit off, to fill in all the fields
! from the original name block
!
	status = $PARSE (FAB = new_fab);
	CH$MOVE(nam$c_bln,new_nam,new_nam2);
	parse_null_string(new_fab);
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL_STOP(set$_enterr,
    			2,
    			conf_desc,
    			file_name,
    			.status);
	    RETURN true;
	    END;

!
! Now parse with OFP set, to obtain the final file name
!
	$FAB_INIT(  FAB = new_fab,
		    NAM = new_nam,
		    FNA = .new_nam2[nam$l_esa],
		    FNS = .new_nam2[nam$b_esl],
		    FOP = ofp);
	$NAM_INIT(  NAM = new_nam,
		    RLF = nam,
		    ESA = new_nam_exp2,
		    ESS = nam$c_maxrss);

	status = $PARSE (FAB = new_fab);
	CH$MOVE(nam$c_bln,new_nam,new_nam2);
	parse_null_string(new_fab);
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL(set$_enterr,			! Error entering
		   2,
		   conf_desc,				! This file
		   file_name,				! as this file
		   .status);				! Not on same device
	    RETURN true;
	    END;

!
! Get the full file name
!
	new_name[0] = .new_nam2[nam$b_esl];
	new_name[1] = .new_nam2[nam$l_esa];

!
! Find the actual file name
!
	new_desc[dsc$w_length] = .new_nam2[nam$b_name]
				 + .new_nam2[nam$b_type]
				 + .new_nam2[nam$b_ver];
	new_desc[dsc$a_pointer] = .new_nam2[nam$l_name];

!
! Put in the file ID of the target directory
!
	fib[fib$w_did_num] = .new_nam2[nam$w_did_num];
	fib[fib$w_did_seq] = .new_nam2[nam$w_did_seq];
	fib[fib$w_did_rvn] = .new_nam2[nam$w_did_rvn];
!
! Check to see that the enter request is for the same device.  If not,
! signal an error.  This is done by comparing the DVI field of the RMS 
! name blocks.
!

	IF CH$NEQ( .(nam[nam$t_dvi])<0,8>, nam[nam$t_dvi]+1,
		   .(new_nam2[nam$t_dvi])<0,8>, new_nam2[nam$t_dvi]+1, 0)
	THEN SIGNAL(set$_enterr,			! Error entering
		    2,
		    conf_desc,				! This file
		    new_name,				! as this file
		    RMS$_DEV)				! Not on same device
	ELSE
!
! If /CONFIRM was set by the user, then interrogate him to see
! if the file is to be entered in a directory.
!
    	IF
	    BEGIN
	    IF .setfile$flags[qual_quit_ent]
	    OR NOT .setfile$flags[qual_confirm]
	    THEN true
	    ELSE
		BEGIN
		LOCAL
		    arglist : VECTOR[2];
		arglist[0] = conf_desc;
		arglist[1] = new_name;
		status = lib$confirm_act(%ASCID 'Enter !AS as !AS? [N]: ',
					 arglist);
		IF NOT .status
		THEN
		    BEGIN
		    IF .status EQL lib$_quipro
		    THEN (setfile$flags[qual_quit] = 1; RETURN true)
		    ELSE IF .status EQL lib$_quiconact
		    THEN (setfile$flags[qual_quit_ent] = 1; status = 1)
	    	    ELSE IF .status NEQ lib$_negans
		    THEN SIGNAL(set$_writeerr, 1, conf_desc, .status);
		    END;
		.status
		END
	    END
	THEN
	    BEGIN
!
! Issue the QIO
!			

	    status = $QIOW( CHAN = .channel,	! Enter the new name
			    FUNC = IO$_CREATE,
			    IOSB = iosb,
			    P1 = desc,
			    P2 = new_desc);
	    IF .status THEN status = .iosb[0];
	    IF NOT .status
	    THEN SIGNAL(set$_enterr,		! Error enterring
			2,
			conf_desc,		! this file
		    	new_name,		! as this file
			.status)		! for this reason
	    ELSE
		IF .setfile$flags[qual_log]	! If /LOG, tell user
		THEN SIGNAL(set$_entered,2,conf_desc,new_name);
	    END;
	END;					! End of /ENTER block
    END;					! End of modify block
!
! If /UNLOCK was specified by the user
!
    IF .setfile$flags[qual_unlock]
    THEN
        IF NOT (status = unlock_action(.fab))
        THEN
           SIGNAL(set$_unlockerr,1,conf_desc,.status);

!
! If /PROTECTION was specified by the user
!
     IF .setfile$flags[qual_protection]
     THEN
         IF NOT (status = setpro_action(.fab))
	 THEN
	    SIGNAL(set$_proerr,1,conf_desc,.status);


!
! Deassign the channel
!
IF NOT (status = $DASSGN(CHAN = .channel))
THEN file_error(set$_closeerr,.status,.fab);		! If deassign failed, say so

RETURN true;				! Continue processing other files
END;

GLOBAL ROUTINE file_error (status1,status2,fab) =
!++
!
! This routine is called if an error occured while trying to access
! a file.  The kind of error is signalled, along with the file name.
!
!--
BEGIN

MAP
    fab : REF $BBLOCK;			! Define the fab

BIND
    status = status2 : $BBLOCK,
    nam = .fab[fab$l_nam] : $BBLOCK;	! Define the name block


LOCAL
    desc : VECTOR[2];			! A temporary descriptor

!
! Check to see if there's a name in the resultant string field.
! If there is, use it.
!
IF .nam[nam$b_rsl] NEQ 0
THEN
    BEGIN
    desc[0] = .nam[nam$b_rsl];
    desc[1] = .nam[nam$l_rsa];
    END

!
! If no resultant name, try the expanded name
!
ELSE IF .nam[nam$b_esl] NEQ 0
THEN
    BEGIN
    desc[0] = .nam[nam$b_esl];
    desc[1] = .nam[nam$l_esa];
    END

!
! If no expanded name, use the original name in the fab
!
ELSE
    BEGIN
    desc[0] = .fab[fab$b_fns];
    desc[1] = .fab[fab$l_fna];
    END;

!
! Signal the error
!
SIGNAL(.status1,			! Report error
	1,				! One FAO argument
	desc,				! Which is the file name
	.status);			! Plus original error
RETURN true;
END;


GLOBAL ROUTINE check_privilege : NOVALUE =
!++
! 
! This routine checks that the image has the correct privilege.
!
!---
BEGIN

LOCAL
    status,
    oldpriv : $BBLOCK[8];		! Permanent privileges go here

OWN
    newpriv : $BBLOCK[8]			! Mask to disable SYSPRV
    	      PRESET([prv$v_sysprv]=true);

!
! The image SET is installed with SYSPRV privilege, but we don't want the user 
! to have that much power unless s/he already has it.  So, first check to 
! see if the process has the privilege, and if not, then remove it for the
! duration of this image.
!
IF NOT (status = $SETPRV(ENBFLG = 1,		! Enable
    			 PRVADR = 0,		! No new privileges
    			 PRMFLG = 1,		! Permanent privs
    			 PRVPRV = oldpriv))	! Store current ones here
THEN SIGNAL_STOP(.status);
!
! Check to see if privilege there.  If not, then remove it from current
! privileges.
!
IF NOT .oldpriv[prv$v_sysprv]			! If SYSPRV not permanent
THEN 
    BEGIN
    IF NOT (status = $SETPRV(ENBFLG = 0,	! Disable
    			     PRVADR = newpriv,	! this privilege
    			     PRMFLG = 0,	! for the duration of this image
    			     PRVPRV = 0))
    THEN SIGNAL_STOP(.status)
    END;

RETURN;
END;

GLOBAL ROUTINE search_error (fab) =
!++
!
! This routine is called when lib$file_scan detects an error while
! searching for a file specified in the command line.
!
!--
BEGIN

MAP
    fab : REF $BBLOCK;			! Define FAB format

BIND
    nam = .fab[fab$l_nam] : $BBLOCK;	! Define NAM block

LOCAL
    desc : VECTOR[2];			! A temporary descriptor

!
! Check to see if there's a name in the resultant string field.
! If there is, use it.
!
IF .nam[nam$b_rsl] NEQ 0
THEN
    BEGIN
    desc[0] = .nam[nam$b_rsl];
    desc[1] = .nam[nam$l_rsa];
    END

!
! If no resultant name, try the expanded name
!
ELSE IF .nam[nam$b_esl] NEQ 0
THEN
    BEGIN
    desc[0] = .nam[nam$b_esl];
    desc[1] = .nam[nam$l_esa];
    END

!
! If no expanded name, use the original name in the fab
!
ELSE
    BEGIN
    desc[0] = .fab[fab$b_fns];
    desc[1] = .fab[fab$l_fna];
    END;

!
! Signal the error
!
SIGNAL_STOP(set$_searchfail,
	    1,				! One FAO argument
	    desc,			! Which is the file name
	    .fab[fab$l_sts],		! Show RMS error code
	    .fab[fab$l_stv]);		! And secondary error code
RETURN true;
END;

ROUTINE unlock_action (fab)  =

!----
!
! Functional description
!
!	This routine is called from SET_ATTRIBUTES whenever
!	a successsful file match for /LOCK occurs
!
! Input parameters
!
!	fab = Address of block describing the file
!
! Output parameters
!
!	None
!
!----

BEGIN

MAP fab: REF $BBLOCK;			! Define fab block format

LOCAL status;				! Receives status

!
! If /CONFIRM was set by the user then interrogate him to see if 
! this file is to be unlocked
!
IF
BEGIN
    IF .setfile$flags[qual_quit_unlock]
        OR NOT .setfile$flags[qual_confirm]
    THEN true
    ELSE
	BEGIN
	status = lib$confirm_act(%ASCID 'Unlock file !AS? [N] : ',
				 %REF(conf_desc));
	IF NOT .status
	THEN
	    BEGIN
	    IF .status EQL lib$_quipro
	    THEN (setfile$flags[qual_quit] = 1; RETURN true)
	    ELSE IF .status EQL lib$_quiconact
	    THEN (setfile$flags[qual_quit_mod] = 1; status = 1)
	    ELSE IF .status NEQ lib$_negans
	    THEN SIGNAL(set$_writeerr, 1, conf_desc, .status);
	    END;
        .status
	END
    END
THEN
BEGIN

!
! Call LIB$UNLOCK_FILE to unlock the file
!

    IF NOT (status = lib$unlock_file(conf_desc))	! Call unlock with file name
    THEN
        RETURN(.status);

!
! Check to see if unlock worked.  SS$_WASSET indicates the file
! was unlocked.  SS$_WASCLR indicates the file was already unlocked
! and no other error occurred
!

    IF (.status EQL SS$_WASCLR)		! If file not locked
    THEN
        SIGNAL(set$_notlocked,1,conf_desc)
    ELSE					! File was unlocked
        IF .setfile$flags[qual_log]		!if /LOG tell user
        THEN SIGNAL(set$_unlocked,1,conf_desc);
  END;
  RETURN(true); 				! Both returns above
						!   are ok!

END;

ROUTINE setpro_action (fab): =

!----
!
! Functional description
!
!	This routine is called from SET_ATTRIBUTES whenever
!	the qualifier PROTECTION is found
!
! Input parameters
!
!	fab = Address of block describing the file
!	fab$l_nam = pointer to name block
!
! Output parameters
!
!	First error encountered, or TRUE is RETURNed
!
!----

BEGIN

MAP fab: REF $BBLOCK;			! Define fab block format

LOCAL
    p_res_mask,				! Enable-mask parameter
    p_res_prot,				! Value-mask parameter
    final_prot:	WORD,			! Receives final protection
    desc:	VECTOR[2],		! Temporary string descriptor
    status;				! Receives status


!
! If /CONFIRM was set by the user then interrogate him to see if 
! this file is to have its protection changed.
!
IF
BEGIN
    IF .setfile$flags[qual_quit_protect]
        OR NOT .setfile$flags[qual_confirm]
    THEN true
    ELSE
	BEGIN
	status = lib$confirm_act(%ASCID 'Change protection of file !AS? [N] : ',
				 %REF(conf_desc));
	IF NOT .status
	THEN
	    BEGIN
	    IF .status EQL lib$_quipro
	    THEN (setfile$flags[qual_quit] = 1; RETURN true)
	    ELSE IF .status EQL lib$_quiconact
	    THEN (setfile$flags[qual_quit_mod] = 1; status = 1)
	    ELSE IF .status NEQ lib$_negans
	    THEN SIGNAL(set$_writeerr, 1, conf_desc, .status);
	    END;
        .status
	END
    END
THEN
BEGIN

! Compute the parameters for lib$set_file_prot.  If not protection 
! value was specified set  enable-mask and value-mask to zero to 
! cause protection to be set to the process default.

p_res_mask = global_mask;
p_res_prot = global_prot;

IF .global_mask EQL 0                   ! If not protection values specified  
   THEN p_res_mask = p_res_prot = 0;    ! pass null parameters


!
! Call lib$set_file_prot to set file protection
!

IF NOT (status = lib$set_file_prot (	! Call library routine with
			conf_desc,	!  - file name
			.p_res_mask,	!  - result mask
			.p_res_prot,	!  - result protection
			final_prot))	!  - final protection returned
					!    by lib$set_file_prot
    THEN
	BEGIN
	SIGNAL  (	        	! Tell the user of error
			set$_pronotchg, !  - "Not changed" error message
			1,		!  - 1 FAO arguement
			conf_desc,	!  - descriptor of filename
			.status);	!  - original error
	return (.status);		! Return to the caller
	END;


!
! If /LOG was set then do it
!

IF (.setfile$flags[qual_log])		! If logging requested
THEN prot_log_results (.fab,.final_prot);	!  then call the logger

END;
RETURN (true);

END;

ROUTINE prot_log_results (fab,final_prot): =

!----
!
! Functional description
!
!	This routine is called from SETPRO_ACTION whenever
!	logging for /PROTECTION is requested
!
! Input parameters
!
!	fab = Address of block describing the file
!	fab$l_nam = pointer to name block
!
! Output parameters
!
!	First error encountered, or TRUE is RETURNed
!
!----

BEGIN

LITERAL
    pbufsize = 32;			! Buffer for generating string

MAP fab: REF $BBLOCK;			! Define fab block format

BIND nam = .fab[fab$l_nam]: $BBLOCK;	! Define name block

LOCAL
    status:,				! Recieves status
    pbuf:	VECTOR[pbufsize,BYTE],	! Place for protection string
    pdesc:	VECTOR[2],		! Temporary string descriptor
    desc:	VECTOR[2],		! Temporary string descriptor
    prot_table:	VECTOR[4];		! Protection string table


!
! Now build the resultant protection string from the value passed
! in the call.
!

expand_prot(				! Call sub with
	prot_table,			!  -place for the result
	.final_prot);			!  -final protection value

pdesc[0] = pbufsize;			! Initialize descriptor size
pdesc[1] = pbuf;			! Initialize descriptor address

IF NOT (status =
$FAOL	(				! Call system service with
	CTRSTR = ADDRDESC ('S:!AS,O:!AS,G:!AS,W:!AS'),	! -FAO string
	OUTLEN = pdesc[0],		!  -place for resultant length
	OUTBUF = pdesc,			!  -output buffer descriptor
	PRMLST = prot_table)		!  -address of list of args
) THEN BEGIN
	SIGNAL (.status); 		! Oops, tell the user
	return (.status);		! And exit immediately
	END;

  SIGNAL       (set$_protected,		! Inform user with
		2,			!  -two FAO arguements
		conf_desc,		!  -file name
		pdesc);			!  -new protection

RETURN (true);

END;

ROUTINE expand_prot (table, protection): =

!----
!
! Functional description
!
!	This routine, called from PROT_LOG_RESULTS, fills 
!       a given VECTOR with the addresses of strings
!	corresponding to a given protection word.
!
! Input parameters
!
!	table = Address of the table to be filled in.
!	protection = Protection word.
!
! Output parameters
!
!	table has been filled in with the addresses of descriptors
!	of strings describing each type of user (SYS,OWN,GRP,WORLD).
!
!----

BEGIN

BIND
    prot_table = .table: VECTOR[4];	! Table of addresses

OWN
    prot_values: VECTOR[16] INITIAL(	! Protection descriptions
	ADDRDESC('RWED'),
	ADDRDESC('WED'),
	ADDRDESC('RED'),
	ADDRDESC('ED'),
	ADDRDESC('RWD'),
	ADDRDESC('WD'),
	ADDRDESC('RD'),
	ADDRDESC('D'),
	ADDRDESC('RWE'),
	ADDRDESC('WE'),
	ADDRDESC('RE'),
	ADDRDESC('E'),
	ADDRDESC('RW'),
	ADDRDESC('W'),
	ADDRDESC('R'),
	ADDRDESC(''));

INCR index FROM 0 TO 3 DO
    prot_table[.index] = .prot_values [.protection<.index*4,4>];

RETURN (true);		! Always return true

END;

ROUTINE parse_class (desc) =

!---
!
! This routine called from SETPRO_ACTION, parses one class of user 
! (e.g. SYSTEM, OWNER, GROUP, WORLD) to see what protection is allowed.  
! The value returned in the low 4 bits is the protection code, with the 
! bits set to reflect that access is  requested.  Note that this is 
! exactly the opposite of what the system wants.
!
! Inputs:
!
!	DESC -- a descriptor pointing to the ASCII representation of the
!		protection desired
!
!---

BEGIN

MAP desc : REF $BBLOCK;

LOCAL
    pointer,				! Pointer to string
    result;				! Resultant protection

!
! Initially set the value to all zeros, no access
!
result = 0;

!
! Scan for the occurrence of each keyletter, and, if it is there, set the
! appropriate bit.
!
pointer = .desc[dsc$a_pointer];
INCR index FROM 1 to .desc[dsc$w_length] DO
    BEGIN
    LOCAL char : BYTE;
    char = CH$RCHAR_A(pointer);
    IF .char EQL'R'
    THEN result = .result OR %X'1'
    ELSE IF .char EQL  'W'
    THEN result = .result OR %X'2'
    ELSE IF .char EQL 'E'
    	 OR .char EQL 'P'
    THEN result = .result OR %X'4'
    ELSE IF .char EQL 'D'
    	 OR .char EQL 'L'
    THEN result = .result OR %X'8'
    ELSE SIGNAL_STOP (set$_syntax, 1, .desc);
    END;

RETURN .result;
END;

END
ELUDOM

