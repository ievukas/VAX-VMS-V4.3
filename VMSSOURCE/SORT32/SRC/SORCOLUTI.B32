MODULE COLL$UTILITIES(
		IDENT = 'V04-000'	! File: SORCOLUTI.B32 Edit: PDG3014
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:	VAX-11 SORT/MERGE
!		PDP-11 SORT/MERGE
!
! ABSTRACT:
!
!	This module contains routines that process a user-defined collating
!	sequence.
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: Peter D Gilbert, CREATION DATE: 20-Jan-1983
!
! MODIFIED BY:
!
!	T03-001		Original
!	T03-002	Add a temporary fix to get a reasonable pad character if
!		the pad character is ignored.  PDG 26-Jan-1983
!	T03-003	Support ignored pad characters.  Set ADJ to zero if there are
!		ignored characters.  PDG 28-Jan-1983
!	T03-004	Add COLL$FOLD.  PDG 31-Jan-1983
!	T03-005	Define CODE and PLIT psects.  1-Feb-1983
!	T03-006	Change the interface to SOR$$COLLATE_x.  PDG 7-Mar-1983
!	T03-007	Remove STATIC table stuff.  Changes for PDP-11 compatability.
!		PDG 5-Apr-1983
!	T03-008	Changes to simplify zapping the upper table.  PDG 12-Apr-1983
!	T03-009	Store info in RES_REVERSE (not CS_REVERSE) in COLL$RESULT.
!		The ORDER parameter to TIE_BREAK is now required.  Changed
!		value of CS_K_REG for Bliss-11.  PDG 15-Apr-1983
!	T03-010	Defined error statuses for Bliss-11.  PDG 21-Apr-1983
!	T03-011	Add routine headers.  PDG 5-Jul-1983
!	T03-012	Allocate large structures in the work area, not on the stack.
!		PDG 25-Apr-1983
!	T03-013	Merge changes from Sort-11 and Sort-32 versions.  19-Sep-1983
!	T03-014 Allocate on the stack for Sort-32.  Specify a comparison
!		routine that can be used after an initial CMPC for Sort-32
!		PDG 14-Oct-1983
!--

!++
!
! OVERVIEW:
!
!	The routines must be called in the following order:
!		INIT [ BASE ] [ NEXT | MODIFY | FOLD ]... RESULT
!	The routines PAD, TIE_BREAK and UPPER may be optionally called any
!	time after the INIT and before the RESULT.
!
!	In all of these routines, the user passes a two element vector
!	containing the length/address of a work area these routines can use.
!	The call to RESULT returns the length that is needed to store the
!	compressed version of the area.  The user can then call the routine
!	whose address is stored at the beginning of the area.  This routine is
!	passed the lengths/address of the strings, and returns:
!		-1	if String1 < String2
!		 0	if String1 = String2
!		+1	if String1 > String2
!
!	All characters are passed to these routines as a word length followed
!	by zero, one or two characters (4 bytes max).
!	The routine INIT simply initializes all characters as ignored, the pad
!	character as the null character, and no tie-breaking.
!
!	BASE defines a base collating sequence (via a 256 byte table).
!	All 256 single-byte characters are given one-byte collating values,
!	taken from the table.
!
!	NEXT specifies a character that is to get a single-byte collating value
!	that collates larger than any other currently defined collating value.
!
!	OTHERS causes NEXT to be called for all currently ignored single-byte
!	characters (similar to COBOL-style definitions).
!
!	MODIFY defines a character to collate just less than, equal to, or just
!	greater than the (0,1,or 2 byte) collating value of a (0,1,or 2 byte)
!	character string.
!
!	FOLD causes all lower case letters to be given the collating values of
!	their upper case equivalents.  If a double character that contain no
!	lower case letters is defined, then lower case and mixed case double
!	characters are defined to collate equal to this double character.
!	For example,
!		This	causes these definitions
!		"D$"	"d$"="D$"
!		"$D"	"$d"="$d"
!		"d$"	none
!		"$d"	none
!		"xy"	none
!		"Xy"	none
!		"XY"	"xy"="XY","xY"="XY","Xy"="XY"
!
!	PAD defines the (single byte) pad character.
!
!	UPPER specifies a simple (i.e., like BASE), secondary collating
!	sequence that should be applied if the primary collating sequence
!	collates two strings as equal.
!
!	TIE_BREAK specifies that, if the primary and secondary collating
!	sequences collate the strings as equal, a final comparison should be
!	done which compares the unsigned binary values of the characters in
!	the strings.
!
!	The linkage to the comparison routine is:
!	    (for VAXen):
!		JSB(
!		REGISTER=0,	! Length of String1
!		REGISTER=1,	! Address of String1
!		REGISTER=2,	! Length of String2
!		REGISTER=3,	! Address of String2
!		REGISTER=5;	! Address of table
!		REGISTER=0):	! Result of the comparison (-1, 0, +1)
!		NOPRESERVE(4,5)
!		PRESERVE(9,10)
!		NOTUSED(6,7,8,11)
!	    (for PDP-11s):
!		TBS
!	    And the condition codes reflect the setting of R0.
!
! IMPLEMENTATION:
!
!	During the definition of the collating sequence, collating values are
!	represented by two word values: <x,y>.
!		<0,0>	indicates an ignored character
!		<x,0>	indicates a single-value collating value
!		<x,y>	indicates a double-value collating value
!	The collating values for single characters are stored in a 256 element
!	array.  Double characters and their collating values are stored in
!	a sequential list at the end of the other tables.  (The UPPER table
!	is always left in byte form).
!
!	The succinct tables generated by RESULT have the form:
!	    RES$TB	A byte of flags for tie-break and upper
!	    RES$REVERSE	A byte of flags to reverse sense of tie-break CMPC
!	    RES$PAD	A byte for the pad character
!	    RES$PTAB	A 256 byte table, with a value of zero indicating
!			that the STAB table must be consulted.
!	    RES$UPPER	A 256 byte table.
!	    RES$STAB	A list of entries for double characters and characters
!			with double collating values.  If a character with a
!			value of 0 in PTAB is not found in this table, it is
!			ignored.
!
!	The flags within TB are:
!	    TB$NOTB	%B'0100'	Don't do tie-breaking (the Z-bit)
!	    TB$NOUPPER	%B'0010'	Don't use upper table (the V-bit)
!
!	The flags within REVERSE are:
!	    TB$REVERSE	%B'0001'	Reverse tie-break CMPC (the C-bit)
!
!	An entry in STAB is four bytes in length:
!	    <ch0,ch1,cv0,cv1>
!	    The ch0,ch1 together form a single or double character.
!	    The cv0,cv1 together form a single or double collating value,
!		with special forms mentioned above.
!	These entries are ordered in groups with equal ch0 values, in order
!	of increasing ch0 values.  The groups are followed by two "trailer"
!	entries:
!	    <%X'FF',%X'FF',...,...>
!	    <%X'00',%X'00',...,...>
!	Each group has the form:
!	    <x,%X'FF', collating value of x>	One of these
!	    <x,  y   , collating value of xy>	0 or more, ordered by y
!
!	The choice of this representation is succinct and allows for efficient
!	processing.  See the support routines SOR$COLLATE_0, 1 and 2 for more
!	details.
!
!--
LIBRARY	'SYS$LIBRARY:XPORT';
%IF %BLISS(BLISS32) %THEN
PSECT
	CODE=		SOR$RO_CODE(PIC,SHARE),
	PLIT=		SOR$RO_CODE(PIC,SHARE);
%FI

LITERAL
    CS_K_REG =	%IF %BLISS(BLISS32) %THEN 10 %ELSE 3 %FI;
MACRO
    LNK_CALL =	%IF %BLISS(BLISS32) %THEN CALL %ELSE JSR %FI %,
    LNK_SUBR =	%IF %BLISS(BLISS32) %THEN JSB  %ELSE JSR %FI %;
LINKAGE
    CS_LINK_0  = LNK_SUBR: GLOBAL(CS=CS_K_REG),
    CS_CALL_0  = LNK_CALL: GLOBAL(CS=CS_K_REG),
    CS_LINK_1  = LNK_SUBR(REGISTER=1): GLOBAL(CS=CS_K_REG),
    CS_LINK_2  = LNK_SUBR(REGISTER=1, REGISTER=2): GLOBAL(CS=CS_K_REG);

FORWARD ROUTINE
    D_LOOKUP:	CS_LINK_1,	! Look up a double character
    D_NEW:	CS_LINK_1,	! Create a new secondary table entry
    GIVE_COLL:	CS_LINK_2,	! Assign a collating value to a character
    DO_BUMP:	CS_LINK_1,	! Increase collating values
    COLL$INIT,			! Initialize collating sequence
    COLL$BASE,			! Define the base collating sequence
    COLL$NEXT,			! Define the next character
!   COLL$OTHERS,		! Define undefined single characters
    COLL$MODIFY,		! Make a modification
    COLL$FOLD,			! Fold upper/lower case characters
    COLL$TIE_BREAK,		! Indicate tie-breaking
    COLL$PAD,			! Indicate collating value of the pad character
    COLL$UPPER,			! Upper case comparison
    COLL_VALUE:	CS_LINK_2,	! Gets the collating value of a character
    COMPRESS:	CS_LINK_1,	! Compress the range of collating values
    COMPRESS_M:	CS_LINK_0,	! Compress the tables and set attributes
    COLL$RESULT;		! Build the final tables


! Define the error statuses returned by these routines
!
%IF %BLISS(BLISS32) %THEN

EXTERNAL LITERAL
    SOR$_COL_ADJ,
    SOR$_COL_CMPLX,
    SOR$_COL_CHAR,
    SOR$_COL_PAD,
    SOR$_COL_THREE;

BIND
    COLL$_ADJ	= SOR$_COL_ADJ,		! Invalid ADJ parameter	
    COLL$_CMPLX	= SOR$_COL_CMPLX,	! Collating sequence is too complex
    COLL$_CHAR	= SOR$_COL_CHAR,	! Invalid character definition
    COLL$_PAD	= SOR$_COL_PAD,		! Invalid pad character
    COLL$_THREE	= SOR$_COL_THREE;	! Cannot define 3-byte collating values

LITERAL
    TRUE  = 1,
    FALSE = 0;

%ELSE

LIBRARY	'S11V3SRC:SMCOM';

BIND
    COLL$_ADJ	= SOR$_SPCADJ,		! Invalid ADJ parameter	
    COLL$_CMPLX	= SOR$_WKAREA,		! Collating sequence is too complex
    COLL$_CHAR	= SOR$_SPCCHR,		! Invalid character definition
    COLL$_PAD	= SOR$_SPCPAD,		! Invalid pad character
    COLL$_THREE	= SOR$_SPCTHR;		! Cannot define 3-byte collating values

%FI


! Define the successful status returned by these routines
!
%IF NOT %DECLARED(SS$_NORMAL) %THEN LITERAL SS$_NORMAL = 1; %FI

MACRO
    IF_ERROR_( X ) = %IF %BLISS( BLISS16 ) %THEN IF X NEQ SS$_NORMAL 
    		     			   %ELSE IF NOT X %FI %;
MACRO
    CS_SETUP(PARAM) =
	%IF %NULL(PARAM)
	%THEN
	    EXTERNAL REGISTER CS = CS_K_REG: REF CS_BLOCK
	%ELSE
	    GLOBAL REGISTER CS = CS_K_REG: REF CS_BLOCK;
	    CS = .PARAM[1]
	%FI %;

%IF %DECLARED(%QUOTE ELIF ) %THEN UNDECLARE %QUOTE ELIF ; %FI
%IF %DECLARED(%QUOTE BASE_) %THEN UNDECLARE %QUOTE BASE_; %FI
MACRO
    ELIF=		ELSE IF %,
    BASE_=		0, 0,  0, 0 %;

MACRO
    MOVE_COLL_ALL_(X,Y) =
	BEGIN
	%IF %FIELDEXPAND(COLL_ALL,2) NEQ 0	
	%THEN
	    BBLOCK[X,COLL_ALL] = .BBLOCK[Y,COLL_ALL];
	%ELSE
	    BBLOCK[X,COLL_C0]  = .BBLOCK[Y,COLL_C0];
	    BBLOCK[X,COLL_C1]  = .BBLOCK[Y,COLL_C1];
	%FI
	END %;
!MACRO
!    MOVE32_(X,Y) =
!	%IF %BLISS(BLISS32)
!	%THEN X = .Y
!	%ELSE ((X) = .(Y); (X+2)=.(Y+2)) %FI %;
LITERAL
    K_CHARS = 256;		! Number of 1-byte characters

MACRO
    XBYTE =	%EXPAND $BITS(8) %,
    XWORD =	%EXPAND $BITS(16) %,
    XLONG =	%EXPAND $BITS(32) %,
    XDESC =	$SUB_BLOCK(2) %,
    XADDR =	$ADDRESS %;
$SHOW(FIELDS)

STRUCTURE
    BBLOCK[O,P,S,E;BS=0] = [BS](BBLOCK+O)<P,S,E>;

!			C H A R - B L O C K
!
! A char is an elementary data structure representing a single or double
! character.
!
$UNIT_FIELD
    CHAR_FIELDS =
	SET
	CHAR_LEN=	[XWORD],
	CHAR_C0=	[XBYTE],
	CHAR_C1=	[XBYTE],
$OVERLAY(CHAR_C0)
	CHAR_C01=	[XWORD],
$OVERLAY(0,0,0,0)
	CHAR_ALL=	[XLONG]
	TES;
LITERAL	CHAR_K_SIZE=	$FIELD_SET_UNITS;	! Size in bytes
MACRO	CHAR_BLOCK=	BBLOCK[CHAR_K_SIZE] FIELD(CHAR_FIELDS) %;

!			C O L L _ B L O C K
!
! A coll is an elementary data structure representing a single, double or
! ignored collating value.
!	<0,0>	ignored
!	<x,0>	single collating value	(x ne 0)
!	<x,y>	double collating value	(x,y ne 0)
!
$UNIT_FIELD
    COLL_FIELDS =
	SET
	COLL_C0=	[XWORD],
	COLL_C1=	[XWORD],
$OVERLAY(0,0,0,0)
	COLL_ALL=	[XLONG]
	TES;
LITERAL	COLL_K_SIZE=	$FIELD_SET_UNITS;	! Size in bytes
MACRO	COLL_BLOCK=	BBLOCK[COLL_K_SIZE] FIELD(COLL_FIELDS) %;

!			C S - B L O C K
!
! This data structure holds pertinent information between calls.
!
$UNIT_FIELD
    CS_FIELDS =
	SET
	CS_SIZE=	[XWORD],	! Size of this block
	CS_CURR_SIZE=	[XWORD],	! Current size of this block
	CS_COLL_MAX=	[XWORD],	! Largest collating value
	CS_DCHAR=	[XWORD],	! Number of double characters
	CS_TB=		[XBYTE],	! Tie-break / Upper bits
	CS_PAD=		[XBYTE],	! Pad character
	CS_REVERSE=	[XBYTE],	! Reverse sense of tie-break CMPC
	CS_MODS=	[$BIT],		! Modifications were made
	CS_IGN=		[$BIT],		! There are ignored characters
	CS_DCOLL=	[$BIT],		! There are double collating values
	$ALIGN(WORD)
!	CS_PSTATIC=	[$ADDRESS],		! Address of static base table
!	CS_USTATIC=	[$ADDRESS],		! Address of static upper table
	CS_UPPER=	[$BYTES(K_CHARS)],	! Secondary table
	CS_PTAB=	[$BYTES(K_CHARS*COLL_K_SIZE)],	! Table of single chars
	CS_STAB=	[$BYTES(0)]			! Table of double chars
	TES;
LITERAL	CS_K_SIZE=	$FIELD_SET_UNITS;	! Size in bytes
MACRO	CS_BLOCK=	BBLOCK[CS_K_SIZE] FIELD(CS_FIELDS,RES_FIELDS) %;
MACRO	CS_PTAB_(X)=	COLL_K_SIZE*(X)+%FIELDEXPAND(CS_PTAB,0),0,
			%IF COLL_K_SIZE*%BPUNIT LEQ %BPVAL
			%THEN COLL_K_SIZE*%BPUNIT %ELSE 0 %FI,0 %;

!			R E S - B L O C K
!
! This data structure holds the compressed form of the tables.
! For Bliss-11, it is defined in a library so that the structure can be known
! to the comparison routines, which are in a different overlay.
!
%IF NOT %BLISS(BLISS32) %THEN

LIBRARY 'S11V3SRC:SORCOLUTI';

%ELSE

$UNIT_FIELD
    RES_FIELDS =
	SET
	RES_RTN=	[$ADDRESS],
	RES_RTN_A=	[$ADDRESS],
	RES_TB=		[$BYTE],
	RES_PAD=	[$BYTE],
	RES_REVERSE=	[$BYTE],
	$ALIGN(WORD)
	RES_PTAB=	[$BYTES(K_CHARS)],
	RES_UPPER=	[$BYTES(K_CHARS)],
	RES_STAB=	[$BYTES(0)]
	TES;
LITERAL	RES_K_SIZE=	$FIELD_SET_UNITS;	! Size in bytes

%FI

%IF RES_K_SIZE GTR CS_K_SIZE %THEN %ERROR('Something terrible happened') %FI

! These values must be known to the macro routine
!
GLOBAL LITERAL
	RES$RTN=	%FIELDEXPAND(RES_RTN,0),
	RES$TB=		%FIELDEXPAND(RES_TB,0),
	RES$REVERSE=	%FIELDEXPAND(RES_REVERSE,0),
	RES$PAD=	%FIELDEXPAND(RES_PAD,0),
	RES$PTAB=	%FIELDEXPAND(RES_PTAB,0),
	RES$UPPER=	%FIELDEXPAND(RES_UPPER,0),
	RES$STAB=	%FIELDEXPAND(RES_STAB,0),
	TB$NOTB =	%B'0100',	! Don't do tie-breaking (the Z-bit)
	TB$NOUPPER =	%B'0010',	! Don't use upper table (the V-bit)
	TB$REVERSE =	%B'0001';	! Reverse tie-break CMPC (the C-bit)


!			S T - B L O C K
!
! A secondary table entry consists of:
!	An indication whether the input character is one or two bytes.
!	The one or two byte input character.
!	The collating value.
!	The offset to the next secondary table entry.
!
$UNIT_FIELD
    ST_FIELDS =
	SET
	ST_CHAR=	[XWORD],
	ST_COLL=	[$BYTES(COLL_K_SIZE)],
$OVERLAY(ST_CHAR)
	ST_CHAR_0=	[XBYTE],
	ST_CHAR_1=	[XBYTE]
$CONTINUE
	TES;
LITERAL	ST_K_SIZE=	$FIELD_SET_UNITS;	! Size in bytes
MACRO	ST_BLOCK=	BBLOCK[ST_K_SIZE] FIELD(ST_FIELDS) %;

! When we are inserting another collating value, but have no available
! single-byte collating values, we can:
!
!    Find two adjacent one-byte collating values (x and x+1) that:
!	are not used as the first byte of any two-byte collating values,
!	and are not used as the second byte of any two-byte collating values
!	    for which the first byte is used as a one-byte collating value.
!    Change the characters that collate to x and x+1 to collate to the two-byte
!	collating values <x,0> and <x,1>, respectively.
!    This frees the single-byte collating value x+1.
!	
! Or (preferably) we can:
!
!    Find a collating value (x) that:
!	is used only as the first byte of two-byte collating values
!	    for which not all 256 different second byte values are used,
!	it has an adjacent value y (either x-1 or x+1) such that:
!	    it is not used as the first byte of any two-byte collating values,
!	    and is not used as the second byte of any two-byte collating values
!		for which the first byte is used as a one-byte collating value.
!    Add another second-byte collating value (z) to the two-byte collating
!	values that have x as their first-byte collating value, such that z is
!	less than (y=x-1), or greater than (y=x+1) all the other second-byte
!	collating values.
!    Change the characters that collate to y to collate to <x,z>.

GLOBAL ROUTINE COLL$INIT(
	COLL_SEQ:	REF VECTOR[2]			! Collating sequence
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Initialize a collating sequence description.
!	It is initialized to all ignored characters.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The memory specified by COLL_SEQ is initialized.
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    CS_SETUP(COLL_SEQ);

    IF .COLL_SEQ[0] LSSU CS_K_SIZE THEN RETURN COLL$_CMPLX;
    CH$FILL(0, CS_K_SIZE, CS[BASE_]);
    CS[CS_SIZE] = MINU(.COLL_SEQ[0], 1^%FIELDEXPAND(CS_SIZE,2)-1);
    CS[CS_CURR_SIZE] = CS_K_SIZE;
    CS[CS_TB] = TB$NOTB OR TB$NOUPPER;

    RETURN SS$_NORMAL;
    END;

GLOBAL ROUTINE COLL$BASE(
	COLL_SEQ:	REF VECTOR[2],			! Collating sequence
	BASE_SEQ:	REF VECTOR[K_CHARS,BYTE]	! Base sequence
!	, STATIC
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Specify the base collating sequence.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	BASE_SEQ	a 256-byte array giving the (single byte) collating
!			value for each character.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	BS:	REF VECTOR[K_CHARS,BYTE];
!   BUILTIN
!	NULLPARAMETER;

    CS_SETUP(COLL_SEQ);

    BS = BASE_SEQ[0];
    DECR I FROM K_CHARS-1 TO 0 DO (CS[CS_PTAB_(.I)]) = .BS[.I] + 1;
    CS[CS_COLL_MAX] = K_CHARS;
!   IF NOT NULLPARAMETER(3) THEN CS[CS_PSTATIC] = BASE_SEQ[0];

    RETURN SS$_NORMAL;
    END;

GLOBAL ROUTINE COLL$UPPER(
	COLL_SEQ:	REF VECTOR[2],			! Collating sequence
	UPPER_SEQ:	REF VECTOR[K_CHARS,BYTE]	! Secondary sequence
!	, STATIC
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Specify the secondary collating sequence.
!	If two strings compare equal using the sequence specified with BASE,
!	SEQUENCE, MODIFY and IGNORE, the collating sequence specified by this
!	routine is then used.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	UPPER_SEQ	a 256-byte array giving the (single byte) collating
!			value for each character.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	BS:	REF VECTOR[K_CHARS,BYTE],
	X;
!   BUILTIN
!	NULLPARAMETER;

    CS_SETUP(COLL_SEQ);

    X = UPPER_SEQ[0];
    IF .X NEQ 0 THEN X = K_CHARS;
    CH$COPY(.X, UPPER_SEQ[0], 0, K_CHARS, CS[CS_UPPER]);

!   IF NOT NULLPARAMETER(3) THEN CS[CS_USTATIC] = UPPER_SEQ[0];
    CS[CS_TB] = .CS[CS_TB] AND NOT TB$NOUPPER;

    RETURN SS$_NORMAL;
    END;

GLOBAL ROUTINE COLL$NEXT(
	COLL_SEQ:	REF VECTOR[2],		! Collating sequence
	CHAR1:		REF CHAR_BLOCK		! Character being defined
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Define a character to collate greater than any currently defined
!	character.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	CHAR1		a character.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	COLL:	COLL_BLOCK;

    CS_SETUP(COLL_SEQ);

    CS[CS_MODS] = TRUE;

    CS[CS_COLL_MAX] = .CS[CS_COLL_MAX] + 1;
    COLL[COLL_C0] = .CS[CS_COLL_MAX];
    COLL[COLL_C1] = 0;
    RETURN GIVE_COLL( CHAR1[CHAR_ALL], COLL[COLL_ALL] );
    END;

%(
GLOBAL ROUTINE COLL$OTHERS(
	COLL_SEQ:	REF VECTOR[2]		! Collating sequence
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Define all currently ignored (undefined) characters to collate larger
!	than all the non-ignored (defined) characters, in order of the
!	character codes.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	CHAR:	CHAR_BLOCK,
	P:	REF COLL_BLOCK,
	S;

    CS_SETUP(COLL_SEQ);

    CS[CS_MODS] = TRUE;

    CHAR[CHAR_LEN] = 1;

    P = CS[CS_PTAB];
    INCR I FROM 0 TO K_CHARS-1 DO
	BEGIN
	IF
	    %IF %FIELDEXPAND(COLL_ALL,2) NEQ 0
	    %THEN .P[COLL_ALL] EQL 0
	    %ELSE .P[COLL_C0] EQL 0 AND .P[COLL_C1] EQL 0
	    %FI
	THEN
	    BEGIN
	    CHAR[CHAR_C0] = .I;
	    S = COLL$NEXT(COLL_SEQ[0], CHAR[BASE_]);
	    IF_ERROR_( .S ) THEN RETURN .S;
	    END;
	P = .P + COLL_K_SIZE;
	END;

    RETURN SS$_NORMAL;
    END;
)%

MACRO
    FOR_ALL_COLLS(X) =
	BEGIN
	LOCAL X: REF COLL_BLOCK;
	LOCAL STEP;
	X = CS[CS_PTAB];
	STEP = COLL_K_SIZE;
	DECR FIRST FROM 1 TO 0 DO
	    BEGIN
	    DECR I FROM (IF .FIRST THEN K_CHARS ELSE .CS[CS_DCHAR])-1 TO 0 DO
		BEGIN
	%,
    END_ALL_COLLS(X) =
		X = .X + .STEP;
		END;
	    STEP = ST_K_SIZE;
	    X = .X + %FIELDEXPAND(ST_COLL,0)
		- K_CHARS * COLL_K_SIZE
		- %FIELDEXPAND(CS_PTAB,0)
		+ %FIELDEXPAND(CS_STAB,0);
	    END;
	END %,
    FOR_ALL_DCHARS(X) =
	BEGIN
	LOCAL X: REF ST_BLOCK;
	X = CS[CS_STAB];
	DECR I FROM .CS[CS_DCHAR]-1 TO 0 DO
	    BEGIN
	%,
    END_ALL_DCHARS(X) =
	    X = .X + ST_K_SIZE;
	    END;
	END %,
    FOR_ALL_SCHARS(X) =
	BEGIN
	LOCAL X: REF COLL_BLOCK;
	X = CS[CS_PTAB];
	DECR I FROM K_CHARS-1 TO 0 DO
	    BEGIN
	%,
    END_ALL_SCHARS(X) =
	    X = .X + COLL_K_SIZE;
	    END;
	END %;

GLOBAL ROUTINE COLL$MODIFY(
	COLL_SEQ:	REF VECTOR[2],		! The collating sequence
	CHAR1:		REF CHAR_BLOCK,		! Character being defined
	CHAR2:		REF CHAR_BLOCK,		! In terms of this character
	ADJ					! Adjustment
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Modify the collating sequence.
!	Based on the value of ADJ, define CHAR1 to collate just less than (-1),
!	equal to (0), or just greater than (+1) CHAR2.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	CHAR1		the character being defined.
!
!	CHAR2		the character used to define CHAR1.
!
!	ADJ		adjustment; either -1, 0 or +1.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	COLL:	COLL_BLOCK,
	LADJ,					! Local copy of adj
	S;					! Status value

    CS_SETUP(COLL_SEQ);

    CS[CS_MODS] = TRUE;

!+
!   Define CHAR1 to collate:
!	(ADJ = -1) less than, (ADJ =  0) equal to, or (ADJ = +1) greater than
!   the character CHAR2.
!-

    ! Check that ADJ = +1, 0, or -1
    !
    LADJ = .ADJ;
    SELECTONE .LADJ OF SET [-1,0,+1]:0; [OTHERWISE]:RETURN COLL$_ADJ; TES;


    ! Set COLL to the current collating value of CHAR2
    !
    S = COLL_VALUE(CHAR2[CHAR_ALL], COLL[COLL_ALL]);
    IF_ERROR_( .S ) THEN RETURN .S;


    ! If COLL indicates an ignored character
    ! Then
    !	Check that ADJ >= 0
    !	If ADJ > 0 then set COLL to the lowest character, and ADJ to -1
    !
    IF .COLL[COLL_C0] EQL 0
    THEN
	BEGIN
	IF .LADJ LSS 0 THEN RETURN COLL$_ADJ;
	IF .LADJ GTR 0
	THEN
	    BEGIN
	    COLL[COLL_C0] = 1;		! The smallest collating value
	    COLL[COLL_C1] = 0;		! No second character
	    LADJ = -1;			! Create something even smaller
	    END;
	END;


    ! Give CHAR1 the collating value COLL
    !
    S = GIVE_COLL( CHAR1[CHAR_ALL], COLL[COLL_ALL] );
    IF_ERROR_( .S ) THEN RETURN .S;


    ! If ADJ = 0 then we are done
    !
    IF .LADJ EQL 0 THEN RETURN SS$_NORMAL;


    ! Set COLL to the current collating value of CHAR1
    !
    S = COLL_VALUE(CHAR1[CHAR_ALL], COLL[COLL_ALL]);
    IF_ERROR_( .S ) THEN RETURN .S;


    ! Bump the collating values of everything greater than or equal to the
    ! new collating value we want to give CHAR1.
    !
    IF (S = .COLL[COLL_C1]) EQL 0 THEN S = .COLL[COLL_C0];
    IF .LADJ GTR 0 THEN S = .S + 1;
    S = DO_BUMP(.S);
    IF_ERROR_( .S ) THEN RETURN .S;
    CS[CS_COLL_MAX] = .CS[CS_COLL_MAX] + 1;


    ! Set COLL to the current collating value of CHAR1
    !
    S = COLL_VALUE(CHAR1[CHAR_ALL], COLL[COLL_ALL]);
    IF_ERROR_( .S ) THEN RETURN .S;


    ! Adjust the collating value COLL, and assign it to CHAR1
    !
    IF .COLL[COLL_C1] NEQ 0
    THEN COLL[COLL_C1] = .COLL[COLL_C1] + .LADJ
    ELSE COLL[COLL_C0] = .COLL[COLL_C0] + .LADJ;
    RETURN GIVE_COLL( CHAR1[CHAR_ALL], COLL[COLL_ALL] );

    END;

GLOBAL ROUTINE COLL$FOLD(
	COLL_SEQ:	REF VECTOR[2],		! The collating sequence
	BV_L:		REF BITVECTOR[K_CHARS],	! Lower case letters
	CC					! Lower XOR .CC = Upper
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Fold characters (this is a shorthand for several calls to MODIFY).
!	For each character (X) in the set of characters specified by BV_L,
!	define it to collate equal to its change-case form (X xor CC).
!	Also, for all double characters for which neither character is in BV_L,
!	define the change-case forms to equal it.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	BV_L		the address of a 256-bit bitvector.
!
!	CC		change-case value to be xor-ed to give the other case.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	COLL:	COLL_BLOCK,
	CHAR:	CHAR_BLOCK,
	S;					! Status value

    CS_SETUP(COLL_SEQ);

    ! Define lower case letters to equal their upper case equivalents
    !
    CHAR[CHAR_LEN] = 1;
    DECR I FROM K_CHARS-1 TO 0 DO
	IF .BV_L[.I]
	THEN
	    BEGIN
	    CHAR[CHAR_C0] = .I;
	    S = GIVE_COLL( CHAR[CHAR_ALL], CS[CS_PTAB_(.I XOR .CC)] );
	    IF_ERROR_( .S ) THEN RETURN .S;
	    END;

    ! For all double characters that contain no lower case letters,
    ! and that contain upper case letters, define lower case forms.
    !
    CHAR[CHAR_LEN] = 2;
    FOR_ALL_DCHARS(ST)
	IF  NOT .BV_L[.ST[ST_CHAR_0]] AND
	    NOT .BV_L[.ST[ST_CHAR_1]]
	THEN
	    BEGIN
	    CHAR[CHAR_C01] = .ST[ST_CHAR];
	    IF .BV_L[.ST[ST_CHAR_0] XOR .CC]
	    THEN
		BEGIN
		CHAR[CHAR_C0] = .CHAR[CHAR_C0] XOR .CC;
		S = GIVE_COLL( CHAR[CHAR_ALL], ST[ST_COLL] );
		IF_ERROR_( .S ) THEN RETURN .S;
		IF .BV_L[.ST[ST_CHAR_1] XOR .CC]
		THEN
		    BEGIN
		    CHAR[CHAR_C1] = .CHAR[CHAR_C1] XOR .CC;
		    S = GIVE_COLL( CHAR[CHAR_ALL], ST[ST_COLL] );
		    IF_ERROR_( .S ) THEN RETURN .S;
		    CHAR[CHAR_C0] = .CHAR[CHAR_C0] XOR .CC;
		    S = GIVE_COLL( CHAR[CHAR_ALL], ST[ST_COLL] );
		    IF_ERROR_( .S ) THEN RETURN .S;
		    END;
		END
	    ELIF .BV_L[.ST[ST_CHAR_1] XOR .CC]
	    THEN
		BEGIN
		CHAR[CHAR_C1] = .CHAR[CHAR_C1] XOR .CC;
		S = GIVE_COLL( CHAR[CHAR_ALL], ST[ST_COLL] );
		IF_ERROR_( .S ) THEN RETURN .S;
		END;
	    END;
    END_ALL_DCHARS(ST);

    RETURN SS$_NORMAL;
    END;

ROUTINE GIVE_COLL(
	CHAR:	REF CHAR_BLOCK,
	COLL:	REF COLL_BLOCK
	):	CS_LINK_2 =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Set CHAR to the collating value COLL
!
! FORMAL PARAMETERS:
!
!	CHAR		a character to be defined
!
!	COLL		a collating value to assign to CHAR
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	TEMP:	REF COLL_BLOCK;

    CS_SETUP();

    CASE .CHAR[CHAR_LEN] FROM 1 TO 2 OF
	SET
	[1]:
	    BEGIN
	    MOVE_COLL_ALL_( CS[CS_PTAB_(.CHAR[CHAR_C0])], COLL[COLL_ALL] );
	    END;
	[2]:
	    BEGIN
	    TEMP = D_LOOKUP(.CHAR[CHAR_C01]);
	    IF .TEMP EQL 0
	    THEN
		TEMP = D_NEW(.CHAR[CHAR_C01]);
	    IF .TEMP EQL 0 THEN RETURN COLL$_CMPLX;
	    MOVE_COLL_ALL_( TEMP[COLL_ALL], COLL[COLL_ALL] );
	    END;
	[INRANGE, OUTRANGE]: RETURN COLL$_CHAR;
	TES;
    RETURN SS$_NORMAL;
    END;

ROUTINE COLL_VALUE(
	CHAR:		REF CHAR_BLOCK,		! Character to look up
	COLL:		REF COLL_BLOCK		! Collating value (output)
	): CS_LINK_2 =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Look up the collating value of a characetr.
!
! FORMAL PARAMETERS:
!
!	CHAR		a character who's collating value is to be found
!
!	COLL		where CHAR's collating value is to be stored
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	TEMP:	COLL_BLOCK,
	P:	REF COLL_BLOCK;

    CS_SETUP();

    CASE .CHAR[CHAR_LEN] FROM 0 TO 2 OF
	SET

	[2]:
	    BEGIN

	    ! See whether this double character is defined
	    !
	    P = D_LOOKUP(.CHAR[CHAR_C01]);
	    IF .P NEQ 0
	    THEN
		BEGIN
		MOVE_COLL_ALL_( COLL[COLL_ALL], P[COLL_ALL] );
		RETURN SS$_NORMAL;
		END;

	    ! Take the concatenation of the collating values of
	    ! the two single characters.
	    !
	    MOVE_COLL_ALL_( COLL[COLL_ALL], CS[CS_PTAB_(.CHAR[CHAR_C0])] );
	    MOVE_COLL_ALL_( TEMP[COLL_ALL], CS[CS_PTAB_(.CHAR[CHAR_C1])] );
	    IF .COLL[COLL_C0] EQL 0
	    THEN
		MOVE_COLL_ALL_( COLL[COLL_ALL], TEMP[COLL_ALL] )
	    ELIF .COLL[COLL_C1] EQL 0
	    THEN
	        BEGIN
		COLL[COLL_C1] = .TEMP[COLL_C0];
		IF .TEMP[COLL_C1] NEQ 0 THEN RETURN COLL$_THREE;
		END
	    ELSE
		IF .TEMP[COLL_C0] NEQ 0 THEN RETURN COLL$_THREE;
	    RETURN SS$_NORMAL;
	    END;
	[1]:
	    BEGIN
	    MOVE_COLL_ALL_( COLL[COLL_ALL], CS[CS_PTAB_(.CHAR[CHAR_C0])] );
	    RETURN SS$_NORMAL;
	    END;
	[0]:
	    BEGIN
	    COLL[COLL_C0] = 0;
	    COLL[COLL_C1] = 0;
	    RETURN SS$_NORMAL;
	    END;
	[INRANGE,OUTRANGE]:
	    RETURN COLL$_CMPLX;

	TES;
	
    END;

GLOBAL ROUTINE COLL$TIE_BREAK(			! Indicate tie-breaking
	COLL_SEQ:	REF VECTOR[2],
	ORDER					! Ascending/Descending flag
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Indicates that a tie-breaking comparison should be done to distinguish
!	records that compare equal with the primary and secondary comparisons.
!	This tie-breaking comparison is a simple binary string compare.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	ORDER		indicates whether the simple comparison part of the
!			tie-breaking should be:
!			In the normal order	(ORDER = FALSE) or
!			In the opposite order	(ORDER = TRUE).
!
!	This distinction is important for DEC STD 169, which places lower case
!	letters before their upper case equivalents.  It is unrelated to whether
!	the keys are ascending or descending.
!
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    CS_SETUP(COLL_SEQ);

    CS[CS_TB] = .CS[CS_TB] AND NOT TB$NOTB;
    
    IF .ORDER
    THEN
	CS[CS_REVERSE] = .CS[CS_REVERSE] OR TB$REVERSE;

    RETURN SS$_NORMAL;
    END;

GLOBAL ROUTINE COLL$PAD(
	COLL_SEQ:	REF VECTOR[2],		! The collating sequence
	PAD:		REF CHAR_BLOCK		! Pad character
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Specifies a pad character to be used in comparisons of strings with
!	different lengths.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	PAD		the pad character.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
! NOTES:
!
!	Assertion:
!		The purpose of a pad character is to allow strings of different
!		lengths to compare equal.
!	Therefore:
!		There is no reason to have a different pad character for the
!		tie-break.
!	Also:
!		It is unreasonable for the pad character to be ignored.
!		It is unreasonable for the pad character to be the second
!		character of a double character.
!
!-
    BEGIN

    CS_SETUP(COLL_SEQ);

    IF .PAD[CHAR_LEN] NEQ 1 THEN RETURN COLL$_PAD;
    CS[CS_PAD] = .PAD[CHAR_C0];
    RETURN SS$_NORMAL;

    END;

ROUTINE DO_BUMP(X: WORD): CS_LINK_1 =		! Bump collating values >= X

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Create an unused collating value by increasing all collating values
!	that are greater than or equal to X.
!
! FORMAL PARAMETERS:
!
!	X		a (single) collating value, passed as a word.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    MACRO
	BUMP_(Z) = IF .Z GEQ .X THEN Z = .Z + 1 ELSE 0 %;

    CS_SETUP();

    FOR_ALL_COLLS(P)
	BUMP_(P[COLL_C0]);
	BUMP_(P[COLL_C1]);
    END_ALL_COLLS(P);
    RETURN SS$_NORMAL;
    END;

ROUTINE D_NEW(X: WORD): CS_LINK_1 =		! Get space for new double char

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get space for the new double character specified by X, and return the
!	address in which its collating value will be stored.
!
! FORMAL PARAMETERS:
!
!	X		a (double) character, passed as a word.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The address in which the collating value will be stored,
!	Or zero if no more space is available.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	P: REF ST_BLOCK;
    CS_SETUP();
    P = .CS[CS_CURR_SIZE] + ST_K_SIZE;
    IF .P GTRU .CS[CS_SIZE] THEN RETURN 0;	! No more storage!
    CS[CS_CURR_SIZE] = .P;
    CS[CS_DCHAR] = .CS[CS_DCHAR] + 1;
    P = .P + CS[BASE_] - ST_K_SIZE;
    P[ST_CHAR] = .X;
    RETURN P[ST_COLL];
    END;

ROUTINE D_LOOKUP(X: WORD): CS_LINK_1 =		! Look up a double character

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get the collating value for a double character.
!
! FORMAL PARAMETERS:
!
!	X		a (double) character, passed as a word.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The address of the collating value,
!	Or zero if the double character is undefined.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    CS_SETUP();

    FOR_ALL_DCHARS(ST)
	IF .ST[ST_CHAR] EQL .X THEN RETURN ST[ST_COLL];
    END_ALL_DCHARS(ST);

    RETURN 0;
    END;

! To compress the range of collating values, we must determine what values
! are currently in use.  In practice, we will determine which of the values
! 1..MAX_USED-1 are in use, and whether any larger values are in use.
! Unused values are freed, and larger values are decreased; repeat as needed.
! If more that 2*K_CHARS distinct values are in use, it would be almost
! impossible to "double-up" sufficent values to fit things in a byte, and
! certainly not by this code.
!
LITERAL
    MAX_USED = 2 * K_CHARS;

ROUTINE COMPRESS
	(
	S_BV: REF BITVECTOR[MAX_USED]
	): CS_LINK_1 =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Reduce the range of collating values in use by simply accounting for
!	unused collating values.
!
! FORMAL PARAMETERS:
!
!	S_BV		bitvector (output parameter)
!			each bit indicates whether the corresponding collating
!			value is in use.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	S_BV_O, 
	USED:	%BLISS16(REF) VECTOR[MAX_USED,WORD],
	FREED;

    MACRO SET_BV_(VAL) = IF .VAL LSSU MAX_USED THEN S_BV[.VAL] = TRUE ELSE 0 %;
    MACRO DEC_BV_(VAL) = IF .VAL LSSU MAX_USED THEN VAL = .USED[.VAL]
			ELSE (VAL = .VAL - .FREED; S_BV_O = FALSE) %;

    CS_SETUP();

    ! Allocate the USED vector in the work area
    !
    %IF %BLISS(BLISS16) %THEN
    USED = .CS[CS_CURR_SIZE] + %SIZE(VECTOR[MAX_USED,WORD]);
    IF .USED GTRU .CS[CS_SIZE] THEN RETURN COLL$_CMPLX;
    USED = .USED + CS[BASE_] - %SIZE(VECTOR[MAX_USED,WORD]);
    %FI


    ! Use as few distinct collating values as possible
    !	(without converting single to double or double to single).
    !
    USED[0] = 0;
    WHILE TRUE DO
	BEGIN
	LOCAL
	    VAL;

	! Determine which old collating values are being used
	!
	DECR I FROM MAX_USED/%BPVAL-1 TO 0 DO (S_BV[0]+(.I*%UPVAL)) = 0;
	%IF (MAX_USED - MAX_USED/%BPVAL*%BPVAL) NEQ 0 %THEN %ERROR('') %FI
	FOR_ALL_COLLS(P)
	    SET_BV_(P[COLL_C0]);
	    SET_BV_(P[COLL_C1]);
	END_ALL_COLLS(P);

	! Compute the new collating values
	!
	FREED = 0;
	VAL = 0;
	INCR I FROM 1 TO MINU(MAX_USED-1, .CS[CS_COLL_MAX]) DO
	    BEGIN
	    IF .S_BV[.I]
	    THEN USED[.I] = VAL = .VAL + 1
	    ELSE FREED = .FREED + 1;
	    END;

	! Now convert to the new collating values
	!
	S_BV_O = TRUE;
	FOR_ALL_COLLS(P)
	    DEC_BV_(P[COLL_C0]);
	    DEC_BV_(P[COLL_C1]);
	END_ALL_COLLS(P);
	CS[CS_COLL_MAX] = .CS[CS_COLL_MAX] - .FREED;

	! Continue?
	!
	IF .S_BV_O THEN EXITLOOP;			! We got everything
	IF .FREED EQL 0 THEN RETURN COLL$_CMPLX;	! Can't do any more

	END;

    RETURN SS$_NORMAL;
    END;

ROUTINE COMPRESS_M: CS_LINK_0 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Convert the collating sequence to the efficient and succint form that's
!	used by the comparison routines.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	BV:	BITVECTOR[MAX_USED],
	NEED,
	S;					! Status value

    CS_SETUP();

    !+
    ! We are going to mash this collating sequence down to size.
    !-

    ! First, check that the pad character isn't used in any double characters,
    ! and that it collates to a single byte collating value.
    !
    FOR_ALL_DCHARS(ST)
	IF .ST[ST_CHAR_0] EQL .CS[CS_PAD]
	OR .ST[ST_CHAR_1] EQL .CS[CS_PAD] THEN RETURN COLL$_PAD;
    END_ALL_DCHARS(ST);
    IF .BBLOCK[CS[CS_PTAB_(.CS[CS_PAD])],COLL_C1] NEQ 0 THEN RETURN COLL$_PAD;


    ! Use fewer collating values
    !
    S = COMPRESS(BV[0]);
    IF_ERROR_( .S ) THEN RETURN .S;


    ! Determine some attributes.
    !	Are there any ignored collating values.
    !	Are there any double collating values.
    !
    FOR_ALL_COLLS(P)
	IF .P[COLL_C0] EQL 0 THEN CS[CS_IGN] = TRUE;
	IF .P[COLL_C1] NEQ 0 THEN CS[CS_DCOLL] = TRUE;
    END_ALL_COLLS(P);


    ! A double character <i0,i1> with double collating value <c0,c1> can
    ! be deleted if:
    !	The collating value of <i0,0> is <c0,0>, and
    !	The collating value of <i1,0> is <c1,0>, and
    !	There are no double characters of the form: <i1,z>
    !
    0;


    ! Determine whether to convert single collating values to double,
    ! Or to convert double to single.
    !
    NEED = .CS[CS_COLL_MAX] - K_CHARS;

    ! If we already have double collating values or double characters,
    ! there's not much harm in creating one more to create a free collating
    ! value.  This is advantageous in the comparison routine; also necessary,
    ! since 0 will be used to indicate a specicial character.
    !
    IF .CS[CS_DCOLL] OR .CS[CS_DCHAR] GTR 0 THEN NEED = .NEED + 1;

    ! Recall that, on entry to this block, bv[x] indicates that
    ! the collating value is in use.
    !
    IF .NEED GTR 0
    THEN
	BEGIN
	!
	! Convert single to double
	!
	! Find a sequence of adjacent (single) collating values that
	! are not used in a double collating value.
	! Convert characters with these collating values to have double
	! collating values.
	!
	LOCAL
	    CHAR: CHAR_BLOCK,
	    S, Q;
	FOR_ALL_COLLS(P)
	    IF .P[COLL_C1] NEQ 0
	    THEN
		BEGIN
		BV[.P[COLL_C0]] = FALSE;
		BV[.P[COLL_C1]] = FALSE;
		END;
	END_ALL_COLLS(P);
	BV[.BBLOCK[CS[CS_PTAB_(.CS[CS_PAD])],COLL_C0]] = FALSE;
	BV[0] = FALSE;

	! Now we know what single collating values are available
	!
	CHAR[CHAR_LEN] = 1;
	Q = .CS[CS_COLL_MAX]+1;
	WHILE .NEED GTR 0 DO
	    BEGIN
	    WHILE (Q=.Q-1) GEQ 0 DO IF .BV[.Q] THEN EXITLOOP;
	    IF (S=.Q) LEQ 0 THEN RETURN COLL$_CMPLX;
	    WHILE .BV[(Q=.Q-1)] DO 0;
	    IF .S-.Q-1 GTR 0
	    THEN
		BEGIN

		IF .S-.Q-1 GTR K_CHARS-1 THEN Q = .S-K_CHARS;
		NEED = .NEED - (.S-.Q-1);
		IF .NEED LSS 0 THEN Q = .Q - .NEED;

		FOR_ALL_COLLS(P)
		    IF
			%IF %FIELDEXPAND(COLL_ALL,2) NEQ 0
			%THEN	.P[COLL_ALL] GTR .Q AND .P[COLL_ALL] LEQ .S
			%ELSE	.P[COLL_C1] EQL 0 AND
				.P[COLL_C0] GTR .Q AND .P[COLL_C0] LEQ .S
			%FI
		    THEN
			BEGIN
			P[COLL_C1] = .P[COLL_C0] - .Q;
			P[COLL_C0] = .S;
			END;
		END_ALL_COLLS(P);

		END;
	    END;

	S = COMPRESS(BV[0]);
	IF_ERROR_( .S ) THEN RETURN .S;

	END
    ELSE
	BEGIN
	!
	! Try converting double to single
	!
	! We can convert a double collating values <x,y> to a single collating
	! value if either:
	! There are no collating values of the form: <x,0> or <z,x>, or
	! There are no collating values of the form: <y,0> or <y,z>.
	! And (additionally), of double collating values of the form: <x,z>,
	! <x,y> has the y with the largest (or smallest) value.
	!
	0;
	END;

    ! Check that the pad character is not the second character of a double
    ! character.
    !
    0;

    RETURN SS$_NORMAL;
    END;

! Debugging routines
!
%IF %SWITCHES(DEBUG)
%THEN
LINKAGE
    CALL = CALL;
%IF %BLISS(BLISS16) %THEN
    MACRO
	DELTA_BEGIN = DEL_BEGIN %,
	DELTA_END   = DEL_END   %;
%FI
EXTERNAL ROUTINE
    DELTA_BEGIN:	CALL,
    DELTA:		CALL,
    DELTA_END:		CALL,
    SOR$$OUTPUT:	CALL;
MACRO
    D_(X) = UPLIT(%CHARCOUNT(X),UPLIT BYTE(X)) %,
    OUT_(X)[] = SOR$$OUTPUT(D_(X) %IF %LENGTH GTR 1 %THEN ,%REMAINING %FI) %;

ROUTINE OUT_PT_1(I,C0,C1): NOVALUE =
    OUT_('!XB(!AF)  C0=!XW, C1=!XW',
	.I, 1, I, .C0, .C1);
ROUTINE OUT_PT_2: NOVALUE = OUT_('  ...');

GLOBAL ROUTINE COLL_DUMP(ADJ): CS_CALL_0 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Dump the current (uncompressed) collating sequence definition.
!
! FORMAL PARAMETERS:
!
!	ADJ	(optional) adjustment to be used when writing the "%X" form
!		of the primary table.  For collating sequences with no ignored
!		or double characters, this should be specified as -1, so that
!		the dump can be used in a compilation.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!	CS is specified as a global register.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    CS_SETUP();

    OUT_(%STRING(
	'SIZE=!XW, CURR_SIZE=!XW, COLL_MAX=!XW, TB=!UB, ',
	'DCHAR=!XW, PAD=!XB'),
	.CS[CS_SIZE],
	.CS[CS_CURR_SIZE],
	.CS[CS_COLL_MAX],
	.CS[CS_TB],
	.CS[CS_DCHAR],
	.CS[CS_PAD]);
    OUT_(%STRING(
	'MODS=!UB, IGN=!UB, DCOLL=!UB!/PTAB:'),
	.CS[CS_MODS],
	.CS[CS_IGN],
	.CS[CS_DCOLL]);
!	cs_pstatic=	[$address],		! Address of static base table
!	cs_ustatic=	[$address],		! Address of static upper table
!	cs_upper=	[$bytes(k_chars)],	! Secondary table

    DELTA_BEGIN(%B'1111',OUT_PT_1,OUT_PT_2);
    INCR I FROM 0 TO K_CHARS-1 DO
	BEGIN
	LOCAL P: REF COLL_BLOCK;
	P = CS[CS_PTAB_(.I)];
	DELTA(.I, .P[COLL_C0], .P[COLL_C1]);
	END;
    DELTA_END();

    OUT_('ST:');
    FOR_ALL_DCHARS(ST)
	OUT_('!XW(!AF)  C0=!XW, C1=!XW',
	    .ST[ST_CHAR],
	    2, ST[ST_CHAR],
	    .BBLOCK[ST[ST_COLL], COLL_C0],
	    .BBLOCK[ST[ST_COLL], COLL_C1]);
    END_ALL_DCHARS(ST);

    INCR I FROM 0 TO K_CHARS/8-1 DO
	BEGIN
	STRUCTURE COLL_VECTOR[I] = [](COLL_VECTOR+I*COLL_K_SIZE)<0,%BPVAL,0>;
	LOCAL P: REF COLL_VECTOR;
	P = CS[CS_PTAB_(8*.I)];
	OUT_(%STRING(
	    '%x''!XB'',%x''!XB'',%x''!XB'',%x''!XB'',',
	    '%x''!XB'',%x''!XB'',%x''!XB'',%x''!XB'','),
	    .P[0]+.ADJ, .P[1]+.ADJ, .P[2]+.ADJ, .P[3]+.ADJ,
	    .P[4]+.ADJ, .P[5]+.ADJ, .P[6]+.ADJ, .P[7]+.ADJ);
	END;

    RETURN SS$_NORMAL;
    END;
%FI

GLOBAL ROUTINE COLL$RESULT(
	COLL_SEQ:	REF VECTOR[2],		! The collating sequence
	RESLEN:		REF VECTOR[1]		! Returned length
	) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Compress the collating sequence for storage and use by the comparison
!	routines.
!
! FORMAL PARAMETERS:
!
!	COLL_SEQ	a two-longword array specifying the length/address
!			of storage to use for the collating sequence.
!
!	RESLEN		a word (output parameter) into which the length of the
!			compressed collating sequence description is written.
!			Thus, only RESLEN bytes of the storage specified by
!			COLL_SEQ needs to be saved.
!
! IMPLICIT INPUTS:
!
!	INIT must have already been called.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	ADJ,
	TAB:	%BLISS16(REF) VECTOR[K_CHARS, BYTE],
	UPP:	%BLISS16(REF) VECTOR[K_CHARS, BYTE],
	NEWS_P:	REF VECTOR[,WORD];
    MACRO
	NEWS_(X,Y) =
	    BEGIN
	    NEWS_P[0] = X; NEWS_P = NEWS_P[1];
	    %IF %NULL(Y)
	    %THEN
		NEWS_P[0] = 0; NEWS_P = NEWS_P[1]
	    %ELSE
		CH$WCHAR_A(.BBLOCK[Y, COLL_C0], NEWS_P);
		CH$WCHAR_A(.BBLOCK[Y, COLL_C1], NEWS_P);
	    %FI
	    END %;
    MACRO
	RES_STAB_TMP = CS_UPPER %;

    %IF %BLISS(BLISS32)
    %THEN
	EXTERNAL ROUTINE
	    SOR$$COLLATE_0:	ADDRESSING_MODE(LONG_RELATIVE),
	    SOR$$COLLATE_1:	ADDRESSING_MODE(LONG_RELATIVE),
	    SOR$$COLLATE_2:	ADDRESSING_MODE(LONG_RELATIVE),
	    SOR$$COLLATE_0_A:	ADDRESSING_MODE(LONG_RELATIVE),
	    SOR$$COLLATE_1_A:	ADDRESSING_MODE(LONG_RELATIVE)
    %ELSE
	! Because of overlay structure, Sort-11 has to resolve the
	! addresses on the fly
	!
	BIND
	    SOR$$COLLATE_0 = 0,
	    SOR$$COLLATE_1 = 1,
	    SOR$$COLLATE_2 = 2
    %FI;

    CS_SETUP(COLL_SEQ);

    ! Compress the tables
    !
    BEGIN LOCAL STATUS;
    STATUS = COMPRESS_M();
    IF_ERROR_( .STATUS ) THEN RETURN .STATUS;
    END;

    ! Compute the adjustment
    ! This is 1, unless we have: double characters or double collating values
    ! or ignored characters, in which case it is zero.
    ! If the adjustment is zero, we will use a zero in the primary table to
    ! indicate that the secondary table must be used.
    !
    ADJ = 1;
    IF .CS[CS_DCOLL] OR .CS[CS_IGN] OR .CS[CS_DCHAR] GTR 0 THEN ADJ = 0;

    %IF %SWITCHES(DEBUG)
    %THEN
	COLL_DUMP(-.ADJ);
    %FI

    ! Allocate the TAB and UPP tables in the work area
    !
    %IF %BLISS(BLISS16) %THEN
    TAB = .CS[CS_CURR_SIZE] + 2 * %SIZE(VECTOR[K_CHARS, BYTE]);
    IF .TAB GTRU .CS[CS_SIZE] THEN RETURN COLL$_CMPLX;
    CS[CS_CURR_SIZE] = .TAB;
    TAB = .TAB + CS[BASE_] - 2 * %SIZE(VECTOR[K_CHARS, BYTE]);
    UPP = .TAB + %SIZE(VECTOR[K_CHARS, BYTE]);
    %FI

    ! First, compute the primary table (into tab)
    !
    CH$FILL(0, K_CHARS, TAB[0]);
    BEGIN
    LOCAL P: REF COLL_BLOCK;
    P = CS[CS_PTAB] + (K_CHARS-1) * COLL_K_SIZE;
    DECR I FROM K_CHARS-1 TO 0 DO
	BEGIN
	IF .P[COLL_C1] EQL 0 THEN TAB[.I] = .P[COLL_C0] - .ADJ;
	P = .P - COLL_K_SIZE;
	END;
    END;
    FOR_ALL_DCHARS(ST)
	TAB[.ST[ST_CHAR_0]] = 0;
    END_ALL_DCHARS(ST);


    ! Copy the upper table
    !
    CH$MOVE(K_CHARS, CS[CS_UPPER], UPP[0]);

    ! Don't bother using silly upper tables.
    !
    IF CH$EQL(0, UPP[0], K_CHARS, UPP[0], .UPP[0])
    THEN
	CS[CS_TB] = .CS[CS_TB] OR TB$NOUPPER;


    ! Order the entries in the cs_stab table by the character codes.
    ! This is needed if there are several double characters with the
    ! same first character.  Note that the entry with the smallest value
    ! must be the first one accessed by the for_all_dchars macro.
    ! This code depends on the for_all_dchars macro accessing the entries
    ! in order from lower addresses to higher addresses.
    !
    BEGIN
    MACRO
	SWAP_(X,Y) = (T = .X; X = .Y; Y = .T) %,
	SWAP_ST_(X,Y) =
	    BEGIN
	    LOCAL T;
	    SWAP_(X[ST_CHAR], Y[ST_CHAR]);
	    %IF %FIELDEXPAND(ST_COLL,2) NEQ 0
	    %THEN
		SWAP_(X[ST_COLL], Y[ST_COLL]);
	    %ELSE
		SWAP_(BBLOCK[X[ST_COLL],COLL_C0],BBLOCK[Y[ST_COLL],COLL_C0]);
		SWAP_(BBLOCK[X[ST_COLL],COLL_C1],BBLOCK[Y[ST_COLL],COLL_C1]);
	    %FI
	    END %;
    LOCAL
	ST_MIN:	REF ST_BLOCK,
	ST_1:	REF ST_BLOCK,
	ST_2:	REF ST_BLOCK;
    ST_1 = CS[CS_STAB];
    DECR I FROM .CS[CS_DCHAR]-1 TO 1 DO
	BEGIN
	ST_MIN = ST_1[BASE_];
	ST_2 = ST_1[BASE_];
	DECR J FROM .I-1 TO 0 DO
	    BEGIN
	    ST_2 = .ST_2 + ST_K_SIZE;
	    IF .ST_2[ST_CHAR] LSSU .ST_MIN[ST_CHAR] THEN ST_MIN = ST_2[BASE_];
	    END;
	SWAP_ST_(ST_MIN, ST_1);
	ST_1 = .ST_1 + ST_K_SIZE;
	END;
    END;

    ! Now compute the secondary table
    !
    ! We compute it to cover the cs_upper table.
    ! It may extend far enough to cover the cs_ptab table, but we should
    ! always be ahead, unless there are more than k_chars double characters.
    !
    NEWS_P = CS[RES_STAB_TMP];
    IF .ADJ EQL 0
    THEN
	BEGIN
	!
	! This must be an incr loop
	!
	INCR PT_IDX FROM 0 TO K_CHARS-1 DO IF .TAB[.PT_IDX] EQL 0 THEN
	    BEGIN
	    LOCAL
		ENTRY;
	    ENTRY = FALSE;
	    IF
		%IF %FIELDEXPAND(COLL_ALL,2) NEQ 0
		%THEN .CS[CS_PTAB_(.PT_IDX)] NEQ 0
		%ELSE
		    BEGIN
		    LOCAL P: REF COLL_BLOCK;
		    P = CS[CS_PTAB_(.PT_IDX)];
		    .P[COLL_C0] NEQ 0 OR .P[COLL_C1] NEQ 0
		    END
		%FI
	    THEN
		BEGIN
		NEWS_(%X'FF00'+.PT_IDX, CS[CS_PTAB_(.PT_IDX)]);
		ENTRY = TRUE;
		END;
	    FOR_ALL_DCHARS(ST)
		IF .ST[ST_CHAR_0] EQL .PT_IDX<0,8,0>
		THEN
		    BEGIN
		    IF NOT .ENTRY
		    THEN
			NEWS_(%X'FF00'+.PT_IDX, CS[CS_PTAB_(.PT_IDX)]);
		    ENTRY = TRUE;
		    NEWS_(.ST[ST_CHAR], ST[ST_COLL]);
		    END;
	    END_ALL_DCHARS(ST);
	    END;
	NEWS_(%X'FFFF');
	NEWS_(%X'0000');
	END;


    ! Store the tables, values, and the address of the routine to use
    !
    BEGIN
    LOCAL
	TMP,
	SAVE: VECTOR[3,BYTE];
    TMP = NEWS_P[0] - CS[RES_STAB_TMP];
    RESLEN[0] = %FIELDEXPAND(RES_STAB,0) + .TMP;
    IF .RESLEN[0] GTRU .CS[CS_SIZE] 
    	%BLISS16( OR CS[RES_STAB_TMP]+.TMP GTRA TAB[0])
    THEN
	RETURN COLL$_CMPLX;
    SAVE[0] = .CS[CS_TB];
    SAVE[1] = .CS[CS_PAD];
    SAVE[2] = .CS[CS_REVERSE];
    CS[RES_RTN] =
	(IF .ADJ NEQ 0 THEN SOR$$COLLATE_0
	ELIF .CS[CS_DCHAR] EQL 0 THEN SOR$$COLLATE_1
	ELSE SOR$$COLLATE_2);
    %IF %BLISS(BLISS32) %THEN
    CS[RES_RTN_A] =
	(IF .ADJ NEQ 0 THEN SOR$$COLLATE_0_A
	ELIF .CS[CS_DCHAR] EQL 0 THEN SOR$$COLLATE_1_A
	ELSE 0);
    %FI
    CH$MOVE(.TMP, CS[RES_STAB_TMP], CS[RES_STAB]);
    CH$MOVE(K_CHARS, UPP[0], CS[RES_UPPER]);
    CH$MOVE(K_CHARS, TAB[0], CS[RES_PTAB]);
    CS[RES_TB] = .SAVE[0];
    CS[RES_PAD] = .SAVE[1];
    CS[RES_REVERSE] = .SAVE[2];
    END;

    RETURN SS$_NORMAL;
    END;

END
ELUDOM
